head	1.9;
access;
symbols
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	v10_2_9:1.1.1.7
	v10_4_3:1.1.1.6
	v10_2_7:1.1.1.5
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.4
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.3
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2015.12.23.05.17.49;	author jsg;	state dead;
branches;
next	1.8;
commitid	TnlogFl9nOv2eaRf;

1.8
date	2015.02.20.23.09.58;	author jsg;	state Exp;
branches;
next	1.7;
commitid	4ry2gvZGMXkCUD2n;

1.7
date	2015.01.25.14.41.20;	author jsg;	state Exp;
branches;
next	1.6;
commitid	mcxB0JvoI9gTDYXU;

1.6
date	2014.09.07.15.20.07;	author jsg;	state Exp;
branches;
next	1.5;
commitid	7kimTMT4YlQauAIU;

1.5
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2014.01.19.03.13.15;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2013.09.05.14.04.18;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.17.13.58.15;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.23.13.29.36;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.36;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.15.32;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.01.19.03.04.26;	author jsg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.07.09.20.34.50;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.5
date	2014.09.07.15.06.06;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	dm8VnQHhowGHmemJ;

1.1.1.6
date	2015.01.25.14.11.37;	author jsg;	state Exp;
branches;
next	1.1.1.7;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.7
date	2015.02.20.22.48.43;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.9
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright Â© 2010 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * Authors:
 *    Eric Anholt <eric@@anholt.net>
 *
 */

#pragma once

#include "brw_shader.h"

extern "C" {

#include <sys/types.h>

#include "main/macros.h"
#include "main/shaderobj.h"
#include "main/uniforms.h"
#include "program/prog_parameter.h"
#include "program/prog_print.h"
#include "program/prog_optimize.h"
#include "program/register_allocate.h"
#include "program/sampler.h"
#include "program/hash_table.h"
#include "brw_context.h"
#include "brw_eu.h"
#include "brw_wm.h"
#include "brw_shader.h"
}
#include "gen8_generator.h"
#include "glsl/glsl_types.h"
#include "glsl/ir.h"

#define MAX_SAMPLER_MESSAGE_SIZE 11

class bblock_t;
namespace {
   struct acp_entry;
}

namespace brw {
   class fs_live_variables;
}

class fs_reg {
public:
   DECLARE_RALLOC_CXX_OPERATORS(fs_reg)

   void init();

   fs_reg();
   fs_reg(float f);
   fs_reg(int32_t i);
   fs_reg(uint32_t u);
   fs_reg(struct brw_reg fixed_hw_reg);
   fs_reg(enum register_file file, int reg);
   fs_reg(enum register_file file, int reg, uint32_t type);
   fs_reg(class fs_visitor *v, const struct glsl_type *type);

   bool equals(const fs_reg &r) const;
   bool is_zero() const;
   bool is_one() const;
   bool is_null() const;
   bool is_valid_3src() const;
   bool is_contiguous() const;
   bool is_accumulator() const;

   fs_reg &apply_stride(unsigned stride);
   /** Smear a channel of the reg to all channels. */
   fs_reg &set_smear(unsigned subreg);

   /** Register file: GRF, MRF, IMM. */
   enum register_file file;
   /** Register type.  BRW_REGISTER_TYPE_* */
   uint8_t type;
   /**
    * Register number.  For MRF, it's the hardware register.  For
    * GRF, it's a virtual register number until register allocation
    */
   uint16_t reg;
   /**
    * Offset from the start of the contiguous register block.
    *
    * For pre-register-allocation GRFs, this is in units of a float per pixel
    * (1 hardware register for SIMD8 mode, or 2 registers for SIMD16 mode).
    * For uniforms, this is in units of 1 float.
    */
   int reg_offset;
   /**
    * Offset in bytes from the start of the register.  Values up to a
    * backend_reg::reg_offset unit are valid.
    */
   int subreg_offset;

   /** Value for file == IMM */
   union {
      int32_t i;
      uint32_t u;
      float f;
   } imm;

   struct brw_reg fixed_hw_reg;

   fs_reg *reladdr;

   bool negate;
   bool abs;

   /** Register region horizontal stride */
   uint8_t stride;
};

static inline fs_reg
retype(fs_reg reg, unsigned type)
{
   reg.fixed_hw_reg.type = reg.type = type;
   return reg;
}

static inline fs_reg
offset(fs_reg reg, unsigned delta)
{
   assert(delta == 0 || (reg.file != HW_REG && reg.file != IMM));
   reg.reg_offset += delta;
   return reg;
}

static inline fs_reg
byte_offset(fs_reg reg, unsigned delta)
{
   assert(delta == 0 || (reg.file != HW_REG && reg.file != IMM));
   reg.subreg_offset += delta;
   return reg;
}

/**
 * Get either of the 8-component halves of a 16-component register.
 *
 * Note: this also works if \c reg represents a SIMD16 pair of registers.
 */
static inline fs_reg
half(const fs_reg &reg, unsigned idx)
{
   assert(idx < 2);
   assert(idx == 0 || (reg.file != HW_REG && reg.file != IMM));
   return byte_offset(reg, 8 * idx * reg.stride * type_sz(reg.type));
}

static const fs_reg reg_undef;
static const fs_reg reg_null_f(retype(brw_null_reg(), BRW_REGISTER_TYPE_F));
static const fs_reg reg_null_d(retype(brw_null_reg(), BRW_REGISTER_TYPE_D));
static const fs_reg reg_null_ud(retype(brw_null_reg(), BRW_REGISTER_TYPE_UD));

class ip_record : public exec_node {
public:
   DECLARE_RALLOC_CXX_OPERATORS(ip_record)

   ip_record(int ip)
   {
      this->ip = ip;
   }

   int ip;
};

class fs_inst : public backend_instruction {
public:
   DECLARE_RALLOC_CXX_OPERATORS(fs_inst)

   void init();

   fs_inst();
   fs_inst(enum opcode opcode);
   fs_inst(enum opcode opcode, fs_reg dst);
   fs_inst(enum opcode opcode, fs_reg dst, fs_reg src0);
   fs_inst(enum opcode opcode, fs_reg dst, fs_reg src0, fs_reg src1);
   fs_inst(enum opcode opcode, fs_reg dst,
           fs_reg src0, fs_reg src1,fs_reg src2);

   bool equals(fs_inst *inst) const;
   bool overwrites_reg(const fs_reg &reg) const;
   bool is_send_from_grf() const;
   bool is_partial_write() const;
   int regs_read(fs_visitor *v, int arg) const;

   bool reads_flag() const;
   bool writes_flag() const;

   fs_reg dst;
   fs_reg src[3];

   /** @@{
    * Annotation for the generated IR.  One of the two can be set.
    */
   const void *ir;
   const char *annotation;
   /** @@} */

   uint32_t texture_offset; /**< Texture offset bitfield */
   uint32_t offset; /* spill/unspill offset */

   uint8_t conditional_mod; /**< BRW_CONDITIONAL_* */

   /* Chooses which flag subregister (f0.0 or f0.1) is used for conditional
    * mod and predication.
    */
   uint8_t flag_subreg;

   uint8_t mlen; /**< SEND message length */
   uint8_t regs_written; /**< Number of vgrfs written by a SEND message, or 1 */
   int8_t base_mrf; /**< First MRF in the SEND message, if mlen is nonzero. */
   uint8_t sampler;
   uint8_t target; /**< MRT target. */
   bool saturate:1;
   bool eot:1;
   bool header_present:1;
   bool shadow_compare:1;
   bool force_uncompressed:1;
   bool force_sechalf:1;
   bool force_writemask_all:1;
};

/**
 * The fragment shader front-end.
 *
 * Translates either GLSL IR or Mesa IR (for ARB_fragment_program) into FS IR.
 */
class fs_visitor : public backend_visitor
{
public:

   fs_visitor(struct brw_context *brw,
              struct brw_wm_compile *c,
              struct gl_shader_program *shader_prog,
              struct gl_fragment_program *fp,
              unsigned dispatch_width);
   ~fs_visitor();

   fs_reg *variable_storage(ir_variable *var);
   int virtual_grf_alloc(int size);
   void import_uniforms(fs_visitor *v);

   void visit(ir_variable *ir);
   void visit(ir_assignment *ir);
   void visit(ir_dereference_variable *ir);
   void visit(ir_dereference_record *ir);
   void visit(ir_dereference_array *ir);
   void visit(ir_expression *ir);
   void visit(ir_texture *ir);
   void visit(ir_if *ir);
   void visit(ir_constant *ir);
   void visit(ir_swizzle *ir);
   void visit(ir_return *ir);
   void visit(ir_loop *ir);
   void visit(ir_loop_jump *ir);
   void visit(ir_discard *ir);
   void visit(ir_call *ir);
   void visit(ir_function *ir);
   void visit(ir_function_signature *ir);
   void visit(ir_emit_vertex *);
   void visit(ir_end_primitive *);

   uint32_t gather_channel(ir_texture *ir, int sampler);
   void swizzle_result(ir_texture *ir, fs_reg orig_val, int sampler);

   bool can_do_source_mods(fs_inst *inst);

   fs_inst *emit(fs_inst *inst);
   void emit(exec_list list);

   fs_inst *emit(enum opcode opcode);
   fs_inst *emit(enum opcode opcode, fs_reg dst);
   fs_inst *emit(enum opcode opcode, fs_reg dst, fs_reg src0);
   fs_inst *emit(enum opcode opcode, fs_reg dst, fs_reg src0, fs_reg src1);
   fs_inst *emit(enum opcode opcode, fs_reg dst,
                 fs_reg src0, fs_reg src1, fs_reg src2);

   fs_inst *MOV(fs_reg dst, fs_reg src);
   fs_inst *NOT(fs_reg dst, fs_reg src);
   fs_inst *RNDD(fs_reg dst, fs_reg src);
   fs_inst *RNDE(fs_reg dst, fs_reg src);
   fs_inst *RNDZ(fs_reg dst, fs_reg src);
   fs_inst *FRC(fs_reg dst, fs_reg src);
   fs_inst *ADD(fs_reg dst, fs_reg src0, fs_reg src1);
   fs_inst *MUL(fs_reg dst, fs_reg src0, fs_reg src1);
   fs_inst *MACH(fs_reg dst, fs_reg src0, fs_reg src1);
   fs_inst *MAC(fs_reg dst, fs_reg src0, fs_reg src1);
   fs_inst *SHL(fs_reg dst, fs_reg src0, fs_reg src1);
   fs_inst *SHR(fs_reg dst, fs_reg src0, fs_reg src1);
   fs_inst *ASR(fs_reg dst, fs_reg src0, fs_reg src1);
   fs_inst *AND(fs_reg dst, fs_reg src0, fs_reg src1);
   fs_inst *OR(fs_reg dst, fs_reg src0, fs_reg src1);
   fs_inst *XOR(fs_reg dst, fs_reg src0, fs_reg src1);
   fs_inst *IF(uint32_t predicate);
   fs_inst *IF(fs_reg src0, fs_reg src1, uint32_t condition);
   fs_inst *CMP(fs_reg dst, fs_reg src0, fs_reg src1,
                uint32_t condition);
   fs_inst *LRP(fs_reg dst, fs_reg a, fs_reg y, fs_reg x);
   fs_inst *DEP_RESOLVE_MOV(int grf);
   fs_inst *BFREV(fs_reg dst, fs_reg value);
   fs_inst *BFE(fs_reg dst, fs_reg bits, fs_reg offset, fs_reg value);
   fs_inst *BFI1(fs_reg dst, fs_reg bits, fs_reg offset);
   fs_inst *BFI2(fs_reg dst, fs_reg bfi1_dst, fs_reg insert, fs_reg base);
   fs_inst *FBH(fs_reg dst, fs_reg value);
   fs_inst *FBL(fs_reg dst, fs_reg value);
   fs_inst *CBIT(fs_reg dst, fs_reg value);
   fs_inst *MAD(fs_reg dst, fs_reg c, fs_reg b, fs_reg a);
   fs_inst *ADDC(fs_reg dst, fs_reg src0, fs_reg src1);
   fs_inst *SUBB(fs_reg dst, fs_reg src0, fs_reg src1);
   fs_inst *SEL(fs_reg dst, fs_reg src0, fs_reg src1);

   int type_size(const struct glsl_type *type);
   fs_inst *get_instruction_generating_reg(fs_inst *start,
					   fs_inst *end,
					   const fs_reg &reg);

   exec_list VARYING_PULL_CONSTANT_LOAD(const fs_reg &dst,
                                        const fs_reg &surf_index,
                                        const fs_reg &varying_offset,
                                        uint32_t const_offset);

   bool run();
   void assign_binding_table_offsets();
   void setup_payload_gen4();
   void setup_payload_gen6();
   void assign_curb_setup();
   void calculate_urb_setup();
   void assign_urb_setup();
   bool assign_regs(bool allow_spilling);
   void assign_regs_trivial();
   void get_used_mrfs(bool *mrf_used);
   void setup_payload_interference(struct ra_graph *g, int payload_reg_count,
                                   int first_payload_node);
   void setup_mrf_hack_interference(struct ra_graph *g,
                                    int first_mrf_hack_node);
   int choose_spill_reg(struct ra_graph *g);
   void spill_reg(int spill_reg);
   void split_virtual_grfs();
   void compact_virtual_grfs();
   void move_uniform_array_access_to_pull_constants();
   void assign_constant_locations();
   void demote_pull_constants();
   void invalidate_live_intervals();
   void calculate_live_intervals();
   void calculate_register_pressure();
   bool opt_algebraic();
   bool opt_cse();
   bool opt_cse_local(bblock_t *block, exec_list *aeb);
   bool opt_copy_propagate();
   bool try_copy_propagate(fs_inst *inst, int arg, acp_entry *entry);
   bool opt_copy_propagate_local(void *mem_ctx, bblock_t *block,
                                 exec_list *acp);
   void opt_drop_redundant_mov_to_flags();
   bool register_coalesce();
   bool compute_to_mrf();
   bool dead_code_eliminate();
   bool remove_duplicate_mrf_writes();
   bool virtual_grf_interferes(int a, int b);
   void schedule_instructions(instruction_scheduler_mode mode);
   void insert_gen4_send_dependency_workarounds();
   void insert_gen4_pre_send_dependency_workarounds(fs_inst *inst);
   void insert_gen4_post_send_dependency_workarounds(fs_inst *inst);
   void vfail(const char *msg, va_list args);
   void fail(const char *msg, ...);
   void no16(const char *msg, ...);
   void lower_uniform_pull_constant_loads();

   void push_force_uncompressed();
   void pop_force_uncompressed();

   void emit_dummy_fs();
   fs_reg *emit_fragcoord_interpolation(ir_variable *ir);
   fs_inst *emit_linterp(const fs_reg &attr, const fs_reg &interp,
                         glsl_interp_qualifier interpolation_mode,
                         bool is_centroid, bool is_sample);
   fs_reg *emit_frontfacing_interpolation(ir_variable *ir);
   fs_reg *emit_samplepos_setup(ir_variable *ir);
   fs_reg *emit_sampleid_setup(ir_variable *ir);
   fs_reg *emit_samplemaskin_setup(ir_variable *ir);
   fs_reg *emit_general_interpolation(ir_variable *ir);
   void emit_interpolation_setup_gen4();
   void emit_interpolation_setup_gen6();
   void compute_sample_position(fs_reg dst, fs_reg int_sample_pos);
   fs_reg rescale_texcoord(ir_texture *ir, fs_reg coordinate,
                           bool is_rect, int sampler, int texunit);
   fs_inst *emit_texture_gen4(ir_texture *ir, fs_reg dst, fs_reg coordinate,
			      fs_reg shadow_comp, fs_reg lod, fs_reg lod2);
   fs_inst *emit_texture_gen5(ir_texture *ir, fs_reg dst, fs_reg coordinate,
                              fs_reg shadow_comp, fs_reg lod, fs_reg lod2,
                              fs_reg sample_index);
   fs_inst *emit_texture_gen7(ir_texture *ir, fs_reg dst, fs_reg coordinate,
                              fs_reg shadow_comp, fs_reg lod, fs_reg lod2,
                              fs_reg sample_index, fs_reg mcs, int sampler);
   fs_reg emit_mcs_fetch(ir_texture *ir, fs_reg coordinate, int sampler);
   void emit_gen6_gather_wa(uint8_t wa, fs_reg dst);
   fs_reg fix_math_operand(fs_reg src);
   fs_inst *emit_math(enum opcode op, fs_reg dst, fs_reg src0);
   fs_inst *emit_math(enum opcode op, fs_reg dst, fs_reg src0, fs_reg src1);
   void emit_lrp(const fs_reg &dst, const fs_reg &x, const fs_reg &y,
                 const fs_reg &a);
   void emit_minmax(uint32_t conditionalmod, const fs_reg &dst,
                    const fs_reg &src0, const fs_reg &src1);
   bool try_emit_saturate(ir_expression *ir);
   bool try_emit_mad(ir_expression *ir);
   void try_replace_with_sel();
   bool opt_peephole_sel();
   bool opt_peephole_predicated_break();
   bool opt_saturate_propagation();
   void emit_bool_to_cond_code(ir_rvalue *condition);
   void emit_if_gen6(ir_if *ir);
   void emit_unspill(fs_inst *inst, fs_reg reg, uint32_t spill_offset,
                     int count);

   void emit_fragment_program_code();
   void setup_fp_regs();
   fs_reg get_fp_src_reg(const prog_src_register *src);
   fs_reg get_fp_dst_reg(const prog_dst_register *dst);
   void emit_fp_alu1(enum opcode opcode,
                     const struct prog_instruction *fpi,
                     fs_reg dst, fs_reg src);
   void emit_fp_alu2(enum opcode opcode,
                     const struct prog_instruction *fpi,
                     fs_reg dst, fs_reg src0, fs_reg src1);
   void emit_fp_scalar_write(const struct prog_instruction *fpi,
                             fs_reg dst, fs_reg src);
   void emit_fp_scalar_math(enum opcode opcode,
                            const struct prog_instruction *fpi,
                            fs_reg dst, fs_reg src);

   void emit_fp_minmax(const struct prog_instruction *fpi,
                       fs_reg dst, fs_reg src0, fs_reg src1);

   void emit_fp_sop(uint32_t conditional_mod,
                    const struct prog_instruction *fpi,
                    fs_reg dst, fs_reg src0, fs_reg src1, fs_reg one);

   void emit_color_write(int target, int index, int first_color_mrf);
   void emit_alpha_test();
   void emit_fb_writes();

   void emit_shader_time_begin();
   void emit_shader_time_end();
   void emit_shader_time_write(enum shader_time_shader_type type,
                               fs_reg value);

   void emit_untyped_atomic(unsigned atomic_op, unsigned surf_index,
                            fs_reg dst, fs_reg offset, fs_reg src0,
                            fs_reg src1);

   void emit_untyped_surface_read(unsigned surf_index, fs_reg dst,
                                  fs_reg offset);

   bool try_rewrite_rhs_to_dst(ir_assignment *ir,
			       fs_reg dst,
			       fs_reg src,
			       fs_inst *pre_rhs_inst,
			       fs_inst *last_rhs_inst);
   void emit_assignment_writes(fs_reg &l, fs_reg &r,
			       const glsl_type *type, bool predicated);
   void resolve_ud_negate(fs_reg *reg);
   void resolve_bool_comparison(ir_rvalue *rvalue, fs_reg *reg);

   fs_reg get_timestamp();

   struct brw_reg interp_reg(int location, int channel);
   void setup_uniform_values(ir_variable *ir);
   void setup_builtin_uniform_values(ir_variable *ir);
   int implied_mrf_writes(fs_inst *inst);

   virtual void dump_instructions();
   void dump_instruction(backend_instruction *inst);

   void visit_atomic_counter_intrinsic(ir_call *ir);

   struct gl_fragment_program *fp;
   struct brw_wm_compile *c;
   unsigned int sanity_param_count;

   int *param_size;

   int *virtual_grf_sizes;
   int virtual_grf_count;
   int virtual_grf_array_size;
   int *virtual_grf_start;
   int *virtual_grf_end;
   brw::fs_live_variables *live_intervals;

   int *regs_live_at_ip;

   /** Number of uniform variable components visited. */
   unsigned uniforms;

   /**
    * Array mapping UNIFORM register numbers to the pull parameter index,
    * or -1 if this uniform register isn't being uploaded as a pull constant.
    */
   int *pull_constant_loc;

   /**
    * Array mapping UNIFORM register numbers to the push parameter index,
    * or -1 if this uniform register isn't being uploaded as a push constant.
    */
   int *push_constant_loc;

   struct hash_table *variable_ht;
   fs_reg frag_depth;
   fs_reg sample_mask;
   fs_reg outputs[BRW_MAX_DRAW_BUFFERS];
   unsigned output_components[BRW_MAX_DRAW_BUFFERS];
   fs_reg dual_src_output;
   bool do_dual_src;
   int first_non_payload_grf;
   /** Either BRW_MAX_GRF or GEN7_MRF_HACK_START */
   int max_grf;

   fs_reg *fp_temp_regs;
   fs_reg *fp_input_regs;

   /** @@{ debug annotation info */
   const char *current_annotation;
   const void *base_ir;
   /** @@} */

   bool failed;
   char *fail_msg;
   bool simd16_unsupported;
   char *no16_msg;

   /* Result of last visit() method. */
   fs_reg result;

   fs_reg pixel_x;
   fs_reg pixel_y;
   fs_reg wpos_w;
   fs_reg pixel_w;
   fs_reg delta_x[BRW_WM_BARYCENTRIC_INTERP_MODE_COUNT];
   fs_reg delta_y[BRW_WM_BARYCENTRIC_INTERP_MODE_COUNT];
   fs_reg shader_start_time;

   int grf_used;
   bool spilled_any_registers;

   const unsigned dispatch_width; /**< 8 or 16 */

   int force_uncompressed_stack;
};

/**
 * The fragment shader code generator.
 *
 * Translates FS IR to actual i965 assembly code.
 */
class fs_generator
{
public:
   fs_generator(struct brw_context *brw,
                struct brw_wm_compile *c,
                struct gl_shader_program *prog,
                struct gl_fragment_program *fp,
                bool dual_source_output);
   ~fs_generator();

   const unsigned *generate_assembly(exec_list *simd8_instructions,
                                     exec_list *simd16_instructions,
                                     unsigned *assembly_size,
                                     FILE *dump_file = NULL);

private:
   void generate_code(exec_list *instructions, FILE *dump_file);
   void generate_fb_write(fs_inst *inst);
   void generate_blorp_fb_write(fs_inst *inst);
   void generate_pixel_xy(struct brw_reg dst, bool is_x);
   void generate_linterp(fs_inst *inst, struct brw_reg dst,
			 struct brw_reg *src);
   void generate_tex(fs_inst *inst, struct brw_reg dst, struct brw_reg src);
   void generate_math1_gen7(fs_inst *inst,
			    struct brw_reg dst,
			    struct brw_reg src);
   void generate_math2_gen7(fs_inst *inst,
			    struct brw_reg dst,
			    struct brw_reg src0,
			    struct brw_reg src1);
   void generate_math1_gen6(fs_inst *inst,
			    struct brw_reg dst,
			    struct brw_reg src);
   void generate_math2_gen6(fs_inst *inst,
			    struct brw_reg dst,
			    struct brw_reg src0,
			    struct brw_reg src1);
   void generate_math_gen4(fs_inst *inst,
			   struct brw_reg dst,
			   struct brw_reg src);
   void generate_math_g45(fs_inst *inst,
			  struct brw_reg dst,
			  struct brw_reg src);
   void generate_ddx(fs_inst *inst, struct brw_reg dst, struct brw_reg src);
   void generate_ddy(fs_inst *inst, struct brw_reg dst, struct brw_reg src,
                     bool negate_value);
   void generate_scratch_write(fs_inst *inst, struct brw_reg src);
   void generate_scratch_read(fs_inst *inst, struct brw_reg dst);
   void generate_scratch_read_gen7(fs_inst *inst, struct brw_reg dst);
   void generate_uniform_pull_constant_load(fs_inst *inst, struct brw_reg dst,
                                            struct brw_reg index,
                                            struct brw_reg offset);
   void generate_uniform_pull_constant_load_gen7(fs_inst *inst,
                                                 struct brw_reg dst,
                                                 struct brw_reg surf_index,
                                                 struct brw_reg offset);
   void generate_varying_pull_constant_load(fs_inst *inst, struct brw_reg dst,
                                            struct brw_reg index,
                                            struct brw_reg offset);
   void generate_varying_pull_constant_load_gen7(fs_inst *inst,
                                                 struct brw_reg dst,
                                                 struct brw_reg index,
                                                 struct brw_reg offset);
   void generate_mov_dispatch_to_flags(fs_inst *inst);

   void generate_set_omask(fs_inst *inst,
                           struct brw_reg dst,
                           struct brw_reg sample_mask);

   void generate_set_sample_id(fs_inst *inst,
                               struct brw_reg dst,
                               struct brw_reg src0,
                               struct brw_reg src1);

   void generate_set_simd4x2_offset(fs_inst *inst,
                                    struct brw_reg dst,
                                    struct brw_reg offset);
   void generate_discard_jump(fs_inst *inst);

   void generate_pack_half_2x16_split(fs_inst *inst,
                                      struct brw_reg dst,
                                      struct brw_reg x,
                                      struct brw_reg y);
   void generate_unpack_half_2x16_split(fs_inst *inst,
                                        struct brw_reg dst,
                                        struct brw_reg src);

   void generate_shader_time_add(fs_inst *inst,
                                 struct brw_reg payload,
                                 struct brw_reg offset,
                                 struct brw_reg value);

   void generate_untyped_atomic(fs_inst *inst,
                                struct brw_reg dst,
                                struct brw_reg atomic_op,
                                struct brw_reg surf_index);

   void generate_untyped_surface_read(fs_inst *inst,
                                      struct brw_reg dst,
                                      struct brw_reg surf_index);

   void patch_discard_jumps_to_fb_writes();

   struct brw_context *brw;
   struct gl_context *ctx;

   struct brw_compile *p;
   struct brw_wm_compile *c;

   struct gl_shader_program *prog;
   const struct gl_fragment_program *fp;

   unsigned dispatch_width; /**< 8 or 16 */

   exec_list discard_halt_patches;
   bool dual_source_output;
   void *mem_ctx;
};

/**
 * The fragment shader code generator.
 *
 * Translates FS IR to actual i965 assembly code.
 */
class gen8_fs_generator : public gen8_generator
{
public:
   gen8_fs_generator(struct brw_context *brw,
                     struct brw_wm_compile *c,
                     struct gl_shader_program *prog,
                     struct gl_fragment_program *fp,
                     bool dual_source_output);
   ~gen8_fs_generator();

   const unsigned *generate_assembly(exec_list *simd8_instructions,
                                     exec_list *simd16_instructions,
                                     unsigned *assembly_size);

private:
   void generate_code(exec_list *instructions);
   void generate_fb_write(fs_inst *inst);
   void generate_linterp(fs_inst *inst, struct brw_reg dst,
                         struct brw_reg *src);
   void generate_tex(fs_inst *inst, struct brw_reg dst, struct brw_reg src);
   void generate_math1(fs_inst *inst, struct brw_reg dst, struct brw_reg src);
   void generate_math2(fs_inst *inst, struct brw_reg dst,
                       struct brw_reg src0, struct brw_reg src1);
   void generate_ddx(fs_inst *inst, struct brw_reg dst, struct brw_reg src);
   void generate_ddy(fs_inst *inst, struct brw_reg dst, struct brw_reg src,
                     bool negate_value);
   void generate_scratch_write(fs_inst *inst, struct brw_reg src);
   void generate_scratch_read(fs_inst *inst, struct brw_reg dst);
   void generate_scratch_read_gen7(fs_inst *inst, struct brw_reg dst);
   void generate_uniform_pull_constant_load(fs_inst *inst,
                                            struct brw_reg dst,
                                            struct brw_reg index,
                                            struct brw_reg offset);
   void generate_varying_pull_constant_load(fs_inst *inst,
                                            struct brw_reg dst,
                                            struct brw_reg index,
                                            struct brw_reg offset);
   void generate_mov_dispatch_to_flags(fs_inst *ir);
   void generate_set_omask(fs_inst *ir,
                           struct brw_reg dst,
                           struct brw_reg sample_mask);
   void generate_set_sample_id(fs_inst *ir,
                               struct brw_reg dst,
                               struct brw_reg src0,
                               struct brw_reg src1);
   void generate_set_simd4x2_offset(fs_inst *ir,
                                    struct brw_reg dst,
                                    struct brw_reg offset);
   void generate_pack_half_2x16_split(fs_inst *inst,
                                      struct brw_reg dst,
                                      struct brw_reg x,
                                      struct brw_reg y);
   void generate_unpack_half_2x16_split(fs_inst *inst,
                                        struct brw_reg dst,
                                        struct brw_reg src);
   void generate_untyped_atomic(fs_inst *inst,
                                struct brw_reg dst,
                                struct brw_reg atomic_op,
                                struct brw_reg surf_index);

   void generate_untyped_surface_read(fs_inst *inst,
                                      struct brw_reg dst,
                                      struct brw_reg surf_index);
   void generate_discard_jump(fs_inst *ir);

   void patch_discard_jumps_to_fb_writes();

   struct brw_wm_compile *c;
   const struct gl_fragment_program *fp;

   unsigned dispatch_width; /** 8 or 16 */

   bool dual_source_output;

   exec_list discard_halt_patches;
};

bool brw_do_channel_expressions(struct exec_list *instructions);
bool brw_do_vector_splitting(struct exec_list *instructions);
bool brw_fs_precompile(struct gl_context *ctx, struct gl_shader_program *prog);

struct brw_reg brw_reg_from_fs_reg(fs_reg *reg);
@


1.8
log
@Merge Mesa 10.2.9
@
text
@@


1.7
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d42 1
a42 1
#include "util/register_allocate.h"
a48 1
#include "intel_asm_annotation.h"
d50 1
a54 1
#define MAX_VGRF_SIZE 16
d56 1
a56 1
struct bblock_t;
d65 1
a65 4
class fs_inst;
class fs_visitor;

class fs_reg : public backend_reg {
d72 3
a74 3
   explicit fs_reg(float f);
   explicit fs_reg(int32_t i);
   explicit fs_reg(uint32_t u);
d77 2
a78 3
   fs_reg(enum register_file file, int reg, enum brw_reg_type type);
   fs_reg(enum register_file file, int reg, enum brw_reg_type type, uint8_t width);
   fs_reg(fs_visitor *v, const struct glsl_type *type);
d81 3
d86 1
d92 17
d115 9
d126 2
a127 15
   /**
    * The register width.  This indicates how many hardware values are
    * represented by each virtual value.  Valid values are 1, 8, or 16.
    * For immediate values, this is 1.  Most of the rest of the time, it
    * will be equal to the dispatch width.
    */
   uint8_t width;

   /**
    * Returns the effective register width when used as a source in the
    * given instruction.  Registers such as uniforms and immediates
    * effectively take on the width of the instruction in which they are
    * used.
    */
   uint8_t effective_width;
d134 1
a134 1
retype(fs_reg reg, enum brw_reg_type type)
a140 39
byte_offset(fs_reg reg, unsigned delta)
{
   switch (reg.file) {
   case BAD_FILE:
      break;
   case GRF:
      reg.reg_offset += delta / 32;
      break;
   case MRF:
      reg.reg += delta / 32;
      break;
   default:
      assert(delta == 0);
   }
   reg.subreg_offset += delta % 32;
   return reg;
}

static inline fs_reg
horiz_offset(fs_reg reg, unsigned delta)
{
   switch (reg.file) {
   case BAD_FILE:
   case UNIFORM:
   case IMM:
      /* These only have a single component that is implicitly splatted.  A
       * horizontal offset should be a harmless no-op.
       */
      break;
   case GRF:
   case MRF:
      return byte_offset(reg, delta * reg.stride * type_sz(reg.type));
   default:
      assert(delta == 0);
   }
   return reg;
}

static inline fs_reg
d143 2
a144 13
   assert(reg.stride > 0);
   switch (reg.file) {
   case BAD_FILE:
      break;
   case GRF:
   case MRF:
      return byte_offset(reg, delta * reg.width * reg.stride * type_sz(reg.type));
   case UNIFORM:
      reg.reg_offset += delta;
      break;
   default:
      assert(delta == 0);
   }
d149 1
a149 1
component(fs_reg reg, unsigned idx)
d151 2
a152 4
   assert(reg.subreg_offset == 0);
   assert(idx < reg.width);
   reg.subreg_offset = idx * type_sz(reg.type);
   reg.width = 1;
d162 1
a162 1
half(fs_reg reg, unsigned idx)
d166 1
a166 3
   assert(reg.width == 16);
   reg.width = 8;
   return horiz_offset(reg, 8 * idx);
d170 3
a186 5
   fs_inst &operator=(const fs_inst &);

   void init(enum opcode opcode, uint8_t exec_width, const fs_reg &dst,
             fs_reg *src, int sources);

d190 2
d193 6
a198 19
   fs_inst(enum opcode opcode, uint8_t exec_size);
   fs_inst(enum opcode opcode, const fs_reg &dst);
   fs_inst(enum opcode opcode, uint8_t exec_size, const fs_reg &dst,
           const fs_reg &src0);
   fs_inst(enum opcode opcode, const fs_reg &dst, const fs_reg &src0);
   fs_inst(enum opcode opcode, uint8_t exec_size, const fs_reg &dst,
           const fs_reg &src0, const fs_reg &src1);
   fs_inst(enum opcode opcode, const fs_reg &dst, const fs_reg &src0,
           const fs_reg &src1);
   fs_inst(enum opcode opcode, uint8_t exec_size, const fs_reg &dst,
           const fs_reg &src0, const fs_reg &src1, const fs_reg &src2);
   fs_inst(enum opcode opcode, const fs_reg &dst, const fs_reg &src0,
           const fs_reg &src1, const fs_reg &src2);
   fs_inst(enum opcode opcode, const fs_reg &dst, fs_reg src[], int sources);
   fs_inst(enum opcode opcode, uint8_t exec_size, const fs_reg &dst,
           fs_reg src[], int sources);
   fs_inst(const fs_inst &that);

   void resize_sources(uint8_t num_sources);
a204 1
   bool can_do_source_mods(struct brw_context *brw);
d210 8
a217 1
   fs_reg *src;
d219 2
a220 1
   uint8_t sources; /**< Number of fs_reg sources. */
d222 1
a222 6
   /**
    * Execution size of the instruction.  This is used by the generator to
    * generate the correct binary for the given fs_inst.  Current valid
    * values are 1, 8, 16.
    */
   uint8_t exec_size;
d229 1
d231 4
d240 1
a240 1
   bool pi_noperspective:1;   /**< Pixel interpolator noperspective flag */
a250 3
   const fs_reg reg_null_f;
   const fs_reg reg_null_d;
   const fs_reg reg_null_ud;
d253 1
a253 3
              void *mem_ctx,
              const struct brw_wm_prog_key *key,
              struct brw_wm_prog_data *prog_data,
a257 1
   void init();
d283 4
a286 3
   uint32_t gather_channel(int orig_chan, uint32_t sampler);
   void swizzle_result(ir_texture_opcode op, int dest_components,
                       fs_reg orig_val, uint32_t sampler);
d292 24
a315 28
   fs_inst *emit(enum opcode opcode, const fs_reg &dst);
   fs_inst *emit(enum opcode opcode, const fs_reg &dst, const fs_reg &src0);
   fs_inst *emit(enum opcode opcode, const fs_reg &dst, const fs_reg &src0,
                 const fs_reg &src1);
   fs_inst *emit(enum opcode opcode, const fs_reg &dst,
                 const fs_reg &src0, const fs_reg &src1, const fs_reg &src2);
   fs_inst *emit(enum opcode opcode, const fs_reg &dst,
                 fs_reg src[], int sources);

   fs_inst *MOV(const fs_reg &dst, const fs_reg &src);
   fs_inst *NOT(const fs_reg &dst, const fs_reg &src);
   fs_inst *RNDD(const fs_reg &dst, const fs_reg &src);
   fs_inst *RNDE(const fs_reg &dst, const fs_reg &src);
   fs_inst *RNDZ(const fs_reg &dst, const fs_reg &src);
   fs_inst *FRC(const fs_reg &dst, const fs_reg &src);
   fs_inst *ADD(const fs_reg &dst, const fs_reg &src0, const fs_reg &src1);
   fs_inst *MUL(const fs_reg &dst, const fs_reg &src0, const fs_reg &src1);
   fs_inst *MACH(const fs_reg &dst, const fs_reg &src0, const fs_reg &src1);
   fs_inst *MAC(const fs_reg &dst, const fs_reg &src0, const fs_reg &src1);
   fs_inst *SHL(const fs_reg &dst, const fs_reg &src0, const fs_reg &src1);
   fs_inst *SHR(const fs_reg &dst, const fs_reg &src0, const fs_reg &src1);
   fs_inst *ASR(const fs_reg &dst, const fs_reg &src0, const fs_reg &src1);
   fs_inst *AND(const fs_reg &dst, const fs_reg &src0, const fs_reg &src1);
   fs_inst *OR(const fs_reg &dst, const fs_reg &src0, const fs_reg &src1);
   fs_inst *XOR(const fs_reg &dst, const fs_reg &src0, const fs_reg &src1);
   fs_inst *IF(enum brw_predicate predicate);
   fs_inst *IF(const fs_reg &src0, const fs_reg &src1,
               enum brw_conditional_mod condition);
d317 2
a318 3
                enum brw_conditional_mod condition);
   fs_inst *LRP(const fs_reg &dst, const fs_reg &a, const fs_reg &y,
                const fs_reg &x);
d320 11
a330 14
   fs_inst *BFREV(const fs_reg &dst, const fs_reg &value);
   fs_inst *BFE(const fs_reg &dst, const fs_reg &bits, const fs_reg &offset,
                const fs_reg &value);
   fs_inst *BFI1(const fs_reg &dst, const fs_reg &bits, const fs_reg &offset);
   fs_inst *BFI2(const fs_reg &dst, const fs_reg &bfi1_dst,
                 const fs_reg &insert, const fs_reg &base);
   fs_inst *FBH(const fs_reg &dst, const fs_reg &value);
   fs_inst *FBL(const fs_reg &dst, const fs_reg &value);
   fs_inst *CBIT(const fs_reg &dst, const fs_reg &value);
   fs_inst *MAD(const fs_reg &dst, const fs_reg &c, const fs_reg &b,
                const fs_reg &a);
   fs_inst *ADDC(const fs_reg &dst, const fs_reg &src0, const fs_reg &src1);
   fs_inst *SUBB(const fs_reg &dst, const fs_reg &src0, const fs_reg &src1);
   fs_inst *SEL(const fs_reg &dst, const fs_reg &src0, const fs_reg &src1);
a336 2
   fs_inst *LOAD_PAYLOAD(const fs_reg &dst, fs_reg *src, int sources);

a342 2
   void optimize();
   void allocate_registers();
d359 1
a359 1
   bool compact_virtual_grfs();
d368 1
a368 1
   bool opt_cse_local(bblock_t *block);
a370 1
   bool try_constant_propagate(fs_inst *inst, acp_entry *entry);
a373 1
   bool opt_register_renaming();
d381 2
a382 4
   void insert_gen4_pre_send_dependency_workarounds(bblock_t *block,
                                                    fs_inst *inst);
   void insert_gen4_post_send_dependency_workarounds(bblock_t *block,
                                                     fs_inst *inst);
d387 3
a389 1
   bool lower_load_payload();
a391 1
   void emit_repclear_shader();
d396 4
a399 3
   fs_reg *emit_frontfacing_interpolation();
   fs_reg *emit_samplepos_setup();
   fs_reg *emit_sampleid_setup();
d404 11
a414 34
   fs_reg rescale_texcoord(fs_reg coordinate, const glsl_type *coord_type,
                           bool is_rect, uint32_t sampler, int texunit);
   fs_inst *emit_texture_gen4(ir_texture_opcode op, fs_reg dst,
                              fs_reg coordinate, int coord_components,
                              fs_reg shadow_comp,
                              fs_reg lod, fs_reg lod2, int grad_components,
                              uint32_t sampler);
   fs_inst *emit_texture_gen5(ir_texture_opcode op, fs_reg dst,
                              fs_reg coordinate, int coord_components,
                              fs_reg shadow_comp,
                              fs_reg lod, fs_reg lod2, int grad_components,
                              fs_reg sample_index, uint32_t sampler,
                              bool has_offset);
   fs_inst *emit_texture_gen7(ir_texture_opcode op, fs_reg dst,
                              fs_reg coordinate, int coord_components,
                              fs_reg shadow_comp,
                              fs_reg lod, fs_reg lod2, int grad_components,
                              fs_reg sample_index, fs_reg mcs, fs_reg sampler,
                              fs_reg offset_value);
   void emit_texture(ir_texture_opcode op,
                     const glsl_type *dest_type,
                     fs_reg coordinate, const struct glsl_type *coord_type,
                     fs_reg shadow_c,
                     fs_reg lod, fs_reg dpdy, int grad_components,
                     fs_reg sample_index,
                     fs_reg offset, unsigned offset_components,
                     fs_reg mcs,
                     int gather_component,
                     bool is_cube_array,
                     bool is_rect,
                     uint32_t sampler,
                     fs_reg sampler_reg,
                     int texunit);
   fs_reg emit_mcs_fetch(fs_reg coordinate, int components, fs_reg sampler);
d421 1
a421 1
   void emit_minmax(enum brw_conditional_mod conditionalmod, const fs_reg &dst,
d431 2
a432 4
   void emit_unspill(bblock_t *block, fs_inst *inst, fs_reg reg,
                     uint32_t spill_offset, int count);
   void emit_spill(bblock_t *block, fs_inst *inst, fs_reg reg,
                   uint32_t spill_offset, int count);
d453 1
a453 1
   void emit_fp_sop(enum brw_conditional_mod conditional_mod,
d457 1
a457 1
   int setup_color_payload(fs_reg *dst, fs_reg color, unsigned components);
a458 2
   fs_inst *emit_single_fb_write(fs_reg color1, fs_reg color2,
                                 fs_reg src0_alpha, unsigned components);
a472 2
   void emit_interpolate_expression(ir_expression *ir);

a490 1
   virtual void dump_instructions(const char *name);
a491 1
   void dump_instruction(backend_instruction *inst, FILE *file);
d495 2
a496 2
   const void *const key;
   struct brw_stage_prog_data *prog_data;
a512 3
   /** Byte-offset for the next available spot in the scratch space buffer. */
   unsigned last_scratch;

a551 17
   /** Register numbers for thread payload fields. */
   struct {
      uint8_t source_depth_reg;
      uint8_t source_w_reg;
      uint8_t aa_dest_stencil_reg;
      uint8_t dest_depth_reg;
      uint8_t sample_pos_reg;
      uint8_t sample_mask_in_reg;
      uint8_t barycentric_coord_reg[BRW_WM_BARYCENTRIC_INTERP_MODE_COUNT];

      /** The number of thread payload registers the hardware will supply. */
      uint8_t num_regs;
   } payload;

   bool source_depth_to_render_target;
   bool runtime_check_aads_emit;

d564 2
d577 2
a578 4
                void *mem_ctx,
                const struct brw_wm_prog_key *key,
                struct brw_wm_prog_data *prog_data,
                struct gl_shader_program *shader_prog,
d580 1
a580 2
                bool runtime_check_aads_emit,
                bool debug_flag);
d583 4
a586 2
   int generate_code(const cfg_t *cfg, int dispatch_width);
   const unsigned *get_assembly(unsigned int *assembly_size);
d589 2
a590 5
   void fire_fb_write(fs_inst *inst,
                      struct brw_reg payload,
                      struct brw_reg implied_header,
                      GLuint nr);
   void generate_fb_write(fs_inst *inst, struct brw_reg payload);
d595 15
a609 6
   void generate_tex(fs_inst *inst, struct brw_reg dst, struct brw_reg src,
                     struct brw_reg sampler_index);
   void generate_math_gen6(fs_inst *inst,
                           struct brw_reg dst,
                           struct brw_reg src0,
                           struct brw_reg src1);
d616 1
a616 1
   void generate_ddx(fs_inst *inst, struct brw_reg dst, struct brw_reg src, struct brw_reg quality);
d618 1
a618 1
                     struct brw_reg quality, bool negate_value);
a637 6
   void generate_pixel_interpolator_query(fs_inst *inst,
                                          struct brw_reg dst,
                                          struct brw_reg src,
                                          struct brw_reg msg_data,
                                          unsigned msg_type);

a666 1
                                struct brw_reg payload,
a671 1
                                      struct brw_reg payload,
d674 1
a674 1
   bool patch_discard_jumps_to_fb_writes();
d680 1
a680 3
   gl_shader_stage stage;
   const void * const key;
   struct brw_stage_prog_data * const prog_data;
d682 2
a683 2
   struct gl_shader_program * const shader_prog;
   const struct gl_program *prog;
d688 1
a688 2
   bool runtime_check_aads_emit;
   const bool debug_flag;
d690 82
@


1.6
log
@Merge Mesa 10.2.7
@
text
@d42 1
a42 1
#include "program/register_allocate.h"
d49 1
a50 1
#include "gen8_generator.h"
d55 1
d57 1
a57 1
class bblock_t;
d66 4
a69 1
class fs_reg {
d76 3
a78 3
   fs_reg(float f);
   fs_reg(int32_t i);
   fs_reg(uint32_t u);
d81 3
a83 2
   fs_reg(enum register_file file, int reg, uint32_t type);
   fs_reg(class fs_visitor *v, const struct glsl_type *type);
a85 3
   bool is_zero() const;
   bool is_one() const;
   bool is_null() const;
a87 1
   bool is_accumulator() const;
a92 17
   /** Register file: GRF, MRF, IMM. */
   enum register_file file;
   /** Register type.  BRW_REGISTER_TYPE_* */
   uint8_t type;
   /**
    * Register number.  For MRF, it's the hardware register.  For
    * GRF, it's a virtual register number until register allocation
    */
   uint16_t reg;
   /**
    * Offset from the start of the contiguous register block.
    *
    * For pre-register-allocation GRFs, this is in units of a float per pixel
    * (1 hardware register for SIMD8 mode, or 2 registers for SIMD16 mode).
    * For uniforms, this is in units of 1 float.
    */
   int reg_offset;
d99 1
a99 6
   /** Value for file == IMM */
   union {
      int32_t i;
      uint32_t u;
      float f;
   } imm;
d101 7
a107 1
   struct brw_reg fixed_hw_reg;
d109 7
a115 4
   fs_reg *reladdr;

   bool negate;
   bool abs;
d122 1
a122 1
retype(fs_reg reg, unsigned type)
d129 39
d170 13
a182 2
   assert(delta == 0 || (reg.file != HW_REG && reg.file != IMM));
   reg.reg_offset += delta;
d187 1
a187 1
byte_offset(fs_reg reg, unsigned delta)
d189 4
a192 2
   assert(delta == 0 || (reg.file != HW_REG && reg.file != IMM));
   reg.subreg_offset += delta;
d202 1
a202 1
half(const fs_reg &reg, unsigned idx)
d206 3
a208 1
   return byte_offset(reg, 8 * idx * reg.stride * type_sz(reg.type));
a211 3
static const fs_reg reg_null_f(retype(brw_null_reg(), BRW_REGISTER_TYPE_F));
static const fs_reg reg_null_d(retype(brw_null_reg(), BRW_REGISTER_TYPE_D));
static const fs_reg reg_null_ud(retype(brw_null_reg(), BRW_REGISTER_TYPE_UD));
d226 5
d234 18
a251 1
   void init();
d253 1
a253 7
   fs_inst();
   fs_inst(enum opcode opcode);
   fs_inst(enum opcode opcode, fs_reg dst);
   fs_inst(enum opcode opcode, fs_reg dst, fs_reg src0);
   fs_inst(enum opcode opcode, fs_reg dst, fs_reg src0, fs_reg src1);
   fs_inst(enum opcode opcode, fs_reg dst,
           fs_reg src0, fs_reg src1,fs_reg src2);
d260 1
d266 3
a268 1
   fs_reg src[3];
d270 4
a273 2
   /** @@{
    * Annotation for the generated IR.  One of the two can be set.
d275 1
a275 8
   const void *ir;
   const char *annotation;
   /** @@} */

   uint32_t texture_offset; /**< Texture offset bitfield */
   uint32_t offset; /* spill/unspill offset */

   uint8_t conditional_mod; /**< BRW_CONDITIONAL_* */
a281 1
   uint8_t mlen; /**< SEND message length */
a282 4
   int8_t base_mrf; /**< First MRF in the SEND message, if mlen is nonzero. */
   uint8_t sampler;
   uint8_t target; /**< MRT target. */
   bool saturate:1;
d288 1
a288 1
   bool force_writemask_all:1;
d299 3
d304 3
a306 1
              struct brw_wm_compile *c,
d311 1
d337 3
a339 4
   uint32_t gather_channel(ir_texture *ir, int sampler);
   void swizzle_result(ir_texture *ir, fs_reg orig_val, int sampler);

   bool can_do_source_mods(fs_inst *inst);
d345 28
a372 24
   fs_inst *emit(enum opcode opcode, fs_reg dst);
   fs_inst *emit(enum opcode opcode, fs_reg dst, fs_reg src0);
   fs_inst *emit(enum opcode opcode, fs_reg dst, fs_reg src0, fs_reg src1);
   fs_inst *emit(enum opcode opcode, fs_reg dst,
                 fs_reg src0, fs_reg src1, fs_reg src2);

   fs_inst *MOV(fs_reg dst, fs_reg src);
   fs_inst *NOT(fs_reg dst, fs_reg src);
   fs_inst *RNDD(fs_reg dst, fs_reg src);
   fs_inst *RNDE(fs_reg dst, fs_reg src);
   fs_inst *RNDZ(fs_reg dst, fs_reg src);
   fs_inst *FRC(fs_reg dst, fs_reg src);
   fs_inst *ADD(fs_reg dst, fs_reg src0, fs_reg src1);
   fs_inst *MUL(fs_reg dst, fs_reg src0, fs_reg src1);
   fs_inst *MACH(fs_reg dst, fs_reg src0, fs_reg src1);
   fs_inst *MAC(fs_reg dst, fs_reg src0, fs_reg src1);
   fs_inst *SHL(fs_reg dst, fs_reg src0, fs_reg src1);
   fs_inst *SHR(fs_reg dst, fs_reg src0, fs_reg src1);
   fs_inst *ASR(fs_reg dst, fs_reg src0, fs_reg src1);
   fs_inst *AND(fs_reg dst, fs_reg src0, fs_reg src1);
   fs_inst *OR(fs_reg dst, fs_reg src0, fs_reg src1);
   fs_inst *XOR(fs_reg dst, fs_reg src0, fs_reg src1);
   fs_inst *IF(uint32_t predicate);
   fs_inst *IF(fs_reg src0, fs_reg src1, uint32_t condition);
d374 3
a376 2
                uint32_t condition);
   fs_inst *LRP(fs_reg dst, fs_reg a, fs_reg y, fs_reg x);
d378 14
a391 11
   fs_inst *BFREV(fs_reg dst, fs_reg value);
   fs_inst *BFE(fs_reg dst, fs_reg bits, fs_reg offset, fs_reg value);
   fs_inst *BFI1(fs_reg dst, fs_reg bits, fs_reg offset);
   fs_inst *BFI2(fs_reg dst, fs_reg bfi1_dst, fs_reg insert, fs_reg base);
   fs_inst *FBH(fs_reg dst, fs_reg value);
   fs_inst *FBL(fs_reg dst, fs_reg value);
   fs_inst *CBIT(fs_reg dst, fs_reg value);
   fs_inst *MAD(fs_reg dst, fs_reg c, fs_reg b, fs_reg a);
   fs_inst *ADDC(fs_reg dst, fs_reg src0, fs_reg src1);
   fs_inst *SUBB(fs_reg dst, fs_reg src0, fs_reg src1);
   fs_inst *SEL(fs_reg dst, fs_reg src0, fs_reg src1);
d398 2
d406 2
d424 1
a424 1
   void compact_virtual_grfs();
d433 1
a433 1
   bool opt_cse_local(bblock_t *block, exec_list *aeb);
d436 1
d440 1
d448 4
a451 2
   void insert_gen4_pre_send_dependency_workarounds(fs_inst *inst);
   void insert_gen4_post_send_dependency_workarounds(fs_inst *inst);
d456 1
a456 3

   void push_force_uncompressed();
   void pop_force_uncompressed();
d459 1
d464 3
a466 4
   fs_reg *emit_frontfacing_interpolation(ir_variable *ir);
   fs_reg *emit_samplepos_setup(ir_variable *ir);
   fs_reg *emit_sampleid_setup(ir_variable *ir);
   fs_reg *emit_samplemaskin_setup(ir_variable *ir);
d471 34
a504 11
   fs_reg rescale_texcoord(ir_texture *ir, fs_reg coordinate,
                           bool is_rect, int sampler, int texunit);
   fs_inst *emit_texture_gen4(ir_texture *ir, fs_reg dst, fs_reg coordinate,
			      fs_reg shadow_comp, fs_reg lod, fs_reg lod2);
   fs_inst *emit_texture_gen5(ir_texture *ir, fs_reg dst, fs_reg coordinate,
                              fs_reg shadow_comp, fs_reg lod, fs_reg lod2,
                              fs_reg sample_index);
   fs_inst *emit_texture_gen7(ir_texture *ir, fs_reg dst, fs_reg coordinate,
                              fs_reg shadow_comp, fs_reg lod, fs_reg lod2,
                              fs_reg sample_index, fs_reg mcs, int sampler);
   fs_reg emit_mcs_fetch(ir_texture *ir, fs_reg coordinate, int sampler);
d511 1
a511 1
   void emit_minmax(uint32_t conditionalmod, const fs_reg &dst,
d521 4
a524 2
   void emit_unspill(fs_inst *inst, fs_reg reg, uint32_t spill_offset,
                     int count);
d545 1
a545 1
   void emit_fp_sop(uint32_t conditional_mod,
d549 1
a549 1
   void emit_color_write(int target, int index, int first_color_mrf);
d551 2
d567 2
d587 1
d589 1
d593 2
a594 2
   struct gl_fragment_program *fp;
   struct brw_wm_compile *c;
d611 3
d653 17
a681 2

   int force_uncompressed_stack;
d693 4
a696 2
                struct brw_wm_compile *c,
                struct gl_shader_program *prog,
d698 2
a699 1
                bool dual_source_output);
d702 2
a703 4
   const unsigned *generate_assembly(exec_list *simd8_instructions,
                                     exec_list *simd16_instructions,
                                     unsigned *assembly_size,
                                     FILE *dump_file = NULL);
d706 5
a710 2
   void generate_code(exec_list *instructions, FILE *dump_file);
   void generate_fb_write(fs_inst *inst);
d715 6
a720 15
   void generate_tex(fs_inst *inst, struct brw_reg dst, struct brw_reg src);
   void generate_math1_gen7(fs_inst *inst,
			    struct brw_reg dst,
			    struct brw_reg src);
   void generate_math2_gen7(fs_inst *inst,
			    struct brw_reg dst,
			    struct brw_reg src0,
			    struct brw_reg src1);
   void generate_math1_gen6(fs_inst *inst,
			    struct brw_reg dst,
			    struct brw_reg src);
   void generate_math2_gen6(fs_inst *inst,
			    struct brw_reg dst,
			    struct brw_reg src0,
			    struct brw_reg src1);
d727 1
a727 1
   void generate_ddx(fs_inst *inst, struct brw_reg dst, struct brw_reg src);
d729 1
a729 1
                     bool negate_value);
d749 6
d784 1
d790 1
d793 1
a793 1
   void patch_discard_jumps_to_fb_writes();
d799 3
a801 1
   struct brw_wm_compile *c;
d803 2
a804 2
   struct gl_shader_program *prog;
   const struct gl_fragment_program *fp;
d809 2
a810 1
   bool dual_source_output;
a811 82
};

/**
 * The fragment shader code generator.
 *
 * Translates FS IR to actual i965 assembly code.
 */
class gen8_fs_generator : public gen8_generator
{
public:
   gen8_fs_generator(struct brw_context *brw,
                     struct brw_wm_compile *c,
                     struct gl_shader_program *prog,
                     struct gl_fragment_program *fp,
                     bool dual_source_output);
   ~gen8_fs_generator();

   const unsigned *generate_assembly(exec_list *simd8_instructions,
                                     exec_list *simd16_instructions,
                                     unsigned *assembly_size);

private:
   void generate_code(exec_list *instructions);
   void generate_fb_write(fs_inst *inst);
   void generate_linterp(fs_inst *inst, struct brw_reg dst,
                         struct brw_reg *src);
   void generate_tex(fs_inst *inst, struct brw_reg dst, struct brw_reg src);
   void generate_math1(fs_inst *inst, struct brw_reg dst, struct brw_reg src);
   void generate_math2(fs_inst *inst, struct brw_reg dst,
                       struct brw_reg src0, struct brw_reg src1);
   void generate_ddx(fs_inst *inst, struct brw_reg dst, struct brw_reg src);
   void generate_ddy(fs_inst *inst, struct brw_reg dst, struct brw_reg src,
                     bool negate_value);
   void generate_scratch_write(fs_inst *inst, struct brw_reg src);
   void generate_scratch_read(fs_inst *inst, struct brw_reg dst);
   void generate_scratch_read_gen7(fs_inst *inst, struct brw_reg dst);
   void generate_uniform_pull_constant_load(fs_inst *inst,
                                            struct brw_reg dst,
                                            struct brw_reg index,
                                            struct brw_reg offset);
   void generate_varying_pull_constant_load(fs_inst *inst,
                                            struct brw_reg dst,
                                            struct brw_reg index,
                                            struct brw_reg offset);
   void generate_mov_dispatch_to_flags(fs_inst *ir);
   void generate_set_omask(fs_inst *ir,
                           struct brw_reg dst,
                           struct brw_reg sample_mask);
   void generate_set_sample_id(fs_inst *ir,
                               struct brw_reg dst,
                               struct brw_reg src0,
                               struct brw_reg src1);
   void generate_set_simd4x2_offset(fs_inst *ir,
                                    struct brw_reg dst,
                                    struct brw_reg offset);
   void generate_pack_half_2x16_split(fs_inst *inst,
                                      struct brw_reg dst,
                                      struct brw_reg x,
                                      struct brw_reg y);
   void generate_unpack_half_2x16_split(fs_inst *inst,
                                        struct brw_reg dst,
                                        struct brw_reg src);
   void generate_untyped_atomic(fs_inst *inst,
                                struct brw_reg dst,
                                struct brw_reg atomic_op,
                                struct brw_reg surf_index);

   void generate_untyped_surface_read(fs_inst *inst,
                                      struct brw_reg dst,
                                      struct brw_reg surf_index);
   void generate_discard_jump(fs_inst *ir);

   void patch_discard_jumps_to_fb_writes();

   struct brw_wm_compile *c;
   const struct gl_fragment_program *fp;

   unsigned dispatch_width; /** 8 or 16 */

   bool dual_source_output;

   exec_list discard_halt_patches;
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@a370 1
   bool try_constant_propagate(fs_inst *inst, acp_entry *entry);
@


1.4
log
@Merge Mesa 9.2.5
@
text
@d50 1
d54 2
d61 4
d67 1
a67 11
   /* Callers of this ralloc-based new need not call delete. It's
    * easier to just ralloc_free 'ctx' (or any of its ancestors). */
   static void* operator new(size_t size, void *ctx)
   {
      void *node;

      node = ralloc_size(ctx, size);
      assert(node != NULL);

      return node;
   }
d83 1
d85 6
d92 1
a92 1
   /** Register file: ARF, GRF, MRF, IMM. */
d94 2
d97 1
a97 1
    * Register number.  For ARF/MRF, it's the hardware register.  For
d100 1
a100 1
   int reg;
d102 5
a106 3
    * For virtual registers, this is a hardware register offset from
    * the start of the register block (for example, a constant index
    * in an array access).
d109 5
a113 7
   /** Register type.  BRW_REGISTER_TYPE_* */
   int type;
   bool negate;
   bool abs;
   bool sechalf;
   struct brw_reg fixed_hw_reg;
   int smear; /* -1, or a channel of the reg to smear to all channels. */
d122 2
d125 6
d133 36
d170 3
a172 2
static const fs_reg reg_null_f(ARF, BRW_ARF_NULL, BRW_REGISTER_TYPE_F);
static const fs_reg reg_null_d(ARF, BRW_ARF_NULL, BRW_REGISTER_TYPE_D);
d176 1
a176 9
   static void* operator new(size_t size, void *ctx)
   {
      void *node;

      node = rzalloc_size(ctx, size);
      assert(node != NULL);

      return node;
   }
d188 1
a188 11
   /* Callers of this ralloc-based new need not call delete. It's
    * easier to just ralloc_free 'ctx' (or any of its ancestors). */
   static void* operator new(size_t size, void *ctx)
   {
      void *node;

      node = rzalloc_size(ctx, size);
      assert(node != NULL);

      return node;
   }
d200 8
a207 4
   bool equals(fs_inst *inst);
   bool overwrites_reg(const fs_reg &reg);
   bool is_send_from_grf();
   bool is_partial_write();
a210 2
   bool saturate;
   int conditional_mod; /**< BRW_CONDITIONAL_* */
d212 2
a213 2
   /* Chooses which flag subregister (f0.0 or f0.1) is used for conditional
    * mod and predication.
d215 3
a217 1
   uint8_t flag_subreg;
a218 3
   int mlen; /**< SEND message length */
   int regs_written; /**< Number of vgrfs written by a SEND message, or 1 */
   int base_mrf; /**< First MRF in the SEND message, if mlen is nonzero. */
a219 8
   int sampler;
   int target; /**< MRT target. */
   bool eot;
   bool header_present;
   bool shadow_compare;
   bool force_uncompressed;
   bool force_sechalf;
   bool force_writemask_all;
d222 4
a225 2
   /** @@{
    * Annotation for the generated IR.  One of the two can be set.
d227 14
a240 3
   const void *ir;
   const char *annotation;
   /** @@} */
d280 2
d283 1
a287 1
   fs_inst *emit(fs_inst inst);
d327 4
d335 1
a335 1
					   fs_reg reg);
d337 3
a339 2
   exec_list VARYING_PULL_CONSTANT_LOAD(fs_reg dst, fs_reg surf_index,
                                        fs_reg varying_offset,
d343 1
d349 1
a349 1
   bool assign_regs();
d351 1
d361 3
a363 1
   void setup_pull_constants();
d365 1
d374 1
a375 1
   bool register_coalesce_2();
a377 2
   bool dead_code_eliminate_local();
   bool remove_dead_constants();
d380 1
a380 1
   void schedule_instructions(bool post_reg_alloc);
d384 1
d386 1
a390 2
   void push_force_sechalf();
   void pop_force_sechalf();
d396 1
a396 1
                         bool is_centroid);
d398 3
d404 1
d414 3
a416 1
                              fs_reg sample_index);
d420 4
a423 3
   void emit_lrp(fs_reg dst, fs_reg x, fs_reg y, fs_reg a);
   void emit_minmax(uint32_t conditionalmod, fs_reg dst,
                    fs_reg src0, fs_reg src1);
d425 5
a429 1
   bool try_emit_mad(ir_expression *ir, int mul_arg);
d432 2
a433 1
   void emit_unspill(fs_inst *inst, fs_reg reg, uint32_t spill_offset);
d467 7
d491 1
d494 2
d500 1
a500 1
   int param_size[MAX_UNIFORMS * 4];
d507 12
a518 1
   bool live_intervals_valid;
d520 3
a522 4
   /* This is the map from UNIFORM hw_reg + reg_offset as generated by
    * the visitor to the packed uniform number after
    * remove_dead_constants() that represents the actual uploaded
    * uniform index.
d524 1
a524 2
   int *params_remap;
   int nr_params_remap;
d528 1
d532 1
a535 1
   int urb_setup[VARYING_SLOT_MAX];
d547 2
d562 1
a566 1
   int force_sechalf_stack;
d586 2
a587 1
                                     unsigned *assembly_size);
d590 1
a590 1
   void generate_code(exec_list *instructions);
d592 1
d620 3
a622 2
   void generate_spill(fs_inst *inst, struct brw_reg src);
   void generate_unspill(fs_inst *inst, struct brw_reg dst);
d638 10
d666 9
a683 1
   struct gl_shader *shader;
d693 82
d778 2
@


1.3
log
@Merge Mesa 9.2.0
@
text
@d398 1
@


1.2
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d28 4
d48 1
d50 2
a51 38
#include "../glsl/glsl_types.h"
#include "../glsl/ir.h"

enum register_file {
   ARF = BRW_ARCHITECTURE_REGISTER_FILE,
   GRF = BRW_GENERAL_REGISTER_FILE,
   MRF = BRW_MESSAGE_REGISTER_FILE,
   IMM = BRW_IMMEDIATE_VALUE,
   FIXED_HW_REG, /* a struct brw_reg */
   UNIFORM, /* prog_data->params[hw_reg] */
   BAD_FILE
};

enum fs_opcodes {
   FS_OPCODE_FB_WRITE = 256,
   FS_OPCODE_RCP,
   FS_OPCODE_RSQ,
   FS_OPCODE_SQRT,
   FS_OPCODE_EXP2,
   FS_OPCODE_LOG2,
   FS_OPCODE_POW,
   FS_OPCODE_SIN,
   FS_OPCODE_COS,
   FS_OPCODE_DDX,
   FS_OPCODE_DDY,
   FS_OPCODE_PIXEL_X,
   FS_OPCODE_PIXEL_Y,
   FS_OPCODE_CINTERP,
   FS_OPCODE_LINTERP,
   FS_OPCODE_TEX,
   FS_OPCODE_TXB,
   FS_OPCODE_TXD,
   FS_OPCODE_TXL,
   FS_OPCODE_DISCARD,
   FS_OPCODE_SPILL,
   FS_OPCODE_UNSPILL,
   FS_OPCODE_PULL_CONSTANT_LOAD,
};
d53 4
d72 1
a72 40
   void init()
   {
      memset(this, 0, sizeof(*this));
      this->hw_reg = -1;
      this->smear = -1;
   }

   /** Generic unset register constructor. */
   fs_reg()
   {
      init();
      this->file = BAD_FILE;
   }

   /** Immediate value constructor. */
   fs_reg(float f)
   {
      init();
      this->file = IMM;
      this->type = BRW_REGISTER_TYPE_F;
      this->imm.f = f;
   }

   /** Immediate value constructor. */
   fs_reg(int32_t i)
   {
      init();
      this->file = IMM;
      this->type = BRW_REGISTER_TYPE_D;
      this->imm.i = i;
   }

   /** Immediate value constructor. */
   fs_reg(uint32_t u)
   {
      init();
      this->file = IMM;
      this->type = BRW_REGISTER_TYPE_UD;
      this->imm.u = u;
   }
d74 7
a80 11
   /** Fixed brw_reg Immediate value constructor. */
   fs_reg(struct brw_reg fixed_hw_reg)
   {
      init();
      this->file = FIXED_HW_REG;
      this->fixed_hw_reg = fixed_hw_reg;
      this->type = fixed_hw_reg.type;
   }

   fs_reg(enum register_file file, int hw_reg);
   fs_reg(enum register_file file, int hw_reg, uint32_t type);
d83 4
a86 14
   bool equals(fs_reg *r)
   {
      return (file == r->file &&
	      reg == r->reg &&
	      reg_offset == r->reg_offset &&
	      hw_reg == r->hw_reg &&
	      type == r->type &&
	      negate == r->negate &&
	      abs == r->abs &&
	      memcmp(&fixed_hw_reg, &r->fixed_hw_reg,
		     sizeof(fixed_hw_reg)) == 0 &&
	      smear == r->smear &&
	      imm.u == r->imm.u);
   }
d90 4
a93 1
   /** virtual register number.  0 = fixed hw reg */
d95 5
a99 1
   /** Offset within the virtual register. */
a100 2
   /** HW register number.  Generally unset until register allocation. */
   int hw_reg;
d109 1
a109 1
   /** Value for file == BRW_IMMMEDIATE_FILE */
d115 2
d123 1
a123 1
class fs_inst : public exec_node {
a124 2
   /* Callers of this ralloc-based new need not call delete. It's
    * easier to just ralloc_free 'ctx' (or any of its ancestors). */
d135 1
a135 1
   void init()
d137 1
a137 8
      memset(this, 0, sizeof(*this));
      this->opcode = BRW_OPCODE_NOP;
      this->conditional_mod = BRW_CONDITIONAL_NONE;

      this->dst = reg_undef;
      this->src[0] = reg_undef;
      this->src[1] = reg_undef;
      this->src[2] = reg_undef;
d140 2
a141 4
   fs_inst()
   {
      init();
   }
d143 5
a147 1
   fs_inst(int opcode)
d149 1
a149 3
      init();
      this->opcode = opcode;
   }
d151 2
a152 5
   fs_inst(int opcode, fs_reg dst)
   {
      init();
      this->opcode = opcode;
      this->dst = dst;
d154 1
a154 15
      if (dst.file == GRF)
	 assert(dst.reg_offset >= 0);
   }

   fs_inst(int opcode, fs_reg dst, fs_reg src0)
   {
      init();
      this->opcode = opcode;
      this->dst = dst;
      this->src[0] = src0;

      if (dst.file == GRF)
	 assert(dst.reg_offset >= 0);
      if (src[0].file == GRF)
	 assert(src[0].reg_offset >= 0);
d157 1
a157 15
   fs_inst(int opcode, fs_reg dst, fs_reg src0, fs_reg src1)
   {
      init();
      this->opcode = opcode;
      this->dst = dst;
      this->src[0] = src0;
      this->src[1] = src1;

      if (dst.file == GRF)
	 assert(dst.reg_offset >= 0);
      if (src[0].file == GRF)
	 assert(src[0].reg_offset >= 0);
      if (src[1].file == GRF)
	 assert(src[1].reg_offset >= 0);
   }
d159 12
a170 18
   fs_inst(int opcode, fs_reg dst, fs_reg src0, fs_reg src1, fs_reg src2)
   {
      init();
      this->opcode = opcode;
      this->dst = dst;
      this->src[0] = src0;
      this->src[1] = src1;
      this->src[2] = src2;

      if (dst.file == GRF)
	 assert(dst.reg_offset >= 0);
      if (src[0].file == GRF)
	 assert(src[0].reg_offset >= 0);
      if (src[1].file == GRF)
	 assert(src[1].reg_offset >= 0);
      if (src[2].file == GRF)
	 assert(src[2].reg_offset >= 0);
   }
a171 41
   bool equals(fs_inst *inst)
   {
      return (opcode == inst->opcode &&
	      dst.equals(&inst->dst) &&
	      src[0].equals(&inst->src[0]) &&
	      src[1].equals(&inst->src[1]) &&
	      src[2].equals(&inst->src[2]) &&
	      saturate == inst->saturate &&
	      predicated == inst->predicated &&
	      conditional_mod == inst->conditional_mod &&
	      mlen == inst->mlen &&
	      base_mrf == inst->base_mrf &&
	      sampler == inst->sampler &&
	      target == inst->target &&
	      eot == inst->eot &&
	      header_present == inst->header_present &&
	      shadow_compare == inst->shadow_compare &&
	      offset == inst->offset);
   }

   bool is_tex()
   {
      return (opcode == FS_OPCODE_TEX ||
	      opcode == FS_OPCODE_TXB ||
	      opcode == FS_OPCODE_TXD ||
	      opcode == FS_OPCODE_TXL);
   }

   bool is_math()
   {
      return (opcode == FS_OPCODE_RCP ||
	      opcode == FS_OPCODE_RSQ ||
	      opcode == FS_OPCODE_SQRT ||
	      opcode == FS_OPCODE_EXP2 ||
	      opcode == FS_OPCODE_LOG2 ||
	      opcode == FS_OPCODE_SIN ||
	      opcode == FS_OPCODE_COS ||
	      opcode == FS_OPCODE_POW);
   }

   int opcode; /* BRW_OPCODE_* or FS_OPCODE_* */
a174 2
   bool predicated;
   bool predicate_inverse;
d177 5
d183 1
d185 1
d193 1
d199 1
a199 1
   ir_instruction *ir;
d204 6
a209 1
class fs_visitor : public ir_visitor
d213 6
a218 59
   fs_visitor(struct brw_wm_compile *c, struct gl_shader_program *prog,
	      struct brw_shader *shader)
   {
      this->c = c;
      this->p = &c->func;
      this->brw = p->brw;
      this->fp = prog->FragmentProgram;
      this->prog = prog;
      this->intel = &brw->intel;
      this->ctx = &intel->ctx;
      this->mem_ctx = ralloc_context(NULL);
      this->shader = shader;
      this->failed = false;
      this->variable_ht = hash_table_ctor(0,
					  hash_table_pointer_hash,
					  hash_table_pointer_compare);

      /* There's a question that appears to be left open in the spec:
       * How do implicit dst conversions interact with the CMP
       * instruction or conditional mods?  On gen6, the instruction:
       *
       * CMP null<d> src0<f> src1<f>
       *
       * will do src1 - src0 and compare that result as if it was an
       * integer.  On gen4, it will do src1 - src0 as float, convert
       * the result to int, and compare as int.  In between, it
       * appears that it does src1 - src0 and does the compare in the
       * execution type so dst type doesn't matter.
       */
      if (this->intel->gen > 4)
	 this->reg_null_cmp = reg_null_d;
      else
	 this->reg_null_cmp = reg_null_f;

      this->frag_color = NULL;
      this->frag_data = NULL;
      this->frag_depth = NULL;
      this->first_non_payload_grf = 0;

      this->current_annotation = NULL;
      this->base_ir = NULL;

      this->virtual_grf_sizes = NULL;
      this->virtual_grf_next = 1;
      this->virtual_grf_array_size = 0;
      this->virtual_grf_def = NULL;
      this->virtual_grf_use = NULL;
      this->live_intervals_valid = false;

      this->kill_emitted = false;
      this->force_uncompressed_stack = 0;
      this->force_sechalf_stack = 0;
   }

   ~fs_visitor()
   {
      ralloc_free(this->mem_ctx);
      hash_table_dtor(this->variable_ht);
   }
d222 1
a222 1
   void import_uniforms(struct hash_table *src_variable_ht);
d244 2
d247 2
d250 36
a285 24
   fs_inst *emit(int opcode)
   {
      return emit(fs_inst(opcode));
   }

   fs_inst *emit(int opcode, fs_reg dst)
   {
      return emit(fs_inst(opcode, dst));
   }

   fs_inst *emit(int opcode, fs_reg dst, fs_reg src0)
   {
      return emit(fs_inst(opcode, dst, src0));
   }

   fs_inst *emit(int opcode, fs_reg dst, fs_reg src0, fs_reg src1)
   {
      return emit(fs_inst(opcode, dst, src0, src1));
   }

   fs_inst *emit(int opcode, fs_reg dst, fs_reg src0, fs_reg src1, fs_reg src2)
   {
      return emit(fs_inst(opcode, dst, src0, src1, src2));
   }
d288 7
d297 2
a298 1
   void setup_paramvalues_refs();
d304 4
d311 2
d315 8
a322 1
   bool propagate_constants();
d324 1
d327 2
d331 4
a334 1
   void schedule_instructions();
d336 1
a342 14
   void generate_code();
   void generate_fb_write(fs_inst *inst);
   void generate_pixel_xy(struct brw_reg dst, bool is_x);
   void generate_linterp(fs_inst *inst, struct brw_reg dst,
			 struct brw_reg *src);
   void generate_tex(fs_inst *inst, struct brw_reg dst, struct brw_reg src);
   void generate_math(fs_inst *inst, struct brw_reg dst, struct brw_reg *src);
   void generate_discard(fs_inst *inst);
   void generate_ddx(fs_inst *inst, struct brw_reg dst, struct brw_reg src);
   void generate_ddy(fs_inst *inst, struct brw_reg dst, struct brw_reg src);
   void generate_spill(fs_inst *inst, struct brw_reg src);
   void generate_unspill(fs_inst *inst, struct brw_reg dst);
   void generate_pull_constant_load(fs_inst *inst, struct brw_reg dst);

d345 3
d352 2
d355 1
a355 1
			      int sampler);
d357 2
a358 1
			      int sampler);
d360 8
a367 3
			      int sampler);
   fs_inst *emit_math(fs_opcodes op, fs_reg dst, fs_reg src0);
   fs_inst *emit_math(fs_opcodes op, fs_reg dst, fs_reg src0, fs_reg src1);
d369 1
d374 24
a397 1
   void emit_color_write(int index, int first_color_mrf, fs_reg color);
d399 11
d412 4
d418 1
a418 1
   int setup_uniform_values(int loc, const glsl_type *type);
d422 3
a424 4
   struct brw_context *brw;
   const struct gl_fragment_program *fp;
   struct intel_context *intel;
   struct gl_context *ctx;
d426 1
a426 5
   struct brw_compile *p;
   struct brw_shader *shader;
   struct gl_shader_program *prog;
   void *mem_ctx;
   exec_list instructions;
d428 1
a428 5
   /* Delayed setup of c->prog_data.params[] due to realloc of
    * ParamValues[] during compile.
    */
   int param_index[MAX_UNIFORMS * 4];
   int param_offset[MAX_UNIFORMS * 4];
d431 1
a431 1
   int virtual_grf_next;
d433 2
a434 2
   int *virtual_grf_def;
   int *virtual_grf_use;
d437 8
d446 4
a449 1
   ir_variable *frag_color, *frag_data, *frag_depth;
d451 6
a456 2
   int urb_setup[FRAG_ATTRIB_MAX];
   bool kill_emitted;
d460 1
a460 1
   ir_instruction *base_ir;
d466 1
a466 4
   /* On entry to a visit() method, this is the storage for the
    * result.  On exit, the visit() called may have changed it, in
    * which case the parent must use the new storage instead.
    */
d473 3
a475 3
   fs_reg delta_x;
   fs_reg delta_y;
   fs_reg reg_null_cmp;
d479 2
d485 105
a589 2
GLboolean brw_do_channel_expressions(struct exec_list *instructions);
GLboolean brw_do_vector_splitting(struct exec_list *instructions);
@


1.1
log
@Initial revision
@
text
@d70 2
d76 1
d78 1
a78 2
   FS_OPCODE_DISCARD_NOT,
   FS_OPCODE_DISCARD_AND,
d180 1
d311 8
d336 1
d346 2
d362 2
a363 1
   fs_visitor(struct brw_wm_compile *c, struct brw_shader *shader)
d368 2
a369 1
      this->fp = brw->fragment_program;
d374 1
a374 1
      this->fail = false;
d409 1
d412 2
d424 1
d444 2
d447 29
d493 8
d503 1
d506 1
a506 1
   void generate_tex(fs_inst *inst, struct brw_reg dst);
d508 1
a508 2
   void generate_discard_not(fs_inst *inst, struct brw_reg temp);
   void generate_discard_and(fs_inst *inst, struct brw_reg temp);
d521 6
a526 2
   fs_inst *emit_texture_gen4(ir_texture *ir, fs_reg dst, fs_reg coordinate);
   fs_inst *emit_texture_gen5(ir_texture *ir, fs_reg dst, fs_reg coordinate);
d534 1
d551 1
d566 1
d579 2
a580 1
   bool fail;
d582 4
a585 1
   /* Result of last visit() method. */
d597 3
d604 1
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a27 4
#pragma once

#include "brw_shader.h"

a43 1
#include "brw_shader.h"
d45 36
a80 2
#include "glsl/glsl_types.h"
#include "glsl/ir.h"
a81 4
class bblock_t;
namespace {
   struct acp_entry;
}
d97 49
a145 1
   void init();
d147 2
a148 7
   fs_reg();
   fs_reg(float f);
   fs_reg(int32_t i);
   fs_reg(uint32_t u);
   fs_reg(struct brw_reg fixed_hw_reg);
   fs_reg(enum register_file file, int reg);
   fs_reg(enum register_file file, int reg, uint32_t type);
d151 14
a164 4
   bool equals(const fs_reg &r) const;
   bool is_zero() const;
   bool is_one() const;
   bool is_valid_3src() const;
d168 1
a168 4
   /**
    * Register number.  For ARF/MRF, it's the hardware register.  For
    * GRF, it's a virtual register number until register allocation
    */
d170 1
a170 5
   /**
    * For virtual registers, this is a hardware register offset from
    * the start of the register block (for example, a constant index
    * in an array access).
    */
d172 2
a177 1
   bool sechalf;
d181 1
a181 1
   /** Value for file == IMM */
a186 2

   fs_reg *reladdr;
d193 1
a193 1
class ip_record : public exec_node {
d195 2
d207 1
a207 1
   ip_record(int ip)
d209 8
a216 1
      this->ip = ip;
d219 10
a228 2
   int ip;
};
d230 1
a230 5
class fs_inst : public backend_instruction {
public:
   /* Callers of this ralloc-based new need not call delete. It's
    * easier to just ralloc_free 'ctx' (or any of its ancestors). */
   static void* operator new(size_t size, void *ctx)
d232 7
a238 1
      void *node;
d240 12
a251 2
      node = rzalloc_size(ctx, size);
      assert(node != NULL);
d253 14
a266 1
      return node;
d269 18
a286 1
   void init();
d288 19
a306 12
   fs_inst();
   fs_inst(enum opcode opcode);
   fs_inst(enum opcode opcode, fs_reg dst);
   fs_inst(enum opcode opcode, fs_reg dst, fs_reg src0);
   fs_inst(enum opcode opcode, fs_reg dst, fs_reg src0, fs_reg src1);
   fs_inst(enum opcode opcode, fs_reg dst,
           fs_reg src0, fs_reg src1,fs_reg src2);

   bool equals(fs_inst *inst);
   bool overwrites_reg(const fs_reg &reg);
   bool is_send_from_grf();
   bool is_partial_write();
d308 13
d324 1
a326 5
   /* Chooses which flag subregister (f0.0 or f0.1) is used for conditional
    * mod and predication.
    */
   uint8_t flag_subreg;

a327 1
   int regs_written; /**< Number of vgrfs written by a SEND message, or 1 */
a328 1
   uint32_t texture_offset; /**< Texture offset bitfield */
a333 3
   bool force_uncompressed;
   bool force_sechalf;
   bool force_writemask_all;
d339 1
a339 1
   const void *ir;
d344 1
a344 6
/**
 * The fragment shader front-end.
 *
 * Translates either GLSL IR or Mesa IR (for ARB_fragment_program) into FS IR.
 */
class fs_visitor : public backend_visitor
d348 54
a401 6
   fs_visitor(struct brw_context *brw,
              struct brw_wm_compile *c,
              struct gl_shader_program *shader_prog,
              struct gl_fragment_program *fp,
              unsigned dispatch_width);
   ~fs_visitor();
a404 1
   void import_uniforms(fs_visitor *v);
a423 4
   void swizzle_result(ir_texture *ir, fs_reg orig_val, int sampler);

   bool can_do_source_mods(fs_inst *inst);

d425 1
a425 52
   fs_inst *emit(fs_inst *inst);
   void emit(exec_list list);

   fs_inst *emit(enum opcode opcode);
   fs_inst *emit(enum opcode opcode, fs_reg dst);
   fs_inst *emit(enum opcode opcode, fs_reg dst, fs_reg src0);
   fs_inst *emit(enum opcode opcode, fs_reg dst, fs_reg src0, fs_reg src1);
   fs_inst *emit(enum opcode opcode, fs_reg dst,
                 fs_reg src0, fs_reg src1, fs_reg src2);

   fs_inst *MOV(fs_reg dst, fs_reg src);
   fs_inst *NOT(fs_reg dst, fs_reg src);
   fs_inst *RNDD(fs_reg dst, fs_reg src);
   fs_inst *RNDE(fs_reg dst, fs_reg src);
   fs_inst *RNDZ(fs_reg dst, fs_reg src);
   fs_inst *FRC(fs_reg dst, fs_reg src);
   fs_inst *ADD(fs_reg dst, fs_reg src0, fs_reg src1);
   fs_inst *MUL(fs_reg dst, fs_reg src0, fs_reg src1);
   fs_inst *MACH(fs_reg dst, fs_reg src0, fs_reg src1);
   fs_inst *MAC(fs_reg dst, fs_reg src0, fs_reg src1);
   fs_inst *SHL(fs_reg dst, fs_reg src0, fs_reg src1);
   fs_inst *SHR(fs_reg dst, fs_reg src0, fs_reg src1);
   fs_inst *ASR(fs_reg dst, fs_reg src0, fs_reg src1);
   fs_inst *AND(fs_reg dst, fs_reg src0, fs_reg src1);
   fs_inst *OR(fs_reg dst, fs_reg src0, fs_reg src1);
   fs_inst *XOR(fs_reg dst, fs_reg src0, fs_reg src1);
   fs_inst *IF(uint32_t predicate);
   fs_inst *IF(fs_reg src0, fs_reg src1, uint32_t condition);
   fs_inst *CMP(fs_reg dst, fs_reg src0, fs_reg src1,
                uint32_t condition);
   fs_inst *LRP(fs_reg dst, fs_reg a, fs_reg y, fs_reg x);
   fs_inst *DEP_RESOLVE_MOV(int grf);
   fs_inst *BFREV(fs_reg dst, fs_reg value);
   fs_inst *BFE(fs_reg dst, fs_reg bits, fs_reg offset, fs_reg value);
   fs_inst *BFI1(fs_reg dst, fs_reg bits, fs_reg offset);
   fs_inst *BFI2(fs_reg dst, fs_reg bfi1_dst, fs_reg insert, fs_reg base);
   fs_inst *FBH(fs_reg dst, fs_reg value);
   fs_inst *FBL(fs_reg dst, fs_reg value);
   fs_inst *CBIT(fs_reg dst, fs_reg value);

   int type_size(const struct glsl_type *type);
   fs_inst *get_instruction_generating_reg(fs_inst *start,
					   fs_inst *end,
					   fs_reg reg);

   exec_list VARYING_PULL_CONSTANT_LOAD(fs_reg dst, fs_reg surf_index,
                                        fs_reg varying_offset,
                                        uint32_t const_offset);

   bool run();
   void setup_payload_gen4();
   void setup_payload_gen6();
a430 4
   void setup_payload_interference(struct ra_graph *g, int payload_reg_count,
                                   int first_payload_node);
   void setup_mrf_hack_interference(struct ra_graph *g,
                                    int first_mrf_hack_node);
a433 2
   void compact_virtual_grfs();
   void move_uniform_array_access_to_pull_constants();
d436 1
a436 8
   bool opt_algebraic();
   bool opt_cse();
   bool opt_cse_local(bblock_t *block, exec_list *aeb);
   bool opt_copy_propagate();
   bool try_copy_propagate(fs_inst *inst, int arg, acp_entry *entry);
   bool try_constant_propagate(fs_inst *inst, acp_entry *entry);
   bool opt_copy_propagate_local(void *mem_ctx, bblock_t *block,
                                 exec_list *acp);
a437 1
   bool register_coalesce_2();
a439 2
   bool dead_code_eliminate_local();
   bool remove_dead_constants();
d442 13
a454 11
   void schedule_instructions(bool post_reg_alloc);
   void insert_gen4_send_dependency_workarounds();
   void insert_gen4_pre_send_dependency_workarounds(fs_inst *inst);
   void insert_gen4_post_send_dependency_workarounds(fs_inst *inst);
   void fail(const char *msg, ...);
   void lower_uniform_pull_constant_loads();

   void push_force_uncompressed();
   void pop_force_uncompressed();
   void push_force_sechalf();
   void pop_force_sechalf();
a457 3
   fs_inst *emit_linterp(const fs_reg &attr, const fs_reg &interp,
                         glsl_interp_qualifier interpolation_mode,
                         bool is_centroid);
d462 4
a465 16
   fs_reg rescale_texcoord(ir_texture *ir, fs_reg coordinate,
                           bool is_rect, int sampler, int texunit);
   fs_inst *emit_texture_gen4(ir_texture *ir, fs_reg dst, fs_reg coordinate,
			      fs_reg shadow_comp, fs_reg lod, fs_reg lod2);
   fs_inst *emit_texture_gen5(ir_texture *ir, fs_reg dst, fs_reg coordinate,
                              fs_reg shadow_comp, fs_reg lod, fs_reg lod2,
                              fs_reg sample_index);
   fs_inst *emit_texture_gen7(ir_texture *ir, fs_reg dst, fs_reg coordinate,
                              fs_reg shadow_comp, fs_reg lod, fs_reg lod2,
                              fs_reg sample_index);
   fs_reg fix_math_operand(fs_reg src);
   fs_inst *emit_math(enum opcode op, fs_reg dst, fs_reg src0);
   fs_inst *emit_math(enum opcode op, fs_reg dst, fs_reg src0, fs_reg src1);
   void emit_lrp(fs_reg dst, fs_reg x, fs_reg y, fs_reg a);
   void emit_minmax(uint32_t conditionalmod, fs_reg dst,
                    fs_reg src0, fs_reg src1);
a466 1
   bool try_emit_mad(ir_expression *ir, int mul_arg);
a470 24
   void emit_fragment_program_code();
   void setup_fp_regs();
   fs_reg get_fp_src_reg(const prog_src_register *src);
   fs_reg get_fp_dst_reg(const prog_dst_register *dst);
   void emit_fp_alu1(enum opcode opcode,
                     const struct prog_instruction *fpi,
                     fs_reg dst, fs_reg src);
   void emit_fp_alu2(enum opcode opcode,
                     const struct prog_instruction *fpi,
                     fs_reg dst, fs_reg src0, fs_reg src1);
   void emit_fp_scalar_write(const struct prog_instruction *fpi,
                             fs_reg dst, fs_reg src);
   void emit_fp_scalar_math(enum opcode opcode,
                            const struct prog_instruction *fpi,
                            fs_reg dst, fs_reg src);

   void emit_fp_minmax(const struct prog_instruction *fpi,
                       fs_reg dst, fs_reg src0, fs_reg src1);

   void emit_fp_sop(uint32_t conditional_mod,
                    const struct prog_instruction *fpi,
                    fs_reg dst, fs_reg src0, fs_reg src1, fs_reg one);

   void emit_color_write(int target, int index, int first_color_mrf);
a471 11

   void emit_shader_time_begin();
   void emit_shader_time_end();
   void emit_shader_time_write(enum shader_time_shader_type type,
                               fs_reg value);

   bool try_rewrite_rhs_to_dst(ir_assignment *ir,
			       fs_reg dst,
			       fs_reg src,
			       fs_inst *pre_rhs_inst,
			       fs_inst *last_rhs_inst);
a473 4
   void resolve_ud_negate(fs_reg *reg);
   void resolve_bool_comparison(ir_rvalue *rvalue, fs_reg *reg);

   fs_reg get_timestamp();
d476 1
a476 1
   void setup_uniform_values(ir_variable *ir);
d480 4
a483 3
   void dump_instruction(backend_instruction *inst);

   struct gl_fragment_program *fp;
d485 4
a488 1
   unsigned int sanity_param_count;
d490 5
a494 1
   int param_size[MAX_UNIFORMS * 4];
d497 1
a497 1
   int virtual_grf_count;
d499 2
a500 11
   int *virtual_grf_start;
   int *virtual_grf_end;
   bool live_intervals_valid;

   /* This is the map from UNIFORM hw_reg + reg_offset as generated by
    * the visitor to the packed uniform number after
    * remove_dead_constants() that represents the actual uploaded
    * uniform index.
    */
   int *params_remap;
   int nr_params_remap;
d503 1
a503 4
   fs_reg frag_depth;
   fs_reg outputs[BRW_MAX_DRAW_BUFFERS];
   unsigned output_components[BRW_MAX_DRAW_BUFFERS];
   fs_reg dual_src_output;
d505 2
a506 6
   /** Either BRW_MAX_GRF or GEN7_MRF_HACK_START */
   int max_grf;
   int urb_setup[VARYING_SLOT_MAX];

   fs_reg *fp_temp_regs;
   fs_reg *fp_input_regs;
d510 1
a510 1
   const void *base_ir;
d513 1
a513 2
   bool failed;
   char *fail_msg;
d522 3
a524 3
   fs_reg delta_x[BRW_WM_BARYCENTRIC_INTERP_MODE_COUNT];
   fs_reg delta_y[BRW_WM_BARYCENTRIC_INTERP_MODE_COUNT];
   fs_reg shader_start_time;
a526 108

   const unsigned dispatch_width; /**< 8 or 16 */

   int force_uncompressed_stack;
   int force_sechalf_stack;
};

/**
 * The fragment shader code generator.
 *
 * Translates FS IR to actual i965 assembly code.
 */
class fs_generator
{
public:
   fs_generator(struct brw_context *brw,
                struct brw_wm_compile *c,
                struct gl_shader_program *prog,
                struct gl_fragment_program *fp,
                bool dual_source_output);
   ~fs_generator();

   const unsigned *generate_assembly(exec_list *simd8_instructions,
                                     exec_list *simd16_instructions,
                                     unsigned *assembly_size);

private:
   void generate_code(exec_list *instructions);
   void generate_fb_write(fs_inst *inst);
   void generate_pixel_xy(struct brw_reg dst, bool is_x);
   void generate_linterp(fs_inst *inst, struct brw_reg dst,
			 struct brw_reg *src);
   void generate_tex(fs_inst *inst, struct brw_reg dst, struct brw_reg src);
   void generate_math1_gen7(fs_inst *inst,
			    struct brw_reg dst,
			    struct brw_reg src);
   void generate_math2_gen7(fs_inst *inst,
			    struct brw_reg dst,
			    struct brw_reg src0,
			    struct brw_reg src1);
   void generate_math1_gen6(fs_inst *inst,
			    struct brw_reg dst,
			    struct brw_reg src);
   void generate_math2_gen6(fs_inst *inst,
			    struct brw_reg dst,
			    struct brw_reg src0,
			    struct brw_reg src1);
   void generate_math_gen4(fs_inst *inst,
			   struct brw_reg dst,
			   struct brw_reg src);
   void generate_math_g45(fs_inst *inst,
			  struct brw_reg dst,
			  struct brw_reg src);
   void generate_ddx(fs_inst *inst, struct brw_reg dst, struct brw_reg src);
   void generate_ddy(fs_inst *inst, struct brw_reg dst, struct brw_reg src,
                     bool negate_value);
   void generate_spill(fs_inst *inst, struct brw_reg src);
   void generate_unspill(fs_inst *inst, struct brw_reg dst);
   void generate_uniform_pull_constant_load(fs_inst *inst, struct brw_reg dst,
                                            struct brw_reg index,
                                            struct brw_reg offset);
   void generate_uniform_pull_constant_load_gen7(fs_inst *inst,
                                                 struct brw_reg dst,
                                                 struct brw_reg surf_index,
                                                 struct brw_reg offset);
   void generate_varying_pull_constant_load(fs_inst *inst, struct brw_reg dst,
                                            struct brw_reg index,
                                            struct brw_reg offset);
   void generate_varying_pull_constant_load_gen7(fs_inst *inst,
                                                 struct brw_reg dst,
                                                 struct brw_reg index,
                                                 struct brw_reg offset);
   void generate_mov_dispatch_to_flags(fs_inst *inst);
   void generate_set_simd4x2_offset(fs_inst *inst,
                                    struct brw_reg dst,
                                    struct brw_reg offset);
   void generate_discard_jump(fs_inst *inst);

   void generate_pack_half_2x16_split(fs_inst *inst,
                                      struct brw_reg dst,
                                      struct brw_reg x,
                                      struct brw_reg y);
   void generate_unpack_half_2x16_split(fs_inst *inst,
                                        struct brw_reg dst,
                                        struct brw_reg src);

   void generate_shader_time_add(fs_inst *inst,
                                 struct brw_reg payload,
                                 struct brw_reg offset,
                                 struct brw_reg value);

   void patch_discard_jumps_to_fb_writes();

   struct brw_context *brw;
   struct gl_context *ctx;

   struct brw_compile *p;
   struct brw_wm_compile *c;

   struct gl_shader_program *prog;
   struct gl_shader *shader;
   const struct gl_fragment_program *fp;

   unsigned dispatch_width; /**< 8 or 16 */

   exec_list discard_halt_patches;
   bool dual_source_output;
   void *mem_ctx;
d529 2
a530 3
bool brw_do_channel_expressions(struct exec_list *instructions);
bool brw_do_vector_splitting(struct exec_list *instructions);
bool brw_fs_precompile(struct gl_context *ctx, struct gl_shader_program *prog);
@


1.1.1.3
log
@Import Mesa 9.2.5
@
text
@a397 1
   void emit_alpha_test();
@


1.1.1.4
log
@Import Mesa 10.2.3
@
text
@a49 1
#include "gen8_generator.h"
a52 2
#define MAX_SAMPLER_MESSAGE_SIZE 11

a57 4
namespace brw {
   class fs_live_variables;
}

d60 11
a70 1
   DECLARE_RALLOC_CXX_OPERATORS(fs_reg)
a85 1
   bool is_null() const;
a86 6
   bool is_contiguous() const;
   bool is_accumulator() const;

   fs_reg &apply_stride(unsigned stride);
   /** Smear a channel of the reg to all channels. */
   fs_reg &set_smear(unsigned subreg);
d88 1
a88 1
   /** Register file: GRF, MRF, IMM. */
a89 2
   /** Register type.  BRW_REGISTER_TYPE_* */
   uint8_t type;
d91 1
a91 1
    * Register number.  For MRF, it's the hardware register.  For
d94 1
a94 1
   uint16_t reg;
d96 3
a98 5
    * Offset from the start of the contiguous register block.
    *
    * For pre-register-allocation GRFs, this is in units of a float per pixel
    * (1 hardware register for SIMD8 mode, or 2 registers for SIMD16 mode).
    * For uniforms, this is in units of 1 float.
d101 7
a107 5
   /**
    * Offset in bytes from the start of the register.  Values up to a
    * backend_reg::reg_offset unit are valid.
    */
   int subreg_offset;
a115 2
   struct brw_reg fixed_hw_reg;

a116 6

   bool negate;
   bool abs;

   /** Register region horizontal stride */
   uint8_t stride;
a118 36
static inline fs_reg
retype(fs_reg reg, unsigned type)
{
   reg.fixed_hw_reg.type = reg.type = type;
   return reg;
}

static inline fs_reg
offset(fs_reg reg, unsigned delta)
{
   assert(delta == 0 || (reg.file != HW_REG && reg.file != IMM));
   reg.reg_offset += delta;
   return reg;
}

static inline fs_reg
byte_offset(fs_reg reg, unsigned delta)
{
   assert(delta == 0 || (reg.file != HW_REG && reg.file != IMM));
   reg.subreg_offset += delta;
   return reg;
}

/**
 * Get either of the 8-component halves of a 16-component register.
 *
 * Note: this also works if \c reg represents a SIMD16 pair of registers.
 */
static inline fs_reg
half(const fs_reg &reg, unsigned idx)
{
   assert(idx < 2);
   assert(idx == 0 || (reg.file != HW_REG && reg.file != IMM));
   return byte_offset(reg, 8 * idx * reg.stride * type_sz(reg.type));
}

d120 2
a121 3
static const fs_reg reg_null_f(retype(brw_null_reg(), BRW_REGISTER_TYPE_F));
static const fs_reg reg_null_d(retype(brw_null_reg(), BRW_REGISTER_TYPE_D));
static const fs_reg reg_null_ud(retype(brw_null_reg(), BRW_REGISTER_TYPE_UD));
d125 9
a133 1
   DECLARE_RALLOC_CXX_OPERATORS(ip_record)
d145 11
a155 1
   DECLARE_RALLOC_CXX_OPERATORS(fs_inst)
d167 4
a170 8
   bool equals(fs_inst *inst) const;
   bool overwrites_reg(const fs_reg &reg) const;
   bool is_send_from_grf() const;
   bool is_partial_write() const;
   int regs_read(fs_visitor *v, int arg) const;

   bool reads_flag() const;
   bool writes_flag() const;
d174 21
a201 23

   uint32_t texture_offset; /**< Texture offset bitfield */
   uint32_t offset; /* spill/unspill offset */

   uint8_t conditional_mod; /**< BRW_CONDITIONAL_* */

   /* Chooses which flag subregister (f0.0 or f0.1) is used for conditional
    * mod and predication.
    */
   uint8_t flag_subreg;

   uint8_t mlen; /**< SEND message length */
   uint8_t regs_written; /**< Number of vgrfs written by a SEND message, or 1 */
   int8_t base_mrf; /**< First MRF in the SEND message, if mlen is nonzero. */
   uint8_t sampler;
   uint8_t target; /**< MRT target. */
   bool saturate:1;
   bool eot:1;
   bool header_present:1;
   bool shadow_compare:1;
   bool force_uncompressed:1;
   bool force_sechalf:1;
   bool force_writemask_all:1;
a240 2
   void visit(ir_emit_vertex *);
   void visit(ir_end_primitive *);
a241 1
   uint32_t gather_channel(ir_texture *ir, int sampler);
d246 1
a285 4
   fs_inst *MAD(fs_reg dst, fs_reg c, fs_reg b, fs_reg a);
   fs_inst *ADDC(fs_reg dst, fs_reg src0, fs_reg src1);
   fs_inst *SUBB(fs_reg dst, fs_reg src0, fs_reg src1);
   fs_inst *SEL(fs_reg dst, fs_reg src0, fs_reg src1);
d290 1
a290 1
					   const fs_reg &reg);
d292 2
a293 3
   exec_list VARYING_PULL_CONSTANT_LOAD(const fs_reg &dst,
                                        const fs_reg &surf_index,
                                        const fs_reg &varying_offset,
a296 1
   void assign_binding_table_offsets();
d302 1
a302 1
   bool assign_regs(bool allow_spilling);
a303 1
   void get_used_mrfs(bool *mrf_used);
d313 1
a313 3
   void assign_constant_locations();
   void demote_pull_constants();
   void invalidate_live_intervals();
a314 1
   void calculate_register_pressure();
a322 1
   void opt_drop_redundant_mov_to_flags();
d324 1
d327 2
d331 1
a331 1
   void schedule_instructions(instruction_scheduler_mode mode);
a334 1
   void vfail(const char *msg, va_list args);
a335 1
   void no16(const char *msg, ...);
d340 2
d347 1
a347 1
                         bool is_centroid, bool is_sample);
a348 3
   fs_reg *emit_samplepos_setup(ir_variable *ir);
   fs_reg *emit_sampleid_setup(ir_variable *ir);
   fs_reg *emit_samplemaskin_setup(ir_variable *ir);
a351 1
   void compute_sample_position(fs_reg dst, fs_reg int_sample_pos);
d361 1
a361 3
                              fs_reg sample_index, fs_reg mcs, int sampler);
   fs_reg emit_mcs_fetch(ir_texture *ir, fs_reg coordinate, int sampler);
   void emit_gen6_gather_wa(uint8_t wa, fs_reg dst);
d365 3
a367 4
   void emit_lrp(const fs_reg &dst, const fs_reg &x, const fs_reg &y,
                 const fs_reg &a);
   void emit_minmax(uint32_t conditionalmod, const fs_reg &dst,
                    const fs_reg &src0, const fs_reg &src1);
d369 1
a369 5
   bool try_emit_mad(ir_expression *ir);
   void try_replace_with_sel();
   bool opt_peephole_sel();
   bool opt_peephole_predicated_break();
   bool opt_saturate_propagation();
d372 1
a372 2
   void emit_unspill(fs_inst *inst, fs_reg reg, uint32_t spill_offset,
                     int count);
a405 7
   void emit_untyped_atomic(unsigned atomic_op, unsigned surf_index,
                            fs_reg dst, fs_reg offset, fs_reg src0,
                            fs_reg src1);

   void emit_untyped_surface_read(unsigned surf_index, fs_reg dst,
                                  fs_reg offset);

a422 1
   virtual void dump_instructions();
a424 2
   void visit_atomic_counter_intrinsic(ir_call *ir);

d429 1
a429 1
   int *param_size;
d436 1
a436 12
   brw::fs_live_variables *live_intervals;

   int *regs_live_at_ip;

   /** Number of uniform variable components visited. */
   unsigned uniforms;

   /**
    * Array mapping UNIFORM register numbers to the pull parameter index,
    * or -1 if this uniform register isn't being uploaded as a pull constant.
    */
   int *pull_constant_loc;
d438 4
a441 3
   /**
    * Array mapping UNIFORM register numbers to the push parameter index,
    * or -1 if this uniform register isn't being uploaded as a push constant.
d443 2
a444 1
   int *push_constant_loc;
a447 1
   fs_reg sample_mask;
a450 1
   bool do_dual_src;
d454 1
a465 2
   bool simd16_unsupported;
   char *no16_msg;
a478 1
   bool spilled_any_registers;
d483 1
d503 1
a503 2
                                     unsigned *assembly_size,
                                     FILE *dump_file = NULL);
d506 1
a506 1
   void generate_code(exec_list *instructions, FILE *dump_file);
a507 1
   void generate_blorp_fb_write(fs_inst *inst);
d535 2
a536 3
   void generate_scratch_write(fs_inst *inst, struct brw_reg src);
   void generate_scratch_read(fs_inst *inst, struct brw_reg dst);
   void generate_scratch_read_gen7(fs_inst *inst, struct brw_reg dst);
a551 10

   void generate_set_omask(fs_inst *inst,
                           struct brw_reg dst,
                           struct brw_reg sample_mask);

   void generate_set_sample_id(fs_inst *inst,
                               struct brw_reg dst,
                               struct brw_reg src0,
                               struct brw_reg src1);

a569 9
   void generate_untyped_atomic(fs_inst *inst,
                                struct brw_reg dst,
                                struct brw_reg atomic_op,
                                struct brw_reg surf_index);

   void generate_untyped_surface_read(fs_inst *inst,
                                      struct brw_reg dst,
                                      struct brw_reg surf_index);

d579 1
a588 82
/**
 * The fragment shader code generator.
 *
 * Translates FS IR to actual i965 assembly code.
 */
class gen8_fs_generator : public gen8_generator
{
public:
   gen8_fs_generator(struct brw_context *brw,
                     struct brw_wm_compile *c,
                     struct gl_shader_program *prog,
                     struct gl_fragment_program *fp,
                     bool dual_source_output);
   ~gen8_fs_generator();

   const unsigned *generate_assembly(exec_list *simd8_instructions,
                                     exec_list *simd16_instructions,
                                     unsigned *assembly_size);

private:
   void generate_code(exec_list *instructions);
   void generate_fb_write(fs_inst *inst);
   void generate_linterp(fs_inst *inst, struct brw_reg dst,
                         struct brw_reg *src);
   void generate_tex(fs_inst *inst, struct brw_reg dst, struct brw_reg src);
   void generate_math1(fs_inst *inst, struct brw_reg dst, struct brw_reg src);
   void generate_math2(fs_inst *inst, struct brw_reg dst,
                       struct brw_reg src0, struct brw_reg src1);
   void generate_ddx(fs_inst *inst, struct brw_reg dst, struct brw_reg src);
   void generate_ddy(fs_inst *inst, struct brw_reg dst, struct brw_reg src,
                     bool negate_value);
   void generate_scratch_write(fs_inst *inst, struct brw_reg src);
   void generate_scratch_read(fs_inst *inst, struct brw_reg dst);
   void generate_scratch_read_gen7(fs_inst *inst, struct brw_reg dst);
   void generate_uniform_pull_constant_load(fs_inst *inst,
                                            struct brw_reg dst,
                                            struct brw_reg index,
                                            struct brw_reg offset);
   void generate_varying_pull_constant_load(fs_inst *inst,
                                            struct brw_reg dst,
                                            struct brw_reg index,
                                            struct brw_reg offset);
   void generate_mov_dispatch_to_flags(fs_inst *ir);
   void generate_set_omask(fs_inst *ir,
                           struct brw_reg dst,
                           struct brw_reg sample_mask);
   void generate_set_sample_id(fs_inst *ir,
                               struct brw_reg dst,
                               struct brw_reg src0,
                               struct brw_reg src1);
   void generate_set_simd4x2_offset(fs_inst *ir,
                                    struct brw_reg dst,
                                    struct brw_reg offset);
   void generate_pack_half_2x16_split(fs_inst *inst,
                                      struct brw_reg dst,
                                      struct brw_reg x,
                                      struct brw_reg y);
   void generate_unpack_half_2x16_split(fs_inst *inst,
                                        struct brw_reg dst,
                                        struct brw_reg src);
   void generate_untyped_atomic(fs_inst *inst,
                                struct brw_reg dst,
                                struct brw_reg atomic_op,
                                struct brw_reg surf_index);

   void generate_untyped_surface_read(fs_inst *inst,
                                      struct brw_reg dst,
                                      struct brw_reg surf_index);
   void generate_discard_jump(fs_inst *ir);

   void patch_discard_jumps_to_fb_writes();

   struct brw_wm_compile *c;
   const struct gl_fragment_program *fp;

   unsigned dispatch_width; /** 8 or 16 */

   bool dual_source_output;

   exec_list discard_halt_patches;
};

a591 2

struct brw_reg brw_reg_from_fs_reg(fs_reg *reg);
@


1.1.1.5
log
@Import Mesa 10.2.7
@
text
@d371 1
@


1.1.1.6
log
@Import Mesa 10.4.3
@
text
@d42 1
a42 1
#include "util/register_allocate.h"
a48 1
#include "intel_asm_annotation.h"
d50 1
a54 1
#define MAX_VGRF_SIZE 16
d56 1
a56 1
struct bblock_t;
d65 1
a65 4
class fs_inst;
class fs_visitor;

class fs_reg : public backend_reg {
d72 3
a74 3
   explicit fs_reg(float f);
   explicit fs_reg(int32_t i);
   explicit fs_reg(uint32_t u);
d77 2
a78 3
   fs_reg(enum register_file file, int reg, enum brw_reg_type type);
   fs_reg(enum register_file file, int reg, enum brw_reg_type type, uint8_t width);
   fs_reg(fs_visitor *v, const struct glsl_type *type);
d81 3
d86 1
d92 17
d115 9
d126 2
a127 15
   /**
    * The register width.  This indicates how many hardware values are
    * represented by each virtual value.  Valid values are 1, 8, or 16.
    * For immediate values, this is 1.  Most of the rest of the time, it
    * will be equal to the dispatch width.
    */
   uint8_t width;

   /**
    * Returns the effective register width when used as a source in the
    * given instruction.  Registers such as uniforms and immediates
    * effectively take on the width of the instruction in which they are
    * used.
    */
   uint8_t effective_width;
d134 1
a134 1
retype(fs_reg reg, enum brw_reg_type type)
a140 39
byte_offset(fs_reg reg, unsigned delta)
{
   switch (reg.file) {
   case BAD_FILE:
      break;
   case GRF:
      reg.reg_offset += delta / 32;
      break;
   case MRF:
      reg.reg += delta / 32;
      break;
   default:
      assert(delta == 0);
   }
   reg.subreg_offset += delta % 32;
   return reg;
}

static inline fs_reg
horiz_offset(fs_reg reg, unsigned delta)
{
   switch (reg.file) {
   case BAD_FILE:
   case UNIFORM:
   case IMM:
      /* These only have a single component that is implicitly splatted.  A
       * horizontal offset should be a harmless no-op.
       */
      break;
   case GRF:
   case MRF:
      return byte_offset(reg, delta * reg.stride * type_sz(reg.type));
   default:
      assert(delta == 0);
   }
   return reg;
}

static inline fs_reg
d143 2
a144 13
   assert(reg.stride > 0);
   switch (reg.file) {
   case BAD_FILE:
      break;
   case GRF:
   case MRF:
      return byte_offset(reg, delta * reg.width * reg.stride * type_sz(reg.type));
   case UNIFORM:
      reg.reg_offset += delta;
      break;
   default:
      assert(delta == 0);
   }
d149 1
a149 1
component(fs_reg reg, unsigned idx)
d151 2
a152 4
   assert(reg.subreg_offset == 0);
   assert(idx < reg.width);
   reg.subreg_offset = idx * type_sz(reg.type);
   reg.width = 1;
d162 1
a162 1
half(fs_reg reg, unsigned idx)
d166 1
a166 3
   assert(reg.width == 16);
   reg.width = 8;
   return horiz_offset(reg, 8 * idx);
d170 3
a186 5
   fs_inst &operator=(const fs_inst &);

   void init(enum opcode opcode, uint8_t exec_width, const fs_reg &dst,
             fs_reg *src, int sources);

d190 2
d193 6
a198 19
   fs_inst(enum opcode opcode, uint8_t exec_size);
   fs_inst(enum opcode opcode, const fs_reg &dst);
   fs_inst(enum opcode opcode, uint8_t exec_size, const fs_reg &dst,
           const fs_reg &src0);
   fs_inst(enum opcode opcode, const fs_reg &dst, const fs_reg &src0);
   fs_inst(enum opcode opcode, uint8_t exec_size, const fs_reg &dst,
           const fs_reg &src0, const fs_reg &src1);
   fs_inst(enum opcode opcode, const fs_reg &dst, const fs_reg &src0,
           const fs_reg &src1);
   fs_inst(enum opcode opcode, uint8_t exec_size, const fs_reg &dst,
           const fs_reg &src0, const fs_reg &src1, const fs_reg &src2);
   fs_inst(enum opcode opcode, const fs_reg &dst, const fs_reg &src0,
           const fs_reg &src1, const fs_reg &src2);
   fs_inst(enum opcode opcode, const fs_reg &dst, fs_reg src[], int sources);
   fs_inst(enum opcode opcode, uint8_t exec_size, const fs_reg &dst,
           fs_reg src[], int sources);
   fs_inst(const fs_inst &that);

   void resize_sources(uint8_t num_sources);
a204 1
   bool can_do_source_mods(struct brw_context *brw);
d210 8
a217 1
   fs_reg *src;
d219 2
a220 1
   uint8_t sources; /**< Number of fs_reg sources. */
d222 1
a222 6
   /**
    * Execution size of the instruction.  This is used by the generator to
    * generate the correct binary for the given fs_inst.  Current valid
    * values are 1, 8, 16.
    */
   uint8_t exec_size;
d229 1
d231 4
d240 1
a240 1
   bool pi_noperspective:1;   /**< Pixel interpolator noperspective flag */
a250 3
   const fs_reg reg_null_f;
   const fs_reg reg_null_d;
   const fs_reg reg_null_ud;
d253 1
a253 3
              void *mem_ctx,
              const struct brw_wm_prog_key *key,
              struct brw_wm_prog_data *prog_data,
a257 1
   void init();
d283 4
a286 3
   uint32_t gather_channel(int orig_chan, uint32_t sampler);
   void swizzle_result(ir_texture_opcode op, int dest_components,
                       fs_reg orig_val, uint32_t sampler);
d292 24
a315 28
   fs_inst *emit(enum opcode opcode, const fs_reg &dst);
   fs_inst *emit(enum opcode opcode, const fs_reg &dst, const fs_reg &src0);
   fs_inst *emit(enum opcode opcode, const fs_reg &dst, const fs_reg &src0,
                 const fs_reg &src1);
   fs_inst *emit(enum opcode opcode, const fs_reg &dst,
                 const fs_reg &src0, const fs_reg &src1, const fs_reg &src2);
   fs_inst *emit(enum opcode opcode, const fs_reg &dst,
                 fs_reg src[], int sources);

   fs_inst *MOV(const fs_reg &dst, const fs_reg &src);
   fs_inst *NOT(const fs_reg &dst, const fs_reg &src);
   fs_inst *RNDD(const fs_reg &dst, const fs_reg &src);
   fs_inst *RNDE(const fs_reg &dst, const fs_reg &src);
   fs_inst *RNDZ(const fs_reg &dst, const fs_reg &src);
   fs_inst *FRC(const fs_reg &dst, const fs_reg &src);
   fs_inst *ADD(const fs_reg &dst, const fs_reg &src0, const fs_reg &src1);
   fs_inst *MUL(const fs_reg &dst, const fs_reg &src0, const fs_reg &src1);
   fs_inst *MACH(const fs_reg &dst, const fs_reg &src0, const fs_reg &src1);
   fs_inst *MAC(const fs_reg &dst, const fs_reg &src0, const fs_reg &src1);
   fs_inst *SHL(const fs_reg &dst, const fs_reg &src0, const fs_reg &src1);
   fs_inst *SHR(const fs_reg &dst, const fs_reg &src0, const fs_reg &src1);
   fs_inst *ASR(const fs_reg &dst, const fs_reg &src0, const fs_reg &src1);
   fs_inst *AND(const fs_reg &dst, const fs_reg &src0, const fs_reg &src1);
   fs_inst *OR(const fs_reg &dst, const fs_reg &src0, const fs_reg &src1);
   fs_inst *XOR(const fs_reg &dst, const fs_reg &src0, const fs_reg &src1);
   fs_inst *IF(enum brw_predicate predicate);
   fs_inst *IF(const fs_reg &src0, const fs_reg &src1,
               enum brw_conditional_mod condition);
d317 2
a318 3
                enum brw_conditional_mod condition);
   fs_inst *LRP(const fs_reg &dst, const fs_reg &a, const fs_reg &y,
                const fs_reg &x);
d320 11
a330 14
   fs_inst *BFREV(const fs_reg &dst, const fs_reg &value);
   fs_inst *BFE(const fs_reg &dst, const fs_reg &bits, const fs_reg &offset,
                const fs_reg &value);
   fs_inst *BFI1(const fs_reg &dst, const fs_reg &bits, const fs_reg &offset);
   fs_inst *BFI2(const fs_reg &dst, const fs_reg &bfi1_dst,
                 const fs_reg &insert, const fs_reg &base);
   fs_inst *FBH(const fs_reg &dst, const fs_reg &value);
   fs_inst *FBL(const fs_reg &dst, const fs_reg &value);
   fs_inst *CBIT(const fs_reg &dst, const fs_reg &value);
   fs_inst *MAD(const fs_reg &dst, const fs_reg &c, const fs_reg &b,
                const fs_reg &a);
   fs_inst *ADDC(const fs_reg &dst, const fs_reg &src0, const fs_reg &src1);
   fs_inst *SUBB(const fs_reg &dst, const fs_reg &src0, const fs_reg &src1);
   fs_inst *SEL(const fs_reg &dst, const fs_reg &src0, const fs_reg &src1);
a336 2
   fs_inst *LOAD_PAYLOAD(const fs_reg &dst, fs_reg *src, int sources);

a342 2
   void optimize();
   void allocate_registers();
d359 1
a359 1
   bool compact_virtual_grfs();
d368 1
a368 1
   bool opt_cse_local(bblock_t *block);
a370 1
   bool try_constant_propagate(fs_inst *inst, acp_entry *entry);
a373 1
   bool opt_register_renaming();
d381 2
a382 4
   void insert_gen4_pre_send_dependency_workarounds(bblock_t *block,
                                                    fs_inst *inst);
   void insert_gen4_post_send_dependency_workarounds(bblock_t *block,
                                                     fs_inst *inst);
d387 3
a389 1
   bool lower_load_payload();
a391 1
   void emit_repclear_shader();
d396 4
a399 3
   fs_reg *emit_frontfacing_interpolation();
   fs_reg *emit_samplepos_setup();
   fs_reg *emit_sampleid_setup();
d404 11
a414 34
   fs_reg rescale_texcoord(fs_reg coordinate, const glsl_type *coord_type,
                           bool is_rect, uint32_t sampler, int texunit);
   fs_inst *emit_texture_gen4(ir_texture_opcode op, fs_reg dst,
                              fs_reg coordinate, int coord_components,
                              fs_reg shadow_comp,
                              fs_reg lod, fs_reg lod2, int grad_components,
                              uint32_t sampler);
   fs_inst *emit_texture_gen5(ir_texture_opcode op, fs_reg dst,
                              fs_reg coordinate, int coord_components,
                              fs_reg shadow_comp,
                              fs_reg lod, fs_reg lod2, int grad_components,
                              fs_reg sample_index, uint32_t sampler,
                              bool has_offset);
   fs_inst *emit_texture_gen7(ir_texture_opcode op, fs_reg dst,
                              fs_reg coordinate, int coord_components,
                              fs_reg shadow_comp,
                              fs_reg lod, fs_reg lod2, int grad_components,
                              fs_reg sample_index, fs_reg mcs, fs_reg sampler,
                              fs_reg offset_value);
   void emit_texture(ir_texture_opcode op,
                     const glsl_type *dest_type,
                     fs_reg coordinate, const struct glsl_type *coord_type,
                     fs_reg shadow_c,
                     fs_reg lod, fs_reg dpdy, int grad_components,
                     fs_reg sample_index,
                     fs_reg offset, unsigned offset_components,
                     fs_reg mcs,
                     int gather_component,
                     bool is_cube_array,
                     bool is_rect,
                     uint32_t sampler,
                     fs_reg sampler_reg,
                     int texunit);
   fs_reg emit_mcs_fetch(fs_reg coordinate, int components, fs_reg sampler);
d421 1
a421 1
   void emit_minmax(enum brw_conditional_mod conditionalmod, const fs_reg &dst,
d431 2
a432 4
   void emit_unspill(bblock_t *block, fs_inst *inst, fs_reg reg,
                     uint32_t spill_offset, int count);
   void emit_spill(bblock_t *block, fs_inst *inst, fs_reg reg,
                   uint32_t spill_offset, int count);
d453 1
a453 1
   void emit_fp_sop(enum brw_conditional_mod conditional_mod,
d457 1
a457 1
   int setup_color_payload(fs_reg *dst, fs_reg color, unsigned components);
a458 2
   fs_inst *emit_single_fb_write(fs_reg color1, fs_reg color2,
                                 fs_reg src0_alpha, unsigned components);
a472 2
   void emit_interpolate_expression(ir_expression *ir);

a490 1
   virtual void dump_instructions(const char *name);
a491 1
   void dump_instruction(backend_instruction *inst, FILE *file);
d495 2
a496 2
   const void *const key;
   struct brw_stage_prog_data *prog_data;
a512 3
   /** Byte-offset for the next available spot in the scratch space buffer. */
   unsigned last_scratch;

a551 17
   /** Register numbers for thread payload fields. */
   struct {
      uint8_t source_depth_reg;
      uint8_t source_w_reg;
      uint8_t aa_dest_stencil_reg;
      uint8_t dest_depth_reg;
      uint8_t sample_pos_reg;
      uint8_t sample_mask_in_reg;
      uint8_t barycentric_coord_reg[BRW_WM_BARYCENTRIC_INTERP_MODE_COUNT];

      /** The number of thread payload registers the hardware will supply. */
      uint8_t num_regs;
   } payload;

   bool source_depth_to_render_target;
   bool runtime_check_aads_emit;

d564 2
d577 2
a578 4
                void *mem_ctx,
                const struct brw_wm_prog_key *key,
                struct brw_wm_prog_data *prog_data,
                struct gl_shader_program *shader_prog,
d580 1
a580 2
                bool runtime_check_aads_emit,
                bool debug_flag);
d583 4
a586 2
   int generate_code(const cfg_t *cfg, int dispatch_width);
   const unsigned *get_assembly(unsigned int *assembly_size);
d589 2
a590 5
   void fire_fb_write(fs_inst *inst,
                      struct brw_reg payload,
                      struct brw_reg implied_header,
                      GLuint nr);
   void generate_fb_write(fs_inst *inst, struct brw_reg payload);
d595 15
a609 6
   void generate_tex(fs_inst *inst, struct brw_reg dst, struct brw_reg src,
                     struct brw_reg sampler_index);
   void generate_math_gen6(fs_inst *inst,
                           struct brw_reg dst,
                           struct brw_reg src0,
                           struct brw_reg src1);
d616 1
a616 1
   void generate_ddx(fs_inst *inst, struct brw_reg dst, struct brw_reg src, struct brw_reg quality);
d618 1
a618 1
                     struct brw_reg quality, bool negate_value);
a637 6
   void generate_pixel_interpolator_query(fs_inst *inst,
                                          struct brw_reg dst,
                                          struct brw_reg src,
                                          struct brw_reg msg_data,
                                          unsigned msg_type);

a666 1
                                struct brw_reg payload,
a671 1
                                      struct brw_reg payload,
d674 1
a674 1
   bool patch_discard_jumps_to_fb_writes();
d680 1
a680 3
   gl_shader_stage stage;
   const void * const key;
   struct brw_stage_prog_data * const prog_data;
d682 2
a683 2
   struct gl_shader_program * const shader_prog;
   const struct gl_program *prog;
d688 1
a688 2
   bool runtime_check_aads_emit;
   const bool debug_flag;
d690 82
@


1.1.1.7
log
@Import Mesa 10.2.9
@
text
@d42 1
a42 1
#include "program/register_allocate.h"
d49 1
a50 1
#include "gen8_generator.h"
d55 1
d57 1
a57 1
class bblock_t;
d66 4
a69 1
class fs_reg {
d76 3
a78 3
   fs_reg(float f);
   fs_reg(int32_t i);
   fs_reg(uint32_t u);
d81 3
a83 2
   fs_reg(enum register_file file, int reg, uint32_t type);
   fs_reg(class fs_visitor *v, const struct glsl_type *type);
a85 3
   bool is_zero() const;
   bool is_one() const;
   bool is_null() const;
a87 1
   bool is_accumulator() const;
a92 17
   /** Register file: GRF, MRF, IMM. */
   enum register_file file;
   /** Register type.  BRW_REGISTER_TYPE_* */
   uint8_t type;
   /**
    * Register number.  For MRF, it's the hardware register.  For
    * GRF, it's a virtual register number until register allocation
    */
   uint16_t reg;
   /**
    * Offset from the start of the contiguous register block.
    *
    * For pre-register-allocation GRFs, this is in units of a float per pixel
    * (1 hardware register for SIMD8 mode, or 2 registers for SIMD16 mode).
    * For uniforms, this is in units of 1 float.
    */
   int reg_offset;
d99 1
a99 6
   /** Value for file == IMM */
   union {
      int32_t i;
      uint32_t u;
      float f;
   } imm;
d101 7
a107 1
   struct brw_reg fixed_hw_reg;
d109 7
a115 4
   fs_reg *reladdr;

   bool negate;
   bool abs;
d122 1
a122 1
retype(fs_reg reg, unsigned type)
d129 39
d170 13
a182 2
   assert(delta == 0 || (reg.file != HW_REG && reg.file != IMM));
   reg.reg_offset += delta;
d187 1
a187 1
byte_offset(fs_reg reg, unsigned delta)
d189 4
a192 2
   assert(delta == 0 || (reg.file != HW_REG && reg.file != IMM));
   reg.subreg_offset += delta;
d202 1
a202 1
half(const fs_reg &reg, unsigned idx)
d206 3
a208 1
   return byte_offset(reg, 8 * idx * reg.stride * type_sz(reg.type));
a211 3
static const fs_reg reg_null_f(retype(brw_null_reg(), BRW_REGISTER_TYPE_F));
static const fs_reg reg_null_d(retype(brw_null_reg(), BRW_REGISTER_TYPE_D));
static const fs_reg reg_null_ud(retype(brw_null_reg(), BRW_REGISTER_TYPE_UD));
d226 5
d234 18
a251 1
   void init();
d253 1
a253 7
   fs_inst();
   fs_inst(enum opcode opcode);
   fs_inst(enum opcode opcode, fs_reg dst);
   fs_inst(enum opcode opcode, fs_reg dst, fs_reg src0);
   fs_inst(enum opcode opcode, fs_reg dst, fs_reg src0, fs_reg src1);
   fs_inst(enum opcode opcode, fs_reg dst,
           fs_reg src0, fs_reg src1,fs_reg src2);
d260 1
d266 3
a268 1
   fs_reg src[3];
d270 4
a273 2
   /** @@{
    * Annotation for the generated IR.  One of the two can be set.
d275 1
a275 8
   const void *ir;
   const char *annotation;
   /** @@} */

   uint32_t texture_offset; /**< Texture offset bitfield */
   uint32_t offset; /* spill/unspill offset */

   uint8_t conditional_mod; /**< BRW_CONDITIONAL_* */
a281 1
   uint8_t mlen; /**< SEND message length */
a282 4
   int8_t base_mrf; /**< First MRF in the SEND message, if mlen is nonzero. */
   uint8_t sampler;
   uint8_t target; /**< MRT target. */
   bool saturate:1;
d288 1
a288 1
   bool force_writemask_all:1;
d299 3
d304 3
a306 1
              struct brw_wm_compile *c,
d311 1
d337 3
a339 4
   uint32_t gather_channel(ir_texture *ir, int sampler);
   void swizzle_result(ir_texture *ir, fs_reg orig_val, int sampler);

   bool can_do_source_mods(fs_inst *inst);
d345 28
a372 24
   fs_inst *emit(enum opcode opcode, fs_reg dst);
   fs_inst *emit(enum opcode opcode, fs_reg dst, fs_reg src0);
   fs_inst *emit(enum opcode opcode, fs_reg dst, fs_reg src0, fs_reg src1);
   fs_inst *emit(enum opcode opcode, fs_reg dst,
                 fs_reg src0, fs_reg src1, fs_reg src2);

   fs_inst *MOV(fs_reg dst, fs_reg src);
   fs_inst *NOT(fs_reg dst, fs_reg src);
   fs_inst *RNDD(fs_reg dst, fs_reg src);
   fs_inst *RNDE(fs_reg dst, fs_reg src);
   fs_inst *RNDZ(fs_reg dst, fs_reg src);
   fs_inst *FRC(fs_reg dst, fs_reg src);
   fs_inst *ADD(fs_reg dst, fs_reg src0, fs_reg src1);
   fs_inst *MUL(fs_reg dst, fs_reg src0, fs_reg src1);
   fs_inst *MACH(fs_reg dst, fs_reg src0, fs_reg src1);
   fs_inst *MAC(fs_reg dst, fs_reg src0, fs_reg src1);
   fs_inst *SHL(fs_reg dst, fs_reg src0, fs_reg src1);
   fs_inst *SHR(fs_reg dst, fs_reg src0, fs_reg src1);
   fs_inst *ASR(fs_reg dst, fs_reg src0, fs_reg src1);
   fs_inst *AND(fs_reg dst, fs_reg src0, fs_reg src1);
   fs_inst *OR(fs_reg dst, fs_reg src0, fs_reg src1);
   fs_inst *XOR(fs_reg dst, fs_reg src0, fs_reg src1);
   fs_inst *IF(uint32_t predicate);
   fs_inst *IF(fs_reg src0, fs_reg src1, uint32_t condition);
d374 3
a376 2
                uint32_t condition);
   fs_inst *LRP(fs_reg dst, fs_reg a, fs_reg y, fs_reg x);
d378 14
a391 11
   fs_inst *BFREV(fs_reg dst, fs_reg value);
   fs_inst *BFE(fs_reg dst, fs_reg bits, fs_reg offset, fs_reg value);
   fs_inst *BFI1(fs_reg dst, fs_reg bits, fs_reg offset);
   fs_inst *BFI2(fs_reg dst, fs_reg bfi1_dst, fs_reg insert, fs_reg base);
   fs_inst *FBH(fs_reg dst, fs_reg value);
   fs_inst *FBL(fs_reg dst, fs_reg value);
   fs_inst *CBIT(fs_reg dst, fs_reg value);
   fs_inst *MAD(fs_reg dst, fs_reg c, fs_reg b, fs_reg a);
   fs_inst *ADDC(fs_reg dst, fs_reg src0, fs_reg src1);
   fs_inst *SUBB(fs_reg dst, fs_reg src0, fs_reg src1);
   fs_inst *SEL(fs_reg dst, fs_reg src0, fs_reg src1);
d398 2
d406 2
d424 1
a424 1
   void compact_virtual_grfs();
d433 1
a433 1
   bool opt_cse_local(bblock_t *block, exec_list *aeb);
d436 1
d440 1
d448 4
a451 2
   void insert_gen4_pre_send_dependency_workarounds(fs_inst *inst);
   void insert_gen4_post_send_dependency_workarounds(fs_inst *inst);
d456 1
a456 3

   void push_force_uncompressed();
   void pop_force_uncompressed();
d459 1
d464 3
a466 4
   fs_reg *emit_frontfacing_interpolation(ir_variable *ir);
   fs_reg *emit_samplepos_setup(ir_variable *ir);
   fs_reg *emit_sampleid_setup(ir_variable *ir);
   fs_reg *emit_samplemaskin_setup(ir_variable *ir);
d471 34
a504 11
   fs_reg rescale_texcoord(ir_texture *ir, fs_reg coordinate,
                           bool is_rect, int sampler, int texunit);
   fs_inst *emit_texture_gen4(ir_texture *ir, fs_reg dst, fs_reg coordinate,
			      fs_reg shadow_comp, fs_reg lod, fs_reg lod2);
   fs_inst *emit_texture_gen5(ir_texture *ir, fs_reg dst, fs_reg coordinate,
                              fs_reg shadow_comp, fs_reg lod, fs_reg lod2,
                              fs_reg sample_index);
   fs_inst *emit_texture_gen7(ir_texture *ir, fs_reg dst, fs_reg coordinate,
                              fs_reg shadow_comp, fs_reg lod, fs_reg lod2,
                              fs_reg sample_index, fs_reg mcs, int sampler);
   fs_reg emit_mcs_fetch(ir_texture *ir, fs_reg coordinate, int sampler);
d511 1
a511 1
   void emit_minmax(uint32_t conditionalmod, const fs_reg &dst,
d521 4
a524 2
   void emit_unspill(fs_inst *inst, fs_reg reg, uint32_t spill_offset,
                     int count);
d545 1
a545 1
   void emit_fp_sop(uint32_t conditional_mod,
d549 1
a549 1
   void emit_color_write(int target, int index, int first_color_mrf);
d551 2
d567 2
d587 1
d589 1
d593 2
a594 2
   struct gl_fragment_program *fp;
   struct brw_wm_compile *c;
d611 3
d653 17
a681 2

   int force_uncompressed_stack;
d693 4
a696 2
                struct brw_wm_compile *c,
                struct gl_shader_program *prog,
d698 2
a699 1
                bool dual_source_output);
d702 2
a703 4
   const unsigned *generate_assembly(exec_list *simd8_instructions,
                                     exec_list *simd16_instructions,
                                     unsigned *assembly_size,
                                     FILE *dump_file = NULL);
d706 5
a710 2
   void generate_code(exec_list *instructions, FILE *dump_file);
   void generate_fb_write(fs_inst *inst);
d715 6
a720 15
   void generate_tex(fs_inst *inst, struct brw_reg dst, struct brw_reg src);
   void generate_math1_gen7(fs_inst *inst,
			    struct brw_reg dst,
			    struct brw_reg src);
   void generate_math2_gen7(fs_inst *inst,
			    struct brw_reg dst,
			    struct brw_reg src0,
			    struct brw_reg src1);
   void generate_math1_gen6(fs_inst *inst,
			    struct brw_reg dst,
			    struct brw_reg src);
   void generate_math2_gen6(fs_inst *inst,
			    struct brw_reg dst,
			    struct brw_reg src0,
			    struct brw_reg src1);
d727 1
a727 1
   void generate_ddx(fs_inst *inst, struct brw_reg dst, struct brw_reg src);
d729 1
a729 1
                     bool negate_value);
d749 6
d784 1
d790 1
d793 1
a793 1
   void patch_discard_jumps_to_fb_writes();
d799 3
a801 1
   struct brw_wm_compile *c;
d803 2
a804 2
   struct gl_shader_program *prog;
   const struct gl_fragment_program *fp;
d809 2
a810 1
   bool dual_source_output;
a811 82
};

/**
 * The fragment shader code generator.
 *
 * Translates FS IR to actual i965 assembly code.
 */
class gen8_fs_generator : public gen8_generator
{
public:
   gen8_fs_generator(struct brw_context *brw,
                     struct brw_wm_compile *c,
                     struct gl_shader_program *prog,
                     struct gl_fragment_program *fp,
                     bool dual_source_output);
   ~gen8_fs_generator();

   const unsigned *generate_assembly(exec_list *simd8_instructions,
                                     exec_list *simd16_instructions,
                                     unsigned *assembly_size);

private:
   void generate_code(exec_list *instructions);
   void generate_fb_write(fs_inst *inst);
   void generate_linterp(fs_inst *inst, struct brw_reg dst,
                         struct brw_reg *src);
   void generate_tex(fs_inst *inst, struct brw_reg dst, struct brw_reg src);
   void generate_math1(fs_inst *inst, struct brw_reg dst, struct brw_reg src);
   void generate_math2(fs_inst *inst, struct brw_reg dst,
                       struct brw_reg src0, struct brw_reg src1);
   void generate_ddx(fs_inst *inst, struct brw_reg dst, struct brw_reg src);
   void generate_ddy(fs_inst *inst, struct brw_reg dst, struct brw_reg src,
                     bool negate_value);
   void generate_scratch_write(fs_inst *inst, struct brw_reg src);
   void generate_scratch_read(fs_inst *inst, struct brw_reg dst);
   void generate_scratch_read_gen7(fs_inst *inst, struct brw_reg dst);
   void generate_uniform_pull_constant_load(fs_inst *inst,
                                            struct brw_reg dst,
                                            struct brw_reg index,
                                            struct brw_reg offset);
   void generate_varying_pull_constant_load(fs_inst *inst,
                                            struct brw_reg dst,
                                            struct brw_reg index,
                                            struct brw_reg offset);
   void generate_mov_dispatch_to_flags(fs_inst *ir);
   void generate_set_omask(fs_inst *ir,
                           struct brw_reg dst,
                           struct brw_reg sample_mask);
   void generate_set_sample_id(fs_inst *ir,
                               struct brw_reg dst,
                               struct brw_reg src0,
                               struct brw_reg src1);
   void generate_set_simd4x2_offset(fs_inst *ir,
                                    struct brw_reg dst,
                                    struct brw_reg offset);
   void generate_pack_half_2x16_split(fs_inst *inst,
                                      struct brw_reg dst,
                                      struct brw_reg x,
                                      struct brw_reg y);
   void generate_unpack_half_2x16_split(fs_inst *inst,
                                        struct brw_reg dst,
                                        struct brw_reg src);
   void generate_untyped_atomic(fs_inst *inst,
                                struct brw_reg dst,
                                struct brw_reg atomic_op,
                                struct brw_reg surf_index);

   void generate_untyped_surface_read(fs_inst *inst,
                                      struct brw_reg dst,
                                      struct brw_reg surf_index);
   void generate_discard_jump(fs_inst *ir);

   void patch_discard_jumps_to_fb_writes();

   struct brw_wm_compile *c;
   const struct gl_fragment_program *fp;

   unsigned dispatch_width; /** 8 or 16 */

   bool dual_source_output;

   exec_list discard_halt_patches;
@


