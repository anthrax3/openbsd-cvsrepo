head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.50;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.58;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.21;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.04.24;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.15;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.39;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.19;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.38;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.15.43;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.52;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.11.50;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.48.55;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright Â© 2009 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * Authors:
 *    Eric Anholt <eric@@anholt.net>
 *
 */

#include "brw_context.h"
#include "brw_state.h"
#include "brw_defines.h"
#include "brw_util.h"
#include "intel_batchbuffer.h"
#include "main/fbobject.h"

static void
upload_clip_state(struct brw_context *brw)
{
   struct gl_context *ctx = &brw->ctx;
   /* BRW_NEW_META_IN_PROGRESS */
   uint32_t dw1 = brw->meta_in_progress ? 0 : GEN6_CLIP_STATISTICS_ENABLE;
   uint32_t dw2 = 0;

   /* _NEW_BUFFERS */
   struct gl_framebuffer *fb = ctx->DrawBuffer;

   /* CACHE_NEW_WM_PROG */
   if (brw->wm.prog_data->barycentric_interp_modes &
       BRW_WM_NONPERSPECTIVE_BARYCENTRIC_BITS) {
      dw2 |= GEN6_CLIP_NON_PERSPECTIVE_BARYCENTRIC_ENABLE;
   }

   if (brw->gen >= 7)
      dw1 |= GEN7_CLIP_EARLY_CULL;

   if (brw->gen == 7) {
      /* _NEW_POLYGON */
      if ((ctx->Polygon.FrontFace == GL_CCW) ^ _mesa_is_user_fbo(fb))
         dw1 |= GEN7_CLIP_WINDING_CCW;

      if (ctx->Polygon.CullFlag) {
         switch (ctx->Polygon.CullFaceMode) {
         case GL_FRONT:
            dw1 |= GEN7_CLIP_CULLMODE_FRONT;
            break;
         case GL_BACK:
            dw1 |= GEN7_CLIP_CULLMODE_BACK;
            break;
         case GL_FRONT_AND_BACK:
            dw1 |= GEN7_CLIP_CULLMODE_BOTH;
            break;
         default:
            assert(!"Should not get here: invalid CullFlag");
            break;
         }
      } else {
         dw1 |= GEN7_CLIP_CULLMODE_NONE;
      }
   }

   if (brw->gen < 8 && !ctx->Transform.DepthClamp)
      dw2 |= GEN6_CLIP_Z_TEST;

   /* _NEW_LIGHT */
   if (ctx->Light.ProvokingVertex == GL_FIRST_VERTEX_CONVENTION) {
      dw2 |=
	 (0 << GEN6_CLIP_TRI_PROVOKE_SHIFT) |
	 (1 << GEN6_CLIP_TRIFAN_PROVOKE_SHIFT) |
	 (0 << GEN6_CLIP_LINE_PROVOKE_SHIFT);
   } else {
      dw2 |=
	 (2 << GEN6_CLIP_TRI_PROVOKE_SHIFT) |
	 (2 << GEN6_CLIP_TRIFAN_PROVOKE_SHIFT) |
	 (1 << GEN6_CLIP_LINE_PROVOKE_SHIFT);
   }

   /* _NEW_TRANSFORM */
   dw2 |= (ctx->Transform.ClipPlanesEnabled <<
           GEN6_USER_CLIP_CLIP_DISTANCES_SHIFT);

   dw2 |= GEN6_CLIP_GB_TEST;
   for (unsigned i = 0; i < ctx->Const.MaxViewports; i++) {
      if (ctx->ViewportArray[i].X != 0 ||
          ctx->ViewportArray[i].Y != 0 ||
          ctx->ViewportArray[i].Width != (float) fb->Width ||
          ctx->ViewportArray[i].Height != (float) fb->Height) {
         dw2 &= ~GEN6_CLIP_GB_TEST;
         if (brw->gen >= 8) {
            perf_debug("Disabling GB clipping due to lack of Gen8 viewport "
                       "clipping setup code.  This should be fixed.\n");
         }
         break;
      }
   }

   /* BRW_NEW_RASTERIZER_DISCARD */
   if (ctx->RasterDiscard) {
      dw2 |= GEN6_CLIP_MODE_REJECT_ALL;
      perf_debug("Rasterizer discard is currently implemented via the clipper; "
                 "%s be faster.\n", brw->gen >= 7 ? "using the SOL unit may" :
                 "having the GS not write primitives would likely");
   }

   BEGIN_BATCH(4);
   OUT_BATCH(_3DSTATE_CLIP << 16 | (4 - 2));
   OUT_BATCH(dw1);
   OUT_BATCH(GEN6_CLIP_ENABLE |
	     GEN6_CLIP_API_OGL |
	     GEN6_CLIP_MODE_NORMAL |
	     GEN6_CLIP_XY_TEST |
	     dw2);
   OUT_BATCH(U_FIXED(0.125, 3) << GEN6_CLIP_MIN_POINT_WIDTH_SHIFT |
             U_FIXED(255.875, 3) << GEN6_CLIP_MAX_POINT_WIDTH_SHIFT |
             (fb->MaxNumLayers > 0 ? 0 : GEN6_CLIP_FORCE_ZERO_RTAINDEX) |
             ((ctx->Const.MaxViewports - 1) & GEN6_CLIP_MAX_VP_INDEX_MASK));
   ADVANCE_BATCH();
}

const struct brw_tracked_state gen6_clip_state = {
   .dirty = {
      .mesa  = _NEW_TRANSFORM | _NEW_LIGHT | _NEW_BUFFERS,
      .brw   = BRW_NEW_CONTEXT |
               BRW_NEW_META_IN_PROGRESS |
               BRW_NEW_RASTERIZER_DISCARD,
      .cache = CACHE_NEW_WM_PROG
   },
   .emit = upload_clip_state,
};

const struct brw_tracked_state gen7_clip_state = {
   .dirty = {
      .mesa  = _NEW_BUFFERS | _NEW_LIGHT | _NEW_POLYGON | _NEW_TRANSFORM,
      .brw   = BRW_NEW_CONTEXT |
               BRW_NEW_META_IN_PROGRESS |
               BRW_NEW_RASTERIZER_DISCARD,
      .cache = CACHE_NEW_WM_PROG
   },
   .emit = upload_clip_state,
};
@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d72 2
a73 1
            unreachable("Should not get here: invalid CullFlag");
a100 24

   /* We need to disable guardband clipping if the guardband (which we always
    * program to the maximum screen-space bounding box of 8K x 8K) will be
    * smaller than the viewport.
    *
    * Closely examining the clip determination formulas in the documentation
    * reveals that objects will be discarded entirely if they're outside the
    * (small) guardband, even if they're within the (large) viewport:
    *
    *     TR = TR_GB || TR_VPXY || TR_VPZ || TR_UC || TR_NEGW
    *     TA   = !TR && TA_GB && TA_VPZ && TA_NEGW
    *     MC = !(TA || TR)
    *
    * (TA is "Trivial Accept", TR is "Trivial Reject", MC is "Must Clip".)
    *
    * Disabling guardband clipping removes the TR_GB condition, which means
    * they'll be considered MC ("Must Clip") unless they're rejected for
    * some other reason.
    *
    * Note that there is no TA_VPXY condition.  If there were, objects entirely
    * inside a 16384x16384 viewport would be trivially accepted, breaking the
    * "objects must have a screenspace bounding box not exceeding 8K in the X
    * or Y direction" restriction.  Instead, they're clipped.
    */
d102 4
a105 2
      if (ctx->ViewportArray[i].Width > 8192 ||
          ctx->ViewportArray[i].Height > 8192) {
d107 4
a114 23
   /* If the viewport dimensions are smaller than the drawable dimensions,
    * we have to disable guardband clipping prior to Gen8.  We always program
    * the guardband to a fixed size, which is almost always larger than the
    * viewport.  Any geometry which intersects the viewport but lies within
    * the guardband would bypass the 3D clipping stage, so it wouldn't be
    * clipped to the viewport.  Rendering would happen beyond the viewport,
    * but still inside the drawable.
    *
    * Gen8+ introduces a viewport extents test which restricts rendering to
    * the viewport, so we can ignore this restriction.
    */
   if (brw->gen < 8) {
      for (unsigned i = 0; i < ctx->Const.MaxViewports; i++) {
         if (ctx->ViewportArray[i].X != 0 ||
             ctx->ViewportArray[i].Y != 0 ||
             ctx->ViewportArray[i].Width != (float) fb->Width ||
             ctx->ViewportArray[i].Height != (float) fb->Height) {
            dw2 &= ~GEN6_CLIP_GB_TEST;
            break;
         }
      }
   }

a122 6
   uint32_t enable;
   if (brw->primitive == _3DPRIM_RECTLIST)
      enable = 0;
   else
      enable = GEN6_CLIP_ENABLE;

d126 1
a126 1
   OUT_BATCH(enable |
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d72 1
a72 2
            assert(!"Should not get here: invalid CullFlag");
            break;
d100 24
d125 2
a126 4
      if (ctx->ViewportArray[i].X != 0 ||
          ctx->ViewportArray[i].Y != 0 ||
          ctx->ViewportArray[i].Width != (float) fb->Width ||
          ctx->ViewportArray[i].Height != (float) fb->Height) {
d128 23
a150 3
         if (brw->gen >= 8) {
            perf_debug("Disabling GB clipping due to lack of Gen8 viewport "
                       "clipping setup code.  This should be fixed.\n");
a151 1
         break;
d163 6
d172 1
a172 1
   OUT_BATCH(GEN6_CLIP_ENABLE |
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d39 1
d52 29
a80 1
   if (!ctx->Transform.DepthClamp)
d100 13
a112 5
   if (ctx->Viewport.X == 0 &&
       ctx->Viewport.Y == 0 &&
       ctx->Viewport.Width == fb->Width &&
       ctx->Viewport.Height == fb->Height) {
      dw2 |= GEN6_CLIP_GB_TEST;
d119 2
a120 1
                 "having the GS not write primitives would likely be faster.");
d133 2
a134 1
             GEN6_CLIP_FORCE_ZERO_RTAINDEX);
d141 11
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d33 1
d38 12
a49 4
   struct intel_context *intel = &brw->intel;
   struct gl_context *ctx = &intel->ctx;
   uint32_t depth_clamp = 0;
   uint32_t provoking, userclip;
d52 1
a52 1
      depth_clamp = GEN6_CLIP_Z_TEST;
d56 1
a56 1
      provoking =
d61 1
a61 1
      provoking =
d68 16
a83 1
   userclip = (1 << brw_count_bits(ctx->Transform.ClipPlanesEnabled)) - 1;
d87 1
a87 1
   OUT_BATCH(GEN6_CLIP_STATISTICS_ENABLE);
d92 1
a92 3
	     userclip << GEN6_USER_CLIP_CLIP_DISTANCES_SHIFT |
	     depth_clamp |
	     provoking);
d101 5
a105 3
      .mesa  = _NEW_TRANSFORM | _NEW_LIGHT,
      .brw   = BRW_NEW_CONTEXT,
      .cache = 0
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d45 1
d79 1
a79 1
      .mesa  = _NEW_TRANSFORM,
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d31 1
d38 1
a38 1
   GLcontext *ctx = &intel->ctx;
d40 1
a40 1
   uint32_t provoking;
d46 4
a49 1
      provoking = 0;
d57 3
d61 1
a61 1
   OUT_BATCH(CMD_3D_CLIP_STATE << 16 | (4 - 2));
d65 1
a65 1
	     GEN6_CLIP_MODE_REJECT_ALL | /* XXX: debug: get VS working */
d67 1
d70 3
a72 1
   OUT_BATCH(0);
a73 2

   intel_batchbuffer_emit_mi_flush(intel->batch);
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a30 1
#include "brw_util.h"
d37 1
a37 1
   struct gl_context *ctx = &intel->ctx;
d39 1
a39 1
   uint32_t provoking, userclip;
d45 1
a45 4
      provoking =
	 (0 << GEN6_CLIP_TRI_PROVOKE_SHIFT) |
	 (1 << GEN6_CLIP_TRIFAN_PROVOKE_SHIFT) |
	 (0 << GEN6_CLIP_LINE_PROVOKE_SHIFT);
a52 3
   /* _NEW_TRANSFORM */
   userclip = (1 << brw_count_bits(ctx->Transform.ClipPlanesEnabled)) - 1;

d54 1
a54 1
   OUT_BATCH(_3DSTATE_CLIP << 16 | (4 - 2));
d58 1
a58 1
	     GEN6_CLIP_MODE_NORMAL |
a59 1
	     userclip << GEN6_USER_CLIP_CLIP_DISTANCES_SHIFT |
d62 1
a62 3
   OUT_BATCH(U_FIXED(0.125, 3) << GEN6_CLIP_MIN_POINT_WIDTH_SHIFT |
             U_FIXED(255.875, 3) << GEN6_CLIP_MAX_POINT_WIDTH_SHIFT |
             GEN6_CLIP_FORCE_ZERO_RTAINDEX);
d64 2
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a32 1
#include "main/fbobject.h"
d37 4
a40 12
   struct gl_context *ctx = &brw->ctx;
   uint32_t dw1 = brw->meta_in_progress ? 0 : GEN6_CLIP_STATISTICS_ENABLE;
   uint32_t dw2 = 0;

   /* _NEW_BUFFERS */
   struct gl_framebuffer *fb = ctx->DrawBuffer;

   /* CACHE_NEW_WM_PROG */
   if (brw->wm.prog_data->barycentric_interp_modes &
       BRW_WM_NONPERSPECTIVE_BARYCENTRIC_BITS) {
      dw2 |= GEN6_CLIP_NON_PERSPECTIVE_BARYCENTRIC_ENABLE;
   }
d43 1
a43 1
      dw2 |= GEN6_CLIP_Z_TEST;
a44 1
   /* _NEW_LIGHT */
d46 1
a46 1
      dw2 |=
d51 1
a51 1
      dw2 |=
d58 1
a58 16
   dw2 |= (ctx->Transform.ClipPlanesEnabled <<
           GEN6_USER_CLIP_CLIP_DISTANCES_SHIFT);

   if (ctx->Viewport.X == 0 &&
       ctx->Viewport.Y == 0 &&
       ctx->Viewport.Width == fb->Width &&
       ctx->Viewport.Height == fb->Height) {
      dw2 |= GEN6_CLIP_GB_TEST;
   }

   /* BRW_NEW_RASTERIZER_DISCARD */
   if (ctx->RasterDiscard) {
      dw2 |= GEN6_CLIP_MODE_REJECT_ALL;
      perf_debug("Rasterizer discard is currently implemented via the clipper; "
                 "having the GS not write primitives would likely be faster.");
   }
d62 1
a62 1
   OUT_BATCH(dw1);
d67 3
a69 1
	     dw2);
d78 3
a80 5
      .mesa  = _NEW_TRANSFORM | _NEW_LIGHT | _NEW_BUFFERS,
      .brw   = BRW_NEW_CONTEXT |
               BRW_NEW_META_IN_PROGRESS |
               BRW_NEW_RASTERIZER_DISCARD,
      .cache = CACHE_NEW_WM_PROG
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@a38 1
   /* BRW_NEW_META_IN_PROGRESS */
d51 1
a51 29
   if (brw->gen >= 7)
      dw1 |= GEN7_CLIP_EARLY_CULL;

   if (brw->gen == 7) {
      /* _NEW_POLYGON */
      if ((ctx->Polygon.FrontFace == GL_CCW) ^ _mesa_is_user_fbo(fb))
         dw1 |= GEN7_CLIP_WINDING_CCW;

      if (ctx->Polygon.CullFlag) {
         switch (ctx->Polygon.CullFaceMode) {
         case GL_FRONT:
            dw1 |= GEN7_CLIP_CULLMODE_FRONT;
            break;
         case GL_BACK:
            dw1 |= GEN7_CLIP_CULLMODE_BACK;
            break;
         case GL_FRONT_AND_BACK:
            dw1 |= GEN7_CLIP_CULLMODE_BOTH;
            break;
         default:
            assert(!"Should not get here: invalid CullFlag");
            break;
         }
      } else {
         dw1 |= GEN7_CLIP_CULLMODE_NONE;
      }
   }

   if (brw->gen < 8 && !ctx->Transform.DepthClamp)
d71 5
a75 13
   dw2 |= GEN6_CLIP_GB_TEST;
   for (unsigned i = 0; i < ctx->Const.MaxViewports; i++) {
      if (ctx->ViewportArray[i].X != 0 ||
          ctx->ViewportArray[i].Y != 0 ||
          ctx->ViewportArray[i].Width != (float) fb->Width ||
          ctx->ViewportArray[i].Height != (float) fb->Height) {
         dw2 &= ~GEN6_CLIP_GB_TEST;
         if (brw->gen >= 8) {
            perf_debug("Disabling GB clipping due to lack of Gen8 viewport "
                       "clipping setup code.  This should be fixed.\n");
         }
         break;
      }
d82 1
a82 2
                 "%s be faster.\n", brw->gen >= 7 ? "using the SOL unit may" :
                 "having the GS not write primitives would likely");
d95 1
a95 2
             (fb->MaxNumLayers > 0 ? 0 : GEN6_CLIP_FORCE_ZERO_RTAINDEX) |
             ((ctx->Const.MaxViewports - 1) & GEN6_CLIP_MAX_VP_INDEX_MASK));
a101 11
      .brw   = BRW_NEW_CONTEXT |
               BRW_NEW_META_IN_PROGRESS |
               BRW_NEW_RASTERIZER_DISCARD,
      .cache = CACHE_NEW_WM_PROG
   },
   .emit = upload_clip_state,
};

const struct brw_tracked_state gen7_clip_state = {
   .dirty = {
      .mesa  = _NEW_BUFFERS | _NEW_LIGHT | _NEW_POLYGON | _NEW_TRANSFORM,
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d72 2
a73 1
            unreachable("Should not get here: invalid CullFlag");
a100 24

   /* We need to disable guardband clipping if the guardband (which we always
    * program to the maximum screen-space bounding box of 8K x 8K) will be
    * smaller than the viewport.
    *
    * Closely examining the clip determination formulas in the documentation
    * reveals that objects will be discarded entirely if they're outside the
    * (small) guardband, even if they're within the (large) viewport:
    *
    *     TR = TR_GB || TR_VPXY || TR_VPZ || TR_UC || TR_NEGW
    *     TA   = !TR && TA_GB && TA_VPZ && TA_NEGW
    *     MC = !(TA || TR)
    *
    * (TA is "Trivial Accept", TR is "Trivial Reject", MC is "Must Clip".)
    *
    * Disabling guardband clipping removes the TR_GB condition, which means
    * they'll be considered MC ("Must Clip") unless they're rejected for
    * some other reason.
    *
    * Note that there is no TA_VPXY condition.  If there were, objects entirely
    * inside a 16384x16384 viewport would be trivially accepted, breaking the
    * "objects must have a screenspace bounding box not exceeding 8K in the X
    * or Y direction" restriction.  Instead, they're clipped.
    */
d102 4
a105 2
      if (ctx->ViewportArray[i].Width > 8192 ||
          ctx->ViewportArray[i].Height > 8192) {
d107 4
a114 23
   /* If the viewport dimensions are smaller than the drawable dimensions,
    * we have to disable guardband clipping prior to Gen8.  We always program
    * the guardband to a fixed size, which is almost always larger than the
    * viewport.  Any geometry which intersects the viewport but lies within
    * the guardband would bypass the 3D clipping stage, so it wouldn't be
    * clipped to the viewport.  Rendering would happen beyond the viewport,
    * but still inside the drawable.
    *
    * Gen8+ introduces a viewport extents test which restricts rendering to
    * the viewport, so we can ignore this restriction.
    */
   if (brw->gen < 8) {
      for (unsigned i = 0; i < ctx->Const.MaxViewports; i++) {
         if (ctx->ViewportArray[i].X != 0 ||
             ctx->ViewportArray[i].Y != 0 ||
             ctx->ViewportArray[i].Width != (float) fb->Width ||
             ctx->ViewportArray[i].Height != (float) fb->Height) {
            dw2 &= ~GEN6_CLIP_GB_TEST;
            break;
         }
      }
   }

a122 6
   uint32_t enable;
   if (brw->primitive == _3DPRIM_RECTLIST)
      enable = 0;
   else
      enable = GEN6_CLIP_ENABLE;

d126 1
a126 1
   OUT_BATCH(enable |
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d72 1
a72 2
            assert(!"Should not get here: invalid CullFlag");
            break;
d100 24
d125 2
a126 4
      if (ctx->ViewportArray[i].X != 0 ||
          ctx->ViewportArray[i].Y != 0 ||
          ctx->ViewportArray[i].Width != (float) fb->Width ||
          ctx->ViewportArray[i].Height != (float) fb->Height) {
d128 23
a150 3
         if (brw->gen >= 8) {
            perf_debug("Disabling GB clipping due to lack of Gen8 viewport "
                       "clipping setup code.  This should be fixed.\n");
a151 1
         break;
d163 6
d172 1
a172 1
   OUT_BATCH(GEN6_CLIP_ENABLE |
@


