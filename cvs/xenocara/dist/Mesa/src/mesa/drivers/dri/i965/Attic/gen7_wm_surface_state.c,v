head	1.6;
access;
symbols
	OPENBSD_5_8:1.5.0.4
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5
	v10_2_9:1.1.1.4
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.2
	OPENBSD_5_6:1.3.0.2
	OPENBSD_5_6_BASE:1.3
	v10_2_3:1.1.1.2
	OPENBSD_5_5:1.2.0.2
	OPENBSD_5_5_BASE:1.2
	v9_2_5:1.1.1.1
	v9_2_3:1.1.1.1
	v9_2_2:1.1.1.1
	v9_2_1:1.1.1.1
	v9_2_0:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_4:1.1.0.4
	OPENBSD_5_4_BASE:1.1
	OPENBSD_5_3:1.1.0.2
	OPENBSD_5_3_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.12.23.05.17.50;	author jsg;	state dead;
branches;
next	1.5;
commitid	TnlogFl9nOv2eaRf;

1.5
date	2015.02.20.23.09.58;	author jsg;	state Exp;
branches;
next	1.4;
commitid	4ry2gvZGMXkCUD2n;

1.4
date	2015.01.25.14.41.21;	author jsg;	state Exp;
branches;
next	1.3;
commitid	mcxB0JvoI9gTDYXU;

1.3
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.2;
commitid	WPD6rgPryPkvXOr9;

1.2
date	2013.09.05.14.04.25;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2012.08.17.13.58.15;	author mpi;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.09.05.13.15.44;	author jsg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.07.09.20.34.52;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.3
date	2015.01.25.14.11.53;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.4
date	2015.02.20.22.48.57;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.6
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright © 2011 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */
#include "main/mtypes.h"
#include "main/blend.h"
#include "main/samplerobj.h"
#include "main/texformat.h"
#include "program/prog_parameter.h"

#include "intel_mipmap_tree.h"
#include "intel_batchbuffer.h"
#include "intel_tex.h"
#include "intel_fbo.h"
#include "intel_buffer_objects.h"

#include "brw_context.h"
#include "brw_state.h"
#include "brw_defines.h"
#include "brw_wm.h"

/**
 * Convert an swizzle enumeration (i.e. SWIZZLE_X) to one of the Gen7.5+
 * "Shader Channel Select" enumerations (i.e. HSW_SCS_RED)
 */
unsigned
brw_swizzle_to_scs(GLenum swizzle, bool need_green_to_blue)
{
   switch (swizzle) {
   case SWIZZLE_X:
      return HSW_SCS_RED;
   case SWIZZLE_Y:
      return need_green_to_blue ? HSW_SCS_BLUE : HSW_SCS_GREEN;
   case SWIZZLE_Z:
      return HSW_SCS_BLUE;
   case SWIZZLE_W:
      return HSW_SCS_ALPHA;
   case SWIZZLE_ZERO:
      return HSW_SCS_ZERO;
   case SWIZZLE_ONE:
      return HSW_SCS_ONE;
   }

   assert(!"Should not get here: invalid swizzle mode");
   return HSW_SCS_ZERO;
}

uint32_t
gen7_surface_tiling_mode(uint32_t tiling)
{
   switch (tiling) {
   case I915_TILING_X:
      return GEN7_SURFACE_TILING_X;
   case I915_TILING_Y:
      return GEN7_SURFACE_TILING_Y;
   default:
      return GEN7_SURFACE_TILING_NONE;
   }
}


uint32_t
gen7_surface_msaa_bits(unsigned num_samples, enum intel_msaa_layout layout)
{
   uint32_t ss4 = 0;

   assert(num_samples <= 8);

   /* The SURFACE_MULTISAMPLECOUNT_X enums are simply log2(num_samples) << 3. */
   ss4 |= (ffs(MAX2(num_samples, 1)) - 1) << 3;

   if (layout == INTEL_MSAA_LAYOUT_IMS)
      ss4 |= GEN7_SURFACE_MSFMT_DEPTH_STENCIL;
   else
      ss4 |= GEN7_SURFACE_MSFMT_MSS;

   return ss4;
}


void
gen7_set_surface_mcs_info(struct brw_context *brw,
                          uint32_t *surf,
                          uint32_t surf_offset,
                          const struct intel_mipmap_tree *mcs_mt,
                          bool is_render_target)
{
   /* From the Ivy Bridge PRM, Vol4 Part1 p76, "MCS Base Address":
    *
    *     "The MCS surface must be stored as Tile Y."
    */
   assert(mcs_mt->tiling == I915_TILING_Y);

   /* Compute the pitch in units of tiles.  To do this we need to divide the
    * pitch in bytes by 128, since a single Y-tile is 128 bytes wide.
    */
   unsigned pitch_tiles = mcs_mt->pitch / 128;

   /* The upper 20 bits of surface state DWORD 6 are the upper 20 bits of the
    * GPU address of the MCS buffer; the lower 12 bits contain other control
    * information.  Since buffer addresses are always on 4k boundaries (and
    * thus have their lower 12 bits zero), we can use an ordinary reloc to do
    * the necessary address translation.
    */
   assert ((mcs_mt->bo->offset64 & 0xfff) == 0);

   surf[6] = GEN7_SURFACE_MCS_ENABLE |
             SET_FIELD(pitch_tiles - 1, GEN7_SURFACE_MCS_PITCH) |
             mcs_mt->bo->offset64;

   drm_intel_bo_emit_reloc(brw->batch.bo,
                           surf_offset + 6 * 4,
                           mcs_mt->bo,
                           surf[6] & 0xfff,
                           is_render_target ? I915_GEM_DOMAIN_RENDER
                           : I915_GEM_DOMAIN_SAMPLER,
                           is_render_target ? I915_GEM_DOMAIN_RENDER : 0);
}


void
gen7_check_surface_setup(uint32_t *surf, bool is_render_target)
{
   unsigned num_multisamples = surf[4] & INTEL_MASK(5, 3);
   unsigned multisampled_surface_storage_format = surf[4] & (1 << 6);
   unsigned surface_array_spacing = surf[0] & (1 << 10);
   bool is_multisampled = num_multisamples != GEN7_SURFACE_MULTISAMPLECOUNT_1;

   (void) surface_array_spacing;

   /* From the Ivybridge PRM, Volume 4 Part 1, page 66 (RENDER_SURFACE_STATE
    * dword 0 bit 10 "Surface Array Spacing" Programming Notes):
    *
    *   If Multisampled Surface Storage Format is MSFMT_MSS and Number of
    *   Multisamples is not MULTISAMPLECOUNT_1, this field must be set to
    *   ARYSPC_LOD0.
    */
   if (multisampled_surface_storage_format == GEN7_SURFACE_MSFMT_MSS
       && is_multisampled)
      assert(surface_array_spacing == GEN7_SURFACE_ARYSPC_LOD0);

   /* From the Ivybridge PRM, Volume 4 Part 1, page 72 (RENDER_SURFACE_STATE
    * dword 4 bit 6 "Multisampled Surface Storage" Programming Notes):
    *
    *   All multisampled render target surfaces must have this field set to
    *   MSFMT_MSS.
    *
    * But also:
    *
    *   This field is ignored if Number of Multisamples is MULTISAMPLECOUNT_1.
    */
   if (is_render_target && is_multisampled) {
      assert(multisampled_surface_storage_format == GEN7_SURFACE_MSFMT_MSS);
   }

   /* From the Ivybridge PRM, Volume 4 Part 1, page 72 (RENDER_SURFACE_STATE
    * dword 4 bit 6 "Multisampled Surface Storage Format" Errata):
    *
    *   If the surface’s Number of Multisamples is MULTISAMPLECOUNT_8, Width
    *   is >= 8192 (meaning the actual surface width is >= 8193 pixels), this
    *   field must be set to MSFMT_MSS.
    */
   uint32_t width = GET_FIELD(surf[2], GEN7_SURFACE_WIDTH) + 1;
   if (num_multisamples == GEN7_SURFACE_MULTISAMPLECOUNT_8 && width >= 8193) {
      assert(multisampled_surface_storage_format == GEN7_SURFACE_MSFMT_MSS);
   }

   /* From the Ivybridge PRM, Volume 4 Part 1, page 72 (RENDER_SURFACE_STATE
    * dword 4 bit 6 "Multisampled Surface Storage Format" Errata):
    *
    *   If the surface’s Number of Multisamples is MULTISAMPLECOUNT_8,
    *   ((Depth+1) * (Height+1)) is > 4,194,304, OR if the surface’s Number of
    *   Multisamples is MULTISAMPLECOUNT_4, ((Depth+1) * (Height+1)) is >
    *   8,388,608, this field must be set to MSFMT_DEPTH_STENCIL.This field
    *   must be set to MSFMT_DEPTH_STENCIL if Surface Format is one of the
    *   following: I24X8_UNORM, L24X8_UNORM, A24X8_UNORM, or
    *   R24_UNORM_X8_TYPELESS.
    *
    * But also (from the Programming Notes):
    *
    *   This field is ignored if Number of Multisamples is MULTISAMPLECOUNT_1.
    */
   uint32_t depth = GET_FIELD(surf[3], BRW_SURFACE_DEPTH) + 1;
   uint32_t height = GET_FIELD(surf[2], GEN7_SURFACE_HEIGHT) + 1;
   if (num_multisamples == GEN7_SURFACE_MULTISAMPLECOUNT_8 &&
       depth * height > 4194304) {
      assert(multisampled_surface_storage_format ==
             GEN7_SURFACE_MSFMT_DEPTH_STENCIL);
   }
   if (num_multisamples == GEN7_SURFACE_MULTISAMPLECOUNT_4 &&
       depth * height > 8388608) {
      assert(multisampled_surface_storage_format ==
             GEN7_SURFACE_MSFMT_DEPTH_STENCIL);
   }
   if (is_multisampled) {
      switch (GET_FIELD(surf[0], BRW_SURFACE_FORMAT)) {
      case BRW_SURFACEFORMAT_I24X8_UNORM:
      case BRW_SURFACEFORMAT_L24X8_UNORM:
      case BRW_SURFACEFORMAT_A24X8_UNORM:
      case BRW_SURFACEFORMAT_R24_UNORM_X8_TYPELESS:
         assert(multisampled_surface_storage_format ==
                GEN7_SURFACE_MSFMT_DEPTH_STENCIL);
      }
   }
}

static void
gen7_emit_buffer_surface_state(struct brw_context *brw,
                               uint32_t *out_offset,
                               drm_intel_bo *bo,
                               unsigned buffer_offset,
                               unsigned surface_format,
                               unsigned buffer_size,
                               unsigned pitch,
                               unsigned mocs,
                               bool rw)
{
   uint32_t *surf = brw_state_batch(brw, AUB_TRACE_SURFACE_STATE,
                                    8 * 4, 32, out_offset);
   memset(surf, 0, 8 * 4);

   surf[0] = BRW_SURFACE_BUFFER << BRW_SURFACE_TYPE_SHIFT |
             surface_format << BRW_SURFACE_FORMAT_SHIFT |
             BRW_SURFACE_RC_READ_WRITE;
   surf[1] = (bo ? bo->offset64 : 0) + buffer_offset; /* reloc */
   surf[2] = SET_FIELD((buffer_size - 1) & 0x7f, GEN7_SURFACE_WIDTH) |
             SET_FIELD(((buffer_size - 1) >> 7) & 0x3fff, GEN7_SURFACE_HEIGHT);
   surf[3] = SET_FIELD(((buffer_size - 1) >> 21) & 0x3f, BRW_SURFACE_DEPTH) |
             (pitch - 1);

   surf[5] = SET_FIELD(mocs, GEN7_SURFACE_MOCS);

   if (brw->is_haswell) {
      surf[7] |= (SET_FIELD(HSW_SCS_RED,   GEN7_SURFACE_SCS_R) |
                  SET_FIELD(HSW_SCS_GREEN, GEN7_SURFACE_SCS_G) |
                  SET_FIELD(HSW_SCS_BLUE,  GEN7_SURFACE_SCS_B) |
                  SET_FIELD(HSW_SCS_ALPHA, GEN7_SURFACE_SCS_A));
   }

   /* Emit relocation to surface contents */
   if (bo) {
      drm_intel_bo_emit_reloc(brw->batch.bo, *out_offset + 4,
                              bo, buffer_offset, I915_GEM_DOMAIN_SAMPLER,
                              (rw ? I915_GEM_DOMAIN_SAMPLER : 0));
   }

   gen7_check_surface_setup(surf, false /* is_render_target */);
}

static void
gen7_update_texture_surface(struct gl_context *ctx,
                            unsigned unit,
                            uint32_t *surf_offset,
                            bool for_gather)
{
   struct brw_context *brw = brw_context(ctx);
   struct gl_texture_object *tObj = ctx->Texture.Unit[unit]._Current;
   struct intel_texture_object *intelObj = intel_texture_object(tObj);
   struct intel_mipmap_tree *mt = intelObj->mt;
   struct gl_texture_image *firstImage = tObj->Image[0][tObj->BaseLevel];
   struct gl_sampler_object *sampler = _mesa_get_samplerobj(ctx, unit);

   if (tObj->Target == GL_TEXTURE_BUFFER) {
      brw_update_buffer_texture_surface(ctx, unit, surf_offset);
      return;
   }

   uint32_t *surf = brw_state_batch(brw, AUB_TRACE_SURFACE_STATE,
                                    8 * 4, 32, surf_offset);
   memset(surf, 0, 8 * 4);

   uint32_t tex_format = translate_tex_format(brw,
                                              intelObj->_Format,
                                              sampler->sRGBDecode);

   if (for_gather && tex_format == BRW_SURFACEFORMAT_R32G32_FLOAT)
      tex_format = BRW_SURFACEFORMAT_R32G32_FLOAT_LD;

   surf[0] = translate_tex_target(tObj->Target) << BRW_SURFACE_TYPE_SHIFT |
             tex_format << BRW_SURFACE_FORMAT_SHIFT |
             gen7_surface_tiling_mode(mt->tiling);

   /* mask of faces present in cube map; for other surfaces MBZ. */
   if (tObj->Target == GL_TEXTURE_CUBE_MAP || tObj->Target == GL_TEXTURE_CUBE_MAP_ARRAY)
      surf[0] |= BRW_SURFACE_CUBEFACE_ENABLES;

   if (mt->align_h == 4)
      surf[0] |= GEN7_SURFACE_VALIGN_4;
   if (mt->align_w == 8)
      surf[0] |= GEN7_SURFACE_HALIGN_8;

   if (mt->logical_depth0 > 1 && tObj->Target != GL_TEXTURE_3D)
      surf[0] |= GEN7_SURFACE_IS_ARRAY;

   /* if this is a view with restricted NumLayers, then
    * our effective depth is not just the miptree depth.
    */
   uint32_t effective_depth = (tObj->Immutable && tObj->Target != GL_TEXTURE_3D)
                              ? tObj->NumLayers : mt->logical_depth0;

   if (mt->array_spacing_lod0)
      surf[0] |= GEN7_SURFACE_ARYSPC_LOD0;

   surf[1] = mt->bo->offset64 + mt->offset; /* reloc */

   surf[2] = SET_FIELD(mt->logical_width0 - 1, GEN7_SURFACE_WIDTH) |
             SET_FIELD(mt->logical_height0 - 1, GEN7_SURFACE_HEIGHT);

   surf[3] = SET_FIELD(effective_depth - 1, BRW_SURFACE_DEPTH) |
             (mt->pitch - 1);

   surf[4] = gen7_surface_msaa_bits(mt->num_samples, mt->msaa_layout) |
             SET_FIELD(tObj->MinLayer, GEN7_SURFACE_MIN_ARRAY_ELEMENT) |
             SET_FIELD((effective_depth - 1),
                       GEN7_SURFACE_RENDER_TARGET_VIEW_EXTENT);

   surf[5] = (SET_FIELD(GEN7_MOCS_L3, GEN7_SURFACE_MOCS) |
              SET_FIELD(tObj->MinLevel + tObj->BaseLevel - mt->first_level, GEN7_SURFACE_MIN_LOD) |
              /* mip count */
              (intelObj->_MaxLevel - tObj->BaseLevel));

   surf[7] = mt->fast_clear_color_value;

   if (brw->is_haswell) {
      /* Handling GL_ALPHA as a surface format override breaks 1.30+ style
       * texturing functions that return a float, as our code generation always
       * selects the .x channel (which would always be 0).
       */
      const bool alpha_depth = tObj->DepthMode == GL_ALPHA &&
         (firstImage->_BaseFormat == GL_DEPTH_COMPONENT ||
          firstImage->_BaseFormat == GL_DEPTH_STENCIL);

      const int swizzle = unlikely(alpha_depth)
         ? SWIZZLE_XYZW : brw_get_texture_swizzle(ctx, tObj);

      const bool need_scs_green_to_blue = for_gather && tex_format == BRW_SURFACEFORMAT_R32G32_FLOAT_LD;

      surf[7] |=
         SET_FIELD(brw_swizzle_to_scs(GET_SWZ(swizzle, 0), need_scs_green_to_blue), GEN7_SURFACE_SCS_R) |
         SET_FIELD(brw_swizzle_to_scs(GET_SWZ(swizzle, 1), need_scs_green_to_blue), GEN7_SURFACE_SCS_G) |
         SET_FIELD(brw_swizzle_to_scs(GET_SWZ(swizzle, 2), need_scs_green_to_blue), GEN7_SURFACE_SCS_B) |
         SET_FIELD(brw_swizzle_to_scs(GET_SWZ(swizzle, 3), need_scs_green_to_blue), GEN7_SURFACE_SCS_A);
   }

   if (mt->mcs_mt) {
      gen7_set_surface_mcs_info(brw, surf, *surf_offset,
                                mt->mcs_mt, false /* is RT */);
   }

   /* Emit relocation to surface contents */
   drm_intel_bo_emit_reloc(brw->batch.bo,
                           *surf_offset + 4,
                           mt->bo,
                           surf[1] - mt->bo->offset64,
                           I915_GEM_DOMAIN_SAMPLER, 0);

   gen7_check_surface_setup(surf, false /* is_render_target */);
}

/**
 * Create a raw surface for untyped R/W access.
 */
static void
gen7_create_raw_surface(struct brw_context *brw, drm_intel_bo *bo,
                        uint32_t offset, uint32_t size,
                        uint32_t *out_offset, bool rw)
{
   gen7_emit_buffer_surface_state(brw,
                                  out_offset,
                                  bo,
                                  offset,
                                  BRW_SURFACEFORMAT_RAW,
                                  size,
                                  1,
                                  0 /* mocs */,
                                  true /* rw */);
}

static void
gen7_update_null_renderbuffer_surface(struct brw_context *brw, unsigned unit)
{
   /* From the Ivy bridge PRM, Vol4 Part1 p62 (Surface Type: Programming
    * Notes):
    *
    *     A null surface is used in instances where an actual surface is not
    *     bound. When a write message is generated to a null surface, no
    *     actual surface is written to. When a read message (including any
    *     sampling engine message) is generated to a null surface, the result
    *     is all zeros. Note that a null surface type is allowed to be used
    *     with all messages, even if it is not specificially indicated as
    *     supported. All of the remaining fields in surface state are ignored
    *     for null surfaces, with the following exceptions: Width, Height,
    *     Depth, LOD, and Render Target View Extent fields must match the
    *     depth buffer’s corresponding state for all render target surfaces,
    *     including null.
    */
   struct gl_context *ctx = &brw->ctx;

   /* _NEW_BUFFERS */
   const struct gl_framebuffer *fb = ctx->DrawBuffer;
   uint32_t surf_index =
      brw->wm.prog_data->binding_table.render_target_start + unit;

   uint32_t *surf = brw_state_batch(brw, AUB_TRACE_SURFACE_STATE, 8 * 4, 32,
                                    &brw->wm.base.surf_offset[surf_index]);
   memset(surf, 0, 8 * 4);

   /* From the Ivybridge PRM, Volume 4, Part 1, page 65,
    * Tiled Surface: Programming Notes:
    * "If Surface Type is SURFTYPE_NULL, this field must be TRUE."
    */
   surf[0] = BRW_SURFACE_NULL << BRW_SURFACE_TYPE_SHIFT |
             BRW_SURFACEFORMAT_B8G8R8A8_UNORM << BRW_SURFACE_FORMAT_SHIFT |
             GEN7_SURFACE_TILING_Y;

   surf[2] = SET_FIELD(fb->Width - 1, GEN7_SURFACE_WIDTH) |
             SET_FIELD(fb->Height - 1, GEN7_SURFACE_HEIGHT);

   gen7_check_surface_setup(surf, true /* is_render_target */);
}

/**
 * Sets up a surface state structure to point at the given region.
 * While it is only used for the front/back buffer currently, it should be
 * usable for further buffers when doing ARB_draw_buffer support.
 */
static void
gen7_update_renderbuffer_surface(struct brw_context *brw,
				 struct gl_renderbuffer *rb,
				 bool layered,
				 unsigned int unit)
{
   struct gl_context *ctx = &brw->ctx;
   struct intel_renderbuffer *irb = intel_renderbuffer(rb);
   struct intel_mipmap_tree *mt = irb->mt;
   uint32_t format;
   /* _NEW_BUFFERS */
   mesa_format rb_format = _mesa_get_render_format(ctx, intel_rb_format(irb));
   uint32_t surftype;
   bool is_array = false;
   int depth = MAX2(irb->layer_count, 1);
   const uint8_t mocs = GEN7_MOCS_L3;

   int min_array_element = irb->mt_layer / MAX2(mt->num_samples, 1);

   GLenum gl_target = rb->TexImage ?
                         rb->TexImage->TexObject->Target : GL_TEXTURE_2D;

   uint32_t surf_index =
      brw->wm.prog_data->binding_table.render_target_start + unit;

   uint32_t *surf = brw_state_batch(brw, AUB_TRACE_SURFACE_STATE, 8 * 4, 32,
                                    &brw->wm.base.surf_offset[surf_index]);
   memset(surf, 0, 8 * 4);

   intel_miptree_used_for_rendering(irb->mt);

   /* Render targets can't use IMS layout */
   assert(irb->mt->msaa_layout != INTEL_MSAA_LAYOUT_IMS);

   assert(brw_render_target_supported(brw, rb));
   format = brw->render_target_format[rb_format];
   if (unlikely(!brw->format_supported_as_render_target[rb_format])) {
      _mesa_problem(ctx, "%s: renderbuffer format %s unsupported\n",
                    __FUNCTION__, _mesa_get_format_name(rb_format));
   }

   switch (gl_target) {
   case GL_TEXTURE_CUBE_MAP_ARRAY:
   case GL_TEXTURE_CUBE_MAP:
      surftype = BRW_SURFACE_2D;
      is_array = true;
      depth *= 6;
      break;
   case GL_TEXTURE_3D:
      depth = MAX2(irb->mt->logical_depth0, 1);
      /* fallthrough */
   default:
      surftype = translate_tex_target(gl_target);
      is_array = _mesa_tex_target_is_array(gl_target);
      break;
   }

   surf[0] = surftype << BRW_SURFACE_TYPE_SHIFT |
             format << BRW_SURFACE_FORMAT_SHIFT |
             (irb->mt->array_spacing_lod0 ? GEN7_SURFACE_ARYSPC_LOD0
                                          : GEN7_SURFACE_ARYSPC_FULL) |
             gen7_surface_tiling_mode(mt->tiling);

   if (irb->mt->align_h == 4)
      surf[0] |= GEN7_SURFACE_VALIGN_4;
   if (irb->mt->align_w == 8)
      surf[0] |= GEN7_SURFACE_HALIGN_8;

   if (is_array) {
      surf[0] |= GEN7_SURFACE_IS_ARRAY;
   }

   surf[1] = mt->bo->offset64;

   assert(brw->has_surface_tile_offset);

   surf[5] = SET_FIELD(mocs, GEN7_SURFACE_MOCS) |
             (irb->mt_level - irb->mt->first_level);

   surf[2] = SET_FIELD(irb->mt->logical_width0 - 1, GEN7_SURFACE_WIDTH) |
             SET_FIELD(irb->mt->logical_height0 - 1, GEN7_SURFACE_HEIGHT);

   surf[3] = ((depth - 1) << BRW_SURFACE_DEPTH_SHIFT) |
             (mt->pitch - 1);

   surf[4] = gen7_surface_msaa_bits(irb->mt->num_samples, irb->mt->msaa_layout) |
             min_array_element << GEN7_SURFACE_MIN_ARRAY_ELEMENT_SHIFT |
             (depth - 1) << GEN7_SURFACE_RENDER_TARGET_VIEW_EXTENT_SHIFT;

   if (irb->mt->mcs_mt) {
      gen7_set_surface_mcs_info(brw, surf, brw->wm.base.surf_offset[surf_index],
                                irb->mt->mcs_mt, true /* is RT */);
   }

   surf[7] = irb->mt->fast_clear_color_value;

   if (brw->is_haswell) {
      surf[7] |= (SET_FIELD(HSW_SCS_RED,   GEN7_SURFACE_SCS_R) |
                  SET_FIELD(HSW_SCS_GREEN, GEN7_SURFACE_SCS_G) |
                  SET_FIELD(HSW_SCS_BLUE,  GEN7_SURFACE_SCS_B) |
                  SET_FIELD(HSW_SCS_ALPHA, GEN7_SURFACE_SCS_A));
   }

   drm_intel_bo_emit_reloc(brw->batch.bo,
			   brw->wm.base.surf_offset[surf_index] + 4,
			   mt->bo,
			   surf[1] - mt->bo->offset64,
			   I915_GEM_DOMAIN_RENDER,
			   I915_GEM_DOMAIN_RENDER);

   gen7_check_surface_setup(surf, true /* is_render_target */);
}

void
gen7_init_vtable_surface_functions(struct brw_context *brw)
{
   brw->vtbl.update_texture_surface = gen7_update_texture_surface;
   brw->vtbl.update_renderbuffer_surface = gen7_update_renderbuffer_surface;
   brw->vtbl.update_null_renderbuffer_surface =
      gen7_update_null_renderbuffer_surface;
   brw->vtbl.create_raw_surface = gen7_create_raw_surface;
   brw->vtbl.emit_buffer_surface_state = gen7_emit_buffer_surface_state;
}
@


1.5
log
@Merge Mesa 10.2.9
@
text
@@


1.4
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d62 2
a63 1
   unreachable("Should not get here: invalid swizzle mode");
d319 1
a319 1
   if (mt->array_layout == ALL_SLICES_AT_EACH_LOD)
a396 8
/**
 * Creates a null renderbuffer surface.
 *
 * This is used when the shader doesn't write to any color output.  An FB
 * write to target 0 will still be emitted, because that's how the thread is
 * terminated (and computed depth is returned), so we need to have the
 * hardware discard the target 0 color output..
 */
d504 2
a505 2
             (irb->mt->array_layout == ALL_SLICES_AT_EACH_LOD ?
                 GEN7_SURFACE_ARYSPC_LOD0 : GEN7_SURFACE_ARYSPC_FULL) |
@


1.3
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d62 1
a62 2
   assert(!"Should not get here: invalid swizzle mode");
   return HSW_SCS_ZERO;
d318 1
a318 1
   if (mt->array_spacing_lod0)
d396 8
d511 2
a512 2
             (irb->mt->array_spacing_lod0 ? GEN7_SURFACE_ARYSPC_LOD0
                                          : GEN7_SURFACE_ARYSPC_FULL) |
@


1.2
log
@Merge Mesa 9.2.0
@
text
@d44 2
a45 2
static unsigned
swizzle_to_scs(GLenum swizzle)
d51 1
a51 1
      return HSW_SCS_GREEN;
d85 4
a88 6
   if (num_samples > 4)
      ss4 |= GEN7_SURFACE_MULTISAMPLECOUNT_8;
   else if (num_samples > 1)
      ss4 |= GEN7_SURFACE_MULTISAMPLECOUNT_4;
   else
      ss4 |= GEN7_SURFACE_MULTISAMPLECOUNT_1;
d110 1
a110 1
   assert(mcs_mt->region->tiling == I915_TILING_Y);
d115 1
a115 1
   unsigned pitch_tiles = mcs_mt->region->pitch / 128;
d123 1
a123 1
   assert ((mcs_mt->region->bo->offset & 0xfff) == 0);
d127 1
a127 1
             mcs_mt->region->bo->offset;
d131 1
a131 1
                           mcs_mt->region->bo,
a224 1

d226 9
a234 4
gen7_update_buffer_texture_surface(struct gl_context *ctx,
                                   unsigned unit,
                                   uint32_t *binding_table,
                                   unsigned surf_index)
a235 7
   struct brw_context *brw = brw_context(ctx);
   struct gl_texture_object *tObj = ctx->Texture.Unit[unit]._Current;
   struct intel_buffer_object *intel_obj =
      intel_buffer_object(tObj->BufferObject);
   drm_intel_bo *bo = intel_obj ? intel_obj->buffer : NULL;
   gl_format format = tObj->_BufferObjectFormat;

d237 1
a237 1
                                    8 * 4, 32, &binding_table[surf_index]);
a239 6
   uint32_t surface_format = brw_format_for_mesa_format(format);
   if (surface_format == 0 && format != MESA_FORMAT_RGBA_FLOAT32) {
      _mesa_problem(NULL, "bad format %s for texture buffer\n",
                    _mesa_get_format_name(format));
   }

d243 7
d251 8
d260 3
a262 15
      surf[1] = bo->offset; /* reloc */

      drm_intel_bo_emit_reloc(brw->batch.bo,
			      binding_table[surf_index] + 4,
			      bo, 0,
			      I915_GEM_DOMAIN_SAMPLER, 0);

      int texel_size = _mesa_get_format_bytes(format);
      int w = intel_obj->Base.Size / texel_size;

      /* note that these differ from GEN6 */
      surf[2] = SET_FIELD(w & 0x7f, GEN7_SURFACE_WIDTH) | /* bits 6:0 of size */
                SET_FIELD((w >> 7) & 0x3fff, GEN7_SURFACE_HEIGHT); /* 20:7 */
      surf[3] = SET_FIELD((w >> 21) & 0x3f, BRW_SURFACE_DEPTH) | /* bits 26:21 */
                (texel_size - 1);
d271 2
a272 2
                            uint32_t *binding_table,
                            unsigned surf_index)
a279 2
   uint32_t tile_x, tile_y;
   uint8_t mocs = brw->is_haswell ? GEN7_MOCS_L3 : 0;
d282 1
a282 1
      gen7_update_buffer_texture_surface(ctx, unit, binding_table, surf_index);
d287 1
a287 1
                                    8 * 4, 32, &binding_table[surf_index]);
d291 1
a291 2
                                              mt->format,
                                              tObj->DepthMode,
d294 3
d299 5
a303 2
             gen7_surface_tiling_mode(mt->region->tiling) |
             BRW_SURFACE_CUBEFACE_ENABLES;
d313 6
d322 1
a322 3
   surf[1] = mt->region->bo->offset + mt->offset; /* reloc */
   surf[1] += intel_miptree_get_tile_offsets(intelObj->mt, firstImage->Level, 0,
                                             &tile_x, &tile_y);
a325 2
   surf[3] = SET_FIELD(mt->logical_depth0 - 1, BRW_SURFACE_DEPTH) |
             ((intelObj->mt->region->pitch) - 1);
d327 7
a333 1
   surf[4] = gen7_surface_msaa_bits(mt->num_samples, mt->msaa_layout);
d335 2
a336 7
   assert(brw->has_surface_tile_offset || (tile_x == 0 && tile_y == 0));
   /* Note that the low bits of these fields are missing, so
    * there's the possibility of getting in trouble.
    */
   surf[5] = ((tile_x / 4) << BRW_SURFACE_X_OFFSET_SHIFT |
              (tile_y / 2) << BRW_SURFACE_Y_OFFSET_SHIFT |
              SET_FIELD(mocs, GEN7_SURFACE_MOCS) |
d340 2
d354 12
a365 5
      surf[7] =
         SET_FIELD(swizzle_to_scs(GET_SWZ(swizzle, 0)), GEN7_SURFACE_SCS_R) |
         SET_FIELD(swizzle_to_scs(GET_SWZ(swizzle, 1)), GEN7_SURFACE_SCS_G) |
         SET_FIELD(swizzle_to_scs(GET_SWZ(swizzle, 2)), GEN7_SURFACE_SCS_B) |
         SET_FIELD(swizzle_to_scs(GET_SWZ(swizzle, 3)), GEN7_SURFACE_SCS_A);
d370 4
a373 4
			   binding_table[surf_index] + 4,
			   intelObj->mt->region->bo,
                           surf[1] - intelObj->mt->region->bo->offset,
			   I915_GEM_DOMAIN_SAMPLER, 0);
d379 1
a379 2
 * Create the constant buffer surface.  Vertex/fragment shader constants will
 * be read from this buffer with Data Port Read instructions/messages.
d382 13
a394 77
gen7_create_constant_surface(struct brw_context *brw,
			     drm_intel_bo *bo,
			     uint32_t offset,
			     uint32_t size,
			     uint32_t *out_offset,
                             bool dword_pitch)
{
   uint32_t stride = dword_pitch ? 4 : 16;
   uint32_t elements = ALIGN(size, stride) / stride;
   const GLint w = elements - 1;

   uint32_t *surf = brw_state_batch(brw, AUB_TRACE_SURFACE_STATE,
                                    8 * 4, 32, out_offset);
   memset(surf, 0, 8 * 4);

   surf[0] = BRW_SURFACE_BUFFER << BRW_SURFACE_TYPE_SHIFT |
             BRW_SURFACEFORMAT_R32G32B32A32_FLOAT << BRW_SURFACE_FORMAT_SHIFT |
             BRW_SURFACE_RC_READ_WRITE;

   assert(bo);
   surf[1] = bo->offset + offset; /* reloc */

   /* note that these differ from GEN6 */
   surf[2] = SET_FIELD(w & 0x7f, GEN7_SURFACE_WIDTH) |
             SET_FIELD((w >> 7) & 0x3fff, GEN7_SURFACE_HEIGHT);
   surf[3] = SET_FIELD((w >> 21) & 0x3f, BRW_SURFACE_DEPTH) |
             (stride - 1);

   if (brw->is_haswell) {
      surf[7] = SET_FIELD(HSW_SCS_RED,   GEN7_SURFACE_SCS_R) |
                SET_FIELD(HSW_SCS_GREEN, GEN7_SURFACE_SCS_G) |
                SET_FIELD(HSW_SCS_BLUE,  GEN7_SURFACE_SCS_B) |
                SET_FIELD(HSW_SCS_ALPHA, GEN7_SURFACE_SCS_A);
   }

   drm_intel_bo_emit_reloc(brw->batch.bo,
			   *out_offset + 4,
			   bo, offset,
			   I915_GEM_DOMAIN_SAMPLER, 0);

   gen7_check_surface_setup(surf, false /* is_render_target */);
}

/**
 * Create a surface for shader time.
 */
void
gen7_create_shader_time_surface(struct brw_context *brw, uint32_t *out_offset)
{
   const int w = brw->shader_time.bo->size - 1;

   uint32_t *surf = brw_state_batch(brw, AUB_TRACE_SURFACE_STATE,
                                    8 * 4, 32, out_offset);
   memset(surf, 0, 8 * 4);

   surf[0] = BRW_SURFACE_BUFFER << BRW_SURFACE_TYPE_SHIFT |
             BRW_SURFACEFORMAT_RAW << BRW_SURFACE_FORMAT_SHIFT |
             BRW_SURFACE_RC_READ_WRITE;

   surf[1] = brw->shader_time.bo->offset; /* reloc */

   /* note that these differ from GEN6 */
   surf[2] = SET_FIELD(w & 0x7f, GEN7_SURFACE_WIDTH) |
             SET_FIELD((w >> 7) & 0x3fff, GEN7_SURFACE_HEIGHT);
   surf[3] = SET_FIELD((w >> 21) & 0x3f, BRW_SURFACE_DEPTH);

   /* Unlike texture or renderbuffer surfaces, we only do untyped operations
    * on the shader_time surface, so there's no need to set HSW channel
    * overrides.
    */

   drm_intel_bo_emit_reloc(brw->batch.bo,
                           *out_offset + 4,
                           brw->shader_time.bo, 0,
                           I915_GEM_DOMAIN_SAMPLER, 0);

   gen7_check_surface_setup(surf, false /* is_render_target */);
d419 2
d422 2
a423 2
   uint32_t *surf = brw_state_batch(brw, AUB_TRACE_SURFACE_STATE,
			            8 * 4, 32, &brw->wm.surf_offset[unit]);
d453 1
a453 1
   struct intel_region *region = irb->mt->region;
d456 1
a456 1
   gl_format rb_format = _mesa_get_render_format(ctx, intel_rb_format(irb));
d459 5
a463 3
   int depth = MAX2(rb->Depth, 1);
   int min_array_element;
   uint8_t mocs = brw->is_haswell ? GEN7_MOCS_L3 : 0;
d467 5
a471 2
   uint32_t *surf = brw_state_batch(brw, AUB_TRACE_SURFACE_STATE,
                                    8 * 4, 32, &brw->wm.surf_offset[unit]);
d493 3
a501 8
   if (layered) {
      min_array_element = 0;
   } else if (irb->mt->num_samples > 1) {
      min_array_element = irb->mt_layer / irb->mt->num_samples;
   } else {
      min_array_element = irb->mt_layer;
   }

d506 1
a506 1
             gen7_surface_tiling_mode(region->tiling);
d517 1
a517 1
   surf[1] = region->bo->offset;
d528 1
a528 1
             (region->pitch - 1);
d535 1
a535 1
      gen7_set_surface_mcs_info(brw, surf, brw->wm.surf_offset[unit],
d549 3
a551 3
			   brw->wm.surf_offset[unit] + 4,
			   region->bo,
			   surf[1] - region->bo->offset,
d565 2
a566 1
   brw->vtbl.create_constant_surface = gen7_create_constant_surface;
@


1.1
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d24 1
d26 1
a26 1
#include "main/texstore.h"
d33 1
d40 28
a67 2
static void
gen7_set_surface_tiling(struct gen7_surface_state *surf, uint32_t tiling)
a69 4
   case I915_TILING_NONE:
      surf->ss0.tiled_surface = 0;
      surf->ss0.tile_walk = 0;
      break;
d71 1
a71 3
      surf->ss0.tiled_surface = 1;
      surf->ss0.tile_walk = BRW_TILEWALK_XMAJOR;
      break;
d73 198
a270 3
      surf->ss0.tiled_surface = 1;
      surf->ss0.tile_walk = BRW_TILEWALK_YMAJOR;
      break;
d272 2
d277 4
a280 1
gen7_update_texture_surface(struct gl_context *ctx, GLuint unit)
d285 1
d288 7
a294 2
   const GLuint surf_index = SURF_INDEX_TEXTURE(unit);
   struct gen7_surface_state *surf;
d296 39
a334 47
   surf = brw_state_batch(brw, sizeof(*surf), 32,
			 &brw->wm.surf_offset[surf_index]);
   memset(surf, 0, sizeof(*surf));

   surf->ss0.surface_type = translate_tex_target(tObj->Target);
   surf->ss0.surface_format = translate_tex_format(firstImage->TexFormat,
                                                   firstImage->InternalFormat,
                                                   sampler->DepthMode,
                                                   sampler->sRGBDecode);
   if (tObj->Target == GL_TEXTURE_CUBE_MAP) {
      surf->ss0.cube_pos_x = 1;
      surf->ss0.cube_pos_y = 1;
      surf->ss0.cube_pos_z = 1;
      surf->ss0.cube_neg_x = 1;
      surf->ss0.cube_neg_y = 1;
      surf->ss0.cube_neg_z = 1;
   }

   gen7_set_surface_tiling(surf, intelObj->mt->region->tiling);

   /* ss0 remaining fields:
    * - is_array
    * - vertical_alignment
    * - horizontal_alignment
    * - vert_line_stride (exists on gen6 but we ignore it)
    * - vert_line_stride_ofs (exists on gen6 but we ignore it)
    * - surface_array_spacing
    * - render_cache_read_write (exists on gen6 but ignored here)
    */

   surf->ss1.base_addr = intelObj->mt->region->buffer->offset; /* reloc */

   surf->ss2.width = firstImage->Width - 1;
   surf->ss2.height = firstImage->Height - 1;

   surf->ss3.pitch = (intelObj->mt->region->pitch * intelObj->mt->cpp) - 1;
   surf->ss3.depth = firstImage->Depth - 1;

   /* ss4: ignored? */

   surf->ss5.mip_count = intelObj->_MaxLevel - tObj->BaseLevel;
   surf->ss5.min_lod = 0;

   /* ss5 remaining fields:
    * - x_offset (N/A for textures?)
    * - y_offset (ditto)
    * - cache_control
d336 24
d362 4
a365 4
   drm_intel_bo_emit_reloc(brw->intel.batch.bo,
			   brw->wm.surf_offset[surf_index] +
			   offsetof(struct gen7_surface_state, ss1),
			   intelObj->mt->region->buffer, 0,
d367 2
d375 1
a375 1
void
d378 4
a381 2
			     int width,
			     uint32_t *out_offset)
d383 11
a393 2
   const GLint w = width - 1;
   struct gen7_surface_state *surf;
d395 2
a396 2
   surf = brw_state_batch(brw, sizeof(*surf), 32, out_offset);
   memset(surf, 0, sizeof(*surf));
d398 12
a409 2
   surf->ss0.surface_type = BRW_SURFACE_BUFFER;
   surf->ss0.surface_format = BRW_SURFACEFORMAT_R32G32B32A32_FLOAT;
d411 4
a414 1
   surf->ss0.render_cache_read_write = 1;
d416 1
a416 18
   assert(bo);
   surf->ss1.base_addr = bo->offset; /* reloc */

   surf->ss2.width = w & 0x7f;            /* bits 6:0 of size or width */
   surf->ss2.height = (w >> 7) & 0x1fff;  /* bits 19:7 of size or width */
   surf->ss3.depth = (w >> 20) & 0x7f;    /* bits 26:20 of size or width */
   surf->ss3.pitch = (width * 16) - 1; /* ignored?? */
   gen7_set_surface_tiling(surf, I915_TILING_NONE); /* tiling now allowed */

   /* Emit relocation to surface contents.  Section 5.1.1 of the gen4
    * bspec ("Data Cache") says that the data cache does not exist as
    * a separate cache and is just the sampler cache.
    */
   drm_intel_bo_emit_reloc(brw->intel.batch.bo,
			   (*out_offset +
			    offsetof(struct gen7_surface_state, ss1)),
			   bo, 0,
			   I915_GEM_DOMAIN_SAMPLER, 0);
d420 1
a420 6
 * Updates surface / buffer for fragment shader constant buffer, if
 * one is required.
 *
 * This consumes the state updates for the constant buffer, and produces
 * BRW_NEW_WM_SURFACES to get picked up by brw_prepare_wm_surfaces for
 * inclusion in the binding table.
d422 2
a423 1
static void upload_wm_constant_surface(struct brw_context *brw)
d425 26
a450 16
   GLuint surf = SURF_INDEX_FRAG_CONST_BUFFER;
   struct brw_fragment_program *fp =
      (struct brw_fragment_program *) brw->fragment_program;
   const struct gl_program_parameter_list *params =
      fp->program.Base.Parameters;

   /* If there's no constant buffer, then no surface BO is needed to point at
    * it.
    */
   if (brw->wm.const_bo == 0) {
      if (brw->wm.surf_offset[surf]) {
	 brw->state.dirty.brw |= BRW_NEW_WM_SURFACES;
	 brw->wm.surf_offset[surf] = 0;
      }
      return;
   }
d452 1
a452 3
   gen7_create_constant_surface(brw, brw->wm.const_bo, params->NumParameters,
			        &brw->wm.surf_offset[surf]);
   brw->state.dirty.brw |= BRW_NEW_WM_SURFACES;
a454 10
const struct brw_tracked_state gen7_wm_constant_surface = {
   .dirty = {
      .mesa = 0,
      .brw = (BRW_NEW_WM_CONSTBUF |
	      BRW_NEW_BATCH),
      .cache = 0
   },
   .emit = upload_wm_constant_surface,
};

d458 16
a473 1
   struct gen7_surface_state *surf;
d475 2
a476 3
   surf = brw_state_batch(brw, sizeof(*surf), 32,
			 &brw->wm.surf_offset[unit]);
   memset(surf, 0, sizeof(*surf));
d478 16
a493 2
   surf->ss0.surface_type = BRW_SURFACE_NULL;
   surf->ss0.surface_format = BRW_SURFACEFORMAT_B8G8R8A8_UNORM;
d504 1
d507 1
a507 2
   struct intel_context *intel = &brw->intel;
   struct gl_context *ctx = &intel->ctx;
d509 27
a535 3
   struct intel_region *region = irb->region;
   struct gen7_surface_state *surf;
   uint32_t tile_x, tile_y;
d537 6
a542 14
   surf = brw_state_batch(brw, sizeof(*surf), 32,
			  &brw->wm.surf_offset[unit]);
   memset(surf, 0, sizeof(*surf));

   switch (irb->Base.Format) {
   case MESA_FORMAT_XRGB8888:
      /* XRGB is handled as ARGB because the chips in this family
       * cannot render to XRGB targets.  This means that we have to
       * mask writes to alpha (ala glColorMask) and reconfigure the
       * alpha blending hardware to use GL_ONE (or GL_ZERO) for
       * cases where GL_DST_ALPHA (or GL_ONE_MINUS_DST_ALPHA) is
       * used.
       */
      surf->ss0.surface_format = BRW_SURFACEFORMAT_B8G8R8A8_UNORM;
d544 3
a546 7
   case MESA_FORMAT_INTENSITY_FLOAT32:
   case MESA_FORMAT_LUMINANCE_FLOAT32:
      /* For these formats, we just need to read/write the first
       * channel into R, which is to say that we just treat them as
       * GL_RED.
       */
      surf->ss0.surface_format = BRW_SURFACEFORMAT_R32_FLOAT;
a547 11
   case MESA_FORMAT_SARGB8:
      /* without GL_EXT_framebuffer_sRGB we shouldn't bind sRGB
	 surfaces to the blend/update as sRGB */
      if (ctx->Color.sRGBEnabled)
	 surf->ss0.surface_format = brw_format_for_mesa_format(irb->Base.Format);
      else
	 surf->ss0.surface_format = BRW_SURFACEFORMAT_B8G8R8A8_UNORM;
      break;
   default:
      assert(brw_render_target_supported(irb->Base.Format));
      surf->ss0.surface_format = brw_format_for_mesa_format(irb->Base.Format);
d550 24
a573 4
   surf->ss0.surface_type = BRW_SURFACE_2D;
   /* reloc */
   surf->ss1.base_addr = intel_renderbuffer_tile_offsets(irb, &tile_x, &tile_y);
   surf->ss1.base_addr += region->buffer->offset; /* reloc */
a575 21
   /* Note that the low bits of these fields are missing, so
    * there's the possibility of getting in trouble.
    */
   assert(tile_x % 4 == 0);
   assert(tile_y % 2 == 0);
   surf->ss5.x_offset = tile_x / 4;
   surf->ss5.y_offset = tile_y / 2;

   surf->ss2.width = rb->Width - 1;
   surf->ss2.height = rb->Height - 1;
   gen7_set_surface_tiling(surf, region->tiling);
   surf->ss3.pitch = (region->pitch * region->cpp) - 1;

   drm_intel_bo_emit_reloc(brw->intel.batch.bo,
			   brw->wm.surf_offset[unit] +
			   offsetof(struct gen7_surface_state, ss1),
			   region->buffer,
			   surf->ss1.base_addr - region->buffer->offset,
			   I915_GEM_DOMAIN_RENDER,
			   I915_GEM_DOMAIN_RENDER);
}
d577 2
a578 18
static void
prepare_wm_surfaces(struct brw_context *brw)
{
   struct gl_context *ctx = &brw->intel.ctx;
   int i;
   int nr_surfaces = 0;

   if (ctx->DrawBuffer->_NumColorDrawBuffers >= 1) {
      for (i = 0; i < ctx->DrawBuffer->_NumColorDrawBuffers; i++) {
	 struct gl_renderbuffer *rb = ctx->DrawBuffer->_ColorDrawBuffers[i];
	 struct intel_renderbuffer *irb = intel_renderbuffer(rb);
	 struct intel_region *region = irb ? irb->region : NULL;

	 if (region)
	    brw_add_validated_bo(brw, region->buffer);
	 nr_surfaces = SURF_INDEX_DRAW(i) + 1;
      }
   }
d580 2
a581 4
   if (brw->wm.const_bo) {
      brw_add_validated_bo(brw, brw->wm.const_bo);
      nr_surfaces = SURF_INDEX_FRAG_CONST_BUFFER + 1;
   }
d583 2
a584 10
   for (i = 0; i < BRW_MAX_TEX_UNIT; i++) {
      const struct gl_texture_unit *texUnit = &ctx->Texture.Unit[i];
      struct gl_texture_object *tObj = texUnit->_Current;
      struct intel_texture_object *intelObj = intel_texture_object(tObj);

      if (texUnit->_ReallyEnabled) {
	 brw_add_validated_bo(brw, intelObj->mt->region->buffer);
	 nr_surfaces = SURF_INDEX_TEXTURE(i) + 1;
      }
   }
d586 7
a592 6
   /* Have to update this in our prepare, since the unit's prepare
    * relies on it.
    */
   if (brw->wm.nr_surfaces != nr_surfaces) {
      brw->wm.nr_surfaces = nr_surfaces;
      brw->state.dirty.brw |= BRW_NEW_NR_WM_SURFACES;
a593 1
}
d595 1
a595 9
/**
 * Constructs the set of surface state objects pointed to by the
 * binding table.
 */
static void
upload_wm_surfaces(struct brw_context *brw)
{
   struct gl_context *ctx = &brw->intel.ctx;
   GLuint i;
d597 5
a601 13
   /* _NEW_BUFFERS | _NEW_COLOR */
   /* Update surfaces for drawing buffers */
   if (ctx->DrawBuffer->_NumColorDrawBuffers >= 1) {
      for (i = 0; i < ctx->DrawBuffer->_NumColorDrawBuffers; i++) {
	 if (intel_renderbuffer(ctx->DrawBuffer->_ColorDrawBuffers[i])) {
	    gen7_update_renderbuffer_surface(brw,
	       ctx->DrawBuffer->_ColorDrawBuffers[i], i);
	 } else {
	    gen7_update_null_renderbuffer_surface(brw, i);
	 }
      }
   } else {
      gen7_update_null_renderbuffer_surface(brw, 0);
d604 6
a609 12
   /* Update surfaces for textures */
   for (i = 0; i < BRW_MAX_TEX_UNIT; i++) {
      const struct gl_texture_unit *texUnit = &ctx->Texture.Unit[i];
      const GLuint surf = SURF_INDEX_TEXTURE(i);

      /* _NEW_TEXTURE */
      if (texUnit->_ReallyEnabled) {
	 gen7_update_texture_surface(ctx, i);
      } else {
         brw->wm.surf_offset[surf] = 0;
      }
   }
d611 1
a611 1
   brw->state.dirty.brw |= BRW_NEW_WM_SURFACES;
d614 9
a622 11
const struct brw_tracked_state gen7_wm_surfaces = {
   .dirty = {
      .mesa = (_NEW_COLOR |
               _NEW_TEXTURE |
               _NEW_BUFFERS),
      .brw = BRW_NEW_BATCH,
      .cache = 0
   },
   .prepare = prepare_wm_surfaces,
   .emit = upload_wm_surfaces,
};
@


1.1.1.1
log
@Import Mesa 9.2.0
@
text
@a23 1
#include "main/blend.h"
d25 1
a25 1
#include "main/texformat.h"
a31 1
#include "intel_buffer_objects.h"
d38 2
a39 28
/**
 * Convert an swizzle enumeration (i.e. SWIZZLE_X) to one of the Gen7.5+
 * "Shader Channel Select" enumerations (i.e. HSW_SCS_RED)
 */
static unsigned
swizzle_to_scs(GLenum swizzle)
{
   switch (swizzle) {
   case SWIZZLE_X:
      return HSW_SCS_RED;
   case SWIZZLE_Y:
      return HSW_SCS_GREEN;
   case SWIZZLE_Z:
      return HSW_SCS_BLUE;
   case SWIZZLE_W:
      return HSW_SCS_ALPHA;
   case SWIZZLE_ZERO:
      return HSW_SCS_ZERO;
   case SWIZZLE_ONE:
      return HSW_SCS_ONE;
   }

   assert(!"Should not get here: invalid swizzle mode");
   return HSW_SCS_ZERO;
}

uint32_t
gen7_surface_tiling_mode(uint32_t tiling)
d42 4
d47 3
a49 1
      return GEN7_SURFACE_TILING_X;
d51 3
a53 3
      return GEN7_SURFACE_TILING_Y;
   default:
      return GEN7_SURFACE_TILING_NONE;
a56 197

uint32_t
gen7_surface_msaa_bits(unsigned num_samples, enum intel_msaa_layout layout)
{
   uint32_t ss4 = 0;

   if (num_samples > 4)
      ss4 |= GEN7_SURFACE_MULTISAMPLECOUNT_8;
   else if (num_samples > 1)
      ss4 |= GEN7_SURFACE_MULTISAMPLECOUNT_4;
   else
      ss4 |= GEN7_SURFACE_MULTISAMPLECOUNT_1;

   if (layout == INTEL_MSAA_LAYOUT_IMS)
      ss4 |= GEN7_SURFACE_MSFMT_DEPTH_STENCIL;
   else
      ss4 |= GEN7_SURFACE_MSFMT_MSS;

   return ss4;
}


void
gen7_set_surface_mcs_info(struct brw_context *brw,
                          uint32_t *surf,
                          uint32_t surf_offset,
                          const struct intel_mipmap_tree *mcs_mt,
                          bool is_render_target)
{
   /* From the Ivy Bridge PRM, Vol4 Part1 p76, "MCS Base Address":
    *
    *     "The MCS surface must be stored as Tile Y."
    */
   assert(mcs_mt->region->tiling == I915_TILING_Y);

   /* Compute the pitch in units of tiles.  To do this we need to divide the
    * pitch in bytes by 128, since a single Y-tile is 128 bytes wide.
    */
   unsigned pitch_tiles = mcs_mt->region->pitch / 128;

   /* The upper 20 bits of surface state DWORD 6 are the upper 20 bits of the
    * GPU address of the MCS buffer; the lower 12 bits contain other control
    * information.  Since buffer addresses are always on 4k boundaries (and
    * thus have their lower 12 bits zero), we can use an ordinary reloc to do
    * the necessary address translation.
    */
   assert ((mcs_mt->region->bo->offset & 0xfff) == 0);

   surf[6] = GEN7_SURFACE_MCS_ENABLE |
             SET_FIELD(pitch_tiles - 1, GEN7_SURFACE_MCS_PITCH) |
             mcs_mt->region->bo->offset;

   drm_intel_bo_emit_reloc(brw->batch.bo,
                           surf_offset + 6 * 4,
                           mcs_mt->region->bo,
                           surf[6] & 0xfff,
                           is_render_target ? I915_GEM_DOMAIN_RENDER
                           : I915_GEM_DOMAIN_SAMPLER,
                           is_render_target ? I915_GEM_DOMAIN_RENDER : 0);
}


void
gen7_check_surface_setup(uint32_t *surf, bool is_render_target)
{
   unsigned num_multisamples = surf[4] & INTEL_MASK(5, 3);
   unsigned multisampled_surface_storage_format = surf[4] & (1 << 6);
   unsigned surface_array_spacing = surf[0] & (1 << 10);
   bool is_multisampled = num_multisamples != GEN7_SURFACE_MULTISAMPLECOUNT_1;

   (void) surface_array_spacing;

   /* From the Ivybridge PRM, Volume 4 Part 1, page 66 (RENDER_SURFACE_STATE
    * dword 0 bit 10 "Surface Array Spacing" Programming Notes):
    *
    *   If Multisampled Surface Storage Format is MSFMT_MSS and Number of
    *   Multisamples is not MULTISAMPLECOUNT_1, this field must be set to
    *   ARYSPC_LOD0.
    */
   if (multisampled_surface_storage_format == GEN7_SURFACE_MSFMT_MSS
       && is_multisampled)
      assert(surface_array_spacing == GEN7_SURFACE_ARYSPC_LOD0);

   /* From the Ivybridge PRM, Volume 4 Part 1, page 72 (RENDER_SURFACE_STATE
    * dword 4 bit 6 "Multisampled Surface Storage" Programming Notes):
    *
    *   All multisampled render target surfaces must have this field set to
    *   MSFMT_MSS.
    *
    * But also:
    *
    *   This field is ignored if Number of Multisamples is MULTISAMPLECOUNT_1.
    */
   if (is_render_target && is_multisampled) {
      assert(multisampled_surface_storage_format == GEN7_SURFACE_MSFMT_MSS);
   }

   /* From the Ivybridge PRM, Volume 4 Part 1, page 72 (RENDER_SURFACE_STATE
    * dword 4 bit 6 "Multisampled Surface Storage Format" Errata):
    *
    *   If the surface’s Number of Multisamples is MULTISAMPLECOUNT_8, Width
    *   is >= 8192 (meaning the actual surface width is >= 8193 pixels), this
    *   field must be set to MSFMT_MSS.
    */
   uint32_t width = GET_FIELD(surf[2], GEN7_SURFACE_WIDTH) + 1;
   if (num_multisamples == GEN7_SURFACE_MULTISAMPLECOUNT_8 && width >= 8193) {
      assert(multisampled_surface_storage_format == GEN7_SURFACE_MSFMT_MSS);
   }

   /* From the Ivybridge PRM, Volume 4 Part 1, page 72 (RENDER_SURFACE_STATE
    * dword 4 bit 6 "Multisampled Surface Storage Format" Errata):
    *
    *   If the surface’s Number of Multisamples is MULTISAMPLECOUNT_8,
    *   ((Depth+1) * (Height+1)) is > 4,194,304, OR if the surface’s Number of
    *   Multisamples is MULTISAMPLECOUNT_4, ((Depth+1) * (Height+1)) is >
    *   8,388,608, this field must be set to MSFMT_DEPTH_STENCIL.This field
    *   must be set to MSFMT_DEPTH_STENCIL if Surface Format is one of the
    *   following: I24X8_UNORM, L24X8_UNORM, A24X8_UNORM, or
    *   R24_UNORM_X8_TYPELESS.
    *
    * But also (from the Programming Notes):
    *
    *   This field is ignored if Number of Multisamples is MULTISAMPLECOUNT_1.
    */
   uint32_t depth = GET_FIELD(surf[3], BRW_SURFACE_DEPTH) + 1;
   uint32_t height = GET_FIELD(surf[2], GEN7_SURFACE_HEIGHT) + 1;
   if (num_multisamples == GEN7_SURFACE_MULTISAMPLECOUNT_8 &&
       depth * height > 4194304) {
      assert(multisampled_surface_storage_format ==
             GEN7_SURFACE_MSFMT_DEPTH_STENCIL);
   }
   if (num_multisamples == GEN7_SURFACE_MULTISAMPLECOUNT_4 &&
       depth * height > 8388608) {
      assert(multisampled_surface_storage_format ==
             GEN7_SURFACE_MSFMT_DEPTH_STENCIL);
   }
   if (is_multisampled) {
      switch (GET_FIELD(surf[0], BRW_SURFACE_FORMAT)) {
      case BRW_SURFACEFORMAT_I24X8_UNORM:
      case BRW_SURFACEFORMAT_L24X8_UNORM:
      case BRW_SURFACEFORMAT_A24X8_UNORM:
      case BRW_SURFACEFORMAT_R24_UNORM_X8_TYPELESS:
         assert(multisampled_surface_storage_format ==
                GEN7_SURFACE_MSFMT_DEPTH_STENCIL);
      }
   }
}


static void
gen7_update_buffer_texture_surface(struct gl_context *ctx,
                                   unsigned unit,
                                   uint32_t *binding_table,
                                   unsigned surf_index)
{
   struct brw_context *brw = brw_context(ctx);
   struct gl_texture_object *tObj = ctx->Texture.Unit[unit]._Current;
   struct intel_buffer_object *intel_obj =
      intel_buffer_object(tObj->BufferObject);
   drm_intel_bo *bo = intel_obj ? intel_obj->buffer : NULL;
   gl_format format = tObj->_BufferObjectFormat;

   uint32_t *surf = brw_state_batch(brw, AUB_TRACE_SURFACE_STATE,
                                    8 * 4, 32, &binding_table[surf_index]);
   memset(surf, 0, 8 * 4);

   uint32_t surface_format = brw_format_for_mesa_format(format);
   if (surface_format == 0 && format != MESA_FORMAT_RGBA_FLOAT32) {
      _mesa_problem(NULL, "bad format %s for texture buffer\n",
                    _mesa_get_format_name(format));
   }

   surf[0] = BRW_SURFACE_BUFFER << BRW_SURFACE_TYPE_SHIFT |
             surface_format << BRW_SURFACE_FORMAT_SHIFT |
             BRW_SURFACE_RC_READ_WRITE;

   if (bo) {
      surf[1] = bo->offset; /* reloc */

      drm_intel_bo_emit_reloc(brw->batch.bo,
			      binding_table[surf_index] + 4,
			      bo, 0,
			      I915_GEM_DOMAIN_SAMPLER, 0);

      int texel_size = _mesa_get_format_bytes(format);
      int w = intel_obj->Base.Size / texel_size;

      /* note that these differ from GEN6 */
      surf[2] = SET_FIELD(w & 0x7f, GEN7_SURFACE_WIDTH) | /* bits 6:0 of size */
                SET_FIELD((w >> 7) & 0x3fff, GEN7_SURFACE_HEIGHT); /* 20:7 */
      surf[3] = SET_FIELD((w >> 21) & 0x3f, BRW_SURFACE_DEPTH) | /* bits 26:21 */
                (texel_size - 1);
   }

   gen7_check_surface_setup(surf, false /* is_render_target */);
}

d58 1
a58 4
gen7_update_texture_surface(struct gl_context *ctx,
                            unsigned unit,
                            uint32_t *binding_table,
                            unsigned surf_index)
a62 1
   struct intel_mipmap_tree *mt = intelObj->mt;
d65 2
a66 7
   uint32_t tile_x, tile_y;
   uint8_t mocs = brw->is_haswell ? GEN7_MOCS_L3 : 0;

   if (tObj->Target == GL_TEXTURE_BUFFER) {
      gen7_update_buffer_texture_surface(ctx, unit, binding_table, surf_index);
      return;
   }
d68 47
a114 39
   uint32_t *surf = brw_state_batch(brw, AUB_TRACE_SURFACE_STATE,
                                    8 * 4, 32, &binding_table[surf_index]);
   memset(surf, 0, 8 * 4);

   uint32_t tex_format = translate_tex_format(brw,
                                              mt->format,
                                              tObj->DepthMode,
                                              sampler->sRGBDecode);

   surf[0] = translate_tex_target(tObj->Target) << BRW_SURFACE_TYPE_SHIFT |
             tex_format << BRW_SURFACE_FORMAT_SHIFT |
             gen7_surface_tiling_mode(mt->region->tiling) |
             BRW_SURFACE_CUBEFACE_ENABLES;

   if (mt->align_h == 4)
      surf[0] |= GEN7_SURFACE_VALIGN_4;
   if (mt->align_w == 8)
      surf[0] |= GEN7_SURFACE_HALIGN_8;

   if (mt->logical_depth0 > 1 && tObj->Target != GL_TEXTURE_3D)
      surf[0] |= GEN7_SURFACE_IS_ARRAY;

   if (mt->array_spacing_lod0)
      surf[0] |= GEN7_SURFACE_ARYSPC_LOD0;

   surf[1] = mt->region->bo->offset + mt->offset; /* reloc */
   surf[1] += intel_miptree_get_tile_offsets(intelObj->mt, firstImage->Level, 0,
                                             &tile_x, &tile_y);

   surf[2] = SET_FIELD(mt->logical_width0 - 1, GEN7_SURFACE_WIDTH) |
             SET_FIELD(mt->logical_height0 - 1, GEN7_SURFACE_HEIGHT);
   surf[3] = SET_FIELD(mt->logical_depth0 - 1, BRW_SURFACE_DEPTH) |
             ((intelObj->mt->region->pitch) - 1);

   surf[4] = gen7_surface_msaa_bits(mt->num_samples, mt->msaa_layout);

   assert(brw->has_surface_tile_offset || (tile_x == 0 && tile_y == 0));
   /* Note that the low bits of these fields are missing, so
    * there's the possibility of getting in trouble.
a115 24
   surf[5] = ((tile_x / 4) << BRW_SURFACE_X_OFFSET_SHIFT |
              (tile_y / 2) << BRW_SURFACE_Y_OFFSET_SHIFT |
              SET_FIELD(mocs, GEN7_SURFACE_MOCS) |
              /* mip count */
              (intelObj->_MaxLevel - tObj->BaseLevel));

   if (brw->is_haswell) {
      /* Handling GL_ALPHA as a surface format override breaks 1.30+ style
       * texturing functions that return a float, as our code generation always
       * selects the .x channel (which would always be 0).
       */
      const bool alpha_depth = tObj->DepthMode == GL_ALPHA &&
         (firstImage->_BaseFormat == GL_DEPTH_COMPONENT ||
          firstImage->_BaseFormat == GL_DEPTH_STENCIL);

      const int swizzle = unlikely(alpha_depth)
         ? SWIZZLE_XYZW : brw_get_texture_swizzle(ctx, tObj);

      surf[7] =
         SET_FIELD(swizzle_to_scs(GET_SWZ(swizzle, 0)), GEN7_SURFACE_SCS_R) |
         SET_FIELD(swizzle_to_scs(GET_SWZ(swizzle, 1)), GEN7_SURFACE_SCS_G) |
         SET_FIELD(swizzle_to_scs(GET_SWZ(swizzle, 2)), GEN7_SURFACE_SCS_B) |
         SET_FIELD(swizzle_to_scs(GET_SWZ(swizzle, 3)), GEN7_SURFACE_SCS_A);
   }
d118 4
a121 4
   drm_intel_bo_emit_reloc(brw->batch.bo,
			   binding_table[surf_index] + 4,
			   intelObj->mt->region->bo,
                           surf[1] - intelObj->mt->region->bo->offset,
a122 2

   gen7_check_surface_setup(surf, false /* is_render_target */);
d129 1
a129 1
static void
d132 2
a133 4
			     uint32_t offset,
			     uint32_t size,
			     uint32_t *out_offset,
                             bool dword_pitch)
d135 10
a144 11
   uint32_t stride = dword_pitch ? 4 : 16;
   uint32_t elements = ALIGN(size, stride) / stride;
   const GLint w = elements - 1;

   uint32_t *surf = brw_state_batch(brw, AUB_TRACE_SURFACE_STATE,
                                    8 * 4, 32, out_offset);
   memset(surf, 0, 8 * 4);

   surf[0] = BRW_SURFACE_BUFFER << BRW_SURFACE_TYPE_SHIFT |
             BRW_SURFACEFORMAT_R32G32B32A32_FLOAT << BRW_SURFACE_FORMAT_SHIFT |
             BRW_SURFACE_RC_READ_WRITE;
d147 1
a147 1
   surf[1] = bo->offset + offset; /* reloc */
d149 14
a162 16
   /* note that these differ from GEN6 */
   surf[2] = SET_FIELD(w & 0x7f, GEN7_SURFACE_WIDTH) |
             SET_FIELD((w >> 7) & 0x3fff, GEN7_SURFACE_HEIGHT);
   surf[3] = SET_FIELD((w >> 21) & 0x3f, BRW_SURFACE_DEPTH) |
             (stride - 1);

   if (brw->is_haswell) {
      surf[7] = SET_FIELD(HSW_SCS_RED,   GEN7_SURFACE_SCS_R) |
                SET_FIELD(HSW_SCS_GREEN, GEN7_SURFACE_SCS_G) |
                SET_FIELD(HSW_SCS_BLUE,  GEN7_SURFACE_SCS_B) |
                SET_FIELD(HSW_SCS_ALPHA, GEN7_SURFACE_SCS_A);
   }

   drm_intel_bo_emit_reloc(brw->batch.bo,
			   *out_offset + 4,
			   bo, offset,
a163 2

   gen7_check_surface_setup(surf, false /* is_render_target */);
d167 6
a172 1
 * Create a surface for shader time.
d174 1
a174 2
void
gen7_create_shader_time_surface(struct brw_context *brw, uint32_t *out_offset)
d176 16
a191 1
   const int w = brw->shader_time.bo->size - 1;
d193 4
a196 24
   uint32_t *surf = brw_state_batch(brw, AUB_TRACE_SURFACE_STATE,
                                    8 * 4, 32, out_offset);
   memset(surf, 0, 8 * 4);

   surf[0] = BRW_SURFACE_BUFFER << BRW_SURFACE_TYPE_SHIFT |
             BRW_SURFACEFORMAT_RAW << BRW_SURFACE_FORMAT_SHIFT |
             BRW_SURFACE_RC_READ_WRITE;

   surf[1] = brw->shader_time.bo->offset; /* reloc */

   /* note that these differ from GEN6 */
   surf[2] = SET_FIELD(w & 0x7f, GEN7_SURFACE_WIDTH) |
             SET_FIELD((w >> 7) & 0x3fff, GEN7_SURFACE_HEIGHT);
   surf[3] = SET_FIELD((w >> 21) & 0x3f, BRW_SURFACE_DEPTH);

   /* Unlike texture or renderbuffer surfaces, we only do untyped operations
    * on the shader_time surface, so there's no need to set HSW channel
    * overrides.
    */

   drm_intel_bo_emit_reloc(brw->batch.bo,
                           *out_offset + 4,
                           brw->shader_time.bo, 0,
                           I915_GEM_DOMAIN_SAMPLER, 0);
d198 9
a206 2
   gen7_check_surface_setup(surf, false /* is_render_target */);
}
d211 1
a211 16
   /* From the Ivy bridge PRM, Vol4 Part1 p62 (Surface Type: Programming
    * Notes):
    *
    *     A null surface is used in instances where an actual surface is not
    *     bound. When a write message is generated to a null surface, no
    *     actual surface is written to. When a read message (including any
    *     sampling engine message) is generated to a null surface, the result
    *     is all zeros. Note that a null surface type is allowed to be used
    *     with all messages, even if it is not specificially indicated as
    *     supported. All of the remaining fields in surface state are ignored
    *     for null surfaces, with the following exceptions: Width, Height,
    *     Depth, LOD, and Render Target View Extent fields must match the
    *     depth buffer’s corresponding state for all render target surfaces,
    *     including null.
    */
   struct gl_context *ctx = &brw->ctx;
d213 3
a215 2
   /* _NEW_BUFFERS */
   const struct gl_framebuffer *fb = ctx->DrawBuffer;
d217 2
a218 16
   uint32_t *surf = brw_state_batch(brw, AUB_TRACE_SURFACE_STATE,
			            8 * 4, 32, &brw->wm.surf_offset[unit]);
   memset(surf, 0, 8 * 4);

   /* From the Ivybridge PRM, Volume 4, Part 1, page 65,
    * Tiled Surface: Programming Notes:
    * "If Surface Type is SURFTYPE_NULL, this field must be TRUE."
    */
   surf[0] = BRW_SURFACE_NULL << BRW_SURFACE_TYPE_SHIFT |
             BRW_SURFACEFORMAT_B8G8R8A8_UNORM << BRW_SURFACE_FORMAT_SHIFT |
             GEN7_SURFACE_TILING_Y;

   surf[2] = SET_FIELD(fb->Width - 1, GEN7_SURFACE_WIDTH) |
             SET_FIELD(fb->Height - 1, GEN7_SURFACE_HEIGHT);

   gen7_check_surface_setup(surf, true /* is_render_target */);
a228 1
				 bool layered,
d231 2
a232 1
   struct gl_context *ctx = &brw->ctx;
d234 3
a236 27
   struct intel_region *region = irb->mt->region;
   uint32_t format;
   /* _NEW_BUFFERS */
   gl_format rb_format = _mesa_get_render_format(ctx, intel_rb_format(irb));
   uint32_t surftype;
   bool is_array = false;
   int depth = MAX2(rb->Depth, 1);
   int min_array_element;
   uint8_t mocs = brw->is_haswell ? GEN7_MOCS_L3 : 0;
   GLenum gl_target = rb->TexImage ?
                         rb->TexImage->TexObject->Target : GL_TEXTURE_2D;

   uint32_t *surf = brw_state_batch(brw, AUB_TRACE_SURFACE_STATE,
                                    8 * 4, 32, &brw->wm.surf_offset[unit]);
   memset(surf, 0, 8 * 4);

   intel_miptree_used_for_rendering(irb->mt);

   /* Render targets can't use IMS layout */
   assert(irb->mt->msaa_layout != INTEL_MSAA_LAYOUT_IMS);

   assert(brw_render_target_supported(brw, rb));
   format = brw->render_target_format[rb_format];
   if (unlikely(!brw->format_supported_as_render_target[rb_format])) {
      _mesa_problem(ctx, "%s: renderbuffer format %s unsupported\n",
                    __FUNCTION__, _mesa_get_format_name(rb_format));
   }
d238 30
a267 6
   switch (gl_target) {
   case GL_TEXTURE_CUBE_MAP_ARRAY:
   case GL_TEXTURE_CUBE_MAP:
      surftype = BRW_SURFACE_2D;
      is_array = true;
      depth *= 6;
d270 2
a271 26
      surftype = translate_tex_target(gl_target);
      is_array = _mesa_tex_target_is_array(gl_target);
      break;
   }

   if (layered) {
      min_array_element = 0;
   } else if (irb->mt->num_samples > 1) {
      min_array_element = irb->mt_layer / irb->mt->num_samples;
   } else {
      min_array_element = irb->mt_layer;
   }

   surf[0] = surftype << BRW_SURFACE_TYPE_SHIFT |
             format << BRW_SURFACE_FORMAT_SHIFT |
             (irb->mt->array_spacing_lod0 ? GEN7_SURFACE_ARYSPC_LOD0
                                          : GEN7_SURFACE_ARYSPC_FULL) |
             gen7_surface_tiling_mode(region->tiling);

   if (irb->mt->align_h == 4)
      surf[0] |= GEN7_SURFACE_VALIGN_4;
   if (irb->mt->align_w == 8)
      surf[0] |= GEN7_SURFACE_HALIGN_8;

   if (is_array) {
      surf[0] |= GEN7_SURFACE_IS_ARRAY;
d274 4
a277 1
   surf[1] = region->bo->offset;
d280 21
d302 18
a319 2
   surf[5] = SET_FIELD(mocs, GEN7_SURFACE_MOCS) |
             (irb->mt_level - irb->mt->first_level);
d321 4
a324 2
   surf[2] = SET_FIELD(irb->mt->logical_width0 - 1, GEN7_SURFACE_WIDTH) |
             SET_FIELD(irb->mt->logical_height0 - 1, GEN7_SURFACE_HEIGHT);
d326 10
a335 2
   surf[3] = ((depth - 1) << BRW_SURFACE_DEPTH_SHIFT) |
             (region->pitch - 1);
d337 6
a342 7
   surf[4] = gen7_surface_msaa_bits(irb->mt->num_samples, irb->mt->msaa_layout) |
             min_array_element << GEN7_SURFACE_MIN_ARRAY_ELEMENT_SHIFT |
             (depth - 1) << GEN7_SURFACE_RENDER_TARGET_VIEW_EXTENT_SHIFT;

   if (irb->mt->mcs_mt) {
      gen7_set_surface_mcs_info(brw, surf, brw->wm.surf_offset[unit],
                                irb->mt->mcs_mt, true /* is RT */);
d344 1
d346 9
a354 1
   surf[7] = irb->mt->fast_clear_color_value;
d356 13
a368 5
   if (brw->is_haswell) {
      surf[7] |= (SET_FIELD(HSW_SCS_RED,   GEN7_SURFACE_SCS_R) |
                  SET_FIELD(HSW_SCS_GREEN, GEN7_SURFACE_SCS_G) |
                  SET_FIELD(HSW_SCS_BLUE,  GEN7_SURFACE_SCS_B) |
                  SET_FIELD(HSW_SCS_ALPHA, GEN7_SURFACE_SCS_A));
d371 12
a382 6
   drm_intel_bo_emit_reloc(brw->batch.bo,
			   brw->wm.surf_offset[unit] + 4,
			   region->bo,
			   surf[1] - region->bo->offset,
			   I915_GEM_DOMAIN_RENDER,
			   I915_GEM_DOMAIN_RENDER);
d384 1
a384 1
   gen7_check_surface_setup(surf, true /* is_render_target */);
d387 11
a397 9
void
gen7_init_vtable_surface_functions(struct brw_context *brw)
{
   brw->vtbl.update_texture_surface = gen7_update_texture_surface;
   brw->vtbl.update_renderbuffer_surface = gen7_update_renderbuffer_surface;
   brw->vtbl.update_null_renderbuffer_surface =
      gen7_update_null_renderbuffer_surface;
   brw->vtbl.create_constant_surface = gen7_create_constant_surface;
}
@


1.1.1.2
log
@Import Mesa 10.2.3
@
text
@d44 2
a45 2
unsigned
brw_swizzle_to_scs(GLenum swizzle, bool need_green_to_blue)
d51 1
a51 1
      return need_green_to_blue ? HSW_SCS_BLUE : HSW_SCS_GREEN;
d85 6
a90 4
   assert(num_samples <= 8);

   /* The SURFACE_MULTISAMPLECOUNT_X enums are simply log2(num_samples) << 3. */
   ss4 |= (ffs(MAX2(num_samples, 1)) - 1) << 3;
d112 1
a112 1
   assert(mcs_mt->tiling == I915_TILING_Y);
d117 1
a117 1
   unsigned pitch_tiles = mcs_mt->pitch / 128;
d125 1
a125 1
   assert ((mcs_mt->bo->offset64 & 0xfff) == 0);
d129 1
a129 1
             mcs_mt->bo->offset64;
d133 1
a133 1
                           mcs_mt->bo,
d227 1
d229 4
a232 9
gen7_emit_buffer_surface_state(struct brw_context *brw,
                               uint32_t *out_offset,
                               drm_intel_bo *bo,
                               unsigned buffer_offset,
                               unsigned surface_format,
                               unsigned buffer_size,
                               unsigned pitch,
                               unsigned mocs,
                               bool rw)
d234 7
d242 1
a242 1
                                    8 * 4, 32, out_offset);
d245 6
a253 5
   surf[1] = (bo ? bo->offset64 : 0) + buffer_offset; /* reloc */
   surf[2] = SET_FIELD((buffer_size - 1) & 0x7f, GEN7_SURFACE_WIDTH) |
             SET_FIELD(((buffer_size - 1) >> 7) & 0x3fff, GEN7_SURFACE_HEIGHT);
   surf[3] = SET_FIELD(((buffer_size - 1) >> 21) & 0x3f, BRW_SURFACE_DEPTH) |
             (pitch - 1);
d255 2
a256 1
   surf[5] = SET_FIELD(mocs, GEN7_SURFACE_MOCS);
d258 13
a270 12
   if (brw->is_haswell) {
      surf[7] |= (SET_FIELD(HSW_SCS_RED,   GEN7_SURFACE_SCS_R) |
                  SET_FIELD(HSW_SCS_GREEN, GEN7_SURFACE_SCS_G) |
                  SET_FIELD(HSW_SCS_BLUE,  GEN7_SURFACE_SCS_B) |
                  SET_FIELD(HSW_SCS_ALPHA, GEN7_SURFACE_SCS_A));
   }

   /* Emit relocation to surface contents */
   if (bo) {
      drm_intel_bo_emit_reloc(brw->batch.bo, *out_offset + 4,
                              bo, buffer_offset, I915_GEM_DOMAIN_SAMPLER,
                              (rw ? I915_GEM_DOMAIN_SAMPLER : 0));
d279 2
a280 2
                            uint32_t *surf_offset,
                            bool for_gather)
d288 2
d292 1
a292 1
      brw_update_buffer_texture_surface(ctx, unit, surf_offset);
d297 1
a297 1
                                    8 * 4, 32, surf_offset);
d301 2
a302 1
                                              intelObj->_Format,
a304 3
   if (for_gather && tex_format == BRW_SURFACEFORMAT_R32G32_FLOAT)
      tex_format = BRW_SURFACEFORMAT_R32G32_FLOAT_LD;

d307 2
a308 5
             gen7_surface_tiling_mode(mt->tiling);

   /* mask of faces present in cube map; for other surfaces MBZ. */
   if (tObj->Target == GL_TEXTURE_CUBE_MAP || tObj->Target == GL_TEXTURE_CUBE_MAP_ARRAY)
      surf[0] |= BRW_SURFACE_CUBEFACE_ENABLES;
a317 6
   /* if this is a view with restricted NumLayers, then
    * our effective depth is not just the miptree depth.
    */
   uint32_t effective_depth = (tObj->Immutable && tObj->Target != GL_TEXTURE_3D)
                              ? tObj->NumLayers : mt->logical_depth0;

d321 3
a323 1
   surf[1] = mt->bo->offset64 + mt->offset; /* reloc */
d327 2
d330 1
a330 2
   surf[3] = SET_FIELD(effective_depth - 1, BRW_SURFACE_DEPTH) |
             (mt->pitch - 1);
d332 7
a338 7
   surf[4] = gen7_surface_msaa_bits(mt->num_samples, mt->msaa_layout) |
             SET_FIELD(tObj->MinLayer, GEN7_SURFACE_MIN_ARRAY_ELEMENT) |
             SET_FIELD((effective_depth - 1),
                       GEN7_SURFACE_RENDER_TARGET_VIEW_EXTENT);

   surf[5] = (SET_FIELD(GEN7_MOCS_L3, GEN7_SURFACE_MOCS) |
              SET_FIELD(tObj->MinLevel + tObj->BaseLevel - mt->first_level, GEN7_SURFACE_MIN_LOD) |
a341 2
   surf[7] = mt->fast_clear_color_value;

d354 43
a396 1
      const bool need_scs_green_to_blue = for_gather && tex_format == BRW_SURFACEFORMAT_R32G32_FLOAT_LD;
d398 5
a402 6
      surf[7] |=
         SET_FIELD(brw_swizzle_to_scs(GET_SWZ(swizzle, 0), need_scs_green_to_blue), GEN7_SURFACE_SCS_R) |
         SET_FIELD(brw_swizzle_to_scs(GET_SWZ(swizzle, 1), need_scs_green_to_blue), GEN7_SURFACE_SCS_G) |
         SET_FIELD(brw_swizzle_to_scs(GET_SWZ(swizzle, 2), need_scs_green_to_blue), GEN7_SURFACE_SCS_B) |
         SET_FIELD(brw_swizzle_to_scs(GET_SWZ(swizzle, 3), need_scs_green_to_blue), GEN7_SURFACE_SCS_A);
   }
d404 5
a408 3
   if (mt->mcs_mt) {
      gen7_set_surface_mcs_info(brw, surf, *surf_offset,
                                mt->mcs_mt, false /* is RT */);
a410 1
   /* Emit relocation to surface contents */
d412 3
a414 4
                           *surf_offset + 4,
                           mt->bo,
                           surf[1] - mt->bo->offset64,
                           I915_GEM_DOMAIN_SAMPLER, 0);
d420 1
a420 1
 * Create a raw surface for untyped R/W access.
d422 31
a452 14
static void
gen7_create_raw_surface(struct brw_context *brw, drm_intel_bo *bo,
                        uint32_t offset, uint32_t size,
                        uint32_t *out_offset, bool rw)
{
   gen7_emit_buffer_surface_state(brw,
                                  out_offset,
                                  bo,
                                  offset,
                                  BRW_SURFACEFORMAT_RAW,
                                  size,
                                  1,
                                  0 /* mocs */,
                                  true /* rw */);
a476 2
   uint32_t surf_index =
      brw->wm.prog_data->binding_table.render_target_start + unit;
d478 2
a479 2
   uint32_t *surf = brw_state_batch(brw, AUB_TRACE_SURFACE_STATE, 8 * 4, 32,
                                    &brw->wm.base.surf_offset[surf_index]);
d509 1
a509 1
   struct intel_mipmap_tree *mt = irb->mt;
d512 1
a512 1
   mesa_format rb_format = _mesa_get_render_format(ctx, intel_rb_format(irb));
d515 3
a517 5
   int depth = MAX2(irb->layer_count, 1);
   const uint8_t mocs = GEN7_MOCS_L3;

   int min_array_element = irb->mt_layer / MAX2(mt->num_samples, 1);

d521 2
a522 5
   uint32_t surf_index =
      brw->wm.prog_data->binding_table.render_target_start + unit;

   uint32_t *surf = brw_state_batch(brw, AUB_TRACE_SURFACE_STATE, 8 * 4, 32,
                                    &brw->wm.base.surf_offset[surf_index]);
a543 3
   case GL_TEXTURE_3D:
      depth = MAX2(irb->mt->logical_depth0, 1);
      /* fallthrough */
d550 8
d562 1
a562 1
             gen7_surface_tiling_mode(mt->tiling);
d573 1
a573 1
   surf[1] = mt->bo->offset64;
d584 1
a584 1
             (mt->pitch - 1);
d591 1
a591 1
      gen7_set_surface_mcs_info(brw, surf, brw->wm.base.surf_offset[surf_index],
d605 3
a607 3
			   brw->wm.base.surf_offset[surf_index] + 4,
			   mt->bo,
			   surf[1] - mt->bo->offset64,
d621 1
a621 2
   brw->vtbl.create_raw_surface = gen7_create_raw_surface;
   brw->vtbl.emit_buffer_surface_state = gen7_emit_buffer_surface_state;
@


1.1.1.3
log
@Import Mesa 10.4.3
@
text
@d62 2
a63 1
   unreachable("Should not get here: invalid swizzle mode");
d319 1
a319 1
   if (mt->array_layout == ALL_SLICES_AT_EACH_LOD)
a396 8
/**
 * Creates a null renderbuffer surface.
 *
 * This is used when the shader doesn't write to any color output.  An FB
 * write to target 0 will still be emitted, because that's how the thread is
 * terminated (and computed depth is returned), so we need to have the
 * hardware discard the target 0 color output..
 */
d504 2
a505 2
             (irb->mt->array_layout == ALL_SLICES_AT_EACH_LOD ?
                 GEN7_SURFACE_ARYSPC_LOD0 : GEN7_SURFACE_ARYSPC_FULL) |
@


1.1.1.4
log
@Import Mesa 10.2.9
@
text
@d62 1
a62 2
   assert(!"Should not get here: invalid swizzle mode");
   return HSW_SCS_ZERO;
d318 1
a318 1
   if (mt->array_spacing_lod0)
d396 8
d511 2
a512 2
             (irb->mt->array_spacing_lod0 ? GEN7_SURFACE_ARYSPC_LOD0
                                          : GEN7_SURFACE_ARYSPC_FULL) |
@


