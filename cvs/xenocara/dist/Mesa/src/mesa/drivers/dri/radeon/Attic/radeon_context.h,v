head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.6
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.4
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.6
	v10_4_3:1.1.1.6
	v10_2_7:1.1.1.6
	OPENBSD_5_6:1.7.0.2
	OPENBSD_5_6_BASE:1.7
	v10_2_3:1.1.1.6
	OPENBSD_5_5:1.6.0.2
	OPENBSD_5_5_BASE:1.6
	v9_2_5:1.1.1.5
	v9_2_3:1.1.1.5
	v9_2_2:1.1.1.5
	v9_2_1:1.1.1.5
	v9_2_0:1.1.1.5
	OPENBSD_5_4:1.5.0.8
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.6
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.3.0.4
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.51;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2014.07.09.21.09.00;	author jsg;	state Exp;
branches;
next	1.6;
commitid	WPD6rgPryPkvXOr9;

1.6
date	2013.09.05.14.05.31;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.23.13.37.40;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.24;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.40;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.18;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.53.36;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.53.36;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.57.29;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.29.30;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.42;	author matthieu;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.09.05.13.16.04;	author jsg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.07.09.20.34.56;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************

Copyright 2000, 2001 ATI Technologies Inc., Ontario, Canada, and
                     VA Linux Systems Inc., Fremont, California.
Copyright (C) The Weather Channel, Inc.  2002.  All Rights Reserved.

The Weather Channel (TM) funded Tungsten Graphics to develop the
initial release of the Radeon 8500 driver under the XFree86 license.
This notice must be preserved.

All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice (including the
next paragraph) shall be included in all copies or substantial
portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

**************************************************************************/

/*
 * Authors:
 *   Gareth Hughes <gareth@@valinux.com>
 *   Keith Whitwell <keithw@@vmware.com>
 *   Kevin E. Martin <martin@@valinux.com>
 *   Nicolai Haehnle <prefect_@@gmx.net>
 */

#ifndef __RADEON_CONTEXT_H__
#define __RADEON_CONTEXT_H__

#include "tnl/t_vertex.h"
#include "dri_util.h"
#include "drm.h"
#include "radeon_drm.h"
#include "main/macros.h"
#include "main/mtypes.h"
#include "main/colormac.h"
#include "radeon_screen.h"

#include "radeon_common.h"


struct r100_context;
typedef struct r100_context r100ContextRec;
typedef struct r100_context *r100ContextPtr;



#define R100_TEX_ALL 0x7

/* used for both tcl_vtx and vc_frmt tex bits (they are identical) */
#define RADEON_ST_BIT(unit) \
(unit == 0 ? RADEON_CP_VC_FRMT_ST0 : (RADEON_CP_VC_FRMT_ST1 >> 2) << (2 * unit))

#define RADEON_Q_BIT(unit) \
(unit == 0 ? RADEON_CP_VC_FRMT_Q0 : (RADEON_CP_VC_FRMT_Q1 >> 2) << (2 * unit))

struct radeon_texture_env_state {
	radeonTexObjPtr texobj;
	GLenum format;
	GLenum envMode;
};

struct radeon_texture_state {
	struct radeon_texture_env_state unit[RADEON_MAX_TEXTURE_UNITS];
};

/* Trying to keep these relatively short as the variables are becoming
 * extravagently long.  Drop the driver name prefix off the front of
 * everything - I think we know which driver we're in by now, and keep the
 * prefix to 3 letters unless absolutely impossible.  
 */

#define CTX_CMD_0             0
#define CTX_PP_MISC           1
#define CTX_PP_FOG_COLOR      2
#define CTX_RE_SOLID_COLOR    3
#define CTX_RB3D_BLENDCNTL    4
#define CTX_RB3D_DEPTHOFFSET  5
#define CTX_RB3D_DEPTHPITCH   6
#define CTX_RB3D_ZSTENCILCNTL 7
#define CTX_CMD_1             8
#define CTX_PP_CNTL           9
#define CTX_RB3D_CNTL         10
#define CTX_RB3D_COLOROFFSET  11
#define CTX_CMD_2             12
#define CTX_RB3D_COLORPITCH   13
#define CTX_STATE_SIZE        14

#define SET_CMD_0               0
#define SET_SE_CNTL             1
#define SET_SE_COORDFMT         2
#define SET_CMD_1               3
#define SET_SE_CNTL_STATUS      4
#define SET_STATE_SIZE          5

#define LIN_CMD_0               0
#define LIN_RE_LINE_PATTERN     1
#define LIN_RE_LINE_STATE       2
#define LIN_CMD_1               3
#define LIN_SE_LINE_WIDTH       4
#define LIN_STATE_SIZE          5

#define MSK_CMD_0               0
#define MSK_RB3D_STENCILREFMASK 1
#define MSK_RB3D_ROPCNTL        2
#define MSK_RB3D_PLANEMASK      3
#define MSK_STATE_SIZE          4

#define VPT_CMD_0           0
#define VPT_SE_VPORT_XSCALE          1
#define VPT_SE_VPORT_XOFFSET         2
#define VPT_SE_VPORT_YSCALE          3
#define VPT_SE_VPORT_YOFFSET         4
#define VPT_SE_VPORT_ZSCALE          5
#define VPT_SE_VPORT_ZOFFSET         6
#define VPT_STATE_SIZE      7

#define MSC_CMD_0               0
#define MSC_RE_MISC             1
#define MSC_STATE_SIZE          2

#define TEX_CMD_0                   0
#define TEX_PP_TXFILTER             1
#define TEX_PP_TXFORMAT             2
#define TEX_PP_TXOFFSET             3
#define TEX_PP_TXCBLEND             4
#define TEX_PP_TXABLEND             5
#define TEX_PP_TFACTOR              6
#define TEX_CMD_1                   7
#define TEX_PP_BORDER_COLOR         8
#define TEX_STATE_SIZE              9

#define TXR_CMD_0                   0	/* rectangle textures */
#define TXR_PP_TEX_SIZE             1	/* 0x1d04, 0x1d0c for NPOT! */
#define TXR_PP_TEX_PITCH            2	/* 0x1d08, 0x1d10 for NPOT! */
#define TXR_STATE_SIZE              3

#define CUBE_CMD_0                  0
#define CUBE_PP_CUBIC_FACES         1
#define CUBE_CMD_1                  2
#define CUBE_PP_CUBIC_OFFSET_0      3
#define CUBE_PP_CUBIC_OFFSET_1      4
#define CUBE_PP_CUBIC_OFFSET_2      5
#define CUBE_PP_CUBIC_OFFSET_3      6
#define CUBE_PP_CUBIC_OFFSET_4      7
#define CUBE_STATE_SIZE             8

#define ZBS_CMD_0              0
#define ZBS_SE_ZBIAS_FACTOR             1
#define ZBS_SE_ZBIAS_CONSTANT           2
#define ZBS_STATE_SIZE         3

#define TCL_CMD_0                        0
#define TCL_OUTPUT_VTXFMT         1
#define TCL_OUTPUT_VTXSEL         2
#define TCL_MATRIX_SELECT_0       3
#define TCL_MATRIX_SELECT_1       4
#define TCL_UCP_VERT_BLEND_CTL    5
#define TCL_TEXTURE_PROC_CTL      6
#define TCL_LIGHT_MODEL_CTL       7
#define TCL_PER_LIGHT_CTL_0       8
#define TCL_PER_LIGHT_CTL_1       9
#define TCL_PER_LIGHT_CTL_2       10
#define TCL_PER_LIGHT_CTL_3       11
#define TCL_STATE_SIZE                   12

#define MTL_CMD_0            0
#define MTL_EMMISSIVE_RED    1
#define MTL_EMMISSIVE_GREEN  2
#define MTL_EMMISSIVE_BLUE   3
#define MTL_EMMISSIVE_ALPHA  4
#define MTL_AMBIENT_RED      5
#define MTL_AMBIENT_GREEN    6
#define MTL_AMBIENT_BLUE     7
#define MTL_AMBIENT_ALPHA    8
#define MTL_DIFFUSE_RED      9
#define MTL_DIFFUSE_GREEN    10
#define MTL_DIFFUSE_BLUE     11
#define MTL_DIFFUSE_ALPHA    12
#define MTL_SPECULAR_RED     13
#define MTL_SPECULAR_GREEN   14
#define MTL_SPECULAR_BLUE    15
#define MTL_SPECULAR_ALPHA   16
#define MTL_SHININESS        17
#define MTL_STATE_SIZE       18

#define VTX_CMD_0              0
#define VTX_SE_COORD_FMT       1
#define VTX_STATE_SIZE         2

#define MAT_CMD_0              0
#define MAT_ELT_0              1
#define MAT_STATE_SIZE         17

#define GRD_CMD_0                  0
#define GRD_VERT_GUARD_CLIP_ADJ    1
#define GRD_VERT_GUARD_DISCARD_ADJ 2
#define GRD_HORZ_GUARD_CLIP_ADJ    3
#define GRD_HORZ_GUARD_DISCARD_ADJ 4
#define GRD_STATE_SIZE             5

/* position changes frequently when lighting in modelpos - separate
 * out to new state item?  
 */
#define LIT_CMD_0                  0
#define LIT_AMBIENT_RED            1
#define LIT_AMBIENT_GREEN          2
#define LIT_AMBIENT_BLUE           3
#define LIT_AMBIENT_ALPHA          4
#define LIT_DIFFUSE_RED            5
#define LIT_DIFFUSE_GREEN          6
#define LIT_DIFFUSE_BLUE           7
#define LIT_DIFFUSE_ALPHA          8
#define LIT_SPECULAR_RED           9
#define LIT_SPECULAR_GREEN         10
#define LIT_SPECULAR_BLUE          11
#define LIT_SPECULAR_ALPHA         12
#define LIT_POSITION_X             13
#define LIT_POSITION_Y             14
#define LIT_POSITION_Z             15
#define LIT_POSITION_W             16
#define LIT_DIRECTION_X            17
#define LIT_DIRECTION_Y            18
#define LIT_DIRECTION_Z            19
#define LIT_DIRECTION_W            20
#define LIT_ATTEN_QUADRATIC        21
#define LIT_ATTEN_LINEAR           22
#define LIT_ATTEN_CONST            23
#define LIT_ATTEN_XXX              24
#define LIT_CMD_1                  25
#define LIT_SPOT_DCD               26
#define LIT_SPOT_EXPONENT          27
#define LIT_SPOT_CUTOFF            28
#define LIT_SPECULAR_THRESH        29
#define LIT_RANGE_CUTOFF           30	/* ? */
#define LIT_ATTEN_CONST_INV        31
#define LIT_STATE_SIZE             32

/* Fog
 */
#define FOG_CMD_0      0
#define FOG_R          1
#define FOG_C          2
#define FOG_D          3
#define FOG_PAD        4
#define FOG_STATE_SIZE 5

/* UCP
 */
#define UCP_CMD_0      0
#define UCP_X          1
#define UCP_Y          2
#define UCP_Z          3
#define UCP_W          4
#define UCP_STATE_SIZE 5

/* GLT - Global ambient
 */
#define GLT_CMD_0      0
#define GLT_RED        1
#define GLT_GREEN      2
#define GLT_BLUE       3
#define GLT_ALPHA      4
#define GLT_STATE_SIZE 5

/* EYE
 */
#define EYE_CMD_0          0
#define EYE_X              1
#define EYE_Y              2
#define EYE_Z              3
#define EYE_RESCALE_FACTOR 4
#define EYE_STATE_SIZE     5

#define SHN_CMD_0          0
#define SHN_SHININESS      1
#define SHN_STATE_SIZE     2

#define R100_QUERYOBJ_CMD_0  0
#define R100_QUERYOBJ_DATA_0 1
#define R100_QUERYOBJ_CMDSIZE  2

#define STP_CMD_0 0
#define STP_DATA_0 1
#define STP_CMD_1 2
#define STP_STATE_SIZE 35

struct r100_hw_state {
	/* Hardware state, stored as cmdbuf commands:  
	 *   -- Need to doublebuffer for
	 *           - eliding noop statechange loops? (except line stipple count)
	 */
	struct radeon_state_atom ctx;
	struct radeon_state_atom set;
	struct radeon_state_atom lin;
	struct radeon_state_atom msk;
	struct radeon_state_atom vpt;
	struct radeon_state_atom tcl;
	struct radeon_state_atom msc;
	struct radeon_state_atom tex[3];
	struct radeon_state_atom cube[3];
	struct radeon_state_atom zbs;
	struct radeon_state_atom mtl;
	struct radeon_state_atom mat[6];
	struct radeon_state_atom lit[8];	/* includes vec, scl commands */
	struct radeon_state_atom ucp[6];
	struct radeon_state_atom eye;	/* eye pos */
	struct radeon_state_atom grd;	/* guard band clipping */
	struct radeon_state_atom fog;
	struct radeon_state_atom glt;
	struct radeon_state_atom txr[3];	/* for NPOT */
	struct radeon_state_atom stp;
};

struct radeon_stipple_state {
	GLuint mask[32];
};

struct r100_state {
	struct radeon_stipple_state stipple;
	struct radeon_texture_state texture;
};

#define RADEON_CMD_BUF_SZ  (8*1024)
#define R200_ELT_BUF_SZ  (8*1024)
/* radeon_tcl.c
 */
struct r100_tcl_info {
	GLuint vertex_format;
	GLuint hw_primitive;

	/* Temporary for cases where incoming vertex data is incompatible
	 * with maos code.
	 */
	GLvector4f ObjClean;

	GLuint *Elts;

        int elt_cmd_offset;
	int elt_cmd_start;
        int elt_used;
};

/* radeon_swtcl.c
 */
struct r100_swtcl_info {
	GLuint vertex_format;

	GLubyte *verts;

	/* Fallback rasterization functions
	 */
	radeon_point_func draw_point;
	radeon_line_func draw_line;
	radeon_tri_func draw_tri;

   /**
    * Offset of the 4UB color data within a hardware (swtcl) vertex.
    */
	GLuint coloroffset;

   /**
    * Offset of the 3UB specular color data within a hardware (swtcl) vertex.
    */
	GLuint specoffset;

	GLboolean needproj;
};



/* A maximum total of 20 elements per vertex:  3 floats for position, 3
 * floats for normal, 4 floats for color, 4 bytes for secondary color,
 * 3 floats for each texture unit (9 floats total).
 * 
 * The position data is never actually stored here, so 3 elements could be
 * trimmed out of the buffer. This number is only valid for vtxfmt!
 */
#define RADEON_MAX_VERTEX_SIZE 20

struct r100_context {
        struct radeon_context radeon;

	/* Driver and hardware state management
	 */
	struct r100_hw_state hw;
	struct r100_state state;

	/* Vertex buffers
	 */
	struct radeon_ioctl ioctl;
	struct radeon_store store;

	/* TCL stuff
	 */
	GLmatrix TexGenMatrix[RADEON_MAX_TEXTURE_UNITS];
	GLboolean recheck_texgen[RADEON_MAX_TEXTURE_UNITS];
	GLboolean TexGenNeedNormals[RADEON_MAX_TEXTURE_UNITS];
	GLuint TexGenEnabled;
	GLuint NeedTexMatrix;
	GLuint TexMatColSwap;
	GLmatrix tmpmat[RADEON_MAX_TEXTURE_UNITS];

	/* radeon_tcl.c
	 */
	struct r100_tcl_info tcl;

	/* radeon_swtcl.c
	 */
	struct r100_swtcl_info swtcl;

	GLboolean using_hyperz;
	GLboolean texmicrotile;

	/* Performance counters
	 */
	GLuint boxes;		/* Draw performance boxes */
	GLuint hardwareWentIdle;
	GLuint c_clears;
	GLuint c_drawWaits;
	GLuint c_textureSwaps;
	GLuint c_textureBytes;
	GLuint c_vertexBuffers;

};


static inline r100ContextPtr
R100_CONTEXT(struct gl_context *ctx)
{
   return (r100ContextPtr) ctx;
}



#define RADEON_OLD_PACKETS 1

extern GLboolean r100CreateContext( gl_api api,
				    const struct gl_config *glVisual,
				    __DRIcontext *driContextPriv,
				    unsigned major_version,
				    unsigned minor_version,
				    uint32_t flags,
                                    bool notify_reset,
				    unsigned *error,
				    void *sharedContextPrivate);


#endif				/* __RADEON_CONTEXT_H__ */
@


1.7
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.6
log
@Merge Mesa 9.2.0
@
text
@d38 1
a38 1
 *   Keith Whitwell <keith@@tungstengraphics.com>
a418 1
	GLuint last_ReallyEnabled;
d460 1
@


1.5
log
@Merge Mesa 7.10.3
@
text
@a49 1
#include "texmem.h"
a61 2
#include "radeon_lock.h"

d445 6
a450 1
#define R100_CONTEXT(ctx)		((r100ContextPtr)(ctx->DriverCtx))
d458 4
@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d453 2
a454 1
extern GLboolean r100CreateContext( const __GLcontextModes *glVisual,
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@a50 1

a53 13

struct radeon_context;
typedef struct radeon_context radeonContextRec;
typedef struct radeon_context *radeonContextPtr;

/* This union is used to avoid warnings/miscompilation
   with float to uint32_t casts due to strict-aliasing */
typedef union {
	GLfloat f;
	uint32_t ui32;
} float_ui32_type;

#include "radeon_lock.h"
a54 1
#include "main/mm.h"
d56 1
a56 1
#include "math/m_vector.h"
a57 15
#define TEX_0   0x1
#define TEX_1   0x2
#define TEX_2   0x4
#define TEX_ALL 0x7

/* Rasterizing fallbacks */
/* See correponding strings in r200_swtcl.c */
#define RADEON_FALLBACK_TEXTURE		0x0001
#define RADEON_FALLBACK_DRAW_BUFFER	0x0002
#define RADEON_FALLBACK_STENCIL		0x0004
#define RADEON_FALLBACK_RENDER_MODE	0x0008
#define RADEON_FALLBACK_BLEND_EQ	0x0010
#define RADEON_FALLBACK_BLEND_FUNC	0x0020
#define RADEON_FALLBACK_DISABLE 	0x0040
#define RADEON_FALLBACK_BORDER_MODE	0x0080
d59 3
a61 3
/* The blit width for texture uploads
 */
#define BLIT_WIDTH_BYTES 1024
d63 1
a63 20
/* Use the templated vertex format:
 */
#define COLOR_IS_RGBA
#define TAG(x) radeon##x
#include "tnl_dd/t_dd_vertex.h"
#undef TAG

typedef void (*radeon_tri_func) (radeonContextPtr,
				 radeonVertex *,
				 radeonVertex *, radeonVertex *);

typedef void (*radeon_line_func) (radeonContextPtr,
				  radeonVertex *, radeonVertex *);

typedef void (*radeon_point_func) (radeonContextPtr, radeonVertex *);

struct radeon_colorbuffer_state {
	GLuint clear;
	int roundEnable;
};
a64 4
struct radeon_depthbuffer_state {
	GLuint clear;
	GLfloat scale;
};
a65 8
struct radeon_scissor_state {
	drm_clip_rect_t rect;
	GLboolean enabled;

	GLuint numClipRects;	/* Cliprects active */
	GLuint numAllocedClipRects;	/* Cliprects available */
	drm_clip_rect_t *pClipRects;
};
d67 1
a67 8
struct radeon_stencilbuffer_state {
	GLboolean hwBuffer;
	GLuint clear;		/* rb3d_stencilrefmask value */
};

struct radeon_stipple_state {
	GLuint mask[32];
};
a75 36
typedef struct radeon_tex_obj radeonTexObj, *radeonTexObjPtr;

/* Texture object in locally shared texture space.
 */
struct radeon_tex_obj {
	driTextureObject base;

	GLuint bufAddr;		/* Offset to start of locally
				   shared texture block */

	GLuint dirty_state;	/* Flags (1 per texunit) for
				   whether or not this texobj
				   has dirty hardware state
				   (pp_*) that needs to be
				   brought into the
				   texunit. */

	drm_radeon_tex_image_t image[6][RADEON_MAX_TEXTURE_LEVELS];
	/* Six, for the cube faces */

	GLboolean image_override; /* Image overridden by GLX_EXT_tfp */

	GLuint pp_txfilter;	/* hardware register values */
	GLuint pp_txformat;
	GLuint pp_txoffset;	/* Image location in texmem.
				   All cube faces follow. */
	GLuint pp_txsize;	/* npot only */
	GLuint pp_txpitch;	/* npot only */
	GLuint pp_border_color;
	GLuint pp_cubic_faces;	/* cube face 1,2,3,4 log2 sizes */

	GLboolean border_fallback;

	GLuint tile_bits;	/* hw texture tile bits used on this texture */
};

a85 11
struct radeon_state_atom {
	struct radeon_state_atom *next, *prev;
	const char *name;	/* for debug */
	int cmd_size;		/* size in bytes */
	GLuint is_tcl;
	int *cmd;		/* one or more cmd's */
	int *lastcmd;		/* one or more cmd's */
	GLboolean dirty;	/* dirty-mark in emit_state_list */
	 GLboolean(*check) (GLcontext *);	/* is this state active? */
};

d298 8
a305 3
struct radeon_hw_state {
	/* Head of the linked list of state atoms. */
	struct radeon_state_atom atomlist;
d307 1
d331 2
d334 2
a335 2
	int max_state_size;	/* Number of bytes necessary for a full state emit. */
	GLboolean is_dirty, all_dirty;
d338 1
a338 7
struct radeon_state {
	/* Derived state for internal purposes:
	 */
	struct radeon_colorbuffer_state color;
	struct radeon_depthbuffer_state depth;
	struct radeon_scissor_state scissor;
	struct radeon_stencilbuffer_state stencil;
a342 55
/* Need refcounting on dma buffers:
 */
struct radeon_dma_buffer {
	int refcount;		/* the number of retained regions in buf */
	drmBufPtr buf;
};

#define GET_START(rvb) (rmesa->radeonScreen->gart_buffer_offset +			\
			(rvb)->address - rmesa->dma.buf0_address +	\
			(rvb)->start)

/* A retained region, eg vertices for indexed vertices.
 */
struct radeon_dma_region {
	struct radeon_dma_buffer *buf;
	char *address;		/* == buf->address */
	int start, end, ptr;	/* offsets from start of buf */
	int aos_start;
	int aos_stride;
	int aos_size;
};

struct radeon_dma {
	/* Active dma region.  Allocations for vertices and retained
	 * regions come from here.  Also used for emitting random vertices,
	 * these may be flushed by calling flush_current();
	 */
	struct radeon_dma_region current;

	void (*flush) (radeonContextPtr);

	char *buf0_address;	/* start of buf[0], for index calcs */
	GLuint nr_released_bufs;	/* flush after so many buffers released */
};

struct radeon_dri_mirror {
	__DRIcontextPrivate *context;	/* DRI context */
	__DRIscreenPrivate *screen;	/* DRI screen */

   /**
    * DRI drawable bound to this context for drawing.
    */
	__DRIdrawablePrivate *drawable;

   /**
    * DRI drawable bound to this context for reading.
    */
	__DRIdrawablePrivate *readable;

	drm_context_t hwContext;
	drm_hw_lock_t *hwLock;
	int fd;
	int drmMinor;
};

d344 1
a344 9

struct radeon_store {
	GLuint statenr;
	GLuint primnr;
	char cmd_buf[RADEON_CMD_BUF_SZ];
	int cmd_used;
	int elts_start;
};

d347 1
a347 1
struct radeon_tcl_info {
a355 3
	struct radeon_dma_region *aos_components[8];
	GLuint nr_aos_components;

d358 3
a360 7
	struct radeon_dma_region indexed_verts;
	struct radeon_dma_region obj;
	struct radeon_dma_region rgba;
	struct radeon_dma_region spec;
	struct radeon_dma_region fog;
	struct radeon_dma_region tex[RADEON_MAX_TEXTURE_UNITS];
	struct radeon_dma_region norm;
d365 1
a365 3
struct radeon_swtcl_info {
	GLuint RenderIndex;
	GLuint vertex_size;
a367 3
	struct tnl_attr_map vertex_attrs[VERT_ATTRIB_MAX];
	GLuint vertex_attr_count;

a375 4
	GLuint hw_primitive;
	GLenum render_primitive;
	GLuint numverts;

a386 2

	struct radeon_dma_region indexed_verts;
a388 6
struct radeon_ioctl {
	GLuint vertex_offset;
	GLuint vertex_size;
};

#define RADEON_MAX_PRIMS 64
a389 5
struct radeon_prim {
	GLuint start;
	GLuint end;
	GLuint prim;
};
d400 2
a401 2
struct radeon_context {
	GLcontext *glCtx;	/* Mesa context */
d405 2
a406 17
	struct radeon_hw_state hw;
	struct radeon_state state;

	/* Texture object bookkeeping
	 */
	unsigned nr_heaps;
	driTexHeap *texture_heaps[RADEON_NR_TEX_HEAPS];
	driTextureObject swapped;
	int texture_depth;
	float initialMaxAnisotropy;

	/* Rasterization and vertex state:
	 */
	GLuint TclFallback;
	GLuint Fallback;
	GLuint NewGLState;
	 DECLARE_RENDERINPUTS(tnl_index_bitset);	/* index of bits for last tnl_install_attrs */
a410 1
	struct radeon_dma dma;
a411 25
	/* A full state emit as of the first state emit in the main store, in case
	 * the context is lost.
	 */
	struct radeon_store backup_store;

	/* Page flipping
	 */
	GLuint doPageFlip;

	/* Busy waiting
	 */
	GLuint do_usleeps;
	GLuint do_irqs;
	GLuint irqsEmitted;
	drm_radeon_irq_wait_t iw;

	/* Drawable, cliprect and scissor information
	 */
	GLuint numClipRects;	/* Cliprects for the draw buffer */
	drm_clip_rect_t *pClipRects;
	unsigned int lastStamp;
	GLboolean lost_context;
	GLboolean save_on_next_emit;
	radeonScreenPtr radeonScreen;	/* Screen private DRI data */
	drm_radeon_sarea_t *sarea;	/* Private SAREA data */
a423 8
	/* VBI
	 */
	int64_t swap_ust;
	int64_t swap_missed_ust;

	GLuint swap_count;
	GLuint swap_missed_count;

d426 1
a426 1
	struct radeon_tcl_info tcl;
d430 1
a430 9
	struct radeon_swtcl_info swtcl;

	/* Mirrors of some DRI state
	 */
	struct radeon_dri_mirror dri;

	/* Configuration cache
	 */
	driOptionCache optionCache;
d444 1
a446 1
#define RADEON_CONTEXT(ctx)		((radeonContextPtr)(ctx->DriverCtx))
d448 2
a449 13
static INLINE GLuint radeonPackColor(GLuint cpp,
                                     GLubyte r, GLubyte g,
                                     GLubyte b, GLubyte a)
{
	switch (cpp) {
	case 2:
		return PACK_COLOR_565(r, g, b);
	case 4:
		return PACK_COLOR_8888(a, r, g, b);
	default:
		return 0;
	}
}
d453 3
a455 16
extern void radeonDestroyContext(__DRIcontextPrivate * driContextPriv);
extern GLboolean radeonCreateContext(const __GLcontextModes * glVisual,
				     __DRIcontextPrivate * driContextPriv,
				     void *sharedContextPrivate);
extern void radeonSwapBuffers(__DRIdrawablePrivate * dPriv);
extern void radeonCopySubBuffer(__DRIdrawablePrivate * dPriv,
				int x, int y, int w, int h);
extern GLboolean radeonMakeCurrent(__DRIcontextPrivate * driContextPriv,
				   __DRIdrawablePrivate * driDrawPriv,
				   __DRIdrawablePrivate * driReadPriv);
extern GLboolean radeonUnbindContext(__DRIcontextPrivate * driContextPriv);

/* ================================================================
 * Debugging:
 */
#define DO_DEBUG		1
a456 19
#if DO_DEBUG
extern int RADEON_DEBUG;
#else
#define RADEON_DEBUG		0
#endif

#define DEBUG_TEXTURE	0x0001
#define DEBUG_STATE	0x0002
#define DEBUG_IOCTL	0x0004
#define DEBUG_PRIMS	0x0008
#define DEBUG_VERTS	0x0010
#define DEBUG_FALLBACKS	0x0020
#define DEBUG_VFMT	0x0040
#define DEBUG_CODEGEN	0x0080
#define DEBUG_VERBOSE	0x0100
#define DEBUG_DRI       0x0200
#define DEBUG_DMA       0x0400
#define DEBUG_SANITY    0x0800
#define DEBUG_SYNC      0x1000
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d52 3
a54 3
#include "macros.h"
#include "mtypes.h"
#include "colormac.h"
d69 1
a69 1
#include "mm.h"
@


1.1
log
@Initial revision
@
text
@a0 1
/* $XFree86: xc/lib/GL/mesa/src/drv/radeon/radeon_context.h,v 1.6 2002/12/16 16:18:58 dawes Exp $ */
d5 5
a36 1
 *   Kevin E. Martin <martin@@valinux.com>
d39 2
d62 4
a65 1
typedef union { GLfloat f; uint32_t ui32; } float_ui32_type;
d73 7
a79 2
/* Flags for software fallback cases */
/* See correponding strings in radeon_swtcl.c */
d100 1
a100 2
typedef void (*radeon_tri_func)( radeonContextPtr,
				 radeonVertex *,
d102 1
a102 1
				 radeonVertex * );
d104 2
a105 6
typedef void (*radeon_line_func)( radeonContextPtr,
				  radeonVertex *,
				  radeonVertex * );

typedef void (*radeon_point_func)( radeonContextPtr,
				   radeonVertex * );
d107 1
d110 2
a111 2
   GLuint clear;
   int roundEnable;
a113 1

d115 2
a116 2
   GLuint clear;
   GLfloat scale;
d120 2
a121 2
   drm_clip_rect_t rect;
   GLboolean enabled;
d123 3
a125 3
   GLuint numClipRects;			/* Cliprects active */
   GLuint numAllocedClipRects;		/* Cliprects available */
   drm_clip_rect_t *pClipRects;
d129 2
a130 2
   GLboolean hwBuffer;
   GLuint clear;			/* rb3d_stencilrefmask value */
d134 1
a134 1
   GLuint mask[32];
a143 5
#define TEX_0   0x1
#define TEX_1   0x2
#define TEX_2   0x4
#define TEX_ALL 0x7

d149 1
a149 1
   driTextureObject   base;
d151 2
a152 2
   GLuint bufAddr;			/* Offset to start of locally
					   shared texture block */
d154 20
a173 18
   GLuint dirty_state;		        /* Flags (1 per texunit) for
					   whether or not this texobj
					   has dirty hardware state
					   (pp_*) that needs to be
					   brought into the
					   texunit. */

   drm_radeon_tex_image_t image[6][RADEON_MAX_TEXTURE_LEVELS];
					/* Six, for the cube faces */

   GLuint pp_txfilter;		        /* hardware register values */
   GLuint pp_txformat;
   GLuint pp_txoffset;		        /* Image location in texmem.
					   All cube faces follow. */
   GLuint pp_txsize;		        /* npot only */
   GLuint pp_txpitch;		        /* npot only */
   GLuint pp_border_color;
   GLuint pp_cubic_faces;	        /* cube face 1,2,3,4 log2 sizes */
d175 1
a175 1
   GLboolean  border_fallback;
d177 1
a177 1
   GLuint tile_bits;			/* hw texture tile bits used on this texture */
a179 1

d181 3
a183 3
   radeonTexObjPtr texobj;
   GLenum format;
   GLenum envMode;
d187 1
a187 1
   struct radeon_texture_env_state unit[RADEON_MAX_TEXTURE_UNITS];
a189 1

d191 8
a198 8
   struct radeon_state_atom *next, *prev;
   const char *name;		         /* for debug */
   int cmd_size;		         /* size in bytes */
   GLuint is_tcl;
   int *cmd;			         /* one or more cmd's */
   int *lastcmd;			 /* one or more cmd's */
   GLboolean dirty;                      /* dirty-mark in emit_state_list */
   GLboolean (*check)( GLcontext * );    /* is this state active? */
a200 2


d267 3
a269 3
#define TXR_CMD_0                   0 /* rectangle textures */
#define TXR_PP_TEX_SIZE             1 /* 0x1d04, 0x1d0c for NPOT! */
#define TXR_PP_TEX_PITCH            2 /* 0x1d08, 0x1d10 for NPOT! */
d301 5
a305 5
#define MTL_CMD_0            0	
#define MTL_EMMISSIVE_RED    1	
#define MTL_EMMISSIVE_GREEN  2	
#define MTL_EMMISSIVE_BLUE   3	
#define MTL_EMMISSIVE_ALPHA  4	
d369 1
a369 1
#define LIT_RANGE_CUTOFF           30 /* ? */
a412 4




d414 2
a415 2
   /* Head of the linked list of state atoms. */
   struct radeon_state_atom atomlist;
d417 23
a439 23
   /* Hardware state, stored as cmdbuf commands:  
    *   -- Need to doublebuffer for
    *           - eliding noop statechange loops? (except line stipple count)
    */
   struct radeon_state_atom ctx;
   struct radeon_state_atom set;
   struct radeon_state_atom lin;
   struct radeon_state_atom msk;
   struct radeon_state_atom vpt;
   struct radeon_state_atom tcl;
   struct radeon_state_atom msc;
   struct radeon_state_atom tex[3];
   struct radeon_state_atom cube[3];
   struct radeon_state_atom zbs;
   struct radeon_state_atom mtl; 
   struct radeon_state_atom mat[6];
   struct radeon_state_atom lit[8]; /* includes vec, scl commands */
   struct radeon_state_atom ucp[6];
   struct radeon_state_atom eye; /* eye pos */
   struct radeon_state_atom grd; /* guard band clipping */
   struct radeon_state_atom fog; 
   struct radeon_state_atom glt; 
   struct radeon_state_atom txr[3]; /* for NPOT */
d441 2
a442 2
   int max_state_size;	/* Number of bytes necessary for a full state emit. */
   GLboolean is_dirty, all_dirty;
d446 8
a453 8
   /* Derived state for internal purposes:
    */
   struct radeon_colorbuffer_state color;
   struct radeon_depthbuffer_state depth;
   struct radeon_scissor_state scissor;
   struct radeon_stencilbuffer_state stencil;
   struct radeon_stipple_state stipple;
   struct radeon_texture_state texture;
a455 1

d459 2
a460 2
   int refcount;		/* the number of retained regions in buf */
   drmBufPtr buf;
d470 6
a475 6
   struct radeon_dma_buffer *buf;
   char *address;		/* == buf->address */
   int start, end, ptr;		/* offsets from start of buf */
   int aos_start;
   int aos_stride;
   int aos_size;
d478 6
d485 1
a485 8
struct radeon_dma {
   /* Active dma region.  Allocations for vertices and retained
    * regions come from here.  Also used for emitting random vertices,
    * these may be flushed by calling flush_current();
    */
   struct radeon_dma_region current;
   
   void (*flush)( radeonContextPtr );
d487 2
a488 2
   char *buf0_address;		/* start of buf[0], for index calcs */
   GLuint nr_released_bufs;	/* flush after so many buffers released */
d492 12
a503 3
   __DRIcontextPrivate	*context;	/* DRI context */
   __DRIscreenPrivate	*screen;	/* DRI screen */
   __DRIdrawablePrivate	*drawable;	/* DRI drawable bound to this ctx */
d505 4
a508 4
   drm_context_t hwContext;
   drm_hw_lock_t *hwLock;
   int fd;
   int drmMinor;
d511 1
a511 2

#define RADEON_CMD_BUF_SZ  (8*1024) 
d514 5
a518 5
   GLuint statenr;
   GLuint primnr;
   char cmd_buf[RADEON_CMD_BUF_SZ];
   int cmd_used;   
   int elts_start;
a520 1

d524 2
a525 13
   GLuint vertex_format;
   GLint last_offset;
   GLuint hw_primitive;

   /* Temporary for cases where incoming vertex data is incompatible
    * with maos code.
    */
   GLvector4f ObjClean;

   struct radeon_dma_region *aos_components[8];
   GLuint nr_aos_components;

   GLuint *Elts;
d527 17
a543 7
   struct radeon_dma_region indexed_verts;
   struct radeon_dma_region obj;
   struct radeon_dma_region rgba;
   struct radeon_dma_region spec;
   struct radeon_dma_region fog;
   struct radeon_dma_region tex[RADEON_MAX_TEXTURE_UNITS];
   struct radeon_dma_region norm;
a545 1

d549 18
a566 18
   GLuint RenderIndex;
   GLuint vertex_size;
   GLuint vertex_format;

   struct tnl_attr_map vertex_attrs[VERT_ATTRIB_MAX];
   GLuint vertex_attr_count;

   GLubyte *verts;

   /* Fallback rasterization functions
    */
   radeon_point_func draw_point;
   radeon_line_func draw_line;
   radeon_tri_func draw_tri;

   GLuint hw_primitive;
   GLenum render_primitive;
   GLuint numverts;
d571 1
a571 1
   GLuint coloroffset;
d576 1
a576 1
   GLuint specoffset;
d578 1
a578 1
   GLboolean needproj;
d580 1
a580 1
   struct radeon_dma_region indexed_verts;
a582 1

d584 2
a585 2
   GLuint vertex_offset;
   GLuint vertex_size;
a587 2


a589 71

/* Want to keep a cache of these around.  Each is parameterized by
 * only a single value which has only a small range.  Only expect a
 * few, so just rescan the list each time?
 */
struct dynfn {
   struct dynfn *next, *prev;
   int key;
   char *code;
};

struct dfn_lists {
   struct dynfn Vertex2f;
   struct dynfn Vertex2fv;
   struct dynfn Vertex3f;
   struct dynfn Vertex3fv;
   struct dynfn Color4ub;
   struct dynfn Color4ubv;
   struct dynfn Color3ub;
   struct dynfn Color3ubv;
   struct dynfn Color4f;
   struct dynfn Color4fv;
   struct dynfn Color3f;
   struct dynfn Color3fv;
   struct dynfn SecondaryColor3ubEXT;
   struct dynfn SecondaryColor3ubvEXT;
   struct dynfn SecondaryColor3fEXT;
   struct dynfn SecondaryColor3fvEXT;
   struct dynfn Normal3f;
   struct dynfn Normal3fv;
   struct dynfn TexCoord2f;
   struct dynfn TexCoord2fv;
   struct dynfn TexCoord1f;
   struct dynfn TexCoord1fv;
   struct dynfn MultiTexCoord2fARB;
   struct dynfn MultiTexCoord2fvARB;
   struct dynfn MultiTexCoord1fARB;
   struct dynfn MultiTexCoord1fvARB;
};

struct dfn_generators {
   struct dynfn *(*Vertex2f)( GLcontext *, int );
   struct dynfn *(*Vertex2fv)( GLcontext *, int );
   struct dynfn *(*Vertex3f)( GLcontext *, int );
   struct dynfn *(*Vertex3fv)( GLcontext *, int );
   struct dynfn *(*Color4ub)( GLcontext *, int );
   struct dynfn *(*Color4ubv)( GLcontext *, int );
   struct dynfn *(*Color3ub)( GLcontext *, int );
   struct dynfn *(*Color3ubv)( GLcontext *, int );
   struct dynfn *(*Color4f)( GLcontext *, int );
   struct dynfn *(*Color4fv)( GLcontext *, int );
   struct dynfn *(*Color3f)( GLcontext *, int );
   struct dynfn *(*Color3fv)( GLcontext *, int );
   struct dynfn *(*SecondaryColor3ubEXT)( GLcontext *, int );
   struct dynfn *(*SecondaryColor3ubvEXT)( GLcontext *, int );
   struct dynfn *(*SecondaryColor3fEXT)( GLcontext *, int );
   struct dynfn *(*SecondaryColor3fvEXT)( GLcontext *, int );
   struct dynfn *(*Normal3f)( GLcontext *, int );
   struct dynfn *(*Normal3fv)( GLcontext *, int );
   struct dynfn *(*TexCoord2f)( GLcontext *, int );
   struct dynfn *(*TexCoord2fv)( GLcontext *, int );
   struct dynfn *(*TexCoord1f)( GLcontext *, int );
   struct dynfn *(*TexCoord1fv)( GLcontext *, int );
   struct dynfn *(*MultiTexCoord2fARB)( GLcontext *, int );
   struct dynfn *(*MultiTexCoord2fvARB)( GLcontext *, int );
   struct dynfn *(*MultiTexCoord1fARB)( GLcontext *, int );
   struct dynfn *(*MultiTexCoord1fvARB)( GLcontext *, int );
};



d591 3
a593 3
   GLuint start;
   GLuint end;
   GLuint prim;
a604 38
struct radeon_vbinfo {
   GLint counter, initial_counter;
   GLint *dmaptr;
   void (*notify)( void );
   GLint vertex_size;

   union { float f; int i; radeon_color_t color; } vertex[RADEON_MAX_VERTEX_SIZE];

   GLfloat *normalptr;
   GLfloat *floatcolorptr;
   radeon_color_t *colorptr;
   GLfloat *floatspecptr;
   radeon_color_t *specptr;
   GLfloat *texcoordptr[4];	/* 3 (TMU) + 1 for radeon_vtxfmt_c.c when GL_TEXTURE3 */

   GLenum *prim;		/* &ctx->Driver.CurrentExecPrimitive */
   GLuint primflags;
   GLboolean enabled;		/* *_NO_VTXFMT / *_NO_TCL env vars */
   GLboolean installed;
   GLboolean fell_back;
   GLboolean recheck;
   GLint nrverts;
   GLuint vertex_format;

   GLuint installed_vertex_format;
   GLuint installed_color_3f_sz;

   struct radeon_prim primlist[RADEON_MAX_PRIMS];
   int nrprims;

   struct dfn_lists dfn_cache;
   struct dfn_generators codegen;
   GLvertexformat vtxfmt;
};




d606 1
a606 79
   GLcontext *glCtx;			/* Mesa context */

   /* Driver and hardware state management
    */
   struct radeon_hw_state hw;
   struct radeon_state state;

   /* Texture object bookkeeping
    */
   unsigned              nr_heaps;
   driTexHeap          * texture_heaps[ RADEON_NR_TEX_HEAPS ];
   driTextureObject      swapped;
   int                   texture_depth;
   float                 initialMaxAnisotropy;

   /* Rasterization and vertex state:
    */
   GLuint TclFallback;
   GLuint Fallback;
   GLuint NewGLState;
   DECLARE_RENDERINPUTS(tnl_index_bitset);	/* index of bits for last tnl_install_attrs */

   /* Vertex buffers
    */
   struct radeon_ioctl ioctl;
   struct radeon_dma dma;
   struct radeon_store store;
   /* A full state emit as of the first state emit in the main store, in case
    * the context is lost.
    */
   struct radeon_store backup_store;

   /* Page flipping
    */
   GLuint doPageFlip;

   /* Busy waiting
    */
   GLuint do_usleeps;
   GLuint do_irqs;
   GLuint irqsEmitted;
   drm_radeon_irq_wait_t iw;

   /* Drawable, cliprect and scissor information
    */
   GLuint numClipRects;			/* Cliprects for the draw buffer */
   drm_clip_rect_t *pClipRects;
   unsigned int lastStamp;
   GLboolean lost_context;
   GLboolean save_on_next_emit;
   radeonScreenPtr radeonScreen;	/* Screen private DRI data */
   drm_radeon_sarea_t *sarea;		/* Private SAREA data */

   /* TCL stuff
    */
   GLmatrix TexGenMatrix[RADEON_MAX_TEXTURE_UNITS];
   GLboolean recheck_texgen[RADEON_MAX_TEXTURE_UNITS];
   GLboolean TexGenNeedNormals[RADEON_MAX_TEXTURE_UNITS];
   GLuint TexGenEnabled;
   GLuint NeedTexMatrix;
   GLuint TexMatColSwap;
   GLmatrix tmpmat[RADEON_MAX_TEXTURE_UNITS];
   GLuint last_ReallyEnabled;

   /* VBI
    */
   GLuint vbl_seq;
   GLuint vblank_flags;

   int64_t swap_ust;
   int64_t swap_missed_ust;

   GLuint swap_count;
   GLuint swap_missed_count;


   /* radeon_tcl.c
    */
   struct radeon_tcl_info tcl;
d608 98
a705 28
   /* radeon_swtcl.c
    */
   struct radeon_swtcl_info swtcl;

   /* radeon_vtxfmt.c
    */
   struct radeon_vbinfo vb;

   /* Mirrors of some DRI state
    */
   struct radeon_dri_mirror dri;

   /* Configuration cache
    */
   driOptionCache optionCache;

   GLboolean using_hyperz;
   GLboolean texmicrotile;

   /* Performance counters
    */
   GLuint boxes;			/* Draw performance boxes */
   GLuint hardwareWentIdle;
   GLuint c_clears;
   GLuint c_drawWaits;
   GLuint c_textureSwaps;
   GLuint c_textureBytes;
   GLuint c_vertexBuffers;
d710 3
a712 4

static __inline GLuint radeonPackColor( GLuint cpp,
					GLubyte r, GLubyte g,
					GLubyte b, GLubyte a )
d714 8
a721 8
   switch ( cpp ) {
   case 2:
      return PACK_COLOR_565( r, g, b );
   case 4:
      return PACK_COLOR_8888( a, r, g, b );
   default:
      return 0;
   }
d726 3
a728 4

extern void radeonDestroyContext( __DRIcontextPrivate *driContextPriv );
extern GLboolean radeonCreateContext(const __GLcontextModes *glVisual,
				     __DRIcontextPrivate *driContextPriv,
d730 1
a730 1
extern void radeonSwapBuffers( __DRIdrawablePrivate *dPriv );
d733 4
a736 4
extern GLboolean radeonMakeCurrent( __DRIcontextPrivate *driContextPriv,
				    __DRIdrawablePrivate *driDrawPriv,
				    __DRIdrawablePrivate *driReadPriv );
extern GLboolean radeonUnbindContext( __DRIcontextPrivate *driContextPriv );
d749 13
a761 13
#define DEBUG_TEXTURE	0x001
#define DEBUG_STATE	0x002
#define DEBUG_IOCTL	0x004
#define DEBUG_PRIMS	0x008
#define DEBUG_VERTS	0x010
#define DEBUG_FALLBACKS	0x020
#define DEBUG_VFMT	0x040
#define DEBUG_CODEGEN	0x080
#define DEBUG_VERBOSE	0x100
#define DEBUG_DRI       0x200
#define DEBUG_DMA       0x400
#define DEBUG_SANITY    0x800
#define DEBUG_SYNC     0x1000
d763 1
a763 1
#endif /* __RADEON_CONTEXT_H__ */
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d499 1
a499 10

   /**
    * DRI drawable bound to this context for drawing.
    */
   __DRIdrawablePrivate	*drawable;	

   /**
    * DRI drawable bound to this context for reading.
    */
   __DRIdrawablePrivate	*readable;
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d1 1
a5 5
Copyright (C) The Weather Channel, Inc.  2002.  All Rights Reserved.

The Weather Channel (TM) funded Tungsten Graphics to develop the
initial release of the Radeon 8500 driver under the XFree86 license.
This notice must be preserved.
d33 1
a35 2
 *   Kevin E. Martin <martin@@valinux.com>
 *   Nicolai Haehnle <prefect_@@gmx.net>
d57 1
a57 4
typedef union {
	GLfloat f;
	uint32_t ui32;
} float_ui32_type;
d65 2
a66 7
#define TEX_0   0x1
#define TEX_1   0x2
#define TEX_2   0x4
#define TEX_ALL 0x7

/* Rasterizing fallbacks */
/* See correponding strings in r200_swtcl.c */
d87 2
a88 1
typedef void (*radeon_tri_func) (radeonContextPtr,
d90 1
a90 1
				 radeonVertex *, radeonVertex *);
d92 6
a97 2
typedef void (*radeon_line_func) (radeonContextPtr,
				  radeonVertex *, radeonVertex *);
a98 1
typedef void (*radeon_point_func) (radeonContextPtr, radeonVertex *);
d101 2
a102 2
	GLuint clear;
	int roundEnable;
d105 1
d107 2
a108 2
	GLuint clear;
	GLfloat scale;
d112 2
a113 2
	drm_clip_rect_t rect;
	GLboolean enabled;
d115 3
a117 3
	GLuint numClipRects;	/* Cliprects active */
	GLuint numAllocedClipRects;	/* Cliprects available */
	drm_clip_rect_t *pClipRects;
d121 2
a122 2
	GLboolean hwBuffer;
	GLuint clear;		/* rb3d_stencilrefmask value */
d126 1
a126 1
	GLuint mask[32];
d136 5
d146 1
a146 1
	driTextureObject base;
d148 2
a149 2
	GLuint bufAddr;		/* Offset to start of locally
				   shared texture block */
d151 18
a168 18
	GLuint dirty_state;	/* Flags (1 per texunit) for
				   whether or not this texobj
				   has dirty hardware state
				   (pp_*) that needs to be
				   brought into the
				   texunit. */

	drm_radeon_tex_image_t image[6][RADEON_MAX_TEXTURE_LEVELS];
	/* Six, for the cube faces */

	GLuint pp_txfilter;	/* hardware register values */
	GLuint pp_txformat;
	GLuint pp_txoffset;	/* Image location in texmem.
				   All cube faces follow. */
	GLuint pp_txsize;	/* npot only */
	GLuint pp_txpitch;	/* npot only */
	GLuint pp_border_color;
	GLuint pp_cubic_faces;	/* cube face 1,2,3,4 log2 sizes */
d170 1
a170 1
	GLboolean border_fallback;
d172 1
a172 1
	GLuint tile_bits;	/* hw texture tile bits used on this texture */
d175 1
d177 3
a179 3
	radeonTexObjPtr texobj;
	GLenum format;
	GLenum envMode;
d183 1
a183 1
	struct radeon_texture_env_state unit[RADEON_MAX_TEXTURE_UNITS];
d186 1
d188 8
a195 8
	struct radeon_state_atom *next, *prev;
	const char *name;	/* for debug */
	int cmd_size;		/* size in bytes */
	GLuint is_tcl;
	int *cmd;		/* one or more cmd's */
	int *lastcmd;		/* one or more cmd's */
	GLboolean dirty;	/* dirty-mark in emit_state_list */
	 GLboolean(*check) (GLcontext *);	/* is this state active? */
d198 2
d266 3
a268 3
#define TXR_CMD_0                   0	/* rectangle textures */
#define TXR_PP_TEX_SIZE             1	/* 0x1d04, 0x1d0c for NPOT! */
#define TXR_PP_TEX_PITCH            2	/* 0x1d08, 0x1d10 for NPOT! */
d300 5
a304 5
#define MTL_CMD_0            0
#define MTL_EMMISSIVE_RED    1
#define MTL_EMMISSIVE_GREEN  2
#define MTL_EMMISSIVE_BLUE   3
#define MTL_EMMISSIVE_ALPHA  4
d368 1
a368 1
#define LIT_RANGE_CUTOFF           30	/* ? */
d412 4
d417 2
a418 2
	/* Head of the linked list of state atoms. */
	struct radeon_state_atom atomlist;
d420 23
a442 23
	/* Hardware state, stored as cmdbuf commands:  
	 *   -- Need to doublebuffer for
	 *           - eliding noop statechange loops? (except line stipple count)
	 */
	struct radeon_state_atom ctx;
	struct radeon_state_atom set;
	struct radeon_state_atom lin;
	struct radeon_state_atom msk;
	struct radeon_state_atom vpt;
	struct radeon_state_atom tcl;
	struct radeon_state_atom msc;
	struct radeon_state_atom tex[3];
	struct radeon_state_atom cube[3];
	struct radeon_state_atom zbs;
	struct radeon_state_atom mtl;
	struct radeon_state_atom mat[6];
	struct radeon_state_atom lit[8];	/* includes vec, scl commands */
	struct radeon_state_atom ucp[6];
	struct radeon_state_atom eye;	/* eye pos */
	struct radeon_state_atom grd;	/* guard band clipping */
	struct radeon_state_atom fog;
	struct radeon_state_atom glt;
	struct radeon_state_atom txr[3];	/* for NPOT */
d444 2
a445 2
	int max_state_size;	/* Number of bytes necessary for a full state emit. */
	GLboolean is_dirty, all_dirty;
d449 8
a456 8
	/* Derived state for internal purposes:
	 */
	struct radeon_colorbuffer_state color;
	struct radeon_depthbuffer_state depth;
	struct radeon_scissor_state scissor;
	struct radeon_stencilbuffer_state stencil;
	struct radeon_stipple_state stipple;
	struct radeon_texture_state texture;
d459 1
d463 2
a464 2
	int refcount;		/* the number of retained regions in buf */
	drmBufPtr buf;
d474 6
a479 6
	struct radeon_dma_buffer *buf;
	char *address;		/* == buf->address */
	int start, end, ptr;	/* offsets from start of buf */
	int aos_start;
	int aos_stride;
	int aos_size;
d482 1
d484 7
a490 5
	/* Active dma region.  Allocations for vertices and retained
	 * regions come from here.  Also used for emitting random vertices,
	 * these may be flushed by calling flush_current();
	 */
	struct radeon_dma_region current;
d492 2
a493 4
	void (*flush) (radeonContextPtr);

	char *buf0_address;	/* start of buf[0], for index calcs */
	GLuint nr_released_bufs;	/* flush after so many buffers released */
d497 2
a498 2
	__DRIcontextPrivate *context;	/* DRI context */
	__DRIscreenPrivate *screen;	/* DRI screen */
d503 1
a503 1
	__DRIdrawablePrivate *drawable;
d508 1
a508 1
	__DRIdrawablePrivate *readable;
d510 4
a513 4
	drm_context_t hwContext;
	drm_hw_lock_t *hwLock;
	int fd;
	int drmMinor;
d516 2
a517 1
#define RADEON_CMD_BUF_SZ  (8*1024)
d520 5
a524 5
	GLuint statenr;
	GLuint primnr;
	char cmd_buf[RADEON_CMD_BUF_SZ];
	int cmd_used;
	int elts_start;
d527 1
d531 8
a538 2
	GLuint vertex_format;
	GLuint hw_primitive;
d540 12
a551 17
	/* Temporary for cases where incoming vertex data is incompatible
	 * with maos code.
	 */
	GLvector4f ObjClean;

	struct radeon_dma_region *aos_components[8];
	GLuint nr_aos_components;

	GLuint *Elts;

	struct radeon_dma_region indexed_verts;
	struct radeon_dma_region obj;
	struct radeon_dma_region rgba;
	struct radeon_dma_region spec;
	struct radeon_dma_region fog;
	struct radeon_dma_region tex[RADEON_MAX_TEXTURE_UNITS];
	struct radeon_dma_region norm;
d554 1
d558 18
a575 18
	GLuint RenderIndex;
	GLuint vertex_size;
	GLuint vertex_format;

	struct tnl_attr_map vertex_attrs[VERT_ATTRIB_MAX];
	GLuint vertex_attr_count;

	GLubyte *verts;

	/* Fallback rasterization functions
	 */
	radeon_point_func draw_point;
	radeon_line_func draw_line;
	radeon_tri_func draw_tri;

	GLuint hw_primitive;
	GLenum render_primitive;
	GLuint numverts;
d580 1
a580 1
	GLuint coloroffset;
d585 1
a585 1
	GLuint specoffset;
d587 1
a587 1
	GLboolean needproj;
d589 1
a589 1
	struct radeon_dma_region indexed_verts;
d592 1
d594 2
a595 2
	GLuint vertex_offset;
	GLuint vertex_size;
d598 2
d602 71
d674 3
a676 3
	GLuint start;
	GLuint end;
	GLuint prim;
d688 38
d727 1
a727 1
	GLcontext *glCtx;	/* Mesa context */
d729 106
a834 101
	/* Driver and hardware state management
	 */
	struct radeon_hw_state hw;
	struct radeon_state state;

	/* Texture object bookkeeping
	 */
	unsigned nr_heaps;
	driTexHeap *texture_heaps[RADEON_NR_TEX_HEAPS];
	driTextureObject swapped;
	int texture_depth;
	float initialMaxAnisotropy;

	/* Rasterization and vertex state:
	 */
	GLuint TclFallback;
	GLuint Fallback;
	GLuint NewGLState;
	 DECLARE_RENDERINPUTS(tnl_index_bitset);	/* index of bits for last tnl_install_attrs */

	/* Vertex buffers
	 */
	struct radeon_ioctl ioctl;
	struct radeon_dma dma;
	struct radeon_store store;
	/* A full state emit as of the first state emit in the main store, in case
	 * the context is lost.
	 */
	struct radeon_store backup_store;

	/* Page flipping
	 */
	GLuint doPageFlip;

	/* Busy waiting
	 */
	GLuint do_usleeps;
	GLuint do_irqs;
	GLuint irqsEmitted;
	drm_radeon_irq_wait_t iw;

	/* Drawable, cliprect and scissor information
	 */
	GLuint numClipRects;	/* Cliprects for the draw buffer */
	drm_clip_rect_t *pClipRects;
	unsigned int lastStamp;
	GLboolean lost_context;
	GLboolean save_on_next_emit;
	radeonScreenPtr radeonScreen;	/* Screen private DRI data */
	drm_radeon_sarea_t *sarea;	/* Private SAREA data */

	/* TCL stuff
	 */
	GLmatrix TexGenMatrix[RADEON_MAX_TEXTURE_UNITS];
	GLboolean recheck_texgen[RADEON_MAX_TEXTURE_UNITS];
	GLboolean TexGenNeedNormals[RADEON_MAX_TEXTURE_UNITS];
	GLuint TexGenEnabled;
	GLuint NeedTexMatrix;
	GLuint TexMatColSwap;
	GLmatrix tmpmat[RADEON_MAX_TEXTURE_UNITS];
	GLuint last_ReallyEnabled;

	/* VBI
	 */
	GLuint vbl_seq;
	GLuint vblank_flags;

	int64_t swap_ust;
	int64_t swap_missed_ust;

	GLuint swap_count;
	GLuint swap_missed_count;

	/* radeon_tcl.c
	 */
	struct radeon_tcl_info tcl;

	/* radeon_swtcl.c
	 */
	struct radeon_swtcl_info swtcl;

	/* Mirrors of some DRI state
	 */
	struct radeon_dri_mirror dri;

	/* Configuration cache
	 */
	driOptionCache optionCache;

	GLboolean using_hyperz;
	GLboolean texmicrotile;

	/* Performance counters
	 */
	GLuint boxes;		/* Draw performance boxes */
	GLuint hardwareWentIdle;
	GLuint c_clears;
	GLuint c_drawWaits;
	GLuint c_textureSwaps;
	GLuint c_textureBytes;
	GLuint c_vertexBuffers;
d839 4
a842 3
static __inline GLuint radeonPackColor(GLuint cpp,
				       GLubyte r, GLubyte g,
				       GLubyte b, GLubyte a)
d844 8
a851 8
	switch (cpp) {
	case 2:
		return PACK_COLOR_565(r, g, b);
	case 4:
		return PACK_COLOR_8888(a, r, g, b);
	default:
		return 0;
	}
d856 4
a859 3
extern void radeonDestroyContext(__DRIcontextPrivate * driContextPriv);
extern GLboolean radeonCreateContext(const __GLcontextModes * glVisual,
				     __DRIcontextPrivate * driContextPriv,
d861 1
a861 1
extern void radeonSwapBuffers(__DRIdrawablePrivate * dPriv);
d864 4
a867 4
extern GLboolean radeonMakeCurrent(__DRIcontextPrivate * driContextPriv,
				   __DRIdrawablePrivate * driDrawPriv,
				   __DRIdrawablePrivate * driReadPriv);
extern GLboolean radeonUnbindContext(__DRIcontextPrivate * driContextPriv);
d880 13
a892 13
#define DEBUG_TEXTURE	0x0001
#define DEBUG_STATE	0x0002
#define DEBUG_IOCTL	0x0004
#define DEBUG_PRIMS	0x0008
#define DEBUG_VERTS	0x0010
#define DEBUG_FALLBACKS	0x0020
#define DEBUG_VFMT	0x0040
#define DEBUG_CODEGEN	0x0080
#define DEBUG_VERBOSE	0x0100
#define DEBUG_DRI       0x0200
#define DEBUG_DMA       0x0400
#define DEBUG_SANITY    0x0800
#define DEBUG_SYNC      0x1000
d894 1
a894 1
#endif				/* __RADEON_CONTEXT_H__ */
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d51 17
a67 3
#include "main/macros.h"
#include "main/mtypes.h"
#include "main/colormac.h"
d69 1
d71 1
a71 1
#include "radeon_common.h"
d73 15
d89 3
a91 3
struct r100_context;
typedef struct r100_context r100ContextRec;
typedef struct r100_context *r100ContextPtr;
d93 20
a112 1
#include "radeon_lock.h"
d114 4
d119 8
d128 8
a135 1
#define R100_TEX_ALL 0x7
d144 34
d188 11
d411 3
a413 8
#define R100_QUERYOBJ_CMD_0  0
#define R100_QUERYOBJ_DATA_0 1
#define R100_QUERYOBJ_CMDSIZE  2

#define STP_CMD_0 0
#define STP_DATA_0 1
#define STP_CMD_1 2
#define STP_STATE_SIZE 35
a414 1
struct r100_hw_state {
a437 2
	struct radeon_state_atom stp;
};
d439 2
a440 2
struct radeon_stipple_state {
	GLuint mask[32];
d443 7
a449 1
struct r100_state {
d454 55
d510 9
a518 1
#define R200_ELT_BUF_SZ  (8*1024)
d521 1
a521 1
struct r100_tcl_info {
d530 3
d535 7
a541 3
        int elt_cmd_offset;
	int elt_cmd_start;
        int elt_used;
d546 3
a548 1
struct r100_swtcl_info {
d551 3
d562 4
d577 7
d586 1
d588 5
d603 2
a604 2
struct r100_context {
        struct radeon_context radeon;
d608 17
a624 2
	struct r100_hw_state hw;
	struct r100_state state;
d629 1
d631 25
d668 11
d681 1
a681 1
	struct r100_tcl_info tcl;
d685 9
a693 1
	struct r100_swtcl_info swtcl;
a706 1

d709 1
d711 13
a723 1
#define R100_CONTEXT(ctx)		((r100ContextPtr)(ctx->DriverCtx))
d725 1
d727 11
a737 1
#define RADEON_OLD_PACKETS 1
d739 4
a742 4
extern GLboolean r100CreateContext( gl_api api,
				    const struct gl_config *glVisual,
				    __DRIcontext *driContextPriv,
				    void *sharedContextPrivate);
d744 19
@


1.1.1.5
log
@Import Mesa 9.2.0
@
text
@d50 1
d63 2
d448 1
a448 6
static inline r100ContextPtr
R100_CONTEXT(struct gl_context *ctx)
{
   return (r100ContextPtr) ctx;
}

a455 4
				    unsigned major_version,
				    unsigned minor_version,
				    uint32_t flags,
				    unsigned *error,
@


1.1.1.6
log
@Import Mesa 10.2.3
@
text
@d38 1
a38 1
 *   Keith Whitwell <keithw@@vmware.com>
d419 1
a460 1
                                    bool notify_reset,
@


