head	1.11;
access;
symbols
	OPENBSD_5_8:1.10.0.6
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.4
	OPENBSD_5_7_BASE:1.10
	v10_2_9:1.1.1.6
	v10_4_3:1.1.1.6
	v10_2_7:1.1.1.6
	OPENBSD_5_6:1.10.0.2
	OPENBSD_5_6_BASE:1.10
	v10_2_3:1.1.1.6
	OPENBSD_5_5:1.9.0.2
	OPENBSD_5_5_BASE:1.9
	v9_2_5:1.1.1.5
	v9_2_3:1.1.1.5
	v9_2_2:1.1.1.5
	v9_2_1:1.1.1.5
	v9_2_0:1.1.1.5
	OPENBSD_5_4:1.8.0.4
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.2
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.7.0.4
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.6.0.6
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.4
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.5.0.4
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.2
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.4.0.2
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.3.0.2
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_3:1.2.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2015.12.23.05.17.51;	author jsg;	state dead;
branches;
next	1.10;
commitid	TnlogFl9nOv2eaRf;

1.10
date	2014.07.09.21.09.00;	author jsg;	state Exp;
branches;
next	1.9;
commitid	WPD6rgPryPkvXOr9;

1.9
date	2013.09.05.14.05.58;	author jsg;	state Exp;
branches;
next	1.8;

1.8
date	2012.08.17.13.58.17;	author mpi;	state Exp;
branches;
next	1.7;

1.7
date	2011.10.23.13.37.41;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.05.22.20.06.27;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2009.05.17.20.26.41;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2008.11.02.14.58.19;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.05.31.16.36.48;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.02.12.21.09.27;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.51.54;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.51.54;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.56.58;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.30.19;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.44;	author matthieu;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.09.05.13.16.16;	author jsg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.07.09.20.34.58;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.11
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Windows (Win32/Win64) device driver for Mesa
 *
 */

#include "wmesadef.h"
#include "colors.h"
#include "GL/wmesa.h"
#include <winuser.h>
#include "main/context.h"
#include "main/api_exec.h"
#include "main/extensions.h"
#include "main/framebuffer.h"
#include "main/renderbuffer.h"
#include "main/macros.h"
#include "main/version.h"
#include "main/vtxfmt.h"
#include "drivers/common/driverfuncs.h"
#include "drivers/common/meta.h"
#include "vbo/vbo.h"
#include "swrast/swrast.h"
#include "swrast/s_renderbuffer.h"
#include "swrast_setup/swrast_setup.h"
#include "tnl/tnl.h"
#include "tnl/t_context.h"
#include "tnl/t_pipeline.h"


/* linked list of our Framebuffers (windows) */
static WMesaFramebuffer FirstFramebuffer = NULL;


/**
 * Create a new WMesaFramebuffer object which will correspond to the
 * given HDC (Window handle).
 */
static WMesaFramebuffer
wmesa_new_framebuffer(HDC hdc, struct gl_config *visual)
{
    WMesaFramebuffer pwfb
        = malloc(sizeof(struct wmesa_framebuffer));
    if (pwfb) {
        _mesa_initialize_window_framebuffer(&pwfb->Base, visual);
        pwfb->hDC = hdc;
        /* insert at head of list */
        pwfb->next = FirstFramebuffer;
        FirstFramebuffer = pwfb;
    }
    return pwfb;
}

/**
 * Given an hdc, free the corresponding WMesaFramebuffer
 */
static void
wmesa_free_framebuffer(HDC hdc)
{
    WMesaFramebuffer pwfb, prev;
    for (pwfb = FirstFramebuffer; pwfb; pwfb = pwfb->next) {
        if (pwfb->hDC == hdc)
            break;
	prev = pwfb;
    }
    if (pwfb) {
        struct gl_framebuffer *fb;
	if (pwfb == FirstFramebuffer)
	    FirstFramebuffer = pwfb->next;
	else
	    prev->next = pwfb->next;
        fb = &pwfb->Base;
        _mesa_reference_framebuffer(&fb, NULL); 
    }
}

/**
 * Given an hdc, return the corresponding WMesaFramebuffer
 */
static WMesaFramebuffer
wmesa_lookup_framebuffer(HDC hdc)
{
    WMesaFramebuffer pwfb;
    for (pwfb = FirstFramebuffer; pwfb; pwfb = pwfb->next) {
        if (pwfb->hDC == hdc)
            return pwfb;
    }
    return NULL;
}


/**
 * Given a struct gl_framebuffer, return the corresponding WMesaFramebuffer.
 */
static WMesaFramebuffer wmesa_framebuffer(struct gl_framebuffer *fb)
{
    return (WMesaFramebuffer) fb;
}


/**
 * Given a struct gl_context, return the corresponding WMesaContext.
 */
static WMesaContext wmesa_context(const struct gl_context *ctx)
{
    return (WMesaContext) ctx;
}


/*
 * Every driver should implement a GetString function in order to
 * return a meaningful GL_RENDERER string.
 */
static const GLubyte *wmesa_get_string(struct gl_context *ctx, GLenum name)
{
    return (name == GL_RENDERER) ? 
	(GLubyte *) "Mesa Windows GDI Driver" : NULL;
}


/*
 * Determine the pixel format based on the pixel size.
 */
static void wmSetPixelFormat(WMesaFramebuffer pwfb, HDC hDC)
{
    pwfb->cColorBits = GetDeviceCaps(hDC, BITSPIXEL);

    /* Only 16 and 32 bit targets are supported now */
    assert(pwfb->cColorBits == 0 ||
	   pwfb->cColorBits == 16 || 
	   pwfb->cColorBits == 24 || 
	   pwfb->cColorBits == 32);

    switch(pwfb->cColorBits){
    case 8:
	pwfb->pixelformat = PF_INDEX8;
	break;
    case 16:
	pwfb->pixelformat = PF_5R6G5B;
	break;
    case 24:
    case 32:
	pwfb->pixelformat = PF_8R8G8B;
	break;
    default:
	pwfb->pixelformat = PF_BADFORMAT;
    }
}


/**
 * Create DIB for back buffer.
 * We write into this memory with the span routines and then blit it
 * to the window on a buffer swap.
 */
static BOOL wmCreateBackingStore(WMesaFramebuffer pwfb, long lxSize, long lySize)
{
    LPBITMAPINFO pbmi = &(pwfb->bmi);
    HDC          hic;

    pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
    pbmi->bmiHeader.biWidth = lxSize;
    pbmi->bmiHeader.biHeight= -lySize;
    pbmi->bmiHeader.biPlanes = 1;
    pbmi->bmiHeader.biBitCount = GetDeviceCaps(pwfb->hDC, BITSPIXEL);
    pbmi->bmiHeader.biCompression = BI_RGB;
    pbmi->bmiHeader.biSizeImage = 0;
    pbmi->bmiHeader.biXPelsPerMeter = 0;
    pbmi->bmiHeader.biYPelsPerMeter = 0;
    pbmi->bmiHeader.biClrUsed = 0;
    pbmi->bmiHeader.biClrImportant = 0;
    
    pwfb->cColorBits = pbmi->bmiHeader.biBitCount;
    pwfb->ScanWidth = (lxSize * (pwfb->cColorBits / 8) + 3) & ~3;
    
    hic = CreateIC("display", NULL, NULL, NULL);
    pwfb->dib_hDC = CreateCompatibleDC(hic);
    
    pwfb->hbmDIB = CreateDIBSection(hic,
				   &pwfb->bmi,
				   DIB_RGB_COLORS,
				   (void **)&(pwfb->pbPixels),
				   0,
				   0);
    pwfb->hOldBitmap = SelectObject(pwfb->dib_hDC, pwfb->hbmDIB);
    
    DeleteDC(hic);

    wmSetPixelFormat(pwfb, pwfb->hDC);
    return TRUE;
}


static void wmDeleteBackingStore(WMesaFramebuffer pwfb)
{
    if (pwfb->hbmDIB) {
	SelectObject(pwfb->dib_hDC, pwfb->hOldBitmap);
	DeleteDC(pwfb->dib_hDC);
	DeleteObject(pwfb->hbmDIB);
    }
}


/**
 * Find the width and height of the window named by hdc.
 */
static void
get_window_size(HDC hdc, GLuint *width, GLuint *height)
{
    if (WindowFromDC(hdc)) {
        RECT rect;
        GetClientRect(WindowFromDC(hdc), &rect);
        *width = rect.right - rect.left;
        *height = rect.bottom - rect.top;
    }
    else { /* Memory context */
        /* From contributed code - use the size of the desktop
         * for the size of a memory context (?) */
        *width = GetDeviceCaps(hdc, HORZRES);
        *height = GetDeviceCaps(hdc, VERTRES);
    }
}


static void
wmesa_get_buffer_size(struct gl_framebuffer *buffer, GLuint *width, GLuint *height)
{
    WMesaFramebuffer pwfb = wmesa_framebuffer(buffer);
    get_window_size(pwfb->hDC, width, height);
}


static void wmesa_flush(struct gl_context *ctx)
{
    WMesaFramebuffer pwfb = wmesa_framebuffer(ctx->WinSysDrawBuffer);

    if (ctx->Visual.doubleBufferMode == 1) {
	BitBlt(pwfb->hDC, 0, 0, pwfb->Base.Width, pwfb->Base.Height,
	       pwfb->dib_hDC, 0, 0, SRCCOPY);
    }
    else {
	/* Do nothing for single buffer */
    }
}


/**********************************************************************/
/*****                   CLEAR Functions                          *****/
/**********************************************************************/

/* 
 * Clear the color/depth/stencil buffers.
 */ 
static void clear(struct gl_context *ctx, GLbitfield mask)
{
#define FLIP(Y)  (ctx->DrawBuffer->Height - (Y) - 1)
    const GLint x = ctx->DrawBuffer->_Xmin;
    const GLint y = ctx->DrawBuffer->_Ymin;
    const GLint height = ctx->DrawBuffer->_Ymax - ctx->DrawBuffer->_Ymin;
    const GLint width  = ctx->DrawBuffer->_Xmax - ctx->DrawBuffer->_Xmin;

    WMesaContext pwc = wmesa_context(ctx);
    WMesaFramebuffer pwfb = wmesa_framebuffer(ctx->DrawBuffer);
    int done = 0;

    /* Let swrast do all the work if the masks are not set to
     * clear all channels. */
    if (!ctx->Color.ColorMask[0][0] ||
	!ctx->Color.ColorMask[0][1] ||
	!ctx->Color.ColorMask[0][2] ||
	!ctx->Color.ColorMask[0][3]) {
	_swrast_Clear(ctx, mask);
	return;
    }

    if (mask & BUFFER_BITS_COLOR) {
       /* setup the clearing color */
       const union gl_color_union color = ctx->Color.ClearColor;
       GLubyte col[3];
       UNCLAMPED_FLOAT_TO_UBYTE(col[0], color.f[0]);
       UNCLAMPED_FLOAT_TO_UBYTE(col[1], color.f[1]);
       UNCLAMPED_FLOAT_TO_UBYTE(col[2], color.f[2]);
       pwc->clearColorRef = RGB(col[0], col[1], col[2]);
       DeleteObject(pwc->clearPen);
       DeleteObject(pwc->clearBrush);
       pwc->clearPen = CreatePen(PS_SOLID, 1, pwc->clearColorRef); 
       pwc->clearBrush = CreateSolidBrush(pwc->clearColorRef); 
    }

    /* Back buffer */
    if (mask & BUFFER_BIT_BACK_LEFT) { 
	
	int     i, rowSize; 
	UINT    bytesPerPixel = pwfb->cColorBits / 8; 
	LPBYTE  lpb, clearRow;
	LPWORD  lpw;
	BYTE    bColor; 
	WORD    wColor; 
	BYTE    r, g, b; 
	DWORD   dwColor; 
	LPDWORD lpdw; 
	
	/* Try for a fast clear - clearing entire buffer with a single
	 * byte value. */
	if (width == ctx->DrawBuffer->Width &&
            height == ctx->DrawBuffer->Height) { /* entire buffer */
	    /* Now check for an easy clear value */
	    switch (bytesPerPixel) {
	    case 1:
		bColor = BGR8(GetRValue(pwc->clearColorRef), 
			      GetGValue(pwc->clearColorRef), 
			      GetBValue(pwc->clearColorRef));
		memset(pwfb->pbPixels, bColor, 
		       pwfb->ScanWidth * height);
		done = 1;
		break;
	    case 2:
		wColor = BGR16(GetRValue(pwc->clearColorRef), 
			       GetGValue(pwc->clearColorRef), 
			       GetBValue(pwc->clearColorRef)); 
		if (((wColor >> 8) & 0xff) == (wColor & 0xff)) {
		    memset(pwfb->pbPixels, wColor & 0xff, 
			   pwfb->ScanWidth * height);
		    done = 1;
		}
		break;
	    case 3:
		/* fall through */
	    case 4:
		if (GetRValue(pwc->clearColorRef) == 
		    GetGValue(pwc->clearColorRef) &&
		    GetRValue(pwc->clearColorRef) == 
		    GetBValue(pwc->clearColorRef)) {
		    memset(pwfb->pbPixels, 
			   GetRValue(pwc->clearColorRef), 
			   pwfb->ScanWidth * height);
		    done = 1;
		}
		break;
	    default:
		break;
	    }
	} /* all */

	if (!done) {
	    /* Need to clear a row at a time.  Begin by setting the first
	     * row in the area to be cleared to the clear color. */
	    
	    clearRow = pwfb->pbPixels + 
		pwfb->ScanWidth * FLIP(y) +
		bytesPerPixel * x; 
	    switch (bytesPerPixel) {
	    case 1:
		lpb = clearRow;
		bColor = BGR8(GetRValue(pwc->clearColorRef), 
			      GetGValue(pwc->clearColorRef), 
			      GetBValue(pwc->clearColorRef));
		memset(lpb, bColor, width);
		break;
	    case 2:
		lpw = (LPWORD)clearRow;
		wColor = BGR16(GetRValue(pwc->clearColorRef), 
			       GetGValue(pwc->clearColorRef), 
			       GetBValue(pwc->clearColorRef)); 
		for (i=0; i<width; i++)
		    *lpw++ = wColor;
		break;
	    case 3: 
		lpb = clearRow;
		r = GetRValue(pwc->clearColorRef); 
		g = GetGValue(pwc->clearColorRef); 
		b = GetBValue(pwc->clearColorRef); 
		for (i=0; i<width; i++) {
		    *lpb++ = b; 
		    *lpb++ = g; 
		    *lpb++ = r; 
		} 
		break;
	    case 4: 
		lpdw = (LPDWORD)clearRow; 
		dwColor = BGR32(GetRValue(pwc->clearColorRef), 
				GetGValue(pwc->clearColorRef), 
				GetBValue(pwc->clearColorRef)); 
		for (i=0; i<width; i++)
		    *lpdw++ = dwColor;
		break;
	    default:
		break;
	    } /* switch */
	    
	    /* copy cleared row to other rows in buffer */
	    lpb = clearRow - pwfb->ScanWidth;
	    rowSize = width * bytesPerPixel;
	    for (i=1; i<height; i++) { 
		memcpy(lpb, clearRow, rowSize); 
		lpb -= pwfb->ScanWidth; 
	    } 
	} /* not done */
	mask &= ~BUFFER_BIT_BACK_LEFT;
    } /* back buffer */ 

    /* front buffer */
    if (mask & BUFFER_BIT_FRONT_LEFT) { 
	HDC DC = pwc->hDC; 
	HPEN Old_Pen = SelectObject(DC, pwc->clearPen); 
	HBRUSH Old_Brush = SelectObject(DC, pwc->clearBrush);
	Rectangle(DC,
		  x,
		  FLIP(y) + 1,
		  x + width + 1,
		  FLIP(y) - height + 1);
	SelectObject(DC, Old_Pen); 
	SelectObject(DC, Old_Brush); 
	mask &= ~BUFFER_BIT_FRONT_LEFT;
    } /* front buffer */ 
    
    /* Call swrast if there is anything left to clear (like DEPTH) */ 
    if (mask) 
	_swrast_Clear(ctx, mask);
  
#undef FLIP
} 



/**********************************************************************/
/*****                   BUFFER Functions                         *****/
/**********************************************************************/




static void
wmesa_delete_renderbuffer(struct gl_context *ctx, struct gl_renderbuffer *rb)
{
    _mesa_delete_renderbuffer(ctx, rb);
}


/**
 * This is called by Mesa whenever it determines that the window size
 * has changed.  Do whatever's needed to cope with that.
 */
static GLboolean
wmesa_renderbuffer_storage(struct gl_context *ctx, 
			   struct gl_renderbuffer *rb,
			   GLenum internalFormat, 
			   GLuint width, 
			   GLuint height)
{
    rb->Width = width;
    rb->Height = height;
    return GL_TRUE;
}


/**
 * Called by ctx->Driver.ResizeBuffers()
 * Resize the front/back colorbuffers to match the latest window size.
 */
static void
wmesa_resize_buffers(struct gl_context *ctx, struct gl_framebuffer *buffer,
                     GLuint width, GLuint height)
{
    WMesaFramebuffer pwfb = wmesa_framebuffer(buffer);

    if (pwfb->Base.Width != width || pwfb->Base.Height != height) {
	/* Realloc back buffer */
	if (ctx->Visual.doubleBufferMode == 1) {
	    wmDeleteBackingStore(pwfb);
	    wmCreateBackingStore(pwfb, width, height);
	}
    }
    _mesa_resize_framebuffer(ctx, buffer, width, height);
}


/**
 * Called by glViewport.
 * This is a good time for us to poll the current window size and adjust
 * our renderbuffers to match the current window size.
 * Remember, we have no opportunity to respond to conventional
 * resize events since the driver has no event loop.
 * Thus, we poll.
 * MakeCurrent also ends up making a call here, so that ensures
 * we get the viewport set correctly, even if the app does not call
 * glViewport and relies on the defaults.
 */
static void wmesa_viewport(struct gl_context *ctx)
{
    GLuint new_width, new_height;

    wmesa_get_buffer_size(ctx->WinSysDrawBuffer, &new_width, &new_height);

    /**
     * Resize buffers if the window size changed.
     */
    wmesa_resize_buffers(ctx, ctx->WinSysDrawBuffer, new_width, new_height);
    ctx->NewState |= _NEW_BUFFERS;  /* to update scissor / window bounds */
}




/**
 * Called when the driver should update it's state, based on the new_state
 * flags.
 */
static void wmesa_update_state(struct gl_context *ctx, GLuint new_state)
{
    _swrast_InvalidateState(ctx, new_state);
    _swsetup_InvalidateState(ctx, new_state);
    _vbo_InvalidateState(ctx, new_state);
    _tnl_InvalidateState(ctx, new_state);

    /* TODO - This code is not complete yet because I 
     * don't know what to do for all state updates.
     */

    if (new_state & _NEW_BUFFERS) {
    }
}





/**********************************************************************/
/*****                   WMESA Functions                          *****/
/**********************************************************************/

WMesaContext WMesaCreateContext(HDC hDC, 
				HPALETTE* Pal,
				GLboolean rgb_flag,
				GLboolean db_flag,
				GLboolean alpha_flag)
{
    WMesaContext c;
    struct dd_function_table functions;
    GLint red_bits, green_bits, blue_bits, alpha_bits;
    struct gl_context *ctx;
    struct gl_config *visual;

    (void) Pal;
    
    /* Indexed mode not supported */
    if (!rgb_flag)
	return NULL;

    /* Allocate wmesa context */
    c = CALLOC_STRUCT(wmesa_context);
    if (!c)
	return NULL;

#if 0
    /* I do not understand this contributed code */
    /* Support memory and device contexts */
    if(WindowFromDC(hDC) != NULL) {
	c->hDC = GetDC(WindowFromDC(hDC)); /* huh ???? */
    }
    else {
	c->hDC = hDC;
    }
#else
    c->hDC = hDC;
#endif

    /* Get data for visual */
    /* Dealing with this is actually a bit of overkill because Mesa will end
     * up treating all color component size requests less than 8 by using 
     * a single byte per channel.  In addition, the interface to the span
     * routines passes colors as an entire byte per channel anyway, so there
     * is nothing to be saved by telling the visual to be 16 bits if the device
     * is 16 bits.  That is, Mesa is going to compute colors down to 8 bits per
     * channel anyway.
     * But we go through the motions here anyway.
     */
    switch (GetDeviceCaps(c->hDC, BITSPIXEL)) {
    case 16:
	red_bits = green_bits = blue_bits = 5;
	alpha_bits = 0;
	break;
    default:
	red_bits = green_bits = blue_bits = 8;
	alpha_bits = 8;
	break;
    }
    /* Create visual based on flags */
    visual = _mesa_create_visual(db_flag,    /* db_flag */
                                 GL_FALSE,   /* stereo */
                                 red_bits, green_bits, blue_bits, /* color RGB */
                                 alpha_flag ? alpha_bits : 0, /* color A */
                                 DEFAULT_SOFTWARE_DEPTH_BITS, /* depth_bits */
                                 8,          /* stencil_bits */
                                 16,16,16,   /* accum RGB */
                                 alpha_flag ? 16 : 0, /* accum A */
                                 1);         /* num samples */
    
    if (!visual) {
	free(c);
	return NULL;
    }

    /* Set up driver functions */
    _mesa_init_driver_functions(&functions);
    functions.GetString = wmesa_get_string;
    functions.UpdateState = wmesa_update_state;
    functions.Flush = wmesa_flush;
    functions.Clear = clear;
    functions.ResizeBuffers = wmesa_resize_buffers;
    functions.Viewport = wmesa_viewport;

    /* initialize the Mesa context data */
    ctx = &c->gl_ctx;
    _mesa_initialize_context(ctx, API_OPENGL_COMPAT, visual,
                             NULL, &functions);

    /* visual no longer needed - it was copied by _mesa_initialize_context() */
    _mesa_destroy_visual(visual);

    _mesa_enable_sw_extensions(ctx);
  
    _mesa_meta_init(ctx);

    /* Initialize the software rasterizer and helper modules. */
    if (!_swrast_CreateContext(ctx) ||
        !_vbo_CreateContext(ctx) ||
        !_tnl_CreateContext(ctx) ||
	!_swsetup_CreateContext(ctx)) {
	_mesa_free_context_data(ctx);
	free(c);
	return NULL;
    }
    _swsetup_Wakeup(ctx);
    TNL_CONTEXT(ctx)->Driver.RunPipeline = _tnl_run_pipeline;

    _mesa_compute_version(ctx);

    /* Exec table initialization requires the version to be computed */
    _mesa_initialize_dispatch_tables(ctx);
    _mesa_initialize_vbo_vtxfmt(ctx);

    return c;
}


void WMesaDestroyContext( WMesaContext pwc )
{
    struct gl_context *ctx = &pwc->gl_ctx;
    WMesaFramebuffer pwfb;
    GET_CURRENT_CONTEXT(cur_ctx);

    if (cur_ctx == ctx) {
        /* unbind current if deleting current context */
        WMesaMakeCurrent(NULL, NULL);
    }

    /* clean up frame buffer resources */
    pwfb = wmesa_lookup_framebuffer(pwc->hDC);
    if (pwfb) {
	if (ctx->Visual.doubleBufferMode == 1)
	    wmDeleteBackingStore(pwfb);
	wmesa_free_framebuffer(pwc->hDC);
    }

    /* Release for device, not memory contexts */
    if (WindowFromDC(pwc->hDC) != NULL)
    {
      ReleaseDC(WindowFromDC(pwc->hDC), pwc->hDC);
    }
    DeleteObject(pwc->clearPen); 
    DeleteObject(pwc->clearBrush); 
    
    _mesa_meta_free(ctx);

    _swsetup_DestroyContext(ctx);
    _tnl_DestroyContext(ctx);
    _vbo_DestroyContext(ctx);
    _swrast_DestroyContext(ctx);
    
    _mesa_free_context_data(ctx);
    free(pwc);
}


/**
 * Create a new color renderbuffer.
 */
static struct gl_renderbuffer *
wmesa_new_renderbuffer(void)
{
    struct gl_renderbuffer *rb = CALLOC_STRUCT(gl_renderbuffer);
    if (!rb)
        return NULL;

    _mesa_init_renderbuffer(rb, (GLuint)0);
    
    rb->_BaseFormat = GL_RGBA;
    rb->InternalFormat = GL_RGBA;
    rb->Delete = wmesa_delete_renderbuffer;
    rb->AllocStorage = wmesa_renderbuffer_storage;
    return rb;
}


void WMesaMakeCurrent(WMesaContext c, HDC hdc)
{
    WMesaFramebuffer pwfb;

    {
        /* return if already current */
        GET_CURRENT_CONTEXT(ctx);
        WMesaContext pwc = wmesa_context(ctx);
        if (pwc && c == pwc && pwc->hDC == hdc)
            return;
    }

    pwfb = wmesa_lookup_framebuffer(hdc);

    /* Lazy creation of framebuffers */
    if (c && !pwfb && hdc) {
        struct gl_renderbuffer *rb;
        struct gl_config *visual = &c->gl_ctx.Visual;
        GLuint width, height;

        get_window_size(hdc, &width, &height);

	c->clearPen = CreatePen(PS_SOLID, 1, 0); 
	c->clearBrush = CreateSolidBrush(0); 

        pwfb = wmesa_new_framebuffer(hdc, visual);

	/* Create back buffer if double buffered */
	if (visual->doubleBufferMode == 1) {
	    wmCreateBackingStore(pwfb, width, height);
	}
	
        /* make render buffers */
        if (visual->doubleBufferMode == 1) {
            rb = wmesa_new_renderbuffer();
            _mesa_add_renderbuffer(&pwfb->Base, BUFFER_BACK_LEFT, rb);
	}
        rb = wmesa_new_renderbuffer();
        _mesa_add_renderbuffer(&pwfb->Base, BUFFER_FRONT_LEFT, rb);

	/* Let Mesa own the Depth, Stencil, and Accum buffers */
        _swrast_add_soft_renderbuffers(&pwfb->Base,
                                       GL_FALSE, /* color */
                                       visual->depthBits > 0,
                                       visual->stencilBits > 0,
                                       visual->accumRedBits > 0,
                                       visual->alphaBits >0, 
                                       GL_FALSE);
    }

    if (c && pwfb)
	_mesa_make_current(&c->gl_ctx, &pwfb->Base, &pwfb->Base);
    else
        _mesa_make_current(NULL, NULL, NULL);
}


void WMesaSwapBuffers( HDC hdc )
{
    GET_CURRENT_CONTEXT(ctx);
    WMesaContext pwc = wmesa_context(ctx);
    WMesaFramebuffer pwfb = wmesa_lookup_framebuffer(hdc);

    if (!pwfb) {
        _mesa_problem(NULL, "wmesa: swapbuffers on unknown hdc");
        return;
    }

    /* If we're swapping the buffer associated with the current context
     * we have to flush any pending rendering commands first.
     */
    if (pwc->hDC == hdc) {
	_mesa_notifySwapBuffers(ctx);

	BitBlt(pwfb->hDC, 0, 0, pwfb->Base.Width, pwfb->Base.Height,
	       pwfb->dib_hDC, 0, 0, SRCCOPY);
    }
    else {
        /* XXX for now only allow swapping current window */
        _mesa_problem(NULL, "wmesa: can't swap non-current window");
    }
}

void WMesaShareLists(WMesaContext ctx_to_share, WMesaContext ctx)
{
	_mesa_share_state(&ctx->gl_ctx, &ctx_to_share->gl_ctx);	
}

@


1.10
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.9
log
@Merge Mesa 9.2.0
@
text
@d487 1
a487 3
static void wmesa_viewport(struct gl_context *ctx, 
			   GLint x, GLint y, 
			   GLsizei width, GLsizei height)
@


1.8
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d11 1
d16 2
d22 1
d41 1
a41 1
        = (WMesaFramebuffer) malloc(sizeof(struct wmesa_framebuffer));
a248 23
/* If we do not implement these, Mesa clears the buffers via the pixel
 * span writing interface, which is very slow for a clear operation.
 */

/*
 * Set the color used to clear the color buffer.
 */
static void clear_color(struct gl_context *ctx, const GLfloat color[4])
{
    WMesaContext pwc = wmesa_context(ctx);
    GLubyte col[3];

    CLAMPED_FLOAT_TO_UBYTE(col[0], color[0]);
    CLAMPED_FLOAT_TO_UBYTE(col[1], color[1]);
    CLAMPED_FLOAT_TO_UBYTE(col[2], color[2]);
    pwc->clearColorRef = RGB(col[0], col[1], col[2]);
    DeleteObject(pwc->clearPen);
    DeleteObject(pwc->clearBrush);
    pwc->clearPen = CreatePen(PS_SOLID, 1, pwc->clearColorRef); 
    pwc->clearBrush = CreateSolidBrush(pwc->clearColorRef); 
}


d250 1
a250 6
 * Clear the specified region of the color buffer using the clear color 
 * or index as specified by one of the two functions above. 
 * 
 * This procedure clears either the front and/or the back COLOR buffers. 
 * Only the "left" buffer is cleared since we are not stereo. 
 * Clearing of the other non-color buffers is left to the swrast. 
a251 1

d274 14
a422 790
/**********************************************************************/
/*****                   PIXEL Functions                          *****/
/**********************************************************************/

#define FLIP(Y)  (rb->Height - (Y) - 1)


/**
 ** Front Buffer reading/writing
 ** These are slow, but work with all non-indexed visual types.
 **/

/* Write a horizontal span of RGBA color pixels with a boolean mask. */
static void write_rgba_span_front(struct gl_context *ctx, 
				  struct gl_renderbuffer *rb, 
				  GLuint n, GLint x, GLint y,
				  const void *values, 
				  const GLubyte *mask)
{
   const GLubyte (*rgba)[4] = (const GLubyte (*)[4])values;
   WMesaContext pwc = wmesa_context(ctx);
   WMesaFramebuffer pwfb = wmesa_lookup_framebuffer(pwc->hDC);
   HBITMAP bmp=0;
   HDC mdc=0;
   typedef union
   {
      unsigned i;
      struct {
         unsigned b:8, g:8, r:8, a:8;
      };
   } BGRA;
   BGRA *bgra, c;
   GLuint i;

   if (n < 16) {   // the value 16 is just guessed
      y=FLIP(y);
      if (mask) {
         for (i=0; i<n; i++)
            if (mask[i])
               SetPixel(pwc->hDC, x+i, y,
                        RGB(rgba[i][RCOMP], rgba[i][GCOMP], rgba[i][BCOMP]));
      }
      else {
         for (i=0; i<n; i++)
            SetPixel(pwc->hDC, x+i, y,
                     RGB(rgba[i][RCOMP], rgba[i][GCOMP], rgba[i][BCOMP]));
      }
   }
   else {
      if (!pwfb) {
         _mesa_problem(NULL, "wmesa: write_rgba_span_front on unknown hdc");
         return;
      }
      bgra=malloc(n*sizeof(BGRA));
      if (!bgra) {
         _mesa_problem(NULL, "wmesa: write_rgba_span_front: out of memory");
         return;
      }
      c.a=0;
      if (mask) {
         for (i=0; i<n; i++) {
            if (mask[i]) {
               c.r=rgba[i][RCOMP];
               c.g=rgba[i][GCOMP];
               c.b=rgba[i][BCOMP];
               c.a=rgba[i][ACOMP];
               bgra[i]=c;
            }
            else
               bgra[i].i=0;
         }
      }
      else {
         for (i=0; i<n; i++) {
            c.r=rgba[i][RCOMP];
            c.g=rgba[i][GCOMP];
            c.b=rgba[i][BCOMP];
            c.a=rgba[i][ACOMP];
            bgra[i]=c;
         }
      }
      bmp=CreateBitmap(n, 1,  1, 32, bgra);
      mdc=CreateCompatibleDC(pwfb->hDC);
      SelectObject(mdc, bmp);
      y=FLIP(y);
      BitBlt(pwfb->hDC, x, y, n, 1, mdc, 0, 0, SRCCOPY);
      SelectObject(mdc, 0);
      DeleteObject(bmp);
      DeleteDC(mdc);
      free(bgra);
   }
}

/* Write a horizontal span of RGB color pixels with a boolean mask. */
static void write_rgb_span_front(struct gl_context *ctx, 
				 struct gl_renderbuffer *rb, 
				 GLuint n, GLint x, GLint y,
				 const void *values, 
				 const GLubyte *mask)
{
    const GLubyte (*rgb)[3] = (const GLubyte (*)[3])values;
    WMesaContext pwc = wmesa_context(ctx);
    GLuint i;
    
    (void) ctx;
    y=FLIP(y);
    if (mask) {
	for (i=0; i<n; i++)
	    if (mask[i])
		SetPixel(pwc->hDC, x+i, y, RGB(rgb[i][RCOMP], rgb[i][GCOMP], 
					       rgb[i][BCOMP]));
    }
    else {
	for (i=0; i<n; i++)
	    SetPixel(pwc->hDC, x+i, y, RGB(rgb[i][RCOMP], rgb[i][GCOMP], 
					   rgb[i][BCOMP]));
    }
    
}

/*
 * Write a horizontal span of pixels with a boolean mask.  The current color
 * is used for all pixels.
 */
static void write_mono_rgba_span_front(struct gl_context *ctx, 
                                       struct gl_renderbuffer *rb,
                                       GLuint n, GLint x, GLint y,
                                       const void *value, 
                                       const GLubyte *mask)
{
    const GLchan *color = (const GLchan *)value;
    GLuint i;
    WMesaContext pwc = wmesa_context(ctx);
    COLORREF colorref;

    (void) ctx;
    colorref = RGB(color[RCOMP], color[GCOMP], color[BCOMP]);
    y=FLIP(y);
    if (mask) {
	for (i=0; i<n; i++)
	    if (mask[i])
		SetPixel(pwc->hDC, x+i, y, colorref);
    }
    else
	for (i=0; i<n; i++)
	    SetPixel(pwc->hDC, x+i, y, colorref);

}

/* Write an array of RGBA pixels with a boolean mask. */
static void write_rgba_pixels_front(struct gl_context *ctx, 
                                    struct gl_renderbuffer *rb,
                                    GLuint n, 
                                    const GLint x[], const GLint y[],
                                    const void *values, 
                                    const GLubyte *mask)
{
    const GLubyte (*rgba)[4] = (const GLubyte (*)[4])values;
    GLuint i;
    WMesaContext pwc = wmesa_context(ctx);
    (void) ctx;
    for (i=0; i<n; i++)
	if (mask[i])
	    SetPixel(pwc->hDC, x[i], FLIP(y[i]), 
		     RGB(rgba[i][RCOMP], rgba[i][GCOMP], 
			 rgba[i][BCOMP]));
}



/*
 * Write an array of pixels with a boolean mask.  The current color
 * is used for all pixels.
 */
static void write_mono_rgba_pixels_front(struct gl_context *ctx, 
                                         struct gl_renderbuffer *rb,
                                         GLuint n,
                                         const GLint x[], const GLint y[],
                                         const void *value,
                                         const GLubyte *mask)
{
    const GLchan *color = (const GLchan *)value;
    GLuint i;
    WMesaContext pwc = wmesa_context(ctx);
    COLORREF colorref;
    (void) ctx;
    colorref = RGB(color[RCOMP], color[GCOMP], color[BCOMP]);
    for (i=0; i<n; i++)
	if (mask[i])
	    SetPixel(pwc->hDC, x[i], FLIP(y[i]), colorref);
}

/* Read a horizontal span of color pixels. */
static void read_rgba_span_front(struct gl_context *ctx, 
                                 struct gl_renderbuffer *rb,
                                 GLuint n, GLint x, GLint y,
                                 void *values)
{
    GLubyte (*rgba)[4] = (GLubyte (*)[4])values;
    WMesaContext pwc = wmesa_context(ctx);
    GLuint i;
    COLORREF Color;
    y = FLIP(y);
    for (i=0; i<n; i++) {
	Color = GetPixel(pwc->hDC, x+i, y);
	rgba[i][RCOMP] = GetRValue(Color);
	rgba[i][GCOMP] = GetGValue(Color);
	rgba[i][BCOMP] = GetBValue(Color);
	rgba[i][ACOMP] = 255;
    }
}


/* Read an array of color pixels. */
static void read_rgba_pixels_front(struct gl_context *ctx, 
                                   struct gl_renderbuffer *rb,
                                   GLuint n, const GLint x[], const GLint y[],
                                   void *values)
{
    GLubyte (*rgba)[4] = (GLubyte (*)[4])values;
    WMesaContext pwc = wmesa_context(ctx);
    GLuint i;
    COLORREF Color;
    for (i=0; i<n; i++) {
        GLint y2 = FLIP(y[i]);
        Color = GetPixel(pwc->hDC, x[i], y2);
        rgba[i][RCOMP] = GetRValue(Color);
        rgba[i][GCOMP] = GetGValue(Color);
        rgba[i][BCOMP] = GetBValue(Color);
        rgba[i][ACOMP] = 255;
    }
}

/*********************************************************************/

/* DOUBLE BUFFER 32-bit */

#define WMSETPIXEL32(pwc, y, x, r, g, b) { \
LPDWORD lpdw = ((LPDWORD)((pwc)->pbPixels + (pwc)->ScanWidth * (y)) + (x)); \
*lpdw = BGR32((r),(g),(b)); }



/* Write a horizontal span of RGBA color pixels with a boolean mask. */
static void write_rgba_span_32(struct gl_context *ctx, 
			       struct gl_renderbuffer *rb, 
			       GLuint n, GLint x, GLint y,
			       const void *values, 
			       const GLubyte *mask)
{
    const GLubyte (*rgba)[4] = (const GLubyte (*)[4])values;
    WMesaFramebuffer pwfb = wmesa_framebuffer(ctx->DrawBuffer);
    GLuint i;
    LPDWORD lpdw;

    (void) ctx;
    
    y=FLIP(y);
    lpdw = ((LPDWORD)(pwfb->pbPixels + pwfb->ScanWidth * y)) + x;
    if (mask) {
	for (i=0; i<n; i++)
	    if (mask[i])
                lpdw[i] = BGR32(rgba[i][RCOMP], rgba[i][GCOMP], 
				rgba[i][BCOMP]);
    }
    else {
	for (i=0; i<n; i++)
                *lpdw++ = BGR32(rgba[i][RCOMP], rgba[i][GCOMP], 
				rgba[i][BCOMP]);
    }
}


/* Write a horizontal span of RGB color pixels with a boolean mask. */
static void write_rgb_span_32(struct gl_context *ctx, 
			      struct gl_renderbuffer *rb, 
			      GLuint n, GLint x, GLint y,
			      const void *values, 
			      const GLubyte *mask)
{
    const GLubyte (*rgb)[3] = (const GLubyte (*)[3])values;
    WMesaFramebuffer pwfb = wmesa_framebuffer(ctx->DrawBuffer);
    GLuint i;
    LPDWORD lpdw;

    (void) ctx;
    
    y=FLIP(y);
    lpdw = ((LPDWORD)(pwfb->pbPixels + pwfb->ScanWidth * y)) + x;
    if (mask) {
	for (i=0; i<n; i++)
	    if (mask[i])
                lpdw[i] = BGR32(rgb[i][RCOMP], rgb[i][GCOMP], 
				rgb[i][BCOMP]);
    }
    else {
	for (i=0; i<n; i++)
                *lpdw++ = BGR32(rgb[i][RCOMP], rgb[i][GCOMP], 
				rgb[i][BCOMP]);
    }
}

/*
 * Write a horizontal span of pixels with a boolean mask.  The current color
 * is used for all pixels.
 */
static void write_mono_rgba_span_32(struct gl_context *ctx, 
				    struct gl_renderbuffer *rb,
				    GLuint n, GLint x, GLint y,
				    const void *value, 
				    const GLubyte *mask)
{
    const GLchan *color = (const GLchan *)value;
    LPDWORD lpdw;
    DWORD pixel;
    GLuint i;
    WMesaFramebuffer pwfb = wmesa_framebuffer(ctx->DrawBuffer);
    lpdw = ((LPDWORD)(pwfb->pbPixels + pwfb->ScanWidth * y)) + x;
    y=FLIP(y);
    pixel = BGR32(color[RCOMP], color[GCOMP], color[BCOMP]);
    if (mask) {
	for (i=0; i<n; i++)
	    if (mask[i])
                lpdw[i] = pixel;
    }
    else
	for (i=0; i<n; i++)
                *lpdw++ = pixel;

}

/* Write an array of RGBA pixels with a boolean mask. */
static void write_rgba_pixels_32(struct gl_context *ctx, 
				 struct gl_renderbuffer *rb,
				 GLuint n, const GLint x[], const GLint y[],
				 const void *values, 
				 const GLubyte *mask)
{
    const GLubyte (*rgba)[4] = (const GLubyte (*)[4])values;
    GLuint i;
    WMesaFramebuffer pwfb = wmesa_framebuffer(ctx->DrawBuffer);
    for (i=0; i<n; i++)
	if (mask[i])
	    WMSETPIXEL32(pwfb, FLIP(y[i]), x[i],
			 rgba[i][RCOMP], rgba[i][GCOMP], rgba[i][BCOMP]);
}

/*
 * Write an array of pixels with a boolean mask.  The current color
 * is used for all pixels.
 */
static void write_mono_rgba_pixels_32(struct gl_context *ctx, 
				      struct gl_renderbuffer *rb,
				      GLuint n,
				      const GLint x[], const GLint y[],
				      const void *value,
				      const GLubyte *mask)
{
    const GLchan *color = (const GLchan *)value;
    GLuint i;
    WMesaFramebuffer pwfb = wmesa_framebuffer(ctx->DrawBuffer);
    for (i=0; i<n; i++)
	if (mask[i])
	    WMSETPIXEL32(pwfb, FLIP(y[i]),x[i],color[RCOMP],
			 color[GCOMP], color[BCOMP]);
}

/* Read a horizontal span of color pixels. */
static void read_rgba_span_32(struct gl_context *ctx, 
			      struct gl_renderbuffer *rb,
			      GLuint n, GLint x, GLint y,
			      void *values)
{
    GLubyte (*rgba)[4] = (GLubyte (*)[4])values;
    GLuint i;
    DWORD pixel;
    LPDWORD lpdw;
    WMesaFramebuffer pwfb = wmesa_framebuffer(ctx->DrawBuffer);
    
    y = FLIP(y);
    lpdw = ((LPDWORD)(pwfb->pbPixels + pwfb->ScanWidth * y)) + x;
    for (i=0; i<n; i++) {
	pixel = lpdw[i];
	rgba[i][RCOMP] = (GLubyte)((pixel & 0x00ff0000) >> 16);
	rgba[i][GCOMP] = (GLubyte)((pixel & 0x0000ff00) >> 8);
	rgba[i][BCOMP] = (GLubyte)(pixel & 0x000000ff);
	rgba[i][ACOMP] = 255;
    }
}


/* Read an array of color pixels. */
static void read_rgba_pixels_32(struct gl_context *ctx, 
				struct gl_renderbuffer *rb,
				GLuint n, const GLint x[], const GLint y[],
				void *values)
{
    GLubyte (*rgba)[4] = (GLubyte (*)[4])values;
    GLuint i;
    DWORD pixel;
    LPDWORD lpdw;
    WMesaFramebuffer pwfb = wmesa_framebuffer(ctx->DrawBuffer);

    for (i=0; i<n; i++) {
	GLint y2 = FLIP(y[i]);
	lpdw = ((LPDWORD)(pwfb->pbPixels + pwfb->ScanWidth * y2)) + x[i];
	pixel = *lpdw;
	rgba[i][RCOMP] = (GLubyte)((pixel & 0x00ff0000) >> 16);
	rgba[i][GCOMP] = (GLubyte)((pixel & 0x0000ff00) >> 8);
	rgba[i][BCOMP] = (GLubyte)(pixel & 0x000000ff);
	rgba[i][ACOMP] = 255;
  }
}


/*********************************************************************/

/* DOUBLE BUFFER 24-bit */

#define WMSETPIXEL24(pwc, y, x, r, g, b) { \
LPBYTE lpb = ((LPBYTE)((pwc)->pbPixels + (pwc)->ScanWidth * (y)) + (3 * x)); \
lpb[0] = (b); \
lpb[1] = (g); \
lpb[2] = (r); }

/* Write a horizontal span of RGBA color pixels with a boolean mask. */
static void write_rgba_span_24(struct gl_context *ctx, 
			       struct gl_renderbuffer *rb, 
			       GLuint n, GLint x, GLint y,
			       const void *values, 
			       const GLubyte *mask)
{
    const GLubyte (*rgba)[4] = (const GLubyte (*)[4])values;
    WMesaFramebuffer pwfb = wmesa_framebuffer(ctx->DrawBuffer);
    GLuint i;
    LPBYTE lpb;

    (void) ctx;
    
    y=FLIP(y);
    lpb = ((LPBYTE)(pwfb->pbPixels + pwfb->ScanWidth * y)) + (3 * x);
    if (mask) {
	for (i=0; i<n; i++)
	    if (mask[i]) {
                lpb[3*i] = rgba[i][BCOMP];
                lpb[3*i+1] = rgba[i][GCOMP];
                lpb[3*i+2] = rgba[i][RCOMP];
	    }
    }
    else {
	    for (i=0; i<n; i++) {
            *lpb++ = rgba[i][BCOMP];
            *lpb++ = rgba[i][GCOMP];
            *lpb++ = rgba[i][RCOMP];
	    }
    }
}


/* Write a horizontal span of RGB color pixels with a boolean mask. */
static void write_rgb_span_24(struct gl_context *ctx, 
			      struct gl_renderbuffer *rb, 
			      GLuint n, GLint x, GLint y,
			      const void *values, 
			      const GLubyte *mask)
{
    const GLubyte (*rgb)[3] = (const GLubyte (*)[3])values;
    WMesaFramebuffer pwfb = wmesa_framebuffer(ctx->DrawBuffer);
    GLuint i;
    LPBYTE lpb;

    (void) ctx;
    
    y=FLIP(y);
    lpb = ((LPBYTE)(pwfb->pbPixels + pwfb->ScanWidth * y)) + (3 * x);
    if (mask) {
	for (i=0; i<n; i++)
	    if (mask[i]) {
            lpb[3*i] = rgb[i][BCOMP];
            lpb[3*i+1] = rgb[i][GCOMP];
            lpb[3*i+2] = rgb[i][RCOMP];
	    }
    }
    else {
    	for (i=0; i<n; i++) {
    		*lpb++ = rgb[i][BCOMP];
    		*lpb++ = rgb[i][GCOMP];
    		*lpb++ = rgb[i][RCOMP];
    	}
    }
}

/*
 * Write a horizontal span of pixels with a boolean mask.  The current color
 * is used for all pixels.
 */
static void write_mono_rgba_span_24(struct gl_context *ctx, 
				    struct gl_renderbuffer *rb,
				    GLuint n, GLint x, GLint y,
				    const void *value, 
				    const GLubyte *mask)
{
    const GLchan *color = (const GLchan *)value;
    LPBYTE lpb;
    GLuint i;
    WMesaFramebuffer pwfb = wmesa_framebuffer(ctx->DrawBuffer);
    lpb = ((LPBYTE)(pwfb->pbPixels + pwfb->ScanWidth * y)) + (3 * x);
    y=FLIP(y);
    if (mask) {
	for (i=0; i<n; i++)
	    if (mask[i]) {
	    	lpb[3*i] = color[BCOMP];
	    	lpb[3*i+1] = color[GCOMP];
	    	lpb[3*i+2] = color[RCOMP];
	    }
    }
    else
	for (i=0; i<n; i++) {
		*lpb++ = color[BCOMP];
		*lpb++ = color[GCOMP];
		*lpb++ = color[RCOMP];		
	}
}

/* Write an array of RGBA pixels with a boolean mask. */
static void write_rgba_pixels_24(struct gl_context *ctx, 
				 struct gl_renderbuffer *rb,
				 GLuint n, const GLint x[], const GLint y[],
				 const void *values, 
				 const GLubyte *mask)
{
    const GLubyte (*rgba)[4] = (const GLubyte (*)[4])values;
    GLuint i;
    WMesaFramebuffer pwfb = wmesa_framebuffer(ctx->DrawBuffer);
    for (i=0; i<n; i++)
	if (mask[i])
	    WMSETPIXEL24(pwfb, FLIP(y[i]), x[i],
			 rgba[i][RCOMP], rgba[i][GCOMP], rgba[i][BCOMP]);
}

/*
 * Write an array of pixels with a boolean mask.  The current color
 * is used for all pixels.
 */
static void write_mono_rgba_pixels_24(struct gl_context *ctx, 
				      struct gl_renderbuffer *rb,
				      GLuint n,
				      const GLint x[], const GLint y[],
				      const void *value,
				      const GLubyte *mask)
{
    const GLchan *color = (const GLchan *)value;
    GLuint i;
    WMesaFramebuffer pwfb = wmesa_framebuffer(ctx->DrawBuffer);
    for (i=0; i<n; i++)
	if (mask[i])
	    WMSETPIXEL24(pwfb, FLIP(y[i]),x[i],color[RCOMP],
			 color[GCOMP], color[BCOMP]);
}

/* Read a horizontal span of color pixels. */
static void read_rgba_span_24(struct gl_context *ctx, 
			      struct gl_renderbuffer *rb,
			      GLuint n, GLint x, GLint y,
			      void *values)
{
    GLubyte (*rgba)[4] = (GLubyte (*)[4])values;
    GLuint i;
    LPBYTE lpb;
    WMesaFramebuffer pwfb = wmesa_framebuffer(ctx->DrawBuffer);
    
    y = FLIP(y);
    lpb = ((LPBYTE)(pwfb->pbPixels + pwfb->ScanWidth * y)) + (3 * x);
    for (i=0; i<n; i++) {
	rgba[i][RCOMP] = lpb[3*i+2];
	rgba[i][GCOMP] = lpb[3*i+1];
	rgba[i][BCOMP] = lpb[3*i];
	rgba[i][ACOMP] = 255;
    }
}


/* Read an array of color pixels. */
static void read_rgba_pixels_24(struct gl_context *ctx, 
				struct gl_renderbuffer *rb,
				GLuint n, const GLint x[], const GLint y[],
				void *values)
{
    GLubyte (*rgba)[4] = (GLubyte (*)[4])values;
    GLuint i;
    LPBYTE lpb;
    WMesaFramebuffer pwfb = wmesa_framebuffer(ctx->DrawBuffer);

    for (i=0; i<n; i++) {
	GLint y2 = FLIP(y[i]);
	lpb = ((LPBYTE)(pwfb->pbPixels + pwfb->ScanWidth * y2)) + (3 * x[i]);
	rgba[i][RCOMP] = lpb[3*i+2];
	rgba[i][GCOMP] = lpb[3*i+1];
	rgba[i][BCOMP] = lpb[3*i];
	rgba[i][ACOMP] = 255;
  }
}


/*********************************************************************/

/* DOUBLE BUFFER 16-bit */

#define WMSETPIXEL16(pwc, y, x, r, g, b) { \
LPWORD lpw = ((LPWORD)((pwc)->pbPixels + (pwc)->ScanWidth * (y)) + (x)); \
*lpw = BGR16((r),(g),(b)); }



/* Write a horizontal span of RGBA color pixels with a boolean mask. */
static void write_rgba_span_16(struct gl_context *ctx, 
			       struct gl_renderbuffer *rb, 
			       GLuint n, GLint x, GLint y,
			       const void *values, 
			       const GLubyte *mask)
{
    const GLubyte (*rgba)[4] = (const GLubyte (*)[4])values;
    WMesaFramebuffer pwfb = wmesa_framebuffer(ctx->DrawBuffer);
    GLuint i;
    LPWORD lpw;

    (void) ctx;
    
    y=FLIP(y);
    lpw = ((LPWORD)(pwfb->pbPixels + pwfb->ScanWidth * y)) + x;
    if (mask) {
	for (i=0; i<n; i++)
	    if (mask[i])
                lpw[i] = BGR16(rgba[i][RCOMP], rgba[i][GCOMP], 
			       rgba[i][BCOMP]);
    }
    else {
	for (i=0; i<n; i++)
                *lpw++ = BGR16(rgba[i][RCOMP], rgba[i][GCOMP], 
			       rgba[i][BCOMP]);
    }
}


/* Write a horizontal span of RGB color pixels with a boolean mask. */
static void write_rgb_span_16(struct gl_context *ctx, 
			      struct gl_renderbuffer *rb, 
			      GLuint n, GLint x, GLint y,
			      const void *values, 
			      const GLubyte *mask)
{
    const GLubyte (*rgb)[3] = (const GLubyte (*)[3])values;
    WMesaFramebuffer pwfb = wmesa_framebuffer(ctx->DrawBuffer);
    GLuint i;
    LPWORD lpw;

    (void) ctx;
    
    y=FLIP(y);
    lpw = ((LPWORD)(pwfb->pbPixels + pwfb->ScanWidth * y)) + x;
    if (mask) {
	for (i=0; i<n; i++)
	    if (mask[i])
                lpw[i] = BGR16(rgb[i][RCOMP], rgb[i][GCOMP], 
			       rgb[i][BCOMP]);
    }
    else {
	for (i=0; i<n; i++)
                *lpw++ = BGR16(rgb[i][RCOMP], rgb[i][GCOMP], 
			       rgb[i][BCOMP]);
    }
}

/*
 * Write a horizontal span of pixels with a boolean mask.  The current color
 * is used for all pixels.
 */
static void write_mono_rgba_span_16(struct gl_context *ctx, 
				    struct gl_renderbuffer *rb,
				    GLuint n, GLint x, GLint y,
				    const void *value, 
				    const GLubyte *mask)
{
    const GLchan *color = (const GLchan *)value;
    LPWORD lpw;
    WORD pixel;
    GLuint i;
    WMesaFramebuffer pwfb = wmesa_framebuffer(ctx->DrawBuffer);
    (void) ctx;
    lpw = ((LPWORD)(pwfb->pbPixels + pwfb->ScanWidth * y)) + x;
    y=FLIP(y);
    pixel = BGR16(color[RCOMP], color[GCOMP], color[BCOMP]);
    if (mask) {
	for (i=0; i<n; i++)
	    if (mask[i])
                lpw[i] = pixel;
    }
    else
	for (i=0; i<n; i++)
                *lpw++ = pixel;

}

/* Write an array of RGBA pixels with a boolean mask. */
static void write_rgba_pixels_16(struct gl_context *ctx, 
				 struct gl_renderbuffer *rb,
				 GLuint n, const GLint x[], const GLint y[],
				 const void *values, 
				 const GLubyte *mask)
{
    const GLubyte (*rgba)[4] = (const GLubyte (*)[4])values;
    GLuint i;
    WMesaFramebuffer pwfb = wmesa_framebuffer(ctx->DrawBuffer);
    (void) ctx;
    for (i=0; i<n; i++)
	if (mask[i])
	    WMSETPIXEL16(pwfb, FLIP(y[i]), x[i],
			 rgba[i][RCOMP], rgba[i][GCOMP], rgba[i][BCOMP]);
}

/*
 * Write an array of pixels with a boolean mask.  The current color
 * is used for all pixels.
 */
static void write_mono_rgba_pixels_16(struct gl_context *ctx, 
				      struct gl_renderbuffer *rb,
				      GLuint n,
				      const GLint x[], const GLint y[],
				      const void *value,
				      const GLubyte *mask)
{
    const GLchan *color = (const GLchan *)value;
    GLuint i;
    WMesaFramebuffer pwfb = wmesa_framebuffer(ctx->DrawBuffer);
    (void) ctx;
    for (i=0; i<n; i++)
	if (mask[i])
	    WMSETPIXEL16(pwfb, FLIP(y[i]),x[i],color[RCOMP],
			 color[GCOMP], color[BCOMP]);
}

/* Read a horizontal span of color pixels. */
static void read_rgba_span_16(struct gl_context *ctx, 
			      struct gl_renderbuffer *rb,
			      GLuint n, GLint x, GLint y,
			      void *values)
{
    GLubyte (*rgba)[4] = (GLubyte (*)[4])values;
    GLuint i, pixel;
    LPWORD lpw;
    WMesaFramebuffer pwfb = wmesa_framebuffer(ctx->DrawBuffer);
    
    y = FLIP(y);
    lpw = ((LPWORD)(pwfb->pbPixels + pwfb->ScanWidth * y)) + x;
    for (i=0; i<n; i++) {
	pixel = lpw[i];
	/* Windows uses 5,5,5 for 16-bit */
	rgba[i][RCOMP] = (pixel & 0x7c00) >> 7;
	rgba[i][GCOMP] = (pixel & 0x03e0) >> 2;
	rgba[i][BCOMP] = (pixel & 0x001f) << 3;
	rgba[i][ACOMP] = 255;
    }
}


/* Read an array of color pixels. */
static void read_rgba_pixels_16(struct gl_context *ctx, 
				struct gl_renderbuffer *rb,
				GLuint n, const GLint x[], const GLint y[],
				void *values)
{
    GLubyte (*rgba)[4] = (GLubyte (*)[4])values;
    GLuint i, pixel;
    LPWORD lpw;
    WMesaFramebuffer pwfb = wmesa_framebuffer(ctx->DrawBuffer);

    for (i=0; i<n; i++) {
	GLint y2 = FLIP(y[i]);
	lpw = ((LPWORD)(pwfb->pbPixels + pwfb->ScanWidth * y2)) + x[i];
	pixel = *lpw;
	/* Windows uses 5,5,5 for 16-bit */
	rgba[i][RCOMP] = (pixel & 0x7c00) >> 7;
	rgba[i][GCOMP] = (pixel & 0x03e0) >> 2;
	rgba[i][BCOMP] = (pixel & 0x001f) << 3;
	rgba[i][ACOMP] = 255;
  }
}



d432 1
a432 1
wmesa_delete_renderbuffer(struct gl_renderbuffer *rb)
d434 1
a434 1
    free(rb);
a455 60
 * Plug in the Get/PutRow/Values functions for a renderbuffer depending
 * on if we're drawing to the front or back color buffer.
 */
static void
wmesa_set_renderbuffer_funcs(struct gl_renderbuffer *rb, int pixelformat,
                             int cColorBits, int double_buffer)
{
    if (double_buffer) {
        /* back buffer */
	/* Picking the correct span functions is important because
	 * the DIB was allocated with the indicated depth. */
	switch(pixelformat) {
	case PF_5R6G5B:
	    rb->PutRow = write_rgba_span_16;
	    rb->PutRowRGB = write_rgb_span_16;
	    rb->PutMonoRow = write_mono_rgba_span_16;
	    rb->PutValues = write_rgba_pixels_16;
	    rb->PutMonoValues = write_mono_rgba_pixels_16;
	    rb->GetRow = read_rgba_span_16;
	    rb->GetValues = read_rgba_pixels_16;
	    break;
	case PF_8R8G8B:
		if (cColorBits == 24)
		{
		    rb->PutRow = write_rgba_span_24;
		    rb->PutRowRGB = write_rgb_span_24;
		    rb->PutMonoRow = write_mono_rgba_span_24;
		    rb->PutValues = write_rgba_pixels_24;
		    rb->PutMonoValues = write_mono_rgba_pixels_24;
		    rb->GetRow = read_rgba_span_24;
		    rb->GetValues = read_rgba_pixels_24;
		}
		else
		{
	        rb->PutRow = write_rgba_span_32;
	        rb->PutRowRGB = write_rgb_span_32;
	        rb->PutMonoRow = write_mono_rgba_span_32;
	        rb->PutValues = write_rgba_pixels_32;
	        rb->PutMonoValues = write_mono_rgba_pixels_32;
	        rb->GetRow = read_rgba_span_32;
	        rb->GetValues = read_rgba_pixels_32;
		}
	    break;
	default:
	    break;
	}
    }
    else {
        /* front buffer (actual Windows window) */
	rb->PutRow = write_rgba_span_front;
	rb->PutRowRGB = write_rgb_span_front;
	rb->PutMonoRow = write_mono_rgba_span_front;
	rb->PutValues = write_rgba_pixels_front;
	rb->PutMonoValues = write_mono_rgba_pixels_front;
	rb->GetRow = read_rgba_span_front;
	rb->GetValues = read_rgba_pixels_front;
    }
}

/**
a607 1
    functions.GetBufferSize = wmesa_get_buffer_size;
a609 1
    functions.ClearColor = clear_color;
d615 2
a616 2
    _mesa_initialize_context(ctx, API_OPENGL, visual,
                             NULL, &functions, (void *)c);
a621 5
    _mesa_enable_1_3_extensions(ctx);
    _mesa_enable_1_4_extensions(ctx);
    _mesa_enable_1_5_extensions(ctx);
    _mesa_enable_2_0_extensions(ctx);
    _mesa_enable_2_1_extensions(ctx);
d637 6
a699 1
    rb->DataType = CHAN_TYPE;
a741 1
            wmesa_set_renderbuffer_funcs(rb, pwfb->pixelformat, pwfb->cColorBits, 1);
a744 1
        wmesa_set_renderbuffer_funcs(rb, pwfb->pixelformat, pwfb->cColorBits, 0);
d747 7
a753 7
        _mesa_add_soft_renderbuffers(&pwfb->Base,
                                     GL_FALSE, /* color */
                                     visual->depthBits > 0,
                                     visual->stencilBits > 0,
                                     visual->accumRedBits > 0,
                                     visual->alphaBits >0, 
                                     GL_FALSE);
@


1.7
log
@Merge Mesa 7.10.3
@
text
@d8 1
a8 1
#include <GL/wmesa.h>
d10 5
a14 4
#include "context.h"
#include "extensions.h"
#include "framebuffer.h"
#include "renderbuffer.h"
d33 1
a33 1
WMesaFramebuffer
d51 1
a51 1
void
d74 1
a74 1
WMesaFramebuffer
d150 1
a150 1
BOOL wmCreateBackingStore(WMesaFramebuffer pwfb, long lxSize, long lySize)
a151 1
    HDC          hdc = pwfb->hDC;
d188 1
a188 1
static wmDeleteBackingStore(WMesaFramebuffer pwfb)
a228 1
    WMesaContext pwc = wmesa_context(ctx);
a254 1
    WMesaFramebuffer pwfb = wmesa_framebuffer(ctx->DrawBuffer);
a255 1
    UINT    bytesPerPixel = pwfb->cColorBits / 8; 
d447 5
a451 5
static void write_rgba_span_front(const struct gl_context *ctx, 
				   struct gl_renderbuffer *rb, 
				   GLuint n, GLint x, GLint y,
				   const GLubyte rgba[][4], 
				   const GLubyte mask[] )
d453 1
a455 7
   CONST BITMAPINFO bmi=
   {
      {
         sizeof(BITMAPINFOHEADER),
         n, 1, 1, 32, BI_RGB, 0, 1, 1, 0, 0
      }
   };
d528 5
a532 5
static void write_rgb_span_front(const struct gl_context *ctx, 
				  struct gl_renderbuffer *rb, 
				  GLuint n, GLint x, GLint y,
				  const GLubyte rgb[][3], 
				  const GLubyte mask[] )
d534 1
d558 5
a562 5
static void write_mono_rgba_span_front(const struct gl_context *ctx, 
					struct gl_renderbuffer *rb,
					GLuint n, GLint x, GLint y,
					const GLchan color[4], 
					const GLubyte mask[])
d564 1
d584 6
a589 6
static void write_rgba_pixels_front(const struct gl_context *ctx, 
				     struct gl_renderbuffer *rb,
				     GLuint n, 
				     const GLint x[], const GLint y[],
				     const GLubyte rgba[][4], 
				     const GLubyte mask[] )
d591 1
d608 6
a613 6
static void write_mono_rgba_pixels_front(const struct gl_context *ctx, 
					  struct gl_renderbuffer *rb,
					  GLuint n,
					  const GLint x[], const GLint y[],
					  const GLchan color[4],
					  const GLubyte mask[] )
d615 1
d627 4
a630 4
static void read_rgba_span_front(const struct gl_context *ctx, 
				  struct gl_renderbuffer *rb,
				  GLuint n, GLint x, GLint y,
				  GLubyte rgba[][4] )
d632 1
d648 4
a651 4
static void read_rgba_pixels_front(const struct gl_context *ctx, 
				    struct gl_renderbuffer *rb,
				    GLuint n, const GLint x[], const GLint y[],
				    GLubyte rgba[][4])
d653 1
d678 1
a678 1
static void write_rgba_span_32(const struct gl_context *ctx, 
d681 2
a682 2
			       const GLubyte rgba[][4], 
			       const GLubyte mask[] )
d684 1
a684 1
    WMesaContext pwc = wmesa_context(ctx);
d708 1
a708 1
static void write_rgb_span_32(const struct gl_context *ctx, 
d711 2
a712 2
			      const GLubyte rgb[][3], 
			      const GLubyte mask[] )
d714 1
a714 1
    WMesaContext pwc = wmesa_context(ctx);
d740 1
a740 1
static void write_mono_rgba_span_32(const struct gl_context *ctx, 
d743 2
a744 2
				    const GLchan color[4], 
				    const GLubyte mask[])
d746 1
a749 1
    WMesaContext pwc = wmesa_context(ctx);
d766 1
a766 1
static void write_rgba_pixels_32(const struct gl_context *ctx, 
d769 2
a770 2
				 const GLubyte rgba[][4], 
				 const GLubyte mask[])
d772 1
a773 1
    WMesaContext pwc = wmesa_context(ctx);
d785 1
a785 1
static void write_mono_rgba_pixels_32(const struct gl_context *ctx, 
d789 2
a790 2
				      const GLchan color[4],
				      const GLubyte mask[])
d792 1
a793 1
    WMesaContext pwc = wmesa_context(ctx);
d802 1
a802 1
static void read_rgba_span_32(const struct gl_context *ctx, 
d805 1
a805 1
			      GLubyte rgba[][4] )
d807 1
a810 1
    WMesaContext pwc = wmesa_context(ctx);
d826 1
a826 1
static void read_rgba_pixels_32(const struct gl_context *ctx, 
d829 1
a829 1
				GLubyte rgba[][4])
d831 1
a834 1
    WMesaContext pwc = wmesa_context(ctx);
d860 1
a860 1
static void write_rgba_span_24(const struct gl_context *ctx, 
d863 2
a864 2
			       const GLubyte rgba[][4], 
			       const GLubyte mask[] )
d866 1
a866 1
    WMesaContext pwc = wmesa_context(ctx);
d894 1
a894 1
static void write_rgb_span_24(const struct gl_context *ctx, 
d897 2
a898 2
			      const GLubyte rgb[][3], 
			      const GLubyte mask[] )
d900 1
a900 1
    WMesaContext pwc = wmesa_context(ctx);
d930 1
a930 1
static void write_mono_rgba_span_24(const struct gl_context *ctx, 
d933 2
a934 2
				    const GLchan color[4], 
				    const GLubyte mask[])
d936 1
a938 1
    WMesaContext pwc = wmesa_context(ctx);
d959 1
a959 1
static void write_rgba_pixels_24(const struct gl_context *ctx, 
d962 2
a963 2
				 const GLubyte rgba[][4], 
				 const GLubyte mask[])
d965 1
a966 1
    WMesaContext pwc = wmesa_context(ctx);
d978 1
a978 1
static void write_mono_rgba_pixels_24(const struct gl_context *ctx, 
d982 2
a983 2
				      const GLchan color[4],
				      const GLubyte mask[])
d985 1
a986 1
    WMesaContext pwc = wmesa_context(ctx);
d995 1
a995 1
static void read_rgba_span_24(const struct gl_context *ctx, 
d998 1
a998 1
			      GLubyte rgba[][4] )
d1000 1
a1002 1
    WMesaContext pwc = wmesa_context(ctx);
d1017 1
a1017 1
static void read_rgba_pixels_24(const struct gl_context *ctx, 
d1020 1
a1020 1
				GLubyte rgba[][4])
d1022 1
a1024 1
    WMesaContext pwc = wmesa_context(ctx);
d1049 1
a1049 1
static void write_rgba_span_16(const struct gl_context *ctx, 
d1052 2
a1053 2
			       const GLubyte rgba[][4], 
			       const GLubyte mask[] )
d1055 1
a1055 1
    WMesaContext pwc = wmesa_context(ctx);
d1079 1
a1079 1
static void write_rgb_span_16(const struct gl_context *ctx, 
d1082 2
a1083 2
			      const GLubyte rgb[][3], 
			      const GLubyte mask[] )
d1085 1
a1085 1
    WMesaContext pwc = wmesa_context(ctx);
d1111 1
a1111 1
static void write_mono_rgba_span_16(const struct gl_context *ctx, 
d1114 2
a1115 2
				    const GLchan color[4], 
				    const GLubyte mask[])
d1117 1
a1120 1
    WMesaContext pwc = wmesa_context(ctx);
d1138 1
a1138 1
static void write_rgba_pixels_16(const struct gl_context *ctx, 
d1141 2
a1142 2
				 const GLubyte rgba[][4], 
				 const GLubyte mask[])
d1144 1
a1145 1
    WMesaContext pwc = wmesa_context(ctx);
d1158 1
a1158 1
static void write_mono_rgba_pixels_16(const struct gl_context *ctx, 
d1162 2
a1163 2
				      const GLchan color[4],
				      const GLubyte mask[])
d1165 1
a1166 1
    WMesaContext pwc = wmesa_context(ctx);
d1176 1
a1176 1
static void read_rgba_span_16(const struct gl_context *ctx, 
d1179 1
a1179 1
			      GLubyte rgba[][4] )
d1181 1
a1183 1
    WMesaContext pwc = wmesa_context(ctx);
d1200 1
a1200 1
static void read_rgba_pixels_16(const struct gl_context *ctx, 
d1203 1
a1203 1
				GLubyte rgba[][4])
d1205 1
a1207 1
    WMesaContext pwc = wmesa_context(ctx);
d1260 3
a1262 2
void wmesa_set_renderbuffer_funcs(struct gl_renderbuffer *rb, int pixelformat,
                                  int cColorBits, int double_buffer)
a1323 1
    WMesaContext pwc = wmesa_context(ctx);
a1351 1
    WMesaContext pwc = wmesa_context(ctx);
d1478 2
a1479 1
    _mesa_initialize_context(ctx, visual, NULL, &functions, (void *)c);
d1551 1
a1551 1
struct gl_renderbuffer *
@


1.6
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d33 1
a33 1
wmesa_new_framebuffer(HDC hdc, GLvisual *visual)
d86 1
a86 1
 * Given a GLframebuffer, return the corresponding WMesaFramebuffer.
d88 1
a88 1
static WMesaFramebuffer wmesa_framebuffer(GLframebuffer *fb)
d95 1
a95 1
 * Given a GLcontext, return the corresponding WMesaContext.
d97 1
a97 1
static WMesaContext wmesa_context(const GLcontext *ctx)
d107 1
a107 1
static const GLubyte *wmesa_get_string(GLcontext *ctx, GLenum name)
d220 1
a220 1
wmesa_get_buffer_size(GLframebuffer *buffer, GLuint *width, GLuint *height)
d227 1
a227 1
static void wmesa_flush(GLcontext *ctx)
d253 1
a253 1
static void clear_color(GLcontext *ctx, const GLfloat color[4])
d280 1
a280 1
static void clear(GLcontext *ctx, GLbitfield mask)
d450 1
a450 1
static void write_rgba_span_front(const GLcontext *ctx, 
d537 1
a537 1
static void write_rgb_span_front(const GLcontext *ctx, 
d566 1
a566 1
static void write_mono_rgba_span_front(const GLcontext *ctx, 
d591 1
a591 1
static void write_rgba_pixels_front(const GLcontext *ctx, 
d614 1
a614 1
static void write_mono_rgba_pixels_front(const GLcontext *ctx, 
d632 1
a632 1
static void read_rgba_span_front(const GLcontext *ctx, 
d652 1
a652 1
static void read_rgba_pixels_front(const GLcontext *ctx, 
d681 1
a681 1
static void write_rgba_span_32(const GLcontext *ctx, 
d711 1
a711 1
static void write_rgb_span_32(const GLcontext *ctx, 
d743 1
a743 1
static void write_mono_rgba_span_32(const GLcontext *ctx, 
d769 1
a769 1
static void write_rgba_pixels_32(const GLcontext *ctx, 
d788 1
a788 1
static void write_mono_rgba_pixels_32(const GLcontext *ctx, 
d805 1
a805 1
static void read_rgba_span_32(const GLcontext *ctx, 
d829 1
a829 1
static void read_rgba_pixels_32(const GLcontext *ctx, 
d863 1
a863 1
static void write_rgba_span_24(const GLcontext *ctx, 
d897 1
a897 1
static void write_rgb_span_24(const GLcontext *ctx, 
d933 1
a933 1
static void write_mono_rgba_span_24(const GLcontext *ctx, 
d962 1
a962 1
static void write_rgba_pixels_24(const GLcontext *ctx, 
d981 1
a981 1
static void write_mono_rgba_pixels_24(const GLcontext *ctx, 
d998 1
a998 1
static void read_rgba_span_24(const GLcontext *ctx, 
d1020 1
a1020 1
static void read_rgba_pixels_24(const GLcontext *ctx, 
d1052 1
a1052 1
static void write_rgba_span_16(const GLcontext *ctx, 
d1082 1
a1082 1
static void write_rgb_span_16(const GLcontext *ctx, 
d1114 1
a1114 1
static void write_mono_rgba_span_16(const GLcontext *ctx, 
d1141 1
a1141 1
static void write_rgba_pixels_16(const GLcontext *ctx, 
d1161 1
a1161 1
static void write_mono_rgba_pixels_16(const GLcontext *ctx, 
d1179 1
a1179 1
static void read_rgba_span_16(const GLcontext *ctx, 
d1203 1
a1203 1
static void read_rgba_pixels_16(const GLcontext *ctx, 
d1247 1
a1247 1
wmesa_renderbuffer_storage(GLcontext *ctx, 
d1323 1
a1323 1
wmesa_resize_buffers(GLcontext *ctx, GLframebuffer *buffer,
d1351 1
a1351 1
static void wmesa_viewport(GLcontext *ctx, 
d1374 1
a1374 1
static void wmesa_update_state(GLcontext *ctx, GLuint new_state)
d1406 2
a1407 2
    GLcontext *ctx;
    GLvisual *visual;
d1514 1
a1514 1
    GLcontext *ctx = &pwc->gl_ctx;
d1589 1
a1589 1
        GLvisual *visual = &c->gl_ctx.Visual;
@


1.5
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d15 1
d38 1
a38 1
        _mesa_initialize_framebuffer(&pwfb->Base, visual);
d66 1
a66 1
        _mesa_unreference_framebuffer(&fb); 
a250 10
 * Set the color index used to clear the color buffer.
 */
static void clear_index(GLcontext *ctx, GLuint index)
{
    WMesaContext pwc = wmesa_context(ctx);
    /* Note that indexed mode is not supported yet */
    pwc->clearColorRef = RGB(0,0,0);
}

/*
d294 4
a297 4
    if (ctx->Color.ColorMask[0] != 0xff ||
	ctx->Color.ColorMask[1] != 0xff ||
	ctx->Color.ColorMask[2] != 0xff ||
	ctx->Color.ColorMask[3] != 0xff) {
d475 1
a475 1
   int i;
d820 3
a822 3
	rgba[i][RCOMP] = (pixel & 0x00ff0000) >> 16;
	rgba[i][GCOMP] = (pixel & 0x0000ff00) >> 8;
	rgba[i][BCOMP] = (pixel & 0x000000ff);
d844 3
a846 3
	rgba[i][RCOMP] = (pixel & 0x00ff0000) >> 16;
	rgba[i][GCOMP] = (pixel & 0x0000ff00) >> 8;
	rgba[i][BCOMP] = (pixel & 0x000000ff);
d1238 1
a1238 1
    _mesa_free(rb);
d1264 1
a1264 1
                                  BYTE cColorBits, int double_buffer)
a1278 3
            rb->RedBits = 5;
            rb->GreenBits = 6;
            rb->BlueBits = 5;
a1289 3
	        rb->RedBits = 8;
	        rb->GreenBits = 8;
	        rb->BlueBits = 8;		
a1299 3
            rb->RedBits = 8;
            rb->GreenBits = 8;
            rb->BlueBits = 8;
a1314 3
        rb->RedBits = 8; /* XXX fix these (565?) */
        rb->GreenBits = 8;
        rb->BlueBits = 8;
d1454 1
a1454 2
    visual = _mesa_create_visual(rgb_flag,
                                 db_flag,    /* db_flag */
a1457 1
                                 0,          /* index bits */
d1465 1
a1465 1
	_mesa_free(c);
a1475 1
    functions.ClearIndex = clear_index;
d1494 2
d1502 1
a1502 1
	_mesa_free(c);
d1539 2
d1547 1
a1547 1
    _mesa_free(pwc);
a1661 77
/* This is hopefully a temporary hack to define some needed dispatch
 * table entries.  Hopefully, I'll find a better solution.  The
 * dispatch table generation scripts ought to be making these dummy
 * stubs as well. */
#if !defined(__MINGW32__) || !defined(GL_NO_STDCALL)
void gl_dispatch_stub_543(void){}
void gl_dispatch_stub_544(void){}
void gl_dispatch_stub_545(void){}
void gl_dispatch_stub_546(void){}
void gl_dispatch_stub_547(void){}
void gl_dispatch_stub_548(void){}
void gl_dispatch_stub_549(void){}
void gl_dispatch_stub_550(void){}
void gl_dispatch_stub_551(void){}
void gl_dispatch_stub_552(void){}
void gl_dispatch_stub_553(void){}
void gl_dispatch_stub_554(void){}
void gl_dispatch_stub_555(void){}
void gl_dispatch_stub_556(void){}
void gl_dispatch_stub_557(void){}
void gl_dispatch_stub_558(void){}
void gl_dispatch_stub_559(void){}
void gl_dispatch_stub_560(void){}
void gl_dispatch_stub_561(void){}
void gl_dispatch_stub_565(void){}
void gl_dispatch_stub_566(void){}
void gl_dispatch_stub_577(void){}
void gl_dispatch_stub_578(void){}
void gl_dispatch_stub_603(void){}
void gl_dispatch_stub_645(void){}
void gl_dispatch_stub_646(void){}
void gl_dispatch_stub_647(void){}
void gl_dispatch_stub_648(void){}
void gl_dispatch_stub_649(void){}
void gl_dispatch_stub_650(void){}
void gl_dispatch_stub_651(void){}
void gl_dispatch_stub_652(void){}
void gl_dispatch_stub_653(void){}
void gl_dispatch_stub_733(void){}
void gl_dispatch_stub_734(void){}
void gl_dispatch_stub_735(void){}
void gl_dispatch_stub_736(void){}
void gl_dispatch_stub_737(void){}
void gl_dispatch_stub_738(void){}
void gl_dispatch_stub_744(void){}
void gl_dispatch_stub_745(void){}
void gl_dispatch_stub_746(void){}
void gl_dispatch_stub_760(void){}
void gl_dispatch_stub_761(void){}
void gl_dispatch_stub_763(void){}
void gl_dispatch_stub_765(void){}
void gl_dispatch_stub_766(void){}
void gl_dispatch_stub_767(void){}
void gl_dispatch_stub_768(void){}

void gl_dispatch_stub_562(void){}
void gl_dispatch_stub_563(void){}
void gl_dispatch_stub_564(void){}
void gl_dispatch_stub_567(void){}
void gl_dispatch_stub_568(void){}
void gl_dispatch_stub_569(void){}
void gl_dispatch_stub_580(void){}
void gl_dispatch_stub_581(void){}
void gl_dispatch_stub_606(void){}
void gl_dispatch_stub_654(void){}
void gl_dispatch_stub_655(void){}
void gl_dispatch_stub_656(void){}
void gl_dispatch_stub_739(void){}
void gl_dispatch_stub_740(void){}
void gl_dispatch_stub_741(void){}
void gl_dispatch_stub_748(void){}
void gl_dispatch_stub_749(void){}
void gl_dispatch_stub_769(void){}
void gl_dispatch_stub_770(void){}
void gl_dispatch_stub_771(void){}

#endif
@


1.4
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d59 1
d64 2
a65 1
	free(pwfb);
d1507 3
@


1.3
log
@Update to Mesa 7.0.3. tested my oga@@ and johan@@
@
text
@d121 1
d131 1
d861 189
d1271 1
a1271 1
                                  int double_buffer)
d1291 22
a1312 7
	    rb->PutRow = write_rgba_span_32;
	    rb->PutRowRGB = write_rgb_span_32;
	    rb->PutMonoRow = write_mono_rgba_span_32;
	    rb->PutValues = write_rgba_pixels_32;
	    rb->PutMonoValues = write_mono_rgba_pixels_32;
	    rb->GetRow = read_rgba_span_32;
	    rb->GetValues = read_rgba_pixels_32;
d1316 1
d1623 1
a1623 1
            wmesa_set_renderbuffer_funcs(rb, pwfb->pixelformat, 1);
d1627 1
a1627 1
        wmesa_set_renderbuffer_funcs(rb, pwfb->pixelformat, 0);
d1672 5
a1751 1
void gl_dispatch_stub_772(void){}
@


1.2
log
@Update to Mesa 7.0.2. Tested by naddy@@ (full ports build), simon@@
and oga@@ (with dri enabled).
@
text
@d1503 1
d1509 1
d1514 2
d1540 1
@


1.1
log
@Initial revision
@
text
@d9 1
d15 1
a15 1
#include "array_cache/acache.h"
d118 1
a118 1
    // Only 16 and 32 bit targets are supported now
d285 1
a285 5
static void clear(GLcontext *ctx, 
		  GLbitfield mask, 
		  GLboolean all, 
		  GLint x, GLint y, 
		  GLint width, GLint height) 
d288 4
d303 1
a303 1
	_swrast_Clear(ctx, mask, all, x, y, width, height); 
d322 2
a323 1
	if (all) { /* entire buffer */
d436 1
a436 1
	_swrast_Clear(ctx, mask, all, x, y, width, height); 
d461 78
a538 17
    WMesaContext pwc = wmesa_context(ctx);
    GLuint i;
    
    (void) ctx;
    y=FLIP(y);
    if (mask) {
	for (i=0; i<n; i++)
	    if (mask[i])
		SetPixel(pwc->hDC, x+i, y, RGB(rgba[i][RCOMP], rgba[i][GCOMP], 
					       rgba[i][BCOMP]));
    }
    else {
	for (i=0; i<n; i++)
	    SetPixel(pwc->hDC, x+i, y, RGB(rgba[i][RCOMP], rgba[i][GCOMP], 
					   rgba[i][BCOMP]));
    }
    
d1190 1
a1190 1
    _ac_InvalidateState(ctx, new_state);
d1236 1
a1236 1
	c->hDC = GetDC(WindowFromDC(hDC)); // huh ????
d1304 1
d1308 1
a1308 1
        !_ac_CreateContext(ctx) ||
d1351 1
a1351 1
    _ac_DestroyContext(ctx);
d1469 69
a1537 45
void gl_dispatch_stub_543(void){};
void gl_dispatch_stub_544(void){};
void gl_dispatch_stub_545(void){};
void gl_dispatch_stub_546(void){};
void gl_dispatch_stub_547(void){};
void gl_dispatch_stub_548(void){};
void gl_dispatch_stub_549(void){};
void gl_dispatch_stub_550(void){};
void gl_dispatch_stub_551(void){};
void gl_dispatch_stub_552(void){};
void gl_dispatch_stub_553(void){};
void gl_dispatch_stub_554(void){};
void gl_dispatch_stub_555(void){};
void gl_dispatch_stub_556(void){};
void gl_dispatch_stub_557(void){};
void gl_dispatch_stub_558(void){};
void gl_dispatch_stub_559(void){};
void gl_dispatch_stub_560(void){};
void gl_dispatch_stub_561(void){};
void gl_dispatch_stub_565(void){};
void gl_dispatch_stub_566(void){};
void gl_dispatch_stub_577(void){};
void gl_dispatch_stub_578(void){};
void gl_dispatch_stub_603(void){};
void gl_dispatch_stub_645(void){};
void gl_dispatch_stub_646(void){};
void gl_dispatch_stub_647(void){};
void gl_dispatch_stub_648(void){};
void gl_dispatch_stub_649(void){};
void gl_dispatch_stub_650(void){};
void gl_dispatch_stub_651(void){};
void gl_dispatch_stub_652(void){};
void gl_dispatch_stub_653(void){};
void gl_dispatch_stub_734(void){};
void gl_dispatch_stub_735(void){};
void gl_dispatch_stub_736(void){};
void gl_dispatch_stub_737(void){};
void gl_dispatch_stub_738(void){};
void gl_dispatch_stub_745(void){};
void gl_dispatch_stub_746(void){};
void gl_dispatch_stub_760(void){};
void gl_dispatch_stub_761(void){};
void gl_dispatch_stub_766(void){};
void gl_dispatch_stub_767(void){};
void gl_dispatch_stub_768(void){};
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d284 5
a288 1
static void clear(GLcontext *ctx, GLbitfield mask)
a290 4
    const GLint x = ctx->DrawBuffer->_Xmin;
    const GLint y = ctx->DrawBuffer->_Ymin;
    const GLint height = ctx->DrawBuffer->_Ymax - ctx->DrawBuffer->_Ymin;
    const GLint width  = ctx->DrawBuffer->_Xmax - ctx->DrawBuffer->_Xmin;
d302 1
a302 1
	_swrast_Clear(ctx, mask);
d321 1
a321 2
	if (width == ctx->DrawBuffer->Width &&
            height == ctx->DrawBuffer->Height) { /* entire buffer */
d434 1
a434 1
	_swrast_Clear(ctx, mask);
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@a8 1
#include <winuser.h>
d14 1
a14 1
#include "vbo/vbo.h"
d117 1
a117 1
    /* Only 16 and 32 bit targets are supported now */
d1128 1
a1128 1
    _vbo_InvalidateState(ctx, new_state);
d1174 1
a1174 1
	c->hDC = GetDC(WindowFromDC(hDC)); /* huh ???? */
a1241 1
    _mesa_enable_2_1_extensions(ctx);
d1245 1
a1245 1
        !_vbo_CreateContext(ctx) ||
d1288 1
a1288 1
    _vbo_DestroyContext(ctx);
d1406 45
a1450 69
#if !defined(__MINGW32__) || !defined(GL_NO_STDCALL)
void gl_dispatch_stub_543(void){}
void gl_dispatch_stub_544(void){}
void gl_dispatch_stub_545(void){}
void gl_dispatch_stub_546(void){}
void gl_dispatch_stub_547(void){}
void gl_dispatch_stub_548(void){}
void gl_dispatch_stub_549(void){}
void gl_dispatch_stub_550(void){}
void gl_dispatch_stub_551(void){}
void gl_dispatch_stub_552(void){}
void gl_dispatch_stub_553(void){}
void gl_dispatch_stub_554(void){}
void gl_dispatch_stub_555(void){}
void gl_dispatch_stub_556(void){}
void gl_dispatch_stub_557(void){}
void gl_dispatch_stub_558(void){}
void gl_dispatch_stub_559(void){}
void gl_dispatch_stub_560(void){}
void gl_dispatch_stub_561(void){}
void gl_dispatch_stub_565(void){}
void gl_dispatch_stub_566(void){}
void gl_dispatch_stub_577(void){}
void gl_dispatch_stub_578(void){}
void gl_dispatch_stub_603(void){}
void gl_dispatch_stub_645(void){}
void gl_dispatch_stub_646(void){}
void gl_dispatch_stub_647(void){}
void gl_dispatch_stub_648(void){}
void gl_dispatch_stub_649(void){}
void gl_dispatch_stub_650(void){}
void gl_dispatch_stub_651(void){}
void gl_dispatch_stub_652(void){}
void gl_dispatch_stub_653(void){}
void gl_dispatch_stub_734(void){}
void gl_dispatch_stub_735(void){}
void gl_dispatch_stub_736(void){}
void gl_dispatch_stub_737(void){}
void gl_dispatch_stub_738(void){}
void gl_dispatch_stub_745(void){}
void gl_dispatch_stub_746(void){}
void gl_dispatch_stub_760(void){}
void gl_dispatch_stub_761(void){}
void gl_dispatch_stub_766(void){}
void gl_dispatch_stub_767(void){}
void gl_dispatch_stub_768(void){}

void gl_dispatch_stub_562(void){}
void gl_dispatch_stub_563(void){}
void gl_dispatch_stub_564(void){}
void gl_dispatch_stub_567(void){}
void gl_dispatch_stub_568(void){}
void gl_dispatch_stub_569(void){}
void gl_dispatch_stub_580(void){}
void gl_dispatch_stub_581(void){}
void gl_dispatch_stub_606(void){}
void gl_dispatch_stub_654(void){}
void gl_dispatch_stub_655(void){}
void gl_dispatch_stub_656(void){}
void gl_dispatch_stub_739(void){}
void gl_dispatch_stub_740(void){}
void gl_dispatch_stub_741(void){}
void gl_dispatch_stub_748(void){}
void gl_dispatch_stub_749(void){}
void gl_dispatch_stub_769(void){}
void gl_dispatch_stub_770(void){}
void gl_dispatch_stub_771(void){}

#endif
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@a14 1
#include "drivers/common/meta.h"
d32 1
a32 1
wmesa_new_framebuffer(HDC hdc, struct gl_config *visual)
d37 1
a37 1
        _mesa_initialize_window_framebuffer(&pwfb->Base, visual);
a58 1
        struct gl_framebuffer *fb;
d63 1
a63 2
        fb = &pwfb->Base;
        _mesa_reference_framebuffer(&fb, NULL); 
d83 1
a83 1
 * Given a struct gl_framebuffer, return the corresponding WMesaFramebuffer.
d85 1
a85 1
static WMesaFramebuffer wmesa_framebuffer(struct gl_framebuffer *fb)
d92 1
a92 1
 * Given a struct gl_context, return the corresponding WMesaContext.
d94 1
a94 1
static WMesaContext wmesa_context(const struct gl_context *ctx)
d104 1
a104 1
static const GLubyte *wmesa_get_string(struct gl_context *ctx, GLenum name)
a120 1
	   pwfb->cColorBits == 24 || 
a129 1
    case 24:
d215 1
a215 1
wmesa_get_buffer_size(struct gl_framebuffer *buffer, GLuint *width, GLuint *height)
d222 1
a222 1
static void wmesa_flush(struct gl_context *ctx)
d246 10
d258 1
a258 1
static void clear_color(struct gl_context *ctx, const GLfloat color[4])
d285 1
a285 1
static void clear(struct gl_context *ctx, GLbitfield mask)
d299 4
a302 4
    if (!ctx->Color.ColorMask[0][0] ||
	!ctx->Color.ColorMask[0][1] ||
	!ctx->Color.ColorMask[0][2] ||
	!ctx->Color.ColorMask[0][3]) {
d455 1
a455 1
static void write_rgba_span_front(const struct gl_context *ctx, 
d461 17
a477 78
   WMesaContext pwc = wmesa_context(ctx);
   WMesaFramebuffer pwfb = wmesa_lookup_framebuffer(pwc->hDC);
   CONST BITMAPINFO bmi=
   {
      {
         sizeof(BITMAPINFOHEADER),
         n, 1, 1, 32, BI_RGB, 0, 1, 1, 0, 0
      }
   };
   HBITMAP bmp=0;
   HDC mdc=0;
   typedef union
   {
      unsigned i;
      struct {
         unsigned b:8, g:8, r:8, a:8;
      };
   } BGRA;
   BGRA *bgra, c;
   GLuint i;

   if (n < 16) {   // the value 16 is just guessed
      y=FLIP(y);
      if (mask) {
         for (i=0; i<n; i++)
            if (mask[i])
               SetPixel(pwc->hDC, x+i, y,
                        RGB(rgba[i][RCOMP], rgba[i][GCOMP], rgba[i][BCOMP]));
      }
      else {
         for (i=0; i<n; i++)
            SetPixel(pwc->hDC, x+i, y,
                     RGB(rgba[i][RCOMP], rgba[i][GCOMP], rgba[i][BCOMP]));
      }
   }
   else {
      if (!pwfb) {
         _mesa_problem(NULL, "wmesa: write_rgba_span_front on unknown hdc");
         return;
      }
      bgra=malloc(n*sizeof(BGRA));
      if (!bgra) {
         _mesa_problem(NULL, "wmesa: write_rgba_span_front: out of memory");
         return;
      }
      c.a=0;
      if (mask) {
         for (i=0; i<n; i++) {
            if (mask[i]) {
               c.r=rgba[i][RCOMP];
               c.g=rgba[i][GCOMP];
               c.b=rgba[i][BCOMP];
               c.a=rgba[i][ACOMP];
               bgra[i]=c;
            }
            else
               bgra[i].i=0;
         }
      }
      else {
         for (i=0; i<n; i++) {
            c.r=rgba[i][RCOMP];
            c.g=rgba[i][GCOMP];
            c.b=rgba[i][BCOMP];
            c.a=rgba[i][ACOMP];
            bgra[i]=c;
         }
      }
      bmp=CreateBitmap(n, 1,  1, 32, bgra);
      mdc=CreateCompatibleDC(pwfb->hDC);
      SelectObject(mdc, bmp);
      y=FLIP(y);
      BitBlt(pwfb->hDC, x, y, n, 1, mdc, 0, 0, SRCCOPY);
      SelectObject(mdc, 0);
      DeleteObject(bmp);
      DeleteDC(mdc);
      free(bgra);
   }
d481 1
a481 1
static void write_rgb_span_front(const struct gl_context *ctx, 
d510 1
a510 1
static void write_mono_rgba_span_front(const struct gl_context *ctx, 
d535 1
a535 1
static void write_rgba_pixels_front(const struct gl_context *ctx, 
d558 1
a558 1
static void write_mono_rgba_pixels_front(const struct gl_context *ctx, 
d576 1
a576 1
static void read_rgba_span_front(const struct gl_context *ctx, 
d596 1
a596 1
static void read_rgba_pixels_front(const struct gl_context *ctx, 
d625 1
a625 1
static void write_rgba_span_32(const struct gl_context *ctx, 
d655 1
a655 1
static void write_rgb_span_32(const struct gl_context *ctx, 
d687 1
a687 1
static void write_mono_rgba_span_32(const struct gl_context *ctx, 
d713 1
a713 1
static void write_rgba_pixels_32(const struct gl_context *ctx, 
d732 1
a732 1
static void write_mono_rgba_pixels_32(const struct gl_context *ctx, 
d749 1
a749 1
static void read_rgba_span_32(const struct gl_context *ctx, 
d764 3
a766 3
	rgba[i][RCOMP] = (GLubyte)((pixel & 0x00ff0000) >> 16);
	rgba[i][GCOMP] = (GLubyte)((pixel & 0x0000ff00) >> 8);
	rgba[i][BCOMP] = (GLubyte)(pixel & 0x000000ff);
d773 1
a773 1
static void read_rgba_pixels_32(const struct gl_context *ctx, 
d788 3
a790 192
	rgba[i][RCOMP] = (GLubyte)((pixel & 0x00ff0000) >> 16);
	rgba[i][GCOMP] = (GLubyte)((pixel & 0x0000ff00) >> 8);
	rgba[i][BCOMP] = (GLubyte)(pixel & 0x000000ff);
	rgba[i][ACOMP] = 255;
  }
}


/*********************************************************************/

/* DOUBLE BUFFER 24-bit */

#define WMSETPIXEL24(pwc, y, x, r, g, b) { \
LPBYTE lpb = ((LPBYTE)((pwc)->pbPixels + (pwc)->ScanWidth * (y)) + (3 * x)); \
lpb[0] = (b); \
lpb[1] = (g); \
lpb[2] = (r); }

/* Write a horizontal span of RGBA color pixels with a boolean mask. */
static void write_rgba_span_24(const struct gl_context *ctx, 
			       struct gl_renderbuffer *rb, 
			       GLuint n, GLint x, GLint y,
			       const GLubyte rgba[][4], 
			       const GLubyte mask[] )
{
    WMesaContext pwc = wmesa_context(ctx);
    WMesaFramebuffer pwfb = wmesa_framebuffer(ctx->DrawBuffer);
    GLuint i;
    LPBYTE lpb;

    (void) ctx;
    
    y=FLIP(y);
    lpb = ((LPBYTE)(pwfb->pbPixels + pwfb->ScanWidth * y)) + (3 * x);
    if (mask) {
	for (i=0; i<n; i++)
	    if (mask[i]) {
                lpb[3*i] = rgba[i][BCOMP];
                lpb[3*i+1] = rgba[i][GCOMP];
                lpb[3*i+2] = rgba[i][RCOMP];
	    }
    }
    else {
	    for (i=0; i<n; i++) {
            *lpb++ = rgba[i][BCOMP];
            *lpb++ = rgba[i][GCOMP];
            *lpb++ = rgba[i][RCOMP];
	    }
    }
}


/* Write a horizontal span of RGB color pixels with a boolean mask. */
static void write_rgb_span_24(const struct gl_context *ctx, 
			      struct gl_renderbuffer *rb, 
			      GLuint n, GLint x, GLint y,
			      const GLubyte rgb[][3], 
			      const GLubyte mask[] )
{
    WMesaContext pwc = wmesa_context(ctx);
    WMesaFramebuffer pwfb = wmesa_framebuffer(ctx->DrawBuffer);
    GLuint i;
    LPBYTE lpb;

    (void) ctx;
    
    y=FLIP(y);
    lpb = ((LPBYTE)(pwfb->pbPixels + pwfb->ScanWidth * y)) + (3 * x);
    if (mask) {
	for (i=0; i<n; i++)
	    if (mask[i]) {
            lpb[3*i] = rgb[i][BCOMP];
            lpb[3*i+1] = rgb[i][GCOMP];
            lpb[3*i+2] = rgb[i][RCOMP];
	    }
    }
    else {
    	for (i=0; i<n; i++) {
    		*lpb++ = rgb[i][BCOMP];
    		*lpb++ = rgb[i][GCOMP];
    		*lpb++ = rgb[i][RCOMP];
    	}
    }
}

/*
 * Write a horizontal span of pixels with a boolean mask.  The current color
 * is used for all pixels.
 */
static void write_mono_rgba_span_24(const struct gl_context *ctx, 
				    struct gl_renderbuffer *rb,
				    GLuint n, GLint x, GLint y,
				    const GLchan color[4], 
				    const GLubyte mask[])
{
    LPBYTE lpb;
    GLuint i;
    WMesaContext pwc = wmesa_context(ctx);
    WMesaFramebuffer pwfb = wmesa_framebuffer(ctx->DrawBuffer);
    lpb = ((LPBYTE)(pwfb->pbPixels + pwfb->ScanWidth * y)) + (3 * x);
    y=FLIP(y);
    if (mask) {
	for (i=0; i<n; i++)
	    if (mask[i]) {
	    	lpb[3*i] = color[BCOMP];
	    	lpb[3*i+1] = color[GCOMP];
	    	lpb[3*i+2] = color[RCOMP];
	    }
    }
    else
	for (i=0; i<n; i++) {
		*lpb++ = color[BCOMP];
		*lpb++ = color[GCOMP];
		*lpb++ = color[RCOMP];		
	}
}

/* Write an array of RGBA pixels with a boolean mask. */
static void write_rgba_pixels_24(const struct gl_context *ctx, 
				 struct gl_renderbuffer *rb,
				 GLuint n, const GLint x[], const GLint y[],
				 const GLubyte rgba[][4], 
				 const GLubyte mask[])
{
    GLuint i;
    WMesaContext pwc = wmesa_context(ctx);
    WMesaFramebuffer pwfb = wmesa_framebuffer(ctx->DrawBuffer);
    for (i=0; i<n; i++)
	if (mask[i])
	    WMSETPIXEL24(pwfb, FLIP(y[i]), x[i],
			 rgba[i][RCOMP], rgba[i][GCOMP], rgba[i][BCOMP]);
}

/*
 * Write an array of pixels with a boolean mask.  The current color
 * is used for all pixels.
 */
static void write_mono_rgba_pixels_24(const struct gl_context *ctx, 
				      struct gl_renderbuffer *rb,
				      GLuint n,
				      const GLint x[], const GLint y[],
				      const GLchan color[4],
				      const GLubyte mask[])
{
    GLuint i;
    WMesaContext pwc = wmesa_context(ctx);
    WMesaFramebuffer pwfb = wmesa_framebuffer(ctx->DrawBuffer);
    for (i=0; i<n; i++)
	if (mask[i])
	    WMSETPIXEL24(pwfb, FLIP(y[i]),x[i],color[RCOMP],
			 color[GCOMP], color[BCOMP]);
}

/* Read a horizontal span of color pixels. */
static void read_rgba_span_24(const struct gl_context *ctx, 
			      struct gl_renderbuffer *rb,
			      GLuint n, GLint x, GLint y,
			      GLubyte rgba[][4] )
{
    GLuint i;
    LPBYTE lpb;
    WMesaContext pwc = wmesa_context(ctx);
    WMesaFramebuffer pwfb = wmesa_framebuffer(ctx->DrawBuffer);
    
    y = FLIP(y);
    lpb = ((LPBYTE)(pwfb->pbPixels + pwfb->ScanWidth * y)) + (3 * x);
    for (i=0; i<n; i++) {
	rgba[i][RCOMP] = lpb[3*i+2];
	rgba[i][GCOMP] = lpb[3*i+1];
	rgba[i][BCOMP] = lpb[3*i];
	rgba[i][ACOMP] = 255;
    }
}


/* Read an array of color pixels. */
static void read_rgba_pixels_24(const struct gl_context *ctx, 
				struct gl_renderbuffer *rb,
				GLuint n, const GLint x[], const GLint y[],
				GLubyte rgba[][4])
{
    GLuint i;
    LPBYTE lpb;
    WMesaContext pwc = wmesa_context(ctx);
    WMesaFramebuffer pwfb = wmesa_framebuffer(ctx->DrawBuffer);

    for (i=0; i<n; i++) {
	GLint y2 = FLIP(y[i]);
	lpb = ((LPBYTE)(pwfb->pbPixels + pwfb->ScanWidth * y2)) + (3 * x[i]);
	rgba[i][RCOMP] = lpb[3*i+2];
	rgba[i][GCOMP] = lpb[3*i+1];
	rgba[i][BCOMP] = lpb[3*i];
d807 1
a807 1
static void write_rgba_span_16(const struct gl_context *ctx, 
d837 1
a837 1
static void write_rgb_span_16(const struct gl_context *ctx, 
d869 1
a869 1
static void write_mono_rgba_span_16(const struct gl_context *ctx, 
d896 1
a896 1
static void write_rgba_pixels_16(const struct gl_context *ctx, 
d916 1
a916 1
static void write_mono_rgba_pixels_16(const struct gl_context *ctx, 
d934 1
a934 1
static void read_rgba_span_16(const struct gl_context *ctx, 
d958 1
a958 1
static void read_rgba_pixels_16(const struct gl_context *ctx, 
d993 1
a993 1
    free(rb);
d1002 1
a1002 1
wmesa_renderbuffer_storage(struct gl_context *ctx, 
d1019 1
a1019 1
                                  int cColorBits, int double_buffer)
d1034 3
d1039 10
a1048 20
		if (cColorBits == 24)
		{
		    rb->PutRow = write_rgba_span_24;
		    rb->PutRowRGB = write_rgb_span_24;
		    rb->PutMonoRow = write_mono_rgba_span_24;
		    rb->PutValues = write_rgba_pixels_24;
		    rb->PutMonoValues = write_mono_rgba_pixels_24;
		    rb->GetRow = read_rgba_span_24;
		    rb->GetValues = read_rgba_pixels_24;
		}
		else
		{
	        rb->PutRow = write_rgba_span_32;
	        rb->PutRowRGB = write_rgb_span_32;
	        rb->PutMonoRow = write_mono_rgba_span_32;
	        rb->PutValues = write_rgba_pixels_32;
	        rb->PutMonoValues = write_mono_rgba_pixels_32;
	        rb->GetRow = read_rgba_span_32;
	        rb->GetValues = read_rgba_pixels_32;
		}
d1063 3
d1074 1
a1074 1
wmesa_resize_buffers(struct gl_context *ctx, struct gl_framebuffer *buffer,
d1102 1
a1102 1
static void wmesa_viewport(struct gl_context *ctx, 
d1125 1
a1125 1
static void wmesa_update_state(struct gl_context *ctx, GLuint new_state)
d1157 2
a1158 2
    struct gl_context *ctx;
    struct gl_config *visual;
d1205 2
a1206 1
    visual = _mesa_create_visual(db_flag,    /* db_flag */
d1210 1
d1218 1
a1218 1
	free(c);
d1229 1
a1237 3
    /* visual no longer needed - it was copied by _mesa_initialize_context() */
    _mesa_destroy_visual(visual);

a1244 2
    _mesa_meta_init(ctx);

d1251 1
a1251 1
	free(c);
d1263 1
a1263 1
    struct gl_context *ctx = &pwc->gl_ctx;
a1287 2
    _mesa_meta_free(ctx);

d1294 1
a1294 1
    free(pwc);
d1336 1
a1336 1
        struct gl_config *visual = &c->gl_ctx.Visual;
d1355 1
a1355 1
            wmesa_set_renderbuffer_funcs(rb, pwfb->pixelformat, pwfb->cColorBits, 1);
d1359 1
a1359 1
        wmesa_set_renderbuffer_funcs(rb, pwfb->pixelformat, pwfb->cColorBits, 0);
d1404 71
a1474 4
void WMesaShareLists(WMesaContext ctx_to_share, WMesaContext ctx)
{
	_mesa_share_state(&ctx->gl_ctx, &ctx_to_share->gl_ctx);	
}
d1476 1
@


1.1.1.5
log
@Import Mesa 9.2.0
@
text
@d8 1
a8 1
#include "GL/wmesa.h"
d10 4
a13 8
#include "main/context.h"
#include "main/api_exec.h"
#include "main/extensions.h"
#include "main/framebuffer.h"
#include "main/renderbuffer.h"
#include "main/macros.h"
#include "main/version.h"
#include "main/vtxfmt.h"
a17 1
#include "swrast/s_renderbuffer.h"
d32 1
a32 1
static WMesaFramebuffer
d36 1
a36 1
        = malloc(sizeof(struct wmesa_framebuffer));
d50 1
a50 1
static void
d73 1
a73 1
static WMesaFramebuffer
d149 1
a149 1
static BOOL wmCreateBackingStore(WMesaFramebuffer pwfb, long lxSize, long lySize)
d151 1
d188 1
a188 1
static void wmDeleteBackingStore(WMesaFramebuffer pwfb)
d229 1
d246 25
d272 6
a277 1
 * Clear the color/depth/stencil buffers.
d279 1
a301 14
    if (mask & BUFFER_BITS_COLOR) {
       /* setup the clearing color */
       const union gl_color_union color = ctx->Color.ClearColor;
       GLubyte col[3];
       UNCLAMPED_FLOAT_TO_UBYTE(col[0], color.f[0]);
       UNCLAMPED_FLOAT_TO_UBYTE(col[1], color.f[1]);
       UNCLAMPED_FLOAT_TO_UBYTE(col[2], color.f[2]);
       pwc->clearColorRef = RGB(col[0], col[1], col[2]);
       DeleteObject(pwc->clearPen);
       DeleteObject(pwc->clearBrush);
       pwc->clearPen = CreatePen(PS_SOLID, 1, pwc->clearColorRef); 
       pwc->clearBrush = CreateSolidBrush(pwc->clearColorRef); 
    }

d437 790
d1236 1
a1236 1
wmesa_delete_renderbuffer(struct gl_context *ctx, struct gl_renderbuffer *rb)
d1238 1
a1238 1
    _mesa_delete_renderbuffer(ctx, rb);
d1260 59
d1326 1
d1355 1
d1473 1
d1476 1
d1482 1
a1482 2
    _mesa_initialize_context(ctx, API_OPENGL_COMPAT, visual,
                             NULL, &functions);
d1488 5
a1507 6
    _mesa_compute_version(ctx);

    /* Exec table initialization requires the version to be computed */
    _mesa_initialize_dispatch_tables(ctx);
    _mesa_initialize_vbo_vtxfmt(ctx);

d1554 1
a1554 1
static struct gl_renderbuffer *
d1565 1
d1608 1
d1612 1
d1615 7
a1621 7
        _swrast_add_soft_renderbuffers(&pwfb->Base,
                                       GL_FALSE, /* color */
                                       visual->depthBits > 0,
                                       visual->stencilBits > 0,
                                       visual->accumRedBits > 0,
                                       visual->alphaBits >0, 
                                       GL_FALSE);
@


1.1.1.6
log
@Import Mesa 10.2.3
@
text
@d487 3
a489 1
static void wmesa_viewport(struct gl_context *ctx)
@


