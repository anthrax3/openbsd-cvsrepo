head	1.9;
access;
symbols
	OPENBSD_5_8:1.8.0.6
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.4
	OPENBSD_5_7_BASE:1.8
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.5
	v10_2_7:1.1.1.5
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	v10_2_3:1.1.1.5
	OPENBSD_5_5:1.7.0.2
	OPENBSD_5_5_BASE:1.7
	v9_2_5:1.1.1.4
	v9_2_3:1.1.1.4
	v9_2_2:1.1.1.4
	v9_2_1:1.1.1.4
	v9_2_0:1.1.1.4
	OPENBSD_5_4:1.6.0.8
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.6
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.4
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	v7_10_3:1.1.1.3
	OPENBSD_5_0:1.5.0.6
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v7_0_1:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v6_5_2:1.1.1.1
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2015.12.23.05.17.55;	author jsg;	state dead;
branches;
next	1.8;
commitid	TnlogFl9nOv2eaRf;

1.8
date	2014.07.09.21.09.01;	author jsg;	state Exp;
branches;
next	1.7;
commitid	WPD6rgPryPkvXOr9;

1.7
date	2013.09.05.14.06.52;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2011.10.23.13.37.45;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.05.22.20.06.34;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.05.17.20.26.42;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.14.58.23;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.05.31.16.36.49;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.51.28;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.51.28;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.32.17;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.10.23.13.29.49;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.09.05.13.17.42;	author jsg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2014.07.09.20.35.13;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.9
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Authors:
 *    Keith Whitwell <keithw@@vmware.com>
 */

#include "main/glheader.h"
#include "main/imports.h"
#include "main/colormac.h"
#include "tnl/tnl.h"
#include "tnl/t_context.h"
#include "tnl/t_pipeline.h"
#include "tnl/t_vertex.h"
#include "swrast_setup.h"
#include "ss_context.h"
#include "ss_triangle.h"


/* Need to check lighting state and vertex program state to know
 * if two-sided lighting is in effect.
 */
#define _SWSETUP_NEW_RENDERINDEX (_NEW_POLYGON|_NEW_LIGHT|_NEW_PROGRAM)


#define VARYING_EMIT_STYLE  EMIT_4F


GLboolean
_swsetup_CreateContext( struct gl_context *ctx )
{
   SScontext *swsetup = calloc(1, sizeof(SScontext));

   if (!swsetup)
      return GL_FALSE;

   ctx->swsetup_context = swsetup;

   swsetup->NewState = ~0;
   _swsetup_trifuncs_init( ctx );

   _tnl_init_vertices( ctx, ctx->Const.MaxArrayLockSize + 12, 
		       sizeof(SWvertex) );


   return GL_TRUE;
}

void
_swsetup_DestroyContext( struct gl_context *ctx )
{
   SScontext *swsetup = SWSETUP_CONTEXT(ctx);

   if (swsetup) {
      free(swsetup);
      ctx->swsetup_context = 0;
   }

   _tnl_free_vertices( ctx );
}

static void
_swsetup_RenderPrimitive( struct gl_context *ctx, GLenum mode )
{
   SWSETUP_CONTEXT(ctx)->render_prim = mode;
   _swrast_render_primitive( ctx, mode );
}


/**
 * Helper macros for setup_vertex_format()
 */
#define SWZ ((SWvertex *)0)
#define SWOffset(MEMBER) (((char *)&(SWZ->MEMBER)) - ((char *)SWZ))

#define EMIT_ATTR( ATTR, STYLE, MEMBER )	\
do {						\
   map[e].attrib = (ATTR);			\
   map[e].format = (STYLE);			\
   map[e].offset = SWOffset(MEMBER);	       	\
   e++;						\
} while (0)


/**
 * Tell the tnl module how to build SWvertex objects for swrast.
 * We'll build the map[] array with that info and pass it to
 * _tnl_install_attrs().
 */
static void
setup_vertex_format(struct gl_context *ctx)
{
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   SScontext *swsetup = SWSETUP_CONTEXT(ctx);
   GLboolean intColors = !ctx->FragmentProgram._Current
                      && !ctx->ATIFragmentShader._Enabled
                      && ctx->RenderMode == GL_RENDER
                      && CHAN_TYPE != GL_FLOAT;

   if (intColors != swsetup->intColors ||
       tnl->render_inputs_bitset != swsetup->last_index_bitset) {
      GLbitfield64 index_bitset = tnl->render_inputs_bitset;
      struct tnl_attr_map map[_TNL_ATTRIB_MAX];
      unsigned int i, e = 0;

      swsetup->intColors = intColors;

      EMIT_ATTR( _TNL_ATTRIB_POS, EMIT_4F_VIEWPORT, attrib[VARYING_SLOT_POS] );

      if (index_bitset & BITFIELD64_BIT(_TNL_ATTRIB_COLOR0)) {
         if (swsetup->intColors)
            EMIT_ATTR( _TNL_ATTRIB_COLOR0, EMIT_4CHAN_4F_RGBA, color );
         else
            EMIT_ATTR( _TNL_ATTRIB_COLOR0, EMIT_4F, attrib[VARYING_SLOT_COL0]);
      }

      if (index_bitset & BITFIELD64_BIT(_TNL_ATTRIB_COLOR1)) {
         EMIT_ATTR( _TNL_ATTRIB_COLOR1, EMIT_4F, attrib[VARYING_SLOT_COL1]);
      }

      if (index_bitset & BITFIELD64_BIT(_TNL_ATTRIB_FOG)) {
         const GLint emit = ctx->FragmentProgram._Current ? EMIT_4F : EMIT_1F;
         EMIT_ATTR( _TNL_ATTRIB_FOG, emit, attrib[VARYING_SLOT_FOGC]);
      }

      if (index_bitset & BITFIELD64_RANGE(_TNL_ATTRIB_TEX0, _TNL_NUM_TEX))
      {
         for (i = 0; i < MAX_TEXTURE_COORD_UNITS; i++) {
            if (index_bitset & BITFIELD64_BIT(_TNL_ATTRIB_TEX(i))) {
               EMIT_ATTR( _TNL_ATTRIB_TEX(i), EMIT_4F,
                          attrib[VARYING_SLOT_TEX0 + i] );
            }
         }
      }

      /* shader varying vars */
      if (index_bitset & BITFIELD64_RANGE(_TNL_ATTRIB_GENERIC0, _TNL_NUM_GENERIC)) {
         for (i = 0; i < ctx->Const.MaxVarying; i++) {
            if (index_bitset & BITFIELD64_BIT(_TNL_ATTRIB_GENERIC(i))) {
               EMIT_ATTR( _TNL_ATTRIB_GENERIC(i), VARYING_EMIT_STYLE,
                          attrib[VARYING_SLOT_VAR0 + i] );
            }
         }
      }

      if (index_bitset & BITFIELD64_BIT(_TNL_ATTRIB_POINTSIZE))
         EMIT_ATTR( _TNL_ATTRIB_POINTSIZE, EMIT_1F, pointSize );

      _tnl_install_attrs( ctx, map, e,
                          ctx->ViewportArray[0]._WindowMap.m,
                          sizeof(SWvertex) );

      swsetup->last_index_bitset = index_bitset;
   }
}


/**
 * Prepare to render a vertex buffer.
 * Called via tnl->Driver.Render.Start.
 */
static void
_swsetup_RenderStart( struct gl_context *ctx )
{
   SScontext *swsetup = SWSETUP_CONTEXT(ctx);
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   struct vertex_buffer *VB = &tnl->vb;

   if (swsetup->NewState & _SWSETUP_NEW_RENDERINDEX) {
      _swsetup_choose_trifuncs(ctx);
   }

   if (swsetup->NewState & _NEW_PROGRAM) {
      swsetup->last_index_bitset = 0;
   }

   swsetup->NewState = 0;

   /* This will change if drawing unfilled tris */
   _swrast_SetFacing(ctx, 0);

   _swrast_render_start(ctx);

   /* Important */
   VB->AttribPtr[VERT_ATTRIB_POS] = VB->NdcPtr;

   setup_vertex_format(ctx);
}


/*
 * We patch this function into tnl->Driver.Render.Finish.
 * It's called when we finish rendering a vertex buffer.
 */
static void
_swsetup_RenderFinish( struct gl_context *ctx )
{
   _swrast_render_finish( ctx );
}

void
_swsetup_InvalidateState( struct gl_context *ctx, GLuint new_state )
{
   SScontext *swsetup = SWSETUP_CONTEXT(ctx);
   swsetup->NewState |= new_state;
   _tnl_invalidate_vertex_state( ctx, new_state );
}


void
_swsetup_Wakeup( struct gl_context *ctx )
{
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   SScontext *swsetup = SWSETUP_CONTEXT(ctx);

   tnl->Driver.Render.Start = _swsetup_RenderStart;
   tnl->Driver.Render.Finish = _swsetup_RenderFinish;
   tnl->Driver.Render.PrimitiveNotify = _swsetup_RenderPrimitive;
   tnl->Driver.Render.Interp = _tnl_interp;
   tnl->Driver.Render.CopyPV = _tnl_copy_pv;
   tnl->Driver.Render.ClippedPolygon = _tnl_RenderClippedPolygon; /* new */
   tnl->Driver.Render.ClippedLine = _tnl_RenderClippedLine; /* new */
   /* points */
   /* line */
   /* triangle */
   /* quad */
   tnl->Driver.Render.PrimTabVerts = _tnl_render_tab_verts;
   tnl->Driver.Render.PrimTabElts = _tnl_render_tab_elts;
   tnl->Driver.Render.ResetLineStipple = _swrast_ResetLineStipple;
   tnl->Driver.Render.BuildVertices = _tnl_build_vertices;
   tnl->Driver.Render.Multipass = 0;

   _tnl_invalidate_vertices( ctx, ~0 );
   _tnl_need_projected_coords( ctx, GL_TRUE );
   _swsetup_InvalidateState( ctx, ~0 );

   swsetup->verts = (SWvertex *)tnl->clipspace.vertex_buf;
   swsetup->last_index_bitset = 0;
}


/**
 * Populate a swrast SWvertex from an attrib-style vertex.
 */
void 
_swsetup_Translate( struct gl_context *ctx, const void *vertex, SWvertex *dest )
{
   const GLfloat *m = ctx->ViewportArray[0]._WindowMap.m;
   GLfloat tmp[4];
   GLuint i;

   _tnl_get_attr( ctx, vertex, _TNL_ATTRIB_POS, tmp );

   dest->attrib[VARYING_SLOT_POS][0] = m[0]  * tmp[0] + m[12];
   dest->attrib[VARYING_SLOT_POS][1] = m[5]  * tmp[1] + m[13];
   dest->attrib[VARYING_SLOT_POS][2] = m[10] * tmp[2] + m[14];
   dest->attrib[VARYING_SLOT_POS][3] =         tmp[3];

   /** XXX try to limit these loops someday */
   for (i = 0 ; i < ctx->Const.MaxTextureCoordUnits ; i++)
      _tnl_get_attr( ctx, vertex, _TNL_ATTRIB_TEX0 + i,
                     dest->attrib[VARYING_SLOT_TEX0 + i] );

   for (i = 0 ; i < ctx->Const.MaxVarying ; i++)
      _tnl_get_attr( ctx, vertex, _TNL_ATTRIB_GENERIC0 + i,
                     dest->attrib[VARYING_SLOT_VAR0 + i] );

   _tnl_get_attr( ctx, vertex, _TNL_ATTRIB_COLOR0,
                  dest->attrib[VARYING_SLOT_COL0] );

   UNCLAMPED_FLOAT_TO_RGBA_CHAN(dest->color, dest->attrib[VARYING_SLOT_COL0]);

   _tnl_get_attr( ctx, vertex, _TNL_ATTRIB_COLOR1,
                  dest->attrib[VARYING_SLOT_COL1]);

   _tnl_get_attr( ctx, vertex, _TNL_ATTRIB_FOG, tmp );
   dest->attrib[VARYING_SLOT_FOGC][0] = tmp[0];

   /* XXX See _tnl_get_attr about pointsize ... */
   _tnl_get_attr( ctx, vertex, _TNL_ATTRIB_POINTSIZE, tmp );
   dest->pointSize = tmp[0];
}

@


1.8
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.7
log
@Merge Mesa 9.2.0
@
text
@d25 1
a25 1
 *    Keith Whitwell <keith@@tungstengraphics.com>
d170 1
a170 1
                          ctx->Viewport._WindowMap.m,
d268 1
a268 1
   const GLfloat *m = ctx->Viewport._WindowMap.m;
d290 2
a291 1
   UNCLAMPED_FLOAT_TO_RGBA_CHAN( dest->color, tmp );
@


1.6
log
@Merge Mesa 7.10.3
@
text
@a2 1
 * Version:  7.1
d19 4
a22 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
d52 1
a52 1
   SScontext *swsetup = (SScontext *)CALLOC(sizeof(SScontext));
d75 1
a75 1
      FREE(swsetup);
d121 2
a122 3
       !RENDERINPUTS_EQUAL(tnl->render_inputs_bitset,
                           swsetup->last_index_bitset)) {
      DECLARE_RENDERINPUTS(index_bitset);
d128 1
a128 1
      RENDERINPUTS_COPY( index_bitset, tnl->render_inputs_bitset );
d130 1
a130 3
      EMIT_ATTR( _TNL_ATTRIB_POS, EMIT_4F_VIEWPORT, attrib[FRAG_ATTRIB_WPOS] );

      if (RENDERINPUTS_TEST( index_bitset, _TNL_ATTRIB_COLOR0 )) {
d134 1
a134 1
            EMIT_ATTR( _TNL_ATTRIB_COLOR0, EMIT_4F, attrib[FRAG_ATTRIB_COL0]);
d137 2
a138 2
      if (RENDERINPUTS_TEST( index_bitset, _TNL_ATTRIB_COLOR1 )) {
         EMIT_ATTR( _TNL_ATTRIB_COLOR1, EMIT_4F, attrib[FRAG_ATTRIB_COL1]);
d141 1
a141 1
      if (RENDERINPUTS_TEST( index_bitset, _TNL_ATTRIB_FOG )) {
d143 1
a143 1
         EMIT_ATTR( _TNL_ATTRIB_FOG, emit, attrib[FRAG_ATTRIB_FOGC]);
d146 1
a146 1
      if (RENDERINPUTS_TEST_RANGE(index_bitset, _TNL_FIRST_TEX, _TNL_LAST_TEX))
d149 1
a149 1
            if (RENDERINPUTS_TEST( index_bitset, _TNL_ATTRIB_TEX(i) )) {
d151 1
a151 1
                          attrib[FRAG_ATTRIB_TEX0 + i] );
d157 1
a157 2
      if (RENDERINPUTS_TEST_RANGE( index_bitset,
                                   _TNL_FIRST_GENERIC, _TNL_LAST_GENERIC )) {
d159 1
a159 1
            if (RENDERINPUTS_TEST( index_bitset, _TNL_ATTRIB_GENERIC(i) )) {
d161 1
a161 1
                          attrib[FRAG_ATTRIB_VAR0 + i] );
d166 1
a166 1
      if (RENDERINPUTS_TEST( index_bitset, _TNL_ATTRIB_POINTSIZE ))
d173 1
a173 1
      RENDERINPUTS_COPY( swsetup->last_index_bitset, index_bitset );
d194 1
a194 1
      RENDERINPUTS_ZERO( swsetup->last_index_bitset );
d258 1
a258 1
   RENDERINPUTS_ZERO( swsetup->last_index_bitset );
d274 4
a277 4
   dest->attrib[FRAG_ATTRIB_WPOS][0] = m[0]  * tmp[0] + m[12];
   dest->attrib[FRAG_ATTRIB_WPOS][1] = m[5]  * tmp[1] + m[13];
   dest->attrib[FRAG_ATTRIB_WPOS][2] = m[10] * tmp[2] + m[14];
   dest->attrib[FRAG_ATTRIB_WPOS][3] =         tmp[3];
d282 1
a282 1
                     dest->attrib[FRAG_ATTRIB_TEX0 + i] );
d286 1
a286 1
                     dest->attrib[FRAG_ATTRIB_VAR0 + i] );
d289 1
a289 1
                  dest->attrib[FRAG_ATTRIB_COL0] );
d293 1
a293 1
                  dest->attrib[FRAG_ATTRIB_COL1]);
d296 1
a296 1
   dest->attrib[FRAG_ATTRIB_FOGC][0] = tmp[0];
@


1.5
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d50 1
a50 1
_swsetup_CreateContext( GLcontext *ctx )
d70 1
a70 1
_swsetup_DestroyContext( GLcontext *ctx )
d83 1
a83 1
_swsetup_RenderPrimitive( GLcontext *ctx, GLenum mode )
d111 1
a111 1
setup_vertex_format(GLcontext *ctx)
d118 1
a118 1
                      && CHAN_TYPE == GL_UNSIGNED_BYTE;
d187 1
a187 1
_swsetup_RenderStart( GLcontext *ctx )
d220 1
a220 1
_swsetup_RenderFinish( GLcontext *ctx )
d226 1
a226 1
_swsetup_InvalidateState( GLcontext *ctx, GLuint new_state )
d235 1
a235 1
_swsetup_Wakeup( GLcontext *ctx )
d270 1
a270 1
_swsetup_Translate( GLcontext *ctx, const void *vertex, SWvertex *dest )
@


1.4
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d125 1
a125 1
      int i, e = 0;
a143 5
      if (RENDERINPUTS_TEST( index_bitset, _TNL_ATTRIB_COLOR_INDEX )) {
         EMIT_ATTR( _TNL_ATTRIB_COLOR_INDEX, EMIT_1F,
                    attrib[FRAG_ATTRIB_CI][0] );
      }

d292 3
a294 4
   if (ctx->Visual.rgbMode) {
      _tnl_get_attr( ctx, vertex, _TNL_ATTRIB_COLOR0,
                     dest->attrib[FRAG_ATTRIB_COL0] );
      UNCLAMPED_FLOAT_TO_RGBA_CHAN( dest->color, tmp );
d296 2
a297 7
      _tnl_get_attr( ctx, vertex, _TNL_ATTRIB_COLOR1,
                     dest->attrib[FRAG_ATTRIB_COL1]);
   }
   else {
      _tnl_get_attr( ctx, vertex, _TNL_ATTRIB_COLOR_INDEX, tmp );
      dest->attrib[FRAG_ATTRIB_CI][0] = tmp[0];
   }
@


1.3
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d28 3
a30 6
#include "glheader.h"
#include "imports.h"
#include "colormac.h"
#include "ss_context.h"
#include "ss_triangle.h"
#include "swrast_setup.h"
d35 4
@


1.2
log
@Update to Mesa 7.0.3. tested my oga@@ and johan@@
@
text
@d3 1
a3 1
 * Version:  6.5.3
d114 4
d119 2
a120 1
   if (!RENDERINPUTS_EQUAL(tnl->render_inputs_bitset,
d126 2
d130 1
a130 1
      EMIT_ATTR( _TNL_ATTRIB_POS, EMIT_4F_VIEWPORT, win );
d132 6
a137 2
      if (RENDERINPUTS_TEST( index_bitset, _TNL_ATTRIB_COLOR0 ))
         EMIT_ATTR( _TNL_ATTRIB_COLOR0, EMIT_4CHAN_4F_RGBA, color );
d139 3
a141 2
      if (RENDERINPUTS_TEST( index_bitset, _TNL_ATTRIB_COLOR1 ))
         EMIT_ATTR( _TNL_ATTRIB_COLOR1, EMIT_4CHAN_4F_RGBA, specular);
d143 4
a146 2
      if (RENDERINPUTS_TEST( index_bitset, _TNL_ATTRIB_COLOR_INDEX ))
         EMIT_ATTR( _TNL_ATTRIB_COLOR_INDEX, EMIT_1F, index );
d201 4
d282 4
a285 4
   dest->win[0] = m[0]  * tmp[0] + m[12];
   dest->win[1] = m[5]  * tmp[1] + m[13];
   dest->win[2] = m[10] * tmp[2] + m[14];
   dest->win[3] =         tmp[3];
d289 1
a289 1
      _tnl_get_attr( ctx, vertex, _TNL_ATTRIB_TEX0+i,
d293 1
a293 1
      _tnl_get_attr( ctx, vertex, _TNL_ATTRIB_GENERIC0+i,
d296 4
a299 2
   _tnl_get_attr( ctx, vertex, _TNL_ATTRIB_COLOR0, tmp );
   UNCLAMPED_FLOAT_TO_RGBA_CHAN( dest->color, tmp );
d301 7
a307 2
   _tnl_get_attr( ctx, vertex, _TNL_ATTRIB_COLOR1, tmp );
   UNCLAMPED_FLOAT_TO_RGBA_CHAN( dest->specular, tmp );
a310 3

   _tnl_get_attr( ctx, vertex, _TNL_ATTRIB_COLOR_INDEX, tmp );
   dest->index = tmp[0];
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * Version:  6.5
d5 1
a5 1
 * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
d45 3
d88 4
d103 5
a107 3
/*
 * We patch this function into tnl->Driver.Render.Start.
 * It's called when we start rendering a vertex buffer.
d110 1
a110 1
_swsetup_RenderStart( GLcontext *ctx )
d112 1
a113 3
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   struct vertex_buffer *VB = &tnl->vb;
   GLuint new_state = swsetup->NewState;
d115 2
a116 14
   if (new_state & _SWSETUP_NEW_RENDERINDEX) {
      _swsetup_choose_trifuncs( ctx );
   }

   swsetup->NewState = 0;

   _swrast_render_start( ctx );

   /* Important:
    */
   VB->AttribPtr[VERT_ATTRIB_POS] = VB->NdcPtr;


   if (!RENDERINPUTS_EQUAL(tnl->render_inputs_bitset, swsetup->last_index_bitset)) {
d134 4
a137 2
      if (RENDERINPUTS_TEST( index_bitset, _TNL_ATTRIB_FOG ))
         EMIT_ATTR( _TNL_ATTRIB_FOG, EMIT_1F, fog);
d139 2
a140 1
      if (RENDERINPUTS_TEST_RANGE( index_bitset, _TNL_FIRST_TEX, _TNL_LAST_TEX )) {
d143 2
a144 1
               EMIT_ATTR( _TNL_ATTRIB_TEX(i), EMIT_4F, texcoord[i] );
d149 9
a157 6
      if (RENDERINPUTS_TEST_RANGE( index_bitset, _TNL_FIRST_GENERIC, _TNL_LAST_GENERIC )) {
          for (i = 0; i < MAX_VERTEX_ATTRIBS; i++) {
              if (RENDERINPUTS_TEST( index_bitset, _TNL_ATTRIB_GENERIC(i) )) {
                  EMIT_ATTR( _TNL_ATTRIB_GENERIC(i), VARYING_EMIT_STYLE, attribute[i] );
              }
          }
d171 30
d269 8
a277 3
   for (i = 0 ; i < ctx->Const.MaxTextureCoordUnits ; i++)
      _tnl_get_attr( ctx, vertex, _TNL_ATTRIB_TEX0+i, dest->texcoord[i] );
	  
d285 1
a285 1
   dest->fog = tmp[0];
d290 1
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@Mesa 7.0.1
@
text
@d3 1
a3 1
 * Version:  6.5.3
d5 1
a5 1
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
a44 3
#define VARYING_EMIT_STYLE  EMIT_4F


a84 4

/**
 * Helper macros for setup_vertex_format()
 */
d96 3
a98 5

/**
 * Tell the tnl module how to build SWvertex objects for swrast.
 * We'll build the map[] array with that info and pass it to
 * _tnl_install_attrs().
d101 1
a101 1
setup_vertex_format(GLcontext *ctx)
d103 1
d105 15
a119 1
   SScontext *swsetup = SWSETUP_CONTEXT(ctx);
d121 1
a121 2
   if (!RENDERINPUTS_EQUAL(tnl->render_inputs_bitset,
                           swsetup->last_index_bitset)) {
d139 2
a140 4
      if (RENDERINPUTS_TEST( index_bitset, _TNL_ATTRIB_FOG )) {
         const GLint emit = ctx->FragmentProgram._Current ? EMIT_4F : EMIT_1F;
         EMIT_ATTR( _TNL_ATTRIB_FOG, emit, attrib[FRAG_ATTRIB_FOGC]);
      }
d142 1
a142 2
      if (RENDERINPUTS_TEST_RANGE(index_bitset, _TNL_FIRST_TEX, _TNL_LAST_TEX))
      {
d145 1
a145 2
               EMIT_ATTR( _TNL_ATTRIB_TEX(i), EMIT_4F,
                          attrib[FRAG_ATTRIB_TEX0 + i] );
d150 6
a155 9
      /* shader varying vars */
      if (RENDERINPUTS_TEST_RANGE( index_bitset,
                                   _TNL_FIRST_GENERIC, _TNL_LAST_GENERIC )) {
         for (i = 0; i < ctx->Const.MaxVarying; i++) {
            if (RENDERINPUTS_TEST( index_bitset, _TNL_ATTRIB_GENERIC(i) )) {
               EMIT_ATTR( _TNL_ATTRIB_GENERIC(i), VARYING_EMIT_STYLE,
                          attrib[FRAG_ATTRIB_VAR0 + i] );
            }
         }
a168 27

/**
 * Prepare to render a vertex buffer.
 * Called via tnl->Driver.Render.Start.
 */
static void
_swsetup_RenderStart( GLcontext *ctx )
{
   SScontext *swsetup = SWSETUP_CONTEXT(ctx);
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   struct vertex_buffer *VB = &tnl->vb;

   if (swsetup->NewState & _SWSETUP_NEW_RENDERINDEX) {
      _swsetup_choose_trifuncs(ctx);
   }

   swsetup->NewState = 0;

   _swrast_render_start(ctx);

   /* Important */
   VB->AttribPtr[VERT_ATTRIB_POS] = VB->NdcPtr;

   setup_vertex_format(ctx);
}


d237 1
a237 1
   /** XXX try to limit these loops someday */
d239 2
a240 7
      _tnl_get_attr( ctx, vertex, _TNL_ATTRIB_TEX0+i,
                     dest->attrib[FRAG_ATTRIB_TEX0 + i] );

   for (i = 0 ; i < ctx->Const.MaxVarying ; i++)
      _tnl_get_attr( ctx, vertex, _TNL_ATTRIB_GENERIC0+i,
                     dest->attrib[FRAG_ATTRIB_VAR0 + i] );

d248 1
a248 1
   dest->attrib[FRAG_ATTRIB_FOGC][0] = tmp[0];
a252 1
   /* XXX See _tnl_get_attr about pointsize ... */
@


1.1.1.3
log
@Import Mesa 7.10.3
@
text
@d3 1
a3 1
 * Version:  7.1
d28 6
a33 3
#include "main/glheader.h"
#include "main/imports.h"
#include "main/colormac.h"
a37 4
#include "swrast_setup.h"
#include "ss_context.h"
#include "ss_triangle.h"

d49 1
a49 1
_swsetup_CreateContext( struct gl_context *ctx )
d69 1
a69 1
_swsetup_DestroyContext( struct gl_context *ctx )
d82 1
a82 1
_swsetup_RenderPrimitive( struct gl_context *ctx, GLenum mode )
d110 1
a110 1
setup_vertex_format(struct gl_context *ctx)
a113 4
   GLboolean intColors = !ctx->FragmentProgram._Current
                      && !ctx->ATIFragmentShader._Enabled
                      && ctx->RenderMode == GL_RENDER
                      && CHAN_TYPE != GL_FLOAT;
d115 1
a115 2
   if (intColors != swsetup->intColors ||
       !RENDERINPUTS_EQUAL(tnl->render_inputs_bitset,
d119 1
a119 1
      unsigned int i, e = 0;
d121 1
a121 1
      swsetup->intColors = intColors;
d123 1
a123 1
      RENDERINPUTS_COPY( index_bitset, tnl->render_inputs_bitset );
d125 2
a126 1
      EMIT_ATTR( _TNL_ATTRIB_POS, EMIT_4F_VIEWPORT, attrib[FRAG_ATTRIB_WPOS] );
d128 2
a129 6
      if (RENDERINPUTS_TEST( index_bitset, _TNL_ATTRIB_COLOR0 )) {
         if (swsetup->intColors)
            EMIT_ATTR( _TNL_ATTRIB_COLOR0, EMIT_4CHAN_4F_RGBA, color );
         else
            EMIT_ATTR( _TNL_ATTRIB_COLOR0, EMIT_4F, attrib[FRAG_ATTRIB_COL0]);
      }
d131 2
a132 3
      if (RENDERINPUTS_TEST( index_bitset, _TNL_ATTRIB_COLOR1 )) {
         EMIT_ATTR( _TNL_ATTRIB_COLOR1, EMIT_4F, attrib[FRAG_ATTRIB_COL1]);
      }
d177 1
a177 1
_swsetup_RenderStart( struct gl_context *ctx )
a186 4
   if (swsetup->NewState & _NEW_PROGRAM) {
      RENDERINPUTS_ZERO( swsetup->last_index_bitset );
   }

a188 3
   /* This will change if drawing unfilled tris */
   _swrast_SetFacing(ctx, 0);

d203 1
a203 1
_swsetup_RenderFinish( struct gl_context *ctx )
d209 1
a209 1
_swsetup_InvalidateState( struct gl_context *ctx, GLuint new_state )
d218 1
a218 1
_swsetup_Wakeup( struct gl_context *ctx )
d253 1
a253 1
_swsetup_Translate( struct gl_context *ctx, const void *vertex, SWvertex *dest )
d261 4
a264 4
   dest->attrib[FRAG_ATTRIB_WPOS][0] = m[0]  * tmp[0] + m[12];
   dest->attrib[FRAG_ATTRIB_WPOS][1] = m[5]  * tmp[1] + m[13];
   dest->attrib[FRAG_ATTRIB_WPOS][2] = m[10] * tmp[2] + m[14];
   dest->attrib[FRAG_ATTRIB_WPOS][3] =         tmp[3];
d268 1
a268 1
      _tnl_get_attr( ctx, vertex, _TNL_ATTRIB_TEX0 + i,
d272 1
a272 1
      _tnl_get_attr( ctx, vertex, _TNL_ATTRIB_GENERIC0 + i,
d275 1
a275 2
   _tnl_get_attr( ctx, vertex, _TNL_ATTRIB_COLOR0,
                  dest->attrib[FRAG_ATTRIB_COL0] );
d278 2
a279 2
   _tnl_get_attr( ctx, vertex, _TNL_ATTRIB_COLOR1,
                  dest->attrib[FRAG_ATTRIB_COL1]);
d283 3
@


1.1.1.4
log
@Import Mesa 9.2.0
@
text
@d3 1
d20 3
a22 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
d52 1
a52 1
   SScontext *swsetup = calloc(1, sizeof(SScontext));
d75 1
a75 1
      free(swsetup);
d121 3
a123 2
       tnl->render_inputs_bitset != swsetup->last_index_bitset) {
      GLbitfield64 index_bitset = tnl->render_inputs_bitset;
d129 1
a129 1
      EMIT_ATTR( _TNL_ATTRIB_POS, EMIT_4F_VIEWPORT, attrib[VARYING_SLOT_POS] );
d131 3
a133 1
      if (index_bitset & BITFIELD64_BIT(_TNL_ATTRIB_COLOR0)) {
d137 1
a137 1
            EMIT_ATTR( _TNL_ATTRIB_COLOR0, EMIT_4F, attrib[VARYING_SLOT_COL0]);
d140 2
a141 2
      if (index_bitset & BITFIELD64_BIT(_TNL_ATTRIB_COLOR1)) {
         EMIT_ATTR( _TNL_ATTRIB_COLOR1, EMIT_4F, attrib[VARYING_SLOT_COL1]);
d144 1
a144 1
      if (index_bitset & BITFIELD64_BIT(_TNL_ATTRIB_FOG)) {
d146 1
a146 1
         EMIT_ATTR( _TNL_ATTRIB_FOG, emit, attrib[VARYING_SLOT_FOGC]);
d149 1
a149 1
      if (index_bitset & BITFIELD64_RANGE(_TNL_ATTRIB_TEX0, _TNL_NUM_TEX))
d152 1
a152 1
            if (index_bitset & BITFIELD64_BIT(_TNL_ATTRIB_TEX(i))) {
d154 1
a154 1
                          attrib[VARYING_SLOT_TEX0 + i] );
d160 2
a161 1
      if (index_bitset & BITFIELD64_RANGE(_TNL_ATTRIB_GENERIC0, _TNL_NUM_GENERIC)) {
d163 1
a163 1
            if (index_bitset & BITFIELD64_BIT(_TNL_ATTRIB_GENERIC(i))) {
d165 1
a165 1
                          attrib[VARYING_SLOT_VAR0 + i] );
d170 1
a170 1
      if (index_bitset & BITFIELD64_BIT(_TNL_ATTRIB_POINTSIZE))
d177 1
a177 1
      swsetup->last_index_bitset = index_bitset;
d198 1
a198 1
      swsetup->last_index_bitset = 0;
d262 1
a262 1
   swsetup->last_index_bitset = 0;
d278 4
a281 4
   dest->attrib[VARYING_SLOT_POS][0] = m[0]  * tmp[0] + m[12];
   dest->attrib[VARYING_SLOT_POS][1] = m[5]  * tmp[1] + m[13];
   dest->attrib[VARYING_SLOT_POS][2] = m[10] * tmp[2] + m[14];
   dest->attrib[VARYING_SLOT_POS][3] =         tmp[3];
d286 1
a286 1
                     dest->attrib[VARYING_SLOT_TEX0 + i] );
d290 1
a290 1
                     dest->attrib[VARYING_SLOT_VAR0 + i] );
d293 1
a293 1
                  dest->attrib[VARYING_SLOT_COL0] );
d297 1
a297 1
                  dest->attrib[VARYING_SLOT_COL1]);
d300 1
a300 1
   dest->attrib[VARYING_SLOT_FOGC][0] = tmp[0];
@


1.1.1.5
log
@Import Mesa 10.2.3
@
text
@d25 1
a25 1
 *    Keith Whitwell <keithw@@vmware.com>
d170 1
a170 1
                          ctx->ViewportArray[0]._WindowMap.m,
d268 1
a268 1
   const GLfloat *m = ctx->ViewportArray[0]._WindowMap.m;
d290 1
a290 2

   UNCLAMPED_FLOAT_TO_RGBA_CHAN(dest->color, dest->attrib[VARYING_SLOT_COL0]);
@


