head	1.9;
access;
symbols
	OPENBSD_5_8:1.8.0.6
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.4
	OPENBSD_5_7_BASE:1.8
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.5
	v10_2_7:1.1.1.5
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	v10_2_3:1.1.1.5
	OPENBSD_5_5:1.7.0.2
	OPENBSD_5_5_BASE:1.7
	v9_2_5:1.1.1.4
	v9_2_3:1.1.1.4
	v9_2_2:1.1.1.4
	v9_2_1:1.1.1.4
	v9_2_0:1.1.1.4
	OPENBSD_5_4:1.6.0.8
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.6
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.4
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	v7_10_3:1.1.1.3
	OPENBSD_5_0:1.5.0.6
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.6
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.4
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.2
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.3.0.2
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_3:1.2.0.2
	v7_0_1:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v6_5_2:1.1.1.1
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2015.12.23.05.17.55;	author jsg;	state dead;
branches;
next	1.8;
commitid	TnlogFl9nOv2eaRf;

1.8
date	2014.07.09.21.09.01;	author jsg;	state Exp;
branches;
next	1.7;
commitid	WPD6rgPryPkvXOr9;

1.7
date	2013.09.05.14.06.52;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2011.10.23.13.37.45;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.05.22.20.06.34;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2008.11.02.14.58.23;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.05.31.16.36.49;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.02.12.21.09.27;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.51.28;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.51.28;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.32.17;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.10.23.13.29.49;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.09.05.13.17.42;	author jsg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2014.07.09.20.35.13;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.9
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Authors:
 *    Keith Whitwell <keithw@@vmware.com>
 */


/**
 * This is where we handle assigning vertex colors based on front/back
 * facing, compute polygon offset and handle glPolygonMode().
 */
static void TAG(triangle)(struct gl_context *ctx, GLuint e0, GLuint e1, GLuint e2 )
{
   struct vertex_buffer *VB = &TNL_CONTEXT(ctx)->vb;
   SScontext *swsetup = SWSETUP_CONTEXT(ctx);
   SWvertex *verts = SWSETUP_CONTEXT(ctx)->verts;
   SWvertex *v[3];
   GLfloat z[3];
   GLfloat offset, oz0, oz1, oz2;
   GLenum mode = GL_FILL;
   GLuint facing = 0;
   GLchan saved_color[3][4] = { { 0 } };
   GLfloat saved_col0[3][4] = { { 0 } };
   GLfloat saved_spec[3][4] = { { 0 } };

   v[0] = &verts[e0];
   v[1] = &verts[e1];
   v[2] = &verts[e2];

   if (IND & (SS_TWOSIDE_BIT | SS_OFFSET_BIT | SS_UNFILLED_BIT))
   {
      GLfloat ex = v[0]->attrib[VARYING_SLOT_POS][0] - v[2]->attrib[VARYING_SLOT_POS][0];
      GLfloat ey = v[0]->attrib[VARYING_SLOT_POS][1] - v[2]->attrib[VARYING_SLOT_POS][1];
      GLfloat fx = v[1]->attrib[VARYING_SLOT_POS][0] - v[2]->attrib[VARYING_SLOT_POS][0];
      GLfloat fy = v[1]->attrib[VARYING_SLOT_POS][1] - v[2]->attrib[VARYING_SLOT_POS][1];
      GLfloat cc  = ex*fy - ey*fx;

      if (IND & (SS_TWOSIDE_BIT | SS_UNFILLED_BIT))
      {
	 facing = (cc < 0.0) ^ ctx->Polygon._FrontBit;

	 if (IND & SS_UNFILLED_BIT)
	    mode = facing ? ctx->Polygon.BackMode : ctx->Polygon.FrontMode;

	 if (facing == 1) {
	    if (IND & SS_TWOSIDE_BIT) {
               if (VB->BackfaceColorPtr) {
                  GLfloat (*vbcolor)[4] = VB->BackfaceColorPtr->data;

                  if (swsetup->intColors) {
                     COPY_CHAN4(saved_color[0], v[0]->color);
                     COPY_CHAN4(saved_color[1], v[1]->color);
                     COPY_CHAN4(saved_color[2], v[2]->color);
                  }
                  else {
                     COPY_4V(saved_col0[0], v[0]->attrib[VARYING_SLOT_COL0]);
                     COPY_4V(saved_col0[1], v[1]->attrib[VARYING_SLOT_COL0]);
                     COPY_4V(saved_col0[2], v[2]->attrib[VARYING_SLOT_COL0]);
                  }

                  if (VB->BackfaceColorPtr->stride) {
                     if (swsetup->intColors) {
                        SS_COLOR(v[0]->color, vbcolor[e0]);
                        SS_COLOR(v[1]->color, vbcolor[e1]);
                        SS_COLOR(v[2]->color, vbcolor[e2]);
                     }
                     else {
                        COPY_4V(v[0]->attrib[VARYING_SLOT_COL0], vbcolor[e0]);
                        COPY_4V(v[1]->attrib[VARYING_SLOT_COL0], vbcolor[e1]);
                        COPY_4V(v[2]->attrib[VARYING_SLOT_COL0], vbcolor[e2]);
                     }
                  }
                  else {
                     /* flat shade */
                     if (swsetup->intColors) {
                        SS_COLOR(v[0]->color, vbcolor[0]);
                        SS_COLOR(v[1]->color, vbcolor[0]);
                        SS_COLOR(v[2]->color, vbcolor[0]);
                     }
                     else {
                        COPY_4V(v[0]->attrib[VARYING_SLOT_COL0], vbcolor[0]);
                        COPY_4V(v[1]->attrib[VARYING_SLOT_COL0], vbcolor[0]);
                        COPY_4V(v[2]->attrib[VARYING_SLOT_COL0], vbcolor[0]);
                     }
                  }
               }

               if (VB->BackfaceSecondaryColorPtr) {
		  GLfloat (*vbspec)[4] = VB->BackfaceSecondaryColorPtr->data;

		  COPY_4V(saved_spec[0], v[0]->attrib[VARYING_SLOT_COL1]);
		  COPY_4V(saved_spec[1], v[1]->attrib[VARYING_SLOT_COL1]);
		  COPY_4V(saved_spec[2], v[2]->attrib[VARYING_SLOT_COL1]);

		  if (VB->BackfaceSecondaryColorPtr->stride) {
		    SS_SPEC(v[0]->attrib[VARYING_SLOT_COL1], vbspec[e0]);
		    SS_SPEC(v[1]->attrib[VARYING_SLOT_COL1], vbspec[e1]);
		    SS_SPEC(v[2]->attrib[VARYING_SLOT_COL1], vbspec[e2]);
		  }
		  else {
		    SS_SPEC(v[0]->attrib[VARYING_SLOT_COL1], vbspec[0]);
		    SS_SPEC(v[1]->attrib[VARYING_SLOT_COL1], vbspec[0]);
		    SS_SPEC(v[2]->attrib[VARYING_SLOT_COL1], vbspec[0]);
		  }
	       }
	    }
	 }
      }

      if (IND & SS_OFFSET_BIT) {
         const GLfloat max = ctx->DrawBuffer->_DepthMaxF;
         /* save original Z values (restored later) */
	 z[0] = v[0]->attrib[VARYING_SLOT_POS][2];
	 z[1] = v[1]->attrib[VARYING_SLOT_POS][2];
	 z[2] = v[2]->attrib[VARYING_SLOT_POS][2];
         /* Note that Z values are already scaled to [0,65535] (for example)
          * so no MRD value is used here.
          */
	 offset = ctx->Polygon.OffsetUnits;
	 if (cc * cc > 1e-16) {
	    const GLfloat ez = z[0] - z[2];
	    const GLfloat fz = z[1] - z[2];
	    const GLfloat oneOverArea = 1.0F / cc;
	    const GLfloat dzdx = FABSF((ey * fz - ez * fy) * oneOverArea);
	    const GLfloat dzdy = FABSF((ez * fx - ex * fz) * oneOverArea);
	    offset += MAX2(dzdx, dzdy) * ctx->Polygon.OffsetFactor;
	 }
         /* new Z values */
         oz0 = CLAMP(v[0]->attrib[VARYING_SLOT_POS][2] + offset, 0.0F, max);
         oz1 = CLAMP(v[1]->attrib[VARYING_SLOT_POS][2] + offset, 0.0F, max);
         oz2 = CLAMP(v[2]->attrib[VARYING_SLOT_POS][2] + offset, 0.0F, max);
      }
   }

   if (mode == GL_POINT) {
      if ((IND & SS_OFFSET_BIT) && ctx->Polygon.OffsetPoint) {
	 v[0]->attrib[VARYING_SLOT_POS][2] = oz0;
	 v[1]->attrib[VARYING_SLOT_POS][2] = oz1;
	 v[2]->attrib[VARYING_SLOT_POS][2] = oz2;
      }
      _swsetup_render_tri(ctx, e0, e1, e2, facing, _swsetup_edge_render_point_tri);
   } else if (mode == GL_LINE) {
      if ((IND & SS_OFFSET_BIT) && ctx->Polygon.OffsetLine) {
	 v[0]->attrib[VARYING_SLOT_POS][2] = oz0;
	 v[1]->attrib[VARYING_SLOT_POS][2] = oz1;
	 v[2]->attrib[VARYING_SLOT_POS][2] = oz2;
      }
      _swsetup_render_tri(ctx, e0, e1, e2, facing, _swsetup_edge_render_line_tri);
   } else {
      if ((IND & SS_OFFSET_BIT) && ctx->Polygon.OffsetFill) {
	 v[0]->attrib[VARYING_SLOT_POS][2] = oz0;
	 v[1]->attrib[VARYING_SLOT_POS][2] = oz1;
	 v[2]->attrib[VARYING_SLOT_POS][2] = oz2;
      }
      _swrast_Triangle( ctx, v[0], v[1], v[2] );
   }

   /*
    * Restore original vertex colors, etc.
    */
   if (IND & SS_OFFSET_BIT) {
      v[0]->attrib[VARYING_SLOT_POS][2] = z[0];
      v[1]->attrib[VARYING_SLOT_POS][2] = z[1];
      v[2]->attrib[VARYING_SLOT_POS][2] = z[2];
   }

   if (IND & SS_TWOSIDE_BIT) {
      if (facing == 1) {
	if (VB->BackfaceColorPtr) {
	  if (swsetup->intColors) {
	    COPY_CHAN4(v[0]->color, saved_color[0]);
	    COPY_CHAN4(v[1]->color, saved_color[1]);
	    COPY_CHAN4(v[2]->color, saved_color[2]);
	  }
	  else {
	    COPY_4V(v[0]->attrib[VARYING_SLOT_COL0], saved_col0[0]);
	    COPY_4V(v[1]->attrib[VARYING_SLOT_COL0], saved_col0[1]);
	    COPY_4V(v[2]->attrib[VARYING_SLOT_COL0], saved_col0[2]);
	  }
	}

	if (VB->BackfaceSecondaryColorPtr) {
	  COPY_4V(v[0]->attrib[VARYING_SLOT_COL1], saved_spec[0]);
	  COPY_4V(v[1]->attrib[VARYING_SLOT_COL1], saved_spec[1]);
	  COPY_4V(v[2]->attrib[VARYING_SLOT_COL1], saved_spec[2]);
	}
      }
   }
}



/* Need to fixup edgeflags when decomposing to triangles:
 */
static void TAG(quadfunc)( struct gl_context *ctx, GLuint v0,
		       GLuint v1, GLuint v2, GLuint v3 )
{
   if (IND & SS_UNFILLED_BIT) {
      struct vertex_buffer *VB = &TNL_CONTEXT(ctx)->vb;
      if (VB->EdgeFlag) { /* XXX this test shouldn't be needed (bug 12614) */
         GLubyte ef1 = VB->EdgeFlag[v1];
         GLubyte ef3 = VB->EdgeFlag[v3];
         VB->EdgeFlag[v1] = 0;
         TAG(triangle)( ctx, v0, v1, v3 );
         VB->EdgeFlag[v1] = ef1;
         VB->EdgeFlag[v3] = 0;
         TAG(triangle)( ctx, v1, v2, v3 );
         VB->EdgeFlag[v3] = ef3;
      }
   } else {
      TAG(triangle)( ctx, v0, v1, v3 );
      TAG(triangle)( ctx, v1, v2, v3 );
   }
}




static void TAG(init)( void )
{
   tri_tab[IND] = TAG(triangle);
   quad_tab[IND] = TAG(quadfunc);
}


#undef IND
#undef TAG
@


1.8
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.7
log
@Merge Mesa 9.2.0
@
text
@d25 1
a25 1
 *    Keith Whitwell <keith@@tungstengraphics.com>
@


1.6
log
@Merge Mesa 7.10.3
@
text
@a2 1
 * Version:  7.1
d19 4
a22 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
d53 4
a56 4
      GLfloat ex = v[0]->attrib[FRAG_ATTRIB_WPOS][0] - v[2]->attrib[FRAG_ATTRIB_WPOS][0];
      GLfloat ey = v[0]->attrib[FRAG_ATTRIB_WPOS][1] - v[2]->attrib[FRAG_ATTRIB_WPOS][1];
      GLfloat fx = v[1]->attrib[FRAG_ATTRIB_WPOS][0] - v[2]->attrib[FRAG_ATTRIB_WPOS][0];
      GLfloat fy = v[1]->attrib[FRAG_ATTRIB_WPOS][1] - v[2]->attrib[FRAG_ATTRIB_WPOS][1];
d77 3
a79 3
                     COPY_4V(saved_col0[0], v[0]->attrib[FRAG_ATTRIB_COL0]);
                     COPY_4V(saved_col0[1], v[1]->attrib[FRAG_ATTRIB_COL0]);
                     COPY_4V(saved_col0[2], v[2]->attrib[FRAG_ATTRIB_COL0]);
d89 3
a91 3
                        COPY_4V(v[0]->attrib[FRAG_ATTRIB_COL0], vbcolor[e0]);
                        COPY_4V(v[1]->attrib[FRAG_ATTRIB_COL0], vbcolor[e1]);
                        COPY_4V(v[2]->attrib[FRAG_ATTRIB_COL0], vbcolor[e2]);
d102 3
a104 3
                        COPY_4V(v[0]->attrib[FRAG_ATTRIB_COL0], vbcolor[0]);
                        COPY_4V(v[1]->attrib[FRAG_ATTRIB_COL0], vbcolor[0]);
                        COPY_4V(v[2]->attrib[FRAG_ATTRIB_COL0], vbcolor[0]);
d112 3
a114 3
		  COPY_4V(saved_spec[0], v[0]->attrib[FRAG_ATTRIB_COL1]);
		  COPY_4V(saved_spec[1], v[1]->attrib[FRAG_ATTRIB_COL1]);
		  COPY_4V(saved_spec[2], v[2]->attrib[FRAG_ATTRIB_COL1]);
d117 3
a119 3
		    SS_SPEC(v[0]->attrib[FRAG_ATTRIB_COL1], vbspec[e0]);
		    SS_SPEC(v[1]->attrib[FRAG_ATTRIB_COL1], vbspec[e1]);
		    SS_SPEC(v[2]->attrib[FRAG_ATTRIB_COL1], vbspec[e2]);
d122 3
a124 3
		    SS_SPEC(v[0]->attrib[FRAG_ATTRIB_COL1], vbspec[0]);
		    SS_SPEC(v[1]->attrib[FRAG_ATTRIB_COL1], vbspec[0]);
		    SS_SPEC(v[2]->attrib[FRAG_ATTRIB_COL1], vbspec[0]);
d134 3
a136 3
	 z[0] = v[0]->attrib[FRAG_ATTRIB_WPOS][2];
	 z[1] = v[1]->attrib[FRAG_ATTRIB_WPOS][2];
	 z[2] = v[2]->attrib[FRAG_ATTRIB_WPOS][2];
d150 3
a152 3
         oz0 = CLAMP(v[0]->attrib[FRAG_ATTRIB_WPOS][2] + offset, 0.0F, max);
         oz1 = CLAMP(v[1]->attrib[FRAG_ATTRIB_WPOS][2] + offset, 0.0F, max);
         oz2 = CLAMP(v[2]->attrib[FRAG_ATTRIB_WPOS][2] + offset, 0.0F, max);
d158 3
a160 3
	 v[0]->attrib[FRAG_ATTRIB_WPOS][2] = oz0;
	 v[1]->attrib[FRAG_ATTRIB_WPOS][2] = oz1;
	 v[2]->attrib[FRAG_ATTRIB_WPOS][2] = oz2;
d165 3
a167 3
	 v[0]->attrib[FRAG_ATTRIB_WPOS][2] = oz0;
	 v[1]->attrib[FRAG_ATTRIB_WPOS][2] = oz1;
	 v[2]->attrib[FRAG_ATTRIB_WPOS][2] = oz2;
d172 3
a174 3
	 v[0]->attrib[FRAG_ATTRIB_WPOS][2] = oz0;
	 v[1]->attrib[FRAG_ATTRIB_WPOS][2] = oz1;
	 v[2]->attrib[FRAG_ATTRIB_WPOS][2] = oz2;
d183 3
a185 3
      v[0]->attrib[FRAG_ATTRIB_WPOS][2] = z[0];
      v[1]->attrib[FRAG_ATTRIB_WPOS][2] = z[1];
      v[2]->attrib[FRAG_ATTRIB_WPOS][2] = z[2];
d197 3
a199 3
	    COPY_4V(v[0]->attrib[FRAG_ATTRIB_COL0], saved_col0[0]);
	    COPY_4V(v[1]->attrib[FRAG_ATTRIB_COL0], saved_col0[1]);
	    COPY_4V(v[2]->attrib[FRAG_ATTRIB_COL0], saved_col0[2]);
d204 3
a206 3
	  COPY_4V(v[0]->attrib[FRAG_ATTRIB_COL1], saved_spec[0]);
	  COPY_4V(v[1]->attrib[FRAG_ATTRIB_COL1], saved_spec[1]);
	  COPY_4V(v[2]->attrib[FRAG_ATTRIB_COL1], saved_spec[2]);
@


1.5
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d33 1
a33 1
static void TAG(triangle)(GLcontext *ctx, GLuint e0, GLuint e1, GLuint e2 )
d216 1
a216 1
static void TAG(quadfunc)( GLcontext *ctx, GLuint v0,
@


1.4
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d43 3
a45 4
   GLchan saved_color[3][4];
   GLfloat saved_col0[3][4];
   GLfloat saved_spec[3][4];
   GLfloat saved_index[3];
d68 2
a69 3
	       if (IND & SS_RGBA_BIT) {
                  if (VB->ColorPtr[1]) {
                     GLfloat (*vbcolor)[4] = VB->ColorPtr[1]->data;
d71 12
d84 3
a86 3
                        COPY_CHAN4(saved_color[0], v[0]->color);
                        COPY_CHAN4(saved_color[1], v[1]->color);
                        COPY_CHAN4(saved_color[2], v[2]->color);
d89 3
a91 3
                        COPY_4V(saved_col0[0], v[0]->attrib[FRAG_ATTRIB_COL0]);
                        COPY_4V(saved_col0[1], v[1]->attrib[FRAG_ATTRIB_COL0]);
                        COPY_4V(saved_col0[2], v[2]->attrib[FRAG_ATTRIB_COL0]);
d93 7
a99 12

                     if (VB->ColorPtr[1]->stride) {
                        if (swsetup->intColors) {
                           SS_COLOR(v[0]->color, vbcolor[e0]);
                           SS_COLOR(v[1]->color, vbcolor[e1]);
                           SS_COLOR(v[2]->color, vbcolor[e2]);
                        }
                        else {
                           COPY_4V(v[0]->attrib[FRAG_ATTRIB_COL0], vbcolor[e0]);
                           COPY_4V(v[1]->attrib[FRAG_ATTRIB_COL0], vbcolor[e1]);
                           COPY_4V(v[2]->attrib[FRAG_ATTRIB_COL0], vbcolor[e2]);
                        }
d102 3
a104 11
                        /* flat shade */
                        if (swsetup->intColors) {
                           SS_COLOR(v[0]->color, vbcolor[0]);
                           SS_COLOR(v[1]->color, vbcolor[0]);
                           SS_COLOR(v[2]->color, vbcolor[0]);
                        }
                        else {
                           COPY_4V(v[0]->attrib[FRAG_ATTRIB_COL0], vbcolor[0]);
                           COPY_4V(v[1]->attrib[FRAG_ATTRIB_COL0], vbcolor[0]);
                           COPY_4V(v[2]->attrib[FRAG_ATTRIB_COL0], vbcolor[0]);
                        }
d107 1
d109 2
a110 2
		  if (VB->SecondaryColorPtr[1]) {
		     GLfloat (*vbspec)[4] = VB->SecondaryColorPtr[1]->data;
d112 13
a124 14
		     COPY_4V(saved_spec[0], v[0]->attrib[FRAG_ATTRIB_COL1]);
		     COPY_4V(saved_spec[1], v[1]->attrib[FRAG_ATTRIB_COL1]);
		     COPY_4V(saved_spec[2], v[2]->attrib[FRAG_ATTRIB_COL1]);

		     if (VB->SecondaryColorPtr[1]->stride) {
			SS_SPEC(v[0]->attrib[FRAG_ATTRIB_COL1], vbspec[e0]);
			SS_SPEC(v[1]->attrib[FRAG_ATTRIB_COL1], vbspec[e1]);
			SS_SPEC(v[2]->attrib[FRAG_ATTRIB_COL1], vbspec[e2]);
		     }
		     else {
			SS_SPEC(v[0]->attrib[FRAG_ATTRIB_COL1], vbspec[0]);
			SS_SPEC(v[1]->attrib[FRAG_ATTRIB_COL1], vbspec[0]);
			SS_SPEC(v[2]->attrib[FRAG_ATTRIB_COL1], vbspec[0]);
		     }
a125 9
	       } else {
		  GLfloat *vbindex = (GLfloat *)VB->IndexPtr[1]->data;
		  saved_index[0] = v[0]->attrib[FRAG_ATTRIB_CI][0];
		  saved_index[1] = v[1]->attrib[FRAG_ATTRIB_CI][0];
		  saved_index[2] = v[2]->attrib[FRAG_ATTRIB_CI][0];
		  
		  SS_IND(v[0]->attrib[FRAG_ATTRIB_CI][0], (GLuint) vbindex[e0]);
		  SS_IND(v[1]->attrib[FRAG_ATTRIB_CI][0], (GLuint) vbindex[e1]);
		  SS_IND(v[2]->attrib[FRAG_ATTRIB_CI][0], (GLuint) vbindex[e2]);
d150 3
a152 3
         oz0 = CLAMP(v[0]->attrib[FRAG_ATTRIB_WPOS][2] + offset, 0.0, max);
         oz1 = CLAMP(v[1]->attrib[FRAG_ATTRIB_WPOS][2] + offset, 0.0, max);
         oz2 = CLAMP(v[2]->attrib[FRAG_ATTRIB_WPOS][2] + offset, 0.0, max);
d162 1
a162 1
      _swsetup_render_point_tri( ctx, e0, e1, e2, facing );
d169 1
a169 1
      _swsetup_render_line_tri( ctx, e0, e1, e2, facing );
d190 18
a207 24
	 if (IND & SS_RGBA_BIT) {
            if (VB->ColorPtr[1]) {
               if (swsetup->intColors) {
                  COPY_CHAN4(v[0]->color, saved_color[0]);
                  COPY_CHAN4(v[1]->color, saved_color[1]);
                  COPY_CHAN4(v[2]->color, saved_color[2]);
               }
               else {
                  COPY_4V(v[0]->attrib[FRAG_ATTRIB_COL0], saved_col0[0]);
                  COPY_4V(v[1]->attrib[FRAG_ATTRIB_COL0], saved_col0[1]);
                  COPY_4V(v[2]->attrib[FRAG_ATTRIB_COL0], saved_col0[2]);
               }
            }

	    if (VB->SecondaryColorPtr[1]) {
	       COPY_4V(v[0]->attrib[FRAG_ATTRIB_COL1], saved_spec[0]);
	       COPY_4V(v[1]->attrib[FRAG_ATTRIB_COL1], saved_spec[1]);
	       COPY_4V(v[2]->attrib[FRAG_ATTRIB_COL1], saved_spec[2]);
	    }
	 } else {
	    v[0]->attrib[FRAG_ATTRIB_CI][0] = saved_index[0];
	    v[1]->attrib[FRAG_ATTRIB_CI][0] = saved_index[1];
	    v[2]->attrib[FRAG_ATTRIB_CI][0] = saved_index[2];
	 }
@


1.3
log
@Update to Mesa 7.0.3. tested my oga@@ and johan@@
@
text
@d3 1
a3 1
 * Version:  6.1
d5 1
a5 1
 * Copyright (C) 1999-2004  Brian Paul   All Rights Reserved.
d29 4
d36 1
d40 1
a40 1
   GLfloat offset;
d44 2
a45 1
   GLchan saved_spec[3][4];
d54 4
a57 4
      GLfloat ex = v[0]->win[0] - v[2]->win[0];
      GLfloat ey = v[0]->win[1] - v[2]->win[1];
      GLfloat fx = v[1]->win[0] - v[2]->win[0];
      GLfloat fy = v[1]->win[1] - v[2]->win[1];
d73 10
a82 3
                     COPY_CHAN4(saved_color[0], v[0]->color);
                     COPY_CHAN4(saved_color[1], v[1]->color);
                     COPY_CHAN4(saved_color[2], v[2]->color);
d85 10
a94 3
                        SS_COLOR(v[0]->color, vbcolor[e0]);
                        SS_COLOR(v[1]->color, vbcolor[e1]);
                        SS_COLOR(v[2]->color, vbcolor[e2]);
d97 11
a107 3
                        SS_COLOR(v[0]->color, vbcolor[0]);
                        SS_COLOR(v[1]->color, vbcolor[0]);
                        SS_COLOR(v[2]->color, vbcolor[0]);
d114 3
a116 3
		     COPY_CHAN4(saved_spec[0], v[0]->specular);
		     COPY_CHAN4(saved_spec[1], v[1]->specular);
		     COPY_CHAN4(saved_spec[2], v[2]->specular);
d119 3
a121 3
			SS_SPEC(v[0]->specular, vbspec[e0]);
			SS_SPEC(v[1]->specular, vbspec[e1]);
			SS_SPEC(v[2]->specular, vbspec[e2]);
d124 3
a126 3
			SS_SPEC(v[0]->specular, vbspec[0]);
			SS_SPEC(v[1]->specular, vbspec[0]);
			SS_SPEC(v[2]->specular, vbspec[0]);
d131 3
a133 3
		  saved_index[0] = v[0]->index;
		  saved_index[1] = v[1]->index;
		  saved_index[2] = v[2]->index;
d135 3
a137 3
		  SS_IND(v[0]->index, (GLuint) vbindex[e0]);
		  SS_IND(v[1]->index, (GLuint) vbindex[e1]);
		  SS_IND(v[2]->index, (GLuint) vbindex[e2]);
d143 10
a152 6
      if (IND & SS_OFFSET_BIT)
      {
	 offset = ctx->Polygon.OffsetUnits * ctx->DrawBuffer->_MRD;
	 z[0] = v[0]->win[2];
	 z[1] = v[1]->win[2];
	 z[2] = v[2]->win[2];
a159 6
            /* Unfortunately, we need to clamp to prevent negative Zs below.
             * Technically, we should do the clamping per-fragment.
             */
            offset = MAX2(offset, -v[0]->win[2]);
            offset = MAX2(offset, -v[1]->win[2]);
            offset = MAX2(offset, -v[2]->win[2]);
d161 4
d170 3
a172 3
	 v[0]->win[2] += offset;
	 v[1]->win[2] += offset;
	 v[2]->win[2] += offset;
d177 3
a179 3
	 v[0]->win[2] += offset;
	 v[1]->win[2] += offset;
	 v[2]->win[2] += offset;
d184 3
a186 3
	 v[0]->win[2] += offset;
	 v[1]->win[2] += offset;
	 v[2]->win[2] += offset;
d191 3
d195 3
a197 3
      v[0]->win[2] = z[0];
      v[1]->win[2] = z[1];
      v[2]->win[2] = z[2];
d204 10
a213 3
               COPY_CHAN4(v[0]->color, saved_color[0]);
               COPY_CHAN4(v[1]->color, saved_color[1]);
               COPY_CHAN4(v[2]->color, saved_color[2]);
d217 3
a219 3
	       COPY_CHAN4(v[0]->specular, saved_spec[0]);
	       COPY_CHAN4(v[1]->specular, saved_spec[1]);
	       COPY_CHAN4(v[2]->specular, saved_spec[2]);
d222 3
a224 3
	    v[0]->index = saved_index[0];
	    v[1]->index = saved_index[1];
	    v[2]->index = saved_index[2];
@


1.2
log
@Update to Mesa 7.0.2. Tested by naddy@@ (full ports build), simon@@
and oga@@ (with dri enabled).
@
text
@a45 1

a56 1
         ctx->_Facing = facing;
@


1.1
log
@Initial revision
@
text
@d58 1
a58 2
         if (ctx->Stencil.TestTwoSide)
            ctx->_Facing = facing; /* for 2-sided stencil test */
d66 2
a67 1
		  GLfloat (*vbcolor)[4] = VB->ColorPtr[1]->data;
d69 15
a83 14
		  COPY_CHAN4(saved_color[0], v[0]->color);
		  COPY_CHAN4(saved_color[1], v[1]->color);
		  COPY_CHAN4(saved_color[2], v[2]->color);

		  if (VB->ColorPtr[1]->stride) {
		     SS_COLOR(v[0]->color, vbcolor[e0]);
		     SS_COLOR(v[1]->color, vbcolor[e1]);
		     SS_COLOR(v[2]->color, vbcolor[e2]);
		  }
		  else {
		     SS_COLOR(v[0]->color, vbcolor[0]);
		     SS_COLOR(v[1]->color, vbcolor[0]);
		     SS_COLOR(v[2]->color, vbcolor[0]);
		  }
d172 6
a177 3
	    COPY_CHAN4(v[0]->color, saved_color[0]);
	    COPY_CHAN4(v[1]->color, saved_color[1]);
	    COPY_CHAN4(v[2]->color, saved_color[2]);
d201 10
a210 8
      GLubyte ef1 = VB->EdgeFlag[v1];
      GLubyte ef3 = VB->EdgeFlag[v3];
      VB->EdgeFlag[v1] = 0;
      TAG(triangle)( ctx, v0, v1, v3 );
      VB->EdgeFlag[v1] = ef1;
      VB->EdgeFlag[v3] = 0;
      TAG(triangle)( ctx, v1, v2, v3 );
      VB->EdgeFlag[v3] = ef3;
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@Mesa 7.0.1
@
text
@d58 2
a59 1
         ctx->_Facing = facing;
d67 1
a67 2
                  if (VB->ColorPtr[1]) {
                     GLfloat (*vbcolor)[4] = VB->ColorPtr[1]->data;
d69 14
a82 15
                     COPY_CHAN4(saved_color[0], v[0]->color);
                     COPY_CHAN4(saved_color[1], v[1]->color);
                     COPY_CHAN4(saved_color[2], v[2]->color);

                     if (VB->ColorPtr[1]->stride) {
                        SS_COLOR(v[0]->color, vbcolor[e0]);
                        SS_COLOR(v[1]->color, vbcolor[e1]);
                        SS_COLOR(v[2]->color, vbcolor[e2]);
                     }
                     else {
                        SS_COLOR(v[0]->color, vbcolor[0]);
                        SS_COLOR(v[1]->color, vbcolor[0]);
                        SS_COLOR(v[2]->color, vbcolor[0]);
                     }
                  }
d171 3
a173 6
            if (VB->ColorPtr[1]) {
               COPY_CHAN4(v[0]->color, saved_color[0]);
               COPY_CHAN4(v[1]->color, saved_color[1]);
               COPY_CHAN4(v[2]->color, saved_color[2]);
            }

@


1.1.1.3
log
@Import Mesa 7.10.3
@
text
@d3 1
a3 1
 * Version:  7.1
d5 1
a5 1
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
d29 1
a29 5
/**
 * This is where we handle assigning vertex colors based on front/back
 * facing, compute polygon offset and handle glPolygonMode().
 */
static void TAG(triangle)(struct gl_context *ctx, GLuint e0, GLuint e1, GLuint e2 )
a31 1
   SScontext *swsetup = SWSETUP_CONTEXT(ctx);
d35 1
a35 1
   GLfloat offset, oz0, oz1, oz2;
d38 3
a40 3
   GLchan saved_color[3][4] = { { 0 } };
   GLfloat saved_col0[3][4] = { { 0 } };
   GLfloat saved_spec[3][4] = { { 0 } };
d46 1
d49 4
a52 4
      GLfloat ex = v[0]->attrib[FRAG_ATTRIB_WPOS][0] - v[2]->attrib[FRAG_ATTRIB_WPOS][0];
      GLfloat ey = v[0]->attrib[FRAG_ATTRIB_WPOS][1] - v[2]->attrib[FRAG_ATTRIB_WPOS][1];
      GLfloat fx = v[1]->attrib[FRAG_ATTRIB_WPOS][0] - v[2]->attrib[FRAG_ATTRIB_WPOS][0];
      GLfloat fy = v[1]->attrib[FRAG_ATTRIB_WPOS][1] - v[2]->attrib[FRAG_ATTRIB_WPOS][1];
d58 1
d65 3
a67 2
               if (VB->BackfaceColorPtr) {
                  GLfloat (*vbcolor)[4] = VB->BackfaceColorPtr->data;
a68 1
                  if (swsetup->intColors) {
a71 6
                  }
                  else {
                     COPY_4V(saved_col0[0], v[0]->attrib[FRAG_ATTRIB_COL0]);
                     COPY_4V(saved_col0[1], v[1]->attrib[FRAG_ATTRIB_COL0]);
                     COPY_4V(saved_col0[2], v[2]->attrib[FRAG_ATTRIB_COL0]);
                  }
d73 1
a73 2
                  if (VB->BackfaceColorPtr->stride) {
                     if (swsetup->intColors) {
a78 8
                        COPY_4V(v[0]->attrib[FRAG_ATTRIB_COL0], vbcolor[e0]);
                        COPY_4V(v[1]->attrib[FRAG_ATTRIB_COL0], vbcolor[e1]);
                        COPY_4V(v[2]->attrib[FRAG_ATTRIB_COL0], vbcolor[e2]);
                     }
                  }
                  else {
                     /* flat shade */
                     if (swsetup->intColors) {
a82 5
                     else {
                        COPY_4V(v[0]->attrib[FRAG_ATTRIB_COL0], vbcolor[0]);
                        COPY_4V(v[1]->attrib[FRAG_ATTRIB_COL0], vbcolor[0]);
                        COPY_4V(v[2]->attrib[FRAG_ATTRIB_COL0], vbcolor[0]);
                     }
a83 1
               }
d85 2
a86 2
               if (VB->BackfaceSecondaryColorPtr) {
		  GLfloat (*vbspec)[4] = VB->BackfaceSecondaryColorPtr->data;
d88 14
a101 13
		  COPY_4V(saved_spec[0], v[0]->attrib[FRAG_ATTRIB_COL1]);
		  COPY_4V(saved_spec[1], v[1]->attrib[FRAG_ATTRIB_COL1]);
		  COPY_4V(saved_spec[2], v[2]->attrib[FRAG_ATTRIB_COL1]);

		  if (VB->BackfaceSecondaryColorPtr->stride) {
		    SS_SPEC(v[0]->attrib[FRAG_ATTRIB_COL1], vbspec[e0]);
		    SS_SPEC(v[1]->attrib[FRAG_ATTRIB_COL1], vbspec[e1]);
		    SS_SPEC(v[2]->attrib[FRAG_ATTRIB_COL1], vbspec[e2]);
		  }
		  else {
		    SS_SPEC(v[0]->attrib[FRAG_ATTRIB_COL1], vbspec[0]);
		    SS_SPEC(v[1]->attrib[FRAG_ATTRIB_COL1], vbspec[0]);
		    SS_SPEC(v[2]->attrib[FRAG_ATTRIB_COL1], vbspec[0]);
d103 9
d117 6
a122 10
      if (IND & SS_OFFSET_BIT) {
         const GLfloat max = ctx->DrawBuffer->_DepthMaxF;
         /* save original Z values (restored later) */
	 z[0] = v[0]->attrib[FRAG_ATTRIB_WPOS][2];
	 z[1] = v[1]->attrib[FRAG_ATTRIB_WPOS][2];
	 z[2] = v[2]->attrib[FRAG_ATTRIB_WPOS][2];
         /* Note that Z values are already scaled to [0,65535] (for example)
          * so no MRD value is used here.
          */
	 offset = ctx->Polygon.OffsetUnits;
d130 6
a136 4
         /* new Z values */
         oz0 = CLAMP(v[0]->attrib[FRAG_ATTRIB_WPOS][2] + offset, 0.0F, max);
         oz1 = CLAMP(v[1]->attrib[FRAG_ATTRIB_WPOS][2] + offset, 0.0F, max);
         oz2 = CLAMP(v[2]->attrib[FRAG_ATTRIB_WPOS][2] + offset, 0.0F, max);
d142 3
a144 3
	 v[0]->attrib[FRAG_ATTRIB_WPOS][2] = oz0;
	 v[1]->attrib[FRAG_ATTRIB_WPOS][2] = oz1;
	 v[2]->attrib[FRAG_ATTRIB_WPOS][2] = oz2;
d146 1
a146 1
      _swsetup_render_tri(ctx, e0, e1, e2, facing, _swsetup_edge_render_point_tri);
d149 3
a151 3
	 v[0]->attrib[FRAG_ATTRIB_WPOS][2] = oz0;
	 v[1]->attrib[FRAG_ATTRIB_WPOS][2] = oz1;
	 v[2]->attrib[FRAG_ATTRIB_WPOS][2] = oz2;
d153 1
a153 1
      _swsetup_render_tri(ctx, e0, e1, e2, facing, _swsetup_edge_render_line_tri);
d156 3
a158 3
	 v[0]->attrib[FRAG_ATTRIB_WPOS][2] = oz0;
	 v[1]->attrib[FRAG_ATTRIB_WPOS][2] = oz1;
	 v[2]->attrib[FRAG_ATTRIB_WPOS][2] = oz2;
a162 3
   /*
    * Restore original vertex colors, etc.
    */
d164 3
a166 3
      v[0]->attrib[FRAG_ATTRIB_WPOS][2] = z[0];
      v[1]->attrib[FRAG_ATTRIB_WPOS][2] = z[1];
      v[2]->attrib[FRAG_ATTRIB_WPOS][2] = z[2];
d171 17
a187 18
	if (VB->BackfaceColorPtr) {
	  if (swsetup->intColors) {
	    COPY_CHAN4(v[0]->color, saved_color[0]);
	    COPY_CHAN4(v[1]->color, saved_color[1]);
	    COPY_CHAN4(v[2]->color, saved_color[2]);
	  }
	  else {
	    COPY_4V(v[0]->attrib[FRAG_ATTRIB_COL0], saved_col0[0]);
	    COPY_4V(v[1]->attrib[FRAG_ATTRIB_COL0], saved_col0[1]);
	    COPY_4V(v[2]->attrib[FRAG_ATTRIB_COL0], saved_col0[2]);
	  }
	}

	if (VB->BackfaceSecondaryColorPtr) {
	  COPY_4V(v[0]->attrib[FRAG_ATTRIB_COL1], saved_spec[0]);
	  COPY_4V(v[1]->attrib[FRAG_ATTRIB_COL1], saved_spec[1]);
	  COPY_4V(v[2]->attrib[FRAG_ATTRIB_COL1], saved_spec[2]);
	}
d196 1
a196 1
static void TAG(quadfunc)( struct gl_context *ctx, GLuint v0,
d201 8
a208 10
      if (VB->EdgeFlag) { /* XXX this test shouldn't be needed (bug 12614) */
         GLubyte ef1 = VB->EdgeFlag[v1];
         GLubyte ef3 = VB->EdgeFlag[v3];
         VB->EdgeFlag[v1] = 0;
         TAG(triangle)( ctx, v0, v1, v3 );
         VB->EdgeFlag[v1] = ef1;
         VB->EdgeFlag[v3] = 0;
         TAG(triangle)( ctx, v1, v2, v3 );
         VB->EdgeFlag[v3] = ef3;
      }
@


1.1.1.4
log
@Import Mesa 9.2.0
@
text
@d3 1
d20 3
a22 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
d53 4
a56 4
      GLfloat ex = v[0]->attrib[VARYING_SLOT_POS][0] - v[2]->attrib[VARYING_SLOT_POS][0];
      GLfloat ey = v[0]->attrib[VARYING_SLOT_POS][1] - v[2]->attrib[VARYING_SLOT_POS][1];
      GLfloat fx = v[1]->attrib[VARYING_SLOT_POS][0] - v[2]->attrib[VARYING_SLOT_POS][0];
      GLfloat fy = v[1]->attrib[VARYING_SLOT_POS][1] - v[2]->attrib[VARYING_SLOT_POS][1];
d77 3
a79 3
                     COPY_4V(saved_col0[0], v[0]->attrib[VARYING_SLOT_COL0]);
                     COPY_4V(saved_col0[1], v[1]->attrib[VARYING_SLOT_COL0]);
                     COPY_4V(saved_col0[2], v[2]->attrib[VARYING_SLOT_COL0]);
d89 3
a91 3
                        COPY_4V(v[0]->attrib[VARYING_SLOT_COL0], vbcolor[e0]);
                        COPY_4V(v[1]->attrib[VARYING_SLOT_COL0], vbcolor[e1]);
                        COPY_4V(v[2]->attrib[VARYING_SLOT_COL0], vbcolor[e2]);
d102 3
a104 3
                        COPY_4V(v[0]->attrib[VARYING_SLOT_COL0], vbcolor[0]);
                        COPY_4V(v[1]->attrib[VARYING_SLOT_COL0], vbcolor[0]);
                        COPY_4V(v[2]->attrib[VARYING_SLOT_COL0], vbcolor[0]);
d112 3
a114 3
		  COPY_4V(saved_spec[0], v[0]->attrib[VARYING_SLOT_COL1]);
		  COPY_4V(saved_spec[1], v[1]->attrib[VARYING_SLOT_COL1]);
		  COPY_4V(saved_spec[2], v[2]->attrib[VARYING_SLOT_COL1]);
d117 3
a119 3
		    SS_SPEC(v[0]->attrib[VARYING_SLOT_COL1], vbspec[e0]);
		    SS_SPEC(v[1]->attrib[VARYING_SLOT_COL1], vbspec[e1]);
		    SS_SPEC(v[2]->attrib[VARYING_SLOT_COL1], vbspec[e2]);
d122 3
a124 3
		    SS_SPEC(v[0]->attrib[VARYING_SLOT_COL1], vbspec[0]);
		    SS_SPEC(v[1]->attrib[VARYING_SLOT_COL1], vbspec[0]);
		    SS_SPEC(v[2]->attrib[VARYING_SLOT_COL1], vbspec[0]);
d134 3
a136 3
	 z[0] = v[0]->attrib[VARYING_SLOT_POS][2];
	 z[1] = v[1]->attrib[VARYING_SLOT_POS][2];
	 z[2] = v[2]->attrib[VARYING_SLOT_POS][2];
d150 3
a152 3
         oz0 = CLAMP(v[0]->attrib[VARYING_SLOT_POS][2] + offset, 0.0F, max);
         oz1 = CLAMP(v[1]->attrib[VARYING_SLOT_POS][2] + offset, 0.0F, max);
         oz2 = CLAMP(v[2]->attrib[VARYING_SLOT_POS][2] + offset, 0.0F, max);
d158 3
a160 3
	 v[0]->attrib[VARYING_SLOT_POS][2] = oz0;
	 v[1]->attrib[VARYING_SLOT_POS][2] = oz1;
	 v[2]->attrib[VARYING_SLOT_POS][2] = oz2;
d165 3
a167 3
	 v[0]->attrib[VARYING_SLOT_POS][2] = oz0;
	 v[1]->attrib[VARYING_SLOT_POS][2] = oz1;
	 v[2]->attrib[VARYING_SLOT_POS][2] = oz2;
d172 3
a174 3
	 v[0]->attrib[VARYING_SLOT_POS][2] = oz0;
	 v[1]->attrib[VARYING_SLOT_POS][2] = oz1;
	 v[2]->attrib[VARYING_SLOT_POS][2] = oz2;
d183 3
a185 3
      v[0]->attrib[VARYING_SLOT_POS][2] = z[0];
      v[1]->attrib[VARYING_SLOT_POS][2] = z[1];
      v[2]->attrib[VARYING_SLOT_POS][2] = z[2];
d197 3
a199 3
	    COPY_4V(v[0]->attrib[VARYING_SLOT_COL0], saved_col0[0]);
	    COPY_4V(v[1]->attrib[VARYING_SLOT_COL0], saved_col0[1]);
	    COPY_4V(v[2]->attrib[VARYING_SLOT_COL0], saved_col0[2]);
d204 3
a206 3
	  COPY_4V(v[0]->attrib[VARYING_SLOT_COL1], saved_spec[0]);
	  COPY_4V(v[1]->attrib[VARYING_SLOT_COL1], saved_spec[1]);
	  COPY_4V(v[2]->attrib[VARYING_SLOT_COL1], saved_spec[2]);
@


1.1.1.5
log
@Import Mesa 10.2.3
@
text
@d25 1
a25 1
 *    Keith Whitwell <keithw@@vmware.com>
@


