head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.6
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.4
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.5
	v10_2_7:1.1.1.5
	OPENBSD_5_6:1.6.0.2
	OPENBSD_5_6_BASE:1.6
	v10_2_3:1.1.1.5
	OPENBSD_5_5:1.5.0.2
	OPENBSD_5_5_BASE:1.5
	v9_2_5:1.1.1.4
	v9_2_3:1.1.1.4
	v9_2_2:1.1.1.4
	v9_2_1:1.1.1.4
	v9_2_0:1.1.1.4
	OPENBSD_5_4:1.4.0.8
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.6
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.4
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	v7_10_3:1.1.1.3
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.6
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v7_0_1:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v6_5_2:1.1.1.1
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.12.23.05.17.55;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2014.07.09.21.09.01;	author jsg;	state Exp;
branches;
next	1.5;
commitid	WPD6rgPryPkvXOr9;

1.5
date	2013.09.05.14.06.56;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2011.10.23.13.37.46;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.05.22.20.06.36;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.23;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.51.38;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.51.38;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.32.22;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.10.23.13.29.49;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.09.05.13.17.44;	author jsg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2014.07.09.20.35.13;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@
/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2001  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Authors:
 *    Keith Whitwell <keithw@@vmware.com>
 */
#include "math/m_translate.h"

#if (HAVE_HW_VIEWPORT)
#define UNVIEWPORT_VARS
#define UNVIEWPORT_X(x) x
#define UNVIEWPORT_Y(x) x
#define UNVIEWPORT_Z(x) x
#endif

#ifndef LOCALVARS
#define LOCALVARS
#endif

#ifndef CHECK_HW_DIVIDE
#define CHECK_HW_DIVIDE 1
#endif

/* These don't need to be duplicated, but there's currently nowhere
 * really convenient to put them.  Need to build some actual .o files in
 * this directory?
 */
static void copy_pv_rgba4_spec5( struct gl_context *ctx, GLuint edst, GLuint esrc )
{
   LOCALVARS   
   GLubyte *verts = GET_VERTEX_STORE();
   GLuint size = GET_VERTEX_SIZE();
   GLuint *dst = (GLuint *)(verts + (edst * size));
   GLuint *src = (GLuint *)(verts + (esrc * size));
   dst[4] = src[4];
   dst[5] = src[5];
}

static void copy_pv_rgba4( struct gl_context *ctx, GLuint edst, GLuint esrc )
{
   LOCALVARS
   GLubyte *verts = GET_VERTEX_STORE();
   GLuint size = GET_VERTEX_SIZE();
   GLuint *dst = (GLuint *)(verts + (edst * size));
   GLuint *src = (GLuint *)(verts + (esrc * size));
   dst[4] = src[4];
}

static void copy_pv_rgba3( struct gl_context *ctx, GLuint edst, GLuint esrc )
{
   LOCALVARS
   GLubyte *verts = GET_VERTEX_STORE();
   GLuint size = GET_VERTEX_SIZE();
   GLuint *dst = (GLuint *)(verts + (edst * size));
   GLuint *src = (GLuint *)(verts + (esrc * size));
   dst[3] = src[3];
}


void TAG(translate_vertex)(struct gl_context *ctx,
			   const VERTEX *src,
			   SWvertex *dst)
{
   LOCALVARS
   GLuint format = GET_VERTEX_FORMAT();
   GLfloat *s = ctx->Viewport._WindowMap.m;
   UNVIEWPORT_VARS;

   if (format == TINY_VERTEX_FORMAT) {
      if (HAVE_HW_VIEWPORT) {
	 dst->attrib[VARYING_SLOT_POS][0] = s[0]  * src->v.x + s[12];
	 dst->attrib[VARYING_SLOT_POS][1] = s[5]  * src->v.y + s[13];
	 dst->attrib[VARYING_SLOT_POS][2] = s[10] * src->v.z + s[14];
	 dst->attrib[VARYING_SLOT_POS][3] = 1.0;
      } else {
	 dst->attrib[VARYING_SLOT_POS][0] = UNVIEWPORT_X( src->v.x );
	 dst->attrib[VARYING_SLOT_POS][1] = UNVIEWPORT_Y( src->v.y );
	 dst->attrib[VARYING_SLOT_POS][2] = UNVIEWPORT_Z( src->v.z );
	 dst->attrib[VARYING_SLOT_POS][3] = 1.0;
      }

      dst->color[0] = src->tv.color.red;
      dst->color[1] = src->tv.color.green;
      dst->color[2] = src->tv.color.blue;
      dst->color[3] = src->tv.color.alpha;
   }
   else {
      if (HAVE_HW_VIEWPORT) {
	 if (HAVE_HW_DIVIDE && CHECK_HW_DIVIDE) {
	    GLfloat oow = 1.0 / src->v.w;
	    dst->attrib[VARYING_SLOT_POS][0] = s[0]  * src->v.x * oow + s[12];
	    dst->attrib[VARYING_SLOT_POS][1] = s[5]  * src->v.y * oow + s[13];
	    dst->attrib[VARYING_SLOT_POS][2] = s[10] * src->v.z * oow + s[14];
	    dst->attrib[VARYING_SLOT_POS][3] = oow;
	 } else {
	    dst->attrib[VARYING_SLOT_POS][0] = s[0]  * src->v.x + s[12];
	    dst->attrib[VARYING_SLOT_POS][1] = s[5]  * src->v.y + s[13];
	    dst->attrib[VARYING_SLOT_POS][2] = s[10] * src->v.z + s[14];
	    dst->attrib[VARYING_SLOT_POS][3] = src->v.w;
	 }
      } else {
	 dst->attrib[VARYING_SLOT_POS][0] = UNVIEWPORT_X( src->v.x );
	 dst->attrib[VARYING_SLOT_POS][1] = UNVIEWPORT_Y( src->v.y );
	 dst->attrib[VARYING_SLOT_POS][2] = UNVIEWPORT_Z( src->v.z );
	 dst->attrib[VARYING_SLOT_POS][3] = src->v.w;
      }

      dst->color[0] = src->v.color.red;
      dst->color[1] = src->v.color.green;
      dst->color[2] = src->v.color.blue;
      dst->color[3] = src->v.color.alpha;

      dst->attrib[VARYING_SLOT_COL1][0] = UBYTE_TO_FLOAT(src->v.specular.red);
      dst->attrib[VARYING_SLOT_COL1][1] = UBYTE_TO_FLOAT(src->v.specular.green);
      dst->attrib[VARYING_SLOT_COL1][2] = UBYTE_TO_FLOAT(src->v.specular.blue);

      dst->attrib[VARYING_SLOT_FOGC][0] = UBYTE_TO_FLOAT(src->v.specular.alpha);

      if (HAVE_PTEX_VERTICES &&
	  ((HAVE_TEX2_VERTICES && format == PROJ_TEX3_VERTEX_FORMAT) ||
	   (format == PROJ_TEX1_VERTEX_FORMAT))) {

	 dst->attrib[VARYING_SLOT_TEX0][0] = src->pv.u0;
	 dst->attrib[VARYING_SLOT_TEX0][1] = src->pv.v0;
	 dst->attrib[VARYING_SLOT_TEX0][3] = src->pv.q0;

	 dst->attrib[VARYING_SLOT_TEX1][0] = src->pv.u1;
	 dst->attrib[VARYING_SLOT_TEX1][1] = src->pv.v1;
	 dst->attrib[VARYING_SLOT_TEX1][3] = src->pv.q1;

	 if (HAVE_TEX2_VERTICES) {
	    dst->attrib[VARYING_SLOT_TEX2][0] = src->pv.u2;
	    dst->attrib[VARYING_SLOT_TEX2][1] = src->pv.v2;
	    dst->attrib[VARYING_SLOT_TEX2][3] = src->pv.q2;
	 }

	 if (HAVE_TEX3_VERTICES) {
	    dst->attrib[VARYING_SLOT_TEX3][0] = src->pv.u3;
	    dst->attrib[VARYING_SLOT_TEX3][1] = src->pv.v3;
	    dst->attrib[VARYING_SLOT_TEX3][3] = src->pv.q3;
	 }
      }
      else {
	 dst->attrib[VARYING_SLOT_TEX0][0] = src->v.u0;
	 dst->attrib[VARYING_SLOT_TEX0][1] = src->v.v0;
	 dst->attrib[VARYING_SLOT_TEX0][3] = 1.0;

	 dst->attrib[VARYING_SLOT_TEX1][0] = src->v.u1;
	 dst->attrib[VARYING_SLOT_TEX1][1] = src->v.v1;
	 dst->attrib[VARYING_SLOT_TEX1][3] = 1.0;

	 if (HAVE_TEX2_VERTICES) {
	    dst->attrib[VARYING_SLOT_TEX2][0] = src->v.u2;
	    dst->attrib[VARYING_SLOT_TEX2][1] = src->v.v2;
	    dst->attrib[VARYING_SLOT_TEX2][3] = 1.0;
	 }

	 if (HAVE_TEX3_VERTICES) {
	    dst->attrib[VARYING_SLOT_TEX3][0] = src->v.u3;
	    dst->attrib[VARYING_SLOT_TEX3][1] = src->v.v3;
	    dst->attrib[VARYING_SLOT_TEX3][3] = 1.0;
	 }
      }
   }

   dst->pointSize = ctx->Point.Size;
}


/* prototype to silence warning */
void TAG(print_vertex)( struct gl_context *ctx, const VERTEX *v );


void TAG(print_vertex)( struct gl_context *ctx, const VERTEX *v )
{
   LOCALVARS
   GLuint format = GET_VERTEX_FORMAT();

   fprintf(stderr, "(%x) ", format);

   switch (format) {
#if HAVE_TINY_VERTICES
   case TINY_VERTEX_FORMAT:
      fprintf(stderr, "xyz %.4f,%.4f,%.4f rgba %x:%x:%x:%x\n",
	      v->v.x, v->v.y, v->v.z,
	      v->tv.color.red,
	      v->tv.color.green,
	      v->tv.color.blue,
	      v->tv.color.alpha);
      break;
#endif
#if HAVE_NOTEX_VERTICES
   case NOTEX_VERTEX_FORMAT:
      fprintf(stderr, "xyzw %.4f,%.4f,%.4f,%.4f rgba %x:%x:%x:%x spec %x:%x:%x:%x\n",
	      v->v.x, v->v.y, v->v.z, v->v.w,
	      v->v.color.red,
	      v->v.color.green,
	      v->v.color.blue,
	      v->v.color.alpha,
	      v->v.specular.red,
	      v->v.specular.green,
	      v->v.specular.blue,
	      v->v.specular.alpha);
      break;
#endif
#if HAVE_TEX0_VERTICES
   case TEX0_VERTEX_FORMAT:
      fprintf(stderr, "xyzw %.4f,%.4f,%.4f,%.4f rgba %x:%x:%x:%x st %.4f,%.4f\n",
	      v->v.x, v->v.y, v->v.z, v->v.w,
	      v->v.color.red,
	      v->v.color.green,
	      v->v.color.blue,
	      v->v.color.alpha,
	      v->v.u0,
	      v->v.v0);
      break;
#endif
#if HAVE_TEX1_VERTICES
   case TEX1_VERTEX_FORMAT:
      fprintf(stderr, "xyzw %.4f,%.4f,%.4f,%.4f rgba %x:%x:%x:%x st %.4f,%.4f st %.4f,%.4f\n",
	      v->v.x, v->v.y, v->v.z, v->v.w,
	      v->v.color.red,
	      v->v.color.green,
	      v->v.color.blue,
	      v->v.color.alpha,
	      v->v.u0,
	      v->v.v0,
	      v->v.u1,
	      v->v.u2);
      break;
#endif
#if HAVE_PTEX_VERTICES
   case PROJ_TEX1_VERTEX_FORMAT:
      fprintf(stderr, "xyzw %.4f,%.4f,%.4f,%.4f rgba %x:%x:%x:%x stq %.4f,%.4f,%.4f stq %.4f,%.4f,%.4f\n",
	      v->v.x, v->v.y, v->v.z, v->v.w,
	      v->v.color.red,
	      v->v.color.green,
	      v->v.color.blue,
	      v->v.color.alpha,
	      v->pv.u0,
	      v->pv.v0,
	      v->pv.q0,
	      v->pv.u1,
	      v->pv.v1,
	      v->pv.q1);
      break;
#endif      
   default:
      fprintf(stderr, "???\n");
      break;
   }

   fprintf(stderr, "\n");
}



/* Interpolate the elements of the VB not included in typical hardware
 * vertices.  
 *
 * NOTE: All these arrays are guarenteed by tnl to be writeable and
 * have good stride.
 */
#ifndef INTERP_QUALIFIER 
#define INTERP_QUALIFIER static
#endif

#define GET_COLOR(ptr, idx) ((ptr)->data[idx])


INTERP_QUALIFIER void TAG(interp_extras)( struct gl_context *ctx,
					  GLfloat t,
					  GLuint dst, GLuint out, GLuint in,
					  GLboolean force_boundary )
{
   LOCALVARS
   struct vertex_buffer *VB = &TNL_CONTEXT(ctx)->vb;

   if (VB->BackfaceColorPtr) {
      assert(VB->BackfaceColorPtr->stride == 4 * sizeof(GLfloat));

      INTERP_4F( t,
		    GET_COLOR(VB->BackfaceColorPtr, dst),
		    GET_COLOR(VB->BackfaceColorPtr, out),
		    GET_COLOR(VB->BackfaceColorPtr, in) );

      if (VB->BackfaceSecondaryColorPtr) {
	 INTERP_3F( t,
		       GET_COLOR(VB->BackfaceSecondaryColorPtr, dst),
		       GET_COLOR(VB->BackfaceSecondaryColorPtr, out),
		       GET_COLOR(VB->BackfaceSecondaryColorPtr, in) );
      }
   }

   if (VB->EdgeFlag) {
      VB->EdgeFlag[dst] = VB->EdgeFlag[out] || force_boundary;
   }

   INTERP_VERTEX(ctx, t, dst, out, in, force_boundary);
}

INTERP_QUALIFIER void TAG(copy_pv_extras)( struct gl_context *ctx, 
					   GLuint dst, GLuint src )
{
   LOCALVARS
      struct vertex_buffer *VB = &TNL_CONTEXT(ctx)->vb;

   if (VB->BackfaceColorPtr) {
      COPY_4FV( GET_COLOR(VB->BackfaceColorPtr, dst),
		GET_COLOR(VB->BackfaceColorPtr, src) );

      if (VB->BackfaceSecondaryColorPtr) {
	 COPY_4FV( GET_COLOR(VB->BackfaceSecondaryColorPtr, dst),
		   GET_COLOR(VB->BackfaceSecondaryColorPtr, src) );
      }
   }

   COPY_PV_VERTEX(ctx, dst, src);
}


#undef INTERP_QUALIFIER
#undef GET_COLOR

#undef IND
#undef TAG
@


1.6
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.5
log
@Merge Mesa 9.2.0
@
text
@d26 1
a26 1
 *    Keith Whitwell <keith@@tungstengraphics.com>
@


1.4
log
@Merge Mesa 7.10.3
@
text
@a3 1
 * Version:  3.5
d20 4
a23 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
d92 4
a95 4
	 dst->attrib[FRAG_ATTRIB_WPOS][0] = s[0]  * src->v.x + s[12];
	 dst->attrib[FRAG_ATTRIB_WPOS][1] = s[5]  * src->v.y + s[13];
	 dst->attrib[FRAG_ATTRIB_WPOS][2] = s[10] * src->v.z + s[14];
	 dst->attrib[FRAG_ATTRIB_WPOS][3] = 1.0;
d97 4
a100 4
	 dst->attrib[FRAG_ATTRIB_WPOS][0] = UNVIEWPORT_X( src->v.x );
	 dst->attrib[FRAG_ATTRIB_WPOS][1] = UNVIEWPORT_Y( src->v.y );
	 dst->attrib[FRAG_ATTRIB_WPOS][2] = UNVIEWPORT_Z( src->v.z );
	 dst->attrib[FRAG_ATTRIB_WPOS][3] = 1.0;
d112 4
a115 4
	    dst->attrib[FRAG_ATTRIB_WPOS][0] = s[0]  * src->v.x * oow + s[12];
	    dst->attrib[FRAG_ATTRIB_WPOS][1] = s[5]  * src->v.y * oow + s[13];
	    dst->attrib[FRAG_ATTRIB_WPOS][2] = s[10] * src->v.z * oow + s[14];
	    dst->attrib[FRAG_ATTRIB_WPOS][3] = oow;
d117 4
a120 4
	    dst->attrib[FRAG_ATTRIB_WPOS][0] = s[0]  * src->v.x + s[12];
	    dst->attrib[FRAG_ATTRIB_WPOS][1] = s[5]  * src->v.y + s[13];
	    dst->attrib[FRAG_ATTRIB_WPOS][2] = s[10] * src->v.z + s[14];
	    dst->attrib[FRAG_ATTRIB_WPOS][3] = src->v.w;
d123 4
a126 4
	 dst->attrib[FRAG_ATTRIB_WPOS][0] = UNVIEWPORT_X( src->v.x );
	 dst->attrib[FRAG_ATTRIB_WPOS][1] = UNVIEWPORT_Y( src->v.y );
	 dst->attrib[FRAG_ATTRIB_WPOS][2] = UNVIEWPORT_Z( src->v.z );
	 dst->attrib[FRAG_ATTRIB_WPOS][3] = src->v.w;
d134 3
a136 3
      dst->attrib[FRAG_ATTRIB_COL1][0] = UBYTE_TO_FLOAT(src->v.specular.red);
      dst->attrib[FRAG_ATTRIB_COL1][1] = UBYTE_TO_FLOAT(src->v.specular.green);
      dst->attrib[FRAG_ATTRIB_COL1][2] = UBYTE_TO_FLOAT(src->v.specular.blue);
d138 1
a138 1
      dst->attrib[FRAG_ATTRIB_FOGC][0] = UBYTE_TO_FLOAT(src->v.specular.alpha);
d144 7
a150 7
	 dst->attrib[FRAG_ATTRIB_TEX0][0] = src->pv.u0;
	 dst->attrib[FRAG_ATTRIB_TEX0][1] = src->pv.v0;
	 dst->attrib[FRAG_ATTRIB_TEX0][3] = src->pv.q0;

	 dst->attrib[FRAG_ATTRIB_TEX1][0] = src->pv.u1;
	 dst->attrib[FRAG_ATTRIB_TEX1][1] = src->pv.v1;
	 dst->attrib[FRAG_ATTRIB_TEX1][3] = src->pv.q1;
d153 3
a155 3
	    dst->attrib[FRAG_ATTRIB_TEX2][0] = src->pv.u2;
	    dst->attrib[FRAG_ATTRIB_TEX2][1] = src->pv.v2;
	    dst->attrib[FRAG_ATTRIB_TEX2][3] = src->pv.q2;
d159 3
a161 3
	    dst->attrib[FRAG_ATTRIB_TEX3][0] = src->pv.u3;
	    dst->attrib[FRAG_ATTRIB_TEX3][1] = src->pv.v3;
	    dst->attrib[FRAG_ATTRIB_TEX3][3] = src->pv.q3;
d165 7
a171 7
	 dst->attrib[FRAG_ATTRIB_TEX0][0] = src->v.u0;
	 dst->attrib[FRAG_ATTRIB_TEX0][1] = src->v.v0;
	 dst->attrib[FRAG_ATTRIB_TEX0][3] = 1.0;

	 dst->attrib[FRAG_ATTRIB_TEX1][0] = src->v.u1;
	 dst->attrib[FRAG_ATTRIB_TEX1][1] = src->v.v1;
	 dst->attrib[FRAG_ATTRIB_TEX1][3] = 1.0;
d174 3
a176 3
	    dst->attrib[FRAG_ATTRIB_TEX2][0] = src->v.u2;
	    dst->attrib[FRAG_ATTRIB_TEX2][1] = src->v.v2;
	    dst->attrib[FRAG_ATTRIB_TEX2][3] = 1.0;
d180 3
a182 3
	    dst->attrib[FRAG_ATTRIB_TEX3][0] = src->v.u3;
	    dst->attrib[FRAG_ATTRIB_TEX3][1] = src->v.v3;
	    dst->attrib[FRAG_ATTRIB_TEX3][3] = 1.0;
@


1.3
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d49 1
a49 1
static void copy_pv_rgba4_spec5( GLcontext *ctx, GLuint edst, GLuint esrc )
d60 1
a60 1
static void copy_pv_rgba4( GLcontext *ctx, GLuint edst, GLuint esrc )
d70 1
a70 1
static void copy_pv_rgba3( GLcontext *ctx, GLuint edst, GLuint esrc )
d81 1
a81 1
void TAG(translate_vertex)(GLcontext *ctx,
d192 1
a192 1
void TAG(print_vertex)( GLcontext *ctx, const VERTEX *v );
d195 1
a195 1
void TAG(print_vertex)( GLcontext *ctx, const VERTEX *v )
d292 1
a292 1
INTERP_QUALIFIER void TAG(interp_extras)( GLcontext *ctx,
d323 1
a323 1
INTERP_QUALIFIER void TAG(copy_pv_extras)( GLcontext *ctx, 
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d191 3
d300 2
a301 2
   if (VB->ColorPtr[1]) {
      assert(VB->ColorPtr[1]->stride == 4 * sizeof(GLfloat));
d304 3
a306 3
		    GET_COLOR(VB->ColorPtr[1], dst),
		    GET_COLOR(VB->ColorPtr[1], out),
		    GET_COLOR(VB->ColorPtr[1], in) );
d308 1
a308 1
      if (VB->SecondaryColorPtr[1]) {
d310 3
a312 3
		       GET_COLOR(VB->SecondaryColorPtr[1], dst),
		       GET_COLOR(VB->SecondaryColorPtr[1], out),
		       GET_COLOR(VB->SecondaryColorPtr[1], in) );
d329 7
a335 7
   if (VB->ColorPtr[1]) {
      COPY_4FV( GET_COLOR(VB->ColorPtr[1], dst), 
		GET_COLOR(VB->ColorPtr[1], src) );

      if (VB->SecondaryColorPtr[1]) {
	 COPY_4FV( GET_COLOR(VB->SecondaryColorPtr[1], dst), 
		   GET_COLOR(VB->SecondaryColorPtr[1], src) );
@


1.1
log
@Initial revision
@
text
@d92 4
a95 4
	 dst->win[0] = s[0]  * src->v.x + s[12];
	 dst->win[1] = s[5]  * src->v.y + s[13];
	 dst->win[2] = s[10] * src->v.z + s[14];
	 dst->win[3] = 1.0;
d97 4
a100 4
	 dst->win[0] = UNVIEWPORT_X( src->v.x );
	 dst->win[1] = UNVIEWPORT_Y( src->v.y );
	 dst->win[2] = UNVIEWPORT_Z( src->v.z );
	 dst->win[3] = 1.0;
d112 4
a115 4
	    dst->win[0] = s[0]  * src->v.x * oow + s[12];
	    dst->win[1] = s[5]  * src->v.y * oow + s[13];
	    dst->win[2] = s[10] * src->v.z * oow + s[14];
	    dst->win[3] = oow;
d117 4
a120 4
	    dst->win[0] = s[0]  * src->v.x + s[12];
	    dst->win[1] = s[5]  * src->v.y + s[13];
	    dst->win[2] = s[10] * src->v.z + s[14];
	    dst->win[3] = src->v.w;
d123 4
a126 4
	 dst->win[0] = UNVIEWPORT_X( src->v.x );
	 dst->win[1] = UNVIEWPORT_Y( src->v.y );
	 dst->win[2] = UNVIEWPORT_Z( src->v.z );
	 dst->win[3] = src->v.w;
d134 3
a136 3
      dst->specular[0] = src->v.specular.red;
      dst->specular[1] = src->v.specular.green;
      dst->specular[2] = src->v.specular.blue;
d138 1
a138 1
      dst->fog = src->v.specular.alpha/255.0;
d144 7
a150 7
	 dst->texcoord[0][0] = src->pv.u0;
	 dst->texcoord[0][1] = src->pv.v0;
	 dst->texcoord[0][3] = src->pv.q0;

	 dst->texcoord[1][0] = src->pv.u1;
	 dst->texcoord[1][1] = src->pv.v1;
	 dst->texcoord[1][3] = src->pv.q1;
d153 3
a155 3
	    dst->texcoord[2][0] = src->pv.u2;
	    dst->texcoord[2][1] = src->pv.v2;
	    dst->texcoord[2][3] = src->pv.q2;
d159 3
a161 3
	    dst->texcoord[3][0] = src->pv.u3;
	    dst->texcoord[3][1] = src->pv.v3;
	    dst->texcoord[3][3] = src->pv.q3;
d165 7
a171 7
	 dst->texcoord[0][0] = src->v.u0;
	 dst->texcoord[0][1] = src->v.v0;
	 dst->texcoord[0][3] = 1.0;

	 dst->texcoord[1][0] = src->v.u1;
	 dst->texcoord[1][1] = src->v.v1;
	 dst->texcoord[1][3] = 1.0;
d174 3
a176 3
	    dst->texcoord[2][0] = src->v.u2;
	    dst->texcoord[2][1] = src->v.v2;
	    dst->texcoord[2][3] = 1.0;
d180 3
a182 3
	    dst->texcoord[3][0] = src->v.u3;
	    dst->texcoord[3][1] = src->v.v3;
	    dst->texcoord[3][3] = 1.0;
d187 1
a187 1
   dst->pointSize = ctx->Point._Size;
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@Mesa 7.0.1
@
text
@d138 1
a138 1
      dst->attrib[FRAG_ATTRIB_FOGC][0] = src->v.specular.alpha/255.0;
d144 7
a150 7
	 dst->attrib[FRAG_ATTRIB_TEX0][0] = src->pv.u0;
	 dst->attrib[FRAG_ATTRIB_TEX0][1] = src->pv.v0;
	 dst->attrib[FRAG_ATTRIB_TEX0][3] = src->pv.q0;

	 dst->attrib[FRAG_ATTRIB_TEX1][0] = src->pv.u1;
	 dst->attrib[FRAG_ATTRIB_TEX1][1] = src->pv.v1;
	 dst->attrib[FRAG_ATTRIB_TEX1][3] = src->pv.q1;
d153 3
a155 3
	    dst->attrib[FRAG_ATTRIB_TEX2][0] = src->pv.u2;
	    dst->attrib[FRAG_ATTRIB_TEX2][1] = src->pv.v2;
	    dst->attrib[FRAG_ATTRIB_TEX2][3] = src->pv.q2;
d159 3
a161 3
	    dst->attrib[FRAG_ATTRIB_TEX3][0] = src->pv.u3;
	    dst->attrib[FRAG_ATTRIB_TEX3][1] = src->pv.v3;
	    dst->attrib[FRAG_ATTRIB_TEX3][3] = src->pv.q3;
d165 7
a171 7
	 dst->attrib[FRAG_ATTRIB_TEX0][0] = src->v.u0;
	 dst->attrib[FRAG_ATTRIB_TEX0][1] = src->v.v0;
	 dst->attrib[FRAG_ATTRIB_TEX0][3] = 1.0;

	 dst->attrib[FRAG_ATTRIB_TEX1][0] = src->v.u1;
	 dst->attrib[FRAG_ATTRIB_TEX1][1] = src->v.v1;
	 dst->attrib[FRAG_ATTRIB_TEX1][3] = 1.0;
d174 3
a176 3
	    dst->attrib[FRAG_ATTRIB_TEX2][0] = src->v.u2;
	    dst->attrib[FRAG_ATTRIB_TEX2][1] = src->v.v2;
	    dst->attrib[FRAG_ATTRIB_TEX2][3] = 1.0;
d180 3
a182 3
	    dst->attrib[FRAG_ATTRIB_TEX3][0] = src->v.u3;
	    dst->attrib[FRAG_ATTRIB_TEX3][1] = src->v.v3;
	    dst->attrib[FRAG_ATTRIB_TEX3][3] = 1.0;
@


1.1.1.3
log
@Import Mesa 7.10.3
@
text
@d49 1
a49 1
static void copy_pv_rgba4_spec5( struct gl_context *ctx, GLuint edst, GLuint esrc )
d60 1
a60 1
static void copy_pv_rgba4( struct gl_context *ctx, GLuint edst, GLuint esrc )
d70 1
a70 1
static void copy_pv_rgba3( struct gl_context *ctx, GLuint edst, GLuint esrc )
d81 1
a81 1
void TAG(translate_vertex)(struct gl_context *ctx,
d92 4
a95 4
	 dst->attrib[FRAG_ATTRIB_WPOS][0] = s[0]  * src->v.x + s[12];
	 dst->attrib[FRAG_ATTRIB_WPOS][1] = s[5]  * src->v.y + s[13];
	 dst->attrib[FRAG_ATTRIB_WPOS][2] = s[10] * src->v.z + s[14];
	 dst->attrib[FRAG_ATTRIB_WPOS][3] = 1.0;
d97 4
a100 4
	 dst->attrib[FRAG_ATTRIB_WPOS][0] = UNVIEWPORT_X( src->v.x );
	 dst->attrib[FRAG_ATTRIB_WPOS][1] = UNVIEWPORT_Y( src->v.y );
	 dst->attrib[FRAG_ATTRIB_WPOS][2] = UNVIEWPORT_Z( src->v.z );
	 dst->attrib[FRAG_ATTRIB_WPOS][3] = 1.0;
d112 4
a115 4
	    dst->attrib[FRAG_ATTRIB_WPOS][0] = s[0]  * src->v.x * oow + s[12];
	    dst->attrib[FRAG_ATTRIB_WPOS][1] = s[5]  * src->v.y * oow + s[13];
	    dst->attrib[FRAG_ATTRIB_WPOS][2] = s[10] * src->v.z * oow + s[14];
	    dst->attrib[FRAG_ATTRIB_WPOS][3] = oow;
d117 4
a120 4
	    dst->attrib[FRAG_ATTRIB_WPOS][0] = s[0]  * src->v.x + s[12];
	    dst->attrib[FRAG_ATTRIB_WPOS][1] = s[5]  * src->v.y + s[13];
	    dst->attrib[FRAG_ATTRIB_WPOS][2] = s[10] * src->v.z + s[14];
	    dst->attrib[FRAG_ATTRIB_WPOS][3] = src->v.w;
d123 4
a126 4
	 dst->attrib[FRAG_ATTRIB_WPOS][0] = UNVIEWPORT_X( src->v.x );
	 dst->attrib[FRAG_ATTRIB_WPOS][1] = UNVIEWPORT_Y( src->v.y );
	 dst->attrib[FRAG_ATTRIB_WPOS][2] = UNVIEWPORT_Z( src->v.z );
	 dst->attrib[FRAG_ATTRIB_WPOS][3] = src->v.w;
d134 3
a136 3
      dst->attrib[FRAG_ATTRIB_COL1][0] = UBYTE_TO_FLOAT(src->v.specular.red);
      dst->attrib[FRAG_ATTRIB_COL1][1] = UBYTE_TO_FLOAT(src->v.specular.green);
      dst->attrib[FRAG_ATTRIB_COL1][2] = UBYTE_TO_FLOAT(src->v.specular.blue);
d138 1
a138 1
      dst->attrib[FRAG_ATTRIB_FOGC][0] = UBYTE_TO_FLOAT(src->v.specular.alpha);
d187 1
a187 1
   dst->pointSize = ctx->Point.Size;
a190 2
/* prototype to silence warning */
void TAG(print_vertex)( struct gl_context *ctx, const VERTEX *v );
d192 1
a192 2

void TAG(print_vertex)( struct gl_context *ctx, const VERTEX *v )
d289 1
a289 1
INTERP_QUALIFIER void TAG(interp_extras)( struct gl_context *ctx,
d297 2
a298 2
   if (VB->BackfaceColorPtr) {
      assert(VB->BackfaceColorPtr->stride == 4 * sizeof(GLfloat));
d301 3
a303 3
		    GET_COLOR(VB->BackfaceColorPtr, dst),
		    GET_COLOR(VB->BackfaceColorPtr, out),
		    GET_COLOR(VB->BackfaceColorPtr, in) );
d305 1
a305 1
      if (VB->BackfaceSecondaryColorPtr) {
d307 3
a309 3
		       GET_COLOR(VB->BackfaceSecondaryColorPtr, dst),
		       GET_COLOR(VB->BackfaceSecondaryColorPtr, out),
		       GET_COLOR(VB->BackfaceSecondaryColorPtr, in) );
d320 1
a320 1
INTERP_QUALIFIER void TAG(copy_pv_extras)( struct gl_context *ctx, 
d326 7
a332 7
   if (VB->BackfaceColorPtr) {
      COPY_4FV( GET_COLOR(VB->BackfaceColorPtr, dst),
		GET_COLOR(VB->BackfaceColorPtr, src) );

      if (VB->BackfaceSecondaryColorPtr) {
	 COPY_4FV( GET_COLOR(VB->BackfaceSecondaryColorPtr, dst),
		   GET_COLOR(VB->BackfaceSecondaryColorPtr, src) );
@


1.1.1.4
log
@Import Mesa 9.2.0
@
text
@d4 1
d21 3
a23 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
d92 4
a95 4
	 dst->attrib[VARYING_SLOT_POS][0] = s[0]  * src->v.x + s[12];
	 dst->attrib[VARYING_SLOT_POS][1] = s[5]  * src->v.y + s[13];
	 dst->attrib[VARYING_SLOT_POS][2] = s[10] * src->v.z + s[14];
	 dst->attrib[VARYING_SLOT_POS][3] = 1.0;
d97 4
a100 4
	 dst->attrib[VARYING_SLOT_POS][0] = UNVIEWPORT_X( src->v.x );
	 dst->attrib[VARYING_SLOT_POS][1] = UNVIEWPORT_Y( src->v.y );
	 dst->attrib[VARYING_SLOT_POS][2] = UNVIEWPORT_Z( src->v.z );
	 dst->attrib[VARYING_SLOT_POS][3] = 1.0;
d112 4
a115 4
	    dst->attrib[VARYING_SLOT_POS][0] = s[0]  * src->v.x * oow + s[12];
	    dst->attrib[VARYING_SLOT_POS][1] = s[5]  * src->v.y * oow + s[13];
	    dst->attrib[VARYING_SLOT_POS][2] = s[10] * src->v.z * oow + s[14];
	    dst->attrib[VARYING_SLOT_POS][3] = oow;
d117 4
a120 4
	    dst->attrib[VARYING_SLOT_POS][0] = s[0]  * src->v.x + s[12];
	    dst->attrib[VARYING_SLOT_POS][1] = s[5]  * src->v.y + s[13];
	    dst->attrib[VARYING_SLOT_POS][2] = s[10] * src->v.z + s[14];
	    dst->attrib[VARYING_SLOT_POS][3] = src->v.w;
d123 4
a126 4
	 dst->attrib[VARYING_SLOT_POS][0] = UNVIEWPORT_X( src->v.x );
	 dst->attrib[VARYING_SLOT_POS][1] = UNVIEWPORT_Y( src->v.y );
	 dst->attrib[VARYING_SLOT_POS][2] = UNVIEWPORT_Z( src->v.z );
	 dst->attrib[VARYING_SLOT_POS][3] = src->v.w;
d134 3
a136 3
      dst->attrib[VARYING_SLOT_COL1][0] = UBYTE_TO_FLOAT(src->v.specular.red);
      dst->attrib[VARYING_SLOT_COL1][1] = UBYTE_TO_FLOAT(src->v.specular.green);
      dst->attrib[VARYING_SLOT_COL1][2] = UBYTE_TO_FLOAT(src->v.specular.blue);
d138 1
a138 1
      dst->attrib[VARYING_SLOT_FOGC][0] = UBYTE_TO_FLOAT(src->v.specular.alpha);
d144 7
a150 7
	 dst->attrib[VARYING_SLOT_TEX0][0] = src->pv.u0;
	 dst->attrib[VARYING_SLOT_TEX0][1] = src->pv.v0;
	 dst->attrib[VARYING_SLOT_TEX0][3] = src->pv.q0;

	 dst->attrib[VARYING_SLOT_TEX1][0] = src->pv.u1;
	 dst->attrib[VARYING_SLOT_TEX1][1] = src->pv.v1;
	 dst->attrib[VARYING_SLOT_TEX1][3] = src->pv.q1;
d153 3
a155 3
	    dst->attrib[VARYING_SLOT_TEX2][0] = src->pv.u2;
	    dst->attrib[VARYING_SLOT_TEX2][1] = src->pv.v2;
	    dst->attrib[VARYING_SLOT_TEX2][3] = src->pv.q2;
d159 3
a161 3
	    dst->attrib[VARYING_SLOT_TEX3][0] = src->pv.u3;
	    dst->attrib[VARYING_SLOT_TEX3][1] = src->pv.v3;
	    dst->attrib[VARYING_SLOT_TEX3][3] = src->pv.q3;
d165 7
a171 7
	 dst->attrib[VARYING_SLOT_TEX0][0] = src->v.u0;
	 dst->attrib[VARYING_SLOT_TEX0][1] = src->v.v0;
	 dst->attrib[VARYING_SLOT_TEX0][3] = 1.0;

	 dst->attrib[VARYING_SLOT_TEX1][0] = src->v.u1;
	 dst->attrib[VARYING_SLOT_TEX1][1] = src->v.v1;
	 dst->attrib[VARYING_SLOT_TEX1][3] = 1.0;
d174 3
a176 3
	    dst->attrib[VARYING_SLOT_TEX2][0] = src->v.u2;
	    dst->attrib[VARYING_SLOT_TEX2][1] = src->v.v2;
	    dst->attrib[VARYING_SLOT_TEX2][3] = 1.0;
d180 3
a182 3
	    dst->attrib[VARYING_SLOT_TEX3][0] = src->v.u3;
	    dst->attrib[VARYING_SLOT_TEX3][1] = src->v.v3;
	    dst->attrib[VARYING_SLOT_TEX3][3] = 1.0;
@


1.1.1.5
log
@Import Mesa 10.2.3
@
text
@d26 1
a26 1
 *    Keith Whitwell <keithw@@vmware.com>
@


