head	1.6;
access;
symbols
	OPENBSD_5_8:1.5.0.6
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.4
	OPENBSD_5_7_BASE:1.5
	v10_2_9:1.1.1.4
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.4
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.4
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.3
	v9_2_3:1.1.1.3
	v9_2_2:1.1.1.3
	v9_2_1:1.1.1.3
	v9_2_0:1.1.1.3
	OPENBSD_5_4:1.3.0.8
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.6
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.4
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.2
	v7_10_3:1.1.1.2
	OPENBSD_5_0:1.2.0.6
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.1.1.0.12
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.10
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v7_0_1:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v6_5_2:1.1.1.1
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.12.23.05.17.55;	author jsg;	state dead;
branches;
next	1.5;
commitid	TnlogFl9nOv2eaRf;

1.5
date	2014.07.09.21.09.01;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.06.55;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2011.10.23.13.37.46;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.05.22.20.06.36;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.51.37;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.51.37;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2011.10.23.13.29.49;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2013.09.05.13.17.43;	author jsg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.07.09.20.35.13;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.6
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Authors:
 *    Keith Whitwell <keithw@@vmware.com>
 */


/**
 * \file t_dd_dmatmp2.h
 * Template for render stages which build and emit vertices directly
 * to fixed-size dma buffers.  Useful for rendering strips and other
 * native primitives where clipping and per-vertex tweaks such as
 * those in t_dd_tritmp.h are not required.
 *
 */

#if !HAVE_TRIANGLES || !HAVE_POINTS || !HAVE_LINES
#error "must have points, lines & triangles to use render template"
#endif

#if !HAVE_TRI_STRIPS || !HAVE_TRI_FANS
#error "must have tri strip and fans to use render template"
#endif

#if !HAVE_LINE_STRIPS
#error "must have line strips to use render template"
#endif

#if !HAVE_POLYGONS
#error "must have polygons to use render template"
#endif

#if !HAVE_ELTS
#error "must have elts to use render template"
#endif


#ifndef EMIT_TWO_ELTS
#define EMIT_TWO_ELTS( dest, offset, elt0, elt1 )	\
do { 						\
   (dest)[offset] = (elt0); 			\
   (dest)[offset+1] = (elt1); 			\
} while (0)
#endif


/**********************************************************************/
/*                  Render whole begin/end objects                    */
/**********************************************************************/


static ELT_TYPE *TAG(emit_elts)( struct gl_context *ctx, 
			    ELT_TYPE *dest,
			    GLuint *elts, GLuint nr )
{
   GLint i;
   LOCAL_VARS;

   for ( i = 0 ; i+1 < nr ; i+=2, elts += 2 ) {
      EMIT_TWO_ELTS( dest, 0, elts[0], elts[1] );
      dest += 2;
   }
   if (i < nr) {
      EMIT_ELT( dest, 0, elts[0] );
      dest += 1;
   }
   
   return dest;
}

static ELT_TYPE *TAG(emit_consecutive_elts)( struct gl_context *ctx, 
					ELT_TYPE *dest,
					GLuint start, GLuint nr )
{
   GLint i;
   LOCAL_VARS;

   for ( i = 0 ; i+1 < nr ; i+=2, start += 2 ) {
      EMIT_TWO_ELTS( dest, 0, start, start+1 );
      dest += 2;
   }
   if (i < nr) {
      EMIT_ELT( dest, 0, start );
      dest += 1;
   }

   return dest;
}

/***********************************************************************
 *                    Render non-indexed primitives.
 ***********************************************************************/



static void TAG(render_points_verts)( struct gl_context *ctx,
				      GLuint start,
				      GLuint count,
				      GLuint flags )
{
   if (start < count) {
      LOCAL_VARS;
      if (0) fprintf(stderr, "%s\n", __FUNCTION__);
      EMIT_PRIM( ctx, GL_POINTS, HW_POINTS, start, count );
   }
}

static void TAG(render_lines_verts)( struct gl_context *ctx,
				     GLuint start,
				     GLuint count,
				     GLuint flags )
{
   LOCAL_VARS;
   if (0) fprintf(stderr, "%s\n", __FUNCTION__);
   count -= (count-start) & 1;

   if (start+1 >= count)
      return;

   if ((flags & PRIM_BEGIN) && ctx->Line.StippleFlag) {
      RESET_STIPPLE();
      AUTO_STIPPLE( GL_TRUE );
   }
      
   EMIT_PRIM( ctx, GL_LINES, HW_LINES, start, count );

   if ((flags & PRIM_END) && ctx->Line.StippleFlag)
      AUTO_STIPPLE( GL_FALSE );
}


static void TAG(render_line_strip_verts)( struct gl_context *ctx,
					  GLuint start,
					  GLuint count,
					  GLuint flags )
{
   LOCAL_VARS;
   if (0) fprintf(stderr, "%s\n", __FUNCTION__);

   if (start+1 >= count)
      return;

   if ((flags & PRIM_BEGIN) && ctx->Line.StippleFlag)
      RESET_STIPPLE();


   if (PREFER_DISCRETE_ELT_PRIM( count-start, HW_LINES ))
   {   
      int dmasz = GET_MAX_HW_ELTS();
      GLuint j, nr;

      ELT_INIT( GL_LINES, HW_LINES );

      /* Emit whole number of lines in each full buffer.
       */
      dmasz = dmasz/2;


      for (j = start; j + 1 < count; j += nr - 1 ) {
	 ELT_TYPE *dest;
	 GLint i;

	 nr = MIN2( dmasz, count - j );
	 dest = ALLOC_ELTS( (nr-1)*2 );
	    
	 for ( i = j ; i+1 < j+nr ; i+=1 ) {
	    EMIT_TWO_ELTS( dest, 0, (i+0), (i+1) );
	    dest += 2;
	 }

	 CLOSE_ELTS();
      }
   }
   else
      EMIT_PRIM( ctx, GL_LINE_STRIP, HW_LINE_STRIP, start, count );
}


static void TAG(render_line_loop_verts)( struct gl_context *ctx,
					 GLuint start,
					 GLuint count,
					 GLuint flags )
{
   LOCAL_VARS;
   GLuint j, nr;
   if (0) fprintf(stderr, "%s\n", __FUNCTION__);

   if (flags & PRIM_BEGIN) {
      j = start;
      if (ctx->Line.StippleFlag)
	 RESET_STIPPLE( );
   }
   else
      j = start + 1;

   if (flags & PRIM_END) {

      if (start+1 >= count)
	 return;

      if (PREFER_DISCRETE_ELT_PRIM( count-start, HW_LINES )) {
	 int dmasz = GET_MAX_HW_ELTS();

	 ELT_INIT( GL_LINES, HW_LINES );

	 /* Emit whole number of lines in each full buffer.
	  */
	 dmasz = dmasz/2;

	 /* Ensure last vertex doesn't wrap:
	  */
	 dmasz--;

	 for (; j + 1 < count;  ) {
	    GLint i;
	    ELT_TYPE *dest;

	    nr = MIN2( dmasz, count - j );
	    dest = ALLOC_ELTS( nr*2 );	/* allocs room for 1 more line */

	    for ( i = 0 ; i < nr - 1 ; i+=1 ) {
	       EMIT_TWO_ELTS( dest, 0, (j+i), (j+i+1) );
	       dest += 2;
	    }

	    j += nr - 1;

	    /* Emit 1 more line into space alloced above */
	    if (j + 1 >= count) {
 	       EMIT_TWO_ELTS( dest, 0, (j), (start) ); 
 	       dest += 2; 
 	    }
 
	    CLOSE_ELTS();
	 }
      }
      else
      {
	 int dmasz = GET_MAX_HW_ELTS() - 1;

	 ELT_INIT( GL_LINE_STRIP, HW_LINE_STRIP );

	 for ( ; j + 1 < count;  ) {
	    nr = MIN2( dmasz, count - j );
	    if (j + nr < count) {
	       ELT_TYPE *dest = ALLOC_ELTS( nr );
	       dest = TAG(emit_consecutive_elts)( ctx, dest, j, nr );
	       (void) dest;
	       j += nr - 1;
	       CLOSE_ELTS();
	    }
	    else if (nr) {
	       ELT_TYPE *dest = ALLOC_ELTS( nr + 1 );
	       dest = TAG(emit_consecutive_elts)( ctx, dest, j, nr );
	       dest = TAG(emit_consecutive_elts)( ctx, dest, start, 1 );
	       (void) dest;
	       j += nr;
	       CLOSE_ELTS();
	    }
	 }   
      }
   } else {
      TAG(render_line_strip_verts)( ctx, j, count, flags );
   }
}


static void TAG(render_triangles_verts)( struct gl_context *ctx,
					 GLuint start,
					 GLuint count,
					 GLuint flags )
{
   LOCAL_VARS;
   if (0) fprintf(stderr, "%s\n", __FUNCTION__);

   count -= (count-start)%3;

   if (start+2 >= count) {
      return;
   }

   /* need a PREFER_DISCRETE_ELT_PRIM here too..
    */
   EMIT_PRIM( ctx, GL_TRIANGLES, HW_TRIANGLES, start, count );
}



static void TAG(render_tri_strip_verts)( struct gl_context *ctx,
					 GLuint start,
					 GLuint count,
					 GLuint flags )
{
   LOCAL_VARS;
   if (0) fprintf(stderr, "%s\n", __FUNCTION__);

   if (start + 2 >= count)
      return;

   if (PREFER_DISCRETE_ELT_PRIM( count-start, HW_TRIANGLES ))
   {   
      int dmasz = GET_MAX_HW_ELTS();
      int parity = 0;
      GLuint j, nr;

      ELT_INIT( GL_TRIANGLES, HW_TRIANGLES );

      /* Emit even number of tris in each full buffer.
       */
      dmasz = dmasz/3;
      dmasz -= dmasz & 1;

      for (j = start; j + 2 < count; j += nr - 2 ) {
	 ELT_TYPE *dest;
	 GLint i;

	 nr = MIN2( dmasz, count - j );
	 dest = ALLOC_ELTS( (nr-2)*3 );
	    
	 for ( i = j ; i+2 < j+nr ; i++, parity^=1 ) {
	    EMIT_ELT( dest, 0, (i+0+parity) );
	    EMIT_ELT( dest, 1, (i+1-parity) );
	    EMIT_ELT( dest, 2, (i+2) );
	    dest += 3;
	 }

	 CLOSE_ELTS();
      }
   }
   else
      EMIT_PRIM( ctx, GL_TRIANGLE_STRIP, HW_TRIANGLE_STRIP_0, start, count );
}

static void TAG(render_tri_fan_verts)( struct gl_context *ctx,
				       GLuint start,
				       GLuint count,
				       GLuint flags )
{
   LOCAL_VARS;
   if (0) fprintf(stderr, "%s\n", __FUNCTION__);

   if (start+2 >= count) 
      return;

   if (PREFER_DISCRETE_ELT_PRIM( count-start, HW_TRIANGLES ))
   {   
      int dmasz = GET_MAX_HW_ELTS();
      GLuint j, nr;

      ELT_INIT( GL_TRIANGLES, HW_TRIANGLES );

      dmasz = dmasz/3;

      for (j = start + 1; j + 1 < count; j += nr - 1 ) {
	 ELT_TYPE *dest;
	 GLint i;

	 nr = MIN2( dmasz, count - j );
	 dest = ALLOC_ELTS( (nr-1)*3 );
	    
	 for ( i = j ; i+1 < j+nr ; i++ ) {
	    EMIT_ELT( dest, 0, (start) );
	    EMIT_ELT( dest, 1, (i) );
	    EMIT_ELT( dest, 2, (i+1) );
	    dest += 3;
	 }
	 
	 CLOSE_ELTS();
      }
   }
   else {
      EMIT_PRIM( ctx, GL_TRIANGLE_FAN, HW_TRIANGLE_FAN, start, count );
   }
}


static void TAG(render_poly_verts)( struct gl_context *ctx,
				    GLuint start,
				    GLuint count,
				    GLuint flags )
{
   LOCAL_VARS;
   if (0) fprintf(stderr, "%s\n", __FUNCTION__);

   if (start+2 >= count) 
      return;

   EMIT_PRIM( ctx, GL_POLYGON, HW_POLYGON, start, count );
}

static void TAG(render_quad_strip_verts)( struct gl_context *ctx,
					  GLuint start,
					  GLuint count,
					  GLuint flags )
{
   LOCAL_VARS;
   if (0) fprintf(stderr, "%s\n", __FUNCTION__);

   count -= (count-start) & 1;

   if (start+3 >= count) 
      return;

   if (HAVE_QUAD_STRIPS) {
      EMIT_PRIM( ctx, GL_QUAD_STRIP, HW_QUAD_STRIP, start, count );
   } 
   else if (ctx->Light.ShadeModel == GL_FLAT) {
      LOCAL_VARS;
      int dmasz = GET_MAX_HW_ELTS();
      GLuint j, nr;

      ELT_INIT( GL_TRIANGLES, HW_TRIANGLES );

      /* Emit whole number of quads in total, and in each buffer.
       */
      dmasz = (dmasz/6)*2;

      for (j = start; j + 3 < count; j += nr - 2 ) {
	 ELT_TYPE *dest;
	 GLint quads, i;

	 nr = MIN2( dmasz, count - j );
	 quads = (nr/2)-1;
	 dest = ALLOC_ELTS( quads*6 );
	    
	 for ( i = j ; i < j+quads*2 ; i+=2 ) {
	    EMIT_TWO_ELTS( dest, 0, (i+0), (i+1) );
	    EMIT_TWO_ELTS( dest, 2, (i+2), (i+1) );
	    EMIT_TWO_ELTS( dest, 4, (i+3), (i+2) );
	    dest += 6;
	 }

	 CLOSE_ELTS();
      }
   }
   else {
      EMIT_PRIM( ctx, GL_TRIANGLE_STRIP, HW_TRIANGLE_STRIP_0, start, count );
   }
}


static void TAG(render_quads_verts)( struct gl_context *ctx,
				     GLuint start,
				     GLuint count,
				     GLuint flags )
{
   LOCAL_VARS;
   if (0) fprintf(stderr, "%s\n", __FUNCTION__);
   count -= (count-start)%4;

   if (start+3 >= count) 
      return;

   if (HAVE_QUADS) {
      EMIT_PRIM( ctx, GL_QUADS, HW_QUADS, start, count );
   } 
   else {
      /* Hardware doesn't have a quad primitive type -- simulate it
       * using indexed vertices and the triangle primitive: 
       */
      LOCAL_VARS;
      int dmasz = GET_MAX_HW_ELTS();
      GLuint j, nr;

      ELT_INIT( GL_TRIANGLES, HW_TRIANGLES );

      /* Adjust for rendering as triangles:
       */
      dmasz = (dmasz/6)*4;

      for (j = start; j < count; j += nr ) {
	 ELT_TYPE *dest;
	 GLint quads, i;

	 nr = MIN2( dmasz, count - j );
	 quads = nr/4;
	 dest = ALLOC_ELTS( quads*6 );

	 for ( i = j ; i < j+quads*4 ; i+=4 ) {
	    EMIT_TWO_ELTS( dest, 0, (i+0), (i+1) );
	    EMIT_TWO_ELTS( dest, 2, (i+3), (i+1) );
	    EMIT_TWO_ELTS( dest, 4, (i+2), (i+3) );
	    dest += 6;
	 }

	 CLOSE_ELTS();
      }
   }
}

static void TAG(render_noop)( struct gl_context *ctx,
			      GLuint start,
			      GLuint count,
			      GLuint flags )
{
}




static tnl_render_func TAG(render_tab_verts)[GL_POLYGON+2] =
{
   TAG(render_points_verts),
   TAG(render_lines_verts),
   TAG(render_line_loop_verts),
   TAG(render_line_strip_verts),
   TAG(render_triangles_verts),
   TAG(render_tri_strip_verts),
   TAG(render_tri_fan_verts),
   TAG(render_quads_verts),
   TAG(render_quad_strip_verts),
   TAG(render_poly_verts),
   TAG(render_noop),
};


/****************************************************************************
 *                 Render elts using hardware indexed verts                 *
 ****************************************************************************/

static void TAG(render_points_elts)( struct gl_context *ctx,
				     GLuint start,
				     GLuint count,
				     GLuint flags )
{
   LOCAL_VARS;
   int dmasz = GET_MAX_HW_ELTS();
   GLuint *elts = GET_MESA_ELTS();
   GLuint j, nr;
   ELT_TYPE *dest;

   ELT_INIT( GL_POINTS, HW_POINTS );

   for (j = start; j < count; j += nr ) {
      nr = MIN2( dmasz, count - j );
      dest = ALLOC_ELTS( nr );
      dest = TAG(emit_elts)( ctx, dest, elts+j, nr );
      (void) dest;
      CLOSE_ELTS();
   }
}



static void TAG(render_lines_elts)( struct gl_context *ctx,
				    GLuint start,
				    GLuint count,
				    GLuint flags )
{
   LOCAL_VARS;
   int dmasz = GET_MAX_HW_ELTS();
   GLuint *elts = GET_MESA_ELTS();
   GLuint j, nr;
   ELT_TYPE *dest;

   if (start+1 >= count)
      return;

   if ((flags & PRIM_BEGIN) && ctx->Line.StippleFlag) {
      RESET_STIPPLE();
      AUTO_STIPPLE( GL_TRUE );
   }

   ELT_INIT( GL_LINES, HW_LINES );

   /* Emit whole number of lines in total and in each buffer:
    */
   count -= (count-start) & 1;
   dmasz -= dmasz & 1;

   for (j = start; j < count; j += nr ) {
      nr = MIN2( dmasz, count - j );
      dest = ALLOC_ELTS( nr );
      dest = TAG(emit_elts)( ctx, dest, elts+j, nr );
      (void) dest;
      CLOSE_ELTS();
   }

   if ((flags & PRIM_END) && ctx->Line.StippleFlag)
      AUTO_STIPPLE( GL_FALSE );
}


static void TAG(render_line_strip_elts)( struct gl_context *ctx,
					 GLuint start,
					 GLuint count,
					 GLuint flags )
{
   LOCAL_VARS;
   int dmasz = GET_MAX_HW_ELTS();
   GLuint *elts = GET_MESA_ELTS();
   GLuint j, nr;
   ELT_TYPE *dest;

   if (start+1 >= count)
      return;

   ELT_INIT( GL_LINE_STRIP, HW_LINE_STRIP );

   if ((flags & PRIM_BEGIN) && ctx->Line.StippleFlag)
      RESET_STIPPLE();

   for (j = start; j + 1 < count; j += nr - 1 ) {
      nr = MIN2( dmasz, count - j );
      dest = ALLOC_ELTS( nr );
      dest = TAG(emit_elts)( ctx, dest, elts+j, nr );
      (void) dest;
      CLOSE_ELTS();
   }
}


static void TAG(render_line_loop_elts)( struct gl_context *ctx,
					GLuint start,
					GLuint count,
					GLuint flags )
{
   LOCAL_VARS;
   int dmasz = GET_MAX_HW_ELTS();
   GLuint *elts = GET_MESA_ELTS();
   GLuint j, nr;
   ELT_TYPE *dest;

   if (0) fprintf(stderr, "%s\n", __FUNCTION__);

   if (flags & PRIM_BEGIN)
      j = start;
   else
      j = start + 1;

   
   if (flags & PRIM_END) {
      if (start+1 >= count)
	 return;
   } 
   else {
      if (j+1 >= count)
	 return;
   }

   ELT_INIT( GL_LINE_STRIP, HW_LINE_STRIP );

   if ((flags & PRIM_BEGIN) && ctx->Line.StippleFlag)
      RESET_STIPPLE();

   
   /* Ensure last vertex doesn't wrap:
    */
   dmasz--;

   for ( ; j + 1 < count; ) {
      nr = MIN2( dmasz, count - j );
      dest = ALLOC_ELTS( nr+1 );	/* Reserve possible space for last elt */
      dest = TAG(emit_elts)( ctx, dest, elts+j, nr );
      j += nr - 1;
      if (j + 1 >= count && (flags & PRIM_END)) {
	 dest = TAG(emit_elts)( ctx, dest, elts+start, 1 );
	 (void) dest;
      }
      CLOSE_ELTS();
   }
}


static void TAG(render_triangles_elts)( struct gl_context *ctx,
					GLuint start,
					GLuint count,
					GLuint flags )
{
   LOCAL_VARS;
   GLuint *elts = GET_MESA_ELTS();
   int dmasz = GET_MAX_HW_ELTS()/3*3;
   GLuint j, nr;
   ELT_TYPE *dest;

   if (start+2 >= count)
      return;

   ELT_INIT( GL_TRIANGLES, HW_TRIANGLES );


   /* Emit whole number of tris in total.  dmasz is already a multiple
    * of 3.
    */
   count -= (count-start)%3;

   for (j = start; j < count; j += nr) {
      nr = MIN2( dmasz, count - j );
      dest = ALLOC_ELTS( nr );
      dest = TAG(emit_elts)( ctx, dest, elts+j, nr );
      (void) dest;
      CLOSE_ELTS();
   }
}



static void TAG(render_tri_strip_elts)( struct gl_context *ctx,
					GLuint start,
					GLuint count,
					GLuint flags )
{
   LOCAL_VARS;
   GLuint j, nr;
   GLuint *elts = GET_MESA_ELTS();
   int dmasz = GET_MAX_HW_ELTS();
   ELT_TYPE *dest;

   if (start+2 >= count)
      return;

   ELT_INIT( GL_TRIANGLE_STRIP, HW_TRIANGLE_STRIP_0 );

   /* Keep the same winding over multiple buffers:
    */
   dmasz -= (dmasz & 1);

   for (j = start ; j + 2 < count; j += nr - 2 ) {
      nr = MIN2( dmasz, count - j );

      dest = ALLOC_ELTS( nr );
      dest = TAG(emit_elts)( ctx, dest, elts+j, nr );
      (void) dest;
      CLOSE_ELTS();
   }
}

static void TAG(render_tri_fan_elts)( struct gl_context *ctx,
				      GLuint start,
				      GLuint count,
				      GLuint flags )
{
   LOCAL_VARS;
   GLuint *elts = GET_MESA_ELTS();
   GLuint j, nr;
   int dmasz = GET_MAX_HW_ELTS();
   ELT_TYPE *dest;

   if (start+2 >= count)
      return;

   ELT_INIT( GL_TRIANGLE_FAN, HW_TRIANGLE_FAN );

   for (j = start + 1 ; j + 1 < count; j += nr - 1 ) {
      nr = MIN2( dmasz, count - j + 1 );
      dest = ALLOC_ELTS( nr );
      dest = TAG(emit_elts)( ctx, dest, elts+start, 1 );
      dest = TAG(emit_elts)( ctx, dest, elts+j, nr - 1 );
      (void) dest;
      CLOSE_ELTS();
   }
}


static void TAG(render_poly_elts)( struct gl_context *ctx,
				   GLuint start,
				   GLuint count,
				   GLuint flags )
{
   LOCAL_VARS;
   GLuint *elts = GET_MESA_ELTS();
   GLuint j, nr;
   int dmasz = GET_MAX_HW_ELTS();
   ELT_TYPE *dest;

   if (start+2 >= count)
      return;

   ELT_INIT( GL_POLYGON, HW_POLYGON );

   for (j = start + 1 ; j + 1 < count ; j += nr - 1 ) {
      nr = MIN2( dmasz, count - j + 1 );
      dest = ALLOC_ELTS( nr );
      dest = TAG(emit_elts)( ctx, dest, elts+start, 1 );
      dest = TAG(emit_elts)( ctx, dest, elts+j, nr - 1 );
      (void) dest;
      CLOSE_ELTS();
   }
}

static void TAG(render_quad_strip_elts)( struct gl_context *ctx,
					 GLuint start,
					 GLuint count,
					 GLuint flags )
{
   if (start+3 >= count)
      return;

   if (HAVE_QUAD_STRIPS && 0) {
   }
   else {
      LOCAL_VARS;
      GLuint *elts = GET_MESA_ELTS();
      int dmasz = GET_MAX_HW_ELTS();
      GLuint j, nr;
      ELT_TYPE *dest;

      /* Emit whole number of quads in total, and in each buffer.
       */
      dmasz -= dmasz & 1;
      count -= (count-start) & 1;

      if (ctx->Light.ShadeModel == GL_FLAT) {
	 ELT_INIT( GL_TRIANGLES, HW_TRIANGLES );

	 dmasz = dmasz/6*2;

	 for (j = start; j + 3 < count; j += nr - 2 ) {
	    nr = MIN2( dmasz, count - j );

	    if (nr >= 4)
	    {
	       GLint quads = (nr/2)-1;
	       ELT_TYPE *dest = ALLOC_ELTS( quads*6 );
	       GLint i;

	       for ( i = j-start ; i < j-start+quads ; i++, elts += 2 ) {
		  EMIT_TWO_ELTS( dest, 0, elts[0], elts[1] );
		  EMIT_TWO_ELTS( dest, 2, elts[2], elts[1] );
		  EMIT_TWO_ELTS( dest, 4, elts[3], elts[2] );
		  dest += 6;
	       }

	       CLOSE_ELTS();
	    }
	 }
      }
      else {
	 ELT_INIT( GL_TRIANGLE_STRIP, HW_TRIANGLE_STRIP_0 );

	 for (j = start; j + 3 < count; j += nr - 2 ) {
	    nr = MIN2( dmasz, count - j );
	    dest = ALLOC_ELTS( nr );
	    dest = TAG(emit_elts)( ctx, dest, elts+j, nr );
	    (void) dest;
	    CLOSE_ELTS();
	 }
      }
   }
}


static void TAG(render_quads_elts)( struct gl_context *ctx,
				    GLuint start,
				    GLuint count,
				    GLuint flags )
{
   if (start+3 >= count)
      return;

   if (HAVE_QUADS && 0) {
   } else {
      LOCAL_VARS;
      GLuint *elts = GET_MESA_ELTS();
      int dmasz = GET_MAX_HW_ELTS();
      GLuint j, nr;

      ELT_INIT( GL_TRIANGLES, HW_TRIANGLES );

      /* Emit whole number of quads in total, and in each buffer.
       */
      dmasz -= dmasz & 3;
      count -= (count-start) & 3;

      /* Adjust for rendering as triangles:
       */
      dmasz = dmasz/6*4;

      for (j = start; j + 3 < count; j += nr ) {
	 nr = MIN2( dmasz, count - j );

	 {
	    GLint quads = nr/4;
	    ELT_TYPE *dest = ALLOC_ELTS( quads * 6 );
	    GLint i;

	    for ( i = j-start ; i < j-start+quads ; i++, elts += 4 ) {
	       EMIT_TWO_ELTS( dest, 0, elts[0], elts[1] );
	       EMIT_TWO_ELTS( dest, 2, elts[3], elts[1] );
	       EMIT_TWO_ELTS( dest, 4, elts[2], elts[3] );
	       dest += 6;
	    }

	    CLOSE_ELTS();
	 }
      }
   }
}



static tnl_render_func TAG(render_tab_elts)[GL_POLYGON+2] =
{
   TAG(render_points_elts),
   TAG(render_lines_elts),
   TAG(render_line_loop_elts),
   TAG(render_line_strip_elts),
   TAG(render_triangles_elts),
   TAG(render_tri_strip_elts),
   TAG(render_tri_fan_elts),
   TAG(render_quads_elts),
   TAG(render_quad_strip_elts),
   TAG(render_poly_elts),
   TAG(render_noop),
};
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.4
log
@Merge Mesa 9.2.0
@
text
@d25 1
a25 1
 *    Keith Whitwell <keith@@tungstengraphics.com>
@


1.3
log
@Merge Mesa 7.10.3
@
text
@a2 1
 * Version:  6.5.1
d19 4
a22 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
@


1.2
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d73 1
a73 1
static ELT_TYPE *TAG(emit_elts)( GLcontext *ctx, 
d92 1
a92 1
static ELT_TYPE *TAG(emit_consecutive_elts)( GLcontext *ctx, 
d117 1
a117 1
static void TAG(render_points_verts)( GLcontext *ctx,
d129 1
a129 1
static void TAG(render_lines_verts)( GLcontext *ctx,
d153 1
a153 1
static void TAG(render_line_strip_verts)( GLcontext *ctx,
d200 1
a200 1
static void TAG(render_line_loop_verts)( GLcontext *ctx,
d289 1
a289 1
static void TAG(render_triangles_verts)( GLcontext *ctx,
d310 1
a310 1
static void TAG(render_tri_strip_verts)( GLcontext *ctx,
d355 1
a355 1
static void TAG(render_tri_fan_verts)( GLcontext *ctx,
d398 1
a398 1
static void TAG(render_poly_verts)( GLcontext *ctx,
d412 1
a412 1
static void TAG(render_quad_strip_verts)( GLcontext *ctx,
d463 1
a463 1
static void TAG(render_quads_verts)( GLcontext *ctx,
d512 1
a512 1
static void TAG(render_noop)( GLcontext *ctx,
d542 1
a542 1
static void TAG(render_points_elts)( GLcontext *ctx,
d566 1
a566 1
static void TAG(render_lines_elts)( GLcontext *ctx,
d605 1
a605 1
static void TAG(render_line_strip_elts)( GLcontext *ctx,
d634 1
a634 1
static void TAG(render_line_loop_elts)( GLcontext *ctx,
d686 1
a686 1
static void TAG(render_triangles_elts)( GLcontext *ctx,
d719 1
a719 1
static void TAG(render_tri_strip_elts)( GLcontext *ctx,
d749 1
a749 1
static void TAG(render_tri_fan_elts)( GLcontext *ctx,
d776 1
a776 1
static void TAG(render_poly_elts)( GLcontext *ctx,
d802 1
a802 1
static void TAG(render_quad_strip_elts)( GLcontext *ctx,
d864 1
a864 1
static void TAG(render_quads_elts)( GLcontext *ctx,
@


1.1
log
@Initial revision
@
text
@d269 1
d277 1
d559 1
d596 1
d628 1
d679 1
d712 1
d744 1
d770 1
d797 1
d856 1
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@Import Mesa 7.10.3
@
text
@d73 1
a73 1
static ELT_TYPE *TAG(emit_elts)( struct gl_context *ctx, 
d92 1
a92 1
static ELT_TYPE *TAG(emit_consecutive_elts)( struct gl_context *ctx, 
d117 1
a117 1
static void TAG(render_points_verts)( struct gl_context *ctx,
d129 1
a129 1
static void TAG(render_lines_verts)( struct gl_context *ctx,
d153 1
a153 1
static void TAG(render_line_strip_verts)( struct gl_context *ctx,
d200 1
a200 1
static void TAG(render_line_loop_verts)( struct gl_context *ctx,
a268 1
	       (void) dest;
a275 1
	       (void) dest;
d287 1
a287 1
static void TAG(render_triangles_verts)( struct gl_context *ctx,
d308 1
a308 1
static void TAG(render_tri_strip_verts)( struct gl_context *ctx,
d353 1
a353 1
static void TAG(render_tri_fan_verts)( struct gl_context *ctx,
d396 1
a396 1
static void TAG(render_poly_verts)( struct gl_context *ctx,
d410 1
a410 1
static void TAG(render_quad_strip_verts)( struct gl_context *ctx,
d461 1
a461 1
static void TAG(render_quads_verts)( struct gl_context *ctx,
d510 1
a510 1
static void TAG(render_noop)( struct gl_context *ctx,
d540 1
a540 1
static void TAG(render_points_elts)( struct gl_context *ctx,
a556 1
      (void) dest;
d563 1
a563 1
static void TAG(render_lines_elts)( struct gl_context *ctx,
a592 1
      (void) dest;
d601 1
a601 1
static void TAG(render_line_strip_elts)( struct gl_context *ctx,
a623 1
      (void) dest;
d629 1
a629 1
static void TAG(render_line_loop_elts)( struct gl_context *ctx,
a673 1
	 (void) dest;
d680 1
a680 1
static void TAG(render_triangles_elts)( struct gl_context *ctx,
a705 1
      (void) dest;
d712 1
a712 1
static void TAG(render_tri_strip_elts)( struct gl_context *ctx,
a736 1
      (void) dest;
d741 1
a741 1
static void TAG(render_tri_fan_elts)( struct gl_context *ctx,
a761 1
      (void) dest;
d767 1
a767 1
static void TAG(render_poly_elts)( struct gl_context *ctx,
a787 1
      (void) dest;
d792 1
a792 1
static void TAG(render_quad_strip_elts)( struct gl_context *ctx,
a845 1
	    (void) dest;
d853 1
a853 1
static void TAG(render_quads_elts)( struct gl_context *ctx,
@


1.1.1.3
log
@Import Mesa 9.2.0
@
text
@d3 1
d20 3
a22 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
@


1.1.1.4
log
@Import Mesa 10.2.3
@
text
@d25 1
a25 1
 *    Keith Whitwell <keithw@@vmware.com>
@


