head	1.9;
access;
symbols
	OPENBSD_5_8:1.8.0.6
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.4
	OPENBSD_5_7_BASE:1.8
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.5
	v10_2_7:1.1.1.5
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	v10_2_3:1.1.1.5
	OPENBSD_5_5:1.7.0.2
	OPENBSD_5_5_BASE:1.7
	v9_2_5:1.1.1.4
	v9_2_3:1.1.1.4
	v9_2_2:1.1.1.4
	v9_2_1:1.1.1.4
	v9_2_0:1.1.1.4
	OPENBSD_5_4:1.6.0.4
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	v7_10_3:1.1.1.3
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.10
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.8
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.6
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.4
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_3:1.3.0.2
	v7_0_1:1.1.1.2
	OPENBSD_4_2:1.2.0.2
	OPENBSD_4_2_BASE:1.2
	v6_5_2:1.1.1.1
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2015.12.23.05.17.53;	author jsg;	state dead;
branches;
next	1.8;
commitid	TnlogFl9nOv2eaRf;

1.8
date	2014.07.09.21.09.00;	author jsg;	state Exp;
branches;
next	1.7;
commitid	WPD6rgPryPkvXOr9;

1.7
date	2013.09.05.14.06.27;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2012.08.17.13.58.19;	author mpi;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.23.13.37.42;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.31;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2007.11.24.17.41.37;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2007.04.19.08.12.55;	author aanriot;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.50.17;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.50.17;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.31.18;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.10.23.13.29.46;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.09.05.13.16.48;	author jsg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2014.07.09.20.35.04;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.9
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */


#include "glheader.h"
#include "imports.h"
#include "context.h"
#include "fbobject.h"
#include "formats.h"
#include "mtypes.h"
#include "renderbuffer.h"


/**
 * Initialize the fields of a gl_renderbuffer to default values.
 */
void
_mesa_init_renderbuffer(struct gl_renderbuffer *rb, GLuint name)
{
   mtx_init(&rb->Mutex, mtx_plain);

   rb->ClassID = 0;
   rb->Name = name;
   rb->RefCount = 0;
   rb->Delete = _mesa_delete_renderbuffer;

   /* The rest of these should be set later by the caller of this function or
    * the AllocStorage method:
    */
   rb->AllocStorage = NULL;

   rb->Width = 0;
   rb->Height = 0;
   rb->Depth = 0;
   rb->InternalFormat = GL_RGBA;
   rb->Format = MESA_FORMAT_NONE;
}


/**
 * Allocate a new gl_renderbuffer object.  This can be used for user-created
 * renderbuffers or window-system renderbuffers.
 */
struct gl_renderbuffer *
_mesa_new_renderbuffer(struct gl_context *ctx, GLuint name)
{
   struct gl_renderbuffer *rb = CALLOC_STRUCT(gl_renderbuffer);
   if (rb) {
      _mesa_init_renderbuffer(rb, name);
   }
   return rb;
}


/**
 * Delete a gl_framebuffer.
 * This is the default function for renderbuffer->Delete().
 * Drivers which subclass gl_renderbuffer should probably implement their
 * own delete function.  But the driver might also call this function to
 * free the object in the end.
 */
void
_mesa_delete_renderbuffer(struct gl_context *ctx, struct gl_renderbuffer *rb)
{
   mtx_destroy(&rb->Mutex);
   free(rb->Label);
   free(rb);
}


/**
 * Attach a renderbuffer to a framebuffer.
 * \param bufferName  one of the BUFFER_x tokens
 */
void
_mesa_add_renderbuffer(struct gl_framebuffer *fb,
                       gl_buffer_index bufferName, struct gl_renderbuffer *rb)
{
   assert(fb);
   assert(rb);
   assert(bufferName < BUFFER_COUNT);

   /* There should be no previous renderbuffer on this attachment point,
    * with the exception of depth/stencil since the same renderbuffer may
    * be used for both.
    */
   assert(bufferName == BUFFER_DEPTH ||
          bufferName == BUFFER_STENCIL ||
          fb->Attachment[bufferName].Renderbuffer == NULL);

   /* winsys vs. user-created buffer cross check */
   if (_mesa_is_user_fbo(fb)) {
      assert(rb->Name);
   }
   else {
      assert(!rb->Name);
   }

   fb->Attachment[bufferName].Type = GL_RENDERBUFFER_EXT;
   fb->Attachment[bufferName].Complete = GL_TRUE;
   _mesa_reference_renderbuffer(&fb->Attachment[bufferName].Renderbuffer, rb);
}


/**
 * Remove the named renderbuffer from the given framebuffer.
 * \param bufferName  one of the BUFFER_x tokens
 */
void
_mesa_remove_renderbuffer(struct gl_framebuffer *fb,
                          gl_buffer_index bufferName)
{
   assert(bufferName < BUFFER_COUNT);
   _mesa_reference_renderbuffer(&fb->Attachment[bufferName].Renderbuffer,
                                NULL);
}


/**
 * Set *ptr to point to rb.  If *ptr points to another renderbuffer,
 * dereference that buffer first.  The new renderbuffer's refcount will
 * be incremented.  The old renderbuffer's refcount will be decremented.
 * This is normally only called from the _mesa_reference_renderbuffer() macro
 * when there's a real pointer change.
 */
void
_mesa_reference_renderbuffer_(struct gl_renderbuffer **ptr,
                              struct gl_renderbuffer *rb)
{
   if (*ptr) {
      /* Unreference the old renderbuffer */
      GLboolean deleteFlag = GL_FALSE;
      struct gl_renderbuffer *oldRb = *ptr;

      mtx_lock(&oldRb->Mutex);
      ASSERT(oldRb->RefCount > 0);
      oldRb->RefCount--;
      /*printf("RB DECR %p (%d) to %d\n", (void*) oldRb, oldRb->Name, oldRb->RefCount);*/
      deleteFlag = (oldRb->RefCount == 0);
      mtx_unlock(&oldRb->Mutex);

      if (deleteFlag) {
         GET_CURRENT_CONTEXT(ctx);
         oldRb->Delete(ctx, oldRb);
      }

      *ptr = NULL;
   }
   assert(!*ptr);

   if (rb) {
      /* reference new renderbuffer */
      mtx_lock(&rb->Mutex);
      rb->RefCount++;
      /*printf("RB INCR %p (%d) to %d\n", (void*) rb, rb->Name, rb->RefCount);*/
      mtx_unlock(&rb->Mutex);
      *ptr = rb;
   }
}
@


1.8
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.7
log
@Merge Mesa 9.2.0
@
text
@d41 1
a41 1
   _glthread_INIT_MUTEX(rb->Mutex);
d86 2
a87 1
   _glthread_DESTROY_MUTEX(rb->Mutex);
d156 1
a156 1
      _glthread_LOCK_MUTEX(oldRb->Mutex);
d161 1
a161 1
      _glthread_UNLOCK_MUTEX(oldRb->Mutex);
d174 1
a174 1
      _glthread_LOCK_MUTEX(rb->Mutex);
d177 1
a177 1
      _glthread_UNLOCK_MUTEX(rb->Mutex);
@


1.6
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a2 1
 * Version:  6.5
d19 4
a22 20
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */


/**
 * Functions for allocating/managing renderbuffers.
 * Also, routines for reading/writing software-based renderbuffer data as
 * ubytes, ushorts, uints, etc.
 *
 * The 'alpha8' renderbuffer is interesting.  It's used to add a software-based
 * alpha channel to RGB renderbuffers.  This is done by wrapping the RGB
 * renderbuffer with the alpha renderbuffer.  We can do this because of the
 * OO-nature of renderbuffers.
 *
 * Down the road we'll use this for run-time support of 8, 16 and 32-bit
 * color channels.  For example, Mesa may use 32-bit/float color channels
 * internally (swrast) and use wrapper renderbuffers to convert 32-bit
 * values down to 16 or 8-bit values for whatever kind of framebuffer we have.
a34 1912
/*
 * Routines for get/put values in common buffer formats follow.
 */

/* Returns a bytes per pixel of the DataType in the get/put span
 * functions for at least a subset of the available combinations a
 * renderbuffer can have.
 *
 * It would be nice to see gl_renderbuffer start talking about a
 * gl_format instead of a GLenum DataType.
 */
static int
get_datatype_bytes(struct gl_renderbuffer *rb)
{
   int component_size;

   switch (rb->DataType) {
   case GL_FLOAT:
   case GL_UNSIGNED_INT:
   case GL_UNSIGNED_INT_24_8_EXT:
      component_size = 4;
      break;
   case GL_UNSIGNED_SHORT:
      component_size = 2;
      break;
   case GL_UNSIGNED_BYTE:
      component_size = 1;
      break;
   default:
      component_size = 1;
      assert(0);
   }

   switch (rb->_BaseFormat) {
   case GL_DEPTH_COMPONENT:
   case GL_DEPTH_STENCIL:
      return component_size;
   default:
      return 4 * component_size;
   }
}

/* This is commonly used by most of the accessors. */
static void *
get_pointer_generic(struct gl_context *ctx, struct gl_renderbuffer *rb,
		    GLint x, GLint y)
{
   if (!rb->Data)
      return NULL;

   return ((char *) rb->Data +
	   (y * rb->RowStride + x) * _mesa_get_format_bytes(rb->Format));
}

/* GetRow() implementation for formats where DataType matches the rb->Format.
 */
static void
get_row_generic(struct gl_context *ctx, struct gl_renderbuffer *rb,
		GLuint count, GLint x, GLint y, void *values)
{
   void *src = rb->GetPointer(ctx, rb, x, y);
   memcpy(values, src, count * _mesa_get_format_bytes(rb->Format));
}

/* Only used for float textures currently, but might also be used for
 * RGBA8888, RGBA16, etc.
 */
static void
get_values_generic(struct gl_context *ctx, struct gl_renderbuffer *rb,
		   GLuint count, const GLint x[], const GLint y[], void *values)
{
   int format_bytes = _mesa_get_format_bytes(rb->Format) / sizeof(GLfloat);
   GLuint i;

   for (i = 0; i < count; i++) {
      const void *src = rb->GetPointer(ctx, rb, x[i], y[i]);
      char *dst = (char *) values + i * format_bytes;
      memcpy(dst, src, format_bytes);
   }
}

/* For the GL_RED/GL_RG/GL_RGB format/DataType combinations (and
 * GL_LUMINANCE/GL_INTENSITY?), the Put functions are a matter of
 * storing those initial components of the value per pixel into the
 * destination.
 */
static void
put_row_generic(struct gl_context *ctx, struct gl_renderbuffer *rb,
		GLuint count, GLint x, GLint y,
		const void *values, const GLubyte *mask)
{
   void *row = rb->GetPointer(ctx, rb, x, y);
   int format_bytes = _mesa_get_format_bytes(rb->Format) / sizeof(GLfloat);
   int datatype_bytes = get_datatype_bytes(rb);
   unsigned int i;

   if (mask) {
      for (i = 0; i < count; i++) {
	 char *dst = (char *) row + i * format_bytes;
	 const char *src = (const char *) values + i * datatype_bytes;

         if (mask[i]) {
	    memcpy(dst, src, format_bytes);
         }
      }
   }
   else {
      for (i = 0; i < count; i++) {
	 char *dst = (char *) row + i * format_bytes;
	 const char *src = (const char *) values + i * datatype_bytes;
	 memcpy(dst, src, format_bytes);
      }
   }
}

static void
put_mono_row_generic(struct gl_context *ctx, struct gl_renderbuffer *rb,
		     GLuint count, GLint x, GLint y,
		     const void *value, const GLubyte *mask)
{
   void *row = rb->GetPointer(ctx, rb, x, y);
   int format_bytes = _mesa_get_format_bytes(rb->Format) / sizeof(GLfloat);
   unsigned int i;

   if (mask) {
      for (i = 0; i < count; i++) {
	 char *dst = (char *) row + i * format_bytes;
         if (mask[i]) {
	    memcpy(dst, value, format_bytes);
         }
      }
   }
   else {
      for (i = 0; i < count; i++) {
	 char *dst = (char *) row + i * format_bytes;
	 memcpy(dst, value, format_bytes);
      }
   }
}


static void
put_values_generic(struct gl_context *ctx, struct gl_renderbuffer *rb,
		   GLuint count, const GLint x[], const GLint y[],
		   const void *values, const GLubyte *mask)
{
   int format_bytes = _mesa_get_format_bytes(rb->Format) / sizeof(GLfloat);
   int datatype_bytes = get_datatype_bytes(rb);
   unsigned int i;

   for (i = 0; i < count; i++) {
      if (!mask || mask[i]) {
	 void *dst = rb->GetPointer(ctx, rb, x[i], y[i]);
	 const char *src = (const char *) values + i * datatype_bytes;
	 memcpy(dst, src, format_bytes);
      }
   }
}


static void
put_mono_values_generic(struct gl_context *ctx,
			struct gl_renderbuffer *rb,
			GLuint count, const GLint x[], const GLint y[],
			const void *value, const GLubyte *mask)
{
   int format_bytes = _mesa_get_format_bytes(rb->Format) / sizeof(GLfloat);
   unsigned int i;

   for (i = 0; i < count; i++) {
      if (!mask || mask[i]) {
	 void *dst = rb->GetPointer(ctx, rb, x[i], y[i]);
	 memcpy(dst, value, format_bytes);
      }
   }
}

/**********************************************************************
 * Functions for buffers of 1 X GLubyte values.
 * Typically stencil.
 */

static void
get_values_ubyte(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
                 const GLint x[], const GLint y[], void *values)
{
   GLubyte *dst = (GLubyte *) values;
   GLuint i;
   ASSERT(rb->DataType == GL_UNSIGNED_BYTE);
   for (i = 0; i < count; i++) {
      const GLubyte *src = (GLubyte *) rb->Data + y[i] * rb->RowStride + x[i];
      dst[i] = *src;
   }
}


static void
put_row_ubyte(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
              GLint x, GLint y, const void *values, const GLubyte *mask)
{
   const GLubyte *src = (const GLubyte *) values;
   GLubyte *dst = (GLubyte *) rb->Data + y * rb->RowStride + x;
   ASSERT(rb->DataType == GL_UNSIGNED_BYTE);
   if (mask) {
      GLuint i;
      for (i = 0; i < count; i++) {
         if (mask[i]) {
            dst[i] = src[i];
         }
      }
   }
   else {
      memcpy(dst, values, count * sizeof(GLubyte));
   }
}


static void
put_mono_row_ubyte(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
                   GLint x, GLint y, const void *value, const GLubyte *mask)
{
   const GLubyte val = *((const GLubyte *) value);
   GLubyte *dst = (GLubyte *) rb->Data + y * rb->RowStride + x;
   ASSERT(rb->DataType == GL_UNSIGNED_BYTE);
   if (mask) {
      GLuint i;
      for (i = 0; i < count; i++) {
         if (mask[i]) {
            dst[i] = val;
         }
      }
   }
   else {
      GLuint i;
      for (i = 0; i < count; i++) {
         dst[i] = val;
      }
   }
}


static void
put_values_ubyte(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
                 const GLint x[], const GLint y[],
                 const void *values, const GLubyte *mask)
{
   const GLubyte *src = (const GLubyte *) values;
   GLuint i;
   ASSERT(rb->DataType == GL_UNSIGNED_BYTE);
   for (i = 0; i < count; i++) {
      if (!mask || mask[i]) {
         GLubyte *dst = (GLubyte *) rb->Data + y[i] * rb->RowStride + x[i];
         *dst = src[i];
      }
   }
}


static void
put_mono_values_ubyte(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
                      const GLint x[], const GLint y[],
                      const void *value, const GLubyte *mask)
{
   const GLubyte val = *((const GLubyte *) value);
   GLuint i;
   ASSERT(rb->DataType == GL_UNSIGNED_BYTE);
   for (i = 0; i < count; i++) {
      if (!mask || mask[i]) {
         GLubyte *dst = (GLubyte *) rb->Data + y[i] * rb->RowStride + x[i];
         *dst = val;
      }
   }
}


/**********************************************************************
 * Functions for buffers of 1 X GLushort values.
 * Typically depth/Z.
 */

static void
get_values_ushort(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
                  const GLint x[], const GLint y[], void *values)
{
   GLushort *dst = (GLushort *) values;
   GLuint i;
   ASSERT(rb->DataType == GL_UNSIGNED_SHORT);
   for (i = 0; i < count; i++) {
      const GLushort *src = (GLushort *) rb->Data + y[i] * rb->RowStride + x[i];
      dst[i] = *src;
   }
}


static void
put_row_ushort(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
               GLint x, GLint y, const void *values, const GLubyte *mask)
{
   const GLushort *src = (const GLushort *) values;
   GLushort *dst = (GLushort *) rb->Data + y * rb->RowStride + x;
   ASSERT(rb->DataType == GL_UNSIGNED_SHORT);
   if (mask) {
      GLuint i;
      for (i = 0; i < count; i++) {
         if (mask[i]) {
            dst[i] = src[i];
         }
      }
   }
   else {
      memcpy(dst, src, count * sizeof(GLushort));
   }
}


static void
put_mono_row_ushort(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
                    GLint x, GLint y, const void *value, const GLubyte *mask)
{
   const GLushort val = *((const GLushort *) value);
   GLushort *dst = (GLushort *) rb->Data + y * rb->RowStride + x;
   ASSERT(rb->DataType == GL_UNSIGNED_SHORT);
   if (mask) {
      GLuint i;
      for (i = 0; i < count; i++) {
         if (mask[i]) {
            dst[i] = val;
         }
      }
   }
   else {
      GLuint i;
      for (i = 0; i < count; i++) {
         dst[i] = val;
      }
   }
}


static void
put_values_ushort(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
                  const GLint x[], const GLint y[], const void *values,
                  const GLubyte *mask)
{
   const GLushort *src = (const GLushort *) values;
   GLuint i;
   ASSERT(rb->DataType == GL_UNSIGNED_SHORT);
   for (i = 0; i < count; i++) {
      if (!mask || mask[i]) {
         GLushort *dst = (GLushort *) rb->Data + y[i] * rb->RowStride + x[i];
         *dst = src[i];
      }
   }
}
 

static void
put_mono_values_ushort(struct gl_context *ctx, struct gl_renderbuffer *rb,
                       GLuint count, const GLint x[], const GLint y[],
                       const void *value, const GLubyte *mask)
{
   const GLushort val = *((const GLushort *) value);
   ASSERT(rb->DataType == GL_UNSIGNED_SHORT);
   if (mask) {
      GLuint i;
      for (i = 0; i < count; i++) {
         if (mask[i]) {
            GLushort *dst = (GLushort *) rb->Data + y[i] * rb->RowStride + x[i];
            *dst = val;
         }
      }
   }
   else {
      GLuint i;
      for (i = 0; i < count; i++) {
         GLushort *dst = (GLushort *) rb->Data + y[i] * rb->RowStride + x[i];
         *dst = val;
      }
   }
}
 

/**********************************************************************
 * Functions for buffers of 1 X GLuint values.
 * Typically depth/Z or color index.
 */

static void
get_values_uint(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
                const GLint x[], const GLint y[], void *values)
{
   GLuint *dst = (GLuint *) values;
   GLuint i;
   ASSERT(rb->DataType == GL_UNSIGNED_INT ||
          rb->DataType == GL_UNSIGNED_INT_24_8_EXT);
   for (i = 0; i < count; i++) {
      const GLuint *src = (GLuint *) rb->Data + y[i] * rb->RowStride + x[i];
      dst[i] = *src;
   }
}


static void
put_row_uint(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
             GLint x, GLint y, const void *values, const GLubyte *mask)
{
   const GLuint *src = (const GLuint *) values;
   GLuint *dst = (GLuint *) rb->Data + y * rb->RowStride + x;
   ASSERT(rb->DataType == GL_UNSIGNED_INT ||
          rb->DataType == GL_UNSIGNED_INT_24_8_EXT);
   if (mask) {
      GLuint i;
      for (i = 0; i < count; i++) {
         if (mask[i]) {
            dst[i] = src[i];
         }
      }
   }
   else {
      memcpy(dst, src, count * sizeof(GLuint));
   }
}


static void
put_mono_row_uint(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
                  GLint x, GLint y, const void *value, const GLubyte *mask)
{
   const GLuint val = *((const GLuint *) value);
   GLuint *dst = (GLuint *) rb->Data + y * rb->RowStride + x;
   ASSERT(rb->DataType == GL_UNSIGNED_INT ||
          rb->DataType == GL_UNSIGNED_INT_24_8_EXT);
   if (mask) {
      GLuint i;
      for (i = 0; i < count; i++) {
         if (mask[i]) {
            dst[i] = val;
         }
      }
   }
   else {
      GLuint i;
      for (i = 0; i < count; i++) {
         dst[i] = val;
      }
   }
}


static void
put_values_uint(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
                const GLint x[], const GLint y[], const void *values,
                const GLubyte *mask)
{
   const GLuint *src = (const GLuint *) values;
   GLuint i;
   ASSERT(rb->DataType == GL_UNSIGNED_INT ||
          rb->DataType == GL_UNSIGNED_INT_24_8_EXT);
   for (i = 0; i < count; i++) {
      if (!mask || mask[i]) {
         GLuint *dst = (GLuint *) rb->Data + y[i] * rb->RowStride + x[i];
         *dst = src[i];
      }
   }
}


static void
put_mono_values_uint(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
                     const GLint x[], const GLint y[], const void *value,
                     const GLubyte *mask)
{
   const GLuint val = *((const GLuint *) value);
   GLuint i;
   ASSERT(rb->DataType == GL_UNSIGNED_INT ||
          rb->DataType == GL_UNSIGNED_INT_24_8_EXT);
   for (i = 0; i < count; i++) {
      if (!mask || mask[i]) {
         GLuint *dst = (GLuint *) rb->Data + y[i] * rb->RowStride + x[i];
         *dst = val;
      }
   }
}


/**********************************************************************
 * Functions for buffers of 3 X GLubyte (or GLbyte) values.
 * Typically color buffers.
 * NOTE: the incoming and outgoing colors are RGBA!  We ignore incoming
 * alpha values and return 255 for outgoing alpha values.
 */

static void *
get_pointer_ubyte3(struct gl_context *ctx, struct gl_renderbuffer *rb,
                   GLint x, GLint y)
{
   ASSERT(rb->Format == MESA_FORMAT_RGB888);
   /* No direct access since this buffer is RGB but caller will be
    * treating it as if it were RGBA.
    */
   return NULL;
}


static void
get_row_ubyte3(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
               GLint x, GLint y, void *values)
{
   const GLubyte *src = ((const GLubyte *) rb->Data) +
					   3 * (y * rb->RowStride + x);
   GLubyte *dst = (GLubyte *) values;
   GLuint i;
   ASSERT(rb->Format == MESA_FORMAT_RGB888);
   ASSERT(rb->DataType == GL_UNSIGNED_BYTE);
   for (i = 0; i < count; i++) {
      dst[i * 4 + 0] = src[i * 3 + 0];
      dst[i * 4 + 1] = src[i * 3 + 1];
      dst[i * 4 + 2] = src[i * 3 + 2];
      dst[i * 4 + 3] = 255;
   }
}


static void
get_values_ubyte3(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
                  const GLint x[], const GLint y[], void *values)
{
   GLubyte *dst = (GLubyte *) values;
   GLuint i;
   ASSERT(rb->Format == MESA_FORMAT_RGB888);
   ASSERT(rb->DataType == GL_UNSIGNED_BYTE);
   for (i = 0; i < count; i++) {
      const GLubyte *src
         = (GLubyte *) rb->Data + 3 * (y[i] * rb->RowStride + x[i]);
      dst[i * 4 + 0] = src[0];
      dst[i * 4 + 1] = src[1];
      dst[i * 4 + 2] = src[2];
      dst[i * 4 + 3] = 255;
   }
}


static void
put_row_ubyte3(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
               GLint x, GLint y, const void *values, const GLubyte *mask)
{
   /* note: incoming values are RGB+A! */
   const GLubyte *src = (const GLubyte *) values;
   GLubyte *dst = (GLubyte *) rb->Data + 3 * (y * rb->RowStride + x);
   GLuint i;
   ASSERT(rb->Format == MESA_FORMAT_RGB888);
   ASSERT(rb->DataType == GL_UNSIGNED_BYTE);
   for (i = 0; i < count; i++) {
      if (!mask || mask[i]) {
         dst[i * 3 + 0] = src[i * 4 + 0];
         dst[i * 3 + 1] = src[i * 4 + 1];
         dst[i * 3 + 2] = src[i * 4 + 2];
      }
   }
}


static void
put_row_rgb_ubyte3(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
                   GLint x, GLint y, const void *values, const GLubyte *mask)
{
   /* note: incoming values are RGB+A! */
   const GLubyte *src = (const GLubyte *) values;
   GLubyte *dst = (GLubyte *) rb->Data + 3 * (y * rb->RowStride + x);
   GLuint i;
   ASSERT(rb->Format == MESA_FORMAT_RGB888);
   ASSERT(rb->DataType == GL_UNSIGNED_BYTE);
   for (i = 0; i < count; i++) {
      if (!mask || mask[i]) {
         dst[i * 3 + 0] = src[i * 3 + 0];
         dst[i * 3 + 1] = src[i * 3 + 1];
         dst[i * 3 + 2] = src[i * 3 + 2];
      }
   }
}


static void
put_mono_row_ubyte3(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
                    GLint x, GLint y, const void *value, const GLubyte *mask)
{
   /* note: incoming value is RGB+A! */
   const GLubyte val0 = ((const GLubyte *) value)[0];
   const GLubyte val1 = ((const GLubyte *) value)[1];
   const GLubyte val2 = ((const GLubyte *) value)[2];
   GLubyte *dst = (GLubyte *) rb->Data + 3 * (y * rb->RowStride + x);
   ASSERT(rb->Format == MESA_FORMAT_RGB888);
   ASSERT(rb->DataType == GL_UNSIGNED_BYTE);
   if (!mask && val0 == val1 && val1 == val2) {
      /* optimized case */
      memset(dst, val0, 3 * count);
   }
   else {
      GLuint i;
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            dst[i * 3 + 0] = val0;
            dst[i * 3 + 1] = val1;
            dst[i * 3 + 2] = val2;
         }
      }
   }
}


static void
put_values_ubyte3(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
                  const GLint x[], const GLint y[], const void *values,
                  const GLubyte *mask)
{
   /* note: incoming values are RGB+A! */
   const GLubyte *src = (const GLubyte *) values;
   GLuint i;
   ASSERT(rb->Format == MESA_FORMAT_RGB888);
   ASSERT(rb->DataType == GL_UNSIGNED_BYTE);
   for (i = 0; i < count; i++) {
      if (!mask || mask[i]) {
         GLubyte *dst = (GLubyte *) rb->Data + 3 * (y[i] * rb->RowStride + x[i]);
         dst[0] = src[i * 4 + 0];
         dst[1] = src[i * 4 + 1];
         dst[2] = src[i * 4 + 2];
      }
   }
}


static void
put_mono_values_ubyte3(struct gl_context *ctx, struct gl_renderbuffer *rb,
                       GLuint count, const GLint x[], const GLint y[],
                       const void *value, const GLubyte *mask)
{
   /* note: incoming value is RGB+A! */
   const GLubyte val0 = ((const GLubyte *) value)[0];
   const GLubyte val1 = ((const GLubyte *) value)[1];
   const GLubyte val2 = ((const GLubyte *) value)[2];
   GLuint i;
   ASSERT(rb->Format == MESA_FORMAT_RGB888);
   ASSERT(rb->DataType == GL_UNSIGNED_BYTE);
   for (i = 0; i < count; i++) {
      if (!mask || mask[i]) {
         GLubyte *dst = ((GLubyte *) rb->Data) +
				     3 * (y[i] * rb->RowStride + x[i]);
         dst[0] = val0;
         dst[1] = val1;
         dst[2] = val2;
      }
   }
}


/**********************************************************************
 * Functions for buffers of 4 X GLubyte (or GLbyte) values.
 * Typically color buffers.
 */

static void
get_values_ubyte4(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
                  const GLint x[], const GLint y[], void *values)
{
   /* treat 4*GLubyte as 1*GLuint */
   GLuint *dst = (GLuint *) values;
   GLuint i;
   ASSERT(rb->DataType == GL_UNSIGNED_BYTE);
   ASSERT(rb->Format == MESA_FORMAT_RGBA8888);
   for (i = 0; i < count; i++) {
      const GLuint *src = (GLuint *) rb->Data + (y[i] * rb->RowStride + x[i]);
      dst[i] = *src;
   }
}


static void
put_row_ubyte4(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
               GLint x, GLint y, const void *values, const GLubyte *mask)
{
   /* treat 4*GLubyte as 1*GLuint */
   const GLuint *src = (const GLuint *) values;
   GLuint *dst = (GLuint *) rb->Data + (y * rb->RowStride + x);
   ASSERT(rb->DataType == GL_UNSIGNED_BYTE);
   ASSERT(rb->Format == MESA_FORMAT_RGBA8888);
   if (mask) {
      GLuint i;
      for (i = 0; i < count; i++) {
         if (mask[i]) {
            dst[i] = src[i];
         }
      }
   }
   else {
      memcpy(dst, src, 4 * count * sizeof(GLubyte));
   }
}


static void
put_row_rgb_ubyte4(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
                   GLint x, GLint y, const void *values, const GLubyte *mask)
{
   /* Store RGB values in RGBA buffer */
   const GLubyte *src = (const GLubyte *) values;
   GLubyte *dst = (GLubyte *) rb->Data + 4 * (y * rb->RowStride + x);
   GLuint i;
   ASSERT(rb->DataType == GL_UNSIGNED_BYTE);
   ASSERT(rb->Format == MESA_FORMAT_RGBA8888);
   for (i = 0; i < count; i++) {
      if (!mask || mask[i]) {
         dst[i * 4 + 0] = src[i * 3 + 0];
         dst[i * 4 + 1] = src[i * 3 + 1];
         dst[i * 4 + 2] = src[i * 3 + 2];
         dst[i * 4 + 3] = 0xff;
      }
   }
}


static void
put_mono_row_ubyte4(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
                    GLint x, GLint y, const void *value, const GLubyte *mask)
{
   /* treat 4*GLubyte as 1*GLuint */
   const GLuint val = *((const GLuint *) value);
   GLuint *dst = (GLuint *) rb->Data + (y * rb->RowStride + x);
   ASSERT(rb->DataType == GL_UNSIGNED_BYTE);
   ASSERT(rb->Format == MESA_FORMAT_RGBA8888);
   if (!mask && val == 0) {
      /* common case */
      memset(dst, 0, count * 4 * sizeof(GLubyte));
   }
   else {
      /* general case */
      if (mask) {
         GLuint i;
         for (i = 0; i < count; i++) {
            if (mask[i]) {
               dst[i] = val;
            }
         }
      }
      else {
         GLuint i;
         for (i = 0; i < count; i++) {
            dst[i] = val;
         }
      }
   }
}


static void
put_values_ubyte4(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
                  const GLint x[], const GLint y[], const void *values,
                  const GLubyte *mask)
{
   /* treat 4*GLubyte as 1*GLuint */
   const GLuint *src = (const GLuint *) values;
   GLuint i;
   ASSERT(rb->DataType == GL_UNSIGNED_BYTE);
   ASSERT(rb->Format == MESA_FORMAT_RGBA8888);
   for (i = 0; i < count; i++) {
      if (!mask || mask[i]) {
         GLuint *dst = (GLuint *) rb->Data + (y[i] * rb->RowStride + x[i]);
         *dst = src[i];
      }
   }
}


static void
put_mono_values_ubyte4(struct gl_context *ctx, struct gl_renderbuffer *rb,
                       GLuint count, const GLint x[], const GLint y[],
                       const void *value, const GLubyte *mask)
{
   /* treat 4*GLubyte as 1*GLuint */
   const GLuint val = *((const GLuint *) value);
   GLuint i;
   ASSERT(rb->DataType == GL_UNSIGNED_BYTE);
   ASSERT(rb->Format == MESA_FORMAT_RGBA8888);
   for (i = 0; i < count; i++) {
      if (!mask || mask[i]) {
         GLuint *dst = (GLuint *) rb->Data + (y[i] * rb->RowStride + x[i]);
         *dst = val;
      }
   }
}


/**********************************************************************
 * Functions for buffers of 4 X GLushort (or GLshort) values.
 * Typically accum buffer.
 */

static void
get_values_ushort4(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
                   const GLint x[], const GLint y[], void *values)
{
   GLushort *dst = (GLushort *) values;
   GLuint i;
   ASSERT(rb->DataType == GL_UNSIGNED_SHORT || rb->DataType == GL_SHORT);
   for (i = 0; i < count; i++) {
      const GLushort *src
         = (GLushort *) rb->Data + 4 * (y[i] * rb->RowStride + x[i]);
      dst[i] = *src;
   }
}


static void
put_row_ushort4(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
                GLint x, GLint y, const void *values, const GLubyte *mask)
{
   const GLushort *src = (const GLushort *) values;
   GLushort *dst = (GLushort *) rb->Data + 4 * (y * rb->RowStride + x);
   ASSERT(rb->DataType == GL_UNSIGNED_SHORT || rb->DataType == GL_SHORT);
   if (mask) {
      GLuint i;
      for (i = 0; i < count; i++) {
         if (mask[i]) {
            dst[i * 4 + 0] = src[i * 4 + 0];
            dst[i * 4 + 1] = src[i * 4 + 1];
            dst[i * 4 + 2] = src[i * 4 + 2];
            dst[i * 4 + 3] = src[i * 4 + 3];
         }
      }
   }
   else {
      memcpy(dst, src, 4 * count * sizeof(GLushort));
   }
}


static void
put_row_rgb_ushort4(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
                    GLint x, GLint y, const void *values, const GLubyte *mask)
{
   /* Put RGB values in RGBA buffer */
   const GLushort *src = (const GLushort *) values;
   GLushort *dst = (GLushort *) rb->Data + 4 * (y * rb->RowStride + x);
   ASSERT(rb->DataType == GL_UNSIGNED_SHORT || rb->DataType == GL_SHORT);
   if (mask) {
      GLuint i;
      for (i = 0; i < count; i++) {
         if (mask[i]) {
            dst[i * 4 + 0] = src[i * 3 + 0];
            dst[i * 4 + 1] = src[i * 3 + 1];
            dst[i * 4 + 2] = src[i * 3 + 2];
            dst[i * 4 + 3] = 0xffff;
         }
      }
   }
   else {
      memcpy(dst, src, 4 * count * sizeof(GLushort));
   }
}


static void
put_mono_row_ushort4(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
                     GLint x, GLint y, const void *value, const GLubyte *mask)
{
   const GLushort val0 = ((const GLushort *) value)[0];
   const GLushort val1 = ((const GLushort *) value)[1];
   const GLushort val2 = ((const GLushort *) value)[2];
   const GLushort val3 = ((const GLushort *) value)[3];
   GLushort *dst = (GLushort *) rb->Data + 4 * (y * rb->RowStride + x);
   ASSERT(rb->DataType == GL_UNSIGNED_SHORT || rb->DataType == GL_SHORT);
   if (!mask && val0 == 0 && val1 == 0 && val2 == 0 && val3 == 0) {
      /* common case for clearing accum buffer */
      memset(dst, 0, count * 4 * sizeof(GLushort));
   }
   else {
      GLuint i;
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            dst[i * 4 + 0] = val0;
            dst[i * 4 + 1] = val1;
            dst[i * 4 + 2] = val2;
            dst[i * 4 + 3] = val3;
         }
      }
   }
}


static void
put_values_ushort4(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
                   const GLint x[], const GLint y[], const void *values,
                   const GLubyte *mask)
{
   const GLushort *src = (const GLushort *) values;
   GLuint i;
   ASSERT(rb->DataType == GL_UNSIGNED_SHORT || rb->DataType == GL_SHORT);
   for (i = 0; i < count; i++) {
      if (!mask || mask[i]) {
         GLushort *dst =
            ((GLushort *) rb->Data) + 4 * (y[i] * rb->RowStride + x[i]);
         dst[0] = src[i * 4 + 0];
         dst[1] = src[i * 4 + 1];
         dst[2] = src[i * 4 + 2];
         dst[3] = src[i * 4 + 3];
      }
   }
}


static void
put_mono_values_ushort4(struct gl_context *ctx, struct gl_renderbuffer *rb,
                        GLuint count, const GLint x[], const GLint y[],
                        const void *value, const GLubyte *mask)
{
   const GLushort val0 = ((const GLushort *) value)[0];
   const GLushort val1 = ((const GLushort *) value)[1];
   const GLushort val2 = ((const GLushort *) value)[2];
   const GLushort val3 = ((const GLushort *) value)[3];
   GLuint i;
   ASSERT(rb->DataType == GL_UNSIGNED_SHORT || rb->DataType == GL_SHORT);
   for (i = 0; i < count; i++) {
      if (!mask || mask[i]) {
         GLushort *dst = ((GLushort *) rb->Data) +
				       4 * (y[i] * rb->RowStride + x[i]);
         dst[0] = val0;
         dst[1] = val1;
         dst[2] = val2;
         dst[3] = val3;
      }
   }
}

/**********************************************************************
 * Functions for MESA_FORMAT_R8.
 */
static void
get_row_r8(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
	   GLint x, GLint y, void *values)
{
   const GLubyte *src = rb->GetPointer(ctx, rb, x, y);
   GLuint *dst = values;
   GLuint i;

   for (i = 0; i < count; i++) {
      dst[i] = 0xff000000 | src[i];
   }
}

static void
get_values_r8(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
	      const GLint x[], const GLint y[], void *values)
{
   GLuint *dst = (GLuint *) values;
   GLuint i;

   for (i = 0; i < count; i++) {
      const GLubyte *src = rb->GetPointer(ctx, rb, x[i], y[i]);
      dst[i] = 0xff000000 | *src;
   }
}

/**********************************************************************
 * Functions for MESA_FORMAT_RG88.
 */
static void
get_row_rg88(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
	     GLint x, GLint y, void *values)
{
   const GLushort *src = rb->GetPointer(ctx, rb, x, y);
   GLuint *dst = values;
   GLuint i;

   for (i = 0; i < count; i++) {
      dst[i] = 0xff000000 | src[i];
   }
}

static void
get_values_rg88(struct gl_context *ctx, struct gl_renderbuffer *rb,
		GLuint count, const GLint x[], const GLint y[], void *values)
{
   GLuint *dst = (GLuint *) values;
   GLuint i;

   for (i = 0; i < count; i++) {
      const GLshort *src = rb->GetPointer(ctx, rb, x[i], y[i]);
      dst[i] = 0xff000000 | *src;
   }
}

/**********************************************************************
 * Functions for MESA_FORMAT_R16.
 */
static void
get_row_r16(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
	    GLint x, GLint y, void *values)
{
   const GLushort *src = rb->GetPointer(ctx, rb, x, y);
   GLushort *dst = values;
   GLuint i;

   for (i = 0; i < count; i++) {
      dst[i * 4 + RCOMP] = src[i];
      dst[i * 4 + GCOMP] = 0;
      dst[i * 4 + BCOMP] = 0;
      dst[i * 4 + ACOMP] = 0xffff;
   }
}

static void
get_values_r16(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
	       const GLint x[], const GLint y[], void *values)
{
   GLushort *dst = values;
   GLuint i;

   for (i = 0; i < count; i++) {
      const GLushort *src = rb->GetPointer(ctx, rb, x[i], y[i]);
      dst[i * 4 + RCOMP] = *src;
      dst[i * 4 + GCOMP] = 0;
      dst[i * 4 + BCOMP] = 0;
      dst[i * 4 + ACOMP] = 0xffff;
   }
}

/**********************************************************************
 * Functions for MESA_FORMAT_RG1616.
 */
static void
get_row_rg1616(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
	       GLint x, GLint y, void *values)
{
   const GLushort *src = rb->GetPointer(ctx, rb, x, y);
   GLushort *dst = values;
   GLuint i;

   for (i = 0; i < count; i++) {
      dst[i * 4 + RCOMP] = src[i * 2];
      dst[i * 4 + GCOMP] = src[i * 2 + 1];
      dst[i * 4 + BCOMP] = 0;
      dst[i * 4 + ACOMP] = 0xffff;
   }
}

static void
get_values_rg1616(struct gl_context *ctx, struct gl_renderbuffer *rb,
		  GLuint count, const GLint x[], const GLint y[], void *values)
{
   GLushort *dst = values;
   GLuint i;

   for (i = 0; i < count; i++) {
      const GLshort *src = rb->GetPointer(ctx, rb, x[i], y[i]);
      dst[i * 4 + RCOMP] = src[0];
      dst[i * 4 + GCOMP] = src[1];
      dst[i * 4 + BCOMP] = 0;
      dst[i * 4 + ACOMP] = 0xffff;
   }
}

/**********************************************************************
 * Functions for MESA_FORMAT_INTENSITY_FLOAT32.
 */
static void
get_row_i_float32(struct gl_context *ctx, struct gl_renderbuffer *rb,
		  GLuint count, GLint x, GLint y, void *values)
{
   const GLfloat *src = rb->GetPointer(ctx, rb, x, y);
   GLfloat *dst = values;
   GLuint i;

   for (i = 0; i < count; i++) {
      dst[i * 4 + RCOMP] =
      dst[i * 4 + GCOMP] =
      dst[i * 4 + BCOMP] =
      dst[i * 4 + ACOMP] = src[i];
   }
}

static void
get_values_i_float32(struct gl_context *ctx, struct gl_renderbuffer *rb,
		     GLuint count, const GLint x[], const GLint y[],
		     void *values)
{
   GLfloat *dst = values;
   GLuint i;

   for (i = 0; i < count; i++) {
      const GLfloat *src = rb->GetPointer(ctx, rb, x[i], y[i]);
      dst[i * 4 + RCOMP] =
      dst[i * 4 + GCOMP] =
      dst[i * 4 + BCOMP] =
      dst[i * 4 + ACOMP] = src[0];
   }
}

/**********************************************************************
 * Functions for MESA_FORMAT_LUMINANCE_FLOAT32.
 */
static void
get_row_l_float32(struct gl_context *ctx, struct gl_renderbuffer *rb,
		  GLuint count, GLint x, GLint y, void *values)
{
   const GLfloat *src = rb->GetPointer(ctx, rb, x, y);
   GLfloat *dst = values;
   GLuint i;

   for (i = 0; i < count; i++) {
      dst[i * 4 + RCOMP] =
      dst[i * 4 + GCOMP] =
      dst[i * 4 + BCOMP] = src[i];
      dst[i * 4 + ACOMP] = 1.0;
   }
}

static void
get_values_l_float32(struct gl_context *ctx, struct gl_renderbuffer *rb,
		     GLuint count, const GLint x[], const GLint y[],
		     void *values)
{
   GLfloat *dst = values;
   GLuint i;

   for (i = 0; i < count; i++) {
      const GLfloat *src = rb->GetPointer(ctx, rb, x[i], y[i]);
      dst[i * 4 + RCOMP] =
      dst[i * 4 + GCOMP] =
      dst[i * 4 + BCOMP] = src[0];
      dst[i * 4 + ACOMP] = 1.0;
   }
}

/**********************************************************************
 * Functions for MESA_FORMAT_ALPHA_FLOAT32.
 */
static void
get_row_a_float32(struct gl_context *ctx, struct gl_renderbuffer *rb,
		  GLuint count, GLint x, GLint y, void *values)
{
   const GLfloat *src = rb->GetPointer(ctx, rb, x, y);
   GLfloat *dst = values;
   GLuint i;

   for (i = 0; i < count; i++) {
      dst[i * 4 + RCOMP] = 0.0;
      dst[i * 4 + GCOMP] = 0.0;
      dst[i * 4 + BCOMP] = 0.0;
      dst[i * 4 + ACOMP] = src[i];
   }
}

static void
get_values_a_float32(struct gl_context *ctx, struct gl_renderbuffer *rb,
		     GLuint count, const GLint x[], const GLint y[],
		     void *values)
{
   GLfloat *dst = values;
   GLuint i;

   for (i = 0; i < count; i++) {
      const GLfloat *src = rb->GetPointer(ctx, rb, x[i], y[i]);
      dst[i * 4 + RCOMP] = 0.0;
      dst[i * 4 + GCOMP] = 0.0;
      dst[i * 4 + BCOMP] = 0.0;
      dst[i * 4 + ACOMP] = src[0];
   }
}

static void
put_row_a_float32(struct gl_context *ctx, struct gl_renderbuffer *rb,
		  GLuint count, GLint x, GLint y,
		  const void *values, const GLubyte *mask)
{
   float *dst = rb->GetPointer(ctx, rb, x, y);
   const float *src = values;
   unsigned int i;

   if (mask) {
      for (i = 0; i < count; i++) {
         if (mask[i]) {
	    dst[i] = src[i * 4 + ACOMP];
         }
      }
   }
   else {
      for (i = 0; i < count; i++) {
	 dst[i] = src[i * 4 + ACOMP];
      }
   }
}

static void
put_mono_row_a_float32(struct gl_context *ctx, struct gl_renderbuffer *rb,
		       GLuint count, GLint x, GLint y,
		       const void *value, const GLubyte *mask)
{
   float *dst = rb->GetPointer(ctx, rb, x, y);
   const float *src = value;
   unsigned int i;

   if (mask) {
      for (i = 0; i < count; i++) {
         if (mask[i]) {
	    dst[i] = src[ACOMP];
         }
      }
   }
   else {
      for (i = 0; i < count; i++) {
	 dst[i] = src[ACOMP];
      }
   }
}

static void
put_values_a_float32(struct gl_context *ctx, struct gl_renderbuffer *rb,
		     GLuint count, const GLint x[], const GLint y[],
		     const void *values, const GLubyte *mask)
{
   const float *src = values;
   unsigned int i;

   for (i = 0; i < count; i++) {
      if (!mask || mask[i]) {
	 float *dst = rb->GetPointer(ctx, rb, x[i], y[i]);

	 *dst = src[i * 4 + ACOMP];
      }
   }
}

static void
put_mono_values_a_float32(struct gl_context *ctx,
			  struct gl_renderbuffer *rb,
			  GLuint count, const GLint x[], const GLint y[],
			  const void *value, const GLubyte *mask)
{
   const float *src = value;
   unsigned int i;

   for (i = 0; i < count; i++) {
      if (!mask || mask[i]) {
	 float *dst = rb->GetPointer(ctx, rb, x[i], y[i]);
	 *dst = src[ACOMP];
      }
   }
}

/**********************************************************************
 * Functions for MESA_FORMAT_R_FLOAT32.
 */
static void
get_row_r_float32(struct gl_context *ctx, struct gl_renderbuffer *rb,
		  GLuint count, GLint x, GLint y, void *values)
{
   const GLfloat *src = rb->GetPointer(ctx, rb, x, y);
   GLfloat *dst = values;
   GLuint i;

   for (i = 0; i < count; i++) {
      dst[i * 4 + RCOMP] = src[i];
      dst[i * 4 + GCOMP] = 0.0;
      dst[i * 4 + BCOMP] = 0.0;
      dst[i * 4 + ACOMP] = 1.0;
   }
}

static void
get_values_r_float32(struct gl_context *ctx, struct gl_renderbuffer *rb,
		     GLuint count, const GLint x[], const GLint y[],
		     void *values)
{
   GLfloat *dst = values;
   GLuint i;

   for (i = 0; i < count; i++) {
      const GLfloat *src = rb->GetPointer(ctx, rb, x[i], y[i]);
      dst[i * 4 + RCOMP] = src[0];
      dst[i * 4 + GCOMP] = 0.0;
      dst[i * 4 + BCOMP] = 0.0;
      dst[i * 4 + ACOMP] = 1.0;
   }
}

/**********************************************************************
 * Functions for MESA_FORMAT_RG_FLOAT32.
 */
static void
get_row_rg_float32(struct gl_context *ctx, struct gl_renderbuffer *rb,
		   GLuint count, GLint x, GLint y, void *values)
{
   const GLfloat *src = rb->GetPointer(ctx, rb, x, y);
   GLfloat *dst = values;
   GLuint i;

   for (i = 0; i < count; i++) {
      dst[i * 4 + RCOMP] = src[i * 2 + 0];
      dst[i * 4 + GCOMP] = src[i * 2 + 1];
      dst[i * 4 + BCOMP] = 0.0;
      dst[i * 4 + ACOMP] = 1.0;
   }
}

static void
get_values_rg_float32(struct gl_context *ctx, struct gl_renderbuffer *rb,
		      GLuint count, const GLint x[], const GLint y[],
		      void *values)
{
   GLfloat *dst = values;
   GLuint i;

   for (i = 0; i < count; i++) {
      const GLfloat *src = rb->GetPointer(ctx, rb, x[i], y[i]);
      dst[i * 4 + RCOMP] = src[0];
      dst[i * 4 + GCOMP] = src[1];
      dst[i * 4 + BCOMP] = 0.0;
      dst[i * 4 + ACOMP] = 1.0;
   }
}

/**
 * This is the default software fallback for gl_renderbuffer's span
 * access functions.
 *
 * The assumptions are that rb->Data will be a pointer to (0,0), that pixels
 * are packed in the type of rb->Format, and that subsequent rows appear
 * rb->RowStride pixels later.
 */
void
_mesa_set_renderbuffer_accessors(struct gl_renderbuffer *rb)
{
   rb->GetPointer = get_pointer_generic;
   rb->GetRow = get_row_generic;

   switch (rb->Format) {
   case MESA_FORMAT_RGB888:
      rb->DataType = GL_UNSIGNED_BYTE;
      rb->GetPointer = get_pointer_ubyte3;
      rb->GetRow = get_row_ubyte3;
      rb->GetValues = get_values_ubyte3;
      rb->PutRow = put_row_ubyte3;
      rb->PutRowRGB = put_row_rgb_ubyte3;
      rb->PutMonoRow = put_mono_row_ubyte3;
      rb->PutValues = put_values_ubyte3;
      rb->PutMonoValues = put_mono_values_ubyte3;
      break;

   case MESA_FORMAT_RGBA8888:
      rb->DataType = GL_UNSIGNED_BYTE;
      rb->GetValues = get_values_ubyte4;
      rb->PutRow = put_row_ubyte4;
      rb->PutRowRGB = put_row_rgb_ubyte4;
      rb->PutMonoRow = put_mono_row_ubyte4;
      rb->PutValues = put_values_ubyte4;
      rb->PutMonoValues = put_mono_values_ubyte4;
      break;

   case MESA_FORMAT_R8:
      rb->DataType = GL_UNSIGNED_BYTE;
      rb->GetValues = get_values_r8;
      rb->GetRow = get_row_r8;
      rb->PutRow = put_row_generic;
      rb->PutRowRGB = put_row_generic;
      rb->PutMonoRow = put_mono_row_generic;
      rb->PutValues = put_values_generic;
      rb->PutMonoValues = put_mono_values_generic;
      break;

   case MESA_FORMAT_RG88:
      rb->DataType = GL_UNSIGNED_BYTE;
      rb->GetValues = get_values_rg88;
      rb->GetRow = get_row_rg88;
      rb->PutRow = put_row_generic;
      rb->PutRowRGB = put_row_generic;
      rb->PutMonoRow = put_mono_row_generic;
      rb->PutValues = put_values_generic;
      rb->PutMonoValues = put_mono_values_generic;
      break;

   case MESA_FORMAT_R16:
      rb->DataType = GL_UNSIGNED_SHORT;
      rb->GetValues = get_values_r16;
      rb->GetRow = get_row_r16;
      rb->PutRow = put_row_generic;
      rb->PutRowRGB = put_row_generic;
      rb->PutMonoRow = put_mono_row_generic;
      rb->PutValues = put_values_generic;
      rb->PutMonoValues = put_mono_values_generic;
      break;

   case MESA_FORMAT_RG1616:
      rb->DataType = GL_UNSIGNED_SHORT;
      rb->GetValues = get_values_rg1616;
      rb->GetRow = get_row_rg1616;
      rb->PutRow = put_row_generic;
      rb->PutRowRGB = put_row_generic;
      rb->PutMonoRow = put_mono_row_generic;
      rb->PutValues = put_values_generic;
      rb->PutMonoValues = put_mono_values_generic;
      break;

   case MESA_FORMAT_SIGNED_RGBA_16:
      rb->DataType = GL_SHORT;
      rb->GetValues = get_values_ushort4;
      rb->PutRow = put_row_ushort4;
      rb->PutRowRGB = put_row_rgb_ushort4;
      rb->PutMonoRow = put_mono_row_ushort4;
      rb->PutValues = put_values_ushort4;
      rb->PutMonoValues = put_mono_values_ushort4;
      break;

#if 0
   case MESA_FORMAT_A8:
      rb->DataType = GL_UNSIGNED_BYTE;
      rb->GetValues = get_values_alpha8;
      rb->PutRow = put_row_alpha8;
      rb->PutRowRGB = NULL;
      rb->PutMonoRow = put_mono_row_alpha8;
      rb->PutValues = put_values_alpha8;
      rb->PutMonoValues = put_mono_values_alpha8;
      break;
#endif

   case MESA_FORMAT_S8:
      rb->DataType = GL_UNSIGNED_BYTE;
      rb->GetValues = get_values_ubyte;
      rb->PutRow = put_row_ubyte;
      rb->PutRowRGB = NULL;
      rb->PutMonoRow = put_mono_row_ubyte;
      rb->PutValues = put_values_ubyte;
      rb->PutMonoValues = put_mono_values_ubyte;
      break;

   case MESA_FORMAT_Z16:
      rb->DataType = GL_UNSIGNED_SHORT;
      rb->GetValues = get_values_ushort;
      rb->PutRow = put_row_ushort;
      rb->PutRowRGB = NULL;
      rb->PutMonoRow = put_mono_row_ushort;
      rb->PutValues = put_values_ushort;
      rb->PutMonoValues = put_mono_values_ushort;
      break;

   case MESA_FORMAT_Z32:
   case MESA_FORMAT_X8_Z24:
   case MESA_FORMAT_Z24_X8:
      rb->DataType = GL_UNSIGNED_INT;
      rb->GetValues = get_values_uint;
      rb->PutRow = put_row_uint;
      rb->PutRowRGB = NULL;
      rb->PutMonoRow = put_mono_row_uint;
      rb->PutValues = put_values_uint;
      rb->PutMonoValues = put_mono_values_uint;
      break;

   case MESA_FORMAT_Z24_S8:
   case MESA_FORMAT_S8_Z24:
      rb->DataType = GL_UNSIGNED_INT_24_8_EXT;
      rb->GetValues = get_values_uint;
      rb->PutRow = put_row_uint;
      rb->PutRowRGB = NULL;
      rb->PutMonoRow = put_mono_row_uint;
      rb->PutValues = put_values_uint;
      rb->PutMonoValues = put_mono_values_uint;
      break;

   case MESA_FORMAT_RGBA_FLOAT32:
      rb->GetRow = get_row_generic;
      rb->GetValues = get_values_generic;
      rb->PutRow = put_row_generic;
      rb->PutRowRGB = NULL;
      rb->PutMonoRow = put_mono_row_generic;
      rb->PutValues = put_values_generic;
      rb->PutMonoValues = put_mono_values_generic;
      break;

   case MESA_FORMAT_INTENSITY_FLOAT32:
      rb->GetRow = get_row_i_float32;
      rb->GetValues = get_values_i_float32;
      rb->PutRow = put_row_generic;
      rb->PutRowRGB = NULL;
      rb->PutMonoRow = put_mono_row_generic;
      rb->PutValues = put_values_generic;
      rb->PutMonoValues = put_mono_values_generic;
      break;

   case MESA_FORMAT_LUMINANCE_FLOAT32:
      rb->GetRow = get_row_l_float32;
      rb->GetValues = get_values_l_float32;
      rb->PutRow = put_row_generic;
      rb->PutRowRGB = NULL;
      rb->PutMonoRow = put_mono_row_generic;
      rb->PutValues = put_values_generic;
      rb->PutMonoValues = put_mono_values_generic;
      break;

   case MESA_FORMAT_ALPHA_FLOAT32:
      rb->GetRow = get_row_a_float32;
      rb->GetValues = get_values_a_float32;
      rb->PutRow = put_row_a_float32;
      rb->PutRowRGB = NULL;
      rb->PutMonoRow = put_mono_row_a_float32;
      rb->PutValues = put_values_a_float32;
      rb->PutMonoValues = put_mono_values_a_float32;
      break;

   case MESA_FORMAT_RG_FLOAT32:
      rb->GetRow = get_row_rg_float32;
      rb->GetValues = get_values_rg_float32;
      rb->PutRow = put_row_generic;
      rb->PutRowRGB = NULL;
      rb->PutMonoRow = put_mono_row_generic;
      rb->PutValues = put_values_generic;
      rb->PutMonoValues = put_mono_values_generic;
      break;

   case MESA_FORMAT_R_FLOAT32:
      rb->GetRow = get_row_r_float32;
      rb->GetValues = get_values_r_float32;
      rb->PutRow = put_row_generic;
      rb->PutRowRGB = NULL;
      rb->PutMonoRow = put_mono_row_generic;
      rb->PutValues = put_values_generic;
      rb->PutMonoValues = put_mono_values_generic;
      break;

   default:
      break;
   }
}

/**
 * This is a software fallback for the gl_renderbuffer->AllocStorage
 * function.
 * Device drivers will typically override this function for the buffers
 * which it manages (typically color buffers, Z and stencil).
 * Other buffers (like software accumulation and aux buffers) which the driver
 * doesn't manage can be handled with this function.
 *
 * This one multi-purpose function can allocate stencil, depth, accum, color
 * or color-index buffers!
 *
 * This function also plugs in the appropriate GetPointer, Get/PutRow and
 * Get/PutValues functions.
 */
GLboolean
_mesa_soft_renderbuffer_storage(struct gl_context *ctx, struct gl_renderbuffer *rb,
                                GLenum internalFormat,
                                GLuint width, GLuint height)
{
   switch (internalFormat) {
   case GL_RGB:
   case GL_R3_G3_B2:
   case GL_RGB4:
   case GL_RGB5:
   case GL_RGB8:
   case GL_RGB10:
   case GL_RGB12:
   case GL_RGB16:
      rb->Format = MESA_FORMAT_RGB888;
      break;
   case GL_RGBA:
   case GL_RGBA2:
   case GL_RGBA4:
   case GL_RGB5_A1:
   case GL_RGBA8:
#if 1
   case GL_RGB10_A2:
   case GL_RGBA12:
#endif
      rb->Format = MESA_FORMAT_RGBA8888;
      break;
   case GL_RGBA16:
   case GL_RGBA16_SNORM:
      /* for accum buffer */
      rb->Format = MESA_FORMAT_SIGNED_RGBA_16;
      break;
#if 0
   case GL_ALPHA8:
      rb->Format = MESA_FORMAT_A8;
      break;
#endif
   case GL_STENCIL_INDEX:
   case GL_STENCIL_INDEX1_EXT:
   case GL_STENCIL_INDEX4_EXT:
   case GL_STENCIL_INDEX8_EXT:
   case GL_STENCIL_INDEX16_EXT:
      rb->Format = MESA_FORMAT_S8;
      break;
   case GL_DEPTH_COMPONENT:
   case GL_DEPTH_COMPONENT16:
      rb->Format = MESA_FORMAT_Z16;
      break;
   case GL_DEPTH_COMPONENT24:
      rb->Format = MESA_FORMAT_X8_Z24;
      break;
   case GL_DEPTH_COMPONENT32:
      rb->Format = MESA_FORMAT_Z32;
      break;
   case GL_DEPTH_STENCIL_EXT:
   case GL_DEPTH24_STENCIL8_EXT:
      rb->Format = MESA_FORMAT_Z24_S8;
      break;
   default:
      /* unsupported format */
      return GL_FALSE;
   }

   _mesa_set_renderbuffer_accessors(rb);

   ASSERT(rb->DataType);
   ASSERT(rb->GetPointer);
   ASSERT(rb->GetRow);
   ASSERT(rb->GetValues);
   ASSERT(rb->PutRow);
   ASSERT(rb->PutMonoRow);
   ASSERT(rb->PutValues);
   ASSERT(rb->PutMonoValues);

   /* free old buffer storage */
   if (rb->Data) {
      free(rb->Data);
      rb->Data = NULL;
   }

   rb->RowStride = width;

   if (width > 0 && height > 0) {
      /* allocate new buffer storage */
      rb->Data = malloc(width * height * _mesa_get_format_bytes(rb->Format));

      if (rb->Data == NULL) {
         rb->Width = 0;
         rb->Height = 0;
	 rb->RowStride = 0;
         _mesa_error(ctx, GL_OUT_OF_MEMORY,
                     "software renderbuffer allocation (%d x %d x %d)",
                     width, height, _mesa_get_format_bytes(rb->Format));
         return GL_FALSE;
      }
   }

   rb->Width = width;
   rb->Height = height;
   rb->_BaseFormat = _mesa_base_fbo_format(ctx, internalFormat);

   if (rb->Name == 0 &&
       internalFormat == GL_RGBA16_SNORM &&
       rb->_BaseFormat == 0) {
      /* NOTE: This is a special case just for accumulation buffers.
       * This is a very limited use case- there's no snorm texturing or
       * rendering going on.
       */
      rb->_BaseFormat = GL_RGBA;
   }
   else {
      /* the internalFormat should have been error checked long ago */
      ASSERT(rb->_BaseFormat);
   }

   return GL_TRUE;
}



/**********************************************************************/
/**********************************************************************/
/**********************************************************************/


/**
 * Here we utilize the gl_renderbuffer->Wrapper field to put an alpha
 * buffer wrapper around an existing RGB renderbuffer (hw or sw).
 *
 * When PutRow is called (for example), we store the alpha values in
 * this buffer, then pass on the PutRow call to the wrapped RGB
 * buffer.
 */


static GLboolean
alloc_storage_alpha8(struct gl_context *ctx, struct gl_renderbuffer *arb,
                     GLenum internalFormat, GLuint width, GLuint height)
{
   ASSERT(arb != arb->Wrapped);
   ASSERT(arb->Format == MESA_FORMAT_A8);

   /* first, pass the call to the wrapped RGB buffer */
   if (!arb->Wrapped->AllocStorage(ctx, arb->Wrapped, internalFormat,
                                  width, height)) {
      return GL_FALSE;
   }

   /* next, resize my alpha buffer */
   if (arb->Data) {
      free(arb->Data);
   }

   arb->Data = malloc(width * height * sizeof(GLubyte));
   if (arb->Data == NULL) {
      arb->Width = 0;
      arb->Height = 0;
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "software alpha buffer allocation");
      return GL_FALSE;
   }

   arb->Width = width;
   arb->Height = height;
   arb->RowStride = width;

   return GL_TRUE;
}


/**
 * Delete an alpha_renderbuffer object, as well as the wrapped RGB buffer.
 */
static void
delete_renderbuffer_alpha8(struct gl_renderbuffer *arb)
{
   if (arb->Data) {
      free(arb->Data);
   }
   ASSERT(arb->Wrapped);
   ASSERT(arb != arb->Wrapped);
   arb->Wrapped->Delete(arb->Wrapped);
   arb->Wrapped = NULL;
   free(arb);
}


static void *
get_pointer_alpha8(struct gl_context *ctx, struct gl_renderbuffer *arb,
                   GLint x, GLint y)
{
   return NULL;   /* don't allow direct access! */
}


static void
get_row_alpha8(struct gl_context *ctx, struct gl_renderbuffer *arb, GLuint count,
               GLint x, GLint y, void *values)
{
   /* NOTE: 'values' is RGBA format! */
   const GLubyte *src = (const GLubyte *) arb->Data + y * arb->RowStride + x;
   GLubyte *dst = (GLubyte *) values;
   GLuint i;
   ASSERT(arb != arb->Wrapped);
   ASSERT(arb->DataType == GL_UNSIGNED_BYTE);
   /* first, pass the call to the wrapped RGB buffer */
   arb->Wrapped->GetRow(ctx, arb->Wrapped, count, x, y, values);
   /* second, fill in alpha values from this buffer! */
   for (i = 0; i < count; i++) {
      dst[i * 4 + 3] = src[i];
   }
}


static void
get_values_alpha8(struct gl_context *ctx, struct gl_renderbuffer *arb, GLuint count,
                  const GLint x[], const GLint y[], void *values)
{
   GLubyte *dst = (GLubyte *) values;
   GLuint i;
   ASSERT(arb != arb->Wrapped);
   ASSERT(arb->DataType == GL_UNSIGNED_BYTE);
   /* first, pass the call to the wrapped RGB buffer */
   arb->Wrapped->GetValues(ctx, arb->Wrapped, count, x, y, values);
   /* second, fill in alpha values from this buffer! */
   for (i = 0; i < count; i++) {
      const GLubyte *src = (GLubyte *) arb->Data + y[i] * arb->RowStride + x[i];
      dst[i * 4 + 3] = *src;
   }
}


static void
put_row_alpha8(struct gl_context *ctx, struct gl_renderbuffer *arb, GLuint count,
               GLint x, GLint y, const void *values, const GLubyte *mask)
{
   const GLubyte *src = (const GLubyte *) values;
   GLubyte *dst = (GLubyte *) arb->Data + y * arb->RowStride + x;
   GLuint i;
   ASSERT(arb != arb->Wrapped);
   ASSERT(arb->DataType == GL_UNSIGNED_BYTE);
   /* first, pass the call to the wrapped RGB buffer */
   arb->Wrapped->PutRow(ctx, arb->Wrapped, count, x, y, values, mask);
   /* second, store alpha in our buffer */
   for (i = 0; i < count; i++) {
      if (!mask || mask[i]) {
         dst[i] = src[i * 4 + 3];
      }
   }
}


static void
put_row_rgb_alpha8(struct gl_context *ctx, struct gl_renderbuffer *arb, GLuint count,
                   GLint x, GLint y, const void *values, const GLubyte *mask)
{
   const GLubyte *src = (const GLubyte *) values;
   GLubyte *dst = (GLubyte *) arb->Data + y * arb->RowStride + x;
   GLuint i;
   ASSERT(arb != arb->Wrapped);
   ASSERT(arb->DataType == GL_UNSIGNED_BYTE);
   /* first, pass the call to the wrapped RGB buffer */
   arb->Wrapped->PutRowRGB(ctx, arb->Wrapped, count, x, y, values, mask);
   /* second, store alpha in our buffer */
   for (i = 0; i < count; i++) {
      if (!mask || mask[i]) {
         dst[i] = src[i * 4 + 3];
      }
   }
}


static void
put_mono_row_alpha8(struct gl_context *ctx, struct gl_renderbuffer *arb, GLuint count,
                    GLint x, GLint y, const void *value, const GLubyte *mask)
{
   const GLubyte val = ((const GLubyte *) value)[3];
   GLubyte *dst = (GLubyte *) arb->Data + y * arb->RowStride + x;
   ASSERT(arb != arb->Wrapped);
   ASSERT(arb->DataType == GL_UNSIGNED_BYTE);
   /* first, pass the call to the wrapped RGB buffer */
   arb->Wrapped->PutMonoRow(ctx, arb->Wrapped, count, x, y, value, mask);
   /* second, store alpha in our buffer */
   if (mask) {
      GLuint i;
      for (i = 0; i < count; i++) {
         if (mask[i]) {
            dst[i] = val;
         }
      }
   }
   else {
      memset(dst, val, count);
   }
}


static void
put_values_alpha8(struct gl_context *ctx, struct gl_renderbuffer *arb, GLuint count,
                  const GLint x[], const GLint y[],
                  const void *values, const GLubyte *mask)
{
   const GLubyte *src = (const GLubyte *) values;
   GLuint i;
   ASSERT(arb != arb->Wrapped);
   ASSERT(arb->DataType == GL_UNSIGNED_BYTE);
   /* first, pass the call to the wrapped RGB buffer */
   arb->Wrapped->PutValues(ctx, arb->Wrapped, count, x, y, values, mask);
   /* second, store alpha in our buffer */
   for (i = 0; i < count; i++) {
      if (!mask || mask[i]) {
         GLubyte *dst = (GLubyte *) arb->Data + y[i] * arb->RowStride + x[i];
         *dst = src[i * 4 + 3];
      }
   }
}


static void
put_mono_values_alpha8(struct gl_context *ctx, struct gl_renderbuffer *arb,
                       GLuint count, const GLint x[], const GLint y[],
                       const void *value, const GLubyte *mask)
{
   const GLubyte val = ((const GLubyte *) value)[3];
   GLuint i;
   ASSERT(arb != arb->Wrapped);
   ASSERT(arb->DataType == GL_UNSIGNED_BYTE);
   /* first, pass the call to the wrapped RGB buffer */
   arb->Wrapped->PutValues(ctx, arb->Wrapped, count, x, y, value, mask);
   /* second, store alpha in our buffer */
   for (i = 0; i < count; i++) {
      if (!mask || mask[i]) {
         GLubyte *dst = (GLubyte *) arb->Data + y[i] * arb->RowStride + x[i];
         *dst = val;
      }
   }
}


static void
copy_buffer_alpha8(struct gl_renderbuffer* dst, struct gl_renderbuffer* src)
{
   ASSERT(dst->Format == MESA_FORMAT_A8);
   ASSERT(src->Format == MESA_FORMAT_A8);
   ASSERT(dst->Width == src->Width);
   ASSERT(dst->Height == src->Height);
   ASSERT(dst->RowStride == src->RowStride);

   memcpy(dst->Data, src->Data, dst->RowStride * dst->Height * sizeof(GLubyte));
}


/**********************************************************************/
/**********************************************************************/
/**********************************************************************/


/**
 * Default GetPointer routine.  Always return NULL to indicate that
 * direct buffer access is not supported.
 */
static void *
nop_get_pointer(struct gl_context *ctx, struct gl_renderbuffer *rb, GLint x, GLint y)
{
   return NULL;
}


d55 2
a56 1
   rb->InternalFormat = GL_NONE;
a57 17

   rb->DataType = GL_NONE;
   rb->Data = NULL;

   /* Point back to ourself so that we don't have to check for Wrapped==NULL
    * all over the drivers.
    */
   rb->Wrapped = rb;

   rb->GetPointer = nop_get_pointer;
   rb->GetRow = NULL;
   rb->GetValues = NULL;
   rb->PutRow = NULL;
   rb->PutRowRGB = NULL;
   rb->PutMonoRow = NULL;
   rb->PutValues = NULL;
   rb->PutMonoValues = NULL;
d79 3
d84 1
a84 1
_mesa_delete_renderbuffer(struct gl_renderbuffer *rb)
d86 1
a86 3
   if (rb->Data) {
      free(rb->Data);
   }
a91 435
 * Allocate a software-based renderbuffer.  This is called via the
 * ctx->Driver.NewRenderbuffer() function when the user creates a new
 * renderbuffer.
 * This would not be used for hardware-based renderbuffers.
 */
struct gl_renderbuffer *
_mesa_new_soft_renderbuffer(struct gl_context *ctx, GLuint name)
{
   struct gl_renderbuffer *rb = _mesa_new_renderbuffer(ctx, name);
   if (rb) {
      rb->AllocStorage = _mesa_soft_renderbuffer_storage;
      /* Normally, one would setup the PutRow, GetRow, etc functions here.
       * But we're doing that in the _mesa_soft_renderbuffer_storage() function
       * instead.
       */
   }
   return rb;
}


/**
 * Add software-based color renderbuffers to the given framebuffer.
 * This is a helper routine for device drivers when creating a
 * window system framebuffer (not a user-created render/framebuffer).
 * Once this function is called, you can basically forget about this
 * renderbuffer; core Mesa will handle all the buffer management and
 * rendering!
 */
GLboolean
_mesa_add_color_renderbuffers(struct gl_context *ctx, struct gl_framebuffer *fb,
                              GLuint rgbBits, GLuint alphaBits,
                              GLboolean frontLeft, GLboolean backLeft,
                              GLboolean frontRight, GLboolean backRight)
{
   gl_buffer_index b;

   if (rgbBits > 16 || alphaBits > 16) {
      _mesa_problem(ctx,
                    "Unsupported bit depth in _mesa_add_color_renderbuffers");
      return GL_FALSE;
   }

   assert(MAX_COLOR_ATTACHMENTS >= 4);

   for (b = BUFFER_FRONT_LEFT; b <= BUFFER_BACK_RIGHT; b++) {
      struct gl_renderbuffer *rb;

      if (b == BUFFER_FRONT_LEFT && !frontLeft)
         continue;
      else if (b == BUFFER_BACK_LEFT && !backLeft)
         continue;
      else if (b == BUFFER_FRONT_RIGHT && !frontRight)
         continue;
      else if (b == BUFFER_BACK_RIGHT && !backRight)
         continue;

      assert(fb->Attachment[b].Renderbuffer == NULL);

      rb = _mesa_new_renderbuffer(ctx, 0);
      if (!rb) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "Allocating color buffer");
         return GL_FALSE;
      }

      if (rgbBits <= 8) {
         if (alphaBits)
            rb->Format = MESA_FORMAT_RGBA8888;
         else
            rb->Format = MESA_FORMAT_RGB888;
      }
      else {
         assert(rgbBits <= 16);
         rb->Format = MESA_FORMAT_NONE; /*XXX RGBA16;*/
      }
      rb->InternalFormat = GL_RGBA;

      rb->AllocStorage = _mesa_soft_renderbuffer_storage;
      _mesa_add_renderbuffer(fb, b, rb);
   }

   return GL_TRUE;
}


/**
 * Add software-based alpha renderbuffers to the given framebuffer.
 * This is a helper routine for device drivers when creating a
 * window system framebuffer (not a user-created render/framebuffer).
 * Once this function is called, you can basically forget about this
 * renderbuffer; core Mesa will handle all the buffer management and
 * rendering!
 */
GLboolean
_mesa_add_alpha_renderbuffers(struct gl_context *ctx, struct gl_framebuffer *fb,
                              GLuint alphaBits,
                              GLboolean frontLeft, GLboolean backLeft,
                              GLboolean frontRight, GLboolean backRight)
{
   gl_buffer_index b;

   /* for window system framebuffers only! */
   assert(fb->Name == 0);

   if (alphaBits > 8) {
      _mesa_problem(ctx,
                    "Unsupported bit depth in _mesa_add_alpha_renderbuffers");
      return GL_FALSE;
   }

   assert(MAX_COLOR_ATTACHMENTS >= 4);

   /* Wrap each of the RGB color buffers with an alpha renderbuffer.
    */
   for (b = BUFFER_FRONT_LEFT; b <= BUFFER_BACK_RIGHT; b++) {
      struct gl_renderbuffer *arb;

      if (b == BUFFER_FRONT_LEFT && !frontLeft)
         continue;
      else if (b == BUFFER_BACK_LEFT && !backLeft)
         continue;
      else if (b == BUFFER_FRONT_RIGHT && !frontRight)
         continue;
      else if (b == BUFFER_BACK_RIGHT && !backRight)
         continue;

      /* the RGB buffer to wrap must already exist!! */
      assert(fb->Attachment[b].Renderbuffer);

      /* only GLubyte supported for now */
      assert(fb->Attachment[b].Renderbuffer->DataType == GL_UNSIGNED_BYTE);

      /* allocate alpha renderbuffer */
      arb = _mesa_new_renderbuffer(ctx, 0);
      if (!arb) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "Allocating alpha buffer");
         return GL_FALSE;
      }

      /* wrap the alpha renderbuffer around the RGB renderbuffer */
      arb->Wrapped = fb->Attachment[b].Renderbuffer;

      /* Set up my alphabuffer fields and plug in my functions.
       * The functions will put/get the alpha values from/to RGBA arrays
       * and then call the wrapped buffer's functions to handle the RGB
       * values.
       */
      arb->InternalFormat = arb->Wrapped->InternalFormat;
      arb->Format         = MESA_FORMAT_A8;
      arb->DataType       = arb->Wrapped->DataType;
      arb->AllocStorage   = alloc_storage_alpha8;
      arb->Delete         = delete_renderbuffer_alpha8;
      arb->GetPointer     = get_pointer_alpha8;
      arb->GetRow         = get_row_alpha8;
      arb->GetValues      = get_values_alpha8;
      arb->PutRow         = put_row_alpha8;
      arb->PutRowRGB      = put_row_rgb_alpha8;
      arb->PutMonoRow     = put_mono_row_alpha8;
      arb->PutValues      = put_values_alpha8;
      arb->PutMonoValues  = put_mono_values_alpha8;

      /* clear the pointer to avoid assertion/sanity check failure later */
      fb->Attachment[b].Renderbuffer = NULL;

      /* plug the alpha renderbuffer into the colorbuffer attachment */
      _mesa_add_renderbuffer(fb, b, arb);
   }

   return GL_TRUE;
}


/**
 * For framebuffers that use a software alpha channel wrapper
 * created by _mesa_add_alpha_renderbuffer or _mesa_add_soft_renderbuffers,
 * copy the back buffer alpha channel into the front buffer alpha channel.
 */
void
_mesa_copy_soft_alpha_renderbuffers(struct gl_context *ctx, struct gl_framebuffer *fb)
{
   if (fb->Attachment[BUFFER_FRONT_LEFT].Renderbuffer &&
       fb->Attachment[BUFFER_BACK_LEFT].Renderbuffer)
      copy_buffer_alpha8(fb->Attachment[BUFFER_FRONT_LEFT].Renderbuffer,
                         fb->Attachment[BUFFER_BACK_LEFT].Renderbuffer);


   if (fb->Attachment[BUFFER_FRONT_RIGHT].Renderbuffer &&
       fb->Attachment[BUFFER_BACK_RIGHT].Renderbuffer)
      copy_buffer_alpha8(fb->Attachment[BUFFER_FRONT_RIGHT].Renderbuffer,
                         fb->Attachment[BUFFER_BACK_RIGHT].Renderbuffer);
}


/**
 * Add a software-based depth renderbuffer to the given framebuffer.
 * This is a helper routine for device drivers when creating a
 * window system framebuffer (not a user-created render/framebuffer).
 * Once this function is called, you can basically forget about this
 * renderbuffer; core Mesa will handle all the buffer management and
 * rendering!
 */
GLboolean
_mesa_add_depth_renderbuffer(struct gl_context *ctx, struct gl_framebuffer *fb,
                             GLuint depthBits)
{
   struct gl_renderbuffer *rb;

   if (depthBits > 32) {
      _mesa_problem(ctx,
                    "Unsupported depthBits in _mesa_add_depth_renderbuffer");
      return GL_FALSE;
   }

   assert(fb->Attachment[BUFFER_DEPTH].Renderbuffer == NULL);

   rb = _mesa_new_renderbuffer(ctx, 0);
   if (!rb) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "Allocating depth buffer");
      return GL_FALSE;
   }

   if (depthBits <= 16) {
      rb->Format = MESA_FORMAT_Z16;
      rb->InternalFormat = GL_DEPTH_COMPONENT16;
   }
   else if (depthBits <= 24) {
      rb->Format = MESA_FORMAT_X8_Z24;
      rb->InternalFormat = GL_DEPTH_COMPONENT24;
   }
   else {
      rb->Format = MESA_FORMAT_Z32;
      rb->InternalFormat = GL_DEPTH_COMPONENT32;
   }

   rb->AllocStorage = _mesa_soft_renderbuffer_storage;
   _mesa_add_renderbuffer(fb, BUFFER_DEPTH, rb);

   return GL_TRUE;
}


/**
 * Add a software-based stencil renderbuffer to the given framebuffer.
 * This is a helper routine for device drivers when creating a
 * window system framebuffer (not a user-created render/framebuffer).
 * Once this function is called, you can basically forget about this
 * renderbuffer; core Mesa will handle all the buffer management and
 * rendering!
 */
GLboolean
_mesa_add_stencil_renderbuffer(struct gl_context *ctx, struct gl_framebuffer *fb,
                               GLuint stencilBits)
{
   struct gl_renderbuffer *rb;

   if (stencilBits > 16) {
      _mesa_problem(ctx,
                  "Unsupported stencilBits in _mesa_add_stencil_renderbuffer");
      return GL_FALSE;
   }

   assert(fb->Attachment[BUFFER_STENCIL].Renderbuffer == NULL);

   rb = _mesa_new_renderbuffer(ctx, 0);
   if (!rb) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "Allocating stencil buffer");
      return GL_FALSE;
   }

   assert(stencilBits <= 8);
   rb->Format = MESA_FORMAT_S8;
   rb->InternalFormat = GL_STENCIL_INDEX8;

   rb->AllocStorage = _mesa_soft_renderbuffer_storage;
   _mesa_add_renderbuffer(fb, BUFFER_STENCIL, rb);

   return GL_TRUE;
}


/**
 * Add a software-based accumulation renderbuffer to the given framebuffer.
 * This is a helper routine for device drivers when creating a
 * window system framebuffer (not a user-created render/framebuffer).
 * Once this function is called, you can basically forget about this
 * renderbuffer; core Mesa will handle all the buffer management and
 * rendering!
 */
GLboolean
_mesa_add_accum_renderbuffer(struct gl_context *ctx, struct gl_framebuffer *fb,
                             GLuint redBits, GLuint greenBits,
                             GLuint blueBits, GLuint alphaBits)
{
   struct gl_renderbuffer *rb;

   if (redBits > 16 || greenBits > 16 || blueBits > 16 || alphaBits > 16) {
      _mesa_problem(ctx,
                    "Unsupported accumBits in _mesa_add_accum_renderbuffer");
      return GL_FALSE;
   }

   assert(fb->Attachment[BUFFER_ACCUM].Renderbuffer == NULL);

   rb = _mesa_new_renderbuffer(ctx, 0);
   if (!rb) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "Allocating accum buffer");
      return GL_FALSE;
   }

   rb->Format = MESA_FORMAT_SIGNED_RGBA_16;
   rb->InternalFormat = GL_RGBA16_SNORM;
   rb->AllocStorage = _mesa_soft_renderbuffer_storage;
   _mesa_add_renderbuffer(fb, BUFFER_ACCUM, rb);

   return GL_TRUE;
}



/**
 * Add a software-based aux renderbuffer to the given framebuffer.
 * This is a helper routine for device drivers when creating a
 * window system framebuffer (not a user-created render/framebuffer).
 * Once this function is called, you can basically forget about this
 * renderbuffer; core Mesa will handle all the buffer management and
 * rendering!
 *
 * NOTE: color-index aux buffers not supported.
 */
GLboolean
_mesa_add_aux_renderbuffers(struct gl_context *ctx, struct gl_framebuffer *fb,
                            GLuint colorBits, GLuint numBuffers)
{
   GLuint i;

   if (colorBits > 16) {
      _mesa_problem(ctx,
                    "Unsupported accumBits in _mesa_add_aux_renderbuffers");
      return GL_FALSE;
   }

   assert(numBuffers <= MAX_AUX_BUFFERS);

   for (i = 0; i < numBuffers; i++) {
      struct gl_renderbuffer *rb = _mesa_new_renderbuffer(ctx, 0);

      assert(fb->Attachment[BUFFER_AUX0 + i].Renderbuffer == NULL);

      if (!rb) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "Allocating aux buffer");
         return GL_FALSE;
      }

      assert (colorBits <= 8);
      rb->Format = MESA_FORMAT_RGBA8888;
      rb->InternalFormat = GL_RGBA;

      rb->AllocStorage = _mesa_soft_renderbuffer_storage;
      _mesa_add_renderbuffer(fb, BUFFER_AUX0 + i, rb);
   }
   return GL_TRUE;
}


/**
 * Create/attach software-based renderbuffers to the given framebuffer.
 * This is a helper routine for device drivers.  Drivers can just as well
 * call the individual _mesa_add_*_renderbuffer() routines directly.
 */
void
_mesa_add_soft_renderbuffers(struct gl_framebuffer *fb,
                             GLboolean color,
                             GLboolean depth,
                             GLboolean stencil,
                             GLboolean accum,
                             GLboolean alpha,
                             GLboolean aux)
{
   GLboolean frontLeft = GL_TRUE;
   GLboolean backLeft = fb->Visual.doubleBufferMode;
   GLboolean frontRight = fb->Visual.stereoMode;
   GLboolean backRight = fb->Visual.stereoMode && fb->Visual.doubleBufferMode;

   if (color) {
      assert(fb->Visual.redBits == fb->Visual.greenBits);
      assert(fb->Visual.redBits == fb->Visual.blueBits);
      _mesa_add_color_renderbuffers(NULL, fb,
				    fb->Visual.redBits,
				    fb->Visual.alphaBits,
				    frontLeft, backLeft,
				    frontRight, backRight);
   }

   if (depth) {
      assert(fb->Visual.depthBits > 0);
      _mesa_add_depth_renderbuffer(NULL, fb, fb->Visual.depthBits);
   }

   if (stencil) {
      assert(fb->Visual.stencilBits > 0);
      _mesa_add_stencil_renderbuffer(NULL, fb, fb->Visual.stencilBits);
   }

   if (accum) {
      assert(fb->Visual.accumRedBits > 0);
      assert(fb->Visual.accumGreenBits > 0);
      assert(fb->Visual.accumBlueBits > 0);
      _mesa_add_accum_renderbuffer(NULL, fb,
                                   fb->Visual.accumRedBits,
                                   fb->Visual.accumGreenBits,
                                   fb->Visual.accumBlueBits,
                                   fb->Visual.accumAlphaBits);
   }

   if (aux) {
      assert(fb->Visual.numAuxBuffers > 0);
      _mesa_add_aux_renderbuffers(NULL, fb, fb->Visual.redBits,
                                  fb->Visual.numAuxBuffers);
   }

   if (alpha) {
      assert(fb->Visual.alphaBits > 0);
      _mesa_add_alpha_renderbuffers(NULL, fb, fb->Visual.alphaBits,
                                    frontLeft, backLeft,
                                    frontRight, backRight);
   }

#if 0
   if (multisample) {
      /* maybe someday */
   }
#endif
}


/**
d112 1
a112 1
   if (fb->Name) {
a132 2
   struct gl_renderbuffer *rb;

d134 2
a135 8

   rb = fb->Attachment[bufferName].Renderbuffer;
   if (!rb)
      return;

   _mesa_reference_renderbuffer(&rb, NULL);

   fb->Attachment[bufferName].Renderbuffer = NULL;
d143 2
d147 2
a148 2
_mesa_reference_renderbuffer(struct gl_renderbuffer **ptr,
                             struct gl_renderbuffer *rb)
a149 6
   assert(ptr);
   if (*ptr == rb) {
      /* no change */
      return;
   }

d163 2
a164 1
         oldRb->Delete(oldRb);
@


1.5
log
@Merge Mesa 7.10.3
@
text
@d116 17
d1112 260
d1518 60
d1656 1
a1656 1
      _mesa_problem(ctx, "Bad internalFormat in _mesa_soft_renderbuffer_storage");
d1697 14
a1710 1
   ASSERT(rb->_BaseFormat);
a1971 1
   rb->Magic = RB_MAGIC;
d2070 1
a2070 1
   GLuint b;
d2134 1
a2134 1
   GLuint b;
d2472 1
d2476 1
a2476 1
                       GLuint bufferName, struct gl_renderbuffer *rb)
d2506 1
d2509 2
a2510 1
_mesa_remove_renderbuffer(struct gl_framebuffer *fb, GLuint bufferName)
a2545 1
      assert(oldRb->Magic == RB_MAGIC);
a2546 1
      assert(oldRb->Magic == RB_MAGIC);
a2553 1
         oldRb->Magic = 0; /* now invalid memory! */
a2561 1
      assert(rb->Magic == RB_MAGIC);
a2568 23
}


/**
 * Create a new combined depth/stencil renderbuffer for implementing
 * the GL_EXT_packed_depth_stencil extension.
 * \return new depth/stencil renderbuffer
 */
struct gl_renderbuffer *
_mesa_new_depthstencil_renderbuffer(struct gl_context *ctx, GLuint name)
{
   struct gl_renderbuffer *dsrb;

   dsrb = _mesa_new_renderbuffer(ctx, name);
   if (!dsrb)
      return NULL;

   /* init fields not covered by _mesa_new_renderbuffer() */
   dsrb->InternalFormat = GL_DEPTH24_STENCIL8_EXT;
   dsrb->Format = MESA_FORMAT_Z24_S8;
   dsrb->AllocStorage = _mesa_soft_renderbuffer_storage;

   return dsrb;
@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@a48 1
#include "fbobject.h"
a50 6
#include "rbadaptors.h"


/* 32-bit color index format.  Not a public format. */
#define COLOR_INDEX32 0x424243

a53 2
 * Someday add support for arbitrary row stride to make them more
 * flexible.
d56 6
a61 3
/**********************************************************************
 * Functions for buffers of 1 X GLubyte values.
 * Typically stencil.
d63 30
d94 1
d96 2
a97 2
get_pointer_ubyte(GLcontext *ctx, struct gl_renderbuffer *rb,
                  GLint x, GLint y)
d101 91
a191 5
   ASSERT(rb->DataType == GL_UNSIGNED_BYTE);
   /* Can't assert rb->Format since these funcs may be used for serveral
    * different formats (GL_ALPHA8, GL_STENCIL_INDEX8, etc).
    */
   return (GLubyte *) rb->Data + y * rb->Width + x;
d196 4
a199 2
get_row_ubyte(GLcontext *ctx, struct gl_renderbuffer *rb, GLuint count,
              GLint x, GLint y, void *values)
d201 9
a209 3
   const GLubyte *src = (const GLubyte *) rb->Data + y * rb->Width + x;
   ASSERT(rb->DataType == GL_UNSIGNED_BYTE);
   memcpy(values, src, count * sizeof(GLubyte));
d212 4
d218 1
a218 1
get_values_ubyte(GLcontext *ctx, struct gl_renderbuffer *rb, GLuint count,
d225 1
a225 1
      const GLubyte *src = (GLubyte *) rb->Data + y[i] * rb->Width + x[i];
d232 1
a232 1
put_row_ubyte(GLcontext *ctx, struct gl_renderbuffer *rb, GLuint count,
d236 1
a236 1
   GLubyte *dst = (GLubyte *) rb->Data + y * rb->Width + x;
d253 1
a253 1
put_mono_row_ubyte(GLcontext *ctx, struct gl_renderbuffer *rb, GLuint count,
d257 1
a257 1
   GLubyte *dst = (GLubyte *) rb->Data + y * rb->Width + x;
d277 1
a277 1
put_values_ubyte(GLcontext *ctx, struct gl_renderbuffer *rb, GLuint count,
d286 1
a286 1
         GLubyte *dst = (GLubyte *) rb->Data + y[i] * rb->Width + x[i];
d294 1
a294 1
put_mono_values_ubyte(GLcontext *ctx, struct gl_renderbuffer *rb, GLuint count,
d303 1
a303 1
         GLubyte *dst = (GLubyte *) rb->Data + y[i] * rb->Width + x[i];
a314 22
static void *
get_pointer_ushort(GLcontext *ctx, struct gl_renderbuffer *rb,
                   GLint x, GLint y)
{
   if (!rb->Data)
      return NULL;
   ASSERT(rb->DataType == GL_UNSIGNED_SHORT);
   ASSERT(rb->Width > 0);
   return (GLushort *) rb->Data + y * rb->Width + x;
}


static void
get_row_ushort(GLcontext *ctx, struct gl_renderbuffer *rb, GLuint count,
               GLint x, GLint y, void *values)
{
   const void *src = rb->GetPointer(ctx, rb, x, y);
   ASSERT(rb->DataType == GL_UNSIGNED_SHORT);
   memcpy(values, src, count * sizeof(GLushort));
}


d316 1
a316 1
get_values_ushort(GLcontext *ctx, struct gl_renderbuffer *rb, GLuint count,
d323 1
a323 1
      const GLushort *src = (GLushort *) rb->Data + y[i] * rb->Width + x[i];
d330 1
a330 1
put_row_ushort(GLcontext *ctx, struct gl_renderbuffer *rb, GLuint count,
d334 1
a334 1
   GLushort *dst = (GLushort *) rb->Data + y * rb->Width + x;
d351 1
a351 1
put_mono_row_ushort(GLcontext *ctx, struct gl_renderbuffer *rb, GLuint count,
d355 1
a355 1
   GLushort *dst = (GLushort *) rb->Data + y * rb->Width + x;
d375 1
a375 1
put_values_ushort(GLcontext *ctx, struct gl_renderbuffer *rb, GLuint count,
d384 1
a384 1
         GLushort *dst = (GLushort *) rb->Data + y[i] * rb->Width + x[i];
d392 1
a392 1
put_mono_values_ushort(GLcontext *ctx, struct gl_renderbuffer *rb,
d402 1
a402 1
            GLushort *dst = (GLushort *) rb->Data + y[i] * rb->Width + x[i];
d410 1
a410 1
         GLushort *dst = (GLushort *) rb->Data + y[i] * rb->Width + x[i];
a421 23
static void *
get_pointer_uint(GLcontext *ctx, struct gl_renderbuffer *rb,
                 GLint x, GLint y)
{
   if (!rb->Data)
      return NULL;
   ASSERT(rb->DataType == GL_UNSIGNED_INT ||
          rb->DataType == GL_UNSIGNED_INT_24_8_EXT);
   return (GLuint *) rb->Data + y * rb->Width + x;
}


static void
get_row_uint(GLcontext *ctx, struct gl_renderbuffer *rb, GLuint count,
             GLint x, GLint y, void *values)
{
   const void *src = rb->GetPointer(ctx, rb, x, y);
   ASSERT(rb->DataType == GL_UNSIGNED_INT ||
          rb->DataType == GL_UNSIGNED_INT_24_8_EXT);
   memcpy(values, src, count * sizeof(GLuint));
}


d423 1
a423 1
get_values_uint(GLcontext *ctx, struct gl_renderbuffer *rb, GLuint count,
d431 1
a431 1
      const GLuint *src = (GLuint *) rb->Data + y[i] * rb->Width + x[i];
d438 1
a438 1
put_row_uint(GLcontext *ctx, struct gl_renderbuffer *rb, GLuint count,
d442 1
a442 1
   GLuint *dst = (GLuint *) rb->Data + y * rb->Width + x;
d460 1
a460 1
put_mono_row_uint(GLcontext *ctx, struct gl_renderbuffer *rb, GLuint count,
d464 1
a464 1
   GLuint *dst = (GLuint *) rb->Data + y * rb->Width + x;
d485 1
a485 1
put_values_uint(GLcontext *ctx, struct gl_renderbuffer *rb, GLuint count,
d495 1
a495 1
         GLuint *dst = (GLuint *) rb->Data + y[i] * rb->Width + x[i];
d503 1
a503 1
put_mono_values_uint(GLcontext *ctx, struct gl_renderbuffer *rb, GLuint count,
d513 1
a513 1
         GLuint *dst = (GLuint *) rb->Data + y[i] * rb->Width + x[i];
d528 1
a528 1
get_pointer_ubyte3(GLcontext *ctx, struct gl_renderbuffer *rb,
d540 1
a540 1
get_row_ubyte3(GLcontext *ctx, struct gl_renderbuffer *rb, GLuint count,
d543 2
a544 1
   const GLubyte *src = (const GLubyte *) rb->Data + 3 * (y * rb->Width + x);
d559 1
a559 1
get_values_ubyte3(GLcontext *ctx, struct gl_renderbuffer *rb, GLuint count,
d568 1
a568 1
         = (GLubyte *) rb->Data + 3 * (y[i] * rb->Width + x[i]);
d578 1
a578 1
put_row_ubyte3(GLcontext *ctx, struct gl_renderbuffer *rb, GLuint count,
d583 1
a583 1
   GLubyte *dst = (GLubyte *) rb->Data + 3 * (y * rb->Width + x);
d598 1
a598 1
put_row_rgb_ubyte3(GLcontext *ctx, struct gl_renderbuffer *rb, GLuint count,
d603 1
a603 1
   GLubyte *dst = (GLubyte *) rb->Data + 3 * (y * rb->Width + x);
d618 1
a618 1
put_mono_row_ubyte3(GLcontext *ctx, struct gl_renderbuffer *rb, GLuint count,
d625 1
a625 1
   GLubyte *dst = (GLubyte *) rb->Data + 3 * (y * rb->Width + x);
d646 1
a646 1
put_values_ubyte3(GLcontext *ctx, struct gl_renderbuffer *rb, GLuint count,
d657 1
a657 1
         GLubyte *dst = (GLubyte *) rb->Data + 3 * (y[i] * rb->Width + x[i]);
d667 1
a667 1
put_mono_values_ubyte3(GLcontext *ctx, struct gl_renderbuffer *rb,
d680 2
a681 1
         GLubyte *dst = (GLubyte *) rb->Data + 3 * (y[i] * rb->Width + x[i]);
a694 23
static void *
get_pointer_ubyte4(GLcontext *ctx, struct gl_renderbuffer *rb,
                   GLint x, GLint y)
{
   if (!rb->Data)
      return NULL;
   ASSERT(rb->DataType == GL_UNSIGNED_BYTE);
   ASSERT(rb->Format == MESA_FORMAT_RGBA8888);
   return (GLubyte *) rb->Data + 4 * (y * rb->Width + x);
}


static void
get_row_ubyte4(GLcontext *ctx, struct gl_renderbuffer *rb, GLuint count,
               GLint x, GLint y, void *values)
{
   const GLubyte *src = (const GLubyte *) rb->Data + 4 * (y * rb->Width + x);
   ASSERT(rb->DataType == GL_UNSIGNED_BYTE);
   ASSERT(rb->Format == MESA_FORMAT_RGBA8888);
   memcpy(values, src, 4 * count * sizeof(GLubyte));
}


d696 1
a696 1
get_values_ubyte4(GLcontext *ctx, struct gl_renderbuffer *rb, GLuint count,
d705 1
a705 1
      const GLuint *src = (GLuint *) rb->Data + (y[i] * rb->Width + x[i]);
d712 1
a712 1
put_row_ubyte4(GLcontext *ctx, struct gl_renderbuffer *rb, GLuint count,
d717 1
a717 1
   GLuint *dst = (GLuint *) rb->Data + (y * rb->Width + x);
d735 1
a735 1
put_row_rgb_ubyte4(GLcontext *ctx, struct gl_renderbuffer *rb, GLuint count,
d740 1
a740 1
   GLubyte *dst = (GLubyte *) rb->Data + 4 * (y * rb->Width + x);
d756 1
a756 1
put_mono_row_ubyte4(GLcontext *ctx, struct gl_renderbuffer *rb, GLuint count,
d761 1
a761 1
   GLuint *dst = (GLuint *) rb->Data + (y * rb->Width + x);
d789 1
a789 1
put_values_ubyte4(GLcontext *ctx, struct gl_renderbuffer *rb, GLuint count,
d800 1
a800 1
         GLuint *dst = (GLuint *) rb->Data + (y[i] * rb->Width + x[i]);
d808 1
a808 1
put_mono_values_ubyte4(GLcontext *ctx, struct gl_renderbuffer *rb,
d819 1
a819 1
         GLuint *dst = (GLuint *) rb->Data + (y[i] * rb->Width + x[i]);
a830 21
static void *
get_pointer_ushort4(GLcontext *ctx, struct gl_renderbuffer *rb,
                    GLint x, GLint y)
{
   if (!rb->Data)
      return NULL;
   ASSERT(rb->DataType == GL_UNSIGNED_SHORT || rb->DataType == GL_SHORT);
   return (GLushort *) rb->Data + 4 * (y * rb->Width + x);
}


static void
get_row_ushort4(GLcontext *ctx, struct gl_renderbuffer *rb, GLuint count,
                GLint x, GLint y, void *values)
{
   const GLshort *src = (const GLshort *) rb->Data + 4 * (y * rb->Width + x);
   ASSERT(rb->DataType == GL_UNSIGNED_SHORT || rb->DataType == GL_SHORT);
   memcpy(values, src, 4 * count * sizeof(GLshort));
}


d832 1
a832 1
get_values_ushort4(GLcontext *ctx, struct gl_renderbuffer *rb, GLuint count,
d840 1
a840 1
         = (GLushort *) rb->Data + 4 * (y[i] * rb->Width + x[i]);
d847 1
a847 1
put_row_ushort4(GLcontext *ctx, struct gl_renderbuffer *rb, GLuint count,
d851 1
a851 1
   GLushort *dst = (GLushort *) rb->Data + 4 * (y * rb->Width + x);
d871 1
a871 1
put_row_rgb_ushort4(GLcontext *ctx, struct gl_renderbuffer *rb, GLuint count,
d876 1
a876 1
   GLushort *dst = (GLushort *) rb->Data + 4 * (y * rb->Width + x);
d896 1
a896 1
put_mono_row_ushort4(GLcontext *ctx, struct gl_renderbuffer *rb, GLuint count,
d903 1
a903 1
   GLushort *dst = (GLushort *) rb->Data + 4 * (y * rb->Width + x);
d924 1
a924 1
put_values_ushort4(GLcontext *ctx, struct gl_renderbuffer *rb, GLuint count,
d933 2
a934 1
         GLushort *dst = (GLushort *) rb->Data + 4 * (y[i] * rb->Width + x[i]);
d945 1
a945 1
put_mono_values_ushort4(GLcontext *ctx, struct gl_renderbuffer *rb,
d957 2
a958 1
         GLushort *dst = (GLushort *) rb->Data + 4 * (y[i] * rb->Width + x[i]);
d967 118
d1086 8
d1096 2
a1097 6
 * This is a software fallback for the gl_renderbuffer->AllocStorage
 * function.
 * Device drivers will typically override this function for the buffers
 * which it manages (typically color buffers, Z and stencil).
 * Other buffers (like software accumulation and aux buffers) which the driver
 * doesn't manage can be handled with this function.
d1099 3
a1101 5
 * This one multi-purpose function can allocate stencil, depth, accum, color
 * or color-index buffers!
 *
 * This function also plugs in the appropriate GetPointer, Get/PutRow and
 * Get/PutValues functions.
d1103 2
a1104 4
GLboolean
_mesa_soft_renderbuffer_storage(GLcontext *ctx, struct gl_renderbuffer *rb,
                                GLenum internalFormat,
                                GLuint width, GLuint height)
d1106 2
a1107 1
   GLuint pixelSize;
d1109 2
a1110 10
   switch (internalFormat) {
   case GL_RGB:
   case GL_R3_G3_B2:
   case GL_RGB4:
   case GL_RGB5:
   case GL_RGB8:
   case GL_RGB10:
   case GL_RGB12:
   case GL_RGB16:
      rb->Format = MESA_FORMAT_RGB888;
a1119 1
      pixelSize = 3 * sizeof(GLubyte);
d1121 2
a1122 10
   case GL_RGBA:
   case GL_RGBA2:
   case GL_RGBA4:
   case GL_RGB5_A1:
   case GL_RGBA8:
#if 1
   case GL_RGB10_A2:
   case GL_RGBA12:
#endif
      rb->Format = MESA_FORMAT_RGBA8888;
a1123 2
      rb->GetPointer = get_pointer_ubyte4;
      rb->GetRow = get_row_ubyte4;
a1129 1
      pixelSize = 4 * sizeof(GLubyte);
d1131 46
a1176 3
   case GL_RGBA16:
      /* for accum buffer */
      rb->Format = MESA_FORMAT_SIGNED_RGBA_16;
a1177 2
      rb->GetPointer = get_pointer_ushort4;
      rb->GetRow = get_row_ushort4;
a1183 1
      pixelSize = 4 * sizeof(GLushort);
d1185 1
d1187 1
a1187 2
   case GL_ALPHA8:
      rb->Format = MESA_FORMAT_A8;
a1188 2
      rb->GetPointer = get_pointer_alpha8;
      rb->GetRow = get_row_alpha8;
a1194 1
      pixelSize = sizeof(GLubyte);
d1197 2
a1198 6
   case GL_STENCIL_INDEX:
   case GL_STENCIL_INDEX1_EXT:
   case GL_STENCIL_INDEX4_EXT:
   case GL_STENCIL_INDEX8_EXT:
   case GL_STENCIL_INDEX16_EXT:
      rb->Format = MESA_FORMAT_S8;
a1199 2
      rb->GetPointer = get_pointer_ubyte;
      rb->GetRow = get_row_ubyte;
a1205 1
      pixelSize = sizeof(GLubyte);
d1207 2
a1208 3
   case GL_DEPTH_COMPONENT:
   case GL_DEPTH_COMPONENT16:
      rb->Format = MESA_FORMAT_Z16;
a1209 2
      rb->GetPointer = get_pointer_ushort;
      rb->GetRow = get_row_ushort;
a1215 1
      pixelSize = sizeof(GLushort);
d1217 4
a1220 1
   case GL_DEPTH_COMPONENT24:
a1221 2
      rb->GetPointer = get_pointer_uint;
      rb->GetRow = get_row_uint;
a1227 2
      rb->Format = MESA_FORMAT_X8_Z24;
      pixelSize = sizeof(GLuint);
d1229 4
a1232 4
   case GL_DEPTH_COMPONENT32:
      rb->DataType = GL_UNSIGNED_INT;
      rb->GetPointer = get_pointer_uint;
      rb->GetRow = get_row_uint;
d1239 73
a1312 1
      pixelSize = sizeof(GLuint);
a1316 25
      rb->DataType = GL_UNSIGNED_INT_24_8_EXT;
      rb->GetPointer = get_pointer_uint;
      rb->GetRow = get_row_uint;
      rb->GetValues = get_values_uint;
      rb->PutRow = put_row_uint;
      rb->PutRowRGB = NULL;
      rb->PutMonoRow = put_mono_row_uint;
      rb->PutValues = put_values_uint;
      rb->PutMonoValues = put_mono_values_uint;
      pixelSize = sizeof(GLuint);
      break;
   case GL_COLOR_INDEX8_EXT:
   case GL_COLOR_INDEX16_EXT:
   case COLOR_INDEX32:
      rb->Format = MESA_FORMAT_CI8;
      rb->DataType = GL_UNSIGNED_BYTE;
      rb->GetPointer = get_pointer_ubyte;
      rb->GetRow = get_row_ubyte;
      rb->GetValues = get_values_ubyte;
      rb->PutRow = put_row_ubyte;
      rb->PutRowRGB = NULL;
      rb->PutMonoRow = put_mono_row_ubyte;
      rb->PutValues = put_values_ubyte;
      rb->PutMonoValues = put_mono_values_ubyte;
      pixelSize = sizeof(GLubyte);
d1323 2
d1340 2
d1344 1
a1344 1
      rb->Data = malloc(width * height * pixelSize);
d1349 1
d1352 1
a1352 1
                     width, height, pixelSize);
d1383 1
a1383 1
alloc_storage_alpha8(GLcontext *ctx, struct gl_renderbuffer *arb,
d1410 1
d1434 1
a1434 1
get_pointer_alpha8(GLcontext *ctx, struct gl_renderbuffer *arb,
d1442 1
a1442 1
get_row_alpha8(GLcontext *ctx, struct gl_renderbuffer *arb, GLuint count,
d1446 1
a1446 1
   const GLubyte *src = (const GLubyte *) arb->Data + y * arb->Width + x;
d1461 1
a1461 1
get_values_alpha8(GLcontext *ctx, struct gl_renderbuffer *arb, GLuint count,
d1472 1
a1472 1
      const GLubyte *src = (GLubyte *) arb->Data + y[i] * arb->Width + x[i];
d1479 1
a1479 1
put_row_alpha8(GLcontext *ctx, struct gl_renderbuffer *arb, GLuint count,
d1483 1
a1483 1
   GLubyte *dst = (GLubyte *) arb->Data + y * arb->Width + x;
d1499 1
a1499 1
put_row_rgb_alpha8(GLcontext *ctx, struct gl_renderbuffer *arb, GLuint count,
d1503 1
a1503 1
   GLubyte *dst = (GLubyte *) arb->Data + y * arb->Width + x;
d1519 1
a1519 1
put_mono_row_alpha8(GLcontext *ctx, struct gl_renderbuffer *arb, GLuint count,
d1523 1
a1523 1
   GLubyte *dst = (GLubyte *) arb->Data + y * arb->Width + x;
d1544 1
a1544 1
put_values_alpha8(GLcontext *ctx, struct gl_renderbuffer *arb, GLuint count,
d1557 1
a1557 1
         GLubyte *dst = (GLubyte *) arb->Data + y[i] * arb->Width + x[i];
d1565 1
a1565 1
put_mono_values_alpha8(GLcontext *ctx, struct gl_renderbuffer *arb,
d1578 1
a1578 1
         GLubyte *dst = (GLubyte *) arb->Data + y[i] * arb->Width + x[i];
d1592 1
d1594 1
a1594 1
   memcpy(dst->Data, src->Data, dst->Width * dst->Height * sizeof(GLubyte));
d1608 1
a1608 1
nop_get_pointer(GLcontext *ctx, struct gl_renderbuffer *rb, GLint x, GLint y)
d1662 1
a1662 1
_mesa_new_renderbuffer(GLcontext *ctx, GLuint name)
d1693 1
a1693 1
_mesa_new_soft_renderbuffer(GLcontext *ctx, GLuint name)
d1716 1
a1716 1
_mesa_add_color_renderbuffers(GLcontext *ctx, struct gl_framebuffer *fb,
d1780 1
a1780 1
_mesa_add_alpha_renderbuffers(GLcontext *ctx, struct gl_framebuffer *fb,
d1864 1
a1864 1
_mesa_copy_soft_alpha_renderbuffers(GLcontext *ctx, struct gl_framebuffer *fb)
d1888 1
a1888 1
_mesa_add_depth_renderbuffer(GLcontext *ctx, struct gl_framebuffer *fb,
d1936 1
a1936 1
_mesa_add_stencil_renderbuffer(GLcontext *ctx, struct gl_framebuffer *fb,
d1975 1
a1975 1
_mesa_add_accum_renderbuffer(GLcontext *ctx, struct gl_framebuffer *fb,
d1996 1
a1996 1
   rb->InternalFormat = GL_RGBA16;
d2006 1
a2006 1
 * Add a software-based accumulation renderbuffer to the given framebuffer.
d2016 1
a2016 1
_mesa_add_aux_renderbuffers(GLcontext *ctx, struct gl_framebuffer *fb,
d2035 1
a2035 1
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "Allocating accum buffer");
a2127 2
   GLenum baseFormat;

a2147 20
   /* If Mesa's compiled with deep color channels (16 or 32 bits / channel)
    * and the device driver is expecting 8-bit values (GLubyte), we can
    * use a "renderbuffer adaptor/wrapper" to do the necessary conversions.
    */
   baseFormat = _mesa_get_format_base_format(rb->Format);
   if (baseFormat == GL_RGBA) {
      if (CHAN_BITS == 16 && rb->DataType == GL_UNSIGNED_BYTE) {
         GET_CURRENT_CONTEXT(ctx);
         rb = _mesa_new_renderbuffer_16wrap8(ctx, rb);
      }
      else if (CHAN_BITS == 32 && rb->DataType == GL_UNSIGNED_BYTE) {
         GET_CURRENT_CONTEXT(ctx);
         rb = _mesa_new_renderbuffer_32wrap8(ctx, rb);
      }
      else if (CHAN_BITS == 32 && rb->DataType == GL_UNSIGNED_SHORT) {
         GET_CURRENT_CONTEXT(ctx);
         rb = _mesa_new_renderbuffer_32wrap16(ctx, rb);
      }
   }

d2230 1
a2230 1
_mesa_new_depthstencil_renderbuffer(GLcontext *ctx, GLuint name)
@


1.3
log
@merge Mesa 7.0.1
@
text
@d46 2
d77 1
a77 1
   /* Can't assert _ActualFormat since these funcs may be used for serveral
d90 1
a90 1
   _mesa_memcpy(values, src, count * sizeof(GLubyte));
d124 1
a124 1
      _mesa_memcpy(dst, values, count * sizeof(GLubyte));
d210 1
a210 1
   _mesa_memcpy(values, src, count * sizeof(GLushort));
d244 1
a244 1
      _mesa_memcpy(dst, src, count * sizeof(GLushort));
d340 1
a340 1
   _mesa_memcpy(values, src, count * sizeof(GLuint));
d376 1
a376 1
      _mesa_memcpy(dst, src, count * sizeof(GLuint));
d453 1
a453 1
   ASSERT(rb->_ActualFormat == GL_RGB8);
d468 1
a468 1
   ASSERT(rb->_ActualFormat == GL_RGB8);
d485 1
a485 1
   ASSERT(rb->_ActualFormat == GL_RGB8);
d506 1
a506 1
   ASSERT(rb->_ActualFormat == GL_RGB8);
d526 1
a526 1
   ASSERT(rb->_ActualFormat == GL_RGB8);
d547 1
a547 1
   ASSERT(rb->_ActualFormat == GL_RGB8);
d551 1
a551 1
      _mesa_memset(dst, val0, 3 * count);
d574 1
a574 1
   ASSERT(rb->_ActualFormat == GL_RGB8);
d597 1
a597 1
   ASSERT(rb->_ActualFormat == GL_RGB8);
d622 1
a622 1
   ASSERT(rb->_ActualFormat == GL_RGBA8);
d633 2
a634 2
   ASSERT(rb->_ActualFormat == GL_RGBA8);
   _mesa_memcpy(values, src, 4 * count * sizeof(GLubyte));
d646 1
a646 1
   ASSERT(rb->_ActualFormat == GL_RGBA8);
d662 1
a662 1
   ASSERT(rb->_ActualFormat == GL_RGBA8);
d672 1
a672 1
      _mesa_memcpy(dst, src, 4 * count * sizeof(GLubyte));
d686 1
a686 1
   ASSERT(rb->_ActualFormat == GL_RGBA8);
d706 1
a706 1
   ASSERT(rb->_ActualFormat == GL_RGBA8);
d709 1
a709 1
      _mesa_bzero(dst, count * 4 * sizeof(GLubyte));
d740 1
a740 1
   ASSERT(rb->_ActualFormat == GL_RGBA8);
d759 1
a759 1
   ASSERT(rb->_ActualFormat == GL_RGBA8);
d791 1
a791 1
   _mesa_memcpy(values, src, 4 * count * sizeof(GLshort));
d829 1
a829 1
      _mesa_memcpy(dst, src, 4 * count * sizeof(GLushort));
d854 1
a854 1
      _mesa_memcpy(dst, src, 4 * count * sizeof(GLushort));
d871 1
a871 1
      _mesa_bzero(dst, count * 4 * sizeof(GLushort));
a951 9
   /* first clear these fields */
   rb->RedBits =
   rb->GreenBits =
   rb->BlueBits =
   rb->AlphaBits =
   rb->IndexBits =
   rb->DepthBits =
   rb->StencilBits = 0;

d961 1
a961 2
      rb->_ActualFormat = GL_RGB8;
      rb->_BaseFormat = GL_RGB;
a970 4
      rb->RedBits   = 8 * sizeof(GLubyte);
      rb->GreenBits = 8 * sizeof(GLubyte);
      rb->BlueBits  = 8 * sizeof(GLubyte);
      rb->AlphaBits = 0;
d978 5
a982 2
      rb->_ActualFormat = GL_RGBA8;
      rb->_BaseFormat = GL_RGBA;
a991 4
      rb->RedBits   = 8 * sizeof(GLubyte);
      rb->GreenBits = 8 * sizeof(GLubyte);
      rb->BlueBits  = 8 * sizeof(GLubyte);
      rb->AlphaBits = 8 * sizeof(GLubyte);
a993 2
   case GL_RGB10_A2:
   case GL_RGBA12:
d995 3
a997 3
      rb->_ActualFormat = GL_RGBA16;
      rb->_BaseFormat = GL_RGBA;
      rb->DataType = GL_UNSIGNED_SHORT;
a1005 4
      rb->RedBits   = 8 * sizeof(GLushort);
      rb->GreenBits = 8 * sizeof(GLushort);
      rb->BlueBits  = 8 * sizeof(GLushort);
      rb->AlphaBits = 8 * sizeof(GLushort);
d1008 1
a1008 1
#if 00
d1010 1
a1010 2
      rb->_ActualFormat = GL_ALPHA8;
      rb->_BaseFormat = GL_RGBA; /* Yes, not GL_ALPHA! */
a1019 4
      rb->RedBits   = 0; /*red*/
      rb->GreenBits = 0; /*green*/
      rb->BlueBits  = 0; /*blue*/
      rb->AlphaBits = 8 * sizeof(GLubyte);
d1027 2
a1028 2
      rb->_ActualFormat = GL_STENCIL_INDEX8_EXT;
      rb->_BaseFormat = GL_STENCIL_INDEX;
a1037 1
      rb->StencilBits = 8 * sizeof(GLubyte);
a1039 15
   case GL_STENCIL_INDEX16_EXT:
      rb->_ActualFormat = GL_STENCIL_INDEX16_EXT;
      rb->_BaseFormat = GL_STENCIL_INDEX;
      rb->DataType = GL_UNSIGNED_SHORT;
      rb->GetPointer = get_pointer_ushort;
      rb->GetRow = get_row_ushort;
      rb->GetValues = get_values_ushort;
      rb->PutRow = put_row_ushort;
      rb->PutRowRGB = NULL;
      rb->PutMonoRow = put_mono_row_ushort;
      rb->PutValues = put_values_ushort;
      rb->PutMonoValues = put_mono_values_ushort;
      rb->StencilBits = 8 * sizeof(GLushort);
      pixelSize = sizeof(GLushort);
      break;
d1042 1
a1042 2
      rb->_ActualFormat = GL_DEPTH_COMPONENT16;
      rb->_BaseFormat = GL_DEPTH_COMPONENT;
a1051 1
      rb->DepthBits = 8 * sizeof(GLushort);
d1055 12
a1067 1
      rb->_BaseFormat = GL_DEPTH_COMPONENT;
d1077 1
a1077 8
      if (internalFormat == GL_DEPTH_COMPONENT24) {
         rb->_ActualFormat = GL_DEPTH_COMPONENT24;
         rb->DepthBits = 24;
      }
      else {
         rb->_ActualFormat = GL_DEPTH_COMPONENT32;
         rb->DepthBits = 32;
      }
d1082 1
a1082 2
      rb->_ActualFormat = GL_DEPTH24_STENCIL8_EXT;
      rb->_BaseFormat = GL_DEPTH_STENCIL_EXT;
a1091 2
      rb->DepthBits = 24;
      rb->StencilBits = 8;
d1095 3
a1097 2
      rb->_ActualFormat = GL_COLOR_INDEX8_EXT;
      rb->_BaseFormat = GL_COLOR_INDEX;
a1106 1
      rb->IndexBits = 8 * sizeof(GLubyte);
a1108 30
   case GL_COLOR_INDEX16_EXT:
      rb->_ActualFormat = GL_COLOR_INDEX16_EXT;
      rb->_BaseFormat = GL_COLOR_INDEX;
      rb->DataType = GL_UNSIGNED_SHORT;
      rb->GetPointer = get_pointer_ushort;
      rb->GetRow = get_row_ushort;
      rb->GetValues = get_values_ushort;
      rb->PutRow = put_row_ushort;
      rb->PutRowRGB = NULL;
      rb->PutMonoRow = put_mono_row_ushort;
      rb->PutValues = put_values_ushort;
      rb->PutMonoValues = put_mono_values_ushort;
      rb->IndexBits = 8 * sizeof(GLushort);
      pixelSize = sizeof(GLushort);
      break;
   case COLOR_INDEX32:
      rb->_ActualFormat = COLOR_INDEX32;
      rb->_BaseFormat = GL_COLOR_INDEX;
      rb->DataType = GL_UNSIGNED_INT;
      rb->GetPointer = get_pointer_uint;
      rb->GetRow = get_row_uint;
      rb->GetValues = get_values_uint;
      rb->PutRow = put_row_uint;
      rb->PutRowRGB = NULL;
      rb->PutMonoRow = put_mono_row_uint;
      rb->PutValues = put_values_uint;
      rb->PutMonoValues = put_mono_values_uint;
      rb->IndexBits = 8 * sizeof(GLuint);
      pixelSize = sizeof(GLuint);
      break;
d1125 1
a1125 1
      _mesa_free(rb->Data);
d1131 2
a1132 1
      rb->Data = _mesa_malloc(width * height * pixelSize);
d1145 2
d1173 1
a1173 1
   ASSERT(arb->_ActualFormat == GL_ALPHA8);
d1183 1
a1183 1
      _mesa_free(arb->Data);
d1186 1
a1186 1
   arb->Data = _mesa_malloc(width * height * sizeof(GLubyte));
d1208 1
a1208 1
      _mesa_free(arb->Data);
d1214 1
a1214 1
   _mesa_free(arb);
d1323 1
a1323 1
      _mesa_memset(dst, val, count);
d1373 2
a1374 2
   ASSERT(dst->_ActualFormat == GL_ALPHA8);
   ASSERT(src->_ActualFormat == GL_ALPHA8);
d1378 1
a1378 1
   _mesa_memcpy(dst->Data, src->Data, dst->Width * dst->Height * sizeof(GLubyte));
d1420 2
a1421 2
   rb->_ActualFormat = GL_NONE;
   rb->_BaseFormat = GL_NONE;
a1422 4
   rb->RedBits = rb->GreenBits = rb->BlueBits = rb->AlphaBits = 0;
   rb->IndexBits = 0;
   rb->DepthBits = 0;
   rb->StencilBits = 0;
d1464 1
a1464 1
      _mesa_free(rb->Data);
d1466 1
a1466 1
   _mesa_free(rb);
d1537 1
a1537 1
            rb->_ActualFormat = GL_RGBA8;
d1539 1
a1539 1
            rb->_ActualFormat = GL_RGB8;
d1543 1
a1543 66
         if (alphaBits)
            rb->_ActualFormat = GL_RGBA16;
         else
            rb->_ActualFormat = GL_RGBA16; /* don't really have RGB16 yet */
      }
      rb->InternalFormat = rb->_ActualFormat;

      rb->AllocStorage = _mesa_soft_renderbuffer_storage;
      _mesa_add_renderbuffer(fb, b, rb);
   }

   return GL_TRUE;
}


/**
 * Add software-based color index renderbuffers to the given framebuffer.
 * This is a helper routine for device drivers when creating a
 * window system framebuffer (not a user-created render/framebuffer).
 * Once this function is called, you can basically forget about this
 * renderbuffer; core Mesa will handle all the buffer management and
 * rendering!
 */
GLboolean
_mesa_add_color_index_renderbuffers(GLcontext *ctx, struct gl_framebuffer *fb,
                                    GLuint indexBits,
                                    GLboolean frontLeft, GLboolean backLeft,
                                    GLboolean frontRight, GLboolean backRight)
{
   GLuint b;

   if (indexBits > 8) {
      _mesa_problem(ctx,
                "Unsupported bit depth in _mesa_add_color_index_renderbuffers");
      return GL_FALSE;
   }

   assert(MAX_COLOR_ATTACHMENTS >= 4);

   for (b = BUFFER_FRONT_LEFT; b <= BUFFER_BACK_RIGHT; b++) {
      struct gl_renderbuffer *rb;

      if (b == BUFFER_FRONT_LEFT && !frontLeft)
         continue;
      else if (b == BUFFER_BACK_LEFT && !backLeft)
         continue;
      else if (b == BUFFER_FRONT_RIGHT && !frontRight)
         continue;
      else if (b == BUFFER_BACK_RIGHT && !backRight)
         continue;

      assert(fb->Attachment[b].Renderbuffer == NULL);

      rb = _mesa_new_renderbuffer(ctx, 0);
      if (!rb) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "Allocating color buffer");
         return GL_FALSE;
      }

      if (indexBits <= 8) {
         /* only support GLuint for now */
         /*rb->InternalFormat = GL_COLOR_INDEX8_EXT;*/
         rb->_ActualFormat = COLOR_INDEX32;
      }
      else {
         rb->_ActualFormat = COLOR_INDEX32;
d1545 1
a1545 1
      rb->InternalFormat = rb->_ActualFormat;
d1618 1
a1618 2
      arb->_ActualFormat  = GL_ALPHA8;
      arb->_BaseFormat    = arb->Wrapped->_BaseFormat;
d1692 2
a1693 1
      rb->_ActualFormat = GL_DEPTH_COMPONENT16;
d1696 2
a1697 1
      rb->_ActualFormat = GL_DEPTH_COMPONENT24;
d1700 2
a1701 1
      rb->_ActualFormat = GL_DEPTH_COMPONENT32;
a1702 1
   rb->InternalFormat = rb->_ActualFormat;
d1739 3
a1741 8
   if (stencilBits <= 8) {
      rb->_ActualFormat = GL_STENCIL_INDEX8_EXT;
   }
   else {
      /* not really supported (see s_stencil.c code) */
      rb->_ActualFormat = GL_STENCIL_INDEX16_EXT;
   }
   rb->InternalFormat = rb->_ActualFormat;
d1779 1
a1779 1
   rb->_ActualFormat = GL_RGBA16;
d1811 1
a1811 1
   assert(numBuffers < MAX_AUX_BUFFERS);
d1823 3
a1825 7
      if (colorBits <= 8) {
         rb->_ActualFormat = GL_RGBA8;
      }
      else {
         rb->_ActualFormat = GL_RGBA16;
      }
      rb->InternalFormat = rb->_ActualFormat;
d1854 7
a1860 15
      if (fb->Visual.rgbMode) {
         assert(fb->Visual.redBits == fb->Visual.greenBits);
         assert(fb->Visual.redBits == fb->Visual.blueBits);
         _mesa_add_color_renderbuffers(NULL, fb,
                                       fb->Visual.redBits,
                                       fb->Visual.alphaBits,
                                       frontLeft, backLeft,
                                       frontRight, backRight);
      }
      else {
         _mesa_add_color_index_renderbuffers(NULL, fb,
                                             fb->Visual.indexBits,
                                             frontLeft, backLeft,
                                             frontRight, backRight);
      }
a1873 1
      assert(fb->Visual.rgbMode);
a1884 1
      assert(fb->Visual.rgbMode);
a1890 1
      assert(fb->Visual.rgbMode);
d1912 2
d1938 2
a1939 1
   if (rb->_BaseFormat == GL_RGBA) {
d2046 1
a2046 1
   dsrb->_ActualFormat = GL_DEPTH24_STENCIL8_EXT;
@


1.2
log
@assorted fixes for dealing with zero-size frame/renderbuffers.

from freedesktop (mesa-commits) with help from games/bzflag;
ok matthieu@@
@
text
@d1438 11
d1474 1
d1477 1
a1477 1
   rb->RefCount = 1;
d1781 21
d2109 1
a2109 3
   fb->Attachment[bufferName].Renderbuffer = rb;

   rb->RefCount++;
d2127 1
a2127 1
   _mesa_dereference_renderbuffer(&rb);
d2134 3
a2136 3
 * Decrement the reference count on a renderbuffer and delete it when
 * the refcount hits zero.
 * Note: we pass the address of a pointer and set it to NULL if we delete it.
d2139 2
a2140 1
_mesa_dereference_renderbuffer(struct gl_renderbuffer **rb)
d2142 5
a2146 1
   GLboolean deleteFlag = GL_FALSE;
d2148 20
a2167 5
   _glthread_LOCK_MUTEX((*rb)->Mutex);
   {
      ASSERT((*rb)->RefCount > 0);
      (*rb)->RefCount--;
      deleteFlag = ((*rb)->RefCount == 0);
d2169 1
a2169 1
   _glthread_UNLOCK_MUTEX((*rb)->Mutex);
d2171 8
a2178 3
   if (deleteFlag) {
      (*rb)->Delete(*rb);
      *rb = NULL;
a2182 2


a2203 1

@


1.1
log
@Initial revision
@
text
@d1195 1
a1195 1
   if (rb->Data)
d1197 2
d1200 11
a1210 9
   /* allocate new buffer storage */
   rb->Data = _mesa_malloc(width * height * pixelSize);
   if (rb->Data == NULL) {
      rb->Width = 0;
      rb->Height = 0;
      _mesa_error(ctx, GL_OUT_OF_MEMORY,
                  "software renderbuffer allocation (%d x %d x %d)",
                  width, height, pixelSize);
      return GL_FALSE;
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@Mesa 7.0.1
@
text
@d1195 1
a1195 1
   if (rb->Data) {
a1196 2
      rb->Data = NULL;
   }
d1198 9
a1206 11
   if (width > 0 && height > 0) {
      /* allocate new buffer storage */
      rb->Data = _mesa_malloc(width * height * pixelSize);
      if (rb->Data == NULL) {
         rb->Width = 0;
         rb->Height = 0;
         _mesa_error(ctx, GL_OUT_OF_MEMORY,
                     "software renderbuffer allocation (%d x %d x %d)",
                     width, height, pixelSize);
         return GL_FALSE;
      }
a1433 11
static void
copy_buffer_alpha8(struct gl_renderbuffer* dst, struct gl_renderbuffer* src)
{
   ASSERT(dst->_ActualFormat == GL_ALPHA8);
   ASSERT(src->_ActualFormat == GL_ALPHA8);
   ASSERT(dst->Width == src->Width);
   ASSERT(dst->Height == src->Height);

   _mesa_memcpy(dst->Data, src->Data, dst->Width * dst->Height * sizeof(GLubyte));
}

a1458 1
   rb->Magic = RB_MAGIC;
d1461 1
a1461 1
   rb->RefCount = 0;
a1764 21
 * For framebuffers that use a software alpha channel wrapper
 * created by _mesa_add_alpha_renderbuffer or _mesa_add_soft_renderbuffers,
 * copy the back buffer alpha channel into the front buffer alpha channel.
 */
void
_mesa_copy_soft_alpha_renderbuffers(GLcontext *ctx, struct gl_framebuffer *fb)
{
   if (fb->Attachment[BUFFER_FRONT_LEFT].Renderbuffer &&
       fb->Attachment[BUFFER_BACK_LEFT].Renderbuffer)
      copy_buffer_alpha8(fb->Attachment[BUFFER_FRONT_LEFT].Renderbuffer,
                         fb->Attachment[BUFFER_BACK_LEFT].Renderbuffer);


   if (fb->Attachment[BUFFER_FRONT_RIGHT].Renderbuffer &&
       fb->Attachment[BUFFER_BACK_RIGHT].Renderbuffer)
      copy_buffer_alpha8(fb->Attachment[BUFFER_FRONT_RIGHT].Renderbuffer,
                         fb->Attachment[BUFFER_BACK_RIGHT].Renderbuffer);
}


/**
d2072 3
a2074 1
   _mesa_reference_renderbuffer(&fb->Attachment[bufferName].Renderbuffer, rb);
d2092 1
a2092 1
   _mesa_reference_renderbuffer(&rb, NULL);
d2099 3
a2101 3
 * Set *ptr to point to rb.  If *ptr points to another renderbuffer,
 * dereference that buffer first.  The new renderbuffer's refcount will
 * be incremented.  The old renderbuffer's refcount will be decremented.
d2104 1
a2104 2
_mesa_reference_renderbuffer(struct gl_renderbuffer **ptr,
                             struct gl_renderbuffer *rb)
d2106 1
a2106 24
   assert(ptr);
   if (*ptr == rb) {
      /* no change */
      return;
   }

   if (*ptr) {
      /* Unreference the old renderbuffer */
      GLboolean deleteFlag = GL_FALSE;
      struct gl_renderbuffer *oldRb = *ptr;

      assert(oldRb->Magic == RB_MAGIC);
      _glthread_LOCK_MUTEX(oldRb->Mutex);
      assert(oldRb->Magic == RB_MAGIC);
      ASSERT(oldRb->RefCount > 0);
      oldRb->RefCount--;
      /*printf("RB DECR %p (%d) to %d\n", (void*) oldRb, oldRb->Name, oldRb->RefCount);*/
      deleteFlag = (oldRb->RefCount == 0);
      _glthread_UNLOCK_MUTEX(oldRb->Mutex);

      if (deleteFlag) {
         oldRb->Magic = 0; /* now invalid memory! */
         oldRb->Delete(oldRb);
      }
d2108 5
a2112 1
      *ptr = NULL;
d2114 1
a2114 1
   assert(!*ptr);
d2116 3
a2118 8
   if (rb) {
      assert(rb->Magic == RB_MAGIC);
      /* reference new renderbuffer */
      _glthread_LOCK_MUTEX(rb->Mutex);
      rb->RefCount++;
      /*printf("RB INCR %p (%d) to %d\n", (void*) rb, rb->Name, rb->RefCount);*/
      _glthread_UNLOCK_MUTEX(rb->Mutex);
      *ptr = rb;
d2123 2
d2146 1
@


1.1.1.3
log
@Import Mesa 7.10.3
@
text
@d46 1
a47 2
#include "formats.h"
#include "mtypes.h"
d50 6
d59 2
d63 3
a65 6
/* Returns a bytes per pixel of the DataType in the get/put span
 * functions for at least a subset of the available combinations a
 * renderbuffer can have.
 *
 * It would be nice to see gl_renderbuffer start talking about a
 * gl_format instead of a GLenum DataType.
a66 30
static int
get_datatype_bytes(struct gl_renderbuffer *rb)
{
   int component_size;

   switch (rb->DataType) {
   case GL_FLOAT:
   case GL_UNSIGNED_INT:
   case GL_UNSIGNED_INT_24_8_EXT:
      component_size = 4;
      break;
   case GL_UNSIGNED_SHORT:
      component_size = 2;
      break;
   case GL_UNSIGNED_BYTE:
      component_size = 1;
      break;
   default:
      component_size = 1;
      assert(0);
   }

   switch (rb->_BaseFormat) {
   case GL_DEPTH_COMPONENT:
   case GL_DEPTH_STENCIL:
      return component_size;
   default:
      return 4 * component_size;
   }
}
a67 1
/* This is commonly used by most of the accessors. */
d69 2
a70 2
get_pointer_generic(struct gl_context *ctx, struct gl_renderbuffer *rb,
		    GLint x, GLint y)
d74 5
a78 3

   return ((char *) rb->Data +
	   (y * rb->RowStride + x) * _mesa_get_format_bytes(rb->Format));
a80 9
/* GetRow() implementation for formats where DataType matches the rb->Format.
 */
static void
get_row_generic(struct gl_context *ctx, struct gl_renderbuffer *rb,
		GLuint count, GLint x, GLint y, void *values)
{
   void *src = rb->GetPointer(ctx, rb, x, y);
   memcpy(values, src, count * _mesa_get_format_bytes(rb->Format));
}
a81 5
/* For the GL_RED/GL_RG/GL_RGB format/DataType combinations (and
 * GL_LUMINANCE/GL_INTENSITY?), the Put functions are a matter of
 * storing those initial components of the value per pixel into the
 * destination.
 */
d83 2
a84 3
put_row_generic(struct gl_context *ctx, struct gl_renderbuffer *rb,
		GLuint count, GLint x, GLint y,
		const void *values, const GLubyte *mask)
d86 3
a88 22
   void *row = rb->GetPointer(ctx, rb, x, y);
   int format_bytes = _mesa_get_format_bytes(rb->Format) / sizeof(GLfloat);
   int datatype_bytes = get_datatype_bytes(rb);
   unsigned int i;

   if (mask) {
      for (i = 0; i < count; i++) {
	 char *dst = (char *) row + i * format_bytes;
	 const char *src = (const char *) values + i * datatype_bytes;

         if (mask[i]) {
	    memcpy(dst, src, format_bytes);
         }
      }
   }
   else {
      for (i = 0; i < count; i++) {
	 char *dst = (char *) row + i * format_bytes;
	 const char *src = (const char *) values + i * datatype_bytes;
	 memcpy(dst, src, format_bytes);
      }
   }
a90 66
static void
put_mono_row_generic(struct gl_context *ctx, struct gl_renderbuffer *rb,
		     GLuint count, GLint x, GLint y,
		     const void *value, const GLubyte *mask)
{
   void *row = rb->GetPointer(ctx, rb, x, y);
   int format_bytes = _mesa_get_format_bytes(rb->Format) / sizeof(GLfloat);
   unsigned int i;

   if (mask) {
      for (i = 0; i < count; i++) {
	 char *dst = (char *) row + i * format_bytes;
         if (mask[i]) {
	    memcpy(dst, value, format_bytes);
         }
      }
   }
   else {
      for (i = 0; i < count; i++) {
	 char *dst = (char *) row + i * format_bytes;
	 memcpy(dst, value, format_bytes);
      }
   }
}


static void
put_values_generic(struct gl_context *ctx, struct gl_renderbuffer *rb,
		   GLuint count, const GLint x[], const GLint y[],
		   const void *values, const GLubyte *mask)
{
   int format_bytes = _mesa_get_format_bytes(rb->Format) / sizeof(GLfloat);
   int datatype_bytes = get_datatype_bytes(rb);
   unsigned int i;

   for (i = 0; i < count; i++) {
      if (!mask || mask[i]) {
	 void *dst = rb->GetPointer(ctx, rb, x[i], y[i]);
	 const char *src = (const char *) values + i * datatype_bytes;
	 memcpy(dst, src, format_bytes);
      }
   }
}


static void
put_mono_values_generic(struct gl_context *ctx,
			struct gl_renderbuffer *rb,
			GLuint count, const GLint x[], const GLint y[],
			const void *value, const GLubyte *mask)
{
   int format_bytes = _mesa_get_format_bytes(rb->Format) / sizeof(GLfloat);
   unsigned int i;

   for (i = 0; i < count; i++) {
      if (!mask || mask[i]) {
	 void *dst = rb->GetPointer(ctx, rb, x[i], y[i]);
	 memcpy(dst, value, format_bytes);
      }
   }
}

/**********************************************************************
 * Functions for buffers of 1 X GLubyte values.
 * Typically stencil.
 */
d93 1
a93 1
get_values_ubyte(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
d100 1
a100 1
      const GLubyte *src = (GLubyte *) rb->Data + y[i] * rb->RowStride + x[i];
d107 1
a107 1
put_row_ubyte(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
d111 1
a111 1
   GLubyte *dst = (GLubyte *) rb->Data + y * rb->RowStride + x;
d122 1
a122 1
      memcpy(dst, values, count * sizeof(GLubyte));
d128 1
a128 1
put_mono_row_ubyte(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
d132 1
a132 1
   GLubyte *dst = (GLubyte *) rb->Data + y * rb->RowStride + x;
d152 1
a152 1
put_values_ubyte(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
d161 1
a161 1
         GLubyte *dst = (GLubyte *) rb->Data + y[i] * rb->RowStride + x[i];
d169 1
a169 1
put_mono_values_ubyte(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
d178 1
a178 1
         GLubyte *dst = (GLubyte *) rb->Data + y[i] * rb->RowStride + x[i];
d190 22
d213 1
a213 1
get_values_ushort(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
d220 1
a220 1
      const GLushort *src = (GLushort *) rb->Data + y[i] * rb->RowStride + x[i];
d227 1
a227 1
put_row_ushort(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
d231 1
a231 1
   GLushort *dst = (GLushort *) rb->Data + y * rb->RowStride + x;
d242 1
a242 1
      memcpy(dst, src, count * sizeof(GLushort));
d248 1
a248 1
put_mono_row_ushort(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
d252 1
a252 1
   GLushort *dst = (GLushort *) rb->Data + y * rb->RowStride + x;
d272 1
a272 1
put_values_ushort(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
d281 1
a281 1
         GLushort *dst = (GLushort *) rb->Data + y[i] * rb->RowStride + x[i];
d289 1
a289 1
put_mono_values_ushort(struct gl_context *ctx, struct gl_renderbuffer *rb,
d299 1
a299 1
            GLushort *dst = (GLushort *) rb->Data + y[i] * rb->RowStride + x[i];
d307 1
a307 1
         GLushort *dst = (GLushort *) rb->Data + y[i] * rb->RowStride + x[i];
d319 23
d343 1
a343 1
get_values_uint(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
d351 1
a351 1
      const GLuint *src = (GLuint *) rb->Data + y[i] * rb->RowStride + x[i];
d358 1
a358 1
put_row_uint(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
d362 1
a362 1
   GLuint *dst = (GLuint *) rb->Data + y * rb->RowStride + x;
d374 1
a374 1
      memcpy(dst, src, count * sizeof(GLuint));
d380 1
a380 1
put_mono_row_uint(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
d384 1
a384 1
   GLuint *dst = (GLuint *) rb->Data + y * rb->RowStride + x;
d405 1
a405 1
put_values_uint(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
d415 1
a415 1
         GLuint *dst = (GLuint *) rb->Data + y[i] * rb->RowStride + x[i];
d423 1
a423 1
put_mono_values_uint(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
d433 1
a433 1
         GLuint *dst = (GLuint *) rb->Data + y[i] * rb->RowStride + x[i];
d448 1
a448 1
get_pointer_ubyte3(struct gl_context *ctx, struct gl_renderbuffer *rb,
d451 1
a451 1
   ASSERT(rb->Format == MESA_FORMAT_RGB888);
d460 1
a460 1
get_row_ubyte3(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
d463 1
a463 2
   const GLubyte *src = ((const GLubyte *) rb->Data) +
					   3 * (y * rb->RowStride + x);
d466 1
a466 1
   ASSERT(rb->Format == MESA_FORMAT_RGB888);
d478 1
a478 1
get_values_ubyte3(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
d483 1
a483 1
   ASSERT(rb->Format == MESA_FORMAT_RGB888);
d487 1
a487 1
         = (GLubyte *) rb->Data + 3 * (y[i] * rb->RowStride + x[i]);
d497 1
a497 1
put_row_ubyte3(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
d502 1
a502 1
   GLubyte *dst = (GLubyte *) rb->Data + 3 * (y * rb->RowStride + x);
d504 1
a504 1
   ASSERT(rb->Format == MESA_FORMAT_RGB888);
d517 1
a517 1
put_row_rgb_ubyte3(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
d522 1
a522 1
   GLubyte *dst = (GLubyte *) rb->Data + 3 * (y * rb->RowStride + x);
d524 1
a524 1
   ASSERT(rb->Format == MESA_FORMAT_RGB888);
d537 1
a537 1
put_mono_row_ubyte3(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
d544 2
a545 2
   GLubyte *dst = (GLubyte *) rb->Data + 3 * (y * rb->RowStride + x);
   ASSERT(rb->Format == MESA_FORMAT_RGB888);
d549 1
a549 1
      memset(dst, val0, 3 * count);
d565 1
a565 1
put_values_ubyte3(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
d572 1
a572 1
   ASSERT(rb->Format == MESA_FORMAT_RGB888);
d576 1
a576 1
         GLubyte *dst = (GLubyte *) rb->Data + 3 * (y[i] * rb->RowStride + x[i]);
d586 1
a586 1
put_mono_values_ubyte3(struct gl_context *ctx, struct gl_renderbuffer *rb,
d595 1
a595 1
   ASSERT(rb->Format == MESA_FORMAT_RGB888);
d599 1
a599 2
         GLubyte *dst = ((GLubyte *) rb->Data) +
				     3 * (y[i] * rb->RowStride + x[i]);
d613 23
d637 1
a637 1
get_values_ubyte4(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
d644 1
a644 1
   ASSERT(rb->Format == MESA_FORMAT_RGBA8888);
d646 1
a646 1
      const GLuint *src = (GLuint *) rb->Data + (y[i] * rb->RowStride + x[i]);
d653 1
a653 1
put_row_ubyte4(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
d658 1
a658 1
   GLuint *dst = (GLuint *) rb->Data + (y * rb->RowStride + x);
d660 1
a660 1
   ASSERT(rb->Format == MESA_FORMAT_RGBA8888);
d670 1
a670 1
      memcpy(dst, src, 4 * count * sizeof(GLubyte));
d676 1
a676 1
put_row_rgb_ubyte4(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
d681 1
a681 1
   GLubyte *dst = (GLubyte *) rb->Data + 4 * (y * rb->RowStride + x);
d684 1
a684 1
   ASSERT(rb->Format == MESA_FORMAT_RGBA8888);
d697 1
a697 1
put_mono_row_ubyte4(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
d702 1
a702 1
   GLuint *dst = (GLuint *) rb->Data + (y * rb->RowStride + x);
d704 1
a704 1
   ASSERT(rb->Format == MESA_FORMAT_RGBA8888);
d707 1
a707 1
      memset(dst, 0, count * 4 * sizeof(GLubyte));
d730 1
a730 1
put_values_ubyte4(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
d738 1
a738 1
   ASSERT(rb->Format == MESA_FORMAT_RGBA8888);
d741 1
a741 1
         GLuint *dst = (GLuint *) rb->Data + (y[i] * rb->RowStride + x[i]);
d749 1
a749 1
put_mono_values_ubyte4(struct gl_context *ctx, struct gl_renderbuffer *rb,
d757 1
a757 1
   ASSERT(rb->Format == MESA_FORMAT_RGBA8888);
d760 1
a760 1
         GLuint *dst = (GLuint *) rb->Data + (y[i] * rb->RowStride + x[i]);
d772 21
d794 1
a794 1
get_values_ushort4(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
d802 1
a802 1
         = (GLushort *) rb->Data + 4 * (y[i] * rb->RowStride + x[i]);
d809 1
a809 1
put_row_ushort4(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
d813 1
a813 1
   GLushort *dst = (GLushort *) rb->Data + 4 * (y * rb->RowStride + x);
d827 1
a827 1
      memcpy(dst, src, 4 * count * sizeof(GLushort));
d833 1
a833 1
put_row_rgb_ushort4(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
d838 1
a838 1
   GLushort *dst = (GLushort *) rb->Data + 4 * (y * rb->RowStride + x);
d852 1
a852 1
      memcpy(dst, src, 4 * count * sizeof(GLushort));
d858 1
a858 1
put_mono_row_ushort4(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
d865 1
a865 1
   GLushort *dst = (GLushort *) rb->Data + 4 * (y * rb->RowStride + x);
d869 1
a869 1
      memset(dst, 0, count * 4 * sizeof(GLushort));
d886 1
a886 1
put_values_ushort4(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
d895 1
a895 2
         GLushort *dst =
            ((GLushort *) rb->Data) + 4 * (y[i] * rb->RowStride + x[i]);
d906 1
a906 1
put_mono_values_ushort4(struct gl_context *ctx, struct gl_renderbuffer *rb,
d918 1
a918 2
         GLushort *dst = ((GLushort *) rb->Data) +
				       4 * (y[i] * rb->RowStride + x[i]);
a926 28
/**********************************************************************
 * Functions for MESA_FORMAT_R8.
 */
static void
get_row_r8(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
	   GLint x, GLint y, void *values)
{
   const GLubyte *src = rb->GetPointer(ctx, rb, x, y);
   GLuint *dst = values;
   GLuint i;

   for (i = 0; i < count; i++) {
      dst[i] = 0xff000000 | src[i];
   }
}

static void
get_values_r8(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
	      const GLint x[], const GLint y[], void *values)
{
   GLuint *dst = (GLuint *) values;
   GLuint i;

   for (i = 0; i < count; i++) {
      const GLubyte *src = rb->GetPointer(ctx, rb, x[i], y[i]);
      dst[i] = 0xff000000 | *src;
   }
}
a927 98
/**********************************************************************
 * Functions for MESA_FORMAT_RG88.
 */
static void
get_row_rg88(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
	     GLint x, GLint y, void *values)
{
   const GLushort *src = rb->GetPointer(ctx, rb, x, y);
   GLuint *dst = values;
   GLuint i;

   for (i = 0; i < count; i++) {
      dst[i] = 0xff000000 | src[i];
   }
}

static void
get_values_rg88(struct gl_context *ctx, struct gl_renderbuffer *rb,
		GLuint count, const GLint x[], const GLint y[], void *values)
{
   GLuint *dst = (GLuint *) values;
   GLuint i;

   for (i = 0; i < count; i++) {
      const GLshort *src = rb->GetPointer(ctx, rb, x[i], y[i]);
      dst[i] = 0xff000000 | *src;
   }
}

/**********************************************************************
 * Functions for MESA_FORMAT_R16.
 */
static void
get_row_r16(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
	    GLint x, GLint y, void *values)
{
   const GLushort *src = rb->GetPointer(ctx, rb, x, y);
   GLushort *dst = values;
   GLuint i;

   for (i = 0; i < count; i++) {
      dst[i * 4 + RCOMP] = src[i];
      dst[i * 4 + GCOMP] = 0;
      dst[i * 4 + BCOMP] = 0;
      dst[i * 4 + ACOMP] = 0xffff;
   }
}

static void
get_values_r16(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
	       const GLint x[], const GLint y[], void *values)
{
   GLushort *dst = values;
   GLuint i;

   for (i = 0; i < count; i++) {
      const GLushort *src = rb->GetPointer(ctx, rb, x[i], y[i]);
      dst[i * 4 + RCOMP] = *src;
      dst[i * 4 + GCOMP] = 0;
      dst[i * 4 + BCOMP] = 0;
      dst[i * 4 + ACOMP] = 0xffff;
   }
}

/**********************************************************************
 * Functions for MESA_FORMAT_RG1616.
 */
static void
get_row_rg1616(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
	       GLint x, GLint y, void *values)
{
   const GLushort *src = rb->GetPointer(ctx, rb, x, y);
   GLushort *dst = values;
   GLuint i;

   for (i = 0; i < count; i++) {
      dst[i * 4 + RCOMP] = src[i * 2];
      dst[i * 4 + GCOMP] = src[i * 2 + 1];
      dst[i * 4 + BCOMP] = 0;
      dst[i * 4 + ACOMP] = 0xffff;
   }
}

static void
get_values_rg1616(struct gl_context *ctx, struct gl_renderbuffer *rb,
		  GLuint count, const GLint x[], const GLint y[], void *values)
{
   GLushort *dst = values;
   GLuint i;

   for (i = 0; i < count; i++) {
      const GLshort *src = rb->GetPointer(ctx, rb, x[i], y[i]);
      dst[i * 4 + RCOMP] = src[0];
      dst[i * 4 + GCOMP] = src[1];
      dst[i * 4 + BCOMP] = 0;
      dst[i * 4 + ACOMP] = 0xffff;
   }
}
d930 6
a935 2
 * This is the default software fallback for gl_renderbuffer's span
 * access functions.
d937 5
a941 3
 * The assumptions are that rb->Data will be a pointer to (0,0), that pixels
 * are packed in the type of rb->Format, and that subsequent rows appear
 * rb->RowStride pixels later.
d943 4
a946 2
void
_mesa_set_renderbuffer_accessors(struct gl_renderbuffer *rb)
d948 10
a957 2
   rb->GetPointer = get_pointer_generic;
   rb->GetRow = get_row_generic;
d959 11
a969 2
   switch (rb->Format) {
   case MESA_FORMAT_RGB888:
d979 5
d985 7
a991 2

   case MESA_FORMAT_RGBA8888:
d993 2
d1001 5
d1007 5
a1011 35

   case MESA_FORMAT_R8:
      rb->DataType = GL_UNSIGNED_BYTE;
      rb->GetValues = get_values_r8;
      rb->GetRow = get_row_r8;
      rb->PutRow = put_row_generic;
      rb->PutRowRGB = put_row_generic;
      rb->PutMonoRow = put_mono_row_generic;
      rb->PutValues = put_values_generic;
      rb->PutMonoValues = put_mono_values_generic;
      break;

   case MESA_FORMAT_RG88:
      rb->DataType = GL_UNSIGNED_BYTE;
      rb->GetValues = get_values_rg88;
      rb->GetRow = get_row_rg88;
      rb->PutRow = put_row_generic;
      rb->PutRowRGB = put_row_generic;
      rb->PutMonoRow = put_mono_row_generic;
      rb->PutValues = put_values_generic;
      rb->PutMonoValues = put_mono_values_generic;
      break;

   case MESA_FORMAT_R16:
      rb->DataType = GL_UNSIGNED_SHORT;
      rb->GetValues = get_values_r16;
      rb->GetRow = get_row_r16;
      rb->PutRow = put_row_generic;
      rb->PutRowRGB = put_row_generic;
      rb->PutMonoRow = put_mono_row_generic;
      rb->PutValues = put_values_generic;
      rb->PutMonoValues = put_mono_values_generic;
      break;

   case MESA_FORMAT_RG1616:
d1013 2
a1014 11
      rb->GetValues = get_values_rg1616;
      rb->GetRow = get_row_rg1616;
      rb->PutRow = put_row_generic;
      rb->PutRowRGB = put_row_generic;
      rb->PutMonoRow = put_mono_row_generic;
      rb->PutValues = put_values_generic;
      rb->PutMonoValues = put_mono_values_generic;
      break;

   case MESA_FORMAT_SIGNED_RGBA_16:
      rb->DataType = GL_SHORT;
d1021 5
d1027 4
a1030 3

#if 0
   case MESA_FORMAT_A8:
d1032 2
d1040 5
d1047 6
a1052 2

   case MESA_FORMAT_S8:
d1054 2
d1062 17
d1080 4
a1083 2

   case MESA_FORMAT_Z16:
d1085 2
d1093 2
d1096 3
a1098 4

   case MESA_FORMAT_Z32:
   case MESA_FORMAT_X8_Z24:
   case MESA_FORMAT_Z24_X8:
d1100 2
d1108 9
d1118 4
a1121 3

   case MESA_FORMAT_Z24_S8:
   case MESA_FORMAT_S8_Z24:
d1123 2
d1131 18
d1150 14
a1163 2

   default:
d1165 14
a1178 74
   }
}

/**
 * This is a software fallback for the gl_renderbuffer->AllocStorage
 * function.
 * Device drivers will typically override this function for the buffers
 * which it manages (typically color buffers, Z and stencil).
 * Other buffers (like software accumulation and aux buffers) which the driver
 * doesn't manage can be handled with this function.
 *
 * This one multi-purpose function can allocate stencil, depth, accum, color
 * or color-index buffers!
 *
 * This function also plugs in the appropriate GetPointer, Get/PutRow and
 * Get/PutValues functions.
 */
GLboolean
_mesa_soft_renderbuffer_storage(struct gl_context *ctx, struct gl_renderbuffer *rb,
                                GLenum internalFormat,
                                GLuint width, GLuint height)
{
   switch (internalFormat) {
   case GL_RGB:
   case GL_R3_G3_B2:
   case GL_RGB4:
   case GL_RGB5:
   case GL_RGB8:
   case GL_RGB10:
   case GL_RGB12:
   case GL_RGB16:
      rb->Format = MESA_FORMAT_RGB888;
      break;
   case GL_RGBA:
   case GL_RGBA2:
   case GL_RGBA4:
   case GL_RGB5_A1:
   case GL_RGBA8:
#if 1
   case GL_RGB10_A2:
   case GL_RGBA12:
#endif
      rb->Format = MESA_FORMAT_RGBA8888;
      break;
   case GL_RGBA16:
   case GL_RGBA16_SNORM:
      /* for accum buffer */
      rb->Format = MESA_FORMAT_SIGNED_RGBA_16;
      break;
#if 0
   case GL_ALPHA8:
      rb->Format = MESA_FORMAT_A8;
      break;
#endif
   case GL_STENCIL_INDEX:
   case GL_STENCIL_INDEX1_EXT:
   case GL_STENCIL_INDEX4_EXT:
   case GL_STENCIL_INDEX8_EXT:
   case GL_STENCIL_INDEX16_EXT:
      rb->Format = MESA_FORMAT_S8;
      break;
   case GL_DEPTH_COMPONENT:
   case GL_DEPTH_COMPONENT16:
      rb->Format = MESA_FORMAT_Z16;
      break;
   case GL_DEPTH_COMPONENT24:
      rb->Format = MESA_FORMAT_X8_Z24;
      break;
   case GL_DEPTH_COMPONENT32:
      rb->Format = MESA_FORMAT_Z32;
      break;
   case GL_DEPTH_STENCIL_EXT:
   case GL_DEPTH24_STENCIL8_EXT:
      rb->Format = MESA_FORMAT_Z24_S8;
a1184 2
   _mesa_set_renderbuffer_accessors(rb);

d1196 1
a1196 1
      free(rb->Data);
a1199 2
   rb->RowStride = width;

d1202 1
a1202 2
      rb->Data = malloc(width * height * _mesa_get_format_bytes(rb->Format));

a1205 1
	 rb->RowStride = 0;
d1208 1
a1208 1
                     width, height, _mesa_get_format_bytes(rb->Format));
a1214 2
   rb->_BaseFormat = _mesa_base_fbo_format(ctx, internalFormat);
   ASSERT(rb->_BaseFormat);
d1237 1
a1237 1
alloc_storage_alpha8(struct gl_context *ctx, struct gl_renderbuffer *arb,
d1241 1
a1241 1
   ASSERT(arb->Format == MESA_FORMAT_A8);
d1251 1
a1251 1
      free(arb->Data);
d1254 1
a1254 1
   arb->Data = malloc(width * height * sizeof(GLubyte));
a1263 1
   arb->RowStride = width;
d1276 1
a1276 1
      free(arb->Data);
d1282 1
a1282 1
   free(arb);
d1287 1
a1287 1
get_pointer_alpha8(struct gl_context *ctx, struct gl_renderbuffer *arb,
d1295 1
a1295 1
get_row_alpha8(struct gl_context *ctx, struct gl_renderbuffer *arb, GLuint count,
d1299 1
a1299 1
   const GLubyte *src = (const GLubyte *) arb->Data + y * arb->RowStride + x;
d1314 1
a1314 1
get_values_alpha8(struct gl_context *ctx, struct gl_renderbuffer *arb, GLuint count,
d1325 1
a1325 1
      const GLubyte *src = (GLubyte *) arb->Data + y[i] * arb->RowStride + x[i];
d1332 1
a1332 1
put_row_alpha8(struct gl_context *ctx, struct gl_renderbuffer *arb, GLuint count,
d1336 1
a1336 1
   GLubyte *dst = (GLubyte *) arb->Data + y * arb->RowStride + x;
d1352 1
a1352 1
put_row_rgb_alpha8(struct gl_context *ctx, struct gl_renderbuffer *arb, GLuint count,
d1356 1
a1356 1
   GLubyte *dst = (GLubyte *) arb->Data + y * arb->RowStride + x;
d1372 1
a1372 1
put_mono_row_alpha8(struct gl_context *ctx, struct gl_renderbuffer *arb, GLuint count,
d1376 1
a1376 1
   GLubyte *dst = (GLubyte *) arb->Data + y * arb->RowStride + x;
d1391 1
a1391 1
      memset(dst, val, count);
d1397 1
a1397 1
put_values_alpha8(struct gl_context *ctx, struct gl_renderbuffer *arb, GLuint count,
d1410 1
a1410 1
         GLubyte *dst = (GLubyte *) arb->Data + y[i] * arb->RowStride + x[i];
d1418 1
a1418 1
put_mono_values_alpha8(struct gl_context *ctx, struct gl_renderbuffer *arb,
d1431 1
a1431 1
         GLubyte *dst = (GLubyte *) arb->Data + y[i] * arb->RowStride + x[i];
d1441 2
a1442 2
   ASSERT(dst->Format == MESA_FORMAT_A8);
   ASSERT(src->Format == MESA_FORMAT_A8);
a1444 1
   ASSERT(dst->RowStride == src->RowStride);
d1446 1
a1446 1
   memcpy(dst->Data, src->Data, dst->RowStride * dst->Height * sizeof(GLubyte));
d1460 1
a1460 1
nop_get_pointer(struct gl_context *ctx, struct gl_renderbuffer *rb, GLint x, GLint y)
d1488 2
a1489 2
   rb->Format = MESA_FORMAT_NONE;

d1491 4
d1518 1
a1518 1
_mesa_new_renderbuffer(struct gl_context *ctx, GLuint name)
d1536 1
a1536 1
      free(rb->Data);
d1538 1
a1538 1
   free(rb);
d1549 1
a1549 1
_mesa_new_soft_renderbuffer(struct gl_context *ctx, GLuint name)
d1572 1
a1572 1
_mesa_add_color_renderbuffers(struct gl_context *ctx, struct gl_framebuffer *fb,
d1609 1
a1609 1
            rb->Format = MESA_FORMAT_RGBA8888;
d1611 1
a1611 1
            rb->Format = MESA_FORMAT_RGB888;
d1615 57
a1671 1
         rb->Format = MESA_FORMAT_NONE; /*XXX RGBA16;*/
d1673 10
a1682 1
      rb->InternalFormat = GL_RGBA;
d1701 1
a1701 1
_mesa_add_alpha_renderbuffers(struct gl_context *ctx, struct gl_framebuffer *fb,
d1755 2
a1756 1
      arb->Format         = MESA_FORMAT_A8;
d1786 1
a1786 1
_mesa_copy_soft_alpha_renderbuffers(struct gl_context *ctx, struct gl_framebuffer *fb)
d1810 1
a1810 1
_mesa_add_depth_renderbuffer(struct gl_context *ctx, struct gl_framebuffer *fb,
d1830 1
a1830 2
      rb->Format = MESA_FORMAT_Z16;
      rb->InternalFormat = GL_DEPTH_COMPONENT16;
d1833 1
a1833 2
      rb->Format = MESA_FORMAT_X8_Z24;
      rb->InternalFormat = GL_DEPTH_COMPONENT24;
d1836 1
a1836 2
      rb->Format = MESA_FORMAT_Z32;
      rb->InternalFormat = GL_DEPTH_COMPONENT32;
d1838 1
d1856 1
a1856 1
_mesa_add_stencil_renderbuffer(struct gl_context *ctx, struct gl_framebuffer *fb,
d1875 8
a1882 3
   assert(stencilBits <= 8);
   rb->Format = MESA_FORMAT_S8;
   rb->InternalFormat = GL_STENCIL_INDEX8;
d1900 1
a1900 1
_mesa_add_accum_renderbuffer(struct gl_context *ctx, struct gl_framebuffer *fb,
d1920 2
a1921 2
   rb->Format = MESA_FORMAT_SIGNED_RGBA_16;
   rb->InternalFormat = GL_RGBA16_SNORM;
d1931 1
a1931 1
 * Add a software-based aux renderbuffer to the given framebuffer.
d1941 1
a1941 1
_mesa_add_aux_renderbuffers(struct gl_context *ctx, struct gl_framebuffer *fb,
d1952 1
a1952 1
   assert(numBuffers <= MAX_AUX_BUFFERS);
d1960 1
a1960 1
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "Allocating aux buffer");
d1964 7
a1970 3
      assert (colorBits <= 8);
      rb->Format = MESA_FORMAT_RGBA8888;
      rb->InternalFormat = GL_RGBA;
d1999 15
a2013 7
      assert(fb->Visual.redBits == fb->Visual.greenBits);
      assert(fb->Visual.redBits == fb->Visual.blueBits);
      _mesa_add_color_renderbuffers(NULL, fb,
				    fb->Visual.redBits,
				    fb->Visual.alphaBits,
				    frontLeft, backLeft,
				    frontRight, backRight);
d2027 1
d2039 1
d2046 1
d2088 19
d2189 1
a2189 1
_mesa_new_depthstencil_renderbuffer(struct gl_context *ctx, GLuint name)
d2199 1
a2199 1
   dsrb->Format = MESA_FORMAT_Z24_S8;
@


1.1.1.4
log
@Import Mesa 9.2.0
@
text
@d3 1
d20 3
a22 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
d26 1586
a1611 7
#include "glheader.h"
#include "imports.h"
#include "context.h"
#include "fbobject.h"
#include "formats.h"
#include "mtypes.h"
#include "renderbuffer.h"
d1622 1
d1635 1
a1635 2
   rb->Depth = 0;
   rb->InternalFormat = GL_RGBA;
d1637 17
a1674 3
 * Drivers which subclass gl_renderbuffer should probably implement their
 * own delete function.  But the driver might also call this function to
 * free the object in the end.
d1677 1
a1677 1
_mesa_delete_renderbuffer(struct gl_context *ctx, struct gl_renderbuffer *rb)
d1679 3
a1681 1
   _glthread_DESTROY_MUTEX(rb->Mutex);
d1687 435
a2122 1
 * \param bufferName  one of the BUFFER_x tokens
d2126 1
a2126 1
                       gl_buffer_index bufferName, struct gl_renderbuffer *rb)
d2141 1
a2141 1
   if (_mesa_is_user_fbo(fb)) {
a2155 1
 * \param bufferName  one of the BUFFER_x tokens
d2158 1
a2158 2
_mesa_remove_renderbuffer(struct gl_framebuffer *fb,
                          gl_buffer_index bufferName)
d2160 2
d2163 8
a2170 2
   _mesa_reference_renderbuffer(&fb->Attachment[bufferName].Renderbuffer,
                                NULL);
a2177 2
 * This is normally only called from the _mesa_reference_renderbuffer() macro
 * when there's a real pointer change.
d2180 2
a2181 2
_mesa_reference_renderbuffer_(struct gl_renderbuffer **ptr,
                              struct gl_renderbuffer *rb)
d2183 6
d2194 1
d2196 1
d2204 2
a2205 2
         GET_CURRENT_CONTEXT(ctx);
         oldRb->Delete(ctx, oldRb);
d2213 1
d2221 23
@


1.1.1.5
log
@Import Mesa 10.2.3
@
text
@d41 1
a41 1
   mtx_init(&rb->Mutex, mtx_plain);
d86 1
a86 2
   mtx_destroy(&rb->Mutex);
   free(rb->Label);
d155 1
a155 1
      mtx_lock(&oldRb->Mutex);
d160 1
a160 1
      mtx_unlock(&oldRb->Mutex);
d173 1
a173 1
      mtx_lock(&rb->Mutex);
d176 1
a176 1
      mtx_unlock(&rb->Mutex);
@


