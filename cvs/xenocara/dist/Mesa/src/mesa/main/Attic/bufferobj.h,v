head	1.10;
access;
symbols
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	v10_2_9:1.1.1.6
	v10_4_3:1.1.1.5
	v10_2_7:1.1.1.4
	OPENBSD_5_6:1.7.0.2
	OPENBSD_5_6_BASE:1.7
	v10_2_3:1.1.1.4
	OPENBSD_5_5:1.6.0.2
	OPENBSD_5_5_BASE:1.6
	v9_2_5:1.1.1.3
	v9_2_3:1.1.1.3
	v9_2_2:1.1.1.3
	v9_2_1:1.1.1.3
	v9_2_0:1.1.1.3
	OPENBSD_5_4:1.5.0.4
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.2
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.4.0.4
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	v7_10_3:1.1.1.2
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.6
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v7_0_1:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v6_5_2:1.1.1.1
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2015.12.23.05.17.52;	author jsg;	state dead;
branches;
next	1.9;
commitid	TnlogFl9nOv2eaRf;

1.9
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.8;
commitid	4ry2gvZGMXkCUD2n;

1.8
date	2015.01.25.14.41.21;	author jsg;	state Exp;
branches;
next	1.7;
commitid	mcxB0JvoI9gTDYXU;

1.7
date	2014.07.09.21.09.00;	author jsg;	state Exp;
branches;
next	1.6;
commitid	WPD6rgPryPkvXOr9;

1.6
date	2013.09.05.14.06.16;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2012.08.17.13.58.17;	author mpi;	state Exp;
branches;
next	1.4;

1.4
date	2011.10.23.13.37.42;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.05.22.20.06.30;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.20;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.49.44;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.49.44;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2011.10.23.13.29.45;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2013.09.05.13.16.24;	author jsg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.07.09.20.34.58;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.5
date	2015.01.25.14.12.28;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.6
date	2015.02.20.22.49.35;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.10
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2008  Brian Paul   All Rights Reserved.
 * Copyright (C) 2009  VMware, Inc.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */



#ifndef BUFFEROBJ_H
#define BUFFEROBJ_H

#include <stdbool.h>
#include "mtypes.h"


/*
 * Internal functions
 */


/** Is the given buffer object currently mapped by the GL user? */
static inline GLboolean
_mesa_bufferobj_mapped(const struct gl_buffer_object *obj,
                       gl_map_buffer_index index)
{
   return obj->Mappings[index].Pointer != NULL;
}

/** Can we not use this buffer while mapped? */
static inline GLboolean
_mesa_check_disallowed_mapping(const struct gl_buffer_object *obj)
{
   return _mesa_bufferobj_mapped(obj, MAP_USER) &&
          !(obj->Mappings[MAP_USER].AccessFlags &
            GL_MAP_PERSISTENT_BIT);
}

/**
 * Is the given buffer object a user-created buffer object?
 * Mesa uses default buffer objects in several places.  Default buffers
 * always have Name==0.  User created buffers have Name!=0.
 */
static inline GLboolean
_mesa_is_bufferobj(const struct gl_buffer_object *obj)
{
   return obj != NULL && obj->Name != 0;
}


extern void
_mesa_init_buffer_objects(struct gl_context *ctx);

extern void
_mesa_free_buffer_objects(struct gl_context *ctx);

extern bool
_mesa_handle_bind_buffer_gen(struct gl_context *ctx,
                             GLenum target,
                             GLuint buffer,
                             struct gl_buffer_object **buf_handle,
                             const char *caller);

extern void
_mesa_update_default_objects_buffer_objects(struct gl_context *ctx);


extern struct gl_buffer_object *
_mesa_lookup_bufferobj(struct gl_context *ctx, GLuint buffer);

extern struct gl_buffer_object *
_mesa_lookup_bufferobj_locked(struct gl_context *ctx, GLuint buffer);

extern void
_mesa_begin_bufferobj_lookups(struct gl_context *ctx);

extern void
_mesa_end_bufferobj_lookups(struct gl_context *ctx);

extern struct gl_buffer_object *
_mesa_multi_bind_lookup_bufferobj(struct gl_context *ctx,
                                  const GLuint *buffers,
                                  GLuint index, const char *caller);

extern void
_mesa_initialize_buffer_object(struct gl_context *ctx,
                               struct gl_buffer_object *obj,
                               GLuint name, GLenum target);

extern void
_mesa_reference_buffer_object_(struct gl_context *ctx,
                               struct gl_buffer_object **ptr,
                               struct gl_buffer_object *bufObj);

static inline void
_mesa_reference_buffer_object(struct gl_context *ctx,
                              struct gl_buffer_object **ptr,
                              struct gl_buffer_object *bufObj)
{
   if (*ptr != bufObj)
      _mesa_reference_buffer_object_(ctx, ptr, bufObj);
}

extern GLuint
_mesa_total_buffer_object_memory(struct gl_context *ctx);

extern void
_mesa_init_buffer_object_functions(struct dd_function_table *driver);

extern void
_mesa_buffer_unmap_all_mappings(struct gl_context *ctx,
                                struct gl_buffer_object *bufObj);

extern void
_mesa_buffer_clear_subdata(struct gl_context *ctx,
                           GLintptr offset, GLsizeiptr size,
                           const GLvoid *clearValue,
                           GLsizeiptr clearValueSize,
                           struct gl_buffer_object *bufObj);

/*
 * API functions
 */
void GLAPIENTRY
_mesa_BindBuffer(GLenum target, GLuint buffer);

void GLAPIENTRY
_mesa_DeleteBuffers(GLsizei n, const GLuint * buffer);

void GLAPIENTRY
_mesa_GenBuffers(GLsizei n, GLuint * buffer);

GLboolean GLAPIENTRY
_mesa_IsBuffer(GLuint buffer);

void GLAPIENTRY
_mesa_BufferStorage(GLenum target, GLsizeiptr size, const GLvoid *data,
                    GLbitfield flags);

void GLAPIENTRY
_mesa_BufferData(GLenum target, GLsizeiptrARB size,
                 const GLvoid * data, GLenum usage);

void GLAPIENTRY
_mesa_BufferSubData(GLenum target, GLintptrARB offset,
                    GLsizeiptrARB size, const GLvoid * data);

void GLAPIENTRY
_mesa_GetBufferSubData(GLenum target, GLintptrARB offset,
                       GLsizeiptrARB size, void * data);

void GLAPIENTRY
_mesa_ClearBufferData(GLenum target, GLenum internalformat,
                      GLenum format, GLenum type,
                      const GLvoid * data);

void GLAPIENTRY
_mesa_ClearBufferSubData(GLenum target, GLenum internalformat,
                         GLintptr offset, GLsizeiptr size,
                         GLenum format, GLenum type,
                         const GLvoid * data);

void * GLAPIENTRY
_mesa_MapBuffer(GLenum target, GLenum access);

GLboolean GLAPIENTRY
_mesa_UnmapBuffer(GLenum target);

void GLAPIENTRY
_mesa_GetBufferParameteriv(GLenum target, GLenum pname, GLint *params);

void GLAPIENTRY
_mesa_GetBufferParameteri64v(GLenum target, GLenum pname, GLint64 *params);

void GLAPIENTRY
_mesa_GetBufferPointerv(GLenum target, GLenum pname, GLvoid **params);

void GLAPIENTRY
_mesa_CopyBufferSubData(GLenum readTarget, GLenum writeTarget,
                        GLintptr readOffset, GLintptr writeOffset,
                        GLsizeiptr size);

void * GLAPIENTRY
_mesa_MapBufferRange(GLenum target, GLintptr offset, GLsizeiptr length,
                     GLbitfield access);

void GLAPIENTRY
_mesa_FlushMappedBufferRange(GLenum target,
                             GLintptr offset, GLsizeiptr length);

GLenum GLAPIENTRY
_mesa_ObjectPurgeableAPPLE(GLenum objectType, GLuint name, GLenum option);

GLenum GLAPIENTRY
_mesa_ObjectUnpurgeableAPPLE(GLenum objectType, GLuint name, GLenum option);

void GLAPIENTRY
_mesa_GetObjectParameterivAPPLE(GLenum objectType, GLuint name,
                                GLenum pname, GLint* params);

void GLAPIENTRY
_mesa_BindBufferRange(GLenum target, GLuint index,
                      GLuint buffer, GLintptr offset, GLsizeiptr size);

void GLAPIENTRY
_mesa_BindBufferBase(GLenum target, GLuint index, GLuint buffer);

void GLAPIENTRY
_mesa_BindBuffersRange(GLenum target, GLuint first, GLsizei count,
                       const GLuint *buffers,
                       const GLintptr *offsets, const GLsizeiptr *sizes);
void GLAPIENTRY
_mesa_BindBuffersBase(GLenum target, GLuint first, GLsizei count,
                      const GLuint *buffers);
void GLAPIENTRY
_mesa_InvalidateBufferSubData(GLuint buffer, GLintptr offset,
                              GLsizeiptr length);

void GLAPIENTRY
_mesa_InvalidateBufferData(GLuint buffer);


#endif
@


1.9
log
@Merge Mesa 10.2.9
@
text
@@


1.8
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d106 1
a106 1
                               GLuint name);
@


1.7
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d106 1
a106 1
                               GLuint name, GLenum target);
@


1.6
log
@Merge Mesa 9.2.0
@
text
@d31 1
a31 1

d40 9
a48 1
/** Is the given buffer object currently mapped? */
d50 1
a50 1
_mesa_bufferobj_mapped(const struct gl_buffer_object *obj)
d52 3
a54 1
   return obj->Pointer != NULL;
d70 1
a70 1
_mesa_init_buffer_objects( struct gl_context *ctx );
d73 8
a80 1
_mesa_free_buffer_objects( struct gl_context *ctx );
d89 14
d104 3
a106 3
_mesa_initialize_buffer_object( struct gl_context *ctx,
				struct gl_buffer_object *obj,
				GLuint name, GLenum target );
d128 10
a141 1

d144 1
d147 1
d150 1
d153 1
d155 3
a157 1
_mesa_BufferData(GLenum target, GLsizeiptrARB size, const GLvoid * data, GLenum usage);
d159 3
a161 1
_mesa_BufferSubData(GLenum target, GLintptrARB offset, GLsizeiptrARB size, const GLvoid * data);
d163 18
a180 1
_mesa_GetBufferSubData(GLenum target, GLintptrARB offset, GLsizeiptrARB size, void * data);
d183 1
d186 1
d189 1
d192 1
d195 1
d200 1
d204 1
d206 3
a208 1
_mesa_FlushMappedBufferRange(GLenum target, GLintptr offset, GLsizeiptr length);
d211 1
d214 1
d216 3
a218 2
_mesa_GetObjectParameterivAPPLE(GLenum objectType, GLuint name, GLenum pname,
                                GLint* params);
d222 1
d225 8
d236 1
@


1.5
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a2 1
 * Version:  7.6
d20 4
a23 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
a31 1
#include "mfeatures.h"
d41 1
a41 1
static INLINE GLboolean
d52 1
a52 1
static INLINE GLboolean
d55 1
a55 1
   return obj->Name != 0;
d73 2
a74 1
_mesa_initialize_buffer_object( struct gl_buffer_object *obj,
d78 5
d85 8
a92 1
                              struct gl_buffer_object *bufObj);
d102 21
a122 31
extern void GLAPIENTRY
_mesa_BindBufferARB(GLenum target, GLuint buffer);

extern void GLAPIENTRY
_mesa_DeleteBuffersARB(GLsizei n, const GLuint * buffer);

extern void GLAPIENTRY
_mesa_GenBuffersARB(GLsizei n, GLuint * buffer);

extern GLboolean GLAPIENTRY
_mesa_IsBufferARB(GLuint buffer);

extern void GLAPIENTRY
_mesa_BufferDataARB(GLenum target, GLsizeiptrARB size, const GLvoid * data, GLenum usage);

extern void GLAPIENTRY
_mesa_BufferSubDataARB(GLenum target, GLintptrARB offset, GLsizeiptrARB size, const GLvoid * data);

extern void GLAPIENTRY
_mesa_GetBufferSubDataARB(GLenum target, GLintptrARB offset, GLsizeiptrARB size, void * data);

extern void * GLAPIENTRY
_mesa_MapBufferARB(GLenum target, GLenum access);

extern GLboolean GLAPIENTRY
_mesa_UnmapBufferARB(GLenum target);

extern void GLAPIENTRY
_mesa_GetBufferParameterivARB(GLenum target, GLenum pname, GLint *params);

extern void GLAPIENTRY
d124 3
a126 5

extern void GLAPIENTRY
_mesa_GetBufferPointervARB(GLenum target, GLenum pname, GLvoid **params);

extern void GLAPIENTRY
d130 1
a130 2

extern void * GLAPIENTRY
d133 1
a133 2

extern void GLAPIENTRY
d135 1
a135 3

#if FEATURE_APPLE_object_purgeable
extern GLenum GLAPIENTRY
d137 1
a137 2

extern GLenum GLAPIENTRY
d139 13
a152 3
extern void GLAPIENTRY
_mesa_GetObjectParameterivAPPLE(GLenum objectType, GLuint name, GLenum pname, GLint* params);
#endif
@


1.4
log
@Merge Mesa 7.10.3
@
text
@d32 1
a80 41

extern GLboolean
_mesa_validate_pbo_access(GLuint dimensions,
                          const struct gl_pixelstore_attrib *pack,
                          GLsizei width, GLsizei height, GLsizei depth,
                          GLenum format, GLenum type, const GLvoid *ptr);

extern const GLvoid *
_mesa_map_pbo_source(struct gl_context *ctx,
                     const struct gl_pixelstore_attrib *unpack,
                     const GLvoid *src);

extern const GLvoid *
_mesa_map_validate_pbo_source(struct gl_context *ctx,
                              GLuint dimensions,
                              const struct gl_pixelstore_attrib *unpack,
                              GLsizei width, GLsizei height, GLsizei depth,
                              GLenum format, GLenum type, const GLvoid *ptr,
                              const char *where);

extern void
_mesa_unmap_pbo_source(struct gl_context *ctx,
                       const struct gl_pixelstore_attrib *unpack);

extern void *
_mesa_map_pbo_dest(struct gl_context *ctx,
                   const struct gl_pixelstore_attrib *pack,
                   GLvoid *dest);

extern GLvoid *
_mesa_map_validate_pbo_dest(struct gl_context *ctx,
                            GLuint dimensions,
                            const struct gl_pixelstore_attrib *unpack,
                            GLsizei width, GLsizei height, GLsizei depth,
                            GLenum format, GLenum type, GLvoid *ptr,
                            const char *where);

extern void
_mesa_unmap_pbo_dest(struct gl_context *ctx,
                     const struct gl_pixelstore_attrib *pack);

@


1.3
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d32 1
a32 1
#include "context.h"
d60 1
a60 1
_mesa_init_buffer_objects( GLcontext *ctx );
d63 1
a63 1
_mesa_free_buffer_objects( GLcontext *ctx );
d66 1
a66 1
_mesa_update_default_objects_buffer_objects(GLcontext *ctx);
d70 1
a70 1
_mesa_lookup_bufferobj(GLcontext *ctx, GLuint buffer);
d77 1
a77 1
_mesa_reference_buffer_object(GLcontext *ctx,
d88 1
a88 1
_mesa_map_pbo_source(GLcontext *ctx,
d93 1
a93 1
_mesa_map_validate_pbo_source(GLcontext *ctx,
d101 1
a101 1
_mesa_unmap_pbo_source(GLcontext *ctx,
d105 1
a105 1
_mesa_map_pbo_dest(GLcontext *ctx,
d110 1
a110 1
_mesa_map_validate_pbo_dest(GLcontext *ctx,
d118 1
a118 1
_mesa_unmap_pbo_dest(GLcontext *ctx,
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d3 1
a3 1
 * Version:  7.2
d6 1
d39 20
d63 3
a67 5
extern struct gl_buffer_object *
_mesa_new_buffer_object( GLcontext *ctx, GLuint name, GLenum target );

extern void
_mesa_delete_buffer_object( GLcontext *ctx, struct gl_buffer_object *bufObj );
a80 23
extern void
_mesa_buffer_data( GLcontext *ctx, GLenum target, GLsizeiptrARB size,
		   const GLvoid * data, GLenum usage,
		   struct gl_buffer_object * bufObj );

extern void
_mesa_buffer_subdata( GLcontext *ctx, GLenum target, GLintptrARB offset,
		      GLsizeiptrARB size, const GLvoid * data,
		      struct gl_buffer_object * bufObj );

extern void
_mesa_buffer_get_subdata( GLcontext *ctx, GLenum target, GLintptrARB offset,
			  GLsizeiptrARB size, GLvoid * data,
			  struct gl_buffer_object * bufObj );

extern void *
_mesa_buffer_map( GLcontext *ctx, GLenum target, GLenum access,
		  struct gl_buffer_object * bufObj );

extern GLboolean
_mesa_buffer_unmap( GLcontext *ctx, GLenum target,
                    struct gl_buffer_object * bufObj );

d87 2
a88 2
extern const GLubyte *
_mesa_map_bitmap_pbo(GLcontext *ctx,
d90 1
a90 5
                     const GLubyte *bitmap);

extern void
_mesa_unmap_bitmap_pbo(GLcontext *ctx,
                       const struct gl_pixelstore_attrib *unpack);
d93 6
a98 3
_mesa_map_drawpix_pbo(GLcontext *ctx,
                      const struct gl_pixelstore_attrib *unpack,
                      const GLvoid *pixels);
d101 1
a101 1
_mesa_unmap_drapix_pbo(GLcontext *ctx,
d104 4
d109 7
a115 4
extern void *
_mesa_map_readpix_pbo(GLcontext *ctx,
                      const struct gl_pixelstore_attrib *pack,
                      GLvoid *dest);
d118 2
a119 2
_mesa_unmap_readpix_pbo(GLcontext *ctx,
                        const struct gl_pixelstore_attrib *pack);
d122 3
d161 3
d165 23
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * Version:  6.3
d5 1
a5 1
 * Copyright (C) 1999-2004  Brian Paul   All Rights Reserved.
d41 3
d58 3
a60 4
_mesa_save_buffer_object( GLcontext *ctx, struct gl_buffer_object *obj );

extern void
_mesa_remove_buffer_object( GLcontext *ctx, struct gl_buffer_object *bufObj );
d91 14
d106 14
a119 1
_mesa_unbind_buffer_object( GLcontext *ctx, struct gl_buffer_object *bufObj );
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@Import Mesa 7.10.3
@
text
@d3 1
a3 1
 * Version:  7.6
d5 1
a5 2
 * Copyright (C) 1999-2008  Brian Paul   All Rights Reserved.
 * Copyright (C) 2009  VMware, Inc.  All Rights Reserved.
d31 1
a31 1
#include "mtypes.h"
a37 20

/** Is the given buffer object currently mapped? */
static INLINE GLboolean
_mesa_bufferobj_mapped(const struct gl_buffer_object *obj)
{
   return obj->Pointer != NULL;
}

/**
 * Is the given buffer object a user-created buffer object?
 * Mesa uses default buffer objects in several places.  Default buffers
 * always have Name==0.  User created buffers have Name!=0.
 */
static INLINE GLboolean
_mesa_is_bufferobj(const struct gl_buffer_object *obj)
{
   return obj->Name != 0;
}


d39 1
a39 1
_mesa_init_buffer_objects( struct gl_context *ctx );
d41 2
a42 2
extern void
_mesa_free_buffer_objects( struct gl_context *ctx );
d45 1
a45 2
_mesa_update_default_objects_buffer_objects(struct gl_context *ctx);

d48 1
a48 1
_mesa_lookup_bufferobj(struct gl_context *ctx, GLuint buffer);
d55 1
a55 3
_mesa_reference_buffer_object(struct gl_context *ctx,
                              struct gl_buffer_object **ptr,
                              struct gl_buffer_object *bufObj);
d57 7
a63 5
extern GLboolean
_mesa_validate_pbo_access(GLuint dimensions,
                          const struct gl_pixelstore_attrib *pack,
                          GLsizei width, GLsizei height, GLsizei depth,
                          GLenum format, GLenum type, const GLvoid *ptr);
d65 4
a68 12
extern const GLvoid *
_mesa_map_pbo_source(struct gl_context *ctx,
                     const struct gl_pixelstore_attrib *unpack,
                     const GLvoid *src);

extern const GLvoid *
_mesa_map_validate_pbo_source(struct gl_context *ctx,
                              GLuint dimensions,
                              const struct gl_pixelstore_attrib *unpack,
                              GLsizei width, GLsizei height, GLsizei depth,
                              GLenum format, GLenum type, const GLvoid *ptr,
                              const char *where);
d71 3
a73 2
_mesa_unmap_pbo_source(struct gl_context *ctx,
                       const struct gl_pixelstore_attrib *unpack);
d76 2
a77 3
_mesa_map_pbo_dest(struct gl_context *ctx,
                   const struct gl_pixelstore_attrib *pack,
                   GLvoid *dest);
d79 3
a81 11
extern GLvoid *
_mesa_map_validate_pbo_dest(struct gl_context *ctx,
                            GLuint dimensions,
                            const struct gl_pixelstore_attrib *unpack,
                            GLsizei width, GLsizei height, GLsizei depth,
                            GLenum format, GLenum type, GLvoid *ptr,
                            const char *where);

extern void
_mesa_unmap_pbo_dest(struct gl_context *ctx,
                     const struct gl_pixelstore_attrib *pack);
d83 5
d90 1
a90 2
_mesa_init_buffer_object_functions(struct dd_function_table *driver);

a126 3
_mesa_GetBufferParameteri64v(GLenum target, GLenum pname, GLint64 *params);

extern void GLAPIENTRY
a127 23

extern void GLAPIENTRY
_mesa_CopyBufferSubData(GLenum readTarget, GLenum writeTarget,
                        GLintptr readOffset, GLintptr writeOffset,
                        GLsizeiptr size);

extern void * GLAPIENTRY
_mesa_MapBufferRange(GLenum target, GLintptr offset, GLsizeiptr length,
                     GLbitfield access);

extern void GLAPIENTRY
_mesa_FlushMappedBufferRange(GLenum target, GLintptr offset, GLsizeiptr length);

#if FEATURE_APPLE_object_purgeable
extern GLenum GLAPIENTRY
_mesa_ObjectPurgeableAPPLE(GLenum objectType, GLuint name, GLenum option);

extern GLenum GLAPIENTRY
_mesa_ObjectUnpurgeableAPPLE(GLenum objectType, GLuint name, GLenum option);

extern void GLAPIENTRY
_mesa_GetObjectParameterivAPPLE(GLenum objectType, GLuint name, GLenum pname, GLint* params);
#endif
@


1.1.1.3
log
@Import Mesa 9.2.0
@
text
@d3 1
d21 3
a23 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
d41 1
a41 1
static inline GLboolean
d52 1
a52 1
static inline GLboolean
d55 1
a55 1
   return obj != NULL && obj->Name != 0;
d73 1
a73 2
_mesa_initialize_buffer_object( struct gl_context *ctx,
				struct gl_buffer_object *obj,
a76 5
_mesa_reference_buffer_object_(struct gl_context *ctx,
                               struct gl_buffer_object **ptr,
                               struct gl_buffer_object *bufObj);

static inline void
d79 41
a119 5
                              struct gl_buffer_object *bufObj)
{
   if (*ptr != bufObj)
      _mesa_reference_buffer_object_(ctx, ptr, bufObj);
}
a120 2
extern GLuint
_mesa_total_buffer_object_memory(struct gl_context *ctx);
d130 31
a160 21
void GLAPIENTRY
_mesa_BindBuffer(GLenum target, GLuint buffer);
void GLAPIENTRY
_mesa_DeleteBuffers(GLsizei n, const GLuint * buffer);
void GLAPIENTRY
_mesa_GenBuffers(GLsizei n, GLuint * buffer);
GLboolean GLAPIENTRY
_mesa_IsBuffer(GLuint buffer);
void GLAPIENTRY
_mesa_BufferData(GLenum target, GLsizeiptrARB size, const GLvoid * data, GLenum usage);
void GLAPIENTRY
_mesa_BufferSubData(GLenum target, GLintptrARB offset, GLsizeiptrARB size, const GLvoid * data);
void GLAPIENTRY
_mesa_GetBufferSubData(GLenum target, GLintptrARB offset, GLsizeiptrARB size, void * data);
void * GLAPIENTRY
_mesa_MapBuffer(GLenum target, GLenum access);
GLboolean GLAPIENTRY
_mesa_UnmapBuffer(GLenum target);
void GLAPIENTRY
_mesa_GetBufferParameteriv(GLenum target, GLenum pname, GLint *params);
void GLAPIENTRY
d162 5
a166 3
void GLAPIENTRY
_mesa_GetBufferPointerv(GLenum target, GLenum pname, GLvoid **params);
void GLAPIENTRY
d170 2
a171 1
void * GLAPIENTRY
d174 2
a175 1
void GLAPIENTRY
d177 3
a179 1
GLenum GLAPIENTRY
d181 2
a182 1
GLenum GLAPIENTRY
a183 13
void GLAPIENTRY
_mesa_GetObjectParameterivAPPLE(GLenum objectType, GLuint name, GLenum pname,
                                GLint* params);
void GLAPIENTRY
_mesa_BindBufferRange(GLenum target, GLuint index,
                      GLuint buffer, GLintptr offset, GLsizeiptr size);
void GLAPIENTRY
_mesa_BindBufferBase(GLenum target, GLuint index, GLuint buffer);
void GLAPIENTRY
_mesa_InvalidateBufferSubData(GLuint buffer, GLintptr offset,
                              GLsizeiptr length);
void GLAPIENTRY
_mesa_InvalidateBufferData(GLuint buffer);
d185 3
@


1.1.1.4
log
@Import Mesa 10.2.3
@
text
@d31 1
a31 1
#include <stdbool.h>
d40 1
a40 9
/** Is the given buffer object currently mapped by the GL user? */
static inline GLboolean
_mesa_bufferobj_mapped(const struct gl_buffer_object *obj,
                       gl_map_buffer_index index)
{
   return obj->Mappings[index].Pointer != NULL;
}

/** Can we not use this buffer while mapped? */
d42 1
a42 1
_mesa_check_disallowed_mapping(const struct gl_buffer_object *obj)
d44 1
a44 3
   return _mesa_bufferobj_mapped(obj, MAP_USER) &&
          !(obj->Mappings[MAP_USER].AccessFlags &
            GL_MAP_PERSISTENT_BIT);
d60 1
a60 1
_mesa_init_buffer_objects(struct gl_context *ctx);
d63 1
a63 8
_mesa_free_buffer_objects(struct gl_context *ctx);

extern bool
_mesa_handle_bind_buffer_gen(struct gl_context *ctx,
                             GLenum target,
                             GLuint buffer,
                             struct gl_buffer_object **buf_handle,
                             const char *caller);
a71 14
extern struct gl_buffer_object *
_mesa_lookup_bufferobj_locked(struct gl_context *ctx, GLuint buffer);

extern void
_mesa_begin_bufferobj_lookups(struct gl_context *ctx);

extern void
_mesa_end_bufferobj_lookups(struct gl_context *ctx);

extern struct gl_buffer_object *
_mesa_multi_bind_lookup_bufferobj(struct gl_context *ctx,
                                  const GLuint *buffers,
                                  GLuint index, const char *caller);

d73 3
a75 3
_mesa_initialize_buffer_object(struct gl_context *ctx,
                               struct gl_buffer_object *obj,
                               GLuint name, GLenum target);
a96 10
extern void
_mesa_buffer_unmap_all_mappings(struct gl_context *ctx,
                                struct gl_buffer_object *bufObj);

extern void
_mesa_buffer_clear_subdata(struct gl_context *ctx,
                           GLintptr offset, GLsizeiptr size,
                           const GLvoid *clearValue,
                           GLsizeiptr clearValueSize,
                           struct gl_buffer_object *bufObj);
d101 1
a103 1

a105 1

a107 1

a109 1

d111 1
a111 3
_mesa_BufferStorage(GLenum target, GLsizeiptr size, const GLvoid *data,
                    GLbitfield flags);

d113 1
a113 3
_mesa_BufferData(GLenum target, GLsizeiptrARB size,
                 const GLvoid * data, GLenum usage);

d115 1
a115 18
_mesa_BufferSubData(GLenum target, GLintptrARB offset,
                    GLsizeiptrARB size, const GLvoid * data);

void GLAPIENTRY
_mesa_GetBufferSubData(GLenum target, GLintptrARB offset,
                       GLsizeiptrARB size, void * data);

void GLAPIENTRY
_mesa_ClearBufferData(GLenum target, GLenum internalformat,
                      GLenum format, GLenum type,
                      const GLvoid * data);

void GLAPIENTRY
_mesa_ClearBufferSubData(GLenum target, GLenum internalformat,
                         GLintptr offset, GLsizeiptr size,
                         GLenum format, GLenum type,
                         const GLvoid * data);

a117 1

a119 1

a121 1

a123 1

a125 1

a129 1

a132 1

d134 1
a134 3
_mesa_FlushMappedBufferRange(GLenum target,
                             GLintptr offset, GLsizeiptr length);

a136 1

a138 1

d140 2
a141 3
_mesa_GetObjectParameterivAPPLE(GLenum objectType, GLuint name,
                                GLenum pname, GLint* params);

a144 1

a146 8

void GLAPIENTRY
_mesa_BindBuffersRange(GLenum target, GLuint first, GLsizei count,
                       const GLuint *buffers,
                       const GLintptr *offsets, const GLsizeiptr *sizes);
void GLAPIENTRY
_mesa_BindBuffersBase(GLenum target, GLuint first, GLsizei count,
                      const GLuint *buffers);
a149 1

@


1.1.1.5
log
@Import Mesa 10.4.3
@
text
@d106 1
a106 1
                               GLuint name);
@


1.1.1.6
log
@Import Mesa 10.2.9
@
text
@d106 1
a106 1
                               GLuint name, GLenum target);
@


