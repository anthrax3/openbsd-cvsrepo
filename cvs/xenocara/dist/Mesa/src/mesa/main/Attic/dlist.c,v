head	1.13;
access;
symbols
	OPENBSD_5_8:1.12.0.4
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	v10_2_9:1.1.1.8
	v10_4_3:1.1.1.7
	v10_2_7:1.1.1.6
	OPENBSD_5_6:1.9.0.2
	OPENBSD_5_6_BASE:1.9
	v10_2_3:1.1.1.6
	OPENBSD_5_5:1.8.0.2
	OPENBSD_5_5_BASE:1.8
	v9_2_5:1.1.1.5
	v9_2_3:1.1.1.5
	v9_2_2:1.1.1.5
	v9_2_1:1.1.1.5
	v9_2_0:1.1.1.5
	OPENBSD_5_4:1.7.0.4
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.6.0.4
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.5.0.6
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.4
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_3:1.2.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2015.12.23.05.17.52;	author jsg;	state dead;
branches;
next	1.12;
commitid	TnlogFl9nOv2eaRf;

1.12
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.11;
commitid	4ry2gvZGMXkCUD2n;

1.11
date	2015.01.31.05.41.14;	author jsg;	state Exp;
branches;
next	1.10;
commitid	MrqvfysMyyM82lGg;

1.10
date	2015.01.25.14.41.21;	author jsg;	state Exp;
branches;
next	1.9;
commitid	mcxB0JvoI9gTDYXU;

1.9
date	2014.07.09.21.09.00;	author jsg;	state Exp;
branches;
next	1.8;
commitid	WPD6rgPryPkvXOr9;

1.8
date	2013.09.05.14.06.19;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2012.08.17.13.58.17;	author mpi;	state Exp;
branches;
next	1.6;

1.6
date	2011.10.23.13.37.42;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.05.22.20.06.30;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.05.17.20.26.41;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.14.58.20;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.02.12.21.09.27;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.49.54;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.49.54;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.56.34;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.30.57;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.45;	author matthieu;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.09.05.13.16.29;	author jsg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.07.09.20.34.59;	author jsg;	state Exp;
branches;
next	1.1.1.7;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.7
date	2015.01.25.14.12.33;	author jsg;	state Exp;
branches;
next	1.1.1.8;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.8
date	2015.02.20.22.49.40;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.13
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2008  Brian Paul   All Rights Reserved.
 * Copyright (C) 2009  VMware, Inc.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */


/**
 * \file dlist.c
 * Display lists management functions.
 */

#include "glheader.h"
#include "imports.h"
#include "api_arrayelt.h"
#include "api_exec.h"
#include "api_loopback.h"
#include "api_validate.h"
#include "atifragshader.h"
#include "config.h"
#include "bufferobj.h"
#include "arrayobj.h"
#include "context.h"
#include "dlist.h"
#include "enums.h"
#include "eval.h"
#include "fbobject.h"
#include "framebuffer.h"
#include "glapi/glapi.h"
#include "glformats.h"
#include "hash.h"
#include "image.h"
#include "light.h"
#include "macros.h"
#include "pack.h"
#include "pbo.h"
#include "queryobj.h"
#include "samplerobj.h"
#include "shaderapi.h"
#include "syncobj.h"
#include "teximage.h"
#include "texstorage.h"
#include "mtypes.h"
#include "varray.h"
#include "arbprogram.h"
#include "transformfeedback.h"

#include "math/m_matrix.h"

#include "main/dispatch.h"

#include "vbo/vbo.h"



/**
 * Other parts of Mesa (such as the VBO module) can plug into the display
 * list system.  This structure describes new display list instructions.
 */
struct gl_list_instruction
{
   GLuint Size;
   void (*Execute)( struct gl_context *ctx, void *data );
   void (*Destroy)( struct gl_context *ctx, void *data );
   void (*Print)( struct gl_context *ctx, void *data );
};


#define MAX_DLIST_EXT_OPCODES 16

/**
 * Used by device drivers to hook new commands into display lists.
 */
struct gl_list_extensions
{
   struct gl_list_instruction Opcode[MAX_DLIST_EXT_OPCODES];
   GLuint NumOpcodes;
};



/**
 * Flush vertices.
 *
 * \param ctx GL context.
 *
 * Checks if dd_function_table::SaveNeedFlush is marked to flush
 * stored (save) vertices, and calls
 * dd_function_table::SaveFlushVertices if so.
 */
#define SAVE_FLUSH_VERTICES(ctx)		\
do {						\
   if (ctx->Driver.SaveNeedFlush)		\
      ctx->Driver.SaveFlushVertices(ctx);	\
} while (0)


/**
 * Macro to assert that the API call was made outside the
 * glBegin()/glEnd() pair, with return value.
 * 
 * \param ctx GL context.
 * \param retval value to return value in case the assertion fails.
 */
#define ASSERT_OUTSIDE_SAVE_BEGIN_END_WITH_RETVAL(ctx, retval)		\
do {									\
   if (ctx->Driver.CurrentSavePrimitive <= PRIM_MAX) {			\
      _mesa_compile_error( ctx, GL_INVALID_OPERATION, "glBegin/End" );	\
      return retval;							\
   }									\
} while (0)

/**
 * Macro to assert that the API call was made outside the
 * glBegin()/glEnd() pair.
 * 
 * \param ctx GL context.
 */
#define ASSERT_OUTSIDE_SAVE_BEGIN_END(ctx)				\
do {									\
   if (ctx->Driver.CurrentSavePrimitive <= PRIM_MAX) {			\
      _mesa_compile_error( ctx, GL_INVALID_OPERATION, "glBegin/End" );	\
      return;								\
   }									\
} while (0)

/**
 * Macro to assert that the API call was made outside the
 * glBegin()/glEnd() pair and flush the vertices.
 * 
 * \param ctx GL context.
 */
#define ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx)			\
do {									\
   ASSERT_OUTSIDE_SAVE_BEGIN_END(ctx);					\
   SAVE_FLUSH_VERTICES(ctx);						\
} while (0)

/**
 * Macro to assert that the API call was made outside the
 * glBegin()/glEnd() pair and flush the vertices, with return value.
 * 
 * \param ctx GL context.
 * \param retval value to return value in case the assertion fails.
 */
#define ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH_WITH_RETVAL(ctx, retval)\
do {									\
   ASSERT_OUTSIDE_SAVE_BEGIN_END_WITH_RETVAL(ctx, retval);		\
   SAVE_FLUSH_VERTICES(ctx);						\
} while (0)



/**
 * Display list opcodes.
 *
 * The fact that these identifiers are assigned consecutive
 * integer values starting at 0 is very important, see InstSize array usage)
 */
typedef enum
{
   OPCODE_INVALID = -1,         /* Force signed enum */
   OPCODE_ACCUM,
   OPCODE_ALPHA_FUNC,
   OPCODE_BIND_TEXTURE,
   OPCODE_BITMAP,
   OPCODE_BLEND_COLOR,
   OPCODE_BLEND_EQUATION,
   OPCODE_BLEND_EQUATION_SEPARATE,
   OPCODE_BLEND_FUNC_SEPARATE,

   OPCODE_BLEND_EQUATION_I,
   OPCODE_BLEND_EQUATION_SEPARATE_I,
   OPCODE_BLEND_FUNC_I,
   OPCODE_BLEND_FUNC_SEPARATE_I,

   OPCODE_CALL_LIST,
   OPCODE_CALL_LIST_OFFSET,
   OPCODE_CLEAR,
   OPCODE_CLEAR_ACCUM,
   OPCODE_CLEAR_COLOR,
   OPCODE_CLEAR_DEPTH,
   OPCODE_CLEAR_INDEX,
   OPCODE_CLEAR_STENCIL,
   OPCODE_CLEAR_BUFFER_IV,
   OPCODE_CLEAR_BUFFER_UIV,
   OPCODE_CLEAR_BUFFER_FV,
   OPCODE_CLEAR_BUFFER_FI,
   OPCODE_CLIP_PLANE,
   OPCODE_COLOR_MASK,
   OPCODE_COLOR_MASK_INDEXED,
   OPCODE_COLOR_MATERIAL,
   OPCODE_COPY_PIXELS,
   OPCODE_COPY_TEX_IMAGE1D,
   OPCODE_COPY_TEX_IMAGE2D,
   OPCODE_COPY_TEX_SUB_IMAGE1D,
   OPCODE_COPY_TEX_SUB_IMAGE2D,
   OPCODE_COPY_TEX_SUB_IMAGE3D,
   OPCODE_CULL_FACE,
   OPCODE_DEPTH_FUNC,
   OPCODE_DEPTH_MASK,
   OPCODE_DEPTH_RANGE,
   OPCODE_DISABLE,
   OPCODE_DISABLE_INDEXED,
   OPCODE_DRAW_BUFFER,
   OPCODE_DRAW_PIXELS,
   OPCODE_ENABLE,
   OPCODE_ENABLE_INDEXED,
   OPCODE_EVALMESH1,
   OPCODE_EVALMESH2,
   OPCODE_FOG,
   OPCODE_FRONT_FACE,
   OPCODE_FRUSTUM,
   OPCODE_HINT,
   OPCODE_INDEX_MASK,
   OPCODE_INIT_NAMES,
   OPCODE_LIGHT,
   OPCODE_LIGHT_MODEL,
   OPCODE_LINE_STIPPLE,
   OPCODE_LINE_WIDTH,
   OPCODE_LIST_BASE,
   OPCODE_LOAD_IDENTITY,
   OPCODE_LOAD_MATRIX,
   OPCODE_LOAD_NAME,
   OPCODE_LOGIC_OP,
   OPCODE_MAP1,
   OPCODE_MAP2,
   OPCODE_MAPGRID1,
   OPCODE_MAPGRID2,
   OPCODE_MATRIX_MODE,
   OPCODE_MULT_MATRIX,
   OPCODE_ORTHO,
   OPCODE_PASSTHROUGH,
   OPCODE_PIXEL_MAP,
   OPCODE_PIXEL_TRANSFER,
   OPCODE_PIXEL_ZOOM,
   OPCODE_POINT_SIZE,
   OPCODE_POINT_PARAMETERS,
   OPCODE_POLYGON_MODE,
   OPCODE_POLYGON_STIPPLE,
   OPCODE_POLYGON_OFFSET,
   OPCODE_POP_ATTRIB,
   OPCODE_POP_MATRIX,
   OPCODE_POP_NAME,
   OPCODE_PRIORITIZE_TEXTURE,
   OPCODE_PUSH_ATTRIB,
   OPCODE_PUSH_MATRIX,
   OPCODE_PUSH_NAME,
   OPCODE_RASTER_POS,
   OPCODE_READ_BUFFER,
   OPCODE_ROTATE,
   OPCODE_SCALE,
   OPCODE_SCISSOR,
   OPCODE_SELECT_TEXTURE_SGIS,
   OPCODE_SELECT_TEXTURE_COORD_SET,
   OPCODE_SHADE_MODEL,
   OPCODE_STENCIL_FUNC,
   OPCODE_STENCIL_MASK,
   OPCODE_STENCIL_OP,
   OPCODE_TEXENV,
   OPCODE_TEXGEN,
   OPCODE_TEXPARAMETER,
   OPCODE_TEX_IMAGE1D,
   OPCODE_TEX_IMAGE2D,
   OPCODE_TEX_IMAGE3D,
   OPCODE_TEX_SUB_IMAGE1D,
   OPCODE_TEX_SUB_IMAGE2D,
   OPCODE_TEX_SUB_IMAGE3D,
   OPCODE_TRANSLATE,
   OPCODE_VIEWPORT,
   OPCODE_WINDOW_POS,
   /* GL_ARB_multitexture */
   OPCODE_ACTIVE_TEXTURE,
   /* GL_ARB_texture_compression */
   OPCODE_COMPRESSED_TEX_IMAGE_1D,
   OPCODE_COMPRESSED_TEX_IMAGE_2D,
   OPCODE_COMPRESSED_TEX_IMAGE_3D,
   OPCODE_COMPRESSED_TEX_SUB_IMAGE_1D,
   OPCODE_COMPRESSED_TEX_SUB_IMAGE_2D,
   OPCODE_COMPRESSED_TEX_SUB_IMAGE_3D,
   /* GL_ARB_multisample */
   OPCODE_SAMPLE_COVERAGE,
   /* GL_ARB_window_pos */
   OPCODE_WINDOW_POS_ARB,
   /* GL_NV_fragment_program */
   OPCODE_BIND_PROGRAM_NV,
   OPCODE_PROGRAM_LOCAL_PARAMETER_ARB,
   /* GL_EXT_stencil_two_side */
   OPCODE_ACTIVE_STENCIL_FACE_EXT,
   /* GL_EXT_depth_bounds_test */
   OPCODE_DEPTH_BOUNDS_EXT,
   /* GL_ARB_vertex/fragment_program */
   OPCODE_PROGRAM_STRING_ARB,
   OPCODE_PROGRAM_ENV_PARAMETER_ARB,
   /* GL_ARB_occlusion_query */
   OPCODE_BEGIN_QUERY_ARB,
   OPCODE_END_QUERY_ARB,
   /* GL_ARB_draw_buffers */
   OPCODE_DRAW_BUFFERS_ARB,
   /* GL_ATI_fragment_shader */
   OPCODE_TEX_BUMP_PARAMETER_ATI,
   /* GL_ATI_fragment_shader */
   OPCODE_BIND_FRAGMENT_SHADER_ATI,
   OPCODE_SET_FRAGMENT_SHADER_CONSTANTS_ATI,
   /* OpenGL 2.0 */
   OPCODE_STENCIL_FUNC_SEPARATE,
   OPCODE_STENCIL_OP_SEPARATE,
   OPCODE_STENCIL_MASK_SEPARATE,

   /* GL_ARB_shader_objects */
   OPCODE_USE_PROGRAM,
   OPCODE_UNIFORM_1F,
   OPCODE_UNIFORM_2F,
   OPCODE_UNIFORM_3F,
   OPCODE_UNIFORM_4F,
   OPCODE_UNIFORM_1FV,
   OPCODE_UNIFORM_2FV,
   OPCODE_UNIFORM_3FV,
   OPCODE_UNIFORM_4FV,
   OPCODE_UNIFORM_1I,
   OPCODE_UNIFORM_2I,
   OPCODE_UNIFORM_3I,
   OPCODE_UNIFORM_4I,
   OPCODE_UNIFORM_1IV,
   OPCODE_UNIFORM_2IV,
   OPCODE_UNIFORM_3IV,
   OPCODE_UNIFORM_4IV,
   OPCODE_UNIFORM_MATRIX22,
   OPCODE_UNIFORM_MATRIX33,
   OPCODE_UNIFORM_MATRIX44,
   OPCODE_UNIFORM_MATRIX23,
   OPCODE_UNIFORM_MATRIX32,
   OPCODE_UNIFORM_MATRIX24,
   OPCODE_UNIFORM_MATRIX42,
   OPCODE_UNIFORM_MATRIX34,
   OPCODE_UNIFORM_MATRIX43,

   /* OpenGL 3.0 */
   OPCODE_UNIFORM_1UI,
   OPCODE_UNIFORM_2UI,
   OPCODE_UNIFORM_3UI,
   OPCODE_UNIFORM_4UI,
   OPCODE_UNIFORM_1UIV,
   OPCODE_UNIFORM_2UIV,
   OPCODE_UNIFORM_3UIV,
   OPCODE_UNIFORM_4UIV,

   /* OpenGL 4.2 / GL_ARB_separate_shader_objects */
   OPCODE_USE_PROGRAM_STAGES,
   OPCODE_PROGRAM_UNIFORM_1F,
   OPCODE_PROGRAM_UNIFORM_2F,
   OPCODE_PROGRAM_UNIFORM_3F,
   OPCODE_PROGRAM_UNIFORM_4F,
   OPCODE_PROGRAM_UNIFORM_1FV,
   OPCODE_PROGRAM_UNIFORM_2FV,
   OPCODE_PROGRAM_UNIFORM_3FV,
   OPCODE_PROGRAM_UNIFORM_4FV,
   OPCODE_PROGRAM_UNIFORM_1I,
   OPCODE_PROGRAM_UNIFORM_2I,
   OPCODE_PROGRAM_UNIFORM_3I,
   OPCODE_PROGRAM_UNIFORM_4I,
   OPCODE_PROGRAM_UNIFORM_1IV,
   OPCODE_PROGRAM_UNIFORM_2IV,
   OPCODE_PROGRAM_UNIFORM_3IV,
   OPCODE_PROGRAM_UNIFORM_4IV,
   OPCODE_PROGRAM_UNIFORM_1UI,
   OPCODE_PROGRAM_UNIFORM_2UI,
   OPCODE_PROGRAM_UNIFORM_3UI,
   OPCODE_PROGRAM_UNIFORM_4UI,
   OPCODE_PROGRAM_UNIFORM_1UIV,
   OPCODE_PROGRAM_UNIFORM_2UIV,
   OPCODE_PROGRAM_UNIFORM_3UIV,
   OPCODE_PROGRAM_UNIFORM_4UIV,
   OPCODE_PROGRAM_UNIFORM_MATRIX22F,
   OPCODE_PROGRAM_UNIFORM_MATRIX33F,
   OPCODE_PROGRAM_UNIFORM_MATRIX44F,
   OPCODE_PROGRAM_UNIFORM_MATRIX23F,
   OPCODE_PROGRAM_UNIFORM_MATRIX32F,
   OPCODE_PROGRAM_UNIFORM_MATRIX24F,
   OPCODE_PROGRAM_UNIFORM_MATRIX42F,
   OPCODE_PROGRAM_UNIFORM_MATRIX34F,
   OPCODE_PROGRAM_UNIFORM_MATRIX43F,

   /* GL_ARB_color_buffer_float */
   OPCODE_CLAMP_COLOR,

   /* GL_EXT_framebuffer_blit */
   OPCODE_BLIT_FRAMEBUFFER,

   /* Vertex attributes -- fallback for when optimized display
    * list build isn't active.
    */
   OPCODE_ATTR_1F_NV,
   OPCODE_ATTR_2F_NV,
   OPCODE_ATTR_3F_NV,
   OPCODE_ATTR_4F_NV,
   OPCODE_ATTR_1F_ARB,
   OPCODE_ATTR_2F_ARB,
   OPCODE_ATTR_3F_ARB,
   OPCODE_ATTR_4F_ARB,
   OPCODE_MATERIAL,
   OPCODE_BEGIN,
   OPCODE_END,
   OPCODE_RECTF,
   OPCODE_EVAL_C1,
   OPCODE_EVAL_C2,
   OPCODE_EVAL_P1,
   OPCODE_EVAL_P2,

   /* GL_EXT_provoking_vertex */
   OPCODE_PROVOKING_VERTEX,

   /* GL_EXT_transform_feedback */
   OPCODE_BEGIN_TRANSFORM_FEEDBACK,
   OPCODE_END_TRANSFORM_FEEDBACK,
   OPCODE_BIND_TRANSFORM_FEEDBACK,
   OPCODE_PAUSE_TRANSFORM_FEEDBACK,
   OPCODE_RESUME_TRANSFORM_FEEDBACK,
   OPCODE_DRAW_TRANSFORM_FEEDBACK,

   /* GL_EXT_texture_integer */
   OPCODE_CLEARCOLOR_I,
   OPCODE_CLEARCOLOR_UI,
   OPCODE_TEXPARAMETER_I,
   OPCODE_TEXPARAMETER_UI,

   /* GL_ARB_instanced_arrays */
   OPCODE_VERTEX_ATTRIB_DIVISOR,

   /* GL_NV_texture_barrier */
   OPCODE_TEXTURE_BARRIER_NV,

   /* GL_ARB_sampler_object */
   OPCODE_BIND_SAMPLER,
   OPCODE_SAMPLER_PARAMETERIV,
   OPCODE_SAMPLER_PARAMETERFV,
   OPCODE_SAMPLER_PARAMETERIIV,
   OPCODE_SAMPLER_PARAMETERUIV,

   /* GL_ARB_geometry_shader4 */
   OPCODE_PROGRAM_PARAMETERI,
   OPCODE_FRAMEBUFFER_TEXTURE,
   OPCODE_FRAMEBUFFER_TEXTURE_FACE,

   /* GL_ARB_sync */
   OPCODE_WAIT_SYNC,

   /* GL_NV_conditional_render */
   OPCODE_BEGIN_CONDITIONAL_RENDER,
   OPCODE_END_CONDITIONAL_RENDER,

   /* ARB_timer_query */
   OPCODE_QUERY_COUNTER,

   /* ARB_transform_feedback3 */
   OPCODE_BEGIN_QUERY_INDEXED,
   OPCODE_END_QUERY_INDEXED,
   OPCODE_DRAW_TRANSFORM_FEEDBACK_STREAM,

   /* ARB_transform_feedback_instanced */
   OPCODE_DRAW_TRANSFORM_FEEDBACK_INSTANCED,
   OPCODE_DRAW_TRANSFORM_FEEDBACK_STREAM_INSTANCED,

   /* ARB_uniform_buffer_object */
   OPCODE_UNIFORM_BLOCK_BINDING,

   /* The following three are meta instructions */
   OPCODE_ERROR,                /* raise compiled-in error */
   OPCODE_CONTINUE,
   OPCODE_NOP,                  /* No-op (used for 8-byte alignment */
   OPCODE_END_OF_LIST,
   OPCODE_EXT_0
} OpCode;



/**
 * Display list node.
 *
 * Display list instructions are stored as sequences of "nodes".  Nodes
 * are allocated in blocks.  Each block has BLOCK_SIZE nodes.  Blocks
 * are linked together with a pointer.
 *
 * Each instruction in the display list is stored as a sequence of
 * contiguous nodes in memory.
 * Each node is the union of a variety of data types.
 *
 * Note, all of these members should be 4 bytes in size or less for the
 * sake of compact display lists.  We store 8-byte pointers in a pair of
 * these nodes using the save/get_pointer() functions below.
 */
union gl_dlist_node
{
   OpCode opcode;
   GLboolean b;
   GLbitfield bf;
   GLubyte ub;
   GLshort s;
   GLushort us;
   GLint i;
   GLuint ui;
   GLenum e;
   GLfloat f;
   GLsizei si;
};


typedef union gl_dlist_node Node;


/** How many 4-byte dwords to store a pointer */
#define POINTER_DWORDS (sizeof(void *) / 4)

/* We want to keep sizeof(union gl_dlist_node) == 4 to minimize
 * space for display lists.  The following types and functions are
 * used to help store 4- and 8-byte pointers in 1 or 2 dlist_nodes.
 */
union pointer
{
   void *ptr;
   GLuint dwords[POINTER_DWORDS];
};


/**
 * Save a 4 or 8-byte pointer at dest (and dest+1).
 */
static inline void
save_pointer(union gl_dlist_node *dest, void *src)
{
   union pointer p;
   unsigned i;

   STATIC_ASSERT(POINTER_DWORDS == 1 || POINTER_DWORDS == 2);
   STATIC_ASSERT(sizeof(union gl_dlist_node) == 4);

   p.ptr = src;

   for (i = 0; i < POINTER_DWORDS; i++)
      dest[i].ui = p.dwords[i];
}


/**
 * Retrieve a 4 or 8-byte pointer from node (node+1).
 */
static inline void *
get_pointer(const union gl_dlist_node *node)
{
   union pointer p;
   unsigned i;

   for (i = 0; i < POINTER_DWORDS; i++)
      p.dwords[i] = node[i].ui;

   return p.ptr;
}


/**
 * Used to store a 64-bit uint in a pair of "Nodes" for the sake of 32-bit
 * environment.  In 64-bit env, sizeof(Node)==8 anyway.
 */
union uint64_pair
{
   GLuint64 uint64;
   GLuint uint32[2];
};


/**
 * How many nodes to allocate at a time.  Note that bulk vertex data
 * from glBegin/glVertex/glEnd primitives will typically wind up in
 * a VBO, and not directly in the display list itself.
 */
#define BLOCK_SIZE 256



/**
 * Number of nodes of storage needed for each instruction.
 * Sizes for dynamically allocated opcodes are stored in the context struct.
 */
static GLuint InstSize[OPCODE_END_OF_LIST + 1];


void mesa_print_display_list(GLuint list);


/**
 * Allocate a gl_display_list object with an initial block of storage.
 * \param count  how many display list nodes/tokes to allocate
 */
static struct gl_display_list *
make_list(GLuint name, GLuint count)
{
   struct gl_display_list *dlist = CALLOC_STRUCT(gl_display_list);
   dlist->Name = name;
   dlist->Head = malloc(sizeof(Node) * count);
   dlist->Head[0].opcode = OPCODE_END_OF_LIST;
   return dlist;
}


/**
 * Lookup function to just encapsulate casting.
 */
struct gl_display_list *
_mesa_lookup_list(struct gl_context *ctx, GLuint list)
{
   return (struct gl_display_list *)
      _mesa_HashLookup(ctx->Shared->DisplayList, list);
}


/** Is the given opcode an extension code? */
static inline GLboolean
is_ext_opcode(OpCode opcode)
{
   return (opcode >= OPCODE_EXT_0);
}


/** Destroy an extended opcode instruction */
static GLint
ext_opcode_destroy(struct gl_context *ctx, Node *node)
{
   const GLint i = node[0].opcode - OPCODE_EXT_0;
   GLint step;
   ctx->ListExt->Opcode[i].Destroy(ctx, &node[1]);
   step = ctx->ListExt->Opcode[i].Size;
   return step;
}


/** Execute an extended opcode instruction */
static GLint
ext_opcode_execute(struct gl_context *ctx, Node *node)
{
   const GLint i = node[0].opcode - OPCODE_EXT_0;
   GLint step;
   ctx->ListExt->Opcode[i].Execute(ctx, &node[1]);
   step = ctx->ListExt->Opcode[i].Size;
   return step;
}


/** Print an extended opcode instruction */
static GLint
ext_opcode_print(struct gl_context *ctx, Node *node)
{
   const GLint i = node[0].opcode - OPCODE_EXT_0;
   GLint step;
   ctx->ListExt->Opcode[i].Print(ctx, &node[1]);
   step = ctx->ListExt->Opcode[i].Size;
   return step;
}


/**
 * Delete the named display list, but don't remove from hash table.
 * \param dlist - display list pointer
 */
void
_mesa_delete_list(struct gl_context *ctx, struct gl_display_list *dlist)
{
   Node *n, *block;
   GLboolean done;

   n = block = dlist->Head;

   done = block ? GL_FALSE : GL_TRUE;
   while (!done) {
      const OpCode opcode = n[0].opcode;

      /* check for extension opcodes first */
      if (is_ext_opcode(opcode)) {
         n += ext_opcode_destroy(ctx, n);
      }
      else {
         switch (opcode) {
            /* for some commands, we need to free malloc'd memory */
         case OPCODE_MAP1:
            free(get_pointer(&n[6]));
            n += InstSize[n[0].opcode];
            break;
         case OPCODE_MAP2:
            free(get_pointer(&n[10]));
            n += InstSize[n[0].opcode];
            break;
         case OPCODE_DRAW_PIXELS:
            free(get_pointer(&n[5]));
            n += InstSize[n[0].opcode];
            break;
         case OPCODE_BITMAP:
            free(get_pointer(&n[7]));
            n += InstSize[n[0].opcode];
            break;
         case OPCODE_POLYGON_STIPPLE:
            free(get_pointer(&n[1]));
            n += InstSize[n[0].opcode];
            break;
         case OPCODE_TEX_IMAGE1D:
            free(get_pointer(&n[8]));
            n += InstSize[n[0].opcode];
            break;
         case OPCODE_TEX_IMAGE2D:
            free(get_pointer(&n[9]));
            n += InstSize[n[0].opcode];
            break;
         case OPCODE_TEX_IMAGE3D:
            free(get_pointer(&n[10]));
            n += InstSize[n[0].opcode];
            break;
         case OPCODE_TEX_SUB_IMAGE1D:
            free(get_pointer(&n[7]));
            n += InstSize[n[0].opcode];
            break;
         case OPCODE_TEX_SUB_IMAGE2D:
            free(get_pointer(&n[9]));
            n += InstSize[n[0].opcode];
            break;
         case OPCODE_TEX_SUB_IMAGE3D:
            free(get_pointer(&n[11]));
            n += InstSize[n[0].opcode];
            break;
         case OPCODE_COMPRESSED_TEX_IMAGE_1D:
            free(get_pointer(&n[7]));
            n += InstSize[n[0].opcode];
            break;
         case OPCODE_COMPRESSED_TEX_IMAGE_2D:
            free(get_pointer(&n[8]));
            n += InstSize[n[0].opcode];
            break;
         case OPCODE_COMPRESSED_TEX_IMAGE_3D:
            free(get_pointer(&n[9]));
            n += InstSize[n[0].opcode];
            break;
         case OPCODE_COMPRESSED_TEX_SUB_IMAGE_1D:
            free(get_pointer(&n[7]));
            n += InstSize[n[0].opcode];
            break;
         case OPCODE_COMPRESSED_TEX_SUB_IMAGE_2D:
            free(get_pointer(&n[9]));
            n += InstSize[n[0].opcode];
            break;
         case OPCODE_COMPRESSED_TEX_SUB_IMAGE_3D:
            free(get_pointer(&n[11]));
            n += InstSize[n[0].opcode];
            break;
         case OPCODE_PROGRAM_STRING_ARB:
            free(get_pointer(&n[4]));      /* program string */
            n += InstSize[n[0].opcode];
            break;
         case OPCODE_UNIFORM_1FV:
         case OPCODE_UNIFORM_2FV:
         case OPCODE_UNIFORM_3FV:
         case OPCODE_UNIFORM_4FV:
         case OPCODE_UNIFORM_1IV:
         case OPCODE_UNIFORM_2IV:
         case OPCODE_UNIFORM_3IV:
         case OPCODE_UNIFORM_4IV:
         case OPCODE_UNIFORM_1UIV:
         case OPCODE_UNIFORM_2UIV:
         case OPCODE_UNIFORM_3UIV:
         case OPCODE_UNIFORM_4UIV:
            free(get_pointer(&n[3]));
            n += InstSize[n[0].opcode];
            break;
         case OPCODE_UNIFORM_MATRIX22:
         case OPCODE_UNIFORM_MATRIX33:
         case OPCODE_UNIFORM_MATRIX44:
         case OPCODE_UNIFORM_MATRIX24:
         case OPCODE_UNIFORM_MATRIX42:
         case OPCODE_UNIFORM_MATRIX23:
         case OPCODE_UNIFORM_MATRIX32:
         case OPCODE_UNIFORM_MATRIX34:
         case OPCODE_UNIFORM_MATRIX43:
            free(get_pointer(&n[4]));
            n += InstSize[n[0].opcode];
            break;
         case OPCODE_PROGRAM_UNIFORM_1FV:
         case OPCODE_PROGRAM_UNIFORM_2FV:
         case OPCODE_PROGRAM_UNIFORM_3FV:
         case OPCODE_PROGRAM_UNIFORM_4FV:
         case OPCODE_PROGRAM_UNIFORM_1IV:
         case OPCODE_PROGRAM_UNIFORM_2IV:
         case OPCODE_PROGRAM_UNIFORM_3IV:
         case OPCODE_PROGRAM_UNIFORM_4IV:
         case OPCODE_PROGRAM_UNIFORM_1UIV:
         case OPCODE_PROGRAM_UNIFORM_2UIV:
         case OPCODE_PROGRAM_UNIFORM_3UIV:
         case OPCODE_PROGRAM_UNIFORM_4UIV:
            free(get_pointer(&n[4]));
            n += InstSize[n[0].opcode];
            break;
         case OPCODE_PROGRAM_UNIFORM_MATRIX22F:
         case OPCODE_PROGRAM_UNIFORM_MATRIX33F:
         case OPCODE_PROGRAM_UNIFORM_MATRIX44F:
         case OPCODE_PROGRAM_UNIFORM_MATRIX24F:
         case OPCODE_PROGRAM_UNIFORM_MATRIX42F:
         case OPCODE_PROGRAM_UNIFORM_MATRIX23F:
         case OPCODE_PROGRAM_UNIFORM_MATRIX32F:
         case OPCODE_PROGRAM_UNIFORM_MATRIX34F:
         case OPCODE_PROGRAM_UNIFORM_MATRIX43F:
            free(get_pointer(&n[5]));
            n += InstSize[n[0].opcode];
            break;
         case OPCODE_PIXEL_MAP:
            free(get_pointer(&n[3]));
            n += InstSize[n[0].opcode];
            break;

         case OPCODE_CONTINUE:
            n = (Node *) get_pointer(&n[1]);
            free(block);
            block = n;
            break;
         case OPCODE_END_OF_LIST:
            free(block);
            done = GL_TRUE;
            break;
         default:
            /* Most frequent case */
            n += InstSize[n[0].opcode];
            break;
         }
      }
   }

   free(dlist->Label);
   free(dlist);
}


/**
 * Destroy a display list and remove from hash table.
 * \param list - display list number
 */
static void
destroy_list(struct gl_context *ctx, GLuint list)
{
   struct gl_display_list *dlist;

   if (list == 0)
      return;

   dlist = _mesa_lookup_list(ctx, list);
   if (!dlist)
      return;

   _mesa_delete_list(ctx, dlist);
   _mesa_HashRemove(ctx->Shared->DisplayList, list);
}


/*
 * Translate the nth element of list from <type> to GLint.
 */
static GLint
translate_id(GLsizei n, GLenum type, const GLvoid * list)
{
   GLbyte *bptr;
   GLubyte *ubptr;
   GLshort *sptr;
   GLushort *usptr;
   GLint *iptr;
   GLuint *uiptr;
   GLfloat *fptr;

   switch (type) {
   case GL_BYTE:
      bptr = (GLbyte *) list;
      return (GLint) bptr[n];
   case GL_UNSIGNED_BYTE:
      ubptr = (GLubyte *) list;
      return (GLint) ubptr[n];
   case GL_SHORT:
      sptr = (GLshort *) list;
      return (GLint) sptr[n];
   case GL_UNSIGNED_SHORT:
      usptr = (GLushort *) list;
      return (GLint) usptr[n];
   case GL_INT:
      iptr = (GLint *) list;
      return iptr[n];
   case GL_UNSIGNED_INT:
      uiptr = (GLuint *) list;
      return (GLint) uiptr[n];
   case GL_FLOAT:
      fptr = (GLfloat *) list;
      return (GLint) FLOORF(fptr[n]);
   case GL_2_BYTES:
      ubptr = ((GLubyte *) list) + 2 * n;
      return (GLint) ubptr[0] * 256
           + (GLint) ubptr[1];
   case GL_3_BYTES:
      ubptr = ((GLubyte *) list) + 3 * n;
      return (GLint) ubptr[0] * 65536
           + (GLint) ubptr[1] * 256
           + (GLint) ubptr[2];
   case GL_4_BYTES:
      ubptr = ((GLubyte *) list) + 4 * n;
      return (GLint) ubptr[0] * 16777216
           + (GLint) ubptr[1] * 65536
           + (GLint) ubptr[2] * 256
           + (GLint) ubptr[3];
   default:
      return 0;
   }
}


/**
 * Wrapper for _mesa_unpack_image/bitmap() that handles pixel buffer objects.
 * If width < 0 or height < 0 or format or type are invalid we'll just
 * return NULL.  We will not generate an error since OpenGL command
 * arguments aren't error-checked until the command is actually executed
 * (not when they're compiled).
 * But if we run out of memory, GL_OUT_OF_MEMORY will be recorded.
 */
static GLvoid *
unpack_image(struct gl_context *ctx, GLuint dimensions,
             GLsizei width, GLsizei height, GLsizei depth,
             GLenum format, GLenum type, const GLvoid * pixels,
             const struct gl_pixelstore_attrib *unpack)
{
   if (width <= 0 || height <= 0) {
      return NULL;
   }

   if (_mesa_bytes_per_pixel(format, type) < 0) {
      /* bad format and/or type */
      return NULL;
   }

   if (!_mesa_is_bufferobj(unpack->BufferObj)) {
      /* no PBO */
      GLvoid *image;

      if (type == GL_BITMAP)
         image = _mesa_unpack_bitmap(width, height, pixels, unpack);
      else
         image = _mesa_unpack_image(dimensions, width, height, depth,
                                    format, type, pixels, unpack);
      if (pixels && !image) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "display list construction");
      }
      return image;
   }
   else if (_mesa_validate_pbo_access(dimensions, unpack, width, height,
                                      depth, format, type, INT_MAX, pixels)) {
      const GLubyte *map, *src;
      GLvoid *image;

      map = (GLubyte *)
         ctx->Driver.MapBufferRange(ctx, 0, unpack->BufferObj->Size,
				    GL_MAP_READ_BIT, unpack->BufferObj,
                                    MAP_INTERNAL);
      if (!map) {
         /* unable to map src buffer! */
         _mesa_error(ctx, GL_INVALID_OPERATION, "unable to map PBO");
         return NULL;
      }

      src = ADD_POINTERS(map, pixels);
      if (type == GL_BITMAP)
         image = _mesa_unpack_bitmap(width, height, src, unpack);
      else
         image = _mesa_unpack_image(dimensions, width, height, depth,
                                    format, type, src, unpack);

      ctx->Driver.UnmapBuffer(ctx, unpack->BufferObj, MAP_INTERNAL);

      if (!image) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "display list construction");
      }
      return image;
   }

   /* bad access! */
   _mesa_error(ctx, GL_INVALID_OPERATION, "invalid PBO access");
   return NULL;
}


/** Return copy of memory */
static void *
memdup(const void *src, GLsizei bytes)
{
   void *b = bytes >= 0 ? malloc(bytes) : NULL;
   if (b)
      memcpy(b, src, bytes);
   return b;
}


/**
 * Allocate space for a display list instruction (opcode + payload space).
 * \param opcode  the instruction opcode (OPCODE_* value)
 * \param bytes   instruction payload size (not counting opcode)
 * \param align8  does the payload need to be 8-byte aligned?
 *                This is only relevant in 64-bit environments.
 * \return pointer to allocated memory (the payload will be at pointer+1)
 */
static Node *
dlist_alloc(struct gl_context *ctx, OpCode opcode, GLuint bytes, bool align8)
{
   const GLuint numNodes = 1 + (bytes + sizeof(Node) - 1) / sizeof(Node);
   const GLuint contNodes = 1 + POINTER_DWORDS;  /* size of continue info */
   GLuint nopNode;
   Node *n;

   if (opcode < (GLuint) OPCODE_EXT_0) {
      if (InstSize[opcode] == 0) {
         /* save instruction size now */
         InstSize[opcode] = numNodes;
      }
      else {
         /* make sure instruction size agrees */
         ASSERT(numNodes == InstSize[opcode]);
      }
   }

   if (sizeof(void *) > sizeof(Node) && align8
       && ctx->ListState.CurrentPos % 2 == 0) {
      /* The opcode would get placed at node[0] and the payload would start
       * at node[1].  But the payload needs to be at an even offset (8-byte
       * multiple).
       */
      nopNode = 1;
   }
   else {
      nopNode = 0;
   }

   if (ctx->ListState.CurrentPos + nopNode + numNodes + contNodes
       > BLOCK_SIZE) {
      /* This block is full.  Allocate a new block and chain to it */
      Node *newblock;
      n = ctx->ListState.CurrentBlock + ctx->ListState.CurrentPos;
      n[0].opcode = OPCODE_CONTINUE;
      newblock = malloc(sizeof(Node) * BLOCK_SIZE);
      if (!newblock) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "Building display list");
         return NULL;
      }

      /* a fresh block should be 8-byte aligned on 64-bit systems */
      assert(((GLintptr) newblock) % sizeof(void *) == 0);

      save_pointer(&n[1], newblock);
      ctx->ListState.CurrentBlock = newblock;
      ctx->ListState.CurrentPos = 0;

      /* Display list nodes are always 4 bytes.  If we need 8-byte alignment
       * we have to insert a NOP so that the payload of the real opcode lands
       * on an even location:
       *   node[0] = OPCODE_NOP
       *   node[1] = OPCODE_x;
       *   node[2] = start of payload
       */
      nopNode = sizeof(void *) > sizeof(Node) && align8;
   }

   n = ctx->ListState.CurrentBlock + ctx->ListState.CurrentPos;
   if (nopNode) {
      assert(ctx->ListState.CurrentPos % 2 == 0); /* even value */
      n[0].opcode = OPCODE_NOP;
      n++;
      /* The "real" opcode will now be at an odd location and the payload
       * will be at an even location.
       */
   }
   ctx->ListState.CurrentPos += nopNode + numNodes;

   n[0].opcode = opcode;

   return n;
}



/**
 * Allocate space for a display list instruction.  Used by callers outside
 * this file for things like VBO vertex data.
 *
 * \param opcode  the instruction opcode (OPCODE_* value)
 * \param bytes   instruction size in bytes, not counting opcode.
 * \return pointer to the usable data area (not including the internal
 *         opcode).
 */
void *
_mesa_dlist_alloc(struct gl_context *ctx, GLuint opcode, GLuint bytes)
{
   Node *n = dlist_alloc(ctx, (OpCode) opcode, bytes, false);
   if (n)
      return n + 1;  /* return pointer to payload area, after opcode */
   else
      return NULL;
}


/**
 * Same as _mesa_dlist_alloc(), but return a pointer which is 8-byte
 * aligned in 64-bit environments, 4-byte aligned otherwise.
 */
void *
_mesa_dlist_alloc_aligned(struct gl_context *ctx, GLuint opcode, GLuint bytes)
{
   Node *n = dlist_alloc(ctx, (OpCode) opcode, bytes, true);
   if (n)
      return n + 1;  /* return pointer to payload area, after opcode */
   else
      return NULL;
}


/**
 * This function allows modules and drivers to get their own opcodes
 * for extending display list functionality.
 * \param ctx  the rendering context
 * \param size  number of bytes for storing the new display list command
 * \param execute  function to execute the new display list command
 * \param destroy  function to destroy the new display list command
 * \param print  function to print the new display list command
 * \return  the new opcode number or -1 if error
 */
GLint
_mesa_dlist_alloc_opcode(struct gl_context *ctx,
                         GLuint size,
                         void (*execute) (struct gl_context *, void *),
                         void (*destroy) (struct gl_context *, void *),
                         void (*print) (struct gl_context *, void *))
{
   if (ctx->ListExt->NumOpcodes < MAX_DLIST_EXT_OPCODES) {
      const GLuint i = ctx->ListExt->NumOpcodes++;
      ctx->ListExt->Opcode[i].Size =
         1 + (size + sizeof(Node) - 1) / sizeof(Node);
      ctx->ListExt->Opcode[i].Execute = execute;
      ctx->ListExt->Opcode[i].Destroy = destroy;
      ctx->ListExt->Opcode[i].Print = print;
      return i + OPCODE_EXT_0;
   }
   return -1;
}


/**
 * Allocate space for a display list instruction.  The space is basically
 * an array of Nodes where node[0] holds the opcode, node[1] is the first
 * function parameter, node[2] is the second parameter, etc.
 *
 * \param opcode  one of OPCODE_x
 * \param nparams  number of function parameters
 * \return  pointer to start of instruction space
 */
static inline Node *
alloc_instruction(struct gl_context *ctx, OpCode opcode, GLuint nparams)
{
   return dlist_alloc(ctx, opcode, nparams * sizeof(Node), false);
}


/**
 * Called by EndList to try to reduce memory used for the list.
 */
static void
trim_list(struct gl_context *ctx)
{
   /* If the list we're ending only has one allocated block of nodes/tokens
    * and its size isn't a full block size, realloc the block to use less
    * memory.  This is important for apps that create many small display
    * lists and apps that use glXUseXFont (many lists each containing one
    * glBitmap call).
    * Note: we currently only trim display lists that allocated one block
    * of tokens.  That hits the short list case which is what we're mainly
    * concerned with.  Trimming longer lists would involve traversing the
    * linked list of blocks.
    */
   struct gl_dlist_state *list = &ctx->ListState;

   if ((list->CurrentList->Head == list->CurrentBlock) &&
       (list->CurrentPos < BLOCK_SIZE)) {
      /* There's only one block and it's not full, so realloc */
      GLuint newSize = list->CurrentPos * sizeof(Node);
      list->CurrentList->Head =
      list->CurrentBlock = realloc(list->CurrentBlock, newSize);
      if (!list->CurrentBlock) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glEndList");
      }
   }
}



/*
 * Display List compilation functions
 */
static void GLAPIENTRY
save_Accum(GLenum op, GLfloat value)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_ACCUM, 2);
   if (n) {
      n[1].e = op;
      n[2].f = value;
   }
   if (ctx->ExecuteFlag) {
      CALL_Accum(ctx->Exec, (op, value));
   }
}


static void GLAPIENTRY
save_AlphaFunc(GLenum func, GLclampf ref)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_ALPHA_FUNC, 2);
   if (n) {
      n[1].e = func;
      n[2].f = (GLfloat) ref;
   }
   if (ctx->ExecuteFlag) {
      CALL_AlphaFunc(ctx->Exec, (func, ref));
   }
}


static void GLAPIENTRY
save_BindTexture(GLenum target, GLuint texture)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_BIND_TEXTURE, 2);
   if (n) {
      n[1].e = target;
      n[2].ui = texture;
   }
   if (ctx->ExecuteFlag) {
      CALL_BindTexture(ctx->Exec, (target, texture));
   }
}


static void GLAPIENTRY
save_Bitmap(GLsizei width, GLsizei height,
            GLfloat xorig, GLfloat yorig,
            GLfloat xmove, GLfloat ymove, const GLubyte * pixels)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_BITMAP, 6 + POINTER_DWORDS);
   if (n) {
      n[1].i = (GLint) width;
      n[2].i = (GLint) height;
      n[3].f = xorig;
      n[4].f = yorig;
      n[5].f = xmove;
      n[6].f = ymove;
      save_pointer(&n[7],
                   unpack_image(ctx, 2, width, height, 1, GL_COLOR_INDEX,
                                GL_BITMAP, pixels, &ctx->Unpack));
   }
   if (ctx->ExecuteFlag) {
      CALL_Bitmap(ctx->Exec, (width, height,
                              xorig, yorig, xmove, ymove, pixels));
   }
}


static void GLAPIENTRY
save_BlendEquation(GLenum mode)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_BLEND_EQUATION, 1);
   if (n) {
      n[1].e = mode;
   }
   if (ctx->ExecuteFlag) {
      CALL_BlendEquation(ctx->Exec, (mode));
   }
}


static void GLAPIENTRY
save_BlendEquationSeparateEXT(GLenum modeRGB, GLenum modeA)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_BLEND_EQUATION_SEPARATE, 2);
   if (n) {
      n[1].e = modeRGB;
      n[2].e = modeA;
   }
   if (ctx->ExecuteFlag) {
      CALL_BlendEquationSeparate(ctx->Exec, (modeRGB, modeA));
   }
}


static void GLAPIENTRY
save_BlendFuncSeparateEXT(GLenum sfactorRGB, GLenum dfactorRGB,
                          GLenum sfactorA, GLenum dfactorA)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_BLEND_FUNC_SEPARATE, 4);
   if (n) {
      n[1].e = sfactorRGB;
      n[2].e = dfactorRGB;
      n[3].e = sfactorA;
      n[4].e = dfactorA;
   }
   if (ctx->ExecuteFlag) {
      CALL_BlendFuncSeparate(ctx->Exec,
                                (sfactorRGB, dfactorRGB, sfactorA, dfactorA));
   }
}


static void GLAPIENTRY
save_BlendFunc(GLenum srcfactor, GLenum dstfactor)
{
   save_BlendFuncSeparateEXT(srcfactor, dstfactor, srcfactor, dstfactor);
}


static void GLAPIENTRY
save_BlendColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_BLEND_COLOR, 4);
   if (n) {
      n[1].f = red;
      n[2].f = green;
      n[3].f = blue;
      n[4].f = alpha;
   }
   if (ctx->ExecuteFlag) {
      CALL_BlendColor(ctx->Exec, (red, green, blue, alpha));
   }
}

/* GL_ARB_draw_buffers_blend */
static void GLAPIENTRY
save_BlendFuncSeparatei(GLuint buf, GLenum sfactorRGB, GLenum dfactorRGB,
                        GLenum sfactorA, GLenum dfactorA)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_BLEND_FUNC_SEPARATE_I, 5);
   if (n) {
      n[1].ui = buf;
      n[2].e = sfactorRGB;
      n[3].e = dfactorRGB;
      n[4].e = sfactorA;
      n[5].e = dfactorA;
   }
   if (ctx->ExecuteFlag) {
      CALL_BlendFuncSeparateiARB(ctx->Exec, (buf, sfactorRGB, dfactorRGB,
                                             sfactorA, dfactorA));
   }
}

/* GL_ARB_draw_buffers_blend */
static void GLAPIENTRY
save_BlendFunci(GLuint buf, GLenum sfactor, GLenum dfactor)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_BLEND_FUNC_SEPARATE_I, 3);
   if (n) {
      n[1].ui = buf;
      n[2].e = sfactor;
      n[3].e = dfactor;
   }
   if (ctx->ExecuteFlag) {
      CALL_BlendFunciARB(ctx->Exec, (buf, sfactor, dfactor));
   }
}

/* GL_ARB_draw_buffers_blend */
static void GLAPIENTRY
save_BlendEquationi(GLuint buf, GLenum mode)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_BLEND_EQUATION_I, 2);
   if (n) {
      n[1].ui = buf;
      n[2].e = mode;
   }
   if (ctx->ExecuteFlag) {
      CALL_BlendEquationiARB(ctx->Exec, (buf, mode));
   }
}

/* GL_ARB_draw_buffers_blend */
static void GLAPIENTRY
save_BlendEquationSeparatei(GLuint buf, GLenum modeRGB, GLenum modeA)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_BLEND_EQUATION_SEPARATE_I, 3);
   if (n) {
      n[1].ui = buf;
      n[2].e = modeRGB;
      n[3].e = modeA;
   }
   if (ctx->ExecuteFlag) {
      CALL_BlendEquationSeparateiARB(ctx->Exec, (buf, modeRGB, modeA));
   }
}


/* GL_ARB_draw_instanced. */
static void GLAPIENTRY
save_DrawArraysInstancedARB(GLenum mode,
			    GLint first,
			    GLsizei count,
			    GLsizei primcount)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_error(ctx, GL_INVALID_OPERATION,
	       "glDrawArraysInstanced() during display list compile");
}

static void GLAPIENTRY
save_DrawElementsInstancedARB(GLenum mode,
			      GLsizei count,
			      GLenum type,
			      const GLvoid *indices,
			      GLsizei primcount)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_error(ctx, GL_INVALID_OPERATION,
	       "glDrawElementsInstanced() during display list compile");
}

static void GLAPIENTRY
save_DrawElementsInstancedBaseVertexARB(GLenum mode,
					GLsizei count,
					GLenum type,
					const GLvoid *indices,
					GLsizei primcount,
					GLint basevertex)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_error(ctx, GL_INVALID_OPERATION,
	       "glDrawElementsInstancedBaseVertex() during display list compile");
}

/* GL_ARB_base_instance. */
static void GLAPIENTRY
save_DrawArraysInstancedBaseInstance(GLenum mode,
                                     GLint first,
                                     GLsizei count,
                                     GLsizei primcount,
                                     GLuint baseinstance)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_error(ctx, GL_INVALID_OPERATION,
	       "glDrawArraysInstancedBaseInstance() during display list compile");
}

static void APIENTRY
save_DrawElementsInstancedBaseInstance(GLenum mode,
                                       GLsizei count,
                                       GLenum type,
                                       const void *indices,
                                       GLsizei primcount,
                                       GLuint baseinstance)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_error(ctx, GL_INVALID_OPERATION,
	       "glDrawElementsInstancedBaseInstance() during display list compile");
}

static void APIENTRY
save_DrawElementsInstancedBaseVertexBaseInstance(GLenum mode,
                                                 GLsizei count,
                                                 GLenum type,
                                                 const void *indices,
                                                 GLsizei primcount,
                                                 GLint basevertex,
                                                 GLuint baseinstance)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_error(ctx, GL_INVALID_OPERATION,
	       "glDrawElementsInstancedBaseVertexBaseInstance() during display list compile");
}


/**
 * While building a display list we cache some OpenGL state.
 * Under some circumstances we need to invalidate that state (immediately
 * when we start compiling a list, or after glCallList(s)).
 */
static void
invalidate_saved_current_state(struct gl_context *ctx)
{
   GLint i;

   for (i = 0; i < VERT_ATTRIB_MAX; i++)
      ctx->ListState.ActiveAttribSize[i] = 0;

   for (i = 0; i < MAT_ATTRIB_MAX; i++)
      ctx->ListState.ActiveMaterialSize[i] = 0;

   memset(&ctx->ListState.Current, 0, sizeof ctx->ListState.Current);

   ctx->Driver.CurrentSavePrimitive = PRIM_UNKNOWN;
}


static void GLAPIENTRY
save_CallList(GLuint list)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   SAVE_FLUSH_VERTICES(ctx);

   n = alloc_instruction(ctx, OPCODE_CALL_LIST, 1);
   if (n) {
      n[1].ui = list;
   }

   /* After this, we don't know what state we're in.  Invalidate all
    * cached information previously gathered:
    */
   invalidate_saved_current_state( ctx );

   if (ctx->ExecuteFlag) {
      _mesa_CallList(list);
   }
}


static void GLAPIENTRY
save_CallLists(GLsizei num, GLenum type, const GLvoid * lists)
{
   GET_CURRENT_CONTEXT(ctx);
   GLint i;
   GLboolean typeErrorFlag;

   SAVE_FLUSH_VERTICES(ctx);

   switch (type) {
   case GL_BYTE:
   case GL_UNSIGNED_BYTE:
   case GL_SHORT:
   case GL_UNSIGNED_SHORT:
   case GL_INT:
   case GL_UNSIGNED_INT:
   case GL_FLOAT:
   case GL_2_BYTES:
   case GL_3_BYTES:
   case GL_4_BYTES:
      typeErrorFlag = GL_FALSE;
      break;
   default:
      typeErrorFlag = GL_TRUE;
   }

   for (i = 0; i < num; i++) {
      GLint list = translate_id(i, type, lists);
      Node *n = alloc_instruction(ctx, OPCODE_CALL_LIST_OFFSET, 2);
      if (n) {
         n[1].i = list;
         n[2].b = typeErrorFlag;
      }
   }

   /* After this, we don't know what state we're in.  Invalidate all
    * cached information previously gathered:
    */
   invalidate_saved_current_state( ctx );

   if (ctx->ExecuteFlag) {
      CALL_CallLists(ctx->Exec, (num, type, lists));
   }
}


static void GLAPIENTRY
save_Clear(GLbitfield mask)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_CLEAR, 1);
   if (n) {
      n[1].bf = mask;
   }
   if (ctx->ExecuteFlag) {
      CALL_Clear(ctx->Exec, (mask));
   }
}


static void GLAPIENTRY
save_ClearBufferiv(GLenum buffer, GLint drawbuffer, const GLint *value)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_CLEAR_BUFFER_IV, 6);
   if (n) {
      n[1].e = buffer;
      n[2].i = drawbuffer;
      n[3].i = value[0];
      if (buffer == GL_COLOR) {
         n[4].i = value[1];
         n[5].i = value[2];
         n[6].i = value[3];
      }
      else {
         n[4].i = 0;
         n[5].i = 0;
         n[6].i = 0;
      }
   }
   if (ctx->ExecuteFlag) {
      CALL_ClearBufferiv(ctx->Exec, (buffer, drawbuffer, value));
   }
}


static void GLAPIENTRY
save_ClearBufferuiv(GLenum buffer, GLint drawbuffer, const GLuint *value)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_CLEAR_BUFFER_UIV, 6);
   if (n) {
      n[1].e = buffer;
      n[2].i = drawbuffer;
      n[3].ui = value[0];
      if (buffer == GL_COLOR) {
         n[4].ui = value[1];
         n[5].ui = value[2];
         n[6].ui = value[3];
      }
      else {
         n[4].ui = 0;
         n[5].ui = 0;
         n[6].ui = 0;
      }
   }
   if (ctx->ExecuteFlag) {
      CALL_ClearBufferuiv(ctx->Exec, (buffer, drawbuffer, value));
   }
}


static void GLAPIENTRY
save_ClearBufferfv(GLenum buffer, GLint drawbuffer, const GLfloat *value)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_CLEAR_BUFFER_FV, 6);
   if (n) {
      n[1].e = buffer;
      n[2].i = drawbuffer;
      n[3].f = value[0];
      if (buffer == GL_COLOR) {
         n[4].f = value[1];
         n[5].f = value[2];
         n[6].f = value[3];
      }
      else {
         n[4].f = 0.0F;
         n[5].f = 0.0F;
         n[6].f = 0.0F;
      }
   }
   if (ctx->ExecuteFlag) {
      CALL_ClearBufferfv(ctx->Exec, (buffer, drawbuffer, value));
   }
}


static void GLAPIENTRY
save_ClearBufferfi(GLenum buffer, GLint drawbuffer,
                   GLfloat depth, GLint stencil)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_CLEAR_BUFFER_FI, 4);
   if (n) {
      n[1].e = buffer;
      n[2].i = drawbuffer;
      n[3].f = depth;
      n[4].i = stencil;
   }
   if (ctx->ExecuteFlag) {
      CALL_ClearBufferfi(ctx->Exec, (buffer, drawbuffer, depth, stencil));
   }
}


static void GLAPIENTRY
save_ClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_CLEAR_ACCUM, 4);
   if (n) {
      n[1].f = red;
      n[2].f = green;
      n[3].f = blue;
      n[4].f = alpha;
   }
   if (ctx->ExecuteFlag) {
      CALL_ClearAccum(ctx->Exec, (red, green, blue, alpha));
   }
}


static void GLAPIENTRY
save_ClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_CLEAR_COLOR, 4);
   if (n) {
      n[1].f = red;
      n[2].f = green;
      n[3].f = blue;
      n[4].f = alpha;
   }
   if (ctx->ExecuteFlag) {
      CALL_ClearColor(ctx->Exec, (red, green, blue, alpha));
   }
}


static void GLAPIENTRY
save_ClearDepth(GLclampd depth)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_CLEAR_DEPTH, 1);
   if (n) {
      n[1].f = (GLfloat) depth;
   }
   if (ctx->ExecuteFlag) {
      CALL_ClearDepth(ctx->Exec, (depth));
   }
}


static void GLAPIENTRY
save_ClearIndex(GLfloat c)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_CLEAR_INDEX, 1);
   if (n) {
      n[1].f = c;
   }
   if (ctx->ExecuteFlag) {
      CALL_ClearIndex(ctx->Exec, (c));
   }
}


static void GLAPIENTRY
save_ClearStencil(GLint s)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_CLEAR_STENCIL, 1);
   if (n) {
      n[1].i = s;
   }
   if (ctx->ExecuteFlag) {
      CALL_ClearStencil(ctx->Exec, (s));
   }
}


static void GLAPIENTRY
save_ClipPlane(GLenum plane, const GLdouble * equ)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_CLIP_PLANE, 5);
   if (n) {
      n[1].e = plane;
      n[2].f = (GLfloat) equ[0];
      n[3].f = (GLfloat) equ[1];
      n[4].f = (GLfloat) equ[2];
      n[5].f = (GLfloat) equ[3];
   }
   if (ctx->ExecuteFlag) {
      CALL_ClipPlane(ctx->Exec, (plane, equ));
   }
}



static void GLAPIENTRY
save_ColorMask(GLboolean red, GLboolean green,
               GLboolean blue, GLboolean alpha)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_COLOR_MASK, 4);
   if (n) {
      n[1].b = red;
      n[2].b = green;
      n[3].b = blue;
      n[4].b = alpha;
   }
   if (ctx->ExecuteFlag) {
      CALL_ColorMask(ctx->Exec, (red, green, blue, alpha));
   }
}


static void GLAPIENTRY
save_ColorMaskIndexed(GLuint buf, GLboolean red, GLboolean green,
                      GLboolean blue, GLboolean alpha)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_COLOR_MASK_INDEXED, 5);
   if (n) {
      n[1].ui = buf;
      n[2].b = red;
      n[3].b = green;
      n[4].b = blue;
      n[5].b = alpha;
   }
   if (ctx->ExecuteFlag) {
      /*CALL_ColorMaski(ctx->Exec, (buf, red, green, blue, alpha));*/
   }
}


static void GLAPIENTRY
save_ColorMaterial(GLenum face, GLenum mode)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);

   n = alloc_instruction(ctx, OPCODE_COLOR_MATERIAL, 2);
   if (n) {
      n[1].e = face;
      n[2].e = mode;
   }
   if (ctx->ExecuteFlag) {
      CALL_ColorMaterial(ctx->Exec, (face, mode));
   }
}


static void GLAPIENTRY
save_CopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_COPY_PIXELS, 5);
   if (n) {
      n[1].i = x;
      n[2].i = y;
      n[3].i = (GLint) width;
      n[4].i = (GLint) height;
      n[5].e = type;
   }
   if (ctx->ExecuteFlag) {
      CALL_CopyPixels(ctx->Exec, (x, y, width, height, type));
   }
}



static void GLAPIENTRY
save_CopyTexImage1D(GLenum target, GLint level, GLenum internalformat,
                    GLint x, GLint y, GLsizei width, GLint border)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_COPY_TEX_IMAGE1D, 7);
   if (n) {
      n[1].e = target;
      n[2].i = level;
      n[3].e = internalformat;
      n[4].i = x;
      n[5].i = y;
      n[6].i = width;
      n[7].i = border;
   }
   if (ctx->ExecuteFlag) {
      CALL_CopyTexImage1D(ctx->Exec, (target, level, internalformat,
                                      x, y, width, border));
   }
}


static void GLAPIENTRY
save_CopyTexImage2D(GLenum target, GLint level,
                    GLenum internalformat,
                    GLint x, GLint y, GLsizei width,
                    GLsizei height, GLint border)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_COPY_TEX_IMAGE2D, 8);
   if (n) {
      n[1].e = target;
      n[2].i = level;
      n[3].e = internalformat;
      n[4].i = x;
      n[5].i = y;
      n[6].i = width;
      n[7].i = height;
      n[8].i = border;
   }
   if (ctx->ExecuteFlag) {
      CALL_CopyTexImage2D(ctx->Exec, (target, level, internalformat,
                                      x, y, width, height, border));
   }
}



static void GLAPIENTRY
save_CopyTexSubImage1D(GLenum target, GLint level,
                       GLint xoffset, GLint x, GLint y, GLsizei width)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_COPY_TEX_SUB_IMAGE1D, 6);
   if (n) {
      n[1].e = target;
      n[2].i = level;
      n[3].i = xoffset;
      n[4].i = x;
      n[5].i = y;
      n[6].i = width;
   }
   if (ctx->ExecuteFlag) {
      CALL_CopyTexSubImage1D(ctx->Exec,
                             (target, level, xoffset, x, y, width));
   }
}


static void GLAPIENTRY
save_CopyTexSubImage2D(GLenum target, GLint level,
                       GLint xoffset, GLint yoffset,
                       GLint x, GLint y, GLsizei width, GLint height)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_COPY_TEX_SUB_IMAGE2D, 8);
   if (n) {
      n[1].e = target;
      n[2].i = level;
      n[3].i = xoffset;
      n[4].i = yoffset;
      n[5].i = x;
      n[6].i = y;
      n[7].i = width;
      n[8].i = height;
   }
   if (ctx->ExecuteFlag) {
      CALL_CopyTexSubImage2D(ctx->Exec, (target, level, xoffset, yoffset,
                                         x, y, width, height));
   }
}


static void GLAPIENTRY
save_CopyTexSubImage3D(GLenum target, GLint level,
                       GLint xoffset, GLint yoffset, GLint zoffset,
                       GLint x, GLint y, GLsizei width, GLint height)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_COPY_TEX_SUB_IMAGE3D, 9);
   if (n) {
      n[1].e = target;
      n[2].i = level;
      n[3].i = xoffset;
      n[4].i = yoffset;
      n[5].i = zoffset;
      n[6].i = x;
      n[7].i = y;
      n[8].i = width;
      n[9].i = height;
   }
   if (ctx->ExecuteFlag) {
      CALL_CopyTexSubImage3D(ctx->Exec, (target, level,
                                         xoffset, yoffset, zoffset,
                                         x, y, width, height));
   }
}


static void GLAPIENTRY
save_CullFace(GLenum mode)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_CULL_FACE, 1);
   if (n) {
      n[1].e = mode;
   }
   if (ctx->ExecuteFlag) {
      CALL_CullFace(ctx->Exec, (mode));
   }
}


static void GLAPIENTRY
save_DepthFunc(GLenum func)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_DEPTH_FUNC, 1);
   if (n) {
      n[1].e = func;
   }
   if (ctx->ExecuteFlag) {
      CALL_DepthFunc(ctx->Exec, (func));
   }
}


static void GLAPIENTRY
save_DepthMask(GLboolean mask)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_DEPTH_MASK, 1);
   if (n) {
      n[1].b = mask;
   }
   if (ctx->ExecuteFlag) {
      CALL_DepthMask(ctx->Exec, (mask));
   }
}


static void GLAPIENTRY
save_DepthRange(GLclampd nearval, GLclampd farval)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_DEPTH_RANGE, 2);
   if (n) {
      n[1].f = (GLfloat) nearval;
      n[2].f = (GLfloat) farval;
   }
   if (ctx->ExecuteFlag) {
      CALL_DepthRange(ctx->Exec, (nearval, farval));
   }
}


static void GLAPIENTRY
save_Disable(GLenum cap)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_DISABLE, 1);
   if (n) {
      n[1].e = cap;
   }
   if (ctx->ExecuteFlag) {
      CALL_Disable(ctx->Exec, (cap));
   }
}


static void GLAPIENTRY
save_DisableIndexed(GLuint index, GLenum cap)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_DISABLE_INDEXED, 2);
   if (n) {
      n[1].ui = index;
      n[2].e = cap;
   }
   if (ctx->ExecuteFlag) {
      CALL_Disablei(ctx->Exec, (index, cap));
   }
}


static void GLAPIENTRY
save_DrawBuffer(GLenum mode)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_DRAW_BUFFER, 1);
   if (n) {
      n[1].e = mode;
   }
   if (ctx->ExecuteFlag) {
      CALL_DrawBuffer(ctx->Exec, (mode));
   }
}


static void GLAPIENTRY
save_DrawPixels(GLsizei width, GLsizei height,
                GLenum format, GLenum type, const GLvoid * pixels)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;

   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);

   n = alloc_instruction(ctx, OPCODE_DRAW_PIXELS, 4 + POINTER_DWORDS);
   if (n) {
      n[1].i = width;
      n[2].i = height;
      n[3].e = format;
      n[4].e = type;
      save_pointer(&n[5],
                   unpack_image(ctx, 2, width, height, 1, format, type,
                                pixels, &ctx->Unpack));
   }
   if (ctx->ExecuteFlag) {
      CALL_DrawPixels(ctx->Exec, (width, height, format, type, pixels));
   }
}



static void GLAPIENTRY
save_Enable(GLenum cap)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_ENABLE, 1);
   if (n) {
      n[1].e = cap;
   }
   if (ctx->ExecuteFlag) {
      CALL_Enable(ctx->Exec, (cap));
   }
}



static void GLAPIENTRY
save_EnableIndexed(GLuint index, GLenum cap)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_ENABLE_INDEXED, 2);
   if (n) {
      n[1].ui = index;
      n[2].e = cap;
   }
   if (ctx->ExecuteFlag) {
      CALL_Enablei(ctx->Exec, (index, cap));
   }
}



static void GLAPIENTRY
save_EvalMesh1(GLenum mode, GLint i1, GLint i2)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_EVALMESH1, 3);
   if (n) {
      n[1].e = mode;
      n[2].i = i1;
      n[3].i = i2;
   }
   if (ctx->ExecuteFlag) {
      CALL_EvalMesh1(ctx->Exec, (mode, i1, i2));
   }
}


static void GLAPIENTRY
save_EvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_EVALMESH2, 5);
   if (n) {
      n[1].e = mode;
      n[2].i = i1;
      n[3].i = i2;
      n[4].i = j1;
      n[5].i = j2;
   }
   if (ctx->ExecuteFlag) {
      CALL_EvalMesh2(ctx->Exec, (mode, i1, i2, j1, j2));
   }
}




static void GLAPIENTRY
save_Fogfv(GLenum pname, const GLfloat *params)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_FOG, 5);
   if (n) {
      n[1].e = pname;
      n[2].f = params[0];
      n[3].f = params[1];
      n[4].f = params[2];
      n[5].f = params[3];
   }
   if (ctx->ExecuteFlag) {
      CALL_Fogfv(ctx->Exec, (pname, params));
   }
}


static void GLAPIENTRY
save_Fogf(GLenum pname, GLfloat param)
{
   GLfloat parray[4];
   parray[0] = param;
   parray[1] = parray[2] = parray[3] = 0.0F;
   save_Fogfv(pname, parray);
}


static void GLAPIENTRY
save_Fogiv(GLenum pname, const GLint *params)
{
   GLfloat p[4];
   switch (pname) {
   case GL_FOG_MODE:
   case GL_FOG_DENSITY:
   case GL_FOG_START:
   case GL_FOG_END:
   case GL_FOG_INDEX:
      p[0] = (GLfloat) *params;
      p[1] = 0.0f;
      p[2] = 0.0f;
      p[3] = 0.0f;
      break;
   case GL_FOG_COLOR:
      p[0] = INT_TO_FLOAT(params[0]);
      p[1] = INT_TO_FLOAT(params[1]);
      p[2] = INT_TO_FLOAT(params[2]);
      p[3] = INT_TO_FLOAT(params[3]);
      break;
   default:
      /* Error will be caught later in gl_Fogfv */
      ASSIGN_4V(p, 0.0F, 0.0F, 0.0F, 0.0F);
   }
   save_Fogfv(pname, p);
}


static void GLAPIENTRY
save_Fogi(GLenum pname, GLint param)
{
   GLint parray[4];
   parray[0] = param;
   parray[1] = parray[2] = parray[3] = 0;
   save_Fogiv(pname, parray);
}


static void GLAPIENTRY
save_FrontFace(GLenum mode)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_FRONT_FACE, 1);
   if (n) {
      n[1].e = mode;
   }
   if (ctx->ExecuteFlag) {
      CALL_FrontFace(ctx->Exec, (mode));
   }
}


static void GLAPIENTRY
save_Frustum(GLdouble left, GLdouble right,
             GLdouble bottom, GLdouble top, GLdouble nearval, GLdouble farval)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_FRUSTUM, 6);
   if (n) {
      n[1].f = (GLfloat) left;
      n[2].f = (GLfloat) right;
      n[3].f = (GLfloat) bottom;
      n[4].f = (GLfloat) top;
      n[5].f = (GLfloat) nearval;
      n[6].f = (GLfloat) farval;
   }
   if (ctx->ExecuteFlag) {
      CALL_Frustum(ctx->Exec, (left, right, bottom, top, nearval, farval));
   }
}


static void GLAPIENTRY
save_Hint(GLenum target, GLenum mode)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_HINT, 2);
   if (n) {
      n[1].e = target;
      n[2].e = mode;
   }
   if (ctx->ExecuteFlag) {
      CALL_Hint(ctx->Exec, (target, mode));
   }
}


static void GLAPIENTRY
save_IndexMask(GLuint mask)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_INDEX_MASK, 1);
   if (n) {
      n[1].ui = mask;
   }
   if (ctx->ExecuteFlag) {
      CALL_IndexMask(ctx->Exec, (mask));
   }
}


static void GLAPIENTRY
save_InitNames(void)
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   (void) alloc_instruction(ctx, OPCODE_INIT_NAMES, 0);
   if (ctx->ExecuteFlag) {
      CALL_InitNames(ctx->Exec, ());
   }
}


static void GLAPIENTRY
save_Lightfv(GLenum light, GLenum pname, const GLfloat *params)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_LIGHT, 6);
   if (n) {
      GLint i, nParams;
      n[1].e = light;
      n[2].e = pname;
      switch (pname) {
      case GL_AMBIENT:
         nParams = 4;
         break;
      case GL_DIFFUSE:
         nParams = 4;
         break;
      case GL_SPECULAR:
         nParams = 4;
         break;
      case GL_POSITION:
         nParams = 4;
         break;
      case GL_SPOT_DIRECTION:
         nParams = 3;
         break;
      case GL_SPOT_EXPONENT:
         nParams = 1;
         break;
      case GL_SPOT_CUTOFF:
         nParams = 1;
         break;
      case GL_CONSTANT_ATTENUATION:
         nParams = 1;
         break;
      case GL_LINEAR_ATTENUATION:
         nParams = 1;
         break;
      case GL_QUADRATIC_ATTENUATION:
         nParams = 1;
         break;
      default:
         nParams = 0;
      }
      for (i = 0; i < nParams; i++) {
         n[3 + i].f = params[i];
      }
   }
   if (ctx->ExecuteFlag) {
      CALL_Lightfv(ctx->Exec, (light, pname, params));
   }
}


static void GLAPIENTRY
save_Lightf(GLenum light, GLenum pname, GLfloat param)
{
   GLfloat parray[4];
   parray[0] = param;
   parray[1] = parray[2] = parray[3] = 0.0F;
   save_Lightfv(light, pname, parray);
}


static void GLAPIENTRY
save_Lightiv(GLenum light, GLenum pname, const GLint *params)
{
   GLfloat fparam[4];
   switch (pname) {
   case GL_AMBIENT:
   case GL_DIFFUSE:
   case GL_SPECULAR:
      fparam[0] = INT_TO_FLOAT(params[0]);
      fparam[1] = INT_TO_FLOAT(params[1]);
      fparam[2] = INT_TO_FLOAT(params[2]);
      fparam[3] = INT_TO_FLOAT(params[3]);
      break;
   case GL_POSITION:
      fparam[0] = (GLfloat) params[0];
      fparam[1] = (GLfloat) params[1];
      fparam[2] = (GLfloat) params[2];
      fparam[3] = (GLfloat) params[3];
      break;
   case GL_SPOT_DIRECTION:
      fparam[0] = (GLfloat) params[0];
      fparam[1] = (GLfloat) params[1];
      fparam[2] = (GLfloat) params[2];
      break;
   case GL_SPOT_EXPONENT:
   case GL_SPOT_CUTOFF:
   case GL_CONSTANT_ATTENUATION:
   case GL_LINEAR_ATTENUATION:
   case GL_QUADRATIC_ATTENUATION:
      fparam[0] = (GLfloat) params[0];
      break;
   default:
      /* error will be caught later in gl_Lightfv */
      ;
   }
   save_Lightfv(light, pname, fparam);
}


static void GLAPIENTRY
save_Lighti(GLenum light, GLenum pname, GLint param)
{
   GLint parray[4];
   parray[0] = param;
   parray[1] = parray[2] = parray[3] = 0;
   save_Lightiv(light, pname, parray);
}


static void GLAPIENTRY
save_LightModelfv(GLenum pname, const GLfloat *params)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_LIGHT_MODEL, 5);
   if (n) {
      n[1].e = pname;
      n[2].f = params[0];
      n[3].f = params[1];
      n[4].f = params[2];
      n[5].f = params[3];
   }
   if (ctx->ExecuteFlag) {
      CALL_LightModelfv(ctx->Exec, (pname, params));
   }
}


static void GLAPIENTRY
save_LightModelf(GLenum pname, GLfloat param)
{
   GLfloat parray[4];
   parray[0] = param;
   parray[1] = parray[2] = parray[3] = 0.0F;
   save_LightModelfv(pname, parray);
}


static void GLAPIENTRY
save_LightModeliv(GLenum pname, const GLint *params)
{
   GLfloat fparam[4];
   switch (pname) {
   case GL_LIGHT_MODEL_AMBIENT:
      fparam[0] = INT_TO_FLOAT(params[0]);
      fparam[1] = INT_TO_FLOAT(params[1]);
      fparam[2] = INT_TO_FLOAT(params[2]);
      fparam[3] = INT_TO_FLOAT(params[3]);
      break;
   case GL_LIGHT_MODEL_LOCAL_VIEWER:
   case GL_LIGHT_MODEL_TWO_SIDE:
   case GL_LIGHT_MODEL_COLOR_CONTROL:
      fparam[0] = (GLfloat) params[0];
      fparam[1] = 0.0F;
      fparam[2] = 0.0F;
      fparam[3] = 0.0F;
      break;
   default:
      /* Error will be caught later in gl_LightModelfv */
      ASSIGN_4V(fparam, 0.0F, 0.0F, 0.0F, 0.0F);
   }
   save_LightModelfv(pname, fparam);
}


static void GLAPIENTRY
save_LightModeli(GLenum pname, GLint param)
{
   GLint parray[4];
   parray[0] = param;
   parray[1] = parray[2] = parray[3] = 0;
   save_LightModeliv(pname, parray);
}


static void GLAPIENTRY
save_LineStipple(GLint factor, GLushort pattern)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_LINE_STIPPLE, 2);
   if (n) {
      n[1].i = factor;
      n[2].us = pattern;
   }
   if (ctx->ExecuteFlag) {
      CALL_LineStipple(ctx->Exec, (factor, pattern));
   }
}


static void GLAPIENTRY
save_LineWidth(GLfloat width)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_LINE_WIDTH, 1);
   if (n) {
      n[1].f = width;
   }
   if (ctx->ExecuteFlag) {
      CALL_LineWidth(ctx->Exec, (width));
   }
}


static void GLAPIENTRY
save_ListBase(GLuint base)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_LIST_BASE, 1);
   if (n) {
      n[1].ui = base;
   }
   if (ctx->ExecuteFlag) {
      CALL_ListBase(ctx->Exec, (base));
   }
}


static void GLAPIENTRY
save_LoadIdentity(void)
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   (void) alloc_instruction(ctx, OPCODE_LOAD_IDENTITY, 0);
   if (ctx->ExecuteFlag) {
      CALL_LoadIdentity(ctx->Exec, ());
   }
}


static void GLAPIENTRY
save_LoadMatrixf(const GLfloat * m)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_LOAD_MATRIX, 16);
   if (n) {
      GLuint i;
      for (i = 0; i < 16; i++) {
         n[1 + i].f = m[i];
      }
   }
   if (ctx->ExecuteFlag) {
      CALL_LoadMatrixf(ctx->Exec, (m));
   }
}


static void GLAPIENTRY
save_LoadMatrixd(const GLdouble * m)
{
   GLfloat f[16];
   GLint i;
   for (i = 0; i < 16; i++) {
      f[i] = (GLfloat) m[i];
   }
   save_LoadMatrixf(f);
}


static void GLAPIENTRY
save_LoadName(GLuint name)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_LOAD_NAME, 1);
   if (n) {
      n[1].ui = name;
   }
   if (ctx->ExecuteFlag) {
      CALL_LoadName(ctx->Exec, (name));
   }
}


static void GLAPIENTRY
save_LogicOp(GLenum opcode)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_LOGIC_OP, 1);
   if (n) {
      n[1].e = opcode;
   }
   if (ctx->ExecuteFlag) {
      CALL_LogicOp(ctx->Exec, (opcode));
   }
}


static void GLAPIENTRY
save_Map1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride,
           GLint order, const GLdouble * points)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_MAP1, 5 + POINTER_DWORDS);
   if (n) {
      GLfloat *pnts = _mesa_copy_map_points1d(target, stride, order, points);
      n[1].e = target;
      n[2].f = (GLfloat) u1;
      n[3].f = (GLfloat) u2;
      n[4].i = _mesa_evaluator_components(target);      /* stride */
      n[5].i = order;
      save_pointer(&n[6], pnts);
   }
   if (ctx->ExecuteFlag) {
      CALL_Map1d(ctx->Exec, (target, u1, u2, stride, order, points));
   }
}

static void GLAPIENTRY
save_Map1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride,
           GLint order, const GLfloat * points)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_MAP1, 5 + POINTER_DWORDS);
   if (n) {
      GLfloat *pnts = _mesa_copy_map_points1f(target, stride, order, points);
      n[1].e = target;
      n[2].f = u1;
      n[3].f = u2;
      n[4].i = _mesa_evaluator_components(target);      /* stride */
      n[5].i = order;
      save_pointer(&n[6], pnts);
   }
   if (ctx->ExecuteFlag) {
      CALL_Map1f(ctx->Exec, (target, u1, u2, stride, order, points));
   }
}


static void GLAPIENTRY
save_Map2d(GLenum target,
           GLdouble u1, GLdouble u2, GLint ustride, GLint uorder,
           GLdouble v1, GLdouble v2, GLint vstride, GLint vorder,
           const GLdouble * points)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_MAP2, 9 + POINTER_DWORDS);
   if (n) {
      GLfloat *pnts = _mesa_copy_map_points2d(target, ustride, uorder,
                                              vstride, vorder, points);
      n[1].e = target;
      n[2].f = (GLfloat) u1;
      n[3].f = (GLfloat) u2;
      n[4].f = (GLfloat) v1;
      n[5].f = (GLfloat) v2;
      /* XXX verify these strides are correct */
      n[6].i = _mesa_evaluator_components(target) * vorder;     /*ustride */
      n[7].i = _mesa_evaluator_components(target);      /*vstride */
      n[8].i = uorder;
      n[9].i = vorder;
      save_pointer(&n[10], pnts);
   }
   if (ctx->ExecuteFlag) {
      CALL_Map2d(ctx->Exec, (target,
                             u1, u2, ustride, uorder,
                             v1, v2, vstride, vorder, points));
   }
}


static void GLAPIENTRY
save_Map2f(GLenum target,
           GLfloat u1, GLfloat u2, GLint ustride, GLint uorder,
           GLfloat v1, GLfloat v2, GLint vstride, GLint vorder,
           const GLfloat * points)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_MAP2, 9 + POINTER_DWORDS);
   if (n) {
      GLfloat *pnts = _mesa_copy_map_points2f(target, ustride, uorder,
                                              vstride, vorder, points);
      n[1].e = target;
      n[2].f = u1;
      n[3].f = u2;
      n[4].f = v1;
      n[5].f = v2;
      /* XXX verify these strides are correct */
      n[6].i = _mesa_evaluator_components(target) * vorder;     /*ustride */
      n[7].i = _mesa_evaluator_components(target);      /*vstride */
      n[8].i = uorder;
      n[9].i = vorder;
      save_pointer(&n[10], pnts);
   }
   if (ctx->ExecuteFlag) {
      CALL_Map2f(ctx->Exec, (target, u1, u2, ustride, uorder,
                             v1, v2, vstride, vorder, points));
   }
}


static void GLAPIENTRY
save_MapGrid1f(GLint un, GLfloat u1, GLfloat u2)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_MAPGRID1, 3);
   if (n) {
      n[1].i = un;
      n[2].f = u1;
      n[3].f = u2;
   }
   if (ctx->ExecuteFlag) {
      CALL_MapGrid1f(ctx->Exec, (un, u1, u2));
   }
}


static void GLAPIENTRY
save_MapGrid1d(GLint un, GLdouble u1, GLdouble u2)
{
   save_MapGrid1f(un, (GLfloat) u1, (GLfloat) u2);
}


static void GLAPIENTRY
save_MapGrid2f(GLint un, GLfloat u1, GLfloat u2,
               GLint vn, GLfloat v1, GLfloat v2)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_MAPGRID2, 6);
   if (n) {
      n[1].i = un;
      n[2].f = u1;
      n[3].f = u2;
      n[4].i = vn;
      n[5].f = v1;
      n[6].f = v2;
   }
   if (ctx->ExecuteFlag) {
      CALL_MapGrid2f(ctx->Exec, (un, u1, u2, vn, v1, v2));
   }
}



static void GLAPIENTRY
save_MapGrid2d(GLint un, GLdouble u1, GLdouble u2,
               GLint vn, GLdouble v1, GLdouble v2)
{
   save_MapGrid2f(un, (GLfloat) u1, (GLfloat) u2,
                  vn, (GLfloat) v1, (GLfloat) v2);
}


static void GLAPIENTRY
save_MatrixMode(GLenum mode)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_MATRIX_MODE, 1);
   if (n) {
      n[1].e = mode;
   }
   if (ctx->ExecuteFlag) {
      CALL_MatrixMode(ctx->Exec, (mode));
   }
}


static void GLAPIENTRY
save_MultMatrixf(const GLfloat * m)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_MULT_MATRIX, 16);
   if (n) {
      GLuint i;
      for (i = 0; i < 16; i++) {
         n[1 + i].f = m[i];
      }
   }
   if (ctx->ExecuteFlag) {
      CALL_MultMatrixf(ctx->Exec, (m));
   }
}


static void GLAPIENTRY
save_MultMatrixd(const GLdouble * m)
{
   GLfloat f[16];
   GLint i;
   for (i = 0; i < 16; i++) {
      f[i] = (GLfloat) m[i];
   }
   save_MultMatrixf(f);
}


static void GLAPIENTRY
save_NewList(GLuint name, GLenum mode)
{
   GET_CURRENT_CONTEXT(ctx);
   /* It's an error to call this function while building a display list */
   _mesa_error(ctx, GL_INVALID_OPERATION, "glNewList");
   (void) name;
   (void) mode;
}



static void GLAPIENTRY
save_Ortho(GLdouble left, GLdouble right,
           GLdouble bottom, GLdouble top, GLdouble nearval, GLdouble farval)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_ORTHO, 6);
   if (n) {
      n[1].f = (GLfloat) left;
      n[2].f = (GLfloat) right;
      n[3].f = (GLfloat) bottom;
      n[4].f = (GLfloat) top;
      n[5].f = (GLfloat) nearval;
      n[6].f = (GLfloat) farval;
   }
   if (ctx->ExecuteFlag) {
      CALL_Ortho(ctx->Exec, (left, right, bottom, top, nearval, farval));
   }
}


static void GLAPIENTRY
save_PixelMapfv(GLenum map, GLint mapsize, const GLfloat *values)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_PIXEL_MAP, 2 + POINTER_DWORDS);
   if (n) {
      n[1].e = map;
      n[2].i = mapsize;
      save_pointer(&n[3], memdup(values, mapsize * sizeof(GLfloat)));
   }
   if (ctx->ExecuteFlag) {
      CALL_PixelMapfv(ctx->Exec, (map, mapsize, values));
   }
}


static void GLAPIENTRY
save_PixelMapuiv(GLenum map, GLint mapsize, const GLuint *values)
{
   GLfloat fvalues[MAX_PIXEL_MAP_TABLE];
   GLint i;
   if (map == GL_PIXEL_MAP_I_TO_I || map == GL_PIXEL_MAP_S_TO_S) {
      for (i = 0; i < mapsize; i++) {
         fvalues[i] = (GLfloat) values[i];
      }
   }
   else {
      for (i = 0; i < mapsize; i++) {
         fvalues[i] = UINT_TO_FLOAT(values[i]);
      }
   }
   save_PixelMapfv(map, mapsize, fvalues);
}


static void GLAPIENTRY
save_PixelMapusv(GLenum map, GLint mapsize, const GLushort *values)
{
   GLfloat fvalues[MAX_PIXEL_MAP_TABLE];
   GLint i;
   if (map == GL_PIXEL_MAP_I_TO_I || map == GL_PIXEL_MAP_S_TO_S) {
      for (i = 0; i < mapsize; i++) {
         fvalues[i] = (GLfloat) values[i];
      }
   }
   else {
      for (i = 0; i < mapsize; i++) {
         fvalues[i] = USHORT_TO_FLOAT(values[i]);
      }
   }
   save_PixelMapfv(map, mapsize, fvalues);
}


static void GLAPIENTRY
save_PixelTransferf(GLenum pname, GLfloat param)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_PIXEL_TRANSFER, 2);
   if (n) {
      n[1].e = pname;
      n[2].f = param;
   }
   if (ctx->ExecuteFlag) {
      CALL_PixelTransferf(ctx->Exec, (pname, param));
   }
}


static void GLAPIENTRY
save_PixelTransferi(GLenum pname, GLint param)
{
   save_PixelTransferf(pname, (GLfloat) param);
}


static void GLAPIENTRY
save_PixelZoom(GLfloat xfactor, GLfloat yfactor)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_PIXEL_ZOOM, 2);
   if (n) {
      n[1].f = xfactor;
      n[2].f = yfactor;
   }
   if (ctx->ExecuteFlag) {
      CALL_PixelZoom(ctx->Exec, (xfactor, yfactor));
   }
}


static void GLAPIENTRY
save_PointParameterfvEXT(GLenum pname, const GLfloat *params)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_POINT_PARAMETERS, 4);
   if (n) {
      n[1].e = pname;
      n[2].f = params[0];
      n[3].f = params[1];
      n[4].f = params[2];
   }
   if (ctx->ExecuteFlag) {
      CALL_PointParameterfv(ctx->Exec, (pname, params));
   }
}


static void GLAPIENTRY
save_PointParameterfEXT(GLenum pname, GLfloat param)
{
   GLfloat parray[3];
   parray[0] = param;
   parray[1] = parray[2] = 0.0F;
   save_PointParameterfvEXT(pname, parray);
}

static void GLAPIENTRY
save_PointParameteriNV(GLenum pname, GLint param)
{
   GLfloat parray[3];
   parray[0] = (GLfloat) param;
   parray[1] = parray[2] = 0.0F;
   save_PointParameterfvEXT(pname, parray);
}

static void GLAPIENTRY
save_PointParameterivNV(GLenum pname, const GLint * param)
{
   GLfloat parray[3];
   parray[0] = (GLfloat) param[0];
   parray[1] = parray[2] = 0.0F;
   save_PointParameterfvEXT(pname, parray);
}


static void GLAPIENTRY
save_PointSize(GLfloat size)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_POINT_SIZE, 1);
   if (n) {
      n[1].f = size;
   }
   if (ctx->ExecuteFlag) {
      CALL_PointSize(ctx->Exec, (size));
   }
}


static void GLAPIENTRY
save_PolygonMode(GLenum face, GLenum mode)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_POLYGON_MODE, 2);
   if (n) {
      n[1].e = face;
      n[2].e = mode;
   }
   if (ctx->ExecuteFlag) {
      CALL_PolygonMode(ctx->Exec, (face, mode));
   }
}


static void GLAPIENTRY
save_PolygonStipple(const GLubyte * pattern)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;

   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);

   n = alloc_instruction(ctx, OPCODE_POLYGON_STIPPLE, POINTER_DWORDS);
   if (n) {
      save_pointer(&n[1],
                   unpack_image(ctx, 2, 32, 32, 1, GL_COLOR_INDEX, GL_BITMAP,
                                pattern, &ctx->Unpack));
   }
   if (ctx->ExecuteFlag) {
      CALL_PolygonStipple(ctx->Exec, ((GLubyte *) pattern));
   }
}


static void GLAPIENTRY
save_PolygonOffset(GLfloat factor, GLfloat units)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_POLYGON_OFFSET, 2);
   if (n) {
      n[1].f = factor;
      n[2].f = units;
   }
   if (ctx->ExecuteFlag) {
      CALL_PolygonOffset(ctx->Exec, (factor, units));
   }
}


static void GLAPIENTRY
save_PolygonOffsetEXT(GLfloat factor, GLfloat bias)
{
   GET_CURRENT_CONTEXT(ctx);
   /* XXX mult by DepthMaxF here??? */
   save_PolygonOffset(factor, ctx->DrawBuffer->_DepthMaxF * bias);
}


static void GLAPIENTRY
save_PopAttrib(void)
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   (void) alloc_instruction(ctx, OPCODE_POP_ATTRIB, 0);
   if (ctx->ExecuteFlag) {
      CALL_PopAttrib(ctx->Exec, ());
   }
}


static void GLAPIENTRY
save_PopMatrix(void)
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   (void) alloc_instruction(ctx, OPCODE_POP_MATRIX, 0);
   if (ctx->ExecuteFlag) {
      CALL_PopMatrix(ctx->Exec, ());
   }
}


static void GLAPIENTRY
save_PopName(void)
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   (void) alloc_instruction(ctx, OPCODE_POP_NAME, 0);
   if (ctx->ExecuteFlag) {
      CALL_PopName(ctx->Exec, ());
   }
}


static void GLAPIENTRY
save_PrioritizeTextures(GLsizei num, const GLuint * textures,
                        const GLclampf * priorities)
{
   GET_CURRENT_CONTEXT(ctx);
   GLint i;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);

   for (i = 0; i < num; i++) {
      Node *n;
      n = alloc_instruction(ctx, OPCODE_PRIORITIZE_TEXTURE, 2);
      if (n) {
         n[1].ui = textures[i];
         n[2].f = priorities[i];
      }
   }
   if (ctx->ExecuteFlag) {
      CALL_PrioritizeTextures(ctx->Exec, (num, textures, priorities));
   }
}


static void GLAPIENTRY
save_PushAttrib(GLbitfield mask)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_PUSH_ATTRIB, 1);
   if (n) {
      n[1].bf = mask;
   }
   if (ctx->ExecuteFlag) {
      CALL_PushAttrib(ctx->Exec, (mask));
   }
}


static void GLAPIENTRY
save_PushMatrix(void)
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   (void) alloc_instruction(ctx, OPCODE_PUSH_MATRIX, 0);
   if (ctx->ExecuteFlag) {
      CALL_PushMatrix(ctx->Exec, ());
   }
}


static void GLAPIENTRY
save_PushName(GLuint name)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_PUSH_NAME, 1);
   if (n) {
      n[1].ui = name;
   }
   if (ctx->ExecuteFlag) {
      CALL_PushName(ctx->Exec, (name));
   }
}


static void GLAPIENTRY
save_RasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_RASTER_POS, 4);
   if (n) {
      n[1].f = x;
      n[2].f = y;
      n[3].f = z;
      n[4].f = w;
   }
   if (ctx->ExecuteFlag) {
      CALL_RasterPos4f(ctx->Exec, (x, y, z, w));
   }
}

static void GLAPIENTRY
save_RasterPos2d(GLdouble x, GLdouble y)
{
   save_RasterPos4f((GLfloat) x, (GLfloat) y, 0.0F, 1.0F);
}

static void GLAPIENTRY
save_RasterPos2f(GLfloat x, GLfloat y)
{
   save_RasterPos4f(x, y, 0.0F, 1.0F);
}

static void GLAPIENTRY
save_RasterPos2i(GLint x, GLint y)
{
   save_RasterPos4f((GLfloat) x, (GLfloat) y, 0.0F, 1.0F);
}

static void GLAPIENTRY
save_RasterPos2s(GLshort x, GLshort y)
{
   save_RasterPos4f(x, y, 0.0F, 1.0F);
}

static void GLAPIENTRY
save_RasterPos3d(GLdouble x, GLdouble y, GLdouble z)
{
   save_RasterPos4f((GLfloat) x, (GLfloat) y, (GLfloat) z, 1.0F);
}

static void GLAPIENTRY
save_RasterPos3f(GLfloat x, GLfloat y, GLfloat z)
{
   save_RasterPos4f(x, y, z, 1.0F);
}

static void GLAPIENTRY
save_RasterPos3i(GLint x, GLint y, GLint z)
{
   save_RasterPos4f((GLfloat) x, (GLfloat) y, (GLfloat) z, 1.0F);
}

static void GLAPIENTRY
save_RasterPos3s(GLshort x, GLshort y, GLshort z)
{
   save_RasterPos4f(x, y, z, 1.0F);
}

static void GLAPIENTRY
save_RasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   save_RasterPos4f((GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) w);
}

static void GLAPIENTRY
save_RasterPos4i(GLint x, GLint y, GLint z, GLint w)
{
   save_RasterPos4f((GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) w);
}

static void GLAPIENTRY
save_RasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w)
{
   save_RasterPos4f(x, y, z, w);
}

static void GLAPIENTRY
save_RasterPos2dv(const GLdouble * v)
{
   save_RasterPos4f((GLfloat) v[0], (GLfloat) v[1], 0.0F, 1.0F);
}

static void GLAPIENTRY
save_RasterPos2fv(const GLfloat * v)
{
   save_RasterPos4f(v[0], v[1], 0.0F, 1.0F);
}

static void GLAPIENTRY
save_RasterPos2iv(const GLint * v)
{
   save_RasterPos4f((GLfloat) v[0], (GLfloat) v[1], 0.0F, 1.0F);
}

static void GLAPIENTRY
save_RasterPos2sv(const GLshort * v)
{
   save_RasterPos4f(v[0], v[1], 0.0F, 1.0F);
}

static void GLAPIENTRY
save_RasterPos3dv(const GLdouble * v)
{
   save_RasterPos4f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], 1.0F);
}

static void GLAPIENTRY
save_RasterPos3fv(const GLfloat * v)
{
   save_RasterPos4f(v[0], v[1], v[2], 1.0F);
}

static void GLAPIENTRY
save_RasterPos3iv(const GLint * v)
{
   save_RasterPos4f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], 1.0F);
}

static void GLAPIENTRY
save_RasterPos3sv(const GLshort * v)
{
   save_RasterPos4f(v[0], v[1], v[2], 1.0F);
}

static void GLAPIENTRY
save_RasterPos4dv(const GLdouble * v)
{
   save_RasterPos4f((GLfloat) v[0], (GLfloat) v[1],
                    (GLfloat) v[2], (GLfloat) v[3]);
}

static void GLAPIENTRY
save_RasterPos4fv(const GLfloat * v)
{
   save_RasterPos4f(v[0], v[1], v[2], v[3]);
}

static void GLAPIENTRY
save_RasterPos4iv(const GLint * v)
{
   save_RasterPos4f((GLfloat) v[0], (GLfloat) v[1],
                    (GLfloat) v[2], (GLfloat) v[3]);
}

static void GLAPIENTRY
save_RasterPos4sv(const GLshort * v)
{
   save_RasterPos4f(v[0], v[1], v[2], v[3]);
}


static void GLAPIENTRY
save_PassThrough(GLfloat token)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_PASSTHROUGH, 1);
   if (n) {
      n[1].f = token;
   }
   if (ctx->ExecuteFlag) {
      CALL_PassThrough(ctx->Exec, (token));
   }
}


static void GLAPIENTRY
save_ReadBuffer(GLenum mode)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_READ_BUFFER, 1);
   if (n) {
      n[1].e = mode;
   }
   if (ctx->ExecuteFlag) {
      CALL_ReadBuffer(ctx->Exec, (mode));
   }
}


static void GLAPIENTRY
save_Rotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_ROTATE, 4);
   if (n) {
      n[1].f = angle;
      n[2].f = x;
      n[3].f = y;
      n[4].f = z;
   }
   if (ctx->ExecuteFlag) {
      CALL_Rotatef(ctx->Exec, (angle, x, y, z));
   }
}


static void GLAPIENTRY
save_Rotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z)
{
   save_Rotatef((GLfloat) angle, (GLfloat) x, (GLfloat) y, (GLfloat) z);
}


static void GLAPIENTRY
save_Scalef(GLfloat x, GLfloat y, GLfloat z)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_SCALE, 3);
   if (n) {
      n[1].f = x;
      n[2].f = y;
      n[3].f = z;
   }
   if (ctx->ExecuteFlag) {
      CALL_Scalef(ctx->Exec, (x, y, z));
   }
}


static void GLAPIENTRY
save_Scaled(GLdouble x, GLdouble y, GLdouble z)
{
   save_Scalef((GLfloat) x, (GLfloat) y, (GLfloat) z);
}


static void GLAPIENTRY
save_Scissor(GLint x, GLint y, GLsizei width, GLsizei height)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_SCISSOR, 4);
   if (n) {
      n[1].i = x;
      n[2].i = y;
      n[3].i = width;
      n[4].i = height;
   }
   if (ctx->ExecuteFlag) {
      CALL_Scissor(ctx->Exec, (x, y, width, height));
   }
}


static void GLAPIENTRY
save_ShadeModel(GLenum mode)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END(ctx);

   if (ctx->ExecuteFlag) {
      CALL_ShadeModel(ctx->Exec, (mode));
   }

   /* Don't compile this call if it's a no-op.
    * By avoiding this state change we have a better chance of
    * coalescing subsequent drawing commands into one batch.
    */
   if (ctx->ListState.Current.ShadeModel == mode)
      return;

   SAVE_FLUSH_VERTICES(ctx);

   ctx->ListState.Current.ShadeModel = mode;

   n = alloc_instruction(ctx, OPCODE_SHADE_MODEL, 1);
   if (n) {
      n[1].e = mode;
   }
}


static void GLAPIENTRY
save_StencilFunc(GLenum func, GLint ref, GLuint mask)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_STENCIL_FUNC, 3);
   if (n) {
      n[1].e = func;
      n[2].i = ref;
      n[3].ui = mask;
   }
   if (ctx->ExecuteFlag) {
      CALL_StencilFunc(ctx->Exec, (func, ref, mask));
   }
}


static void GLAPIENTRY
save_StencilMask(GLuint mask)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_STENCIL_MASK, 1);
   if (n) {
      n[1].ui = mask;
   }
   if (ctx->ExecuteFlag) {
      CALL_StencilMask(ctx->Exec, (mask));
   }
}


static void GLAPIENTRY
save_StencilOp(GLenum fail, GLenum zfail, GLenum zpass)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_STENCIL_OP, 3);
   if (n) {
      n[1].e = fail;
      n[2].e = zfail;
      n[3].e = zpass;
   }
   if (ctx->ExecuteFlag) {
      CALL_StencilOp(ctx->Exec, (fail, zfail, zpass));
   }
}


static void GLAPIENTRY
save_StencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_STENCIL_FUNC_SEPARATE, 4);
   if (n) {
      n[1].e = face;
      n[2].e = func;
      n[3].i = ref;
      n[4].ui = mask;
   }
   if (ctx->ExecuteFlag) {
      CALL_StencilFuncSeparate(ctx->Exec, (face, func, ref, mask));
   }
}


static void GLAPIENTRY
save_StencilFuncSeparateATI(GLenum frontfunc, GLenum backfunc, GLint ref,
                            GLuint mask)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   /* GL_FRONT */
   n = alloc_instruction(ctx, OPCODE_STENCIL_FUNC_SEPARATE, 4);
   if (n) {
      n[1].e = GL_FRONT;
      n[2].e = frontfunc;
      n[3].i = ref;
      n[4].ui = mask;
   }
   /* GL_BACK */
   n = alloc_instruction(ctx, OPCODE_STENCIL_FUNC_SEPARATE, 4);
   if (n) {
      n[1].e = GL_BACK;
      n[2].e = backfunc;
      n[3].i = ref;
      n[4].ui = mask;
   }
   if (ctx->ExecuteFlag) {
      CALL_StencilFuncSeparate(ctx->Exec, (GL_FRONT, frontfunc, ref, mask));
      CALL_StencilFuncSeparate(ctx->Exec, (GL_BACK, backfunc, ref, mask));
   }
}


static void GLAPIENTRY
save_StencilMaskSeparate(GLenum face, GLuint mask)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_STENCIL_MASK_SEPARATE, 2);
   if (n) {
      n[1].e = face;
      n[2].ui = mask;
   }
   if (ctx->ExecuteFlag) {
      CALL_StencilMaskSeparate(ctx->Exec, (face, mask));
   }
}


static void GLAPIENTRY
save_StencilOpSeparate(GLenum face, GLenum fail, GLenum zfail, GLenum zpass)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_STENCIL_OP_SEPARATE, 4);
   if (n) {
      n[1].e = face;
      n[2].e = fail;
      n[3].e = zfail;
      n[4].e = zpass;
   }
   if (ctx->ExecuteFlag) {
      CALL_StencilOpSeparate(ctx->Exec, (face, fail, zfail, zpass));
   }
}


static void GLAPIENTRY
save_TexEnvfv(GLenum target, GLenum pname, const GLfloat *params)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_TEXENV, 6);
   if (n) {
      n[1].e = target;
      n[2].e = pname;
      if (pname == GL_TEXTURE_ENV_COLOR) {
         n[3].f = params[0];
         n[4].f = params[1];
         n[5].f = params[2];
         n[6].f = params[3];
      }
      else {
         n[3].f = params[0];
         n[4].f = n[5].f = n[6].f = 0.0F;
      }
   }
   if (ctx->ExecuteFlag) {
      CALL_TexEnvfv(ctx->Exec, (target, pname, params));
   }
}


static void GLAPIENTRY
save_TexEnvf(GLenum target, GLenum pname, GLfloat param)
{
   GLfloat parray[4];
   parray[0] = (GLfloat) param;
   parray[1] = parray[2] = parray[3] = 0.0F;
   save_TexEnvfv(target, pname, parray);
}


static void GLAPIENTRY
save_TexEnvi(GLenum target, GLenum pname, GLint param)
{
   GLfloat p[4];
   p[0] = (GLfloat) param;
   p[1] = p[2] = p[3] = 0.0F;
   save_TexEnvfv(target, pname, p);
}


static void GLAPIENTRY
save_TexEnviv(GLenum target, GLenum pname, const GLint * param)
{
   GLfloat p[4];
   if (pname == GL_TEXTURE_ENV_COLOR) {
      p[0] = INT_TO_FLOAT(param[0]);
      p[1] = INT_TO_FLOAT(param[1]);
      p[2] = INT_TO_FLOAT(param[2]);
      p[3] = INT_TO_FLOAT(param[3]);
   }
   else {
      p[0] = (GLfloat) param[0];
      p[1] = p[2] = p[3] = 0.0F;
   }
   save_TexEnvfv(target, pname, p);
}


static void GLAPIENTRY
save_TexGenfv(GLenum coord, GLenum pname, const GLfloat *params)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_TEXGEN, 6);
   if (n) {
      n[1].e = coord;
      n[2].e = pname;
      n[3].f = params[0];
      n[4].f = params[1];
      n[5].f = params[2];
      n[6].f = params[3];
   }
   if (ctx->ExecuteFlag) {
      CALL_TexGenfv(ctx->Exec, (coord, pname, params));
   }
}


static void GLAPIENTRY
save_TexGeniv(GLenum coord, GLenum pname, const GLint *params)
{
   GLfloat p[4];
   p[0] = (GLfloat) params[0];
   p[1] = (GLfloat) params[1];
   p[2] = (GLfloat) params[2];
   p[3] = (GLfloat) params[3];
   save_TexGenfv(coord, pname, p);
}


static void GLAPIENTRY
save_TexGend(GLenum coord, GLenum pname, GLdouble param)
{
   GLfloat parray[4];
   parray[0] = (GLfloat) param;
   parray[1] = parray[2] = parray[3] = 0.0F;
   save_TexGenfv(coord, pname, parray);
}


static void GLAPIENTRY
save_TexGendv(GLenum coord, GLenum pname, const GLdouble *params)
{
   GLfloat p[4];
   p[0] = (GLfloat) params[0];
   p[1] = (GLfloat) params[1];
   p[2] = (GLfloat) params[2];
   p[3] = (GLfloat) params[3];
   save_TexGenfv(coord, pname, p);
}


static void GLAPIENTRY
save_TexGenf(GLenum coord, GLenum pname, GLfloat param)
{
   GLfloat parray[4];
   parray[0] = param;
   parray[1] = parray[2] = parray[3] = 0.0F;
   save_TexGenfv(coord, pname, parray);
}


static void GLAPIENTRY
save_TexGeni(GLenum coord, GLenum pname, GLint param)
{
   GLint parray[4];
   parray[0] = param;
   parray[1] = parray[2] = parray[3] = 0;
   save_TexGeniv(coord, pname, parray);
}


static void GLAPIENTRY
save_TexParameterfv(GLenum target, GLenum pname, const GLfloat *params)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_TEXPARAMETER, 6);
   if (n) {
      n[1].e = target;
      n[2].e = pname;
      n[3].f = params[0];
      n[4].f = params[1];
      n[5].f = params[2];
      n[6].f = params[3];
   }
   if (ctx->ExecuteFlag) {
      CALL_TexParameterfv(ctx->Exec, (target, pname, params));
   }
}


static void GLAPIENTRY
save_TexParameterf(GLenum target, GLenum pname, GLfloat param)
{
   GLfloat parray[4];
   parray[0] = param;
   parray[1] = parray[2] = parray[3] = 0.0F;
   save_TexParameterfv(target, pname, parray);
}


static void GLAPIENTRY
save_TexParameteri(GLenum target, GLenum pname, GLint param)
{
   GLfloat fparam[4];
   fparam[0] = (GLfloat) param;
   fparam[1] = fparam[2] = fparam[3] = 0.0F;
   save_TexParameterfv(target, pname, fparam);
}


static void GLAPIENTRY
save_TexParameteriv(GLenum target, GLenum pname, const GLint *params)
{
   GLfloat fparam[4];
   fparam[0] = (GLfloat) params[0];
   fparam[1] = fparam[2] = fparam[3] = 0.0F;
   save_TexParameterfv(target, pname, fparam);
}


static void GLAPIENTRY
save_TexImage1D(GLenum target,
                GLint level, GLint components,
                GLsizei width, GLint border,
                GLenum format, GLenum type, const GLvoid * pixels)
{
   GET_CURRENT_CONTEXT(ctx);
   if (target == GL_PROXY_TEXTURE_1D) {
      /* don't compile, execute immediately */
      CALL_TexImage1D(ctx->Exec, (target, level, components, width,
                                  border, format, type, pixels));
   }
   else {
      Node *n;
      ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
      n = alloc_instruction(ctx, OPCODE_TEX_IMAGE1D, 7 + POINTER_DWORDS);
      if (n) {
         n[1].e = target;
         n[2].i = level;
         n[3].i = components;
         n[4].i = (GLint) width;
         n[5].i = border;
         n[6].e = format;
         n[7].e = type;
         save_pointer(&n[8],
                      unpack_image(ctx, 1, width, 1, 1, format, type,
                                   pixels, &ctx->Unpack));
      }
      if (ctx->ExecuteFlag) {
         CALL_TexImage1D(ctx->Exec, (target, level, components, width,
                                     border, format, type, pixels));
      }
   }
}


static void GLAPIENTRY
save_TexImage2D(GLenum target,
                GLint level, GLint components,
                GLsizei width, GLsizei height, GLint border,
                GLenum format, GLenum type, const GLvoid * pixels)
{
   GET_CURRENT_CONTEXT(ctx);
   if (target == GL_PROXY_TEXTURE_2D) {
      /* don't compile, execute immediately */
      CALL_TexImage2D(ctx->Exec, (target, level, components, width,
                                  height, border, format, type, pixels));
   }
   else {
      Node *n;
      ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
      n = alloc_instruction(ctx, OPCODE_TEX_IMAGE2D, 8 + POINTER_DWORDS);
      if (n) {
         n[1].e = target;
         n[2].i = level;
         n[3].i = components;
         n[4].i = (GLint) width;
         n[5].i = (GLint) height;
         n[6].i = border;
         n[7].e = format;
         n[8].e = type;
         save_pointer(&n[9],
                      unpack_image(ctx, 2, width, height, 1, format, type,
                                   pixels, &ctx->Unpack));
      }
      if (ctx->ExecuteFlag) {
         CALL_TexImage2D(ctx->Exec, (target, level, components, width,
                                     height, border, format, type, pixels));
      }
   }
}


static void GLAPIENTRY
save_TexImage3D(GLenum target,
                GLint level, GLint internalFormat,
                GLsizei width, GLsizei height, GLsizei depth,
                GLint border,
                GLenum format, GLenum type, const GLvoid * pixels)
{
   GET_CURRENT_CONTEXT(ctx);
   if (target == GL_PROXY_TEXTURE_3D) {
      /* don't compile, execute immediately */
      CALL_TexImage3D(ctx->Exec, (target, level, internalFormat, width,
                                  height, depth, border, format, type,
                                  pixels));
   }
   else {
      Node *n;
      ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
      n = alloc_instruction(ctx, OPCODE_TEX_IMAGE3D, 9 + POINTER_DWORDS);
      if (n) {
         n[1].e = target;
         n[2].i = level;
         n[3].i = (GLint) internalFormat;
         n[4].i = (GLint) width;
         n[5].i = (GLint) height;
         n[6].i = (GLint) depth;
         n[7].i = border;
         n[8].e = format;
         n[9].e = type;
         save_pointer(&n[10],
                      unpack_image(ctx, 3, width, height, depth, format, type,
                                   pixels, &ctx->Unpack));
      }
      if (ctx->ExecuteFlag) {
         CALL_TexImage3D(ctx->Exec, (target, level, internalFormat, width,
                                     height, depth, border, format, type,
                                     pixels));
      }
   }
}


static void GLAPIENTRY
save_TexSubImage1D(GLenum target, GLint level, GLint xoffset,
                   GLsizei width, GLenum format, GLenum type,
                   const GLvoid * pixels)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;

   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);

   n = alloc_instruction(ctx, OPCODE_TEX_SUB_IMAGE1D, 6 + POINTER_DWORDS);
   if (n) {
      n[1].e = target;
      n[2].i = level;
      n[3].i = xoffset;
      n[4].i = (GLint) width;
      n[5].e = format;
      n[6].e = type;
      save_pointer(&n[7],
                   unpack_image(ctx, 1, width, 1, 1, format, type,
                                pixels, &ctx->Unpack));
   }
   if (ctx->ExecuteFlag) {
      CALL_TexSubImage1D(ctx->Exec, (target, level, xoffset, width,
                                     format, type, pixels));
   }
}


static void GLAPIENTRY
save_TexSubImage2D(GLenum target, GLint level,
                   GLint xoffset, GLint yoffset,
                   GLsizei width, GLsizei height,
                   GLenum format, GLenum type, const GLvoid * pixels)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;

   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);

   n = alloc_instruction(ctx, OPCODE_TEX_SUB_IMAGE2D, 8 + POINTER_DWORDS);
   if (n) {
      n[1].e = target;
      n[2].i = level;
      n[3].i = xoffset;
      n[4].i = yoffset;
      n[5].i = (GLint) width;
      n[6].i = (GLint) height;
      n[7].e = format;
      n[8].e = type;
      save_pointer(&n[9],
                   unpack_image(ctx, 2, width, height, 1, format, type,
                                pixels, &ctx->Unpack));
   }
   if (ctx->ExecuteFlag) {
      CALL_TexSubImage2D(ctx->Exec, (target, level, xoffset, yoffset,
                                     width, height, format, type, pixels));
   }
}


static void GLAPIENTRY
save_TexSubImage3D(GLenum target, GLint level,
                   GLint xoffset, GLint yoffset, GLint zoffset,
                   GLsizei width, GLsizei height, GLsizei depth,
                   GLenum format, GLenum type, const GLvoid * pixels)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;

   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);

   n = alloc_instruction(ctx, OPCODE_TEX_SUB_IMAGE3D, 10 + POINTER_DWORDS);
   if (n) {
      n[1].e = target;
      n[2].i = level;
      n[3].i = xoffset;
      n[4].i = yoffset;
      n[5].i = zoffset;
      n[6].i = (GLint) width;
      n[7].i = (GLint) height;
      n[8].i = (GLint) depth;
      n[9].e = format;
      n[10].e = type;
      save_pointer(&n[11],
                   unpack_image(ctx, 3, width, height, depth, format, type,
                                pixels, &ctx->Unpack));
   }
   if (ctx->ExecuteFlag) {
      CALL_TexSubImage3D(ctx->Exec, (target, level,
                                     xoffset, yoffset, zoffset,
                                     width, height, depth, format, type,
                                     pixels));
   }
}


static void GLAPIENTRY
save_Translatef(GLfloat x, GLfloat y, GLfloat z)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_TRANSLATE, 3);
   if (n) {
      n[1].f = x;
      n[2].f = y;
      n[3].f = z;
   }
   if (ctx->ExecuteFlag) {
      CALL_Translatef(ctx->Exec, (x, y, z));
   }
}


static void GLAPIENTRY
save_Translated(GLdouble x, GLdouble y, GLdouble z)
{
   save_Translatef((GLfloat) x, (GLfloat) y, (GLfloat) z);
}



static void GLAPIENTRY
save_Viewport(GLint x, GLint y, GLsizei width, GLsizei height)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_VIEWPORT, 4);
   if (n) {
      n[1].i = x;
      n[2].i = y;
      n[3].i = (GLint) width;
      n[4].i = (GLint) height;
   }
   if (ctx->ExecuteFlag) {
      CALL_Viewport(ctx->Exec, (x, y, width, height));
   }
}


static void GLAPIENTRY
save_WindowPos4fMESA(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_WINDOW_POS, 4);
   if (n) {
      n[1].f = x;
      n[2].f = y;
      n[3].f = z;
      n[4].f = w;
   }
   if (ctx->ExecuteFlag) {
      CALL_WindowPos4fMESA(ctx->Exec, (x, y, z, w));
   }
}

static void GLAPIENTRY
save_WindowPos2dMESA(GLdouble x, GLdouble y)
{
   save_WindowPos4fMESA((GLfloat) x, (GLfloat) y, 0.0F, 1.0F);
}

static void GLAPIENTRY
save_WindowPos2fMESA(GLfloat x, GLfloat y)
{
   save_WindowPos4fMESA(x, y, 0.0F, 1.0F);
}

static void GLAPIENTRY
save_WindowPos2iMESA(GLint x, GLint y)
{
   save_WindowPos4fMESA((GLfloat) x, (GLfloat) y, 0.0F, 1.0F);
}

static void GLAPIENTRY
save_WindowPos2sMESA(GLshort x, GLshort y)
{
   save_WindowPos4fMESA(x, y, 0.0F, 1.0F);
}

static void GLAPIENTRY
save_WindowPos3dMESA(GLdouble x, GLdouble y, GLdouble z)
{
   save_WindowPos4fMESA((GLfloat) x, (GLfloat) y, (GLfloat) z, 1.0F);
}

static void GLAPIENTRY
save_WindowPos3fMESA(GLfloat x, GLfloat y, GLfloat z)
{
   save_WindowPos4fMESA(x, y, z, 1.0F);
}

static void GLAPIENTRY
save_WindowPos3iMESA(GLint x, GLint y, GLint z)
{
   save_WindowPos4fMESA((GLfloat) x, (GLfloat) y, (GLfloat) z, 1.0F);
}

static void GLAPIENTRY
save_WindowPos3sMESA(GLshort x, GLshort y, GLshort z)
{
   save_WindowPos4fMESA(x, y, z, 1.0F);
}

static void GLAPIENTRY
save_WindowPos4dMESA(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   save_WindowPos4fMESA((GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) w);
}

static void GLAPIENTRY
save_WindowPos4iMESA(GLint x, GLint y, GLint z, GLint w)
{
   save_WindowPos4fMESA((GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) w);
}

static void GLAPIENTRY
save_WindowPos4sMESA(GLshort x, GLshort y, GLshort z, GLshort w)
{
   save_WindowPos4fMESA(x, y, z, w);
}

static void GLAPIENTRY
save_WindowPos2dvMESA(const GLdouble * v)
{
   save_WindowPos4fMESA((GLfloat) v[0], (GLfloat) v[1], 0.0F, 1.0F);
}

static void GLAPIENTRY
save_WindowPos2fvMESA(const GLfloat * v)
{
   save_WindowPos4fMESA(v[0], v[1], 0.0F, 1.0F);
}

static void GLAPIENTRY
save_WindowPos2ivMESA(const GLint * v)
{
   save_WindowPos4fMESA((GLfloat) v[0], (GLfloat) v[1], 0.0F, 1.0F);
}

static void GLAPIENTRY
save_WindowPos2svMESA(const GLshort * v)
{
   save_WindowPos4fMESA(v[0], v[1], 0.0F, 1.0F);
}

static void GLAPIENTRY
save_WindowPos3dvMESA(const GLdouble * v)
{
   save_WindowPos4fMESA((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], 1.0F);
}

static void GLAPIENTRY
save_WindowPos3fvMESA(const GLfloat * v)
{
   save_WindowPos4fMESA(v[0], v[1], v[2], 1.0F);
}

static void GLAPIENTRY
save_WindowPos3ivMESA(const GLint * v)
{
   save_WindowPos4fMESA((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], 1.0F);
}

static void GLAPIENTRY
save_WindowPos3svMESA(const GLshort * v)
{
   save_WindowPos4fMESA(v[0], v[1], v[2], 1.0F);
}

static void GLAPIENTRY
save_WindowPos4dvMESA(const GLdouble * v)
{
   save_WindowPos4fMESA((GLfloat) v[0], (GLfloat) v[1],
                        (GLfloat) v[2], (GLfloat) v[3]);
}

static void GLAPIENTRY
save_WindowPos4fvMESA(const GLfloat * v)
{
   save_WindowPos4fMESA(v[0], v[1], v[2], v[3]);
}

static void GLAPIENTRY
save_WindowPos4ivMESA(const GLint * v)
{
   save_WindowPos4fMESA((GLfloat) v[0], (GLfloat) v[1],
                        (GLfloat) v[2], (GLfloat) v[3]);
}

static void GLAPIENTRY
save_WindowPos4svMESA(const GLshort * v)
{
   save_WindowPos4fMESA(v[0], v[1], v[2], v[3]);
}



/* GL_ARB_multitexture */
static void GLAPIENTRY
save_ActiveTextureARB(GLenum target)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_ACTIVE_TEXTURE, 1);
   if (n) {
      n[1].e = target;
   }
   if (ctx->ExecuteFlag) {
      CALL_ActiveTexture(ctx->Exec, (target));
   }
}


/* GL_ARB_transpose_matrix */

static void GLAPIENTRY
save_LoadTransposeMatrixdARB(const GLdouble m[16])
{
   GLfloat tm[16];
   _math_transposefd(tm, m);
   save_LoadMatrixf(tm);
}


static void GLAPIENTRY
save_LoadTransposeMatrixfARB(const GLfloat m[16])
{
   GLfloat tm[16];
   _math_transposef(tm, m);
   save_LoadMatrixf(tm);
}


static void GLAPIENTRY
save_MultTransposeMatrixdARB(const GLdouble m[16])
{
   GLfloat tm[16];
   _math_transposefd(tm, m);
   save_MultMatrixf(tm);
}


static void GLAPIENTRY
save_MultTransposeMatrixfARB(const GLfloat m[16])
{
   GLfloat tm[16];
   _math_transposef(tm, m);
   save_MultMatrixf(tm);
}

static GLvoid *copy_data(const GLvoid *data, GLsizei size, const char *func)
{
   GET_CURRENT_CONTEXT(ctx);
   GLvoid *image;

   if (!data)
      return NULL;

   image = malloc(size);
   if (!image) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "%s", func);
      return NULL;
   }
   memcpy(image, data, size);

   return image;
}


/* GL_ARB_texture_compression */
static void GLAPIENTRY
save_CompressedTexImage1DARB(GLenum target, GLint level,
                             GLenum internalFormat, GLsizei width,
                             GLint border, GLsizei imageSize,
                             const GLvoid * data)
{
   GET_CURRENT_CONTEXT(ctx);
   if (target == GL_PROXY_TEXTURE_1D) {
      /* don't compile, execute immediately */
      CALL_CompressedTexImage1D(ctx->Exec, (target, level, internalFormat,
                                               width, border, imageSize,
                                               data));
   }
   else {
      Node *n;
      ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);

      n = alloc_instruction(ctx, OPCODE_COMPRESSED_TEX_IMAGE_1D,
                            6 + POINTER_DWORDS);
      if (n) {
         n[1].e = target;
         n[2].i = level;
         n[3].e = internalFormat;
         n[4].i = (GLint) width;
         n[5].i = border;
         n[6].i = imageSize;
         save_pointer(&n[7],
                      copy_data(data, imageSize, "glCompressedTexImage1DARB"));
      }
      if (ctx->ExecuteFlag) {
         CALL_CompressedTexImage1D(ctx->Exec,
                                      (target, level, internalFormat, width,
                                       border, imageSize, data));
      }
   }
}


static void GLAPIENTRY
save_CompressedTexImage2DARB(GLenum target, GLint level,
                             GLenum internalFormat, GLsizei width,
                             GLsizei height, GLint border, GLsizei imageSize,
                             const GLvoid * data)
{
   GET_CURRENT_CONTEXT(ctx);
   if (target == GL_PROXY_TEXTURE_2D) {
      /* don't compile, execute immediately */
      CALL_CompressedTexImage2D(ctx->Exec, (target, level, internalFormat,
                                               width, height, border,
                                               imageSize, data));
   }
   else {
      Node *n;
      ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);

      n = alloc_instruction(ctx, OPCODE_COMPRESSED_TEX_IMAGE_2D,
                            7 + POINTER_DWORDS);
      if (n) {
         n[1].e = target;
         n[2].i = level;
         n[3].e = internalFormat;
         n[4].i = (GLint) width;
         n[5].i = (GLint) height;
         n[6].i = border;
         n[7].i = imageSize;
         save_pointer(&n[8],
                      copy_data(data, imageSize, "glCompressedTexImage2DARB"));
      }
      if (ctx->ExecuteFlag) {
         CALL_CompressedTexImage2D(ctx->Exec,
                                      (target, level, internalFormat, width,
                                       height, border, imageSize, data));
      }
   }
}


static void GLAPIENTRY
save_CompressedTexImage3DARB(GLenum target, GLint level,
                             GLenum internalFormat, GLsizei width,
                             GLsizei height, GLsizei depth, GLint border,
                             GLsizei imageSize, const GLvoid * data)
{
   GET_CURRENT_CONTEXT(ctx);
   if (target == GL_PROXY_TEXTURE_3D) {
      /* don't compile, execute immediately */
      CALL_CompressedTexImage3D(ctx->Exec, (target, level, internalFormat,
                                               width, height, depth, border,
                                               imageSize, data));
   }
   else {
      Node *n;
      ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);

      n = alloc_instruction(ctx, OPCODE_COMPRESSED_TEX_IMAGE_3D,
                            8 + POINTER_DWORDS);
      if (n) {
         n[1].e = target;
         n[2].i = level;
         n[3].e = internalFormat;
         n[4].i = (GLint) width;
         n[5].i = (GLint) height;
         n[6].i = (GLint) depth;
         n[7].i = border;
         n[8].i = imageSize;
         save_pointer(&n[9],
                      copy_data(data, imageSize, "glCompressedTexImage3DARB"));
      }
      if (ctx->ExecuteFlag) {
         CALL_CompressedTexImage3D(ctx->Exec,
                                      (target, level, internalFormat, width,
                                       height, depth, border, imageSize,
                                       data));
      }
   }
}


static void GLAPIENTRY
save_CompressedTexSubImage1DARB(GLenum target, GLint level, GLint xoffset,
                                GLsizei width, GLenum format,
                                GLsizei imageSize, const GLvoid * data)
{
   Node *n;
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);

   n = alloc_instruction(ctx, OPCODE_COMPRESSED_TEX_SUB_IMAGE_1D,
                         6 + POINTER_DWORDS);
   if (n) {
      n[1].e = target;
      n[2].i = level;
      n[3].i = xoffset;
      n[4].i = (GLint) width;
      n[5].e = format;
      n[6].i = imageSize;
      save_pointer(&n[7],
                   copy_data(data, imageSize, "glCompressedTexSubImage1DARB"));
   }
   if (ctx->ExecuteFlag) {
      CALL_CompressedTexSubImage1D(ctx->Exec, (target, level, xoffset,
                                                  width, format, imageSize,
                                                  data));
   }
}


static void GLAPIENTRY
save_CompressedTexSubImage2DARB(GLenum target, GLint level, GLint xoffset,
                                GLint yoffset, GLsizei width, GLsizei height,
                                GLenum format, GLsizei imageSize,
                                const GLvoid * data)
{
   Node *n;
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);

   n = alloc_instruction(ctx, OPCODE_COMPRESSED_TEX_SUB_IMAGE_2D,
                         8 + POINTER_DWORDS);
   if (n) {
      n[1].e = target;
      n[2].i = level;
      n[3].i = xoffset;
      n[4].i = yoffset;
      n[5].i = (GLint) width;
      n[6].i = (GLint) height;
      n[7].e = format;
      n[8].i = imageSize;
      save_pointer(&n[9],
                   copy_data(data, imageSize, "glCompressedTexSubImage2DARB"));
   }
   if (ctx->ExecuteFlag) {
      CALL_CompressedTexSubImage2D(ctx->Exec,
                                      (target, level, xoffset, yoffset, width,
                                       height, format, imageSize, data));
   }
}


static void GLAPIENTRY
save_CompressedTexSubImage3DARB(GLenum target, GLint level, GLint xoffset,
                                GLint yoffset, GLint zoffset, GLsizei width,
                                GLsizei height, GLsizei depth, GLenum format,
                                GLsizei imageSize, const GLvoid * data)
{
   Node *n;
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);

   n = alloc_instruction(ctx, OPCODE_COMPRESSED_TEX_SUB_IMAGE_3D,
                         10 + POINTER_DWORDS);
   if (n) {
      n[1].e = target;
      n[2].i = level;
      n[3].i = xoffset;
      n[4].i = yoffset;
      n[5].i = zoffset;
      n[6].i = (GLint) width;
      n[7].i = (GLint) height;
      n[8].i = (GLint) depth;
      n[9].e = format;
      n[10].i = imageSize;
      save_pointer(&n[11],
                   copy_data(data, imageSize, "glCompressedTexSubImage3DARB"));
   }
   if (ctx->ExecuteFlag) {
      CALL_CompressedTexSubImage3D(ctx->Exec,
                                      (target, level, xoffset, yoffset,
                                       zoffset, width, height, depth, format,
                                       imageSize, data));
   }
}


/* GL_ARB_multisample */
static void GLAPIENTRY
save_SampleCoverageARB(GLclampf value, GLboolean invert)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_SAMPLE_COVERAGE, 2);
   if (n) {
      n[1].f = value;
      n[2].b = invert;
   }
   if (ctx->ExecuteFlag) {
      CALL_SampleCoverage(ctx->Exec, (value, invert));
   }
}


/*
 * GL_NV_fragment_program
 */
static void GLAPIENTRY
save_BindProgramNV(GLenum target, GLuint id)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_BIND_PROGRAM_NV, 2);
   if (n) {
      n[1].e = target;
      n[2].ui = id;
   }
   if (ctx->ExecuteFlag) {
      CALL_BindProgramARB(ctx->Exec, (target, id));
   }
}

static void GLAPIENTRY
save_ProgramEnvParameter4fARB(GLenum target, GLuint index,
                              GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_PROGRAM_ENV_PARAMETER_ARB, 6);
   if (n) {
      n[1].e = target;
      n[2].ui = index;
      n[3].f = x;
      n[4].f = y;
      n[5].f = z;
      n[6].f = w;
   }
   if (ctx->ExecuteFlag) {
      CALL_ProgramEnvParameter4fARB(ctx->Exec, (target, index, x, y, z, w));
   }
}


static void GLAPIENTRY
save_ProgramEnvParameter4fvARB(GLenum target, GLuint index,
                               const GLfloat *params)
{
   save_ProgramEnvParameter4fARB(target, index, params[0], params[1],
                                 params[2], params[3]);
}


static void GLAPIENTRY
save_ProgramEnvParameters4fvEXT(GLenum target, GLuint index, GLsizei count,
				const GLfloat * params)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);

   if (count > 0) {
      GLint i;
      const GLfloat * p = params;

      for (i = 0 ; i < count ; i++) {
	 n = alloc_instruction(ctx, OPCODE_PROGRAM_ENV_PARAMETER_ARB, 6);
	 if (n) {
	    n[1].e = target;
	    n[2].ui = index;
	    n[3].f = p[0];
	    n[4].f = p[1];
	    n[5].f = p[2];
	    n[6].f = p[3];
	    p += 4;
	 }
      }
   }

   if (ctx->ExecuteFlag) {
      CALL_ProgramEnvParameters4fvEXT(ctx->Exec, (target, index, count, params));
   }
}


static void GLAPIENTRY
save_ProgramEnvParameter4dARB(GLenum target, GLuint index,
                              GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   save_ProgramEnvParameter4fARB(target, index,
                                 (GLfloat) x,
                                 (GLfloat) y, (GLfloat) z, (GLfloat) w);
}


static void GLAPIENTRY
save_ProgramEnvParameter4dvARB(GLenum target, GLuint index,
                               const GLdouble *params)
{
   save_ProgramEnvParameter4fARB(target, index,
                                 (GLfloat) params[0],
                                 (GLfloat) params[1],
                                 (GLfloat) params[2], (GLfloat) params[3]);
}


static void GLAPIENTRY
save_ProgramLocalParameter4fARB(GLenum target, GLuint index,
                                GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_PROGRAM_LOCAL_PARAMETER_ARB, 6);
   if (n) {
      n[1].e = target;
      n[2].ui = index;
      n[3].f = x;
      n[4].f = y;
      n[5].f = z;
      n[6].f = w;
   }
   if (ctx->ExecuteFlag) {
      CALL_ProgramLocalParameter4fARB(ctx->Exec, (target, index, x, y, z, w));
   }
}


static void GLAPIENTRY
save_ProgramLocalParameter4fvARB(GLenum target, GLuint index,
                                 const GLfloat *params)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_PROGRAM_LOCAL_PARAMETER_ARB, 6);
   if (n) {
      n[1].e = target;
      n[2].ui = index;
      n[3].f = params[0];
      n[4].f = params[1];
      n[5].f = params[2];
      n[6].f = params[3];
   }
   if (ctx->ExecuteFlag) {
      CALL_ProgramLocalParameter4fvARB(ctx->Exec, (target, index, params));
   }
}


static void GLAPIENTRY
save_ProgramLocalParameters4fvEXT(GLenum target, GLuint index, GLsizei count,
				  const GLfloat *params)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);

   if (count > 0) {
      GLint i;
      const GLfloat * p = params;

      for (i = 0 ; i < count ; i++) {
	 n = alloc_instruction(ctx, OPCODE_PROGRAM_LOCAL_PARAMETER_ARB, 6);
	 if (n) {
	    n[1].e = target;
	    n[2].ui = index;
	    n[3].f = p[0];
	    n[4].f = p[1];
	    n[5].f = p[2];
	    n[6].f = p[3];
	    p += 4;
	 }
      }
   }

   if (ctx->ExecuteFlag) {
      CALL_ProgramLocalParameters4fvEXT(ctx->Exec, (target, index, count, params));
   }
}


static void GLAPIENTRY
save_ProgramLocalParameter4dARB(GLenum target, GLuint index,
                                GLdouble x, GLdouble y,
                                GLdouble z, GLdouble w)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_PROGRAM_LOCAL_PARAMETER_ARB, 6);
   if (n) {
      n[1].e = target;
      n[2].ui = index;
      n[3].f = (GLfloat) x;
      n[4].f = (GLfloat) y;
      n[5].f = (GLfloat) z;
      n[6].f = (GLfloat) w;
   }
   if (ctx->ExecuteFlag) {
      CALL_ProgramLocalParameter4dARB(ctx->Exec, (target, index, x, y, z, w));
   }
}


static void GLAPIENTRY
save_ProgramLocalParameter4dvARB(GLenum target, GLuint index,
                                 const GLdouble *params)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_PROGRAM_LOCAL_PARAMETER_ARB, 6);
   if (n) {
      n[1].e = target;
      n[2].ui = index;
      n[3].f = (GLfloat) params[0];
      n[4].f = (GLfloat) params[1];
      n[5].f = (GLfloat) params[2];
      n[6].f = (GLfloat) params[3];
   }
   if (ctx->ExecuteFlag) {
      CALL_ProgramLocalParameter4dvARB(ctx->Exec, (target, index, params));
   }
}


/* GL_EXT_stencil_two_side */
static void GLAPIENTRY
save_ActiveStencilFaceEXT(GLenum face)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_ACTIVE_STENCIL_FACE_EXT, 1);
   if (n) {
      n[1].e = face;
   }
   if (ctx->ExecuteFlag) {
      CALL_ActiveStencilFaceEXT(ctx->Exec, (face));
   }
}


/* GL_EXT_depth_bounds_test */
static void GLAPIENTRY
save_DepthBoundsEXT(GLclampd zmin, GLclampd zmax)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_DEPTH_BOUNDS_EXT, 2);
   if (n) {
      n[1].f = (GLfloat) zmin;
      n[2].f = (GLfloat) zmax;
   }
   if (ctx->ExecuteFlag) {
      CALL_DepthBoundsEXT(ctx->Exec, (zmin, zmax));
   }
}



static void GLAPIENTRY
save_ProgramStringARB(GLenum target, GLenum format, GLsizei len,
                      const GLvoid * string)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;

   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);

   n = alloc_instruction(ctx, OPCODE_PROGRAM_STRING_ARB, 3 + POINTER_DWORDS);
   if (n) {
      GLubyte *programCopy = malloc(len);
      if (!programCopy) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glProgramStringARB");
         return;
      }
      memcpy(programCopy, string, len);
      n[1].e = target;
      n[2].e = format;
      n[3].i = len;
      save_pointer(&n[4], programCopy);
   }
   if (ctx->ExecuteFlag) {
      CALL_ProgramStringARB(ctx->Exec, (target, format, len, string));
   }
}


static void GLAPIENTRY
save_BeginQueryARB(GLenum target, GLuint id)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_BEGIN_QUERY_ARB, 2);
   if (n) {
      n[1].e = target;
      n[2].ui = id;
   }
   if (ctx->ExecuteFlag) {
      CALL_BeginQuery(ctx->Exec, (target, id));
   }
}

static void GLAPIENTRY
save_EndQueryARB(GLenum target)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_END_QUERY_ARB, 1);
   if (n) {
      n[1].e = target;
   }
   if (ctx->ExecuteFlag) {
      CALL_EndQuery(ctx->Exec, (target));
   }
}

static void GLAPIENTRY
save_QueryCounter(GLuint id, GLenum target)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_QUERY_COUNTER, 2);
   if (n) {
      n[1].ui = id;
      n[2].e = target;
   }
   if (ctx->ExecuteFlag) {
      CALL_QueryCounter(ctx->Exec, (id, target));
   }
}

static void GLAPIENTRY
save_BeginQueryIndexed(GLenum target, GLuint index, GLuint id)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_BEGIN_QUERY_INDEXED, 3);
   if (n) {
      n[1].e = target;
      n[2].ui = index;
      n[3].ui = id;
   }
   if (ctx->ExecuteFlag) {
      CALL_BeginQueryIndexed(ctx->Exec, (target, index, id));
   }
}

static void GLAPIENTRY
save_EndQueryIndexed(GLenum target, GLuint index)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_END_QUERY_INDEXED, 2);
   if (n) {
      n[1].e = target;
      n[2].ui = index;
   }
   if (ctx->ExecuteFlag) {
      CALL_EndQueryIndexed(ctx->Exec, (target, index));
   }
}


static void GLAPIENTRY
save_DrawBuffersARB(GLsizei count, const GLenum * buffers)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_DRAW_BUFFERS_ARB, 1 + MAX_DRAW_BUFFERS);
   if (n) {
      GLint i;
      n[1].i = count;
      if (count > MAX_DRAW_BUFFERS)
         count = MAX_DRAW_BUFFERS;
      for (i = 0; i < count; i++) {
         n[2 + i].e = buffers[i];
      }
   }
   if (ctx->ExecuteFlag) {
      CALL_DrawBuffers(ctx->Exec, (count, buffers));
   }
}

static void GLAPIENTRY
save_TexBumpParameterfvATI(GLenum pname, const GLfloat *param)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;

   n = alloc_instruction(ctx, OPCODE_TEX_BUMP_PARAMETER_ATI, 5);
   if (n) {
      n[1].ui = pname;
      n[2].f = param[0];
      n[3].f = param[1];
      n[4].f = param[2];
      n[5].f = param[3];
   }
   if (ctx->ExecuteFlag) {
      CALL_TexBumpParameterfvATI(ctx->Exec, (pname, param));
   }
}

static void GLAPIENTRY
save_TexBumpParameterivATI(GLenum pname, const GLint *param)
{
   GLfloat p[4];
   p[0] = INT_TO_FLOAT(param[0]);
   p[1] = INT_TO_FLOAT(param[1]);
   p[2] = INT_TO_FLOAT(param[2]);
   p[3] = INT_TO_FLOAT(param[3]);
   save_TexBumpParameterfvATI(pname, p);
}

static void GLAPIENTRY
save_BindFragmentShaderATI(GLuint id)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;

   n = alloc_instruction(ctx, OPCODE_BIND_FRAGMENT_SHADER_ATI, 1);
   if (n) {
      n[1].ui = id;
   }
   if (ctx->ExecuteFlag) {
      CALL_BindFragmentShaderATI(ctx->Exec, (id));
   }
}

static void GLAPIENTRY
save_SetFragmentShaderConstantATI(GLuint dst, const GLfloat *value)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;

   n = alloc_instruction(ctx, OPCODE_SET_FRAGMENT_SHADER_CONSTANTS_ATI, 5);
   if (n) {
      n[1].ui = dst;
      n[2].f = value[0];
      n[3].f = value[1];
      n[4].f = value[2];
      n[5].f = value[3];
   }
   if (ctx->ExecuteFlag) {
      CALL_SetFragmentShaderConstantATI(ctx->Exec, (dst, value));
   }
}

static void GLAPIENTRY
save_Attr1fNV(GLenum attr, GLfloat x)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   SAVE_FLUSH_VERTICES(ctx);
   n = alloc_instruction(ctx, OPCODE_ATTR_1F_NV, 2);
   if (n) {
      n[1].e = attr;
      n[2].f = x;
   }

   ASSERT(attr < MAX_VERTEX_GENERIC_ATTRIBS);
   ctx->ListState.ActiveAttribSize[attr] = 1;
   ASSIGN_4V(ctx->ListState.CurrentAttrib[attr], x, 0, 0, 1);

   if (ctx->ExecuteFlag) {
      CALL_VertexAttrib1fNV(ctx->Exec, (attr, x));
   }
}

static void GLAPIENTRY
save_Attr2fNV(GLenum attr, GLfloat x, GLfloat y)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   SAVE_FLUSH_VERTICES(ctx);
   n = alloc_instruction(ctx, OPCODE_ATTR_2F_NV, 3);
   if (n) {
      n[1].e = attr;
      n[2].f = x;
      n[3].f = y;
   }

   ASSERT(attr < MAX_VERTEX_GENERIC_ATTRIBS);
   ctx->ListState.ActiveAttribSize[attr] = 2;
   ASSIGN_4V(ctx->ListState.CurrentAttrib[attr], x, y, 0, 1);

   if (ctx->ExecuteFlag) {
      CALL_VertexAttrib2fNV(ctx->Exec, (attr, x, y));
   }
}

static void GLAPIENTRY
save_Attr3fNV(GLenum attr, GLfloat x, GLfloat y, GLfloat z)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   SAVE_FLUSH_VERTICES(ctx);
   n = alloc_instruction(ctx, OPCODE_ATTR_3F_NV, 4);
   if (n) {
      n[1].e = attr;
      n[2].f = x;
      n[3].f = y;
      n[4].f = z;
   }

   ASSERT(attr < MAX_VERTEX_GENERIC_ATTRIBS);
   ctx->ListState.ActiveAttribSize[attr] = 3;
   ASSIGN_4V(ctx->ListState.CurrentAttrib[attr], x, y, z, 1);

   if (ctx->ExecuteFlag) {
      CALL_VertexAttrib3fNV(ctx->Exec, (attr, x, y, z));
   }
}

static void GLAPIENTRY
save_Attr4fNV(GLenum attr, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   SAVE_FLUSH_VERTICES(ctx);
   n = alloc_instruction(ctx, OPCODE_ATTR_4F_NV, 5);
   if (n) {
      n[1].e = attr;
      n[2].f = x;
      n[3].f = y;
      n[4].f = z;
      n[5].f = w;
   }

   ASSERT(attr < MAX_VERTEX_GENERIC_ATTRIBS);
   ctx->ListState.ActiveAttribSize[attr] = 4;
   ASSIGN_4V(ctx->ListState.CurrentAttrib[attr], x, y, z, w);

   if (ctx->ExecuteFlag) {
      CALL_VertexAttrib4fNV(ctx->Exec, (attr, x, y, z, w));
   }
}


static void GLAPIENTRY
save_Attr1fARB(GLenum attr, GLfloat x)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   SAVE_FLUSH_VERTICES(ctx);
   n = alloc_instruction(ctx, OPCODE_ATTR_1F_ARB, 2);
   if (n) {
      n[1].e = attr;
      n[2].f = x;
   }

   ASSERT(attr < MAX_VERTEX_GENERIC_ATTRIBS);
   ctx->ListState.ActiveAttribSize[attr] = 1;
   ASSIGN_4V(ctx->ListState.CurrentAttrib[attr], x, 0, 0, 1);

   if (ctx->ExecuteFlag) {
      CALL_VertexAttrib1fARB(ctx->Exec, (attr, x));
   }
}

static void GLAPIENTRY
save_Attr2fARB(GLenum attr, GLfloat x, GLfloat y)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   SAVE_FLUSH_VERTICES(ctx);
   n = alloc_instruction(ctx, OPCODE_ATTR_2F_ARB, 3);
   if (n) {
      n[1].e = attr;
      n[2].f = x;
      n[3].f = y;
   }

   ASSERT(attr < MAX_VERTEX_GENERIC_ATTRIBS);
   ctx->ListState.ActiveAttribSize[attr] = 2;
   ASSIGN_4V(ctx->ListState.CurrentAttrib[attr], x, y, 0, 1);

   if (ctx->ExecuteFlag) {
      CALL_VertexAttrib2fARB(ctx->Exec, (attr, x, y));
   }
}

static void GLAPIENTRY
save_Attr3fARB(GLenum attr, GLfloat x, GLfloat y, GLfloat z)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   SAVE_FLUSH_VERTICES(ctx);
   n = alloc_instruction(ctx, OPCODE_ATTR_3F_ARB, 4);
   if (n) {
      n[1].e = attr;
      n[2].f = x;
      n[3].f = y;
      n[4].f = z;
   }

   ASSERT(attr < MAX_VERTEX_GENERIC_ATTRIBS);
   ctx->ListState.ActiveAttribSize[attr] = 3;
   ASSIGN_4V(ctx->ListState.CurrentAttrib[attr], x, y, z, 1);

   if (ctx->ExecuteFlag) {
      CALL_VertexAttrib3fARB(ctx->Exec, (attr, x, y, z));
   }
}

static void GLAPIENTRY
save_Attr4fARB(GLenum attr, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   SAVE_FLUSH_VERTICES(ctx);
   n = alloc_instruction(ctx, OPCODE_ATTR_4F_ARB, 5);
   if (n) {
      n[1].e = attr;
      n[2].f = x;
      n[3].f = y;
      n[4].f = z;
      n[5].f = w;
   }

   ASSERT(attr < MAX_VERTEX_GENERIC_ATTRIBS);
   ctx->ListState.ActiveAttribSize[attr] = 4;
   ASSIGN_4V(ctx->ListState.CurrentAttrib[attr], x, y, z, w);

   if (ctx->ExecuteFlag) {
      CALL_VertexAttrib4fARB(ctx->Exec, (attr, x, y, z, w));
   }
}


static void GLAPIENTRY
save_EvalCoord1f(GLfloat x)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   SAVE_FLUSH_VERTICES(ctx);
   n = alloc_instruction(ctx, OPCODE_EVAL_C1, 1);
   if (n) {
      n[1].f = x;
   }
   if (ctx->ExecuteFlag) {
      CALL_EvalCoord1f(ctx->Exec, (x));
   }
}

static void GLAPIENTRY
save_EvalCoord1fv(const GLfloat * v)
{
   save_EvalCoord1f(v[0]);
}

static void GLAPIENTRY
save_EvalCoord2f(GLfloat x, GLfloat y)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   SAVE_FLUSH_VERTICES(ctx);
   n = alloc_instruction(ctx, OPCODE_EVAL_C2, 2);
   if (n) {
      n[1].f = x;
      n[2].f = y;
   }
   if (ctx->ExecuteFlag) {
      CALL_EvalCoord2f(ctx->Exec, (x, y));
   }
}

static void GLAPIENTRY
save_EvalCoord2fv(const GLfloat * v)
{
   save_EvalCoord2f(v[0], v[1]);
}


static void GLAPIENTRY
save_EvalPoint1(GLint x)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   SAVE_FLUSH_VERTICES(ctx);
   n = alloc_instruction(ctx, OPCODE_EVAL_P1, 1);
   if (n) {
      n[1].i = x;
   }
   if (ctx->ExecuteFlag) {
      CALL_EvalPoint1(ctx->Exec, (x));
   }
}

static void GLAPIENTRY
save_EvalPoint2(GLint x, GLint y)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   SAVE_FLUSH_VERTICES(ctx);
   n = alloc_instruction(ctx, OPCODE_EVAL_P2, 2);
   if (n) {
      n[1].i = x;
      n[2].i = y;
   }
   if (ctx->ExecuteFlag) {
      CALL_EvalPoint2(ctx->Exec, (x, y));
   }
}

static void GLAPIENTRY
save_Indexf(GLfloat x)
{
   save_Attr1fNV(VERT_ATTRIB_COLOR_INDEX, x);
}

static void GLAPIENTRY
save_Indexfv(const GLfloat * v)
{
   save_Attr1fNV(VERT_ATTRIB_COLOR_INDEX, v[0]);
}

static void GLAPIENTRY
save_EdgeFlag(GLboolean x)
{
   save_Attr1fNV(VERT_ATTRIB_EDGEFLAG, x ? 1.0f : 0.0f);
}


/**
 * Compare 'count' elements of vectors 'a' and 'b'.
 * \return GL_TRUE if equal, GL_FALSE if different.
 */
static inline GLboolean
compare_vec(const GLfloat *a, const GLfloat *b, GLuint count)
{
   return memcmp( a, b, count * sizeof(GLfloat) ) == 0;
}


/**
 * This glMaterial function is used for glMaterial calls that are outside
 * a glBegin/End pair.  For glMaterial inside glBegin/End, see the VBO code.
 */
static void GLAPIENTRY
save_Materialfv(GLenum face, GLenum pname, const GLfloat * param)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   int args, i;
   GLuint bitmask;

   switch (face) {
   case GL_BACK:
   case GL_FRONT:
   case GL_FRONT_AND_BACK:
      break;
   default:
      _mesa_compile_error(ctx, GL_INVALID_ENUM, "glMaterial(face)");
      return;
   }

   switch (pname) {
   case GL_EMISSION:
   case GL_AMBIENT:
   case GL_DIFFUSE:
   case GL_SPECULAR:
   case GL_AMBIENT_AND_DIFFUSE:
      args = 4;
      break;
   case GL_SHININESS:
      args = 1;
      break;
   case GL_COLOR_INDEXES:
      args = 3;
      break;
   default:
      _mesa_compile_error(ctx, GL_INVALID_ENUM, "glMaterial(pname)");
      return;
   }
   
   if (ctx->ExecuteFlag) {
      CALL_Materialfv(ctx->Exec, (face, pname, param));
   }

   bitmask = _mesa_material_bitmask(ctx, face, pname, ~0, NULL);

   /* Try to eliminate redundant statechanges.  Because it is legal to
    * call glMaterial even inside begin/end calls, don't need to worry
    * about ctx->Driver.CurrentSavePrimitive here.
    */
   for (i = 0; i < MAT_ATTRIB_MAX; i++) {
      if (bitmask & (1 << i)) {
         if (ctx->ListState.ActiveMaterialSize[i] == args &&
             compare_vec(ctx->ListState.CurrentMaterial[i], param, args)) {
            /* no change in material value */
            bitmask &= ~(1 << i);
         }
         else {
            ctx->ListState.ActiveMaterialSize[i] = args;
            COPY_SZ_4V(ctx->ListState.CurrentMaterial[i], args, param);
         }
      }
   }

   /* If this call has no effect, return early */
   if (bitmask == 0)
      return;

   SAVE_FLUSH_VERTICES(ctx);

   n = alloc_instruction(ctx, OPCODE_MATERIAL, 6);
   if (n) {
      n[1].e = face;
      n[2].e = pname;
      for (i = 0; i < args; i++)
         n[3 + i].f = param[i];
   }
}

static void GLAPIENTRY
save_Begin(GLenum mode)
{
   GET_CURRENT_CONTEXT(ctx);

   if (!_mesa_is_valid_prim_mode(ctx, mode)) {
      /* compile this error into the display list */
      _mesa_compile_error(ctx, GL_INVALID_ENUM, "glBegin(mode)");
   }
   else if (_mesa_inside_dlist_begin_end(ctx)) {
      /* compile this error into the display list */
      _mesa_compile_error(ctx, GL_INVALID_OPERATION, "recursive glBegin");
   }
   else {
      Node *n;

      ctx->Driver.CurrentSavePrimitive = mode;

      /* Give the driver an opportunity to hook in an optimized
       * display list compiler.
       */
      if (ctx->Driver.NotifySaveBegin(ctx, mode))
         return;

      SAVE_FLUSH_VERTICES(ctx);
      n = alloc_instruction(ctx, OPCODE_BEGIN, 1);
      if (n) {
         n[1].e = mode;
      }

      if (ctx->ExecuteFlag) {
         CALL_Begin(ctx->Exec, (mode));
      }
   }
}

static void GLAPIENTRY
save_End(void)
{
   GET_CURRENT_CONTEXT(ctx);
   SAVE_FLUSH_VERTICES(ctx);
   (void) alloc_instruction(ctx, OPCODE_END, 0);
   ctx->Driver.CurrentSavePrimitive = PRIM_OUTSIDE_BEGIN_END;
   if (ctx->ExecuteFlag) {
      CALL_End(ctx->Exec, ());
   }
}

static void GLAPIENTRY
save_Rectf(GLfloat a, GLfloat b, GLfloat c, GLfloat d)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_RECTF, 4);
   if (n) {
      n[1].f = a;
      n[2].f = b;
      n[3].f = c;
      n[4].f = d;
   }
   if (ctx->ExecuteFlag) {
      CALL_Rectf(ctx->Exec, (a, b, c, d));
   }
}


static void GLAPIENTRY
save_Vertex2f(GLfloat x, GLfloat y)
{
   save_Attr2fNV(VERT_ATTRIB_POS, x, y);
}

static void GLAPIENTRY
save_Vertex2fv(const GLfloat * v)
{
   save_Attr2fNV(VERT_ATTRIB_POS, v[0], v[1]);
}

static void GLAPIENTRY
save_Vertex3f(GLfloat x, GLfloat y, GLfloat z)
{
   save_Attr3fNV(VERT_ATTRIB_POS, x, y, z);
}

static void GLAPIENTRY
save_Vertex3fv(const GLfloat * v)
{
   save_Attr3fNV(VERT_ATTRIB_POS, v[0], v[1], v[2]);
}

static void GLAPIENTRY
save_Vertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   save_Attr4fNV(VERT_ATTRIB_POS, x, y, z, w);
}

static void GLAPIENTRY
save_Vertex4fv(const GLfloat * v)
{
   save_Attr4fNV(VERT_ATTRIB_POS, v[0], v[1], v[2], v[3]);
}

static void GLAPIENTRY
save_TexCoord1f(GLfloat x)
{
   save_Attr1fNV(VERT_ATTRIB_TEX0, x);
}

static void GLAPIENTRY
save_TexCoord1fv(const GLfloat * v)
{
   save_Attr1fNV(VERT_ATTRIB_TEX0, v[0]);
}

static void GLAPIENTRY
save_TexCoord2f(GLfloat x, GLfloat y)
{
   save_Attr2fNV(VERT_ATTRIB_TEX0, x, y);
}

static void GLAPIENTRY
save_TexCoord2fv(const GLfloat * v)
{
   save_Attr2fNV(VERT_ATTRIB_TEX0, v[0], v[1]);
}

static void GLAPIENTRY
save_TexCoord3f(GLfloat x, GLfloat y, GLfloat z)
{
   save_Attr3fNV(VERT_ATTRIB_TEX0, x, y, z);
}

static void GLAPIENTRY
save_TexCoord3fv(const GLfloat * v)
{
   save_Attr3fNV(VERT_ATTRIB_TEX0, v[0], v[1], v[2]);
}

static void GLAPIENTRY
save_TexCoord4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   save_Attr4fNV(VERT_ATTRIB_TEX0, x, y, z, w);
}

static void GLAPIENTRY
save_TexCoord4fv(const GLfloat * v)
{
   save_Attr4fNV(VERT_ATTRIB_TEX0, v[0], v[1], v[2], v[3]);
}

static void GLAPIENTRY
save_Normal3f(GLfloat x, GLfloat y, GLfloat z)
{
   save_Attr3fNV(VERT_ATTRIB_NORMAL, x, y, z);
}

static void GLAPIENTRY
save_Normal3fv(const GLfloat * v)
{
   save_Attr3fNV(VERT_ATTRIB_NORMAL, v[0], v[1], v[2]);
}

static void GLAPIENTRY
save_FogCoordfEXT(GLfloat x)
{
   save_Attr1fNV(VERT_ATTRIB_FOG, x);
}

static void GLAPIENTRY
save_FogCoordfvEXT(const GLfloat * v)
{
   save_Attr1fNV(VERT_ATTRIB_FOG, v[0]);
}

static void GLAPIENTRY
save_Color3f(GLfloat x, GLfloat y, GLfloat z)
{
   save_Attr3fNV(VERT_ATTRIB_COLOR0, x, y, z);
}

static void GLAPIENTRY
save_Color3fv(const GLfloat * v)
{
   save_Attr3fNV(VERT_ATTRIB_COLOR0, v[0], v[1], v[2]);
}

static void GLAPIENTRY
save_Color4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   save_Attr4fNV(VERT_ATTRIB_COLOR0, x, y, z, w);
}

static void GLAPIENTRY
save_Color4fv(const GLfloat * v)
{
   save_Attr4fNV(VERT_ATTRIB_COLOR0, v[0], v[1], v[2], v[3]);
}

static void GLAPIENTRY
save_SecondaryColor3fEXT(GLfloat x, GLfloat y, GLfloat z)
{
   save_Attr3fNV(VERT_ATTRIB_COLOR1, x, y, z);
}

static void GLAPIENTRY
save_SecondaryColor3fvEXT(const GLfloat * v)
{
   save_Attr3fNV(VERT_ATTRIB_COLOR1, v[0], v[1], v[2]);
}


/* Just call the respective ATTR for texcoord
 */
static void GLAPIENTRY
save_MultiTexCoord1f(GLenum target, GLfloat x)
{
   GLuint attr = (target & 0x7) + VERT_ATTRIB_TEX0;
   save_Attr1fNV(attr, x);
}

static void GLAPIENTRY
save_MultiTexCoord1fv(GLenum target, const GLfloat * v)
{
   GLuint attr = (target & 0x7) + VERT_ATTRIB_TEX0;
   save_Attr1fNV(attr, v[0]);
}

static void GLAPIENTRY
save_MultiTexCoord2f(GLenum target, GLfloat x, GLfloat y)
{
   GLuint attr = (target & 0x7) + VERT_ATTRIB_TEX0;
   save_Attr2fNV(attr, x, y);
}

static void GLAPIENTRY
save_MultiTexCoord2fv(GLenum target, const GLfloat * v)
{
   GLuint attr = (target & 0x7) + VERT_ATTRIB_TEX0;
   save_Attr2fNV(attr, v[0], v[1]);
}

static void GLAPIENTRY
save_MultiTexCoord3f(GLenum target, GLfloat x, GLfloat y, GLfloat z)
{
   GLuint attr = (target & 0x7) + VERT_ATTRIB_TEX0;
   save_Attr3fNV(attr, x, y, z);
}

static void GLAPIENTRY
save_MultiTexCoord3fv(GLenum target, const GLfloat * v)
{
   GLuint attr = (target & 0x7) + VERT_ATTRIB_TEX0;
   save_Attr3fNV(attr, v[0], v[1], v[2]);
}

static void GLAPIENTRY
save_MultiTexCoord4f(GLenum target, GLfloat x, GLfloat y,
                     GLfloat z, GLfloat w)
{
   GLuint attr = (target & 0x7) + VERT_ATTRIB_TEX0;
   save_Attr4fNV(attr, x, y, z, w);
}

static void GLAPIENTRY
save_MultiTexCoord4fv(GLenum target, const GLfloat * v)
{
   GLuint attr = (target & 0x7) + VERT_ATTRIB_TEX0;
   save_Attr4fNV(attr, v[0], v[1], v[2], v[3]);
}


/**
 * Record a GL_INVALID_VALUE error when a invalid vertex attribute
 * index is found.
 */
static void
index_error(void)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_error(ctx, GL_INVALID_VALUE, "VertexAttribf(index)");
}



static void GLAPIENTRY
save_VertexAttrib1fARB(GLuint index, GLfloat x)
{
   if (index < MAX_VERTEX_GENERIC_ATTRIBS)
      save_Attr1fARB(index, x);
   else
      index_error();
}

static void GLAPIENTRY
save_VertexAttrib1fvARB(GLuint index, const GLfloat * v)
{
   if (index < MAX_VERTEX_GENERIC_ATTRIBS)
      save_Attr1fARB(index, v[0]);
   else
      index_error();
}

static void GLAPIENTRY
save_VertexAttrib2fARB(GLuint index, GLfloat x, GLfloat y)
{
   if (index < MAX_VERTEX_GENERIC_ATTRIBS)
      save_Attr2fARB(index, x, y);
   else
      index_error();
}

static void GLAPIENTRY
save_VertexAttrib2fvARB(GLuint index, const GLfloat * v)
{
   if (index < MAX_VERTEX_GENERIC_ATTRIBS)
      save_Attr2fARB(index, v[0], v[1]);
   else
      index_error();
}

static void GLAPIENTRY
save_VertexAttrib3fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z)
{
   if (index < MAX_VERTEX_GENERIC_ATTRIBS)
      save_Attr3fARB(index, x, y, z);
   else
      index_error();
}

static void GLAPIENTRY
save_VertexAttrib3fvARB(GLuint index, const GLfloat * v)
{
   if (index < MAX_VERTEX_GENERIC_ATTRIBS)
      save_Attr3fARB(index, v[0], v[1], v[2]);
   else
      index_error();
}

static void GLAPIENTRY
save_VertexAttrib4fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z,
                       GLfloat w)
{
   if (index < MAX_VERTEX_GENERIC_ATTRIBS)
      save_Attr4fARB(index, x, y, z, w);
   else
      index_error();
}

static void GLAPIENTRY
save_VertexAttrib4fvARB(GLuint index, const GLfloat * v)
{
   if (index < MAX_VERTEX_GENERIC_ATTRIBS)
      save_Attr4fARB(index, v[0], v[1], v[2], v[3]);
   else
      index_error();
}

static void GLAPIENTRY
save_BlitFramebufferEXT(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1,
                        GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1,
                        GLbitfield mask, GLenum filter)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_BLIT_FRAMEBUFFER, 10);
   if (n) {
      n[1].i = srcX0;
      n[2].i = srcY0;
      n[3].i = srcX1;
      n[4].i = srcY1;
      n[5].i = dstX0;
      n[6].i = dstY0;
      n[7].i = dstX1;
      n[8].i = dstY1;
      n[9].i = mask;
      n[10].e = filter;
   }
   if (ctx->ExecuteFlag) {
      CALL_BlitFramebuffer(ctx->Exec, (srcX0, srcY0, srcX1, srcY1,
                                          dstX0, dstY0, dstX1, dstY1,
                                          mask, filter));
   }
}


/** GL_EXT_provoking_vertex */
static void GLAPIENTRY
save_ProvokingVertexEXT(GLenum mode)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_PROVOKING_VERTEX, 1);
   if (n) {
      n[1].e = mode;
   }
   if (ctx->ExecuteFlag) {
      /*CALL_ProvokingVertex(ctx->Exec, (mode));*/
      _mesa_ProvokingVertex(mode);
   }
}


/** GL_EXT_transform_feedback */
static void GLAPIENTRY
save_BeginTransformFeedback(GLenum mode)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_BEGIN_TRANSFORM_FEEDBACK, 1);
   if (n) {
      n[1].e = mode;
   }
   if (ctx->ExecuteFlag) {
      CALL_BeginTransformFeedback(ctx->Exec, (mode));
   }
}


/** GL_EXT_transform_feedback */
static void GLAPIENTRY
save_EndTransformFeedback(void)
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   (void) alloc_instruction(ctx, OPCODE_END_TRANSFORM_FEEDBACK, 0);
   if (ctx->ExecuteFlag) {
      CALL_EndTransformFeedback(ctx->Exec, ());
   }
}

static void GLAPIENTRY
save_BindTransformFeedback(GLenum target, GLuint name)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_BIND_TRANSFORM_FEEDBACK, 2);
   if (n) {
      n[1].e = target;
      n[2].ui = name;
   }
   if (ctx->ExecuteFlag) {
      CALL_BindTransformFeedback(ctx->Exec, (target, name));
   }
}

static void GLAPIENTRY
save_PauseTransformFeedback(void)
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   (void) alloc_instruction(ctx, OPCODE_PAUSE_TRANSFORM_FEEDBACK, 0);
   if (ctx->ExecuteFlag) {
      CALL_PauseTransformFeedback(ctx->Exec, ());
   }
}

static void GLAPIENTRY
save_ResumeTransformFeedback(void)
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   (void) alloc_instruction(ctx, OPCODE_RESUME_TRANSFORM_FEEDBACK, 0);
   if (ctx->ExecuteFlag) {
      CALL_ResumeTransformFeedback(ctx->Exec, ());
   }
}

static void GLAPIENTRY
save_DrawTransformFeedback(GLenum mode, GLuint name)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_DRAW_TRANSFORM_FEEDBACK, 2);
   if (n) {
      n[1].e = mode;
      n[2].ui = name;
   }
   if (ctx->ExecuteFlag) {
      CALL_DrawTransformFeedback(ctx->Exec, (mode, name));
   }
}

static void GLAPIENTRY
save_DrawTransformFeedbackStream(GLenum mode, GLuint name, GLuint stream)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_DRAW_TRANSFORM_FEEDBACK_STREAM, 3);
   if (n) {
      n[1].e = mode;
      n[2].ui = name;
      n[3].ui = stream;
   }
   if (ctx->ExecuteFlag) {
      CALL_DrawTransformFeedbackStream(ctx->Exec, (mode, name, stream));
   }
}

static void GLAPIENTRY
save_DrawTransformFeedbackInstanced(GLenum mode, GLuint name,
                                    GLsizei primcount)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_DRAW_TRANSFORM_FEEDBACK_INSTANCED, 3);
   if (n) {
      n[1].e = mode;
      n[2].ui = name;
      n[3].si = primcount;
   }
   if (ctx->ExecuteFlag) {
      CALL_DrawTransformFeedbackInstanced(ctx->Exec, (mode, name, primcount));
   }
}

static void GLAPIENTRY
save_DrawTransformFeedbackStreamInstanced(GLenum mode, GLuint name,
                                          GLuint stream, GLsizei primcount)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_DRAW_TRANSFORM_FEEDBACK_STREAM_INSTANCED, 4);
   if (n) {
      n[1].e = mode;
      n[2].ui = name;
      n[3].ui = stream;
      n[4].si = primcount;
   }
   if (ctx->ExecuteFlag) {
      CALL_DrawTransformFeedbackStreamInstanced(ctx->Exec, (mode, name, stream,
                                                            primcount));
   }
}

/* aka UseProgram() */
static void GLAPIENTRY
save_UseProgramObjectARB(GLhandleARB program)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_USE_PROGRAM, 1);
   if (n) {
      n[1].ui = program;
   }
   if (ctx->ExecuteFlag) {
      CALL_UseProgram(ctx->Exec, (program));
   }
}


static void GLAPIENTRY
save_Uniform1fARB(GLint location, GLfloat x)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_1F, 2);
   if (n) {
      n[1].i = location;
      n[2].f = x;
   }
   if (ctx->ExecuteFlag) {
      CALL_Uniform1f(ctx->Exec, (location, x));
   }
}


static void GLAPIENTRY
save_Uniform2fARB(GLint location, GLfloat x, GLfloat y)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_2F, 3);
   if (n) {
      n[1].i = location;
      n[2].f = x;
      n[3].f = y;
   }
   if (ctx->ExecuteFlag) {
      CALL_Uniform2f(ctx->Exec, (location, x, y));
   }
}


static void GLAPIENTRY
save_Uniform3fARB(GLint location, GLfloat x, GLfloat y, GLfloat z)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_3F, 4);
   if (n) {
      n[1].i = location;
      n[2].f = x;
      n[3].f = y;
      n[4].f = z;
   }
   if (ctx->ExecuteFlag) {
      CALL_Uniform3f(ctx->Exec, (location, x, y, z));
   }
}


static void GLAPIENTRY
save_Uniform4fARB(GLint location, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_4F, 5);
   if (n) {
      n[1].i = location;
      n[2].f = x;
      n[3].f = y;
      n[4].f = z;
      n[5].f = w;
   }
   if (ctx->ExecuteFlag) {
      CALL_Uniform4f(ctx->Exec, (location, x, y, z, w));
   }
}


static void GLAPIENTRY
save_Uniform1fvARB(GLint location, GLsizei count, const GLfloat *v)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_1FV, 2 + POINTER_DWORDS);
   if (n) {
      n[1].i = location;
      n[2].i = count;
      save_pointer(&n[3], memdup(v, count * 1 * sizeof(GLfloat)));
   }
   if (ctx->ExecuteFlag) {
      CALL_Uniform1fv(ctx->Exec, (location, count, v));
   }
}

static void GLAPIENTRY
save_Uniform2fvARB(GLint location, GLsizei count, const GLfloat *v)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_2FV, 2 + POINTER_DWORDS);
   if (n) {
      n[1].i = location;
      n[2].i = count;
      save_pointer(&n[3], memdup(v, count * 2 * sizeof(GLfloat)));
   }
   if (ctx->ExecuteFlag) {
      CALL_Uniform2fv(ctx->Exec, (location, count, v));
   }
}

static void GLAPIENTRY
save_Uniform3fvARB(GLint location, GLsizei count, const GLfloat *v)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_3FV, 2 + POINTER_DWORDS);
   if (n) {
      n[1].i = location;
      n[2].i = count;
      save_pointer(&n[3], memdup(v, count * 3 * sizeof(GLfloat)));
   }
   if (ctx->ExecuteFlag) {
      CALL_Uniform3fv(ctx->Exec, (location, count, v));
   }
}

static void GLAPIENTRY
save_Uniform4fvARB(GLint location, GLsizei count, const GLfloat *v)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_4FV, 2 + POINTER_DWORDS);
   if (n) {
      n[1].i = location;
      n[2].i = count;
      save_pointer(&n[3], memdup(v, count * 4 * sizeof(GLfloat)));
   }
   if (ctx->ExecuteFlag) {
      CALL_Uniform4fv(ctx->Exec, (location, count, v));
   }
}


static void GLAPIENTRY
save_Uniform1iARB(GLint location, GLint x)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_1I, 2);
   if (n) {
      n[1].i = location;
      n[2].i = x;
   }
   if (ctx->ExecuteFlag) {
      CALL_Uniform1i(ctx->Exec, (location, x));
   }
}

static void GLAPIENTRY
save_Uniform2iARB(GLint location, GLint x, GLint y)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_2I, 3);
   if (n) {
      n[1].i = location;
      n[2].i = x;
      n[3].i = y;
   }
   if (ctx->ExecuteFlag) {
      CALL_Uniform2i(ctx->Exec, (location, x, y));
   }
}

static void GLAPIENTRY
save_Uniform3iARB(GLint location, GLint x, GLint y, GLint z)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_3I, 4);
   if (n) {
      n[1].i = location;
      n[2].i = x;
      n[3].i = y;
      n[4].i = z;
   }
   if (ctx->ExecuteFlag) {
      CALL_Uniform3i(ctx->Exec, (location, x, y, z));
   }
}

static void GLAPIENTRY
save_Uniform4iARB(GLint location, GLint x, GLint y, GLint z, GLint w)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_4I, 5);
   if (n) {
      n[1].i = location;
      n[2].i = x;
      n[3].i = y;
      n[4].i = z;
      n[5].i = w;
   }
   if (ctx->ExecuteFlag) {
      CALL_Uniform4i(ctx->Exec, (location, x, y, z, w));
   }
}



static void GLAPIENTRY
save_Uniform1ivARB(GLint location, GLsizei count, const GLint *v)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_1IV, 2 + POINTER_DWORDS);
   if (n) {
      n[1].i = location;
      n[2].i = count;
      save_pointer(&n[3], memdup(v, count * 1 * sizeof(GLint)));
   }
   if (ctx->ExecuteFlag) {
      CALL_Uniform1iv(ctx->Exec, (location, count, v));
   }
}

static void GLAPIENTRY
save_Uniform2ivARB(GLint location, GLsizei count, const GLint *v)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_2IV, 2 + POINTER_DWORDS);
   if (n) {
      n[1].i = location;
      n[2].i = count;
      save_pointer(&n[3], memdup(v, count * 2 * sizeof(GLint)));
   }
   if (ctx->ExecuteFlag) {
      CALL_Uniform2iv(ctx->Exec, (location, count, v));
   }
}

static void GLAPIENTRY
save_Uniform3ivARB(GLint location, GLsizei count, const GLint *v)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_3IV, 2 + POINTER_DWORDS);
   if (n) {
      n[1].i = location;
      n[2].i = count;
      save_pointer(&n[3], memdup(v, count * 3 * sizeof(GLint)));
   }
   if (ctx->ExecuteFlag) {
      CALL_Uniform3iv(ctx->Exec, (location, count, v));
   }
}

static void GLAPIENTRY
save_Uniform4ivARB(GLint location, GLsizei count, const GLint *v)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_4IV, 2 + POINTER_DWORDS);
   if (n) {
      n[1].i = location;
      n[2].i = count;
      save_pointer(&n[3], memdup(v, count * 4 * sizeof(GLfloat)));
   }
   if (ctx->ExecuteFlag) {
      CALL_Uniform4iv(ctx->Exec, (location, count, v));
   }
}



static void GLAPIENTRY
save_Uniform1ui(GLint location, GLuint x)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_1UI, 2);
   if (n) {
      n[1].i = location;
      n[2].i = x;
   }
   if (ctx->ExecuteFlag) {
      /*CALL_Uniform1ui(ctx->Exec, (location, x));*/
   }
}

static void GLAPIENTRY
save_Uniform2ui(GLint location, GLuint x, GLuint y)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_2UI, 3);
   if (n) {
      n[1].i = location;
      n[2].i = x;
      n[3].i = y;
   }
   if (ctx->ExecuteFlag) {
      /*CALL_Uniform2ui(ctx->Exec, (location, x, y));*/
   }
}

static void GLAPIENTRY
save_Uniform3ui(GLint location, GLuint x, GLuint y, GLuint z)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_3UI, 4);
   if (n) {
      n[1].i = location;
      n[2].i = x;
      n[3].i = y;
      n[4].i = z;
   }
   if (ctx->ExecuteFlag) {
      /*CALL_Uniform3ui(ctx->Exec, (location, x, y, z));*/
   }
}

static void GLAPIENTRY
save_Uniform4ui(GLint location, GLuint x, GLuint y, GLuint z, GLuint w)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_4UI, 5);
   if (n) {
      n[1].i = location;
      n[2].i = x;
      n[3].i = y;
      n[4].i = z;
      n[5].i = w;
   }
   if (ctx->ExecuteFlag) {
      /*CALL_Uniform4ui(ctx->Exec, (location, x, y, z, w));*/
   }
}



static void GLAPIENTRY
save_Uniform1uiv(GLint location, GLsizei count, const GLuint *v)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_1UIV, 2 + POINTER_DWORDS);
   if (n) {
      n[1].i = location;
      n[2].i = count;
      save_pointer(&n[3], memdup(v, count * 1 * sizeof(*v)));
   }
   if (ctx->ExecuteFlag) {
      /*CALL_Uniform1uiv(ctx->Exec, (location, count, v));*/
   }
}

static void GLAPIENTRY
save_Uniform2uiv(GLint location, GLsizei count, const GLuint *v)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_2UIV, 2 + POINTER_DWORDS);
   if (n) {
      n[1].i = location;
      n[2].i = count;
      save_pointer(&n[3], memdup(v, count * 2 * sizeof(*v)));
   }
   if (ctx->ExecuteFlag) {
      /*CALL_Uniform2uiv(ctx->Exec, (location, count, v));*/
   }
}

static void GLAPIENTRY
save_Uniform3uiv(GLint location, GLsizei count, const GLuint *v)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_3UIV, 2 + POINTER_DWORDS);
   if (n) {
      n[1].i = location;
      n[2].i = count;
      save_pointer(&n[3], memdup(v, count * 3 * sizeof(*v)));
   }
   if (ctx->ExecuteFlag) {
      /*CALL_Uniform3uiv(ctx->Exec, (location, count, v));*/
   }
}

static void GLAPIENTRY
save_Uniform4uiv(GLint location, GLsizei count, const GLuint *v)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_4UIV, 2 + POINTER_DWORDS);
   if (n) {
      n[1].i = location;
      n[2].i = count;
      save_pointer(&n[3], memdup(v, count * 4 * sizeof(*v)));
   }
   if (ctx->ExecuteFlag) {
      /*CALL_Uniform4uiv(ctx->Exec, (location, count, v));*/
   }
}



static void GLAPIENTRY
save_UniformMatrix2fvARB(GLint location, GLsizei count, GLboolean transpose,
                         const GLfloat *m)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_MATRIX22, 3 + POINTER_DWORDS);
   if (n) {
      n[1].i = location;
      n[2].i = count;
      n[3].b = transpose;
      save_pointer(&n[4], memdup(m, count * 2 * 2 * sizeof(GLfloat)));
   }
   if (ctx->ExecuteFlag) {
      CALL_UniformMatrix2fv(ctx->Exec, (location, count, transpose, m));
   }
}

static void GLAPIENTRY
save_UniformMatrix3fvARB(GLint location, GLsizei count, GLboolean transpose,
                         const GLfloat *m)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_MATRIX33, 3 + POINTER_DWORDS);
   if (n) {
      n[1].i = location;
      n[2].i = count;
      n[3].b = transpose;
      save_pointer(&n[4], memdup(m, count * 3 * 3 * sizeof(GLfloat)));
   }
   if (ctx->ExecuteFlag) {
      CALL_UniformMatrix3fv(ctx->Exec, (location, count, transpose, m));
   }
}

static void GLAPIENTRY
save_UniformMatrix4fvARB(GLint location, GLsizei count, GLboolean transpose,
                         const GLfloat *m)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_MATRIX44, 3 + POINTER_DWORDS);
   if (n) {
      n[1].i = location;
      n[2].i = count;
      n[3].b = transpose;
      save_pointer(&n[4], memdup(m, count * 4 * 4 * sizeof(GLfloat)));
   }
   if (ctx->ExecuteFlag) {
      CALL_UniformMatrix4fv(ctx->Exec, (location, count, transpose, m));
   }
}


static void GLAPIENTRY
save_UniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose,
                        const GLfloat *m)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_MATRIX23, 3 + POINTER_DWORDS);
   if (n) {
      n[1].i = location;
      n[2].i = count;
      n[3].b = transpose;
      save_pointer(&n[4], memdup(m, count * 2 * 3 * sizeof(GLfloat)));
   }
   if (ctx->ExecuteFlag) {
      CALL_UniformMatrix2x3fv(ctx->Exec, (location, count, transpose, m));
   }
}

static void GLAPIENTRY
save_UniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose,
                        const GLfloat *m)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_MATRIX32, 3 + POINTER_DWORDS);
   if (n) {
      n[1].i = location;
      n[2].i = count;
      n[3].b = transpose;
      save_pointer(&n[4], memdup(m, count * 3 * 2 * sizeof(GLfloat)));
   }
   if (ctx->ExecuteFlag) {
      CALL_UniformMatrix3x2fv(ctx->Exec, (location, count, transpose, m));
   }
}


static void GLAPIENTRY
save_UniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose,
                        const GLfloat *m)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_MATRIX24, 3 + POINTER_DWORDS);
   if (n) {
      n[1].i = location;
      n[2].i = count;
      n[3].b = transpose;
      save_pointer(&n[4], memdup(m, count * 2 * 4 * sizeof(GLfloat)));
   }
   if (ctx->ExecuteFlag) {
      CALL_UniformMatrix2x4fv(ctx->Exec, (location, count, transpose, m));
   }
}

static void GLAPIENTRY
save_UniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose,
                        const GLfloat *m)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_MATRIX42, 3 + POINTER_DWORDS);
   if (n) {
      n[1].i = location;
      n[2].i = count;
      n[3].b = transpose;
      save_pointer(&n[4], memdup(m, count * 4 * 2 * sizeof(GLfloat)));
   }
   if (ctx->ExecuteFlag) {
      CALL_UniformMatrix4x2fv(ctx->Exec, (location, count, transpose, m));
   }
}


static void GLAPIENTRY
save_UniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose,
                        const GLfloat *m)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_MATRIX34, 3 + POINTER_DWORDS);
   if (n) {
      n[1].i = location;
      n[2].i = count;
      n[3].b = transpose;
      save_pointer(&n[4], memdup(m, count * 3 * 4 * sizeof(GLfloat)));
   }
   if (ctx->ExecuteFlag) {
      CALL_UniformMatrix3x4fv(ctx->Exec, (location, count, transpose, m));
   }
}

static void GLAPIENTRY
save_UniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose,
                        const GLfloat *m)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_MATRIX43, 3 + POINTER_DWORDS);
   if (n) {
      n[1].i = location;
      n[2].i = count;
      n[3].b = transpose;
      save_pointer(&n[4], memdup(m, count * 4 * 3 * sizeof(GLfloat)));
   }
   if (ctx->ExecuteFlag) {
      CALL_UniformMatrix4x3fv(ctx->Exec, (location, count, transpose, m));
   }
}

static void GLAPIENTRY
save_UseProgramStages(GLuint pipeline, GLbitfield stages, GLuint program)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_USE_PROGRAM_STAGES, 3);
   if (n) {
      n[1].ui = pipeline;
      n[2].ui = stages;
      n[3].ui = program;
   }
   if (ctx->ExecuteFlag) {
      CALL_UseProgramStages(ctx->Exec, (pipeline, stages, program));
   }
}

static void GLAPIENTRY
save_ProgramUniform1f(GLuint program, GLint location, GLfloat x)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_1F, 3);
   if (n) {
      n[1].ui = program;
      n[2].i = location;
      n[3].f = x;
   }
   if (ctx->ExecuteFlag) {
      CALL_ProgramUniform1f(ctx->Exec, (program, location, x));
   }
}

static void GLAPIENTRY
save_ProgramUniform2f(GLuint program, GLint location, GLfloat x, GLfloat y)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_2F, 4);
   if (n) {
      n[1].ui = program;
      n[2].i = location;
      n[3].f = x;
      n[4].f = y;
   }
   if (ctx->ExecuteFlag) {
      CALL_ProgramUniform2f(ctx->Exec, (program, location, x, y));
   }
}

static void GLAPIENTRY
save_ProgramUniform3f(GLuint program, GLint location,
                      GLfloat x, GLfloat y, GLfloat z)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_3F, 5);
   if (n) {
      n[1].ui = program;
      n[2].i = location;
      n[3].f = x;
      n[4].f = y;
      n[5].f = z;
   }
   if (ctx->ExecuteFlag) {
      CALL_ProgramUniform3f(ctx->Exec, (program, location, x, y, z));
   }
}

static void GLAPIENTRY
save_ProgramUniform4f(GLuint program, GLint location,
                      GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_4F, 6);
   if (n) {
      n[1].ui = program;
      n[2].i = location;
      n[3].f = x;
      n[4].f = y;
      n[5].f = z;
      n[6].f = w;
   }
   if (ctx->ExecuteFlag) {
      CALL_ProgramUniform4f(ctx->Exec, (program, location, x, y, z, w));
   }
}

static void GLAPIENTRY
save_ProgramUniform1fv(GLuint program, GLint location, GLsizei count,
                       const GLfloat *v)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_1FV, 3 + POINTER_DWORDS);
   if (n) {
      n[1].ui = program;
      n[2].i = location;
      n[3].i = count;
      save_pointer(&n[4], memdup(v, count * 1 * sizeof(GLfloat)));
   }
   if (ctx->ExecuteFlag) {
      CALL_ProgramUniform1fv(ctx->Exec, (program, location, count, v));
   }
}

static void GLAPIENTRY
save_ProgramUniform2fv(GLuint program, GLint location, GLsizei count,
                       const GLfloat *v)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_2FV, 3 + POINTER_DWORDS);
   if (n) {
      n[1].ui = program;
      n[2].i = location;
      n[3].i = count;
      save_pointer(&n[4], memdup(v, count * 2 * sizeof(GLfloat)));
   }
   if (ctx->ExecuteFlag) {
      CALL_ProgramUniform2fv(ctx->Exec, (program, location, count, v));
   }
}

static void GLAPIENTRY
save_ProgramUniform3fv(GLuint program, GLint location, GLsizei count,
                       const GLfloat *v)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_3FV, 3 + POINTER_DWORDS);
   if (n) {
      n[1].ui = program;
      n[2].i = location;
      n[3].i = count;
      save_pointer(&n[4], memdup(v, count * 3 * sizeof(GLfloat)));
   }
   if (ctx->ExecuteFlag) {
      CALL_ProgramUniform3fv(ctx->Exec, (program, location, count, v));
   }
}

static void GLAPIENTRY
save_ProgramUniform4fv(GLuint program, GLint location, GLsizei count,
                       const GLfloat *v)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_4FV, 3 + POINTER_DWORDS);
   if (n) {
      n[1].ui = program;
      n[2].i = location;
      n[3].i = count;
      save_pointer(&n[4], memdup(v, count * 4 * sizeof(GLfloat)));
   }
   if (ctx->ExecuteFlag) {
      CALL_ProgramUniform4fv(ctx->Exec, (program, location, count, v));
   }
}

static void GLAPIENTRY
save_ProgramUniform1i(GLuint program, GLint location, GLint x)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_1I, 3);
   if (n) {
      n[1].ui = program;
      n[2].i = location;
      n[3].i = x;
   }
   if (ctx->ExecuteFlag) {
      CALL_ProgramUniform1i(ctx->Exec, (program, location, x));
   }
}

static void GLAPIENTRY
save_ProgramUniform2i(GLuint program, GLint location, GLint x, GLint y)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_2I, 4);
   if (n) {
      n[1].ui = program;
      n[2].i = location;
      n[3].i = x;
      n[4].i = y;
   }
   if (ctx->ExecuteFlag) {
      CALL_ProgramUniform2i(ctx->Exec, (program, location, x, y));
   }
}

static void GLAPIENTRY
save_ProgramUniform3i(GLuint program, GLint location,
                      GLint x, GLint y, GLint z)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_3I, 5);
   if (n) {
      n[1].ui = program;
      n[2].i = location;
      n[3].i = x;
      n[4].i = y;
      n[5].i = z;
   }
   if (ctx->ExecuteFlag) {
      CALL_ProgramUniform3i(ctx->Exec, (program, location, x, y, z));
   }
}

static void GLAPIENTRY
save_ProgramUniform4i(GLuint program, GLint location,
                      GLint x, GLint y, GLint z, GLint w)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_4I, 6);
   if (n) {
      n[1].ui = program;
      n[2].i = location;
      n[3].i = x;
      n[4].i = y;
      n[5].i = z;
      n[6].i = w;
   }
   if (ctx->ExecuteFlag) {
      CALL_ProgramUniform4i(ctx->Exec, (program, location, x, y, z, w));
   }
}

static void GLAPIENTRY
save_ProgramUniform1iv(GLuint program, GLint location, GLsizei count,
                       const GLint *v)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_1IV, 3 + POINTER_DWORDS);
   if (n) {
      n[1].ui = program;
      n[2].i = location;
      n[3].i = count;
      save_pointer(&n[4], memdup(v, count * 1 * sizeof(GLint)));
   }
   if (ctx->ExecuteFlag) {
      CALL_ProgramUniform1iv(ctx->Exec, (program, location, count, v));
   }
}

static void GLAPIENTRY
save_ProgramUniform2iv(GLuint program, GLint location, GLsizei count,
                       const GLint *v)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_2IV, 3 + POINTER_DWORDS);
   if (n) {
      n[1].ui = program;
      n[2].i = location;
      n[3].i = count;
      save_pointer(&n[4], memdup(v, count * 2 * sizeof(GLint)));
   }
   if (ctx->ExecuteFlag) {
      CALL_ProgramUniform2iv(ctx->Exec, (program, location, count, v));
   }
}

static void GLAPIENTRY
save_ProgramUniform3iv(GLuint program, GLint location, GLsizei count,
                       const GLint *v)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_3IV, 3 + POINTER_DWORDS);
   if (n) {
      n[1].ui = program;
      n[2].i = location;
      n[3].i = count;
      save_pointer(&n[4], memdup(v, count * 3 * sizeof(GLint)));
   }
   if (ctx->ExecuteFlag) {
      CALL_ProgramUniform3iv(ctx->Exec, (program, location, count, v));
   }
}

static void GLAPIENTRY
save_ProgramUniform4iv(GLuint program, GLint location, GLsizei count,
                       const GLint *v)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_4IV, 3 + POINTER_DWORDS);
   if (n) {
      n[1].ui = program;
      n[2].i = location;
      n[3].i = count;
      save_pointer(&n[4], memdup(v, count * 4 * sizeof(GLint)));
   }
   if (ctx->ExecuteFlag) {
      CALL_ProgramUniform4iv(ctx->Exec, (program, location, count, v));
   }
}

static void GLAPIENTRY
save_ProgramUniform1ui(GLuint program, GLint location, GLuint x)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_1UI, 3);
   if (n) {
      n[1].ui = program;
      n[2].i = location;
      n[3].ui = x;
   }
   if (ctx->ExecuteFlag) {
      CALL_ProgramUniform1ui(ctx->Exec, (program, location, x));
   }
}

static void GLAPIENTRY
save_ProgramUniform2ui(GLuint program, GLint location, GLuint x, GLuint y)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_2UI, 4);
   if (n) {
      n[1].ui = program;
      n[2].i = location;
      n[3].ui = x;
      n[4].ui = y;
   }
   if (ctx->ExecuteFlag) {
      CALL_ProgramUniform2ui(ctx->Exec, (program, location, x, y));
   }
}

static void GLAPIENTRY
save_ProgramUniform3ui(GLuint program, GLint location,
                       GLuint x, GLuint y, GLuint z)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_3UI, 5);
   if (n) {
      n[1].ui = program;
      n[2].i = location;
      n[3].ui = x;
      n[4].ui = y;
      n[5].ui = z;
   }
   if (ctx->ExecuteFlag) {
      CALL_ProgramUniform3ui(ctx->Exec, (program, location, x, y, z));
   }
}

static void GLAPIENTRY
save_ProgramUniform4ui(GLuint program, GLint location,
                       GLuint x, GLuint y, GLuint z, GLuint w)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_4UI, 6);
   if (n) {
      n[1].ui = program;
      n[2].i = location;
      n[3].ui = x;
      n[4].ui = y;
      n[5].ui = z;
      n[6].ui = w;
   }
   if (ctx->ExecuteFlag) {
      CALL_ProgramUniform4ui(ctx->Exec, (program, location, x, y, z, w));
   }
}

static void GLAPIENTRY
save_ProgramUniform1uiv(GLuint program, GLint location, GLsizei count,
                        const GLuint *v)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_1UIV, 3 + POINTER_DWORDS);
   if (n) {
      n[1].ui = program;
      n[2].i = location;
      n[3].i = count;
      save_pointer(&n[4], memdup(v, count * 1 * sizeof(GLuint)));
   }
   if (ctx->ExecuteFlag) {
      CALL_ProgramUniform1uiv(ctx->Exec, (program, location, count, v));
   }
}

static void GLAPIENTRY
save_ProgramUniform2uiv(GLuint program, GLint location, GLsizei count,
                        const GLuint *v)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_2UIV, 3 + POINTER_DWORDS);
   if (n) {
      n[1].ui = program;
      n[2].i = location;
      n[3].i = count;
      save_pointer(&n[4], memdup(v, count * 2 * sizeof(GLuint)));
   }
   if (ctx->ExecuteFlag) {
      CALL_ProgramUniform2uiv(ctx->Exec, (program, location, count, v));
   }
}

static void GLAPIENTRY
save_ProgramUniform3uiv(GLuint program, GLint location, GLsizei count,
                        const GLuint *v)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_3UIV, 3 + POINTER_DWORDS);
   if (n) {
      n[1].ui = program;
      n[2].i = location;
      n[3].i = count;
      save_pointer(&n[4], memdup(v, count * 3 * sizeof(GLuint)));
   }
   if (ctx->ExecuteFlag) {
      CALL_ProgramUniform3uiv(ctx->Exec, (program, location, count, v));
   }
}

static void GLAPIENTRY
save_ProgramUniform4uiv(GLuint program, GLint location, GLsizei count,
                        const GLuint *v)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_4UIV, 3 + POINTER_DWORDS);
   if (n) {
      n[1].ui = program;
      n[2].i = location;
      n[3].i = count;
      save_pointer(&n[4], memdup(v, count * 4 * sizeof(GLuint)));
   }
   if (ctx->ExecuteFlag) {
      CALL_ProgramUniform4uiv(ctx->Exec, (program, location, count, v));
   }
}

static void GLAPIENTRY
save_ProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count,
                             GLboolean transpose, const GLfloat *v)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_MATRIX22F,
                         4 + POINTER_DWORDS);
   if (n) {
      n[1].ui = program;
      n[2].i = location;
      n[3].i = count;
      n[4].b = transpose;
      save_pointer(&n[5], memdup(v, count * 2 * 2 * sizeof(GLfloat)));
   }
   if (ctx->ExecuteFlag) {
      CALL_ProgramUniformMatrix2fv(ctx->Exec,
                                   (program, location, count, transpose, v));
   }
}

static void GLAPIENTRY
save_ProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count,
                               GLboolean transpose, const GLfloat *v)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_MATRIX23F,
                         4 + POINTER_DWORDS);
   if (n) {
      n[1].ui = program;
      n[2].i = location;
      n[3].i = count;
      n[4].b = transpose;
      save_pointer(&n[5], memdup(v, count * 2 * 3 * sizeof(GLfloat)));
   }
   if (ctx->ExecuteFlag) {
      CALL_ProgramUniformMatrix2x3fv(ctx->Exec,
                                     (program, location, count, transpose, v));
   }
}

static void GLAPIENTRY
save_ProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count,
                               GLboolean transpose, const GLfloat *v)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_MATRIX24F,
                         4 + POINTER_DWORDS);
   if (n) {
      n[1].ui = program;
      n[2].i = location;
      n[3].i = count;
      n[4].b = transpose;
      save_pointer(&n[5], memdup(v, count * 2 * 4 * sizeof(GLfloat)));
   }
   if (ctx->ExecuteFlag) {
      CALL_ProgramUniformMatrix2x4fv(ctx->Exec,
                                     (program, location, count, transpose, v));
   }
}

static void GLAPIENTRY
save_ProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count,
                               GLboolean transpose, const GLfloat *v)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_MATRIX32F,
                         4 + POINTER_DWORDS);
   if (n) {
      n[1].ui = program;
      n[2].i = location;
      n[3].i = count;
      n[4].b = transpose;
      save_pointer(&n[5], memdup(v, count * 3 * 2 * sizeof(GLfloat)));
   }
   if (ctx->ExecuteFlag) {
      CALL_ProgramUniformMatrix3x2fv(ctx->Exec,
                                     (program, location, count, transpose, v));
   }
}

static void GLAPIENTRY
save_ProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count,
                             GLboolean transpose, const GLfloat *v)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_MATRIX33F,
                         4 + POINTER_DWORDS);
   if (n) {
      n[1].ui = program;
      n[2].i = location;
      n[3].i = count;
      n[4].b = transpose;
      save_pointer(&n[5], memdup(v, count * 3 * 3 * sizeof(GLfloat)));
   }
   if (ctx->ExecuteFlag) {
      CALL_ProgramUniformMatrix3fv(ctx->Exec,
                                   (program, location, count, transpose, v));
   }
}

static void GLAPIENTRY
save_ProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count,
                               GLboolean transpose, const GLfloat *v)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_MATRIX34F,
                         4 + POINTER_DWORDS);
   if (n) {
      n[1].ui = program;
      n[2].i = location;
      n[3].i = count;
      n[4].b = transpose;
      save_pointer(&n[5], memdup(v, count * 3 * 4 * sizeof(GLfloat)));
   }
   if (ctx->ExecuteFlag) {
      CALL_ProgramUniformMatrix3x4fv(ctx->Exec,
                                     (program, location, count, transpose, v));
   }
}

static void GLAPIENTRY
save_ProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count,
                               GLboolean transpose, const GLfloat *v)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_MATRIX42F,
                         4 + POINTER_DWORDS);
   if (n) {
      n[1].ui = program;
      n[2].i = location;
      n[3].i = count;
      n[4].b = transpose;
      save_pointer(&n[5], memdup(v, count * 4 * 2 * sizeof(GLfloat)));
   }
   if (ctx->ExecuteFlag) {
      CALL_ProgramUniformMatrix4x2fv(ctx->Exec,
                                     (program, location, count, transpose, v));
   }
}

static void GLAPIENTRY
save_ProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count,
                               GLboolean transpose, const GLfloat *v)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_MATRIX43F,
                         4 + POINTER_DWORDS);
   if (n) {
      n[1].ui = program;
      n[2].i = location;
      n[3].i = count;
      n[4].b = transpose;
      save_pointer(&n[5], memdup(v, count * 4 * 3 * sizeof(GLfloat)));
   }
   if (ctx->ExecuteFlag) {
      CALL_ProgramUniformMatrix4x3fv(ctx->Exec,
                                     (program, location, count, transpose, v));
   }
}

static void GLAPIENTRY
save_ProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count,
                             GLboolean transpose, const GLfloat *v)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_MATRIX44F,
                         4 + POINTER_DWORDS);
   if (n) {
      n[1].ui = program;
      n[2].i = location;
      n[3].i = count;
      n[4].b = transpose;
      save_pointer(&n[5], memdup(v, count * 4 * 4 * sizeof(GLfloat)));
   }
   if (ctx->ExecuteFlag) {
      CALL_ProgramUniformMatrix4fv(ctx->Exec,
                                   (program, location, count, transpose, v));
   }
}

static void GLAPIENTRY
save_ClampColorARB(GLenum target, GLenum clamp)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_CLAMP_COLOR, 2);
   if (n) {
      n[1].e = target;
      n[2].e = clamp;
   }
   if (ctx->ExecuteFlag) {
      CALL_ClampColor(ctx->Exec, (target, clamp));
   }
}

/** GL_EXT_texture_integer */
static void GLAPIENTRY
save_ClearColorIi(GLint red, GLint green, GLint blue, GLint alpha)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_CLEARCOLOR_I, 4);
   if (n) {
      n[1].i = red;
      n[2].i = green;
      n[3].i = blue;
      n[4].i = alpha;
   }
   if (ctx->ExecuteFlag) {
      CALL_ClearColorIiEXT(ctx->Exec, (red, green, blue, alpha));
   }
}

/** GL_EXT_texture_integer */
static void GLAPIENTRY
save_ClearColorIui(GLuint red, GLuint green, GLuint blue, GLuint alpha)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_CLEARCOLOR_UI, 4);
   if (n) {
      n[1].ui = red;
      n[2].ui = green;
      n[3].ui = blue;
      n[4].ui = alpha;
   }
   if (ctx->ExecuteFlag) {
      CALL_ClearColorIuiEXT(ctx->Exec, (red, green, blue, alpha));
   }
}

/** GL_EXT_texture_integer */
static void GLAPIENTRY
save_TexParameterIiv(GLenum target, GLenum pname, const GLint *params)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_TEXPARAMETER_I, 6);
   if (n) {
      n[1].e = target;
      n[2].e = pname;
      n[3].i = params[0];
      n[4].i = params[1];
      n[5].i = params[2];
      n[6].i = params[3];
   }
   if (ctx->ExecuteFlag) {
      CALL_TexParameterIiv(ctx->Exec, (target, pname, params));
   }
}

/** GL_EXT_texture_integer */
static void GLAPIENTRY
save_TexParameterIuiv(GLenum target, GLenum pname, const GLuint *params)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_TEXPARAMETER_UI, 6);
   if (n) {
      n[1].e = target;
      n[2].e = pname;
      n[3].ui = params[0];
      n[4].ui = params[1];
      n[5].ui = params[2];
      n[6].ui = params[3];
   }
   if (ctx->ExecuteFlag) {
      CALL_TexParameterIuiv(ctx->Exec, (target, pname, params));
   }
}

/* GL_ARB_instanced_arrays */
static void GLAPIENTRY
save_VertexAttribDivisor(GLuint index, GLuint divisor)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_VERTEX_ATTRIB_DIVISOR, 2);
   if (n) {
      n[1].ui = index;
      n[2].ui = divisor;
   }
   if (ctx->ExecuteFlag) {
      CALL_VertexAttribDivisor(ctx->Exec, (index, divisor));
   }
}


/* GL_NV_texture_barrier */
static void GLAPIENTRY
save_TextureBarrierNV(void)
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   alloc_instruction(ctx, OPCODE_TEXTURE_BARRIER_NV, 0);
   if (ctx->ExecuteFlag) {
      CALL_TextureBarrierNV(ctx->Exec, ());
   }
}


/* GL_ARB_sampler_objects */
static void GLAPIENTRY
save_BindSampler(GLuint unit, GLuint sampler)
{
   Node *n;
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_BIND_SAMPLER, 2);
   if (n) {
      n[1].ui = unit;
      n[2].ui = sampler;
   }
   if (ctx->ExecuteFlag) {
      CALL_BindSampler(ctx->Exec, (unit, sampler));
   }
}

static void GLAPIENTRY
save_SamplerParameteriv(GLuint sampler, GLenum pname, const GLint *params)
{
   Node *n;
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_SAMPLER_PARAMETERIV, 6);
   if (n) {
      n[1].ui = sampler;
      n[2].e = pname;
      n[3].i = params[0];
      if (pname == GL_TEXTURE_BORDER_COLOR) {
         n[4].i = params[1];
         n[5].i = params[2];
         n[6].i = params[3];
      }
      else {
         n[4].i = n[5].i = n[6].i = 0;
      }
   }
   if (ctx->ExecuteFlag) {
      CALL_SamplerParameteriv(ctx->Exec, (sampler, pname, params));
   }
}

static void GLAPIENTRY
save_SamplerParameteri(GLuint sampler, GLenum pname, GLint param)
{
   GLint parray[4];
   parray[0] = param;
   parray[1] = parray[2] = parray[3] = 0;
   save_SamplerParameteriv(sampler, pname, parray);
}

static void GLAPIENTRY
save_SamplerParameterfv(GLuint sampler, GLenum pname, const GLfloat *params)
{
   Node *n;
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_SAMPLER_PARAMETERFV, 6);
   if (n) {
      n[1].ui = sampler;
      n[2].e = pname;
      n[3].f = params[0];
      if (pname == GL_TEXTURE_BORDER_COLOR) {
         n[4].f = params[1];
         n[5].f = params[2];
         n[6].f = params[3];
      }
      else {
         n[4].f = n[5].f = n[6].f = 0.0F;
      }
   }
   if (ctx->ExecuteFlag) {
      CALL_SamplerParameterfv(ctx->Exec, (sampler, pname, params));
   }
}

static void GLAPIENTRY
save_SamplerParameterf(GLuint sampler, GLenum pname, GLfloat param)
{
   GLfloat parray[4];
   parray[0] = param;
   parray[1] = parray[2] = parray[3] = 0.0F;
   save_SamplerParameterfv(sampler, pname, parray);
}

static void GLAPIENTRY
save_SamplerParameterIiv(GLuint sampler, GLenum pname, const GLint *params)
{
   Node *n;
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_SAMPLER_PARAMETERIIV, 6);
   if (n) {
      n[1].ui = sampler;
      n[2].e = pname;
      n[3].i = params[0];
      if (pname == GL_TEXTURE_BORDER_COLOR) {
         n[4].i = params[1];
         n[5].i = params[2];
         n[6].i = params[3];
      }
      else {
         n[4].i = n[5].i = n[6].i = 0;
      }
   }
   if (ctx->ExecuteFlag) {
      CALL_SamplerParameterIiv(ctx->Exec, (sampler, pname, params));
   }
}

static void GLAPIENTRY
save_SamplerParameterIuiv(GLuint sampler, GLenum pname, const GLuint *params)
{
   Node *n;
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_SAMPLER_PARAMETERUIV, 6);
   if (n) {
      n[1].ui = sampler;
      n[2].e = pname;
      n[3].ui = params[0];
      if (pname == GL_TEXTURE_BORDER_COLOR) {
         n[4].ui = params[1];
         n[5].ui = params[2];
         n[6].ui = params[3];
      }
      else {
         n[4].ui = n[5].ui = n[6].ui = 0;
      }
   }
   if (ctx->ExecuteFlag) {
      CALL_SamplerParameterIuiv(ctx->Exec, (sampler, pname, params));
   }
}

/* GL_ARB_geometry_shader4 */
static void GLAPIENTRY
save_ProgramParameteri(GLuint program, GLenum pname, GLint value)
{
   Node *n;
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_PROGRAM_PARAMETERI, 3);
   if (n) {
      n[1].ui = program;
      n[2].e = pname;
      n[3].i = value;
   }
   if (ctx->ExecuteFlag) {
      CALL_ProgramParameteri(ctx->Exec, (program, pname, value));
   }
}

static void GLAPIENTRY
save_FramebufferTexture(GLenum target, GLenum attachment,
                        GLuint texture, GLint level)
{
   Node *n;
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_FRAMEBUFFER_TEXTURE, 4);
   if (n) {
      n[1].e = target;
      n[2].e = attachment;
      n[3].ui = texture;
      n[4].i = level;
   }
   if (ctx->ExecuteFlag) {
      CALL_FramebufferTexture(ctx->Exec, (target, attachment, texture, level));
   }
}

static void GLAPIENTRY
save_FramebufferTextureFace(GLenum target, GLenum attachment,
                            GLuint texture, GLint level, GLenum face)
{
   Node *n;
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_FRAMEBUFFER_TEXTURE_FACE, 5);
   if (n) {
      n[1].e = target;
      n[2].e = attachment;
      n[3].ui = texture;
      n[4].i = level;
      n[5].e = face;
   }
   if (ctx->ExecuteFlag) {
      CALL_FramebufferTextureFaceARB(ctx->Exec, (target, attachment, texture,
                                                 level, face));
   }
}



static void GLAPIENTRY
save_WaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout)
{
   Node *n;
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_WAIT_SYNC, 4);
   if (n) {
      union uint64_pair p;
      p.uint64 = timeout;
      n[1].bf = flags;
      n[2].ui = p.uint32[0];
      n[3].ui = p.uint32[1];
      save_pointer(&n[4], sync);
   }
   if (ctx->ExecuteFlag) {
      CALL_WaitSync(ctx->Exec, (sync, flags, timeout));
   }
}


/** GL_NV_conditional_render */
static void GLAPIENTRY
save_BeginConditionalRender(GLuint queryId, GLenum mode)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_BEGIN_CONDITIONAL_RENDER, 2);
   if (n) {
      n[1].i = queryId;
      n[2].e = mode;
   }
   if (ctx->ExecuteFlag) {
      CALL_BeginConditionalRender(ctx->Exec, (queryId, mode));
   }
}

static void GLAPIENTRY
save_EndConditionalRender(void)
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   alloc_instruction(ctx, OPCODE_END_CONDITIONAL_RENDER, 0);
   if (ctx->ExecuteFlag) {
      CALL_EndConditionalRender(ctx->Exec, ());
   }
}

static void GLAPIENTRY
save_UniformBlockBinding(GLuint prog, GLuint index, GLuint binding)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_BLOCK_BINDING, 3);
   if (n) {
      n[1].ui = prog;
      n[2].ui = index;
      n[3].ui = binding;
   }
   if (ctx->ExecuteFlag) {
      CALL_UniformBlockBinding(ctx->Exec, (prog, index, binding));
   }
}


/**
 * Save an error-generating command into display list.
 *
 * KW: Will appear in the list before the vertex buffer containing the
 * command that provoked the error.  I don't see this as a problem.
 */
static void
save_error(struct gl_context *ctx, GLenum error, const char *s)
{
   Node *n;
   n = alloc_instruction(ctx, OPCODE_ERROR, 1 + POINTER_DWORDS);
   if (n) {
      n[1].e = error;
      save_pointer(&n[2], (void *) s);
      /* note: the data/string here doesn't have to be freed in
       * _mesa_delete_list() since the string is never dynamically
       * allocated.
       */
   }
}


/**
 * Compile an error into current display list.
 */
void
_mesa_compile_error(struct gl_context *ctx, GLenum error, const char *s)
{
   if (ctx->CompileFlag)
      save_error(ctx, error, s);
   if (ctx->ExecuteFlag)
      _mesa_error(ctx, error, "%s", s);
}


/**
 * Test if ID names a display list.
 */
static GLboolean
islist(struct gl_context *ctx, GLuint list)
{
   if (list > 0 && _mesa_lookup_list(ctx, list)) {
      return GL_TRUE;
   }
   else {
      return GL_FALSE;
   }
}



/**********************************************************************/
/*                     Display list execution                         */
/**********************************************************************/


/*
 * Execute a display list.  Note that the ListBase offset must have already
 * been added before calling this function.  I.e. the list argument is
 * the absolute list number, not relative to ListBase.
 * \param list - display list number
 */
static void
execute_list(struct gl_context *ctx, GLuint list)
{
   struct gl_display_list *dlist;
   Node *n;
   GLboolean done;

   if (list == 0 || !islist(ctx, list))
      return;

   if (ctx->ListState.CallDepth == MAX_LIST_NESTING) {
      /* raise an error? */
      return;
   }

   dlist = _mesa_lookup_list(ctx, list);
   if (!dlist)
      return;

   ctx->ListState.CallDepth++;

   if (ctx->Driver.BeginCallList)
      ctx->Driver.BeginCallList(ctx, dlist);

   n = dlist->Head;

   done = GL_FALSE;
   while (!done) {
      const OpCode opcode = n[0].opcode;

      if (is_ext_opcode(opcode)) {
         n += ext_opcode_execute(ctx, n);
      }
      else {
         switch (opcode) {
         case OPCODE_ERROR:
            _mesa_error(ctx, n[1].e, "%s", (const char *) get_pointer(&n[2]));
            break;
         case OPCODE_ACCUM:
            CALL_Accum(ctx->Exec, (n[1].e, n[2].f));
            break;
         case OPCODE_ALPHA_FUNC:
            CALL_AlphaFunc(ctx->Exec, (n[1].e, n[2].f));
            break;
         case OPCODE_BIND_TEXTURE:
            CALL_BindTexture(ctx->Exec, (n[1].e, n[2].ui));
            break;
         case OPCODE_BITMAP:
            {
               const struct gl_pixelstore_attrib save = ctx->Unpack;
               ctx->Unpack = ctx->DefaultPacking;
               CALL_Bitmap(ctx->Exec, ((GLsizei) n[1].i, (GLsizei) n[2].i,
                                       n[3].f, n[4].f, n[5].f, n[6].f,
                                       get_pointer(&n[7])));
               ctx->Unpack = save;      /* restore */
            }
            break;
         case OPCODE_BLEND_COLOR:
            CALL_BlendColor(ctx->Exec, (n[1].f, n[2].f, n[3].f, n[4].f));
            break;
         case OPCODE_BLEND_EQUATION:
            CALL_BlendEquation(ctx->Exec, (n[1].e));
            break;
         case OPCODE_BLEND_EQUATION_SEPARATE:
            CALL_BlendEquationSeparate(ctx->Exec, (n[1].e, n[2].e));
            break;
         case OPCODE_BLEND_FUNC_SEPARATE:
            CALL_BlendFuncSeparate(ctx->Exec,
                                      (n[1].e, n[2].e, n[3].e, n[4].e));
            break;

         case OPCODE_BLEND_FUNC_I:
            /* GL_ARB_draw_buffers_blend */
            CALL_BlendFunciARB(ctx->Exec, (n[1].ui, n[2].e, n[3].e));
            break;
         case OPCODE_BLEND_FUNC_SEPARATE_I:
            /* GL_ARB_draw_buffers_blend */
            CALL_BlendFuncSeparateiARB(ctx->Exec, (n[1].ui, n[2].e, n[3].e,
                                                   n[4].e, n[5].e));
            break;
         case OPCODE_BLEND_EQUATION_I:
            /* GL_ARB_draw_buffers_blend */
            CALL_BlendEquationiARB(ctx->Exec, (n[1].ui, n[2].e));
            break;
         case OPCODE_BLEND_EQUATION_SEPARATE_I:
            /* GL_ARB_draw_buffers_blend */
            CALL_BlendEquationSeparateiARB(ctx->Exec,
                                           (n[1].ui, n[2].e, n[3].e));
            break;

         case OPCODE_CALL_LIST:
            /* Generated by glCallList(), don't add ListBase */
            if (ctx->ListState.CallDepth < MAX_LIST_NESTING) {
               execute_list(ctx, n[1].ui);
            }
            break;
         case OPCODE_CALL_LIST_OFFSET:
            /* Generated by glCallLists() so we must add ListBase */
            if (n[2].b) {
               /* user specified a bad data type at compile time */
               _mesa_error(ctx, GL_INVALID_ENUM, "glCallLists(type)");
            }
            else if (ctx->ListState.CallDepth < MAX_LIST_NESTING) {
               GLuint list = (GLuint) (ctx->List.ListBase + n[1].i);
               execute_list(ctx, list);
            }
            break;
         case OPCODE_CLEAR:
            CALL_Clear(ctx->Exec, (n[1].bf));
            break;
         case OPCODE_CLEAR_BUFFER_IV:
            {
               GLint value[4];
               value[0] = n[3].i;
               value[1] = n[4].i;
               value[2] = n[5].i;
               value[3] = n[6].i;
               CALL_ClearBufferiv(ctx->Exec, (n[1].e, n[2].i, value));
            }
            break;
         case OPCODE_CLEAR_BUFFER_UIV:
            {
               GLuint value[4];
               value[0] = n[3].ui;
               value[1] = n[4].ui;
               value[2] = n[5].ui;
               value[3] = n[6].ui;
               CALL_ClearBufferuiv(ctx->Exec, (n[1].e, n[2].i, value));
            }
            break;
         case OPCODE_CLEAR_BUFFER_FV:
            {
               GLfloat value[4];
               value[0] = n[3].f;
               value[1] = n[4].f;
               value[2] = n[5].f;
               value[3] = n[6].f;
               CALL_ClearBufferfv(ctx->Exec, (n[1].e, n[2].i, value));
            }
            break;
         case OPCODE_CLEAR_BUFFER_FI:
            CALL_ClearBufferfi(ctx->Exec, (n[1].e, n[2].i, n[3].f, n[4].i));
            break;
         case OPCODE_CLEAR_COLOR:
            CALL_ClearColor(ctx->Exec, (n[1].f, n[2].f, n[3].f, n[4].f));
            break;
         case OPCODE_CLEAR_ACCUM:
            CALL_ClearAccum(ctx->Exec, (n[1].f, n[2].f, n[3].f, n[4].f));
            break;
         case OPCODE_CLEAR_DEPTH:
            CALL_ClearDepth(ctx->Exec, ((GLclampd) n[1].f));
            break;
         case OPCODE_CLEAR_INDEX:
            CALL_ClearIndex(ctx->Exec, ((GLfloat) n[1].ui));
            break;
         case OPCODE_CLEAR_STENCIL:
            CALL_ClearStencil(ctx->Exec, (n[1].i));
            break;
         case OPCODE_CLIP_PLANE:
            {
               GLdouble eq[4];
               eq[0] = n[2].f;
               eq[1] = n[3].f;
               eq[2] = n[4].f;
               eq[3] = n[5].f;
               CALL_ClipPlane(ctx->Exec, (n[1].e, eq));
            }
            break;
         case OPCODE_COLOR_MASK:
            CALL_ColorMask(ctx->Exec, (n[1].b, n[2].b, n[3].b, n[4].b));
            break;
         case OPCODE_COLOR_MASK_INDEXED:
            CALL_ColorMaski(ctx->Exec, (n[1].ui, n[2].b, n[3].b,
                                                 n[4].b, n[5].b));
            break;
         case OPCODE_COLOR_MATERIAL:
            CALL_ColorMaterial(ctx->Exec, (n[1].e, n[2].e));
            break;
         case OPCODE_COPY_PIXELS:
            CALL_CopyPixels(ctx->Exec, (n[1].i, n[2].i,
                                        (GLsizei) n[3].i, (GLsizei) n[4].i,
                                        n[5].e));
            break;
         case OPCODE_COPY_TEX_IMAGE1D:
            CALL_CopyTexImage1D(ctx->Exec, (n[1].e, n[2].i, n[3].e, n[4].i,
                                            n[5].i, n[6].i, n[7].i));
            break;
         case OPCODE_COPY_TEX_IMAGE2D:
            CALL_CopyTexImage2D(ctx->Exec, (n[1].e, n[2].i, n[3].e, n[4].i,
                                            n[5].i, n[6].i, n[7].i, n[8].i));
            break;
         case OPCODE_COPY_TEX_SUB_IMAGE1D:
            CALL_CopyTexSubImage1D(ctx->Exec, (n[1].e, n[2].i, n[3].i,
                                               n[4].i, n[5].i, n[6].i));
            break;
         case OPCODE_COPY_TEX_SUB_IMAGE2D:
            CALL_CopyTexSubImage2D(ctx->Exec, (n[1].e, n[2].i, n[3].i,
                                               n[4].i, n[5].i, n[6].i, n[7].i,
                                               n[8].i));
            break;
         case OPCODE_COPY_TEX_SUB_IMAGE3D:
            CALL_CopyTexSubImage3D(ctx->Exec, (n[1].e, n[2].i, n[3].i,
                                               n[4].i, n[5].i, n[6].i, n[7].i,
                                               n[8].i, n[9].i));
            break;
         case OPCODE_CULL_FACE:
            CALL_CullFace(ctx->Exec, (n[1].e));
            break;
         case OPCODE_DEPTH_FUNC:
            CALL_DepthFunc(ctx->Exec, (n[1].e));
            break;
         case OPCODE_DEPTH_MASK:
            CALL_DepthMask(ctx->Exec, (n[1].b));
            break;
         case OPCODE_DEPTH_RANGE:
            CALL_DepthRange(ctx->Exec,
                            ((GLclampd) n[1].f, (GLclampd) n[2].f));
            break;
         case OPCODE_DISABLE:
            CALL_Disable(ctx->Exec, (n[1].e));
            break;
         case OPCODE_DISABLE_INDEXED:
            CALL_Disablei(ctx->Exec, (n[1].ui, n[2].e));
            break;
         case OPCODE_DRAW_BUFFER:
            CALL_DrawBuffer(ctx->Exec, (n[1].e));
            break;
         case OPCODE_DRAW_PIXELS:
            {
               const struct gl_pixelstore_attrib save = ctx->Unpack;
               ctx->Unpack = ctx->DefaultPacking;
               CALL_DrawPixels(ctx->Exec, (n[1].i, n[2].i, n[3].e, n[4].e,
                                           get_pointer(&n[5])));
               ctx->Unpack = save;      /* restore */
            }
            break;
         case OPCODE_ENABLE:
            CALL_Enable(ctx->Exec, (n[1].e));
            break;
         case OPCODE_ENABLE_INDEXED:
            CALL_Enablei(ctx->Exec, (n[1].ui, n[2].e));
            break;
         case OPCODE_EVALMESH1:
            CALL_EvalMesh1(ctx->Exec, (n[1].e, n[2].i, n[3].i));
            break;
         case OPCODE_EVALMESH2:
            CALL_EvalMesh2(ctx->Exec,
                           (n[1].e, n[2].i, n[3].i, n[4].i, n[5].i));
            break;
         case OPCODE_FOG:
            {
               GLfloat p[4];
               p[0] = n[2].f;
               p[1] = n[3].f;
               p[2] = n[4].f;
               p[3] = n[5].f;
               CALL_Fogfv(ctx->Exec, (n[1].e, p));
            }
            break;
         case OPCODE_FRONT_FACE:
            CALL_FrontFace(ctx->Exec, (n[1].e));
            break;
         case OPCODE_FRUSTUM:
            CALL_Frustum(ctx->Exec,
                         (n[1].f, n[2].f, n[3].f, n[4].f, n[5].f, n[6].f));
            break;
         case OPCODE_HINT:
            CALL_Hint(ctx->Exec, (n[1].e, n[2].e));
            break;
         case OPCODE_INDEX_MASK:
            CALL_IndexMask(ctx->Exec, (n[1].ui));
            break;
         case OPCODE_INIT_NAMES:
            CALL_InitNames(ctx->Exec, ());
            break;
         case OPCODE_LIGHT:
            {
               GLfloat p[4];
               p[0] = n[3].f;
               p[1] = n[4].f;
               p[2] = n[5].f;
               p[3] = n[6].f;
               CALL_Lightfv(ctx->Exec, (n[1].e, n[2].e, p));
            }
            break;
         case OPCODE_LIGHT_MODEL:
            {
               GLfloat p[4];
               p[0] = n[2].f;
               p[1] = n[3].f;
               p[2] = n[4].f;
               p[3] = n[5].f;
               CALL_LightModelfv(ctx->Exec, (n[1].e, p));
            }
            break;
         case OPCODE_LINE_STIPPLE:
            CALL_LineStipple(ctx->Exec, (n[1].i, n[2].us));
            break;
         case OPCODE_LINE_WIDTH:
            CALL_LineWidth(ctx->Exec, (n[1].f));
            break;
         case OPCODE_LIST_BASE:
            CALL_ListBase(ctx->Exec, (n[1].ui));
            break;
         case OPCODE_LOAD_IDENTITY:
            CALL_LoadIdentity(ctx->Exec, ());
            break;
         case OPCODE_LOAD_MATRIX:
            if (sizeof(Node) == sizeof(GLfloat)) {
               CALL_LoadMatrixf(ctx->Exec, (&n[1].f));
            }
            else {
               GLfloat m[16];
               GLuint i;
               for (i = 0; i < 16; i++) {
                  m[i] = n[1 + i].f;
               }
               CALL_LoadMatrixf(ctx->Exec, (m));
            }
            break;
         case OPCODE_LOAD_NAME:
            CALL_LoadName(ctx->Exec, (n[1].ui));
            break;
         case OPCODE_LOGIC_OP:
            CALL_LogicOp(ctx->Exec, (n[1].e));
            break;
         case OPCODE_MAP1:
            {
               GLenum target = n[1].e;
               GLint ustride = _mesa_evaluator_components(target);
               GLint uorder = n[5].i;
               GLfloat u1 = n[2].f;
               GLfloat u2 = n[3].f;
               CALL_Map1f(ctx->Exec, (target, u1, u2, ustride, uorder,
                                      (GLfloat *) get_pointer(&n[6])));
            }
            break;
         case OPCODE_MAP2:
            {
               GLenum target = n[1].e;
               GLfloat u1 = n[2].f;
               GLfloat u2 = n[3].f;
               GLfloat v1 = n[4].f;
               GLfloat v2 = n[5].f;
               GLint ustride = n[6].i;
               GLint vstride = n[7].i;
               GLint uorder = n[8].i;
               GLint vorder = n[9].i;
               CALL_Map2f(ctx->Exec, (target, u1, u2, ustride, uorder,
                                      v1, v2, vstride, vorder,
                                      (GLfloat *) get_pointer(&n[10])));
            }
            break;
         case OPCODE_MAPGRID1:
            CALL_MapGrid1f(ctx->Exec, (n[1].i, n[2].f, n[3].f));
            break;
         case OPCODE_MAPGRID2:
            CALL_MapGrid2f(ctx->Exec,
                           (n[1].i, n[2].f, n[3].f, n[4].i, n[5].f, n[6].f));
            break;
         case OPCODE_MATRIX_MODE:
            CALL_MatrixMode(ctx->Exec, (n[1].e));
            break;
         case OPCODE_MULT_MATRIX:
            if (sizeof(Node) == sizeof(GLfloat)) {
               CALL_MultMatrixf(ctx->Exec, (&n[1].f));
            }
            else {
               GLfloat m[16];
               GLuint i;
               for (i = 0; i < 16; i++) {
                  m[i] = n[1 + i].f;
               }
               CALL_MultMatrixf(ctx->Exec, (m));
            }
            break;
         case OPCODE_ORTHO:
            CALL_Ortho(ctx->Exec,
                       (n[1].f, n[2].f, n[3].f, n[4].f, n[5].f, n[6].f));
            break;
         case OPCODE_PASSTHROUGH:
            CALL_PassThrough(ctx->Exec, (n[1].f));
            break;
         case OPCODE_PIXEL_MAP:
            CALL_PixelMapfv(ctx->Exec,
                            (n[1].e, n[2].i, get_pointer(&n[3])));
            break;
         case OPCODE_PIXEL_TRANSFER:
            CALL_PixelTransferf(ctx->Exec, (n[1].e, n[2].f));
            break;
         case OPCODE_PIXEL_ZOOM:
            CALL_PixelZoom(ctx->Exec, (n[1].f, n[2].f));
            break;
         case OPCODE_POINT_SIZE:
            CALL_PointSize(ctx->Exec, (n[1].f));
            break;
         case OPCODE_POINT_PARAMETERS:
            {
               GLfloat params[3];
               params[0] = n[2].f;
               params[1] = n[3].f;
               params[2] = n[4].f;
               CALL_PointParameterfv(ctx->Exec, (n[1].e, params));
            }
            break;
         case OPCODE_POLYGON_MODE:
            CALL_PolygonMode(ctx->Exec, (n[1].e, n[2].e));
            break;
         case OPCODE_POLYGON_STIPPLE:
            {
               const struct gl_pixelstore_attrib save = ctx->Unpack;
               ctx->Unpack = ctx->DefaultPacking;
               CALL_PolygonStipple(ctx->Exec, (get_pointer(&n[1])));
               ctx->Unpack = save;      /* restore */
            }
            break;
         case OPCODE_POLYGON_OFFSET:
            CALL_PolygonOffset(ctx->Exec, (n[1].f, n[2].f));
            break;
         case OPCODE_POP_ATTRIB:
            CALL_PopAttrib(ctx->Exec, ());
            break;
         case OPCODE_POP_MATRIX:
            CALL_PopMatrix(ctx->Exec, ());
            break;
         case OPCODE_POP_NAME:
            CALL_PopName(ctx->Exec, ());
            break;
         case OPCODE_PRIORITIZE_TEXTURE:
            CALL_PrioritizeTextures(ctx->Exec, (1, &n[1].ui, &n[2].f));
            break;
         case OPCODE_PUSH_ATTRIB:
            CALL_PushAttrib(ctx->Exec, (n[1].bf));
            break;
         case OPCODE_PUSH_MATRIX:
            CALL_PushMatrix(ctx->Exec, ());
            break;
         case OPCODE_PUSH_NAME:
            CALL_PushName(ctx->Exec, (n[1].ui));
            break;
         case OPCODE_RASTER_POS:
            CALL_RasterPos4f(ctx->Exec, (n[1].f, n[2].f, n[3].f, n[4].f));
            break;
         case OPCODE_READ_BUFFER:
            CALL_ReadBuffer(ctx->Exec, (n[1].e));
            break;
         case OPCODE_ROTATE:
            CALL_Rotatef(ctx->Exec, (n[1].f, n[2].f, n[3].f, n[4].f));
            break;
         case OPCODE_SCALE:
            CALL_Scalef(ctx->Exec, (n[1].f, n[2].f, n[3].f));
            break;
         case OPCODE_SCISSOR:
            CALL_Scissor(ctx->Exec, (n[1].i, n[2].i, n[3].i, n[4].i));
            break;
         case OPCODE_SHADE_MODEL:
            CALL_ShadeModel(ctx->Exec, (n[1].e));
            break;
         case OPCODE_PROVOKING_VERTEX:
            CALL_ProvokingVertex(ctx->Exec, (n[1].e));
            break;
         case OPCODE_STENCIL_FUNC:
            CALL_StencilFunc(ctx->Exec, (n[1].e, n[2].i, n[3].ui));
            break;
         case OPCODE_STENCIL_MASK:
            CALL_StencilMask(ctx->Exec, (n[1].ui));
            break;
         case OPCODE_STENCIL_OP:
            CALL_StencilOp(ctx->Exec, (n[1].e, n[2].e, n[3].e));
            break;
         case OPCODE_STENCIL_FUNC_SEPARATE:
            CALL_StencilFuncSeparate(ctx->Exec,
                                     (n[1].e, n[2].e, n[3].i, n[4].ui));
            break;
         case OPCODE_STENCIL_MASK_SEPARATE:
            CALL_StencilMaskSeparate(ctx->Exec, (n[1].e, n[2].ui));
            break;
         case OPCODE_STENCIL_OP_SEPARATE:
            CALL_StencilOpSeparate(ctx->Exec,
                                   (n[1].e, n[2].e, n[3].e, n[4].e));
            break;
         case OPCODE_TEXENV:
            {
               GLfloat params[4];
               params[0] = n[3].f;
               params[1] = n[4].f;
               params[2] = n[5].f;
               params[3] = n[6].f;
               CALL_TexEnvfv(ctx->Exec, (n[1].e, n[2].e, params));
            }
            break;
         case OPCODE_TEXGEN:
            {
               GLfloat params[4];
               params[0] = n[3].f;
               params[1] = n[4].f;
               params[2] = n[5].f;
               params[3] = n[6].f;
               CALL_TexGenfv(ctx->Exec, (n[1].e, n[2].e, params));
            }
            break;
         case OPCODE_TEXPARAMETER:
            {
               GLfloat params[4];
               params[0] = n[3].f;
               params[1] = n[4].f;
               params[2] = n[5].f;
               params[3] = n[6].f;
               CALL_TexParameterfv(ctx->Exec, (n[1].e, n[2].e, params));
            }
            break;
         case OPCODE_TEX_IMAGE1D:
            {
               const struct gl_pixelstore_attrib save = ctx->Unpack;
               ctx->Unpack = ctx->DefaultPacking;
               CALL_TexImage1D(ctx->Exec, (n[1].e,      /* target */
                                           n[2].i,      /* level */
                                           n[3].i,      /* components */
                                           n[4].i,      /* width */
                                           n[5].e,      /* border */
                                           n[6].e,      /* format */
                                           n[7].e,      /* type */
                                           get_pointer(&n[8])));
               ctx->Unpack = save;      /* restore */
            }
            break;
         case OPCODE_TEX_IMAGE2D:
            {
               const struct gl_pixelstore_attrib save = ctx->Unpack;
               ctx->Unpack = ctx->DefaultPacking;
               CALL_TexImage2D(ctx->Exec, (n[1].e,      /* target */
                                           n[2].i,      /* level */
                                           n[3].i,      /* components */
                                           n[4].i,      /* width */
                                           n[5].i,      /* height */
                                           n[6].e,      /* border */
                                           n[7].e,      /* format */
                                           n[8].e,      /* type */
                                           get_pointer(&n[9])));
               ctx->Unpack = save;      /* restore */
            }
            break;
         case OPCODE_TEX_IMAGE3D:
            {
               const struct gl_pixelstore_attrib save = ctx->Unpack;
               ctx->Unpack = ctx->DefaultPacking;
               CALL_TexImage3D(ctx->Exec, (n[1].e,      /* target */
                                           n[2].i,      /* level */
                                           n[3].i,      /* components */
                                           n[4].i,      /* width */
                                           n[5].i,      /* height */
                                           n[6].i,      /* depth  */
                                           n[7].e,      /* border */
                                           n[8].e,      /* format */
                                           n[9].e,      /* type */
                                           get_pointer(&n[10])));
               ctx->Unpack = save;      /* restore */
            }
            break;
         case OPCODE_TEX_SUB_IMAGE1D:
            {
               const struct gl_pixelstore_attrib save = ctx->Unpack;
               ctx->Unpack = ctx->DefaultPacking;
               CALL_TexSubImage1D(ctx->Exec, (n[1].e, n[2].i, n[3].i,
                                              n[4].i, n[5].e,
                                              n[6].e, get_pointer(&n[7])));
               ctx->Unpack = save;      /* restore */
            }
            break;
         case OPCODE_TEX_SUB_IMAGE2D:
            {
               const struct gl_pixelstore_attrib save = ctx->Unpack;
               ctx->Unpack = ctx->DefaultPacking;
               CALL_TexSubImage2D(ctx->Exec, (n[1].e, n[2].i, n[3].i,
                                              n[4].i, n[5].e,
                                              n[6].i, n[7].e, n[8].e,
                                              get_pointer(&n[9])));
               ctx->Unpack = save;      /* restore */
            }
            break;
         case OPCODE_TEX_SUB_IMAGE3D:
            {
               const struct gl_pixelstore_attrib save = ctx->Unpack;
               ctx->Unpack = ctx->DefaultPacking;
               CALL_TexSubImage3D(ctx->Exec, (n[1].e, n[2].i, n[3].i,
                                              n[4].i, n[5].i, n[6].i, n[7].i,
                                              n[8].i, n[9].e, n[10].e,
                                              get_pointer(&n[11])));
               ctx->Unpack = save;      /* restore */
            }
            break;
         case OPCODE_TRANSLATE:
            CALL_Translatef(ctx->Exec, (n[1].f, n[2].f, n[3].f));
            break;
         case OPCODE_VIEWPORT:
            CALL_Viewport(ctx->Exec, (n[1].i, n[2].i,
                                      (GLsizei) n[3].i, (GLsizei) n[4].i));
            break;
         case OPCODE_WINDOW_POS:
            CALL_WindowPos4fMESA(ctx->Exec, (n[1].f, n[2].f, n[3].f, n[4].f));
            break;
         case OPCODE_ACTIVE_TEXTURE:   /* GL_ARB_multitexture */
            CALL_ActiveTexture(ctx->Exec, (n[1].e));
            break;
         case OPCODE_COMPRESSED_TEX_IMAGE_1D:  /* GL_ARB_texture_compression */
            CALL_CompressedTexImage1D(ctx->Exec, (n[1].e, n[2].i, n[3].e,
                                                  n[4].i, n[5].i, n[6].i,
                                                  get_pointer(&n[7])));
            break;
         case OPCODE_COMPRESSED_TEX_IMAGE_2D:  /* GL_ARB_texture_compression */
            CALL_CompressedTexImage2D(ctx->Exec, (n[1].e, n[2].i, n[3].e,
                                                  n[4].i, n[5].i, n[6].i,
                                                  n[7].i, get_pointer(&n[8])));
            break;
         case OPCODE_COMPRESSED_TEX_IMAGE_3D:  /* GL_ARB_texture_compression */
            CALL_CompressedTexImage3D(ctx->Exec, (n[1].e, n[2].i, n[3].e,
                                                  n[4].i, n[5].i, n[6].i,
                                                  n[7].i, n[8].i,
                                                  get_pointer(&n[9])));
            break;
         case OPCODE_COMPRESSED_TEX_SUB_IMAGE_1D:      /* GL_ARB_texture_compress */
            CALL_CompressedTexSubImage1D(ctx->Exec,
                                            (n[1].e, n[2].i, n[3].i, n[4].i,
                                             n[5].e, n[6].i,
                                             get_pointer(&n[7])));
            break;
         case OPCODE_COMPRESSED_TEX_SUB_IMAGE_2D:      /* GL_ARB_texture_compress */
            CALL_CompressedTexSubImage2D(ctx->Exec,
                                            (n[1].e, n[2].i, n[3].i, n[4].i,
                                             n[5].i, n[6].i, n[7].e, n[8].i,
                                             get_pointer(&n[9])));
            break;
         case OPCODE_COMPRESSED_TEX_SUB_IMAGE_3D:      /* GL_ARB_texture_compress */
            CALL_CompressedTexSubImage3D(ctx->Exec,
                                            (n[1].e, n[2].i, n[3].i, n[4].i,
                                             n[5].i, n[6].i, n[7].i, n[8].i,
                                             n[9].e, n[10].i,
                                             get_pointer(&n[11])));
            break;
         case OPCODE_SAMPLE_COVERAGE:  /* GL_ARB_multisample */
            CALL_SampleCoverage(ctx->Exec, (n[1].f, n[2].b));
            break;
         case OPCODE_WINDOW_POS_ARB:   /* GL_ARB_window_pos */
            CALL_WindowPos3f(ctx->Exec, (n[1].f, n[2].f, n[3].f));
            break;
         case OPCODE_BIND_PROGRAM_NV:  /* GL_ARB_vertex_program */
            CALL_BindProgramARB(ctx->Exec, (n[1].e, n[2].ui));
            break;
         case OPCODE_PROGRAM_LOCAL_PARAMETER_ARB:
            CALL_ProgramLocalParameter4fARB(ctx->Exec,
                                            (n[1].e, n[2].ui, n[3].f, n[4].f,
                                             n[5].f, n[6].f));
            break;
         case OPCODE_ACTIVE_STENCIL_FACE_EXT:
            CALL_ActiveStencilFaceEXT(ctx->Exec, (n[1].e));
            break;
         case OPCODE_DEPTH_BOUNDS_EXT:
            CALL_DepthBoundsEXT(ctx->Exec, (n[1].f, n[2].f));
            break;
         case OPCODE_PROGRAM_STRING_ARB:
            CALL_ProgramStringARB(ctx->Exec,
                                  (n[1].e, n[2].e, n[3].i,
                                   get_pointer(&n[4])));
            break;
         case OPCODE_PROGRAM_ENV_PARAMETER_ARB:
            CALL_ProgramEnvParameter4fARB(ctx->Exec, (n[1].e, n[2].ui, n[3].f,
                                                      n[4].f, n[5].f,
                                                      n[6].f));
            break;
         case OPCODE_BEGIN_QUERY_ARB:
            CALL_BeginQuery(ctx->Exec, (n[1].e, n[2].ui));
            break;
         case OPCODE_END_QUERY_ARB:
            CALL_EndQuery(ctx->Exec, (n[1].e));
            break;
         case OPCODE_QUERY_COUNTER:
            CALL_QueryCounter(ctx->Exec, (n[1].ui, n[2].e));
            break;
         case OPCODE_BEGIN_QUERY_INDEXED:
            CALL_BeginQueryIndexed(ctx->Exec, (n[1].e, n[2].ui, n[3].ui));
            break;
         case OPCODE_END_QUERY_INDEXED:
            CALL_EndQueryIndexed(ctx->Exec, (n[1].e, n[2].ui));
            break;
         case OPCODE_DRAW_BUFFERS_ARB:
            {
               GLenum buffers[MAX_DRAW_BUFFERS];
               GLint i, count = MIN2(n[1].i, MAX_DRAW_BUFFERS);
               for (i = 0; i < count; i++)
                  buffers[i] = n[2 + i].e;
               CALL_DrawBuffers(ctx->Exec, (n[1].i, buffers));
            }
            break;
	 case OPCODE_BLIT_FRAMEBUFFER:
	    CALL_BlitFramebuffer(ctx->Exec, (n[1].i, n[2].i, n[3].i, n[4].i,
                                                n[5].i, n[6].i, n[7].i, n[8].i,
                                                n[9].i, n[10].e));
	    break;
	 case OPCODE_USE_PROGRAM:
	    CALL_UseProgram(ctx->Exec, (n[1].ui));
	    break;
	 case OPCODE_UNIFORM_1F:
	    CALL_Uniform1f(ctx->Exec, (n[1].i, n[2].f));
	    break;
	 case OPCODE_UNIFORM_2F:
	    CALL_Uniform2f(ctx->Exec, (n[1].i, n[2].f, n[3].f));
	    break;
	 case OPCODE_UNIFORM_3F:
	    CALL_Uniform3f(ctx->Exec, (n[1].i, n[2].f, n[3].f, n[4].f));
	    break;
	 case OPCODE_UNIFORM_4F:
	    CALL_Uniform4f(ctx->Exec,
                              (n[1].i, n[2].f, n[3].f, n[4].f, n[5].f));
	    break;
	 case OPCODE_UNIFORM_1FV:
	    CALL_Uniform1fv(ctx->Exec, (n[1].i, n[2].i, get_pointer(&n[3])));
	    break;
	 case OPCODE_UNIFORM_2FV:
	    CALL_Uniform2fv(ctx->Exec, (n[1].i, n[2].i, get_pointer(&n[3])));
	    break;
	 case OPCODE_UNIFORM_3FV:
	    CALL_Uniform3fv(ctx->Exec, (n[1].i, n[2].i, get_pointer(&n[3])));
	    break;
	 case OPCODE_UNIFORM_4FV:
	    CALL_Uniform4fv(ctx->Exec, (n[1].i, n[2].i, get_pointer(&n[3])));
	    break;
	 case OPCODE_UNIFORM_1I:
	    CALL_Uniform1i(ctx->Exec, (n[1].i, n[2].i));
	    break;
	 case OPCODE_UNIFORM_2I:
	    CALL_Uniform2i(ctx->Exec, (n[1].i, n[2].i, n[3].i));
	    break;
	 case OPCODE_UNIFORM_3I:
	    CALL_Uniform3i(ctx->Exec, (n[1].i, n[2].i, n[3].i, n[4].i));
	    break;
	 case OPCODE_UNIFORM_4I:
	    CALL_Uniform4i(ctx->Exec,
                              (n[1].i, n[2].i, n[3].i, n[4].i, n[5].i));
	    break;
	 case OPCODE_UNIFORM_1IV:
	    CALL_Uniform1iv(ctx->Exec, (n[1].i, n[2].i, get_pointer(&n[3])));
	    break;
	 case OPCODE_UNIFORM_2IV:
	    CALL_Uniform2iv(ctx->Exec, (n[1].i, n[2].i, get_pointer(&n[3])));
	    break;
	 case OPCODE_UNIFORM_3IV:
	    CALL_Uniform3iv(ctx->Exec, (n[1].i, n[2].i, get_pointer(&n[3])));
	    break;
	 case OPCODE_UNIFORM_4IV:
	    CALL_Uniform4iv(ctx->Exec, (n[1].i, n[2].i, get_pointer(&n[3])));
	    break;
	 case OPCODE_UNIFORM_1UI:
	    /*CALL_Uniform1uiARB(ctx->Exec, (n[1].i, n[2].i));*/
	    break;
	 case OPCODE_UNIFORM_2UI:
	    /*CALL_Uniform2uiARB(ctx->Exec, (n[1].i, n[2].i, n[3].i));*/
	    break;
	 case OPCODE_UNIFORM_3UI:
	    /*CALL_Uniform3uiARB(ctx->Exec, (n[1].i, n[2].i, n[3].i, n[4].i));*/
	    break;
	 case OPCODE_UNIFORM_4UI:
	    /*CALL_Uniform4uiARB(ctx->Exec,
                              (n[1].i, n[2].i, n[3].i, n[4].i, n[5].i));
            */
	    break;
	 case OPCODE_UNIFORM_1UIV:
	    /*CALL_Uniform1uivARB(ctx->Exec, (n[1].i, n[2].i,
                                              get_pointer(&n[3])));*/
	    break;
	 case OPCODE_UNIFORM_2UIV:
	    /*CALL_Uniform2uivARB(ctx->Exec, (n[1].i, n[2].i,
                                              get_pointer(&n[3])));*/
	    break;
	 case OPCODE_UNIFORM_3UIV:
	    /*CALL_Uniform3uivARB(ctx->Exec, (n[1].i, n[2].i,
                                              get_pointer(&n[3])));*/
	    break;
	 case OPCODE_UNIFORM_4UIV:
	    /*CALL_Uniform4uivARB(ctx->Exec, (n[1].i, n[2].i,
                                              get_pointer(&n[3])));*/
	    break;
	 case OPCODE_UNIFORM_MATRIX22:
	    CALL_UniformMatrix2fv(ctx->Exec,
                                  (n[1].i, n[2].i, n[3].b, get_pointer(&n[4])));
	    break;
	 case OPCODE_UNIFORM_MATRIX33:
	    CALL_UniformMatrix3fv(ctx->Exec,
                                  (n[1].i, n[2].i, n[3].b, get_pointer(&n[4])));
	    break;
	 case OPCODE_UNIFORM_MATRIX44:
	    CALL_UniformMatrix4fv(ctx->Exec,
                                  (n[1].i, n[2].i, n[3].b, get_pointer(&n[4])));
	    break;
	 case OPCODE_UNIFORM_MATRIX23:
	    CALL_UniformMatrix2x3fv(ctx->Exec,
                                    (n[1].i, n[2].i, n[3].b, get_pointer(&n[4])));
	    break;
	 case OPCODE_UNIFORM_MATRIX32:
	    CALL_UniformMatrix3x2fv(ctx->Exec,
                                    (n[1].i, n[2].i, n[3].b, get_pointer(&n[4])));
	    break;
	 case OPCODE_UNIFORM_MATRIX24:
	    CALL_UniformMatrix2x4fv(ctx->Exec,
                                    (n[1].i, n[2].i, n[3].b, get_pointer(&n[4])));
	    break;
	 case OPCODE_UNIFORM_MATRIX42:
	    CALL_UniformMatrix4x2fv(ctx->Exec,
                                    (n[1].i, n[2].i, n[3].b, get_pointer(&n[4])));
	    break;
	 case OPCODE_UNIFORM_MATRIX34:
	    CALL_UniformMatrix3x4fv(ctx->Exec,
                                    (n[1].i, n[2].i, n[3].b, get_pointer(&n[4])));
	    break;
	 case OPCODE_UNIFORM_MATRIX43:
	    CALL_UniformMatrix4x3fv(ctx->Exec,
                                    (n[1].i, n[2].i, n[3].b, get_pointer(&n[4])));
	    break;

	 case OPCODE_USE_PROGRAM_STAGES:
	    CALL_UseProgramStages(ctx->Exec, (n[1].ui, n[2].ui, n[3].ui));
	    break;
         case OPCODE_PROGRAM_UNIFORM_1F:
            CALL_ProgramUniform1f(ctx->Exec, (n[1].ui, n[2].i, n[3].f));
            break;
         case OPCODE_PROGRAM_UNIFORM_2F:
            CALL_ProgramUniform2f(ctx->Exec, (n[1].ui, n[2].i, n[3].f, n[4].f));
            break;
         case OPCODE_PROGRAM_UNIFORM_3F:
            CALL_ProgramUniform3f(ctx->Exec, (n[1].ui, n[2].i,
                                              n[3].f, n[4].f, n[5].f));
            break;
         case OPCODE_PROGRAM_UNIFORM_4F:
            CALL_ProgramUniform4f(ctx->Exec, (n[1].ui, n[2].i,
                                              n[3].f, n[4].f, n[5].f, n[6].f));
            break;
         case OPCODE_PROGRAM_UNIFORM_1FV:
            CALL_ProgramUniform1fv(ctx->Exec, (n[1].ui, n[2].i, n[3].i,
                                               get_pointer(&n[4])));
            break;
         case OPCODE_PROGRAM_UNIFORM_2FV:
            CALL_ProgramUniform2fv(ctx->Exec, (n[1].ui, n[2].i, n[3].i,
                                               get_pointer(&n[4])));
            break;
         case OPCODE_PROGRAM_UNIFORM_3FV:
            CALL_ProgramUniform3fv(ctx->Exec, (n[1].ui, n[2].i, n[3].i,
                                               get_pointer(&n[4])));
            break;
         case OPCODE_PROGRAM_UNIFORM_4FV:
            CALL_ProgramUniform4fv(ctx->Exec, (n[1].ui, n[2].i, n[3].i,
                                               get_pointer(&n[4])));
            break;
         case OPCODE_PROGRAM_UNIFORM_1I:
            CALL_ProgramUniform1i(ctx->Exec, (n[1].ui, n[2].i, n[3].i));
            break;
         case OPCODE_PROGRAM_UNIFORM_2I:
            CALL_ProgramUniform2i(ctx->Exec, (n[1].ui, n[2].i, n[3].i, n[4].i));
            break;
         case OPCODE_PROGRAM_UNIFORM_3I:
            CALL_ProgramUniform3i(ctx->Exec, (n[1].ui, n[2].i,
                                              n[3].i, n[4].i, n[5].i));
            break;
         case OPCODE_PROGRAM_UNIFORM_4I:
            CALL_ProgramUniform4i(ctx->Exec, (n[1].ui, n[2].i,
                                              n[3].i, n[4].i, n[5].i, n[6].i));
            break;
         case OPCODE_PROGRAM_UNIFORM_1IV:
            CALL_ProgramUniform1iv(ctx->Exec, (n[1].ui, n[2].i, n[3].i,
                                               get_pointer(&n[4])));
            break;
         case OPCODE_PROGRAM_UNIFORM_2IV:
            CALL_ProgramUniform2iv(ctx->Exec, (n[1].ui, n[2].i, n[3].i,
                                               get_pointer(&n[4])));
            break;
         case OPCODE_PROGRAM_UNIFORM_3IV:
            CALL_ProgramUniform3iv(ctx->Exec, (n[1].ui, n[2].i, n[3].i,
                                               get_pointer(&n[4])));
            break;
         case OPCODE_PROGRAM_UNIFORM_4IV:
            CALL_ProgramUniform4iv(ctx->Exec, (n[1].ui, n[2].i, n[3].i,
                                               get_pointer(&n[4])));
            break;
         case OPCODE_PROGRAM_UNIFORM_1UI:
            CALL_ProgramUniform1ui(ctx->Exec, (n[1].ui, n[2].i, n[3].ui));
            break;
         case OPCODE_PROGRAM_UNIFORM_2UI:
            CALL_ProgramUniform2ui(ctx->Exec, (n[1].ui, n[2].i,
                                               n[3].ui, n[4].ui));
            break;
         case OPCODE_PROGRAM_UNIFORM_3UI:
            CALL_ProgramUniform3ui(ctx->Exec, (n[1].ui, n[2].i,
                                               n[3].ui, n[4].ui, n[5].ui));
            break;
         case OPCODE_PROGRAM_UNIFORM_4UI:
            CALL_ProgramUniform4ui(ctx->Exec, (n[1].ui, n[2].i,
                                               n[3].ui,
                                               n[4].ui, n[5].ui, n[6].ui));
            break;
         case OPCODE_PROGRAM_UNIFORM_1UIV:
            CALL_ProgramUniform1uiv(ctx->Exec, (n[1].ui, n[2].i, n[3].i,
                                                get_pointer(&n[4])));
            break;
         case OPCODE_PROGRAM_UNIFORM_2UIV:
            CALL_ProgramUniform2uiv(ctx->Exec, (n[1].ui, n[2].i, n[3].i,
                                                get_pointer(&n[4])));
            break;
         case OPCODE_PROGRAM_UNIFORM_3UIV:
            CALL_ProgramUniform3uiv(ctx->Exec, (n[1].ui, n[2].i, n[3].i,
                                                get_pointer(&n[4])));
            break;
         case OPCODE_PROGRAM_UNIFORM_4UIV:
            CALL_ProgramUniform4uiv(ctx->Exec, (n[1].ui, n[2].i, n[3].i,
                                                get_pointer(&n[4])));
            break;
         case OPCODE_PROGRAM_UNIFORM_MATRIX22F:
            CALL_ProgramUniformMatrix2fv(ctx->Exec,
                                         (n[1].ui, n[2].i, n[3].i, n[4].b,
                                          get_pointer(&n[5])));
            break;
         case OPCODE_PROGRAM_UNIFORM_MATRIX23F:
            CALL_ProgramUniformMatrix2x3fv(ctx->Exec,
                                           (n[1].ui, n[2].i, n[3].i, n[4].b,
                                            get_pointer(&n[5])));
            break;
         case OPCODE_PROGRAM_UNIFORM_MATRIX24F:
            CALL_ProgramUniformMatrix2x4fv(ctx->Exec,
                                           (n[1].ui, n[2].i, n[3].i, n[4].b,
                                            get_pointer(&n[5])));
            break;
         case OPCODE_PROGRAM_UNIFORM_MATRIX32F:
            CALL_ProgramUniformMatrix3x2fv(ctx->Exec,
                                           (n[1].ui, n[2].i, n[3].i, n[4].b,
                                            get_pointer(&n[5])));
            break;
         case OPCODE_PROGRAM_UNIFORM_MATRIX33F:
            CALL_ProgramUniformMatrix3fv(ctx->Exec,
                                         (n[1].ui, n[2].i, n[3].i, n[4].b,
                                          get_pointer(&n[5])));
            break;
         case OPCODE_PROGRAM_UNIFORM_MATRIX34F:
            CALL_ProgramUniformMatrix3x4fv(ctx->Exec,
                                           (n[1].ui, n[2].i, n[3].i, n[4].b,
                                            get_pointer(&n[5])));
            break;
         case OPCODE_PROGRAM_UNIFORM_MATRIX42F:
            CALL_ProgramUniformMatrix4x2fv(ctx->Exec,
                                           (n[1].ui, n[2].i, n[3].i, n[4].b,
                                            get_pointer(&n[5])));
            break;
         case OPCODE_PROGRAM_UNIFORM_MATRIX43F:
            CALL_ProgramUniformMatrix4x3fv(ctx->Exec,
                                           (n[1].ui, n[2].i, n[3].i, n[4].b,
                                            get_pointer(&n[5])));
            break;
         case OPCODE_PROGRAM_UNIFORM_MATRIX44F:
            CALL_ProgramUniformMatrix4fv(ctx->Exec,
                                         (n[1].ui, n[2].i, n[3].i, n[4].b,
                                          get_pointer(&n[5])));
            break;

         case OPCODE_CLAMP_COLOR:
            CALL_ClampColor(ctx->Exec, (n[1].e, n[2].e));
            break;

         case OPCODE_TEX_BUMP_PARAMETER_ATI:
            {
               GLfloat values[4];
               GLuint i, pname = n[1].ui;

               for (i = 0; i < 4; i++)
                  values[i] = n[1 + i].f;
               CALL_TexBumpParameterfvATI(ctx->Exec, (pname, values));
            }
            break;
         case OPCODE_BIND_FRAGMENT_SHADER_ATI:
            CALL_BindFragmentShaderATI(ctx->Exec, (n[1].i));
            break;
         case OPCODE_SET_FRAGMENT_SHADER_CONSTANTS_ATI:
            {
               GLfloat values[4];
               GLuint i, dst = n[1].ui;

               for (i = 0; i < 4; i++)
                  values[i] = n[1 + i].f;
               CALL_SetFragmentShaderConstantATI(ctx->Exec, (dst, values));
            }
            break;
         case OPCODE_ATTR_1F_NV:
            CALL_VertexAttrib1fNV(ctx->Exec, (n[1].e, n[2].f));
            break;
         case OPCODE_ATTR_2F_NV:
            /* Really shouldn't have to do this - the Node structure
             * is convenient, but it would be better to store the data
             * packed appropriately so that it can be sent directly
             * on.  With x86_64 becoming common, this will start to
             * matter more.
             */
            if (sizeof(Node) == sizeof(GLfloat))
               CALL_VertexAttrib2fvNV(ctx->Exec, (n[1].e, &n[2].f));
            else
               CALL_VertexAttrib2fNV(ctx->Exec, (n[1].e, n[2].f, n[3].f));
            break;
         case OPCODE_ATTR_3F_NV:
            if (sizeof(Node) == sizeof(GLfloat))
               CALL_VertexAttrib3fvNV(ctx->Exec, (n[1].e, &n[2].f));
            else
               CALL_VertexAttrib3fNV(ctx->Exec, (n[1].e, n[2].f, n[3].f,
                                                 n[4].f));
            break;
         case OPCODE_ATTR_4F_NV:
            if (sizeof(Node) == sizeof(GLfloat))
               CALL_VertexAttrib4fvNV(ctx->Exec, (n[1].e, &n[2].f));
            else
               CALL_VertexAttrib4fNV(ctx->Exec, (n[1].e, n[2].f, n[3].f,
                                                 n[4].f, n[5].f));
            break;
         case OPCODE_ATTR_1F_ARB:
            CALL_VertexAttrib1fARB(ctx->Exec, (n[1].e, n[2].f));
            break;
         case OPCODE_ATTR_2F_ARB:
            /* Really shouldn't have to do this - the Node structure
             * is convenient, but it would be better to store the data
             * packed appropriately so that it can be sent directly
             * on.  With x86_64 becoming common, this will start to
             * matter more.
             */
            if (sizeof(Node) == sizeof(GLfloat))
               CALL_VertexAttrib2fvARB(ctx->Exec, (n[1].e, &n[2].f));
            else
               CALL_VertexAttrib2fARB(ctx->Exec, (n[1].e, n[2].f, n[3].f));
            break;
         case OPCODE_ATTR_3F_ARB:
            if (sizeof(Node) == sizeof(GLfloat))
               CALL_VertexAttrib3fvARB(ctx->Exec, (n[1].e, &n[2].f));
            else
               CALL_VertexAttrib3fARB(ctx->Exec, (n[1].e, n[2].f, n[3].f,
                                                  n[4].f));
            break;
         case OPCODE_ATTR_4F_ARB:
            if (sizeof(Node) == sizeof(GLfloat))
               CALL_VertexAttrib4fvARB(ctx->Exec, (n[1].e, &n[2].f));
            else
               CALL_VertexAttrib4fARB(ctx->Exec, (n[1].e, n[2].f, n[3].f,
                                                  n[4].f, n[5].f));
            break;
         case OPCODE_MATERIAL:
            if (sizeof(Node) == sizeof(GLfloat))
               CALL_Materialfv(ctx->Exec, (n[1].e, n[2].e, &n[3].f));
            else {
               GLfloat f[4];
               f[0] = n[3].f;
               f[1] = n[4].f;
               f[2] = n[5].f;
               f[3] = n[6].f;
               CALL_Materialfv(ctx->Exec, (n[1].e, n[2].e, f));
            }
            break;
         case OPCODE_BEGIN:
            CALL_Begin(ctx->Exec, (n[1].e));
            break;
         case OPCODE_END:
            CALL_End(ctx->Exec, ());
            break;
         case OPCODE_RECTF:
            CALL_Rectf(ctx->Exec, (n[1].f, n[2].f, n[3].f, n[4].f));
            break;
         case OPCODE_EVAL_C1:
            CALL_EvalCoord1f(ctx->Exec, (n[1].f));
            break;
         case OPCODE_EVAL_C2:
            CALL_EvalCoord2f(ctx->Exec, (n[1].f, n[2].f));
            break;
         case OPCODE_EVAL_P1:
            CALL_EvalPoint1(ctx->Exec, (n[1].i));
            break;
         case OPCODE_EVAL_P2:
            CALL_EvalPoint2(ctx->Exec, (n[1].i, n[2].i));
            break;

         /* GL_EXT_texture_integer */
         case OPCODE_CLEARCOLOR_I:
            CALL_ClearColorIiEXT(ctx->Exec, (n[1].i, n[2].i, n[3].i, n[4].i));
            break;
         case OPCODE_CLEARCOLOR_UI:
            CALL_ClearColorIuiEXT(ctx->Exec,
                                  (n[1].ui, n[2].ui, n[3].ui, n[4].ui));
            break;
         case OPCODE_TEXPARAMETER_I:
            {
               GLint params[4];
               params[0] = n[3].i;
               params[1] = n[4].i;
               params[2] = n[5].i;
               params[3] = n[6].i;
               CALL_TexParameterIiv(ctx->Exec, (n[1].e, n[2].e, params));
            }
            break;
         case OPCODE_TEXPARAMETER_UI:
            {
               GLuint params[4];
               params[0] = n[3].ui;
               params[1] = n[4].ui;
               params[2] = n[5].ui;
               params[3] = n[6].ui;
               CALL_TexParameterIuiv(ctx->Exec, (n[1].e, n[2].e, params));
            }
            break;

         case OPCODE_VERTEX_ATTRIB_DIVISOR:
            /* GL_ARB_instanced_arrays */
            CALL_VertexAttribDivisor(ctx->Exec, (n[1].ui, n[2].ui));
            break;

         case OPCODE_TEXTURE_BARRIER_NV:
            CALL_TextureBarrierNV(ctx->Exec, ());
            break;

         /* GL_EXT/ARB_transform_feedback */
         case OPCODE_BEGIN_TRANSFORM_FEEDBACK:
            CALL_BeginTransformFeedback(ctx->Exec, (n[1].e));
            break;
         case OPCODE_END_TRANSFORM_FEEDBACK:
            CALL_EndTransformFeedback(ctx->Exec, ());
            break;
         case OPCODE_BIND_TRANSFORM_FEEDBACK:
            CALL_BindTransformFeedback(ctx->Exec, (n[1].e, n[2].ui));
            break;
         case OPCODE_PAUSE_TRANSFORM_FEEDBACK:
            CALL_PauseTransformFeedback(ctx->Exec, ());
            break;
         case OPCODE_RESUME_TRANSFORM_FEEDBACK:
            CALL_ResumeTransformFeedback(ctx->Exec, ());
            break;
         case OPCODE_DRAW_TRANSFORM_FEEDBACK:
            CALL_DrawTransformFeedback(ctx->Exec, (n[1].e, n[2].ui));
            break;
         case OPCODE_DRAW_TRANSFORM_FEEDBACK_STREAM:
            CALL_DrawTransformFeedbackStream(ctx->Exec,
                                             (n[1].e, n[2].ui, n[3].ui));
            break;
         case OPCODE_DRAW_TRANSFORM_FEEDBACK_INSTANCED:
            CALL_DrawTransformFeedbackInstanced(ctx->Exec,
                                                (n[1].e, n[2].ui, n[3].si));
            break;
         case OPCODE_DRAW_TRANSFORM_FEEDBACK_STREAM_INSTANCED:
            CALL_DrawTransformFeedbackStreamInstanced(ctx->Exec,
                                       (n[1].e, n[2].ui, n[3].ui, n[4].si));
            break;


         case OPCODE_BIND_SAMPLER:
            CALL_BindSampler(ctx->Exec, (n[1].ui, n[2].ui));
            break;
         case OPCODE_SAMPLER_PARAMETERIV:
            {
               GLint params[4];
               params[0] = n[3].i;
               params[1] = n[4].i;
               params[2] = n[5].i;
               params[3] = n[6].i;
               CALL_SamplerParameteriv(ctx->Exec, (n[1].ui, n[2].e, params));
            }
            break;
         case OPCODE_SAMPLER_PARAMETERFV:
            {
               GLfloat params[4];
               params[0] = n[3].f;
               params[1] = n[4].f;
               params[2] = n[5].f;
               params[3] = n[6].f;
               CALL_SamplerParameterfv(ctx->Exec, (n[1].ui, n[2].e, params));
            }
            break;
         case OPCODE_SAMPLER_PARAMETERIIV:
            {
               GLint params[4];
               params[0] = n[3].i;
               params[1] = n[4].i;
               params[2] = n[5].i;
               params[3] = n[6].i;
               CALL_SamplerParameterIiv(ctx->Exec, (n[1].ui, n[2].e, params));
            }
            break;
         case OPCODE_SAMPLER_PARAMETERUIV:
            {
               GLuint params[4];
               params[0] = n[3].ui;
               params[1] = n[4].ui;
               params[2] = n[5].ui;
               params[3] = n[6].ui;
               CALL_SamplerParameterIuiv(ctx->Exec, (n[1].ui, n[2].e, params));
            }
            break;

         /* GL_ARB_geometry_shader4 */
         case OPCODE_PROGRAM_PARAMETERI:
            CALL_ProgramParameteri(ctx->Exec, (n[1].ui, n[2].e, n[3].i));
            break;
         case OPCODE_FRAMEBUFFER_TEXTURE:
            CALL_FramebufferTexture(ctx->Exec, (n[1].e, n[2].e,
                                                   n[3].ui, n[4].i));
            break;
         case OPCODE_FRAMEBUFFER_TEXTURE_FACE:
            CALL_FramebufferTextureFaceARB(ctx->Exec, (n[1].e, n[2].e,
                                                       n[3].ui, n[4].i, n[5].e));
            break;

         /* GL_ARB_sync */
         case OPCODE_WAIT_SYNC:
            {
               union uint64_pair p;
               p.uint32[0] = n[2].ui;
               p.uint32[1] = n[3].ui;
               CALL_WaitSync(ctx->Exec,
                             (get_pointer(&n[4]), n[1].bf, p.uint64));
            }
            break;

         /* GL_NV_conditional_render */
         case OPCODE_BEGIN_CONDITIONAL_RENDER:
            CALL_BeginConditionalRender(ctx->Exec, (n[1].i, n[2].e));
            break;
         case OPCODE_END_CONDITIONAL_RENDER:
            CALL_EndConditionalRender(ctx->Exec, ());
            break;

         case OPCODE_UNIFORM_BLOCK_BINDING:
            CALL_UniformBlockBinding(ctx->Exec, (n[1].ui, n[2].ui, n[3].ui));
            break;

         case OPCODE_CONTINUE:
            n = (Node *) get_pointer(&n[1]);
            break;
         case OPCODE_NOP:
            /* no-op */
            break;
         case OPCODE_END_OF_LIST:
            done = GL_TRUE;
            break;
         default:
            {
               char msg[1000];
               _mesa_snprintf(msg, sizeof(msg), "Error in execute_list: opcode=%d",
                             (int) opcode);
               _mesa_problem(ctx, "%s", msg);
            }
            done = GL_TRUE;
         }

         /* increment n to point to next compiled command */
         if (opcode != OPCODE_CONTINUE) {
            n += InstSize[opcode];
         }
      }
   }

   if (ctx->Driver.EndCallList)
      ctx->Driver.EndCallList(ctx);

   ctx->ListState.CallDepth--;
}



/**********************************************************************/
/*                           GL functions                             */
/**********************************************************************/

/**
 * Test if a display list number is valid.
 */
GLboolean GLAPIENTRY
_mesa_IsList(GLuint list)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);      /* must be called before assert */
   ASSERT_OUTSIDE_BEGIN_END_WITH_RETVAL(ctx, GL_FALSE);
   return islist(ctx, list);
}


/**
 * Delete a sequence of consecutive display lists.
 */
void GLAPIENTRY
_mesa_DeleteLists(GLuint list, GLsizei range)
{
   GET_CURRENT_CONTEXT(ctx);
   GLuint i;
   FLUSH_VERTICES(ctx, 0);      /* must be called before assert */
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   if (range < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glDeleteLists");
      return;
   }
   for (i = list; i < list + range; i++) {
      destroy_list(ctx, i);
   }
}


/**
 * Return a display list number, n, such that lists n through n+range-1
 * are free.
 */
GLuint GLAPIENTRY
_mesa_GenLists(GLsizei range)
{
   GET_CURRENT_CONTEXT(ctx);
   GLuint base;
   FLUSH_VERTICES(ctx, 0);      /* must be called before assert */
   ASSERT_OUTSIDE_BEGIN_END_WITH_RETVAL(ctx, 0);

   if (range < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glGenLists");
      return 0;
   }
   if (range == 0) {
      return 0;
   }

   /*
    * Make this an atomic operation
    */
   mtx_lock(&ctx->Shared->Mutex);

   base = _mesa_HashFindFreeKeyBlock(ctx->Shared->DisplayList, range);
   if (base) {
      /* reserve the list IDs by with empty/dummy lists */
      GLint i;
      for (i = 0; i < range; i++) {
         _mesa_HashInsert(ctx->Shared->DisplayList, base + i,
                          make_list(base + i, 1));
      }
   }

   mtx_unlock(&ctx->Shared->Mutex);

   return base;
}


/**
 * Begin a new display list.
 */
void GLAPIENTRY
_mesa_NewList(GLuint name, GLenum mode)
{
   GET_CURRENT_CONTEXT(ctx);

   FLUSH_CURRENT(ctx, 0);       /* must be called before assert */
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glNewList %u %s\n", name,
                  _mesa_lookup_enum_by_nr(mode));

   if (name == 0) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glNewList");
      return;
   }

   if (mode != GL_COMPILE && mode != GL_COMPILE_AND_EXECUTE) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glNewList");
      return;
   }

   if (ctx->ListState.CurrentList) {
      /* already compiling a display list */
      _mesa_error(ctx, GL_INVALID_OPERATION, "glNewList");
      return;
   }

   ctx->CompileFlag = GL_TRUE;
   ctx->ExecuteFlag = (mode == GL_COMPILE_AND_EXECUTE);

   /* Reset accumulated list state */
   invalidate_saved_current_state( ctx );

   /* Allocate new display list */
   ctx->ListState.CurrentList = make_list(name, BLOCK_SIZE);
   ctx->ListState.CurrentBlock = ctx->ListState.CurrentList->Head;
   ctx->ListState.CurrentPos = 0;

   ctx->Driver.NewList(ctx, name, mode);

   ctx->CurrentDispatch = ctx->Save;
   _glapi_set_dispatch(ctx->CurrentDispatch);
}


/**
 * End definition of current display list. 
 */
void GLAPIENTRY
_mesa_EndList(void)
{
   GET_CURRENT_CONTEXT(ctx);
   SAVE_FLUSH_VERTICES(ctx);
   FLUSH_VERTICES(ctx, 0);

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glEndList\n");

   if (ctx->ExecuteFlag && _mesa_inside_dlist_begin_end(ctx)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glEndList() called inside glBegin/End");
   }

   /* Check that a list is under construction */
   if (!ctx->ListState.CurrentList) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glEndList");
      return;
   }
   
   /* Call before emitting END_OF_LIST, in case the driver wants to
    * emit opcodes itself.
    */
   ctx->Driver.EndList(ctx);

   (void) alloc_instruction(ctx, OPCODE_END_OF_LIST, 0);

   trim_list(ctx);

   /* Destroy old list, if any */
   destroy_list(ctx, ctx->ListState.CurrentList->Name);

   /* Install the new list */
   _mesa_HashInsert(ctx->Shared->DisplayList,
                    ctx->ListState.CurrentList->Name,
                    ctx->ListState.CurrentList);


   if (MESA_VERBOSE & VERBOSE_DISPLAY_LIST)
      mesa_print_display_list(ctx->ListState.CurrentList->Name);

   ctx->ListState.CurrentList = NULL;
   ctx->ListState.CurrentBlock = NULL;
   ctx->ListState.CurrentPos = 0;
   ctx->ExecuteFlag = GL_TRUE;
   ctx->CompileFlag = GL_FALSE;

   ctx->CurrentDispatch = ctx->Exec;
   _glapi_set_dispatch(ctx->CurrentDispatch);
}


void GLAPIENTRY
_mesa_CallList(GLuint list)
{
   GLboolean save_compile_flag;
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_CURRENT(ctx, 0);

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glCallList %d\n", list);

   if (list == 0) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glCallList(list==0)");
      return;
   }

   if (0)
      mesa_print_display_list( list );

   /* VERY IMPORTANT:  Save the CompileFlag status, turn it off,
    * execute the display list, and restore the CompileFlag.
    */
   save_compile_flag = ctx->CompileFlag;
   if (save_compile_flag) {
      ctx->CompileFlag = GL_FALSE;
   }

   execute_list(ctx, list);
   ctx->CompileFlag = save_compile_flag;

   /* also restore API function pointers to point to "save" versions */
   if (save_compile_flag) {
      ctx->CurrentDispatch = ctx->Save;
      _glapi_set_dispatch(ctx->CurrentDispatch);
   }
}


/**
 * Execute glCallLists:  call multiple display lists.
 */
void GLAPIENTRY
_mesa_CallLists(GLsizei n, GLenum type, const GLvoid * lists)
{
   GET_CURRENT_CONTEXT(ctx);
   GLint i;
   GLboolean save_compile_flag;

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glCallLists %d\n", n);

   switch (type) {
   case GL_BYTE:
   case GL_UNSIGNED_BYTE:
   case GL_SHORT:
   case GL_UNSIGNED_SHORT:
   case GL_INT:
   case GL_UNSIGNED_INT:
   case GL_FLOAT:
   case GL_2_BYTES:
   case GL_3_BYTES:
   case GL_4_BYTES:
      /* OK */
      break;
   default:
      _mesa_error(ctx, GL_INVALID_ENUM, "glCallLists(type)");
      return;
   }

   /* Save the CompileFlag status, turn it off, execute display list,
    * and restore the CompileFlag.
    */
   save_compile_flag = ctx->CompileFlag;
   ctx->CompileFlag = GL_FALSE;

   for (i = 0; i < n; i++) {
      GLuint list = (GLuint) (ctx->List.ListBase + translate_id(i, type, lists));
      execute_list(ctx, list);
   }

   ctx->CompileFlag = save_compile_flag;

   /* also restore API function pointers to point to "save" versions */
   if (save_compile_flag) {
      ctx->CurrentDispatch = ctx->Save;
      _glapi_set_dispatch(ctx->CurrentDispatch);
   }
}


/**
 * Set the offset added to list numbers in glCallLists.
 */
void GLAPIENTRY
_mesa_ListBase(GLuint base)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);      /* must be called before assert */
   ASSERT_OUTSIDE_BEGIN_END(ctx);
   ctx->List.ListBase = base;
}

/**
 * Setup the given dispatch table to point to Mesa's display list
 * building functions.
 *
 * This does not include any of the tnl functions - they are
 * initialized from _mesa_init_api_defaults and from the active vtxfmt
 * struct.
 */
void
_mesa_initialize_save_table(const struct gl_context *ctx)
{
   struct _glapi_table *table = ctx->Save;
   int numEntries = MAX2(_gloffset_COUNT, _glapi_get_dispatch_table_size());

   /* Initially populate the dispatch table with the contents of the
    * normal-execution dispatch table.  This lets us skip populating functions
    * that should be called directly instead of compiled into display lists.
    */
   memcpy(table, ctx->Exec, numEntries * sizeof(_glapi_proc));

   _mesa_loopback_init_api_table(ctx, table);

   /* VBO functions */
   vbo_initialize_save_dispatch(ctx, table);

   /* GL 1.0 */
   SET_Accum(table, save_Accum);
   SET_AlphaFunc(table, save_AlphaFunc);
   SET_Bitmap(table, save_Bitmap);
   SET_BlendFunc(table, save_BlendFunc);
   SET_CallList(table, save_CallList);
   SET_CallLists(table, save_CallLists);
   SET_Clear(table, save_Clear);
   SET_ClearAccum(table, save_ClearAccum);
   SET_ClearColor(table, save_ClearColor);
   SET_ClearDepth(table, save_ClearDepth);
   SET_ClearIndex(table, save_ClearIndex);
   SET_ClearStencil(table, save_ClearStencil);
   SET_ClipPlane(table, save_ClipPlane);
   SET_ColorMask(table, save_ColorMask);
   SET_ColorMaski(table, save_ColorMaskIndexed);
   SET_ColorMaterial(table, save_ColorMaterial);
   SET_CopyPixels(table, save_CopyPixels);
   SET_CullFace(table, save_CullFace);
   SET_DepthFunc(table, save_DepthFunc);
   SET_DepthMask(table, save_DepthMask);
   SET_DepthRange(table, save_DepthRange);
   SET_Disable(table, save_Disable);
   SET_Disablei(table, save_DisableIndexed);
   SET_DrawBuffer(table, save_DrawBuffer);
   SET_DrawPixels(table, save_DrawPixels);
   SET_Enable(table, save_Enable);
   SET_Enablei(table, save_EnableIndexed);
   SET_EvalMesh1(table, save_EvalMesh1);
   SET_EvalMesh2(table, save_EvalMesh2);
   SET_Fogf(table, save_Fogf);
   SET_Fogfv(table, save_Fogfv);
   SET_Fogi(table, save_Fogi);
   SET_Fogiv(table, save_Fogiv);
   SET_FrontFace(table, save_FrontFace);
   SET_Frustum(table, save_Frustum);
   SET_Hint(table, save_Hint);
   SET_IndexMask(table, save_IndexMask);
   SET_InitNames(table, save_InitNames);
   SET_LightModelf(table, save_LightModelf);
   SET_LightModelfv(table, save_LightModelfv);
   SET_LightModeli(table, save_LightModeli);
   SET_LightModeliv(table, save_LightModeliv);
   SET_Lightf(table, save_Lightf);
   SET_Lightfv(table, save_Lightfv);
   SET_Lighti(table, save_Lighti);
   SET_Lightiv(table, save_Lightiv);
   SET_LineStipple(table, save_LineStipple);
   SET_LineWidth(table, save_LineWidth);
   SET_ListBase(table, save_ListBase);
   SET_LoadIdentity(table, save_LoadIdentity);
   SET_LoadMatrixd(table, save_LoadMatrixd);
   SET_LoadMatrixf(table, save_LoadMatrixf);
   SET_LoadName(table, save_LoadName);
   SET_LogicOp(table, save_LogicOp);
   SET_Map1d(table, save_Map1d);
   SET_Map1f(table, save_Map1f);
   SET_Map2d(table, save_Map2d);
   SET_Map2f(table, save_Map2f);
   SET_MapGrid1d(table, save_MapGrid1d);
   SET_MapGrid1f(table, save_MapGrid1f);
   SET_MapGrid2d(table, save_MapGrid2d);
   SET_MapGrid2f(table, save_MapGrid2f);
   SET_MatrixMode(table, save_MatrixMode);
   SET_MultMatrixd(table, save_MultMatrixd);
   SET_MultMatrixf(table, save_MultMatrixf);
   SET_NewList(table, save_NewList);
   SET_Ortho(table, save_Ortho);
   SET_PassThrough(table, save_PassThrough);
   SET_PixelMapfv(table, save_PixelMapfv);
   SET_PixelMapuiv(table, save_PixelMapuiv);
   SET_PixelMapusv(table, save_PixelMapusv);
   SET_PixelTransferf(table, save_PixelTransferf);
   SET_PixelTransferi(table, save_PixelTransferi);
   SET_PixelZoom(table, save_PixelZoom);
   SET_PointSize(table, save_PointSize);
   SET_PolygonMode(table, save_PolygonMode);
   SET_PolygonOffset(table, save_PolygonOffset);
   SET_PolygonStipple(table, save_PolygonStipple);
   SET_PopAttrib(table, save_PopAttrib);
   SET_PopMatrix(table, save_PopMatrix);
   SET_PopName(table, save_PopName);
   SET_PushAttrib(table, save_PushAttrib);
   SET_PushMatrix(table, save_PushMatrix);
   SET_PushName(table, save_PushName);
   SET_RasterPos2d(table, save_RasterPos2d);
   SET_RasterPos2dv(table, save_RasterPos2dv);
   SET_RasterPos2f(table, save_RasterPos2f);
   SET_RasterPos2fv(table, save_RasterPos2fv);
   SET_RasterPos2i(table, save_RasterPos2i);
   SET_RasterPos2iv(table, save_RasterPos2iv);
   SET_RasterPos2s(table, save_RasterPos2s);
   SET_RasterPos2sv(table, save_RasterPos2sv);
   SET_RasterPos3d(table, save_RasterPos3d);
   SET_RasterPos3dv(table, save_RasterPos3dv);
   SET_RasterPos3f(table, save_RasterPos3f);
   SET_RasterPos3fv(table, save_RasterPos3fv);
   SET_RasterPos3i(table, save_RasterPos3i);
   SET_RasterPos3iv(table, save_RasterPos3iv);
   SET_RasterPos3s(table, save_RasterPos3s);
   SET_RasterPos3sv(table, save_RasterPos3sv);
   SET_RasterPos4d(table, save_RasterPos4d);
   SET_RasterPos4dv(table, save_RasterPos4dv);
   SET_RasterPos4f(table, save_RasterPos4f);
   SET_RasterPos4fv(table, save_RasterPos4fv);
   SET_RasterPos4i(table, save_RasterPos4i);
   SET_RasterPos4iv(table, save_RasterPos4iv);
   SET_RasterPos4s(table, save_RasterPos4s);
   SET_RasterPos4sv(table, save_RasterPos4sv);
   SET_ReadBuffer(table, save_ReadBuffer);
   SET_Rectf(table, save_Rectf);
   SET_Rotated(table, save_Rotated);
   SET_Rotatef(table, save_Rotatef);
   SET_Scaled(table, save_Scaled);
   SET_Scalef(table, save_Scalef);
   SET_Scissor(table, save_Scissor);
   SET_ShadeModel(table, save_ShadeModel);
   SET_StencilFunc(table, save_StencilFunc);
   SET_StencilMask(table, save_StencilMask);
   SET_StencilOp(table, save_StencilOp);
   SET_TexEnvf(table, save_TexEnvf);
   SET_TexEnvfv(table, save_TexEnvfv);
   SET_TexEnvi(table, save_TexEnvi);
   SET_TexEnviv(table, save_TexEnviv);
   SET_TexGend(table, save_TexGend);
   SET_TexGendv(table, save_TexGendv);
   SET_TexGenf(table, save_TexGenf);
   SET_TexGenfv(table, save_TexGenfv);
   SET_TexGeni(table, save_TexGeni);
   SET_TexGeniv(table, save_TexGeniv);
   SET_TexImage1D(table, save_TexImage1D);
   SET_TexImage2D(table, save_TexImage2D);
   SET_TexParameterf(table, save_TexParameterf);
   SET_TexParameterfv(table, save_TexParameterfv);
   SET_TexParameteri(table, save_TexParameteri);
   SET_TexParameteriv(table, save_TexParameteriv);
   SET_Translated(table, save_Translated);
   SET_Translatef(table, save_Translatef);
   SET_Viewport(table, save_Viewport);

   /* GL 1.1 */
   SET_BindTexture(table, save_BindTexture);
   SET_CopyTexImage1D(table, save_CopyTexImage1D);
   SET_CopyTexImage2D(table, save_CopyTexImage2D);
   SET_CopyTexSubImage1D(table, save_CopyTexSubImage1D);
   SET_CopyTexSubImage2D(table, save_CopyTexSubImage2D);
   SET_PrioritizeTextures(table, save_PrioritizeTextures);
   SET_TexSubImage1D(table, save_TexSubImage1D);
   SET_TexSubImage2D(table, save_TexSubImage2D);

   /* GL 1.2 */
   SET_CopyTexSubImage3D(table, save_CopyTexSubImage3D);
   SET_TexImage3D(table, save_TexImage3D);
   SET_TexSubImage3D(table, save_TexSubImage3D);

   /* GL 2.0 */
   SET_StencilFuncSeparate(table, save_StencilFuncSeparate);
   SET_StencilMaskSeparate(table, save_StencilMaskSeparate);
   SET_StencilOpSeparate(table, save_StencilOpSeparate);

   /* ATI_separate_stencil */ 
   SET_StencilFuncSeparateATI(table, save_StencilFuncSeparateATI);

   /* GL_ARB_imaging */
   /* Not all are supported */
   SET_BlendColor(table, save_BlendColor);
   SET_BlendEquation(table, save_BlendEquation);

   /* 2. GL_EXT_blend_color */
#if 0
   SET_BlendColorEXT(table, save_BlendColorEXT);
#endif

   /* 3. GL_EXT_polygon_offset */
   SET_PolygonOffsetEXT(table, save_PolygonOffsetEXT);

   /* 6. GL_EXT_texture3d */
#if 0
   SET_CopyTexSubImage3DEXT(table, save_CopyTexSubImage3D);
   SET_TexImage3DEXT(table, save_TexImage3DEXT);
   SET_TexSubImage3DEXT(table, save_TexSubImage3D);
#endif

   /* 37. GL_EXT_blend_minmax */
#if 0
   SET_BlendEquationEXT(table, save_BlendEquationEXT);
#endif

   /* 54. GL_EXT_point_parameters */
   SET_PointParameterf(table, save_PointParameterfEXT);
   SET_PointParameterfv(table, save_PointParameterfvEXT);

   /* 173. GL_EXT_blend_func_separate */
   SET_BlendFuncSeparate(table, save_BlendFuncSeparateEXT);

   /* 197. GL_MESA_window_pos */
   SET_WindowPos2d(table, save_WindowPos2dMESA);
   SET_WindowPos2dv(table, save_WindowPos2dvMESA);
   SET_WindowPos2f(table, save_WindowPos2fMESA);
   SET_WindowPos2fv(table, save_WindowPos2fvMESA);
   SET_WindowPos2i(table, save_WindowPos2iMESA);
   SET_WindowPos2iv(table, save_WindowPos2ivMESA);
   SET_WindowPos2s(table, save_WindowPos2sMESA);
   SET_WindowPos2sv(table, save_WindowPos2svMESA);
   SET_WindowPos3d(table, save_WindowPos3dMESA);
   SET_WindowPos3dv(table, save_WindowPos3dvMESA);
   SET_WindowPos3f(table, save_WindowPos3fMESA);
   SET_WindowPos3fv(table, save_WindowPos3fvMESA);
   SET_WindowPos3i(table, save_WindowPos3iMESA);
   SET_WindowPos3iv(table, save_WindowPos3ivMESA);
   SET_WindowPos3s(table, save_WindowPos3sMESA);
   SET_WindowPos3sv(table, save_WindowPos3svMESA);
   SET_WindowPos4dMESA(table, save_WindowPos4dMESA);
   SET_WindowPos4dvMESA(table, save_WindowPos4dvMESA);
   SET_WindowPos4fMESA(table, save_WindowPos4fMESA);
   SET_WindowPos4fvMESA(table, save_WindowPos4fvMESA);
   SET_WindowPos4iMESA(table, save_WindowPos4iMESA);
   SET_WindowPos4ivMESA(table, save_WindowPos4ivMESA);
   SET_WindowPos4sMESA(table, save_WindowPos4sMESA);
   SET_WindowPos4svMESA(table, save_WindowPos4svMESA);

   /* 233. GL_NV_vertex_program */
   /* The following commands DO NOT go into display lists:
    * AreProgramsResidentNV, IsProgramNV, GenProgramsNV, DeleteProgramsNV,
    * VertexAttribPointerNV, GetProgram*, GetVertexAttrib*
    */
   SET_BindProgramARB(table, save_BindProgramNV);

   /* 244. GL_ATI_envmap_bumpmap */
   SET_TexBumpParameterivATI(table, save_TexBumpParameterivATI);
   SET_TexBumpParameterfvATI(table, save_TexBumpParameterfvATI);

   /* 245. GL_ATI_fragment_shader */
   SET_BindFragmentShaderATI(table, save_BindFragmentShaderATI);
   SET_SetFragmentShaderConstantATI(table, save_SetFragmentShaderConstantATI);

   /* 262. GL_NV_point_sprite */
   SET_PointParameteri(table, save_PointParameteriNV);
   SET_PointParameteriv(table, save_PointParameterivNV);

   /* 268. GL_EXT_stencil_two_side */
   SET_ActiveStencilFaceEXT(table, save_ActiveStencilFaceEXT);

   /* ???. GL_EXT_depth_bounds_test */
   SET_DepthBoundsEXT(table, save_DepthBoundsEXT);

   /* ARB 1. GL_ARB_multitexture */
   SET_ActiveTexture(table, save_ActiveTextureARB);

   /* ARB 3. GL_ARB_transpose_matrix */
   SET_LoadTransposeMatrixd(table, save_LoadTransposeMatrixdARB);
   SET_LoadTransposeMatrixf(table, save_LoadTransposeMatrixfARB);
   SET_MultTransposeMatrixd(table, save_MultTransposeMatrixdARB);
   SET_MultTransposeMatrixf(table, save_MultTransposeMatrixfARB);

   /* ARB 5. GL_ARB_multisample */
   SET_SampleCoverage(table, save_SampleCoverageARB);

   /* ARB 12. GL_ARB_texture_compression */
   SET_CompressedTexImage3D(table, save_CompressedTexImage3DARB);
   SET_CompressedTexImage2D(table, save_CompressedTexImage2DARB);
   SET_CompressedTexImage1D(table, save_CompressedTexImage1DARB);
   SET_CompressedTexSubImage3D(table, save_CompressedTexSubImage3DARB);
   SET_CompressedTexSubImage2D(table, save_CompressedTexSubImage2DARB);
   SET_CompressedTexSubImage1D(table, save_CompressedTexSubImage1DARB);

   /* ARB 14. GL_ARB_point_parameters */
   /* aliased with EXT_point_parameters functions */

   /* ARB 25. GL_ARB_window_pos */
   /* aliased with MESA_window_pos functions */

   /* ARB 26. GL_ARB_vertex_program */
   /* ARB 27. GL_ARB_fragment_program */
   /* glVertexAttrib* functions alias the NV ones, handled elsewhere */
   SET_ProgramStringARB(table, save_ProgramStringARB);
   SET_BindProgramARB(table, save_BindProgramNV);
   SET_ProgramEnvParameter4dARB(table, save_ProgramEnvParameter4dARB);
   SET_ProgramEnvParameter4dvARB(table, save_ProgramEnvParameter4dvARB);
   SET_ProgramEnvParameter4fARB(table, save_ProgramEnvParameter4fARB);
   SET_ProgramEnvParameter4fvARB(table, save_ProgramEnvParameter4fvARB);
   SET_ProgramLocalParameter4dARB(table, save_ProgramLocalParameter4dARB);
   SET_ProgramLocalParameter4dvARB(table, save_ProgramLocalParameter4dvARB);
   SET_ProgramLocalParameter4fARB(table, save_ProgramLocalParameter4fARB);
   SET_ProgramLocalParameter4fvARB(table, save_ProgramLocalParameter4fvARB);

   SET_BeginQuery(table, save_BeginQueryARB);
   SET_EndQuery(table, save_EndQueryARB);
   SET_QueryCounter(table, save_QueryCounter);

   SET_DrawBuffers(table, save_DrawBuffersARB);

   SET_BlitFramebuffer(table, save_BlitFramebufferEXT);

   SET_UseProgram(table, save_UseProgramObjectARB);
   SET_Uniform1f(table, save_Uniform1fARB);
   SET_Uniform2f(table, save_Uniform2fARB);
   SET_Uniform3f(table, save_Uniform3fARB);
   SET_Uniform4f(table, save_Uniform4fARB);
   SET_Uniform1fv(table, save_Uniform1fvARB);
   SET_Uniform2fv(table, save_Uniform2fvARB);
   SET_Uniform3fv(table, save_Uniform3fvARB);
   SET_Uniform4fv(table, save_Uniform4fvARB);
   SET_Uniform1i(table, save_Uniform1iARB);
   SET_Uniform2i(table, save_Uniform2iARB);
   SET_Uniform3i(table, save_Uniform3iARB);
   SET_Uniform4i(table, save_Uniform4iARB);
   SET_Uniform1iv(table, save_Uniform1ivARB);
   SET_Uniform2iv(table, save_Uniform2ivARB);
   SET_Uniform3iv(table, save_Uniform3ivARB);
   SET_Uniform4iv(table, save_Uniform4ivARB);
   SET_UniformMatrix2fv(table, save_UniformMatrix2fvARB);
   SET_UniformMatrix3fv(table, save_UniformMatrix3fvARB);
   SET_UniformMatrix4fv(table, save_UniformMatrix4fvARB);
   SET_UniformMatrix2x3fv(table, save_UniformMatrix2x3fv);
   SET_UniformMatrix3x2fv(table, save_UniformMatrix3x2fv);
   SET_UniformMatrix2x4fv(table, save_UniformMatrix2x4fv);
   SET_UniformMatrix4x2fv(table, save_UniformMatrix4x2fv);
   SET_UniformMatrix3x4fv(table, save_UniformMatrix3x4fv);
   SET_UniformMatrix4x3fv(table, save_UniformMatrix4x3fv);

   /* 299. GL_EXT_blend_equation_separate */
   SET_BlendEquationSeparate(table, save_BlendEquationSeparateEXT);

   /* GL_EXT_gpu_program_parameters */
   SET_ProgramEnvParameters4fvEXT(table, save_ProgramEnvParameters4fvEXT);
   SET_ProgramLocalParameters4fvEXT(table, save_ProgramLocalParameters4fvEXT);

   /* 364. GL_EXT_provoking_vertex */
   SET_ProvokingVertex(table, save_ProvokingVertexEXT);

   /* GL_EXT_texture_integer */
   SET_ClearColorIiEXT(table, save_ClearColorIi);
   SET_ClearColorIuiEXT(table, save_ClearColorIui);
   SET_TexParameterIiv(table, save_TexParameterIiv);
   SET_TexParameterIuiv(table, save_TexParameterIuiv);

   /* GL_ARB_color_buffer_float */
   SET_ClampColor(table, save_ClampColorARB);

   /* GL 3.0 */
   SET_ClearBufferiv(table, save_ClearBufferiv);
   SET_ClearBufferuiv(table, save_ClearBufferuiv);
   SET_ClearBufferfv(table, save_ClearBufferfv);
   SET_ClearBufferfi(table, save_ClearBufferfi);
#if 0
   SET_Uniform1ui(table, save_Uniform1ui);
   SET_Uniform2ui(table, save_Uniform2ui);
   SET_Uniform3ui(table, save_Uniform3ui);
   SET_Uniform4ui(table, save_Uniform4ui);
   SET_Uniform1uiv(table, save_Uniform1uiv);
   SET_Uniform2uiv(table, save_Uniform2uiv);
   SET_Uniform3uiv(table, save_Uniform3uiv);
   SET_Uniform4uiv(table, save_Uniform4uiv);
#else
   (void) save_Uniform1ui;
   (void) save_Uniform2ui;
   (void) save_Uniform3ui;
   (void) save_Uniform4ui;
   (void) save_Uniform1uiv;
   (void) save_Uniform2uiv;
   (void) save_Uniform3uiv;
   (void) save_Uniform4uiv;
#endif

   /* These are: */
   SET_BeginTransformFeedback(table, save_BeginTransformFeedback);
   SET_EndTransformFeedback(table, save_EndTransformFeedback);
   SET_BindTransformFeedback(table, save_BindTransformFeedback);
   SET_PauseTransformFeedback(table, save_PauseTransformFeedback);
   SET_ResumeTransformFeedback(table, save_ResumeTransformFeedback);
   SET_DrawTransformFeedback(table, save_DrawTransformFeedback);
   SET_DrawTransformFeedbackStream(table, save_DrawTransformFeedbackStream);
   SET_DrawTransformFeedbackInstanced(table,
                                      save_DrawTransformFeedbackInstanced);
   SET_DrawTransformFeedbackStreamInstanced(table,
                                save_DrawTransformFeedbackStreamInstanced);
   SET_BeginQueryIndexed(table, save_BeginQueryIndexed);
   SET_EndQueryIndexed(table, save_EndQueryIndexed);

   /* GL_ARB_instanced_arrays */
   SET_VertexAttribDivisor(table, save_VertexAttribDivisor);

   /* GL_NV_texture_barrier */
   SET_TextureBarrierNV(table, save_TextureBarrierNV);

   SET_BindSampler(table, save_BindSampler);
   SET_SamplerParameteri(table, save_SamplerParameteri);
   SET_SamplerParameterf(table, save_SamplerParameterf);
   SET_SamplerParameteriv(table, save_SamplerParameteriv);
   SET_SamplerParameterfv(table, save_SamplerParameterfv);
   SET_SamplerParameterIiv(table, save_SamplerParameterIiv);
   SET_SamplerParameterIuiv(table, save_SamplerParameterIuiv);

   /* GL_ARB_draw_buffer_blend */
   SET_BlendFunciARB(table, save_BlendFunci);
   SET_BlendFuncSeparateiARB(table, save_BlendFuncSeparatei);
   SET_BlendEquationiARB(table, save_BlendEquationi);
   SET_BlendEquationSeparateiARB(table, save_BlendEquationSeparatei);

   /* GL_ARB_geometry_shader4 */
   SET_ProgramParameteri(table, save_ProgramParameteri);
   SET_FramebufferTexture(table, save_FramebufferTexture);
   SET_FramebufferTextureFaceARB(table, save_FramebufferTextureFace);

   /* GL_NV_conditional_render */
   SET_BeginConditionalRender(table, save_BeginConditionalRender);
   SET_EndConditionalRender(table, save_EndConditionalRender);

   /* GL_ARB_sync */
   SET_WaitSync(table, save_WaitSync);

   /* GL_ARB_uniform_buffer_object */
   SET_UniformBlockBinding(table, save_UniformBlockBinding);

   /* GL_ARB_draw_instanced */
   SET_DrawArraysInstancedARB(table, save_DrawArraysInstancedARB);
   SET_DrawElementsInstancedARB(table, save_DrawElementsInstancedARB);

   /* GL_ARB_draw_elements_base_vertex */
   SET_DrawElementsInstancedBaseVertex(table, save_DrawElementsInstancedBaseVertexARB);

   /* GL_ARB_base_instance */
   SET_DrawArraysInstancedBaseInstance(table, save_DrawArraysInstancedBaseInstance);
   SET_DrawElementsInstancedBaseInstance(table, save_DrawElementsInstancedBaseInstance);
   SET_DrawElementsInstancedBaseVertexBaseInstance(table, save_DrawElementsInstancedBaseVertexBaseInstance);

   /* OpenGL 4.2 / GL_ARB_separate_shader_objects */
   SET_UseProgramStages(table, save_UseProgramStages);
   SET_ProgramUniform1f(table, save_ProgramUniform1f);
   SET_ProgramUniform2f(table, save_ProgramUniform2f);
   SET_ProgramUniform3f(table, save_ProgramUniform3f);
   SET_ProgramUniform4f(table, save_ProgramUniform4f);
   SET_ProgramUniform1fv(table, save_ProgramUniform1fv);
   SET_ProgramUniform2fv(table, save_ProgramUniform2fv);
   SET_ProgramUniform3fv(table, save_ProgramUniform3fv);
   SET_ProgramUniform4fv(table, save_ProgramUniform4fv);
   SET_ProgramUniform1i(table, save_ProgramUniform1i);
   SET_ProgramUniform2i(table, save_ProgramUniform2i);
   SET_ProgramUniform3i(table, save_ProgramUniform3i);
   SET_ProgramUniform4i(table, save_ProgramUniform4i);
   SET_ProgramUniform1iv(table, save_ProgramUniform1iv);
   SET_ProgramUniform2iv(table, save_ProgramUniform2iv);
   SET_ProgramUniform3iv(table, save_ProgramUniform3iv);
   SET_ProgramUniform4iv(table, save_ProgramUniform4iv);
   SET_ProgramUniform1ui(table, save_ProgramUniform1ui);
   SET_ProgramUniform2ui(table, save_ProgramUniform2ui);
   SET_ProgramUniform3ui(table, save_ProgramUniform3ui);
   SET_ProgramUniform4ui(table, save_ProgramUniform4ui);
   SET_ProgramUniform1uiv(table, save_ProgramUniform1uiv);
   SET_ProgramUniform2uiv(table, save_ProgramUniform2uiv);
   SET_ProgramUniform3uiv(table, save_ProgramUniform3uiv);
   SET_ProgramUniform4uiv(table, save_ProgramUniform4uiv);
   SET_ProgramUniformMatrix2fv(table, save_ProgramUniformMatrix2fv);
   SET_ProgramUniformMatrix3fv(table, save_ProgramUniformMatrix3fv);
   SET_ProgramUniformMatrix4fv(table, save_ProgramUniformMatrix4fv);
   SET_ProgramUniformMatrix2x3fv(table, save_ProgramUniformMatrix2x3fv);
   SET_ProgramUniformMatrix3x2fv(table, save_ProgramUniformMatrix3x2fv);
   SET_ProgramUniformMatrix2x4fv(table, save_ProgramUniformMatrix2x4fv);
   SET_ProgramUniformMatrix4x2fv(table, save_ProgramUniformMatrix4x2fv);
   SET_ProgramUniformMatrix3x4fv(table, save_ProgramUniformMatrix3x4fv);
   SET_ProgramUniformMatrix4x3fv(table, save_ProgramUniformMatrix4x3fv);
}



static const char *
enum_string(GLenum k)
{
   return _mesa_lookup_enum_by_nr(k);
}


/**
 * Print the commands in a display list.  For debugging only.
 * TODO: many commands aren't handled yet.
 */
static void GLAPIENTRY
print_list(struct gl_context *ctx, GLuint list)
{
   struct gl_display_list *dlist;
   Node *n;
   GLboolean done;

   if (!islist(ctx, list)) {
      printf("%u is not a display list ID\n", list);
      return;
   }

   dlist = _mesa_lookup_list(ctx, list);
   if (!dlist)
      return;

   n = dlist->Head;

   printf("START-LIST %u, address %p\n", list, (void *) n);

   done = n ? GL_FALSE : GL_TRUE;
   while (!done) {
      const OpCode opcode = n[0].opcode;

      if (is_ext_opcode(opcode)) {
         n += ext_opcode_print(ctx, n);
      }
      else {
         switch (opcode) {
         case OPCODE_ACCUM:
            printf("Accum %s %g\n", enum_string(n[1].e), n[2].f);
            break;
         case OPCODE_BITMAP:
            printf("Bitmap %d %d %g %g %g %g %p\n", n[1].i, n[2].i,
                   n[3].f, n[4].f, n[5].f, n[6].f,
                   get_pointer(&n[7]));
            break;
         case OPCODE_CALL_LIST:
            printf("CallList %d\n", (int) n[1].ui);
            break;
         case OPCODE_CALL_LIST_OFFSET:
            printf("CallList %d + offset %u = %u\n", (int) n[1].ui,
                         ctx->List.ListBase, ctx->List.ListBase + n[1].ui);
            break;
         case OPCODE_DISABLE:
            printf("Disable %s\n", enum_string(n[1].e));
            break;
         case OPCODE_ENABLE:
            printf("Enable %s\n", enum_string(n[1].e));
            break;
         case OPCODE_FRUSTUM:
            printf("Frustum %g %g %g %g %g %g\n",
                         n[1].f, n[2].f, n[3].f, n[4].f, n[5].f, n[6].f);
            break;
         case OPCODE_LINE_STIPPLE:
            printf("LineStipple %d %x\n", n[1].i, (int) n[2].us);
            break;
         case OPCODE_LOAD_IDENTITY:
            printf("LoadIdentity\n");
            break;
         case OPCODE_LOAD_MATRIX:
            printf("LoadMatrix\n");
            printf("  %8f %8f %8f %8f\n",
                         n[1].f, n[5].f, n[9].f, n[13].f);
            printf("  %8f %8f %8f %8f\n",
                         n[2].f, n[6].f, n[10].f, n[14].f);
            printf("  %8f %8f %8f %8f\n",
                         n[3].f, n[7].f, n[11].f, n[15].f);
            printf("  %8f %8f %8f %8f\n",
                         n[4].f, n[8].f, n[12].f, n[16].f);
            break;
         case OPCODE_MULT_MATRIX:
            printf("MultMatrix (or Rotate)\n");
            printf("  %8f %8f %8f %8f\n",
                         n[1].f, n[5].f, n[9].f, n[13].f);
            printf("  %8f %8f %8f %8f\n",
                         n[2].f, n[6].f, n[10].f, n[14].f);
            printf("  %8f %8f %8f %8f\n",
                         n[3].f, n[7].f, n[11].f, n[15].f);
            printf("  %8f %8f %8f %8f\n",
                         n[4].f, n[8].f, n[12].f, n[16].f);
            break;
         case OPCODE_ORTHO:
            printf("Ortho %g %g %g %g %g %g\n",
                         n[1].f, n[2].f, n[3].f, n[4].f, n[5].f, n[6].f);
            break;
         case OPCODE_POP_ATTRIB:
            printf("PopAttrib\n");
            break;
         case OPCODE_POP_MATRIX:
            printf("PopMatrix\n");
            break;
         case OPCODE_POP_NAME:
            printf("PopName\n");
            break;
         case OPCODE_PUSH_ATTRIB:
            printf("PushAttrib %x\n", n[1].bf);
            break;
         case OPCODE_PUSH_MATRIX:
            printf("PushMatrix\n");
            break;
         case OPCODE_PUSH_NAME:
            printf("PushName %d\n", (int) n[1].ui);
            break;
         case OPCODE_RASTER_POS:
            printf("RasterPos %g %g %g %g\n",
                         n[1].f, n[2].f, n[3].f, n[4].f);
            break;
         case OPCODE_ROTATE:
            printf("Rotate %g %g %g %g\n",
                         n[1].f, n[2].f, n[3].f, n[4].f);
            break;
         case OPCODE_SCALE:
            printf("Scale %g %g %g\n", n[1].f, n[2].f, n[3].f);
            break;
         case OPCODE_TRANSLATE:
            printf("Translate %g %g %g\n", n[1].f, n[2].f, n[3].f);
            break;
         case OPCODE_BIND_TEXTURE:
            printf("BindTexture %s %d\n",
                         _mesa_lookup_enum_by_nr(n[1].ui), n[2].ui);
            break;
         case OPCODE_SHADE_MODEL:
            printf("ShadeModel %s\n", _mesa_lookup_enum_by_nr(n[1].ui));
            break;
         case OPCODE_MAP1:
            printf("Map1 %s %.3f %.3f %d %d\n",
                         _mesa_lookup_enum_by_nr(n[1].ui),
                         n[2].f, n[3].f, n[4].i, n[5].i);
            break;
         case OPCODE_MAP2:
            printf("Map2 %s %.3f %.3f %.3f %.3f %d %d %d %d\n",
                         _mesa_lookup_enum_by_nr(n[1].ui),
                         n[2].f, n[3].f, n[4].f, n[5].f,
                         n[6].i, n[7].i, n[8].i, n[9].i);
            break;
         case OPCODE_MAPGRID1:
            printf("MapGrid1 %d %.3f %.3f\n", n[1].i, n[2].f, n[3].f);
            break;
         case OPCODE_MAPGRID2:
            printf("MapGrid2 %d %.3f %.3f, %d %.3f %.3f\n",
                         n[1].i, n[2].f, n[3].f, n[4].i, n[5].f, n[6].f);
            break;
         case OPCODE_EVALMESH1:
            printf("EvalMesh1 %d %d\n", n[1].i, n[2].i);
            break;
         case OPCODE_EVALMESH2:
            printf("EvalMesh2 %d %d %d %d\n",
                         n[1].i, n[2].i, n[3].i, n[4].i);
            break;

         case OPCODE_ATTR_1F_NV:
            printf("ATTR_1F_NV attr %d: %f\n", n[1].i, n[2].f);
            break;
         case OPCODE_ATTR_2F_NV:
            printf("ATTR_2F_NV attr %d: %f %f\n",
                         n[1].i, n[2].f, n[3].f);
            break;
         case OPCODE_ATTR_3F_NV:
            printf("ATTR_3F_NV attr %d: %f %f %f\n",
                         n[1].i, n[2].f, n[3].f, n[4].f);
            break;
         case OPCODE_ATTR_4F_NV:
            printf("ATTR_4F_NV attr %d: %f %f %f %f\n",
                         n[1].i, n[2].f, n[3].f, n[4].f, n[5].f);
            break;
         case OPCODE_ATTR_1F_ARB:
            printf("ATTR_1F_ARB attr %d: %f\n", n[1].i, n[2].f);
            break;
         case OPCODE_ATTR_2F_ARB:
            printf("ATTR_2F_ARB attr %d: %f %f\n",
                         n[1].i, n[2].f, n[3].f);
            break;
         case OPCODE_ATTR_3F_ARB:
            printf("ATTR_3F_ARB attr %d: %f %f %f\n",
                         n[1].i, n[2].f, n[3].f, n[4].f);
            break;
         case OPCODE_ATTR_4F_ARB:
            printf("ATTR_4F_ARB attr %d: %f %f %f %f\n",
                         n[1].i, n[2].f, n[3].f, n[4].f, n[5].f);
            break;

         case OPCODE_MATERIAL:
            printf("MATERIAL %x %x: %f %f %f %f\n",
                         n[1].i, n[2].i, n[3].f, n[4].f, n[5].f, n[6].f);
            break;
         case OPCODE_BEGIN:
            printf("BEGIN %x\n", n[1].i);
            break;
         case OPCODE_END:
            printf("END\n");
            break;
         case OPCODE_RECTF:
            printf("RECTF %f %f %f %f\n", n[1].f, n[2].f, n[3].f,
                         n[4].f);
            break;
         case OPCODE_EVAL_C1:
            printf("EVAL_C1 %f\n", n[1].f);
            break;
         case OPCODE_EVAL_C2:
            printf("EVAL_C2 %f %f\n", n[1].f, n[2].f);
            break;
         case OPCODE_EVAL_P1:
            printf("EVAL_P1 %d\n", n[1].i);
            break;
         case OPCODE_EVAL_P2:
            printf("EVAL_P2 %d %d\n", n[1].i, n[2].i);
            break;

         case OPCODE_PROVOKING_VERTEX:
            printf("ProvokingVertex %s\n",
                         _mesa_lookup_enum_by_nr(n[1].ui));
            break;

            /*
             * meta opcodes/commands
             */
         case OPCODE_ERROR:
            printf("Error: %s %s\n", enum_string(n[1].e),
                   (const char *) get_pointer(&n[2]));
            break;
         case OPCODE_CONTINUE:
            printf("DISPLAY-LIST-CONTINUE\n");
            n = (Node *) get_pointer(&n[1]);
            break;
         case OPCODE_NOP:
            printf("NOP\n");
            break;
         case OPCODE_END_OF_LIST:
            printf("END-LIST %u\n", list);
            done = GL_TRUE;
            break;
         default:
            if (opcode < 0 || opcode > OPCODE_END_OF_LIST) {
               printf
                  ("ERROR IN DISPLAY LIST: opcode = %d, address = %p\n",
                   opcode, (void *) n);
               return;
            }
            else {
               printf("command %d, %u operands\n", opcode,
                            InstSize[opcode]);
            }
         }
         /* increment n to point to next compiled command */
         if (opcode != OPCODE_CONTINUE) {
            n += InstSize[opcode];
         }
      }
   }
}



/**
 * Clients may call this function to help debug display list problems.
 * This function is _ONLY_FOR_DEBUGGING_PURPOSES_.  It may be removed,
 * changed, or break in the future without notice.
 */
void
mesa_print_display_list(GLuint list)
{
   GET_CURRENT_CONTEXT(ctx);
   print_list(ctx, list);
}


/**********************************************************************/
/*****                      Initialization                        *****/
/**********************************************************************/

static void
save_vtxfmt_init(GLvertexformat * vfmt)
{
   vfmt->ArrayElement = _ae_ArrayElement;

   vfmt->Begin = save_Begin;

   vfmt->CallList = save_CallList;
   vfmt->CallLists = save_CallLists;

   vfmt->Color3f = save_Color3f;
   vfmt->Color3fv = save_Color3fv;
   vfmt->Color4f = save_Color4f;
   vfmt->Color4fv = save_Color4fv;
   vfmt->EdgeFlag = save_EdgeFlag;
   vfmt->End = save_End;

   vfmt->EvalCoord1f = save_EvalCoord1f;
   vfmt->EvalCoord1fv = save_EvalCoord1fv;
   vfmt->EvalCoord2f = save_EvalCoord2f;
   vfmt->EvalCoord2fv = save_EvalCoord2fv;
   vfmt->EvalPoint1 = save_EvalPoint1;
   vfmt->EvalPoint2 = save_EvalPoint2;

   vfmt->FogCoordfEXT = save_FogCoordfEXT;
   vfmt->FogCoordfvEXT = save_FogCoordfvEXT;
   vfmt->Indexf = save_Indexf;
   vfmt->Indexfv = save_Indexfv;
   vfmt->Materialfv = save_Materialfv;
   vfmt->MultiTexCoord1fARB = save_MultiTexCoord1f;
   vfmt->MultiTexCoord1fvARB = save_MultiTexCoord1fv;
   vfmt->MultiTexCoord2fARB = save_MultiTexCoord2f;
   vfmt->MultiTexCoord2fvARB = save_MultiTexCoord2fv;
   vfmt->MultiTexCoord3fARB = save_MultiTexCoord3f;
   vfmt->MultiTexCoord3fvARB = save_MultiTexCoord3fv;
   vfmt->MultiTexCoord4fARB = save_MultiTexCoord4f;
   vfmt->MultiTexCoord4fvARB = save_MultiTexCoord4fv;
   vfmt->Normal3f = save_Normal3f;
   vfmt->Normal3fv = save_Normal3fv;
   vfmt->SecondaryColor3fEXT = save_SecondaryColor3fEXT;
   vfmt->SecondaryColor3fvEXT = save_SecondaryColor3fvEXT;
   vfmt->TexCoord1f = save_TexCoord1f;
   vfmt->TexCoord1fv = save_TexCoord1fv;
   vfmt->TexCoord2f = save_TexCoord2f;
   vfmt->TexCoord2fv = save_TexCoord2fv;
   vfmt->TexCoord3f = save_TexCoord3f;
   vfmt->TexCoord3fv = save_TexCoord3fv;
   vfmt->TexCoord4f = save_TexCoord4f;
   vfmt->TexCoord4fv = save_TexCoord4fv;
   vfmt->Vertex2f = save_Vertex2f;
   vfmt->Vertex2fv = save_Vertex2fv;
   vfmt->Vertex3f = save_Vertex3f;
   vfmt->Vertex3fv = save_Vertex3fv;
   vfmt->Vertex4f = save_Vertex4f;
   vfmt->Vertex4fv = save_Vertex4fv;
   vfmt->VertexAttrib1fARB = save_VertexAttrib1fARB;
   vfmt->VertexAttrib1fvARB = save_VertexAttrib1fvARB;
   vfmt->VertexAttrib2fARB = save_VertexAttrib2fARB;
   vfmt->VertexAttrib2fvARB = save_VertexAttrib2fvARB;
   vfmt->VertexAttrib3fARB = save_VertexAttrib3fARB;
   vfmt->VertexAttrib3fvARB = save_VertexAttrib3fvARB;
   vfmt->VertexAttrib4fARB = save_VertexAttrib4fARB;
   vfmt->VertexAttrib4fvARB = save_VertexAttrib4fvARB;
}


void
_mesa_install_dlist_vtxfmt(struct _glapi_table *disp,
                           const GLvertexformat *vfmt)
{
   SET_CallList(disp, vfmt->CallList);
   SET_CallLists(disp, vfmt->CallLists);
}


/**
 * Initialize display list state for given context.
 */
void
_mesa_init_display_list(struct gl_context *ctx)
{
   static GLboolean tableInitialized = GL_FALSE;

   /* zero-out the instruction size table, just once */
   if (!tableInitialized) {
      memset(InstSize, 0, sizeof(InstSize));
      tableInitialized = GL_TRUE;
   }

   /* extension info */
   ctx->ListExt = CALLOC_STRUCT(gl_list_extensions);

   /* Display list */
   ctx->ListState.CallDepth = 0;
   ctx->ExecuteFlag = GL_TRUE;
   ctx->CompileFlag = GL_FALSE;
   ctx->ListState.CurrentBlock = NULL;
   ctx->ListState.CurrentPos = 0;

   /* Display List group */
   ctx->List.ListBase = 0;

   save_vtxfmt_init(&ctx->ListState.ListVtxfmt);

   InstSize[OPCODE_NOP] = 1;
}


void
_mesa_free_display_list_data(struct gl_context *ctx)
{
   free(ctx->ListExt);
   ctx->ListExt = NULL;
}
@


1.12
log
@Merge Mesa 10.2.9
@
text
@@


1.11
log
@Remove the local workaround for alignment faults in the VBO code on
archs with strict 64 bit pointer alignment and use Brian Paul's fix
which has been committed upstream and should end up in future releases
of 10.4.x.
@
text
@d320 2
a402 3
   /* GL_ARB_clip_control */
   OPCODE_CLIP_CONTROL,

d5033 30
a7295 16
save_ClipControl(GLenum origin, GLenum depth)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_CLIP_CONTROL, 2);
   if (n) {
      n[1].e = origin;
      n[2].e = depth;
   }
   if (ctx->ExecuteFlag) {
      CALL_ClipControl(ctx->Exec, (origin, depth));
   }
}

static void GLAPIENTRY
a8704 4
         case OPCODE_CLIP_CONTROL:
            CALL_ClipControl(ctx->Exec, (n[1].e, n[2].e));
            break;

d8709 10
d9547 4
a9654 3

   /* GL_ARB_clip_control */
   SET_ClipControl(table, save_ClipControl);
@


1.10
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d490 1
a524 3
#if defined(__LP64__) && !defined(__x86_64__)
   void *pad;
#endif
a554 1
#if 0
d556 1
a556 1
#endif
d1022 3
a1024 1
 * \return pointer to allocated memory (the opcode space)
d1027 1
a1027 1
dlist_alloc(struct gl_context *ctx, OpCode opcode, GLuint bytes)
d1031 1
d1045 14
a1058 1
   if (ctx->ListState.CurrentPos + numNodes + contNodes > BLOCK_SIZE) {
d1068 4
d1075 9
d1087 9
a1095 1
   ctx->ListState.CurrentPos += numNodes;
d1116 16
a1131 1
   Node *n = dlist_alloc(ctx, (OpCode) opcode, bytes);
d1181 1
a1181 1
   return dlist_alloc(ctx, opcode, nparams * sizeof(Node));
d8959 3
d10001 3
d10150 2
@


1.9
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@a319 2
   OPCODE_TEX_BUMP_PARAMETER_ATI,
   /* GL_ATI_fragment_shader */
d401 3
d524 3
d557 1
d559 1
a559 1

a4984 30
save_TexBumpParameterfvATI(GLenum pname, const GLfloat *param)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;

   n = alloc_instruction(ctx, OPCODE_TEX_BUMP_PARAMETER_ATI, 5);
   if (n) {
      n[1].ui = pname;
      n[2].f = param[0];
      n[3].f = param[1];
      n[4].f = param[2];
      n[5].f = param[3];
   }
   if (ctx->ExecuteFlag) {
      CALL_TexBumpParameterfvATI(ctx->Exec, (pname, param));
   }
}

static void GLAPIENTRY
save_TexBumpParameterivATI(GLenum pname, const GLint *param)
{
   GLfloat p[4];
   p[0] = INT_TO_FLOAT(param[0]);
   p[1] = INT_TO_FLOAT(param[1]);
   p[2] = INT_TO_FLOAT(param[2]);
   p[3] = INT_TO_FLOAT(param[3]);
   save_TexBumpParameterfvATI(pname, p);
}

static void GLAPIENTRY
d7218 16
d8643 4
a8650 10
         case OPCODE_TEX_BUMP_PARAMETER_ATI:
            {
               GLfloat values[4];
               GLuint i, pname = n[1].ui;

               for (i = 0; i < 4; i++)
                  values[i] = n[1 + i].f;
               CALL_TexBumpParameterfvATI(ctx->Exec, (pname, values));
            }
            break;
a9475 4
   /* 244. GL_ATI_envmap_bumpmap */
   SET_TexBumpParameterivATI(table, save_TexBumpParameterivATI);
   SET_TexBumpParameterfvATI(table, save_TexBumpParameterfvATI);

d9580 3
@


1.8
log
@Merge Mesa 9.2.0
@
text
@a211 12
   OPCODE_COLOR_TABLE,
   OPCODE_COLOR_TABLE_PARAMETER_FV,
   OPCODE_COLOR_TABLE_PARAMETER_IV,
   OPCODE_COLOR_SUB_TABLE,
   OPCODE_CONVOLUTION_FILTER_1D,
   OPCODE_CONVOLUTION_FILTER_2D,
   OPCODE_CONVOLUTION_PARAMETER_I,
   OPCODE_CONVOLUTION_PARAMETER_IV,
   OPCODE_CONVOLUTION_PARAMETER_F,
   OPCODE_CONVOLUTION_PARAMETER_FV,
   OPCODE_COPY_COLOR_SUB_TABLE,
   OPCODE_COPY_COLOR_TABLE,
a233 1
   OPCODE_HISTOGRAM,
a249 1
   OPCODE_MIN_MAX,
a269 2
   OPCODE_RESET_HISTOGRAM,
   OPCODE_RESET_MIN_MAX,
d367 36
a445 4
   /* GL_EXT_separate_shader_objects */
   OPCODE_ACTIVE_PROGRAM_EXT,
   OPCODE_USE_SHADER_PROGRAM_EXT,

d505 4
a522 2
   GLvoid *data;
   void *next;                  /* If prev node's opcode==OPCODE_CONTINUE */
d529 49
d590 3
a592 3
 * How many nodes to allocate at a time.
 *
 * \note Reduced now that we hold vertices etc. elsewhere.
a607 5
/**********************************************************************/
/*****                           Private                          *****/
/**********************************************************************/


d609 2
a610 2
 * Make an empty display list.  This is used by glGenLists() to
 * reserve display list IDs.
d626 2
a627 2
static inline struct gl_display_list *
lookup_list(struct gl_context *ctx, GLuint list)
d702 1
a702 1
            free(n[6].data);
d706 1
a706 1
            free(n[10].data);
d710 1
a710 1
            free(n[5].data);
d714 1
a714 17
            free(n[7].data);
            n += InstSize[n[0].opcode];
            break;
         case OPCODE_COLOR_TABLE:
            free(n[6].data);
            n += InstSize[n[0].opcode];
            break;
         case OPCODE_COLOR_SUB_TABLE:
            free(n[6].data);
            n += InstSize[n[0].opcode];
            break;
         case OPCODE_CONVOLUTION_FILTER_1D:
            free(n[6].data);
            n += InstSize[n[0].opcode];
            break;
         case OPCODE_CONVOLUTION_FILTER_2D:
            free(n[7].data);
d718 1
a718 1
            free(n[1].data);
d722 1
a722 1
            free(n[8].data);
d726 1
a726 1
            free(n[9].data);
d730 1
a730 1
            free(n[10].data);
d734 1
a734 1
            free(n[7].data);
d738 1
a738 1
            free(n[9].data);
d742 1
a742 1
            free(n[11].data);
d746 1
a746 1
            free(n[7].data);
d750 1
a750 1
            free(n[8].data);
d754 1
a754 1
            free(n[9].data);
d758 1
a758 1
            free(n[7].data);
d762 1
a762 1
            free(n[9].data);
d766 1
a766 1
            free(n[11].data);
d770 1
a770 1
            free(n[4].data);      /* program string */
d785 1
a785 1
            free(n[3].data);
d797 32
a828 1
            free(n[4].data);
d833 1
a833 1
            n = (Node *) n[1].next;
d849 1
d866 1
a866 1
   dlist = lookup_list(ctx, list);
a931 6


/**********************************************************************/
/*****                        Public                              *****/
/**********************************************************************/

d976 2
a977 1
				    GL_MAP_READ_BIT, unpack->BufferObj);
d991 1
a991 1
      ctx->Driver.UnmapBuffer(ctx, unpack->BufferObj);
d1004 12
d1026 1
d1040 1
a1040 1
   if (ctx->ListState.CurrentPos + numNodes + 2 > BLOCK_SIZE) {
d1050 1
a1050 1
      n[1].next = (Node *) newblock;
d1131 31
d1225 1
a1225 1
   n = alloc_instruction(ctx, OPCODE_BITMAP, 7);
d1233 3
a1235 2
      n[7].data = unpack_image(ctx, 2, width, height, 1, GL_COLOR_INDEX,
                               GL_BITMAP, pixels, &ctx->Unpack);
d1855 1
a1855 3
save_ColorTable(GLenum target, GLenum internalFormat,
                GLsizei width, GLenum format, GLenum type,
                const GLvoid * table)
d1858 9
a1866 4
   if (_mesa_is_proxy_texture(target)) {
      /* execute immediately */
      CALL_ColorTable(ctx->Exec, (target, internalFormat, width,
                                  format, type, table));
d1868 2
a1869 17
   else {
      Node *n;
      ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
      n = alloc_instruction(ctx, OPCODE_COLOR_TABLE, 6);
      if (n) {
         n[1].e = target;
         n[2].e = internalFormat;
         n[3].i = width;
         n[4].e = format;
         n[5].e = type;
         n[6].data = unpack_image(ctx, 1, width, 1, 1, format, type, table,
                                  &ctx->Unpack);
      }
      if (ctx->ExecuteFlag) {
         CALL_ColorTable(ctx->Exec, (target, internalFormat, width,
                                     format, type, table));
      }
d1876 2
a1877 2
save_ColorTableParameterfv(GLenum target, GLenum pname,
                           const GLfloat *params)
a1880 1

d1882 1
a1882 2

   n = alloc_instruction(ctx, OPCODE_COLOR_TABLE_PARAMETER_FV, 6);
d1885 6
a1890 9
      n[2].e = pname;
      n[3].f = params[0];
      if (pname == GL_COLOR_TABLE_SGI ||
          pname == GL_POST_CONVOLUTION_COLOR_TABLE_SGI ||
          pname == GL_TEXTURE_COLOR_TABLE_SGI) {
         n[4].f = params[1];
         n[5].f = params[2];
         n[6].f = params[3];
      }
a1891 1

d1893 2
a1894 1
      CALL_ColorTableParameterfv(ctx->Exec, (target, pname, params));
d1900 4
a1903 1
save_ColorTableParameteriv(GLenum target, GLenum pname, const GLint *params)
a1906 1

d1908 1
a1908 2

   n = alloc_instruction(ctx, OPCODE_COLOR_TABLE_PARAMETER_IV, 6);
d1911 7
a1917 9
      n[2].e = pname;
      n[3].i = params[0];
      if (pname == GL_COLOR_TABLE_SGI ||
          pname == GL_POST_CONVOLUTION_COLOR_TABLE_SGI ||
          pname == GL_TEXTURE_COLOR_TABLE_SGI) {
         n[4].i = params[1];
         n[5].i = params[2];
         n[6].i = params[3];
      }
a1918 1

d1920 2
a1921 1
      CALL_ColorTableParameteriv(ctx->Exec, (target, pname, params));
d1928 2
a1929 2
save_ColorSubTable(GLenum target, GLsizei start, GLsizei count,
                   GLenum format, GLenum type, const GLvoid * table)
d1934 1
a1934 1
   n = alloc_instruction(ctx, OPCODE_COLOR_SUB_TABLE, 6);
d1937 5
a1941 6
      n[2].i = start;
      n[3].i = count;
      n[4].e = format;
      n[5].e = type;
      n[6].data = unpack_image(ctx, 1, count, 1, 1, format, type, table,
                               &ctx->Unpack);
d1944 2
a1945 2
      CALL_ColorSubTable(ctx->Exec,
                         (target, start, count, format, type, table));
d1951 3
a1953 2
save_CopyColorSubTable(GLenum target, GLsizei start,
                       GLint x, GLint y, GLsizei width)
a1956 1

d1958 1
a1958 1
   n = alloc_instruction(ctx, OPCODE_COPY_COLOR_SUB_TABLE, 5);
d1961 7
a1967 4
      n[2].i = start;
      n[3].i = x;
      n[4].i = y;
      n[5].i = width;
d1970 2
a1971 1
      CALL_CopyColorSubTable(ctx->Exec, (target, start, x, y, width));
d1977 3
a1979 2
save_CopyColorTable(GLenum target, GLenum internalformat,
                    GLint x, GLint y, GLsizei width)
a1982 1

d1984 1
a1984 1
   n = alloc_instruction(ctx, OPCODE_COPY_COLOR_TABLE, 5);
d1987 8
a1994 4
      n[2].e = internalformat;
      n[3].i = x;
      n[4].i = y;
      n[5].i = width;
d1997 3
a1999 1
      CALL_CopyColorTable(ctx->Exec, (target, internalformat, x, y, width));
d2005 1
a2005 2
save_ConvolutionFilter1D(GLenum target, GLenum internalFormat, GLsizei width,
                         GLenum format, GLenum type, const GLvoid * filter)
a2008 1

d2010 1
a2010 2

   n = alloc_instruction(ctx, OPCODE_CONVOLUTION_FILTER_1D, 6);
d2012 1
a2012 7
      n[1].e = target;
      n[2].e = internalFormat;
      n[3].i = width;
      n[4].e = format;
      n[5].e = type;
      n[6].data = unpack_image(ctx, 1, width, 1, 1, format, type, filter,
                               &ctx->Unpack);
d2015 1
a2015 2
      CALL_ConvolutionFilter1D(ctx->Exec, (target, internalFormat, width,
                                           format, type, filter));
d2021 1
a2021 3
save_ConvolutionFilter2D(GLenum target, GLenum internalFormat,
                         GLsizei width, GLsizei height, GLenum format,
                         GLenum type, const GLvoid * filter)
a2024 1

d2026 1
a2026 2

   n = alloc_instruction(ctx, OPCODE_CONVOLUTION_FILTER_2D, 7);
d2028 1
a2028 8
      n[1].e = target;
      n[2].e = internalFormat;
      n[3].i = width;
      n[4].i = height;
      n[5].e = format;
      n[6].e = type;
      n[7].data = unpack_image(ctx, 2, width, height, 1, format, type, filter,
                               &ctx->Unpack);
d2031 1
a2031 3
      CALL_ConvolutionFilter2D(ctx->Exec,
                               (target, internalFormat, width, height, format,
                                type, filter));
d2037 1
a2037 1
save_ConvolutionParameteri(GLenum target, GLenum pname, GLint param)
d2042 1
a2042 1
   n = alloc_instruction(ctx, OPCODE_CONVOLUTION_PARAMETER_I, 3);
d2044 1
a2044 3
      n[1].e = target;
      n[2].e = pname;
      n[3].i = param;
d2047 1
a2047 1
      CALL_ConvolutionParameteri(ctx->Exec, (target, pname, param));
d2053 1
a2053 1
save_ConvolutionParameteriv(GLenum target, GLenum pname, const GLint *params)
d2058 1
a2058 1
   n = alloc_instruction(ctx, OPCODE_CONVOLUTION_PARAMETER_IV, 6);
d2060 2
a2061 13
      n[1].e = target;
      n[2].e = pname;
      n[3].i = params[0];
      if (pname == GL_CONVOLUTION_BORDER_COLOR ||
          pname == GL_CONVOLUTION_FILTER_SCALE ||
          pname == GL_CONVOLUTION_FILTER_BIAS) {
         n[4].i = params[1];
         n[5].i = params[2];
         n[6].i = params[3];
      }
      else {
         n[4].i = n[5].i = n[6].i = 0;
      }
d2064 1
a2064 1
      CALL_ConvolutionParameteriv(ctx->Exec, (target, pname, params));
d2070 1
a2070 1
save_ConvolutionParameterf(GLenum target, GLenum pname, GLfloat param)
d2075 1
a2075 1
   n = alloc_instruction(ctx, OPCODE_CONVOLUTION_PARAMETER_F, 3);
d2077 1
a2077 3
      n[1].e = target;
      n[2].e = pname;
      n[3].f = param;
d2080 1
a2080 1
      CALL_ConvolutionParameterf(ctx->Exec, (target, pname, param));
d2086 1
a2086 2
save_ConvolutionParameterfv(GLenum target, GLenum pname,
                            const GLfloat *params)
d2091 1
a2091 1
   n = alloc_instruction(ctx, OPCODE_CONVOLUTION_PARAMETER_FV, 6);
d2093 2
a2094 13
      n[1].e = target;
      n[2].e = pname;
      n[3].f = params[0];
      if (pname == GL_CONVOLUTION_BORDER_COLOR ||
          pname == GL_CONVOLUTION_FILTER_SCALE ||
          pname == GL_CONVOLUTION_FILTER_BIAS) {
         n[4].f = params[1];
         n[5].f = params[2];
         n[6].f = params[3];
      }
      else {
         n[4].f = n[5].f = n[6].f = 0.0F;
      }
d2097 1
a2097 1
      CALL_ConvolutionParameterfv(ctx->Exec, (target, pname, params));
d2103 1
a2103 1
save_CopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type)
d2108 1
a2108 1
   n = alloc_instruction(ctx, OPCODE_COPY_PIXELS, 5);
d2110 1
a2110 5
      n[1].i = x;
      n[2].i = y;
      n[3].i = (GLint) width;
      n[4].i = (GLint) height;
      n[5].e = type;
d2113 1
a2113 245
      CALL_CopyPixels(ctx->Exec, (x, y, width, height, type));
   }
}



static void GLAPIENTRY
save_CopyTexImage1D(GLenum target, GLint level, GLenum internalformat,
                    GLint x, GLint y, GLsizei width, GLint border)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_COPY_TEX_IMAGE1D, 7);
   if (n) {
      n[1].e = target;
      n[2].i = level;
      n[3].e = internalformat;
      n[4].i = x;
      n[5].i = y;
      n[6].i = width;
      n[7].i = border;
   }
   if (ctx->ExecuteFlag) {
      CALL_CopyTexImage1D(ctx->Exec, (target, level, internalformat,
                                      x, y, width, border));
   }
}


static void GLAPIENTRY
save_CopyTexImage2D(GLenum target, GLint level,
                    GLenum internalformat,
                    GLint x, GLint y, GLsizei width,
                    GLsizei height, GLint border)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_COPY_TEX_IMAGE2D, 8);
   if (n) {
      n[1].e = target;
      n[2].i = level;
      n[3].e = internalformat;
      n[4].i = x;
      n[5].i = y;
      n[6].i = width;
      n[7].i = height;
      n[8].i = border;
   }
   if (ctx->ExecuteFlag) {
      CALL_CopyTexImage2D(ctx->Exec, (target, level, internalformat,
                                      x, y, width, height, border));
   }
}



static void GLAPIENTRY
save_CopyTexSubImage1D(GLenum target, GLint level,
                       GLint xoffset, GLint x, GLint y, GLsizei width)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_COPY_TEX_SUB_IMAGE1D, 6);
   if (n) {
      n[1].e = target;
      n[2].i = level;
      n[3].i = xoffset;
      n[4].i = x;
      n[5].i = y;
      n[6].i = width;
   }
   if (ctx->ExecuteFlag) {
      CALL_CopyTexSubImage1D(ctx->Exec,
                             (target, level, xoffset, x, y, width));
   }
}


static void GLAPIENTRY
save_CopyTexSubImage2D(GLenum target, GLint level,
                       GLint xoffset, GLint yoffset,
                       GLint x, GLint y, GLsizei width, GLint height)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_COPY_TEX_SUB_IMAGE2D, 8);
   if (n) {
      n[1].e = target;
      n[2].i = level;
      n[3].i = xoffset;
      n[4].i = yoffset;
      n[5].i = x;
      n[6].i = y;
      n[7].i = width;
      n[8].i = height;
   }
   if (ctx->ExecuteFlag) {
      CALL_CopyTexSubImage2D(ctx->Exec, (target, level, xoffset, yoffset,
                                         x, y, width, height));
   }
}


static void GLAPIENTRY
save_CopyTexSubImage3D(GLenum target, GLint level,
                       GLint xoffset, GLint yoffset, GLint zoffset,
                       GLint x, GLint y, GLsizei width, GLint height)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_COPY_TEX_SUB_IMAGE3D, 9);
   if (n) {
      n[1].e = target;
      n[2].i = level;
      n[3].i = xoffset;
      n[4].i = yoffset;
      n[5].i = zoffset;
      n[6].i = x;
      n[7].i = y;
      n[8].i = width;
      n[9].i = height;
   }
   if (ctx->ExecuteFlag) {
      CALL_CopyTexSubImage3D(ctx->Exec, (target, level,
                                         xoffset, yoffset, zoffset,
                                         x, y, width, height));
   }
}


static void GLAPIENTRY
save_CullFace(GLenum mode)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_CULL_FACE, 1);
   if (n) {
      n[1].e = mode;
   }
   if (ctx->ExecuteFlag) {
      CALL_CullFace(ctx->Exec, (mode));
   }
}


static void GLAPIENTRY
save_DepthFunc(GLenum func)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_DEPTH_FUNC, 1);
   if (n) {
      n[1].e = func;
   }
   if (ctx->ExecuteFlag) {
      CALL_DepthFunc(ctx->Exec, (func));
   }
}


static void GLAPIENTRY
save_DepthMask(GLboolean mask)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_DEPTH_MASK, 1);
   if (n) {
      n[1].b = mask;
   }
   if (ctx->ExecuteFlag) {
      CALL_DepthMask(ctx->Exec, (mask));
   }
}


static void GLAPIENTRY
save_DepthRange(GLclampd nearval, GLclampd farval)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_DEPTH_RANGE, 2);
   if (n) {
      n[1].f = (GLfloat) nearval;
      n[2].f = (GLfloat) farval;
   }
   if (ctx->ExecuteFlag) {
      CALL_DepthRange(ctx->Exec, (nearval, farval));
   }
}


static void GLAPIENTRY
save_Disable(GLenum cap)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_DISABLE, 1);
   if (n) {
      n[1].e = cap;
   }
   if (ctx->ExecuteFlag) {
      CALL_Disable(ctx->Exec, (cap));
   }
}


static void GLAPIENTRY
save_DisableIndexed(GLuint index, GLenum cap)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_DISABLE_INDEXED, 2);
   if (n) {
      n[1].ui = index;
      n[2].e = cap;
   }
   if (ctx->ExecuteFlag) {
      CALL_Disablei(ctx->Exec, (index, cap));
   }
}


static void GLAPIENTRY
save_DrawBuffer(GLenum mode)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_DRAW_BUFFER, 1);
   if (n) {
      n[1].e = mode;
   }
   if (ctx->ExecuteFlag) {
      CALL_DrawBuffer(ctx->Exec, (mode));
d2127 1
a2127 1
   n = alloc_instruction(ctx, OPCODE_DRAW_PIXELS, 5);
d2133 3
a2135 2
      n[5].data = unpack_image(ctx, 2, width, height, 1, format, type,
                               pixels, &ctx->Unpack);
d2344 1
a2344 2
save_Histogram(GLenum target, GLsizei width, GLenum internalFormat,
               GLboolean sink)
a2347 1

d2349 1
a2349 1
   n = alloc_instruction(ctx, OPCODE_HISTOGRAM, 4);
d2351 1
a2351 4
      n[1].e = target;
      n[2].i = width;
      n[3].e = internalFormat;
      n[4].b = sink;
d2354 1
a2354 1
      CALL_Histogram(ctx->Exec, (target, width, internalFormat, sink));
d2360 1
a2360 1
save_IndexMask(GLuint mask)
a2362 1
   Node *n;
d2364 2
a2365 17
   n = alloc_instruction(ctx, OPCODE_INDEX_MASK, 1);
   if (n) {
      n[1].ui = mask;
   }
   if (ctx->ExecuteFlag) {
      CALL_IndexMask(ctx->Exec, (mask));
   }
}


static void GLAPIENTRY
save_InitNames(void)
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   (void) alloc_instruction(ctx, OPCODE_INIT_NAMES, 0);
   if (ctx->ExecuteFlag) {
d2683 1
a2683 1
   n = alloc_instruction(ctx, OPCODE_MAP1, 6);
d2691 1
a2691 1
      n[6].data = (void *) pnts;
d2705 1
a2705 1
   n = alloc_instruction(ctx, OPCODE_MAP1, 6);
d2713 1
a2713 1
      n[6].data = (void *) pnts;
d2730 1
a2730 1
   n = alloc_instruction(ctx, OPCODE_MAP2, 10);
d2744 1
a2744 1
      n[10].data = (void *) pnts;
d2763 1
a2763 1
   n = alloc_instruction(ctx, OPCODE_MAP2, 10);
d2777 1
a2777 1
      n[10].data = (void *) pnts;
a2859 19
save_Minmax(GLenum target, GLenum internalFormat, GLboolean sink)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;

   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_MIN_MAX, 3);
   if (n) {
      n[1].e = target;
      n[2].e = internalFormat;
      n[3].b = sink;
   }
   if (ctx->ExecuteFlag) {
      CALL_Minmax(ctx->Exec, (target, internalFormat, sink));
   }
}


static void GLAPIENTRY
d2930 1
a2930 1
   n = alloc_instruction(ctx, OPCODE_PIXEL_MAP, 3);
d2934 1
a2934 2
      n[3].data = malloc(mapsize * sizeof(GLfloat));
      memcpy(n[3].data, (void *) values, mapsize * sizeof(GLfloat));
d3109 1
a3109 1
   n = alloc_instruction(ctx, OPCODE_POLYGON_STIPPLE, 1);
d3111 3
a3113 2
      n[1].data = unpack_image(ctx, 2, 32, 32, 1, GL_COLOR_INDEX, GL_BITMAP,
                               pattern, &ctx->Unpack);
a3440 32
save_ResetHistogram(GLenum target)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_RESET_HISTOGRAM, 1);
   if (n) {
      n[1].e = target;
   }
   if (ctx->ExecuteFlag) {
      CALL_ResetHistogram(ctx->Exec, (target));
   }
}


static void GLAPIENTRY
save_ResetMinmax(GLenum target)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_RESET_MIN_MAX, 1);
   if (n) {
      n[1].e = target;
   }
   if (ctx->ExecuteFlag) {
      CALL_ResetMinmax(ctx->Exec, (target));
   }
}


static void GLAPIENTRY
d3882 1
a3882 1
      n = alloc_instruction(ctx, OPCODE_TEX_IMAGE1D, 8);
d3891 3
a3893 2
         n[8].data = unpack_image(ctx, 1, width, 1, 1, format, type,
                                  pixels, &ctx->Unpack);
d3918 1
a3918 1
      n = alloc_instruction(ctx, OPCODE_TEX_IMAGE2D, 9);
d3928 3
a3930 2
         n[9].data = unpack_image(ctx, 2, width, height, 1, format, type,
                                  pixels, &ctx->Unpack);
d3957 1
a3957 1
      n = alloc_instruction(ctx, OPCODE_TEX_IMAGE3D, 10);
d3968 3
a3970 2
         n[10].data = unpack_image(ctx, 3, width, height, depth, format, type,
                                   pixels, &ctx->Unpack);
d3991 1
a3991 1
   n = alloc_instruction(ctx, OPCODE_TEX_SUB_IMAGE1D, 7);
d3999 3
a4001 2
      n[7].data = unpack_image(ctx, 1, width, 1, 1, format, type,
                               pixels, &ctx->Unpack);
d4021 1
a4021 1
   n = alloc_instruction(ctx, OPCODE_TEX_SUB_IMAGE2D, 9);
d4031 3
a4033 2
      n[9].data = unpack_image(ctx, 2, width, height, 1, format, type,
                               pixels, &ctx->Unpack);
d4053 1
a4053 1
   n = alloc_instruction(ctx, OPCODE_TEX_SUB_IMAGE3D, 11);
d4065 3
a4067 2
      n[11].data = unpack_image(ctx, 3, width, height, depth, format, type,
                                pixels, &ctx->Unpack);
d4374 2
a4375 1
      n = alloc_instruction(ctx, OPCODE_COMPRESSED_TEX_IMAGE_1D, 7);
d4383 2
a4384 1
         n[7].data = copy_data(data, imageSize, "glCompressedTexImage1DARB");
d4412 2
a4413 1
      n = alloc_instruction(ctx, OPCODE_COMPRESSED_TEX_IMAGE_2D, 8);
d4422 2
a4423 1
         n[8].data = copy_data(data, imageSize, "glCompressedTexImage2DARB");
d4451 2
a4452 1
      n = alloc_instruction(ctx, OPCODE_COMPRESSED_TEX_IMAGE_3D, 9);
d4462 2
a4463 1
         n[9].data = copy_data(data, imageSize, "glCompressedTexImage3DARB");
d4484 2
a4485 1
   n = alloc_instruction(ctx, OPCODE_COMPRESSED_TEX_SUB_IMAGE_1D, 7);
d4493 2
a4494 1
      n[7].data = copy_data(data, imageSize, "glCompressedTexSubImage1DARB");
d4514 2
a4515 1
   n = alloc_instruction(ctx, OPCODE_COMPRESSED_TEX_SUB_IMAGE_2D, 9);
d4525 2
a4526 1
      n[9].data = copy_data(data, imageSize, "glCompressedTexSubImage2DARB");
d4546 2
a4547 1
   n = alloc_instruction(ctx, OPCODE_COMPRESSED_TEX_SUB_IMAGE_3D, 11);
d4559 2
a4560 1
      n[11].data = copy_data(data, imageSize, "glCompressedTexSubImage3DARB");
d4858 1
a4858 1
   n = alloc_instruction(ctx, OPCODE_PROGRAM_STRING_ARB, 4);
d4869 1
a4869 1
      n[4].data = programCopy;
d5799 530
a6328 1
save_ProvokingVertexEXT(GLenum mode)
d6333 1
a6333 1
   n = alloc_instruction(ctx, OPCODE_PROVOKING_VERTEX, 1);
d6335 3
a6337 1
      n[1].e = mode;
d6340 1
a6340 2
      /*CALL_ProvokingVertex(ctx->Exec, (mode));*/
      _mesa_ProvokingVertex(mode);
a6343 2

/** GL_EXT_transform_feedback */
d6345 1
a6345 1
save_BeginTransformFeedback(GLenum mode)
d6350 1
a6350 1
   n = alloc_instruction(ctx, OPCODE_BEGIN_TRANSFORM_FEEDBACK, 1);
d6352 3
a6354 1
      n[1].e = mode;
d6357 1
a6357 1
      CALL_BeginTransformFeedback(ctx->Exec, (mode));
a6360 2

/** GL_EXT_transform_feedback */
d6362 1
a6362 1
save_EndTransformFeedback(void)
d6365 1
d6367 6
a6372 1
   (void) alloc_instruction(ctx, OPCODE_END_TRANSFORM_FEEDBACK, 0);
d6374 1
a6374 1
      CALL_EndTransformFeedback(ctx->Exec, ());
d6379 1
a6379 1
save_BindTransformFeedback(GLenum target, GLuint name)
d6384 1
a6384 1
   n = alloc_instruction(ctx, OPCODE_BIND_TRANSFORM_FEEDBACK, 2);
d6386 3
a6388 2
      n[1].e = target;
      n[2].ui = name;
d6391 1
a6391 1
      CALL_BindTransformFeedback(ctx->Exec, (target, name));
d6395 2
d6398 2
a6399 1
save_PauseTransformFeedback(void)
d6402 1
d6404 7
a6410 1
   (void) alloc_instruction(ctx, OPCODE_PAUSE_TRANSFORM_FEEDBACK, 0);
d6412 1
a6412 1
      CALL_PauseTransformFeedback(ctx->Exec, ());
d6417 2
a6418 1
save_ResumeTransformFeedback(void)
d6421 1
d6423 7
a6429 1
   (void) alloc_instruction(ctx, OPCODE_RESUME_TRANSFORM_FEEDBACK, 0);
d6431 1
a6431 1
      CALL_ResumeTransformFeedback(ctx->Exec, ());
d6436 2
a6437 1
save_DrawTransformFeedback(GLenum mode, GLuint name)
d6442 1
a6442 1
   n = alloc_instruction(ctx, OPCODE_DRAW_TRANSFORM_FEEDBACK, 2);
d6444 4
a6447 2
      n[1].e = mode;
      n[2].ui = name;
d6450 1
a6450 1
      CALL_DrawTransformFeedback(ctx->Exec, (mode, name));
d6454 1
d6456 2
a6457 1
save_DrawTransformFeedbackStream(GLenum mode, GLuint name, GLuint stream)
d6462 1
a6462 1
   n = alloc_instruction(ctx, OPCODE_DRAW_TRANSFORM_FEEDBACK_STREAM, 3);
d6464 4
a6467 3
      n[1].e = mode;
      n[2].ui = name;
      n[3].ui = stream;
d6470 1
a6470 1
      CALL_DrawTransformFeedbackStream(ctx->Exec, (mode, name, stream));
d6475 2
a6476 2
save_DrawTransformFeedbackInstanced(GLenum mode, GLuint name,
                                    GLsizei primcount)
d6481 1
a6481 1
   n = alloc_instruction(ctx, OPCODE_DRAW_TRANSFORM_FEEDBACK_INSTANCED, 3);
d6483 4
a6486 3
      n[1].e = mode;
      n[2].ui = name;
      n[3].si = primcount;
d6489 1
a6489 1
      CALL_DrawTransformFeedbackInstanced(ctx->Exec, (mode, name, primcount));
d6493 1
d6495 2
a6496 2
save_DrawTransformFeedbackStreamInstanced(GLenum mode, GLuint name,
                                          GLuint stream, GLsizei primcount)
d6501 1
a6501 1
   n = alloc_instruction(ctx, OPCODE_DRAW_TRANSFORM_FEEDBACK_STREAM_INSTANCED, 4);
d6503 4
a6506 4
      n[1].e = mode;
      n[2].ui = name;
      n[3].ui = stream;
      n[4].si = primcount;
d6509 1
a6509 2
      CALL_DrawTransformFeedbackStreamInstanced(ctx->Exec, (mode, name, stream,
                                                            primcount));
a6512 1
/* aka UseProgram() */
d6514 2
a6515 1
save_UseProgramObjectARB(GLhandleARB program)
d6520 1
a6520 1
   n = alloc_instruction(ctx, OPCODE_USE_PROGRAM, 1);
d6522 4
a6525 1
      n[1].ui = program;
d6528 1
a6528 1
      CALL_UseProgram(ctx->Exec, (program));
d6534 2
a6535 1
save_Uniform1fARB(GLint location, GLfloat x)
d6540 1
a6540 1
   n = alloc_instruction(ctx, OPCODE_UNIFORM_1F, 2);
d6543 3
a6545 1
      n[2].f = x;
d6548 1
a6548 1
      CALL_Uniform1f(ctx->Exec, (location, x));
a6551 1

d6553 2
a6554 1
save_Uniform2fARB(GLint location, GLfloat x, GLfloat y)
d6559 1
a6559 1
   n = alloc_instruction(ctx, OPCODE_UNIFORM_2F, 3);
d6562 3
a6564 2
      n[2].f = x;
      n[3].f = y;
d6567 1
a6567 1
      CALL_Uniform2f(ctx->Exec, (location, x, y));
a6570 1

d6572 1
a6572 1
save_Uniform3fARB(GLint location, GLfloat x, GLfloat y, GLfloat z)
d6577 1
a6577 1
   n = alloc_instruction(ctx, OPCODE_UNIFORM_3F, 4);
d6579 3
a6581 4
      n[1].i = location;
      n[2].f = x;
      n[3].f = y;
      n[4].f = z;
d6584 1
a6584 1
      CALL_Uniform3f(ctx->Exec, (location, x, y, z));
a6587 1

d6589 1
a6589 1
save_Uniform4fARB(GLint location, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
d6594 1
a6594 1
   n = alloc_instruction(ctx, OPCODE_UNIFORM_4F, 5);
d6596 3
a6598 5
      n[1].i = location;
      n[2].f = x;
      n[3].f = y;
      n[4].f = z;
      n[5].f = w;
d6601 1
a6601 1
      CALL_Uniform4f(ctx->Exec, (location, x, y, z, w));
d6605 2
a6606 4

/** Return copy of memory */
static void *
memdup(const void *src, GLsizei bytes)
d6608 13
a6620 4
   void *b = bytes >= 0 ? malloc(bytes) : NULL;
   if (b)
      memcpy(b, src, bytes);
   return b;
a6622 1

d6624 2
a6625 1
save_Uniform1fvARB(GLint location, GLsizei count, const GLfloat *v)
d6630 1
a6630 1
   n = alloc_instruction(ctx, OPCODE_UNIFORM_1FV, 3);
d6632 5
a6636 3
      n[1].i = location;
      n[2].i = count;
      n[3].data = memdup(v, count * 1 * sizeof(GLfloat));
d6639 1
a6639 1
      CALL_Uniform1fv(ctx->Exec, (location, count, v));
d6644 2
a6645 1
save_Uniform2fvARB(GLint location, GLsizei count, const GLfloat *v)
d6650 1
a6650 1
   n = alloc_instruction(ctx, OPCODE_UNIFORM_2FV, 3);
d6652 6
a6657 3
      n[1].i = location;
      n[2].i = count;
      n[3].data = memdup(v, count * 2 * sizeof(GLfloat));
d6660 1
a6660 1
      CALL_Uniform2fv(ctx->Exec, (location, count, v));
d6665 2
a6666 1
save_Uniform3fvARB(GLint location, GLsizei count, const GLfloat *v)
d6671 1
a6671 1
   n = alloc_instruction(ctx, OPCODE_UNIFORM_3FV, 3);
d6673 4
a6676 3
      n[1].i = location;
      n[2].i = count;
      n[3].data = memdup(v, count * 3 * sizeof(GLfloat));
d6679 1
a6679 1
      CALL_Uniform3fv(ctx->Exec, (location, count, v));
d6684 2
a6685 1
save_Uniform4fvARB(GLint location, GLsizei count, const GLfloat *v)
d6690 1
a6690 1
   n = alloc_instruction(ctx, OPCODE_UNIFORM_4FV, 3);
d6692 4
a6695 3
      n[1].i = location;
      n[2].i = count;
      n[3].data = memdup(v, count * 4 * sizeof(GLfloat));
d6698 1
a6698 1
      CALL_Uniform4fv(ctx->Exec, (location, count, v));
a6701 1

d6703 2
a6704 1
save_Uniform1iARB(GLint location, GLint x)
d6709 1
a6709 1
   n = alloc_instruction(ctx, OPCODE_UNIFORM_1I, 2);
d6711 4
a6714 2
      n[1].i = location;
      n[2].i = x;
d6717 1
a6717 1
      CALL_Uniform1i(ctx->Exec, (location, x));
d6722 2
a6723 1
save_Uniform2iARB(GLint location, GLint x, GLint y)
d6728 1
a6728 1
   n = alloc_instruction(ctx, OPCODE_UNIFORM_2I, 3);
d6730 4
a6733 3
      n[1].i = location;
      n[2].i = x;
      n[3].i = y;
d6736 1
a6736 1
      CALL_Uniform2i(ctx->Exec, (location, x, y));
d6741 1
a6741 1
save_Uniform3iARB(GLint location, GLint x, GLint y, GLint z)
d6746 1
a6746 1
   n = alloc_instruction(ctx, OPCODE_UNIFORM_3I, 4);
d6748 3
a6750 4
      n[1].i = location;
      n[2].i = x;
      n[3].i = y;
      n[4].i = z;
d6753 1
a6753 1
      CALL_Uniform3i(ctx->Exec, (location, x, y, z));
d6758 1
a6758 1
save_Uniform4iARB(GLint location, GLint x, GLint y, GLint z, GLint w)
d6763 1
a6763 1
   n = alloc_instruction(ctx, OPCODE_UNIFORM_4I, 5);
d6765 4
a6768 5
      n[1].i = location;
      n[2].i = x;
      n[3].i = y;
      n[4].i = z;
      n[5].i = w;
d6771 1
a6771 1
      CALL_Uniform4i(ctx->Exec, (location, x, y, z, w));
a6774 2


d6776 2
a6777 1
save_Uniform1ivARB(GLint location, GLsizei count, const GLint *v)
d6782 1
a6782 1
   n = alloc_instruction(ctx, OPCODE_UNIFORM_1IV, 3);
d6784 5
a6788 3
      n[1].i = location;
      n[2].i = count;
      n[3].data = memdup(v, count * 1 * sizeof(GLint));
d6791 1
a6791 1
      CALL_Uniform1iv(ctx->Exec, (location, count, v));
d6796 2
a6797 1
save_Uniform2ivARB(GLint location, GLsizei count, const GLint *v)
d6802 1
a6802 1
   n = alloc_instruction(ctx, OPCODE_UNIFORM_2IV, 3);
d6804 6
a6809 3
      n[1].i = location;
      n[2].i = count;
      n[3].data = memdup(v, count * 2 * sizeof(GLint));
d6812 1
a6812 1
      CALL_Uniform2iv(ctx->Exec, (location, count, v));
d6817 2
a6818 1
save_Uniform3ivARB(GLint location, GLsizei count, const GLint *v)
d6823 1
a6823 1
   n = alloc_instruction(ctx, OPCODE_UNIFORM_3IV, 3);
d6825 4
a6828 3
      n[1].i = location;
      n[2].i = count;
      n[3].data = memdup(v, count * 3 * sizeof(GLint));
d6831 1
a6831 1
      CALL_Uniform3iv(ctx->Exec, (location, count, v));
d6836 2
a6837 1
save_Uniform4ivARB(GLint location, GLsizei count, const GLint *v)
d6842 1
a6842 1
   n = alloc_instruction(ctx, OPCODE_UNIFORM_4IV, 3);
d6844 4
a6847 3
      n[1].i = location;
      n[2].i = count;
      n[3].data = memdup(v, count * 4 * sizeof(GLfloat));
d6850 1
a6850 1
      CALL_Uniform4iv(ctx->Exec, (location, count, v));
a6853 2


d6855 2
a6856 1
save_Uniform1ui(GLint location, GLuint x)
d6861 1
a6861 1
   n = alloc_instruction(ctx, OPCODE_UNIFORM_1UI, 2);
d6863 4
a6866 2
      n[1].i = location;
      n[2].i = x;
d6869 1
a6869 1
      /*CALL_Uniform1ui(ctx->Exec, (location, x));*/
d6874 2
a6875 1
save_Uniform2ui(GLint location, GLuint x, GLuint y)
d6880 1
a6880 1
   n = alloc_instruction(ctx, OPCODE_UNIFORM_2UI, 3);
d6882 4
a6885 3
      n[1].i = location;
      n[2].i = x;
      n[3].i = y;
d6888 1
a6888 1
      /*CALL_Uniform2ui(ctx->Exec, (location, x, y));*/
d6893 1
a6893 1
save_Uniform3ui(GLint location, GLuint x, GLuint y, GLuint z)
d6898 1
a6898 1
   n = alloc_instruction(ctx, OPCODE_UNIFORM_3UI, 4);
d6900 3
a6902 4
      n[1].i = location;
      n[2].i = x;
      n[3].i = y;
      n[4].i = z;
d6905 1
a6905 1
      /*CALL_Uniform3ui(ctx->Exec, (location, x, y, z));*/
d6910 1
a6910 1
save_Uniform4ui(GLint location, GLuint x, GLuint y, GLuint z, GLuint w)
d6915 1
a6915 1
   n = alloc_instruction(ctx, OPCODE_UNIFORM_4UI, 5);
d6917 4
a6920 5
      n[1].i = location;
      n[2].i = x;
      n[3].i = y;
      n[4].i = z;
      n[5].i = w;
d6923 1
a6923 1
      /*CALL_Uniform4ui(ctx->Exec, (location, x, y, z, w));*/
a6926 2


d6928 2
a6929 1
save_Uniform1uiv(GLint location, GLsizei count, const GLuint *v)
d6934 1
a6934 1
   n = alloc_instruction(ctx, OPCODE_UNIFORM_1UIV, 3);
d6936 5
a6940 3
      n[1].i = location;
      n[2].i = count;
      n[3].data = memdup(v, count * 1 * sizeof(*v));
d6943 1
a6943 1
      /*CALL_Uniform1uiv(ctx->Exec, (location, count, v));*/
d6948 2
a6949 1
save_Uniform2uiv(GLint location, GLsizei count, const GLuint *v)
d6954 1
a6954 1
   n = alloc_instruction(ctx, OPCODE_UNIFORM_2UIV, 3);
d6956 6
a6961 3
      n[1].i = location;
      n[2].i = count;
      n[3].data = memdup(v, count * 2 * sizeof(*v));
d6964 1
a6964 1
      /*CALL_Uniform2uiv(ctx->Exec, (location, count, v));*/
d6969 2
a6970 1
save_Uniform3uiv(GLint location, GLsizei count, const GLuint *v)
d6975 1
a6975 1
   n = alloc_instruction(ctx, OPCODE_UNIFORM_3UIV, 3);
d6977 4
a6980 3
      n[1].i = location;
      n[2].i = count;
      n[3].data = memdup(v, count * 3 * sizeof(*v));
d6983 1
a6983 1
      /*CALL_Uniform3uiv(ctx->Exec, (location, count, v));*/
d6988 2
a6989 1
save_Uniform4uiv(GLint location, GLsizei count, const GLuint *v)
d6994 1
a6994 1
   n = alloc_instruction(ctx, OPCODE_UNIFORM_4UIV, 3);
d6996 4
a6999 3
      n[1].i = location;
      n[2].i = count;
      n[3].data = memdup(v, count * 4 * sizeof(*v));
d7002 1
a7002 1
      /*CALL_Uniform4uiv(ctx->Exec, (location, count, v));*/
a7005 2


d7007 2
a7008 2
save_UniformMatrix2fvARB(GLint location, GLsizei count, GLboolean transpose,
                         const GLfloat *m)
d7013 1
a7013 1
   n = alloc_instruction(ctx, OPCODE_UNIFORM_MATRIX22, 4);
d7015 4
a7018 4
      n[1].i = location;
      n[2].i = count;
      n[3].b = transpose;
      n[4].data = memdup(m, count * 2 * 2 * sizeof(GLfloat));
d7021 1
a7021 1
      CALL_UniformMatrix2fv(ctx->Exec, (location, count, transpose, m));
d7026 2
a7027 2
save_UniformMatrix3fvARB(GLint location, GLsizei count, GLboolean transpose,
                         const GLfloat *m)
d7032 1
a7032 1
   n = alloc_instruction(ctx, OPCODE_UNIFORM_MATRIX33, 4);
d7034 4
a7037 4
      n[1].i = location;
      n[2].i = count;
      n[3].b = transpose;
      n[4].data = memdup(m, count * 3 * 3 * sizeof(GLfloat));
d7040 1
a7040 1
      CALL_UniformMatrix3fv(ctx->Exec, (location, count, transpose, m));
d7045 2
a7046 2
save_UniformMatrix4fvARB(GLint location, GLsizei count, GLboolean transpose,
                         const GLfloat *m)
d7051 2
a7052 1
   n = alloc_instruction(ctx, OPCODE_UNIFORM_MATRIX44, 4);
d7054 5
a7058 4
      n[1].i = location;
      n[2].i = count;
      n[3].b = transpose;
      n[4].data = memdup(m, count * 4 * 4 * sizeof(GLfloat));
d7061 2
a7062 1
      CALL_UniformMatrix4fv(ctx->Exec, (location, count, transpose, m));
a7065 1

d7067 2
a7068 2
save_UniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose,
                        const GLfloat *m)
d7073 2
a7074 1
   n = alloc_instruction(ctx, OPCODE_UNIFORM_MATRIX23, 4);
d7076 5
a7080 4
      n[1].i = location;
      n[2].i = count;
      n[3].b = transpose;
      n[4].data = memdup(m, count * 2 * 3 * sizeof(GLfloat));
d7083 2
a7084 1
      CALL_UniformMatrix2x3fv(ctx->Exec, (location, count, transpose, m));
d7089 2
a7090 2
save_UniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose,
                        const GLfloat *m)
d7095 2
a7096 1
   n = alloc_instruction(ctx, OPCODE_UNIFORM_MATRIX32, 4);
d7098 5
a7102 4
      n[1].i = location;
      n[2].i = count;
      n[3].b = transpose;
      n[4].data = memdup(m, count * 3 * 2 * sizeof(GLfloat));
d7105 2
a7106 1
      CALL_UniformMatrix3x2fv(ctx->Exec, (location, count, transpose, m));
a7109 1

d7111 2
a7112 2
save_UniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose,
                        const GLfloat *m)
d7117 2
a7118 1
   n = alloc_instruction(ctx, OPCODE_UNIFORM_MATRIX24, 4);
d7120 5
a7124 4
      n[1].i = location;
      n[2].i = count;
      n[3].b = transpose;
      n[4].data = memdup(m, count * 2 * 4 * sizeof(GLfloat));
d7127 2
a7128 1
      CALL_UniformMatrix2x4fv(ctx->Exec, (location, count, transpose, m));
d7133 2
a7134 2
save_UniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose,
                        const GLfloat *m)
d7139 2
a7140 1
   n = alloc_instruction(ctx, OPCODE_UNIFORM_MATRIX42, 4);
d7142 5
a7146 4
      n[1].i = location;
      n[2].i = count;
      n[3].b = transpose;
      n[4].data = memdup(m, count * 4 * 2 * sizeof(GLfloat));
d7149 2
a7150 1
      CALL_UniformMatrix4x2fv(ctx->Exec, (location, count, transpose, m));
a7153 1

d7155 2
a7156 2
save_UniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose,
                        const GLfloat *m)
d7161 2
a7162 1
   n = alloc_instruction(ctx, OPCODE_UNIFORM_MATRIX34, 4);
d7164 5
a7168 4
      n[1].i = location;
      n[2].i = count;
      n[3].b = transpose;
      n[4].data = memdup(m, count * 3 * 4 * sizeof(GLfloat));
d7171 2
a7172 1
      CALL_UniformMatrix3x4fv(ctx->Exec, (location, count, transpose, m));
d7177 2
a7178 2
save_UniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose,
                        const GLfloat *m)
d7183 2
a7184 1
   n = alloc_instruction(ctx, OPCODE_UNIFORM_MATRIX43, 4);
d7186 5
a7190 4
      n[1].i = location;
      n[2].i = count;
      n[3].b = transpose;
      n[4].data = memdup(m, count * 4 * 3 * sizeof(GLfloat));
d7193 2
a7194 1
      CALL_UniformMatrix4x3fv(ctx->Exec, (location, count, transpose, m));
d7199 2
a7200 1
save_ClampColorARB(GLenum target, GLenum clamp)
d7205 2
a7206 1
   n = alloc_instruction(ctx, OPCODE_CLAMP_COLOR, 2);
d7208 5
a7212 2
      n[1].e = target;
      n[2].e = clamp;
d7215 2
a7216 1
      CALL_ClampColor(ctx->Exec, (target, clamp));
d7221 2
a7222 1
save_UseShaderProgramEXT(GLenum type, GLuint program)
d7227 2
a7228 1
   n = alloc_instruction(ctx, OPCODE_USE_SHADER_PROGRAM_EXT, 2);
d7230 5
a7234 2
      n[1].ui = type;
      n[2].ui = program;
d7237 2
a7238 1
      CALL_UseShaderProgramEXT(ctx->Exec, (type, program));
d7243 1
a7243 1
save_ActiveProgramEXT(GLuint program)
d7248 1
a7248 1
   n = alloc_instruction(ctx, OPCODE_ACTIVE_PROGRAM_EXT, 1);
d7250 2
a7251 1
      n[1].ui = program;
d7254 1
a7254 1
      CALL_ActiveProgramEXT(ctx->Exec, (program));
d7574 4
a7577 4
      n[1].data = sync;
      n[2].e = flags;
      n[3].ui = p.uint32[0];
      n[4].ui = p.uint32[1];
d7641 1
a7641 1
   n = alloc_instruction(ctx, OPCODE_ERROR, 2);
d7644 5
a7648 1
      n[2].data = (void *) s;
d7672 1
a7672 1
   if (list > 0 && lookup_list(ctx, list)) {
d7708 1
a7708 1
   dlist = lookup_list(ctx, list);
d7729 1
a7729 1
            _mesa_error(ctx, n[1].e, "%s", (const char *) n[2].data);
d7746 1
a7746 1
                                       (const GLubyte *) n[7].data));
a7870 96
         case OPCODE_COLOR_TABLE:
            {
               const struct gl_pixelstore_attrib save = ctx->Unpack;
               ctx->Unpack = ctx->DefaultPacking;
               CALL_ColorTable(ctx->Exec, (n[1].e, n[2].e, n[3].i, n[4].e,
                                           n[5].e, n[6].data));
               ctx->Unpack = save;      /* restore */
            }
            break;
         case OPCODE_COLOR_TABLE_PARAMETER_FV:
            {
               GLfloat params[4];
               params[0] = n[3].f;
               params[1] = n[4].f;
               params[2] = n[5].f;
               params[3] = n[6].f;
               CALL_ColorTableParameterfv(ctx->Exec,
                                          (n[1].e, n[2].e, params));
            }
            break;
         case OPCODE_COLOR_TABLE_PARAMETER_IV:
            {
               GLint params[4];
               params[0] = n[3].i;
               params[1] = n[4].i;
               params[2] = n[5].i;
               params[3] = n[6].i;
               CALL_ColorTableParameteriv(ctx->Exec,
                                          (n[1].e, n[2].e, params));
            }
            break;
         case OPCODE_COLOR_SUB_TABLE:
            {
               const struct gl_pixelstore_attrib save = ctx->Unpack;
               ctx->Unpack = ctx->DefaultPacking;
               CALL_ColorSubTable(ctx->Exec, (n[1].e, n[2].i, n[3].i,
                                              n[4].e, n[5].e, n[6].data));
               ctx->Unpack = save;      /* restore */
            }
            break;
         case OPCODE_CONVOLUTION_FILTER_1D:
            {
               const struct gl_pixelstore_attrib save = ctx->Unpack;
               ctx->Unpack = ctx->DefaultPacking;
               CALL_ConvolutionFilter1D(ctx->Exec, (n[1].e, n[2].i, n[3].i,
                                                    n[4].e, n[5].e,
                                                    n[6].data));
               ctx->Unpack = save;      /* restore */
            }
            break;
         case OPCODE_CONVOLUTION_FILTER_2D:
            {
               const struct gl_pixelstore_attrib save = ctx->Unpack;
               ctx->Unpack = ctx->DefaultPacking;
               CALL_ConvolutionFilter2D(ctx->Exec, (n[1].e, n[2].i, n[3].i,
                                                    n[4].i, n[5].e, n[6].e,
                                                    n[7].data));
               ctx->Unpack = save;      /* restore */
            }
            break;
         case OPCODE_CONVOLUTION_PARAMETER_I:
            CALL_ConvolutionParameteri(ctx->Exec, (n[1].e, n[2].e, n[3].i));
            break;
         case OPCODE_CONVOLUTION_PARAMETER_IV:
            {
               GLint params[4];
               params[0] = n[3].i;
               params[1] = n[4].i;
               params[2] = n[5].i;
               params[3] = n[6].i;
               CALL_ConvolutionParameteriv(ctx->Exec,
                                           (n[1].e, n[2].e, params));
            }
            break;
         case OPCODE_CONVOLUTION_PARAMETER_F:
            CALL_ConvolutionParameterf(ctx->Exec, (n[1].e, n[2].e, n[3].f));
            break;
         case OPCODE_CONVOLUTION_PARAMETER_FV:
            {
               GLfloat params[4];
               params[0] = n[3].f;
               params[1] = n[4].f;
               params[2] = n[5].f;
               params[3] = n[6].f;
               CALL_ConvolutionParameterfv(ctx->Exec,
                                           (n[1].e, n[2].e, params));
            }
            break;
         case OPCODE_COPY_COLOR_SUB_TABLE:
            CALL_CopyColorSubTable(ctx->Exec, (n[1].e, n[2].i,
                                               n[3].i, n[4].i, n[5].i));
            break;
         case OPCODE_COPY_COLOR_TABLE:
            CALL_CopyColorSubTable(ctx->Exec, (n[1].e, n[2].i,
                                               n[3].i, n[4].i, n[5].i));
            break;
d7925 1
a7925 1
                                           n[5].data));
a7961 3
         case OPCODE_HISTOGRAM:
            CALL_Histogram(ctx->Exec, (n[1].e, n[2].i, n[3].e, n[4].b));
            break;
d8027 1
a8027 1
                                      (GLfloat *) n[6].data));
d8043 1
a8043 1
                                      (GLfloat *) n[10].data));
a8055 3
         case OPCODE_MIN_MAX:
            CALL_Minmax(ctx->Exec, (n[1].e, n[2].e, n[3].b));
            break;
d8078 1
a8078 1
                            (n[1].e, n[2].i, (GLfloat *) n[3].data));
d8105 1
a8105 1
               CALL_PolygonStipple(ctx->Exec, ((GLubyte *) n[1].data));
a8138 6
         case OPCODE_RESET_HISTOGRAM:
            CALL_ResetHistogram(ctx->Exec, (n[1].e));
            break;
         case OPCODE_RESET_MIN_MAX:
            CALL_ResetMinmax(ctx->Exec, (n[1].e));
            break;
d8215 1
a8215 1
                                           n[8].data));
d8231 1
a8231 1
                                           n[9].data));
d8248 1
a8248 1
                                           n[10].data));
d8258 1
a8258 1
                                              n[6].e, n[7].data));
d8269 1
a8269 1
                                              n[9].data));
d8280 1
a8280 1
                                              n[11].data));
d8299 2
a8300 2
                                                     n[4].i, n[5].i, n[6].i,
                                                     n[7].data));
d8304 2
a8305 2
                                                     n[4].i, n[5].i, n[6].i,
                                                     n[7].i, n[8].data));
d8309 3
a8311 3
                                                     n[4].i, n[5].i, n[6].i,
                                                     n[7].i, n[8].i,
                                                     n[9].data));
d8316 2
a8317 1
                                             n[5].e, n[6].i, n[7].data));
d8323 1
a8323 1
                                             n[9].data));
d8329 2
a8330 1
                                             n[9].e, n[10].i, n[11].data));
d8354 2
a8355 1
                                  (n[1].e, n[2].e, n[3].i, n[4].data));
a8393 6
	 case OPCODE_USE_SHADER_PROGRAM_EXT:
	    CALL_UseShaderProgramEXT(ctx->Exec, (n[1].ui, n[2].ui));
	    break;
	 case OPCODE_ACTIVE_PROGRAM_EXT:
	    CALL_ActiveProgramEXT(ctx->Exec, (n[1].ui));
	    break;
d8408 1
a8408 1
	    CALL_Uniform1fv(ctx->Exec, (n[1].i, n[2].i, n[3].data));
d8411 1
a8411 1
	    CALL_Uniform2fv(ctx->Exec, (n[1].i, n[2].i, n[3].data));
d8414 1
a8414 1
	    CALL_Uniform3fv(ctx->Exec, (n[1].i, n[2].i, n[3].data));
d8417 1
a8417 1
	    CALL_Uniform4fv(ctx->Exec, (n[1].i, n[2].i, n[3].data));
d8433 1
a8433 1
	    CALL_Uniform1iv(ctx->Exec, (n[1].i, n[2].i, n[3].data));
d8436 1
a8436 1
	    CALL_Uniform2iv(ctx->Exec, (n[1].i, n[2].i, n[3].data));
d8439 1
a8439 1
	    CALL_Uniform3iv(ctx->Exec, (n[1].i, n[2].i, n[3].data));
d8442 1
a8442 1
	    CALL_Uniform4iv(ctx->Exec, (n[1].i, n[2].i, n[3].data));
d8459 2
a8460 1
	    /*CALL_Uniform1uivARB(ctx->Exec, (n[1].i, n[2].i, n[3].data));*/
d8463 2
a8464 1
	    /*CALL_Uniform2uivARB(ctx->Exec, (n[1].i, n[2].i, n[3].data));*/
d8467 2
a8468 1
	    /*CALL_Uniform3uivARB(ctx->Exec, (n[1].i, n[2].i, n[3].data));*/
d8471 2
a8472 1
	    /*CALL_Uniform4uivARB(ctx->Exec, (n[1].i, n[2].i, n[3].data));*/
d8476 1
a8476 1
                                     (n[1].i, n[2].i, n[3].b, n[4].data));
d8480 1
a8480 1
                                     (n[1].i, n[2].i, n[3].b, n[4].data));
d8484 1
a8484 1
                                     (n[1].i, n[2].i, n[3].b, n[4].data));
d8488 1
a8488 1
                                    (n[1].i, n[2].i, n[3].b, n[4].data));
d8492 1
a8492 1
                                    (n[1].i, n[2].i, n[3].b, n[4].data));
d8496 1
a8496 1
                                    (n[1].i, n[2].i, n[3].b, n[4].data));
d8500 1
a8500 1
                                    (n[1].i, n[2].i, n[3].b, n[4].data));
d8504 1
a8504 1
                                    (n[1].i, n[2].i, n[3].b, n[4].data));
d8508 5
a8512 1
                                    (n[1].i, n[2].i, n[3].b, n[4].data));
d8514 137
d8903 4
a8906 3
               p.uint32[0] = n[3].ui;
               p.uint32[1] = n[4].ui;
               CALL_WaitSync(ctx->Exec, (n[1].data, n[2].bf, p.uint64));
d8923 1
a8923 1
            n = (Node *) n[1].next;
d9014 1
a9014 1
   _glthread_LOCK_MUTEX(ctx->Shared->Mutex);
d9026 1
a9026 1
   _glthread_UNLOCK_MUTEX(ctx->Shared->Mutex);
d9112 2
d9127 2
a9429 16
   SET_ColorSubTable(table, save_ColorSubTable);
   SET_ColorTable(table, save_ColorTable);
   SET_ColorTableParameterfv(table, save_ColorTableParameterfv);
   SET_ColorTableParameteriv(table, save_ColorTableParameteriv);
   SET_ConvolutionFilter1D(table, save_ConvolutionFilter1D);
   SET_ConvolutionFilter2D(table, save_ConvolutionFilter2D);
   SET_ConvolutionParameterf(table, save_ConvolutionParameterf);
   SET_ConvolutionParameterfv(table, save_ConvolutionParameterfv);
   SET_ConvolutionParameteri(table, save_ConvolutionParameteri);
   SET_ConvolutionParameteriv(table, save_ConvolutionParameteriv);
   SET_CopyColorSubTable(table, save_CopyColorSubTable);
   SET_CopyColorTable(table, save_CopyColorTable);
   SET_Histogram(table, save_Histogram);
   SET_Minmax(table, save_Minmax);
   SET_ResetHistogram(table, save_ResetHistogram);
   SET_ResetMinmax(table, save_ResetMinmax);
a9445 6
   /* 14. GL_SGI_color_table */
#if 0
   SET_ColorTableSGI(table, save_ColorTable);
   SET_ColorSubTableSGI(table, save_ColorSubTable);
#endif

a9599 4
   /* 377. GL_EXT_separate_shader_objects */
   SET_UseShaderProgramEXT(table, save_UseShaderProgramEXT);
   SET_ActiveProgramEXT(table, save_ActiveProgramEXT);

d9689 36
d9752 1
a9752 1
   dlist = lookup_list(ctx, list);
d9774 2
a9775 1
                         n[3].f, n[4].f, n[5].f, n[6].f, (void *) n[7].data);
a9783 10
         case OPCODE_COLOR_TABLE_PARAMETER_FV:
            printf("ColorTableParameterfv %s %s %f %f %f %f\n",
                         enum_string(n[1].e), enum_string(n[2].e),
                         n[3].f, n[4].f, n[5].f, n[6].f);
            break;
         case OPCODE_COLOR_TABLE_PARAMETER_IV:
            printf("ColorTableParameteriv %s %s %d %d %d %d\n",
                         enum_string(n[1].e), enum_string(n[2].e),
                         n[3].i, n[4].i, n[5].i, n[6].i);
            break;
d9958 2
a9959 2
            printf("Error: %s %s\n",
                         enum_string(n[1].e), (const char *) n[2].data);
d9963 1
a9963 1
            n = (Node *) n[1].next;
@


1.7
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a2 1
 * Version:  7.7
d20 4
a23 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
d37 1
a37 1
#if FEATURE_ATI_fragment_shader
a38 1
#endif
a39 2
#include "mfeatures.h"
#if FEATURE_ARB_vertex_buffer_object
a40 1
#endif
d46 1
d49 1
d61 1
a63 1
#if FEATURE_ARB_vertex_program || FEATURE_ARB_fragment_program
d65 1
a65 4
#endif
#if FEATURE_NV_vertex_program || FEATURE_NV_fragment_program
#include "nvprogram.h"
#endif
d71 2
d126 2
a127 3
   if (ctx->Driver.CurrentSavePrimitive <= GL_POLYGON ||		\
       ctx->Driver.CurrentSavePrimitive == PRIM_INSIDE_UNKNOWN_PRIM) {	\
      _mesa_compile_error( ctx, GL_INVALID_OPERATION, "begin/end" );	\
d140 2
a141 3
   if (ctx->Driver.CurrentSavePrimitive <= GL_POLYGON ||		\
       ctx->Driver.CurrentSavePrimitive == PRIM_INSIDE_UNKNOWN_PRIM) {	\
      _mesa_compile_error( ctx, GL_INVALID_OPERATION, "begin/end" );	\
d320 1
a320 1
   /* GL_NV_vertex_program */
a321 5
   OPCODE_EXECUTE_PROGRAM_NV,
   OPCODE_REQUEST_RESIDENT_PROGRAMS_NV,
   OPCODE_LOAD_PROGRAM_NV,
   OPCODE_TRACK_MATRIX_NV,
   /* GL_NV_fragment_program */
a322 1
   OPCODE_PROGRAM_NAMED_PARAMETER_NV,
d455 15
d502 1
a537 3
#if FEATURE_dlist


d555 1
a555 1
   dlist->Head = (Node *) malloc(sizeof(Node) * count);
d564 1
a564 1
static INLINE struct gl_display_list *
d573 1
a573 1
static INLINE GLboolean
a722 17
#if FEATURE_NV_vertex_program
         case OPCODE_LOAD_PROGRAM_NV:
            free(n[4].data);      /* program string */
            n += InstSize[n[0].opcode];
            break;
         case OPCODE_REQUEST_RESIDENT_PROGRAMS_NV:
            free(n[2].data);      /* array of program ids */
            n += InstSize[n[0].opcode];
            break;
#endif
#if FEATURE_NV_fragment_program
         case OPCODE_PROGRAM_NAMED_PARAMETER_NV:
            free(n[3].data);      /* parameter name */
            n += InstSize[n[0].opcode];
            break;
#endif
#if FEATURE_ARB_vertex_program || FEATURE_ARB_fragment_program
a726 1
#endif
d903 2
a904 2
         ctx->Driver.MapBuffer(ctx, GL_PIXEL_UNPACK_BUFFER_EXT,
                               GL_READ_ONLY_ARB, unpack->BufferObj);
d918 1
a918 2
      ctx->Driver.UnmapBuffer(ctx, GL_PIXEL_UNPACK_BUFFER_EXT,
                              unpack->BufferObj);
d959 1
a959 1
      newblock = (Node *) malloc(sizeof(Node) * BLOCK_SIZE);
d1038 1
a1038 1
static INLINE Node *
d1154 1
a1154 1
      CALL_BlendEquationSeparateEXT(ctx->Exec, (modeRGB, modeA));
d1174 1
a1174 1
      CALL_BlendFuncSeparateEXT(ctx->Exec,
d1281 85
a1365 1
static void invalidate_saved_current_state( struct gl_context *ctx )
d1380 1
d1489 1
a1489 1
      /*CALL_ClearBufferiv(ctx->Exec, (buffer, drawbuffer, value));*/
d1517 1
a1517 1
      /*CALL_ClearBufferuiv(ctx->Exec, (buffer, drawbuffer, value));*/
d1545 1
a1545 1
      /*CALL_ClearBufferuiv(ctx->Exec, (buffer, drawbuffer, value));*/
d1565 1
a1565 1
      /*CALL_ClearBufferfi(ctx->Exec, (buffer, drawbuffer, depth, stencil));*/
d1713 1
a1713 1
      /*CALL_ColorMaskIndexedEXT(ctx->Exec, (buf, red, green, blue, alpha));*/
d2286 1
a2286 1
      CALL_DisableIndexedEXT(ctx->Exec, (index, cap));
d2361 1
a2361 1
      CALL_EnableIndexedEXT(ctx->Exec, (index, cap));
d3162 1
a3162 1
      n[3].data = (void *) malloc(mapsize * sizeof(GLfloat));
d3264 1
a3264 1
      CALL_PointParameterfvEXT(ctx->Exec, (pname, params));
d3781 4
d3790 1
a3790 4
   /* Only save the value if we know the statechange will take effect:
    */
   if (ctx->Driver.CurrentSavePrimitive == PRIM_OUTSIDE_BEGIN_END)
      ctx->ListState.Current.ShadeModel = mode;
d4549 1
a4549 1
      CALL_ActiveTextureARB(ctx->Exec, (target));
d4620 1
a4620 1
      CALL_CompressedTexImage1DARB(ctx->Exec, (target, level, internalFormat,
d4639 1
a4639 1
         CALL_CompressedTexImage1DARB(ctx->Exec,
d4656 1
a4656 1
      CALL_CompressedTexImage2DARB(ctx->Exec, (target, level, internalFormat,
d4676 1
a4676 1
         CALL_CompressedTexImage2DARB(ctx->Exec,
d4693 1
a4693 1
      CALL_CompressedTexImage3DARB(ctx->Exec, (target, level, internalFormat,
d4714 1
a4714 1
         CALL_CompressedTexImage3DARB(ctx->Exec,
d4743 1
a4743 1
      CALL_CompressedTexSubImage1DARB(ctx->Exec, (target, level, xoffset,
d4773 1
a4773 1
      CALL_CompressedTexSubImage2DARB(ctx->Exec,
d4805 1
a4805 1
      CALL_CompressedTexSubImage3DARB(ctx->Exec,
d4826 1
a4826 1
      CALL_SampleCoverageARB(ctx->Exec, (value, invert));
d4832 1
a4832 1
 * GL_NV_vertex_program
a4833 1
#if FEATURE_NV_vertex_program || FEATURE_ARB_vertex_program || FEATURE_ARB_fragment_program
d4846 1
a4846 1
      CALL_BindProgramNV(ctx->Exec, (target, id));
a4932 119
#endif /* FEATURE_ARB_vertex_program || FEATURE_ARB_fragment_program || FEATURE_NV_vertex_program */

#if FEATURE_NV_vertex_program
static void GLAPIENTRY
save_ExecuteProgramNV(GLenum target, GLuint id, const GLfloat *params)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_EXECUTE_PROGRAM_NV, 6);
   if (n) {
      n[1].e = target;
      n[2].ui = id;
      n[3].f = params[0];
      n[4].f = params[1];
      n[5].f = params[2];
      n[6].f = params[3];
   }
   if (ctx->ExecuteFlag) {
      CALL_ExecuteProgramNV(ctx->Exec, (target, id, params));
   }
}


static void GLAPIENTRY
save_ProgramParameters4dvNV(GLenum target, GLuint index,
                            GLsizei num, const GLdouble *params)
{
   GLint i;
   for (i = 0; i < num; i++) {
      save_ProgramEnvParameter4dvARB(target, index + i, params + 4 * i);
   }
}


static void GLAPIENTRY
save_ProgramParameters4fvNV(GLenum target, GLuint index,
                            GLsizei num, const GLfloat *params)
{
   GLint i;
   for (i = 0; i < num; i++) {
      save_ProgramEnvParameter4fvARB(target, index + i, params + 4 * i);
   }
}


static void GLAPIENTRY
save_LoadProgramNV(GLenum target, GLuint id, GLsizei len,
                   const GLubyte * program)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;

   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);

   n = alloc_instruction(ctx, OPCODE_LOAD_PROGRAM_NV, 4);
   if (n) {
      GLubyte *programCopy = (GLubyte *) malloc(len);
      if (!programCopy) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glLoadProgramNV");
         return;
      }
      memcpy(programCopy, program, len);
      n[1].e = target;
      n[2].ui = id;
      n[3].i = len;
      n[4].data = programCopy;
   }
   if (ctx->ExecuteFlag) {
      CALL_LoadProgramNV(ctx->Exec, (target, id, len, program));
   }
}


static void GLAPIENTRY
save_RequestResidentProgramsNV(GLsizei num, const GLuint * ids)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;

   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);

   n = alloc_instruction(ctx, OPCODE_TRACK_MATRIX_NV, 2);
   if (n) {
      GLuint *idCopy = (GLuint *) malloc(num * sizeof(GLuint));
      if (!idCopy) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glRequestResidentProgramsNV");
         return;
      }
      memcpy(idCopy, ids, num * sizeof(GLuint));
      n[1].i = num;
      n[2].data = idCopy;
   }
   if (ctx->ExecuteFlag) {
      CALL_RequestResidentProgramsNV(ctx->Exec, (num, ids));
   }
}


static void GLAPIENTRY
save_TrackMatrixNV(GLenum target, GLuint address,
                   GLenum matrix, GLenum transform)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_TRACK_MATRIX_NV, 4);
   if (n) {
      n[1].e = target;
      n[2].ui = address;
      n[3].e = matrix;
      n[4].e = transform;
   }
   if (ctx->ExecuteFlag) {
      CALL_TrackMatrixNV(ctx->Exec, (target, address, matrix, transform));
   }
}
#endif /* FEATURE_NV_vertex_program */

a4933 4
/*
 * GL_NV_fragment_program
 */
#if FEATURE_NV_fragment_program
a5053 60
static void GLAPIENTRY
save_ProgramNamedParameter4fNV(GLuint id, GLsizei len, const GLubyte * name,
                               GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;

   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);

   n = alloc_instruction(ctx, OPCODE_PROGRAM_NAMED_PARAMETER_NV, 6);
   if (n) {
      GLubyte *nameCopy = (GLubyte *) malloc(len);
      if (!nameCopy) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glProgramNamedParameter4fNV");
         return;
      }
      memcpy(nameCopy, name, len);
      n[1].ui = id;
      n[2].i = len;
      n[3].data = nameCopy;
      n[4].f = x;
      n[5].f = y;
      n[6].f = z;
      n[7].f = w;
   }
   if (ctx->ExecuteFlag) {
      CALL_ProgramNamedParameter4fNV(ctx->Exec, (id, len, name, x, y, z, w));
   }
}


static void GLAPIENTRY
save_ProgramNamedParameter4fvNV(GLuint id, GLsizei len, const GLubyte * name,
                                const float v[])
{
   save_ProgramNamedParameter4fNV(id, len, name, v[0], v[1], v[2], v[3]);
}


static void GLAPIENTRY
save_ProgramNamedParameter4dNV(GLuint id, GLsizei len, const GLubyte * name,
                               GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   save_ProgramNamedParameter4fNV(id, len, name, (GLfloat) x, (GLfloat) y,
                                  (GLfloat) z, (GLfloat) w);
}


static void GLAPIENTRY
save_ProgramNamedParameter4dvNV(GLuint id, GLsizei len, const GLubyte * name,
                                const double v[])
{
   save_ProgramNamedParameter4fNV(id, len, name, (GLfloat) v[0],
                                  (GLfloat) v[1], (GLfloat) v[2],
                                  (GLfloat) v[3]);
}

#endif /* FEATURE_NV_fragment_program */


a5090 2
#if FEATURE_ARB_vertex_program || FEATURE_ARB_fragment_program

d5102 1
a5102 1
      GLubyte *programCopy = (GLubyte *) malloc(len);
a5117 4
#endif /* FEATURE_ARB_vertex_program || FEATURE_ARB_fragment_program */


#if FEATURE_queryobj
d5131 1
a5131 1
      CALL_BeginQueryARB(ctx->Exec, (target, id));
a5134 1

d5146 34
a5179 1
      CALL_EndQueryARB(ctx->Exec, (target));
d5183 15
a5197 1
#endif /* FEATURE_queryobj */
d5217 1
a5217 1
      CALL_DrawBuffersARB(ctx->Exec, (count, buffers));
a5250 1
#if FEATURE_ATI_fragment_shader
a5283 1
#endif
d5557 1
a5557 1
   save_Attr1fNV(VERT_ATTRIB_EDGEFLAG, x ? (GLfloat)1.0 : (GLfloat)0.0);
d5560 7
a5566 3
static INLINE GLboolean compare4fv( const GLfloat *a,
                                    const GLfloat *b,
                                    GLuint count )
a5569 1
                              
d5571 5
d5590 1
a5590 1
      _mesa_compile_error(ctx, GL_INVALID_ENUM, "material(face)");
d5609 1
a5609 1
      _mesa_compile_error(ctx, GL_INVALID_ENUM, "material(pname)");
d5626 2
a5627 1
             compare4fv(ctx->ListState.CurrentMaterial[i], param, args)) {
d5637 1
a5637 2
   /* If this call has effect, return early:
    */
a5655 2
   Node *n;
   GLboolean error = GL_FALSE;
d5657 7
a5663 10
   if ( /*mode < GL_POINTS || */ mode > GL_POLYGON) {
      _mesa_compile_error(ctx, GL_INVALID_ENUM, "Begin (mode)");
      error = GL_TRUE;
   }
   else if (ctx->Driver.CurrentSavePrimitive == PRIM_UNKNOWN) {
      /* Typically the first begin.  This may raise an error on
       * playback, depending on whether CallList is issued from inside
       * a begin/end or not.
       */
      ctx->Driver.CurrentSavePrimitive = PRIM_INSIDE_UNKNOWN_PRIM;
d5665 3
a5667 1
   else if (ctx->Driver.CurrentSavePrimitive == PRIM_OUTSIDE_BEGIN_END) {
a5668 5
   }
   else {
      _mesa_compile_error(ctx, GL_INVALID_OPERATION, "recursive begin");
      error = GL_TRUE;
   }
a5669 1
   if (!error) {
a5680 1
   }
d5682 3
a5684 2
   if (ctx->ExecuteFlag) {
      CALL_Begin(ctx->Exec, (mode));
d5705 1
a5705 1
   SAVE_FLUSH_VERTICES(ctx);
d5936 1
a5936 4
/* First level for NV_vertex_program:
 *
 * Check for errors at compile time?.
 */
d5938 1
a5938 1
save_VertexAttrib1fNV(GLuint index, GLfloat x)
d5940 2
a5941 2
   if (index < MAX_NV_VERTEX_PROGRAM_INPUTS)
      save_Attr1fNV(index, x);
d5947 1
a5947 1
save_VertexAttrib1fvNV(GLuint index, const GLfloat * v)
d5949 2
a5950 2
   if (index < MAX_NV_VERTEX_PROGRAM_INPUTS)
      save_Attr1fNV(index, v[0]);
d5956 1
a5956 1
save_VertexAttrib2fNV(GLuint index, GLfloat x, GLfloat y)
d5958 2
a5959 2
   if (index < MAX_NV_VERTEX_PROGRAM_INPUTS)
      save_Attr2fNV(index, x, y);
d5965 1
a5965 1
save_VertexAttrib2fvNV(GLuint index, const GLfloat * v)
d5967 2
a5968 78
   if (index < MAX_NV_VERTEX_PROGRAM_INPUTS)
      save_Attr2fNV(index, v[0], v[1]);
   else
      index_error();
}

static void GLAPIENTRY
save_VertexAttrib3fNV(GLuint index, GLfloat x, GLfloat y, GLfloat z)
{
   if (index < MAX_NV_VERTEX_PROGRAM_INPUTS)
      save_Attr3fNV(index, x, y, z);
   else
      index_error();
}

static void GLAPIENTRY
save_VertexAttrib3fvNV(GLuint index, const GLfloat * v)
{
   if (index < MAX_NV_VERTEX_PROGRAM_INPUTS)
      save_Attr3fNV(index, v[0], v[1], v[2]);
   else
      index_error();
}

static void GLAPIENTRY
save_VertexAttrib4fNV(GLuint index, GLfloat x, GLfloat y,
                      GLfloat z, GLfloat w)
{
   if (index < MAX_NV_VERTEX_PROGRAM_INPUTS)
      save_Attr4fNV(index, x, y, z, w);
   else
      index_error();
}

static void GLAPIENTRY
save_VertexAttrib4fvNV(GLuint index, const GLfloat * v)
{
   if (index < MAX_NV_VERTEX_PROGRAM_INPUTS)
      save_Attr4fNV(index, v[0], v[1], v[2], v[3]);
   else
      index_error();
}




static void GLAPIENTRY
save_VertexAttrib1fARB(GLuint index, GLfloat x)
{
   if (index < MAX_VERTEX_GENERIC_ATTRIBS)
      save_Attr1fARB(index, x);
   else
      index_error();
}

static void GLAPIENTRY
save_VertexAttrib1fvARB(GLuint index, const GLfloat * v)
{
   if (index < MAX_VERTEX_GENERIC_ATTRIBS)
      save_Attr1fARB(index, v[0]);
   else
      index_error();
}

static void GLAPIENTRY
save_VertexAttrib2fARB(GLuint index, GLfloat x, GLfloat y)
{
   if (index < MAX_VERTEX_GENERIC_ATTRIBS)
      save_Attr2fARB(index, x, y);
   else
      index_error();
}

static void GLAPIENTRY
save_VertexAttrib2fvARB(GLuint index, const GLfloat * v)
{
   if (index < MAX_VERTEX_GENERIC_ATTRIBS)
      save_Attr2fARB(index, v[0], v[1]);
a6009 30

/* GL_ARB_shader_objects, GL_ARB_vertex/fragment_shader */

static void GLAPIENTRY
exec_BindAttribLocationARB(GLuint program, GLuint index, const GLchar *name)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_BindAttribLocationARB(ctx->Exec, (program, index, name));
}

static GLint GLAPIENTRY
exec_GetAttribLocationARB(GLuint program, const GLchar *name)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   return CALL_GetAttribLocationARB(ctx->Exec, (program, name));
}

static GLint GLAPIENTRY
exec_GetUniformLocationARB(GLuint program, const GLchar *name)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   return CALL_GetUniformLocationARB(ctx->Exec, (program, name));
}
/* XXX more shader functions needed here */


#if FEATURE_EXT_framebuffer_blit
d6032 1
a6032 1
      CALL_BlitFramebufferEXT(ctx->Exec, (srcX0, srcY0, srcX1, srcY1,
a6036 1
#endif
d6051 2
a6052 2
      /*CALL_ProvokingVertexEXT(ctx->Exec, (mode));*/
      _mesa_ProvokingVertexEXT(mode);
d6069 1
a6069 1
      CALL_BeginTransformFeedbackEXT(ctx->Exec, (mode));
d6082 1
a6082 1
      CALL_EndTransformFeedbackEXT(ctx->Exec, ());
a6086 9
save_TransformFeedbackVaryings(GLuint program, GLsizei count,
                               const GLchar **varyings, GLenum bufferMode)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_problem(ctx,
                 "glTransformFeedbackVarying() display list support not done");
}

static void GLAPIENTRY
d6140 54
d6207 1
a6207 1
      CALL_UseProgramObjectARB(ctx->Exec, (program));
d6224 1
a6224 1
      CALL_Uniform1fARB(ctx->Exec, (location, x));
d6242 1
a6242 1
      CALL_Uniform2fARB(ctx->Exec, (location, x, y));
d6261 1
a6261 1
      CALL_Uniform3fARB(ctx->Exec, (location, x, y, z));
d6281 1
a6281 1
      CALL_Uniform4fARB(ctx->Exec, (location, x, y, z, w));
d6310 1
a6310 1
      CALL_Uniform1fvARB(ctx->Exec, (location, count, v));
d6327 1
a6327 1
      CALL_Uniform2fvARB(ctx->Exec, (location, count, v));
d6344 1
a6344 1
      CALL_Uniform3fvARB(ctx->Exec, (location, count, v));
d6361 1
a6361 1
      CALL_Uniform4fvARB(ctx->Exec, (location, count, v));
d6378 1
a6378 1
      CALL_Uniform1iARB(ctx->Exec, (location, x));
d6395 1
a6395 1
      CALL_Uniform2iARB(ctx->Exec, (location, x, y));
d6413 1
a6413 1
      CALL_Uniform3iARB(ctx->Exec, (location, x, y, z));
d6432 1
a6432 1
      CALL_Uniform4iARB(ctx->Exec, (location, x, y, z, w));
d6451 1
a6451 1
      CALL_Uniform1ivARB(ctx->Exec, (location, count, v));
d6468 1
a6468 1
      CALL_Uniform2ivARB(ctx->Exec, (location, count, v));
d6485 1
a6485 1
      CALL_Uniform3ivARB(ctx->Exec, (location, count, v));
d6502 1
a6502 1
      CALL_Uniform4ivARB(ctx->Exec, (location, count, v));
d6665 1
a6665 1
      CALL_UniformMatrix2fvARB(ctx->Exec, (location, count, transpose, m));
d6684 1
a6684 1
      CALL_UniformMatrix3fvARB(ctx->Exec, (location, count, transpose, m));
d6703 1
a6703 1
      CALL_UniformMatrix4fvARB(ctx->Exec, (location, count, transpose, m));
d6836 1
a6836 1
      CALL_ClampColorARB(ctx->Exec, (target, clamp));
d6926 1
a6926 1
      CALL_TexParameterIivEXT(ctx->Exec, (target, pname, params));
d6947 1
a6947 1
      CALL_TexParameterIuivEXT(ctx->Exec, (target, pname, params));
a6950 19
/** GL_EXT_texture_integer */
static void GLAPIENTRY
exec_GetTexParameterIiv(GLenum target, GLenum pname, GLint *params)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_GetTexParameterIivEXT(ctx->Exec, (target, pname, params));
}

/** GL_EXT_texture_integer */
static void GLAPIENTRY
exec_GetTexParameterIuiv(GLenum target, GLenum pname, GLuint *params)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_GetTexParameterIuivEXT(ctx->Exec, (target, pname, params));
}


d6964 1
a6964 1
      CALL_VertexAttribDivisorARB(ctx->Exec, (index, divisor));
d7027 4
a7030 1
   save_SamplerParameteriv(sampler, pname, &param);
d7061 4
a7064 1
   save_SamplerParameterfv(sampler, pname, &param);
d7131 1
a7131 1
      CALL_ProgramParameteriARB(ctx->Exec, (program, pname, value));
d7150 1
a7150 1
      CALL_FramebufferTextureARB(ctx->Exec, (target, attachment, texture, level));
d7211 1
a7211 1
      CALL_BeginConditionalRenderNV(ctx->Exec, (queryId, mode));
d7216 1
a7216 1
save_EndConditionalRender()
d7222 18
a7239 1
      CALL_EndConditionalRenderNV(ctx->Exec, ());
d7366 1
a7366 1
            CALL_BlendEquationSeparateEXT(ctx->Exec, (n[1].e, n[2].e));
d7369 1
a7369 1
            CALL_BlendFuncSeparateEXT(ctx->Exec,
d7419 1
a7419 1
               /*CALL_ClearBufferiv(ctx->Exec, (n[1].e, n[2].i, value));*/
d7429 1
a7429 1
               /*CALL_ClearBufferiv(ctx->Exec, (n[1].e, n[2].i, value));*/
d7439 1
a7439 1
               /*CALL_ClearBufferfv(ctx->Exec, (n[1].e, n[2].i, value));*/
d7443 1
a7443 1
            /*CALL_ClearBufferfi(ctx->Exec, (n[1].e, n[2].i, n[3].f, n[4].i));*/
d7474 1
a7474 1
            CALL_ColorMaskIndexedEXT(ctx->Exec, (n[1].ui, n[2].b, n[3].b,
d7620 1
a7620 1
            CALL_DisableIndexedEXT(ctx->Exec, (n[1].ui, n[2].e));
d7638 1
a7638 1
            CALL_EnableIndexedEXT(ctx->Exec, (n[1].ui, n[2].e));
d7806 1
a7806 1
               CALL_PointParameterfvEXT(ctx->Exec, (n[1].e, params));
d7869 1
a7869 1
            CALL_ProvokingVertexEXT(ctx->Exec, (n[1].e));
d8012 1
a8012 1
            CALL_ActiveTextureARB(ctx->Exec, (n[1].e));
d8015 1
a8015 1
            CALL_CompressedTexImage1DARB(ctx->Exec, (n[1].e, n[2].i, n[3].e,
d8020 1
a8020 1
            CALL_CompressedTexImage2DARB(ctx->Exec, (n[1].e, n[2].i, n[3].e,
d8025 1
a8025 1
            CALL_CompressedTexImage3DARB(ctx->Exec, (n[1].e, n[2].i, n[3].e,
d8031 1
a8031 1
            CALL_CompressedTexSubImage1DARB(ctx->Exec,
d8036 1
a8036 1
            CALL_CompressedTexSubImage2DARB(ctx->Exec,
d8042 1
a8042 1
            CALL_CompressedTexSubImage3DARB(ctx->Exec,
d8048 1
a8048 1
            CALL_SampleCoverageARB(ctx->Exec, (n[1].f, n[2].b));
d8051 1
a8051 5
            CALL_WindowPos3fMESA(ctx->Exec, (n[1].f, n[2].f, n[3].f));
            break;
#if FEATURE_NV_vertex_program || FEATURE_ARB_vertex_program || FEATURE_ARB_fragment_program
         case OPCODE_BIND_PROGRAM_NV:  /* GL_NV_vertex_program */
            CALL_BindProgramNV(ctx->Exec, (n[1].e, n[2].ui));
d8053 2
a8054 19
#endif
#if FEATURE_NV_vertex_program
         case OPCODE_EXECUTE_PROGRAM_NV:
            {
               GLfloat v[4];
               v[0] = n[3].f;
               v[1] = n[4].f;
               v[2] = n[5].f;
               v[3] = n[6].f;
               CALL_ExecuteProgramNV(ctx->Exec, (n[1].e, n[2].ui, v));
            }
            break;
         case OPCODE_REQUEST_RESIDENT_PROGRAMS_NV:
            CALL_RequestResidentProgramsNV(ctx->Exec, (n[1].ui,
                                                       (GLuint *) n[2].data));
            break;
         case OPCODE_LOAD_PROGRAM_NV:
            CALL_LoadProgramNV(ctx->Exec, (n[1].e, n[2].ui, n[3].i,
                                           (const GLubyte *) n[4].data));
a8055 6
         case OPCODE_TRACK_MATRIX_NV:
            CALL_TrackMatrixNV(ctx->Exec, (n[1].e, n[2].ui, n[3].e, n[4].e));
            break;
#endif

#if FEATURE_NV_fragment_program
a8060 8
         case OPCODE_PROGRAM_NAMED_PARAMETER_NV:
            CALL_ProgramNamedParameter4fNV(ctx->Exec, (n[1].ui, n[2].i,
                                                       (const GLubyte *) n[3].
                                                       data, n[4].f, n[5].f,
                                                       n[6].f, n[7].f));
            break;
#endif

a8066 1
#if FEATURE_ARB_vertex_program || FEATURE_ARB_fragment_program
a8070 2
#endif
#if FEATURE_ARB_vertex_program || FEATURE_ARB_fragment_program || FEATURE_NV_vertex_program
a8075 2
#endif
#if FEATURE_queryobj
d8077 1
a8077 1
            CALL_BeginQueryARB(ctx->Exec, (n[1].e, n[2].ui));
d8080 10
a8089 1
            CALL_EndQueryARB(ctx->Exec, (n[1].e));
a8090 1
#endif
d8097 1
a8097 1
               CALL_DrawBuffersARB(ctx->Exec, (n[1].i, buffers));
a8099 1
#if FEATURE_EXT_framebuffer_blit
d8101 1
a8101 1
	    CALL_BlitFramebufferEXT(ctx->Exec, (n[1].i, n[2].i, n[3].i, n[4].i,
a8104 2
#endif

d8106 1
a8106 1
	    CALL_UseProgramObjectARB(ctx->Exec, (n[1].ui));
d8115 1
a8115 1
	    CALL_Uniform1fARB(ctx->Exec, (n[1].i, n[2].f));
d8118 1
a8118 1
	    CALL_Uniform2fARB(ctx->Exec, (n[1].i, n[2].f, n[3].f));
d8121 1
a8121 1
	    CALL_Uniform3fARB(ctx->Exec, (n[1].i, n[2].f, n[3].f, n[4].f));
d8124 1
a8124 1
	    CALL_Uniform4fARB(ctx->Exec,
d8128 1
a8128 1
	    CALL_Uniform1fvARB(ctx->Exec, (n[1].i, n[2].i, n[3].data));
d8131 1
a8131 1
	    CALL_Uniform2fvARB(ctx->Exec, (n[1].i, n[2].i, n[3].data));
d8134 1
a8134 1
	    CALL_Uniform3fvARB(ctx->Exec, (n[1].i, n[2].i, n[3].data));
d8137 1
a8137 1
	    CALL_Uniform4fvARB(ctx->Exec, (n[1].i, n[2].i, n[3].data));
d8140 1
a8140 1
	    CALL_Uniform1iARB(ctx->Exec, (n[1].i, n[2].i));
d8143 1
a8143 1
	    CALL_Uniform2iARB(ctx->Exec, (n[1].i, n[2].i, n[3].i));
d8146 1
a8146 1
	    CALL_Uniform3iARB(ctx->Exec, (n[1].i, n[2].i, n[3].i, n[4].i));
d8149 1
a8149 1
	    CALL_Uniform4iARB(ctx->Exec,
d8153 1
a8153 1
	    CALL_Uniform1ivARB(ctx->Exec, (n[1].i, n[2].i, n[3].data));
d8156 1
a8156 1
	    CALL_Uniform2ivARB(ctx->Exec, (n[1].i, n[2].i, n[3].data));
d8159 1
a8159 1
	    CALL_Uniform3ivARB(ctx->Exec, (n[1].i, n[2].i, n[3].data));
d8162 1
a8162 1
	    CALL_Uniform4ivARB(ctx->Exec, (n[1].i, n[2].i, n[3].data));
d8191 1
a8191 1
	    CALL_UniformMatrix2fvARB(ctx->Exec,
d8195 1
a8195 1
	    CALL_UniformMatrix3fvARB(ctx->Exec,
d8199 1
a8199 1
	    CALL_UniformMatrix4fvARB(ctx->Exec,
d8228 1
a8228 1
            CALL_ClampColorARB(ctx->Exec, (n[1].e, n[2].e));
a8240 1
#if FEATURE_ATI_fragment_shader
a8253 1
#endif
d8361 1
a8361 1
               CALL_TexParameterIivEXT(ctx->Exec, (n[1].e, n[2].e, params));
d8371 1
a8371 1
               CALL_TexParameterIuivEXT(ctx->Exec, (n[1].e, n[2].e, params));
d8377 1
a8377 1
            CALL_VertexAttribDivisorARB(ctx->Exec, (n[1].ui, n[2].ui));
d8386 1
a8386 1
            CALL_BeginTransformFeedbackEXT(ctx->Exec, (n[1].e));
d8389 1
a8389 1
            CALL_EndTransformFeedbackEXT(ctx->Exec, ());
d8403 12
d8463 1
a8463 1
            CALL_ProgramParameteriARB(ctx->Exec, (n[1].ui, n[2].e, n[3].i));
d8466 1
a8466 1
            CALL_FramebufferTextureARB(ctx->Exec, (n[1].e, n[2].e,
d8486 1
a8486 1
            CALL_BeginConditionalRenderNV(ctx->Exec, (n[1].i, n[2].e));
d8489 5
a8493 1
            CALL_EndConditionalRenderNV(ctx->Exec, ());
d8534 1
a8534 1
static GLboolean GLAPIENTRY
d8547 1
a8547 1
static void GLAPIENTRY
d8569 1
a8569 1
static GLuint GLAPIENTRY
d8609 1
a8609 1
static void GLAPIENTRY
d8640 1
a8640 2
   /* Reset acumulated list state:
    */
d8658 1
a8658 1
static void GLAPIENTRY
d8663 1
a8663 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d8668 5
d8799 1
a8799 1
static void GLAPIENTRY
d8808 7
a8814 2

/* Can no longer assume ctx->Exec->Func is equal to _mesa_Func.
d8816 2
a8817 2
static void GLAPIENTRY
exec_Finish(void)
d8819 2
a8820 4
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_Finish(ctx->Exec, ());
}
d8822 5
a8826 7
static void GLAPIENTRY
exec_Flush(void)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_Flush(ctx->Exec, ());
}
d8828 1
a8828 7
static void GLAPIENTRY
exec_GetBooleanv(GLenum pname, GLboolean *params)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_GetBooleanv(ctx->Exec, (pname, params));
}
d8830 2
a8831 7
static void GLAPIENTRY
exec_GetClipPlane(GLenum plane, GLdouble * equation)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_GetClipPlane(ctx->Exec, (plane, equation));
}
d8833 38
a8870 772
static void GLAPIENTRY
exec_GetDoublev(GLenum pname, GLdouble *params)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_GetDoublev(ctx->Exec, (pname, params));
}

static GLenum GLAPIENTRY
exec_GetError(void)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   return CALL_GetError(ctx->Exec, ());
}

static void GLAPIENTRY
exec_GetFloatv(GLenum pname, GLfloat *params)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_GetFloatv(ctx->Exec, (pname, params));
}

static void GLAPIENTRY
exec_GetIntegerv(GLenum pname, GLint *params)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_GetIntegerv(ctx->Exec, (pname, params));
}

static void GLAPIENTRY
exec_GetLightfv(GLenum light, GLenum pname, GLfloat *params)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_GetLightfv(ctx->Exec, (light, pname, params));
}

static void GLAPIENTRY
exec_GetLightiv(GLenum light, GLenum pname, GLint *params)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_GetLightiv(ctx->Exec, (light, pname, params));
}

static void GLAPIENTRY
exec_GetMapdv(GLenum target, GLenum query, GLdouble * v)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_GetMapdv(ctx->Exec, (target, query, v));
}

static void GLAPIENTRY
exec_GetMapfv(GLenum target, GLenum query, GLfloat * v)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_GetMapfv(ctx->Exec, (target, query, v));
}

static void GLAPIENTRY
exec_GetMapiv(GLenum target, GLenum query, GLint * v)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_GetMapiv(ctx->Exec, (target, query, v));
}

static void GLAPIENTRY
exec_GetMaterialfv(GLenum face, GLenum pname, GLfloat *params)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_GetMaterialfv(ctx->Exec, (face, pname, params));
}

static void GLAPIENTRY
exec_GetMaterialiv(GLenum face, GLenum pname, GLint *params)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_GetMaterialiv(ctx->Exec, (face, pname, params));
}

static void GLAPIENTRY
exec_GetPixelMapfv(GLenum map, GLfloat *values)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_GetPixelMapfv(ctx->Exec, (map, values));
}

static void GLAPIENTRY
exec_GetPixelMapuiv(GLenum map, GLuint *values)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_GetPixelMapuiv(ctx->Exec, (map, values));
}

static void GLAPIENTRY
exec_GetPixelMapusv(GLenum map, GLushort *values)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_GetPixelMapusv(ctx->Exec, (map, values));
}

static void GLAPIENTRY
exec_GetPolygonStipple(GLubyte * dest)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_GetPolygonStipple(ctx->Exec, (dest));
}

static const GLubyte *GLAPIENTRY
exec_GetString(GLenum name)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   return CALL_GetString(ctx->Exec, (name));
}

static void GLAPIENTRY
exec_GetTexEnvfv(GLenum target, GLenum pname, GLfloat *params)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_GetTexEnvfv(ctx->Exec, (target, pname, params));
}

static void GLAPIENTRY
exec_GetTexEnviv(GLenum target, GLenum pname, GLint *params)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_GetTexEnviv(ctx->Exec, (target, pname, params));
}

static void GLAPIENTRY
exec_GetTexGendv(GLenum coord, GLenum pname, GLdouble *params)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_GetTexGendv(ctx->Exec, (coord, pname, params));
}

static void GLAPIENTRY
exec_GetTexGenfv(GLenum coord, GLenum pname, GLfloat *params)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_GetTexGenfv(ctx->Exec, (coord, pname, params));
}

static void GLAPIENTRY
exec_GetTexGeniv(GLenum coord, GLenum pname, GLint *params)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_GetTexGeniv(ctx->Exec, (coord, pname, params));
}

static void GLAPIENTRY
exec_GetTexImage(GLenum target, GLint level, GLenum format,
                 GLenum type, GLvoid * pixels)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_GetTexImage(ctx->Exec, (target, level, format, type, pixels));
}

static void GLAPIENTRY
exec_GetTexLevelParameterfv(GLenum target, GLint level,
                            GLenum pname, GLfloat *params)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_GetTexLevelParameterfv(ctx->Exec, (target, level, pname, params));
}

static void GLAPIENTRY
exec_GetTexLevelParameteriv(GLenum target, GLint level,
                            GLenum pname, GLint *params)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_GetTexLevelParameteriv(ctx->Exec, (target, level, pname, params));
}

static void GLAPIENTRY
exec_GetTexParameterfv(GLenum target, GLenum pname, GLfloat *params)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_GetTexParameterfv(ctx->Exec, (target, pname, params));
}

static void GLAPIENTRY
exec_GetTexParameteriv(GLenum target, GLenum pname, GLint *params)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_GetTexParameteriv(ctx->Exec, (target, pname, params));
}

static GLboolean GLAPIENTRY
exec_IsEnabled(GLenum cap)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   return CALL_IsEnabled(ctx->Exec, (cap));
}

static void GLAPIENTRY
exec_PixelStoref(GLenum pname, GLfloat param)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_PixelStoref(ctx->Exec, (pname, param));
}

static void GLAPIENTRY
exec_PixelStorei(GLenum pname, GLint param)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_PixelStorei(ctx->Exec, (pname, param));
}

static void GLAPIENTRY
exec_ReadPixels(GLint x, GLint y, GLsizei width, GLsizei height,
                GLenum format, GLenum type, GLvoid * pixels)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_ReadPixels(ctx->Exec, (x, y, width, height, format, type, pixels));
}

static GLint GLAPIENTRY
exec_RenderMode(GLenum mode)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   return CALL_RenderMode(ctx->Exec, (mode));
}

static void GLAPIENTRY
exec_FeedbackBuffer(GLsizei size, GLenum type, GLfloat * buffer)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_FeedbackBuffer(ctx->Exec, (size, type, buffer));
}

static void GLAPIENTRY
exec_SelectBuffer(GLsizei size, GLuint * buffer)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_SelectBuffer(ctx->Exec, (size, buffer));
}

static GLboolean GLAPIENTRY
exec_AreTexturesResident(GLsizei n, const GLuint * texName,
                         GLboolean * residences)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   return CALL_AreTexturesResident(ctx->Exec, (n, texName, residences));
}

static void GLAPIENTRY
exec_ColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *ptr)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_ColorPointer(ctx->Exec, (size, type, stride, ptr));
}

static void GLAPIENTRY
exec_DeleteTextures(GLsizei n, const GLuint * texName)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_DeleteTextures(ctx->Exec, (n, texName));
}

static void GLAPIENTRY
exec_DisableClientState(GLenum cap)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_DisableClientState(ctx->Exec, (cap));
}

static void GLAPIENTRY
exec_EdgeFlagPointer(GLsizei stride, const GLvoid * vptr)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_EdgeFlagPointer(ctx->Exec, (stride, vptr));
}

static void GLAPIENTRY
exec_EnableClientState(GLenum cap)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_EnableClientState(ctx->Exec, (cap));
}

static void GLAPIENTRY
exec_GenTextures(GLsizei n, GLuint * texName)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_GenTextures(ctx->Exec, (n, texName));
}

static void GLAPIENTRY
exec_GetPointerv(GLenum pname, GLvoid **params)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_GetPointerv(ctx->Exec, (pname, params));
}

static void GLAPIENTRY
exec_IndexPointer(GLenum type, GLsizei stride, const GLvoid *ptr)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_IndexPointer(ctx->Exec, (type, stride, ptr));
}

static void GLAPIENTRY
exec_InterleavedArrays(GLenum format, GLsizei stride, const GLvoid * pointer)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_InterleavedArrays(ctx->Exec, (format, stride, pointer));
}

static GLboolean GLAPIENTRY
exec_IsTexture(GLuint texture)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   return CALL_IsTexture(ctx->Exec, (texture));
}

static void GLAPIENTRY
exec_NormalPointer(GLenum type, GLsizei stride, const GLvoid *ptr)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_NormalPointer(ctx->Exec, (type, stride, ptr));
}

static void GLAPIENTRY
exec_PopClientAttrib(void)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_PopClientAttrib(ctx->Exec, ());
}

static void GLAPIENTRY
exec_PushClientAttrib(GLbitfield mask)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_PushClientAttrib(ctx->Exec, (mask));
}

static void GLAPIENTRY
exec_TexCoordPointer(GLint size, GLenum type, GLsizei stride,
                     const GLvoid *ptr)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_TexCoordPointer(ctx->Exec, (size, type, stride, ptr));
}

static void GLAPIENTRY
exec_GetCompressedTexImageARB(GLenum target, GLint level, GLvoid * img)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_GetCompressedTexImageARB(ctx->Exec, (target, level, img));
}

static void GLAPIENTRY
exec_VertexPointer(GLint size, GLenum type, GLsizei stride,
                   const GLvoid *ptr)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_VertexPointer(ctx->Exec, (size, type, stride, ptr));
}

static void GLAPIENTRY
exec_CopyConvolutionFilter1D(GLenum target, GLenum internalFormat,
                             GLint x, GLint y, GLsizei width)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_CopyConvolutionFilter1D(ctx->Exec,
                                (target, internalFormat, x, y, width));
}

static void GLAPIENTRY
exec_CopyConvolutionFilter2D(GLenum target, GLenum internalFormat,
                             GLint x, GLint y, GLsizei width, GLsizei height)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_CopyConvolutionFilter2D(ctx->Exec,
                                (target, internalFormat, x, y, width,
                                 height));
}

static void GLAPIENTRY
exec_GetColorTable(GLenum target, GLenum format, GLenum type, GLvoid * data)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_GetColorTable(ctx->Exec, (target, format, type, data));
}

static void GLAPIENTRY
exec_GetColorTableParameterfv(GLenum target, GLenum pname, GLfloat *params)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_GetColorTableParameterfv(ctx->Exec, (target, pname, params));
}

static void GLAPIENTRY
exec_GetColorTableParameteriv(GLenum target, GLenum pname, GLint *params)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_GetColorTableParameteriv(ctx->Exec, (target, pname, params));
}

static void GLAPIENTRY
exec_GetConvolutionFilter(GLenum target, GLenum format, GLenum type,
                          GLvoid * image)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_GetConvolutionFilter(ctx->Exec, (target, format, type, image));
}

static void GLAPIENTRY
exec_GetConvolutionParameterfv(GLenum target, GLenum pname, GLfloat *params)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_GetConvolutionParameterfv(ctx->Exec, (target, pname, params));
}

static void GLAPIENTRY
exec_GetConvolutionParameteriv(GLenum target, GLenum pname, GLint *params)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_GetConvolutionParameteriv(ctx->Exec, (target, pname, params));
}

static void GLAPIENTRY
exec_GetHistogram(GLenum target, GLboolean reset, GLenum format,
                  GLenum type, GLvoid *values)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_GetHistogram(ctx->Exec, (target, reset, format, type, values));
}

static void GLAPIENTRY
exec_GetHistogramParameterfv(GLenum target, GLenum pname, GLfloat *params)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_GetHistogramParameterfv(ctx->Exec, (target, pname, params));
}

static void GLAPIENTRY
exec_GetHistogramParameteriv(GLenum target, GLenum pname, GLint *params)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_GetHistogramParameteriv(ctx->Exec, (target, pname, params));
}

static void GLAPIENTRY
exec_GetMinmax(GLenum target, GLboolean reset, GLenum format,
               GLenum type, GLvoid *values)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_GetMinmax(ctx->Exec, (target, reset, format, type, values));
}

static void GLAPIENTRY
exec_GetMinmaxParameterfv(GLenum target, GLenum pname, GLfloat *params)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_GetMinmaxParameterfv(ctx->Exec, (target, pname, params));
}

static void GLAPIENTRY
exec_GetMinmaxParameteriv(GLenum target, GLenum pname, GLint *params)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_GetMinmaxParameteriv(ctx->Exec, (target, pname, params));
}

static void GLAPIENTRY
exec_GetSeparableFilter(GLenum target, GLenum format, GLenum type,
                        GLvoid *row, GLvoid *column, GLvoid *span)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_GetSeparableFilter(ctx->Exec,
                           (target, format, type, row, column, span));
}

static void GLAPIENTRY
exec_SeparableFilter2D(GLenum target, GLenum internalFormat,
                       GLsizei width, GLsizei height, GLenum format,
                       GLenum type, const GLvoid *row, const GLvoid *column)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_SeparableFilter2D(ctx->Exec,
                          (target, internalFormat, width, height, format,
                           type, row, column));
}

static void GLAPIENTRY
exec_ColorPointerEXT(GLint size, GLenum type, GLsizei stride,
                     GLsizei count, const GLvoid *ptr)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_ColorPointerEXT(ctx->Exec, (size, type, stride, count, ptr));
}

static void GLAPIENTRY
exec_EdgeFlagPointerEXT(GLsizei stride, GLsizei count, const GLboolean *ptr)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_EdgeFlagPointerEXT(ctx->Exec, (stride, count, ptr));
}

static void GLAPIENTRY
exec_IndexPointerEXT(GLenum type, GLsizei stride, GLsizei count,
                     const GLvoid *ptr)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_IndexPointerEXT(ctx->Exec, (type, stride, count, ptr));
}

static void GLAPIENTRY
exec_NormalPointerEXT(GLenum type, GLsizei stride, GLsizei count,
                      const GLvoid *ptr)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_NormalPointerEXT(ctx->Exec, (type, stride, count, ptr));
}

static void GLAPIENTRY
exec_TexCoordPointerEXT(GLint size, GLenum type, GLsizei stride,
                        GLsizei count, const GLvoid *ptr)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_TexCoordPointerEXT(ctx->Exec, (size, type, stride, count, ptr));
}

static void GLAPIENTRY
exec_VertexPointerEXT(GLint size, GLenum type, GLsizei stride,
                      GLsizei count, const GLvoid *ptr)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_VertexPointerEXT(ctx->Exec, (size, type, stride, count, ptr));
}

static void GLAPIENTRY
exec_LockArraysEXT(GLint first, GLsizei count)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_LockArraysEXT(ctx->Exec, (first, count));
}

static void GLAPIENTRY
exec_UnlockArraysEXT(void)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_UnlockArraysEXT(ctx->Exec, ());
}

static void GLAPIENTRY
exec_ClientActiveTextureARB(GLenum target)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_ClientActiveTextureARB(ctx->Exec, (target));
}

static void GLAPIENTRY
exec_SecondaryColorPointerEXT(GLint size, GLenum type,
                              GLsizei stride, const GLvoid *ptr)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_SecondaryColorPointerEXT(ctx->Exec, (size, type, stride, ptr));
}

static void GLAPIENTRY
exec_FogCoordPointerEXT(GLenum type, GLsizei stride, const GLvoid *ptr)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_FogCoordPointerEXT(ctx->Exec, (type, stride, ptr));
}

/* GL_EXT_multi_draw_arrays */
static void GLAPIENTRY
exec_MultiDrawArraysEXT(GLenum mode, const GLint *first,
                        const GLsizei *count, GLsizei primcount)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_MultiDrawArraysEXT(ctx->Exec, (mode, first, count, primcount));
}

/* GL_IBM_multimode_draw_arrays */
static void GLAPIENTRY
exec_MultiModeDrawArraysIBM(const GLenum * mode, const GLint * first,
                            const GLsizei * count, GLsizei primcount,
                            GLint modestride)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_MultiModeDrawArraysIBM(ctx->Exec,
                               (mode, first, count, primcount, modestride));
}

/* GL_IBM_multimode_draw_arrays */
static void GLAPIENTRY
exec_MultiModeDrawElementsIBM(const GLenum * mode,
                              const GLsizei * count,
                              GLenum type,
                              const GLvoid * const *indices,
                              GLsizei primcount, GLint modestride)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_MultiModeDrawElementsIBM(ctx->Exec,
                                 (mode, count, type, indices, primcount,
                                  modestride));
}



/**
 * Setup the given dispatch table to point to Mesa's display list
 * building functions.
 *
 * This does not include any of the tnl functions - they are
 * initialized from _mesa_init_api_defaults and from the active vtxfmt
 * struct.
 */
struct _glapi_table *
_mesa_create_save_table(void)
{
   struct _glapi_table *table;

   table = _mesa_alloc_dispatch_table(_gloffset_COUNT);
   if (table == NULL)
      return NULL;

   _mesa_loopback_init_api_table(table);

   /* GL 1.0 */
   SET_Accum(table, save_Accum);
   SET_AlphaFunc(table, save_AlphaFunc);
   SET_Bitmap(table, save_Bitmap);
   SET_BlendFunc(table, save_BlendFunc);
   SET_CallList(table, save_CallList);
   SET_CallLists(table, save_CallLists);
   SET_Clear(table, save_Clear);
   SET_ClearAccum(table, save_ClearAccum);
   SET_ClearColor(table, save_ClearColor);
   SET_ClearDepth(table, save_ClearDepth);
   SET_ClearIndex(table, save_ClearIndex);
   SET_ClearStencil(table, save_ClearStencil);
   SET_ClipPlane(table, save_ClipPlane);
   SET_ColorMask(table, save_ColorMask);
   SET_ColorMaskIndexedEXT(table, save_ColorMaskIndexed);
   SET_ColorMaterial(table, save_ColorMaterial);
   SET_CopyPixels(table, save_CopyPixels);
   SET_CullFace(table, save_CullFace);
   SET_DeleteLists(table, _mesa_DeleteLists);
   SET_DepthFunc(table, save_DepthFunc);
   SET_DepthMask(table, save_DepthMask);
   SET_DepthRange(table, save_DepthRange);
   SET_Disable(table, save_Disable);
   SET_DisableIndexedEXT(table, save_DisableIndexed);
   SET_DrawBuffer(table, save_DrawBuffer);
   SET_DrawPixels(table, save_DrawPixels);
   SET_Enable(table, save_Enable);
   SET_EnableIndexedEXT(table, save_EnableIndexed);
   SET_EndList(table, _mesa_EndList);
   SET_EvalMesh1(table, save_EvalMesh1);
   SET_EvalMesh2(table, save_EvalMesh2);
   SET_Finish(table, exec_Finish);
   SET_Flush(table, exec_Flush);
   SET_Fogf(table, save_Fogf);
   SET_Fogfv(table, save_Fogfv);
   SET_Fogi(table, save_Fogi);
   SET_Fogiv(table, save_Fogiv);
   SET_FrontFace(table, save_FrontFace);
   SET_Frustum(table, save_Frustum);
   SET_GenLists(table, _mesa_GenLists);
   SET_GetBooleanv(table, exec_GetBooleanv);
   SET_GetClipPlane(table, exec_GetClipPlane);
   SET_GetDoublev(table, exec_GetDoublev);
   SET_GetError(table, exec_GetError);
   SET_GetFloatv(table, exec_GetFloatv);
   SET_GetIntegerv(table, exec_GetIntegerv);
   SET_GetLightfv(table, exec_GetLightfv);
   SET_GetLightiv(table, exec_GetLightiv);
   SET_GetMapdv(table, exec_GetMapdv);
   SET_GetMapfv(table, exec_GetMapfv);
   SET_GetMapiv(table, exec_GetMapiv);
   SET_GetMaterialfv(table, exec_GetMaterialfv);
   SET_GetMaterialiv(table, exec_GetMaterialiv);
   SET_GetPixelMapfv(table, exec_GetPixelMapfv);
   SET_GetPixelMapuiv(table, exec_GetPixelMapuiv);
   SET_GetPixelMapusv(table, exec_GetPixelMapusv);
   SET_GetPolygonStipple(table, exec_GetPolygonStipple);
   SET_GetString(table, exec_GetString);
   SET_GetTexEnvfv(table, exec_GetTexEnvfv);
   SET_GetTexEnviv(table, exec_GetTexEnviv);
   SET_GetTexGendv(table, exec_GetTexGendv);
   SET_GetTexGenfv(table, exec_GetTexGenfv);
   SET_GetTexGeniv(table, exec_GetTexGeniv);
   SET_GetTexImage(table, exec_GetTexImage);
   SET_GetTexLevelParameterfv(table, exec_GetTexLevelParameterfv);
   SET_GetTexLevelParameteriv(table, exec_GetTexLevelParameteriv);
   SET_GetTexParameterfv(table, exec_GetTexParameterfv);
   SET_GetTexParameteriv(table, exec_GetTexParameteriv);
   SET_Hint(table, save_Hint);
   SET_IndexMask(table, save_IndexMask);
a8871 2
   SET_IsEnabled(table, exec_IsEnabled);
   SET_IsList(table, _mesa_IsList);
a8904 2
   SET_PixelStoref(table, exec_PixelStoref);
   SET_PixelStorei(table, exec_PixelStorei);
d8943 1
a8943 2
   SET_ReadPixels(table, exec_ReadPixels);
   SET_RenderMode(table, exec_RenderMode);
a8948 2
   SET_FeedbackBuffer(table, exec_FeedbackBuffer);
   SET_SelectBuffer(table, exec_SelectBuffer);
a8973 1
   SET_AreTexturesResident(table, exec_AreTexturesResident);
a8974 1
   SET_ColorPointer(table, exec_ColorPointer);
a8978 11
   SET_DeleteTextures(table, exec_DeleteTextures);
   SET_DisableClientState(table, exec_DisableClientState);
   SET_EdgeFlagPointer(table, exec_EdgeFlagPointer);
   SET_EnableClientState(table, exec_EnableClientState);
   SET_GenTextures(table, exec_GenTextures);
   SET_GetPointerv(table, exec_GetPointerv);
   SET_IndexPointer(table, exec_IndexPointer);
   SET_InterleavedArrays(table, exec_InterleavedArrays);
   SET_IsTexture(table, exec_IsTexture);
   SET_NormalPointer(table, exec_NormalPointer);
   SET_PopClientAttrib(table, exec_PopClientAttrib);
a8979 2
   SET_PushClientAttrib(table, exec_PushClientAttrib);
   SET_TexCoordPointer(table, exec_TexCoordPointer);
a8981 1
   SET_VertexPointer(table, exec_VertexPointer);
a9011 15
   SET_CopyConvolutionFilter1D(table, exec_CopyConvolutionFilter1D);
   SET_CopyConvolutionFilter2D(table, exec_CopyConvolutionFilter2D);
   SET_GetColorTable(table, exec_GetColorTable);
   SET_GetColorTableParameterfv(table, exec_GetColorTableParameterfv);
   SET_GetColorTableParameteriv(table, exec_GetColorTableParameteriv);
   SET_GetConvolutionFilter(table, exec_GetConvolutionFilter);
   SET_GetConvolutionParameterfv(table, exec_GetConvolutionParameterfv);
   SET_GetConvolutionParameteriv(table, exec_GetConvolutionParameteriv);
   SET_GetHistogram(table, exec_GetHistogram);
   SET_GetHistogramParameterfv(table, exec_GetHistogramParameterfv);
   SET_GetHistogramParameteriv(table, exec_GetHistogramParameteriv);
   SET_GetMinmax(table, exec_GetMinmax);
   SET_GetMinmaxParameterfv(table, exec_GetMinmaxParameterfv);
   SET_GetMinmaxParameteriv(table, exec_GetMinmaxParameteriv);
   SET_GetSeparableFilter(table, exec_GetSeparableFilter);
a9015 1
   SET_SeparableFilter2D(table, exec_SeparableFilter2D);
a9035 3
   SET_GetColorTableSGI(table, exec_GetColorTable);
   SET_GetColorTableParameterfvSGI(table, exec_GetColorTableParameterfv);
   SET_GetColorTableParameterivSGI(table, exec_GetColorTableParameteriv);
a9037 8
   /* 30. GL_EXT_vertex_array */
   SET_ColorPointerEXT(table, exec_ColorPointerEXT);
   SET_EdgeFlagPointerEXT(table, exec_EdgeFlagPointerEXT);
   SET_IndexPointerEXT(table, exec_IndexPointerEXT);
   SET_NormalPointerEXT(table, exec_NormalPointerEXT);
   SET_TexCoordPointerEXT(table, exec_TexCoordPointerEXT);
   SET_VertexPointerEXT(table, exec_VertexPointerEXT);

d9044 2
a9045 15
   SET_PointParameterfEXT(table, save_PointParameterfEXT);
   SET_PointParameterfvEXT(table, save_PointParameterfvEXT);

   /* 97. GL_EXT_compiled_vertex_array */
   SET_LockArraysEXT(table, exec_LockArraysEXT);
   SET_UnlockArraysEXT(table, exec_UnlockArraysEXT);

   /* 145. GL_EXT_secondary_color */
   SET_SecondaryColorPointerEXT(table, exec_SecondaryColorPointerEXT);

   /* 148. GL_EXT_multi_draw_arrays */
   SET_MultiDrawArraysEXT(table, exec_MultiDrawArraysEXT);

   /* 149. GL_EXT_fog_coord */
   SET_FogCoordPointerEXT(table, exec_FogCoordPointerEXT);
d9048 1
a9048 4
   SET_BlendFuncSeparateEXT(table, save_BlendFuncSeparateEXT);

   /* 196. GL_MESA_resize_buffers */
   SET_ResizeBuffersMESA(table, _mesa_ResizeBuffersMESA);
d9051 16
a9066 16
   SET_WindowPos2dMESA(table, save_WindowPos2dMESA);
   SET_WindowPos2dvMESA(table, save_WindowPos2dvMESA);
   SET_WindowPos2fMESA(table, save_WindowPos2fMESA);
   SET_WindowPos2fvMESA(table, save_WindowPos2fvMESA);
   SET_WindowPos2iMESA(table, save_WindowPos2iMESA);
   SET_WindowPos2ivMESA(table, save_WindowPos2ivMESA);
   SET_WindowPos2sMESA(table, save_WindowPos2sMESA);
   SET_WindowPos2svMESA(table, save_WindowPos2svMESA);
   SET_WindowPos3dMESA(table, save_WindowPos3dMESA);
   SET_WindowPos3dvMESA(table, save_WindowPos3dvMESA);
   SET_WindowPos3fMESA(table, save_WindowPos3fMESA);
   SET_WindowPos3fvMESA(table, save_WindowPos3fvMESA);
   SET_WindowPos3iMESA(table, save_WindowPos3iMESA);
   SET_WindowPos3ivMESA(table, save_WindowPos3ivMESA);
   SET_WindowPos3sMESA(table, save_WindowPos3sMESA);
   SET_WindowPos3svMESA(table, save_WindowPos3svMESA);
a9075 5
   /* 200. GL_IBM_multimode_draw_arrays */
   SET_MultiModeDrawArraysIBM(table, exec_MultiModeDrawArraysIBM);
   SET_MultiModeDrawElementsIBM(table, exec_MultiModeDrawElementsIBM);

#if FEATURE_NV_vertex_program
d9081 1
a9081 26
   SET_BindProgramNV(table, save_BindProgramNV);
   SET_DeleteProgramsNV(table, _mesa_DeletePrograms);
   SET_ExecuteProgramNV(table, save_ExecuteProgramNV);
   SET_GenProgramsNV(table, _mesa_GenPrograms);
   SET_AreProgramsResidentNV(table, _mesa_AreProgramsResidentNV);
   SET_RequestResidentProgramsNV(table, save_RequestResidentProgramsNV);
   SET_GetProgramParameterfvNV(table, _mesa_GetProgramParameterfvNV);
   SET_GetProgramParameterdvNV(table, _mesa_GetProgramParameterdvNV);
   SET_GetProgramivNV(table, _mesa_GetProgramivNV);
   SET_GetProgramStringNV(table, _mesa_GetProgramStringNV);
   SET_GetTrackMatrixivNV(table, _mesa_GetTrackMatrixivNV);
   SET_GetVertexAttribdvNV(table, _mesa_GetVertexAttribdvNV);
   SET_GetVertexAttribfvNV(table, _mesa_GetVertexAttribfvNV);
   SET_GetVertexAttribivNV(table, _mesa_GetVertexAttribivNV);
   SET_GetVertexAttribPointervNV(table, _mesa_GetVertexAttribPointervNV);
   SET_IsProgramNV(table, _mesa_IsProgramARB);
   SET_LoadProgramNV(table, save_LoadProgramNV);
   SET_ProgramEnvParameter4dARB(table, save_ProgramEnvParameter4dARB);
   SET_ProgramEnvParameter4dvARB(table, save_ProgramEnvParameter4dvARB);
   SET_ProgramEnvParameter4fARB(table, save_ProgramEnvParameter4fARB);
   SET_ProgramEnvParameter4fvARB(table, save_ProgramEnvParameter4fvARB);
   SET_ProgramParameters4dvNV(table, save_ProgramParameters4dvNV);
   SET_ProgramParameters4fvNV(table, save_ProgramParameters4fvNV);
   SET_TrackMatrixNV(table, save_TrackMatrixNV);
   SET_VertexAttribPointerNV(table, _mesa_VertexAttribPointerNV);
#endif
a9087 1
#if FEATURE_ATI_fragment_shader
a9089 21
#endif

   /* 282. GL_NV_fragment_program */
#if FEATURE_NV_fragment_program
   SET_ProgramNamedParameter4fNV(table, save_ProgramNamedParameter4fNV);
   SET_ProgramNamedParameter4dNV(table, save_ProgramNamedParameter4dNV);
   SET_ProgramNamedParameter4fvNV(table, save_ProgramNamedParameter4fvNV);
   SET_ProgramNamedParameter4dvNV(table, save_ProgramNamedParameter4dvNV);
   SET_GetProgramNamedParameterfvNV(table,
                                    _mesa_GetProgramNamedParameterfvNV);
   SET_GetProgramNamedParameterdvNV(table,
                                    _mesa_GetProgramNamedParameterdvNV);
   SET_ProgramLocalParameter4dARB(table, save_ProgramLocalParameter4dARB);
   SET_ProgramLocalParameter4dvARB(table, save_ProgramLocalParameter4dvARB);
   SET_ProgramLocalParameter4fARB(table, save_ProgramLocalParameter4fARB);
   SET_ProgramLocalParameter4fvARB(table, save_ProgramLocalParameter4fvARB);
   SET_GetProgramLocalParameterdvARB(table,
                                     _mesa_GetProgramLocalParameterdvARB);
   SET_GetProgramLocalParameterfvARB(table,
                                     _mesa_GetProgramLocalParameterfvARB);
#endif
d9092 2
a9093 2
   SET_PointParameteriNV(table, save_PointParameteriNV);
   SET_PointParameterivNV(table, save_PointParameterivNV);
a9097 10
   /* 273. GL_APPLE_vertex_array_object */
   SET_BindVertexArrayAPPLE(table, _mesa_BindVertexArrayAPPLE);
   SET_DeleteVertexArraysAPPLE(table, _mesa_DeleteVertexArraysAPPLE);
   SET_GenVertexArraysAPPLE(table, _mesa_GenVertexArraysAPPLE);
   SET_IsVertexArrayAPPLE(table, _mesa_IsVertexArrayAPPLE);

   /* GL_ARB_vertex_array_object */
   SET_BindVertexArray(table, _mesa_BindVertexArray);
   SET_GenVertexArrays(table, _mesa_GenVertexArrays);

d9102 1
a9102 2
   SET_ActiveTextureARB(table, save_ActiveTextureARB);
   SET_ClientActiveTextureARB(table, exec_ClientActiveTextureARB);
d9105 4
a9108 4
   SET_LoadTransposeMatrixdARB(table, save_LoadTransposeMatrixdARB);
   SET_LoadTransposeMatrixfARB(table, save_LoadTransposeMatrixfARB);
   SET_MultTransposeMatrixdARB(table, save_MultTransposeMatrixdARB);
   SET_MultTransposeMatrixfARB(table, save_MultTransposeMatrixfARB);
d9111 1
a9111 1
   SET_SampleCoverageARB(table, save_SampleCoverageARB);
d9114 6
a9119 7
   SET_CompressedTexImage3DARB(table, save_CompressedTexImage3DARB);
   SET_CompressedTexImage2DARB(table, save_CompressedTexImage2DARB);
   SET_CompressedTexImage1DARB(table, save_CompressedTexImage1DARB);
   SET_CompressedTexSubImage3DARB(table, save_CompressedTexSubImage3DARB);
   SET_CompressedTexSubImage2DARB(table, save_CompressedTexSubImage2DARB);
   SET_CompressedTexSubImage1DARB(table, save_CompressedTexSubImage1DARB);
   SET_GetCompressedTexImageARB(table, exec_GetCompressedTexImageARB);
a9128 1
#if FEATURE_ARB_vertex_program || FEATURE_ARB_fragment_program
a9129 3
   SET_VertexAttribPointerARB(table, _mesa_VertexAttribPointerARB);
   SET_EnableVertexAttribArrayARB(table, _mesa_EnableVertexAttribArrayARB);
   SET_DisableVertexAttribArrayARB(table, _mesa_DisableVertexAttribArrayARB);
d9131 1
a9131 8
   SET_BindProgramNV(table, save_BindProgramNV);
   SET_DeleteProgramsNV(table, _mesa_DeletePrograms);
   SET_GenProgramsNV(table, _mesa_GenPrograms);
   SET_IsProgramNV(table, _mesa_IsProgramARB);
   SET_GetVertexAttribdvARB(table, _mesa_GetVertexAttribdvARB);
   SET_GetVertexAttribfvARB(table, _mesa_GetVertexAttribfvARB);
   SET_GetVertexAttribivARB(table, _mesa_GetVertexAttribivARB);
   SET_GetVertexAttribPointervNV(table, _mesa_GetVertexAttribPointervNV);
a9139 9
   SET_GetProgramEnvParameterdvARB(table, _mesa_GetProgramEnvParameterdvARB);
   SET_GetProgramEnvParameterfvARB(table, _mesa_GetProgramEnvParameterfvARB);
   SET_GetProgramLocalParameterdvARB(table,
                                     _mesa_GetProgramLocalParameterdvARB);
   SET_GetProgramLocalParameterfvARB(table,
                                     _mesa_GetProgramLocalParameterfvARB);
   SET_GetProgramivARB(table, _mesa_GetProgramivARB);
   SET_GetProgramStringARB(table, _mesa_GetProgramStringARB);
#endif
d9141 28
a9168 50
   /* ARB 28. GL_ARB_vertex_buffer_object */
#if FEATURE_ARB_vertex_buffer_object
   /* None of the extension's functions get compiled */
   SET_BindBufferARB(table, _mesa_BindBufferARB);
   SET_BufferDataARB(table, _mesa_BufferDataARB);
   SET_BufferSubDataARB(table, _mesa_BufferSubDataARB);
   SET_DeleteBuffersARB(table, _mesa_DeleteBuffersARB);
   SET_GenBuffersARB(table, _mesa_GenBuffersARB);
   SET_GetBufferParameterivARB(table, _mesa_GetBufferParameterivARB);
   SET_GetBufferPointervARB(table, _mesa_GetBufferPointervARB);
   SET_GetBufferSubDataARB(table, _mesa_GetBufferSubDataARB);
   SET_IsBufferARB(table, _mesa_IsBufferARB);
   SET_MapBufferARB(table, _mesa_MapBufferARB);
   SET_UnmapBufferARB(table, _mesa_UnmapBufferARB);
#endif

#if FEATURE_queryobj
   _mesa_init_queryobj_dispatch(table); /* glGetQuery, etc */
   SET_BeginQueryARB(table, save_BeginQueryARB);
   SET_EndQueryARB(table, save_EndQueryARB);
#endif

   SET_DrawBuffersARB(table, save_DrawBuffersARB);

#if FEATURE_EXT_framebuffer_blit
   SET_BlitFramebufferEXT(table, save_BlitFramebufferEXT);
#endif

   /* GL_ARB_shader_objects */
   _mesa_init_shader_dispatch(table); /* Plug in glCreate/Delete/Get, etc */
   SET_UseProgramObjectARB(table, save_UseProgramObjectARB);
   SET_Uniform1fARB(table, save_Uniform1fARB);
   SET_Uniform2fARB(table, save_Uniform2fARB);
   SET_Uniform3fARB(table, save_Uniform3fARB);
   SET_Uniform4fARB(table, save_Uniform4fARB);
   SET_Uniform1fvARB(table, save_Uniform1fvARB);
   SET_Uniform2fvARB(table, save_Uniform2fvARB);
   SET_Uniform3fvARB(table, save_Uniform3fvARB);
   SET_Uniform4fvARB(table, save_Uniform4fvARB);
   SET_Uniform1iARB(table, save_Uniform1iARB);
   SET_Uniform2iARB(table, save_Uniform2iARB);
   SET_Uniform3iARB(table, save_Uniform3iARB);
   SET_Uniform4iARB(table, save_Uniform4iARB);
   SET_Uniform1ivARB(table, save_Uniform1ivARB);
   SET_Uniform2ivARB(table, save_Uniform2ivARB);
   SET_Uniform3ivARB(table, save_Uniform3ivARB);
   SET_Uniform4ivARB(table, save_Uniform4ivARB);
   SET_UniformMatrix2fvARB(table, save_UniformMatrix2fvARB);
   SET_UniformMatrix3fvARB(table, save_UniformMatrix3fvARB);
   SET_UniformMatrix4fvARB(table, save_UniformMatrix4fvARB);
a9175 6
   /* ARB 30/31/32. GL_ARB_shader_objects, GL_ARB_vertex/fragment_shader */
   SET_BindAttribLocationARB(table, exec_BindAttribLocationARB);
   SET_GetAttribLocationARB(table, exec_GetAttribLocationARB);
   SET_GetUniformLocationARB(table, exec_GetUniformLocationARB);
   /* XXX additional functions need to be implemented here! */

d9177 1
a9177 1
   SET_BlendEquationSeparateEXT(table, save_BlendEquationSeparateEXT);
a9179 1
#if FEATURE_ARB_vertex_program || FEATURE_ARB_fragment_program
a9181 10
#endif

   /* ARB 50. GL_ARB_map_buffer_range */
#if FEATURE_ARB_map_buffer_range
   SET_MapBufferRange(table, _mesa_MapBufferRange); /* no dlist save */
   SET_FlushMappedBufferRange(table, _mesa_FlushMappedBufferRange); /* no dl */
#endif

   /* ARB 59. GL_ARB_copy_buffer */
   SET_CopyBufferSubData(table, _mesa_CopyBufferSubData); /* no dlist save */
d9184 1
a9184 8
   SET_ProvokingVertexEXT(table, save_ProvokingVertexEXT);

   /* 371. GL_APPLE_object_purgeable */
#if FEATURE_APPLE_object_purgeable
   SET_ObjectPurgeableAPPLE(table, _mesa_ObjectPurgeableAPPLE);
   SET_ObjectUnpurgeableAPPLE(table, _mesa_ObjectUnpurgeableAPPLE);
   SET_GetObjectParameterivAPPLE(table, _mesa_GetObjectParameterivAPPLE);
#endif
d9189 2
a9190 4
   SET_TexParameterIivEXT(table, save_TexParameterIiv);
   SET_TexParameterIuivEXT(table, save_TexParameterIuiv);
   SET_GetTexParameterIivEXT(table, exec_GetTexParameterIiv);
   SET_GetTexParameterIuivEXT(table, exec_GetTexParameterIuiv);
a9196 1
   SET_ClampColorARB(table, save_ClampColorARB);
d9224 3
a9226 4
#if FEATURE_EXT_transform_feedback
   SET_BeginTransformFeedbackEXT(table, save_BeginTransformFeedback);
   SET_EndTransformFeedbackEXT(table, save_EndTransformFeedback);
   SET_TransformFeedbackVaryingsEXT(table, save_TransformFeedbackVaryings);
d9231 7
a9237 1
#endif
d9240 1
a9240 1
   SET_VertexAttribDivisorARB(table, save_VertexAttribDivisor);
a9244 2
   /* GL_ARB_sampler_objects */
   _mesa_init_sampler_object_dispatch(table); /* plug in Gen/Get/etc functions */
d9260 2
a9261 2
   SET_ProgramParameteriARB(table, save_ProgramParameteri);
   SET_FramebufferTextureARB(table, save_FramebufferTexture);
d9265 2
a9266 2
   SET_BeginConditionalRenderNV(table, save_BeginConditionalRender);
   SET_EndConditionalRenderNV(table, save_EndConditionalRender);
a9268 1
   _mesa_init_sync_dispatch(table);
d9271 14
a9284 1
   return table;
d9577 2
a9578 2
void
_mesa_save_vtxfmt_init(GLvertexformat * vfmt)
d9580 1
a9580 1
   _MESA_INIT_ARRAYELT_VTXFMT(vfmt, _ae_);
d9584 2
a9585 1
   _MESA_INIT_DLIST_VTXFMT(vfmt, save_);
d9594 6
a9599 1
   _MESA_INIT_EVAL_VTXFMT(vfmt, save_);
a9631 8
   vfmt->VertexAttrib1fNV = save_VertexAttrib1fNV;
   vfmt->VertexAttrib1fvNV = save_VertexAttrib1fvNV;
   vfmt->VertexAttrib2fNV = save_VertexAttrib2fNV;
   vfmt->VertexAttrib2fvNV = save_VertexAttrib2fvNV;
   vfmt->VertexAttrib3fNV = save_VertexAttrib3fNV;
   vfmt->VertexAttrib3fvNV = save_VertexAttrib3fvNV;
   vfmt->VertexAttrib4fNV = save_VertexAttrib4fNV;
   vfmt->VertexAttrib4fvNV = save_VertexAttrib4fvNV;
a9639 18

   vfmt->Rectf = save_Rectf;

   /* The driver is required to implement these as
    * 1) They can probably do a better job.
    * 2) A lot of new mechanisms would have to be added to this module
    *     to support it.  That code would probably never get used,
    *     because of (1).
    */
#if 0
   vfmt->DrawArrays = 0;
   vfmt->DrawElements = 0;
   vfmt->DrawRangeElements = 0;
   vfmt->MultiDrawElemementsEXT = 0;
   vfmt->DrawElementsBaseVertex = 0;
   vfmt->DrawRangeElementsBaseVertex = 0;
   vfmt->MultiDrawElemementsBaseVertex = 0;
#endif
a9651 17
void _mesa_init_dlist_dispatch(struct _glapi_table *disp)
{
   SET_CallList(disp, _mesa_CallList);
   SET_CallLists(disp, _mesa_CallLists);

   SET_DeleteLists(disp, _mesa_DeleteLists);
   SET_EndList(disp, _mesa_EndList);
   SET_GenLists(disp, _mesa_GenLists);
   SET_IsList(disp, _mesa_IsList);
   SET_ListBase(disp, _mesa_ListBase);
   SET_NewList(disp, _mesa_NewList);
}


#endif /* FEATURE_dlist */


d9679 1
a9679 3
#if FEATURE_dlist
   _mesa_save_vtxfmt_init(&ctx->ListState.ListVtxfmt);
#endif
@


1.6
log
@Merge Mesa 7.10.3
@
text
@d57 1
d59 3
d195 6
d394 3
d426 4
d441 25
d507 11
d877 6
a882 2
 * Wrapper for _mesa_unpack_image() that handles pixel buffer objects.
 * If we run out of memory, GL_OUT_OF_MEMORY will be recorded.
d890 9
d901 7
a907 2
      GLvoid *image = _mesa_unpack_image(dimensions, width, height, depth,
                                         format, type, pixels, unpack);
d913 2
a914 2
   else if (_mesa_validate_pbo_access(dimensions, unpack, width, height, depth,
                                      format, type, pixels)) {
d928 5
a932 2
      image = _mesa_unpack_image(dimensions, width, height, depth,
                                 format, type, src, unpack);
d942 1
d944 1
a947 1

d1133 2
a1134 1
      n[7].data = _mesa_unpack_bitmap(width, height, pixels, &ctx->Unpack);
d1222 76
d4522 18
a4556 1
      GLvoid *image;
d4558 1
a4558 7
      /* make copy of image */
      image = malloc(imageSize);
      if (!image) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCompressedTexImage1DARB");
         return;
      }
      memcpy(image, data, imageSize);
d4567 1
a4567 4
         n[7].data = image;
      }
      else if (image) {
         free(image);
a4592 1
      GLvoid *image;
d4594 1
a4594 7
      /* make copy of image */
      image = malloc(imageSize);
      if (!image) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCompressedTexImage2DARB");
         return;
      }
      memcpy(image, data, imageSize);
d4604 1
a4604 4
         n[8].data = image;
      }
      else if (image) {
         free(image);
a4629 1
      GLvoid *image;
d4631 1
a4631 7
      /* make copy of image */
      image = malloc(imageSize);
      if (!image) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCompressedTexImage3DARB");
         return;
      }
      memcpy(image, data, imageSize);
d4642 1
a4642 4
         n[9].data = image;
      }
      else if (image) {
         free(image);
a4659 2
   GLvoid *image;

a4662 7
   /* make copy of image */
   image = malloc(imageSize);
   if (!image) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCompressedTexSubImage1DARB");
      return;
   }
   memcpy(image, data, imageSize);
d4671 1
a4671 4
      n[7].data = image;
   }
   else if (image) {
      free(image);
a4687 2
   GLvoid *image;

a4690 7
   /* make copy of image */
   image = malloc(imageSize);
   if (!image) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCompressedTexSubImage2DARB");
      return;
   }
   memcpy(image, data, imageSize);
d4701 1
a4701 4
      n[9].data = image;
   }
   else if (image) {
      free(image);
a4717 2
   GLvoid *image;

a4720 7
   /* make copy of image */
   image = malloc(imageSize);
   if (!image) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCompressedTexSubImage3DARB");
      return;
   }
   memcpy(image, data, imageSize);
d4733 1
a4733 4
      n[11].data = image;
   }
   else if (image) {
      free(image);
d6274 63
d6968 16
d7113 218
d7333 49
d7511 20
a8009 6
         case OPCODE_BEGIN_TRANSFORM_FEEDBACK:
            CALL_BeginTransformFeedbackEXT(ctx->Exec, (n[1].e));
            break;
         case OPCODE_END_TRANSFORM_FEEDBACK:
            CALL_EndTransformFeedbackEXT(ctx->Exec, ());
            break;
d8401 4
d8551 105
a8868 2
   /* VERY IMPORTANT:  Save the CompileFlag status, turn it off, */
   /* execute the display list, and restore the CompileFlag. */
d8878 2
a8879 1
/*     mesa_print_display_list( list ); */
d8881 3
d10122 4
d10208 1
a10210 6
   SET_GenQueriesARB(table, _mesa_GenQueriesARB);
   SET_DeleteQueriesARB(table, _mesa_DeleteQueriesARB);
   SET_IsQueryARB(table, _mesa_IsQueryARB);
   SET_GetQueryivARB(table, _mesa_GetQueryivARB);
   SET_GetQueryObjectivARB(table, _mesa_GetQueryObjectivARB);
   SET_GetQueryObjectuivARB(table, _mesa_GetQueryObjectuivARB);
d10212 1
d10220 1
a10271 6
   /* 352. GL_EXT_transform_feedback */
#if FEATURE_EXT_transform_feedback
   SET_BeginTransformFeedbackEXT(table, save_BeginTransformFeedback);
   SET_EndTransformFeedbackEXT(table, save_EndTransformFeedback);
#endif

d10279 1
d10294 4
a10298 1
#if 0
d10303 1
a10312 4
   (void) save_ClearBufferiv;
   (void) save_ClearBufferuiv;
   (void) save_ClearBufferfv;
   (void) save_ClearBufferfi;
d10322 45
@


1.5
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d35 1
d37 3
a54 1
#include "dlist.h"
d56 1
d62 1
a62 1
#include "shader/arbprogram.h"
d65 1
a65 4
#include "shader/nvprogram.h"
#endif
#if FEATURE_ATI_fragment_shader
#include "shader/atifragshader.h"
d81 3
a83 3
   void (*Execute)( GLcontext *ctx, void *data );
   void (*Destroy)( GLcontext *ctx, void *data );
   void (*Print)( GLcontext *ctx, void *data );
d374 10
d410 14
d510 1
a510 1
lookup_list(GLcontext *ctx, GLuint list)
d527 1
a527 1
ext_opcode_destroy(GLcontext *ctx, Node *node)
d539 1
a539 1
ext_opcode_execute(GLcontext *ctx, Node *node)
d551 1
a551 1
ext_opcode_print(GLcontext *ctx, Node *node)
d566 1
a566 1
_mesa_delete_list(GLcontext *ctx, struct gl_display_list *dlist)
d698 4
d744 1
a744 1
destroy_list(GLcontext *ctx, GLuint list)
d828 1
a828 1
unpack_image(GLcontext *ctx, GLuint dimensions,
d880 1
a880 1
dlist_alloc(GLcontext *ctx, OpCode opcode, GLuint bytes)
d931 1
a931 1
_mesa_dlist_alloc(GLcontext *ctx, GLuint opcode, GLuint bytes)
d952 1
a952 1
_mesa_dlist_alloc_opcode(GLcontext *ctx,
d954 3
a956 3
                         void (*execute) (GLcontext *, void *),
                         void (*destroy) (GLcontext *, void *),
                         void (*print) (GLcontext *, void *))
d981 1
a981 1
alloc_instruction(GLcontext *ctx, OpCode opcode, GLuint nparams)
d1146 1
a1146 1
static void invalidate_saved_current_state( GLcontext *ctx )
a1564 1
          pname == GL_POST_COLOR_MATRIX_COLOR_TABLE_SGI ||
a1592 1
          pname == GL_POST_COLOR_MATRIX_COLOR_TABLE_SGI ||
d4787 1
a4787 1
                            GLuint num, const GLdouble *params)
d4789 1
a4789 1
   GLuint i;
d4798 1
a4798 1
                            GLuint num, const GLfloat *params)
d4800 1
a4800 1
   GLuint i;
d5258 1
a5258 1
static void
d5279 1
a5279 1
static void
d5301 1
a5301 1
static void
d5324 1
a5324 1
static void
d5349 1
a5349 1
static void
d5370 1
a5370 1
static void
d5392 1
a5392 1
static void
d5415 1
a5415 1
static void
d6081 8
a6091 1

d6141 30
d6483 143
d6800 131
d6940 1
a6940 1
save_error(GLcontext *ctx, GLenum error, const char *s)
d6955 1
a6955 1
_mesa_compile_error(GLcontext *ctx, GLenum error, const char *s)
d6960 1
a6960 1
      _mesa_error(ctx, error, s);
d6968 1
a6968 1
islist(GLcontext *ctx, GLuint list)
d6992 1
a6992 1
execute_list(GLcontext *ctx, GLuint list)
d7027 1
a7027 1
            _mesa_error(ctx, n[1].e, (const char *) n[2].data);
d7540 6
d7818 6
d7874 26
a7899 1

d8054 29
d8092 1
a8092 1
               sprintf(msg, "Error in execute_list: opcode=%d",
d8094 1
a8094 1
               _mesa_problem(ctx, msg);
d9069 2
a9070 2
exec_MultiDrawArraysEXT(GLenum mode, GLint * first,
                        GLsizei * count, GLsizei primcount)
d9114 2
a9115 2
void
_mesa_init_save_table(struct _glapi_table *table)
d9117 6
d9590 3
a9592 3
   SET_GetVertexAttribdvNV(table, _mesa_GetVertexAttribdvNV);
   SET_GetVertexAttribfvNV(table, _mesa_GetVertexAttribfvNV);
   SET_GetVertexAttribivNV(table, _mesa_GetVertexAttribivNV);
d9675 1
d9681 1
a9681 1
   /* GL_EXT_gpu_program_parmaeters */
d9696 6
d9711 12
d9729 8
d9742 8
d9751 2
d9769 1
a9769 1
print_list(GLcontext *ctx, GLuint list)
d10161 1
a10161 1
_mesa_init_display_list(GLcontext *ctx)
d10191 1
a10191 1
_mesa_free_display_list_data(GLcontext *ctx)
@


1.4
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d3 1
a3 1
 * Version:  7.1
d5 2
a6 1
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
d37 1
a37 3
#include "attrib.h"
#include "blend.h"
#include "buffers.h"
a41 2
#include "clip.h"
#include "colortab.h"
a42 2
#include "convolve.h"
#include "depth.h"
a43 1
#include "enable.h"
a45 2
#include "extensions.h"
#include "feedback.h"
a46 1
#include "get.h"
a48 1
#include "histogram.h"
a50 1
#include "lines.h"
a52 4
#include "matrix.h"
#include "pixel.h"
#include "points.h"
#include "polygon.h"
a53 2
#include "state.h"
#include "texobj.h"
a54 1
#include "texstate.h"
a58 1
#include "shader/program.h"
a61 1
#include "shader/program.h"
a67 1
#include "math/m_xform.h"
d69 28
a96 1
#include "glapi/dispatch.h"
d198 4
d204 1
d229 1
d233 1
d336 2
d345 28
d396 3
d419 1
a419 1
union node
d436 3
d454 4
d470 2
a471 2
static struct mesa_display_list *
make_list(GLuint list, GLuint count)
d473 4
a476 4
   struct mesa_display_list *dlist = CALLOC_STRUCT(mesa_display_list);
   dlist->id = list;
   dlist->node = (Node *) _mesa_malloc(sizeof(Node) * count);
   dlist->node[0].opcode = OPCODE_END_OF_LIST;
d484 1
a484 1
static INLINE struct mesa_display_list *
d487 1
a487 1
   return (struct mesa_display_list *)
d492 43
d541 1
a541 1
_mesa_delete_list(GLcontext *ctx, struct mesa_display_list *dlist)
d546 1
a546 1
   n = block = dlist->node;
d550 1
d553 2
a554 5

      GLint i = (GLint) n[0].opcode - (GLint) OPCODE_EXT_0;
      if (i >= 0 && i < (GLint) ctx->ListExt.NumOpcodes) {
         ctx->ListExt.Opcode[i].Destroy(ctx, &n[1]);
         n += ctx->ListExt.Opcode[i].Size;
d557 1
a557 1
         switch (n[0].opcode) {
d560 1
a560 1
            _mesa_free(n[6].data);
d564 1
a564 1
            _mesa_free(n[10].data);
d568 1
a568 1
            _mesa_free(n[5].data);
d572 1
a572 1
            _mesa_free(n[7].data);
d576 1
a576 1
            _mesa_free(n[6].data);
d580 1
a580 1
            _mesa_free(n[6].data);
d584 1
a584 1
            _mesa_free(n[6].data);
d588 1
a588 1
            _mesa_free(n[7].data);
d592 1
a592 1
            _mesa_free(n[1].data);
d596 1
a596 1
            _mesa_free(n[8].data);
d600 1
a600 1
            _mesa_free(n[9].data);
d604 1
a604 1
            _mesa_free(n[10].data);
d608 1
a608 1
            _mesa_free(n[7].data);
d612 1
a612 1
            _mesa_free(n[9].data);
d616 1
a616 1
            _mesa_free(n[11].data);
d620 1
a620 1
            _mesa_free(n[7].data);
d624 1
a624 1
            _mesa_free(n[8].data);
d628 1
a628 1
            _mesa_free(n[9].data);
d632 1
a632 1
            _mesa_free(n[7].data);
d636 1
a636 1
            _mesa_free(n[9].data);
d640 1
a640 1
            _mesa_free(n[11].data);
d645 1
a645 1
            _mesa_free(n[4].data);      /* program string */
d649 1
a649 1
            _mesa_free(n[2].data);      /* array of program ids */
d655 1
a655 1
            _mesa_free(n[3].data);      /* parameter name */
d661 1
a661 1
            _mesa_free(n[4].data);      /* program string */
d665 24
d691 1
a691 1
            _mesa_free(block);
d695 1
a695 1
            _mesa_free(block);
d706 1
a706 1
   _mesa_free(dlist);
d717 1
a717 1
   struct mesa_display_list *dlist;
d796 1
a796 1
 * \todo This won't suffice when the PBO is really in VRAM/GPU memory.
d799 2
a800 1
unpack_image(GLuint dimensions, GLsizei width, GLsizei height, GLsizei depth,
d804 1
a804 1
   if (unpack->BufferObj->Name == 0) {
d806 32
a837 9
      return _mesa_unpack_image(dimensions, width, height, depth, format,
                                type, pixels, unpack);
   }
   else
      if (_mesa_validate_pbo_access
          (dimensions, unpack, width, height, depth, format, type, pixels)) {
      const GLubyte *src = ADD_POINTERS(unpack->BufferObj->Data, pixels);
      return _mesa_unpack_image(dimensions, width, height, depth, format,
                                type, src, unpack);
d845 1
a845 1
 * Allocate space for a display list instruction.
d847 2
a848 3
 * \param size   instruction size in bytes, not counting opcode.
 * \return pointer to the usable data area (not including the internal
 *         opcode).
d850 2
a851 2
void *
_mesa_alloc_instruction(GLcontext *ctx, GLuint opcode, GLuint bytes)
d872 1
a872 1
      newblock = (Node *) _mesa_malloc(sizeof(Node) * BLOCK_SIZE);
d885 6
a890 1
   n[0].opcode = (OpCode) opcode;
d892 17
a908 1
   return (void *) (n + 1);     /* return ptr to node following opcode */
d923 9
a931 9
_mesa_alloc_opcode(GLcontext *ctx,
                   GLuint size,
                   void (*execute) (GLcontext *, void *),
                   void (*destroy) (GLcontext *, void *),
                   void (*print) (GLcontext *, void *))
{
   if (ctx->ListExt.NumOpcodes < MAX_DLIST_EXT_OPCODES) {
      const GLuint i = ctx->ListExt.NumOpcodes++;
      ctx->ListExt.Opcode[i].Size =
d933 3
a935 3
      ctx->ListExt.Opcode[i].Execute = execute;
      ctx->ListExt.Opcode[i].Destroy = destroy;
      ctx->ListExt.Opcode[i].Print = print;
a941 1

d943 7
a949 5
 * Allocate display list instruction.  Returns Node ptr to where the opcode
 * is stored.
 *   - nParams is the number of function parameters
 *   - return value a pointer to sizeof(Node) before the actual
 *     usable data area.
d951 5
a955 2
#define ALLOC_INSTRUCTION(CTX, OPCODE, NPARAMS) \
    ((Node *)_mesa_alloc_instruction(CTX, OPCODE, (NPARAMS)*sizeof(Node)) - 1)
d968 1
a968 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_ACCUM, 2);
d985 1
a985 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_ALPHA_FUNC, 2);
d1002 1
a1002 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_BIND_TEXTURE, 2);
a1018 1
   GLvoid *image = _mesa_unpack_bitmap(width, height, pixels, &ctx->Unpack);
d1021 1
a1021 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_BITMAP, 7);
d1029 1
a1029 4
      n[7].data = image;
   }
   else if (image) {
      _mesa_free(image);
d1044 1
a1044 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_BLEND_EQUATION, 1);
d1060 1
a1060 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_BLEND_EQUATION_SEPARATE, 2);
d1078 1
a1078 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_BLEND_FUNC_SEPARATE, 4);
d1105 1
a1105 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_BLEND_COLOR, 4);
d1117 14
d1132 2
a1133 2
void GLAPIENTRY
_mesa_save_CallList(GLuint list)
d1139 1
a1139 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_CALL_LIST, 1);
d1144 2
a1145 1
   /* After this, we don't know what begin/end state we're in:
d1147 1
a1147 1
   ctx->Driver.CurrentSavePrimitive = PRIM_UNKNOWN;
d1150 1
a1150 1
      CALL_CallList(ctx->Exec, (list));
d1155 2
a1156 2
void GLAPIENTRY
_mesa_save_CallLists(GLsizei n, GLenum type, const GLvoid * lists)
d1181 1
a1181 1
   for (i = 0; i < n; i++) {
d1183 1
a1183 1
      Node *n = ALLOC_INSTRUCTION(ctx, OPCODE_CALL_LIST_OFFSET, 2);
d1190 2
a1191 1
   /* After this, we don't know what begin/end state we're in:
d1193 1
a1193 1
   ctx->Driver.CurrentSavePrimitive = PRIM_UNKNOWN;
d1196 1
a1196 1
      CALL_CallLists(ctx->Exec, (n, type, lists));
d1207 1
a1207 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_CLEAR, 1);
d1218 104
d1327 1
a1327 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_CLEAR_ACCUM, 4);
d1346 1
a1346 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_CLEAR_COLOR, 4);
d1365 1
a1365 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_CLEAR_DEPTH, 1);
d1381 1
a1381 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_CLEAR_INDEX, 1);
d1397 1
a1397 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_CLEAR_STENCIL, 1);
d1413 1
a1413 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_CLIP_PLANE, 5);
d1435 1
a1435 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_COLOR_MASK, 4);
d1449 21
d1476 1
a1476 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_COLOR_MATERIAL, 2);
a1498 2
      GLvoid *image = unpack_image(1, width, 1, 1, format, type, table,
                                   &ctx->Unpack);
d1501 1
a1501 1
      n = ALLOC_INSTRUCTION(ctx, OPCODE_COLOR_TABLE, 6);
d1508 2
a1509 4
         n[6].data = image;
      }
      else if (image) {
         _mesa_free(image);
d1529 1
a1529 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_COLOR_TABLE_PARAMETER_FV, 6);
d1558 1
a1558 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_COLOR_TABLE_PARAMETER_IV, 6);
a1584 2
   GLvoid *image = unpack_image(1, count, 1, 1, format, type, table,
                                &ctx->Unpack);
d1587 1
a1587 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_COLOR_SUB_TABLE, 6);
d1594 2
a1595 4
      n[6].data = image;
   }
   else if (image) {
      _mesa_free(image);
d1612 1
a1612 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_COPY_COLOR_SUB_TABLE, 5);
d1634 1
a1634 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_COPY_COLOR_TABLE, 5);
a1652 2
   GLvoid *image = unpack_image(1, width, 1, 1, format, type, filter,
                                &ctx->Unpack);
d1654 1
d1656 2
a1657 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_CONVOLUTION_FILTER_1D, 6);
d1664 2
a1665 4
      n[6].data = image;
   }
   else if (image) {
      _mesa_free(image);
a1679 2
   GLvoid *image = unpack_image(2, width, height, 1, format, type, filter,
                                &ctx->Unpack);
d1681 1
d1683 2
a1684 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_CONVOLUTION_FILTER_2D, 7);
d1692 2
a1693 4
      n[7].data = image;
   }
   else if (image) {
      _mesa_free(image);
d1709 1
a1709 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_CONVOLUTION_PARAMETER_I, 3);
d1727 1
a1727 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_CONVOLUTION_PARAMETER_IV, 6);
d1755 1
a1755 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_CONVOLUTION_PARAMETER_F, 3);
d1774 1
a1774 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_CONVOLUTION_PARAMETER_FV, 6);
d1802 1
a1802 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_COPY_PIXELS, 5);
d1824 1
a1824 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_COPY_TEX_IMAGE1D, 7);
d1850 1
a1850 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_COPY_TEX_IMAGE2D, 8);
d1876 1
a1876 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_COPY_TEX_SUB_IMAGE1D, 6);
d1900 1
a1900 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_COPY_TEX_SUB_IMAGE2D, 8);
d1926 1
a1926 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_COPY_TEX_SUB_IMAGE3D, 9);
d1952 1
a1952 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_CULL_FACE, 1);
d1968 1
a1968 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_DEPTH_FUNC, 1);
d1984 1
a1984 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_DEPTH_MASK, 1);
d2000 1
a2000 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_DEPTH_RANGE, 2);
d2017 1
a2017 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_DISABLE, 1);
d2028 17
d2050 1
a2050 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_DRAW_BUFFER, 1);
a2064 2
   GLvoid *image = unpack_image(2, width, height, 1, format, type,
                                pixels, &ctx->Unpack);
d2066 1
d2068 2
a2069 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_DRAW_PIXELS, 5);
d2075 2
a2076 4
      n[5].data = image;
   }
   else if (image) {
      _mesa_free(image);
d2091 1
a2091 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_ENABLE, 1);
d2103 19
a2121 1
_mesa_save_EvalMesh1(GLenum mode, GLint i1, GLint i2)
d2126 1
a2126 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_EVALMESH1, 3);
d2139 1
a2139 1
_mesa_save_EvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2)
d2144 1
a2144 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_EVALMESH2, 5);
d2166 1
a2166 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_FOG, 5);
d2183 4
a2186 1
   save_Fogfv(pname, &param);
d2201 3
d2213 1
a2213 1
      ;
d2222 4
a2225 1
   save_Fogiv(pname, &param);
d2235 1
a2235 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_FRONT_FACE, 1);
d2252 1
a2252 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_FRUSTUM, 6);
d2273 1
a2273 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_HINT, 2);
d2292 1
a2292 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_HISTOGRAM, 4);
d2311 1
a2311 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_INDEX_MASK, 1);
d2326 1
a2326 1
   (void) ALLOC_INSTRUCTION(ctx, OPCODE_INIT_NAMES, 0);
d2339 1
a2339 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_LIGHT, 6);
d2389 1
a2389 1
save_Lightf(GLenum light, GLenum pname, GLfloat params)
d2391 4
a2394 1
   save_Lightfv(light, pname, &params);
d2440 4
a2443 1
   save_Lightiv(light, pname, &param);
d2453 1
a2453 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_LIGHT_MODEL, 5);
d2470 4
a2473 1
   save_LightModelfv(pname, &param);
d2492 3
d2498 1
a2498 1
      ;
d2507 4
a2510 1
   save_LightModeliv(pname, &param);
d2520 1
a2520 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_LINE_STIPPLE, 2);
d2537 1
a2537 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_LINE_WIDTH, 1);
d2553 1
a2553 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_LIST_BASE, 1);
d2568 1
a2568 1
   (void) ALLOC_INSTRUCTION(ctx, OPCODE_LOAD_IDENTITY, 0);
d2581 1
a2581 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_LOAD_MATRIX, 16);
d2612 1
a2612 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_LOAD_NAME, 1);
d2628 1
a2628 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_LOGIC_OP, 1);
d2645 1
a2645 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_MAP1, 6);
d2667 1
a2667 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_MAP1, 6);
d2692 1
a2692 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_MAP2, 10);
d2725 1
a2725 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_MAP2, 10);
d2754 1
a2754 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_MAPGRID1, 3);
d2780 1
a2780 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_MAPGRID2, 6);
d2811 1
a2811 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_MATRIX_MODE, 1);
d2828 1
a2828 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_MIN_MAX, 3);
d2846 1
a2846 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_MULT_MATRIX, 16);
d2872 1
a2872 1
save_NewList(GLuint list, GLenum mode)
d2877 1
a2877 1
   (void) list;
d2890 1
a2890 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_ORTHO, 6);
d2911 1
a2911 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_PIXEL_MAP, 3);
d2915 2
a2916 2
      n[3].data = (void *) _mesa_malloc(mapsize * sizeof(GLfloat));
      MEMCPY(n[3].data, (void *) values, mapsize * sizeof(GLfloat));
d2968 1
a2968 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_PIXEL_TRANSFER, 2);
d2992 1
a2992 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_PIXEL_ZOOM, 2);
d3009 1
a3009 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_POINT_PARAMETERS, 4);
d3025 4
a3028 1
   save_PointParameterfvEXT(pname, &param);
d3034 4
a3037 2
   GLfloat p = (GLfloat) param;
   save_PointParameterfvEXT(pname, &p);
d3043 4
a3046 2
   GLfloat p = (GLfloat) param[0];
   save_PointParameterfvEXT(pname, &p);
d3056 1
a3056 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_POINT_SIZE, 1);
d3072 1
a3072 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_POLYGON_MODE, 2);
a3086 2
   GLvoid *image = unpack_image(2, 32, 32, 1, GL_COLOR_INDEX, GL_BITMAP,
                                pattern, &ctx->Unpack);
d3088 1
d3090 2
a3091 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_POLYGON_STIPPLE, 1);
d3093 2
a3094 4
      n[1].data = image; 
   }
   else if (image) {
      _mesa_free(image);
d3108 1
a3108 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_POLYGON_OFFSET, 2);
d3133 1
a3133 1
   (void) ALLOC_INSTRUCTION(ctx, OPCODE_POP_ATTRIB, 0);
d3145 1
a3145 1
   (void) ALLOC_INSTRUCTION(ctx, OPCODE_POP_MATRIX, 0);
d3157 1
a3157 1
   (void) ALLOC_INSTRUCTION(ctx, OPCODE_POP_NAME, 0);
d3174 1
a3174 1
      n = ALLOC_INSTRUCTION(ctx, OPCODE_PRIORITIZE_TEXTURE, 2);
d3192 1
a3192 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_PUSH_ATTRIB, 1);
d3207 1
a3207 1
   (void) ALLOC_INSTRUCTION(ctx, OPCODE_PUSH_MATRIX, 0);
d3220 1
a3220 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_PUSH_NAME, 1);
d3236 1
a3236 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_RASTER_POS, 4);
d3395 1
a3395 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_PASSTHROUGH, 1);
d3411 1
a3411 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_READ_BUFFER, 1);
d3427 1
a3427 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_RESET_HISTOGRAM, 1);
d3443 1
a3443 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_RESET_MIN_MAX, 1);
d3459 1
a3459 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_ROTATE, 4);
d3485 1
a3485 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_SCALE, 3);
d3510 1
a3510 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_SCISSOR, 4);
d3528 17
a3544 2
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = ALLOC_INSTRUCTION(ctx, OPCODE_SHADE_MODEL, 1);
a3547 3
   if (ctx->ExecuteFlag) {
      CALL_ShadeModel(ctx->Exec, (mode));
   }
d3557 1
a3557 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_STENCIL_FUNC, 3);
d3575 1
a3575 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_STENCIL_MASK, 1);
d3591 1
a3591 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_STENCIL_OP, 3);
d3609 1
a3609 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_STENCIL_FUNC_SEPARATE, 4);
d3630 1
a3630 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_STENCIL_FUNC_SEPARATE, 4);
d3638 1
a3638 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_STENCIL_FUNC_SEPARATE, 4);
d3658 1
a3658 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_STENCIL_MASK_SEPARATE, 2);
d3675 1
a3675 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_STENCIL_OP_SEPARATE, 4);
d3694 1
a3694 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_TEXENV, 6);
d3718 4
a3721 1
   save_TexEnvfv(target, pname, &param);
d3730 1
a3730 1
   p[1] = p[2] = p[3] = 0.0;
d3759 1
a3759 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_TEXGEN, 6);
d3789 4
a3792 2
   GLfloat p = (GLfloat) param;
   save_TexGenfv(coord, pname, &p);
d3811 4
a3814 1
   save_TexGenfv(coord, pname, &param);
d3821 4
a3824 1
   save_TexGeniv(coord, pname, &param);
d3834 1
a3834 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_TEXPARAMETER, 6);
d3852 4
a3855 1
   save_TexParameterfv(target, pname, &param);
d3864 1
a3864 1
   fparam[1] = fparam[2] = fparam[3] = 0.0;
d3874 1
a3874 1
   fparam[1] = fparam[2] = fparam[3] = 0.0;
a3891 2
      GLvoid *image = unpack_image(1, width, 1, 1, format, type,
                                   pixels, &ctx->Unpack);
d3894 1
a3894 1
      n = ALLOC_INSTRUCTION(ctx, OPCODE_TEX_IMAGE1D, 8);
d3903 2
a3904 4
         n[8].data = image;
      }
      else if (image) {
         _mesa_free(image);
a3926 2
      GLvoid *image = unpack_image(2, width, height, 1, format, type,
                                   pixels, &ctx->Unpack);
d3929 1
a3929 1
      n = ALLOC_INSTRUCTION(ctx, OPCODE_TEX_IMAGE2D, 9);
d3939 2
a3940 4
         n[9].data = image;
      }
      else if (image) {
         _mesa_free(image);
a3965 2
      GLvoid *image = unpack_image(3, width, height, depth, format, type,
                                   pixels, &ctx->Unpack);
d3967 1
a3967 1
      n = ALLOC_INSTRUCTION(ctx, OPCODE_TEX_IMAGE3D, 10);
d3978 2
a3979 4
         n[10].data = image;
      }
      else if (image) {
         _mesa_free(image);
d3997 1
a3997 2
   GLvoid *image = unpack_image(1, width, 1, 1, format, type,
                                pixels, &ctx->Unpack);
d3999 2
a4000 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_TEX_SUB_IMAGE1D, 7);
d4008 2
a4009 4
      n[7].data = image;
   }
   else if (image) {
      _mesa_free(image);
d4026 1
a4026 2
   GLvoid *image = unpack_image(2, width, height, 1, format, type,
                                pixels, &ctx->Unpack);
d4028 2
a4029 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_TEX_SUB_IMAGE2D, 9);
d4039 2
a4040 4
      n[9].data = image;
   }
   else if (image) {
      _mesa_free(image);
d4057 1
a4057 2
   GLvoid *image = unpack_image(3, width, height, depth, format, type,
                                pixels, &ctx->Unpack);
d4059 2
a4060 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_TEX_SUB_IMAGE3D, 11);
d4072 2
a4073 4
      n[11].data = image;
   }
   else if (image) {
      _mesa_free(image);
d4090 1
a4090 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_TRANSLATE, 3);
d4116 1
a4116 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_VIEWPORT, 4);
d4135 1
a4135 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_WINDOW_POS, 4);
d4296 1
a4296 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_ACTIVE_TEXTURE, 1);
d4363 1
a4363 1
      image = _mesa_malloc(imageSize);
d4368 2
a4369 2
      MEMCPY(image, data, imageSize);
      n = ALLOC_INSTRUCTION(ctx, OPCODE_COMPRESSED_TEX_IMAGE_1D, 7);
d4380 1
a4380 1
         _mesa_free(image);
d4409 1
a4409 1
      image = _mesa_malloc(imageSize);
d4414 2
a4415 2
      MEMCPY(image, data, imageSize);
      n = ALLOC_INSTRUCTION(ctx, OPCODE_COMPRESSED_TEX_IMAGE_2D, 8);
d4427 1
a4427 1
         _mesa_free(image);
d4456 1
a4456 1
      image = _mesa_malloc(imageSize);
d4461 2
a4462 2
      MEMCPY(image, data, imageSize);
      n = ALLOC_INSTRUCTION(ctx, OPCODE_COMPRESSED_TEX_IMAGE_3D, 9);
d4475 1
a4475 1
         _mesa_free(image);
d4499 1
a4499 1
   image = _mesa_malloc(imageSize);
d4504 2
a4505 2
   MEMCPY(image, data, imageSize);
   n = ALLOC_INSTRUCTION(ctx, OPCODE_COMPRESSED_TEX_SUB_IMAGE_1D, 7);
d4516 1
a4516 1
      _mesa_free(image);
d4539 1
a4539 1
   image = _mesa_malloc(imageSize);
d4544 2
a4545 2
   MEMCPY(image, data, imageSize);
   n = ALLOC_INSTRUCTION(ctx, OPCODE_COMPRESSED_TEX_SUB_IMAGE_2D, 9);
d4558 1
a4558 1
      _mesa_free(image);
d4581 1
a4581 1
   image = _mesa_malloc(imageSize);
d4586 2
a4587 2
   MEMCPY(image, data, imageSize);
   n = ALLOC_INSTRUCTION(ctx, OPCODE_COMPRESSED_TEX_SUB_IMAGE_3D, 11);
d4602 1
a4602 1
      _mesa_free(image);
d4620 1
a4620 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_SAMPLE_COVERAGE, 2);
d4641 1
a4641 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_BIND_PROGRAM_NV, 2);
d4658 1
a4658 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_PROGRAM_ENV_PARAMETER_ARB, 6);
d4695 1
a4695 1
	 n = ALLOC_INSTRUCTION(ctx, OPCODE_PROGRAM_ENV_PARAMETER_ARB, 6);
d4743 1
a4743 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_EXECUTE_PROGRAM_NV, 6);
a4785 1
   GLubyte *programCopy;
d4787 1
a4787 6
   programCopy = (GLubyte *) _mesa_malloc(len);
   if (!programCopy) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glLoadProgramNV");
      return;
   }
   _mesa_memcpy(programCopy, program, len);
d4789 1
a4789 2
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = ALLOC_INSTRUCTION(ctx, OPCODE_LOAD_PROGRAM_NV, 4);
d4791 6
d4813 1
a4813 6
   GLuint *idCopy = (GLuint *) _mesa_malloc(num * sizeof(GLuint));
   if (!idCopy) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glRequestResidentProgramsNV");
      return;
   }
   _mesa_memcpy(idCopy, ids, num * sizeof(GLuint));
d4815 2
a4816 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_TRACK_MATRIX_NV, 2);
d4818 6
d4840 1
a4840 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_TRACK_MATRIX_NV, 4);
d4865 1
a4865 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_PROGRAM_LOCAL_PARAMETER_ARB, 6);
d4887 1
a4887 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_PROGRAM_LOCAL_PARAMETER_ARB, 6);
d4915 1
a4915 1
	 n = ALLOC_INSTRUCTION(ctx, OPCODE_PROGRAM_LOCAL_PARAMETER_ARB, 6);
d4942 1
a4942 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_PROGRAM_LOCAL_PARAMETER_ARB, 6);
d4964 1
a4964 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_PROGRAM_LOCAL_PARAMETER_ARB, 6);
a4983 6
   GLubyte *nameCopy = (GLubyte *) _mesa_malloc(len);
   if (!nameCopy) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glProgramNamedParameter4fNV");
      return;
   }
   _mesa_memcpy(nameCopy, name, len);
d4986 2
a4987 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_PROGRAM_NAMED_PARAMETER_NV, 6);
d4989 6
d5046 1
a5046 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_ACTIVE_STENCIL_FACE_EXT, 1);
d5063 1
a5063 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_DEPTH_BOUNDS_EXT, 2);
a5082 1
   GLubyte *programCopy;
d5084 1
a5084 6
   programCopy = (GLubyte *) _mesa_malloc(len);
   if (!programCopy) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glProgramStringARB");
      return;
   }
   _mesa_memcpy(programCopy, string, len);
d5086 1
a5086 2
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = ALLOC_INSTRUCTION(ctx, OPCODE_PROGRAM_STRING_ARB, 4);
d5088 6
d5107 1
a5107 1
#if FEATURE_ARB_occlusion_query
d5115 1
a5115 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_BEGIN_QUERY_ARB, 2);
d5132 1
a5132 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_END_QUERY_ARB, 1);
d5141 1
a5141 1
#endif /* FEATURE_ARB_occlusion_query */
d5150 1
a5150 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_DRAW_BUFFERS_ARB, 1 + MAX_DRAW_BUFFERS);
d5165 30
d5202 1
a5202 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_BIND_FRAGMENT_SHADER_ATI, 1);
d5217 1
a5217 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_SET_FRAGMENT_SHADER_CONSTANTS_ATI, 5);
d5237 1
a5237 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_ATTR_1F_NV, 2);
d5243 1
a5243 1
   ASSERT(attr < MAX_VERTEX_PROGRAM_ATTRIBS);
d5258 1
a5258 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_ATTR_2F_NV, 3);
d5265 1
a5265 1
   ASSERT(attr < MAX_VERTEX_PROGRAM_ATTRIBS);
d5280 1
a5280 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_ATTR_3F_NV, 4);
d5288 1
a5288 1
   ASSERT(attr < MAX_VERTEX_PROGRAM_ATTRIBS);
d5303 1
a5303 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_ATTR_4F_NV, 5);
d5312 1
a5312 1
   ASSERT(attr < MAX_VERTEX_PROGRAM_ATTRIBS);
d5328 1
a5328 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_ATTR_1F_ARB, 2);
d5334 1
a5334 1
   ASSERT(attr < MAX_VERTEX_ATTRIBS);
d5349 1
a5349 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_ATTR_2F_ARB, 3);
d5356 1
a5356 1
   ASSERT(attr < MAX_VERTEX_ATTRIBS);
d5371 1
a5371 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_ATTR_3F_ARB, 4);
d5379 1
a5379 1
   ASSERT(attr < MAX_VERTEX_ATTRIBS);
d5394 1
a5394 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_ATTR_4F_ARB, 5);
d5403 1
a5403 1
   ASSERT(attr < MAX_VERTEX_ATTRIBS);
d5419 1
a5419 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_EVAL_C1, 1);
d5440 1
a5440 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_EVAL_C2, 2);
d5463 1
a5463 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_EVAL_P1, 1);
d5478 1
a5478 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_EVAL_P2, 2);
d5506 8
d5520 1
a5520 2

   SAVE_FLUSH_VERTICES(ctx);
d5550 4
d5555 1
a5555 7
   n = ALLOC_INSTRUCTION(ctx, OPCODE_MATERIAL, 6);
   if (n) {
      n[1].e = face;
      n[2].e = pname;
      for (i = 0; i < args; i++)
         n[3 + i].f = param[i];
   }
d5557 11
a5567 4
   {
      GLuint bitmask = _mesa_material_bitmask(ctx, face, pname, ~0, NULL);
      for (i = 0; i < MAT_ATTRIB_MAX; i++)
         if (bitmask & (1 << i)) {
d5571 1
d5574 13
a5586 2
   if (ctx->ExecuteFlag) {
      CALL_Materialfv(ctx->Exec, (face, pname, param));
d5624 1
a5624 1
      n = ALLOC_INSTRUCTION(ctx, OPCODE_BEGIN, 1);
d5640 1
a5640 1
   (void) ALLOC_INSTRUCTION(ctx, OPCODE_END, 0);
d5653 1
a5653 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_RECTF, 4);
d5890 1
a5890 1
   if (index < MAX_VERTEX_PROGRAM_ATTRIBS)
d5899 1
a5899 1
   if (index < MAX_VERTEX_PROGRAM_ATTRIBS)
d5908 1
a5908 1
   if (index < MAX_VERTEX_PROGRAM_ATTRIBS)
d5917 1
a5917 1
   if (index < MAX_VERTEX_PROGRAM_ATTRIBS)
d5926 1
a5926 1
   if (index < MAX_VERTEX_PROGRAM_ATTRIBS)
d5935 1
a5935 1
   if (index < MAX_VERTEX_PROGRAM_ATTRIBS)
d5945 1
a5945 1
   if (index < MAX_VERTEX_PROGRAM_ATTRIBS)
d5952 451
a6402 1
save_VertexAttrib4fvNV(GLuint index, const GLfloat * v)
d6404 12
a6415 4
   if (index < MAX_VERTEX_PROGRAM_ATTRIBS)
      save_Attr4fNV(index, v[0], v[1], v[2], v[3]);
   else
      index_error();
a6418 2


d6420 2
a6421 1
save_VertexAttrib1fARB(GLuint index, GLfloat x)
d6423 13
a6435 4
   if (index < MAX_VERTEX_ATTRIBS)
      save_Attr1fARB(index, x);
   else
      index_error();
d6439 2
a6440 1
save_VertexAttrib1fvARB(GLuint index, const GLfloat * v)
d6442 13
a6454 4
   if (index < MAX_VERTEX_ATTRIBS)
      save_Attr1fARB(index, v[0]);
   else
      index_error();
d6458 2
a6459 1
save_VertexAttrib2fARB(GLuint index, GLfloat x, GLfloat y)
d6461 13
a6473 4
   if (index < MAX_VERTEX_ATTRIBS)
      save_Attr2fARB(index, x, y);
   else
      index_error();
d6476 1
d6478 2
a6479 1
save_VertexAttrib2fvARB(GLuint index, const GLfloat * v)
d6481 13
a6493 4
   if (index < MAX_VERTEX_ATTRIBS)
      save_Attr2fARB(index, v[0], v[1]);
   else
      index_error();
d6497 2
a6498 1
save_VertexAttrib3fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z)
d6500 13
a6512 4
   if (index < MAX_VERTEX_ATTRIBS)
      save_Attr3fARB(index, x, y, z);
   else
      index_error();
a6514 8
static void GLAPIENTRY
save_VertexAttrib3fvARB(GLuint index, const GLfloat * v)
{
   if (index < MAX_VERTEX_ATTRIBS)
      save_Attr3fARB(index, v[0], v[1], v[2]);
   else
      index_error();
}
d6517 2
a6518 2
save_VertexAttrib4fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z,
                       GLfloat w)
d6520 13
a6532 4
   if (index < MAX_VERTEX_ATTRIBS)
      save_Attr4fARB(index, x, y, z, w);
   else
      index_error();
d6536 2
a6537 1
save_VertexAttrib4fvARB(GLuint index, const GLfloat * v)
d6539 13
a6551 4
   if (index < MAX_VERTEX_ATTRIBS)
      save_Attr4fARB(index, v[0], v[1], v[2], v[3]);
   else
      index_error();
a6554 2
/* GL_ARB_shader_objects, GL_ARB_vertex/fragment_shader */

d6556 2
a6557 1
exec_BindAttribLocationARB(GLuint program, GLuint index, const GLchar *name)
d6560 12
a6571 10
   FLUSH_VERTICES(ctx, 0);
   CALL_BindAttribLocationARB(ctx->Exec, (program, index, name));
}

static GLint GLAPIENTRY
exec_GetAttribLocationARB(GLuint program, const GLchar *name)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   return CALL_GetAttribLocationARB(ctx->Exec, (program, name));
a6572 2
/* XXX more shader functions needed here */

a6573 2

#if FEATURE_EXT_framebuffer_blit
d6575 2
a6576 3
save_BlitFramebufferEXT(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1,
                        GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1,
                        GLbitfield mask, GLenum filter)
d6581 1
a6581 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_BLIT_FRAMEBUFFER, 10);
d6583 4
a6586 10
      n[1].i = srcX0;
      n[2].i = srcY0;
      n[3].i = srcX1;
      n[4].i = srcY1;
      n[5].i = dstX0;
      n[6].i = dstY0;
      n[7].i = dstX1;
      n[8].i = dstY1;
      n[9].i = mask;
      n[10].e = filter;
d6589 1
a6589 3
      CALL_BlitFramebufferEXT(ctx->Exec, (srcX0, srcY0, srcX1, srcY1,
                                          dstX0, dstY0, dstX1, dstY1,
                                          mask, filter));
d6592 1
a6592 1
#endif
d6605 1
a6605 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_ERROR, 2);
d6656 1
a6656 1
   struct mesa_display_list *dlist;
d6677 1
a6677 1
   n = dlist->node;
d6681 1
a6681 2
      OpCode opcode = n[0].opcode;
      int i = (int) n[0].opcode - (int) OPCODE_EXT_0;
d6683 2
a6684 4
      if (i >= 0 && i < (GLint) ctx->ListExt.NumOpcodes) {
         /* this is a driver-extended opcode */
         ctx->ListExt.Opcode[i].Execute(ctx, &n[1]);
         n += ctx->ListExt.Opcode[i].Size;
d6743 33
d6804 4
d6950 3
d6968 3
d7199 3
d7446 1
a7446 1
#if FEATURE_ARB_occlusion_query
d7470 102
d7688 1
a7688 1
               _mesa_sprintf(msg, "Error in execute_list: opcode=%d",
d7717 1
a7717 1
GLboolean GLAPIENTRY
d7730 1
a7730 1
void GLAPIENTRY
d7752 1
a7752 1
GLuint GLAPIENTRY
d7792 2
a7793 2
void GLAPIENTRY
_mesa_NewList(GLuint list, GLenum mode)
a7795 1
   GLint i;
d7801 1
a7801 1
      _mesa_debug(ctx, "glNewList %u %s\n", list,
d7804 1
a7804 1
   if (list == 0) {
d7814 1
a7814 1
   if (ctx->ListState.CurrentListPtr) {
a7822 7
   /* Allocate new display list */
   ctx->ListState.CurrentListNum = list;
   ctx->ListState.CurrentList = make_list(list, BLOCK_SIZE);
   ctx->ListState.CurrentBlock = ctx->ListState.CurrentList->node;
   ctx->ListState.CurrentListPtr = ctx->ListState.CurrentBlock;
   ctx->ListState.CurrentPos = 0;

d7825 1
a7825 2
   for (i = 0; i < VERT_ATTRIB_MAX; i++)
      ctx->ListState.ActiveAttribSize[i] = 0;
d7827 4
a7830 2
   for (i = 0; i < MAT_ATTRIB_MAX; i++)
      ctx->ListState.ActiveMaterialSize[i] = 0;
d7832 1
a7832 2
   ctx->Driver.CurrentSavePrimitive = PRIM_UNKNOWN;
   ctx->Driver.NewList(ctx, list, mode);
d7842 1
a7842 1
void GLAPIENTRY
d7853 1
a7853 1
   if (!ctx->ListState.CurrentListPtr) {
d7863 1
a7863 1
   (void) ALLOC_INSTRUCTION(ctx, OPCODE_END_OF_LIST, 0);
d7866 5
a7870 3
   destroy_list(ctx, ctx->ListState.CurrentListNum);
   /* Install the list */
   _mesa_HashInsert(ctx->Shared->DisplayList, ctx->ListState.CurrentListNum,
d7875 1
a7875 1
      mesa_print_display_list(ctx->ListState.CurrentListNum);
a7877 2
   ctx->ListState.CurrentListNum = 0;
   ctx->ListState.CurrentListPtr = NULL;
d7976 1
a7976 1
void GLAPIENTRY
a8672 12
/* GL_EXT_multi_draw_arrays */
static void GLAPIENTRY
exec_MultiDrawElementsEXT(GLenum mode, const GLsizei * count,
                          GLenum type, const GLvoid ** indices,
                          GLsizei primcount)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_MultiDrawElementsEXT(ctx->Exec,
                             (mode, count, type, indices, primcount));
}

d8711 1
a8711 1
_mesa_init_dlist_table(struct _glapi_table *table)
d8720 2
a8721 2
   SET_CallList(table, _mesa_save_CallList);
   SET_CallLists(table, _mesa_save_CallLists);
d8730 1
d8739 1
d8743 1
d8745 2
a8746 2
   SET_EvalMesh1(table, _mesa_save_EvalMesh1);
   SET_EvalMesh2(table, _mesa_save_EvalMesh2);
a9020 1
   SET_MultiDrawElementsEXT(table, exec_MultiDrawElementsEXT);
d9094 4
d9218 1
a9218 1
#if FEATURE_ARB_occlusion_query
d9234 28
d9275 31
d9324 1
a9324 1
   struct mesa_display_list *dlist;
d9329 1
a9329 1
      _mesa_printf("%u is not a display list ID\n", list);
d9337 1
a9337 1
   n = dlist->node;
d9339 1
a9339 1
   _mesa_printf("START-LIST %u, address %p\n", list, (void *) n);
d9343 1
a9343 2
      OpCode opcode = n[0].opcode;
      GLint i = (GLint) n[0].opcode - (GLint) OPCODE_EXT_0;
d9345 2
a9346 4
      if (i >= 0 && i < (GLint) ctx->ListExt.NumOpcodes) {
         /* this is a driver-extended opcode */
         ctx->ListExt.Opcode[i].Print(ctx, &n[1]);
         n += ctx->ListExt.Opcode[i].Size;
d9351 1
a9351 1
            _mesa_printf("Accum %s %g\n", enum_string(n[1].e), n[2].f);
d9354 1
a9354 1
            _mesa_printf("Bitmap %d %d %g %g %g %g %p\n", n[1].i, n[2].i,
d9358 1
a9358 1
            _mesa_printf("CallList %d\n", (int) n[1].ui);
d9361 1
a9361 1
            _mesa_printf("CallList %d + offset %u = %u\n", (int) n[1].ui,
d9365 1
a9365 1
            _mesa_printf("ColorTableParameterfv %s %s %f %f %f %f\n",
d9370 1
a9370 1
            _mesa_printf("ColorTableParameteriv %s %s %d %d %d %d\n",
d9375 1
a9375 1
            _mesa_printf("Disable %s\n", enum_string(n[1].e));
d9378 1
a9378 1
            _mesa_printf("Enable %s\n", enum_string(n[1].e));
d9381 1
a9381 1
            _mesa_printf("Frustum %g %g %g %g %g %g\n",
d9385 1
a9385 1
            _mesa_printf("LineStipple %d %x\n", n[1].i, (int) n[2].us);
d9388 1
a9388 1
            _mesa_printf("LoadIdentity\n");
d9391 2
a9392 2
            _mesa_printf("LoadMatrix\n");
            _mesa_printf("  %8f %8f %8f %8f\n",
d9394 1
a9394 1
            _mesa_printf("  %8f %8f %8f %8f\n",
d9396 1
a9396 1
            _mesa_printf("  %8f %8f %8f %8f\n",
d9398 1
a9398 1
            _mesa_printf("  %8f %8f %8f %8f\n",
d9402 2
a9403 2
            _mesa_printf("MultMatrix (or Rotate)\n");
            _mesa_printf("  %8f %8f %8f %8f\n",
d9405 1
a9405 1
            _mesa_printf("  %8f %8f %8f %8f\n",
d9407 1
a9407 1
            _mesa_printf("  %8f %8f %8f %8f\n",
d9409 1
a9409 1
            _mesa_printf("  %8f %8f %8f %8f\n",
d9413 1
a9413 1
            _mesa_printf("Ortho %g %g %g %g %g %g\n",
d9417 1
a9417 1
            _mesa_printf("PopAttrib\n");
d9420 1
a9420 1
            _mesa_printf("PopMatrix\n");
d9423 1
a9423 1
            _mesa_printf("PopName\n");
d9426 1
a9426 1
            _mesa_printf("PushAttrib %x\n", n[1].bf);
d9429 1
a9429 1
            _mesa_printf("PushMatrix\n");
d9432 1
a9432 1
            _mesa_printf("PushName %d\n", (int) n[1].ui);
d9435 1
a9435 1
            _mesa_printf("RasterPos %g %g %g %g\n",
d9439 1
a9439 1
            _mesa_printf("Rotate %g %g %g %g\n",
d9443 1
a9443 1
            _mesa_printf("Scale %g %g %g\n", n[1].f, n[2].f, n[3].f);
d9446 1
a9446 1
            _mesa_printf("Translate %g %g %g\n", n[1].f, n[2].f, n[3].f);
d9449 1
a9449 1
            _mesa_printf("BindTexture %s %d\n",
d9453 1
a9453 1
            _mesa_printf("ShadeModel %s\n", _mesa_lookup_enum_by_nr(n[1].ui));
d9456 1
a9456 1
            _mesa_printf("Map1 %s %.3f %.3f %d %d\n",
d9461 1
a9461 1
            _mesa_printf("Map2 %s %.3f %.3f %.3f %.3f %d %d %d %d\n",
d9467 1
a9467 1
            _mesa_printf("MapGrid1 %d %.3f %.3f\n", n[1].i, n[2].f, n[3].f);
d9470 1
a9470 1
            _mesa_printf("MapGrid2 %d %.3f %.3f, %d %.3f %.3f\n",
d9474 1
a9474 1
            _mesa_printf("EvalMesh1 %d %d\n", n[1].i, n[2].i);
d9477 1
a9477 1
            _mesa_printf("EvalMesh2 %d %d %d %d\n",
d9482 1
a9482 1
            _mesa_printf("ATTR_1F_NV attr %d: %f\n", n[1].i, n[2].f);
d9485 1
a9485 1
            _mesa_printf("ATTR_2F_NV attr %d: %f %f\n",
d9489 1
a9489 1
            _mesa_printf("ATTR_3F_NV attr %d: %f %f %f\n",
d9493 1
a9493 1
            _mesa_printf("ATTR_4F_NV attr %d: %f %f %f %f\n",
d9497 1
a9497 1
            _mesa_printf("ATTR_1F_ARB attr %d: %f\n", n[1].i, n[2].f);
d9500 1
a9500 1
            _mesa_printf("ATTR_2F_ARB attr %d: %f %f\n",
d9504 1
a9504 1
            _mesa_printf("ATTR_3F_ARB attr %d: %f %f %f\n",
d9508 1
a9508 1
            _mesa_printf("ATTR_4F_ARB attr %d: %f %f %f %f\n",
d9513 1
a9513 1
            _mesa_printf("MATERIAL %x %x: %f %f %f %f\n",
d9517 1
a9517 1
            _mesa_printf("BEGIN %x\n", n[1].i);
d9520 1
a9520 1
            _mesa_printf("END\n");
d9523 1
a9523 1
            _mesa_printf("RECTF %f %f %f %f\n", n[1].f, n[2].f, n[3].f,
d9527 1
a9527 1
            _mesa_printf("EVAL_C1 %f\n", n[1].f);
d9530 1
a9530 1
            _mesa_printf("EVAL_C2 %f %f\n", n[1].f, n[2].f);
d9533 1
a9533 1
            _mesa_printf("EVAL_P1 %d\n", n[1].i);
d9536 6
a9541 1
            _mesa_printf("EVAL_P2 %d %d\n", n[1].i, n[2].i);
d9548 1
a9548 1
            _mesa_printf("Error: %s %s\n",
d9552 1
a9552 1
            _mesa_printf("DISPLAY-LIST-CONTINUE\n");
d9556 1
a9556 1
            _mesa_printf("END-LIST %u\n", list);
d9561 1
a9561 1
               _mesa_printf
d9567 1
a9567 1
               _mesa_printf("command %d, %u operands\n", opcode,
d9601 2
a9602 1
   vfmt->ArrayElement = _ae_loopback_array_elt; /* generic helper */
d9604 3
a9606 2
   vfmt->CallList = _mesa_save_CallList;
   vfmt->CallLists = _mesa_save_CallLists;
d9613 3
a9615 6
   vfmt->EvalCoord1f = save_EvalCoord1f;
   vfmt->EvalCoord1fv = save_EvalCoord1fv;
   vfmt->EvalCoord2f = save_EvalCoord2f;
   vfmt->EvalCoord2fv = save_EvalCoord2fv;
   vfmt->EvalPoint1 = save_EvalPoint1;
   vfmt->EvalPoint2 = save_EvalPoint2;
a9663 2
   vfmt->EvalMesh1 = _mesa_save_EvalMesh1;
   vfmt->EvalMesh2 = _mesa_save_EvalMesh2;
d9676 4
d9684 26
d9720 1
a9720 1
      _mesa_bzero(InstSize, sizeof(InstSize));
d9724 3
a9730 1
   ctx->ListState.CurrentListPtr = NULL;
a9731 1
   ctx->ListState.CurrentListNum = 0;
d9737 1
d9739 9
@


1.3
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@a43 1
#include "colormac.h"
d54 1
d931 7
d2007 1
a2007 1
   if (OPCODE_LIGHT) {
d5111 1
a5111 1
   save_Attr1fNV(VERT_ATTRIB_EDGEFLAG, x ? 1.0 : 0.0);
d7672 1
a7672 1
   SET_BlendFunc(table, _mesa_BlendFunc);       /* loops-back to BlendFuncSeparate */
@


1.2
log
@Update to Mesa 7.0.2. Tested by naddy@@ (full ports build), simon@@
and oga@@ (with dri enabled).
@
text
@d3 1
a3 1
 * Version:  7.0.2
a35 4
#if FEATURE_ARB_vertex_program || FEATURE_ARB_fragment_program
#include "arbprogram.h"
#include "program.h"
#endif
d56 1
a56 1
#include "glapi.h"
d75 4
d80 2
a81 2
#include "nvprogram.h"
#include "program.h"
d84 1
a84 1
#include "atifragshader.h"
d90 1
a90 1
#include "dispatch.h"
a305 1
   OPCODE_PROGRAM_PARAMETER4F_NV,
d614 1
a614 1
 * Translate the nth element of list from type to GLuint.
d616 1
a616 1
static GLuint
d630 1
a630 1
      return (GLuint) *(bptr + n);
d633 1
a633 1
      return (GLuint) *(ubptr + n);
d636 1
a636 1
      return (GLuint) *(sptr + n);
d639 1
a639 1
      return (GLuint) *(usptr + n);
d642 1
a642 1
      return (GLuint) *(iptr + n);
d645 1
a645 1
      return (GLuint) *(uiptr + n);
d648 1
a648 1
      return (GLuint) *(fptr + n);
d651 2
a652 1
      return (GLuint) *ubptr * 256 + (GLuint) * (ubptr + 1);
d655 3
a657 2
      return (GLuint) * ubptr * 65536
           + (GLuint) *(ubptr + 1) * 256 + (GLuint) * (ubptr + 2);
d660 4
a663 3
      return (GLuint) *ubptr * 16777216
           + (GLuint) *(ubptr + 1) * 65536
           + (GLuint) *(ubptr + 2) * 256 + (GLuint) * (ubptr + 3);
d998 1
a998 1
      GLuint list = translate_id(i, type, lists);
d1001 1
a1001 1
         n[1].ui = list;
d3251 30
a4281 1
#endif /* FEATURE_NV_vertex_program || FEATURE_ARB_vertex_program || FEATURE_ARB_fragment_program */
a4282 1
#if FEATURE_NV_vertex_program
d4284 2
a4285 1
save_ExecuteProgramNV(GLenum target, GLuint id, const GLfloat *params)
d4290 1
a4290 1
   n = ALLOC_INSTRUCTION(ctx, OPCODE_EXECUTE_PROGRAM_NV, 6);
d4293 5
a4297 5
      n[2].ui = id;
      n[3].f = params[0];
      n[4].f = params[1];
      n[5].f = params[2];
      n[6].f = params[3];
d4300 1
a4300 1
      CALL_ExecuteProgramNV(ctx->Exec, (target, id, params));
d4306 11
a4316 2
save_ProgramParameter4fNV(GLenum target, GLuint index,
                          GLfloat x, GLfloat y, GLfloat z, GLfloat w)
d4321 17
a4337 8
   n = ALLOC_INSTRUCTION(ctx, OPCODE_PROGRAM_PARAMETER4F_NV, 6);
   if (n) {
      n[1].e = target;
      n[2].ui = index;
      n[3].f = x;
      n[4].f = y;
      n[5].f = z;
      n[6].f = w;
d4339 1
d4341 1
a4341 1
      CALL_ProgramParameter4fNV(ctx->Exec, (target, index, x, y, z, w));
d4347 2
a4348 2
save_ProgramParameter4fvNV(GLenum target, GLuint index,
                           const GLfloat *params)
d4350 3
a4352 2
   save_ProgramParameter4fNV(target, index, params[0], params[1],
                             params[2], params[3]);
d4357 2
a4358 2
save_ProgramParameter4dNV(GLenum target, GLuint index,
                          GLdouble x, GLdouble y, GLdouble z, GLdouble w)
d4360 4
a4363 2
   save_ProgramParameter4fNV(target, index, (GLfloat) x, (GLfloat) y,
                             (GLfloat) z, (GLfloat) w);
d4366 1
d4368 1
d4370 1
a4370 2
save_ProgramParameter4dvNV(GLenum target, GLuint index,
                           const GLdouble *params)
d4372 15
a4386 3
   save_ProgramParameter4fNV(target, index, (GLfloat) params[0],
                             (GLfloat) params[1], (GLfloat) params[2],
                             (GLfloat) params[3]);
d4396 1
a4396 1
      save_ProgramParameter4dvNV(target, index + i, params + 4 * i);
d4407 1
a4407 1
      save_ProgramParameter4fvNV(target, index + i, params + 4 * i);
a4734 84

static void GLAPIENTRY
save_ProgramEnvParameter4fARB(GLenum target, GLuint index,
                              GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = ALLOC_INSTRUCTION(ctx, OPCODE_PROGRAM_ENV_PARAMETER_ARB, 6);
   if (n) {
      n[1].e = target;
      n[2].ui = index;
      n[3].f = x;
      n[4].f = y;
      n[5].f = z;
      n[6].f = w;
   }
   if (ctx->ExecuteFlag) {
      CALL_ProgramEnvParameter4fARB(ctx->Exec, (target, index, x, y, z, w));
   }
}


static void GLAPIENTRY
save_ProgramEnvParameter4fvARB(GLenum target, GLuint index,
                               const GLfloat *params)
{
   save_ProgramEnvParameter4fARB(target, index, params[0], params[1],
                                 params[2], params[3]);
}


static void GLAPIENTRY
save_ProgramEnvParameters4fvEXT(GLenum target, GLuint index, GLsizei count,
				const GLfloat * params)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);

   if (count > 0) {
      GLint i;
      const GLfloat * p = params;

      for (i = 0 ; i < count ; i++) {
	 n = ALLOC_INSTRUCTION(ctx, OPCODE_PROGRAM_ENV_PARAMETER_ARB, 6);
	 if (n) {
	    n[1].e = target;
	    n[2].ui = index;
	    n[3].f = p[0];
	    n[4].f = p[1];
	    n[5].f = p[2];
	    n[6].f = p[3];
	    p += 4;
	 }
      }
   }

   if (ctx->ExecuteFlag) {
      CALL_ProgramEnvParameters4fvEXT(ctx->Exec, (target, index, count, params));
   }
}


static void GLAPIENTRY
save_ProgramEnvParameter4dARB(GLenum target, GLuint index,
                              GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   save_ProgramEnvParameter4fARB(target, index,
                                 (GLfloat) x,
                                 (GLfloat) y, (GLfloat) z, (GLfloat) w);
}


static void GLAPIENTRY
save_ProgramEnvParameter4dvARB(GLenum target, GLuint index,
                               const GLdouble *params)
{
   save_ProgramEnvParameter4fARB(target, index,
                                 (GLfloat) params[0],
                                 (GLfloat) params[1],
                                 (GLfloat) params[2], (GLfloat) params[3]);
}

d5614 21
d5810 2
a5811 1
               execute_list(ctx, ctx->List.ListBase + n[1].ui);
a6435 4
         case OPCODE_PROGRAM_PARAMETER4F_NV:
            CALL_ProgramParameter4fNV(ctx->Exec, (n[1].e, n[2].ui, n[3].f,
                                                  n[4].f, n[5].f, n[6].f));
            break;
d6466 2
a6604 3



d6791 5
a6808 2
   ctx->Driver.EndList(ctx);

a6861 1
   GLuint list;
d6893 2
a6894 2
      list = translate_id(i, type, lists);
      execute_list(ctx, ctx->List.ListBase + list);
d7874 3
d8028 4
a8031 4
   SET_ProgramParameter4dNV(table, save_ProgramParameter4dNV);
   SET_ProgramParameter4dvNV(table, save_ProgramParameter4dvNV);
   SET_ProgramParameter4fNV(table, save_ProgramParameter4fNV);
   SET_ProgramParameter4fvNV(table, save_ProgramParameter4fvNV);
d8174 5
a8421 2


@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * Version:  6.5.1
d5 1
a5 1
 * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
a68 1
#include "occlude.h"
d72 1
a345 2
   OPCODE_INDEX,
   OPCODE_EDGEFLAG,
a2718 3
/*
 * Polygon stipple must have been upacked already!
 */
d2723 2
d2729 4
a2732 4
      void *data;
      n[1].data = _mesa_malloc(32 * 4);
      data = n[1].data;         /* This needed for Acorn compiler */
      MEMCPY(data, pattern, 32 * 4);
d4476 1
a4476 1
      unsigned i;
d4710 1
a4710 1
      unsigned i;
d5110 1
a5110 14
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   SAVE_FLUSH_VERTICES(ctx);
   n = ALLOC_INSTRUCTION(ctx, OPCODE_INDEX, 1);
   if (n) {
      n[1].f = x;
   }

   ctx->ListState.ActiveIndex = 1;
   ctx->ListState.CurrentIndex = x;

   if (ctx->ExecuteFlag) {
      CALL_Indexf(ctx->Exec, (x));
   }
d5116 1
a5116 1
   save_Indexf(v[0]);
d5122 1
a5122 14
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   SAVE_FLUSH_VERTICES(ctx);
   n = ALLOC_INSTRUCTION(ctx, OPCODE_EDGEFLAG, 1);
   if (n) {
      n[1].b = x;
   }

   ctx->ListState.ActiveEdgeFlag = 1;
   ctx->ListState.CurrentEdgeFlag = x;

   if (ctx->ExecuteFlag) {
      CALL_EdgeFlag(ctx->Exec, (x));
   }
d5740 1
a5740 1
   ctx->ListState.CallStack[ctx->ListState.CallDepth++] = dlist;
d6171 6
a6176 1
            CALL_PolygonStipple(ctx->Exec, ((GLubyte *) n[1].data));
a6580 6
         case OPCODE_INDEX:
            CALL_Indexf(ctx->Exec, (n[1].f));
            break;
         case OPCODE_EDGEFLAG:
            CALL_EdgeFlag(ctx->Exec, (n[1].b));
            break;
d6632 1
a6632 1
   ctx->ListState.CallStack[ctx->ListState.CallDepth--] = NULL;
a6765 3
   ctx->ListState.ActiveIndex = 0;
   ctx->ListState.ActiveEdgeFlag = 0;

a7838 1
   SET_AreTexturesResidentEXT(table, exec_AreTexturesResident);
a7849 1
   SET_GenTexturesEXT(table, exec_GenTextures);
a7853 1
   SET_IsTextureEXT(table, exec_IsTexture);
a7891 1
   SET_GetColorTableSGI(table, exec_GetColorTable);
a7892 1
   SET_GetColorTableParameterfvSGI(table, exec_GetColorTableParameterfv);
a7893 1
   SET_GetColorTableParameterivSGI(table, exec_GetColorTableParameteriv);
a7894 1
   SET_GetConvolutionFilterEXT(table, exec_GetConvolutionFilter);
a7895 1
   SET_GetConvolutionParameterfvEXT(table, exec_GetConvolutionParameterfv);
a7896 1
   SET_GetConvolutionParameterivEXT(table, exec_GetConvolutionParameteriv);
a7897 1
   SET_GetHistogramEXT(table, exec_GetHistogram);
a7898 1
   SET_GetHistogramParameterfvEXT(table, exec_GetHistogramParameterfv);
a7899 1
   SET_GetHistogramParameterivEXT(table, exec_GetHistogramParameteriv);
a7900 1
   SET_GetMinmaxEXT(table, exec_GetMinmax);
a7901 1
   SET_GetMinmaxParameterfvEXT(table, exec_GetMinmaxParameterfv);
a7902 1
   SET_GetMinmaxParameterivEXT(table, exec_GetMinmaxParameteriv);
a7903 1
   SET_GetSeparableFilterEXT(table, exec_GetSeparableFilter);
a7928 1
#endif
d7932 1
d8022 1
a8022 1
   SET_IsProgramNV(table, _mesa_IsProgram);
d8115 1
a8115 1
   SET_IsProgramNV(table, _mesa_IsProgram);
a8389 6
            break;
         case OPCODE_INDEX:
            _mesa_printf("INDEX: %f\n", n[1].f);
            break;
         case OPCODE_EDGEFLAG:
            _mesa_printf("EDGEFLAG: %d\n", n[1].i);
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d7872 1
d7884 1
d7889 1
d7928 1
d7930 1
d7932 1
d7934 1
d7936 1
d7938 1
d7940 1
d7942 1
d7944 1
d7946 1
d7948 1
d7950 1
d7952 1
d7978 1
a7981 1
#endif
d8071 1
a8071 1
   SET_IsProgramNV(table, _mesa_IsProgramARB);
d8164 1
a8164 1
   SET_IsProgramNV(table, _mesa_IsProgramARB);
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d3 1
a3 1
 * Version:  7.0.1
d5 1
a5 1
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
d69 1
a72 1
#include "queryobj.h"
d346 2
d2721 3
a2727 2
   GLvoid *image = unpack_image(2, 32, 32, 1, GL_COLOR_INDEX, GL_BITMAP,
                                pattern, &ctx->Unpack);
d2732 4
a2735 4
      n[1].data = image; 
   }
   else if (image) {
      _mesa_free(image);
d4479 1
a4479 1
      GLint i;
d4713 1
a4713 1
      GLint i;
d5113 14
a5126 1
   save_Attr1fNV(VERT_ATTRIB_COLOR_INDEX, x);
d5132 1
a5132 1
   save_Attr1fNV(VERT_ATTRIB_COLOR_INDEX, v[0]);
d5138 14
a5151 1
   save_Attr1fNV(VERT_ATTRIB_EDGEFLAG, x ? 1.0 : 0.0);
d6200 1
a6200 6
            {
               const struct gl_pixelstore_attrib save = ctx->Unpack;
               ctx->Unpack = ctx->DefaultPacking;
               CALL_PolygonStipple(ctx->Exec, ((GLubyte *) n[1].data));
               ctx->Unpack = save;      /* restore */
            }
d6605 6
d6796 3
d8423 6
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d3 1
a3 1
 * Version:  7.7
d5 1
a5 2
 * Copyright (C) 1999-2008  Brian Paul   All Rights Reserved.
 * Copyright (C) 2009  VMware, Inc.  All Rights Reserved.
a33 1
#include "api_exec.h"
d35 4
a38 2
#if FEATURE_ATI_fragment_shader
#include "atifragshader.h"
d40 3
a42 2
#include "config.h"
#include "mfeatures.h"
d47 3
d51 2
d54 1
d57 4
a60 2
#include "framebuffer.h"
#include "glapi/glapi.h"
d62 1
d65 2
d68 4
a71 1
#include "pack.h"
d73 2
d76 1
a78 3
#if FEATURE_ARB_vertex_program || FEATURE_ARB_fragment_program
#include "arbprogram.h"
#endif
d81 4
d88 1
d90 1
a90 28
#include "main/dispatch.h"



/**
 * Other parts of Mesa (such as the VBO module) can plug into the display
 * list system.  This structure describes new display list instructions.
 */
struct gl_list_instruction
{
   GLuint Size;
   void (*Execute)( struct gl_context *ctx, void *data );
   void (*Destroy)( struct gl_context *ctx, void *data );
   void (*Print)( struct gl_context *ctx, void *data );
};


#define MAX_DLIST_EXT_OPCODES 16

/**
 * Used by device drivers to hook new commands into display lists.
 */
struct gl_list_extensions
{
   struct gl_list_instruction Opcode[MAX_DLIST_EXT_OPCODES];
   GLuint NumOpcodes;
};

a191 4
   OPCODE_CLEAR_BUFFER_IV,
   OPCODE_CLEAR_BUFFER_UIV,
   OPCODE_CLEAR_BUFFER_FV,
   OPCODE_CLEAR_BUFFER_FI,
a193 1
   OPCODE_COLOR_MASK_INDEXED,
a217 1
   OPCODE_DISABLE_INDEXED,
a220 1
   OPCODE_ENABLE_INDEXED,
d306 1
a323 2
   OPCODE_TEX_BUMP_PARAMETER_ATI,
   /* GL_ATI_fragment_shader */
a330 38
   /* GL_ARB_shader_objects */
   OPCODE_USE_PROGRAM,
   OPCODE_UNIFORM_1F,
   OPCODE_UNIFORM_2F,
   OPCODE_UNIFORM_3F,
   OPCODE_UNIFORM_4F,
   OPCODE_UNIFORM_1FV,
   OPCODE_UNIFORM_2FV,
   OPCODE_UNIFORM_3FV,
   OPCODE_UNIFORM_4FV,
   OPCODE_UNIFORM_1I,
   OPCODE_UNIFORM_2I,
   OPCODE_UNIFORM_3I,
   OPCODE_UNIFORM_4I,
   OPCODE_UNIFORM_1IV,
   OPCODE_UNIFORM_2IV,
   OPCODE_UNIFORM_3IV,
   OPCODE_UNIFORM_4IV,
   OPCODE_UNIFORM_MATRIX22,
   OPCODE_UNIFORM_MATRIX33,
   OPCODE_UNIFORM_MATRIX44,
   OPCODE_UNIFORM_MATRIX23,
   OPCODE_UNIFORM_MATRIX32,
   OPCODE_UNIFORM_MATRIX24,
   OPCODE_UNIFORM_MATRIX42,
   OPCODE_UNIFORM_MATRIX34,
   OPCODE_UNIFORM_MATRIX43,

   /* OpenGL 3.0 */
   OPCODE_UNIFORM_1UI,
   OPCODE_UNIFORM_2UI,
   OPCODE_UNIFORM_3UI,
   OPCODE_UNIFORM_4UI,
   OPCODE_UNIFORM_1UIV,
   OPCODE_UNIFORM_2UIV,
   OPCODE_UNIFORM_3UIV,
   OPCODE_UNIFORM_4UIV,

a353 17
   /* GL_EXT_provoking_vertex */
   OPCODE_PROVOKING_VERTEX,

   /* GL_EXT_transform_feedback */
   OPCODE_BEGIN_TRANSFORM_FEEDBACK,
   OPCODE_END_TRANSFORM_FEEDBACK,

   /* GL_EXT_texture_integer */
   OPCODE_CLEARCOLOR_I,
   OPCODE_CLEARCOLOR_UI,
   OPCODE_TEXPARAMETER_I,
   OPCODE_TEXPARAMETER_UI,

   /* GL_EXT_separate_shader_objects */
   OPCODE_ACTIVE_PROGRAM_EXT,
   OPCODE_USE_SHADER_PROGRAM_EXT,

d374 1
a374 1
union gl_dlist_node
a390 3
typedef union gl_dlist_node Node;


a405 4

#if FEATURE_dlist


d418 2
a419 2
static struct gl_display_list *
make_list(GLuint name, GLuint count)
d421 4
a424 4
   struct gl_display_list *dlist = CALLOC_STRUCT(gl_display_list);
   dlist->Name = name;
   dlist->Head = (Node *) malloc(sizeof(Node) * count);
   dlist->Head[0].opcode = OPCODE_END_OF_LIST;
d432 2
a433 2
static INLINE struct gl_display_list *
lookup_list(struct gl_context *ctx, GLuint list)
d435 1
a435 1
   return (struct gl_display_list *)
a439 43
/** Is the given opcode an extension code? */
static INLINE GLboolean
is_ext_opcode(OpCode opcode)
{
   return (opcode >= OPCODE_EXT_0);
}


/** Destroy an extended opcode instruction */
static GLint
ext_opcode_destroy(struct gl_context *ctx, Node *node)
{
   const GLint i = node[0].opcode - OPCODE_EXT_0;
   GLint step;
   ctx->ListExt->Opcode[i].Destroy(ctx, &node[1]);
   step = ctx->ListExt->Opcode[i].Size;
   return step;
}


/** Execute an extended opcode instruction */
static GLint
ext_opcode_execute(struct gl_context *ctx, Node *node)
{
   const GLint i = node[0].opcode - OPCODE_EXT_0;
   GLint step;
   ctx->ListExt->Opcode[i].Execute(ctx, &node[1]);
   step = ctx->ListExt->Opcode[i].Size;
   return step;
}


/** Print an extended opcode instruction */
static GLint
ext_opcode_print(struct gl_context *ctx, Node *node)
{
   const GLint i = node[0].opcode - OPCODE_EXT_0;
   GLint step;
   ctx->ListExt->Opcode[i].Print(ctx, &node[1]);
   step = ctx->ListExt->Opcode[i].Size;
   return step;
}

d446 1
a446 1
_mesa_delete_list(struct gl_context *ctx, struct gl_display_list *dlist)
d451 1
a451 1
   n = block = dlist->Head;
a454 1
      const OpCode opcode = n[0].opcode;
d457 5
a461 2
      if (is_ext_opcode(opcode)) {
         n += ext_opcode_destroy(ctx, n);
d464 1
a464 1
         switch (opcode) {
d467 1
a467 1
            free(n[6].data);
d471 1
a471 1
            free(n[10].data);
d475 1
a475 1
            free(n[5].data);
d479 1
a479 1
            free(n[7].data);
d483 1
a483 1
            free(n[6].data);
d487 1
a487 1
            free(n[6].data);
d491 1
a491 1
            free(n[6].data);
d495 1
a495 1
            free(n[7].data);
d499 1
a499 1
            free(n[1].data);
d503 1
a503 1
            free(n[8].data);
d507 1
a507 1
            free(n[9].data);
d511 1
a511 1
            free(n[10].data);
d515 1
a515 1
            free(n[7].data);
d519 1
a519 1
            free(n[9].data);
d523 1
a523 1
            free(n[11].data);
d527 1
a527 1
            free(n[7].data);
d531 1
a531 1
            free(n[8].data);
d535 1
a535 1
            free(n[9].data);
d539 1
a539 1
            free(n[7].data);
d543 1
a543 1
            free(n[9].data);
d547 1
a547 1
            free(n[11].data);
d552 1
a552 1
            free(n[4].data);      /* program string */
d556 1
a556 1
            free(n[2].data);      /* array of program ids */
d562 1
a562 1
            free(n[3].data);      /* parameter name */
d568 1
a568 1
            free(n[4].data);      /* program string */
a571 28
         case OPCODE_UNIFORM_1FV:
         case OPCODE_UNIFORM_2FV:
         case OPCODE_UNIFORM_3FV:
         case OPCODE_UNIFORM_4FV:
         case OPCODE_UNIFORM_1IV:
         case OPCODE_UNIFORM_2IV:
         case OPCODE_UNIFORM_3IV:
         case OPCODE_UNIFORM_4IV:
         case OPCODE_UNIFORM_1UIV:
         case OPCODE_UNIFORM_2UIV:
         case OPCODE_UNIFORM_3UIV:
         case OPCODE_UNIFORM_4UIV:
            free(n[3].data);
            n += InstSize[n[0].opcode];
            break;
         case OPCODE_UNIFORM_MATRIX22:
         case OPCODE_UNIFORM_MATRIX33:
         case OPCODE_UNIFORM_MATRIX44:
         case OPCODE_UNIFORM_MATRIX24:
         case OPCODE_UNIFORM_MATRIX42:
         case OPCODE_UNIFORM_MATRIX23:
         case OPCODE_UNIFORM_MATRIX32:
         case OPCODE_UNIFORM_MATRIX34:
         case OPCODE_UNIFORM_MATRIX43:
            free(n[4].data);
            n += InstSize[n[0].opcode];
            break;

d574 1
a574 1
            free(block);
d578 1
a578 1
            free(block);
d589 1
a589 1
   free(dlist);
d598 1
a598 1
destroy_list(struct gl_context *ctx, GLuint list)
d600 1
a600 1
   struct gl_display_list *dlist;
d615 1
a615 1
 * Translate the nth element of list from <type> to GLint.
d617 1
a617 1
static GLint
d631 1
a631 1
      return (GLint) bptr[n];
d634 1
a634 1
      return (GLint) ubptr[n];
d637 1
a637 1
      return (GLint) sptr[n];
d640 1
a640 1
      return (GLint) usptr[n];
d643 1
a643 1
      return iptr[n];
d646 1
a646 1
      return (GLint) uiptr[n];
d649 1
a649 1
      return (GLint) FLOORF(fptr[n]);
d652 1
a652 2
      return (GLint) ubptr[0] * 256
           + (GLint) ubptr[1];
d655 2
a656 3
      return (GLint) ubptr[0] * 65536
           + (GLint) ubptr[1] * 256
           + (GLint) ubptr[2];
d659 3
a661 4
      return (GLint) ubptr[0] * 16777216
           + (GLint) ubptr[1] * 65536
           + (GLint) ubptr[2] * 256
           + (GLint) ubptr[3];
d676 1
a676 1
 * If we run out of memory, GL_OUT_OF_MEMORY will be recorded.
d679 1
a679 2
unpack_image(struct gl_context *ctx, GLuint dimensions,
             GLsizei width, GLsizei height, GLsizei depth,
d683 1
a683 1
   if (!_mesa_is_bufferobj(unpack->BufferObj)) {
d685 9
a693 32
      GLvoid *image = _mesa_unpack_image(dimensions, width, height, depth,
                                         format, type, pixels, unpack);
      if (pixels && !image) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "display list construction");
      }
      return image;
   }
   else if (_mesa_validate_pbo_access(dimensions, unpack, width, height, depth,
                                      format, type, pixels)) {
      const GLubyte *map, *src;
      GLvoid *image;

      map = (GLubyte *)
         ctx->Driver.MapBuffer(ctx, GL_PIXEL_UNPACK_BUFFER_EXT,
                               GL_READ_ONLY_ARB, unpack->BufferObj);
      if (!map) {
         /* unable to map src buffer! */
         _mesa_error(ctx, GL_INVALID_OPERATION, "unable to map PBO");
         return NULL;
      }

      src = ADD_POINTERS(map, pixels);
      image = _mesa_unpack_image(dimensions, width, height, depth,
                                 format, type, src, unpack);

      ctx->Driver.UnmapBuffer(ctx, GL_PIXEL_UNPACK_BUFFER_EXT,
                              unpack->BufferObj);

      if (!image) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "display list construction");
      }
      return image;
d701 1
a701 1
 * Allocate space for a display list instruction (opcode + payload space).
d703 3
a705 2
 * \param bytes   instruction payload size (not counting opcode)
 * \return pointer to allocated memory (the opcode space)
d707 2
a708 2
static Node *
dlist_alloc(struct gl_context *ctx, OpCode opcode, GLuint bytes)
d729 1
a729 1
      newblock = (Node *) malloc(sizeof(Node) * BLOCK_SIZE);
d742 1
a742 5
   n[0].opcode = opcode;

   return n;
}

d744 1
a744 18

/**
 * Allocate space for a display list instruction.  Used by callers outside
 * this file for things like VBO vertex data.
 *
 * \param opcode  the instruction opcode (OPCODE_* value)
 * \param bytes   instruction size in bytes, not counting opcode.
 * \return pointer to the usable data area (not including the internal
 *         opcode).
 */
void *
_mesa_dlist_alloc(struct gl_context *ctx, GLuint opcode, GLuint bytes)
{
   Node *n = dlist_alloc(ctx, (OpCode) opcode, bytes);
   if (n)
      return n + 1;  /* return pointer to payload area, after opcode */
   else
      return NULL;
d759 9
a767 9
_mesa_dlist_alloc_opcode(struct gl_context *ctx,
                         GLuint size,
                         void (*execute) (struct gl_context *, void *),
                         void (*destroy) (struct gl_context *, void *),
                         void (*print) (struct gl_context *, void *))
{
   if (ctx->ListExt->NumOpcodes < MAX_DLIST_EXT_OPCODES) {
      const GLuint i = ctx->ListExt->NumOpcodes++;
      ctx->ListExt->Opcode[i].Size =
d769 3
a771 3
      ctx->ListExt->Opcode[i].Execute = execute;
      ctx->ListExt->Opcode[i].Destroy = destroy;
      ctx->ListExt->Opcode[i].Print = print;
d778 1
d780 5
a784 7
 * Allocate space for a display list instruction.  The space is basically
 * an array of Nodes where node[0] holds the opcode, node[1] is the first
 * function parameter, node[2] is the second parameter, etc.
 *
 * \param opcode  one of OPCODE_x
 * \param nparams  number of function parameters
 * \return  pointer to start of instruction space
d786 2
a787 5
static INLINE Node *
alloc_instruction(struct gl_context *ctx, OpCode opcode, GLuint nparams)
{
   return dlist_alloc(ctx, opcode, nparams * sizeof(Node));
}
d800 1
a800 1
   n = alloc_instruction(ctx, OPCODE_ACCUM, 2);
d817 1
a817 1
   n = alloc_instruction(ctx, OPCODE_ALPHA_FUNC, 2);
d834 1
a834 1
   n = alloc_instruction(ctx, OPCODE_BIND_TEXTURE, 2);
d851 1
d854 1
a854 1
   n = alloc_instruction(ctx, OPCODE_BITMAP, 7);
d862 4
a865 1
      n[7].data = _mesa_unpack_bitmap(width, height, pixels, &ctx->Unpack);
d880 1
a880 1
   n = alloc_instruction(ctx, OPCODE_BLEND_EQUATION, 1);
d896 1
a896 1
   n = alloc_instruction(ctx, OPCODE_BLEND_EQUATION_SEPARATE, 2);
d914 1
a914 1
   n = alloc_instruction(ctx, OPCODE_BLEND_FUNC_SEPARATE, 4);
a928 7
save_BlendFunc(GLenum srcfactor, GLenum dstfactor)
{
   save_BlendFuncSeparateEXT(srcfactor, dstfactor, srcfactor, dstfactor);
}


static void GLAPIENTRY
d934 1
a934 1
   n = alloc_instruction(ctx, OPCODE_BLEND_COLOR, 4);
a945 6
static void invalidate_saved_current_state( struct gl_context *ctx )
{
   GLint i;

   for (i = 0; i < VERT_ATTRIB_MAX; i++)
      ctx->ListState.ActiveAttribSize[i] = 0;
d947 2
a948 10
   for (i = 0; i < MAT_ATTRIB_MAX; i++)
      ctx->ListState.ActiveMaterialSize[i] = 0;

   memset(&ctx->ListState.Current, 0, sizeof ctx->ListState.Current);

   ctx->Driver.CurrentSavePrimitive = PRIM_UNKNOWN;
}

static void GLAPIENTRY
save_CallList(GLuint list)
d954 1
a954 1
   n = alloc_instruction(ctx, OPCODE_CALL_LIST, 1);
d959 1
a959 2
   /* After this, we don't know what state we're in.  Invalidate all
    * cached information previously gathered:
d961 1
a961 1
   invalidate_saved_current_state( ctx );
d964 1
a964 1
      _mesa_CallList(list);
d969 2
a970 2
static void GLAPIENTRY
save_CallLists(GLsizei num, GLenum type, const GLvoid * lists)
d995 3
a997 3
   for (i = 0; i < num; i++) {
      GLint list = translate_id(i, type, lists);
      Node *n = alloc_instruction(ctx, OPCODE_CALL_LIST_OFFSET, 2);
d999 1
a999 1
         n[1].i = list;
d1004 1
a1004 2
   /* After this, we don't know what state we're in.  Invalidate all
    * cached information previously gathered:
d1006 1
a1006 1
   invalidate_saved_current_state( ctx );
d1009 1
a1009 1
      CALL_CallLists(ctx->Exec, (num, type, lists));
d1020 1
a1020 1
   n = alloc_instruction(ctx, OPCODE_CLEAR, 1);
a1030 104
save_ClearBufferiv(GLenum buffer, GLint drawbuffer, const GLint *value)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_CLEAR_BUFFER_IV, 6);
   if (n) {
      n[1].e = buffer;
      n[2].i = drawbuffer;
      n[3].i = value[0];
      if (buffer == GL_COLOR) {
         n[4].i = value[1];
         n[5].i = value[2];
         n[6].i = value[3];
      }
      else {
         n[4].i = 0;
         n[5].i = 0;
         n[6].i = 0;
      }
   }
   if (ctx->ExecuteFlag) {
      /*CALL_ClearBufferiv(ctx->Exec, (buffer, drawbuffer, value));*/
   }
}


static void GLAPIENTRY
save_ClearBufferuiv(GLenum buffer, GLint drawbuffer, const GLuint *value)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_CLEAR_BUFFER_UIV, 6);
   if (n) {
      n[1].e = buffer;
      n[2].i = drawbuffer;
      n[3].ui = value[0];
      if (buffer == GL_COLOR) {
         n[4].ui = value[1];
         n[5].ui = value[2];
         n[6].ui = value[3];
      }
      else {
         n[4].ui = 0;
         n[5].ui = 0;
         n[6].ui = 0;
      }
   }
   if (ctx->ExecuteFlag) {
      /*CALL_ClearBufferuiv(ctx->Exec, (buffer, drawbuffer, value));*/
   }
}


static void GLAPIENTRY
save_ClearBufferfv(GLenum buffer, GLint drawbuffer, const GLfloat *value)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_CLEAR_BUFFER_FV, 6);
   if (n) {
      n[1].e = buffer;
      n[2].i = drawbuffer;
      n[3].f = value[0];
      if (buffer == GL_COLOR) {
         n[4].f = value[1];
         n[5].f = value[2];
         n[6].f = value[3];
      }
      else {
         n[4].f = 0.0F;
         n[5].f = 0.0F;
         n[6].f = 0.0F;
      }
   }
   if (ctx->ExecuteFlag) {
      /*CALL_ClearBufferuiv(ctx->Exec, (buffer, drawbuffer, value));*/
   }
}


static void GLAPIENTRY
save_ClearBufferfi(GLenum buffer, GLint drawbuffer,
                   GLfloat depth, GLint stencil)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_CLEAR_BUFFER_FI, 4);
   if (n) {
      n[1].e = buffer;
      n[2].i = drawbuffer;
      n[3].f = depth;
      n[4].i = stencil;
   }
   if (ctx->ExecuteFlag) {
      /*CALL_ClearBufferfi(ctx->Exec, (buffer, drawbuffer, depth, stencil));*/
   }
}


static void GLAPIENTRY
d1036 1
a1036 1
   n = alloc_instruction(ctx, OPCODE_CLEAR_ACCUM, 4);
d1055 1
a1055 1
   n = alloc_instruction(ctx, OPCODE_CLEAR_COLOR, 4);
d1074 1
a1074 1
   n = alloc_instruction(ctx, OPCODE_CLEAR_DEPTH, 1);
d1090 1
a1090 1
   n = alloc_instruction(ctx, OPCODE_CLEAR_INDEX, 1);
d1106 1
a1106 1
   n = alloc_instruction(ctx, OPCODE_CLEAR_STENCIL, 1);
d1122 1
a1122 1
   n = alloc_instruction(ctx, OPCODE_CLIP_PLANE, 5);
d1144 1
a1144 1
   n = alloc_instruction(ctx, OPCODE_COLOR_MASK, 4);
a1157 21
save_ColorMaskIndexed(GLuint buf, GLboolean red, GLboolean green,
                      GLboolean blue, GLboolean alpha)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_COLOR_MASK_INDEXED, 5);
   if (n) {
      n[1].ui = buf;
      n[2].b = red;
      n[3].b = green;
      n[4].b = blue;
      n[5].b = alpha;
   }
   if (ctx->ExecuteFlag) {
      /*CALL_ColorMaskIndexedEXT(ctx->Exec, (buf, red, green, blue, alpha));*/
   }
}


static void GLAPIENTRY
d1164 1
a1164 1
   n = alloc_instruction(ctx, OPCODE_COLOR_MATERIAL, 2);
d1187 2
d1191 1
a1191 1
      n = alloc_instruction(ctx, OPCODE_COLOR_TABLE, 6);
d1198 4
a1201 2
         n[6].data = unpack_image(ctx, 1, width, 1, 1, format, type, table,
                                  &ctx->Unpack);
d1221 1
a1221 1
   n = alloc_instruction(ctx, OPCODE_COLOR_TABLE_PARAMETER_FV, 6);
d1228 1
d1250 1
a1250 1
   n = alloc_instruction(ctx, OPCODE_COLOR_TABLE_PARAMETER_IV, 6);
d1257 1
d1277 2
d1281 1
a1281 1
   n = alloc_instruction(ctx, OPCODE_COLOR_SUB_TABLE, 6);
d1288 4
a1291 2
      n[6].data = unpack_image(ctx, 1, count, 1, 1, format, type, table,
                               &ctx->Unpack);
d1308 1
a1308 1
   n = alloc_instruction(ctx, OPCODE_COPY_COLOR_SUB_TABLE, 5);
d1330 1
a1330 1
   n = alloc_instruction(ctx, OPCODE_COPY_COLOR_TABLE, 5);
d1349 2
a1351 1

d1353 1
a1353 2

   n = alloc_instruction(ctx, OPCODE_CONVOLUTION_FILTER_1D, 6);
d1360 4
a1363 2
      n[6].data = unpack_image(ctx, 1, width, 1, 1, format, type, filter,
                               &ctx->Unpack);
d1378 2
a1380 1

d1382 1
a1382 2

   n = alloc_instruction(ctx, OPCODE_CONVOLUTION_FILTER_2D, 7);
d1390 4
a1393 2
      n[7].data = unpack_image(ctx, 2, width, height, 1, format, type, filter,
                               &ctx->Unpack);
d1409 1
a1409 1
   n = alloc_instruction(ctx, OPCODE_CONVOLUTION_PARAMETER_I, 3);
d1427 1
a1427 1
   n = alloc_instruction(ctx, OPCODE_CONVOLUTION_PARAMETER_IV, 6);
d1455 1
a1455 1
   n = alloc_instruction(ctx, OPCODE_CONVOLUTION_PARAMETER_F, 3);
d1474 1
a1474 1
   n = alloc_instruction(ctx, OPCODE_CONVOLUTION_PARAMETER_FV, 6);
d1502 1
a1502 1
   n = alloc_instruction(ctx, OPCODE_COPY_PIXELS, 5);
d1524 1
a1524 1
   n = alloc_instruction(ctx, OPCODE_COPY_TEX_IMAGE1D, 7);
d1550 1
a1550 1
   n = alloc_instruction(ctx, OPCODE_COPY_TEX_IMAGE2D, 8);
d1576 1
a1576 1
   n = alloc_instruction(ctx, OPCODE_COPY_TEX_SUB_IMAGE1D, 6);
d1600 1
a1600 1
   n = alloc_instruction(ctx, OPCODE_COPY_TEX_SUB_IMAGE2D, 8);
d1626 1
a1626 1
   n = alloc_instruction(ctx, OPCODE_COPY_TEX_SUB_IMAGE3D, 9);
d1652 1
a1652 1
   n = alloc_instruction(ctx, OPCODE_CULL_FACE, 1);
d1668 1
a1668 1
   n = alloc_instruction(ctx, OPCODE_DEPTH_FUNC, 1);
d1684 1
a1684 1
   n = alloc_instruction(ctx, OPCODE_DEPTH_MASK, 1);
d1700 1
a1700 1
   n = alloc_instruction(ctx, OPCODE_DEPTH_RANGE, 2);
d1717 1
a1717 1
   n = alloc_instruction(ctx, OPCODE_DISABLE, 1);
a1727 17
save_DisableIndexed(GLuint index, GLenum cap)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_DISABLE_INDEXED, 2);
   if (n) {
      n[1].ui = index;
      n[2].e = cap;
   }
   if (ctx->ExecuteFlag) {
      CALL_DisableIndexedEXT(ctx->Exec, (index, cap));
   }
}


static void GLAPIENTRY
d1733 1
a1733 1
   n = alloc_instruction(ctx, OPCODE_DRAW_BUFFER, 1);
d1748 2
a1750 1

d1752 1
a1752 2

   n = alloc_instruction(ctx, OPCODE_DRAW_PIXELS, 5);
d1758 4
a1761 2
      n[5].data = unpack_image(ctx, 2, width, height, 1, format, type,
                               pixels, &ctx->Unpack);
d1776 1
a1776 1
   n = alloc_instruction(ctx, OPCODE_ENABLE, 1);
d1788 1
a1788 19
save_EnableIndexed(GLuint index, GLenum cap)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_ENABLE_INDEXED, 2);
   if (n) {
      n[1].ui = index;
      n[2].e = cap;
   }
   if (ctx->ExecuteFlag) {
      CALL_EnableIndexedEXT(ctx->Exec, (index, cap));
   }
}



static void GLAPIENTRY
save_EvalMesh1(GLenum mode, GLint i1, GLint i2)
d1793 1
a1793 1
   n = alloc_instruction(ctx, OPCODE_EVALMESH1, 3);
d1806 1
a1806 1
save_EvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2)
d1811 1
a1811 1
   n = alloc_instruction(ctx, OPCODE_EVALMESH2, 5);
d1833 1
a1833 1
   n = alloc_instruction(ctx, OPCODE_FOG, 5);
d1850 1
a1850 4
   GLfloat parray[4];
   parray[0] = param;
   parray[1] = parray[2] = parray[3] = 0.0F;
   save_Fogfv(pname, parray);
a1864 3
      p[1] = 0.0f;
      p[2] = 0.0f;
      p[3] = 0.0f;
d1874 1
a1874 1
      ASSIGN_4V(p, 0.0F, 0.0F, 0.0F, 0.0F);
d1883 1
a1883 4
   GLint parray[4];
   parray[0] = param;
   parray[1] = parray[2] = parray[3] = 0;
   save_Fogiv(pname, parray);
d1893 1
a1893 1
   n = alloc_instruction(ctx, OPCODE_FRONT_FACE, 1);
d1910 1
a1910 1
   n = alloc_instruction(ctx, OPCODE_FRUSTUM, 6);
d1931 1
a1931 1
   n = alloc_instruction(ctx, OPCODE_HINT, 2);
d1950 1
a1950 1
   n = alloc_instruction(ctx, OPCODE_HISTOGRAM, 4);
d1969 1
a1969 1
   n = alloc_instruction(ctx, OPCODE_INDEX_MASK, 1);
d1984 1
a1984 1
   (void) alloc_instruction(ctx, OPCODE_INIT_NAMES, 0);
d1997 2
a1998 2
   n = alloc_instruction(ctx, OPCODE_LIGHT, 6);
   if (n) {
d2047 1
a2047 1
save_Lightf(GLenum light, GLenum pname, GLfloat param)
d2049 1
a2049 4
   GLfloat parray[4];
   parray[0] = param;
   parray[1] = parray[2] = parray[3] = 0.0F;
   save_Lightfv(light, pname, parray);
d2095 1
a2095 4
   GLint parray[4];
   parray[0] = param;
   parray[1] = parray[2] = parray[3] = 0;
   save_Lightiv(light, pname, parray);
d2105 1
a2105 1
   n = alloc_instruction(ctx, OPCODE_LIGHT_MODEL, 5);
d2122 1
a2122 4
   GLfloat parray[4];
   parray[0] = param;
   parray[1] = parray[2] = parray[3] = 0.0F;
   save_LightModelfv(pname, parray);
a2140 3
      fparam[1] = 0.0F;
      fparam[2] = 0.0F;
      fparam[3] = 0.0F;
d2144 1
a2144 1
      ASSIGN_4V(fparam, 0.0F, 0.0F, 0.0F, 0.0F);
d2153 1
a2153 4
   GLint parray[4];
   parray[0] = param;
   parray[1] = parray[2] = parray[3] = 0;
   save_LightModeliv(pname, parray);
d2163 1
a2163 1
   n = alloc_instruction(ctx, OPCODE_LINE_STIPPLE, 2);
d2180 1
a2180 1
   n = alloc_instruction(ctx, OPCODE_LINE_WIDTH, 1);
d2196 1
a2196 1
   n = alloc_instruction(ctx, OPCODE_LIST_BASE, 1);
d2211 1
a2211 1
   (void) alloc_instruction(ctx, OPCODE_LOAD_IDENTITY, 0);
d2224 1
a2224 1
   n = alloc_instruction(ctx, OPCODE_LOAD_MATRIX, 16);
d2255 1
a2255 1
   n = alloc_instruction(ctx, OPCODE_LOAD_NAME, 1);
d2271 1
a2271 1
   n = alloc_instruction(ctx, OPCODE_LOGIC_OP, 1);
d2288 1
a2288 1
   n = alloc_instruction(ctx, OPCODE_MAP1, 6);
d2310 1
a2310 1
   n = alloc_instruction(ctx, OPCODE_MAP1, 6);
d2335 1
a2335 1
   n = alloc_instruction(ctx, OPCODE_MAP2, 10);
d2368 1
a2368 1
   n = alloc_instruction(ctx, OPCODE_MAP2, 10);
d2397 1
a2397 1
   n = alloc_instruction(ctx, OPCODE_MAPGRID1, 3);
d2423 1
a2423 1
   n = alloc_instruction(ctx, OPCODE_MAPGRID2, 6);
d2454 1
a2454 1
   n = alloc_instruction(ctx, OPCODE_MATRIX_MODE, 1);
d2471 1
a2471 1
   n = alloc_instruction(ctx, OPCODE_MIN_MAX, 3);
d2489 1
a2489 1
   n = alloc_instruction(ctx, OPCODE_MULT_MATRIX, 16);
d2515 1
a2515 1
save_NewList(GLuint name, GLenum mode)
d2520 1
a2520 1
   (void) name;
d2533 1
a2533 1
   n = alloc_instruction(ctx, OPCODE_ORTHO, 6);
d2554 1
a2554 1
   n = alloc_instruction(ctx, OPCODE_PIXEL_MAP, 3);
d2558 2
a2559 2
      n[3].data = (void *) malloc(mapsize * sizeof(GLfloat));
      memcpy(n[3].data, (void *) values, mapsize * sizeof(GLfloat));
d2611 1
a2611 1
   n = alloc_instruction(ctx, OPCODE_PIXEL_TRANSFER, 2);
d2635 1
a2635 1
   n = alloc_instruction(ctx, OPCODE_PIXEL_ZOOM, 2);
d2652 1
a2652 1
   n = alloc_instruction(ctx, OPCODE_POINT_PARAMETERS, 4);
d2668 1
a2668 4
   GLfloat parray[3];
   parray[0] = param;
   parray[1] = parray[2] = 0.0F;
   save_PointParameterfvEXT(pname, parray);
d2674 2
a2675 4
   GLfloat parray[3];
   parray[0] = (GLfloat) param;
   parray[1] = parray[2] = 0.0F;
   save_PointParameterfvEXT(pname, parray);
d2681 2
a2682 4
   GLfloat parray[3];
   parray[0] = (GLfloat) param[0];
   parray[1] = parray[2] = 0.0F;
   save_PointParameterfvEXT(pname, parray);
d2692 1
a2692 1
   n = alloc_instruction(ctx, OPCODE_POINT_SIZE, 1);
d2708 1
a2708 1
   n = alloc_instruction(ctx, OPCODE_POLYGON_MODE, 2);
d2723 2
a2725 1

d2727 1
a2727 2

   n = alloc_instruction(ctx, OPCODE_POLYGON_STIPPLE, 1);
d2729 4
a2732 2
      n[1].data = unpack_image(ctx, 2, 32, 32, 1, GL_COLOR_INDEX, GL_BITMAP,
                               pattern, &ctx->Unpack);
d2746 1
a2746 1
   n = alloc_instruction(ctx, OPCODE_POLYGON_OFFSET, 2);
d2771 1
a2771 1
   (void) alloc_instruction(ctx, OPCODE_POP_ATTRIB, 0);
d2783 1
a2783 1
   (void) alloc_instruction(ctx, OPCODE_POP_MATRIX, 0);
d2795 1
a2795 1
   (void) alloc_instruction(ctx, OPCODE_POP_NAME, 0);
d2812 1
a2812 1
      n = alloc_instruction(ctx, OPCODE_PRIORITIZE_TEXTURE, 2);
d2830 1
a2830 1
   n = alloc_instruction(ctx, OPCODE_PUSH_ATTRIB, 1);
d2845 1
a2845 1
   (void) alloc_instruction(ctx, OPCODE_PUSH_MATRIX, 0);
d2858 1
a2858 1
   n = alloc_instruction(ctx, OPCODE_PUSH_NAME, 1);
d2874 1
a2874 1
   n = alloc_instruction(ctx, OPCODE_RASTER_POS, 4);
d3033 1
a3033 1
   n = alloc_instruction(ctx, OPCODE_PASSTHROUGH, 1);
d3049 1
a3049 1
   n = alloc_instruction(ctx, OPCODE_READ_BUFFER, 1);
d3065 1
a3065 1
   n = alloc_instruction(ctx, OPCODE_RESET_HISTOGRAM, 1);
d3081 1
a3081 1
   n = alloc_instruction(ctx, OPCODE_RESET_MIN_MAX, 1);
d3097 1
a3097 1
   n = alloc_instruction(ctx, OPCODE_ROTATE, 4);
d3123 1
a3123 1
   n = alloc_instruction(ctx, OPCODE_SCALE, 3);
d3148 1
a3148 1
   n = alloc_instruction(ctx, OPCODE_SCISSOR, 4);
d3166 5
a3170 2
   ASSERT_OUTSIDE_SAVE_BEGIN_END(ctx);

a3173 15

   if (ctx->ListState.Current.ShadeModel == mode)
      return;

   SAVE_FLUSH_VERTICES(ctx);

   /* Only save the value if we know the statechange will take effect:
    */
   if (ctx->Driver.CurrentSavePrimitive == PRIM_OUTSIDE_BEGIN_END)
      ctx->ListState.Current.ShadeModel = mode;

   n = alloc_instruction(ctx, OPCODE_SHADE_MODEL, 1);
   if (n) {
      n[1].e = mode;
   }
d3183 1
a3183 1
   n = alloc_instruction(ctx, OPCODE_STENCIL_FUNC, 3);
d3201 1
a3201 1
   n = alloc_instruction(ctx, OPCODE_STENCIL_MASK, 1);
d3217 1
a3217 1
   n = alloc_instruction(ctx, OPCODE_STENCIL_OP, 3);
d3235 1
a3235 1
   n = alloc_instruction(ctx, OPCODE_STENCIL_FUNC_SEPARATE, 4);
d3249 1
a3249 2
save_StencilFuncSeparateATI(GLenum frontfunc, GLenum backfunc, GLint ref,
                            GLuint mask)
d3254 1
a3254 2
   /* GL_FRONT */
   n = alloc_instruction(ctx, OPCODE_STENCIL_FUNC_SEPARATE, 4);
d3256 3
a3258 31
      n[1].e = GL_FRONT;
      n[2].e = frontfunc;
      n[3].i = ref;
      n[4].ui = mask;
   }
   /* GL_BACK */
   n = alloc_instruction(ctx, OPCODE_STENCIL_FUNC_SEPARATE, 4);
   if (n) {
      n[1].e = GL_BACK;
      n[2].e = backfunc;
      n[3].i = ref;
      n[4].ui = mask;
   }
   if (ctx->ExecuteFlag) {
      CALL_StencilFuncSeparate(ctx->Exec, (GL_FRONT, frontfunc, ref, mask));
      CALL_StencilFuncSeparate(ctx->Exec, (GL_BACK, backfunc, ref, mask));
   }
}


static void GLAPIENTRY
save_StencilMaskSeparate(GLenum face, GLuint mask)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_STENCIL_MASK_SEPARATE, 2);
   if (n) {
      n[1].e = face;
      n[2].ui = mask;
   }
d3271 1
a3271 1
   n = alloc_instruction(ctx, OPCODE_STENCIL_OP_SEPARATE, 4);
d3290 1
a3290 1
   n = alloc_instruction(ctx, OPCODE_TEXENV, 6);
d3314 1
a3314 4
   GLfloat parray[4];
   parray[0] = (GLfloat) param;
   parray[1] = parray[2] = parray[3] = 0.0F;
   save_TexEnvfv(target, pname, parray);
d3323 1
a3323 1
   p[1] = p[2] = p[3] = 0.0F;
d3352 1
a3352 1
   n = alloc_instruction(ctx, OPCODE_TEXGEN, 6);
d3382 2
a3383 4
   GLfloat parray[4];
   parray[0] = (GLfloat) param;
   parray[1] = parray[2] = parray[3] = 0.0F;
   save_TexGenfv(coord, pname, parray);
d3402 1
a3402 4
   GLfloat parray[4];
   parray[0] = param;
   parray[1] = parray[2] = parray[3] = 0.0F;
   save_TexGenfv(coord, pname, parray);
d3409 1
a3409 4
   GLint parray[4];
   parray[0] = param;
   parray[1] = parray[2] = parray[3] = 0;
   save_TexGeniv(coord, pname, parray);
d3419 1
a3419 1
   n = alloc_instruction(ctx, OPCODE_TEXPARAMETER, 6);
d3437 1
a3437 4
   GLfloat parray[4];
   parray[0] = param;
   parray[1] = parray[2] = parray[3] = 0.0F;
   save_TexParameterfv(target, pname, parray);
d3446 1
a3446 1
   fparam[1] = fparam[2] = fparam[3] = 0.0F;
d3456 1
a3456 1
   fparam[1] = fparam[2] = fparam[3] = 0.0F;
d3474 2
d3478 1
a3478 1
      n = alloc_instruction(ctx, OPCODE_TEX_IMAGE1D, 8);
d3487 4
a3490 2
         n[8].data = unpack_image(ctx, 1, width, 1, 1, format, type,
                                  pixels, &ctx->Unpack);
d3513 2
d3517 1
a3517 1
      n = alloc_instruction(ctx, OPCODE_TEX_IMAGE2D, 9);
d3527 4
a3530 2
         n[9].data = unpack_image(ctx, 2, width, height, 1, format, type,
                                  pixels, &ctx->Unpack);
d3556 2
d3559 1
a3559 1
      n = alloc_instruction(ctx, OPCODE_TEX_IMAGE3D, 10);
d3570 4
a3573 2
         n[10].data = unpack_image(ctx, 3, width, height, depth, format, type,
                                   pixels, &ctx->Unpack);
d3591 2
a3592 1

d3594 1
a3594 2

   n = alloc_instruction(ctx, OPCODE_TEX_SUB_IMAGE1D, 7);
d3602 4
a3605 2
      n[7].data = unpack_image(ctx, 1, width, 1, 1, format, type,
                               pixels, &ctx->Unpack);
d3622 2
a3623 1

d3625 1
a3625 2

   n = alloc_instruction(ctx, OPCODE_TEX_SUB_IMAGE2D, 9);
d3635 4
a3638 2
      n[9].data = unpack_image(ctx, 2, width, height, 1, format, type,
                               pixels, &ctx->Unpack);
d3655 2
a3656 1

d3658 1
a3658 2

   n = alloc_instruction(ctx, OPCODE_TEX_SUB_IMAGE3D, 11);
d3670 4
a3673 2
      n[11].data = unpack_image(ctx, 3, width, height, depth, format, type,
                                pixels, &ctx->Unpack);
d3690 1
a3690 1
   n = alloc_instruction(ctx, OPCODE_TRANSLATE, 3);
d3716 1
a3716 1
   n = alloc_instruction(ctx, OPCODE_VIEWPORT, 4);
d3735 1
a3735 1
   n = alloc_instruction(ctx, OPCODE_WINDOW_POS, 4);
d3896 1
a3896 1
   n = alloc_instruction(ctx, OPCODE_ACTIVE_TEXTURE, 1);
d3963 1
a3963 1
      image = malloc(imageSize);
d3968 2
a3969 2
      memcpy(image, data, imageSize);
      n = alloc_instruction(ctx, OPCODE_COMPRESSED_TEX_IMAGE_1D, 7);
d3980 1
a3980 1
         free(image);
d4009 1
a4009 1
      image = malloc(imageSize);
d4014 2
a4015 2
      memcpy(image, data, imageSize);
      n = alloc_instruction(ctx, OPCODE_COMPRESSED_TEX_IMAGE_2D, 8);
d4027 1
a4027 1
         free(image);
d4056 1
a4056 1
      image = malloc(imageSize);
d4061 2
a4062 2
      memcpy(image, data, imageSize);
      n = alloc_instruction(ctx, OPCODE_COMPRESSED_TEX_IMAGE_3D, 9);
d4075 1
a4075 1
         free(image);
d4099 1
a4099 1
   image = malloc(imageSize);
d4104 2
a4105 2
   memcpy(image, data, imageSize);
   n = alloc_instruction(ctx, OPCODE_COMPRESSED_TEX_SUB_IMAGE_1D, 7);
d4116 1
a4116 1
      free(image);
d4139 1
a4139 1
   image = malloc(imageSize);
d4144 2
a4145 2
   memcpy(image, data, imageSize);
   n = alloc_instruction(ctx, OPCODE_COMPRESSED_TEX_SUB_IMAGE_2D, 9);
d4158 1
a4158 1
      free(image);
d4181 1
a4181 1
   image = malloc(imageSize);
d4186 2
a4187 2
   memcpy(image, data, imageSize);
   n = alloc_instruction(ctx, OPCODE_COMPRESSED_TEX_SUB_IMAGE_3D, 11);
d4202 1
a4202 1
      free(image);
d4220 1
a4220 1
   n = alloc_instruction(ctx, OPCODE_SAMPLE_COVERAGE, 2);
d4241 1
a4241 1
   n = alloc_instruction(ctx, OPCODE_BIND_PROGRAM_NV, 2);
d4250 1
d4252 1
d4254 1
a4254 2
save_ProgramEnvParameter4fARB(GLenum target, GLuint index,
                              GLfloat x, GLfloat y, GLfloat z, GLfloat w)
d4259 1
a4259 1
   n = alloc_instruction(ctx, OPCODE_PROGRAM_ENV_PARAMETER_ARB, 6);
d4262 5
a4266 5
      n[2].ui = index;
      n[3].f = x;
      n[4].f = y;
      n[5].f = z;
      n[6].f = w;
d4269 1
a4269 1
      CALL_ProgramEnvParameter4fARB(ctx->Exec, (target, index, x, y, z, w));
d4275 2
a4276 11
save_ProgramEnvParameter4fvARB(GLenum target, GLuint index,
                               const GLfloat *params)
{
   save_ProgramEnvParameter4fARB(target, index, params[0], params[1],
                                 params[2], params[3]);
}


static void GLAPIENTRY
save_ProgramEnvParameters4fvEXT(GLenum target, GLuint index, GLsizei count,
				const GLfloat * params)
d4281 8
a4288 17

   if (count > 0) {
      GLint i;
      const GLfloat * p = params;

      for (i = 0 ; i < count ; i++) {
	 n = alloc_instruction(ctx, OPCODE_PROGRAM_ENV_PARAMETER_ARB, 6);
	 if (n) {
	    n[1].e = target;
	    n[2].ui = index;
	    n[3].f = p[0];
	    n[4].f = p[1];
	    n[5].f = p[2];
	    n[6].f = p[3];
	    p += 4;
	 }
      }
a4289 1

d4291 1
a4291 1
      CALL_ProgramEnvParameters4fvEXT(ctx->Exec, (target, index, count, params));
d4297 2
a4298 2
save_ProgramEnvParameter4dARB(GLenum target, GLuint index,
                              GLdouble x, GLdouble y, GLdouble z, GLdouble w)
d4300 2
a4301 3
   save_ProgramEnvParameter4fARB(target, index,
                                 (GLfloat) x,
                                 (GLfloat) y, (GLfloat) z, (GLfloat) w);
d4306 2
a4307 2
save_ProgramEnvParameter4dvARB(GLenum target, GLuint index,
                               const GLdouble *params)
d4309 2
a4310 4
   save_ProgramEnvParameter4fARB(target, index,
                                 (GLfloat) params[0],
                                 (GLfloat) params[1],
                                 (GLfloat) params[2], (GLfloat) params[3]);
a4312 1
#endif /* FEATURE_ARB_vertex_program || FEATURE_ARB_fragment_program || FEATURE_NV_vertex_program */
a4313 1
#if FEATURE_NV_vertex_program
d4315 2
a4316 1
save_ExecuteProgramNV(GLenum target, GLuint id, const GLfloat *params)
d4318 3
a4320 15
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_EXECUTE_PROGRAM_NV, 6);
   if (n) {
      n[1].e = target;
      n[2].ui = id;
      n[3].f = params[0];
      n[4].f = params[1];
      n[5].f = params[2];
      n[6].f = params[3];
   }
   if (ctx->ExecuteFlag) {
      CALL_ExecuteProgramNV(ctx->Exec, (target, id, params));
   }
d4326 1
a4326 1
                            GLsizei num, const GLdouble *params)
d4328 1
a4328 1
   GLint i;
d4330 1
a4330 1
      save_ProgramEnvParameter4dvARB(target, index + i, params + 4 * i);
d4337 1
a4337 1
                            GLsizei num, const GLfloat *params)
d4339 1
a4339 1
   GLint i;
d4341 1
a4341 1
      save_ProgramEnvParameter4fvARB(target, index + i, params + 4 * i);
d4352 8
d4362 1
a4362 2

   n = alloc_instruction(ctx, OPCODE_LOAD_PROGRAM_NV, 4);
a4363 6
      GLubyte *programCopy = (GLubyte *) malloc(len);
      if (!programCopy) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glLoadProgramNV");
         return;
      }
      memcpy(programCopy, program, len);
d4380 6
a4385 1

d4387 1
a4387 2

   n = alloc_instruction(ctx, OPCODE_TRACK_MATRIX_NV, 2);
a4388 6
      GLuint *idCopy = (GLuint *) malloc(num * sizeof(GLuint));
      if (!idCopy) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glRequestResidentProgramsNV");
         return;
      }
      memcpy(idCopy, ids, num * sizeof(GLuint));
d4405 1
a4405 1
   n = alloc_instruction(ctx, OPCODE_TRACK_MATRIX_NV, 4);
d4430 1
a4430 1
   n = alloc_instruction(ctx, OPCODE_PROGRAM_LOCAL_PARAMETER_ARB, 6);
d4452 1
a4452 1
   n = alloc_instruction(ctx, OPCODE_PROGRAM_LOCAL_PARAMETER_ARB, 6);
d4480 1
a4480 1
	 n = alloc_instruction(ctx, OPCODE_PROGRAM_LOCAL_PARAMETER_ARB, 6);
d4507 1
a4507 1
   n = alloc_instruction(ctx, OPCODE_PROGRAM_LOCAL_PARAMETER_ARB, 6);
d4529 1
a4529 1
   n = alloc_instruction(ctx, OPCODE_PROGRAM_LOCAL_PARAMETER_ARB, 6);
d4549 6
d4557 1
a4557 2

   n = alloc_instruction(ctx, OPCODE_PROGRAM_NAMED_PARAMETER_NV, 6);
a4558 6
      GLubyte *nameCopy = (GLubyte *) malloc(len);
      if (!nameCopy) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glProgramNamedParameter4fNV");
         return;
      }
      memcpy(nameCopy, name, len);
d4610 1
a4610 1
   n = alloc_instruction(ctx, OPCODE_ACTIVE_STENCIL_FACE_EXT, 1);
d4627 1
a4627 1
   n = alloc_instruction(ctx, OPCODE_DEPTH_BOUNDS_EXT, 2);
d4647 8
d4657 1
a4657 2

   n = alloc_instruction(ctx, OPCODE_PROGRAM_STRING_ARB, 4);
a4658 6
      GLubyte *programCopy = (GLubyte *) malloc(len);
      if (!programCopy) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glProgramStringARB");
         return;
      }
      memcpy(programCopy, string, len);
d4669 84
d4756 1
a4756 1
#if FEATURE_queryobj
d4764 1
a4764 1
   n = alloc_instruction(ctx, OPCODE_BEGIN_QUERY_ARB, 2);
d4781 1
a4781 1
   n = alloc_instruction(ctx, OPCODE_END_QUERY_ARB, 1);
d4790 1
a4790 1
#endif /* FEATURE_queryobj */
d4799 1
a4799 1
   n = alloc_instruction(ctx, OPCODE_DRAW_BUFFERS_ARB, 1 + MAX_DRAW_BUFFERS);
d4814 1
d4816 1
a4816 1
save_TexBumpParameterfvATI(GLenum pname, const GLfloat *param)
d4821 1
a4821 1
   n = alloc_instruction(ctx, OPCODE_TEX_BUMP_PARAMETER_ATI, 5);
d4823 1
a4823 5
      n[1].ui = pname;
      n[2].f = param[0];
      n[3].f = param[1];
      n[4].f = param[2];
      n[5].f = param[3];
d4826 1
a4826 1
      CALL_TexBumpParameterfvATI(ctx->Exec, (pname, param));
d4831 1
a4831 13
save_TexBumpParameterivATI(GLenum pname, const GLint *param)
{
   GLfloat p[4];
   p[0] = INT_TO_FLOAT(param[0]);
   p[1] = INT_TO_FLOAT(param[1]);
   p[2] = INT_TO_FLOAT(param[2]);
   p[3] = INT_TO_FLOAT(param[3]);
   save_TexBumpParameterfvATI(pname, p);
}

#if FEATURE_ATI_fragment_shader
static void GLAPIENTRY
save_BindFragmentShaderATI(GLuint id)
d4836 1
a4836 1
   n = alloc_instruction(ctx, OPCODE_BIND_FRAGMENT_SHADER_ATI, 1);
d4838 2
a4839 17
      n[1].ui = id;
   }
   if (ctx->ExecuteFlag) {
      CALL_BindFragmentShaderATI(ctx->Exec, (id));
   }
}

static void GLAPIENTRY
save_SetFragmentShaderConstantATI(GLuint dst, const GLfloat *value)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;

   n = alloc_instruction(ctx, OPCODE_SET_FRAGMENT_SHADER_CONSTANTS_ATI, 5);
   if (n) {
      n[1].ui = dst;
      n[2].f = value[0];
d4850 1
a4850 1
static void GLAPIENTRY
d4856 1
a4856 1
   n = alloc_instruction(ctx, OPCODE_ATTR_1F_NV, 2);
d4862 1
a4862 1
   ASSERT(attr < MAX_VERTEX_GENERIC_ATTRIBS);
d4871 1
a4871 1
static void GLAPIENTRY
d4877 1
a4877 1
   n = alloc_instruction(ctx, OPCODE_ATTR_2F_NV, 3);
d4884 1
a4884 1
   ASSERT(attr < MAX_VERTEX_GENERIC_ATTRIBS);
d4893 1
a4893 1
static void GLAPIENTRY
d4899 1
a4899 1
   n = alloc_instruction(ctx, OPCODE_ATTR_3F_NV, 4);
d4907 1
a4907 1
   ASSERT(attr < MAX_VERTEX_GENERIC_ATTRIBS);
d4916 1
a4916 1
static void GLAPIENTRY
d4922 1
a4922 1
   n = alloc_instruction(ctx, OPCODE_ATTR_4F_NV, 5);
d4931 1
a4931 1
   ASSERT(attr < MAX_VERTEX_GENERIC_ATTRIBS);
d4941 1
a4941 1
static void GLAPIENTRY
d4947 1
a4947 1
   n = alloc_instruction(ctx, OPCODE_ATTR_1F_ARB, 2);
d4953 1
a4953 1
   ASSERT(attr < MAX_VERTEX_GENERIC_ATTRIBS);
d4962 1
a4962 1
static void GLAPIENTRY
d4968 1
a4968 1
   n = alloc_instruction(ctx, OPCODE_ATTR_2F_ARB, 3);
d4975 1
a4975 1
   ASSERT(attr < MAX_VERTEX_GENERIC_ATTRIBS);
d4984 1
a4984 1
static void GLAPIENTRY
d4990 1
a4990 1
   n = alloc_instruction(ctx, OPCODE_ATTR_3F_ARB, 4);
d4998 1
a4998 1
   ASSERT(attr < MAX_VERTEX_GENERIC_ATTRIBS);
d5007 1
a5007 1
static void GLAPIENTRY
d5013 1
a5013 1
   n = alloc_instruction(ctx, OPCODE_ATTR_4F_ARB, 5);
d5022 1
a5022 1
   ASSERT(attr < MAX_VERTEX_GENERIC_ATTRIBS);
d5038 1
a5038 1
   n = alloc_instruction(ctx, OPCODE_EVAL_C1, 1);
d5059 1
a5059 1
   n = alloc_instruction(ctx, OPCODE_EVAL_C2, 2);
d5082 1
a5082 1
   n = alloc_instruction(ctx, OPCODE_EVAL_P1, 1);
d5097 1
a5097 1
   n = alloc_instruction(ctx, OPCODE_EVAL_P2, 2);
d5122 1
a5122 1
   save_Attr1fNV(VERT_ATTRIB_EDGEFLAG, x ? (GLfloat)1.0 : (GLfloat)0.0);
a5124 8
static INLINE GLboolean compare4fv( const GLfloat *a,
                                    const GLfloat *b,
                                    GLuint count )
{
   return memcmp( a, b, count * sizeof(GLfloat) ) == 0;
}
                              

d5131 2
a5132 1
   GLuint bitmask;
d5162 7
a5168 3
   
   if (ctx->ExecuteFlag) {
      CALL_Materialfv(ctx->Exec, (face, pname, param));
d5171 4
a5174 13
   bitmask = _mesa_material_bitmask(ctx, face, pname, ~0, NULL);

   /* Try to eliminate redundant statechanges.  Because it is legal to
    * call glMaterial even inside begin/end calls, don't need to worry
    * about ctx->Driver.CurrentSavePrimitive here.
    */
   for (i = 0; i < MAT_ATTRIB_MAX; i++) {
      if (bitmask & (1 << i)) {
         if (ctx->ListState.ActiveMaterialSize[i] == args &&
             compare4fv(ctx->ListState.CurrentMaterial[i], param, args)) {
            bitmask &= ~(1 << i);
         }
         else {
a5177 1
      }
d5180 2
a5181 13
   /* If this call has effect, return early:
    */
   if (bitmask == 0)
      return;

   SAVE_FLUSH_VERTICES(ctx);

   n = alloc_instruction(ctx, OPCODE_MATERIAL, 6);
   if (n) {
      n[1].e = face;
      n[2].e = pname;
      for (i = 0; i < args; i++)
         n[3 + i].f = param[i];
d5219 1
a5219 1
      n = alloc_instruction(ctx, OPCODE_BEGIN, 1);
d5235 1
a5235 1
   (void) alloc_instruction(ctx, OPCODE_END, 0);
d5248 1
a5248 1
   n = alloc_instruction(ctx, OPCODE_RECTF, 4);
d5485 1
a5485 1
   if (index < MAX_NV_VERTEX_PROGRAM_INPUTS)
d5494 1
a5494 1
   if (index < MAX_NV_VERTEX_PROGRAM_INPUTS)
d5503 1
a5503 1
   if (index < MAX_NV_VERTEX_PROGRAM_INPUTS)
d5512 1
a5512 1
   if (index < MAX_NV_VERTEX_PROGRAM_INPUTS)
d5521 1
a5521 1
   if (index < MAX_NV_VERTEX_PROGRAM_INPUTS)
d5530 1
a5530 1
   if (index < MAX_NV_VERTEX_PROGRAM_INPUTS)
d5540 1
a5540 1
   if (index < MAX_NV_VERTEX_PROGRAM_INPUTS)
d5549 1
a5549 1
   if (index < MAX_NV_VERTEX_PROGRAM_INPUTS)
d5561 1
a5561 1
   if (index < MAX_VERTEX_GENERIC_ATTRIBS)
d5570 1
a5570 1
   if (index < MAX_VERTEX_GENERIC_ATTRIBS)
d5579 1
a5579 1
   if (index < MAX_VERTEX_GENERIC_ATTRIBS)
d5588 1
a5588 1
   if (index < MAX_VERTEX_GENERIC_ATTRIBS)
d5595 1
a5595 775
save_VertexAttrib3fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z)
{
   if (index < MAX_VERTEX_GENERIC_ATTRIBS)
      save_Attr3fARB(index, x, y, z);
   else
      index_error();
}

static void GLAPIENTRY
save_VertexAttrib3fvARB(GLuint index, const GLfloat * v)
{
   if (index < MAX_VERTEX_GENERIC_ATTRIBS)
      save_Attr3fARB(index, v[0], v[1], v[2]);
   else
      index_error();
}

static void GLAPIENTRY
save_VertexAttrib4fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z,
                       GLfloat w)
{
   if (index < MAX_VERTEX_GENERIC_ATTRIBS)
      save_Attr4fARB(index, x, y, z, w);
   else
      index_error();
}

static void GLAPIENTRY
save_VertexAttrib4fvARB(GLuint index, const GLfloat * v)
{
   if (index < MAX_VERTEX_GENERIC_ATTRIBS)
      save_Attr4fARB(index, v[0], v[1], v[2], v[3]);
   else
      index_error();
}


/* GL_ARB_shader_objects, GL_ARB_vertex/fragment_shader */

static void GLAPIENTRY
exec_BindAttribLocationARB(GLuint program, GLuint index, const GLchar *name)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_BindAttribLocationARB(ctx->Exec, (program, index, name));
}

static GLint GLAPIENTRY
exec_GetAttribLocationARB(GLuint program, const GLchar *name)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   return CALL_GetAttribLocationARB(ctx->Exec, (program, name));
}

static GLint GLAPIENTRY
exec_GetUniformLocationARB(GLuint program, const GLchar *name)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   return CALL_GetUniformLocationARB(ctx->Exec, (program, name));
}
/* XXX more shader functions needed here */


#if FEATURE_EXT_framebuffer_blit
static void GLAPIENTRY
save_BlitFramebufferEXT(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1,
                        GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1,
                        GLbitfield mask, GLenum filter)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_BLIT_FRAMEBUFFER, 10);
   if (n) {
      n[1].i = srcX0;
      n[2].i = srcY0;
      n[3].i = srcX1;
      n[4].i = srcY1;
      n[5].i = dstX0;
      n[6].i = dstY0;
      n[7].i = dstX1;
      n[8].i = dstY1;
      n[9].i = mask;
      n[10].e = filter;
   }
   if (ctx->ExecuteFlag) {
      CALL_BlitFramebufferEXT(ctx->Exec, (srcX0, srcY0, srcX1, srcY1,
                                          dstX0, dstY0, dstX1, dstY1,
                                          mask, filter));
   }
}
#endif


/** GL_EXT_provoking_vertex */
static void GLAPIENTRY
save_ProvokingVertexEXT(GLenum mode)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_PROVOKING_VERTEX, 1);
   if (n) {
      n[1].e = mode;
   }
   if (ctx->ExecuteFlag) {
      /*CALL_ProvokingVertexEXT(ctx->Exec, (mode));*/
      _mesa_ProvokingVertexEXT(mode);
   }
}


/** GL_EXT_transform_feedback */
static void GLAPIENTRY
save_BeginTransformFeedback(GLenum mode)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_BEGIN_TRANSFORM_FEEDBACK, 1);
   if (n) {
      n[1].e = mode;
   }
   if (ctx->ExecuteFlag) {
      CALL_BeginTransformFeedbackEXT(ctx->Exec, (mode));
   }
}


/** GL_EXT_transform_feedback */
static void GLAPIENTRY
save_EndTransformFeedback(void)
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   (void) alloc_instruction(ctx, OPCODE_END_TRANSFORM_FEEDBACK, 0);
   if (ctx->ExecuteFlag) {
      CALL_EndTransformFeedbackEXT(ctx->Exec, ());
   }
}


/* aka UseProgram() */
static void GLAPIENTRY
save_UseProgramObjectARB(GLhandleARB program)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_USE_PROGRAM, 1);
   if (n) {
      n[1].ui = program;
   }
   if (ctx->ExecuteFlag) {
      CALL_UseProgramObjectARB(ctx->Exec, (program));
   }
}


static void GLAPIENTRY
save_Uniform1fARB(GLint location, GLfloat x)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_1F, 2);
   if (n) {
      n[1].i = location;
      n[2].f = x;
   }
   if (ctx->ExecuteFlag) {
      CALL_Uniform1fARB(ctx->Exec, (location, x));
   }
}


static void GLAPIENTRY
save_Uniform2fARB(GLint location, GLfloat x, GLfloat y)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_2F, 3);
   if (n) {
      n[1].i = location;
      n[2].f = x;
      n[3].f = y;
   }
   if (ctx->ExecuteFlag) {
      CALL_Uniform2fARB(ctx->Exec, (location, x, y));
   }
}


static void GLAPIENTRY
save_Uniform3fARB(GLint location, GLfloat x, GLfloat y, GLfloat z)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_3F, 4);
   if (n) {
      n[1].i = location;
      n[2].f = x;
      n[3].f = y;
      n[4].f = z;
   }
   if (ctx->ExecuteFlag) {
      CALL_Uniform3fARB(ctx->Exec, (location, x, y, z));
   }
}


static void GLAPIENTRY
save_Uniform4fARB(GLint location, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_4F, 5);
   if (n) {
      n[1].i = location;
      n[2].f = x;
      n[3].f = y;
      n[4].f = z;
      n[5].f = w;
   }
   if (ctx->ExecuteFlag) {
      CALL_Uniform4fARB(ctx->Exec, (location, x, y, z, w));
   }
}


/** Return copy of memory */
static void *
memdup(const void *src, GLsizei bytes)
{
   void *b = bytes >= 0 ? malloc(bytes) : NULL;
   if (b)
      memcpy(b, src, bytes);
   return b;
}


static void GLAPIENTRY
save_Uniform1fvARB(GLint location, GLsizei count, const GLfloat *v)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_1FV, 3);
   if (n) {
      n[1].i = location;
      n[2].i = count;
      n[3].data = memdup(v, count * 1 * sizeof(GLfloat));
   }
   if (ctx->ExecuteFlag) {
      CALL_Uniform1fvARB(ctx->Exec, (location, count, v));
   }
}

static void GLAPIENTRY
save_Uniform2fvARB(GLint location, GLsizei count, const GLfloat *v)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_2FV, 3);
   if (n) {
      n[1].i = location;
      n[2].i = count;
      n[3].data = memdup(v, count * 2 * sizeof(GLfloat));
   }
   if (ctx->ExecuteFlag) {
      CALL_Uniform2fvARB(ctx->Exec, (location, count, v));
   }
}

static void GLAPIENTRY
save_Uniform3fvARB(GLint location, GLsizei count, const GLfloat *v)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_3FV, 3);
   if (n) {
      n[1].i = location;
      n[2].i = count;
      n[3].data = memdup(v, count * 3 * sizeof(GLfloat));
   }
   if (ctx->ExecuteFlag) {
      CALL_Uniform3fvARB(ctx->Exec, (location, count, v));
   }
}

static void GLAPIENTRY
save_Uniform4fvARB(GLint location, GLsizei count, const GLfloat *v)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_4FV, 3);
   if (n) {
      n[1].i = location;
      n[2].i = count;
      n[3].data = memdup(v, count * 4 * sizeof(GLfloat));
   }
   if (ctx->ExecuteFlag) {
      CALL_Uniform4fvARB(ctx->Exec, (location, count, v));
   }
}


static void GLAPIENTRY
save_Uniform1iARB(GLint location, GLint x)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_1I, 2);
   if (n) {
      n[1].i = location;
      n[2].i = x;
   }
   if (ctx->ExecuteFlag) {
      CALL_Uniform1iARB(ctx->Exec, (location, x));
   }
}

static void GLAPIENTRY
save_Uniform2iARB(GLint location, GLint x, GLint y)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_2I, 3);
   if (n) {
      n[1].i = location;
      n[2].i = x;
      n[3].i = y;
   }
   if (ctx->ExecuteFlag) {
      CALL_Uniform2iARB(ctx->Exec, (location, x, y));
   }
}

static void GLAPIENTRY
save_Uniform3iARB(GLint location, GLint x, GLint y, GLint z)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_3I, 4);
   if (n) {
      n[1].i = location;
      n[2].i = x;
      n[3].i = y;
      n[4].i = z;
   }
   if (ctx->ExecuteFlag) {
      CALL_Uniform3iARB(ctx->Exec, (location, x, y, z));
   }
}

static void GLAPIENTRY
save_Uniform4iARB(GLint location, GLint x, GLint y, GLint z, GLint w)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_4I, 5);
   if (n) {
      n[1].i = location;
      n[2].i = x;
      n[3].i = y;
      n[4].i = z;
      n[5].i = w;
   }
   if (ctx->ExecuteFlag) {
      CALL_Uniform4iARB(ctx->Exec, (location, x, y, z, w));
   }
}



static void GLAPIENTRY
save_Uniform1ivARB(GLint location, GLsizei count, const GLint *v)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_1IV, 3);
   if (n) {
      n[1].i = location;
      n[2].i = count;
      n[3].data = memdup(v, count * 1 * sizeof(GLint));
   }
   if (ctx->ExecuteFlag) {
      CALL_Uniform1ivARB(ctx->Exec, (location, count, v));
   }
}

static void GLAPIENTRY
save_Uniform2ivARB(GLint location, GLsizei count, const GLint *v)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_2IV, 3);
   if (n) {
      n[1].i = location;
      n[2].i = count;
      n[3].data = memdup(v, count * 2 * sizeof(GLint));
   }
   if (ctx->ExecuteFlag) {
      CALL_Uniform2ivARB(ctx->Exec, (location, count, v));
   }
}

static void GLAPIENTRY
save_Uniform3ivARB(GLint location, GLsizei count, const GLint *v)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_3IV, 3);
   if (n) {
      n[1].i = location;
      n[2].i = count;
      n[3].data = memdup(v, count * 3 * sizeof(GLint));
   }
   if (ctx->ExecuteFlag) {
      CALL_Uniform3ivARB(ctx->Exec, (location, count, v));
   }
}

static void GLAPIENTRY
save_Uniform4ivARB(GLint location, GLsizei count, const GLint *v)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_4IV, 3);
   if (n) {
      n[1].i = location;
      n[2].i = count;
      n[3].data = memdup(v, count * 4 * sizeof(GLfloat));
   }
   if (ctx->ExecuteFlag) {
      CALL_Uniform4ivARB(ctx->Exec, (location, count, v));
   }
}



static void GLAPIENTRY
save_Uniform1ui(GLint location, GLuint x)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_1UI, 2);
   if (n) {
      n[1].i = location;
      n[2].i = x;
   }
   if (ctx->ExecuteFlag) {
      /*CALL_Uniform1ui(ctx->Exec, (location, x));*/
   }
}

static void GLAPIENTRY
save_Uniform2ui(GLint location, GLuint x, GLuint y)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_2UI, 3);
   if (n) {
      n[1].i = location;
      n[2].i = x;
      n[3].i = y;
   }
   if (ctx->ExecuteFlag) {
      /*CALL_Uniform2ui(ctx->Exec, (location, x, y));*/
   }
}

static void GLAPIENTRY
save_Uniform3ui(GLint location, GLuint x, GLuint y, GLuint z)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_3UI, 4);
   if (n) {
      n[1].i = location;
      n[2].i = x;
      n[3].i = y;
      n[4].i = z;
   }
   if (ctx->ExecuteFlag) {
      /*CALL_Uniform3ui(ctx->Exec, (location, x, y, z));*/
   }
}

static void GLAPIENTRY
save_Uniform4ui(GLint location, GLuint x, GLuint y, GLuint z, GLuint w)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_4UI, 5);
   if (n) {
      n[1].i = location;
      n[2].i = x;
      n[3].i = y;
      n[4].i = z;
      n[5].i = w;
   }
   if (ctx->ExecuteFlag) {
      /*CALL_Uniform4ui(ctx->Exec, (location, x, y, z, w));*/
   }
}



static void GLAPIENTRY
save_Uniform1uiv(GLint location, GLsizei count, const GLuint *v)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_1UIV, 3);
   if (n) {
      n[1].i = location;
      n[2].i = count;
      n[3].data = memdup(v, count * 1 * sizeof(*v));
   }
   if (ctx->ExecuteFlag) {
      /*CALL_Uniform1uiv(ctx->Exec, (location, count, v));*/
   }
}

static void GLAPIENTRY
save_Uniform2uiv(GLint location, GLsizei count, const GLuint *v)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_2UIV, 3);
   if (n) {
      n[1].i = location;
      n[2].i = count;
      n[3].data = memdup(v, count * 2 * sizeof(*v));
   }
   if (ctx->ExecuteFlag) {
      /*CALL_Uniform2uiv(ctx->Exec, (location, count, v));*/
   }
}

static void GLAPIENTRY
save_Uniform3uiv(GLint location, GLsizei count, const GLuint *v)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_3UIV, 3);
   if (n) {
      n[1].i = location;
      n[2].i = count;
      n[3].data = memdup(v, count * 3 * sizeof(*v));
   }
   if (ctx->ExecuteFlag) {
      /*CALL_Uniform3uiv(ctx->Exec, (location, count, v));*/
   }
}

static void GLAPIENTRY
save_Uniform4uiv(GLint location, GLsizei count, const GLuint *v)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_4UIV, 3);
   if (n) {
      n[1].i = location;
      n[2].i = count;
      n[3].data = memdup(v, count * 4 * sizeof(*v));
   }
   if (ctx->ExecuteFlag) {
      /*CALL_Uniform4uiv(ctx->Exec, (location, count, v));*/
   }
}



static void GLAPIENTRY
save_UniformMatrix2fvARB(GLint location, GLsizei count, GLboolean transpose,
                         const GLfloat *m)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_MATRIX22, 4);
   if (n) {
      n[1].i = location;
      n[2].i = count;
      n[3].b = transpose;
      n[4].data = memdup(m, count * 2 * 2 * sizeof(GLfloat));
   }
   if (ctx->ExecuteFlag) {
      CALL_UniformMatrix2fvARB(ctx->Exec, (location, count, transpose, m));
   }
}

static void GLAPIENTRY
save_UniformMatrix3fvARB(GLint location, GLsizei count, GLboolean transpose,
                         const GLfloat *m)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_MATRIX33, 4);
   if (n) {
      n[1].i = location;
      n[2].i = count;
      n[3].b = transpose;
      n[4].data = memdup(m, count * 3 * 3 * sizeof(GLfloat));
   }
   if (ctx->ExecuteFlag) {
      CALL_UniformMatrix3fvARB(ctx->Exec, (location, count, transpose, m));
   }
}

static void GLAPIENTRY
save_UniformMatrix4fvARB(GLint location, GLsizei count, GLboolean transpose,
                         const GLfloat *m)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_MATRIX44, 4);
   if (n) {
      n[1].i = location;
      n[2].i = count;
      n[3].b = transpose;
      n[4].data = memdup(m, count * 4 * 4 * sizeof(GLfloat));
   }
   if (ctx->ExecuteFlag) {
      CALL_UniformMatrix4fvARB(ctx->Exec, (location, count, transpose, m));
   }
}


static void GLAPIENTRY
save_UniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose,
                        const GLfloat *m)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_MATRIX23, 4);
   if (n) {
      n[1].i = location;
      n[2].i = count;
      n[3].b = transpose;
      n[4].data = memdup(m, count * 2 * 3 * sizeof(GLfloat));
   }
   if (ctx->ExecuteFlag) {
      CALL_UniformMatrix2x3fv(ctx->Exec, (location, count, transpose, m));
   }
}

static void GLAPIENTRY
save_UniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose,
                        const GLfloat *m)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_MATRIX32, 4);
   if (n) {
      n[1].i = location;
      n[2].i = count;
      n[3].b = transpose;
      n[4].data = memdup(m, count * 3 * 2 * sizeof(GLfloat));
   }
   if (ctx->ExecuteFlag) {
      CALL_UniformMatrix3x2fv(ctx->Exec, (location, count, transpose, m));
   }
}


static void GLAPIENTRY
save_UniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose,
                        const GLfloat *m)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_MATRIX24, 4);
   if (n) {
      n[1].i = location;
      n[2].i = count;
      n[3].b = transpose;
      n[4].data = memdup(m, count * 2 * 4 * sizeof(GLfloat));
   }
   if (ctx->ExecuteFlag) {
      CALL_UniformMatrix2x4fv(ctx->Exec, (location, count, transpose, m));
   }
}

static void GLAPIENTRY
save_UniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose,
                        const GLfloat *m)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_MATRIX42, 4);
   if (n) {
      n[1].i = location;
      n[2].i = count;
      n[3].b = transpose;
      n[4].data = memdup(m, count * 4 * 2 * sizeof(GLfloat));
   }
   if (ctx->ExecuteFlag) {
      CALL_UniformMatrix4x2fv(ctx->Exec, (location, count, transpose, m));
   }
}


static void GLAPIENTRY
save_UniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose,
                        const GLfloat *m)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_MATRIX34, 4);
   if (n) {
      n[1].i = location;
      n[2].i = count;
      n[3].b = transpose;
      n[4].data = memdup(m, count * 3 * 4 * sizeof(GLfloat));
   }
   if (ctx->ExecuteFlag) {
      CALL_UniformMatrix3x4fv(ctx->Exec, (location, count, transpose, m));
   }
}

static void GLAPIENTRY
save_UniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose,
                        const GLfloat *m)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_MATRIX43, 4);
   if (n) {
      n[1].i = location;
      n[2].i = count;
      n[3].b = transpose;
      n[4].data = memdup(m, count * 4 * 3 * sizeof(GLfloat));
   }
   if (ctx->ExecuteFlag) {
      CALL_UniformMatrix4x3fv(ctx->Exec, (location, count, transpose, m));
   }
}

static void GLAPIENTRY
save_UseShaderProgramEXT(GLenum type, GLuint program)
d5597 4
a5600 11
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_USE_SHADER_PROGRAM_EXT, 2);
   if (n) {
      n[1].ui = type;
      n[2].ui = program;
   }
   if (ctx->ExecuteFlag) {
      CALL_UseShaderProgramEXT(ctx->Exec, (type, program));
   }
d5604 1
a5604 1
save_ActiveProgramEXT(GLuint program)
d5606 4
a5609 10
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_ACTIVE_PROGRAM_EXT, 1);
   if (n) {
      n[1].ui = program;
   }
   if (ctx->ExecuteFlag) {
      CALL_ActiveProgramEXT(ctx->Exec, (program));
   }
a5611 1
/** GL_EXT_texture_integer */
d5613 2
a5614 1
save_ClearColorIi(GLint red, GLint green, GLint blue, GLint alpha)
d5616 4
a5619 13
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_CLEARCOLOR_I, 4);
   if (n) {
      n[1].i = red;
      n[2].i = green;
      n[3].i = blue;
      n[4].i = alpha;
   }
   if (ctx->ExecuteFlag) {
      CALL_ClearColorIiEXT(ctx->Exec, (red, green, blue, alpha));
   }
a5621 1
/** GL_EXT_texture_integer */
d5623 1
a5623 1
save_ClearColorIui(GLuint red, GLuint green, GLuint blue, GLuint alpha)
d5625 4
a5628 13
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_CLEARCOLOR_UI, 4);
   if (n) {
      n[1].ui = red;
      n[2].ui = green;
      n[3].ui = blue;
      n[4].ui = alpha;
   }
   if (ctx->ExecuteFlag) {
      CALL_ClearColorIuiEXT(ctx->Exec, (red, green, blue, alpha));
   }
a5630 20
/** GL_EXT_texture_integer */
static void GLAPIENTRY
save_TexParameterIiv(GLenum target, GLenum pname, const GLint *params)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_TEXPARAMETER_I, 6);
   if (n) {
      n[1].e = target;
      n[2].e = pname;
      n[3].i = params[0];
      n[4].i = params[1];
      n[5].i = params[2];
      n[6].i = params[3];
   }
   if (ctx->ExecuteFlag) {
      CALL_TexParameterIivEXT(ctx->Exec, (target, pname, params));
   }
}
d5632 1
a5632 1
/** GL_EXT_texture_integer */
d5634 3
a5636 1
save_TexParameterIuiv(GLenum target, GLenum pname, const GLuint *params)
d5641 1
a5641 1
   n = alloc_instruction(ctx, OPCODE_TEXPARAMETER_UI, 6);
d5643 10
a5652 6
      n[1].e = target;
      n[2].e = pname;
      n[3].ui = params[0];
      n[4].ui = params[1];
      n[5].ui = params[2];
      n[6].ui = params[3];
d5655 3
a5657 1
      CALL_TexParameterIuivEXT(ctx->Exec, (target, pname, params));
d5660 1
a5660 21

/** GL_EXT_texture_integer */
static void GLAPIENTRY
exec_GetTexParameterIiv(GLenum target, GLenum pname, GLint *params)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_GetTexParameterIivEXT(ctx->Exec, (target, pname, params));
}

/** GL_EXT_texture_integer */
static void GLAPIENTRY
exec_GetTexParameterIuiv(GLenum target, GLenum pname, GLuint *params)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);
   CALL_GetTexParameterIuivEXT(ctx->Exec, (target, pname, params));
}



d5670 1
a5670 1
save_error(struct gl_context *ctx, GLenum error, const char *s)
d5673 1
a5673 1
   n = alloc_instruction(ctx, OPCODE_ERROR, 2);
d5685 1
a5685 1
_mesa_compile_error(struct gl_context *ctx, GLenum error, const char *s)
d5690 1
a5690 1
      _mesa_error(ctx, error, "%s", s);
d5698 1
a5698 1
islist(struct gl_context *ctx, GLuint list)
d5722 1
a5722 1
execute_list(struct gl_context *ctx, GLuint list)
d5724 1
a5724 1
   struct gl_display_list *dlist;
d5740 1
a5740 1
   ctx->ListState.CallDepth++;
d5745 1
a5745 1
   n = dlist->Head;
d5749 2
a5750 1
      const OpCode opcode = n[0].opcode;
d5752 4
a5755 2
      if (is_ext_opcode(opcode)) {
         n += ext_opcode_execute(ctx, n);
d5760 1
a5760 1
            _mesa_error(ctx, n[1].e, "%s", (const char *) n[2].data);
d5807 1
a5807 2
               GLuint list = (GLuint) (ctx->List.ListBase + n[1].i);
               execute_list(ctx, list);
a5812 33
         case OPCODE_CLEAR_BUFFER_IV:
            {
               GLint value[4];
               value[0] = n[3].i;
               value[1] = n[4].i;
               value[2] = n[5].i;
               value[3] = n[6].i;
               /*CALL_ClearBufferiv(ctx->Exec, (n[1].e, n[2].i, value));*/
            }
            break;
         case OPCODE_CLEAR_BUFFER_UIV:
            {
               GLuint value[4];
               value[0] = n[3].ui;
               value[1] = n[4].ui;
               value[2] = n[5].ui;
               value[3] = n[6].ui;
               /*CALL_ClearBufferiv(ctx->Exec, (n[1].e, n[2].i, value));*/
            }
            break;
         case OPCODE_CLEAR_BUFFER_FV:
            {
               GLfloat value[4];
               value[0] = n[3].f;
               value[1] = n[4].f;
               value[2] = n[5].f;
               value[3] = n[6].f;
               /*CALL_ClearBufferfv(ctx->Exec, (n[1].e, n[2].i, value));*/
            }
            break;
         case OPCODE_CLEAR_BUFFER_FI:
            /*CALL_ClearBufferfi(ctx->Exec, (n[1].e, n[2].i, n[3].f, n[4].i));*/
            break;
a5840 4
         case OPCODE_COLOR_MASK_INDEXED:
            CALL_ColorMaskIndexedEXT(ctx->Exec, (n[1].ui, n[2].b, n[3].b,
                                                 n[4].b, n[5].b));
            break;
a5982 3
         case OPCODE_DISABLE_INDEXED:
            CALL_DisableIndexedEXT(ctx->Exec, (n[1].ui, n[2].e));
            break;
a5997 3
         case OPCODE_ENABLE_INDEXED:
            CALL_EnableIndexedEXT(ctx->Exec, (n[1].ui, n[2].e));
            break;
a6225 9
         case OPCODE_PROVOKING_VERTEX:
            CALL_ProvokingVertexEXT(ctx->Exec, (n[1].e));
            break;
         case OPCODE_BEGIN_TRANSFORM_FEEDBACK:
            CALL_BeginTransformFeedbackEXT(ctx->Exec, (n[1].e));
            break;
         case OPCODE_END_TRANSFORM_FEEDBACK:
            CALL_EndTransformFeedbackEXT(ctx->Exec, ());
            break;
d6432 4
a6465 2
#endif
#if FEATURE_ARB_vertex_program || FEATURE_ARB_fragment_program || FEATURE_NV_vertex_program
d6472 1
a6472 1
#if FEATURE_queryobj
a6495 133

	 case OPCODE_USE_PROGRAM:
	    CALL_UseProgramObjectARB(ctx->Exec, (n[1].ui));
	    break;
	 case OPCODE_USE_SHADER_PROGRAM_EXT:
	    CALL_UseShaderProgramEXT(ctx->Exec, (n[1].ui, n[2].ui));
	    break;
	 case OPCODE_ACTIVE_PROGRAM_EXT:
	    CALL_ActiveProgramEXT(ctx->Exec, (n[1].ui));
	    break;
	 case OPCODE_UNIFORM_1F:
	    CALL_Uniform1fARB(ctx->Exec, (n[1].i, n[2].f));
	    break;
	 case OPCODE_UNIFORM_2F:
	    CALL_Uniform2fARB(ctx->Exec, (n[1].i, n[2].f, n[3].f));
	    break;
	 case OPCODE_UNIFORM_3F:
	    CALL_Uniform3fARB(ctx->Exec, (n[1].i, n[2].f, n[3].f, n[4].f));
	    break;
	 case OPCODE_UNIFORM_4F:
	    CALL_Uniform4fARB(ctx->Exec,
                              (n[1].i, n[2].f, n[3].f, n[4].f, n[5].f));
	    break;
	 case OPCODE_UNIFORM_1FV:
	    CALL_Uniform1fvARB(ctx->Exec, (n[1].i, n[2].i, n[3].data));
	    break;
	 case OPCODE_UNIFORM_2FV:
	    CALL_Uniform2fvARB(ctx->Exec, (n[1].i, n[2].i, n[3].data));
	    break;
	 case OPCODE_UNIFORM_3FV:
	    CALL_Uniform3fvARB(ctx->Exec, (n[1].i, n[2].i, n[3].data));
	    break;
	 case OPCODE_UNIFORM_4FV:
	    CALL_Uniform4fvARB(ctx->Exec, (n[1].i, n[2].i, n[3].data));
	    break;
	 case OPCODE_UNIFORM_1I:
	    CALL_Uniform1iARB(ctx->Exec, (n[1].i, n[2].i));
	    break;
	 case OPCODE_UNIFORM_2I:
	    CALL_Uniform2iARB(ctx->Exec, (n[1].i, n[2].i, n[3].i));
	    break;
	 case OPCODE_UNIFORM_3I:
	    CALL_Uniform3iARB(ctx->Exec, (n[1].i, n[2].i, n[3].i, n[4].i));
	    break;
	 case OPCODE_UNIFORM_4I:
	    CALL_Uniform4iARB(ctx->Exec,
                              (n[1].i, n[2].i, n[3].i, n[4].i, n[5].i));
	    break;
	 case OPCODE_UNIFORM_1IV:
	    CALL_Uniform1ivARB(ctx->Exec, (n[1].i, n[2].i, n[3].data));
	    break;
	 case OPCODE_UNIFORM_2IV:
	    CALL_Uniform2ivARB(ctx->Exec, (n[1].i, n[2].i, n[3].data));
	    break;
	 case OPCODE_UNIFORM_3IV:
	    CALL_Uniform3ivARB(ctx->Exec, (n[1].i, n[2].i, n[3].data));
	    break;
	 case OPCODE_UNIFORM_4IV:
	    CALL_Uniform4ivARB(ctx->Exec, (n[1].i, n[2].i, n[3].data));
	    break;
	 case OPCODE_UNIFORM_1UI:
	    /*CALL_Uniform1uiARB(ctx->Exec, (n[1].i, n[2].i));*/
	    break;
	 case OPCODE_UNIFORM_2UI:
	    /*CALL_Uniform2uiARB(ctx->Exec, (n[1].i, n[2].i, n[3].i));*/
	    break;
	 case OPCODE_UNIFORM_3UI:
	    /*CALL_Uniform3uiARB(ctx->Exec, (n[1].i, n[2].i, n[3].i, n[4].i));*/
	    break;
	 case OPCODE_UNIFORM_4UI:
	    /*CALL_Uniform4uiARB(ctx->Exec,
                              (n[1].i, n[2].i, n[3].i, n[4].i, n[5].i));
            */
	    break;
	 case OPCODE_UNIFORM_1UIV:
	    /*CALL_Uniform1uivARB(ctx->Exec, (n[1].i, n[2].i, n[3].data));*/
	    break;
	 case OPCODE_UNIFORM_2UIV:
	    /*CALL_Uniform2uivARB(ctx->Exec, (n[1].i, n[2].i, n[3].data));*/
	    break;
	 case OPCODE_UNIFORM_3UIV:
	    /*CALL_Uniform3uivARB(ctx->Exec, (n[1].i, n[2].i, n[3].data));*/
	    break;
	 case OPCODE_UNIFORM_4UIV:
	    /*CALL_Uniform4uivARB(ctx->Exec, (n[1].i, n[2].i, n[3].data));*/
	    break;
	 case OPCODE_UNIFORM_MATRIX22:
	    CALL_UniformMatrix2fvARB(ctx->Exec,
                                     (n[1].i, n[2].i, n[3].b, n[4].data));
	    break;
	 case OPCODE_UNIFORM_MATRIX33:
	    CALL_UniformMatrix3fvARB(ctx->Exec,
                                     (n[1].i, n[2].i, n[3].b, n[4].data));
	    break;
	 case OPCODE_UNIFORM_MATRIX44:
	    CALL_UniformMatrix4fvARB(ctx->Exec,
                                     (n[1].i, n[2].i, n[3].b, n[4].data));
	    break;
	 case OPCODE_UNIFORM_MATRIX23:
	    CALL_UniformMatrix2x3fv(ctx->Exec,
                                    (n[1].i, n[2].i, n[3].b, n[4].data));
	    break;
	 case OPCODE_UNIFORM_MATRIX32:
	    CALL_UniformMatrix3x2fv(ctx->Exec,
                                    (n[1].i, n[2].i, n[3].b, n[4].data));
	    break;
	 case OPCODE_UNIFORM_MATRIX24:
	    CALL_UniformMatrix2x4fv(ctx->Exec,
                                    (n[1].i, n[2].i, n[3].b, n[4].data));
	    break;
	 case OPCODE_UNIFORM_MATRIX42:
	    CALL_UniformMatrix4x2fv(ctx->Exec,
                                    (n[1].i, n[2].i, n[3].b, n[4].data));
	    break;
	 case OPCODE_UNIFORM_MATRIX34:
	    CALL_UniformMatrix3x4fv(ctx->Exec,
                                    (n[1].i, n[2].i, n[3].b, n[4].data));
	    break;
	 case OPCODE_UNIFORM_MATRIX43:
	    CALL_UniformMatrix4x3fv(ctx->Exec,
                                    (n[1].i, n[2].i, n[3].b, n[4].data));
	    break;

         case OPCODE_TEX_BUMP_PARAMETER_ATI:
            {
               GLfloat values[4];
               GLuint i, pname = n[1].ui;

               for (i = 0; i < 4; i++)
                  values[i] = n[1 + i].f;
               CALL_TexBumpParameterfvATI(ctx->Exec, (pname, values));
            }
            break;
d6603 2
a6604 28
         /* GL_EXT_texture_integer */
         case OPCODE_CLEARCOLOR_I:
            CALL_ClearColorIiEXT(ctx->Exec, (n[1].i, n[2].i, n[3].i, n[4].i));
            break;
         case OPCODE_CLEARCOLOR_UI:
            CALL_ClearColorIuiEXT(ctx->Exec,
                                  (n[1].ui, n[2].ui, n[3].ui, n[4].ui));
            break;
         case OPCODE_TEXPARAMETER_I:
            {
               GLint params[4];
               params[0] = n[3].i;
               params[1] = n[4].i;
               params[2] = n[5].i;
               params[3] = n[6].i;
               CALL_TexParameterIivEXT(ctx->Exec, (n[1].e, n[2].e, params));
            }
            break;
         case OPCODE_TEXPARAMETER_UI:
            {
               GLuint params[4];
               params[0] = n[3].ui;
               params[1] = n[4].ui;
               params[2] = n[5].ui;
               params[3] = n[6].ui;
               CALL_TexParameterIuivEXT(ctx->Exec, (n[1].e, n[2].e, params));
            }
            break;
d6615 1
a6615 1
               _mesa_snprintf(msg, sizeof(msg), "Error in execute_list: opcode=%d",
d6617 1
a6617 1
               _mesa_problem(ctx, "%s", msg);
d6632 1
a6632 1
   ctx->ListState.CallDepth--;
d6644 1
a6644 1
static GLboolean GLAPIENTRY
d6657 1
a6657 1
static void GLAPIENTRY
d6679 1
a6679 1
static GLuint GLAPIENTRY
d6719 2
a6720 2
static void GLAPIENTRY
_mesa_NewList(GLuint name, GLenum mode)
d6723 1
d6729 1
a6729 1
      _mesa_debug(ctx, "glNewList %u %s\n", name,
d6732 1
a6732 1
   if (name == 0) {
d6742 1
a6742 1
   if (ctx->ListState.CurrentList) {
d6751 7
d6760 2
a6761 1
   invalidate_saved_current_state( ctx );
d6763 2
a6764 4
   /* Allocate new display list */
   ctx->ListState.CurrentList = make_list(name, BLOCK_SIZE);
   ctx->ListState.CurrentBlock = ctx->ListState.CurrentList->Head;
   ctx->ListState.CurrentPos = 0;
d6766 2
a6767 1
   ctx->Driver.NewList(ctx, name, mode);
d6777 1
a6777 1
static void GLAPIENTRY
d6788 1
a6788 1
   if (!ctx->ListState.CurrentList) {
a6791 5
   
   /* Call before emitting END_OF_LIST, in case the driver wants to
    * emit opcodes itself.
    */
   ctx->Driver.EndList(ctx);
d6793 1
a6793 1
   (void) alloc_instruction(ctx, OPCODE_END_OF_LIST, 0);
d6796 3
a6798 5
   destroy_list(ctx, ctx->ListState.CurrentList->Name);

   /* Install the new list */
   _mesa_HashInsert(ctx->Shared->DisplayList,
                    ctx->ListState.CurrentList->Name,
d6803 3
a6805 1
      mesa_print_display_list(ctx->ListState.CurrentList->Name);
d6808 2
d6860 1
d6892 2
a6893 2
      GLuint list = (GLuint) (ctx->List.ListBase + translate_id(i, type, lists));
      execute_list(ctx, list);
d6909 1
a6909 1
static void GLAPIENTRY
d7598 2
a7599 2
exec_MultiDrawArraysEXT(GLenum mode, const GLint *first,
                        const GLsizei *count, GLsizei primcount)
d7606 12
d7655 2
a7656 2
struct _glapi_table *
_mesa_create_save_table(void)
a7657 6
   struct _glapi_table *table;

   table = _mesa_alloc_dispatch_table(_gloffset_COUNT);
   if (table == NULL)
      return NULL;

d7664 3
a7666 3
   SET_BlendFunc(table, save_BlendFunc);
   SET_CallList(table, save_CallList);
   SET_CallLists(table, save_CallLists);
a7674 1
   SET_ColorMaskIndexedEXT(table, save_ColorMaskIndexed);
a7682 1
   SET_DisableIndexedEXT(table, save_DisableIndexed);
a7685 1
   SET_EnableIndexedEXT(table, save_EnableIndexed);
d7687 2
a7688 2
   SET_EvalMesh1(table, save_EvalMesh1);
   SET_EvalMesh2(table, save_EvalMesh2);
a7872 3
   /* ATI_separate_stencil */ 
   SET_StencilFuncSeparateATI(table, save_StencilFuncSeparateATI);

d7960 1
d8024 4
a8027 4
   SET_ProgramEnvParameter4dARB(table, save_ProgramEnvParameter4dARB);
   SET_ProgramEnvParameter4dvARB(table, save_ProgramEnvParameter4dvARB);
   SET_ProgramEnvParameter4fARB(table, save_ProgramEnvParameter4fARB);
   SET_ProgramEnvParameter4fvARB(table, save_ProgramEnvParameter4fvARB);
a8033 4
   /* 244. GL_ATI_envmap_bumpmap */
   SET_TexBumpParameterivATI(table, save_TexBumpParameterivATI);
   SET_TexBumpParameterfvATI(table, save_TexBumpParameterfvATI);

d8116 3
a8118 3
   SET_GetVertexAttribdvARB(table, _mesa_GetVertexAttribdvARB);
   SET_GetVertexAttribfvARB(table, _mesa_GetVertexAttribfvARB);
   SET_GetVertexAttribivARB(table, _mesa_GetVertexAttribivARB);
d8154 1
a8154 1
#if FEATURE_queryobj
a8169 34
   /* GL_ARB_shader_objects */
   SET_UseProgramObjectARB(table, save_UseProgramObjectARB);
   SET_Uniform1fARB(table, save_Uniform1fARB);
   SET_Uniform2fARB(table, save_Uniform2fARB);
   SET_Uniform3fARB(table, save_Uniform3fARB);
   SET_Uniform4fARB(table, save_Uniform4fARB);
   SET_Uniform1fvARB(table, save_Uniform1fvARB);
   SET_Uniform2fvARB(table, save_Uniform2fvARB);
   SET_Uniform3fvARB(table, save_Uniform3fvARB);
   SET_Uniform4fvARB(table, save_Uniform4fvARB);
   SET_Uniform1iARB(table, save_Uniform1iARB);
   SET_Uniform2iARB(table, save_Uniform2iARB);
   SET_Uniform3iARB(table, save_Uniform3iARB);
   SET_Uniform4iARB(table, save_Uniform4iARB);
   SET_Uniform1ivARB(table, save_Uniform1ivARB);
   SET_Uniform2ivARB(table, save_Uniform2ivARB);
   SET_Uniform3ivARB(table, save_Uniform3ivARB);
   SET_Uniform4ivARB(table, save_Uniform4ivARB);
   SET_UniformMatrix2fvARB(table, save_UniformMatrix2fvARB);
   SET_UniformMatrix3fvARB(table, save_UniformMatrix3fvARB);
   SET_UniformMatrix4fvARB(table, save_UniformMatrix4fvARB);
   SET_UniformMatrix2x3fv(table, save_UniformMatrix2x3fv);
   SET_UniformMatrix3x2fv(table, save_UniformMatrix3x2fv);
   SET_UniformMatrix2x4fv(table, save_UniformMatrix2x4fv);
   SET_UniformMatrix4x2fv(table, save_UniformMatrix4x2fv);
   SET_UniformMatrix3x4fv(table, save_UniformMatrix3x4fv);
   SET_UniformMatrix4x3fv(table, save_UniformMatrix4x3fv);

   /* ARB 30/31/32. GL_ARB_shader_objects, GL_ARB_vertex/fragment_shader */
   SET_BindAttribLocationARB(table, exec_BindAttribLocationARB);
   SET_GetAttribLocationARB(table, exec_GetAttribLocationARB);
   SET_GetUniformLocationARB(table, exec_GetUniformLocationARB);
   /* XXX additional functions need to be implemented here! */

d8173 1
a8173 1
   /* GL_EXT_gpu_program_parameters */
a8177 67

   /* ARB 50. GL_ARB_map_buffer_range */
#if FEATURE_ARB_map_buffer_range
   SET_MapBufferRange(table, _mesa_MapBufferRange); /* no dlist save */
   SET_FlushMappedBufferRange(table, _mesa_FlushMappedBufferRange); /* no dl */
#endif

   /* ARB 59. GL_ARB_copy_buffer */
   SET_CopyBufferSubData(table, _mesa_CopyBufferSubData); /* no dlist save */

   /* 352. GL_EXT_transform_feedback */
#if FEATURE_EXT_transform_feedback
   SET_BeginTransformFeedbackEXT(table, save_BeginTransformFeedback);
   SET_EndTransformFeedbackEXT(table, save_EndTransformFeedback);
#endif

   /* 364. GL_EXT_provoking_vertex */
   SET_ProvokingVertexEXT(table, save_ProvokingVertexEXT);

   /* 371. GL_APPLE_object_purgeable */
#if FEATURE_APPLE_object_purgeable
   SET_ObjectPurgeableAPPLE(table, _mesa_ObjectPurgeableAPPLE);
   SET_ObjectUnpurgeableAPPLE(table, _mesa_ObjectUnpurgeableAPPLE);
#endif

   /* GL_EXT_texture_integer */
   SET_ClearColorIiEXT(table, save_ClearColorIi);
   SET_ClearColorIuiEXT(table, save_ClearColorIui);
   SET_TexParameterIivEXT(table, save_TexParameterIiv);
   SET_TexParameterIuivEXT(table, save_TexParameterIuiv);
   SET_GetTexParameterIivEXT(table, exec_GetTexParameterIiv);
   SET_GetTexParameterIuivEXT(table, exec_GetTexParameterIuiv);

   /* 377. GL_EXT_separate_shader_objects */
   SET_UseShaderProgramEXT(table, save_UseShaderProgramEXT);
   SET_ActiveProgramEXT(table, save_ActiveProgramEXT);

   /* GL 3.0 */
#if 0
   SET_ClearBufferiv(table, save_ClearBufferiv);
   SET_ClearBufferuiv(table, save_ClearBufferuiv);
   SET_ClearBufferfv(table, save_ClearBufferfv);
   SET_ClearBufferfi(table, save_ClearBufferfi);
   SET_Uniform1ui(table, save_Uniform1ui);
   SET_Uniform2ui(table, save_Uniform2ui);
   SET_Uniform3ui(table, save_Uniform3ui);
   SET_Uniform4ui(table, save_Uniform4ui);
   SET_Uniform1uiv(table, save_Uniform1uiv);
   SET_Uniform2uiv(table, save_Uniform2uiv);
   SET_Uniform3uiv(table, save_Uniform3uiv);
   SET_Uniform4uiv(table, save_Uniform4uiv);
#else
   (void) save_ClearBufferiv;
   (void) save_ClearBufferuiv;
   (void) save_ClearBufferfv;
   (void) save_ClearBufferfi;
   (void) save_Uniform1ui;
   (void) save_Uniform2ui;
   (void) save_Uniform3ui;
   (void) save_Uniform4ui;
   (void) save_Uniform1uiv;
   (void) save_Uniform2uiv;
   (void) save_Uniform3uiv;
   (void) save_Uniform4uiv;
#endif

   return table;
d8194 1
a8194 1
print_list(struct gl_context *ctx, GLuint list)
d8196 1
a8196 1
   struct gl_display_list *dlist;
d8201 1
a8201 1
      printf("%u is not a display list ID\n", list);
d8209 1
a8209 1
   n = dlist->Head;
d8211 1
a8211 1
   printf("START-LIST %u, address %p\n", list, (void *) n);
d8215 2
a8216 1
      const OpCode opcode = n[0].opcode;
d8218 4
a8221 2
      if (is_ext_opcode(opcode)) {
         n += ext_opcode_print(ctx, n);
d8226 1
a8226 1
            printf("Accum %s %g\n", enum_string(n[1].e), n[2].f);
d8229 1
a8229 1
            printf("Bitmap %d %d %g %g %g %g %p\n", n[1].i, n[2].i,
d8233 1
a8233 1
            printf("CallList %d\n", (int) n[1].ui);
d8236 1
a8236 1
            printf("CallList %d + offset %u = %u\n", (int) n[1].ui,
d8240 1
a8240 1
            printf("ColorTableParameterfv %s %s %f %f %f %f\n",
d8245 1
a8245 1
            printf("ColorTableParameteriv %s %s %d %d %d %d\n",
d8250 1
a8250 1
            printf("Disable %s\n", enum_string(n[1].e));
d8253 1
a8253 1
            printf("Enable %s\n", enum_string(n[1].e));
d8256 1
a8256 1
            printf("Frustum %g %g %g %g %g %g\n",
d8260 1
a8260 1
            printf("LineStipple %d %x\n", n[1].i, (int) n[2].us);
d8263 1
a8263 1
            printf("LoadIdentity\n");
d8266 2
a8267 2
            printf("LoadMatrix\n");
            printf("  %8f %8f %8f %8f\n",
d8269 1
a8269 1
            printf("  %8f %8f %8f %8f\n",
d8271 1
a8271 1
            printf("  %8f %8f %8f %8f\n",
d8273 1
a8273 1
            printf("  %8f %8f %8f %8f\n",
d8277 2
a8278 2
            printf("MultMatrix (or Rotate)\n");
            printf("  %8f %8f %8f %8f\n",
d8280 1
a8280 1
            printf("  %8f %8f %8f %8f\n",
d8282 1
a8282 1
            printf("  %8f %8f %8f %8f\n",
d8284 1
a8284 1
            printf("  %8f %8f %8f %8f\n",
d8288 1
a8288 1
            printf("Ortho %g %g %g %g %g %g\n",
d8292 1
a8292 1
            printf("PopAttrib\n");
d8295 1
a8295 1
            printf("PopMatrix\n");
d8298 1
a8298 1
            printf("PopName\n");
d8301 1
a8301 1
            printf("PushAttrib %x\n", n[1].bf);
d8304 1
a8304 1
            printf("PushMatrix\n");
d8307 1
a8307 1
            printf("PushName %d\n", (int) n[1].ui);
d8310 1
a8310 1
            printf("RasterPos %g %g %g %g\n",
d8314 1
a8314 1
            printf("Rotate %g %g %g %g\n",
d8318 1
a8318 1
            printf("Scale %g %g %g\n", n[1].f, n[2].f, n[3].f);
d8321 1
a8321 1
            printf("Translate %g %g %g\n", n[1].f, n[2].f, n[3].f);
d8324 1
a8324 1
            printf("BindTexture %s %d\n",
d8328 1
a8328 1
            printf("ShadeModel %s\n", _mesa_lookup_enum_by_nr(n[1].ui));
d8331 1
a8331 1
            printf("Map1 %s %.3f %.3f %d %d\n",
d8336 1
a8336 1
            printf("Map2 %s %.3f %.3f %.3f %.3f %d %d %d %d\n",
d8342 1
a8342 1
            printf("MapGrid1 %d %.3f %.3f\n", n[1].i, n[2].f, n[3].f);
d8345 1
a8345 1
            printf("MapGrid2 %d %.3f %.3f, %d %.3f %.3f\n",
d8349 1
a8349 1
            printf("EvalMesh1 %d %d\n", n[1].i, n[2].i);
d8352 1
a8352 1
            printf("EvalMesh2 %d %d %d %d\n",
d8357 1
a8357 1
            printf("ATTR_1F_NV attr %d: %f\n", n[1].i, n[2].f);
d8360 1
a8360 1
            printf("ATTR_2F_NV attr %d: %f %f\n",
d8364 1
a8364 1
            printf("ATTR_3F_NV attr %d: %f %f %f\n",
d8368 1
a8368 1
            printf("ATTR_4F_NV attr %d: %f %f %f %f\n",
d8372 1
a8372 1
            printf("ATTR_1F_ARB attr %d: %f\n", n[1].i, n[2].f);
d8375 1
a8375 1
            printf("ATTR_2F_ARB attr %d: %f %f\n",
d8379 1
a8379 1
            printf("ATTR_3F_ARB attr %d: %f %f %f\n",
d8383 1
a8383 1
            printf("ATTR_4F_ARB attr %d: %f %f %f %f\n",
d8388 1
a8388 1
            printf("MATERIAL %x %x: %f %f %f %f\n",
d8392 1
a8392 1
            printf("BEGIN %x\n", n[1].i);
d8395 1
a8395 1
            printf("END\n");
d8398 1
a8398 1
            printf("RECTF %f %f %f %f\n", n[1].f, n[2].f, n[3].f,
d8402 1
a8402 1
            printf("EVAL_C1 %f\n", n[1].f);
d8405 1
a8405 1
            printf("EVAL_C2 %f %f\n", n[1].f, n[2].f);
d8408 1
a8408 1
            printf("EVAL_P1 %d\n", n[1].i);
d8411 1
a8411 1
            printf("EVAL_P2 %d %d\n", n[1].i, n[2].i);
d8414 1
a8414 4
         case OPCODE_PROVOKING_VERTEX:
            printf("ProvokingVertex %s\n",
                         _mesa_lookup_enum_by_nr(n[1].ui));
            break;
d8420 1
a8420 1
            printf("Error: %s %s\n",
d8424 1
a8424 1
            printf("DISPLAY-LIST-CONTINUE\n");
d8428 1
a8428 1
            printf("END-LIST %u\n", list);
d8433 1
a8433 1
               printf
d8439 1
a8439 1
               printf("command %d, %u operands\n", opcode,
d8473 1
a8473 2
   _MESA_INIT_ARRAYELT_VTXFMT(vfmt, _ae_);

d8475 2
a8476 3

   _MESA_INIT_DLIST_VTXFMT(vfmt, save_);

d8483 6
a8488 3

   _MESA_INIT_EVAL_VTXFMT(vfmt, save_);

d8537 2
a8550 4
   vfmt->MultiDrawElemementsEXT = 0;
   vfmt->DrawElementsBaseVertex = 0;
   vfmt->DrawRangeElementsBaseVertex = 0;
   vfmt->MultiDrawElemementsBaseVertex = 0;
a8554 26
void
_mesa_install_dlist_vtxfmt(struct _glapi_table *disp,
                           const GLvertexformat *vfmt)
{
   SET_CallList(disp, vfmt->CallList);
   SET_CallLists(disp, vfmt->CallLists);
}


void _mesa_init_dlist_dispatch(struct _glapi_table *disp)
{
   SET_CallList(disp, _mesa_CallList);
   SET_CallLists(disp, _mesa_CallLists);

   SET_DeleteLists(disp, _mesa_DeleteLists);
   SET_EndList(disp, _mesa_EndList);
   SET_GenLists(disp, _mesa_GenLists);
   SET_IsList(disp, _mesa_IsList);
   SET_ListBase(disp, _mesa_ListBase);
   SET_NewList(disp, _mesa_NewList);
}


#endif /* FEATURE_dlist */


d8559 1
a8559 1
_mesa_init_display_list(struct gl_context *ctx)
d8565 1
a8565 1
      memset(InstSize, 0, sizeof(InstSize));
a8568 3
   /* extension info */
   ctx->ListExt = CALLOC_STRUCT(gl_list_extensions);

d8573 1
d8575 1
a8580 1
#if FEATURE_dlist
a8581 9
#endif
}


void
_mesa_free_display_list_data(struct gl_context *ctx)
{
   free(ctx->ListExt);
   ctx->ListExt = NULL;
@


1.1.1.5
log
@Import Mesa 9.2.0
@
text
@d3 1
d21 3
a23 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
d37 1
a37 1
#include "api_validate.h"
d39 1
d41 2
d44 1
a49 1
#include "fbobject.h"
a51 1
#include "glformats.h"
a56 1
#include "pbo.h"
a57 3
#include "samplerobj.h"
#include "shaderapi.h"
#include "syncobj.h"
a58 1
#include "texstorage.h"
d61 1
d63 4
a66 1
#include "transformfeedback.h"
a71 2
#include "vbo/vbo.h"

d125 3
a127 2
   if (ctx->Driver.CurrentSavePrimitive <= PRIM_MAX) {			\
      _mesa_compile_error( ctx, GL_INVALID_OPERATION, "glBegin/End" );	\
d140 3
a142 2
   if (ctx->Driver.CurrentSavePrimitive <= PRIM_MAX) {			\
      _mesa_compile_error( ctx, GL_INVALID_OPERATION, "glBegin/End" );	\
a190 6

   OPCODE_BLEND_EQUATION_I,
   OPCODE_BLEND_EQUATION_SEPARATE_I,
   OPCODE_BLEND_FUNC_I,
   OPCODE_BLEND_FUNC_SEPARATE_I,

d315 6
a321 1
   OPCODE_BIND_PROGRAM_NV,
d323 1
a383 3
   /* GL_ARB_color_buffer_float */
   OPCODE_CLAMP_COLOR,

a412 4
   OPCODE_BIND_TRANSFORM_FEEDBACK,
   OPCODE_PAUSE_TRANSFORM_FEEDBACK,
   OPCODE_RESUME_TRANSFORM_FEEDBACK,
   OPCODE_DRAW_TRANSFORM_FEEDBACK,
a423 40
   /* GL_ARB_instanced_arrays */
   OPCODE_VERTEX_ATTRIB_DIVISOR,

   /* GL_NV_texture_barrier */
   OPCODE_TEXTURE_BARRIER_NV,

   /* GL_ARB_sampler_object */
   OPCODE_BIND_SAMPLER,
   OPCODE_SAMPLER_PARAMETERIV,
   OPCODE_SAMPLER_PARAMETERFV,
   OPCODE_SAMPLER_PARAMETERIIV,
   OPCODE_SAMPLER_PARAMETERUIV,

   /* GL_ARB_geometry_shader4 */
   OPCODE_PROGRAM_PARAMETERI,
   OPCODE_FRAMEBUFFER_TEXTURE,
   OPCODE_FRAMEBUFFER_TEXTURE_FACE,

   /* GL_ARB_sync */
   OPCODE_WAIT_SYNC,

   /* GL_NV_conditional_render */
   OPCODE_BEGIN_CONDITIONAL_RENDER,
   OPCODE_END_CONDITIONAL_RENDER,

   /* ARB_timer_query */
   OPCODE_QUERY_COUNTER,

   /* ARB_transform_feedback3 */
   OPCODE_BEGIN_QUERY_INDEXED,
   OPCODE_END_QUERY_INDEXED,
   OPCODE_DRAW_TRANSFORM_FEEDBACK_STREAM,

   /* ARB_transform_feedback_instanced */
   OPCODE_DRAW_TRANSFORM_FEEDBACK_INSTANCED,
   OPCODE_DRAW_TRANSFORM_FEEDBACK_STREAM_INSTANCED,

   /* ARB_uniform_buffer_object */
   OPCODE_UNIFORM_BLOCK_BINDING,

a455 1
   GLsizei si;
a464 11
 * Used to store a 64-bit uint in a pair of "Nodes" for the sake of 32-bit
 * environment.  In 64-bit env, sizeof(Node)==8 anyway.
 */
union uint64_pair
{
   GLuint64 uint64;
   GLuint uint32[2];
};


/**
d480 3
d500 1
a500 1
   dlist->Head = malloc(sizeof(Node) * count);
d509 1
a509 1
static inline struct gl_display_list *
d518 1
a518 1
static inline GLboolean
d668 17
d689 1
d824 2
a825 6
 * Wrapper for _mesa_unpack_image/bitmap() that handles pixel buffer objects.
 * If width < 0 or height < 0 or format or type are invalid we'll just
 * return NULL.  We will not generate an error since OpenGL command
 * arguments aren't error-checked until the command is actually executed
 * (not when they're compiled).
 * But if we run out of memory, GL_OUT_OF_MEMORY will be recorded.
a832 9
   if (width <= 0 || height <= 0) {
      return NULL;
   }

   if (_mesa_bytes_per_pixel(format, type) < 0) {
      /* bad format and/or type */
      return NULL;
   }

d835 2
a836 7
      GLvoid *image;

      if (type == GL_BITMAP)
         image = _mesa_unpack_bitmap(width, height, pixels, unpack);
      else
         image = _mesa_unpack_image(dimensions, width, height, depth,
                                    format, type, pixels, unpack);
d842 2
a843 2
   else if (_mesa_validate_pbo_access(dimensions, unpack, width, height,
                                      depth, format, type, INT_MAX, pixels)) {
d848 2
a849 2
         ctx->Driver.MapBufferRange(ctx, 0, unpack->BufferObj->Size,
				    GL_MAP_READ_BIT, unpack->BufferObj);
d857 2
a858 5
      if (type == GL_BITMAP)
         image = _mesa_unpack_bitmap(width, height, src, unpack);
      else
         image = _mesa_unpack_image(dimensions, width, height, depth,
                                    format, type, src, unpack);
d860 2
a861 1
      ctx->Driver.UnmapBuffer(ctx, unpack->BufferObj);
a867 1

a868 1
   _mesa_error(ctx, GL_INVALID_OPERATION, "invalid PBO access");
d872 1
d901 1
a901 1
      newblock = malloc(sizeof(Node) * BLOCK_SIZE);
d980 1
a980 1
static inline Node *
d1058 1
a1058 2
      n[7].data = unpack_image(ctx, 2, width, height, 1, GL_COLOR_INDEX,
                               GL_BITMAP, pixels, &ctx->Unpack);
d1095 1
a1095 1
      CALL_BlendEquationSeparate(ctx->Exec, (modeRGB, modeA));
d1115 1
a1115 1
      CALL_BlendFuncSeparate(ctx->Exec,
d1146 1
a1146 161
/* GL_ARB_draw_buffers_blend */
static void GLAPIENTRY
save_BlendFuncSeparatei(GLuint buf, GLenum sfactorRGB, GLenum dfactorRGB,
                        GLenum sfactorA, GLenum dfactorA)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_BLEND_FUNC_SEPARATE_I, 5);
   if (n) {
      n[1].ui = buf;
      n[2].e = sfactorRGB;
      n[3].e = dfactorRGB;
      n[4].e = sfactorA;
      n[5].e = dfactorA;
   }
   if (ctx->ExecuteFlag) {
      CALL_BlendFuncSeparateiARB(ctx->Exec, (buf, sfactorRGB, dfactorRGB,
                                             sfactorA, dfactorA));
   }
}

/* GL_ARB_draw_buffers_blend */
static void GLAPIENTRY
save_BlendFunci(GLuint buf, GLenum sfactor, GLenum dfactor)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_BLEND_FUNC_SEPARATE_I, 3);
   if (n) {
      n[1].ui = buf;
      n[2].e = sfactor;
      n[3].e = dfactor;
   }
   if (ctx->ExecuteFlag) {
      CALL_BlendFunciARB(ctx->Exec, (buf, sfactor, dfactor));
   }
}

/* GL_ARB_draw_buffers_blend */
static void GLAPIENTRY
save_BlendEquationi(GLuint buf, GLenum mode)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_BLEND_EQUATION_I, 2);
   if (n) {
      n[1].ui = buf;
      n[2].e = mode;
   }
   if (ctx->ExecuteFlag) {
      CALL_BlendEquationiARB(ctx->Exec, (buf, mode));
   }
}

/* GL_ARB_draw_buffers_blend */
static void GLAPIENTRY
save_BlendEquationSeparatei(GLuint buf, GLenum modeRGB, GLenum modeA)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_BLEND_EQUATION_SEPARATE_I, 3);
   if (n) {
      n[1].ui = buf;
      n[2].e = modeRGB;
      n[3].e = modeA;
   }
   if (ctx->ExecuteFlag) {
      CALL_BlendEquationSeparateiARB(ctx->Exec, (buf, modeRGB, modeA));
   }
}


/* GL_ARB_draw_instanced. */
static void GLAPIENTRY
save_DrawArraysInstancedARB(GLenum mode,
			    GLint first,
			    GLsizei count,
			    GLsizei primcount)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_error(ctx, GL_INVALID_OPERATION,
	       "glDrawArraysInstanced() during display list compile");
}

static void GLAPIENTRY
save_DrawElementsInstancedARB(GLenum mode,
			      GLsizei count,
			      GLenum type,
			      const GLvoid *indices,
			      GLsizei primcount)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_error(ctx, GL_INVALID_OPERATION,
	       "glDrawElementsInstanced() during display list compile");
}

static void GLAPIENTRY
save_DrawElementsInstancedBaseVertexARB(GLenum mode,
					GLsizei count,
					GLenum type,
					const GLvoid *indices,
					GLsizei primcount,
					GLint basevertex)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_error(ctx, GL_INVALID_OPERATION,
	       "glDrawElementsInstancedBaseVertex() during display list compile");
}

/* GL_ARB_base_instance. */
static void GLAPIENTRY
save_DrawArraysInstancedBaseInstance(GLenum mode,
                                     GLint first,
                                     GLsizei count,
                                     GLsizei primcount,
                                     GLuint baseinstance)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_error(ctx, GL_INVALID_OPERATION,
	       "glDrawArraysInstancedBaseInstance() during display list compile");
}

static void APIENTRY
save_DrawElementsInstancedBaseInstance(GLenum mode,
                                       GLsizei count,
                                       GLenum type,
                                       const void *indices,
                                       GLsizei primcount,
                                       GLuint baseinstance)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_error(ctx, GL_INVALID_OPERATION,
	       "glDrawElementsInstancedBaseInstance() during display list compile");
}

static void APIENTRY
save_DrawElementsInstancedBaseVertexBaseInstance(GLenum mode,
                                                 GLsizei count,
                                                 GLenum type,
                                                 const void *indices,
                                                 GLsizei primcount,
                                                 GLint basevertex,
                                                 GLuint baseinstance)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_error(ctx, GL_INVALID_OPERATION,
	       "glDrawElementsInstancedBaseVertexBaseInstance() during display list compile");
}


/**
 * While building a display list we cache some OpenGL state.
 * Under some circumstances we need to invalidate that state (immediately
 * when we start compiling a list, or after glCallList(s)).
 */
static void
invalidate_saved_current_state(struct gl_context *ctx)
a1160 1

d1269 1
a1269 1
      CALL_ClearBufferiv(ctx->Exec, (buffer, drawbuffer, value));
d1297 1
a1297 1
      CALL_ClearBufferuiv(ctx->Exec, (buffer, drawbuffer, value));
d1325 1
a1325 1
      CALL_ClearBufferfv(ctx->Exec, (buffer, drawbuffer, value));
d1345 1
a1345 1
      CALL_ClearBufferfi(ctx->Exec, (buffer, drawbuffer, depth, stencil));
d1493 1
a1493 1
      /*CALL_ColorMaski(ctx->Exec, (buf, red, green, blue, alpha));*/
d2066 1
a2066 1
      CALL_Disablei(ctx->Exec, (index, cap));
d2141 1
a2141 1
      CALL_Enablei(ctx->Exec, (index, cap));
d2942 1
a2942 1
      n[3].data = malloc(mapsize * sizeof(GLfloat));
d3044 1
a3044 1
      CALL_PointParameterfv(ctx->Exec, (pname, params));
a3560 4
   /* Don't compile this call if it's a no-op.
    * By avoiding this state change we have a better chance of
    * coalescing subsequent drawing commands into one batch.
    */
d3566 4
a3569 1
   ctx->ListState.Current.ShadeModel = mode;
d4328 1
a4328 1
      CALL_ActiveTexture(ctx->Exec, (target));
a4369 18
static GLvoid *copy_data(const GLvoid *data, GLsizei size, const char *func)
{
   GET_CURRENT_CONTEXT(ctx);
   GLvoid *image;

   if (!data)
      return NULL;

   image = malloc(size);
   if (!image) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "%s", func);
      return NULL;
   }
   memcpy(image, data, size);

   return image;
}

d4381 1
a4381 1
      CALL_CompressedTexImage1D(ctx->Exec, (target, level, internalFormat,
d4387 1
d4389 7
a4395 1

d4404 4
a4407 1
         n[7].data = copy_data(data, imageSize, "glCompressedTexImage1DARB");
d4410 1
a4410 1
         CALL_CompressedTexImage1D(ctx->Exec,
d4427 1
a4427 1
      CALL_CompressedTexImage2D(ctx->Exec, (target, level, internalFormat,
d4433 1
d4435 7
a4441 1

d4451 4
a4454 1
         n[8].data = copy_data(data, imageSize, "glCompressedTexImage2DARB");
d4457 1
a4457 1
         CALL_CompressedTexImage2D(ctx->Exec,
d4474 1
a4474 1
      CALL_CompressedTexImage3D(ctx->Exec, (target, level, internalFormat,
d4480 1
d4482 7
a4488 1

d4499 4
a4502 1
         n[9].data = copy_data(data, imageSize, "glCompressedTexImage3DARB");
d4505 1
a4505 1
         CALL_CompressedTexImage3D(ctx->Exec,
d4520 2
d4525 7
d4540 4
a4543 1
      n[7].data = copy_data(data, imageSize, "glCompressedTexSubImage1DARB");
d4546 1
a4546 1
      CALL_CompressedTexSubImage1D(ctx->Exec, (target, level, xoffset,
d4560 2
d4565 7
d4582 4
a4585 1
      n[9].data = copy_data(data, imageSize, "glCompressedTexSubImage2DARB");
d4588 1
a4588 1
      CALL_CompressedTexSubImage2D(ctx->Exec,
d4602 2
d4607 7
d4626 4
a4629 1
      n[11].data = copy_data(data, imageSize, "glCompressedTexSubImage3DARB");
d4632 1
a4632 1
      CALL_CompressedTexSubImage3D(ctx->Exec,
d4653 1
a4653 1
      CALL_SampleCoverage(ctx->Exec, (value, invert));
d4659 1
a4659 1
 * GL_NV_fragment_program
d4661 1
d4674 1
a4674 1
      CALL_BindProgramARB(ctx->Exec, (target, id));
d4761 1
d4763 1
d4765 1
a4765 2
save_ProgramLocalParameter4fARB(GLenum target, GLuint index,
                                GLfloat x, GLfloat y, GLfloat z, GLfloat w)
d4770 1
a4770 1
   n = alloc_instruction(ctx, OPCODE_PROGRAM_LOCAL_PARAMETER_ARB, 6);
d4773 5
a4777 5
      n[2].ui = index;
      n[3].f = x;
      n[4].f = y;
      n[5].f = z;
      n[6].f = w;
d4780 23
a4802 1
      CALL_ProgramLocalParameter4fARB(ctx->Exec, (target, index, x, y, z, w));
d4808 2
a4809 2
save_ProgramLocalParameter4fvARB(GLenum target, GLuint index,
                                 const GLfloat *params)
d4813 1
d4815 2
a4816 1
   n = alloc_instruction(ctx, OPCODE_PROGRAM_LOCAL_PARAMETER_ARB, 6);
d4818 6
d4825 3
a4827 5
      n[2].ui = index;
      n[3].f = params[0];
      n[4].f = params[1];
      n[5].f = params[2];
      n[6].f = params[3];
d4830 1
a4830 1
      CALL_ProgramLocalParameter4fvARB(ctx->Exec, (target, index, params));
d4836 1
a4836 2
save_ProgramLocalParameters4fvEXT(GLenum target, GLuint index, GLsizei count,
				  const GLfloat *params)
d4840 1
d4843 6
a4848 15
   if (count > 0) {
      GLint i;
      const GLfloat * p = params;

      for (i = 0 ; i < count ; i++) {
	 n = alloc_instruction(ctx, OPCODE_PROGRAM_LOCAL_PARAMETER_ARB, 6);
	 if (n) {
	    n[1].e = target;
	    n[2].ui = index;
	    n[3].f = p[0];
	    n[4].f = p[1];
	    n[5].f = p[2];
	    n[6].f = p[3];
	    p += 4;
	 }
d4850 3
a4853 1

d4855 1
a4855 1
      CALL_ProgramLocalParameters4fvEXT(ctx->Exec, (target, index, count, params));
d4861 2
a4862 3
save_ProgramLocalParameter4dARB(GLenum target, GLuint index,
                                GLdouble x, GLdouble y,
                                GLdouble z, GLdouble w)
d4867 1
a4867 1
   n = alloc_instruction(ctx, OPCODE_PROGRAM_LOCAL_PARAMETER_ARB, 6);
d4870 3
a4872 5
      n[2].ui = index;
      n[3].f = (GLfloat) x;
      n[4].f = (GLfloat) y;
      n[5].f = (GLfloat) z;
      n[6].f = (GLfloat) w;
d4875 105
a4979 1
      CALL_ProgramLocalParameter4dARB(ctx->Exec, (target, index, x, y, z, w));
d5005 60
d5102 2
d5115 1
a5115 1
      GLubyte *programCopy = malloc(len);
d5131 4
d5148 1
a5148 1
      CALL_BeginQuery(ctx->Exec, (target, id));
d5152 1
d5164 1
a5164 34
      CALL_EndQuery(ctx->Exec, (target));
   }
}

static void GLAPIENTRY
save_QueryCounter(GLuint id, GLenum target)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_QUERY_COUNTER, 2);
   if (n) {
      n[1].ui = id;
      n[2].e = target;
   }
   if (ctx->ExecuteFlag) {
      CALL_QueryCounter(ctx->Exec, (id, target));
   }
}

static void GLAPIENTRY
save_BeginQueryIndexed(GLenum target, GLuint index, GLuint id)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_BEGIN_QUERY_INDEXED, 3);
   if (n) {
      n[1].e = target;
      n[2].ui = index;
      n[3].ui = id;
   }
   if (ctx->ExecuteFlag) {
      CALL_BeginQueryIndexed(ctx->Exec, (target, index, id));
d5168 1
a5168 15
static void GLAPIENTRY
save_EndQueryIndexed(GLenum target, GLuint index)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_END_QUERY_INDEXED, 2);
   if (n) {
      n[1].e = target;
      n[2].ui = index;
   }
   if (ctx->ExecuteFlag) {
      CALL_EndQueryIndexed(ctx->Exec, (target, index));
   }
}
d5188 1
a5188 1
      CALL_DrawBuffers(ctx->Exec, (count, buffers));
d5222 1
d5256 1
d5530 1
a5530 1
   save_Attr1fNV(VERT_ATTRIB_EDGEFLAG, x ? 1.0f : 0.0f);
d5533 3
a5535 7

/**
 * Compare 'count' elements of vectors 'a' and 'b'.
 * \return GL_TRUE if equal, GL_FALSE if different.
 */
static inline GLboolean
compare_vec(const GLfloat *a, const GLfloat *b, GLuint count)
d5539 1
a5540 5

/**
 * This glMaterial function is used for glMaterial calls that are outside
 * a glBegin/End pair.  For glMaterial inside glBegin/End, see the VBO code.
 */
d5555 1
a5555 1
      _mesa_compile_error(ctx, GL_INVALID_ENUM, "glMaterial(face)");
d5574 1
a5574 1
      _mesa_compile_error(ctx, GL_INVALID_ENUM, "glMaterial(pname)");
d5591 1
a5591 2
             compare_vec(ctx->ListState.CurrentMaterial[i], param, args)) {
            /* no change in material value */
d5601 2
a5602 1
   /* If this call has no effect, return early */
d5621 2
d5624 13
a5636 7
   if (!_mesa_is_valid_prim_mode(ctx, mode)) {
      /* compile this error into the display list */
      _mesa_compile_error(ctx, GL_INVALID_ENUM, "glBegin(mode)");
   }
   else if (_mesa_inside_dlist_begin_end(ctx)) {
      /* compile this error into the display list */
      _mesa_compile_error(ctx, GL_INVALID_OPERATION, "recursive glBegin");
d5639 3
a5641 3
      Node *n;

      ctx->Driver.CurrentSavePrimitive = mode;
d5643 1
d5655 1
d5657 2
a5658 3
      if (ctx->ExecuteFlag) {
         CALL_Begin(ctx->Exec, (mode));
      }
d5679 1
a5679 1
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
d5910 79
d6063 3
d6067 30
a6096 3
save_BlitFramebufferEXT(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1,
                        GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1,
                        GLbitfield mask, GLenum filter)
d6115 1
a6115 1
      CALL_BlitFramebuffer(ctx->Exec, (srcX0, srcY0, srcX1, srcY1,
d6120 1
d6135 2
a6136 2
      /*CALL_ProvokingVertex(ctx->Exec, (mode));*/
      _mesa_ProvokingVertex(mode);
d6153 1
a6153 1
      CALL_BeginTransformFeedback(ctx->Exec, (mode));
d6166 1
a6166 90
      CALL_EndTransformFeedback(ctx->Exec, ());
   }
}

static void GLAPIENTRY
save_BindTransformFeedback(GLenum target, GLuint name)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_BIND_TRANSFORM_FEEDBACK, 2);
   if (n) {
      n[1].e = target;
      n[2].ui = name;
   }
   if (ctx->ExecuteFlag) {
      CALL_BindTransformFeedback(ctx->Exec, (target, name));
   }
}

static void GLAPIENTRY
save_PauseTransformFeedback(void)
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   (void) alloc_instruction(ctx, OPCODE_PAUSE_TRANSFORM_FEEDBACK, 0);
   if (ctx->ExecuteFlag) {
      CALL_PauseTransformFeedback(ctx->Exec, ());
   }
}

static void GLAPIENTRY
save_ResumeTransformFeedback(void)
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   (void) alloc_instruction(ctx, OPCODE_RESUME_TRANSFORM_FEEDBACK, 0);
   if (ctx->ExecuteFlag) {
      CALL_ResumeTransformFeedback(ctx->Exec, ());
   }
}

static void GLAPIENTRY
save_DrawTransformFeedback(GLenum mode, GLuint name)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_DRAW_TRANSFORM_FEEDBACK, 2);
   if (n) {
      n[1].e = mode;
      n[2].ui = name;
   }
   if (ctx->ExecuteFlag) {
      CALL_DrawTransformFeedback(ctx->Exec, (mode, name));
   }
}

static void GLAPIENTRY
save_DrawTransformFeedbackStream(GLenum mode, GLuint name, GLuint stream)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_DRAW_TRANSFORM_FEEDBACK_STREAM, 3);
   if (n) {
      n[1].e = mode;
      n[2].ui = name;
      n[3].ui = stream;
   }
   if (ctx->ExecuteFlag) {
      CALL_DrawTransformFeedbackStream(ctx->Exec, (mode, name, stream));
   }
}

static void GLAPIENTRY
save_DrawTransformFeedbackInstanced(GLenum mode, GLuint name,
                                    GLsizei primcount)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_DRAW_TRANSFORM_FEEDBACK_INSTANCED, 3);
   if (n) {
      n[1].e = mode;
      n[2].ui = name;
      n[3].si = primcount;
   }
   if (ctx->ExecuteFlag) {
      CALL_DrawTransformFeedbackInstanced(ctx->Exec, (mode, name, primcount));
a6169 19
static void GLAPIENTRY
save_DrawTransformFeedbackStreamInstanced(GLenum mode, GLuint name,
                                          GLuint stream, GLsizei primcount)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_DRAW_TRANSFORM_FEEDBACK_STREAM_INSTANCED, 4);
   if (n) {
      n[1].e = mode;
      n[2].ui = name;
      n[3].ui = stream;
      n[4].si = primcount;
   }
   if (ctx->ExecuteFlag) {
      CALL_DrawTransformFeedbackStreamInstanced(ctx->Exec, (mode, name, stream,
                                                            primcount));
   }
}
d6183 1
a6183 1
      CALL_UseProgram(ctx->Exec, (program));
d6200 1
a6200 1
      CALL_Uniform1f(ctx->Exec, (location, x));
d6218 1
a6218 1
      CALL_Uniform2f(ctx->Exec, (location, x, y));
d6237 1
a6237 1
      CALL_Uniform3f(ctx->Exec, (location, x, y, z));
d6257 1
a6257 1
      CALL_Uniform4f(ctx->Exec, (location, x, y, z, w));
d6286 1
a6286 1
      CALL_Uniform1fv(ctx->Exec, (location, count, v));
d6303 1
a6303 1
      CALL_Uniform2fv(ctx->Exec, (location, count, v));
d6320 1
a6320 1
      CALL_Uniform3fv(ctx->Exec, (location, count, v));
d6337 1
a6337 1
      CALL_Uniform4fv(ctx->Exec, (location, count, v));
d6354 1
a6354 1
      CALL_Uniform1i(ctx->Exec, (location, x));
d6371 1
a6371 1
      CALL_Uniform2i(ctx->Exec, (location, x, y));
d6389 1
a6389 1
      CALL_Uniform3i(ctx->Exec, (location, x, y, z));
d6408 1
a6408 1
      CALL_Uniform4i(ctx->Exec, (location, x, y, z, w));
d6427 1
a6427 1
      CALL_Uniform1iv(ctx->Exec, (location, count, v));
d6444 1
a6444 1
      CALL_Uniform2iv(ctx->Exec, (location, count, v));
d6461 1
a6461 1
      CALL_Uniform3iv(ctx->Exec, (location, count, v));
d6478 1
a6478 1
      CALL_Uniform4iv(ctx->Exec, (location, count, v));
d6641 1
a6641 1
      CALL_UniformMatrix2fv(ctx->Exec, (location, count, transpose, m));
d6660 1
a6660 1
      CALL_UniformMatrix3fv(ctx->Exec, (location, count, transpose, m));
d6679 1
a6679 1
      CALL_UniformMatrix4fv(ctx->Exec, (location, count, transpose, m));
a6800 16
save_ClampColorARB(GLenum target, GLenum clamp)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_CLAMP_COLOR, 2);
   if (n) {
      n[1].e = target;
      n[2].e = clamp;
   }
   if (ctx->ExecuteFlag) {
      CALL_ClampColor(ctx->Exec, (target, clamp));
   }
}

static void GLAPIENTRY
d6886 1
a6886 1
      CALL_TexParameterIiv(ctx->Exec, (target, pname, params));
d6907 1
a6907 1
      CALL_TexParameterIuiv(ctx->Exec, (target, pname, params));
d6911 1
a6911 1
/* GL_ARB_instanced_arrays */
d6913 1
a6913 1
save_VertexAttribDivisor(GLuint index, GLuint divisor)
d6916 2
a6917 10
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_VERTEX_ATTRIB_DIVISOR, 2);
   if (n) {
      n[1].ui = index;
      n[2].ui = divisor;
   }
   if (ctx->ExecuteFlag) {
      CALL_VertexAttribDivisor(ctx->Exec, (index, divisor));
   }
d6920 1
a6920 2

/* GL_NV_texture_barrier */
d6922 1
a6922 1
save_TextureBarrierNV(void)
d6925 2
a6926 5
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   alloc_instruction(ctx, OPCODE_TEXTURE_BARRIER_NV, 0);
   if (ctx->ExecuteFlag) {
      CALL_TextureBarrierNV(ctx->Exec, ());
   }
d6930 11
a6940 3
/* GL_ARB_sampler_objects */
static void GLAPIENTRY
save_BindSampler(GLuint unit, GLuint sampler)
d6943 1
a6943 3
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_BIND_SAMPLER, 2);
d6945 2
a6946 5
      n[1].ui = unit;
      n[2].ui = sampler;
   }
   if (ctx->ExecuteFlag) {
      CALL_BindSampler(ctx->Exec, (unit, sampler));
d6950 6
a6955 2
static void GLAPIENTRY
save_SamplerParameteriv(GLuint sampler, GLenum pname, const GLint *params)
d6957 4
a6960 20
   Node *n;
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_SAMPLER_PARAMETERIV, 6);
   if (n) {
      n[1].ui = sampler;
      n[2].e = pname;
      n[3].i = params[0];
      if (pname == GL_TEXTURE_BORDER_COLOR) {
         n[4].i = params[1];
         n[5].i = params[2];
         n[6].i = params[3];
      }
      else {
         n[4].i = n[5].i = n[6].i = 0;
      }
   }
   if (ctx->ExecuteFlag) {
      CALL_SamplerParameteriv(ctx->Exec, (sampler, pname, params));
   }
a6962 8
static void GLAPIENTRY
save_SamplerParameteri(GLuint sampler, GLenum pname, GLint param)
{
   GLint parray[4];
   parray[0] = param;
   parray[1] = parray[2] = parray[3] = 0;
   save_SamplerParameteriv(sampler, pname, parray);
}
d6964 5
a6968 2
static void GLAPIENTRY
save_SamplerParameterfv(GLuint sampler, GLenum pname, const GLfloat *params)
d6970 2
a6971 16
   Node *n;
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_SAMPLER_PARAMETERFV, 6);
   if (n) {
      n[1].ui = sampler;
      n[2].e = pname;
      n[3].f = params[0];
      if (pname == GL_TEXTURE_BORDER_COLOR) {
         n[4].f = params[1];
         n[5].f = params[2];
         n[6].f = params[3];
      }
      else {
         n[4].f = n[5].f = n[6].f = 0.0F;
      }
d6973 2
a6974 2
   if (ctx->ExecuteFlag) {
      CALL_SamplerParameterfv(ctx->Exec, (sampler, pname, params));
a6977 8
static void GLAPIENTRY
save_SamplerParameterf(GLuint sampler, GLenum pname, GLfloat param)
{
   GLfloat parray[4];
   parray[0] = param;
   parray[1] = parray[2] = parray[3] = 0.0F;
   save_SamplerParameterfv(sampler, pname, parray);
}
d6979 14
a6992 2
static void GLAPIENTRY
save_SamplerParameterIiv(GLuint sampler, GLenum pname, const GLint *params)
d6994 1
d6996 4
a6999 20
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_SAMPLER_PARAMETERIIV, 6);
   if (n) {
      n[1].ui = sampler;
      n[2].e = pname;
      n[3].i = params[0];
      if (pname == GL_TEXTURE_BORDER_COLOR) {
         n[4].i = params[1];
         n[5].i = params[2];
         n[6].i = params[3];
      }
      else {
         n[4].i = n[5].i = n[6].i = 0;
      }
   }
   if (ctx->ExecuteFlag) {
      CALL_SamplerParameterIiv(ctx->Exec, (sampler, pname, params));
   }
}
d7001 3
a7003 223
static void GLAPIENTRY
save_SamplerParameterIuiv(GLuint sampler, GLenum pname, const GLuint *params)
{
   Node *n;
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_SAMPLER_PARAMETERUIV, 6);
   if (n) {
      n[1].ui = sampler;
      n[2].e = pname;
      n[3].ui = params[0];
      if (pname == GL_TEXTURE_BORDER_COLOR) {
         n[4].ui = params[1];
         n[5].ui = params[2];
         n[6].ui = params[3];
      }
      else {
         n[4].ui = n[5].ui = n[6].ui = 0;
      }
   }
   if (ctx->ExecuteFlag) {
      CALL_SamplerParameterIuiv(ctx->Exec, (sampler, pname, params));
   }
}

/* GL_ARB_geometry_shader4 */
static void GLAPIENTRY
save_ProgramParameteri(GLuint program, GLenum pname, GLint value)
{
   Node *n;
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_PROGRAM_PARAMETERI, 3);
   if (n) {
      n[1].ui = program;
      n[2].e = pname;
      n[3].i = value;
   }
   if (ctx->ExecuteFlag) {
      CALL_ProgramParameteri(ctx->Exec, (program, pname, value));
   }
}

static void GLAPIENTRY
save_FramebufferTexture(GLenum target, GLenum attachment,
                        GLuint texture, GLint level)
{
   Node *n;
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_FRAMEBUFFER_TEXTURE, 4);
   if (n) {
      n[1].e = target;
      n[2].e = attachment;
      n[3].ui = texture;
      n[4].i = level;
   }
   if (ctx->ExecuteFlag) {
      CALL_FramebufferTexture(ctx->Exec, (target, attachment, texture, level));
   }
}

static void GLAPIENTRY
save_FramebufferTextureFace(GLenum target, GLenum attachment,
                            GLuint texture, GLint level, GLenum face)
{
   Node *n;
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_FRAMEBUFFER_TEXTURE_FACE, 5);
   if (n) {
      n[1].e = target;
      n[2].e = attachment;
      n[3].ui = texture;
      n[4].i = level;
      n[5].e = face;
   }
   if (ctx->ExecuteFlag) {
      CALL_FramebufferTextureFaceARB(ctx->Exec, (target, attachment, texture,
                                                 level, face));
   }
}



static void GLAPIENTRY
save_WaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout)
{
   Node *n;
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_WAIT_SYNC, 4);
   if (n) {
      union uint64_pair p;
      p.uint64 = timeout;
      n[1].data = sync;
      n[2].e = flags;
      n[3].ui = p.uint32[0];
      n[4].ui = p.uint32[1];
   }
   if (ctx->ExecuteFlag) {
      CALL_WaitSync(ctx->Exec, (sync, flags, timeout));
   }
}


/** GL_NV_conditional_render */
static void GLAPIENTRY
save_BeginConditionalRender(GLuint queryId, GLenum mode)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_BEGIN_CONDITIONAL_RENDER, 2);
   if (n) {
      n[1].i = queryId;
      n[2].e = mode;
   }
   if (ctx->ExecuteFlag) {
      CALL_BeginConditionalRender(ctx->Exec, (queryId, mode));
   }
}

static void GLAPIENTRY
save_EndConditionalRender(void)
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   alloc_instruction(ctx, OPCODE_END_CONDITIONAL_RENDER, 0);
   if (ctx->ExecuteFlag) {
      CALL_EndConditionalRender(ctx->Exec, ());
   }
}

static void GLAPIENTRY
save_UniformBlockBinding(GLuint prog, GLuint index, GLuint binding)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_BLOCK_BINDING, 3);
   if (n) {
      n[1].ui = prog;
      n[2].ui = index;
      n[3].ui = binding;
   }
   if (ctx->ExecuteFlag) {
      CALL_UniformBlockBinding(ctx->Exec, (prog, index, binding));
   }
}


/**
 * Save an error-generating command into display list.
 *
 * KW: Will appear in the list before the vertex buffer containing the
 * command that provoked the error.  I don't see this as a problem.
 */
static void
save_error(struct gl_context *ctx, GLenum error, const char *s)
{
   Node *n;
   n = alloc_instruction(ctx, OPCODE_ERROR, 2);
   if (n) {
      n[1].e = error;
      n[2].data = (void *) s;
   }
}


/**
 * Compile an error into current display list.
 */
void
_mesa_compile_error(struct gl_context *ctx, GLenum error, const char *s)
{
   if (ctx->CompileFlag)
      save_error(ctx, error, s);
   if (ctx->ExecuteFlag)
      _mesa_error(ctx, error, "%s", s);
}


/**
 * Test if ID names a display list.
 */
static GLboolean
islist(struct gl_context *ctx, GLuint list)
{
   if (list > 0 && lookup_list(ctx, list)) {
      return GL_TRUE;
   }
   else {
      return GL_FALSE;
   }
}



/**********************************************************************/
/*                     Display list execution                         */
/**********************************************************************/


/*
 * Execute a display list.  Note that the ListBase offset must have already
 * been added before calling this function.  I.e. the list argument is
 * the absolute list number, not relative to ListBase.
 * \param list - display list number
 */
static void
execute_list(struct gl_context *ctx, GLuint list)
{
   struct gl_display_list *dlist;
   Node *n;
   GLboolean done;

   if (list == 0 || !islist(ctx, list))
      return;

   if (ctx->ListState.CallDepth == MAX_LIST_NESTING) {
      /* raise an error? */
      return;
d7055 1
a7055 1
            CALL_BlendEquationSeparate(ctx->Exec, (n[1].e, n[2].e));
d7058 1
a7058 1
            CALL_BlendFuncSeparate(ctx->Exec,
a7060 20

         case OPCODE_BLEND_FUNC_I:
            /* GL_ARB_draw_buffers_blend */
            CALL_BlendFunciARB(ctx->Exec, (n[1].ui, n[2].e, n[3].e));
            break;
         case OPCODE_BLEND_FUNC_SEPARATE_I:
            /* GL_ARB_draw_buffers_blend */
            CALL_BlendFuncSeparateiARB(ctx->Exec, (n[1].ui, n[2].e, n[3].e,
                                                   n[4].e, n[5].e));
            break;
         case OPCODE_BLEND_EQUATION_I:
            /* GL_ARB_draw_buffers_blend */
            CALL_BlendEquationiARB(ctx->Exec, (n[1].ui, n[2].e));
            break;
         case OPCODE_BLEND_EQUATION_SEPARATE_I:
            /* GL_ARB_draw_buffers_blend */
            CALL_BlendEquationSeparateiARB(ctx->Exec,
                                           (n[1].ui, n[2].e, n[3].e));
            break;

d7088 1
a7088 1
               CALL_ClearBufferiv(ctx->Exec, (n[1].e, n[2].i, value));
d7098 1
a7098 1
               CALL_ClearBufferuiv(ctx->Exec, (n[1].e, n[2].i, value));
d7108 1
a7108 1
               CALL_ClearBufferfv(ctx->Exec, (n[1].e, n[2].i, value));
d7112 1
a7112 1
            CALL_ClearBufferfi(ctx->Exec, (n[1].e, n[2].i, n[3].f, n[4].i));
d7143 1
a7143 1
            CALL_ColorMaski(ctx->Exec, (n[1].ui, n[2].b, n[3].b,
d7289 1
a7289 1
            CALL_Disablei(ctx->Exec, (n[1].ui, n[2].e));
d7307 1
a7307 1
            CALL_Enablei(ctx->Exec, (n[1].ui, n[2].e));
d7475 1
a7475 1
               CALL_PointParameterfv(ctx->Exec, (n[1].e, params));
d7538 7
a7544 1
            CALL_ProvokingVertex(ctx->Exec, (n[1].e));
d7687 1
a7687 1
            CALL_ActiveTexture(ctx->Exec, (n[1].e));
d7690 1
a7690 1
            CALL_CompressedTexImage1D(ctx->Exec, (n[1].e, n[2].i, n[3].e,
d7695 1
a7695 1
            CALL_CompressedTexImage2D(ctx->Exec, (n[1].e, n[2].i, n[3].e,
d7700 1
a7700 1
            CALL_CompressedTexImage3D(ctx->Exec, (n[1].e, n[2].i, n[3].e,
d7706 1
a7706 1
            CALL_CompressedTexSubImage1D(ctx->Exec,
d7711 1
a7711 1
            CALL_CompressedTexSubImage2D(ctx->Exec,
d7717 1
a7717 1
            CALL_CompressedTexSubImage3D(ctx->Exec,
d7723 1
a7723 1
            CALL_SampleCoverage(ctx->Exec, (n[1].f, n[2].b));
d7726 25
a7750 1
            CALL_WindowPos3f(ctx->Exec, (n[1].f, n[2].f, n[3].f));
d7752 2
a7753 2
         case OPCODE_BIND_PROGRAM_NV:  /* GL_ARB_vertex_program */
            CALL_BindProgramARB(ctx->Exec, (n[1].e, n[2].ui));
d7755 3
d7763 8
d7777 1
d7782 2
d7789 2
d7792 1
a7792 1
            CALL_BeginQuery(ctx->Exec, (n[1].e, n[2].ui));
d7795 1
a7795 10
            CALL_EndQuery(ctx->Exec, (n[1].e));
            break;
         case OPCODE_QUERY_COUNTER:
            CALL_QueryCounter(ctx->Exec, (n[1].ui, n[2].e));
            break;
         case OPCODE_BEGIN_QUERY_INDEXED:
            CALL_BeginQueryIndexed(ctx->Exec, (n[1].e, n[2].ui, n[3].ui));
            break;
         case OPCODE_END_QUERY_INDEXED:
            CALL_EndQueryIndexed(ctx->Exec, (n[1].e, n[2].ui));
d7797 1
d7804 1
a7804 1
               CALL_DrawBuffers(ctx->Exec, (n[1].i, buffers));
d7807 1
d7809 1
a7809 1
	    CALL_BlitFramebuffer(ctx->Exec, (n[1].i, n[2].i, n[3].i, n[4].i,
d7813 2
d7816 1
a7816 1
	    CALL_UseProgram(ctx->Exec, (n[1].ui));
d7825 1
a7825 1
	    CALL_Uniform1f(ctx->Exec, (n[1].i, n[2].f));
d7828 1
a7828 1
	    CALL_Uniform2f(ctx->Exec, (n[1].i, n[2].f, n[3].f));
d7831 1
a7831 1
	    CALL_Uniform3f(ctx->Exec, (n[1].i, n[2].f, n[3].f, n[4].f));
d7834 1
a7834 1
	    CALL_Uniform4f(ctx->Exec,
d7838 1
a7838 1
	    CALL_Uniform1fv(ctx->Exec, (n[1].i, n[2].i, n[3].data));
d7841 1
a7841 1
	    CALL_Uniform2fv(ctx->Exec, (n[1].i, n[2].i, n[3].data));
d7844 1
a7844 1
	    CALL_Uniform3fv(ctx->Exec, (n[1].i, n[2].i, n[3].data));
d7847 1
a7847 1
	    CALL_Uniform4fv(ctx->Exec, (n[1].i, n[2].i, n[3].data));
d7850 1
a7850 1
	    CALL_Uniform1i(ctx->Exec, (n[1].i, n[2].i));
d7853 1
a7853 1
	    CALL_Uniform2i(ctx->Exec, (n[1].i, n[2].i, n[3].i));
d7856 1
a7856 1
	    CALL_Uniform3i(ctx->Exec, (n[1].i, n[2].i, n[3].i, n[4].i));
d7859 1
a7859 1
	    CALL_Uniform4i(ctx->Exec,
d7863 1
a7863 1
	    CALL_Uniform1iv(ctx->Exec, (n[1].i, n[2].i, n[3].data));
d7866 1
a7866 1
	    CALL_Uniform2iv(ctx->Exec, (n[1].i, n[2].i, n[3].data));
d7869 1
a7869 1
	    CALL_Uniform3iv(ctx->Exec, (n[1].i, n[2].i, n[3].data));
d7872 1
a7872 1
	    CALL_Uniform4iv(ctx->Exec, (n[1].i, n[2].i, n[3].data));
d7901 1
a7901 1
	    CALL_UniformMatrix2fv(ctx->Exec,
d7905 1
a7905 1
	    CALL_UniformMatrix3fv(ctx->Exec,
d7909 1
a7909 1
	    CALL_UniformMatrix4fv(ctx->Exec,
a7936 4
         case OPCODE_CLAMP_COLOR:
            CALL_ClampColor(ctx->Exec, (n[1].e, n[2].e));
            break;

d7947 1
d7961 1
d8069 1
a8069 1
               CALL_TexParameterIiv(ctx->Exec, (n[1].e, n[2].e, params));
d8079 1
a8079 110
               CALL_TexParameterIuiv(ctx->Exec, (n[1].e, n[2].e, params));
            }
            break;

         case OPCODE_VERTEX_ATTRIB_DIVISOR:
            /* GL_ARB_instanced_arrays */
            CALL_VertexAttribDivisor(ctx->Exec, (n[1].ui, n[2].ui));
            break;

         case OPCODE_TEXTURE_BARRIER_NV:
            CALL_TextureBarrierNV(ctx->Exec, ());
            break;

         /* GL_EXT/ARB_transform_feedback */
         case OPCODE_BEGIN_TRANSFORM_FEEDBACK:
            CALL_BeginTransformFeedback(ctx->Exec, (n[1].e));
            break;
         case OPCODE_END_TRANSFORM_FEEDBACK:
            CALL_EndTransformFeedback(ctx->Exec, ());
            break;
         case OPCODE_BIND_TRANSFORM_FEEDBACK:
            CALL_BindTransformFeedback(ctx->Exec, (n[1].e, n[2].ui));
            break;
         case OPCODE_PAUSE_TRANSFORM_FEEDBACK:
            CALL_PauseTransformFeedback(ctx->Exec, ());
            break;
         case OPCODE_RESUME_TRANSFORM_FEEDBACK:
            CALL_ResumeTransformFeedback(ctx->Exec, ());
            break;
         case OPCODE_DRAW_TRANSFORM_FEEDBACK:
            CALL_DrawTransformFeedback(ctx->Exec, (n[1].e, n[2].ui));
            break;
         case OPCODE_DRAW_TRANSFORM_FEEDBACK_STREAM:
            CALL_DrawTransformFeedbackStream(ctx->Exec,
                                             (n[1].e, n[2].ui, n[3].ui));
            break;
         case OPCODE_DRAW_TRANSFORM_FEEDBACK_INSTANCED:
            CALL_DrawTransformFeedbackInstanced(ctx->Exec,
                                                (n[1].e, n[2].ui, n[3].si));
            break;
         case OPCODE_DRAW_TRANSFORM_FEEDBACK_STREAM_INSTANCED:
            CALL_DrawTransformFeedbackStreamInstanced(ctx->Exec,
                                       (n[1].e, n[2].ui, n[3].ui, n[4].si));
            break;


         case OPCODE_BIND_SAMPLER:
            CALL_BindSampler(ctx->Exec, (n[1].ui, n[2].ui));
            break;
         case OPCODE_SAMPLER_PARAMETERIV:
            {
               GLint params[4];
               params[0] = n[3].i;
               params[1] = n[4].i;
               params[2] = n[5].i;
               params[3] = n[6].i;
               CALL_SamplerParameteriv(ctx->Exec, (n[1].ui, n[2].e, params));
            }
            break;
         case OPCODE_SAMPLER_PARAMETERFV:
            {
               GLfloat params[4];
               params[0] = n[3].f;
               params[1] = n[4].f;
               params[2] = n[5].f;
               params[3] = n[6].f;
               CALL_SamplerParameterfv(ctx->Exec, (n[1].ui, n[2].e, params));
            }
            break;
         case OPCODE_SAMPLER_PARAMETERIIV:
            {
               GLint params[4];
               params[0] = n[3].i;
               params[1] = n[4].i;
               params[2] = n[5].i;
               params[3] = n[6].i;
               CALL_SamplerParameterIiv(ctx->Exec, (n[1].ui, n[2].e, params));
            }
            break;
         case OPCODE_SAMPLER_PARAMETERUIV:
            {
               GLuint params[4];
               params[0] = n[3].ui;
               params[1] = n[4].ui;
               params[2] = n[5].ui;
               params[3] = n[6].ui;
               CALL_SamplerParameterIuiv(ctx->Exec, (n[1].ui, n[2].e, params));
            }
            break;

         /* GL_ARB_geometry_shader4 */
         case OPCODE_PROGRAM_PARAMETERI:
            CALL_ProgramParameteri(ctx->Exec, (n[1].ui, n[2].e, n[3].i));
            break;
         case OPCODE_FRAMEBUFFER_TEXTURE:
            CALL_FramebufferTexture(ctx->Exec, (n[1].e, n[2].e,
                                                   n[3].ui, n[4].i));
            break;
         case OPCODE_FRAMEBUFFER_TEXTURE_FACE:
            CALL_FramebufferTextureFaceARB(ctx->Exec, (n[1].e, n[2].e,
                                                       n[3].ui, n[4].i, n[5].e));
            break;

         /* GL_ARB_sync */
         case OPCODE_WAIT_SYNC:
            {
               union uint64_pair p;
               p.uint32[0] = n[3].ui;
               p.uint32[1] = n[4].ui;
               CALL_WaitSync(ctx->Exec, (n[1].data, n[2].bf, p.uint64));
a8082 12
         /* GL_NV_conditional_render */
         case OPCODE_BEGIN_CONDITIONAL_RENDER:
            CALL_BeginConditionalRender(ctx->Exec, (n[1].i, n[2].e));
            break;
         case OPCODE_END_CONDITIONAL_RENDER:
            CALL_EndConditionalRender(ctx->Exec, ());
            break;

         case OPCODE_UNIFORM_BLOCK_BINDING:
            CALL_UniformBlockBinding(ctx->Exec, (n[1].ui, n[2].ui, n[3].ui));
            break;

d8121 1
a8121 1
GLboolean GLAPIENTRY
d8134 1
a8134 1
void GLAPIENTRY
d8156 1
a8156 1
GLuint GLAPIENTRY
d8196 1
a8196 1
void GLAPIENTRY
d8227 2
a8228 1
   /* Reset accumulated list state */
d8246 1
a8246 1
void GLAPIENTRY
d8251 1
a8251 1
   FLUSH_VERTICES(ctx, 0);
a8255 5
   if (ctx->ExecuteFlag && _mesa_inside_dlist_begin_end(ctx)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glEndList() called inside glBegin/End");
   }

d8267 617
a8883 1
   (void) alloc_instruction(ctx, OPCODE_END_OF_LIST, 0);
d8885 7
a8891 2
   /* Destroy old list, if any */
   destroy_list(ctx, ctx->ListState.CurrentList->Name);
d8893 7
a8899 4
   /* Install the new list */
   _mesa_HashInsert(ctx->Shared->DisplayList,
                    ctx->ListState.CurrentList->Name,
                    ctx->ListState.CurrentList);
d8901 8
d8910 7
a8916 2
   if (MESA_VERBOSE & VERBOSE_DISPLAY_LIST)
      mesa_print_display_list(ctx->ListState.CurrentList->Name);
d8918 7
a8924 3
   ctx->ListState.CurrentList = NULL;
   ctx->ExecuteFlag = GL_TRUE;
   ctx->CompileFlag = GL_FALSE;
d8926 7
a8932 2
   ctx->CurrentDispatch = ctx->Exec;
   _glapi_set_dispatch(ctx->CurrentDispatch);
d8935 7
d8943 2
a8944 2
void GLAPIENTRY
_mesa_CallList(GLuint list)
a8945 1
   GLboolean save_compile_flag;
d8947 3
a8949 1
   FLUSH_CURRENT(ctx, 0);
d8951 9
a8959 2
   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glCallList %d\n", list);
d8961 11
a8971 4
   if (list == 0) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glCallList(list==0)");
      return;
   }
d8973 8
a8980 2
   if (0)
      mesa_print_display_list( list );
d8982 7
a8988 7
   /* VERY IMPORTANT:  Save the CompileFlag status, turn it off,
    * execute the display list, and restore the CompileFlag.
    */
   save_compile_flag = ctx->CompileFlag;
   if (save_compile_flag) {
      ctx->CompileFlag = GL_FALSE;
   }
d8990 8
a8997 2
   execute_list(ctx, list);
   ctx->CompileFlag = save_compile_flag;
d8999 7
a9005 5
   /* also restore API function pointers to point to "save" versions */
   if (save_compile_flag) {
      ctx->CurrentDispatch = ctx->Save;
      _glapi_set_dispatch(ctx->CurrentDispatch);
   }
d9008 8
d9017 3
a9019 5
/**
 * Execute glCallLists:  call multiple display lists.
 */
void GLAPIENTRY
_mesa_CallLists(GLsizei n, GLenum type, const GLvoid * lists)
d9022 3
a9024 2
   GLint i;
   GLboolean save_compile_flag;
d9026 7
a9032 2
   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glCallLists %d\n", n);
d9034 7
a9040 17
   switch (type) {
   case GL_BYTE:
   case GL_UNSIGNED_BYTE:
   case GL_SHORT:
   case GL_UNSIGNED_SHORT:
   case GL_INT:
   case GL_UNSIGNED_INT:
   case GL_FLOAT:
   case GL_2_BYTES:
   case GL_3_BYTES:
   case GL_4_BYTES:
      /* OK */
      break;
   default:
      _mesa_error(ctx, GL_INVALID_ENUM, "glCallLists(type)");
      return;
   }
d9042 7
a9048 5
   /* Save the CompileFlag status, turn it off, execute display list,
    * and restore the CompileFlag.
    */
   save_compile_flag = ctx->CompileFlag;
   ctx->CompileFlag = GL_FALSE;
d9050 8
a9057 4
   for (i = 0; i < n; i++) {
      GLuint list = (GLuint) (ctx->List.ListBase + translate_id(i, type, lists));
      execute_list(ctx, list);
   }
d9059 7
a9065 1
   ctx->CompileFlag = save_compile_flag;
d9067 8
a9074 5
   /* also restore API function pointers to point to "save" versions */
   if (save_compile_flag) {
      ctx->CurrentDispatch = ctx->Save;
      _glapi_set_dispatch(ctx->CurrentDispatch);
   }
d9077 11
d9089 7
a9095 5
/**
 * Set the offset added to list numbers in glCallLists.
 */
void GLAPIENTRY
_mesa_ListBase(GLuint base)
d9098 4
a9101 3
   FLUSH_VERTICES(ctx, 0);      /* must be called before assert */
   ASSERT_OUTSIDE_BEGIN_END(ctx);
   ctx->List.ListBase = base;
d9104 2
d9114 2
a9115 2
void
_mesa_initialize_save_table(const struct gl_context *ctx)
d9117 1
a9117 2
   struct _glapi_table *table = ctx->Save;
   int numEntries = MAX2(_gloffset_COUNT, _glapi_get_dispatch_table_size());
d9119 3
a9121 5
   /* Initially populate the dispatch table with the contents of the
    * normal-execution dispatch table.  This lets us skip populating functions
    * that should be called directly instead of compiled into display lists.
    */
   memcpy(table, ctx->Exec, numEntries * sizeof(_glapi_proc));
d9123 1
a9123 4
   _mesa_loopback_init_api_table(ctx, table);

   /* VBO functions */
   vbo_initialize_save_dispatch(ctx, table);
d9140 1
a9140 1
   SET_ColorMaski(table, save_ColorMaskIndexed);
d9144 1
d9149 1
a9149 1
   SET_Disablei(table, save_DisableIndexed);
d9153 2
a9154 1
   SET_Enablei(table, save_EnableIndexed);
d9157 2
d9165 29
d9197 2
d9232 2
d9272 2
a9273 1
   SET_Rectf(table, save_Rectf);
d9279 2
d9306 1
d9308 1
d9313 11
d9325 2
d9329 1
d9360 15
d9379 1
d9400 3
d9405 8
d9419 15
a9433 2
   SET_PointParameterf(table, save_PointParameterfEXT);
   SET_PointParameterfv(table, save_PointParameterfvEXT);
d9436 4
a9439 1
   SET_BlendFuncSeparate(table, save_BlendFuncSeparateEXT);
d9442 16
a9457 16
   SET_WindowPos2d(table, save_WindowPos2dMESA);
   SET_WindowPos2dv(table, save_WindowPos2dvMESA);
   SET_WindowPos2f(table, save_WindowPos2fMESA);
   SET_WindowPos2fv(table, save_WindowPos2fvMESA);
   SET_WindowPos2i(table, save_WindowPos2iMESA);
   SET_WindowPos2iv(table, save_WindowPos2ivMESA);
   SET_WindowPos2s(table, save_WindowPos2sMESA);
   SET_WindowPos2sv(table, save_WindowPos2svMESA);
   SET_WindowPos3d(table, save_WindowPos3dMESA);
   SET_WindowPos3dv(table, save_WindowPos3dvMESA);
   SET_WindowPos3f(table, save_WindowPos3fMESA);
   SET_WindowPos3fv(table, save_WindowPos3fvMESA);
   SET_WindowPos3i(table, save_WindowPos3iMESA);
   SET_WindowPos3iv(table, save_WindowPos3ivMESA);
   SET_WindowPos3s(table, save_WindowPos3sMESA);
   SET_WindowPos3sv(table, save_WindowPos3svMESA);
d9467 5
d9477 26
a9502 1
   SET_BindProgramARB(table, save_BindProgramNV);
d9509 1
d9512 21
d9535 2
a9536 2
   SET_PointParameteri(table, save_PointParameteriNV);
   SET_PointParameteriv(table, save_PointParameterivNV);
d9541 6
d9551 2
a9552 1
   SET_ActiveTexture(table, save_ActiveTextureARB);
d9555 4
a9558 4
   SET_LoadTransposeMatrixd(table, save_LoadTransposeMatrixdARB);
   SET_LoadTransposeMatrixf(table, save_LoadTransposeMatrixfARB);
   SET_MultTransposeMatrixd(table, save_MultTransposeMatrixdARB);
   SET_MultTransposeMatrixf(table, save_MultTransposeMatrixfARB);
d9561 1
a9561 1
   SET_SampleCoverage(table, save_SampleCoverageARB);
d9564 7
a9570 6
   SET_CompressedTexImage3D(table, save_CompressedTexImage3DARB);
   SET_CompressedTexImage2D(table, save_CompressedTexImage2DARB);
   SET_CompressedTexImage1D(table, save_CompressedTexImage1DARB);
   SET_CompressedTexSubImage3D(table, save_CompressedTexSubImage3DARB);
   SET_CompressedTexSubImage2D(table, save_CompressedTexSubImage2DARB);
   SET_CompressedTexSubImage1D(table, save_CompressedTexSubImage1DARB);
d9580 1
d9582 3
d9586 8
a9593 1
   SET_BindProgramARB(table, save_BindProgramNV);
d9602 25
d9628 37
a9664 28
   SET_BeginQuery(table, save_BeginQueryARB);
   SET_EndQuery(table, save_EndQueryARB);
   SET_QueryCounter(table, save_QueryCounter);

   SET_DrawBuffers(table, save_DrawBuffersARB);

   SET_BlitFramebuffer(table, save_BlitFramebufferEXT);

   SET_UseProgram(table, save_UseProgramObjectARB);
   SET_Uniform1f(table, save_Uniform1fARB);
   SET_Uniform2f(table, save_Uniform2fARB);
   SET_Uniform3f(table, save_Uniform3fARB);
   SET_Uniform4f(table, save_Uniform4fARB);
   SET_Uniform1fv(table, save_Uniform1fvARB);
   SET_Uniform2fv(table, save_Uniform2fvARB);
   SET_Uniform3fv(table, save_Uniform3fvARB);
   SET_Uniform4fv(table, save_Uniform4fvARB);
   SET_Uniform1i(table, save_Uniform1iARB);
   SET_Uniform2i(table, save_Uniform2iARB);
   SET_Uniform3i(table, save_Uniform3iARB);
   SET_Uniform4i(table, save_Uniform4iARB);
   SET_Uniform1iv(table, save_Uniform1ivARB);
   SET_Uniform2iv(table, save_Uniform2ivARB);
   SET_Uniform3iv(table, save_Uniform3ivARB);
   SET_Uniform4iv(table, save_Uniform4ivARB);
   SET_UniformMatrix2fv(table, save_UniformMatrix2fvARB);
   SET_UniformMatrix3fv(table, save_UniformMatrix3fvARB);
   SET_UniformMatrix4fv(table, save_UniformMatrix4fvARB);
d9672 6
d9679 1
a9679 1
   SET_BlendEquationSeparate(table, save_BlendEquationSeparateEXT);
d9682 1
d9685 16
d9703 7
a9709 1
   SET_ProvokingVertex(table, save_ProvokingVertexEXT);
d9714 4
a9717 2
   SET_TexParameterIiv(table, save_TexParameterIiv);
   SET_TexParameterIuiv(table, save_TexParameterIuiv);
a9722 3
   /* GL_ARB_color_buffer_float */
   SET_ClampColor(table, save_ClampColorARB);

d9724 1
a9728 1
#if 0
d9738 4
d9752 1
a9752 61
   /* These are: */
   SET_BeginTransformFeedback(table, save_BeginTransformFeedback);
   SET_EndTransformFeedback(table, save_EndTransformFeedback);
   SET_BindTransformFeedback(table, save_BindTransformFeedback);
   SET_PauseTransformFeedback(table, save_PauseTransformFeedback);
   SET_ResumeTransformFeedback(table, save_ResumeTransformFeedback);
   SET_DrawTransformFeedback(table, save_DrawTransformFeedback);
   SET_DrawTransformFeedbackStream(table, save_DrawTransformFeedbackStream);
   SET_DrawTransformFeedbackInstanced(table,
                                      save_DrawTransformFeedbackInstanced);
   SET_DrawTransformFeedbackStreamInstanced(table,
                                save_DrawTransformFeedbackStreamInstanced);
   SET_BeginQueryIndexed(table, save_BeginQueryIndexed);
   SET_EndQueryIndexed(table, save_EndQueryIndexed);

   /* GL_ARB_instanced_arrays */
   SET_VertexAttribDivisor(table, save_VertexAttribDivisor);

   /* GL_NV_texture_barrier */
   SET_TextureBarrierNV(table, save_TextureBarrierNV);

   SET_BindSampler(table, save_BindSampler);
   SET_SamplerParameteri(table, save_SamplerParameteri);
   SET_SamplerParameterf(table, save_SamplerParameterf);
   SET_SamplerParameteriv(table, save_SamplerParameteriv);
   SET_SamplerParameterfv(table, save_SamplerParameterfv);
   SET_SamplerParameterIiv(table, save_SamplerParameterIiv);
   SET_SamplerParameterIuiv(table, save_SamplerParameterIuiv);

   /* GL_ARB_draw_buffer_blend */
   SET_BlendFunciARB(table, save_BlendFunci);
   SET_BlendFuncSeparateiARB(table, save_BlendFuncSeparatei);
   SET_BlendEquationiARB(table, save_BlendEquationi);
   SET_BlendEquationSeparateiARB(table, save_BlendEquationSeparatei);

   /* GL_ARB_geometry_shader4 */
   SET_ProgramParameteri(table, save_ProgramParameteri);
   SET_FramebufferTexture(table, save_FramebufferTexture);
   SET_FramebufferTextureFaceARB(table, save_FramebufferTextureFace);

   /* GL_NV_conditional_render */
   SET_BeginConditionalRender(table, save_BeginConditionalRender);
   SET_EndConditionalRender(table, save_EndConditionalRender);

   /* GL_ARB_sync */
   SET_WaitSync(table, save_WaitSync);

   /* GL_ARB_uniform_buffer_object */
   SET_UniformBlockBinding(table, save_UniformBlockBinding);

   /* GL_ARB_draw_instanced */
   SET_DrawArraysInstancedARB(table, save_DrawArraysInstancedARB);
   SET_DrawElementsInstancedARB(table, save_DrawElementsInstancedARB);

   /* GL_ARB_draw_elements_base_vertex */
   SET_DrawElementsInstancedBaseVertex(table, save_DrawElementsInstancedBaseVertexARB);

   /* GL_ARB_base_instance */
   SET_DrawArraysInstancedBaseInstance(table, save_DrawArraysInstancedBaseInstance);
   SET_DrawElementsInstancedBaseInstance(table, save_DrawElementsInstancedBaseInstance);
   SET_DrawElementsInstancedBaseVertexBaseInstance(table, save_DrawElementsInstancedBaseVertexBaseInstance);
d10045 2
a10046 2
static void
save_vtxfmt_init(GLvertexformat * vfmt)
d10048 1
a10048 1
   vfmt->ArrayElement = _ae_ArrayElement;
d10052 1
a10052 2
   vfmt->CallList = save_CallList;
   vfmt->CallLists = save_CallLists;
d10061 1
a10061 6
   vfmt->EvalCoord1f = save_EvalCoord1f;
   vfmt->EvalCoord1fv = save_EvalCoord1fv;
   vfmt->EvalCoord2f = save_EvalCoord2f;
   vfmt->EvalCoord2fv = save_EvalCoord2fv;
   vfmt->EvalPoint1 = save_EvalPoint1;
   vfmt->EvalPoint2 = save_EvalPoint2;
d10094 8
d10110 18
d10140 17
d10184 3
a10186 1
   save_vtxfmt_init(&ctx->ListState.ListVtxfmt);
@


1.1.1.6
log
@Import Mesa 10.2.3
@
text
@d212 12
d246 1
d263 1
d284 2
a382 36
   /* OpenGL 4.2 / GL_ARB_separate_shader_objects */
   OPCODE_USE_PROGRAM_STAGES,
   OPCODE_PROGRAM_UNIFORM_1F,
   OPCODE_PROGRAM_UNIFORM_2F,
   OPCODE_PROGRAM_UNIFORM_3F,
   OPCODE_PROGRAM_UNIFORM_4F,
   OPCODE_PROGRAM_UNIFORM_1FV,
   OPCODE_PROGRAM_UNIFORM_2FV,
   OPCODE_PROGRAM_UNIFORM_3FV,
   OPCODE_PROGRAM_UNIFORM_4FV,
   OPCODE_PROGRAM_UNIFORM_1I,
   OPCODE_PROGRAM_UNIFORM_2I,
   OPCODE_PROGRAM_UNIFORM_3I,
   OPCODE_PROGRAM_UNIFORM_4I,
   OPCODE_PROGRAM_UNIFORM_1IV,
   OPCODE_PROGRAM_UNIFORM_2IV,
   OPCODE_PROGRAM_UNIFORM_3IV,
   OPCODE_PROGRAM_UNIFORM_4IV,
   OPCODE_PROGRAM_UNIFORM_1UI,
   OPCODE_PROGRAM_UNIFORM_2UI,
   OPCODE_PROGRAM_UNIFORM_3UI,
   OPCODE_PROGRAM_UNIFORM_4UI,
   OPCODE_PROGRAM_UNIFORM_1UIV,
   OPCODE_PROGRAM_UNIFORM_2UIV,
   OPCODE_PROGRAM_UNIFORM_3UIV,
   OPCODE_PROGRAM_UNIFORM_4UIV,
   OPCODE_PROGRAM_UNIFORM_MATRIX22F,
   OPCODE_PROGRAM_UNIFORM_MATRIX33F,
   OPCODE_PROGRAM_UNIFORM_MATRIX44F,
   OPCODE_PROGRAM_UNIFORM_MATRIX23F,
   OPCODE_PROGRAM_UNIFORM_MATRIX32F,
   OPCODE_PROGRAM_UNIFORM_MATRIX24F,
   OPCODE_PROGRAM_UNIFORM_MATRIX42F,
   OPCODE_PROGRAM_UNIFORM_MATRIX34F,
   OPCODE_PROGRAM_UNIFORM_MATRIX43F,

d426 4
a488 4
 *
 * Note, all of these members should be 4 bytes in size or less for the
 * sake of compact display lists.  We store 8-byte pointers in a pair of
 * these nodes using the save/get_pointer() functions below.
d503 2
a510 49
/** How many 4-byte dwords to store a pointer */
#define POINTER_DWORDS (sizeof(void *) / 4)

/* We want to keep sizeof(union gl_dlist_node) == 4 to minimize
 * space for display lists.  The following types and functions are
 * used to help store 4- and 8-byte pointers in 1 or 2 dlist_nodes.
 */
union pointer
{
   void *ptr;
   GLuint dwords[POINTER_DWORDS];
};


/**
 * Save a 4 or 8-byte pointer at dest (and dest+1).
 */
static inline void
save_pointer(union gl_dlist_node *dest, void *src)
{
   union pointer p;
   unsigned i;

   STATIC_ASSERT(POINTER_DWORDS == 1 || POINTER_DWORDS == 2);
   STATIC_ASSERT(sizeof(union gl_dlist_node) == 4);

   p.ptr = src;

   for (i = 0; i < POINTER_DWORDS; i++)
      dest[i].ui = p.dwords[i];
}


/**
 * Retrieve a 4 or 8-byte pointer from node (node+1).
 */
static inline void *
get_pointer(const union gl_dlist_node *node)
{
   union pointer p;
   unsigned i;

   for (i = 0; i < POINTER_DWORDS; i++)
      p.dwords[i] = node[i].ui;

   return p.ptr;
}


d523 3
a525 3
 * How many nodes to allocate at a time.  Note that bulk vertex data
 * from glBegin/glVertex/glEnd primitives will typically wind up in
 * a VBO, and not directly in the display list itself.
d541 5
d547 2
a548 2
 * Allocate a gl_display_list object with an initial block of storage.
 * \param count  how many display list nodes/tokes to allocate
d564 2
a565 2
struct gl_display_list *
_mesa_lookup_list(struct gl_context *ctx, GLuint list)
d640 1
a640 1
            free(get_pointer(&n[6]));
d644 1
a644 1
            free(get_pointer(&n[10]));
d648 1
a648 1
            free(get_pointer(&n[5]));
d652 17
a668 1
            free(get_pointer(&n[7]));
d672 1
a672 1
            free(get_pointer(&n[1]));
d676 1
a676 1
            free(get_pointer(&n[8]));
d680 1
a680 1
            free(get_pointer(&n[9]));
d684 1
a684 1
            free(get_pointer(&n[10]));
d688 1
a688 1
            free(get_pointer(&n[7]));
d692 1
a692 1
            free(get_pointer(&n[9]));
d696 1
a696 1
            free(get_pointer(&n[11]));
d700 1
a700 1
            free(get_pointer(&n[7]));
d704 1
a704 1
            free(get_pointer(&n[8]));
d708 1
a708 1
            free(get_pointer(&n[9]));
d712 1
a712 1
            free(get_pointer(&n[7]));
d716 1
a716 1
            free(get_pointer(&n[9]));
d720 1
a720 1
            free(get_pointer(&n[11]));
d724 1
a724 1
            free(get_pointer(&n[4]));      /* program string */
d739 1
a739 1
            free(get_pointer(&n[3]));
d751 1
a751 32
            free(get_pointer(&n[4]));
            n += InstSize[n[0].opcode];
            break;
         case OPCODE_PROGRAM_UNIFORM_1FV:
         case OPCODE_PROGRAM_UNIFORM_2FV:
         case OPCODE_PROGRAM_UNIFORM_3FV:
         case OPCODE_PROGRAM_UNIFORM_4FV:
         case OPCODE_PROGRAM_UNIFORM_1IV:
         case OPCODE_PROGRAM_UNIFORM_2IV:
         case OPCODE_PROGRAM_UNIFORM_3IV:
         case OPCODE_PROGRAM_UNIFORM_4IV:
         case OPCODE_PROGRAM_UNIFORM_1UIV:
         case OPCODE_PROGRAM_UNIFORM_2UIV:
         case OPCODE_PROGRAM_UNIFORM_3UIV:
         case OPCODE_PROGRAM_UNIFORM_4UIV:
            free(get_pointer(&n[4]));
            n += InstSize[n[0].opcode];
            break;
         case OPCODE_PROGRAM_UNIFORM_MATRIX22F:
         case OPCODE_PROGRAM_UNIFORM_MATRIX33F:
         case OPCODE_PROGRAM_UNIFORM_MATRIX44F:
         case OPCODE_PROGRAM_UNIFORM_MATRIX24F:
         case OPCODE_PROGRAM_UNIFORM_MATRIX42F:
         case OPCODE_PROGRAM_UNIFORM_MATRIX23F:
         case OPCODE_PROGRAM_UNIFORM_MATRIX32F:
         case OPCODE_PROGRAM_UNIFORM_MATRIX34F:
         case OPCODE_PROGRAM_UNIFORM_MATRIX43F:
            free(get_pointer(&n[5]));
            n += InstSize[n[0].opcode];
            break;
         case OPCODE_PIXEL_MAP:
            free(get_pointer(&n[3]));
d756 1
a756 1
            n = (Node *) get_pointer(&n[1]);
a771 1
   free(dlist->Label);
d788 1
a788 1
   dlist = _mesa_lookup_list(ctx, list);
d854 6
d904 1
a904 2
				    GL_MAP_READ_BIT, unpack->BufferObj,
                                    MAP_INTERNAL);
d918 1
a918 1
      ctx->Driver.UnmapBuffer(ctx, unpack->BufferObj, MAP_INTERNAL);
a930 12

/** Return copy of memory */
static void *
memdup(const void *src, GLsizei bytes)
{
   void *b = bytes >= 0 ? malloc(bytes) : NULL;
   if (b)
      memcpy(b, src, bytes);
   return b;
}


a940 1
   const GLuint contNodes = 1 + POINTER_DWORDS;  /* size of continue info */
d954 1
a954 1
   if (ctx->ListState.CurrentPos + numNodes + contNodes > BLOCK_SIZE) {
d964 1
a964 1
      save_pointer(&n[1], newblock);
a1044 31
/**
 * Called by EndList to try to reduce memory used for the list.
 */
static void
trim_list(struct gl_context *ctx)
{
   /* If the list we're ending only has one allocated block of nodes/tokens
    * and its size isn't a full block size, realloc the block to use less
    * memory.  This is important for apps that create many small display
    * lists and apps that use glXUseXFont (many lists each containing one
    * glBitmap call).
    * Note: we currently only trim display lists that allocated one block
    * of tokens.  That hits the short list case which is what we're mainly
    * concerned with.  Trimming longer lists would involve traversing the
    * linked list of blocks.
    */
   struct gl_dlist_state *list = &ctx->ListState;

   if ((list->CurrentList->Head == list->CurrentBlock) &&
       (list->CurrentPos < BLOCK_SIZE)) {
      /* There's only one block and it's not full, so realloc */
      GLuint newSize = list->CurrentPos * sizeof(Node);
      list->CurrentList->Head =
      list->CurrentBlock = realloc(list->CurrentBlock, newSize);
      if (!list->CurrentBlock) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glEndList");
      }
   }
}


d1108 1
a1108 1
   n = alloc_instruction(ctx, OPCODE_BITMAP, 6 + POINTER_DWORDS);
d1116 2
a1117 3
      save_pointer(&n[7],
                   unpack_image(ctx, 2, width, height, 1, GL_COLOR_INDEX,
                                GL_BITMAP, pixels, &ctx->Unpack));
d1737 3
a1739 1
save_CopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type)
d1742 4
a1745 9
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_COPY_PIXELS, 5);
   if (n) {
      n[1].i = x;
      n[2].i = y;
      n[3].i = (GLint) width;
      n[4].i = (GLint) height;
      n[5].e = type;
d1747 17
a1763 2
   if (ctx->ExecuteFlag) {
      CALL_CopyPixels(ctx->Exec, (x, y, width, height, type));
d1770 2
a1771 2
save_CopyTexImage1D(GLenum target, GLint level, GLenum internalformat,
                    GLint x, GLint y, GLsizei width, GLint border)
d1775 1
d1777 2
a1778 1
   n = alloc_instruction(ctx, OPCODE_COPY_TEX_IMAGE1D, 7);
d1781 9
a1789 6
      n[2].i = level;
      n[3].e = internalformat;
      n[4].i = x;
      n[5].i = y;
      n[6].i = width;
      n[7].i = border;
d1791 1
d1793 1
a1793 2
      CALL_CopyTexImage1D(ctx->Exec, (target, level, internalformat,
                                      x, y, width, border));
d1799 1
a1799 4
save_CopyTexImage2D(GLenum target, GLint level,
                    GLenum internalformat,
                    GLint x, GLint y, GLsizei width,
                    GLsizei height, GLint border)
d1803 1
d1805 2
a1806 1
   n = alloc_instruction(ctx, OPCODE_COPY_TEX_IMAGE2D, 8);
d1809 9
a1817 7
      n[2].i = level;
      n[3].e = internalformat;
      n[4].i = x;
      n[5].i = y;
      n[6].i = width;
      n[7].i = height;
      n[8].i = border;
d1819 1
d1821 1
a1821 2
      CALL_CopyTexImage2D(ctx->Exec, (target, level, internalformat,
                                      x, y, width, height, border));
d1828 2
a1829 2
save_CopyTexSubImage1D(GLenum target, GLint level,
                       GLint xoffset, GLint x, GLint y, GLsizei width)
d1834 1
a1834 1
   n = alloc_instruction(ctx, OPCODE_COPY_TEX_SUB_IMAGE1D, 6);
d1837 6
a1842 5
      n[2].i = level;
      n[3].i = xoffset;
      n[4].i = x;
      n[5].i = y;
      n[6].i = width;
d1845 2
a1846 2
      CALL_CopyTexSubImage1D(ctx->Exec,
                             (target, level, xoffset, x, y, width));
d1852 2
a1853 3
save_CopyTexSubImage2D(GLenum target, GLint level,
                       GLint xoffset, GLint yoffset,
                       GLint x, GLint y, GLsizei width, GLint height)
d1857 1
d1859 1
a1859 1
   n = alloc_instruction(ctx, OPCODE_COPY_TEX_SUB_IMAGE2D, 8);
d1862 4
a1865 7
      n[2].i = level;
      n[3].i = xoffset;
      n[4].i = yoffset;
      n[5].i = x;
      n[6].i = y;
      n[7].i = width;
      n[8].i = height;
d1868 1
a1868 2
      CALL_CopyTexSubImage2D(ctx->Exec, (target, level, xoffset, yoffset,
                                         x, y, width, height));
d1874 2
a1875 3
save_CopyTexSubImage3D(GLenum target, GLint level,
                       GLint xoffset, GLint yoffset, GLint zoffset,
                       GLint x, GLint y, GLsizei width, GLint height)
d1879 1
d1881 1
a1881 1
   n = alloc_instruction(ctx, OPCODE_COPY_TEX_SUB_IMAGE3D, 9);
d1884 4
a1887 8
      n[2].i = level;
      n[3].i = xoffset;
      n[4].i = yoffset;
      n[5].i = zoffset;
      n[6].i = x;
      n[7].i = y;
      n[8].i = width;
      n[9].i = height;
d1890 1
a1890 3
      CALL_CopyTexSubImage3D(ctx->Exec, (target, level,
                                         xoffset, yoffset, zoffset,
                                         x, y, width, height));
d1896 2
a1897 1
save_CullFace(GLenum mode)
d1901 1
d1903 2
a1904 1
   n = alloc_instruction(ctx, OPCODE_CULL_FACE, 1);
d1906 7
a1912 1
      n[1].e = mode;
d1915 2
a1916 1
      CALL_CullFace(ctx->Exec, (mode));
d1922 3
a1924 1
save_DepthFunc(GLenum func)
d1928 1
d1930 2
a1931 1
   n = alloc_instruction(ctx, OPCODE_DEPTH_FUNC, 1);
d1933 8
a1940 1
      n[1].e = func;
d1943 3
a1945 1
      CALL_DepthFunc(ctx->Exec, (func));
d1951 1
a1951 1
save_DepthMask(GLboolean mask)
d1956 1
a1956 1
   n = alloc_instruction(ctx, OPCODE_DEPTH_MASK, 1);
d1958 3
a1960 1
      n[1].b = mask;
d1963 1
a1963 1
      CALL_DepthMask(ctx->Exec, (mask));
d1969 1
a1969 1
save_DepthRange(GLclampd nearval, GLclampd farval)
d1974 1
a1974 1
   n = alloc_instruction(ctx, OPCODE_DEPTH_RANGE, 2);
d1976 13
a1988 2
      n[1].f = (GLfloat) nearval;
      n[2].f = (GLfloat) farval;
d1991 1
a1991 1
      CALL_DepthRange(ctx->Exec, (nearval, farval));
d1997 1
a1997 1
save_Disable(GLenum cap)
d2002 1
a2002 1
   n = alloc_instruction(ctx, OPCODE_DISABLE, 1);
d2004 3
a2006 1
      n[1].e = cap;
d2009 1
a2009 1
      CALL_Disable(ctx->Exec, (cap));
d2015 2
a2016 1
save_DisableIndexed(GLuint index, GLenum cap)
d2021 1
a2021 1
   n = alloc_instruction(ctx, OPCODE_DISABLE_INDEXED, 2);
d2023 13
a2035 2
      n[1].ui = index;
      n[2].e = cap;
d2038 1
a2038 1
      CALL_Disablei(ctx->Exec, (index, cap));
d2044 1
a2044 1
save_DrawBuffer(GLenum mode)
d2049 1
a2049 1
   n = alloc_instruction(ctx, OPCODE_DRAW_BUFFER, 1);
d2051 249
a2299 1
      n[1].e = mode;
d2316 1
a2316 1
   n = alloc_instruction(ctx, OPCODE_DRAW_PIXELS, 4 + POINTER_DWORDS);
d2322 2
a2323 3
      save_pointer(&n[5],
                   unpack_image(ctx, 2, width, height, 1, format, type,
                                pixels, &ctx->Unpack));
d2532 2
a2533 1
save_IndexMask(GLuint mask)
d2537 1
d2539 1
a2539 1
   n = alloc_instruction(ctx, OPCODE_INDEX_MASK, 1);
d2541 4
a2544 1
      n[1].ui = mask;
d2547 1
a2547 1
      CALL_IndexMask(ctx->Exec, (mask));
d2553 17
a2569 1
save_InitNames(void)
d2892 1
a2892 1
   n = alloc_instruction(ctx, OPCODE_MAP1, 5 + POINTER_DWORDS);
d2900 1
a2900 1
      save_pointer(&n[6], pnts);
d2914 1
a2914 1
   n = alloc_instruction(ctx, OPCODE_MAP1, 5 + POINTER_DWORDS);
d2922 1
a2922 1
      save_pointer(&n[6], pnts);
d2939 1
a2939 1
   n = alloc_instruction(ctx, OPCODE_MAP2, 9 + POINTER_DWORDS);
d2953 1
a2953 1
      save_pointer(&n[10], pnts);
d2972 1
a2972 1
   n = alloc_instruction(ctx, OPCODE_MAP2, 9 + POINTER_DWORDS);
d2986 1
a2986 1
      save_pointer(&n[10], pnts);
d3069 19
d3158 1
a3158 1
   n = alloc_instruction(ctx, OPCODE_PIXEL_MAP, 2 + POINTER_DWORDS);
d3162 2
a3163 1
      save_pointer(&n[3], memdup(values, mapsize * sizeof(GLfloat)));
d3338 1
a3338 1
   n = alloc_instruction(ctx, OPCODE_POLYGON_STIPPLE, POINTER_DWORDS);
d3340 2
a3341 3
      save_pointer(&n[1],
                   unpack_image(ctx, 2, 32, 32, 1, GL_COLOR_INDEX, GL_BITMAP,
                                pattern, &ctx->Unpack));
d3669 32
d4142 1
a4142 1
      n = alloc_instruction(ctx, OPCODE_TEX_IMAGE1D, 7 + POINTER_DWORDS);
d4151 2
a4152 3
         save_pointer(&n[8],
                      unpack_image(ctx, 1, width, 1, 1, format, type,
                                   pixels, &ctx->Unpack));
d4177 1
a4177 1
      n = alloc_instruction(ctx, OPCODE_TEX_IMAGE2D, 8 + POINTER_DWORDS);
d4187 2
a4188 3
         save_pointer(&n[9],
                      unpack_image(ctx, 2, width, height, 1, format, type,
                                   pixels, &ctx->Unpack));
d4215 1
a4215 1
      n = alloc_instruction(ctx, OPCODE_TEX_IMAGE3D, 9 + POINTER_DWORDS);
d4226 2
a4227 3
         save_pointer(&n[10],
                      unpack_image(ctx, 3, width, height, depth, format, type,
                                   pixels, &ctx->Unpack));
d4248 1
a4248 1
   n = alloc_instruction(ctx, OPCODE_TEX_SUB_IMAGE1D, 6 + POINTER_DWORDS);
d4256 2
a4257 3
      save_pointer(&n[7],
                   unpack_image(ctx, 1, width, 1, 1, format, type,
                                pixels, &ctx->Unpack));
d4277 1
a4277 1
   n = alloc_instruction(ctx, OPCODE_TEX_SUB_IMAGE2D, 8 + POINTER_DWORDS);
d4287 2
a4288 3
      save_pointer(&n[9],
                   unpack_image(ctx, 2, width, height, 1, format, type,
                                pixels, &ctx->Unpack));
d4308 1
a4308 1
   n = alloc_instruction(ctx, OPCODE_TEX_SUB_IMAGE3D, 10 + POINTER_DWORDS);
d4320 2
a4321 3
      save_pointer(&n[11],
                   unpack_image(ctx, 3, width, height, depth, format, type,
                                pixels, &ctx->Unpack));
d4628 1
a4628 2
      n = alloc_instruction(ctx, OPCODE_COMPRESSED_TEX_IMAGE_1D,
                            6 + POINTER_DWORDS);
d4636 1
a4636 2
         save_pointer(&n[7],
                      copy_data(data, imageSize, "glCompressedTexImage1DARB"));
d4664 1
a4664 2
      n = alloc_instruction(ctx, OPCODE_COMPRESSED_TEX_IMAGE_2D,
                            7 + POINTER_DWORDS);
d4673 1
a4673 2
         save_pointer(&n[8],
                      copy_data(data, imageSize, "glCompressedTexImage2DARB"));
d4701 1
a4701 2
      n = alloc_instruction(ctx, OPCODE_COMPRESSED_TEX_IMAGE_3D,
                            8 + POINTER_DWORDS);
d4711 1
a4711 2
         save_pointer(&n[9],
                      copy_data(data, imageSize, "glCompressedTexImage3DARB"));
d4732 1
a4732 2
   n = alloc_instruction(ctx, OPCODE_COMPRESSED_TEX_SUB_IMAGE_1D,
                         6 + POINTER_DWORDS);
d4740 1
a4740 2
      save_pointer(&n[7],
                   copy_data(data, imageSize, "glCompressedTexSubImage1DARB"));
d4760 1
a4760 2
   n = alloc_instruction(ctx, OPCODE_COMPRESSED_TEX_SUB_IMAGE_2D,
                         8 + POINTER_DWORDS);
d4770 1
a4770 2
      save_pointer(&n[9],
                   copy_data(data, imageSize, "glCompressedTexSubImage2DARB"));
d4790 1
a4790 2
   n = alloc_instruction(ctx, OPCODE_COMPRESSED_TEX_SUB_IMAGE_3D,
                         10 + POINTER_DWORDS);
d4802 1
a4802 2
      save_pointer(&n[11],
                   copy_data(data, imageSize, "glCompressedTexSubImage3DARB"));
d5100 1
a5100 1
   n = alloc_instruction(ctx, OPCODE_PROGRAM_STRING_ARB, 3 + POINTER_DWORDS);
d5111 1
a5111 1
      save_pointer(&n[4], programCopy);
d6041 1
a6041 530
save_ProvokingVertexEXT(GLenum mode)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_PROVOKING_VERTEX, 1);
   if (n) {
      n[1].e = mode;
   }
   if (ctx->ExecuteFlag) {
      /*CALL_ProvokingVertex(ctx->Exec, (mode));*/
      _mesa_ProvokingVertex(mode);
   }
}


/** GL_EXT_transform_feedback */
static void GLAPIENTRY
save_BeginTransformFeedback(GLenum mode)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_BEGIN_TRANSFORM_FEEDBACK, 1);
   if (n) {
      n[1].e = mode;
   }
   if (ctx->ExecuteFlag) {
      CALL_BeginTransformFeedback(ctx->Exec, (mode));
   }
}


/** GL_EXT_transform_feedback */
static void GLAPIENTRY
save_EndTransformFeedback(void)
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   (void) alloc_instruction(ctx, OPCODE_END_TRANSFORM_FEEDBACK, 0);
   if (ctx->ExecuteFlag) {
      CALL_EndTransformFeedback(ctx->Exec, ());
   }
}

static void GLAPIENTRY
save_BindTransformFeedback(GLenum target, GLuint name)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_BIND_TRANSFORM_FEEDBACK, 2);
   if (n) {
      n[1].e = target;
      n[2].ui = name;
   }
   if (ctx->ExecuteFlag) {
      CALL_BindTransformFeedback(ctx->Exec, (target, name));
   }
}

static void GLAPIENTRY
save_PauseTransformFeedback(void)
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   (void) alloc_instruction(ctx, OPCODE_PAUSE_TRANSFORM_FEEDBACK, 0);
   if (ctx->ExecuteFlag) {
      CALL_PauseTransformFeedback(ctx->Exec, ());
   }
}

static void GLAPIENTRY
save_ResumeTransformFeedback(void)
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   (void) alloc_instruction(ctx, OPCODE_RESUME_TRANSFORM_FEEDBACK, 0);
   if (ctx->ExecuteFlag) {
      CALL_ResumeTransformFeedback(ctx->Exec, ());
   }
}

static void GLAPIENTRY
save_DrawTransformFeedback(GLenum mode, GLuint name)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_DRAW_TRANSFORM_FEEDBACK, 2);
   if (n) {
      n[1].e = mode;
      n[2].ui = name;
   }
   if (ctx->ExecuteFlag) {
      CALL_DrawTransformFeedback(ctx->Exec, (mode, name));
   }
}

static void GLAPIENTRY
save_DrawTransformFeedbackStream(GLenum mode, GLuint name, GLuint stream)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_DRAW_TRANSFORM_FEEDBACK_STREAM, 3);
   if (n) {
      n[1].e = mode;
      n[2].ui = name;
      n[3].ui = stream;
   }
   if (ctx->ExecuteFlag) {
      CALL_DrawTransformFeedbackStream(ctx->Exec, (mode, name, stream));
   }
}

static void GLAPIENTRY
save_DrawTransformFeedbackInstanced(GLenum mode, GLuint name,
                                    GLsizei primcount)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_DRAW_TRANSFORM_FEEDBACK_INSTANCED, 3);
   if (n) {
      n[1].e = mode;
      n[2].ui = name;
      n[3].si = primcount;
   }
   if (ctx->ExecuteFlag) {
      CALL_DrawTransformFeedbackInstanced(ctx->Exec, (mode, name, primcount));
   }
}

static void GLAPIENTRY
save_DrawTransformFeedbackStreamInstanced(GLenum mode, GLuint name,
                                          GLuint stream, GLsizei primcount)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_DRAW_TRANSFORM_FEEDBACK_STREAM_INSTANCED, 4);
   if (n) {
      n[1].e = mode;
      n[2].ui = name;
      n[3].ui = stream;
      n[4].si = primcount;
   }
   if (ctx->ExecuteFlag) {
      CALL_DrawTransformFeedbackStreamInstanced(ctx->Exec, (mode, name, stream,
                                                            primcount));
   }
}

/* aka UseProgram() */
static void GLAPIENTRY
save_UseProgramObjectARB(GLhandleARB program)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_USE_PROGRAM, 1);
   if (n) {
      n[1].ui = program;
   }
   if (ctx->ExecuteFlag) {
      CALL_UseProgram(ctx->Exec, (program));
   }
}


static void GLAPIENTRY
save_Uniform1fARB(GLint location, GLfloat x)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_1F, 2);
   if (n) {
      n[1].i = location;
      n[2].f = x;
   }
   if (ctx->ExecuteFlag) {
      CALL_Uniform1f(ctx->Exec, (location, x));
   }
}


static void GLAPIENTRY
save_Uniform2fARB(GLint location, GLfloat x, GLfloat y)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_2F, 3);
   if (n) {
      n[1].i = location;
      n[2].f = x;
      n[3].f = y;
   }
   if (ctx->ExecuteFlag) {
      CALL_Uniform2f(ctx->Exec, (location, x, y));
   }
}


static void GLAPIENTRY
save_Uniform3fARB(GLint location, GLfloat x, GLfloat y, GLfloat z)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_3F, 4);
   if (n) {
      n[1].i = location;
      n[2].f = x;
      n[3].f = y;
      n[4].f = z;
   }
   if (ctx->ExecuteFlag) {
      CALL_Uniform3f(ctx->Exec, (location, x, y, z));
   }
}


static void GLAPIENTRY
save_Uniform4fARB(GLint location, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_4F, 5);
   if (n) {
      n[1].i = location;
      n[2].f = x;
      n[3].f = y;
      n[4].f = z;
      n[5].f = w;
   }
   if (ctx->ExecuteFlag) {
      CALL_Uniform4f(ctx->Exec, (location, x, y, z, w));
   }
}


static void GLAPIENTRY
save_Uniform1fvARB(GLint location, GLsizei count, const GLfloat *v)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_1FV, 2 + POINTER_DWORDS);
   if (n) {
      n[1].i = location;
      n[2].i = count;
      save_pointer(&n[3], memdup(v, count * 1 * sizeof(GLfloat)));
   }
   if (ctx->ExecuteFlag) {
      CALL_Uniform1fv(ctx->Exec, (location, count, v));
   }
}

static void GLAPIENTRY
save_Uniform2fvARB(GLint location, GLsizei count, const GLfloat *v)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_2FV, 2 + POINTER_DWORDS);
   if (n) {
      n[1].i = location;
      n[2].i = count;
      save_pointer(&n[3], memdup(v, count * 2 * sizeof(GLfloat)));
   }
   if (ctx->ExecuteFlag) {
      CALL_Uniform2fv(ctx->Exec, (location, count, v));
   }
}

static void GLAPIENTRY
save_Uniform3fvARB(GLint location, GLsizei count, const GLfloat *v)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_3FV, 2 + POINTER_DWORDS);
   if (n) {
      n[1].i = location;
      n[2].i = count;
      save_pointer(&n[3], memdup(v, count * 3 * sizeof(GLfloat)));
   }
   if (ctx->ExecuteFlag) {
      CALL_Uniform3fv(ctx->Exec, (location, count, v));
   }
}

static void GLAPIENTRY
save_Uniform4fvARB(GLint location, GLsizei count, const GLfloat *v)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_4FV, 2 + POINTER_DWORDS);
   if (n) {
      n[1].i = location;
      n[2].i = count;
      save_pointer(&n[3], memdup(v, count * 4 * sizeof(GLfloat)));
   }
   if (ctx->ExecuteFlag) {
      CALL_Uniform4fv(ctx->Exec, (location, count, v));
   }
}


static void GLAPIENTRY
save_Uniform1iARB(GLint location, GLint x)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_1I, 2);
   if (n) {
      n[1].i = location;
      n[2].i = x;
   }
   if (ctx->ExecuteFlag) {
      CALL_Uniform1i(ctx->Exec, (location, x));
   }
}

static void GLAPIENTRY
save_Uniform2iARB(GLint location, GLint x, GLint y)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_2I, 3);
   if (n) {
      n[1].i = location;
      n[2].i = x;
      n[3].i = y;
   }
   if (ctx->ExecuteFlag) {
      CALL_Uniform2i(ctx->Exec, (location, x, y));
   }
}

static void GLAPIENTRY
save_Uniform3iARB(GLint location, GLint x, GLint y, GLint z)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_3I, 4);
   if (n) {
      n[1].i = location;
      n[2].i = x;
      n[3].i = y;
      n[4].i = z;
   }
   if (ctx->ExecuteFlag) {
      CALL_Uniform3i(ctx->Exec, (location, x, y, z));
   }
}

static void GLAPIENTRY
save_Uniform4iARB(GLint location, GLint x, GLint y, GLint z, GLint w)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_4I, 5);
   if (n) {
      n[1].i = location;
      n[2].i = x;
      n[3].i = y;
      n[4].i = z;
      n[5].i = w;
   }
   if (ctx->ExecuteFlag) {
      CALL_Uniform4i(ctx->Exec, (location, x, y, z, w));
   }
}



static void GLAPIENTRY
save_Uniform1ivARB(GLint location, GLsizei count, const GLint *v)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_1IV, 2 + POINTER_DWORDS);
   if (n) {
      n[1].i = location;
      n[2].i = count;
      save_pointer(&n[3], memdup(v, count * 1 * sizeof(GLint)));
   }
   if (ctx->ExecuteFlag) {
      CALL_Uniform1iv(ctx->Exec, (location, count, v));
   }
}

static void GLAPIENTRY
save_Uniform2ivARB(GLint location, GLsizei count, const GLint *v)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_2IV, 2 + POINTER_DWORDS);
   if (n) {
      n[1].i = location;
      n[2].i = count;
      save_pointer(&n[3], memdup(v, count * 2 * sizeof(GLint)));
   }
   if (ctx->ExecuteFlag) {
      CALL_Uniform2iv(ctx->Exec, (location, count, v));
   }
}

static void GLAPIENTRY
save_Uniform3ivARB(GLint location, GLsizei count, const GLint *v)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_3IV, 2 + POINTER_DWORDS);
   if (n) {
      n[1].i = location;
      n[2].i = count;
      save_pointer(&n[3], memdup(v, count * 3 * sizeof(GLint)));
   }
   if (ctx->ExecuteFlag) {
      CALL_Uniform3iv(ctx->Exec, (location, count, v));
   }
}

static void GLAPIENTRY
save_Uniform4ivARB(GLint location, GLsizei count, const GLint *v)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_4IV, 2 + POINTER_DWORDS);
   if (n) {
      n[1].i = location;
      n[2].i = count;
      save_pointer(&n[3], memdup(v, count * 4 * sizeof(GLfloat)));
   }
   if (ctx->ExecuteFlag) {
      CALL_Uniform4iv(ctx->Exec, (location, count, v));
   }
}



static void GLAPIENTRY
save_Uniform1ui(GLint location, GLuint x)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_1UI, 2);
   if (n) {
      n[1].i = location;
      n[2].i = x;
   }
   if (ctx->ExecuteFlag) {
      /*CALL_Uniform1ui(ctx->Exec, (location, x));*/
   }
}

static void GLAPIENTRY
save_Uniform2ui(GLint location, GLuint x, GLuint y)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_2UI, 3);
   if (n) {
      n[1].i = location;
      n[2].i = x;
      n[3].i = y;
   }
   if (ctx->ExecuteFlag) {
      /*CALL_Uniform2ui(ctx->Exec, (location, x, y));*/
   }
}

static void GLAPIENTRY
save_Uniform3ui(GLint location, GLuint x, GLuint y, GLuint z)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_3UI, 4);
   if (n) {
      n[1].i = location;
      n[2].i = x;
      n[3].i = y;
      n[4].i = z;
   }
   if (ctx->ExecuteFlag) {
      /*CALL_Uniform3ui(ctx->Exec, (location, x, y, z));*/
   }
}

static void GLAPIENTRY
save_Uniform4ui(GLint location, GLuint x, GLuint y, GLuint z, GLuint w)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_UNIFORM_4UI, 5);
   if (n) {
      n[1].i = location;
      n[2].i = x;
      n[3].i = y;
      n[4].i = z;
      n[5].i = w;
   }
   if (ctx->ExecuteFlag) {
      /*CALL_Uniform4ui(ctx->Exec, (location, x, y, z, w));*/
   }
}



static void GLAPIENTRY
save_Uniform1uiv(GLint location, GLsizei count, const GLuint *v)
d6046 1
a6046 1
   n = alloc_instruction(ctx, OPCODE_UNIFORM_1UIV, 2 + POINTER_DWORDS);
d6048 1
a6048 3
      n[1].i = location;
      n[2].i = count;
      save_pointer(&n[3], memdup(v, count * 1 * sizeof(*v)));
d6051 2
a6052 1
      /*CALL_Uniform1uiv(ctx->Exec, (location, count, v));*/
d6056 2
d6059 1
a6059 1
save_Uniform2uiv(GLint location, GLsizei count, const GLuint *v)
d6064 1
a6064 1
   n = alloc_instruction(ctx, OPCODE_UNIFORM_2UIV, 2 + POINTER_DWORDS);
d6066 1
a6066 3
      n[1].i = location;
      n[2].i = count;
      save_pointer(&n[3], memdup(v, count * 2 * sizeof(*v)));
d6069 1
a6069 1
      /*CALL_Uniform2uiv(ctx->Exec, (location, count, v));*/
d6073 2
d6076 1
a6076 1
save_Uniform3uiv(GLint location, GLsizei count, const GLuint *v)
a6078 1
   Node *n;
d6080 1
a6080 6
   n = alloc_instruction(ctx, OPCODE_UNIFORM_3UIV, 2 + POINTER_DWORDS);
   if (n) {
      n[1].i = location;
      n[2].i = count;
      save_pointer(&n[3], memdup(v, count * 3 * sizeof(*v)));
   }
d6082 1
a6082 1
      /*CALL_Uniform3uiv(ctx->Exec, (location, count, v));*/
d6087 1
a6087 1
save_Uniform4uiv(GLint location, GLsizei count, const GLuint *v)
d6092 1
a6092 1
   n = alloc_instruction(ctx, OPCODE_UNIFORM_4UIV, 2 + POINTER_DWORDS);
d6094 2
a6095 3
      n[1].i = location;
      n[2].i = count;
      save_pointer(&n[3], memdup(v, count * 4 * sizeof(*v)));
d6098 1
a6098 1
      /*CALL_Uniform4uiv(ctx->Exec, (location, count, v));*/
a6101 2


d6103 1
a6103 2
save_UniformMatrix2fvARB(GLint location, GLsizei count, GLboolean transpose,
                         const GLfloat *m)
a6105 1
   Node *n;
d6107 1
a6107 7
   n = alloc_instruction(ctx, OPCODE_UNIFORM_MATRIX22, 3 + POINTER_DWORDS);
   if (n) {
      n[1].i = location;
      n[2].i = count;
      n[3].b = transpose;
      save_pointer(&n[4], memdup(m, count * 2 * 2 * sizeof(GLfloat)));
   }
d6109 1
a6109 1
      CALL_UniformMatrix2fv(ctx->Exec, (location, count, transpose, m));
d6114 1
a6114 2
save_UniformMatrix3fvARB(GLint location, GLsizei count, GLboolean transpose,
                         const GLfloat *m)
a6116 1
   Node *n;
d6118 1
a6118 7
   n = alloc_instruction(ctx, OPCODE_UNIFORM_MATRIX33, 3 + POINTER_DWORDS);
   if (n) {
      n[1].i = location;
      n[2].i = count;
      n[3].b = transpose;
      save_pointer(&n[4], memdup(m, count * 3 * 3 * sizeof(GLfloat)));
   }
d6120 1
a6120 1
      CALL_UniformMatrix3fv(ctx->Exec, (location, count, transpose, m));
d6125 1
a6125 2
save_UniformMatrix4fvARB(GLint location, GLsizei count, GLboolean transpose,
                         const GLfloat *m)
d6130 1
a6130 1
   n = alloc_instruction(ctx, OPCODE_UNIFORM_MATRIX44, 3 + POINTER_DWORDS);
d6132 2
a6133 4
      n[1].i = location;
      n[2].i = count;
      n[3].b = transpose;
      save_pointer(&n[4], memdup(m, count * 4 * 4 * sizeof(GLfloat)));
d6136 1
a6136 1
      CALL_UniformMatrix4fv(ctx->Exec, (location, count, transpose, m));
a6139 1

d6141 1
a6141 2
save_UniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose,
                        const GLfloat *m)
d6146 1
a6146 1
   n = alloc_instruction(ctx, OPCODE_UNIFORM_MATRIX23, 3 + POINTER_DWORDS);
d6148 3
a6150 4
      n[1].i = location;
      n[2].i = count;
      n[3].b = transpose;
      save_pointer(&n[4], memdup(m, count * 2 * 3 * sizeof(GLfloat)));
d6153 1
a6153 1
      CALL_UniformMatrix2x3fv(ctx->Exec, (location, count, transpose, m));
d6158 2
a6159 2
save_UniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose,
                        const GLfloat *m)
d6164 1
a6164 1
   n = alloc_instruction(ctx, OPCODE_UNIFORM_MATRIX32, 3 + POINTER_DWORDS);
d6166 3
a6168 4
      n[1].i = location;
      n[2].i = count;
      n[3].b = transpose;
      save_pointer(&n[4], memdup(m, count * 3 * 2 * sizeof(GLfloat)));
d6171 1
a6171 1
      CALL_UniformMatrix3x2fv(ctx->Exec, (location, count, transpose, m));
a6174 1

d6176 2
a6177 2
save_UniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose,
                        const GLfloat *m)
d6182 1
a6182 1
   n = alloc_instruction(ctx, OPCODE_UNIFORM_MATRIX24, 3 + POINTER_DWORDS);
d6184 4
a6187 4
      n[1].i = location;
      n[2].i = count;
      n[3].b = transpose;
      save_pointer(&n[4], memdup(m, count * 2 * 4 * sizeof(GLfloat)));
d6190 2
a6191 1
      CALL_UniformMatrix2x4fv(ctx->Exec, (location, count, transpose, m));
d6195 1
d6197 1
a6197 2
save_UniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose,
                        const GLfloat *m)
d6202 1
a6202 1
   n = alloc_instruction(ctx, OPCODE_UNIFORM_MATRIX42, 3 + POINTER_DWORDS);
d6204 1
a6204 4
      n[1].i = location;
      n[2].i = count;
      n[3].b = transpose;
      save_pointer(&n[4], memdup(m, count * 4 * 2 * sizeof(GLfloat)));
d6207 1
a6207 1
      CALL_UniformMatrix4x2fv(ctx->Exec, (location, count, transpose, m));
d6213 1
a6213 2
save_UniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose,
                        const GLfloat *m)
d6218 1
a6218 1
   n = alloc_instruction(ctx, OPCODE_UNIFORM_MATRIX34, 3 + POINTER_DWORDS);
d6221 1
a6221 3
      n[2].i = count;
      n[3].b = transpose;
      save_pointer(&n[4], memdup(m, count * 3 * 4 * sizeof(GLfloat)));
d6224 1
a6224 1
      CALL_UniformMatrix3x4fv(ctx->Exec, (location, count, transpose, m));
d6228 1
d6230 1
a6230 2
save_UniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose,
                        const GLfloat *m)
d6235 1
a6235 1
   n = alloc_instruction(ctx, OPCODE_UNIFORM_MATRIX43, 3 + POINTER_DWORDS);
d6238 2
a6239 3
      n[2].i = count;
      n[3].b = transpose;
      save_pointer(&n[4], memdup(m, count * 4 * 3 * sizeof(GLfloat)));
d6242 1
a6242 1
      CALL_UniformMatrix4x3fv(ctx->Exec, (location, count, transpose, m));
d6246 1
d6248 1
a6248 1
save_UseProgramStages(GLuint pipeline, GLbitfield stages, GLuint program)
d6253 1
a6253 1
   n = alloc_instruction(ctx, OPCODE_USE_PROGRAM_STAGES, 3);
d6255 4
a6258 3
      n[1].ui = pipeline;
      n[2].ui = stages;
      n[3].ui = program;
d6261 1
a6261 1
      CALL_UseProgramStages(ctx->Exec, (pipeline, stages, program));
d6265 1
d6267 1
a6267 1
save_ProgramUniform1f(GLuint program, GLint location, GLfloat x)
d6272 1
a6272 1
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_1F, 3);
d6274 5
a6278 3
      n[1].ui = program;
      n[2].i = location;
      n[3].f = x;
d6281 1
a6281 1
      CALL_ProgramUniform1f(ctx->Exec, (program, location, x));
d6285 4
a6288 2
static void GLAPIENTRY
save_ProgramUniform2f(GLuint program, GLint location, GLfloat x, GLfloat y)
d6290 4
a6293 13
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_2F, 4);
   if (n) {
      n[1].ui = program;
      n[2].i = location;
      n[3].f = x;
      n[4].f = y;
   }
   if (ctx->ExecuteFlag) {
      CALL_ProgramUniform2f(ctx->Exec, (program, location, x, y));
   }
d6296 1
d6298 1
a6298 2
save_ProgramUniform3f(GLuint program, GLint location,
                      GLfloat x, GLfloat y, GLfloat z)
d6303 1
a6303 1
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_3F, 5);
d6305 3
a6307 5
      n[1].ui = program;
      n[2].i = location;
      n[3].f = x;
      n[4].f = y;
      n[5].f = z;
d6310 1
a6310 1
      CALL_ProgramUniform3f(ctx->Exec, (program, location, x, y, z));
d6315 1
a6315 2
save_ProgramUniform4f(GLuint program, GLint location,
                      GLfloat x, GLfloat y, GLfloat z, GLfloat w)
d6320 1
a6320 1
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_4F, 6);
d6322 3
a6324 6
      n[1].ui = program;
      n[2].i = location;
      n[3].f = x;
      n[4].f = y;
      n[5].f = z;
      n[6].f = w;
d6327 1
a6327 1
      CALL_ProgramUniform4f(ctx->Exec, (program, location, x, y, z, w));
d6332 1
a6332 2
save_ProgramUniform1fv(GLuint program, GLint location, GLsizei count,
                       const GLfloat *v)
d6337 1
a6337 1
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_1FV, 3 + POINTER_DWORDS);
d6339 3
a6341 4
      n[1].ui = program;
      n[2].i = location;
      n[3].i = count;
      save_pointer(&n[4], memdup(v, count * 1 * sizeof(GLfloat)));
d6344 1
a6344 1
      CALL_ProgramUniform1fv(ctx->Exec, (program, location, count, v));
d6349 1
a6349 2
save_ProgramUniform2fv(GLuint program, GLint location, GLsizei count,
                       const GLfloat *v)
d6354 1
a6354 1
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_2FV, 3 + POINTER_DWORDS);
d6356 3
a6358 4
      n[1].ui = program;
      n[2].i = location;
      n[3].i = count;
      save_pointer(&n[4], memdup(v, count * 2 * sizeof(GLfloat)));
d6361 1
a6361 1
      CALL_ProgramUniform2fv(ctx->Exec, (program, location, count, v));
d6365 1
d6367 1
a6367 2
save_ProgramUniform3fv(GLuint program, GLint location, GLsizei count,
                       const GLfloat *v)
d6372 1
a6372 1
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_3FV, 3 + POINTER_DWORDS);
d6374 2
a6375 4
      n[1].ui = program;
      n[2].i = location;
      n[3].i = count;
      save_pointer(&n[4], memdup(v, count * 3 * sizeof(GLfloat)));
d6378 1
a6378 1
      CALL_ProgramUniform3fv(ctx->Exec, (program, location, count, v));
d6383 1
a6383 2
save_ProgramUniform4fv(GLuint program, GLint location, GLsizei count,
                       const GLfloat *v)
d6388 1
a6388 1
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_4FV, 3 + POINTER_DWORDS);
d6390 3
a6392 4
      n[1].ui = program;
      n[2].i = location;
      n[3].i = count;
      save_pointer(&n[4], memdup(v, count * 4 * sizeof(GLfloat)));
d6395 1
a6395 1
      CALL_ProgramUniform4fv(ctx->Exec, (program, location, count, v));
d6400 1
a6400 1
save_ProgramUniform1i(GLuint program, GLint location, GLint x)
d6405 1
a6405 1
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_1I, 3);
d6407 4
a6410 3
      n[1].ui = program;
      n[2].i = location;
      n[3].i = x;
d6413 1
a6413 1
      CALL_ProgramUniform1i(ctx->Exec, (program, location, x));
d6418 1
a6418 1
save_ProgramUniform2i(GLuint program, GLint location, GLint x, GLint y)
d6423 1
a6423 1
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_2I, 4);
d6425 5
a6429 4
      n[1].ui = program;
      n[2].i = location;
      n[3].i = x;
      n[4].i = y;
d6432 1
a6432 1
      CALL_ProgramUniform2i(ctx->Exec, (program, location, x, y));
d6436 2
d6439 1
a6439 2
save_ProgramUniform3i(GLuint program, GLint location,
                      GLint x, GLint y, GLint z)
d6444 1
a6444 1
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_3I, 5);
d6446 3
a6448 5
      n[1].ui = program;
      n[2].i = location;
      n[3].i = x;
      n[4].i = y;
      n[5].i = z;
d6451 1
a6451 1
      CALL_ProgramUniform3i(ctx->Exec, (program, location, x, y, z));
d6456 1
a6456 2
save_ProgramUniform4i(GLuint program, GLint location,
                      GLint x, GLint y, GLint z, GLint w)
d6461 1
a6461 1
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_4I, 6);
d6463 3
a6465 6
      n[1].ui = program;
      n[2].i = location;
      n[3].i = x;
      n[4].i = y;
      n[5].i = z;
      n[6].i = w;
d6468 1
a6468 1
      CALL_ProgramUniform4i(ctx->Exec, (program, location, x, y, z, w));
d6473 1
a6473 2
save_ProgramUniform1iv(GLuint program, GLint location, GLsizei count,
                       const GLint *v)
d6478 1
a6478 1
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_1IV, 3 + POINTER_DWORDS);
d6480 3
a6482 4
      n[1].ui = program;
      n[2].i = location;
      n[3].i = count;
      save_pointer(&n[4], memdup(v, count * 1 * sizeof(GLint)));
d6485 1
a6485 1
      CALL_ProgramUniform1iv(ctx->Exec, (program, location, count, v));
d6490 1
a6490 2
save_ProgramUniform2iv(GLuint program, GLint location, GLsizei count,
                       const GLint *v)
d6495 1
a6495 1
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_2IV, 3 + POINTER_DWORDS);
d6497 3
a6499 4
      n[1].ui = program;
      n[2].i = location;
      n[3].i = count;
      save_pointer(&n[4], memdup(v, count * 2 * sizeof(GLint)));
d6502 1
a6502 1
      CALL_ProgramUniform2iv(ctx->Exec, (program, location, count, v));
d6506 2
d6509 1
a6509 2
save_ProgramUniform3iv(GLuint program, GLint location, GLsizei count,
                       const GLint *v)
d6514 1
a6514 1
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_3IV, 3 + POINTER_DWORDS);
d6516 2
a6517 4
      n[1].ui = program;
      n[2].i = location;
      n[3].i = count;
      save_pointer(&n[4], memdup(v, count * 3 * sizeof(GLint)));
d6520 1
a6520 1
      CALL_ProgramUniform3iv(ctx->Exec, (program, location, count, v));
d6525 1
a6525 2
save_ProgramUniform4iv(GLuint program, GLint location, GLsizei count,
                       const GLint *v)
d6530 1
a6530 1
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_4IV, 3 + POINTER_DWORDS);
d6532 3
a6534 4
      n[1].ui = program;
      n[2].i = location;
      n[3].i = count;
      save_pointer(&n[4], memdup(v, count * 4 * sizeof(GLint)));
d6537 1
a6537 1
      CALL_ProgramUniform4iv(ctx->Exec, (program, location, count, v));
d6542 1
a6542 1
save_ProgramUniform1ui(GLuint program, GLint location, GLuint x)
d6547 1
a6547 1
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_1UI, 3);
d6549 4
a6552 3
      n[1].ui = program;
      n[2].i = location;
      n[3].ui = x;
d6555 1
a6555 1
      CALL_ProgramUniform1ui(ctx->Exec, (program, location, x));
d6560 1
a6560 1
save_ProgramUniform2ui(GLuint program, GLint location, GLuint x, GLuint y)
d6565 1
a6565 1
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_2UI, 4);
d6567 5
a6571 4
      n[1].ui = program;
      n[2].i = location;
      n[3].ui = x;
      n[4].ui = y;
d6574 1
a6574 1
      CALL_ProgramUniform2ui(ctx->Exec, (program, location, x, y));
d6578 2
d6581 1
a6581 2
save_ProgramUniform3ui(GLuint program, GLint location,
                       GLuint x, GLuint y, GLuint z)
d6586 1
a6586 1
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_3UI, 5);
d6588 3
a6590 5
      n[1].ui = program;
      n[2].i = location;
      n[3].ui = x;
      n[4].ui = y;
      n[5].ui = z;
d6593 1
a6593 1
      CALL_ProgramUniform3ui(ctx->Exec, (program, location, x, y, z));
d6598 1
a6598 2
save_ProgramUniform4ui(GLuint program, GLint location,
                       GLuint x, GLuint y, GLuint z, GLuint w)
d6603 1
a6603 1
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_4UI, 6);
d6605 3
a6607 6
      n[1].ui = program;
      n[2].i = location;
      n[3].ui = x;
      n[4].ui = y;
      n[5].ui = z;
      n[6].ui = w;
d6610 1
a6610 1
      CALL_ProgramUniform4ui(ctx->Exec, (program, location, x, y, z, w));
d6615 1
a6615 2
save_ProgramUniform1uiv(GLuint program, GLint location, GLsizei count,
                        const GLuint *v)
d6620 1
a6620 1
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_1UIV, 3 + POINTER_DWORDS);
d6622 3
a6624 4
      n[1].ui = program;
      n[2].i = location;
      n[3].i = count;
      save_pointer(&n[4], memdup(v, count * 1 * sizeof(GLuint)));
d6627 1
a6627 1
      CALL_ProgramUniform1uiv(ctx->Exec, (program, location, count, v));
d6632 1
a6632 2
save_ProgramUniform2uiv(GLuint program, GLint location, GLsizei count,
                        const GLuint *v)
d6637 1
a6637 1
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_2UIV, 3 + POINTER_DWORDS);
d6639 3
a6641 4
      n[1].ui = program;
      n[2].i = location;
      n[3].i = count;
      save_pointer(&n[4], memdup(v, count * 2 * sizeof(GLuint)));
d6644 1
a6644 1
      CALL_ProgramUniform2uiv(ctx->Exec, (program, location, count, v));
d6648 2
d6651 2
a6652 2
save_ProgramUniform3uiv(GLuint program, GLint location, GLsizei count,
                        const GLuint *v)
d6657 1
a6657 1
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_3UIV, 3 + POINTER_DWORDS);
d6659 4
a6662 4
      n[1].ui = program;
      n[2].i = location;
      n[3].i = count;
      save_pointer(&n[4], memdup(v, count * 3 * sizeof(GLuint)));
d6665 1
a6665 1
      CALL_ProgramUniform3uiv(ctx->Exec, (program, location, count, v));
d6670 2
a6671 2
save_ProgramUniform4uiv(GLuint program, GLint location, GLsizei count,
                        const GLuint *v)
d6676 1
a6676 1
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_4UIV, 3 + POINTER_DWORDS);
d6678 4
a6681 4
      n[1].ui = program;
      n[2].i = location;
      n[3].i = count;
      save_pointer(&n[4], memdup(v, count * 4 * sizeof(GLuint)));
d6684 1
a6684 1
      CALL_ProgramUniform4uiv(ctx->Exec, (program, location, count, v));
d6689 2
a6690 2
save_ProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count,
                             GLboolean transpose, const GLfloat *v)
d6695 1
a6695 2
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_MATRIX22F,
                         4 + POINTER_DWORDS);
d6697 4
a6700 5
      n[1].ui = program;
      n[2].i = location;
      n[3].i = count;
      n[4].b = transpose;
      save_pointer(&n[5], memdup(v, count * 2 * 2 * sizeof(GLfloat)));
d6703 1
a6703 2
      CALL_ProgramUniformMatrix2fv(ctx->Exec,
                                   (program, location, count, transpose, v));
d6707 1
d6709 2
a6710 2
save_ProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count,
                               GLboolean transpose, const GLfloat *v)
d6715 1
a6715 2
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_MATRIX23F,
                         4 + POINTER_DWORDS);
d6717 4
a6720 5
      n[1].ui = program;
      n[2].i = location;
      n[3].i = count;
      n[4].b = transpose;
      save_pointer(&n[5], memdup(v, count * 2 * 3 * sizeof(GLfloat)));
d6723 1
a6723 2
      CALL_ProgramUniformMatrix2x3fv(ctx->Exec,
                                     (program, location, count, transpose, v));
d6728 2
a6729 2
save_ProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count,
                               GLboolean transpose, const GLfloat *v)
d6734 1
a6734 2
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_MATRIX24F,
                         4 + POINTER_DWORDS);
d6736 4
a6739 5
      n[1].ui = program;
      n[2].i = location;
      n[3].i = count;
      n[4].b = transpose;
      save_pointer(&n[5], memdup(v, count * 2 * 4 * sizeof(GLfloat)));
d6742 1
a6742 2
      CALL_ProgramUniformMatrix2x4fv(ctx->Exec,
                                     (program, location, count, transpose, v));
d6746 1
d6748 2
a6749 2
save_ProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count,
                               GLboolean transpose, const GLfloat *v)
d6754 1
a6754 2
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_MATRIX32F,
                         4 + POINTER_DWORDS);
d6756 4
a6759 5
      n[1].ui = program;
      n[2].i = location;
      n[3].i = count;
      n[4].b = transpose;
      save_pointer(&n[5], memdup(v, count * 3 * 2 * sizeof(GLfloat)));
d6762 1
a6762 2
      CALL_ProgramUniformMatrix3x2fv(ctx->Exec,
                                     (program, location, count, transpose, v));
d6767 2
a6768 2
save_ProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count,
                             GLboolean transpose, const GLfloat *v)
d6773 1
a6773 2
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_MATRIX33F,
                         4 + POINTER_DWORDS);
d6775 4
a6778 5
      n[1].ui = program;
      n[2].i = location;
      n[3].i = count;
      n[4].b = transpose;
      save_pointer(&n[5], memdup(v, count * 3 * 3 * sizeof(GLfloat)));
d6781 1
a6781 2
      CALL_ProgramUniformMatrix3fv(ctx->Exec,
                                   (program, location, count, transpose, v));
d6785 1
d6787 2
a6788 2
save_ProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count,
                               GLboolean transpose, const GLfloat *v)
d6793 1
a6793 2
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_MATRIX34F,
                         4 + POINTER_DWORDS);
d6795 4
a6798 5
      n[1].ui = program;
      n[2].i = location;
      n[3].i = count;
      n[4].b = transpose;
      save_pointer(&n[5], memdup(v, count * 3 * 4 * sizeof(GLfloat)));
d6801 1
a6801 2
      CALL_ProgramUniformMatrix3x4fv(ctx->Exec,
                                     (program, location, count, transpose, v));
d6806 2
a6807 2
save_ProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count,
                               GLboolean transpose, const GLfloat *v)
d6812 1
a6812 2
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_MATRIX42F,
                         4 + POINTER_DWORDS);
d6814 4
a6817 5
      n[1].ui = program;
      n[2].i = location;
      n[3].i = count;
      n[4].b = transpose;
      save_pointer(&n[5], memdup(v, count * 4 * 2 * sizeof(GLfloat)));
d6820 1
a6820 2
      CALL_ProgramUniformMatrix4x2fv(ctx->Exec,
                                     (program, location, count, transpose, v));
d6825 1
a6825 2
save_ProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count,
                               GLboolean transpose, const GLfloat *v)
d6830 1
a6830 2
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_MATRIX43F,
                         4 + POINTER_DWORDS);
d6832 2
a6833 5
      n[1].ui = program;
      n[2].i = location;
      n[3].i = count;
      n[4].b = transpose;
      save_pointer(&n[5], memdup(v, count * 4 * 3 * sizeof(GLfloat)));
d6836 1
a6836 2
      CALL_ProgramUniformMatrix4x3fv(ctx->Exec,
                                     (program, location, count, transpose, v));
d6841 1
a6841 2
save_ProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count,
                             GLboolean transpose, const GLfloat *v)
d6846 1
a6846 2
   n = alloc_instruction(ctx, OPCODE_PROGRAM_UNIFORM_MATRIX44F,
                         4 + POINTER_DWORDS);
d6848 2
a6849 5
      n[1].ui = program;
      n[2].i = location;
      n[3].i = count;
      n[4].b = transpose;
      save_pointer(&n[5], memdup(v, count * 4 * 4 * sizeof(GLfloat)));
d6852 1
a6852 2
      CALL_ProgramUniformMatrix4fv(ctx->Exec,
                                   (program, location, count, transpose, v));
d6857 1
a6857 1
save_ClampColorARB(GLenum target, GLenum clamp)
d6862 1
a6862 1
   n = alloc_instruction(ctx, OPCODE_CLAMP_COLOR, 2);
d6864 1
a6864 2
      n[1].e = target;
      n[2].e = clamp;
d6867 1
a6867 1
      CALL_ClampColor(ctx->Exec, (target, clamp));
d7187 4
a7190 4
      n[1].bf = flags;
      n[2].ui = p.uint32[0];
      n[3].ui = p.uint32[1];
      save_pointer(&n[4], sync);
d7254 1
a7254 1
   n = alloc_instruction(ctx, OPCODE_ERROR, 1 + POINTER_DWORDS);
d7257 1
a7257 5
      save_pointer(&n[2], (void *) s);
      /* note: the data/string here doesn't have to be freed in
       * _mesa_delete_list() since the string is never dynamically
       * allocated.
       */
d7281 1
a7281 1
   if (list > 0 && _mesa_lookup_list(ctx, list)) {
d7317 1
a7317 1
   dlist = _mesa_lookup_list(ctx, list);
d7338 1
a7338 1
            _mesa_error(ctx, n[1].e, "%s", (const char *) get_pointer(&n[2]));
d7355 1
a7355 1
                                       get_pointer(&n[7])));
d7480 96
d7630 1
a7630 1
                                           get_pointer(&n[5])));
d7667 3
d7735 1
a7735 1
                                      (GLfloat *) get_pointer(&n[6])));
d7751 1
a7751 1
                                      (GLfloat *) get_pointer(&n[10])));
d7764 3
d7789 1
a7789 1
                            (n[1].e, n[2].i, get_pointer(&n[3])));
d7816 1
a7816 1
               CALL_PolygonStipple(ctx->Exec, (get_pointer(&n[1])));
d7850 6
d7932 1
a7932 1
                                           get_pointer(&n[8])));
d7948 1
a7948 1
                                           get_pointer(&n[9])));
d7965 1
a7965 1
                                           get_pointer(&n[10])));
d7975 1
a7975 1
                                              n[6].e, get_pointer(&n[7])));
d7986 1
a7986 1
                                              get_pointer(&n[9])));
d7997 1
a7997 1
                                              get_pointer(&n[11])));
d8016 2
a8017 2
                                                  n[4].i, n[5].i, n[6].i,
                                                  get_pointer(&n[7])));
d8021 2
a8022 2
                                                  n[4].i, n[5].i, n[6].i,
                                                  n[7].i, get_pointer(&n[8])));
d8026 3
a8028 3
                                                  n[4].i, n[5].i, n[6].i,
                                                  n[7].i, n[8].i,
                                                  get_pointer(&n[9])));
d8033 1
a8033 2
                                             n[5].e, n[6].i,
                                             get_pointer(&n[7])));
d8039 1
a8039 1
                                             get_pointer(&n[9])));
d8045 1
a8045 2
                                             n[9].e, n[10].i,
                                             get_pointer(&n[11])));
d8069 1
a8069 2
                                  (n[1].e, n[2].e, n[3].i,
                                   get_pointer(&n[4])));
d8108 6
d8128 1
a8128 1
	    CALL_Uniform1fv(ctx->Exec, (n[1].i, n[2].i, get_pointer(&n[3])));
d8131 1
a8131 1
	    CALL_Uniform2fv(ctx->Exec, (n[1].i, n[2].i, get_pointer(&n[3])));
d8134 1
a8134 1
	    CALL_Uniform3fv(ctx->Exec, (n[1].i, n[2].i, get_pointer(&n[3])));
d8137 1
a8137 1
	    CALL_Uniform4fv(ctx->Exec, (n[1].i, n[2].i, get_pointer(&n[3])));
d8153 1
a8153 1
	    CALL_Uniform1iv(ctx->Exec, (n[1].i, n[2].i, get_pointer(&n[3])));
d8156 1
a8156 1
	    CALL_Uniform2iv(ctx->Exec, (n[1].i, n[2].i, get_pointer(&n[3])));
d8159 1
a8159 1
	    CALL_Uniform3iv(ctx->Exec, (n[1].i, n[2].i, get_pointer(&n[3])));
d8162 1
a8162 1
	    CALL_Uniform4iv(ctx->Exec, (n[1].i, n[2].i, get_pointer(&n[3])));
d8179 1
a8179 2
	    /*CALL_Uniform1uivARB(ctx->Exec, (n[1].i, n[2].i,
                                              get_pointer(&n[3])));*/
d8182 1
a8182 2
	    /*CALL_Uniform2uivARB(ctx->Exec, (n[1].i, n[2].i,
                                              get_pointer(&n[3])));*/
d8185 1
a8185 2
	    /*CALL_Uniform3uivARB(ctx->Exec, (n[1].i, n[2].i,
                                              get_pointer(&n[3])));*/
d8188 1
a8188 2
	    /*CALL_Uniform4uivARB(ctx->Exec, (n[1].i, n[2].i,
                                              get_pointer(&n[3])));*/
d8192 1
a8192 1
                                  (n[1].i, n[2].i, n[3].b, get_pointer(&n[4])));
d8196 1
a8196 1
                                  (n[1].i, n[2].i, n[3].b, get_pointer(&n[4])));
d8200 1
a8200 1
                                  (n[1].i, n[2].i, n[3].b, get_pointer(&n[4])));
d8204 1
a8204 1
                                    (n[1].i, n[2].i, n[3].b, get_pointer(&n[4])));
d8208 1
a8208 1
                                    (n[1].i, n[2].i, n[3].b, get_pointer(&n[4])));
d8212 1
a8212 1
                                    (n[1].i, n[2].i, n[3].b, get_pointer(&n[4])));
d8216 1
a8216 1
                                    (n[1].i, n[2].i, n[3].b, get_pointer(&n[4])));
d8220 1
a8220 1
                                    (n[1].i, n[2].i, n[3].b, get_pointer(&n[4])));
d8224 1
a8224 5
                                    (n[1].i, n[2].i, n[3].b, get_pointer(&n[4])));
	    break;

	 case OPCODE_USE_PROGRAM_STAGES:
	    CALL_UseProgramStages(ctx->Exec, (n[1].ui, n[2].ui, n[3].ui));
a8225 137
         case OPCODE_PROGRAM_UNIFORM_1F:
            CALL_ProgramUniform1f(ctx->Exec, (n[1].ui, n[2].i, n[3].f));
            break;
         case OPCODE_PROGRAM_UNIFORM_2F:
            CALL_ProgramUniform2f(ctx->Exec, (n[1].ui, n[2].i, n[3].f, n[4].f));
            break;
         case OPCODE_PROGRAM_UNIFORM_3F:
            CALL_ProgramUniform3f(ctx->Exec, (n[1].ui, n[2].i,
                                              n[3].f, n[4].f, n[5].f));
            break;
         case OPCODE_PROGRAM_UNIFORM_4F:
            CALL_ProgramUniform4f(ctx->Exec, (n[1].ui, n[2].i,
                                              n[3].f, n[4].f, n[5].f, n[6].f));
            break;
         case OPCODE_PROGRAM_UNIFORM_1FV:
            CALL_ProgramUniform1fv(ctx->Exec, (n[1].ui, n[2].i, n[3].i,
                                               get_pointer(&n[4])));
            break;
         case OPCODE_PROGRAM_UNIFORM_2FV:
            CALL_ProgramUniform2fv(ctx->Exec, (n[1].ui, n[2].i, n[3].i,
                                               get_pointer(&n[4])));
            break;
         case OPCODE_PROGRAM_UNIFORM_3FV:
            CALL_ProgramUniform3fv(ctx->Exec, (n[1].ui, n[2].i, n[3].i,
                                               get_pointer(&n[4])));
            break;
         case OPCODE_PROGRAM_UNIFORM_4FV:
            CALL_ProgramUniform4fv(ctx->Exec, (n[1].ui, n[2].i, n[3].i,
                                               get_pointer(&n[4])));
            break;
         case OPCODE_PROGRAM_UNIFORM_1I:
            CALL_ProgramUniform1i(ctx->Exec, (n[1].ui, n[2].i, n[3].i));
            break;
         case OPCODE_PROGRAM_UNIFORM_2I:
            CALL_ProgramUniform2i(ctx->Exec, (n[1].ui, n[2].i, n[3].i, n[4].i));
            break;
         case OPCODE_PROGRAM_UNIFORM_3I:
            CALL_ProgramUniform3i(ctx->Exec, (n[1].ui, n[2].i,
                                              n[3].i, n[4].i, n[5].i));
            break;
         case OPCODE_PROGRAM_UNIFORM_4I:
            CALL_ProgramUniform4i(ctx->Exec, (n[1].ui, n[2].i,
                                              n[3].i, n[4].i, n[5].i, n[6].i));
            break;
         case OPCODE_PROGRAM_UNIFORM_1IV:
            CALL_ProgramUniform1iv(ctx->Exec, (n[1].ui, n[2].i, n[3].i,
                                               get_pointer(&n[4])));
            break;
         case OPCODE_PROGRAM_UNIFORM_2IV:
            CALL_ProgramUniform2iv(ctx->Exec, (n[1].ui, n[2].i, n[3].i,
                                               get_pointer(&n[4])));
            break;
         case OPCODE_PROGRAM_UNIFORM_3IV:
            CALL_ProgramUniform3iv(ctx->Exec, (n[1].ui, n[2].i, n[3].i,
                                               get_pointer(&n[4])));
            break;
         case OPCODE_PROGRAM_UNIFORM_4IV:
            CALL_ProgramUniform4iv(ctx->Exec, (n[1].ui, n[2].i, n[3].i,
                                               get_pointer(&n[4])));
            break;
         case OPCODE_PROGRAM_UNIFORM_1UI:
            CALL_ProgramUniform1ui(ctx->Exec, (n[1].ui, n[2].i, n[3].ui));
            break;
         case OPCODE_PROGRAM_UNIFORM_2UI:
            CALL_ProgramUniform2ui(ctx->Exec, (n[1].ui, n[2].i,
                                               n[3].ui, n[4].ui));
            break;
         case OPCODE_PROGRAM_UNIFORM_3UI:
            CALL_ProgramUniform3ui(ctx->Exec, (n[1].ui, n[2].i,
                                               n[3].ui, n[4].ui, n[5].ui));
            break;
         case OPCODE_PROGRAM_UNIFORM_4UI:
            CALL_ProgramUniform4ui(ctx->Exec, (n[1].ui, n[2].i,
                                               n[3].ui,
                                               n[4].ui, n[5].ui, n[6].ui));
            break;
         case OPCODE_PROGRAM_UNIFORM_1UIV:
            CALL_ProgramUniform1uiv(ctx->Exec, (n[1].ui, n[2].i, n[3].i,
                                                get_pointer(&n[4])));
            break;
         case OPCODE_PROGRAM_UNIFORM_2UIV:
            CALL_ProgramUniform2uiv(ctx->Exec, (n[1].ui, n[2].i, n[3].i,
                                                get_pointer(&n[4])));
            break;
         case OPCODE_PROGRAM_UNIFORM_3UIV:
            CALL_ProgramUniform3uiv(ctx->Exec, (n[1].ui, n[2].i, n[3].i,
                                                get_pointer(&n[4])));
            break;
         case OPCODE_PROGRAM_UNIFORM_4UIV:
            CALL_ProgramUniform4uiv(ctx->Exec, (n[1].ui, n[2].i, n[3].i,
                                                get_pointer(&n[4])));
            break;
         case OPCODE_PROGRAM_UNIFORM_MATRIX22F:
            CALL_ProgramUniformMatrix2fv(ctx->Exec,
                                         (n[1].ui, n[2].i, n[3].i, n[4].b,
                                          get_pointer(&n[5])));
            break;
         case OPCODE_PROGRAM_UNIFORM_MATRIX23F:
            CALL_ProgramUniformMatrix2x3fv(ctx->Exec,
                                           (n[1].ui, n[2].i, n[3].i, n[4].b,
                                            get_pointer(&n[5])));
            break;
         case OPCODE_PROGRAM_UNIFORM_MATRIX24F:
            CALL_ProgramUniformMatrix2x4fv(ctx->Exec,
                                           (n[1].ui, n[2].i, n[3].i, n[4].b,
                                            get_pointer(&n[5])));
            break;
         case OPCODE_PROGRAM_UNIFORM_MATRIX32F:
            CALL_ProgramUniformMatrix3x2fv(ctx->Exec,
                                           (n[1].ui, n[2].i, n[3].i, n[4].b,
                                            get_pointer(&n[5])));
            break;
         case OPCODE_PROGRAM_UNIFORM_MATRIX33F:
            CALL_ProgramUniformMatrix3fv(ctx->Exec,
                                         (n[1].ui, n[2].i, n[3].i, n[4].b,
                                          get_pointer(&n[5])));
            break;
         case OPCODE_PROGRAM_UNIFORM_MATRIX34F:
            CALL_ProgramUniformMatrix3x4fv(ctx->Exec,
                                           (n[1].ui, n[2].i, n[3].i, n[4].b,
                                            get_pointer(&n[5])));
            break;
         case OPCODE_PROGRAM_UNIFORM_MATRIX42F:
            CALL_ProgramUniformMatrix4x2fv(ctx->Exec,
                                           (n[1].ui, n[2].i, n[3].i, n[4].b,
                                            get_pointer(&n[5])));
            break;
         case OPCODE_PROGRAM_UNIFORM_MATRIX43F:
            CALL_ProgramUniformMatrix4x3fv(ctx->Exec,
                                           (n[1].ui, n[2].i, n[3].i, n[4].b,
                                            get_pointer(&n[5])));
            break;
         case OPCODE_PROGRAM_UNIFORM_MATRIX44F:
            CALL_ProgramUniformMatrix4fv(ctx->Exec,
                                         (n[1].ui, n[2].i, n[3].i, n[4].b,
                                          get_pointer(&n[5])));
            break;
d8478 3
a8480 4
               p.uint32[0] = n[2].ui;
               p.uint32[1] = n[3].ui;
               CALL_WaitSync(ctx->Exec,
                             (get_pointer(&n[4]), n[1].bf, p.uint64));
d8497 1
a8497 1
            n = (Node *) get_pointer(&n[1]);
d8588 1
a8588 1
   mtx_lock(&ctx->Shared->Mutex);
d8600 1
a8600 1
   mtx_unlock(&ctx->Shared->Mutex);
a8685 2
   trim_list(ctx);

a8698 2
   ctx->ListState.CurrentBlock = NULL;
   ctx->ListState.CurrentPos = 0;
d9000 16
d9032 6
d9192 4
a9284 36

   /* OpenGL 4.2 / GL_ARB_separate_shader_objects */
   SET_UseProgramStages(table, save_UseProgramStages);
   SET_ProgramUniform1f(table, save_ProgramUniform1f);
   SET_ProgramUniform2f(table, save_ProgramUniform2f);
   SET_ProgramUniform3f(table, save_ProgramUniform3f);
   SET_ProgramUniform4f(table, save_ProgramUniform4f);
   SET_ProgramUniform1fv(table, save_ProgramUniform1fv);
   SET_ProgramUniform2fv(table, save_ProgramUniform2fv);
   SET_ProgramUniform3fv(table, save_ProgramUniform3fv);
   SET_ProgramUniform4fv(table, save_ProgramUniform4fv);
   SET_ProgramUniform1i(table, save_ProgramUniform1i);
   SET_ProgramUniform2i(table, save_ProgramUniform2i);
   SET_ProgramUniform3i(table, save_ProgramUniform3i);
   SET_ProgramUniform4i(table, save_ProgramUniform4i);
   SET_ProgramUniform1iv(table, save_ProgramUniform1iv);
   SET_ProgramUniform2iv(table, save_ProgramUniform2iv);
   SET_ProgramUniform3iv(table, save_ProgramUniform3iv);
   SET_ProgramUniform4iv(table, save_ProgramUniform4iv);
   SET_ProgramUniform1ui(table, save_ProgramUniform1ui);
   SET_ProgramUniform2ui(table, save_ProgramUniform2ui);
   SET_ProgramUniform3ui(table, save_ProgramUniform3ui);
   SET_ProgramUniform4ui(table, save_ProgramUniform4ui);
   SET_ProgramUniform1uiv(table, save_ProgramUniform1uiv);
   SET_ProgramUniform2uiv(table, save_ProgramUniform2uiv);
   SET_ProgramUniform3uiv(table, save_ProgramUniform3uiv);
   SET_ProgramUniform4uiv(table, save_ProgramUniform4uiv);
   SET_ProgramUniformMatrix2fv(table, save_ProgramUniformMatrix2fv);
   SET_ProgramUniformMatrix3fv(table, save_ProgramUniformMatrix3fv);
   SET_ProgramUniformMatrix4fv(table, save_ProgramUniformMatrix4fv);
   SET_ProgramUniformMatrix2x3fv(table, save_ProgramUniformMatrix2x3fv);
   SET_ProgramUniformMatrix3x2fv(table, save_ProgramUniformMatrix3x2fv);
   SET_ProgramUniformMatrix2x4fv(table, save_ProgramUniformMatrix2x4fv);
   SET_ProgramUniformMatrix4x2fv(table, save_ProgramUniformMatrix4x2fv);
   SET_ProgramUniformMatrix3x4fv(table, save_ProgramUniformMatrix3x4fv);
   SET_ProgramUniformMatrix4x3fv(table, save_ProgramUniformMatrix4x3fv);
d9312 1
a9312 1
   dlist = _mesa_lookup_list(ctx, list);
d9334 1
a9334 2
                   n[3].f, n[4].f, n[5].f, n[6].f,
                   get_pointer(&n[7]));
d9343 10
d9527 2
a9528 2
            printf("Error: %s %s\n", enum_string(n[1].e),
                   (const char *) get_pointer(&n[2]));
d9532 1
a9532 1
            n = (Node *) get_pointer(&n[1]);
@


1.1.1.7
log
@Import Mesa 10.4.3
@
text
@d320 2
a402 3
   /* GL_ARB_clip_control */
   OPCODE_CLIP_CONTROL,

d4980 30
a7242 16
save_ClipControl(GLenum origin, GLenum depth)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;
   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
   n = alloc_instruction(ctx, OPCODE_CLIP_CONTROL, 2);
   if (n) {
      n[1].e = origin;
      n[2].e = depth;
   }
   if (ctx->ExecuteFlag) {
      CALL_ClipControl(ctx->Exec, (origin, depth));
   }
}

static void GLAPIENTRY
a8651 4
         case OPCODE_CLIP_CONTROL:
            CALL_ClipControl(ctx->Exec, (n[1].e, n[2].e));
            break;

d8656 10
d9491 4
a9598 3

   /* GL_ARB_clip_control */
   SET_ClipControl(table, save_ClipControl);
@


1.1.1.8
log
@Import Mesa 10.2.9
@
text
@a319 2
   OPCODE_TEX_BUMP_PARAMETER_ATI,
   /* GL_ATI_fragment_shader */
d401 3
a4980 30
save_TexBumpParameterfvATI(GLenum pname, const GLfloat *param)
{
   GET_CURRENT_CONTEXT(ctx);
   Node *n;

   n = alloc_instruction(ctx, OPCODE_TEX_BUMP_PARAMETER_ATI, 5);
   if (n) {
      n[1].ui = pname;
      n[2].f = param[0];
      n[3].f = param[1];
      n[4].f = param[2];
      n[5].f = param[3];
   }
   if (ctx->ExecuteFlag) {
      CALL_TexBumpParameterfvATI(ctx->Exec, (pname, param));
   }
}

static void GLAPIENTRY
save_TexBumpParameterivATI(GLenum pname, const GLint *param)
{
   GLfloat p[4];
   p[0] = INT_TO_FLOAT(param[0]);
   p[1] = INT_TO_FLOAT(param[1]);
   p[2] = INT_TO_FLOAT(param[2]);
   p[3] = INT_TO_FLOAT(param[3]);
   save_TexBumpParameterfvATI(pname, p);
}

static void GLAPIENTRY
d7214 16
d8639 4
a8646 10
         case OPCODE_TEX_BUMP_PARAMETER_ATI:
            {
               GLfloat values[4];
               GLuint i, pname = n[1].ui;

               for (i = 0; i < 4; i++)
                  values[i] = n[1 + i].f;
               CALL_TexBumpParameterfvATI(ctx->Exec, (pname, values));
            }
            break;
a9471 4
   /* 244. GL_ATI_envmap_bumpmap */
   SET_TexBumpParameterivATI(table, save_TexBumpParameterivATI);
   SET_TexBumpParameterfvATI(table, save_TexBumpParameterfvATI);

d9576 3
@


