head	1.6;
access;
symbols
	OPENBSD_5_4:1.5.0.8
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.6
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	v7_10_3:1.1.1.2
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v7_0_1:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v6_5_2:1.1.1.1
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2013.09.05.14.06.18;	author jsg;	state dead;
branches;
next	1.5;

1.5
date	2011.10.23.13.37.42;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.30;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.41;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.20;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.49.50;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.49.50;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2011.10.23.13.29.45;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Merge Mesa 9.2.0
@
text
@/*
 * Mesa 3-D graphics library
 * Version:  6.5
 *
 * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include "glheader.h"
#include "imports.h"
#include "context.h"
#include "formats.h"
#include "mtypes.h"
#include "depthstencil.h"
#include "renderbuffer.h"


/**
 * Adaptor/wrappers for GL_DEPTH_STENCIL renderbuffers.
 *
 * The problem with a GL_DEPTH_STENCIL renderbuffer is that sometimes we
 * want to treat it as a stencil buffer, other times we want to treat it
 * as a depth/z buffer and still other times when we want to treat it as
 * a combined Z+stencil buffer!  That implies we need three different sets
 * of Get/Put functions.
 *
 * We solve this by wrapping the Z24_S8 or S8_Z24 renderbuffer with depth and
 * stencil adaptors, each with the right kind of depth/stencil Get/Put functions.
 */


static void *
nop_get_pointer(struct gl_context *ctx, struct gl_renderbuffer *rb, GLint x, GLint y)
{
   (void) ctx;
   (void) rb;
   (void) x;
   (void) y;
   return NULL;
}


/**
 * Delete a depth or stencil wrapper renderbuffer.
 */
static void
delete_wrapper(struct gl_renderbuffer *rb)
{
   ASSERT(rb->Format == MESA_FORMAT_S8 ||
          rb->Format == MESA_FORMAT_X8_Z24);
   _mesa_reference_renderbuffer(&rb->Wrapped, NULL);
   free(rb);
}


/**
 * Realloc storage for wrapper.
 */
static GLboolean
alloc_wrapper_storage(struct gl_context *ctx, struct gl_renderbuffer *rb,
                      GLenum internalFormat, GLuint width, GLuint height)
{
   /* just pass this on to the wrapped renderbuffer */
   struct gl_renderbuffer *dsrb = rb->Wrapped;
   GLboolean retVal;

   (void) internalFormat;

   ASSERT(dsrb->Format == MESA_FORMAT_Z24_S8 ||
          dsrb->Format == MESA_FORMAT_Z24_X8 ||
          dsrb->Format == MESA_FORMAT_S8_Z24 ||
          dsrb->Format == MESA_FORMAT_X8_Z24);

   retVal = dsrb->AllocStorage(ctx, dsrb, dsrb->InternalFormat, width, height);
   if (retVal) {
      rb->Width = width;
      rb->Height = height;
      rb->RowStride = dsrb->RowStride;
   }
   return retVal;
}




/*======================================================================
 * Depth wrapper around depth/stencil renderbuffer
 */

static void
get_row_z24(struct gl_context *ctx, struct gl_renderbuffer *z24rb, GLuint count,
            GLint x, GLint y, void *values)
{
   struct gl_renderbuffer *dsrb = z24rb->Wrapped;
   GLuint temp[MAX_WIDTH], i;
   GLuint *dst = (GLuint *) values;
   const GLuint *src = (const GLuint *) dsrb->GetPointer(ctx, dsrb, x, y);
   ASSERT(z24rb->DataType == GL_UNSIGNED_INT);
   ASSERT(dsrb->DataType == GL_UNSIGNED_INT_24_8_EXT);
   if (!src) {
      dsrb->GetRow(ctx, dsrb, count, x, y, temp);
      src = temp;
   }
   if (dsrb->Format == MESA_FORMAT_Z24_S8) {
      for (i = 0; i < count; i++) {
         dst[i] = src[i] >> 8;
      }
   }
   else {
      assert(dsrb->Format == MESA_FORMAT_S8_Z24);
      for (i = 0; i < count; i++) {
         dst[i] = src[i] & 0xffffff;
      }
   }
}

static void
get_values_z24(struct gl_context *ctx, struct gl_renderbuffer *z24rb, GLuint count,
               const GLint x[], const GLint y[], void *values)
{
   struct gl_renderbuffer *dsrb = z24rb->Wrapped;
   GLuint temp[MAX_WIDTH], i;
   GLuint *dst = (GLuint *) values;
   ASSERT(z24rb->DataType == GL_UNSIGNED_INT);
   ASSERT(dsrb->DataType == GL_UNSIGNED_INT_24_8_EXT);
   ASSERT(count <= MAX_WIDTH);
   /* don't bother trying direct access */
   dsrb->GetValues(ctx, dsrb, count, x, y, temp);
   if (dsrb->Format == MESA_FORMAT_Z24_S8) {
      for (i = 0; i < count; i++) {
         dst[i] = temp[i] >> 8;
      }
   }
   else {
      assert(dsrb->Format == MESA_FORMAT_S8_Z24);
      for (i = 0; i < count; i++) {
         dst[i] = temp[i] & 0xffffff;
      }
   }
}

static void
put_row_z24(struct gl_context *ctx, struct gl_renderbuffer *z24rb, GLuint count,
            GLint x, GLint y, const void *values, const GLubyte *mask)
{
   struct gl_renderbuffer *dsrb = z24rb->Wrapped;
   const GLuint *src = (const GLuint *) values;
   GLuint *dst = (GLuint *) dsrb->GetPointer(ctx, dsrb, x, y);
   ASSERT(z24rb->DataType == GL_UNSIGNED_INT);
   ASSERT(dsrb->DataType == GL_UNSIGNED_INT_24_8_EXT);
   if (dst) {
      /* direct access */
      GLuint i;
      if (dsrb->Format == MESA_FORMAT_Z24_S8) {
         for (i = 0; i < count; i++) {
            if (!mask || mask[i]) {
               dst[i] = (src[i] << 8) | (dst[i] & 0xff);
            }
         }
      }
      else {
         assert(dsrb->Format == MESA_FORMAT_S8_Z24);
         for (i = 0; i < count; i++) {
            if (!mask || mask[i]) {
               dst[i] = (src[i] & 0xffffff) | (dst[i] & 0xff000000);
            }
         }
      }
   }
   else {
      /* get, modify, put */
      GLuint temp[MAX_WIDTH], i;
      dsrb->GetRow(ctx, dsrb, count, x, y, temp);
      if (dsrb->Format == MESA_FORMAT_Z24_S8) {
         for (i = 0; i < count; i++) {
            if (!mask || mask[i]) {
               temp[i] = (src[i] << 8) | (temp[i] & 0xff);
            }
         }
      }
      else {
         assert(dsrb->Format == MESA_FORMAT_S8_Z24);
         for (i = 0; i < count; i++) {
            if (!mask || mask[i]) {
               temp[i] = (src[i] & 0xffffff) | (temp[i] & 0xff000000);
            }
         }
      }
      dsrb->PutRow(ctx, dsrb, count, x, y, temp, mask);
   }
}

static void
put_mono_row_z24(struct gl_context *ctx, struct gl_renderbuffer *z24rb, GLuint count,
                 GLint x, GLint y, const void *value, const GLubyte *mask)
{
   struct gl_renderbuffer *dsrb = z24rb->Wrapped;
   GLuint *dst = (GLuint *) dsrb->GetPointer(ctx, dsrb, x, y);
   ASSERT(z24rb->DataType == GL_UNSIGNED_INT);
   ASSERT(dsrb->DataType == GL_UNSIGNED_INT_24_8_EXT);
   if (dst) {
      /* direct access */
      GLuint i;
      if (dsrb->Format == MESA_FORMAT_Z24_S8) {
         const GLuint shiftedVal = *((GLuint *) value) << 8;
         for (i = 0; i < count; i++) {
            if (!mask || mask[i]) {
               dst[i] = shiftedVal | (dst[i] & 0xff);
            }
         }
      }
      else {
         const GLuint shiftedVal = *((GLuint *) value);
         assert(dsrb->Format == MESA_FORMAT_S8_Z24);
         for (i = 0; i < count; i++) {
            if (!mask || mask[i]) {
               dst[i] = shiftedVal | (dst[i] & 0xff000000);
            }
         }
      }
   }
   else {
      /* get, modify, put */
      GLuint temp[MAX_WIDTH], i;
      dsrb->GetRow(ctx, dsrb, count, x, y, temp);
      if (dsrb->Format == MESA_FORMAT_Z24_S8) {
         const GLuint shiftedVal = *((GLuint *) value) << 8;
         for (i = 0; i < count; i++) {
            if (!mask || mask[i]) {
               temp[i] = shiftedVal | (temp[i] & 0xff);
            }
         }
      }
      else {
         const GLuint shiftedVal = *((GLuint *) value);
         assert(dsrb->Format == MESA_FORMAT_S8_Z24);
         for (i = 0; i < count; i++) {
            if (!mask || mask[i]) {
               temp[i] = shiftedVal | (temp[i] & 0xff000000);
            }
         }
      }
      dsrb->PutRow(ctx, dsrb, count, x, y, temp, mask);
   }
}

static void
put_values_z24(struct gl_context *ctx, struct gl_renderbuffer *z24rb, GLuint count,
               const GLint x[], const GLint y[],
               const void *values, const GLubyte *mask)
{
   struct gl_renderbuffer *dsrb = z24rb->Wrapped;
   const GLuint *src = (const GLuint *) values;
   ASSERT(z24rb->DataType == GL_UNSIGNED_INT);
   ASSERT(dsrb->DataType == GL_UNSIGNED_INT_24_8_EXT);
   if (dsrb->GetPointer(ctx, dsrb, 0, 0)) {
      /* direct access */
      GLuint i;
      if (dsrb->Format == MESA_FORMAT_Z24_S8) {
         for (i = 0; i < count; i++) {
            if (!mask || mask[i]) {
               GLuint *dst = (GLuint *) dsrb->GetPointer(ctx, dsrb, x[i], y[i]);
               *dst = (src[i] << 8) | (*dst & 0xff);
            }
         }
      }
      else {
         assert(dsrb->Format == MESA_FORMAT_S8_Z24);
         for (i = 0; i < count; i++) {
            if (!mask || mask[i]) {
               GLuint *dst = (GLuint *) dsrb->GetPointer(ctx, dsrb, x[i], y[i]);
               *dst = (src[i] & 0xffffff) | (*dst & 0xff000000);
            }
         }
      }
   }
   else {
      /* get, modify, put */
      GLuint temp[MAX_WIDTH], i;
      dsrb->GetValues(ctx, dsrb, count, x, y, temp);
      if (dsrb->Format == MESA_FORMAT_Z24_S8) {
         for (i = 0; i < count; i++) {
            if (!mask || mask[i]) {
               temp[i] = (src[i] << 8) | (temp[i] & 0xff);
            }
         }
      }
      else {
         assert(dsrb->Format == MESA_FORMAT_S8_Z24);
         for (i = 0; i < count; i++) {
            if (!mask || mask[i]) {
               temp[i] = (src[i] & 0xffffff) | (temp[i] & 0xff000000);
            }
         }
      }
      dsrb->PutValues(ctx, dsrb, count, x, y, temp, mask);
   }
}

static void
put_mono_values_z24(struct gl_context *ctx, struct gl_renderbuffer *z24rb,
                    GLuint count, const GLint x[], const GLint y[],
                    const void *value, const GLubyte *mask)
{
   struct gl_renderbuffer *dsrb = z24rb->Wrapped;
   GLuint temp[MAX_WIDTH], i;
   /* get, modify, put */
   dsrb->GetValues(ctx, dsrb, count, x, y, temp);
   if (dsrb->Format == MESA_FORMAT_Z24_S8) {
      const GLuint shiftedVal = *((GLuint *) value) << 8;
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            temp[i] = shiftedVal | (temp[i] & 0xff);
         }
      }
   }
   else {
      const GLuint shiftedVal = *((GLuint *) value);
      assert(dsrb->Format == MESA_FORMAT_S8_Z24);
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            temp[i] = shiftedVal | (temp[i] & 0xff000000);
         }
      }
   }
   dsrb->PutValues(ctx, dsrb, count, x, y, temp, mask);
}


/**
 * Wrap the given GL_DEPTH_STENCIL renderbuffer so that it acts like
 * a depth renderbuffer.
 * \return new depth renderbuffer
 */
struct gl_renderbuffer *
_mesa_new_z24_renderbuffer_wrapper(struct gl_context *ctx,
                                   struct gl_renderbuffer *dsrb)
{
   struct gl_renderbuffer *z24rb;

   ASSERT(dsrb->Format == MESA_FORMAT_Z24_S8 ||
          dsrb->Format == MESA_FORMAT_Z24_X8 ||
          dsrb->Format == MESA_FORMAT_S8_Z24 ||
          dsrb->Format == MESA_FORMAT_X8_Z24);
   ASSERT(dsrb->DataType == GL_UNSIGNED_INT_24_8_EXT);

   z24rb = ctx->Driver.NewRenderbuffer(ctx, 0);
   if (!z24rb)
      return NULL;

   /* NOTE: need to do manual refcounting here */
   z24rb->Wrapped = dsrb;
   dsrb->RefCount++;

   z24rb->Name = dsrb->Name;
   z24rb->RefCount = 0;
   z24rb->Width = dsrb->Width;
   z24rb->Height = dsrb->Height;
   z24rb->RowStride = dsrb->RowStride;
   z24rb->InternalFormat = GL_DEPTH_COMPONENT24;
   z24rb->Format = MESA_FORMAT_X8_Z24;
   z24rb->_BaseFormat = GL_DEPTH_COMPONENT;
   z24rb->DataType = GL_UNSIGNED_INT;
   z24rb->Data = NULL;
   z24rb->Delete = delete_wrapper;
   z24rb->AllocStorage = alloc_wrapper_storage;
   z24rb->GetPointer = nop_get_pointer;
   z24rb->GetRow = get_row_z24;
   z24rb->GetValues = get_values_z24;
   z24rb->PutRow = put_row_z24;
   z24rb->PutRowRGB = NULL;
   z24rb->PutMonoRow = put_mono_row_z24;
   z24rb->PutValues = put_values_z24;
   z24rb->PutMonoValues = put_mono_values_z24;

   return z24rb;
}


/*======================================================================
 * Stencil wrapper around depth/stencil renderbuffer
 */

static void
get_row_s8(struct gl_context *ctx, struct gl_renderbuffer *s8rb, GLuint count,
           GLint x, GLint y, void *values)
{
   struct gl_renderbuffer *dsrb = s8rb->Wrapped;
   GLuint temp[MAX_WIDTH], i;
   GLubyte *dst = (GLubyte *) values;
   const GLuint *src = (const GLuint *) dsrb->GetPointer(ctx, dsrb, x, y);
   ASSERT(s8rb->DataType == GL_UNSIGNED_BYTE);
   ASSERT(dsrb->DataType == GL_UNSIGNED_INT_24_8_EXT);
   if (!src) {
      dsrb->GetRow(ctx, dsrb, count, x, y, temp);
      src = temp;
   }
   if (dsrb->Format == MESA_FORMAT_Z24_S8) {
      for (i = 0; i < count; i++) {
         dst[i] = src[i] & 0xff;
      }
   }
   else {
      assert(dsrb->Format == MESA_FORMAT_S8_Z24);
      for (i = 0; i < count; i++) {
         dst[i] = src[i] >> 24;
      }
   }
}

static void
get_values_s8(struct gl_context *ctx, struct gl_renderbuffer *s8rb, GLuint count,
              const GLint x[], const GLint y[], void *values)
{
   struct gl_renderbuffer *dsrb = s8rb->Wrapped;
   GLuint temp[MAX_WIDTH], i;
   GLubyte *dst = (GLubyte *) values;
   ASSERT(s8rb->DataType == GL_UNSIGNED_BYTE);
   ASSERT(dsrb->DataType == GL_UNSIGNED_INT_24_8_EXT);
   ASSERT(count <= MAX_WIDTH);
   /* don't bother trying direct access */
   dsrb->GetValues(ctx, dsrb, count, x, y, temp);
   if (dsrb->Format == MESA_FORMAT_Z24_S8) {
      for (i = 0; i < count; i++) {
         dst[i] = temp[i] & 0xff;
      }
   }
   else {
      assert(dsrb->Format == MESA_FORMAT_S8_Z24);
      for (i = 0; i < count; i++) {
         dst[i] = temp[i] >> 24;
      }
   }
}

static void
put_row_s8(struct gl_context *ctx, struct gl_renderbuffer *s8rb, GLuint count,
           GLint x, GLint y, const void *values, const GLubyte *mask)
{
   struct gl_renderbuffer *dsrb = s8rb->Wrapped;
   const GLubyte *src = (const GLubyte *) values;
   GLuint *dst = (GLuint *) dsrb->GetPointer(ctx, dsrb, x, y);
   ASSERT(s8rb->DataType == GL_UNSIGNED_BYTE);
   ASSERT(dsrb->DataType == GL_UNSIGNED_INT_24_8_EXT);
   if (dst) {
      /* direct access */
      GLuint i;
      if (dsrb->Format == MESA_FORMAT_Z24_S8) {
         for (i = 0; i < count; i++) {
            if (!mask || mask[i]) {
               dst[i] = (dst[i] & 0xffffff00) | src[i];
            }
         }
      }
      else {
         assert(dsrb->Format == MESA_FORMAT_S8_Z24);
         for (i = 0; i < count; i++) {
            if (!mask || mask[i]) {
               dst[i] = (dst[i] & 0xffffff) | (src[i] << 24);
            }
         }
      }
   }
   else {
      /* get, modify, put */
      GLuint temp[MAX_WIDTH], i;
      dsrb->GetRow(ctx, dsrb, count, x, y, temp);
      if (dsrb->Format == MESA_FORMAT_Z24_S8) {
         for (i = 0; i < count; i++) {
            if (!mask || mask[i]) {
               temp[i] = (temp[i] & 0xffffff00) | src[i];
            }
         }
      }
      else {
         assert(dsrb->Format == MESA_FORMAT_S8_Z24);
         for (i = 0; i < count; i++) {
            if (!mask || mask[i]) {
               temp[i] = (temp[i] & 0xffffff) | (src[i] << 24);
            }
         }
      }
      dsrb->PutRow(ctx, dsrb, count, x, y, temp, mask);
   }
}

static void
put_mono_row_s8(struct gl_context *ctx, struct gl_renderbuffer *s8rb, GLuint count,
                GLint x, GLint y, const void *value, const GLubyte *mask)
{
   struct gl_renderbuffer *dsrb = s8rb->Wrapped;
   const GLubyte val = *((GLubyte *) value);
   GLuint *dst = (GLuint *) dsrb->GetPointer(ctx, dsrb, x, y);
   ASSERT(s8rb->DataType == GL_UNSIGNED_BYTE);
   ASSERT(dsrb->DataType == GL_UNSIGNED_INT_24_8_EXT);
   if (dst) {
      /* direct access */
      GLuint i;
      if (dsrb->Format == MESA_FORMAT_Z24_S8) {
         for (i = 0; i < count; i++) {
            if (!mask || mask[i]) {
               dst[i] = (dst[i] & 0xffffff00) | val;
            }
         }
      }
      else {
         assert(dsrb->Format == MESA_FORMAT_S8_Z24);
         for (i = 0; i < count; i++) {
            if (!mask || mask[i]) {
               dst[i] = (dst[i] & 0xffffff) | (val << 24);
            }
         }
      }
   }
   else {
      /* get, modify, put */
      GLuint temp[MAX_WIDTH], i;
      dsrb->GetRow(ctx, dsrb, count, x, y, temp);
      if (dsrb->Format == MESA_FORMAT_Z24_S8) {
         for (i = 0; i < count; i++) {
            if (!mask || mask[i]) {
               temp[i] = (temp[i] & 0xffffff00) | val;
            }
         }
      }
      else {
         assert(dsrb->Format == MESA_FORMAT_S8_Z24);
         for (i = 0; i < count; i++) {
            if (!mask || mask[i]) {
               temp[i] = (temp[i] & 0xffffff) | (val << 24);
            }
         }
      }
      dsrb->PutRow(ctx, dsrb, count, x, y, temp, mask);
   }
}

static void
put_values_s8(struct gl_context *ctx, struct gl_renderbuffer *s8rb, GLuint count,
              const GLint x[], const GLint y[],
              const void *values, const GLubyte *mask)
{
   struct gl_renderbuffer *dsrb = s8rb->Wrapped;
   const GLubyte *src = (const GLubyte *) values;
   ASSERT(s8rb->DataType == GL_UNSIGNED_BYTE);
   ASSERT(dsrb->DataType == GL_UNSIGNED_INT_24_8_EXT);
   if (dsrb->GetPointer(ctx, dsrb, 0, 0)) {
      /* direct access */
      GLuint i;
      if (dsrb->Format == MESA_FORMAT_Z24_S8) {
         for (i = 0; i < count; i++) {
            if (!mask || mask[i]) {
               GLuint *dst = (GLuint *) dsrb->GetPointer(ctx, dsrb, x[i], y[i]);
               *dst = (*dst & 0xffffff00) | src[i];
            }
         }
      }
      else {
         assert(dsrb->Format == MESA_FORMAT_S8_Z24);
         for (i = 0; i < count; i++) {
            if (!mask || mask[i]) {
               GLuint *dst = (GLuint *) dsrb->GetPointer(ctx, dsrb, x[i], y[i]);
               *dst = (*dst & 0xffffff) | (src[i] << 24);
            }
         }
      }
   }
   else {
      /* get, modify, put */
      GLuint temp[MAX_WIDTH], i;
      dsrb->GetValues(ctx, dsrb, count, x, y, temp);
      if (dsrb->Format == MESA_FORMAT_Z24_S8) {
         for (i = 0; i < count; i++) {
            if (!mask || mask[i]) {
               temp[i] = (temp[i] & 0xffffff00) | src[i];
            }
         }
      }
      else {
         assert(dsrb->Format == MESA_FORMAT_S8_Z24);
         for (i = 0; i < count; i++) {
            if (!mask || mask[i]) {
               temp[i] = (temp[i] & 0xffffff) | (src[i] << 24);
            }
         }
      }
      dsrb->PutValues(ctx, dsrb, count, x, y, temp, mask);
   }
}

static void
put_mono_values_s8(struct gl_context *ctx, struct gl_renderbuffer *s8rb, GLuint count,
                   const GLint x[], const GLint y[],
                   const void *value, const GLubyte *mask)
{
   struct gl_renderbuffer *dsrb = s8rb->Wrapped;
   GLuint temp[MAX_WIDTH], i;
   const GLubyte val = *((GLubyte *) value);
   /* get, modify, put */
   dsrb->GetValues(ctx, dsrb, count, x, y, temp);
   if (dsrb->Format == MESA_FORMAT_Z24_S8) {
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            temp[i] = (temp[i] & 0xffffff00) | val;
         }
      }
   }
   else {
      assert(dsrb->Format == MESA_FORMAT_S8_Z24);
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            temp[i] = (temp[i] & 0xffffff) | (val << 24);
         }
      }
   }
   dsrb->PutValues(ctx, dsrb, count, x, y, temp, mask);
}


/**
 * Wrap the given GL_DEPTH_STENCIL renderbuffer so that it acts like
 * a stencil renderbuffer.
 * \return new stencil renderbuffer
 */
struct gl_renderbuffer *
_mesa_new_s8_renderbuffer_wrapper(struct gl_context *ctx, struct gl_renderbuffer *dsrb)
{
   struct gl_renderbuffer *s8rb;

   ASSERT(dsrb->Format == MESA_FORMAT_Z24_S8 ||
          dsrb->Format == MESA_FORMAT_S8_Z24);
   ASSERT(dsrb->DataType == GL_UNSIGNED_INT_24_8_EXT);

   s8rb = ctx->Driver.NewRenderbuffer(ctx, 0);
   if (!s8rb)
      return NULL;

   /* NOTE: need to do manual refcounting here */
   s8rb->Wrapped = dsrb;
   dsrb->RefCount++;

   s8rb->Name = dsrb->Name;
   s8rb->RefCount = 0;
   s8rb->Width = dsrb->Width;
   s8rb->Height = dsrb->Height;
   s8rb->RowStride = dsrb->RowStride;
   s8rb->InternalFormat = GL_STENCIL_INDEX8_EXT;
   s8rb->Format = MESA_FORMAT_S8;
   s8rb->_BaseFormat = GL_STENCIL_INDEX;
   s8rb->DataType = GL_UNSIGNED_BYTE;
   s8rb->Data = NULL;
   s8rb->Delete = delete_wrapper;
   s8rb->AllocStorage = alloc_wrapper_storage;
   s8rb->GetPointer = nop_get_pointer;
   s8rb->GetRow = get_row_s8;
   s8rb->GetValues = get_values_s8;
   s8rb->PutRow = put_row_s8;
   s8rb->PutRowRGB = NULL;
   s8rb->PutMonoRow = put_mono_row_s8;
   s8rb->PutValues = put_values_s8;
   s8rb->PutMonoValues = put_mono_values_s8;

   return s8rb;
}



/**
 ** The following functions are useful for hardware drivers that only
 ** implement combined depth/stencil buffers.
 ** The GL_EXT_framebuffer_object extension allows indepedent depth and
 ** stencil buffers to be used in any combination.
 ** Therefore, we sometimes have to merge separate depth and stencil
 ** renderbuffers into a single depth+stencil renderbuffer.  And sometimes
 ** we have to split combined depth+stencil renderbuffers into separate
 ** renderbuffers.
 **/


/**
 * Extract stencil values from the combined depth/stencil renderbuffer, storing
 * the values into a separate stencil renderbuffer.
 * \param dsRb  the source depth/stencil renderbuffer
 * \param stencilRb  the destination stencil renderbuffer
 *                   (either 8-bit or 32-bit)
 */
void
_mesa_extract_stencil(struct gl_context *ctx,
                      struct gl_renderbuffer *dsRb,
                      struct gl_renderbuffer *stencilRb)
{
   GLuint row, width, height;

   ASSERT(dsRb);
   ASSERT(stencilRb);

   ASSERT(dsRb->Format == MESA_FORMAT_Z24_S8);
   ASSERT(dsRb->DataType == GL_UNSIGNED_INT_24_8_EXT);
   ASSERT(stencilRb->Format == MESA_FORMAT_Z24_S8 ||
          stencilRb->Format == MESA_FORMAT_S8);
   ASSERT(dsRb->Width == stencilRb->Width);
   ASSERT(dsRb->Height == stencilRb->Height);

   width = dsRb->Width;
   height = dsRb->Height;

   for (row = 0; row < height; row++) {
      GLuint depthStencil[MAX_WIDTH];
      dsRb->GetRow(ctx, dsRb, width, 0, row, depthStencil);
      if (stencilRb->Format == MESA_FORMAT_S8) {
         /* 8bpp stencil */
         GLubyte stencil[MAX_WIDTH];
         GLuint i;
         for (i = 0; i < width; i++) {
            stencil[i] = depthStencil[i] & 0xff;
         }
         stencilRb->PutRow(ctx, stencilRb, width, 0, row, stencil, NULL);
      }
      else {
         /* 32bpp stencil */
         /* the 24 depth bits will be ignored */
         ASSERT(stencilRb->Format == MESA_FORMAT_Z24_S8);
         ASSERT(stencilRb->DataType == GL_UNSIGNED_INT_24_8_EXT);
         stencilRb->PutRow(ctx, stencilRb, width, 0, row, depthStencil, NULL);
      }
   }
}


/**
 * Copy stencil values from a stencil renderbuffer into a combined
 * depth/stencil renderbuffer.
 * \param dsRb  the destination depth/stencil renderbuffer
 * \param stencilRb  the source stencil buffer (either 8-bit or 32-bit)
 */
void
_mesa_insert_stencil(struct gl_context *ctx,
                     struct gl_renderbuffer *dsRb,
                     struct gl_renderbuffer *stencilRb)
{
   GLuint row, width, height;

   ASSERT(dsRb);
   ASSERT(stencilRb);

   ASSERT(dsRb->Format == MESA_FORMAT_Z24_S8);
   ASSERT(dsRb->DataType == GL_UNSIGNED_INT_24_8_EXT);
   ASSERT(stencilRb->Format == MESA_FORMAT_Z24_S8 ||
          stencilRb->Format == MESA_FORMAT_S8);

   ASSERT(dsRb->Width == stencilRb->Width);
   ASSERT(dsRb->Height == stencilRb->Height);

   width = dsRb->Width;
   height = dsRb->Height;

   for (row = 0; row < height; row++) {
      GLuint depthStencil[MAX_WIDTH];

      dsRb->GetRow(ctx, dsRb, width, 0, row, depthStencil);

      if (stencilRb->Format == MESA_FORMAT_S8) {
         /* 8bpp stencil */
         GLubyte stencil[MAX_WIDTH];
         GLuint i;
         stencilRb->GetRow(ctx, stencilRb, width, 0, row, stencil);
         for (i = 0; i < width; i++) {
            depthStencil[i] = (depthStencil[i] & 0xffffff00) | stencil[i];
         }
      }
      else {
         /* 32bpp stencil buffer */
         GLuint stencil[MAX_WIDTH], i;
         ASSERT(stencilRb->Format == MESA_FORMAT_Z24_S8);
         ASSERT(stencilRb->DataType == GL_UNSIGNED_INT_24_8_EXT);
         stencilRb->GetRow(ctx, stencilRb, width, 0, row, stencil);
         for (i = 0; i < width; i++) {
            depthStencil[i]
               = (depthStencil[i] & 0xffffff00) | (stencil[i] & 0xff);
         }
      }

      dsRb->PutRow(ctx, dsRb, width, 0, row, depthStencil, NULL);
   }
}


/**
 * Convert the stencil buffer from 8bpp to 32bpp depth/stencil.
 * \param stencilRb  the stencil renderbuffer to promote
 */
void
_mesa_promote_stencil(struct gl_context *ctx, struct gl_renderbuffer *stencilRb)
{
   const GLsizei width = stencilRb->Width;
   const GLsizei height = stencilRb->Height;
   GLubyte *data;
   GLint i, j, k;

   ASSERT(stencilRb->Format == MESA_FORMAT_S8);
   ASSERT(stencilRb->Data);

   data = (GLubyte *) stencilRb->Data;
   stencilRb->Data = NULL;
   stencilRb->AllocStorage(ctx, stencilRb, GL_DEPTH24_STENCIL8_EXT,
                           width, height);

   ASSERT(stencilRb->DataType == GL_UNSIGNED_INT_24_8_EXT);

   k = 0;
   for (i = 0; i < height; i++) {
      GLuint depthStencil[MAX_WIDTH];
      for (j = 0; j < width; j++) {
         depthStencil[j] = data[k++];
      }
      stencilRb->PutRow(ctx, stencilRb, width, 0, i, depthStencil, NULL);
   }
   free(data);
}
@


1.5
log
@Merge Mesa 7.10.3
@
text
@@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d49 1
a49 1
nop_get_pointer(GLcontext *ctx, struct gl_renderbuffer *rb, GLint x, GLint y)
d65 2
a66 2
   ASSERT(rb->Format == MESA_FORMAT_Z24_S8 ||
          rb->Format == MESA_FORMAT_S8_Z24);
d76 1
a76 1
alloc_wrapper_storage(GLcontext *ctx, struct gl_renderbuffer *rb,
d86 3
a88 1
          dsrb->Format == MESA_FORMAT_S8_Z24);
d94 1
d107 1
a107 1
get_row_z24(GLcontext *ctx, struct gl_renderbuffer *z24rb, GLuint count,
d134 1
a134 1
get_values_z24(GLcontext *ctx, struct gl_renderbuffer *z24rb, GLuint count,
d159 1
a159 1
put_row_z24(GLcontext *ctx, struct gl_renderbuffer *z24rb, GLuint count,
d210 1
a210 1
put_mono_row_z24(GLcontext *ctx, struct gl_renderbuffer *z24rb, GLuint count,
d264 1
a264 1
put_values_z24(GLcontext *ctx, struct gl_renderbuffer *z24rb, GLuint count,
d317 1
a317 1
put_mono_values_z24(GLcontext *ctx, struct gl_renderbuffer *z24rb,
d352 1
a352 1
_mesa_new_z24_renderbuffer_wrapper(GLcontext *ctx,
d358 3
a360 1
          dsrb->Format == MESA_FORMAT_S8_Z24);
d363 1
a363 1
   z24rb = _mesa_new_renderbuffer(ctx, 0);
d367 1
d369 2
d372 1
a372 1
   z24rb->RefCount = 1;
d375 1
d401 1
a401 1
get_row_s8(GLcontext *ctx, struct gl_renderbuffer *s8rb, GLuint count,
d428 1
a428 1
get_values_s8(GLcontext *ctx, struct gl_renderbuffer *s8rb, GLuint count,
d453 1
a453 1
put_row_s8(GLcontext *ctx, struct gl_renderbuffer *s8rb, GLuint count,
d504 1
a504 1
put_mono_row_s8(GLcontext *ctx, struct gl_renderbuffer *s8rb, GLuint count,
d555 1
a555 1
put_values_s8(GLcontext *ctx, struct gl_renderbuffer *s8rb, GLuint count,
d608 1
a608 1
put_mono_values_s8(GLcontext *ctx, struct gl_renderbuffer *s8rb, GLuint count,
d642 1
a642 1
_mesa_new_s8_renderbuffer_wrapper(GLcontext *ctx, struct gl_renderbuffer *dsrb)
d650 1
a650 1
   s8rb = _mesa_new_renderbuffer(ctx, 0);
d654 1
d656 2
d659 1
a659 1
   s8rb->RefCount = 1;
d662 1
d704 1
a704 1
_mesa_extract_stencil(GLcontext *ctx,
d753 1
a753 1
_mesa_insert_stencil(GLcontext *ctx,
d809 1
a809 1
_mesa_promote_stencil(GLcontext *ctx, struct gl_renderbuffer *stencilRb)
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d28 1
a28 1
#include "fbobject.h"
d43 2
a44 2
 * We solve this by wrapping the Z24_S8 renderbuffer with depth and stencil
 * adaptors, each with the right kind of depth/stencil Get/Put functions.
d65 4
a68 10
   struct gl_renderbuffer *dsrb = rb->Wrapped;
   ASSERT(dsrb);
   ASSERT(rb->_ActualFormat == GL_DEPTH_COMPONENT24 ||
          rb->_ActualFormat == GL_STENCIL_INDEX8_EXT);
   /* decrement refcount on the wrapped buffer and delete it if necessary */
   dsrb->RefCount--;
   if (dsrb->RefCount <= 0) {
      dsrb->Delete(dsrb);
   }
   _mesa_free(rb);
d85 2
a86 1
   ASSERT(dsrb->_ActualFormat == GL_DEPTH24_STENCIL8_EXT);
a111 1
   ASSERT(dsrb->_ActualFormat == GL_DEPTH24_STENCIL8_EXT);
d117 10
a126 2
   for (i = 0; i < count; i++) {
      dst[i] = src[i] >> 8;
a137 1
   ASSERT(dsrb->_ActualFormat == GL_DEPTH24_STENCIL8_EXT);
d142 10
a151 2
   for (i = 0; i < count; i++) {
      dst[i] = temp[i] >> 8;
a162 1
   ASSERT(dsrb->_ActualFormat == GL_DEPTH24_STENCIL8_EXT);
d167 13
a179 3
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            dst[i] = (src[i] << 8) | (dst[i] & 0xff);
d187 13
a199 3
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            temp[i] = (src[i] << 8) | (temp[i] & 0xff);
a210 1
   const GLuint shiftedVal = *((GLuint *) value) << 8;
a212 1
   ASSERT(dsrb->_ActualFormat == GL_DEPTH24_STENCIL8_EXT);
d217 15
a231 3
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            dst[i] = shiftedVal | (dst[i] & 0xff);
d239 15
a253 3
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            temp[i] = shiftedVal | (temp[i] & 0xff);
a267 1
   ASSERT(dsrb->_ActualFormat == GL_DEPTH24_STENCIL8_EXT);
d272 15
a286 4
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            GLuint *dst = (GLuint *) dsrb->GetPointer(ctx, dsrb, x[i], y[i]);
            *dst = (src[i] << 8) | (*dst & 0xff);
d294 13
a306 3
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            temp[i] = (src[i] << 8) | (temp[i] & 0xff);
a319 1
   const GLuint shiftedVal = *((GLuint *) value) << 8;
d322 15
a336 3
   for (i = 0; i < count; i++) {
      if (!mask || mask[i]) {
         temp[i] = shiftedVal | (temp[i] & 0xff);
d354 2
a355 1
   ASSERT(dsrb->_ActualFormat == GL_DEPTH24_STENCIL8_EXT);
d368 1
a368 1
   z24rb->_ActualFormat = GL_DEPTH_COMPONENT24;
a370 1
   z24rb->DepthBits = 24;
a399 1
   ASSERT(dsrb->_ActualFormat == GL_DEPTH24_STENCIL8_EXT);
d405 10
a414 2
   for (i = 0; i < count; i++) {
      dst[i] = src[i] & 0xff;
a425 1
   ASSERT(dsrb->_ActualFormat == GL_DEPTH24_STENCIL8_EXT);
d430 10
a439 2
   for (i = 0; i < count; i++) {
      dst[i] = temp[i] & 0xff;
a450 1
   ASSERT(dsrb->_ActualFormat == GL_DEPTH24_STENCIL8_EXT);
d455 13
a467 3
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            dst[i] = (dst[i] & 0xffffff00) | src[i];
d475 13
a487 3
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            temp[i] = (temp[i] & 0xffffff00) | src[i];
a501 1
   ASSERT(dsrb->_ActualFormat == GL_DEPTH24_STENCIL8_EXT);
d506 13
a518 3
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            dst[i] = (dst[i] & 0xffffff00) | val;
d526 13
a538 3
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            temp[i] = (temp[i] & 0xffffff00) | val;
a552 1
   ASSERT(dsrb->_ActualFormat == GL_DEPTH24_STENCIL8_EXT);
d557 15
a571 4
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            GLuint *dst = (GLuint *) dsrb->GetPointer(ctx, dsrb, x[i], y[i]);
            *dst = (*dst & 0xffffff00) | src[i];
d579 13
a591 3
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            temp[i] = (temp[i] & 0xffffff00) | src[i];
d608 13
a620 3
   for (i = 0; i < count; i++) {
      if (!mask || mask[i]) {
         temp[i] = (temp[i] & 0xffffff) | val;
d637 2
a638 1
   ASSERT(dsrb->_ActualFormat == GL_DEPTH24_STENCIL8_EXT);
d651 1
a651 1
   s8rb->_ActualFormat = GL_STENCIL_INDEX8_EXT;
a653 1
   s8rb->StencilBits = 8;
d700 1
a700 1
   ASSERT(dsRb->_ActualFormat == GL_DEPTH24_STENCIL8_EXT);
d702 2
a703 2
   ASSERT(stencilRb->_ActualFormat == GL_DEPTH24_STENCIL8_EXT ||
          stencilRb->_ActualFormat == GL_STENCIL_INDEX8_EXT);
d713 1
a713 1
      if (stencilRb->_ActualFormat == GL_STENCIL_INDEX8_EXT) {
d725 1
a725 1
         ASSERT(stencilRb->_ActualFormat == GL_DEPTH24_STENCIL8_EXT);
d749 1
a749 1
   ASSERT(dsRb->_ActualFormat == GL_DEPTH24_STENCIL8_EXT);
d751 2
a752 2
   ASSERT(stencilRb->_ActualFormat == GL_DEPTH24_STENCIL8_EXT ||
          stencilRb->_ActualFormat == GL_STENCIL_INDEX8_EXT);
d765 1
a765 1
      if (stencilRb->_ActualFormat == GL_STENCIL_INDEX8_EXT) {
d777 1
a777 1
         ASSERT(stencilRb->_ActualFormat == GL_DEPTH24_STENCIL8_EXT);
d803 1
a803 1
   ASSERT(stencilRb->_ActualFormat == GL_STENCIL_INDEX8_EXT);
d821 1
a821 3
   _mesa_free(data);

   stencilRb->_BaseFormat = GL_DEPTH_STENCIL_EXT;
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d285 2
a286 2
   z24rb->InternalFormat = GL_DEPTH_COMPONENT24_ARB;
   z24rb->_ActualFormat = GL_DEPTH_COMPONENT24_ARB;
@


1.1
log
@Initial revision
@
text
@d216 1
a216 1
   const GLubyte *src = (const GLubyte *) values;
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@Import Mesa 7.10.3
@
text
@d28 1
a28 1
#include "formats.h"
d43 2
a44 2
 * We solve this by wrapping the Z24_S8 or S8_Z24 renderbuffer with depth and
 * stencil adaptors, each with the right kind of depth/stencil Get/Put functions.
d49 1
a49 1
nop_get_pointer(struct gl_context *ctx, struct gl_renderbuffer *rb, GLint x, GLint y)
d65 10
a74 4
   ASSERT(rb->Format == MESA_FORMAT_S8 ||
          rb->Format == MESA_FORMAT_X8_Z24);
   _mesa_reference_renderbuffer(&rb->Wrapped, NULL);
   free(rb);
d82 1
a82 1
alloc_wrapper_storage(struct gl_context *ctx, struct gl_renderbuffer *rb,
d91 1
a91 4
   ASSERT(dsrb->Format == MESA_FORMAT_Z24_S8 ||
          dsrb->Format == MESA_FORMAT_Z24_X8 ||
          dsrb->Format == MESA_FORMAT_S8_Z24 ||
          dsrb->Format == MESA_FORMAT_X8_Z24);
a96 1
      rb->RowStride = dsrb->RowStride;
d109 1
a109 1
get_row_z24(struct gl_context *ctx, struct gl_renderbuffer *z24rb, GLuint count,
d117 1
d123 2
a124 10
   if (dsrb->Format == MESA_FORMAT_Z24_S8) {
      for (i = 0; i < count; i++) {
         dst[i] = src[i] >> 8;
      }
   }
   else {
      assert(dsrb->Format == MESA_FORMAT_S8_Z24);
      for (i = 0; i < count; i++) {
         dst[i] = src[i] & 0xffffff;
      }
d129 1
a129 1
get_values_z24(struct gl_context *ctx, struct gl_renderbuffer *z24rb, GLuint count,
d136 1
d141 2
a142 10
   if (dsrb->Format == MESA_FORMAT_Z24_S8) {
      for (i = 0; i < count; i++) {
         dst[i] = temp[i] >> 8;
      }
   }
   else {
      assert(dsrb->Format == MESA_FORMAT_S8_Z24);
      for (i = 0; i < count; i++) {
         dst[i] = temp[i] & 0xffffff;
      }
d147 1
a147 1
put_row_z24(struct gl_context *ctx, struct gl_renderbuffer *z24rb, GLuint count,
d154 1
d159 3
a161 13
      if (dsrb->Format == MESA_FORMAT_Z24_S8) {
         for (i = 0; i < count; i++) {
            if (!mask || mask[i]) {
               dst[i] = (src[i] << 8) | (dst[i] & 0xff);
            }
         }
      }
      else {
         assert(dsrb->Format == MESA_FORMAT_S8_Z24);
         for (i = 0; i < count; i++) {
            if (!mask || mask[i]) {
               dst[i] = (src[i] & 0xffffff) | (dst[i] & 0xff000000);
            }
d169 3
a171 13
      if (dsrb->Format == MESA_FORMAT_Z24_S8) {
         for (i = 0; i < count; i++) {
            if (!mask || mask[i]) {
               temp[i] = (src[i] << 8) | (temp[i] & 0xff);
            }
         }
      }
      else {
         assert(dsrb->Format == MESA_FORMAT_S8_Z24);
         for (i = 0; i < count; i++) {
            if (!mask || mask[i]) {
               temp[i] = (src[i] & 0xffffff) | (temp[i] & 0xff000000);
            }
d179 1
a179 1
put_mono_row_z24(struct gl_context *ctx, struct gl_renderbuffer *z24rb, GLuint count,
d183 1
d186 1
d191 3
a193 15
      if (dsrb->Format == MESA_FORMAT_Z24_S8) {
         const GLuint shiftedVal = *((GLuint *) value) << 8;
         for (i = 0; i < count; i++) {
            if (!mask || mask[i]) {
               dst[i] = shiftedVal | (dst[i] & 0xff);
            }
         }
      }
      else {
         const GLuint shiftedVal = *((GLuint *) value);
         assert(dsrb->Format == MESA_FORMAT_S8_Z24);
         for (i = 0; i < count; i++) {
            if (!mask || mask[i]) {
               dst[i] = shiftedVal | (dst[i] & 0xff000000);
            }
d201 3
a203 15
      if (dsrb->Format == MESA_FORMAT_Z24_S8) {
         const GLuint shiftedVal = *((GLuint *) value) << 8;
         for (i = 0; i < count; i++) {
            if (!mask || mask[i]) {
               temp[i] = shiftedVal | (temp[i] & 0xff);
            }
         }
      }
      else {
         const GLuint shiftedVal = *((GLuint *) value);
         assert(dsrb->Format == MESA_FORMAT_S8_Z24);
         for (i = 0; i < count; i++) {
            if (!mask || mask[i]) {
               temp[i] = shiftedVal | (temp[i] & 0xff000000);
            }
d211 1
a211 1
put_values_z24(struct gl_context *ctx, struct gl_renderbuffer *z24rb, GLuint count,
d216 1
a216 1
   const GLuint *src = (const GLuint *) values;
d218 1
d223 4
a226 15
      if (dsrb->Format == MESA_FORMAT_Z24_S8) {
         for (i = 0; i < count; i++) {
            if (!mask || mask[i]) {
               GLuint *dst = (GLuint *) dsrb->GetPointer(ctx, dsrb, x[i], y[i]);
               *dst = (src[i] << 8) | (*dst & 0xff);
            }
         }
      }
      else {
         assert(dsrb->Format == MESA_FORMAT_S8_Z24);
         for (i = 0; i < count; i++) {
            if (!mask || mask[i]) {
               GLuint *dst = (GLuint *) dsrb->GetPointer(ctx, dsrb, x[i], y[i]);
               *dst = (src[i] & 0xffffff) | (*dst & 0xff000000);
            }
d234 3
a236 13
      if (dsrb->Format == MESA_FORMAT_Z24_S8) {
         for (i = 0; i < count; i++) {
            if (!mask || mask[i]) {
               temp[i] = (src[i] << 8) | (temp[i] & 0xff);
            }
         }
      }
      else {
         assert(dsrb->Format == MESA_FORMAT_S8_Z24);
         for (i = 0; i < count; i++) {
            if (!mask || mask[i]) {
               temp[i] = (src[i] & 0xffffff) | (temp[i] & 0xff000000);
            }
d244 1
a244 1
put_mono_values_z24(struct gl_context *ctx, struct gl_renderbuffer *z24rb,
d250 1
d253 3
a255 15
   if (dsrb->Format == MESA_FORMAT_Z24_S8) {
      const GLuint shiftedVal = *((GLuint *) value) << 8;
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            temp[i] = shiftedVal | (temp[i] & 0xff);
         }
      }
   }
   else {
      const GLuint shiftedVal = *((GLuint *) value);
      assert(dsrb->Format == MESA_FORMAT_S8_Z24);
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            temp[i] = shiftedVal | (temp[i] & 0xff000000);
         }
d268 1
a268 1
_mesa_new_z24_renderbuffer_wrapper(struct gl_context *ctx,
d273 1
a273 4
   ASSERT(dsrb->Format == MESA_FORMAT_Z24_S8 ||
          dsrb->Format == MESA_FORMAT_Z24_X8 ||
          dsrb->Format == MESA_FORMAT_S8_Z24 ||
          dsrb->Format == MESA_FORMAT_X8_Z24);
d276 1
a276 1
   z24rb = ctx->Driver.NewRenderbuffer(ctx, 0);
a279 1
   /* NOTE: need to do manual refcounting here */
a280 2
   dsrb->RefCount++;

d282 1
a282 1
   z24rb->RefCount = 0;
d285 2
a286 3
   z24rb->RowStride = dsrb->RowStride;
   z24rb->InternalFormat = GL_DEPTH_COMPONENT24;
   z24rb->Format = MESA_FORMAT_X8_Z24;
d289 1
d311 1
a311 1
get_row_s8(struct gl_context *ctx, struct gl_renderbuffer *s8rb, GLuint count,
d319 1
d325 2
a326 10
   if (dsrb->Format == MESA_FORMAT_Z24_S8) {
      for (i = 0; i < count; i++) {
         dst[i] = src[i] & 0xff;
      }
   }
   else {
      assert(dsrb->Format == MESA_FORMAT_S8_Z24);
      for (i = 0; i < count; i++) {
         dst[i] = src[i] >> 24;
      }
d331 1
a331 1
get_values_s8(struct gl_context *ctx, struct gl_renderbuffer *s8rb, GLuint count,
d338 1
d343 2
a344 10
   if (dsrb->Format == MESA_FORMAT_Z24_S8) {
      for (i = 0; i < count; i++) {
         dst[i] = temp[i] & 0xff;
      }
   }
   else {
      assert(dsrb->Format == MESA_FORMAT_S8_Z24);
      for (i = 0; i < count; i++) {
         dst[i] = temp[i] >> 24;
      }
d349 1
a349 1
put_row_s8(struct gl_context *ctx, struct gl_renderbuffer *s8rb, GLuint count,
d356 1
d361 3
a363 13
      if (dsrb->Format == MESA_FORMAT_Z24_S8) {
         for (i = 0; i < count; i++) {
            if (!mask || mask[i]) {
               dst[i] = (dst[i] & 0xffffff00) | src[i];
            }
         }
      }
      else {
         assert(dsrb->Format == MESA_FORMAT_S8_Z24);
         for (i = 0; i < count; i++) {
            if (!mask || mask[i]) {
               dst[i] = (dst[i] & 0xffffff) | (src[i] << 24);
            }
d371 3
a373 13
      if (dsrb->Format == MESA_FORMAT_Z24_S8) {
         for (i = 0; i < count; i++) {
            if (!mask || mask[i]) {
               temp[i] = (temp[i] & 0xffffff00) | src[i];
            }
         }
      }
      else {
         assert(dsrb->Format == MESA_FORMAT_S8_Z24);
         for (i = 0; i < count; i++) {
            if (!mask || mask[i]) {
               temp[i] = (temp[i] & 0xffffff) | (src[i] << 24);
            }
d381 1
a381 1
put_mono_row_s8(struct gl_context *ctx, struct gl_renderbuffer *s8rb, GLuint count,
d388 1
d393 3
a395 13
      if (dsrb->Format == MESA_FORMAT_Z24_S8) {
         for (i = 0; i < count; i++) {
            if (!mask || mask[i]) {
               dst[i] = (dst[i] & 0xffffff00) | val;
            }
         }
      }
      else {
         assert(dsrb->Format == MESA_FORMAT_S8_Z24);
         for (i = 0; i < count; i++) {
            if (!mask || mask[i]) {
               dst[i] = (dst[i] & 0xffffff) | (val << 24);
            }
d403 3
a405 13
      if (dsrb->Format == MESA_FORMAT_Z24_S8) {
         for (i = 0; i < count; i++) {
            if (!mask || mask[i]) {
               temp[i] = (temp[i] & 0xffffff00) | val;
            }
         }
      }
      else {
         assert(dsrb->Format == MESA_FORMAT_S8_Z24);
         for (i = 0; i < count; i++) {
            if (!mask || mask[i]) {
               temp[i] = (temp[i] & 0xffffff) | (val << 24);
            }
d413 1
a413 1
put_values_s8(struct gl_context *ctx, struct gl_renderbuffer *s8rb, GLuint count,
d420 1
d425 4
a428 15
      if (dsrb->Format == MESA_FORMAT_Z24_S8) {
         for (i = 0; i < count; i++) {
            if (!mask || mask[i]) {
               GLuint *dst = (GLuint *) dsrb->GetPointer(ctx, dsrb, x[i], y[i]);
               *dst = (*dst & 0xffffff00) | src[i];
            }
         }
      }
      else {
         assert(dsrb->Format == MESA_FORMAT_S8_Z24);
         for (i = 0; i < count; i++) {
            if (!mask || mask[i]) {
               GLuint *dst = (GLuint *) dsrb->GetPointer(ctx, dsrb, x[i], y[i]);
               *dst = (*dst & 0xffffff) | (src[i] << 24);
            }
d436 3
a438 13
      if (dsrb->Format == MESA_FORMAT_Z24_S8) {
         for (i = 0; i < count; i++) {
            if (!mask || mask[i]) {
               temp[i] = (temp[i] & 0xffffff00) | src[i];
            }
         }
      }
      else {
         assert(dsrb->Format == MESA_FORMAT_S8_Z24);
         for (i = 0; i < count; i++) {
            if (!mask || mask[i]) {
               temp[i] = (temp[i] & 0xffffff) | (src[i] << 24);
            }
d446 1
a446 1
put_mono_values_s8(struct gl_context *ctx, struct gl_renderbuffer *s8rb, GLuint count,
d455 3
a457 13
   if (dsrb->Format == MESA_FORMAT_Z24_S8) {
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            temp[i] = (temp[i] & 0xffffff00) | val;
         }
      }
   }
   else {
      assert(dsrb->Format == MESA_FORMAT_S8_Z24);
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            temp[i] = (temp[i] & 0xffffff) | (val << 24);
         }
d470 1
a470 1
_mesa_new_s8_renderbuffer_wrapper(struct gl_context *ctx, struct gl_renderbuffer *dsrb)
d474 1
a474 2
   ASSERT(dsrb->Format == MESA_FORMAT_Z24_S8 ||
          dsrb->Format == MESA_FORMAT_S8_Z24);
d477 1
a477 1
   s8rb = ctx->Driver.NewRenderbuffer(ctx, 0);
a480 1
   /* NOTE: need to do manual refcounting here */
a481 2
   dsrb->RefCount++;

d483 1
a483 1
   s8rb->RefCount = 0;
a485 1
   s8rb->RowStride = dsrb->RowStride;
d487 1
a487 1
   s8rb->Format = MESA_FORMAT_S8;
d490 1
d528 1
a528 1
_mesa_extract_stencil(struct gl_context *ctx,
d537 1
a537 1
   ASSERT(dsRb->Format == MESA_FORMAT_Z24_S8);
d539 2
a540 2
   ASSERT(stencilRb->Format == MESA_FORMAT_Z24_S8 ||
          stencilRb->Format == MESA_FORMAT_S8);
d550 1
a550 1
      if (stencilRb->Format == MESA_FORMAT_S8) {
d562 1
a562 1
         ASSERT(stencilRb->Format == MESA_FORMAT_Z24_S8);
d577 1
a577 1
_mesa_insert_stencil(struct gl_context *ctx,
d586 1
a586 1
   ASSERT(dsRb->Format == MESA_FORMAT_Z24_S8);
d588 2
a589 2
   ASSERT(stencilRb->Format == MESA_FORMAT_Z24_S8 ||
          stencilRb->Format == MESA_FORMAT_S8);
d602 1
a602 1
      if (stencilRb->Format == MESA_FORMAT_S8) {
d614 1
a614 1
         ASSERT(stencilRb->Format == MESA_FORMAT_Z24_S8);
d633 1
a633 1
_mesa_promote_stencil(struct gl_context *ctx, struct gl_renderbuffer *stencilRb)
d640 1
a640 1
   ASSERT(stencilRb->Format == MESA_FORMAT_S8);
d658 3
a660 1
   free(data);
@

