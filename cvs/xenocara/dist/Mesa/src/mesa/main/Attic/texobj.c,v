head	1.13;
access;
symbols
	OPENBSD_5_8:1.12.0.4
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	v10_2_9:1.1.1.8
	v10_4_3:1.1.1.7
	v10_2_7:1.1.1.6
	OPENBSD_5_6:1.10.0.2
	OPENBSD_5_6_BASE:1.10
	v10_2_3:1.1.1.6
	OPENBSD_5_5:1.9.0.2
	OPENBSD_5_5_BASE:1.9
	v9_2_5:1.1.1.5
	v9_2_3:1.1.1.5
	v9_2_2:1.1.1.5
	v9_2_1:1.1.1.5
	v9_2_0:1.1.1.5
	OPENBSD_5_4:1.8.0.4
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.2
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.7.0.4
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.6.0.6
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.4
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.5.0.4
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.2
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.4.0.2
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.3.0.2
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_3:1.2.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2015.12.23.05.17.53;	author jsg;	state dead;
branches;
next	1.12;
commitid	TnlogFl9nOv2eaRf;

1.12
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.11;
commitid	4ry2gvZGMXkCUD2n;

1.11
date	2015.01.25.14.41.22;	author jsg;	state Exp;
branches;
next	1.10;
commitid	mcxB0JvoI9gTDYXU;

1.10
date	2014.07.09.21.09.00;	author jsg;	state Exp;
branches;
next	1.9;
commitid	WPD6rgPryPkvXOr9;

1.9
date	2013.09.05.14.06.32;	author jsg;	state Exp;
branches;
next	1.8;

1.8
date	2012.08.17.13.58.19;	author mpi;	state Exp;
branches;
next	1.7;

1.7
date	2011.10.23.13.37.44;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.05.22.20.06.31;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2009.05.17.20.26.42;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2008.11.02.14.58.21;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.05.31.16.36.48;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.02.12.21.09.27;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.50.26;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.50.26;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.56.40;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.31.25;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.47;	author matthieu;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.09.05.13.16.54;	author jsg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.07.09.20.35.06;	author jsg;	state Exp;
branches;
next	1.1.1.7;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.7
date	2015.01.25.14.13.00;	author jsg;	state Exp;
branches;
next	1.1.1.8;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.8
date	2015.02.20.22.50.05;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.13
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**
 * \file texobj.c
 * Texture object management.
 */

/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */


#include "bufferobj.h"
#include "colortab.h"
#include "context.h"
#include "enums.h"
#include "fbobject.h"
#include "formats.h"
#include "hash.h"
#include "imports.h"
#include "macros.h"
#include "teximage.h"
#include "texobj.h"
#include "texstate.h"
#include "mtypes.h"
#include "program/prog_instruction.h"



/**********************************************************************/
/** \name Internal functions */
/*@@{*/


/**
 * Return the gl_texture_object for a given ID.
 */
struct gl_texture_object *
_mesa_lookup_texture(struct gl_context *ctx, GLuint id)
{
   return (struct gl_texture_object *)
      _mesa_HashLookup(ctx->Shared->TexObjects, id);
}


void
_mesa_begin_texture_lookups(struct gl_context *ctx)
{
   _mesa_HashLockMutex(ctx->Shared->TexObjects);
}


void
_mesa_end_texture_lookups(struct gl_context *ctx)
{
   _mesa_HashUnlockMutex(ctx->Shared->TexObjects);
}


struct gl_texture_object *
_mesa_lookup_texture_locked(struct gl_context *ctx, GLuint id)
{
   return (struct gl_texture_object *)
      _mesa_HashLookupLocked(ctx->Shared->TexObjects, id);
}


/**
 * Allocate and initialize a new texture object.  But don't put it into the
 * texture object hash table.
 *
 * Called via ctx->Driver.NewTextureObject, unless overridden by a device
 * driver.
 * 
 * \param shared the shared GL state structure to contain the texture object
 * \param name integer name for the texture object
 * \param target either GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D,
 * GL_TEXTURE_CUBE_MAP_ARB or GL_TEXTURE_RECTANGLE_NV.  zero is ok for the sake
 * of GenTextures()
 *
 * \return pointer to new texture object.
 */
struct gl_texture_object *
_mesa_new_texture_object( struct gl_context *ctx, GLuint name, GLenum target )
{
   struct gl_texture_object *obj;
   (void) ctx;
   obj = MALLOC_STRUCT(gl_texture_object);
   _mesa_initialize_texture_object(ctx, obj, name, target);
   return obj;
}


/**
 * Initialize a new texture object to default values.
 * \param obj  the texture object
 * \param name  the texture name
 * \param target  the texture target
 */
void
_mesa_initialize_texture_object( struct gl_context *ctx,
                                 struct gl_texture_object *obj,
                                 GLuint name, GLenum target )
{
   ASSERT(target == 0 ||
          target == GL_TEXTURE_1D ||
          target == GL_TEXTURE_2D ||
          target == GL_TEXTURE_3D ||
          target == GL_TEXTURE_CUBE_MAP_ARB ||
          target == GL_TEXTURE_RECTANGLE_NV ||
          target == GL_TEXTURE_1D_ARRAY_EXT ||
          target == GL_TEXTURE_2D_ARRAY_EXT ||
          target == GL_TEXTURE_EXTERNAL_OES ||
          target == GL_TEXTURE_CUBE_MAP_ARRAY ||
          target == GL_TEXTURE_BUFFER ||
          target == GL_TEXTURE_2D_MULTISAMPLE ||
          target == GL_TEXTURE_2D_MULTISAMPLE_ARRAY);

   memset(obj, 0, sizeof(*obj));
   /* init the non-zero fields */
   mtx_init(&obj->Mutex, mtx_plain);
   obj->RefCount = 1;
   obj->Name = name;
   obj->Target = target;
   obj->Priority = 1.0F;
   obj->BaseLevel = 0;
   obj->MaxLevel = 1000;

   /* must be one; no support for (YUV) planes in separate buffers */
   obj->RequiredTextureImageUnits = 1;

   /* sampler state */
   if (target == GL_TEXTURE_RECTANGLE_NV ||
       target == GL_TEXTURE_EXTERNAL_OES) {
      obj->Sampler.WrapS = GL_CLAMP_TO_EDGE;
      obj->Sampler.WrapT = GL_CLAMP_TO_EDGE;
      obj->Sampler.WrapR = GL_CLAMP_TO_EDGE;
      obj->Sampler.MinFilter = GL_LINEAR;
   }
   else {
      obj->Sampler.WrapS = GL_REPEAT;
      obj->Sampler.WrapT = GL_REPEAT;
      obj->Sampler.WrapR = GL_REPEAT;
      obj->Sampler.MinFilter = GL_NEAREST_MIPMAP_LINEAR;
   }
   obj->Sampler.MagFilter = GL_LINEAR;
   obj->Sampler.MinLod = -1000.0;
   obj->Sampler.MaxLod = 1000.0;
   obj->Sampler.LodBias = 0.0;
   obj->Sampler.MaxAnisotropy = 1.0;
   obj->Sampler.CompareMode = GL_NONE;         /* ARB_shadow */
   obj->Sampler.CompareFunc = GL_LEQUAL;       /* ARB_shadow */
   obj->DepthMode = ctx->API == API_OPENGL_CORE ? GL_RED : GL_LUMINANCE;
   obj->StencilSampling = false;
   obj->Sampler.CubeMapSeamless = GL_FALSE;
   obj->Swizzle[0] = GL_RED;
   obj->Swizzle[1] = GL_GREEN;
   obj->Swizzle[2] = GL_BLUE;
   obj->Swizzle[3] = GL_ALPHA;
   obj->_Swizzle = SWIZZLE_NOOP;
   obj->Sampler.sRGBDecode = GL_DECODE_EXT;
   obj->BufferObjectFormat = GL_R8;
   obj->_BufferObjectFormat = MESA_FORMAT_R_UNORM8;
   obj->ImageFormatCompatibilityType = GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE;
}


/**
 * Some texture initialization can't be finished until we know which
 * target it's getting bound to (GL_TEXTURE_1D/2D/etc).
 */
static void
finish_texture_init(struct gl_context *ctx, GLenum target,
                    struct gl_texture_object *obj)
{
   GLenum filter = GL_LINEAR;
   assert(obj->Target == 0);

   switch (target) {
      case GL_TEXTURE_2D_MULTISAMPLE:
      case GL_TEXTURE_2D_MULTISAMPLE_ARRAY:
         filter = GL_NEAREST;
         /* fallthrough */

      case GL_TEXTURE_RECTANGLE_NV:
      case GL_TEXTURE_EXTERNAL_OES:
         /* have to init wrap and filter state here - kind of klunky */
         obj->Sampler.WrapS = GL_CLAMP_TO_EDGE;
         obj->Sampler.WrapT = GL_CLAMP_TO_EDGE;
         obj->Sampler.WrapR = GL_CLAMP_TO_EDGE;
         obj->Sampler.MinFilter = filter;
         obj->Sampler.MagFilter = filter;
         if (ctx->Driver.TexParameter) {
            static const GLfloat fparam_wrap[1] = {(GLfloat) GL_CLAMP_TO_EDGE};
            const GLfloat fparam_filter[1] = {(GLfloat) filter};
            ctx->Driver.TexParameter(ctx, obj, GL_TEXTURE_WRAP_S, fparam_wrap);
            ctx->Driver.TexParameter(ctx, obj, GL_TEXTURE_WRAP_T, fparam_wrap);
            ctx->Driver.TexParameter(ctx, obj, GL_TEXTURE_WRAP_R, fparam_wrap);
            ctx->Driver.TexParameter(ctx, obj,
                  GL_TEXTURE_MIN_FILTER, fparam_filter);
            ctx->Driver.TexParameter(ctx, obj,
                  GL_TEXTURE_MAG_FILTER, fparam_filter);
         }
         break;

      default:
         /* nothing needs done */
         break;
   }
}


/**
 * Deallocate a texture object struct.  It should have already been
 * removed from the texture object pool.
 * Called via ctx->Driver.DeleteTexture() if not overriden by a driver.
 *
 * \param shared the shared GL state to which the object belongs.
 * \param texObj the texture object to delete.
 */
void
_mesa_delete_texture_object(struct gl_context *ctx,
                            struct gl_texture_object *texObj)
{
   GLuint i, face;

   /* Set Target to an invalid value.  With some assertions elsewhere
    * we can try to detect possible use of deleted textures.
    */
   texObj->Target = 0x99;

   /* free the texture images */
   for (face = 0; face < 6; face++) {
      for (i = 0; i < MAX_TEXTURE_LEVELS; i++) {
         if (texObj->Image[face][i]) {
            ctx->Driver.DeleteTextureImage(ctx, texObj->Image[face][i]);
         }
      }
   }

   _mesa_reference_buffer_object(ctx, &texObj->BufferObject, NULL);

   /* destroy the mutex -- it may have allocated memory (eg on bsd) */
   mtx_destroy(&texObj->Mutex);

   free(texObj->Label);

   /* free this object */
   free(texObj);
}



/**
 * Copy texture object state from one texture object to another.
 * Use for glPush/PopAttrib.
 *
 * \param dest destination texture object.
 * \param src source texture object.
 */
void
_mesa_copy_texture_object( struct gl_texture_object *dest,
                           const struct gl_texture_object *src )
{
   dest->Target = src->Target;
   dest->TargetIndex = src->TargetIndex;
   dest->Name = src->Name;
   dest->Priority = src->Priority;
   dest->Sampler.BorderColor.f[0] = src->Sampler.BorderColor.f[0];
   dest->Sampler.BorderColor.f[1] = src->Sampler.BorderColor.f[1];
   dest->Sampler.BorderColor.f[2] = src->Sampler.BorderColor.f[2];
   dest->Sampler.BorderColor.f[3] = src->Sampler.BorderColor.f[3];
   dest->Sampler.WrapS = src->Sampler.WrapS;
   dest->Sampler.WrapT = src->Sampler.WrapT;
   dest->Sampler.WrapR = src->Sampler.WrapR;
   dest->Sampler.MinFilter = src->Sampler.MinFilter;
   dest->Sampler.MagFilter = src->Sampler.MagFilter;
   dest->Sampler.MinLod = src->Sampler.MinLod;
   dest->Sampler.MaxLod = src->Sampler.MaxLod;
   dest->Sampler.LodBias = src->Sampler.LodBias;
   dest->BaseLevel = src->BaseLevel;
   dest->MaxLevel = src->MaxLevel;
   dest->Sampler.MaxAnisotropy = src->Sampler.MaxAnisotropy;
   dest->Sampler.CompareMode = src->Sampler.CompareMode;
   dest->Sampler.CompareFunc = src->Sampler.CompareFunc;
   dest->Sampler.CubeMapSeamless = src->Sampler.CubeMapSeamless;
   dest->DepthMode = src->DepthMode;
   dest->StencilSampling = src->StencilSampling;
   dest->Sampler.sRGBDecode = src->Sampler.sRGBDecode;
   dest->_MaxLevel = src->_MaxLevel;
   dest->_MaxLambda = src->_MaxLambda;
   dest->GenerateMipmap = src->GenerateMipmap;
   dest->_BaseComplete = src->_BaseComplete;
   dest->_MipmapComplete = src->_MipmapComplete;
   COPY_4V(dest->Swizzle, src->Swizzle);
   dest->_Swizzle = src->_Swizzle;

   dest->RequiredTextureImageUnits = src->RequiredTextureImageUnits;
}


/**
 * Free all texture images of the given texture object.
 *
 * \param ctx GL context.
 * \param t texture object.
 *
 * \sa _mesa_clear_texture_image().
 */
void
_mesa_clear_texture_object(struct gl_context *ctx,
                           struct gl_texture_object *texObj)
{
   GLuint i, j;

   if (texObj->Target == 0)
      return;

   for (i = 0; i < MAX_FACES; i++) {
      for (j = 0; j < MAX_TEXTURE_LEVELS; j++) {
         struct gl_texture_image *texImage = texObj->Image[i][j];
         if (texImage)
            _mesa_clear_texture_image(ctx, texImage);
      }
   }
}


/**
 * Check if the given texture object is valid by examining its Target field.
 * For debugging only.
 */
static GLboolean
valid_texture_object(const struct gl_texture_object *tex)
{
   switch (tex->Target) {
   case 0:
   case GL_TEXTURE_1D:
   case GL_TEXTURE_2D:
   case GL_TEXTURE_3D:
   case GL_TEXTURE_CUBE_MAP_ARB:
   case GL_TEXTURE_RECTANGLE_NV:
   case GL_TEXTURE_1D_ARRAY_EXT:
   case GL_TEXTURE_2D_ARRAY_EXT:
   case GL_TEXTURE_BUFFER:
   case GL_TEXTURE_EXTERNAL_OES:
   case GL_TEXTURE_CUBE_MAP_ARRAY:
   case GL_TEXTURE_2D_MULTISAMPLE:
   case GL_TEXTURE_2D_MULTISAMPLE_ARRAY:
      return GL_TRUE;
   case 0x99:
      _mesa_problem(NULL, "invalid reference to a deleted texture object");
      return GL_FALSE;
   default:
      _mesa_problem(NULL, "invalid texture object Target 0x%x, Id = %u",
                    tex->Target, tex->Name);
      return GL_FALSE;
   }
}


/**
 * Reference (or unreference) a texture object.
 * If '*ptr', decrement *ptr's refcount (and delete if it becomes zero).
 * If 'tex' is non-null, increment its refcount.
 * This is normally only called from the _mesa_reference_texobj() macro
 * when there's a real pointer change.
 */
void
_mesa_reference_texobj_(struct gl_texture_object **ptr,
                        struct gl_texture_object *tex)
{
   assert(ptr);

   if (*ptr) {
      /* Unreference the old texture */
      GLboolean deleteFlag = GL_FALSE;
      struct gl_texture_object *oldTex = *ptr;

      ASSERT(valid_texture_object(oldTex));
      (void) valid_texture_object; /* silence warning in release builds */

      mtx_lock(&oldTex->Mutex);
      ASSERT(oldTex->RefCount > 0);
      oldTex->RefCount--;

      deleteFlag = (oldTex->RefCount == 0);
      mtx_unlock(&oldTex->Mutex);

      if (deleteFlag) {
         GET_CURRENT_CONTEXT(ctx);
         if (ctx)
            ctx->Driver.DeleteTexture(ctx, oldTex);
         else
            _mesa_problem(NULL, "Unable to delete texture, no context");
      }

      *ptr = NULL;
   }
   assert(!*ptr);

   if (tex) {
      /* reference new texture */
      ASSERT(valid_texture_object(tex));
      mtx_lock(&tex->Mutex);
      if (tex->RefCount == 0) {
         /* this texture's being deleted (look just above) */
         /* Not sure this can every really happen.  Warn if it does. */
         _mesa_problem(NULL, "referencing deleted texture object");
         *ptr = NULL;
      }
      else {
         tex->RefCount++;
         *ptr = tex;
      }
      mtx_unlock(&tex->Mutex);
   }
}


enum base_mipmap { BASE, MIPMAP };


/**
 * Mark a texture object as incomplete.  There are actually three kinds of
 * (in)completeness:
 * 1. "base incomplete": the base level of the texture is invalid so no
 *    texturing is possible.
 * 2. "mipmap incomplete": a non-base level of the texture is invalid so
 *    mipmap filtering isn't possible, but non-mipmap filtering is.
 * 3. "texture incompleteness": some combination of texture state and
 *    sampler state renders the texture incomplete.
 *
 * \param t  texture object
 * \param bm  either BASE or MIPMAP to indicate what's incomplete
 * \param fmt...  string describing why it's incomplete (for debugging).
 */
static void
incomplete(struct gl_texture_object *t, enum base_mipmap bm,
           const char *fmt, ...)
{
   if (MESA_DEBUG_FLAGS & DEBUG_INCOMPLETE_TEXTURE) {
      va_list args;
      char s[100];

      va_start(args, fmt);
      vsnprintf(s, sizeof(s), fmt, args);
      va_end(args);

      _mesa_debug(NULL, "Texture Obj %d incomplete because: %s\n", t->Name, s);
   }

   if (bm == BASE)
      t->_BaseComplete = GL_FALSE;
   t->_MipmapComplete = GL_FALSE;
}


/**
 * Examine a texture object to determine if it is complete.
 *
 * The gl_texture_object::Complete flag will be set to GL_TRUE or GL_FALSE
 * accordingly.
 *
 * \param ctx GL context.
 * \param t texture object.
 *
 * According to the texture target, verifies that each of the mipmaps is
 * present and has the expected size.
 */
void
_mesa_test_texobj_completeness( const struct gl_context *ctx,
                                struct gl_texture_object *t )
{
   const GLint baseLevel = t->BaseLevel;
   const struct gl_texture_image *baseImage;
   GLint maxLevels = 0;

   /* We'll set these to FALSE if tests fail below */
   t->_BaseComplete = GL_TRUE;
   t->_MipmapComplete = GL_TRUE;

   if (t->Target == GL_TEXTURE_BUFFER) {
      /* Buffer textures are always considered complete.  The obvious case where
       * they would be incomplete (no BO attached) is actually specced to be
       * undefined rendering results.
       */
      return;
   }

   /* Detect cases where the application set the base level to an invalid
    * value.
    */
   if ((baseLevel < 0) || (baseLevel >= MAX_TEXTURE_LEVELS)) {
      incomplete(t, BASE, "base level = %d is invalid", baseLevel);
      return;
   }

   if (t->MaxLevel < baseLevel) {
      incomplete(t, MIPMAP, "MAX_LEVEL (%d) < BASE_LEVEL (%d)",
		 t->MaxLevel, baseLevel);
      return;
   }

   baseImage = t->Image[0][baseLevel];

   /* Always need the base level image */
   if (!baseImage) {
      incomplete(t, BASE, "Image[baseLevel=%d] == NULL", baseLevel);
      return;
   }

   /* Check width/height/depth for zero */
   if (baseImage->Width == 0 ||
       baseImage->Height == 0 ||
       baseImage->Depth == 0) {
      incomplete(t, BASE, "texture width or height or depth = 0");
      return;
   }

   /* Check if the texture values are integer */
   {
      GLenum datatype = _mesa_get_format_datatype(baseImage->TexFormat);
      t->_IsIntegerFormat = datatype == GL_INT || datatype == GL_UNSIGNED_INT;
   }

   /* Compute _MaxLevel (the maximum mipmap level we'll sample from given the
    * mipmap image sizes and GL_TEXTURE_MAX_LEVEL state).
    */
   switch (t->Target) {
   case GL_TEXTURE_1D:
   case GL_TEXTURE_1D_ARRAY_EXT:
      maxLevels = ctx->Const.MaxTextureLevels;
      break;
   case GL_TEXTURE_2D:
   case GL_TEXTURE_2D_ARRAY_EXT:
      maxLevels = ctx->Const.MaxTextureLevels;
      break;
   case GL_TEXTURE_3D:
      maxLevels = ctx->Const.Max3DTextureLevels;
      break;
   case GL_TEXTURE_CUBE_MAP_ARB:
   case GL_TEXTURE_CUBE_MAP_ARRAY:
      maxLevels = ctx->Const.MaxCubeTextureLevels;
      break;
   case GL_TEXTURE_RECTANGLE_NV:
   case GL_TEXTURE_BUFFER:
   case GL_TEXTURE_EXTERNAL_OES:
   case GL_TEXTURE_2D_MULTISAMPLE:
   case GL_TEXTURE_2D_MULTISAMPLE_ARRAY:
      maxLevels = 1;  /* no mipmapping */
      break;
   default:
      _mesa_problem(ctx, "Bad t->Target in _mesa_test_texobj_completeness");
      return;
   }

   ASSERT(maxLevels > 0);

   t->_MaxLevel = MIN3(t->MaxLevel,
                       /* 'p' in the GL spec */
                       (int) (baseLevel + baseImage->MaxNumLevels - 1),
                       /* 'q' in the GL spec */
                       maxLevels - 1);

   if (t->Immutable) {
      /* Adjust max level for views: the data store may have more levels than
       * the view exposes.
       */
      t->_MaxLevel = MIN2(t->_MaxLevel, t->NumLevels - 1);
   }

   /* Compute _MaxLambda = q - p in the spec used during mipmapping */
   t->_MaxLambda = (GLfloat) (t->_MaxLevel - baseLevel);

   if (t->Immutable) {
      /* This texture object was created with glTexStorage1/2/3D() so we
       * know that all the mipmap levels are the right size and all cube
       * map faces are the same size.
       * We don't need to do any of the additional checks below.
       */
      return;
   }

   if (t->Target == GL_TEXTURE_CUBE_MAP_ARB) {
      /* Make sure that all six cube map level 0 images are the same size.
       * Note:  we know that the image's width==height (we enforce that
       * at glTexImage time) so we only need to test the width here.
       */
      GLuint face;
      assert(baseImage->Width2 == baseImage->Height);
      for (face = 1; face < 6; face++) {
         assert(t->Image[face][baseLevel] == NULL ||
                t->Image[face][baseLevel]->Width2 ==
                t->Image[face][baseLevel]->Height2);
         if (t->Image[face][baseLevel] == NULL ||
             t->Image[face][baseLevel]->Width2 != baseImage->Width2) {
            incomplete(t, BASE, "Cube face missing or mismatched size");
            return;
         }
      }
   }

   /*
    * Do mipmap consistency checking.
    * Note: we don't care about the current texture sampler state here.
    * To determine texture completeness we'll either look at _BaseComplete
    * or _MipmapComplete depending on the current minification filter mode.
    */
   {
      GLint i;
      const GLint minLevel = baseLevel;
      const GLint maxLevel = t->_MaxLevel;
      const GLuint numFaces = _mesa_num_tex_faces(t->Target);
      GLuint width, height, depth, face;

      if (minLevel > maxLevel) {
         incomplete(t, MIPMAP, "minLevel > maxLevel");
         return;
      }

      /* Get the base image's dimensions */
      width = baseImage->Width2;
      height = baseImage->Height2;
      depth = baseImage->Depth2;

      /* Note: this loop will be a no-op for RECT, BUFFER, EXTERNAL,
       * MULTISAMPLE and MULTISAMPLE_ARRAY textures
       */
      for (i = baseLevel + 1; i < maxLevels; i++) {
         /* Compute the expected size of image at level[i] */
         if (width > 1) {
            width /= 2;
         }
         if (height > 1 && t->Target != GL_TEXTURE_1D_ARRAY) {
            height /= 2;
         }
         if (depth > 1 && t->Target != GL_TEXTURE_2D_ARRAY && t->Target != GL_TEXTURE_CUBE_MAP_ARRAY) {
            depth /= 2;
         }

         /* loop over cube faces (or single face otherwise) */
         for (face = 0; face < numFaces; face++) {
            if (i >= minLevel && i <= maxLevel) {
               const struct gl_texture_image *img = t->Image[face][i];

               if (!img) {
                  incomplete(t, MIPMAP, "TexImage[%d] is missing", i);
                  return;
               }
               if (img->TexFormat != baseImage->TexFormat) {
                  incomplete(t, MIPMAP, "Format[i] != Format[baseLevel]");
                  return;
               }
               if (img->Border != baseImage->Border) {
                  incomplete(t, MIPMAP, "Border[i] != Border[baseLevel]");
                  return;
               }
               if (img->Width2 != width) {
                  incomplete(t, MIPMAP, "TexImage[%d] bad width %u", i, img->Width2);
                  return;
               }
               if (img->Height2 != height) {
                  incomplete(t, MIPMAP, "TexImage[%d] bad height %u", i, img->Height2);
                  return;
               }
               if (img->Depth2 != depth) {
                  incomplete(t, MIPMAP, "TexImage[%d] bad depth %u", i, img->Depth2);
                  return;
               }

               /* Extra checks for cube textures */
               if (face > 0) {
                  /* check that cube faces are the same size */
                  if (img->Width2 != t->Image[0][i]->Width2 || 
                      img->Height2 != t->Image[0][i]->Height2) {
		     incomplete(t, MIPMAP, "CubeMap Image[n][i] bad size");
		     return;
		  }
               }
            }
         }
         
         if (width == 1 && height == 1 && depth == 1) {
            return;  /* found smallest needed mipmap, all done! */
         }
      }
   }
}


/**
 * Check if the given cube map texture is "cube complete" as defined in
 * the OpenGL specification.
 */
GLboolean
_mesa_cube_complete(const struct gl_texture_object *texObj)
{
   const GLint baseLevel = texObj->BaseLevel;
   const struct gl_texture_image *img0, *img;
   GLuint face;

   if (texObj->Target != GL_TEXTURE_CUBE_MAP)
      return GL_FALSE;

   if ((baseLevel < 0) || (baseLevel >= MAX_TEXTURE_LEVELS))
      return GL_FALSE;

   /* check first face */
   img0 = texObj->Image[0][baseLevel];
   if (!img0 ||
       img0->Width < 1 ||
       img0->Width != img0->Height)
      return GL_FALSE;

   /* check remaining faces vs. first face */
   for (face = 1; face < 6; face++) {
      img = texObj->Image[face][baseLevel];
      if (!img ||
          img->Width != img0->Width ||
          img->Height != img0->Height ||
          img->TexFormat != img0->TexFormat)
         return GL_FALSE;
   }

   return GL_TRUE;
}


/**
 * Mark a texture object dirty.  It forces the object to be incomplete
 * and forces the context to re-validate its state.
 *
 * \param ctx GL context.
 * \param texObj texture object.
 */
void
_mesa_dirty_texobj(struct gl_context *ctx, struct gl_texture_object *texObj)
{
   texObj->_BaseComplete = GL_FALSE;
   texObj->_MipmapComplete = GL_FALSE;
   ctx->NewState |= _NEW_TEXTURE;
}


/**
 * Return pointer to a default/fallback texture of the given type/target.
 * The texture is an RGBA texture with all texels = (0,0,0,1).
 * That's the value a GLSL sampler should get when sampling from an
 * incomplete texture.
 */
struct gl_texture_object *
_mesa_get_fallback_texture(struct gl_context *ctx, gl_texture_index tex)
{
   if (!ctx->Shared->FallbackTex[tex]) {
      /* create fallback texture now */
      const GLsizei width = 1, height = 1, depth = 1;
      GLubyte texel[4];
      struct gl_texture_object *texObj;
      struct gl_texture_image *texImage;
      mesa_format texFormat;
      GLuint dims, face, numFaces = 1;
      GLenum target;

      texel[0] =
      texel[1] =
      texel[2] = 0x0;
      texel[3] = 0xff;

      switch (tex) {
      case TEXTURE_2D_ARRAY_INDEX:
         dims = 3;
         target = GL_TEXTURE_2D_ARRAY;
         break;
      case TEXTURE_1D_ARRAY_INDEX:
         dims = 2;
         target = GL_TEXTURE_1D_ARRAY;
         break;
      case TEXTURE_CUBE_INDEX:
         dims = 2;
         target = GL_TEXTURE_CUBE_MAP;
         numFaces = 6;
         break;
      case TEXTURE_3D_INDEX:
         dims = 3;
         target = GL_TEXTURE_3D;
         break;
      case TEXTURE_RECT_INDEX:
         dims = 2;
         target = GL_TEXTURE_RECTANGLE;
         break;
      case TEXTURE_2D_INDEX:
         dims = 2;
         target = GL_TEXTURE_2D;
         break;
      case TEXTURE_1D_INDEX:
         dims = 1;
         target = GL_TEXTURE_1D;
         break;
      case TEXTURE_BUFFER_INDEX:
         dims = 0;
         target = GL_TEXTURE_BUFFER;
         break;
      case TEXTURE_CUBE_ARRAY_INDEX:
         dims = 3;
         target = GL_TEXTURE_CUBE_MAP_ARRAY;
         break;
      case TEXTURE_EXTERNAL_INDEX:
         dims = 2;
         target = GL_TEXTURE_EXTERNAL_OES;
         break;
      case TEXTURE_2D_MULTISAMPLE_INDEX:
         dims = 2;
         target = GL_TEXTURE_2D_MULTISAMPLE;
         break;
      case TEXTURE_2D_MULTISAMPLE_ARRAY_INDEX:
         dims = 3;
         target = GL_TEXTURE_2D_MULTISAMPLE_ARRAY;
         break;
      default:
         /* no-op */
         return NULL;
      }

      /* create texture object */
      texObj = ctx->Driver.NewTextureObject(ctx, 0, target);
      if (!texObj)
         return NULL;

      assert(texObj->RefCount == 1);
      texObj->Sampler.MinFilter = GL_NEAREST;
      texObj->Sampler.MagFilter = GL_NEAREST;

      texFormat = ctx->Driver.ChooseTextureFormat(ctx, target,
                                                  GL_RGBA, GL_RGBA,
                                                  GL_UNSIGNED_BYTE);

      /* need a loop here just for cube maps */
      for (face = 0; face < numFaces; face++) {
         GLenum faceTarget;

         if (target == GL_TEXTURE_CUBE_MAP)
            faceTarget = GL_TEXTURE_CUBE_MAP_POSITIVE_X + face;
         else
            faceTarget = target;

         /* initialize level[0] texture image */
         texImage = _mesa_get_tex_image(ctx, texObj, faceTarget, 0);

         _mesa_init_teximage_fields(ctx, texImage,
                                    width,
                                    (dims > 1) ? height : 1,
                                    (dims > 2) ? depth : 1,
                                    0, /* border */
                                    GL_RGBA, texFormat);

         ctx->Driver.TexImage(ctx, dims, texImage,
                              GL_RGBA, GL_UNSIGNED_BYTE, texel,
                              &ctx->DefaultPacking);
      }

      _mesa_test_texobj_completeness(ctx, texObj);
      assert(texObj->_BaseComplete);
      assert(texObj->_MipmapComplete);

      ctx->Shared->FallbackTex[tex] = texObj;
   }
   return ctx->Shared->FallbackTex[tex];
}


/**
 * Compute the size of the given texture object, in bytes.
 */
static GLuint
texture_size(const struct gl_texture_object *texObj)
{
   const GLuint numFaces = _mesa_num_tex_faces(texObj->Target);
   GLuint face, level, size = 0;

   for (face = 0; face < numFaces; face++) {
      for (level = 0; level < MAX_TEXTURE_LEVELS; level++) {
         const struct gl_texture_image *img = texObj->Image[face][level];
         if (img) {
            GLuint sz = _mesa_format_image_size(img->TexFormat, img->Width,
                                                img->Height, img->Depth);
            size += sz;
         }
      }
   }

   return size;
}


/**
 * Callback called from _mesa_HashWalk()
 */
static void
count_tex_size(GLuint key, void *data, void *userData)
{
   const struct gl_texture_object *texObj =
      (const struct gl_texture_object *) data;
   GLuint *total = (GLuint *) userData;

   (void) key;

   *total = *total + texture_size(texObj);
}


/**
 * Compute total size (in bytes) of all textures for the given context.
 * For debugging purposes.
 */
GLuint
_mesa_total_texture_memory(struct gl_context *ctx)
{
   GLuint tgt, total = 0;

   _mesa_HashWalk(ctx->Shared->TexObjects, count_tex_size, &total);

   /* plus, the default texture objects */
   for (tgt = 0; tgt < NUM_TEXTURE_TARGETS; tgt++) {
      total += texture_size(ctx->Shared->DefaultTex[tgt]);
   }

   return total;
}

static struct gl_texture_object *
invalidate_tex_image_error_check(struct gl_context *ctx, GLuint texture,
                                 GLint level, const char *name)
{
   /* The GL_ARB_invalidate_subdata spec says:
    *
    *     "If <texture> is zero or is not the name of a texture, the error
    *     INVALID_VALUE is generated."
    *
    * This performs the error check in a different order than listed in the
    * spec.  We have to get the texture object before we can validate the
    * other parameters against values in the texture object.
    */
   struct gl_texture_object *const t = _mesa_lookup_texture(ctx, texture);
   if (texture == 0 || t == NULL) {
      _mesa_error(ctx, GL_INVALID_VALUE, "%s(texture)", name);
      return NULL;
   }

   /* The GL_ARB_invalidate_subdata spec says:
    *
    *     "If <level> is less than zero or greater than the base 2 logarithm
    *     of the maximum texture width, height, or depth, the error
    *     INVALID_VALUE is generated."
    */
   if (level < 0 || level > t->MaxLevel) {
      _mesa_error(ctx, GL_INVALID_VALUE, "%s(level)", name);
      return NULL;
   }

   /* The GL_ARB_invalidate_subdata spec says:
    *
    *     "If the target of <texture> is TEXTURE_RECTANGLE, TEXTURE_BUFFER,
    *     TEXTURE_2D_MULTISAMPLE, or TEXTURE_2D_MULTISAMPLE_ARRAY, and <level>
    *     is not zero, the error INVALID_VALUE is generated."
    */
   if (level != 0) {
      switch (t->Target) {
      case GL_TEXTURE_RECTANGLE:
      case GL_TEXTURE_BUFFER:
      case GL_TEXTURE_2D_MULTISAMPLE:
      case GL_TEXTURE_2D_MULTISAMPLE_ARRAY:
         _mesa_error(ctx, GL_INVALID_VALUE, "%s(level)", name);
         return NULL;

      default:
         break;
      }
   }

   return t;
}

/*@@}*/


/***********************************************************************/
/** \name API functions */
/*@@{*/


/**
 * Generate texture names.
 *
 * \param n number of texture names to be generated.
 * \param textures an array in which will hold the generated texture names.
 *
 * \sa glGenTextures().
 *
 * Calls _mesa_HashFindFreeKeyBlock() to find a block of free texture
 * IDs which are stored in \p textures.  Corresponding empty texture
 * objects are also generated.
 */ 
void GLAPIENTRY
_mesa_GenTextures( GLsizei n, GLuint *textures )
{
   GET_CURRENT_CONTEXT(ctx);
   GLuint first;
   GLint i;

   if (MESA_VERBOSE & (VERBOSE_API|VERBOSE_TEXTURE))
      _mesa_debug(ctx, "glGenTextures %d\n", n);

   if (n < 0) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glGenTextures" );
      return;
   }

   if (!textures)
      return;

   /*
    * This must be atomic (generation and allocation of texture IDs)
    */
   mtx_lock(&ctx->Shared->Mutex);

   first = _mesa_HashFindFreeKeyBlock(ctx->Shared->TexObjects, n);

   /* Allocate new, empty texture objects */
   for (i = 0; i < n; i++) {
      struct gl_texture_object *texObj;
      GLuint name = first + i;
      GLenum target = 0;
      texObj = ctx->Driver.NewTextureObject(ctx, name, target);
      if (!texObj) {
         mtx_unlock(&ctx->Shared->Mutex);
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glGenTextures");
         return;
      }

      /* insert into hash table */
      _mesa_HashInsert(ctx->Shared->TexObjects, texObj->Name, texObj);

      textures[i] = name;
   }

   mtx_unlock(&ctx->Shared->Mutex);
}


/**
 * Check if the given texture object is bound to the current draw or
 * read framebuffer.  If so, Unbind it.
 */
static void
unbind_texobj_from_fbo(struct gl_context *ctx,
                       struct gl_texture_object *texObj)
{
   bool progress = false;

   /* Section 4.4.2 (Attaching Images to Framebuffer Objects), subsection
    * "Attaching Texture Images to a Framebuffer," of the OpenGL 3.1 spec
    * says:
    *
    *     "If a texture object is deleted while its image is attached to one
    *     or more attachment points in the currently bound framebuffer, then
    *     it is as if FramebufferTexture* had been called, with a texture of
    *     zero, for each attachment point to which this image was attached in
    *     the currently bound framebuffer. In other words, this texture image
    *     is first detached from all attachment points in the currently bound
    *     framebuffer. Note that the texture image is specifically not
    *     detached from any other framebuffer objects. Detaching the texture
    *     image from any other framebuffer objects is the responsibility of
    *     the application."
    */
   if (_mesa_is_user_fbo(ctx->DrawBuffer)) {
      progress = _mesa_detach_renderbuffer(ctx, ctx->DrawBuffer, texObj);
   }
   if (_mesa_is_user_fbo(ctx->ReadBuffer)
       && ctx->ReadBuffer != ctx->DrawBuffer) {
      progress = _mesa_detach_renderbuffer(ctx, ctx->ReadBuffer, texObj)
         || progress;
   }

   if (progress)
      /* Vertices are already flushed by _mesa_DeleteTextures */
      ctx->NewState |= _NEW_BUFFERS;
}


/**
 * Check if the given texture object is bound to any texture image units and
 * unbind it if so (revert to default textures).
 */
static void
unbind_texobj_from_texunits(struct gl_context *ctx,
                            struct gl_texture_object *texObj)
{
   const gl_texture_index index = texObj->TargetIndex;
   GLuint u;

   if (texObj->Target == 0)
      return;

   for (u = 0; u < ctx->Texture.NumCurrentTexUsed; u++) {
      struct gl_texture_unit *unit = &ctx->Texture.Unit[u];

      if (texObj == unit->CurrentTex[index]) {
         /* Bind the default texture for this unit/target */
         _mesa_reference_texobj(&unit->CurrentTex[index],
                                ctx->Shared->DefaultTex[index]);
         unit->_BoundTextures &= ~(1 << index);
      }
   }
}


/**
 * Check if the given texture object is bound to any shader image unit
 * and unbind it if that's the case.
 */
static void
unbind_texobj_from_image_units(struct gl_context *ctx,
                               struct gl_texture_object *texObj)
{
   GLuint i;

   for (i = 0; i < ctx->Const.MaxImageUnits; i++) {
      struct gl_image_unit *unit = &ctx->ImageUnits[i];

      if (texObj == unit->TexObj)
         _mesa_reference_texobj(&unit->TexObj, NULL);
   }
}

/**
 * Unbinds all textures bound to the given texture image unit.
 */
static void
unbind_textures_from_unit(struct gl_context *ctx, GLuint unit)
{
   struct gl_texture_unit *texUnit = &ctx->Texture.Unit[unit];

   while (texUnit->_BoundTextures) {
      const GLuint index = ffs(texUnit->_BoundTextures) - 1;
      struct gl_texture_object *texObj = ctx->Shared->DefaultTex[index];

      _mesa_reference_texobj(&texUnit->CurrentTex[index], texObj);

      /* Pass BindTexture call to device driver */
      if (ctx->Driver.BindTexture)
         ctx->Driver.BindTexture(ctx, unit, 0, texObj);

      texUnit->_BoundTextures &= ~(1 << index);
      ctx->NewState |= _NEW_TEXTURE;
   }
}

/**
 * Delete named textures.
 *
 * \param n number of textures to be deleted.
 * \param textures array of texture IDs to be deleted.
 *
 * \sa glDeleteTextures().
 *
 * If we're about to delete a texture that's currently bound to any
 * texture unit, unbind the texture first.  Decrement the reference
 * count on the texture object and delete it if it's zero.
 * Recall that texture objects can be shared among several rendering
 * contexts.
 */
void GLAPIENTRY
_mesa_DeleteTextures( GLsizei n, const GLuint *textures)
{
   GET_CURRENT_CONTEXT(ctx);
   GLint i;

   if (MESA_VERBOSE & (VERBOSE_API|VERBOSE_TEXTURE))
      _mesa_debug(ctx, "glDeleteTextures %d\n", n);

   FLUSH_VERTICES(ctx, 0); /* too complex */

   if (!textures)
      return;

   for (i = 0; i < n; i++) {
      if (textures[i] > 0) {
         struct gl_texture_object *delObj
            = _mesa_lookup_texture(ctx, textures[i]);

         if (delObj) {
            _mesa_lock_texture(ctx, delObj);

            /* Check if texture is bound to any framebuffer objects.
             * If so, unbind.
             * See section 4.4.2.3 of GL_EXT_framebuffer_object.
             */
            unbind_texobj_from_fbo(ctx, delObj);

            /* Check if this texture is currently bound to any texture units.
             * If so, unbind it.
             */
            unbind_texobj_from_texunits(ctx, delObj);

            /* Check if this texture is currently bound to any shader
             * image unit.  If so, unbind it.
             * See section 3.9.X of GL_ARB_shader_image_load_store.
             */
            unbind_texobj_from_image_units(ctx, delObj);

            _mesa_unlock_texture(ctx, delObj);

            ctx->NewState |= _NEW_TEXTURE;

            /* The texture _name_ is now free for re-use.
             * Remove it from the hash table now.
             */
            mtx_lock(&ctx->Shared->Mutex);
            _mesa_HashRemove(ctx->Shared->TexObjects, delObj->Name);
            mtx_unlock(&ctx->Shared->Mutex);

            /* Unreference the texobj.  If refcount hits zero, the texture
             * will be deleted.
             */
            _mesa_reference_texobj(&delObj, NULL);
         }
      }
   }
}


/**
 * Convert a GL texture target enum such as GL_TEXTURE_2D or GL_TEXTURE_3D
 * into the corresponding Mesa texture target index.
 * Note that proxy targets are not valid here.
 * \return TEXTURE_x_INDEX or -1 if target is invalid
 */
int
_mesa_tex_target_to_index(const struct gl_context *ctx, GLenum target)
{
   switch (target) {
   case GL_TEXTURE_1D:
      return _mesa_is_desktop_gl(ctx) ? TEXTURE_1D_INDEX : -1;
   case GL_TEXTURE_2D:
      return TEXTURE_2D_INDEX;
   case GL_TEXTURE_3D:
      return ctx->API != API_OPENGLES ? TEXTURE_3D_INDEX : -1;
   case GL_TEXTURE_CUBE_MAP:
      return ctx->Extensions.ARB_texture_cube_map
         ? TEXTURE_CUBE_INDEX : -1;
   case GL_TEXTURE_RECTANGLE:
      return _mesa_is_desktop_gl(ctx) && ctx->Extensions.NV_texture_rectangle
         ? TEXTURE_RECT_INDEX : -1;
   case GL_TEXTURE_1D_ARRAY:
      return _mesa_is_desktop_gl(ctx) && ctx->Extensions.EXT_texture_array
         ? TEXTURE_1D_ARRAY_INDEX : -1;
   case GL_TEXTURE_2D_ARRAY:
      return (_mesa_is_desktop_gl(ctx) && ctx->Extensions.EXT_texture_array)
         || _mesa_is_gles3(ctx)
         ? TEXTURE_2D_ARRAY_INDEX : -1;
   case GL_TEXTURE_BUFFER:
      return ctx->API == API_OPENGL_CORE &&
             ctx->Extensions.ARB_texture_buffer_object ?
             TEXTURE_BUFFER_INDEX : -1;
   case GL_TEXTURE_EXTERNAL_OES:
      return _mesa_is_gles(ctx) && ctx->Extensions.OES_EGL_image_external
         ? TEXTURE_EXTERNAL_INDEX : -1;
   case GL_TEXTURE_CUBE_MAP_ARRAY:
      return _mesa_is_desktop_gl(ctx) && ctx->Extensions.ARB_texture_cube_map_array
         ? TEXTURE_CUBE_ARRAY_INDEX : -1;
   case GL_TEXTURE_2D_MULTISAMPLE:
      return _mesa_is_desktop_gl(ctx) && ctx->Extensions.ARB_texture_multisample
         ? TEXTURE_2D_MULTISAMPLE_INDEX: -1;
   case GL_TEXTURE_2D_MULTISAMPLE_ARRAY:
      return _mesa_is_desktop_gl(ctx) && ctx->Extensions.ARB_texture_multisample
         ? TEXTURE_2D_MULTISAMPLE_ARRAY_INDEX: -1;
   default:
      return -1;
   }
}


/**
 * Bind a named texture to a texturing target.
 * 
 * \param target texture target.
 * \param texName texture name.
 * 
 * \sa glBindTexture().
 *
 * Determines the old texture object bound and returns immediately if rebinding
 * the same texture.  Get the current texture which is either a default texture
 * if name is null, a named texture from the hash, or a new texture if the
 * given texture name is new. Increments its reference count, binds it, and
 * calls dd_function_table::BindTexture. Decrements the old texture reference
 * count and deletes it if it reaches zero.
 */
void GLAPIENTRY
_mesa_BindTexture( GLenum target, GLuint texName )
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_texture_unit *texUnit = _mesa_get_current_tex_unit(ctx);
   struct gl_texture_object *newTexObj = NULL;
   GLint targetIndex;

   if (MESA_VERBOSE & (VERBOSE_API|VERBOSE_TEXTURE))
      _mesa_debug(ctx, "glBindTexture %s %d\n",
                  _mesa_lookup_enum_by_nr(target), (GLint) texName);

   targetIndex = _mesa_tex_target_to_index(ctx, target);
   if (targetIndex < 0) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glBindTexture(target)");
      return;
   }
   assert(targetIndex < NUM_TEXTURE_TARGETS);

   /*
    * Get pointer to new texture object (newTexObj)
    */
   if (texName == 0) {
      /* Use a default texture object */
      newTexObj = ctx->Shared->DefaultTex[targetIndex];
   }
   else {
      /* non-default texture object */
      newTexObj = _mesa_lookup_texture(ctx, texName);
      if (newTexObj) {
         /* error checking */
         if (newTexObj->Target != 0 && newTexObj->Target != target) {
            /* the named texture object's target doesn't match the given target */
            _mesa_error( ctx, GL_INVALID_OPERATION,
                         "glBindTexture(target mismatch)" );
            return;
         }
         if (newTexObj->Target == 0) {
            finish_texture_init(ctx, target, newTexObj);
         }
      }
      else {
         if (ctx->API == API_OPENGL_CORE) {
            _mesa_error(ctx, GL_INVALID_OPERATION, "glBindTexture(non-gen name)");
            return;
         }

         /* if this is a new texture id, allocate a texture object now */
         newTexObj = ctx->Driver.NewTextureObject(ctx, texName, target);
         if (!newTexObj) {
            _mesa_error(ctx, GL_OUT_OF_MEMORY, "glBindTexture");
            return;
         }

         /* and insert it into hash table */
         mtx_lock(&ctx->Shared->Mutex);
         _mesa_HashInsert(ctx->Shared->TexObjects, texName, newTexObj);
         mtx_unlock(&ctx->Shared->Mutex);
      }
      newTexObj->Target = target;
      newTexObj->TargetIndex = targetIndex;
   }

   assert(valid_texture_object(newTexObj));

   /* Check if this texture is only used by this context and is already bound.
    * If so, just return.
    */
   {
      GLboolean early_out;
      mtx_lock(&ctx->Shared->Mutex);
      early_out = ((ctx->Shared->RefCount == 1)
                   && (newTexObj == texUnit->CurrentTex[targetIndex]));
      mtx_unlock(&ctx->Shared->Mutex);
      if (early_out) {
         return;
      }
   }

   /* flush before changing binding */
   FLUSH_VERTICES(ctx, _NEW_TEXTURE);

   /* Do the actual binding.  The refcount on the previously bound
    * texture object will be decremented.  It'll be deleted if the
    * count hits zero.
    */
   _mesa_reference_texobj(&texUnit->CurrentTex[targetIndex], newTexObj);
   ctx->Texture.NumCurrentTexUsed = MAX2(ctx->Texture.NumCurrentTexUsed,
                                         ctx->Texture.CurrentUnit + 1);
   ASSERT(texUnit->CurrentTex[targetIndex]);

   if (texName != 0)
      texUnit->_BoundTextures |= (1 << targetIndex);
   else
      texUnit->_BoundTextures &= ~(1 << targetIndex);

   /* Pass BindTexture call to device driver */
   if (ctx->Driver.BindTexture)
      ctx->Driver.BindTexture(ctx, ctx->Texture.CurrentUnit, target, newTexObj);
}


void GLAPIENTRY
_mesa_BindTextures(GLuint first, GLsizei count, const GLuint *textures)
{
   GET_CURRENT_CONTEXT(ctx);
   GLint i;

   /* The ARB_multi_bind spec says:
    *
    *     "An INVALID_OPERATION error is generated if <first> + <count>
    *      is greater than the number of texture image units supported
    *      by the implementation."
    */
   if (first + count > ctx->Const.MaxCombinedTextureImageUnits) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glBindTextures(first=%u + count=%d > the value of "
                  "GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS=%u)",
                  first, count, ctx->Const.MaxCombinedTextureImageUnits);
      return;
   }

   /* Flush before changing bindings */
   FLUSH_VERTICES(ctx, 0);

   ctx->Texture.NumCurrentTexUsed = MAX2(ctx->Texture.NumCurrentTexUsed,
                                         first + count);

   if (textures) {
      /* Note that the error semantics for multi-bind commands differ from
       * those of other GL commands.
       *
       * The issues section in the ARB_multi_bind spec says:
       *
       *    "(11) Typically, OpenGL specifies that if an error is generated by
       *          a command, that command has no effect.  This is somewhat
       *          unfortunate for multi-bind commands, because it would require
       *          a first pass to scan the entire list of bound objects for
       *          errors and then a second pass to actually perform the
       *          bindings.  Should we have different error semantics?
       *
       *       RESOLVED:  Yes.  In this specification, when the parameters for
       *       one of the <count> binding points are invalid, that binding
       *       point is not updated and an error will be generated.  However,
       *       other binding points in the same command will be updated if
       *       their parameters are valid and no other error occurs."
       */

      _mesa_begin_texture_lookups(ctx);

      for (i = 0; i < count; i++) {
         if (textures[i] != 0) {
            struct gl_texture_unit *texUnit = &ctx->Texture.Unit[first + i];
            struct gl_texture_object *current = texUnit->_Current;
            struct gl_texture_object *texObj;

            if (current && current->Name == textures[i])
               texObj = current;
            else
               texObj = _mesa_lookup_texture_locked(ctx, textures[i]);

            if (texObj && texObj->Target != 0) {
               const gl_texture_index targetIndex = texObj->TargetIndex;

               if (texUnit->CurrentTex[targetIndex] != texObj) {
                  /* Do the actual binding.  The refcount on the previously
                   * bound texture object will be decremented.  It will be
                   * deleted if the count hits zero.
                   */
                  _mesa_reference_texobj(&texUnit->CurrentTex[targetIndex],
                                         texObj);

                  texUnit->_BoundTextures |= (1 << targetIndex);
                  ctx->NewState |= _NEW_TEXTURE;

                  /* Pass the BindTexture call to the device driver */
                  if (ctx->Driver.BindTexture)
                     ctx->Driver.BindTexture(ctx, first + i,
                                             texObj->Target, texObj);
               }
            } else {
               /* The ARB_multi_bind spec says:
                *
                *     "An INVALID_OPERATION error is generated if any value
                *      in <textures> is not zero or the name of an existing
                *      texture object (per binding)."
                */
               _mesa_error(ctx, GL_INVALID_OPERATION,
                           "glBindTextures(textures[%d]=%u is not zero "
                           "or the name of an existing texture object)",
                           i, textures[i]);
            }
         } else {
            unbind_textures_from_unit(ctx, first + i);
         }
      }

      _mesa_end_texture_lookups(ctx);
   } else {
      /* Unbind all textures in the range <first> through <first>+<count>-1 */
      for (i = 0; i < count; i++)
         unbind_textures_from_unit(ctx, first + i);
   }
}


/**
 * Set texture priorities.
 * 
 * \param n number of textures.
 * \param texName texture names.
 * \param priorities corresponding texture priorities.
 * 
 * \sa glPrioritizeTextures().
 * 
 * Looks up each texture in the hash, clamps the corresponding priority between
 * 0.0 and 1.0, and calls dd_function_table::PrioritizeTexture.
 */
void GLAPIENTRY
_mesa_PrioritizeTextures( GLsizei n, const GLuint *texName,
                          const GLclampf *priorities )
{
   GET_CURRENT_CONTEXT(ctx);
   GLint i;

   if (MESA_VERBOSE & (VERBOSE_API|VERBOSE_TEXTURE))
      _mesa_debug(ctx, "glPrioritizeTextures %d\n", n);

   FLUSH_VERTICES(ctx, 0);

   if (n < 0) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glPrioritizeTextures" );
      return;
   }

   if (!priorities)
      return;

   for (i = 0; i < n; i++) {
      if (texName[i] > 0) {
         struct gl_texture_object *t = _mesa_lookup_texture(ctx, texName[i]);
         if (t) {
            t->Priority = CLAMP( priorities[i], 0.0F, 1.0F );
         }
      }
   }

   ctx->NewState |= _NEW_TEXTURE;
}



/**
 * See if textures are loaded in texture memory.
 * 
 * \param n number of textures to query.
 * \param texName array with the texture names.
 * \param residences array which will hold the residence status.
 *
 * \return GL_TRUE if all textures are resident and \p residences is left unchanged, 
 * 
 * Note: we assume all textures are always resident
 */
GLboolean GLAPIENTRY
_mesa_AreTexturesResident(GLsizei n, const GLuint *texName,
                          GLboolean *residences)
{
   GET_CURRENT_CONTEXT(ctx);
   GLboolean allResident = GL_TRUE;
   GLint i;
   ASSERT_OUTSIDE_BEGIN_END_WITH_RETVAL(ctx, GL_FALSE);

   if (MESA_VERBOSE & (VERBOSE_API|VERBOSE_TEXTURE))
      _mesa_debug(ctx, "glAreTexturesResident %d\n", n);

   if (n < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glAreTexturesResident(n)");
      return GL_FALSE;
   }

   if (!texName || !residences)
      return GL_FALSE;

   /* We only do error checking on the texture names */
   for (i = 0; i < n; i++) {
      struct gl_texture_object *t;
      if (texName[i] == 0) {
         _mesa_error(ctx, GL_INVALID_VALUE, "glAreTexturesResident");
         return GL_FALSE;
      }
      t = _mesa_lookup_texture(ctx, texName[i]);
      if (!t) {
         _mesa_error(ctx, GL_INVALID_VALUE, "glAreTexturesResident");
         return GL_FALSE;
      }
   }
   
   return allResident;
}


/**
 * See if a name corresponds to a texture.
 *
 * \param texture texture name.
 *
 * \return GL_TRUE if texture name corresponds to a texture, or GL_FALSE
 * otherwise.
 * 
 * \sa glIsTexture().
 *
 * Calls _mesa_HashLookup().
 */
GLboolean GLAPIENTRY
_mesa_IsTexture( GLuint texture )
{
   struct gl_texture_object *t;
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_WITH_RETVAL(ctx, GL_FALSE);

   if (MESA_VERBOSE & (VERBOSE_API|VERBOSE_TEXTURE))
      _mesa_debug(ctx, "glIsTexture %d\n", texture);

   if (!texture)
      return GL_FALSE;

   t = _mesa_lookup_texture(ctx, texture);

   /* IsTexture is true only after object has been bound once. */
   return t && t->Target;
}


/**
 * Simplest implementation of texture locking: grab the shared tex
 * mutex.  Examine the shared context state timestamp and if there has
 * been a change, set the appropriate bits in ctx->NewState.
 *
 * This is used to deal with synchronizing things when a texture object
 * is used/modified by different contexts (or threads) which are sharing
 * the texture.
 *
 * See also _mesa_lock/unlock_texture() in teximage.h
 */
void
_mesa_lock_context_textures( struct gl_context *ctx )
{
   mtx_lock(&ctx->Shared->TexMutex);

   if (ctx->Shared->TextureStateStamp != ctx->TextureStateTimestamp) {
      ctx->NewState |= _NEW_TEXTURE;
      ctx->TextureStateTimestamp = ctx->Shared->TextureStateStamp;
   }
}


void
_mesa_unlock_context_textures( struct gl_context *ctx )
{
   assert(ctx->Shared->TextureStateStamp == ctx->TextureStateTimestamp);
   mtx_unlock(&ctx->Shared->TexMutex);
}

void GLAPIENTRY
_mesa_InvalidateTexSubImage(GLuint texture, GLint level, GLint xoffset,
                            GLint yoffset, GLint zoffset, GLsizei width,
                            GLsizei height, GLsizei depth)
{
   struct gl_texture_object *t;
   struct gl_texture_image *image;
   GET_CURRENT_CONTEXT(ctx);

   if (MESA_VERBOSE & (VERBOSE_API|VERBOSE_TEXTURE))
      _mesa_debug(ctx, "glInvalidateTexSubImage %d\n", texture);

   t = invalidate_tex_image_error_check(ctx, texture, level,
                                        "glInvalidateTexSubImage");

   /* The GL_ARB_invalidate_subdata spec says:
    *
    *     "...the specified subregion must be between -<b> and <dim>+<b> where
    *     <dim> is the size of the dimension of the texture image, and <b> is
    *     the size of the border of that texture image, otherwise
    *     INVALID_VALUE is generated (border is not applied to dimensions that
    *     don't exist in a given texture target)."
    */
   image = t->Image[0][level];
   if (image) {
      int xBorder;
      int yBorder;
      int zBorder;
      int imageWidth;
      int imageHeight;
      int imageDepth;

      /* The GL_ARB_invalidate_subdata spec says:
       *
       *     "For texture targets that don't have certain dimensions, this
       *     command treats those dimensions as having a size of 1. For
       *     example, to invalidate a portion of a two-dimensional texture,
       *     the application would use <zoffset> equal to zero and <depth>
       *     equal to one."
       */
      switch (t->Target) {
      case GL_TEXTURE_BUFFER:
         xBorder = 0;
         yBorder = 0;
         zBorder = 0;
         imageWidth = 1;
         imageHeight = 1;
         imageDepth = 1;
         break;
      case GL_TEXTURE_1D:
         xBorder = image->Border;
         yBorder = 0;
         zBorder = 0;
         imageWidth = image->Width;
         imageHeight = 1;
         imageDepth = 1;
         break;
      case GL_TEXTURE_1D_ARRAY:
         xBorder = image->Border;
         yBorder = 0;
         zBorder = 0;
         imageWidth = image->Width;
         imageHeight = image->Height;
         imageDepth = 1;
         break;
      case GL_TEXTURE_2D:
      case GL_TEXTURE_CUBE_MAP:
      case GL_TEXTURE_RECTANGLE:
      case GL_TEXTURE_2D_MULTISAMPLE:
         xBorder = image->Border;
         yBorder = image->Border;
         zBorder = 0;
         imageWidth = image->Width;
         imageHeight = image->Height;
         imageDepth = 1;
         break;
      case GL_TEXTURE_2D_ARRAY:
      case GL_TEXTURE_CUBE_MAP_ARRAY:
      case GL_TEXTURE_2D_MULTISAMPLE_ARRAY:
         xBorder = image->Border;
         yBorder = image->Border;
         zBorder = 0;
         imageWidth = image->Width;
         imageHeight = image->Height;
         imageDepth = image->Depth;
         break;
      case GL_TEXTURE_3D:
         xBorder = image->Border;
         yBorder = image->Border;
         zBorder = image->Border;
         imageWidth = image->Width;
         imageHeight = image->Height;
         imageDepth = image->Depth;
         break;
      default:
         assert(!"Should not get here.");
         xBorder = 0;
         yBorder = 0;
         zBorder = 0;
         imageWidth = 0;
         imageHeight = 0;
         imageDepth = 0;
         break;
      }

      if (xoffset < -xBorder) {
         _mesa_error(ctx, GL_INVALID_VALUE, "glInvalidateSubTexImage(xoffset)");
         return;
      }

      if (xoffset + width > imageWidth + xBorder) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glInvalidateSubTexImage(xoffset+width)");
         return;
      }

      if (yoffset < -yBorder) {
         _mesa_error(ctx, GL_INVALID_VALUE, "glInvalidateSubTexImage(yoffset)");
         return;
      }

      if (yoffset + height > imageHeight + yBorder) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glInvalidateSubTexImage(yoffset+height)");
         return;
      }

      if (zoffset < -zBorder) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glInvalidateSubTexImage(zoffset)");
         return;
      }

      if (zoffset + depth  > imageDepth + zBorder) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glInvalidateSubTexImage(zoffset+depth)");
         return;
      }
   }

   /* We don't actually do anything for this yet.  Just return after
    * validating the parameters and generating the required errors.
    */
   return;
}

void GLAPIENTRY
_mesa_InvalidateTexImage(GLuint texture, GLint level)
{
   GET_CURRENT_CONTEXT(ctx);

   if (MESA_VERBOSE & (VERBOSE_API|VERBOSE_TEXTURE))
      _mesa_debug(ctx, "glInvalidateTexImage(%d, %d)\n", texture, level);

   invalidate_tex_image_error_check(ctx, texture, level,
                                    "glInvalidateTexImage");

   /* We don't actually do anything for this yet.  Just return after
    * validating the parameters and generating the required errors.
    */
   return;
}

/*@@}*/
@


1.12
log
@Merge Mesa 10.2.9
@
text
@@


1.11
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d775 2
a776 3
      const GLsizei width = 1, height = 1;
      GLsizei depth = 1;
      GLubyte texel[24];
d783 4
a786 6
      for (face = 0; face < 6; face++) {
         texel[4*face + 0] =
         texel[4*face + 1] =
         texel[4*face + 2] = 0x0;
         texel[4*face + 3] = 0xff;
      }
a824 1
         depth = 6;
@


1.10
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d775 3
a777 2
      const GLsizei width = 1, height = 1, depth = 1;
      GLubyte texel[4];
d784 6
a789 4
      texel[0] =
      texel[1] =
      texel[2] = 0x0;
      texel[3] = 0xff;
d828 1
@


1.9
log
@Merge Mesa 9.2.0
@
text
@d64 21
d139 1
a139 1
   _glthread_INIT_MUTEX(obj->Mutex);
d172 1
d181 2
a182 1
   obj->_BufferObjectFormat = MESA_FORMAT_R8;
d214 4
a217 4
            ctx->Driver.TexParameter(ctx, target, obj, GL_TEXTURE_WRAP_S, fparam_wrap);
            ctx->Driver.TexParameter(ctx, target, obj, GL_TEXTURE_WRAP_T, fparam_wrap);
            ctx->Driver.TexParameter(ctx, target, obj, GL_TEXTURE_WRAP_R, fparam_wrap);
            ctx->Driver.TexParameter(ctx, target, obj,
d219 1
a219 1
            ctx->Driver.TexParameter(ctx, target, obj,
d262 3
a264 1
   _glthread_DESTROY_MUTEX(texObj->Mutex);
d284 1
d306 1
d401 1
a401 1
      _glthread_LOCK_MUTEX(oldTex->Mutex);
d406 1
a406 1
      _glthread_UNLOCK_MUTEX(oldTex->Mutex);
d423 1
a423 1
      _glthread_LOCK_MUTEX(tex->Mutex);
d434 1
a434 1
      _glthread_UNLOCK_MUTEX(tex->Mutex);
d578 12
a589 4
   t->_MaxLevel =
      baseLevel + baseImage->MaxNumLevels - 1; /* 'p' in the GL spec */
   t->_MaxLevel = MIN2(t->_MaxLevel, t->MaxLevel);
   t->_MaxLevel = MIN2(t->_MaxLevel, maxLevels - 1); /* 'q' in the GL spec */
d591 1
a591 1
   /* Compute _MaxLambda = q - b (see the 1.2 spec) used during mipmapping */
d750 1
a750 1
 * and optionally forces the context to re-validate its state.
a753 1
 * \param invalidate_state also invalidate context state.
d756 1
a756 2
_mesa_dirty_texobj(struct gl_context *ctx, struct gl_texture_object *texObj,
                   GLboolean invalidate_state)
d760 1
a760 2
   if (invalidate_state)
      ctx->NewState |= _NEW_TEXTURE;
d779 1
a779 1
      gl_format texFormat;
d924 2
d1043 1
a1043 1
   _glthread_LOCK_MUTEX(ctx->Shared->Mutex);
d1054 1
a1054 1
         _glthread_UNLOCK_MUTEX(ctx->Shared->Mutex);
d1065 1
a1065 1
   _glthread_UNLOCK_MUTEX(ctx->Shared->Mutex);
d1117 2
a1118 1
   GLuint u, tex;
d1120 4
a1123 1
   for (u = 0; u < Elements(ctx->Texture.Unit); u++) {
d1125 6
a1130 7
      for (tex = 0; tex < NUM_TEXTURE_TARGETS; tex++) {
         if (texObj == unit->CurrentTex[tex]) {
            _mesa_reference_texobj(&unit->CurrentTex[tex],
                                   ctx->Shared->DefaultTex[tex]);
            ASSERT(unit->CurrentTex[tex]);
            break;
         }
d1137 41
d1224 6
d1237 1
a1237 1
            _glthread_LOCK_MUTEX(ctx->Shared->Mutex);
d1239 1
a1239 1
            _glthread_UNLOCK_MUTEX(ctx->Shared->Mutex);
d1257 2
a1258 2
static GLint
target_enum_to_index(struct gl_context *ctx, GLenum target)
d1266 2
a1267 2
      return TEXTURE_3D_INDEX;
   case GL_TEXTURE_CUBE_MAP_ARB:
d1270 1
a1270 1
   case GL_TEXTURE_RECTANGLE_NV:
d1273 2
a1274 4
   case GL_TEXTURE_1D_ARRAY_EXT:
      return _mesa_is_desktop_gl(ctx)
         && (ctx->Extensions.EXT_texture_array
             || ctx->Extensions.MESA_texture_array)
d1276 2
a1277 4
   case GL_TEXTURE_2D_ARRAY_EXT:
      return (_mesa_is_desktop_gl(ctx)
              && (ctx->Extensions.EXT_texture_array
                  || ctx->Extensions.MESA_texture_array))
d1280 1
a1280 1
   case GL_TEXTURE_BUFFER_ARB:
d1288 2
a1289 1
      return TEXTURE_CUBE_ARRAY_INDEX;
d1329 1
a1329 1
   targetIndex = target_enum_to_index(ctx, target);
d1372 1
a1372 1
         _glthread_LOCK_MUTEX(ctx->Shared->Mutex);
d1374 1
a1374 1
         _glthread_UNLOCK_MUTEX(ctx->Shared->Mutex);
d1377 1
d1387 1
a1387 1
      _glthread_LOCK_MUTEX(ctx->Shared->Mutex);
d1390 1
a1390 1
      _glthread_UNLOCK_MUTEX(ctx->Shared->Mutex);
d1404 2
d1408 5
d1415 105
a1519 1
      ctx->Driver.BindTexture(ctx, target, newTexObj);
d1664 1
a1664 1
   _glthread_LOCK_MUTEX(ctx->Shared->TexMutex);
d1677 1
a1677 1
   _glthread_UNLOCK_MUTEX(ctx->Shared->TexMutex);
@


1.8
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a7 1
 * Version:  7.1
d24 4
a27 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
a30 1
#include "mfeatures.h"
d86 1
a86 1
   _mesa_initialize_texture_object(obj, name, target);
d98 2
a99 1
_mesa_initialize_texture_object( struct gl_texture_object *obj,
d110 5
a114 1
          target == GL_TEXTURE_BUFFER);
d126 3
d130 2
a131 1
   if (target == GL_TEXTURE_RECTANGLE_NV) {
d150 1
a150 2
   obj->Sampler.CompareFailValue = 0.0F;       /* ARB_shadow_ambient */
   obj->Sampler.DepthMode = GL_LUMINANCE;      /* ARB_depth_texture */
d158 2
d171 1
d174 30
a203 14
   if (target == GL_TEXTURE_RECTANGLE_NV) {
      /* have to init wrap and filter state here - kind of klunky */
      obj->Sampler.WrapS = GL_CLAMP_TO_EDGE;
      obj->Sampler.WrapT = GL_CLAMP_TO_EDGE;
      obj->Sampler.WrapR = GL_CLAMP_TO_EDGE;
      obj->Sampler.MinFilter = GL_LINEAR;
      if (ctx->Driver.TexParameter) {
         static const GLfloat fparam_wrap[1] = {(GLfloat) GL_CLAMP_TO_EDGE};
         static const GLfloat fparam_filter[1] = {(GLfloat) GL_LINEAR};
         ctx->Driver.TexParameter(ctx, target, obj, GL_TEXTURE_WRAP_S, fparam_wrap);
         ctx->Driver.TexParameter(ctx, target, obj, GL_TEXTURE_WRAP_T, fparam_wrap);
         ctx->Driver.TexParameter(ctx, target, obj, GL_TEXTURE_WRAP_R, fparam_wrap);
         ctx->Driver.TexParameter(ctx, target, obj, GL_TEXTURE_MIN_FILTER, fparam_filter);
      }
a226 2
   _mesa_free_colortable_data(&texObj->Palette);

d231 1
a231 1
            _mesa_delete_texture_image( ctx, texObj->Image[face][i] );
a277 1
   dest->Sampler.CompareFailValue = src->Sampler.CompareFailValue;
d279 1
a279 1
   dest->Sampler.DepthMode = src->Sampler.DepthMode;
d284 2
a285 2
   dest->Palette = src->Palette;
   dest->_Complete = src->_Complete;
d288 2
d337 4
d357 2
d361 2
a362 2
_mesa_reference_texobj(struct gl_texture_object **ptr,
                       struct gl_texture_object *tex)
a364 4
   if (*ptr == tex) {
      /* no change */
      return;
   }
d412 2
d416 9
a424 1
 * Mark a texture object as incomplete.
d426 1
d430 2
a431 1
incomplete(struct gl_texture_object *t, const char *fmt, ...)
d433 14
a446 11
#if 0
   va_list args;
   char s[100];

   va_start(args, fmt);
   vsnprintf(s, sizeof(s), fmt, args);
   va_end(args);

   printf("Texture Obj %d incomplete because: %s\n", t->Name, s);
#endif
   t->_Complete = GL_FALSE;
d467 2
a468 1
   GLint maxLog2 = 0, maxLevels = 0;
d470 11
a480 1
   t->_Complete = GL_TRUE;  /* be optimistic */
d486 1
a486 1
      incomplete(t, "base level = %d is invalid", baseLevel);
d490 8
d499 2
a500 2
   if (!t->Image[0][baseLevel]) {
      incomplete(t, "Image[baseLevel=%d] == NULL", baseLevel);
d505 4
a508 4
   if (t->Image[0][baseLevel]->Width == 0 ||
       t->Image[0][baseLevel]->Height == 0 ||
       t->Image[0][baseLevel]->Depth == 0) {
      incomplete(t, "texture width = 0");
d512 12
a523 4
   /* Compute _MaxLevel */
   if ((t->Target == GL_TEXTURE_1D) ||
       (t->Target == GL_TEXTURE_1D_ARRAY_EXT)) {
      maxLog2 = t->Image[0][baseLevel]->WidthLog2;
d525 3
a527 5
   }
   else if ((t->Target == GL_TEXTURE_2D) ||
            (t->Target == GL_TEXTURE_2D_ARRAY_EXT)) {
      maxLog2 = MAX2(t->Image[0][baseLevel]->WidthLog2,
                     t->Image[0][baseLevel]->HeightLog2);
d529 2
a530 5
   }
   else if (t->Target == GL_TEXTURE_3D) {
      GLint max = MAX2(t->Image[0][baseLevel]->WidthLog2,
                       t->Image[0][baseLevel]->HeightLog2);
      maxLog2 = MAX2(max, (GLint)(t->Image[0][baseLevel]->DepthLog2));
d532 3
a534 4
   }
   else if (t->Target == GL_TEXTURE_CUBE_MAP_ARB) {
      maxLog2 = MAX2(t->Image[0][baseLevel]->WidthLog2,
                     t->Image[0][baseLevel]->HeightLog2);
d536 6
a541 3
   }
   else if (t->Target == GL_TEXTURE_RECTANGLE_NV) {
      maxLog2 = 0;  /* not applicable */
d543 2
a544 2
   }
   else {
d551 2
a552 7
   if (t->MaxLevel < t->BaseLevel) {
      incomplete(t, "MAX_LEVEL (%d) < BASE_LEVEL (%d)",
		 t->MaxLevel, t->BaseLevel);
      return;
   }

   t->_MaxLevel = baseLevel + maxLog2;
d554 1
a554 1
   t->_MaxLevel = MIN2(t->_MaxLevel, maxLevels - 1);
d557 10
a566 1
   t->_MaxLambda = (GLfloat) (t->_MaxLevel - t->BaseLevel);
d569 4
a572 3
      /* make sure that all six cube map level 0 images are the same size */
      const GLuint w = t->Image[0][baseLevel]->Width2;
      const GLuint h = t->Image[0][baseLevel]->Height2;
d574 1
d576 3
d580 2
a581 3
             t->Image[face][baseLevel]->Width2 != w ||
             t->Image[face][baseLevel]->Height2 != h) {
            incomplete(t, "Cube face missing or mismatched size");
d587 7
a593 5
   /* extra checking for mipmaps */
   if (t->Sampler.MinFilter != GL_NEAREST && t->Sampler.MinFilter != GL_LINEAR) {
      /*
       * Mipmapping: determine if we have a complete set of mipmaps
       */
d595 4
a598 2
      GLint minLevel = baseLevel;
      GLint maxLevel = t->_MaxLevel;
d601 1
a601 1
         incomplete(t, "minLevel > maxLevel");
d605 18
a622 11
      /* Test dimension-independent attributes */
      for (i = minLevel; i <= maxLevel; i++) {
         if (t->Image[0][i]) {
            if (t->Image[0][i]->TexFormat != t->Image[0][baseLevel]->TexFormat) {
               incomplete(t, "Format[i] != Format[baseLevel]");
               return;
            }
            if (t->Image[0][i]->Border != t->Image[0][baseLevel]->Border) {
               incomplete(t, "Border[i] != Border[baseLevel]");
               return;
            }
a623 1
      }
d625 2
a626 9
      /* Test things which depend on number of texture image dimensions */
      if ((t->Target == GL_TEXTURE_1D) ||
          (t->Target == GL_TEXTURE_1D_ARRAY_EXT)) {
         /* Test 1-D mipmaps */
         GLuint width = t->Image[0][baseLevel]->Width2;
         for (i = baseLevel + 1; i < maxLevels; i++) {
            if (width > 1) {
               width /= 2;
            }
d628 4
a631 2
               if (!t->Image[0][i]) {
                  incomplete(t, "1D Image[0][i] == NULL");
d634 2
a635 2
               if (t->Image[0][i]->Width2 != width ) {
                  incomplete(t, "1D Image[0][i] bad width");
d638 2
a639 21
            }
            if (width == 1) {
               return;  /* found smallest needed mipmap, all done! */
            }
         }
      }
      else if ((t->Target == GL_TEXTURE_2D) ||
               (t->Target == GL_TEXTURE_2D_ARRAY_EXT)) {
         /* Test 2-D mipmaps */
         GLuint width = t->Image[0][baseLevel]->Width2;
         GLuint height = t->Image[0][baseLevel]->Height2;
         for (i = baseLevel + 1; i < maxLevels; i++) {
            if (width > 1) {
               width /= 2;
            }
            if (height > 1) {
               height /= 2;
            }
            if (i >= minLevel && i <= maxLevel) {
               if (!t->Image[0][i]) {
                  incomplete(t, "2D Image[0][i] == NULL");
d642 2
a643 2
               if (t->Image[0][i]->Width2 != width) {
                  incomplete(t, "2D Image[0][i] bad width");
d646 2
a647 2
               if (t->Image[0][i]->Height2 != height) {
                  incomplete(t, "2D Image[0][i] bad height");
d650 2
a651 24
               if (width==1 && height==1) {
                  return;  /* found smallest needed mipmap, all done! */
               }
            }
         }
      }
      else if (t->Target == GL_TEXTURE_3D) {
         /* Test 3-D mipmaps */
         GLuint width = t->Image[0][baseLevel]->Width2;
         GLuint height = t->Image[0][baseLevel]->Height2;
         GLuint depth = t->Image[0][baseLevel]->Depth2;
         for (i = baseLevel + 1; i < maxLevels; i++) {
            if (width > 1) {
               width /= 2;
            }
            if (height > 1) {
               height /= 2;
            }
            if (depth > 1) {
               depth /= 2;
            }
            if (i >= minLevel && i <= maxLevel) {
               if (!t->Image[0][i]) {
                  incomplete(t, "3D Image[0][i] == NULL");
d654 9
a662 3
               if (t->Image[0][i]->_BaseFormat == GL_DEPTH_COMPONENT) {
                  incomplete(t, "GL_DEPTH_COMPONENT only works with 1/2D tex");
                  return;
a663 15
               if (t->Image[0][i]->Width2 != width) {
                  incomplete(t, "3D Image[0][i] bad width");
                  return;
               }
               if (t->Image[0][i]->Height2 != height) {
                  incomplete(t, "3D Image[0][i] bad height");
                  return;
               }
               if (t->Image[0][i]->Depth2 != depth) {
                  incomplete(t, "3D Image[0][i] bad depth");
                  return;
               }
            }
            if (width == 1 && height == 1 && depth == 1) {
               return;  /* found smallest needed mipmap, all done! */
d666 3
a668 36
      }
      else if (t->Target == GL_TEXTURE_CUBE_MAP_ARB) {
         /* make sure 6 cube faces are consistant */
         GLuint width = t->Image[0][baseLevel]->Width2;
         GLuint height = t->Image[0][baseLevel]->Height2;
         for (i = baseLevel + 1; i < maxLevels; i++) {
            if (width > 1) {
               width /= 2;
            }
            if (height > 1) {
               height /= 2;
            }
            if (i >= minLevel && i <= maxLevel) {
	       GLuint face;
	       for (face = 0; face < 6; face++) {
		  /* check that we have images defined */
		  if (!t->Image[face][i]) {
		     incomplete(t, "CubeMap Image[n][i] == NULL");
		     return;
		  }
		  /* Don't support GL_DEPTH_COMPONENT for cube maps */
		  if (t->Image[face][i]->_BaseFormat == GL_DEPTH_COMPONENT) {
		     incomplete(t, "GL_DEPTH_COMPONENT only works with 1/2D tex");
		     return;
		  }
		  /* check that all six images have same size */
                  if (t->Image[face][i]->Width2 != width || 
                      t->Image[face][i]->Height2 != height) {
		     incomplete(t, "CubeMap Image[n][i] bad size");
		     return;
		  }
	       }
	    }
	    if (width == 1 && height == 1) {
	       return;  /* found smallest needed mipmap, all done! */
            }
a670 7
      else if (t->Target == GL_TEXTURE_RECTANGLE_NV) {
         /* XXX special checking? */
      }
      else {
         /* Target = ??? */
         _mesa_problem(ctx, "Bug in gl_test_texture_object_completeness\n");
      }
d725 2
a726 1
   texObj->_Complete = GL_FALSE;
d733 3
a735 3
 * Return pointer to a default/fallback texture.
 * The texture is a 2D 8x8 RGBA texture with all texels = (0,0,0,1).
 * That's the value a sampler should get when sampling from an
d739 1
a739 1
_mesa_get_fallback_texture(struct gl_context *ctx)
d741 1
a741 1
   if (!ctx->Shared->FallbackTex) {
d743 2
a744 1
      static GLubyte texels[8 * 8][4];
d748 2
a749 1
      GLuint i;
d751 58
a808 5
      for (i = 0; i < 8 * 8; i++) {
         texels[i][0] =
         texels[i][1] =
         texels[i][2] = 0x0;
         texels[i][3] = 0xff;
d812 4
a815 1
      texObj = ctx->Driver.NewTextureObject(ctx, 0, GL_TEXTURE_2D);
d820 12
a831 2
      /* create level[0] texture image */
      texImage = _mesa_get_tex_image(ctx, texObj, GL_TEXTURE_2D, 0);
d833 2
a834 2
      texFormat = ctx->Driver.ChooseTextureFormat(ctx, GL_RGBA, GL_RGBA,
                                                  GL_UNSIGNED_BYTE);
d836 11
a846 11
      /* init the image fields */
      _mesa_init_teximage_fields(ctx, GL_TEXTURE_2D, texImage,
                                 8, 8, 1, 0, GL_RGBA, texFormat); 

      ASSERT(texImage->TexFormat != MESA_FORMAT_NONE);

      /* set image data */
      ctx->Driver.TexImage2D(ctx, GL_TEXTURE_2D, 0, GL_RGBA,
                             8, 8, 0,
                             GL_RGBA, GL_UNSIGNED_BYTE, texels,
                             &ctx->DefaultPacking, texObj, texImage);
d849 2
a850 1
      assert(texObj->_Complete);
d852 1
a852 1
      ctx->Shared->FallbackTex = texObj;
d854 1
a854 1
   return ctx->Shared->FallbackTex;
d858 110
d994 3
a996 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d1018 1
a1018 1
      texObj = (*ctx->Driver.NewTextureObject)( ctx, name, target);
d1043 1
a1043 2
   const GLuint n = (ctx->DrawBuffer == ctx->ReadBuffer) ? 1 : 2;
   GLuint i;
d1045 22
a1066 13
   for (i = 0; i < n; i++) {
      struct gl_framebuffer *fb = (i == 0) ? ctx->DrawBuffer : ctx->ReadBuffer;
      if (fb->Name) {
         GLuint j;
         for (j = 0; j < BUFFER_COUNT; j++) {
            if (fb->Attachment[j].Type == GL_TEXTURE &&
                fb->Attachment[j].Texture == texObj) {
	       /* Vertices are already flushed by _mesa_DeleteTextures */
	       ctx->NewState |= _NEW_BUFFERS;
               _mesa_remove_attachment(ctx, fb->Attachment + j);         
            }
         }
      }
d1068 4
d1118 5
a1122 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx); /* too complex */
d1174 1
a1174 1
target_enum_to_index(GLenum target)
d1178 1
a1178 1
      return TEXTURE_1D_INDEX;
d1184 2
a1185 1
      return TEXTURE_CUBE_INDEX;
d1187 2
a1188 1
      return TEXTURE_RECT_INDEX;
d1190 4
a1193 1
      return TEXTURE_1D_ARRAY_INDEX;
d1195 5
a1199 1
      return TEXTURE_2D_ARRAY_INDEX;
d1201 14
a1214 1
      return TEXTURE_BUFFER_INDEX;
a1242 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d1248 1
a1248 1
   targetIndex = target_enum_to_index(target);
d1278 5
d1284 1
a1284 1
         newTexObj = (*ctx->Driver.NewTextureObject)(ctx, texName, target);
d1326 1
a1326 1
      (*ctx->Driver.BindTexture)( ctx, target, newTexObj );
d1348 5
a1352 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d1385 1
a1385 4
 * \sa glAreTexturesResident().
 *
 * Looks up each texture in the hash and calls
 * dd_function_table::IsTextureResident.
d1393 1
a1393 1
   GLint i, j;
d1396 3
d1407 1
a1418 15
      if (!ctx->Driver.IsTextureResident ||
          ctx->Driver.IsTextureResident(ctx, t)) {
         /* The texture is resident */
         if (!allResident)
            residences[i] = GL_TRUE;
      }
      else {
         /* The texture is not resident */
         if (allResident) {
            allResident = GL_FALSE;
            for (j = 0; j < i; j++)
               residences[j] = GL_TRUE;
         }
         residences[i] = GL_FALSE;
      }
d1444 3
d1485 163
@


1.7
log
@Merge Mesa 7.10.3
@
text
@d32 1
d43 1
d109 2
a110 1
          target == GL_TEXTURE_2D_ARRAY_EXT);
d119 4
d124 4
a127 4
      obj->WrapS = GL_CLAMP_TO_EDGE;
      obj->WrapT = GL_CLAMP_TO_EDGE;
      obj->WrapR = GL_CLAMP_TO_EDGE;
      obj->MinFilter = GL_LINEAR;
d130 15
a144 16
      obj->WrapS = GL_REPEAT;
      obj->WrapT = GL_REPEAT;
      obj->WrapR = GL_REPEAT;
      obj->MinFilter = GL_NEAREST_MIPMAP_LINEAR;
   }
   obj->MagFilter = GL_LINEAR;
   obj->MinLod = -1000.0;
   obj->MaxLod = 1000.0;
   obj->LodBias = 0.0;
   obj->BaseLevel = 0;
   obj->MaxLevel = 1000;
   obj->MaxAnisotropy = 1.0;
   obj->CompareMode = GL_NONE;         /* ARB_shadow */
   obj->CompareFunc = GL_LEQUAL;       /* ARB_shadow */
   obj->CompareFailValue = 0.0F;       /* ARB_shadow_ambient */
   obj->DepthMode = GL_LUMINANCE;      /* ARB_depth_texture */
d150 1
d166 4
a169 4
      obj->WrapS = GL_CLAMP_TO_EDGE;
      obj->WrapT = GL_CLAMP_TO_EDGE;
      obj->WrapR = GL_CLAMP_TO_EDGE;
      obj->MinFilter = GL_LINEAR;
d212 2
d237 12
a248 12
   dest->BorderColor.f[0] = src->BorderColor.f[0];
   dest->BorderColor.f[1] = src->BorderColor.f[1];
   dest->BorderColor.f[2] = src->BorderColor.f[2];
   dest->BorderColor.f[3] = src->BorderColor.f[3];
   dest->WrapS = src->WrapS;
   dest->WrapT = src->WrapT;
   dest->WrapR = src->WrapR;
   dest->MinFilter = src->MinFilter;
   dest->MagFilter = src->MagFilter;
   dest->MinLod = src->MinLod;
   dest->MaxLod = src->MaxLod;
   dest->LodBias = src->LodBias;
d251 7
a257 5
   dest->MaxAnisotropy = src->MaxAnisotropy;
   dest->CompareMode = src->CompareMode;
   dest->CompareFunc = src->CompareFunc;
   dest->CompareFailValue = src->CompareFailValue;
   dest->DepthMode = src->DepthMode;
d311 1
d485 6
d514 1
a514 1
   if (t->MinFilter != GL_NEAREST && t->MinFilter != GL_LINEAR) {
d769 2
a770 2
      texObj->MinFilter = GL_NEAREST;
      texObj->MagFilter = GL_NEAREST;
d882 2
d902 1
a902 1
   for (u = 0; u < MAX_TEXTURE_IMAGE_UNITS; u++) {
d1004 2
d1031 2
a1032 3
   const GLuint unit = ctx->Texture.CurrentUnit;
   struct gl_texture_unit *texUnit = &ctx->Texture.Unit[unit];
   struct gl_texture_object *newTexObj = NULL, *defaultTexObj = NULL;
a1033 1
   GLboolean early_out = GL_FALSE;
a1045 1
   defaultTexObj = ctx->Shared->DefaultTex[targetIndex];
d1051 2
a1052 1
      newTexObj = defaultTexObj;
d1087 12
a1098 9
   _glthread_LOCK_MUTEX(ctx->Shared->Mutex);
   if ((ctx->Shared->RefCount == 1)
       && (newTexObj == texUnit->CurrentTex[targetIndex])) {
      early_out = GL_TRUE;
   }
   _glthread_UNLOCK_MUTEX(ctx->Shared->Mutex);

   if (early_out) {
      return;
@


1.6
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d43 1
a43 1
#include "shader/prog_instruction.h"
d56 1
a56 1
_mesa_lookup_texture(GLcontext *ctx, GLuint id)
d80 1
a80 1
_mesa_new_texture_object( GLcontext *ctx, GLuint name, GLenum target )
d152 1
a152 1
finish_texture_init(GLcontext *ctx, GLenum target,
d184 2
a185 1
_mesa_delete_texture_object( GLcontext *ctx, struct gl_texture_object *texObj )
a188 2
   (void) ctx;

d199 3
a201 3
	 if (texObj->Image[face][i]) {
	    _mesa_delete_texture_image( ctx, texObj->Image[face][i] );
	 }
a213 1

d258 1
a258 1
 * Clear all texture images of the given texture object.
d266 2
a267 1
_mesa_clear_texture_object(GLcontext *ctx, struct gl_texture_object *texObj)
d333 1
d375 3
a377 6
 * Report why a texture object is incomplete.  
 *
 * \param t texture object.
 * \param why string describing why it's incomplete.
 *
 * \note For debug purposes only.
a378 1
#if 0
d380 1
a380 1
incomplete(const struct gl_texture_object *t, const char *why)
d382 11
a392 1
   printf("Texture Obj %d incomplete because: %s\n", t->Name, why);
a393 3
#else
#define incomplete(t, why)
#endif
d409 1
a409 1
_mesa_test_texobj_completeness( const GLcontext *ctx,
d421 1
a421 4
      char s[100];
      sprintf(s, "base level = %d is invalid", baseLevel);
      incomplete(t, s);
      t->_Complete = GL_FALSE;
d427 1
a427 4
      char s[100];
      sprintf(s, "Image[baseLevel=%d] == NULL", baseLevel);
      incomplete(t, s);
      t->_Complete = GL_FALSE;
a435 1
      t->_Complete = GL_FALSE;
d446 1
a446 1
	    (t->Target == GL_TEXTURE_2D_ARRAY_EXT)) {
d486 6
a491 7
	 if (t->Image[face][baseLevel] == NULL ||
	     t->Image[face][baseLevel]->Width2 != w ||
	     t->Image[face][baseLevel]->Height2 != h) {
	    t->_Complete = GL_FALSE;
	    incomplete(t, "Cube face missing or mismatched size");
	    return;
	 }
a504 1
         t->_Complete = GL_FALSE;
a512 1
               t->_Complete = GL_FALSE;
a516 1
               t->_Complete = GL_FALSE;
a533 1
                  t->_Complete = GL_FALSE;
a537 1
                  t->_Complete = GL_FALSE;
a560 1
                  t->_Complete = GL_FALSE;
a564 1
                  t->_Complete = GL_FALSE;
a568 1
                  t->_Complete = GL_FALSE;
d583 1
a583 1
	 for (i = baseLevel + 1; i < maxLevels; i++) {
a595 1
                  t->_Complete = GL_FALSE;
a598 1
                  t->_Complete = GL_FALSE;
a602 1
                  t->_Complete = GL_FALSE;
a606 1
                  t->_Complete = GL_FALSE;
a610 1
                  t->_Complete = GL_FALSE;
d624 1
a624 1
	 for (i = baseLevel + 1; i < maxLevels; i++) {
a635 1
		     t->_Complete = GL_FALSE;
a640 1
		     t->_Complete = GL_FALSE;
d645 2
a646 3
		  if (t->Image[face][i]->Width2!=width || 
		      t->Image[face][i]->Height2!=height) {
		     t->_Complete = GL_FALSE;
d669 38
d715 1
a715 1
_mesa_dirty_texobj(GLcontext *ctx, struct gl_texture_object *texObj,
d731 1
a731 1
_mesa_get_fallback_texture(GLcontext *ctx)
d738 1
d757 3
d762 1
a762 1
                                    8, 8, 1, 0, GL_RGBA); 
a763 2
      texImage->TexFormat =
         ctx->Driver.ChooseTextureFormat(ctx, GL_RGBA, GL_RGBA, GL_UNSIGNED_BYTE);
d851 2
a852 1
unbind_texobj_from_fbo(GLcontext *ctx, struct gl_texture_object *texObj)
d877 2
a878 1
unbind_texobj_from_texunits(GLcontext *ctx, struct gl_texture_object *texObj)
d926 1
a926 1
	    _mesa_lock_texture(ctx, delObj);
d939 1
a939 1
	    _mesa_unlock_texture(ctx, delObj);
d1051 1
a1051 1
	 newTexObj = (*ctx->Driver.NewTextureObject)(ctx, texName, target);
d1134 2
d1181 2
a1182 2
	 if (!allResident)
	    residences[i] = GL_TRUE;
d1187 5
a1191 5
	    allResident = GL_FALSE;
	    for (j = 0; j < i; j++)
	       residences[j] = GL_TRUE;
	 }
	 residences[i] = GL_FALSE;
d1198 1
d1240 1
a1240 1
_mesa_lock_context_textures( GLcontext *ctx )
d1252 1
a1252 1
_mesa_unlock_context_textures( GLcontext *ctx )
a1258 2


@


1.5
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d31 1
a31 2
#include "glheader.h"
#if FEATURE_colortable
a32 1
#endif
d36 1
a40 1
#include "texstate.h"
d43 2
d109 1
a109 1
   _mesa_bzero(obj, sizeof(*obj));
a134 2
   obj->CompareFlag = GL_FALSE;                      /* SGIX_shadow */
   obj->CompareOperator = GL_TEXTURE_LEQUAL_R_SGIX;  /* SGIX_shadow */
d137 1
d139 5
a143 1
   obj->ShadowAmbient = 0.0F;          /* ARB/SGIX_shadow_ambient */
d181 1
a181 1
 * \param texOjb the texture object to delete.
a194 1
#if FEATURE_colortable
a195 1
#endif
d210 1
a210 1
   _mesa_free(texObj);
d230 4
a233 4
   dest->BorderColor[0] = src->BorderColor[0];
   dest->BorderColor[1] = src->BorderColor[1];
   dest->BorderColor[2] = src->BorderColor[2];
   dest->BorderColor[3] = src->BorderColor[3];
a244 3
   dest->CompareFlag = src->CompareFlag;
   dest->CompareOperator = src->CompareOperator;
   dest->ShadowAmbient = src->ShadowAmbient;
d247 1
d254 28
d306 2
a307 1
      _mesa_problem(NULL, "invalid texture object Target value");
d333 1
a333 1
      assert(valid_texture_object(oldTex));
d356 1
a356 1
      assert(valid_texture_object(tex));
d386 1
a386 1
   _mesa_printf("Texture Obj %d incomplete because: %s\n", t->Name, why);
d417 1
a417 1
   if ((baseLevel < 0) || (baseLevel > MAX_TEXTURE_LEVELS)) {
d419 1
a419 2
      _mesa_sprintf(s, "obj %p (%d) base level = %d is invalid",
              (void *) t, t->Name, baseLevel);
d428 1
a428 2
      _mesa_sprintf(s, "obj %p (%d) Image[baseLevel=%d] == NULL",
              (void *) t, t->Name, baseLevel);
d494 1
a494 1
	    incomplete(t, "Non-quare cubemap image");
d688 74
d866 1
a866 1
                                   ctx->Shared->DefaultTex[TEXTURE_1D_INDEX]);
d942 2
a943 1
 * Return -1 if target is invalid.
d992 1
d1046 11
a1105 2
	    if (ctx->Driver.PrioritizeTexture)
	       ctx->Driver.PrioritizeTexture( ctx, t, t->Priority );
d1205 3
a1207 4
 * Simplest implementation of texture locking: Grab the a new mutex in
 * the shared context.  Examine the shared context state timestamp and
 * if there has been a change, set the appropriate bits in
 * ctx->NewState.
@


1.4
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d32 1
d34 1
d192 1
d194 1
d386 12
d759 1
a759 1
   GLuint u;
d763 7
a769 20
      if (texObj == unit->Current1D) {
         _mesa_reference_texobj(&unit->Current1D, ctx->Shared->Default1D);
      }
      else if (texObj == unit->Current2D) {
         _mesa_reference_texobj(&unit->Current2D, ctx->Shared->Default2D);
      }
      else if (texObj == unit->Current3D) {
         _mesa_reference_texobj(&unit->Current3D, ctx->Shared->Default3D);
      }
      else if (texObj == unit->CurrentCubeMap) {
         _mesa_reference_texobj(&unit->CurrentCubeMap, ctx->Shared->DefaultCubeMap);
      }
      else if (texObj == unit->CurrentRect) {
         _mesa_reference_texobj(&unit->CurrentRect, ctx->Shared->DefaultRect);
      }
      else if (texObj == unit->Current1DArray) {
         _mesa_reference_texobj(&unit->Current1DArray, ctx->Shared->Default1DArray);
      }
      else if (texObj == unit->Current2DArray) {
         _mesa_reference_texobj(&unit->Current2DArray, ctx->Shared->Default2DArray);
d840 29
d890 1
d897 2
a898 23
   switch (target) {
   case GL_TEXTURE_1D:
      defaultTexObj = ctx->Shared->Default1D;
      break;
   case GL_TEXTURE_2D:
      defaultTexObj = ctx->Shared->Default2D;
      break;
   case GL_TEXTURE_3D:
      defaultTexObj = ctx->Shared->Default3D;
      break;
   case GL_TEXTURE_CUBE_MAP_ARB:
      defaultTexObj = ctx->Shared->DefaultCubeMap;
      break;
   case GL_TEXTURE_RECTANGLE_NV:
      defaultTexObj = ctx->Shared->DefaultRect;
      break;
   case GL_TEXTURE_1D_ARRAY_EXT:
      defaultTexObj = ctx->Shared->Default1DArray;
      break;
   case GL_TEXTURE_2D_ARRAY_EXT:
      defaultTexObj = ctx->Shared->Default2DArray;
      break;
   default:
d902 2
d951 2
a952 27
   switch (target) {
      case GL_TEXTURE_1D:
         _mesa_reference_texobj(&texUnit->Current1D, newTexObj);
         break;
      case GL_TEXTURE_2D:
         _mesa_reference_texobj(&texUnit->Current2D, newTexObj);
         break;
      case GL_TEXTURE_3D:
         _mesa_reference_texobj(&texUnit->Current3D, newTexObj);
         break;
      case GL_TEXTURE_CUBE_MAP_ARB:
         _mesa_reference_texobj(&texUnit->CurrentCubeMap, newTexObj);
         break;
      case GL_TEXTURE_RECTANGLE_NV:
         _mesa_reference_texobj(&texUnit->CurrentRect, newTexObj);
         break;
      case GL_TEXTURE_1D_ARRAY_EXT:
         texUnit->Current1DArray = newTexObj;
         break;
      case GL_TEXTURE_2D_ARRAY_EXT:
         texUnit->Current2DArray = newTexObj;
         break;
      default:
         /* Bad target should be caught above */
         _mesa_problem(ctx, "bad target in BindTexture");
         return;
   }
@


1.3
log
@Update to Mesa 7.0.3. tested my oga@@ and johan@@
@
text
@d8 1
a8 1
 * Version:  6.5
d10 1
a10 1
 * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
a44 4
#ifdef __VMS
#define _mesa_sprintf sprintf
#endif

d103 3
a105 1
          target == GL_TEXTURE_RECTANGLE_NV);
d139 28
a166 1
   _mesa_init_colortable(&obj->Palette);
d173 1
d250 1
a250 1
   dest->Complete = src->Complete;
d268 2
d380 1
a380 1
   t->Complete = GL_TRUE;  /* be optimistic */
d388 1
a388 1
      t->Complete = GL_FALSE;
d397 1
a397 1
      t->Complete = GL_FALSE;
d402 2
a403 1
   if (t->Target == GL_TEXTURE_1D) {
d407 2
a408 1
   else if (t->Target == GL_TEXTURE_2D) {
d451 1
a451 1
	    t->Complete = GL_FALSE;
d468 1
a468 1
         t->Complete = GL_FALSE;
d477 1
a477 1
               t->Complete = GL_FALSE;
d482 1
a482 1
               t->Complete = GL_FALSE;
d490 2
a491 1
      if (t->Target == GL_TEXTURE_1D) {
d500 1
a500 1
                  t->Complete = GL_FALSE;
d505 1
a505 1
                  t->Complete = GL_FALSE;
d515 2
a516 1
      else if (t->Target == GL_TEXTURE_2D) {
d529 1
a529 1
                  t->Complete = GL_FALSE;
d534 1
a534 1
                  t->Complete = GL_FALSE;
d539 1
a539 1
                  t->Complete = GL_FALSE;
d567 1
a567 1
                  t->Complete = GL_FALSE;
d571 1
a571 1
                  t->Complete = GL_FALSE;
d576 1
a576 1
                  t->Complete = GL_FALSE;
d581 1
a581 1
                  t->Complete = GL_FALSE;
d586 1
a586 1
                  t->Complete = GL_FALSE;
d612 1
a612 1
		     t->Complete = GL_FALSE;
d618 1
a618 1
		     t->Complete = GL_FALSE;
d625 1
a625 1
		     t->Complete = GL_FALSE;
a652 7
/**
 * Texture name generation lock.
 *
 * Used by _mesa_GenTextures() to guarantee that the generation and allocation
 * of texture IDs is atomic.
 */
_glthread_DECLARE_STATIC_MUTEX(GenTexturesLock);
d662 3
a664 3
 * While holding the GenTexturesLock lock, calls _mesa_HashFindFreeKeyBlock()
 * to find a block of free texture IDs which are stored in \p textures.
 * Corresponding empty texture objects are also generated.
d685 1
a685 1
   _glthread_LOCK_MUTEX(GenTexturesLock);
d696 1
a696 1
         _glthread_UNLOCK_MUTEX(GenTexturesLock);
a701 1
      _glthread_LOCK_MUTEX(ctx->Shared->Mutex);
a702 1
      _glthread_UNLOCK_MUTEX(ctx->Shared->Mutex);
d707 1
a707 1
   _glthread_UNLOCK_MUTEX(GenTexturesLock);
d762 6
d857 1
a857 1
   struct gl_texture_object *newTexObj = NULL;
d864 27
d895 1
a895 21
      /* newTexObj = a default texture object */
      switch (target) {
         case GL_TEXTURE_1D:
            newTexObj = ctx->Shared->Default1D;
            break;
         case GL_TEXTURE_2D:
            newTexObj = ctx->Shared->Default2D;
            break;
         case GL_TEXTURE_3D:
            newTexObj = ctx->Shared->Default3D;
            break;
         case GL_TEXTURE_CUBE_MAP_ARB:
            newTexObj = ctx->Shared->DefaultCubeMap;
            break;
         case GL_TEXTURE_RECTANGLE_NV:
            newTexObj = ctx->Shared->DefaultRect;
            break;
         default:
            _mesa_error(ctx, GL_INVALID_ENUM, "glBindTexture(target)");
            return;
      }
d903 1
a903 1
            /* the named texture object's dimensions don't match the target */
d905 1
a905 1
                         "glBindTexture(wrong dimensionality)" );
d908 2
a909 14
         if (newTexObj->Target == 0 && target == GL_TEXTURE_RECTANGLE_NV) {
            /* have to init wrap and filter state here - kind of klunky */
            newTexObj->WrapS = GL_CLAMP_TO_EDGE;
            newTexObj->WrapT = GL_CLAMP_TO_EDGE;
            newTexObj->WrapR = GL_CLAMP_TO_EDGE;
            newTexObj->MinFilter = GL_LINEAR;
            if (ctx->Driver.TexParameter) {
               static const GLfloat fparam_wrap[1] = {(GLfloat) GL_CLAMP_TO_EDGE};
               static const GLfloat fparam_filter[1] = {(GLfloat) GL_LINEAR};
               (*ctx->Driver.TexParameter)( ctx, target, newTexObj, GL_TEXTURE_WRAP_S, fparam_wrap );
               (*ctx->Driver.TexParameter)( ctx, target, newTexObj, GL_TEXTURE_WRAP_T, fparam_wrap );
               (*ctx->Driver.TexParameter)( ctx, target, newTexObj, GL_TEXTURE_WRAP_R, fparam_wrap );
               (*ctx->Driver.TexParameter)( ctx, target, newTexObj, GL_TEXTURE_MIN_FILTER, fparam_filter );
            }
d953 6
d1103 3
a1105 1
/* Simplest implementation of texture locking: Grab the a new mutex in
d1110 5
a1114 1
 * See also _mesa_lock/unlock_texture in texobj.h
d1116 2
a1117 1
void _mesa_lock_context_textures( GLcontext *ctx )
d1128 2
a1129 1
void _mesa_unlock_context_textures( GLcontext *ctx )
@


1.2
log
@Update to Mesa 7.0.2. Tested by naddy@@ (full ports build), simon@@
and oga@@ (with dri enabled).
@
text
@d857 2
a858 1
            ; /* Bad targets are caught above */
d930 1
@


1.1
log
@Initial revision
@
text
@d159 5
d196 1
d229 86
d715 1
a715 2
 * unbind it if so.
 * XXX all RefCount accesses should be protected by a mutex.
d725 1
a725 5
         unit->Current1D = ctx->Shared->Default1D;
         ctx->Shared->Default1D->RefCount++;
         texObj->RefCount--;
         if (texObj == unit->_Current)
            unit->_Current = unit->Current1D;
d728 1
a728 5
         unit->Current2D = ctx->Shared->Default2D;
         ctx->Shared->Default2D->RefCount++;
         texObj->RefCount--;
         if (texObj == unit->_Current)
            unit->_Current = unit->Current2D;
d731 1
a731 5
         unit->Current3D = ctx->Shared->Default3D;
         ctx->Shared->Default3D->RefCount++;
         texObj->RefCount--;
         if (texObj == unit->_Current)
            unit->_Current = unit->Current3D;
d734 1
a734 5
         unit->CurrentCubeMap = ctx->Shared->DefaultCubeMap;
         ctx->Shared->DefaultCubeMap->RefCount++;
         texObj->RefCount--;
         if (texObj == unit->_Current)
            unit->_Current = unit->CurrentCubeMap;
d737 1
a737 5
         unit->CurrentRect = ctx->Shared->DefaultRect;
         ctx->Shared->DefaultRect->RefCount++;
         texObj->RefCount--;
         if (texObj == unit->_Current)
            unit->_Current = unit->CurrentRect;
d771 1
d773 1
d782 1
a782 1
             * If so, unbind it and decrement the reference count.
d786 2
d797 2
a798 3
            /* The actual texture object will not be freed until it's no
             * longer bound in any context.
             * XXX all RefCount accesses should be protected by a mutex.
d800 1
a800 6
            delObj->RefCount--;
            if (delObj->RefCount == 0) {
               ASSERT(delObj->Name != 0); /* Never delete default tex objs */
               ASSERT(ctx->Driver.DeleteTexture);
               (*ctx->Driver.DeleteTexture)(ctx, delObj);
            }
a827 1
   struct gl_texture_object *oldTexObj;
a835 42
    * Get pointer to currently bound texture object (oldTexObj)
    */
   switch (target) {
      case GL_TEXTURE_1D:
         oldTexObj = texUnit->Current1D;
         break;
      case GL_TEXTURE_2D:
         oldTexObj = texUnit->Current2D;
         break;
      case GL_TEXTURE_3D:
         oldTexObj = texUnit->Current3D;
         break;
      case GL_TEXTURE_CUBE_MAP_ARB:
         if (!ctx->Extensions.ARB_texture_cube_map) {
            _mesa_error( ctx, GL_INVALID_ENUM, "glBindTexture(target)" );
            return;
         }
         oldTexObj = texUnit->CurrentCubeMap;
         break;
      case GL_TEXTURE_RECTANGLE_NV:
         if (!ctx->Extensions.NV_texture_rectangle) {
            _mesa_error( ctx, GL_INVALID_ENUM, "glBindTexture(target)" );
            return;
         }
         oldTexObj = texUnit->CurrentRect;
         break;
      default:
         _mesa_error( ctx, GL_INVALID_ENUM, "glBindTexture(target)" );
         return;
   }

   if (oldTexObj->Name == texName) {
      /* XXX this might be wrong.  If the texobj is in use by another
       * context and a texobj parameter was changed, this might be our
       * only chance to update this context's hardware state.
       * Note that some applications re-bind the same texture a lot so we
       * want to handle that case quickly.
       */
      return;   /* rebinding the same texture- no change */
   }

   /*
d903 1
a903 2
   /* XXX all RefCount accesses should be protected by a mutex. */
   newTexObj->RefCount++;
d905 1
a905 2
   /* do the actual binding, but first flush outstanding vertices:
    */
d908 4
d914 1
a914 1
         texUnit->Current1D = newTexObj;
d917 1
a917 1
         texUnit->Current2D = newTexObj;
d920 1
a920 1
         texUnit->Current3D = newTexObj;
d923 1
a923 1
         texUnit->CurrentCubeMap = newTexObj;
d926 1
a926 1
         texUnit->CurrentRect = newTexObj;
a935 12

   /* Decrement the reference count on the old texture and check if it's
    * time to delete it.
    */
   /* XXX all RefCount accesses should be protected by a mutex. */
   oldTexObj->RefCount--;
   ASSERT(oldTexObj->RefCount >= 0);
   if (oldTexObj->RefCount == 0) {
      ASSERT(oldTexObj->Name != 0);
      ASSERT(ctx->Driver.DeleteTexture);
      (*ctx->Driver.DeleteTexture)( ctx, oldTexObj );
   }
d1071 24
d1096 2
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@a699 1

a700 3
	    GLboolean delete;

	    _mesa_lock_texture(ctx, delObj);
d727 1
a727 8
	    delete = (delObj->RefCount == 0);
	    _mesa_unlock_texture(ctx, delObj);

	    /* We know that refcount went to zero above, so this is
	     * the only pointer left to delObj, so we don't have to
	     * worry about locking any more:
	     */
            if (delete) {
a1054 24
/* Simplest implementation of texture locking: Grab the a new mutex in
 * the shared context.  Examine the shared context state timestamp and
 * if there has been a change, set the appropriate bits in
 * ctx->NewState.
 *
 * See also _mesa_lock/unlock_texture in texobj.h
 */
void _mesa_lock_context_textures( GLcontext *ctx )
{
   _glthread_LOCK_MUTEX(ctx->Shared->TexMutex);

   if (ctx->Shared->TextureStateStamp != ctx->TextureStateTimestamp) {
      ctx->NewState |= _NEW_TEXTURE;
      ctx->TextureStateTimestamp = ctx->Shared->TextureStateStamp;
   }
}


void _mesa_unlock_context_textures( GLcontext *ctx )
{
   assert(ctx->Shared->TextureStateStamp == ctx->TextureStateTimestamp);
   _glthread_UNLOCK_MUTEX(ctx->Shared->TexMutex);
}

a1055 2


@


1.1.1.3
log
@Mesa 7.0.1
@
text
@a632 2
      struct gl_texture_object **curr = NULL;

a633 1
         curr = &unit->Current1D;
d635 4
a640 1
         curr = &unit->Current2D;
d642 4
a647 1
         curr = &unit->Current3D;
d649 4
a654 1
         curr = &unit->CurrentCubeMap;
d656 4
a661 1
         curr = &unit->CurrentRect;
d663 1
a663 4
      }

      if (curr) {
         (*curr)->RefCount++;
d666 1
a666 1
            unit->_Current = *curr;
d702 1
a702 1
	    GLboolean deleted;
d731 1
a731 1
	    deleted = (delObj->RefCount == 0);
d738 1
a738 1
            if (deleted) {
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d8 1
a8 1
 * Version:  7.1
d10 1
a10 1
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
d31 1
a31 1
#include "mfeatures.h"
a35 1
#include "formats.h"
d40 1
a42 1
#include "program/prog_instruction.h"
d45 3
d58 1
a58 1
_mesa_lookup_texture(struct gl_context *ctx, GLuint id)
d82 1
a82 1
_mesa_new_texture_object( struct gl_context *ctx, GLuint name, GLenum target )
d107 1
a107 3
          target == GL_TEXTURE_RECTANGLE_NV ||
          target == GL_TEXTURE_1D_ARRAY_EXT ||
          target == GL_TEXTURE_2D_ARRAY_EXT);
d109 1
a109 1
   memset(obj, 0, sizeof(*obj));
d135 2
a138 1
   obj->CompareFailValue = 0.0F;       /* ARB_shadow_ambient */
d140 2
a141 33
   obj->Swizzle[0] = GL_RED;
   obj->Swizzle[1] = GL_GREEN;
   obj->Swizzle[2] = GL_BLUE;
   obj->Swizzle[3] = GL_ALPHA;
   obj->_Swizzle = SWIZZLE_NOOP;
}


/**
 * Some texture initialization can't be finished until we know which
 * target it's getting bound to (GL_TEXTURE_1D/2D/etc).
 */
static void
finish_texture_init(struct gl_context *ctx, GLenum target,
                    struct gl_texture_object *obj)
{
   assert(obj->Target == 0);

   if (target == GL_TEXTURE_RECTANGLE_NV) {
      /* have to init wrap and filter state here - kind of klunky */
      obj->WrapS = GL_CLAMP_TO_EDGE;
      obj->WrapT = GL_CLAMP_TO_EDGE;
      obj->WrapR = GL_CLAMP_TO_EDGE;
      obj->MinFilter = GL_LINEAR;
      if (ctx->Driver.TexParameter) {
         static const GLfloat fparam_wrap[1] = {(GLfloat) GL_CLAMP_TO_EDGE};
         static const GLfloat fparam_filter[1] = {(GLfloat) GL_LINEAR};
         ctx->Driver.TexParameter(ctx, target, obj, GL_TEXTURE_WRAP_S, fparam_wrap);
         ctx->Driver.TexParameter(ctx, target, obj, GL_TEXTURE_WRAP_T, fparam_wrap);
         ctx->Driver.TexParameter(ctx, target, obj, GL_TEXTURE_WRAP_R, fparam_wrap);
         ctx->Driver.TexParameter(ctx, target, obj, GL_TEXTURE_MIN_FILTER, fparam_filter);
      }
   }
a147 1
 * Called via ctx->Driver.DeleteTexture() if not overriden by a driver.
d150 1
a150 1
 * \param texObj the texture object to delete.
d153 1
a153 2
_mesa_delete_texture_object(struct gl_context *ctx,
                            struct gl_texture_object *texObj)
d157 1
a157 4
   /* Set Target to an invalid value.  With some assertions elsewhere
    * we can try to detect possible use of deleted textures.
    */
   texObj->Target = 0x99;
d164 3
a166 3
         if (texObj->Image[face][i]) {
            _mesa_delete_texture_image( ctx, texObj->Image[face][i] );
         }
d174 1
a174 1
   free(texObj);
d179 1
a190 1
   dest->Target = src->Target;
d193 4
a196 4
   dest->BorderColor.f[0] = src->BorderColor.f[0];
   dest->BorderColor.f[1] = src->BorderColor.f[1];
   dest->BorderColor.f[2] = src->BorderColor.f[2];
   dest->BorderColor.f[3] = src->BorderColor.f[3];
d208 3
a212 1
   dest->CompareFailValue = src->CompareFailValue;
d218 1
a218 3
   dest->_Complete = src->_Complete;
   COPY_4V(dest->Swizzle, src->Swizzle);
   dest->_Swizzle = src->_Swizzle;
d223 1
a223 1
 * Free all texture images of the given texture object.
a224 1
 * \param ctx GL context.
d226 1
d228 1
a228 1
 * \sa _mesa_clear_texture_image().
d230 3
a232 25
void
_mesa_clear_texture_object(struct gl_context *ctx,
                           struct gl_texture_object *texObj)
{
   GLuint i, j;

   if (texObj->Target == 0)
      return;

   for (i = 0; i < MAX_FACES; i++) {
      for (j = 0; j < MAX_TEXTURE_LEVELS; j++) {
         struct gl_texture_image *texImage = texObj->Image[i][j];
         if (texImage)
            _mesa_clear_texture_image(ctx, texImage);
      }
   }
}


/**
 * Check if the given texture object is valid by examining its Target field.
 * For debugging only.
 */
static GLboolean
valid_texture_object(const struct gl_texture_object *tex)
d234 1
a234 18
   switch (tex->Target) {
   case 0:
   case GL_TEXTURE_1D:
   case GL_TEXTURE_2D:
   case GL_TEXTURE_3D:
   case GL_TEXTURE_CUBE_MAP_ARB:
   case GL_TEXTURE_RECTANGLE_NV:
   case GL_TEXTURE_1D_ARRAY_EXT:
   case GL_TEXTURE_2D_ARRAY_EXT:
      return GL_TRUE;
   case 0x99:
      _mesa_problem(NULL, "invalid reference to a deleted texture object");
      return GL_FALSE;
   default:
      _mesa_problem(NULL, "invalid texture object Target 0x%x, Id = %u",
                    tex->Target, tex->Name);
      return GL_FALSE;
   }
d236 2
a237 81


/**
 * Reference (or unreference) a texture object.
 * If '*ptr', decrement *ptr's refcount (and delete if it becomes zero).
 * If 'tex' is non-null, increment its refcount.
 */
void
_mesa_reference_texobj(struct gl_texture_object **ptr,
                       struct gl_texture_object *tex)
{
   assert(ptr);
   if (*ptr == tex) {
      /* no change */
      return;
   }

   if (*ptr) {
      /* Unreference the old texture */
      GLboolean deleteFlag = GL_FALSE;
      struct gl_texture_object *oldTex = *ptr;

      ASSERT(valid_texture_object(oldTex));
      (void) valid_texture_object; /* silence warning in release builds */

      _glthread_LOCK_MUTEX(oldTex->Mutex);
      ASSERT(oldTex->RefCount > 0);
      oldTex->RefCount--;

      deleteFlag = (oldTex->RefCount == 0);
      _glthread_UNLOCK_MUTEX(oldTex->Mutex);

      if (deleteFlag) {
         GET_CURRENT_CONTEXT(ctx);
         if (ctx)
            ctx->Driver.DeleteTexture(ctx, oldTex);
         else
            _mesa_problem(NULL, "Unable to delete texture, no context");
      }

      *ptr = NULL;
   }
   assert(!*ptr);

   if (tex) {
      /* reference new texture */
      ASSERT(valid_texture_object(tex));
      _glthread_LOCK_MUTEX(tex->Mutex);
      if (tex->RefCount == 0) {
         /* this texture's being deleted (look just above) */
         /* Not sure this can every really happen.  Warn if it does. */
         _mesa_problem(NULL, "referencing deleted texture object");
         *ptr = NULL;
      }
      else {
         tex->RefCount++;
         *ptr = tex;
      }
      _glthread_UNLOCK_MUTEX(tex->Mutex);
   }
}



/**
 * Mark a texture object as incomplete.
 * \param t  texture object
 * \param fmt...  string describing why it's incomplete (for debugging).
 */
static void
incomplete(struct gl_texture_object *t, const char *fmt, ...)
{
#if 0
   va_list args;
   char s[100];

   va_start(args, fmt);
   vsnprintf(s, sizeof(s), fmt, args);
   va_end(args);

   printf("Texture Obj %d incomplete because: %s\n", t->Name, s);
a238 2
   t->_Complete = GL_FALSE;
}
d254 1
a254 1
_mesa_test_texobj_completeness( const struct gl_context *ctx,
d260 1
a260 9
   t->_Complete = GL_TRUE;  /* be optimistic */

   /* Detect cases where the application set the base level to an invalid
    * value.
    */
   if ((baseLevel < 0) || (baseLevel >= MAX_TEXTURE_LEVELS)) {
      incomplete(t, "base level = %d is invalid", baseLevel);
      return;
   }
d264 5
a268 1
      incomplete(t, "Image[baseLevel=%d] == NULL", baseLevel);
d277 1
d282 1
a282 2
   if ((t->Target == GL_TEXTURE_1D) ||
       (t->Target == GL_TEXTURE_1D_ARRAY_EXT)) {
d286 1
a286 2
   else if ((t->Target == GL_TEXTURE_2D) ||
            (t->Target == GL_TEXTURE_2D_ARRAY_EXT)) {
d326 7
a332 6
         if (t->Image[face][baseLevel] == NULL ||
             t->Image[face][baseLevel]->Width2 != w ||
             t->Image[face][baseLevel]->Height2 != h) {
            incomplete(t, "Cube face missing or mismatched size");
            return;
         }
d346 1
d355 1
d360 1
d368 1
a368 2
      if ((t->Target == GL_TEXTURE_1D) ||
          (t->Target == GL_TEXTURE_1D_ARRAY_EXT)) {
d377 1
d382 1
d392 1
a392 2
      else if ((t->Target == GL_TEXTURE_2D) ||
               (t->Target == GL_TEXTURE_2D_ARRAY_EXT)) {
d405 1
d410 1
d415 1
d430 1
a430 1
         for (i = baseLevel + 1; i < maxLevels; i++) {
d443 1
d447 1
d452 1
d457 1
d462 1
d476 1
a476 1
         for (i = baseLevel + 1; i < maxLevels; i++) {
d488 1
d494 1
d499 3
a501 2
                  if (t->Image[face][i]->Width2 != width || 
                      t->Image[face][i]->Height2 != height) {
a521 114

/**
 * Check if the given cube map texture is "cube complete" as defined in
 * the OpenGL specification.
 */
GLboolean
_mesa_cube_complete(const struct gl_texture_object *texObj)
{
   const GLint baseLevel = texObj->BaseLevel;
   const struct gl_texture_image *img0, *img;
   GLuint face;

   if (texObj->Target != GL_TEXTURE_CUBE_MAP)
      return GL_FALSE;

   if ((baseLevel < 0) || (baseLevel >= MAX_TEXTURE_LEVELS))
      return GL_FALSE;

   /* check first face */
   img0 = texObj->Image[0][baseLevel];
   if (!img0 ||
       img0->Width < 1 ||
       img0->Width != img0->Height)
      return GL_FALSE;

   /* check remaining faces vs. first face */
   for (face = 1; face < 6; face++) {
      img = texObj->Image[face][baseLevel];
      if (!img ||
          img->Width != img0->Width ||
          img->Height != img0->Height ||
          img->TexFormat != img0->TexFormat)
         return GL_FALSE;
   }

   return GL_TRUE;
}


/**
 * Mark a texture object dirty.  It forces the object to be incomplete
 * and optionally forces the context to re-validate its state.
 *
 * \param ctx GL context.
 * \param texObj texture object.
 * \param invalidate_state also invalidate context state.
 */
void
_mesa_dirty_texobj(struct gl_context *ctx, struct gl_texture_object *texObj,
                   GLboolean invalidate_state)
{
   texObj->_Complete = GL_FALSE;
   if (invalidate_state)
      ctx->NewState |= _NEW_TEXTURE;
}


/**
 * Return pointer to a default/fallback texture.
 * The texture is a 2D 8x8 RGBA texture with all texels = (0,0,0,1).
 * That's the value a sampler should get when sampling from an
 * incomplete texture.
 */
struct gl_texture_object *
_mesa_get_fallback_texture(struct gl_context *ctx)
{
   if (!ctx->Shared->FallbackTex) {
      /* create fallback texture now */
      static GLubyte texels[8 * 8][4];
      struct gl_texture_object *texObj;
      struct gl_texture_image *texImage;
      gl_format texFormat;
      GLuint i;

      for (i = 0; i < 8 * 8; i++) {
         texels[i][0] =
         texels[i][1] =
         texels[i][2] = 0x0;
         texels[i][3] = 0xff;
      }

      /* create texture object */
      texObj = ctx->Driver.NewTextureObject(ctx, 0, GL_TEXTURE_2D);
      assert(texObj->RefCount == 1);
      texObj->MinFilter = GL_NEAREST;
      texObj->MagFilter = GL_NEAREST;

      /* create level[0] texture image */
      texImage = _mesa_get_tex_image(ctx, texObj, GL_TEXTURE_2D, 0);

      texFormat = ctx->Driver.ChooseTextureFormat(ctx, GL_RGBA, GL_RGBA,
                                                  GL_UNSIGNED_BYTE);

      /* init the image fields */
      _mesa_init_teximage_fields(ctx, GL_TEXTURE_2D, texImage,
                                 8, 8, 1, 0, GL_RGBA, texFormat); 

      ASSERT(texImage->TexFormat != MESA_FORMAT_NONE);

      /* set image data */
      ctx->Driver.TexImage2D(ctx, GL_TEXTURE_2D, 0, GL_RGBA,
                             8, 8, 0,
                             GL_RGBA, GL_UNSIGNED_BYTE, texels,
                             &ctx->DefaultPacking, texObj, texImage);

      _mesa_test_texobj_completeness(ctx, texObj);
      assert(texObj->_Complete);

      ctx->Shared->FallbackTex = texObj;
   }
   return ctx->Shared->FallbackTex;
}


d529 7
d545 3
a547 3
 * Calls _mesa_HashFindFreeKeyBlock() to find a block of free texture
 * IDs which are stored in \p textures.  Corresponding empty texture
 * objects are also generated.
d568 1
a568 1
   _glthread_LOCK_MUTEX(ctx->Shared->Mutex);
d579 1
a579 1
         _glthread_UNLOCK_MUTEX(ctx->Shared->Mutex);
d585 1
d587 1
d592 1
a592 1
   _glthread_UNLOCK_MUTEX(ctx->Shared->Mutex);
d601 1
a601 2
unbind_texobj_from_fbo(struct gl_context *ctx,
                       struct gl_texture_object *texObj)
d623 2
a624 1
 * unbind it if so (revert to default textures).
d627 1
a627 2
unbind_texobj_from_texunits(struct gl_context *ctx,
                            struct gl_texture_object *texObj)
d629 1
a629 1
   GLuint u, tex;
d633 28
a660 7
      for (tex = 0; tex < NUM_TEXTURE_TARGETS; tex++) {
         if (texObj == unit->CurrentTex[tex]) {
            _mesa_reference_texobj(&unit->CurrentTex[tex],
                                   ctx->Shared->DefaultTex[tex]);
            ASSERT(unit->CurrentTex[tex]);
            break;
         }
d696 3
a698 1
            _mesa_lock_texture(ctx, delObj);
d707 1
a707 1
             * If so, unbind it.
a710 2
            _mesa_unlock_texture(ctx, delObj);

d720 3
a722 2
            /* Unreference the texobj.  If refcount hits zero, the texture
             * will be deleted.
d724 13
a736 1
            _mesa_reference_texobj(&delObj, NULL);
a743 30
 * Convert a GL texture target enum such as GL_TEXTURE_2D or GL_TEXTURE_3D
 * into the corresponding Mesa texture target index.
 * Note that proxy targets are not valid here.
 * \return TEXTURE_x_INDEX or -1 if target is invalid
 */
static GLint
target_enum_to_index(GLenum target)
{
   switch (target) {
   case GL_TEXTURE_1D:
      return TEXTURE_1D_INDEX;
   case GL_TEXTURE_2D:
      return TEXTURE_2D_INDEX;
   case GL_TEXTURE_3D:
      return TEXTURE_3D_INDEX;
   case GL_TEXTURE_CUBE_MAP_ARB:
      return TEXTURE_CUBE_INDEX;
   case GL_TEXTURE_RECTANGLE_NV:
      return TEXTURE_RECT_INDEX;
   case GL_TEXTURE_1D_ARRAY_EXT:
      return TEXTURE_1D_ARRAY_INDEX;
   case GL_TEXTURE_2D_ARRAY_EXT:
      return TEXTURE_2D_ARRAY_INDEX;
   default:
      return -1;
   }
}


/**
d764 2
a765 3
   struct gl_texture_object *newTexObj = NULL, *defaultTexObj = NULL;
   GLint targetIndex;
   GLboolean early_out = GL_FALSE;
d772 40
a811 4
   targetIndex = target_enum_to_index(target);
   if (targetIndex < 0) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glBindTexture(target)");
      return;
a812 2
   assert(targetIndex < NUM_TEXTURE_TARGETS);
   defaultTexObj = ctx->Shared->DefaultTex[targetIndex];
d818 20
a837 1
      newTexObj = defaultTexObj;
d845 1
a845 1
            /* the named texture object's target doesn't match the given target */
d847 1
a847 1
                         "glBindTexture(target mismatch)" );
d850 14
a863 2
         if (newTexObj->Target == 0) {
            finish_texture_init(ctx, target, newTexObj);
d868 1
a868 1
         newTexObj = (*ctx->Driver.NewTextureObject)(ctx, texName, target);
d882 2
a883 1
   assert(valid_texture_object(newTexObj));
d885 3
a887 6
   _glthread_LOCK_MUTEX(ctx->Shared->Mutex);
   if ((ctx->Shared->RefCount == 1)
       && (newTexObj == texUnit->CurrentTex[targetIndex])) {
      early_out = GL_TRUE;
   }
   _glthread_UNLOCK_MUTEX(ctx->Shared->Mutex);
d889 19
a907 2
   if (early_out) {
      return;
a909 10
   /* flush before changing binding */
   FLUSH_VERTICES(ctx, _NEW_TEXTURE);

   /* Do the actual binding.  The refcount on the previously bound
    * texture object will be decremented.  It'll be deleted if the
    * count hits zero.
    */
   _mesa_reference_texobj(&texUnit->CurrentTex[targetIndex], newTexObj);
   ASSERT(texUnit->CurrentTex[targetIndex]);

d913 12
d961 2
a969 2


d1015 2
a1016 2
         if (!allResident)
            residences[i] = GL_TRUE;
d1021 5
a1025 5
            allResident = GL_FALSE;
            for (j = 0; j < i; j++)
               residences[j] = GL_TRUE;
         }
         residences[i] = GL_FALSE;
a1031 1

d1060 4
a1063 9

/**
 * Simplest implementation of texture locking: grab the shared tex
 * mutex.  Examine the shared context state timestamp and if there has
 * been a change, set the appropriate bits in ctx->NewState.
 *
 * This is used to deal with synchronizing things when a texture object
 * is used/modified by different contexts (or threads) which are sharing
 * the texture.
d1065 1
a1065 1
 * See also _mesa_lock/unlock_texture() in teximage.h
d1067 1
a1067 2
void
_mesa_lock_context_textures( struct gl_context *ctx )
d1078 1
a1078 2
void
_mesa_unlock_context_textures( struct gl_context *ctx )
d1085 2
@


1.1.1.5
log
@Import Mesa 9.2.0
@
text
@d8 1
d25 3
a27 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
d31 1
a31 1
#include "bufferobj.h"
a41 1
#include "texstate.h"
d85 1
a85 1
   _mesa_initialize_texture_object(ctx, obj, name, target);
d97 1
a97 2
_mesa_initialize_texture_object( struct gl_context *ctx,
                                 struct gl_texture_object *obj,
d107 1
a107 6
          target == GL_TEXTURE_2D_ARRAY_EXT ||
          target == GL_TEXTURE_EXTERNAL_OES ||
          target == GL_TEXTURE_CUBE_MAP_ARRAY ||
          target == GL_TEXTURE_BUFFER ||
          target == GL_TEXTURE_2D_MULTISAMPLE ||
          target == GL_TEXTURE_2D_MULTISAMPLE_ARRAY);
d116 16
d134 5
a138 27

   /* must be one; no support for (YUV) planes in separate buffers */
   obj->RequiredTextureImageUnits = 1;

   /* sampler state */
   if (target == GL_TEXTURE_RECTANGLE_NV ||
       target == GL_TEXTURE_EXTERNAL_OES) {
      obj->Sampler.WrapS = GL_CLAMP_TO_EDGE;
      obj->Sampler.WrapT = GL_CLAMP_TO_EDGE;
      obj->Sampler.WrapR = GL_CLAMP_TO_EDGE;
      obj->Sampler.MinFilter = GL_LINEAR;
   }
   else {
      obj->Sampler.WrapS = GL_REPEAT;
      obj->Sampler.WrapT = GL_REPEAT;
      obj->Sampler.WrapR = GL_REPEAT;
      obj->Sampler.MinFilter = GL_NEAREST_MIPMAP_LINEAR;
   }
   obj->Sampler.MagFilter = GL_LINEAR;
   obj->Sampler.MinLod = -1000.0;
   obj->Sampler.MaxLod = 1000.0;
   obj->Sampler.LodBias = 0.0;
   obj->Sampler.MaxAnisotropy = 1.0;
   obj->Sampler.CompareMode = GL_NONE;         /* ARB_shadow */
   obj->Sampler.CompareFunc = GL_LEQUAL;       /* ARB_shadow */
   obj->DepthMode = ctx->API == API_OPENGL_CORE ? GL_RED : GL_LUMINANCE;
   obj->Sampler.CubeMapSeamless = GL_FALSE;
a143 3
   obj->Sampler.sRGBDecode = GL_DECODE_EXT;
   obj->BufferObjectFormat = GL_R8;
   obj->_BufferObjectFormat = MESA_FORMAT_R8;
a154 1
   GLenum filter = GL_LINEAR;
d157 14
a170 30
   switch (target) {
      case GL_TEXTURE_2D_MULTISAMPLE:
      case GL_TEXTURE_2D_MULTISAMPLE_ARRAY:
         filter = GL_NEAREST;
         /* fallthrough */

      case GL_TEXTURE_RECTANGLE_NV:
      case GL_TEXTURE_EXTERNAL_OES:
         /* have to init wrap and filter state here - kind of klunky */
         obj->Sampler.WrapS = GL_CLAMP_TO_EDGE;
         obj->Sampler.WrapT = GL_CLAMP_TO_EDGE;
         obj->Sampler.WrapR = GL_CLAMP_TO_EDGE;
         obj->Sampler.MinFilter = filter;
         obj->Sampler.MagFilter = filter;
         if (ctx->Driver.TexParameter) {
            static const GLfloat fparam_wrap[1] = {(GLfloat) GL_CLAMP_TO_EDGE};
            const GLfloat fparam_filter[1] = {(GLfloat) filter};
            ctx->Driver.TexParameter(ctx, target, obj, GL_TEXTURE_WRAP_S, fparam_wrap);
            ctx->Driver.TexParameter(ctx, target, obj, GL_TEXTURE_WRAP_T, fparam_wrap);
            ctx->Driver.TexParameter(ctx, target, obj, GL_TEXTURE_WRAP_R, fparam_wrap);
            ctx->Driver.TexParameter(ctx, target, obj,
                  GL_TEXTURE_MIN_FILTER, fparam_filter);
            ctx->Driver.TexParameter(ctx, target, obj,
                  GL_TEXTURE_MAG_FILTER, fparam_filter);
         }
         break;

      default:
         /* nothing needs done */
         break;
d194 2
d200 1
a200 1
            ctx->Driver.DeleteTextureImage(ctx, texObj->Image[face][i]);
a204 2
   _mesa_reference_buffer_object(ctx, &texObj->BufferObject, NULL);

d228 12
a239 12
   dest->Sampler.BorderColor.f[0] = src->Sampler.BorderColor.f[0];
   dest->Sampler.BorderColor.f[1] = src->Sampler.BorderColor.f[1];
   dest->Sampler.BorderColor.f[2] = src->Sampler.BorderColor.f[2];
   dest->Sampler.BorderColor.f[3] = src->Sampler.BorderColor.f[3];
   dest->Sampler.WrapS = src->Sampler.WrapS;
   dest->Sampler.WrapT = src->Sampler.WrapT;
   dest->Sampler.WrapR = src->Sampler.WrapR;
   dest->Sampler.MinFilter = src->Sampler.MinFilter;
   dest->Sampler.MagFilter = src->Sampler.MagFilter;
   dest->Sampler.MinLod = src->Sampler.MinLod;
   dest->Sampler.MaxLod = src->Sampler.MaxLod;
   dest->Sampler.LodBias = src->Sampler.LodBias;
d242 4
a245 4
   dest->Sampler.MaxAnisotropy = src->Sampler.MaxAnisotropy;
   dest->Sampler.CompareMode = src->Sampler.CompareMode;
   dest->Sampler.CompareFunc = src->Sampler.CompareFunc;
   dest->Sampler.CubeMapSeamless = src->Sampler.CubeMapSeamless;
a246 1
   dest->Sampler.sRGBDecode = src->Sampler.sRGBDecode;
d250 2
a251 2
   dest->_BaseComplete = src->_BaseComplete;
   dest->_MipmapComplete = src->_MipmapComplete;
a253 2

   dest->RequiredTextureImageUnits = src->RequiredTextureImageUnits;
a299 5
   case GL_TEXTURE_BUFFER:
   case GL_TEXTURE_EXTERNAL_OES:
   case GL_TEXTURE_CUBE_MAP_ARRAY:
   case GL_TEXTURE_2D_MULTISAMPLE:
   case GL_TEXTURE_2D_MULTISAMPLE_ARRAY:
a315 2
 * This is normally only called from the _mesa_reference_texobj() macro
 * when there's a real pointer change.
d318 2
a319 2
_mesa_reference_texobj_(struct gl_texture_object **ptr,
                        struct gl_texture_object *tex)
d322 4
a372 2
enum base_mipmap { BASE, MIPMAP };

d375 1
a375 9
 * Mark a texture object as incomplete.  There are actually three kinds of
 * (in)completeness:
 * 1. "base incomplete": the base level of the texture is invalid so no
 *    texturing is possible.
 * 2. "mipmap incomplete": a non-base level of the texture is invalid so
 *    mipmap filtering isn't possible, but non-mipmap filtering is.
 * 3. "texture incompleteness": some combination of texture state and
 *    sampler state renders the texture incomplete.
 *
a376 1
 * \param bm  either BASE or MIPMAP to indicate what's incomplete
d380 1
a380 2
incomplete(struct gl_texture_object *t, enum base_mipmap bm,
           const char *fmt, ...)
d382 11
a392 14
   if (MESA_DEBUG_FLAGS & DEBUG_INCOMPLETE_TEXTURE) {
      va_list args;
      char s[100];

      va_start(args, fmt);
      vsnprintf(s, sizeof(s), fmt, args);
      va_end(args);

      _mesa_debug(NULL, "Texture Obj %d incomplete because: %s\n", t->Name, s);
   }

   if (bm == BASE)
      t->_BaseComplete = GL_FALSE;
   t->_MipmapComplete = GL_FALSE;
d413 1
a413 2
   const struct gl_texture_image *baseImage;
   GLint maxLevels = 0;
d415 1
a415 11
   /* We'll set these to FALSE if tests fail below */
   t->_BaseComplete = GL_TRUE;
   t->_MipmapComplete = GL_TRUE;

   if (t->Target == GL_TEXTURE_BUFFER) {
      /* Buffer textures are always considered complete.  The obvious case where
       * they would be incomplete (no BO attached) is actually specced to be
       * undefined rendering results.
       */
      return;
   }
d421 1
a421 1
      incomplete(t, BASE, "base level = %d is invalid", baseLevel);
a424 8
   if (t->MaxLevel < baseLevel) {
      incomplete(t, MIPMAP, "MAX_LEVEL (%d) < BASE_LEVEL (%d)",
		 t->MaxLevel, baseLevel);
      return;
   }

   baseImage = t->Image[0][baseLevel];

d426 2
a427 2
   if (!baseImage) {
      incomplete(t, BASE, "Image[baseLevel=%d] == NULL", baseLevel);
d432 4
a435 4
   if (baseImage->Width == 0 ||
       baseImage->Height == 0 ||
       baseImage->Depth == 0) {
      incomplete(t, BASE, "texture width or height or depth = 0");
d439 5
a443 4
   /* Check if the texture values are integer */
   {
      GLenum datatype = _mesa_get_format_datatype(baseImage->TexFormat);
      t->_IsIntegerFormat = datatype == GL_INT || datatype == GL_UNSIGNED_INT;
d445 4
a448 7

   /* Compute _MaxLevel (the maximum mipmap level we'll sample from given the
    * mipmap image sizes and GL_TEXTURE_MAX_LEVEL state).
    */
   switch (t->Target) {
   case GL_TEXTURE_1D:
   case GL_TEXTURE_1D_ARRAY_EXT:
d450 5
a454 6
      break;
   case GL_TEXTURE_2D:
   case GL_TEXTURE_2D_ARRAY_EXT:
      maxLevels = ctx->Const.MaxTextureLevels;
      break;
   case GL_TEXTURE_3D:
d456 4
a459 3
      break;
   case GL_TEXTURE_CUBE_MAP_ARB:
   case GL_TEXTURE_CUBE_MAP_ARRAY:
d461 3
a463 6
      break;
   case GL_TEXTURE_RECTANGLE_NV:
   case GL_TEXTURE_BUFFER:
   case GL_TEXTURE_EXTERNAL_OES:
   case GL_TEXTURE_2D_MULTISAMPLE:
   case GL_TEXTURE_2D_MULTISAMPLE_ARRAY:
d465 2
a466 2
      break;
   default:
d473 1
a473 2
   t->_MaxLevel =
      baseLevel + baseImage->MaxNumLevels - 1; /* 'p' in the GL spec */
d475 1
a475 1
   t->_MaxLevel = MIN2(t->_MaxLevel, maxLevels - 1); /* 'q' in the GL spec */
d478 1
a478 10
   t->_MaxLambda = (GLfloat) (t->_MaxLevel - baseLevel);

   if (t->Immutable) {
      /* This texture object was created with glTexStorage1/2/3D() so we
       * know that all the mipmap levels are the right size and all cube
       * map faces are the same size.
       * We don't need to do any of the additional checks below.
       */
      return;
   }
d481 3
a483 4
      /* Make sure that all six cube map level 0 images are the same size.
       * Note:  we know that the image's width==height (we enforce that
       * at glTexImage time) so we only need to test the width here.
       */
a484 1
      assert(baseImage->Width2 == baseImage->Height);
a485 3
         assert(t->Image[face][baseLevel] == NULL ||
                t->Image[face][baseLevel]->Width2 ==
                t->Image[face][baseLevel]->Height2);
d487 3
a489 2
             t->Image[face][baseLevel]->Width2 != baseImage->Width2) {
            incomplete(t, BASE, "Cube face missing or mismatched size");
d495 5
a499 7
   /*
    * Do mipmap consistency checking.
    * Note: we don't care about the current texture sampler state here.
    * To determine texture completeness we'll either look at _BaseComplete
    * or _MipmapComplete depending on the current minification filter mode.
    */
   {
d501 2
a502 4
      const GLint minLevel = baseLevel;
      const GLint maxLevel = t->_MaxLevel;
      const GLuint numFaces = _mesa_num_tex_faces(t->Target);
      GLuint width, height, depth, face;
d505 1
a505 1
         incomplete(t, MIPMAP, "minLevel > maxLevel");
d509 13
a521 4
      /* Get the base image's dimensions */
      width = baseImage->Width2;
      height = baseImage->Height2;
      depth = baseImage->Depth2;
d523 22
a544 7
      /* Note: this loop will be a no-op for RECT, BUFFER, EXTERNAL,
       * MULTISAMPLE and MULTISAMPLE_ARRAY textures
       */
      for (i = baseLevel + 1; i < maxLevels; i++) {
         /* Compute the expected size of image at level[i] */
         if (width > 1) {
            width /= 2;
d546 13
a558 9
         if (height > 1 && t->Target != GL_TEXTURE_1D_ARRAY) {
            height /= 2;
         }
         if (depth > 1 && t->Target != GL_TEXTURE_2D_ARRAY && t->Target != GL_TEXTURE_CUBE_MAP_ARRAY) {
            depth /= 2;
         }

         /* loop over cube faces (or single face otherwise) */
         for (face = 0; face < numFaces; face++) {
d560 10
a569 4
               const struct gl_texture_image *img = t->Image[face][i];

               if (!img) {
                  incomplete(t, MIPMAP, "TexImage[%d] is missing", i);
d572 24
a595 2
               if (img->TexFormat != baseImage->TexFormat) {
                  incomplete(t, MIPMAP, "Format[i] != Format[baseLevel]");
d598 2
a599 2
               if (img->Border != baseImage->Border) {
                  incomplete(t, MIPMAP, "Border[i] != Border[baseLevel]");
d602 2
a603 2
               if (img->Width2 != width) {
                  incomplete(t, MIPMAP, "TexImage[%d] bad width %u", i, img->Width2);
d606 2
a607 2
               if (img->Height2 != height) {
                  incomplete(t, MIPMAP, "TexImage[%d] bad height %u", i, img->Height2);
d610 2
a611 2
               if (img->Depth2 != depth) {
                  incomplete(t, MIPMAP, "TexImage[%d] bad depth %u", i, img->Depth2);
d614 34
a647 7

               /* Extra checks for cube textures */
               if (face > 0) {
                  /* check that cube faces are the same size */
                  if (img->Width2 != t->Image[0][i]->Width2 || 
                      img->Height2 != t->Image[0][i]->Height2) {
		     incomplete(t, MIPMAP, "CubeMap Image[n][i] bad size");
d650 4
a653 1
               }
d656 7
a662 4
         
         if (width == 1 && height == 1 && depth == 1) {
            return;  /* found smallest needed mipmap, all done! */
         }
d718 1
a718 2
   texObj->_BaseComplete = GL_FALSE;
   texObj->_MipmapComplete = GL_FALSE;
d725 3
a727 3
 * Return pointer to a default/fallback texture of the given type/target.
 * The texture is an RGBA texture with all texels = (0,0,0,1).
 * That's the value a GLSL sampler should get when sampling from an
d731 1
a731 1
_mesa_get_fallback_texture(struct gl_context *ctx, gl_texture_index tex)
d733 1
a733 1
   if (!ctx->Shared->FallbackTex[tex]) {
d735 1
a735 2
      const GLsizei width = 1, height = 1, depth = 1;
      GLubyte texel[4];
d739 1
a739 2
      GLuint dims, face, numFaces = 1;
      GLenum target;
d741 5
a745 58
      texel[0] =
      texel[1] =
      texel[2] = 0x0;
      texel[3] = 0xff;

      switch (tex) {
      case TEXTURE_2D_ARRAY_INDEX:
         dims = 3;
         target = GL_TEXTURE_2D_ARRAY;
         break;
      case TEXTURE_1D_ARRAY_INDEX:
         dims = 2;
         target = GL_TEXTURE_1D_ARRAY;
         break;
      case TEXTURE_CUBE_INDEX:
         dims = 2;
         target = GL_TEXTURE_CUBE_MAP;
         numFaces = 6;
         break;
      case TEXTURE_3D_INDEX:
         dims = 3;
         target = GL_TEXTURE_3D;
         break;
      case TEXTURE_RECT_INDEX:
         dims = 2;
         target = GL_TEXTURE_RECTANGLE;
         break;
      case TEXTURE_2D_INDEX:
         dims = 2;
         target = GL_TEXTURE_2D;
         break;
      case TEXTURE_1D_INDEX:
         dims = 1;
         target = GL_TEXTURE_1D;
         break;
      case TEXTURE_BUFFER_INDEX:
         dims = 0;
         target = GL_TEXTURE_BUFFER;
         break;
      case TEXTURE_CUBE_ARRAY_INDEX:
         dims = 3;
         target = GL_TEXTURE_CUBE_MAP_ARRAY;
         break;
      case TEXTURE_EXTERNAL_INDEX:
         dims = 2;
         target = GL_TEXTURE_EXTERNAL_OES;
         break;
      case TEXTURE_2D_MULTISAMPLE_INDEX:
         dims = 2;
         target = GL_TEXTURE_2D_MULTISAMPLE;
         break;
      case TEXTURE_2D_MULTISAMPLE_ARRAY_INDEX:
         dims = 3;
         target = GL_TEXTURE_2D_MULTISAMPLE_ARRAY;
         break;
      default:
         /* no-op */
         return NULL;
d749 4
a752 3
      texObj = ctx->Driver.NewTextureObject(ctx, 0, target);
      if (!texObj)
         return NULL;
d754 2
a755 3
      assert(texObj->RefCount == 1);
      texObj->Sampler.MinFilter = GL_NEAREST;
      texObj->Sampler.MagFilter = GL_NEAREST;
d757 1
a757 2
      texFormat = ctx->Driver.ChooseTextureFormat(ctx, target,
                                                  GL_RGBA, GL_RGBA,
d760 11
a770 23
      /* need a loop here just for cube maps */
      for (face = 0; face < numFaces; face++) {
         GLenum faceTarget;

         if (target == GL_TEXTURE_CUBE_MAP)
            faceTarget = GL_TEXTURE_CUBE_MAP_POSITIVE_X + face;
         else
            faceTarget = target;

         /* initialize level[0] texture image */
         texImage = _mesa_get_tex_image(ctx, texObj, faceTarget, 0);

         _mesa_init_teximage_fields(ctx, texImage,
                                    width,
                                    (dims > 1) ? height : 1,
                                    (dims > 2) ? depth : 1,
                                    0, /* border */
                                    GL_RGBA, texFormat);

         ctx->Driver.TexImage(ctx, dims, texImage,
                              GL_RGBA, GL_UNSIGNED_BYTE, texel,
                              &ctx->DefaultPacking);
      }
d773 1
a773 2
      assert(texObj->_BaseComplete);
      assert(texObj->_MipmapComplete);
d775 1
a775 1
      ctx->Shared->FallbackTex[tex] = texObj;
d777 1
a777 1
   return ctx->Shared->FallbackTex[tex];
a780 110
/**
 * Compute the size of the given texture object, in bytes.
 */
static GLuint
texture_size(const struct gl_texture_object *texObj)
{
   const GLuint numFaces = _mesa_num_tex_faces(texObj->Target);
   GLuint face, level, size = 0;

   for (face = 0; face < numFaces; face++) {
      for (level = 0; level < MAX_TEXTURE_LEVELS; level++) {
         const struct gl_texture_image *img = texObj->Image[face][level];
         if (img) {
            GLuint sz = _mesa_format_image_size(img->TexFormat, img->Width,
                                                img->Height, img->Depth);
            size += sz;
         }
      }
   }

   return size;
}


/**
 * Callback called from _mesa_HashWalk()
 */
static void
count_tex_size(GLuint key, void *data, void *userData)
{
   const struct gl_texture_object *texObj =
      (const struct gl_texture_object *) data;
   GLuint *total = (GLuint *) userData;

   *total = *total + texture_size(texObj);
}


/**
 * Compute total size (in bytes) of all textures for the given context.
 * For debugging purposes.
 */
GLuint
_mesa_total_texture_memory(struct gl_context *ctx)
{
   GLuint tgt, total = 0;

   _mesa_HashWalk(ctx->Shared->TexObjects, count_tex_size, &total);

   /* plus, the default texture objects */
   for (tgt = 0; tgt < NUM_TEXTURE_TARGETS; tgt++) {
      total += texture_size(ctx->Shared->DefaultTex[tgt]);
   }

   return total;
}

static struct gl_texture_object *
invalidate_tex_image_error_check(struct gl_context *ctx, GLuint texture,
                                 GLint level, const char *name)
{
   /* The GL_ARB_invalidate_subdata spec says:
    *
    *     "If <texture> is zero or is not the name of a texture, the error
    *     INVALID_VALUE is generated."
    *
    * This performs the error check in a different order than listed in the
    * spec.  We have to get the texture object before we can validate the
    * other parameters against values in the texture object.
    */
   struct gl_texture_object *const t = _mesa_lookup_texture(ctx, texture);
   if (texture == 0 || t == NULL) {
      _mesa_error(ctx, GL_INVALID_VALUE, "%s(texture)", name);
      return NULL;
   }

   /* The GL_ARB_invalidate_subdata spec says:
    *
    *     "If <level> is less than zero or greater than the base 2 logarithm
    *     of the maximum texture width, height, or depth, the error
    *     INVALID_VALUE is generated."
    */
   if (level < 0 || level > t->MaxLevel) {
      _mesa_error(ctx, GL_INVALID_VALUE, "%s(level)", name);
      return NULL;
   }

   /* The GL_ARB_invalidate_subdata spec says:
    *
    *     "If the target of <texture> is TEXTURE_RECTANGLE, TEXTURE_BUFFER,
    *     TEXTURE_2D_MULTISAMPLE, or TEXTURE_2D_MULTISAMPLE_ARRAY, and <level>
    *     is not zero, the error INVALID_VALUE is generated."
    */
   if (level != 0) {
      switch (t->Target) {
      case GL_TEXTURE_RECTANGLE:
      case GL_TEXTURE_BUFFER:
      case GL_TEXTURE_2D_MULTISAMPLE:
      case GL_TEXTURE_2D_MULTISAMPLE_ARRAY:
         _mesa_error(ctx, GL_INVALID_VALUE, "%s(level)", name);
         return NULL;

      default:
         break;
      }
   }

   return t;
}

d807 1
a807 3

   if (MESA_VERBOSE & (VERBOSE_API|VERBOSE_TEXTURE))
      _mesa_debug(ctx, "glGenTextures %d\n", n);
d829 1
a829 1
      texObj = ctx->Driver.NewTextureObject(ctx, name, target);
d854 2
a855 1
   bool progress = false;
d857 11
a867 22
   /* Section 4.4.2 (Attaching Images to Framebuffer Objects), subsection
    * "Attaching Texture Images to a Framebuffer," of the OpenGL 3.1 spec
    * says:
    *
    *     "If a texture object is deleted while its image is attached to one
    *     or more attachment points in the currently bound framebuffer, then
    *     it is as if FramebufferTexture* had been called, with a texture of
    *     zero, for each attachment point to which this image was attached in
    *     the currently bound framebuffer. In other words, this texture image
    *     is first detached from all attachment points in the currently bound
    *     framebuffer. Note that the texture image is specifically not
    *     detached from any other framebuffer objects. Detaching the texture
    *     image from any other framebuffer objects is the responsibility of
    *     the application."
    */
   if (_mesa_is_user_fbo(ctx->DrawBuffer)) {
      progress = _mesa_detach_renderbuffer(ctx, ctx->DrawBuffer, texObj);
   }
   if (_mesa_is_user_fbo(ctx->ReadBuffer)
       && ctx->ReadBuffer != ctx->DrawBuffer) {
      progress = _mesa_detach_renderbuffer(ctx, ctx->ReadBuffer, texObj)
         || progress;
a868 4

   if (progress)
      /* Vertices are already flushed by _mesa_DeleteTextures */
      ctx->NewState |= _NEW_BUFFERS;
d882 1
a882 1
   for (u = 0; u < Elements(ctx->Texture.Unit); u++) {
d915 1
a915 5

   if (MESA_VERBOSE & (VERBOSE_API|VERBOSE_TEXTURE))
      _mesa_debug(ctx, "glDeleteTextures %d\n", n);

   FLUSH_VERTICES(ctx, 0); /* too complex */
d967 1
a967 1
target_enum_to_index(struct gl_context *ctx, GLenum target)
d971 1
a971 1
      return _mesa_is_desktop_gl(ctx) ? TEXTURE_1D_INDEX : -1;
d977 1
a977 2
      return ctx->Extensions.ARB_texture_cube_map
         ? TEXTURE_CUBE_INDEX : -1;
d979 1
a979 2
      return _mesa_is_desktop_gl(ctx) && ctx->Extensions.NV_texture_rectangle
         ? TEXTURE_RECT_INDEX : -1;
d981 1
a981 4
      return _mesa_is_desktop_gl(ctx)
         && (ctx->Extensions.EXT_texture_array
             || ctx->Extensions.MESA_texture_array)
         ? TEXTURE_1D_ARRAY_INDEX : -1;
d983 1
a983 20
      return (_mesa_is_desktop_gl(ctx)
              && (ctx->Extensions.EXT_texture_array
                  || ctx->Extensions.MESA_texture_array))
         || _mesa_is_gles3(ctx)
         ? TEXTURE_2D_ARRAY_INDEX : -1;
   case GL_TEXTURE_BUFFER_ARB:
      return ctx->API == API_OPENGL_CORE &&
             ctx->Extensions.ARB_texture_buffer_object ?
             TEXTURE_BUFFER_INDEX : -1;
   case GL_TEXTURE_EXTERNAL_OES:
      return _mesa_is_gles(ctx) && ctx->Extensions.OES_EGL_image_external
         ? TEXTURE_EXTERNAL_INDEX : -1;
   case GL_TEXTURE_CUBE_MAP_ARRAY:
      return TEXTURE_CUBE_ARRAY_INDEX;
   case GL_TEXTURE_2D_MULTISAMPLE:
      return _mesa_is_desktop_gl(ctx) && ctx->Extensions.ARB_texture_multisample
         ? TEXTURE_2D_MULTISAMPLE_INDEX: -1;
   case GL_TEXTURE_2D_MULTISAMPLE_ARRAY:
      return _mesa_is_desktop_gl(ctx) && ctx->Extensions.ARB_texture_multisample
         ? TEXTURE_2D_MULTISAMPLE_ARRAY_INDEX: -1;
d1009 3
a1011 2
   struct gl_texture_unit *texUnit = _mesa_get_current_tex_unit(ctx);
   struct gl_texture_object *newTexObj = NULL;
d1013 2
d1020 1
a1020 1
   targetIndex = target_enum_to_index(ctx, target);
d1026 1
d1032 1
a1032 2
      /* Use a default texture object */
      newTexObj = ctx->Shared->DefaultTex[targetIndex];
a1049 5
         if (ctx->API == API_OPENGL_CORE) {
            _mesa_error(ctx, GL_INVALID_OPERATION, "glBindTexture(non-gen name)");
            return;
         }

d1051 1
a1051 1
         newTexObj = ctx->Driver.NewTextureObject(ctx, texName, target);
d1067 9
a1075 12
   /* Check if this texture is only used by this context and is already bound.
    * If so, just return.
    */
   {
      GLboolean early_out;
      _glthread_LOCK_MUTEX(ctx->Shared->Mutex);
      early_out = ((ctx->Shared->RefCount == 1)
                   && (newTexObj == texUnit->CurrentTex[targetIndex]));
      _glthread_UNLOCK_MUTEX(ctx->Shared->Mutex);
      if (early_out) {
         return;
      }
d1090 1
a1090 1
      ctx->Driver.BindTexture(ctx, target, newTexObj);
d1112 1
a1112 5

   if (MESA_VERBOSE & (VERBOSE_API|VERBOSE_TEXTURE))
      _mesa_debug(ctx, "glPrioritizeTextures %d\n", n);

   FLUSH_VERTICES(ctx, 0);
d1145 4
a1148 1
 * Note: we assume all textures are always resident
d1156 1
a1156 1
   GLint i;
a1158 3
   if (MESA_VERBOSE & (VERBOSE_API|VERBOSE_TEXTURE))
      _mesa_debug(ctx, "glAreTexturesResident %d\n", n);

a1166 1
   /* We only do error checking on the texture names */
d1178 15
a1217 3
   if (MESA_VERBOSE & (VERBOSE_API|VERBOSE_TEXTURE))
      _mesa_debug(ctx, "glIsTexture %d\n", texture);

a1255 163
}

void GLAPIENTRY
_mesa_InvalidateTexSubImage(GLuint texture, GLint level, GLint xoffset,
                            GLint yoffset, GLint zoffset, GLsizei width,
                            GLsizei height, GLsizei depth)
{
   struct gl_texture_object *t;
   struct gl_texture_image *image;
   GET_CURRENT_CONTEXT(ctx);

   if (MESA_VERBOSE & (VERBOSE_API|VERBOSE_TEXTURE))
      _mesa_debug(ctx, "glInvalidateTexSubImage %d\n", texture);

   t = invalidate_tex_image_error_check(ctx, texture, level,
                                        "glInvalidateTexSubImage");

   /* The GL_ARB_invalidate_subdata spec says:
    *
    *     "...the specified subregion must be between -<b> and <dim>+<b> where
    *     <dim> is the size of the dimension of the texture image, and <b> is
    *     the size of the border of that texture image, otherwise
    *     INVALID_VALUE is generated (border is not applied to dimensions that
    *     don't exist in a given texture target)."
    */
   image = t->Image[0][level];
   if (image) {
      int xBorder;
      int yBorder;
      int zBorder;
      int imageWidth;
      int imageHeight;
      int imageDepth;

      /* The GL_ARB_invalidate_subdata spec says:
       *
       *     "For texture targets that don't have certain dimensions, this
       *     command treats those dimensions as having a size of 1. For
       *     example, to invalidate a portion of a two-dimensional texture,
       *     the application would use <zoffset> equal to zero and <depth>
       *     equal to one."
       */
      switch (t->Target) {
      case GL_TEXTURE_BUFFER:
         xBorder = 0;
         yBorder = 0;
         zBorder = 0;
         imageWidth = 1;
         imageHeight = 1;
         imageDepth = 1;
         break;
      case GL_TEXTURE_1D:
         xBorder = image->Border;
         yBorder = 0;
         zBorder = 0;
         imageWidth = image->Width;
         imageHeight = 1;
         imageDepth = 1;
         break;
      case GL_TEXTURE_1D_ARRAY:
         xBorder = image->Border;
         yBorder = 0;
         zBorder = 0;
         imageWidth = image->Width;
         imageHeight = image->Height;
         imageDepth = 1;
         break;
      case GL_TEXTURE_2D:
      case GL_TEXTURE_CUBE_MAP:
      case GL_TEXTURE_RECTANGLE:
      case GL_TEXTURE_2D_MULTISAMPLE:
         xBorder = image->Border;
         yBorder = image->Border;
         zBorder = 0;
         imageWidth = image->Width;
         imageHeight = image->Height;
         imageDepth = 1;
         break;
      case GL_TEXTURE_2D_ARRAY:
      case GL_TEXTURE_CUBE_MAP_ARRAY:
      case GL_TEXTURE_2D_MULTISAMPLE_ARRAY:
         xBorder = image->Border;
         yBorder = image->Border;
         zBorder = 0;
         imageWidth = image->Width;
         imageHeight = image->Height;
         imageDepth = image->Depth;
         break;
      case GL_TEXTURE_3D:
         xBorder = image->Border;
         yBorder = image->Border;
         zBorder = image->Border;
         imageWidth = image->Width;
         imageHeight = image->Height;
         imageDepth = image->Depth;
         break;
      default:
         assert(!"Should not get here.");
         xBorder = 0;
         yBorder = 0;
         zBorder = 0;
         imageWidth = 0;
         imageHeight = 0;
         imageDepth = 0;
         break;
      }

      if (xoffset < -xBorder) {
         _mesa_error(ctx, GL_INVALID_VALUE, "glInvalidateSubTexImage(xoffset)");
         return;
      }

      if (xoffset + width > imageWidth + xBorder) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glInvalidateSubTexImage(xoffset+width)");
         return;
      }

      if (yoffset < -yBorder) {
         _mesa_error(ctx, GL_INVALID_VALUE, "glInvalidateSubTexImage(yoffset)");
         return;
      }

      if (yoffset + height > imageHeight + yBorder) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glInvalidateSubTexImage(yoffset+height)");
         return;
      }

      if (zoffset < -zBorder) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glInvalidateSubTexImage(zoffset)");
         return;
      }

      if (zoffset + depth  > imageDepth + zBorder) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glInvalidateSubTexImage(zoffset+depth)");
         return;
      }
   }

   /* We don't actually do anything for this yet.  Just return after
    * validating the parameters and generating the required errors.
    */
   return;
}

void GLAPIENTRY
_mesa_InvalidateTexImage(GLuint texture, GLint level)
{
   GET_CURRENT_CONTEXT(ctx);

   if (MESA_VERBOSE & (VERBOSE_API|VERBOSE_TEXTURE))
      _mesa_debug(ctx, "glInvalidateTexImage(%d, %d)\n", texture, level);

   invalidate_tex_image_error_check(ctx, texture, level,
                                    "glInvalidateTexImage");

   /* We don't actually do anything for this yet.  Just return after
    * validating the parameters and generating the required errors.
    */
   return;
@


1.1.1.6
log
@Import Mesa 10.2.3
@
text
@a63 21
void
_mesa_begin_texture_lookups(struct gl_context *ctx)
{
   _mesa_HashLockMutex(ctx->Shared->TexObjects);
}


void
_mesa_end_texture_lookups(struct gl_context *ctx)
{
   _mesa_HashUnlockMutex(ctx->Shared->TexObjects);
}


struct gl_texture_object *
_mesa_lookup_texture_locked(struct gl_context *ctx, GLuint id)
{
   return (struct gl_texture_object *)
      _mesa_HashLookupLocked(ctx->Shared->TexObjects, id);
}

d118 1
a118 1
   mtx_init(&obj->Mutex, mtx_plain);
a150 1
   obj->StencilSampling = false;
d159 1
a159 2
   obj->_BufferObjectFormat = MESA_FORMAT_R_UNORM8;
   obj->ImageFormatCompatibilityType = GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE;
d191 4
a194 4
            ctx->Driver.TexParameter(ctx, obj, GL_TEXTURE_WRAP_S, fparam_wrap);
            ctx->Driver.TexParameter(ctx, obj, GL_TEXTURE_WRAP_T, fparam_wrap);
            ctx->Driver.TexParameter(ctx, obj, GL_TEXTURE_WRAP_R, fparam_wrap);
            ctx->Driver.TexParameter(ctx, obj,
d196 1
a196 1
            ctx->Driver.TexParameter(ctx, obj,
d239 1
a239 3
   mtx_destroy(&texObj->Mutex);

   free(texObj->Label);
a258 1
   dest->TargetIndex = src->TargetIndex;
a279 1
   dest->StencilSampling = src->StencilSampling;
d374 1
a374 1
      mtx_lock(&oldTex->Mutex);
d379 1
a379 1
      mtx_unlock(&oldTex->Mutex);
d396 1
a396 1
      mtx_lock(&tex->Mutex);
d407 1
a407 1
      mtx_unlock(&tex->Mutex);
d551 4
a554 12
   t->_MaxLevel = MIN3(t->MaxLevel,
                       /* 'p' in the GL spec */
                       (int) (baseLevel + baseImage->MaxNumLevels - 1),
                       /* 'q' in the GL spec */
                       maxLevels - 1);

   if (t->Immutable) {
      /* Adjust max level for views: the data store may have more levels than
       * the view exposes.
       */
      t->_MaxLevel = MIN2(t->_MaxLevel, t->NumLevels - 1);
   }
d556 1
a556 1
   /* Compute _MaxLambda = q - p in the spec used during mipmapping */
d715 1
a715 1
 * and forces the context to re-validate its state.
d719 1
d722 2
a723 1
_mesa_dirty_texobj(struct gl_context *ctx, struct gl_texture_object *texObj)
d727 2
a728 1
   ctx->NewState |= _NEW_TEXTURE;
d747 1
a747 1
      mesa_format texFormat;
a891 2
   (void) key;

d1009 1
a1009 1
   mtx_lock(&ctx->Shared->Mutex);
d1020 1
a1020 1
         mtx_unlock(&ctx->Shared->Mutex);
d1031 1
a1031 1
   mtx_unlock(&ctx->Shared->Mutex);
d1083 1
a1083 2
   const gl_texture_index index = texObj->TargetIndex;
   GLuint u;
d1085 1
a1085 4
   if (texObj->Target == 0)
      return;

   for (u = 0; u < ctx->Texture.NumCurrentTexUsed; u++) {
d1087 7
a1093 6

      if (texObj == unit->CurrentTex[index]) {
         /* Bind the default texture for this unit/target */
         _mesa_reference_texobj(&unit->CurrentTex[index],
                                ctx->Shared->DefaultTex[index]);
         unit->_BoundTextures &= ~(1 << index);
a1099 41
 * Check if the given texture object is bound to any shader image unit
 * and unbind it if that's the case.
 */
static void
unbind_texobj_from_image_units(struct gl_context *ctx,
                               struct gl_texture_object *texObj)
{
   GLuint i;

   for (i = 0; i < ctx->Const.MaxImageUnits; i++) {
      struct gl_image_unit *unit = &ctx->ImageUnits[i];

      if (texObj == unit->TexObj)
         _mesa_reference_texobj(&unit->TexObj, NULL);
   }
}

/**
 * Unbinds all textures bound to the given texture image unit.
 */
static void
unbind_textures_from_unit(struct gl_context *ctx, GLuint unit)
{
   struct gl_texture_unit *texUnit = &ctx->Texture.Unit[unit];

   while (texUnit->_BoundTextures) {
      const GLuint index = ffs(texUnit->_BoundTextures) - 1;
      struct gl_texture_object *texObj = ctx->Shared->DefaultTex[index];

      _mesa_reference_texobj(&texUnit->CurrentTex[index], texObj);

      /* Pass BindTexture call to device driver */
      if (ctx->Driver.BindTexture)
         ctx->Driver.BindTexture(ctx, unit, 0, texObj);

      texUnit->_BoundTextures &= ~(1 << index);
      ctx->NewState |= _NEW_TEXTURE;
   }
}

/**
a1145 6
            /* Check if this texture is currently bound to any shader
             * image unit.  If so, unbind it.
             * See section 3.9.X of GL_ARB_shader_image_load_store.
             */
            unbind_texobj_from_image_units(ctx, delObj);

d1153 1
a1153 1
            mtx_lock(&ctx->Shared->Mutex);
d1155 1
a1155 1
            mtx_unlock(&ctx->Shared->Mutex);
d1173 2
a1174 2
int
_mesa_tex_target_to_index(const struct gl_context *ctx, GLenum target)
d1182 2
a1183 2
      return ctx->API != API_OPENGLES ? TEXTURE_3D_INDEX : -1;
   case GL_TEXTURE_CUBE_MAP:
d1186 1
a1186 1
   case GL_TEXTURE_RECTANGLE:
d1189 4
a1192 2
   case GL_TEXTURE_1D_ARRAY:
      return _mesa_is_desktop_gl(ctx) && ctx->Extensions.EXT_texture_array
d1194 4
a1197 2
   case GL_TEXTURE_2D_ARRAY:
      return (_mesa_is_desktop_gl(ctx) && ctx->Extensions.EXT_texture_array)
d1200 1
a1200 1
   case GL_TEXTURE_BUFFER:
d1208 1
a1208 2
      return _mesa_is_desktop_gl(ctx) && ctx->Extensions.ARB_texture_cube_map_array
         ? TEXTURE_CUBE_ARRAY_INDEX : -1;
d1248 1
a1248 1
   targetIndex = _mesa_tex_target_to_index(ctx, target);
d1291 1
a1291 1
         mtx_lock(&ctx->Shared->Mutex);
d1293 1
a1293 1
         mtx_unlock(&ctx->Shared->Mutex);
a1295 1
      newTexObj->TargetIndex = targetIndex;
d1305 1
a1305 1
      mtx_lock(&ctx->Shared->Mutex);
d1308 1
a1308 1
      mtx_unlock(&ctx->Shared->Mutex);
a1321 2
   ctx->Texture.NumCurrentTexUsed = MAX2(ctx->Texture.NumCurrentTexUsed,
                                         ctx->Texture.CurrentUnit + 1);
a1323 5
   if (texName != 0)
      texUnit->_BoundTextures |= (1 << targetIndex);
   else
      texUnit->_BoundTextures &= ~(1 << targetIndex);

d1326 1
a1326 105
      ctx->Driver.BindTexture(ctx, ctx->Texture.CurrentUnit, target, newTexObj);
}


void GLAPIENTRY
_mesa_BindTextures(GLuint first, GLsizei count, const GLuint *textures)
{
   GET_CURRENT_CONTEXT(ctx);
   GLint i;

   /* The ARB_multi_bind spec says:
    *
    *     "An INVALID_OPERATION error is generated if <first> + <count>
    *      is greater than the number of texture image units supported
    *      by the implementation."
    */
   if (first + count > ctx->Const.MaxCombinedTextureImageUnits) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glBindTextures(first=%u + count=%d > the value of "
                  "GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS=%u)",
                  first, count, ctx->Const.MaxCombinedTextureImageUnits);
      return;
   }

   /* Flush before changing bindings */
   FLUSH_VERTICES(ctx, 0);

   ctx->Texture.NumCurrentTexUsed = MAX2(ctx->Texture.NumCurrentTexUsed,
                                         first + count);

   if (textures) {
      /* Note that the error semantics for multi-bind commands differ from
       * those of other GL commands.
       *
       * The issues section in the ARB_multi_bind spec says:
       *
       *    "(11) Typically, OpenGL specifies that if an error is generated by
       *          a command, that command has no effect.  This is somewhat
       *          unfortunate for multi-bind commands, because it would require
       *          a first pass to scan the entire list of bound objects for
       *          errors and then a second pass to actually perform the
       *          bindings.  Should we have different error semantics?
       *
       *       RESOLVED:  Yes.  In this specification, when the parameters for
       *       one of the <count> binding points are invalid, that binding
       *       point is not updated and an error will be generated.  However,
       *       other binding points in the same command will be updated if
       *       their parameters are valid and no other error occurs."
       */

      _mesa_begin_texture_lookups(ctx);

      for (i = 0; i < count; i++) {
         if (textures[i] != 0) {
            struct gl_texture_unit *texUnit = &ctx->Texture.Unit[first + i];
            struct gl_texture_object *current = texUnit->_Current;
            struct gl_texture_object *texObj;

            if (current && current->Name == textures[i])
               texObj = current;
            else
               texObj = _mesa_lookup_texture_locked(ctx, textures[i]);

            if (texObj && texObj->Target != 0) {
               const gl_texture_index targetIndex = texObj->TargetIndex;

               if (texUnit->CurrentTex[targetIndex] != texObj) {
                  /* Do the actual binding.  The refcount on the previously
                   * bound texture object will be decremented.  It will be
                   * deleted if the count hits zero.
                   */
                  _mesa_reference_texobj(&texUnit->CurrentTex[targetIndex],
                                         texObj);

                  texUnit->_BoundTextures |= (1 << targetIndex);
                  ctx->NewState |= _NEW_TEXTURE;

                  /* Pass the BindTexture call to the device driver */
                  if (ctx->Driver.BindTexture)
                     ctx->Driver.BindTexture(ctx, first + i,
                                             texObj->Target, texObj);
               }
            } else {
               /* The ARB_multi_bind spec says:
                *
                *     "An INVALID_OPERATION error is generated if any value
                *      in <textures> is not zero or the name of an existing
                *      texture object (per binding)."
                */
               _mesa_error(ctx, GL_INVALID_OPERATION,
                           "glBindTextures(textures[%d]=%u is not zero "
                           "or the name of an existing texture object)",
                           i, textures[i]);
            }
         } else {
            unbind_textures_from_unit(ctx, first + i);
         }
      }

      _mesa_end_texture_lookups(ctx);
   } else {
      /* Unbind all textures in the range <first> through <first>+<count>-1 */
      for (i = 0; i < count; i++)
         unbind_textures_from_unit(ctx, first + i);
   }
d1471 1
a1471 1
   mtx_lock(&ctx->Shared->TexMutex);
d1484 1
a1484 1
   mtx_unlock(&ctx->Shared->TexMutex);
@


1.1.1.7
log
@Import Mesa 10.4.3
@
text
@d775 2
a776 3
      const GLsizei width = 1, height = 1;
      GLsizei depth = 1;
      GLubyte texel[24];
d783 4
a786 6
      for (face = 0; face < 6; face++) {
         texel[4*face + 0] =
         texel[4*face + 1] =
         texel[4*face + 2] = 0x0;
         texel[4*face + 3] = 0xff;
      }
a824 1
         depth = 6;
@


1.1.1.8
log
@Import Mesa 10.2.9
@
text
@d775 3
a777 2
      const GLsizei width = 1, height = 1, depth = 1;
      GLubyte texel[4];
d784 6
a789 4
      texel[0] =
      texel[1] =
      texel[2] = 0x0;
      texel[3] = 0xff;
d828 1
@


