head	1.9;
access;
symbols
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.6.0.2
	OPENBSD_5_6_BASE:1.6
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.5.0.2
	OPENBSD_5_5_BASE:1.5
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.4.0.4
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.2
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.9
date	2015.12.23.05.17.53;	author jsg;	state dead;
branches;
next	1.8;
commitid	TnlogFl9nOv2eaRf;

1.8
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.7;
commitid	4ry2gvZGMXkCUD2n;

1.7
date	2015.01.25.14.41.22;	author jsg;	state Exp;
branches;
next	1.6;
commitid	mcxB0JvoI9gTDYXU;

1.6
date	2014.07.09.21.09.00;	author jsg;	state Exp;
branches;
next	1.5;
commitid	WPD6rgPryPkvXOr9;

1.5
date	2013.09.05.14.06.33;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2012.08.17.14.18.49;	author mpi;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.20;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.44;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.31;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.47;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.16.59;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.35.07;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.13.04;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.50.10;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.9
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 2010  VMware, Inc.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */


#include "imports.h"
#include "mtypes.h"
#include "version.h"
#include "git_sha1.h"

/**
 * Scans 'string' to see if it ends with 'ending'.
 */
static GLboolean
check_for_ending(const char *string, const char *ending)
{
   int len1, len2;

   len1 = strlen(string);
   len2 = strlen(ending);

   if (len2 > len1) {
      return GL_FALSE;
   }

   if (strcmp(string + (len1 - len2), ending) == 0) {
      return GL_TRUE;
   } else {
      return GL_FALSE;
   }
}

/**
 * Returns the gl override data
 *
 * version > 0 indicates there is an override requested
 * fwd_context is only valid if version > 0
 */
static void
get_gl_override(int *version, GLboolean *fwd_context)
{
   const char *env_var = "MESA_GL_VERSION_OVERRIDE";
   const char *version_str;
   int major, minor, n;
   static int override_version = -1;
   static GLboolean fc_suffix = GL_FALSE;

   if (override_version < 0) {
      override_version = 0;

      version_str = getenv(env_var);
      if (version_str) {
         fc_suffix = check_for_ending(version_str, "FC");

         n = sscanf(version_str, "%u.%u", &major, &minor);
         if (n != 2) {
            fprintf(stderr, "error: invalid value for %s: %s\n", env_var, version_str);
            override_version = 0;
         } else {
            override_version = major * 10 + minor;
            if (override_version < 30 && fc_suffix) {
               fprintf(stderr, "error: invalid value for %s: %s\n", env_var, version_str);
            }
         }
      }
   }

   *version = override_version;
   *fwd_context = fc_suffix;
}

/**
 * Builds the MESA version string.
 */
static void
create_version_string(struct gl_context *ctx, const char *prefix)
{
   static const int max = 100;

   ctx->VersionString = malloc(max);
   if (ctx->VersionString) {
      _mesa_snprintf(ctx->VersionString, max,
		     "%s%u.%u%s Mesa " PACKAGE_VERSION
#ifdef MESA_GIT_SHA1
		     " (" MESA_GIT_SHA1 ")"
#endif
		     ,
		     prefix,
		     ctx->Version / 10, ctx->Version % 10,
		     (ctx->API == API_OPENGL_CORE) ? " (Core Profile)" : ""
		     );
   }
}

/**
 * Override the context's version and/or API type if the
 * environment variable MESA_GL_VERSION_OVERRIDE is set.
 *
 * Example uses of MESA_GL_VERSION_OVERRIDE:
 *
 * 2.1: select a compatibility (non-Core) profile with GL version 2.1
 * 3.0: select a compatibility (non-Core) profile with GL version 3.0
 * 3.0FC: select a Core+Forward Compatible profile with GL version 3.0
 * 3.1: select a Core profile with GL version 3.1
 * 3.1FC: select a Core+Forward Compatible profile with GL version 3.1
 */
void
_mesa_override_gl_version(struct gl_context *ctx)
{
   int version;
   GLboolean fwd_context;

   get_gl_override(&version, &fwd_context);

   if (version > 0) {
      ctx->Version = version;
      if (version >= 30 && fwd_context) {
         ctx->API = API_OPENGL_CORE;
         ctx->Const.ContextFlags |= GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT;
      } else if (version >= 31) {
         ctx->API = API_OPENGL_CORE;
      } else {
         ctx->API = API_OPENGL_COMPAT;
      }
      create_version_string(ctx, "");
   }
}

/**
 * Returns the gl override value
 *
 * version > 0 indicates there is an override requested
 */
int
_mesa_get_gl_version_override(void)
{
   int version;
   GLboolean fwd_context;

   get_gl_override(&version, &fwd_context);

   return version;
}

/**
 * Override the context's GLSL version if the environment variable
 * MESA_GLSL_VERSION_OVERRIDE is set. Valid values for
 * MESA_GLSL_VERSION_OVERRIDE are integers, such as "130".
 */
void
_mesa_override_glsl_version(struct gl_context *ctx)
{
   const char *env_var = "MESA_GLSL_VERSION_OVERRIDE";
   const char *version;
   int n;

   version = getenv(env_var);
   if (!version) {
      return;
   }

   n = sscanf(version, "%u", &ctx->Const.GLSLVersion);
   if (n != 1) {
      fprintf(stderr, "error: invalid value for %s: %s\n", env_var, version);
      return;
   }
}

/**
 * Examine enabled GL extensions to determine GL version.
 */
static void
compute_version(struct gl_context *ctx)
{
   GLuint major, minor;

   const GLboolean ver_1_3 = (ctx->Extensions.ARB_texture_border_clamp &&
                              ctx->Extensions.ARB_texture_cube_map &&
                              ctx->Extensions.ARB_texture_env_combine &&
                              ctx->Extensions.ARB_texture_env_dot3);
   const GLboolean ver_1_4 = (ver_1_3 &&
                              ctx->Extensions.ARB_depth_texture &&
                              ctx->Extensions.ARB_shadow &&
                              ctx->Extensions.ARB_texture_env_crossbar &&
                              ctx->Extensions.EXT_blend_color &&
                              ctx->Extensions.EXT_blend_func_separate &&
                              ctx->Extensions.EXT_blend_minmax &&
                              ctx->Extensions.EXT_point_parameters);
   const GLboolean ver_1_5 = (ver_1_4 &&
                              ctx->Extensions.ARB_occlusion_query);
   const GLboolean ver_2_0 = (ver_1_5 &&
                              ctx->Extensions.ARB_point_sprite &&
                              ctx->Extensions.ARB_vertex_shader &&
                              ctx->Extensions.ARB_fragment_shader &&
                              ctx->Extensions.ARB_texture_non_power_of_two &&
                              ctx->Extensions.EXT_blend_equation_separate &&

			      /* Technically, 2.0 requires the functionality
			       * of the EXT version.  Enable 2.0 if either
			       * extension is available, and assume that a
			       * driver that only exposes the ATI extension
			       * will fallback to software when necessary.
			       */
			      (ctx->Extensions.EXT_stencil_two_side
			       || ctx->Extensions.ATI_separate_stencil));
   const GLboolean ver_2_1 = (ver_2_0 &&
                              ctx->Extensions.EXT_pixel_buffer_object &&
                              ctx->Extensions.EXT_texture_sRGB);
   const GLboolean ver_3_0 = (ver_2_1 &&
                              ctx->Const.GLSLVersion >= 130 &&
                              (ctx->Const.MaxSamples >= 4 || ctx->Const.FakeSWMSAA) &&
                              (ctx->API == API_OPENGL_CORE ||
                               ctx->Extensions.ARB_color_buffer_float) &&
                              ctx->Extensions.ARB_depth_buffer_float &&
                              ctx->Extensions.ARB_half_float_vertex &&
                              ctx->Extensions.ARB_map_buffer_range &&
                              ctx->Extensions.ARB_shader_texture_lod &&
                              ctx->Extensions.ARB_texture_float &&
                              ctx->Extensions.ARB_texture_rg &&
                              ctx->Extensions.ARB_texture_compression_rgtc &&
                              ctx->Extensions.EXT_draw_buffers2 &&
                              ctx->Extensions.ARB_framebuffer_object &&
                              ctx->Extensions.EXT_framebuffer_sRGB &&
                              ctx->Extensions.EXT_packed_float &&
                              ctx->Extensions.EXT_texture_array &&
                              ctx->Extensions.EXT_texture_shared_exponent &&
                              ctx->Extensions.EXT_transform_feedback &&
                              ctx->Extensions.NV_conditional_render);
   const GLboolean ver_3_1 = (ver_3_0 &&
                              ctx->Const.GLSLVersion >= 140 &&
                              ctx->Extensions.ARB_draw_instanced &&
                              ctx->Extensions.ARB_texture_buffer_object &&
                              ctx->Extensions.ARB_uniform_buffer_object &&
                              ctx->Extensions.EXT_texture_snorm &&
                              ctx->Extensions.NV_primitive_restart &&
                              ctx->Extensions.NV_texture_rectangle &&
                              ctx->Const.Program[MESA_SHADER_VERTEX].MaxTextureImageUnits >= 16);
   const GLboolean ver_3_2 = (ver_3_1 &&
                              ctx->Const.GLSLVersion >= 150 &&
                              ctx->Extensions.ARB_depth_clamp &&
                              ctx->Extensions.ARB_draw_elements_base_vertex &&
                              ctx->Extensions.ARB_fragment_coord_conventions &&
                              ctx->Extensions.EXT_provoking_vertex &&
                              ctx->Extensions.ARB_seamless_cube_map &&
                              ctx->Extensions.ARB_sync &&
                              ctx->Extensions.ARB_texture_multisample &&
                              ctx->Extensions.EXT_vertex_array_bgra);
   const GLboolean ver_3_3 = (ver_3_2 &&
                              ctx->Const.GLSLVersion >= 330 &&
                              ctx->Extensions.ARB_blend_func_extended &&
                              ctx->Extensions.ARB_explicit_attrib_location &&
                              ctx->Extensions.ARB_instanced_arrays &&
                              ctx->Extensions.ARB_occlusion_query2 &&
                              ctx->Extensions.ARB_shader_bit_encoding &&
                              ctx->Extensions.ARB_texture_rgb10_a2ui &&
                              ctx->Extensions.ARB_timer_query &&
                              ctx->Extensions.ARB_vertex_type_2_10_10_10_rev &&
                              ctx->Extensions.EXT_texture_swizzle);
                              /* ARB_sampler_objects is always enabled in mesa */

   if (ver_3_3) {
      major = 3;
      minor = 3;
   }
   else if (ver_3_2) {
      major = 3;
      minor = 2;
   }
   else if (ver_3_1) {
      major = 3;
      minor = 1;
   }
   else if (ver_3_0) {
      major = 3;
      minor = 0;
   }
   else if (ver_2_1) {
      major = 2;
      minor = 1;
   }
   else if (ver_2_0) {
      major = 2;
      minor = 0;
   }
   else if (ver_1_5) {
      major = 1;
      minor = 5;
   }
   else if (ver_1_4) {
      major = 1;
      minor = 4;
   }
   else if (ver_1_3) {
      major = 1;
      minor = 3;
   }
   else {
      major = 1;
      minor = 2;
   }

   ctx->Version = major * 10 + minor;

   create_version_string(ctx, "");
}

static void
compute_version_es1(struct gl_context *ctx)
{
   /* OpenGL ES 1.0 is derived from OpenGL 1.3 */
   const GLboolean ver_1_0 = (ctx->Extensions.ARB_texture_env_combine &&
                              ctx->Extensions.ARB_texture_env_dot3);
   /* OpenGL ES 1.1 is derived from OpenGL 1.5 */
   const GLboolean ver_1_1 = (ver_1_0 &&
                              ctx->Extensions.EXT_point_parameters);

   if (ver_1_1) {
      ctx->Version = 11;
   } else if (ver_1_0) {
      ctx->Version = 10;
   } else {
      _mesa_problem(ctx, "Incomplete OpenGL ES 1.0 support.");
   }

   create_version_string(ctx, "OpenGL ES-CM ");
}

static void
compute_version_es2(struct gl_context *ctx)
{
   /* OpenGL ES 2.0 is derived from OpenGL 2.0 */
   const GLboolean ver_2_0 = (ctx->Extensions.ARB_texture_cube_map &&
                              ctx->Extensions.EXT_blend_color &&
                              ctx->Extensions.EXT_blend_func_separate &&
                              ctx->Extensions.EXT_blend_minmax &&
                              ctx->Extensions.ARB_vertex_shader &&
                              ctx->Extensions.ARB_fragment_shader &&
                              ctx->Extensions.ARB_texture_non_power_of_two &&
                              ctx->Extensions.EXT_blend_equation_separate);
   /* FINISHME: This list isn't quite right. */
   const GLboolean ver_3_0 = (ctx->Extensions.ARB_half_float_vertex &&
                              ctx->Extensions.ARB_internalformat_query &&
                              ctx->Extensions.ARB_map_buffer_range &&
                              ctx->Extensions.ARB_shader_texture_lod &&
                              ctx->Extensions.ARB_texture_float &&
                              ctx->Extensions.ARB_texture_rg &&
                              ctx->Extensions.ARB_texture_compression_rgtc &&
                              ctx->Extensions.EXT_draw_buffers2 &&
                              /* ctx->Extensions.ARB_framebuffer_object && */
                              ctx->Extensions.EXT_framebuffer_sRGB &&
                              ctx->Extensions.EXT_packed_float &&
                              ctx->Extensions.EXT_texture_array &&
                              ctx->Extensions.EXT_texture_shared_exponent &&
                              ctx->Extensions.EXT_transform_feedback &&
                              ctx->Extensions.NV_conditional_render &&
                              ctx->Extensions.ARB_draw_instanced &&
                              ctx->Extensions.ARB_uniform_buffer_object &&
                              ctx->Extensions.EXT_texture_snorm &&
                              ctx->Extensions.NV_primitive_restart &&
                              ctx->Extensions.OES_depth_texture_cube_map);
   if (ver_3_0) {
      ctx->Version = 30;
   } else if (ver_2_0) {
      ctx->Version = 20;
   } else {
      _mesa_problem(ctx, "Incomplete OpenGL ES 2.0 support.");
   }

   create_version_string(ctx, "OpenGL ES ");
}

/**
 * Set the context's Version and VersionString fields.
 * This should only be called once as part of context initialization
 * or to perform version check for GLX_ARB_create_context_profile.
 */
void
_mesa_compute_version(struct gl_context *ctx)
{
   if (ctx->Version)
      return;

   switch (ctx->API) {
   case API_OPENGL_COMPAT:
      /* Disable GLSL 1.40 and later for legacy contexts.
       * This disallows creation of the GL 3.1 compatibility context. */
      if (ctx->Const.GLSLVersion > 130) {
         ctx->Const.GLSLVersion = 130;
      }
      /* fall through */
   case API_OPENGL_CORE:
      compute_version(ctx);
      break;
   case API_OPENGLES:
      compute_version_es1(ctx);
      break;
   case API_OPENGLES2:
      compute_version_es2(ctx);
      break;
   }

}
@


1.8
log
@Merge Mesa 10.2.9
@
text
@@


1.7
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d60 1
a60 2
get_gl_override(int *version, GLboolean *fwd_context,
                GLboolean *compat_context)
a66 1
   static GLboolean compat_suffix = GL_FALSE;
a73 1
         compat_suffix = check_for_ending(version_str, "COMPAT");
a89 1
   *compat_context = compat_suffix;
d127 2
a128 3
bool
_mesa_override_gl_version_contextless(struct gl_constants *consts,
                                      gl_api *apiOut, GLuint *versionOut)
d131 1
a131 1
   GLboolean fwd_context, compat_context;
d133 1
a133 1
   get_gl_override(&version, &fwd_context, &compat_context);
d136 1
a136 1
      *versionOut = version;
d138 4
a141 4
         *apiOut = API_OPENGL_CORE;
         consts->ContextFlags |= GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT;
      } else if (version >= 31 && !compat_context) {
         *apiOut = API_OPENGL_CORE;
d143 1
a143 1
         *apiOut = API_OPENGL_COMPAT;
a144 10
      return GL_TRUE;
   }
   return GL_FALSE;
}

void
_mesa_override_gl_version(struct gl_context *ctx)
{
   if (_mesa_override_gl_version_contextless(&ctx->Const, &ctx->API,
                                             &ctx->Version)) {
d158 1
a158 1
   GLboolean fwd_context, compat_context;
d160 1
a160 1
   get_gl_override(&version, &fwd_context, &compat_context);
d171 1
a171 1
_mesa_override_glsl_version(struct gl_constants *consts)
d182 1
a182 1
   n = sscanf(version, "%u", &consts->GLSLVersion);
d192 2
a193 3
static GLuint
compute_version(const struct gl_extensions *extensions,
                const struct gl_constants *consts, gl_api api)
d195 1
a195 1
   GLuint major, minor, version;
d197 4
a200 4
   const GLboolean ver_1_3 = (extensions->ARB_texture_border_clamp &&
                              extensions->ARB_texture_cube_map &&
                              extensions->ARB_texture_env_combine &&
                              extensions->ARB_texture_env_dot3);
d202 7
a208 7
                              extensions->ARB_depth_texture &&
                              extensions->ARB_shadow &&
                              extensions->ARB_texture_env_crossbar &&
                              extensions->EXT_blend_color &&
                              extensions->EXT_blend_func_separate &&
                              extensions->EXT_blend_minmax &&
                              extensions->EXT_point_parameters);
d210 1
a210 1
                              extensions->ARB_occlusion_query);
d212 5
a216 5
                              extensions->ARB_point_sprite &&
                              extensions->ARB_vertex_shader &&
                              extensions->ARB_fragment_shader &&
                              extensions->ARB_texture_non_power_of_two &&
                              extensions->EXT_blend_equation_separate &&
d224 2
a225 2
			      (extensions->EXT_stencil_two_side
			       || extensions->ATI_separate_stencil));
d227 2
a228 2
                              extensions->EXT_pixel_buffer_object &&
                              extensions->EXT_texture_sRGB);
d230 19
a248 19
                              consts->GLSLVersion >= 130 &&
                              (consts->MaxSamples >= 4 || consts->FakeSWMSAA) &&
                              (api == API_OPENGL_CORE ||
                               extensions->ARB_color_buffer_float) &&
                              extensions->ARB_depth_buffer_float &&
                              extensions->ARB_half_float_vertex &&
                              extensions->ARB_map_buffer_range &&
                              extensions->ARB_shader_texture_lod &&
                              extensions->ARB_texture_float &&
                              extensions->ARB_texture_rg &&
                              extensions->ARB_texture_compression_rgtc &&
                              extensions->EXT_draw_buffers2 &&
                              extensions->ARB_framebuffer_object &&
                              extensions->EXT_framebuffer_sRGB &&
                              extensions->EXT_packed_float &&
                              extensions->EXT_texture_array &&
                              extensions->EXT_texture_shared_exponent &&
                              extensions->EXT_transform_feedback &&
                              extensions->NV_conditional_render);
d250 8
a257 8
                              consts->GLSLVersion >= 140 &&
                              extensions->ARB_draw_instanced &&
                              extensions->ARB_texture_buffer_object &&
                              extensions->ARB_uniform_buffer_object &&
                              extensions->EXT_texture_snorm &&
                              extensions->NV_primitive_restart &&
                              extensions->NV_texture_rectangle &&
                              consts->Program[MESA_SHADER_VERTEX].MaxTextureImageUnits >= 16);
d259 9
a267 9
                              consts->GLSLVersion >= 150 &&
                              extensions->ARB_depth_clamp &&
                              extensions->ARB_draw_elements_base_vertex &&
                              extensions->ARB_fragment_coord_conventions &&
                              extensions->EXT_provoking_vertex &&
                              extensions->ARB_seamless_cube_map &&
                              extensions->ARB_sync &&
                              extensions->ARB_texture_multisample &&
                              extensions->EXT_vertex_array_bgra);
d269 10
a278 10
                              consts->GLSLVersion >= 330 &&
                              extensions->ARB_blend_func_extended &&
                              extensions->ARB_explicit_attrib_location &&
                              extensions->ARB_instanced_arrays &&
                              extensions->ARB_occlusion_query2 &&
                              extensions->ARB_shader_bit_encoding &&
                              extensions->ARB_texture_rgb10_a2ui &&
                              extensions->ARB_timer_query &&
                              extensions->ARB_vertex_type_2_10_10_10_rev &&
                              extensions->EXT_texture_swizzle);
d322 1
a322 1
   version = major * 10 + minor;
d324 1
a324 4
   if (api == API_OPENGL_CORE && version < 31)
      return 0;

   return version;
d327 2
a328 2
static GLuint
compute_version_es1(const struct gl_extensions *extensions)
d331 2
a332 2
   const GLboolean ver_1_0 = (extensions->ARB_texture_env_combine &&
                              extensions->ARB_texture_env_dot3);
d335 1
a335 1
                              extensions->EXT_point_parameters);
d338 1
a338 1
      return 11;
d340 1
a340 1
      return 10;
d342 1
a342 1
      return 0;
d344 2
d348 2
a349 2
static GLuint
compute_version_es2(const struct gl_extensions *extensions)
d352 8
a359 8
   const GLboolean ver_2_0 = (extensions->ARB_texture_cube_map &&
                              extensions->EXT_blend_color &&
                              extensions->EXT_blend_func_separate &&
                              extensions->EXT_blend_minmax &&
                              extensions->ARB_vertex_shader &&
                              extensions->ARB_fragment_shader &&
                              extensions->ARB_texture_non_power_of_two &&
                              extensions->EXT_blend_equation_separate);
d361 20
a380 18
   const GLboolean ver_3_0 = (extensions->ARB_half_float_vertex &&
                              extensions->ARB_internalformat_query &&
                              extensions->ARB_map_buffer_range &&
                              extensions->ARB_shader_texture_lod &&
                              extensions->ARB_texture_float &&
                              extensions->ARB_texture_rg &&
                              extensions->EXT_draw_buffers2 &&
                              /* extensions->ARB_framebuffer_object && */
                              extensions->EXT_framebuffer_sRGB &&
                              extensions->EXT_packed_float &&
                              extensions->EXT_texture_array &&
                              extensions->EXT_texture_shared_exponent &&
                              extensions->EXT_transform_feedback &&
                              extensions->ARB_draw_instanced &&
                              extensions->ARB_uniform_buffer_object &&
                              extensions->EXT_texture_snorm &&
                              extensions->NV_primitive_restart &&
                              extensions->OES_depth_texture_cube_map);
d382 1
a382 1
      return 30;
d384 1
a384 1
      return 20;
d386 1
a386 1
      return 0;
a387 1
}
d389 1
a389 20
GLuint
_mesa_get_version(const struct gl_extensions *extensions,
                  struct gl_constants *consts, gl_api api)
{
   switch (api) {
   case API_OPENGL_COMPAT:
      /* Disable GLSL 1.40 and later for legacy contexts.
       * This disallows creation of the GL 3.1 compatibility context. */
      if (consts->GLSLVersion > 130) {
         consts->GLSLVersion = 130;
      }
      /* fall through */
   case API_OPENGL_CORE:
      return compute_version(extensions, consts, api);
   case API_OPENGLES:
      return compute_version_es1(extensions);
   case API_OPENGLES2:
      return compute_version_es2(extensions);
   }
   return 0;
a402 2
   ctx->Version = _mesa_get_version(&ctx->Extensions, &ctx->Const, ctx->API);

d405 6
d412 1
a412 1
      create_version_string(ctx, "");
a413 1

d415 1
a415 5
      if (!ctx->Version) {
         _mesa_problem(ctx, "Incomplete OpenGL ES 1.0 support.");
         return;
      }
      create_version_string(ctx, "OpenGL ES-CM ");
a416 1

d418 1
a418 5
      if (!ctx->Version) {
         _mesa_problem(ctx, "Incomplete OpenGL ES 2.0 support.");
         return;
      }
      create_version_string(ctx, "OpenGL ES ");
d421 1
@


1.6
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d60 2
a61 1
get_gl_override(int *version, GLboolean *fwd_context)
d68 1
d76 1
d93 1
d131 3
a133 2
void
_mesa_override_gl_version(struct gl_context *ctx)
d136 1
a136 1
   GLboolean fwd_context;
d138 1
a138 1
   get_gl_override(&version, &fwd_context);
d141 1
a141 1
      ctx->Version = version;
d143 4
a146 4
         ctx->API = API_OPENGL_CORE;
         ctx->Const.ContextFlags |= GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT;
      } else if (version >= 31) {
         ctx->API = API_OPENGL_CORE;
d148 1
a148 1
         ctx->API = API_OPENGL_COMPAT;
d150 10
d173 1
a173 1
   GLboolean fwd_context;
d175 1
a175 1
   get_gl_override(&version, &fwd_context);
d186 1
a186 1
_mesa_override_glsl_version(struct gl_context *ctx)
d197 1
a197 1
   n = sscanf(version, "%u", &ctx->Const.GLSLVersion);
d207 3
a209 2
static void
compute_version(struct gl_context *ctx)
d211 1
a211 1
   GLuint major, minor;
d213 4
a216 4
   const GLboolean ver_1_3 = (ctx->Extensions.ARB_texture_border_clamp &&
                              ctx->Extensions.ARB_texture_cube_map &&
                              ctx->Extensions.ARB_texture_env_combine &&
                              ctx->Extensions.ARB_texture_env_dot3);
d218 7
a224 7
                              ctx->Extensions.ARB_depth_texture &&
                              ctx->Extensions.ARB_shadow &&
                              ctx->Extensions.ARB_texture_env_crossbar &&
                              ctx->Extensions.EXT_blend_color &&
                              ctx->Extensions.EXT_blend_func_separate &&
                              ctx->Extensions.EXT_blend_minmax &&
                              ctx->Extensions.EXT_point_parameters);
d226 1
a226 1
                              ctx->Extensions.ARB_occlusion_query);
d228 5
a232 5
                              ctx->Extensions.ARB_point_sprite &&
                              ctx->Extensions.ARB_vertex_shader &&
                              ctx->Extensions.ARB_fragment_shader &&
                              ctx->Extensions.ARB_texture_non_power_of_two &&
                              ctx->Extensions.EXT_blend_equation_separate &&
d240 2
a241 2
			      (ctx->Extensions.EXT_stencil_two_side
			       || ctx->Extensions.ATI_separate_stencil));
d243 2
a244 2
                              ctx->Extensions.EXT_pixel_buffer_object &&
                              ctx->Extensions.EXT_texture_sRGB);
d246 19
a264 19
                              ctx->Const.GLSLVersion >= 130 &&
                              (ctx->Const.MaxSamples >= 4 || ctx->Const.FakeSWMSAA) &&
                              (ctx->API == API_OPENGL_CORE ||
                               ctx->Extensions.ARB_color_buffer_float) &&
                              ctx->Extensions.ARB_depth_buffer_float &&
                              ctx->Extensions.ARB_half_float_vertex &&
                              ctx->Extensions.ARB_map_buffer_range &&
                              ctx->Extensions.ARB_shader_texture_lod &&
                              ctx->Extensions.ARB_texture_float &&
                              ctx->Extensions.ARB_texture_rg &&
                              ctx->Extensions.ARB_texture_compression_rgtc &&
                              ctx->Extensions.EXT_draw_buffers2 &&
                              ctx->Extensions.ARB_framebuffer_object &&
                              ctx->Extensions.EXT_framebuffer_sRGB &&
                              ctx->Extensions.EXT_packed_float &&
                              ctx->Extensions.EXT_texture_array &&
                              ctx->Extensions.EXT_texture_shared_exponent &&
                              ctx->Extensions.EXT_transform_feedback &&
                              ctx->Extensions.NV_conditional_render);
d266 8
a273 8
                              ctx->Const.GLSLVersion >= 140 &&
                              ctx->Extensions.ARB_draw_instanced &&
                              ctx->Extensions.ARB_texture_buffer_object &&
                              ctx->Extensions.ARB_uniform_buffer_object &&
                              ctx->Extensions.EXT_texture_snorm &&
                              ctx->Extensions.NV_primitive_restart &&
                              ctx->Extensions.NV_texture_rectangle &&
                              ctx->Const.Program[MESA_SHADER_VERTEX].MaxTextureImageUnits >= 16);
d275 9
a283 9
                              ctx->Const.GLSLVersion >= 150 &&
                              ctx->Extensions.ARB_depth_clamp &&
                              ctx->Extensions.ARB_draw_elements_base_vertex &&
                              ctx->Extensions.ARB_fragment_coord_conventions &&
                              ctx->Extensions.EXT_provoking_vertex &&
                              ctx->Extensions.ARB_seamless_cube_map &&
                              ctx->Extensions.ARB_sync &&
                              ctx->Extensions.ARB_texture_multisample &&
                              ctx->Extensions.EXT_vertex_array_bgra);
d285 10
a294 10
                              ctx->Const.GLSLVersion >= 330 &&
                              ctx->Extensions.ARB_blend_func_extended &&
                              ctx->Extensions.ARB_explicit_attrib_location &&
                              ctx->Extensions.ARB_instanced_arrays &&
                              ctx->Extensions.ARB_occlusion_query2 &&
                              ctx->Extensions.ARB_shader_bit_encoding &&
                              ctx->Extensions.ARB_texture_rgb10_a2ui &&
                              ctx->Extensions.ARB_timer_query &&
                              ctx->Extensions.ARB_vertex_type_2_10_10_10_rev &&
                              ctx->Extensions.EXT_texture_swizzle);
d338 1
a338 1
   ctx->Version = major * 10 + minor;
d340 4
a343 1
   create_version_string(ctx, "");
d346 2
a347 2
static void
compute_version_es1(struct gl_context *ctx)
d350 2
a351 2
   const GLboolean ver_1_0 = (ctx->Extensions.ARB_texture_env_combine &&
                              ctx->Extensions.ARB_texture_env_dot3);
d354 1
a354 1
                              ctx->Extensions.EXT_point_parameters);
d357 1
a357 1
      ctx->Version = 11;
d359 1
a359 1
      ctx->Version = 10;
d361 1
a361 1
      _mesa_problem(ctx, "Incomplete OpenGL ES 1.0 support.");
a362 2

   create_version_string(ctx, "OpenGL ES-CM ");
d365 2
a366 2
static void
compute_version_es2(struct gl_context *ctx)
d369 8
a376 8
   const GLboolean ver_2_0 = (ctx->Extensions.ARB_texture_cube_map &&
                              ctx->Extensions.EXT_blend_color &&
                              ctx->Extensions.EXT_blend_func_separate &&
                              ctx->Extensions.EXT_blend_minmax &&
                              ctx->Extensions.ARB_vertex_shader &&
                              ctx->Extensions.ARB_fragment_shader &&
                              ctx->Extensions.ARB_texture_non_power_of_two &&
                              ctx->Extensions.EXT_blend_equation_separate);
d378 18
a395 20
   const GLboolean ver_3_0 = (ctx->Extensions.ARB_half_float_vertex &&
                              ctx->Extensions.ARB_internalformat_query &&
                              ctx->Extensions.ARB_map_buffer_range &&
                              ctx->Extensions.ARB_shader_texture_lod &&
                              ctx->Extensions.ARB_texture_float &&
                              ctx->Extensions.ARB_texture_rg &&
                              ctx->Extensions.ARB_texture_compression_rgtc &&
                              ctx->Extensions.EXT_draw_buffers2 &&
                              /* ctx->Extensions.ARB_framebuffer_object && */
                              ctx->Extensions.EXT_framebuffer_sRGB &&
                              ctx->Extensions.EXT_packed_float &&
                              ctx->Extensions.EXT_texture_array &&
                              ctx->Extensions.EXT_texture_shared_exponent &&
                              ctx->Extensions.EXT_transform_feedback &&
                              ctx->Extensions.NV_conditional_render &&
                              ctx->Extensions.ARB_draw_instanced &&
                              ctx->Extensions.ARB_uniform_buffer_object &&
                              ctx->Extensions.EXT_texture_snorm &&
                              ctx->Extensions.NV_primitive_restart &&
                              ctx->Extensions.OES_depth_texture_cube_map);
d397 1
a397 1
      ctx->Version = 30;
d399 1
a399 1
      ctx->Version = 20;
d401 1
a401 1
      _mesa_problem(ctx, "Incomplete OpenGL ES 2.0 support.");
d403 1
d405 20
a424 1
   create_version_string(ctx, "OpenGL ES ");
d438 2
a441 6
      /* Disable GLSL 1.40 and later for legacy contexts.
       * This disallows creation of the GL 3.1 compatibility context. */
      if (ctx->Const.GLSLVersion > 130) {
         ctx->Const.GLSLVersion = 130;
      }
      /* fall through */
d443 1
a443 1
      compute_version(ctx);
d445 1
d447 5
a451 1
      compute_version_es1(ctx);
d453 1
d455 5
a459 1
      compute_version_es2(ctx);
a461 1

@


1.5
log
@Merge Mesa 9.2.0
@
text
@a226 1
                              ctx->Const.GLSLVersion >= 120 &&
d231 1
a231 1
                              ctx->Const.MaxSamples >= 4 &&
a234 1
                              ctx->Extensions.ARB_half_float_pixel &&
d257 1
a257 1
                              ctx->Const.VertexProgram.MaxTextureImageUnits >= 16);
a262 1
                              ctx->Extensions.ARB_geometry_shader4 &&
@


1.4
log
@Don't try to include an empty header
@
text
@d19 4
a22 3
 * THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
d29 1
d31 68
d100 88
a190 1
 * Return major and minor version numbers.
a195 1
   static const int max = 100;
d197 1
a197 4
   const GLboolean ver_1_3 = (ctx->Extensions.ARB_multisample &&
                              ctx->Extensions.ARB_multitexture &&
                              ctx->Extensions.ARB_texture_border_clamp &&
                              ctx->Extensions.ARB_texture_compression &&
a198 1
                              ctx->Extensions.EXT_texture_env_add &&
a204 2
                              ctx->Extensions.ARB_texture_mirrored_repeat &&
                              ctx->Extensions.ARB_window_pos &&
d208 1
a208 8
                              ctx->Extensions.EXT_blend_subtract &&
                              ctx->Extensions.EXT_fog_coord &&
                              ctx->Extensions.EXT_multi_draw_arrays &&
                              ctx->Extensions.EXT_point_parameters &&
                              ctx->Extensions.EXT_secondary_color &&
                              ctx->Extensions.EXT_stencil_wrap &&
                              ctx->Extensions.EXT_texture_lod_bias &&
                              ctx->Extensions.SGIS_generate_mipmap);
d210 1
a210 3
                              ctx->Extensions.ARB_occlusion_query &&
                              ctx->Extensions.ARB_vertex_buffer_object &&
                              ctx->Extensions.EXT_shadow_funcs);
a211 1
                              ctx->Extensions.ARB_draw_buffers &&
a212 1
                              ctx->Extensions.ARB_shader_objects &&
d231 4
a234 1
                              ctx->Extensions.ARB_color_buffer_float &&
d237 1
d239 1
a242 1
                              ctx->Extensions.APPLE_vertex_array_object &&
d244 1
a244 3
                              ctx->Extensions.EXT_framebuffer_blit &&
                              ctx->Extensions.EXT_framebuffer_multisample &&
                              ctx->Extensions.EXT_framebuffer_object &&
a245 1
                              ctx->Extensions.EXT_packed_depth_stencil &&
a247 1
                              ctx->Extensions.EXT_texture_integer &&
d252 1
a252 1
                              ctx->Extensions.ARB_copy_buffer &&
d259 1
a259 1
                              ctx->Const.MaxVertexTextureImageUnits >= 16);
d261 1
d272 1
d277 1
a277 1
                              ctx->Extensions.ARB_sampler_objects &&
d282 1
d325 3
a327 12
   ctx->VersionMajor = major;
   ctx->VersionMinor = minor;
   ctx->VersionString = (char *) malloc(max);
   if (ctx->VersionString) {
      _mesa_snprintf(ctx->VersionString, max,
		     "%u.%u Mesa " MESA_VERSION_STRING
#ifdef MESA_GIT_SHA1
		     " (" MESA_GIT_SHA1 ")"
#endif
		     ,
		     ctx->VersionMajor, ctx->VersionMinor);
   }
a332 2
   static const int max = 100;

d334 1
a334 5
   const GLboolean ver_1_0 = (ctx->Extensions.ARB_multisample &&
                              ctx->Extensions.ARB_multitexture &&
                              ctx->Extensions.ARB_texture_compression &&
                              ctx->Extensions.EXT_texture_env_add &&
                              ctx->Extensions.ARB_texture_env_combine &&
d338 1
a338 3
                              ctx->Extensions.EXT_point_parameters &&
                              ctx->Extensions.SGIS_generate_mipmap &&
                              ctx->Extensions.ARB_vertex_buffer_object);
d341 1
a341 2
      ctx->VersionMajor = 1;
      ctx->VersionMinor = 1;
d343 1
a343 2
      ctx->VersionMajor = 1;
      ctx->VersionMinor = 0;
d348 1
a348 6
   ctx->VersionString = (char *) malloc(max);
   if (ctx->VersionString) {
      _mesa_snprintf(ctx->VersionString, max,
		     "OpenGL ES-CM 1.%d Mesa " MESA_VERSION_STRING,
		     ctx->VersionMinor);
   }
a353 2
   static const int max = 100;

d355 1
a355 5
   const GLboolean ver_2_0 = (ctx->Extensions.ARB_multisample &&
                              ctx->Extensions.ARB_multitexture &&
                              ctx->Extensions.ARB_texture_compression &&
                              ctx->Extensions.ARB_texture_cube_map &&
                              ctx->Extensions.ARB_texture_mirrored_repeat &&
a358 4
                              ctx->Extensions.EXT_blend_subtract &&
                              ctx->Extensions.EXT_stencil_wrap &&
                              ctx->Extensions.ARB_vertex_buffer_object &&
                              ctx->Extensions.ARB_shader_objects &&
d363 25
a387 3
   if (ver_2_0) {
      ctx->VersionMajor = 2;
      ctx->VersionMinor = 0;
d392 1
a392 5
   ctx->VersionString = (char *) malloc(max);
   if (ctx->VersionString) {
      _mesa_snprintf(ctx->VersionString, max,
		     "OpenGL ES 2.0 Mesa " MESA_VERSION_STRING);
   }
d396 1
a396 1
 * Set the context's VersionMajor, VersionMinor, VersionString fields.
d403 1
a403 1
   if (ctx->VersionMajor)
d407 8
a414 1
   case API_OPENGL:
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a27 1
#include "git_sha1.h"
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d25 2
a26 1
#include "context.h"
d28 1
d93 2
d118 1
d189 5
a193 1
		     "%u.%u Mesa " MESA_VERSION_STRING,
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d35 1
a35 1
compute_version(const GLcontext *ctx, GLuint *major, GLuint *minor)
d37 3
d87 1
a87 1
                              ctx->Extensions.ARB_shading_language_120 &&
d90 67
a156 3
   if (ver_2_1) {
      *major = 2;
      *minor = 1;
d159 2
a160 2
      *major = 2;
      *minor = 0;
d163 2
a164 2
      *major = 1;
      *minor = 5;
d167 2
a168 2
      *major = 1;
      *minor = 4;
d171 2
a172 2
      *major = 1;
      *minor = 3;
d175 47
a221 2
      *major = 1;
      *minor = 2;
d225 35
d263 2
a264 1
 * This should only be called once as part of context initialization.
d267 1
a267 1
_mesa_compute_version(GLcontext *ctx)
d269 2
a270 1
   static const int max = 100;
d272 10
a281 6
   compute_version(ctx, &ctx->VersionMajor, &ctx->VersionMinor);
   
   ctx->VersionString = (char *) malloc(max);
   if (ctx->VersionString) {
      _mesa_snprintf(ctx->VersionString, max, "%u.%u Mesa " MESA_VERSION_STRING,
	       ctx->VersionMajor, ctx->VersionMinor);
d283 1
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d35 1
a35 1
compute_version(struct gl_context *ctx)
a36 3
   GLuint major, minor;
   static const int max = 100;

d84 1
a84 1
                              ctx->Const.GLSLVersion >= 120 &&
d87 3
a89 67
   const GLboolean ver_3_0 = (ver_2_1 &&
                              ctx->Extensions.ARB_half_float_pixel &&
                              ctx->Extensions.ARB_map_buffer_range &&
                              ctx->Extensions.ARB_texture_float &&
                              ctx->Extensions.ARB_texture_rg &&
                              ctx->Extensions.ARB_texture_compression_rgtc &&
                              ctx->Extensions.APPLE_vertex_array_object &&
                              ctx->Extensions.EXT_draw_buffers2 &&
                              ctx->Extensions.EXT_framebuffer_blit &&
                              ctx->Extensions.EXT_framebuffer_multisample &&
                              ctx->Extensions.EXT_framebuffer_object &&
                              ctx->Extensions.EXT_framebuffer_sRGB &&
                              ctx->Extensions.EXT_packed_depth_stencil &&
                              ctx->Extensions.EXT_packed_float &&
                              ctx->Extensions.EXT_texture_array &&
                              ctx->Extensions.EXT_texture_integer &&
                              ctx->Extensions.EXT_texture_shared_exponent &&
                              ctx->Extensions.EXT_transform_feedback &&
                              ctx->Extensions.NV_conditional_render);
   const GLboolean ver_3_1 = (ver_3_0 &&
                              ctx->Extensions.ARB_copy_buffer &&
                              ctx->Extensions.ARB_draw_instanced &&
                              ctx->Extensions.ARB_texture_buffer_object &&
                              ctx->Extensions.ARB_uniform_buffer_object &&
                              ctx->Extensions.NV_primitive_restart &&
                              ctx->Extensions.NV_texture_rectangle &&
                              ctx->Const.MaxVertexTextureImageUnits >= 16);
   const GLboolean ver_3_2 = (ver_3_1 &&
                              ctx->Extensions.ARB_depth_clamp &&
                              ctx->Extensions.ARB_draw_elements_base_vertex &&
                              ctx->Extensions.ARB_fragment_coord_conventions &&
                              ctx->Extensions.ARB_geometry_shader4 &&
                              ctx->Extensions.EXT_provoking_vertex &&
                              ctx->Extensions.ARB_seamless_cube_map &&
                              ctx->Extensions.ARB_sync &&
                              ctx->Extensions.ARB_texture_multisample &&
                              ctx->Extensions.EXT_vertex_array_bgra);
   const GLboolean ver_3_3 = (ver_3_2 &&
                              ctx->Extensions.ARB_blend_func_extended &&
                              ctx->Extensions.ARB_explicit_attrib_location &&
                              ctx->Extensions.ARB_instanced_arrays &&
                              ctx->Extensions.ARB_occlusion_query2 &&
                              ctx->Extensions.ARB_sampler_objects &&
                              ctx->Extensions.ARB_texture_rgb10_a2ui &&
                              ctx->Extensions.ARB_timer_query &&
                              ctx->Extensions.ARB_vertex_type_2_10_10_10_rev &&
                              ctx->Extensions.EXT_texture_swizzle);

   if (ver_3_3) {
      major = 3;
      minor = 3;
   }
   else if (ver_3_2) {
      major = 3;
      minor = 2;
   }
   else if (ver_3_1) {
      major = 3;
      minor = 1;
   }
   else if (ver_3_0) {
      major = 3;
      minor = 0;
   }
   else if (ver_2_1) {
      major = 2;
      minor = 1;
d92 2
a93 2
      major = 2;
      minor = 0;
d96 2
a97 2
      major = 1;
      minor = 5;
d100 2
a101 2
      major = 1;
      minor = 4;
d104 2
a105 2
      major = 1;
      minor = 3;
d108 2
a109 47
      major = 1;
      minor = 2;
   }

   ctx->VersionMajor = major;
   ctx->VersionMinor = minor;
   ctx->VersionString = (char *) malloc(max);
   if (ctx->VersionString) {
      _mesa_snprintf(ctx->VersionString, max,
		     "%u.%u Mesa " MESA_VERSION_STRING,
		     ctx->VersionMajor, ctx->VersionMinor);
   }
}

static void
compute_version_es1(struct gl_context *ctx)
{
   static const int max = 100;

   /* OpenGL ES 1.0 is derived from OpenGL 1.3 */
   const GLboolean ver_1_0 = (ctx->Extensions.ARB_multisample &&
                              ctx->Extensions.ARB_multitexture &&
                              ctx->Extensions.ARB_texture_compression &&
                              ctx->Extensions.EXT_texture_env_add &&
                              ctx->Extensions.ARB_texture_env_combine &&
                              ctx->Extensions.ARB_texture_env_dot3);
   /* OpenGL ES 1.1 is derived from OpenGL 1.5 */
   const GLboolean ver_1_1 = (ver_1_0 &&
                              ctx->Extensions.EXT_point_parameters &&
                              ctx->Extensions.SGIS_generate_mipmap &&
                              ctx->Extensions.ARB_vertex_buffer_object);

   if (ver_1_1) {
      ctx->VersionMajor = 1;
      ctx->VersionMinor = 1;
   } else if (ver_1_0) {
      ctx->VersionMajor = 1;
      ctx->VersionMinor = 0;
   } else {
      _mesa_problem(ctx, "Incomplete OpenGL ES 1.0 support.");
   }

   ctx->VersionString = (char *) malloc(max);
   if (ctx->VersionString) {
      _mesa_snprintf(ctx->VersionString, max,
		     "OpenGL ES-CM 1.%d Mesa " MESA_VERSION_STRING,
		     ctx->VersionMinor);
a112 35
static void
compute_version_es2(struct gl_context *ctx)
{
   static const int max = 100;

   /* OpenGL ES 2.0 is derived from OpenGL 2.0 */
   const GLboolean ver_2_0 = (ctx->Extensions.ARB_multisample &&
                              ctx->Extensions.ARB_multitexture &&
                              ctx->Extensions.ARB_texture_compression &&
                              ctx->Extensions.ARB_texture_cube_map &&
                              ctx->Extensions.ARB_texture_mirrored_repeat &&
                              ctx->Extensions.EXT_blend_color &&
                              ctx->Extensions.EXT_blend_func_separate &&
                              ctx->Extensions.EXT_blend_minmax &&
                              ctx->Extensions.EXT_blend_subtract &&
                              ctx->Extensions.EXT_stencil_wrap &&
                              ctx->Extensions.ARB_vertex_buffer_object &&
                              ctx->Extensions.ARB_shader_objects &&
                              ctx->Extensions.ARB_vertex_shader &&
                              ctx->Extensions.ARB_fragment_shader &&
                              ctx->Extensions.ARB_texture_non_power_of_two &&
                              ctx->Extensions.EXT_blend_equation_separate);
   if (ver_2_0) {
      ctx->VersionMajor = 2;
      ctx->VersionMinor = 0;
   } else {
      _mesa_problem(ctx, "Incomplete OpenGL ES 2.0 support.");
   }

   ctx->VersionString = (char *) malloc(max);
   if (ctx->VersionString) {
      _mesa_snprintf(ctx->VersionString, max,
		     "OpenGL ES 2.0 Mesa " MESA_VERSION_STRING);
   }
}
d116 1
a116 2
 * This should only be called once as part of context initialization
 * or to perform version check for GLX_ARB_create_context_profile.
d119 1
a119 1
_mesa_compute_version(struct gl_context *ctx)
d121 1
a121 2
   if (ctx->VersionMajor)
      return;
d123 6
a128 10
   switch (ctx->API) {
   case API_OPENGL:
      compute_version(ctx);
      break;
   case API_OPENGLES:
      compute_version_es1(ctx);
      break;
   case API_OPENGLES2:
      compute_version_es2(ctx);
      break;
a129 1

@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d19 3
a21 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
d25 1
a25 2
#include "imports.h"
#include "mtypes.h"
a26 1
#include "git_sha1.h"
a27 130
/**
 * Scans 'string' to see if it ends with 'ending'.
 */
static GLboolean
check_for_ending(const char *string, const char *ending)
{
   int len1, len2;

   len1 = strlen(string);
   len2 = strlen(ending);

   if (len2 > len1) {
      return GL_FALSE;
   }

   if (strcmp(string + (len1 - len2), ending) == 0) {
      return GL_TRUE;
   } else {
      return GL_FALSE;
   }
}

/**
 * Returns the gl override data
 *
 * version > 0 indicates there is an override requested
 * fwd_context is only valid if version > 0
 */
static void
get_gl_override(int *version, GLboolean *fwd_context)
{
   const char *env_var = "MESA_GL_VERSION_OVERRIDE";
   const char *version_str;
   int major, minor, n;
   static int override_version = -1;
   static GLboolean fc_suffix = GL_FALSE;

   if (override_version < 0) {
      override_version = 0;

      version_str = getenv(env_var);
      if (version_str) {
         fc_suffix = check_for_ending(version_str, "FC");

         n = sscanf(version_str, "%u.%u", &major, &minor);
         if (n != 2) {
            fprintf(stderr, "error: invalid value for %s: %s\n", env_var, version_str);
            override_version = 0;
         } else {
            override_version = major * 10 + minor;
            if (override_version < 30 && fc_suffix) {
               fprintf(stderr, "error: invalid value for %s: %s\n", env_var, version_str);
            }
         }
      }
   }

   *version = override_version;
   *fwd_context = fc_suffix;
}

/**
 * Builds the MESA version string.
 */
static void
create_version_string(struct gl_context *ctx, const char *prefix)
{
   static const int max = 100;

   ctx->VersionString = malloc(max);
   if (ctx->VersionString) {
      _mesa_snprintf(ctx->VersionString, max,
		     "%s%u.%u%s Mesa " PACKAGE_VERSION
#ifdef MESA_GIT_SHA1
		     " (" MESA_GIT_SHA1 ")"
#endif
		     ,
		     prefix,
		     ctx->Version / 10, ctx->Version % 10,
		     (ctx->API == API_OPENGL_CORE) ? " (Core Profile)" : ""
		     );
   }
}

/**
 * Override the context's version and/or API type if the
 * environment variable MESA_GL_VERSION_OVERRIDE is set.
 *
 * Example uses of MESA_GL_VERSION_OVERRIDE:
 *
 * 2.1: select a compatibility (non-Core) profile with GL version 2.1
 * 3.0: select a compatibility (non-Core) profile with GL version 3.0
 * 3.0FC: select a Core+Forward Compatible profile with GL version 3.0
 * 3.1: select a Core profile with GL version 3.1
 * 3.1FC: select a Core+Forward Compatible profile with GL version 3.1
 */
void
_mesa_override_gl_version(struct gl_context *ctx)
{
   int version;
   GLboolean fwd_context;

   get_gl_override(&version, &fwd_context);

   if (version > 0) {
      ctx->Version = version;
      if (version >= 30 && fwd_context) {
         ctx->API = API_OPENGL_CORE;
         ctx->Const.ContextFlags |= GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT;
      } else if (version >= 31) {
         ctx->API = API_OPENGL_CORE;
      } else {
         ctx->API = API_OPENGL_COMPAT;
      }
      create_version_string(ctx, "");
   }
}

/**
 * Returns the gl override value
 *
 * version > 0 indicates there is an override requested
 */
int
_mesa_get_gl_version_override(void)
{
   int version;
   GLboolean fwd_context;

   get_gl_override(&version, &fwd_context);
a28 26
   return version;
}

/**
 * Override the context's GLSL version if the environment variable
 * MESA_GLSL_VERSION_OVERRIDE is set. Valid values for
 * MESA_GLSL_VERSION_OVERRIDE are integers, such as "130".
 */
void
_mesa_override_glsl_version(struct gl_context *ctx)
{
   const char *env_var = "MESA_GLSL_VERSION_OVERRIDE";
   const char *version;
   int n;

   version = getenv(env_var);
   if (!version) {
      return;
   }

   n = sscanf(version, "%u", &ctx->Const.GLSLVersion);
   if (n != 1) {
      fprintf(stderr, "error: invalid value for %s: %s\n", env_var, version);
      return;
   }
}
d32 1
d38 1
d40 4
a43 1
   const GLboolean ver_1_3 = (ctx->Extensions.ARB_texture_border_clamp &&
d45 1
d52 2
d57 8
a64 1
                              ctx->Extensions.EXT_point_parameters);
d66 3
a68 1
                              ctx->Extensions.ARB_occlusion_query);
d70 1
d72 1
a90 5
                              ctx->Const.GLSLVersion >= 130 &&
                              ctx->Const.MaxSamples >= 4 &&
                              (ctx->API == API_OPENGL_CORE ||
                               ctx->Extensions.ARB_color_buffer_float) &&
                              ctx->Extensions.ARB_depth_buffer_float &&
a91 1
                              ctx->Extensions.ARB_half_float_vertex &&
a92 1
                              ctx->Extensions.ARB_shader_texture_lod &&
d96 1
d98 3
a100 1
                              ctx->Extensions.ARB_framebuffer_object &&
d102 1
d105 1
d110 1
a110 1
                              ctx->Const.GLSLVersion >= 140 &&
a113 1
                              ctx->Extensions.EXT_texture_snorm &&
d116 1
a116 1
                              ctx->Const.VertexProgram.MaxTextureImageUnits >= 16);
a117 1
                              ctx->Const.GLSLVersion >= 150 &&
a127 1
                              ctx->Const.GLSLVersion >= 330 &&
d132 1
a132 1
                              ctx->Extensions.ARB_shader_bit_encoding &&
a136 1
                              /* ARB_sampler_objects is always enabled in mesa */
d179 8
a186 3
   ctx->Version = major * 10 + minor;

   create_version_string(ctx, "");
d192 2
d195 5
a199 1
   const GLboolean ver_1_0 = (ctx->Extensions.ARB_texture_env_combine &&
d203 3
a205 1
                              ctx->Extensions.EXT_point_parameters);
d208 2
a209 1
      ctx->Version = 11;
d211 2
a212 1
      ctx->Version = 10;
d217 6
a222 1
   create_version_string(ctx, "OpenGL ES-CM ");
d228 2
d231 5
a235 1
   const GLboolean ver_2_0 = (ctx->Extensions.ARB_texture_cube_map &&
d239 4
d247 3
a249 25
   /* FINISHME: This list isn't quite right. */
   const GLboolean ver_3_0 = (ctx->Extensions.ARB_half_float_vertex &&
                              ctx->Extensions.ARB_internalformat_query &&
                              ctx->Extensions.ARB_map_buffer_range &&
                              ctx->Extensions.ARB_shader_texture_lod &&
                              ctx->Extensions.ARB_texture_float &&
                              ctx->Extensions.ARB_texture_rg &&
                              ctx->Extensions.ARB_texture_compression_rgtc &&
                              ctx->Extensions.EXT_draw_buffers2 &&
                              /* ctx->Extensions.ARB_framebuffer_object && */
                              ctx->Extensions.EXT_framebuffer_sRGB &&
                              ctx->Extensions.EXT_packed_float &&
                              ctx->Extensions.EXT_texture_array &&
                              ctx->Extensions.EXT_texture_shared_exponent &&
                              ctx->Extensions.EXT_transform_feedback &&
                              ctx->Extensions.NV_conditional_render &&
                              ctx->Extensions.ARB_draw_instanced &&
                              ctx->Extensions.ARB_uniform_buffer_object &&
                              ctx->Extensions.EXT_texture_snorm &&
                              ctx->Extensions.NV_primitive_restart &&
                              ctx->Extensions.OES_depth_texture_cube_map);
   if (ver_3_0) {
      ctx->Version = 30;
   } else if (ver_2_0) {
      ctx->Version = 20;
d254 5
a258 1
   create_version_string(ctx, "OpenGL ES ");
d262 1
a262 1
 * Set the context's Version and VersionString fields.
d269 1
a269 1
   if (ctx->Version)
d273 1
a273 8
   case API_OPENGL_COMPAT:
      /* Disable GLSL 1.40 and later for legacy contexts.
       * This disallows creation of the GL 3.1 compatibility context. */
      if (ctx->Const.GLSLVersion > 130) {
         ctx->Const.GLSLVersion = 130;
      }
      /* fall through */
   case API_OPENGL_CORE:
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d227 1
d232 1
a232 1
                              (ctx->Const.MaxSamples >= 4 || ctx->Const.FakeSWMSAA) &&
d236 1
d259 1
a259 1
                              ctx->Const.Program[MESA_SHADER_VERTEX].MaxTextureImageUnits >= 16);
d265 1
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d60 1
a60 2
get_gl_override(int *version, GLboolean *fwd_context,
                GLboolean *compat_context)
a66 1
   static GLboolean compat_suffix = GL_FALSE;
a73 1
         compat_suffix = check_for_ending(version_str, "COMPAT");
a89 1
   *compat_context = compat_suffix;
d127 2
a128 3
bool
_mesa_override_gl_version_contextless(struct gl_constants *consts,
                                      gl_api *apiOut, GLuint *versionOut)
d131 1
a131 1
   GLboolean fwd_context, compat_context;
d133 1
a133 1
   get_gl_override(&version, &fwd_context, &compat_context);
d136 1
a136 1
      *versionOut = version;
d138 4
a141 4
         *apiOut = API_OPENGL_CORE;
         consts->ContextFlags |= GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT;
      } else if (version >= 31 && !compat_context) {
         *apiOut = API_OPENGL_CORE;
d143 1
a143 1
         *apiOut = API_OPENGL_COMPAT;
a144 10
      return GL_TRUE;
   }
   return GL_FALSE;
}

void
_mesa_override_gl_version(struct gl_context *ctx)
{
   if (_mesa_override_gl_version_contextless(&ctx->Const, &ctx->API,
                                             &ctx->Version)) {
d158 1
a158 1
   GLboolean fwd_context, compat_context;
d160 1
a160 1
   get_gl_override(&version, &fwd_context, &compat_context);
d171 1
a171 1
_mesa_override_glsl_version(struct gl_constants *consts)
d182 1
a182 1
   n = sscanf(version, "%u", &consts->GLSLVersion);
d192 2
a193 3
static GLuint
compute_version(const struct gl_extensions *extensions,
                const struct gl_constants *consts, gl_api api)
d195 1
a195 1
   GLuint major, minor, version;
d197 4
a200 4
   const GLboolean ver_1_3 = (extensions->ARB_texture_border_clamp &&
                              extensions->ARB_texture_cube_map &&
                              extensions->ARB_texture_env_combine &&
                              extensions->ARB_texture_env_dot3);
d202 7
a208 7
                              extensions->ARB_depth_texture &&
                              extensions->ARB_shadow &&
                              extensions->ARB_texture_env_crossbar &&
                              extensions->EXT_blend_color &&
                              extensions->EXT_blend_func_separate &&
                              extensions->EXT_blend_minmax &&
                              extensions->EXT_point_parameters);
d210 1
a210 1
                              extensions->ARB_occlusion_query);
d212 5
a216 5
                              extensions->ARB_point_sprite &&
                              extensions->ARB_vertex_shader &&
                              extensions->ARB_fragment_shader &&
                              extensions->ARB_texture_non_power_of_two &&
                              extensions->EXT_blend_equation_separate &&
d224 2
a225 2
			      (extensions->EXT_stencil_two_side
			       || extensions->ATI_separate_stencil));
d227 2
a228 2
                              extensions->EXT_pixel_buffer_object &&
                              extensions->EXT_texture_sRGB);
d230 19
a248 19
                              consts->GLSLVersion >= 130 &&
                              (consts->MaxSamples >= 4 || consts->FakeSWMSAA) &&
                              (api == API_OPENGL_CORE ||
                               extensions->ARB_color_buffer_float) &&
                              extensions->ARB_depth_buffer_float &&
                              extensions->ARB_half_float_vertex &&
                              extensions->ARB_map_buffer_range &&
                              extensions->ARB_shader_texture_lod &&
                              extensions->ARB_texture_float &&
                              extensions->ARB_texture_rg &&
                              extensions->ARB_texture_compression_rgtc &&
                              extensions->EXT_draw_buffers2 &&
                              extensions->ARB_framebuffer_object &&
                              extensions->EXT_framebuffer_sRGB &&
                              extensions->EXT_packed_float &&
                              extensions->EXT_texture_array &&
                              extensions->EXT_texture_shared_exponent &&
                              extensions->EXT_transform_feedback &&
                              extensions->NV_conditional_render);
d250 8
a257 8
                              consts->GLSLVersion >= 140 &&
                              extensions->ARB_draw_instanced &&
                              extensions->ARB_texture_buffer_object &&
                              extensions->ARB_uniform_buffer_object &&
                              extensions->EXT_texture_snorm &&
                              extensions->NV_primitive_restart &&
                              extensions->NV_texture_rectangle &&
                              consts->Program[MESA_SHADER_VERTEX].MaxTextureImageUnits >= 16);
d259 9
a267 9
                              consts->GLSLVersion >= 150 &&
                              extensions->ARB_depth_clamp &&
                              extensions->ARB_draw_elements_base_vertex &&
                              extensions->ARB_fragment_coord_conventions &&
                              extensions->EXT_provoking_vertex &&
                              extensions->ARB_seamless_cube_map &&
                              extensions->ARB_sync &&
                              extensions->ARB_texture_multisample &&
                              extensions->EXT_vertex_array_bgra);
d269 10
a278 10
                              consts->GLSLVersion >= 330 &&
                              extensions->ARB_blend_func_extended &&
                              extensions->ARB_explicit_attrib_location &&
                              extensions->ARB_instanced_arrays &&
                              extensions->ARB_occlusion_query2 &&
                              extensions->ARB_shader_bit_encoding &&
                              extensions->ARB_texture_rgb10_a2ui &&
                              extensions->ARB_timer_query &&
                              extensions->ARB_vertex_type_2_10_10_10_rev &&
                              extensions->EXT_texture_swizzle);
d322 1
a322 1
   version = major * 10 + minor;
d324 1
a324 4
   if (api == API_OPENGL_CORE && version < 31)
      return 0;

   return version;
d327 2
a328 2
static GLuint
compute_version_es1(const struct gl_extensions *extensions)
d331 2
a332 2
   const GLboolean ver_1_0 = (extensions->ARB_texture_env_combine &&
                              extensions->ARB_texture_env_dot3);
d335 1
a335 1
                              extensions->EXT_point_parameters);
d338 1
a338 1
      return 11;
d340 1
a340 1
      return 10;
d342 1
a342 1
      return 0;
d344 2
d348 2
a349 2
static GLuint
compute_version_es2(const struct gl_extensions *extensions)
d352 8
a359 8
   const GLboolean ver_2_0 = (extensions->ARB_texture_cube_map &&
                              extensions->EXT_blend_color &&
                              extensions->EXT_blend_func_separate &&
                              extensions->EXT_blend_minmax &&
                              extensions->ARB_vertex_shader &&
                              extensions->ARB_fragment_shader &&
                              extensions->ARB_texture_non_power_of_two &&
                              extensions->EXT_blend_equation_separate);
d361 20
a380 18
   const GLboolean ver_3_0 = (extensions->ARB_half_float_vertex &&
                              extensions->ARB_internalformat_query &&
                              extensions->ARB_map_buffer_range &&
                              extensions->ARB_shader_texture_lod &&
                              extensions->ARB_texture_float &&
                              extensions->ARB_texture_rg &&
                              extensions->EXT_draw_buffers2 &&
                              /* extensions->ARB_framebuffer_object && */
                              extensions->EXT_framebuffer_sRGB &&
                              extensions->EXT_packed_float &&
                              extensions->EXT_texture_array &&
                              extensions->EXT_texture_shared_exponent &&
                              extensions->EXT_transform_feedback &&
                              extensions->ARB_draw_instanced &&
                              extensions->ARB_uniform_buffer_object &&
                              extensions->EXT_texture_snorm &&
                              extensions->NV_primitive_restart &&
                              extensions->OES_depth_texture_cube_map);
d382 1
a382 1
      return 30;
d384 1
a384 1
      return 20;
d386 1
a386 1
      return 0;
a387 1
}
d389 1
a389 20
GLuint
_mesa_get_version(const struct gl_extensions *extensions,
                  struct gl_constants *consts, gl_api api)
{
   switch (api) {
   case API_OPENGL_COMPAT:
      /* Disable GLSL 1.40 and later for legacy contexts.
       * This disallows creation of the GL 3.1 compatibility context. */
      if (consts->GLSLVersion > 130) {
         consts->GLSLVersion = 130;
      }
      /* fall through */
   case API_OPENGL_CORE:
      return compute_version(extensions, consts, api);
   case API_OPENGLES:
      return compute_version_es1(extensions);
   case API_OPENGLES2:
      return compute_version_es2(extensions);
   }
   return 0;
a402 2
   ctx->Version = _mesa_get_version(&ctx->Extensions, &ctx->Const, ctx->API);

d405 6
d412 1
a412 1
      create_version_string(ctx, "");
a413 1

d415 1
a415 5
      if (!ctx->Version) {
         _mesa_problem(ctx, "Incomplete OpenGL ES 1.0 support.");
         return;
      }
      create_version_string(ctx, "OpenGL ES-CM ");
a416 1

d418 1
a418 5
      if (!ctx->Version) {
         _mesa_problem(ctx, "Incomplete OpenGL ES 2.0 support.");
         return;
      }
      create_version_string(ctx, "OpenGL ES ");
d421 1
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d60 2
a61 1
get_gl_override(int *version, GLboolean *fwd_context)
d68 1
d76 1
d93 1
d131 3
a133 2
void
_mesa_override_gl_version(struct gl_context *ctx)
d136 1
a136 1
   GLboolean fwd_context;
d138 1
a138 1
   get_gl_override(&version, &fwd_context);
d141 1
a141 1
      ctx->Version = version;
d143 4
a146 4
         ctx->API = API_OPENGL_CORE;
         ctx->Const.ContextFlags |= GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT;
      } else if (version >= 31) {
         ctx->API = API_OPENGL_CORE;
d148 1
a148 1
         ctx->API = API_OPENGL_COMPAT;
d150 10
d173 1
a173 1
   GLboolean fwd_context;
d175 1
a175 1
   get_gl_override(&version, &fwd_context);
d186 1
a186 1
_mesa_override_glsl_version(struct gl_context *ctx)
d197 1
a197 1
   n = sscanf(version, "%u", &ctx->Const.GLSLVersion);
d207 3
a209 2
static void
compute_version(struct gl_context *ctx)
d211 1
a211 1
   GLuint major, minor;
d213 4
a216 4
   const GLboolean ver_1_3 = (ctx->Extensions.ARB_texture_border_clamp &&
                              ctx->Extensions.ARB_texture_cube_map &&
                              ctx->Extensions.ARB_texture_env_combine &&
                              ctx->Extensions.ARB_texture_env_dot3);
d218 7
a224 7
                              ctx->Extensions.ARB_depth_texture &&
                              ctx->Extensions.ARB_shadow &&
                              ctx->Extensions.ARB_texture_env_crossbar &&
                              ctx->Extensions.EXT_blend_color &&
                              ctx->Extensions.EXT_blend_func_separate &&
                              ctx->Extensions.EXT_blend_minmax &&
                              ctx->Extensions.EXT_point_parameters);
d226 1
a226 1
                              ctx->Extensions.ARB_occlusion_query);
d228 5
a232 5
                              ctx->Extensions.ARB_point_sprite &&
                              ctx->Extensions.ARB_vertex_shader &&
                              ctx->Extensions.ARB_fragment_shader &&
                              ctx->Extensions.ARB_texture_non_power_of_two &&
                              ctx->Extensions.EXT_blend_equation_separate &&
d240 2
a241 2
			      (ctx->Extensions.EXT_stencil_two_side
			       || ctx->Extensions.ATI_separate_stencil));
d243 2
a244 2
                              ctx->Extensions.EXT_pixel_buffer_object &&
                              ctx->Extensions.EXT_texture_sRGB);
d246 19
a264 19
                              ctx->Const.GLSLVersion >= 130 &&
                              (ctx->Const.MaxSamples >= 4 || ctx->Const.FakeSWMSAA) &&
                              (ctx->API == API_OPENGL_CORE ||
                               ctx->Extensions.ARB_color_buffer_float) &&
                              ctx->Extensions.ARB_depth_buffer_float &&
                              ctx->Extensions.ARB_half_float_vertex &&
                              ctx->Extensions.ARB_map_buffer_range &&
                              ctx->Extensions.ARB_shader_texture_lod &&
                              ctx->Extensions.ARB_texture_float &&
                              ctx->Extensions.ARB_texture_rg &&
                              ctx->Extensions.ARB_texture_compression_rgtc &&
                              ctx->Extensions.EXT_draw_buffers2 &&
                              ctx->Extensions.ARB_framebuffer_object &&
                              ctx->Extensions.EXT_framebuffer_sRGB &&
                              ctx->Extensions.EXT_packed_float &&
                              ctx->Extensions.EXT_texture_array &&
                              ctx->Extensions.EXT_texture_shared_exponent &&
                              ctx->Extensions.EXT_transform_feedback &&
                              ctx->Extensions.NV_conditional_render);
d266 8
a273 8
                              ctx->Const.GLSLVersion >= 140 &&
                              ctx->Extensions.ARB_draw_instanced &&
                              ctx->Extensions.ARB_texture_buffer_object &&
                              ctx->Extensions.ARB_uniform_buffer_object &&
                              ctx->Extensions.EXT_texture_snorm &&
                              ctx->Extensions.NV_primitive_restart &&
                              ctx->Extensions.NV_texture_rectangle &&
                              ctx->Const.Program[MESA_SHADER_VERTEX].MaxTextureImageUnits >= 16);
d275 9
a283 9
                              ctx->Const.GLSLVersion >= 150 &&
                              ctx->Extensions.ARB_depth_clamp &&
                              ctx->Extensions.ARB_draw_elements_base_vertex &&
                              ctx->Extensions.ARB_fragment_coord_conventions &&
                              ctx->Extensions.EXT_provoking_vertex &&
                              ctx->Extensions.ARB_seamless_cube_map &&
                              ctx->Extensions.ARB_sync &&
                              ctx->Extensions.ARB_texture_multisample &&
                              ctx->Extensions.EXT_vertex_array_bgra);
d285 10
a294 10
                              ctx->Const.GLSLVersion >= 330 &&
                              ctx->Extensions.ARB_blend_func_extended &&
                              ctx->Extensions.ARB_explicit_attrib_location &&
                              ctx->Extensions.ARB_instanced_arrays &&
                              ctx->Extensions.ARB_occlusion_query2 &&
                              ctx->Extensions.ARB_shader_bit_encoding &&
                              ctx->Extensions.ARB_texture_rgb10_a2ui &&
                              ctx->Extensions.ARB_timer_query &&
                              ctx->Extensions.ARB_vertex_type_2_10_10_10_rev &&
                              ctx->Extensions.EXT_texture_swizzle);
d338 1
a338 1
   ctx->Version = major * 10 + minor;
d340 4
a343 1
   create_version_string(ctx, "");
d346 2
a347 2
static void
compute_version_es1(struct gl_context *ctx)
d350 2
a351 2
   const GLboolean ver_1_0 = (ctx->Extensions.ARB_texture_env_combine &&
                              ctx->Extensions.ARB_texture_env_dot3);
d354 1
a354 1
                              ctx->Extensions.EXT_point_parameters);
d357 1
a357 1
      ctx->Version = 11;
d359 1
a359 1
      ctx->Version = 10;
d361 1
a361 1
      _mesa_problem(ctx, "Incomplete OpenGL ES 1.0 support.");
a362 2

   create_version_string(ctx, "OpenGL ES-CM ");
d365 2
a366 2
static void
compute_version_es2(struct gl_context *ctx)
d369 8
a376 8
   const GLboolean ver_2_0 = (ctx->Extensions.ARB_texture_cube_map &&
                              ctx->Extensions.EXT_blend_color &&
                              ctx->Extensions.EXT_blend_func_separate &&
                              ctx->Extensions.EXT_blend_minmax &&
                              ctx->Extensions.ARB_vertex_shader &&
                              ctx->Extensions.ARB_fragment_shader &&
                              ctx->Extensions.ARB_texture_non_power_of_two &&
                              ctx->Extensions.EXT_blend_equation_separate);
d378 18
a395 20
   const GLboolean ver_3_0 = (ctx->Extensions.ARB_half_float_vertex &&
                              ctx->Extensions.ARB_internalformat_query &&
                              ctx->Extensions.ARB_map_buffer_range &&
                              ctx->Extensions.ARB_shader_texture_lod &&
                              ctx->Extensions.ARB_texture_float &&
                              ctx->Extensions.ARB_texture_rg &&
                              ctx->Extensions.ARB_texture_compression_rgtc &&
                              ctx->Extensions.EXT_draw_buffers2 &&
                              /* ctx->Extensions.ARB_framebuffer_object && */
                              ctx->Extensions.EXT_framebuffer_sRGB &&
                              ctx->Extensions.EXT_packed_float &&
                              ctx->Extensions.EXT_texture_array &&
                              ctx->Extensions.EXT_texture_shared_exponent &&
                              ctx->Extensions.EXT_transform_feedback &&
                              ctx->Extensions.NV_conditional_render &&
                              ctx->Extensions.ARB_draw_instanced &&
                              ctx->Extensions.ARB_uniform_buffer_object &&
                              ctx->Extensions.EXT_texture_snorm &&
                              ctx->Extensions.NV_primitive_restart &&
                              ctx->Extensions.OES_depth_texture_cube_map);
d397 1
a397 1
      ctx->Version = 30;
d399 1
a399 1
      ctx->Version = 20;
d401 1
a401 1
      _mesa_problem(ctx, "Incomplete OpenGL ES 2.0 support.");
d403 1
d405 20
a424 1
   create_version_string(ctx, "OpenGL ES ");
d438 2
a441 6
      /* Disable GLSL 1.40 and later for legacy contexts.
       * This disallows creation of the GL 3.1 compatibility context. */
      if (ctx->Const.GLSLVersion > 130) {
         ctx->Const.GLSLVersion = 130;
      }
      /* fall through */
d443 1
a443 1
      compute_version(ctx);
d445 1
d447 5
a451 1
      compute_version_es1(ctx);
d453 1
d455 5
a459 1
      compute_version_es2(ctx);
a461 1

@


