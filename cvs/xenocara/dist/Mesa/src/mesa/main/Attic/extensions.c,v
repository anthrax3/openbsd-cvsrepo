head	1.12;
access;
symbols
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	v10_2_9:1.1.1.9
	v10_4_3:1.1.1.8
	v10_2_7:1.1.1.7
	OPENBSD_5_6:1.9.0.2
	OPENBSD_5_6_BASE:1.9
	v10_2_3:1.1.1.7
	OPENBSD_5_5:1.8.0.2
	OPENBSD_5_5_BASE:1.8
	v9_2_5:1.1.1.6
	v9_2_3:1.1.1.6
	v9_2_2:1.1.1.6
	v9_2_1:1.1.1.6
	v9_2_0:1.1.1.5
	OPENBSD_5_4:1.6.0.4
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.3.0.4
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2015.12.23.05.17.52;	author jsg;	state dead;
branches;
next	1.11;
commitid	TnlogFl9nOv2eaRf;

1.11
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.10;
commitid	4ry2gvZGMXkCUD2n;

1.10
date	2015.01.25.14.41.21;	author jsg;	state Exp;
branches;
next	1.9;
commitid	mcxB0JvoI9gTDYXU;

1.9
date	2014.07.09.21.09.00;	author jsg;	state Exp;
branches;
next	1.8;
commitid	WPD6rgPryPkvXOr9;

1.8
date	2013.10.05.09.53.59;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2013.09.05.14.06.21;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2012.08.17.13.58.19;	author mpi;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.23.13.37.42;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.30;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.41;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.21;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.50.00;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.50.00;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.56.35;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.31.02;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.46;	author matthieu;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.09.05.13.16.32;	author jsg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2013.10.05.09.26.13;	author jsg;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2014.07.09.20.35.00;	author jsg;	state Exp;
branches;
next	1.1.1.8;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.8
date	2015.01.25.14.12.36;	author jsg;	state Exp;
branches;
next	1.1.1.9;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.9
date	2015.02.20.22.49.42;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.12
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2008  Brian Paul   All Rights Reserved.
 * Copyright (C) 2009  VMware, Inc.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */


/**
 * \file
 * \brief Extension handling
 */


#include "glheader.h"
#include "imports.h"
#include "context.h"
#include "extensions.h"
#include "macros.h"
#include "mtypes.h"

enum {
   DISABLE = 0,
   GLL = 1 << API_OPENGL_COMPAT,       /* GL Legacy / Compatibility */
   GLC = 1 << API_OPENGL_CORE,  /* GL Core */
   GL  = (1 << API_OPENGL_COMPAT) | (1 << API_OPENGL_CORE),
   ES1 = 1 << API_OPENGLES,
   ES2 = 1 << API_OPENGLES2,
   ES3 = 1 << (API_OPENGL_LAST + 1),
};

/**
 * \brief An element of the \c extension_table.
 */
struct extension {
   /** Name of extension, such as "GL_ARB_depth_clamp". */
   const char *name;

   /** Offset (in bytes) of the corresponding member in struct gl_extensions. */
   size_t offset;

   /** Set of API's in which the extension exists, as a bitset. */
   uint8_t api_set;

   /** Year the extension was proposed or approved.  Used to sort the 
    * extension string chronologically. */
   uint16_t year;
};


/**
 * Given a member \c x of struct gl_extensions, return offset of
 * \c x in bytes.
 */
#define o(x) offsetof(struct gl_extensions, x)


/**
 * \brief Table of supported OpenGL extensions for all API's.
 */
static const struct extension extension_table[] = {
   /* ARB Extensions */
   { "GL_ARB_ES2_compatibility",                   o(ARB_ES2_compatibility),                   GL,             2009 },
   { "GL_ARB_ES3_compatibility",                   o(ARB_ES3_compatibility),                   GL,             2012 },
   { "GL_ARB_arrays_of_arrays",                    o(ARB_arrays_of_arrays),                    GL,             2012 },
   { "GL_ARB_base_instance",                       o(ARB_base_instance),                       GL,             2011 },
   { "GL_ARB_blend_func_extended",                 o(ARB_blend_func_extended),                 GL,             2009 },
   { "GL_ARB_buffer_storage",                      o(ARB_buffer_storage),                      GL,             2013 },
   { "GL_ARB_clear_buffer_object",                 o(dummy_true),                              GL,             2012 },
   { "GL_ARB_color_buffer_float",                  o(ARB_color_buffer_float),                  GL,             2004 },
   { "GL_ARB_compute_shader",                      o(ARB_compute_shader),                      GL,             2012 },
   { "GL_ARB_copy_buffer",                         o(dummy_true),                              GL,             2008 },
   { "GL_ARB_conservative_depth",                  o(ARB_conservative_depth),                  GL,             2011 },
   { "GL_ARB_debug_output",                        o(dummy_true),                              GL,             2009 },
   { "GL_ARB_depth_buffer_float",                  o(ARB_depth_buffer_float),                  GL,             2008 },
   { "GL_ARB_depth_clamp",                         o(ARB_depth_clamp),                         GL,             2003 },
   { "GL_ARB_depth_texture",                       o(ARB_depth_texture),                       GLL,            2001 },
   { "GL_ARB_draw_buffers",                        o(dummy_true),                              GL,             2002 },
   { "GL_ARB_draw_buffers_blend",                  o(ARB_draw_buffers_blend),                  GL,             2009 },
   { "GL_ARB_draw_elements_base_vertex",           o(ARB_draw_elements_base_vertex),           GL,             2009 },
   { "GL_ARB_draw_indirect",                       o(ARB_draw_indirect),                       GLC,            2010 },
   { "GL_ARB_draw_instanced",                      o(ARB_draw_instanced),                      GL,             2008 },
   { "GL_ARB_explicit_attrib_location",            o(ARB_explicit_attrib_location),            GL,             2009 },
   { "GL_ARB_fragment_coord_conventions",          o(ARB_fragment_coord_conventions),          GL,             2009 },
   { "GL_ARB_fragment_program",                    o(ARB_fragment_program),                    GLL,            2002 },
   { "GL_ARB_fragment_program_shadow",             o(ARB_fragment_program_shadow),             GLL,            2003 },
   { "GL_ARB_fragment_shader",                     o(ARB_fragment_shader),                     GL,             2002 },
   { "GL_ARB_framebuffer_object",                  o(ARB_framebuffer_object),                  GL,             2005 },
   { "GL_ARB_framebuffer_sRGB",                    o(EXT_framebuffer_sRGB),                    GL,             1998 },
   { "GL_ARB_get_program_binary",                  o(dummy_true),                              GL,             2010 },
   { "GL_ARB_gpu_shader5",                         o(ARB_gpu_shader5),                         GL,             2010 },
   { "GL_ARB_half_float_pixel",                    o(dummy_true),                              GL,             2003 },
   { "GL_ARB_half_float_vertex",                   o(ARB_half_float_vertex),                   GL,             2008 },
   { "GL_ARB_instanced_arrays",                    o(ARB_instanced_arrays),                    GL,             2008 },
   { "GL_ARB_internalformat_query",                o(ARB_internalformat_query),                GL,             2011 },
   { "GL_ARB_invalidate_subdata",                  o(dummy_true),                              GL,             2012 },
   { "GL_ARB_map_buffer_alignment",                o(dummy_true),                              GL,             2011 },
   { "GL_ARB_map_buffer_range",                    o(ARB_map_buffer_range),                    GL,             2008 },
   { "GL_ARB_multi_bind",                          o(dummy_true),                              GL,             2013 },
   { "GL_ARB_multi_draw_indirect",                 o(ARB_draw_indirect),                       GLC,            2012 },
   { "GL_ARB_multisample",                         o(dummy_true),                              GLL,            1994 },
   { "GL_ARB_multitexture",                        o(dummy_true),                              GLL,            1998 },
   { "GL_ARB_occlusion_query2",                    o(ARB_occlusion_query2),                    GL,             2003 },
   { "GL_ARB_occlusion_query",                     o(ARB_occlusion_query),                     GLL,            2001 },
   { "GL_ARB_pixel_buffer_object",                 o(EXT_pixel_buffer_object),                 GL,             2004 },
   { "GL_ARB_point_parameters",                    o(EXT_point_parameters),                    GLL,            1997 },
   { "GL_ARB_point_sprite",                        o(ARB_point_sprite),                        GL,             2003 },
   { "GL_ARB_provoking_vertex",                    o(EXT_provoking_vertex),                    GL,             2009 },
   { "GL_ARB_robustness",                          o(dummy_true),                              GL,             2010 },
   { "GL_ARB_sample_shading",                      o(ARB_sample_shading),                      GL,             2009 },
   { "GL_ARB_sampler_objects",                     o(dummy_true),                              GL,             2009 },
   { "GL_ARB_seamless_cube_map",                   o(ARB_seamless_cube_map),                   GL,             2009 },
   { "GL_ARB_separate_shader_objects",             o(dummy_true),                              GL,             2010 },
   { "GL_ARB_shader_atomic_counters",              o(ARB_shader_atomic_counters),              GL,             2011 },
   { "GL_ARB_shader_bit_encoding",                 o(ARB_shader_bit_encoding),                 GL,             2010 },
   { "GL_ARB_shader_image_load_store",             o(ARB_shader_image_load_store),             GL,             2011 },
   { "GL_ARB_shader_objects",                      o(dummy_true),                              GL,             2002 },
   { "GL_ARB_shader_stencil_export",               o(ARB_shader_stencil_export),               GL,             2009 },
   { "GL_ARB_shader_texture_lod",                  o(ARB_shader_texture_lod),                  GL,             2009 },
   { "GL_ARB_shading_language_100",                o(dummy_true),                              GLL,            2003 },
   { "GL_ARB_shading_language_packing",            o(ARB_shading_language_packing),            GL,             2011 },
   { "GL_ARB_shading_language_420pack",            o(ARB_shading_language_420pack),            GL,             2011 },
   { "GL_ARB_shadow",                              o(ARB_shadow),                              GLL,            2001 },
   { "GL_ARB_stencil_texturing",                   o(ARB_stencil_texturing),                   GL,             2012 },
   { "GL_ARB_sync",                                o(ARB_sync),                                GL,             2003 },
   { "GL_ARB_texture_border_clamp",                o(ARB_texture_border_clamp),                GLL,            2000 },
   { "GL_ARB_texture_buffer_object",               o(ARB_texture_buffer_object),               GLC,            2008 },
   { "GL_ARB_texture_buffer_object_rgb32",         o(ARB_texture_buffer_object_rgb32),         GLC,            2009 },
   { "GL_ARB_texture_buffer_range",                o(ARB_texture_buffer_range),                GLC,            2012 },
   { "GL_ARB_texture_compression",                 o(dummy_true),                              GLL,            2000 },
   { "GL_ARB_texture_compression_rgtc",            o(ARB_texture_compression_rgtc),            GL,             2004 },
   { "GL_ARB_texture_cube_map",                    o(ARB_texture_cube_map),                    GLL,            1999 },
   { "GL_ARB_texture_cube_map_array",              o(ARB_texture_cube_map_array),              GL,             2009 },
   { "GL_ARB_texture_env_add",                     o(dummy_true),                              GLL,            1999 },
   { "GL_ARB_texture_env_combine",                 o(ARB_texture_env_combine),                 GLL,            2001 },
   { "GL_ARB_texture_env_crossbar",                o(ARB_texture_env_crossbar),                GLL,            2001 },
   { "GL_ARB_texture_env_dot3",                    o(ARB_texture_env_dot3),                    GLL,            2001 },
   { "GL_ARB_texture_float",                       o(ARB_texture_float),                       GL,             2004 },
   { "GL_ARB_texture_gather",                      o(ARB_texture_gather),                      GL,             2009 },
   { "GL_ARB_texture_mirrored_repeat",             o(dummy_true),                              GLL,            2001 },
   { "GL_ARB_texture_mirror_clamp_to_edge",        o(ARB_texture_mirror_clamp_to_edge),        GL,             2013 },
   { "GL_ARB_texture_multisample",                 o(ARB_texture_multisample),                 GL,             2009 },
   { "GL_ARB_texture_non_power_of_two",            o(ARB_texture_non_power_of_two),            GL,             2003 },
   { "GL_ARB_texture_query_levels",                o(ARB_texture_query_levels),                GL,             2012 },
   { "GL_ARB_texture_query_lod",                   o(ARB_texture_query_lod),                   GL,             2009 },
   { "GL_ARB_texture_rectangle",                   o(NV_texture_rectangle),                    GL,             2004 },
   { "GL_ARB_texture_rgb10_a2ui",                  o(ARB_texture_rgb10_a2ui),                  GL,             2009 },
   { "GL_ARB_texture_rg",                          o(ARB_texture_rg),                          GL,             2008 },
   { "GL_ARB_texture_storage",                     o(dummy_true),                              GL,             2011 },
   { "GL_ARB_texture_storage_multisample",         o(ARB_texture_multisample),                 GL,             2012 },
   { "GL_ARB_texture_view",                        o(ARB_texture_view),                        GL,             2012 },
   { "GL_ARB_texture_swizzle",                     o(EXT_texture_swizzle),                     GL,             2008 },
   { "GL_ARB_timer_query",                         o(ARB_timer_query),                         GL,             2010 },
   { "GL_ARB_transform_feedback2",                 o(ARB_transform_feedback2),                 GL,             2010 },
   { "GL_ARB_transform_feedback3",                 o(ARB_transform_feedback3),                 GL,             2010 },
   { "GL_ARB_transform_feedback_instanced",        o(ARB_transform_feedback_instanced),        GL,             2011 },
   { "GL_ARB_transpose_matrix",                    o(dummy_true),                              GLL,            1999 },
   { "GL_ARB_uniform_buffer_object",               o(ARB_uniform_buffer_object),               GL,             2009 },
   { "GL_ARB_vertex_array_bgra",                   o(EXT_vertex_array_bgra),                   GL,             2008 },
   { "GL_ARB_vertex_array_object",                 o(dummy_true),                              GL,             2006 },
   { "GL_ARB_vertex_attrib_binding",               o(dummy_true),                              GL,             2012 },
   { "GL_ARB_vertex_buffer_object",                o(dummy_true),                              GLL,            2003 },
   { "GL_ARB_vertex_program",                      o(ARB_vertex_program),                      GLL,            2002 },
   { "GL_ARB_vertex_shader",                       o(ARB_vertex_shader),                       GL,             2002 },
   { "GL_ARB_vertex_type_10f_11f_11f_rev",         o(ARB_vertex_type_10f_11f_11f_rev),         GL,             2013 },
   { "GL_ARB_vertex_type_2_10_10_10_rev",          o(ARB_vertex_type_2_10_10_10_rev),          GL,             2009 },
   { "GL_ARB_viewport_array",                      o(ARB_viewport_array),                      GLC,            2010 },
   { "GL_ARB_window_pos",                          o(dummy_true),                              GLL,            2001 },
   /* EXT extensions */
   { "GL_EXT_abgr",                                o(dummy_true),                              GL,             1995 },
   { "GL_EXT_bgra",                                o(dummy_true),                              GLL,            1995 },
   { "GL_EXT_blend_color",                         o(EXT_blend_color),                         GLL,            1995 },
   { "GL_EXT_blend_equation_separate",             o(EXT_blend_equation_separate),             GL,             2003 },
   { "GL_EXT_blend_func_separate",                 o(EXT_blend_func_separate),                 GLL,            1999 },
   { "GL_EXT_discard_framebuffer",                 o(dummy_true),                                    ES1 | ES2, 2009 },
   { "GL_EXT_blend_minmax",                        o(EXT_blend_minmax),                        GLL | ES1 | ES2, 1995 },
   { "GL_EXT_blend_subtract",                      o(dummy_true),                              GLL,            1995 },
   { "GL_EXT_compiled_vertex_array",               o(dummy_true),                              GLL,            1996 },
   { "GL_EXT_copy_texture",                        o(dummy_true),                              GLL,            1995 },
   { "GL_EXT_depth_bounds_test",                   o(EXT_depth_bounds_test),                   GL,             2002 },
   { "GL_EXT_draw_buffers2",                       o(EXT_draw_buffers2),                       GL,             2006 },
   { "GL_EXT_draw_instanced",                      o(ARB_draw_instanced),                      GL,             2006 },
   { "GL_EXT_draw_range_elements",                 o(dummy_true),                              GLL,            1997 },
   { "GL_EXT_fog_coord",                           o(dummy_true),                              GLL,            1999 },
   { "GL_EXT_framebuffer_blit",                    o(dummy_true),                              GL,             2005 },
   { "GL_EXT_framebuffer_multisample",             o(EXT_framebuffer_multisample),             GL,             2005 },
   { "GL_EXT_framebuffer_multisample_blit_scaled", o(EXT_framebuffer_multisample_blit_scaled), GL,             2011 },
   { "GL_EXT_framebuffer_object",                  o(dummy_true),                              GLL,            2000 },
   { "GL_EXT_framebuffer_sRGB",                    o(EXT_framebuffer_sRGB),                    GL,             1998 },
   { "GL_EXT_gpu_program_parameters",              o(EXT_gpu_program_parameters),              GLL,            2006 },
   { "GL_EXT_gpu_shader4",                         o(EXT_gpu_shader4),                         GL,             2006 },
   { "GL_EXT_map_buffer_range",                    o(ARB_map_buffer_range),                          ES1 | ES2, 2012 },
   { "GL_EXT_multi_draw_arrays",                   o(dummy_true),                              GLL | ES1 | ES2, 1999 },
   { "GL_EXT_packed_depth_stencil",                o(dummy_true),                              GL,             2005 },
   { "GL_EXT_packed_float",                        o(EXT_packed_float),                        GL,             2004 },
   { "GL_EXT_packed_pixels",                       o(dummy_true),                              GLL,            1997 },
   { "GL_EXT_pixel_buffer_object",                 o(EXT_pixel_buffer_object),                 GL,             2004 },
   { "GL_EXT_point_parameters",                    o(EXT_point_parameters),                    GLL,            1997 },
   { "GL_EXT_polygon_offset",                      o(dummy_true),                              GLL,            1995 },
   { "GL_EXT_provoking_vertex",                    o(EXT_provoking_vertex),                    GL,             2009 },
   { "GL_EXT_rescale_normal",                      o(dummy_true),                              GLL,            1997 },
   { "GL_EXT_secondary_color",                     o(dummy_true),                              GLL,            1999 },
   { "GL_EXT_separate_shader_objects",             o(dummy_true),                                         ES2, 2013 },
   { "GL_EXT_separate_specular_color",             o(dummy_true),                              GLL,            1997 },
   { "GL_EXT_shader_integer_mix",                  o(EXT_shader_integer_mix),                  GL       | ES3, 2013 },
   { "GL_EXT_shadow_funcs",                        o(ARB_shadow),                              GLL,            2002 },
   { "GL_EXT_stencil_two_side",                    o(EXT_stencil_two_side),                    GLL,            2001 },
   { "GL_EXT_stencil_wrap",                        o(dummy_true),                              GLL,            2002 },
   { "GL_EXT_subtexture",                          o(dummy_true),                              GLL,            1995 },
   { "GL_EXT_texture3D",                           o(EXT_texture3D),                           GLL,            1996 },
   { "GL_EXT_texture_array",                       o(EXT_texture_array),                       GL,             2006 },
   { "GL_EXT_texture_compression_dxt1",            o(ANGLE_texture_compression_dxt),           GL | ES1 | ES2, 2004 },
   { "GL_ANGLE_texture_compression_dxt3",          o(ANGLE_texture_compression_dxt),           GL | ES1 | ES2, 2011 },
   { "GL_ANGLE_texture_compression_dxt5",          o(ANGLE_texture_compression_dxt),           GL | ES1 | ES2, 2011 },
   { "GL_EXT_texture_compression_latc",            o(EXT_texture_compression_latc),            GL,             2006 },
   { "GL_EXT_texture_compression_rgtc",            o(ARB_texture_compression_rgtc),            GL,             2004 },
   { "GL_EXT_texture_compression_s3tc",            o(EXT_texture_compression_s3tc),            GL,             2000 },
   { "GL_EXT_texture_cube_map",                    o(ARB_texture_cube_map),                    GLL,            2001 },
   { "GL_EXT_texture_edge_clamp",                  o(dummy_true),                              GLL,            1997 },
   { "GL_EXT_texture_env_add",                     o(dummy_true),                              GLL,            1999 },
   { "GL_EXT_texture_env_combine",                 o(dummy_true),                              GLL,            2000 },
   { "GL_EXT_texture_env_dot3",                    o(EXT_texture_env_dot3),                    GLL,            2000 },
   { "GL_EXT_texture_filter_anisotropic",          o(EXT_texture_filter_anisotropic),          GL | ES1 | ES2, 1999 },
   { "GL_EXT_texture_format_BGRA8888",             o(dummy_true),                                   ES1 | ES2, 2005 },
   { "GL_EXT_texture_rg",                          o(ARB_texture_rg),                                     ES2, 2011 },
   { "GL_EXT_read_format_bgra",                    o(dummy_true),                                   ES1 | ES2, 2009 },
   { "GL_EXT_texture_integer",                     o(EXT_texture_integer),                     GL,             2006 },
   { "GL_EXT_texture_lod_bias",                    o(dummy_true),                              GLL | ES1,      1999 },
   { "GL_EXT_texture_mirror_clamp",                o(EXT_texture_mirror_clamp),                GL,             2004 },
   { "GL_EXT_texture_object",                      o(dummy_true),                              GLL,            1995 },
   { "GL_EXT_texture",                             o(dummy_true),                              GLL,            1996 },
   { "GL_EXT_texture_rectangle",                   o(NV_texture_rectangle),                    GLL,            2004 },
   { "GL_EXT_texture_shared_exponent",             o(EXT_texture_shared_exponent),             GL,             2004 },
   { "GL_EXT_texture_snorm",                       o(EXT_texture_snorm),                       GL,             2009 },
   { "GL_EXT_texture_sRGB",                        o(EXT_texture_sRGB),                        GL,             2004 },
   { "GL_EXT_texture_sRGB_decode",                 o(EXT_texture_sRGB_decode),                        GL,      2006 },
   { "GL_EXT_texture_swizzle",                     o(EXT_texture_swizzle),                     GL,             2008 },
   { "GL_EXT_texture_type_2_10_10_10_REV",         o(dummy_true),                                         ES2, 2008 },
   { "GL_EXT_timer_query",                         o(EXT_timer_query),                         GL,             2006 },
   { "GL_EXT_transform_feedback",                  o(EXT_transform_feedback),                  GL,             2011 },
   { "GL_EXT_unpack_subimage",                     o(dummy_true),                                         ES2, 2011 },
   { "GL_EXT_vertex_array_bgra",                   o(EXT_vertex_array_bgra),                   GL,             2008 },
   { "GL_EXT_vertex_array",                        o(dummy_true),                              GLL,            1995 },
   { "GL_EXT_color_buffer_float",                  o(dummy_true),                                         ES3, 2013 },

   /* OES extensions */
   { "GL_OES_blend_equation_separate",             o(EXT_blend_equation_separate),                  ES1,       2009 },
   { "GL_OES_blend_func_separate",                 o(EXT_blend_func_separate),                      ES1,       2009 },
   { "GL_OES_blend_subtract",                      o(dummy_true),                                   ES1,       2009 },
   { "GL_OES_byte_coordinates",                    o(dummy_true),                                   ES1,       2002 },
   { "GL_OES_compressed_ETC1_RGB8_texture",        o(OES_compressed_ETC1_RGB8_texture),             ES1 | ES2, 2005 },
   { "GL_OES_compressed_paletted_texture",         o(dummy_true),                                   ES1,       2003 },
   { "GL_OES_depth24",                             o(dummy_true),                                   ES1 | ES2, 2005 },
   { "GL_OES_depth32",                             o(dummy_false),                     DISABLE,                2005 },
   { "GL_OES_depth_texture",                       o(ARB_depth_texture),                                  ES2, 2006 },
   { "GL_OES_depth_texture_cube_map",              o(OES_depth_texture_cube_map),                         ES2, 2012 },
   { "GL_OES_draw_texture",                        o(OES_draw_texture),                             ES1,       2004 },
   /*  FIXME: Mesa expects GL_OES_EGL_image to be available in OpenGL contexts. */
   { "GL_OES_EGL_image",                           o(OES_EGL_image),                           GL | ES1 | ES2, 2006 },
   { "GL_OES_EGL_image_external",                  o(OES_EGL_image_external),                       ES1 | ES2, 2010 },
   { "GL_OES_element_index_uint",                  o(dummy_true),                                   ES1 | ES2, 2005 },
   { "GL_OES_fbo_render_mipmap",                   o(dummy_true),                                   ES1 | ES2, 2005 },
   { "GL_OES_fixed_point",                         o(dummy_true),                                   ES1,       2002 },
   { "GL_OES_framebuffer_object",                  o(dummy_true),                                   ES1,       2005 },
   { "GL_OES_get_program_binary",                  o(dummy_true),                                         ES2, 2008 },
   { "GL_OES_mapbuffer",                           o(dummy_true),                                   ES1 | ES2, 2005 },
   { "GL_OES_packed_depth_stencil",                o(dummy_true),                                   ES1 | ES2, 2007 },
   { "GL_OES_point_size_array",                    o(dummy_true),                                   ES1,       2004 },
   { "GL_OES_point_sprite",                        o(ARB_point_sprite),                             ES1,       2004 },
   { "GL_OES_query_matrix",                        o(dummy_true),                                   ES1,       2003 },
   { "GL_OES_read_format",                         o(dummy_true),                              GL | ES1,       2003 },
   { "GL_OES_rgb8_rgba8",                          o(dummy_true),                                   ES1 | ES2, 2005 },
   { "GL_OES_single_precision",                    o(dummy_true),                                   ES1,       2003 },
   { "GL_OES_standard_derivatives",                o(OES_standard_derivatives),                           ES2, 2005 },
   { "GL_OES_stencil1",                            o(dummy_false),                     DISABLE,                2005 },
   { "GL_OES_stencil4",                            o(dummy_false),                     DISABLE,                2005 },
   { "GL_OES_stencil8",                            o(dummy_true),                                   ES1 | ES2, 2005 },
   { "GL_OES_stencil_wrap",                        o(dummy_true),                                   ES1,       2002 },
   { "GL_OES_surfaceless_context",                 o(dummy_true),                                   ES1 | ES2, 2012 },
   { "GL_OES_texture_3D",                          o(EXT_texture3D),                                      ES2, 2005 },
   { "GL_OES_texture_cube_map",                    o(ARB_texture_cube_map),                         ES1,       2007 },
   { "GL_OES_texture_env_crossbar",                o(ARB_texture_env_crossbar),                     ES1,       2005 },
   { "GL_OES_texture_mirrored_repeat",             o(dummy_true),                                   ES1,       2005 },
   { "GL_OES_texture_npot",                        o(ARB_texture_non_power_of_two),                 ES1 | ES2, 2005 },
   { "GL_OES_vertex_array_object",                 o(dummy_true),                                   ES1 | ES2, 2010 },

   /* KHR extensions */
   { "GL_KHR_debug",                               o(dummy_true),                              GL,             2012 },

   /* Vendor extensions */
   { "GL_3DFX_texture_compression_FXT1",           o(TDFX_texture_compression_FXT1),           GL,             1999 },
   { "GL_AMD_conservative_depth",                  o(ARB_conservative_depth),                  GL,             2009 },
   { "GL_AMD_draw_buffers_blend",                  o(ARB_draw_buffers_blend),                  GL,             2009 },
   { "GL_AMD_performance_monitor",                 o(AMD_performance_monitor),                 GL,             2007 },
   { "GL_AMD_seamless_cubemap_per_texture",        o(AMD_seamless_cubemap_per_texture),        GL,             2009 },
   { "GL_AMD_shader_stencil_export",               o(ARB_shader_stencil_export),               GL,             2009 },
   { "GL_AMD_shader_trinary_minmax",               o(dummy_true),                              GL,             2012 },
   { "GL_AMD_vertex_shader_layer",                 o(AMD_vertex_shader_layer),                 GLC,            2012 },
   { "GL_APPLE_object_purgeable",                  o(APPLE_object_purgeable),                  GL,             2006 },
   { "GL_APPLE_packed_pixels",                     o(dummy_true),                              GLL,            2002 },
   { "GL_APPLE_texture_max_level",                 o(dummy_true),                                   ES1 | ES2, 2009 },
   { "GL_APPLE_vertex_array_object",               o(dummy_true),                              GLL,            2002 },
   { "GL_ATI_blend_equation_separate",             o(EXT_blend_equation_separate),             GL,             2003 },
   { "GL_ATI_draw_buffers",                        o(dummy_true),                              GLL,            2002 },
   { "GL_ATI_envmap_bumpmap",                      o(ATI_envmap_bumpmap),                      GLL,            2001 },
   { "GL_ATI_fragment_shader",                     o(ATI_fragment_shader),                     GLL,            2001 },
   { "GL_ATI_separate_stencil",                    o(ATI_separate_stencil),                    GLL,            2006 },
   { "GL_ATI_texture_compression_3dc",             o(ATI_texture_compression_3dc),             GL,             2004 },
   { "GL_ATI_texture_env_combine3",                o(ATI_texture_env_combine3),                GLL,            2002 },
   { "GL_ATI_texture_float",                       o(ARB_texture_float),                       GL,             2002 },
   { "GL_ATI_texture_mirror_once",                 o(ATI_texture_mirror_once),                 GL,             2006 },
   { "GL_IBM_multimode_draw_arrays",               o(dummy_true),                              GL,             1998 },
   { "GL_IBM_rasterpos_clip",                      o(dummy_true),                              GLL,            1996 },
   { "GL_IBM_texture_mirrored_repeat",             o(dummy_true),                              GLL,            1998 },
   { "GL_INGR_blend_func_separate",                o(EXT_blend_func_separate),                 GLL,            1999 },
   { "GL_INTEL_performance_query",                 o(INTEL_performance_query),                       GL | ES2, 2013 },
   { "GL_MESA_pack_invert",                        o(MESA_pack_invert),                        GL,             2002 },
   { "GL_MESA_texture_signed_rgba",                o(EXT_texture_snorm),                       GL,             2009 },
   { "GL_MESA_window_pos",                         o(dummy_true),                              GLL,            2000 },
   { "GL_MESA_ycbcr_texture",                      o(MESA_ycbcr_texture),                      GL,             2002 },
   { "GL_NV_blend_square",                         o(dummy_true),                              GLL,            1999 },
   { "GL_NV_conditional_render",                   o(NV_conditional_render),                   GL,             2008 },
   { "GL_NV_depth_clamp",                          o(ARB_depth_clamp),                         GL,             2001 },
   { "GL_NV_draw_buffers",                         o(dummy_true),                                         ES2, 2011 },
   { "GL_NV_fbo_color_attachments",                o(dummy_true),                                         ES2, 2010 },
   { "GL_NV_fog_distance",                         o(NV_fog_distance),                         GLL,            2001 },
   { "GL_NV_fragment_program_option",              o(NV_fragment_program_option),              GLL,            2005 },
   { "GL_NV_light_max_exponent",                   o(dummy_true),                              GLL,            1999 },
   { "GL_NV_packed_depth_stencil",                 o(dummy_true),                              GL,             2000 },
   { "GL_NV_point_sprite",                         o(NV_point_sprite),                         GL,             2001 },
   { "GL_NV_primitive_restart",                    o(NV_primitive_restart),                    GLL,            2002 },
   { "GL_NV_read_buffer",                          o(dummy_true),                              ES2,            2011 },
   { "GL_NV_texgen_reflection",                    o(dummy_true),                              GLL,            1999 },
   { "GL_NV_texture_barrier",                      o(NV_texture_barrier),                      GL,             2009 },
   { "GL_NV_texture_env_combine4",                 o(NV_texture_env_combine4),                 GLL,            1999 },
   { "GL_NV_texture_rectangle",                    o(NV_texture_rectangle),                    GLL,            2000 },
   { "GL_NV_vdpau_interop",                        o(NV_vdpau_interop),                        GL,             2010 },
   { "GL_S3_s3tc",                                 o(ANGLE_texture_compression_dxt),           GL,             1999 },
   { "GL_SGIS_generate_mipmap",                    o(dummy_true),                              GLL,            1997 },
   { "GL_SGIS_texture_border_clamp",               o(ARB_texture_border_clamp),                GLL,            1997 },
   { "GL_SGIS_texture_edge_clamp",                 o(dummy_true),                              GLL,            1997 },
   { "GL_SGIS_texture_lod",                        o(dummy_true),                              GLL,            1997 },
   { "GL_SUN_multi_draw_arrays",                   o(dummy_true),                              GLL,            1999 },

   { 0, 0, 0, 0 },
};


/**
 * Given an extension name, lookup up the corresponding member of struct
 * gl_extensions and return that member's offset (in bytes).  If the name is
 * not found in the \c extension_table, return 0.
 *
 * \param name Name of extension.
 * \return Offset of member in struct gl_extensions.
 */
static size_t
name_to_offset(const char* name)
{
   const struct extension *i;

   if (name == 0)
      return 0;

   for (i = extension_table; i->name != 0; ++i) {
      if (strcmp(name, i->name) == 0)
	 return i->offset;
   }

   return 0;
}


/**
 * Enable all extensions suitable for a software-only renderer.
 * This is a convenience function used by the XMesa, OSMesa, GGI drivers, etc.
 */
void
_mesa_enable_sw_extensions(struct gl_context *ctx)
{
   ctx->Extensions.ARB_depth_clamp = GL_TRUE;
   ctx->Extensions.ARB_depth_texture = GL_TRUE;
   ctx->Extensions.ARB_draw_elements_base_vertex = GL_TRUE;
   ctx->Extensions.ARB_draw_instanced = GL_TRUE;
   ctx->Extensions.ARB_explicit_attrib_location = GL_TRUE;
   ctx->Extensions.ARB_fragment_coord_conventions = GL_TRUE;
   ctx->Extensions.ARB_fragment_program = GL_TRUE;
   ctx->Extensions.ARB_fragment_program_shadow = GL_TRUE;
   ctx->Extensions.ARB_fragment_shader = GL_TRUE;
   ctx->Extensions.ARB_framebuffer_object = GL_TRUE;
   ctx->Extensions.ARB_half_float_vertex = GL_TRUE;
   ctx->Extensions.ARB_map_buffer_range = GL_TRUE;
   ctx->Extensions.ARB_occlusion_query = GL_TRUE;
   ctx->Extensions.ARB_occlusion_query2 = GL_TRUE;
   ctx->Extensions.ARB_point_sprite = GL_TRUE;
   ctx->Extensions.ARB_shadow = GL_TRUE;
   ctx->Extensions.ARB_texture_border_clamp = GL_TRUE;
   ctx->Extensions.ARB_texture_cube_map = GL_TRUE;
   ctx->Extensions.ARB_texture_env_combine = GL_TRUE;
   ctx->Extensions.ARB_texture_env_crossbar = GL_TRUE;
   ctx->Extensions.ARB_texture_env_dot3 = GL_TRUE;
#ifdef TEXTURE_FLOAT_ENABLED
   ctx->Extensions.ARB_texture_float = GL_TRUE;
#endif
   ctx->Extensions.ARB_texture_mirror_clamp_to_edge = GL_TRUE;
   ctx->Extensions.ARB_texture_non_power_of_two = GL_TRUE;
   ctx->Extensions.ARB_texture_rg = GL_TRUE;
   ctx->Extensions.ARB_texture_compression_rgtc = GL_TRUE;
   ctx->Extensions.ARB_vertex_program = GL_TRUE;
   ctx->Extensions.ARB_vertex_shader = GL_TRUE;
   ctx->Extensions.ARB_sync = GL_TRUE;
   ctx->Extensions.APPLE_object_purgeable = GL_TRUE;
   ctx->Extensions.ATI_envmap_bumpmap = GL_TRUE;
   ctx->Extensions.ATI_fragment_shader = GL_TRUE;
   ctx->Extensions.ATI_texture_compression_3dc = GL_TRUE;
   ctx->Extensions.ATI_texture_env_combine3 = GL_TRUE;
   ctx->Extensions.ATI_texture_mirror_once = GL_TRUE;
   ctx->Extensions.ATI_separate_stencil = GL_TRUE;
   ctx->Extensions.EXT_blend_color = GL_TRUE;
   ctx->Extensions.EXT_blend_equation_separate = GL_TRUE;
   ctx->Extensions.EXT_blend_func_separate = GL_TRUE;
   ctx->Extensions.EXT_blend_minmax = GL_TRUE;
   ctx->Extensions.EXT_depth_bounds_test = GL_TRUE;
   ctx->Extensions.EXT_draw_buffers2 = GL_TRUE;
   ctx->Extensions.EXT_pixel_buffer_object = GL_TRUE;
   ctx->Extensions.EXT_point_parameters = GL_TRUE;
   ctx->Extensions.EXT_provoking_vertex = GL_TRUE;
   ctx->Extensions.EXT_stencil_two_side = GL_TRUE;
   ctx->Extensions.EXT_texture_array = GL_TRUE;
   ctx->Extensions.EXT_texture_compression_latc = GL_TRUE;
   ctx->Extensions.EXT_texture_env_dot3 = GL_TRUE;
   ctx->Extensions.EXT_texture_filter_anisotropic = GL_TRUE;
   ctx->Extensions.EXT_texture_mirror_clamp = GL_TRUE;
   ctx->Extensions.EXT_texture_shared_exponent = GL_TRUE;
   ctx->Extensions.EXT_texture_sRGB = GL_TRUE;
   ctx->Extensions.EXT_texture_sRGB_decode = GL_TRUE;
   ctx->Extensions.EXT_texture_swizzle = GL_TRUE;
   /*ctx->Extensions.EXT_transform_feedback = GL_TRUE;*/
   ctx->Extensions.EXT_vertex_array_bgra = GL_TRUE;
   ctx->Extensions.MESA_pack_invert = GL_TRUE;
   ctx->Extensions.MESA_ycbcr_texture = GL_TRUE;
   ctx->Extensions.NV_conditional_render = GL_TRUE;
   ctx->Extensions.NV_point_sprite = GL_TRUE;
   ctx->Extensions.NV_texture_env_combine4 = GL_TRUE;
   ctx->Extensions.NV_texture_rectangle = GL_TRUE;
   ctx->Extensions.NV_fragment_program_option = GL_TRUE;
   ctx->Extensions.EXT_gpu_program_parameters = GL_TRUE;
   ctx->Extensions.OES_standard_derivatives = GL_TRUE;
   ctx->Extensions.TDFX_texture_compression_FXT1 = GL_TRUE;
   if (ctx->Mesa_DXTn) {
      ctx->Extensions.ANGLE_texture_compression_dxt = GL_TRUE;
      ctx->Extensions.EXT_texture_compression_s3tc = GL_TRUE;
   }
}

/**
 * Either enable or disable the named extension.
 * \return GL_TRUE for success, GL_FALSE if invalid extension name
 */
static GLboolean
set_extension( struct gl_context *ctx, const char *name, GLboolean state )
{
   size_t offset;

   if (ctx->Extensions.String) {
      /* The string was already queried - can't change it now! */
      _mesa_problem(ctx, "Trying to enable/disable extension after "
                    "glGetString(GL_EXTENSIONS): %s", name);
      return GL_FALSE;
   }

   offset = name_to_offset(name);
   if (offset == 0) {
      _mesa_problem(ctx, "Trying to enable/disable unknown extension %s",
	            name);
      return GL_FALSE;
   } else if (offset == o(dummy_true) && state == GL_FALSE) {
      _mesa_problem(ctx, "Trying to disable a permanently enabled extension: "
	                  "%s", name);
      return GL_FALSE;
   } else {
      GLboolean *base = (GLboolean *) &ctx->Extensions;
      base[offset] = state;
      return GL_TRUE;
   }
}

/**
 * \brief Apply the \c MESA_EXTENSION_OVERRIDE environment variable.
 *
 * \c MESA_EXTENSION_OVERRIDE is a space-separated list of extensions to
 * enable or disable. The list is processed thus:
 *    - Enable recognized extension names that are prefixed with '+'.
 *    - Disable recognized extension names that are prefixed with '-'.
 *    - Enable recognized extension names that are not prefixed.
 *    - Collect unrecognized extension names in a new string.
 *
 * \return Space-separated list of unrecognized extension names (which must
 *    be freed). Does not return \c NULL.
 */
static char *
get_extension_override( struct gl_context *ctx )
{
   const char *env_const = _mesa_getenv("MESA_EXTENSION_OVERRIDE");
   char *env;
   char *ext;
   char *extra_exts;
   int len;

   if (env_const == NULL) {
      /* Return the empty string rather than NULL. This simplifies the logic
       * of client functions. */
      return calloc(4, sizeof(char));
   }

   /* extra_exts: List of unrecognized extensions. */
   extra_exts = calloc(ALIGN(strlen(env_const) + 2, 4), sizeof(char));

   /* Copy env_const because strtok() is destructive. */
   env = strdup(env_const);
   for (ext = strtok(env, " "); ext != NULL; ext = strtok(NULL, " ")) {
      int enable;
      int recognized;
      switch (ext[0]) {
      case '+':
         enable = 1;
         ++ext;
         break;
      case '-':
         enable = 0;
         ++ext;
         break;
      default:
         enable = 1;
         break;
      }
      recognized = set_extension(ctx, ext, enable);
      if (!recognized) {
         strcat(extra_exts, ext);
         strcat(extra_exts, " ");
      }
   }

   free(env);

   /* Remove trailing space. */
   len = strlen(extra_exts);
   if (len > 0 && extra_exts[len - 1] == ' ')
      extra_exts[len - 1] = '\0';

   return extra_exts;
}


/**
 * \brief Initialize extension tables and enable default extensions.
 *
 * This should be called during context initialization.
 * Note: Sets gl_extensions.dummy_true to true.
 */
void
_mesa_init_extensions( struct gl_context *ctx )
{
   GLboolean *base = (GLboolean *) &ctx->Extensions;
   GLboolean *sentinel = base + o(extension_sentinel);
   GLboolean *i;

   /* First, turn all extensions off. */
   for (i = base; i != sentinel; ++i)
      *i = GL_FALSE;

   /* Then, selectively turn default extensions on. */
   ctx->Extensions.dummy_true = GL_TRUE;
   ctx->Extensions.EXT_texture3D = GL_TRUE;
}


typedef unsigned short extension_index;


/**
 * Compare two entries of the extensions table.  Sorts first by year,
 * then by name.
 *
 * Arguments are indices into extension_table.
 */
static int
extension_compare(const void *p1, const void *p2)
{
   extension_index i1 = * (const extension_index *) p1;
   extension_index i2 = * (const extension_index *) p2;
   const struct extension *e1 = &extension_table[i1];
   const struct extension *e2 = &extension_table[i2];
   int res;

   res = (int)e1->year - (int)e2->year;

   if (res == 0) {
      res = strcmp(e1->name, e2->name);
   }

   return res;
}


/**
 * Construct the GL_EXTENSIONS string.  Called the first time that
 * glGetString(GL_EXTENSIONS) is called.
 */
GLubyte*
_mesa_make_extension_string(struct gl_context *ctx)
{
   /* The extension string. */
   char *exts = 0;
   /* Length of extension string. */
   size_t length = 0;
   /* Number of extensions */
   unsigned count;
   /* Indices of the extensions sorted by year */
   extension_index *extension_indices;
   /* String of extra extensions. */
   char *extra_extensions = get_extension_override(ctx);
   GLboolean *base = (GLboolean *) &ctx->Extensions;
   const struct extension *i;
   unsigned j;
   unsigned maxYear = ~0;
   unsigned api_set = (1 << ctx->API);
   if (_mesa_is_gles3(ctx))
      api_set |= ES3;

   /* Check if the MESA_EXTENSION_MAX_YEAR env var is set */
   {
      const char *env = getenv("MESA_EXTENSION_MAX_YEAR");
      if (env) {
         maxYear = atoi(env);
         _mesa_debug(ctx, "Note: limiting GL extensions to %u or earlier\n",
                     maxYear);
      }
   }

   /* Compute length of the extension string. */
   count = 0;
   for (i = extension_table; i->name != 0; ++i) {
      if (base[i->offset] &&
          i->year <= maxYear &&
          (i->api_set & api_set)) {
	 length += strlen(i->name) + 1; /* +1 for space */
	 ++count;
      }
   }
   if (extra_extensions != NULL)
      length += 1 + strlen(extra_extensions); /* +1 for space */

   exts = calloc(ALIGN(length + 1, 4), sizeof(char));
   if (exts == NULL) {
      free(extra_extensions);
      return NULL;
   }

   extension_indices = malloc(count * sizeof(extension_index));
   if (extension_indices == NULL) {
      free(exts);
      free(extra_extensions);
      return NULL;
   }

   /* Sort extensions in chronological order because certain old applications
    * (e.g., Quake3 demo) store the extension list in a static size buffer so
    * chronologically order ensure that the extensions that such applications
    * expect will fit into that buffer.
    */
   j = 0;
   for (i = extension_table; i->name != 0; ++i) {
      if (base[i->offset] &&
          i->year <= maxYear &&
          (i->api_set & api_set)) {
         extension_indices[j++] = i - extension_table;
      }
   }
   assert(j == count);
   qsort(extension_indices, count,
         sizeof *extension_indices, extension_compare);

   /* Build the extension string.*/
   for (j = 0; j < count; ++j) {
      i = &extension_table[extension_indices[j]];
      assert(base[i->offset] && (i->api_set & api_set));
      strcat(exts, i->name);
      strcat(exts, " ");
   }
   free(extension_indices);
   if (extra_extensions != 0) {
      strcat(exts, extra_extensions);
      free(extra_extensions);
   }

   return (GLubyte *) exts;
}

/**
 * Return number of enabled extensions.
 */
GLuint
_mesa_get_extension_count(struct gl_context *ctx)
{
   GLboolean *base;
   const struct extension *i;
   unsigned api_set = (1 << ctx->API);
   if (_mesa_is_gles3(ctx))
      api_set |= ES3;

   /* only count once */
   if (ctx->Extensions.Count != 0)
      return ctx->Extensions.Count;

   base = (GLboolean *) &ctx->Extensions;
   for (i = extension_table; i->name != 0; ++i) {
      if (base[i->offset] && (i->api_set & api_set)) {
	 ctx->Extensions.Count++;
      }
   }
   return ctx->Extensions.Count;
}

/**
 * Return name of i-th enabled extension
 */
const GLubyte *
_mesa_get_enabled_extension(struct gl_context *ctx, GLuint index)
{
   const GLboolean *base;
   size_t n;
   const struct extension *i;
   unsigned api_set = (1 << ctx->API);
   if (_mesa_is_gles3(ctx))
      api_set |= ES3;

   base = (GLboolean*) &ctx->Extensions;
   n = 0;
   for (i = extension_table; i->name != 0; ++i) {
      if (base[i->offset] && (i->api_set & api_set)) {
         if (n == index)
            return (const GLubyte*) i->name;
         else
            ++n;
      }
   }

   return NULL;
}
@


1.11
log
@Merge Mesa 10.2.9
@
text
@@


1.10
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a39 5
struct gl_extensions _mesa_extension_override_enables;
struct gl_extensions _mesa_extension_override_disables;
static char *extra_extensions = NULL;
static char *cant_disable_extensions = NULL;

a87 2
   { "GL_ARB_clear_texture",                       o(ARB_clear_texture),                       GL,             2013 },
   { "GL_ARB_clip_control",                        o(ARB_clip_control),                        GL,             2014 },
a88 1
   { "GL_ARB_compressed_texture_pixel_storage",    o(dummy_true),                              GL,             2011 },
a89 1
   { "GL_ARB_conditional_render_inverted",         o(ARB_conditional_render_inverted),         GL,             2014 },
a90 1
   { "GL_ARB_copy_image",                          o(ARB_copy_image),                          GL,             2012 },
a95 1
   { "GL_ARB_derivative_control",                  o(ARB_derivative_control),                  GL,             2014 },
a101 1
   { "GL_ARB_explicit_uniform_location",           o(ARB_explicit_uniform_location),           GL,             2012 },
a102 1
   { "GL_ARB_fragment_layer_viewport",             o(ARB_fragment_layer_viewport),             GLC,            2012 },
d109 1
a109 1
   { "GL_ARB_gpu_shader5",                         o(ARB_gpu_shader5),                         GLC,            2010 },
a130 1
   { "GL_ARB_seamless_cubemap_per_texture",        o(AMD_seamless_cubemap_per_texture),        GL,             2013 },
a143 1
   { "GL_ARB_texture_barrier",                     o(NV_texture_barrier),                      GL,             2014 },
a148 1
   { "GL_ARB_texture_compression_bptc",            o(ARB_texture_compression_bptc),            GL,             2010 },
a306 1
   { "GL_KHR_context_flush_control",               o(dummy_true),                              GL       | ES2, 2014 },
a316 1
   { "GL_AMD_vertex_shader_viewport_index",        o(AMD_vertex_shader_viewport_index),        GLC,            2012 },
d323 1
a390 25
/**
 * Overrides extensions in \c ctx based on the values in
 * _mesa_extension_override_enables and _mesa_extension_override_disables.
 */
static void
override_extensions_in_context(struct gl_context *ctx)
{
   const struct extension *i;
   const GLboolean *enables =
      (GLboolean*) &_mesa_extension_override_enables;
   const GLboolean *disables =
      (GLboolean*) &_mesa_extension_override_disables;
   GLboolean *ctx_ext = (GLboolean*)&ctx->Extensions;

   for (i = extension_table; i->name != 0; ++i) {
      size_t offset = i->offset;
      assert(!enables[offset] || !disables[offset]);
      if (enables[offset]) {
         ctx_ext[offset] = 1;
      } else if (disables[offset]) {
         ctx_ext[offset] = 0;
      }
   }
}

a415 1
   ctx->Extensions.ARB_texture_compression_bptc = GL_TRUE;
d431 1
d476 1
a476 1
 * \return offset of extensions withint `ext' or 0 if extension is not known
d478 2
a479 2
static size_t
set_extension(struct gl_extensions *ext, const char *name, GLboolean state)
d483 7
d491 12
a502 2
   if (offset != 0 && (offset != o(dummy_true) || state != GL_FALSE)) {
      ((GLboolean *) ext)[offset] = state;
a503 2

   return offset;
a515 4
 * \c MESA_EXTENSION_OVERRIDE was previously parsed during
 * _mesa_one_time_init_extension_overrides. We just use the results of that
 * parsing in this function.
 *
d522 1
a522 41
   override_extensions_in_context(ctx);

   if (cant_disable_extensions != NULL) {
      _mesa_problem(ctx,
                    "Trying to disable permanently enabled extensions: %s",
	            cant_disable_extensions);
   }

   if (extra_extensions == NULL) {
      return calloc(1, sizeof(char));
   } else {
      _mesa_problem(ctx, "Trying to enable unknown extensions: %s",
                    extra_extensions);
      return strdup(extra_extensions);
   }
}


/**
 * \brief Free extra_extensions and cant_disable_extensions strings
 *
 * These strings are allocated early during the first context creation by
 * _mesa_one_time_init_extension_overrides.
 */
static void
free_unknown_extensions_strings(void)
{
   free(extra_extensions);
   free(cant_disable_extensions);
}


/**
 * \brief Initialize extension override tables.
 *
 * This should be called one time early during first context initialization.
 */
void
_mesa_one_time_init_extension_overrides(void)
{
   const char *env_const = getenv("MESA_EXTENSION_OVERRIDE");
d525 1
a526 6
   size_t offset;

   atexit(free_unknown_extensions_strings);

   memset(&_mesa_extension_override_enables, 0, sizeof(struct gl_extensions));
   memset(&_mesa_extension_override_disables, 0, sizeof(struct gl_extensions));
d529 3
a531 1
      return;
d535 1
a535 2
   extra_extensions = calloc(ALIGN(strlen(env_const) + 2, 4), sizeof(char));
   cant_disable_extensions = calloc(ALIGN(strlen(env_const) + 2, 4), sizeof(char));
a538 9

   if (env == NULL || extra_extensions == NULL ||
           cant_disable_extensions == NULL) {
       free(env);
       free(extra_extensions);
       free(cant_disable_extensions);
       return;
   }

d541 1
a541 1
      bool recognized;
d555 1
a555 9

      offset = set_extension(&_mesa_extension_override_enables, ext, enable);
      if (offset != 0 && (offset != o(dummy_true) || enable != GL_FALSE)) {
         ((GLboolean *) &_mesa_extension_override_disables)[offset] = !enable;
         recognized = true;
      } else {
         recognized = false;
      }

d557 2
a558 7
         if (enable) {
            strcat(extra_extensions, ext);
            strcat(extra_extensions, " ");
         } else if (offset == o(dummy_true)) {
            strcat(cant_disable_extensions, ext);
            strcat(cant_disable_extensions, " ");
         }
d564 6
a569 15
   /* Remove trailing space, and free if unused. */
   len = strlen(extra_extensions);
   if (len == 0) {
      free(extra_extensions);
      extra_extensions = NULL;
   } else if (extra_extensions[len - 1] == ' ') {
      extra_extensions[len - 1] = '\0';
   }
   len = strlen(cant_disable_extensions);
   if (len == 0) {
      free(cant_disable_extensions);
      cant_disable_extensions = NULL;
   } else if (cant_disable_extensions[len - 1] == ' ') {
      cant_disable_extensions[len - 1] = '\0';
   }
d580 1
a580 1
_mesa_init_extensions(struct gl_extensions *extensions)
d582 1
a582 1
   GLboolean *base = (GLboolean *) extensions;
d591 2
a592 2
   extensions->dummy_true = GL_TRUE;
   extensions->EXT_texture3D = GL_TRUE;
@


1.9
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d40 5
d93 2
d96 1
d98 1
d100 1
d106 1
d113 1
d115 1
d122 1
a122 1
   { "GL_ARB_gpu_shader5",                         o(ARB_gpu_shader5),                         GL,             2010 },
d144 1
d158 1
d164 1
d323 1
d334 1
a340 1
   { "GL_ATI_envmap_bumpmap",                      o(ATI_envmap_bumpmap),                      GLL,            2001 },
d408 25
d458 1
a473 1
   ctx->Extensions.ATI_envmap_bumpmap = GL_TRUE;
d518 1
a518 1
 * \return GL_TRUE for success, GL_FALSE if invalid extension name
d520 2
a521 2
static GLboolean
set_extension( struct gl_context *ctx, const char *name, GLboolean state )
d525 3
a527 5
   if (ctx->Extensions.String) {
      /* The string was already queried - can't change it now! */
      _mesa_problem(ctx, "Trying to enable/disable extension after "
                    "glGetString(GL_EXTENSIONS): %s", name);
      return GL_FALSE;
d530 1
a530 14
   offset = name_to_offset(name);
   if (offset == 0) {
      _mesa_problem(ctx, "Trying to enable/disable unknown extension %s",
	            name);
      return GL_FALSE;
   } else if (offset == o(dummy_true) && state == GL_FALSE) {
      _mesa_problem(ctx, "Trying to disable a permanently enabled extension: "
	                  "%s", name);
      return GL_FALSE;
   } else {
      GLboolean *base = (GLboolean *) &ctx->Extensions;
      base[offset] = state;
      return GL_TRUE;
   }
d543 4
d553 41
a593 1
   const char *env_const = _mesa_getenv("MESA_EXTENSION_OVERRIDE");
a595 1
   char *extra_exts;
d597 6
d605 1
a605 3
      /* Return the empty string rather than NULL. This simplifies the logic
       * of client functions. */
      return calloc(4, sizeof(char));
d609 2
a610 1
   extra_exts = calloc(ALIGN(strlen(env_const) + 2, 4), sizeof(char));
d614 9
d625 1
a625 1
      int recognized;
d639 9
a647 1
      recognized = set_extension(ctx, ext, enable);
d649 7
a655 2
         strcat(extra_exts, ext);
         strcat(extra_exts, " ");
d661 15
a675 6
   /* Remove trailing space. */
   len = strlen(extra_exts);
   if (len > 0 && extra_exts[len - 1] == ' ')
      extra_exts[len - 1] = '\0';

   return extra_exts;
d686 1
a686 1
_mesa_init_extensions( struct gl_context *ctx )
d688 1
a688 1
   GLboolean *base = (GLboolean *) &ctx->Extensions;
d697 2
a698 2
   ctx->Extensions.dummy_true = GL_TRUE;
   ctx->Extensions.EXT_texture3D = GL_TRUE;
@


1.8
log
@Merge Mesa 9.2.1
@
text
@d83 1
d86 2
d89 1
d99 1
d110 1
a110 1
   { "GL_ARB_half_float_pixel",                    o(ARB_half_float_pixel),                    GL,             2003 },
d115 1
a115 1
   { "GL_ARB_map_buffer_alignment",                o(ARB_map_buffer_alignment),                GL,             2011 },
d117 2
d128 1
d131 2
d134 1
d142 1
d157 1
d159 1
d162 1
d169 1
d179 1
d183 1
d185 1
d203 1
a203 1
   { "GL_EXT_framebuffer_blit",                    o(EXT_framebuffer_blit),                    GL,             2005 },
d212 1
a212 1
   { "GL_EXT_packed_depth_stencil",                o(EXT_packed_depth_stencil),                GL,             2005 },
d221 1
a221 1
   { "GL_EXT_separate_shader_objects",             o(EXT_separate_shader_objects),             GLL,            2008 },
d223 1
d285 1
a285 1
   { "GL_OES_packed_depth_stencil",                o(EXT_packed_depth_stencil),                     ES1 | ES2, 2007 },
d297 1
d305 3
d312 1
d315 2
a316 1
   { "GL_AMD_vertex_shader_layer",                 o(AMD_vertex_shader_layer),                 GL,             2012 },
d334 1
a335 1
   { "GL_MESA_texture_array",                      o(MESA_texture_array),                      GLL,            2007 },
d347 1
a347 1
   { "GL_NV_packed_depth_stencil",                 o(EXT_packed_depth_stencil),                GL,             2000 },
d355 1
a408 5
   /* XXX re-enable when GLSL compiler again supports geometry shaders */
#if 0
   ctx->Extensions.ARB_geometry_shader4 = GL_TRUE;
#endif
   ctx->Extensions.ARB_half_float_pixel = GL_TRUE;
a413 1
   ctx->Extensions.EXT_separate_shader_objects = GL_TRUE;
d423 1
a442 2
   ctx->Extensions.EXT_framebuffer_blit = GL_TRUE;
   ctx->Extensions.EXT_packed_depth_stencil = GL_TRUE;
a458 1
   ctx->Extensions.MESA_texture_array = GL_TRUE;
d485 2
a486 1
      _mesa_problem(ctx, "Trying to enable/disable extension after glGetString(GL_EXTENSIONS): %s", name);
d685 4
a688 4
   /* Sort extensions in chronological order because certain old applications (e.g.,
    * Quake3 demo) store the extension list in a static size buffer so chronologically
    * order ensure that the extensions that such applications expect will fit into
    * that buffer.
d699 2
a700 1
   qsort(extension_indices, count, sizeof *extension_indices, extension_compare);
@


1.7
log
@Merge Mesa 9.2.0
@
text
@a264 1
   { "GL_OES_matrix_get",                          o(dummy_true),                                   ES1,       2004 },
@


1.6
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a2 1
 * Version:  7.6
d20 4
a23 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
d37 1
a37 1
#include "mfeatures.h"
d42 3
a44 1
   GL  = 1 << API_OPENGL,
d47 1
a77 2
 *
 * Note: The GL_MESAX_* extensions are placeholders for future ARB extensions.
d82 2
d86 3
a88 1
   { "GL_ARB_copy_buffer",                         o(ARB_copy_buffer),                         GL,             2008 },
d91 2
a92 2
   { "GL_ARB_depth_texture",                       o(ARB_depth_texture),                       GL,             2001 },
   { "GL_ARB_draw_buffers",                        o(ARB_draw_buffers),                        GL,             2002 },
d98 2
a99 2
   { "GL_ARB_fragment_program",                    o(ARB_fragment_program),                    GL,             2002 },
   { "GL_ARB_fragment_program_shadow",             o(ARB_fragment_program_shadow),             GL,             2003 },
d103 2
d108 3
d112 2
a113 2
   { "GL_ARB_multisample",                         o(ARB_multisample),                         GL,             1994 },
   { "GL_ARB_multitexture",                        o(ARB_multitexture),                        GL,             1998 },
d115 1
a115 1
   { "GL_ARB_occlusion_query",                     o(ARB_occlusion_query),                     GL,             2001 },
d117 1
a117 1
   { "GL_ARB_point_parameters",                    o(EXT_point_parameters),                    GL,             1997 },
d121 1
a121 1
   { "GL_ARB_sampler_objects",                     o(ARB_sampler_objects),                     GL,             2009 },
d123 2
a124 1
   { "GL_ARB_shader_objects",                      o(ARB_shader_objects),                      GL,             2002 },
d127 4
a130 3
   { "GL_ARB_shading_language_100",                o(ARB_shading_language_100),                GL,             2003 },
   { "GL_ARB_shadow_ambient",                      o(ARB_shadow_ambient),                      GL,             2001 },
   { "GL_ARB_shadow",                              o(ARB_shadow),                              GL,             2001 },
d132 5
a136 3
   { "GL_ARB_texture_border_clamp",                o(ARB_texture_border_clamp),                GL,             2000 },
   { "GL_ARB_texture_buffer_object",               o(ARB_texture_buffer_object),               GL,             2008 },
   { "GL_ARB_texture_compression",                 o(ARB_texture_compression),                 GL,             2000 },
d138 6
a143 5
   { "GL_ARB_texture_cube_map",                    o(ARB_texture_cube_map),                    GL,             1999 },
   { "GL_ARB_texture_env_add",                     o(EXT_texture_env_add),                     GL,             1999 },
   { "GL_ARB_texture_env_combine",                 o(ARB_texture_env_combine),                 GL,             2001 },
   { "GL_ARB_texture_env_crossbar",                o(ARB_texture_env_crossbar),                GL,             2001 },
   { "GL_ARB_texture_env_dot3",                    o(ARB_texture_env_dot3),                    GL,             2001 },
d145 1
a145 1
   { "GL_ARB_texture_mirrored_repeat",             o(ARB_texture_mirrored_repeat),             GL,             2001 },
d148 1
d152 2
d155 1
d157 4
a160 2
   { "GL_ARB_transpose_matrix",                    o(ARB_transpose_matrix),                    GL,             1999 },
   { "GL_ARB_uniform_buffer_object",               o(ARB_uniform_buffer_object),               GL,             2002 },
d162 3
a164 3
   { "GL_ARB_vertex_array_object",                 o(ARB_vertex_array_object),                 GL,             2006 },
   { "GL_ARB_vertex_buffer_object",                o(ARB_vertex_buffer_object),                GL,             2003 },
   { "GL_ARB_vertex_program",                      o(ARB_vertex_program),                      GL,             2002 },
d167 1
a167 1
   { "GL_ARB_window_pos",                          o(ARB_window_pos),                          GL,             2001 },
d169 3
a171 3
   { "GL_EXT_abgr",                                o(EXT_abgr),                                GL,             1995 },
   { "GL_EXT_bgra",                                o(EXT_bgra),                                GL,             1995 },
   { "GL_EXT_blend_color",                         o(EXT_blend_color),                         GL,             1995 },
d173 6
a178 7
   { "GL_EXT_blend_func_separate",                 o(EXT_blend_func_separate),                 GL,             1999 },
   { "GL_EXT_blend_logic_op",                      o(EXT_blend_logic_op),                      GL,             1995 },
   { "GL_EXT_blend_minmax",                        o(EXT_blend_minmax),                        GL | ES1 | ES2, 1995 },
   { "GL_EXT_blend_subtract",                      o(EXT_blend_subtract),                      GL,             1995 },
   { "GL_EXT_clip_volume_hint",                    o(EXT_clip_volume_hint),                    GL,             1996 },
   { "GL_EXT_compiled_vertex_array",               o(EXT_compiled_vertex_array),               GL,             1996 },
   { "GL_EXT_copy_texture",                        o(EXT_copy_texture),                        GL,             1995 },
d182 2
a183 2
   { "GL_EXT_draw_range_elements",                 o(EXT_draw_range_elements),                 GL,             1997 },
   { "GL_EXT_fog_coord",                           o(EXT_fog_coord),                           GL,             1999 },
d186 2
a187 1
   { "GL_EXT_framebuffer_object",                  o(EXT_framebuffer_object),                  GL,             2000 },
d189 1
a189 1
   { "GL_EXT_gpu_program_parameters",              o(EXT_gpu_program_parameters),              GL,             2006 },
d191 2
a192 1
   { "GL_EXT_multi_draw_arrays",                   o(EXT_multi_draw_arrays),                   GL | ES1 | ES2, 1999 },
d195 1
a195 2
   { "GL_EXT_packed_pixels",                       o(EXT_packed_pixels),                       GL,             1997 },
   { "GL_EXT_paletted_texture",                    o(EXT_paletted_texture),                    GL,             1995 },
d197 2
a198 2
   { "GL_EXT_point_parameters",                    o(EXT_point_parameters),                    GL,             1997 },
   { "GL_EXT_polygon_offset",                      o(EXT_polygon_offset),                      GL,             1995 },
d200 9
a208 10
   { "GL_EXT_rescale_normal",                      o(EXT_rescale_normal),                      GL,             1997 },
   { "GL_EXT_secondary_color",                     o(EXT_secondary_color),                     GL,             1999 },
   { "GL_EXT_separate_shader_objects",             o(EXT_separate_shader_objects),             GL,             2008 },
   { "GL_EXT_separate_specular_color",             o(EXT_separate_specular_color),             GL,             1997 },
   { "GL_EXT_shadow_funcs",                        o(EXT_shadow_funcs),                        GL,             2002 },
   { "GL_EXT_shared_texture_palette",              o(EXT_shared_texture_palette),              GL,             2000 },
   { "GL_EXT_stencil_two_side",                    o(EXT_stencil_two_side),                    GL,             2001 },
   { "GL_EXT_stencil_wrap",                        o(EXT_stencil_wrap),                        GL,             2002 },
   { "GL_EXT_subtexture",                          o(EXT_subtexture),                          GL,             1995 },
   { "GL_EXT_texture3D",                           o(EXT_texture3D),                           GL,             1996 },
d210 3
a212 1
   { "GL_EXT_texture_compression_dxt1",            o(EXT_texture_compression_s3tc),            GL | ES1 | ES2, 2004 },
d216 5
a220 5
   { "GL_EXT_texture_cube_map",                    o(ARB_texture_cube_map),                    GL,             2001 },
   { "GL_EXT_texture_edge_clamp",                  o(SGIS_texture_edge_clamp),                 GL,             1997 },
   { "GL_EXT_texture_env_add",                     o(EXT_texture_env_add),                     GL,             1999 },
   { "GL_EXT_texture_env_combine",                 o(EXT_texture_env_combine),                 GL,             2006 },
   { "GL_EXT_texture_env_dot3",                    o(EXT_texture_env_dot3),                    GL,             2000 },
d222 3
a224 1
   { "GL_EXT_texture_format_BGRA8888",             o(EXT_texture_format_BGRA8888),                  ES1 | ES2, 2009 },
d226 1
a226 1
   { "GL_EXT_texture_lod_bias",                    o(EXT_texture_lod_bias),                    GL | ES1,       1999 },
d228 3
a230 3
   { "GL_EXT_texture_object",                      o(EXT_texture_object),                      GL,             1995 },
   { "GL_EXT_texture",                             o(EXT_texture),                             GL,             1996 },
   { "GL_EXT_texture_rectangle",                   o(NV_texture_rectangle),                    GL,             2004 },
d239 1
d241 2
a242 2
   { "GL_EXT_vertex_array",                        o(EXT_vertex_array),                        GL,             1995 },
   { "GL_EXT_vertex_array_set",                    o(EXT_vertex_array_set),                    GL,             1997 },
d247 1
a247 1
   { "GL_OES_blend_subtract",                      o(EXT_blend_subtract),                           ES1,       2009 },
d249 1
d251 1
a251 1
   { "GL_OES_depth24",                             o(EXT_framebuffer_object),                       ES1 | ES2, 2005 },
d254 2
a255 4
#if FEATURE_OES_draw_texture
   { "GL_OES_draw_texture",                        o(OES_draw_texture),                             ES1 | ES2, 2004 },
#endif
#if FEATURE_OES_EGL_image
d258 3
a260 3
#endif
   { "GL_OES_element_index_uint",                  o(EXT_vertex_array),                             ES1 | ES2, 2005 },
   { "GL_OES_fbo_render_mipmap",                   o(EXT_framebuffer_object),                       ES1 | ES2, 2005 },
d262 3
a264 2
   { "GL_OES_framebuffer_object",                  o(EXT_framebuffer_object),                       ES1,       2005 },
   { "GL_OES_mapbuffer",                           o(ARB_vertex_buffer_object),                     ES1 | ES2, 2005 },
d270 2
a271 2
   { "GL_OES_read_format",                         o(OES_read_format),                         GL | ES1,       2003 },
   { "GL_OES_rgb8_rgba8",                          o(EXT_framebuffer_object),                       ES1 | ES2, 2005 },
d276 2
a277 2
   { "GL_OES_stencil8",                            o(EXT_framebuffer_object),                       ES1 | ES2, 2005 },
   { "GL_OES_stencil_wrap",                        o(EXT_stencil_wrap),                             ES1,       2002 },
d281 3
a283 2
   { "GL_OES_texture_mirrored_repeat",             o(ARB_texture_mirrored_repeat),                  ES1,       2005 },
   { "GL_OES_texture_npot",                        o(ARB_texture_non_power_of_two),                       ES2, 2005 },
d287 1
a287 1
   { "GL_AMD_conservative_depth",                  o(AMD_conservative_depth),                  GL,             2009 },
d291 1
a291 1
   { "GL_APPLE_client_storage",                    o(APPLE_client_storage),                    GL,             2002 },
d293 3
a295 2
   { "GL_APPLE_packed_pixels",                     o(APPLE_packed_pixels),                     GL,             2002 },
   { "GL_APPLE_vertex_array_object",               o(APPLE_vertex_array_object),               GL,             2002 },
d297 4
a300 4
   { "GL_ATI_draw_buffers",                        o(ARB_draw_buffers),                        GL,             2002 },
   { "GL_ATI_envmap_bumpmap",                      o(ATI_envmap_bumpmap),                      GL,             2001 },
   { "GL_ATI_fragment_shader",                     o(ATI_fragment_shader),                     GL,             2001 },
   { "GL_ATI_separate_stencil",                    o(ATI_separate_stencil),                    GL,             2006 },
d302 1
a302 1
   { "GL_ATI_texture_env_combine3",                o(ATI_texture_env_combine3),                GL,             2002 },
d305 4
a308 4
   { "GL_IBM_multimode_draw_arrays",               o(IBM_multimode_draw_arrays),               GL,             1998 },
   { "GL_IBM_rasterpos_clip",                      o(IBM_rasterpos_clip),                      GL,             1996 },
   { "GL_IBM_texture_mirrored_repeat",             o(ARB_texture_mirrored_repeat),             GL,             1998 },
   { "GL_INGR_blend_func_separate",                o(EXT_blend_func_separate),                 GL,             1999 },
d310 1
a310 2
   { "GL_MESA_resize_buffers",                     o(MESA_resize_buffers),                     GL,             1999 },
   { "GL_MESA_texture_array",                      o(MESA_texture_array),                      GL,             2007 },
d312 1
a312 1
   { "GL_MESA_window_pos",                         o(ARB_window_pos),                          GL,             2000 },
d314 1
a314 1
   { "GL_NV_blend_square",                         o(NV_blend_square),                         GL,             1999 },
d317 5
a321 3
   { "GL_NV_fragment_program",                     o(NV_fragment_program),                     GL,             2001 },
   { "GL_NV_fragment_program_option",              o(NV_fragment_program_option),              GL,             2005 },
   { "GL_NV_light_max_exponent",                   o(NV_light_max_exponent),                   GL,             1999 },
d324 3
a326 2
   { "GL_NV_primitive_restart",                    o(NV_primitive_restart),                    GL,             2002 },
   { "GL_NV_texgen_reflection",                    o(NV_texgen_reflection),                    GL,             1999 },
d328 8
a335 10
   { "GL_NV_texture_env_combine4",                 o(NV_texture_env_combine4),                 GL,             1999 },
   { "GL_NV_texture_rectangle",                    o(NV_texture_rectangle),                    GL,             2000 },
   { "GL_NV_vertex_program1_1",                    o(NV_vertex_program1_1),                    GL,             2001 },
   { "GL_NV_vertex_program",                       o(NV_vertex_program),                       GL,             2000 },
   { "GL_S3_s3tc",                                 o(S3_s3tc),                                 GL,             1999 },
   { "GL_SGIS_generate_mipmap",                    o(SGIS_generate_mipmap),                    GL,             1997 },
   { "GL_SGIS_texture_border_clamp",               o(ARB_texture_border_clamp),                GL,             1997 },
   { "GL_SGIS_texture_edge_clamp",                 o(SGIS_texture_edge_clamp),                 GL,             1997 },
   { "GL_SGIS_texture_lod",                        o(SGIS_texture_lod),                        GL,             1997 },
   { "GL_SUN_multi_draw_arrays",                   o(EXT_multi_draw_arrays),                   GL,             1999 },
a366 49
 * \brief Extensions enabled by default.
 *
 * These extensions are enabled by _mesa_init_extensions().
 *
 * XXX: Should these defaults also apply to GLES?
 */
static const size_t default_extensions[] = {
   o(ARB_copy_buffer),
   o(ARB_draw_buffers),
   o(ARB_multisample),
   o(ARB_texture_compression),
   o(ARB_transpose_matrix),
   o(ARB_vertex_buffer_object),
   o(ARB_window_pos),

   o(EXT_abgr),
   o(EXT_bgra),
   o(EXT_compiled_vertex_array),
   o(EXT_copy_texture),
   o(EXT_draw_range_elements),
   o(EXT_multi_draw_arrays),
   o(EXT_packed_pixels),
   o(EXT_polygon_offset),
   o(EXT_rescale_normal),
   o(EXT_separate_specular_color),
   o(EXT_subtexture),
   o(EXT_texture),
   o(EXT_texture3D),
   o(EXT_texture_object),
   o(EXT_vertex_array),

   o(OES_read_format),
   o(OES_standard_derivatives),

   /* Vendor Extensions */
   o(APPLE_packed_pixels),
   o(IBM_multimode_draw_arrays),
   o(IBM_rasterpos_clip),
   o(NV_light_max_exponent),
   o(NV_texgen_reflection),
   o(SGIS_generate_mipmap),
   o(SGIS_texture_edge_clamp),
   o(SGIS_texture_lod),

   0,
};


/**
a372 1
   /*ctx->Extensions.ARB_copy_buffer = GL_TRUE;*/
a374 1
   /*ctx->Extensions.ARB_draw_buffers = GL_TRUE;*/
a378 1
#if FEATURE_ARB_fragment_program
a380 2
#endif
#if FEATURE_ARB_fragment_shader
a381 2
#endif
#if FEATURE_ARB_framebuffer_object
a382 2
#endif
#if FEATURE_ARB_geometry_shader4 && 0
d384 1
a389 2
   ctx->Extensions.ARB_multitexture = GL_TRUE;
#if FEATURE_queryobj
a391 1
#endif
a392 2
#if FEATURE_ARB_shader_objects
   ctx->Extensions.ARB_shader_objects = GL_TRUE;
a393 4
#endif
#if FEATURE_ARB_shading_language_100
   ctx->Extensions.ARB_shading_language_100 = GL_TRUE;
#endif
a394 1
   ctx->Extensions.ARB_shadow_ambient = GL_TRUE;
d400 3
a402 2
   /*ctx->Extensions.ARB_texture_float = GL_TRUE;*/
   ctx->Extensions.ARB_texture_mirrored_repeat = GL_TRUE;
a405 2
   ctx->Extensions.ARB_vertex_array_object = GL_TRUE;
#if FEATURE_ARB_vertex_program
a406 2
#endif
#if FEATURE_ARB_vertex_shader
a407 5
#endif
#if FEATURE_ARB_vertex_buffer_object
   /*ctx->Extensions.ARB_vertex_buffer_object = GL_TRUE;*/
#endif
#if FEATURE_ARB_sync
a408 3
#endif
   ctx->Extensions.APPLE_vertex_array_object = GL_TRUE;
#if FEATURE_APPLE_object_purgeable
a409 1
#endif
a410 1
#if FEATURE_ATI_fragment_shader
a411 1
#endif
a418 1
   ctx->Extensions.EXT_blend_logic_op = GL_TRUE;
a419 1
   ctx->Extensions.EXT_blend_subtract = GL_TRUE;
a421 5
   ctx->Extensions.EXT_fog_coord = GL_TRUE;
#if FEATURE_EXT_framebuffer_object
   ctx->Extensions.EXT_framebuffer_object = GL_TRUE;
#endif
#if FEATURE_EXT_framebuffer_blit
a422 5
#endif
#if FEATURE_ARB_framebuffer_object
   ctx->Extensions.EXT_framebuffer_multisample = GL_TRUE;
#endif
   /*ctx->Extensions.EXT_multi_draw_arrays = GL_TRUE;*/
a423 2
   ctx->Extensions.EXT_paletted_texture = GL_TRUE;
#if FEATURE_EXT_pixel_buffer_object
a424 1
#endif
a426 4
   ctx->Extensions.EXT_shadow_funcs = GL_TRUE;
   ctx->Extensions.EXT_secondary_color = GL_TRUE;
   ctx->Extensions.EXT_shared_texture_palette = GL_TRUE;
   ctx->Extensions.EXT_stencil_wrap = GL_TRUE;
a429 2
   ctx->Extensions.EXT_texture_env_add = GL_TRUE;
   ctx->Extensions.EXT_texture_env_combine = GL_TRUE;
a432 1
   ctx->Extensions.EXT_texture_lod_bias = GL_TRUE;
a433 1
#if FEATURE_EXT_texture_sRGB
a435 1
#endif
a436 1
#if FEATURE_EXT_transform_feedback
a437 1
#endif
a438 1
   /*ctx->Extensions.IBM_multimode_draw_arrays = GL_TRUE;*/
a439 1
   ctx->Extensions.MESA_resize_buffers = GL_TRUE;
a441 1
   ctx->Extensions.NV_blend_square = GL_TRUE;
a442 1
   /*ctx->Extensions.NV_light_max_exponent = GL_TRUE;*/
a445 9
   /*ctx->Extensions.NV_texgen_reflection = GL_TRUE;*/
#if FEATURE_NV_vertex_program
   ctx->Extensions.NV_vertex_program = GL_TRUE;
   ctx->Extensions.NV_vertex_program1_1 = GL_TRUE;
#endif
#if FEATURE_NV_fragment_program
   ctx->Extensions.NV_fragment_program = GL_TRUE;
#endif
#if FEATURE_NV_fragment_program && FEATURE_ARB_fragment_program
a446 4
#endif
   /*ctx->Extensions.SGIS_generate_mipmap = GL_TRUE;*/
   ctx->Extensions.SGIS_texture_edge_clamp = GL_TRUE;
#if FEATURE_ARB_vertex_program || FEATURE_ARB_fragment_program
d448 2
a449 5
#endif
#if FEATURE_texture_fxt1
   _mesa_enable_extension(ctx, "GL_3DFX_texture_compression_FXT1");
#endif
#if FEATURE_texture_s3tc
d451 2
a452 2
      _mesa_enable_extension(ctx, "GL_EXT_texture_compression_s3tc");
      _mesa_enable_extension(ctx, "GL_S3_s3tc");
a453 101
#endif
}


/**
 * Enable common EXT extensions in the ARB_imaging subset.
 */
void
_mesa_enable_imaging_extensions(struct gl_context *ctx)
{
   ctx->Extensions.EXT_blend_color = GL_TRUE;
   ctx->Extensions.EXT_blend_logic_op = GL_TRUE;
   ctx->Extensions.EXT_blend_minmax = GL_TRUE;
   ctx->Extensions.EXT_blend_subtract = GL_TRUE;
}



/**
 * Enable all OpenGL 1.3 features and extensions.
 * A convenience function to be called by drivers.
 */
void
_mesa_enable_1_3_extensions(struct gl_context *ctx)
{
   /*ctx->Extensions.ARB_multisample = GL_TRUE;*/
   ctx->Extensions.ARB_multitexture = GL_TRUE;
   ctx->Extensions.ARB_texture_border_clamp = GL_TRUE;
   /*ctx->Extensions.ARB_texture_compression = GL_TRUE;*/
   ctx->Extensions.ARB_texture_cube_map = GL_TRUE;
   ctx->Extensions.ARB_texture_env_combine = GL_TRUE;
   ctx->Extensions.ARB_texture_env_dot3 = GL_TRUE;
   ctx->Extensions.EXT_texture_env_add = GL_TRUE;
   /*ctx->Extensions.ARB_transpose_matrix = GL_TRUE;*/
}



/**
 * Enable all OpenGL 1.4 features and extensions.
 * A convenience function to be called by drivers.
 */
void
_mesa_enable_1_4_extensions(struct gl_context *ctx)
{
   ctx->Extensions.ARB_depth_texture = GL_TRUE;
   ctx->Extensions.ARB_shadow = GL_TRUE;
   ctx->Extensions.ARB_texture_env_crossbar = GL_TRUE;
   ctx->Extensions.ARB_texture_mirrored_repeat = GL_TRUE;
   ctx->Extensions.ARB_window_pos = GL_TRUE;
   ctx->Extensions.EXT_blend_color = GL_TRUE;
   ctx->Extensions.EXT_blend_func_separate = GL_TRUE;
   ctx->Extensions.EXT_blend_minmax = GL_TRUE;
   ctx->Extensions.EXT_blend_subtract = GL_TRUE;
   ctx->Extensions.EXT_fog_coord = GL_TRUE;
   /*ctx->Extensions.EXT_multi_draw_arrays = GL_TRUE;*/
   ctx->Extensions.EXT_point_parameters = GL_TRUE;
   ctx->Extensions.EXT_secondary_color = GL_TRUE;
   ctx->Extensions.EXT_stencil_wrap = GL_TRUE;
   ctx->Extensions.EXT_texture_lod_bias = GL_TRUE;
   /*ctx->Extensions.SGIS_generate_mipmap = GL_TRUE;*/
}


/**
 * Enable all OpenGL 1.5 features and extensions.
 * A convenience function to be called by drivers.
 */
void
_mesa_enable_1_5_extensions(struct gl_context *ctx)
{
   ctx->Extensions.ARB_occlusion_query = GL_TRUE;
   /*ctx->Extensions.ARB_vertex_buffer_object = GL_TRUE;*/
   ctx->Extensions.EXT_shadow_funcs = GL_TRUE;
}


/**
 * Enable all OpenGL 2.0 features and extensions.
 * A convenience function to be called by drivers.
 */
void
_mesa_enable_2_0_extensions(struct gl_context *ctx)
{
   /*ctx->Extensions.ARB_draw_buffers = GL_TRUE;*/
#if FEATURE_ARB_fragment_shader
   ctx->Extensions.ARB_fragment_shader = GL_TRUE;
#endif
   ctx->Extensions.ARB_point_sprite = GL_TRUE;
   ctx->Extensions.EXT_blend_equation_separate = GL_TRUE;
   ctx->Extensions.ARB_texture_non_power_of_two = GL_TRUE;
#if FEATURE_ARB_shader_objects
   ctx->Extensions.ARB_shader_objects = GL_TRUE;
#endif
#if FEATURE_ARB_shading_language_100
   ctx->Extensions.ARB_shading_language_100 = GL_TRUE;
#endif
   ctx->Extensions.EXT_stencil_two_side = GL_TRUE;
#if FEATURE_ARB_vertex_shader
   ctx->Extensions.ARB_vertex_shader = GL_TRUE;
#endif
a455 17

/**
 * Enable all OpenGL 2.1 features and extensions.
 * A convenience function to be called by drivers.
 */
void
_mesa_enable_2_1_extensions(struct gl_context *ctx)
{
#if FEATURE_EXT_pixel_buffer_object
   ctx->Extensions.EXT_pixel_buffer_object = GL_TRUE;
#endif
#if FEATURE_EXT_texture_sRGB
   ctx->Extensions.EXT_texture_sRGB = GL_TRUE;
#endif
}


a486 45

/**
 * Enable the named extension.
 * Typically called by drivers.
 */
void
_mesa_enable_extension( struct gl_context *ctx, const char *name )
{
   if (!set_extension(ctx, name, GL_TRUE))
      _mesa_problem(ctx, "Trying to enable unknown extension: %s", name);
}


/**
 * Disable the named extension.
 * XXX is this really needed???
 */
void
_mesa_disable_extension( struct gl_context *ctx, const char *name )
{
   if (!set_extension(ctx, name, GL_FALSE))
      _mesa_problem(ctx, "Trying to disable unknown extension: %s", name);
}


/**
 * Test if the named extension is enabled in this context.
 */
GLboolean
_mesa_extension_is_enabled( struct gl_context *ctx, const char *name )
{
   size_t offset;
   GLboolean *base;

   if (name == 0)
      return GL_FALSE;

   offset = name_to_offset(name);
   if (offset == 0)
      return GL_FALSE;
   base = (GLboolean *) &ctx->Extensions;
   return base[offset];
}


d512 1
a512 1
      return calloc(1, sizeof(char));
d516 1
a516 1
   extra_exts = calloc(strlen(env_const), sizeof(char));
d543 2
d547 1
a547 1
   if (extra_exts[len - 1] == ' ')
a565 1
   const size_t *j;
d573 1
a573 2
   for (j = default_extensions; *j != 0; ++j)
      base[*j] = GL_TRUE;
d626 3
d645 1
a645 1
          (i->api_set & (1 << ctx->API))) {
d653 1
a653 1
   exts = (char *) calloc(length + 1, sizeof(char));
d675 1
a675 1
          (i->api_set & (1 << ctx->API))) {
d685 1
a685 1
      assert(base[i->offset] && (i->api_set & (1 << ctx->API)));
d706 3
d716 1
a716 1
      if (base[i->offset]) {
d732 3
a734 3

   if (index < 0)
      return NULL;
d739 5
a743 4
      if (n == index && base[i->offset]) {
	 return (GLubyte*) i->name;
      } else if (base[i->offset]) {
	 ++n;
@


1.5
log
@Merge Mesa 7.10.3
@
text
@d37 1
d59 4
d80 67
a146 62
   { "GL_ARB_ES2_compatibility",                   o(ARB_ES2_compatibility),                   GL             },
   { "GL_ARB_blend_func_extended",                 o(ARB_blend_func_extended),                 GL             },
   { "GL_ARB_copy_buffer",                         o(ARB_copy_buffer),                         GL             },
   { "GL_ARB_depth_buffer_float",                  o(ARB_depth_buffer_float),                  GL             },
   { "GL_ARB_depth_clamp",                         o(ARB_depth_clamp),                         GL             },
   { "GL_ARB_depth_texture",                       o(ARB_depth_texture),                       GL             },
   { "GL_ARB_draw_buffers",                        o(ARB_draw_buffers),                        GL             },
   { "GL_ARB_draw_elements_base_vertex",           o(ARB_draw_elements_base_vertex),           GL             },
   { "GL_ARB_draw_instanced",                      o(ARB_draw_instanced),                      GL             },
   { "GL_ARB_explicit_attrib_location",            o(ARB_explicit_attrib_location),            GL             },
   { "GL_ARB_fragment_coord_conventions",          o(ARB_fragment_coord_conventions),          GL             },
   { "GL_ARB_fragment_program",                    o(ARB_fragment_program),                    GL             },
   { "GL_ARB_fragment_program_shadow",             o(ARB_fragment_program_shadow),             GL             },
   { "GL_ARB_fragment_shader",                     o(ARB_fragment_shader),                     GL             },
   { "GL_ARB_framebuffer_object",                  o(ARB_framebuffer_object),                  GL             },
   { "GL_ARB_half_float_pixel",                    o(ARB_half_float_pixel),                    GL             },
   { "GL_ARB_half_float_vertex",                   o(ARB_half_float_vertex),                   GL             },
   { "GL_ARB_instanced_arrays",                    o(ARB_instanced_arrays),                    GL             },
   { "GL_ARB_map_buffer_range",                    o(ARB_map_buffer_range),                    GL             },
   { "GL_ARB_multisample",                         o(ARB_multisample),                         GL             },
   { "GL_ARB_multitexture",                        o(ARB_multitexture),                        GL             },
   { "GL_ARB_occlusion_query2",                    o(ARB_occlusion_query2),                    GL             },
   { "GL_ARB_occlusion_query",                     o(ARB_occlusion_query),                     GL             },
   { "GL_ARB_pixel_buffer_object",                 o(EXT_pixel_buffer_object),                 GL             },
   { "GL_ARB_point_parameters",                    o(EXT_point_parameters),                    GL             },
   { "GL_ARB_point_sprite",                        o(ARB_point_sprite),                        GL             },
   { "GL_ARB_provoking_vertex",                    o(EXT_provoking_vertex),                    GL             },
   { "GL_ARB_sampler_objects",                     o(ARB_sampler_objects),                     GL             },
   { "GL_ARB_seamless_cube_map",                   o(ARB_seamless_cube_map),                   GL             },
   { "GL_ARB_shader_objects",                      o(ARB_shader_objects),                      GL             },
   { "GL_ARB_shader_stencil_export",               o(ARB_shader_stencil_export),               GL             },
   { "GL_ARB_shading_language_100",                o(ARB_shading_language_100),                GL             },
   { "GL_ARB_shadow_ambient",                      o(ARB_shadow_ambient),                      GL             },
   { "GL_ARB_shadow",                              o(ARB_shadow),                              GL             },
   { "GL_ARB_sync",                                o(ARB_sync),                                GL             },
   { "GL_ARB_texture_border_clamp",                o(ARB_texture_border_clamp),                GL             },
   { "GL_ARB_texture_buffer_object",               o(ARB_texture_buffer_object),               GL             },
   { "GL_ARB_texture_compression",                 o(ARB_texture_compression),                 GL             },
   { "GL_ARB_texture_compression_rgtc",            o(ARB_texture_compression_rgtc),            GL             },
   { "GL_ARB_texture_cube_map",                    o(ARB_texture_cube_map),                    GL             },
   { "GL_ARB_texture_env_add",                     o(EXT_texture_env_add),                     GL             },
   { "GL_ARB_texture_env_combine",                 o(ARB_texture_env_combine),                 GL             },
   { "GL_ARB_texture_env_crossbar",                o(ARB_texture_env_crossbar),                GL             },
   { "GL_ARB_texture_env_dot3",                    o(ARB_texture_env_dot3),                    GL             },
   { "GL_ARB_texture_mirrored_repeat",             o(ARB_texture_mirrored_repeat),             GL             },
   { "GL_ARB_texture_multisample",                 o(ARB_texture_multisample),                 GL             },
   { "GL_ARB_texture_non_power_of_two",            o(ARB_texture_non_power_of_two),            GL             },
   { "GL_ARB_texture_rectangle",                   o(NV_texture_rectangle),                    GL             },
   { "GL_ARB_texture_rgb10_a2ui",                  o(ARB_texture_rgb10_a2ui),                  GL             },
   { "GL_ARB_texture_rg",                          o(ARB_texture_rg),                          GL             },
   { "GL_ARB_texture_swizzle",                     o(EXT_texture_swizzle),                     GL             },
   { "GL_ARB_transform_feedback2",                 o(ARB_transform_feedback2),                 GL             },
   { "GL_ARB_transpose_matrix",                    o(ARB_transpose_matrix),                    GL             },
   { "GL_ARB_uniform_buffer_object",               o(ARB_uniform_buffer_object),               GL             },
   { "GL_ARB_vertex_array_bgra",                   o(EXT_vertex_array_bgra),                   GL             },
   { "GL_ARB_vertex_array_object",                 o(ARB_vertex_array_object),                 GL             },
   { "GL_ARB_vertex_buffer_object",                o(ARB_vertex_buffer_object),                GL             },
   { "GL_ARB_vertex_program",                      o(ARB_vertex_program),                      GL             },
   { "GL_ARB_vertex_shader",                       o(ARB_vertex_shader),                       GL             },
   { "GL_ARB_vertex_type_2_10_10_10_rev",          o(ARB_vertex_type_2_10_10_10_rev),          GL             },
   { "GL_ARB_window_pos",                          o(ARB_window_pos),                          GL             },

d148 70
a217 67
   { "GL_EXT_abgr",                                o(EXT_abgr),                                GL             },
   { "GL_EXT_bgra",                                o(EXT_bgra),                                GL             },
   { "GL_EXT_blend_color",                         o(EXT_blend_color),                         GL             },
   { "GL_EXT_blend_equation_separate",             o(EXT_blend_equation_separate),             GL             },
   { "GL_EXT_blend_func_separate",                 o(EXT_blend_func_separate),                 GL             },
   { "GL_EXT_blend_logic_op",                      o(EXT_blend_logic_op),                      GL             },
   { "GL_EXT_blend_minmax",                        o(EXT_blend_minmax),                        GL | ES1 | ES2 },
   { "GL_EXT_blend_subtract",                      o(EXT_blend_subtract),                      GL             },
   { "GL_EXT_clip_volume_hint",                    o(EXT_clip_volume_hint),                    GL             },
   { "GL_EXT_compiled_vertex_array",               o(EXT_compiled_vertex_array),               GL             },
   { "GL_EXT_copy_texture",                        o(EXT_copy_texture),                        GL             },
   { "GL_EXT_depth_bounds_test",                   o(EXT_depth_bounds_test),                   GL             },
   { "GL_EXT_draw_buffers2",                       o(EXT_draw_buffers2),                       GL             },
   { "GL_EXT_draw_instanced",                      o(ARB_draw_instanced),                      GL             },
   { "GL_EXT_draw_range_elements",                 o(EXT_draw_range_elements),                 GL             },
   { "GL_EXT_fog_coord",                           o(EXT_fog_coord),                           GL             },
   { "GL_EXT_framebuffer_blit",                    o(EXT_framebuffer_blit),                    GL             },
   { "GL_EXT_framebuffer_multisample",             o(EXT_framebuffer_multisample),             GL             },
   { "GL_EXT_framebuffer_object",                  o(EXT_framebuffer_object),                  GL             },
   { "GL_EXT_framebuffer_sRGB",                    o(EXT_framebuffer_sRGB),                    GL             },
   { "GL_EXT_gpu_program_parameters",              o(EXT_gpu_program_parameters),              GL             },
   { "GL_EXT_gpu_shader4",                         o(EXT_gpu_shader4),                         GL             },
   { "GL_EXT_multi_draw_arrays",                   o(EXT_multi_draw_arrays),                   GL | ES1 | ES2 },
   { "GL_EXT_packed_depth_stencil",                o(EXT_packed_depth_stencil),                GL             },
   { "GL_EXT_packed_float",                        o(EXT_packed_float),                        GL             },
   { "GL_EXT_packed_pixels",                       o(EXT_packed_pixels),                       GL             },
   { "GL_EXT_paletted_texture",                    o(EXT_paletted_texture),                    GL             },
   { "GL_EXT_pixel_buffer_object",                 o(EXT_pixel_buffer_object),                 GL             },
   { "GL_EXT_point_parameters",                    o(EXT_point_parameters),                    GL             },
   { "GL_EXT_polygon_offset",                      o(EXT_polygon_offset),                      GL             },
   { "GL_EXT_provoking_vertex",                    o(EXT_provoking_vertex),                    GL             },
   { "GL_EXT_rescale_normal",                      o(EXT_rescale_normal),                      GL             },
   { "GL_EXT_secondary_color",                     o(EXT_secondary_color),                     GL             },
   { "GL_EXT_separate_shader_objects",             o(EXT_separate_shader_objects),             GL             },
   { "GL_EXT_separate_specular_color",             o(EXT_separate_specular_color),             GL             },
   { "GL_EXT_shadow_funcs",                        o(EXT_shadow_funcs),                        GL             },
   { "GL_EXT_shared_texture_palette",              o(EXT_shared_texture_palette),              GL             },
   { "GL_EXT_stencil_two_side",                    o(EXT_stencil_two_side),                    GL             },
   { "GL_EXT_stencil_wrap",                        o(EXT_stencil_wrap),                        GL             },
   { "GL_EXT_subtexture",                          o(EXT_subtexture),                          GL             },
   { "GL_EXT_texture3D",                           o(EXT_texture3D),                           GL             },
   { "GL_EXT_texture_array",                       o(EXT_texture_array),                       GL             },
   { "GL_EXT_texture_compression_dxt1",            o(EXT_texture_compression_s3tc),            GL | ES1 | ES2 },
   { "GL_EXT_texture_compression_rgtc",            o(ARB_texture_compression_rgtc),            GL             },
   { "GL_EXT_texture_compression_s3tc",            o(EXT_texture_compression_s3tc),            GL             },
   { "GL_EXT_texture_cube_map",                    o(ARB_texture_cube_map),                    GL             },
   { "GL_EXT_texture_edge_clamp",                  o(SGIS_texture_edge_clamp),                 GL             },
   { "GL_EXT_texture_env_add",                     o(EXT_texture_env_add),                     GL             },
   { "GL_EXT_texture_env_combine",                 o(EXT_texture_env_combine),                 GL             },
   { "GL_EXT_texture_env_dot3",                    o(EXT_texture_env_dot3),                    GL             },
   { "GL_EXT_texture_filter_anisotropic",          o(EXT_texture_filter_anisotropic),          GL | ES1 | ES2 },
   { "GL_EXT_texture_format_BGRA8888",             o(EXT_texture_format_BGRA8888),                  ES1 | ES2 },
   { "GL_EXT_texture_integer",                     o(EXT_texture_integer),                     GL             },
   { "GL_EXT_texture_lod_bias",                    o(EXT_texture_lod_bias),                    GL | ES1       },
   { "GL_EXT_texture_mirror_clamp",                o(EXT_texture_mirror_clamp),                GL             },
   { "GL_EXT_texture_object",                      o(EXT_texture_object),                      GL             },
   { "GL_EXT_texture",                             o(EXT_texture),                             GL             },
   { "GL_EXT_texture_rectangle",                   o(NV_texture_rectangle),                    GL             },
   { "GL_EXT_texture_shared_exponent",             o(EXT_texture_shared_exponent),             GL             },
   { "GL_EXT_texture_sRGB",                        o(EXT_texture_sRGB),                        GL             },
   { "GL_EXT_texture_swizzle",                     o(EXT_texture_swizzle),                     GL             },
   { "GL_EXT_texture_type_2_10_10_10_REV",         o(dummy_true),                                         ES2 },
   { "GL_EXT_timer_query",                         o(EXT_timer_query),                         GL             },
   { "GL_EXT_transform_feedback",                  o(EXT_transform_feedback),                  GL             },
   { "GL_EXT_vertex_array_bgra",                   o(EXT_vertex_array_bgra),                   GL             },
   { "GL_EXT_vertex_array",                        o(EXT_vertex_array),                        GL             },
   { "GL_EXT_vertex_array_set",                    o(EXT_vertex_array_set),                    GL             },
d220 8
a227 8
   { "GL_OES_blend_equation_separate",             o(EXT_blend_equation_separate),                  ES1       },
   { "GL_OES_blend_func_separate",                 o(EXT_blend_func_separate),                      ES1       },
   { "GL_OES_blend_subtract",                      o(EXT_blend_subtract),                           ES1       },
   { "GL_OES_byte_coordinates",                    o(dummy_true),                                   ES1       },
   { "GL_OES_compressed_paletted_texture",         o(dummy_false),                     DISABLE                },
   { "GL_OES_depth24",                             o(EXT_framebuffer_object),                       ES1 | ES2 },
   { "GL_OES_depth32",                             o(dummy_false),                     DISABLE                },
   { "GL_OES_depth_texture",                       o(ARB_depth_texture),                                  ES2 },
d229 1
a229 1
   { "GL_OES_draw_texture",                        o(OES_draw_texture),                             ES1 | ES2 },
d233 1
a233 1
   { "GL_OES_EGL_image",                           o(OES_EGL_image),                           GL | ES1 | ES2 },
d235 23
a257 24
   { "GL_OES_element_index_uint",                  o(EXT_vertex_array),                             ES1 | ES2 },
   { "GL_OES_fbo_render_mipmap",                   o(EXT_framebuffer_object),                       ES1 | ES2 },
   { "GL_OES_fixed_point",                         o(dummy_true),                                   ES1       },
   { "GL_OES_framebuffer_object",                  o(EXT_framebuffer_object),                       ES1       },
   { "GL_OES_mapbuffer",                           o(ARB_vertex_buffer_object),                     ES1 | ES2 },
   { "GL_OES_matrix_get",                          o(dummy_true),                                   ES1       },
   { "GL_OES_packed_depth_stencil",                o(EXT_packed_depth_stencil),                     ES1 | ES2 },
   { "GL_OES_point_size_array",                    o(dummy_true),                                   ES1       },
   { "GL_OES_point_sprite",                        o(ARB_point_sprite),                             ES1       },
   { "GL_OES_query_matrix",                        o(dummy_true),                                   ES1       },
   { "GL_OES_read_format",                         o(OES_read_format),                         GL | ES1       },
   { "GL_OES_rgb8_rgba8",                          o(EXT_framebuffer_object),                       ES1 | ES2 },
   { "GL_OES_single_precision",                    o(dummy_true),                                   ES1       },
   { "GL_OES_standard_derivatives",                o(OES_standard_derivatives),                           ES2 },
   { "GL_OES_stencil1",                            o(dummy_false),                     DISABLE                },
   { "GL_OES_stencil4",                            o(dummy_false),                     DISABLE                },
   { "GL_OES_stencil8",                            o(EXT_framebuffer_object),                       ES1 | ES2 },
   { "GL_OES_stencil_wrap",                        o(EXT_stencil_wrap),                             ES1       },
   /* GL_OES_texture_3D is disabled due to missing GLSL support. */
   { "GL_OES_texture_3D",                          o(EXT_texture3D),                   DISABLE                },
   { "GL_OES_texture_cube_map",                    o(ARB_texture_cube_map),                         ES1       },
   { "GL_OES_texture_env_crossbar",                o(ARB_texture_env_crossbar),                     ES1       },
   { "GL_OES_texture_mirrored_repeat",             o(ARB_texture_mirrored_repeat),                  ES1       },
   { "GL_OES_texture_npot",                        o(ARB_texture_non_power_of_two),                       ES2 },
d260 49
a308 43
   { "GL_3DFX_texture_compression_FXT1",           o(TDFX_texture_compression_FXT1),           GL             },
   { "GL_APPLE_client_storage",                    o(APPLE_client_storage),                    GL             },
   { "GL_APPLE_object_purgeable",                  o(APPLE_object_purgeable),                  GL             },
   { "GL_APPLE_packed_pixels",                     o(APPLE_packed_pixels),                     GL             },
   { "GL_APPLE_vertex_array_object",               o(APPLE_vertex_array_object),               GL             },
   { "GL_ATI_blend_equation_separate",             o(EXT_blend_equation_separate),             GL             },
   { "GL_ATI_envmap_bumpmap",                      o(ATI_envmap_bumpmap),                      GL             },
   { "GL_ATI_fragment_shader",                     o(ATI_fragment_shader),                     GL             },
   { "GL_ATI_separate_stencil",                    o(ATI_separate_stencil),                    GL             },
   { "GL_ATI_texture_env_combine3",                o(ATI_texture_env_combine3),                GL             },
   { "GL_ATI_texture_mirror_once",                 o(ATI_texture_mirror_once),                 GL             },
   { "GL_IBM_multimode_draw_arrays",               o(IBM_multimode_draw_arrays),               GL             },
   { "GL_IBM_rasterpos_clip",                      o(IBM_rasterpos_clip),                      GL             },
   { "GL_IBM_texture_mirrored_repeat",             o(ARB_texture_mirrored_repeat),             GL             },
   { "GL_INGR_blend_func_separate",                o(EXT_blend_func_separate),                 GL             },
   { "GL_MESA_pack_invert",                        o(MESA_pack_invert),                        GL             },
   { "GL_MESA_resize_buffers",                     o(MESA_resize_buffers),                     GL             },
   { "GL_MESA_texture_array",                      o(MESA_texture_array),                      GL             },
   { "GL_MESA_texture_signed_rgba",                o(MESA_texture_signed_rgba),                GL             },
   { "GL_MESA_window_pos",                         o(ARB_window_pos),                          GL             },
   { "GL_MESAX_texture_float",                     o(ARB_texture_float),                       GL             },
   { "GL_MESA_ycbcr_texture",                      o(MESA_ycbcr_texture),                      GL             },
   { "GL_NV_blend_square",                         o(NV_blend_square),                         GL             },
   { "GL_NV_conditional_render",                   o(NV_conditional_render),                   GL             },
   { "GL_NV_depth_clamp",                          o(ARB_depth_clamp),                         GL             },
   { "GL_NV_fragment_program",                     o(NV_fragment_program),                     GL             },
   { "GL_NV_fragment_program_option",              o(NV_fragment_program_option),              GL             },
   { "GL_NV_light_max_exponent",                   o(NV_light_max_exponent),                   GL             },
   { "GL_NV_packed_depth_stencil",                 o(EXT_packed_depth_stencil),                GL             },
   { "GL_NV_point_sprite",                         o(NV_point_sprite),                         GL             },
   { "GL_NV_primitive_restart",                    o(NV_primitive_restart),                    GL             },
   { "GL_NV_texgen_reflection",                    o(NV_texgen_reflection),                    GL             },
   { "GL_NV_texture_env_combine4",                 o(NV_texture_env_combine4),                 GL             },
   { "GL_NV_texture_rectangle",                    o(NV_texture_rectangle),                    GL             },
   { "GL_NV_vertex_program1_1",                    o(NV_vertex_program1_1),                    GL             },
   { "GL_NV_vertex_program",                       o(NV_vertex_program),                       GL             },
   { "GL_S3_s3tc",                                 o(S3_s3tc),                                 GL             },
   { "GL_SGIS_generate_mipmap",                    o(SGIS_generate_mipmap),                    GL             },
   { "GL_SGIS_texture_border_clamp",               o(ARB_texture_border_clamp),                GL             },
   { "GL_SGIS_texture_edge_clamp",                 o(SGIS_texture_edge_clamp),                 GL             },
   { "GL_SGIS_texture_lod",                        o(SGIS_texture_lod),                        GL             },
   { "GL_SGI_texture_color_table",                 o(SGI_texture_color_table),                 GL             },
   { "GL_SUN_multi_draw_arrays",                   o(EXT_multi_draw_arrays),                   GL             },
d310 1
a310 1
   { 0, 0, 0 },
d400 1
d423 1
d444 1
d466 1
d502 1
d506 1
d509 1
d512 1
a540 1
   ctx->Extensions.SGI_texture_color_table = GL_TRUE;
d751 8
a758 26
 * Append string 'b' onto string 'a'.  Free 'a' and return new string.
 */
static char *
append(const char *a, const char *b)
{
   const GLuint aLen = a ? strlen(a) : 0;
   const GLuint bLen = b ? strlen(b) : 0;
   char *s = calloc(1, aLen + bLen + 1);
   if (s) {
      if (a)
         memcpy(s, a, aLen);
      if (b)
         memcpy(s + aLen, b, bLen);
      s[aLen + bLen] = '\0';
   }
   if (a)
      free((void *) a);
   return s;
}


/**
 * Check the MESA_EXTENSION_OVERRIDE env var.
 * For extension names that are recognized, turn them on.  For extension
 * names that are recognized and prefixed with '-', turn them off.
 * Return a string of the unknown/leftover names.
d760 2
a761 1
 * Returnd string needs to be freed.
d766 11
a776 6
   const char *envExt = _mesa_getenv("MESA_EXTENSION_OVERRIDE");
   char *extraExt = NULL;
   char ext[1000];
   GLuint extLen = 0;
   GLuint i;
   GLboolean disableExt = GL_FALSE;
d778 2
a779 2
   if (!envExt)
      return NULL;
d781 17
a797 19
   for (i = 0; ; i++) {
      if (envExt[i] == '\0' || envExt[i] == ' ') {
         /* terminate/process 'ext' if extLen > 0 */
         if (extLen > 0) {
            assert(extLen < sizeof(ext));
            /* enable extension named by 'ext' */
            ext[extLen] = 0;
            if (!set_extension(ctx, ext, !disableExt)) {
               /* unknown extension name, append it to extraExt */
               if (extraExt) {
                  extraExt = append(extraExt, " ");
               }
               extraExt = append(extraExt, ext);
            }
            extLen = 0;
            disableExt = GL_FALSE;
         }
         if (envExt[i] == '\0')
            break;
d799 4
a802 6
      else if (envExt[i] == '-') {
         disableExt = GL_TRUE;
      }
      else {
         /* accumulate this non-space character */
         ext[extLen++] = envExt[i];
d806 6
a811 1
   return extraExt;
d840 28
d879 4
d887 12
d901 1
d903 3
a905 1
      if (base[i->offset] && (i->api_set & (1 << ctx->API))) {
d907 1
d919 13
a931 1
   /* Build the extension string.*/
d933 4
a936 3
      if (base[i->offset] && (i->api_set & (1 << ctx->API))) {
         strcat(exts, i->name);
         strcat(exts, " ");
d939 11
@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d27 6
a36 1
#include "simple_list.h"
d39 13
d53 2
a54 3
#define F(x) offsetof(struct gl_extensions, x)
#define ON GL_TRUE
#define OFF GL_FALSE
d56 3
d60 11
a70 1
/*
d73 142
a214 154
static const struct {
   GLboolean enabled;
   const char *name;
   int flag_offset;
} default_extensions[] = {
   { OFF, "GL_ARB_copy_buffer",                F(ARB_copy_buffer) },
   { OFF, "GL_ARB_depth_texture",              F(ARB_depth_texture) },
   { OFF, "GL_ARB_depth_clamp",                F(ARB_depth_clamp) },
   { ON,  "GL_ARB_draw_buffers",               F(ARB_draw_buffers) },
   { OFF, "GL_ARB_draw_elements_base_vertex",  F(ARB_draw_elements_base_vertex) },
   { OFF, "GL_ARB_fragment_coord_conventions", F(ARB_fragment_coord_conventions) },
   { OFF, "GL_ARB_fragment_program",           F(ARB_fragment_program) },
   { OFF, "GL_ARB_fragment_program_shadow",    F(ARB_fragment_program_shadow) },
   { OFF, "GL_ARB_fragment_shader",            F(ARB_fragment_shader) },
   { OFF, "GL_ARB_framebuffer_object",         F(ARB_framebuffer_object) },
   { OFF, "GL_ARB_half_float_pixel",           F(ARB_half_float_pixel) },
   { OFF, "GL_ARB_half_float_vertex",          F(ARB_half_float_vertex) },
   { OFF, "GL_ARB_imaging",                    F(ARB_imaging) },
   { OFF, "GL_ARB_map_buffer_range",           F(ARB_map_buffer_range) },
   { ON,  "GL_ARB_multisample",                F(ARB_multisample) },
   { OFF, "GL_ARB_multitexture",               F(ARB_multitexture) },
   { OFF, "GL_ARB_occlusion_query",            F(ARB_occlusion_query) },
   { OFF, "GL_ARB_pixel_buffer_object",        F(EXT_pixel_buffer_object) },
   { OFF, "GL_ARB_point_parameters",           F(EXT_point_parameters) },
   { OFF, "GL_ARB_point_sprite",               F(ARB_point_sprite) },
   { OFF, "GL_ARB_provoking_vertex",           F(EXT_provoking_vertex) },
   { OFF, "GL_ARB_seamless_cube_map",          F(ARB_seamless_cube_map) },
   { OFF, "GL_ARB_shader_objects",             F(ARB_shader_objects) },
   { OFF, "GL_ARB_shading_language_100",       F(ARB_shading_language_100) },
   { OFF, "GL_ARB_shading_language_120",       F(ARB_shading_language_120) },
   { OFF, "GL_ARB_shadow",                     F(ARB_shadow) },
   { OFF, "GL_ARB_shadow_ambient",             F(ARB_shadow_ambient) },
   { OFF, "GL_ARB_sync",                       F(ARB_sync) },
   { OFF, "GL_ARB_texture_border_clamp",       F(ARB_texture_border_clamp) },
   { ON,  "GL_ARB_texture_compression",        F(ARB_texture_compression) },
   { OFF, "GL_ARB_texture_cube_map",           F(ARB_texture_cube_map) },
   { OFF, "GL_ARB_texture_env_add",            F(EXT_texture_env_add) },
   { OFF, "GL_ARB_texture_env_combine",        F(ARB_texture_env_combine) },
   { OFF, "GL_ARB_texture_env_crossbar",       F(ARB_texture_env_crossbar) },
   { OFF, "GL_ARB_texture_env_dot3",           F(ARB_texture_env_dot3) },
   { OFF, "GL_MESAX_texture_float",            F(ARB_texture_float) },
   { OFF, "GL_ARB_texture_mirrored_repeat",    F(ARB_texture_mirrored_repeat)},
   { OFF, "GL_ARB_texture_non_power_of_two",   F(ARB_texture_non_power_of_two)},
   { OFF, "GL_ARB_texture_rectangle",          F(NV_texture_rectangle) },
   { ON,  "GL_ARB_transpose_matrix",           F(ARB_transpose_matrix) },
   { OFF, "GL_ARB_vertex_array_bgra",          F(EXT_vertex_array_bgra) },
   { OFF, "GL_ARB_vertex_array_object",        F(ARB_vertex_array_object) },
   { ON,  "GL_ARB_vertex_buffer_object",       F(ARB_vertex_buffer_object) },
   { OFF, "GL_ARB_vertex_program",             F(ARB_vertex_program) },
   { OFF, "GL_ARB_vertex_shader",              F(ARB_vertex_shader) },
   { ON,  "GL_ARB_window_pos",                 F(ARB_window_pos) },
   { ON,  "GL_EXT_abgr",                       F(EXT_abgr) },
   { ON,  "GL_EXT_bgra",                       F(EXT_bgra) },
   { OFF, "GL_EXT_blend_color",                F(EXT_blend_color) },
   { OFF, "GL_EXT_blend_equation_separate",    F(EXT_blend_equation_separate) },
   { OFF, "GL_EXT_blend_func_separate",        F(EXT_blend_func_separate) },
   { OFF, "GL_EXT_blend_logic_op",             F(EXT_blend_logic_op) },
   { OFF, "GL_EXT_blend_minmax",               F(EXT_blend_minmax) },
   { OFF, "GL_EXT_blend_subtract",             F(EXT_blend_subtract) },
   { OFF, "GL_EXT_clip_volume_hint",           F(EXT_clip_volume_hint) },
   { OFF, "GL_EXT_cull_vertex",                F(EXT_cull_vertex) },
   { ON,  "GL_EXT_compiled_vertex_array",      F(EXT_compiled_vertex_array) },
   { OFF, "GL_EXT_convolution",                F(EXT_convolution) },
   { ON,  "GL_EXT_copy_texture",               F(EXT_copy_texture) },
   { OFF, "GL_EXT_depth_bounds_test",          F(EXT_depth_bounds_test) },
   { OFF, "GL_EXT_draw_buffers2",              F(EXT_draw_buffers2) },
   { ON,  "GL_EXT_draw_range_elements",        F(EXT_draw_range_elements) },
   { OFF, "GL_EXT_framebuffer_blit",           F(EXT_framebuffer_blit) },
   { OFF, "GL_EXT_framebuffer_multisample",    F(EXT_framebuffer_multisample) },
   { OFF, "GL_EXT_framebuffer_object",         F(EXT_framebuffer_object) },
   { OFF, "GL_EXT_fog_coord",                  F(EXT_fog_coord) },
   { OFF, "GL_EXT_gpu_program_parameters",     F(EXT_gpu_program_parameters) },
   { OFF, "GL_EXT_histogram",                  F(EXT_histogram) },
   { ON,  "GL_EXT_multi_draw_arrays",          F(EXT_multi_draw_arrays) },
   { OFF, "GL_EXT_packed_depth_stencil",       F(EXT_packed_depth_stencil) },
   { ON,  "GL_EXT_packed_pixels",              F(EXT_packed_pixels) },
   { OFF, "GL_EXT_paletted_texture",           F(EXT_paletted_texture) },
   { OFF, "GL_EXT_pixel_buffer_object",        F(EXT_pixel_buffer_object) },
   { OFF, "GL_EXT_point_parameters",           F(EXT_point_parameters) },
   { ON,  "GL_EXT_polygon_offset",             F(EXT_polygon_offset) },
   { OFF, "GL_EXT_provoking_vertex",           F(EXT_provoking_vertex) },
   { ON,  "GL_EXT_rescale_normal",             F(EXT_rescale_normal) },
   { OFF, "GL_EXT_secondary_color",            F(EXT_secondary_color) },
   { ON,  "GL_EXT_separate_specular_color",    F(EXT_separate_specular_color) },
   { OFF, "GL_EXT_shadow_funcs",               F(EXT_shadow_funcs) },
   { OFF, "GL_EXT_shared_texture_palette",     F(EXT_shared_texture_palette) },
   { OFF, "GL_EXT_stencil_two_side",           F(EXT_stencil_two_side) },
   { OFF, "GL_EXT_stencil_wrap",               F(EXT_stencil_wrap) },
   { ON,  "GL_EXT_subtexture",                 F(EXT_subtexture) },
   { ON,  "GL_EXT_texture",                    F(EXT_texture) },
   { ON,  "GL_EXT_texture3D",                  F(EXT_texture3D) },
   { OFF, "GL_EXT_texture_array",              F(EXT_texture_array) },
   { OFF, "GL_EXT_texture_compression_s3tc",   F(EXT_texture_compression_s3tc) },
   { OFF, "GL_EXT_texture_cube_map",           F(ARB_texture_cube_map) },
   { ON,  "GL_EXT_texture_edge_clamp",         F(SGIS_texture_edge_clamp) },
   { OFF, "GL_EXT_texture_env_add",            F(EXT_texture_env_add) },
   { OFF, "GL_EXT_texture_env_combine",        F(EXT_texture_env_combine) },
   { OFF, "GL_EXT_texture_env_dot3",           F(EXT_texture_env_dot3) },
   { OFF, "GL_EXT_texture_filter_anisotropic", F(EXT_texture_filter_anisotropic) },
   { OFF, "GL_EXT_texture_lod_bias",           F(EXT_texture_lod_bias) },
   { OFF, "GL_EXT_texture_mirror_clamp",       F(EXT_texture_mirror_clamp) },
   { ON,  "GL_EXT_texture_object",             F(EXT_texture_object) },
   { OFF, "GL_EXT_texture_rectangle",          F(NV_texture_rectangle) },
   { OFF, "GL_EXT_texture_sRGB",               F(EXT_texture_sRGB) },
   { OFF, "GL_EXT_texture_swizzle",            F(EXT_texture_swizzle) },
   { OFF, "GL_EXT_timer_query",                F(EXT_timer_query) },
   { ON,  "GL_EXT_vertex_array",               F(EXT_vertex_array) },
   { OFF, "GL_EXT_vertex_array_bgra",          F(EXT_vertex_array_bgra) },
   { OFF, "GL_EXT_vertex_array_set",           F(EXT_vertex_array_set) },
   { OFF, "GL_3DFX_texture_compression_FXT1",  F(TDFX_texture_compression_FXT1) },
   { OFF, "GL_APPLE_client_storage",           F(APPLE_client_storage) },
   { ON,  "GL_APPLE_packed_pixels",            F(APPLE_packed_pixels) },
   { OFF, "GL_APPLE_vertex_array_object",      F(APPLE_vertex_array_object) },
   { OFF, "GL_APPLE_object_purgeable",         F(APPLE_object_purgeable) },
   { OFF, "GL_ATI_blend_equation_separate",    F(EXT_blend_equation_separate) },
   { OFF, "GL_ATI_envmap_bumpmap",             F(ATI_envmap_bumpmap) },
   { OFF, "GL_ATI_texture_env_combine3",       F(ATI_texture_env_combine3)},
   { OFF, "GL_ATI_texture_mirror_once",        F(ATI_texture_mirror_once)},
   { OFF, "GL_ATI_fragment_shader",            F(ATI_fragment_shader)},
   { OFF, "GL_ATI_separate_stencil",           F(ATI_separate_stencil)},
   { ON,  "GL_IBM_multimode_draw_arrays",      F(IBM_multimode_draw_arrays) },
   { ON,  "GL_IBM_rasterpos_clip",             F(IBM_rasterpos_clip) },
   { OFF, "GL_IBM_texture_mirrored_repeat",    F(ARB_texture_mirrored_repeat)},
   { OFF, "GL_INGR_blend_func_separate",       F(EXT_blend_func_separate) },
   { OFF, "GL_MESA_pack_invert",               F(MESA_pack_invert) },
   { OFF, "GL_MESA_packed_depth_stencil",      F(MESA_packed_depth_stencil) },
   { OFF, "GL_MESA_resize_buffers",            F(MESA_resize_buffers) },
   { OFF, "GL_MESA_texture_array",             F(MESA_texture_array) },
   { OFF, "GL_MESA_texture_signed_rgba",       F(MESA_texture_signed_rgba) },
   { OFF, "GL_MESA_ycbcr_texture",             F(MESA_ycbcr_texture) },
   { ON,  "GL_MESA_window_pos",                F(ARB_window_pos) },
   { OFF, "GL_NV_blend_square",                F(NV_blend_square) },
   { OFF, "GL_NV_conditional_render",          F(NV_conditional_render) },
   { OFF, "GL_NV_depth_clamp",                 F(ARB_depth_clamp) },
   { OFF, "GL_NV_fragment_program",            F(NV_fragment_program) },
   { OFF, "GL_NV_fragment_program_option",     F(NV_fragment_program_option) },
   { ON,  "GL_NV_light_max_exponent",          F(NV_light_max_exponent) },
   { OFF, "GL_NV_packed_depth_stencil",        F(EXT_packed_depth_stencil) },
   { OFF, "GL_NV_point_sprite",                F(NV_point_sprite) },
   { OFF, "GL_NV_texture_env_combine4",        F(NV_texture_env_combine4) },
   { OFF, "GL_NV_texture_rectangle",           F(NV_texture_rectangle) },
   { ON,  "GL_NV_texgen_reflection",           F(NV_texgen_reflection) },
   { OFF, "GL_NV_vertex_program",              F(NV_vertex_program) },
   { OFF, "GL_NV_vertex_program1_1",           F(NV_vertex_program1_1) },
   { ON,  "GL_OES_read_format",                F(OES_read_format) },
   { OFF, "GL_SGI_color_matrix",               F(SGI_color_matrix) },
   { OFF, "GL_SGI_color_table",                F(SGI_color_table) },
   { OFF, "GL_SGI_texture_color_table",        F(SGI_texture_color_table) },
   { OFF, "GL_SGIS_generate_mipmap",           F(SGIS_generate_mipmap) },
   { OFF, "GL_SGIS_texture_border_clamp",      F(ARB_texture_border_clamp) },
   { ON,  "GL_SGIS_texture_edge_clamp",        F(SGIS_texture_edge_clamp) },
   { ON,  "GL_SGIS_texture_lod",               F(SGIS_texture_lod) },
   { ON,  "GL_SUN_multi_draw_arrays",          F(EXT_multi_draw_arrays) },
   { OFF, "GL_S3_s3tc",                        F(S3_s3tc) },
d216 77
a292 2
   { OFF, "GL_OES_draw_texture",               F(OES_draw_texture) },
#endif /* FEATURE_OES_draw_texture */
d296 73
d375 1
a375 1
_mesa_enable_sw_extensions(GLcontext *ctx)
d377 1
a377 1
   ctx->Extensions.ARB_copy_buffer = GL_TRUE;
d382 1
d394 4
a399 1
   ctx->Extensions.ARB_imaging = GL_TRUE;
d408 1
a412 3
#if FEATURE_ARB_shading_language_120
   ctx->Extensions.ARB_shading_language_120 = GL_TRUE;
#endif
d423 1
a453 1
   ctx->Extensions.EXT_convolution = GL_TRUE;
a465 1
   ctx->Extensions.EXT_histogram = GL_TRUE;
d489 3
a514 2
   ctx->Extensions.SGI_color_matrix = GL_TRUE;
   ctx->Extensions.SGI_color_table = GL_TRUE;
d516 1
a516 1
   ctx->Extensions.SGIS_generate_mipmap = GL_TRUE;
d534 1
a534 1
 * Enable GL_ARB_imaging and all the EXT extensions that are subsets of it.
d537 1
a537 1
_mesa_enable_imaging_extensions(GLcontext *ctx)
a538 1
   ctx->Extensions.ARB_imaging = GL_TRUE;
a542 4
   ctx->Extensions.EXT_convolution = GL_TRUE;
   ctx->Extensions.EXT_histogram = GL_TRUE;
   ctx->Extensions.SGI_color_matrix = GL_TRUE;
   ctx->Extensions.SGI_color_table = GL_TRUE;
d552 1
a552 1
_mesa_enable_1_3_extensions(GLcontext *ctx)
d572 1
a572 1
_mesa_enable_1_4_extensions(GLcontext *ctx)
d589 1
a589 1
   ctx->Extensions.SGIS_generate_mipmap = GL_TRUE;
d598 1
a598 1
_mesa_enable_1_5_extensions(GLcontext *ctx)
d611 1
a611 1
_mesa_enable_2_0_extensions(GLcontext *ctx)
d638 1
a638 1
_mesa_enable_2_1_extensions(GLcontext *ctx)
a645 3
#ifdef FEATURE_ARB_shading_language_120
   ctx->Extensions.ARB_shading_language_120 = GL_TRUE;
#endif
a648 1

d654 1
a654 1
set_extension( GLcontext *ctx, const char *name, GLboolean state )
d656 1
a656 2
   GLboolean *base = (GLboolean *) &ctx->Extensions;
   GLuint i;
d664 13
a676 8
   for (i = 0 ; i < Elements(default_extensions) ; i++) {
      if (strcmp(default_extensions[i].name, name) == 0) {
         if (default_extensions[i].flag_offset) {
            GLboolean *enabled = base + default_extensions[i].flag_offset;
            *enabled = state;
         }
         return GL_TRUE;
      }
a677 1
   return GL_FALSE;
d686 1
a686 1
_mesa_enable_extension( GLcontext *ctx, const char *name )
d698 1
a698 1
_mesa_disable_extension( GLcontext *ctx, const char *name )
a705 17
 * Check if the i-th extension is enabled.
 */
static GLboolean
extension_enabled(GLcontext *ctx, GLuint index)
{
   const GLboolean *base = (const GLboolean *) &ctx->Extensions;
   if (!default_extensions[index].flag_offset ||
       *(base + default_extensions[index].flag_offset)) {
      return GL_TRUE;
   }
   else {
      return GL_FALSE;
   }
}


/**
d709 1
a709 1
_mesa_extension_is_enabled( GLcontext *ctx, const char *name )
d711 5
a715 1
   GLuint i;
d717 5
a721 6
   for (i = 0 ; i < Elements(default_extensions) ; i++) {
      if (strcmp(default_extensions[i].name, name) == 0) {
         return extension_enabled(ctx, i);
      }
   }
   return GL_FALSE;
d752 2
d755 2
a756 2
static const char *
get_extension_override( GLcontext *ctx )
d802 4
a805 3
 * Run through the default_extensions array above and set the
 * ctx->Extensions.ARB/EXT_* flags accordingly.
 * To be called during context initialization.
d808 1
a808 1
_mesa_init_extensions( GLcontext *ctx )
d811 12
a822 8
   GLuint i;

   for (i = 0 ; i < Elements(default_extensions) ; i++) {
      if (default_extensions[i].enabled &&
          default_extensions[i].flag_offset) {
         *(base + default_extensions[i].flag_offset) = GL_TRUE;
      }
   }
d830 2
a831 2
GLubyte *
_mesa_make_extension_string( GLcontext *ctx )
d833 8
a840 4
   const char *extraExt = get_extension_override(ctx);
   GLuint extStrLen = 0;
   char *s;
   GLuint i;
d842 4
a845 4
   /* first, compute length of the extension string */
   for (i = 0 ; i < Elements(default_extensions) ; i++) {
      if (extension_enabled(ctx, i)) {
         extStrLen += (GLuint) strlen(default_extensions[i].name) + 1;
d848 2
d851 3
a853 6
   if (extraExt)
      extStrLen += strlen(extraExt) + 1; /* +1 for space */

   /* allocate the extension string */
   s = (char *) malloc(extStrLen);
   if (!s)
d855 1
d857 5
a861 9
   /* second, build the extension string */
   extStrLen = 0;
   for (i = 0 ; i < Elements(default_extensions) ; i++) {
      if (extension_enabled(ctx, i)) {
         GLuint len = (GLuint) strlen(default_extensions[i].name);
         memcpy(s + extStrLen, default_extensions[i].name, len);
         extStrLen += len;
         s[extStrLen] = ' ';
         extStrLen++;
d864 3
a866 7
   ASSERT(extStrLen > 0);

   s[extStrLen - 1] = 0; /* -1 to overwrite trailing the ' ' */

   if (extraExt) {
      s = append(s, " ");
      s = append(s, extraExt);
d869 1
a869 1
   return (GLubyte *) s;
a871 1

d876 1
a876 1
_mesa_get_extension_count(GLcontext *ctx)
d878 2
a879 1
   GLuint i;
d882 7
a888 5
   if (!ctx->Extensions.Count) {
      for (i = 0; i < Elements(default_extensions); i++) {
         if (extension_enabled(ctx, i)) {
            ctx->Extensions.Count++;
         }
a890 5

   if (0)
      _mesa_debug(ctx, "%u of %d extensions enabled\n", ctx->Extensions.Count,
                  Elements(default_extensions));

a893 1

d898 1
a898 1
_mesa_get_enabled_extension(GLcontext *ctx, GLuint index)
d900 6
a905 1
   GLuint i;
d907 7
a913 5
   for (i = 0; i < Elements(default_extensions); i++) {
      if (extension_enabled(ctx, i)) {
         if (index == 0)
            return (const GLubyte *) default_extensions[i].name;
         index--;
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d3 1
a3 1
 * Version:  7.3
d6 1
d35 1
a35 1
#define F(x) (int)(uintptr_t)&(((struct gl_extensions *)0)->x)
d48 1
d50 4
a53 1
   { OFF, "GL_ARB_draw_buffers",               F(ARB_draw_buffers) },
d57 1
d59 1
d61 2
a62 1
   { OFF, "GL_ARB_multisample",                F(ARB_multisample) },
d68 2
d74 2
a75 1
   { OFF, "GL_ARB_shadow_ambient",             F(SGIX_shadow_ambient) },
d77 1
a77 1
   { OFF, "GL_ARB_texture_compression",        F(ARB_texture_compression) },
d88 3
a90 1
   { OFF, "GL_ARB_vertex_buffer_object",       F(ARB_vertex_buffer_object) },
d102 1
a102 1
   { ON,  "GL_EXT_clip_volume_hint",           F(EXT_clip_volume_hint) },
d108 1
d110 2
a112 1
   { OFF, "GL_EXT_framebuffer_blit",           F(EXT_framebuffer_blit) },
d116 1
a116 1
   { OFF, "GL_EXT_multi_draw_arrays",          F(EXT_multi_draw_arrays) },
d123 1
d134 1
d136 1
d147 1
d150 1
d156 1
d158 1
d163 1
a163 1
   { OFF, "GL_IBM_multimode_draw_arrays",      F(IBM_multimode_draw_arrays) },
a168 1
   { OFF, "GL_MESA_program_debug",             F(MESA_program_debug) },
d171 1
d175 2
d178 1
d180 1
d182 1
d195 1
a195 4
   { OFF, "GL_SGIX_depth_texture",             F(ARB_depth_texture) },
   { OFF, "GL_SGIX_shadow",                    F(SGIX_shadow) },
   { OFF, "GL_SGIX_shadow_ambient",            F(SGIX_shadow_ambient) },
   { OFF, "GL_SUN_multi_draw_arrays",          F(EXT_multi_draw_arrays) },
d197 3
d211 2
d214 3
a216 1
   ctx->Extensions.ARB_draw_buffers = GL_TRUE;
d224 3
d228 1
d230 1
d232 1
a232 1
#if FEATURE_ARB_occlusion_query
d246 1
d255 1
d263 4
a266 1
   ctx->Extensions.ARB_vertex_buffer_object = GL_TRUE;
d269 4
d287 1
d295 3
d299 1
a299 1
   ctx->Extensions.EXT_multi_draw_arrays = GL_TRUE;
d306 1
d312 1
d321 3
a323 1
   ctx->Extensions.IBM_multimode_draw_arrays = GL_TRUE;
a324 3
#if FEATURE_MESA_program_debug
   ctx->Extensions.MESA_program_debug = GL_TRUE;
#endif
d329 1
d332 1
d342 3
a349 2
   ctx->Extensions.SGIX_shadow = GL_TRUE;
   ctx->Extensions.SGIX_shadow_ambient = GL_TRUE;
d391 1
a391 1
   ctx->Extensions.ARB_multisample = GL_TRUE;
d394 1
a394 1
   ctx->Extensions.ARB_texture_compression = GL_TRUE;
d421 1
a421 1
   ctx->Extensions.EXT_multi_draw_arrays = GL_TRUE;
d438 1
a438 1
   ctx->Extensions.ARB_vertex_buffer_object = GL_TRUE;
d450 1
a450 1
   ctx->Extensions.ARB_draw_buffers = GL_TRUE;
d455 1
d492 1
d494 1
a494 1
static void
d503 1
a503 1
      return;
d507 1
a507 1
      if (_mesa_strcmp(default_extensions[i].name, name) == 0) {
d512 1
a512 1
         return;
d515 1
a515 1
   _mesa_problem(ctx, "Trying to enable unknown extension: %s", name);
d526 2
a527 1
   set_extension(ctx, name, GL_TRUE);
d538 19
a556 1
   set_extension(ctx, name, GL_FALSE);
a565 1
   const GLboolean *base = (const GLboolean *) &ctx->Extensions;
d569 2
a570 4
      if (_mesa_strcmp(default_extensions[i].name, name) == 0) {
         if (!default_extensions[i].flag_offset)
            return GL_TRUE;
         return *(base + default_extensions[i].flag_offset);
d578 74
d678 1
a678 1
   const GLboolean *base = (const GLboolean *) &ctx->Extensions;
d680 1
a680 1
   GLubyte *s;
d685 2
a686 3
      if (!default_extensions[i].flag_offset ||
          *(base + default_extensions[i].flag_offset)) {
         extStrLen += (GLuint)_mesa_strlen(default_extensions[i].name) + 1;
d689 8
a696 1
   s = (GLubyte *) _mesa_malloc(extStrLen);
d701 3
a703 4
      if (!default_extensions[i].flag_offset ||
          *(base + default_extensions[i].flag_offset)) {
         GLuint len = (GLuint)_mesa_strlen(default_extensions[i].name);
         _mesa_memcpy(s + extStrLen, default_extensions[i].name, len);
d705 1
a705 1
         s[extStrLen] = (GLubyte) ' ';
d711 18
a728 1
   s[extStrLen - 1] = 0;
d730 34
a763 1
   return s;
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d3 1
a3 1
 * Version:  7.1
d168 1
a168 1
   { OFF, "GL_SGIX_depth_texture",             F(SGIX_depth_texture) },
d207 1
a207 1
   ctx->Extensions.ARB_shading_language_120 = GL_FALSE; /* not quite done */
d261 1
a261 1
   ctx->Extensions.EXT_stencil_two_side = GL_FALSE; /* obsolete */
a294 1
   ctx->Extensions.SGIX_depth_texture = GL_TRUE;
d300 9
d409 1
a409 1
   ctx->Extensions.EXT_stencil_two_side = GL_FALSE; /* obsolete */
d430 1
a430 1
   ctx->Extensions.ARB_shading_language_120 = GL_FALSE; /* not quite done */
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * Version:  6.5.1
d5 1
a5 1
 * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
d50 1
d62 1
d140 1
d149 1
d188 1
d206 3
d233 1
d261 1
a261 1
   ctx->Extensions.EXT_stencil_two_side = GL_TRUE;
d276 1
d312 1
a356 1
   ctx->Extensions.EXT_blend_logic_op = GL_TRUE;
d401 1
a401 1
   ctx->Extensions.EXT_stencil_two_side = GL_FALSE; /* yes, turn it off */
d421 3
a423 1
   /* plus: shading language extensions, non-square uniform matrices */
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@a60 1
   { OFF, "GL_ARB_shading_language_120",       F(ARB_shading_language_120) },
d252 1
a252 1
   ctx->Extensions.EXT_stencil_two_side = GL_FALSE; /* obsolete */
d391 1
a391 1
   ctx->Extensions.EXT_stencil_two_side = GL_FALSE; /* obsolete */
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@a138 1
   { OFF, "GL_ATI_separate_stencil",           F(ATI_separate_stencil)},
a201 3
#if FEATURE_ARB_shading_language_120
   ctx->Extensions.ARB_shading_language_120 = GL_TRUE;
#endif
a225 1
   ctx->Extensions.ATI_separate_stencil = GL_TRUE;
d412 1
a412 3
#ifdef FEATURE_ARB_shading_language_120
   ctx->Extensions.ARB_shading_language_120 = GL_TRUE;
#endif
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d3 1
a3 1
 * Version:  7.6
d5 1
a5 2
 * Copyright (C) 1999-2008  Brian Paul   All Rights Reserved.
 * Copyright (C) 2009  VMware, Inc.  All Rights Reserved.
a25 6
/**
 * \file
 * \brief Extension handling
 */


d30 1
a32 16
enum {
   DISABLE = 0,
   GL  = 1 << API_OPENGL,
   ES1 = 1 << API_OPENGLES,
   ES2 = 1 << API_OPENGLES2,
};

/**
 * \brief An element of the \c extension_table.
 */
struct extension {
   /** Name of extension, such as "GL_ARB_depth_clamp". */
   const char *name;

   /** Offset (in bytes) of the corresponding member in struct gl_extensions. */
   size_t offset;
d34 3
a36 10
   /** Set of API's in which the extension exists, as a bitset. */
   uint8_t api_set;
};


/**
 * Given a member \c x of struct gl_extensions, return offset of
 * \c x in bytes.
 */
#define o(x) offsetof(struct gl_extensions, x)
d39 1
a39 3
/**
 * \brief Table of supported OpenGL extensions for all API's.
 *
d42 129
a170 220
static const struct extension extension_table[] = {
   /* ARB Extensions */
   { "GL_ARB_ES2_compatibility",                   o(ARB_ES2_compatibility),                   GL             },
   { "GL_ARB_blend_func_extended",                 o(ARB_blend_func_extended),                 GL             },
   { "GL_ARB_copy_buffer",                         o(ARB_copy_buffer),                         GL             },
   { "GL_ARB_depth_buffer_float",                  o(ARB_depth_buffer_float),                  GL             },
   { "GL_ARB_depth_clamp",                         o(ARB_depth_clamp),                         GL             },
   { "GL_ARB_depth_texture",                       o(ARB_depth_texture),                       GL             },
   { "GL_ARB_draw_buffers",                        o(ARB_draw_buffers),                        GL             },
   { "GL_ARB_draw_elements_base_vertex",           o(ARB_draw_elements_base_vertex),           GL             },
   { "GL_ARB_draw_instanced",                      o(ARB_draw_instanced),                      GL             },
   { "GL_ARB_explicit_attrib_location",            o(ARB_explicit_attrib_location),            GL             },
   { "GL_ARB_fragment_coord_conventions",          o(ARB_fragment_coord_conventions),          GL             },
   { "GL_ARB_fragment_program",                    o(ARB_fragment_program),                    GL             },
   { "GL_ARB_fragment_program_shadow",             o(ARB_fragment_program_shadow),             GL             },
   { "GL_ARB_fragment_shader",                     o(ARB_fragment_shader),                     GL             },
   { "GL_ARB_framebuffer_object",                  o(ARB_framebuffer_object),                  GL             },
   { "GL_ARB_half_float_pixel",                    o(ARB_half_float_pixel),                    GL             },
   { "GL_ARB_half_float_vertex",                   o(ARB_half_float_vertex),                   GL             },
   { "GL_ARB_instanced_arrays",                    o(ARB_instanced_arrays),                    GL             },
   { "GL_ARB_map_buffer_range",                    o(ARB_map_buffer_range),                    GL             },
   { "GL_ARB_multisample",                         o(ARB_multisample),                         GL             },
   { "GL_ARB_multitexture",                        o(ARB_multitexture),                        GL             },
   { "GL_ARB_occlusion_query2",                    o(ARB_occlusion_query2),                    GL             },
   { "GL_ARB_occlusion_query",                     o(ARB_occlusion_query),                     GL             },
   { "GL_ARB_pixel_buffer_object",                 o(EXT_pixel_buffer_object),                 GL             },
   { "GL_ARB_point_parameters",                    o(EXT_point_parameters),                    GL             },
   { "GL_ARB_point_sprite",                        o(ARB_point_sprite),                        GL             },
   { "GL_ARB_provoking_vertex",                    o(EXT_provoking_vertex),                    GL             },
   { "GL_ARB_sampler_objects",                     o(ARB_sampler_objects),                     GL             },
   { "GL_ARB_seamless_cube_map",                   o(ARB_seamless_cube_map),                   GL             },
   { "GL_ARB_shader_objects",                      o(ARB_shader_objects),                      GL             },
   { "GL_ARB_shader_stencil_export",               o(ARB_shader_stencil_export),               GL             },
   { "GL_ARB_shading_language_100",                o(ARB_shading_language_100),                GL             },
   { "GL_ARB_shadow_ambient",                      o(ARB_shadow_ambient),                      GL             },
   { "GL_ARB_shadow",                              o(ARB_shadow),                              GL             },
   { "GL_ARB_sync",                                o(ARB_sync),                                GL             },
   { "GL_ARB_texture_border_clamp",                o(ARB_texture_border_clamp),                GL             },
   { "GL_ARB_texture_buffer_object",               o(ARB_texture_buffer_object),               GL             },
   { "GL_ARB_texture_compression",                 o(ARB_texture_compression),                 GL             },
   { "GL_ARB_texture_compression_rgtc",            o(ARB_texture_compression_rgtc),            GL             },
   { "GL_ARB_texture_cube_map",                    o(ARB_texture_cube_map),                    GL             },
   { "GL_ARB_texture_env_add",                     o(EXT_texture_env_add),                     GL             },
   { "GL_ARB_texture_env_combine",                 o(ARB_texture_env_combine),                 GL             },
   { "GL_ARB_texture_env_crossbar",                o(ARB_texture_env_crossbar),                GL             },
   { "GL_ARB_texture_env_dot3",                    o(ARB_texture_env_dot3),                    GL             },
   { "GL_ARB_texture_mirrored_repeat",             o(ARB_texture_mirrored_repeat),             GL             },
   { "GL_ARB_texture_multisample",                 o(ARB_texture_multisample),                 GL             },
   { "GL_ARB_texture_non_power_of_two",            o(ARB_texture_non_power_of_two),            GL             },
   { "GL_ARB_texture_rectangle",                   o(NV_texture_rectangle),                    GL             },
   { "GL_ARB_texture_rgb10_a2ui",                  o(ARB_texture_rgb10_a2ui),                  GL             },
   { "GL_ARB_texture_rg",                          o(ARB_texture_rg),                          GL             },
   { "GL_ARB_texture_swizzle",                     o(EXT_texture_swizzle),                     GL             },
   { "GL_ARB_transform_feedback2",                 o(ARB_transform_feedback2),                 GL             },
   { "GL_ARB_transpose_matrix",                    o(ARB_transpose_matrix),                    GL             },
   { "GL_ARB_uniform_buffer_object",               o(ARB_uniform_buffer_object),               GL             },
   { "GL_ARB_vertex_array_bgra",                   o(EXT_vertex_array_bgra),                   GL             },
   { "GL_ARB_vertex_array_object",                 o(ARB_vertex_array_object),                 GL             },
   { "GL_ARB_vertex_buffer_object",                o(ARB_vertex_buffer_object),                GL             },
   { "GL_ARB_vertex_program",                      o(ARB_vertex_program),                      GL             },
   { "GL_ARB_vertex_shader",                       o(ARB_vertex_shader),                       GL             },
   { "GL_ARB_vertex_type_2_10_10_10_rev",          o(ARB_vertex_type_2_10_10_10_rev),          GL             },
   { "GL_ARB_window_pos",                          o(ARB_window_pos),                          GL             },

   /* EXT extensions */
   { "GL_EXT_abgr",                                o(EXT_abgr),                                GL             },
   { "GL_EXT_bgra",                                o(EXT_bgra),                                GL             },
   { "GL_EXT_blend_color",                         o(EXT_blend_color),                         GL             },
   { "GL_EXT_blend_equation_separate",             o(EXT_blend_equation_separate),             GL             },
   { "GL_EXT_blend_func_separate",                 o(EXT_blend_func_separate),                 GL             },
   { "GL_EXT_blend_logic_op",                      o(EXT_blend_logic_op),                      GL             },
   { "GL_EXT_blend_minmax",                        o(EXT_blend_minmax),                        GL | ES1 | ES2 },
   { "GL_EXT_blend_subtract",                      o(EXT_blend_subtract),                      GL             },
   { "GL_EXT_clip_volume_hint",                    o(EXT_clip_volume_hint),                    GL             },
   { "GL_EXT_compiled_vertex_array",               o(EXT_compiled_vertex_array),               GL             },
   { "GL_EXT_copy_texture",                        o(EXT_copy_texture),                        GL             },
   { "GL_EXT_depth_bounds_test",                   o(EXT_depth_bounds_test),                   GL             },
   { "GL_EXT_draw_buffers2",                       o(EXT_draw_buffers2),                       GL             },
   { "GL_EXT_draw_instanced",                      o(ARB_draw_instanced),                      GL             },
   { "GL_EXT_draw_range_elements",                 o(EXT_draw_range_elements),                 GL             },
   { "GL_EXT_fog_coord",                           o(EXT_fog_coord),                           GL             },
   { "GL_EXT_framebuffer_blit",                    o(EXT_framebuffer_blit),                    GL             },
   { "GL_EXT_framebuffer_multisample",             o(EXT_framebuffer_multisample),             GL             },
   { "GL_EXT_framebuffer_object",                  o(EXT_framebuffer_object),                  GL             },
   { "GL_EXT_framebuffer_sRGB",                    o(EXT_framebuffer_sRGB),                    GL             },
   { "GL_EXT_gpu_program_parameters",              o(EXT_gpu_program_parameters),              GL             },
   { "GL_EXT_gpu_shader4",                         o(EXT_gpu_shader4),                         GL             },
   { "GL_EXT_multi_draw_arrays",                   o(EXT_multi_draw_arrays),                   GL | ES1 | ES2 },
   { "GL_EXT_packed_depth_stencil",                o(EXT_packed_depth_stencil),                GL             },
   { "GL_EXT_packed_float",                        o(EXT_packed_float),                        GL             },
   { "GL_EXT_packed_pixels",                       o(EXT_packed_pixels),                       GL             },
   { "GL_EXT_paletted_texture",                    o(EXT_paletted_texture),                    GL             },
   { "GL_EXT_pixel_buffer_object",                 o(EXT_pixel_buffer_object),                 GL             },
   { "GL_EXT_point_parameters",                    o(EXT_point_parameters),                    GL             },
   { "GL_EXT_polygon_offset",                      o(EXT_polygon_offset),                      GL             },
   { "GL_EXT_provoking_vertex",                    o(EXT_provoking_vertex),                    GL             },
   { "GL_EXT_rescale_normal",                      o(EXT_rescale_normal),                      GL             },
   { "GL_EXT_secondary_color",                     o(EXT_secondary_color),                     GL             },
   { "GL_EXT_separate_shader_objects",             o(EXT_separate_shader_objects),             GL             },
   { "GL_EXT_separate_specular_color",             o(EXT_separate_specular_color),             GL             },
   { "GL_EXT_shadow_funcs",                        o(EXT_shadow_funcs),                        GL             },
   { "GL_EXT_shared_texture_palette",              o(EXT_shared_texture_palette),              GL             },
   { "GL_EXT_stencil_two_side",                    o(EXT_stencil_two_side),                    GL             },
   { "GL_EXT_stencil_wrap",                        o(EXT_stencil_wrap),                        GL             },
   { "GL_EXT_subtexture",                          o(EXT_subtexture),                          GL             },
   { "GL_EXT_texture3D",                           o(EXT_texture3D),                           GL             },
   { "GL_EXT_texture_array",                       o(EXT_texture_array),                       GL             },
   { "GL_EXT_texture_compression_dxt1",            o(EXT_texture_compression_s3tc),            GL | ES1 | ES2 },
   { "GL_EXT_texture_compression_rgtc",            o(ARB_texture_compression_rgtc),            GL             },
   { "GL_EXT_texture_compression_s3tc",            o(EXT_texture_compression_s3tc),            GL             },
   { "GL_EXT_texture_cube_map",                    o(ARB_texture_cube_map),                    GL             },
   { "GL_EXT_texture_edge_clamp",                  o(SGIS_texture_edge_clamp),                 GL             },
   { "GL_EXT_texture_env_add",                     o(EXT_texture_env_add),                     GL             },
   { "GL_EXT_texture_env_combine",                 o(EXT_texture_env_combine),                 GL             },
   { "GL_EXT_texture_env_dot3",                    o(EXT_texture_env_dot3),                    GL             },
   { "GL_EXT_texture_filter_anisotropic",          o(EXT_texture_filter_anisotropic),          GL | ES1 | ES2 },
   { "GL_EXT_texture_format_BGRA8888",             o(EXT_texture_format_BGRA8888),                  ES1 | ES2 },
   { "GL_EXT_texture_integer",                     o(EXT_texture_integer),                     GL             },
   { "GL_EXT_texture_lod_bias",                    o(EXT_texture_lod_bias),                    GL | ES1       },
   { "GL_EXT_texture_mirror_clamp",                o(EXT_texture_mirror_clamp),                GL             },
   { "GL_EXT_texture_object",                      o(EXT_texture_object),                      GL             },
   { "GL_EXT_texture",                             o(EXT_texture),                             GL             },
   { "GL_EXT_texture_rectangle",                   o(NV_texture_rectangle),                    GL             },
   { "GL_EXT_texture_shared_exponent",             o(EXT_texture_shared_exponent),             GL             },
   { "GL_EXT_texture_sRGB",                        o(EXT_texture_sRGB),                        GL             },
   { "GL_EXT_texture_swizzle",                     o(EXT_texture_swizzle),                     GL             },
   { "GL_EXT_texture_type_2_10_10_10_REV",         o(dummy_true),                                         ES2 },
   { "GL_EXT_timer_query",                         o(EXT_timer_query),                         GL             },
   { "GL_EXT_transform_feedback",                  o(EXT_transform_feedback),                  GL             },
   { "GL_EXT_vertex_array_bgra",                   o(EXT_vertex_array_bgra),                   GL             },
   { "GL_EXT_vertex_array",                        o(EXT_vertex_array),                        GL             },
   { "GL_EXT_vertex_array_set",                    o(EXT_vertex_array_set),                    GL             },

   /* OES extensions */
   { "GL_OES_blend_equation_separate",             o(EXT_blend_equation_separate),                  ES1       },
   { "GL_OES_blend_func_separate",                 o(EXT_blend_func_separate),                      ES1       },
   { "GL_OES_blend_subtract",                      o(EXT_blend_subtract),                           ES1       },
   { "GL_OES_byte_coordinates",                    o(dummy_true),                                   ES1       },
   { "GL_OES_compressed_paletted_texture",         o(dummy_false),                     DISABLE                },
   { "GL_OES_depth24",                             o(EXT_framebuffer_object),                       ES1 | ES2 },
   { "GL_OES_depth32",                             o(dummy_false),                     DISABLE                },
   { "GL_OES_depth_texture",                       o(ARB_depth_texture),                                  ES2 },
#if FEATURE_OES_draw_texture
   { "GL_OES_draw_texture",                        o(OES_draw_texture),                             ES1 | ES2 },
#endif
#if FEATURE_OES_EGL_image
   /*  FIXME: Mesa expects GL_OES_EGL_image to be available in OpenGL contexts. */
   { "GL_OES_EGL_image",                           o(OES_EGL_image),                           GL | ES1 | ES2 },
#endif
   { "GL_OES_element_index_uint",                  o(EXT_vertex_array),                             ES1 | ES2 },
   { "GL_OES_fbo_render_mipmap",                   o(EXT_framebuffer_object),                       ES1 | ES2 },
   { "GL_OES_fixed_point",                         o(dummy_true),                                   ES1       },
   { "GL_OES_framebuffer_object",                  o(EXT_framebuffer_object),                       ES1       },
   { "GL_OES_mapbuffer",                           o(ARB_vertex_buffer_object),                     ES1 | ES2 },
   { "GL_OES_matrix_get",                          o(dummy_true),                                   ES1       },
   { "GL_OES_packed_depth_stencil",                o(EXT_packed_depth_stencil),                     ES1 | ES2 },
   { "GL_OES_point_size_array",                    o(dummy_true),                                   ES1       },
   { "GL_OES_point_sprite",                        o(ARB_point_sprite),                             ES1       },
   { "GL_OES_query_matrix",                        o(dummy_true),                                   ES1       },
   { "GL_OES_read_format",                         o(OES_read_format),                         GL | ES1       },
   { "GL_OES_rgb8_rgba8",                          o(EXT_framebuffer_object),                       ES1 | ES2 },
   { "GL_OES_single_precision",                    o(dummy_true),                                   ES1       },
   { "GL_OES_standard_derivatives",                o(OES_standard_derivatives),                           ES2 },
   { "GL_OES_stencil1",                            o(dummy_false),                     DISABLE                },
   { "GL_OES_stencil4",                            o(dummy_false),                     DISABLE                },
   { "GL_OES_stencil8",                            o(EXT_framebuffer_object),                       ES1 | ES2 },
   { "GL_OES_stencil_wrap",                        o(EXT_stencil_wrap),                             ES1       },
   /* GL_OES_texture_3D is disabled due to missing GLSL support. */
   { "GL_OES_texture_3D",                          o(EXT_texture3D),                   DISABLE                },
   { "GL_OES_texture_cube_map",                    o(ARB_texture_cube_map),                         ES1       },
   { "GL_OES_texture_env_crossbar",                o(ARB_texture_env_crossbar),                     ES1       },
   { "GL_OES_texture_mirrored_repeat",             o(ARB_texture_mirrored_repeat),                  ES1       },
   { "GL_OES_texture_npot",                        o(ARB_texture_non_power_of_two),                       ES2 },

   /* Vendor extensions */
   { "GL_3DFX_texture_compression_FXT1",           o(TDFX_texture_compression_FXT1),           GL             },
   { "GL_APPLE_client_storage",                    o(APPLE_client_storage),                    GL             },
   { "GL_APPLE_object_purgeable",                  o(APPLE_object_purgeable),                  GL             },
   { "GL_APPLE_packed_pixels",                     o(APPLE_packed_pixels),                     GL             },
   { "GL_APPLE_vertex_array_object",               o(APPLE_vertex_array_object),               GL             },
   { "GL_ATI_blend_equation_separate",             o(EXT_blend_equation_separate),             GL             },
   { "GL_ATI_envmap_bumpmap",                      o(ATI_envmap_bumpmap),                      GL             },
   { "GL_ATI_fragment_shader",                     o(ATI_fragment_shader),                     GL             },
   { "GL_ATI_separate_stencil",                    o(ATI_separate_stencil),                    GL             },
   { "GL_ATI_texture_env_combine3",                o(ATI_texture_env_combine3),                GL             },
   { "GL_ATI_texture_mirror_once",                 o(ATI_texture_mirror_once),                 GL             },
   { "GL_IBM_multimode_draw_arrays",               o(IBM_multimode_draw_arrays),               GL             },
   { "GL_IBM_rasterpos_clip",                      o(IBM_rasterpos_clip),                      GL             },
   { "GL_IBM_texture_mirrored_repeat",             o(ARB_texture_mirrored_repeat),             GL             },
   { "GL_INGR_blend_func_separate",                o(EXT_blend_func_separate),                 GL             },
   { "GL_MESA_pack_invert",                        o(MESA_pack_invert),                        GL             },
   { "GL_MESA_resize_buffers",                     o(MESA_resize_buffers),                     GL             },
   { "GL_MESA_texture_array",                      o(MESA_texture_array),                      GL             },
   { "GL_MESA_texture_signed_rgba",                o(MESA_texture_signed_rgba),                GL             },
   { "GL_MESA_window_pos",                         o(ARB_window_pos),                          GL             },
   { "GL_MESAX_texture_float",                     o(ARB_texture_float),                       GL             },
   { "GL_MESA_ycbcr_texture",                      o(MESA_ycbcr_texture),                      GL             },
   { "GL_NV_blend_square",                         o(NV_blend_square),                         GL             },
   { "GL_NV_conditional_render",                   o(NV_conditional_render),                   GL             },
   { "GL_NV_depth_clamp",                          o(ARB_depth_clamp),                         GL             },
   { "GL_NV_fragment_program",                     o(NV_fragment_program),                     GL             },
   { "GL_NV_fragment_program_option",              o(NV_fragment_program_option),              GL             },
   { "GL_NV_light_max_exponent",                   o(NV_light_max_exponent),                   GL             },
   { "GL_NV_packed_depth_stencil",                 o(EXT_packed_depth_stencil),                GL             },
   { "GL_NV_point_sprite",                         o(NV_point_sprite),                         GL             },
   { "GL_NV_primitive_restart",                    o(NV_primitive_restart),                    GL             },
   { "GL_NV_texgen_reflection",                    o(NV_texgen_reflection),                    GL             },
   { "GL_NV_texture_env_combine4",                 o(NV_texture_env_combine4),                 GL             },
   { "GL_NV_texture_rectangle",                    o(NV_texture_rectangle),                    GL             },
   { "GL_NV_vertex_program1_1",                    o(NV_vertex_program1_1),                    GL             },
   { "GL_NV_vertex_program",                       o(NV_vertex_program),                       GL             },
   { "GL_S3_s3tc",                                 o(S3_s3tc),                                 GL             },
   { "GL_SGIS_generate_mipmap",                    o(SGIS_generate_mipmap),                    GL             },
   { "GL_SGIS_texture_border_clamp",               o(ARB_texture_border_clamp),                GL             },
   { "GL_SGIS_texture_edge_clamp",                 o(SGIS_texture_edge_clamp),                 GL             },
   { "GL_SGIS_texture_lod",                        o(SGIS_texture_lod),                        GL             },
   { "GL_SGI_texture_color_table",                 o(SGI_texture_color_table),                 GL             },
   { "GL_SUN_multi_draw_arrays",                   o(EXT_multi_draw_arrays),                   GL             },

   { 0, 0, 0 },
a173 73
/**
 * Given an extension name, lookup up the corresponding member of struct
 * gl_extensions and return that member's offset (in bytes).  If the name is
 * not found in the \c extension_table, return 0.
 *
 * \param name Name of extension.
 * \return Offset of member in struct gl_extensions.
 */
static size_t
name_to_offset(const char* name)
{
   const struct extension *i;

   if (name == 0)
      return 0;

   for (i = extension_table; i->name != 0; ++i) {
      if (strcmp(name, i->name) == 0)
	 return i->offset;
   }

   return 0;
}


/**
 * \brief Extensions enabled by default.
 *
 * These extensions are enabled by _mesa_init_extensions().
 *
 * XXX: Should these defaults also apply to GLES?
 */
static const size_t default_extensions[] = {
   o(ARB_copy_buffer),
   o(ARB_draw_buffers),
   o(ARB_multisample),
   o(ARB_texture_compression),
   o(ARB_transpose_matrix),
   o(ARB_vertex_buffer_object),
   o(ARB_window_pos),

   o(EXT_abgr),
   o(EXT_bgra),
   o(EXT_compiled_vertex_array),
   o(EXT_copy_texture),
   o(EXT_draw_range_elements),
   o(EXT_multi_draw_arrays),
   o(EXT_packed_pixels),
   o(EXT_polygon_offset),
   o(EXT_rescale_normal),
   o(EXT_separate_specular_color),
   o(EXT_subtexture),
   o(EXT_texture),
   o(EXT_texture3D),
   o(EXT_texture_object),
   o(EXT_vertex_array),

   o(OES_read_format),
   o(OES_standard_derivatives),

   /* Vendor Extensions */
   o(APPLE_packed_pixels),
   o(IBM_multimode_draw_arrays),
   o(IBM_rasterpos_clip),
   o(NV_light_max_exponent),
   o(NV_texgen_reflection),
   o(SGIS_generate_mipmap),
   o(SGIS_texture_edge_clamp),
   o(SGIS_texture_lod),

   0,
};

d180 1
a180 1
_mesa_enable_sw_extensions(struct gl_context *ctx)
a181 2
   /*ctx->Extensions.ARB_copy_buffer = GL_TRUE;*/
   ctx->Extensions.ARB_depth_clamp = GL_TRUE;
d183 1
a183 4
   /*ctx->Extensions.ARB_draw_buffers = GL_TRUE;*/
   ctx->Extensions.ARB_draw_elements_base_vertex = GL_TRUE;
   ctx->Extensions.ARB_explicit_attrib_location = GL_TRUE;
   ctx->Extensions.ARB_fragment_coord_conventions = GL_TRUE;
a185 1
   ctx->Extensions.ARB_fragment_program_shadow = GL_TRUE;
a189 7
#if FEATURE_ARB_framebuffer_object
   ctx->Extensions.ARB_framebuffer_object = GL_TRUE;
#endif
#if FEATURE_ARB_geometry_shader4 && 0
   /* XXX re-enable when GLSL compiler again supports geometry shaders */
   ctx->Extensions.ARB_geometry_shader4 = GL_TRUE;
#endif
d191 1
a191 2
   ctx->Extensions.ARB_half_float_vertex = GL_TRUE;
   ctx->Extensions.ARB_map_buffer_range = GL_TRUE;
d193 1
a193 1
#if FEATURE_queryobj
a198 1
   ctx->Extensions.EXT_separate_shader_objects = GL_TRUE;
d203 3
a206 1
   ctx->Extensions.ARB_shadow_ambient = GL_TRUE;
a214 2
   ctx->Extensions.ARB_texture_rg = GL_TRUE;
   ctx->Extensions.ARB_vertex_array_object = GL_TRUE;
d222 1
a222 4
   /*ctx->Extensions.ARB_vertex_buffer_object = GL_TRUE;*/
#endif
#if FEATURE_ARB_sync
   ctx->Extensions.ARB_sync = GL_TRUE;
a224 4
#if FEATURE_APPLE_object_purgeable
   ctx->Extensions.APPLE_object_purgeable = GL_TRUE;
#endif
   ctx->Extensions.ATI_envmap_bumpmap = GL_TRUE;
d237 1
a238 1
   ctx->Extensions.EXT_draw_buffers2 = GL_TRUE;
d246 2
a247 4
#if FEATURE_ARB_framebuffer_object
   ctx->Extensions.EXT_framebuffer_multisample = GL_TRUE;
#endif
   /*ctx->Extensions.EXT_multi_draw_arrays = GL_TRUE;*/
a253 1
   ctx->Extensions.EXT_provoking_vertex = GL_TRUE;
d258 1
a258 2
   ctx->Extensions.EXT_stencil_two_side = GL_TRUE;
   ctx->Extensions.EXT_texture_array = GL_TRUE;
d267 4
a270 3
   ctx->Extensions.EXT_texture_swizzle = GL_TRUE;
#if FEATURE_EXT_transform_feedback
   /*ctx->Extensions.EXT_transform_feedback = GL_TRUE;*/
a271 3
   ctx->Extensions.EXT_vertex_array_bgra = GL_TRUE;
   /*ctx->Extensions.IBM_multimode_draw_arrays = GL_TRUE;*/
   ctx->Extensions.MESA_pack_invert = GL_TRUE;
a272 1
   ctx->Extensions.MESA_texture_array = GL_TRUE;
a274 1
   ctx->Extensions.NV_conditional_render = GL_TRUE;
a276 1
   ctx->Extensions.NV_texture_env_combine4 = GL_TRUE;
d286 2
a287 3
#if FEATURE_NV_fragment_program && FEATURE_ARB_fragment_program
   ctx->Extensions.NV_fragment_program_option = GL_TRUE;
#endif
d289 1
a289 1
   /*ctx->Extensions.SGIS_generate_mipmap = GL_TRUE;*/
d291 3
a296 9
#if FEATURE_texture_fxt1
   _mesa_enable_extension(ctx, "GL_3DFX_texture_compression_FXT1");
#endif
#if FEATURE_texture_s3tc
   if (ctx->Mesa_DXTn) {
      _mesa_enable_extension(ctx, "GL_EXT_texture_compression_s3tc");
      _mesa_enable_extension(ctx, "GL_S3_s3tc");
   }
#endif
d301 1
a301 1
 * Enable common EXT extensions in the ARB_imaging subset.
d304 1
a304 1
_mesa_enable_imaging_extensions(struct gl_context *ctx)
d306 1
a307 1
   ctx->Extensions.EXT_blend_logic_op = GL_TRUE;
d310 4
d323 1
a323 1
_mesa_enable_1_3_extensions(struct gl_context *ctx)
d325 1
a325 1
   /*ctx->Extensions.ARB_multisample = GL_TRUE;*/
d328 1
a328 1
   /*ctx->Extensions.ARB_texture_compression = GL_TRUE;*/
d343 1
a343 1
_mesa_enable_1_4_extensions(struct gl_context *ctx)
d352 1
d356 1
a356 1
   /*ctx->Extensions.EXT_multi_draw_arrays = GL_TRUE;*/
d361 1
a361 1
   /*ctx->Extensions.SGIS_generate_mipmap = GL_TRUE;*/
d370 1
a370 1
_mesa_enable_1_5_extensions(struct gl_context *ctx)
d373 1
a373 1
   /*ctx->Extensions.ARB_vertex_buffer_object = GL_TRUE;*/
d383 1
a383 1
_mesa_enable_2_0_extensions(struct gl_context *ctx)
d385 1
a385 1
   /*ctx->Extensions.ARB_draw_buffers = GL_TRUE;*/
a389 1
   ctx->Extensions.EXT_blend_equation_separate = GL_TRUE;
d397 1
a397 1
   ctx->Extensions.EXT_stencil_two_side = GL_TRUE;
d409 1
a409 1
_mesa_enable_2_1_extensions(struct gl_context *ctx)
d417 3
d423 1
a425 1
 * \return GL_TRUE for success, GL_FALSE if invalid extension name
d427 2
a428 2
static GLboolean
set_extension( struct gl_context *ctx, const char *name, GLboolean state )
d430 2
a431 1
   size_t offset;
d436 1
a436 1
      return GL_FALSE;
d439 8
a446 13
   offset = name_to_offset(name);
   if (offset == 0) {
      _mesa_problem(ctx, "Trying to enable/disable unknown extension %s",
	            name);
      return GL_FALSE;
   } else if (offset == o(dummy_true) && state == GL_FALSE) {
      _mesa_problem(ctx, "Trying to disable a permanently enabled extension: "
	                  "%s", name);
      return GL_FALSE;
   } else {
      GLboolean *base = (GLboolean *) &ctx->Extensions;
      base[offset] = state;
      return GL_TRUE;
d448 1
d457 1
a457 1
_mesa_enable_extension( struct gl_context *ctx, const char *name )
d459 1
a459 2
   if (!set_extension(ctx, name, GL_TRUE))
      _mesa_problem(ctx, "Trying to enable unknown extension: %s", name);
d468 1
a468 1
_mesa_disable_extension( struct gl_context *ctx, const char *name )
d470 1
a470 2
   if (!set_extension(ctx, name, GL_FALSE))
      _mesa_problem(ctx, "Trying to disable unknown extension: %s", name);
d478 1
a478 1
_mesa_extension_is_enabled( struct gl_context *ctx, const char *name )
d480 2
a481 2
   size_t offset;
   GLboolean *base;
d483 6
a488 26
   if (name == 0)
      return GL_FALSE;

   offset = name_to_offset(name);
   if (offset == 0)
      return GL_FALSE;
   base = (GLboolean *) &ctx->Extensions;
   return base[offset];
}


/**
 * Append string 'b' onto string 'a'.  Free 'a' and return new string.
 */
static char *
append(const char *a, const char *b)
{
   const GLuint aLen = a ? strlen(a) : 0;
   const GLuint bLen = b ? strlen(b) : 0;
   char *s = calloc(1, aLen + bLen + 1);
   if (s) {
      if (a)
         memcpy(s, a, aLen);
      if (b)
         memcpy(s + aLen, b, bLen);
      s[aLen + bLen] = '\0';
d490 1
a490 3
   if (a)
      free((void *) a);
   return s;
d495 3
a497 6
 * Check the MESA_EXTENSION_OVERRIDE env var.
 * For extension names that are recognized, turn them on.  For extension
 * names that are recognized and prefixed with '-', turn them off.
 * Return a string of the unknown/leftover names.
 *
 * Returnd string needs to be freed.
d499 2
a500 2
static char *
get_extension_override( struct gl_context *ctx )
d502 1
a502 4
   const char *envExt = _mesa_getenv("MESA_EXTENSION_OVERRIDE");
   char *extraExt = NULL;
   char ext[1000];
   GLuint extLen = 0;
a503 1
   GLboolean disableExt = GL_FALSE;
d505 4
a508 29
   if (!envExt)
      return NULL;

   for (i = 0; ; i++) {
      if (envExt[i] == '\0' || envExt[i] == ' ') {
         /* terminate/process 'ext' if extLen > 0 */
         if (extLen > 0) {
            assert(extLen < sizeof(ext));
            /* enable extension named by 'ext' */
            ext[extLen] = 0;
            if (!set_extension(ctx, ext, !disableExt)) {
               /* unknown extension name, append it to extraExt */
               if (extraExt) {
                  extraExt = append(extraExt, " ");
               }
               extraExt = append(extraExt, ext);
            }
            extLen = 0;
            disableExt = GL_FALSE;
         }
         if (envExt[i] == '\0')
            break;
      }
      else if (envExt[i] == '-') {
         disableExt = GL_TRUE;
      }
      else {
         /* accumulate this non-space character */
         ext[extLen++] = envExt[i];
a510 27

   return extraExt;
}


/**
 * \brief Initialize extension tables and enable default extensions.
 *
 * This should be called during context initialization.
 * Note: Sets gl_extensions.dummy_true to true.
 */
void
_mesa_init_extensions( struct gl_context *ctx )
{
   GLboolean *base = (GLboolean *) &ctx->Extensions;
   GLboolean *sentinel = base + o(extension_sentinel);
   GLboolean *i;
   const size_t *j;

   /* First, turn all extensions off. */
   for (i = base; i != sentinel; ++i)
      *i = GL_FALSE;

   /* Then, selectively turn default extensions on. */
   ctx->Extensions.dummy_true = GL_TRUE;
   for (j = default_extensions; *j != 0; ++j)
      base[*j] = GL_TRUE;
d518 2
a519 2
GLubyte*
_mesa_make_extension_string(struct gl_context *ctx)
d521 4
a524 8
   /* The extension string. */
   char *exts = 0;
   /* Length of extension string. */
   size_t length = 0;
   /* String of extra extensions. */
   char *extra_extensions = get_extension_override(ctx);
   GLboolean *base = (GLboolean *) &ctx->Extensions;
   const struct extension *i;
d526 5
a530 4
   /* Compute length of the extension string. */
   for (i = extension_table; i->name != 0; ++i) {
      if (base[i->offset] && (i->api_set & (1 << ctx->API))) {
	 length += strlen(i->name) + 1; /* +1 for space */
d533 1
a533 8
   if (extra_extensions != NULL)
      length += 1 + strlen(extra_extensions); /* +1 for space */

   exts = (char *) calloc(length + 1, sizeof(char));
   if (exts == NULL) {
      free(extra_extensions);
      return NULL;
   }
d535 10
a544 5
   /* Build the extension string.*/
   for (i = extension_table; i->name != 0; ++i) {
      if (base[i->offset] && (i->api_set & (1 << ctx->API))) {
         strcat(exts, i->name);
         strcat(exts, " ");
d547 1
a547 4
   if (extra_extensions != 0) {
      strcat(exts, extra_extensions);
      free(extra_extensions);
   }
d549 1
a549 2
   return (GLubyte *) exts;
}
d551 1
a551 46
/**
 * Return number of enabled extensions.
 */
GLuint
_mesa_get_extension_count(struct gl_context *ctx)
{
   GLboolean *base;
   const struct extension *i;

   /* only count once */
   if (ctx->Extensions.Count != 0)
      return ctx->Extensions.Count;

   base = (GLboolean *) &ctx->Extensions;
   for (i = extension_table; i->name != 0; ++i) {
      if (base[i->offset]) {
	 ctx->Extensions.Count++;
      }
   }
   return ctx->Extensions.Count;
}

/**
 * Return name of i-th enabled extension
 */
const GLubyte *
_mesa_get_enabled_extension(struct gl_context *ctx, GLuint index)
{
   const GLboolean *base;
   size_t n;
   const struct extension *i;

   if (index < 0)
      return NULL;

   base = (GLboolean*) &ctx->Extensions;
   n = 0;
   for (i = extension_table; i->name != 0; ++i) {
      if (n == index && base[i->offset]) {
	 return (GLubyte*) i->name;
      } else if (base[i->offset]) {
	 ++n;
      }
   }

   return NULL;
@


1.1.1.5
log
@Import Mesa 9.2.0
@
text
@d3 1
d21 3
a23 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
a36 1
#include "macros.h"
d41 1
a41 3
   GLL = 1 << API_OPENGL_COMPAT,       /* GL Legacy / Compatibility */
   GLC = 1 << API_OPENGL_CORE,  /* GL Core */
   GL  = (1 << API_OPENGL_COMPAT) | (1 << API_OPENGL_CORE),
a43 1
   ES3 = 1 << (API_OPENGL_LAST + 1),
a57 4

   /** Year the extension was proposed or approved.  Used to sort the 
    * extension string chronologically. */
   uint16_t year;
d70 2
d75 62
a136 87
   { "GL_ARB_ES2_compatibility",                   o(ARB_ES2_compatibility),                   GL,             2009 },
   { "GL_ARB_ES3_compatibility",                   o(ARB_ES3_compatibility),                   GL,             2012 },
   { "GL_ARB_base_instance",                       o(ARB_base_instance),                       GL,             2011 },
   { "GL_ARB_blend_func_extended",                 o(ARB_blend_func_extended),                 GL,             2009 },
   { "GL_ARB_color_buffer_float",                  o(ARB_color_buffer_float),                  GL,             2004 },
   { "GL_ARB_copy_buffer",                         o(dummy_true),                              GL,             2008 },
   { "GL_ARB_conservative_depth",                  o(ARB_conservative_depth),                  GL,             2011 },
   { "GL_ARB_debug_output",                        o(dummy_true),                              GL,             2009 },
   { "GL_ARB_depth_buffer_float",                  o(ARB_depth_buffer_float),                  GL,             2008 },
   { "GL_ARB_depth_clamp",                         o(ARB_depth_clamp),                         GL,             2003 },
   { "GL_ARB_depth_texture",                       o(ARB_depth_texture),                       GLL,            2001 },
   { "GL_ARB_draw_buffers",                        o(dummy_true),                              GL,             2002 },
   { "GL_ARB_draw_buffers_blend",                  o(ARB_draw_buffers_blend),                  GL,             2009 },
   { "GL_ARB_draw_elements_base_vertex",           o(ARB_draw_elements_base_vertex),           GL,             2009 },
   { "GL_ARB_draw_instanced",                      o(ARB_draw_instanced),                      GL,             2008 },
   { "GL_ARB_explicit_attrib_location",            o(ARB_explicit_attrib_location),            GL,             2009 },
   { "GL_ARB_fragment_coord_conventions",          o(ARB_fragment_coord_conventions),          GL,             2009 },
   { "GL_ARB_fragment_program",                    o(ARB_fragment_program),                    GLL,            2002 },
   { "GL_ARB_fragment_program_shadow",             o(ARB_fragment_program_shadow),             GLL,            2003 },
   { "GL_ARB_fragment_shader",                     o(ARB_fragment_shader),                     GL,             2002 },
   { "GL_ARB_framebuffer_object",                  o(ARB_framebuffer_object),                  GL,             2005 },
   { "GL_ARB_framebuffer_sRGB",                    o(EXT_framebuffer_sRGB),                    GL,             1998 },
   { "GL_ARB_get_program_binary",                  o(dummy_true),                              GL,             2010 },
   { "GL_ARB_gpu_shader5",                         o(ARB_gpu_shader5),                         GL,             2010 },
   { "GL_ARB_half_float_pixel",                    o(ARB_half_float_pixel),                    GL,             2003 },
   { "GL_ARB_half_float_vertex",                   o(ARB_half_float_vertex),                   GL,             2008 },
   { "GL_ARB_instanced_arrays",                    o(ARB_instanced_arrays),                    GL,             2008 },
   { "GL_ARB_internalformat_query",                o(ARB_internalformat_query),                GL,             2011 },
   { "GL_ARB_invalidate_subdata",                  o(dummy_true),                              GL,             2012 },
   { "GL_ARB_map_buffer_alignment",                o(ARB_map_buffer_alignment),                GL,             2011 },
   { "GL_ARB_map_buffer_range",                    o(ARB_map_buffer_range),                    GL,             2008 },
   { "GL_ARB_multisample",                         o(dummy_true),                              GLL,            1994 },
   { "GL_ARB_multitexture",                        o(dummy_true),                              GLL,            1998 },
   { "GL_ARB_occlusion_query2",                    o(ARB_occlusion_query2),                    GL,             2003 },
   { "GL_ARB_occlusion_query",                     o(ARB_occlusion_query),                     GLL,            2001 },
   { "GL_ARB_pixel_buffer_object",                 o(EXT_pixel_buffer_object),                 GL,             2004 },
   { "GL_ARB_point_parameters",                    o(EXT_point_parameters),                    GLL,            1997 },
   { "GL_ARB_point_sprite",                        o(ARB_point_sprite),                        GL,             2003 },
   { "GL_ARB_provoking_vertex",                    o(EXT_provoking_vertex),                    GL,             2009 },
   { "GL_ARB_robustness",                          o(dummy_true),                              GL,             2010 },
   { "GL_ARB_sampler_objects",                     o(dummy_true),                              GL,             2009 },
   { "GL_ARB_seamless_cube_map",                   o(ARB_seamless_cube_map),                   GL,             2009 },
   { "GL_ARB_shader_bit_encoding",                 o(ARB_shader_bit_encoding),                 GL,             2010 },
   { "GL_ARB_shader_objects",                      o(dummy_true),                              GL,             2002 },
   { "GL_ARB_shader_stencil_export",               o(ARB_shader_stencil_export),               GL,             2009 },
   { "GL_ARB_shader_texture_lod",                  o(ARB_shader_texture_lod),                  GL,             2009 },
   { "GL_ARB_shading_language_100",                o(dummy_true),                              GLL,            2003 },
   { "GL_ARB_shading_language_packing",            o(ARB_shading_language_packing),            GL,             2011 },
   { "GL_ARB_shading_language_420pack",            o(ARB_shading_language_420pack),            GL,             2011 },
   { "GL_ARB_shadow",                              o(ARB_shadow),                              GLL,            2001 },
   { "GL_ARB_sync",                                o(ARB_sync),                                GL,             2003 },
   { "GL_ARB_texture_border_clamp",                o(ARB_texture_border_clamp),                GLL,            2000 },
   { "GL_ARB_texture_buffer_object",               o(ARB_texture_buffer_object),               GLC,            2008 },
   { "GL_ARB_texture_buffer_object_rgb32",         o(ARB_texture_buffer_object_rgb32),         GLC,            2009 },
   { "GL_ARB_texture_buffer_range",                o(ARB_texture_buffer_range),                GLC,            2012 },
   { "GL_ARB_texture_compression",                 o(dummy_true),                              GLL,            2000 },
   { "GL_ARB_texture_compression_rgtc",            o(ARB_texture_compression_rgtc),            GL,             2004 },
   { "GL_ARB_texture_cube_map",                    o(ARB_texture_cube_map),                    GLL,            1999 },
   { "GL_ARB_texture_cube_map_array",              o(ARB_texture_cube_map_array),              GL,             2009 },
   { "GL_ARB_texture_env_add",                     o(dummy_true),                              GLL,            1999 },
   { "GL_ARB_texture_env_combine",                 o(ARB_texture_env_combine),                 GLL,            2001 },
   { "GL_ARB_texture_env_crossbar",                o(ARB_texture_env_crossbar),                GLL,            2001 },
   { "GL_ARB_texture_env_dot3",                    o(ARB_texture_env_dot3),                    GLL,            2001 },
   { "GL_ARB_texture_float",                       o(ARB_texture_float),                       GL,             2004 },
   { "GL_ARB_texture_mirrored_repeat",             o(dummy_true),                              GLL,            2001 },
   { "GL_ARB_texture_multisample",                 o(ARB_texture_multisample),                 GL,             2009 },
   { "GL_ARB_texture_non_power_of_two",            o(ARB_texture_non_power_of_two),            GL,             2003 },
   { "GL_ARB_texture_query_lod",                   o(ARB_texture_query_lod),                   GL,             2009 },
   { "GL_ARB_texture_rectangle",                   o(NV_texture_rectangle),                    GL,             2004 },
   { "GL_ARB_texture_rgb10_a2ui",                  o(ARB_texture_rgb10_a2ui),                  GL,             2009 },
   { "GL_ARB_texture_rg",                          o(ARB_texture_rg),                          GL,             2008 },
   { "GL_ARB_texture_storage",                     o(dummy_true),                              GL,             2011 },
   { "GL_ARB_texture_storage_multisample",         o(ARB_texture_multisample),                 GL,             2012 },
   { "GL_ARB_texture_swizzle",                     o(EXT_texture_swizzle),                     GL,             2008 },
   { "GL_ARB_timer_query",                         o(ARB_timer_query),                         GL,             2010 },
   { "GL_ARB_transform_feedback2",                 o(ARB_transform_feedback2),                 GL,             2010 },
   { "GL_ARB_transform_feedback3",                 o(ARB_transform_feedback3),                 GL,             2010 },
   { "GL_ARB_transform_feedback_instanced",        o(ARB_transform_feedback_instanced),        GL,             2011 },
   { "GL_ARB_transpose_matrix",                    o(dummy_true),                              GLL,            1999 },
   { "GL_ARB_uniform_buffer_object",               o(ARB_uniform_buffer_object),               GL,             2009 },
   { "GL_ARB_vertex_array_bgra",                   o(EXT_vertex_array_bgra),                   GL,             2008 },
   { "GL_ARB_vertex_array_object",                 o(dummy_true),                              GL,             2006 },
   { "GL_ARB_vertex_buffer_object",                o(dummy_true),                              GLL,            2003 },
   { "GL_ARB_vertex_program",                      o(ARB_vertex_program),                      GLL,            2002 },
   { "GL_ARB_vertex_shader",                       o(ARB_vertex_shader),                       GL,             2002 },
   { "GL_ARB_vertex_type_2_10_10_10_rev",          o(ARB_vertex_type_2_10_10_10_rev),          GL,             2009 },
   { "GL_ARB_window_pos",                          o(dummy_true),                              GLL,            2001 },
d138 67
a204 74
   { "GL_EXT_abgr",                                o(dummy_true),                              GL,             1995 },
   { "GL_EXT_bgra",                                o(dummy_true),                              GLL,            1995 },
   { "GL_EXT_blend_color",                         o(EXT_blend_color),                         GLL,            1995 },
   { "GL_EXT_blend_equation_separate",             o(EXT_blend_equation_separate),             GL,             2003 },
   { "GL_EXT_blend_func_separate",                 o(EXT_blend_func_separate),                 GLL,            1999 },
   { "GL_EXT_discard_framebuffer",                 o(dummy_true),                                    ES1 | ES2, 2009 },
   { "GL_EXT_blend_minmax",                        o(EXT_blend_minmax),                        GLL | ES1 | ES2, 1995 },
   { "GL_EXT_blend_subtract",                      o(dummy_true),                              GLL,            1995 },
   { "GL_EXT_compiled_vertex_array",               o(dummy_true),                              GLL,            1996 },
   { "GL_EXT_copy_texture",                        o(dummy_true),                              GLL,            1995 },
   { "GL_EXT_depth_bounds_test",                   o(EXT_depth_bounds_test),                   GL,             2002 },
   { "GL_EXT_draw_buffers2",                       o(EXT_draw_buffers2),                       GL,             2006 },
   { "GL_EXT_draw_instanced",                      o(ARB_draw_instanced),                      GL,             2006 },
   { "GL_EXT_draw_range_elements",                 o(dummy_true),                              GLL,            1997 },
   { "GL_EXT_fog_coord",                           o(dummy_true),                              GLL,            1999 },
   { "GL_EXT_framebuffer_blit",                    o(EXT_framebuffer_blit),                    GL,             2005 },
   { "GL_EXT_framebuffer_multisample",             o(EXT_framebuffer_multisample),             GL,             2005 },
   { "GL_EXT_framebuffer_multisample_blit_scaled", o(EXT_framebuffer_multisample_blit_scaled), GL,             2011 },
   { "GL_EXT_framebuffer_object",                  o(dummy_true),                              GLL,            2000 },
   { "GL_EXT_framebuffer_sRGB",                    o(EXT_framebuffer_sRGB),                    GL,             1998 },
   { "GL_EXT_gpu_program_parameters",              o(EXT_gpu_program_parameters),              GLL,            2006 },
   { "GL_EXT_gpu_shader4",                         o(EXT_gpu_shader4),                         GL,             2006 },
   { "GL_EXT_map_buffer_range",                    o(ARB_map_buffer_range),                          ES1 | ES2, 2012 },
   { "GL_EXT_multi_draw_arrays",                   o(dummy_true),                              GLL | ES1 | ES2, 1999 },
   { "GL_EXT_packed_depth_stencil",                o(EXT_packed_depth_stencil),                GL,             2005 },
   { "GL_EXT_packed_float",                        o(EXT_packed_float),                        GL,             2004 },
   { "GL_EXT_packed_pixels",                       o(dummy_true),                              GLL,            1997 },
   { "GL_EXT_pixel_buffer_object",                 o(EXT_pixel_buffer_object),                 GL,             2004 },
   { "GL_EXT_point_parameters",                    o(EXT_point_parameters),                    GLL,            1997 },
   { "GL_EXT_polygon_offset",                      o(dummy_true),                              GLL,            1995 },
   { "GL_EXT_provoking_vertex",                    o(EXT_provoking_vertex),                    GL,             2009 },
   { "GL_EXT_rescale_normal",                      o(dummy_true),                              GLL,            1997 },
   { "GL_EXT_secondary_color",                     o(dummy_true),                              GLL,            1999 },
   { "GL_EXT_separate_shader_objects",             o(EXT_separate_shader_objects),             GLL,            2008 },
   { "GL_EXT_separate_specular_color",             o(dummy_true),                              GLL,            1997 },
   { "GL_EXT_shadow_funcs",                        o(ARB_shadow),                              GLL,            2002 },
   { "GL_EXT_stencil_two_side",                    o(EXT_stencil_two_side),                    GLL,            2001 },
   { "GL_EXT_stencil_wrap",                        o(dummy_true),                              GLL,            2002 },
   { "GL_EXT_subtexture",                          o(dummy_true),                              GLL,            1995 },
   { "GL_EXT_texture3D",                           o(EXT_texture3D),                           GLL,            1996 },
   { "GL_EXT_texture_array",                       o(EXT_texture_array),                       GL,             2006 },
   { "GL_EXT_texture_compression_dxt1",            o(ANGLE_texture_compression_dxt),           GL | ES1 | ES2, 2004 },
   { "GL_ANGLE_texture_compression_dxt3",          o(ANGLE_texture_compression_dxt),           GL | ES1 | ES2, 2011 },
   { "GL_ANGLE_texture_compression_dxt5",          o(ANGLE_texture_compression_dxt),           GL | ES1 | ES2, 2011 },
   { "GL_EXT_texture_compression_latc",            o(EXT_texture_compression_latc),            GL,             2006 },
   { "GL_EXT_texture_compression_rgtc",            o(ARB_texture_compression_rgtc),            GL,             2004 },
   { "GL_EXT_texture_compression_s3tc",            o(EXT_texture_compression_s3tc),            GL,             2000 },
   { "GL_EXT_texture_cube_map",                    o(ARB_texture_cube_map),                    GLL,            2001 },
   { "GL_EXT_texture_edge_clamp",                  o(dummy_true),                              GLL,            1997 },
   { "GL_EXT_texture_env_add",                     o(dummy_true),                              GLL,            1999 },
   { "GL_EXT_texture_env_combine",                 o(dummy_true),                              GLL,            2000 },
   { "GL_EXT_texture_env_dot3",                    o(EXT_texture_env_dot3),                    GLL,            2000 },
   { "GL_EXT_texture_filter_anisotropic",          o(EXT_texture_filter_anisotropic),          GL | ES1 | ES2, 1999 },
   { "GL_EXT_texture_format_BGRA8888",             o(dummy_true),                                   ES1 | ES2, 2005 },
   { "GL_EXT_texture_rg",                          o(ARB_texture_rg),                                     ES2, 2011 },
   { "GL_EXT_read_format_bgra",                    o(dummy_true),                                   ES1 | ES2, 2009 },
   { "GL_EXT_texture_integer",                     o(EXT_texture_integer),                     GL,             2006 },
   { "GL_EXT_texture_lod_bias",                    o(dummy_true),                              GLL | ES1,      1999 },
   { "GL_EXT_texture_mirror_clamp",                o(EXT_texture_mirror_clamp),                GL,             2004 },
   { "GL_EXT_texture_object",                      o(dummy_true),                              GLL,            1995 },
   { "GL_EXT_texture",                             o(dummy_true),                              GLL,            1996 },
   { "GL_EXT_texture_rectangle",                   o(NV_texture_rectangle),                    GLL,            2004 },
   { "GL_EXT_texture_shared_exponent",             o(EXT_texture_shared_exponent),             GL,             2004 },
   { "GL_EXT_texture_snorm",                       o(EXT_texture_snorm),                       GL,             2009 },
   { "GL_EXT_texture_sRGB",                        o(EXT_texture_sRGB),                        GL,             2004 },
   { "GL_EXT_texture_sRGB_decode",                 o(EXT_texture_sRGB_decode),                        GL,      2006 },
   { "GL_EXT_texture_swizzle",                     o(EXT_texture_swizzle),                     GL,             2008 },
   { "GL_EXT_texture_type_2_10_10_10_REV",         o(dummy_true),                                         ES2, 2008 },
   { "GL_EXT_timer_query",                         o(EXT_timer_query),                         GL,             2006 },
   { "GL_EXT_transform_feedback",                  o(EXT_transform_feedback),                  GL,             2011 },
   { "GL_EXT_unpack_subimage",                     o(dummy_true),                                         ES2, 2011 },
   { "GL_EXT_vertex_array_bgra",                   o(EXT_vertex_array_bgra),                   GL,             2008 },
   { "GL_EXT_vertex_array",                        o(dummy_true),                              GLL,            1995 },
   { "GL_EXT_color_buffer_float",                  o(dummy_true),                                         ES3, 2013 },
d207 12
a218 11
   { "GL_OES_blend_equation_separate",             o(EXT_blend_equation_separate),                  ES1,       2009 },
   { "GL_OES_blend_func_separate",                 o(EXT_blend_func_separate),                      ES1,       2009 },
   { "GL_OES_blend_subtract",                      o(dummy_true),                                   ES1,       2009 },
   { "GL_OES_byte_coordinates",                    o(dummy_true),                                   ES1,       2002 },
   { "GL_OES_compressed_ETC1_RGB8_texture",        o(OES_compressed_ETC1_RGB8_texture),             ES1 | ES2, 2005 },
   { "GL_OES_compressed_paletted_texture",         o(dummy_true),                                   ES1,       2003 },
   { "GL_OES_depth24",                             o(dummy_true),                                   ES1 | ES2, 2005 },
   { "GL_OES_depth32",                             o(dummy_false),                     DISABLE,                2005 },
   { "GL_OES_depth_texture",                       o(ARB_depth_texture),                                  ES2, 2006 },
   { "GL_OES_depth_texture_cube_map",              o(OES_depth_texture_cube_map),                         ES2, 2012 },
   { "GL_OES_draw_texture",                        o(OES_draw_texture),                             ES1,       2004 },
d220 26
a245 27
   { "GL_OES_EGL_image",                           o(OES_EGL_image),                           GL | ES1 | ES2, 2006 },
   { "GL_OES_EGL_image_external",                  o(OES_EGL_image_external),                       ES1 | ES2, 2010 },
   { "GL_OES_element_index_uint",                  o(dummy_true),                                   ES1 | ES2, 2005 },
   { "GL_OES_fbo_render_mipmap",                   o(dummy_true),                                   ES1 | ES2, 2005 },
   { "GL_OES_fixed_point",                         o(dummy_true),                                   ES1,       2002 },
   { "GL_OES_framebuffer_object",                  o(dummy_true),                                   ES1,       2005 },
   { "GL_OES_get_program_binary",                  o(dummy_true),                                         ES2, 2008 },
   { "GL_OES_mapbuffer",                           o(dummy_true),                                   ES1 | ES2, 2005 },
   { "GL_OES_matrix_get",                          o(dummy_true),                                   ES1,       2004 },
   { "GL_OES_packed_depth_stencil",                o(EXT_packed_depth_stencil),                     ES1 | ES2, 2007 },
   { "GL_OES_point_size_array",                    o(dummy_true),                                   ES1,       2004 },
   { "GL_OES_point_sprite",                        o(ARB_point_sprite),                             ES1,       2004 },
   { "GL_OES_query_matrix",                        o(dummy_true),                                   ES1,       2003 },
   { "GL_OES_read_format",                         o(dummy_true),                              GL | ES1,       2003 },
   { "GL_OES_rgb8_rgba8",                          o(dummy_true),                                   ES1 | ES2, 2005 },
   { "GL_OES_single_precision",                    o(dummy_true),                                   ES1,       2003 },
   { "GL_OES_standard_derivatives",                o(OES_standard_derivatives),                           ES2, 2005 },
   { "GL_OES_stencil1",                            o(dummy_false),                     DISABLE,                2005 },
   { "GL_OES_stencil4",                            o(dummy_false),                     DISABLE,                2005 },
   { "GL_OES_stencil8",                            o(dummy_true),                                   ES1 | ES2, 2005 },
   { "GL_OES_stencil_wrap",                        o(dummy_true),                                   ES1,       2002 },
   { "GL_OES_texture_3D",                          o(EXT_texture3D),                                      ES2, 2005 },
   { "GL_OES_texture_cube_map",                    o(ARB_texture_cube_map),                         ES1,       2007 },
   { "GL_OES_texture_env_crossbar",                o(ARB_texture_env_crossbar),                     ES1,       2005 },
   { "GL_OES_texture_mirrored_repeat",             o(dummy_true),                                   ES1,       2005 },
   { "GL_OES_texture_npot",                        o(ARB_texture_non_power_of_two),                 ES1 | ES2, 2005 },
   { "GL_OES_vertex_array_object",                 o(dummy_true),                                   ES1 | ES2, 2010 },
d248 43
a290 50
   { "GL_3DFX_texture_compression_FXT1",           o(TDFX_texture_compression_FXT1),           GL,             1999 },
   { "GL_AMD_conservative_depth",                  o(ARB_conservative_depth),                  GL,             2009 },
   { "GL_AMD_draw_buffers_blend",                  o(ARB_draw_buffers_blend),                  GL,             2009 },
   { "GL_AMD_seamless_cubemap_per_texture",        o(AMD_seamless_cubemap_per_texture),        GL,             2009 },
   { "GL_AMD_shader_stencil_export",               o(ARB_shader_stencil_export),               GL,             2009 },
   { "GL_AMD_vertex_shader_layer",                 o(AMD_vertex_shader_layer),                 GL,             2012 },
   { "GL_APPLE_object_purgeable",                  o(APPLE_object_purgeable),                  GL,             2006 },
   { "GL_APPLE_packed_pixels",                     o(dummy_true),                              GLL,            2002 },
   { "GL_APPLE_texture_max_level",                 o(dummy_true),                                   ES1 | ES2, 2009 },
   { "GL_APPLE_vertex_array_object",               o(dummy_true),                              GLL,            2002 },
   { "GL_ATI_blend_equation_separate",             o(EXT_blend_equation_separate),             GL,             2003 },
   { "GL_ATI_draw_buffers",                        o(dummy_true),                              GLL,            2002 },
   { "GL_ATI_envmap_bumpmap",                      o(ATI_envmap_bumpmap),                      GLL,            2001 },
   { "GL_ATI_fragment_shader",                     o(ATI_fragment_shader),                     GLL,            2001 },
   { "GL_ATI_separate_stencil",                    o(ATI_separate_stencil),                    GLL,            2006 },
   { "GL_ATI_texture_compression_3dc",             o(ATI_texture_compression_3dc),             GL,             2004 },
   { "GL_ATI_texture_env_combine3",                o(ATI_texture_env_combine3),                GLL,            2002 },
   { "GL_ATI_texture_float",                       o(ARB_texture_float),                       GL,             2002 },
   { "GL_ATI_texture_mirror_once",                 o(ATI_texture_mirror_once),                 GL,             2006 },
   { "GL_IBM_multimode_draw_arrays",               o(dummy_true),                              GL,             1998 },
   { "GL_IBM_rasterpos_clip",                      o(dummy_true),                              GLL,            1996 },
   { "GL_IBM_texture_mirrored_repeat",             o(dummy_true),                              GLL,            1998 },
   { "GL_INGR_blend_func_separate",                o(EXT_blend_func_separate),                 GLL,            1999 },
   { "GL_MESA_pack_invert",                        o(MESA_pack_invert),                        GL,             2002 },
   { "GL_MESA_texture_array",                      o(MESA_texture_array),                      GLL,            2007 },
   { "GL_MESA_texture_signed_rgba",                o(EXT_texture_snorm),                       GL,             2009 },
   { "GL_MESA_window_pos",                         o(dummy_true),                              GLL,            2000 },
   { "GL_MESA_ycbcr_texture",                      o(MESA_ycbcr_texture),                      GL,             2002 },
   { "GL_NV_blend_square",                         o(dummy_true),                              GLL,            1999 },
   { "GL_NV_conditional_render",                   o(NV_conditional_render),                   GL,             2008 },
   { "GL_NV_depth_clamp",                          o(ARB_depth_clamp),                         GL,             2001 },
   { "GL_NV_draw_buffers",                         o(dummy_true),                                         ES2, 2011 },
   { "GL_NV_fbo_color_attachments",                o(dummy_true),                                         ES2, 2010 },
   { "GL_NV_fog_distance",                         o(NV_fog_distance),                         GLL,            2001 },
   { "GL_NV_fragment_program_option",              o(NV_fragment_program_option),              GLL,            2005 },
   { "GL_NV_light_max_exponent",                   o(dummy_true),                              GLL,            1999 },
   { "GL_NV_packed_depth_stencil",                 o(EXT_packed_depth_stencil),                GL,             2000 },
   { "GL_NV_point_sprite",                         o(NV_point_sprite),                         GL,             2001 },
   { "GL_NV_primitive_restart",                    o(NV_primitive_restart),                    GLL,            2002 },
   { "GL_NV_read_buffer",                          o(dummy_true),                              ES2,            2011 },
   { "GL_NV_texgen_reflection",                    o(dummy_true),                              GLL,            1999 },
   { "GL_NV_texture_barrier",                      o(NV_texture_barrier),                      GL,             2009 },
   { "GL_NV_texture_env_combine4",                 o(NV_texture_env_combine4),                 GLL,            1999 },
   { "GL_NV_texture_rectangle",                    o(NV_texture_rectangle),                    GLL,            2000 },
   { "GL_S3_s3tc",                                 o(ANGLE_texture_compression_dxt),           GL,             1999 },
   { "GL_SGIS_generate_mipmap",                    o(dummy_true),                              GLL,            1997 },
   { "GL_SGIS_texture_border_clamp",               o(ARB_texture_border_clamp),                GLL,            1997 },
   { "GL_SGIS_texture_edge_clamp",                 o(dummy_true),                              GLL,            1997 },
   { "GL_SGIS_texture_lod",                        o(dummy_true),                              GLL,            1997 },
   { "GL_SUN_multi_draw_arrays",                   o(dummy_true),                              GLL,            1999 },
d292 1
a292 1
   { 0, 0, 0, 0 },
d322 49
d377 1
d380 1
a381 1
   ctx->Extensions.ARB_draw_instanced = GL_TRUE;
d384 1
d387 2
d390 2
d393 2
a395 1
#if 0
d401 2
d404 1
a404 1
   ctx->Extensions.ARB_occlusion_query2 = GL_TRUE;
d406 2
d409 4
d414 1
d420 2
a421 3
#ifdef TEXTURE_FLOAT_ENABLED
   ctx->Extensions.ARB_texture_float = GL_TRUE;
#endif
d424 2
a425 1
   ctx->Extensions.ARB_texture_compression_rgtc = GL_TRUE;
d427 2
d430 5
d436 3
d440 1
d442 1
d444 1
a444 1
   ctx->Extensions.ATI_texture_compression_3dc = GL_TRUE;
d451 1
d453 1
d456 5
d462 5
d468 2
d471 1
d474 4
d480 2
a481 1
   ctx->Extensions.EXT_texture_compression_latc = GL_TRUE;
a482 1
   ctx->Extensions.EXT_texture_filter_anisotropic = GL_TRUE;
d484 2
a485 1
   ctx->Extensions.EXT_texture_shared_exponent = GL_TRUE;
d487 1
a487 1
   ctx->Extensions.EXT_texture_sRGB_decode = GL_TRUE;
d489 1
d491 1
d493 1
d495 1
d498 1
d500 1
d504 9
d514 5
d520 5
a524 2
   ctx->Extensions.OES_standard_derivatives = GL_TRUE;
   ctx->Extensions.TDFX_texture_compression_FXT1 = GL_TRUE;
d526 2
a527 2
      ctx->Extensions.ANGLE_texture_compression_dxt = GL_TRUE;
      ctx->Extensions.EXT_texture_compression_s3tc = GL_TRUE;
d529 101
d632 17
d680 45
d726 26
a751 8
 * \brief Apply the \c MESA_EXTENSION_OVERRIDE environment variable.
 *
 * \c MESA_EXTENSION_OVERRIDE is a space-separated list of extensions to
 * enable or disable. The list is processed thus:
 *    - Enable recognized extension names that are prefixed with '+'.
 *    - Disable recognized extension names that are prefixed with '-'.
 *    - Enable recognized extension names that are not prefixed.
 *    - Collect unrecognized extension names in a new string.
d753 1
a753 2
 * \return Space-separated list of unrecognized extension names (which must
 *    be freed). Does not return \c NULL.
d758 32
a789 32
   const char *env_const = _mesa_getenv("MESA_EXTENSION_OVERRIDE");
   char *env;
   char *ext;
   char *extra_exts;
   int len;

   if (env_const == NULL) {
      /* Return the empty string rather than NULL. This simplifies the logic
       * of client functions. */
      return calloc(4, sizeof(char));
   }

   /* extra_exts: List of unrecognized extensions. */
   extra_exts = calloc(ALIGN(strlen(env_const) + 2, 4), sizeof(char));

   /* Copy env_const because strtok() is destructive. */
   env = strdup(env_const);
   for (ext = strtok(env, " "); ext != NULL; ext = strtok(NULL, " ")) {
      int enable;
      int recognized;
      switch (ext[0]) {
      case '+':
         enable = 1;
         ++ext;
         break;
      case '-':
         enable = 0;
         ++ext;
         break;
      default:
         enable = 1;
         break;
d791 3
a793 4
      recognized = set_extension(ctx, ext, enable);
      if (!recognized) {
         strcat(extra_exts, ext);
         strcat(extra_exts, " ");
d797 1
a797 8
   free(env);

   /* Remove trailing space. */
   len = strlen(extra_exts);
   if (len > 0 && extra_exts[len - 1] == ' ')
      extra_exts[len - 1] = '\0';

   return extra_exts;
d813 1
d821 2
a822 29
   ctx->Extensions.EXT_texture3D = GL_TRUE;
}


typedef unsigned short extension_index;


/**
 * Compare two entries of the extensions table.  Sorts first by year,
 * then by name.
 *
 * Arguments are indices into extension_table.
 */
static int
extension_compare(const void *p1, const void *p2)
{
   extension_index i1 = * (const extension_index *) p1;
   extension_index i2 = * (const extension_index *) p2;
   const struct extension *e1 = &extension_table[i1];
   const struct extension *e2 = &extension_table[i2];
   int res;

   res = (int)e1->year - (int)e2->year;

   if (res == 0) {
      res = strcmp(e1->name, e2->name);
   }

   return res;
a836 4
   /* Number of extensions */
   unsigned count;
   /* Indices of the extensions sorted by year */
   extension_index *extension_indices;
a840 15
   unsigned j;
   unsigned maxYear = ~0;
   unsigned api_set = (1 << ctx->API);
   if (_mesa_is_gles3(ctx))
      api_set |= ES3;

   /* Check if the MESA_EXTENSION_MAX_YEAR env var is set */
   {
      const char *env = getenv("MESA_EXTENSION_MAX_YEAR");
      if (env) {
         maxYear = atoi(env);
         _mesa_debug(ctx, "Note: limiting GL extensions to %u or earlier\n",
                     maxYear);
      }
   }
a842 1
   count = 0;
d844 1
a844 3
      if (base[i->offset] &&
          i->year <= maxYear &&
          (i->api_set & api_set)) {
a845 1
	 ++count;
d851 1
a851 1
   exts = calloc(ALIGN(length + 1, 4), sizeof(char));
d857 1
a857 13
   extension_indices = malloc(count * sizeof(extension_index));
   if (extension_indices == NULL) {
      free(exts);
      free(extra_extensions);
      return NULL;
   }

   /* Sort extensions in chronological order because certain old applications (e.g.,
    * Quake3 demo) store the extension list in a static size buffer so chronologically
    * order ensure that the extensions that such applications expect will fit into
    * that buffer.
    */
   j = 0;
d859 3
a861 4
      if (base[i->offset] &&
          i->year <= maxYear &&
          (i->api_set & api_set)) {
         extension_indices[j++] = i - extension_table;
a863 11
   assert(j == count);
   qsort(extension_indices, count, sizeof *extension_indices, extension_compare);

   /* Build the extension string.*/
   for (j = 0; j < count; ++j) {
      i = &extension_table[extension_indices[j]];
      assert(base[i->offset] && (i->api_set & api_set));
      strcat(exts, i->name);
      strcat(exts, " ");
   }
   free(extension_indices);
a879 3
   unsigned api_set = (1 << ctx->API);
   if (_mesa_is_gles3(ctx))
      api_set |= ES3;
d887 1
a887 1
      if (base[i->offset] && (i->api_set & api_set)) {
d903 3
a905 3
   unsigned api_set = (1 << ctx->API);
   if (_mesa_is_gles3(ctx))
      api_set |= ES3;
d910 4
a913 5
      if (base[i->offset] && (i->api_set & api_set)) {
         if (n == index)
            return (const GLubyte*) i->name;
         else
            ++n;
@


1.1.1.6
log
@Import Mesa 9.2.1
@
text
@d265 1
@


1.1.1.7
log
@Import Mesa 10.2.3
@
text
@a82 1
   { "GL_ARB_arrays_of_arrays",                    o(ARB_arrays_of_arrays),                    GL,             2012 },
a84 2
   { "GL_ARB_buffer_storage",                      o(ARB_buffer_storage),                      GL,             2013 },
   { "GL_ARB_clear_buffer_object",                 o(dummy_true),                              GL,             2012 },
a85 1
   { "GL_ARB_compute_shader",                      o(ARB_compute_shader),                      GL,             2012 },
a94 1
   { "GL_ARB_draw_indirect",                       o(ARB_draw_indirect),                       GLC,            2010 },
d105 1
a105 1
   { "GL_ARB_half_float_pixel",                    o(dummy_true),                              GL,             2003 },
d110 1
a110 1
   { "GL_ARB_map_buffer_alignment",                o(dummy_true),                              GL,             2011 },
a111 2
   { "GL_ARB_multi_bind",                          o(dummy_true),                              GL,             2013 },
   { "GL_ARB_multi_draw_indirect",                 o(ARB_draw_indirect),                       GLC,            2012 },
a120 1
   { "GL_ARB_sample_shading",                      o(ARB_sample_shading),                      GL,             2009 },
a122 2
   { "GL_ARB_separate_shader_objects",             o(dummy_true),                              GL,             2010 },
   { "GL_ARB_shader_atomic_counters",              o(ARB_shader_atomic_counters),              GL,             2011 },
a123 1
   { "GL_ARB_shader_image_load_store",             o(ARB_shader_image_load_store),             GL,             2011 },
a130 1
   { "GL_ARB_stencil_texturing",                   o(ARB_stencil_texturing),                   GL,             2012 },
a144 1
   { "GL_ARB_texture_gather",                      o(ARB_texture_gather),                      GL,             2009 },
a145 1
   { "GL_ARB_texture_mirror_clamp_to_edge",        o(ARB_texture_mirror_clamp_to_edge),        GL,             2013 },
a147 1
   { "GL_ARB_texture_query_levels",                o(ARB_texture_query_levels),                GL,             2012 },
a153 1
   { "GL_ARB_texture_view",                        o(ARB_texture_view),                        GL,             2012 },
a162 1
   { "GL_ARB_vertex_attrib_binding",               o(dummy_true),                              GL,             2012 },
a165 1
   { "GL_ARB_vertex_type_10f_11f_11f_rev",         o(ARB_vertex_type_10f_11f_11f_rev),         GL,             2013 },
a166 1
   { "GL_ARB_viewport_array",                      o(ARB_viewport_array),                      GLC,            2010 },
d184 1
a184 1
   { "GL_EXT_framebuffer_blit",                    o(dummy_true),                              GL,             2005 },
d193 1
a193 1
   { "GL_EXT_packed_depth_stencil",                o(dummy_true),                              GL,             2005 },
d202 1
a202 1
   { "GL_EXT_separate_shader_objects",             o(dummy_true),                                         ES2, 2013 },
a203 1
   { "GL_EXT_shader_integer_mix",                  o(EXT_shader_integer_mix),                  GL       | ES3, 2013 },
d265 1
a265 1
   { "GL_OES_packed_depth_stencil",                o(dummy_true),                                   ES1 | ES2, 2007 },
a276 1
   { "GL_OES_surfaceless_context",                 o(dummy_true),                                   ES1 | ES2, 2012 },
a283 3
   /* KHR extensions */
   { "GL_KHR_debug",                               o(dummy_true),                              GL,             2012 },

a287 1
   { "GL_AMD_performance_monitor",                 o(AMD_performance_monitor),                 GL,             2007 },
d290 1
a290 2
   { "GL_AMD_shader_trinary_minmax",               o(dummy_true),                              GL,             2012 },
   { "GL_AMD_vertex_shader_layer",                 o(AMD_vertex_shader_layer),                 GLC,            2012 },
a307 1
   { "GL_INTEL_performance_query",                 o(INTEL_performance_query),                       GL | ES2, 2013 },
d309 1
d321 1
a321 1
   { "GL_NV_packed_depth_stencil",                 o(dummy_true),                              GL,             2000 },
a328 1
   { "GL_NV_vdpau_interop",                        o(NV_vdpau_interop),                        GL,             2010 },
d382 5
d392 1
a401 1
   ctx->Extensions.ARB_texture_mirror_clamp_to_edge = GL_TRUE;
d421 2
d439 1
d466 1
a466 2
      _mesa_problem(ctx, "Trying to enable/disable extension after "
                    "glGetString(GL_EXTENSIONS): %s", name);
d665 4
a668 4
   /* Sort extensions in chronological order because certain old applications
    * (e.g., Quake3 demo) store the extension list in a static size buffer so
    * chronologically order ensure that the extensions that such applications
    * expect will fit into that buffer.
d679 1
a679 2
   qsort(extension_indices, count,
         sizeof *extension_indices, extension_compare);
@


1.1.1.8
log
@Import Mesa 10.4.3
@
text
@a39 5
struct gl_extensions _mesa_extension_override_enables;
struct gl_extensions _mesa_extension_override_disables;
static char *extra_extensions = NULL;
static char *cant_disable_extensions = NULL;

a87 2
   { "GL_ARB_clear_texture",                       o(ARB_clear_texture),                       GL,             2013 },
   { "GL_ARB_clip_control",                        o(ARB_clip_control),                        GL,             2014 },
a88 1
   { "GL_ARB_compressed_texture_pixel_storage",    o(dummy_true),                              GL,             2011 },
a89 1
   { "GL_ARB_conditional_render_inverted",         o(ARB_conditional_render_inverted),         GL,             2014 },
a90 1
   { "GL_ARB_copy_image",                          o(ARB_copy_image),                          GL,             2012 },
a95 1
   { "GL_ARB_derivative_control",                  o(ARB_derivative_control),                  GL,             2014 },
a101 1
   { "GL_ARB_explicit_uniform_location",           o(ARB_explicit_uniform_location),           GL,             2012 },
a102 1
   { "GL_ARB_fragment_layer_viewport",             o(ARB_fragment_layer_viewport),             GLC,            2012 },
d109 1
a109 1
   { "GL_ARB_gpu_shader5",                         o(ARB_gpu_shader5),                         GLC,            2010 },
a130 1
   { "GL_ARB_seamless_cubemap_per_texture",        o(AMD_seamless_cubemap_per_texture),        GL,             2013 },
a143 1
   { "GL_ARB_texture_barrier",                     o(NV_texture_barrier),                      GL,             2014 },
a148 1
   { "GL_ARB_texture_compression_bptc",            o(ARB_texture_compression_bptc),            GL,             2010 },
a306 1
   { "GL_KHR_context_flush_control",               o(dummy_true),                              GL       | ES2, 2014 },
a316 1
   { "GL_AMD_vertex_shader_viewport_index",        o(AMD_vertex_shader_viewport_index),        GLC,            2012 },
d323 1
a390 25
/**
 * Overrides extensions in \c ctx based on the values in
 * _mesa_extension_override_enables and _mesa_extension_override_disables.
 */
static void
override_extensions_in_context(struct gl_context *ctx)
{
   const struct extension *i;
   const GLboolean *enables =
      (GLboolean*) &_mesa_extension_override_enables;
   const GLboolean *disables =
      (GLboolean*) &_mesa_extension_override_disables;
   GLboolean *ctx_ext = (GLboolean*)&ctx->Extensions;

   for (i = extension_table; i->name != 0; ++i) {
      size_t offset = i->offset;
      assert(!enables[offset] || !disables[offset]);
      if (enables[offset]) {
         ctx_ext[offset] = 1;
      } else if (disables[offset]) {
         ctx_ext[offset] = 0;
      }
   }
}

a415 1
   ctx->Extensions.ARB_texture_compression_bptc = GL_TRUE;
d431 1
d476 1
a476 1
 * \return offset of extensions withint `ext' or 0 if extension is not known
d478 2
a479 2
static size_t
set_extension(struct gl_extensions *ext, const char *name, GLboolean state)
d483 7
d491 12
a502 2
   if (offset != 0 && (offset != o(dummy_true) || state != GL_FALSE)) {
      ((GLboolean *) ext)[offset] = state;
a503 2

   return offset;
a515 4
 * \c MESA_EXTENSION_OVERRIDE was previously parsed during
 * _mesa_one_time_init_extension_overrides. We just use the results of that
 * parsing in this function.
 *
d522 1
a522 41
   override_extensions_in_context(ctx);

   if (cant_disable_extensions != NULL) {
      _mesa_problem(ctx,
                    "Trying to disable permanently enabled extensions: %s",
	            cant_disable_extensions);
   }

   if (extra_extensions == NULL) {
      return calloc(1, sizeof(char));
   } else {
      _mesa_problem(ctx, "Trying to enable unknown extensions: %s",
                    extra_extensions);
      return strdup(extra_extensions);
   }
}


/**
 * \brief Free extra_extensions and cant_disable_extensions strings
 *
 * These strings are allocated early during the first context creation by
 * _mesa_one_time_init_extension_overrides.
 */
static void
free_unknown_extensions_strings(void)
{
   free(extra_extensions);
   free(cant_disable_extensions);
}


/**
 * \brief Initialize extension override tables.
 *
 * This should be called one time early during first context initialization.
 */
void
_mesa_one_time_init_extension_overrides(void)
{
   const char *env_const = getenv("MESA_EXTENSION_OVERRIDE");
d525 1
a526 6
   size_t offset;

   atexit(free_unknown_extensions_strings);

   memset(&_mesa_extension_override_enables, 0, sizeof(struct gl_extensions));
   memset(&_mesa_extension_override_disables, 0, sizeof(struct gl_extensions));
d529 3
a531 1
      return;
d535 1
a535 2
   extra_extensions = calloc(ALIGN(strlen(env_const) + 2, 4), sizeof(char));
   cant_disable_extensions = calloc(ALIGN(strlen(env_const) + 2, 4), sizeof(char));
a538 9

   if (env == NULL || extra_extensions == NULL ||
           cant_disable_extensions == NULL) {
       free(env);
       free(extra_extensions);
       free(cant_disable_extensions);
       return;
   }

d541 1
a541 1
      bool recognized;
d555 1
a555 9

      offset = set_extension(&_mesa_extension_override_enables, ext, enable);
      if (offset != 0 && (offset != o(dummy_true) || enable != GL_FALSE)) {
         ((GLboolean *) &_mesa_extension_override_disables)[offset] = !enable;
         recognized = true;
      } else {
         recognized = false;
      }

d557 2
a558 7
         if (enable) {
            strcat(extra_extensions, ext);
            strcat(extra_extensions, " ");
         } else if (offset == o(dummy_true)) {
            strcat(cant_disable_extensions, ext);
            strcat(cant_disable_extensions, " ");
         }
d564 6
a569 15
   /* Remove trailing space, and free if unused. */
   len = strlen(extra_extensions);
   if (len == 0) {
      free(extra_extensions);
      extra_extensions = NULL;
   } else if (extra_extensions[len - 1] == ' ') {
      extra_extensions[len - 1] = '\0';
   }
   len = strlen(cant_disable_extensions);
   if (len == 0) {
      free(cant_disable_extensions);
      cant_disable_extensions = NULL;
   } else if (cant_disable_extensions[len - 1] == ' ') {
      cant_disable_extensions[len - 1] = '\0';
   }
d580 1
a580 1
_mesa_init_extensions(struct gl_extensions *extensions)
d582 1
a582 1
   GLboolean *base = (GLboolean *) extensions;
d591 2
a592 2
   extensions->dummy_true = GL_TRUE;
   extensions->EXT_texture3D = GL_TRUE;
@


1.1.1.9
log
@Import Mesa 10.2.9
@
text
@d40 5
d93 2
d96 1
d98 1
d100 1
d106 1
d113 1
d115 1
d122 1
a122 1
   { "GL_ARB_gpu_shader5",                         o(ARB_gpu_shader5),                         GL,             2010 },
d144 1
d158 1
d164 1
d323 1
d334 1
a340 1
   { "GL_ATI_envmap_bumpmap",                      o(ATI_envmap_bumpmap),                      GLL,            2001 },
d408 25
d458 1
a473 1
   ctx->Extensions.ATI_envmap_bumpmap = GL_TRUE;
d518 1
a518 1
 * \return GL_TRUE for success, GL_FALSE if invalid extension name
d520 2
a521 2
static GLboolean
set_extension( struct gl_context *ctx, const char *name, GLboolean state )
d525 3
a527 5
   if (ctx->Extensions.String) {
      /* The string was already queried - can't change it now! */
      _mesa_problem(ctx, "Trying to enable/disable extension after "
                    "glGetString(GL_EXTENSIONS): %s", name);
      return GL_FALSE;
d530 1
a530 14
   offset = name_to_offset(name);
   if (offset == 0) {
      _mesa_problem(ctx, "Trying to enable/disable unknown extension %s",
	            name);
      return GL_FALSE;
   } else if (offset == o(dummy_true) && state == GL_FALSE) {
      _mesa_problem(ctx, "Trying to disable a permanently enabled extension: "
	                  "%s", name);
      return GL_FALSE;
   } else {
      GLboolean *base = (GLboolean *) &ctx->Extensions;
      base[offset] = state;
      return GL_TRUE;
   }
d543 4
d553 41
a593 1
   const char *env_const = _mesa_getenv("MESA_EXTENSION_OVERRIDE");
a595 1
   char *extra_exts;
d597 6
d605 1
a605 3
      /* Return the empty string rather than NULL. This simplifies the logic
       * of client functions. */
      return calloc(4, sizeof(char));
d609 2
a610 1
   extra_exts = calloc(ALIGN(strlen(env_const) + 2, 4), sizeof(char));
d614 9
d625 1
a625 1
      int recognized;
d639 9
a647 1
      recognized = set_extension(ctx, ext, enable);
d649 7
a655 2
         strcat(extra_exts, ext);
         strcat(extra_exts, " ");
d661 15
a675 6
   /* Remove trailing space. */
   len = strlen(extra_exts);
   if (len > 0 && extra_exts[len - 1] == ' ')
      extra_exts[len - 1] = '\0';

   return extra_exts;
d686 1
a686 1
_mesa_init_extensions( struct gl_context *ctx )
d688 1
a688 1
   GLboolean *base = (GLboolean *) &ctx->Extensions;
d697 2
a698 2
   ctx->Extensions.dummy_true = GL_TRUE;
   ctx->Extensions.EXT_texture3D = GL_TRUE;
@


