head	1.15;
access;
symbols
	OPENBSD_5_8:1.14.0.4
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	v10_2_9:1.1.1.9
	v10_4_3:1.1.1.8
	v10_2_7:1.1.1.7
	OPENBSD_5_6:1.12.0.2
	OPENBSD_5_6_BASE:1.12
	v10_2_3:1.1.1.7
	OPENBSD_5_5:1.11.0.2
	OPENBSD_5_5_BASE:1.11
	v9_2_5:1.1.1.6
	v9_2_3:1.1.1.6
	v9_2_2:1.1.1.6
	v9_2_1:1.1.1.5
	v9_2_0:1.1.1.5
	OPENBSD_5_4:1.9.0.4
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.2
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.8.0.4
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.7.0.6
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.2
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.4
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.5.0.4
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.2
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.4.0.2
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.3.0.2
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_3:1.2.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2015.12.23.05.17.52;	author jsg;	state dead;
branches;
next	1.14;
commitid	TnlogFl9nOv2eaRf;

1.14
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.13;
commitid	4ry2gvZGMXkCUD2n;

1.13
date	2015.01.25.14.41.21;	author jsg;	state Exp;
branches;
next	1.12;
commitid	mcxB0JvoI9gTDYXU;

1.12
date	2014.07.09.21.09.00;	author jsg;	state Exp;
branches;
next	1.11;
commitid	WPD6rgPryPkvXOr9;

1.11
date	2013.11.09.02.46.54;	author jsg;	state Exp;
branches;
next	1.10;

1.10
date	2013.09.05.14.06.21;	author jsg;	state Exp;
branches;
next	1.9;

1.9
date	2012.08.17.13.58.19;	author mpi;	state Exp;
branches;
next	1.8;

1.8
date	2011.10.23.13.37.42;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2010.06.22.20.04.22;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.05.22.20.06.30;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2009.05.17.20.26.41;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2008.11.02.14.58.21;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.05.31.16.36.48;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.02.12.21.09.27;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.50.00;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.50.00;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.56.35;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.31.03;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.46;	author matthieu;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.09.05.13.16.34;	author jsg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2013.11.09.02.35.43;	author jsg;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2014.07.09.20.35.00;	author jsg;	state Exp;
branches;
next	1.1.1.8;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.8
date	2015.01.25.14.12.36;	author jsg;	state Exp;
branches;
next	1.1.1.9;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.9
date	2015.02.20.22.49.43;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.15
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2008  Brian Paul   All Rights Reserved.
 * Copyright (C) 1999-2009  VMware, Inc.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */


/*
 * GL_EXT/ARB_framebuffer_object extensions
 *
 * Authors:
 *   Brian Paul
 */

#include <stdbool.h>

#include "buffers.h"
#include "context.h"
#include "enums.h"
#include "fbobject.h"
#include "formats.h"
#include "framebuffer.h"
#include "glformats.h"
#include "hash.h"
#include "macros.h"
#include "multisample.h"
#include "mtypes.h"
#include "renderbuffer.h"
#include "state.h"
#include "teximage.h"
#include "texobj.h"


/**
 * Notes:
 *
 * None of the GL_EXT_framebuffer_object functions are compiled into
 * display lists.
 */



/*
 * When glGenRender/FramebuffersEXT() is called we insert pointers to
 * these placeholder objects into the hash table.
 * Later, when the object ID is first bound, we replace the placeholder
 * with the real frame/renderbuffer.
 */
static struct gl_framebuffer DummyFramebuffer;
static struct gl_renderbuffer DummyRenderbuffer;

/* We bind this framebuffer when applications pass a NULL
 * drawable/surface in make current. */
static struct gl_framebuffer IncompleteFramebuffer;


static void
delete_dummy_renderbuffer(struct gl_context *ctx, struct gl_renderbuffer *rb)
{
   /* no op */
}

static void
delete_dummy_framebuffer(struct gl_framebuffer *fb)
{
   /* no op */
}


void
_mesa_init_fbobjects(struct gl_context *ctx)
{
   mtx_init(&DummyFramebuffer.Mutex, mtx_plain);
   mtx_init(&DummyRenderbuffer.Mutex, mtx_plain);
   mtx_init(&IncompleteFramebuffer.Mutex, mtx_plain);
   DummyFramebuffer.Delete = delete_dummy_framebuffer;
   DummyRenderbuffer.Delete = delete_dummy_renderbuffer;
   IncompleteFramebuffer.Delete = delete_dummy_framebuffer;
}

struct gl_framebuffer *
_mesa_get_incomplete_framebuffer(void)
{
   return &IncompleteFramebuffer;
}

/**
 * Helper routine for getting a gl_renderbuffer.
 */
struct gl_renderbuffer *
_mesa_lookup_renderbuffer(struct gl_context *ctx, GLuint id)
{
   struct gl_renderbuffer *rb;

   if (id == 0)
      return NULL;

   rb = (struct gl_renderbuffer *)
      _mesa_HashLookup(ctx->Shared->RenderBuffers, id);
   return rb;
}


/**
 * Helper routine for getting a gl_framebuffer.
 */
struct gl_framebuffer *
_mesa_lookup_framebuffer(struct gl_context *ctx, GLuint id)
{
   struct gl_framebuffer *fb;

   if (id == 0)
      return NULL;

   fb = (struct gl_framebuffer *)
      _mesa_HashLookup(ctx->Shared->FrameBuffers, id);
   return fb;
}


/**
 * Mark the given framebuffer as invalid.  This will force the
 * test for framebuffer completeness to be done before the framebuffer
 * is used.
 */
static void
invalidate_framebuffer(struct gl_framebuffer *fb)
{
   fb->_Status = 0; /* "indeterminate" */
}


/**
 * Return the gl_framebuffer object which corresponds to the given
 * framebuffer target, such as GL_DRAW_FRAMEBUFFER.
 * Check support for GL_EXT_framebuffer_blit to determine if certain
 * targets are legal.
 * \return gl_framebuffer pointer or NULL if target is illegal
 */
static struct gl_framebuffer *
get_framebuffer_target(struct gl_context *ctx, GLenum target)
{
   bool have_fb_blit = _mesa_is_gles3(ctx) || _mesa_is_desktop_gl(ctx);
   switch (target) {
   case GL_DRAW_FRAMEBUFFER:
      return have_fb_blit ? ctx->DrawBuffer : NULL;
   case GL_READ_FRAMEBUFFER:
      return have_fb_blit ? ctx->ReadBuffer : NULL;
   case GL_FRAMEBUFFER_EXT:
      return ctx->DrawBuffer;
   default:
      return NULL;
   }
}


/**
 * Given a GL_*_ATTACHMENTn token, return a pointer to the corresponding
 * gl_renderbuffer_attachment object.
 * This function is only used for user-created FB objects, not the
 * default / window-system FB object.
 * If \p attachment is GL_DEPTH_STENCIL_ATTACHMENT, return a pointer to
 * the depth buffer attachment point.
 */
static struct gl_renderbuffer_attachment *
get_attachment(struct gl_context *ctx, struct gl_framebuffer *fb,
               GLenum attachment)
{
   GLuint i;

   assert(_mesa_is_user_fbo(fb));

   switch (attachment) {
   case GL_COLOR_ATTACHMENT0_EXT:
   case GL_COLOR_ATTACHMENT1_EXT:
   case GL_COLOR_ATTACHMENT2_EXT:
   case GL_COLOR_ATTACHMENT3_EXT:
   case GL_COLOR_ATTACHMENT4_EXT:
   case GL_COLOR_ATTACHMENT5_EXT:
   case GL_COLOR_ATTACHMENT6_EXT:
   case GL_COLOR_ATTACHMENT7_EXT:
   case GL_COLOR_ATTACHMENT8_EXT:
   case GL_COLOR_ATTACHMENT9_EXT:
   case GL_COLOR_ATTACHMENT10_EXT:
   case GL_COLOR_ATTACHMENT11_EXT:
   case GL_COLOR_ATTACHMENT12_EXT:
   case GL_COLOR_ATTACHMENT13_EXT:
   case GL_COLOR_ATTACHMENT14_EXT:
   case GL_COLOR_ATTACHMENT15_EXT:
      /* Only OpenGL ES 1.x forbids color attachments other than
       * GL_COLOR_ATTACHMENT0.  For all other APIs the limit set by the
       * hardware is used.
       */
      i = attachment - GL_COLOR_ATTACHMENT0_EXT;
      if (i >= ctx->Const.MaxColorAttachments
	  || (i > 0 && ctx->API == API_OPENGLES)) {
	 return NULL;
      }
      return &fb->Attachment[BUFFER_COLOR0 + i];
   case GL_DEPTH_STENCIL_ATTACHMENT:
      if (!_mesa_is_desktop_gl(ctx) && !_mesa_is_gles3(ctx))
	 return NULL;
      /* fall-through */
   case GL_DEPTH_ATTACHMENT_EXT:
      return &fb->Attachment[BUFFER_DEPTH];
   case GL_STENCIL_ATTACHMENT_EXT:
      return &fb->Attachment[BUFFER_STENCIL];
   default:
      return NULL;
   }
}


/**
 * As above, but only used for getting attachments of the default /
 * window-system framebuffer (not user-created framebuffer objects).
 */
static struct gl_renderbuffer_attachment *
_mesa_get_fb0_attachment(struct gl_context *ctx, struct gl_framebuffer *fb,
                         GLenum attachment)
{
   assert(_mesa_is_winsys_fbo(fb));

   if (_mesa_is_gles3(ctx)) {
      assert(attachment == GL_BACK ||
             attachment == GL_DEPTH ||
             attachment == GL_STENCIL);
      switch (attachment) {
      case GL_BACK:
         /* Since there is no stereo rendering in ES 3.0, only return the
          * LEFT bits.
          */
         if (ctx->DrawBuffer->Visual.doubleBufferMode)
            return &fb->Attachment[BUFFER_BACK_LEFT];
         return &fb->Attachment[BUFFER_FRONT_LEFT];
      case GL_DEPTH:
      return &fb->Attachment[BUFFER_DEPTH];
      case GL_STENCIL:
         return &fb->Attachment[BUFFER_STENCIL];
      }
   }

   switch (attachment) {
   case GL_FRONT_LEFT:
      return &fb->Attachment[BUFFER_FRONT_LEFT];
   case GL_FRONT_RIGHT:
      return &fb->Attachment[BUFFER_FRONT_RIGHT];
   case GL_BACK_LEFT:
      return &fb->Attachment[BUFFER_BACK_LEFT];
   case GL_BACK_RIGHT:
      return &fb->Attachment[BUFFER_BACK_RIGHT];
   case GL_AUX0:
      if (fb->Visual.numAuxBuffers == 1) {
         return &fb->Attachment[BUFFER_AUX0];
      }
      return NULL;

   /* Page 336 (page 352 of the PDF) of the OpenGL 3.0 spec says:
    *
    *     "If the default framebuffer is bound to target, then attachment must
    *     be one of FRONT LEFT, FRONT RIGHT, BACK LEFT, BACK RIGHT, or AUXi,
    *     identifying a color buffer; DEPTH, identifying the depth buffer; or
    *     STENCIL, identifying the stencil buffer."
    *
    * Revision #34 of the ARB_framebuffer_object spec has essentially the same
    * language.  However, revision #33 of the ARB_framebuffer_object spec
    * says:
    *
    *     "If the default framebuffer is bound to <target>, then <attachment>
    *     must be one of FRONT_LEFT, FRONT_RIGHT, BACK_LEFT, BACK_RIGHT, AUXi,
    *     DEPTH_BUFFER, or STENCIL_BUFFER, identifying a color buffer, the
    *     depth buffer, or the stencil buffer, and <pname> may be
    *     FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE or
    *     FRAMEBUFFER_ATTACHMENT_OBJECT_NAME."
    *
    * The enum values for DEPTH_BUFFER and STENCIL_BUFFER have been removed
    * from glext.h, so shipping apps should not use those values.
    *
    * Note that neither EXT_framebuffer_object nor OES_framebuffer_object
    * support queries of the window system FBO.
    */
   case GL_DEPTH:
      return &fb->Attachment[BUFFER_DEPTH];
   case GL_STENCIL:
      return &fb->Attachment[BUFFER_STENCIL];
   default:
      return NULL;
   }
}



/**
 * Remove any texture or renderbuffer attached to the given attachment
 * point.  Update reference counts, etc.
 */
static void
remove_attachment(struct gl_context *ctx,
                  struct gl_renderbuffer_attachment *att)
{
   struct gl_renderbuffer *rb = att->Renderbuffer;

   /* tell driver that we're done rendering to this texture. */
   if (rb && rb->NeedsFinishRenderTexture)
      ctx->Driver.FinishRenderTexture(ctx, rb);

   if (att->Type == GL_TEXTURE) {
      ASSERT(att->Texture);
      _mesa_reference_texobj(&att->Texture, NULL); /* unbind */
      ASSERT(!att->Texture);
   }
   if (att->Type == GL_TEXTURE || att->Type == GL_RENDERBUFFER_EXT) {
      ASSERT(!att->Texture);
      _mesa_reference_renderbuffer(&att->Renderbuffer, NULL); /* unbind */
      ASSERT(!att->Renderbuffer);
   }
   att->Type = GL_NONE;
   att->Complete = GL_TRUE;
}

/**
 * Verify a couple error conditions that will lead to an incomplete FBO and
 * may cause problems for the driver's RenderTexture path.
 */
static bool
driver_RenderTexture_is_safe(const struct gl_renderbuffer_attachment *att)
{
   const struct gl_texture_image *const texImage =
      att->Texture->Image[att->CubeMapFace][att->TextureLevel];

   if (texImage->Width == 0 || texImage->Height == 0 || texImage->Depth == 0)
      return false;

   if ((texImage->TexObject->Target == GL_TEXTURE_1D_ARRAY
        && att->Zoffset >= texImage->Height)
       || (texImage->TexObject->Target != GL_TEXTURE_1D_ARRAY
           && att->Zoffset >= texImage->Depth))
      return false;

   return true;
}

/**
 * Create a renderbuffer which will be set up by the driver to wrap the
 * texture image slice.
 *
 * By using a gl_renderbuffer (like user-allocated renderbuffers), drivers get
 * to share most of their framebuffer rendering code between winsys,
 * renderbuffer, and texture attachments.
 *
 * The allocated renderbuffer uses a non-zero Name so that drivers can check
 * it for determining vertical orientation, but we use ~0 to make it fairly
 * unambiguous with actual user (non-texture) renderbuffers.
 */
void
_mesa_update_texture_renderbuffer(struct gl_context *ctx,
                                  struct gl_framebuffer *fb,
                                  struct gl_renderbuffer_attachment *att)
{
   struct gl_texture_image *texImage;
   struct gl_renderbuffer *rb;

   texImage = att->Texture->Image[att->CubeMapFace][att->TextureLevel];

   rb = att->Renderbuffer;
   if (!rb) {
      rb = ctx->Driver.NewRenderbuffer(ctx, ~0);
      if (!rb) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glFramebufferTexture()");
         return;
      }
      _mesa_reference_renderbuffer(&att->Renderbuffer, rb);

      /* This can't get called on a texture renderbuffer, so set it to NULL
       * for clarity compared to user renderbuffers.
       */
      rb->AllocStorage = NULL;

      rb->NeedsFinishRenderTexture = ctx->Driver.FinishRenderTexture != NULL;
   }

   if (!texImage)
      return;

   rb->_BaseFormat = texImage->_BaseFormat;
   rb->Format = texImage->TexFormat;
   rb->InternalFormat = texImage->InternalFormat;
   rb->Width = texImage->Width2;
   rb->Height = texImage->Height2;
   rb->Depth = texImage->Depth2;
   rb->NumSamples = texImage->NumSamples;
   rb->TexImage = texImage;

   if (driver_RenderTexture_is_safe(att))
      ctx->Driver.RenderTexture(ctx, fb, att);
}

/**
 * Bind a texture object to an attachment point.
 * The previous binding, if any, will be removed first.
 */
static void
set_texture_attachment(struct gl_context *ctx,
                       struct gl_framebuffer *fb,
                       struct gl_renderbuffer_attachment *att,
                       struct gl_texture_object *texObj,
                       GLenum texTarget, GLuint level, GLuint zoffset,
                       GLboolean layered)
{
   struct gl_renderbuffer *rb = att->Renderbuffer;

   if (rb && rb->NeedsFinishRenderTexture)
      ctx->Driver.FinishRenderTexture(ctx, rb);

   if (att->Texture == texObj) {
      /* re-attaching same texture */
      ASSERT(att->Type == GL_TEXTURE);
   }
   else {
      /* new attachment */
      remove_attachment(ctx, att);
      att->Type = GL_TEXTURE;
      assert(!att->Texture);
      _mesa_reference_texobj(&att->Texture, texObj);
   }
   invalidate_framebuffer(fb);

   /* always update these fields */
   att->TextureLevel = level;
   att->CubeMapFace = _mesa_tex_target_to_face(texTarget);
   att->Zoffset = zoffset;
   att->Layered = layered;
   att->Complete = GL_FALSE;

   _mesa_update_texture_renderbuffer(ctx, fb, att);
}


/**
 * Bind a renderbuffer to an attachment point.
 * The previous binding, if any, will be removed first.
 */
static void
set_renderbuffer_attachment(struct gl_context *ctx,
                            struct gl_renderbuffer_attachment *att,
                            struct gl_renderbuffer *rb)
{
   /* XXX check if re-doing same attachment, exit early */
   remove_attachment(ctx, att);
   att->Type = GL_RENDERBUFFER_EXT;
   att->Texture = NULL; /* just to be safe */
   att->Complete = GL_FALSE;
   _mesa_reference_renderbuffer(&att->Renderbuffer, rb);
}


/**
 * Fallback for ctx->Driver.FramebufferRenderbuffer()
 * Attach a renderbuffer object to a framebuffer object.
 */
void
_mesa_framebuffer_renderbuffer(struct gl_context *ctx,
                               struct gl_framebuffer *fb,
                               GLenum attachment, struct gl_renderbuffer *rb)
{
   struct gl_renderbuffer_attachment *att;

   mtx_lock(&fb->Mutex);

   att = get_attachment(ctx, fb, attachment);
   ASSERT(att);
   if (rb) {
      set_renderbuffer_attachment(ctx, att, rb);
      if (attachment == GL_DEPTH_STENCIL_ATTACHMENT) {
         /* do stencil attachment here (depth already done above) */
         att = get_attachment(ctx, fb, GL_STENCIL_ATTACHMENT_EXT);
         assert(att);
         set_renderbuffer_attachment(ctx, att, rb);
      }
      rb->AttachedAnytime = GL_TRUE;
   }
   else {
      remove_attachment(ctx, att);
      if (attachment == GL_DEPTH_STENCIL_ATTACHMENT) {
         /* detach stencil (depth was detached above) */
         att = get_attachment(ctx, fb, GL_STENCIL_ATTACHMENT_EXT);
         assert(att);
         remove_attachment(ctx, att);
      }
   }

   invalidate_framebuffer(fb);

   mtx_unlock(&fb->Mutex);
}


/**
 * Fallback for ctx->Driver.ValidateFramebuffer()
 * Check if the renderbuffer's formats are supported by the software
 * renderer.
 * Drivers should probably override this.
 */
void
_mesa_validate_framebuffer(struct gl_context *ctx, struct gl_framebuffer *fb)
{
   gl_buffer_index buf;
   for (buf = 0; buf < BUFFER_COUNT; buf++) {
      const struct gl_renderbuffer *rb = fb->Attachment[buf].Renderbuffer;
      if (rb) {
         switch (rb->_BaseFormat) {
         case GL_ALPHA:
         case GL_LUMINANCE_ALPHA:
         case GL_LUMINANCE:
         case GL_INTENSITY:
         case GL_RED:
         case GL_RG:
            fb->_Status = GL_FRAMEBUFFER_UNSUPPORTED;
            return;

         default:
            switch (rb->Format) {
            /* XXX This list is likely incomplete. */
            case MESA_FORMAT_R9G9B9E5_FLOAT:
               fb->_Status = GL_FRAMEBUFFER_UNSUPPORTED;
               return;
            default:;
               /* render buffer format is supported by software rendering */
            }
         }
      }
   }
}


/**
 * Return true if the framebuffer has a combined depth/stencil
 * renderbuffer attached.
 */
GLboolean
_mesa_has_depthstencil_combined(const struct gl_framebuffer *fb)
{
   const struct gl_renderbuffer_attachment *depth =
         &fb->Attachment[BUFFER_DEPTH];
   const struct gl_renderbuffer_attachment *stencil =
         &fb->Attachment[BUFFER_STENCIL];

   if (depth->Type == stencil->Type) {
      if (depth->Type == GL_RENDERBUFFER_EXT &&
          depth->Renderbuffer == stencil->Renderbuffer)
         return GL_TRUE;

      if (depth->Type == GL_TEXTURE &&
          depth->Texture == stencil->Texture)
         return GL_TRUE;
   }

   return GL_FALSE;
}


/**
 * For debug only.
 */
static void
att_incomplete(const char *msg)
{
   if (MESA_DEBUG_FLAGS & DEBUG_INCOMPLETE_FBO) {
      _mesa_debug(NULL, "attachment incomplete: %s\n", msg);
   }
}


/**
 * For debug only.
 */
static void
fbo_incomplete(struct gl_context *ctx, const char *msg, int index)
{
   static GLuint msg_id;

   _mesa_gl_debug(ctx, &msg_id,
                  MESA_DEBUG_TYPE_OTHER,
                  MESA_DEBUG_SEVERITY_MEDIUM,
                  "FBO incomplete: %s [%d]\n", msg, index);

   if (MESA_DEBUG_FLAGS & DEBUG_INCOMPLETE_FBO) {
      _mesa_debug(NULL, "FBO Incomplete: %s [%d]\n", msg, index);
   }
}


/**
 * Is the given base format a legal format for a color renderbuffer?
 */
GLboolean
_mesa_is_legal_color_format(const struct gl_context *ctx, GLenum baseFormat)
{
   switch (baseFormat) {
   case GL_RGB:
   case GL_RGBA:
      return GL_TRUE;
   case GL_LUMINANCE:
   case GL_LUMINANCE_ALPHA:
   case GL_INTENSITY:
   case GL_ALPHA:
      return ctx->API == API_OPENGL_COMPAT &&
             ctx->Extensions.ARB_framebuffer_object;
   case GL_RED:
   case GL_RG:
      return ctx->Extensions.ARB_texture_rg;
   default:
      return GL_FALSE;
   }
}


/**
 * Is the given base format a legal format for a color renderbuffer?
 */
static GLboolean
is_format_color_renderable(const struct gl_context *ctx, mesa_format format,
                           GLenum internalFormat)
{
   const GLenum baseFormat =
      _mesa_get_format_base_format(format);
   GLboolean valid;

   valid = _mesa_is_legal_color_format(ctx, baseFormat);
   if (!valid || _mesa_is_desktop_gl(ctx)) {
      return valid;
   }

   /* Reject additional cases for GLES */
   switch (internalFormat) {
   case GL_RGBA8_SNORM:
   case GL_RGB32F:
   case GL_RGB32I:
   case GL_RGB32UI:
   case GL_RGB16F:
   case GL_RGB16I:
   case GL_RGB16UI:
   case GL_RGB8_SNORM:
   case GL_RGB8I:
   case GL_RGB8UI:
   case GL_SRGB8:
   case GL_RGB9_E5:
   case GL_RG8_SNORM:
   case GL_R8_SNORM:
      return GL_FALSE;
   default:
      break;
   }

   if (format == MESA_FORMAT_B10G10R10A2_UNORM &&
       internalFormat != GL_RGB10_A2) {
      return GL_FALSE;
   }

   return GL_TRUE;
}


/**
 * Is the given base format a legal format for a depth/stencil renderbuffer?
 */
static GLboolean
is_legal_depth_format(const struct gl_context *ctx, GLenum baseFormat)
{
   switch (baseFormat) {
   case GL_DEPTH_COMPONENT:
   case GL_DEPTH_STENCIL_EXT:
      return GL_TRUE;
   default:
      return GL_FALSE;
   }
}


/**
 * Test if an attachment point is complete and update its Complete field.
 * \param format if GL_COLOR, this is a color attachment point,
 *               if GL_DEPTH, this is a depth component attachment point,
 *               if GL_STENCIL, this is a stencil component attachment point.
 */
static void
test_attachment_completeness(const struct gl_context *ctx, GLenum format,
                             struct gl_renderbuffer_attachment *att)
{
   assert(format == GL_COLOR || format == GL_DEPTH || format == GL_STENCIL);

   /* assume complete */
   att->Complete = GL_TRUE;

   /* Look for reasons why the attachment might be incomplete */
   if (att->Type == GL_TEXTURE) {
      const struct gl_texture_object *texObj = att->Texture;
      struct gl_texture_image *texImage;
      GLenum baseFormat;

      if (!texObj) {
         att_incomplete("no texobj");
         att->Complete = GL_FALSE;
         return;
      }

      texImage = texObj->Image[att->CubeMapFace][att->TextureLevel];
      if (!texImage) {
         att_incomplete("no teximage");
         att->Complete = GL_FALSE;
         return;
      }
      if (texImage->Width < 1 || texImage->Height < 1) {
         att_incomplete("teximage width/height=0");
         att->Complete = GL_FALSE;
         return;
      }

      switch (texObj->Target) {
      case GL_TEXTURE_3D:
         if (att->Zoffset >= texImage->Depth) {
            att_incomplete("bad z offset");
            att->Complete = GL_FALSE;
            return;
         }
         break;
      case GL_TEXTURE_1D_ARRAY:
         if (att->Zoffset >= texImage->Height) {
            att_incomplete("bad 1D-array layer");
            att->Complete = GL_FALSE;
            return;
         }
         break;
      case GL_TEXTURE_2D_ARRAY:
         if (att->Zoffset >= texImage->Depth) {
            att_incomplete("bad 2D-array layer");
            att->Complete = GL_FALSE;
            return;
         }
         break;
      case GL_TEXTURE_CUBE_MAP_ARRAY:
         if (att->Zoffset >= texImage->Depth) {
            att_incomplete("bad cube-array layer");
            att->Complete = GL_FALSE;
            return;
         }
         break;
      }

      baseFormat = _mesa_get_format_base_format(texImage->TexFormat);

      if (format == GL_COLOR) {
         if (!_mesa_is_legal_color_format(ctx, baseFormat)) {
            att_incomplete("bad format");
            att->Complete = GL_FALSE;
            return;
         }
         if (_mesa_is_format_compressed(texImage->TexFormat)) {
            att_incomplete("compressed internalformat");
            att->Complete = GL_FALSE;
            return;
         }
      }
      else if (format == GL_DEPTH) {
         if (baseFormat == GL_DEPTH_COMPONENT) {
            /* OK */
         }
         else if (ctx->Extensions.ARB_depth_texture &&
                  baseFormat == GL_DEPTH_STENCIL) {
            /* OK */
         }
         else {
            att->Complete = GL_FALSE;
            att_incomplete("bad depth format");
            return;
         }
      }
      else {
         ASSERT(format == GL_STENCIL);
         if (ctx->Extensions.ARB_depth_texture &&
             baseFormat == GL_DEPTH_STENCIL) {
            /* OK */
         }
         else {
            /* no such thing as stencil-only textures */
            att_incomplete("illegal stencil texture");
            att->Complete = GL_FALSE;
            return;
         }
      }
   }
   else if (att->Type == GL_RENDERBUFFER_EXT) {
      const GLenum baseFormat =
         _mesa_get_format_base_format(att->Renderbuffer->Format);

      ASSERT(att->Renderbuffer);
      if (!att->Renderbuffer->InternalFormat ||
          att->Renderbuffer->Width < 1 ||
          att->Renderbuffer->Height < 1) {
         att_incomplete("0x0 renderbuffer");
         att->Complete = GL_FALSE;
         return;
      }
      if (format == GL_COLOR) {
         if (!_mesa_is_legal_color_format(ctx, baseFormat)) {
            att_incomplete("bad renderbuffer color format");
            att->Complete = GL_FALSE;
            return;
         }
      }
      else if (format == GL_DEPTH) {
         if (baseFormat == GL_DEPTH_COMPONENT) {
            /* OK */
         }
         else if (baseFormat == GL_DEPTH_STENCIL) {
            /* OK */
         }
         else {
            att_incomplete("bad renderbuffer depth format");
            att->Complete = GL_FALSE;
            return;
         }
      }
      else {
         assert(format == GL_STENCIL);
         if (baseFormat == GL_STENCIL_INDEX ||
             baseFormat == GL_DEPTH_STENCIL) {
            /* OK */
         }
         else {
            att->Complete = GL_FALSE;
            att_incomplete("bad renderbuffer stencil format");
            return;
         }
      }
   }
   else {
      ASSERT(att->Type == GL_NONE);
      /* complete */
      return;
   }
}


/**
 * Test if the given framebuffer object is complete and update its
 * Status field with the results.
 * Calls the ctx->Driver.ValidateFramebuffer() function to allow the
 * driver to make hardware-specific validation/completeness checks.
 * Also update the framebuffer's Width and Height fields if the
 * framebuffer is complete.
 */
void
_mesa_test_framebuffer_completeness(struct gl_context *ctx,
                                    struct gl_framebuffer *fb)
{
   GLuint numImages;
   GLenum intFormat = GL_NONE; /* color buffers' internal format */
   GLuint minWidth = ~0, minHeight = ~0, maxWidth = 0, maxHeight = 0;
   GLint numSamples = -1;
   GLint fixedSampleLocations = -1;
   GLint i;
   GLuint j;
   /* Covers max_layer_count, is_layered, and layer_tex_target */
   bool layer_info_valid = false;
   GLuint max_layer_count = 0, att_layer_count;
   bool is_layered = false;
   GLenum layer_tex_target = 0;

   assert(_mesa_is_user_fbo(fb));

   /* we're changing framebuffer fields here */
   FLUSH_VERTICES(ctx, _NEW_BUFFERS);

   numImages = 0;
   fb->Width = 0;
   fb->Height = 0;
   fb->_AllColorBuffersFixedPoint = GL_TRUE;
   fb->_HasSNormOrFloatColorBuffer = GL_FALSE;

   /* Start at -2 to more easily loop over all attachment points.
    *  -2: depth buffer
    *  -1: stencil buffer
    * >=0: color buffer
    */
   for (i = -2; i < (GLint) ctx->Const.MaxColorAttachments; i++) {
      struct gl_renderbuffer_attachment *att;
      GLenum f;
      mesa_format attFormat;
      GLenum att_tex_target = GL_NONE;

      /*
       * XXX for ARB_fbo, only check color buffers that are named by
       * GL_READ_BUFFER and GL_DRAW_BUFFERi.
       */

      /* check for attachment completeness
       */
      if (i == -2) {
         att = &fb->Attachment[BUFFER_DEPTH];
         test_attachment_completeness(ctx, GL_DEPTH, att);
         if (!att->Complete) {
            fb->_Status = GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT_EXT;
            fbo_incomplete(ctx, "depth attachment incomplete", -1);
            return;
         }
      }
      else if (i == -1) {
         att = &fb->Attachment[BUFFER_STENCIL];
         test_attachment_completeness(ctx, GL_STENCIL, att);
         if (!att->Complete) {
            fb->_Status = GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT_EXT;
            fbo_incomplete(ctx, "stencil attachment incomplete", -1);
            return;
         }
      }
      else {
         att = &fb->Attachment[BUFFER_COLOR0 + i];
         test_attachment_completeness(ctx, GL_COLOR, att);
         if (!att->Complete) {
            fb->_Status = GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT_EXT;
            fbo_incomplete(ctx, "color attachment incomplete", i);
            return;
         }
      }

      /* get width, height, format of the renderbuffer/texture
       */
      if (att->Type == GL_TEXTURE) {
         const struct gl_texture_image *texImg = att->Renderbuffer->TexImage;
         att_tex_target = att->Texture->Target;
         minWidth = MIN2(minWidth, texImg->Width);
         maxWidth = MAX2(maxWidth, texImg->Width);
         minHeight = MIN2(minHeight, texImg->Height);
         maxHeight = MAX2(maxHeight, texImg->Height);
         f = texImg->_BaseFormat;
         attFormat = texImg->TexFormat;
         numImages++;

         if (!is_format_color_renderable(ctx, attFormat,
                                         texImg->InternalFormat) &&
             !is_legal_depth_format(ctx, f)) {
            fb->_Status = GL_FRAMEBUFFER_INCOMPLETE_FORMATS_EXT;
            fbo_incomplete(ctx, "texture attachment incomplete", -1);
            return;
         }

         if (numSamples < 0)
            numSamples = texImg->NumSamples;
         else if (numSamples != texImg->NumSamples) {
            fb->_Status = GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE;
            fbo_incomplete(ctx, "inconsistent sample count", -1);
            return;
         }

         if (fixedSampleLocations < 0)
            fixedSampleLocations = texImg->FixedSampleLocations;
         else if (fixedSampleLocations != texImg->FixedSampleLocations) {
            fb->_Status = GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE;
            fbo_incomplete(ctx, "inconsistent fixed sample locations", -1);
            return;
         }
      }
      else if (att->Type == GL_RENDERBUFFER_EXT) {
         minWidth = MIN2(minWidth, att->Renderbuffer->Width);
         maxWidth = MAX2(minWidth, att->Renderbuffer->Width);
         minHeight = MIN2(minHeight, att->Renderbuffer->Height);
         maxHeight = MAX2(minHeight, att->Renderbuffer->Height);
         f = att->Renderbuffer->InternalFormat;
         attFormat = att->Renderbuffer->Format;
         numImages++;

         if (numSamples < 0)
            numSamples = att->Renderbuffer->NumSamples;
         else if (numSamples != att->Renderbuffer->NumSamples) {
            fb->_Status = GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE;
            fbo_incomplete(ctx, "inconsistent sample count", -1);
            return;
         }

         /* RENDERBUFFER has fixedSampleLocations implicitly true */
         if (fixedSampleLocations < 0)
            fixedSampleLocations = GL_TRUE;
         else if (fixedSampleLocations != GL_TRUE) {
            fb->_Status = GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE;
            fbo_incomplete(ctx, "inconsistent fixed sample locations", -1);
            return;
         }
      }
      else {
         assert(att->Type == GL_NONE);
         continue;
      }

      /* check if integer color */
      fb->_IntegerColor = _mesa_is_format_integer_color(attFormat);

      /* Update _AllColorBuffersFixedPoint and _HasSNormOrFloatColorBuffer. */
      if (i >= 0) {
         GLenum type = _mesa_get_format_datatype(attFormat);

         fb->_AllColorBuffersFixedPoint =
            fb->_AllColorBuffersFixedPoint &&
            (type == GL_UNSIGNED_NORMALIZED || type == GL_SIGNED_NORMALIZED);

         fb->_HasSNormOrFloatColorBuffer =
            fb->_HasSNormOrFloatColorBuffer ||
            type == GL_SIGNED_NORMALIZED || type == GL_FLOAT;
      }

      /* Error-check width, height, format */
      if (numImages == 1) {
         /* save format */
         if (i >= 0) {
            intFormat = f;
         }
      }
      else {
         if (!ctx->Extensions.ARB_framebuffer_object) {
            /* check that width, height, format are same */
            if (minWidth != maxWidth || minHeight != maxHeight) {
               fb->_Status = GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS_EXT;
               fbo_incomplete(ctx, "width or height mismatch", -1);
               return;
            }
            /* check that all color buffers are the same format */
            if (intFormat != GL_NONE && f != intFormat) {
               fb->_Status = GL_FRAMEBUFFER_INCOMPLETE_FORMATS_EXT;
               fbo_incomplete(ctx, "format mismatch", -1);
               return;
            }
         }
      }

      /* Check that the format is valid. (MESA_FORMAT_NONE means unsupported)
       */
      if (att->Type == GL_RENDERBUFFER &&
          att->Renderbuffer->Format == MESA_FORMAT_NONE) {
         fb->_Status = GL_FRAMEBUFFER_UNSUPPORTED;
         fbo_incomplete(ctx, "unsupported renderbuffer format", i);
         return;
      }

      /* Check that layered rendering is consistent. */
      if (att->Layered) {
         if (att_tex_target == GL_TEXTURE_CUBE_MAP)
            att_layer_count = 6;
         else if (att_tex_target == GL_TEXTURE_1D_ARRAY)
            att_layer_count = att->Renderbuffer->Height;
         else
            att_layer_count = att->Renderbuffer->Depth;
      } else {
         att_layer_count = 0;
      }
      if (!layer_info_valid) {
         is_layered = att->Layered;
         max_layer_count = att_layer_count;
         layer_tex_target = att_tex_target;
         layer_info_valid = true;
      } else if (max_layer_count > 0 && layer_tex_target != att_tex_target) {
         fb->_Status = GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS;
         fbo_incomplete(ctx, "layered framebuffer has mismatched targets", i);
         return;
      } else if (is_layered != att->Layered) {
         fb->_Status = GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS;
         fbo_incomplete(ctx,
                        "framebuffer attachment layer mode is inconsistent",
                        i);
         return;
      } else if (att_layer_count > max_layer_count) {
         max_layer_count = att_layer_count;
      }
   }

   fb->MaxNumLayers = max_layer_count;

   if (numImages == 0) {
      fb->_Status = GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT_EXT;
      fbo_incomplete(ctx, "no attachments", -1);
      return;
   }

   if (_mesa_is_desktop_gl(ctx) && !ctx->Extensions.ARB_ES2_compatibility) {
      /* Check that all DrawBuffers are present */
      for (j = 0; j < ctx->Const.MaxDrawBuffers; j++) {
	 if (fb->ColorDrawBuffer[j] != GL_NONE) {
	    const struct gl_renderbuffer_attachment *att
	       = get_attachment(ctx, fb, fb->ColorDrawBuffer[j]);
	    assert(att);
	    if (att->Type == GL_NONE) {
	       fb->_Status = GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER_EXT;
	       fbo_incomplete(ctx, "missing drawbuffer", j);
	       return;
	    }
	 }
      }

      /* Check that the ReadBuffer is present */
      if (fb->ColorReadBuffer != GL_NONE) {
	 const struct gl_renderbuffer_attachment *att
	    = get_attachment(ctx, fb, fb->ColorReadBuffer);
	 assert(att);
	 if (att->Type == GL_NONE) {
	    fb->_Status = GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER_EXT;
            fbo_incomplete(ctx, "missing readbuffer", -1);
	    return;
	 }
      }
   }

   /* Provisionally set status = COMPLETE ... */
   fb->_Status = GL_FRAMEBUFFER_COMPLETE_EXT;

   /* ... but the driver may say the FB is incomplete.
    * Drivers will most likely set the status to GL_FRAMEBUFFER_UNSUPPORTED
    * if anything.
    */
   if (ctx->Driver.ValidateFramebuffer) {
      ctx->Driver.ValidateFramebuffer(ctx, fb);
      if (fb->_Status != GL_FRAMEBUFFER_COMPLETE_EXT) {
         fbo_incomplete(ctx, "driver marked FBO as incomplete", -1);
      }
   }

   if (fb->_Status == GL_FRAMEBUFFER_COMPLETE_EXT) {
      /*
       * Note that if ARB_framebuffer_object is supported and the attached
       * renderbuffers/textures are different sizes, the framebuffer
       * width/height will be set to the smallest width/height.
       */
      fb->Width = minWidth;
      fb->Height = minHeight;

      /* finally, update the visual info for the framebuffer */
      _mesa_update_framebuffer_visual(ctx, fb);
   }
}


GLboolean GLAPIENTRY
_mesa_IsRenderbuffer(GLuint renderbuffer)
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_WITH_RETVAL(ctx, GL_FALSE);
   if (renderbuffer) {
      struct gl_renderbuffer *rb =
         _mesa_lookup_renderbuffer(ctx, renderbuffer);
      if (rb != NULL && rb != &DummyRenderbuffer)
         return GL_TRUE;
   }
   return GL_FALSE;
}


static void
bind_renderbuffer(GLenum target, GLuint renderbuffer, bool allow_user_names)
{
   struct gl_renderbuffer *newRb;
   GET_CURRENT_CONTEXT(ctx);

   if (target != GL_RENDERBUFFER_EXT) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glBindRenderbufferEXT(target)");
      return;
   }

   /* No need to flush here since the render buffer binding has no
    * effect on rendering state.
    */

   if (renderbuffer) {
      newRb = _mesa_lookup_renderbuffer(ctx, renderbuffer);
      if (newRb == &DummyRenderbuffer) {
         /* ID was reserved, but no real renderbuffer object made yet */
         newRb = NULL;
      }
      else if (!newRb && !allow_user_names) {
         /* All RB IDs must be Gen'd */
         _mesa_error(ctx, GL_INVALID_OPERATION, "glBindRenderbuffer(buffer)");
         return;
      }

      if (!newRb) {
	 /* create new renderbuffer object */
	 newRb = ctx->Driver.NewRenderbuffer(ctx, renderbuffer);
	 if (!newRb) {
	    _mesa_error(ctx, GL_OUT_OF_MEMORY, "glBindRenderbufferEXT");
	    return;
	 }
         ASSERT(newRb->AllocStorage);
         _mesa_HashInsert(ctx->Shared->RenderBuffers, renderbuffer, newRb);
         newRb->RefCount = 1; /* referenced by hash table */
      }
   }
   else {
      newRb = NULL;
   }

   ASSERT(newRb != &DummyRenderbuffer);

   _mesa_reference_renderbuffer(&ctx->CurrentRenderbuffer, newRb);
}

void GLAPIENTRY
_mesa_BindRenderbuffer(GLenum target, GLuint renderbuffer)
{
   GET_CURRENT_CONTEXT(ctx);

   /* OpenGL ES glBindRenderbuffer and glBindRenderbufferOES use this same
    * entry point, but they allow the use of user-generated names.
    */
   bind_renderbuffer(target, renderbuffer, _mesa_is_gles(ctx));
}

void GLAPIENTRY
_mesa_BindRenderbufferEXT(GLenum target, GLuint renderbuffer)
{
   /* This function should not be in the dispatch table for core profile /
    * OpenGL 3.1, so execution should never get here in those cases -- no
    * need for an explicit test.
    */
   bind_renderbuffer(target, renderbuffer, true);
}


/**
 * Remove the specified renderbuffer or texture from any attachment point in
 * the framebuffer.
 *
 * \returns
 * \c true if the renderbuffer was detached from an attachment point.  \c
 * false otherwise.
 */
bool
_mesa_detach_renderbuffer(struct gl_context *ctx,
                          struct gl_framebuffer *fb,
                          const void *att)
{
   unsigned i;
   bool progress = false;

   for (i = 0; i < BUFFER_COUNT; i++) {
      if (fb->Attachment[i].Texture == att
          || fb->Attachment[i].Renderbuffer == att) {
         remove_attachment(ctx, &fb->Attachment[i]);
         progress = true;
      }
   }

   /* Section 4.4.4 (Framebuffer Completeness), subsection "Whole Framebuffer
    * Completeness," of the OpenGL 3.1 spec says:
    *
    *     "Performing any of the following actions may change whether the
    *     framebuffer is considered complete or incomplete:
    *
    *     ...
    *
    *        - Deleting, with DeleteTextures or DeleteRenderbuffers, an object
    *          containing an image that is attached to a framebuffer object
    *          that is bound to the framebuffer."
    */
   if (progress)
      invalidate_framebuffer(fb);

   return progress;
}


void GLAPIENTRY
_mesa_DeleteRenderbuffers(GLsizei n, const GLuint *renderbuffers)
{
   GLint i;
   GET_CURRENT_CONTEXT(ctx);

   FLUSH_VERTICES(ctx, _NEW_BUFFERS);

   for (i = 0; i < n; i++) {
      if (renderbuffers[i] > 0) {
	 struct gl_renderbuffer *rb;
	 rb = _mesa_lookup_renderbuffer(ctx, renderbuffers[i]);
	 if (rb) {
            /* check if deleting currently bound renderbuffer object */
            if (rb == ctx->CurrentRenderbuffer) {
               /* bind default */
               ASSERT(rb->RefCount >= 2);
               _mesa_BindRenderbuffer(GL_RENDERBUFFER_EXT, 0);
            }

            /* Section 4.4.2 (Attaching Images to Framebuffer Objects),
             * subsection "Attaching Renderbuffer Images to a Framebuffer,"
             * of the OpenGL 3.1 spec says:
             *
             *     "If a renderbuffer object is deleted while its image is
             *     attached to one or more attachment points in the currently
             *     bound framebuffer, then it is as if FramebufferRenderbuffer
             *     had been called, with a renderbuffer of 0, for each
             *     attachment point to which this image was attached in the
             *     currently bound framebuffer. In other words, this
             *     renderbuffer image is first detached from all attachment
             *     points in the currently bound framebuffer. Note that the
             *     renderbuffer image is specifically not detached from any
             *     non-bound framebuffers. Detaching the image from any
             *     non-bound framebuffers is the responsibility of the
             *     application.
             */
            if (_mesa_is_user_fbo(ctx->DrawBuffer)) {
               _mesa_detach_renderbuffer(ctx, ctx->DrawBuffer, rb);
            }
            if (_mesa_is_user_fbo(ctx->ReadBuffer)
                && ctx->ReadBuffer != ctx->DrawBuffer) {
               _mesa_detach_renderbuffer(ctx, ctx->ReadBuffer, rb);
            }

	    /* Remove from hash table immediately, to free the ID.
             * But the object will not be freed until it's no longer
             * referenced anywhere else.
             */
	    _mesa_HashRemove(ctx->Shared->RenderBuffers, renderbuffers[i]);

            if (rb != &DummyRenderbuffer) {
               /* no longer referenced by hash table */
               _mesa_reference_renderbuffer(&rb, NULL);
	    }
	 }
      }
   }
}


void GLAPIENTRY
_mesa_GenRenderbuffers(GLsizei n, GLuint *renderbuffers)
{
   GET_CURRENT_CONTEXT(ctx);
   GLuint first;
   GLint i;

   if (n < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glGenRenderbuffersEXT(n)");
      return;
   }

   if (!renderbuffers)
      return;

   first = _mesa_HashFindFreeKeyBlock(ctx->Shared->RenderBuffers, n);

   for (i = 0; i < n; i++) {
      GLuint name = first + i;
      renderbuffers[i] = name;
      /* insert dummy placeholder into hash table */
      mtx_lock(&ctx->Shared->Mutex);
      _mesa_HashInsert(ctx->Shared->RenderBuffers, name, &DummyRenderbuffer);
      mtx_unlock(&ctx->Shared->Mutex);
   }
}


/**
 * Given an internal format token for a render buffer, return the
 * corresponding base format (one of GL_RGB, GL_RGBA, GL_STENCIL_INDEX,
 * GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL_EXT, GL_ALPHA, GL_LUMINANCE,
 * GL_LUMINANCE_ALPHA, GL_INTENSITY, etc).
 *
 * This is similar to _mesa_base_tex_format() but the set of valid
 * internal formats is different.
 *
 * Note that even if a format is determined to be legal here, validation
 * of the FBO may fail if the format is not supported by the driver/GPU.
 *
 * \param internalFormat  as passed to glRenderbufferStorage()
 * \return the base internal format, or 0 if internalFormat is illegal
 */
GLenum
_mesa_base_fbo_format(struct gl_context *ctx, GLenum internalFormat)
{
   /*
    * Notes: some formats such as alpha, luminance, etc. were added
    * with GL_ARB_framebuffer_object.
    */
   switch (internalFormat) {
   case GL_ALPHA:
   case GL_ALPHA4:
   case GL_ALPHA8:
   case GL_ALPHA12:
   case GL_ALPHA16:
      return (ctx->API == API_OPENGL_COMPAT &&
              ctx->Extensions.ARB_framebuffer_object) ? GL_ALPHA : 0;
   case GL_LUMINANCE:
   case GL_LUMINANCE4:
   case GL_LUMINANCE8:
   case GL_LUMINANCE12:
   case GL_LUMINANCE16:
      return (ctx->API == API_OPENGL_COMPAT &&
              ctx->Extensions.ARB_framebuffer_object) ? GL_LUMINANCE : 0;
   case GL_LUMINANCE_ALPHA:
   case GL_LUMINANCE4_ALPHA4:
   case GL_LUMINANCE6_ALPHA2:
   case GL_LUMINANCE8_ALPHA8:
   case GL_LUMINANCE12_ALPHA4:
   case GL_LUMINANCE12_ALPHA12:
   case GL_LUMINANCE16_ALPHA16:
      return (ctx->API == API_OPENGL_COMPAT &&
              ctx->Extensions.ARB_framebuffer_object) ? GL_LUMINANCE_ALPHA : 0;
   case GL_INTENSITY:
   case GL_INTENSITY4:
   case GL_INTENSITY8:
   case GL_INTENSITY12:
   case GL_INTENSITY16:
      return (ctx->API == API_OPENGL_COMPAT &&
              ctx->Extensions.ARB_framebuffer_object) ? GL_INTENSITY : 0;
   case GL_RGB8:
      return GL_RGB;
   case GL_RGB:
   case GL_R3_G3_B2:
   case GL_RGB4:
   case GL_RGB5:
   case GL_RGB10:
   case GL_RGB12:
   case GL_RGB16:
      return _mesa_is_desktop_gl(ctx) ? GL_RGB : 0;
   case GL_SRGB8_EXT:
      return _mesa_is_desktop_gl(ctx) ? GL_RGB : 0;
   case GL_RGBA4:
   case GL_RGB5_A1:
   case GL_RGBA8:
      return GL_RGBA;
   case GL_RGBA:
   case GL_RGBA2:
   case GL_RGBA12:
   case GL_RGBA16:
      return _mesa_is_desktop_gl(ctx) ? GL_RGBA : 0;
   case GL_RGB10_A2:
   case GL_SRGB8_ALPHA8_EXT:
      return _mesa_is_desktop_gl(ctx) || _mesa_is_gles3(ctx) ? GL_RGBA : 0;
   case GL_STENCIL_INDEX:
   case GL_STENCIL_INDEX1_EXT:
   case GL_STENCIL_INDEX4_EXT:
   case GL_STENCIL_INDEX16_EXT:
      /* There are extensions for GL_STENCIL_INDEX1 and GL_STENCIL_INDEX4 in
       * OpenGL ES, but Mesa does not currently support them.
       */
      return _mesa_is_desktop_gl(ctx) ? GL_STENCIL_INDEX : 0;
   case GL_STENCIL_INDEX8_EXT:
      return GL_STENCIL_INDEX;
   case GL_DEPTH_COMPONENT:
   case GL_DEPTH_COMPONENT32:
      return _mesa_is_desktop_gl(ctx) ? GL_DEPTH_COMPONENT : 0;
   case GL_DEPTH_COMPONENT16:
   case GL_DEPTH_COMPONENT24:
      return GL_DEPTH_COMPONENT;
   case GL_DEPTH_STENCIL:
      return _mesa_is_desktop_gl(ctx) ? GL_DEPTH_STENCIL : 0;
   case GL_DEPTH24_STENCIL8:
      return GL_DEPTH_STENCIL;
   case GL_DEPTH_COMPONENT32F:
      return ctx->Version >= 30
         || (ctx->API == API_OPENGL_COMPAT &&
             ctx->Extensions.ARB_depth_buffer_float)
         ? GL_DEPTH_COMPONENT : 0;
   case GL_DEPTH32F_STENCIL8:
      return ctx->Version >= 30
         || (ctx->API == API_OPENGL_COMPAT &&
             ctx->Extensions.ARB_depth_buffer_float)
         ? GL_DEPTH_STENCIL : 0;
   case GL_RED:
   case GL_R16:
      return _mesa_is_desktop_gl(ctx) && ctx->Extensions.ARB_texture_rg
         ? GL_RED : 0;
   case GL_R8:
      return ctx->API != API_OPENGLES && ctx->Extensions.ARB_texture_rg
         ? GL_RED : 0;
   case GL_RG:
   case GL_RG16:
      return _mesa_is_desktop_gl(ctx) && ctx->Extensions.ARB_texture_rg
         ? GL_RG : 0;
   case GL_RG8:
      return ctx->API != API_OPENGLES && ctx->Extensions.ARB_texture_rg
         ? GL_RG : 0;
   /* signed normalized texture formats */
   case GL_RED_SNORM:
   case GL_R8_SNORM:
   case GL_R16_SNORM:
      return _mesa_is_desktop_gl(ctx) && ctx->Extensions.EXT_texture_snorm
         ? GL_RED : 0;
   case GL_RG_SNORM:
   case GL_RG8_SNORM:
   case GL_RG16_SNORM:
      return _mesa_is_desktop_gl(ctx) && ctx->Extensions.EXT_texture_snorm
         ? GL_RG : 0;
   case GL_RGB_SNORM:
   case GL_RGB8_SNORM:
   case GL_RGB16_SNORM:
      return _mesa_is_desktop_gl(ctx) && ctx->Extensions.EXT_texture_snorm
         ? GL_RGB : 0;
   case GL_RGBA_SNORM:
   case GL_RGBA8_SNORM:
   case GL_RGBA16_SNORM:
      return _mesa_is_desktop_gl(ctx) && ctx->Extensions.EXT_texture_snorm
         ? GL_RGBA : 0;
   case GL_ALPHA_SNORM:
   case GL_ALPHA8_SNORM:
   case GL_ALPHA16_SNORM:
      return ctx->API == API_OPENGL_COMPAT &&
             ctx->Extensions.EXT_texture_snorm &&
             ctx->Extensions.ARB_framebuffer_object ? GL_ALPHA : 0;
   case GL_LUMINANCE_SNORM:
   case GL_LUMINANCE8_SNORM:
   case GL_LUMINANCE16_SNORM:
      return _mesa_is_desktop_gl(ctx) && ctx->Extensions.EXT_texture_snorm
         ? GL_LUMINANCE : 0;
   case GL_LUMINANCE_ALPHA_SNORM:
   case GL_LUMINANCE8_ALPHA8_SNORM:
   case GL_LUMINANCE16_ALPHA16_SNORM:
      return _mesa_is_desktop_gl(ctx) && ctx->Extensions.EXT_texture_snorm
         ? GL_LUMINANCE_ALPHA : 0;
   case GL_INTENSITY_SNORM:
   case GL_INTENSITY8_SNORM:
   case GL_INTENSITY16_SNORM:
      return _mesa_is_desktop_gl(ctx) && ctx->Extensions.EXT_texture_snorm
         ? GL_INTENSITY : 0;

   case GL_R16F:
   case GL_R32F:
      return ((_mesa_is_desktop_gl(ctx) &&
               ctx->Extensions.ARB_texture_rg &&
               ctx->Extensions.ARB_texture_float) ||
              _mesa_is_gles3(ctx) /* EXT_color_buffer_float */ )
         ? GL_RED : 0;
   case GL_RG16F:
   case GL_RG32F:
      return ((_mesa_is_desktop_gl(ctx) &&
               ctx->Extensions.ARB_texture_rg &&
               ctx->Extensions.ARB_texture_float) ||
              _mesa_is_gles3(ctx) /* EXT_color_buffer_float */ )
         ? GL_RG : 0;
   case GL_RGB16F:
   case GL_RGB32F:
      return (_mesa_is_desktop_gl(ctx) && ctx->Extensions.ARB_texture_float)
         ? GL_RGB : 0;
   case GL_RGBA16F:
   case GL_RGBA32F:
      return ((_mesa_is_desktop_gl(ctx) &&
               ctx->Extensions.ARB_texture_float) ||
              _mesa_is_gles3(ctx) /* EXT_color_buffer_float */ )
         ? GL_RGBA : 0;
   case GL_ALPHA16F_ARB:
   case GL_ALPHA32F_ARB:
      return ctx->API == API_OPENGL_COMPAT &&
             ctx->Extensions.ARB_texture_float &&
             ctx->Extensions.ARB_framebuffer_object ? GL_ALPHA : 0;
   case GL_LUMINANCE16F_ARB:
   case GL_LUMINANCE32F_ARB:
      return ctx->API == API_OPENGL_COMPAT &&
             ctx->Extensions.ARB_texture_float &&
             ctx->Extensions.ARB_framebuffer_object ? GL_LUMINANCE : 0;
   case GL_LUMINANCE_ALPHA16F_ARB:
   case GL_LUMINANCE_ALPHA32F_ARB:
      return ctx->API == API_OPENGL_COMPAT &&
             ctx->Extensions.ARB_texture_float &&
             ctx->Extensions.ARB_framebuffer_object ? GL_LUMINANCE_ALPHA : 0;
   case GL_INTENSITY16F_ARB:
   case GL_INTENSITY32F_ARB:
      return ctx->API == API_OPENGL_COMPAT &&
             ctx->Extensions.ARB_texture_float &&
             ctx->Extensions.ARB_framebuffer_object ? GL_INTENSITY : 0;
   case GL_R11F_G11F_B10F:
      return ((_mesa_is_desktop_gl(ctx) && ctx->Extensions.EXT_packed_float) ||
              _mesa_is_gles3(ctx) /* EXT_color_buffer_float */ )
         ? GL_RGB : 0;

   case GL_RGBA8UI_EXT:
   case GL_RGBA16UI_EXT:
   case GL_RGBA32UI_EXT:
   case GL_RGBA8I_EXT:
   case GL_RGBA16I_EXT:
   case GL_RGBA32I_EXT:
      return ctx->Version >= 30
         || (_mesa_is_desktop_gl(ctx) &&
             ctx->Extensions.EXT_texture_integer) ? GL_RGBA : 0;

   case GL_RGB8UI_EXT:
   case GL_RGB16UI_EXT:
   case GL_RGB32UI_EXT:
   case GL_RGB8I_EXT:
   case GL_RGB16I_EXT:
   case GL_RGB32I_EXT:
      return _mesa_is_desktop_gl(ctx) && ctx->Extensions.EXT_texture_integer
         ? GL_RGB : 0;
   case GL_R8UI:
   case GL_R8I:
   case GL_R16UI:
   case GL_R16I:
   case GL_R32UI:
   case GL_R32I:
      return ctx->Version >= 30
         || (_mesa_is_desktop_gl(ctx) &&
             ctx->Extensions.ARB_texture_rg &&
             ctx->Extensions.EXT_texture_integer) ? GL_RED : 0;

   case GL_RG8UI:
   case GL_RG8I:
   case GL_RG16UI:
   case GL_RG16I:
   case GL_RG32UI:
   case GL_RG32I:
      return ctx->Version >= 30
         || (_mesa_is_desktop_gl(ctx) &&
             ctx->Extensions.ARB_texture_rg &&
             ctx->Extensions.EXT_texture_integer) ? GL_RG : 0;

   case GL_INTENSITY8I_EXT:
   case GL_INTENSITY8UI_EXT:
   case GL_INTENSITY16I_EXT:
   case GL_INTENSITY16UI_EXT:
   case GL_INTENSITY32I_EXT:
   case GL_INTENSITY32UI_EXT:
      return ctx->API == API_OPENGL_COMPAT &&
             ctx->Extensions.EXT_texture_integer &&
             ctx->Extensions.ARB_framebuffer_object ? GL_INTENSITY : 0;

   case GL_LUMINANCE8I_EXT:
   case GL_LUMINANCE8UI_EXT:
   case GL_LUMINANCE16I_EXT:
   case GL_LUMINANCE16UI_EXT:
   case GL_LUMINANCE32I_EXT:
   case GL_LUMINANCE32UI_EXT:
      return ctx->API == API_OPENGL_COMPAT &&
             ctx->Extensions.EXT_texture_integer &&
             ctx->Extensions.ARB_framebuffer_object ? GL_LUMINANCE : 0;

   case GL_LUMINANCE_ALPHA8I_EXT:
   case GL_LUMINANCE_ALPHA8UI_EXT:
   case GL_LUMINANCE_ALPHA16I_EXT:
   case GL_LUMINANCE_ALPHA16UI_EXT:
   case GL_LUMINANCE_ALPHA32I_EXT:
   case GL_LUMINANCE_ALPHA32UI_EXT:
      return ctx->API == API_OPENGL_COMPAT &&
             ctx->Extensions.EXT_texture_integer &&
             ctx->Extensions.ARB_framebuffer_object ? GL_LUMINANCE_ALPHA : 0;

   case GL_ALPHA8I_EXT:
   case GL_ALPHA8UI_EXT:
   case GL_ALPHA16I_EXT:
   case GL_ALPHA16UI_EXT:
   case GL_ALPHA32I_EXT:
   case GL_ALPHA32UI_EXT:
      return ctx->API == API_OPENGL_COMPAT &&
             ctx->Extensions.EXT_texture_integer &&
             ctx->Extensions.ARB_framebuffer_object ? GL_ALPHA : 0;

   case GL_RGB10_A2UI:
      return (_mesa_is_desktop_gl(ctx) &&
              ctx->Extensions.ARB_texture_rgb10_a2ui)
         || _mesa_is_gles3(ctx) ? GL_RGBA : 0;

   case GL_RGB565:
      return _mesa_is_gles(ctx) || ctx->Extensions.ARB_ES2_compatibility
         ? GL_RGB : 0;
   default:
      return 0;
   }
}


/**
 * Invalidate a renderbuffer attachment.  Called from _mesa_HashWalk().
 */
static void
invalidate_rb(GLuint key, void *data, void *userData)
{
   struct gl_framebuffer *fb = (struct gl_framebuffer *) data;
   struct gl_renderbuffer *rb = (struct gl_renderbuffer *) userData;

   /* If this is a user-created FBO */
   if (_mesa_is_user_fbo(fb)) {
      GLuint i;
      for (i = 0; i < BUFFER_COUNT; i++) {
         struct gl_renderbuffer_attachment *att = fb->Attachment + i;
         if (att->Type == GL_RENDERBUFFER &&
             att->Renderbuffer == rb) {
            /* Mark fb status as indeterminate to force re-validation */
            fb->_Status = 0;
            return;
         }
      }
   }
}


/** sentinal value, see below */
#define NO_SAMPLES 1000


/**
 * Helper function used by _mesa_RenderbufferStorage() and
 * _mesa_RenderbufferStorageMultisample().
 * samples will be NO_SAMPLES if called by _mesa_RenderbufferStorage().
 */
static void
renderbuffer_storage(GLenum target, GLenum internalFormat,
                     GLsizei width, GLsizei height, GLsizei samples)
{
   const char *func = samples == NO_SAMPLES ?
      "glRenderbufferStorage" : "glRenderbufferStorageMultisample";
   struct gl_renderbuffer *rb;
   GLenum baseFormat;
   GLenum sample_count_error;
   GET_CURRENT_CONTEXT(ctx);

   if (MESA_VERBOSE & VERBOSE_API) {
      if (samples == NO_SAMPLES)
         _mesa_debug(ctx, "%s(%s, %s, %d, %d)\n",
                     func,
                     _mesa_lookup_enum_by_nr(target),
                     _mesa_lookup_enum_by_nr(internalFormat),
                     width, height);
      else
         _mesa_debug(ctx, "%s(%s, %s, %d, %d, %d)\n",
                     func,
                     _mesa_lookup_enum_by_nr(target),
                     _mesa_lookup_enum_by_nr(internalFormat),
                     width, height, samples);
   }

   if (target != GL_RENDERBUFFER_EXT) {
      _mesa_error(ctx, GL_INVALID_ENUM, "%s(target)", func);
      return;
   }

   baseFormat = _mesa_base_fbo_format(ctx, internalFormat);
   if (baseFormat == 0) {
      _mesa_error(ctx, GL_INVALID_ENUM, "%s(internalFormat=%s)",
                  func, _mesa_lookup_enum_by_nr(internalFormat));
      return;
   }

   if (width < 0 || width > (GLsizei) ctx->Const.MaxRenderbufferSize) {
      _mesa_error(ctx, GL_INVALID_VALUE, "%s(width)", func);
      return;
   }

   if (height < 0 || height > (GLsizei) ctx->Const.MaxRenderbufferSize) {
      _mesa_error(ctx, GL_INVALID_VALUE, "%s(height)", func);
      return;
   }

   if (samples == NO_SAMPLES) {
      /* NumSamples == 0 indicates non-multisampling */
      samples = 0;
   }
   else {
      /* check the sample count;
       * note: driver may choose to use more samples than what's requested
       */
      sample_count_error = _mesa_check_sample_count(ctx, target,
            internalFormat, samples);
      if (sample_count_error != GL_NO_ERROR) {
         _mesa_error(ctx, sample_count_error, "%s(samples)", func);
         return;
      }
   }

   rb = ctx->CurrentRenderbuffer;
   if (!rb) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "%s", func);
      return;
   }

   FLUSH_VERTICES(ctx, _NEW_BUFFERS);

   if (rb->InternalFormat == internalFormat &&
       rb->Width == (GLuint) width &&
       rb->Height == (GLuint) height &&
       rb->NumSamples == samples) {
      /* no change in allocation needed */
      return;
   }

   /* These MUST get set by the AllocStorage func */
   rb->Format = MESA_FORMAT_NONE;
   rb->NumSamples = samples;

   /* Now allocate the storage */
   ASSERT(rb->AllocStorage);
   if (rb->AllocStorage(ctx, rb, internalFormat, width, height)) {
      /* No error - check/set fields now */
      /* If rb->Format == MESA_FORMAT_NONE, the format is unsupported. */
      assert(rb->Width == (GLuint) width);
      assert(rb->Height == (GLuint) height);
      rb->InternalFormat = internalFormat;
      rb->_BaseFormat = baseFormat;
      assert(rb->_BaseFormat != 0);
   }
   else {
      /* Probably ran out of memory - clear the fields */
      rb->Width = 0;
      rb->Height = 0;
      rb->Format = MESA_FORMAT_NONE;
      rb->InternalFormat = GL_NONE;
      rb->_BaseFormat = GL_NONE;
      rb->NumSamples = 0;
   }

   /* Invalidate the framebuffers the renderbuffer is attached in. */
   if (rb->AttachedAnytime) {
      _mesa_HashWalk(ctx->Shared->FrameBuffers, invalidate_rb, rb);
   }
}


void GLAPIENTRY
_mesa_EGLImageTargetRenderbufferStorageOES(GLenum target, GLeglImageOES image)
{
   struct gl_renderbuffer *rb;
   GET_CURRENT_CONTEXT(ctx);

   if (!ctx->Extensions.OES_EGL_image) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glEGLImageTargetRenderbufferStorageOES(unsupported)");
      return;
   }

   if (target != GL_RENDERBUFFER) {
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "EGLImageTargetRenderbufferStorageOES");
      return;
   }

   rb = ctx->CurrentRenderbuffer;
   if (!rb) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "EGLImageTargetRenderbufferStorageOES");
      return;
   }

   FLUSH_VERTICES(ctx, _NEW_BUFFERS);

   ctx->Driver.EGLImageTargetRenderbufferStorage(ctx, rb, image);
}


/**
 * Helper function for _mesa_GetRenderbufferParameteriv() and
 * _mesa_GetFramebufferAttachmentParameteriv()
 * We have to be careful to respect the base format.  For example, if a
 * renderbuffer/texture was created with internalFormat=GL_RGB but the
 * driver actually chose a GL_RGBA format, when the user queries ALPHA_SIZE
 * we need to return zero.
 */
static GLint
get_component_bits(GLenum pname, GLenum baseFormat, mesa_format format)
{
   if (_mesa_base_format_has_channel(baseFormat, pname))
      return _mesa_get_format_bits(format, pname);
   else
      return 0;
}



void GLAPIENTRY
_mesa_RenderbufferStorage(GLenum target, GLenum internalFormat,
                             GLsizei width, GLsizei height)
{
   /* GL_ARB_fbo says calling this function is equivalent to calling
    * glRenderbufferStorageMultisample() with samples=0.  We pass in
    * a token value here just for error reporting purposes.
    */
   renderbuffer_storage(target, internalFormat, width, height, NO_SAMPLES);
}


void GLAPIENTRY
_mesa_RenderbufferStorageMultisample(GLenum target, GLsizei samples,
                                     GLenum internalFormat,
                                     GLsizei width, GLsizei height)
{
   renderbuffer_storage(target, internalFormat, width, height, samples);
}


/**
 * OpenGL ES version of glRenderBufferStorage.
 */
void GLAPIENTRY
_es_RenderbufferStorageEXT(GLenum target, GLenum internalFormat,
			   GLsizei width, GLsizei height)
{
   switch (internalFormat) {
   case GL_RGB565:
      /* XXX this confuses GL_RENDERBUFFER_INTERNAL_FORMAT_OES */
      /* choose a closest format */
      internalFormat = GL_RGB5;
      break;
   default:
      break;
   }

   renderbuffer_storage(target, internalFormat, width, height, 0);
}


void GLAPIENTRY
_mesa_GetRenderbufferParameteriv(GLenum target, GLenum pname, GLint *params)
{
   struct gl_renderbuffer *rb;
   GET_CURRENT_CONTEXT(ctx);

   if (target != GL_RENDERBUFFER_EXT) {
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "glGetRenderbufferParameterivEXT(target)");
      return;
   }

   rb = ctx->CurrentRenderbuffer;
   if (!rb) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glGetRenderbufferParameterivEXT");
      return;
   }

   /* No need to flush here since we're just quering state which is
    * not effected by rendering.
    */

   switch (pname) {
   case GL_RENDERBUFFER_WIDTH_EXT:
      *params = rb->Width;
      return;
   case GL_RENDERBUFFER_HEIGHT_EXT:
      *params = rb->Height;
      return;
   case GL_RENDERBUFFER_INTERNAL_FORMAT_EXT:
      *params = rb->InternalFormat;
      return;
   case GL_RENDERBUFFER_RED_SIZE_EXT:
   case GL_RENDERBUFFER_GREEN_SIZE_EXT:
   case GL_RENDERBUFFER_BLUE_SIZE_EXT:
   case GL_RENDERBUFFER_ALPHA_SIZE_EXT:
   case GL_RENDERBUFFER_DEPTH_SIZE_EXT:
   case GL_RENDERBUFFER_STENCIL_SIZE_EXT:
      *params = get_component_bits(pname, rb->_BaseFormat, rb->Format);
      break;
   case GL_RENDERBUFFER_SAMPLES:
      if ((_mesa_is_desktop_gl(ctx) && ctx->Extensions.ARB_framebuffer_object)
          || _mesa_is_gles3(ctx)) {
         *params = rb->NumSamples;
         break;
      }
      /* fallthrough */
   default:
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "glGetRenderbufferParameterivEXT(target)");
      return;
   }
}


GLboolean GLAPIENTRY
_mesa_IsFramebuffer(GLuint framebuffer)
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_WITH_RETVAL(ctx, GL_FALSE);
   if (framebuffer) {
      struct gl_framebuffer *rb = _mesa_lookup_framebuffer(ctx, framebuffer);
      if (rb != NULL && rb != &DummyFramebuffer)
         return GL_TRUE;
   }
   return GL_FALSE;
}


/**
 * Check if any of the attachments of the given framebuffer are textures
 * (render to texture).  Call ctx->Driver.RenderTexture() for such
 * attachments.
 */
static void
check_begin_texture_render(struct gl_context *ctx, struct gl_framebuffer *fb)
{
   GLuint i;
   ASSERT(ctx->Driver.RenderTexture);

   if (_mesa_is_winsys_fbo(fb))
      return; /* can't render to texture with winsys framebuffers */

   for (i = 0; i < BUFFER_COUNT; i++) {
      struct gl_renderbuffer_attachment *att = fb->Attachment + i;
      if (att->Texture && att->Renderbuffer->TexImage
          && driver_RenderTexture_is_safe(att)) {
         ctx->Driver.RenderTexture(ctx, fb, att);
      }
   }
}


/**
 * Examine all the framebuffer's attachments to see if any are textures.
 * If so, call ctx->Driver.FinishRenderTexture() for each texture to
 * notify the device driver that the texture image may have changed.
 */
static void
check_end_texture_render(struct gl_context *ctx, struct gl_framebuffer *fb)
{
   /* Skip if we know NeedsFinishRenderTexture won't be set. */
   if (_mesa_is_winsys_fbo(fb) && !ctx->Driver.BindRenderbufferTexImage)
      return;

   if (ctx->Driver.FinishRenderTexture) {
      GLuint i;
      for (i = 0; i < BUFFER_COUNT; i++) {
         struct gl_renderbuffer_attachment *att = fb->Attachment + i;
         struct gl_renderbuffer *rb = att->Renderbuffer;
         if (rb && rb->NeedsFinishRenderTexture) {
            ctx->Driver.FinishRenderTexture(ctx, rb);
         }
      }
   }
}


static void
bind_framebuffer(GLenum target, GLuint framebuffer, bool allow_user_names)
{
   struct gl_framebuffer *newDrawFb, *newReadFb;
   struct gl_framebuffer *oldDrawFb, *oldReadFb;
   GLboolean bindReadBuf, bindDrawBuf;
   GET_CURRENT_CONTEXT(ctx);

   switch (target) {
   case GL_DRAW_FRAMEBUFFER_EXT:
      bindDrawBuf = GL_TRUE;
      bindReadBuf = GL_FALSE;
      break;
   case GL_READ_FRAMEBUFFER_EXT:
      bindDrawBuf = GL_FALSE;
      bindReadBuf = GL_TRUE;
      break;
   case GL_FRAMEBUFFER_EXT:
      bindDrawBuf = GL_TRUE;
      bindReadBuf = GL_TRUE;
      break;
   default:
      _mesa_error(ctx, GL_INVALID_ENUM, "glBindFramebufferEXT(target)");
      return;
   }

   if (framebuffer) {
      /* Binding a user-created framebuffer object */
      newDrawFb = _mesa_lookup_framebuffer(ctx, framebuffer);
      if (newDrawFb == &DummyFramebuffer) {
         /* ID was reserved, but no real framebuffer object made yet */
         newDrawFb = NULL;
      }
      else if (!newDrawFb && !allow_user_names) {
         /* All FBO IDs must be Gen'd */
         _mesa_error(ctx, GL_INVALID_OPERATION, "glBindFramebuffer(buffer)");
         return;
      }

      if (!newDrawFb) {
	 /* create new framebuffer object */
	 newDrawFb = ctx->Driver.NewFramebuffer(ctx, framebuffer);
	 if (!newDrawFb) {
	    _mesa_error(ctx, GL_OUT_OF_MEMORY, "glBindFramebufferEXT");
	    return;
	 }
         _mesa_HashInsert(ctx->Shared->FrameBuffers, framebuffer, newDrawFb);
      }
      newReadFb = newDrawFb;
   }
   else {
      /* Binding the window system framebuffer (which was originally set
       * with MakeCurrent).
       */
      newDrawFb = ctx->WinSysDrawBuffer;
      newReadFb = ctx->WinSysReadBuffer;
   }

   ASSERT(newDrawFb);
   ASSERT(newDrawFb != &DummyFramebuffer);

   /* save pointers to current/old framebuffers */
   oldDrawFb = ctx->DrawBuffer;
   oldReadFb = ctx->ReadBuffer;

   /* check if really changing bindings */
   if (oldDrawFb == newDrawFb)
      bindDrawBuf = GL_FALSE;
   if (oldReadFb == newReadFb)
      bindReadBuf = GL_FALSE;

   /*
    * OK, now bind the new Draw/Read framebuffers, if they're changing.
    *
    * We also check if we're beginning and/or ending render-to-texture.
    * When a framebuffer with texture attachments is unbound, call
    * ctx->Driver.FinishRenderTexture().
    * When a framebuffer with texture attachments is bound, call
    * ctx->Driver.RenderTexture().
    *
    * Note that if the ReadBuffer has texture attachments we don't consider
    * that a render-to-texture case.
    */
   if (bindReadBuf) {
      FLUSH_VERTICES(ctx, _NEW_BUFFERS);

      /* check if old readbuffer was render-to-texture */
      check_end_texture_render(ctx, oldReadFb);

      _mesa_reference_framebuffer(&ctx->ReadBuffer, newReadFb);
   }

   if (bindDrawBuf) {
      FLUSH_VERTICES(ctx, _NEW_BUFFERS);

      /* check if old framebuffer had any texture attachments */
      if (oldDrawFb)
         check_end_texture_render(ctx, oldDrawFb);

      /* check if newly bound framebuffer has any texture attachments */
      check_begin_texture_render(ctx, newDrawFb);

      _mesa_reference_framebuffer(&ctx->DrawBuffer, newDrawFb);
   }

   if ((bindDrawBuf || bindReadBuf) && ctx->Driver.BindFramebuffer) {
      ctx->Driver.BindFramebuffer(ctx, target, newDrawFb, newReadFb);
   }
}

void GLAPIENTRY
_mesa_BindFramebuffer(GLenum target, GLuint framebuffer)
{
   GET_CURRENT_CONTEXT(ctx);

   /* OpenGL ES glBindFramebuffer and glBindFramebufferOES use this same entry
    * point, but they allow the use of user-generated names.
    */
   bind_framebuffer(target, framebuffer, _mesa_is_gles(ctx));
}


void GLAPIENTRY
_mesa_BindFramebufferEXT(GLenum target, GLuint framebuffer)
{
   /* This function should not be in the dispatch table for core profile /
    * OpenGL 3.1, so execution should never get here in those cases -- no
    * need for an explicit test.
    */
   bind_framebuffer(target, framebuffer, true);
}


void GLAPIENTRY
_mesa_DeleteFramebuffers(GLsizei n, const GLuint *framebuffers)
{
   GLint i;
   GET_CURRENT_CONTEXT(ctx);

   FLUSH_VERTICES(ctx, _NEW_BUFFERS);

   for (i = 0; i < n; i++) {
      if (framebuffers[i] > 0) {
	 struct gl_framebuffer *fb;
	 fb = _mesa_lookup_framebuffer(ctx, framebuffers[i]);
	 if (fb) {
            ASSERT(fb == &DummyFramebuffer || fb->Name == framebuffers[i]);

            /* check if deleting currently bound framebuffer object */
            if (fb == ctx->DrawBuffer) {
               /* bind default */
               ASSERT(fb->RefCount >= 2);
               _mesa_BindFramebuffer(GL_DRAW_FRAMEBUFFER, 0);
            }
            if (fb == ctx->ReadBuffer) {
               /* bind default */
               ASSERT(fb->RefCount >= 2);
               _mesa_BindFramebuffer(GL_READ_FRAMEBUFFER, 0);
            }

	    /* remove from hash table immediately, to free the ID */
	    _mesa_HashRemove(ctx->Shared->FrameBuffers, framebuffers[i]);

            if (fb != &DummyFramebuffer) {
               /* But the object will not be freed until it's no longer
                * bound in any context.
                */
               _mesa_reference_framebuffer(&fb, NULL);
	    }
	 }
      }
   }
}


void GLAPIENTRY
_mesa_GenFramebuffers(GLsizei n, GLuint *framebuffers)
{
   GET_CURRENT_CONTEXT(ctx);
   GLuint first;
   GLint i;

   if (n < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glGenFramebuffersEXT(n)");
      return;
   }

   if (!framebuffers)
      return;

   first = _mesa_HashFindFreeKeyBlock(ctx->Shared->FrameBuffers, n);

   for (i = 0; i < n; i++) {
      GLuint name = first + i;
      framebuffers[i] = name;
      /* insert dummy placeholder into hash table */
      mtx_lock(&ctx->Shared->Mutex);
      _mesa_HashInsert(ctx->Shared->FrameBuffers, name, &DummyFramebuffer);
      mtx_unlock(&ctx->Shared->Mutex);
   }
}


GLenum GLAPIENTRY
_mesa_CheckFramebufferStatus(GLenum target)
{
   struct gl_framebuffer *buffer;
   GET_CURRENT_CONTEXT(ctx);

   ASSERT_OUTSIDE_BEGIN_END_WITH_RETVAL(ctx, 0);

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glCheckFramebufferStatus(%s)\n",
                  _mesa_lookup_enum_by_nr(target));

   buffer = get_framebuffer_target(ctx, target);
   if (!buffer) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glCheckFramebufferStatus(target)");
      return 0;
   }

   if (_mesa_is_winsys_fbo(buffer)) {
      /* EGL_KHR_surfaceless_context allows the winsys FBO to be incomplete. */
      if (buffer != &IncompleteFramebuffer) {
         return GL_FRAMEBUFFER_COMPLETE_EXT;
      } else {
         return GL_FRAMEBUFFER_UNDEFINED;
      }
   }

   /* No need to flush here */

   if (buffer->_Status != GL_FRAMEBUFFER_COMPLETE) {
      _mesa_test_framebuffer_completeness(ctx, buffer);
   }

   return buffer->_Status;
}


/**
 * Replicate the src attachment point. Used by framebuffer_texture() when
 * the same texture is attached at GL_DEPTH_ATTACHMENT and
 * GL_STENCIL_ATTACHMENT.
 */
static void
reuse_framebuffer_texture_attachment(struct gl_framebuffer *fb,
                                     gl_buffer_index dst,
                                     gl_buffer_index src)
{
   struct gl_renderbuffer_attachment *dst_att = &fb->Attachment[dst];
   struct gl_renderbuffer_attachment *src_att = &fb->Attachment[src];

   assert(src_att->Texture != NULL);
   assert(src_att->Renderbuffer != NULL);

   _mesa_reference_texobj(&dst_att->Texture, src_att->Texture);
   _mesa_reference_renderbuffer(&dst_att->Renderbuffer, src_att->Renderbuffer);
   dst_att->Type = src_att->Type;
   dst_att->Complete = src_att->Complete;
   dst_att->TextureLevel = src_att->TextureLevel;
   dst_att->Zoffset = src_att->Zoffset;
}


/**
 * Common code called by glFramebufferTexture1D/2D/3DEXT() and
 * glFramebufferTextureLayerEXT().
 *
 * \param textarget is the textarget that was passed to the
 * glFramebufferTexture...() function, or 0 if the corresponding function
 * doesn't have a textarget parameter.
 *
 * \param layered is true if this function was called from
 * glFramebufferTexture(), false otherwise.
 */
static void
framebuffer_texture(struct gl_context *ctx, const char *caller, GLenum target,
                    GLenum attachment, GLenum textarget, GLuint texture,
                    GLint level, GLint zoffset, GLboolean layered)
{
   struct gl_renderbuffer_attachment *att;
   struct gl_texture_object *texObj = NULL;
   struct gl_framebuffer *fb;
   GLenum maxLevelsTarget;

   fb = get_framebuffer_target(ctx, target);
   if (!fb) {
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "glFramebufferTexture%sEXT(target=0x%x)", caller, target);
      return;
   }

   /* check framebuffer binding */
   if (_mesa_is_winsys_fbo(fb)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glFramebufferTexture%sEXT", caller);
      return;
   }

   /* The textarget, level, and zoffset parameters are only validated if
    * texture is non-zero.
    */
   if (texture) {
      GLboolean err = GL_TRUE;

      texObj = _mesa_lookup_texture(ctx, texture);
      if (texObj != NULL) {
         if (textarget == 0) {
            if (layered) {
               /* We're being called by glFramebufferTexture() and textarget
                * is not used.
                */
               switch (texObj->Target) {
               case GL_TEXTURE_3D:
               case GL_TEXTURE_1D_ARRAY_EXT:
               case GL_TEXTURE_2D_ARRAY_EXT:
               case GL_TEXTURE_CUBE_MAP:
               case GL_TEXTURE_CUBE_MAP_ARRAY:
               case GL_TEXTURE_2D_MULTISAMPLE_ARRAY:
                  err = false;
                  break;
               case GL_TEXTURE_1D:
               case GL_TEXTURE_2D:
               case GL_TEXTURE_RECTANGLE:
               case GL_TEXTURE_2D_MULTISAMPLE:
                  /* These texture types are valid to pass to
                   * glFramebufferTexture(), but since they aren't layered, it
                   * is equivalent to calling glFramebufferTexture{1D,2D}().
                   */
                  err = false;
                  layered = false;
                  textarget = texObj->Target;
                  break;
               default:
                  err = true;
                  break;
               }
            } else {
               /* We're being called by glFramebufferTextureLayer() and
                * textarget is not used.  The only legal texture types for
                * that function are 3D and 1D/2D arrays textures.
                */
               err = (texObj->Target != GL_TEXTURE_3D) &&
                  (texObj->Target != GL_TEXTURE_1D_ARRAY_EXT) &&
                  (texObj->Target != GL_TEXTURE_2D_ARRAY_EXT) &&
                  (texObj->Target != GL_TEXTURE_CUBE_MAP_ARRAY) &&
                  (texObj->Target != GL_TEXTURE_2D_MULTISAMPLE_ARRAY);
            }
         }
         else {
            /* Make sure textarget is consistent with the texture's type */
            err = (texObj->Target == GL_TEXTURE_CUBE_MAP)
                ? !_mesa_is_cube_face(textarget)
                : (texObj->Target != textarget);
         }
      }
      else {
         /* can't render to a non-existant texture */
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glFramebufferTexture%sEXT(non existant texture)",
                     caller);
         return;
      }

      if (err) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glFramebufferTexture%sEXT(texture target mismatch)",
                     caller);
         return;
      }

      if (texObj->Target == GL_TEXTURE_3D) {
         const GLint maxSize = 1 << (ctx->Const.Max3DTextureLevels - 1);
         if (zoffset < 0 || zoffset >= maxSize) {
            _mesa_error(ctx, GL_INVALID_VALUE,
                        "glFramebufferTexture%sEXT(zoffset)", caller);
            return;
         }
      }
      else if ((texObj->Target == GL_TEXTURE_1D_ARRAY_EXT) ||
               (texObj->Target == GL_TEXTURE_2D_ARRAY_EXT) ||
               (texObj->Target == GL_TEXTURE_CUBE_MAP_ARRAY) ||
               (texObj->Target == GL_TEXTURE_2D_MULTISAMPLE_ARRAY)) {
         if (zoffset < 0 ||
             zoffset >= (GLint) ctx->Const.MaxArrayTextureLayers) {
            _mesa_error(ctx, GL_INVALID_VALUE,
                        "glFramebufferTexture%sEXT(layer)", caller);
            return;
         }
      }

      maxLevelsTarget = textarget ? textarget : texObj->Target;
      if ((level < 0) ||
          (level >= _mesa_max_texture_levels(ctx, maxLevelsTarget))) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glFramebufferTexture%sEXT(level)", caller);
         return;
      }
   }

   att = get_attachment(ctx, fb, attachment);
   if (att == NULL) {
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "glFramebufferTexture%sEXT(attachment)", caller);
      return;
   }

   FLUSH_VERTICES(ctx, _NEW_BUFFERS);

   mtx_lock(&fb->Mutex);
   if (texObj) {
      if (attachment == GL_DEPTH_ATTACHMENT &&
          texObj == fb->Attachment[BUFFER_STENCIL].Texture &&
          level == fb->Attachment[BUFFER_STENCIL].TextureLevel &&
          _mesa_tex_target_to_face(textarget) ==
          fb->Attachment[BUFFER_STENCIL].CubeMapFace &&
          zoffset == fb->Attachment[BUFFER_STENCIL].Zoffset) {
	 /* The texture object is already attached to the stencil attachment
	  * point. Don't create a new renderbuffer; just reuse the stencil
	  * attachment's. This is required to prevent a GL error in
	  * glGetFramebufferAttachmentParameteriv(GL_DEPTH_STENCIL).
	  */
	 reuse_framebuffer_texture_attachment(fb, BUFFER_DEPTH,
	                                      BUFFER_STENCIL);
      } else if (attachment == GL_STENCIL_ATTACHMENT &&
	         texObj == fb->Attachment[BUFFER_DEPTH].Texture &&
                 level == fb->Attachment[BUFFER_DEPTH].TextureLevel &&
                 _mesa_tex_target_to_face(textarget) ==
                 fb->Attachment[BUFFER_DEPTH].CubeMapFace &&
                 zoffset == fb->Attachment[BUFFER_DEPTH].Zoffset) {
	 /* As above, but with depth and stencil transposed. */
	 reuse_framebuffer_texture_attachment(fb, BUFFER_STENCIL,
	                                      BUFFER_DEPTH);
      } else {
	 set_texture_attachment(ctx, fb, att, texObj, textarget,
	                              level, zoffset, layered);
	 if (attachment == GL_DEPTH_STENCIL_ATTACHMENT) {
	    /* Above we created a new renderbuffer and attached it to the
	     * depth attachment point. Now attach it to the stencil attachment
	     * point too.
	     */
	    assert(att == &fb->Attachment[BUFFER_DEPTH]);
	    reuse_framebuffer_texture_attachment(fb,BUFFER_STENCIL,
	                                         BUFFER_DEPTH);
	 }
      }

      /* Set the render-to-texture flag.  We'll check this flag in
       * glTexImage() and friends to determine if we need to revalidate
       * any FBOs that might be rendering into this texture.
       * This flag never gets cleared since it's non-trivial to determine
       * when all FBOs might be done rendering to this texture.  That's OK
       * though since it's uncommon to render to a texture then repeatedly
       * call glTexImage() to change images in the texture.
       */
      texObj->_RenderToTexture = GL_TRUE;
   }
   else {
      remove_attachment(ctx, att);
      if (attachment == GL_DEPTH_STENCIL_ATTACHMENT) {
	 assert(att == &fb->Attachment[BUFFER_DEPTH]);
	 remove_attachment(ctx, &fb->Attachment[BUFFER_STENCIL]);
      }
   }

   invalidate_framebuffer(fb);

   mtx_unlock(&fb->Mutex);
}


void GLAPIENTRY
_mesa_FramebufferTexture1D(GLenum target, GLenum attachment,
                           GLenum textarget, GLuint texture, GLint level)
{
   GET_CURRENT_CONTEXT(ctx);

   if (texture != 0) {
      GLboolean error;

      switch (textarget) {
      case GL_TEXTURE_1D:
         error = GL_FALSE;
         break;
      case GL_TEXTURE_1D_ARRAY:
         error = !ctx->Extensions.EXT_texture_array;
         break;
      default:
         error = GL_TRUE;
      }

      if (error) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glFramebufferTexture1DEXT(textarget=%s)",
                     _mesa_lookup_enum_by_nr(textarget));
         return;
      }
   }

   framebuffer_texture(ctx, "1D", target, attachment, textarget, texture,
                       level, 0, GL_FALSE);
}


void GLAPIENTRY
_mesa_FramebufferTexture2D(GLenum target, GLenum attachment,
                           GLenum textarget, GLuint texture, GLint level)
{
   GET_CURRENT_CONTEXT(ctx);

   if (texture != 0) {
      GLboolean error;

      switch (textarget) {
      case GL_TEXTURE_2D:
         error = GL_FALSE;
         break;
      case GL_TEXTURE_RECTANGLE:
         error = _mesa_is_gles(ctx)
            || !ctx->Extensions.NV_texture_rectangle;
         break;
      case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
      case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
      case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
         error = !ctx->Extensions.ARB_texture_cube_map;
         break;
      case GL_TEXTURE_2D_ARRAY:
         error = (_mesa_is_gles(ctx) && ctx->Version < 30)
            || !ctx->Extensions.EXT_texture_array;
         break;
      case GL_TEXTURE_2D_MULTISAMPLE:
      case GL_TEXTURE_2D_MULTISAMPLE_ARRAY:
         error = _mesa_is_gles(ctx)
            || !ctx->Extensions.ARB_texture_multisample;
         break;
      default:
         error = GL_TRUE;
      }

      if (error) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glFramebufferTexture2DEXT(textarget=%s)",
                     _mesa_lookup_enum_by_nr(textarget));
         return;
      }
   }

   framebuffer_texture(ctx, "2D", target, attachment, textarget, texture,
                       level, 0, GL_FALSE);
}


void GLAPIENTRY
_mesa_FramebufferTexture3D(GLenum target, GLenum attachment,
                           GLenum textarget, GLuint texture,
                           GLint level, GLint zoffset)
{
   GET_CURRENT_CONTEXT(ctx);

   if ((texture != 0) && (textarget != GL_TEXTURE_3D)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glFramebufferTexture3DEXT(textarget)");
      return;
   }

   framebuffer_texture(ctx, "3D", target, attachment, textarget, texture,
                       level, zoffset, GL_FALSE);
}


void GLAPIENTRY
_mesa_FramebufferTextureLayer(GLenum target, GLenum attachment,
                              GLuint texture, GLint level, GLint layer)
{
   GET_CURRENT_CONTEXT(ctx);

   framebuffer_texture(ctx, "Layer", target, attachment, 0, texture,
                       level, layer, GL_FALSE);
}


void GLAPIENTRY
_mesa_FramebufferTexture(GLenum target, GLenum attachment,
                         GLuint texture, GLint level)
{
   GET_CURRENT_CONTEXT(ctx);

   if (_mesa_has_geometry_shaders(ctx)) {
      framebuffer_texture(ctx, "Layer", target, attachment, 0, texture,
                          level, 0, GL_TRUE);
   } else {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "unsupported function (glFramebufferTexture) called");
   }
}


void GLAPIENTRY
_mesa_FramebufferRenderbuffer(GLenum target, GLenum attachment,
                              GLenum renderbufferTarget,
                              GLuint renderbuffer)
{
   struct gl_renderbuffer_attachment *att;
   struct gl_framebuffer *fb;
   struct gl_renderbuffer *rb;
   GET_CURRENT_CONTEXT(ctx);

   fb = get_framebuffer_target(ctx, target);
   if (!fb) {
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "glFramebufferRenderbufferEXT(target)");
      return;
   }

   if (renderbufferTarget != GL_RENDERBUFFER_EXT) {
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "glFramebufferRenderbufferEXT(renderbufferTarget)");
      return;
   }

   if (_mesa_is_winsys_fbo(fb)) {
      /* Can't attach new renderbuffers to a window system framebuffer */
      _mesa_error(ctx, GL_INVALID_OPERATION, "glFramebufferRenderbufferEXT");
      return;
   }

   att = get_attachment(ctx, fb, attachment);
   if (att == NULL) {
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "glFramebufferRenderbufferEXT(invalid attachment %s)",
                  _mesa_lookup_enum_by_nr(attachment));
      return;
   }

   if (renderbuffer) {
      rb = _mesa_lookup_renderbuffer(ctx, renderbuffer);
      if (!rb) {
	 _mesa_error(ctx, GL_INVALID_OPERATION,
		     "glFramebufferRenderbufferEXT(non-existant"
                     " renderbuffer %u)", renderbuffer);
	 return;
      }
      else if (rb == &DummyRenderbuffer) {
	 _mesa_error(ctx, GL_INVALID_OPERATION,
		     "glFramebufferRenderbufferEXT(renderbuffer %u)",
                     renderbuffer);
	 return;
      }
   }
   else {
      /* remove renderbuffer attachment */
      rb = NULL;
   }

   if (attachment == GL_DEPTH_STENCIL_ATTACHMENT &&
       rb && rb->Format != MESA_FORMAT_NONE) {
      /* make sure the renderbuffer is a depth/stencil format */
      const GLenum baseFormat = _mesa_get_format_base_format(rb->Format);
      if (baseFormat != GL_DEPTH_STENCIL) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glFramebufferRenderbufferEXT(renderbuffer"
                     " is not DEPTH_STENCIL format)");
         return;
      }
   }

   FLUSH_VERTICES(ctx, _NEW_BUFFERS);

   assert(ctx->Driver.FramebufferRenderbuffer);
   ctx->Driver.FramebufferRenderbuffer(ctx, fb, attachment, rb);

   /* Some subsequent GL commands may depend on the framebuffer's visual
    * after the binding is updated.  Update visual info now.
    */
   _mesa_update_framebuffer_visual(ctx, fb);
}


void GLAPIENTRY
_mesa_GetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment,
                                          GLenum pname, GLint *params)
{
   const struct gl_renderbuffer_attachment *att;
   struct gl_framebuffer *buffer;
   GLenum err;
   GET_CURRENT_CONTEXT(ctx);

   /* The error differs in GL and GLES. */
   err = _mesa_is_desktop_gl(ctx) ? GL_INVALID_OPERATION : GL_INVALID_ENUM;

   buffer = get_framebuffer_target(ctx, target);
   if (!buffer) {
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "glGetFramebufferAttachmentParameterivEXT(target)");
      return;
   }

   if (_mesa_is_winsys_fbo(buffer)) {
      /* Page 126 (page 136 of the PDF) of the OpenGL ES 2.0.25 spec
       * says:
       *
       *     "If the framebuffer currently bound to target is zero, then
       *     INVALID_OPERATION is generated."
       *
       * The EXT_framebuffer_object spec has the same wording, and the
       * OES_framebuffer_object spec refers to the EXT_framebuffer_object
       * spec.
       */
      if ((!_mesa_is_desktop_gl(ctx) ||
           !ctx->Extensions.ARB_framebuffer_object)
          && !_mesa_is_gles3(ctx)) {
	 _mesa_error(ctx, GL_INVALID_OPERATION,
		     "glGetFramebufferAttachmentParameteriv(bound FBO = 0)");
	 return;
      }

      if (_mesa_is_gles3(ctx) && attachment != GL_BACK &&
          attachment != GL_DEPTH && attachment != GL_STENCIL) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glGetFramebufferAttachmentParameteriv(attachment)");
         return;
      }
      /* the default / window-system FBO */
      att = _mesa_get_fb0_attachment(ctx, buffer, attachment);
   }
   else {
      /* user-created framebuffer FBO */
      att = get_attachment(ctx, buffer, attachment);
   }

   if (att == NULL) {
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "glGetFramebufferAttachmentParameterivEXT(attachment)");
      return;
   }

   if (attachment == GL_DEPTH_STENCIL_ATTACHMENT) {
      const struct gl_renderbuffer_attachment *depthAtt, *stencilAtt;
      if (pname == GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE) {
         /* This behavior is first specified in OpenGL 4.4 specification.
          *
          * From the OpenGL 4.4 spec page 275:
          *   "This query cannot be performed for a combined depth+stencil
          *    attachment, since it does not have a single format."
          */
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glGetFramebufferAttachmentParameteriv("
                     "GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE"
                     " is invalid for depth+stencil attachment)");
         return;
      }
      /* the depth and stencil attachments must point to the same buffer */
      depthAtt = get_attachment(ctx, buffer, GL_DEPTH_ATTACHMENT);
      stencilAtt = get_attachment(ctx, buffer, GL_STENCIL_ATTACHMENT);
      if (depthAtt->Renderbuffer != stencilAtt->Renderbuffer) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glGetFramebufferAttachmentParameterivEXT(DEPTH/STENCIL"
                     " attachments differ)");
         return;
      }
   }

   /* No need to flush here */

   switch (pname) {
   case GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE_EXT:
      *params = _mesa_is_winsys_fbo(buffer)
         ? GL_FRAMEBUFFER_DEFAULT : att->Type;
      return;
   case GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME_EXT:
      if (att->Type == GL_RENDERBUFFER_EXT) {
	 *params = att->Renderbuffer->Name;
      }
      else if (att->Type == GL_TEXTURE) {
	 *params = att->Texture->Name;
      }
      else {
         assert(att->Type == GL_NONE);
         if (_mesa_is_desktop_gl(ctx) || _mesa_is_gles3(ctx)) {
            *params = 0;
         } else {
            goto invalid_pname_enum;
         }
      }
      return;
   case GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL_EXT:
      if (att->Type == GL_TEXTURE) {
	 *params = att->TextureLevel;
      }
      else if (att->Type == GL_NONE) {
         _mesa_error(ctx, err,
                     "glGetFramebufferAttachmentParameterivEXT(pname)");
      }
      else {
         goto invalid_pname_enum;
      }
      return;
   case GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE_EXT:
      if (att->Type == GL_TEXTURE) {
         if (att->Texture && att->Texture->Target == GL_TEXTURE_CUBE_MAP) {
            *params = GL_TEXTURE_CUBE_MAP_POSITIVE_X + att->CubeMapFace;
         }
         else {
            *params = 0;
         }
      }
      else if (att->Type == GL_NONE) {
         _mesa_error(ctx, err,
                     "glGetFramebufferAttachmentParameterivEXT(pname)");
      }
      else {
         goto invalid_pname_enum;
      }
      return;
   case GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET_EXT:
      if (ctx->API == API_OPENGLES) {
         goto invalid_pname_enum;
      } else if (att->Type == GL_NONE) {
         _mesa_error(ctx, err,
                     "glGetFramebufferAttachmentParameterivEXT(pname)");
      } else if (att->Type == GL_TEXTURE) {
         if (att->Texture && att->Texture->Target == GL_TEXTURE_3D) {
            *params = att->Zoffset;
         }
         else {
            *params = 0;
         }
      }
      else {
         goto invalid_pname_enum;
      }
      return;
   case GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING:
      if ((!_mesa_is_desktop_gl(ctx) ||
           !ctx->Extensions.ARB_framebuffer_object)
          && !_mesa_is_gles3(ctx)) {
         goto invalid_pname_enum;
      }
      else if (att->Type == GL_NONE) {
         _mesa_error(ctx, err,
                     "glGetFramebufferAttachmentParameterivEXT(pname)");
      }
      else {
         if (ctx->Extensions.EXT_framebuffer_sRGB) {
            *params =
               _mesa_get_format_color_encoding(att->Renderbuffer->Format);
         }
         else {
            /* According to ARB_framebuffer_sRGB, we should return LINEAR
             * if the sRGB conversion is unsupported. */
            *params = GL_LINEAR;
         }
      }
      return;
   case GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE:
      if ((ctx->API != API_OPENGL_COMPAT ||
           !ctx->Extensions.ARB_framebuffer_object)
          && ctx->API != API_OPENGL_CORE
          && !_mesa_is_gles3(ctx)) {
         goto invalid_pname_enum;
      }
      else if (att->Type == GL_NONE) {
         _mesa_error(ctx, err,
                     "glGetFramebufferAttachmentParameterivEXT(pname)");
      }
      else {
         mesa_format format = att->Renderbuffer->Format;

         /* Page 235 (page 247 of the PDF) in section 6.1.13 of the OpenGL ES
          * 3.0.1 spec says:
          *
          *     "If pname is FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE.... If
          *     attachment is DEPTH_STENCIL_ATTACHMENT the query will fail and
          *     generate an INVALID_OPERATION error.
          */
         if (_mesa_is_gles3(ctx) &&
             attachment == GL_DEPTH_STENCIL_ATTACHMENT) {
            _mesa_error(ctx, GL_INVALID_OPERATION,
                        "glGetFramebufferAttachmentParameteriv(cannot query "
                        "GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE of "
                        "GL_DEPTH_STENCIL_ATTACHMENT");
            return;
         }

         if (format == MESA_FORMAT_S_UINT8) {
            /* special cases */
            *params = GL_INDEX;
         }
         else if (format == MESA_FORMAT_Z32_FLOAT_S8X24_UINT) {
            /* depends on the attachment parameter */
            if (attachment == GL_STENCIL_ATTACHMENT) {
               *params = GL_INDEX;
            }
            else {
               *params = GL_FLOAT;
            }
         }
         else {
            *params = _mesa_get_format_datatype(format);
         }
      }
      return;
   case GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE:
   case GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE:
   case GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE:
   case GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE:
   case GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE:
   case GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE:
      if ((!_mesa_is_desktop_gl(ctx) ||
           !ctx->Extensions.ARB_framebuffer_object)
          && !_mesa_is_gles3(ctx)) {
         goto invalid_pname_enum;
      }
      else if (att->Type == GL_NONE) {
         _mesa_error(ctx, err,
                     "glGetFramebufferAttachmentParameterivEXT(pname)");
      }
      else if (att->Texture) {
         const struct gl_texture_image *texImage =
            _mesa_select_tex_image(ctx, att->Texture, att->Texture->Target,
                                   att->TextureLevel);
         if (texImage) {
            *params = get_component_bits(pname, texImage->_BaseFormat,
                                         texImage->TexFormat);
         }
         else {
            *params = 0;
         }
      }
      else if (att->Renderbuffer) {
         *params = get_component_bits(pname, att->Renderbuffer->_BaseFormat,
                                      att->Renderbuffer->Format);
      }
      else {
         _mesa_problem(ctx, "glGetFramebufferAttachmentParameterivEXT:"
                       " invalid FBO attachment structure");
      }
      return;
   case GL_FRAMEBUFFER_ATTACHMENT_LAYERED:
      if (!_mesa_has_geometry_shaders(ctx)) {
         goto invalid_pname_enum;
      } else if (att->Type == GL_TEXTURE) {
         *params = att->Layered;
      } else if (att->Type == GL_NONE) {
         _mesa_error(ctx, err,
                     "glGetFramebufferAttachmentParameteriv(pname)");
      } else {
         goto invalid_pname_enum;
      }
      return;
   default:
      goto invalid_pname_enum;
   }

   return;

invalid_pname_enum:
   _mesa_error(ctx, GL_INVALID_ENUM,
               "glGetFramebufferAttachmentParameteriv(pname)");
   return;
}


static void
invalidate_framebuffer_storage(GLenum target, GLsizei numAttachments,
                               const GLenum *attachments, GLint x, GLint y,
                               GLsizei width, GLsizei height, const char *name)
{
   int i;
   struct gl_framebuffer *fb;
   GET_CURRENT_CONTEXT(ctx);

   fb = get_framebuffer_target(ctx, target);
   if (!fb) {
      _mesa_error(ctx, GL_INVALID_ENUM, "%s(target)", name);
      return;
   }

   if (numAttachments < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "%s(numAttachments < 0)", name);
      return;
   }

   /* The GL_ARB_invalidate_subdata spec says:
    *
    *     "If an attachment is specified that does not exist in the
    *     framebuffer bound to <target>, it is ignored."
    *
    * It also says:
    *
    *     "If <attachments> contains COLOR_ATTACHMENTm and m is greater than
    *     or equal to the value of MAX_COLOR_ATTACHMENTS, then the error
    *     INVALID_OPERATION is generated."
    *
    * No mention is made of GL_AUXi being out of range.  Therefore, we allow
    * any enum that can be allowed by the API (OpenGL ES 3.0 has a different
    * set of retrictions).
    */
   for (i = 0; i < numAttachments; i++) {
      if (_mesa_is_winsys_fbo(fb)) {
         switch (attachments[i]) {
         case GL_ACCUM:
         case GL_AUX0:
         case GL_AUX1:
         case GL_AUX2:
         case GL_AUX3:
            /* Accumulation buffers and auxilary buffers were removed in
             * OpenGL 3.1, and they never existed in OpenGL ES.
             */
            if (ctx->API != API_OPENGL_COMPAT)
               goto invalid_enum;
            break;
         case GL_COLOR:
         case GL_DEPTH:
         case GL_STENCIL:
            break;
         case GL_BACK_LEFT:
         case GL_BACK_RIGHT:
         case GL_FRONT_LEFT:
         case GL_FRONT_RIGHT:
            if (!_mesa_is_desktop_gl(ctx))
               goto invalid_enum;
            break;
         default:
            goto invalid_enum;
         }
      } else {
         switch (attachments[i]) {
         case GL_DEPTH_ATTACHMENT:
         case GL_STENCIL_ATTACHMENT:
            break;
         case GL_COLOR_ATTACHMENT0:
         case GL_COLOR_ATTACHMENT1:
         case GL_COLOR_ATTACHMENT2:
         case GL_COLOR_ATTACHMENT3:
         case GL_COLOR_ATTACHMENT4:
         case GL_COLOR_ATTACHMENT5:
         case GL_COLOR_ATTACHMENT6:
         case GL_COLOR_ATTACHMENT7:
         case GL_COLOR_ATTACHMENT8:
         case GL_COLOR_ATTACHMENT9:
         case GL_COLOR_ATTACHMENT10:
         case GL_COLOR_ATTACHMENT11:
         case GL_COLOR_ATTACHMENT12:
         case GL_COLOR_ATTACHMENT13:
         case GL_COLOR_ATTACHMENT14:
         case GL_COLOR_ATTACHMENT15: {
            unsigned k = attachments[i] - GL_COLOR_ATTACHMENT0;
            if (k >= ctx->Const.MaxColorAttachments) {
               _mesa_error(ctx, GL_INVALID_OPERATION,
                           "%s(attachment >= max. color attachments)", name);
               return;
            }
            break;
         }
         default:
            goto invalid_enum;
         }
      }
   }

   /* We don't actually do anything for this yet.  Just return after
    * validating the parameters and generating the required errors.
    */
   return;

invalid_enum:
   _mesa_error(ctx, GL_INVALID_ENUM, "%s(attachment)", name);
   return;
}


void GLAPIENTRY
_mesa_InvalidateSubFramebuffer(GLenum target, GLsizei numAttachments,
                               const GLenum *attachments, GLint x, GLint y,
                               GLsizei width, GLsizei height)
{
   invalidate_framebuffer_storage(target, numAttachments, attachments,
                                  x, y, width, height,
                                  "glInvalidateSubFramebuffer");
}


void GLAPIENTRY
_mesa_InvalidateFramebuffer(GLenum target, GLsizei numAttachments,
                            const GLenum *attachments)
{
   /* The GL_ARB_invalidate_subdata spec says:
    *
    *     "The command
    *
    *        void InvalidateFramebuffer(enum target,
    *                                   sizei numAttachments,
    *                                   const enum *attachments);
    *
    *     is equivalent to the command InvalidateSubFramebuffer with <x>, <y>,
    *     <width>, <height> equal to 0, 0, <MAX_VIEWPORT_DIMS[0]>,
    *     <MAX_VIEWPORT_DIMS[1]> respectively."
    */
   invalidate_framebuffer_storage(target, numAttachments, attachments,
                                  0, 0,
                                  MAX_VIEWPORT_WIDTH, MAX_VIEWPORT_HEIGHT,
                                  "glInvalidateFramebuffer");
}


void GLAPIENTRY
_mesa_DiscardFramebufferEXT(GLenum target, GLsizei numAttachments,
                            const GLenum *attachments)
{
   struct gl_framebuffer *fb;
   GLint i;

   GET_CURRENT_CONTEXT(ctx);

   fb = get_framebuffer_target(ctx, target);
   if (!fb) {
      _mesa_error(ctx, GL_INVALID_ENUM,
         "glDiscardFramebufferEXT(target %s)",
         _mesa_lookup_enum_by_nr(target));
      return;
   }

   if (numAttachments < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glDiscardFramebufferEXT(numAttachments < 0)");
      return;
   }

   for (i = 0; i < numAttachments; i++) {
      switch (attachments[i]) {
      case GL_COLOR:
      case GL_DEPTH:
      case GL_STENCIL:
         if (_mesa_is_user_fbo(fb))
            goto invalid_enum;
         break;
      case GL_COLOR_ATTACHMENT0:
      case GL_DEPTH_ATTACHMENT:
      case GL_STENCIL_ATTACHMENT:
         if (_mesa_is_winsys_fbo(fb))
            goto invalid_enum;
         break;
      default:
         goto invalid_enum;
      }
   }

   if (ctx->Driver.DiscardFramebuffer)
      ctx->Driver.DiscardFramebuffer(ctx, target, numAttachments, attachments);

   return;

invalid_enum:
   _mesa_error(ctx, GL_INVALID_ENUM,
               "glDiscardFramebufferEXT(attachment %s)",
              _mesa_lookup_enum_by_nr(attachments[i]));
}
@


1.14
log
@Merge Mesa 10.2.9
@
text
@@


1.13
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d2306 2
a2307 2
 * Common code called by glFramebufferTexture1D/2D/3D() and
 * glFramebufferTextureLayer().
d2329 1
a2329 1
                  "glFramebufferTexture%s(target=0x%x)", caller, target);
d2336 1
a2336 1
                  "glFramebufferTexture%s", caller);
d2400 1
a2400 1
                     "glFramebufferTexture%s(non existant texture)",
d2407 1
a2407 1
                     "glFramebufferTexture%s(texture target mismatch)",
d2416 1
a2416 1
                        "glFramebufferTexture%s(zoffset)", caller);
d2427 1
a2427 1
                        "glFramebufferTexture%s(layer)", caller);
d2436 1
a2436 1
                     "glFramebufferTexture%s(level)", caller);
d2444 1
a2444 1
                  "glFramebufferTexture%s(attachment)", caller);
d2534 1
a2534 1
                     "glFramebufferTexture1D(textarget=%s)",
d2585 1
a2585 1
                     "glFramebufferTexture2D(textarget=%s)",
d2605 1
a2605 1
                  "glFramebufferTexture3D(textarget)");
d2632 1
a2632 1
      framebuffer_texture(ctx, "", target, attachment, 0, texture,
d2654 1
a2654 1
                  "glFramebufferRenderbuffer(target)");
d2660 1
a2660 1
                  "glFramebufferRenderbuffer(renderbufferTarget)");
d2666 1
a2666 1
      _mesa_error(ctx, GL_INVALID_OPERATION, "glFramebufferRenderbuffer");
d2673 1
a2673 1
                  "glFramebufferRenderbuffer(invalid attachment %s)",
d2682 1
a2682 1
		     "glFramebufferRenderbuffer(non-existant"
d2688 1
a2688 1
		     "glFramebufferRenderbuffer(renderbuffer %u)",
d2704 1
a2704 1
                     "glFramebufferRenderbuffer(renderbuffer"
d2737 1
a2737 1
                  "glGetFramebufferAttachmentParameteriv(target)");
d2776 1
a2776 1
                  "glGetFramebufferAttachmentParameteriv(attachment)");
d2800 1
a2800 1
                     "glGetFramebufferAttachmentParameteriv(DEPTH/STENCIL"
d2835 1
a2835 1
                     "glGetFramebufferAttachmentParameteriv(pname)");
d2852 1
a2852 1
                     "glGetFramebufferAttachmentParameteriv(pname)");
d2863 1
a2863 1
                     "glGetFramebufferAttachmentParameteriv(pname)");
d2884 1
a2884 1
                     "glGetFramebufferAttachmentParameteriv(pname)");
d2907 1
a2907 1
                     "glGetFramebufferAttachmentParameteriv(pname)");
d2959 1
a2959 1
                     "glGetFramebufferAttachmentParameteriv(pname)");
@


1.12
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d2306 2
a2307 2
 * Common code called by glFramebufferTexture1D/2D/3DEXT() and
 * glFramebufferTextureLayerEXT().
d2329 1
a2329 1
                  "glFramebufferTexture%sEXT(target=0x%x)", caller, target);
d2336 1
a2336 1
                  "glFramebufferTexture%sEXT", caller);
d2400 1
a2400 1
                     "glFramebufferTexture%sEXT(non existant texture)",
d2407 1
a2407 1
                     "glFramebufferTexture%sEXT(texture target mismatch)",
d2416 1
a2416 1
                        "glFramebufferTexture%sEXT(zoffset)", caller);
d2427 1
a2427 1
                        "glFramebufferTexture%sEXT(layer)", caller);
d2436 1
a2436 1
                     "glFramebufferTexture%sEXT(level)", caller);
d2444 1
a2444 1
                  "glFramebufferTexture%sEXT(attachment)", caller);
d2534 1
a2534 1
                     "glFramebufferTexture1DEXT(textarget=%s)",
d2585 1
a2585 1
                     "glFramebufferTexture2DEXT(textarget=%s)",
d2605 1
a2605 1
                  "glFramebufferTexture3DEXT(textarget)");
d2632 1
a2632 1
      framebuffer_texture(ctx, "Layer", target, attachment, 0, texture,
d2654 1
a2654 1
                  "glFramebufferRenderbufferEXT(target)");
d2660 1
a2660 1
                  "glFramebufferRenderbufferEXT(renderbufferTarget)");
d2666 1
a2666 1
      _mesa_error(ctx, GL_INVALID_OPERATION, "glFramebufferRenderbufferEXT");
d2673 1
a2673 1
                  "glFramebufferRenderbufferEXT(invalid attachment %s)",
d2682 1
a2682 1
		     "glFramebufferRenderbufferEXT(non-existant"
d2688 1
a2688 1
		     "glFramebufferRenderbufferEXT(renderbuffer %u)",
d2704 1
a2704 1
                     "glFramebufferRenderbufferEXT(renderbuffer"
d2737 1
a2737 1
                  "glGetFramebufferAttachmentParameterivEXT(target)");
d2776 1
a2776 1
                  "glGetFramebufferAttachmentParameterivEXT(attachment)");
d2800 1
a2800 1
                     "glGetFramebufferAttachmentParameterivEXT(DEPTH/STENCIL"
d2835 1
a2835 1
                     "glGetFramebufferAttachmentParameterivEXT(pname)");
d2852 1
a2852 1
                     "glGetFramebufferAttachmentParameterivEXT(pname)");
d2863 1
a2863 1
                     "glGetFramebufferAttachmentParameterivEXT(pname)");
d2884 1
a2884 1
                     "glGetFramebufferAttachmentParameterivEXT(pname)");
d2907 1
a2907 1
                     "glGetFramebufferAttachmentParameterivEXT(pname)");
d2959 1
a2959 1
                     "glGetFramebufferAttachmentParameterivEXT(pname)");
@


1.11
log
@Merge Mesa 9.2.2
@
text
@a52 4
/** Set this to 1 to debug/log glBlitFramebuffer() calls */
#define DEBUG_BLIT 0


d92 3
a94 3
   _glthread_INIT_MUTEX(DummyFramebuffer.Mutex);
   _glthread_INIT_MUTEX(DummyRenderbuffer.Mutex);
   _glthread_INIT_MUTEX(IncompleteFramebuffer.Mutex);
d162 1
a162 2
   bool have_fb_blit = _mesa_is_gles3(ctx) ||
      (ctx->Extensions.EXT_framebuffer_blit && _mesa_is_desktop_gl(ctx));
d184 3
a186 3
struct gl_renderbuffer_attachment *
_mesa_get_attachment(struct gl_context *ctx, struct gl_framebuffer *fb,
                     GLenum attachment)
d316 3
a318 3
void
_mesa_remove_attachment(struct gl_context *ctx,
                        struct gl_renderbuffer_attachment *att)
d409 1
d421 7
a427 7
void
_mesa_set_texture_attachment(struct gl_context *ctx,
                             struct gl_framebuffer *fb,
                             struct gl_renderbuffer_attachment *att,
                             struct gl_texture_object *texObj,
                             GLenum texTarget, GLuint level, GLuint zoffset,
                             GLboolean layered)
d440 1
a440 1
      _mesa_remove_attachment(ctx, att);
d462 4
a465 4
void
_mesa_set_renderbuffer_attachment(struct gl_context *ctx,
                                  struct gl_renderbuffer_attachment *att,
                                  struct gl_renderbuffer *rb)
d468 1
a468 1
   _mesa_remove_attachment(ctx, att);
d487 1
a487 1
   _glthread_LOCK_MUTEX(fb->Mutex);
d489 1
a489 1
   att = _mesa_get_attachment(ctx, fb, attachment);
d492 1
a492 1
      _mesa_set_renderbuffer_attachment(ctx, att, rb);
d495 1
a495 1
         att = _mesa_get_attachment(ctx, fb, GL_STENCIL_ATTACHMENT_EXT);
d497 1
a497 1
         _mesa_set_renderbuffer_attachment(ctx, att, rb);
d502 7
a508 1
      _mesa_remove_attachment(ctx, att);
d513 1
a513 1
   _glthread_UNLOCK_MUTEX(fb->Mutex);
d543 1
a543 1
            case MESA_FORMAT_RGB9_E5_FLOAT:
d641 2
a642 1
is_format_color_renderable(const struct gl_context *ctx, gl_format format, GLenum internalFormat)
d674 2
a675 1
   if (format == MESA_FORMAT_ARGB2101010 && internalFormat != GL_RGB10_A2) {
d787 2
a788 3
         else if (ctx->Extensions.EXT_packed_depth_stencil &&
                  ctx->Extensions.ARB_depth_texture &&
                  baseFormat == GL_DEPTH_STENCIL_EXT) {
d799 2
a800 3
         if (ctx->Extensions.EXT_packed_depth_stencil &&
             ctx->Extensions.ARB_depth_texture &&
             baseFormat == GL_DEPTH_STENCIL_EXT) {
d834 1
a834 2
         else if (ctx->Extensions.EXT_packed_depth_stencil &&
                  baseFormat == GL_DEPTH_STENCIL_EXT) {
d845 2
a846 5
         if (baseFormat == GL_STENCIL_INDEX) {
            /* OK */
         }
         else if (ctx->Extensions.EXT_packed_depth_stencil &&
                  baseFormat == GL_DEPTH_STENCIL_EXT) {
d883 5
a887 2
   bool layer_count_valid = false;
   GLuint layer_count = 0, att_layer_count;
d908 2
a909 1
      gl_format attFormat;
d950 1
d959 2
a960 1
         if (!is_format_color_renderable(ctx, attFormat, texImg->InternalFormat) &&
d1064 24
a1087 12
      att_layer_count = att->Layered ? att->Renderbuffer->Depth : 0;
      if (!layer_count_valid) {
         layer_count = att_layer_count;
         layer_count_valid = true;
      } else if (layer_count != att_layer_count) {
         if (layer_count == 0 || att_layer_count == 0) {
            fb->_Status = GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS;
            fbo_incomplete(ctx, "framebuffer attachment layer mode is inconsistent", i);
         } else {
            fb->_Status = GL_FRAMEBUFFER_INCOMPLETE_LAYER_COUNT_ARB;
            fbo_incomplete(ctx, "framebuffer attachment layer count is inconsistent", i);
         }
d1089 2
d1094 7
a1100 1
   fb->Layered = layer_count > 0;
d1107 1
a1107 1
	       = _mesa_get_attachment(ctx, fb, fb->ColorDrawBuffer[j]);
d1120 1
a1120 1
	    = _mesa_get_attachment(ctx, fb, fb->ColorReadBuffer);
a1129 6
   if (numImages == 0) {
      fb->_Status = GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT_EXT;
      fbo_incomplete(ctx, "no attachments", -1);
      return;
   }

d1165 2
a1166 1
      struct gl_renderbuffer *rb = _mesa_lookup_renderbuffer(ctx, renderbuffer);
d1263 1
a1263 1
         _mesa_remove_attachment(ctx, &fb->Attachment[i]);
d1308 2
a1309 2
             * subsection "Attaching Renderbuffer Images to a Framebuffer," of
             * the OpenGL 3.1 spec says:
d1369 1
a1369 1
      _glthread_LOCK_MUTEX(ctx->Shared->Mutex);
d1371 1
a1371 1
      _glthread_UNLOCK_MUTEX(ctx->Shared->Mutex);
d1404 2
a1405 2
      return ctx->API == API_OPENGL_COMPAT && ctx->Extensions.ARB_framebuffer_object
         ? GL_ALPHA : 0;
d1411 2
a1412 2
      return ctx->API == API_OPENGL_COMPAT && ctx->Extensions.ARB_framebuffer_object
         ? GL_LUMINANCE : 0;
d1420 2
a1421 2
      return ctx->API == API_OPENGL_COMPAT && ctx->Extensions.ARB_framebuffer_object
         ? GL_LUMINANCE_ALPHA : 0;
d1427 2
a1428 2
      return ctx->API == API_OPENGL_COMPAT && ctx->Extensions.ARB_framebuffer_object
         ? GL_INTENSITY : 0;
d1469 4
a1472 7
   case GL_DEPTH_STENCIL_EXT:
      return _mesa_is_desktop_gl(ctx)
         && ctx->Extensions.EXT_packed_depth_stencil
         ? GL_DEPTH_STENCIL_EXT : 0;
   case GL_DEPTH24_STENCIL8_EXT:
      return ctx->Extensions.EXT_packed_depth_stencil
         ? GL_DEPTH_STENCIL_EXT : 0;
d1475 2
a1476 1
         || (ctx->API == API_OPENGL_COMPAT && ctx->Extensions.ARB_depth_buffer_float)
d1480 2
a1481 1
         || (ctx->API == API_OPENGL_COMPAT && ctx->Extensions.ARB_depth_buffer_float)
d1524 16
a1583 4
   case GL_RGB9_E5:
      return (_mesa_is_desktop_gl(ctx)
              && ctx->Extensions.EXT_texture_shared_exponent)
         ? GL_RGB : 0;
d1713 1
a1713 1
 * Helper function used by _mesa_RenderbufferStorage() and 
d1869 1
a1869 1
get_component_bits(GLenum pname, GLenum baseFormat, gl_format format)
d2023 3
a2025 2
   if (_mesa_is_winsys_fbo(fb))
      return; /* can't render to texture with winsys framebuffers */
a2047 6
#ifdef DEBUG
   if (ctx->Extensions.ARB_framebuffer_object) {
      ASSERT(ctx->Extensions.EXT_framebuffer_blit);
   }
#endif

a2049 4
      if (!ctx->Extensions.EXT_framebuffer_blit) {
         _mesa_error(ctx, GL_INVALID_ENUM, "glBindFramebufferEXT(target)");
         return;
      }
a2053 4
      if (!ctx->Extensions.EXT_framebuffer_blit) {
         _mesa_error(ctx, GL_INVALID_ENUM, "glBindFramebufferEXT(target)");
         return;
      }
d2161 1
d2172 1
d2189 4
a2192 12
            if (ctx->Extensions.EXT_framebuffer_blit) {
               /* separate draw/read binding points */
               if (fb == ctx->DrawBuffer) {
                  /* bind default */
                  ASSERT(fb->RefCount >= 2);
                  _mesa_BindFramebuffer(GL_DRAW_FRAMEBUFFER_EXT, 0);
               }
               if (fb == ctx->ReadBuffer) {
                  /* bind default */
                  ASSERT(fb->RefCount >= 2);
                  _mesa_BindFramebuffer(GL_READ_FRAMEBUFFER_EXT, 0);
               }
d2194 4
a2197 7
            else {
               /* only one binding point for read/draw buffers */
               if (fb == ctx->DrawBuffer || fb == ctx->ReadBuffer) {
                  /* bind default */
                  ASSERT(fb->RefCount >= 2);
                  _mesa_BindFramebuffer(GL_FRAMEBUFFER_EXT, 0);
               }
d2236 1
a2236 1
      _glthread_LOCK_MUTEX(ctx->Shared->Mutex);
d2238 1
a2238 1
      _glthread_UNLOCK_MUTEX(ctx->Shared->Mutex);
a2242 1

d2262 6
a2267 2
      /* The window system / default framebuffer is always complete */
      return GL_FRAMEBUFFER_COMPLETE_EXT;
d2308 7
a2314 2
 * Note: glFramebufferTextureLayerEXT() has no textarget parameter so we'll
 * get textarget=0 in that case.
d2317 1
a2317 1
framebuffer_texture(struct gl_context *ctx, const char *caller, GLenum target, 
d2349 40
a2388 10
            /* If textarget == 0 it means we're being called by
             * glFramebufferTextureLayer() and textarget is not used.
             * The only legal texture types for that function are 3D and
             * 1D/2D arrays textures.
             */
            err = (texObj->Target != GL_TEXTURE_3D) &&
                (texObj->Target != GL_TEXTURE_1D_ARRAY_EXT) &&
                (texObj->Target != GL_TEXTURE_2D_ARRAY_EXT) &&
                (texObj->Target != GL_TEXTURE_CUBE_MAP_ARRAY) &&
                (texObj->Target != GL_TEXTURE_2D_MULTISAMPLE_ARRAY);
d2441 1
a2441 1
   att = _mesa_get_attachment(ctx, fb, attachment);
d2450 1
a2450 1
   _glthread_LOCK_MUTEX(fb->Mutex);
d2475 1
a2475 1
	 _mesa_set_texture_attachment(ctx, fb, att, texObj, textarget,
d2499 1
a2499 1
      _mesa_remove_attachment(ctx, att);
d2502 1
a2502 1
	 _mesa_remove_attachment(ctx, &fb->Attachment[BUFFER_STENCIL]);
d2508 1
a2508 1
   _glthread_UNLOCK_MUTEX(fb->Mutex);
a2511 1

d2514 1
a2514 1
                              GLenum textarget, GLuint texture, GLint level)
d2547 1
a2547 1
                              GLenum textarget, GLuint texture, GLint level)
d2598 2
a2599 2
                              GLenum textarget, GLuint texture,
                              GLint level, GLint zoffset)
d2616 1
a2616 1
                                 GLuint texture, GLint level, GLint layer)
d2631 1
a2631 1
   if (ctx->Version >= 32 || ctx->Extensions.ARB_geometry_shader4) {
d2643 2
a2644 2
                                 GLenum renderbufferTarget,
                                 GLuint renderbuffer)
d2653 2
a2654 1
      _mesa_error(ctx, GL_INVALID_ENUM, "glFramebufferRenderbufferEXT(target)");
d2670 1
a2670 1
   att = _mesa_get_attachment(ctx, fb, attachment);
d2687 1
a2687 2
         /* This is what NVIDIA does */
	 _mesa_error(ctx, GL_INVALID_VALUE,
a2709 1

d2724 1
a2724 1
                                             GLenum pname, GLint *params)
d2752 2
a2753 1
      if ((!_mesa_is_desktop_gl(ctx) || !ctx->Extensions.ARB_framebuffer_object)
d2771 1
a2771 1
      att = _mesa_get_attachment(ctx, buffer, attachment);
d2781 14
d2796 2
a2797 3
      const struct gl_renderbuffer_attachment *depthAtt, *stencilAtt;
      depthAtt = _mesa_get_attachment(ctx, buffer, GL_DEPTH_ATTACHMENT);
      stencilAtt = _mesa_get_attachment(ctx, buffer, GL_STENCIL_ATTACHMENT);
d2877 2
a2878 1
      if ((!_mesa_is_desktop_gl(ctx) || !ctx->Extensions.ARB_framebuffer_object)
d2888 2
a2889 1
            *params = _mesa_get_format_color_encoding(att->Renderbuffer->Format);
d2899 2
a2900 1
      if ((ctx->API != API_OPENGL_COMPAT || !ctx->Extensions.ARB_framebuffer_object)
d2910 1
a2910 1
         gl_format format = att->Renderbuffer->Format;
d2919 2
a2920 1
         if (_mesa_is_gles3(ctx) && attachment == GL_DEPTH_STENCIL_ATTACHMENT) {
d2928 1
a2928 1
         if (format == MESA_FORMAT_S8) {
d2932 1
a2932 1
         else if (format == MESA_FORMAT_Z32_FLOAT_X24S8) {
d2952 2
a2953 1
      if ((!_mesa_is_desktop_gl(ctx) || !ctx->Extensions.ARB_framebuffer_object)
d2982 12
a3006 561
void GLAPIENTRY
_mesa_GenerateMipmap(GLenum target)
{
   struct gl_texture_image *srcImage;
   struct gl_texture_object *texObj;
   GLboolean error;

   GET_CURRENT_CONTEXT(ctx);

   FLUSH_VERTICES(ctx, 0);

   switch (target) {
   case GL_TEXTURE_1D:
      error = _mesa_is_gles(ctx);
      break;
   case GL_TEXTURE_2D:
      error = GL_FALSE;
      break;
   case GL_TEXTURE_3D:
      error = ctx->API == API_OPENGLES;
      break;
   case GL_TEXTURE_CUBE_MAP:
      error = !ctx->Extensions.ARB_texture_cube_map;
      break;
   case GL_TEXTURE_1D_ARRAY:
      error = _mesa_is_gles(ctx) || !ctx->Extensions.EXT_texture_array;
      break;
   case GL_TEXTURE_2D_ARRAY:
      error = (_mesa_is_gles(ctx) && ctx->Version < 30)
         || !ctx->Extensions.EXT_texture_array;
      break;
   default:
      error = GL_TRUE;
   }

   if (error) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glGenerateMipmapEXT(target=%s)",
                  _mesa_lookup_enum_by_nr(target));
      return;
   }

   texObj = _mesa_get_current_tex_object(ctx, target);

   if (texObj->BaseLevel >= texObj->MaxLevel) {
      /* nothing to do */
      return;
   }

   if (texObj->Target == GL_TEXTURE_CUBE_MAP &&
       !_mesa_cube_complete(texObj)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glGenerateMipmap(incomplete cube map)");
      return;
   }

   _mesa_lock_texture(ctx, texObj);

   srcImage = _mesa_select_tex_image(ctx, texObj, target, texObj->BaseLevel);
   if (!srcImage) {
      _mesa_unlock_texture(ctx, texObj);
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glGenerateMipmap(zero size base image)");
      return;
   }

   if (_mesa_is_enum_format_integer(srcImage->InternalFormat) ||
       _mesa_is_depthstencil_format(srcImage->InternalFormat) ||
       _mesa_is_stencil_format(srcImage->InternalFormat)) {
      _mesa_unlock_texture(ctx, texObj);
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glGenerateMipmap(invalid internal format)");
      return;
   }

   if (target == GL_TEXTURE_CUBE_MAP) {
      GLuint face;
      for (face = 0; face < 6; face++)
	 ctx->Driver.GenerateMipmap(ctx,
				    GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB + face,
				    texObj);
   }
   else {
      ctx->Driver.GenerateMipmap(ctx, target, texObj);
   }
   _mesa_unlock_texture(ctx, texObj);
}


static const struct gl_renderbuffer_attachment *
find_attachment(const struct gl_framebuffer *fb,
                const struct gl_renderbuffer *rb)
{
   GLuint i;
   for (i = 0; i < Elements(fb->Attachment); i++) {
      if (fb->Attachment[i].Renderbuffer == rb)
         return &fb->Attachment[i];
   }
   return NULL;
}


/**
 * Helper function for checking if the datatypes of color buffers are
 * compatible for glBlitFramebuffer.  From the 3.1 spec, page 198:
 *
 * "GL_INVALID_OPERATION is generated if mask contains GL_COLOR_BUFFER_BIT
 *  and any of the following conditions hold:
 *   - The read buffer contains fixed-point or floating-point values and any
 *     draw buffer contains neither fixed-point nor floating-point values.
 *   - The read buffer contains unsigned integer values and any draw buffer
 *     does not contain unsigned integer values.
 *   - The read buffer contains signed integer values and any draw buffer
 *     does not contain signed integer values."
 */
static GLboolean
compatible_color_datatypes(gl_format srcFormat, gl_format dstFormat)
{
   GLenum srcType = _mesa_get_format_datatype(srcFormat);
   GLenum dstType = _mesa_get_format_datatype(dstFormat);

   if (srcType != GL_INT && srcType != GL_UNSIGNED_INT) {
      assert(srcType == GL_UNSIGNED_NORMALIZED ||
             srcType == GL_SIGNED_NORMALIZED ||
             srcType == GL_FLOAT);
      /* Boil any of those types down to GL_FLOAT */
      srcType = GL_FLOAT;
   }

   if (dstType != GL_INT && dstType != GL_UNSIGNED_INT) {
      assert(dstType == GL_UNSIGNED_NORMALIZED ||
             dstType == GL_SIGNED_NORMALIZED ||
             dstType == GL_FLOAT);
      /* Boil any of those types down to GL_FLOAT */
      dstType = GL_FLOAT;
   }

   return srcType == dstType;
}


static GLboolean
compatible_resolve_formats(const struct gl_renderbuffer *readRb,
                           const struct gl_renderbuffer *drawRb)
{
   GLenum readFormat, drawFormat;

   /* The simple case where we know the backing Mesa formats are the same.
    */
   if (_mesa_get_srgb_format_linear(readRb->Format) ==
       _mesa_get_srgb_format_linear(drawRb->Format)) {
      return GL_TRUE;
   }

   /* The Mesa formats are different, so we must check whether the internal
    * formats are compatible.
    *
    * Under some circumstances, the user may request e.g. two GL_RGBA8
    * textures and get two entirely different Mesa formats like RGBA8888 and
    * ARGB8888. Drivers behaving like that should be able to cope with
    * non-matching formats by themselves, because it's not the user's fault.
    *
    * Blits between linear and sRGB formats are also allowed.
    */
   readFormat = _mesa_get_nongeneric_internalformat(readRb->InternalFormat);
   drawFormat = _mesa_get_nongeneric_internalformat(drawRb->InternalFormat);
   readFormat = _mesa_get_linear_internalformat(readFormat);
   drawFormat = _mesa_get_linear_internalformat(drawFormat);

   if (readFormat == drawFormat) {
      return GL_TRUE;
   }

   return GL_FALSE;
}

static GLboolean
is_valid_blit_filter(const struct gl_context *ctx, GLenum filter)
{
   switch (filter) {
   case GL_NEAREST:
   case GL_LINEAR:
      return true;
   case GL_SCALED_RESOLVE_FASTEST_EXT:
   case GL_SCALED_RESOLVE_NICEST_EXT:
      return ctx->Extensions.EXT_framebuffer_multisample_blit_scaled;
   default:
      return false;
   }
}

/**
 * Blit rectangular region, optionally from one framebuffer to another.
 *
 * Note, if the src buffer is multisampled and the dest is not, this is
 * when the samples must be resolved to a single color.
 */
void GLAPIENTRY
_mesa_BlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1,
                         GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1,
                         GLbitfield mask, GLenum filter)
{
   const GLbitfield legalMaskBits = (GL_COLOR_BUFFER_BIT |
                                     GL_DEPTH_BUFFER_BIT |
                                     GL_STENCIL_BUFFER_BIT);
   const struct gl_framebuffer *readFb, *drawFb;
   GET_CURRENT_CONTEXT(ctx);

   FLUSH_VERTICES(ctx, 0);

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx,
                  "glBlitFramebuffer(%d, %d, %d, %d,  %d, %d, %d, %d, 0x%x, %s)\n",
                  srcX0, srcY0, srcX1, srcY1,
                  dstX0, dstY0, dstX1, dstY1,
                  mask, _mesa_lookup_enum_by_nr(filter));

   if (ctx->NewState) {
      _mesa_update_state(ctx);
   }

   readFb = ctx->ReadBuffer;
   drawFb = ctx->DrawBuffer;

   if (!readFb || !drawFb) {
      /* This will normally never happen but someday we may want to
       * support MakeCurrent() with no drawables.
       */
      return;
   }

   /* check for complete framebuffers */
   if (drawFb->_Status != GL_FRAMEBUFFER_COMPLETE_EXT ||
       readFb->_Status != GL_FRAMEBUFFER_COMPLETE_EXT) {
      _mesa_error(ctx, GL_INVALID_FRAMEBUFFER_OPERATION_EXT,
                  "glBlitFramebufferEXT(incomplete draw/read buffers)");
      return;
   }

   if (!is_valid_blit_filter(ctx, filter)) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glBlitFramebufferEXT(%s)",
                  _mesa_lookup_enum_by_nr(filter));
      return;
   }

   if ((filter == GL_SCALED_RESOLVE_FASTEST_EXT ||
        filter == GL_SCALED_RESOLVE_NICEST_EXT) &&
        (readFb->Visual.samples == 0 || drawFb->Visual.samples > 0)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glBlitFramebufferEXT(%s)",
                  _mesa_lookup_enum_by_nr(filter));
      return;
   }

   if (mask & ~legalMaskBits) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glBlitFramebufferEXT(mask)");
      return;
   }

   /* depth/stencil must be blitted with nearest filtering */
   if ((mask & (GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT))
        && filter != GL_NEAREST) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
             "glBlitFramebufferEXT(depth/stencil requires GL_NEAREST filter)");
      return;
   }

   /* get color read/draw renderbuffers */
   if (mask & GL_COLOR_BUFFER_BIT) {
      const GLuint numColorDrawBuffers = ctx->DrawBuffer->_NumColorDrawBuffers;
      const struct gl_renderbuffer *colorReadRb = readFb->_ColorReadBuffer;
      const struct gl_renderbuffer *colorDrawRb = NULL;
      GLuint i;

      /* From the EXT_framebuffer_object spec:
       *
       *     "If a buffer is specified in <mask> and does not exist in both
       *     the read and draw framebuffers, the corresponding bit is silently
       *     ignored."
       */
      if (!colorReadRb || numColorDrawBuffers == 0) {
         mask &= ~GL_COLOR_BUFFER_BIT;
      }
      else {
         for (i = 0; i < numColorDrawBuffers; i++) {
            colorDrawRb = ctx->DrawBuffer->_ColorDrawBuffers[i];
            if (!colorDrawRb)
               continue;

            /* Page 193 (page 205 of the PDF) in section 4.3.2 of the OpenGL
             * ES 3.0.1 spec says:
             *
             *     "If the source and destination buffers are identical, an
             *     INVALID_OPERATION error is generated. Different mipmap
             *     levels of a texture, different layers of a three-
             *     dimensional texture or two-dimensional array texture, and
             *     different faces of a cube map texture do not constitute
             *     identical buffers."
             */
            if (_mesa_is_gles3(ctx) && (colorDrawRb == colorReadRb)) {
               _mesa_error(ctx, GL_INVALID_OPERATION,
                           "glBlitFramebuffer(source and destination color "
                           "buffer cannot be the same)");
               return;
            }

            if (!compatible_color_datatypes(colorReadRb->Format,
                                            colorDrawRb->Format)) {
               _mesa_error(ctx, GL_INVALID_OPERATION,
                           "glBlitFramebufferEXT(color buffer datatypes mismatch)");
               return;
            }
            /* extra checks for multisample copies... */
            if (readFb->Visual.samples > 0 || drawFb->Visual.samples > 0) {
               /* color formats must match */
               if (!compatible_resolve_formats(colorReadRb, colorDrawRb)) {
                  _mesa_error(ctx, GL_INVALID_OPERATION,
                         "glBlitFramebufferEXT(bad src/dst multisample pixel formats)");
                  return;
               }
            }
         }
         if (filter != GL_NEAREST) {
            /* From EXT_framebuffer_multisample_blit_scaled specification:
             * "Calling BlitFramebuffer will result in an INVALID_OPERATION error
             * if filter is not NEAREST and read buffer contains integer data."
             */
            GLenum type = _mesa_get_format_datatype(colorReadRb->Format);
            if (type == GL_INT || type == GL_UNSIGNED_INT) {
               _mesa_error(ctx, GL_INVALID_OPERATION,
                           "glBlitFramebufferEXT(integer color type)");
               return;
            }
         }
      }
   }

   if (mask & GL_STENCIL_BUFFER_BIT) {
      struct gl_renderbuffer *readRb =
         readFb->Attachment[BUFFER_STENCIL].Renderbuffer;
      struct gl_renderbuffer *drawRb =
         drawFb->Attachment[BUFFER_STENCIL].Renderbuffer;

      /* From the EXT_framebuffer_object spec:
       *
       *     "If a buffer is specified in <mask> and does not exist in both
       *     the read and draw framebuffers, the corresponding bit is silently
       *     ignored."
       */
      if ((readRb == NULL) || (drawRb == NULL)) {
	 mask &= ~GL_STENCIL_BUFFER_BIT;
      }
      else {
         int read_z_bits, draw_z_bits;

         if (_mesa_is_gles3(ctx) && (drawRb == readRb)) {
            _mesa_error(ctx, GL_INVALID_OPERATION,
                        "glBlitFramebuffer(source and destination stencil "
                        "buffer cannot be the same)");
            return;
         }

         if (_mesa_get_format_bits(readRb->Format, GL_STENCIL_BITS) !=
             _mesa_get_format_bits(drawRb->Format, GL_STENCIL_BITS)) {
            /* There is no need to check the stencil datatype here, because
             * there is only one: GL_UNSIGNED_INT.
             */
            _mesa_error(ctx, GL_INVALID_OPERATION,
                        "glBlitFramebuffer(stencil attachment format mismatch)");
            return;
         }

         read_z_bits = _mesa_get_format_bits(readRb->Format, GL_DEPTH_BITS);
         draw_z_bits = _mesa_get_format_bits(drawRb->Format, GL_DEPTH_BITS);

         /* If both buffers also have depth data, the depth formats must match
          * as well.  If one doesn't have depth, it's not blitted, so we should
          * ignore the depth format check.
          */
         if (read_z_bits > 0 && draw_z_bits > 0 &&
             (read_z_bits != draw_z_bits ||
              _mesa_get_format_datatype(readRb->Format) !=
              _mesa_get_format_datatype(drawRb->Format))) {

            _mesa_error(ctx, GL_INVALID_OPERATION, "glBlitFramebuffer"
                        "(stencil attachment depth format mismatch)");
            return;
         }
      }
   }

   if (mask & GL_DEPTH_BUFFER_BIT) {
      struct gl_renderbuffer *readRb =
         readFb->Attachment[BUFFER_DEPTH].Renderbuffer;
      struct gl_renderbuffer *drawRb =
         drawFb->Attachment[BUFFER_DEPTH].Renderbuffer;

      /* From the EXT_framebuffer_object spec:
       *
       *     "If a buffer is specified in <mask> and does not exist in both
       *     the read and draw framebuffers, the corresponding bit is silently
       *     ignored."
       */
      if ((readRb == NULL) || (drawRb == NULL)) {
	 mask &= ~GL_DEPTH_BUFFER_BIT;
      }
      else {
         int read_s_bit, draw_s_bit;

         if (_mesa_is_gles3(ctx) && (drawRb == readRb)) {
            _mesa_error(ctx, GL_INVALID_OPERATION,
                        "glBlitFramebuffer(source and destination depth "
                        "buffer cannot be the same)");
            return;
         }

         if ((_mesa_get_format_bits(readRb->Format, GL_DEPTH_BITS) !=
              _mesa_get_format_bits(drawRb->Format, GL_DEPTH_BITS)) ||
             (_mesa_get_format_datatype(readRb->Format) !=
              _mesa_get_format_datatype(drawRb->Format))) {
            _mesa_error(ctx, GL_INVALID_OPERATION,
                        "glBlitFramebuffer(depth attachment format mismatch)");
            return;
         }

         read_s_bit = _mesa_get_format_bits(readRb->Format, GL_STENCIL_BITS);
         draw_s_bit = _mesa_get_format_bits(drawRb->Format, GL_STENCIL_BITS);

         /* If both buffers also have stencil data, the stencil formats must
          * match as well.  If one doesn't have stencil, it's not blitted, so
          * we should ignore the stencil format check.
          */
         if (read_s_bit > 0 && draw_s_bit > 0 && read_s_bit != draw_s_bit) {
            _mesa_error(ctx, GL_INVALID_OPERATION, "glBlitFramebuffer"
                        "(depth attachment stencil bits mismatch)");
            return;
         }
      }
   }


   if (_mesa_is_gles3(ctx)) {
      /* Page 194 (page 206 of the PDF) in section 4.3.2 of the OpenGL ES
       * 3.0.1 spec says:
       *
       *     "If SAMPLE_BUFFERS for the draw framebuffer is greater than zero,
       *     an INVALID_OPERATION error is generated."
       */
      if (drawFb->Visual.samples > 0) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glBlitFramebuffer(destination samples must be 0)");
         return;
      }

      /* Page 194 (page 206 of the PDF) in section 4.3.2 of the OpenGL ES
       * 3.0.1 spec says:
       *
       *     "If SAMPLE_BUFFERS for the read framebuffer is greater than zero,
       *     no copy is performed and an INVALID_OPERATION error is generated
       *     if the formats of the read and draw framebuffers are not
       *     identical or if the source and destination rectangles are not
       *     defined with the same (X0, Y0) and (X1, Y1) bounds."
       *
       * The format check was made above because desktop OpenGL has the same
       * requirement.
       */
      if (readFb->Visual.samples > 0
          && (srcX0 != dstX0 || srcY0 != dstY0
              || srcX1 != dstX1 || srcY1 != dstY1)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glBlitFramebuffer(bad src/dst multisample region)");
         return;
      }
   } else {
      if (readFb->Visual.samples > 0 &&
          drawFb->Visual.samples > 0 &&
          readFb->Visual.samples != drawFb->Visual.samples) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glBlitFramebufferEXT(mismatched samples)");
         return;
      }

      /* extra checks for multisample copies... */
      if ((readFb->Visual.samples > 0 || drawFb->Visual.samples > 0) &&
          (filter == GL_NEAREST || filter == GL_LINEAR)) {
         /* src and dest region sizes must be the same */
         if (abs(srcX1 - srcX0) != abs(dstX1 - dstX0) ||
             abs(srcY1 - srcY0) != abs(dstY1 - dstY0)) {
            _mesa_error(ctx, GL_INVALID_OPERATION,
                        "glBlitFramebufferEXT(bad src/dst multisample region sizes)");
            return;
         }
      }
   }

   if (!ctx->Extensions.EXT_framebuffer_blit) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glBlitFramebufferEXT");
      return;
   }

   /* Debug code */
   if (DEBUG_BLIT) {
      const struct gl_renderbuffer *colorReadRb = readFb->_ColorReadBuffer;
      const struct gl_renderbuffer *colorDrawRb = NULL;
      GLuint i = 0;

      printf("glBlitFramebuffer(%d, %d, %d, %d,  %d, %d, %d, %d,"
	     " 0x%x, 0x%x)\n",
	     srcX0, srcY0, srcX1, srcY1,
	     dstX0, dstY0, dstX1, dstY1,
	     mask, filter);
      if (colorReadRb) {
         const struct gl_renderbuffer_attachment *att;

         att = find_attachment(readFb, colorReadRb);
         printf("  Src FBO %u  RB %u (%dx%d)  ",
		readFb->Name, colorReadRb->Name,
		colorReadRb->Width, colorReadRb->Height);
         if (att && att->Texture) {
            printf("Tex %u  tgt 0x%x  level %u  face %u",
		   att->Texture->Name,
		   att->Texture->Target,
		   att->TextureLevel,
		   att->CubeMapFace);
         }
         printf("\n");

         /* Print all active color render buffers */
         for (i = 0; i < ctx->DrawBuffer->_NumColorDrawBuffers; i++) {
            colorDrawRb = ctx->DrawBuffer->_ColorDrawBuffers[i];
            if (!colorDrawRb)
               continue;

            att = find_attachment(drawFb, colorDrawRb);
            printf("  Dst FBO %u  RB %u (%dx%d)  ",
		   drawFb->Name, colorDrawRb->Name,
		   colorDrawRb->Width, colorDrawRb->Height);
            if (att && att->Texture) {
               printf("Tex %u  tgt 0x%x  level %u  face %u",
		      att->Texture->Name,
		      att->Texture->Target,
		      att->TextureLevel,
		      att->CubeMapFace);
            }
            printf("\n");
         }
      }
   }

   if (!mask ||
       (srcX1 - srcX0) == 0 || (srcY1 - srcY0) == 0 ||
       (dstX1 - dstX0) == 0 || (dstY1 - dstY0) == 0) {
      return;
   }

   ASSERT(ctx->Driver.BlitFramebuffer);
   ctx->Driver.BlitFramebuffer(ctx,
                               srcX0, srcY0, srcX1, srcY1,
                               dstX0, dstY0, dstX1, dstY1,
                               mask, filter);
}


d3116 1
d3127 1
d3145 2
a3146 1
                                  0, 0, MAX_VIEWPORT_WIDTH, MAX_VIEWPORT_HEIGHT,
d3149 1
@


1.10
log
@Merge Mesa 9.2.0
@
text
@d3584 1
@


1.9
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a2 1
 * Version:  7.1
d20 4
a23 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
d34 1
d42 1
d45 1
a45 1
#include "mfeatures.h"
a52 3
/** Set this to 1 to help debug FBO incompleteness problems */
#define DEBUG_FBO 0

a79 28
static INLINE GLboolean
is_cube_face(GLenum target)
{
   return (target >= GL_TEXTURE_CUBE_MAP_POSITIVE_X &&
           target <= GL_TEXTURE_CUBE_MAP_NEGATIVE_Z);
}


/**
 * Is the given FBO a user-created FBO?
 */
static INLINE GLboolean
is_user_fbo(const struct gl_framebuffer *fb)
{
   return fb->Name != 0;
}


/**
 * Is the given FBO a window system FBO (like an X window)?
 */
static INLINE GLboolean
is_winsys_fbo(const struct gl_framebuffer *fb)
{
   return fb->Name == 0;
}


d81 1
a81 1
delete_dummy_renderbuffer(struct gl_renderbuffer *rb)
d166 2
d170 1
a170 1
      return ctx->Extensions.EXT_framebuffer_blit ? ctx->DrawBuffer : NULL;
d172 1
a172 1
      return ctx->Extensions.EXT_framebuffer_blit ? ctx->ReadBuffer : NULL;
d195 1
a195 1
   assert(is_user_fbo(fb));
d214 4
d219 2
a220 1
      if (i >= ctx->Const.MaxColorAttachments) {
d225 2
a227 2
   case GL_DEPTH_BUFFER:
      /* fall-through / new in GL 3.0 */
a229 2
   case GL_STENCIL_BUFFER:
      /* fall-through / new in GL 3.0 */
d246 20
a265 1
   assert(is_winsys_fbo(fb));
d281 26
a306 3
   case GL_DEPTH_BUFFER:
      /* fall-through / new in GL 3.0 */
   case GL_DEPTH_ATTACHMENT_EXT:
d308 1
a308 3
   case GL_STENCIL_BUFFER:
      /* fall-through / new in GL 3.0 */
   case GL_STENCIL_ATTACHMENT_EXT:
d325 6
a332 4
      if (ctx->Driver.FinishRenderTexture) {
         /* tell driver that we're done rendering to this texture. */
         ctx->Driver.FinishRenderTexture(ctx, att);
      }
d345 75
d430 2
a431 1
                             GLenum texTarget, GLuint level, GLuint zoffset)
d433 5
a440 2
      if (ctx->Driver.FinishRenderTexture)
	 ctx->Driver.FinishRenderTexture(ctx, att);
a443 2
      if (ctx->Driver.FinishRenderTexture && att->Texture)
	 ctx->Driver.FinishRenderTexture(ctx, att);
d449 1
d455 1
d458 1
a458 5
   if (_mesa_get_attachment_teximage(att)) {
      ctx->Driver.RenderTexture(ctx, fb, att);
   }

   invalidate_framebuffer(fb);
d554 26
d585 3
a587 5
#if DEBUG_FBO
   _mesa_debug(NULL, "attachment incomplete: %s\n", msg);
#else
   (void) msg;
#endif
d595 1
a595 1
fbo_incomplete(const char *msg, int index)
d597 10
a606 6
#if DEBUG_FBO
   _mesa_debug(NULL, "FBO Incomplete: %s [%d]\n", msg, index);
#else
   (void) msg;
   (void) index;
#endif
d624 2
a625 1
      return ctx->Extensions.ARB_framebuffer_object;
d636 44
a729 2
         printf("texobj = %u\n", texObj->Name);
         printf("level = %d\n", att->TextureLevel);
d733 30
a762 4
      if (texObj->Target == GL_TEXTURE_3D && att->Zoffset >= texImage->Depth) {
         att_incomplete("bad z offset");
         att->Complete = GL_FALSE;
         return;
d882 1
d885 2
d888 4
a891 1
   assert(is_user_fbo(fb));
d896 2
d921 1
a921 1
            fbo_incomplete("depth attachment incomplete", -1);
d930 1
a930 1
            fbo_incomplete("stencil attachment incomplete", -1);
d939 1
a939 1
            fbo_incomplete("color attachment incomplete", i);
d947 1
a947 2
         const struct gl_texture_image *texImg =
            _mesa_get_attachment_teximage(att);
d955 2
a956 1
         if (!_mesa_is_legal_color_format(ctx, f) &&
d959 17
a975 1
            fbo_incomplete("texture attachment incomplete", -1);
d987 17
a1009 5
      if (att->Renderbuffer && numSamples < 0) {
         /* first buffer */
         numSamples = att->Renderbuffer->NumSamples;
      }

d1013 14
a1026 2
      /* Error-check width, height, format, samples
       */
d1028 1
a1028 1
         /* save format, num samples */
d1038 1
a1038 1
               fbo_incomplete("width or height mismatch", -1);
d1041 1
a1041 1
            /* check that all color buffer have same format */
d1044 1
a1044 1
               fbo_incomplete("format mismatch", -1);
d1048 10
a1057 6
         if (att->Renderbuffer &&
             att->Renderbuffer->NumSamples != numSamples) {
            fb->_Status = GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE;
            fbo_incomplete("inconsistant number of samples", i);
            return;
         }            
d1059 14
d1076 3
a1078 2
#if FEATURE_GL
   if (ctx->API == API_OPENGL && !ctx->Extensions.ARB_ES2_compatibility) {
d1087 1
a1087 1
	       fbo_incomplete("missing drawbuffer", j);
d1100 1
a1100 1
            fbo_incomplete("missing readbuffer", -1);
a1104 3
#else
   (void) j;
#endif
d1108 1
a1108 1
      fbo_incomplete("no attachments", -1);
d1122 1
a1122 1
         fbo_incomplete("driver marked FBO as incomplete", -1);
d1142 1
a1142 1
_mesa_IsRenderbufferEXT(GLuint renderbuffer)
d1155 2
a1156 2
void GLAPIENTRY
_mesa_BindRenderbufferEXT(GLenum target, GLuint renderbuffer)
a1160 2
   ASSERT_OUTSIDE_BEGIN_END(ctx);

d1176 1
a1176 1
      else if (!newRb && ctx->Extensions.ARB_framebuffer_object) {
d1203 21
d1226 11
a1236 9
 * If the given renderbuffer is anywhere attached to the framebuffer, detach
 * the renderbuffer.
 * This is used when a renderbuffer object is deleted.
 * The spec calls for unbinding.
 */
static void
detach_renderbuffer(struct gl_context *ctx,
                    struct gl_framebuffer *fb,
                    struct gl_renderbuffer *rb)
d1238 3
a1240 1
   GLuint i;
d1242 2
a1243 1
      if (fb->Attachment[i].Renderbuffer == rb) {
d1245 1
d1248 17
a1264 1
   invalidate_framebuffer(fb);
d1269 1
a1269 1
_mesa_DeleteRenderbuffersEXT(GLsizei n, const GLuint *renderbuffers)
a1273 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d1285 1
a1285 1
               _mesa_BindRenderbufferEXT(GL_RENDERBUFFER_EXT, 0);
d1288 19
a1306 2
            if (is_user_fbo(ctx->DrawBuffer)) {
               detach_renderbuffer(ctx, ctx->DrawBuffer, rb);
d1308 1
a1308 1
            if (is_user_fbo(ctx->ReadBuffer)
d1310 1
a1310 1
               detach_renderbuffer(ctx, ctx->ReadBuffer, rb);
d1330 1
a1330 1
_mesa_GenRenderbuffersEXT(GLsizei n, GLuint *renderbuffers)
a1335 2
   ASSERT_OUTSIDE_BEGIN_END(ctx);

d1385 2
a1386 1
      return ctx->Extensions.ARB_framebuffer_object ? GL_ALPHA : 0;
d1392 2
a1393 1
      return ctx->Extensions.ARB_framebuffer_object ? GL_LUMINANCE : 0;
d1401 2
a1402 1
      return ctx->Extensions.ARB_framebuffer_object ? GL_LUMINANCE_ALPHA : 0;
d1408 4
a1411 1
      return ctx->Extensions.ARB_framebuffer_object ? GL_INTENSITY : 0;
a1415 1
   case GL_RGB8:
d1419 1
d1421 1
a1421 3
      return GL_RGB;
   case GL_RGBA:
   case GL_RGBA2:
d1425 3
a1427 1
   case GL_RGB10_A2:
d1430 2
d1433 1
a1433 1
      return GL_RGBA;
d1437 5
a1442 1
   case GL_STENCIL_INDEX16_EXT:
d1445 2
a1448 1
   case GL_DEPTH_COMPONENT32:
d1451 3
d1455 10
a1464 4
      if (ctx->Extensions.EXT_packed_depth_stencil)
         return GL_DEPTH_STENCIL_EXT;
      else
         return 0;
d1466 3
d1470 2
a1471 2
   case GL_R16:
      return ctx->Extensions.ARB_texture_rg ? GL_RED : 0;
d1473 3
d1477 2
a1478 2
   case GL_RG16:
      return ctx->Extensions.ARB_texture_rg ? GL_RG : 0;
d1483 2
a1484 1
      return ctx->Extensions.EXT_texture_snorm ? GL_RED : 0;
d1488 2
a1489 1
      return ctx->Extensions.EXT_texture_snorm ? GL_RG : 0;
d1493 2
a1494 1
      return ctx->Extensions.EXT_texture_snorm ? GL_RGB : 0;
d1498 2
a1499 1
      return ctx->Extensions.EXT_texture_snorm ? GL_RGBA : 0;
d1503 2
a1504 1
      return ctx->Extensions.EXT_texture_snorm &&
a1505 15
   case GL_LUMINANCE_SNORM:
   case GL_LUMINANCE8_SNORM:
   case GL_LUMINANCE16_SNORM:
      return ctx->Extensions.EXT_texture_snorm &&
             ctx->Extensions.ARB_framebuffer_object ? GL_LUMINANCE : 0;
   case GL_LUMINANCE_ALPHA_SNORM:
   case GL_LUMINANCE8_ALPHA8_SNORM:
   case GL_LUMINANCE16_ALPHA16_SNORM:
      return ctx->Extensions.EXT_texture_snorm &&
             ctx->Extensions.ARB_framebuffer_object ? GL_LUMINANCE_ALPHA : 0;
   case GL_INTENSITY_SNORM:
   case GL_INTENSITY8_SNORM:
   case GL_INTENSITY16_SNORM:
      return ctx->Extensions.EXT_texture_snorm &&
             ctx->Extensions.ARB_framebuffer_object ? GL_INTENSITY : 0;
d1508 5
a1512 2
      return ctx->Extensions.ARB_texture_rg &&
             ctx->Extensions.ARB_texture_float ? GL_RED : 0;
d1515 5
a1519 2
      return ctx->Extensions.ARB_texture_rg &&
             ctx->Extensions.ARB_texture_float ? GL_RG : 0;
d1522 2
a1523 1
      return ctx->Extensions.ARB_texture_float ? GL_RGB : 0;
d1526 4
a1529 1
      return ctx->Extensions.ARB_texture_float ? GL_RGBA : 0;
d1532 2
a1533 1
      return ctx->Extensions.ARB_texture_float &&
d1537 2
a1538 1
      return ctx->Extensions.ARB_texture_float &&
d1542 2
a1543 1
      return ctx->Extensions.ARB_texture_float &&
d1547 2
a1548 1
      return ctx->Extensions.ARB_texture_float &&
d1551 3
a1553 1
      return ctx->Extensions.EXT_texture_shared_exponent ? GL_RGB : 0;
d1555 92
a1646 2
      return ctx->Extensions.EXT_packed_float ? GL_RGB : 0;
   /* XXX add integer formats eventually */
d1663 1
a1663 1
   if (is_user_fbo(fb)) {
d1683 1
a1683 1
 * Helper function used by _mesa_RenderbufferStorageEXT() and 
d1685 1
a1685 1
 * samples will be NO_SAMPLES if called by _mesa_RenderbufferStorageEXT().
d1692 1
a1692 1
      "glRenderbufferStorage" : "RenderbufferStorageMultisample";
d1695 1
d1698 14
a1711 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d1720 2
a1721 1
      _mesa_error(ctx, GL_INVALID_ENUM, "%s(internalFormat)", func);
d1725 1
a1725 1
   if (width < 1 || width > (GLsizei) ctx->Const.MaxRenderbufferSize) {
d1730 1
a1730 1
   if (height < 1 || height > (GLsizei) ctx->Const.MaxRenderbufferSize) {
d1739 10
a1748 4
   else if (samples > (GLsizei) ctx->Const.MaxSamples) {
      /* note: driver may choose to use more samples than what's requested */
      _mesa_error(ctx, GL_INVALID_VALUE, "%s(samples)", func);
      return;
d1761 2
a1762 1
       rb->Height == (GLuint) height) {
d1775 1
a1775 1
      assert(rb->Format != MESA_FORMAT_NONE);
a1798 1
#if FEATURE_OES_EGL_image
a1803 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
a1827 1
#endif
d1831 2
a1832 2
 * Helper function for _mesa_GetRenderbufferParameterivEXT() and
 * _mesa_GetFramebufferAttachmentParameterivEXT()
d1841 10
a1850 48
   switch (pname) {
   case GL_RENDERBUFFER_RED_SIZE_EXT:
   case GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE:
      if (baseFormat == GL_RGB || baseFormat == GL_RGBA ||
	  baseFormat == GL_RG || baseFormat == GL_RED)
         return _mesa_get_format_bits(format, pname);
      else
         return 0;
   case GL_RENDERBUFFER_GREEN_SIZE_EXT:
   case GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE:
      if (baseFormat == GL_RGB || baseFormat == GL_RGBA || baseFormat == GL_RG)
         return _mesa_get_format_bits(format, pname);
      else
         return 0;
   case GL_RENDERBUFFER_BLUE_SIZE_EXT:
   case GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE:
      if (baseFormat == GL_RGB || baseFormat == GL_RGBA)
         return _mesa_get_format_bits(format, pname);
      else
         return 0;
   case GL_RENDERBUFFER_ALPHA_SIZE_EXT:
   case GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE:
      if (baseFormat == GL_RGBA || baseFormat == GL_ALPHA ||
	  baseFormat == GL_LUMINANCE_ALPHA)
         return _mesa_get_format_bits(format, pname);
      else
         return 0;
   case GL_RENDERBUFFER_DEPTH_SIZE_EXT:
   case GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE:
      if (baseFormat == GL_DEPTH_COMPONENT || baseFormat == GL_DEPTH_STENCIL)
         return _mesa_get_format_bits(format, pname);
      else
         return 0;
   case GL_RENDERBUFFER_STENCIL_SIZE_EXT:
   case GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE:
      if (baseFormat == GL_STENCIL_INDEX || baseFormat == GL_DEPTH_STENCIL)
         return _mesa_get_format_bits(format, pname);
      else
         return 0;
   default:
      return 0;
   }
}



void GLAPIENTRY
_mesa_RenderbufferStorageEXT(GLenum target, GLenum internalFormat,
d1892 1
a1892 1
_mesa_GetRenderbufferParameterivEXT(GLenum target, GLenum pname, GLint *params)
a1896 2
   ASSERT_OUTSIDE_BEGIN_END(ctx);

d1933 2
a1934 1
      if (ctx->Extensions.ARB_framebuffer_object) {
d1948 1
a1948 1
_mesa_IsFramebufferEXT(GLuint framebuffer)
d1972 1
a1972 1
   if (is_winsys_fbo(fb))
d1977 2
a1978 1
      if (att->Texture && _mesa_get_attachment_teximage(att)) {
d1993 1
a1993 1
   if (is_winsys_fbo(fb))
d2000 3
a2002 2
         if (att->Texture && att->Renderbuffer) {
            ctx->Driver.FinishRenderTexture(ctx, att);
d2009 2
a2010 2
void GLAPIENTRY
_mesa_BindFramebufferEXT(GLenum target, GLuint framebuffer)
a2018 1
      ASSERT(ctx->Extensions.EXT_framebuffer_object);
a2022 8
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   if (!ctx->Extensions.EXT_framebuffer_object) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glBindFramebufferEXT(unsupported)");
      return;
   }

a2023 1
#if FEATURE_EXT_framebuffer_blit
a2039 1
#endif
d2056 1
a2056 1
      else if (!newDrawFb && ctx->Extensions.ARB_framebuffer_object) {
d2118 2
a2119 5
      /* check if old read/draw buffers were render-to-texture */
      if (!bindReadBuf)
         check_end_texture_render(ctx, oldReadFb);

      if (oldDrawFb != oldReadFb)
d2133 20
d2155 1
a2155 1
_mesa_DeleteFramebuffersEXT(GLsizei n, const GLuint *framebuffers)
a2159 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d2175 1
a2175 1
                  _mesa_BindFramebufferEXT(GL_DRAW_FRAMEBUFFER_EXT, 0);
d2180 1
a2180 1
                  _mesa_BindFramebufferEXT(GL_READ_FRAMEBUFFER_EXT, 0);
d2188 2
a2189 2
                  _mesa_BindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
               }    
d2208 1
a2208 1
_mesa_GenFramebuffersEXT(GLsizei n, GLuint *framebuffers)
a2213 2
   ASSERT_OUTSIDE_BEGIN_END(ctx);

d2237 1
a2237 1
_mesa_CheckFramebufferStatusEXT(GLenum target)
d2244 4
d2254 1
a2254 1
   if (is_winsys_fbo(buffer)) {
d2269 24
d2295 4
a2298 1
 * Common code called by glFramebufferTexture1D/2D/3DEXT().
d2303 1
a2303 1
                    GLint level, GLint zoffset)
d2308 1
a2308 2

   ASSERT_OUTSIDE_BEGIN_END(ctx);
d2318 1
a2318 1
   if (is_winsys_fbo(fb)) {
a2323 1

d2333 5
a2337 1
            /* XXX what's the purpose of this? */
d2340 3
a2342 1
                (texObj->Target != GL_TEXTURE_2D_ARRAY_EXT);
d2345 1
d2347 1
a2347 1
                ? !is_cube_face(textarget)
d2375 5
a2379 2
               (texObj->Target == GL_TEXTURE_2D_ARRAY_EXT)) {
         if (zoffset < 0 || zoffset >= ctx->Const.MaxArrayTextureLayers) {
d2386 3
a2388 2
      if ((level < 0) || 
          (level >= _mesa_max_texture_levels(ctx, texObj->Target))) {
d2406 36
a2441 2
      _mesa_set_texture_attachment(ctx, fb, att, texObj, textarget,
                                   level, zoffset);
d2454 4
d2468 1
a2468 1
_mesa_FramebufferTexture1DEXT(GLenum target, GLenum attachment,
d2473 20
a2492 4
   if ((texture != 0) && (textarget != GL_TEXTURE_1D)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glFramebufferTexture1DEXT(textarget)");
      return;
d2496 1
a2496 1
                       level, 0);
d2501 1
a2501 1
_mesa_FramebufferTexture2DEXT(GLenum target, GLenum attachment,
d2506 38
a2543 7
   if ((texture != 0) &&
       (textarget != GL_TEXTURE_2D) &&
       (textarget != GL_TEXTURE_RECTANGLE_ARB) &&
       (!is_cube_face(textarget))) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glFramebufferTexture2DEXT(textarget=0x%x)", textarget);
      return;
d2547 1
a2547 1
                       level, 0);
d2552 1
a2552 1
_mesa_FramebufferTexture3DEXT(GLenum target, GLenum attachment,
d2565 1
a2565 1
                       level, zoffset);
d2570 1
a2570 1
_mesa_FramebufferTextureLayerEXT(GLenum target, GLenum attachment,
d2576 1
a2576 1
                       level, layer);
d2581 17
a2597 1
_mesa_FramebufferRenderbufferEXT(GLenum target, GLenum attachment,
a2605 2
   ASSERT_OUTSIDE_BEGIN_END(ctx);

d2618 1
a2618 1
   if (is_winsys_fbo(fb)) {
d2679 1
a2679 1
_mesa_GetFramebufferAttachmentParameterivEXT(GLenum target, GLenum attachment,
d2687 2
a2688 4
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   /* The error differs in GL andd GLES. */
   err = ctx->API == API_OPENGL ? GL_INVALID_OPERATION : GL_INVALID_ENUM;
d2697 24
a2720 1
   if (is_winsys_fbo(buffer)) {
d2752 2
a2753 1
      *params = is_winsys_fbo(buffer) ? GL_FRAMEBUFFER_DEFAULT : att->Type;
d2764 1
a2764 1
         if (ctx->API == API_OPENGL) {
d2767 1
a2767 2
            _mesa_error(ctx, GL_INVALID_ENUM,
                        "glGetFramebufferAttachmentParameterivEXT(pname)");
d2780 1
a2780 2
	 _mesa_error(ctx, GL_INVALID_ENUM,
		     "glGetFramebufferAttachmentParameterivEXT(pname)");
d2797 1
a2797 2
	 _mesa_error(ctx, GL_INVALID_ENUM,
		     "glGetFramebufferAttachmentParameterivEXT(pname)");
d2801 6
a2806 1
      if (att->Type == GL_TEXTURE) {
a2813 4
      else if (att->Type == GL_NONE) {
         _mesa_error(ctx, err,
                     "glGetFramebufferAttachmentParameterivEXT(pname)");
      }
d2815 1
a2815 2
	 _mesa_error(ctx, GL_INVALID_ENUM,
		     "glGetFramebufferAttachmentParameterivEXT(pname)");
d2819 3
a2821 3
      if (!ctx->Extensions.ARB_framebuffer_object) {
         _mesa_error(ctx, GL_INVALID_ENUM,
                     "glGetFramebufferAttachmentParameterivEXT(pname)");
d2828 1
a2828 1
         if (ctx->Extensions.EXT_framebuffer_sRGB && ctx->Const.sRGBCapable) {
d2839 4
a2842 4
      if (!ctx->Extensions.ARB_framebuffer_object) {
         _mesa_error(ctx, GL_INVALID_ENUM,
                     "glGetFramebufferAttachmentParameterivEXT(pname)");
         return;
d2850 17
a2866 1
         if (format == MESA_FORMAT_CI8 || format == MESA_FORMAT_S8) {
d2870 9
d2890 3
a2892 3
      if (!ctx->Extensions.ARB_framebuffer_object) {
         _mesa_error(ctx, GL_INVALID_ENUM,
                     "glGetFramebufferAttachmentParameterivEXT(pname)");
d2920 1
a2920 3
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "glGetFramebufferAttachmentParameterivEXT(pname)");
      return;
d2922 7
d2933 1
a2933 1
_mesa_GenerateMipmapEXT(GLenum target)
d2935 1
d2937 2
d2941 1
a2941 2
   ASSERT_OUTSIDE_BEGIN_END(ctx);
   FLUSH_VERTICES(ctx, _NEW_BUFFERS);
d2945 2
d2948 2
d2951 2
d2954 8
a2961 1
      /* OK, legal value */
d2964 6
a2969 2
      /* XXX need to implement GL_TEXTURE_1D_ARRAY and GL_TEXTURE_2D_ARRAY */
      _mesa_error(ctx, GL_INVALID_ENUM, "glGenerateMipmapEXT(target)");
d2988 18
a3019 2
#if FEATURE_EXT_framebuffer_blit

d3033 88
d3129 1
a3129 1
_mesa_BlitFramebufferEXT(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1,
a3136 1
   const struct gl_renderbuffer *colorReadRb, *colorDrawRb;
d3139 1
a3139 2
   ASSERT_OUTSIDE_BEGIN_END(ctx);
   FLUSH_VERTICES(ctx, _NEW_BUFFERS);
d3170 11
a3180 2
   if (filter != GL_NEAREST && filter != GL_LINEAR) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glBlitFramebufferEXT(filter)");
d3199 4
a3202 2
      colorReadRb = readFb->_ColorReadBuffer;
      colorDrawRb = drawFb->_ColorDrawBuffers[0];
d3210 54
a3263 3
      if ((colorReadRb == NULL) || (colorDrawRb == NULL)) {
	 colorReadRb = colorDrawRb = NULL;
	 mask &= ~GL_COLOR_BUFFER_BIT;
a3265 3
   else {
      colorReadRb = colorDrawRb = NULL;
   }
d3268 4
a3271 2
      struct gl_renderbuffer *readRb = readFb->_StencilBuffer;
      struct gl_renderbuffer *drawRb = drawFb->_StencilBuffer;
a3279 1
	 readRb = drawRb = NULL;
d3282 36
a3317 5
      else if (_mesa_get_format_bits(readRb->Format, GL_STENCIL_BITS) !=
	       _mesa_get_format_bits(drawRb->Format, GL_STENCIL_BITS)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glBlitFramebufferEXT(stencil buffer size mismatch)");
         return;
d3322 4
a3325 2
      struct gl_renderbuffer *readRb = readFb->_DepthBuffer;
      struct gl_renderbuffer *drawRb = drawFb->_DepthBuffer;
a3333 1
	 readRb = drawRb = NULL;
d3336 31
a3366 5
      else if (_mesa_get_format_bits(readRb->Format, GL_DEPTH_BITS) !=
	       _mesa_get_format_bits(drawRb->Format, GL_DEPTH_BITS)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glBlitFramebufferEXT(depth buffer size mismatch)");
         return;
a3369 7
   if (readFb->Visual.samples > 0 &&
       drawFb->Visual.samples > 0 &&
       readFb->Visual.samples != drawFb->Visual.samples) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glBlitFramebufferEXT(mismatched samples");
      return;
   }
d3371 8
a3378 5
   /* extra checks for multisample copies... */
   if (readFb->Visual.samples > 0 || drawFb->Visual.samples > 0) {
      /* src and dest region sizes must be the same */
      if (srcX1 - srcX0 != dstX1 - dstX0 ||
          srcY1 - srcY0 != dstY1 - dstY0) {
d3380 1
a3380 1
                "glBlitFramebufferEXT(bad src/dst multisample region sizes)");
d3384 23
a3406 4
      /* color formats must match */
      if (colorReadRb &&
          colorDrawRb &&
          colorReadRb->Format != colorDrawRb->Format) {
d3408 1
a3408 1
                "glBlitFramebufferEXT(bad src/dst multisample pixel formats)");
d3411 12
d3432 4
d3457 18
a3474 10
         att = find_attachment(drawFb, colorDrawRb);
         printf("  Dst FBO %u  RB %u (%dx%d)  ",
		drawFb->Name, colorDrawRb->Name,
		colorDrawRb->Width, colorDrawRb->Height);
         if (att && att->Texture) {
            printf("Tex %u  tgt 0x%x  level %u  face %u",
		   att->Texture->Name,
		   att->Texture->Target,
		   att->TextureLevel,
		   att->CubeMapFace);
a3475 1
         printf("\n");
d3479 3
a3481 1
   if (!mask) {
a3490 1
#endif /* FEATURE_EXT_framebuffer_blit */
d3492 119
a3610 1
#if FEATURE_ARB_geometry_shader4
d3612 2
a3613 2
_mesa_FramebufferTextureARB(GLenum target, GLenum attachment,
                            GLuint texture, GLint level)
d3615 15
a3629 4
   GET_CURRENT_CONTEXT(ctx);
   _mesa_error(ctx, GL_INVALID_OPERATION,
               "glFramebufferTextureARB "
               "not implemented!");
d3633 2
a3634 2
_mesa_FramebufferTextureFaceARB(GLenum target, GLenum attachment,
                                GLuint texture, GLint level, GLenum face)
d3636 3
d3640 43
a3682 3
   _mesa_error(ctx, GL_INVALID_OPERATION,
               "glFramebufferTextureFaceARB "
               "not implemented!");
a3683 1
#endif /* FEATURE_ARB_geometry_shader4 */
@


1.8
log
@Merge Mesa 7.10.3
@
text
@d43 2
d81 26
a106 3
#define IS_CUBE_FACE(TARGET) \
   ((TARGET) >= GL_TEXTURE_CUBE_MAP_POSITIVE_X && \
    (TARGET) <= GL_TEXTURE_CUBE_MAP_NEGATIVE_Z)
d186 23
d222 1
a222 1
   assert(fb->Name > 0);
d270 1
a270 1
   assert(fb->Name == 0);
d361 1
a361 1
   if (att->Texture->Image[att->CubeMapFace][att->TextureLevel]) {
d423 38
d492 2
a493 2
static GLboolean
is_legal_color_format(const struct gl_context *ctx, GLenum baseFormat)
d578 1
a578 1
         if (!is_legal_color_format(ctx, baseFormat)) {
d632 1
a632 2
         if (baseFormat != GL_RGB &&
             baseFormat != GL_RGBA) {
d695 1
a695 1
   assert(fb->Name != 0);
d709 1
a709 1
      gl_format mesaFormat;
d749 2
a750 2
         const struct gl_texture_image *texImg
            = att->Texture->Image[att->CubeMapFace][att->TextureLevel];
d756 1
a756 1
         mesaFormat = texImg->TexFormat;
d758 1
a758 1
         if (!is_legal_color_format(ctx, f) &&
d771 1
a771 1
         mesaFormat = att->Renderbuffer->Format;
d785 1
a785 1
      fb->_IntegerColor = _mesa_is_format_integer_color(mesaFormat);
d821 1
a821 1
   if (ctx->API == API_OPENGL) {
d882 1
a882 1
      _mesa_update_framebuffer_visual(fb);
d994 1
a994 1
            if (ctx->DrawBuffer->Name) {
d997 2
a998 1
            if (ctx->ReadBuffer->Name && ctx->ReadBuffer != ctx->DrawBuffer) {
d1050 3
a1052 3
 * corresponding base format.
 * This is very similar to _mesa_base_tex_format() but the set of valid
 * internal formats is somewhat different.
d1054 2
a1055 2
 * \return one of GL_RGB, GL_RGBA, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT
 *  GL_DEPTH_STENCIL_EXT or zero if error.
d1057 5
a1061 2
 * XXX in the future when we support red-only and red-green formats
 * we'll also return GL_RED and GL_RG.
d1066 4
d1076 21
a1096 1
      return GL_ALPHA;
d1105 1
d1115 1
a1115 1
   case GL_RGBA16_SNORM:
d1134 80
a1213 1
   /* XXX add floating point formats eventually */
d1230 1
a1230 1
   if (fb->Name) {
d1392 5
d1399 4
d1411 2
a1412 1
      if (baseFormat == GL_RGBA || baseFormat == GL_ALPHA)
d1559 1
a1559 1
   if (fb->Name == 0)
d1564 1
a1564 3
      struct gl_texture_object *texObj = att->Texture;
      if (texObj
          && texObj->Image[att->CubeMapFace][att->TextureLevel]) {
d1579 1
a1579 1
   if (fb->Name == 0)
d1826 2
a1827 21
   switch (target) {
#if FEATURE_EXT_framebuffer_blit
   case GL_DRAW_FRAMEBUFFER_EXT:
      if (!ctx->Extensions.EXT_framebuffer_blit) {
         _mesa_error(ctx, GL_INVALID_ENUM, "glCheckFramebufferStatus(target)");
         return 0;
      }
      buffer = ctx->DrawBuffer;
      break;
   case GL_READ_FRAMEBUFFER_EXT:
      if (!ctx->Extensions.EXT_framebuffer_blit) {
         _mesa_error(ctx, GL_INVALID_ENUM, "glCheckFramebufferStatus(target)");
         return 0;
      }
      buffer = ctx->ReadBuffer;
      break;
#endif
   case GL_FRAMEBUFFER_EXT:
      buffer = ctx->DrawBuffer;
      break;
   default:
d1829 1
a1829 1
      return 0; /* formerly GL_FRAMEBUFFER_STATUS_ERROR_EXT */
d1832 1
a1832 1
   if (buffer->Name == 0) {
a1858 1
   GLboolean error = GL_FALSE;
d1862 2
a1863 16
   switch (target) {
   case GL_READ_FRAMEBUFFER_EXT:
      error = !ctx->Extensions.EXT_framebuffer_blit;
      fb = ctx->ReadBuffer;
      break;
   case GL_DRAW_FRAMEBUFFER_EXT:
      error = !ctx->Extensions.EXT_framebuffer_blit;
      /* fall-through */
   case GL_FRAMEBUFFER_EXT:
      fb = ctx->DrawBuffer;
      break;
   default:
      error = GL_TRUE;
   }

   if (error) {
a1868 2
   ASSERT(fb);

d1870 1
a1870 1
   if (fb->Name == 0) {
d1893 1
a1893 1
                ? !IS_CUBE_FACE(textarget)
d1978 1
a1978 1
      _mesa_error(ctx, GL_INVALID_ENUM,
d1997 1
a1997 1
       (!IS_CUBE_FACE(textarget))) {
d2016 1
a2016 1
      _mesa_error(ctx, GL_INVALID_ENUM,
d2049 3
a2051 25
   switch (target) {
#if FEATURE_EXT_framebuffer_blit
   case GL_DRAW_FRAMEBUFFER_EXT:
      if (!ctx->Extensions.EXT_framebuffer_blit) {
         _mesa_error(ctx, GL_INVALID_ENUM,
                     "glFramebufferRenderbufferEXT(target)");
         return;
      }
      fb = ctx->DrawBuffer;
      break;
   case GL_READ_FRAMEBUFFER_EXT:
      if (!ctx->Extensions.EXT_framebuffer_blit) {
         _mesa_error(ctx, GL_INVALID_ENUM,
                     "glFramebufferRenderbufferEXT(target)");
         return;
      }
      fb = ctx->ReadBuffer;
      break;
#endif
   case GL_FRAMEBUFFER_EXT:
      fb = ctx->DrawBuffer;
      break;
   default:
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "glFramebufferRenderbufferEXT(target)");
d2061 1
a2061 1
   if (fb->Name == 0) {
d2117 1
a2117 1
   _mesa_update_framebuffer_visual(fb);
d2127 1
d2132 5
a2136 23
   switch (target) {
#if FEATURE_EXT_framebuffer_blit
   case GL_DRAW_FRAMEBUFFER_EXT:
      if (!ctx->Extensions.EXT_framebuffer_blit) {
         _mesa_error(ctx, GL_INVALID_ENUM,
                     "glGetFramebufferAttachmentParameterivEXT(target)");
         return;
      }
      buffer = ctx->DrawBuffer;
      break;
   case GL_READ_FRAMEBUFFER_EXT:
      if (!ctx->Extensions.EXT_framebuffer_blit) {
         _mesa_error(ctx, GL_INVALID_ENUM,
                     "glGetFramebufferAttachmentParameterivEXT(target)");
         return;
      }
      buffer = ctx->ReadBuffer;
      break;
#endif
   case GL_FRAMEBUFFER_EXT:
      buffer = ctx->DrawBuffer;
      break;
   default:
d2142 1
a2142 1
   if (buffer->Name == 0) {
d2174 1
a2174 1
      *params = buffer->Name == 0 ? GL_FRAMEBUFFER_DEFAULT : att->Type;
d2185 6
a2190 1
         *params = 0;
d2198 1
a2198 1
         _mesa_error(ctx, GL_INVALID_OPERATION,
d2216 1
a2216 1
         _mesa_error(ctx, GL_INVALID_OPERATION,
d2234 1
a2234 1
         _mesa_error(ctx, GL_INVALID_OPERATION,
d2248 1
a2248 1
         _mesa_error(ctx, GL_INVALID_OPERATION,
d2252 8
a2259 1
         *params = _mesa_get_format_color_encoding(att->Renderbuffer->Format);
d2269 1
a2269 1
         _mesa_error(ctx, GL_INVALID_OPERATION,
d2294 1
a2294 1
         _mesa_error(ctx, GL_INVALID_OPERATION,
d2380 2
a2381 1
find_attachment(const struct gl_framebuffer *fb, const struct gl_renderbuffer *rb)
d2414 7
d2457 1
a2457 1
             "glBlitFramebufferEXT(depth/stencil requires GL_NEAREST filter");
d2498 1
a2498 1
                     "glBlitFramebufferEXT(stencil buffer size mismatch");
d2520 1
a2520 1
                     "glBlitFramebufferEXT(depth buffer size mismatch");
d2539 1
a2539 1
                "glBlitFramebufferEXT(bad src/dst multisample region sizes");
d2548 1
a2548 1
                "glBlitFramebufferEXT(bad src/dst multisample pixel formats");
@


1.7
log
@Update to Mesa 7.8.2. Tested by johan@@. Thanks.
@
text
@d74 4
d98 1
a98 1
_mesa_init_fbobjects(GLcontext *ctx)
d100 3
d105 1
d108 5
d118 1
a118 1
_mesa_lookup_renderbuffer(GLcontext *ctx, GLuint id)
d135 1
a135 1
_mesa_lookup_framebuffer(GLcontext *ctx, GLuint id)
d163 2
d169 1
a169 1
_mesa_get_attachment(GLcontext *ctx, struct gl_framebuffer *fb,
d174 2
d200 40
d242 2
d252 1
d258 2
a259 1
_mesa_remove_attachment(GLcontext *ctx, struct gl_renderbuffer_attachment *att)
d285 1
a285 1
_mesa_set_texture_attachment(GLcontext *ctx,
d326 1
a326 1
_mesa_set_renderbuffer_attachment(GLcontext *ctx,
d344 2
a345 1
_mesa_framebuffer_renderbuffer(GLcontext *ctx, struct gl_framebuffer *fb,
d362 1
d403 38
d450 1
a450 1
test_attachment_completeness(const GLcontext *ctx, GLenum format,
d492 1
a492 2
         if (baseFormat != GL_RGB &&
             baseFormat != GL_RGBA) {
d600 2
a601 1
_mesa_test_framebuffer_completeness(GLcontext *ctx, struct gl_framebuffer *fb)
d624 1
d671 1
d673 2
a674 2
         if (f != GL_RGB && f != GL_RGBA && f != GL_DEPTH_COMPONENT
             && f != GL_DEPTH_STENCIL_EXT) {
d686 1
d694 1
a694 1
      if (numSamples < 0) {
d699 3
d735 14
a748 12
#ifndef FEATURE_OES_framebuffer_object
   /* Check that all DrawBuffers are present */
   for (j = 0; j < ctx->Const.MaxDrawBuffers; j++) {
      if (fb->ColorDrawBuffer[j] != GL_NONE) {
         const struct gl_renderbuffer_attachment *att
            = _mesa_get_attachment(ctx, fb, fb->ColorDrawBuffer[j]);
         assert(att);
         if (att->Type == GL_NONE) {
            fb->_Status = GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER_EXT;
            fbo_incomplete("missing drawbuffer", j);
            return;
         }
a749 1
   }
d751 7
a757 7
   /* Check that the ReadBuffer is present */
   if (fb->ColorReadBuffer != GL_NONE) {
      const struct gl_renderbuffer_attachment *att
         = _mesa_get_attachment(ctx, fb, fb->ColorReadBuffer);
      assert(att);
      if (att->Type == GL_NONE) {
         fb->_Status = GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER_EXT;
d759 2
a760 1
         return;
d874 1
a874 1
detach_renderbuffer(GLcontext *ctx,
d975 1
a975 1
_mesa_base_fbo_format(GLcontext *ctx, GLenum internalFormat)
d978 6
d1001 1
d1027 25
d1106 1
a1106 1
      _mesa_error(ctx, GL_INVALID_OPERATION, func);
d1144 4
a1147 6
   /*
   test_framebuffer_completeness(ctx, fb);
   */
   /* XXX if this renderbuffer is attached anywhere, invalidate attachment
    * points???
    */
d1150 1
d1153 1
a1153 1
_mesa_EGLImageTargetRenderbufferStorageOES (GLenum target, GLeglImageOES image)
d1159 6
d1166 2
a1167 1
      _mesa_error(ctx, GL_INVALID_ENUM, "EGLImageTargetRenderbufferStorageOES");
d1173 2
a1174 1
      _mesa_error(ctx, GL_INVALID_OPERATION, "EGLImageTargetRenderbufferStorageOES");
d1184 1
d1253 20
d1351 1
a1351 1
check_begin_texture_render(GLcontext *ctx, struct gl_framebuffer *fb)
d1376 1
a1376 1
check_end_texture_render(GLcontext *ctx, struct gl_framebuffer *fb)
d1670 1
a1670 1
framebuffer_texture(GLcontext *ctx, const char *caller, GLenum target, 
d1721 1
d1732 7
d1940 7
d2017 6
a2022 3
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glGetFramebufferAttachmentParameterivEXT");
      return;
a2024 1
   att = _mesa_get_attachment(ctx, buffer, attachment);
d2048 1
a2048 1
      *params = att->Type;
d2058 2
a2059 2
	 _mesa_error(ctx, GL_INVALID_ENUM,
		     "glGetFramebufferAttachmentParameterivEXT(pname)");
d2066 4
d2084 4
d2102 4
d2116 4
d2130 4
d2155 4
d2176 2
a2177 1
         *params = 0;
d2205 1
d2217 7
d2319 11
d2338 13
a2350 4
      if (!readRb ||
          !drawRb ||
          _mesa_get_format_bits(readRb->Format, GL_STENCIL_BITS) != 
          _mesa_get_format_bits(drawRb->Format, GL_STENCIL_BITS)) {
d2360 13
a2372 4
      if (!readRb ||
          !drawRb ||
          _mesa_get_format_bits(readRb->Format, GL_DEPTH_BITS) != 
          _mesa_get_format_bits(drawRb->Format, GL_DEPTH_BITS)) {
d2450 4
d2461 22
@


1.6
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d1769 2
a1770 1
   if (attachment == GL_DEPTH_STENCIL_ATTACHMENT) {
d1772 1
a1772 2
      const GLenum baseFormat =
         _mesa_get_format_base_format(att->Renderbuffer->Format);
@


1.5
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d6 1
d28 2
d37 1
d39 1
d42 1
a42 1
#include "mipmap.h"
d47 7
a53 1
#include "texstore.h"
d136 12
d150 2
d181 2
d203 1
a203 1
         /* tell driver we're done rendering to this texobj */
d233 2
d238 2
d248 1
a248 6
   if (IS_CUBE_FACE(texTarget)) {
      att->CubeMapFace = texTarget - GL_TEXTURE_CUBE_MAP_POSITIVE_X;
   }
   else {
      att->CubeMapFace = 0;
   }
d255 2
d294 6
d305 2
d312 31
d361 1
d364 1
d371 1
d376 3
d383 1
d388 2
d391 8
a398 2
         if (texImage->TexFormat->BaseFormat != GL_RGB &&
             texImage->TexFormat->BaseFormat != GL_RGBA) {
d404 1
a404 1
         if (texImage->TexFormat->BaseFormat == GL_DEPTH_COMPONENT) {
d408 2
a409 1
                  texImage->TexFormat->BaseFormat == GL_DEPTH_STENCIL_EXT) {
d414 1
d419 12
a430 3
         /* no such thing as stencil textures */
         att->Complete = GL_FALSE;
         return;
d434 3
d441 1
d446 3
a448 5
         if (att->Renderbuffer->_BaseFormat != GL_RGB &&
             att->Renderbuffer->_BaseFormat != GL_RGBA) {
            ASSERT(att->Renderbuffer->RedBits);
            ASSERT(att->Renderbuffer->GreenBits);
            ASSERT(att->Renderbuffer->BlueBits);
d454 1
a454 2
         ASSERT(att->Renderbuffer->DepthBits);
         if (att->Renderbuffer->_BaseFormat == GL_DEPTH_COMPONENT) {
d458 1
a458 1
                  att->Renderbuffer->_BaseFormat == GL_DEPTH_STENCIL_EXT) {
d462 1
d469 1
a469 2
         ASSERT(att->Renderbuffer->StencilBits);
         if (att->Renderbuffer->_BaseFormat == GL_STENCIL_INDEX) {
d473 1
a473 1
                  att->Renderbuffer->_BaseFormat == GL_DEPTH_STENCIL_EXT) {
d478 1
a491 14
 * Helpful for debugging
 */
static void
fbo_incomplete(const char *msg, int index)
{
   (void) msg;
   (void) index;
   /*
   _mesa_debug(NULL, "FBO Incomplete: %s [%d]\n", msg, index);
   */
}


/**
d494 2
d502 4
a505 3
   GLuint numImages, width = 0, height = 0;
   GLenum intFormat = GL_NONE;
   GLuint w = 0, h = 0;
d515 5
a519 1
   /* Start at -2 to more easily loop over all attachment points */
d524 7
d559 2
d564 4
a567 2
         w = texImg->Width;
         h = texImg->Height;
d578 4
a581 2
         w = att->Renderbuffer->Width;
         h = att->Renderbuffer->Height;
d590 7
d598 2
a599 4
         /* set required width, height and format */
         width = w;
         height = h;
         if (i >= 0)
d601 1
d604 13
a616 5
         /* check that width, height, format are same */
         if (w != width || h != height) {
            fb->_Status = GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS_EXT;
            fbo_incomplete("width or height mismatch", -1);
            return;
d618 4
a621 3
         if (intFormat != GL_NONE && f != intFormat) {
            fb->_Status = GL_FRAMEBUFFER_INCOMPLETE_FORMATS_EXT;
            fbo_incomplete("format mismatch", -1);
d623 2
a624 1
         }
d654 2
d664 6
a669 2
   /*
    * If we get here, the framebuffer is complete!
d671 19
a689 3
   fb->_Status = GL_FRAMEBUFFER_COMPLETE_EXT;
   fb->Width = w;
   fb->Height = h;
d716 1
a716 2
         _mesa_error(ctx, GL_INVALID_ENUM,
                  "glBindRenderbufferEXT(target)");
d720 2
a721 3
   FLUSH_VERTICES(ctx, _NEW_BUFFERS);
   /* The above doesn't fully flush the drivers in the way that a
    * glFlush does, but that is required here:
a722 3
   if (ctx->Driver.Flush)
      ctx->Driver.Flush(ctx);

d730 6
d758 21
d800 7
d861 3
d911 12
a922 3
void GLAPIENTRY
_mesa_RenderbufferStorageEXT(GLenum target, GLenum internalFormat,
                             GLsizei width, GLsizei height)
d924 2
d933 1
a933 1
      _mesa_error(ctx, GL_INVALID_ENUM, "glRenderbufferStorageEXT(target)");
d939 1
a939 2
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "glRenderbufferStorageEXT(internalFormat)");
d944 1
a944 1
      _mesa_error(ctx, GL_INVALID_VALUE, "glRenderbufferStorageEXT(width)");
d949 11
a959 1
      _mesa_error(ctx, GL_INVALID_VALUE, "glRenderbufferStorageEXT(height)");
a963 1

d965 1
a965 1
      _mesa_error(ctx, GL_INVALID_OPERATION, "glRenderbufferStorageEXT");
d979 2
a980 8
   rb->_ActualFormat = 0;
   rb->RedBits =
   rb->GreenBits =
   rb->BlueBits =
   rb->AlphaBits =
   rb->IndexBits =
   rb->DepthBits =
   rb->StencilBits = 0;
d986 1
a986 1
      assert(rb->_ActualFormat);
a988 2
      assert(rb->RedBits || rb->GreenBits || rb->BlueBits || rb->AlphaBits ||
             rb->DepthBits || rb->StencilBits || rb->IndexBits);
d991 1
d997 1
a998 1
      rb->_ActualFormat = GL_NONE;
d1000 1
a1000 7
      rb->RedBits =
      rb->GreenBits =
      rb->BlueBits =
      rb->AlphaBits =
      rb->IndexBits =
      rb->DepthBits =
      rb->StencilBits = 0;
d1011 93
d1108 1
d1119 2
a1120 1
   if (!ctx->CurrentRenderbuffer) {
d1126 3
a1128 1
   FLUSH_VERTICES(ctx, _NEW_BUFFERS);
d1132 1
a1132 1
      *params = ctx->CurrentRenderbuffer->Width;
d1135 1
a1135 1
      *params = ctx->CurrentRenderbuffer->Height;
d1138 1
a1138 1
      *params = ctx->CurrentRenderbuffer->InternalFormat;
a1140 2
      *params = ctx->CurrentRenderbuffer->RedBits;
      break;
a1141 2
      *params = ctx->CurrentRenderbuffer->GreenBits;
      break;
a1142 2
      *params = ctx->CurrentRenderbuffer->BlueBits;
      break;
a1143 2
      *params = ctx->CurrentRenderbuffer->AlphaBits;
      break;
a1144 2
      *params = ctx->CurrentRenderbuffer->DepthBits;
      break;
d1146 1
a1146 1
      *params = ctx->CurrentRenderbuffer->StencilBits;
d1148 6
d1176 5
d1186 4
d1194 1
a1194 1
          && att->Texture->Image[att->CubeMapFace][att->TextureLevel]) {
d1209 3
d1227 2
a1228 1
   struct gl_framebuffer *newFb, *newFbread;
d1232 7
a1274 6
   FLUSH_VERTICES(ctx, _NEW_BUFFERS);

   if (ctx->Driver.Flush) {  
      ctx->Driver.Flush(ctx);
   }

d1277 2
a1278 2
      newFb = _mesa_lookup_framebuffer(ctx, framebuffer);
      if (newFb == &DummyFramebuffer) {
d1280 1
a1280 1
         newFb = NULL;
d1282 7
a1288 1
      if (!newFb) {
d1290 2
a1291 2
	 newFb = ctx->Driver.NewFramebuffer(ctx, framebuffer);
	 if (!newFb) {
d1295 1
a1295 1
         _mesa_HashInsert(ctx->Shared->FrameBuffers, framebuffer, newFb);
d1297 1
a1297 1
      newFbread = newFb;
d1303 2
a1304 2
      newFb = ctx->WinSysDrawBuffer;
      newFbread = ctx->WinSysReadBuffer;
d1307 12
a1318 2
   ASSERT(newFb);
   ASSERT(newFb != &DummyFramebuffer);
d1321 10
a1330 1
    * XXX check if re-binding same buffer and skip some of this code.
d1332 2
d1335 4
a1338 2
   if (bindReadBuf) {
      _mesa_reference_framebuffer(&ctx->ReadBuffer, newFbread);
d1342 1
a1342 2
      /* check if old FB had any texture attachments */
      check_end_texture_render(ctx, ctx->DrawBuffer);
d1344 3
a1346 2
      /* check if time to delete this framebuffer */
      _mesa_reference_framebuffer(&ctx->DrawBuffer, newFb);
d1348 7
a1354 4
      if (newFb->Name != 0) {
         /* check if newly bound framebuffer has any texture attachments */
         check_begin_texture_render(ctx, newFb);
      }
d1357 2
a1358 2
   if (ctx->Driver.BindFramebuffer) {
      ctx->Driver.BindFramebuffer(ctx, target, newFb, newFbread);
a1370 5
   /* The above doesn't fully flush the drivers in the way that a
    * glFlush does, but that is required here:
    */
   if (ctx->Driver.Flush)
      ctx->Driver.Flush(ctx);
d1380 20
a1399 4
            if (fb == ctx->DrawBuffer) {
               /* bind default */
               ASSERT(fb->RefCount >= 2);
               _mesa_BindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
d1409 1
a1409 1
               _mesa_unreference_framebuffer(&fb);
d1486 5
a1490 1
   FLUSH_VERTICES(ctx, _NEW_BUFFERS);
a1491 1
   _mesa_test_framebuffer_completeness(ctx, buffer);
d1508 1
d1512 16
a1527 1
   if (target != GL_FRAMEBUFFER_EXT) {
d1529 1
a1529 1
                  "glFramebufferTexture%sEXT(target)", caller);
a1532 1
   fb = ctx->DrawBuffer;
a1586 1

a1602 5
   /* The above doesn't fully flush the drivers in the way that a
    * glFlush does, but that is required here:
    */
   if (ctx->Driver.Flush)
      ctx->Driver.Flush(ctx);
d1608 9
d1621 3
d1657 1
a1657 1
                  "glFramebufferTexture2DEXT(textarget)");
d1750 2
a1751 1
                 "glFramebufferRenderbufferEXT(attachment)");
d1759 2
a1760 1
		     "glFramebufferRenderbufferEXT(renderbuffer)");
d1769 13
a1782 5
   /* The above doesn't fully flush the drivers in the way that a
    * glFlush does, but that is required here:
    */
   if (ctx->Driver.Flush)
      ctx->Driver.Flush(ctx);
d1845 14
a1858 6
   FLUSH_VERTICES(ctx, _NEW_BUFFERS);
   /* The above doesn't fully flush the drivers in the way that a
    * glFlush does, but that is required here:
    */
   if (ctx->Driver.Flush)
      ctx->Driver.Flush(ctx);
d1913 56
a1979 1
   struct gl_texture_unit *texUnit;
d1998 6
a2003 2
   texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
   texObj = _mesa_select_tex_object(ctx, texUnit, target);
d2007 1
a2007 2
      int face;

d2012 2
a2013 1
   } else {
d2021 20
d2046 5
d2060 8
a2067 2
   if (!ctx->ReadBuffer) {
      /* XXX */
d2071 2
a2072 2
   if (ctx->DrawBuffer->_Status != GL_FRAMEBUFFER_COMPLETE_EXT ||
       ctx->ReadBuffer->_Status != GL_FRAMEBUFFER_COMPLETE_EXT) {
d2083 1
a2083 3
   if (mask & ~(GL_COLOR_BUFFER_BIT |
                GL_DEPTH_BUFFER_BIT |
                GL_STENCIL_BUFFER_BIT)) {
d2096 9
d2106 6
a2111 3
      struct gl_renderbuffer *readRb = ctx->ReadBuffer->_StencilBuffer;
      struct gl_renderbuffer *drawRb = ctx->DrawBuffer->_StencilBuffer;
      if (readRb->StencilBits != drawRb->StencilBits) {
d2119 6
a2124 3
      struct gl_renderbuffer *readRb = ctx->ReadBuffer->_DepthBuffer;
      struct gl_renderbuffer *drawRb = ctx->DrawBuffer->_DepthBuffer;
      if (readRb->DepthBits != drawRb->DepthBits) {
d2131 28
d2162 38
@


1.4
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d511 1
d537 1
a1576 1
   /* XXX this might not handle cube maps correctly */
d1578 10
a1587 1
   ctx->Driver.GenerateMipmap(ctx, target, texObj);
@


1.3
log
@Update to Mesa 7.0.3. tested my oga@@ and johan@@
@
text
@d3 1
a3 1
 * Version:  6.5.1
d5 1
a5 1
 * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
d32 1
d69 21
a182 1
      ASSERT(att->Renderbuffer);
d932 1
a932 2
         struct gl_texture_object *texObj = att->Texture;
         if (texObj) {
d943 1
a943 1
   struct gl_framebuffer *newFb;
d984 1
d988 1
a1003 1
         ASSERT(newFb->RefCount == 1);
d1005 1
d1012 1
d1023 1
a1023 1
      _mesa_reference_framebuffer(&ctx->ReadBuffer, newFb);
d1030 1
a1030 1
      /* bind new drawing buffer */
d1040 1
a1040 1
      ctx->Driver.BindFramebuffer(ctx, target, newFb);
d1204 10
a1213 3
         err = (texObj->Target == GL_TEXTURE_CUBE_MAP)
             ? !IS_CUBE_FACE(textarget)
             : (texObj->Target != textarget);
d1227 9
a1235 2
                        "glFramebufferTexture%sEXT(zoffset)", 
                        caller);
d1240 1
d1332 11
d1516 6
a1521 1
	 *params = GL_TEXTURE_CUBE_MAP_POSITIVE_X + att->CubeMapFace;
d1530 6
a1535 1
	 *params = att->Zoffset;
d1577 1
a1577 1
   _mesa_generate_mipmap(ctx, target, texUnit, texObj);
@


1.2
log
@Update to Mesa 7.0.2. Tested by naddy@@ (full ports build), simon@@
and oga@@ (with dri enabled).
@
text
@d305 1
a305 1
                  att->Renderbuffer->_BaseFormat == GL_DEPTH_STENCIL_EXT) {
@


1.1
log
@Initial revision
@
text
@d36 1
d153 3
a155 3
      att->Texture->RefCount--;
      if (att->Texture->RefCount == 0) {
	 ctx->Driver.DeleteTexture(ctx, att->Texture);
d157 2
a158 7
      else {
         /* tell driver that we're done rendering to this texture. */
         if (ctx->Driver.FinishRenderTexture) {
            ctx->Driver.FinishRenderTexture(ctx, att);
         }
      }
      att->Texture = NULL;
d163 2
a164 5
      att->Renderbuffer->RefCount--;
      if (att->Renderbuffer->RefCount == 0) {
         att->Renderbuffer->Delete(att->Renderbuffer);
      }
      att->Renderbuffer = NULL;
d190 2
a191 2
      att->Texture = texObj;
      texObj->RefCount++;
a222 1
   att->Renderbuffer = rb;
d225 1
a225 1
   rb->RefCount++;
a239 2
   if (rb)
      _glthread_LOCK_MUTEX(rb->Mutex);
a242 1

a249 2
   if (rb)
      _glthread_UNLOCK_MUTEX(rb->Mutex);
d548 1
a548 1
   struct gl_renderbuffer *newRb, *oldRb;
d560 6
d582 1
a583 1
      newRb->RefCount++;
a588 5
   oldRb = ctx->CurrentRenderbuffer;
   if (oldRb) {
      _mesa_dereference_renderbuffer(&oldRb);
   }

d591 1
a591 1
   ctx->CurrentRenderbuffer = newRb;
d616 4
a619 1
	    /* remove from hash table immediately, to free the ID */
d623 2
a624 4
               /* But the object will not be freed until it's no longer
                * bound in any context.
                */
               _mesa_dereference_renderbuffer(&rb);
d923 1
a923 1
   struct gl_framebuffer *newFb, *oldFb;
d964 3
a966 1

d982 1
a983 6
      _glthread_LOCK_MUTEX(newFb->Mutex);
      if (bindReadBuf)
         newFb->RefCount++;
      if (bindDrawBuf)
         newFb->RefCount++;
      _glthread_UNLOCK_MUTEX(newFb->Mutex);
d1000 1
a1000 5
      oldFb = ctx->ReadBuffer;
      if (oldFb && oldFb->Name != 0) {
         _mesa_dereference_framebuffer(&oldFb);
      }
      ctx->ReadBuffer = newFb;
d1004 6
a1009 8
      oldFb = ctx->DrawBuffer;
      if (oldFb && oldFb->Name != 0) {
         /* check if old FB had any texture attachments */
         check_end_texture_render(ctx, oldFb);
         /* check if time to delete this framebuffer */
         _mesa_dereference_framebuffer(&oldFb);
      }
      ctx->DrawBuffer = newFb;
d1030 5
d1057 1
a1057 1
               _mesa_dereference_framebuffer(&fb);
d1146 2
a1147 2
framebuffer_texture(GLuint dims, GLenum target, GLenum attachment,
                    GLenum textarget, GLuint texture,
a1152 1
   GET_CURRENT_CONTEXT(ctx);
d1158 1
a1158 1
                  "glFramebufferTexture%dDEXT(target)", dims);
d1168 1
a1168 1
                  "glFramebufferTexture%dDEXT", dims);
d1172 4
d1177 2
d1180 5
a1184 1
   }
d1186 1
a1186 9
   /* Check dimension-dependent things */
   switch (dims) {
   case 1:
      if (textarget != GL_TEXTURE_1D) {
         _mesa_error(ctx, GL_INVALID_ENUM,
                     "glFramebufferTexture1DEXT(textarget)");
         return;
      }
      if (texObj && texObj->Target != GL_TEXTURE_1D) {
d1188 2
a1189 1
                     "glFramebufferTexture1DEXT(texture target mismatch)");
d1192 2
a1193 33
      break;
   case 2:
      if (textarget != GL_TEXTURE_2D &&
          textarget != GL_TEXTURE_RECTANGLE_ARB &&
          !IS_CUBE_FACE(textarget)) {
         _mesa_error(ctx, GL_INVALID_ENUM,
                     "glFramebufferTexture2DEXT(textarget)");
         return;
      }
      if (texObj) {
         if ((texObj->Target == GL_TEXTURE_2D && textarget != GL_TEXTURE_2D) ||
             (texObj->Target == GL_TEXTURE_RECTANGLE_ARB
              && textarget != GL_TEXTURE_RECTANGLE_ARB) ||
             (texObj->Target == GL_TEXTURE_CUBE_MAP
              && !IS_CUBE_FACE(textarget))) {
            _mesa_error(ctx, GL_INVALID_OPERATION,
                        "glFramebufferTexture1DEXT(texture target mismatch)");
            return;
         }
      }
      break;
   case 3:
      if (textarget != GL_TEXTURE_3D) {
         _mesa_error(ctx, GL_INVALID_ENUM,
                     "glFramebufferTexture3DEXT(textarget)");
         return;
      }
      if (texObj && texObj->Target != GL_TEXTURE_3D) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glFramebufferTexture3DEXT(texture target mismatch)");
         return;
      }
      {
d1197 2
a1198 1
                        "glFramebufferTexture3DEXT(zoffset)");
a1201 5
      break;
   default:
      _mesa_problem(ctx, "Unexpected dims in error_check_framebuffer_texture");
      return;
   }
d1203 6
a1208 4
   if ((level < 0) || level >= _mesa_max_texture_levels(ctx, textarget)) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glFramebufferTexture%dDEXT(level)", dims);
      return;
d1214 1
a1214 1
		  "glFramebufferTexture%dDEXT(attachment)", dims);
d1219 5
d1242 10
a1251 3
   const GLint zoffset = 0;
   framebuffer_texture(1, target, attachment, textarget, texture,
                       level, zoffset);
d1259 13
a1271 3
   const GLint zoffset = 0;
   framebuffer_texture(2, target, attachment, textarget, texture,
                       level, zoffset);
d1280 9
a1288 1
   framebuffer_texture(3, target, attachment, textarget, texture,
a1292 1

d1366 5
d1434 5
d1517 1
d1519 1
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@a35 1
#include "mipmap.h"
a572 6
   /* The above doesn't fully flush the drivers in the way that a
    * glFlush does, but that is required here:
    */
   if (ctx->Driver.Flush)
      ctx->Driver.Flush(ctx);

d975 1
a975 3
   if (ctx->Driver.Flush) {  
      ctx->Driver.Flush(ctx);
   }
a1049 5
   /* The above doesn't fully flush the drivers in the way that a
    * glFlush does, but that is required here:
    */
   if (ctx->Driver.Flush)
      ctx->Driver.Flush(ctx);
a1264 5
   /* The above doesn't fully flush the drivers in the way that a
    * glFlush does, but that is required here:
    */
   if (ctx->Driver.Flush)
      ctx->Driver.Flush(ctx);
a1382 5
   /* The above doesn't fully flush the drivers in the way that a
    * glFlush does, but that is required here:
    */
   if (ctx->Driver.Flush)
      ctx->Driver.Flush(ctx);
a1445 5
   /* The above doesn't fully flush the drivers in the way that a
    * glFlush does, but that is required here:
    */
   if (ctx->Driver.Flush)
      ctx->Driver.Flush(ctx);
a1523 1
   _mesa_lock_texture(ctx, texObj);
a1524 1
   _mesa_unlock_texture(ctx, texObj);
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d168 5
a172 1
      _mesa_reference_renderbuffer(&att->Renderbuffer, NULL);
d231 1
d234 1
a234 1
   _mesa_reference_renderbuffer(&att->Renderbuffer, rb);
d249 2
d254 1
d262 2
d562 1
a562 1
   struct gl_renderbuffer *newRb;
a595 1
         newRb->RefCount = 1; /* referenced by hash table */
d597 1
d603 5
d610 1
a610 1
   _mesa_reference_renderbuffer(&ctx->CurrentRenderbuffer, newRb);
d635 1
a635 4
	    /* Remove from hash table immediately, to free the ID.
             * But the object will not be freed until it's no longer
             * referenced anywhere else.
             */
d639 4
a642 2
               /* no longer referenced by hash table */
               _mesa_reference_renderbuffer(&rb, NULL);
d941 1
a941 1
   struct gl_framebuffer *newFb;
d1001 6
d1023 5
a1027 1
      _mesa_reference_framebuffer(&ctx->ReadBuffer, newFb);
d1031 8
a1038 4
      /* check if old FB had any texture attachments */
      check_end_texture_render(ctx, ctx->DrawBuffer);
      /* check if time to delete this framebuffer */
      _mesa_reference_framebuffer(&ctx->DrawBuffer, newFb);
d1086 1
a1086 1
               _mesa_unreference_framebuffer(&fb);
d1175 2
a1176 2
framebuffer_texture(GLcontext *ctx, const char *caller, GLenum target, 
                    GLenum attachment, GLenum textarget, GLuint texture,
d1182 1
d1188 1
a1188 1
                  "glFramebufferTexture%sEXT(target)", caller);
d1198 1
a1198 1
                  "glFramebufferTexture%sEXT", caller);
a1201 4

   /* The textarget, level, and zoffset parameters are only validated if
    * texture is non-zero.
    */
d1203 2
a1204 1
      GLboolean err = GL_TRUE;
d1206 39
a1244 5
      texObj = _mesa_lookup_texture(ctx, texture);
      if (texObj != NULL) {
         err = (texObj->Target == GL_TEXTURE_CUBE_MAP)
             ? !IS_CUBE_FACE(textarget)
             : (texObj->Target != textarget);
d1246 1
a1246 2

      if (err) {
d1248 1
a1248 2
                     "glFramebufferTexture%sEXT(texture target mismatch)",
                     caller);
d1251 1
a1251 2

      if (texObj->Target == GL_TEXTURE_3D) {
d1255 1
a1255 2
                        "glFramebufferTexture%sEXT(zoffset)", 
                        caller);
d1259 5
d1265 4
a1268 6
      if ((level < 0) || 
          (level >= _mesa_max_texture_levels(ctx, texObj->Target))) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glFramebufferTexture%sEXT(level)", caller);
         return;
      }
d1274 1
a1274 1
                  "glFramebufferTexture%sEXT(attachment)", caller);
d1302 3
a1304 10
   GET_CURRENT_CONTEXT(ctx);

   if ((texture != 0) && (textarget != GL_TEXTURE_1D)) {
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "glFramebufferTexture1DEXT(textarget)");
      return;
   }

   framebuffer_texture(ctx, "1D", target, attachment, textarget, texture,
                       level, 0);
d1312 3
a1314 13
   GET_CURRENT_CONTEXT(ctx);

   if ((texture != 0) &&
       (textarget != GL_TEXTURE_2D) &&
       (textarget != GL_TEXTURE_RECTANGLE_ARB) &&
       (!IS_CUBE_FACE(textarget))) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glFramebufferTexture2DEXT(textarget)");
      return;
   }

   framebuffer_texture(ctx, "2D", target, attachment, textarget, texture,
                       level, 0);
d1323 1
a1323 9
   GET_CURRENT_CONTEXT(ctx);

   if ((texture != 0) && (textarget != GL_TEXTURE_3D)) {
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "glFramebufferTexture3DEXT(textarget)");
      return;
   }

   framebuffer_texture(ctx, "3D", target, attachment, textarget, texture,
d1326 1
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d3 1
a3 1
 * Version:  7.1
d5 1
a5 2
 * Copyright (C) 1999-2008  Brian Paul   All Rights Reserved.
 * Copyright (C) 1999-2009  VMware, Inc.  All Rights Reserved.
a26 2
 * GL_EXT/ARB_framebuffer_object extensions
 *
a31 1
#include "buffers.h"
a32 1
#include "enums.h"
a33 1
#include "formats.h"
d36 1
a36 1
#include "macros.h"
d41 1
a41 7


/** Set this to 1 to help debug FBO incompleteness problems */
#define DEBUG_FBO 0

/** Set this to 1 to debug/log glBlitFramebuffer() calls */
#define DEBUG_BLIT 0
a61 4
/* We bind this framebuffer when applications pass a NULL
 * drawable/surface in make current. */
static struct gl_framebuffer IncompleteFramebuffer;

a67 30
static void
delete_dummy_renderbuffer(struct gl_renderbuffer *rb)
{
   /* no op */
}

static void
delete_dummy_framebuffer(struct gl_framebuffer *fb)
{
   /* no op */
}


void
_mesa_init_fbobjects(struct gl_context *ctx)
{
   _glthread_INIT_MUTEX(DummyFramebuffer.Mutex);
   _glthread_INIT_MUTEX(DummyRenderbuffer.Mutex);
   _glthread_INIT_MUTEX(IncompleteFramebuffer.Mutex);
   DummyFramebuffer.Delete = delete_dummy_framebuffer;
   DummyRenderbuffer.Delete = delete_dummy_renderbuffer;
   IncompleteFramebuffer.Delete = delete_dummy_framebuffer;
}

struct gl_framebuffer *
_mesa_get_incomplete_framebuffer(void)
{
   return &IncompleteFramebuffer;
}

d72 1
a72 1
_mesa_lookup_renderbuffer(struct gl_context *ctx, GLuint id)
d89 1
a89 1
_mesa_lookup_framebuffer(struct gl_context *ctx, GLuint id)
a102 12
 * Mark the given framebuffer as invalid.  This will force the
 * test for framebuffer completeness to be done before the framebuffer
 * is used.
 */
static void
invalidate_framebuffer(struct gl_framebuffer *fb)
{
   fb->_Status = 0; /* "indeterminate" */
}


/**
a104 4
 * This function is only used for user-created FB objects, not the
 * default / window-system FB object.
 * If \p attachment is GL_DEPTH_STENCIL_ATTACHMENT, return a pointer to
 * the depth buffer attachment point.
d107 1
a107 1
_mesa_get_attachment(struct gl_context *ctx, struct gl_framebuffer *fb,
a111 2
   assert(fb->Name > 0);

a133 4
   case GL_DEPTH_STENCIL_ATTACHMENT:
      /* fall-through */
   case GL_DEPTH_BUFFER:
      /* fall-through / new in GL 3.0 */
a135 2
   case GL_STENCIL_BUFFER:
      /* fall-through / new in GL 3.0 */
a144 39
 * As above, but only used for getting attachments of the default /
 * window-system framebuffer (not user-created framebuffer objects).
 */
static struct gl_renderbuffer_attachment *
_mesa_get_fb0_attachment(struct gl_context *ctx, struct gl_framebuffer *fb,
                         GLenum attachment)
{
   assert(fb->Name == 0);

   switch (attachment) {
   case GL_FRONT_LEFT:
      return &fb->Attachment[BUFFER_FRONT_LEFT];
   case GL_FRONT_RIGHT:
      return &fb->Attachment[BUFFER_FRONT_RIGHT];
   case GL_BACK_LEFT:
      return &fb->Attachment[BUFFER_BACK_LEFT];
   case GL_BACK_RIGHT:
      return &fb->Attachment[BUFFER_BACK_RIGHT];
   case GL_AUX0:
      if (fb->Visual.numAuxBuffers == 1) {
         return &fb->Attachment[BUFFER_AUX0];
      }
      return NULL;
   case GL_DEPTH_BUFFER:
      /* fall-through / new in GL 3.0 */
   case GL_DEPTH_ATTACHMENT_EXT:
      return &fb->Attachment[BUFFER_DEPTH];
   case GL_STENCIL_BUFFER:
      /* fall-through / new in GL 3.0 */
   case GL_STENCIL_ATTACHMENT_EXT:
      return &fb->Attachment[BUFFER_STENCIL];
   default:
      return NULL;
   }
}



/**
d149 1
a149 2
_mesa_remove_attachment(struct gl_context *ctx,
                        struct gl_renderbuffer_attachment *att)
d153 5
a157 1
      if (ctx->Driver.FinishRenderTexture) {
d159 3
a161 1
         ctx->Driver.FinishRenderTexture(ctx, att);
d163 1
a163 2
      _mesa_reference_texobj(&att->Texture, NULL); /* unbind */
      ASSERT(!att->Texture);
d166 1
d168 1
a168 2
      _mesa_reference_renderbuffer(&att->Renderbuffer, NULL); /* unbind */
      ASSERT(!att->Renderbuffer);
d180 1
a180 1
_mesa_set_texture_attachment(struct gl_context *ctx,
a188 2
      if (ctx->Driver.FinishRenderTexture)
	 ctx->Driver.FinishRenderTexture(ctx, att);
a191 2
      if (ctx->Driver.FinishRenderTexture && att->Texture)
	 ctx->Driver.FinishRenderTexture(ctx, att);
d194 2
a195 2
      assert(!att->Texture);
      _mesa_reference_texobj(&att->Texture, texObj);
d200 6
a205 1
   att->CubeMapFace = _mesa_tex_target_to_face(texTarget);
a211 2

   invalidate_framebuffer(fb);
d220 1
a220 1
_mesa_set_renderbuffer_attachment(struct gl_context *ctx,
d238 1
a238 2
_mesa_framebuffer_renderbuffer(struct gl_context *ctx,
                               struct gl_framebuffer *fb,
a248 7
      if (attachment == GL_DEPTH_STENCIL_ATTACHMENT) {
         /* do stencil attachment here (depth already done above) */
         att = _mesa_get_attachment(ctx, fb, GL_STENCIL_ATTACHMENT_EXT);
         assert(att);
         _mesa_set_renderbuffer_attachment(ctx, att, rb);
      }
      rb->AttachedAnytime = GL_TRUE;
a253 2
   invalidate_framebuffer(fb);

a258 69
 * For debug only.
 */
static void
att_incomplete(const char *msg)
{
#if DEBUG_FBO
   _mesa_debug(NULL, "attachment incomplete: %s\n", msg);
#else
   (void) msg;
#endif
}


/**
 * For debug only.
 */
static void
fbo_incomplete(const char *msg, int index)
{
#if DEBUG_FBO
   _mesa_debug(NULL, "FBO Incomplete: %s [%d]\n", msg, index);
#else
   (void) msg;
   (void) index;
#endif
}


/**
 * Is the given base format a legal format for a color renderbuffer?
 */
static GLboolean
is_legal_color_format(const struct gl_context *ctx, GLenum baseFormat)
{
   switch (baseFormat) {
   case GL_RGB:
   case GL_RGBA:
      return GL_TRUE;
   case GL_LUMINANCE:
   case GL_LUMINANCE_ALPHA:
   case GL_INTENSITY:
   case GL_ALPHA:
      return ctx->Extensions.ARB_framebuffer_object;
   case GL_RED:
   case GL_RG:
      return ctx->Extensions.ARB_texture_rg;
   default:
      return GL_FALSE;
   }
}


/**
 * Is the given base format a legal format for a depth/stencil renderbuffer?
 */
static GLboolean
is_legal_depth_format(const struct gl_context *ctx, GLenum baseFormat)
{
   switch (baseFormat) {
   case GL_DEPTH_COMPONENT:
   case GL_DEPTH_STENCIL_EXT:
      return GL_TRUE;
   default:
      return GL_FALSE;
   }
}


/**
d265 1
a265 1
test_attachment_completeness(const struct gl_context *ctx, GLenum format,
a276 1
      GLenum baseFormat;
a278 1
         att_incomplete("no texobj");
a284 1
         att_incomplete("no teximage");
a288 3
         att_incomplete("teximage width/height=0");
         printf("texobj = %u\n", texObj->Name);
         printf("level = %d\n", att->TextureLevel);
a292 1
         att_incomplete("bad z offset");
a296 2
      baseFormat = _mesa_get_format_base_format(texImage->TexFormat);

d298 2
a299 7
         if (!is_legal_color_format(ctx, baseFormat)) {
            att_incomplete("bad format");
            att->Complete = GL_FALSE;
            return;
         }
         if (_mesa_is_format_compressed(texImage->TexFormat)) {
            att_incomplete("compressed internalformat");
d305 1
a305 1
         if (baseFormat == GL_DEPTH_COMPONENT) {
d309 1
a309 2
                  ctx->Extensions.ARB_depth_texture &&
                  baseFormat == GL_DEPTH_STENCIL_EXT) {
a313 1
            att_incomplete("bad depth format");
d318 3
a320 12
         ASSERT(format == GL_STENCIL);
         if (ctx->Extensions.EXT_packed_depth_stencil &&
             ctx->Extensions.ARB_depth_texture &&
             baseFormat == GL_DEPTH_STENCIL_EXT) {
            /* OK */
         }
         else {
            /* no such thing as stencil-only textures */
            att_incomplete("illegal stencil texture");
            att->Complete = GL_FALSE;
            return;
         }
a323 3
      const GLenum baseFormat =
         _mesa_get_format_base_format(att->Renderbuffer->Format);

a327 1
         att_incomplete("0x0 renderbuffer");
d332 5
a336 3
         if (baseFormat != GL_RGB &&
             baseFormat != GL_RGBA) {
            att_incomplete("bad renderbuffer color format");
d342 2
a343 1
         if (baseFormat == GL_DEPTH_COMPONENT) {
d347 1
a347 1
                  baseFormat == GL_DEPTH_STENCIL_EXT) {
a350 1
            att_incomplete("bad renderbuffer depth format");
d357 2
a358 1
         if (baseFormat == GL_STENCIL_INDEX) {
d362 1
a362 1
                  baseFormat == GL_DEPTH_STENCIL_EXT) {
a366 1
            att_incomplete("bad renderbuffer stencil format");
d380 14
a395 2
 * Calls the ctx->Driver.ValidateFramebuffer() function to allow the
 * driver to make hardware-specific validation/completeness checks.
d400 1
a400 2
_mesa_test_framebuffer_completeness(struct gl_context *ctx,
                                    struct gl_framebuffer *fb)
d402 3
a404 4
   GLuint numImages;
   GLenum intFormat = GL_NONE; /* color buffers' internal format */
   GLuint minWidth = ~0, minHeight = ~0, maxWidth = 0, maxHeight = 0;
   GLint numSamples = -1;
d414 1
a414 5
   /* Start at -2 to more easily loop over all attachment points.
    *  -2: depth buffer
    *  -1: stencil buffer
    * >=0: color buffer
    */
a417 6
      gl_format mesaFormat;

      /*
       * XXX for ARB_fbo, only check color buffers that are named by
       * GL_READ_BUFFER and GL_DRAW_BUFFERi.
       */
a418 2
      /* check for attachment completeness
       */
a446 2
      /* get width, height, format of the renderbuffer/texture
       */
d450 2
a451 4
         minWidth = MIN2(minWidth, texImg->Width);
         maxWidth = MAX2(maxWidth, texImg->Width);
         minHeight = MIN2(minHeight, texImg->Height);
         maxHeight = MAX2(maxHeight, texImg->Height);
a452 1
         mesaFormat = texImg->TexFormat;
d454 2
a455 2
         if (!is_legal_color_format(ctx, f) &&
             !is_legal_depth_format(ctx, f)) {
d462 2
a463 4
         minWidth = MIN2(minWidth, att->Renderbuffer->Width);
         maxWidth = MAX2(minWidth, att->Renderbuffer->Width);
         minHeight = MIN2(minHeight, att->Renderbuffer->Height);
         maxHeight = MAX2(minHeight, att->Renderbuffer->Height);
a464 1
         mesaFormat = att->Renderbuffer->Format;
a471 10
      if (att->Renderbuffer && numSamples < 0) {
         /* first buffer */
         numSamples = att->Renderbuffer->NumSamples;
      }

      /* check if integer color */
      fb->_IntegerColor = _mesa_is_format_integer_color(mesaFormat);

      /* Error-check width, height, format, samples
       */
d473 4
a476 2
         /* save format, num samples */
         if (i >= 0) {
a477 1
         }
d480 5
a484 13
         if (!ctx->Extensions.ARB_framebuffer_object) {
            /* check that width, height, format are same */
            if (minWidth != maxWidth || minHeight != maxHeight) {
               fb->_Status = GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS_EXT;
               fbo_incomplete("width or height mismatch", -1);
               return;
            }
            /* check that all color buffer have same format */
            if (intFormat != GL_NONE && f != intFormat) {
               fb->_Status = GL_FRAMEBUFFER_INCOMPLETE_FORMATS_EXT;
               fbo_incomplete("format mismatch", -1);
               return;
            }
d486 3
a488 4
         if (att->Renderbuffer &&
             att->Renderbuffer->NumSamples != numSamples) {
            fb->_Status = GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE;
            fbo_incomplete("inconsistant number of samples", i);
d490 1
a490 2
         }            

d494 11
a504 14
#if FEATURE_GL
   if (ctx->API == API_OPENGL) {
      /* Check that all DrawBuffers are present */
      for (j = 0; j < ctx->Const.MaxDrawBuffers; j++) {
	 if (fb->ColorDrawBuffer[j] != GL_NONE) {
	    const struct gl_renderbuffer_attachment *att
	       = _mesa_get_attachment(ctx, fb, fb->ColorDrawBuffer[j]);
	    assert(att);
	    if (att->Type == GL_NONE) {
	       fb->_Status = GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER_EXT;
	       fbo_incomplete("missing drawbuffer", j);
	       return;
	    }
	 }
d506 1
d508 7
a514 7
      /* Check that the ReadBuffer is present */
      if (fb->ColorReadBuffer != GL_NONE) {
	 const struct gl_renderbuffer_attachment *att
	    = _mesa_get_attachment(ctx, fb, fb->ColorReadBuffer);
	 assert(att);
	 if (att->Type == GL_NONE) {
	    fb->_Status = GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER_EXT;
d516 1
a516 2
	    return;
	 }
a518 3
#else
   (void) j;
#endif
d526 3
a528 1
   /* Provisionally set status = COMPLETE ... */
d530 2
a531 24

   /* ... but the driver may say the FB is incomplete.
    * Drivers will most likely set the status to GL_FRAMEBUFFER_UNSUPPORTED
    * if anything.
    */
   if (ctx->Driver.ValidateFramebuffer) {
      ctx->Driver.ValidateFramebuffer(ctx, fb);
      if (fb->_Status != GL_FRAMEBUFFER_COMPLETE_EXT) {
         fbo_incomplete("driver marked FBO as incomplete", -1);
      }
   }

   if (fb->_Status == GL_FRAMEBUFFER_COMPLETE_EXT) {
      /*
       * Note that if ARB_framebuffer_object is supported and the attached
       * renderbuffers/textures are different sizes, the framebuffer
       * width/height will be set to the smallest width/height.
       */
      fb->Width = minWidth;
      fb->Height = minHeight;

      /* finally, update the visual info for the framebuffer */
      _mesa_update_framebuffer_visual(fb);
   }
d558 2
a559 1
      _mesa_error(ctx, GL_INVALID_ENUM, "glBindRenderbufferEXT(target)");
d563 3
a565 2
   /* No need to flush here since the render buffer binding has no
    * effect on rendering state.
d567 3
a576 6
      else if (!newRb && ctx->Extensions.ARB_framebuffer_object) {
         /* All RB IDs must be Gen'd */
         _mesa_error(ctx, GL_INVALID_OPERATION, "glBindRenderbuffer(buffer)");
         return;
      }

a598 21
/**
 * If the given renderbuffer is anywhere attached to the framebuffer, detach
 * the renderbuffer.
 * This is used when a renderbuffer object is deleted.
 * The spec calls for unbinding.
 */
static void
detach_renderbuffer(struct gl_context *ctx,
                    struct gl_framebuffer *fb,
                    struct gl_renderbuffer *rb)
{
   GLuint i;
   for (i = 0; i < BUFFER_COUNT; i++) {
      if (fb->Attachment[i].Renderbuffer == rb) {
         _mesa_remove_attachment(ctx, &fb->Attachment[i]);
      }
   }
   invalidate_framebuffer(fb);
}


a619 7
            if (ctx->DrawBuffer->Name) {
               detach_renderbuffer(ctx, ctx->DrawBuffer, rb);
            }
            if (ctx->ReadBuffer->Name && ctx->ReadBuffer != ctx->DrawBuffer) {
               detach_renderbuffer(ctx, ctx->ReadBuffer, rb);
            }

a673 3
 *
 * XXX in the future when we support red-only and red-green formats
 * we'll also return GL_RED and GL_RG.
d676 1
a676 1
_mesa_base_fbo_format(struct gl_context *ctx, GLenum internalFormat)
a678 6
   case GL_ALPHA:
   case GL_ALPHA4:
   case GL_ALPHA8:
   case GL_ALPHA12:
   case GL_ALPHA16:
      return GL_ALPHA;
a695 1
   case GL_RGBA16_SNORM:
d721 3
a723 5
/**
 * Invalidate a renderbuffer attachment.  Called from _mesa_HashWalk().
 */
static void
invalidate_rb(GLuint key, void *data, void *userData)
a724 34
   struct gl_framebuffer *fb = (struct gl_framebuffer *) data;
   struct gl_renderbuffer *rb = (struct gl_renderbuffer *) userData;

   /* If this is a user-created FBO */
   if (fb->Name) {
      GLuint i;
      for (i = 0; i < BUFFER_COUNT; i++) {
         struct gl_renderbuffer_attachment *att = fb->Attachment + i;
         if (att->Type == GL_RENDERBUFFER &&
             att->Renderbuffer == rb) {
            /* Mark fb status as indeterminate to force re-validation */
            fb->_Status = 0;
            return;
         }
      }
   }
}


/** sentinal value, see below */
#define NO_SAMPLES 1000


/**
 * Helper function used by _mesa_RenderbufferStorageEXT() and 
 * _mesa_RenderbufferStorageMultisample().
 * samples will be NO_SAMPLES if called by _mesa_RenderbufferStorageEXT().
 */
static void
renderbuffer_storage(GLenum target, GLenum internalFormat,
                     GLsizei width, GLsizei height, GLsizei samples)
{
   const char *func = samples == NO_SAMPLES ?
      "glRenderbufferStorage" : "RenderbufferStorageMultisample";
d732 1
a732 1
      _mesa_error(ctx, GL_INVALID_ENUM, "%s(target)", func);
d738 2
a739 1
      _mesa_error(ctx, GL_INVALID_ENUM, "%s(internalFormat)", func);
d744 1
a744 1
      _mesa_error(ctx, GL_INVALID_VALUE, "%s(width)", func);
d749 1
a749 1
      _mesa_error(ctx, GL_INVALID_VALUE, "%s(height)", func);
d753 1
a753 9
   if (samples == NO_SAMPLES) {
      /* NumSamples == 0 indicates non-multisampling */
      samples = 0;
   }
   else if (samples > (GLsizei) ctx->Const.MaxSamples) {
      /* note: driver may choose to use more samples than what's requested */
      _mesa_error(ctx, GL_INVALID_VALUE, "%s(samples)", func);
      return;
   }
a754 1
   rb = ctx->CurrentRenderbuffer;
d756 1
a756 1
      _mesa_error(ctx, GL_INVALID_OPERATION, "%s", func);
d770 8
a777 2
   rb->Format = MESA_FORMAT_NONE;
   rb->NumSamples = samples;
d783 1
a783 1
      assert(rb->Format != MESA_FORMAT_NONE);
d786 2
a789 1
      assert(rb->_BaseFormat != 0);
a794 1
      rb->Format = MESA_FORMAT_NONE;
d796 1
d798 7
a804 1
      rb->NumSamples = 0;
d807 5
a811 95
   /* Invalidate the framebuffers the renderbuffer is attached in. */
   if (rb->AttachedAnytime) {
      _mesa_HashWalk(ctx->Shared->FrameBuffers, invalidate_rb, rb);
   }
}


#if FEATURE_OES_EGL_image
void GLAPIENTRY
_mesa_EGLImageTargetRenderbufferStorageOES(GLenum target, GLeglImageOES image)
{
   struct gl_renderbuffer *rb;
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   if (!ctx->Extensions.OES_EGL_image) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glEGLImageTargetRenderbufferStorageOES(unsupported)");
      return;
   }

   if (target != GL_RENDERBUFFER) {
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "EGLImageTargetRenderbufferStorageOES");
      return;
   }

   rb = ctx->CurrentRenderbuffer;
   if (!rb) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "EGLImageTargetRenderbufferStorageOES");
      return;
   }

   FLUSH_VERTICES(ctx, _NEW_BUFFERS);

   ctx->Driver.EGLImageTargetRenderbufferStorage(ctx, rb, image);
}
#endif


/**
 * Helper function for _mesa_GetRenderbufferParameterivEXT() and
 * _mesa_GetFramebufferAttachmentParameterivEXT()
 * We have to be careful to respect the base format.  For example, if a
 * renderbuffer/texture was created with internalFormat=GL_RGB but the
 * driver actually chose a GL_RGBA format, when the user queries ALPHA_SIZE
 * we need to return zero.
 */
static GLint
get_component_bits(GLenum pname, GLenum baseFormat, gl_format format)
{
   switch (pname) {
   case GL_RENDERBUFFER_RED_SIZE_EXT:
   case GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE:
   case GL_RENDERBUFFER_GREEN_SIZE_EXT:
   case GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE:
   case GL_RENDERBUFFER_BLUE_SIZE_EXT:
   case GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE:
      if (baseFormat == GL_RGB || baseFormat == GL_RGBA)
         return _mesa_get_format_bits(format, pname);
      else
         return 0;
   case GL_RENDERBUFFER_ALPHA_SIZE_EXT:
   case GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE:
      if (baseFormat == GL_RGBA || baseFormat == GL_ALPHA)
         return _mesa_get_format_bits(format, pname);
      else
         return 0;
   case GL_RENDERBUFFER_DEPTH_SIZE_EXT:
   case GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE:
      if (baseFormat == GL_DEPTH_COMPONENT || baseFormat == GL_DEPTH_STENCIL)
         return _mesa_get_format_bits(format, pname);
      else
         return 0;
   case GL_RENDERBUFFER_STENCIL_SIZE_EXT:
   case GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE:
      if (baseFormat == GL_STENCIL_INDEX || baseFormat == GL_DEPTH_STENCIL)
         return _mesa_get_format_bits(format, pname);
      else
         return 0;
   default:
      return 0;
   }
}



void GLAPIENTRY
_mesa_RenderbufferStorageEXT(GLenum target, GLenum internalFormat,
                             GLsizei width, GLsizei height)
{
   /* GL_ARB_fbo says calling this function is equivalent to calling
    * glRenderbufferStorageMultisample() with samples=0.  We pass in
    * a token value here just for error reporting purposes.
a812 31
   renderbuffer_storage(target, internalFormat, width, height, NO_SAMPLES);
}


void GLAPIENTRY
_mesa_RenderbufferStorageMultisample(GLenum target, GLsizei samples,
                                     GLenum internalFormat,
                                     GLsizei width, GLsizei height)
{
   renderbuffer_storage(target, internalFormat, width, height, samples);
}


/**
 * OpenGL ES version of glRenderBufferStorage.
 */
void GLAPIENTRY
_es_RenderbufferStorageEXT(GLenum target, GLenum internalFormat,
			   GLsizei width, GLsizei height)
{
   switch (internalFormat) {
   case GL_RGB565:
      /* XXX this confuses GL_RENDERBUFFER_INTERNAL_FORMAT_OES */
      /* choose a closest format */
      internalFormat = GL_RGB5;
      break;
   default:
      break;
   }

   renderbuffer_storage(target, internalFormat, width, height, 0);
a818 1
   struct gl_renderbuffer *rb;
d829 1
a829 2
   rb = ctx->CurrentRenderbuffer;
   if (!rb) {
d835 1
a835 3
   /* No need to flush here since we're just quering state which is
    * not effected by rendering.
    */
d839 1
a839 1
      *params = rb->Width;
d842 1
a842 1
      *params = rb->Height;
d845 1
a845 1
      *params = rb->InternalFormat;
d848 2
d851 2
d854 2
d857 2
d860 2
d863 1
a863 1
      *params = get_component_bits(pname, rb->_BaseFormat, rb->Format);
a864 6
   case GL_RENDERBUFFER_SAMPLES:
      if (ctx->Extensions.ARB_framebuffer_object) {
         *params = rb->NumSamples;
         break;
      }
      /* fallthrough */
a886 5
/**
 * Check if any of the attachments of the given framebuffer are textures
 * (render to texture).  Call ctx->Driver.RenderTexture() for such
 * attachments.
 */
d888 1
a888 1
check_begin_texture_render(struct gl_context *ctx, struct gl_framebuffer *fb)
a891 4

   if (fb->Name == 0)
      return; /* can't render to texture with winsys framebuffers */

d896 1
a896 1
          && texObj->Image[att->CubeMapFace][att->TextureLevel]) {
d909 1
a909 1
check_end_texture_render(struct gl_context *ctx, struct gl_framebuffer *fb)
a910 3
   if (fb->Name == 0)
      return; /* can't render to texture with winsys framebuffers */

d915 2
a916 1
         if (att->Texture && att->Renderbuffer) {
d927 1
a927 2
   struct gl_framebuffer *newDrawFb, *newReadFb;
   struct gl_framebuffer *oldDrawFb, *oldReadFb;
a930 7
#ifdef DEBUG
   if (ctx->Extensions.ARB_framebuffer_object) {
      ASSERT(ctx->Extensions.EXT_framebuffer_object);
      ASSERT(ctx->Extensions.EXT_framebuffer_blit);
   }
#endif

d967 4
d973 2
a974 2
      newDrawFb = _mesa_lookup_framebuffer(ctx, framebuffer);
      if (newDrawFb == &DummyFramebuffer) {
d976 1
a976 1
         newDrawFb = NULL;
d978 1
a978 7
      else if (!newDrawFb && ctx->Extensions.ARB_framebuffer_object) {
         /* All FBO IDs must be Gen'd */
         _mesa_error(ctx, GL_INVALID_OPERATION, "glBindFramebuffer(buffer)");
         return;
      }

      if (!newDrawFb) {
d980 2
a981 2
	 newDrawFb = ctx->Driver.NewFramebuffer(ctx, framebuffer);
	 if (!newDrawFb) {
d985 1
a985 1
         _mesa_HashInsert(ctx->Shared->FrameBuffers, framebuffer, newDrawFb);
a986 1
      newReadFb = newDrawFb;
d992 1
a992 2
      newDrawFb = ctx->WinSysDrawBuffer;
      newReadFb = ctx->WinSysReadBuffer;
d995 2
a996 12
   ASSERT(newDrawFb);
   ASSERT(newDrawFb != &DummyFramebuffer);

   /* save pointers to current/old framebuffers */
   oldDrawFb = ctx->DrawBuffer;
   oldReadFb = ctx->ReadBuffer;

   /* check if really changing bindings */
   if (oldDrawFb == newDrawFb)
      bindDrawBuf = GL_FALSE;
   if (oldReadFb == newReadFb)
      bindReadBuf = GL_FALSE;
d999 1
a999 10
    * OK, now bind the new Draw/Read framebuffers, if they're changing.
    *
    * We also check if we're beginning and/or ending render-to-texture.
    * When a framebuffer with texture attachments is unbound, call
    * ctx->Driver.FinishRenderTexture().
    * When a framebuffer with texture attachments is bound, call
    * ctx->Driver.RenderTexture().
    *
    * Note that if the ReadBuffer has texture attachments we don't consider
    * that a render-to-texture case.
d1001 1
d1003 1
a1003 6
      FLUSH_VERTICES(ctx, _NEW_BUFFERS);

      /* check if old readbuffer was render-to-texture */
      check_end_texture_render(ctx, oldReadFb);

      _mesa_reference_framebuffer(&ctx->ReadBuffer, newReadFb);
d1007 8
a1014 13
      FLUSH_VERTICES(ctx, _NEW_BUFFERS);

      /* check if old read/draw buffers were render-to-texture */
      if (!bindReadBuf)
         check_end_texture_render(ctx, oldReadFb);

      if (oldDrawFb != oldReadFb)
         check_end_texture_render(ctx, oldDrawFb);

      /* check if newly bound framebuffer has any texture attachments */
      check_begin_texture_render(ctx, newDrawFb);

      _mesa_reference_framebuffer(&ctx->DrawBuffer, newDrawFb);
d1017 2
a1018 2
   if ((bindDrawBuf || bindReadBuf) && ctx->Driver.BindFramebuffer) {
      ctx->Driver.BindFramebuffer(ctx, target, newDrawFb, newReadFb);
d1031 5
d1045 4
a1048 20
            if (ctx->Extensions.EXT_framebuffer_blit) {
               /* separate draw/read binding points */
               if (fb == ctx->DrawBuffer) {
                  /* bind default */
                  ASSERT(fb->RefCount >= 2);
                  _mesa_BindFramebufferEXT(GL_DRAW_FRAMEBUFFER_EXT, 0);
               }
               if (fb == ctx->ReadBuffer) {
                  /* bind default */
                  ASSERT(fb->RefCount >= 2);
                  _mesa_BindFramebufferEXT(GL_READ_FRAMEBUFFER_EXT, 0);
               }
            }
            else {
               /* only one binding point for read/draw buffers */
               if (fb == ctx->DrawBuffer || fb == ctx->ReadBuffer) {
                  /* bind default */
                  ASSERT(fb->RefCount >= 2);
                  _mesa_BindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
               }    
d1058 1
a1058 1
               _mesa_reference_framebuffer(&fb, NULL);
d1135 1
a1135 5
   /* No need to flush here */

   if (buffer->_Status != GL_FRAMEBUFFER_COMPLETE) {
      _mesa_test_framebuffer_completeness(ctx, buffer);
   }
d1137 1
d1147 1
a1147 1
framebuffer_texture(struct gl_context *ctx, const char *caller, GLenum target, 
a1153 1
   GLboolean error = GL_FALSE;
d1157 1
a1157 16
   switch (target) {
   case GL_READ_FRAMEBUFFER_EXT:
      error = !ctx->Extensions.EXT_framebuffer_blit;
      fb = ctx->ReadBuffer;
      break;
   case GL_DRAW_FRAMEBUFFER_EXT:
      error = !ctx->Extensions.EXT_framebuffer_blit;
      /* fall-through */
   case GL_FRAMEBUFFER_EXT:
      fb = ctx->DrawBuffer;
      break;
   default:
      error = GL_TRUE;
   }

   if (error) {
d1159 1
a1159 1
                  "glFramebufferTexture%sEXT(target=0x%x)", caller, target);
d1163 1
d1182 3
a1184 18
         if (textarget == 0) {
            /* XXX what's the purpose of this? */
            err = (texObj->Target != GL_TEXTURE_3D) &&
                (texObj->Target != GL_TEXTURE_1D_ARRAY_EXT) &&
                (texObj->Target != GL_TEXTURE_2D_ARRAY_EXT);
         }
         else {
            err = (texObj->Target == GL_TEXTURE_CUBE_MAP)
                ? !IS_CUBE_FACE(textarget)
                : (texObj->Target != textarget);
         }
      }
      else {
         /* can't render to a non-existant texture */
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glFramebufferTexture%sEXT(non existant texture)",
                     caller);
         return;
d1198 2
a1199 9
                        "glFramebufferTexture%sEXT(zoffset)", caller);
            return;
         }
      }
      else if ((texObj->Target == GL_TEXTURE_1D_ARRAY_EXT) ||
               (texObj->Target == GL_TEXTURE_2D_ARRAY_EXT)) {
         if (zoffset < 0 || zoffset >= ctx->Const.MaxArrayTextureLayers) {
            _mesa_error(ctx, GL_INVALID_VALUE,
                        "glFramebufferTexture%sEXT(layer)", caller);
d1220 5
a1229 9
      /* Set the render-to-texture flag.  We'll check this flag in
       * glTexImage() and friends to determine if we need to revalidate
       * any FBOs that might be rendering into this texture.
       * This flag never gets cleared since it's non-trivial to determine
       * when all FBOs might be done rendering to this texture.  That's OK
       * though since it's uncommon to render to a texture then repeatedly
       * call glTexImage() to change images in the texture.
       */
      texObj->_RenderToTexture = GL_TRUE;
a1233 3

   invalidate_framebuffer(fb);

d1267 1
a1267 1
                  "glFramebufferTexture2DEXT(textarget=0x%x)", textarget);
a1294 11
_mesa_FramebufferTextureLayerEXT(GLenum target, GLenum attachment,
                                 GLuint texture, GLint level, GLint layer)
{
   GET_CURRENT_CONTEXT(ctx);

   framebuffer_texture(ctx, "Layer", target, attachment, 0, texture,
                       level, layer);
}


void GLAPIENTRY
d1349 1
a1349 2
                  "glFramebufferRenderbufferEXT(invalid attachment %s)",
                  _mesa_lookup_enum_by_nr(attachment));
d1357 1
a1357 9
		     "glFramebufferRenderbufferEXT(non-existant"
                     " renderbuffer %u)", renderbuffer);
	 return;
      }
      else if (rb == &DummyRenderbuffer) {
         /* This is what NVIDIA does */
	 _mesa_error(ctx, GL_INVALID_VALUE,
		     "glFramebufferRenderbufferEXT(renderbuffer %u)",
                     renderbuffer);
a1365 13
   if (attachment == GL_DEPTH_STENCIL_ATTACHMENT &&
       rb && rb->Format != MESA_FORMAT_NONE) {
      /* make sure the renderbuffer is a depth/stencil format */
      const GLenum baseFormat = _mesa_get_format_base_format(rb->Format);
      if (baseFormat != GL_DEPTH_STENCIL) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glFramebufferRenderbufferEXT(renderbuffer"
                     " is not DEPTH_STENCIL format)");
         return;
      }
   }


d1367 5
d1422 3
a1424 6
      /* the default / window-system FBO */
      att = _mesa_get_fb0_attachment(ctx, buffer, attachment);
   }
   else {
      /* user-created framebuffer FBO */
      att = _mesa_get_attachment(ctx, buffer, attachment);
d1427 1
d1434 6
a1439 14
   if (attachment == GL_DEPTH_STENCIL_ATTACHMENT) {
      /* the depth and stencil attachments must point to the same buffer */
      const struct gl_renderbuffer_attachment *depthAtt, *stencilAtt;
      depthAtt = _mesa_get_attachment(ctx, buffer, GL_DEPTH_ATTACHMENT);
      stencilAtt = _mesa_get_attachment(ctx, buffer, GL_STENCIL_ATTACHMENT);
      if (depthAtt->Renderbuffer != stencilAtt->Renderbuffer) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glGetFramebufferAttachmentParameterivEXT(DEPTH/STENCIL"
                     " attachments differ)");
         return;
      }
   }

   /* No need to flush here */
d1443 1
a1443 1
      *params = buffer->Name == 0 ? GL_FRAMEBUFFER_DEFAULT : att->Type;
d1453 2
a1454 2
         assert(att->Type == GL_NONE);
         *params = 0;
a1460 4
      else if (att->Type == GL_NONE) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glGetFramebufferAttachmentParameterivEXT(pname)");
      }
d1468 1
a1468 10
         if (att->Texture && att->Texture->Target == GL_TEXTURE_CUBE_MAP) {
            *params = GL_TEXTURE_CUBE_MAP_POSITIVE_X + att->CubeMapFace;
         }
         else {
            *params = 0;
         }
      }
      else if (att->Type == GL_NONE) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glGetFramebufferAttachmentParameterivEXT(pname)");
d1477 1
a1477 10
         if (att->Texture && att->Texture->Target == GL_TEXTURE_3D) {
            *params = att->Zoffset;
         }
         else {
            *params = 0;
         }
      }
      else if (att->Type == GL_NONE) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glGetFramebufferAttachmentParameterivEXT(pname)");
a1483 69
   case GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING:
      if (!ctx->Extensions.ARB_framebuffer_object) {
         _mesa_error(ctx, GL_INVALID_ENUM,
                     "glGetFramebufferAttachmentParameterivEXT(pname)");
      }
      else if (att->Type == GL_NONE) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glGetFramebufferAttachmentParameterivEXT(pname)");
      }
      else {
         *params = _mesa_get_format_color_encoding(att->Renderbuffer->Format);
      }
      return;
   case GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE:
      if (!ctx->Extensions.ARB_framebuffer_object) {
         _mesa_error(ctx, GL_INVALID_ENUM,
                     "glGetFramebufferAttachmentParameterivEXT(pname)");
         return;
      }
      else if (att->Type == GL_NONE) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glGetFramebufferAttachmentParameterivEXT(pname)");
      }
      else {
         gl_format format = att->Renderbuffer->Format;
         if (format == MESA_FORMAT_CI8 || format == MESA_FORMAT_S8) {
            /* special cases */
            *params = GL_INDEX;
         }
         else {
            *params = _mesa_get_format_datatype(format);
         }
      }
      return;
   case GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE:
   case GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE:
   case GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE:
   case GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE:
   case GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE:
   case GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE:
      if (!ctx->Extensions.ARB_framebuffer_object) {
         _mesa_error(ctx, GL_INVALID_ENUM,
                     "glGetFramebufferAttachmentParameterivEXT(pname)");
      }
      else if (att->Type == GL_NONE) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glGetFramebufferAttachmentParameterivEXT(pname)");
      }
      else if (att->Texture) {
         const struct gl_texture_image *texImage =
            _mesa_select_tex_image(ctx, att->Texture, att->Texture->Target,
                                   att->TextureLevel);
         if (texImage) {
            *params = get_component_bits(pname, texImage->_BaseFormat,
                                         texImage->TexFormat);
         }
         else {
            *params = 0;
         }
      }
      else if (att->Renderbuffer) {
         *params = get_component_bits(pname, att->Renderbuffer->_BaseFormat,
                                      att->Renderbuffer->Format);
      }
      else {
         _mesa_problem(ctx, "glGetFramebufferAttachmentParameterivEXT:"
                       " invalid FBO attachment structure");
      }
      return;
d1495 1
a1509 1
      /* XXX need to implement GL_TEXTURE_1D_ARRAY and GL_TEXTURE_2D_ARRAY */
d1514 2
a1515 13
   texObj = _mesa_get_current_tex_object(ctx, target);

   if (texObj->BaseLevel >= texObj->MaxLevel) {
      /* nothing to do */
      return;
   }

   if (texObj->Target == GL_TEXTURE_CUBE_MAP &&
       !_mesa_cube_complete(texObj)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glGenerateMipmap(incomplete cube map)");
      return;
   }
d1517 1
d1519 1
a1519 10
   if (target == GL_TEXTURE_CUBE_MAP) {
      GLuint face;
      for (face = 0; face < 6; face++)
	 ctx->Driver.GenerateMipmap(ctx,
				    GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB + face,
				    texObj);
   }
   else {
      ctx->Driver.GenerateMipmap(ctx, target, texObj);
   }
a1524 20

static const struct gl_renderbuffer_attachment *
find_attachment(const struct gl_framebuffer *fb, const struct gl_renderbuffer *rb)
{
   GLuint i;
   for (i = 0; i < Elements(fb->Attachment); i++) {
      if (fb->Attachment[i].Renderbuffer == rb)
         return &fb->Attachment[i];
   }
   return NULL;
}



/**
 * Blit rectangular region, optionally from one framebuffer to another.
 *
 * Note, if the src buffer is multisampled and the dest is not, this is
 * when the samples must be resolved to a single color.
 */
a1529 5
   const GLbitfield legalMaskBits = (GL_COLOR_BUFFER_BIT |
                                     GL_DEPTH_BUFFER_BIT |
                                     GL_STENCIL_BUFFER_BIT);
   const struct gl_framebuffer *readFb, *drawFb;
   const struct gl_renderbuffer *colorReadRb, *colorDrawRb;
d1539 2
a1540 8
   readFb = ctx->ReadBuffer;
   drawFb = ctx->DrawBuffer;

   if (!readFb || !drawFb) {
      /* This will normally never happen but someday we may want to
       * support MakeCurrent() with no drawables.
       */
      return;
d1544 2
a1545 2
   if (drawFb->_Status != GL_FRAMEBUFFER_COMPLETE_EXT ||
       readFb->_Status != GL_FRAMEBUFFER_COMPLETE_EXT) {
d1556 3
a1558 1
   if (mask & ~legalMaskBits) {
a1570 20
   /* get color read/draw renderbuffers */
   if (mask & GL_COLOR_BUFFER_BIT) {
      colorReadRb = readFb->_ColorReadBuffer;
      colorDrawRb = drawFb->_ColorDrawBuffers[0];

      /* From the EXT_framebuffer_object spec:
       *
       *     "If a buffer is specified in <mask> and does not exist in both
       *     the read and draw framebuffers, the corresponding bit is silently
       *     ignored."
       */
      if ((colorReadRb == NULL) || (colorDrawRb == NULL)) {
	 colorReadRb = colorDrawRb = NULL;
	 mask &= ~GL_COLOR_BUFFER_BIT;
      }
   }
   else {
      colorReadRb = colorDrawRb = NULL;
   }

d1572 3
a1574 15
      struct gl_renderbuffer *readRb = readFb->_StencilBuffer;
      struct gl_renderbuffer *drawRb = drawFb->_StencilBuffer;

      /* From the EXT_framebuffer_object spec:
       *
       *     "If a buffer is specified in <mask> and does not exist in both
       *     the read and draw framebuffers, the corresponding bit is silently
       *     ignored."
       */
      if ((readRb == NULL) || (drawRb == NULL)) {
	 readRb = drawRb = NULL;
	 mask &= ~GL_STENCIL_BUFFER_BIT;
      }
      else if (_mesa_get_format_bits(readRb->Format, GL_STENCIL_BITS) !=
	       _mesa_get_format_bits(drawRb->Format, GL_STENCIL_BITS)) {
d1582 3
a1584 15
      struct gl_renderbuffer *readRb = readFb->_DepthBuffer;
      struct gl_renderbuffer *drawRb = drawFb->_DepthBuffer;

      /* From the EXT_framebuffer_object spec:
       *
       *     "If a buffer is specified in <mask> and does not exist in both
       *     the read and draw framebuffers, the corresponding bit is silently
       *     ignored."
       */
      if ((readRb == NULL) || (drawRb == NULL)) {
	 readRb = drawRb = NULL;
	 mask &= ~GL_DEPTH_BUFFER_BIT;
      }
      else if (_mesa_get_format_bits(readRb->Format, GL_DEPTH_BITS) !=
	       _mesa_get_format_bits(drawRb->Format, GL_DEPTH_BITS)) {
a1590 28
   if (readFb->Visual.samples > 0 &&
       drawFb->Visual.samples > 0 &&
       readFb->Visual.samples != drawFb->Visual.samples) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glBlitFramebufferEXT(mismatched samples");
      return;
   }

   /* extra checks for multisample copies... */
   if (readFb->Visual.samples > 0 || drawFb->Visual.samples > 0) {
      /* src and dest region sizes must be the same */
      if (srcX1 - srcX0 != dstX1 - dstX0 ||
          srcY1 - srcY0 != dstY1 - dstY0) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                "glBlitFramebufferEXT(bad src/dst multisample region sizes");
         return;
      }

      /* color formats must match */
      if (colorReadRb &&
          colorDrawRb &&
          colorReadRb->Format != colorDrawRb->Format) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                "glBlitFramebufferEXT(bad src/dst multisample pixel formats");
         return;
      }
   }

a1595 42
   /* Debug code */
   if (DEBUG_BLIT) {
      printf("glBlitFramebuffer(%d, %d, %d, %d,  %d, %d, %d, %d,"
	     " 0x%x, 0x%x)\n",
	     srcX0, srcY0, srcX1, srcY1,
	     dstX0, dstY0, dstX1, dstY1,
	     mask, filter);
      if (colorReadRb) {
         const struct gl_renderbuffer_attachment *att;

         att = find_attachment(readFb, colorReadRb);
         printf("  Src FBO %u  RB %u (%dx%d)  ",
		readFb->Name, colorReadRb->Name,
		colorReadRb->Width, colorReadRb->Height);
         if (att && att->Texture) {
            printf("Tex %u  tgt 0x%x  level %u  face %u",
		   att->Texture->Name,
		   att->Texture->Target,
		   att->TextureLevel,
		   att->CubeMapFace);
         }
         printf("\n");

         att = find_attachment(drawFb, colorDrawRb);
         printf("  Dst FBO %u  RB %u (%dx%d)  ",
		drawFb->Name, colorDrawRb->Name,
		colorDrawRb->Width, colorDrawRb->Height);
         if (att && att->Texture) {
            printf("Tex %u  tgt 0x%x  level %u  face %u",
		   att->Texture->Name,
		   att->Texture->Target,
		   att->TextureLevel,
		   att->CubeMapFace);
         }
         printf("\n");
      }
   }

   if (!mask) {
      return;
   }

a1602 22

#if FEATURE_ARB_geometry_shader4
void GLAPIENTRY
_mesa_FramebufferTextureARB(GLenum target, GLenum attachment,
                            GLuint texture, GLint level)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_error(ctx, GL_INVALID_OPERATION,
               "glFramebufferTextureARB "
               "not implemented!");
}

void GLAPIENTRY
_mesa_FramebufferTextureFaceARB(GLenum target, GLenum attachment,
                                GLuint texture, GLint level, GLenum face)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_error(ctx, GL_INVALID_OPERATION,
               "glFramebufferTextureFaceARB "
               "not implemented!");
}
#endif /* FEATURE_ARB_geometry_shader4 */
@


1.1.1.5
log
@Import Mesa 9.2.0
@
text
@d3 1
d21 3
a23 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
a33 1
#include <stdbool.h>
a40 1
#include "glformats.h"
a42 2
#include "multisample.h"
#include "mtypes.h"
d49 3
d79 5
d85 1
a85 1
delete_dummy_renderbuffer(struct gl_context *ctx, struct gl_renderbuffer *rb)
a160 25
 * Return the gl_framebuffer object which corresponds to the given
 * framebuffer target, such as GL_DRAW_FRAMEBUFFER.
 * Check support for GL_EXT_framebuffer_blit to determine if certain
 * targets are legal.
 * \return gl_framebuffer pointer or NULL if target is illegal
 */
static struct gl_framebuffer *
get_framebuffer_target(struct gl_context *ctx, GLenum target)
{
   bool have_fb_blit = _mesa_is_gles3(ctx) ||
      (ctx->Extensions.EXT_framebuffer_blit && _mesa_is_desktop_gl(ctx));
   switch (target) {
   case GL_DRAW_FRAMEBUFFER:
      return have_fb_blit ? ctx->DrawBuffer : NULL;
   case GL_READ_FRAMEBUFFER:
      return have_fb_blit ? ctx->ReadBuffer : NULL;
   case GL_FRAMEBUFFER_EXT:
      return ctx->DrawBuffer;
   default:
      return NULL;
   }
}


/**
d174 1
a174 1
   assert(_mesa_is_user_fbo(fb));
a192 4
      /* Only OpenGL ES 1.x forbids color attachments other than
       * GL_COLOR_ATTACHMENT0.  For all other APIs the limit set by the
       * hardware is used.
       */
d194 1
a194 2
      if (i >= ctx->Const.MaxColorAttachments
	  || (i > 0 && ctx->API == API_OPENGLES)) {
a198 2
      if (!_mesa_is_desktop_gl(ctx) && !_mesa_is_gles3(ctx))
	 return NULL;
d200 2
d204 2
d222 1
a222 20
   assert(_mesa_is_winsys_fbo(fb));

   if (_mesa_is_gles3(ctx)) {
      assert(attachment == GL_BACK ||
             attachment == GL_DEPTH ||
             attachment == GL_STENCIL);
      switch (attachment) {
      case GL_BACK:
         /* Since there is no stereo rendering in ES 3.0, only return the
          * LEFT bits.
          */
         if (ctx->DrawBuffer->Visual.doubleBufferMode)
            return &fb->Attachment[BUFFER_BACK_LEFT];
         return &fb->Attachment[BUFFER_FRONT_LEFT];
      case GL_DEPTH:
      return &fb->Attachment[BUFFER_DEPTH];
      case GL_STENCIL:
         return &fb->Attachment[BUFFER_STENCIL];
      }
   }
d238 3
a240 26

   /* Page 336 (page 352 of the PDF) of the OpenGL 3.0 spec says:
    *
    *     "If the default framebuffer is bound to target, then attachment must
    *     be one of FRONT LEFT, FRONT RIGHT, BACK LEFT, BACK RIGHT, or AUXi,
    *     identifying a color buffer; DEPTH, identifying the depth buffer; or
    *     STENCIL, identifying the stencil buffer."
    *
    * Revision #34 of the ARB_framebuffer_object spec has essentially the same
    * language.  However, revision #33 of the ARB_framebuffer_object spec
    * says:
    *
    *     "If the default framebuffer is bound to <target>, then <attachment>
    *     must be one of FRONT_LEFT, FRONT_RIGHT, BACK_LEFT, BACK_RIGHT, AUXi,
    *     DEPTH_BUFFER, or STENCIL_BUFFER, identifying a color buffer, the
    *     depth buffer, or the stencil buffer, and <pname> may be
    *     FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE or
    *     FRAMEBUFFER_ATTACHMENT_OBJECT_NAME."
    *
    * The enum values for DEPTH_BUFFER and STENCIL_BUFFER have been removed
    * from glext.h, so shipping apps should not use those values.
    *
    * Note that neither EXT_framebuffer_object nor OES_framebuffer_object
    * support queries of the window system FBO.
    */
   case GL_DEPTH:
d242 3
a244 1
   case GL_STENCIL:
a260 6
   struct gl_renderbuffer *rb = att->Renderbuffer;

   /* tell driver that we're done rendering to this texture. */
   if (rb && rb->NeedsFinishRenderTexture)
      ctx->Driver.FinishRenderTexture(ctx, rb);

d263 4
a278 75
/**
 * Verify a couple error conditions that will lead to an incomplete FBO and
 * may cause problems for the driver's RenderTexture path.
 */
static bool
driver_RenderTexture_is_safe(const struct gl_renderbuffer_attachment *att)
{
   const struct gl_texture_image *const texImage =
      att->Texture->Image[att->CubeMapFace][att->TextureLevel];

   if (texImage->Width == 0 || texImage->Height == 0 || texImage->Depth == 0)
      return false;

   if ((texImage->TexObject->Target == GL_TEXTURE_1D_ARRAY
        && att->Zoffset >= texImage->Height)
       || (texImage->TexObject->Target != GL_TEXTURE_1D_ARRAY
           && att->Zoffset >= texImage->Depth))
      return false;

   return true;
}

/**
 * Create a renderbuffer which will be set up by the driver to wrap the
 * texture image slice.
 *
 * By using a gl_renderbuffer (like user-allocated renderbuffers), drivers get
 * to share most of their framebuffer rendering code between winsys,
 * renderbuffer, and texture attachments.
 *
 * The allocated renderbuffer uses a non-zero Name so that drivers can check
 * it for determining vertical orientation, but we use ~0 to make it fairly
 * unambiguous with actual user (non-texture) renderbuffers.
 */
void
_mesa_update_texture_renderbuffer(struct gl_context *ctx,
                                  struct gl_framebuffer *fb,
                                  struct gl_renderbuffer_attachment *att)
{
   struct gl_texture_image *texImage;
   struct gl_renderbuffer *rb;

   texImage = att->Texture->Image[att->CubeMapFace][att->TextureLevel];

   rb = att->Renderbuffer;
   if (!rb) {
      rb = ctx->Driver.NewRenderbuffer(ctx, ~0);
      if (!rb) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glFramebufferTexture()");
         return;
      }
      _mesa_reference_renderbuffer(&att->Renderbuffer, rb);

      /* This can't get called on a texture renderbuffer, so set it to NULL
       * for clarity compared to user renderbuffers.
       */
      rb->AllocStorage = NULL;

      rb->NeedsFinishRenderTexture = ctx->Driver.FinishRenderTexture != NULL;
   }

   if (!texImage)
      return;

   rb->_BaseFormat = texImage->_BaseFormat;
   rb->Format = texImage->TexFormat;
   rb->InternalFormat = texImage->InternalFormat;
   rb->Width = texImage->Width2;
   rb->Height = texImage->Height2;
   rb->NumSamples = texImage->NumSamples;
   rb->TexImage = texImage;

   if (driver_RenderTexture_is_safe(att))
      ctx->Driver.RenderTexture(ctx, fb, att);
}
d289 1
a289 2
                             GLenum texTarget, GLuint level, GLuint zoffset,
                             GLboolean layered)
a290 5
   struct gl_renderbuffer *rb = att->Renderbuffer;

   if (rb && rb->NeedsFinishRenderTexture)
      ctx->Driver.FinishRenderTexture(ctx, rb);

d294 2
d299 2
a305 1
   invalidate_framebuffer(fb);
a310 1
   att->Layered = layered;
d313 5
a317 1
   _mesa_update_texture_renderbuffer(ctx, fb, att);
a374 64
 * Fallback for ctx->Driver.ValidateFramebuffer()
 * Check if the renderbuffer's formats are supported by the software
 * renderer.
 * Drivers should probably override this.
 */
void
_mesa_validate_framebuffer(struct gl_context *ctx, struct gl_framebuffer *fb)
{
   gl_buffer_index buf;
   for (buf = 0; buf < BUFFER_COUNT; buf++) {
      const struct gl_renderbuffer *rb = fb->Attachment[buf].Renderbuffer;
      if (rb) {
         switch (rb->_BaseFormat) {
         case GL_ALPHA:
         case GL_LUMINANCE_ALPHA:
         case GL_LUMINANCE:
         case GL_INTENSITY:
         case GL_RED:
         case GL_RG:
            fb->_Status = GL_FRAMEBUFFER_UNSUPPORTED;
            return;

         default:
            switch (rb->Format) {
            /* XXX This list is likely incomplete. */
            case MESA_FORMAT_RGB9_E5_FLOAT:
               fb->_Status = GL_FRAMEBUFFER_UNSUPPORTED;
               return;
            default:;
               /* render buffer format is supported by software rendering */
            }
         }
      }
   }
}


/**
 * Return true if the framebuffer has a combined depth/stencil
 * renderbuffer attached.
 */
GLboolean
_mesa_has_depthstencil_combined(const struct gl_framebuffer *fb)
{
   const struct gl_renderbuffer_attachment *depth =
         &fb->Attachment[BUFFER_DEPTH];
   const struct gl_renderbuffer_attachment *stencil =
         &fb->Attachment[BUFFER_STENCIL];

   if (depth->Type == stencil->Type) {
      if (depth->Type == GL_RENDERBUFFER_EXT &&
          depth->Renderbuffer == stencil->Renderbuffer)
         return GL_TRUE;

      if (depth->Type == GL_TEXTURE &&
          depth->Texture == stencil->Texture)
         return GL_TRUE;
   }

   return GL_FALSE;
}


/**
d380 5
a384 3
   if (MESA_DEBUG_FLAGS & DEBUG_INCOMPLETE_FBO) {
      _mesa_debug(NULL, "attachment incomplete: %s\n", msg);
   }
d392 1
a392 1
fbo_incomplete(struct gl_context *ctx, const char *msg, int index)
d394 6
a399 10
   static GLuint msg_id;

   _mesa_gl_debug(ctx, &msg_id,
                  MESA_DEBUG_TYPE_OTHER,
                  MESA_DEBUG_SEVERITY_MEDIUM,
                  "FBO incomplete: %s [%d]\n", msg, index);

   if (MESA_DEBUG_FLAGS & DEBUG_INCOMPLETE_FBO) {
      _mesa_debug(NULL, "FBO Incomplete: %s [%d]\n", msg, index);
   }
d406 2
a407 2
GLboolean
_mesa_is_legal_color_format(const struct gl_context *ctx, GLenum baseFormat)
d417 1
a417 2
      return ctx->API == API_OPENGL_COMPAT &&
             ctx->Extensions.ARB_framebuffer_object;
a427 44
 * Is the given base format a legal format for a color renderbuffer?
 */
static GLboolean
is_format_color_renderable(const struct gl_context *ctx, gl_format format, GLenum internalFormat)
{
   const GLenum baseFormat =
      _mesa_get_format_base_format(format);
   GLboolean valid;

   valid = _mesa_is_legal_color_format(ctx, baseFormat);
   if (!valid || _mesa_is_desktop_gl(ctx)) {
      return valid;
   }

   /* Reject additional cases for GLES */
   switch (internalFormat) {
   case GL_RGBA8_SNORM:
   case GL_RGB32F:
   case GL_RGB32I:
   case GL_RGB32UI:
   case GL_RGB16F:
   case GL_RGB16I:
   case GL_RGB16UI:
   case GL_RGB8_SNORM:
   case GL_RGB8I:
   case GL_RGB8UI:
   case GL_SRGB8:
   case GL_RGB9_E5:
   case GL_RG8_SNORM:
   case GL_R8_SNORM:
      return GL_FALSE;
   default:
      break;
   }

   if (format == MESA_FORMAT_ARGB2101010 && internalFormat != GL_RGB10_A2) {
      return GL_FALSE;
   }

   return GL_TRUE;
}


/**
d478 2
d483 4
a486 30

      switch (texObj->Target) {
      case GL_TEXTURE_3D:
         if (att->Zoffset >= texImage->Depth) {
            att_incomplete("bad z offset");
            att->Complete = GL_FALSE;
            return;
         }
         break;
      case GL_TEXTURE_1D_ARRAY:
         if (att->Zoffset >= texImage->Height) {
            att_incomplete("bad 1D-array layer");
            att->Complete = GL_FALSE;
            return;
         }
         break;
      case GL_TEXTURE_2D_ARRAY:
         if (att->Zoffset >= texImage->Depth) {
            att_incomplete("bad 2D-array layer");
            att->Complete = GL_FALSE;
            return;
         }
         break;
      case GL_TEXTURE_CUBE_MAP_ARRAY:
         if (att->Zoffset >= texImage->Depth) {
            att_incomplete("bad cube-array layer");
            att->Complete = GL_FALSE;
            return;
         }
         break;
d492 1
a492 1
         if (!_mesa_is_legal_color_format(ctx, baseFormat)) {
d546 2
a547 1
         if (!_mesa_is_legal_color_format(ctx, baseFormat)) {
a606 1
   GLint fixedSampleLocations = -1;
a608 2
   bool layer_count_valid = false;
   GLuint layer_count = 0, att_layer_count;
d610 1
a610 4
   assert(_mesa_is_user_fbo(fb));

   /* we're changing framebuffer fields here */
   FLUSH_VERTICES(ctx, _NEW_BUFFERS);
a614 2
   fb->_AllColorBuffersFixedPoint = GL_TRUE;
   fb->_HasSNormOrFloatColorBuffer = GL_FALSE;
d624 1
a624 1
      gl_format attFormat;
d638 1
a638 1
            fbo_incomplete(ctx, "depth attachment incomplete", -1);
d647 1
a647 1
            fbo_incomplete(ctx, "stencil attachment incomplete", -1);
d656 1
a656 1
            fbo_incomplete(ctx, "color attachment incomplete", i);
d664 2
a665 1
         const struct gl_texture_image *texImg = att->Renderbuffer->TexImage;
d671 1
a671 1
         attFormat = texImg->TexFormat;
d673 1
a673 2

         if (!is_format_color_renderable(ctx, attFormat, texImg->InternalFormat) &&
d676 1
a676 17
            fbo_incomplete(ctx, "texture attachment incomplete", -1);
            return;
         }

         if (numSamples < 0)
            numSamples = texImg->NumSamples;
         else if (numSamples != texImg->NumSamples) {
            fb->_Status = GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE;
            fbo_incomplete(ctx, "inconsistent sample count", -1);
            return;
         }

         if (fixedSampleLocations < 0)
            fixedSampleLocations = texImg->FixedSampleLocations;
         else if (fixedSampleLocations != texImg->FixedSampleLocations) {
            fb->_Status = GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE;
            fbo_incomplete(ctx, "inconsistent fixed sample locations", -1);
d686 1
a686 1
         attFormat = att->Renderbuffer->Format;
a687 17

         if (numSamples < 0)
            numSamples = att->Renderbuffer->NumSamples;
         else if (numSamples != att->Renderbuffer->NumSamples) {
            fb->_Status = GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE;
            fbo_incomplete(ctx, "inconsistent sample count", -1);
            return;
         }

         /* RENDERBUFFER has fixedSampleLocations implicitly true */
         if (fixedSampleLocations < 0)
            fixedSampleLocations = GL_TRUE;
         else if (fixedSampleLocations != GL_TRUE) {
            fb->_Status = GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE;
            fbo_incomplete(ctx, "inconsistent fixed sample locations", -1);
            return;
         }
d694 5
d700 1
a700 1
      fb->_IntegerColor = _mesa_is_format_integer_color(attFormat);
d702 2
a703 14
      /* Update _AllColorBuffersFixedPoint and _HasSNormOrFloatColorBuffer. */
      if (i >= 0) {
         GLenum type = _mesa_get_format_datatype(attFormat);

         fb->_AllColorBuffersFixedPoint =
            fb->_AllColorBuffersFixedPoint &&
            (type == GL_UNSIGNED_NORMALIZED || type == GL_SIGNED_NORMALIZED);

         fb->_HasSNormOrFloatColorBuffer =
            fb->_HasSNormOrFloatColorBuffer ||
            type == GL_SIGNED_NORMALIZED || type == GL_FLOAT;
      }

      /* Error-check width, height, format */
d705 1
a705 1
         /* save format */
d715 1
a715 1
               fbo_incomplete(ctx, "width or height mismatch", -1);
d718 1
a718 1
            /* check that all color buffers are the same format */
d721 1
a721 1
               fbo_incomplete(ctx, "format mismatch", -1);
d725 6
a730 10
      }

      /* Check that the format is valid. (MESA_FORMAT_NONE means unsupported)
       */
      if (att->Type == GL_RENDERBUFFER &&
          att->Renderbuffer->Format == MESA_FORMAT_NONE) {
         fb->_Status = GL_FRAMEBUFFER_UNSUPPORTED;
         fbo_incomplete(ctx, "unsupported renderbuffer format", i);
         return;
      }
a731 14
      /* Check that layered rendering is consistent. */
      att_layer_count = att->Layered ? att->Renderbuffer->Depth : 0;
      if (!layer_count_valid) {
         layer_count = att_layer_count;
         layer_count_valid = true;
      } else if (layer_count != att_layer_count) {
         if (layer_count == 0 || att_layer_count == 0) {
            fb->_Status = GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS;
            fbo_incomplete(ctx, "framebuffer attachment layer mode is inconsistent", i);
         } else {
            fb->_Status = GL_FRAMEBUFFER_INCOMPLETE_LAYER_COUNT_ARB;
            fbo_incomplete(ctx, "framebuffer attachment layer count is inconsistent", i);
         }
         return;
d735 2
a736 3
   fb->Layered = layer_count > 0;

   if (_mesa_is_desktop_gl(ctx) && !ctx->Extensions.ARB_ES2_compatibility) {
d745 1
a745 1
	       fbo_incomplete(ctx, "missing drawbuffer", j);
d758 1
a758 1
            fbo_incomplete(ctx, "missing readbuffer", -1);
d763 3
d769 1
a769 1
      fbo_incomplete(ctx, "no attachments", -1);
d783 1
a783 1
         fbo_incomplete(ctx, "driver marked FBO as incomplete", -1);
d797 1
a797 1
      _mesa_update_framebuffer_visual(ctx, fb);
d803 1
a803 1
_mesa_IsRenderbuffer(GLuint renderbuffer)
d816 2
a817 2
static void
bind_renderbuffer(GLenum target, GLuint renderbuffer, bool allow_user_names)
d822 2
d839 1
a839 1
      else if (!newRb && !allow_user_names) {
a865 21
void GLAPIENTRY
_mesa_BindRenderbuffer(GLenum target, GLuint renderbuffer)
{
   GET_CURRENT_CONTEXT(ctx);

   /* OpenGL ES glBindRenderbuffer and glBindRenderbufferOES use this same
    * entry point, but they allow the use of user-generated names.
    */
   bind_renderbuffer(target, renderbuffer, _mesa_is_gles(ctx));
}

void GLAPIENTRY
_mesa_BindRenderbufferEXT(GLenum target, GLuint renderbuffer)
{
   /* This function should not be in the dispatch table for core profile /
    * OpenGL 3.1, so execution should never get here in those cases -- no
    * need for an explicit test.
    */
   bind_renderbuffer(target, renderbuffer, true);
}

d868 9
a876 11
 * Remove the specified renderbuffer or texture from any attachment point in
 * the framebuffer.
 *
 * \returns
 * \c true if the renderbuffer was detached from an attachment point.  \c
 * false otherwise.
 */
bool
_mesa_detach_renderbuffer(struct gl_context *ctx,
                          struct gl_framebuffer *fb,
                          const void *att)
d878 1
a878 3
   unsigned i;
   bool progress = false;

d880 1
a880 2
      if (fb->Attachment[i].Texture == att
          || fb->Attachment[i].Renderbuffer == att) {
a881 1
         progress = true;
d884 1
a884 17

   /* Section 4.4.4 (Framebuffer Completeness), subsection "Whole Framebuffer
    * Completeness," of the OpenGL 3.1 spec says:
    *
    *     "Performing any of the following actions may change whether the
    *     framebuffer is considered complete or incomplete:
    *
    *     ...
    *
    *        - Deleting, with DeleteTextures or DeleteRenderbuffers, an object
    *          containing an image that is attached to a framebuffer object
    *          that is bound to the framebuffer."
    */
   if (progress)
      invalidate_framebuffer(fb);

   return progress;
d889 1
a889 1
_mesa_DeleteRenderbuffers(GLsizei n, const GLuint *renderbuffers)
d894 1
d906 1
a906 1
               _mesa_BindRenderbuffer(GL_RENDERBUFFER_EXT, 0);
d909 2
a910 19
            /* Section 4.4.2 (Attaching Images to Framebuffer Objects),
             * subsection "Attaching Renderbuffer Images to a Framebuffer," of
             * the OpenGL 3.1 spec says:
             *
             *     "If a renderbuffer object is deleted while its image is
             *     attached to one or more attachment points in the currently
             *     bound framebuffer, then it is as if FramebufferRenderbuffer
             *     had been called, with a renderbuffer of 0, for each
             *     attachment point to which this image was attached in the
             *     currently bound framebuffer. In other words, this
             *     renderbuffer image is first detached from all attachment
             *     points in the currently bound framebuffer. Note that the
             *     renderbuffer image is specifically not detached from any
             *     non-bound framebuffers. Detaching the image from any
             *     non-bound framebuffers is the responsibility of the
             *     application.
             */
            if (_mesa_is_user_fbo(ctx->DrawBuffer)) {
               _mesa_detach_renderbuffer(ctx, ctx->DrawBuffer, rb);
d912 2
a913 3
            if (_mesa_is_user_fbo(ctx->ReadBuffer)
                && ctx->ReadBuffer != ctx->DrawBuffer) {
               _mesa_detach_renderbuffer(ctx, ctx->ReadBuffer, rb);
d933 1
a933 1
_mesa_GenRenderbuffers(GLsizei n, GLuint *renderbuffers)
d939 2
d964 3
a966 3
 * corresponding base format (one of GL_RGB, GL_RGBA, GL_STENCIL_INDEX,
 * GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL_EXT, GL_ALPHA, GL_LUMINANCE,
 * GL_LUMINANCE_ALPHA, GL_INTENSITY, etc).
d968 2
a969 2
 * This is similar to _mesa_base_tex_format() but the set of valid
 * internal formats is different.
d971 2
a972 5
 * Note that even if a format is determined to be legal here, validation
 * of the FBO may fail if the format is not supported by the driver/GPU.
 *
 * \param internalFormat  as passed to glRenderbufferStorage()
 * \return the base internal format, or 0 if internalFormat is illegal
a976 4
   /*
    * Notes: some formats such as alpha, luminance, etc. were added
    * with GL_ARB_framebuffer_object.
    */
d983 1
a983 27
      return ctx->API == API_OPENGL_COMPAT && ctx->Extensions.ARB_framebuffer_object
         ? GL_ALPHA : 0;
   case GL_LUMINANCE:
   case GL_LUMINANCE4:
   case GL_LUMINANCE8:
   case GL_LUMINANCE12:
   case GL_LUMINANCE16:
      return ctx->API == API_OPENGL_COMPAT && ctx->Extensions.ARB_framebuffer_object
         ? GL_LUMINANCE : 0;
   case GL_LUMINANCE_ALPHA:
   case GL_LUMINANCE4_ALPHA4:
   case GL_LUMINANCE6_ALPHA2:
   case GL_LUMINANCE8_ALPHA8:
   case GL_LUMINANCE12_ALPHA4:
   case GL_LUMINANCE12_ALPHA12:
   case GL_LUMINANCE16_ALPHA16:
      return ctx->API == API_OPENGL_COMPAT && ctx->Extensions.ARB_framebuffer_object
         ? GL_LUMINANCE_ALPHA : 0;
   case GL_INTENSITY:
   case GL_INTENSITY4:
   case GL_INTENSITY8:
   case GL_INTENSITY12:
   case GL_INTENSITY16:
      return ctx->API == API_OPENGL_COMPAT && ctx->Extensions.ARB_framebuffer_object
         ? GL_INTENSITY : 0;
   case GL_RGB8:
      return GL_RGB;
d988 1
d992 3
a994 3
      return _mesa_is_desktop_gl(ctx) ? GL_RGB : 0;
   case GL_SRGB8_EXT:
      return _mesa_is_desktop_gl(ctx) ? GL_RGB : 0;
d998 1
a998 3
      return GL_RGBA;
   case GL_RGBA:
   case GL_RGBA2:
d1001 2
a1002 4
      return _mesa_is_desktop_gl(ctx) ? GL_RGBA : 0;
   case GL_RGB10_A2:
   case GL_SRGB8_ALPHA8_EXT:
      return _mesa_is_desktop_gl(ctx) || _mesa_is_gles3(ctx) ? GL_RGBA : 0;
d1006 1
a1007 5
      /* There are extensions for GL_STENCIL_INDEX1 and GL_STENCIL_INDEX4 in
       * OpenGL ES, but Mesa does not currently support them.
       */
      return _mesa_is_desktop_gl(ctx) ? GL_STENCIL_INDEX : 0;
   case GL_STENCIL_INDEX8_EXT:
a1009 2
   case GL_DEPTH_COMPONENT32:
      return _mesa_is_desktop_gl(ctx) ? GL_DEPTH_COMPONENT : 0;
d1012 1
a1014 3
      return _mesa_is_desktop_gl(ctx)
         && ctx->Extensions.EXT_packed_depth_stencil
         ? GL_DEPTH_STENCIL_EXT : 0;
d1016 5
a1020 192
      return ctx->Extensions.EXT_packed_depth_stencil
         ? GL_DEPTH_STENCIL_EXT : 0;
   case GL_DEPTH_COMPONENT32F:
      return ctx->Version >= 30
         || (ctx->API == API_OPENGL_COMPAT && ctx->Extensions.ARB_depth_buffer_float)
         ? GL_DEPTH_COMPONENT : 0;
   case GL_DEPTH32F_STENCIL8:
      return ctx->Version >= 30
         || (ctx->API == API_OPENGL_COMPAT && ctx->Extensions.ARB_depth_buffer_float)
         ? GL_DEPTH_STENCIL : 0;
   case GL_RED:
   case GL_R16:
      return _mesa_is_desktop_gl(ctx) && ctx->Extensions.ARB_texture_rg
         ? GL_RED : 0;
   case GL_R8:
      return ctx->API != API_OPENGLES && ctx->Extensions.ARB_texture_rg
         ? GL_RED : 0;
   case GL_RG:
   case GL_RG16:
      return _mesa_is_desktop_gl(ctx) && ctx->Extensions.ARB_texture_rg
         ? GL_RG : 0;
   case GL_RG8:
      return ctx->API != API_OPENGLES && ctx->Extensions.ARB_texture_rg
         ? GL_RG : 0;
   /* signed normalized texture formats */
   case GL_RED_SNORM:
   case GL_R8_SNORM:
   case GL_R16_SNORM:
      return _mesa_is_desktop_gl(ctx) && ctx->Extensions.EXT_texture_snorm
         ? GL_RED : 0;
   case GL_RG_SNORM:
   case GL_RG8_SNORM:
   case GL_RG16_SNORM:
      return _mesa_is_desktop_gl(ctx) && ctx->Extensions.EXT_texture_snorm
         ? GL_RG : 0;
   case GL_RGB_SNORM:
   case GL_RGB8_SNORM:
   case GL_RGB16_SNORM:
      return _mesa_is_desktop_gl(ctx) && ctx->Extensions.EXT_texture_snorm
         ? GL_RGB : 0;
   case GL_RGBA_SNORM:
   case GL_RGBA8_SNORM:
   case GL_RGBA16_SNORM:
      return _mesa_is_desktop_gl(ctx) && ctx->Extensions.EXT_texture_snorm
         ? GL_RGBA : 0;
   case GL_ALPHA_SNORM:
   case GL_ALPHA8_SNORM:
   case GL_ALPHA16_SNORM:
      return ctx->API == API_OPENGL_COMPAT &&
             ctx->Extensions.EXT_texture_snorm &&
             ctx->Extensions.ARB_framebuffer_object ? GL_ALPHA : 0;
   case GL_R16F:
   case GL_R32F:
      return ((_mesa_is_desktop_gl(ctx) &&
               ctx->Extensions.ARB_texture_rg &&
               ctx->Extensions.ARB_texture_float) ||
              _mesa_is_gles3(ctx) /* EXT_color_buffer_float */ )
         ? GL_RED : 0;
   case GL_RG16F:
   case GL_RG32F:
      return ((_mesa_is_desktop_gl(ctx) &&
               ctx->Extensions.ARB_texture_rg &&
               ctx->Extensions.ARB_texture_float) ||
              _mesa_is_gles3(ctx) /* EXT_color_buffer_float */ )
         ? GL_RG : 0;
   case GL_RGB16F:
   case GL_RGB32F:
      return (_mesa_is_desktop_gl(ctx) && ctx->Extensions.ARB_texture_float)
         ? GL_RGB : 0;
   case GL_RGBA16F:
   case GL_RGBA32F:
      return ((_mesa_is_desktop_gl(ctx) &&
               ctx->Extensions.ARB_texture_float) ||
              _mesa_is_gles3(ctx) /* EXT_color_buffer_float */ )
         ? GL_RGBA : 0;
   case GL_ALPHA16F_ARB:
   case GL_ALPHA32F_ARB:
      return ctx->API == API_OPENGL_COMPAT &&
             ctx->Extensions.ARB_texture_float &&
             ctx->Extensions.ARB_framebuffer_object ? GL_ALPHA : 0;
   case GL_LUMINANCE16F_ARB:
   case GL_LUMINANCE32F_ARB:
      return ctx->API == API_OPENGL_COMPAT &&
             ctx->Extensions.ARB_texture_float &&
             ctx->Extensions.ARB_framebuffer_object ? GL_LUMINANCE : 0;
   case GL_LUMINANCE_ALPHA16F_ARB:
   case GL_LUMINANCE_ALPHA32F_ARB:
      return ctx->API == API_OPENGL_COMPAT &&
             ctx->Extensions.ARB_texture_float &&
             ctx->Extensions.ARB_framebuffer_object ? GL_LUMINANCE_ALPHA : 0;
   case GL_INTENSITY16F_ARB:
   case GL_INTENSITY32F_ARB:
      return ctx->API == API_OPENGL_COMPAT &&
             ctx->Extensions.ARB_texture_float &&
             ctx->Extensions.ARB_framebuffer_object ? GL_INTENSITY : 0;
   case GL_RGB9_E5:
      return (_mesa_is_desktop_gl(ctx)
              && ctx->Extensions.EXT_texture_shared_exponent)
         ? GL_RGB : 0;
   case GL_R11F_G11F_B10F:
      return ((_mesa_is_desktop_gl(ctx) && ctx->Extensions.EXT_packed_float) ||
              _mesa_is_gles3(ctx) /* EXT_color_buffer_float */ )
         ? GL_RGB : 0;

   case GL_RGBA8UI_EXT:
   case GL_RGBA16UI_EXT:
   case GL_RGBA32UI_EXT:
   case GL_RGBA8I_EXT:
   case GL_RGBA16I_EXT:
   case GL_RGBA32I_EXT:
      return ctx->Version >= 30
         || (_mesa_is_desktop_gl(ctx) &&
             ctx->Extensions.EXT_texture_integer) ? GL_RGBA : 0;

   case GL_RGB8UI_EXT:
   case GL_RGB16UI_EXT:
   case GL_RGB32UI_EXT:
   case GL_RGB8I_EXT:
   case GL_RGB16I_EXT:
   case GL_RGB32I_EXT:
      return _mesa_is_desktop_gl(ctx) && ctx->Extensions.EXT_texture_integer
         ? GL_RGB : 0;
   case GL_R8UI:
   case GL_R8I:
   case GL_R16UI:
   case GL_R16I:
   case GL_R32UI:
   case GL_R32I:
      return ctx->Version >= 30
         || (_mesa_is_desktop_gl(ctx) &&
             ctx->Extensions.ARB_texture_rg &&
             ctx->Extensions.EXT_texture_integer) ? GL_RED : 0;

   case GL_RG8UI:
   case GL_RG8I:
   case GL_RG16UI:
   case GL_RG16I:
   case GL_RG32UI:
   case GL_RG32I:
      return ctx->Version >= 30
         || (_mesa_is_desktop_gl(ctx) &&
             ctx->Extensions.ARB_texture_rg &&
             ctx->Extensions.EXT_texture_integer) ? GL_RG : 0;

   case GL_INTENSITY8I_EXT:
   case GL_INTENSITY8UI_EXT:
   case GL_INTENSITY16I_EXT:
   case GL_INTENSITY16UI_EXT:
   case GL_INTENSITY32I_EXT:
   case GL_INTENSITY32UI_EXT:
      return ctx->API == API_OPENGL_COMPAT &&
             ctx->Extensions.EXT_texture_integer &&
             ctx->Extensions.ARB_framebuffer_object ? GL_INTENSITY : 0;

   case GL_LUMINANCE8I_EXT:
   case GL_LUMINANCE8UI_EXT:
   case GL_LUMINANCE16I_EXT:
   case GL_LUMINANCE16UI_EXT:
   case GL_LUMINANCE32I_EXT:
   case GL_LUMINANCE32UI_EXT:
      return ctx->API == API_OPENGL_COMPAT &&
             ctx->Extensions.EXT_texture_integer &&
             ctx->Extensions.ARB_framebuffer_object ? GL_LUMINANCE : 0;

   case GL_LUMINANCE_ALPHA8I_EXT:
   case GL_LUMINANCE_ALPHA8UI_EXT:
   case GL_LUMINANCE_ALPHA16I_EXT:
   case GL_LUMINANCE_ALPHA16UI_EXT:
   case GL_LUMINANCE_ALPHA32I_EXT:
   case GL_LUMINANCE_ALPHA32UI_EXT:
      return ctx->API == API_OPENGL_COMPAT &&
             ctx->Extensions.EXT_texture_integer &&
             ctx->Extensions.ARB_framebuffer_object ? GL_LUMINANCE_ALPHA : 0;

   case GL_ALPHA8I_EXT:
   case GL_ALPHA8UI_EXT:
   case GL_ALPHA16I_EXT:
   case GL_ALPHA16UI_EXT:
   case GL_ALPHA32I_EXT:
   case GL_ALPHA32UI_EXT:
      return ctx->API == API_OPENGL_COMPAT &&
             ctx->Extensions.EXT_texture_integer &&
             ctx->Extensions.ARB_framebuffer_object ? GL_ALPHA : 0;

   case GL_RGB10_A2UI:
      return (_mesa_is_desktop_gl(ctx) &&
              ctx->Extensions.ARB_texture_rgb10_a2ui)
         || _mesa_is_gles3(ctx) ? GL_RGBA : 0;

   case GL_RGB565:
      return _mesa_is_gles(ctx) || ctx->Extensions.ARB_ES2_compatibility
         ? GL_RGB : 0;
d1037 1
a1037 1
   if (_mesa_is_user_fbo(fb)) {
d1057 1
a1057 1
 * Helper function used by _mesa_RenderbufferStorage() and 
d1059 1
a1059 1
 * samples will be NO_SAMPLES if called by _mesa_RenderbufferStorage().
d1066 1
a1066 1
      "glRenderbufferStorage" : "glRenderbufferStorageMultisample";
a1068 1
   GLenum sample_count_error;
d1071 1
a1071 14
   if (MESA_VERBOSE & VERBOSE_API) {
      if (samples == NO_SAMPLES)
         _mesa_debug(ctx, "%s(%s, %s, %d, %d)\n",
                     func,
                     _mesa_lookup_enum_by_nr(target),
                     _mesa_lookup_enum_by_nr(internalFormat),
                     width, height);
      else
         _mesa_debug(ctx, "%s(%s, %s, %d, %d, %d)\n",
                     func,
                     _mesa_lookup_enum_by_nr(target),
                     _mesa_lookup_enum_by_nr(internalFormat),
                     width, height, samples);
   }
d1080 1
a1080 2
      _mesa_error(ctx, GL_INVALID_ENUM, "%s(internalFormat=%s)",
                  func, _mesa_lookup_enum_by_nr(internalFormat));
d1084 1
a1084 1
   if (width < 0 || width > (GLsizei) ctx->Const.MaxRenderbufferSize) {
d1089 1
a1089 1
   if (height < 0 || height > (GLsizei) ctx->Const.MaxRenderbufferSize) {
d1098 4
a1101 10
   else {
      /* check the sample count;
       * note: driver may choose to use more samples than what's requested
       */
      sample_count_error = _mesa_check_sample_count(ctx, target,
            internalFormat, samples);
      if (sample_count_error != GL_NO_ERROR) {
         _mesa_error(ctx, sample_count_error, "%s(samples)", func);
         return;
      }
d1114 1
a1114 2
       rb->Height == (GLuint) height &&
       rb->NumSamples == samples) {
d1127 1
a1127 1
      /* If rb->Format == MESA_FORMAT_NONE, the format is unsupported. */
d1151 1
d1157 1
d1182 1
d1186 2
a1187 2
 * Helper function for _mesa_GetRenderbufferParameteriv() and
 * _mesa_GetFramebufferAttachmentParameteriv()
d1196 30
a1225 3
   if (_mesa_base_format_has_channel(baseFormat, pname))
      return _mesa_get_format_bits(format, pname);
   else
d1227 1
d1233 1
a1233 1
_mesa_RenderbufferStorage(GLenum target, GLenum internalFormat,
d1275 1
a1275 1
_mesa_GetRenderbufferParameteriv(GLenum target, GLenum pname, GLint *params)
d1280 2
d1318 1
a1318 2
      if ((_mesa_is_desktop_gl(ctx) && ctx->Extensions.ARB_framebuffer_object)
          || _mesa_is_gles3(ctx)) {
d1332 1
a1332 1
_mesa_IsFramebuffer(GLuint framebuffer)
d1356 1
a1356 1
   if (_mesa_is_winsys_fbo(fb))
d1361 3
a1363 2
      if (att->Texture && att->Renderbuffer->TexImage
          && driver_RenderTexture_is_safe(att)) {
d1378 1
a1378 1
   if (_mesa_is_winsys_fbo(fb))
d1385 2
a1386 3
         struct gl_renderbuffer *rb = att->Renderbuffer;
         if (rb && rb->NeedsFinishRenderTexture) {
            ctx->Driver.FinishRenderTexture(ctx, rb);
d1393 2
a1394 2
static void
bind_framebuffer(GLenum target, GLuint framebuffer, bool allow_user_names)
d1403 1
d1408 8
d1417 1
d1434 1
d1451 1
a1451 1
      else if (!newDrawFb && !allow_user_names) {
d1513 5
a1517 2
      /* check if old framebuffer had any texture attachments */
      if (oldDrawFb)
a1530 20
void GLAPIENTRY
_mesa_BindFramebuffer(GLenum target, GLuint framebuffer)
{
   GET_CURRENT_CONTEXT(ctx);

   /* OpenGL ES glBindFramebuffer and glBindFramebufferOES use this same entry
    * point, but they allow the use of user-generated names.
    */
   bind_framebuffer(target, framebuffer, _mesa_is_gles(ctx));
}

void GLAPIENTRY
_mesa_BindFramebufferEXT(GLenum target, GLuint framebuffer)
{
   /* This function should not be in the dispatch table for core profile /
    * OpenGL 3.1, so execution should never get here in those cases -- no
    * need for an explicit test.
    */
   bind_framebuffer(target, framebuffer, true);
}
d1533 1
a1533 1
_mesa_DeleteFramebuffers(GLsizei n, const GLuint *framebuffers)
d1538 1
d1554 1
a1554 1
                  _mesa_BindFramebuffer(GL_DRAW_FRAMEBUFFER_EXT, 0);
d1559 1
a1559 1
                  _mesa_BindFramebuffer(GL_READ_FRAMEBUFFER_EXT, 0);
d1567 2
a1568 2
                  _mesa_BindFramebuffer(GL_FRAMEBUFFER_EXT, 0);
               }
d1587 1
a1587 1
_mesa_GenFramebuffers(GLsizei n, GLuint *framebuffers)
d1593 2
d1618 1
a1618 1
_mesa_CheckFramebufferStatus(GLenum target)
d1625 21
a1645 6
   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glCheckFramebufferStatus(%s)\n",
                  _mesa_lookup_enum_by_nr(target));

   buffer = get_framebuffer_target(ctx, target);
   if (!buffer) {
d1647 1
a1647 1
      return 0;
d1650 1
a1650 1
   if (_mesa_is_winsys_fbo(buffer)) {
a1664 24
/**
 * Replicate the src attachment point. Used by framebuffer_texture() when
 * the same texture is attached at GL_DEPTH_ATTACHMENT and
 * GL_STENCIL_ATTACHMENT.
 */
static void
reuse_framebuffer_texture_attachment(struct gl_framebuffer *fb,
                                     gl_buffer_index dst,
                                     gl_buffer_index src)
{
   struct gl_renderbuffer_attachment *dst_att = &fb->Attachment[dst];
   struct gl_renderbuffer_attachment *src_att = &fb->Attachment[src];

   assert(src_att->Texture != NULL);
   assert(src_att->Renderbuffer != NULL);

   _mesa_reference_texobj(&dst_att->Texture, src_att->Texture);
   _mesa_reference_renderbuffer(&dst_att->Renderbuffer, src_att->Renderbuffer);
   dst_att->Type = src_att->Type;
   dst_att->Complete = src_att->Complete;
   dst_att->TextureLevel = src_att->TextureLevel;
   dst_att->Zoffset = src_att->Zoffset;
}

d1667 1
a1667 4
 * Common code called by glFramebufferTexture1D/2D/3DEXT() and
 * glFramebufferTextureLayerEXT().
 * Note: glFramebufferTextureLayerEXT() has no textarget parameter so we'll
 * get textarget=0 in that case.
d1672 1
a1672 1
                    GLint level, GLint zoffset, GLboolean layered)
d1677 18
a1694 1
   GLenum maxLevelsTarget;
d1696 1
a1696 2
   fb = get_framebuffer_target(ctx, target);
   if (!fb) {
d1702 2
d1705 1
a1705 1
   if (_mesa_is_winsys_fbo(fb)) {
d1711 1
d1721 1
a1721 5
            /* If textarget == 0 it means we're being called by
             * glFramebufferTextureLayer() and textarget is not used.
             * The only legal texture types for that function are 3D and
             * 1D/2D arrays textures.
             */
d1724 1
a1724 3
                (texObj->Target != GL_TEXTURE_2D_ARRAY_EXT) &&
                (texObj->Target != GL_TEXTURE_CUBE_MAP_ARRAY) &&
                (texObj->Target != GL_TEXTURE_2D_MULTISAMPLE_ARRAY);
a1726 1
            /* Make sure textarget is consistent with the texture's type */
d1728 1
a1728 1
                ? !_mesa_is_cube_face(textarget)
d1756 2
a1757 5
               (texObj->Target == GL_TEXTURE_2D_ARRAY_EXT) ||
               (texObj->Target == GL_TEXTURE_CUBE_MAP_ARRAY) ||
               (texObj->Target == GL_TEXTURE_2D_MULTISAMPLE_ARRAY)) {
         if (zoffset < 0 ||
             zoffset >= (GLint) ctx->Const.MaxArrayTextureLayers) {
d1764 2
a1765 3
      maxLevelsTarget = textarget ? textarget : texObj->Target;
      if ((level < 0) ||
          (level >= _mesa_max_texture_levels(ctx, maxLevelsTarget))) {
d1783 2
a1784 36
      if (attachment == GL_DEPTH_ATTACHMENT &&
          texObj == fb->Attachment[BUFFER_STENCIL].Texture &&
          level == fb->Attachment[BUFFER_STENCIL].TextureLevel &&
          _mesa_tex_target_to_face(textarget) ==
          fb->Attachment[BUFFER_STENCIL].CubeMapFace &&
          zoffset == fb->Attachment[BUFFER_STENCIL].Zoffset) {
	 /* The texture object is already attached to the stencil attachment
	  * point. Don't create a new renderbuffer; just reuse the stencil
	  * attachment's. This is required to prevent a GL error in
	  * glGetFramebufferAttachmentParameteriv(GL_DEPTH_STENCIL).
	  */
	 reuse_framebuffer_texture_attachment(fb, BUFFER_DEPTH,
	                                      BUFFER_STENCIL);
      } else if (attachment == GL_STENCIL_ATTACHMENT &&
	         texObj == fb->Attachment[BUFFER_DEPTH].Texture &&
                 level == fb->Attachment[BUFFER_DEPTH].TextureLevel &&
                 _mesa_tex_target_to_face(textarget) ==
                 fb->Attachment[BUFFER_DEPTH].CubeMapFace &&
                 zoffset == fb->Attachment[BUFFER_DEPTH].Zoffset) {
	 /* As above, but with depth and stencil transposed. */
	 reuse_framebuffer_texture_attachment(fb, BUFFER_STENCIL,
	                                      BUFFER_DEPTH);
      } else {
	 _mesa_set_texture_attachment(ctx, fb, att, texObj, textarget,
	                              level, zoffset, layered);
	 if (attachment == GL_DEPTH_STENCIL_ATTACHMENT) {
	    /* Above we created a new renderbuffer and attached it to the
	     * depth attachment point. Now attach it to the stencil attachment
	     * point too.
	     */
	    assert(att == &fb->Attachment[BUFFER_DEPTH]);
	    reuse_framebuffer_texture_attachment(fb,BUFFER_STENCIL,
	                                         BUFFER_DEPTH);
	 }
      }

a1796 4
      if (attachment == GL_DEPTH_STENCIL_ATTACHMENT) {
	 assert(att == &fb->Attachment[BUFFER_DEPTH]);
	 _mesa_remove_attachment(ctx, &fb->Attachment[BUFFER_STENCIL]);
      }
d1807 1
a1807 1
_mesa_FramebufferTexture1D(GLenum target, GLenum attachment,
d1812 4
a1815 20
   if (texture != 0) {
      GLboolean error;

      switch (textarget) {
      case GL_TEXTURE_1D:
         error = GL_FALSE;
         break;
      case GL_TEXTURE_1D_ARRAY:
         error = !ctx->Extensions.EXT_texture_array;
         break;
      default:
         error = GL_TRUE;
      }

      if (error) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glFramebufferTexture1DEXT(textarget=%s)",
                     _mesa_lookup_enum_by_nr(textarget));
         return;
      }
d1819 1
a1819 1
                       level, 0, GL_FALSE);
d1824 1
a1824 1
_mesa_FramebufferTexture2D(GLenum target, GLenum attachment,
d1829 7
a1835 38
   if (texture != 0) {
      GLboolean error;

      switch (textarget) {
      case GL_TEXTURE_2D:
         error = GL_FALSE;
         break;
      case GL_TEXTURE_RECTANGLE:
         error = _mesa_is_gles(ctx)
            || !ctx->Extensions.NV_texture_rectangle;
         break;
      case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
      case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
      case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
         error = !ctx->Extensions.ARB_texture_cube_map;
         break;
      case GL_TEXTURE_2D_ARRAY:
         error = (_mesa_is_gles(ctx) && ctx->Version < 30)
            || !ctx->Extensions.EXT_texture_array;
         break;
      case GL_TEXTURE_2D_MULTISAMPLE:
      case GL_TEXTURE_2D_MULTISAMPLE_ARRAY:
         error = _mesa_is_gles(ctx)
            || !ctx->Extensions.ARB_texture_multisample;
         break;
      default:
         error = GL_TRUE;
      }

      if (error) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glFramebufferTexture2DEXT(textarget=%s)",
                     _mesa_lookup_enum_by_nr(textarget));
         return;
      }
d1839 1
a1839 1
                       level, 0, GL_FALSE);
d1844 1
a1844 1
_mesa_FramebufferTexture3D(GLenum target, GLenum attachment,
d1851 1
a1851 1
      _mesa_error(ctx, GL_INVALID_OPERATION,
d1857 1
a1857 1
                       level, zoffset, GL_FALSE);
d1862 1
a1862 1
_mesa_FramebufferTextureLayer(GLenum target, GLenum attachment,
d1868 1
a1868 17
                       level, layer, GL_FALSE);
}


void GLAPIENTRY
_mesa_FramebufferTexture(GLenum target, GLenum attachment,
                         GLuint texture, GLint level)
{
   GET_CURRENT_CONTEXT(ctx);

   if (ctx->Version >= 32 || ctx->Extensions.ARB_geometry_shader4) {
      framebuffer_texture(ctx, "Layer", target, attachment, 0, texture,
                          level, 0, GL_TRUE);
   } else {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "unsupported function (glFramebufferTexture) called");
   }
d1873 1
a1873 1
_mesa_FramebufferRenderbuffer(GLenum target, GLenum attachment,
d1882 27
a1908 3
   fb = get_framebuffer_target(ctx, target);
   if (!fb) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glFramebufferRenderbufferEXT(target)");
d1918 1
a1918 1
   if (_mesa_is_winsys_fbo(fb)) {
d1974 1
a1974 1
   _mesa_update_framebuffer_visual(ctx, fb);
d1979 1
a1979 1
_mesa_GetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment,
a1983 1
   GLenum err;
d1986 1
a1986 2
   /* The error differs in GL and GLES. */
   err = _mesa_is_desktop_gl(ctx) ? GL_INVALID_OPERATION : GL_INVALID_ENUM;
d1988 23
a2010 2
   buffer = get_framebuffer_target(ctx, target);
   if (!buffer) {
d2016 1
a2016 24
   if (_mesa_is_winsys_fbo(buffer)) {
      /* Page 126 (page 136 of the PDF) of the OpenGL ES 2.0.25 spec
       * says:
       *
       *     "If the framebuffer currently bound to target is zero, then
       *     INVALID_OPERATION is generated."
       *
       * The EXT_framebuffer_object spec has the same wording, and the
       * OES_framebuffer_object spec refers to the EXT_framebuffer_object
       * spec.
       */
      if ((!_mesa_is_desktop_gl(ctx) || !ctx->Extensions.ARB_framebuffer_object)
          && !_mesa_is_gles3(ctx)) {
	 _mesa_error(ctx, GL_INVALID_OPERATION,
		     "glGetFramebufferAttachmentParameteriv(bound FBO = 0)");
	 return;
      }

      if (_mesa_is_gles3(ctx) && attachment != GL_BACK &&
          attachment != GL_DEPTH && attachment != GL_STENCIL) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glGetFramebufferAttachmentParameteriv(attachment)");
         return;
      }
d2048 1
a2048 2
      *params = _mesa_is_winsys_fbo(buffer)
         ? GL_FRAMEBUFFER_DEFAULT : att->Type;
d2059 1
a2059 5
         if (_mesa_is_desktop_gl(ctx) || _mesa_is_gles3(ctx)) {
            *params = 0;
         } else {
            goto invalid_pname_enum;
         }
d2067 1
a2067 1
         _mesa_error(ctx, err,
d2071 2
a2072 1
         goto invalid_pname_enum;
d2085 1
a2085 1
         _mesa_error(ctx, err,
d2089 2
a2090 1
         goto invalid_pname_enum;
d2094 1
a2094 6
      if (ctx->API == API_OPENGLES) {
         goto invalid_pname_enum;
      } else if (att->Type == GL_NONE) {
         _mesa_error(ctx, err,
                     "glGetFramebufferAttachmentParameterivEXT(pname)");
      } else if (att->Type == GL_TEXTURE) {
d2102 4
d2107 2
a2108 1
         goto invalid_pname_enum;
d2112 3
a2114 3
      if ((!_mesa_is_desktop_gl(ctx) || !ctx->Extensions.ARB_framebuffer_object)
          && !_mesa_is_gles3(ctx)) {
         goto invalid_pname_enum;
d2117 1
a2117 1
         _mesa_error(ctx, err,
d2121 1
a2121 8
         if (ctx->Extensions.EXT_framebuffer_sRGB) {
            *params = _mesa_get_format_color_encoding(att->Renderbuffer->Format);
         }
         else {
            /* According to ARB_framebuffer_sRGB, we should return LINEAR
             * if the sRGB conversion is unsupported. */
            *params = GL_LINEAR;
         }
d2125 4
a2128 4
      if ((ctx->API != API_OPENGL_COMPAT || !ctx->Extensions.ARB_framebuffer_object)
          && ctx->API != API_OPENGL_CORE
          && !_mesa_is_gles3(ctx)) {
         goto invalid_pname_enum;
d2131 1
a2131 1
         _mesa_error(ctx, err,
d2136 1
a2136 17

         /* Page 235 (page 247 of the PDF) in section 6.1.13 of the OpenGL ES
          * 3.0.1 spec says:
          *
          *     "If pname is FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE.... If
          *     attachment is DEPTH_STENCIL_ATTACHMENT the query will fail and
          *     generate an INVALID_OPERATION error.
          */
         if (_mesa_is_gles3(ctx) && attachment == GL_DEPTH_STENCIL_ATTACHMENT) {
            _mesa_error(ctx, GL_INVALID_OPERATION,
                        "glGetFramebufferAttachmentParameteriv(cannot query "
                        "GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE of "
                        "GL_DEPTH_STENCIL_ATTACHMENT");
            return;
         }

         if (format == MESA_FORMAT_S8) {
a2139 9
         else if (format == MESA_FORMAT_Z32_FLOAT_X24S8) {
            /* depends on the attachment parameter */
            if (attachment == GL_STENCIL_ATTACHMENT) {
               *params = GL_INDEX;
            }
            else {
               *params = GL_FLOAT;
            }
         }
d2151 3
a2153 3
      if ((!_mesa_is_desktop_gl(ctx) || !ctx->Extensions.ARB_framebuffer_object)
          && !_mesa_is_gles3(ctx)) {
         goto invalid_pname_enum;
d2156 1
a2156 1
         _mesa_error(ctx, err,
d2181 3
a2183 1
      goto invalid_pname_enum;
a2184 7

   return;

invalid_pname_enum:
   _mesa_error(ctx, GL_INVALID_ENUM,
               "glGetFramebufferAttachmentParameteriv(pname)");
   return;
d2189 1
a2189 1
_mesa_GenerateMipmap(GLenum target)
a2190 1
   struct gl_texture_image *srcImage;
a2191 2
   GLboolean error;

d2194 2
a2195 1
   FLUSH_VERTICES(ctx, 0);
a2198 2
      error = _mesa_is_gles(ctx);
      break;
a2199 2
      error = GL_FALSE;
      break;
a2200 2
      error = ctx->API == API_OPENGLES;
      break;
d2202 1
a2202 8
      error = !ctx->Extensions.ARB_texture_cube_map;
      break;
   case GL_TEXTURE_1D_ARRAY:
      error = _mesa_is_gles(ctx) || !ctx->Extensions.EXT_texture_array;
      break;
   case GL_TEXTURE_2D_ARRAY:
      error = (_mesa_is_gles(ctx) && ctx->Version < 30)
         || !ctx->Extensions.EXT_texture_array;
d2205 2
a2206 6
      error = GL_TRUE;
   }

   if (error) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glGenerateMipmapEXT(target=%s)",
                  _mesa_lookup_enum_by_nr(target));
a2224 18

   srcImage = _mesa_select_tex_image(ctx, texObj, target, texObj->BaseLevel);
   if (!srcImage) {
      _mesa_unlock_texture(ctx, texObj);
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glGenerateMipmap(zero size base image)");
      return;
   }

   if (_mesa_is_enum_format_integer(srcImage->InternalFormat) ||
       _mesa_is_depthstencil_format(srcImage->InternalFormat) ||
       _mesa_is_stencil_format(srcImage->InternalFormat)) {
      _mesa_unlock_texture(ctx, texObj);
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glGenerateMipmap(invalid internal format)");
      return;
   }

d2239 2
d2242 1
a2242 2
find_attachment(const struct gl_framebuffer *fb,
                const struct gl_renderbuffer *rb)
a2252 88
/**
 * Helper function for checking if the datatypes of color buffers are
 * compatible for glBlitFramebuffer.  From the 3.1 spec, page 198:
 *
 * "GL_INVALID_OPERATION is generated if mask contains GL_COLOR_BUFFER_BIT
 *  and any of the following conditions hold:
 *   - The read buffer contains fixed-point or floating-point values and any
 *     draw buffer contains neither fixed-point nor floating-point values.
 *   - The read buffer contains unsigned integer values and any draw buffer
 *     does not contain unsigned integer values.
 *   - The read buffer contains signed integer values and any draw buffer
 *     does not contain signed integer values."
 */
static GLboolean
compatible_color_datatypes(gl_format srcFormat, gl_format dstFormat)
{
   GLenum srcType = _mesa_get_format_datatype(srcFormat);
   GLenum dstType = _mesa_get_format_datatype(dstFormat);

   if (srcType != GL_INT && srcType != GL_UNSIGNED_INT) {
      assert(srcType == GL_UNSIGNED_NORMALIZED ||
             srcType == GL_SIGNED_NORMALIZED ||
             srcType == GL_FLOAT);
      /* Boil any of those types down to GL_FLOAT */
      srcType = GL_FLOAT;
   }

   if (dstType != GL_INT && dstType != GL_UNSIGNED_INT) {
      assert(dstType == GL_UNSIGNED_NORMALIZED ||
             dstType == GL_SIGNED_NORMALIZED ||
             dstType == GL_FLOAT);
      /* Boil any of those types down to GL_FLOAT */
      dstType = GL_FLOAT;
   }

   return srcType == dstType;
}


static GLboolean
compatible_resolve_formats(const struct gl_renderbuffer *readRb,
                           const struct gl_renderbuffer *drawRb)
{
   GLenum readFormat, drawFormat;

   /* The simple case where we know the backing Mesa formats are the same.
    */
   if (_mesa_get_srgb_format_linear(readRb->Format) ==
       _mesa_get_srgb_format_linear(drawRb->Format)) {
      return GL_TRUE;
   }

   /* The Mesa formats are different, so we must check whether the internal
    * formats are compatible.
    *
    * Under some circumstances, the user may request e.g. two GL_RGBA8
    * textures and get two entirely different Mesa formats like RGBA8888 and
    * ARGB8888. Drivers behaving like that should be able to cope with
    * non-matching formats by themselves, because it's not the user's fault.
    *
    * Blits between linear and sRGB formats are also allowed.
    */
   readFormat = _mesa_get_nongeneric_internalformat(readRb->InternalFormat);
   drawFormat = _mesa_get_nongeneric_internalformat(drawRb->InternalFormat);
   readFormat = _mesa_get_linear_internalformat(readFormat);
   drawFormat = _mesa_get_linear_internalformat(drawFormat);

   if (readFormat == drawFormat) {
      return GL_TRUE;
   }

   return GL_FALSE;
}

static GLboolean
is_valid_blit_filter(const struct gl_context *ctx, GLenum filter)
{
   switch (filter) {
   case GL_NEAREST:
   case GL_LINEAR:
      return true;
   case GL_SCALED_RESOLVE_FASTEST_EXT:
   case GL_SCALED_RESOLVE_NICEST_EXT:
      return ctx->Extensions.EXT_framebuffer_multisample_blit_scaled;
   default:
      return false;
   }
}
d2261 1
a2261 1
_mesa_BlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1,
d2269 1
d2272 2
a2273 8
   FLUSH_VERTICES(ctx, 0);

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx,
                  "glBlitFramebuffer(%d, %d, %d, %d,  %d, %d, %d, %d, 0x%x, %s)\n",
                  srcX0, srcY0, srcX1, srcY1,
                  dstX0, dstY0, dstX1, dstY1,
                  mask, _mesa_lookup_enum_by_nr(filter));
d2297 2
a2298 11
   if (!is_valid_blit_filter(ctx, filter)) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glBlitFramebufferEXT(%s)",
                  _mesa_lookup_enum_by_nr(filter));
      return;
   }

   if ((filter == GL_SCALED_RESOLVE_FASTEST_EXT ||
        filter == GL_SCALED_RESOLVE_NICEST_EXT) &&
        (readFb->Visual.samples == 0 || drawFb->Visual.samples > 0)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glBlitFramebufferEXT(%s)",
                  _mesa_lookup_enum_by_nr(filter));
d2311 1
a2311 1
             "glBlitFramebufferEXT(depth/stencil requires GL_NEAREST filter)");
d2317 2
a2318 4
      const GLuint numColorDrawBuffers = ctx->DrawBuffer->_NumColorDrawBuffers;
      const struct gl_renderbuffer *colorReadRb = readFb->_ColorReadBuffer;
      const struct gl_renderbuffer *colorDrawRb = NULL;
      GLuint i;
d2326 3
a2328 54
      if (!colorReadRb || numColorDrawBuffers == 0) {
         mask &= ~GL_COLOR_BUFFER_BIT;
      }
      else {
         for (i = 0; i < numColorDrawBuffers; i++) {
            colorDrawRb = ctx->DrawBuffer->_ColorDrawBuffers[i];
            if (!colorDrawRb)
               continue;

            /* Page 193 (page 205 of the PDF) in section 4.3.2 of the OpenGL
             * ES 3.0.1 spec says:
             *
             *     "If the source and destination buffers are identical, an
             *     INVALID_OPERATION error is generated. Different mipmap
             *     levels of a texture, different layers of a three-
             *     dimensional texture or two-dimensional array texture, and
             *     different faces of a cube map texture do not constitute
             *     identical buffers."
             */
            if (_mesa_is_gles3(ctx) && (colorDrawRb == colorReadRb)) {
               _mesa_error(ctx, GL_INVALID_OPERATION,
                           "glBlitFramebuffer(source and destination color "
                           "buffer cannot be the same)");
               return;
            }

            if (!compatible_color_datatypes(colorReadRb->Format,
                                            colorDrawRb->Format)) {
               _mesa_error(ctx, GL_INVALID_OPERATION,
                           "glBlitFramebufferEXT(color buffer datatypes mismatch)");
               return;
            }
            /* extra checks for multisample copies... */
            if (readFb->Visual.samples > 0 || drawFb->Visual.samples > 0) {
               /* color formats must match */
               if (!compatible_resolve_formats(colorReadRb, colorDrawRb)) {
                  _mesa_error(ctx, GL_INVALID_OPERATION,
                         "glBlitFramebufferEXT(bad src/dst multisample pixel formats)");
                  return;
               }
            }
         }
         if (filter != GL_NEAREST) {
            /* From EXT_framebuffer_multisample_blit_scaled specification:
             * "Calling BlitFramebuffer will result in an INVALID_OPERATION error
             * if filter is not NEAREST and read buffer contains integer data."
             */
            GLenum type = _mesa_get_format_datatype(colorReadRb->Format);
            if (type == GL_INT || type == GL_UNSIGNED_INT) {
               _mesa_error(ctx, GL_INVALID_OPERATION,
                           "glBlitFramebufferEXT(integer color type)");
               return;
            }
         }
d2330 3
d2336 2
a2337 4
      struct gl_renderbuffer *readRb =
         readFb->Attachment[BUFFER_STENCIL].Renderbuffer;
      struct gl_renderbuffer *drawRb =
         drawFb->Attachment[BUFFER_STENCIL].Renderbuffer;
d2346 1
d2349 5
a2353 36
      else {
         int read_z_bits, draw_z_bits;

         if (_mesa_is_gles3(ctx) && (drawRb == readRb)) {
            _mesa_error(ctx, GL_INVALID_OPERATION,
                        "glBlitFramebuffer(source and destination stencil "
                        "buffer cannot be the same)");
            return;
         }

         if (_mesa_get_format_bits(readRb->Format, GL_STENCIL_BITS) !=
             _mesa_get_format_bits(drawRb->Format, GL_STENCIL_BITS)) {
            /* There is no need to check the stencil datatype here, because
             * there is only one: GL_UNSIGNED_INT.
             */
            _mesa_error(ctx, GL_INVALID_OPERATION,
                        "glBlitFramebuffer(stencil attachment format mismatch)");
            return;
         }

         read_z_bits = _mesa_get_format_bits(readRb->Format, GL_DEPTH_BITS);
         draw_z_bits = _mesa_get_format_bits(drawRb->Format, GL_DEPTH_BITS);

         /* If both buffers also have depth data, the depth formats must match
          * as well.  If one doesn't have depth, it's not blitted, so we should
          * ignore the depth format check.
          */
         if (read_z_bits > 0 && draw_z_bits > 0 &&
             (read_z_bits != draw_z_bits ||
              _mesa_get_format_datatype(readRb->Format) !=
              _mesa_get_format_datatype(drawRb->Format))) {

            _mesa_error(ctx, GL_INVALID_OPERATION, "glBlitFramebuffer"
                        "(stencil attachment depth format mismatch)");
            return;
         }
d2358 2
a2359 4
      struct gl_renderbuffer *readRb =
         readFb->Attachment[BUFFER_DEPTH].Renderbuffer;
      struct gl_renderbuffer *drawRb =
         drawFb->Attachment[BUFFER_DEPTH].Renderbuffer;
d2368 1
d2371 5
a2375 31
      else {
         int read_s_bit, draw_s_bit;

         if (_mesa_is_gles3(ctx) && (drawRb == readRb)) {
            _mesa_error(ctx, GL_INVALID_OPERATION,
                        "glBlitFramebuffer(source and destination depth "
                        "buffer cannot be the same)");
            return;
         }

         if ((_mesa_get_format_bits(readRb->Format, GL_DEPTH_BITS) !=
              _mesa_get_format_bits(drawRb->Format, GL_DEPTH_BITS)) ||
             (_mesa_get_format_datatype(readRb->Format) !=
              _mesa_get_format_datatype(drawRb->Format))) {
            _mesa_error(ctx, GL_INVALID_OPERATION,
                        "glBlitFramebuffer(depth attachment format mismatch)");
            return;
         }

         read_s_bit = _mesa_get_format_bits(readRb->Format, GL_STENCIL_BITS);
         draw_s_bit = _mesa_get_format_bits(drawRb->Format, GL_STENCIL_BITS);

         /* If both buffers also have stencil data, the stencil formats must
          * match as well.  If one doesn't have stencil, it's not blitted, so
          * we should ignore the stencil format check.
          */
         if (read_s_bit > 0 && draw_s_bit > 0 && read_s_bit != draw_s_bit) {
            _mesa_error(ctx, GL_INVALID_OPERATION, "glBlitFramebuffer"
                        "(depth attachment stencil bits mismatch)");
            return;
         }
d2379 7
d2387 5
a2391 8
   if (_mesa_is_gles3(ctx)) {
      /* Page 194 (page 206 of the PDF) in section 4.3.2 of the OpenGL ES
       * 3.0.1 spec says:
       *
       *     "If SAMPLE_BUFFERS for the draw framebuffer is greater than zero,
       *     an INVALID_OPERATION error is generated."
       */
      if (drawFb->Visual.samples > 0) {
d2393 1
a2393 1
                     "glBlitFramebuffer(destination samples must be 0)");
d2397 4
a2400 23
      /* Page 194 (page 206 of the PDF) in section 4.3.2 of the OpenGL ES
       * 3.0.1 spec says:
       *
       *     "If SAMPLE_BUFFERS for the read framebuffer is greater than zero,
       *     no copy is performed and an INVALID_OPERATION error is generated
       *     if the formats of the read and draw framebuffers are not
       *     identical or if the source and destination rectangles are not
       *     defined with the same (X0, Y0) and (X1, Y1) bounds."
       *
       * The format check was made above because desktop OpenGL has the same
       * requirement.
       */
      if (readFb->Visual.samples > 0
          && (srcX0 != dstX0 || srcY0 != dstY0
              || srcX1 != dstX1 || srcY1 != dstY1)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glBlitFramebuffer(bad src/dst multisample region)");
         return;
      }
   } else {
      if (readFb->Visual.samples > 0 &&
          drawFb->Visual.samples > 0 &&
          readFb->Visual.samples != drawFb->Visual.samples) {
d2402 1
a2402 1
                     "glBlitFramebufferEXT(mismatched samples)");
a2404 12

      /* extra checks for multisample copies... */
      if ((readFb->Visual.samples > 0 || drawFb->Visual.samples > 0) &&
          (filter == GL_NEAREST || filter == GL_LINEAR)) {
         /* src and dest region sizes must be the same */
         if (abs(srcX1 - srcX0) != abs(dstX1 - dstX0) ||
             abs(srcY1 - srcY0) != abs(dstY1 - dstY0)) {
            _mesa_error(ctx, GL_INVALID_OPERATION,
                        "glBlitFramebufferEXT(bad src/dst multisample region sizes)");
            return;
         }
      }
a2413 4
      const struct gl_renderbuffer *colorReadRb = readFb->_ColorReadBuffer;
      const struct gl_renderbuffer *colorDrawRb = NULL;
      GLuint i = 0;

d2435 10
a2444 18
         /* Print all active color render buffers */
         for (i = 0; i < ctx->DrawBuffer->_NumColorDrawBuffers; i++) {
            colorDrawRb = ctx->DrawBuffer->_ColorDrawBuffers[i];
            if (!colorDrawRb)
               continue;

            att = find_attachment(drawFb, colorDrawRb);
            printf("  Dst FBO %u  RB %u (%dx%d)  ",
		   drawFb->Name, colorDrawRb->Name,
		   colorDrawRb->Width, colorDrawRb->Height);
            if (att && att->Texture) {
               printf("Tex %u  tgt 0x%x  level %u  face %u",
		      att->Texture->Name,
		      att->Texture->Target,
		      att->TextureLevel,
		      att->CubeMapFace);
            }
            printf("\n");
d2446 1
d2450 1
a2450 3
   if (!mask ||
       (srcX1 - srcX0) == 0 || (srcY1 - srcY0) == 0 ||
       (dstX1 - dstX0) == 0 || (dstY1 - dstY0) == 0) {
d2460 1
d2462 4
a2465 5

static void
invalidate_framebuffer_storage(GLenum target, GLsizei numAttachments,
                               const GLenum *attachments, GLint x, GLint y,
                               GLsizei width, GLsizei height, const char *name)
a2466 2
   int i;
   struct gl_framebuffer *fb;
d2468 3
a2470 129

   fb = get_framebuffer_target(ctx, target);
   if (!fb) {
      _mesa_error(ctx, GL_INVALID_ENUM, "%s(target)", name);
      return;
   }

   if (numAttachments < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "%s(numAttachments < 0)", name);
      return;
   }

   /* The GL_ARB_invalidate_subdata spec says:
    *
    *     "If an attachment is specified that does not exist in the
    *     framebuffer bound to <target>, it is ignored."
    *
    * It also says:
    *
    *     "If <attachments> contains COLOR_ATTACHMENTm and m is greater than
    *     or equal to the value of MAX_COLOR_ATTACHMENTS, then the error
    *     INVALID_OPERATION is generated."
    *
    * No mention is made of GL_AUXi being out of range.  Therefore, we allow
    * any enum that can be allowed by the API (OpenGL ES 3.0 has a different
    * set of retrictions).
    */
   for (i = 0; i < numAttachments; i++) {
      if (_mesa_is_winsys_fbo(fb)) {
         switch (attachments[i]) {
         case GL_ACCUM:
         case GL_AUX0:
         case GL_AUX1:
         case GL_AUX2:
         case GL_AUX3:
            /* Accumulation buffers and auxilary buffers were removed in
             * OpenGL 3.1, and they never existed in OpenGL ES.
             */
            if (ctx->API != API_OPENGL_COMPAT)
               goto invalid_enum;
            break;
         case GL_COLOR:
         case GL_DEPTH:
         case GL_STENCIL:
            break;
         case GL_BACK_LEFT:
         case GL_BACK_RIGHT:
         case GL_FRONT_LEFT:
         case GL_FRONT_RIGHT:
            if (!_mesa_is_desktop_gl(ctx))
               goto invalid_enum;
            break;
         default:
            goto invalid_enum;
         }
      } else {
         switch (attachments[i]) {
         case GL_DEPTH_ATTACHMENT:
         case GL_STENCIL_ATTACHMENT:
            break;
         case GL_COLOR_ATTACHMENT0:
         case GL_COLOR_ATTACHMENT1:
         case GL_COLOR_ATTACHMENT2:
         case GL_COLOR_ATTACHMENT3:
         case GL_COLOR_ATTACHMENT4:
         case GL_COLOR_ATTACHMENT5:
         case GL_COLOR_ATTACHMENT6:
         case GL_COLOR_ATTACHMENT7:
         case GL_COLOR_ATTACHMENT8:
         case GL_COLOR_ATTACHMENT9:
         case GL_COLOR_ATTACHMENT10:
         case GL_COLOR_ATTACHMENT11:
         case GL_COLOR_ATTACHMENT12:
         case GL_COLOR_ATTACHMENT13:
         case GL_COLOR_ATTACHMENT14:
         case GL_COLOR_ATTACHMENT15: {
            unsigned k = attachments[i] - GL_COLOR_ATTACHMENT0;
            if (k >= ctx->Const.MaxColorAttachments) {
               _mesa_error(ctx, GL_INVALID_OPERATION,
                           "%s(attachment >= max. color attachments)", name);
               return;
            }
         }
         default:
            goto invalid_enum;
         }
      }
   }

   /* We don't actually do anything for this yet.  Just return after
    * validating the parameters and generating the required errors.
    */
   return;

invalid_enum:
   _mesa_error(ctx, GL_INVALID_ENUM, "%s(attachment)", name);
   return;
}

void GLAPIENTRY
_mesa_InvalidateSubFramebuffer(GLenum target, GLsizei numAttachments,
                               const GLenum *attachments, GLint x, GLint y,
                               GLsizei width, GLsizei height)
{
   invalidate_framebuffer_storage(target, numAttachments, attachments,
                                  x, y, width, height,
                                  "glInvalidateSubFramebuffer");
}

void GLAPIENTRY
_mesa_InvalidateFramebuffer(GLenum target, GLsizei numAttachments,
                            const GLenum *attachments)
{
   /* The GL_ARB_invalidate_subdata spec says:
    *
    *     "The command
    *
    *        void InvalidateFramebuffer(enum target,
    *                                   sizei numAttachments,
    *                                   const enum *attachments);
    *
    *     is equivalent to the command InvalidateSubFramebuffer with <x>, <y>,
    *     <width>, <height> equal to 0, 0, <MAX_VIEWPORT_DIMS[0]>,
    *     <MAX_VIEWPORT_DIMS[1]> respectively."
    */
   invalidate_framebuffer_storage(target, numAttachments, attachments,
                                  0, 0, MAX_VIEWPORT_WIDTH, MAX_VIEWPORT_HEIGHT,
                                  "glInvalidateFramebuffer");
d2474 2
a2475 2
_mesa_DiscardFramebufferEXT(GLenum target, GLsizei numAttachments,
                            const GLenum *attachments)
a2476 3
   struct gl_framebuffer *fb;
   GLint i;

d2478 3
a2480 43

   fb = get_framebuffer_target(ctx, target);
   if (!fb) {
      _mesa_error(ctx, GL_INVALID_ENUM,
         "glDiscardFramebufferEXT(target %s)",
         _mesa_lookup_enum_by_nr(target));
      return;
   }

   if (numAttachments < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glDiscardFramebufferEXT(numAttachments < 0)");
      return;
   }

   for (i = 0; i < numAttachments; i++) {
      switch (attachments[i]) {
      case GL_COLOR:
      case GL_DEPTH:
      case GL_STENCIL:
         if (_mesa_is_user_fbo(fb))
            goto invalid_enum;
         break;
      case GL_COLOR_ATTACHMENT0:
      case GL_DEPTH_ATTACHMENT:
      case GL_STENCIL_ATTACHMENT:
         if (_mesa_is_winsys_fbo(fb))
            goto invalid_enum;
         break;
      default:
         goto invalid_enum;
      }
   }

   if (ctx->Driver.DiscardFramebuffer)
      ctx->Driver.DiscardFramebuffer(ctx, target, numAttachments, attachments);

   return;

invalid_enum:
   _mesa_error(ctx, GL_INVALID_ENUM,
               "glDiscardFramebufferEXT(attachment %s)",
              _mesa_lookup_enum_by_nr(attachments[i]));
d2482 1
@


1.1.1.6
log
@Import Mesa 9.2.2
@
text
@a3583 1
            break;
@


1.1.1.7
log
@Import Mesa 10.2.3
@
text
@d53 4
d96 3
a98 3
   mtx_init(&DummyFramebuffer.Mutex, mtx_plain);
   mtx_init(&DummyRenderbuffer.Mutex, mtx_plain);
   mtx_init(&IncompleteFramebuffer.Mutex, mtx_plain);
d166 2
a167 1
   bool have_fb_blit = _mesa_is_gles3(ctx) || _mesa_is_desktop_gl(ctx);
d189 3
a191 3
static struct gl_renderbuffer_attachment *
get_attachment(struct gl_context *ctx, struct gl_framebuffer *fb,
               GLenum attachment)
d321 3
a323 3
static void
remove_attachment(struct gl_context *ctx,
                  struct gl_renderbuffer_attachment *att)
a413 1
   rb->Depth = texImage->Depth2;
d425 7
a431 7
static void
set_texture_attachment(struct gl_context *ctx,
                       struct gl_framebuffer *fb,
                       struct gl_renderbuffer_attachment *att,
                       struct gl_texture_object *texObj,
                       GLenum texTarget, GLuint level, GLuint zoffset,
                       GLboolean layered)
d444 1
a444 1
      remove_attachment(ctx, att);
d466 4
a469 4
static void
set_renderbuffer_attachment(struct gl_context *ctx,
                            struct gl_renderbuffer_attachment *att,
                            struct gl_renderbuffer *rb)
d472 1
a472 1
   remove_attachment(ctx, att);
d491 1
a491 1
   mtx_lock(&fb->Mutex);
d493 1
a493 1
   att = get_attachment(ctx, fb, attachment);
d496 1
a496 1
      set_renderbuffer_attachment(ctx, att, rb);
d499 1
a499 1
         att = get_attachment(ctx, fb, GL_STENCIL_ATTACHMENT_EXT);
d501 1
a501 1
         set_renderbuffer_attachment(ctx, att, rb);
d506 1
a506 7
      remove_attachment(ctx, att);
      if (attachment == GL_DEPTH_STENCIL_ATTACHMENT) {
         /* detach stencil (depth was detached above) */
         att = get_attachment(ctx, fb, GL_STENCIL_ATTACHMENT_EXT);
         assert(att);
         remove_attachment(ctx, att);
      }
d511 1
a511 1
   mtx_unlock(&fb->Mutex);
d541 1
a541 1
            case MESA_FORMAT_R9G9B9E5_FLOAT:
d639 1
a639 2
is_format_color_renderable(const struct gl_context *ctx, mesa_format format,
                           GLenum internalFormat)
d671 1
a671 2
   if (format == MESA_FORMAT_B10G10R10A2_UNORM &&
       internalFormat != GL_RGB10_A2) {
d783 3
a785 2
         else if (ctx->Extensions.ARB_depth_texture &&
                  baseFormat == GL_DEPTH_STENCIL) {
d796 3
a798 2
         if (ctx->Extensions.ARB_depth_texture &&
             baseFormat == GL_DEPTH_STENCIL) {
d832 2
a833 1
         else if (baseFormat == GL_DEPTH_STENCIL) {
d844 5
a848 2
         if (baseFormat == GL_STENCIL_INDEX ||
             baseFormat == GL_DEPTH_STENCIL) {
d885 2
a886 5
   /* Covers max_layer_count, is_layered, and layer_tex_target */
   bool layer_info_valid = false;
   GLuint max_layer_count = 0, att_layer_count;
   bool is_layered = false;
   GLenum layer_tex_target = 0;
d907 1
a907 2
      mesa_format attFormat;
      GLenum att_tex_target = GL_NONE;
a947 1
         att_tex_target = att->Texture->Target;
d956 1
a956 2
         if (!is_format_color_renderable(ctx, attFormat,
                                         texImg->InternalFormat) &&
d1060 12
a1071 18
      if (att->Layered) {
         if (att_tex_target == GL_TEXTURE_CUBE_MAP)
            att_layer_count = 6;
         else if (att_tex_target == GL_TEXTURE_1D_ARRAY)
            att_layer_count = att->Renderbuffer->Height;
         else
            att_layer_count = att->Renderbuffer->Depth;
      } else {
         att_layer_count = 0;
      }
      if (!layer_info_valid) {
         is_layered = att->Layered;
         max_layer_count = att_layer_count;
         layer_tex_target = att_tex_target;
         layer_info_valid = true;
      } else if (max_layer_count > 0 && layer_tex_target != att_tex_target) {
         fb->_Status = GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS;
         fbo_incomplete(ctx, "layered framebuffer has mismatched targets", i);
a1072 8
      } else if (is_layered != att->Layered) {
         fb->_Status = GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS;
         fbo_incomplete(ctx,
                        "framebuffer attachment layer mode is inconsistent",
                        i);
         return;
      } else if (att_layer_count > max_layer_count) {
         max_layer_count = att_layer_count;
d1076 1
a1076 7
   fb->MaxNumLayers = max_layer_count;

   if (numImages == 0) {
      fb->_Status = GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT_EXT;
      fbo_incomplete(ctx, "no attachments", -1);
      return;
   }
d1083 1
a1083 1
	       = get_attachment(ctx, fb, fb->ColorDrawBuffer[j]);
d1096 1
a1096 1
	    = get_attachment(ctx, fb, fb->ColorReadBuffer);
d1106 6
d1147 1
a1147 2
      struct gl_renderbuffer *rb =
         _mesa_lookup_renderbuffer(ctx, renderbuffer);
d1244 1
a1244 1
         remove_attachment(ctx, &fb->Attachment[i]);
d1289 2
a1290 2
             * subsection "Attaching Renderbuffer Images to a Framebuffer,"
             * of the OpenGL 3.1 spec says:
d1350 1
a1350 1
      mtx_lock(&ctx->Shared->Mutex);
d1352 1
a1352 1
      mtx_unlock(&ctx->Shared->Mutex);
d1385 2
a1386 2
      return (ctx->API == API_OPENGL_COMPAT &&
              ctx->Extensions.ARB_framebuffer_object) ? GL_ALPHA : 0;
d1392 2
a1393 2
      return (ctx->API == API_OPENGL_COMPAT &&
              ctx->Extensions.ARB_framebuffer_object) ? GL_LUMINANCE : 0;
d1401 2
a1402 2
      return (ctx->API == API_OPENGL_COMPAT &&
              ctx->Extensions.ARB_framebuffer_object) ? GL_LUMINANCE_ALPHA : 0;
d1408 2
a1409 2
      return (ctx->API == API_OPENGL_COMPAT &&
              ctx->Extensions.ARB_framebuffer_object) ? GL_INTENSITY : 0;
d1450 7
a1456 4
   case GL_DEPTH_STENCIL:
      return _mesa_is_desktop_gl(ctx) ? GL_DEPTH_STENCIL : 0;
   case GL_DEPTH24_STENCIL8:
      return GL_DEPTH_STENCIL;
d1459 1
a1459 2
         || (ctx->API == API_OPENGL_COMPAT &&
             ctx->Extensions.ARB_depth_buffer_float)
d1463 1
a1463 2
         || (ctx->API == API_OPENGL_COMPAT &&
             ctx->Extensions.ARB_depth_buffer_float)
a1505 16
   case GL_LUMINANCE_SNORM:
   case GL_LUMINANCE8_SNORM:
   case GL_LUMINANCE16_SNORM:
      return _mesa_is_desktop_gl(ctx) && ctx->Extensions.EXT_texture_snorm
         ? GL_LUMINANCE : 0;
   case GL_LUMINANCE_ALPHA_SNORM:
   case GL_LUMINANCE8_ALPHA8_SNORM:
   case GL_LUMINANCE16_ALPHA16_SNORM:
      return _mesa_is_desktop_gl(ctx) && ctx->Extensions.EXT_texture_snorm
         ? GL_LUMINANCE_ALPHA : 0;
   case GL_INTENSITY_SNORM:
   case GL_INTENSITY8_SNORM:
   case GL_INTENSITY16_SNORM:
      return _mesa_is_desktop_gl(ctx) && ctx->Extensions.EXT_texture_snorm
         ? GL_INTENSITY : 0;

d1550 4
d1683 1
a1683 1
 * Helper function used by _mesa_RenderbufferStorage() and
d1839 1
a1839 1
get_component_bits(GLenum pname, GLenum baseFormat, mesa_format format)
d1993 2
a1994 3
   /* Skip if we know NeedsFinishRenderTexture won't be set. */
   if (_mesa_is_winsys_fbo(fb) && !ctx->Driver.BindRenderbufferTexImage)
      return;
d2017 6
d2025 4
d2033 4
a2143 1

a2153 1

d2170 12
a2181 4
            if (fb == ctx->DrawBuffer) {
               /* bind default */
               ASSERT(fb->RefCount >= 2);
               _mesa_BindFramebuffer(GL_DRAW_FRAMEBUFFER, 0);
d2183 7
a2189 4
            if (fb == ctx->ReadBuffer) {
               /* bind default */
               ASSERT(fb->RefCount >= 2);
               _mesa_BindFramebuffer(GL_READ_FRAMEBUFFER, 0);
d2228 1
a2228 1
      mtx_lock(&ctx->Shared->Mutex);
d2230 1
a2230 1
      mtx_unlock(&ctx->Shared->Mutex);
d2235 1
d2255 2
a2256 6
      /* EGL_KHR_surfaceless_context allows the winsys FBO to be incomplete. */
      if (buffer != &IncompleteFramebuffer) {
         return GL_FRAMEBUFFER_COMPLETE_EXT;
      } else {
         return GL_FRAMEBUFFER_UNDEFINED;
      }
d2297 2
a2298 7
 *
 * \param textarget is the textarget that was passed to the
 * glFramebufferTexture...() function, or 0 if the corresponding function
 * doesn't have a textarget parameter.
 *
 * \param layered is true if this function was called from
 * glFramebufferTexture(), false otherwise.
d2301 1
a2301 1
framebuffer_texture(struct gl_context *ctx, const char *caller, GLenum target,
d2333 10
a2342 40
            if (layered) {
               /* We're being called by glFramebufferTexture() and textarget
                * is not used.
                */
               switch (texObj->Target) {
               case GL_TEXTURE_3D:
               case GL_TEXTURE_1D_ARRAY_EXT:
               case GL_TEXTURE_2D_ARRAY_EXT:
               case GL_TEXTURE_CUBE_MAP:
               case GL_TEXTURE_CUBE_MAP_ARRAY:
               case GL_TEXTURE_2D_MULTISAMPLE_ARRAY:
                  err = false;
                  break;
               case GL_TEXTURE_1D:
               case GL_TEXTURE_2D:
               case GL_TEXTURE_RECTANGLE:
               case GL_TEXTURE_2D_MULTISAMPLE:
                  /* These texture types are valid to pass to
                   * glFramebufferTexture(), but since they aren't layered, it
                   * is equivalent to calling glFramebufferTexture{1D,2D}().
                   */
                  err = false;
                  layered = false;
                  textarget = texObj->Target;
                  break;
               default:
                  err = true;
                  break;
               }
            } else {
               /* We're being called by glFramebufferTextureLayer() and
                * textarget is not used.  The only legal texture types for
                * that function are 3D and 1D/2D arrays textures.
                */
               err = (texObj->Target != GL_TEXTURE_3D) &&
                  (texObj->Target != GL_TEXTURE_1D_ARRAY_EXT) &&
                  (texObj->Target != GL_TEXTURE_2D_ARRAY_EXT) &&
                  (texObj->Target != GL_TEXTURE_CUBE_MAP_ARRAY) &&
                  (texObj->Target != GL_TEXTURE_2D_MULTISAMPLE_ARRAY);
            }
d2395 1
a2395 1
   att = get_attachment(ctx, fb, attachment);
d2404 1
a2404 1
   mtx_lock(&fb->Mutex);
d2429 1
a2429 1
	 set_texture_attachment(ctx, fb, att, texObj, textarget,
d2453 1
a2453 1
      remove_attachment(ctx, att);
d2456 1
a2456 1
	 remove_attachment(ctx, &fb->Attachment[BUFFER_STENCIL]);
d2462 1
a2462 1
   mtx_unlock(&fb->Mutex);
d2466 1
d2469 1
a2469 1
                           GLenum textarget, GLuint texture, GLint level)
d2502 1
a2502 1
                           GLenum textarget, GLuint texture, GLint level)
d2553 2
a2554 2
                           GLenum textarget, GLuint texture,
                           GLint level, GLint zoffset)
d2571 1
a2571 1
                              GLuint texture, GLint level, GLint layer)
d2586 1
a2586 1
   if (_mesa_has_geometry_shaders(ctx)) {
d2598 2
a2599 2
                              GLenum renderbufferTarget,
                              GLuint renderbuffer)
d2608 1
a2608 2
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "glFramebufferRenderbufferEXT(target)");
d2624 1
a2624 1
   att = get_attachment(ctx, fb, attachment);
d2641 2
a2642 1
	 _mesa_error(ctx, GL_INVALID_OPERATION,
d2665 1
d2680 1
a2680 1
                                          GLenum pname, GLint *params)
d2708 1
a2708 2
      if ((!_mesa_is_desktop_gl(ctx) ||
           !ctx->Extensions.ARB_framebuffer_object)
d2726 1
a2726 1
      att = get_attachment(ctx, buffer, attachment);
d2736 1
d2738 2
a2739 16
      if (pname == GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE) {
         /* This behavior is first specified in OpenGL 4.4 specification.
          *
          * From the OpenGL 4.4 spec page 275:
          *   "This query cannot be performed for a combined depth+stencil
          *    attachment, since it does not have a single format."
          */
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glGetFramebufferAttachmentParameteriv("
                     "GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE"
                     " is invalid for depth+stencil attachment)");
         return;
      }
      /* the depth and stencil attachments must point to the same buffer */
      depthAtt = get_attachment(ctx, buffer, GL_DEPTH_ATTACHMENT);
      stencilAtt = get_attachment(ctx, buffer, GL_STENCIL_ATTACHMENT);
d2819 1
a2819 2
      if ((!_mesa_is_desktop_gl(ctx) ||
           !ctx->Extensions.ARB_framebuffer_object)
d2829 1
a2829 2
            *params =
               _mesa_get_format_color_encoding(att->Renderbuffer->Format);
d2839 1
a2839 2
      if ((ctx->API != API_OPENGL_COMPAT ||
           !ctx->Extensions.ARB_framebuffer_object)
d2849 1
a2849 1
         mesa_format format = att->Renderbuffer->Format;
d2858 1
a2858 2
         if (_mesa_is_gles3(ctx) &&
             attachment == GL_DEPTH_STENCIL_ATTACHMENT) {
d2866 1
a2866 1
         if (format == MESA_FORMAT_S_UINT8) {
d2870 1
a2870 1
         else if (format == MESA_FORMAT_Z32_FLOAT_S8X24_UINT) {
d2890 1
a2890 2
      if ((!_mesa_is_desktop_gl(ctx) ||
           !ctx->Extensions.ARB_framebuffer_object)
a2918 12
   case GL_FRAMEBUFFER_ATTACHMENT_LAYERED:
      if (!_mesa_has_geometry_shaders(ctx)) {
         goto invalid_pname_enum;
      } else if (att->Type == GL_TEXTURE) {
         *params = att->Layered;
      } else if (att->Type == GL_NONE) {
         _mesa_error(ctx, err,
                     "glGetFramebufferAttachmentParameteriv(pname)");
      } else {
         goto invalid_pname_enum;
      }
      return;
d2932 561
a3601 1

a3611 1

d3629 1
a3629 2
                                  0, 0,
                                  MAX_VIEWPORT_WIDTH, MAX_VIEWPORT_HEIGHT,
a3631 1

@


1.1.1.8
log
@Import Mesa 10.4.3
@
text
@d2306 2
a2307 2
 * Common code called by glFramebufferTexture1D/2D/3D() and
 * glFramebufferTextureLayer().
d2329 1
a2329 1
                  "glFramebufferTexture%s(target=0x%x)", caller, target);
d2336 1
a2336 1
                  "glFramebufferTexture%s", caller);
d2400 1
a2400 1
                     "glFramebufferTexture%s(non existant texture)",
d2407 1
a2407 1
                     "glFramebufferTexture%s(texture target mismatch)",
d2416 1
a2416 1
                        "glFramebufferTexture%s(zoffset)", caller);
d2427 1
a2427 1
                        "glFramebufferTexture%s(layer)", caller);
d2436 1
a2436 1
                     "glFramebufferTexture%s(level)", caller);
d2444 1
a2444 1
                  "glFramebufferTexture%s(attachment)", caller);
d2534 1
a2534 1
                     "glFramebufferTexture1D(textarget=%s)",
d2585 1
a2585 1
                     "glFramebufferTexture2D(textarget=%s)",
d2605 1
a2605 1
                  "glFramebufferTexture3D(textarget)");
d2632 1
a2632 1
      framebuffer_texture(ctx, "", target, attachment, 0, texture,
d2654 1
a2654 1
                  "glFramebufferRenderbuffer(target)");
d2660 1
a2660 1
                  "glFramebufferRenderbuffer(renderbufferTarget)");
d2666 1
a2666 1
      _mesa_error(ctx, GL_INVALID_OPERATION, "glFramebufferRenderbuffer");
d2673 1
a2673 1
                  "glFramebufferRenderbuffer(invalid attachment %s)",
d2682 1
a2682 1
		     "glFramebufferRenderbuffer(non-existant"
d2688 1
a2688 1
		     "glFramebufferRenderbuffer(renderbuffer %u)",
d2704 1
a2704 1
                     "glFramebufferRenderbuffer(renderbuffer"
d2737 1
a2737 1
                  "glGetFramebufferAttachmentParameteriv(target)");
d2776 1
a2776 1
                  "glGetFramebufferAttachmentParameteriv(attachment)");
d2800 1
a2800 1
                     "glGetFramebufferAttachmentParameteriv(DEPTH/STENCIL"
d2835 1
a2835 1
                     "glGetFramebufferAttachmentParameteriv(pname)");
d2852 1
a2852 1
                     "glGetFramebufferAttachmentParameteriv(pname)");
d2863 1
a2863 1
                     "glGetFramebufferAttachmentParameteriv(pname)");
d2884 1
a2884 1
                     "glGetFramebufferAttachmentParameteriv(pname)");
d2907 1
a2907 1
                     "glGetFramebufferAttachmentParameteriv(pname)");
d2959 1
a2959 1
                     "glGetFramebufferAttachmentParameteriv(pname)");
@


1.1.1.9
log
@Import Mesa 10.2.9
@
text
@d2306 2
a2307 2
 * Common code called by glFramebufferTexture1D/2D/3DEXT() and
 * glFramebufferTextureLayerEXT().
d2329 1
a2329 1
                  "glFramebufferTexture%sEXT(target=0x%x)", caller, target);
d2336 1
a2336 1
                  "glFramebufferTexture%sEXT", caller);
d2400 1
a2400 1
                     "glFramebufferTexture%sEXT(non existant texture)",
d2407 1
a2407 1
                     "glFramebufferTexture%sEXT(texture target mismatch)",
d2416 1
a2416 1
                        "glFramebufferTexture%sEXT(zoffset)", caller);
d2427 1
a2427 1
                        "glFramebufferTexture%sEXT(layer)", caller);
d2436 1
a2436 1
                     "glFramebufferTexture%sEXT(level)", caller);
d2444 1
a2444 1
                  "glFramebufferTexture%sEXT(attachment)", caller);
d2534 1
a2534 1
                     "glFramebufferTexture1DEXT(textarget=%s)",
d2585 1
a2585 1
                     "glFramebufferTexture2DEXT(textarget=%s)",
d2605 1
a2605 1
                  "glFramebufferTexture3DEXT(textarget)");
d2632 1
a2632 1
      framebuffer_texture(ctx, "Layer", target, attachment, 0, texture,
d2654 1
a2654 1
                  "glFramebufferRenderbufferEXT(target)");
d2660 1
a2660 1
                  "glFramebufferRenderbufferEXT(renderbufferTarget)");
d2666 1
a2666 1
      _mesa_error(ctx, GL_INVALID_OPERATION, "glFramebufferRenderbufferEXT");
d2673 1
a2673 1
                  "glFramebufferRenderbufferEXT(invalid attachment %s)",
d2682 1
a2682 1
		     "glFramebufferRenderbufferEXT(non-existant"
d2688 1
a2688 1
		     "glFramebufferRenderbufferEXT(renderbuffer %u)",
d2704 1
a2704 1
                     "glFramebufferRenderbufferEXT(renderbuffer"
d2737 1
a2737 1
                  "glGetFramebufferAttachmentParameterivEXT(target)");
d2776 1
a2776 1
                  "glGetFramebufferAttachmentParameterivEXT(attachment)");
d2800 1
a2800 1
                     "glGetFramebufferAttachmentParameterivEXT(DEPTH/STENCIL"
d2835 1
a2835 1
                     "glGetFramebufferAttachmentParameterivEXT(pname)");
d2852 1
a2852 1
                     "glGetFramebufferAttachmentParameterivEXT(pname)");
d2863 1
a2863 1
                     "glGetFramebufferAttachmentParameterivEXT(pname)");
d2884 1
a2884 1
                     "glGetFramebufferAttachmentParameterivEXT(pname)");
d2907 1
a2907 1
                     "glGetFramebufferAttachmentParameterivEXT(pname)");
d2959 1
a2959 1
                     "glGetFramebufferAttachmentParameterivEXT(pname)");
@


