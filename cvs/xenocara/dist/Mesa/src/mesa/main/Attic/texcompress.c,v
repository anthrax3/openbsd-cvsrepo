head	1.10;
access;
symbols
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	v10_2_9:1.1.1.7
	v10_4_3:1.1.1.6
	v10_2_7:1.1.1.5
	OPENBSD_5_6:1.7.0.2
	OPENBSD_5_6_BASE:1.7
	v10_2_3:1.1.1.5
	OPENBSD_5_5:1.6.0.2
	OPENBSD_5_5_BASE:1.6
	v9_2_5:1.1.1.4
	v9_2_3:1.1.1.4
	v9_2_2:1.1.1.4
	v9_2_1:1.1.1.4
	v9_2_0:1.1.1.4
	OPENBSD_5_4:1.5.0.4
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.2
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.4.0.4
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	v7_10_3:1.1.1.3
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.1.2.0.8
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.6
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.4
	v7_0_1:1.1.1.2
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2015.12.23.05.17.53;	author jsg;	state dead;
branches;
next	1.9;
commitid	TnlogFl9nOv2eaRf;

1.9
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.8;
commitid	4ry2gvZGMXkCUD2n;

1.8
date	2015.01.25.14.41.22;	author jsg;	state Exp;
branches;
next	1.7;
commitid	mcxB0JvoI9gTDYXU;

1.7
date	2014.07.09.21.09.00;	author jsg;	state Exp;
branches;
next	1.6;
commitid	WPD6rgPryPkvXOr9;

1.6
date	2013.09.05.14.06.29;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2012.08.17.13.58.19;	author mpi;	state Exp;
branches;
next	1.4;

1.4
date	2011.10.23.13.37.42;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.05.22.20.06.31;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.05.17.20.26.41;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.50.18;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.50.18;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.56.39;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.10.23.13.29.46;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.09.05.13.16.50;	author jsg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2014.07.09.20.35.05;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.6
date	2015.01.25.14.12.54;	author jsg;	state Exp;
branches;
next	1.1.1.7;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.7
date	2015.02.20.22.50.01;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.10
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
 * Copyright (c) 2008 VMware, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */


/**
 * \file texcompress.c
 * Helper functions for texture compression.
 */


#include "glheader.h"
#include "imports.h"
#include "colormac.h"
#include "context.h"
#include "formats.h"
#include "mtypes.h"
#include "context.h"
#include "texcompress.h"
#include "texcompress_fxt1.h"
#include "texcompress_rgtc.h"
#include "texcompress_s3tc.h"
#include "texcompress_etc.h"


/**
 * Get the GL base format of a specified GL compressed texture format
 *
 * From page 232 of the OpenGL 3.3 (Compatiblity Profile) spec:
 *
 *     "Compressed Internal Format      Base Internal Format    Type
 *     ---------------------------     --------------------    ---------
 *     COMPRESSED_ALPHA                ALPHA                   Generic
 *     COMPRESSED_LUMINANCE            LUMINANCE               Generic
 *     COMPRESSED_LUMINANCE_ALPHA      LUMINANCE_ALPHA         Generic
 *     COMPRESSED_INTENSITY            INTENSITY               Generic
 *     COMPRESSED_RED                  RED                     Generic
 *     COMPRESSED_RG                   RG                      Generic
 *     COMPRESSED_RGB                  RGB                     Generic
 *     COMPRESSED_RGBA                 RGBA                    Generic
 *     COMPRESSED_SRGB                 RGB                     Generic
 *     COMPRESSED_SRGB_ALPHA           RGBA                    Generic
 *     COMPRESSED_SLUMINANCE           LUMINANCE               Generic
 *     COMPRESSED_SLUMINANCE_ALPHA     LUMINANCE_ALPHA         Generic
 *     COMPRESSED_RED_RGTC1            RED                     Specific
 *     COMPRESSED_SIGNED_RED_RGTC1     RED                     Specific
 *     COMPRESSED_RG_RGTC2             RG                      Specific
 *     COMPRESSED_SIGNED_RG_RGTC2      RG                      Specific"
 *
 * \return
 * The base format of \c format if \c format is a compressed format (either
 * generic or specific.  Otherwise 0 is returned.
 */
GLenum
_mesa_gl_compressed_format_base_format(GLenum format)
{
   switch (format) {
   case GL_COMPRESSED_RED:
   case GL_COMPRESSED_R11_EAC:
   case GL_COMPRESSED_RED_RGTC1:
   case GL_COMPRESSED_SIGNED_R11_EAC:
   case GL_COMPRESSED_SIGNED_RED_RGTC1:
      return GL_RED;

   case GL_COMPRESSED_RG:
   case GL_COMPRESSED_RG11_EAC:
   case GL_COMPRESSED_RG_RGTC2:
   case GL_COMPRESSED_SIGNED_RG11_EAC:
   case GL_COMPRESSED_SIGNED_RG_RGTC2:
      return GL_RG;

   case GL_COMPRESSED_RGB:
   case GL_COMPRESSED_SRGB:
   case GL_COMPRESSED_RGB_S3TC_DXT1_EXT:
   case GL_COMPRESSED_RGB_FXT1_3DFX:
   case GL_COMPRESSED_SRGB_S3TC_DXT1_EXT:
   case GL_ETC1_RGB8_OES:
   case GL_COMPRESSED_RGB8_ETC2:
   case GL_COMPRESSED_SRGB8_ETC2:
      return GL_RGB;

   case GL_COMPRESSED_RGBA:
   case GL_COMPRESSED_SRGB_ALPHA:
   case GL_COMPRESSED_RGBA_BPTC_UNORM_ARB:
   case GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM_ARB:
   case GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT_ARB:
   case GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_ARB:
   case GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:
   case GL_COMPRESSED_RGBA_S3TC_DXT3_EXT:
   case GL_COMPRESSED_RGBA_S3TC_DXT5_EXT:
   case GL_COMPRESSED_RGBA_FXT1_3DFX:
   case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:
   case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:
   case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:
   case GL_COMPRESSED_RGBA8_ETC2_EAC:
   case GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:
   case GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:
   case GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:
      return GL_RGBA;

   case GL_COMPRESSED_ALPHA:
      return GL_ALPHA;

   case GL_COMPRESSED_LUMINANCE:
   case GL_COMPRESSED_SLUMINANCE:
   case GL_COMPRESSED_LUMINANCE_LATC1_EXT:
   case GL_COMPRESSED_SIGNED_LUMINANCE_LATC1_EXT:
      return GL_LUMINANCE;

   case GL_COMPRESSED_LUMINANCE_ALPHA:
   case GL_COMPRESSED_SLUMINANCE_ALPHA:
   case GL_COMPRESSED_LUMINANCE_ALPHA_LATC2_EXT:
   case GL_COMPRESSED_SIGNED_LUMINANCE_ALPHA_LATC2_EXT:
   case GL_COMPRESSED_LUMINANCE_ALPHA_3DC_ATI:
      return GL_LUMINANCE_ALPHA;

   case GL_COMPRESSED_INTENSITY:
      return GL_INTENSITY;

   default:
      return 0;
   }
}

/**
 * Return list of (and count of) all specific texture compression
 * formats that are supported.
 *
 * Some formats are \b not returned by this function.  The
 * \c GL_COMPRESSED_TEXTURE_FORMATS query only returns formats that are
 * "suitable for general-purpose usage."  All texture compression extensions
 * have taken this to mean either linear RGB or linear RGBA.
 *
 * The GL_ARB_texture_compress_rgtc spec says:
 *
 *    "19) Should the GL_NUM_COMPRESSED_TEXTURE_FORMATS and
 *        GL_COMPRESSED_TEXTURE_FORMATS queries return the RGTC formats?
 *
 *        RESOLVED:  No.
 *
 *        The OpenGL 2.1 specification says "The only values returned
 *        by this query [GL_COMPRESSED_TEXTURE_FORMATS"] are those
 *        corresponding to formats suitable for general-purpose usage.
 *        The renderer will not enumerate formats with restrictions that
 *        need to be specifically understood prior to use."
 *
 *        Compressed textures with just red or red-green components are
 *        not general-purpose so should not be returned by these queries
 *        because they have restrictions.
 *
 *        Applications that seek to use the RGTC formats should do so
 *        by looking for this extension's name in the string returned by
 *        glGetString(GL_EXTENSIONS) rather than
 *        what GL_NUM_COMPRESSED_TEXTURE_FORMATS and
 *        GL_COMPRESSED_TEXTURE_FORMATS return."
 *
 * There is nearly identical wording in the GL_EXT_texture_compression_rgtc
 * spec.
 *
 * The GL_EXT_texture_rRGB spec says:
 *
 *    "22) Should the new COMPRESSED_SRGB_* formats be listed in an
 *        implementation's GL_COMPRESSED_TEXTURE_FORMATS list?
 *
 *        RESOLVED:  No.  Section 3.8.1 says formats listed by
 *        GL_COMPRESSED_TEXTURE_FORMATS are "suitable for general-purpose
 *        usage."  The non-linear distribution of red, green, and
 *        blue for these sRGB compressed formats makes them not really
 *        general-purpose."
 *
 * The GL_EXT_texture_compression_latc spec says:
 *
 *    "16) Should the GL_NUM_COMPRESSED_TEXTURE_FORMATS and
 *        GL_COMPRESSED_TEXTURE_FORMATS queries return the LATC formats?
 *
 *        RESOLVED:  No.
 *
 *        The OpenGL 2.1 specification says "The only values returned
 *        by this query [GL_COMPRESSED_TEXTURE_FORMATS"] are those
 *        corresponding to formats suitable for general-purpose usage.
 *        The renderer will not enumerate formats with restrictions that
 *        need to be specifically understood prior to use."
 *
 *        Historically, OpenGL implementation have advertised the RGB and
 *        RGBA versions of the S3TC extensions compressed format tokens
 *        through this mechanism.
 *
 *        The specification is not sufficiently clear about what "suitable
 *        for general-purpose usage" means.  Historically that seems to mean
 *        unsigned RGB or unsigned RGBA.  The DXT1 format supporting alpha
 *        (GL_COMPRESSED_RGBA_S3TC_DXT1_EXT) is not exposed in the list (at
 *        least for NVIDIA drivers) because the alpha is always 1.0 expect
 *        when it is 0.0 when RGB is required to be black.  NVIDIA's even
 *        limits itself to true linear RGB or RGBA formats, specifically
 *        not including EXT_texture_sRGB's sRGB S3TC compressed formats.
 *
 *        Adding luminance and luminance-alpha texture formats (and
 *        certainly signed versions of luminance and luminance-alpha
 *        formats!) invites potential comptaibility problems with old
 *        applications using this mechanism since old applications are
 *        unlikely to expect non-RGB or non-RGBA formats to be advertised
 *        through this mechanism.  However no specific misinteractions
 *        with old applications is known.
 *
 *        Applications that seek to use the LATC formats should do so
 *        by looking for this extension's name in the string returned by
 *        glGetString(GL_EXTENSIONS) rather than
 *        what GL_NUM_COMPRESSED_TEXTURE_FORMATS and
 *        GL_COMPRESSED_TEXTURE_FORMATS return."
 *
 * There is no formal spec for GL_ATI_texture_compression_3dc.  Since the
 * formats added by this extension are luminance-alpha formats, it is
 * reasonable to expect them to follow the same rules as
 * GL_EXT_texture_compression_latc.  At the very least, Catalyst 11.6 does not
 * expose the 3dc formats through this mechanism.
 *
 * \param ctx  the GL context
 * \param formats  the resulting format list (may be NULL).
 *
 * \return number of formats.
 */
GLuint
_mesa_get_compressed_formats(struct gl_context *ctx, GLint *formats)
{
   GLuint n = 0;
   if (ctx->Extensions.TDFX_texture_compression_FXT1) {
      if (formats) {
         formats[n++] = GL_COMPRESSED_RGB_FXT1_3DFX;
         formats[n++] = GL_COMPRESSED_RGBA_FXT1_3DFX;
      }
      else {
         n += 2;
      }
   }

   if (ctx->Extensions.EXT_texture_compression_s3tc) {
      if (formats) {
         formats[n++] = GL_COMPRESSED_RGB_S3TC_DXT1_EXT;
         formats[n++] = GL_COMPRESSED_RGBA_S3TC_DXT3_EXT;
         formats[n++] = GL_COMPRESSED_RGBA_S3TC_DXT5_EXT;
      }
      else {
         n += 3;
      }

      /* The ES and desktop GL specs diverge here.
       *
       * In desktop OpenGL, the driver can perform online compression of
       * uncompressed texture data.  GL_NUM_COMPRESSED_TEXTURE_FORMATS and
       * GL_COMPRESSED_TEXTURE_FORMATS give the application a list of
       * formats that it could ask the driver to compress with some
       * expectation of quality.  The GL_ARB_texture_compression spec
       * calls this "suitable for general-purpose usage."  As noted
       * above, this means GL_COMPRESSED_RGBA_S3TC_DXT1_EXT is not
       * included in the list.
       *
       * In OpenGL ES, the driver never performs compression.
       * GL_NUM_COMPRESSED_TEXTURE_FORMATS and
       * GL_COMPRESSED_TEXTURE_FORMATS give the application a list of
       * formats that the driver can receive from the application.  It
       * is the *complete* list of formats.  The
       * GL_EXT_texture_compression_s3tc spec says:
       *
       *     "New State for OpenGL ES 2.0.25 and 3.0.2 Specifications
       *
       *         The queries for NUM_COMPRESSED_TEXTURE_FORMATS and
       *         COMPRESSED_TEXTURE_FORMATS include
       *         COMPRESSED_RGB_S3TC_DXT1_EXT,
       *         COMPRESSED_RGBA_S3TC_DXT1_EXT,
       *         COMPRESSED_RGBA_S3TC_DXT3_EXT, and
       *         COMPRESSED_RGBA_S3TC_DXT5_EXT."
       *
       * Note that the addition is only to the OpenGL ES specification!
       */
      if (_mesa_is_gles(ctx)) {
         if (formats) {
            formats[n++] = GL_COMPRESSED_RGBA_S3TC_DXT1_EXT;
         } else {
            n += 1;
         }
      }
   }

   /* The GL_OES_compressed_ETC1_RGB8_texture spec says:
    *
    *     "New State
    *
    *         The queries for NUM_COMPRESSED_TEXTURE_FORMATS and
    *         COMPRESSED_TEXTURE_FORMATS include ETC1_RGB8_OES."
    */
   if (_mesa_is_gles(ctx)
       && ctx->Extensions.OES_compressed_ETC1_RGB8_texture) {
      if (formats) {
         formats[n++] = GL_ETC1_RGB8_OES;
      }
      else {
         n += 1;
      }
   }

   if (ctx->API == API_OPENGLES) {
      if (formats) {
	 formats[n++] = GL_PALETTE4_RGB8_OES;
	 formats[n++] = GL_PALETTE4_RGBA8_OES;
	 formats[n++] = GL_PALETTE4_R5_G6_B5_OES;
	 formats[n++] = GL_PALETTE4_RGBA4_OES;
	 formats[n++] = GL_PALETTE4_RGB5_A1_OES;
	 formats[n++] = GL_PALETTE8_RGB8_OES;
	 formats[n++] = GL_PALETTE8_RGBA8_OES;
	 formats[n++] = GL_PALETTE8_R5_G6_B5_OES;
	 formats[n++] = GL_PALETTE8_RGBA4_OES;
	 formats[n++] = GL_PALETTE8_RGB5_A1_OES;
      }
      else {
	 n += 10;
      }
   }

   if (_mesa_is_gles3(ctx)) {
      if (formats) {
         formats[n++] = GL_COMPRESSED_RGB8_ETC2;
         formats[n++] = GL_COMPRESSED_SRGB8_ETC2;
         formats[n++] = GL_COMPRESSED_RGBA8_ETC2_EAC;
         formats[n++] = GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;
         formats[n++] = GL_COMPRESSED_R11_EAC;
         formats[n++] = GL_COMPRESSED_RG11_EAC;
         formats[n++] = GL_COMPRESSED_SIGNED_R11_EAC;
         formats[n++] = GL_COMPRESSED_SIGNED_RG11_EAC;
         formats[n++] = GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2;
         formats[n++] = GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2;
      }
      else {
         n += 10;
      }
   }
   return n;
}


/**
 * Convert a compressed MESA_FORMAT_x to a GLenum.
 */
mesa_format
_mesa_glenum_to_compressed_format(GLenum format)
{
   switch (format) {
   case GL_COMPRESSED_RGB_FXT1_3DFX:
      return MESA_FORMAT_RGB_FXT1;
   case GL_COMPRESSED_RGBA_FXT1_3DFX:
      return MESA_FORMAT_RGBA_FXT1;

   case GL_COMPRESSED_RGB_S3TC_DXT1_EXT:
   case GL_RGB_S3TC:
      return MESA_FORMAT_RGB_DXT1;
   case GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:
   case GL_RGB4_S3TC:
      return MESA_FORMAT_RGBA_DXT1;
   case GL_COMPRESSED_RGBA_S3TC_DXT3_EXT:
   case GL_RGBA_S3TC:
      return MESA_FORMAT_RGBA_DXT3;
   case GL_COMPRESSED_RGBA_S3TC_DXT5_EXT:
   case GL_RGBA4_S3TC:
      return MESA_FORMAT_RGBA_DXT5;

   case GL_COMPRESSED_SRGB_S3TC_DXT1_EXT:
      return MESA_FORMAT_SRGB_DXT1;
   case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:
      return MESA_FORMAT_SRGBA_DXT1;
   case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:
      return MESA_FORMAT_SRGBA_DXT3;
   case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:
      return MESA_FORMAT_SRGBA_DXT5;

   case GL_COMPRESSED_RED_RGTC1:
      return MESA_FORMAT_R_RGTC1_UNORM;
   case GL_COMPRESSED_SIGNED_RED_RGTC1:
      return MESA_FORMAT_R_RGTC1_SNORM;
   case GL_COMPRESSED_RG_RGTC2:
      return MESA_FORMAT_RG_RGTC2_UNORM;
   case GL_COMPRESSED_SIGNED_RG_RGTC2:
      return MESA_FORMAT_RG_RGTC2_SNORM;

   case GL_COMPRESSED_LUMINANCE_LATC1_EXT:
      return MESA_FORMAT_L_LATC1_UNORM;
   case GL_COMPRESSED_SIGNED_LUMINANCE_LATC1_EXT:
      return MESA_FORMAT_L_LATC1_SNORM;
   case GL_COMPRESSED_LUMINANCE_ALPHA_LATC2_EXT:
   case GL_COMPRESSED_LUMINANCE_ALPHA_3DC_ATI:
      return MESA_FORMAT_LA_LATC2_UNORM;
   case GL_COMPRESSED_SIGNED_LUMINANCE_ALPHA_LATC2_EXT:
      return MESA_FORMAT_LA_LATC2_SNORM;

   case GL_ETC1_RGB8_OES:
      return MESA_FORMAT_ETC1_RGB8;
   case GL_COMPRESSED_RGB8_ETC2:
      return MESA_FORMAT_ETC2_RGB8;
   case GL_COMPRESSED_SRGB8_ETC2:
      return MESA_FORMAT_ETC2_SRGB8;
   case GL_COMPRESSED_RGBA8_ETC2_EAC:
      return MESA_FORMAT_ETC2_RGBA8_EAC;
   case GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:
      return MESA_FORMAT_ETC2_SRGB8_ALPHA8_EAC;
   case GL_COMPRESSED_R11_EAC:
      return MESA_FORMAT_ETC2_R11_EAC;
   case GL_COMPRESSED_RG11_EAC:
      return MESA_FORMAT_ETC2_RG11_EAC;
   case GL_COMPRESSED_SIGNED_R11_EAC:
      return MESA_FORMAT_ETC2_SIGNED_R11_EAC;
   case GL_COMPRESSED_SIGNED_RG11_EAC:
      return MESA_FORMAT_ETC2_SIGNED_RG11_EAC;
   case GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:
      return MESA_FORMAT_ETC2_RGB8_PUNCHTHROUGH_ALPHA1;
   case GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:
      return MESA_FORMAT_ETC2_SRGB8_PUNCHTHROUGH_ALPHA1;

   default:
      return MESA_FORMAT_NONE;
   }
}


/**
 * Given a compressed MESA_FORMAT_x value, return the corresponding
 * GLenum for that format.
 * This is needed for glGetTexLevelParameter(GL_TEXTURE_INTERNAL_FORMAT)
 * which must return the specific texture format used when the user might
 * have originally specified a generic compressed format in their
 * glTexImage2D() call.
 * For non-compressed textures, we always return the user-specified
 * internal format unchanged.
 */
GLenum
_mesa_compressed_format_to_glenum(struct gl_context *ctx, mesa_format mesaFormat)
{
   switch (mesaFormat) {
   case MESA_FORMAT_RGB_FXT1:
      return GL_COMPRESSED_RGB_FXT1_3DFX;
   case MESA_FORMAT_RGBA_FXT1:
      return GL_COMPRESSED_RGBA_FXT1_3DFX;
   case MESA_FORMAT_RGB_DXT1:
      return GL_COMPRESSED_RGB_S3TC_DXT1_EXT;
   case MESA_FORMAT_RGBA_DXT1:
      return GL_COMPRESSED_RGBA_S3TC_DXT1_EXT;
   case MESA_FORMAT_RGBA_DXT3:
      return GL_COMPRESSED_RGBA_S3TC_DXT3_EXT;
   case MESA_FORMAT_RGBA_DXT5:
      return GL_COMPRESSED_RGBA_S3TC_DXT5_EXT;
   case MESA_FORMAT_SRGB_DXT1:
      return GL_COMPRESSED_SRGB_S3TC_DXT1_EXT;
   case MESA_FORMAT_SRGBA_DXT1:
      return GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
   case MESA_FORMAT_SRGBA_DXT3:
      return GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
   case MESA_FORMAT_SRGBA_DXT5:
      return GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
   case MESA_FORMAT_R_RGTC1_UNORM:
      return GL_COMPRESSED_RED_RGTC1;
   case MESA_FORMAT_R_RGTC1_SNORM:
      return GL_COMPRESSED_SIGNED_RED_RGTC1;
   case MESA_FORMAT_RG_RGTC2_UNORM:
      return GL_COMPRESSED_RG_RGTC2;
   case MESA_FORMAT_RG_RGTC2_SNORM:
      return GL_COMPRESSED_SIGNED_RG_RGTC2;

   case MESA_FORMAT_L_LATC1_UNORM:
      return GL_COMPRESSED_LUMINANCE_LATC1_EXT;
   case MESA_FORMAT_L_LATC1_SNORM:
      return GL_COMPRESSED_SIGNED_LUMINANCE_LATC1_EXT;
   case MESA_FORMAT_LA_LATC2_UNORM:
      return GL_COMPRESSED_LUMINANCE_ALPHA_LATC2_EXT;
   case MESA_FORMAT_LA_LATC2_SNORM:
      return GL_COMPRESSED_SIGNED_LUMINANCE_ALPHA_LATC2_EXT;

   case MESA_FORMAT_ETC1_RGB8:
      return GL_ETC1_RGB8_OES;
   case MESA_FORMAT_ETC2_RGB8:
      return GL_COMPRESSED_RGB8_ETC2;
   case MESA_FORMAT_ETC2_SRGB8:
      return GL_COMPRESSED_SRGB8_ETC2;
   case MESA_FORMAT_ETC2_RGBA8_EAC:
      return GL_COMPRESSED_RGBA8_ETC2_EAC;
   case MESA_FORMAT_ETC2_SRGB8_ALPHA8_EAC:
      return GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;
   case MESA_FORMAT_ETC2_R11_EAC:
      return GL_COMPRESSED_R11_EAC;
   case MESA_FORMAT_ETC2_RG11_EAC:
      return GL_COMPRESSED_RG11_EAC;
   case MESA_FORMAT_ETC2_SIGNED_R11_EAC:
      return GL_COMPRESSED_SIGNED_R11_EAC;
   case MESA_FORMAT_ETC2_SIGNED_RG11_EAC:
      return GL_COMPRESSED_SIGNED_RG11_EAC;
   case MESA_FORMAT_ETC2_RGB8_PUNCHTHROUGH_ALPHA1:
      return GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2;
   case MESA_FORMAT_ETC2_SRGB8_PUNCHTHROUGH_ALPHA1:
      return GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2;

   default:
      _mesa_problem(ctx, "Unexpected mesa texture format in"
                    " _mesa_compressed_format_to_glenum()");
      return 0;
   }
}


/*
 * Return the address of the pixel at (col, row, img) in a
 * compressed texture image.
 * \param col, row, img - image position (3D), should be a multiple of the
 *                        format's block size.
 * \param format - compressed image format
 * \param width - image width (stride) in pixels
 * \param image - the image address
 * \return address of pixel at (row, col, img)
 */
GLubyte *
_mesa_compressed_image_address(GLint col, GLint row, GLint img,
                               mesa_format mesaFormat,
                               GLsizei width, const GLubyte *image)
{
   /* XXX only 2D images implemented, not 3D */
   const GLuint blockSize = _mesa_get_format_bytes(mesaFormat);
   GLuint bw, bh;
   GLint offset;

   _mesa_get_format_block_size(mesaFormat, &bw, &bh);

   ASSERT(col % bw == 0);
   ASSERT(row % bh == 0);

   offset = ((width + bw - 1) / bw) * (row / bh) + col / bw;
   offset *= blockSize;

   return (GLubyte *) image + offset;
}


/**
 * Return a texel-fetch function for the given format, or NULL if
 * invalid format.
 */
compressed_fetch_func
_mesa_get_compressed_fetch_func(mesa_format format)
{
   switch (format) {
   case MESA_FORMAT_RGB_DXT1:
   case MESA_FORMAT_RGBA_DXT1:
   case MESA_FORMAT_RGBA_DXT3:
   case MESA_FORMAT_RGBA_DXT5:
   case MESA_FORMAT_SRGB_DXT1:
   case MESA_FORMAT_SRGBA_DXT1:
   case MESA_FORMAT_SRGBA_DXT3:
   case MESA_FORMAT_SRGBA_DXT5:
      return _mesa_get_dxt_fetch_func(format);
   case MESA_FORMAT_RGB_FXT1:
   case MESA_FORMAT_RGBA_FXT1:
      return _mesa_get_fxt_fetch_func(format);
   case MESA_FORMAT_R_RGTC1_UNORM:
   case MESA_FORMAT_L_LATC1_UNORM:
   case MESA_FORMAT_R_RGTC1_SNORM:
   case MESA_FORMAT_L_LATC1_SNORM:
   case MESA_FORMAT_RG_RGTC2_UNORM:
   case MESA_FORMAT_LA_LATC2_UNORM:
   case MESA_FORMAT_RG_RGTC2_SNORM:
   case MESA_FORMAT_LA_LATC2_SNORM:
      return _mesa_get_compressed_rgtc_func(format);
   case MESA_FORMAT_ETC1_RGB8:
      return _mesa_get_etc_fetch_func(format);
   default:
      return NULL;
   }
}


/**
 * Decompress a compressed texture image, returning a GL_RGBA/GL_FLOAT image.
 * \param srcRowStride  stride in bytes between rows of blocks in the
 *                      compressed source image.
 */
void
_mesa_decompress_image(mesa_format format, GLuint width, GLuint height,
                       const GLubyte *src, GLint srcRowStride,
                       GLfloat *dest)
{
   compressed_fetch_func fetch;
   GLuint i, j;
   GLuint bytes, bw, bh;
   GLint stride;

   bytes = _mesa_get_format_bytes(format);
   _mesa_get_format_block_size(format, &bw, &bh);

   fetch = _mesa_get_compressed_fetch_func(format);
   if (!fetch) {
      _mesa_problem(NULL, "Unexpected format in _mesa_decompress_image()");
      return;
   }
 
   stride = srcRowStride * bh / bytes;

   for (j = 0; j < height; j++) {
      for (i = 0; i < width; i++) {
         fetch(src, stride, i, j, dest);
         dest += 4;
      }
   }
}
@


1.9
log
@Merge Mesa 10.2.9
@
text
@@


1.8
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a44 1
#include "texcompress_bptc.h"
a94 2
   case GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT_ARB:
   case GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_ARB:
d107 2
a237 6
 * The spec for GL_ARB_texture_compression_bptc doesn't mention whether it
 * should be included in GL_COMPRESSED_TEXTURE_FORMATS. However as it takes a
 * very long time to compress the textures in this format it's probably not
 * very useful as a general format where the GL will have to compress it on
 * the fly.
 *
a436 9
   case GL_COMPRESSED_RGBA_BPTC_UNORM:
      return MESA_FORMAT_BPTC_RGBA_UNORM;
   case GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:
      return MESA_FORMAT_BPTC_SRGB_ALPHA_UNORM;
   case GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:
      return MESA_FORMAT_BPTC_RGB_SIGNED_FLOAT;
   case GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:
      return MESA_FORMAT_BPTC_RGB_UNSIGNED_FLOAT;

a517 9
   case MESA_FORMAT_BPTC_RGBA_UNORM:
      return GL_COMPRESSED_RGBA_BPTC_UNORM;
   case MESA_FORMAT_BPTC_SRGB_ALPHA_UNORM:
      return GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM;
   case MESA_FORMAT_BPTC_RGB_SIGNED_FLOAT:
      return GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT;
   case MESA_FORMAT_BPTC_RGB_UNSIGNED_FLOAT:
      return GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT;

a588 5
   case MESA_FORMAT_BPTC_RGBA_UNORM:
   case MESA_FORMAT_BPTC_SRGB_ALPHA_UNORM:
   case MESA_FORMAT_BPTC_RGB_SIGNED_FLOAT:
   case MESA_FORMAT_BPTC_RGB_UNSIGNED_FLOAT:
      return _mesa_get_bptc_fetch_func(format);
@


1.7
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d45 1
d96 2
a109 2
   case GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT_ARB:
   case GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_ARB:
d239 6
d444 9
d534 9
d614 5
@


1.6
log
@Merge Mesa 9.2.0
@
text
@d266 37
d364 1
a364 1
gl_format
d396 1
a396 1
      return MESA_FORMAT_RED_RGTC1;
d398 1
a398 1
      return MESA_FORMAT_SIGNED_RED_RGTC1;
d400 1
a400 1
      return MESA_FORMAT_RG_RGTC2;
d402 1
a402 1
      return MESA_FORMAT_SIGNED_RG_RGTC2;
d405 1
a405 1
      return MESA_FORMAT_L_LATC1;
d407 1
a407 1
      return MESA_FORMAT_SIGNED_L_LATC1;
d410 1
a410 1
      return MESA_FORMAT_LA_LATC2;
d412 1
a412 1
      return MESA_FORMAT_SIGNED_LA_LATC2;
d454 1
a454 1
_mesa_compressed_format_to_glenum(struct gl_context *ctx, gl_format mesaFormat)
d477 1
a477 1
   case MESA_FORMAT_RED_RGTC1:
d479 1
a479 1
   case MESA_FORMAT_SIGNED_RED_RGTC1:
d481 1
a481 1
   case MESA_FORMAT_RG_RGTC2:
d483 1
a483 1
   case MESA_FORMAT_SIGNED_RG_RGTC2:
d486 1
a486 1
   case MESA_FORMAT_L_LATC1:
d488 1
a488 1
   case MESA_FORMAT_SIGNED_L_LATC1:
d490 1
a490 1
   case MESA_FORMAT_LA_LATC2:
d492 1
a492 1
   case MESA_FORMAT_SIGNED_LA_LATC2:
d538 1
a538 1
                               gl_format mesaFormat,
d563 1
a563 1
_mesa_get_compressed_fetch_func(gl_format format)
d578 8
a585 8
   case MESA_FORMAT_RED_RGTC1:
   case MESA_FORMAT_L_LATC1:
   case MESA_FORMAT_SIGNED_RED_RGTC1:
   case MESA_FORMAT_SIGNED_L_LATC1:
   case MESA_FORMAT_RG_RGTC2:
   case MESA_FORMAT_LA_LATC2:
   case MESA_FORMAT_SIGNED_RG_RGTC2:
   case MESA_FORMAT_SIGNED_LA_LATC2:
d601 1
a601 1
_mesa_decompress_image(gl_format format, GLuint width, GLuint height,
@


1.5
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a2 1
 * Version:  6.5.1
d20 4
a23 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
d36 1
a37 1
#include "mfeatures.h"
d39 1
d41 4
d80 1
d82 1
d87 1
d89 1
d98 3
d116 4
d267 10
a276 1
   if (ctx->Extensions.S3_s3tc) {
d278 1
a278 4
         formats[n++] = GL_RGB_S3TC;
         formats[n++] = GL_RGB4_S3TC;
         formats[n++] = GL_RGBA_S3TC;
         formats[n++] = GL_RGBA4_S3TC;
d281 1
a281 1
         n += 4;
a283 1
   return n;
d285 16
a300 12
#if FEATURE_ES1 || FEATURE_ES2
   if (formats) {
      formats[n++] = GL_PALETTE4_RGB8_OES;
      formats[n++] = GL_PALETTE4_RGBA8_OES;
      formats[n++] = GL_PALETTE4_R5_G6_B5_OES;
      formats[n++] = GL_PALETTE4_RGBA4_OES;
      formats[n++] = GL_PALETTE4_RGB5_A1_OES;
      formats[n++] = GL_PALETTE8_RGB8_OES;
      formats[n++] = GL_PALETTE8_RGBA8_OES;
      formats[n++] = GL_PALETTE8_R5_G6_B5_OES;
      formats[n++] = GL_PALETTE8_RGBA4_OES;
      formats[n++] = GL_PALETTE8_RGB5_A1_OES;
d302 17
a318 2
   else {
      n += 10;
d320 1
a320 1
#endif
d377 23
d417 1
a417 1
_mesa_compressed_format_to_glenum(struct gl_context *ctx, GLuint mesaFormat)
a419 1
#if FEATURE_texture_fxt1
a423 2
#endif
#if FEATURE_texture_s3tc
a431 1
#if FEATURE_EXT_texture_sRGB
a439 3
#endif
#endif

d458 23
d518 72
@


1.4
log
@Merge Mesa 7.10.3
@
text
@d37 2
d43 88
d134 88
a223 3
 * \param all  if true return all formats, even those with  some kind
 *             of restrictions/limitations (See GL_ARB_texture_compression
 *             spec for more info).
d228 1
a228 1
_mesa_get_compressed_formats(struct gl_context *ctx, GLint *formats, GLboolean all)
d240 1
a243 7
         /* This format has some restrictions/limitations and so should
          * not be returned via the GL_COMPRESSED_TEXTURE_FORMATS query.
          * Specifically, all transparent pixels become black.  NVIDIA
          * omits this format too.
          */
         if (all)
             formats[n++] = GL_COMPRESSED_RGBA_S3TC_DXT1_EXT;
a248 2
         if (all)
             n += 1;
a261 13
#if FEATURE_EXT_texture_sRGB
   if (ctx->Extensions.EXT_texture_sRGB) {
      if (formats) {
         formats[n++] = GL_COMPRESSED_SRGB_S3TC_DXT1_EXT;
         formats[n++] = GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
         formats[n++] = GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
         formats[n++] = GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
      }
      else {
         n += 4;
      }
   }
#endif /* FEATURE_EXT_texture_sRGB */
d318 19
d383 19
@


1.3
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@a35 1
#include "context.h"
d53 1
a53 1
_mesa_get_compressed_formats(GLcontext *ctx, GLint *formats, GLboolean all)
d109 18
d181 1
a181 1
_mesa_compressed_format_to_glenum(GLcontext *ctx, GLuint mesaFormat)
@


1.2
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d6 1
d37 1
a37 2
#include "image.h"
#include "mipmap.h"
a38 2
#include "texformat.h"
#include "texstore.h"
d57 4
a60 9
   if (ctx->Extensions.ARB_texture_compression) {
      if (ctx->Extensions.TDFX_texture_compression_FXT1) {
         if (formats) {
            formats[n++] = GL_COMPRESSED_RGB_FXT1_3DFX;
            formats[n++] = GL_COMPRESSED_RGBA_FXT1_3DFX;
         }
         else {
            n += 2;
         }
d62 2
a63 18
      if (ctx->Extensions.EXT_texture_compression_s3tc) {
         if (formats) {
            formats[n++] = GL_COMPRESSED_RGB_S3TC_DXT1_EXT;
            /* This format has some restrictions/limitations and so should
             * not be returned via the GL_COMPRESSED_TEXTURE_FORMATS query.
             * Specifically, all transparent pixels become black.  NVIDIA
             * omits this format too.
             */
            if (all)
               formats[n++] = GL_COMPRESSED_RGBA_S3TC_DXT1_EXT;
            formats[n++] = GL_COMPRESSED_RGBA_S3TC_DXT3_EXT;
            formats[n++] = GL_COMPRESSED_RGBA_S3TC_DXT5_EXT;
         }
         else {
            n += 3;
            if (all)
               n += 1;
         }
d65 26
a90 10
      if (ctx->Extensions.S3_s3tc) {
         if (formats) {
            formats[n++] = GL_RGB_S3TC;
            formats[n++] = GL_RGB4_S3TC;
            formats[n++] = GL_RGBA_S3TC;
            formats[n++] = GL_RGBA4_S3TC;
         }
         else {
            n += 4;
         }
d92 4
d97 9
a105 10
      if (ctx->Extensions.EXT_texture_sRGB) {
         if (formats) {
            formats[n++] = GL_COMPRESSED_SRGB_S3TC_DXT1_EXT;
            formats[n++] = GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
            formats[n++] = GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
            formats[n++] = GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
         }
         else {
            n += 4;
         }
d107 1
a108 1
   }
a112 65

/**
 * Return number of bytes needed to store a texture of the given size
 * using the specified compressed format.
 * This is called via the ctx->Driver.CompressedTextureSize function,
 * unless a device driver overrides it.
 *
 * \param width texture width in texels.
 * \param height texture height in texels.
 * \param depth texture depth in texels.
 * \param mesaFormat  one of the MESA_FORMAT_* compressed formats
 *
 * \return size in bytes, or zero if bad format
 */
GLuint
_mesa_compressed_texture_size( GLcontext *ctx,
                               GLsizei width, GLsizei height, GLsizei depth,
                               GLuint mesaFormat )
{
   GLuint size;

   ASSERT(depth == 1);
   (void) depth;

   switch (mesaFormat) {
   case MESA_FORMAT_RGB_FXT1:
   case MESA_FORMAT_RGBA_FXT1:
      /* round up width to next multiple of 8, height to next multiple of 4 */
      width = (width + 7) & ~7;
      height = (height + 3) & ~3;
      /* 16 bytes per 8x4 tile of RGB[A] texels */
      size = width * height / 2;
      /* Textures smaller than 8x4 will effectively be made into 8x4 and
       * take 16 bytes.
       */
      return size;
   case MESA_FORMAT_RGB_DXT1:
   case MESA_FORMAT_RGBA_DXT1:
      /* round up width, height to next multiple of 4 */
      width = (width + 3) & ~3;
      height = (height + 3) & ~3;
      /* 8 bytes per 4x4 tile of RGB[A] texels */
      size = width * height / 2;
      /* Textures smaller than 4x4 will effectively be made into 4x4 and
       * take 8 bytes.
       */
      return size;
   case MESA_FORMAT_RGBA_DXT3:
   case MESA_FORMAT_RGBA_DXT5:
      /* round up width, height to next multiple of 4 */
      width = (width + 3) & ~3;
      height = (height + 3) & ~3;
      /* 16 bytes per 4x4 tile of RGBA texels */
      size = width * height; /* simple! */
      /* Textures smaller than 4x4 will effectively be made into 4x4 and
       * take 16 bytes.
       */
      return size;
   default:
      _mesa_problem(ctx, "bad mesaFormat in _mesa_compressed_texture_size");
      return 0;
   }
}


d114 1
a114 7
 * As above, but format is specified by a GLenum (GL_COMPRESSED_*) token.
 *
 * Note: This function CAN NOT return a padded hardware texture size.
 * That's why we don't call the ctx->Driver.CompressedTextureSize() function.
 *
 * We use this function to validate the <imageSize> parameter
 * of glCompressedTex[Sub]Image1/2/3D(), which must be an exact match.
d116 2
a117 4
GLuint
_mesa_compressed_texture_size_glenum(GLcontext *ctx,
                                     GLsizei width, GLsizei height,
                                     GLsizei depth, GLenum glformat)
d119 1
a119 3
   GLuint mesaFormat;

   switch (glformat) {
d121 1
a121 2
      mesaFormat = MESA_FORMAT_RGB_FXT1;
      break;
d123 2
a124 2
      mesaFormat = MESA_FORMAT_RGBA_FXT1;
      break;
d127 1
a127 2
      mesaFormat = MESA_FORMAT_RGB_DXT1;
      break;
d130 1
a130 2
      mesaFormat = MESA_FORMAT_RGBA_DXT1;
      break;
d133 1
a133 2
      mesaFormat = MESA_FORMAT_RGBA_DXT3;
      break;
d136 11
a146 2
      mesaFormat = MESA_FORMAT_RGBA_DXT5;
      break;
d148 1
a148 1
      return 0;
a149 2

   return _mesa_compressed_texture_size(ctx, width, height, depth, mesaFormat);
d153 9
a161 6
/*
 * Compute the bytes per row in a compressed texture image.
 * We use this for computing the destination address for sub-texture updates.
 * \param mesaFormat  one of the MESA_FORMAT_* compressed formats
 * \param width  image width in pixels
 * \return stride, in bytes, between rows for compressed image
d163 2
a164 2
GLint
_mesa_compressed_row_stride(GLuint mesaFormat, GLsizei width)
a165 2
   GLint stride;

d167 1
d169 1
d171 3
a173 2
      stride = ((width + 7) / 8) * 16; /* 16 bytes per 8x4 tile */
      break;
d175 1
d177 1
a177 2
      stride = ((width + 3) / 4) * 8; /* 8 bytes per 4x4 tile */
      break;
d179 1
d181 12
a192 2
      stride = ((width + 3) / 4) * 16; /* 16 bytes per 4x4 tile */
      break;
d194 2
a195 1
      _mesa_problem(NULL, "bad mesaFormat in _mesa_compressed_row_stride");
a197 2

   return stride;
d204 2
a205 1
 * \param col, row, img - image position (3D)
d207 1
a207 1
 * \param width - image width
d209 1
a209 1
 * \return address of pixel at (row, col)
d213 1
a213 1
                               GLuint mesaFormat,
d216 4
a219 1
   GLubyte *addr;
d221 1
a221 1
   (void) img;
d223 2
a224 7
   /* We try to spot a "complete" subtexture "above" ROW, COL;
    * this texture is given by appropriate rounding of WIDTH x ROW.
    * Then we just add the amount left (usually on the left).
    *
    * Example for X*Y microtiles (Z bytes each)
    * offset = Z * (((width + X - 1) / X) * (row / Y) + col / X);
    */
d226 2
a227 17
   switch (mesaFormat) {
   case MESA_FORMAT_RGB_FXT1:
   case MESA_FORMAT_RGBA_FXT1:
      addr = (GLubyte *) image + 16 * (((width + 7) / 8) * (row / 4) + col / 8);
      break;
   case MESA_FORMAT_RGB_DXT1:
   case MESA_FORMAT_RGBA_DXT1:
      addr = (GLubyte *) image + 8 * (((width + 3) / 4) * (row / 4) + col / 4);
      break;
   case MESA_FORMAT_RGBA_DXT3:
   case MESA_FORMAT_RGBA_DXT5:
      addr = (GLubyte *) image + 16 * (((width + 3) / 4) * (row / 4) + col / 4);
      break;
   default:
      _mesa_problem(NULL, "bad mesaFormat in _mesa_compressed_image_address");
      addr = NULL;
   }
d229 1
a229 1
   return addr;
@


1.1
log
@Initial revision
@
text
@d37 1
a151 2
      if (size < 16)
         size = 16;
a162 2
      if (size < 8)
         size = 8;
a173 2
      if (size < 16)
         size = 16;
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@a36 1
#include "mipmap.h"
@


1.1.1.3
log
@Import Mesa 7.10.3
@
text
@a5 1
 * Copyright (c) 2008 VMware, Inc.
d35 3
a37 1
#include "formats.h"
d39 2
d56 1
a56 1
_mesa_get_compressed_formats(struct gl_context *ctx, GLint *formats, GLboolean all)
d59 9
a67 4
   if (ctx->Extensions.TDFX_texture_compression_FXT1) {
      if (formats) {
         formats[n++] = GL_COMPRESSED_RGB_FXT1_3DFX;
         formats[n++] = GL_COMPRESSED_RGBA_FXT1_3DFX;
d69 18
a86 2
      else {
         n += 2;
d88 10
a97 26
   }
   if (ctx->Extensions.EXT_texture_compression_s3tc) {
      if (formats) {
         formats[n++] = GL_COMPRESSED_RGB_S3TC_DXT1_EXT;
         /* This format has some restrictions/limitations and so should
          * not be returned via the GL_COMPRESSED_TEXTURE_FORMATS query.
          * Specifically, all transparent pixels become black.  NVIDIA
          * omits this format too.
          */
         if (all)
             formats[n++] = GL_COMPRESSED_RGBA_S3TC_DXT1_EXT;
         formats[n++] = GL_COMPRESSED_RGBA_S3TC_DXT3_EXT;
         formats[n++] = GL_COMPRESSED_RGBA_S3TC_DXT5_EXT;
      }
      else {
         n += 3;
         if (all)
             n += 1;
      }
   }
   if (ctx->Extensions.S3_s3tc) {
      if (formats) {
         formats[n++] = GL_RGB_S3TC;
         formats[n++] = GL_RGB4_S3TC;
         formats[n++] = GL_RGBA_S3TC;
         formats[n++] = GL_RGBA4_S3TC;
a98 4
      else {
         n += 4;
      }
   }
d100 10
a109 9
   if (ctx->Extensions.EXT_texture_sRGB) {
      if (formats) {
         formats[n++] = GL_COMPRESSED_SRGB_S3TC_DXT1_EXT;
         formats[n++] = GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
         formats[n++] = GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
         formats[n++] = GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
      }
      else {
         n += 4;
d111 1
a112 1
#endif /* FEATURE_EXT_texture_sRGB */
d114 2
d117 67
a183 12
#if FEATURE_ES1 || FEATURE_ES2
   if (formats) {
      formats[n++] = GL_PALETTE4_RGB8_OES;
      formats[n++] = GL_PALETTE4_RGBA8_OES;
      formats[n++] = GL_PALETTE4_R5_G6_B5_OES;
      formats[n++] = GL_PALETTE4_RGBA4_OES;
      formats[n++] = GL_PALETTE4_RGB5_A1_OES;
      formats[n++] = GL_PALETTE8_RGB8_OES;
      formats[n++] = GL_PALETTE8_RGBA8_OES;
      formats[n++] = GL_PALETTE8_R5_G6_B5_OES;
      formats[n++] = GL_PALETTE8_RGBA4_OES;
      formats[n++] = GL_PALETTE8_RGB5_A1_OES;
a184 4
   else {
      n += 10;
   }
#endif
d189 7
a195 1
 * Convert a compressed MESA_FORMAT_x to a GLenum.
d197 4
a200 2
gl_format
_mesa_glenum_to_compressed_format(GLenum format)
d202 3
a204 1
   switch (format) {
d206 2
a207 1
      return MESA_FORMAT_RGB_FXT1;
d209 2
a210 2
      return MESA_FORMAT_RGBA_FXT1;

d213 2
a214 1
      return MESA_FORMAT_RGB_DXT1;
d217 2
a218 1
      return MESA_FORMAT_RGBA_DXT1;
d221 2
a222 1
      return MESA_FORMAT_RGBA_DXT3;
d225 2
a226 11
      return MESA_FORMAT_RGBA_DXT5;

   case GL_COMPRESSED_SRGB_S3TC_DXT1_EXT:
      return MESA_FORMAT_SRGB_DXT1;
   case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:
      return MESA_FORMAT_SRGBA_DXT1;
   case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:
      return MESA_FORMAT_SRGBA_DXT3;
   case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:
      return MESA_FORMAT_SRGBA_DXT5;

d228 1
a228 1
      return MESA_FORMAT_NONE;
d230 2
d235 6
a240 9
/**
 * Given a compressed MESA_FORMAT_x value, return the corresponding
 * GLenum for that format.
 * This is needed for glGetTexLevelParameter(GL_TEXTURE_INTERNAL_FORMAT)
 * which must return the specific texture format used when the user might
 * have originally specified a generic compressed format in their
 * glTexImage2D() call.
 * For non-compressed textures, we always return the user-specified
 * internal format unchanged.
d242 2
a243 2
GLenum
_mesa_compressed_format_to_glenum(struct gl_context *ctx, GLuint mesaFormat)
d245 2
a247 1
#if FEATURE_texture_fxt1
a248 1
      return GL_COMPRESSED_RGB_FXT1_3DFX;
d250 2
a251 3
      return GL_COMPRESSED_RGBA_FXT1_3DFX;
#endif
#if FEATURE_texture_s3tc
a252 1
      return GL_COMPRESSED_RGB_S3TC_DXT1_EXT;
d254 2
a255 1
      return GL_COMPRESSED_RGBA_S3TC_DXT1_EXT;
a256 1
      return GL_COMPRESSED_RGBA_S3TC_DXT3_EXT;
d258 2
a259 12
      return GL_COMPRESSED_RGBA_S3TC_DXT5_EXT;
#if FEATURE_EXT_texture_sRGB
   case MESA_FORMAT_SRGB_DXT1:
      return GL_COMPRESSED_SRGB_S3TC_DXT1_EXT;
   case MESA_FORMAT_SRGBA_DXT1:
      return GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
   case MESA_FORMAT_SRGBA_DXT3:
      return GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
   case MESA_FORMAT_SRGBA_DXT5:
      return GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
#endif
#endif
d261 1
a261 2
      _mesa_problem(ctx, "Unexpected mesa texture format in"
                    " _mesa_compressed_format_to_glenum()");
d264 2
d272 1
a272 2
 * \param col, row, img - image position (3D), should be a multiple of the
 *                        format's block size.
d274 1
a274 1
 * \param width - image width (stride) in pixels
d276 1
a276 1
 * \return address of pixel at (row, col, img)
d280 1
a280 1
                               gl_format mesaFormat,
d283 1
a283 4
   /* XXX only 2D images implemented, not 3D */
   const GLuint blockSize = _mesa_get_format_bytes(mesaFormat);
   GLuint bw, bh;
   GLint offset;
d285 1
a285 1
   _mesa_get_format_block_size(mesaFormat, &bw, &bh);
d287 7
a293 2
   ASSERT(col % bw == 0);
   ASSERT(row % bh == 0);
d295 17
a311 2
   offset = ((width + bw - 1) / bw) * (row / bh) + col / bw;
   offset *= blockSize;
d313 1
a313 1
   return (GLubyte *) image + offset;
@


1.1.1.4
log
@Import Mesa 9.2.0
@
text
@d3 1
d21 3
a23 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
a35 1
#include "context.h"
a36 2
#include "mtypes.h"
#include "context.h"
a37 4
#include "texcompress_fxt1.h"
#include "texcompress_rgtc.h"
#include "texcompress_s3tc.h"
#include "texcompress_etc.h"
a40 99
 * Get the GL base format of a specified GL compressed texture format
 *
 * From page 232 of the OpenGL 3.3 (Compatiblity Profile) spec:
 *
 *     "Compressed Internal Format      Base Internal Format    Type
 *     ---------------------------     --------------------    ---------
 *     COMPRESSED_ALPHA                ALPHA                   Generic
 *     COMPRESSED_LUMINANCE            LUMINANCE               Generic
 *     COMPRESSED_LUMINANCE_ALPHA      LUMINANCE_ALPHA         Generic
 *     COMPRESSED_INTENSITY            INTENSITY               Generic
 *     COMPRESSED_RED                  RED                     Generic
 *     COMPRESSED_RG                   RG                      Generic
 *     COMPRESSED_RGB                  RGB                     Generic
 *     COMPRESSED_RGBA                 RGBA                    Generic
 *     COMPRESSED_SRGB                 RGB                     Generic
 *     COMPRESSED_SRGB_ALPHA           RGBA                    Generic
 *     COMPRESSED_SLUMINANCE           LUMINANCE               Generic
 *     COMPRESSED_SLUMINANCE_ALPHA     LUMINANCE_ALPHA         Generic
 *     COMPRESSED_RED_RGTC1            RED                     Specific
 *     COMPRESSED_SIGNED_RED_RGTC1     RED                     Specific
 *     COMPRESSED_RG_RGTC2             RG                      Specific
 *     COMPRESSED_SIGNED_RG_RGTC2      RG                      Specific"
 *
 * \return
 * The base format of \c format if \c format is a compressed format (either
 * generic or specific.  Otherwise 0 is returned.
 */
GLenum
_mesa_gl_compressed_format_base_format(GLenum format)
{
   switch (format) {
   case GL_COMPRESSED_RED:
   case GL_COMPRESSED_R11_EAC:
   case GL_COMPRESSED_RED_RGTC1:
   case GL_COMPRESSED_SIGNED_R11_EAC:
   case GL_COMPRESSED_SIGNED_RED_RGTC1:
      return GL_RED;

   case GL_COMPRESSED_RG:
   case GL_COMPRESSED_RG11_EAC:
   case GL_COMPRESSED_RG_RGTC2:
   case GL_COMPRESSED_SIGNED_RG11_EAC:
   case GL_COMPRESSED_SIGNED_RG_RGTC2:
      return GL_RG;

   case GL_COMPRESSED_RGB:
   case GL_COMPRESSED_SRGB:
   case GL_COMPRESSED_RGB_S3TC_DXT1_EXT:
   case GL_COMPRESSED_RGB_FXT1_3DFX:
   case GL_COMPRESSED_SRGB_S3TC_DXT1_EXT:
   case GL_ETC1_RGB8_OES:
   case GL_COMPRESSED_RGB8_ETC2:
   case GL_COMPRESSED_SRGB8_ETC2:
      return GL_RGB;

   case GL_COMPRESSED_RGBA:
   case GL_COMPRESSED_SRGB_ALPHA:
   case GL_COMPRESSED_RGBA_BPTC_UNORM_ARB:
   case GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM_ARB:
   case GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT_ARB:
   case GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_ARB:
   case GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:
   case GL_COMPRESSED_RGBA_S3TC_DXT3_EXT:
   case GL_COMPRESSED_RGBA_S3TC_DXT5_EXT:
   case GL_COMPRESSED_RGBA_FXT1_3DFX:
   case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:
   case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:
   case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:
   case GL_COMPRESSED_RGBA8_ETC2_EAC:
   case GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:
   case GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:
   case GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:
      return GL_RGBA;

   case GL_COMPRESSED_ALPHA:
      return GL_ALPHA;

   case GL_COMPRESSED_LUMINANCE:
   case GL_COMPRESSED_SLUMINANCE:
   case GL_COMPRESSED_LUMINANCE_LATC1_EXT:
   case GL_COMPRESSED_SIGNED_LUMINANCE_LATC1_EXT:
      return GL_LUMINANCE;

   case GL_COMPRESSED_LUMINANCE_ALPHA:
   case GL_COMPRESSED_SLUMINANCE_ALPHA:
   case GL_COMPRESSED_LUMINANCE_ALPHA_LATC2_EXT:
   case GL_COMPRESSED_SIGNED_LUMINANCE_ALPHA_LATC2_EXT:
   case GL_COMPRESSED_LUMINANCE_ALPHA_3DC_ATI:
      return GL_LUMINANCE_ALPHA;

   case GL_COMPRESSED_INTENSITY:
      return GL_INTENSITY;

   default:
      return 0;
   }
}

/**
a43 88
 * Some formats are \b not returned by this function.  The
 * \c GL_COMPRESSED_TEXTURE_FORMATS query only returns formats that are
 * "suitable for general-purpose usage."  All texture compression extensions
 * have taken this to mean either linear RGB or linear RGBA.
 *
 * The GL_ARB_texture_compress_rgtc spec says:
 *
 *    "19) Should the GL_NUM_COMPRESSED_TEXTURE_FORMATS and
 *        GL_COMPRESSED_TEXTURE_FORMATS queries return the RGTC formats?
 *
 *        RESOLVED:  No.
 *
 *        The OpenGL 2.1 specification says "The only values returned
 *        by this query [GL_COMPRESSED_TEXTURE_FORMATS"] are those
 *        corresponding to formats suitable for general-purpose usage.
 *        The renderer will not enumerate formats with restrictions that
 *        need to be specifically understood prior to use."
 *
 *        Compressed textures with just red or red-green components are
 *        not general-purpose so should not be returned by these queries
 *        because they have restrictions.
 *
 *        Applications that seek to use the RGTC formats should do so
 *        by looking for this extension's name in the string returned by
 *        glGetString(GL_EXTENSIONS) rather than
 *        what GL_NUM_COMPRESSED_TEXTURE_FORMATS and
 *        GL_COMPRESSED_TEXTURE_FORMATS return."
 *
 * There is nearly identical wording in the GL_EXT_texture_compression_rgtc
 * spec.
 *
 * The GL_EXT_texture_rRGB spec says:
 *
 *    "22) Should the new COMPRESSED_SRGB_* formats be listed in an
 *        implementation's GL_COMPRESSED_TEXTURE_FORMATS list?
 *
 *        RESOLVED:  No.  Section 3.8.1 says formats listed by
 *        GL_COMPRESSED_TEXTURE_FORMATS are "suitable for general-purpose
 *        usage."  The non-linear distribution of red, green, and
 *        blue for these sRGB compressed formats makes them not really
 *        general-purpose."
 *
 * The GL_EXT_texture_compression_latc spec says:
 *
 *    "16) Should the GL_NUM_COMPRESSED_TEXTURE_FORMATS and
 *        GL_COMPRESSED_TEXTURE_FORMATS queries return the LATC formats?
 *
 *        RESOLVED:  No.
 *
 *        The OpenGL 2.1 specification says "The only values returned
 *        by this query [GL_COMPRESSED_TEXTURE_FORMATS"] are those
 *        corresponding to formats suitable for general-purpose usage.
 *        The renderer will not enumerate formats with restrictions that
 *        need to be specifically understood prior to use."
 *
 *        Historically, OpenGL implementation have advertised the RGB and
 *        RGBA versions of the S3TC extensions compressed format tokens
 *        through this mechanism.
 *
 *        The specification is not sufficiently clear about what "suitable
 *        for general-purpose usage" means.  Historically that seems to mean
 *        unsigned RGB or unsigned RGBA.  The DXT1 format supporting alpha
 *        (GL_COMPRESSED_RGBA_S3TC_DXT1_EXT) is not exposed in the list (at
 *        least for NVIDIA drivers) because the alpha is always 1.0 expect
 *        when it is 0.0 when RGB is required to be black.  NVIDIA's even
 *        limits itself to true linear RGB or RGBA formats, specifically
 *        not including EXT_texture_sRGB's sRGB S3TC compressed formats.
 *
 *        Adding luminance and luminance-alpha texture formats (and
 *        certainly signed versions of luminance and luminance-alpha
 *        formats!) invites potential comptaibility problems with old
 *        applications using this mechanism since old applications are
 *        unlikely to expect non-RGB or non-RGBA formats to be advertised
 *        through this mechanism.  However no specific misinteractions
 *        with old applications is known.
 *
 *        Applications that seek to use the LATC formats should do so
 *        by looking for this extension's name in the string returned by
 *        glGetString(GL_EXTENSIONS) rather than
 *        what GL_NUM_COMPRESSED_TEXTURE_FORMATS and
 *        GL_COMPRESSED_TEXTURE_FORMATS return."
 *
 * There is no formal spec for GL_ATI_texture_compression_3dc.  Since the
 * formats added by this extension are luminance-alpha formats, it is
 * reasonable to expect them to follow the same rules as
 * GL_EXT_texture_compression_latc.  At the very least, Catalyst 11.6 does not
 * expose the 3dc formats through this mechanism.
 *
d46 3
d53 1
a53 1
_mesa_get_compressed_formats(struct gl_context *ctx, GLint *formats)
a64 1

d68 7
d80 2
d84 1
a84 10

   /* The GL_OES_compressed_ETC1_RGB8_texture spec says:
    *
    *     "New State
    *
    *         The queries for NUM_COMPRESSED_TEXTURE_FORMATS and
    *         COMPRESSED_TEXTURE_FORMATS include ETC1_RGB8_OES."
    */
   if (_mesa_is_gles(ctx)
       && ctx->Extensions.OES_compressed_ETC1_RGB8_texture) {
d86 4
a89 1
         formats[n++] = GL_ETC1_RGB8_OES;
d92 1
a92 1
         n += 1;
d95 2
a96 2

   if (ctx->API == API_OPENGLES) {
d98 4
a101 10
	 formats[n++] = GL_PALETTE4_RGB8_OES;
	 formats[n++] = GL_PALETTE4_RGBA8_OES;
	 formats[n++] = GL_PALETTE4_R5_G6_B5_OES;
	 formats[n++] = GL_PALETTE4_RGBA4_OES;
	 formats[n++] = GL_PALETTE4_RGB5_A1_OES;
	 formats[n++] = GL_PALETTE8_RGB8_OES;
	 formats[n++] = GL_PALETTE8_RGBA8_OES;
	 formats[n++] = GL_PALETTE8_R5_G6_B5_OES;
	 formats[n++] = GL_PALETTE8_RGBA4_OES;
	 formats[n++] = GL_PALETTE8_RGB5_A1_OES;
d104 1
a104 1
	 n += 10;
d107 2
d110 15
a124 16
   if (_mesa_is_gles3(ctx)) {
      if (formats) {
         formats[n++] = GL_COMPRESSED_RGB8_ETC2;
         formats[n++] = GL_COMPRESSED_SRGB8_ETC2;
         formats[n++] = GL_COMPRESSED_RGBA8_ETC2_EAC;
         formats[n++] = GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;
         formats[n++] = GL_COMPRESSED_R11_EAC;
         formats[n++] = GL_COMPRESSED_RG11_EAC;
         formats[n++] = GL_COMPRESSED_SIGNED_R11_EAC;
         formats[n++] = GL_COMPRESSED_SIGNED_RG11_EAC;
         formats[n++] = GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2;
         formats[n++] = GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2;
      }
      else {
         n += 10;
      }
d126 1
a126 1
   return n;
a163 42
   case GL_COMPRESSED_RED_RGTC1:
      return MESA_FORMAT_RED_RGTC1;
   case GL_COMPRESSED_SIGNED_RED_RGTC1:
      return MESA_FORMAT_SIGNED_RED_RGTC1;
   case GL_COMPRESSED_RG_RGTC2:
      return MESA_FORMAT_RG_RGTC2;
   case GL_COMPRESSED_SIGNED_RG_RGTC2:
      return MESA_FORMAT_SIGNED_RG_RGTC2;

   case GL_COMPRESSED_LUMINANCE_LATC1_EXT:
      return MESA_FORMAT_L_LATC1;
   case GL_COMPRESSED_SIGNED_LUMINANCE_LATC1_EXT:
      return MESA_FORMAT_SIGNED_L_LATC1;
   case GL_COMPRESSED_LUMINANCE_ALPHA_LATC2_EXT:
   case GL_COMPRESSED_LUMINANCE_ALPHA_3DC_ATI:
      return MESA_FORMAT_LA_LATC2;
   case GL_COMPRESSED_SIGNED_LUMINANCE_ALPHA_LATC2_EXT:
      return MESA_FORMAT_SIGNED_LA_LATC2;

   case GL_ETC1_RGB8_OES:
      return MESA_FORMAT_ETC1_RGB8;
   case GL_COMPRESSED_RGB8_ETC2:
      return MESA_FORMAT_ETC2_RGB8;
   case GL_COMPRESSED_SRGB8_ETC2:
      return MESA_FORMAT_ETC2_SRGB8;
   case GL_COMPRESSED_RGBA8_ETC2_EAC:
      return MESA_FORMAT_ETC2_RGBA8_EAC;
   case GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:
      return MESA_FORMAT_ETC2_SRGB8_ALPHA8_EAC;
   case GL_COMPRESSED_R11_EAC:
      return MESA_FORMAT_ETC2_R11_EAC;
   case GL_COMPRESSED_RG11_EAC:
      return MESA_FORMAT_ETC2_RG11_EAC;
   case GL_COMPRESSED_SIGNED_R11_EAC:
      return MESA_FORMAT_ETC2_SIGNED_R11_EAC;
   case GL_COMPRESSED_SIGNED_RG11_EAC:
      return MESA_FORMAT_ETC2_SIGNED_RG11_EAC;
   case GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:
      return MESA_FORMAT_ETC2_RGB8_PUNCHTHROUGH_ALPHA1;
   case GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:
      return MESA_FORMAT_ETC2_SRGB8_PUNCHTHROUGH_ALPHA1;

d181 1
a181 1
_mesa_compressed_format_to_glenum(struct gl_context *ctx, gl_format mesaFormat)
d184 1
d189 2
d199 1
d208 2
a209 41
   case MESA_FORMAT_RED_RGTC1:
      return GL_COMPRESSED_RED_RGTC1;
   case MESA_FORMAT_SIGNED_RED_RGTC1:
      return GL_COMPRESSED_SIGNED_RED_RGTC1;
   case MESA_FORMAT_RG_RGTC2:
      return GL_COMPRESSED_RG_RGTC2;
   case MESA_FORMAT_SIGNED_RG_RGTC2:
      return GL_COMPRESSED_SIGNED_RG_RGTC2;

   case MESA_FORMAT_L_LATC1:
      return GL_COMPRESSED_LUMINANCE_LATC1_EXT;
   case MESA_FORMAT_SIGNED_L_LATC1:
      return GL_COMPRESSED_SIGNED_LUMINANCE_LATC1_EXT;
   case MESA_FORMAT_LA_LATC2:
      return GL_COMPRESSED_LUMINANCE_ALPHA_LATC2_EXT;
   case MESA_FORMAT_SIGNED_LA_LATC2:
      return GL_COMPRESSED_SIGNED_LUMINANCE_ALPHA_LATC2_EXT;

   case MESA_FORMAT_ETC1_RGB8:
      return GL_ETC1_RGB8_OES;
   case MESA_FORMAT_ETC2_RGB8:
      return GL_COMPRESSED_RGB8_ETC2;
   case MESA_FORMAT_ETC2_SRGB8:
      return GL_COMPRESSED_SRGB8_ETC2;
   case MESA_FORMAT_ETC2_RGBA8_EAC:
      return GL_COMPRESSED_RGBA8_ETC2_EAC;
   case MESA_FORMAT_ETC2_SRGB8_ALPHA8_EAC:
      return GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;
   case MESA_FORMAT_ETC2_R11_EAC:
      return GL_COMPRESSED_R11_EAC;
   case MESA_FORMAT_ETC2_RG11_EAC:
      return GL_COMPRESSED_RG11_EAC;
   case MESA_FORMAT_ETC2_SIGNED_R11_EAC:
      return GL_COMPRESSED_SIGNED_R11_EAC;
   case MESA_FORMAT_ETC2_SIGNED_RG11_EAC:
      return GL_COMPRESSED_SIGNED_RG11_EAC;
   case MESA_FORMAT_ETC2_RGB8_PUNCHTHROUGH_ALPHA1:
      return GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2;
   case MESA_FORMAT_ETC2_SRGB8_PUNCHTHROUGH_ALPHA1:
      return GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2;

a246 72
}


/**
 * Return a texel-fetch function for the given format, or NULL if
 * invalid format.
 */
compressed_fetch_func
_mesa_get_compressed_fetch_func(gl_format format)
{
   switch (format) {
   case MESA_FORMAT_RGB_DXT1:
   case MESA_FORMAT_RGBA_DXT1:
   case MESA_FORMAT_RGBA_DXT3:
   case MESA_FORMAT_RGBA_DXT5:
   case MESA_FORMAT_SRGB_DXT1:
   case MESA_FORMAT_SRGBA_DXT1:
   case MESA_FORMAT_SRGBA_DXT3:
   case MESA_FORMAT_SRGBA_DXT5:
      return _mesa_get_dxt_fetch_func(format);
   case MESA_FORMAT_RGB_FXT1:
   case MESA_FORMAT_RGBA_FXT1:
      return _mesa_get_fxt_fetch_func(format);
   case MESA_FORMAT_RED_RGTC1:
   case MESA_FORMAT_L_LATC1:
   case MESA_FORMAT_SIGNED_RED_RGTC1:
   case MESA_FORMAT_SIGNED_L_LATC1:
   case MESA_FORMAT_RG_RGTC2:
   case MESA_FORMAT_LA_LATC2:
   case MESA_FORMAT_SIGNED_RG_RGTC2:
   case MESA_FORMAT_SIGNED_LA_LATC2:
      return _mesa_get_compressed_rgtc_func(format);
   case MESA_FORMAT_ETC1_RGB8:
      return _mesa_get_etc_fetch_func(format);
   default:
      return NULL;
   }
}


/**
 * Decompress a compressed texture image, returning a GL_RGBA/GL_FLOAT image.
 * \param srcRowStride  stride in bytes between rows of blocks in the
 *                      compressed source image.
 */
void
_mesa_decompress_image(gl_format format, GLuint width, GLuint height,
                       const GLubyte *src, GLint srcRowStride,
                       GLfloat *dest)
{
   compressed_fetch_func fetch;
   GLuint i, j;
   GLuint bytes, bw, bh;
   GLint stride;

   bytes = _mesa_get_format_bytes(format);
   _mesa_get_format_block_size(format, &bw, &bh);

   fetch = _mesa_get_compressed_fetch_func(format);
   if (!fetch) {
      _mesa_problem(NULL, "Unexpected format in _mesa_decompress_image()");
      return;
   }
 
   stride = srcRowStride * bh / bytes;

   for (j = 0; j < height; j++) {
      for (i = 0; i < width; i++) {
         fetch(src, stride, i, j, dest);
         dest += 4;
      }
   }
@


1.1.1.5
log
@Import Mesa 10.2.3
@
text
@a265 37

      /* The ES and desktop GL specs diverge here.
       *
       * In desktop OpenGL, the driver can perform online compression of
       * uncompressed texture data.  GL_NUM_COMPRESSED_TEXTURE_FORMATS and
       * GL_COMPRESSED_TEXTURE_FORMATS give the application a list of
       * formats that it could ask the driver to compress with some
       * expectation of quality.  The GL_ARB_texture_compression spec
       * calls this "suitable for general-purpose usage."  As noted
       * above, this means GL_COMPRESSED_RGBA_S3TC_DXT1_EXT is not
       * included in the list.
       *
       * In OpenGL ES, the driver never performs compression.
       * GL_NUM_COMPRESSED_TEXTURE_FORMATS and
       * GL_COMPRESSED_TEXTURE_FORMATS give the application a list of
       * formats that the driver can receive from the application.  It
       * is the *complete* list of formats.  The
       * GL_EXT_texture_compression_s3tc spec says:
       *
       *     "New State for OpenGL ES 2.0.25 and 3.0.2 Specifications
       *
       *         The queries for NUM_COMPRESSED_TEXTURE_FORMATS and
       *         COMPRESSED_TEXTURE_FORMATS include
       *         COMPRESSED_RGB_S3TC_DXT1_EXT,
       *         COMPRESSED_RGBA_S3TC_DXT1_EXT,
       *         COMPRESSED_RGBA_S3TC_DXT3_EXT, and
       *         COMPRESSED_RGBA_S3TC_DXT5_EXT."
       *
       * Note that the addition is only to the OpenGL ES specification!
       */
      if (_mesa_is_gles(ctx)) {
         if (formats) {
            formats[n++] = GL_COMPRESSED_RGBA_S3TC_DXT1_EXT;
         } else {
            n += 1;
         }
      }
d327 1
a327 1
mesa_format
d359 1
a359 1
      return MESA_FORMAT_R_RGTC1_UNORM;
d361 1
a361 1
      return MESA_FORMAT_R_RGTC1_SNORM;
d363 1
a363 1
      return MESA_FORMAT_RG_RGTC2_UNORM;
d365 1
a365 1
      return MESA_FORMAT_RG_RGTC2_SNORM;
d368 1
a368 1
      return MESA_FORMAT_L_LATC1_UNORM;
d370 1
a370 1
      return MESA_FORMAT_L_LATC1_SNORM;
d373 1
a373 1
      return MESA_FORMAT_LA_LATC2_UNORM;
d375 1
a375 1
      return MESA_FORMAT_LA_LATC2_SNORM;
d417 1
a417 1
_mesa_compressed_format_to_glenum(struct gl_context *ctx, mesa_format mesaFormat)
d440 1
a440 1
   case MESA_FORMAT_R_RGTC1_UNORM:
d442 1
a442 1
   case MESA_FORMAT_R_RGTC1_SNORM:
d444 1
a444 1
   case MESA_FORMAT_RG_RGTC2_UNORM:
d446 1
a446 1
   case MESA_FORMAT_RG_RGTC2_SNORM:
d449 1
a449 1
   case MESA_FORMAT_L_LATC1_UNORM:
d451 1
a451 1
   case MESA_FORMAT_L_LATC1_SNORM:
d453 1
a453 1
   case MESA_FORMAT_LA_LATC2_UNORM:
d455 1
a455 1
   case MESA_FORMAT_LA_LATC2_SNORM:
d501 1
a501 1
                               mesa_format mesaFormat,
d526 1
a526 1
_mesa_get_compressed_fetch_func(mesa_format format)
d541 8
a548 8
   case MESA_FORMAT_R_RGTC1_UNORM:
   case MESA_FORMAT_L_LATC1_UNORM:
   case MESA_FORMAT_R_RGTC1_SNORM:
   case MESA_FORMAT_L_LATC1_SNORM:
   case MESA_FORMAT_RG_RGTC2_UNORM:
   case MESA_FORMAT_LA_LATC2_UNORM:
   case MESA_FORMAT_RG_RGTC2_SNORM:
   case MESA_FORMAT_LA_LATC2_SNORM:
d564 1
a564 1
_mesa_decompress_image(mesa_format format, GLuint width, GLuint height,
@


1.1.1.6
log
@Import Mesa 10.4.3
@
text
@a44 1
#include "texcompress_bptc.h"
a94 2
   case GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT_ARB:
   case GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_ARB:
d107 2
a237 6
 * The spec for GL_ARB_texture_compression_bptc doesn't mention whether it
 * should be included in GL_COMPRESSED_TEXTURE_FORMATS. However as it takes a
 * very long time to compress the textures in this format it's probably not
 * very useful as a general format where the GL will have to compress it on
 * the fly.
 *
a436 9
   case GL_COMPRESSED_RGBA_BPTC_UNORM:
      return MESA_FORMAT_BPTC_RGBA_UNORM;
   case GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:
      return MESA_FORMAT_BPTC_SRGB_ALPHA_UNORM;
   case GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:
      return MESA_FORMAT_BPTC_RGB_SIGNED_FLOAT;
   case GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:
      return MESA_FORMAT_BPTC_RGB_UNSIGNED_FLOAT;

a517 9
   case MESA_FORMAT_BPTC_RGBA_UNORM:
      return GL_COMPRESSED_RGBA_BPTC_UNORM;
   case MESA_FORMAT_BPTC_SRGB_ALPHA_UNORM:
      return GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM;
   case MESA_FORMAT_BPTC_RGB_SIGNED_FLOAT:
      return GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT;
   case MESA_FORMAT_BPTC_RGB_UNSIGNED_FLOAT:
      return GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT;

a588 5
   case MESA_FORMAT_BPTC_RGBA_UNORM:
   case MESA_FORMAT_BPTC_SRGB_ALPHA_UNORM:
   case MESA_FORMAT_BPTC_RGB_SIGNED_FLOAT:
   case MESA_FORMAT_BPTC_RGB_UNSIGNED_FLOAT:
      return _mesa_get_bptc_fetch_func(format);
@


1.1.1.7
log
@Import Mesa 10.2.9
@
text
@d45 1
d96 2
a109 2
   case GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT_ARB:
   case GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_ARB:
d239 6
d444 9
d534 9
d614 5
@


