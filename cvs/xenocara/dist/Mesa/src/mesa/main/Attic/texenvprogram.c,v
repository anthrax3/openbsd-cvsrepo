head	1.8;
access;
symbols
	OPENBSD_5_2:1.7.0.4
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.6.0.6
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.4
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.5.0.4
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.2
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.4.0.2
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.3.0.2
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_3:1.2.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2012.08.17.13.58.19;	author mpi;	state dead;
branches;
next	1.7;

1.7
date	2011.10.23.13.37.43;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.05.22.20.06.31;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2009.05.17.20.26.41;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2008.11.02.14.58.21;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.05.31.16.36.48;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.02.12.21.09.27;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.50.20;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.50.20;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.56.39;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.31.22;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.47;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@/**************************************************************************
 * 
 * Copyright 2007 Tungsten Graphics, Inc., Cedar Park, Texas.
 * All Rights Reserved.
 * Copyright 2009 VMware, Inc.  All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

#include "glheader.h"
#include "imports.h"
#include "program/program.h"
#include "program/prog_parameter.h"
#include "program/prog_cache.h"
#include "program/prog_instruction.h"
#include "program/prog_print.h"
#include "program/prog_statevars.h"
#include "program/programopt.h"
#include "texenvprogram.h"


/*
 * Note on texture units:
 *
 * The number of texture units supported by fixed-function fragment
 * processing is MAX_TEXTURE_COORD_UNITS, not MAX_TEXTURE_IMAGE_UNITS.
 * That's because there's a one-to-one correspondence between texture
 * coordinates and samplers in fixed-function processing.
 *
 * Since fixed-function vertex processing is limited to MAX_TEXTURE_COORD_UNITS
 * sets of texcoords, so is fixed-function fragment processing.
 *
 * We can safely use ctx->Const.MaxTextureUnits for loop bounds.
 */


struct texenvprog_cache_item
{
   GLuint hash;
   void *key;
   struct gl_fragment_program *data;
   struct texenvprog_cache_item *next;
};

static GLboolean
texenv_doing_secondary_color(struct gl_context *ctx)
{
   if (ctx->Light.Enabled &&
       (ctx->Light.Model.ColorControl == GL_SEPARATE_SPECULAR_COLOR))
      return GL_TRUE;

   if (ctx->Fog.ColorSumEnabled)
      return GL_TRUE;

   return GL_FALSE;
}

/**
 * Up to nine instructions per tex unit, plus fog, specular color.
 */
#define MAX_INSTRUCTIONS ((MAX_TEXTURE_COORD_UNITS * 9) + 12)

#define DISASSEM (MESA_VERBOSE & VERBOSE_DISASSEM)

struct mode_opt {
#ifdef __GNUC__
   __extension__ GLubyte Source:4;  /**< SRC_x */
   __extension__ GLubyte Operand:3; /**< OPR_x */
#else
   GLubyte Source;  /**< SRC_x */
   GLubyte Operand; /**< OPR_x */
#endif
};

struct state_key {
   GLuint nr_enabled_units:8;
   GLuint enabled_units:8;
   GLuint separate_specular:1;
   GLuint fog_enabled:1;
   GLuint fog_mode:2;          /**< FOG_x */
   GLuint inputs_available:12;
   GLuint num_draw_buffers:4;

   /* NOTE: This array of structs must be last! (see "keySize" below) */
   struct {
      GLuint enabled:1;
      GLuint source_index:3;   /**< TEXTURE_x_INDEX */
      GLuint shadow:1;
      GLuint ScaleShiftRGB:2;
      GLuint ScaleShiftA:2;

      GLuint NumArgsRGB:3;  /**< up to MAX_COMBINER_TERMS */
      GLuint ModeRGB:5;     /**< MODE_x */

      GLuint NumArgsA:3;  /**< up to MAX_COMBINER_TERMS */
      GLuint ModeA:5;     /**< MODE_x */

      GLuint texture_cyl_wrap:1; /**< For gallium test/debug only */

      struct mode_opt OptRGB[MAX_COMBINER_TERMS];
      struct mode_opt OptA[MAX_COMBINER_TERMS];
   } unit[MAX_TEXTURE_UNITS];
};

#define FOG_LINEAR  0
#define FOG_EXP     1
#define FOG_EXP2    2
#define FOG_UNKNOWN 3

static GLuint translate_fog_mode( GLenum mode )
{
   switch (mode) {
   case GL_LINEAR: return FOG_LINEAR;
   case GL_EXP: return FOG_EXP;
   case GL_EXP2: return FOG_EXP2;
   default: return FOG_UNKNOWN;
   }
}

#define OPR_SRC_COLOR           0
#define OPR_ONE_MINUS_SRC_COLOR 1
#define OPR_SRC_ALPHA           2
#define OPR_ONE_MINUS_SRC_ALPHA	3
#define OPR_ZERO                4
#define OPR_ONE                 5
#define OPR_UNKNOWN             7

static GLuint translate_operand( GLenum operand )
{
   switch (operand) {
   case GL_SRC_COLOR: return OPR_SRC_COLOR;
   case GL_ONE_MINUS_SRC_COLOR: return OPR_ONE_MINUS_SRC_COLOR;
   case GL_SRC_ALPHA: return OPR_SRC_ALPHA;
   case GL_ONE_MINUS_SRC_ALPHA: return OPR_ONE_MINUS_SRC_ALPHA;
   case GL_ZERO: return OPR_ZERO;
   case GL_ONE: return OPR_ONE;
   default:
      assert(0);
      return OPR_UNKNOWN;
   }
}

#define SRC_TEXTURE  0
#define SRC_TEXTURE0 1
#define SRC_TEXTURE1 2
#define SRC_TEXTURE2 3
#define SRC_TEXTURE3 4
#define SRC_TEXTURE4 5
#define SRC_TEXTURE5 6
#define SRC_TEXTURE6 7
#define SRC_TEXTURE7 8
#define SRC_CONSTANT 9
#define SRC_PRIMARY_COLOR 10
#define SRC_PREVIOUS 11
#define SRC_ZERO     12
#define SRC_UNKNOWN  15

static GLuint translate_source( GLenum src )
{
   switch (src) {
   case GL_TEXTURE: return SRC_TEXTURE;
   case GL_TEXTURE0:
   case GL_TEXTURE1:
   case GL_TEXTURE2:
   case GL_TEXTURE3:
   case GL_TEXTURE4:
   case GL_TEXTURE5:
   case GL_TEXTURE6:
   case GL_TEXTURE7: return SRC_TEXTURE0 + (src - GL_TEXTURE0);
   case GL_CONSTANT: return SRC_CONSTANT;
   case GL_PRIMARY_COLOR: return SRC_PRIMARY_COLOR;
   case GL_PREVIOUS: return SRC_PREVIOUS;
   case GL_ZERO:
      return SRC_ZERO;
   default:
      assert(0);
      return SRC_UNKNOWN;
   }
}

#define MODE_REPLACE                     0  /* r = a0 */
#define MODE_MODULATE                    1  /* r = a0 * a1 */
#define MODE_ADD                         2  /* r = a0 + a1 */
#define MODE_ADD_SIGNED                  3  /* r = a0 + a1 - 0.5 */
#define MODE_INTERPOLATE                 4  /* r = a0 * a2 + a1 * (1 - a2) */
#define MODE_SUBTRACT                    5  /* r = a0 - a1 */
#define MODE_DOT3_RGB                    6  /* r = a0 . a1 */
#define MODE_DOT3_RGB_EXT                7  /* r = a0 . a1 */
#define MODE_DOT3_RGBA                   8  /* r = a0 . a1 */
#define MODE_DOT3_RGBA_EXT               9  /* r = a0 . a1 */
#define MODE_MODULATE_ADD_ATI           10  /* r = a0 * a2 + a1 */
#define MODE_MODULATE_SIGNED_ADD_ATI    11  /* r = a0 * a2 + a1 - 0.5 */
#define MODE_MODULATE_SUBTRACT_ATI      12  /* r = a0 * a2 - a1 */
#define MODE_ADD_PRODUCTS               13  /* r = a0 * a1 + a2 * a3 */
#define MODE_ADD_PRODUCTS_SIGNED        14  /* r = a0 * a1 + a2 * a3 - 0.5 */
#define MODE_BUMP_ENVMAP_ATI            15  /* special */
#define MODE_UNKNOWN                    16

/**
 * Translate GL combiner state into a MODE_x value
 */
static GLuint translate_mode( GLenum envMode, GLenum mode )
{
   switch (mode) {
   case GL_REPLACE: return MODE_REPLACE;
   case GL_MODULATE: return MODE_MODULATE;
   case GL_ADD:
      if (envMode == GL_COMBINE4_NV)
         return MODE_ADD_PRODUCTS;
      else
         return MODE_ADD;
   case GL_ADD_SIGNED:
      if (envMode == GL_COMBINE4_NV)
         return MODE_ADD_PRODUCTS_SIGNED;
      else
         return MODE_ADD_SIGNED;
   case GL_INTERPOLATE: return MODE_INTERPOLATE;
   case GL_SUBTRACT: return MODE_SUBTRACT;
   case GL_DOT3_RGB: return MODE_DOT3_RGB;
   case GL_DOT3_RGB_EXT: return MODE_DOT3_RGB_EXT;
   case GL_DOT3_RGBA: return MODE_DOT3_RGBA;
   case GL_DOT3_RGBA_EXT: return MODE_DOT3_RGBA_EXT;
   case GL_MODULATE_ADD_ATI: return MODE_MODULATE_ADD_ATI;
   case GL_MODULATE_SIGNED_ADD_ATI: return MODE_MODULATE_SIGNED_ADD_ATI;
   case GL_MODULATE_SUBTRACT_ATI: return MODE_MODULATE_SUBTRACT_ATI;
   case GL_BUMP_ENVMAP_ATI: return MODE_BUMP_ENVMAP_ATI;
   default:
      assert(0);
      return MODE_UNKNOWN;
   }
}


/**
 * Do we need to clamp the results of the given texture env/combine mode?
 * If the inputs to the mode are in [0,1] we don't always have to clamp
 * the results.
 */
static GLboolean
need_saturate( GLuint mode )
{
   switch (mode) {
   case MODE_REPLACE:
   case MODE_MODULATE:
   case MODE_INTERPOLATE:
      return GL_FALSE;
   case MODE_ADD:
   case MODE_ADD_SIGNED:
   case MODE_SUBTRACT:
   case MODE_DOT3_RGB:
   case MODE_DOT3_RGB_EXT:
   case MODE_DOT3_RGBA:
   case MODE_DOT3_RGBA_EXT:
   case MODE_MODULATE_ADD_ATI:
   case MODE_MODULATE_SIGNED_ADD_ATI:
   case MODE_MODULATE_SUBTRACT_ATI:
   case MODE_ADD_PRODUCTS:
   case MODE_ADD_PRODUCTS_SIGNED:
   case MODE_BUMP_ENVMAP_ATI:
      return GL_TRUE;
   default:
      assert(0);
      return GL_FALSE;
   }
}



/**
 * Translate TEXTURE_x_BIT to TEXTURE_x_INDEX.
 */
static GLuint translate_tex_src_bit( GLbitfield bit )
{
   ASSERT(bit);
   return _mesa_ffs(bit) - 1;
}


#define VERT_BIT_TEX_ANY    (0xff << VERT_ATTRIB_TEX0)
#define VERT_RESULT_TEX_ANY (0xff << VERT_RESULT_TEX0)

/**
 * Identify all possible varying inputs.  The fragment program will
 * never reference non-varying inputs, but will track them via state
 * constants instead.
 *
 * This function figures out all the inputs that the fragment program
 * has access to.  The bitmask is later reduced to just those which
 * are actually referenced.
 */
static GLbitfield get_fp_input_mask( struct gl_context *ctx )
{
   /* _NEW_PROGRAM */
   const GLboolean vertexShader =
      (ctx->Shader.CurrentVertexProgram &&
       ctx->Shader.CurrentVertexProgram->LinkStatus &&
       ctx->Shader.CurrentVertexProgram->VertexProgram);
   const GLboolean vertexProgram = ctx->VertexProgram._Enabled;
   GLbitfield fp_inputs = 0x0;

   if (ctx->VertexProgram._Overriden) {
      /* Somebody's messing with the vertex program and we don't have
       * a clue what's happening.  Assume that it could be producing
       * all possible outputs.
       */
      fp_inputs = ~0;
   }
   else if (ctx->RenderMode == GL_FEEDBACK) {
      /* _NEW_RENDERMODE */
      fp_inputs = (FRAG_BIT_COL0 | FRAG_BIT_TEX0);
   }
   else if (!(vertexProgram || vertexShader) ||
            !ctx->VertexProgram._Current) {
      /* Fixed function vertex logic */
      /* _NEW_ARRAY */
      GLbitfield varying_inputs = ctx->varying_vp_inputs;

      /* These get generated in the setup routine regardless of the
       * vertex program:
       */
      /* _NEW_POINT */
      if (ctx->Point.PointSprite)
         varying_inputs |= FRAG_BITS_TEX_ANY;

      /* First look at what values may be computed by the generated
       * vertex program:
       */
      /* _NEW_LIGHT */
      if (ctx->Light.Enabled) {
         fp_inputs |= FRAG_BIT_COL0;

         if (texenv_doing_secondary_color(ctx))
            fp_inputs |= FRAG_BIT_COL1;
      }

      /* _NEW_TEXTURE */
      fp_inputs |= (ctx->Texture._TexGenEnabled |
                    ctx->Texture._TexMatEnabled) << FRAG_ATTRIB_TEX0;

      /* Then look at what might be varying as a result of enabled
       * arrays, etc:
       */
      if (varying_inputs & VERT_BIT_COLOR0)
         fp_inputs |= FRAG_BIT_COL0;
      if (varying_inputs & VERT_BIT_COLOR1)
         fp_inputs |= FRAG_BIT_COL1;

      fp_inputs |= (((varying_inputs & VERT_BIT_TEX_ANY) >> VERT_ATTRIB_TEX0) 
                    << FRAG_ATTRIB_TEX0);

   }
   else {
      /* calculate from vp->outputs */
      struct gl_vertex_program *vprog;
      GLbitfield64 vp_outputs;

      /* Choose GLSL vertex shader over ARB vertex program.  Need this
       * since vertex shader state validation comes after fragment state
       * validation (see additional comments in state.c).
       */
      if (vertexShader)
         vprog = ctx->Shader.CurrentVertexProgram->VertexProgram;
      else
         vprog = ctx->VertexProgram.Current;

      vp_outputs = vprog->Base.OutputsWritten;

      /* These get generated in the setup routine regardless of the
       * vertex program:
       */
      /* _NEW_POINT */
      if (ctx->Point.PointSprite)
         vp_outputs |= FRAG_BITS_TEX_ANY;

      if (vp_outputs & (1 << VERT_RESULT_COL0))
         fp_inputs |= FRAG_BIT_COL0;
      if (vp_outputs & (1 << VERT_RESULT_COL1))
         fp_inputs |= FRAG_BIT_COL1;

      fp_inputs |= (((vp_outputs & VERT_RESULT_TEX_ANY) >> VERT_RESULT_TEX0) 
                    << FRAG_ATTRIB_TEX0);
   }
   
   return fp_inputs;
}


/**
 * Examine current texture environment state and generate a unique
 * key to identify it.
 */
static GLuint make_state_key( struct gl_context *ctx,  struct state_key *key )
{
   GLuint i, j;
   GLbitfield inputs_referenced = FRAG_BIT_COL0;
   const GLbitfield inputs_available = get_fp_input_mask( ctx );
   GLuint keySize;

   memset(key, 0, sizeof(*key));

   /* _NEW_TEXTURE */
   for (i = 0; i < ctx->Const.MaxTextureUnits; i++) {
      const struct gl_texture_unit *texUnit = &ctx->Texture.Unit[i];
      const struct gl_texture_object *texObj = texUnit->_Current;
      const struct gl_tex_env_combine_state *comb = texUnit->_CurrentCombine;
      GLenum format;

      if (!texUnit->_ReallyEnabled || !texUnit->Enabled)
         continue;

      format = texObj->Image[0][texObj->BaseLevel]->_BaseFormat;

      key->unit[i].enabled = 1;
      key->enabled_units |= (1<<i);
      key->nr_enabled_units = i + 1;
      inputs_referenced |= FRAG_BIT_TEX(i);

      key->unit[i].source_index =
         translate_tex_src_bit(texUnit->_ReallyEnabled);

      key->unit[i].shadow = ((texObj->CompareMode == GL_COMPARE_R_TO_TEXTURE) &&
                             ((format == GL_DEPTH_COMPONENT) || 
                              (format == GL_DEPTH_STENCIL_EXT)));

      key->unit[i].NumArgsRGB = comb->_NumArgsRGB;
      key->unit[i].NumArgsA = comb->_NumArgsA;

      key->unit[i].ModeRGB =
	 translate_mode(texUnit->EnvMode, comb->ModeRGB);
      key->unit[i].ModeA =
	 translate_mode(texUnit->EnvMode, comb->ModeA);

      key->unit[i].ScaleShiftRGB = comb->ScaleShiftRGB;
      key->unit[i].ScaleShiftA = comb->ScaleShiftA;

      for (j = 0; j < MAX_COMBINER_TERMS; j++) {
         key->unit[i].OptRGB[j].Operand = translate_operand(comb->OperandRGB[j]);
         key->unit[i].OptA[j].Operand = translate_operand(comb->OperandA[j]);
         key->unit[i].OptRGB[j].Source = translate_source(comb->SourceRGB[j]);
         key->unit[i].OptA[j].Source = translate_source(comb->SourceA[j]);
      }

      if (key->unit[i].ModeRGB == MODE_BUMP_ENVMAP_ATI) {
         /* requires some special translation */
         key->unit[i].NumArgsRGB = 2;
         key->unit[i].ScaleShiftRGB = 0;
         key->unit[i].OptRGB[0].Operand = OPR_SRC_COLOR;
         key->unit[i].OptRGB[0].Source = SRC_TEXTURE;
         key->unit[i].OptRGB[1].Operand = OPR_SRC_COLOR;
         key->unit[i].OptRGB[1].Source = texUnit->BumpTarget - GL_TEXTURE0 + SRC_TEXTURE0;
       }

      /* this is a back-door for enabling cylindrical texture wrap mode */
      if (texObj->Priority == 0.125)
         key->unit[i].texture_cyl_wrap = 1;
   }

   /* _NEW_LIGHT | _NEW_FOG */
   if (texenv_doing_secondary_color(ctx)) {
      key->separate_specular = 1;
      inputs_referenced |= FRAG_BIT_COL1;
   }

   /* _NEW_FOG */
   if (ctx->Fog.Enabled) {
      key->fog_enabled = 1;
      key->fog_mode = translate_fog_mode(ctx->Fog.Mode);
      inputs_referenced |= FRAG_BIT_FOGC; /* maybe */
   }

   /* _NEW_BUFFERS */
   key->num_draw_buffers = ctx->DrawBuffer->_NumColorDrawBuffers;

   key->inputs_available = (inputs_available & inputs_referenced);

   /* compute size of state key, ignoring unused texture units */
   keySize = sizeof(*key) - sizeof(key->unit)
      + key->nr_enabled_units * sizeof(key->unit[0]);

   return keySize;
}


/**
 * Use uregs to represent registers internally, translate to Mesa's
 * expected formats on emit.  
 *
 * NOTE: These are passed by value extensively in this file rather
 * than as usual by pointer reference.  If this disturbs you, try
 * remembering they are just 32bits in size.
 *
 * GCC is smart enough to deal with these dword-sized structures in
 * much the same way as if I had defined them as dwords and was using
 * macros to access and set the fields.  This is much nicer and easier
 * to evolve.
 */
struct ureg {
   GLuint file:4;
   GLuint idx:8;
   GLuint negatebase:1;
   GLuint swz:12;
   GLuint pad:7;
};

static const struct ureg undef = { 
   PROGRAM_UNDEFINED,
   ~0,
   0,
   0,
   0
};


/** State used to build the fragment program:
 */
struct texenv_fragment_program {
   struct gl_fragment_program *program;
   struct state_key *state;

   GLbitfield alu_temps;	/**< Track texture indirections, see spec. */
   GLbitfield temps_output;	/**< Track texture indirections, see spec. */
   GLbitfield temp_in_use;	/**< Tracks temporary regs which are in use. */
   GLboolean error;

   struct ureg src_texture[MAX_TEXTURE_COORD_UNITS];   
   /* Reg containing each texture unit's sampled texture color,
    * else undef.
    */

   struct ureg texcoord_tex[MAX_TEXTURE_COORD_UNITS];
   /* Reg containing texcoord for a texture unit,
    * needed for bump mapping, else undef.
    */

   struct ureg src_previous;	/**< Reg containing color from previous 
				 * stage.  May need to be decl'd.
				 */

   GLuint last_tex_stage;	/**< Number of last enabled texture unit */

   struct ureg half;
   struct ureg one;
   struct ureg zero;
};



static struct ureg make_ureg(GLuint file, GLuint idx)
{
   struct ureg reg;
   reg.file = file;
   reg.idx = idx;
   reg.negatebase = 0;
   reg.swz = SWIZZLE_NOOP;
   reg.pad = 0;
   return reg;
}

static struct ureg swizzle( struct ureg reg, int x, int y, int z, int w )
{
   reg.swz = MAKE_SWIZZLE4(GET_SWZ(reg.swz, x),
			   GET_SWZ(reg.swz, y),
			   GET_SWZ(reg.swz, z),
			   GET_SWZ(reg.swz, w));

   return reg;
}

static struct ureg swizzle1( struct ureg reg, int x )
{
   return swizzle(reg, x, x, x, x);
}

static struct ureg negate( struct ureg reg )
{
   reg.negatebase ^= 1;
   return reg;
}

static GLboolean is_undef( struct ureg reg )
{
   return reg.file == PROGRAM_UNDEFINED;
}


static struct ureg get_temp( struct texenv_fragment_program *p )
{
   GLint bit;
   
   /* First try and reuse temps which have been used already:
    */
   bit = _mesa_ffs( ~p->temp_in_use & p->alu_temps );

   /* Then any unused temporary:
    */
   if (!bit)
      bit = _mesa_ffs( ~p->temp_in_use );

   if (!bit) {
      _mesa_problem(NULL, "%s: out of temporaries\n", __FILE__);
      exit(1);
   }

   if ((GLuint) bit > p->program->Base.NumTemporaries)
      p->program->Base.NumTemporaries = bit;

   p->temp_in_use |= 1<<(bit-1);
   return make_ureg(PROGRAM_TEMPORARY, (bit-1));
}

static struct ureg get_tex_temp( struct texenv_fragment_program *p )
{
   int bit;
   
   /* First try to find available temp not previously used (to avoid
    * starting a new texture indirection).  According to the spec, the
    * ~p->temps_output isn't necessary, but will keep it there for
    * now:
    */
   bit = _mesa_ffs( ~p->temp_in_use & ~p->alu_temps & ~p->temps_output );

   /* Then any unused temporary:
    */
   if (!bit) 
      bit = _mesa_ffs( ~p->temp_in_use );

   if (!bit) {
      _mesa_problem(NULL, "%s: out of temporaries\n", __FILE__);
      exit(1);
   }

   if ((GLuint) bit > p->program->Base.NumTemporaries)
      p->program->Base.NumTemporaries = bit;

   p->temp_in_use |= 1<<(bit-1);
   return make_ureg(PROGRAM_TEMPORARY, (bit-1));
}


/** Mark a temp reg as being no longer allocatable. */
static void reserve_temp( struct texenv_fragment_program *p, struct ureg r )
{
   if (r.file == PROGRAM_TEMPORARY)
      p->temps_output |= (1 << r.idx);
}


static void release_temps(struct gl_context *ctx, struct texenv_fragment_program *p )
{
   GLuint max_temp = ctx->Const.FragmentProgram.MaxTemps;

   /* KW: To support tex_env_crossbar, don't release the registers in
    * temps_output.
    */
   if (max_temp >= sizeof(int) * 8)
      p->temp_in_use = p->temps_output;
   else
      p->temp_in_use = ~((1<<max_temp)-1) | p->temps_output;
}


static struct ureg register_param5( struct texenv_fragment_program *p, 
				    GLint s0,
				    GLint s1,
				    GLint s2,
				    GLint s3,
				    GLint s4)
{
   gl_state_index tokens[STATE_LENGTH];
   GLuint idx;
   tokens[0] = s0;
   tokens[1] = s1;
   tokens[2] = s2;
   tokens[3] = s3;
   tokens[4] = s4;
   idx = _mesa_add_state_reference( p->program->Base.Parameters, tokens );
   return make_ureg(PROGRAM_STATE_VAR, idx);
}


#define register_param1(p,s0)          register_param5(p,s0,0,0,0,0)
#define register_param2(p,s0,s1)       register_param5(p,s0,s1,0,0,0)
#define register_param3(p,s0,s1,s2)    register_param5(p,s0,s1,s2,0,0)
#define register_param4(p,s0,s1,s2,s3) register_param5(p,s0,s1,s2,s3,0)

static GLuint frag_to_vert_attrib( GLuint attrib )
{
   switch (attrib) {
   case FRAG_ATTRIB_COL0: return VERT_ATTRIB_COLOR0;
   case FRAG_ATTRIB_COL1: return VERT_ATTRIB_COLOR1;
   default:
      assert(attrib >= FRAG_ATTRIB_TEX0);
      assert(attrib <= FRAG_ATTRIB_TEX7);
      return attrib - FRAG_ATTRIB_TEX0 + VERT_ATTRIB_TEX0;
   }
}


static struct ureg register_input( struct texenv_fragment_program *p, GLuint input )
{
   if (p->state->inputs_available & (1<<input)) {
      p->program->Base.InputsRead |= (1 << input);
      return make_ureg(PROGRAM_INPUT, input);
   }
   else {
      GLuint idx = frag_to_vert_attrib( input );
      return register_param3( p, STATE_INTERNAL, STATE_CURRENT_ATTRIB, idx );
   }
}


static void emit_arg( struct prog_src_register *reg,
		      struct ureg ureg )
{
   reg->File = ureg.file;
   reg->Index = ureg.idx;
   reg->Swizzle = ureg.swz;
   reg->Negate = ureg.negatebase ? NEGATE_XYZW : NEGATE_NONE;
   reg->Abs = GL_FALSE;
}

static void emit_dst( struct prog_dst_register *dst,
		      struct ureg ureg, GLuint mask )
{
   dst->File = ureg.file;
   dst->Index = ureg.idx;
   dst->WriteMask = mask;
   dst->CondMask = COND_TR;  /* always pass cond test */
   dst->CondSwizzle = SWIZZLE_NOOP;
}

static struct prog_instruction *
emit_op(struct texenv_fragment_program *p,
	enum prog_opcode op,
	struct ureg dest,
	GLuint mask,
	GLboolean saturate,
	struct ureg src0,
	struct ureg src1,
	struct ureg src2 )
{
   const GLuint nr = p->program->Base.NumInstructions++;
   struct prog_instruction *inst = &p->program->Base.Instructions[nr];

   assert(nr < MAX_INSTRUCTIONS);

   _mesa_init_instructions(inst, 1);
   inst->Opcode = op;
   
   emit_arg( &inst->SrcReg[0], src0 );
   emit_arg( &inst->SrcReg[1], src1 );
   emit_arg( &inst->SrcReg[2], src2 );
   
   inst->SaturateMode = saturate ? SATURATE_ZERO_ONE : SATURATE_OFF;

   emit_dst( &inst->DstReg, dest, mask );

#if 0
   /* Accounting for indirection tracking:
    */
   if (dest.file == PROGRAM_TEMPORARY)
      p->temps_output |= 1 << dest.idx;
#endif

   return inst;
}
   

static struct ureg emit_arith( struct texenv_fragment_program *p,
			       enum prog_opcode op,
			       struct ureg dest,
			       GLuint mask,
			       GLboolean saturate,
			       struct ureg src0,
			       struct ureg src1,
			       struct ureg src2 )
{
   emit_op(p, op, dest, mask, saturate, src0, src1, src2);
   
   /* Accounting for indirection tracking:
    */
   if (src0.file == PROGRAM_TEMPORARY)
      p->alu_temps |= 1 << src0.idx;

   if (!is_undef(src1) && src1.file == PROGRAM_TEMPORARY)
      p->alu_temps |= 1 << src1.idx;

   if (!is_undef(src2) && src2.file == PROGRAM_TEMPORARY)
      p->alu_temps |= 1 << src2.idx;

   if (dest.file == PROGRAM_TEMPORARY)
      p->alu_temps |= 1 << dest.idx;
       
   p->program->Base.NumAluInstructions++;
   return dest;
}

static struct ureg emit_texld( struct texenv_fragment_program *p,
			       enum prog_opcode op,
			       struct ureg dest,
			       GLuint destmask,
			       GLuint tex_unit,
			       GLuint tex_idx,
                               GLuint tex_shadow,
			       struct ureg coord )
{
   struct prog_instruction *inst = emit_op( p, op, 
					  dest, destmask, 
					  GL_FALSE,	/* don't saturate? */
					  coord, 	/* arg 0? */
					  undef,
					  undef);
   
   inst->TexSrcTarget = tex_idx;
   inst->TexSrcUnit = tex_unit;
   inst->TexShadow = tex_shadow;

   p->program->Base.NumTexInstructions++;

   /* Accounting for indirection tracking:
    */
   reserve_temp(p, dest);

#if 0
   /* Is this a texture indirection?
    */
   if ((coord.file == PROGRAM_TEMPORARY &&
	(p->temps_output & (1<<coord.idx))) ||
       (dest.file == PROGRAM_TEMPORARY &&
	(p->alu_temps & (1<<dest.idx)))) {
      p->program->Base.NumTexIndirections++;
      p->temps_output = 1<<coord.idx;
      p->alu_temps = 0;
      assert(0);		/* KW: texture env crossbar */
   }
#endif

   return dest;
}


static struct ureg register_const4f( struct texenv_fragment_program *p, 
				     GLfloat s0,
				     GLfloat s1,
				     GLfloat s2,
				     GLfloat s3)
{
   GLfloat values[4];
   GLuint idx, swizzle;
   struct ureg r;
   values[0] = s0;
   values[1] = s1;
   values[2] = s2;
   values[3] = s3;
   idx = _mesa_add_unnamed_constant( p->program->Base.Parameters, values, 4,
                                     &swizzle );
   r = make_ureg(PROGRAM_CONSTANT, idx);
   r.swz = swizzle;
   return r;
}

#define register_scalar_const(p, s0)    register_const4f(p, s0, s0, s0, s0)
#define register_const1f(p, s0)         register_const4f(p, s0, 0, 0, 1)
#define register_const2f(p, s0, s1)     register_const4f(p, s0, s1, 0, 1)
#define register_const3f(p, s0, s1, s2) register_const4f(p, s0, s1, s2, 1)


static struct ureg get_one( struct texenv_fragment_program *p )
{
   if (is_undef(p->one)) 
      p->one = register_scalar_const(p, 1.0);
   return p->one;
}

static struct ureg get_half( struct texenv_fragment_program *p )
{
   if (is_undef(p->half)) 
      p->half = register_scalar_const(p, 0.5);
   return p->half;
}

static struct ureg get_zero( struct texenv_fragment_program *p )
{
   if (is_undef(p->zero)) 
      p->zero = register_scalar_const(p, 0.0);
   return p->zero;
}


static void program_error( struct texenv_fragment_program *p, const char *msg )
{
   _mesa_problem(NULL, "%s", msg);
   p->error = 1;
}

static struct ureg get_source( struct texenv_fragment_program *p, 
			       GLuint src, GLuint unit )
{
   switch (src) {
   case SRC_TEXTURE: 
      assert(!is_undef(p->src_texture[unit]));
      return p->src_texture[unit];

   case SRC_TEXTURE0:
   case SRC_TEXTURE1:
   case SRC_TEXTURE2:
   case SRC_TEXTURE3:
   case SRC_TEXTURE4:
   case SRC_TEXTURE5:
   case SRC_TEXTURE6:
   case SRC_TEXTURE7: 
      assert(!is_undef(p->src_texture[src - SRC_TEXTURE0]));
      return p->src_texture[src - SRC_TEXTURE0];

   case SRC_CONSTANT:
      return register_param2(p, STATE_TEXENV_COLOR, unit);

   case SRC_PRIMARY_COLOR:
      return register_input(p, FRAG_ATTRIB_COL0);

   case SRC_ZERO:
      return get_zero(p);

   case SRC_PREVIOUS:
      if (is_undef(p->src_previous))
	 return register_input(p, FRAG_ATTRIB_COL0);
      else
	 return p->src_previous;

   default:
      assert(0);
      return undef;
   }
}

static struct ureg emit_combine_source( struct texenv_fragment_program *p, 
					GLuint mask,
					GLuint unit,
					GLuint source, 
					GLuint operand )
{
   struct ureg arg, src, one;

   src = get_source(p, source, unit);

   switch (operand) {
   case OPR_ONE_MINUS_SRC_COLOR: 
      /* Get unused tmp,
       * Emit tmp = 1.0 - arg.xyzw
       */
      arg = get_temp( p );
      one = get_one( p );
      return emit_arith( p, OPCODE_SUB, arg, mask, 0, one, src, undef);

   case OPR_SRC_ALPHA: 
      if (mask == WRITEMASK_W)
	 return src;
      else
	 return swizzle1( src, SWIZZLE_W );
   case OPR_ONE_MINUS_SRC_ALPHA: 
      /* Get unused tmp,
       * Emit tmp = 1.0 - arg.wwww
       */
      arg = get_temp(p);
      one = get_one(p);
      return emit_arith(p, OPCODE_SUB, arg, mask, 0,
			one, swizzle1(src, SWIZZLE_W), undef);
   case OPR_ZERO:
      return get_zero(p);
   case OPR_ONE:
      return get_one(p);
   case OPR_SRC_COLOR: 
      return src;
   default:
      assert(0);
      return src;
   }
}

/**
 * Check if the RGB and Alpha sources and operands match for the given
 * texture unit's combinder state.  When the RGB and A sources and
 * operands match, we can emit fewer instructions.
 */
static GLboolean args_match( const struct state_key *key, GLuint unit )
{
   GLuint i, numArgs = key->unit[unit].NumArgsRGB;

   for (i = 0; i < numArgs; i++) {
      if (key->unit[unit].OptA[i].Source != key->unit[unit].OptRGB[i].Source) 
	 return GL_FALSE;

      switch (key->unit[unit].OptA[i].Operand) {
      case OPR_SRC_ALPHA: 
	 switch (key->unit[unit].OptRGB[i].Operand) {
	 case OPR_SRC_COLOR: 
	 case OPR_SRC_ALPHA: 
	    break;
	 default:
	    return GL_FALSE;
	 }
	 break;
      case OPR_ONE_MINUS_SRC_ALPHA: 
	 switch (key->unit[unit].OptRGB[i].Operand) {
	 case OPR_ONE_MINUS_SRC_COLOR: 
	 case OPR_ONE_MINUS_SRC_ALPHA: 
	    break;
	 default:
	    return GL_FALSE;
	 }
	 break;
      default: 
	 return GL_FALSE;	/* impossible */
      }
   }

   return GL_TRUE;
}

static struct ureg emit_combine( struct texenv_fragment_program *p,
				 struct ureg dest,
				 GLuint mask,
				 GLboolean saturate,
				 GLuint unit,
				 GLuint nr,
				 GLuint mode,
				 const struct mode_opt *opt)
{
   struct ureg src[MAX_COMBINER_TERMS];
   struct ureg tmp, half;
   GLuint i;

   assert(nr <= MAX_COMBINER_TERMS);

   for (i = 0; i < nr; i++)
      src[i] = emit_combine_source( p, mask, unit, opt[i].Source, opt[i].Operand );

   switch (mode) {
   case MODE_REPLACE: 
      if (mask == WRITEMASK_XYZW && !saturate)
	 return src[0];
      else
	 return emit_arith( p, OPCODE_MOV, dest, mask, saturate, src[0], undef, undef );
   case MODE_MODULATE: 
      return emit_arith( p, OPCODE_MUL, dest, mask, saturate,
			 src[0], src[1], undef );
   case MODE_ADD: 
      return emit_arith( p, OPCODE_ADD, dest, mask, saturate, 
			 src[0], src[1], undef );
   case MODE_ADD_SIGNED:
      /* tmp = arg0 + arg1
       * result = tmp - .5
       */
      half = get_half(p);
      tmp = get_temp( p );
      emit_arith( p, OPCODE_ADD, tmp, mask, 0, src[0], src[1], undef );
      emit_arith( p, OPCODE_SUB, dest, mask, saturate, tmp, half, undef );
      return dest;
   case MODE_INTERPOLATE: 
      /* Arg0 * (Arg2) + Arg1 * (1-Arg2) -- note arguments are reordered:
       */
      return emit_arith( p, OPCODE_LRP, dest, mask, saturate, src[2], src[0], src[1] );

   case MODE_SUBTRACT: 
      return emit_arith( p, OPCODE_SUB, dest, mask, saturate, src[0], src[1], undef );

   case MODE_DOT3_RGBA:
   case MODE_DOT3_RGBA_EXT: 
   case MODE_DOT3_RGB_EXT:
   case MODE_DOT3_RGB: {
      struct ureg tmp0 = get_temp( p );
      struct ureg tmp1 = get_temp( p );
      struct ureg neg1 = register_scalar_const(p, -1);
      struct ureg two  = register_scalar_const(p, 2);

      /* tmp0 = 2*src0 - 1
       * tmp1 = 2*src1 - 1
       *
       * dst = tmp0 dot3 tmp1 
       */
      emit_arith( p, OPCODE_MAD, tmp0, WRITEMASK_XYZW, 0, 
		  two, src[0], neg1);

      if (memcmp(&src[0], &src[1], sizeof(struct ureg)) == 0)
	 tmp1 = tmp0;
      else
	 emit_arith( p, OPCODE_MAD, tmp1, WRITEMASK_XYZW, 0, 
		     two, src[1], neg1);
      emit_arith( p, OPCODE_DP3, dest, mask, saturate, tmp0, tmp1, undef);
      return dest;
   }
   case MODE_MODULATE_ADD_ATI:
      /* Arg0 * Arg2 + Arg1 */
      return emit_arith( p, OPCODE_MAD, dest, mask, saturate,
			 src[0], src[2], src[1] );
   case MODE_MODULATE_SIGNED_ADD_ATI: {
      /* Arg0 * Arg2 + Arg1 - 0.5 */
      struct ureg tmp0 = get_temp(p);
      half = get_half(p);
      emit_arith( p, OPCODE_MAD, tmp0, mask, 0, src[0], src[2], src[1] );
      emit_arith( p, OPCODE_SUB, dest, mask, saturate, tmp0, half, undef );
      return dest;
   }
   case MODE_MODULATE_SUBTRACT_ATI:
      /* Arg0 * Arg2 - Arg1 */
      emit_arith( p, OPCODE_MAD, dest, mask, 0, src[0], src[2], negate(src[1]) );
      return dest;
   case MODE_ADD_PRODUCTS:
      /* Arg0 * Arg1 + Arg2 * Arg3 */
      {
         struct ureg tmp0 = get_temp(p);
         emit_arith( p, OPCODE_MUL, tmp0, mask, 0, src[0], src[1], undef );
         emit_arith( p, OPCODE_MAD, dest, mask, saturate, src[2], src[3], tmp0 );
      }
      return dest;
   case MODE_ADD_PRODUCTS_SIGNED:
      /* Arg0 * Arg1 + Arg2 * Arg3 - 0.5 */
      {
         struct ureg tmp0 = get_temp(p);
         half = get_half(p);
         emit_arith( p, OPCODE_MUL, tmp0, mask, 0, src[0], src[1], undef );
         emit_arith( p, OPCODE_MAD, tmp0, mask, 0, src[2], src[3], tmp0 );
         emit_arith( p, OPCODE_SUB, dest, mask, saturate, tmp0, half, undef );
      }
      return dest;
   case MODE_BUMP_ENVMAP_ATI:
      /* special - not handled here */
      assert(0);
      return src[0];
   default: 
      assert(0);
      return src[0];
   }
}


/**
 * Generate instructions for one texture unit's env/combiner mode.
 */
static struct ureg
emit_texenv(struct texenv_fragment_program *p, GLuint unit)
{
   const struct state_key *key = p->state;
   GLboolean rgb_saturate, alpha_saturate;
   GLuint rgb_shift, alpha_shift;
   struct ureg out, dest;

   if (!key->unit[unit].enabled) {
      return get_source(p, SRC_PREVIOUS, 0);
   }
   if (key->unit[unit].ModeRGB == MODE_BUMP_ENVMAP_ATI) {
      /* this isn't really a env stage delivering a color and handled elsewhere */
      return get_source(p, SRC_PREVIOUS, 0);
   }
   
   switch (key->unit[unit].ModeRGB) {
   case MODE_DOT3_RGB_EXT:
      alpha_shift = key->unit[unit].ScaleShiftA;
      rgb_shift = 0;
      break;
   case MODE_DOT3_RGBA_EXT:
      alpha_shift = 0;
      rgb_shift = 0;
      break;
   default:
      rgb_shift = key->unit[unit].ScaleShiftRGB;
      alpha_shift = key->unit[unit].ScaleShiftA;
      break;
   }
   
   /* If we'll do rgb/alpha shifting don't saturate in emit_combine().
    * We don't want to clamp twice.
    */
   if (rgb_shift)
      rgb_saturate = GL_FALSE;  /* saturate after rgb shift */
   else if (need_saturate(key->unit[unit].ModeRGB))
      rgb_saturate = GL_TRUE;
   else
      rgb_saturate = GL_FALSE;

   if (alpha_shift)
      alpha_saturate = GL_FALSE;  /* saturate after alpha shift */
   else if (need_saturate(key->unit[unit].ModeA))
      alpha_saturate = GL_TRUE;
   else
      alpha_saturate = GL_FALSE;

   /* If this is the very last calculation (and various other conditions
    * are met), emit directly to the color output register.  Otherwise,
    * emit to a temporary register.
    */
   if (key->separate_specular ||
       unit != p->last_tex_stage ||
       alpha_shift ||
       key->num_draw_buffers != 1 ||
       rgb_shift)
      dest = get_temp( p );
   else
      dest = make_ureg(PROGRAM_OUTPUT, FRAG_RESULT_COLOR);

   /* Emit the RGB and A combine ops
    */
   if (key->unit[unit].ModeRGB == key->unit[unit].ModeA &&
       args_match(key, unit)) {
      out = emit_combine( p, dest, WRITEMASK_XYZW, rgb_saturate,
			  unit,
			  key->unit[unit].NumArgsRGB,
			  key->unit[unit].ModeRGB,
			  key->unit[unit].OptRGB);
   }
   else if (key->unit[unit].ModeRGB == MODE_DOT3_RGBA_EXT ||
	    key->unit[unit].ModeRGB == MODE_DOT3_RGBA) {
      out = emit_combine( p, dest, WRITEMASK_XYZW, rgb_saturate,
			  unit,
			  key->unit[unit].NumArgsRGB,
			  key->unit[unit].ModeRGB,
			  key->unit[unit].OptRGB);
   }
   else {
      /* Need to do something to stop from re-emitting identical
       * argument calculations here:
       */
      out = emit_combine( p, dest, WRITEMASK_XYZ, rgb_saturate,
			  unit,
			  key->unit[unit].NumArgsRGB,
			  key->unit[unit].ModeRGB,
			  key->unit[unit].OptRGB);
      out = emit_combine( p, dest, WRITEMASK_W, alpha_saturate,
			  unit,
			  key->unit[unit].NumArgsA,
			  key->unit[unit].ModeA,
			  key->unit[unit].OptA);
   }

   /* Deal with the final shift:
    */
   if (alpha_shift || rgb_shift) {
      struct ureg shift;
      GLboolean saturate = GL_TRUE;  /* always saturate at this point */

      if (rgb_shift == alpha_shift) {
	 shift = register_scalar_const(p, (GLfloat)(1<<rgb_shift));
      }
      else {
	 shift = register_const4f(p, 
				  (GLfloat)(1<<rgb_shift),
				  (GLfloat)(1<<rgb_shift),
				  (GLfloat)(1<<rgb_shift),
				  (GLfloat)(1<<alpha_shift));
      }
      return emit_arith( p, OPCODE_MUL, dest, WRITEMASK_XYZW, 
			 saturate, out, shift, undef );
   }
   else
      return out;
}


/**
 * Generate instruction for getting a texture source term.
 */
static void load_texture( struct texenv_fragment_program *p, GLuint unit )
{
   if (is_undef(p->src_texture[unit])) {
      const GLuint texTarget = p->state->unit[unit].source_index;
      struct ureg texcoord;
      struct ureg tmp = get_tex_temp( p );

      if (is_undef(p->texcoord_tex[unit])) {
         texcoord = register_input(p, FRAG_ATTRIB_TEX0+unit);
      }
      else {
         /* might want to reuse this reg for tex output actually */
         texcoord = p->texcoord_tex[unit];
      }

      /* TODO: Use D0_MASK_XY where possible.
       */
      if (p->state->unit[unit].enabled) {
         GLboolean shadow = GL_FALSE;

	 if (p->state->unit[unit].shadow) {
	    p->program->Base.ShadowSamplers |= 1 << unit;
            shadow = GL_TRUE;
         }

	 p->src_texture[unit] = emit_texld( p, OPCODE_TXP,
					    tmp, WRITEMASK_XYZW, 
					    unit, texTarget, shadow,
                                            texcoord );

         p->program->Base.SamplersUsed |= (1 << unit);
         /* This identity mapping should already be in place
          * (see _mesa_init_program_struct()) but let's be safe.
          */
         p->program->Base.SamplerUnits[unit] = unit;
      }
      else
	 p->src_texture[unit] = get_zero(p);

      if (p->state->unit[unit].texture_cyl_wrap) {
         /* set flag which is checked by Mesa->Gallium program translation */
         p->program->Base.InputFlags[0] |= PROG_PARAM_BIT_CYL_WRAP;
      }

   }
}

static GLboolean load_texenv_source( struct texenv_fragment_program *p, 
				     GLuint src, GLuint unit )
{
   switch (src) {
   case SRC_TEXTURE:
      load_texture(p, unit);
      break;

   case SRC_TEXTURE0:
   case SRC_TEXTURE1:
   case SRC_TEXTURE2:
   case SRC_TEXTURE3:
   case SRC_TEXTURE4:
   case SRC_TEXTURE5:
   case SRC_TEXTURE6:
   case SRC_TEXTURE7:       
      load_texture(p, src - SRC_TEXTURE0);
      break;
      
   default:
      /* not a texture src - do nothing */
      break;
   }
 
   return GL_TRUE;
}


/**
 * Generate instructions for loading all texture source terms.
 */
static GLboolean
load_texunit_sources( struct texenv_fragment_program *p, GLuint unit )
{
   const struct state_key *key = p->state;
   GLuint i;

   for (i = 0; i < key->unit[unit].NumArgsRGB; i++) {
      load_texenv_source( p, key->unit[unit].OptRGB[i].Source, unit );
   }

   for (i = 0; i < key->unit[unit].NumArgsA; i++) {
      load_texenv_source( p, key->unit[unit].OptA[i].Source, unit );
   }

   return GL_TRUE;
}

/**
 * Generate instructions for loading bump map textures.
 */
static GLboolean
load_texunit_bumpmap( struct texenv_fragment_program *p, GLuint unit )
{
   const struct state_key *key = p->state;
   GLuint bumpedUnitNr = key->unit[unit].OptRGB[1].Source - SRC_TEXTURE0;
   struct ureg texcDst, bumpMapRes;
   struct ureg constdudvcolor = register_const4f(p, 0.0, 0.0, 0.0, 1.0);
   struct ureg texcSrc = register_input(p, FRAG_ATTRIB_TEX0 + bumpedUnitNr);
   struct ureg rotMat0 = register_param3( p, STATE_INTERNAL, STATE_ROT_MATRIX_0, unit );
   struct ureg rotMat1 = register_param3( p, STATE_INTERNAL, STATE_ROT_MATRIX_1, unit );

   load_texenv_source( p, unit + SRC_TEXTURE0, unit );

   bumpMapRes = get_source(p, key->unit[unit].OptRGB[0].Source, unit);
   texcDst = get_tex_temp( p );
   p->texcoord_tex[bumpedUnitNr] = texcDst;

   /* Apply rot matrix and add coords to be available in next phase.
    * dest = (Arg0.xxxx * rotMat0 + Arg1) + (Arg0.yyyy * rotMat1)
    * note only 2 coords are affected the rest are left unchanged (mul by 0)
    */
   emit_arith( p, OPCODE_MAD, texcDst, WRITEMASK_XYZW, 0,
               swizzle1(bumpMapRes, SWIZZLE_X), rotMat0, texcSrc );
   emit_arith( p, OPCODE_MAD, texcDst, WRITEMASK_XYZW, 0,
               swizzle1(bumpMapRes, SWIZZLE_Y), rotMat1, texcDst );

   /* Move 0,0,0,1 into bumpmap src if someone (crossbar) is foolish
    * enough to access this later, should optimize away.
    */
   emit_arith( p, OPCODE_MOV, bumpMapRes, WRITEMASK_XYZW, 0,
               constdudvcolor, undef, undef );

   return GL_TRUE;
}

/**
 * Generate a new fragment program which implements the context's
 * current texture env/combine mode.
 */
static void
create_new_program(struct gl_context *ctx, struct state_key *key,
                   struct gl_fragment_program *program)
{
   struct prog_instruction instBuffer[MAX_INSTRUCTIONS];
   struct texenv_fragment_program p;
   GLuint unit;
   struct ureg cf, out;
   int i;

   memset(&p, 0, sizeof(p));
   p.state = key;
   p.program = program;

   /* During code generation, use locally-allocated instruction buffer,
    * then alloc dynamic storage below.
    */
   p.program->Base.Instructions = instBuffer;
   p.program->Base.Target = GL_FRAGMENT_PROGRAM_ARB;
   p.program->Base.String = NULL;
   p.program->Base.NumTexIndirections = 1; /* is this right? */
   p.program->Base.NumTexInstructions = 0;
   p.program->Base.NumAluInstructions = 0;
   p.program->Base.NumInstructions = 0;
   p.program->Base.NumTemporaries = 0;
   p.program->Base.NumParameters = 0;
   p.program->Base.NumAttributes = 0;
   p.program->Base.NumAddressRegs = 0;
   p.program->Base.Parameters = _mesa_new_parameter_list();
   p.program->Base.InputsRead = 0x0;

   if (key->num_draw_buffers == 1)
      p.program->Base.OutputsWritten = 1 << FRAG_RESULT_COLOR;
   else {
      for (i = 0; i < key->num_draw_buffers; i++)
	 p.program->Base.OutputsWritten |= (1 << (FRAG_RESULT_DATA0 + i));
   }

   for (unit = 0; unit < ctx->Const.MaxTextureUnits; unit++) {
      p.src_texture[unit] = undef;
      p.texcoord_tex[unit] = undef;
   }

   p.src_previous = undef;
   p.half = undef;
   p.zero = undef;
   p.one = undef;

   p.last_tex_stage = 0;
   release_temps(ctx, &p);

   if (key->enabled_units && key->num_draw_buffers) {
      GLboolean needbumpstage = GL_FALSE;

      /* Zeroth pass - bump map textures first */
      for (unit = 0; unit < key->nr_enabled_units; unit++)
	 if (key->unit[unit].enabled &&
             key->unit[unit].ModeRGB == MODE_BUMP_ENVMAP_ATI) {
	    needbumpstage = GL_TRUE;
	    load_texunit_bumpmap( &p, unit );
	 }
      if (needbumpstage)
	 p.program->Base.NumTexIndirections++;

      /* First pass - to support texture_env_crossbar, first identify
       * all referenced texture sources and emit texld instructions
       * for each:
       */
      for (unit = 0; unit < key->nr_enabled_units; unit++)
	 if (key->unit[unit].enabled) {
	    load_texunit_sources( &p, unit );
	    p.last_tex_stage = unit;
	 }

      /* Second pass - emit combine instructions to build final color:
       */
      for (unit = 0; unit < key->nr_enabled_units; unit++)
	 if (key->unit[unit].enabled) {
	    p.src_previous = emit_texenv( &p, unit );
            reserve_temp(&p, p.src_previous); /* don't re-use this temp reg */
	    release_temps(ctx, &p);	/* release all temps */
	 }
   }

   cf = get_source( &p, SRC_PREVIOUS, 0 );

   for (i = 0; i < key->num_draw_buffers; i++) {
      if (key->num_draw_buffers == 1)
	 out = make_ureg( PROGRAM_OUTPUT, FRAG_RESULT_COLOR );
      else {
	 out = make_ureg( PROGRAM_OUTPUT, FRAG_RESULT_DATA0 + i );
      }

      if (key->separate_specular) {
	 /* Emit specular add.
	  */
	 struct ureg s = register_input(&p, FRAG_ATTRIB_COL1);
	 emit_arith( &p, OPCODE_ADD, out, WRITEMASK_XYZ, 0, cf, s, undef );
	 emit_arith( &p, OPCODE_MOV, out, WRITEMASK_W, 0, cf, undef, undef );
      }
      else if (memcmp(&cf, &out, sizeof(cf)) != 0) {
	 /* Will wind up in here if no texture enabled or a couple of
	  * other scenarios (GL_REPLACE for instance).
	  */
	 emit_arith( &p, OPCODE_MOV, out, WRITEMASK_XYZW, 0, cf, undef, undef );
      }
   }
   /* Finish up:
    */
   emit_arith( &p, OPCODE_END, undef, WRITEMASK_XYZW, 0, undef, undef, undef);

   if (key->fog_enabled) {
      /* Pull fog mode from struct gl_context, the value in the state key is
       * a reduced value and not what is expected in FogOption
       */
      p.program->FogOption = ctx->Fog.Mode;
      p.program->Base.InputsRead |= FRAG_BIT_FOGC;
   }
   else {
      p.program->FogOption = GL_NONE;
   }

   if (p.program->Base.NumTexIndirections > ctx->Const.FragmentProgram.MaxTexIndirections) 
      program_error(&p, "Exceeded max nr indirect texture lookups");

   if (p.program->Base.NumTexInstructions > ctx->Const.FragmentProgram.MaxTexInstructions)
      program_error(&p, "Exceeded max TEX instructions");

   if (p.program->Base.NumAluInstructions > ctx->Const.FragmentProgram.MaxAluInstructions)
      program_error(&p, "Exceeded max ALU instructions");

   ASSERT(p.program->Base.NumInstructions <= MAX_INSTRUCTIONS);

   /* Allocate final instruction array */
   p.program->Base.Instructions
      = _mesa_alloc_instructions(p.program->Base.NumInstructions);
   if (!p.program->Base.Instructions) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY,
                  "generating tex env program");
      return;
   }
   _mesa_copy_instructions(p.program->Base.Instructions, instBuffer,
                           p.program->Base.NumInstructions);

   if (key->num_draw_buffers && p.program->FogOption) {
      _mesa_append_fog_code(ctx, p.program);
      p.program->FogOption = GL_NONE;
   }


   /* Notify driver the fragment program has (actually) changed.
    */
   if (ctx->Driver.ProgramStringNotify) {
      GLboolean ok = ctx->Driver.ProgramStringNotify(ctx,
                                                     GL_FRAGMENT_PROGRAM_ARB, 
                                                     &p.program->Base);
      /* Driver should be able to handle any texenv programs as long as
       * the driver correctly reported max number of texture units correctly,
       * etc.
       */
      ASSERT(ok);
      (void) ok; /* silence unused var warning */
   }

   if (DISASSEM) {
      _mesa_print_program(&p.program->Base);
      printf("\n");
   }
}


/**
 * Return a fragment program which implements the current
 * fixed-function texture, fog and color-sum operations.
 */
struct gl_fragment_program *
_mesa_get_fixed_func_fragment_program(struct gl_context *ctx)
{
   struct gl_fragment_program *prog;
   struct state_key key;
   GLuint keySize;
	
   keySize = make_state_key(ctx, &key);
      
   prog = (struct gl_fragment_program *)
      _mesa_search_program_cache(ctx->FragmentProgram.Cache,
                                 &key, keySize);

   if (!prog) {
      prog = (struct gl_fragment_program *) 
         ctx->Driver.NewProgram(ctx, GL_FRAGMENT_PROGRAM_ARB, 0);

      create_new_program(ctx, &key, prog);

      _mesa_program_cache_insert(ctx, ctx->FragmentProgram.Cache,
                                 &key, keySize, &prog->Base);
   }

   return prog;
}
@


1.7
log
@Merge Mesa 7.10.3
@
text
@@


1.6
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d31 7
a37 7
#include "shader/program.h"
#include "shader/prog_parameter.h"
#include "shader/prog_cache.h"
#include "shader/prog_instruction.h"
#include "shader/prog_print.h"
#include "shader/prog_statevars.h"
#include "shader/programopt.h"
d65 1
a65 1
texenv_doing_secondary_color(GLcontext *ctx)
d101 1
d310 1
a310 1
static GLbitfield get_fp_input_mask( GLcontext *ctx )
d313 4
a316 3
   const GLboolean vertexShader = (ctx->Shader.CurrentProgram &&
				   ctx->Shader.CurrentProgram->LinkStatus &&
                                   ctx->Shader.CurrentProgram->VertexProgram);
d381 1
a381 1
         vprog = ctx->Shader.CurrentProgram->VertexProgram;
d411 1
a411 1
static GLuint make_state_key( GLcontext *ctx,  struct state_key *key )
d490 3
d667 1
a667 1
static void release_temps(GLcontext *ctx, struct texenv_fragment_program *p )
d911 1
a911 1
   _mesa_problem(NULL, msg);
d1207 3
a1209 1
   /* If this is the very last calculation, emit direct to output reg:
d1214 1
d1419 1
a1419 1
create_new_program(GLcontext *ctx, struct state_key *key,
d1449 1
a1449 1
   if (ctx->DrawBuffer->_NumColorDrawBuffers == 1)
d1452 1
a1452 1
      for (i = 0; i < ctx->DrawBuffer->_NumColorDrawBuffers; i++)
d1469 1
a1469 1
   if (key->enabled_units) {
d1504 2
a1505 2
   for (i = 0; i < ctx->DrawBuffer->_NumColorDrawBuffers; i++) {
      if (ctx->DrawBuffer->_NumColorDrawBuffers == 1)
d1530 1
a1530 1
      /* Pull fog mode from GLcontext, the value in the state key is
d1562 1
a1562 1
   if (p.program->FogOption) {
d1594 1
a1594 1
_mesa_get_fixed_func_fragment_program(GLcontext *ctx)
@


1.5
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d5 1
d30 1
a30 2
#include "macros.h"
#include "enums.h"
d64 12
d78 1
a78 3
 * This MAX is probably a bit generous, but that's OK.  There can be
 * up to four instructions per texture unit (TEX + 3 for combine),
 * then there's fog and specular add.
d80 1
a80 1
#define MAX_INSTRUCTIONS ((MAX_TEXTURE_COORD_UNITS * 4) + 12)
d85 7
a91 2
   GLuint Source:4;
   GLuint Operand:3;
d95 2
a96 1
   GLbitfield enabled_units;
d99 2
a100 1
   GLuint fog_mode:2;
d102 1
d105 1
a105 1
      GLuint source_index:3;   /* one of TEXTURE_1D/2D/3D/CUBE/RECT_INDEX */
d110 11
a120 8
      GLuint NumArgsRGB:2;
      GLuint ModeRGB:4;
      struct mode_opt OptRGB[3];

      GLuint NumArgsA:2;
      GLuint ModeA:4;
      struct mode_opt OptA[3];
   } unit[8];
d155 3
a157 1
   default:	return OPR_UNKNOWN;
d173 1
d191 5
a195 1
   default: return SRC_UNKNOWN;
d199 17
a215 14
#define MODE_REPLACE       0
#define MODE_MODULATE      1
#define MODE_ADD           2
#define MODE_ADD_SIGNED    3
#define MODE_INTERPOLATE   4
#define MODE_SUBTRACT      5
#define MODE_DOT3_RGB      6
#define MODE_DOT3_RGB_EXT  7
#define MODE_DOT3_RGBA     8
#define MODE_DOT3_RGBA_EXT 9
#define MODE_MODULATE_ADD_ATI           10
#define MODE_MODULATE_SIGNED_ADD_ATI    11
#define MODE_MODULATE_SUBTRACT_ATI      12
#define MODE_UNKNOWN       15
d217 4
a220 1
static GLuint translate_mode( GLenum mode )
d225 10
a234 2
   case GL_ADD: return MODE_ADD;
   case GL_ADD_SIGNED: return MODE_ADD_SIGNED;
d244 38
a281 1
   default: return MODE_UNKNOWN;
d285 5
a289 1
#define TEXTURE_UNKNOWN_INDEX 7
d292 32
a323 7
   switch (bit) {
   case TEXTURE_1D_BIT:   return TEXTURE_1D_INDEX;
   case TEXTURE_2D_BIT:   return TEXTURE_2D_INDEX;
   case TEXTURE_RECT_BIT: return TEXTURE_RECT_INDEX;
   case TEXTURE_3D_BIT:   return TEXTURE_3D_INDEX;
   case TEXTURE_CUBE_BIT: return TEXTURE_CUBE_INDEX;
   default: return TEXTURE_UNKNOWN_INDEX;
d325 77
d404 1
d409 1
a409 1
static void make_state_key( GLcontext *ctx,  struct state_key *key )
d412 4
a415 1
	
d418 1
d421 2
d428 1
a428 1
      format = texUnit->_Current->Image[0][texUnit->_Current->BaseLevel]->_BaseFormat;
d432 5
d438 1
a438 3
      key->unit[i].source_index = 
	 translate_tex_src_bit(texUnit->_ReallyEnabled);		
      key->unit[i].shadow = ((texUnit->_Current->CompareMode == GL_COMPARE_R_TO_TEXTURE) && 
d442 2
a443 2
      key->unit[i].NumArgsRGB = texUnit->_CurrentCombine->_NumArgsRGB;
      key->unit[i].NumArgsA = texUnit->_CurrentCombine->_NumArgsA;
d446 1
a446 1
	 translate_mode(texUnit->_CurrentCombine->ModeRGB);
d448 10
a457 14
	 translate_mode(texUnit->_CurrentCombine->ModeA);
		
      key->unit[i].ScaleShiftRGB = texUnit->_CurrentCombine->ScaleShiftRGB;
      key->unit[i].ScaleShiftA = texUnit->_CurrentCombine->ScaleShiftA;

      for (j=0;j<3;j++) {
         key->unit[i].OptRGB[j].Operand =
	    translate_operand(texUnit->_CurrentCombine->OperandRGB[j]);
         key->unit[i].OptA[j].Operand =
	    translate_operand(texUnit->_CurrentCombine->OperandA[j]);
         key->unit[i].OptRGB[j].Source =
	    translate_source(texUnit->_CurrentCombine->SourceRGB[j]);
         key->unit[i].OptA[j].Source =
	    translate_source(texUnit->_CurrentCombine->SourceA[j]);
d459 14
d474 3
a476 2
	
   if (ctx->_TriangleCaps & DD_SEPARATE_SPECULAR)
d478 2
d481 1
d485 1
d487 8
d497 3
a499 1
/* Use uregs to represent registers internally, translate to Mesa's
a514 2
   GLuint abs:1;
   GLuint negateabs:1;
d516 1
a516 1
   GLuint pad:5;
a523 2
   0,
   0,
d528 1
a528 1
/* State used to build the fragment program:
a531 1
   GLcontext *ctx;
d534 3
a536 3
   GLbitfield alu_temps;	/* Track texture indirections, see spec. */
   GLbitfield temps_output;	/* Track texture indirections, see spec. */
   GLbitfield temp_in_use;	/* Tracks temporary regs which are in use. */
d544 6
a549 1
   struct ureg src_previous;	/* Reg containing color from previous 
d553 1
a553 1
   GLuint last_tex_stage;	/* Number of last enabled texture unit */
a567 2
   reg.abs = 0;
   reg.negateabs = 0;
d615 1
a615 1
      _mesa_exit(1);
d629 1
a629 1
   /* First try to find availble temp not previously used (to avoid
d643 1
a643 1
      _mesa_exit(1);
d654 8
d700 12
d715 8
a722 2
   p->program->Base.InputsRead |= (1 << input);
   return make_ureg(PROGRAM_INPUT, input);
d732 2
a733 3
   reg->NegateBase = ureg.negatebase ? 0xf : 0x0;
   reg->Abs = ureg.abs;
   reg->NegateAbs = ureg.negateabs;
d756 1
a756 1
   GLuint nr = p->program->Base.NumInstructions++;
d772 1
d777 1
d818 1
d830 1
d834 5
d850 1
d864 1
d871 3
a873 2
   ASSERT(swizzle == SWIZZLE_NOOP);
   return make_ureg(PROGRAM_CONSTANT, idx);
d935 3
a938 1
   default:
d943 4
d987 1
d989 1
d994 6
a999 1
static GLboolean args_match( struct state_key *key, GLuint unit )
d1001 1
a1001 1
   GLuint i, nr = key->unit[unit].NumArgsRGB;
d1003 1
a1003 1
   for (i = 0 ; i < nr ; i++) {
d1007 1
a1007 1
      switch(key->unit[unit].OptA[i].Operand) {
d1009 1
a1009 1
	 switch(key->unit[unit].OptRGB[i].Operand) {
d1018 1
a1018 1
	 switch(key->unit[unit].OptRGB[i].Operand) {
d1043 1
a1043 1
   struct ureg src[3];
d1047 1
a1047 1
   tmp = undef; /* silence warning (bug 5318) */
d1098 1
a1098 1
      if (_mesa_memcmp(&src[0], &src[1], sizeof(struct ureg)) == 0)
d1122 22
d1145 1
d1157 2
a1158 2
   struct state_key *key = p->state;
   GLboolean saturate = (unit < p->last_tex_stage);
d1160 1
a1160 2
   struct ureg out, shift;
   struct ureg dest;
d1165 4
d1185 17
d1210 1
a1210 1
      dest = make_ureg(PROGRAM_OUTPUT, FRAG_RESULT_COLR);
d1216 1
a1216 1
      out = emit_combine( p, dest, WRITEMASK_XYZW, saturate,
d1224 1
a1224 2

      out = emit_combine( p, dest, WRITEMASK_XYZW, saturate,
d1234 1
a1234 1
      out = emit_combine( p, dest, WRITEMASK_XYZ, saturate,
d1239 1
a1239 1
      out = emit_combine( p, dest, WRITEMASK_W, saturate,
d1249 3
d1276 2
a1277 2
      GLuint dim = p->state->unit[unit].source_index;
      struct ureg texcoord = register_input(p, FRAG_ATTRIB_TEX0+unit);
d1280 8
a1287 3
      if (dim == TEXTURE_UNKNOWN_INDEX)
         program_error(p, "TexSrcBit");
			  
d1291 7
d1300 2
a1301 3
					    unit, dim, texcoord );
	 if (p->state->unit[unit].shadow)
	    p->program->Base.ShadowSamplers |= 1 << unit;
d1311 6
d1340 1
d1352 1
a1352 1
load_texunit_sources( struct texenv_fragment_program *p, int unit )
d1354 1
a1354 1
   struct state_key *key = p->state;
d1358 1
a1358 1
      load_texenv_source( p, key->unit[unit].OptRGB[i].Source, unit);
d1368 37
d1418 1
d1420 1
a1420 2
   _mesa_memset(&p, 0, sizeof(p));
   p.ctx = ctx;
d1429 2
a1430 1
   p.program->Base.NumTexIndirections = 1;	/* correct? */
d1433 5
a1437 5
   p.program->Base.String = NULL;
   p.program->Base.NumInstructions =
   p.program->Base.NumTemporaries =
   p.program->Base.NumParameters =
   p.program->Base.NumAttributes = p.program->Base.NumAddressRegs = 0;
d1439 1
d1441 6
a1446 2
   p.program->Base.InputsRead = 0;
   p.program->Base.OutputsWritten = 1 << FRAG_RESULT_COLR;
d1448 1
a1448 1
   for (unit = 0; unit < ctx->Const.MaxTextureUnits; unit++)
d1450 2
d1462 12
d1478 1
a1478 1
      for (unit = 0 ; unit < ctx->Const.MaxTextureUnits ; unit++)
d1486 2
a1487 2
      for (unit = 0 ; unit < ctx->Const.MaxTextureUnits; unit++)
	 if (key->enabled_units & (1<<unit)) {
d1489 1
a1494 1
   out = make_ureg( PROGRAM_OUTPUT, FRAG_RESULT_COLR );
d1496 20
a1515 12
   if (key->separate_specular) {
      /* Emit specular add.
       */
      struct ureg s = register_input(&p, FRAG_ATTRIB_COL1);
      emit_arith( &p, OPCODE_ADD, out, WRITEMASK_XYZ, 0, cf, s, undef );
      emit_arith( &p, OPCODE_MOV, out, WRITEMASK_W, 0, cf, undef, undef );
   }
   else if (_mesa_memcmp(&cf, &out, sizeof(cf)) != 0) {
      /* Will wind up in here if no texture enabled or a couple of
       * other scenarios (GL_REPLACE for instance).
       */
      emit_arith( &p, OPCODE_MOV, out, WRITEMASK_XYZW, 0, cf, undef, undef );
a1516 1

d1526 3
a1528 2
      p.program->Base.InputsRead |= FRAG_BIT_FOGC; /* XXX new */
   } else
d1530 1
d1563 9
a1571 2
      ctx->Driver.ProgramStringNotify( ctx, GL_FRAGMENT_PROGRAM_ARB, 
                                       &p.program->Base );
d1576 1
a1576 1
      _mesa_printf("\n");
d1590 1
d1592 1
a1592 1
   make_state_key(ctx, &key);
d1596 1
a1596 1
                                 &key, sizeof(key));
d1605 1
a1605 1
                                 &key, sizeof(key), &prog->Base);
a1608 36
}



/**
 * If _MaintainTexEnvProgram is set we'll generate a fragment program that
 * implements the current texture env/combine mode.
 * This function generates that program and puts it into effect.
 */
void
_mesa_UpdateTexEnvProgram( GLcontext *ctx )
{
   const struct gl_fragment_program *prev = ctx->FragmentProgram._Current;
	
   ASSERT(ctx->FragmentProgram._MaintainTexEnvProgram);

   /* If a conventional fragment program/shader isn't in effect... */
   if (!ctx->FragmentProgram._Enabled &&
       (!ctx->Shader.CurrentProgram ||
        !ctx->Shader.CurrentProgram->FragmentProgram) ) 
   {
      struct gl_fragment_program *newProg;

      newProg = _mesa_get_fixed_func_fragment_program(ctx);

      _mesa_reference_fragprog(ctx, &ctx->FragmentProgram._Current, newProg);
      _mesa_reference_fragprog(ctx, &ctx->FragmentProgram._TexEnvProgram, newProg);
   } 

   /* Tell the driver about the change.  Could define a new target for
    * this?
    */
   if (ctx->FragmentProgram._Current != prev && ctx->Driver.BindProgram) {
      ctx->Driver.BindProgram(ctx, GL_FRAGMENT_PROGRAM_ARB,
                         (struct gl_program *) ctx->FragmentProgram._Current);
   }
@


1.4
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d3 1
a3 1
 * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
d33 1
d37 1
d41 15
d70 1
a70 1
#define MAX_INSTRUCTIONS ((MAX_TEXTURE_UNITS * 4) + 12)
d229 1
a229 1
   for (i=0;i<MAX_TEXTURE_UNITS;i++) {
d231 1
d236 2
d243 3
a245 1
      key->unit[i].shadow = texUnit->_Current->CompareMode == GL_COMPARE_R_TO_TEXTURE;
d324 1
a324 1
   struct ureg src_texture[MAX_TEXTURE_UNITS];   
d436 1
a436 1
static void release_temps( struct texenv_fragment_program *p )
d438 1
a438 1
   GLuint max_temp = p->ctx->Const.FragmentProgram.MaxTemps;
d618 1
a618 1
   return make_ureg(PROGRAM_STATE_VAR, idx);
d940 1
a940 1
	 shift = register_scalar_const(p, 1<<rgb_shift);
d944 4
a947 4
				  1<<rgb_shift,
				  1<<rgb_shift,
				  1<<rgb_shift,
				  1<<alpha_shift);
d978 8
a985 1
      } else
d1074 1
a1074 1
   for (unit = 0; unit < MAX_TEXTURE_UNITS; unit++)
d1083 1
a1083 1
   release_temps(&p);
d1101 1
a1101 1
	    release_temps(&p);	/* release all temps */
d1131 1
d1147 3
a1149 3
   program->Base.Instructions
      = _mesa_alloc_instructions(program->Base.NumInstructions);
   if (!program->Base.Instructions) {
d1154 8
a1161 2
   _mesa_copy_instructions(program->Base.Instructions, instBuffer,
                           program->Base.NumInstructions);
d1177 6
a1182 5
static struct gl_fragment_program *
search_cache(const struct texenvprog_cache *cache,
             GLuint hash,
             const void *key,
             GLuint keysize)
d1184 8
a1191 46
   struct texenvprog_cache_item *c;

   for (c = cache->items[hash % cache->size]; c; c = c->next) {
      if (c->hash == hash && memcmp(c->key, key, keysize) == 0)
	 return c->data;
   }

   return NULL;
}

static void rehash( struct texenvprog_cache *cache )
{
   struct texenvprog_cache_item **items;
   struct texenvprog_cache_item *c, *next;
   GLuint size, i;

   size = cache->size * 3;
   items = (struct texenvprog_cache_item**) _mesa_malloc(size * sizeof(*items));
   _mesa_memset(items, 0, size * sizeof(*items));

   for (i = 0; i < cache->size; i++)
      for (c = cache->items[i]; c; c = next) {
	 next = c->next;
	 c->next = items[c->hash % size];
	 items[c->hash % size] = c;
      }

   _mesa_free(cache->items);
   cache->items = items;
   cache->size = size;
}

static void clear_cache(GLcontext *ctx, struct texenvprog_cache *cache)
{
   struct texenvprog_cache_item *c, *next;
   GLuint i;

   for (i = 0; i < cache->size; i++) {
      for (c = cache->items[i]; c; c = next) {
	 next = c->next;
	 _mesa_free(c->key);
         _mesa_reference_fragprog(ctx, &c->data, NULL);
	 _mesa_free(c);
      }
      cache->items[i] = NULL;
   }
d1193 3
d1197 1
a1197 2
   cache->n_items = 0;
}
d1199 2
a1200 20

static void cache_item( GLcontext *ctx,
                        struct texenvprog_cache *cache,
			GLuint hash,
			const struct state_key *key,
                        struct gl_fragment_program *prog)
{
   struct texenvprog_cache_item *c = CALLOC_STRUCT(texenvprog_cache_item);
   c->hash = hash;

   c->key = _mesa_malloc(sizeof(*key));
   memcpy(c->key, key, sizeof(*key));

   c->data = prog;

   if (cache->n_items > cache->size * 1.5) {
      if (cache->size < 1000)
	 rehash(cache);
      else 
	 clear_cache(ctx, cache);
d1203 1
a1203 3
   cache->n_items++;
   c->next = cache->items[hash % cache->size];
   cache->items[hash % cache->size] = c;
a1205 16
static GLuint hash_key( const struct state_key *key )
{
   GLuint *ikey = (GLuint *)key;
   GLuint hash = 0, i;

   /* Make a slightly better attempt at a hash function:
    */
   for (i = 0; i < sizeof(*key)/sizeof(*ikey); i++)
   {
      hash += ikey[i];
      hash += (hash << 10);
      hash ^= (hash >> 6);
   }

   return hash;
}
a1215 2
   struct state_key key;
   GLuint hash;
d1222 3
a1224 1
       (!ctx->Shader.CurrentProgram || !ctx->Shader.CurrentProgram->FragmentProgram)) {
d1227 1
a1227 19
      make_state_key(ctx, &key);
      hash = hash_key(&key);
      
      newProg = search_cache(&ctx->Texture.env_fp_cache, hash, &key, sizeof(key));

      if (!newProg) {
         /* create new tex env program */

         if (0)
            _mesa_printf("Building new texenv proggy for key %x\n", hash);

         newProg = (struct gl_fragment_program *) 
            ctx->Driver.NewProgram(ctx, GL_FRAGMENT_PROGRAM_ARB, 0);

         create_new_program(ctx, &key, newProg);

         /* Our ownership of newProg is transferred to the cache */
         cache_item(ctx, &ctx->Texture.env_fp_cache, hash, &key, newProg);
      }
a1231 4
   else {
      /* _Current pointer has been updated in update_program */
      /* ctx->FragmentProgram._Current = ctx->FragmentProgram.Current; */
   }
a1239 18
}


void _mesa_TexEnvProgramCacheInit( GLcontext *ctx )
{
   ctx->Texture.env_fp_cache.ctx = ctx;
   ctx->Texture.env_fp_cache.size = 17;
   ctx->Texture.env_fp_cache.n_items = 0;
   ctx->Texture.env_fp_cache.items = (struct texenvprog_cache_item **)
      _mesa_calloc(ctx->Texture.env_fp_cache.size * 
		   sizeof(struct texenvprog_cache_item));
}


void _mesa_TexEnvProgramCacheDestroy( GLcontext *ctx )
{
   clear_cache(ctx, &ctx->Texture.env_fp_cache);
   _mesa_free(ctx->Texture.env_fp_cache.items);
@


1.3
log
@Update to Mesa 7.0.3. tested my oga@@ and johan@@
@
text
@d31 5
a35 4
#include "prog_parameter.h"
#include "prog_instruction.h"
#include "prog_print.h"
#include "prog_statevars.h"
d38 10
d71 1
d223 1
d950 1
a950 1
      if (p->state->unit[unit].enabled) 
d954 3
a956 1
      else
d1151 1
a1151 1
	 return (struct gl_fragment_program *) c->data;
d1179 1
a1179 1
static void clear_cache( struct texenvprog_cache *cache )
d1188 1
a1188 2
	 cache->ctx->Driver.DeleteProgram(cache->ctx,
                                          (struct gl_program *) c->data);
d1199 2
a1200 1
static void cache_item( struct texenvprog_cache *cache,
d1203 1
a1203 1
			void *data )
d1205 1
a1205 2
   struct texenvprog_cache_item *c
      = (struct texenvprog_cache_item *) MALLOC(sizeof(*c));
d1211 1
a1211 1
   c->data = (struct gl_fragment_program *) data;
d1217 1
a1217 1
	 clear_cache(cache);
d1259 3
a1261 1
       !ctx->Shader.CurrentProgram) {
d1265 4
a1268 3
      ctx->FragmentProgram._Current =
      ctx->FragmentProgram._TexEnvProgram =
         search_cache(&ctx->Texture.env_fp_cache, hash, &key, sizeof(key));
a1269 1
      if (!ctx->FragmentProgram._TexEnvProgram) {
d1273 1
a1273 4
         /* create new tex env program */
	 ctx->FragmentProgram._Current =
         ctx->FragmentProgram._TexEnvProgram =
            (struct gl_fragment_program *) 
d1276 1
a1276 1
         create_new_program(ctx, &key, ctx->FragmentProgram._TexEnvProgram);
d1278 2
a1279 6
         cache_item(&ctx->Texture.env_fp_cache, hash, &key,
                    ctx->FragmentProgram._TexEnvProgram);
      }
      else {
         if (0)
            _mesa_printf("Found existing texenv program for key %x\n", hash);
d1281 3
d1286 2
a1287 1
      ctx->FragmentProgram._Current = ctx->FragmentProgram.Current;
d1313 1
a1313 1
   clear_cache(&ctx->Texture.env_fp_cache);
@


1.2
log
@Update to Mesa 7.0.2. Tested by naddy@@ (full ports build), simon@@
and oga@@ (with dri enabled).
@
text
@d202 2
a203 2
		
      if (!texUnit->_ReallyEnabled)
@


1.1
log
@Initial revision
@
text
@d31 4
d37 6
a42 4
#include "shader/program.h"
#include "shader/program_instruction.h"

#define MAX_INSTRUCTIONS 100
d415 1
a415 1
static struct ureg register_param6( struct texenv_fragment_program *p, 
d420 1
a420 2
				    GLint s4,
				    GLint s5)
d422 1
a422 1
   GLint tokens[6];
a428 1
   tokens[5] = s5;
d434 4
a437 4
#define register_param1(p,s0)          register_param6(p,s0,0,0,0,0,0)
#define register_param2(p,s0,s1)       register_param6(p,s0,s1,0,0,0,0)
#define register_param3(p,s0,s1,s2)    register_param6(p,s0,s1,s2,0,0,0)
#define register_param4(p,s0,s1,s2,s3) register_param6(p,s0,s1,s2,s3,0,0)
d464 2
a465 2
   dst->CondMask = 0;
   dst->CondSwizzle = 0;
d480 4
a483 2
      
   _mesa_init_instruction(inst);
d528 1
a528 1
   p->program->NumAluInstructions++;
d550 1
a550 1
   p->program->NumTexInstructions++;
d558 1
a558 1
      p->program->NumTexIndirections++;
d575 1
a575 1
   GLuint idx;
d580 3
a582 1
   idx = _mesa_add_unnamed_constant( p->program->Base.Parameters, values );
d877 1
a877 1
	    key->unit[unit].ModeA == MODE_DOT3_RGBA) {
d999 1
a999 1
create_new_program(struct state_key *key, GLcontext *ctx,
d1002 1
d1012 4
a1015 3
   p.program->Base.Instructions =
      (struct prog_instruction*) _mesa_malloc(sizeof(struct prog_instruction) * MAX_INSTRUCTIONS);
   p.program->Base.NumInstructions = 0;
d1017 4
a1020 4
   p.program->NumTexIndirections = 1;	/* correct? */
   p.program->NumTexInstructions = 0;
   p.program->NumAluInstructions = 0;
   p.program->Base.String = 0;
d1022 3
a1024 3
      p.program->Base.NumTemporaries =
      p.program->Base.NumParameters =
      p.program->Base.NumAttributes = p.program->Base.NumAddressRegs = 0;
d1090 1
a1090 1
   if (p.program->NumTexIndirections > ctx->Const.FragmentProgram.MaxTexIndirections) 
d1093 1
a1093 1
   if (p.program->NumTexInstructions > ctx->Const.FragmentProgram.MaxTexInstructions)
d1096 1
a1096 1
   if (p.program->NumAluInstructions > ctx->Const.FragmentProgram.MaxAluInstructions)
d1101 11
d1114 8
a1121 9
   if (ctx->Driver.ProgramStringNotify || DISASSEM) {
      if (ctx->Driver.ProgramStringNotify)
	 ctx->Driver.ProgramStringNotify( ctx, GL_FRAGMENT_PROGRAM_ARB, 
					  &p.program->Base );

      if (DISASSEM) {
	 _mesa_print_program(&p.program->Base);
	 _mesa_printf("\n");
      }
d1190 2
a1191 1
   struct texenvprog_cache_item *c = MALLOC(sizeof(*c));
d1197 1
a1197 1
   c->data = data;
d1228 8
a1235 1
void _mesa_UpdateTexEnvProgram( GLcontext *ctx )
d1241 5
a1245 1
   if (!ctx->FragmentProgram._Enabled) {
d1250 14
a1263 11
      ctx->_TexEnvProgram =
	 search_cache(&ctx->Texture.env_fp_cache, hash, &key, sizeof(key));
	
      if (!ctx->_TexEnvProgram) {
	 if (0) _mesa_printf("Building new texenv proggy for key %x\n", hash);
		
	 ctx->FragmentProgram._Current = ctx->_TexEnvProgram = 
	    (struct gl_fragment_program *) 
	    ctx->Driver.NewProgram(ctx, GL_FRAGMENT_PROGRAM_ARB, 0);
		
	 create_new_program(&key, ctx, ctx->_TexEnvProgram);
d1265 6
a1270 3
	 cache_item(&ctx->Texture.env_fp_cache, hash, &key, ctx->_TexEnvProgram);
      } else {
	 if (0) _mesa_printf("Found existing texenv program for key %x\n", hash);
d1282 1
a1282 1
                             (struct gl_program *) ctx->FragmentProgram._Current);
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d36 1
a36 5
/**
 * According to Glean's texCombine test, no more than 21 instructions
 * are needed.  Allow a few extra just in case.
 */
#define MAX_INSTRUCTIONS 24
d477 1
a477 1
   _mesa_init_instructions(inst, 1);
d574 1
a574 1
   idx = _mesa_add_unnamed_constant( p->program->Base.Parameters, values, 4 );
d991 1
a991 1
create_new_program(GLcontext *ctx, struct state_key *key,
a993 1
   struct prog_instruction instBuffer[MAX_INSTRUCTIONS];
d1003 3
a1005 4
   /* During code generation, use locally-allocated instruction buffer,
    * then alloc dynamic storage below.
    */
   p.program->Base.Instructions = instBuffer;
d1012 3
a1014 3
   p.program->Base.NumTemporaries =
   p.program->Base.NumParameters =
   p.program->Base.NumAttributes = p.program->Base.NumAddressRegs = 0;
a1090 12
   /* Allocate final instruction array */
   program->Base.Instructions
      = _mesa_alloc_instructions(program->Base.NumInstructions);
   if (!program->Base.Instructions) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY,
                  "generating tex env program");
      return;
   }
   _mesa_memcpy(program->Base.Instructions, instBuffer,
                sizeof(struct prog_instruction)
                * program->Base.NumInstructions);

d1093 9
a1101 8
   if (ctx->Driver.ProgramStringNotify) {
      ctx->Driver.ProgramStringNotify( ctx, GL_FRAGMENT_PROGRAM_ARB, 
                                       &p.program->Base );
   }

   if (DISASSEM) {
      _mesa_print_program(&p.program->Base);
      _mesa_printf("\n");
d1228 1
a1228 1
	 create_new_program(ctx, &key, ctx->_TexEnvProgram);
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@a30 4
#include "prog_parameter.h"
#include "prog_instruction.h"
#include "prog_print.h"
#include "prog_statevars.h"
d33 3
d413 1
a413 1
static struct ureg register_param5( struct texenv_fragment_program *p, 
d418 2
a419 1
				    GLint s4)
d421 1
a421 1
   gl_state_index tokens[STATE_LENGTH];
d428 1
d434 4
a437 4
#define register_param1(p,s0)          register_param5(p,s0,0,0,0,0)
#define register_param2(p,s0,s1)       register_param5(p,s0,s1,0,0,0)
#define register_param3(p,s0,s1,s2)    register_param5(p,s0,s1,s2,0,0)
#define register_param4(p,s0,s1,s2,s3) register_param5(p,s0,s1,s2,s3,0)
d526 1
a526 1
   p->program->Base.NumAluInstructions++;
d548 1
a548 1
   p->program->Base.NumTexInstructions++;
d556 1
a556 1
      p->program->Base.NumTexIndirections++;
d573 1
a573 1
   GLuint idx, swizzle;
d578 1
a578 3
   idx = _mesa_add_unnamed_constant( p->program->Base.Parameters, values, 4,
                                     &swizzle );
   ASSERT(swizzle == SWIZZLE_NOOP);
d873 1
a873 1
	    key->unit[unit].ModeRGB == MODE_DOT3_RGBA) {
d1013 4
a1016 4
   p.program->Base.NumTexIndirections = 1;	/* correct? */
   p.program->Base.NumTexInstructions = 0;
   p.program->Base.NumAluInstructions = 0;
   p.program->Base.String = NULL;
d1086 1
a1086 1
   if (p.program->Base.NumTexIndirections > ctx->Const.FragmentProgram.MaxTexIndirections) 
d1089 1
a1089 1
   if (p.program->Base.NumTexInstructions > ctx->Const.FragmentProgram.MaxTexInstructions)
d1092 1
a1092 1
   if (p.program->Base.NumAluInstructions > ctx->Const.FragmentProgram.MaxAluInstructions)
d1105 3
a1107 2
   _mesa_copy_instructions(program->Base.Instructions, instBuffer,
                           program->Base.NumInstructions);
d1187 1
a1187 2
   struct texenvprog_cache_item *c
      = (struct texenvprog_cache_item *) MALLOC(sizeof(*c));
d1193 1
a1193 1
   c->data = (struct gl_fragment_program *) data;
d1224 1
a1224 8

/**
 * If _MaintainTexEnvProgram is set we'll generate a fragment program that
 * implements the current texture env/combine mode.
 * This function generates that program and puts it into effect.
 */
void
_mesa_UpdateTexEnvProgram( GLcontext *ctx )
d1230 1
a1230 5
   ASSERT(ctx->FragmentProgram._MaintainTexEnvProgram);

   /* If a conventional fragment program/shader isn't in effect... */
   if (!ctx->FragmentProgram._Enabled &&
       !ctx->Shader.CurrentProgram) {
d1235 11
a1245 12
      ctx->FragmentProgram._TexEnvProgram =
         search_cache(&ctx->Texture.env_fp_cache, hash, &key, sizeof(key));

      if (!ctx->FragmentProgram._TexEnvProgram) {
         if (0)
            _mesa_printf("Building new texenv proggy for key %x\n", hash);

         /* create new tex env program */
	 ctx->FragmentProgram._Current =
         ctx->FragmentProgram._TexEnvProgram =
            (struct gl_fragment_program *) 
            ctx->Driver.NewProgram(ctx, GL_FRAGMENT_PROGRAM_ARB, 0);
d1247 3
a1249 8
         create_new_program(ctx, &key, ctx->FragmentProgram._TexEnvProgram);

         cache_item(&ctx->Texture.env_fp_cache, hash, &key,
                    ctx->FragmentProgram._TexEnvProgram);
      }
      else {
         if (0)
            _mesa_printf("Found existing texenv program for key %x\n", hash);
d1261 1
a1261 1
                         (struct gl_program *) ctx->FragmentProgram._Current);
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d3 1
a3 1
 * Copyright 2007 Tungsten Graphics, Inc., Cedar Park, Texas.
a4 1
 * Copyright 2009 VMware, Inc.  All Rights Reserved.
d29 6
a34 8
#include "imports.h"
#include "program/program.h"
#include "program/prog_parameter.h"
#include "program/prog_cache.h"
#include "program/prog_instruction.h"
#include "program/prog_print.h"
#include "program/prog_statevars.h"
#include "program/programopt.h"
a36 37

/*
 * Note on texture units:
 *
 * The number of texture units supported by fixed-function fragment
 * processing is MAX_TEXTURE_COORD_UNITS, not MAX_TEXTURE_IMAGE_UNITS.
 * That's because there's a one-to-one correspondence between texture
 * coordinates and samplers in fixed-function processing.
 *
 * Since fixed-function vertex processing is limited to MAX_TEXTURE_COORD_UNITS
 * sets of texcoords, so is fixed-function fragment processing.
 *
 * We can safely use ctx->Const.MaxTextureUnits for loop bounds.
 */


struct texenvprog_cache_item
{
   GLuint hash;
   void *key;
   struct gl_fragment_program *data;
   struct texenvprog_cache_item *next;
};

static GLboolean
texenv_doing_secondary_color(struct gl_context *ctx)
{
   if (ctx->Light.Enabled &&
       (ctx->Light.Model.ColorControl == GL_SEPARATE_SPECULAR_COLOR))
      return GL_TRUE;

   if (ctx->Fog.ColorSumEnabled)
      return GL_TRUE;

   return GL_FALSE;
}

d38 2
a39 1
 * Up to nine instructions per tex unit, plus fog, specular color.
d41 1
a41 1
#define MAX_INSTRUCTIONS ((MAX_TEXTURE_COORD_UNITS * 9) + 12)
d46 2
a47 7
#ifdef __GNUC__
   __extension__ GLubyte Source:4;  /**< SRC_x */
   __extension__ GLubyte Operand:3; /**< OPR_x */
#else
   GLubyte Source;  /**< SRC_x */
   GLubyte Operand; /**< OPR_x */
#endif
d51 1
a51 2
   GLuint nr_enabled_units:8;
   GLuint enabled_units:8;
d54 1
a54 3
   GLuint fog_mode:2;          /**< FOG_x */
   GLuint inputs_available:12;
   GLuint num_draw_buffers:4;
a55 1
   /* NOTE: This array of structs must be last! (see "keySize" below) */
d58 1
a58 2
      GLuint source_index:3;   /**< TEXTURE_x_INDEX */
      GLuint shadow:1;
d62 8
a69 11
      GLuint NumArgsRGB:3;  /**< up to MAX_COMBINER_TERMS */
      GLuint ModeRGB:5;     /**< MODE_x */

      GLuint NumArgsA:3;  /**< up to MAX_COMBINER_TERMS */
      GLuint ModeA:5;     /**< MODE_x */

      GLuint texture_cyl_wrap:1; /**< For gallium test/debug only */

      struct mode_opt OptRGB[MAX_COMBINER_TERMS];
      struct mode_opt OptA[MAX_COMBINER_TERMS];
   } unit[MAX_TEXTURE_UNITS];
d104 1
a104 3
   default:
      assert(0);
      return OPR_UNKNOWN;
a119 1
#define SRC_ZERO     12
d137 1
a137 5
   case GL_ZERO:
      return SRC_ZERO;
   default:
      assert(0);
      return SRC_UNKNOWN;
d141 14
a154 17
#define MODE_REPLACE                     0  /* r = a0 */
#define MODE_MODULATE                    1  /* r = a0 * a1 */
#define MODE_ADD                         2  /* r = a0 + a1 */
#define MODE_ADD_SIGNED                  3  /* r = a0 + a1 - 0.5 */
#define MODE_INTERPOLATE                 4  /* r = a0 * a2 + a1 * (1 - a2) */
#define MODE_SUBTRACT                    5  /* r = a0 - a1 */
#define MODE_DOT3_RGB                    6  /* r = a0 . a1 */
#define MODE_DOT3_RGB_EXT                7  /* r = a0 . a1 */
#define MODE_DOT3_RGBA                   8  /* r = a0 . a1 */
#define MODE_DOT3_RGBA_EXT               9  /* r = a0 . a1 */
#define MODE_MODULATE_ADD_ATI           10  /* r = a0 * a2 + a1 */
#define MODE_MODULATE_SIGNED_ADD_ATI    11  /* r = a0 * a2 + a1 - 0.5 */
#define MODE_MODULATE_SUBTRACT_ATI      12  /* r = a0 * a2 - a1 */
#define MODE_ADD_PRODUCTS               13  /* r = a0 * a1 + a2 * a3 */
#define MODE_ADD_PRODUCTS_SIGNED        14  /* r = a0 * a1 + a2 * a3 - 0.5 */
#define MODE_BUMP_ENVMAP_ATI            15  /* special */
#define MODE_UNKNOWN                    16
d156 1
a156 4
/**
 * Translate GL combiner state into a MODE_x value
 */
static GLuint translate_mode( GLenum envMode, GLenum mode )
d161 2
a162 10
   case GL_ADD:
      if (envMode == GL_COMBINE4_NV)
         return MODE_ADD_PRODUCTS;
      else
         return MODE_ADD;
   case GL_ADD_SIGNED:
      if (envMode == GL_COMBINE4_NV)
         return MODE_ADD_PRODUCTS_SIGNED;
      else
         return MODE_ADD_SIGNED;
d172 1
a172 38
   case GL_BUMP_ENVMAP_ATI: return MODE_BUMP_ENVMAP_ATI;
   default:
      assert(0);
      return MODE_UNKNOWN;
   }
}


/**
 * Do we need to clamp the results of the given texture env/combine mode?
 * If the inputs to the mode are in [0,1] we don't always have to clamp
 * the results.
 */
static GLboolean
need_saturate( GLuint mode )
{
   switch (mode) {
   case MODE_REPLACE:
   case MODE_MODULATE:
   case MODE_INTERPOLATE:
      return GL_FALSE;
   case MODE_ADD:
   case MODE_ADD_SIGNED:
   case MODE_SUBTRACT:
   case MODE_DOT3_RGB:
   case MODE_DOT3_RGB_EXT:
   case MODE_DOT3_RGBA:
   case MODE_DOT3_RGBA_EXT:
   case MODE_MODULATE_ADD_ATI:
   case MODE_MODULATE_SIGNED_ADD_ATI:
   case MODE_MODULATE_SUBTRACT_ATI:
   case MODE_ADD_PRODUCTS:
   case MODE_ADD_PRODUCTS_SIGNED:
   case MODE_BUMP_ENVMAP_ATI:
      return GL_TRUE;
   default:
      assert(0);
      return GL_FALSE;
d176 1
a176 5


/**
 * Translate TEXTURE_x_BIT to TEXTURE_x_INDEX.
 */
d179 7
a185 108
   ASSERT(bit);
   return _mesa_ffs(bit) - 1;
}


#define VERT_BIT_TEX_ANY    (0xff << VERT_ATTRIB_TEX0)
#define VERT_RESULT_TEX_ANY (0xff << VERT_RESULT_TEX0)

/**
 * Identify all possible varying inputs.  The fragment program will
 * never reference non-varying inputs, but will track them via state
 * constants instead.
 *
 * This function figures out all the inputs that the fragment program
 * has access to.  The bitmask is later reduced to just those which
 * are actually referenced.
 */
static GLbitfield get_fp_input_mask( struct gl_context *ctx )
{
   /* _NEW_PROGRAM */
   const GLboolean vertexShader =
      (ctx->Shader.CurrentVertexProgram &&
       ctx->Shader.CurrentVertexProgram->LinkStatus &&
       ctx->Shader.CurrentVertexProgram->VertexProgram);
   const GLboolean vertexProgram = ctx->VertexProgram._Enabled;
   GLbitfield fp_inputs = 0x0;

   if (ctx->VertexProgram._Overriden) {
      /* Somebody's messing with the vertex program and we don't have
       * a clue what's happening.  Assume that it could be producing
       * all possible outputs.
       */
      fp_inputs = ~0;
   }
   else if (ctx->RenderMode == GL_FEEDBACK) {
      /* _NEW_RENDERMODE */
      fp_inputs = (FRAG_BIT_COL0 | FRAG_BIT_TEX0);
   }
   else if (!(vertexProgram || vertexShader) ||
            !ctx->VertexProgram._Current) {
      /* Fixed function vertex logic */
      /* _NEW_ARRAY */
      GLbitfield varying_inputs = ctx->varying_vp_inputs;

      /* These get generated in the setup routine regardless of the
       * vertex program:
       */
      /* _NEW_POINT */
      if (ctx->Point.PointSprite)
         varying_inputs |= FRAG_BITS_TEX_ANY;

      /* First look at what values may be computed by the generated
       * vertex program:
       */
      /* _NEW_LIGHT */
      if (ctx->Light.Enabled) {
         fp_inputs |= FRAG_BIT_COL0;

         if (texenv_doing_secondary_color(ctx))
            fp_inputs |= FRAG_BIT_COL1;
      }

      /* _NEW_TEXTURE */
      fp_inputs |= (ctx->Texture._TexGenEnabled |
                    ctx->Texture._TexMatEnabled) << FRAG_ATTRIB_TEX0;

      /* Then look at what might be varying as a result of enabled
       * arrays, etc:
       */
      if (varying_inputs & VERT_BIT_COLOR0)
         fp_inputs |= FRAG_BIT_COL0;
      if (varying_inputs & VERT_BIT_COLOR1)
         fp_inputs |= FRAG_BIT_COL1;

      fp_inputs |= (((varying_inputs & VERT_BIT_TEX_ANY) >> VERT_ATTRIB_TEX0) 
                    << FRAG_ATTRIB_TEX0);

   }
   else {
      /* calculate from vp->outputs */
      struct gl_vertex_program *vprog;
      GLbitfield64 vp_outputs;

      /* Choose GLSL vertex shader over ARB vertex program.  Need this
       * since vertex shader state validation comes after fragment state
       * validation (see additional comments in state.c).
       */
      if (vertexShader)
         vprog = ctx->Shader.CurrentVertexProgram->VertexProgram;
      else
         vprog = ctx->VertexProgram.Current;

      vp_outputs = vprog->Base.OutputsWritten;

      /* These get generated in the setup routine regardless of the
       * vertex program:
       */
      /* _NEW_POINT */
      if (ctx->Point.PointSprite)
         vp_outputs |= FRAG_BITS_TEX_ANY;

      if (vp_outputs & (1 << VERT_RESULT_COL0))
         fp_inputs |= FRAG_BIT_COL0;
      if (vp_outputs & (1 << VERT_RESULT_COL1))
         fp_inputs |= FRAG_BIT_COL1;

      fp_inputs |= (((vp_outputs & VERT_RESULT_TEX_ANY) >> VERT_RESULT_TEX0) 
                    << FRAG_ATTRIB_TEX0);
a186 2
   
   return fp_inputs;
a188 1

d193 1
a193 1
static GLuint make_state_key( struct gl_context *ctx,  struct state_key *key )
d196 1
a196 4
   GLbitfield inputs_referenced = FRAG_BIT_COL0;
   const GLbitfield inputs_available = get_fp_input_mask( ctx );
   GLuint keySize;

d199 1
a199 2
   /* _NEW_TEXTURE */
   for (i = 0; i < ctx->Const.MaxTextureUnits; i++) {
d201 2
a202 5
      const struct gl_texture_object *texObj = texUnit->_Current;
      const struct gl_tex_env_combine_state *comb = texUnit->_CurrentCombine;
      GLenum format;

      if (!texUnit->_ReallyEnabled || !texUnit->Enabled)
a204 2
      format = texObj->Image[0][texObj->BaseLevel]->_BaseFormat;

a206 5
      key->nr_enabled_units = i + 1;
      inputs_referenced |= FRAG_BIT_TEX(i);

      key->unit[i].source_index =
         translate_tex_src_bit(texUnit->_ReallyEnabled);
d208 2
a209 3
      key->unit[i].shadow = ((texObj->CompareMode == GL_COMPARE_R_TO_TEXTURE) &&
                             ((format == GL_DEPTH_COMPONENT) || 
                              (format == GL_DEPTH_STENCIL_EXT)));
d211 2
a212 2
      key->unit[i].NumArgsRGB = comb->_NumArgsRGB;
      key->unit[i].NumArgsA = comb->_NumArgsA;
d215 1
a215 1
	 translate_mode(texUnit->EnvMode, comb->ModeRGB);
d217 14
a230 10
	 translate_mode(texUnit->EnvMode, comb->ModeA);

      key->unit[i].ScaleShiftRGB = comb->ScaleShiftRGB;
      key->unit[i].ScaleShiftA = comb->ScaleShiftA;

      for (j = 0; j < MAX_COMBINER_TERMS; j++) {
         key->unit[i].OptRGB[j].Operand = translate_operand(comb->OperandRGB[j]);
         key->unit[i].OptA[j].Operand = translate_operand(comb->OperandA[j]);
         key->unit[i].OptRGB[j].Source = translate_source(comb->SourceRGB[j]);
         key->unit[i].OptA[j].Source = translate_source(comb->SourceA[j]);
a231 14

      if (key->unit[i].ModeRGB == MODE_BUMP_ENVMAP_ATI) {
         /* requires some special translation */
         key->unit[i].NumArgsRGB = 2;
         key->unit[i].ScaleShiftRGB = 0;
         key->unit[i].OptRGB[0].Operand = OPR_SRC_COLOR;
         key->unit[i].OptRGB[0].Source = SRC_TEXTURE;
         key->unit[i].OptRGB[1].Operand = OPR_SRC_COLOR;
         key->unit[i].OptRGB[1].Source = texUnit->BumpTarget - GL_TEXTURE0 + SRC_TEXTURE0;
       }

      /* this is a back-door for enabling cylindrical texture wrap mode */
      if (texObj->Priority == 0.125)
         key->unit[i].texture_cyl_wrap = 1;
d233 2
a234 3

   /* _NEW_LIGHT | _NEW_FOG */
   if (texenv_doing_secondary_color(ctx)) {
a235 2
      inputs_referenced |= FRAG_BIT_COL1;
   }
a236 1
   /* _NEW_FOG */
a239 1
      inputs_referenced |= FRAG_BIT_FOGC; /* maybe */
a240 11

   /* _NEW_BUFFERS */
   key->num_draw_buffers = ctx->DrawBuffer->_NumColorDrawBuffers;

   key->inputs_available = (inputs_available & inputs_referenced);

   /* compute size of state key, ignoring unused texture units */
   keySize = sizeof(*key) - sizeof(key->unit)
      + key->nr_enabled_units * sizeof(key->unit[0]);

   return keySize;
d243 1
a243 3

/**
 * Use uregs to represent registers internally, translate to Mesa's
d259 2
d262 1
a262 1
   GLuint pad:7;
d270 2
d276 1
a276 1
/** State used to build the fragment program:
d280 1
d283 3
a285 3
   GLbitfield alu_temps;	/**< Track texture indirections, see spec. */
   GLbitfield temps_output;	/**< Track texture indirections, see spec. */
   GLbitfield temp_in_use;	/**< Tracks temporary regs which are in use. */
d288 1
a288 1
   struct ureg src_texture[MAX_TEXTURE_COORD_UNITS];   
d293 1
a293 6
   struct ureg texcoord_tex[MAX_TEXTURE_COORD_UNITS];
   /* Reg containing texcoord for a texture unit,
    * needed for bump mapping, else undef.
    */

   struct ureg src_previous;	/**< Reg containing color from previous 
d297 1
a297 1
   GLuint last_tex_stage;	/**< Number of last enabled texture unit */
d312 2
d361 1
a361 1
      exit(1);
d375 1
a375 1
   /* First try to find available temp not previously used (to avoid
d389 1
a389 1
      exit(1);
d400 1
a400 2
/** Mark a temp reg as being no longer allocatable. */
static void reserve_temp( struct texenv_fragment_program *p, struct ureg r )
d402 1
a402 8
   if (r.file == PROGRAM_TEMPORARY)
      p->temps_output |= (1 << r.idx);
}


static void release_temps(struct gl_context *ctx, struct texenv_fragment_program *p )
{
   GLuint max_temp = ctx->Const.FragmentProgram.MaxTemps;
a437 12
static GLuint frag_to_vert_attrib( GLuint attrib )
{
   switch (attrib) {
   case FRAG_ATTRIB_COL0: return VERT_ATTRIB_COLOR0;
   case FRAG_ATTRIB_COL1: return VERT_ATTRIB_COLOR1;
   default:
      assert(attrib >= FRAG_ATTRIB_TEX0);
      assert(attrib <= FRAG_ATTRIB_TEX7);
      return attrib - FRAG_ATTRIB_TEX0 + VERT_ATTRIB_TEX0;
   }
}

d441 2
a442 8
   if (p->state->inputs_available & (1<<input)) {
      p->program->Base.InputsRead |= (1 << input);
      return make_ureg(PROGRAM_INPUT, input);
   }
   else {
      GLuint idx = frag_to_vert_attrib( input );
      return register_param3( p, STATE_INTERNAL, STATE_CURRENT_ATTRIB, idx );
   }
d452 3
a454 2
   reg->Negate = ureg.negatebase ? NEGATE_XYZW : NEGATE_NONE;
   reg->Abs = GL_FALSE;
d463 2
a464 2
   dst->CondMask = COND_TR;  /* always pass cond test */
   dst->CondSwizzle = SWIZZLE_NOOP;
d477 1
a477 1
   const GLuint nr = p->program->Base.NumInstructions++;
d479 1
a479 3

   assert(nr < MAX_INSTRUCTIONS);

a490 1
#if 0
a494 1
#endif
a534 1
                               GLuint tex_shadow,
a545 1
   inst->TexShadow = tex_shadow;
a548 5
   /* Accounting for indirection tracking:
    */
   reserve_temp(p, dest);

#if 0
a559 1
#endif
a572 1
   struct ureg r;
d579 2
a580 3
   r = make_ureg(PROGRAM_CONSTANT, idx);
   r.swz = swizzle;
   return r;
d613 1
a613 1
   _mesa_problem(NULL, "%s", msg);
a641 3
   case SRC_ZERO:
      return get_zero(p);

d643 1
a647 4

   default:
      assert(0);
      return undef;
a687 1
      return src;
a688 1
      assert(0);
d693 1
a693 6
/**
 * Check if the RGB and Alpha sources and operands match for the given
 * texture unit's combinder state.  When the RGB and A sources and
 * operands match, we can emit fewer instructions.
 */
static GLboolean args_match( const struct state_key *key, GLuint unit )
d695 1
a695 1
   GLuint i, numArgs = key->unit[unit].NumArgsRGB;
d697 1
a697 1
   for (i = 0; i < numArgs; i++) {
d701 1
a701 1
      switch (key->unit[unit].OptA[i].Operand) {
d703 1
a703 1
	 switch (key->unit[unit].OptRGB[i].Operand) {
d712 1
a712 1
	 switch (key->unit[unit].OptRGB[i].Operand) {
d737 1
a737 1
   struct ureg src[MAX_COMBINER_TERMS];
d741 1
a741 1
   assert(nr <= MAX_COMBINER_TERMS);
d792 1
a792 1
      if (memcmp(&src[0], &src[1], sizeof(struct ureg)) == 0)
a815 22
   case MODE_ADD_PRODUCTS:
      /* Arg0 * Arg1 + Arg2 * Arg3 */
      {
         struct ureg tmp0 = get_temp(p);
         emit_arith( p, OPCODE_MUL, tmp0, mask, 0, src[0], src[1], undef );
         emit_arith( p, OPCODE_MAD, dest, mask, saturate, src[2], src[3], tmp0 );
      }
      return dest;
   case MODE_ADD_PRODUCTS_SIGNED:
      /* Arg0 * Arg1 + Arg2 * Arg3 - 0.5 */
      {
         struct ureg tmp0 = get_temp(p);
         half = get_half(p);
         emit_arith( p, OPCODE_MUL, tmp0, mask, 0, src[0], src[1], undef );
         emit_arith( p, OPCODE_MAD, tmp0, mask, 0, src[2], src[3], tmp0 );
         emit_arith( p, OPCODE_SUB, dest, mask, saturate, tmp0, half, undef );
      }
      return dest;
   case MODE_BUMP_ENVMAP_ATI:
      /* special - not handled here */
      assert(0);
      return src[0];
a816 1
      assert(0);
d828 2
a829 2
   const struct state_key *key = p->state;
   GLboolean rgb_saturate, alpha_saturate;
d831 2
a832 1
   struct ureg out, dest;
a836 4
   if (key->unit[unit].ModeRGB == MODE_BUMP_ENVMAP_ATI) {
      /* this isn't really a env stage delivering a color and handled elsewhere */
      return get_source(p, SRC_PREVIOUS, 0);
   }
d853 1
a853 20
   /* If we'll do rgb/alpha shifting don't saturate in emit_combine().
    * We don't want to clamp twice.
    */
   if (rgb_shift)
      rgb_saturate = GL_FALSE;  /* saturate after rgb shift */
   else if (need_saturate(key->unit[unit].ModeRGB))
      rgb_saturate = GL_TRUE;
   else
      rgb_saturate = GL_FALSE;

   if (alpha_shift)
      alpha_saturate = GL_FALSE;  /* saturate after alpha shift */
   else if (need_saturate(key->unit[unit].ModeA))
      alpha_saturate = GL_TRUE;
   else
      alpha_saturate = GL_FALSE;

   /* If this is the very last calculation (and various other conditions
    * are met), emit directly to the color output register.  Otherwise,
    * emit to a temporary register.
a857 1
       key->num_draw_buffers != 1 ||
d861 1
a861 1
      dest = make_ureg(PROGRAM_OUTPUT, FRAG_RESULT_COLOR);
d867 1
a867 1
      out = emit_combine( p, dest, WRITEMASK_XYZW, rgb_saturate,
d875 2
a876 1
      out = emit_combine( p, dest, WRITEMASK_XYZW, rgb_saturate,
d886 1
a886 1
      out = emit_combine( p, dest, WRITEMASK_XYZ, rgb_saturate,
d891 1
a891 1
      out = emit_combine( p, dest, WRITEMASK_W, alpha_saturate,
a900 3
      struct ureg shift;
      GLboolean saturate = GL_TRUE;  /* always saturate at this point */

d902 1
a902 1
	 shift = register_scalar_const(p, (GLfloat)(1<<rgb_shift));
d906 4
a909 4
				  (GLfloat)(1<<rgb_shift),
				  (GLfloat)(1<<rgb_shift),
				  (GLfloat)(1<<rgb_shift),
				  (GLfloat)(1<<alpha_shift));
d925 2
a926 2
      const GLuint texTarget = p->state->unit[unit].source_index;
      struct ureg texcoord;
d929 3
a931 8
      if (is_undef(p->texcoord_tex[unit])) {
         texcoord = register_input(p, FRAG_ATTRIB_TEX0+unit);
      }
      else {
         /* might want to reuse this reg for tex output actually */
         texcoord = p->texcoord_tex[unit];
      }

d934 1
a934 8
      if (p->state->unit[unit].enabled) {
         GLboolean shadow = GL_FALSE;

	 if (p->state->unit[unit].shadow) {
	    p->program->Base.ShadowSamplers |= 1 << unit;
            shadow = GL_TRUE;
         }

d937 1
a937 9
					    unit, texTarget, shadow,
                                            texcoord );

         p->program->Base.SamplersUsed |= (1 << unit);
         /* This identity mapping should already be in place
          * (see _mesa_init_program_struct()) but let's be safe.
          */
         p->program->Base.SamplerUnits[unit] = unit;
      }
a939 6

      if (p->state->unit[unit].texture_cyl_wrap) {
         /* set flag which is checked by Mesa->Gallium program translation */
         p->program->Base.InputFlags[0] |= PROG_PARAM_BIT_CYL_WRAP;
      }

a962 1
      /* not a texture src - do nothing */
d974 1
a974 1
load_texunit_sources( struct texenv_fragment_program *p, GLuint unit )
d976 1
a976 1
   const struct state_key *key = p->state;
d980 1
a980 1
      load_texenv_source( p, key->unit[unit].OptRGB[i].Source, unit );
a989 37
/**
 * Generate instructions for loading bump map textures.
 */
static GLboolean
load_texunit_bumpmap( struct texenv_fragment_program *p, GLuint unit )
{
   const struct state_key *key = p->state;
   GLuint bumpedUnitNr = key->unit[unit].OptRGB[1].Source - SRC_TEXTURE0;
   struct ureg texcDst, bumpMapRes;
   struct ureg constdudvcolor = register_const4f(p, 0.0, 0.0, 0.0, 1.0);
   struct ureg texcSrc = register_input(p, FRAG_ATTRIB_TEX0 + bumpedUnitNr);
   struct ureg rotMat0 = register_param3( p, STATE_INTERNAL, STATE_ROT_MATRIX_0, unit );
   struct ureg rotMat1 = register_param3( p, STATE_INTERNAL, STATE_ROT_MATRIX_1, unit );

   load_texenv_source( p, unit + SRC_TEXTURE0, unit );

   bumpMapRes = get_source(p, key->unit[unit].OptRGB[0].Source, unit);
   texcDst = get_tex_temp( p );
   p->texcoord_tex[bumpedUnitNr] = texcDst;

   /* Apply rot matrix and add coords to be available in next phase.
    * dest = (Arg0.xxxx * rotMat0 + Arg1) + (Arg0.yyyy * rotMat1)
    * note only 2 coords are affected the rest are left unchanged (mul by 0)
    */
   emit_arith( p, OPCODE_MAD, texcDst, WRITEMASK_XYZW, 0,
               swizzle1(bumpMapRes, SWIZZLE_X), rotMat0, texcSrc );
   emit_arith( p, OPCODE_MAD, texcDst, WRITEMASK_XYZW, 0,
               swizzle1(bumpMapRes, SWIZZLE_Y), rotMat1, texcDst );

   /* Move 0,0,0,1 into bumpmap src if someone (crossbar) is foolish
    * enough to access this later, should optimize away.
    */
   emit_arith( p, OPCODE_MOV, bumpMapRes, WRITEMASK_XYZW, 0,
               constdudvcolor, undef, undef );

   return GL_TRUE;
}
d996 1
a996 1
create_new_program(struct gl_context *ctx, struct state_key *key,
a1002 1
   int i;
d1004 2
a1005 1
   memset(&p, 0, sizeof(p));
d1014 1
a1014 2
   p.program->Base.String = NULL;
   p.program->Base.NumTexIndirections = 1; /* is this right? */
d1017 5
a1021 5
   p.program->Base.NumInstructions = 0;
   p.program->Base.NumTemporaries = 0;
   p.program->Base.NumParameters = 0;
   p.program->Base.NumAttributes = 0;
   p.program->Base.NumAddressRegs = 0;
a1022 1
   p.program->Base.InputsRead = 0x0;
d1024 2
a1025 6
   if (key->num_draw_buffers == 1)
      p.program->Base.OutputsWritten = 1 << FRAG_RESULT_COLOR;
   else {
      for (i = 0; i < key->num_draw_buffers; i++)
	 p.program->Base.OutputsWritten |= (1 << (FRAG_RESULT_DATA0 + i));
   }
d1027 1
a1027 1
   for (unit = 0; unit < ctx->Const.MaxTextureUnits; unit++) {
a1028 2
      p.texcoord_tex[unit] = undef;
   }
d1036 1
a1036 14
   release_temps(ctx, &p);

   if (key->enabled_units && key->num_draw_buffers) {
      GLboolean needbumpstage = GL_FALSE;

      /* Zeroth pass - bump map textures first */
      for (unit = 0; unit < key->nr_enabled_units; unit++)
	 if (key->unit[unit].enabled &&
             key->unit[unit].ModeRGB == MODE_BUMP_ENVMAP_ATI) {
	    needbumpstage = GL_TRUE;
	    load_texunit_bumpmap( &p, unit );
	 }
      if (needbumpstage)
	 p.program->Base.NumTexIndirections++;
d1038 1
d1043 1
a1043 1
      for (unit = 0; unit < key->nr_enabled_units; unit++)
d1051 2
a1052 2
      for (unit = 0; unit < key->nr_enabled_units; unit++)
	 if (key->unit[unit].enabled) {
d1054 1
a1054 2
            reserve_temp(&p, p.src_previous); /* don't re-use this temp reg */
	    release_temps(ctx, &p);	/* release all temps */
d1059 1
d1061 13
a1073 6
   for (i = 0; i < key->num_draw_buffers; i++) {
      if (key->num_draw_buffers == 1)
	 out = make_ureg( PROGRAM_OUTPUT, FRAG_RESULT_COLOR );
      else {
	 out = make_ureg( PROGRAM_OUTPUT, FRAG_RESULT_DATA0 + i );
      }
a1074 14
      if (key->separate_specular) {
	 /* Emit specular add.
	  */
	 struct ureg s = register_input(&p, FRAG_ATTRIB_COL1);
	 emit_arith( &p, OPCODE_ADD, out, WRITEMASK_XYZ, 0, cf, s, undef );
	 emit_arith( &p, OPCODE_MOV, out, WRITEMASK_W, 0, cf, undef, undef );
      }
      else if (memcmp(&cf, &out, sizeof(cf)) != 0) {
	 /* Will wind up in here if no texture enabled or a couple of
	  * other scenarios (GL_REPLACE for instance).
	  */
	 emit_arith( &p, OPCODE_MOV, out, WRITEMASK_XYZW, 0, cf, undef, undef );
      }
   }
d1080 1
a1080 1
      /* Pull fog mode from struct gl_context, the value in the state key is
d1084 1
a1084 3
      p.program->Base.InputsRead |= FRAG_BIT_FOGC;
   }
   else {
a1085 1
   }
d1099 3
a1101 3
   p.program->Base.Instructions
      = _mesa_alloc_instructions(p.program->Base.NumInstructions);
   if (!p.program->Base.Instructions) {
d1106 2
a1107 8
   _mesa_copy_instructions(p.program->Base.Instructions, instBuffer,
                           p.program->Base.NumInstructions);

   if (key->num_draw_buffers && p.program->FogOption) {
      _mesa_append_fog_code(ctx, p.program);
      p.program->FogOption = GL_NONE;
   }

d1112 2
a1113 9
      GLboolean ok = ctx->Driver.ProgramStringNotify(ctx,
                                                     GL_FRAGMENT_PROGRAM_ARB, 
                                                     &p.program->Base);
      /* Driver should be able to handle any texenv programs as long as
       * the driver correctly reported max number of texture units correctly,
       * etc.
       */
      ASSERT(ok);
      (void) ok; /* silence unused var warning */
d1118 83
a1200 1
      printf("\n");
d1202 21
d1227 3
a1229 2
 * Return a fragment program which implements the current
 * fixed-function texture, fog and color-sum operations.
d1231 2
a1232 2
struct gl_fragment_program *
_mesa_get_fixed_func_fragment_program(struct gl_context *ctx)
a1233 1
   struct gl_fragment_program *prog;
d1235 2
a1236 1
   GLuint keySize;
d1238 7
a1244 1
   keySize = make_state_key(ctx, &key);
d1246 13
a1258 3
   prog = (struct gl_fragment_program *)
      _mesa_search_program_cache(ctx->FragmentProgram.Cache,
                                 &key, keySize);
d1260 1
a1260 3
   if (!prog) {
      prog = (struct gl_fragment_program *) 
         ctx->Driver.NewProgram(ctx, GL_FRAGMENT_PROGRAM_ARB, 0);
d1262 11
a1272 1
      create_new_program(ctx, &key, prog);
d1274 6
a1279 2
      _mesa_program_cache_insert(ctx, ctx->FragmentProgram.Cache,
                                 &key, keySize, &prog->Base);
d1281 2
d1284 15
a1298 1
   return prog;
@


