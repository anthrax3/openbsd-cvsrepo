head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.6
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.4
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.6
	v10_4_3:1.1.1.6
	v10_2_7:1.1.1.6
	OPENBSD_5_6:1.7.0.2
	OPENBSD_5_6_BASE:1.7
	v10_2_3:1.1.1.6
	OPENBSD_5_5:1.6.0.2
	OPENBSD_5_5_BASE:1.6
	v9_2_5:1.1.1.5
	v9_2_3:1.1.1.5
	v9_2_2:1.1.1.5
	v9_2_1:1.1.1.5
	v9_2_0:1.1.1.5
	OPENBSD_5_4:1.5.0.4
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.2
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.4.0.4
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.1.3.0.6
	OPENBSD_4_5_BASE:1.1.1.3
	OPENBSD_4_4:1.1.1.3.0.4
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.53;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2014.07.09.21.09.00;	author jsg;	state Exp;
branches;
next	1.6;
commitid	WPD6rgPryPkvXOr9;

1.6
date	2013.09.05.14.06.26;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2012.08.17.13.58.19;	author mpi;	state Exp;
branches;
next	1.4;

1.4
date	2011.10.23.13.37.42;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.05.22.20.06.31;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.05.17.20.26.41;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.50.16;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.50.16;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.56.38;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.31.17;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.46;	author matthieu;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.09.05.13.16.47;	author jsg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.07.09.20.35.04;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */


/**
 * \file rastpos.c
 * Raster position operations.
 */

#include "glheader.h"
#include "context.h"
#include "feedback.h"
#include "macros.h"
#include "mtypes.h"
#include "rastpos.h"
#include "state.h"
#include "main/dispatch.h"


/**
 * Helper function for all the RasterPos functions.
 */
static void
rasterpos(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   GET_CURRENT_CONTEXT(ctx);
   GLfloat p[4];

   p[0] = x;
   p[1] = y;
   p[2] = z;
   p[3] = w;

   FLUSH_VERTICES(ctx, 0);
   FLUSH_CURRENT(ctx, 0);

   if (ctx->NewState)
      _mesa_update_state( ctx );

   ctx->Driver.RasterPos(ctx, p);
}


void GLAPIENTRY
_mesa_RasterPos2d(GLdouble x, GLdouble y)
{
   rasterpos((GLfloat)x, (GLfloat)y, (GLfloat)0.0, (GLfloat)1.0);
}

void GLAPIENTRY
_mesa_RasterPos2f(GLfloat x, GLfloat y)
{
   rasterpos(x, y, 0.0F, 1.0F);
}

void GLAPIENTRY
_mesa_RasterPos2i(GLint x, GLint y)
{
   rasterpos((GLfloat) x, (GLfloat) y, 0.0F, 1.0F);
}

void GLAPIENTRY
_mesa_RasterPos2s(GLshort x, GLshort y)
{
   rasterpos(x, y, 0.0F, 1.0F);
}

void GLAPIENTRY
_mesa_RasterPos3d(GLdouble x, GLdouble y, GLdouble z)
{
   rasterpos((GLfloat) x, (GLfloat) y, (GLfloat) z, 1.0F);
}

void GLAPIENTRY
_mesa_RasterPos3f(GLfloat x, GLfloat y, GLfloat z)
{
   rasterpos(x, y, z, 1.0F);
}

void GLAPIENTRY
_mesa_RasterPos3i(GLint x, GLint y, GLint z)
{
   rasterpos((GLfloat) x, (GLfloat) y, (GLfloat) z, 1.0F);
}

void GLAPIENTRY
_mesa_RasterPos3s(GLshort x, GLshort y, GLshort z)
{
   rasterpos(x, y, z, 1.0F);
}

void GLAPIENTRY
_mesa_RasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   rasterpos((GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) w);
}

void GLAPIENTRY
_mesa_RasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   rasterpos(x, y, z, w);
}

void GLAPIENTRY
_mesa_RasterPos4i(GLint x, GLint y, GLint z, GLint w)
{
   rasterpos((GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) w);
}

void GLAPIENTRY
_mesa_RasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w)
{
   rasterpos(x, y, z, w);
}

void GLAPIENTRY
_mesa_RasterPos2dv(const GLdouble *v)
{
   rasterpos((GLfloat) v[0], (GLfloat) v[1], 0.0F, 1.0F);
}

void GLAPIENTRY
_mesa_RasterPos2fv(const GLfloat *v)
{
   rasterpos(v[0], v[1], 0.0F, 1.0F);
}

void GLAPIENTRY
_mesa_RasterPos2iv(const GLint *v)
{
   rasterpos((GLfloat) v[0], (GLfloat) v[1], 0.0F, 1.0F);
}

void GLAPIENTRY
_mesa_RasterPos2sv(const GLshort *v)
{
   rasterpos(v[0], v[1], 0.0F, 1.0F);
}

void GLAPIENTRY
_mesa_RasterPos3dv(const GLdouble *v)
{
   rasterpos((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], 1.0F);
}

void GLAPIENTRY
_mesa_RasterPos3fv(const GLfloat *v)
{
   rasterpos(v[0], v[1], v[2], 1.0F);
}

void GLAPIENTRY
_mesa_RasterPos3iv(const GLint *v)
{
   rasterpos((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], 1.0F);
}

void GLAPIENTRY
_mesa_RasterPos3sv(const GLshort *v)
{
   rasterpos(v[0], v[1], v[2], 1.0F);
}

void GLAPIENTRY
_mesa_RasterPos4dv(const GLdouble *v)
{
   rasterpos((GLfloat) v[0], (GLfloat) v[1], 
		     (GLfloat) v[2], (GLfloat) v[3]);
}

void GLAPIENTRY
_mesa_RasterPos4fv(const GLfloat *v)
{
   rasterpos(v[0], v[1], v[2], v[3]);
}

void GLAPIENTRY
_mesa_RasterPos4iv(const GLint *v)
{
   rasterpos((GLfloat) v[0], (GLfloat) v[1], 
		     (GLfloat) v[2], (GLfloat) v[3]);
}

void GLAPIENTRY
_mesa_RasterPos4sv(const GLshort *v)
{
   rasterpos(v[0], v[1], v[2], v[3]);
}


/**********************************************************************/
/***           GL_ARB_window_pos / GL_MESA_window_pos               ***/
/**********************************************************************/


/**
 * All glWindowPosMESA and glWindowPosARB commands call this function to
 * update the current raster position.
 */
static void
window_pos3f(GLfloat x, GLfloat y, GLfloat z)
{
   GET_CURRENT_CONTEXT(ctx);
   GLfloat z2;

   FLUSH_VERTICES(ctx, 0);
   FLUSH_CURRENT(ctx, 0);

   z2 = CLAMP(z, 0.0F, 1.0F)
      * (ctx->ViewportArray[0].Far - ctx->ViewportArray[0].Near)
      + ctx->ViewportArray[0].Near;

   /* set raster position */
   ctx->Current.RasterPos[0] = x;
   ctx->Current.RasterPos[1] = y;
   ctx->Current.RasterPos[2] = z2;
   ctx->Current.RasterPos[3] = 1.0F;

   ctx->Current.RasterPosValid = GL_TRUE;

   if (ctx->Fog.FogCoordinateSource == GL_FOG_COORDINATE_EXT)
      ctx->Current.RasterDistance = ctx->Current.Attrib[VERT_ATTRIB_FOG][0];
   else
      ctx->Current.RasterDistance = 0.0;

   /* raster color = current color or index */
   ctx->Current.RasterColor[0]
      = CLAMP(ctx->Current.Attrib[VERT_ATTRIB_COLOR0][0], 0.0F, 1.0F);
   ctx->Current.RasterColor[1]
      = CLAMP(ctx->Current.Attrib[VERT_ATTRIB_COLOR0][1], 0.0F, 1.0F);
   ctx->Current.RasterColor[2]
      = CLAMP(ctx->Current.Attrib[VERT_ATTRIB_COLOR0][2], 0.0F, 1.0F);
   ctx->Current.RasterColor[3]
      = CLAMP(ctx->Current.Attrib[VERT_ATTRIB_COLOR0][3], 0.0F, 1.0F);
   ctx->Current.RasterSecondaryColor[0]
      = CLAMP(ctx->Current.Attrib[VERT_ATTRIB_COLOR1][0], 0.0F, 1.0F);
   ctx->Current.RasterSecondaryColor[1]
      = CLAMP(ctx->Current.Attrib[VERT_ATTRIB_COLOR1][1], 0.0F, 1.0F);
   ctx->Current.RasterSecondaryColor[2]
      = CLAMP(ctx->Current.Attrib[VERT_ATTRIB_COLOR1][2], 0.0F, 1.0F);
   ctx->Current.RasterSecondaryColor[3]
      = CLAMP(ctx->Current.Attrib[VERT_ATTRIB_COLOR1][3], 0.0F, 1.0F);

   /* raster texcoord = current texcoord */
   {
      GLuint texSet;
      for (texSet = 0; texSet < ctx->Const.MaxTextureCoordUnits; texSet++) {
         assert(texSet < Elements(ctx->Current.RasterTexCoords));
         COPY_4FV( ctx->Current.RasterTexCoords[texSet],
                  ctx->Current.Attrib[VERT_ATTRIB_TEX0 + texSet] );
      }
   }

   if (ctx->RenderMode==GL_SELECT) {
      _mesa_update_hitflag( ctx, ctx->Current.RasterPos[2] );
   }
}


/* This is just to support the GL_MESA_window_pos version */
static void
window_pos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   GET_CURRENT_CONTEXT(ctx);
   window_pos3f(x, y, z);
   ctx->Current.RasterPos[3] = w;
}


void GLAPIENTRY
_mesa_WindowPos2d(GLdouble x, GLdouble y)
{
   window_pos4f((GLfloat) x, (GLfloat) y, 0.0F, 1.0F);
}

void GLAPIENTRY
_mesa_WindowPos2f(GLfloat x, GLfloat y)
{
   window_pos4f(x, y, 0.0F, 1.0F);
}

void GLAPIENTRY
_mesa_WindowPos2i(GLint x, GLint y)
{
   window_pos4f((GLfloat) x, (GLfloat) y, 0.0F, 1.0F);
}

void GLAPIENTRY
_mesa_WindowPos2s(GLshort x, GLshort y)
{
   window_pos4f(x, y, 0.0F, 1.0F);
}

void GLAPIENTRY
_mesa_WindowPos3d(GLdouble x, GLdouble y, GLdouble z)
{
   window_pos4f((GLfloat) x, (GLfloat) y, (GLfloat) z, 1.0F);
}

void GLAPIENTRY
_mesa_WindowPos3f(GLfloat x, GLfloat y, GLfloat z)
{
   window_pos4f(x, y, z, 1.0F);
}

void GLAPIENTRY
_mesa_WindowPos3i(GLint x, GLint y, GLint z)
{
   window_pos4f((GLfloat) x, (GLfloat) y, (GLfloat) z, 1.0F);
}

void GLAPIENTRY
_mesa_WindowPos3s(GLshort x, GLshort y, GLshort z)
{
   window_pos4f(x, y, z, 1.0F);
}

void GLAPIENTRY
_mesa_WindowPos4dMESA(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   window_pos4f((GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) w);
}

void GLAPIENTRY
_mesa_WindowPos4fMESA(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   window_pos4f(x, y, z, w);
}

void GLAPIENTRY
_mesa_WindowPos4iMESA(GLint x, GLint y, GLint z, GLint w)
{
   window_pos4f((GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) w);
}

void GLAPIENTRY
_mesa_WindowPos4sMESA(GLshort x, GLshort y, GLshort z, GLshort w)
{
   window_pos4f(x, y, z, w);
}

void GLAPIENTRY
_mesa_WindowPos2dv(const GLdouble *v)
{
   window_pos4f((GLfloat) v[0], (GLfloat) v[1], 0.0F, 1.0F);
}

void GLAPIENTRY
_mesa_WindowPos2fv(const GLfloat *v)
{
   window_pos4f(v[0], v[1], 0.0F, 1.0F);
}

void GLAPIENTRY
_mesa_WindowPos2iv(const GLint *v)
{
   window_pos4f((GLfloat) v[0], (GLfloat) v[1], 0.0F, 1.0F);
}

void GLAPIENTRY
_mesa_WindowPos2sv(const GLshort *v)
{
   window_pos4f(v[0], v[1], 0.0F, 1.0F);
}

void GLAPIENTRY
_mesa_WindowPos3dv(const GLdouble *v)
{
   window_pos4f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], 1.0F);
}

void GLAPIENTRY
_mesa_WindowPos3fv(const GLfloat *v)
{
   window_pos4f(v[0], v[1], v[2], 1.0);
}

void GLAPIENTRY
_mesa_WindowPos3iv(const GLint *v)
{
   window_pos4f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], 1.0F);
}

void GLAPIENTRY
_mesa_WindowPos3sv(const GLshort *v)
{
   window_pos4f(v[0], v[1], v[2], 1.0F);
}

void GLAPIENTRY
_mesa_WindowPos4dvMESA(const GLdouble *v)
{
   window_pos4f((GLfloat) v[0], (GLfloat) v[1], 
			 (GLfloat) v[2], (GLfloat) v[3]);
}

void GLAPIENTRY
_mesa_WindowPos4fvMESA(const GLfloat *v)
{
   window_pos4f(v[0], v[1], v[2], v[3]);
}

void GLAPIENTRY
_mesa_WindowPos4ivMESA(const GLint *v)
{
   window_pos4f((GLfloat) v[0], (GLfloat) v[1], 
			 (GLfloat) v[2], (GLfloat) v[3]);
}

void GLAPIENTRY
_mesa_WindowPos4svMESA(const GLshort *v)
{
   window_pos4f(v[0], v[1], v[2], v[3]);
}


#if 0

/*
 * OpenGL implementation of glWindowPos*MESA()
 */
void glWindowPos4fMESA( GLfloat x, GLfloat y, GLfloat z, GLfloat w )
{
   GLfloat fx, fy;

   /* Push current matrix mode and viewport attributes */
   glPushAttrib( GL_TRANSFORM_BIT | GL_VIEWPORT_BIT );

   /* Setup projection parameters */
   glMatrixMode( GL_PROJECTION );
   glPushMatrix();
   glLoadIdentity();
   glMatrixMode( GL_MODELVIEW );
   glPushMatrix();
   glLoadIdentity();

   glDepthRange( z, z );
   glViewport( (int) x - 1, (int) y - 1, 2, 2 );

   /* set the raster (window) position */
   fx = x - (int) x;
   fy = y - (int) y;
   glRasterPos4f( fx, fy, 0.0, w );

   /* restore matrices, viewport and matrix mode */
   glPopMatrix();
   glMatrixMode( GL_PROJECTION );
   glPopMatrix();

   glPopAttrib();
}

#endif


/**********************************************************************/
/** \name Initialization                                              */
/**********************************************************************/
/*@@{*/

/**
 * Initialize the context current raster position information.
 *
 * \param ctx GL context.
 *
 * Initialize the current raster position information in
 * __struct gl_contextRec::Current, and adds the extension entry points to the
 * dispatcher.
 */
void _mesa_init_rastpos( struct gl_context * ctx )
{
   int i;

   ASSIGN_4V( ctx->Current.RasterPos, 0.0, 0.0, 0.0, 1.0 );
   ctx->Current.RasterDistance = 0.0;
   ASSIGN_4V( ctx->Current.RasterColor, 1.0, 1.0, 1.0, 1.0 );
   ASSIGN_4V( ctx->Current.RasterSecondaryColor, 0.0, 0.0, 0.0, 1.0 );
   for (i = 0; i < Elements(ctx->Current.RasterTexCoords); i++)
      ASSIGN_4V( ctx->Current.RasterTexCoords[i], 0.0, 0.0, 0.0, 1.0 );
   ctx->Current.RasterPosValid = GL_TRUE;
}

/*@@}*/
@


1.7
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.6
log
@Merge Mesa 9.2.0
@
text
@d230 3
a232 2
   z2 = CLAMP(z, 0.0F, 1.0F) * (ctx->Viewport.Far - ctx->Viewport.Near)
      + ctx->Viewport.Near;
@


1.5
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a2 1
 * Version:  6.5.3
d19 4
a22 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
a34 1
#include "mfeatures.h"
a40 3
#if FEATURE_rastpos


d55 1
a55 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d65 1
a65 1
static void GLAPIENTRY
d71 1
a71 1
static void GLAPIENTRY
d77 1
a77 1
static void GLAPIENTRY
d83 1
a83 1
static void GLAPIENTRY
d89 1
a89 1
static void GLAPIENTRY
d95 1
a95 1
static void GLAPIENTRY
d101 1
a101 1
static void GLAPIENTRY
d107 1
a107 1
static void GLAPIENTRY
d113 1
a113 1
static void GLAPIENTRY
d119 1
a119 1
static void GLAPIENTRY
d125 1
a125 1
static void GLAPIENTRY
d131 1
a131 1
static void GLAPIENTRY
d137 1
a137 1
static void GLAPIENTRY
d143 1
a143 1
static void GLAPIENTRY
d149 1
a149 1
static void GLAPIENTRY
d155 1
a155 1
static void GLAPIENTRY
d161 1
a161 1
static void GLAPIENTRY
d167 1
a167 1
static void GLAPIENTRY
d173 1
a173 1
static void GLAPIENTRY
d179 1
a179 1
static void GLAPIENTRY
d185 1
a185 1
static void GLAPIENTRY
d192 1
a192 1
static void GLAPIENTRY
d198 1
a198 1
static void GLAPIENTRY
d205 1
a205 1
static void GLAPIENTRY
d227 1
a227 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d290 2
a291 2
static void GLAPIENTRY
_mesa_WindowPos2dMESA(GLdouble x, GLdouble y)
d296 2
a297 2
static void GLAPIENTRY
_mesa_WindowPos2fMESA(GLfloat x, GLfloat y)
d302 2
a303 2
static void GLAPIENTRY
_mesa_WindowPos2iMESA(GLint x, GLint y)
d308 2
a309 2
static void GLAPIENTRY
_mesa_WindowPos2sMESA(GLshort x, GLshort y)
d314 2
a315 2
static void GLAPIENTRY
_mesa_WindowPos3dMESA(GLdouble x, GLdouble y, GLdouble z)
d320 2
a321 2
static void GLAPIENTRY
_mesa_WindowPos3fMESA(GLfloat x, GLfloat y, GLfloat z)
d326 2
a327 2
static void GLAPIENTRY
_mesa_WindowPos3iMESA(GLint x, GLint y, GLint z)
d332 2
a333 2
static void GLAPIENTRY
_mesa_WindowPos3sMESA(GLshort x, GLshort y, GLshort z)
d338 1
a338 1
static void GLAPIENTRY
d344 1
a344 1
static void GLAPIENTRY
d350 1
a350 1
static void GLAPIENTRY
d356 1
a356 1
static void GLAPIENTRY
d362 2
a363 2
static void GLAPIENTRY
_mesa_WindowPos2dvMESA(const GLdouble *v)
d368 2
a369 2
static void GLAPIENTRY
_mesa_WindowPos2fvMESA(const GLfloat *v)
d374 2
a375 2
static void GLAPIENTRY
_mesa_WindowPos2ivMESA(const GLint *v)
d380 2
a381 2
static void GLAPIENTRY
_mesa_WindowPos2svMESA(const GLshort *v)
d386 2
a387 2
static void GLAPIENTRY
_mesa_WindowPos3dvMESA(const GLdouble *v)
d392 2
a393 2
static void GLAPIENTRY
_mesa_WindowPos3fvMESA(const GLfloat *v)
d398 2
a399 2
static void GLAPIENTRY
_mesa_WindowPos3ivMESA(const GLint *v)
d404 2
a405 2
static void GLAPIENTRY
_mesa_WindowPos3svMESA(const GLshort *v)
d410 1
a410 1
static void GLAPIENTRY
d417 1
a417 1
static void GLAPIENTRY
d423 1
a423 1
static void GLAPIENTRY
d430 1
a430 1
static void GLAPIENTRY
a473 59


void
_mesa_init_rastpos_dispatch(struct _glapi_table *disp)
{
   SET_RasterPos2f(disp, _mesa_RasterPos2f);
   SET_RasterPos2fv(disp, _mesa_RasterPos2fv);
   SET_RasterPos2i(disp, _mesa_RasterPos2i);
   SET_RasterPos2iv(disp, _mesa_RasterPos2iv);
   SET_RasterPos2d(disp, _mesa_RasterPos2d);
   SET_RasterPos2dv(disp, _mesa_RasterPos2dv);
   SET_RasterPos2s(disp, _mesa_RasterPos2s);
   SET_RasterPos2sv(disp, _mesa_RasterPos2sv);
   SET_RasterPos3d(disp, _mesa_RasterPos3d);
   SET_RasterPos3dv(disp, _mesa_RasterPos3dv);
   SET_RasterPos3f(disp, _mesa_RasterPos3f);
   SET_RasterPos3fv(disp, _mesa_RasterPos3fv);
   SET_RasterPos3i(disp, _mesa_RasterPos3i);
   SET_RasterPos3iv(disp, _mesa_RasterPos3iv);
   SET_RasterPos3s(disp, _mesa_RasterPos3s);
   SET_RasterPos3sv(disp, _mesa_RasterPos3sv);
   SET_RasterPos4d(disp, _mesa_RasterPos4d);
   SET_RasterPos4dv(disp, _mesa_RasterPos4dv);
   SET_RasterPos4f(disp, _mesa_RasterPos4f);
   SET_RasterPos4fv(disp, _mesa_RasterPos4fv);
   SET_RasterPos4i(disp, _mesa_RasterPos4i);
   SET_RasterPos4iv(disp, _mesa_RasterPos4iv);
   SET_RasterPos4s(disp, _mesa_RasterPos4s);
   SET_RasterPos4sv(disp, _mesa_RasterPos4sv);

   /* 197. GL_MESA_window_pos */
   SET_WindowPos2dMESA(disp, _mesa_WindowPos2dMESA);
   SET_WindowPos2dvMESA(disp, _mesa_WindowPos2dvMESA);
   SET_WindowPos2fMESA(disp, _mesa_WindowPos2fMESA);
   SET_WindowPos2fvMESA(disp, _mesa_WindowPos2fvMESA);
   SET_WindowPos2iMESA(disp, _mesa_WindowPos2iMESA);
   SET_WindowPos2ivMESA(disp, _mesa_WindowPos2ivMESA);
   SET_WindowPos2sMESA(disp, _mesa_WindowPos2sMESA);
   SET_WindowPos2svMESA(disp, _mesa_WindowPos2svMESA);
   SET_WindowPos3dMESA(disp, _mesa_WindowPos3dMESA);
   SET_WindowPos3dvMESA(disp, _mesa_WindowPos3dvMESA);
   SET_WindowPos3fMESA(disp, _mesa_WindowPos3fMESA);
   SET_WindowPos3fvMESA(disp, _mesa_WindowPos3fvMESA);
   SET_WindowPos3iMESA(disp, _mesa_WindowPos3iMESA);
   SET_WindowPos3ivMESA(disp, _mesa_WindowPos3ivMESA);
   SET_WindowPos3sMESA(disp, _mesa_WindowPos3sMESA);
   SET_WindowPos3svMESA(disp, _mesa_WindowPos3svMESA);
   SET_WindowPos4dMESA(disp, _mesa_WindowPos4dMESA);
   SET_WindowPos4dvMESA(disp, _mesa_WindowPos4dvMESA);
   SET_WindowPos4fMESA(disp, _mesa_WindowPos4fMESA);
   SET_WindowPos4fvMESA(disp, _mesa_WindowPos4fvMESA);
   SET_WindowPos4iMESA(disp, _mesa_WindowPos4iMESA);
   SET_WindowPos4ivMESA(disp, _mesa_WindowPos4ivMESA);
   SET_WindowPos4sMESA(disp, _mesa_WindowPos4sMESA);
   SET_WindowPos4svMESA(disp, _mesa_WindowPos4svMESA);
}


#endif /* FEATURE_rastpos */
@


1.4
log
@Merge Mesa 7.10.3
@
text
@d35 2
@


1.3
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d548 1
a548 1
 * __GLcontextRec::Current, and adds the extension entry points to the
d551 1
a551 1
void _mesa_init_rastpos( GLcontext * ctx )
@


1.2
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d37 4
d67 1
a67 1
void GLAPIENTRY
d73 1
a73 1
void GLAPIENTRY
d79 1
a79 1
void GLAPIENTRY
d85 1
a85 1
void GLAPIENTRY
d91 1
a91 1
void GLAPIENTRY
d97 1
a97 1
void GLAPIENTRY
d103 1
a103 1
void GLAPIENTRY
d109 1
a109 1
void GLAPIENTRY
d115 1
a115 1
void GLAPIENTRY
d121 1
a121 1
void GLAPIENTRY
d127 1
a127 1
void GLAPIENTRY
d133 1
a133 1
void GLAPIENTRY
d139 1
a139 1
void GLAPIENTRY
d145 1
a145 1
void GLAPIENTRY
d151 1
a151 1
void GLAPIENTRY
d157 1
a157 1
void GLAPIENTRY
d163 1
a163 1
void GLAPIENTRY
d169 1
a169 1
void GLAPIENTRY
d175 1
a175 1
void GLAPIENTRY
d181 1
a181 1
void GLAPIENTRY
d187 1
a187 1
void GLAPIENTRY
d194 1
a194 1
void GLAPIENTRY
d200 1
a200 1
void GLAPIENTRY
d207 1
a207 1
void GLAPIENTRY
d218 1
a218 1
#if FEATURE_drawpix
d249 16
a264 22
   if (ctx->Visual.rgbMode) {
      ctx->Current.RasterColor[0]
         = CLAMP(ctx->Current.Attrib[VERT_ATTRIB_COLOR0][0], 0.0F, 1.0F);
      ctx->Current.RasterColor[1]
         = CLAMP(ctx->Current.Attrib[VERT_ATTRIB_COLOR0][1], 0.0F, 1.0F);
      ctx->Current.RasterColor[2]
         = CLAMP(ctx->Current.Attrib[VERT_ATTRIB_COLOR0][2], 0.0F, 1.0F);
      ctx->Current.RasterColor[3]
         = CLAMP(ctx->Current.Attrib[VERT_ATTRIB_COLOR0][3], 0.0F, 1.0F);
      ctx->Current.RasterSecondaryColor[0]
         = CLAMP(ctx->Current.Attrib[VERT_ATTRIB_COLOR1][0], 0.0F, 1.0F);
      ctx->Current.RasterSecondaryColor[1]
         = CLAMP(ctx->Current.Attrib[VERT_ATTRIB_COLOR1][1], 0.0F, 1.0F);
      ctx->Current.RasterSecondaryColor[2]
         = CLAMP(ctx->Current.Attrib[VERT_ATTRIB_COLOR1][2], 0.0F, 1.0F);
      ctx->Current.RasterSecondaryColor[3]
         = CLAMP(ctx->Current.Attrib[VERT_ATTRIB_COLOR1][3], 0.0F, 1.0F);
   }
   else {
      ctx->Current.RasterIndex
         = ctx->Current.Attrib[VERT_ATTRIB_COLOR_INDEX][0];
   }
d270 1
d292 1
a292 1
void GLAPIENTRY
d298 1
a298 1
void GLAPIENTRY
d304 1
a304 1
void GLAPIENTRY
d310 1
a310 1
void GLAPIENTRY
d316 1
a316 1
void GLAPIENTRY
d322 1
a322 1
void GLAPIENTRY
d328 1
a328 1
void GLAPIENTRY
d334 1
a334 1
void GLAPIENTRY
d340 1
a340 1
void GLAPIENTRY
d346 1
a346 1
void GLAPIENTRY
d352 1
a352 1
void GLAPIENTRY
d358 1
a358 1
void GLAPIENTRY
d364 1
a364 1
void GLAPIENTRY
d370 1
a370 1
void GLAPIENTRY
d376 1
a376 1
void GLAPIENTRY
d382 1
a382 1
void GLAPIENTRY
d388 1
a388 1
void GLAPIENTRY
d394 1
a394 1
void GLAPIENTRY
d400 1
a400 1
void GLAPIENTRY
d406 1
a406 1
void GLAPIENTRY
d412 1
a412 1
void GLAPIENTRY
d419 1
a419 1
void GLAPIENTRY
d425 1
a425 1
void GLAPIENTRY
d432 1
a432 1
void GLAPIENTRY
a437 1
#endif
d478 59
d559 1
a559 2
   ctx->Current.RasterIndex = 1.0;
   for (i = 0; i < MAX_TEXTURE_COORD_UNITS; i++)
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * Version:  6.3
d5 1
a5 1
 * Copyright (C) 1999-2004  Brian Paul   All Rights Reserved.
a31 1
#include "colormac.h"
a33 1
#include "light.h"
a36 240
#include "simple_list.h"
#include "mtypes.h"

#include "math/m_matrix.h"


/**
 * Clip a point against the view volume.
 *
 * \param v vertex vector describing the point to clip.
 * 
 * \return zero if outside view volume, or one if inside.
 */
static GLuint
viewclip_point( const GLfloat v[] )
{
   if (   v[0] > v[3] || v[0] < -v[3]
       || v[1] > v[3] || v[1] < -v[3]
       || v[2] > v[3] || v[2] < -v[3] ) {
      return 0;
   }
   else {
      return 1;
   }
}


/**
 * Clip a point against the far/near Z clipping planes.
 *
 * \param v vertex vector describing the point to clip.
 * 
 * \return zero if outside view volume, or one if inside.
 */
static GLuint
viewclip_point_z( const GLfloat v[] )
{
   if (v[2] > v[3] || v[2] < -v[3] ) {
      return 0;
   }
   else {
      return 1;
   }
}


/**
 * Clip a point against the user clipping planes.
 * 
 * \param ctx GL context.
 * \param v vertex vector describing the point to clip.
 * 
 * \return zero if the point was clipped, or one otherwise.
 */
static GLuint
userclip_point( GLcontext *ctx, const GLfloat v[] )
{
   GLuint p;

   for (p = 0; p < ctx->Const.MaxClipPlanes; p++) {
      if (ctx->Transform.ClipPlanesEnabled & (1 << p)) {
	 GLfloat dot = v[0] * ctx->Transform._ClipUserPlane[p][0]
		     + v[1] * ctx->Transform._ClipUserPlane[p][1]
		     + v[2] * ctx->Transform._ClipUserPlane[p][2]
		     + v[3] * ctx->Transform._ClipUserPlane[p][3];
         if (dot < 0.0F) {
            return 0;
         }
      }
   }

   return 1;
}


/**
 * This has been split off to allow the normal shade routines to
 * get a little closer to the vertex buffer, and to use the
 * GLvector objects directly.
 * \param ctx the context
 * \param vertex vertex location
 * \param normal normal vector
 * \param Rcolor returned color
 * \param Rspec returned specular color (if separate specular enabled)
 * \param Rindex returned color index
 */
static void
shade_rastpos(GLcontext *ctx,
              const GLfloat vertex[4],
              const GLfloat normal[3],
              GLfloat Rcolor[4],
              GLfloat Rspec[4],
              GLfloat *Rindex)
{
   GLfloat (*base)[3] = ctx->Light._BaseColor;
   struct gl_light *light;
   GLfloat diffuseColor[4], specularColor[4];
   GLfloat diffuse = 0, specular = 0;

   if (!ctx->_ShineTable[0] || !ctx->_ShineTable[1])
      _mesa_validate_all_lighting_tables( ctx );

   COPY_3V(diffuseColor, base[0]);
   diffuseColor[3] = CLAMP( 
      ctx->Light.Material.Attrib[MAT_ATTRIB_FRONT_DIFFUSE][3], 0.0F, 1.0F );
   ASSIGN_4V(specularColor, 0.0, 0.0, 0.0, 0.0);

   foreach (light, &ctx->Light.EnabledList) {
      GLfloat n_dot_h;
      GLfloat attenuation = 1.0;
      GLfloat VP[3];
      GLfloat n_dot_VP;
      GLfloat *h;
      GLfloat diffuseContrib[3], specularContrib[3];
      GLboolean normalized;

      if (!(light->_Flags & LIGHT_POSITIONAL)) {
	 COPY_3V(VP, light->_VP_inf_norm);
	 attenuation = light->_VP_inf_spot_attenuation;
      }
      else {
	 GLfloat d;

	 SUB_3V(VP, light->_Position, vertex);
	 d = (GLfloat) LEN_3FV( VP );

	 if ( d > 1e-6) {
	    GLfloat invd = 1.0F / d;
	    SELF_SCALE_SCALAR_3V(VP, invd);
	 }
	 attenuation = 1.0F / (light->ConstantAttenuation + d *
			       (light->LinearAttenuation + d *
				light->QuadraticAttenuation));

	 if (light->_Flags & LIGHT_SPOT) {
	    GLfloat PV_dot_dir = - DOT3(VP, light->_NormDirection);

	    if (PV_dot_dir<light->_CosCutoff) {
	       continue;
	    }
	    else {
	       double x = PV_dot_dir * (EXP_TABLE_SIZE-1);
	       int k = (int) x;
	       GLfloat spot = (GLfloat) (light->_SpotExpTable[k][0]
			       + (x-k)*light->_SpotExpTable[k][1]);
	       attenuation *= spot;
	    }
	 }
      }

      if (attenuation < 1e-3)
	 continue;

      n_dot_VP = DOT3( normal, VP );

      if (n_dot_VP < 0.0F) {
	 ACC_SCALE_SCALAR_3V(diffuseColor, attenuation, light->_MatAmbient[0]);
	 continue;
      }

      COPY_3V(diffuseContrib, light->_MatAmbient[0]);
      ACC_SCALE_SCALAR_3V(diffuseContrib, n_dot_VP, light->_MatDiffuse[0]);
      diffuse += n_dot_VP * light->_dli * attenuation;
      ASSIGN_3V(specularContrib, 0.0, 0.0, 0.0);

      {
	 if (ctx->Light.Model.LocalViewer) {
	    GLfloat v[3];
	    COPY_3V(v, vertex);
	    NORMALIZE_3FV(v);
	    SUB_3V(VP, VP, v);
	    h = VP;
	    normalized = 0;
	 }
	 else if (light->_Flags & LIGHT_POSITIONAL) {
	    h = VP;
	    ACC_3V(h, ctx->_EyeZDir);
	    normalized = 0;
	 }
         else {
	    h = light->_h_inf_norm;
	    normalized = 1;
	 }

	 n_dot_h = DOT3(normal, h);

	 if (n_dot_h > 0.0F) {
	    GLfloat (*mat)[4] = ctx->Light.Material.Attrib;
	    GLfloat spec_coef;
	    GLfloat shininess = mat[MAT_ATTRIB_FRONT_SHININESS][0];

	    if (!normalized) {
	       n_dot_h *= n_dot_h;
	       n_dot_h /= LEN_SQUARED_3FV( h );
	       shininess *= .5;
	    }

	    GET_SHINE_TAB_ENTRY( ctx->_ShineTable[0], n_dot_h, spec_coef );

	    if (spec_coef > 1.0e-10) {
               if (ctx->Light.Model.ColorControl==GL_SEPARATE_SPECULAR_COLOR) {
                  ACC_SCALE_SCALAR_3V( specularContrib, spec_coef,
                                       light->_MatSpecular[0]);
               }
               else {
                  ACC_SCALE_SCALAR_3V( diffuseContrib, spec_coef,
                                       light->_MatSpecular[0]);
               }
	       specular += spec_coef * light->_sli * attenuation;
	    }
	 }
      }

      ACC_SCALE_SCALAR_3V( diffuseColor, attenuation, diffuseContrib );
      ACC_SCALE_SCALAR_3V( specularColor, attenuation, specularContrib );
   }

   if (ctx->Visual.rgbMode) {
      Rcolor[0] = CLAMP(diffuseColor[0], 0.0F, 1.0F);
      Rcolor[1] = CLAMP(diffuseColor[1], 0.0F, 1.0F);
      Rcolor[2] = CLAMP(diffuseColor[2], 0.0F, 1.0F);
      Rcolor[3] = CLAMP(diffuseColor[3], 0.0F, 1.0F);
      Rspec[0] = CLAMP(specularColor[0], 0.0F, 1.0F);
      Rspec[1] = CLAMP(specularColor[1], 0.0F, 1.0F);
      Rspec[2] = CLAMP(specularColor[2], 0.0F, 1.0F);
      Rspec[3] = CLAMP(specularColor[3], 0.0F, 1.0F);
   }
   else {
      GLfloat *ind = ctx->Light.Material.Attrib[MAT_ATTRIB_FRONT_INDEXES];
      GLfloat d_a = ind[MAT_INDEX_DIFFUSE] - ind[MAT_INDEX_AMBIENT];
      GLfloat s_a = ind[MAT_INDEX_SPECULAR] - ind[MAT_INDEX_AMBIENT];
      GLfloat i = (ind[MAT_INDEX_AMBIENT]
		   + diffuse * (1.0F-specular) * d_a
		   + specular * s_a);
      if (i > ind[MAT_INDEX_SPECULAR]) {
	 i = ind[MAT_INDEX_SPECULAR];
      }
      *Rindex = i;
   }
}
d40 1
a40 7
 * Do texgen needed for glRasterPos.
 * \param ctx  rendering context
 * \param vObj  object-space vertex coordinate
 * \param vEye  eye-space vertex coordinate
 * \param normal  vertex normal
 * \param unit  texture unit number
 * \param texcoord  incoming texcoord and resulting texcoord
d43 1
a43 2
compute_texgen(GLcontext *ctx, const GLfloat vObj[4], const GLfloat vEye[4],
               const GLfloat normal[3], GLuint unit, GLfloat texcoord[4])
d45 2
a46 1
   const struct gl_texture_unit *texUnit = &ctx->Texture.Unit[unit];
d48 4
a51 36
   /* always compute sphere map terms, just in case */
   GLfloat u[3], two_nu, rx, ry, rz, m, mInv;
   COPY_3V(u, vEye);
   NORMALIZE_3FV(u);
   two_nu = 2.0F * DOT3(normal, u);
   rx = u[0] - normal[0] * two_nu;
   ry = u[1] - normal[1] * two_nu;
   rz = u[2] - normal[2] * two_nu;
   m = rx * rx + ry * ry + (rz + 1.0F) * (rz + 1.0F);
   if (m > 0.0F)
      mInv = 0.5F * _mesa_inv_sqrtf(m);
   else
      mInv = 0.0F;

   if (texUnit->TexGenEnabled & S_BIT) {
      switch (texUnit->GenModeS) {
         case GL_OBJECT_LINEAR:
            texcoord[0] = DOT4(vObj, texUnit->ObjectPlaneS);
            break;
         case GL_EYE_LINEAR:
            texcoord[0] = DOT4(vEye, texUnit->EyePlaneS);
            break;
         case GL_SPHERE_MAP:
            texcoord[0] = rx * mInv + 0.5F;
            break;
         case GL_REFLECTION_MAP:
            texcoord[0] = rx;
            break;
         case GL_NORMAL_MAP:
            texcoord[0] = normal[0];
            break;
         default:
            _mesa_problem(ctx, "Bad S texgen in compute_texgen()");
            return;
      }
   }
a52 82
   if (texUnit->TexGenEnabled & T_BIT) {
      switch (texUnit->GenModeT) {
         case GL_OBJECT_LINEAR:
            texcoord[1] = DOT4(vObj, texUnit->ObjectPlaneT);
            break;
         case GL_EYE_LINEAR:
            texcoord[1] = DOT4(vEye, texUnit->EyePlaneT);
            break;
         case GL_SPHERE_MAP:
            texcoord[1] = ry * mInv + 0.5F;
            break;
         case GL_REFLECTION_MAP:
            texcoord[1] = ry;
            break;
         case GL_NORMAL_MAP:
            texcoord[1] = normal[1];
            break;
         default:
            _mesa_problem(ctx, "Bad T texgen in compute_texgen()");
            return;
      }
   }

   if (texUnit->TexGenEnabled & R_BIT) {
      switch (texUnit->GenModeR) {
         case GL_OBJECT_LINEAR:
            texcoord[2] = DOT4(vObj, texUnit->ObjectPlaneR);
            break;
         case GL_EYE_LINEAR:
            texcoord[2] = DOT4(vEye, texUnit->EyePlaneR);
            break;
         case GL_REFLECTION_MAP:
            texcoord[2] = rz;
            break;
         case GL_NORMAL_MAP:
            texcoord[2] = normal[2];
            break;
         default:
            _mesa_problem(ctx, "Bad R texgen in compute_texgen()");
            return;
      }
   }

   if (texUnit->TexGenEnabled & Q_BIT) {
      switch (texUnit->GenModeQ) {
         case GL_OBJECT_LINEAR:
            texcoord[3] = DOT4(vObj, texUnit->ObjectPlaneQ);
            break;
         case GL_EYE_LINEAR:
            texcoord[3] = DOT4(vEye, texUnit->EyePlaneQ);
            break;
         default:
            _mesa_problem(ctx, "Bad Q texgen in compute_texgen()");
            return;
      }
   }
}



/**
 * Set the raster position for pixel operations.
 *
 * All glRasterPos command call this function to update the current
 * raster position.
 * 
 * \param ctx GL context.
 * \param x x coordinate for the raster position.
 * \param y y coordinate for the raster position.
 * \param z z coordinate for the raster position.
 * \param w w coordinate for the raster position.
 * 
 * \sa Called by _mesa_RasterPos4f().
 *
 * Flushes the vertices, transforms and clips the vertex coordinates, and
 * finally sets the current raster position and associated data in
 * __GLcontextRec::Current.  When in selection mode calls
 * _mesa_update_hitflag() with the current raster position.
 */
static void
raster_pos4f(GLcontext *ctx, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
d59 1
a59 110
   if (ctx->VertexProgram._Enabled) {
      /* XXX implement this */
      _mesa_problem(ctx, "Vertex programs not implemented for glRasterPos");
      return;
   }
   else {
      GLfloat obj[4], eye[4], clip[4], ndc[3], d;
      GLfloat *norm, eyenorm[3];
      GLfloat *objnorm = ctx->Current.Attrib[VERT_ATTRIB_NORMAL];

      ASSIGN_4V( obj, x, y, z, w );
      /* apply modelview matrix:  eye = MV * obj */
      TRANSFORM_POINT( eye, ctx->ModelviewMatrixStack.Top->m, obj );
      /* apply projection matrix:  clip = Proj * eye */
      TRANSFORM_POINT( clip, ctx->ProjectionMatrixStack.Top->m, eye );

      /* clip to view volume */
      if (ctx->Transform.RasterPositionUnclipped) {
         /* GL_IBM_rasterpos_clip: only clip against Z */
         if (viewclip_point_z(clip) == 0) {
            ctx->Current.RasterPosValid = GL_FALSE;
            return;
         }
      }
      else if (viewclip_point(clip) == 0) {
         /* Normal OpenGL behaviour */
         ctx->Current.RasterPosValid = GL_FALSE;
         return;
      }

      /* clip to user clipping planes */
      if (ctx->Transform.ClipPlanesEnabled && !userclip_point(ctx, clip)) {
         ctx->Current.RasterPosValid = GL_FALSE;
         return;
      }

      /* ndc = clip / W */
      d = (clip[3] == 0.0F) ? 1.0F : 1.0F / clip[3];
      ndc[0] = clip[0] * d;
      ndc[1] = clip[1] * d;
      ndc[2] = clip[2] * d;
      /* wincoord = viewport_mapping(ndc) */
      ctx->Current.RasterPos[0] = (ndc[0] * ctx->Viewport._WindowMap.m[MAT_SX]
                                   + ctx->Viewport._WindowMap.m[MAT_TX]);
      ctx->Current.RasterPos[1] = (ndc[1] * ctx->Viewport._WindowMap.m[MAT_SY]
                                   + ctx->Viewport._WindowMap.m[MAT_TY]);
      ctx->Current.RasterPos[2] = (ndc[2] * ctx->Viewport._WindowMap.m[MAT_SZ]
                                   + ctx->Viewport._WindowMap.m[MAT_TZ])
                                  / ctx->DrawBuffer->_DepthMaxF;
      ctx->Current.RasterPos[3] = clip[3];

      /* compute raster distance */
      if (ctx->Fog.FogCoordinateSource == GL_FOG_COORDINATE_EXT)
         ctx->Current.RasterDistance = ctx->Current.Attrib[VERT_ATTRIB_FOG][0];
      else
         ctx->Current.RasterDistance =
                        SQRTF( eye[0]*eye[0] + eye[1]*eye[1] + eye[2]*eye[2] );

      /* compute transformed normal vector (for lighting or texgen) */
      if (ctx->_NeedEyeCoords) {
         const GLfloat *inv = ctx->ModelviewMatrixStack.Top->inv;
         TRANSFORM_NORMAL( eyenorm, objnorm, inv );
         norm = eyenorm;
      }
      else {
         norm = objnorm;
      }

      /* update raster color */
      if (ctx->Light.Enabled) {
         /* lighting */
         shade_rastpos( ctx, obj, norm,
                        ctx->Current.RasterColor,
                        ctx->Current.RasterSecondaryColor,
                        &ctx->Current.RasterIndex );
      }
      else {
         /* use current color or index */
         if (ctx->Visual.rgbMode) {
            COPY_4FV(ctx->Current.RasterColor,
                     ctx->Current.Attrib[VERT_ATTRIB_COLOR0]);
            COPY_4FV(ctx->Current.RasterSecondaryColor,
                     ctx->Current.Attrib[VERT_ATTRIB_COLOR1]);
         }
         else {
            ctx->Current.RasterIndex
               = ctx->Current.Attrib[VERT_ATTRIB_COLOR_INDEX][0];
         }
      }

      /* texture coords */
      {
         GLuint u;
         for (u = 0; u < ctx->Const.MaxTextureCoordUnits; u++) {
            GLfloat tc[4];
            COPY_4V(tc, ctx->Current.Attrib[VERT_ATTRIB_TEX0 + u]);
            if (ctx->Texture.Unit[u].TexGenEnabled) {
               compute_texgen(ctx, obj, eye, norm, u, tc);
            }
            TRANSFORM_POINT(ctx->Current.RasterTexCoords[u],
                            ctx->TextureMatrixStack[u].Top->m, tc);
         }
      }

      ctx->Current.RasterPosValid = GL_TRUE;
   }

   if (ctx->RenderMode == GL_SELECT) {
      _mesa_update_hitflag( ctx, ctx->Current.RasterPos[2] );
   }
a62 1
/** Calls _mesa_RasterPos4f() */
d66 1
a66 1
   _mesa_RasterPos4f((GLfloat) x, (GLfloat) y, 0.0F, 1.0F);
a68 1
/** Calls _mesa_RasterPos4f() */
d72 1
a72 1
   _mesa_RasterPos4f(x, y, 0.0F, 1.0F);
a74 1
/** Calls _mesa_RasterPos4f() */
d78 1
a78 1
   _mesa_RasterPos4f((GLfloat) x, (GLfloat) y, 0.0F, 1.0F);
a80 1
/** Calls _mesa_RasterPos4f() */
d84 1
a84 1
   _mesa_RasterPos4f(x, y, 0.0F, 1.0F);
a86 1
/** Calls _mesa_RasterPos4f() */
d90 1
a90 1
   _mesa_RasterPos4f((GLfloat) x, (GLfloat) y, (GLfloat) z, 1.0F);
a92 1
/** Calls _mesa_RasterPos4f() */
d96 1
a96 1
   _mesa_RasterPos4f(x, y, z, 1.0F);
a98 1
/** Calls _mesa_RasterPos4f() */
d102 1
a102 1
   _mesa_RasterPos4f((GLfloat) x, (GLfloat) y, (GLfloat) z, 1.0F);
a104 1
/** Calls _mesa_RasterPos4f() */
d108 1
a108 1
   _mesa_RasterPos4f(x, y, z, 1.0F);
a110 1
/** Calls _mesa_RasterPos4f() */
d114 1
a114 1
   _mesa_RasterPos4f((GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) w);
a116 1
/** Calls raster_pos4f() */
d120 1
a120 2
   GET_CURRENT_CONTEXT(ctx);
   raster_pos4f(ctx, x, y, z, w);
a122 1
/** Calls _mesa_RasterPos4f() */
d126 1
a126 1
   _mesa_RasterPos4f((GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) w);
a128 1
/** Calls _mesa_RasterPos4f() */
d132 1
a132 1
   _mesa_RasterPos4f(x, y, z, w);
a134 1
/** Calls _mesa_RasterPos4f() */
d138 1
a138 1
   _mesa_RasterPos4f((GLfloat) v[0], (GLfloat) v[1], 0.0F, 1.0F);
a140 1
/** Calls _mesa_RasterPos4f() */
d144 1
a144 1
   _mesa_RasterPos4f(v[0], v[1], 0.0F, 1.0F);
a146 1
/** Calls _mesa_RasterPos4f() */
d150 1
a150 1
   _mesa_RasterPos4f((GLfloat) v[0], (GLfloat) v[1], 0.0F, 1.0F);
a152 1
/** Calls _mesa_RasterPos4f() */
d156 1
a156 1
   _mesa_RasterPos4f(v[0], v[1], 0.0F, 1.0F);
a158 1
/** Calls _mesa_RasterPos4f() */
d162 1
a162 1
   _mesa_RasterPos4f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], 1.0F);
a164 1
/** Calls _mesa_RasterPos4f() */
d168 1
a168 1
   _mesa_RasterPos4f(v[0], v[1], v[2], 1.0F);
a170 1
/** Calls _mesa_RasterPos4f() */
d174 1
a174 1
   _mesa_RasterPos4f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], 1.0F);
a176 1
/** Calls _mesa_RasterPos4f() */
d180 1
a180 1
   _mesa_RasterPos4f(v[0], v[1], v[2], 1.0F);
a182 1
/** Calls _mesa_RasterPos4f() */
d186 1
a186 1
   _mesa_RasterPos4f((GLfloat) v[0], (GLfloat) v[1], 
a189 1
/** Calls _mesa_RasterPos4f() */
d193 1
a193 1
   _mesa_RasterPos4f(v[0], v[1], v[2], v[3]);
a195 1
/** Calls _mesa_RasterPos4f() */
d199 1
a199 1
   _mesa_RasterPos4f((GLfloat) v[0], (GLfloat) v[1], 
a202 1
/** Calls _mesa_RasterPos4f() */
d206 1
a206 1
   _mesa_RasterPos4f(v[0], v[1], v[2], v[3]);
d214 1
a214 1
#if FEATURE_windowpos
d501 1
d503 1
a503 1
   for (i=0; i<MAX_TEXTURE_UNITS; i++)
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@a996 1
   ASSIGN_4V( ctx->Current.RasterSecondaryColor, 0.0, 0.0, 0.0, 1.0 );
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d3 1
a3 1
 * Version:  6.5.3
d5 1
a5 1
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
d115 3
a117 1
 * Compute lighting for the raster position.  Both RGB and CI modes computed.
d133 4
a136 4
   /*const*/ GLfloat (*base)[3] = ctx->Light._BaseColor;
   const struct gl_light *light;
   GLfloat diffuseColor[4], specularColor[4];  /* for RGB mode only */
   GLfloat diffuseCI = 0.0, specularCI = 0.0;  /* for CI mode only */
d138 2
a139 1
   _mesa_validate_all_lighting_tables( ctx );
d144 1
a144 1
   ASSIGN_4V(specularColor, 0.0, 0.0, 0.0, 1.0);
d147 1
d149 1
a149 1
      GLfloat VP[3]; /* vector from vertex to light pos */
d151 1
d153 1
a155 1
         /* light at infinity */
a159 1
         /* local/positional light */
a161 1
         /* VP = vector from vertex pos to light[i].pos */
a162 1
         /* d = length(VP) */
d164 2
a165 2
	 if (d > 1.0e-6) {
            /* normalize VP */
a168 2

         /* atti */
a198 1
      /* Ambient + diffuse */
d201 2
a202 1
      diffuseCI += n_dot_VP * light->_dli * attenuation;
a203 1
      /* Specular */
a204 5
         const GLfloat *h;
         GLfloat n_dot_h;

         ASSIGN_3V(specularContrib, 0.0, 0.0, 0.0);

a209 1
            NORMALIZE_3FV(VP);
d211 1
a213 2
	    ACC_3V(VP, ctx->_EyeZDir);
            NORMALIZE_3FV(VP);
d215 2
d220 1
d226 1
d228 8
d247 1
a247 2
               /*assert(light->_sli > 0.0);*/
               specularCI += spec_coef * light->_sli * attenuation;
d271 2
a272 2
		   + diffuseCI * (1.0F-specularCI) * d_a
		   + specularCI * s_a);
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d32 1
d35 1
d39 2
a40 1
#include "main/dispatch.h"
d42 1
d44 39
a82 1
#if FEATURE_rastpos
d86 36
a121 1
 * Helper function for all the RasterPos functions.
d124 166
a289 1
rasterpos(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
d291 97
a387 2
   GET_CURRENT_CONTEXT(ctx);
   GLfloat p[4];
a388 4
   p[0] = x;
   p[1] = y;
   p[2] = z;
   p[3] = w;
d390 22
d418 110
a527 1
   ctx->Driver.RasterPos(ctx, p);
d531 2
a532 1
static void GLAPIENTRY
d535 1
a535 1
   rasterpos((GLfloat)x, (GLfloat)y, (GLfloat)0.0, (GLfloat)1.0);
d538 2
a539 1
static void GLAPIENTRY
d542 1
a542 1
   rasterpos(x, y, 0.0F, 1.0F);
d545 2
a546 1
static void GLAPIENTRY
d549 1
a549 1
   rasterpos((GLfloat) x, (GLfloat) y, 0.0F, 1.0F);
d552 2
a553 1
static void GLAPIENTRY
d556 1
a556 1
   rasterpos(x, y, 0.0F, 1.0F);
d559 2
a560 1
static void GLAPIENTRY
d563 1
a563 1
   rasterpos((GLfloat) x, (GLfloat) y, (GLfloat) z, 1.0F);
d566 2
a567 1
static void GLAPIENTRY
d570 1
a570 1
   rasterpos(x, y, z, 1.0F);
d573 2
a574 1
static void GLAPIENTRY
d577 1
a577 1
   rasterpos((GLfloat) x, (GLfloat) y, (GLfloat) z, 1.0F);
d580 2
a581 1
static void GLAPIENTRY
d584 1
a584 1
   rasterpos(x, y, z, 1.0F);
d587 2
a588 1
static void GLAPIENTRY
d591 1
a591 1
   rasterpos((GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) w);
d594 2
a595 1
static void GLAPIENTRY
d598 2
a599 1
   rasterpos(x, y, z, w);
d602 2
a603 1
static void GLAPIENTRY
d606 1
a606 1
   rasterpos((GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) w);
d609 2
a610 1
static void GLAPIENTRY
d613 1
a613 1
   rasterpos(x, y, z, w);
d616 2
a617 1
static void GLAPIENTRY
d620 1
a620 1
   rasterpos((GLfloat) v[0], (GLfloat) v[1], 0.0F, 1.0F);
d623 2
a624 1
static void GLAPIENTRY
d627 1
a627 1
   rasterpos(v[0], v[1], 0.0F, 1.0F);
d630 2
a631 1
static void GLAPIENTRY
d634 1
a634 1
   rasterpos((GLfloat) v[0], (GLfloat) v[1], 0.0F, 1.0F);
d637 2
a638 1
static void GLAPIENTRY
d641 1
a641 1
   rasterpos(v[0], v[1], 0.0F, 1.0F);
d644 2
a645 1
static void GLAPIENTRY
d648 1
a648 1
   rasterpos((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], 1.0F);
d651 2
a652 1
static void GLAPIENTRY
d655 1
a655 1
   rasterpos(v[0], v[1], v[2], 1.0F);
d658 2
a659 1
static void GLAPIENTRY
d662 1
a662 1
   rasterpos((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], 1.0F);
d665 2
a666 1
static void GLAPIENTRY
d669 1
a669 1
   rasterpos(v[0], v[1], v[2], 1.0F);
d672 2
a673 1
static void GLAPIENTRY
d676 1
a676 1
   rasterpos((GLfloat) v[0], (GLfloat) v[1], 
d680 2
a681 1
static void GLAPIENTRY
d684 1
a684 1
   rasterpos(v[0], v[1], v[2], v[3]);
d687 2
a688 1
static void GLAPIENTRY
d691 1
a691 1
   rasterpos((GLfloat) v[0], (GLfloat) v[1], 
d695 2
a696 1
static void GLAPIENTRY
d699 1
a699 1
   rasterpos(v[0], v[1], v[2], v[3]);
d707 1
a707 1

d738 22
a759 16
   ctx->Current.RasterColor[0]
      = CLAMP(ctx->Current.Attrib[VERT_ATTRIB_COLOR0][0], 0.0F, 1.0F);
   ctx->Current.RasterColor[1]
      = CLAMP(ctx->Current.Attrib[VERT_ATTRIB_COLOR0][1], 0.0F, 1.0F);
   ctx->Current.RasterColor[2]
      = CLAMP(ctx->Current.Attrib[VERT_ATTRIB_COLOR0][2], 0.0F, 1.0F);
   ctx->Current.RasterColor[3]
      = CLAMP(ctx->Current.Attrib[VERT_ATTRIB_COLOR0][3], 0.0F, 1.0F);
   ctx->Current.RasterSecondaryColor[0]
      = CLAMP(ctx->Current.Attrib[VERT_ATTRIB_COLOR1][0], 0.0F, 1.0F);
   ctx->Current.RasterSecondaryColor[1]
      = CLAMP(ctx->Current.Attrib[VERT_ATTRIB_COLOR1][1], 0.0F, 1.0F);
   ctx->Current.RasterSecondaryColor[2]
      = CLAMP(ctx->Current.Attrib[VERT_ATTRIB_COLOR1][2], 0.0F, 1.0F);
   ctx->Current.RasterSecondaryColor[3]
      = CLAMP(ctx->Current.Attrib[VERT_ATTRIB_COLOR1][3], 0.0F, 1.0F);
a764 1
         assert(texSet < Elements(ctx->Current.RasterTexCoords));
d786 1
a786 1
static void GLAPIENTRY
d792 1
a792 1
static void GLAPIENTRY
d798 1
a798 1
static void GLAPIENTRY
d804 1
a804 1
static void GLAPIENTRY
d810 1
a810 1
static void GLAPIENTRY
d816 1
a816 1
static void GLAPIENTRY
d822 1
a822 1
static void GLAPIENTRY
d828 1
a828 1
static void GLAPIENTRY
d834 1
a834 1
static void GLAPIENTRY
d840 1
a840 1
static void GLAPIENTRY
d846 1
a846 1
static void GLAPIENTRY
d852 1
a852 1
static void GLAPIENTRY
d858 1
a858 1
static void GLAPIENTRY
d864 1
a864 1
static void GLAPIENTRY
d870 1
a870 1
static void GLAPIENTRY
d876 1
a876 1
static void GLAPIENTRY
d882 1
a882 1
static void GLAPIENTRY
d888 1
a888 1
static void GLAPIENTRY
d894 1
a894 1
static void GLAPIENTRY
d900 1
a900 1
static void GLAPIENTRY
d906 1
a906 1
static void GLAPIENTRY
d913 1
a913 1
static void GLAPIENTRY
d919 1
a919 1
static void GLAPIENTRY
d926 1
a926 1
static void GLAPIENTRY
d932 1
a972 59
void
_mesa_init_rastpos_dispatch(struct _glapi_table *disp)
{
   SET_RasterPos2f(disp, _mesa_RasterPos2f);
   SET_RasterPos2fv(disp, _mesa_RasterPos2fv);
   SET_RasterPos2i(disp, _mesa_RasterPos2i);
   SET_RasterPos2iv(disp, _mesa_RasterPos2iv);
   SET_RasterPos2d(disp, _mesa_RasterPos2d);
   SET_RasterPos2dv(disp, _mesa_RasterPos2dv);
   SET_RasterPos2s(disp, _mesa_RasterPos2s);
   SET_RasterPos2sv(disp, _mesa_RasterPos2sv);
   SET_RasterPos3d(disp, _mesa_RasterPos3d);
   SET_RasterPos3dv(disp, _mesa_RasterPos3dv);
   SET_RasterPos3f(disp, _mesa_RasterPos3f);
   SET_RasterPos3fv(disp, _mesa_RasterPos3fv);
   SET_RasterPos3i(disp, _mesa_RasterPos3i);
   SET_RasterPos3iv(disp, _mesa_RasterPos3iv);
   SET_RasterPos3s(disp, _mesa_RasterPos3s);
   SET_RasterPos3sv(disp, _mesa_RasterPos3sv);
   SET_RasterPos4d(disp, _mesa_RasterPos4d);
   SET_RasterPos4dv(disp, _mesa_RasterPos4dv);
   SET_RasterPos4f(disp, _mesa_RasterPos4f);
   SET_RasterPos4fv(disp, _mesa_RasterPos4fv);
   SET_RasterPos4i(disp, _mesa_RasterPos4i);
   SET_RasterPos4iv(disp, _mesa_RasterPos4iv);
   SET_RasterPos4s(disp, _mesa_RasterPos4s);
   SET_RasterPos4sv(disp, _mesa_RasterPos4sv);

   /* 197. GL_MESA_window_pos */
   SET_WindowPos2dMESA(disp, _mesa_WindowPos2dMESA);
   SET_WindowPos2dvMESA(disp, _mesa_WindowPos2dvMESA);
   SET_WindowPos2fMESA(disp, _mesa_WindowPos2fMESA);
   SET_WindowPos2fvMESA(disp, _mesa_WindowPos2fvMESA);
   SET_WindowPos2iMESA(disp, _mesa_WindowPos2iMESA);
   SET_WindowPos2ivMESA(disp, _mesa_WindowPos2ivMESA);
   SET_WindowPos2sMESA(disp, _mesa_WindowPos2sMESA);
   SET_WindowPos2svMESA(disp, _mesa_WindowPos2svMESA);
   SET_WindowPos3dMESA(disp, _mesa_WindowPos3dMESA);
   SET_WindowPos3dvMESA(disp, _mesa_WindowPos3dvMESA);
   SET_WindowPos3fMESA(disp, _mesa_WindowPos3fMESA);
   SET_WindowPos3fvMESA(disp, _mesa_WindowPos3fvMESA);
   SET_WindowPos3iMESA(disp, _mesa_WindowPos3iMESA);
   SET_WindowPos3ivMESA(disp, _mesa_WindowPos3ivMESA);
   SET_WindowPos3sMESA(disp, _mesa_WindowPos3sMESA);
   SET_WindowPos3svMESA(disp, _mesa_WindowPos3svMESA);
   SET_WindowPos4dMESA(disp, _mesa_WindowPos4dMESA);
   SET_WindowPos4dvMESA(disp, _mesa_WindowPos4dvMESA);
   SET_WindowPos4fMESA(disp, _mesa_WindowPos4fMESA);
   SET_WindowPos4fvMESA(disp, _mesa_WindowPos4fvMESA);
   SET_WindowPos4iMESA(disp, _mesa_WindowPos4iMESA);
   SET_WindowPos4ivMESA(disp, _mesa_WindowPos4ivMESA);
   SET_WindowPos4sMESA(disp, _mesa_WindowPos4sMESA);
   SET_WindowPos4svMESA(disp, _mesa_WindowPos4svMESA);
}


#endif /* FEATURE_rastpos */


d984 1
a984 1
 * __struct gl_contextRec::Current, and adds the extension entry points to the
d987 1
a987 1
void _mesa_init_rastpos( struct gl_context * ctx )
d995 2
a996 1
   for (i = 0; i < Elements(ctx->Current.RasterTexCoords); i++)
@


1.1.1.5
log
@Import Mesa 9.2.0
@
text
@d3 1
d20 3
a22 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
a34 1
#include "mtypes.h"
d40 3
d57 1
a57 1
   FLUSH_VERTICES(ctx, 0);
d67 1
a67 1
void GLAPIENTRY
d73 1
a73 1
void GLAPIENTRY
d79 1
a79 1
void GLAPIENTRY
d85 1
a85 1
void GLAPIENTRY
d91 1
a91 1
void GLAPIENTRY
d97 1
a97 1
void GLAPIENTRY
d103 1
a103 1
void GLAPIENTRY
d109 1
a109 1
void GLAPIENTRY
d115 1
a115 1
void GLAPIENTRY
d121 1
a121 1
void GLAPIENTRY
d127 1
a127 1
void GLAPIENTRY
d133 1
a133 1
void GLAPIENTRY
d139 1
a139 1
void GLAPIENTRY
d145 1
a145 1
void GLAPIENTRY
d151 1
a151 1
void GLAPIENTRY
d157 1
a157 1
void GLAPIENTRY
d163 1
a163 1
void GLAPIENTRY
d169 1
a169 1
void GLAPIENTRY
d175 1
a175 1
void GLAPIENTRY
d181 1
a181 1
void GLAPIENTRY
d187 1
a187 1
void GLAPIENTRY
d194 1
a194 1
void GLAPIENTRY
d200 1
a200 1
void GLAPIENTRY
d207 1
a207 1
void GLAPIENTRY
d229 1
a229 1
   FLUSH_VERTICES(ctx, 0);
d292 2
a293 2
void GLAPIENTRY
_mesa_WindowPos2d(GLdouble x, GLdouble y)
d298 2
a299 2
void GLAPIENTRY
_mesa_WindowPos2f(GLfloat x, GLfloat y)
d304 2
a305 2
void GLAPIENTRY
_mesa_WindowPos2i(GLint x, GLint y)
d310 2
a311 2
void GLAPIENTRY
_mesa_WindowPos2s(GLshort x, GLshort y)
d316 2
a317 2
void GLAPIENTRY
_mesa_WindowPos3d(GLdouble x, GLdouble y, GLdouble z)
d322 2
a323 2
void GLAPIENTRY
_mesa_WindowPos3f(GLfloat x, GLfloat y, GLfloat z)
d328 2
a329 2
void GLAPIENTRY
_mesa_WindowPos3i(GLint x, GLint y, GLint z)
d334 2
a335 2
void GLAPIENTRY
_mesa_WindowPos3s(GLshort x, GLshort y, GLshort z)
d340 1
a340 1
void GLAPIENTRY
d346 1
a346 1
void GLAPIENTRY
d352 1
a352 1
void GLAPIENTRY
d358 1
a358 1
void GLAPIENTRY
d364 2
a365 2
void GLAPIENTRY
_mesa_WindowPos2dv(const GLdouble *v)
d370 2
a371 2
void GLAPIENTRY
_mesa_WindowPos2fv(const GLfloat *v)
d376 2
a377 2
void GLAPIENTRY
_mesa_WindowPos2iv(const GLint *v)
d382 2
a383 2
void GLAPIENTRY
_mesa_WindowPos2sv(const GLshort *v)
d388 2
a389 2
void GLAPIENTRY
_mesa_WindowPos3dv(const GLdouble *v)
d394 2
a395 2
void GLAPIENTRY
_mesa_WindowPos3fv(const GLfloat *v)
d400 2
a401 2
void GLAPIENTRY
_mesa_WindowPos3iv(const GLint *v)
d406 2
a407 2
void GLAPIENTRY
_mesa_WindowPos3sv(const GLshort *v)
d412 1
a412 1
void GLAPIENTRY
d419 1
a419 1
void GLAPIENTRY
d425 1
a425 1
void GLAPIENTRY
d432 1
a432 1
void GLAPIENTRY
d476 59
@


1.1.1.6
log
@Import Mesa 10.2.3
@
text
@d230 2
a231 3
   z2 = CLAMP(z, 0.0F, 1.0F)
      * (ctx->ViewportArray[0].Far - ctx->ViewportArray[0].Near)
      + ctx->ViewportArray[0].Near;
@


