head	1.9;
access;
symbols
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.6.0.2
	OPENBSD_5_6_BASE:1.6
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.5.0.2
	OPENBSD_5_5_BASE:1.5
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.4.0.4
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.2
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.3.0.4
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.2.0.6
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.0.4
	OPENBSD_4_7_BASE:1.1
	OPENBSD_4_6:1.1.0.2
	OPENBSD_4_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.9
date	2015.12.23.05.17.52;	author jsg;	state dead;
branches;
next	1.8;
commitid	TnlogFl9nOv2eaRf;

1.8
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.7;
commitid	4ry2gvZGMXkCUD2n;

1.7
date	2015.01.25.14.41.21;	author jsg;	state Exp;
branches;
next	1.6;
commitid	mcxB0JvoI9gTDYXU;

1.6
date	2014.07.09.21.09.00;	author jsg;	state Exp;
branches;
next	1.5;
commitid	WPD6rgPryPkvXOr9;

1.5
date	2013.09.05.14.06.16;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2012.08.17.13.58.17;	author mpi;	state Exp;
branches;
next	1.3;

1.3
date	2011.10.23.13.37.42;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.05.22.20.06.30;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2009.05.17.20.26.41;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.45;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.16.25;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.58;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.12.27;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.49.34;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.9
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */


/**
 * \file clear.c
 * glClearColor, glClearIndex, glClear() functions.
 */



#include "glheader.h"
#include "clear.h"
#include "context.h"
#include "colormac.h"
#include "enums.h"
#include "macros.h"
#include "mtypes.h"
#include "state.h"



void GLAPIENTRY
_mesa_ClearIndex( GLfloat c )
{
   GET_CURRENT_CONTEXT(ctx);

   ctx->Color.ClearIndex = (GLuint) c;
}


/**
 * Specify the clear values for the color buffers.
 *
 * \param red red color component.
 * \param green green color component.
 * \param blue blue color component.
 * \param alpha alpha component.
 *
 * \sa glClearColor().
 *
 * Clamps the parameters and updates gl_colorbuffer_attrib::ClearColor.  On a
 * change, flushes the vertices and notifies the driver via the
 * dd_function_table::ClearColor callback.
 */
void GLAPIENTRY
_mesa_ClearColor( GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha )
{
   GET_CURRENT_CONTEXT(ctx);

   ctx->Color.ClearColor.f[0] = red;
   ctx->Color.ClearColor.f[1] = green;
   ctx->Color.ClearColor.f[2] = blue;
   ctx->Color.ClearColor.f[3] = alpha;
}


/**
 * GL_EXT_texture_integer
 */
void GLAPIENTRY
_mesa_ClearColorIiEXT(GLint r, GLint g, GLint b, GLint a)
{
   GET_CURRENT_CONTEXT(ctx);

   ctx->Color.ClearColor.i[0] = r;
   ctx->Color.ClearColor.i[1] = g;
   ctx->Color.ClearColor.i[2] = b;
   ctx->Color.ClearColor.i[3] = a;
}


/**
 * GL_EXT_texture_integer
 */
void GLAPIENTRY
_mesa_ClearColorIuiEXT(GLuint r, GLuint g, GLuint b, GLuint a)
{
   GET_CURRENT_CONTEXT(ctx);

   ctx->Color.ClearColor.ui[0] = r;
   ctx->Color.ClearColor.ui[1] = g;
   ctx->Color.ClearColor.ui[2] = b;
   ctx->Color.ClearColor.ui[3] = a;
}


/**
 * Returns true if color writes are enabled for the given color attachment.
 *
 * Beyond checking ColorMask, this uses _mesa_format_has_color_component to
 * ignore components that don't actually exist in the format (such as X in
 * XRGB).
 */
static bool
color_buffer_writes_enabled(const struct gl_context *ctx, unsigned idx)
{
   struct gl_renderbuffer *rb = ctx->DrawBuffer->_ColorDrawBuffers[idx];
   GLuint c;
   GLubyte colorMask = 0;

   if (rb) {
      for (c = 0; c < 4; c++) {
         if (_mesa_format_has_color_component(rb->Format, c))
            colorMask |= ctx->Color.ColorMask[idx][c];
      }
   }

   return colorMask != 0;
}


/**
 * Clear buffers.
 * 
 * \param mask bit-mask indicating the buffers to be cleared.
 *
 * Flushes the vertices and verifies the parameter. If __struct gl_contextRec::NewState
 * is set then calls _mesa_update_state() to update gl_frame_buffer::_Xmin,
 * etc. If the rasterization mode is set to GL_RENDER then requests the driver
 * to clear the buffers, via the dd_function_table::Clear callback.
 */ 
void GLAPIENTRY
_mesa_Clear( GLbitfield mask )
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);

   FLUSH_CURRENT(ctx, 0);

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glClear 0x%x\n", mask);

   if (mask & ~(GL_COLOR_BUFFER_BIT |
                GL_DEPTH_BUFFER_BIT |
                GL_STENCIL_BUFFER_BIT |
                GL_ACCUM_BUFFER_BIT)) {
      /* invalid bit set */
      _mesa_error( ctx, GL_INVALID_VALUE, "glClear(0x%x)", mask);
      return;
   }

   /* Accumulation buffers were removed in core contexts, and they never
    * existed in OpenGL ES.
    */
   if ((mask & GL_ACCUM_BUFFER_BIT) != 0
       && (ctx->API == API_OPENGL_CORE || _mesa_is_gles(ctx))) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glClear(GL_ACCUM_BUFFER_BIT)");
      return;
   }

   if (ctx->NewState) {
      _mesa_update_state( ctx );	/* update _Xmin, etc */
   }

   if (ctx->DrawBuffer->_Status != GL_FRAMEBUFFER_COMPLETE_EXT) {
      _mesa_error(ctx, GL_INVALID_FRAMEBUFFER_OPERATION_EXT,
                  "glClear(incomplete framebuffer)");
      return;
   }

   if (ctx->RasterDiscard)
      return;

   if (ctx->RenderMode == GL_RENDER) {
      GLbitfield bufferMask;

      /* don't clear depth buffer if depth writing disabled */
      if (!ctx->Depth.Mask)
         mask &= ~GL_DEPTH_BUFFER_BIT;

      /* Build the bitmask to send to device driver's Clear function.
       * Note that the GL_COLOR_BUFFER_BIT flag will expand to 0, 1, 2 or 4
       * of the BUFFER_BIT_FRONT/BACK_LEFT/RIGHT flags, or one of the
       * BUFFER_BIT_COLORn flags.
       */
      bufferMask = 0;
      if (mask & GL_COLOR_BUFFER_BIT) {
         GLuint i;
         for (i = 0; i < ctx->DrawBuffer->_NumColorDrawBuffers; i++) {
            GLint buf = ctx->DrawBuffer->_ColorDrawBufferIndexes[i];

            if (buf >= 0 && color_buffer_writes_enabled(ctx, i)) {
               bufferMask |= 1 << buf;
            }
         }
      }

      if ((mask & GL_DEPTH_BUFFER_BIT)
          && ctx->DrawBuffer->Visual.haveDepthBuffer) {
         bufferMask |= BUFFER_BIT_DEPTH;
      }

      if ((mask & GL_STENCIL_BUFFER_BIT)
          && ctx->DrawBuffer->Visual.haveStencilBuffer) {
         bufferMask |= BUFFER_BIT_STENCIL;
      }

      if ((mask & GL_ACCUM_BUFFER_BIT)
          && ctx->DrawBuffer->Visual.haveAccumBuffer) {
         bufferMask |= BUFFER_BIT_ACCUM;
      }

      ASSERT(ctx->Driver.Clear);
      ctx->Driver.Clear(ctx, bufferMask);
   }
}


/** Returned by make_color_buffer_mask() for errors */
#define INVALID_MASK ~0x0


/**
 * Convert the glClearBuffer 'drawbuffer' parameter into a bitmask of
 * BUFFER_BIT_x values.
 * Return INVALID_MASK if the drawbuffer value is invalid.
 */
static GLbitfield
make_color_buffer_mask(struct gl_context *ctx, GLint drawbuffer)
{
   const struct gl_renderbuffer_attachment *att = ctx->DrawBuffer->Attachment;
   GLbitfield mask = 0x0;

   /* From the GL 4.0 specification:
    *	If buffer is COLOR, a particular draw buffer DRAW_BUFFERi is
    *	specified by passing i as the parameter drawbuffer, and value
    *	points to a four-element vector specifying the R, G, B, and A
    *	color to clear that draw buffer to. If the draw buffer is one
    *	of FRONT, BACK, LEFT, RIGHT, or FRONT_AND_BACK, identifying
    *	multiple buffers, each selected buffer is cleared to the same
    *	value.
    *
    * Note that "drawbuffer" and "draw buffer" have different meaning.
    * "drawbuffer" specifies DRAW_BUFFERi, while "draw buffer" is what's
    * assigned to DRAW_BUFFERi. It could be COLOR_ATTACHMENT0, FRONT, BACK,
    * etc.
    */
   if (drawbuffer < 0 || drawbuffer >= (GLint)ctx->Const.MaxDrawBuffers) {
      return INVALID_MASK;
   }

   switch (ctx->DrawBuffer->ColorDrawBuffer[drawbuffer]) {
   case GL_FRONT:
      if (att[BUFFER_FRONT_LEFT].Renderbuffer)
         mask |= BUFFER_BIT_FRONT_LEFT;
      if (att[BUFFER_FRONT_RIGHT].Renderbuffer)
         mask |= BUFFER_BIT_FRONT_RIGHT;
      break;
   case GL_BACK:
      if (att[BUFFER_BACK_LEFT].Renderbuffer)
         mask |= BUFFER_BIT_BACK_LEFT;
      if (att[BUFFER_BACK_RIGHT].Renderbuffer)
         mask |= BUFFER_BIT_BACK_RIGHT;
      break;
   case GL_LEFT:
      if (att[BUFFER_FRONT_LEFT].Renderbuffer)
         mask |= BUFFER_BIT_FRONT_LEFT;
      if (att[BUFFER_BACK_LEFT].Renderbuffer)
         mask |= BUFFER_BIT_BACK_LEFT;
      break;
   case GL_RIGHT:
      if (att[BUFFER_FRONT_RIGHT].Renderbuffer)
         mask |= BUFFER_BIT_FRONT_RIGHT;
      if (att[BUFFER_BACK_RIGHT].Renderbuffer)
         mask |= BUFFER_BIT_BACK_RIGHT;
      break;
   case GL_FRONT_AND_BACK:
      if (att[BUFFER_FRONT_LEFT].Renderbuffer)
         mask |= BUFFER_BIT_FRONT_LEFT;
      if (att[BUFFER_BACK_LEFT].Renderbuffer)
         mask |= BUFFER_BIT_BACK_LEFT;
      if (att[BUFFER_FRONT_RIGHT].Renderbuffer)
         mask |= BUFFER_BIT_FRONT_RIGHT;
      if (att[BUFFER_BACK_RIGHT].Renderbuffer)
         mask |= BUFFER_BIT_BACK_RIGHT;
      break;
   default:
      {
         GLint buf = ctx->DrawBuffer->_ColorDrawBufferIndexes[drawbuffer];

         if (buf >= 0 && att[buf].Renderbuffer) {
            mask |= 1 << buf;
         }
      }
   }

   return mask;
}



/**
 * New in GL 3.0
 * Clear signed integer color buffer or stencil buffer (not depth).
 */
void GLAPIENTRY
_mesa_ClearBufferiv(GLenum buffer, GLint drawbuffer, const GLint *value)
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);

   FLUSH_CURRENT(ctx, 0);

   if (ctx->NewState) {
      _mesa_update_state( ctx );
   }

   switch (buffer) {
   case GL_STENCIL:
      /* Page 264 (page 280 of the PDF) of the OpenGL 3.0 spec says:
       *
       *     "ClearBuffer generates an INVALID VALUE error if buffer is
       *     COLOR and drawbuffer is less than zero, or greater than the
       *     value of MAX DRAW BUFFERS minus one; or if buffer is DEPTH,
       *     STENCIL, or DEPTH STENCIL and drawbuffer is not zero."
       */
      if (drawbuffer != 0) {
         _mesa_error(ctx, GL_INVALID_VALUE, "glClearBufferiv(drawbuffer=%d)",
                     drawbuffer);
         return;
      }
      else if (ctx->DrawBuffer->Attachment[BUFFER_STENCIL].Renderbuffer && !ctx->RasterDiscard) {
         /* Save current stencil clear value, set to 'value', do the
          * stencil clear and restore the clear value.
          * XXX in the future we may have a new ctx->Driver.ClearBuffer()
          * hook instead.
          */
         const GLuint clearSave = ctx->Stencil.Clear;
         ctx->Stencil.Clear = *value;
         ctx->Driver.Clear(ctx, BUFFER_BIT_STENCIL);
         ctx->Stencil.Clear = clearSave;
      }
      break;
   case GL_COLOR:
      {
         const GLbitfield mask = make_color_buffer_mask(ctx, drawbuffer);
         if (mask == INVALID_MASK) {
            _mesa_error(ctx, GL_INVALID_VALUE, "glClearBufferiv(drawbuffer=%d)",
                        drawbuffer);
            return;
         }
         else if (mask && !ctx->RasterDiscard) {
            union gl_color_union clearSave;

            /* save color */
            clearSave = ctx->Color.ClearColor;
            /* set color */
            COPY_4V(ctx->Color.ClearColor.i, value);
            /* clear buffer(s) */
            ctx->Driver.Clear(ctx, mask);
            /* restore color */
            ctx->Color.ClearColor = clearSave;
         }
      }
      break;
   case GL_DEPTH:
      /* Page 264 (page 280 of the PDF) of the OpenGL 3.0 spec says:
       *
       *     "The result of ClearBuffer is undefined if no conversion between
       *     the type of the specified value and the type of the buffer being
       *     cleared is defined (for example, if ClearBufferiv is called for a
       *     fixed- or floating-point buffer, or if ClearBufferfv is called
       *     for a signed or unsigned integer buffer). This is not an error."
       *
       * In this case we take "undefined" and "not an error" to mean "ignore."
       * Note that we still need to generate an error for the invalid
       * drawbuffer case (see the GL_STENCIL case above).
       */
      if (drawbuffer != 0) {
         _mesa_error(ctx, GL_INVALID_VALUE, "glClearBufferiv(drawbuffer=%d)",
                     drawbuffer);
         return;
      }
      return;
   default:
      _mesa_error(ctx, GL_INVALID_ENUM, "glClearBufferiv(buffer=%s)",
                  _mesa_lookup_enum_by_nr(buffer));
      return;
   }
}


/**
 * New in GL 3.0
 * Clear unsigned integer color buffer (not depth, not stencil).
 */
void GLAPIENTRY
_mesa_ClearBufferuiv(GLenum buffer, GLint drawbuffer, const GLuint *value)
{
   GET_CURRENT_CONTEXT(ctx);

   FLUSH_VERTICES(ctx, 0);
   FLUSH_CURRENT(ctx, 0);

   if (ctx->NewState) {
      _mesa_update_state( ctx );
   }

   switch (buffer) {
   case GL_COLOR:
      {
         const GLbitfield mask = make_color_buffer_mask(ctx, drawbuffer);
         if (mask == INVALID_MASK) {
            _mesa_error(ctx, GL_INVALID_VALUE, "glClearBufferuiv(drawbuffer=%d)",
                        drawbuffer);
            return;
         }
         else if (mask && !ctx->RasterDiscard) {
            union gl_color_union clearSave;

            /* save color */
            clearSave = ctx->Color.ClearColor;
            /* set color */
            COPY_4V(ctx->Color.ClearColor.ui, value);
            /* clear buffer(s) */
            ctx->Driver.Clear(ctx, mask);
            /* restore color */
            ctx->Color.ClearColor = clearSave;
         }
      }
      break;
   case GL_DEPTH:
   case GL_STENCIL:
      /* Page 264 (page 280 of the PDF) of the OpenGL 3.0 spec says:
       *
       *     "The result of ClearBuffer is undefined if no conversion between
       *     the type of the specified value and the type of the buffer being
       *     cleared is defined (for example, if ClearBufferiv is called for a
       *     fixed- or floating-point buffer, or if ClearBufferfv is called
       *     for a signed or unsigned integer buffer). This is not an error."
       *
       * In this case we take "undefined" and "not an error" to mean "ignore."
       * Even though we could do something sensible for GL_STENCIL, page 263
       * (page 279 of the PDF) says:
       *
       *     "Only ClearBufferiv should be used to clear stencil buffers."
       *
       * Note that we still need to generate an error for the invalid
       * drawbuffer case (see the GL_STENCIL case in _mesa_ClearBufferiv).
       */
      if (drawbuffer != 0) {
         _mesa_error(ctx, GL_INVALID_VALUE, "glClearBufferuiv(drawbuffer=%d)",
                     drawbuffer);
         return;
      }
      return;
   default:
      _mesa_error(ctx, GL_INVALID_ENUM, "glClearBufferuiv(buffer=%s)",
                  _mesa_lookup_enum_by_nr(buffer));
      return;
   }
}


/**
 * New in GL 3.0
 * Clear fixed-pt or float color buffer or depth buffer (not stencil).
 */
void GLAPIENTRY
_mesa_ClearBufferfv(GLenum buffer, GLint drawbuffer, const GLfloat *value)
{
   GET_CURRENT_CONTEXT(ctx);

   FLUSH_VERTICES(ctx, 0);
   FLUSH_CURRENT(ctx, 0);

   if (ctx->NewState) {
      _mesa_update_state( ctx );
   }

   switch (buffer) {
   case GL_DEPTH:
      /* Page 264 (page 280 of the PDF) of the OpenGL 3.0 spec says:
       *
       *     "ClearBuffer generates an INVALID VALUE error if buffer is
       *     COLOR and drawbuffer is less than zero, or greater than the
       *     value of MAX DRAW BUFFERS minus one; or if buffer is DEPTH,
       *     STENCIL, or DEPTH STENCIL and drawbuffer is not zero."
       */
      if (drawbuffer != 0) {
         _mesa_error(ctx, GL_INVALID_VALUE, "glClearBufferfv(drawbuffer=%d)",
                     drawbuffer);
         return;
      }
      else if (ctx->DrawBuffer->Attachment[BUFFER_DEPTH].Renderbuffer && !ctx->RasterDiscard) {
         /* Save current depth clear value, set to 'value', do the
          * depth clear and restore the clear value.
          * XXX in the future we may have a new ctx->Driver.ClearBuffer()
          * hook instead.
          */
         const GLclampd clearSave = ctx->Depth.Clear;
         ctx->Depth.Clear = *value;
         ctx->Driver.Clear(ctx, BUFFER_BIT_DEPTH);
         ctx->Depth.Clear = clearSave;
      }
      /* clear depth buffer to value */
      break;
   case GL_COLOR:
      {
         const GLbitfield mask = make_color_buffer_mask(ctx, drawbuffer);
         if (mask == INVALID_MASK) {
            _mesa_error(ctx, GL_INVALID_VALUE, "glClearBufferfv(drawbuffer=%d)",
                        drawbuffer);
            return;
         }
         else if (mask && !ctx->RasterDiscard) {
            union gl_color_union clearSave;

            /* save color */
            clearSave = ctx->Color.ClearColor;
            /* set color */
            COPY_4V(ctx->Color.ClearColor.f, value);
            /* clear buffer(s) */
            ctx->Driver.Clear(ctx, mask);
            /* restore color */
            ctx->Color.ClearColor = clearSave;
         }
      }
      break;
   case GL_STENCIL:
      /* Page 264 (page 280 of the PDF) of the OpenGL 3.0 spec says:
       *
       *     "The result of ClearBuffer is undefined if no conversion between
       *     the type of the specified value and the type of the buffer being
       *     cleared is defined (for example, if ClearBufferiv is called for a
       *     fixed- or floating-point buffer, or if ClearBufferfv is called
       *     for a signed or unsigned integer buffer). This is not an error."
       *
       * In this case we take "undefined" and "not an error" to mean "ignore."
       * Note that we still need to generate an error for the invalid
       * drawbuffer case (see the GL_DEPTH case above).
       */
      if (drawbuffer != 0) {
         _mesa_error(ctx, GL_INVALID_VALUE, "glClearBufferfv(drawbuffer=%d)",
                     drawbuffer);
         return;
      }
      return;
   default:
      _mesa_error(ctx, GL_INVALID_ENUM, "glClearBufferfv(buffer=%s)",
                  _mesa_lookup_enum_by_nr(buffer));
      return;
   }
}


/**
 * New in GL 3.0
 * Clear depth/stencil buffer only.
 */
void GLAPIENTRY
_mesa_ClearBufferfi(GLenum buffer, GLint drawbuffer,
                    GLfloat depth, GLint stencil)
{
   GET_CURRENT_CONTEXT(ctx);
   GLbitfield mask = 0;

   FLUSH_VERTICES(ctx, 0);
   FLUSH_CURRENT(ctx, 0);

   if (buffer != GL_DEPTH_STENCIL) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glClearBufferfi(buffer=%s)",
                  _mesa_lookup_enum_by_nr(buffer));
      return;
   }

   /* Page 264 (page 280 of the PDF) of the OpenGL 3.0 spec says:
    *
    *     "ClearBuffer generates an INVALID VALUE error if buffer is
    *     COLOR and drawbuffer is less than zero, or greater than the
    *     value of MAX DRAW BUFFERS minus one; or if buffer is DEPTH,
    *     STENCIL, or DEPTH STENCIL and drawbuffer is not zero."
    */
   if (drawbuffer != 0) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glClearBufferfi(drawbuffer=%d)",
                  drawbuffer);
      return;
   }

   if (ctx->RasterDiscard)
      return;

   if (ctx->NewState) {
      _mesa_update_state( ctx );
   }

   if (ctx->DrawBuffer->Attachment[BUFFER_DEPTH].Renderbuffer)
      mask |= BUFFER_BIT_DEPTH;
   if (ctx->DrawBuffer->Attachment[BUFFER_STENCIL].Renderbuffer)
      mask |= BUFFER_BIT_STENCIL;

   if (mask) {
      /* save current clear values */
      const GLclampd clearDepthSave = ctx->Depth.Clear;
      const GLuint clearStencilSave = ctx->Stencil.Clear;

      /* set new clear values */
      ctx->Depth.Clear = depth;
      ctx->Stencil.Clear = stencil;

      /* clear buffers */
      ctx->Driver.Clear(ctx, mask);

      /* restore */
      ctx->Depth.Clear = clearDepthSave;
      ctx->Stencil.Clear = clearStencilSave;
   }
}
@


1.8
log
@Merge Mesa 10.2.9
@
text
@@


1.7
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d36 1
@


1.6
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@a35 1
#include "colormac.h"
@


1.5
log
@Merge Mesa 9.2.0
@
text
@d110 25
a182 5
   if (ctx->DrawBuffer->Width == 0 || ctx->DrawBuffer->Height == 0 ||
       ctx->DrawBuffer->_Xmin >= ctx->DrawBuffer->_Xmax ||
       ctx->DrawBuffer->_Ymin >= ctx->DrawBuffer->_Ymax)
      return;

d202 5
a206 1
            bufferMask |= (1 << ctx->DrawBuffer->_ColorDrawBufferIndexes[i]);
d246 19
a264 1
   switch (drawbuffer) {
d300 6
a305 5
      if (drawbuffer < 0 || drawbuffer >= (GLint)ctx->Const.MaxDrawBuffers) {
         mask = INVALID_MASK;
      }
      else if (att[BUFFER_COLOR0 + drawbuffer].Renderbuffer) {
         mask |= (BUFFER_BIT_COLOR0 << drawbuffer);
@


1.4
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a2 1
 * Version:  7.1
d19 4
a22 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
a43 1
#if _HAVE_FULL_GL
a47 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
a48 4
   if (ctx->Color.ClearIndex == (GLuint) c)
      return;

   FLUSH_VERTICES(ctx, _NEW_COLOR);
a50 1
#endif
a69 1
   GLfloat tmp[4];
a70 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d72 4
a75 23
   tmp[0] = red;
   tmp[1] = green;
   tmp[2] = blue;
   tmp[3] = alpha;

   if (TEST_EQ_4V(tmp, ctx->Color.ClearColorUnclamped))
      return; /* no change */

   FLUSH_VERTICES(ctx, _NEW_COLOR);
   COPY_4V(ctx->Color.ClearColorUnclamped, tmp);

   ctx->Color.ClearColor[0] = CLAMP(tmp[0], 0.0F, 1.0F);
   ctx->Color.ClearColor[1] = CLAMP(tmp[1], 0.0F, 1.0F);
   ctx->Color.ClearColor[2] = CLAMP(tmp[2], 0.0F, 1.0F);
   ctx->Color.ClearColor[3] = CLAMP(tmp[3], 0.0F, 1.0F);

   if (ctx->Driver.ClearColor) {
      /* it's OK to call glClearColor in CI mode but it should be a NOP */
      /* we pass the clamped color, since all drivers that need this don't
       * support GL_ARB_color_buffer_float
       */
      (*ctx->Driver.ClearColor)(ctx, ctx->Color.ClearColor);
   }
a84 1
   GLfloat tmp[4];
a85 11
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   tmp[0] = (GLfloat) r;
   tmp[1] = (GLfloat) g;
   tmp[2] = (GLfloat) b;
   tmp[3] = (GLfloat) a;

   if (TEST_EQ_4V(tmp, ctx->Color.ClearColor))
      return; /* no change */

   FLUSH_VERTICES(ctx, _NEW_COLOR);
d87 4
a90 8
   /* XXX we should eventually have a float/int/uint union for
    * the ctx->Color.ClearColor state.
    */
   COPY_4V(ctx->Color.ClearColor, tmp);

   if (ctx->Driver.ClearColor) {
      ctx->Driver.ClearColor(ctx, ctx->Color.ClearColor);
   }
a99 1
   GLfloat tmp[4];
a100 16
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   tmp[0] = (GLfloat) r;
   tmp[1] = (GLfloat) g;
   tmp[2] = (GLfloat) b;
   tmp[3] = (GLfloat) a;

   if (TEST_EQ_4V(tmp, ctx->Color.ClearColor))
      return; /* no change */

   FLUSH_VERTICES(ctx, _NEW_COLOR);

   /* XXX we should eventually have a float/int/uint union for
    * the ctx->Color.ClearColor state.
    */
   COPY_4V(ctx->Color.ClearColor, tmp);
d102 4
a105 3
   if (ctx->Driver.ClearColor) {
      ctx->Driver.ClearColor(ctx, ctx->Color.ClearColor);
   }
d123 1
a123 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d139 9
d163 3
d279 1
a279 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d289 7
d301 1
a301 1
      else {
a308 2
         if (ctx->Driver.ClearStencil)
            ctx->Driver.ClearStencil(ctx, *value);
a310 2
         if (ctx->Driver.ClearStencil)
            ctx->Driver.ClearStencil(ctx, clearSave);
d321 3
a323 6
         else if (mask) {
            /* XXX note: we're putting the integer clear values into the
             * floating point state var.  This will not always work.  We'll
             * need a new ctx->Driver.ClearBuffer() hook....
             */
            GLclampf clearSave[4];
d325 1
a325 1
            COPY_4V(clearSave, ctx->Color.ClearColor);
d327 1
a327 3
            COPY_4V_CAST(ctx->Color.ClearColor, value, GLclampf);
            if (ctx->Driver.ClearColor)
               ctx->Driver.ClearColor(ctx, ctx->Color.ClearColor);
d331 1
a331 3
            COPY_4V(ctx->Color.ClearColor, clearSave);
            if (ctx->Driver.ClearColor)
               ctx->Driver.ClearColor(ctx, clearSave);
d335 19
a369 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d371 1
d387 3
a389 6
         else if (mask) {
            /* XXX note: we're putting the uint clear values into the
             * floating point state var.  This will not always work.  We'll
             * need a new ctx->Driver.ClearBuffer() hook....
             */
            GLclampf clearSave[4];
d391 1
a391 1
            COPY_4V(clearSave, ctx->Color.ClearColor);
d393 1
a393 3
            COPY_4V_CAST(ctx->Color.ClearColor, value, GLclampf);
            if (ctx->Driver.ClearColor)
               ctx->Driver.ClearColor(ctx, ctx->Color.ClearColor);
d397 1
a397 3
            COPY_4V(ctx->Color.ClearColor, clearSave);
            if (ctx->Driver.ClearColor)
               ctx->Driver.ClearColor(ctx, clearSave);
d401 25
a441 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d443 1
d452 7
d464 1
a464 1
      else {
a471 2
         if (ctx->Driver.ClearDepth)
            ctx->Driver.ClearDepth(ctx, *value);
a473 2
         if (ctx->Driver.ClearDepth)
            ctx->Driver.ClearDepth(ctx, clearSave);
d485 3
a487 2
         else if (mask) {
            GLclampf clearSave[4];
d489 1
a489 1
            COPY_4V(clearSave, ctx->Color.ClearColor);
d491 1
a491 3
            COPY_4V_CAST(ctx->Color.ClearColor, value, GLclampf);
            if (ctx->Driver.ClearColor)
               ctx->Driver.ClearColor(ctx, ctx->Color.ClearColor);
d495 1
a495 3
            COPY_4V(ctx->Color.ClearColor, clearSave);
            if (ctx->Driver.ClearColor)
               ctx->Driver.ClearColor(ctx, clearSave);
d499 19
d535 1
a535 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d537 1
d546 7
d559 3
d566 6
a571 1
   {
a578 4
      if (ctx->Driver.ClearDepth)
         ctx->Driver.ClearDepth(ctx, depth);
      if (ctx->Driver.ClearStencil)
         ctx->Driver.ClearStencil(ctx, stencil);
d581 1
a581 1
      ctx->Driver.Clear(ctx, BUFFER_BIT_DEPTH | BUFFER_BIT_STENCIL);
a585 4
      if (ctx->Driver.ClearDepth)
         ctx->Driver.ClearDepth(ctx, clearDepthSave);
      if (ctx->Driver.ClearStencil)
         ctx->Driver.ClearStencil(ctx, clearStencilSave);
@


1.3
log
@Merge Mesa 7.10.3
@
text
@d39 1
d81 4
a84 4
   tmp[0] = CLAMP(red,   0.0F, 1.0F);
   tmp[1] = CLAMP(green, 0.0F, 1.0F);
   tmp[2] = CLAMP(blue,  0.0F, 1.0F);
   tmp[3] = CLAMP(alpha, 0.0F, 1.0F);
d86 1
a86 1
   if (TEST_EQ_4V(tmp, ctx->Color.ClearColor))
d90 6
a95 1
   COPY_4V(ctx->Color.ClearColor, tmp);
d99 3
@


1.2
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d38 1
d99 62
d165 1
a165 1
 * Flushes the vertices and verifies the parameter. If __GLcontextRec::NewState
d256 1
a256 1
make_color_buffer_mask(GLcontext *ctx, GLint drawbuffer)
d407 1
a407 1
            _mesa_error(ctx, GL_INVALID_VALUE, "glClearBufferiv(drawbuffer=%d)",
@


1.1
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d37 1
a53 5

   if (!ctx->Visual.rgbMode && ctx->Driver.ClearIndex) {
      /* it's OK to call glClearIndex in RGBA mode but it should be a NOP */
      (*ctx->Driver.ClearIndex)( ctx, ctx->Color.ClearIndex );
   }
d90 1
a90 1
   if (ctx->Visual.rgbMode && ctx->Driver.ClearColor) {
d179 323
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a36 2
#include "enums.h"
#include "macros.h"
d53 5
d94 1
a94 1
   if (ctx->Driver.ClearColor) {
a101 62
 * GL_EXT_texture_integer
 */
void GLAPIENTRY
_mesa_ClearColorIiEXT(GLint r, GLint g, GLint b, GLint a)
{
   GLfloat tmp[4];
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   tmp[0] = (GLfloat) r;
   tmp[1] = (GLfloat) g;
   tmp[2] = (GLfloat) b;
   tmp[3] = (GLfloat) a;

   if (TEST_EQ_4V(tmp, ctx->Color.ClearColor))
      return; /* no change */

   FLUSH_VERTICES(ctx, _NEW_COLOR);

   /* XXX we should eventually have a float/int/uint union for
    * the ctx->Color.ClearColor state.
    */
   COPY_4V(ctx->Color.ClearColor, tmp);

   if (ctx->Driver.ClearColor) {
      ctx->Driver.ClearColor(ctx, ctx->Color.ClearColor);
   }
}


/**
 * GL_EXT_texture_integer
 */
void GLAPIENTRY
_mesa_ClearColorIuiEXT(GLuint r, GLuint g, GLuint b, GLuint a)
{
   GLfloat tmp[4];
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   tmp[0] = (GLfloat) r;
   tmp[1] = (GLfloat) g;
   tmp[2] = (GLfloat) b;
   tmp[3] = (GLfloat) a;

   if (TEST_EQ_4V(tmp, ctx->Color.ClearColor))
      return; /* no change */

   FLUSH_VERTICES(ctx, _NEW_COLOR);

   /* XXX we should eventually have a float/int/uint union for
    * the ctx->Color.ClearColor state.
    */
   COPY_4V(ctx->Color.ClearColor, tmp);

   if (ctx->Driver.ClearColor) {
      ctx->Driver.ClearColor(ctx, ctx->Color.ClearColor);
   }
}


/**
d106 1
a106 1
 * Flushes the vertices and verifies the parameter. If __struct gl_contextRec::NewState
a182 323
   }
}


/** Returned by make_color_buffer_mask() for errors */
#define INVALID_MASK ~0x0


/**
 * Convert the glClearBuffer 'drawbuffer' parameter into a bitmask of
 * BUFFER_BIT_x values.
 * Return INVALID_MASK if the drawbuffer value is invalid.
 */
static GLbitfield
make_color_buffer_mask(struct gl_context *ctx, GLint drawbuffer)
{
   const struct gl_renderbuffer_attachment *att = ctx->DrawBuffer->Attachment;
   GLbitfield mask = 0x0;

   switch (drawbuffer) {
   case GL_FRONT:
      if (att[BUFFER_FRONT_LEFT].Renderbuffer)
         mask |= BUFFER_BIT_FRONT_LEFT;
      if (att[BUFFER_FRONT_RIGHT].Renderbuffer)
         mask |= BUFFER_BIT_FRONT_RIGHT;
      break;
   case GL_BACK:
      if (att[BUFFER_BACK_LEFT].Renderbuffer)
         mask |= BUFFER_BIT_BACK_LEFT;
      if (att[BUFFER_BACK_RIGHT].Renderbuffer)
         mask |= BUFFER_BIT_BACK_RIGHT;
      break;
   case GL_LEFT:
      if (att[BUFFER_FRONT_LEFT].Renderbuffer)
         mask |= BUFFER_BIT_FRONT_LEFT;
      if (att[BUFFER_BACK_LEFT].Renderbuffer)
         mask |= BUFFER_BIT_BACK_LEFT;
      break;
   case GL_RIGHT:
      if (att[BUFFER_FRONT_RIGHT].Renderbuffer)
         mask |= BUFFER_BIT_FRONT_RIGHT;
      if (att[BUFFER_BACK_RIGHT].Renderbuffer)
         mask |= BUFFER_BIT_BACK_RIGHT;
      break;
   case GL_FRONT_AND_BACK:
      if (att[BUFFER_FRONT_LEFT].Renderbuffer)
         mask |= BUFFER_BIT_FRONT_LEFT;
      if (att[BUFFER_BACK_LEFT].Renderbuffer)
         mask |= BUFFER_BIT_BACK_LEFT;
      if (att[BUFFER_FRONT_RIGHT].Renderbuffer)
         mask |= BUFFER_BIT_FRONT_RIGHT;
      if (att[BUFFER_BACK_RIGHT].Renderbuffer)
         mask |= BUFFER_BIT_BACK_RIGHT;
      break;
   default:
      if (drawbuffer < 0 || drawbuffer >= (GLint)ctx->Const.MaxDrawBuffers) {
         mask = INVALID_MASK;
      }
      else if (att[BUFFER_COLOR0 + drawbuffer].Renderbuffer) {
         mask |= (BUFFER_BIT_COLOR0 << drawbuffer);
      }
   }

   return mask;
}



/**
 * New in GL 3.0
 * Clear signed integer color buffer or stencil buffer (not depth).
 */
void GLAPIENTRY
_mesa_ClearBufferiv(GLenum buffer, GLint drawbuffer, const GLint *value)
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

   FLUSH_CURRENT(ctx, 0);

   if (ctx->NewState) {
      _mesa_update_state( ctx );
   }

   switch (buffer) {
   case GL_STENCIL:
      if (drawbuffer != 0) {
         _mesa_error(ctx, GL_INVALID_VALUE, "glClearBufferiv(drawbuffer=%d)",
                     drawbuffer);
         return;
      }
      else {
         /* Save current stencil clear value, set to 'value', do the
          * stencil clear and restore the clear value.
          * XXX in the future we may have a new ctx->Driver.ClearBuffer()
          * hook instead.
          */
         const GLuint clearSave = ctx->Stencil.Clear;
         ctx->Stencil.Clear = *value;
         if (ctx->Driver.ClearStencil)
            ctx->Driver.ClearStencil(ctx, *value);
         ctx->Driver.Clear(ctx, BUFFER_BIT_STENCIL);
         ctx->Stencil.Clear = clearSave;
         if (ctx->Driver.ClearStencil)
            ctx->Driver.ClearStencil(ctx, clearSave);
      }
      break;
   case GL_COLOR:
      {
         const GLbitfield mask = make_color_buffer_mask(ctx, drawbuffer);
         if (mask == INVALID_MASK) {
            _mesa_error(ctx, GL_INVALID_VALUE, "glClearBufferiv(drawbuffer=%d)",
                        drawbuffer);
            return;
         }
         else if (mask) {
            /* XXX note: we're putting the integer clear values into the
             * floating point state var.  This will not always work.  We'll
             * need a new ctx->Driver.ClearBuffer() hook....
             */
            GLclampf clearSave[4];
            /* save color */
            COPY_4V(clearSave, ctx->Color.ClearColor);
            /* set color */
            COPY_4V_CAST(ctx->Color.ClearColor, value, GLclampf);
            if (ctx->Driver.ClearColor)
               ctx->Driver.ClearColor(ctx, ctx->Color.ClearColor);
            /* clear buffer(s) */
            ctx->Driver.Clear(ctx, mask);
            /* restore color */
            COPY_4V(ctx->Color.ClearColor, clearSave);
            if (ctx->Driver.ClearColor)
               ctx->Driver.ClearColor(ctx, clearSave);
         }
      }
      break;
   default:
      _mesa_error(ctx, GL_INVALID_ENUM, "glClearBufferiv(buffer=%s)",
                  _mesa_lookup_enum_by_nr(buffer));
      return;
   }
}


/**
 * New in GL 3.0
 * Clear unsigned integer color buffer (not depth, not stencil).
 */
void GLAPIENTRY
_mesa_ClearBufferuiv(GLenum buffer, GLint drawbuffer, const GLuint *value)
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

   FLUSH_CURRENT(ctx, 0);

   if (ctx->NewState) {
      _mesa_update_state( ctx );
   }

   switch (buffer) {
   case GL_COLOR:
      {
         const GLbitfield mask = make_color_buffer_mask(ctx, drawbuffer);
         if (mask == INVALID_MASK) {
            _mesa_error(ctx, GL_INVALID_VALUE, "glClearBufferuiv(drawbuffer=%d)",
                        drawbuffer);
            return;
         }
         else if (mask) {
            /* XXX note: we're putting the uint clear values into the
             * floating point state var.  This will not always work.  We'll
             * need a new ctx->Driver.ClearBuffer() hook....
             */
            GLclampf clearSave[4];
            /* save color */
            COPY_4V(clearSave, ctx->Color.ClearColor);
            /* set color */
            COPY_4V_CAST(ctx->Color.ClearColor, value, GLclampf);
            if (ctx->Driver.ClearColor)
               ctx->Driver.ClearColor(ctx, ctx->Color.ClearColor);
            /* clear buffer(s) */
            ctx->Driver.Clear(ctx, mask);
            /* restore color */
            COPY_4V(ctx->Color.ClearColor, clearSave);
            if (ctx->Driver.ClearColor)
               ctx->Driver.ClearColor(ctx, clearSave);
         }
      }
      break;
   default:
      _mesa_error(ctx, GL_INVALID_ENUM, "glClearBufferuiv(buffer=%s)",
                  _mesa_lookup_enum_by_nr(buffer));
      return;
   }
}


/**
 * New in GL 3.0
 * Clear fixed-pt or float color buffer or depth buffer (not stencil).
 */
void GLAPIENTRY
_mesa_ClearBufferfv(GLenum buffer, GLint drawbuffer, const GLfloat *value)
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

   FLUSH_CURRENT(ctx, 0);

   if (ctx->NewState) {
      _mesa_update_state( ctx );
   }

   switch (buffer) {
   case GL_DEPTH:
      if (drawbuffer != 0) {
         _mesa_error(ctx, GL_INVALID_VALUE, "glClearBufferfv(drawbuffer=%d)",
                     drawbuffer);
         return;
      }
      else {
         /* Save current depth clear value, set to 'value', do the
          * depth clear and restore the clear value.
          * XXX in the future we may have a new ctx->Driver.ClearBuffer()
          * hook instead.
          */
         const GLclampd clearSave = ctx->Depth.Clear;
         ctx->Depth.Clear = *value;
         if (ctx->Driver.ClearDepth)
            ctx->Driver.ClearDepth(ctx, *value);
         ctx->Driver.Clear(ctx, BUFFER_BIT_DEPTH);
         ctx->Depth.Clear = clearSave;
         if (ctx->Driver.ClearDepth)
            ctx->Driver.ClearDepth(ctx, clearSave);
      }
      /* clear depth buffer to value */
      break;
   case GL_COLOR:
      {
         const GLbitfield mask = make_color_buffer_mask(ctx, drawbuffer);
         if (mask == INVALID_MASK) {
            _mesa_error(ctx, GL_INVALID_VALUE, "glClearBufferfv(drawbuffer=%d)",
                        drawbuffer);
            return;
         }
         else if (mask) {
            GLclampf clearSave[4];
            /* save color */
            COPY_4V(clearSave, ctx->Color.ClearColor);
            /* set color */
            COPY_4V_CAST(ctx->Color.ClearColor, value, GLclampf);
            if (ctx->Driver.ClearColor)
               ctx->Driver.ClearColor(ctx, ctx->Color.ClearColor);
            /* clear buffer(s) */
            ctx->Driver.Clear(ctx, mask);
            /* restore color */
            COPY_4V(ctx->Color.ClearColor, clearSave);
            if (ctx->Driver.ClearColor)
               ctx->Driver.ClearColor(ctx, clearSave);
         }
      }
      break;
   default:
      _mesa_error(ctx, GL_INVALID_ENUM, "glClearBufferfv(buffer=%s)",
                  _mesa_lookup_enum_by_nr(buffer));
      return;
   }
}


/**
 * New in GL 3.0
 * Clear depth/stencil buffer only.
 */
void GLAPIENTRY
_mesa_ClearBufferfi(GLenum buffer, GLint drawbuffer,
                    GLfloat depth, GLint stencil)
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

   FLUSH_CURRENT(ctx, 0);

   if (buffer != GL_DEPTH_STENCIL) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glClearBufferfi(buffer=%s)",
                  _mesa_lookup_enum_by_nr(buffer));
      return;
   }

   if (drawbuffer != 0) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glClearBufferfi(drawbuffer=%d)",
                  drawbuffer);
      return;
   }

   if (ctx->NewState) {
      _mesa_update_state( ctx );
   }

   {
      /* save current clear values */
      const GLclampd clearDepthSave = ctx->Depth.Clear;
      const GLuint clearStencilSave = ctx->Stencil.Clear;

      /* set new clear values */
      ctx->Depth.Clear = depth;
      ctx->Stencil.Clear = stencil;
      if (ctx->Driver.ClearDepth)
         ctx->Driver.ClearDepth(ctx, depth);
      if (ctx->Driver.ClearStencil)
         ctx->Driver.ClearStencil(ctx, stencil);

      /* clear buffers */
      ctx->Driver.Clear(ctx, BUFFER_BIT_DEPTH | BUFFER_BIT_STENCIL);

      /* restore */
      ctx->Depth.Clear = clearDepthSave;
      ctx->Stencil.Clear = clearStencilSave;
      if (ctx->Driver.ClearDepth)
         ctx->Driver.ClearDepth(ctx, clearDepthSave);
      if (ctx->Driver.ClearStencil)
         ctx->Driver.ClearStencil(ctx, clearStencilSave);
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d3 1
d20 3
a22 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
a38 1
#include "mtypes.h"
d43 1
d48 1
d50 4
d56 1
d76 1
d78 1
d80 15
a94 4
   ctx->Color.ClearColor.f[0] = red;
   ctx->Color.ClearColor.f[1] = green;
   ctx->Color.ClearColor.f[2] = blue;
   ctx->Color.ClearColor.f[3] = alpha;
d104 1
d106 16
d123 3
a125 4
   ctx->Color.ClearColor.i[0] = r;
   ctx->Color.ClearColor.i[1] = g;
   ctx->Color.ClearColor.i[2] = b;
   ctx->Color.ClearColor.i[3] = a;
d135 1
d137 16
d154 3
a156 4
   ctx->Color.ClearColor.ui[0] = r;
   ctx->Color.ClearColor.ui[1] = g;
   ctx->Color.ClearColor.ui[2] = b;
   ctx->Color.ClearColor.ui[3] = a;
d174 1
a174 1
   FLUSH_VERTICES(ctx, 0);
a189 9
   /* Accumulation buffers were removed in core contexts, and they never
    * existed in OpenGL ES.
    */
   if ((mask & GL_ACCUM_BUFFER_BIT) != 0
       && (ctx->API == API_OPENGL_CORE || _mesa_is_gles(ctx))) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glClear(GL_ACCUM_BUFFER_BIT)");
      return;
   }

a204 3
   if (ctx->RasterDiscard)
      return;

d318 1
a318 1
   FLUSH_VERTICES(ctx, 0);
a327 7
      /* Page 264 (page 280 of the PDF) of the OpenGL 3.0 spec says:
       *
       *     "ClearBuffer generates an INVALID VALUE error if buffer is
       *     COLOR and drawbuffer is less than zero, or greater than the
       *     value of MAX DRAW BUFFERS minus one; or if buffer is DEPTH,
       *     STENCIL, or DEPTH STENCIL and drawbuffer is not zero."
       */
d333 1
a333 1
      else if (ctx->DrawBuffer->Attachment[BUFFER_STENCIL].Renderbuffer && !ctx->RasterDiscard) {
d341 2
d345 2
d357 6
a362 3
         else if (mask && !ctx->RasterDiscard) {
            union gl_color_union clearSave;

d364 1
a364 1
            clearSave = ctx->Color.ClearColor;
d366 3
a368 1
            COPY_4V(ctx->Color.ClearColor.i, value);
d372 3
a374 1
            ctx->Color.ClearColor = clearSave;
a377 19
   case GL_DEPTH:
      /* Page 264 (page 280 of the PDF) of the OpenGL 3.0 spec says:
       *
       *     "The result of ClearBuffer is undefined if no conversion between
       *     the type of the specified value and the type of the buffer being
       *     cleared is defined (for example, if ClearBufferiv is called for a
       *     fixed- or floating-point buffer, or if ClearBufferfv is called
       *     for a signed or unsigned integer buffer). This is not an error."
       *
       * In this case we take "undefined" and "not an error" to mean "ignore."
       * Note that we still need to generate an error for the invalid
       * drawbuffer case (see the GL_STENCIL case above).
       */
      if (drawbuffer != 0) {
         _mesa_error(ctx, GL_INVALID_VALUE, "glClearBufferiv(drawbuffer=%d)",
                     drawbuffer);
         return;
      }
      return;
d394 1
a395 1
   FLUSH_VERTICES(ctx, 0);
d411 6
a416 3
         else if (mask && !ctx->RasterDiscard) {
            union gl_color_union clearSave;

d418 1
a418 1
            clearSave = ctx->Color.ClearColor;
d420 3
a422 1
            COPY_4V(ctx->Color.ClearColor.ui, value);
d426 3
a428 1
            ctx->Color.ClearColor = clearSave;
a431 25
   case GL_DEPTH:
   case GL_STENCIL:
      /* Page 264 (page 280 of the PDF) of the OpenGL 3.0 spec says:
       *
       *     "The result of ClearBuffer is undefined if no conversion between
       *     the type of the specified value and the type of the buffer being
       *     cleared is defined (for example, if ClearBufferiv is called for a
       *     fixed- or floating-point buffer, or if ClearBufferfv is called
       *     for a signed or unsigned integer buffer). This is not an error."
       *
       * In this case we take "undefined" and "not an error" to mean "ignore."
       * Even though we could do something sensible for GL_STENCIL, page 263
       * (page 279 of the PDF) says:
       *
       *     "Only ClearBufferiv should be used to clear stencil buffers."
       *
       * Note that we still need to generate an error for the invalid
       * drawbuffer case (see the GL_STENCIL case in _mesa_ClearBufferiv).
       */
      if (drawbuffer != 0) {
         _mesa_error(ctx, GL_INVALID_VALUE, "glClearBufferuiv(drawbuffer=%d)",
                     drawbuffer);
         return;
      }
      return;
d448 1
a449 1
   FLUSH_VERTICES(ctx, 0);
a457 7
      /* Page 264 (page 280 of the PDF) of the OpenGL 3.0 spec says:
       *
       *     "ClearBuffer generates an INVALID VALUE error if buffer is
       *     COLOR and drawbuffer is less than zero, or greater than the
       *     value of MAX DRAW BUFFERS minus one; or if buffer is DEPTH,
       *     STENCIL, or DEPTH STENCIL and drawbuffer is not zero."
       */
d463 1
a463 1
      else if (ctx->DrawBuffer->Attachment[BUFFER_DEPTH].Renderbuffer && !ctx->RasterDiscard) {
d471 2
d475 2
d488 2
a489 3
         else if (mask && !ctx->RasterDiscard) {
            union gl_color_union clearSave;

d491 1
a491 1
            clearSave = ctx->Color.ClearColor;
d493 3
a495 1
            COPY_4V(ctx->Color.ClearColor.f, value);
d499 3
a501 1
            ctx->Color.ClearColor = clearSave;
a504 19
   case GL_STENCIL:
      /* Page 264 (page 280 of the PDF) of the OpenGL 3.0 spec says:
       *
       *     "The result of ClearBuffer is undefined if no conversion between
       *     the type of the specified value and the type of the buffer being
       *     cleared is defined (for example, if ClearBufferiv is called for a
       *     fixed- or floating-point buffer, or if ClearBufferfv is called
       *     for a signed or unsigned integer buffer). This is not an error."
       *
       * In this case we take "undefined" and "not an error" to mean "ignore."
       * Note that we still need to generate an error for the invalid
       * drawbuffer case (see the GL_DEPTH case above).
       */
      if (drawbuffer != 0) {
         _mesa_error(ctx, GL_INVALID_VALUE, "glClearBufferfv(drawbuffer=%d)",
                     drawbuffer);
         return;
      }
      return;
d522 1
a522 1
   GLbitfield mask = 0;
a523 1
   FLUSH_VERTICES(ctx, 0);
a531 7
   /* Page 264 (page 280 of the PDF) of the OpenGL 3.0 spec says:
    *
    *     "ClearBuffer generates an INVALID VALUE error if buffer is
    *     COLOR and drawbuffer is less than zero, or greater than the
    *     value of MAX DRAW BUFFERS minus one; or if buffer is DEPTH,
    *     STENCIL, or DEPTH STENCIL and drawbuffer is not zero."
    */
a537 3
   if (ctx->RasterDiscard)
      return;

d542 1
a542 6
   if (ctx->DrawBuffer->Attachment[BUFFER_DEPTH].Renderbuffer)
      mask |= BUFFER_BIT_DEPTH;
   if (ctx->DrawBuffer->Attachment[BUFFER_STENCIL].Renderbuffer)
      mask |= BUFFER_BIT_STENCIL;

   if (mask) {
d550 4
d556 1
a556 1
      ctx->Driver.Clear(ctx, mask);
d561 4
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@a109 25
 * Returns true if color writes are enabled for the given color attachment.
 *
 * Beyond checking ColorMask, this uses _mesa_format_has_color_component to
 * ignore components that don't actually exist in the format (such as X in
 * XRGB).
 */
static bool
color_buffer_writes_enabled(const struct gl_context *ctx, unsigned idx)
{
   struct gl_renderbuffer *rb = ctx->DrawBuffer->_ColorDrawBuffers[idx];
   GLuint c;
   GLubyte colorMask = 0;

   if (rb) {
      for (c = 0; c < 4; c++) {
         if (_mesa_format_has_color_component(rb->Format, c))
            colorMask |= ctx->Color.ColorMask[idx][c];
      }
   }

   return colorMask != 0;
}


/**
d158 5
d182 1
a182 5
            GLint buf = ctx->DrawBuffer->_ColorDrawBufferIndexes[i];

            if (buf >= 0 && color_buffer_writes_enabled(ctx, i)) {
               bufferMask |= 1 << buf;
            }
d222 1
a222 19
   /* From the GL 4.0 specification:
    *	If buffer is COLOR, a particular draw buffer DRAW_BUFFERi is
    *	specified by passing i as the parameter drawbuffer, and value
    *	points to a four-element vector specifying the R, G, B, and A
    *	color to clear that draw buffer to. If the draw buffer is one
    *	of FRONT, BACK, LEFT, RIGHT, or FRONT_AND_BACK, identifying
    *	multiple buffers, each selected buffer is cleared to the same
    *	value.
    *
    * Note that "drawbuffer" and "draw buffer" have different meaning.
    * "drawbuffer" specifies DRAW_BUFFERi, while "draw buffer" is what's
    * assigned to DRAW_BUFFERi. It could be COLOR_ATTACHMENT0, FRONT, BACK,
    * etc.
    */
   if (drawbuffer < 0 || drawbuffer >= (GLint)ctx->Const.MaxDrawBuffers) {
      return INVALID_MASK;
   }

   switch (ctx->DrawBuffer->ColorDrawBuffer[drawbuffer]) {
d258 5
a262 6
      {
         GLint buf = ctx->DrawBuffer->_ColorDrawBufferIndexes[drawbuffer];

         if (buf >= 0 && att[buf].Renderbuffer) {
            mask |= 1 << buf;
         }
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d36 1
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@a35 1
#include "colormac.h"
@


