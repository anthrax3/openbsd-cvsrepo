head	1.6;
access;
symbols
	OPENBSD_5_8:1.5.0.4
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5
	v10_2_9:1.1.1.4
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.2
	OPENBSD_5_6:1.3.0.2
	OPENBSD_5_6_BASE:1.3
	v10_2_3:1.1.1.2
	OPENBSD_5_5:1.2.0.2
	OPENBSD_5_5_BASE:1.2
	v9_2_5:1.1.1.1
	v9_2_3:1.1.1.1
	v9_2_2:1.1.1.1
	v9_2_1:1.1.1.1
	v9_2_0:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_4:1.1.0.4
	OPENBSD_5_4_BASE:1.1
	OPENBSD_5_3:1.1.0.2
	OPENBSD_5_3_BASE:1.1;
locks; strict;
comment	@// @;


1.6
date	2015.12.23.05.17.52;	author jsg;	state dead;
branches;
next	1.5;
commitid	TnlogFl9nOv2eaRf;

1.5
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.4;
commitid	4ry2gvZGMXkCUD2n;

1.4
date	2015.01.25.14.41.21;	author jsg;	state Exp;
branches;
next	1.3;
commitid	mcxB0JvoI9gTDYXU;

1.3
date	2014.07.09.21.09.00;	author jsg;	state Exp;
branches;
next	1.2;
commitid	WPD6rgPryPkvXOr9;

1.2
date	2013.09.05.14.06.22;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2012.08.17.13.58.19;	author mpi;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.09.05.13.16.34;	author jsg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.07.09.20.35.00;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.3
date	2015.01.25.14.12.37;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.4
date	2015.02.20.22.49.44;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.6
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2007 VMware, Inc.
 * All Rights Reserved.
 * Copyright 2009 VMware, Inc.  All Rights Reserved.
 * Copyright Â© 2010-2011 Intel Corporation
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

extern "C" {
#include "glheader.h"
#include "imports.h"
#include "mtypes.h"
#include "main/context.h"
#include "main/macros.h"
#include "main/samplerobj.h"
#include "program/program.h"
#include "program/prog_parameter.h"
#include "program/prog_cache.h"
#include "program/prog_instruction.h"
#include "program/prog_print.h"
#include "program/prog_statevars.h"
#include "program/programopt.h"
#include "texenvprogram.h"
#include "texobj.h"
}
#include "main/uniforms.h"
#include "../glsl/glsl_types.h"
#include "../glsl/ir.h"
#include "../glsl/ir_builder.h"
#include "../glsl/glsl_symbol_table.h"
#include "../glsl/glsl_parser_extras.h"
#include "../glsl/ir_optimization.h"
#include "../program/ir_to_mesa.h"

using namespace ir_builder;

/*
 * Note on texture units:
 *
 * The number of texture units supported by fixed-function fragment
 * processing is MAX_TEXTURE_COORD_UNITS, not MAX_TEXTURE_IMAGE_UNITS.
 * That's because there's a one-to-one correspondence between texture
 * coordinates and samplers in fixed-function processing.
 *
 * Since fixed-function vertex processing is limited to MAX_TEXTURE_COORD_UNITS
 * sets of texcoords, so is fixed-function fragment processing.
 *
 * We can safely use ctx->Const.MaxTextureUnits for loop bounds.
 */


struct texenvprog_cache_item
{
   GLuint hash;
   void *key;
   struct gl_shader_program *data;
   struct texenvprog_cache_item *next;
};

static GLboolean
texenv_doing_secondary_color(struct gl_context *ctx)
{
   if (ctx->Light.Enabled &&
       (ctx->Light.Model.ColorControl == GL_SEPARATE_SPECULAR_COLOR))
      return GL_TRUE;

   if (ctx->Fog.ColorSumEnabled)
      return GL_TRUE;

   return GL_FALSE;
}

struct mode_opt {
#ifdef __GNUC__
   __extension__ GLubyte Source:4;  /**< SRC_x */
   __extension__ GLubyte Operand:3; /**< OPR_x */
#else
   GLubyte Source;  /**< SRC_x */
   GLubyte Operand; /**< OPR_x */
#endif
};

struct state_key {
   GLuint nr_enabled_units:8;
   GLuint enabled_units:8;
   GLuint separate_specular:1;
   GLuint fog_enabled:1;
   GLuint fog_mode:2;          /**< FOG_x */
   GLuint inputs_available:12;
   GLuint num_draw_buffers:4;

   /* NOTE: This array of structs must be last! (see "keySize" below) */
   struct {
      GLuint enabled:1;
      GLuint source_index:4;   /**< TEXTURE_x_INDEX */
      GLuint shadow:1;
      GLuint ScaleShiftRGB:2;
      GLuint ScaleShiftA:2;

      GLuint NumArgsRGB:3;  /**< up to MAX_COMBINER_TERMS */
      GLuint ModeRGB:5;     /**< MODE_x */

      GLuint NumArgsA:3;  /**< up to MAX_COMBINER_TERMS */
      GLuint ModeA:5;     /**< MODE_x */

      struct mode_opt OptRGB[MAX_COMBINER_TERMS];
      struct mode_opt OptA[MAX_COMBINER_TERMS];
   } unit[MAX_TEXTURE_UNITS];
};

#define FOG_LINEAR  0
#define FOG_EXP     1
#define FOG_EXP2    2
#define FOG_UNKNOWN 3

static GLuint translate_fog_mode( GLenum mode )
{
   switch (mode) {
   case GL_LINEAR: return FOG_LINEAR;
   case GL_EXP: return FOG_EXP;
   case GL_EXP2: return FOG_EXP2;
   default: return FOG_UNKNOWN;
   }
}

#define OPR_SRC_COLOR           0
#define OPR_ONE_MINUS_SRC_COLOR 1
#define OPR_SRC_ALPHA           2
#define OPR_ONE_MINUS_SRC_ALPHA	3
#define OPR_ZERO                4
#define OPR_ONE                 5
#define OPR_UNKNOWN             7

static GLuint translate_operand( GLenum operand )
{
   switch (operand) {
   case GL_SRC_COLOR: return OPR_SRC_COLOR;
   case GL_ONE_MINUS_SRC_COLOR: return OPR_ONE_MINUS_SRC_COLOR;
   case GL_SRC_ALPHA: return OPR_SRC_ALPHA;
   case GL_ONE_MINUS_SRC_ALPHA: return OPR_ONE_MINUS_SRC_ALPHA;
   case GL_ZERO: return OPR_ZERO;
   case GL_ONE: return OPR_ONE;
   default:
      assert(0);
      return OPR_UNKNOWN;
   }
}

#define SRC_TEXTURE  0
#define SRC_TEXTURE0 1
#define SRC_TEXTURE1 2
#define SRC_TEXTURE2 3
#define SRC_TEXTURE3 4
#define SRC_TEXTURE4 5
#define SRC_TEXTURE5 6
#define SRC_TEXTURE6 7
#define SRC_TEXTURE7 8
#define SRC_CONSTANT 9
#define SRC_PRIMARY_COLOR 10
#define SRC_PREVIOUS 11
#define SRC_ZERO     12
#define SRC_UNKNOWN  15

static GLuint translate_source( GLenum src )
{
   switch (src) {
   case GL_TEXTURE: return SRC_TEXTURE;
   case GL_TEXTURE0:
   case GL_TEXTURE1:
   case GL_TEXTURE2:
   case GL_TEXTURE3:
   case GL_TEXTURE4:
   case GL_TEXTURE5:
   case GL_TEXTURE6:
   case GL_TEXTURE7: return SRC_TEXTURE0 + (src - GL_TEXTURE0);
   case GL_CONSTANT: return SRC_CONSTANT;
   case GL_PRIMARY_COLOR: return SRC_PRIMARY_COLOR;
   case GL_PREVIOUS: return SRC_PREVIOUS;
   case GL_ZERO:
      return SRC_ZERO;
   default:
      assert(0);
      return SRC_UNKNOWN;
   }
}

#define MODE_REPLACE                     0  /* r = a0 */
#define MODE_MODULATE                    1  /* r = a0 * a1 */
#define MODE_ADD                         2  /* r = a0 + a1 */
#define MODE_ADD_SIGNED                  3  /* r = a0 + a1 - 0.5 */
#define MODE_INTERPOLATE                 4  /* r = a0 * a2 + a1 * (1 - a2) */
#define MODE_SUBTRACT                    5  /* r = a0 - a1 */
#define MODE_DOT3_RGB                    6  /* r = a0 . a1 */
#define MODE_DOT3_RGB_EXT                7  /* r = a0 . a1 */
#define MODE_DOT3_RGBA                   8  /* r = a0 . a1 */
#define MODE_DOT3_RGBA_EXT               9  /* r = a0 . a1 */
#define MODE_MODULATE_ADD_ATI           10  /* r = a0 * a2 + a1 */
#define MODE_MODULATE_SIGNED_ADD_ATI    11  /* r = a0 * a2 + a1 - 0.5 */
#define MODE_MODULATE_SUBTRACT_ATI      12  /* r = a0 * a2 - a1 */
#define MODE_ADD_PRODUCTS               13  /* r = a0 * a1 + a2 * a3 */
#define MODE_ADD_PRODUCTS_SIGNED        14  /* r = a0 * a1 + a2 * a3 - 0.5 */
#define MODE_BUMP_ENVMAP_ATI            15  /* special */
#define MODE_UNKNOWN                    16

/**
 * Translate GL combiner state into a MODE_x value
 */
static GLuint translate_mode( GLenum envMode, GLenum mode )
{
   switch (mode) {
   case GL_REPLACE: return MODE_REPLACE;
   case GL_MODULATE: return MODE_MODULATE;
   case GL_ADD:
      if (envMode == GL_COMBINE4_NV)
         return MODE_ADD_PRODUCTS;
      else
         return MODE_ADD;
   case GL_ADD_SIGNED:
      if (envMode == GL_COMBINE4_NV)
         return MODE_ADD_PRODUCTS_SIGNED;
      else
         return MODE_ADD_SIGNED;
   case GL_INTERPOLATE: return MODE_INTERPOLATE;
   case GL_SUBTRACT: return MODE_SUBTRACT;
   case GL_DOT3_RGB: return MODE_DOT3_RGB;
   case GL_DOT3_RGB_EXT: return MODE_DOT3_RGB_EXT;
   case GL_DOT3_RGBA: return MODE_DOT3_RGBA;
   case GL_DOT3_RGBA_EXT: return MODE_DOT3_RGBA_EXT;
   case GL_MODULATE_ADD_ATI: return MODE_MODULATE_ADD_ATI;
   case GL_MODULATE_SIGNED_ADD_ATI: return MODE_MODULATE_SIGNED_ADD_ATI;
   case GL_MODULATE_SUBTRACT_ATI: return MODE_MODULATE_SUBTRACT_ATI;
   case GL_BUMP_ENVMAP_ATI: return MODE_BUMP_ENVMAP_ATI;
   default:
      assert(0);
      return MODE_UNKNOWN;
   }
}


/**
 * Do we need to clamp the results of the given texture env/combine mode?
 * If the inputs to the mode are in [0,1] we don't always have to clamp
 * the results.
 */
static GLboolean
need_saturate( GLuint mode )
{
   switch (mode) {
   case MODE_REPLACE:
   case MODE_MODULATE:
   case MODE_INTERPOLATE:
      return GL_FALSE;
   case MODE_ADD:
   case MODE_ADD_SIGNED:
   case MODE_SUBTRACT:
   case MODE_DOT3_RGB:
   case MODE_DOT3_RGB_EXT:
   case MODE_DOT3_RGBA:
   case MODE_DOT3_RGBA_EXT:
   case MODE_MODULATE_ADD_ATI:
   case MODE_MODULATE_SIGNED_ADD_ATI:
   case MODE_MODULATE_SUBTRACT_ATI:
   case MODE_ADD_PRODUCTS:
   case MODE_ADD_PRODUCTS_SIGNED:
   case MODE_BUMP_ENVMAP_ATI:
      return GL_TRUE;
   default:
      assert(0);
      return GL_FALSE;
   }
}

#define VERT_BIT_TEX_ANY    (0xff << VERT_ATTRIB_TEX0)

/**
 * Identify all possible varying inputs.  The fragment program will
 * never reference non-varying inputs, but will track them via state
 * constants instead.
 *
 * This function figures out all the inputs that the fragment program
 * has access to.  The bitmask is later reduced to just those which
 * are actually referenced.
 */
static GLbitfield get_fp_input_mask( struct gl_context *ctx )
{
   /* _NEW_PROGRAM */
   const GLboolean vertexShader =
      (ctx->_Shader->CurrentProgram[MESA_SHADER_VERTEX] &&
       ctx->_Shader->CurrentProgram[MESA_SHADER_VERTEX]->LinkStatus &&
       ctx->_Shader->CurrentProgram[MESA_SHADER_VERTEX]->_LinkedShaders[MESA_SHADER_VERTEX]);
   const GLboolean vertexProgram = ctx->VertexProgram._Enabled;
   GLbitfield fp_inputs = 0x0;

   if (ctx->VertexProgram._Overriden) {
      /* Somebody's messing with the vertex program and we don't have
       * a clue what's happening.  Assume that it could be producing
       * all possible outputs.
       */
      fp_inputs = ~0;
   }
   else if (ctx->RenderMode == GL_FEEDBACK) {
      /* _NEW_RENDERMODE */
      fp_inputs = (VARYING_BIT_COL0 | VARYING_BIT_TEX0);
   }
   else if (!(vertexProgram || vertexShader)) {
      /* Fixed function vertex logic */
      /* _NEW_VARYING_VP_INPUTS */
      GLbitfield64 varying_inputs = ctx->varying_vp_inputs;

      /* These get generated in the setup routine regardless of the
       * vertex program:
       */
      /* _NEW_POINT */
      if (ctx->Point.PointSprite)
         varying_inputs |= VARYING_BITS_TEX_ANY;

      /* First look at what values may be computed by the generated
       * vertex program:
       */
      /* _NEW_LIGHT */
      if (ctx->Light.Enabled) {
         fp_inputs |= VARYING_BIT_COL0;

         if (texenv_doing_secondary_color(ctx))
            fp_inputs |= VARYING_BIT_COL1;
      }

      /* _NEW_TEXTURE */
      fp_inputs |= (ctx->Texture._TexGenEnabled |
                    ctx->Texture._TexMatEnabled) << VARYING_SLOT_TEX0;

      /* Then look at what might be varying as a result of enabled
       * arrays, etc:
       */
      if (varying_inputs & VERT_BIT_COLOR0)
         fp_inputs |= VARYING_BIT_COL0;
      if (varying_inputs & VERT_BIT_COLOR1)
         fp_inputs |= VARYING_BIT_COL1;

      fp_inputs |= (((varying_inputs & VERT_BIT_TEX_ANY) >> VERT_ATTRIB_TEX0) 
                    << VARYING_SLOT_TEX0);

   }
   else {
      /* calculate from vp->outputs */
      struct gl_program *vprog;
      GLbitfield64 vp_outputs;

      /* Choose GLSL vertex shader over ARB vertex program.  Need this
       * since vertex shader state validation comes after fragment state
       * validation (see additional comments in state.c).
       */
      if (vertexShader)
         vprog = ctx->_Shader->CurrentProgram[MESA_SHADER_VERTEX]->_LinkedShaders[MESA_SHADER_VERTEX]->Program;
      else
         vprog = &ctx->VertexProgram.Current->Base;

      vp_outputs = vprog->OutputsWritten;

      /* These get generated in the setup routine regardless of the
       * vertex program:
       */
      /* _NEW_POINT */
      if (ctx->Point.PointSprite)
         vp_outputs |= VARYING_BITS_TEX_ANY;

      if (vp_outputs & (1 << VARYING_SLOT_COL0))
         fp_inputs |= VARYING_BIT_COL0;
      if (vp_outputs & (1 << VARYING_SLOT_COL1))
         fp_inputs |= VARYING_BIT_COL1;

      fp_inputs |= (((vp_outputs & VARYING_BITS_TEX_ANY) >> VARYING_SLOT_TEX0) 
                    << VARYING_SLOT_TEX0);
   }
   
   return fp_inputs;
}


/**
 * Examine current texture environment state and generate a unique
 * key to identify it.
 */
static GLuint make_state_key( struct gl_context *ctx,  struct state_key *key )
{
   GLuint i, j;
   GLbitfield inputs_referenced = VARYING_BIT_COL0;
   const GLbitfield inputs_available = get_fp_input_mask( ctx );
   GLuint keySize;

   memset(key, 0, sizeof(*key));

   /* _NEW_TEXTURE */
   for (i = 0; i < ctx->Const.MaxTextureUnits; i++) {
      const struct gl_texture_unit *texUnit = &ctx->Texture.Unit[i];
      const struct gl_texture_object *texObj = texUnit->_Current;
      const struct gl_tex_env_combine_state *comb = texUnit->_CurrentCombine;
      const struct gl_sampler_object *samp;
      GLenum format;

      if (!texUnit->_Current || !texUnit->Enabled)
         continue;

      samp = _mesa_get_samplerobj(ctx, i);
      format = texObj->Image[0][texObj->BaseLevel]->_BaseFormat;

      key->unit[i].enabled = 1;
      key->enabled_units |= (1<<i);
      key->nr_enabled_units = i + 1;
      inputs_referenced |= VARYING_BIT_TEX(i);

      key->unit[i].source_index = _mesa_tex_target_to_index(ctx,
                                                            texObj->Target);

      key->unit[i].shadow =
         ((samp->CompareMode == GL_COMPARE_R_TO_TEXTURE) &&
          ((format == GL_DEPTH_COMPONENT) || 
           (format == GL_DEPTH_STENCIL_EXT)));

      key->unit[i].NumArgsRGB = comb->_NumArgsRGB;
      key->unit[i].NumArgsA = comb->_NumArgsA;

      key->unit[i].ModeRGB =
	 translate_mode(texUnit->EnvMode, comb->ModeRGB);
      key->unit[i].ModeA =
	 translate_mode(texUnit->EnvMode, comb->ModeA);

      key->unit[i].ScaleShiftRGB = comb->ScaleShiftRGB;
      key->unit[i].ScaleShiftA = comb->ScaleShiftA;

      for (j = 0; j < MAX_COMBINER_TERMS; j++) {
         key->unit[i].OptRGB[j].Operand = translate_operand(comb->OperandRGB[j]);
         key->unit[i].OptA[j].Operand = translate_operand(comb->OperandA[j]);
         key->unit[i].OptRGB[j].Source = translate_source(comb->SourceRGB[j]);
         key->unit[i].OptA[j].Source = translate_source(comb->SourceA[j]);
      }

      if (key->unit[i].ModeRGB == MODE_BUMP_ENVMAP_ATI) {
         /* requires some special translation */
         key->unit[i].NumArgsRGB = 2;
         key->unit[i].ScaleShiftRGB = 0;
         key->unit[i].OptRGB[0].Operand = OPR_SRC_COLOR;
         key->unit[i].OptRGB[0].Source = SRC_TEXTURE;
         key->unit[i].OptRGB[1].Operand = OPR_SRC_COLOR;
         key->unit[i].OptRGB[1].Source = texUnit->BumpTarget - GL_TEXTURE0 + SRC_TEXTURE0;
       }
   }

   /* _NEW_LIGHT | _NEW_FOG */
   if (texenv_doing_secondary_color(ctx)) {
      key->separate_specular = 1;
      inputs_referenced |= VARYING_BIT_COL1;
   }

   /* _NEW_FOG */
   if (ctx->Fog.Enabled) {
      key->fog_enabled = 1;
      key->fog_mode = translate_fog_mode(ctx->Fog.Mode);
      inputs_referenced |= VARYING_BIT_FOGC; /* maybe */
   }

   /* _NEW_BUFFERS */
   key->num_draw_buffers = ctx->DrawBuffer->_NumColorDrawBuffers;

   /* _NEW_COLOR */
   if (ctx->Color.AlphaEnabled && key->num_draw_buffers == 0) {
      /* if alpha test is enabled we need to emit at least one color */
      key->num_draw_buffers = 1;
   }

   key->inputs_available = (inputs_available & inputs_referenced);

   /* compute size of state key, ignoring unused texture units */
   keySize = sizeof(*key) - sizeof(key->unit)
      + key->nr_enabled_units * sizeof(key->unit[0]);

   return keySize;
}


/** State used to build the fragment program:
 */
class texenv_fragment_program : public ir_factory {
public:
   struct gl_shader_program *shader_program;
   struct gl_shader *shader;
   exec_list *top_instructions;
   struct state_key *state;

   ir_variable *src_texture[MAX_TEXTURE_COORD_UNITS];
   /* Reg containing each texture unit's sampled texture color,
    * else undef.
    */

   /* Texcoord override from bumpmapping. */
   ir_variable *texcoord_tex[MAX_TEXTURE_COORD_UNITS];

   /* Reg containing texcoord for a texture unit,
    * needed for bump mapping, else undef.
    */

   ir_rvalue *src_previous;	/**< Reg containing color from previous
				 * stage.  May need to be decl'd.
				 */
};

static ir_rvalue *
get_current_attrib(texenv_fragment_program *p, GLuint attrib)
{
   ir_variable *current;
   ir_rvalue *val;

   current = p->shader->symbols->get_variable("gl_CurrentAttribFragMESA");
   assert(current);
   current->data.max_array_access = MAX2(current->data.max_array_access, attrib);
   val = new(p->mem_ctx) ir_dereference_variable(current);
   ir_rvalue *index = new(p->mem_ctx) ir_constant(attrib);
   return new(p->mem_ctx) ir_dereference_array(val, index);
}

static ir_rvalue *
get_gl_Color(texenv_fragment_program *p)
{
   if (p->state->inputs_available & VARYING_BIT_COL0) {
      ir_variable *var = p->shader->symbols->get_variable("gl_Color");
      assert(var);
      return new(p->mem_ctx) ir_dereference_variable(var);
   } else {
      return get_current_attrib(p, VERT_ATTRIB_COLOR0);
   }
}

static ir_rvalue *
get_source(texenv_fragment_program *p,
	   GLuint src, GLuint unit)
{
   ir_variable *var;
   ir_dereference *deref;

   switch (src) {
   case SRC_TEXTURE: 
      return new(p->mem_ctx) ir_dereference_variable(p->src_texture[unit]);

   case SRC_TEXTURE0:
   case SRC_TEXTURE1:
   case SRC_TEXTURE2:
   case SRC_TEXTURE3:
   case SRC_TEXTURE4:
   case SRC_TEXTURE5:
   case SRC_TEXTURE6:
   case SRC_TEXTURE7: 
      return new(p->mem_ctx)
	 ir_dereference_variable(p->src_texture[src - SRC_TEXTURE0]);

   case SRC_CONSTANT:
      var = p->shader->symbols->get_variable("gl_TextureEnvColor");
      assert(var);
      deref = new(p->mem_ctx) ir_dereference_variable(var);
      var->data.max_array_access = MAX2(var->data.max_array_access, unit);
      return new(p->mem_ctx) ir_dereference_array(deref,
						  new(p->mem_ctx) ir_constant(unit));

   case SRC_PRIMARY_COLOR:
      var = p->shader->symbols->get_variable("gl_Color");
      assert(var);
      return new(p->mem_ctx) ir_dereference_variable(var);

   case SRC_ZERO:
      return new(p->mem_ctx) ir_constant(0.0f);

   case SRC_PREVIOUS:
      if (!p->src_previous) {
	 return get_gl_Color(p);
      } else {
	 return p->src_previous->clone(p->mem_ctx, NULL);
      }

   default:
      assert(0);
      return NULL;
   }
}

static ir_rvalue *
emit_combine_source(texenv_fragment_program *p,
		    GLuint unit,
		    GLuint source,
		    GLuint operand)
{
   ir_rvalue *src;

   src = get_source(p, source, unit);

   switch (operand) {
   case OPR_ONE_MINUS_SRC_COLOR: 
      return sub(new(p->mem_ctx) ir_constant(1.0f), src);

   case OPR_SRC_ALPHA:
      return src->type->is_scalar() ? src : swizzle_w(src);

   case OPR_ONE_MINUS_SRC_ALPHA: {
      ir_rvalue *const scalar = src->type->is_scalar() ? src : swizzle_w(src);

      return sub(new(p->mem_ctx) ir_constant(1.0f), scalar);
   }

   case OPR_ZERO:
      return new(p->mem_ctx) ir_constant(0.0f);
   case OPR_ONE:
      return new(p->mem_ctx) ir_constant(1.0f);
   case OPR_SRC_COLOR: 
      return src;
   default:
      assert(0);
      return src;
   }
}

/**
 * Check if the RGB and Alpha sources and operands match for the given
 * texture unit's combinder state.  When the RGB and A sources and
 * operands match, we can emit fewer instructions.
 */
static GLboolean args_match( const struct state_key *key, GLuint unit )
{
   GLuint i, numArgs = key->unit[unit].NumArgsRGB;

   for (i = 0; i < numArgs; i++) {
      if (key->unit[unit].OptA[i].Source != key->unit[unit].OptRGB[i].Source) 
	 return GL_FALSE;

      switch (key->unit[unit].OptA[i].Operand) {
      case OPR_SRC_ALPHA: 
	 switch (key->unit[unit].OptRGB[i].Operand) {
	 case OPR_SRC_COLOR: 
	 case OPR_SRC_ALPHA: 
	    break;
	 default:
	    return GL_FALSE;
	 }
	 break;
      case OPR_ONE_MINUS_SRC_ALPHA: 
	 switch (key->unit[unit].OptRGB[i].Operand) {
	 case OPR_ONE_MINUS_SRC_COLOR: 
	 case OPR_ONE_MINUS_SRC_ALPHA: 
	    break;
	 default:
	    return GL_FALSE;
	 }
	 break;
      default: 
	 return GL_FALSE;	/* impossible */
      }
   }

   return GL_TRUE;
}

static ir_rvalue *
smear(texenv_fragment_program *p, ir_rvalue *val)
{
   if (!val->type->is_scalar())
      return val;

   return swizzle_xxxx(val);
}

static ir_rvalue *
emit_combine(texenv_fragment_program *p,
	     GLuint unit,
	     GLuint nr,
	     GLuint mode,
	     const struct mode_opt *opt)
{
   ir_rvalue *src[MAX_COMBINER_TERMS];
   ir_rvalue *tmp0, *tmp1;
   GLuint i;

   assert(nr <= MAX_COMBINER_TERMS);

   for (i = 0; i < nr; i++)
      src[i] = emit_combine_source( p, unit, opt[i].Source, opt[i].Operand );

   switch (mode) {
   case MODE_REPLACE: 
      return src[0];

   case MODE_MODULATE: 
      return mul(src[0], src[1]);

   case MODE_ADD: 
      return add(src[0], src[1]);

   case MODE_ADD_SIGNED:
      return add(add(src[0], src[1]), new(p->mem_ctx) ir_constant(-0.5f));

   case MODE_INTERPOLATE: 
      /* Arg0 * (Arg2) + Arg1 * (1-Arg2) */
      tmp0 = mul(src[0], src[2]);
      tmp1 = mul(src[1], sub(new(p->mem_ctx) ir_constant(1.0f),
			     src[2]->clone(p->mem_ctx, NULL)));
      return add(tmp0, tmp1);

   case MODE_SUBTRACT: 
      return sub(src[0], src[1]);

   case MODE_DOT3_RGBA:
   case MODE_DOT3_RGBA_EXT: 
   case MODE_DOT3_RGB_EXT:
   case MODE_DOT3_RGB: {
      tmp0 = mul(src[0], new(p->mem_ctx) ir_constant(2.0f));
      tmp0 = add(tmp0, new(p->mem_ctx) ir_constant(-1.0f));

      tmp1 = mul(src[1], new(p->mem_ctx) ir_constant(2.0f));
      tmp1 = add(tmp1, new(p->mem_ctx) ir_constant(-1.0f));

      return dot(swizzle_xyz(smear(p, tmp0)), swizzle_xyz(smear(p, tmp1)));
   }
   case MODE_MODULATE_ADD_ATI:
      return add(mul(src[0], src[2]), src[1]);

   case MODE_MODULATE_SIGNED_ADD_ATI:
      return add(add(mul(src[0], src[2]), src[1]),
		 new(p->mem_ctx) ir_constant(-0.5f));

   case MODE_MODULATE_SUBTRACT_ATI:
      return sub(mul(src[0], src[2]), src[1]);

   case MODE_ADD_PRODUCTS:
      return add(mul(src[0], src[1]), mul(src[2], src[3]));

   case MODE_ADD_PRODUCTS_SIGNED:
      return add(add(mul(src[0], src[1]), mul(src[2], src[3])),
		 new(p->mem_ctx) ir_constant(-0.5f));

   case MODE_BUMP_ENVMAP_ATI:
      /* special - not handled here */
      assert(0);
      return src[0];
   default: 
      assert(0);
      return src[0];
   }
}

/**
 * Generate instructions for one texture unit's env/combiner mode.
 */
static ir_rvalue *
emit_texenv(texenv_fragment_program *p, GLuint unit)
{
   const struct state_key *key = p->state;
   GLboolean rgb_saturate, alpha_saturate;
   GLuint rgb_shift, alpha_shift;

   if (!key->unit[unit].enabled) {
      return get_source(p, SRC_PREVIOUS, 0);
   }
   if (key->unit[unit].ModeRGB == MODE_BUMP_ENVMAP_ATI) {
      /* this isn't really a env stage delivering a color and handled elsewhere */
      return get_source(p, SRC_PREVIOUS, 0);
   }
   
   switch (key->unit[unit].ModeRGB) {
   case MODE_DOT3_RGB_EXT:
      alpha_shift = key->unit[unit].ScaleShiftA;
      rgb_shift = 0;
      break;
   case MODE_DOT3_RGBA_EXT:
      alpha_shift = 0;
      rgb_shift = 0;
      break;
   default:
      rgb_shift = key->unit[unit].ScaleShiftRGB;
      alpha_shift = key->unit[unit].ScaleShiftA;
      break;
   }
   
   /* If we'll do rgb/alpha shifting don't saturate in emit_combine().
    * We don't want to clamp twice.
    */
   if (rgb_shift)
      rgb_saturate = GL_FALSE;  /* saturate after rgb shift */
   else if (need_saturate(key->unit[unit].ModeRGB))
      rgb_saturate = GL_TRUE;
   else
      rgb_saturate = GL_FALSE;

   if (alpha_shift)
      alpha_saturate = GL_FALSE;  /* saturate after alpha shift */
   else if (need_saturate(key->unit[unit].ModeA))
      alpha_saturate = GL_TRUE;
   else
      alpha_saturate = GL_FALSE;

   ir_variable *temp_var = p->make_temp(glsl_type::vec4_type, "texenv_combine");
   ir_dereference *deref;
   ir_rvalue *val;

   /* Emit the RGB and A combine ops
    */
   if (key->unit[unit].ModeRGB == key->unit[unit].ModeA &&
       args_match(key, unit)) {
      val = emit_combine(p, unit,
			 key->unit[unit].NumArgsRGB,
			 key->unit[unit].ModeRGB,
			 key->unit[unit].OptRGB);
      val = smear(p, val);
      if (rgb_saturate)
	 val = saturate(val);

      p->emit(assign(temp_var, val));
   }
   else if (key->unit[unit].ModeRGB == MODE_DOT3_RGBA_EXT ||
	    key->unit[unit].ModeRGB == MODE_DOT3_RGBA) {
      ir_rvalue *val = emit_combine(p, unit,
				    key->unit[unit].NumArgsRGB,
				    key->unit[unit].ModeRGB,
				    key->unit[unit].OptRGB);
      val = smear(p, val);
      if (rgb_saturate)
	 val = saturate(val);
      p->emit(assign(temp_var, val));
   }
   else {
      /* Need to do something to stop from re-emitting identical
       * argument calculations here:
       */
      val = emit_combine(p, unit,
			 key->unit[unit].NumArgsRGB,
			 key->unit[unit].ModeRGB,
			 key->unit[unit].OptRGB);
      val = swizzle_xyz(smear(p, val));
      if (rgb_saturate)
	 val = saturate(val);
      p->emit(assign(temp_var, val, WRITEMASK_XYZ));

      val = emit_combine(p, unit,
			 key->unit[unit].NumArgsA,
			 key->unit[unit].ModeA,
			 key->unit[unit].OptA);
      val = swizzle_w(smear(p, val));
      if (alpha_saturate)
	 val = saturate(val);
      p->emit(assign(temp_var, val, WRITEMASK_W));
   }

   deref = new(p->mem_ctx) ir_dereference_variable(temp_var);

   /* Deal with the final shift:
    */
   if (alpha_shift || rgb_shift) {
      ir_constant *shift;

      if (rgb_shift == alpha_shift) {
	 shift = new(p->mem_ctx) ir_constant((float)(1 << rgb_shift));
      }
      else {
	 float const_data[4] = {
	    float(1 << rgb_shift),
	    float(1 << rgb_shift),
	    float(1 << rgb_shift),
	    float(1 << alpha_shift)
	 };
	 shift = new(p->mem_ctx) ir_constant(glsl_type::vec4_type,
					     (ir_constant_data *)const_data);
      }

      return saturate(mul(deref, shift));
   }
   else
      return deref;
}


/**
 * Generate instruction for getting a texture source term.
 */
static void load_texture( texenv_fragment_program *p, GLuint unit )
{
   ir_dereference *deref;

   if (p->src_texture[unit])
      return;

   const GLuint texTarget = p->state->unit[unit].source_index;
   ir_rvalue *texcoord;

   if (!(p->state->inputs_available & (VARYING_BIT_TEX0 << unit))) {
      texcoord = get_current_attrib(p, VERT_ATTRIB_TEX0 + unit);
   } else if (p->texcoord_tex[unit]) {
      texcoord = new(p->mem_ctx) ir_dereference_variable(p->texcoord_tex[unit]);
   } else {
      ir_variable *tc_array = p->shader->symbols->get_variable("gl_TexCoord");
      assert(tc_array);
      texcoord = new(p->mem_ctx) ir_dereference_variable(tc_array);
      ir_rvalue *index = new(p->mem_ctx) ir_constant(unit);
      texcoord = new(p->mem_ctx) ir_dereference_array(texcoord, index);
      tc_array->data.max_array_access = MAX2(tc_array->data.max_array_access, unit);
   }

   if (!p->state->unit[unit].enabled) {
      p->src_texture[unit] = p->make_temp(glsl_type::vec4_type,
					  "dummy_tex");
      p->emit(p->src_texture[unit]);

      p->emit(assign(p->src_texture[unit], new(p->mem_ctx) ir_constant(0.0f)));
      return ;
   }

   const glsl_type *sampler_type = NULL;
   int coords = 0;

   switch (texTarget) {
   case TEXTURE_1D_INDEX:
      if (p->state->unit[unit].shadow)
	 sampler_type = p->shader->symbols->get_type("sampler1DShadow");
      else
	 sampler_type = p->shader->symbols->get_type("sampler1D");
      coords = 1;
      break;
   case TEXTURE_1D_ARRAY_INDEX:
      if (p->state->unit[unit].shadow)
	 sampler_type = p->shader->symbols->get_type("sampler1DArrayShadow");
      else
	 sampler_type = p->shader->symbols->get_type("sampler1DArray");
      coords = 2;
      break;
   case TEXTURE_2D_INDEX:
      if (p->state->unit[unit].shadow)
	 sampler_type = p->shader->symbols->get_type("sampler2DShadow");
      else
	 sampler_type = p->shader->symbols->get_type("sampler2D");
      coords = 2;
      break;
   case TEXTURE_2D_ARRAY_INDEX:
      if (p->state->unit[unit].shadow)
	 sampler_type = p->shader->symbols->get_type("sampler2DArrayShadow");
      else
	 sampler_type = p->shader->symbols->get_type("sampler2DArray");
      coords = 3;
      break;
   case TEXTURE_RECT_INDEX:
      if (p->state->unit[unit].shadow)
	 sampler_type = p->shader->symbols->get_type("sampler2DRectShadow");
      else
	 sampler_type = p->shader->symbols->get_type("sampler2DRect");
      coords = 2;
      break;
   case TEXTURE_3D_INDEX:
      assert(!p->state->unit[unit].shadow);
      sampler_type = p->shader->symbols->get_type("sampler3D");
      coords = 3;
      break;
   case TEXTURE_CUBE_INDEX:
      if (p->state->unit[unit].shadow)
	 sampler_type = p->shader->symbols->get_type("samplerCubeShadow");
      else
	 sampler_type = p->shader->symbols->get_type("samplerCube");
      coords = 3;
      break;
   case TEXTURE_EXTERNAL_INDEX:
      assert(!p->state->unit[unit].shadow);
      sampler_type = p->shader->symbols->get_type("samplerExternalOES");
      coords = 2;
      break;
   }

   p->src_texture[unit] = p->make_temp(glsl_type::vec4_type,
				       "tex");

   ir_texture *tex = new(p->mem_ctx) ir_texture(ir_tex);


   char *sampler_name = ralloc_asprintf(p->mem_ctx, "sampler_%d", unit);
   ir_variable *sampler = new(p->mem_ctx) ir_variable(sampler_type,
						      sampler_name,
						      ir_var_uniform);
   p->top_instructions->push_head(sampler);

   /* Set the texture unit for this sampler.  The linker will pick this value
    * up and do-the-right-thing.
    *
    * NOTE: The cast to int is important.  Without it, the constant will have
    * type uint, and things later on may get confused.
    */
   sampler->constant_value = new(p->mem_ctx) ir_constant(int(unit));

   deref = new(p->mem_ctx) ir_dereference_variable(sampler);
   tex->set_sampler(deref, glsl_type::vec4_type);

   tex->coordinate = new(p->mem_ctx) ir_swizzle(texcoord, 0, 1, 2, 3, coords);

   if (p->state->unit[unit].shadow) {
      texcoord = texcoord->clone(p->mem_ctx, NULL);
      tex->shadow_comparitor = new(p->mem_ctx) ir_swizzle(texcoord,
							  coords, 0, 0, 0,
							  1);
      coords++;
   }

   texcoord = texcoord->clone(p->mem_ctx, NULL);
   tex->projector = swizzle_w(texcoord);

   p->emit(assign(p->src_texture[unit], tex));
}

static void
load_texenv_source(texenv_fragment_program *p,
		   GLuint src, GLuint unit)
{
   switch (src) {
   case SRC_TEXTURE:
      load_texture(p, unit);
      break;

   case SRC_TEXTURE0:
   case SRC_TEXTURE1:
   case SRC_TEXTURE2:
   case SRC_TEXTURE3:
   case SRC_TEXTURE4:
   case SRC_TEXTURE5:
   case SRC_TEXTURE6:
   case SRC_TEXTURE7:       
      load_texture(p, src - SRC_TEXTURE0);
      break;
      
   default:
      /* not a texture src - do nothing */
      break;
   }
}


/**
 * Generate instructions for loading all texture source terms.
 */
static GLboolean
load_texunit_sources( texenv_fragment_program *p, GLuint unit )
{
   const struct state_key *key = p->state;
   GLuint i;

   for (i = 0; i < key->unit[unit].NumArgsRGB; i++) {
      load_texenv_source( p, key->unit[unit].OptRGB[i].Source, unit );
   }

   for (i = 0; i < key->unit[unit].NumArgsA; i++) {
      load_texenv_source( p, key->unit[unit].OptA[i].Source, unit );
   }

   return GL_TRUE;
}

/**
 * Generate instructions for loading bump map textures.
 */
static void
load_texunit_bumpmap( texenv_fragment_program *p, GLuint unit )
{
   const struct state_key *key = p->state;
   GLuint bumpedUnitNr = key->unit[unit].OptRGB[1].Source - SRC_TEXTURE0;
   ir_rvalue *bump;
   ir_rvalue *texcoord;
   ir_variable *rot_mat_0, *rot_mat_1;

   rot_mat_0 = p->shader->symbols->get_variable("gl_BumpRotMatrix0MESA");
   assert(rot_mat_0);
   rot_mat_1 = p->shader->symbols->get_variable("gl_BumpRotMatrix1MESA");
   assert(rot_mat_1);

   ir_variable *tc_array = p->shader->symbols->get_variable("gl_TexCoord");
   assert(tc_array);
   texcoord = new(p->mem_ctx) ir_dereference_variable(tc_array);
   ir_rvalue *index = new(p->mem_ctx) ir_constant(bumpedUnitNr);
   texcoord = new(p->mem_ctx) ir_dereference_array(texcoord, index);
   tc_array->data.max_array_access = MAX2(tc_array->data.max_array_access, unit);

   load_texenv_source( p, unit + SRC_TEXTURE0, unit );

   /* Apply rot matrix and add coords to be available in next phase.
    * dest = Arg1 + (Arg0.xx * rotMat0) + (Arg0.yy * rotMat1)
    * note only 2 coords are affected the rest are left unchanged (mul by 0)
    */
   ir_rvalue *bump_x, *bump_y;

   texcoord = smear(p, texcoord);

   /* bump_texcoord = texcoord */
   ir_variable *bumped = p->make_temp(texcoord->type, "bump_texcoord");
   p->emit(bumped);
   p->emit(assign(bumped, texcoord));

   /* bump_texcoord.xy += arg0.x * rotmat0 + arg0.y * rotmat1 */
   bump = get_source(p, key->unit[unit].OptRGB[0].Source, unit);
   bump_x = mul(swizzle_x(bump), rot_mat_0);
   bump_y = mul(swizzle_y(bump->clone(p->mem_ctx, NULL)), rot_mat_1);

   p->emit(assign(bumped, add(swizzle_xy(bumped), add(bump_x, bump_y)),
		  WRITEMASK_XY));

   p->texcoord_tex[bumpedUnitNr] = bumped;
}

/**
 * Applies the fog calculations.
 *
 * This is basically like the ARB_fragment_prorgam fog options.  Note
 * that ffvertex_prog.c produces fogcoord for us when
 * GL_FOG_COORDINATE_EXT is set to GL_FRAGMENT_DEPTH_EXT.
 */
static ir_rvalue *
emit_fog_instructions(texenv_fragment_program *p,
		      ir_rvalue *fragcolor)
{
   struct state_key *key = p->state;
   ir_rvalue *f, *temp;
   ir_variable *params, *oparams;
   ir_variable *fogcoord;

   /* Temporary storage for the whole fog result.  Fog calculations
    * only affect rgb so we're hanging on to the .a value of fragcolor
    * this way.
    */
   ir_variable *fog_result = p->make_temp(glsl_type::vec4_type, "fog_result");
   p->emit(assign(fog_result, fragcolor));

   fragcolor = swizzle_xyz(fog_result);

   oparams = p->shader->symbols->get_variable("gl_FogParamsOptimizedMESA");
   assert(oparams);
   fogcoord = p->shader->symbols->get_variable("gl_FogFragCoord");
   assert(fogcoord);
   params = p->shader->symbols->get_variable("gl_Fog");
   assert(params);
   f = new(p->mem_ctx) ir_dereference_variable(fogcoord);

   ir_variable *f_var = p->make_temp(glsl_type::float_type, "fog_factor");

   switch (key->fog_mode) {
   case FOG_LINEAR:
      /* f = (end - z) / (end - start)
       *
       * gl_MesaFogParamsOptimized gives us (-1 / (end - start)) and
       * (end / (end - start)) so we can generate a single MAD.
       */
      f = add(mul(f, swizzle_x(oparams)), swizzle_y(oparams));
      break;
   case FOG_EXP:
      /* f = e^(-(density * fogcoord))
       *
       * gl_MesaFogParamsOptimized gives us density/ln(2) so we can
       * use EXP2 which is generally the native instruction without
       * having to do any further math on the fog density uniform.
       */
      f = mul(f, swizzle_z(oparams));
      f = new(p->mem_ctx) ir_expression(ir_unop_neg, f);
      f = new(p->mem_ctx) ir_expression(ir_unop_exp2, f);
      break;
   case FOG_EXP2:
      /* f = e^(-(density * fogcoord)^2)
       *
       * gl_MesaFogParamsOptimized gives us density/sqrt(ln(2)) so we
       * can do this like FOG_EXP but with a squaring after the
       * multiply by density.
       */
      ir_variable *temp_var = p->make_temp(glsl_type::float_type, "fog_temp");
      p->emit(assign(temp_var, mul(f, swizzle_w(oparams))));

      f = mul(temp_var, temp_var);
      f = new(p->mem_ctx) ir_expression(ir_unop_neg, f);
      f = new(p->mem_ctx) ir_expression(ir_unop_exp2, f);
      break;
   }

   p->emit(assign(f_var, saturate(f)));

   f = sub(new(p->mem_ctx) ir_constant(1.0f), f_var);
   temp = new(p->mem_ctx) ir_dereference_variable(params);
   temp = new(p->mem_ctx) ir_dereference_record(temp, "color");
   temp = mul(swizzle_xyz(temp), f);

   p->emit(assign(fog_result, add(temp, mul(fragcolor, f_var)), WRITEMASK_XYZ));

   return new(p->mem_ctx) ir_dereference_variable(fog_result);
}

static void
emit_instructions(texenv_fragment_program *p)
{
   struct state_key *key = p->state;
   GLuint unit;

   if (key->enabled_units) {
      /* Zeroth pass - bump map textures first */
      for (unit = 0; unit < key->nr_enabled_units; unit++) {
	 if (key->unit[unit].enabled &&
             key->unit[unit].ModeRGB == MODE_BUMP_ENVMAP_ATI) {
	    load_texunit_bumpmap(p, unit);
	 }
      }

      /* First pass - to support texture_env_crossbar, first identify
       * all referenced texture sources and emit texld instructions
       * for each:
       */
      for (unit = 0; unit < key->nr_enabled_units; unit++)
	 if (key->unit[unit].enabled) {
	    load_texunit_sources(p, unit);
	 }

      /* Second pass - emit combine instructions to build final color:
       */
      for (unit = 0; unit < key->nr_enabled_units; unit++) {
	 if (key->unit[unit].enabled) {
	    p->src_previous = emit_texenv(p, unit);
	 }
      }
   }

   ir_rvalue *cf = get_source(p, SRC_PREVIOUS, 0);

   if (key->separate_specular) {
      ir_variable *spec_result = p->make_temp(glsl_type::vec4_type,
					      "specular_add");
      p->emit(assign(spec_result, cf));

      ir_rvalue *secondary;
      if (p->state->inputs_available & VARYING_BIT_COL1) {
	 ir_variable *var =
	    p->shader->symbols->get_variable("gl_SecondaryColor");
	 assert(var);
	 secondary = swizzle_xyz(var);
      } else {
	 secondary = swizzle_xyz(get_current_attrib(p, VERT_ATTRIB_COLOR1));
      }

      p->emit(assign(spec_result, add(swizzle_xyz(spec_result), secondary),
		     WRITEMASK_XYZ));

      cf = new(p->mem_ctx) ir_dereference_variable(spec_result);
   }

   if (key->fog_enabled) {
      cf = emit_fog_instructions(p, cf);
   }

   ir_variable *frag_color = p->shader->symbols->get_variable("gl_FragColor");
   assert(frag_color);
   p->emit(assign(frag_color, cf));
}

/**
 * Generate a new fragment program which implements the context's
 * current texture env/combine mode.
 */
static struct gl_shader_program *
create_new_program(struct gl_context *ctx, struct state_key *key)
{
   texenv_fragment_program p;
   unsigned int unit;
   _mesa_glsl_parse_state *state;

   p.mem_ctx = ralloc_context(NULL);
   p.shader = ctx->Driver.NewShader(ctx, 0, GL_FRAGMENT_SHADER);
   p.shader->ir = new(p.shader) exec_list;
   state = new(p.shader) _mesa_glsl_parse_state(ctx, MESA_SHADER_FRAGMENT,
						p.shader);
   p.shader->symbols = state->symbols;
   p.top_instructions = p.shader->ir;
   p.instructions = p.shader->ir;
   p.state = key;
   p.shader_program = ctx->Driver.NewShaderProgram(ctx, 0);

   /* Tell the linker to ignore the fact that we're building a
    * separate shader, in case we're in a GLES2 context that would
    * normally reject that.  The real problem is that we're building a
    * fixed function program in a GLES2 context at all, but that's a
    * big mess to clean up.
    */
   p.shader_program->SeparateShader = GL_TRUE;

   state->language_version = 130;
   state->es_shader = false;
   if (_mesa_is_gles(ctx) && ctx->Extensions.OES_EGL_image_external)
      state->OES_EGL_image_external_enable = true;
   _mesa_glsl_initialize_types(state);
   _mesa_glsl_initialize_variables(p.instructions, state);

   for (unit = 0; unit < ctx->Const.MaxTextureUnits; unit++) {
      p.src_texture[unit] = NULL;
      p.texcoord_tex[unit] = NULL;
   }

   p.src_previous = NULL;

   ir_function *main_f = new(p.mem_ctx) ir_function("main");
   p.emit(main_f);
   state->symbols->add_function(main_f);

   ir_function_signature *main_sig =
      new(p.mem_ctx) ir_function_signature(p.shader->symbols->get_type("void"));
   main_sig->is_defined = true;
   main_f->add_signature(main_sig);

   p.instructions = &main_sig->body;
   if (key->num_draw_buffers)
      emit_instructions(&p);

   validate_ir_tree(p.shader->ir);

   const struct gl_shader_compiler_options *options =
      &ctx->ShaderCompilerOptions[MESA_SHADER_FRAGMENT];

   while (do_common_optimization(p.shader->ir, false, false, options,
                                 ctx->Const.NativeIntegers))
      ;
   reparent_ir(p.shader->ir, p.shader->ir);

   p.shader->CompileStatus = true;
   p.shader->Version = state->language_version;
   p.shader->uses_builtin_functions = state->uses_builtin_functions;
   p.shader_program->Shaders =
      (gl_shader **)malloc(sizeof(*p.shader_program->Shaders));
   p.shader_program->Shaders[0] = p.shader;
   p.shader_program->NumShaders = 1;

   _mesa_glsl_link_shader(ctx, p.shader_program);

   if (!p.shader_program->LinkStatus)
      _mesa_problem(ctx, "Failed to link fixed function fragment shader: %s\n",
		    p.shader_program->InfoLog);

   ralloc_free(p.mem_ctx);
   return p.shader_program;
}

extern "C" {

/**
 * Return a fragment program which implements the current
 * fixed-function texture, fog and color-sum operations.
 */
struct gl_shader_program *
_mesa_get_fixed_func_fragment_program(struct gl_context *ctx)
{
   struct gl_shader_program *shader_program;
   struct state_key key;
   GLuint keySize;

   keySize = make_state_key(ctx, &key);

   shader_program = (struct gl_shader_program *)
      _mesa_search_program_cache(ctx->FragmentProgram.Cache,
                                 &key, keySize);

   if (!shader_program) {
      shader_program = create_new_program(ctx, &key);

      _mesa_shader_cache_insert(ctx, ctx->FragmentProgram.Cache,
				&key, keySize, shader_program);
   }

   return shader_program;
}

}
@


1.5
log
@Merge Mesa 10.2.9
@
text
@@


1.4
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d223 1
d253 1
d286 1
d458 10
d681 1
a681 1
smear(ir_rvalue *val)
d738 1
a738 1
      return dot(swizzle_xyz(smear(tmp0)), swizzle_xyz(smear(tmp1)));
d756 5
d780 4
d829 1
a829 1
      val = smear(val);
d841 1
a841 1
      val = smear(val);
d854 1
a854 1
      val = swizzle_xyz(smear(val));
d863 1
a863 1
      val = swizzle_w(smear(val));
d880 8
a887 9
         ir_constant_data const_data;

         const_data.f[0] = float(1 << rgb_shift);
         const_data.f[1] = float(1 << rgb_shift);
         const_data.f[2] = float(1 << rgb_shift);
         const_data.f[3] = float(1 << alpha_shift);

         shift = new(p->mem_ctx) ir_constant(glsl_type::vec4_type,
                                             &const_data);
d938 1
a938 1
	 sampler_type = glsl_type::sampler1DShadow_type;
d940 1
a940 1
	 sampler_type = glsl_type::sampler1D_type;
d945 1
a945 1
	 sampler_type = glsl_type::sampler1DArrayShadow_type;
d947 1
a947 1
	 sampler_type = glsl_type::sampler1DArray_type;
d952 1
a952 1
	 sampler_type = glsl_type::sampler2DShadow_type;
d954 1
a954 1
	 sampler_type = glsl_type::sampler2D_type;
d959 1
a959 1
	 sampler_type = glsl_type::sampler2DArrayShadow_type;
d961 1
a961 1
	 sampler_type = glsl_type::sampler2DArray_type;
d966 1
a966 1
	 sampler_type = glsl_type::sampler2DRectShadow_type;
d968 1
a968 1
	 sampler_type = glsl_type::sampler2DRect_type;
d973 1
a973 1
      sampler_type = glsl_type::sampler3D_type;
d978 1
a978 1
	 sampler_type = glsl_type::samplerCubeShadow_type;
d980 1
a980 1
	 sampler_type = glsl_type::samplerCube_type;
d985 1
a985 1
      sampler_type = glsl_type::samplerExternalOES_type;
d1077 50
d1216 8
d1294 1
a1294 1
   p.shader_program = ctx->Driver.NewShaderProgram(0);
d1323 1
a1323 1
      new(p.mem_ctx) ir_function_signature(glsl_type::void_type);
d1334 1
a1334 1
      &ctx->Const.ShaderCompilerOptions[MESA_SHADER_FRAGMENT];
@


1.3
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@a222 1
#define MODE_BUMP_ENVMAP_ATI            15  /* special */
a251 1
   case GL_BUMP_ENVMAP_ATI: return MODE_BUMP_ENVMAP_ATI;
a283 1
   case MODE_BUMP_ENVMAP_ATI:
a454 10

      if (key->unit[i].ModeRGB == MODE_BUMP_ENVMAP_ATI) {
         /* requires some special translation */
         key->unit[i].NumArgsRGB = 2;
         key->unit[i].ScaleShiftRGB = 0;
         key->unit[i].OptRGB[0].Operand = OPR_SRC_COLOR;
         key->unit[i].OptRGB[0].Source = SRC_TEXTURE;
         key->unit[i].OptRGB[1].Operand = OPR_SRC_COLOR;
         key->unit[i].OptRGB[1].Source = texUnit->BumpTarget - GL_TEXTURE0 + SRC_TEXTURE0;
       }
d668 1
a668 1
smear(texenv_fragment_program *p, ir_rvalue *val)
d725 1
a725 1
      return dot(swizzle_xyz(smear(p, tmp0)), swizzle_xyz(smear(p, tmp1)));
a742 5

   case MODE_BUMP_ENVMAP_ATI:
      /* special - not handled here */
      assert(0);
      return src[0];
a761 4
   if (key->unit[unit].ModeRGB == MODE_BUMP_ENVMAP_ATI) {
      /* this isn't really a env stage delivering a color and handled elsewhere */
      return get_source(p, SRC_PREVIOUS, 0);
   }
d807 1
a807 1
      val = smear(p, val);
d819 1
a819 1
      val = smear(p, val);
d832 1
a832 1
      val = swizzle_xyz(smear(p, val));
d841 1
a841 1
      val = swizzle_w(smear(p, val));
d858 9
a866 8
	 float const_data[4] = {
	    float(1 << rgb_shift),
	    float(1 << rgb_shift),
	    float(1 << rgb_shift),
	    float(1 << alpha_shift)
	 };
	 shift = new(p->mem_ctx) ir_constant(glsl_type::vec4_type,
					     (ir_constant_data *)const_data);
d917 1
a917 1
	 sampler_type = p->shader->symbols->get_type("sampler1DShadow");
d919 1
a919 1
	 sampler_type = p->shader->symbols->get_type("sampler1D");
d924 1
a924 1
	 sampler_type = p->shader->symbols->get_type("sampler1DArrayShadow");
d926 1
a926 1
	 sampler_type = p->shader->symbols->get_type("sampler1DArray");
d931 1
a931 1
	 sampler_type = p->shader->symbols->get_type("sampler2DShadow");
d933 1
a933 1
	 sampler_type = p->shader->symbols->get_type("sampler2D");
d938 1
a938 1
	 sampler_type = p->shader->symbols->get_type("sampler2DArrayShadow");
d940 1
a940 1
	 sampler_type = p->shader->symbols->get_type("sampler2DArray");
d945 1
a945 1
	 sampler_type = p->shader->symbols->get_type("sampler2DRectShadow");
d947 1
a947 1
	 sampler_type = p->shader->symbols->get_type("sampler2DRect");
d952 1
a952 1
      sampler_type = p->shader->symbols->get_type("sampler3D");
d957 1
a957 1
	 sampler_type = p->shader->symbols->get_type("samplerCubeShadow");
d959 1
a959 1
	 sampler_type = p->shader->symbols->get_type("samplerCube");
d964 1
a964 1
      sampler_type = p->shader->symbols->get_type("samplerExternalOES");
a1055 50
 * Generate instructions for loading bump map textures.
 */
static void
load_texunit_bumpmap( texenv_fragment_program *p, GLuint unit )
{
   const struct state_key *key = p->state;
   GLuint bumpedUnitNr = key->unit[unit].OptRGB[1].Source - SRC_TEXTURE0;
   ir_rvalue *bump;
   ir_rvalue *texcoord;
   ir_variable *rot_mat_0, *rot_mat_1;

   rot_mat_0 = p->shader->symbols->get_variable("gl_BumpRotMatrix0MESA");
   assert(rot_mat_0);
   rot_mat_1 = p->shader->symbols->get_variable("gl_BumpRotMatrix1MESA");
   assert(rot_mat_1);

   ir_variable *tc_array = p->shader->symbols->get_variable("gl_TexCoord");
   assert(tc_array);
   texcoord = new(p->mem_ctx) ir_dereference_variable(tc_array);
   ir_rvalue *index = new(p->mem_ctx) ir_constant(bumpedUnitNr);
   texcoord = new(p->mem_ctx) ir_dereference_array(texcoord, index);
   tc_array->data.max_array_access = MAX2(tc_array->data.max_array_access, unit);

   load_texenv_source( p, unit + SRC_TEXTURE0, unit );

   /* Apply rot matrix and add coords to be available in next phase.
    * dest = Arg1 + (Arg0.xx * rotMat0) + (Arg0.yy * rotMat1)
    * note only 2 coords are affected the rest are left unchanged (mul by 0)
    */
   ir_rvalue *bump_x, *bump_y;

   texcoord = smear(p, texcoord);

   /* bump_texcoord = texcoord */
   ir_variable *bumped = p->make_temp(texcoord->type, "bump_texcoord");
   p->emit(bumped);
   p->emit(assign(bumped, texcoord));

   /* bump_texcoord.xy += arg0.x * rotmat0 + arg0.y * rotmat1 */
   bump = get_source(p, key->unit[unit].OptRGB[0].Source, unit);
   bump_x = mul(swizzle_x(bump), rot_mat_0);
   bump_y = mul(swizzle_y(bump->clone(p->mem_ctx, NULL)), rot_mat_1);

   p->emit(assign(bumped, add(swizzle_xy(bumped), add(bump_x, bump_y)),
		  WRITEMASK_XY));

   p->texcoord_tex[bumpedUnitNr] = bumped;
}

/**
a1144 8
      /* Zeroth pass - bump map textures first */
      for (unit = 0; unit < key->nr_enabled_units; unit++) {
	 if (key->unit[unit].enabled &&
             key->unit[unit].ModeRGB == MODE_BUMP_ENVMAP_ATI) {
	    load_texunit_bumpmap(p, unit);
	 }
      }

d1215 1
a1215 1
   p.shader_program = ctx->Driver.NewShaderProgram(ctx, 0);
d1244 1
a1244 1
      new(p.mem_ctx) ir_function_signature(p.shader->symbols->get_type("void"));
d1255 1
a1255 1
      &ctx->ShaderCompilerOptions[MESA_SHADER_FRAGMENT];
@


1.2
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2007 Tungsten Graphics, Inc., Cedar Park, Texas.
d23 1
a23 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
a34 1
#include "main/uniforms.h"
d45 1
a293 12


/**
 * Translate TEXTURE_x_BIT to TEXTURE_x_INDEX.
 */
static GLuint translate_tex_src_bit( GLbitfield bit )
{
   ASSERT(bit);
   return ffs(bit) - 1;
}


d309 3
a311 3
      (ctx->Shader.CurrentVertexProgram &&
       ctx->Shader.CurrentVertexProgram->LinkStatus &&
       ctx->Shader.CurrentVertexProgram->_LinkedShaders[MESA_SHADER_VERTEX]);
d375 1
a375 1
         vprog = ctx->Shader.CurrentVertexProgram->_LinkedShaders[MESA_SHADER_VERTEX]->Program;
d422 1
a422 1
      if (!texUnit->_ReallyEnabled || !texUnit->Enabled)
d433 2
a434 2
      key->unit[i].source_index =
         translate_tex_src_bit(texUnit->_ReallyEnabled);
d535 2
a536 1
   current->max_array_access = MAX2(current->max_array_access, attrib);
d580 1
a580 1
      var->max_array_access = MAX2(var->max_array_access, unit);
d920 1
a920 1
      tc_array->max_array_access = MAX2(tc_array->max_array_access, unit);
d1089 1
d1091 1
d1098 1
a1098 1
   tc_array->max_array_access = MAX2(tc_array->max_array_access, unit);
d1152 1
d1154 1
d1156 1
d1288 1
a1288 1
   state = new(p.shader) _mesa_glsl_parse_state(ctx, GL_FRAGMENT_SHADER,
d1302 1
a1302 1
   p.shader_program->InternalSeparateShader = GL_TRUE;
d1336 2
a1337 1
   while (do_common_optimization(p.shader->ir, false, false, 32, options))
d1343 1
a1343 1
   p.shader->num_builtins_to_link = state->num_builtins_to_link;
@


1.1
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d6 1
d34 4
d47 10
d77 1
a77 1
   struct gl_fragment_program *data;
a93 7
/**
 * Up to nine instructions per tex unit, plus fog, specular color.
 */
#define MAX_INSTRUCTIONS ((MAX_TEXTURE_COORD_UNITS * 9) + 12)

#define DISASSEM (MESA_VERBOSE & VERBOSE_DISASSEM)

d116 1
a116 1
      GLuint source_index:3;   /**< TEXTURE_x_INDEX */
a126 2
      GLuint texture_cyl_wrap:1; /**< For gallium test/debug only */

d302 1
a302 1
   return _mesa_ffs(bit) - 1;
a306 1
#define VERT_RESULT_TEX_ANY (0xff << VERT_RESULT_TEX0)
d323 1
a323 1
       ctx->Shader.CurrentVertexProgram->VertexProgram);
d336 1
a336 1
      fp_inputs = (FRAG_BIT_COL0 | FRAG_BIT_TEX0);
d338 1
a338 2
   else if (!(vertexProgram || vertexShader) ||
            !ctx->VertexProgram._Current) {
d340 2
a341 2
      /* _NEW_ARRAY */
      GLbitfield varying_inputs = ctx->varying_vp_inputs;
d348 1
a348 1
         varying_inputs |= FRAG_BITS_TEX_ANY;
d355 1
a355 1
         fp_inputs |= FRAG_BIT_COL0;
d358 1
a358 1
            fp_inputs |= FRAG_BIT_COL1;
d363 1
a363 1
                    ctx->Texture._TexMatEnabled) << FRAG_ATTRIB_TEX0;
d369 1
a369 1
         fp_inputs |= FRAG_BIT_COL0;
d371 1
a371 1
         fp_inputs |= FRAG_BIT_COL1;
d374 1
a374 1
                    << FRAG_ATTRIB_TEX0);
d379 1
a379 1
      struct gl_vertex_program *vprog;
d387 1
a387 1
         vprog = ctx->Shader.CurrentVertexProgram->VertexProgram;
d389 1
a389 1
         vprog = ctx->VertexProgram.Current;
d391 1
a391 1
      vp_outputs = vprog->Base.OutputsWritten;
d398 1
a398 1
         vp_outputs |= FRAG_BITS_TEX_ANY;
d400 4
a403 4
      if (vp_outputs & (1 << VERT_RESULT_COL0))
         fp_inputs |= FRAG_BIT_COL0;
      if (vp_outputs & (1 << VERT_RESULT_COL1))
         fp_inputs |= FRAG_BIT_COL1;
d405 2
a406 2
      fp_inputs |= (((vp_outputs & VERT_RESULT_TEX_ANY) >> VERT_RESULT_TEX0) 
                    << FRAG_ATTRIB_TEX0);
d420 1
a420 1
   GLbitfield inputs_referenced = FRAG_BIT_COL0;
d431 1
d437 1
d443 1
a443 1
      inputs_referenced |= FRAG_BIT_TEX(i);
d449 1
a449 1
         ((texObj->Sampler.CompareMode == GL_COMPARE_R_TO_TEXTURE) &&
a479 4

      /* this is a back-door for enabling cylindrical texture wrap mode */
      if (texObj->Priority == 0.125)
         key->unit[i].texture_cyl_wrap = 1;
d485 1
a485 1
      inputs_referenced |= FRAG_BIT_COL1;
d492 1
a492 1
      inputs_referenced |= FRAG_BIT_FOGC; /* maybe */
d498 6
a513 30
/**
 * Use uregs to represent registers internally, translate to Mesa's
 * expected formats on emit.  
 *
 * NOTE: These are passed by value extensively in this file rather
 * than as usual by pointer reference.  If this disturbs you, try
 * remembering they are just 32bits in size.
 *
 * GCC is smart enough to deal with these dword-sized structures in
 * much the same way as if I had defined them as dwords and was using
 * macros to access and set the fields.  This is much nicer and easier
 * to evolve.
 */
struct ureg {
   GLuint file:4;
   GLuint idx:8;
   GLuint negatebase:1;
   GLuint swz:12;
   GLuint pad:7;
};

static const struct ureg undef = { 
   PROGRAM_UNDEFINED,
   255,
   0,
   0,
   0
};


d516 5
a520 2
struct texenv_fragment_program {
   struct gl_fragment_program *program;
d523 1
a523 6
   GLbitfield alu_temps;	/**< Track texture indirections, see spec. */
   GLbitfield temps_output;	/**< Track texture indirections, see spec. */
   GLbitfield temp_in_use;	/**< Tracks temporary regs which are in use. */
   GLboolean error;

   struct ureg src_texture[MAX_TEXTURE_COORD_UNITS];   
d528 3
a530 1
   struct ureg texcoord_tex[MAX_TEXTURE_COORD_UNITS];
d535 1
a535 1
   struct ureg src_previous;	/**< Reg containing color from previous 
a537 6

   GLuint last_tex_stage;	/**< Number of last enabled texture unit */

   struct ureg half;
   struct ureg one;
   struct ureg zero;
d540 2
a541 122


static struct ureg make_ureg(GLuint file, GLuint idx)
{
   struct ureg reg;
   reg.file = file;
   reg.idx = idx;
   reg.negatebase = 0;
   reg.swz = SWIZZLE_NOOP;
   reg.pad = 0;
   return reg;
}

static struct ureg swizzle( struct ureg reg, int x, int y, int z, int w )
{
   reg.swz = MAKE_SWIZZLE4(GET_SWZ(reg.swz, x),
			   GET_SWZ(reg.swz, y),
			   GET_SWZ(reg.swz, z),
			   GET_SWZ(reg.swz, w));

   return reg;
}

static struct ureg swizzle1( struct ureg reg, int x )
{
   return swizzle(reg, x, x, x, x);
}

static struct ureg negate( struct ureg reg )
{
   reg.negatebase ^= 1;
   return reg;
}

static GLboolean is_undef( struct ureg reg )
{
   return reg.file == PROGRAM_UNDEFINED;
}


static struct ureg get_temp( struct texenv_fragment_program *p )
{
   GLint bit;
   
   /* First try and reuse temps which have been used already:
    */
   bit = _mesa_ffs( ~p->temp_in_use & p->alu_temps );

   /* Then any unused temporary:
    */
   if (!bit)
      bit = _mesa_ffs( ~p->temp_in_use );

   if (!bit) {
      _mesa_problem(NULL, "%s: out of temporaries\n", __FILE__);
      exit(1);
   }

   if ((GLuint) bit > p->program->Base.NumTemporaries)
      p->program->Base.NumTemporaries = bit;

   p->temp_in_use |= 1<<(bit-1);
   return make_ureg(PROGRAM_TEMPORARY, (bit-1));
}

static struct ureg get_tex_temp( struct texenv_fragment_program *p )
{
   int bit;
   
   /* First try to find available temp not previously used (to avoid
    * starting a new texture indirection).  According to the spec, the
    * ~p->temps_output isn't necessary, but will keep it there for
    * now:
    */
   bit = _mesa_ffs( ~p->temp_in_use & ~p->alu_temps & ~p->temps_output );

   /* Then any unused temporary:
    */
   if (!bit) 
      bit = _mesa_ffs( ~p->temp_in_use );

   if (!bit) {
      _mesa_problem(NULL, "%s: out of temporaries\n", __FILE__);
      exit(1);
   }

   if ((GLuint) bit > p->program->Base.NumTemporaries)
      p->program->Base.NumTemporaries = bit;

   p->temp_in_use |= 1<<(bit-1);
   return make_ureg(PROGRAM_TEMPORARY, (bit-1));
}


/** Mark a temp reg as being no longer allocatable. */
static void reserve_temp( struct texenv_fragment_program *p, struct ureg r )
{
   if (r.file == PROGRAM_TEMPORARY)
      p->temps_output |= (1 << r.idx);
}


static void release_temps(struct gl_context *ctx, struct texenv_fragment_program *p )
{
   GLuint max_temp = ctx->Const.FragmentProgram.MaxTemps;

   /* KW: To support tex_env_crossbar, don't release the registers in
    * temps_output.
    */
   if (max_temp >= sizeof(int) * 8)
      p->temp_in_use = p->temps_output;
   else
      p->temp_in_use = ~((1<<max_temp)-1) | p->temps_output;
}


static struct ureg register_param5( struct texenv_fragment_program *p, 
				    GLint s0,
				    GLint s1,
				    GLint s2,
				    GLint s3,
				    GLint s4)
d543 2
a544 11
   int tokens[STATE_LENGTH];
   GLuint idx;
   tokens[0] = s0;
   tokens[1] = s1;
   tokens[2] = s2;
   tokens[3] = s3;
   tokens[4] = s4;
   idx = _mesa_add_state_reference(p->program->Base.Parameters,
				   (gl_state_index *)tokens);
   return make_ureg(PROGRAM_STATE_VAR, idx);
}
d546 5
a550 16

#define register_param1(p,s0)          register_param5(p,s0,0,0,0,0)
#define register_param2(p,s0,s1)       register_param5(p,s0,s1,0,0,0)
#define register_param3(p,s0,s1,s2)    register_param5(p,s0,s1,s2,0,0)
#define register_param4(p,s0,s1,s2,s3) register_param5(p,s0,s1,s2,s3,0)

static GLuint frag_to_vert_attrib( GLuint attrib )
{
   switch (attrib) {
   case FRAG_ATTRIB_COL0: return VERT_ATTRIB_COLOR0;
   case FRAG_ATTRIB_COL1: return VERT_ATTRIB_COLOR1;
   default:
      assert(attrib >= FRAG_ATTRIB_TEX0);
      assert(attrib <= FRAG_ATTRIB_TEX7);
      return attrib - FRAG_ATTRIB_TEX0 + VERT_ATTRIB_TEX0;
   }
d553 2
a554 2

static struct ureg register_input( struct texenv_fragment_program *p, GLuint input )
d556 6
a561 3
   if (p->state->inputs_available & (1<<input)) {
      p->program->Base.InputsRead |= (1 << input);
      return make_ureg(PROGRAM_INPUT, input);
a562 61
   else {
      GLuint idx = frag_to_vert_attrib( input );
      return register_param3( p, STATE_INTERNAL, STATE_CURRENT_ATTRIB_MAYBE_VP_CLAMPED, idx );
   }
}


static void emit_arg( struct prog_src_register *reg,
		      struct ureg ureg )
{
   reg->File = ureg.file;
   reg->Index = ureg.idx;
   reg->Swizzle = ureg.swz;
   reg->Negate = ureg.negatebase ? NEGATE_XYZW : NEGATE_NONE;
   reg->Abs = GL_FALSE;
}

static void emit_dst( struct prog_dst_register *dst,
		      struct ureg ureg, GLuint mask )
{
   dst->File = ureg.file;
   dst->Index = ureg.idx;
   dst->WriteMask = mask;
   dst->CondMask = COND_TR;  /* always pass cond test */
   dst->CondSwizzle = SWIZZLE_NOOP;
}

static struct prog_instruction *
emit_op(struct texenv_fragment_program *p,
	enum prog_opcode op,
	struct ureg dest,
	GLuint mask,
	GLboolean saturate,
	struct ureg src0,
	struct ureg src1,
	struct ureg src2 )
{
   const GLuint nr = p->program->Base.NumInstructions++;
   struct prog_instruction *inst = &p->program->Base.Instructions[nr];

   assert(nr < MAX_INSTRUCTIONS);

   _mesa_init_instructions(inst, 1);
   inst->Opcode = op;
   
   emit_arg( &inst->SrcReg[0], src0 );
   emit_arg( &inst->SrcReg[1], src1 );
   emit_arg( &inst->SrcReg[2], src2 );
   
   inst->SaturateMode = saturate ? SATURATE_ZERO_ONE : SATURATE_OFF;

   emit_dst( &inst->DstReg, dest, mask );

#if 0
   /* Accounting for indirection tracking:
    */
   if (dest.file == PROGRAM_TEMPORARY)
      p->temps_output |= 1 << dest.idx;
#endif

   return inst;
a563 1
   
d565 3
a567 8
static struct ureg emit_arith( struct texenv_fragment_program *p,
			       enum prog_opcode op,
			       struct ureg dest,
			       GLuint mask,
			       GLboolean saturate,
			       struct ureg src0,
			       struct ureg src1,
			       struct ureg src2 )
d569 2
a570 9
   emit_op(p, op, dest, mask, saturate, src0, src1, src2);
   
   /* Accounting for indirection tracking:
    */
   if (src0.file == PROGRAM_TEMPORARY)
      p->alu_temps |= 1 << src0.idx;

   if (!is_undef(src1) && src1.file == PROGRAM_TEMPORARY)
      p->alu_temps |= 1 << src1.idx;
a571 111
   if (!is_undef(src2) && src2.file == PROGRAM_TEMPORARY)
      p->alu_temps |= 1 << src2.idx;

   if (dest.file == PROGRAM_TEMPORARY)
      p->alu_temps |= 1 << dest.idx;
       
   p->program->Base.NumAluInstructions++;
   return dest;
}

static struct ureg emit_texld( struct texenv_fragment_program *p,
			       enum prog_opcode op,
			       struct ureg dest,
			       GLuint destmask,
			       GLuint tex_unit,
			       GLuint tex_idx,
                               GLuint tex_shadow,
			       struct ureg coord )
{
   struct prog_instruction *inst = emit_op( p, op, 
					  dest, destmask, 
					  GL_FALSE,	/* don't saturate? */
					  coord, 	/* arg 0? */
					  undef,
					  undef);
   
   inst->TexSrcTarget = tex_idx;
   inst->TexSrcUnit = tex_unit;
   inst->TexShadow = tex_shadow;

   p->program->Base.NumTexInstructions++;

   /* Accounting for indirection tracking:
    */
   reserve_temp(p, dest);

#if 0
   /* Is this a texture indirection?
    */
   if ((coord.file == PROGRAM_TEMPORARY &&
	(p->temps_output & (1<<coord.idx))) ||
       (dest.file == PROGRAM_TEMPORARY &&
	(p->alu_temps & (1<<dest.idx)))) {
      p->program->Base.NumTexIndirections++;
      p->temps_output = 1<<coord.idx;
      p->alu_temps = 0;
      assert(0);		/* KW: texture env crossbar */
   }
#endif

   return dest;
}


static struct ureg register_const4f( struct texenv_fragment_program *p, 
				     GLfloat s0,
				     GLfloat s1,
				     GLfloat s2,
				     GLfloat s3)
{
   GLfloat values[4];
   GLuint idx, swizzle;
   struct ureg r;
   values[0] = s0;
   values[1] = s1;
   values[2] = s2;
   values[3] = s3;
   idx = _mesa_add_unnamed_constant( p->program->Base.Parameters, values, 4,
                                     &swizzle );
   r = make_ureg(PROGRAM_CONSTANT, idx);
   r.swz = swizzle;
   return r;
}

#define register_scalar_const(p, s0)    register_const4f(p, s0, s0, s0, s0)
#define register_const1f(p, s0)         register_const4f(p, s0, 0, 0, 1)
#define register_const2f(p, s0, s1)     register_const4f(p, s0, s1, 0, 1)
#define register_const3f(p, s0, s1, s2) register_const4f(p, s0, s1, s2, 1)


static struct ureg get_one( struct texenv_fragment_program *p )
{
   if (is_undef(p->one)) 
      p->one = register_scalar_const(p, 1.0);
   return p->one;
}

static struct ureg get_half( struct texenv_fragment_program *p )
{
   if (is_undef(p->half)) 
      p->half = register_scalar_const(p, 0.5);
   return p->half;
}

static struct ureg get_zero( struct texenv_fragment_program *p )
{
   if (is_undef(p->zero)) 
      p->zero = register_scalar_const(p, 0.0);
   return p->zero;
}


static void program_error( struct texenv_fragment_program *p, const char *msg )
{
   _mesa_problem(NULL, "%s", msg);
   p->error = 1;
}

static struct ureg get_source( struct texenv_fragment_program *p, 
			       GLuint src, GLuint unit )
{
d574 1
a574 2
      assert(!is_undef(p->src_texture[unit]));
      return p->src_texture[unit];
d584 2
a585 2
      assert(!is_undef(p->src_texture[src - SRC_TEXTURE0]));
      return p->src_texture[src - SRC_TEXTURE0];
d588 6
a593 1
      return register_param2(p, STATE_TEXENV_COLOR, unit);
d596 3
a598 1
      return register_input(p, FRAG_ATTRIB_COL0);
d601 1
a601 1
      return get_zero(p);
d604 5
a608 4
      if (is_undef(p->src_previous))
	 return register_input(p, FRAG_ATTRIB_COL0);
      else
	 return p->src_previous;
d612 1
a612 1
      return undef;
d616 5
a620 5
static struct ureg emit_combine_source( struct texenv_fragment_program *p, 
					GLuint mask,
					GLuint unit,
					GLuint source, 
					GLuint operand )
d622 1
a622 1
   struct ureg arg, src, one;
d628 11
a638 20
      /* Get unused tmp,
       * Emit tmp = 1.0 - arg.xyzw
       */
      arg = get_temp( p );
      one = get_one( p );
      return emit_arith( p, OPCODE_SUB, arg, mask, 0, one, src, undef);

   case OPR_SRC_ALPHA: 
      if (mask == WRITEMASK_W)
	 return src;
      else
	 return swizzle1( src, SWIZZLE_W );
   case OPR_ONE_MINUS_SRC_ALPHA: 
      /* Get unused tmp,
       * Emit tmp = 1.0 - arg.wwww
       */
      arg = get_temp(p);
      one = get_one(p);
      return emit_arith(p, OPCODE_SUB, arg, mask, 0,
			one, swizzle1(src, SWIZZLE_W), undef);
d640 1
a640 1
      return get_zero(p);
d642 1
a642 1
      return get_one(p);
d691 15
a705 8
static struct ureg emit_combine( struct texenv_fragment_program *p,
				 struct ureg dest,
				 GLuint mask,
				 GLboolean saturate,
				 GLuint unit,
				 GLuint nr,
				 GLuint mode,
				 const struct mode_opt *opt)
d707 2
a708 2
   struct ureg src[MAX_COMBINER_TERMS];
   struct ureg tmp, half;
d714 1
a714 1
      src[i] = emit_combine_source( p, mask, unit, opt[i].Source, opt[i].Operand );
d718 2
a719 4
      if (mask == WRITEMASK_XYZW && !saturate)
	 return src[0];
      else
	 return emit_arith( p, OPCODE_MOV, dest, mask, saturate, src[0], undef, undef );
d721 2
a722 2
      return emit_arith( p, OPCODE_MUL, dest, mask, saturate,
			 src[0], src[1], undef );
d724 2
a725 2
      return emit_arith( p, OPCODE_ADD, dest, mask, saturate, 
			 src[0], src[1], undef );
d727 2
a728 8
      /* tmp = arg0 + arg1
       * result = tmp - .5
       */
      half = get_half(p);
      tmp = get_temp( p );
      emit_arith( p, OPCODE_ADD, tmp, mask, 0, src[0], src[1], undef );
      emit_arith( p, OPCODE_SUB, dest, mask, saturate, tmp, half, undef );
      return dest;
d730 5
a734 3
      /* Arg0 * (Arg2) + Arg1 * (1-Arg2) -- note arguments are reordered:
       */
      return emit_arith( p, OPCODE_LRP, dest, mask, saturate, src[2], src[0], src[1] );
d737 1
a737 1
      return emit_arith( p, OPCODE_SUB, dest, mask, saturate, src[0], src[1], undef );
d743 2
a744 4
      struct ureg tmp0 = get_temp( p );
      struct ureg tmp1 = get_temp( p );
      struct ureg neg1 = register_scalar_const(p, -1);
      struct ureg two  = register_scalar_const(p, 2);
d746 2
a747 7
      /* tmp0 = 2*src0 - 1
       * tmp1 = 2*src1 - 1
       *
       * dst = tmp0 dot3 tmp1 
       */
      emit_arith( p, OPCODE_MAD, tmp0, WRITEMASK_XYZW, 0, 
		  two, src[0], neg1);
d749 1
a749 7
      if (memcmp(&src[0], &src[1], sizeof(struct ureg)) == 0)
	 tmp1 = tmp0;
      else
	 emit_arith( p, OPCODE_MAD, tmp1, WRITEMASK_XYZW, 0, 
		     two, src[1], neg1);
      emit_arith( p, OPCODE_DP3, dest, mask, saturate, tmp0, tmp1, undef);
      return dest;
d752 6
a757 11
      /* Arg0 * Arg2 + Arg1 */
      return emit_arith( p, OPCODE_MAD, dest, mask, saturate,
			 src[0], src[2], src[1] );
   case MODE_MODULATE_SIGNED_ADD_ATI: {
      /* Arg0 * Arg2 + Arg1 - 0.5 */
      struct ureg tmp0 = get_temp(p);
      half = get_half(p);
      emit_arith( p, OPCODE_MAD, tmp0, mask, 0, src[0], src[2], src[1] );
      emit_arith( p, OPCODE_SUB, dest, mask, saturate, tmp0, half, undef );
      return dest;
   }
d759 2
a760 3
      /* Arg0 * Arg2 - Arg1 */
      emit_arith( p, OPCODE_MAD, dest, mask, 0, src[0], src[2], negate(src[1]) );
      return dest;
d762 2
a763 7
      /* Arg0 * Arg1 + Arg2 * Arg3 */
      {
         struct ureg tmp0 = get_temp(p);
         emit_arith( p, OPCODE_MUL, tmp0, mask, 0, src[0], src[1], undef );
         emit_arith( p, OPCODE_MAD, dest, mask, saturate, src[2], src[3], tmp0 );
      }
      return dest;
d765 3
a767 9
      /* Arg0 * Arg1 + Arg2 * Arg3 - 0.5 */
      {
         struct ureg tmp0 = get_temp(p);
         half = get_half(p);
         emit_arith( p, OPCODE_MUL, tmp0, mask, 0, src[0], src[1], undef );
         emit_arith( p, OPCODE_MAD, tmp0, mask, 0, src[2], src[3], tmp0 );
         emit_arith( p, OPCODE_SUB, dest, mask, saturate, tmp0, half, undef );
      }
      return dest;
a777 1

d781 2
a782 2
static struct ureg
emit_texenv(struct texenv_fragment_program *p, GLuint unit)
a786 1
   struct ureg out, dest;
d828 3
a830 12
   /* If this is the very last calculation (and various other conditions
    * are met), emit directly to the color output register.  Otherwise,
    * emit to a temporary register.
    */
   if (key->separate_specular ||
       unit != p->last_tex_stage ||
       alpha_shift ||
       key->num_draw_buffers != 1 ||
       rgb_shift)
      dest = get_temp( p );
   else
      dest = make_ureg(PROGRAM_OUTPUT, FRAG_RESULT_COLOR);
d836 9
a844 5
      out = emit_combine( p, dest, WRITEMASK_XYZW, rgb_saturate,
			  unit,
			  key->unit[unit].NumArgsRGB,
			  key->unit[unit].ModeRGB,
			  key->unit[unit].OptRGB);
d848 8
a855 5
      out = emit_combine( p, dest, WRITEMASK_XYZW, rgb_saturate,
			  unit,
			  key->unit[unit].NumArgsRGB,
			  key->unit[unit].ModeRGB,
			  key->unit[unit].OptRGB);
d861 17
a877 10
      out = emit_combine( p, dest, WRITEMASK_XYZ, rgb_saturate,
			  unit,
			  key->unit[unit].NumArgsRGB,
			  key->unit[unit].ModeRGB,
			  key->unit[unit].OptRGB);
      out = emit_combine( p, dest, WRITEMASK_W, alpha_saturate,
			  unit,
			  key->unit[unit].NumArgsA,
			  key->unit[unit].ModeA,
			  key->unit[unit].OptA);
d880 2
d885 1
a885 2
      struct ureg shift;
      GLboolean saturate = GL_TRUE;  /* always saturate at this point */
d888 1
a888 1
	 shift = register_scalar_const(p, (GLfloat)(1<<rgb_shift));
d891 8
a898 5
	 shift = register_const4f(p, 
				  (GLfloat)(1<<rgb_shift),
				  (GLfloat)(1<<rgb_shift),
				  (GLfloat)(1<<rgb_shift),
				  (GLfloat)(1<<alpha_shift));
d900 2
a901 2
      return emit_arith( p, OPCODE_MUL, dest, WRITEMASK_XYZW, 
			 saturate, out, shift, undef );
d904 1
a904 1
      return out;
d911 1
a911 1
static void load_texture( struct texenv_fragment_program *p, GLuint unit )
d913 1
a913 4
   if (is_undef(p->src_texture[unit])) {
      const GLuint texTarget = p->state->unit[unit].source_index;
      struct ureg texcoord;
      struct ureg tmp = get_tex_temp( p );
d915 2
a916 7
      if (is_undef(p->texcoord_tex[unit])) {
         texcoord = register_input(p, FRAG_ATTRIB_TEX0+unit);
      }
      else {
         /* might want to reuse this reg for tex output actually */
         texcoord = p->texcoord_tex[unit];
      }
d918 2
a919 4
      /* TODO: Use D0_MASK_XY where possible.
       */
      if (p->state->unit[unit].enabled) {
         GLboolean shadow = GL_FALSE;
d921 69
a989 16
	 if (p->state->unit[unit].shadow) {
	    p->program->Base.ShadowSamplers |= 1 << unit;
            shadow = GL_TRUE;
         }

	 p->src_texture[unit] = emit_texld( p, OPCODE_TXP,
					    tmp, WRITEMASK_XYZW, 
					    unit, texTarget, shadow,
                                            texcoord );

         p->program->Base.SamplersUsed |= (1 << unit);
         /* This identity mapping should already be in place
          * (see _mesa_init_program_struct()) but let's be safe.
          */
         p->program->Base.SamplerUnits[unit] = unit;
      }
d991 29
a1019 1
	 p->src_texture[unit] = get_zero(p);
d1021 4
a1024 4
      if (p->state->unit[unit].texture_cyl_wrap) {
         /* set flag which is checked by Mesa->Gallium program translation */
         p->program->Base.InputFlags[0] |= PROG_PARAM_BIT_CYL_WRAP;
      }
d1026 6
d1033 5
d1040 3
a1042 2
static GLboolean load_texenv_source( struct texenv_fragment_program *p, 
				     GLuint src, GLuint unit )
a1063 2
 
   return GL_TRUE;
d1071 1
a1071 1
load_texunit_sources( struct texenv_fragment_program *p, GLuint unit )
d1090 2
a1091 2
static GLboolean
load_texunit_bumpmap( struct texenv_fragment_program *p, GLuint unit )
d1095 13
a1107 5
   struct ureg texcDst, bumpMapRes;
   struct ureg constdudvcolor = register_const4f(p, 0.0, 0.0, 0.0, 1.0);
   struct ureg texcSrc = register_input(p, FRAG_ATTRIB_TEX0 + bumpedUnitNr);
   struct ureg rotMat0 = register_param3( p, STATE_INTERNAL, STATE_ROT_MATRIX_0, unit );
   struct ureg rotMat1 = register_param3( p, STATE_INTERNAL, STATE_ROT_MATRIX_1, unit );
a1110 4
   bumpMapRes = get_source(p, key->unit[unit].OptRGB[0].Source, unit);
   texcDst = get_tex_temp( p );
   p->texcoord_tex[bumpedUnitNr] = texcDst;

d1112 1
a1112 1
    * dest = (Arg0.xxxx * rotMat0 + Arg1) + (Arg0.yyyy * rotMat1)
d1115 8
a1122 4
   emit_arith( p, OPCODE_MAD, texcDst, WRITEMASK_XYZW, 0,
               swizzle1(bumpMapRes, SWIZZLE_X), rotMat0, texcSrc );
   emit_arith( p, OPCODE_MAD, texcDst, WRITEMASK_XYZW, 0,
               swizzle1(bumpMapRes, SWIZZLE_Y), rotMat1, texcDst );
d1124 7
a1130 5
   /* Move 0,0,0,1 into bumpmap src if someone (crossbar) is foolish
    * enough to access this later, should optimize away.
    */
   emit_arith( p, OPCODE_MOV, bumpMapRes, WRITEMASK_XYZW, 0,
               constdudvcolor, undef, undef );
d1132 1
a1132 1
   return GL_TRUE;
d1136 5
a1140 2
 * Generate a new fragment program which implements the context's
 * current texture env/combine mode.
d1142 54
a1195 9
static void
create_new_program(struct gl_context *ctx, struct state_key *key,
                   struct gl_fragment_program *program)
{
   struct prog_instruction instBuffer[MAX_INSTRUCTIONS];
   struct texenv_fragment_program p;
   GLuint unit;
   struct ureg cf, out;
   int i;
d1197 5
a1201 3
   memset(&p, 0, sizeof(p));
   p.state = key;
   p.program = program;
d1203 1
a1203 23
   /* During code generation, use locally-allocated instruction buffer,
    * then alloc dynamic storage below.
    */
   p.program->Base.Instructions = instBuffer;
   p.program->Base.Target = GL_FRAGMENT_PROGRAM_ARB;
   p.program->Base.String = NULL;
   p.program->Base.NumTexIndirections = 1; /* is this right? */
   p.program->Base.NumTexInstructions = 0;
   p.program->Base.NumAluInstructions = 0;
   p.program->Base.NumInstructions = 0;
   p.program->Base.NumTemporaries = 0;
   p.program->Base.NumParameters = 0;
   p.program->Base.NumAttributes = 0;
   p.program->Base.NumAddressRegs = 0;
   p.program->Base.Parameters = _mesa_new_parameter_list();
   p.program->Base.InputsRead = 0x0;

   if (key->num_draw_buffers == 1)
      p.program->Base.OutputsWritten = 1 << FRAG_RESULT_COLOR;
   else {
      for (i = 0; i < key->num_draw_buffers; i++)
	 p.program->Base.OutputsWritten |= (1 << (FRAG_RESULT_DATA0 + i));
   }
d1205 4
a1208 4
   for (unit = 0; unit < ctx->Const.MaxTextureUnits; unit++) {
      p.src_texture[unit] = undef;
      p.texcoord_tex[unit] = undef;
   }
d1210 1
a1210 4
   p.src_previous = undef;
   p.half = undef;
   p.zero = undef;
   p.one = undef;
d1212 2
a1213 2
   p.last_tex_stage = 0;
   release_temps(ctx, &p);
d1215 5
a1219 2
   if (key->enabled_units && key->num_draw_buffers) {
      GLboolean needbumpstage = GL_FALSE;
d1221 1
d1223 1
a1223 1
      for (unit = 0; unit < key->nr_enabled_units; unit++)
d1226 1
a1226 2
	    needbumpstage = GL_TRUE;
	    load_texunit_bumpmap( &p, unit );
d1228 1
a1228 2
      if (needbumpstage)
	 p.program->Base.NumTexIndirections++;
d1236 1
a1236 2
	    load_texunit_sources( &p, unit );
	    p.last_tex_stage = unit;
d1241 1
a1241 1
      for (unit = 0; unit < key->nr_enabled_units; unit++)
d1243 1
a1243 3
	    p.src_previous = emit_texenv( &p, unit );
            reserve_temp(&p, p.src_previous); /* don't re-use this temp reg */
	    release_temps(ctx, &p);	/* release all temps */
d1245 1
d1248 1
a1248 1
   cf = get_source( &p, SRC_PREVIOUS, 0 );
d1250 13
a1262 5
   for (i = 0; i < key->num_draw_buffers; i++) {
      if (key->num_draw_buffers == 1)
	 out = make_ureg( PROGRAM_OUTPUT, FRAG_RESULT_COLOR );
      else {
	 out = make_ureg( PROGRAM_OUTPUT, FRAG_RESULT_DATA0 + i );
d1265 4
a1268 13
      if (key->separate_specular) {
	 /* Emit specular add.
	  */
	 struct ureg s = register_input(&p, FRAG_ATTRIB_COL1);
	 emit_arith( &p, OPCODE_ADD, out, WRITEMASK_XYZ, 0, cf, s, undef );
	 emit_arith( &p, OPCODE_MOV, out, WRITEMASK_W, 0, cf, undef, undef );
      }
      else if (memcmp(&cf, &out, sizeof(cf)) != 0) {
	 /* Will wind up in here if no texture enabled or a couple of
	  * other scenarios (GL_REPLACE for instance).
	  */
	 emit_arith( &p, OPCODE_MOV, out, WRITEMASK_XYZW, 0, cf, undef, undef );
      }
a1269 3
   /* Finish up:
    */
   emit_arith( &p, OPCODE_END, undef, WRITEMASK_XYZW, 0, undef, undef, undef);
d1271 2
a1272 11
   /* Allocate final instruction array.  This has to be done before calling
    * _mesa_append_fog_code because that function frees the Base.Instructions.
    * At this point, Base.Instructions points to stack data, so it's a really
    * bad idea to free it.
    */
   p.program->Base.Instructions
      = _mesa_alloc_instructions(p.program->Base.NumInstructions);
   if (!p.program->Base.Instructions) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY,
                  "generating tex env program");
      return;
a1273 2
   _mesa_copy_instructions(p.program->Base.Instructions, instBuffer,
                           p.program->Base.NumInstructions);
d1275 45
a1319 5
   /* Append fog code.  This must be done before checking the program against
    * the limits becuase it will potentially add some instructions.
    */
   if (key->fog_enabled) {
      _mesa_append_fog_code(ctx, p.program, ctx->Fog.Mode, GL_FALSE);
d1322 19
a1340 2
   if (p.program->Base.NumTexIndirections > ctx->Const.FragmentProgram.MaxTexIndirections) 
      program_error(&p, "Exceeded max nr indirect texture lookups");
d1342 3
a1344 2
   if (p.program->Base.NumTexInstructions > ctx->Const.FragmentProgram.MaxTexInstructions)
      program_error(&p, "Exceeded max TEX instructions");
d1346 7
a1352 2
   if (p.program->Base.NumAluInstructions > ctx->Const.FragmentProgram.MaxAluInstructions)
      program_error(&p, "Exceeded max ALU instructions");
d1354 1
a1354 1
   ASSERT(p.program->Base.NumInstructions <= MAX_INSTRUCTIONS);
d1356 3
a1358 13
   /* Notify driver the fragment program has (actually) changed.
    */
   if (ctx->Driver.ProgramStringNotify) {
      GLboolean ok = ctx->Driver.ProgramStringNotify(ctx,
                                                     GL_FRAGMENT_PROGRAM_ARB, 
                                                     &p.program->Base);
      /* Driver should be able to handle any texenv programs as long as
       * the driver correctly reported max number of texture units correctly,
       * etc.
       */
      ASSERT(ok);
      (void) ok; /* silence unused var warning */
   }
d1360 2
a1361 4
   if (DISASSEM) {
      _mesa_print_program(&p.program->Base);
      printf("\n");
   }
d1370 1
a1370 1
struct gl_fragment_program *
d1373 1
a1373 1
   struct gl_fragment_program *prog;
d1376 1
a1376 1
	
d1378 2
a1379 2
      
   prog = (struct gl_fragment_program *)
d1383 2
a1384 5
   if (!prog) {
      prog = (struct gl_fragment_program *) 
         ctx->Driver.NewProgram(ctx, GL_FRAGMENT_PROGRAM_ARB, 0);

      create_new_program(ctx, &key, prog);
d1386 2
a1387 2
      _mesa_program_cache_insert(ctx, ctx->FragmentProgram.Cache,
                                 &key, keySize, &prog->Base);
d1390 1
a1390 1
   return prog;
@


1.1.1.1
log
@Import Mesa 9.2.0
@
text
@a5 1
 * Copyright Â© 2010-2011 Intel Corporation
a32 4
#include "main/context.h"
#include "main/uniforms.h"
#include "main/macros.h"
#include "main/samplerobj.h"
a41 10
#include "main/uniforms.h"
#include "../glsl/glsl_types.h"
#include "../glsl/ir.h"
#include "../glsl/ir_builder.h"
#include "../glsl/glsl_symbol_table.h"
#include "../glsl/glsl_parser_extras.h"
#include "../glsl/ir_optimization.h"
#include "../program/ir_to_mesa.h"

using namespace ir_builder;
d62 1
a62 1
   struct gl_shader_program *data;
d79 7
d108 1
a108 1
      GLuint source_index:4;   /**< TEXTURE_x_INDEX */
d119 2
d296 1
a296 1
   return ffs(bit) - 1;
d301 1
d318 1
a318 1
       ctx->Shader.CurrentVertexProgram->_LinkedShaders[MESA_SHADER_VERTEX]);
d331 1
a331 1
      fp_inputs = (VARYING_BIT_COL0 | VARYING_BIT_TEX0);
d333 2
a334 1
   else if (!(vertexProgram || vertexShader)) {
d336 2
a337 2
      /* _NEW_VARYING_VP_INPUTS */
      GLbitfield64 varying_inputs = ctx->varying_vp_inputs;
d344 1
a344 1
         varying_inputs |= VARYING_BITS_TEX_ANY;
d351 1
a351 1
         fp_inputs |= VARYING_BIT_COL0;
d354 1
a354 1
            fp_inputs |= VARYING_BIT_COL1;
d359 1
a359 1
                    ctx->Texture._TexMatEnabled) << VARYING_SLOT_TEX0;
d365 1
a365 1
         fp_inputs |= VARYING_BIT_COL0;
d367 1
a367 1
         fp_inputs |= VARYING_BIT_COL1;
d370 1
a370 1
                    << VARYING_SLOT_TEX0);
d375 1
a375 1
      struct gl_program *vprog;
d383 1
a383 1
         vprog = ctx->Shader.CurrentVertexProgram->_LinkedShaders[MESA_SHADER_VERTEX]->Program;
d385 1
a385 1
         vprog = &ctx->VertexProgram.Current->Base;
d387 1
a387 1
      vp_outputs = vprog->OutputsWritten;
d394 1
a394 1
         vp_outputs |= VARYING_BITS_TEX_ANY;
d396 4
a399 4
      if (vp_outputs & (1 << VARYING_SLOT_COL0))
         fp_inputs |= VARYING_BIT_COL0;
      if (vp_outputs & (1 << VARYING_SLOT_COL1))
         fp_inputs |= VARYING_BIT_COL1;
d401 2
a402 2
      fp_inputs |= (((vp_outputs & VARYING_BITS_TEX_ANY) >> VARYING_SLOT_TEX0) 
                    << VARYING_SLOT_TEX0);
d416 1
a416 1
   GLbitfield inputs_referenced = VARYING_BIT_COL0;
a426 1
      const struct gl_sampler_object *samp;
a431 1
      samp = _mesa_get_samplerobj(ctx, i);
d437 1
a437 1
      inputs_referenced |= VARYING_BIT_TEX(i);
d443 1
a443 1
         ((samp->CompareMode == GL_COMPARE_R_TO_TEXTURE) &&
d474 4
d483 1
a483 1
      inputs_referenced |= VARYING_BIT_COL1;
d490 1
a490 1
      inputs_referenced |= VARYING_BIT_FOGC; /* maybe */
a495 6
   /* _NEW_COLOR */
   if (ctx->Color.AlphaEnabled && key->num_draw_buffers == 0) {
      /* if alpha test is enabled we need to emit at least one color */
      key->num_draw_buffers = 1;
   }

d506 30
d538 2
a539 5
class texenv_fragment_program : public ir_factory {
public:
   struct gl_shader_program *shader_program;
   struct gl_shader *shader;
   exec_list *top_instructions;
d542 6
a547 1
   ir_variable *src_texture[MAX_TEXTURE_COORD_UNITS];
d552 1
a552 3
   /* Texcoord override from bumpmapping. */
   ir_variable *texcoord_tex[MAX_TEXTURE_COORD_UNITS];

d557 1
a557 1
   ir_rvalue *src_previous;	/**< Reg containing color from previous
d560 6
d568 122
a689 2
static ir_rvalue *
get_current_attrib(texenv_fragment_program *p, GLuint attrib)
d691 11
a701 2
   ir_variable *current;
   ir_rvalue *val;
d703 16
a718 5
   current = p->shader->symbols->get_variable("gl_CurrentAttribFragMESA");
   current->max_array_access = MAX2(current->max_array_access, attrib);
   val = new(p->mem_ctx) ir_dereference_variable(current);
   ir_rvalue *index = new(p->mem_ctx) ir_constant(attrib);
   return new(p->mem_ctx) ir_dereference_array(val, index);
d721 2
a722 2
static ir_rvalue *
get_gl_Color(texenv_fragment_program *p)
d724 3
a726 6
   if (p->state->inputs_available & VARYING_BIT_COL0) {
      ir_variable *var = p->shader->symbols->get_variable("gl_Color");
      assert(var);
      return new(p->mem_ctx) ir_dereference_variable(var);
   } else {
      return get_current_attrib(p, VERT_ATTRIB_COLOR0);
d728 61
d790 1
d792 8
a799 3
static ir_rvalue *
get_source(texenv_fragment_program *p,
	   GLuint src, GLuint unit)
d801 9
a809 2
   ir_variable *var;
   ir_dereference *deref;
d811 111
d924 2
a925 1
      return new(p->mem_ctx) ir_dereference_variable(p->src_texture[unit]);
d935 2
a936 2
      return new(p->mem_ctx)
	 ir_dereference_variable(p->src_texture[src - SRC_TEXTURE0]);
d939 1
a939 6
      var = p->shader->symbols->get_variable("gl_TextureEnvColor");
      assert(var);
      deref = new(p->mem_ctx) ir_dereference_variable(var);
      var->max_array_access = MAX2(var->max_array_access, unit);
      return new(p->mem_ctx) ir_dereference_array(deref,
						  new(p->mem_ctx) ir_constant(unit));
d942 1
a942 3
      var = p->shader->symbols->get_variable("gl_Color");
      assert(var);
      return new(p->mem_ctx) ir_dereference_variable(var);
d945 1
a945 1
      return new(p->mem_ctx) ir_constant(0.0f);
d948 4
a951 5
      if (!p->src_previous) {
	 return get_gl_Color(p);
      } else {
	 return p->src_previous->clone(p->mem_ctx, NULL);
      }
d955 1
a955 1
      return NULL;
d959 5
a963 5
static ir_rvalue *
emit_combine_source(texenv_fragment_program *p,
		    GLuint unit,
		    GLuint source,
		    GLuint operand)
d965 1
a965 1
   ir_rvalue *src;
d971 20
a990 11
      return sub(new(p->mem_ctx) ir_constant(1.0f), src);

   case OPR_SRC_ALPHA:
      return src->type->is_scalar() ? src : swizzle_w(src);

   case OPR_ONE_MINUS_SRC_ALPHA: {
      ir_rvalue *const scalar = src->type->is_scalar() ? src : swizzle_w(src);

      return sub(new(p->mem_ctx) ir_constant(1.0f), scalar);
   }

d992 1
a992 1
      return new(p->mem_ctx) ir_constant(0.0f);
d994 1
a994 1
      return new(p->mem_ctx) ir_constant(1.0f);
d1043 8
a1050 15
static ir_rvalue *
smear(texenv_fragment_program *p, ir_rvalue *val)
{
   if (!val->type->is_scalar())
      return val;

   return swizzle_xxxx(val);
}

static ir_rvalue *
emit_combine(texenv_fragment_program *p,
	     GLuint unit,
	     GLuint nr,
	     GLuint mode,
	     const struct mode_opt *opt)
d1052 2
a1053 2
   ir_rvalue *src[MAX_COMBINER_TERMS];
   ir_rvalue *tmp0, *tmp1;
d1059 1
a1059 1
      src[i] = emit_combine_source( p, unit, opt[i].Source, opt[i].Operand );
d1063 4
a1066 2
      return src[0];

d1068 2
a1069 2
      return mul(src[0], src[1]);

d1071 2
a1072 2
      return add(src[0], src[1]);

d1074 8
a1081 2
      return add(add(src[0], src[1]), new(p->mem_ctx) ir_constant(-0.5f));

d1083 3
a1085 5
      /* Arg0 * (Arg2) + Arg1 * (1-Arg2) */
      tmp0 = mul(src[0], src[2]);
      tmp1 = mul(src[1], sub(new(p->mem_ctx) ir_constant(1.0f),
			     src[2]->clone(p->mem_ctx, NULL)));
      return add(tmp0, tmp1);
d1088 1
a1088 1
      return sub(src[0], src[1]);
d1094 4
a1097 2
      tmp0 = mul(src[0], new(p->mem_ctx) ir_constant(2.0f));
      tmp0 = add(tmp0, new(p->mem_ctx) ir_constant(-1.0f));
d1099 7
a1105 2
      tmp1 = mul(src[1], new(p->mem_ctx) ir_constant(2.0f));
      tmp1 = add(tmp1, new(p->mem_ctx) ir_constant(-1.0f));
d1107 7
a1113 1
      return dot(swizzle_xyz(smear(p, tmp0)), swizzle_xyz(smear(p, tmp1)));
d1116 11
a1126 6
      return add(mul(src[0], src[2]), src[1]);

   case MODE_MODULATE_SIGNED_ADD_ATI:
      return add(add(mul(src[0], src[2]), src[1]),
		 new(p->mem_ctx) ir_constant(-0.5f));

d1128 3
a1130 2
      return sub(mul(src[0], src[2]), src[1]);

d1132 7
a1138 2
      return add(mul(src[0], src[1]), mul(src[2], src[3]));

d1140 9
a1148 3
      return add(add(mul(src[0], src[1]), mul(src[2], src[3])),
		 new(p->mem_ctx) ir_constant(-0.5f));

d1159 1
d1163 2
a1164 2
static ir_rvalue *
emit_texenv(texenv_fragment_program *p, GLuint unit)
d1169 1
d1211 12
a1222 3
   ir_variable *temp_var = p->make_temp(glsl_type::vec4_type, "texenv_combine");
   ir_dereference *deref;
   ir_rvalue *val;
d1228 5
a1232 9
      val = emit_combine(p, unit,
			 key->unit[unit].NumArgsRGB,
			 key->unit[unit].ModeRGB,
			 key->unit[unit].OptRGB);
      val = smear(p, val);
      if (rgb_saturate)
	 val = saturate(val);

      p->emit(assign(temp_var, val));
d1236 5
a1240 8
      ir_rvalue *val = emit_combine(p, unit,
				    key->unit[unit].NumArgsRGB,
				    key->unit[unit].ModeRGB,
				    key->unit[unit].OptRGB);
      val = smear(p, val);
      if (rgb_saturate)
	 val = saturate(val);
      p->emit(assign(temp_var, val));
d1246 10
a1255 17
      val = emit_combine(p, unit,
			 key->unit[unit].NumArgsRGB,
			 key->unit[unit].ModeRGB,
			 key->unit[unit].OptRGB);
      val = swizzle_xyz(smear(p, val));
      if (rgb_saturate)
	 val = saturate(val);
      p->emit(assign(temp_var, val, WRITEMASK_XYZ));

      val = emit_combine(p, unit,
			 key->unit[unit].NumArgsA,
			 key->unit[unit].ModeA,
			 key->unit[unit].OptA);
      val = swizzle_w(smear(p, val));
      if (alpha_saturate)
	 val = saturate(val);
      p->emit(assign(temp_var, val, WRITEMASK_W));
a1257 2
   deref = new(p->mem_ctx) ir_dereference_variable(temp_var);

d1261 2
a1262 1
      ir_constant *shift;
d1265 1
a1265 1
	 shift = new(p->mem_ctx) ir_constant((float)(1 << rgb_shift));
d1268 5
a1272 8
	 float const_data[4] = {
	    float(1 << rgb_shift),
	    float(1 << rgb_shift),
	    float(1 << rgb_shift),
	    float(1 << alpha_shift)
	 };
	 shift = new(p->mem_ctx) ir_constant(glsl_type::vec4_type,
					     (ir_constant_data *)const_data);
d1274 2
a1275 2

      return saturate(mul(deref, shift));
d1278 1
a1278 1
      return deref;
d1285 1
a1285 1
static void load_texture( texenv_fragment_program *p, GLuint unit )
d1287 4
a1290 1
   ir_dereference *deref;
d1292 7
a1298 2
   if (p->src_texture[unit])
      return;
d1300 4
a1303 2
   const GLuint texTarget = p->state->unit[unit].source_index;
   ir_rvalue *texcoord;
d1305 16
a1320 69
   if (!(p->state->inputs_available & (VARYING_BIT_TEX0 << unit))) {
      texcoord = get_current_attrib(p, VERT_ATTRIB_TEX0 + unit);
   } else if (p->texcoord_tex[unit]) {
      texcoord = new(p->mem_ctx) ir_dereference_variable(p->texcoord_tex[unit]);
   } else {
      ir_variable *tc_array = p->shader->symbols->get_variable("gl_TexCoord");
      assert(tc_array);
      texcoord = new(p->mem_ctx) ir_dereference_variable(tc_array);
      ir_rvalue *index = new(p->mem_ctx) ir_constant(unit);
      texcoord = new(p->mem_ctx) ir_dereference_array(texcoord, index);
      tc_array->max_array_access = MAX2(tc_array->max_array_access, unit);
   }

   if (!p->state->unit[unit].enabled) {
      p->src_texture[unit] = p->make_temp(glsl_type::vec4_type,
					  "dummy_tex");
      p->emit(p->src_texture[unit]);

      p->emit(assign(p->src_texture[unit], new(p->mem_ctx) ir_constant(0.0f)));
      return ;
   }

   const glsl_type *sampler_type = NULL;
   int coords = 0;

   switch (texTarget) {
   case TEXTURE_1D_INDEX:
      if (p->state->unit[unit].shadow)
	 sampler_type = p->shader->symbols->get_type("sampler1DShadow");
      else
	 sampler_type = p->shader->symbols->get_type("sampler1D");
      coords = 1;
      break;
   case TEXTURE_1D_ARRAY_INDEX:
      if (p->state->unit[unit].shadow)
	 sampler_type = p->shader->symbols->get_type("sampler1DArrayShadow");
      else
	 sampler_type = p->shader->symbols->get_type("sampler1DArray");
      coords = 2;
      break;
   case TEXTURE_2D_INDEX:
      if (p->state->unit[unit].shadow)
	 sampler_type = p->shader->symbols->get_type("sampler2DShadow");
      else
	 sampler_type = p->shader->symbols->get_type("sampler2D");
      coords = 2;
      break;
   case TEXTURE_2D_ARRAY_INDEX:
      if (p->state->unit[unit].shadow)
	 sampler_type = p->shader->symbols->get_type("sampler2DArrayShadow");
      else
	 sampler_type = p->shader->symbols->get_type("sampler2DArray");
      coords = 3;
      break;
   case TEXTURE_RECT_INDEX:
      if (p->state->unit[unit].shadow)
	 sampler_type = p->shader->symbols->get_type("sampler2DRectShadow");
      else
	 sampler_type = p->shader->symbols->get_type("sampler2DRect");
      coords = 2;
      break;
   case TEXTURE_3D_INDEX:
      assert(!p->state->unit[unit].shadow);
      sampler_type = p->shader->symbols->get_type("sampler3D");
      coords = 3;
      break;
   case TEXTURE_CUBE_INDEX:
      if (p->state->unit[unit].shadow)
	 sampler_type = p->shader->symbols->get_type("samplerCubeShadow");
d1322 1
a1322 9
	 sampler_type = p->shader->symbols->get_type("samplerCube");
      coords = 3;
      break;
   case TEXTURE_EXTERNAL_INDEX:
      assert(!p->state->unit[unit].shadow);
      sampler_type = p->shader->symbols->get_type("samplerExternalOES");
      coords = 2;
      break;
   }
d1324 4
a1327 19
   p->src_texture[unit] = p->make_temp(glsl_type::vec4_type,
				       "tex");

   ir_texture *tex = new(p->mem_ctx) ir_texture(ir_tex);


   char *sampler_name = ralloc_asprintf(p->mem_ctx, "sampler_%d", unit);
   ir_variable *sampler = new(p->mem_ctx) ir_variable(sampler_type,
						      sampler_name,
						      ir_var_uniform);
   p->top_instructions->push_head(sampler);

   /* Set the texture unit for this sampler.  The linker will pick this value
    * up and do-the-right-thing.
    *
    * NOTE: The cast to int is important.  Without it, the constant will have
    * type uint, and things later on may get confused.
    */
   sampler->constant_value = new(p->mem_ctx) ir_constant(int(unit));
a1328 11
   deref = new(p->mem_ctx) ir_dereference_variable(sampler);
   tex->set_sampler(deref, glsl_type::vec4_type);

   tex->coordinate = new(p->mem_ctx) ir_swizzle(texcoord, 0, 1, 2, 3, coords);

   if (p->state->unit[unit].shadow) {
      texcoord = texcoord->clone(p->mem_ctx, NULL);
      tex->shadow_comparitor = new(p->mem_ctx) ir_swizzle(texcoord,
							  coords, 0, 0, 0,
							  1);
      coords++;
a1329 5

   texcoord = texcoord->clone(p->mem_ctx, NULL);
   tex->projector = swizzle_w(texcoord);

   p->emit(assign(p->src_texture[unit], tex));
d1332 2
a1333 3
static void
load_texenv_source(texenv_fragment_program *p,
		   GLuint src, GLuint unit)
d1355 2
d1364 1
a1364 1
load_texunit_sources( texenv_fragment_program *p, GLuint unit )
d1383 2
a1384 2
static void
load_texunit_bumpmap( texenv_fragment_program *p, GLuint unit )
d1388 5
a1392 13
   ir_rvalue *bump;
   ir_rvalue *texcoord;
   ir_variable *rot_mat_0, *rot_mat_1;

   rot_mat_0 = p->shader->symbols->get_variable("gl_BumpRotMatrix0MESA");
   rot_mat_1 = p->shader->symbols->get_variable("gl_BumpRotMatrix1MESA");

   ir_variable *tc_array = p->shader->symbols->get_variable("gl_TexCoord");
   assert(tc_array);
   texcoord = new(p->mem_ctx) ir_dereference_variable(tc_array);
   ir_rvalue *index = new(p->mem_ctx) ir_constant(bumpedUnitNr);
   texcoord = new(p->mem_ctx) ir_dereference_array(texcoord, index);
   tc_array->max_array_access = MAX2(tc_array->max_array_access, unit);
d1396 4
d1401 1
a1401 1
    * dest = Arg1 + (Arg0.xx * rotMat0) + (Arg0.yy * rotMat1)
d1404 4
a1407 1
   ir_rvalue *bump_x, *bump_y;
d1409 5
a1413 1
   texcoord = smear(p, texcoord);
d1415 1
a1415 14
   /* bump_texcoord = texcoord */
   ir_variable *bumped = p->make_temp(texcoord->type, "bump_texcoord");
   p->emit(bumped);
   p->emit(assign(bumped, texcoord));

   /* bump_texcoord.xy += arg0.x * rotmat0 + arg0.y * rotmat1 */
   bump = get_source(p, key->unit[unit].OptRGB[0].Source, unit);
   bump_x = mul(swizzle_x(bump), rot_mat_0);
   bump_y = mul(swizzle_y(bump->clone(p->mem_ctx, NULL)), rot_mat_1);

   p->emit(assign(bumped, add(swizzle_xy(bumped), add(bump_x, bump_y)),
		  WRITEMASK_XY));

   p->texcoord_tex[bumpedUnitNr] = bumped;
d1419 2
a1420 5
 * Applies the fog calculations.
 *
 * This is basically like the ARB_fragment_prorgam fog options.  Note
 * that ffvertex_prog.c produces fogcoord for us when
 * GL_FOG_COORDINATE_EXT is set to GL_FRAGMENT_DEPTH_EXT.
d1422 30
a1451 54
static ir_rvalue *
emit_fog_instructions(texenv_fragment_program *p,
		      ir_rvalue *fragcolor)
{
   struct state_key *key = p->state;
   ir_rvalue *f, *temp;
   ir_variable *params, *oparams;
   ir_variable *fogcoord;

   /* Temporary storage for the whole fog result.  Fog calculations
    * only affect rgb so we're hanging on to the .a value of fragcolor
    * this way.
    */
   ir_variable *fog_result = p->make_temp(glsl_type::vec4_type, "fog_result");
   p->emit(assign(fog_result, fragcolor));

   fragcolor = swizzle_xyz(fog_result);

   oparams = p->shader->symbols->get_variable("gl_FogParamsOptimizedMESA");
   fogcoord = p->shader->symbols->get_variable("gl_FogFragCoord");
   params = p->shader->symbols->get_variable("gl_Fog");
   f = new(p->mem_ctx) ir_dereference_variable(fogcoord);

   ir_variable *f_var = p->make_temp(glsl_type::float_type, "fog_factor");

   switch (key->fog_mode) {
   case FOG_LINEAR:
      /* f = (end - z) / (end - start)
       *
       * gl_MesaFogParamsOptimized gives us (-1 / (end - start)) and
       * (end / (end - start)) so we can generate a single MAD.
       */
      f = add(mul(f, swizzle_x(oparams)), swizzle_y(oparams));
      break;
   case FOG_EXP:
      /* f = e^(-(density * fogcoord))
       *
       * gl_MesaFogParamsOptimized gives us density/ln(2) so we can
       * use EXP2 which is generally the native instruction without
       * having to do any further math on the fog density uniform.
       */
      f = mul(f, swizzle_z(oparams));
      f = new(p->mem_ctx) ir_expression(ir_unop_neg, f);
      f = new(p->mem_ctx) ir_expression(ir_unop_exp2, f);
      break;
   case FOG_EXP2:
      /* f = e^(-(density * fogcoord)^2)
       *
       * gl_MesaFogParamsOptimized gives us density/sqrt(ln(2)) so we
       * can do this like FOG_EXP but with a squaring after the
       * multiply by density.
       */
      ir_variable *temp_var = p->make_temp(glsl_type::float_type, "fog_temp");
      p->emit(assign(temp_var, mul(f, swizzle_w(oparams))));
d1453 5
a1457 4
      f = mul(temp_var, temp_var);
      f = new(p->mem_ctx) ir_expression(ir_unop_neg, f);
      f = new(p->mem_ctx) ir_expression(ir_unop_exp2, f);
      break;
d1460 4
a1463 1
   p->emit(assign(f_var, saturate(f)));
d1465 4
a1468 4
   f = sub(new(p->mem_ctx) ir_constant(1.0f), f_var);
   temp = new(p->mem_ctx) ir_dereference_variable(params);
   temp = new(p->mem_ctx) ir_dereference_record(temp, "color");
   temp = mul(swizzle_xyz(temp), f);
d1470 2
a1471 1
   p->emit(assign(fog_result, add(temp, mul(fragcolor, f_var)), WRITEMASK_XYZ));
d1473 2
a1474 2
   return new(p->mem_ctx) ir_dereference_variable(fog_result);
}
a1475 7
static void
emit_instructions(texenv_fragment_program *p)
{
   struct state_key *key = p->state;
   GLuint unit;

   if (key->enabled_units) {
d1477 1
a1477 1
      for (unit = 0; unit < key->nr_enabled_units; unit++) {
d1480 2
a1481 1
	    load_texunit_bumpmap(p, unit);
d1483 2
a1484 1
      }
d1492 2
a1493 1
	    load_texunit_sources(p, unit);
d1498 1
a1498 1
      for (unit = 0; unit < key->nr_enabled_units; unit++) {
d1500 3
a1502 1
	    p->src_previous = emit_texenv(p, unit);
a1503 1
      }
d1506 1
a1506 1
   ir_rvalue *cf = get_source(p, SRC_PREVIOUS, 0);
d1508 5
a1512 13
   if (key->separate_specular) {
      ir_variable *spec_result = p->make_temp(glsl_type::vec4_type,
					      "specular_add");
      p->emit(assign(spec_result, cf));

      ir_rvalue *secondary;
      if (p->state->inputs_available & VARYING_BIT_COL1) {
	 ir_variable *var =
	    p->shader->symbols->get_variable("gl_SecondaryColor");
	 assert(var);
	 secondary = swizzle_xyz(var);
      } else {
	 secondary = swizzle_xyz(get_current_attrib(p, VERT_ATTRIB_COLOR1));
d1515 17
a1531 2
      p->emit(assign(spec_result, add(swizzle_xyz(spec_result), secondary),
		     WRITEMASK_XYZ));
d1533 11
a1543 1
      cf = new(p->mem_ctx) ir_dereference_variable(spec_result);
d1545 2
d1548 3
d1552 1
a1552 1
      cf = emit_fog_instructions(p, cf);
d1555 5
a1559 4
   ir_variable *frag_color = p->shader->symbols->get_variable("gl_FragColor");
   assert(frag_color);
   p->emit(assign(frag_color, cf));
}
d1561 2
a1562 21
/**
 * Generate a new fragment program which implements the context's
 * current texture env/combine mode.
 */
static struct gl_shader_program *
create_new_program(struct gl_context *ctx, struct state_key *key)
{
   texenv_fragment_program p;
   unsigned int unit;
   _mesa_glsl_parse_state *state;

   p.mem_ctx = ralloc_context(NULL);
   p.shader = ctx->Driver.NewShader(ctx, 0, GL_FRAGMENT_SHADER);
   p.shader->ir = new(p.shader) exec_list;
   state = new(p.shader) _mesa_glsl_parse_state(ctx, GL_FRAGMENT_SHADER,
						p.shader);
   p.shader->symbols = state->symbols;
   p.top_instructions = p.shader->ir;
   p.instructions = p.shader->ir;
   p.state = key;
   p.shader_program = ctx->Driver.NewShaderProgram(ctx, 0);
d1564 1
a1564 14
   /* Tell the linker to ignore the fact that we're building a
    * separate shader, in case we're in a GLES2 context that would
    * normally reject that.  The real problem is that we're building a
    * fixed function program in a GLES2 context at all, but that's a
    * big mess to clean up.
    */
   p.shader_program->InternalSeparateShader = GL_TRUE;

   state->language_version = 130;
   state->es_shader = false;
   if (_mesa_is_gles(ctx) && ctx->Extensions.OES_EGL_image_external)
      state->OES_EGL_image_external_enable = true;
   _mesa_glsl_initialize_types(state);
   _mesa_glsl_initialize_variables(p.instructions, state);
d1566 12
a1577 3
   for (unit = 0; unit < ctx->Const.MaxTextureUnits; unit++) {
      p.src_texture[unit] = NULL;
      p.texcoord_tex[unit] = NULL;
d1580 4
a1583 40
   p.src_previous = NULL;

   ir_function *main_f = new(p.mem_ctx) ir_function("main");
   p.emit(main_f);
   state->symbols->add_function(main_f);

   ir_function_signature *main_sig =
      new(p.mem_ctx) ir_function_signature(p.shader->symbols->get_type("void"));
   main_sig->is_defined = true;
   main_f->add_signature(main_sig);

   p.instructions = &main_sig->body;
   if (key->num_draw_buffers)
      emit_instructions(&p);

   validate_ir_tree(p.shader->ir);

   const struct gl_shader_compiler_options *options =
      &ctx->ShaderCompilerOptions[MESA_SHADER_FRAGMENT];

   while (do_common_optimization(p.shader->ir, false, false, 32, options))
      ;
   reparent_ir(p.shader->ir, p.shader->ir);

   p.shader->CompileStatus = true;
   p.shader->Version = state->language_version;
   p.shader->num_builtins_to_link = state->num_builtins_to_link;
   p.shader_program->Shaders =
      (gl_shader **)malloc(sizeof(*p.shader_program->Shaders));
   p.shader_program->Shaders[0] = p.shader;
   p.shader_program->NumShaders = 1;

   _mesa_glsl_link_shader(ctx, p.shader_program);

   if (!p.shader_program->LinkStatus)
      _mesa_problem(ctx, "Failed to link fixed function fragment shader: %s\n",
		    p.shader_program->InfoLog);

   ralloc_free(p.mem_ctx);
   return p.shader_program;
d1592 1
a1592 1
struct gl_shader_program *
d1595 1
a1595 1
   struct gl_shader_program *shader_program;
d1598 1
a1598 1

d1600 2
a1601 2

   shader_program = (struct gl_shader_program *)
d1605 5
a1609 2
   if (!shader_program) {
      shader_program = create_new_program(ctx, &key);
d1611 2
a1612 2
      _mesa_shader_cache_insert(ctx, ctx->FragmentProgram.Cache,
				&key, keySize, shader_program);
d1615 1
a1615 1
   return shader_program;
@


1.1.1.2
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2007 VMware, Inc.
d23 1
a23 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
d35 1
a45 1
#include "texobj.h"
d294 12
d321 3
a323 3
      (ctx->_Shader->CurrentProgram[MESA_SHADER_VERTEX] &&
       ctx->_Shader->CurrentProgram[MESA_SHADER_VERTEX]->LinkStatus &&
       ctx->_Shader->CurrentProgram[MESA_SHADER_VERTEX]->_LinkedShaders[MESA_SHADER_VERTEX]);
d387 1
a387 1
         vprog = ctx->_Shader->CurrentProgram[MESA_SHADER_VERTEX]->_LinkedShaders[MESA_SHADER_VERTEX]->Program;
d434 1
a434 1
      if (!texUnit->_Current || !texUnit->Enabled)
d445 2
a446 2
      key->unit[i].source_index = _mesa_tex_target_to_index(ctx,
                                                            texObj->Target);
d547 1
a547 2
   assert(current);
   current->data.max_array_access = MAX2(current->data.max_array_access, attrib);
d591 1
a591 1
      var->data.max_array_access = MAX2(var->data.max_array_access, unit);
d931 1
a931 1
      tc_array->data.max_array_access = MAX2(tc_array->data.max_array_access, unit);
a1099 1
   assert(rot_mat_0);
a1100 1
   assert(rot_mat_1);
d1107 1
a1107 1
   tc_array->data.max_array_access = MAX2(tc_array->data.max_array_access, unit);
a1160 1
   assert(oparams);
a1161 1
   assert(fogcoord);
a1162 1
   assert(params);
d1294 1
a1294 1
   state = new(p.shader) _mesa_glsl_parse_state(ctx, MESA_SHADER_FRAGMENT,
d1308 1
a1308 1
   p.shader_program->SeparateShader = GL_TRUE;
d1342 1
a1342 2
   while (do_common_optimization(p.shader->ir, false, false, options,
                                 ctx->Const.NativeIntegers))
d1348 1
a1348 1
   p.shader->uses_builtin_functions = state->uses_builtin_functions;
@


1.1.1.3
log
@Import Mesa 10.4.3
@
text
@d223 1
d253 1
d286 1
d458 10
d681 1
a681 1
smear(ir_rvalue *val)
d738 1
a738 1
      return dot(swizzle_xyz(smear(tmp0)), swizzle_xyz(smear(tmp1)));
d756 5
d780 4
d829 1
a829 1
      val = smear(val);
d841 1
a841 1
      val = smear(val);
d854 1
a854 1
      val = swizzle_xyz(smear(val));
d863 1
a863 1
      val = swizzle_w(smear(val));
d880 8
a887 9
         ir_constant_data const_data;

         const_data.f[0] = float(1 << rgb_shift);
         const_data.f[1] = float(1 << rgb_shift);
         const_data.f[2] = float(1 << rgb_shift);
         const_data.f[3] = float(1 << alpha_shift);

         shift = new(p->mem_ctx) ir_constant(glsl_type::vec4_type,
                                             &const_data);
d938 1
a938 1
	 sampler_type = glsl_type::sampler1DShadow_type;
d940 1
a940 1
	 sampler_type = glsl_type::sampler1D_type;
d945 1
a945 1
	 sampler_type = glsl_type::sampler1DArrayShadow_type;
d947 1
a947 1
	 sampler_type = glsl_type::sampler1DArray_type;
d952 1
a952 1
	 sampler_type = glsl_type::sampler2DShadow_type;
d954 1
a954 1
	 sampler_type = glsl_type::sampler2D_type;
d959 1
a959 1
	 sampler_type = glsl_type::sampler2DArrayShadow_type;
d961 1
a961 1
	 sampler_type = glsl_type::sampler2DArray_type;
d966 1
a966 1
	 sampler_type = glsl_type::sampler2DRectShadow_type;
d968 1
a968 1
	 sampler_type = glsl_type::sampler2DRect_type;
d973 1
a973 1
      sampler_type = glsl_type::sampler3D_type;
d978 1
a978 1
	 sampler_type = glsl_type::samplerCubeShadow_type;
d980 1
a980 1
	 sampler_type = glsl_type::samplerCube_type;
d985 1
a985 1
      sampler_type = glsl_type::samplerExternalOES_type;
d1077 50
d1216 8
d1294 1
a1294 1
   p.shader_program = ctx->Driver.NewShaderProgram(0);
d1323 1
a1323 1
      new(p.mem_ctx) ir_function_signature(glsl_type::void_type);
d1334 1
a1334 1
      &ctx->Const.ShaderCompilerOptions[MESA_SHADER_FRAGMENT];
@


1.1.1.4
log
@Import Mesa 10.2.9
@
text
@a222 1
#define MODE_BUMP_ENVMAP_ATI            15  /* special */
a251 1
   case GL_BUMP_ENVMAP_ATI: return MODE_BUMP_ENVMAP_ATI;
a283 1
   case MODE_BUMP_ENVMAP_ATI:
a454 10

      if (key->unit[i].ModeRGB == MODE_BUMP_ENVMAP_ATI) {
         /* requires some special translation */
         key->unit[i].NumArgsRGB = 2;
         key->unit[i].ScaleShiftRGB = 0;
         key->unit[i].OptRGB[0].Operand = OPR_SRC_COLOR;
         key->unit[i].OptRGB[0].Source = SRC_TEXTURE;
         key->unit[i].OptRGB[1].Operand = OPR_SRC_COLOR;
         key->unit[i].OptRGB[1].Source = texUnit->BumpTarget - GL_TEXTURE0 + SRC_TEXTURE0;
       }
d668 1
a668 1
smear(texenv_fragment_program *p, ir_rvalue *val)
d725 1
a725 1
      return dot(swizzle_xyz(smear(p, tmp0)), swizzle_xyz(smear(p, tmp1)));
a742 5

   case MODE_BUMP_ENVMAP_ATI:
      /* special - not handled here */
      assert(0);
      return src[0];
a761 4
   if (key->unit[unit].ModeRGB == MODE_BUMP_ENVMAP_ATI) {
      /* this isn't really a env stage delivering a color and handled elsewhere */
      return get_source(p, SRC_PREVIOUS, 0);
   }
d807 1
a807 1
      val = smear(p, val);
d819 1
a819 1
      val = smear(p, val);
d832 1
a832 1
      val = swizzle_xyz(smear(p, val));
d841 1
a841 1
      val = swizzle_w(smear(p, val));
d858 9
a866 8
	 float const_data[4] = {
	    float(1 << rgb_shift),
	    float(1 << rgb_shift),
	    float(1 << rgb_shift),
	    float(1 << alpha_shift)
	 };
	 shift = new(p->mem_ctx) ir_constant(glsl_type::vec4_type,
					     (ir_constant_data *)const_data);
d917 1
a917 1
	 sampler_type = p->shader->symbols->get_type("sampler1DShadow");
d919 1
a919 1
	 sampler_type = p->shader->symbols->get_type("sampler1D");
d924 1
a924 1
	 sampler_type = p->shader->symbols->get_type("sampler1DArrayShadow");
d926 1
a926 1
	 sampler_type = p->shader->symbols->get_type("sampler1DArray");
d931 1
a931 1
	 sampler_type = p->shader->symbols->get_type("sampler2DShadow");
d933 1
a933 1
	 sampler_type = p->shader->symbols->get_type("sampler2D");
d938 1
a938 1
	 sampler_type = p->shader->symbols->get_type("sampler2DArrayShadow");
d940 1
a940 1
	 sampler_type = p->shader->symbols->get_type("sampler2DArray");
d945 1
a945 1
	 sampler_type = p->shader->symbols->get_type("sampler2DRectShadow");
d947 1
a947 1
	 sampler_type = p->shader->symbols->get_type("sampler2DRect");
d952 1
a952 1
      sampler_type = p->shader->symbols->get_type("sampler3D");
d957 1
a957 1
	 sampler_type = p->shader->symbols->get_type("samplerCubeShadow");
d959 1
a959 1
	 sampler_type = p->shader->symbols->get_type("samplerCube");
d964 1
a964 1
      sampler_type = p->shader->symbols->get_type("samplerExternalOES");
a1055 50
 * Generate instructions for loading bump map textures.
 */
static void
load_texunit_bumpmap( texenv_fragment_program *p, GLuint unit )
{
   const struct state_key *key = p->state;
   GLuint bumpedUnitNr = key->unit[unit].OptRGB[1].Source - SRC_TEXTURE0;
   ir_rvalue *bump;
   ir_rvalue *texcoord;
   ir_variable *rot_mat_0, *rot_mat_1;

   rot_mat_0 = p->shader->symbols->get_variable("gl_BumpRotMatrix0MESA");
   assert(rot_mat_0);
   rot_mat_1 = p->shader->symbols->get_variable("gl_BumpRotMatrix1MESA");
   assert(rot_mat_1);

   ir_variable *tc_array = p->shader->symbols->get_variable("gl_TexCoord");
   assert(tc_array);
   texcoord = new(p->mem_ctx) ir_dereference_variable(tc_array);
   ir_rvalue *index = new(p->mem_ctx) ir_constant(bumpedUnitNr);
   texcoord = new(p->mem_ctx) ir_dereference_array(texcoord, index);
   tc_array->data.max_array_access = MAX2(tc_array->data.max_array_access, unit);

   load_texenv_source( p, unit + SRC_TEXTURE0, unit );

   /* Apply rot matrix and add coords to be available in next phase.
    * dest = Arg1 + (Arg0.xx * rotMat0) + (Arg0.yy * rotMat1)
    * note only 2 coords are affected the rest are left unchanged (mul by 0)
    */
   ir_rvalue *bump_x, *bump_y;

   texcoord = smear(p, texcoord);

   /* bump_texcoord = texcoord */
   ir_variable *bumped = p->make_temp(texcoord->type, "bump_texcoord");
   p->emit(bumped);
   p->emit(assign(bumped, texcoord));

   /* bump_texcoord.xy += arg0.x * rotmat0 + arg0.y * rotmat1 */
   bump = get_source(p, key->unit[unit].OptRGB[0].Source, unit);
   bump_x = mul(swizzle_x(bump), rot_mat_0);
   bump_y = mul(swizzle_y(bump->clone(p->mem_ctx, NULL)), rot_mat_1);

   p->emit(assign(bumped, add(swizzle_xy(bumped), add(bump_x, bump_y)),
		  WRITEMASK_XY));

   p->texcoord_tex[bumpedUnitNr] = bumped;
}

/**
a1144 8
      /* Zeroth pass - bump map textures first */
      for (unit = 0; unit < key->nr_enabled_units; unit++) {
	 if (key->unit[unit].enabled &&
             key->unit[unit].ModeRGB == MODE_BUMP_ENVMAP_ATI) {
	    load_texunit_bumpmap(p, unit);
	 }
      }

d1215 1
a1215 1
   p.shader_program = ctx->Driver.NewShaderProgram(ctx, 0);
d1244 1
a1244 1
      new(p.mem_ctx) ir_function_signature(p.shader->symbols->get_type("void"));
d1255 1
a1255 1
      &ctx->ShaderCompilerOptions[MESA_SHADER_FRAGMENT];
@


