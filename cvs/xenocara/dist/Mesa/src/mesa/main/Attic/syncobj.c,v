head	1.9;
access;
symbols
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	v10_2_9:1.1.1.6
	v10_4_3:1.1.1.5
	v10_2_7:1.1.1.4
	OPENBSD_5_6:1.6.0.2
	OPENBSD_5_6_BASE:1.6
	v10_2_3:1.1.1.4
	OPENBSD_5_5:1.5.0.2
	OPENBSD_5_5_BASE:1.5
	v9_2_5:1.1.1.3
	v9_2_3:1.1.1.3
	v9_2_2:1.1.1.3
	v9_2_1:1.1.1.3
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.9
date	2015.12.23.05.17.53;	author jsg;	state dead;
branches;
next	1.8;
commitid	TnlogFl9nOv2eaRf;

1.8
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.7;
commitid	4ry2gvZGMXkCUD2n;

1.7
date	2015.01.25.14.41.22;	author jsg;	state Exp;
branches;
next	1.6;
commitid	mcxB0JvoI9gTDYXU;

1.6
date	2014.07.09.21.09.00;	author jsg;	state Exp;
branches;
next	1.5;
commitid	WPD6rgPryPkvXOr9;

1.5
date	2013.10.05.09.54.00;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2013.09.05.14.06.29;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.19;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.42;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.31;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.46;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.16.50;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2013.10.05.09.26.30;	author jsg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.07.09.20.35.05;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.5
date	2015.01.25.14.12.54;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.6
date	2015.02.20.22.50.01;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.9
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright Â© 2009 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 * \file syncobj.c
 * Sync object management.
 *
 * Unlike textures and other objects that are shared between contexts, sync
 * objects are not bound to the context.  As a result, the reference counting
 * and delete behavior of sync objects is slightly different.  References to
 * sync objects are added:
 *
 *    - By \c glFencSynce.  This sets the initial reference count to 1.
 *    - At the start of \c glClientWaitSync.  The reference is held for the
 *      duration of the wait call.
 *
 * References are removed:
 *
 *    - By \c glDeleteSync.
 *    - At the end of \c glClientWaitSync.
 *
 * Additionally, drivers may call \c _mesa_ref_sync_object and
 * \c _mesa_unref_sync_object as needed to implement \c ServerWaitSync.
 *
 * As with shader objects, sync object names become invalid as soon as
 * \c glDeleteSync is called.  For this reason \c glDeleteSync sets the
 * \c DeletePending flag.  All functions validate object handles by testing
 * this flag.
 *
 * \note
 * Only \c GL_ARB_sync objects are shared between contexts.  If support is ever
 * added for either \c GL_NV_fence or \c GL_APPLE_fence different semantics
 * will need to be implemented.
 *
 * \author Ian Romanick <ian.d.romanick@@intel.com>
 */

#include <inttypes.h>
#include "glheader.h"
#include "imports.h"
#include "context.h"
#include "macros.h"
#include "get.h"
#include "dispatch.h"
#include "mtypes.h"
#include "set.h"
#include "hash_table.h"

#include "syncobj.h"

static struct gl_sync_object *
_mesa_new_sync_object(struct gl_context *ctx, GLenum type)
{
   struct gl_sync_object *s = CALLOC_STRUCT(gl_sync_object);
   (void) ctx;
   (void) type;

   return s;
}


static void
_mesa_delete_sync_object(struct gl_context *ctx, struct gl_sync_object *syncObj)
{
   (void) ctx;
   free(syncObj->Label);
   free(syncObj);
}


static void
_mesa_fence_sync(struct gl_context *ctx, struct gl_sync_object *syncObj,
		 GLenum condition, GLbitfield flags)
{
   (void) ctx;
   (void) condition;
   (void) flags;

   syncObj->StatusFlag = 1;
}


static void
_mesa_check_sync(struct gl_context *ctx, struct gl_sync_object *syncObj)
{
   (void) ctx;
   (void) syncObj;

   /* No-op for software rendering.  Hardware drivers will need to determine
    * whether the state of the sync object has changed.
    */
}


static void
_mesa_wait_sync(struct gl_context *ctx, struct gl_sync_object *syncObj,
		GLbitfield flags, GLuint64 timeout)
{
   (void) ctx;
   (void) syncObj;
   (void) flags;
   (void) timeout;

   /* No-op for software rendering.  Hardware drivers will need to wait until
    * the state of the sync object changes or the timeout expires.
    */
}


void
_mesa_init_sync_object_functions(struct dd_function_table *driver)
{
   driver->NewSyncObject = _mesa_new_sync_object;
   driver->FenceSync = _mesa_fence_sync;
   driver->DeleteSyncObject = _mesa_delete_sync_object;
   driver->CheckSync = _mesa_check_sync;

   /* Use the same no-op wait function for both.
    */
   driver->ClientWaitSync = _mesa_wait_sync;
   driver->ServerWaitSync = _mesa_wait_sync;
}

/**
 * Allocate/init the context state related to sync objects.
 */
void
_mesa_init_sync(struct gl_context *ctx)
{
   (void) ctx;
}


/**
 * Free the context state related to sync objects.
 */
void
_mesa_free_sync_data(struct gl_context *ctx)
{
   (void) ctx;
}


/**
 * Check if the given sync object is:
 *  - non-null
 *  - not in sync objects hash table
 *  - type is GL_SYNC_FENCE
 *  - not marked as deleted
 */
bool
_mesa_validate_sync(struct gl_context *ctx,
                    const struct gl_sync_object *syncObj)
{
   return (syncObj != NULL)
      && _mesa_set_search(ctx->Shared->SyncObjects,
                          _mesa_hash_pointer(syncObj),
                          syncObj) != NULL
      && (syncObj->Type == GL_SYNC_FENCE)
      && !syncObj->DeletePending;
}


void
_mesa_ref_sync_object(struct gl_context *ctx, struct gl_sync_object *syncObj)
{
   mtx_lock(&ctx->Shared->Mutex);
   syncObj->RefCount++;
   mtx_unlock(&ctx->Shared->Mutex);
}


void
_mesa_unref_sync_object(struct gl_context *ctx, struct gl_sync_object *syncObj)
{
   struct set_entry *entry;

   mtx_lock(&ctx->Shared->Mutex);
   syncObj->RefCount--;
   if (syncObj->RefCount == 0) {
      entry = _mesa_set_search(ctx->Shared->SyncObjects,
                               _mesa_hash_pointer(syncObj),
                               syncObj);
      assert (entry != NULL);
      _mesa_set_remove(ctx->Shared->SyncObjects, entry);
      mtx_unlock(&ctx->Shared->Mutex);

      ctx->Driver.DeleteSyncObject(ctx, syncObj);
   } else {
      mtx_unlock(&ctx->Shared->Mutex);
   }
}


GLboolean GLAPIENTRY
_mesa_IsSync(GLsync sync)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_sync_object *const syncObj = (struct gl_sync_object *) sync;
   ASSERT_OUTSIDE_BEGIN_END_WITH_RETVAL(ctx, GL_FALSE);

   return _mesa_validate_sync(ctx, syncObj) ? GL_TRUE : GL_FALSE;
}


void GLAPIENTRY
_mesa_DeleteSync(GLsync sync)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_sync_object *const syncObj = (struct gl_sync_object *) sync;

   /* From the GL_ARB_sync spec:
    *
    *    DeleteSync will silently ignore a <sync> value of zero. An
    *    INVALID_VALUE error is generated if <sync> is neither zero nor the
    *    name of a sync object.
    */
   if (sync == 0) {
      return;
   }

   if (!_mesa_validate_sync(ctx, syncObj)) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glDeleteSync (not a valid sync object)");
      return;
   }

   /* If there are no client-waits or server-waits pending on this sync, delete
    * the underlying object.
    */
   syncObj->DeletePending = GL_TRUE;
   _mesa_unref_sync_object(ctx, syncObj);
}


GLsync GLAPIENTRY
_mesa_FenceSync(GLenum condition, GLbitfield flags)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_sync_object *syncObj;
   ASSERT_OUTSIDE_BEGIN_END_WITH_RETVAL(ctx, 0);

   if (condition != GL_SYNC_GPU_COMMANDS_COMPLETE) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glFenceSync(condition=0x%x)",
		  condition);
      return 0;
   }

   if (flags != 0) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glFenceSync(flags=0x%x)",
		  condition);
      return 0;
   }

   syncObj = ctx->Driver.NewSyncObject(ctx, GL_SYNC_FENCE);
   if (syncObj != NULL) {
      syncObj->Type = GL_SYNC_FENCE;
      /* The name is not currently used, and it is never visible to
       * applications.  If sync support is extended to provide support for
       * NV_fence, this field will be used.  We'll also need to add an object
       * ID hashtable.
       */
      syncObj->Name = 1;
      syncObj->RefCount = 1;
      syncObj->DeletePending = GL_FALSE;
      syncObj->SyncCondition = condition;
      syncObj->Flags = flags;
      syncObj->StatusFlag = 0;

      ctx->Driver.FenceSync(ctx, syncObj, condition, flags);

      mtx_lock(&ctx->Shared->Mutex);
      _mesa_set_add(ctx->Shared->SyncObjects,
                    _mesa_hash_pointer(syncObj),
                    syncObj);
      mtx_unlock(&ctx->Shared->Mutex);

      return (GLsync) syncObj;
   }

   return NULL;
}


GLenum GLAPIENTRY
_mesa_ClientWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_sync_object *const syncObj = (struct gl_sync_object *) sync;
   GLenum ret;
   ASSERT_OUTSIDE_BEGIN_END_WITH_RETVAL(ctx, GL_WAIT_FAILED);

   if (!_mesa_validate_sync(ctx, syncObj)) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glClientWaitSync (not a valid sync object)");
      return GL_WAIT_FAILED;
   }

   if ((flags & ~GL_SYNC_FLUSH_COMMANDS_BIT) != 0) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glClientWaitSync(flags=0x%x)", flags);
      return GL_WAIT_FAILED;
   }

   _mesa_ref_sync_object(ctx, syncObj);

   /* From the GL_ARB_sync spec:
    *
    *    ClientWaitSync returns one of four status values. A return value of
    *    ALREADY_SIGNALED indicates that <sync> was signaled at the time
    *    ClientWaitSync was called. ALREADY_SIGNALED will always be returned
    *    if <sync> was signaled, even if the value of <timeout> is zero.
    */
   ctx->Driver.CheckSync(ctx, syncObj);
   if (syncObj->StatusFlag) {
      ret = GL_ALREADY_SIGNALED;
   } else {
      if (timeout == 0) {
         ret = GL_TIMEOUT_EXPIRED;
      } else {
         ctx->Driver.ClientWaitSync(ctx, syncObj, flags, timeout);

         ret = syncObj->StatusFlag ? GL_CONDITION_SATISFIED : GL_TIMEOUT_EXPIRED;
      }
   }

   _mesa_unref_sync_object(ctx, syncObj);
   return ret;
}


void GLAPIENTRY
_mesa_WaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_sync_object *const syncObj = (struct gl_sync_object *) sync;

   if (!_mesa_validate_sync(ctx, syncObj)) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glWaitSync (not a valid sync object)");
      return;
   }

   if (flags != 0) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glWaitSync(flags=0x%x)", flags);
      return;
   }

   if (timeout != GL_TIMEOUT_IGNORED) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glWaitSync(timeout=0x%" PRIx64 ")",
                  (uint64_t) timeout);
      return;
   }

   ctx->Driver.ServerWaitSync(ctx, syncObj, flags, timeout);
}


void GLAPIENTRY
_mesa_GetSynciv(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length,
		GLint *values)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_sync_object *const syncObj = (struct gl_sync_object *) sync;
   GLsizei size = 0;
   GLint v[1];

   if (!_mesa_validate_sync(ctx, syncObj)) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glGetSynciv (not a valid sync object)");
      return;
   }

   switch (pname) {
   case GL_OBJECT_TYPE:
      v[0] = syncObj->Type;
      size = 1;
      break;

   case GL_SYNC_CONDITION:
      v[0] = syncObj->SyncCondition;
      size = 1;
      break;

   case GL_SYNC_STATUS:
      /* Update the state of the sync by dipping into the driver.  Note that
       * this call won't block.  It just updates state in the common object
       * data from the current driver state.
       */
      ctx->Driver.CheckSync(ctx, syncObj);

      v[0] = (syncObj->StatusFlag) ? GL_SIGNALED : GL_UNSIGNALED;
      size = 1;
      break;

   case GL_SYNC_FLAGS:
      v[0] = syncObj->Flags;
      size = 1;
      break;

   default:
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetSynciv(pname=0x%x)\n", pname);
      return;
   }

   if (size > 0 && bufSize > 0) {
      const GLsizei copy_count = MIN2(size, bufSize);

      memcpy(values, v, sizeof(GLint) * copy_count);
   }

   if (length != NULL) {
      *length = size;
   }
}
@


1.8
log
@Merge Mesa 10.2.9
@
text
@@


1.7
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d67 1
a67 1
#include "util/hash_table.h"
@


1.6
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d67 1
a67 1
#include "hash_table.h"
@


1.5
log
@Merge Mesa 9.2.1
@
text
@d74 1
a74 1
   struct gl_sync_object *s = MALLOC_STRUCT(gl_sync_object);
d86 1
d164 10
a173 2
static int
_mesa_validate_sync(struct gl_context *ctx, struct gl_sync_object *syncObj)
d187 1
a187 1
   _glthread_LOCK_MUTEX(ctx->Shared->Mutex);
d189 1
a189 1
   _glthread_UNLOCK_MUTEX(ctx->Shared->Mutex);
d198 1
a198 1
   _glthread_LOCK_MUTEX(ctx->Shared->Mutex);
d206 1
a206 1
      _glthread_UNLOCK_MUTEX(ctx->Shared->Mutex);
d210 1
a210 1
      _glthread_UNLOCK_MUTEX(ctx->Shared->Mutex);
d291 1
a291 1
      _glthread_LOCK_MUTEX(ctx->Shared->Mutex);
d295 1
a295 1
      _glthread_UNLOCK_MUTEX(ctx->Shared->Mutex);
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d412 1
a412 1
   if (size > 0) {
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d58 1
a62 1
#include "mfeatures.h"
d66 2
a68 1
#if FEATURE_ARB_sync
a142 14

void
_mesa_init_sync_dispatch(struct _glapi_table *disp)
{
   SET_IsSync(disp, _mesa_IsSync);
   SET_DeleteSync(disp, _mesa_DeleteSync);
   SET_FenceSync(disp, _mesa_FenceSync);
   SET_ClientWaitSync(disp, _mesa_ClientWaitSync);
   SET_WaitSync(disp, _mesa_WaitSync);
   SET_GetInteger64v(disp, _mesa_GetInteger64v);
   SET_GetSynciv(disp, _mesa_GetSynciv);
}


d164 1
a164 1
_mesa_validate_sync(struct gl_sync_object *syncObj)
d167 3
d187 2
d192 5
a196 1
      remove_from_list(& syncObj->link);
d213 1
a213 1
   return _mesa_validate_sync(syncObj) ? GL_TRUE : GL_FALSE;
a221 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d233 2
a234 2
   if (!_mesa_validate_sync(syncObj)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glDeleteSync");
d283 3
a285 1
      insert_at_tail(& ctx->Shared->SyncObjects, & syncObj->link);
d303 2
a304 2
   if (!_mesa_validate_sync(syncObj)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glClientWaitSync");
d309 1
a309 1
      _mesa_error(ctx, GL_INVALID_ENUM, "glClientWaitSync(flags=0x%x)", flags);
d326 4
a329 1
      ctx->Driver.ClientWaitSync(ctx, syncObj, flags, timeout);
d331 2
a332 1
      ret = syncObj->StatusFlag ? GL_CONDITION_SATISFIED : GL_TIMEOUT_EXPIRED;
a344 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d346 2
a347 2
   if (!_mesa_validate_sync(syncObj)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glWaitSync");
d352 1
a352 1
      _mesa_error(ctx, GL_INVALID_ENUM, "glWaitSync(flags=0x%x)", flags);
d356 3
a358 5
   /* From the GL_ARB_sync spec:
    *
    *     If the value of <timeout> is zero, then WaitSync does nothing.
    */
   if (timeout == 0) {
a373 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d375 2
a376 2
   if (!_mesa_validate_sync(syncObj)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glGetSynciv");
a421 2

#endif /* FEATURE_ARB_sync */
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d62 1
d65 1
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d62 2
d69 1
a69 1
_mesa_new_sync_object(GLcontext *ctx, GLenum type)
d80 1
a80 1
_mesa_delete_sync_object(GLcontext *ctx, struct gl_sync_object *syncObj)
d88 1
a88 1
_mesa_fence_sync(GLcontext *ctx, struct gl_sync_object *syncObj,
d100 1
a100 1
_mesa_check_sync(GLcontext *ctx, struct gl_sync_object *syncObj)
d112 1
a112 1
_mesa_wait_sync(GLcontext *ctx, struct gl_sync_object *syncObj,
d141 13
d158 1
a158 1
_mesa_init_sync(GLcontext *ctx)
d168 1
a168 1
_mesa_free_sync_data(GLcontext *ctx)
d184 1
a184 1
_mesa_ref_sync_object(GLcontext *ctx, struct gl_sync_object *syncObj)
d193 1
a193 1
_mesa_unref_sync_object(GLcontext *ctx, struct gl_sync_object *syncObj)
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a61 2
#include "get.h"
#include "dispatch.h"
d67 1
a67 1
_mesa_new_sync_object(struct gl_context *ctx, GLenum type)
d78 1
a78 1
_mesa_delete_sync_object(struct gl_context *ctx, struct gl_sync_object *syncObj)
d86 1
a86 1
_mesa_fence_sync(struct gl_context *ctx, struct gl_sync_object *syncObj,
d98 1
a98 1
_mesa_check_sync(struct gl_context *ctx, struct gl_sync_object *syncObj)
d110 1
a110 1
_mesa_wait_sync(struct gl_context *ctx, struct gl_sync_object *syncObj,
a138 13
void
_mesa_init_sync_dispatch(struct _glapi_table *disp)
{
   SET_IsSync(disp, _mesa_IsSync);
   SET_DeleteSync(disp, _mesa_DeleteSync);
   SET_FenceSync(disp, _mesa_FenceSync);
   SET_ClientWaitSync(disp, _mesa_ClientWaitSync);
   SET_WaitSync(disp, _mesa_WaitSync);
   SET_GetInteger64v(disp, _mesa_GetInteger64v);
   SET_GetSynciv(disp, _mesa_GetSynciv);
}


d143 1
a143 1
_mesa_init_sync(struct gl_context *ctx)
d153 1
a153 1
_mesa_free_sync_data(struct gl_context *ctx)
d169 1
a169 1
_mesa_ref_sync_object(struct gl_context *ctx, struct gl_sync_object *syncObj)
d178 1
a178 1
_mesa_unref_sync_object(struct gl_context *ctx, struct gl_sync_object *syncObj)
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a57 1
#include <inttypes.h>
a63 3
#include "mtypes.h"
#include "set.h"
#include "hash_table.h"
d65 1
d140 14
d175 1
a175 1
_mesa_validate_sync(struct gl_context *ctx, struct gl_sync_object *syncObj)
a177 3
      && _mesa_set_search(ctx->Shared->SyncObjects,
                          _mesa_hash_pointer(syncObj),
                          syncObj) != NULL
a194 2
   struct set_entry *entry;

d198 1
a198 5
      entry = _mesa_set_search(ctx->Shared->SyncObjects,
                               _mesa_hash_pointer(syncObj),
                               syncObj);
      assert (entry != NULL);
      _mesa_set_remove(ctx->Shared->SyncObjects, entry);
d215 1
a215 1
   return _mesa_validate_sync(ctx, syncObj) ? GL_TRUE : GL_FALSE;
d224 1
d236 2
a237 2
   if (!_mesa_validate_sync(ctx, syncObj)) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glDeleteSync (not a valid sync object)");
d286 1
a286 3
      _mesa_set_add(ctx->Shared->SyncObjects,
                    _mesa_hash_pointer(syncObj),
                    syncObj);
d304 2
a305 2
   if (!_mesa_validate_sync(ctx, syncObj)) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glClientWaitSync (not a valid sync object)");
d310 1
a310 1
      _mesa_error(ctx, GL_INVALID_VALUE, "glClientWaitSync(flags=0x%x)", flags);
d327 1
a327 4
      if (timeout == 0) {
         ret = GL_TIMEOUT_EXPIRED;
      } else {
         ctx->Driver.ClientWaitSync(ctx, syncObj, flags, timeout);
d329 1
a329 2
         ret = syncObj->StatusFlag ? GL_CONDITION_SATISFIED : GL_TIMEOUT_EXPIRED;
      }
d342 1
d344 2
a345 2
   if (!_mesa_validate_sync(ctx, syncObj)) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glWaitSync (not a valid sync object)");
d350 1
a350 1
      _mesa_error(ctx, GL_INVALID_VALUE, "glWaitSync(flags=0x%x)", flags);
d354 5
a358 3
   if (timeout != GL_TIMEOUT_IGNORED) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glWaitSync(timeout=0x%" PRIx64 ")",
                  (uint64_t) timeout);
d374 1
d376 2
a377 2
   if (!_mesa_validate_sync(ctx, syncObj)) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glGetSynciv (not a valid sync object)");
d423 2
@


1.1.1.3
log
@Import Mesa 9.2.1
@
text
@d412 1
a412 1
   if (size > 0 && bufSize > 0) {
@


1.1.1.4
log
@Import Mesa 10.2.3
@
text
@d74 1
a74 1
   struct gl_sync_object *s = CALLOC_STRUCT(gl_sync_object);
a85 1
   free(syncObj->Label);
d163 2
a164 10
/**
 * Check if the given sync object is:
 *  - non-null
 *  - not in sync objects hash table
 *  - type is GL_SYNC_FENCE
 *  - not marked as deleted
 */
bool
_mesa_validate_sync(struct gl_context *ctx,
                    const struct gl_sync_object *syncObj)
d178 1
a178 1
   mtx_lock(&ctx->Shared->Mutex);
d180 1
a180 1
   mtx_unlock(&ctx->Shared->Mutex);
d189 1
a189 1
   mtx_lock(&ctx->Shared->Mutex);
d197 1
a197 1
      mtx_unlock(&ctx->Shared->Mutex);
d201 1
a201 1
      mtx_unlock(&ctx->Shared->Mutex);
d282 1
a282 1
      mtx_lock(&ctx->Shared->Mutex);
d286 1
a286 1
      mtx_unlock(&ctx->Shared->Mutex);
@


1.1.1.5
log
@Import Mesa 10.4.3
@
text
@d67 1
a67 1
#include "util/hash_table.h"
@


1.1.1.6
log
@Import Mesa 10.2.9
@
text
@d67 1
a67 1
#include "hash_table.h"
@


