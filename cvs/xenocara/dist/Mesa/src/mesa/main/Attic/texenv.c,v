head	1.9;
access;
symbols
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.6.0.2
	OPENBSD_5_6_BASE:1.6
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.5.0.2
	OPENBSD_5_5_BASE:1.5
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.4.0.4
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.2
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.3.0.4
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.2.0.6
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.0.4
	OPENBSD_4_7_BASE:1.1
	OPENBSD_4_6:1.1.0.2
	OPENBSD_4_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.9
date	2015.12.23.05.17.53;	author jsg;	state dead;
branches;
next	1.8;
commitid	TnlogFl9nOv2eaRf;

1.8
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.7;
commitid	4ry2gvZGMXkCUD2n;

1.7
date	2015.01.25.14.41.22;	author jsg;	state Exp;
branches;
next	1.6;
commitid	mcxB0JvoI9gTDYXU;

1.6
date	2014.07.09.21.09.00;	author jsg;	state Exp;
branches;
next	1.5;
commitid	WPD6rgPryPkvXOr9;

1.5
date	2013.09.05.14.06.30;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2012.08.17.13.58.19;	author mpi;	state Exp;
branches;
next	1.3;

1.3
date	2011.10.23.13.37.43;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.05.22.20.06.31;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2009.05.17.20.26.41;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.47;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.16.51;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.35.05;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.12.55;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.50.02;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.9
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2008  Brian Paul   All Rights Reserved.
 * Copyright (C) 2009  VMware, Inc.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

/** 
 * \file texenv.c
 *
 * glTexEnv-related functions
 */


#include "main/glheader.h"
#include "main/context.h"
#include "main/blend.h"
#include "main/enums.h"
#include "main/macros.h"
#include "main/mtypes.h"
#include "main/state.h"
#include "main/texenv.h"
#include "main/texstate.h"


#define TE_ERROR(errCode, msg, value)				\
   _mesa_error(ctx, errCode, msg, _mesa_lookup_enum_by_nr(value));


/** Set texture env mode */
static void
set_env_mode(struct gl_context *ctx,
             struct gl_texture_unit *texUnit,
             GLenum mode)
{
   GLboolean legal;

   if (texUnit->EnvMode == mode)
      return;

   switch (mode) {
   case GL_MODULATE:
   case GL_BLEND:
   case GL_DECAL:
   case GL_REPLACE:
   case GL_ADD:
   case GL_COMBINE:
      legal = GL_TRUE;
      break;
   case GL_REPLACE_EXT:
      mode = GL_REPLACE; /* GL_REPLACE_EXT != GL_REPLACE */
      legal = GL_TRUE;
      break;
   case GL_COMBINE4_NV:
      legal = ctx->Extensions.NV_texture_env_combine4;
      break;
   default:
      legal = GL_FALSE;
   }

   if (legal) {
      FLUSH_VERTICES(ctx, _NEW_TEXTURE);
      texUnit->EnvMode = mode;
   }
   else {
      TE_ERROR(GL_INVALID_ENUM, "glTexEnv(param=%s)", mode);
   }
}


static void
set_env_color(struct gl_context *ctx,
              struct gl_texture_unit *texUnit,
              const GLfloat *color)
{
   if (TEST_EQ_4V(color, texUnit->EnvColorUnclamped))
      return;
   FLUSH_VERTICES(ctx, _NEW_TEXTURE);
   COPY_4FV(texUnit->EnvColorUnclamped, color);
   texUnit->EnvColor[0] = CLAMP(color[0], 0.0F, 1.0F);
   texUnit->EnvColor[1] = CLAMP(color[1], 0.0F, 1.0F);
   texUnit->EnvColor[2] = CLAMP(color[2], 0.0F, 1.0F);
   texUnit->EnvColor[3] = CLAMP(color[3], 0.0F, 1.0F);
}


/** Set an RGB or A combiner mode/function */
static void
set_combiner_mode(struct gl_context *ctx,
                  struct gl_texture_unit *texUnit,
                  GLenum pname, GLenum mode)
{
   GLboolean legal;

   switch (mode) {
   case GL_REPLACE:
   case GL_MODULATE:
   case GL_ADD:
   case GL_ADD_SIGNED:
   case GL_INTERPOLATE:
      legal = GL_TRUE;
      break;
   case GL_SUBTRACT:
      legal = ctx->Extensions.ARB_texture_env_combine;
      break;
   case GL_DOT3_RGB_EXT:
   case GL_DOT3_RGBA_EXT:
      legal = (ctx->API == API_OPENGL_COMPAT &&
               ctx->Extensions.EXT_texture_env_dot3 &&
               pname == GL_COMBINE_RGB);
      break;
   case GL_DOT3_RGB:
   case GL_DOT3_RGBA:
      legal = (ctx->Extensions.ARB_texture_env_dot3 &&
               pname == GL_COMBINE_RGB);
      break;
   case GL_MODULATE_ADD_ATI:
   case GL_MODULATE_SIGNED_ADD_ATI:
   case GL_MODULATE_SUBTRACT_ATI:
      legal = (ctx->API == API_OPENGL_COMPAT &&
               ctx->Extensions.ATI_texture_env_combine3);
      break;
   case GL_BUMP_ENVMAP_ATI:
      legal = (ctx->API == API_OPENGL_COMPAT &&
               ctx->Extensions.ATI_envmap_bumpmap &&
               pname == GL_COMBINE_RGB);
      break;
   default:
      legal = GL_FALSE;
   }

   if (!legal) {
      TE_ERROR(GL_INVALID_ENUM, "glTexEnv(param=%s)", mode);
      return;
   }

   switch (pname) {
   case GL_COMBINE_RGB:
      if (texUnit->Combine.ModeRGB == mode)
         return;
      FLUSH_VERTICES(ctx, _NEW_TEXTURE);
      texUnit->Combine.ModeRGB = mode;
      break;

   case GL_COMBINE_ALPHA:
      if (texUnit->Combine.ModeA == mode)
         return;
      FLUSH_VERTICES(ctx, _NEW_TEXTURE);
      texUnit->Combine.ModeA = mode;
      break;
   default:
      TE_ERROR(GL_INVALID_ENUM, "glTexEnv(pname=%s)", pname);
   }
}



/** Set an RGB or A combiner source term */
static void
set_combiner_source(struct gl_context *ctx,
                    struct gl_texture_unit *texUnit,
                    GLenum pname, GLenum param)
{
   GLuint term;
   GLboolean alpha, legal;

   /*
    * Translate pname to (term, alpha).
    *
    * The enums were given sequential values for a reason.
    */
   switch (pname) {
   case GL_SOURCE0_RGB:
   case GL_SOURCE1_RGB:
   case GL_SOURCE2_RGB:
   case GL_SOURCE3_RGB_NV:
      term = pname - GL_SOURCE0_RGB;
      alpha = GL_FALSE;
      break;
   case GL_SOURCE0_ALPHA:
   case GL_SOURCE1_ALPHA:
   case GL_SOURCE2_ALPHA:
   case GL_SOURCE3_ALPHA_NV:
      term = pname - GL_SOURCE0_ALPHA;
      alpha = GL_TRUE;
      break;
   default:
      TE_ERROR(GL_INVALID_ENUM, "glTexEnv(pname=%s)", pname);
      return;
   }

   if ((term == 3) && (ctx->API != API_OPENGL_COMPAT
                       || !ctx->Extensions.NV_texture_env_combine4)) {
      TE_ERROR(GL_INVALID_ENUM, "glTexEnv(pname=%s)", pname);
      return;
   }

   assert(term < MAX_COMBINER_TERMS);

   /*
    * Error-check param (the source term)
    */
   switch (param) {
   case GL_TEXTURE:
   case GL_CONSTANT:
   case GL_PRIMARY_COLOR:
   case GL_PREVIOUS:
      legal = GL_TRUE;
      break;
   case GL_TEXTURE0:
   case GL_TEXTURE1:
   case GL_TEXTURE2:
   case GL_TEXTURE3:
   case GL_TEXTURE4:
   case GL_TEXTURE5:
   case GL_TEXTURE6:
   case GL_TEXTURE7:
      legal = (ctx->Extensions.ARB_texture_env_crossbar &&
               param - GL_TEXTURE0 < ctx->Const.MaxTextureUnits);
      break;
   case GL_ZERO:
      legal = (ctx->API == API_OPENGL_COMPAT &&
               (ctx->Extensions.ATI_texture_env_combine3 ||
                ctx->Extensions.NV_texture_env_combine4));
      break;
   case GL_ONE:
      legal = (ctx->API == API_OPENGL_COMPAT &&
               ctx->Extensions.ATI_texture_env_combine3);
      break;
   default:
      legal = GL_FALSE;
   }

   if (!legal) {
      TE_ERROR(GL_INVALID_ENUM, "glTexEnv(param=%s)", param);
      return;
   }

   FLUSH_VERTICES(ctx, _NEW_TEXTURE);

   if (alpha)
      texUnit->Combine.SourceA[term] = param;
   else
      texUnit->Combine.SourceRGB[term] = param;
}


/** Set an RGB or A combiner operand term */
static void
set_combiner_operand(struct gl_context *ctx,
                     struct gl_texture_unit *texUnit,
                     GLenum pname, GLenum param)
{
   GLuint term;
   GLboolean alpha, legal;

   /* The enums were given sequential values for a reason.
    */
   switch (pname) {
   case GL_OPERAND0_RGB:
   case GL_OPERAND1_RGB:
   case GL_OPERAND2_RGB:
   case GL_OPERAND3_RGB_NV:
      term = pname - GL_OPERAND0_RGB;
      alpha = GL_FALSE;
      break;
   case GL_OPERAND0_ALPHA:
   case GL_OPERAND1_ALPHA:
   case GL_OPERAND2_ALPHA:
   case GL_OPERAND3_ALPHA_NV:
      term = pname - GL_OPERAND0_ALPHA;
      alpha = GL_TRUE;
      break;
   default:
      TE_ERROR(GL_INVALID_ENUM, "glTexEnv(pname=%s)", pname);
      return;
   }

   if ((term == 3) && (ctx->API != API_OPENGL_COMPAT
                       || !ctx->Extensions.NV_texture_env_combine4)) {
      TE_ERROR(GL_INVALID_ENUM, "glTexEnv(pname=%s)", pname);
      return;
   }

   assert(term < MAX_COMBINER_TERMS);

   /*
    * Error-check param (the source operand)
    */
   switch (param) {
   case GL_SRC_COLOR:
   case GL_ONE_MINUS_SRC_COLOR:
      /* The color input can only be used with GL_OPERAND[01]_RGB in the EXT
       * version.  In the ARB and NV versions and OpenGL ES 1.x they can be
       * used for any RGB operand.
       */
      legal = !alpha
	 && ((term < 2) || ctx->Extensions.ARB_texture_env_combine
	     || ctx->Extensions.NV_texture_env_combine4);
      break;
   case GL_ONE_MINUS_SRC_ALPHA:
      /* GL_ONE_MINUS_SRC_ALPHA can only be used with
       * GL_OPERAND[01]_(RGB|ALPHA) in the EXT version.  In the ARB and NV
       * versions and OpenGL ES 1.x it can be used for any operand.
       */
      legal = (term < 2) || ctx->Extensions.ARB_texture_env_combine
	 || ctx->Extensions.NV_texture_env_combine4;
      break;
   case GL_SRC_ALPHA:
      legal = GL_TRUE;
      break;
   default:
      legal = GL_FALSE;
   }

   if (!legal) {
      TE_ERROR(GL_INVALID_ENUM, "glTexEnv(param=%s)", param);
      return;
   }

   FLUSH_VERTICES(ctx, _NEW_TEXTURE);

   if (alpha)
      texUnit->Combine.OperandA[term] = param;
   else
      texUnit->Combine.OperandRGB[term] = param;
}


static void
set_combiner_scale(struct gl_context *ctx,
                   struct gl_texture_unit *texUnit,
                   GLenum pname, GLfloat scale)
{
   GLuint shift;

   if (scale == 1.0F) {
      shift = 0;
   }
   else if (scale == 2.0F) {
      shift = 1;
   }
   else if (scale == 4.0F) {
      shift = 2;
   }
   else {
      _mesa_error( ctx, GL_INVALID_VALUE,
                   "glTexEnv(GL_RGB_SCALE not 1, 2 or 4)" );
      return;
   }

   switch (pname) {
   case GL_RGB_SCALE:
      if (texUnit->Combine.ScaleShiftRGB == shift)
         return;
      FLUSH_VERTICES(ctx, _NEW_TEXTURE);
      texUnit->Combine.ScaleShiftRGB = shift;
      break;
   case GL_ALPHA_SCALE:
      if (texUnit->Combine.ScaleShiftA == shift)
         return;
      FLUSH_VERTICES(ctx, _NEW_TEXTURE);
      texUnit->Combine.ScaleShiftA = shift;
      break;
   default:
      TE_ERROR(GL_INVALID_ENUM, "glTexEnv(pname=%s)", pname);
   }
}



void GLAPIENTRY
_mesa_TexEnvfv( GLenum target, GLenum pname, const GLfloat *param )
{
   const GLint iparam0 = (GLint) param[0];
   struct gl_texture_unit *texUnit;
   GLuint maxUnit;
   GET_CURRENT_CONTEXT(ctx);

   maxUnit = (target == GL_POINT_SPRITE_NV && pname == GL_COORD_REPLACE_NV)
      ? ctx->Const.MaxTextureCoordUnits : ctx->Const.MaxCombinedTextureImageUnits;
   if (ctx->Texture.CurrentUnit >= maxUnit) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glTexEnvfv(current unit)");
      return;
   }

   texUnit = _mesa_get_current_tex_unit(ctx);

   if (target == GL_TEXTURE_ENV) {
      switch (pname) {
      case GL_TEXTURE_ENV_MODE:
         set_env_mode(ctx, texUnit, (GLenum) iparam0);
         break;
      case GL_TEXTURE_ENV_COLOR:
         set_env_color(ctx, texUnit, param);
         break;
      case GL_COMBINE_RGB:
      case GL_COMBINE_ALPHA:
         set_combiner_mode(ctx, texUnit, pname, (GLenum) iparam0);
	 break;
      case GL_SOURCE0_RGB:
      case GL_SOURCE1_RGB:
      case GL_SOURCE2_RGB:
      case GL_SOURCE3_RGB_NV:
      case GL_SOURCE0_ALPHA:
      case GL_SOURCE1_ALPHA:
      case GL_SOURCE2_ALPHA:
      case GL_SOURCE3_ALPHA_NV:
         set_combiner_source(ctx, texUnit, pname, (GLenum) iparam0);
	 break;
      case GL_OPERAND0_RGB:
      case GL_OPERAND1_RGB:
      case GL_OPERAND2_RGB:
      case GL_OPERAND3_RGB_NV:
      case GL_OPERAND0_ALPHA:
      case GL_OPERAND1_ALPHA:
      case GL_OPERAND2_ALPHA:
      case GL_OPERAND3_ALPHA_NV:
         set_combiner_operand(ctx, texUnit, pname, (GLenum) iparam0);
	 break;
      case GL_RGB_SCALE:
      case GL_ALPHA_SCALE:
         set_combiner_scale(ctx, texUnit, pname, param[0]);
	 break;
      case GL_BUMP_TARGET_ATI:
         if (ctx->API != API_OPENGL_COMPAT || !ctx->Extensions.ATI_envmap_bumpmap) {
	    _mesa_error( ctx, GL_INVALID_ENUM, "glTexEnv(pname=0x%x)", pname );
	    return;
	 }
	 if ((iparam0 < GL_TEXTURE0) ||
             (iparam0 > GL_TEXTURE31)) {
	    /* spec doesn't say this but it seems logical */
	    _mesa_error( ctx, GL_INVALID_ENUM, "glTexEnv(param=0x%x)", iparam0);
	    return;
	 }
	 if (!((1 << (iparam0 - GL_TEXTURE0)) & ctx->Const.SupportedBumpUnits)) {
	    _mesa_error( ctx, GL_INVALID_VALUE, "glTexEnv(param=0x%x)", iparam0);
	    return;
	 }
	 else {
	    FLUSH_VERTICES(ctx, _NEW_TEXTURE);
	    texUnit->BumpTarget = iparam0;
	 }
	 break;
      default:
	 _mesa_error( ctx, GL_INVALID_ENUM, "glTexEnv(pname)" );
	 return;
      }
   }
   else if (target == GL_TEXTURE_FILTER_CONTROL_EXT) {
      if (pname == GL_TEXTURE_LOD_BIAS_EXT) {
	 if (texUnit->LodBias == param[0])
	    return;
	 FLUSH_VERTICES(ctx, _NEW_TEXTURE);
         texUnit->LodBias = param[0];
      }
      else {
         TE_ERROR(GL_INVALID_ENUM, "glTexEnv(pname=%s)", pname);
	 return;
      }
   }
   else if (target == GL_POINT_SPRITE_NV) {
      /* GL_ARB_point_sprite / GL_NV_point_sprite */
      if (!ctx->Extensions.NV_point_sprite
	  && !ctx->Extensions.ARB_point_sprite) {
	 _mesa_error( ctx, GL_INVALID_ENUM, "glTexEnv(target=0x%x)", target );
	 return;
      }
      if (pname == GL_COORD_REPLACE_NV) {
         if (iparam0 == GL_TRUE || iparam0 == GL_FALSE) {
            /* It's kind of weird to set point state via glTexEnv,
             * but that's what the spec calls for.
             */
            const GLboolean state = (GLboolean) iparam0;
            if (ctx->Point.CoordReplace[ctx->Texture.CurrentUnit] == state)
               return;
            FLUSH_VERTICES(ctx, _NEW_POINT);
            ctx->Point.CoordReplace[ctx->Texture.CurrentUnit] = state;
         }
         else {
            _mesa_error( ctx, GL_INVALID_VALUE, "glTexEnv(param=0x%x)", iparam0);
            return;
         }
      }
      else {
         _mesa_error( ctx, GL_INVALID_ENUM, "glTexEnv(pname=0x%x)", pname );
         return;
      }
   }
   else {
      _mesa_error(ctx, GL_INVALID_ENUM, "glTexEnv(target=%s)",
                  _mesa_lookup_enum_by_nr(target));
      return;
   }

   if (MESA_VERBOSE&(VERBOSE_API|VERBOSE_TEXTURE))
      _mesa_debug(ctx, "glTexEnv %s %s %.1f(%s) ...\n",
                  _mesa_lookup_enum_by_nr(target),
                  _mesa_lookup_enum_by_nr(pname),
                  *param,
                  _mesa_lookup_enum_by_nr((GLenum) iparam0));

   /* Tell device driver about the new texture environment */
   if (ctx->Driver.TexEnv) {
      (*ctx->Driver.TexEnv)( ctx, target, pname, param );
   }
}


void GLAPIENTRY
_mesa_TexEnvf( GLenum target, GLenum pname, GLfloat param )
{
   GLfloat p[4];
   p[0] = param;
   p[1] = p[2] = p[3] = 0.0;
   _mesa_TexEnvfv( target, pname, p );
}



void GLAPIENTRY
_mesa_TexEnvi( GLenum target, GLenum pname, GLint param )
{
   GLfloat p[4];
   p[0] = (GLfloat) param;
   p[1] = p[2] = p[3] = 0.0;
   _mesa_TexEnvfv( target, pname, p );
}


void GLAPIENTRY
_mesa_TexEnviv( GLenum target, GLenum pname, const GLint *param )
{
   GLfloat p[4];
   if (pname == GL_TEXTURE_ENV_COLOR) {
      p[0] = INT_TO_FLOAT( param[0] );
      p[1] = INT_TO_FLOAT( param[1] );
      p[2] = INT_TO_FLOAT( param[2] );
      p[3] = INT_TO_FLOAT( param[3] );
   }
   else {
      p[0] = (GLfloat) param[0];
      p[1] = p[2] = p[3] = 0;  /* init to zero, just to be safe */
   }
   _mesa_TexEnvfv( target, pname, p );
}



/**
 * Helper for glGetTexEnvi/f()
 * \return  value of queried pname or -1 if error.
 */
static GLint
get_texenvi(struct gl_context *ctx, const struct gl_texture_unit *texUnit,
            GLenum pname)
{
   switch (pname) {
   case GL_TEXTURE_ENV_MODE:
      return texUnit->EnvMode;
      break;
   case GL_COMBINE_RGB:
      return texUnit->Combine.ModeRGB;
   case GL_COMBINE_ALPHA:
      return texUnit->Combine.ModeA;
   case GL_SOURCE0_RGB:
   case GL_SOURCE1_RGB:
   case GL_SOURCE2_RGB: {
      const unsigned rgb_idx = pname - GL_SOURCE0_RGB;
      return texUnit->Combine.SourceRGB[rgb_idx];
   }
   case GL_SOURCE3_RGB_NV:
      if (ctx->API == API_OPENGL_COMPAT && ctx->Extensions.NV_texture_env_combine4) {
         return texUnit->Combine.SourceRGB[3];
      }
      else {
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)");
      }
      break;
   case GL_SOURCE0_ALPHA:
   case GL_SOURCE1_ALPHA:
   case GL_SOURCE2_ALPHA: {
      const unsigned alpha_idx = pname - GL_SOURCE0_ALPHA;
      return texUnit->Combine.SourceA[alpha_idx];
   }
   case GL_SOURCE3_ALPHA_NV:
      if (ctx->API == API_OPENGL_COMPAT && ctx->Extensions.NV_texture_env_combine4) {
         return texUnit->Combine.SourceA[3];
      }
      else {
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)");
      }
      break;
   case GL_OPERAND0_RGB:
   case GL_OPERAND1_RGB:
   case GL_OPERAND2_RGB: {
      const unsigned op_rgb = pname - GL_OPERAND0_RGB;
      return texUnit->Combine.OperandRGB[op_rgb];
   }
   case GL_OPERAND3_RGB_NV:
      if (ctx->API == API_OPENGL_COMPAT && ctx->Extensions.NV_texture_env_combine4) {
         return texUnit->Combine.OperandRGB[3];
      }
      else {
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)");
      }
      break;
   case GL_OPERAND0_ALPHA:
   case GL_OPERAND1_ALPHA:
   case GL_OPERAND2_ALPHA: {
      const unsigned op_alpha = pname - GL_OPERAND0_ALPHA;
      return texUnit->Combine.OperandA[op_alpha];
   }
   case GL_OPERAND3_ALPHA_NV:
      if (ctx->API == API_OPENGL_COMPAT && ctx->Extensions.NV_texture_env_combine4) {
         return texUnit->Combine.OperandA[3];
      }
      else {
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)");
      }
      break;
   case GL_RGB_SCALE:
      return 1 << texUnit->Combine.ScaleShiftRGB;
   case GL_ALPHA_SCALE:
      return 1 << texUnit->Combine.ScaleShiftA;
   case GL_BUMP_TARGET_ATI:
      /* spec doesn't say so, but I think this should be queryable */
      if (ctx->API == API_OPENGL_COMPAT && ctx->Extensions.ATI_envmap_bumpmap) {
         return texUnit->BumpTarget;
      }
      else {
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)");
      }
      break;

   default:
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)");
      break;
   }

   return -1; /* error */
}



void GLAPIENTRY
_mesa_GetTexEnvfv( GLenum target, GLenum pname, GLfloat *params )
{
   GLuint maxUnit;
   const struct gl_texture_unit *texUnit;
   GET_CURRENT_CONTEXT(ctx);

   maxUnit = (target == GL_POINT_SPRITE_NV && pname == GL_COORD_REPLACE_NV)
      ? ctx->Const.MaxTextureCoordUnits : ctx->Const.MaxCombinedTextureImageUnits;
   if (ctx->Texture.CurrentUnit >= maxUnit) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glGetTexEnvfv(current unit)");
      return;
   }

   texUnit = _mesa_get_current_tex_unit(ctx);

   if (target == GL_TEXTURE_ENV) {
      if (pname == GL_TEXTURE_ENV_COLOR) {
         if(ctx->NewState & (_NEW_BUFFERS | _NEW_FRAG_CLAMP))
            _mesa_update_state(ctx);
         if (_mesa_get_clamp_fragment_color(ctx))
            COPY_4FV( params, texUnit->EnvColor );
         else
            COPY_4FV( params, texUnit->EnvColorUnclamped );
      }
      else {
         GLint val = get_texenvi(ctx, texUnit, pname);
         if (val >= 0) {
            *params = (GLfloat) val;
         }
      }
   }
   else if (target == GL_TEXTURE_FILTER_CONTROL_EXT) {
      if (pname == GL_TEXTURE_LOD_BIAS_EXT) {
         *params = texUnit->LodBias;
      }
      else {
         _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)" );
	 return;
      }
   }
   else if (target == GL_POINT_SPRITE_NV) {
      /* GL_ARB_point_sprite / GL_NV_point_sprite */
      if (!ctx->Extensions.NV_point_sprite
	  && !ctx->Extensions.ARB_point_sprite) {
         _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexEnvfv(target)" );
         return;
      }
      if (pname == GL_COORD_REPLACE_NV) {
         *params = (GLfloat) ctx->Point.CoordReplace[ctx->Texture.CurrentUnit];
      }
      else {
         _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)" );
         return;
      }
   }
   else {
      _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexEnvfv(target)" );
      return;
   }
}


void GLAPIENTRY
_mesa_GetTexEnviv( GLenum target, GLenum pname, GLint *params )
{
   GLuint maxUnit;
   const struct gl_texture_unit *texUnit;
   GET_CURRENT_CONTEXT(ctx);

   maxUnit = (target == GL_POINT_SPRITE_NV && pname == GL_COORD_REPLACE_NV)
      ? ctx->Const.MaxTextureCoordUnits : ctx->Const.MaxCombinedTextureImageUnits;
   if (ctx->Texture.CurrentUnit >= maxUnit) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glGetTexEnviv(current unit)");
      return;
   }

   texUnit = _mesa_get_current_tex_unit(ctx);

   if (target == GL_TEXTURE_ENV) {
      if (pname == GL_TEXTURE_ENV_COLOR) {
         params[0] = FLOAT_TO_INT( texUnit->EnvColor[0] );
         params[1] = FLOAT_TO_INT( texUnit->EnvColor[1] );
         params[2] = FLOAT_TO_INT( texUnit->EnvColor[2] );
         params[3] = FLOAT_TO_INT( texUnit->EnvColor[3] );
      }
      else {
         GLint val = get_texenvi(ctx, texUnit, pname);
         if (val >= 0) {
            *params = val;
         }
      }
   }
   else if (target == GL_TEXTURE_FILTER_CONTROL_EXT) {
      if (pname == GL_TEXTURE_LOD_BIAS_EXT) {
         *params = (GLint) texUnit->LodBias;
      }
      else {
         _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexEnviv(pname)" );
	 return;
      }
   }
   else if (target == GL_POINT_SPRITE_NV) {
      /* GL_ARB_point_sprite / GL_NV_point_sprite */
      if (!ctx->Extensions.NV_point_sprite
	  && !ctx->Extensions.ARB_point_sprite) {
         _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexEnviv(target)" );
         return;
      }
      if (pname == GL_COORD_REPLACE_NV) {
         *params = (GLint) ctx->Point.CoordReplace[ctx->Texture.CurrentUnit];
      }
      else {
         _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexEnviv(pname)" );
         return;
      }
   }
   else {
      _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexEnviv(target)" );
      return;
   }
}


/**
 * Why does ATI_envmap_bumpmap require new entrypoints? Should just
 * reuse TexEnv ones...
 */
void GLAPIENTRY
_mesa_TexBumpParameterivATI( GLenum pname, const GLint *param )
{
   GLfloat p[4];
   GET_CURRENT_CONTEXT(ctx);

   if (!ctx->Extensions.ATI_envmap_bumpmap) {
      /* This isn't an "official" error case, but let's tell the user
       * that something's wrong.
       */
      _mesa_error(ctx, GL_INVALID_OPERATION, "glTexBumpParameterivATI");
      return;
   }

   if (pname == GL_BUMP_ROT_MATRIX_ATI) {
      /* hope that conversion is correct here */
      p[0] = INT_TO_FLOAT( param[0] );
      p[1] = INT_TO_FLOAT( param[1] );
      p[2] = INT_TO_FLOAT( param[2] );
      p[3] = INT_TO_FLOAT( param[3] );
   }
   else {
      p[0] = (GLfloat) param[0];
      p[1] = p[2] = p[3] = 0.0F;  /* init to zero, just to be safe */
   }
   _mesa_TexBumpParameterfvATI( pname, p );
}


void GLAPIENTRY
_mesa_TexBumpParameterfvATI( GLenum pname, const GLfloat *param )
{
   struct gl_texture_unit *texUnit;
   GET_CURRENT_CONTEXT(ctx);

   if (!ctx->Extensions.ATI_envmap_bumpmap) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glTexBumpParameterfvATI");
      return;
   }

   texUnit = _mesa_get_current_tex_unit(ctx);

   if (pname == GL_BUMP_ROT_MATRIX_ATI) {
      if (TEST_EQ_4V(param, texUnit->RotMatrix))
         return;
      FLUSH_VERTICES(ctx, _NEW_TEXTURE);
      COPY_4FV(texUnit->RotMatrix, param);
   }
   else {
      _mesa_error( ctx, GL_INVALID_ENUM, "glTexBumpParameter(pname)" );
      return;
   }
   /* Drivers might want to know about this, instead of dedicated function
      just shove it into TexEnv where it really belongs anyway */
   if (ctx->Driver.TexEnv) {
      (*ctx->Driver.TexEnv)( ctx, 0, pname, param );
   }
}


void GLAPIENTRY
_mesa_GetTexBumpParameterivATI( GLenum pname, GLint *param )
{
   const struct gl_texture_unit *texUnit;
   GLuint i;
   GET_CURRENT_CONTEXT(ctx);

   if (!ctx->Extensions.ATI_envmap_bumpmap) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glGetTexBumpParameterivATI");
      return;
   }

   texUnit = _mesa_get_current_tex_unit(ctx);

   if (pname == GL_BUMP_ROT_MATRIX_SIZE_ATI) {
      /* spec leaves open to support larger matrices.
         Don't think anyone would ever want to use it
         (and apps almost certainly would not understand it and
         thus fail to submit matrices correctly) so hardcode this. */
      *param = 4;
   }
   else if (pname == GL_BUMP_ROT_MATRIX_ATI) {
      /* hope that conversion is correct here */
      param[0] = FLOAT_TO_INT(texUnit->RotMatrix[0]);
      param[1] = FLOAT_TO_INT(texUnit->RotMatrix[1]);
      param[2] = FLOAT_TO_INT(texUnit->RotMatrix[2]);
      param[3] = FLOAT_TO_INT(texUnit->RotMatrix[3]);
   }
   else if (pname == GL_BUMP_NUM_TEX_UNITS_ATI) {
      GLint count = 0;
      for (i = 0; i < ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits; i++) {
         if (ctx->Const.SupportedBumpUnits & (1 << i)) {
            count++;
         }
      }
      *param = count;
   }
   else if (pname == GL_BUMP_TEX_UNITS_ATI) {
      for (i = 0; i < ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits; i++) {
         if (ctx->Const.SupportedBumpUnits & (1 << i)) {
            *param++ = i + GL_TEXTURE0;
         }
      }
   }
   else {
      _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexBumpParameter(pname)" );
      return;
   }
}


void GLAPIENTRY
_mesa_GetTexBumpParameterfvATI( GLenum pname, GLfloat *param )
{
   const struct gl_texture_unit *texUnit;
   GLuint i;
   GET_CURRENT_CONTEXT(ctx);

   if (!ctx->Extensions.ATI_envmap_bumpmap) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glGetTexBumpParameterfvATI");
      return;
   }

   texUnit = _mesa_get_current_tex_unit(ctx);

   if (pname == GL_BUMP_ROT_MATRIX_SIZE_ATI) {
      /* spec leaves open to support larger matrices.
         Don't think anyone would ever want to use it
         (and apps might not understand it) so hardcode this. */
      *param = 4.0F;
   }
   else if (pname == GL_BUMP_ROT_MATRIX_ATI) {
      param[0] = texUnit->RotMatrix[0];
      param[1] = texUnit->RotMatrix[1];
      param[2] = texUnit->RotMatrix[2];
      param[3] = texUnit->RotMatrix[3];
   }
   else if (pname == GL_BUMP_NUM_TEX_UNITS_ATI) {
      GLint count = 0;
      for (i = 0; i < ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits; i++) {
         if (ctx->Const.SupportedBumpUnits & (1 << i)) {
            count++;
         }
      }
      *param = (GLfloat) count;
   }
   else if (pname == GL_BUMP_TEX_UNITS_ATI) {
      for (i = 0; i < ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits; i++) {
         if (ctx->Const.SupportedBumpUnits & (1 << i)) {
            *param++ = (GLfloat) (i + GL_TEXTURE0);
         }
      }
   }
   else {
      _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexBumpParameter(pname)" );
      return;
   }
}
@


1.8
log
@Merge Mesa 10.2.9
@
text
@@


1.7
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d141 5
d443 20
d644 10
d787 163
@


1.6
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@a140 5
   case GL_BUMP_ENVMAP_ATI:
      legal = (ctx->API == API_OPENGL_COMPAT &&
               ctx->Extensions.ATI_envmap_bumpmap &&
               pname == GL_COMBINE_RGB);
      break;
a437 20
      case GL_BUMP_TARGET_ATI:
         if (ctx->API != API_OPENGL_COMPAT || !ctx->Extensions.ATI_envmap_bumpmap) {
	    _mesa_error( ctx, GL_INVALID_ENUM, "glTexEnv(pname=0x%x)", pname );
	    return;
	 }
	 if ((iparam0 < GL_TEXTURE0) ||
             (iparam0 > GL_TEXTURE31)) {
	    /* spec doesn't say this but it seems logical */
	    _mesa_error( ctx, GL_INVALID_ENUM, "glTexEnv(param=0x%x)", iparam0);
	    return;
	 }
	 if (!((1 << (iparam0 - GL_TEXTURE0)) & ctx->Const.SupportedBumpUnits)) {
	    _mesa_error( ctx, GL_INVALID_VALUE, "glTexEnv(param=0x%x)", iparam0);
	    return;
	 }
	 else {
	    FLUSH_VERTICES(ctx, _NEW_TEXTURE);
	    texUnit->BumpTarget = iparam0;
	 }
	 break;
a618 10
   case GL_BUMP_TARGET_ATI:
      /* spec doesn't say so, but I think this should be queryable */
      if (ctx->API == API_OPENGL_COMPAT && ctx->Extensions.ATI_envmap_bumpmap) {
         return texUnit->BumpTarget;
      }
      else {
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)");
      }
      break;

a751 163

/**
 * Why does ATI_envmap_bumpmap require new entrypoints? Should just
 * reuse TexEnv ones...
 */
void GLAPIENTRY
_mesa_TexBumpParameterivATI( GLenum pname, const GLint *param )
{
   GLfloat p[4];
   GET_CURRENT_CONTEXT(ctx);

   if (!ctx->Extensions.ATI_envmap_bumpmap) {
      /* This isn't an "official" error case, but let's tell the user
       * that something's wrong.
       */
      _mesa_error(ctx, GL_INVALID_OPERATION, "glTexBumpParameterivATI");
      return;
   }

   if (pname == GL_BUMP_ROT_MATRIX_ATI) {
      /* hope that conversion is correct here */
      p[0] = INT_TO_FLOAT( param[0] );
      p[1] = INT_TO_FLOAT( param[1] );
      p[2] = INT_TO_FLOAT( param[2] );
      p[3] = INT_TO_FLOAT( param[3] );
   }
   else {
      p[0] = (GLfloat) param[0];
      p[1] = p[2] = p[3] = 0.0F;  /* init to zero, just to be safe */
   }
   _mesa_TexBumpParameterfvATI( pname, p );
}


void GLAPIENTRY
_mesa_TexBumpParameterfvATI( GLenum pname, const GLfloat *param )
{
   struct gl_texture_unit *texUnit;
   GET_CURRENT_CONTEXT(ctx);

   if (!ctx->Extensions.ATI_envmap_bumpmap) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glTexBumpParameterfvATI");
      return;
   }

   texUnit = _mesa_get_current_tex_unit(ctx);

   if (pname == GL_BUMP_ROT_MATRIX_ATI) {
      if (TEST_EQ_4V(param, texUnit->RotMatrix))
         return;
      FLUSH_VERTICES(ctx, _NEW_TEXTURE);
      COPY_4FV(texUnit->RotMatrix, param);
   }
   else {
      _mesa_error( ctx, GL_INVALID_ENUM, "glTexBumpParameter(pname)" );
      return;
   }
   /* Drivers might want to know about this, instead of dedicated function
      just shove it into TexEnv where it really belongs anyway */
   if (ctx->Driver.TexEnv) {
      (*ctx->Driver.TexEnv)( ctx, 0, pname, param );
   }
}


void GLAPIENTRY
_mesa_GetTexBumpParameterivATI( GLenum pname, GLint *param )
{
   const struct gl_texture_unit *texUnit;
   GLuint i;
   GET_CURRENT_CONTEXT(ctx);

   if (!ctx->Extensions.ATI_envmap_bumpmap) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glGetTexBumpParameterivATI");
      return;
   }

   texUnit = _mesa_get_current_tex_unit(ctx);

   if (pname == GL_BUMP_ROT_MATRIX_SIZE_ATI) {
      /* spec leaves open to support larger matrices.
         Don't think anyone would ever want to use it
         (and apps almost certainly would not understand it and
         thus fail to submit matrices correctly) so hardcode this. */
      *param = 4;
   }
   else if (pname == GL_BUMP_ROT_MATRIX_ATI) {
      /* hope that conversion is correct here */
      param[0] = FLOAT_TO_INT(texUnit->RotMatrix[0]);
      param[1] = FLOAT_TO_INT(texUnit->RotMatrix[1]);
      param[2] = FLOAT_TO_INT(texUnit->RotMatrix[2]);
      param[3] = FLOAT_TO_INT(texUnit->RotMatrix[3]);
   }
   else if (pname == GL_BUMP_NUM_TEX_UNITS_ATI) {
      GLint count = 0;
      for (i = 0; i < ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits; i++) {
         if (ctx->Const.SupportedBumpUnits & (1 << i)) {
            count++;
         }
      }
      *param = count;
   }
   else if (pname == GL_BUMP_TEX_UNITS_ATI) {
      for (i = 0; i < ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits; i++) {
         if (ctx->Const.SupportedBumpUnits & (1 << i)) {
            *param++ = i + GL_TEXTURE0;
         }
      }
   }
   else {
      _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexBumpParameter(pname)" );
      return;
   }
}


void GLAPIENTRY
_mesa_GetTexBumpParameterfvATI( GLenum pname, GLfloat *param )
{
   const struct gl_texture_unit *texUnit;
   GLuint i;
   GET_CURRENT_CONTEXT(ctx);

   if (!ctx->Extensions.ATI_envmap_bumpmap) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glGetTexBumpParameterfvATI");
      return;
   }

   texUnit = _mesa_get_current_tex_unit(ctx);

   if (pname == GL_BUMP_ROT_MATRIX_SIZE_ATI) {
      /* spec leaves open to support larger matrices.
         Don't think anyone would ever want to use it
         (and apps might not understand it) so hardcode this. */
      *param = 4.0F;
   }
   else if (pname == GL_BUMP_ROT_MATRIX_ATI) {
      param[0] = texUnit->RotMatrix[0];
      param[1] = texUnit->RotMatrix[1];
      param[2] = texUnit->RotMatrix[2];
      param[3] = texUnit->RotMatrix[3];
   }
   else if (pname == GL_BUMP_NUM_TEX_UNITS_ATI) {
      GLint count = 0;
      for (i = 0; i < ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits; i++) {
         if (ctx->Const.SupportedBumpUnits & (1 << i)) {
            count++;
         }
      }
      *param = (GLfloat) count;
   }
   else if (pname == GL_BUMP_TEX_UNITS_ATI) {
      for (i = 0; i < ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits; i++) {
         if (ctx->Const.SupportedBumpUnits & (1 << i)) {
            *param++ = (GLfloat) (i + GL_TEXTURE0);
         }
      }
   }
   else {
      _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexBumpParameter(pname)" );
      return;
   }
}
@


1.5
log
@Merge Mesa 9.2.0
@
text
@d882 1
a882 1
      for (i = 0; i < ctx->Const.FragmentProgram.MaxTextureImageUnits; i++) {
d890 1
a890 1
      for (i = 0; i < ctx->Const.FragmentProgram.MaxTextureImageUnits; i++) {
d931 1
a931 1
      for (i = 0; i < ctx->Const.FragmentProgram.MaxTextureImageUnits; i++) {
d939 1
a939 1
      for (i = 0; i < ctx->Const.FragmentProgram.MaxTextureImageUnits; i++) {
@


1.4
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a2 1
 * Version:  7.5
d20 4
a23 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
d35 1
d64 2
a71 7
   case GL_ADD:
      legal = ctx->Extensions.EXT_texture_env_add;
      break;
   case GL_COMBINE:
      legal = (ctx->Extensions.EXT_texture_env_combine ||
               ctx->Extensions.ARB_texture_env_combine);
      break;
a112 6
   if (!ctx->Extensions.EXT_texture_env_combine &&
       !ctx->Extensions.ARB_texture_env_combine) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glTexEnv(pname)");
      return;
   }

d126 2
a127 1
      legal = (ctx->Extensions.EXT_texture_env_dot3 &&
d138 2
a139 1
      legal = ctx->Extensions.ATI_texture_env_combine3;
d142 2
a143 1
      legal = (ctx->Extensions.ATI_envmap_bumpmap &&
a184 6
   if (!ctx->Extensions.EXT_texture_env_combine &&
       !ctx->Extensions.ARB_texture_env_combine) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glTexEnv(pname)");
      return;
   }

d210 2
a211 1
   if ((term == 3) && !ctx->Extensions.NV_texture_env_combine4) {
d240 3
a242 2
      legal = (ctx->Extensions.ATI_texture_env_combine3 ||
               ctx->Extensions.NV_texture_env_combine4);
d245 2
a246 1
      legal = ctx->Extensions.ATI_texture_env_combine3;
a274 6
   if (!ctx->Extensions.EXT_texture_env_combine &&
       !ctx->Extensions.ARB_texture_env_combine) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glTexEnv(pname)");
      return;
   }

d297 2
a298 1
   if ((term == 3) && !ctx->Extensions.NV_texture_env_combine4) {
d312 2
a313 2
       * version.  In the ARB and NV versions they can be used for any RGB
       * operand.
d322 1
a322 1
       * versions it can be used for any operand.
a354 6
   if (!ctx->Extensions.EXT_texture_env_combine &&
       !ctx->Extensions.ARB_texture_env_combine) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glTexEnv(pname)");
      return;
   }

a395 1

a396 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d444 1
a444 1
         if (!ctx->Extensions.ATI_envmap_bumpmap) {
a468 5
      /* GL_EXT_texture_lod_bias */
      if (!ctx->Extensions.EXT_texture_lod_bias) {
	 _mesa_error( ctx, GL_INVALID_ENUM, "glTexEnv(target=0x%x)", target );
	 return;
      }
d509 2
a510 1
      _mesa_error( ctx, GL_INVALID_ENUM, "glTexEnv(target=0x%x)",target );
d581 1
a581 8
      if (ctx->Extensions.EXT_texture_env_combine ||
          ctx->Extensions.ARB_texture_env_combine) {
         return texUnit->Combine.ModeRGB;
      }
      else {
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)");
      }
      break;
d583 1
a583 8
      if (ctx->Extensions.EXT_texture_env_combine ||
          ctx->Extensions.ARB_texture_env_combine) {
         return texUnit->Combine.ModeA;
      }
      else {
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)");
      }
      break;
d586 4
a589 10
   case GL_SOURCE2_RGB:
      if (ctx->Extensions.EXT_texture_env_combine ||
          ctx->Extensions.ARB_texture_env_combine) {
         const unsigned rgb_idx = pname - GL_SOURCE0_RGB;
         return texUnit->Combine.SourceRGB[rgb_idx];
      }
      else {
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)");
      }
      break;
d591 1
a591 1
      if (ctx->Extensions.NV_texture_env_combine4) {
d600 4
a603 10
   case GL_SOURCE2_ALPHA:
      if (ctx->Extensions.EXT_texture_env_combine ||
          ctx->Extensions.ARB_texture_env_combine) {
         const unsigned alpha_idx = pname - GL_SOURCE0_ALPHA;
         return texUnit->Combine.SourceA[alpha_idx];
      }
      else {
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)");
      }
      break;
d605 1
a605 1
      if (ctx->Extensions.NV_texture_env_combine4) {
d614 4
a617 10
   case GL_OPERAND2_RGB:
      if (ctx->Extensions.EXT_texture_env_combine ||
          ctx->Extensions.ARB_texture_env_combine) {
         const unsigned op_rgb = pname - GL_OPERAND0_RGB;
         return texUnit->Combine.OperandRGB[op_rgb];
      }
      else {
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)");
      }
      break;
d619 1
a619 1
      if (ctx->Extensions.NV_texture_env_combine4) {
d628 4
a631 10
   case GL_OPERAND2_ALPHA:
      if (ctx->Extensions.EXT_texture_env_combine ||
          ctx->Extensions.ARB_texture_env_combine) {
         const unsigned op_alpha = pname - GL_OPERAND0_ALPHA;
         return texUnit->Combine.OperandA[op_alpha];
      }
      else {
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)");
      }
      break;
d633 1
a633 1
      if (ctx->Extensions.NV_texture_env_combine4) {
d641 1
a641 8
      if (ctx->Extensions.EXT_texture_env_combine ||
          ctx->Extensions.ARB_texture_env_combine) {
         return 1 << texUnit->Combine.ScaleShiftRGB;
      }
      else {
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)");
      }
      break;
d643 1
a643 8
      if (ctx->Extensions.EXT_texture_env_combine ||
          ctx->Extensions.ARB_texture_env_combine) {
         return 1 << texUnit->Combine.ScaleShiftA;
      }
      else {
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)");
      }
      break;
d646 1
a646 1
      if (ctx->Extensions.ATI_envmap_bumpmap) {
a669 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d684 1
a684 1
         if(ctx->Color._ClampFragmentColor)
a696 5
      /* GL_EXT_texture_lod_bias */
      if (!ctx->Extensions.EXT_texture_lod_bias) {
	 _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexEnvfv(target)" );
	 return;
      }
a732 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
a757 5
      /* GL_EXT_texture_lod_bias */
      if (!ctx->Extensions.EXT_texture_lod_bias) {
	 _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexEnviv(target)" );
	 return;
      }
a796 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
a825 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
a857 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d882 1
a882 1
      for (i = 0; i < ctx->Const.MaxTextureImageUnits; i++) {
d890 1
a890 1
      for (i = 0; i < ctx->Const.MaxTextureImageUnits; i++) {
a908 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d931 1
a931 1
      for (i = 0; i < ctx->Const.MaxTextureImageUnits; i++) {
d939 1
a939 1
      for (i = 0; i < ctx->Const.MaxTextureImageUnits; i++) {
@


1.3
log
@Merge Mesa 7.10.3
@
text
@d37 2
d98 1
a98 6
   GLfloat tmp[4];
   tmp[0] = CLAMP(color[0], 0.0F, 1.0F);
   tmp[1] = CLAMP(color[1], 0.0F, 1.0F);
   tmp[2] = CLAMP(color[2], 0.0F, 1.0F);
   tmp[3] = CLAMP(color[3], 0.0F, 1.0F);
   if (TEST_EQ_4V(tmp, texUnit->EnvColor))
d101 5
a105 1
   COPY_4FV(texUnit->EnvColor, tmp);
d414 2
d417 1
a418 1
   struct gl_texture_unit *texUnit;
d422 1
a422 1
      ? ctx->Const.MaxTextureCoordUnits : ctx->Const.MaxTextureImageUnits;
d433 1
a433 1
         set_env_mode(ctx, texUnit, (GLenum) (GLint) param[0]);
d440 1
a440 1
         set_combiner_mode(ctx, texUnit, pname, (GLenum) (GLint) param[0]);
d450 1
a450 1
         set_combiner_source(ctx, texUnit, pname, (GLenum) (GLint) param[0]);
d460 1
a460 1
         set_combiner_operand(ctx, texUnit, pname, (GLenum) (GLint) param[0]);
d471 2
a472 2
	 if (((GLenum) (GLint) param[0] < GL_TEXTURE0) ||
	 ((GLenum) (GLint) param[0] > GL_TEXTURE31)) {
d474 1
a474 1
	    _mesa_error( ctx, GL_INVALID_ENUM, "glTexEnv(param=0x%x)", (GLenum) (GLint) param[0]);
d477 2
a478 2
	 if (!((1 << ((GLenum) (GLint) param[0] - GL_TEXTURE0)) & ctx->Const.SupportedBumpUnits)) {
	    _mesa_error( ctx, GL_INVALID_VALUE, "glTexEnv(param=0x%x)", (GLenum) (GLint) param[0]);
d483 1
a483 1
	    texUnit->BumpTarget = (GLenum) (GLint) param[0];
d516 1
a516 2
         const GLenum value = (GLenum) param[0];
         if (value == GL_TRUE || value == GL_FALSE) {
d520 1
a520 1
            const GLboolean state = (GLboolean) value;
d527 1
a527 1
            _mesa_error( ctx, GL_INVALID_VALUE, "glTexEnv(param=0x%x)", value);
d546 1
a546 1
                  _mesa_lookup_enum_by_nr((GLenum) (GLint) *param));
d734 2
a735 1
      ;
d752 1
a752 1
      ? ctx->Const.MaxTextureCoordUnits : ctx->Const.MaxTextureImageUnits;
d762 6
a767 1
         COPY_4FV( params, texUnit->EnvColor );
d821 1
a821 1
      ? ctx->Const.MaxTextureCoordUnits : ctx->Const.MaxTextureImageUnits;
@


1.2
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d47 1
a47 1
set_env_mode(GLcontext *ctx,
d92 1
a92 1
set_env_color(GLcontext *ctx,
d110 1
a110 1
set_combiner_mode(GLcontext *ctx,
d184 1
a184 1
set_combiner_source(GLcontext *ctx,
d199 2
a203 3
      term = 0;
      alpha = GL_FALSE;
      break;
a204 3
      term = 1;
      alpha = GL_FALSE;
      break;
d206 2
a207 1
      term = 2;
a209 10
   case GL_SOURCE3_RGB_NV:
      if (ctx->Extensions.NV_texture_env_combine4) {
         term = 3;
         alpha = GL_FALSE;
      }
      else {
         TE_ERROR(GL_INVALID_ENUM, "glTexEnv(pname=%s)", pname);
         return;
      }
      break;
a210 3
      term = 0;
      alpha = GL_TRUE;
      break;
a211 3
      term = 1;
      alpha = GL_TRUE;
      break;
d213 2
a214 1
      term = 2;
a216 10
   case GL_SOURCE3_ALPHA_NV:
      if (ctx->Extensions.NV_texture_env_combine4) {
         term = 3;
         alpha = GL_TRUE;
      }
      else {
         TE_ERROR(GL_INVALID_ENUM, "glTexEnv(pname=%s)", pname);
         return;
      }
      break;
d222 5
d277 1
a277 1
set_combiner_operand(GLcontext *ctx,
d290 2
a293 3
      term = 0;
      alpha = GL_FALSE;
      break;
a294 3
      term = 1;
      alpha = GL_FALSE;
      break;
a295 9
      if (ctx->Extensions.ARB_texture_env_combine) {
         term = 2;
         alpha = GL_FALSE;
      }
      else {
         TE_ERROR(GL_INVALID_ENUM, "glTexEnv(pname=%s)", pname);
         return;
      }
      break;
d297 2
a298 8
      if (ctx->Extensions.NV_texture_env_combine4) {
         term = 3;
         alpha = GL_FALSE;
      }
      else {
         TE_ERROR(GL_INVALID_ENUM, "glTexEnv(pname=%s)", pname);
         return;
      }
a300 3
      term = 0;
      alpha = GL_TRUE;
      break;
a301 3
      term = 1;
      alpha = GL_TRUE;
      break;
a302 9
      if (ctx->Extensions.ARB_texture_env_combine) {
         term = 2;
         alpha = GL_TRUE;
      }
      else {
         TE_ERROR(GL_INVALID_ENUM, "glTexEnv(pname=%s)", pname);
         return;
      }
      break;
d304 2
a305 8
      if (ctx->Extensions.NV_texture_env_combine4) {
         term = 3;
         alpha = GL_TRUE;
      }
      else {
         TE_ERROR(GL_INVALID_ENUM, "glTexEnv(pname=%s)", pname);
         return;
      }
d312 5
d325 15
a339 1
      legal = !alpha;
a341 1
   case GL_ONE_MINUS_SRC_ALPHA:
d363 1
a363 1
set_combiner_scale(GLcontext *ctx,
d598 1
a598 1
get_texenvi(GLcontext *ctx, const struct gl_texture_unit *texUnit,
@


1.1
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d3 1
a3 1
 * Version:  7.1
d6 1
d38 414
a451 1
#include "math/m_xform.h"
d470 1
a470 4
   texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];

#define TE_ERROR(errCode, msg, value)				\
   _mesa_error(ctx, errCode, msg, _mesa_lookup_enum_by_nr(value));
d475 1
a475 23
         {
            GLenum mode = (GLenum) (GLint) *param;
            if (mode == GL_REPLACE_EXT)
               mode = GL_REPLACE;
	    if (texUnit->EnvMode == mode)
	       return;
            if (mode == GL_MODULATE ||
                mode == GL_BLEND ||
                mode == GL_DECAL ||
                mode == GL_REPLACE ||
                (mode == GL_ADD && ctx->Extensions.EXT_texture_env_add) ||
                (mode == GL_COMBINE &&
                 (ctx->Extensions.EXT_texture_env_combine ||
                  ctx->Extensions.ARB_texture_env_combine))) {
               /* legal */
               FLUSH_VERTICES(ctx, _NEW_TEXTURE);
               texUnit->EnvMode = mode;
            }
            else {
               TE_ERROR(GL_INVALID_ENUM, "glTexEnv(param=%s)", mode);
               return;
            }
         }
d478 1
a478 11
         {
            GLfloat tmp[4];
            tmp[0] = CLAMP( param[0], 0.0F, 1.0F );
            tmp[1] = CLAMP( param[1], 0.0F, 1.0F );
            tmp[2] = CLAMP( param[2], 0.0F, 1.0F );
            tmp[3] = CLAMP( param[3], 0.0F, 1.0F );
            if (TEST_EQ_4V(tmp, texUnit->EnvColor))
               return;
            FLUSH_VERTICES(ctx, _NEW_TEXTURE);
            COPY_4FV(texUnit->EnvColor, tmp);
         }
a480 53
	 if (ctx->Extensions.EXT_texture_env_combine ||
             ctx->Extensions.ARB_texture_env_combine) {
	    const GLenum mode = (GLenum) (GLint) *param;
	    if (texUnit->Combine.ModeRGB == mode)
	       return;
	    switch (mode) {
	    case GL_REPLACE:
	    case GL_MODULATE:
	    case GL_ADD:
	    case GL_ADD_SIGNED:
	    case GL_INTERPOLATE:
               /* OK */
	       break;
            case GL_SUBTRACT:
               if (!ctx->Extensions.ARB_texture_env_combine) {
                  TE_ERROR(GL_INVALID_ENUM, "glTexEnv(param=%s)", mode);
                  return;
               }
               break;
	    case GL_DOT3_RGB_EXT:
	    case GL_DOT3_RGBA_EXT:
	       if (!ctx->Extensions.EXT_texture_env_dot3) {
                  TE_ERROR(GL_INVALID_ENUM, "glTexEnv(param=%s)", mode);
		  return;
	       }
	       break;
	    case GL_DOT3_RGB:
	    case GL_DOT3_RGBA:
	       if (!ctx->Extensions.ARB_texture_env_dot3) {
                  TE_ERROR(GL_INVALID_ENUM, "glTexEnv(param=%s)", mode);
		  return;
	       }
	       break;
	    case GL_MODULATE_ADD_ATI:
	    case GL_MODULATE_SIGNED_ADD_ATI:
	    case GL_MODULATE_SUBTRACT_ATI:
	       if (!ctx->Extensions.ATI_texture_env_combine3) {
                  TE_ERROR(GL_INVALID_ENUM, "glTexEnv(param=%s)", mode);
		  return;
	       }
	       break;
	    default:
               TE_ERROR(GL_INVALID_ENUM, "glTexEnv(param=%s)", mode);
	       return;
	    }
	    FLUSH_VERTICES(ctx, _NEW_TEXTURE);
	    texUnit->Combine.ModeRGB = mode;
	 }
	 else {
            TE_ERROR(GL_INVALID_ENUM, "glTexEnv(pname=%s)", pname);
	    return;
	 }
         break;
d482 1
a482 38
	 if (ctx->Extensions.EXT_texture_env_combine ||
             ctx->Extensions.ARB_texture_env_combine) {
	    const GLenum mode = (GLenum) (GLint) *param;
	    if (texUnit->Combine.ModeA == mode)
	       return;
            switch (mode) {
	    case GL_REPLACE:
	    case GL_MODULATE:
	    case GL_ADD:
	    case GL_ADD_SIGNED:
	    case GL_INTERPOLATE:
	       /* OK */
	       break;
	    case GL_SUBTRACT:
	       if (!ctx->Extensions.ARB_texture_env_combine) {
		  TE_ERROR(GL_INVALID_ENUM, "glTexEnv(param=%s)", mode);
		  return;
	       }
	       break;
	    case GL_MODULATE_ADD_ATI:
	    case GL_MODULATE_SIGNED_ADD_ATI:
	    case GL_MODULATE_SUBTRACT_ATI:
	       if (!ctx->Extensions.ATI_texture_env_combine3) {
                  TE_ERROR(GL_INVALID_ENUM, "glTexEnv(param=%s)", mode);
		  return;
	       }
	       break;
	    default:
	       TE_ERROR(GL_INVALID_ENUM, "glTexEnv(param=%s)", mode);
	       return;
	    }
	    FLUSH_VERTICES(ctx, _NEW_TEXTURE);
	    texUnit->Combine.ModeA = mode;
	 }
	 else {
            TE_ERROR(GL_INVALID_ENUM, "glTexEnv(pname=%s)", pname);
	    return;
	 }
d487 1
a487 29
	 if (ctx->Extensions.EXT_texture_env_combine ||
	     ctx->Extensions.ARB_texture_env_combine) {
	    const GLenum source = (GLenum) (GLint) *param;
	    const GLuint s = pname - GL_SOURCE0_RGB;
	    if (texUnit->Combine.SourceRGB[s] == source)
	       return;
            if (source == GL_TEXTURE ||
                source == GL_CONSTANT ||
                source == GL_PRIMARY_COLOR ||
                source == GL_PREVIOUS ||
                (ctx->Extensions.ARB_texture_env_crossbar &&
                 source >= GL_TEXTURE0 &&
                 source < GL_TEXTURE0 + ctx->Const.MaxTextureUnits) ||
                (ctx->Extensions.ATI_texture_env_combine3 &&
                 (source == GL_ZERO || source == GL_ONE))) {
               /* legal */
	       FLUSH_VERTICES(ctx, _NEW_TEXTURE);
	       texUnit->Combine.SourceRGB[s] = source;
            }
            else {
               TE_ERROR(GL_INVALID_ENUM, "glTexEnv(param=%s)", source);
	       return;
	    }
	 }
	 else {
            TE_ERROR(GL_INVALID_ENUM, "glTexEnv(pname=%s)", pname);
	    return;
	 }
	 break;
d491 2
a492 28
	 if (ctx->Extensions.EXT_texture_env_combine ||
             ctx->Extensions.ARB_texture_env_combine) {
	    const GLenum source = (GLenum) (GLint) *param;
	    const GLuint s = pname - GL_SOURCE0_ALPHA;
	    if (texUnit->Combine.SourceA[s] == source)
	       return;
            if (source == GL_TEXTURE ||
                source == GL_CONSTANT ||
                source == GL_PRIMARY_COLOR ||
                source == GL_PREVIOUS ||
                (ctx->Extensions.ARB_texture_env_crossbar &&
                 source >= GL_TEXTURE0 &&
                 source < GL_TEXTURE0 + ctx->Const.MaxTextureUnits) ||
		(ctx->Extensions.ATI_texture_env_combine3 &&
                 (source == GL_ZERO || source == GL_ONE))) {
               /* legal */
	       FLUSH_VERTICES(ctx, _NEW_TEXTURE);
	       texUnit->Combine.SourceA[s] = source;
            }
            else {
               TE_ERROR(GL_INVALID_ENUM, "glTexEnv(param=%s)", source);
	       return;
	    }
	 }
	 else {
            TE_ERROR(GL_INVALID_ENUM, "glTexEnv(pname=%s)", pname);
	    return;
	 }
d496 2
a497 24
	 if (ctx->Extensions.EXT_texture_env_combine ||
	     ctx->Extensions.ARB_texture_env_combine) {
	    const GLenum operand = (GLenum) (GLint) *param;
	    const GLuint s = pname - GL_OPERAND0_RGB;
	    if (texUnit->Combine.OperandRGB[s] == operand)
	       return;
	    switch (operand) {
	    case GL_SRC_COLOR:
	    case GL_ONE_MINUS_SRC_COLOR:
	    case GL_SRC_ALPHA:
	    case GL_ONE_MINUS_SRC_ALPHA:
	       FLUSH_VERTICES(ctx, _NEW_TEXTURE);
	       texUnit->Combine.OperandRGB[s] = operand;
	       break;
	    default:
               TE_ERROR(GL_INVALID_ENUM, "glTexEnv(param=%s)", operand);
	       return;
	    }
	 }
	 else {
            TE_ERROR(GL_INVALID_ENUM, "glTexEnv(pname=%s)", pname);
	    return;
	 }
	 break;
d500 11
a510 18
	 if (ctx->Extensions.EXT_texture_env_combine ||
             ctx->Extensions.ARB_texture_env_combine) {
	    const GLenum operand = (GLenum) (GLint) *param;
	    if (texUnit->Combine.OperandA[pname-GL_OPERAND0_ALPHA] == operand)
	       return;
	    switch (operand) {
	    case GL_SRC_ALPHA:
	    case GL_ONE_MINUS_SRC_ALPHA:
	       FLUSH_VERTICES(ctx, _NEW_TEXTURE);
	       texUnit->Combine.OperandA[pname-GL_OPERAND0_ALPHA] = operand;
	       break;
	    default:
               TE_ERROR(GL_INVALID_ENUM, "glTexEnv(param=%s)", operand);
	       return;
	    }
	 }
	 else {
            TE_ERROR(GL_INVALID_ENUM, "glTexEnv(pname=%s)", pname);
d513 4
a516 32
	 break;
      case GL_OPERAND2_RGB:
	 if (ctx->Extensions.ARB_texture_env_combine) {
	    const GLenum operand = (GLenum) (GLint) *param;
	    if (texUnit->Combine.OperandRGB[2] == operand)
	       return;
	    switch (operand) {
	    case GL_SRC_COLOR:           /* ARB combine only */
	    case GL_ONE_MINUS_SRC_COLOR: /* ARB combine only */
	    case GL_SRC_ALPHA:
	    case GL_ONE_MINUS_SRC_ALPHA: /* ARB combine only */
	       FLUSH_VERTICES(ctx, _NEW_TEXTURE);
	       texUnit->Combine.OperandRGB[2] = operand;
               break;
	    default:
               TE_ERROR(GL_INVALID_ENUM, "glTexEnv(param=%s)", operand);
	       return;
	    }
	 }
	 else if (ctx->Extensions.EXT_texture_env_combine) {
	    const GLenum operand = (GLenum) (GLint) *param;
	    if (texUnit->Combine.OperandRGB[2] == operand)
	       return;
	    /* operand must be GL_SRC_ALPHA which is the initial value - thus
	       don't need to actually compare the operand to the possible value */
	    else {
               TE_ERROR(GL_INVALID_ENUM, "glTexEnv(param=%s)", operand);
	       return;
	    }
	 }
	 else {
            TE_ERROR(GL_INVALID_ENUM, "glTexEnv(pname=%s)", pname);
d519 2
a520 30
	 break;
      case GL_OPERAND2_ALPHA:
	 if (ctx->Extensions.ARB_texture_env_combine) {
	    const GLenum operand = (GLenum) (GLint) *param;
	    if (texUnit->Combine.OperandA[2] == operand)
	       return;
	    switch (operand) {
	    case GL_SRC_ALPHA:
	    case GL_ONE_MINUS_SRC_ALPHA: /* ARB combine only */
	       FLUSH_VERTICES(ctx, _NEW_TEXTURE);
	       texUnit->Combine.OperandA[2] = operand;
	       break;
	    default:
               TE_ERROR(GL_INVALID_ENUM, "glTexEnv(param=%s)", operand);
	       return;
	    }
	 }
	 else if (ctx->Extensions.EXT_texture_env_combine) {
	    const GLenum operand = (GLenum) (GLint) *param;
	    if (texUnit->Combine.OperandA[2] == operand)
	       return;
	    /* operand must be GL_SRC_ALPHA which is the initial value - thus
	       don't need to actually compare the operand to the possible value */
	    else {
               TE_ERROR(GL_INVALID_ENUM, "glTexEnv(param=%s)", operand);
	       return;
	    }
	 }
	 else {
            TE_ERROR(GL_INVALID_ENUM, "glTexEnv(pname=%s)", pname);
a522 24
	 break;
      case GL_RGB_SCALE:
	 if (ctx->Extensions.EXT_texture_env_combine ||
             ctx->Extensions.ARB_texture_env_combine) {
	    GLuint newshift;
	    if (*param == 1.0) {
	       newshift = 0;
	    }
	    else if (*param == 2.0) {
	       newshift = 1;
	    }
	    else if (*param == 4.0) {
	       newshift = 2;
	    }
	    else {
	       _mesa_error( ctx, GL_INVALID_VALUE,
                            "glTexEnv(GL_RGB_SCALE not 1, 2 or 4)" );
	       return;
	    }
	    if (texUnit->Combine.ScaleShiftRGB == newshift)
	       return;
	    FLUSH_VERTICES(ctx, _NEW_TEXTURE);
	    texUnit->Combine.ScaleShiftRGB = newshift;
	 }
a523 24
            TE_ERROR(GL_INVALID_ENUM, "glTexEnv(pname=%s)", pname);
	    return;
	 }
	 break;
      case GL_ALPHA_SCALE:
	 if (ctx->Extensions.EXT_texture_env_combine ||
             ctx->Extensions.ARB_texture_env_combine) {
	    GLuint newshift;
	    if (*param == 1.0) {
	       newshift = 0;
	    }
	    else if (*param == 2.0) {
	       newshift = 1;
	    }
	    else if (*param == 4.0) {
	       newshift = 2;
	    }
	    else {
	       _mesa_error( ctx, GL_INVALID_VALUE,
                            "glTexEnv(GL_ALPHA_SCALE not 1, 2 or 4)" );
	       return;
	    }
	    if (texUnit->Combine.ScaleShiftA == newshift)
	       return;
d525 1
a525 5
	    texUnit->Combine.ScaleShiftA = newshift;
	 }
	 else {
            TE_ERROR(GL_INVALID_ENUM, "glTexEnv(pname=%s)", pname);
	    return;
d601 4
a604 1
   _mesa_TexEnvfv( target, pname, &param );
d680 8
d700 8
d720 8
d740 8
d766 10
d800 1
a800 1
   texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
d864 1
a864 1
   texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
d916 166
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d3 1
a3 1
 * Version:  7.5
a5 1
 * Copyright (C) 2009  VMware, Inc.  All Rights Reserved.
d37 1
a37 369
#include "main/texstate.h"


#define TE_ERROR(errCode, msg, value)				\
   _mesa_error(ctx, errCode, msg, _mesa_lookup_enum_by_nr(value));


/** Set texture env mode */
static void
set_env_mode(struct gl_context *ctx,
             struct gl_texture_unit *texUnit,
             GLenum mode)
{
   GLboolean legal;

   if (texUnit->EnvMode == mode)
      return;

   switch (mode) {
   case GL_MODULATE:
   case GL_BLEND:
   case GL_DECAL:
   case GL_REPLACE:
      legal = GL_TRUE;
      break;
   case GL_REPLACE_EXT:
      mode = GL_REPLACE; /* GL_REPLACE_EXT != GL_REPLACE */
      legal = GL_TRUE;
      break;
   case GL_ADD:
      legal = ctx->Extensions.EXT_texture_env_add;
      break;
   case GL_COMBINE:
      legal = (ctx->Extensions.EXT_texture_env_combine ||
               ctx->Extensions.ARB_texture_env_combine);
      break;
   case GL_COMBINE4_NV:
      legal = ctx->Extensions.NV_texture_env_combine4;
      break;
   default:
      legal = GL_FALSE;
   }

   if (legal) {
      FLUSH_VERTICES(ctx, _NEW_TEXTURE);
      texUnit->EnvMode = mode;
   }
   else {
      TE_ERROR(GL_INVALID_ENUM, "glTexEnv(param=%s)", mode);
   }
}


static void
set_env_color(struct gl_context *ctx,
              struct gl_texture_unit *texUnit,
              const GLfloat *color)
{
   GLfloat tmp[4];
   tmp[0] = CLAMP(color[0], 0.0F, 1.0F);
   tmp[1] = CLAMP(color[1], 0.0F, 1.0F);
   tmp[2] = CLAMP(color[2], 0.0F, 1.0F);
   tmp[3] = CLAMP(color[3], 0.0F, 1.0F);
   if (TEST_EQ_4V(tmp, texUnit->EnvColor))
      return;
   FLUSH_VERTICES(ctx, _NEW_TEXTURE);
   COPY_4FV(texUnit->EnvColor, tmp);
}


/** Set an RGB or A combiner mode/function */
static void
set_combiner_mode(struct gl_context *ctx,
                  struct gl_texture_unit *texUnit,
                  GLenum pname, GLenum mode)
{
   GLboolean legal;

   if (!ctx->Extensions.EXT_texture_env_combine &&
       !ctx->Extensions.ARB_texture_env_combine) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glTexEnv(pname)");
      return;
   }

   switch (mode) {
   case GL_REPLACE:
   case GL_MODULATE:
   case GL_ADD:
   case GL_ADD_SIGNED:
   case GL_INTERPOLATE:
      legal = GL_TRUE;
      break;
   case GL_SUBTRACT:
      legal = ctx->Extensions.ARB_texture_env_combine;
      break;
   case GL_DOT3_RGB_EXT:
   case GL_DOT3_RGBA_EXT:
      legal = (ctx->Extensions.EXT_texture_env_dot3 &&
               pname == GL_COMBINE_RGB);
      break;
   case GL_DOT3_RGB:
   case GL_DOT3_RGBA:
      legal = (ctx->Extensions.ARB_texture_env_dot3 &&
               pname == GL_COMBINE_RGB);
      break;
   case GL_MODULATE_ADD_ATI:
   case GL_MODULATE_SIGNED_ADD_ATI:
   case GL_MODULATE_SUBTRACT_ATI:
      legal = ctx->Extensions.ATI_texture_env_combine3;
      break;
   case GL_BUMP_ENVMAP_ATI:
      legal = (ctx->Extensions.ATI_envmap_bumpmap &&
               pname == GL_COMBINE_RGB);
      break;
   default:
      legal = GL_FALSE;
   }

   if (!legal) {
      TE_ERROR(GL_INVALID_ENUM, "glTexEnv(param=%s)", mode);
      return;
   }

   switch (pname) {
   case GL_COMBINE_RGB:
      if (texUnit->Combine.ModeRGB == mode)
         return;
      FLUSH_VERTICES(ctx, _NEW_TEXTURE);
      texUnit->Combine.ModeRGB = mode;
      break;

   case GL_COMBINE_ALPHA:
      if (texUnit->Combine.ModeA == mode)
         return;
      FLUSH_VERTICES(ctx, _NEW_TEXTURE);
      texUnit->Combine.ModeA = mode;
      break;
   default:
      TE_ERROR(GL_INVALID_ENUM, "glTexEnv(pname=%s)", pname);
   }
}



/** Set an RGB or A combiner source term */
static void
set_combiner_source(struct gl_context *ctx,
                    struct gl_texture_unit *texUnit,
                    GLenum pname, GLenum param)
{
   GLuint term;
   GLboolean alpha, legal;

   if (!ctx->Extensions.EXT_texture_env_combine &&
       !ctx->Extensions.ARB_texture_env_combine) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glTexEnv(pname)");
      return;
   }

   /*
    * Translate pname to (term, alpha).
    *
    * The enums were given sequential values for a reason.
    */
   switch (pname) {
   case GL_SOURCE0_RGB:
   case GL_SOURCE1_RGB:
   case GL_SOURCE2_RGB:
   case GL_SOURCE3_RGB_NV:
      term = pname - GL_SOURCE0_RGB;
      alpha = GL_FALSE;
      break;
   case GL_SOURCE0_ALPHA:
   case GL_SOURCE1_ALPHA:
   case GL_SOURCE2_ALPHA:
   case GL_SOURCE3_ALPHA_NV:
      term = pname - GL_SOURCE0_ALPHA;
      alpha = GL_TRUE;
      break;
   default:
      TE_ERROR(GL_INVALID_ENUM, "glTexEnv(pname=%s)", pname);
      return;
   }

   if ((term == 3) && !ctx->Extensions.NV_texture_env_combine4) {
      TE_ERROR(GL_INVALID_ENUM, "glTexEnv(pname=%s)", pname);
      return;
   }

   assert(term < MAX_COMBINER_TERMS);

   /*
    * Error-check param (the source term)
    */
   switch (param) {
   case GL_TEXTURE:
   case GL_CONSTANT:
   case GL_PRIMARY_COLOR:
   case GL_PREVIOUS:
      legal = GL_TRUE;
      break;
   case GL_TEXTURE0:
   case GL_TEXTURE1:
   case GL_TEXTURE2:
   case GL_TEXTURE3:
   case GL_TEXTURE4:
   case GL_TEXTURE5:
   case GL_TEXTURE6:
   case GL_TEXTURE7:
      legal = (ctx->Extensions.ARB_texture_env_crossbar &&
               param - GL_TEXTURE0 < ctx->Const.MaxTextureUnits);
      break;
   case GL_ZERO:
      legal = (ctx->Extensions.ATI_texture_env_combine3 ||
               ctx->Extensions.NV_texture_env_combine4);
      break;
   case GL_ONE:
      legal = ctx->Extensions.ATI_texture_env_combine3;
      break;
   default:
      legal = GL_FALSE;
   }

   if (!legal) {
      TE_ERROR(GL_INVALID_ENUM, "glTexEnv(param=%s)", param);
      return;
   }

   FLUSH_VERTICES(ctx, _NEW_TEXTURE);

   if (alpha)
      texUnit->Combine.SourceA[term] = param;
   else
      texUnit->Combine.SourceRGB[term] = param;
}


/** Set an RGB or A combiner operand term */
static void
set_combiner_operand(struct gl_context *ctx,
                     struct gl_texture_unit *texUnit,
                     GLenum pname, GLenum param)
{
   GLuint term;
   GLboolean alpha, legal;

   if (!ctx->Extensions.EXT_texture_env_combine &&
       !ctx->Extensions.ARB_texture_env_combine) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glTexEnv(pname)");
      return;
   }

   /* The enums were given sequential values for a reason.
    */
   switch (pname) {
   case GL_OPERAND0_RGB:
   case GL_OPERAND1_RGB:
   case GL_OPERAND2_RGB:
   case GL_OPERAND3_RGB_NV:
      term = pname - GL_OPERAND0_RGB;
      alpha = GL_FALSE;
      break;
   case GL_OPERAND0_ALPHA:
   case GL_OPERAND1_ALPHA:
   case GL_OPERAND2_ALPHA:
   case GL_OPERAND3_ALPHA_NV:
      term = pname - GL_OPERAND0_ALPHA;
      alpha = GL_TRUE;
      break;
   default:
      TE_ERROR(GL_INVALID_ENUM, "glTexEnv(pname=%s)", pname);
      return;
   }

   if ((term == 3) && !ctx->Extensions.NV_texture_env_combine4) {
      TE_ERROR(GL_INVALID_ENUM, "glTexEnv(pname=%s)", pname);
      return;
   }

   assert(term < MAX_COMBINER_TERMS);

   /*
    * Error-check param (the source operand)
    */
   switch (param) {
   case GL_SRC_COLOR:
   case GL_ONE_MINUS_SRC_COLOR:
      /* The color input can only be used with GL_OPERAND[01]_RGB in the EXT
       * version.  In the ARB and NV versions they can be used for any RGB
       * operand.
       */
      legal = !alpha
	 && ((term < 2) || ctx->Extensions.ARB_texture_env_combine
	     || ctx->Extensions.NV_texture_env_combine4);
      break;
   case GL_ONE_MINUS_SRC_ALPHA:
      /* GL_ONE_MINUS_SRC_ALPHA can only be used with
       * GL_OPERAND[01]_(RGB|ALPHA) in the EXT version.  In the ARB and NV
       * versions it can be used for any operand.
       */
      legal = (term < 2) || ctx->Extensions.ARB_texture_env_combine
	 || ctx->Extensions.NV_texture_env_combine4;
      break;
   case GL_SRC_ALPHA:
      legal = GL_TRUE;
      break;
   default:
      legal = GL_FALSE;
   }

   if (!legal) {
      TE_ERROR(GL_INVALID_ENUM, "glTexEnv(param=%s)", param);
      return;
   }

   FLUSH_VERTICES(ctx, _NEW_TEXTURE);

   if (alpha)
      texUnit->Combine.OperandA[term] = param;
   else
      texUnit->Combine.OperandRGB[term] = param;
}


static void
set_combiner_scale(struct gl_context *ctx,
                   struct gl_texture_unit *texUnit,
                   GLenum pname, GLfloat scale)
{
   GLuint shift;

   if (!ctx->Extensions.EXT_texture_env_combine &&
       !ctx->Extensions.ARB_texture_env_combine) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glTexEnv(pname)");
      return;
   }

   if (scale == 1.0F) {
      shift = 0;
   }
   else if (scale == 2.0F) {
      shift = 1;
   }
   else if (scale == 4.0F) {
      shift = 2;
   }
   else {
      _mesa_error( ctx, GL_INVALID_VALUE,
                   "glTexEnv(GL_RGB_SCALE not 1, 2 or 4)" );
      return;
   }

   switch (pname) {
   case GL_RGB_SCALE:
      if (texUnit->Combine.ScaleShiftRGB == shift)
         return;
      FLUSH_VERTICES(ctx, _NEW_TEXTURE);
      texUnit->Combine.ScaleShiftRGB = shift;
      break;
   case GL_ALPHA_SCALE:
      if (texUnit->Combine.ScaleShiftA == shift)
         return;
      FLUSH_VERTICES(ctx, _NEW_TEXTURE);
      texUnit->Combine.ScaleShiftA = shift;
      break;
   default:
      TE_ERROR(GL_INVALID_ENUM, "glTexEnv(pname=%s)", pname);
   }
}
d56 4
a59 1
   texUnit = _mesa_get_current_tex_unit(ctx);
d64 23
a86 1
         set_env_mode(ctx, texUnit, (GLenum) (GLint) param[0]);
d89 11
a99 1
         set_env_color(ctx, texUnit, param);
d102 53
d156 38
a193 1
         set_combiner_mode(ctx, texUnit, pname, (GLenum) (GLint) param[0]);
d198 29
a226 1
      case GL_SOURCE3_RGB_NV:
d230 28
a257 2
      case GL_SOURCE3_ALPHA_NV:
         set_combiner_source(ctx, texUnit, pname, (GLenum) (GLint) param[0]);
d261 24
a284 2
      case GL_OPERAND2_RGB:
      case GL_OPERAND3_RGB_NV:
d287 55
d343 30
a372 2
      case GL_OPERAND3_ALPHA_NV:
         set_combiner_operand(ctx, texUnit, pname, (GLenum) (GLint) param[0]);
d375 21
a395 7
      case GL_ALPHA_SCALE:
         set_combiner_scale(ctx, texUnit, pname, param[0]);
	 break;
      case GL_BUMP_TARGET_ATI:
         if (!ctx->Extensions.ATI_envmap_bumpmap) {
	    _mesa_error( ctx, GL_INVALID_ENUM, "glTexEnv(pname=0x%x)", pname );
	    return;
d397 2
a398 4
	 if (((GLenum) (GLint) param[0] < GL_TEXTURE0) ||
	 ((GLenum) (GLint) param[0] > GL_TEXTURE31)) {
	    /* spec doesn't say this but it seems logical */
	    _mesa_error( ctx, GL_INVALID_ENUM, "glTexEnv(param=0x%x)", (GLenum) (GLint) param[0]);
d401 23
a423 3
	 if (!((1 << ((GLenum) (GLint) param[0] - GL_TEXTURE0)) & ctx->Const.SupportedBumpUnits)) {
	    _mesa_error( ctx, GL_INVALID_VALUE, "glTexEnv(param=0x%x)", (GLenum) (GLint) param[0]);
	    return;
d426 2
a427 2
	    FLUSH_VERTICES(ctx, _NEW_TEXTURE);
	    texUnit->BumpTarget = (GLenum) (GLint) param[0];
d503 1
a503 4
   GLfloat p[4];
   p[0] = param;
   p[1] = p[2] = p[3] = 0.0;
   _mesa_TexEnvfv( target, pname, p );
d542 1
a542 1
get_texenvi(struct gl_context *ctx, const struct gl_texture_unit *texUnit,
a578 8
   case GL_SOURCE3_RGB_NV:
      if (ctx->Extensions.NV_texture_env_combine4) {
         return texUnit->Combine.SourceRGB[3];
      }
      else {
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)");
      }
      break;
a590 8
   case GL_SOURCE3_ALPHA_NV:
      if (ctx->Extensions.NV_texture_env_combine4) {
         return texUnit->Combine.SourceA[3];
      }
      else {
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)");
      }
      break;
a602 8
   case GL_OPERAND3_RGB_NV:
      if (ctx->Extensions.NV_texture_env_combine4) {
         return texUnit->Combine.OperandRGB[3];
      }
      else {
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)");
      }
      break;
a614 8
   case GL_OPERAND3_ALPHA_NV:
      if (ctx->Extensions.NV_texture_env_combine4) {
         return texUnit->Combine.OperandA[3];
      }
      else {
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)");
      }
      break;
a632 10
   case GL_BUMP_TARGET_ATI:
      /* spec doesn't say so, but I think this should be queryable */
      if (ctx->Extensions.ATI_envmap_bumpmap) {
         return texUnit->BumpTarget;
      }
      else {
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)");
      }
      break;

d657 1
a657 1
   texUnit = _mesa_get_current_tex_unit(ctx);
d721 1
a721 1
   texUnit = _mesa_get_current_tex_unit(ctx);
a772 166
/**
 * Why does ATI_envmap_bumpmap require new entrypoints? Should just
 * reuse TexEnv ones...
 */
void GLAPIENTRY
_mesa_TexBumpParameterivATI( GLenum pname, const GLint *param )
{
   GLfloat p[4];
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   if (!ctx->Extensions.ATI_envmap_bumpmap) {
      /* This isn't an "official" error case, but let's tell the user
       * that something's wrong.
       */
      _mesa_error(ctx, GL_INVALID_OPERATION, "glTexBumpParameterivATI");
      return;
   }

   if (pname == GL_BUMP_ROT_MATRIX_ATI) {
      /* hope that conversion is correct here */
      p[0] = INT_TO_FLOAT( param[0] );
      p[1] = INT_TO_FLOAT( param[1] );
      p[2] = INT_TO_FLOAT( param[2] );
      p[3] = INT_TO_FLOAT( param[3] );
   }
   else {
      p[0] = (GLfloat) param[0];
      p[1] = p[2] = p[3] = 0.0F;  /* init to zero, just to be safe */
   }
   _mesa_TexBumpParameterfvATI( pname, p );
}


void GLAPIENTRY
_mesa_TexBumpParameterfvATI( GLenum pname, const GLfloat *param )
{
   struct gl_texture_unit *texUnit;
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   if (!ctx->Extensions.ATI_envmap_bumpmap) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glTexBumpParameterfvATI");
      return;
   }

   texUnit = _mesa_get_current_tex_unit(ctx);

   if (pname == GL_BUMP_ROT_MATRIX_ATI) {
      if (TEST_EQ_4V(param, texUnit->RotMatrix))
         return;
      FLUSH_VERTICES(ctx, _NEW_TEXTURE);
      COPY_4FV(texUnit->RotMatrix, param);
   }
   else {
      _mesa_error( ctx, GL_INVALID_ENUM, "glTexBumpParameter(pname)" );
      return;
   }
   /* Drivers might want to know about this, instead of dedicated function
      just shove it into TexEnv where it really belongs anyway */
   if (ctx->Driver.TexEnv) {
      (*ctx->Driver.TexEnv)( ctx, 0, pname, param );
   }
}


void GLAPIENTRY
_mesa_GetTexBumpParameterivATI( GLenum pname, GLint *param )
{
   const struct gl_texture_unit *texUnit;
   GLuint i;
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   if (!ctx->Extensions.ATI_envmap_bumpmap) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glGetTexBumpParameterivATI");
      return;
   }

   texUnit = _mesa_get_current_tex_unit(ctx);

   if (pname == GL_BUMP_ROT_MATRIX_SIZE_ATI) {
      /* spec leaves open to support larger matrices.
         Don't think anyone would ever want to use it
         (and apps almost certainly would not understand it and
         thus fail to submit matrices correctly) so hardcode this. */
      *param = 4;
   }
   else if (pname == GL_BUMP_ROT_MATRIX_ATI) {
      /* hope that conversion is correct here */
      param[0] = FLOAT_TO_INT(texUnit->RotMatrix[0]);
      param[1] = FLOAT_TO_INT(texUnit->RotMatrix[1]);
      param[2] = FLOAT_TO_INT(texUnit->RotMatrix[2]);
      param[3] = FLOAT_TO_INT(texUnit->RotMatrix[3]);
   }
   else if (pname == GL_BUMP_NUM_TEX_UNITS_ATI) {
      GLint count = 0;
      for (i = 0; i < ctx->Const.MaxTextureImageUnits; i++) {
         if (ctx->Const.SupportedBumpUnits & (1 << i)) {
            count++;
         }
      }
      *param = count;
   }
   else if (pname == GL_BUMP_TEX_UNITS_ATI) {
      for (i = 0; i < ctx->Const.MaxTextureImageUnits; i++) {
         if (ctx->Const.SupportedBumpUnits & (1 << i)) {
            *param++ = i + GL_TEXTURE0;
         }
      }
   }
   else {
      _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexBumpParameter(pname)" );
      return;
   }
}


void GLAPIENTRY
_mesa_GetTexBumpParameterfvATI( GLenum pname, GLfloat *param )
{
   const struct gl_texture_unit *texUnit;
   GLuint i;
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   if (!ctx->Extensions.ATI_envmap_bumpmap) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glGetTexBumpParameterfvATI");
      return;
   }

   texUnit = _mesa_get_current_tex_unit(ctx);

   if (pname == GL_BUMP_ROT_MATRIX_SIZE_ATI) {
      /* spec leaves open to support larger matrices.
         Don't think anyone would ever want to use it
         (and apps might not understand it) so hardcode this. */
      *param = 4.0F;
   }
   else if (pname == GL_BUMP_ROT_MATRIX_ATI) {
      param[0] = texUnit->RotMatrix[0];
      param[1] = texUnit->RotMatrix[1];
      param[2] = texUnit->RotMatrix[2];
      param[3] = texUnit->RotMatrix[3];
   }
   else if (pname == GL_BUMP_NUM_TEX_UNITS_ATI) {
      GLint count = 0;
      for (i = 0; i < ctx->Const.MaxTextureImageUnits; i++) {
         if (ctx->Const.SupportedBumpUnits & (1 << i)) {
            count++;
         }
      }
      *param = (GLfloat) count;
   }
   else if (pname == GL_BUMP_TEX_UNITS_ATI) {
      for (i = 0; i < ctx->Const.MaxTextureImageUnits; i++) {
         if (ctx->Const.SupportedBumpUnits & (1 << i)) {
            *param++ = (GLfloat) (i + GL_TEXTURE0);
         }
      }
   }
   else {
      _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexBumpParameter(pname)" );
      return;
   }
}
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d3 1
d21 3
a23 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
a34 1
#include "main/blend.h"
a36 2
#include "main/mtypes.h"
#include "main/state.h"
a60 2
   case GL_ADD:
   case GL_COMBINE:
d67 7
d96 6
a101 1
   if (TEST_EQ_4V(color, texUnit->EnvColorUnclamped))
d104 1
a104 5
   COPY_4FV(texUnit->EnvColorUnclamped, color);
   texUnit->EnvColor[0] = CLAMP(color[0], 0.0F, 1.0F);
   texUnit->EnvColor[1] = CLAMP(color[1], 0.0F, 1.0F);
   texUnit->EnvColor[2] = CLAMP(color[2], 0.0F, 1.0F);
   texUnit->EnvColor[3] = CLAMP(color[3], 0.0F, 1.0F);
d116 6
d135 1
a135 2
      legal = (ctx->API == API_OPENGL_COMPAT &&
               ctx->Extensions.EXT_texture_env_dot3 &&
d146 1
a146 2
      legal = (ctx->API == API_OPENGL_COMPAT &&
               ctx->Extensions.ATI_texture_env_combine3);
d149 1
a149 2
      legal = (ctx->API == API_OPENGL_COMPAT &&
               ctx->Extensions.ATI_envmap_bumpmap &&
d191 6
d222 1
a222 2
   if ((term == 3) && (ctx->API != API_OPENGL_COMPAT
                       || !ctx->Extensions.NV_texture_env_combine4)) {
d251 2
a252 3
      legal = (ctx->API == API_OPENGL_COMPAT &&
               (ctx->Extensions.ATI_texture_env_combine3 ||
                ctx->Extensions.NV_texture_env_combine4));
d255 1
a255 2
      legal = (ctx->API == API_OPENGL_COMPAT &&
               ctx->Extensions.ATI_texture_env_combine3);
d284 6
d312 1
a312 2
   if ((term == 3) && (ctx->API != API_OPENGL_COMPAT
                       || !ctx->Extensions.NV_texture_env_combine4)) {
d326 2
a327 2
       * version.  In the ARB and NV versions and OpenGL ES 1.x they can be
       * used for any RGB operand.
d336 1
a336 1
       * versions and OpenGL ES 1.x it can be used for any operand.
d369 6
a412 2
   const GLint iparam0 = (GLint) param[0];
   struct gl_texture_unit *texUnit;
d415 2
d419 1
a419 1
      ? ctx->Const.MaxTextureCoordUnits : ctx->Const.MaxCombinedTextureImageUnits;
d430 1
a430 1
         set_env_mode(ctx, texUnit, (GLenum) iparam0);
d437 1
a437 1
         set_combiner_mode(ctx, texUnit, pname, (GLenum) iparam0);
d447 1
a447 1
         set_combiner_source(ctx, texUnit, pname, (GLenum) iparam0);
d457 1
a457 1
         set_combiner_operand(ctx, texUnit, pname, (GLenum) iparam0);
d464 1
a464 1
         if (ctx->API != API_OPENGL_COMPAT || !ctx->Extensions.ATI_envmap_bumpmap) {
d468 2
a469 2
	 if ((iparam0 < GL_TEXTURE0) ||
             (iparam0 > GL_TEXTURE31)) {
d471 1
a471 1
	    _mesa_error( ctx, GL_INVALID_ENUM, "glTexEnv(param=0x%x)", iparam0);
d474 2
a475 2
	 if (!((1 << (iparam0 - GL_TEXTURE0)) & ctx->Const.SupportedBumpUnits)) {
	    _mesa_error( ctx, GL_INVALID_VALUE, "glTexEnv(param=0x%x)", iparam0);
d480 1
a480 1
	    texUnit->BumpTarget = iparam0;
d489 5
d513 2
a514 1
         if (iparam0 == GL_TRUE || iparam0 == GL_FALSE) {
d518 1
a518 1
            const GLboolean state = (GLboolean) iparam0;
d525 1
a525 1
            _mesa_error( ctx, GL_INVALID_VALUE, "glTexEnv(param=0x%x)", iparam0);
d535 1
a535 2
      _mesa_error(ctx, GL_INVALID_ENUM, "glTexEnv(target=%s)",
                  _mesa_lookup_enum_by_nr(target));
d544 1
a544 1
                  _mesa_lookup_enum_by_nr((GLenum) iparam0));
d606 8
a613 1
      return texUnit->Combine.ModeRGB;
d615 8
a622 1
      return texUnit->Combine.ModeA;
d625 10
a634 4
   case GL_SOURCE2_RGB: {
      const unsigned rgb_idx = pname - GL_SOURCE0_RGB;
      return texUnit->Combine.SourceRGB[rgb_idx];
   }
d636 1
a636 1
      if (ctx->API == API_OPENGL_COMPAT && ctx->Extensions.NV_texture_env_combine4) {
d645 10
a654 4
   case GL_SOURCE2_ALPHA: {
      const unsigned alpha_idx = pname - GL_SOURCE0_ALPHA;
      return texUnit->Combine.SourceA[alpha_idx];
   }
d656 1
a656 1
      if (ctx->API == API_OPENGL_COMPAT && ctx->Extensions.NV_texture_env_combine4) {
d665 10
a674 4
   case GL_OPERAND2_RGB: {
      const unsigned op_rgb = pname - GL_OPERAND0_RGB;
      return texUnit->Combine.OperandRGB[op_rgb];
   }
d676 1
a676 1
      if (ctx->API == API_OPENGL_COMPAT && ctx->Extensions.NV_texture_env_combine4) {
d685 10
a694 4
   case GL_OPERAND2_ALPHA: {
      const unsigned op_alpha = pname - GL_OPERAND0_ALPHA;
      return texUnit->Combine.OperandA[op_alpha];
   }
d696 1
a696 1
      if (ctx->API == API_OPENGL_COMPAT && ctx->Extensions.NV_texture_env_combine4) {
d704 8
a711 1
      return 1 << texUnit->Combine.ScaleShiftRGB;
d713 8
a720 1
      return 1 << texUnit->Combine.ScaleShiftA;
d723 1
a723 1
      if (ctx->API == API_OPENGL_COMPAT && ctx->Extensions.ATI_envmap_bumpmap) {
d732 1
a732 2
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)");
      break;
d746 1
d749 1
a749 1
      ? ctx->Const.MaxTextureCoordUnits : ctx->Const.MaxCombinedTextureImageUnits;
d759 1
a759 6
         if(ctx->NewState & (_NEW_BUFFERS | _NEW_FRAG_CLAMP))
            _mesa_update_state(ctx);
         if (_mesa_get_clamp_fragment_color(ctx))
            COPY_4FV( params, texUnit->EnvColor );
         else
            COPY_4FV( params, texUnit->EnvColorUnclamped );
d769 5
d810 1
d813 1
a813 1
      ? ctx->Const.MaxTextureCoordUnits : ctx->Const.MaxCombinedTextureImageUnits;
d836 5
d880 1
d910 1
d943 1
d968 1
a968 1
      for (i = 0; i < ctx->Const.FragmentProgram.MaxTextureImageUnits; i++) {
d976 1
a976 1
      for (i = 0; i < ctx->Const.FragmentProgram.MaxTextureImageUnits; i++) {
d995 1
d1018 1
a1018 1
      for (i = 0; i < ctx->Const.FragmentProgram.MaxTextureImageUnits; i++) {
d1026 1
a1026 1
      for (i = 0; i < ctx->Const.FragmentProgram.MaxTextureImageUnits; i++) {
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d882 1
a882 1
      for (i = 0; i < ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits; i++) {
d890 1
a890 1
      for (i = 0; i < ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits; i++) {
d931 1
a931 1
      for (i = 0; i < ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits; i++) {
d939 1
a939 1
      for (i = 0; i < ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits; i++) {
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d141 5
d443 20
d644 10
d787 163
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@a140 5
   case GL_BUMP_ENVMAP_ATI:
      legal = (ctx->API == API_OPENGL_COMPAT &&
               ctx->Extensions.ATI_envmap_bumpmap &&
               pname == GL_COMBINE_RGB);
      break;
a437 20
      case GL_BUMP_TARGET_ATI:
         if (ctx->API != API_OPENGL_COMPAT || !ctx->Extensions.ATI_envmap_bumpmap) {
	    _mesa_error( ctx, GL_INVALID_ENUM, "glTexEnv(pname=0x%x)", pname );
	    return;
	 }
	 if ((iparam0 < GL_TEXTURE0) ||
             (iparam0 > GL_TEXTURE31)) {
	    /* spec doesn't say this but it seems logical */
	    _mesa_error( ctx, GL_INVALID_ENUM, "glTexEnv(param=0x%x)", iparam0);
	    return;
	 }
	 if (!((1 << (iparam0 - GL_TEXTURE0)) & ctx->Const.SupportedBumpUnits)) {
	    _mesa_error( ctx, GL_INVALID_VALUE, "glTexEnv(param=0x%x)", iparam0);
	    return;
	 }
	 else {
	    FLUSH_VERTICES(ctx, _NEW_TEXTURE);
	    texUnit->BumpTarget = iparam0;
	 }
	 break;
a618 10
   case GL_BUMP_TARGET_ATI:
      /* spec doesn't say so, but I think this should be queryable */
      if (ctx->API == API_OPENGL_COMPAT && ctx->Extensions.ATI_envmap_bumpmap) {
         return texUnit->BumpTarget;
      }
      else {
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)");
      }
      break;

a751 163

/**
 * Why does ATI_envmap_bumpmap require new entrypoints? Should just
 * reuse TexEnv ones...
 */
void GLAPIENTRY
_mesa_TexBumpParameterivATI( GLenum pname, const GLint *param )
{
   GLfloat p[4];
   GET_CURRENT_CONTEXT(ctx);

   if (!ctx->Extensions.ATI_envmap_bumpmap) {
      /* This isn't an "official" error case, but let's tell the user
       * that something's wrong.
       */
      _mesa_error(ctx, GL_INVALID_OPERATION, "glTexBumpParameterivATI");
      return;
   }

   if (pname == GL_BUMP_ROT_MATRIX_ATI) {
      /* hope that conversion is correct here */
      p[0] = INT_TO_FLOAT( param[0] );
      p[1] = INT_TO_FLOAT( param[1] );
      p[2] = INT_TO_FLOAT( param[2] );
      p[3] = INT_TO_FLOAT( param[3] );
   }
   else {
      p[0] = (GLfloat) param[0];
      p[1] = p[2] = p[3] = 0.0F;  /* init to zero, just to be safe */
   }
   _mesa_TexBumpParameterfvATI( pname, p );
}


void GLAPIENTRY
_mesa_TexBumpParameterfvATI( GLenum pname, const GLfloat *param )
{
   struct gl_texture_unit *texUnit;
   GET_CURRENT_CONTEXT(ctx);

   if (!ctx->Extensions.ATI_envmap_bumpmap) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glTexBumpParameterfvATI");
      return;
   }

   texUnit = _mesa_get_current_tex_unit(ctx);

   if (pname == GL_BUMP_ROT_MATRIX_ATI) {
      if (TEST_EQ_4V(param, texUnit->RotMatrix))
         return;
      FLUSH_VERTICES(ctx, _NEW_TEXTURE);
      COPY_4FV(texUnit->RotMatrix, param);
   }
   else {
      _mesa_error( ctx, GL_INVALID_ENUM, "glTexBumpParameter(pname)" );
      return;
   }
   /* Drivers might want to know about this, instead of dedicated function
      just shove it into TexEnv where it really belongs anyway */
   if (ctx->Driver.TexEnv) {
      (*ctx->Driver.TexEnv)( ctx, 0, pname, param );
   }
}


void GLAPIENTRY
_mesa_GetTexBumpParameterivATI( GLenum pname, GLint *param )
{
   const struct gl_texture_unit *texUnit;
   GLuint i;
   GET_CURRENT_CONTEXT(ctx);

   if (!ctx->Extensions.ATI_envmap_bumpmap) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glGetTexBumpParameterivATI");
      return;
   }

   texUnit = _mesa_get_current_tex_unit(ctx);

   if (pname == GL_BUMP_ROT_MATRIX_SIZE_ATI) {
      /* spec leaves open to support larger matrices.
         Don't think anyone would ever want to use it
         (and apps almost certainly would not understand it and
         thus fail to submit matrices correctly) so hardcode this. */
      *param = 4;
   }
   else if (pname == GL_BUMP_ROT_MATRIX_ATI) {
      /* hope that conversion is correct here */
      param[0] = FLOAT_TO_INT(texUnit->RotMatrix[0]);
      param[1] = FLOAT_TO_INT(texUnit->RotMatrix[1]);
      param[2] = FLOAT_TO_INT(texUnit->RotMatrix[2]);
      param[3] = FLOAT_TO_INT(texUnit->RotMatrix[3]);
   }
   else if (pname == GL_BUMP_NUM_TEX_UNITS_ATI) {
      GLint count = 0;
      for (i = 0; i < ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits; i++) {
         if (ctx->Const.SupportedBumpUnits & (1 << i)) {
            count++;
         }
      }
      *param = count;
   }
   else if (pname == GL_BUMP_TEX_UNITS_ATI) {
      for (i = 0; i < ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits; i++) {
         if (ctx->Const.SupportedBumpUnits & (1 << i)) {
            *param++ = i + GL_TEXTURE0;
         }
      }
   }
   else {
      _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexBumpParameter(pname)" );
      return;
   }
}


void GLAPIENTRY
_mesa_GetTexBumpParameterfvATI( GLenum pname, GLfloat *param )
{
   const struct gl_texture_unit *texUnit;
   GLuint i;
   GET_CURRENT_CONTEXT(ctx);

   if (!ctx->Extensions.ATI_envmap_bumpmap) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glGetTexBumpParameterfvATI");
      return;
   }

   texUnit = _mesa_get_current_tex_unit(ctx);

   if (pname == GL_BUMP_ROT_MATRIX_SIZE_ATI) {
      /* spec leaves open to support larger matrices.
         Don't think anyone would ever want to use it
         (and apps might not understand it) so hardcode this. */
      *param = 4.0F;
   }
   else if (pname == GL_BUMP_ROT_MATRIX_ATI) {
      param[0] = texUnit->RotMatrix[0];
      param[1] = texUnit->RotMatrix[1];
      param[2] = texUnit->RotMatrix[2];
      param[3] = texUnit->RotMatrix[3];
   }
   else if (pname == GL_BUMP_NUM_TEX_UNITS_ATI) {
      GLint count = 0;
      for (i = 0; i < ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits; i++) {
         if (ctx->Const.SupportedBumpUnits & (1 << i)) {
            count++;
         }
      }
      *param = (GLfloat) count;
   }
   else if (pname == GL_BUMP_TEX_UNITS_ATI) {
      for (i = 0; i < ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits; i++) {
         if (ctx->Const.SupportedBumpUnits & (1 << i)) {
            *param++ = (GLfloat) (i + GL_TEXTURE0);
         }
      }
   }
   else {
      _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexBumpParameter(pname)" );
      return;
   }
}
@


