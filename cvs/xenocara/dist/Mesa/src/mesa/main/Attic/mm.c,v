head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.8
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.6
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.4
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.4
	OPENBSD_5_6:1.6.0.4
	OPENBSD_5_6_BASE:1.6
	v10_2_3:1.1.1.4
	OPENBSD_5_5:1.6.0.2
	OPENBSD_5_5_BASE:1.6
	v9_2_5:1.1.1.4
	v9_2_3:1.1.1.4
	v9_2_2:1.1.1.4
	v9_2_1:1.1.1.4
	v9_2_0:1.1.1.4
	OPENBSD_5_4:1.5.0.8
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.6
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	v7_10_3:1.1.1.3
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.6
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.4
	v7_0_1:1.1.1.2
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.12.23.05.17.52;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2013.09.05.14.06.24;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.23.13.37.42;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.31;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.41;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.21;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.50.11;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.50.11;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.56.37;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.10.23.13.29.46;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.09.05.13.16.43;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * GLX Hardware Device Driver common code
 * Copyright (C) 1999 Wittawat Yamwong
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * WITTAWAT YAMWONG, OR ANY OTHER CONTRIBUTORS BE LIABLE FOR ANY CLAIM, 
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE 
 * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>

#include "compiler.h"
#include "mm.h"


void
mmDumpMemInfo(const struct mem_block *heap)
{
   fprintf(stderr, "Memory heap %p:\n", (void *)heap);
   if (heap == 0) {
      fprintf(stderr, "  heap == 0\n");
   } else {
      const struct mem_block *p;

      for(p = heap->next; p != heap; p = p->next) {
	 fprintf(stderr, "  Offset:%08x, Size:%08x, %c%c\n",p->ofs,p->size,
		 p->free ? 'F':'.',
		 p->reserved ? 'R':'.');
      }

      fprintf(stderr, "\nFree list:\n");

      for(p = heap->next_free; p != heap; p = p->next_free) {
	 fprintf(stderr, " FREE Offset:%08x, Size:%08x, %c%c\n",p->ofs,p->size,
		 p->free ? 'F':'.',
		 p->reserved ? 'R':'.');
      }

   }
   fprintf(stderr, "End of memory blocks\n");
}

struct mem_block *
mmInit(unsigned ofs, unsigned size)
{
   struct mem_block *heap, *block;
  
   if (!size) 
      return NULL;

   heap = calloc(1, sizeof(struct mem_block));
   if (!heap) 
      return NULL;
   
   block = calloc(1, sizeof(struct mem_block));
   if (!block) {
      free(heap);
      return NULL;
   }

   heap->next = block;
   heap->prev = block;
   heap->next_free = block;
   heap->prev_free = block;

   block->heap = heap;
   block->next = heap;
   block->prev = heap;
   block->next_free = heap;
   block->prev_free = heap;

   block->ofs = ofs;
   block->size = size;
   block->free = 1;

   return heap;
}


static struct mem_block *
SliceBlock(struct mem_block *p, 
           unsigned startofs, unsigned size, 
           unsigned reserved, unsigned alignment)
{
   struct mem_block *newblock;

   /* break left  [p, newblock, p->next], then p = newblock */
   if (startofs > p->ofs) {
      newblock = calloc(1, sizeof(struct mem_block));
      if (!newblock)
	 return NULL;
      newblock->ofs = startofs;
      newblock->size = p->size - (startofs - p->ofs);
      newblock->free = 1;
      newblock->heap = p->heap;

      newblock->next = p->next;
      newblock->prev = p;
      p->next->prev = newblock;
      p->next = newblock;

      newblock->next_free = p->next_free;
      newblock->prev_free = p;
      p->next_free->prev_free = newblock;
      p->next_free = newblock;

      p->size -= newblock->size;
      p = newblock;
   }

   /* break right, also [p, newblock, p->next] */
   if (size < p->size) {
      newblock = calloc(1, sizeof(struct mem_block));
      if (!newblock)
	 return NULL;
      newblock->ofs = startofs + size;
      newblock->size = p->size - size;
      newblock->free = 1;
      newblock->heap = p->heap;

      newblock->next = p->next;
      newblock->prev = p;
      p->next->prev = newblock;
      p->next = newblock;

      newblock->next_free = p->next_free;
      newblock->prev_free = p;
      p->next_free->prev_free = newblock;
      p->next_free = newblock;
	 
      p->size = size;
   }

   /* p = middle block */
   p->free = 0;

   /* Remove p from the free list: 
    */
   p->next_free->prev_free = p->prev_free;
   p->prev_free->next_free = p->next_free;

   p->next_free = 0;
   p->prev_free = 0;

   p->reserved = reserved;
   return p;
}


struct mem_block *
mmAllocMem(struct mem_block *heap, unsigned size, unsigned align2, unsigned startSearch)
{
   struct mem_block *p;
   const unsigned mask = (1 << align2)-1;
   unsigned startofs = 0;
   unsigned endofs;

   if (!heap || !size)
      return NULL;

   for (p = heap->next_free; p != heap; p = p->next_free) {
      assert(p->free);

      startofs = (p->ofs + mask) & ~mask;
      if ( startofs < startSearch ) {
	 startofs = startSearch;
      }
      endofs = startofs+size;
      if (endofs <= (p->ofs+p->size))
	 break;
   }

   if (p == heap) 
      return NULL;

   assert(p->free);
   p = SliceBlock(p,startofs,size,0,mask+1);

   return p;
}


struct mem_block *
mmFindBlock(struct mem_block *heap, unsigned start)
{
   struct mem_block *p;

   for (p = heap->next; p != heap; p = p->next) {
      if (p->ofs == start) 
	 return p;
   }

   return NULL;
}


static inline int
Join2Blocks(struct mem_block *p)
{
   /* XXX there should be some assertions here */

   /* NOTE: heap->free == 0 */

   if (p->free && p->next->free) {
      struct mem_block *q = p->next;

      assert(p->ofs + p->size == q->ofs);
      p->size += q->size;

      p->next = q->next;
      q->next->prev = p;

      q->next_free->prev_free = q->prev_free; 
      q->prev_free->next_free = q->next_free;
     
      free(q);
      return 1;
   }
   return 0;
}

int
mmFreeMem(struct mem_block *b)
{
   if (!b)
      return 0;

   if (b->free) {
      fprintf(stderr, "block already free\n");
      return -1;
   }
   if (b->reserved) {
      fprintf(stderr, "block is reserved\n");
      return -1;
   }

   b->free = 1;
   b->next_free = b->heap->next_free;
   b->prev_free = b->heap;
   b->next_free->prev_free = b;
   b->prev_free->next_free = b;

   Join2Blocks(b);
   if (b->prev != b->heap)
      Join2Blocks(b->prev);

   return 0;
}


void
mmDestroy(struct mem_block *heap)
{
   struct mem_block *p;

   if (!heap)
      return;

   for (p = heap->next; p != heap; ) {
      struct mem_block *next = p->next;
      free(p);
      p = next;
   }

   free(heap);
}
@


1.6
log
@Merge Mesa 9.2.0
@
text
@@


1.5
log
@Merge Mesa 7.10.3
@
text
@d68 1
a68 1
   heap = (struct mem_block *) calloc(1, sizeof(struct mem_block));
d72 1
a72 1
   block = (struct mem_block *) calloc(1, sizeof(struct mem_block));
d106 1
a106 1
      newblock = (struct mem_block*) calloc(1, sizeof(struct mem_block));
d130 1
a130 1
      newblock = (struct mem_block*) calloc(1, sizeof(struct mem_block));
d214 1
a214 1
static INLINE int
@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d25 5
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d63 1
a63 1
   heap = (struct mem_block *) _mesa_calloc(sizeof(struct mem_block));
d67 1
a67 1
   block = (struct mem_block *) _mesa_calloc(sizeof(struct mem_block));
d69 1
a69 1
      _mesa_free(heap);
d101 1
a101 1
      newblock = (struct mem_block*) _mesa_calloc(sizeof(struct mem_block));
d125 1
a125 1
      newblock = (struct mem_block*) _mesa_calloc(sizeof(struct mem_block));
d228 1
a228 1
      _mesa_free(q);
d273 1
a273 1
      _mesa_free(p);
d277 1
a277 1
   _mesa_free(heap);
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d56 1
a56 1
mmInit(unsigned int ofs, int size)
d60 1
a60 1
   if (size <= 0) 
d94 2
a95 2
           unsigned int startofs, int size, 
           int reserved, int alignment)
d163 1
a163 1
mmAllocMem(struct mem_block *heap, int size, int align2, int startSearch)
d166 3
a168 3
   const int mask = (1 << align2)-1;
   unsigned int startofs = 0;
   unsigned int endofs;
d170 1
a170 1
   if (!heap || align2 < 0 || size <= 0)
d196 1
a196 1
mmFindBlock(struct mem_block *heap, int start)
@


1.1
log
@Initial revision
@
text
@d56 1
a56 1
mmInit(int ofs, int size)
d94 1
a94 1
           int startofs, int size, 
d167 2
a168 2
   int startofs = 0;
   int endofs;
a236 2
   struct mem_block *heap = b->heap;

@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d237 2
@


1.1.1.3
log
@Import Mesa 7.10.3
@
text
@a24 5
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>

#include "compiler.h"
d56 1
a56 1
mmInit(unsigned ofs, unsigned size)
d60 1
a60 1
   if (!size) 
d63 1
a63 1
   heap = (struct mem_block *) calloc(1, sizeof(struct mem_block));
d67 1
a67 1
   block = (struct mem_block *) calloc(1, sizeof(struct mem_block));
d69 1
a69 1
      free(heap);
d94 2
a95 2
           unsigned startofs, unsigned size, 
           unsigned reserved, unsigned alignment)
d101 1
a101 1
      newblock = (struct mem_block*) calloc(1, sizeof(struct mem_block));
d125 1
a125 1
      newblock = (struct mem_block*) calloc(1, sizeof(struct mem_block));
d163 1
a163 1
mmAllocMem(struct mem_block *heap, unsigned size, unsigned align2, unsigned startSearch)
d166 3
a168 3
   const unsigned mask = (1 << align2)-1;
   unsigned startofs = 0;
   unsigned endofs;
d170 1
a170 1
   if (!heap || !size)
d196 1
a196 1
mmFindBlock(struct mem_block *heap, unsigned start)
d228 1
a228 1
      free(q);
d273 1
a273 1
      free(p);
d277 1
a277 1
   free(heap);
@


1.1.1.4
log
@Import Mesa 9.2.0
@
text
@d68 1
a68 1
   heap = calloc(1, sizeof(struct mem_block));
d72 1
a72 1
   block = calloc(1, sizeof(struct mem_block));
d106 1
a106 1
      newblock = calloc(1, sizeof(struct mem_block));
d130 1
a130 1
      newblock = calloc(1, sizeof(struct mem_block));
d214 1
a214 1
static inline int
@


