head	1.11;
access;
symbols
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	v10_2_9:1.1.1.7
	v10_4_3:1.1.1.6
	v10_2_7:1.1.1.5
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	v10_2_3:1.1.1.5
	OPENBSD_5_5:1.7.0.2
	OPENBSD_5_5_BASE:1.7
	v9_2_5:1.1.1.4
	v9_2_3:1.1.1.4
	v9_2_2:1.1.1.3
	v9_2_1:1.1.1.3
	v9_2_0:1.1.1.3
	OPENBSD_5_4:1.5.0.4
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.2
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.4.0.4
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	v7_10_3:1.1.1.2
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.1.1.0.6
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.4
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.2
	v7_0_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2015.12.23.05.17.53;	author jsg;	state dead;
branches;
next	1.10;
commitid	TnlogFl9nOv2eaRf;

1.10
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.9;
commitid	4ry2gvZGMXkCUD2n;

1.9
date	2015.01.25.14.41.22;	author jsg;	state Exp;
branches;
next	1.8;
commitid	mcxB0JvoI9gTDYXU;

1.8
date	2014.07.09.21.09.00;	author jsg;	state Exp;
branches;
next	1.7;
commitid	WPD6rgPryPkvXOr9;

1.7
date	2013.11.24.06.19.52;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2013.09.05.14.06.26;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2012.08.17.13.58.19;	author mpi;	state Exp;
branches;
next	1.4;

1.4
date	2011.10.23.13.37.42;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.05.22.20.06.31;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.05.17.20.26.41;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.24.17.31.17;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.11.24.17.31.17;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2011.10.23.13.29.46;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2013.09.05.13.16.47;	author jsg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.11.24.06.02.21;	author jsg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2014.07.09.20.35.04;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.6
date	2015.01.25.14.12.51;	author jsg;	state Exp;
branches;
next	1.1.1.7;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.7
date	2015.02.20.22.49.58;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.11
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */


#include "glheader.h"
#include "context.h"
#include "enums.h"
#include "hash.h"
#include "imports.h"
#include "queryobj.h"
#include "mtypes.h"
#include "main/dispatch.h"


/**
 * Allocate a new query object.  This is a fallback routine called via
 * ctx->Driver.NewQueryObject().
 * \param ctx - rendering context
 * \param id - the new object's ID
 * \return pointer to new query_object object or NULL if out of memory.
 */
static struct gl_query_object *
_mesa_new_query_object(struct gl_context *ctx, GLuint id)
{
   struct gl_query_object *q = CALLOC_STRUCT(gl_query_object);
   (void) ctx;
   if (q) {
      q->Id = id;
      q->Result = 0;
      q->Active = GL_FALSE;

      /* This is to satisfy the language of the specification: "In the initial
       * state of a query object, the result is available" (OpenGL 3.1 ยง
       * 2.13).
       */
      q->Ready = GL_TRUE;

      /* OpenGL 3.1 ยง 2.13 says about GenQueries, "These names are marked as
       * used, but no object is associated with them until the first time they
       * are used by BeginQuery." Since our implementation actually does
       * allocate an object at this point, use a flag to indicate that this
       * object has not yet been bound so should not be considered a query.
       */
      q->EverBound = GL_FALSE;
   }
   return q;
}


/**
 * Begin a query.  Software driver fallback.
 * Called via ctx->Driver.BeginQuery().
 */
static void
_mesa_begin_query(struct gl_context *ctx, struct gl_query_object *q)
{
   ctx->NewState |= _NEW_DEPTH; /* for swrast */
}


/**
 * End a query.  Software driver fallback.
 * Called via ctx->Driver.EndQuery().
 */
static void
_mesa_end_query(struct gl_context *ctx, struct gl_query_object *q)
{
   ctx->NewState |= _NEW_DEPTH; /* for swrast */
   q->Ready = GL_TRUE;
}


/**
 * Wait for query to complete.  Software driver fallback.
 * Called via ctx->Driver.WaitQuery().
 */
static void
_mesa_wait_query(struct gl_context *ctx, struct gl_query_object *q)
{
   /* For software drivers, _mesa_end_query() should have completed the query.
    * For real hardware, implement a proper WaitQuery() driver function,
    * which may require issuing a flush.
    */
   assert(q->Ready);
}


/**
 * Check if a query results are ready.  Software driver fallback.
 * Called via ctx->Driver.CheckQuery().
 */
static void
_mesa_check_query(struct gl_context *ctx, struct gl_query_object *q)
{
   /* No-op for sw rendering.
    * HW drivers may need to flush at this time.
    */
}


/**
 * Delete a query object.  Called via ctx->Driver.DeleteQuery().
 * Not removed from hash table here.
 */
static void
_mesa_delete_query(struct gl_context *ctx, struct gl_query_object *q)
{
   free(q->Label);
   free(q);
}


void
_mesa_init_query_object_functions(struct dd_function_table *driver)
{
   driver->NewQueryObject = _mesa_new_query_object;
   driver->DeleteQuery = _mesa_delete_query;
   driver->BeginQuery = _mesa_begin_query;
   driver->EndQuery = _mesa_end_query;
   driver->WaitQuery = _mesa_wait_query;
   driver->CheckQuery = _mesa_check_query;
}


/**
 * Return pointer to the query object binding point for the given target.
 * \return NULL if invalid target, else the address of binding point
 */
static struct gl_query_object **
get_query_binding_point(struct gl_context *ctx, GLenum target)
{
   switch (target) {
   case GL_SAMPLES_PASSED_ARB:
      if (ctx->Extensions.ARB_occlusion_query)
         return &ctx->Query.CurrentOcclusionObject;
      else
         return NULL;
   case GL_ANY_SAMPLES_PASSED:
      if (ctx->Extensions.ARB_occlusion_query2)
         return &ctx->Query.CurrentOcclusionObject;
      else
         return NULL;
   case GL_ANY_SAMPLES_PASSED_CONSERVATIVE:
      if (ctx->Extensions.ARB_ES3_compatibility
          || (ctx->API == API_OPENGLES2 && ctx->Version >= 30))
         return &ctx->Query.CurrentOcclusionObject;
      else
         return NULL;
   case GL_TIME_ELAPSED_EXT:
      if (ctx->Extensions.EXT_timer_query)
         return &ctx->Query.CurrentTimerObject;
      else
         return NULL;
   case GL_PRIMITIVES_GENERATED:
      if (ctx->Extensions.EXT_transform_feedback)
         return &ctx->Query.PrimitivesGenerated;
      else
         return NULL;
   case GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN:
      if (ctx->Extensions.EXT_transform_feedback)
         return &ctx->Query.PrimitivesWritten;
      else
         return NULL;
   default:
      return NULL;
   }
}


void GLAPIENTRY
_mesa_GenQueries(GLsizei n, GLuint *ids)
{
   GLuint first;
   GET_CURRENT_CONTEXT(ctx);

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glGenQueries(%d)\n", n);

   if (n < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glGenQueriesARB(n < 0)");
      return;
   }

   first = _mesa_HashFindFreeKeyBlock(ctx->Query.QueryObjects, n);
   if (first) {
      GLsizei i;
      for (i = 0; i < n; i++) {
         struct gl_query_object *q
            = ctx->Driver.NewQueryObject(ctx, first + i);
         if (!q) {
            _mesa_error(ctx, GL_OUT_OF_MEMORY, "glGenQueriesARB");
            return;
         }
         ids[i] = first + i;
         _mesa_HashInsert(ctx->Query.QueryObjects, first + i, q);
      }
   }
}


void GLAPIENTRY
_mesa_DeleteQueries(GLsizei n, const GLuint *ids)
{
   GLint i;
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glDeleteQueries(%d)\n", n);

   if (n < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glDeleteQueriesARB(n < 0)");
      return;
   }

   for (i = 0; i < n; i++) {
      if (ids[i] > 0) {
         struct gl_query_object *q = _mesa_lookup_query_object(ctx, ids[i]);
         if (q) {
            if (q->Active) {
               struct gl_query_object **bindpt;
               bindpt = get_query_binding_point(ctx, q->Target);
               assert(bindpt); /* Should be non-null for active q. */
               if (bindpt) {
                  *bindpt = NULL;
               }
               q->Active = GL_FALSE;
               ctx->Driver.EndQuery(ctx, q);
            }
            _mesa_HashRemove(ctx->Query.QueryObjects, ids[i]);
            ctx->Driver.DeleteQuery(ctx, q);
         }
      }
   }
}


GLboolean GLAPIENTRY
_mesa_IsQuery(GLuint id)
{
   struct gl_query_object *q;

   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_WITH_RETVAL(ctx, GL_FALSE);

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glIsQuery(%u)\n", id);

   if (id == 0)
      return GL_FALSE;

   q = _mesa_lookup_query_object(ctx, id);
   if (q == NULL)
      return GL_FALSE;

   return q->EverBound;
}

static GLboolean
query_error_check_index(struct gl_context *ctx, GLenum target, GLuint index)
{
   switch (target) {
   case GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN:
   case GL_PRIMITIVES_GENERATED:
      if (index >= ctx->Const.MaxVertexStreams) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glBeginQueryIndexed(index>=MaxVertexStreams)");
         return GL_FALSE;
      }
      break;
   default:
      if (index > 0) {
         _mesa_error(ctx, GL_INVALID_VALUE, "glBeginQueryIndexed(index>0)");
         return GL_FALSE;
      }
   }
   return GL_TRUE;
}

void GLAPIENTRY
_mesa_BeginQueryIndexed(GLenum target, GLuint index, GLuint id)
{
   struct gl_query_object *q, **bindpt;
   GET_CURRENT_CONTEXT(ctx);

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glBeginQueryIndexed(%s, %u, %u)\n",
                  _mesa_lookup_enum_by_nr(target), index, id);

   if (!query_error_check_index(ctx, target, index))
      return;

   FLUSH_VERTICES(ctx, 0);

   bindpt = get_query_binding_point(ctx, target);
   if (!bindpt) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glBeginQuery{Indexed}(target)");
      return;
   }

   /* From the GL_ARB_occlusion_query spec:
    *
    *     "If BeginQueryARB is called while another query is already in
    *      progress with the same target, an INVALID_OPERATION error is
    *      generated."
    */
   if (*bindpt) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glBeginQuery{Indexed}(target=%s is active)",
                  _mesa_lookup_enum_by_nr(target));
      return;
   }

   if (id == 0) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glBeginQuery{Indexed}(id==0)");
      return;
   }

   q = _mesa_lookup_query_object(ctx, id);
   if (!q) {
      if (ctx->API != API_OPENGL_COMPAT) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glBeginQuery{Indexed}(non-gen name)");
         return;
      } else {
         /* create new object */
         q = ctx->Driver.NewQueryObject(ctx, id);
         if (!q) {
            _mesa_error(ctx, GL_OUT_OF_MEMORY, "glBeginQuery{Indexed}");
            return;
         }
         _mesa_HashInsert(ctx->Query.QueryObjects, id, q);
      }
   }
   else {
      /* pre-existing object */
      if (q->Active) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glBeginQuery{Indexed}(query already active)");
         return;
      }
   }

   q->Target = target;
   q->Active = GL_TRUE;
   q->Result = 0;
   q->Ready = GL_FALSE;
   q->EverBound = GL_TRUE;

   /* XXX should probably refcount query objects */
   *bindpt = q;

   ctx->Driver.BeginQuery(ctx, q);
}


void GLAPIENTRY
_mesa_EndQueryIndexed(GLenum target, GLuint index)
{
   struct gl_query_object *q, **bindpt;
   GET_CURRENT_CONTEXT(ctx);

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glEndQueryIndexed(%s, %u)\n",
                  _mesa_lookup_enum_by_nr(target), index);

   if (!query_error_check_index(ctx, target, index))
      return;

   FLUSH_VERTICES(ctx, 0);

   bindpt = get_query_binding_point(ctx, target);
   if (!bindpt) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glEndQuery{Indexed}(target)");
      return;
   }

   /* XXX should probably refcount query objects */
   q = *bindpt;

   /* Check for GL_ANY_SAMPLES_PASSED vs GL_SAMPLES_PASSED. */
   if (q && q->Target != target) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glEndQuery(target=%s with active query of target %s)",
                  _mesa_lookup_enum_by_nr(target),
                  _mesa_lookup_enum_by_nr(q->Target));
      return;
   }

   *bindpt = NULL;

   if (!q || !q->Active) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glEndQuery{Indexed}(no matching glBeginQuery{Indexed})");
      return;
   }

   q->Active = GL_FALSE;
   ctx->Driver.EndQuery(ctx, q);
}

void GLAPIENTRY
_mesa_BeginQuery(GLenum target, GLuint id)
{
   _mesa_BeginQueryIndexed(target, 0, id);
}

void GLAPIENTRY
_mesa_EndQuery(GLenum target)
{
   _mesa_EndQueryIndexed(target, 0);
}

void GLAPIENTRY
_mesa_QueryCounter(GLuint id, GLenum target)
{
   struct gl_query_object *q;
   GET_CURRENT_CONTEXT(ctx);

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glQueryCounter(%u, %s)\n", id,
                  _mesa_lookup_enum_by_nr(target));

   /* error checking */
   if (target != GL_TIMESTAMP) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glQueryCounter(target)");
      return;
   }

   if (id == 0) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glQueryCounter(id==0)");
      return;
   }

   q = _mesa_lookup_query_object(ctx, id);
   if (!q) {
      /* XXX the Core profile should throw INVALID_OPERATION here */

      /* create new object */
      q = ctx->Driver.NewQueryObject(ctx, id);
      if (!q) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glQueryCounter");
         return;
      }
      _mesa_HashInsert(ctx->Query.QueryObjects, id, q);
   }
   else {
      if (q->Target && q->Target != GL_TIMESTAMP) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glQueryCounter(id has an invalid target)");
         return;
      }
   }

   if (q->Active) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glQueryCounter(id is active)");
      return;
   }

   q->Target = target;
   q->Result = 0;
   q->Ready = GL_FALSE;
   q->EverBound = GL_TRUE;

   if (ctx->Driver.QueryCounter) {
      ctx->Driver.QueryCounter(ctx, q);
   } else {
      /* QueryCounter is implemented using EndQuery without BeginQuery
       * in drivers. This is actually Direct3D and Gallium convention.
       */
      ctx->Driver.EndQuery(ctx, q);
   }
}


void GLAPIENTRY
_mesa_GetQueryIndexediv(GLenum target, GLuint index, GLenum pname,
                        GLint *params)
{
   struct gl_query_object *q = NULL, **bindpt = NULL;
   GET_CURRENT_CONTEXT(ctx);

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glGetQueryIndexediv(%s, %u, %s)\n",
                  _mesa_lookup_enum_by_nr(target),
                  index,
                  _mesa_lookup_enum_by_nr(pname));

   if (!query_error_check_index(ctx, target, index))
      return;

   if (target == GL_TIMESTAMP) {
      if (!ctx->Extensions.ARB_timer_query) {
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetQueryARB(target)");
         return;
      }
   }
   else {
      bindpt = get_query_binding_point(ctx, target);
      if (!bindpt) {
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetQuery{Indexed}iv(target)");
         return;
      }

      q = *bindpt;
   }

   switch (pname) {
      case GL_QUERY_COUNTER_BITS_ARB:
         switch (target) {
         case GL_SAMPLES_PASSED:
            *params = ctx->Const.QueryCounterBits.SamplesPassed;
            break;
         case GL_ANY_SAMPLES_PASSED:
            /* The minimum value of this is 1 if it's nonzero, and the value
             * is only ever GL_TRUE or GL_FALSE, so no sense in reporting more
             * bits.
             */
            *params = 1;
            break;
         case GL_TIME_ELAPSED:
            *params = ctx->Const.QueryCounterBits.TimeElapsed;
            break;
         case GL_TIMESTAMP:
            *params = ctx->Const.QueryCounterBits.Timestamp;
            break;
         case GL_PRIMITIVES_GENERATED:
            *params = ctx->Const.QueryCounterBits.PrimitivesGenerated;
            break;
         case GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN:
            *params = ctx->Const.QueryCounterBits.PrimitivesWritten;
            break;
         default:
            _mesa_problem(ctx,
                          "Unknown target in glGetQueryIndexediv(target = %s)",
                          _mesa_lookup_enum_by_nr(target));
            *params = 0;
            break;
         }
         break;
      case GL_CURRENT_QUERY_ARB:
         *params = (q && q->Target == target) ? q->Id : 0;
         break;
      default:
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetQuery{Indexed}iv(pname)");
         return;
   }
}

void GLAPIENTRY
_mesa_GetQueryiv(GLenum target, GLenum pname, GLint *params)
{
   _mesa_GetQueryIndexediv(target, 0, pname, params);
}

void GLAPIENTRY
_mesa_GetQueryObjectiv(GLuint id, GLenum pname, GLint *params)
{
   struct gl_query_object *q = NULL;
   GET_CURRENT_CONTEXT(ctx);

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glGetQueryObjectiv(%u, %s)\n", id,
                  _mesa_lookup_enum_by_nr(pname));

   if (id)
      q = _mesa_lookup_query_object(ctx, id);

   if (!q || q->Active) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glGetQueryObjectivARB(id=%d is invalid or active)", id);
      return;
   }

   switch (pname) {
      case GL_QUERY_RESULT_ARB:
         if (!q->Ready)
            ctx->Driver.WaitQuery(ctx, q);
         /* if result is too large for returned type, clamp to max value */
         if (q->Target == GL_ANY_SAMPLES_PASSED
             || q->Target == GL_ANY_SAMPLES_PASSED_CONSERVATIVE) {
            if (q->Result)
               *params = GL_TRUE;
            else
               *params = GL_FALSE;
         } else {
            if (q->Result > 0x7fffffff) {
               *params = 0x7fffffff;
            }
            else {
               *params = (GLint)q->Result;
            }
         }
         break;
      case GL_QUERY_RESULT_AVAILABLE_ARB:
	 if (!q->Ready)
	    ctx->Driver.CheckQuery( ctx, q );
         *params = q->Ready;
         break;
      default:
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetQueryObjectivARB(pname)");
         return;
   }
}


void GLAPIENTRY
_mesa_GetQueryObjectuiv(GLuint id, GLenum pname, GLuint *params)
{
   struct gl_query_object *q = NULL;
   GET_CURRENT_CONTEXT(ctx);

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glGetQueryObjectuiv(%u, %s)\n", id,
                  _mesa_lookup_enum_by_nr(pname));

   if (id)
      q = _mesa_lookup_query_object(ctx, id);

   if (!q || q->Active) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glGetQueryObjectuivARB(id=%d is invalid or active)", id);
      return;
   }

   switch (pname) {
      case GL_QUERY_RESULT_ARB:
         if (!q->Ready)
            ctx->Driver.WaitQuery(ctx, q);
         /* if result is too large for returned type, clamp to max value */
         if (q->Target == GL_ANY_SAMPLES_PASSED
             || q->Target == GL_ANY_SAMPLES_PASSED_CONSERVATIVE) {
            if (q->Result)
               *params = GL_TRUE;
            else
               *params = GL_FALSE;
         } else {
            if (q->Result > 0xffffffff) {
               *params = 0xffffffff;
            }
            else {
               *params = (GLuint)q->Result;
            }
         }
         break;
      case GL_QUERY_RESULT_AVAILABLE_ARB:
	 if (!q->Ready)
	    ctx->Driver.CheckQuery( ctx, q );
         *params = q->Ready;
         break;
      default:
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetQueryObjectuivARB(pname)");
         return;
   }
}


/**
 * New with GL_EXT_timer_query
 */
void GLAPIENTRY
_mesa_GetQueryObjecti64v(GLuint id, GLenum pname, GLint64EXT *params)
{
   struct gl_query_object *q = NULL;
   GET_CURRENT_CONTEXT(ctx);

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glGetQueryObjecti64v(%u, %s)\n", id,
                  _mesa_lookup_enum_by_nr(pname));

   if (id)
      q = _mesa_lookup_query_object(ctx, id);

   if (!q || q->Active) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glGetQueryObjectui64vARB(id=%d is invalid or active)", id);
      return;
   }

   switch (pname) {
      case GL_QUERY_RESULT_ARB:
         if (!q->Ready)
            ctx->Driver.WaitQuery(ctx, q);
         *params = q->Result;
         break;
      case GL_QUERY_RESULT_AVAILABLE_ARB:
	 if (!q->Ready)
	    ctx->Driver.CheckQuery( ctx, q );
         *params = q->Ready;
         break;
      default:
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetQueryObjecti64vARB(pname)");
         return;
   }
}


/**
 * New with GL_EXT_timer_query
 */
void GLAPIENTRY
_mesa_GetQueryObjectui64v(GLuint id, GLenum pname, GLuint64EXT *params)
{
   struct gl_query_object *q = NULL;
   GET_CURRENT_CONTEXT(ctx);

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glGetQueryObjectui64v(%u, %s)\n", id,
                  _mesa_lookup_enum_by_nr(pname));

   if (id)
      q = _mesa_lookup_query_object(ctx, id);

   if (!q || q->Active) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glGetQueryObjectuui64vARB(id=%d is invalid or active)", id);
      return;
   }

   switch (pname) {
      case GL_QUERY_RESULT_ARB:
         if (!q->Ready)
            ctx->Driver.WaitQuery(ctx, q);
         *params = q->Result;
         break;
      case GL_QUERY_RESULT_AVAILABLE_ARB:
	 if (!q->Ready)
	    ctx->Driver.CheckQuery( ctx, q );
         *params = q->Ready;
         break;
      default:
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetQueryObjectui64vARB(pname)");
         return;
   }
}

/**
 * Allocate/init the context state related to query objects.
 */
void
_mesa_init_queryobj(struct gl_context *ctx)
{
   ctx->Query.QueryObjects = _mesa_NewHashTable();
   ctx->Query.CurrentOcclusionObject = NULL;

   ctx->Const.QueryCounterBits.SamplesPassed = 64;
   ctx->Const.QueryCounterBits.TimeElapsed = 64;
   ctx->Const.QueryCounterBits.Timestamp = 64;
   ctx->Const.QueryCounterBits.PrimitivesGenerated = 64;
   ctx->Const.QueryCounterBits.PrimitivesWritten = 64;
}


/**
 * Callback for deleting a query object.  Called by _mesa_HashDeleteAll().
 */
static void
delete_queryobj_cb(GLuint id, void *data, void *userData)
{
   struct gl_query_object *q= (struct gl_query_object *) data;
   struct gl_context *ctx = (struct gl_context *)userData;
   ctx->Driver.DeleteQuery(ctx, q);
}


/**
 * Free the context state related to query objects.
 */
void
_mesa_free_queryobj_data(struct gl_context *ctx)
{
   _mesa_HashDeleteAll(ctx->Query.QueryObjects, delete_queryobj_cb, ctx);
   _mesa_DeleteHashTable(ctx->Query.QueryObjects);
}
@


1.10
log
@Merge Mesa 10.2.9
@
text
@@


1.9
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d147 1
a147 2
 * Return pointer to the query object binding point for the given target and
 * index.
d151 1
a151 1
get_query_binding_point(struct gl_context *ctx, GLenum target, GLuint index)
d177 1
a177 1
         return &ctx->Query.PrimitivesGenerated[index];
d182 1
a182 1
         return &ctx->Query.PrimitivesWritten[index];
d243 1
a243 1
               bindpt = get_query_binding_point(ctx, q->Target, q->Stream);
d316 1
a316 1
   bindpt = get_query_binding_point(ctx, target, index);
a369 1
   q->Stream = index;
d393 1
a393 1
   bindpt = get_query_binding_point(ctx, target, index);
d520 1
a520 1
      bindpt = get_query_binding_point(ctx, target, index);
@


1.8
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d147 2
a148 1
 * Return pointer to the query object binding point for the given target.
d152 1
a152 1
get_query_binding_point(struct gl_context *ctx, GLenum target)
d178 1
a178 1
         return &ctx->Query.PrimitivesGenerated;
d183 1
a183 1
         return &ctx->Query.PrimitivesWritten;
d244 1
a244 1
               bindpt = get_query_binding_point(ctx, q->Target);
d317 1
a317 1
   bindpt = get_query_binding_point(ctx, target);
d371 1
d395 1
a395 1
   bindpt = get_query_binding_point(ctx, target);
d522 1
a522 1
      bindpt = get_query_binding_point(ctx, target);
@


1.7
log
@Merge Mesa 9.2.3
ok mpi@@ kettenis@@
@
text
@d46 1
a46 1
   struct gl_query_object *q = MALLOC_STRUCT(gl_query_object);
d129 1
@


1.6
log
@Merge Mesa 9.2.0
@
text
@a203 7
   /* No query objects can be active at this time! */
   if (ctx->Query.CurrentOcclusionObject ||
       ctx->Query.CurrentTimerObject) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glGenQueriesARB");
      return;
   }

a235 7
   /* No query objects can be active at this time! */
   if (ctx->Query.CurrentOcclusionObject ||
       ctx->Query.CurrentTimerObject) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glDeleteQueriesARB");
      return;
   }

d240 10
a249 1
            ASSERT(!q->Active); /* should be caught earlier */
@


1.5
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a2 1
 * Version:  7.1
d19 4
a22 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
a31 1
#include "mfeatures.h"
a35 3
#if FEATURE_queryobj


d52 14
a65 1
      q->Ready = GL_TRUE;   /* correct, see spec */
d78 1
a78 1
   /* no-op */
d89 1
d163 6
a173 1
#if FEATURE_EXT_transform_feedback
a183 1
#endif
d190 2
a191 2
static void GLAPIENTRY
_mesa_GenQueriesARB(GLsizei n, GLuint *ids)
a194 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d228 2
a229 2
static void GLAPIENTRY
_mesa_DeleteQueriesARB(GLsizei n, const GLuint *ids)
a232 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d236 1
a236 1
      _mesa_debug(ctx, "glDeleeteQueries(%d)\n", n);
d263 2
a264 2
static GLboolean GLAPIENTRY
_mesa_IsQueryARB(GLuint id)
d266 2
d274 1
a274 3
   if (id && _mesa_lookup_query_object(ctx, id))
      return GL_TRUE;
   else
d276 6
d284 20
d305 2
a306 2
static void GLAPIENTRY
_mesa_BeginQueryARB(GLenum target, GLuint id)
a309 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d312 5
a316 2
      _mesa_debug(ctx, "glBeginQuery(%s, %u)\n",
                  _mesa_lookup_enum_by_nr(target), id);
d318 1
a318 1
   FLUSH_VERTICES(ctx, _NEW_DEPTH);
d322 14
a335 1
      _mesa_error(ctx, GL_INVALID_ENUM, "glBeginQueryARB(target)");
d340 1
a340 1
      _mesa_error(ctx, GL_INVALID_OPERATION, "glBeginQueryARB(id==0)");
d346 3
a348 4
      /* create new object */
      q = ctx->Driver.NewQueryObject(ctx, id);
      if (!q) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glBeginQueryARB");
d350 8
a358 1
      _mesa_HashInsert(ctx->Query.QueryObjects, id, q);
d364 1
a364 1
                     "glBeginQueryARB(query already active)");
d373 1
d382 2
a383 2
static void GLAPIENTRY
_mesa_EndQueryARB(GLenum target)
a386 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d389 2
a390 1
      _mesa_debug(ctx, "glEndQuery(%s)\n", _mesa_lookup_enum_by_nr(target));
d392 4
a395 1
   FLUSH_VERTICES(ctx, _NEW_DEPTH);
d399 1
a399 1
      _mesa_error(ctx, GL_INVALID_ENUM, "glEndQueryARB(target)");
d405 10
d419 1
a419 1
                  "glEndQueryARB(no matching glBeginQueryARB)");
d427 11
d439 2
a440 2
static void GLAPIENTRY
_mesa_GetQueryivARB(GLenum target, GLenum pname, GLint *params)
d442 64
a505 1
   struct gl_query_object *q, **bindpt;
a506 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d509 1
a509 1
      _mesa_debug(ctx, "glGetQueryiv(%s, %s)\n",
d511 1
d514 1
a514 3
   bindpt = get_query_binding_point(ctx, target);
   if (!bindpt) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetQueryARB(target)");
d516 6
d523 6
d530 2
a531 1
   q = *bindpt;
d535 30
a564 1
         *params = 8 * sizeof(q->Result);
d567 1
a567 1
         *params = q ? q->Id : 0;
d570 1
a570 1
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetQueryivARB(pname)");
d575 5
d581 2
a582 2
static void GLAPIENTRY
_mesa_GetQueryObjectivARB(GLuint id, GLenum pname, GLint *params)
a585 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d605 2
a606 1
         if (q->Target == GL_ANY_SAMPLES_PASSED) {
d632 2
a633 2
static void GLAPIENTRY
_mesa_GetQueryObjectuivARB(GLuint id, GLenum pname, GLuint *params)
a636 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d656 2
a657 1
         if (q->Target == GL_ANY_SAMPLES_PASSED) {
d686 2
a687 2
static void GLAPIENTRY
_mesa_GetQueryObjecti64vEXT(GLuint id, GLenum pname, GLint64EXT *params)
a690 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d726 2
a727 2
static void GLAPIENTRY
_mesa_GetQueryObjectui64vEXT(GLuint id, GLenum pname, GLuint64EXT *params)
a730 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
a761 21

void
_mesa_init_queryobj_dispatch(struct _glapi_table *disp)
{
   SET_GenQueriesARB(disp, _mesa_GenQueriesARB);
   SET_DeleteQueriesARB(disp, _mesa_DeleteQueriesARB);
   SET_IsQueryARB(disp, _mesa_IsQueryARB);
   SET_BeginQueryARB(disp, _mesa_BeginQueryARB);
   SET_EndQueryARB(disp, _mesa_EndQueryARB);
   SET_GetQueryivARB(disp, _mesa_GetQueryivARB);
   SET_GetQueryObjectivARB(disp, _mesa_GetQueryObjectivARB);
   SET_GetQueryObjectuivARB(disp, _mesa_GetQueryObjectuivARB);

   SET_GetQueryObjecti64vEXT(disp, _mesa_GetQueryObjecti64vEXT);
   SET_GetQueryObjectui64vEXT(disp, _mesa_GetQueryObjectui64vEXT);
}


#endif /* FEATURE_queryobj */


d770 6
@


1.4
log
@Merge Mesa 7.10.3
@
text
@d28 1
d32 1
d148 5
d176 1
a176 1
void GLAPIENTRY
d183 3
d215 1
a215 1
void GLAPIENTRY
d221 4
d251 1
a251 1
GLboolean GLAPIENTRY
d257 3
d274 4
d329 3
d355 1
a355 1
void GLAPIENTRY
d362 5
d389 1
a389 1
void GLAPIENTRY
d396 4
d414 12
a425 5
         if (q->Result > 0x7fffffff) {
            *params = 0x7fffffff;
         }
         else {
            *params = (GLint)q->Result;
d440 1
a440 1
void GLAPIENTRY
d447 4
d465 12
a476 5
         if (q->Result > 0xffffffff) {
            *params = 0xffffffff;
         }
         else {
            *params = (GLuint)q->Result;
d501 4
d541 4
@


1.3
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d46 1
a46 1
_mesa_new_query_object(GLcontext *ctx, GLuint id)
d65 1
a65 1
_mesa_begin_query(GLcontext *ctx, struct gl_query_object *q)
d76 1
a76 1
_mesa_end_query(GLcontext *ctx, struct gl_query_object *q)
d87 1
a87 1
_mesa_wait_query(GLcontext *ctx, struct gl_query_object *q)
d102 1
a102 1
_mesa_check_query(GLcontext *ctx, struct gl_query_object *q)
d115 1
a115 1
_mesa_delete_query(GLcontext *ctx, struct gl_query_object *q)
d133 36
d253 1
a253 1
   struct gl_query_object *q;
d259 4
a262 24
   switch (target) {
      case GL_SAMPLES_PASSED_ARB:
         if (!ctx->Extensions.ARB_occlusion_query) {
            _mesa_error(ctx, GL_INVALID_ENUM, "glBeginQueryARB(target)");
            return;
         }
         if (ctx->Query.CurrentOcclusionObject) {
            _mesa_error(ctx, GL_INVALID_OPERATION, "glBeginQueryARB");
            return;
         }
         break;
      case GL_TIME_ELAPSED_EXT:
         if (!ctx->Extensions.EXT_timer_query) {
            _mesa_error(ctx, GL_INVALID_ENUM, "glBeginQueryARB(target)");
            return;
         }
         if (ctx->Query.CurrentTimerObject) {
            _mesa_error(ctx, GL_INVALID_OPERATION, "glBeginQueryARB");
            return;
         }
         break;
      default:
         _mesa_error(ctx, GL_INVALID_ENUM, "glBeginQueryARB(target)");
         return;
d294 2
a295 6
   if (target == GL_SAMPLES_PASSED_ARB) {
      ctx->Query.CurrentOcclusionObject = q;
   }
   else if (target == GL_TIME_ELAPSED_EXT) {
      ctx->Query.CurrentTimerObject = q;
   }
d304 1
a304 1
   struct gl_query_object *q;
d310 4
a313 20
   switch (target) {
      case GL_SAMPLES_PASSED_ARB:
         if (!ctx->Extensions.ARB_occlusion_query) {
            _mesa_error(ctx, GL_INVALID_ENUM, "glEndQueryARB(target)");
            return;
         }
         q = ctx->Query.CurrentOcclusionObject;
         ctx->Query.CurrentOcclusionObject = NULL;
         break;
      case GL_TIME_ELAPSED_EXT:
         if (!ctx->Extensions.EXT_timer_query) {
            _mesa_error(ctx, GL_INVALID_ENUM, "glEndQueryARB(target)");
            return;
         }
         q = ctx->Query.CurrentTimerObject;
         ctx->Query.CurrentTimerObject = NULL;
         break;
      default:
         _mesa_error(ctx, GL_INVALID_ENUM, "glEndQueryARB(target)");
         return;
d316 4
d334 1
a334 1
   struct gl_query_object *q;
d338 4
a341 18
   switch (target) {
      case GL_SAMPLES_PASSED_ARB:
         if (!ctx->Extensions.ARB_occlusion_query) {
            _mesa_error(ctx, GL_INVALID_ENUM, "glEndQueryARB(target)");
            return;
         }
         q = ctx->Query.CurrentOcclusionObject;
         break;
      case GL_TIME_ELAPSED_EXT:
         if (!ctx->Extensions.EXT_timer_query) {
            _mesa_error(ctx, GL_INVALID_ENUM, "glEndQueryARB(target)");
            return;
         }
         q = ctx->Query.CurrentTimerObject;
         break;
      default:
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetQueryivARB(target)");
         return;
d344 2
d538 1
a538 1
_mesa_init_queryobj(GLcontext *ctx)
d552 1
a552 1
   GLcontext *ctx = (GLcontext *)userData;
d561 1
a561 1
_mesa_free_queryobj_data(GLcontext *ctx)
@


1.2
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d32 4
d45 1
a45 1
struct gl_query_object *
d64 1
a64 1
void
d75 1
a75 1
void
d86 1
a86 1
void
d90 2
a91 1
    * For real hardware, implement a proper WaitQuery() driver function.
d98 13
d114 1
a114 1
void
d117 1
a117 1
   _mesa_free(q);
d121 2
a122 2
static struct gl_query_object *
lookup_query_object(GLcontext *ctx, GLuint id)
d124 6
a129 2
   return (struct gl_query_object *)
      _mesa_HashLookup(ctx->Query.QueryObjects, id);
a132 1

d190 1
a190 1
         struct gl_query_object *q = lookup_query_object(ctx, ids[i]);
d207 1
a207 1
   if (id && lookup_query_object(ctx, id))
d214 1
a214 1
void GLAPIENTRY
a233 1
#if FEATURE_EXT_timer_query
a243 1
#endif
d254 1
a254 1
   q = lookup_query_object(ctx, id);
a280 1
#if FEATURE_EXT_timer_query
a283 1
#endif
d289 1
a289 1
void GLAPIENTRY
a306 1
#if FEATURE_EXT_timer_query
a314 1
#endif
a345 1
#if FEATURE_EXT_timer_query
a352 1
#endif
d380 1
a380 1
      q = lookup_query_object(ctx, id);
d420 1
a420 1
      q = lookup_query_object(ctx, id);
a451 2
#if FEATURE_EXT_timer_query

d455 1
a455 1
void GLAPIENTRY
d463 1
a463 1
      q = lookup_query_object(ctx, id);
d492 1
a492 1
void GLAPIENTRY
d500 1
a500 1
      q = lookup_query_object(ctx, id);
d525 19
a543 1
#endif /* FEATURE_EXT_timer_query */
d550 1
a550 1
_mesa_init_query(GLcontext *ctx)
a551 1
#if FEATURE_ARB_occlusion_query
a553 1
#endif
d573 1
a573 1
_mesa_free_query_data(GLcontext *ctx)
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * Version:  6.5.1
d5 1
a5 1
 * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
d57 37
a93 1
 * Delete an occlusion query object.
a94 1
 * XXX maybe add Delete() method to gl_query_object class and call that instead
d96 2
a97 2
static void
delete_query_object(struct gl_query_object *q)
d99 1
a99 1
   FREE(q);
d173 1
a173 1
            delete_query_object(q);
d254 1
d268 1
a268 3
   if (ctx->Driver.BeginQuery) {
      ctx->Driver.BeginQuery(ctx, target, q);
   }
d312 1
a312 7
   if (ctx->Driver.EndQuery) {
      ctx->Driver.EndQuery(ctx, target, q);
   }
   else {
      /* if we're using software rendering/querying */
      q->Ready = GL_TRUE;
   }
d377 2
a378 7
         while (!q->Ready) {
            /* Wait for the query to finish! */
            /* If using software rendering, the result will always be ready
             * by time we get here.  Otherwise, we must be using hardware!
             */
            ASSERT(ctx->Driver.EndQuery);
         }
d384 1
a384 1
            *params = q->Result;
d388 2
a389 1
         /* XXX revisit when we have a hardware implementation! */
d417 2
a418 7
         while (!q->Ready) {
            /* Wait for the query to finish! */
            /* If using software rendering, the result will always be ready
             * by time we get here.  Otherwise, we must be using hardware!
             */
            ASSERT(ctx->Driver.EndQuery);
         }
d424 1
a424 1
            *params = q->Result;
d428 2
a429 1
         /* XXX revisit when we have a hardware implementation! */
d462 2
a463 7
         while (!q->Ready) {
            /* Wait for the query to finish! */
            /* If using software rendering, the result will always be ready
             * by time we get here.  Otherwise, we must be using hardware!
             */
            ASSERT(ctx->Driver.EndQuery);
         }
d467 2
a468 1
         /* XXX revisit when we have a hardware implementation! */
d499 2
a500 7
         while (!q->Ready) {
            /* Wait for the query to finish! */
            /* If using software rendering, the result will always be ready
             * by time we get here.  Otherwise, we must be using hardware!
             */
            ASSERT(ctx->Driver.EndQuery);
         }
d504 2
a505 1
         /* XXX revisit when we have a hardware implementation! */
d537 2
a538 2
   (void) userData;
   delete_query_object(q);
d548 1
a548 1
   _mesa_HashDeleteAll(ctx->Query.QueryObjects, delete_queryobj_cb, NULL);
@


1.1.1.1
log
@Mesa 7.0.1
@
text
@@


1.1.1.2
log
@Import Mesa 7.10.3
@
text
@d3 1
a3 1
 * Version:  7.1
d5 1
a5 1
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
a31 4
#include "main/dispatch.h"


#if FEATURE_queryobj
d41 2
a42 2
static struct gl_query_object *
_mesa_new_query_object(struct gl_context *ctx, GLuint id)
d57 1
a57 51
 * Begin a query.  Software driver fallback.
 * Called via ctx->Driver.BeginQuery().
 */
static void
_mesa_begin_query(struct gl_context *ctx, struct gl_query_object *q)
{
   /* no-op */
}


/**
 * End a query.  Software driver fallback.
 * Called via ctx->Driver.EndQuery().
 */
static void
_mesa_end_query(struct gl_context *ctx, struct gl_query_object *q)
{
   q->Ready = GL_TRUE;
}


/**
 * Wait for query to complete.  Software driver fallback.
 * Called via ctx->Driver.WaitQuery().
 */
static void
_mesa_wait_query(struct gl_context *ctx, struct gl_query_object *q)
{
   /* For software drivers, _mesa_end_query() should have completed the query.
    * For real hardware, implement a proper WaitQuery() driver function,
    * which may require issuing a flush.
    */
   assert(q->Ready);
}


/**
 * Check if a query results are ready.  Software driver fallback.
 * Called via ctx->Driver.CheckQuery().
 */
static void
_mesa_check_query(struct gl_context *ctx, struct gl_query_object *q)
{
   /* No-op for sw rendering.
    * HW drivers may need to flush at this time.
    */
}


/**
 * Delete a query object.  Called via ctx->Driver.DeleteQuery().
d59 1
d62 1
a62 1
_mesa_delete_query(struct gl_context *ctx, struct gl_query_object *q)
d64 1
a64 1
   free(q);
d68 2
a69 2
void
_mesa_init_query_object_functions(struct dd_function_table *driver)
d71 2
a72 6
   driver->NewQueryObject = _mesa_new_query_object;
   driver->DeleteQuery = _mesa_delete_query;
   driver->BeginQuery = _mesa_begin_query;
   driver->EndQuery = _mesa_end_query;
   driver->WaitQuery = _mesa_wait_query;
   driver->CheckQuery = _mesa_check_query;
a75 35
/**
 * Return pointer to the query object binding point for the given target.
 * \return NULL if invalid target, else the address of binding point
 */
static struct gl_query_object **
get_query_binding_point(struct gl_context *ctx, GLenum target)
{
   switch (target) {
   case GL_SAMPLES_PASSED_ARB:
      if (ctx->Extensions.ARB_occlusion_query)
         return &ctx->Query.CurrentOcclusionObject;
      else
         return NULL;
   case GL_TIME_ELAPSED_EXT:
      if (ctx->Extensions.EXT_timer_query)
         return &ctx->Query.CurrentTimerObject;
      else
         return NULL;
#if FEATURE_EXT_transform_feedback
   case GL_PRIMITIVES_GENERATED:
      if (ctx->Extensions.EXT_transform_feedback)
         return &ctx->Query.PrimitivesGenerated;
      else
         return NULL;
   case GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN:
      if (ctx->Extensions.EXT_transform_feedback)
         return &ctx->Query.PrimitivesWritten;
      else
         return NULL;
#endif
   default:
      return NULL;
   }
}

d134 1
a134 1
         struct gl_query_object *q = _mesa_lookup_query_object(ctx, ids[i]);
d138 1
a138 1
            ctx->Driver.DeleteQuery(ctx, q);
d151 1
a151 1
   if (id && _mesa_lookup_query_object(ctx, id))
d158 1
a158 1
static void GLAPIENTRY
d161 1
a161 1
   struct gl_query_object *q, **bindpt;
d167 26
a192 4
   bindpt = get_query_binding_point(ctx, target);
   if (!bindpt) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glBeginQueryARB(target)");
      return;
d200 1
a200 1
   q = _mesa_lookup_query_object(ctx, id);
a218 1
   q->Target = target;
d223 8
a230 2
   /* XXX should probably refcount query objects */
   *bindpt = q;
d232 3
a234 1
   ctx->Driver.BeginQuery(ctx, q);
d238 1
a238 1
static void GLAPIENTRY
d241 1
a241 1
   struct gl_query_object *q, **bindpt;
d247 22
a268 4
   bindpt = get_query_binding_point(ctx, target);
   if (!bindpt) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glEndQueryARB(target)");
      return;
a270 4
   /* XXX should probably refcount query objects */
   q = *bindpt;
   *bindpt = NULL;

d278 7
a284 1
   ctx->Driver.EndQuery(ctx, q);
d291 1
a291 1
   struct gl_query_object *q, **bindpt;
d295 20
a314 4
   bindpt = get_query_binding_point(ctx, target);
   if (!bindpt) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetQueryARB(target)");
      return;
a316 2
   q = *bindpt;

d339 1
a339 1
      q = _mesa_lookup_query_object(ctx, id);
d349 7
a355 2
         if (!q->Ready)
            ctx->Driver.WaitQuery(ctx, q);
d361 1
a361 1
            *params = (GLint)q->Result;
d365 1
a365 2
	 if (!q->Ready)
	    ctx->Driver.CheckQuery( ctx, q );
d383 1
a383 1
      q = _mesa_lookup_query_object(ctx, id);
d393 7
a399 2
         if (!q->Ready)
            ctx->Driver.WaitQuery(ctx, q);
d405 1
a405 1
            *params = (GLuint)q->Result;
d409 1
a409 2
	 if (!q->Ready)
	    ctx->Driver.CheckQuery( ctx, q );
d419 2
d424 1
a424 1
static void GLAPIENTRY
d432 1
a432 1
      q = _mesa_lookup_query_object(ctx, id);
d442 7
a448 2
         if (!q->Ready)
            ctx->Driver.WaitQuery(ctx, q);
d452 1
a452 2
	 if (!q->Ready)
	    ctx->Driver.CheckQuery( ctx, q );
d465 1
a465 1
static void GLAPIENTRY
d473 1
a473 1
      q = _mesa_lookup_query_object(ctx, id);
d483 7
a489 2
         if (!q->Ready)
            ctx->Driver.WaitQuery(ctx, q);
d493 1
a493 2
	 if (!q->Ready)
	    ctx->Driver.CheckQuery( ctx, q );
d502 1
a502 19

void
_mesa_init_queryobj_dispatch(struct _glapi_table *disp)
{
   SET_GenQueriesARB(disp, _mesa_GenQueriesARB);
   SET_DeleteQueriesARB(disp, _mesa_DeleteQueriesARB);
   SET_IsQueryARB(disp, _mesa_IsQueryARB);
   SET_BeginQueryARB(disp, _mesa_BeginQueryARB);
   SET_EndQueryARB(disp, _mesa_EndQueryARB);
   SET_GetQueryivARB(disp, _mesa_GetQueryivARB);
   SET_GetQueryObjectivARB(disp, _mesa_GetQueryObjectivARB);
   SET_GetQueryObjectuivARB(disp, _mesa_GetQueryObjectuivARB);

   SET_GetQueryObjecti64vEXT(disp, _mesa_GetQueryObjecti64vEXT);
   SET_GetQueryObjectui64vEXT(disp, _mesa_GetQueryObjectui64vEXT);
}


#endif /* FEATURE_queryobj */
d509 1
a509 1
_mesa_init_queryobj(struct gl_context *ctx)
d511 1
d514 1
d525 2
a526 2
   struct gl_context *ctx = (struct gl_context *)userData;
   ctx->Driver.DeleteQuery(ctx, q);
d534 1
a534 1
_mesa_free_queryobj_data(struct gl_context *ctx)
d536 1
a536 1
   _mesa_HashDeleteAll(ctx->Query.QueryObjects, delete_queryobj_cb, ctx);
@


1.1.1.3
log
@Import Mesa 9.2.0
@
text
@d3 1
d20 3
a22 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
a27 1
#include "enums.h"
d35 3
d54 1
a54 14

      /* This is to satisfy the language of the specification: "In the initial
       * state of a query object, the result is available" (OpenGL 3.1 ยง
       * 2.13).
       */
      q->Ready = GL_TRUE;

      /* OpenGL 3.1 ยง 2.13 says about GenQueries, "These names are marked as
       * used, but no object is associated with them until the first time they
       * are used by BeginQuery." Since our implementation actually does
       * allocate an object at this point, use a flag to indicate that this
       * object has not yet been bound so should not be considered a query.
       */
      q->EverBound = GL_FALSE;
d67 1
a67 1
   ctx->NewState |= _NEW_DEPTH; /* for swrast */
a77 1
   ctx->NewState |= _NEW_DEPTH; /* for swrast */
a145 11
   case GL_ANY_SAMPLES_PASSED:
      if (ctx->Extensions.ARB_occlusion_query2)
         return &ctx->Query.CurrentOcclusionObject;
      else
         return NULL;
   case GL_ANY_SAMPLES_PASSED_CONSERVATIVE:
      if (ctx->Extensions.ARB_ES3_compatibility
          || (ctx->API == API_OPENGLES2 && ctx->Version >= 30))
         return &ctx->Query.CurrentOcclusionObject;
      else
         return NULL;
d151 1
d162 1
d170 1
a170 1
_mesa_GenQueries(GLsizei n, GLuint *ids)
d174 1
a174 3

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glGenQueries(%d)\n", n);
d206 1
a206 1
_mesa_DeleteQueries(GLsizei n, const GLuint *ids)
d210 1
a210 4
   FLUSH_VERTICES(ctx, 0);

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glDeleteQueries(%d)\n", n);
d238 1
a238 1
_mesa_IsQuery(GLuint id)
a239 2
   struct gl_query_object *q;

d243 3
a245 4
   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glIsQuery(%u)\n", id);

   if (id == 0)
a246 6

   q = _mesa_lookup_query_object(ctx, id);
   if (q == NULL)
      return GL_FALSE;

   return q->EverBound;
a248 20
static GLboolean
query_error_check_index(struct gl_context *ctx, GLenum target, GLuint index)
{
   switch (target) {
   case GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN:
   case GL_PRIMITIVES_GENERATED:
      if (index >= ctx->Const.MaxVertexStreams) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glBeginQueryIndexed(index>=MaxVertexStreams)");
         return GL_FALSE;
      }
      break;
   default:
      if (index > 0) {
         _mesa_error(ctx, GL_INVALID_VALUE, "glBeginQueryIndexed(index>0)");
         return GL_FALSE;
      }
   }
   return GL_TRUE;
}
d250 2
a251 2
void GLAPIENTRY
_mesa_BeginQueryIndexed(GLenum target, GLuint index, GLuint id)
d255 1
d257 1
a257 8
   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glBeginQueryIndexed(%s, %u, %u)\n",
                  _mesa_lookup_enum_by_nr(target), index, id);

   if (!query_error_check_index(ctx, target, index))
      return;

   FLUSH_VERTICES(ctx, 0);
d261 1
a261 14
      _mesa_error(ctx, GL_INVALID_ENUM, "glBeginQuery{Indexed}(target)");
      return;
   }

   /* From the GL_ARB_occlusion_query spec:
    *
    *     "If BeginQueryARB is called while another query is already in
    *      progress with the same target, an INVALID_OPERATION error is
    *      generated."
    */
   if (*bindpt) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glBeginQuery{Indexed}(target=%s is active)",
                  _mesa_lookup_enum_by_nr(target));
d266 1
a266 1
      _mesa_error(ctx, GL_INVALID_OPERATION, "glBeginQuery{Indexed}(id==0)");
d272 4
a275 3
      if (ctx->API != API_OPENGL_COMPAT) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glBeginQuery{Indexed}(non-gen name)");
a276 8
      } else {
         /* create new object */
         q = ctx->Driver.NewQueryObject(ctx, id);
         if (!q) {
            _mesa_error(ctx, GL_OUT_OF_MEMORY, "glBeginQuery{Indexed}");
            return;
         }
         _mesa_HashInsert(ctx->Query.QueryObjects, id, q);
d278 1
d284 1
a284 1
                     "glBeginQuery{Indexed}(query already active)");
a292 1
   q->EverBound = GL_TRUE;
d301 2
a302 2
void GLAPIENTRY
_mesa_EndQueryIndexed(GLenum target, GLuint index)
d306 1
d308 1
a308 8
   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glEndQueryIndexed(%s, %u)\n",
                  _mesa_lookup_enum_by_nr(target), index);

   if (!query_error_check_index(ctx, target, index))
      return;

   FLUSH_VERTICES(ctx, 0);
d312 1
a312 1
      _mesa_error(ctx, GL_INVALID_ENUM, "glEndQuery{Indexed}(target)");
a317 10

   /* Check for GL_ANY_SAMPLES_PASSED vs GL_SAMPLES_PASSED. */
   if (q && q->Target != target) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glEndQuery(target=%s with active query of target %s)",
                  _mesa_lookup_enum_by_nr(target),
                  _mesa_lookup_enum_by_nr(q->Target));
      return;
   }

d322 1
a322 1
                  "glEndQuery{Indexed}(no matching glBeginQuery{Indexed})");
a329 5
void GLAPIENTRY
_mesa_BeginQuery(GLenum target, GLuint id)
{
   _mesa_BeginQueryIndexed(target, 0, id);
}
d332 1
a332 1
_mesa_EndQuery(GLenum target)
d334 1
a334 7
   _mesa_EndQueryIndexed(target, 0);
}

void GLAPIENTRY
_mesa_QueryCounter(GLuint id, GLenum target)
{
   struct gl_query_object *q;
d336 1
d338 3
a340 7
   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glQueryCounter(%u, %s)\n", id,
                  _mesa_lookup_enum_by_nr(target));

   /* error checking */
   if (target != GL_TIMESTAMP) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glQueryCounter(target)");
d344 1
a344 77
   if (id == 0) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glQueryCounter(id==0)");
      return;
   }

   q = _mesa_lookup_query_object(ctx, id);
   if (!q) {
      /* XXX the Core profile should throw INVALID_OPERATION here */

      /* create new object */
      q = ctx->Driver.NewQueryObject(ctx, id);
      if (!q) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glQueryCounter");
         return;
      }
      _mesa_HashInsert(ctx->Query.QueryObjects, id, q);
   }
   else {
      if (q->Target && q->Target != GL_TIMESTAMP) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glQueryCounter(id has an invalid target)");
         return;
      }
   }

   if (q->Active) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glQueryCounter(id is active)");
      return;
   }

   q->Target = target;
   q->Result = 0;
   q->Ready = GL_FALSE;
   q->EverBound = GL_TRUE;

   if (ctx->Driver.QueryCounter) {
      ctx->Driver.QueryCounter(ctx, q);
   } else {
      /* QueryCounter is implemented using EndQuery without BeginQuery
       * in drivers. This is actually Direct3D and Gallium convention.
       */
      ctx->Driver.EndQuery(ctx, q);
   }
}


void GLAPIENTRY
_mesa_GetQueryIndexediv(GLenum target, GLuint index, GLenum pname,
                        GLint *params)
{
   struct gl_query_object *q = NULL, **bindpt = NULL;
   GET_CURRENT_CONTEXT(ctx);

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glGetQueryIndexediv(%s, %u, %s)\n",
                  _mesa_lookup_enum_by_nr(target),
                  index,
                  _mesa_lookup_enum_by_nr(pname));

   if (!query_error_check_index(ctx, target, index))
      return;

   if (target == GL_TIMESTAMP) {
      if (!ctx->Extensions.ARB_timer_query) {
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetQueryARB(target)");
         return;
      }
   }
   else {
      bindpt = get_query_binding_point(ctx, target);
      if (!bindpt) {
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetQuery{Indexed}iv(target)");
         return;
      }

      q = *bindpt;
   }
d348 1
a348 30
         switch (target) {
         case GL_SAMPLES_PASSED:
            *params = ctx->Const.QueryCounterBits.SamplesPassed;
            break;
         case GL_ANY_SAMPLES_PASSED:
            /* The minimum value of this is 1 if it's nonzero, and the value
             * is only ever GL_TRUE or GL_FALSE, so no sense in reporting more
             * bits.
             */
            *params = 1;
            break;
         case GL_TIME_ELAPSED:
            *params = ctx->Const.QueryCounterBits.TimeElapsed;
            break;
         case GL_TIMESTAMP:
            *params = ctx->Const.QueryCounterBits.Timestamp;
            break;
         case GL_PRIMITIVES_GENERATED:
            *params = ctx->Const.QueryCounterBits.PrimitivesGenerated;
            break;
         case GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN:
            *params = ctx->Const.QueryCounterBits.PrimitivesWritten;
            break;
         default:
            _mesa_problem(ctx,
                          "Unknown target in glGetQueryIndexediv(target = %s)",
                          _mesa_lookup_enum_by_nr(target));
            *params = 0;
            break;
         }
d351 1
a351 1
         *params = (q && q->Target == target) ? q->Id : 0;
d354 1
a354 1
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetQuery{Indexed}iv(pname)");
a358 5
void GLAPIENTRY
_mesa_GetQueryiv(GLenum target, GLenum pname, GLint *params)
{
   _mesa_GetQueryIndexediv(target, 0, pname, params);
}
d361 1
a361 1
_mesa_GetQueryObjectiv(GLuint id, GLenum pname, GLint *params)
d365 1
a365 4

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glGetQueryObjectiv(%u, %s)\n", id,
                  _mesa_lookup_enum_by_nr(pname));
d381 5
a385 13
         if (q->Target == GL_ANY_SAMPLES_PASSED
             || q->Target == GL_ANY_SAMPLES_PASSED_CONSERVATIVE) {
            if (q->Result)
               *params = GL_TRUE;
            else
               *params = GL_FALSE;
         } else {
            if (q->Result > 0x7fffffff) {
               *params = 0x7fffffff;
            }
            else {
               *params = (GLint)q->Result;
            }
d401 1
a401 1
_mesa_GetQueryObjectuiv(GLuint id, GLenum pname, GLuint *params)
d405 1
a405 4

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glGetQueryObjectuiv(%u, %s)\n", id,
                  _mesa_lookup_enum_by_nr(pname));
d421 5
a425 13
         if (q->Target == GL_ANY_SAMPLES_PASSED
             || q->Target == GL_ANY_SAMPLES_PASSED_CONSERVATIVE) {
            if (q->Result)
               *params = GL_TRUE;
            else
               *params = GL_FALSE;
         } else {
            if (q->Result > 0xffffffff) {
               *params = 0xffffffff;
            }
            else {
               *params = (GLuint)q->Result;
            }
d443 2
a444 2
void GLAPIENTRY
_mesa_GetQueryObjecti64v(GLuint id, GLenum pname, GLint64EXT *params)
d448 1
a448 4

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glGetQueryObjecti64v(%u, %s)\n", id,
                  _mesa_lookup_enum_by_nr(pname));
d480 2
a481 2
void GLAPIENTRY
_mesa_GetQueryObjectui64v(GLuint id, GLenum pname, GLuint64EXT *params)
d485 1
a485 4

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glGetQueryObjectui64v(%u, %s)\n", id,
                  _mesa_lookup_enum_by_nr(pname));
d513 21
a541 6

   ctx->Const.QueryCounterBits.SamplesPassed = 64;
   ctx->Const.QueryCounterBits.TimeElapsed = 64;
   ctx->Const.QueryCounterBits.Timestamp = 64;
   ctx->Const.QueryCounterBits.PrimitivesGenerated = 64;
   ctx->Const.QueryCounterBits.PrimitivesWritten = 64;
@


1.1.1.4
log
@Import Mesa 9.2.3
@
text
@d204 7
d243 7
d254 1
a254 10
            if (q->Active) {
               struct gl_query_object **bindpt;
               bindpt = get_query_binding_point(ctx, q->Target);
               assert(bindpt); /* Should be non-null for active q. */
               if (bindpt) {
                  *bindpt = NULL;
               }
               q->Active = GL_FALSE;
               ctx->Driver.EndQuery(ctx, q);
            }
@


1.1.1.5
log
@Import Mesa 10.2.3
@
text
@d46 1
a46 1
   struct gl_query_object *q = CALLOC_STRUCT(gl_query_object);
a128 1
   free(q->Label);
@


1.1.1.6
log
@Import Mesa 10.4.3
@
text
@d147 1
a147 2
 * Return pointer to the query object binding point for the given target and
 * index.
d151 1
a151 1
get_query_binding_point(struct gl_context *ctx, GLenum target, GLuint index)
d177 1
a177 1
         return &ctx->Query.PrimitivesGenerated[index];
d182 1
a182 1
         return &ctx->Query.PrimitivesWritten[index];
d243 1
a243 1
               bindpt = get_query_binding_point(ctx, q->Target, q->Stream);
d316 1
a316 1
   bindpt = get_query_binding_point(ctx, target, index);
a369 1
   q->Stream = index;
d393 1
a393 1
   bindpt = get_query_binding_point(ctx, target, index);
d520 1
a520 1
      bindpt = get_query_binding_point(ctx, target, index);
@


1.1.1.7
log
@Import Mesa 10.2.9
@
text
@d147 2
a148 1
 * Return pointer to the query object binding point for the given target.
d152 1
a152 1
get_query_binding_point(struct gl_context *ctx, GLenum target)
d178 1
a178 1
         return &ctx->Query.PrimitivesGenerated;
d183 1
a183 1
         return &ctx->Query.PrimitivesWritten;
d244 1
a244 1
               bindpt = get_query_binding_point(ctx, q->Target);
d317 1
a317 1
   bindpt = get_query_binding_point(ctx, target);
d371 1
d395 1
a395 1
   bindpt = get_query_binding_point(ctx, target);
d522 1
a522 1
      bindpt = get_query_binding_point(ctx, target);
@


