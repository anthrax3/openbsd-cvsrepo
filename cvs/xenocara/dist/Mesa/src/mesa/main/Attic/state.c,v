head	1.13;
access;
symbols
	OPENBSD_5_8:1.12.0.4
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	v10_2_9:1.1.1.8
	v10_4_3:1.1.1.7
	v10_2_7:1.1.1.6
	OPENBSD_5_6:1.10.0.2
	OPENBSD_5_6_BASE:1.10
	v10_2_3:1.1.1.6
	OPENBSD_5_5:1.9.0.2
	OPENBSD_5_5_BASE:1.9
	v9_2_5:1.1.1.5
	v9_2_3:1.1.1.5
	v9_2_2:1.1.1.5
	v9_2_1:1.1.1.5
	v9_2_0:1.1.1.5
	OPENBSD_5_4:1.8.0.4
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.2
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.7.0.4
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.6.0.6
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.4
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.5.0.4
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.2
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.4.0.2
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.3.0.2
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_3:1.2.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2015.12.23.05.17.53;	author jsg;	state dead;
branches;
next	1.12;
commitid	TnlogFl9nOv2eaRf;

1.12
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.11;
commitid	4ry2gvZGMXkCUD2n;

1.11
date	2015.01.25.14.41.22;	author jsg;	state Exp;
branches;
next	1.10;
commitid	mcxB0JvoI9gTDYXU;

1.10
date	2014.07.09.21.09.00;	author jsg;	state Exp;
branches;
next	1.9;
commitid	WPD6rgPryPkvXOr9;

1.9
date	2013.09.05.14.06.28;	author jsg;	state Exp;
branches;
next	1.8;

1.8
date	2012.08.17.13.58.19;	author mpi;	state Exp;
branches;
next	1.7;

1.7
date	2011.10.23.13.37.42;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.05.22.20.06.31;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2009.05.17.20.26.41;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2008.11.02.14.58.21;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.05.31.16.36.48;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.02.12.21.09.27;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.50.18;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.50.18;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.56.39;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.31.20;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.46;	author matthieu;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.09.05.13.16.49;	author jsg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.07.09.20.35.05;	author jsg;	state Exp;
branches;
next	1.1.1.7;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.7
date	2015.01.25.14.12.53;	author jsg;	state Exp;
branches;
next	1.1.1.8;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.8
date	2015.02.20.22.50.00;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.13
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2008  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */


/**
 * \file state.c
 * State management.
 * 
 * This file manages recalculation of derived values in struct gl_context.
 */


#include "glheader.h"
#include "mtypes.h"
#include "arrayobj.h"
#include "context.h"
#include "debug.h"
#include "macros.h"
#include "ffvertex_prog.h"
#include "framebuffer.h"
#include "light.h"
#include "matrix.h"
#include "pixel.h"
#include "program/program.h"
#include "program/prog_parameter.h"
#include "shaderobj.h"
#include "state.h"
#include "stencil.h"
#include "texenvprogram.h"
#include "texobj.h"
#include "texstate.h"
#include "varray.h"
#include "blend.h"


/**
 * Update the following fields:
 *   ctx->VertexProgram._Enabled
 *   ctx->FragmentProgram._Enabled
 *   ctx->ATIFragmentShader._Enabled
 * This needs to be done before texture state validation.
 */
static void
update_program_enables(struct gl_context *ctx)
{
   /* These _Enabled flags indicate if the user-defined ARB/NV vertex/fragment
    * program is enabled AND valid.  Similarly for ATI fragment shaders.
    * GLSL shaders not relevant here.
    */
   ctx->VertexProgram._Enabled = ctx->VertexProgram.Enabled
      && ctx->VertexProgram.Current->Base.Instructions;
   ctx->FragmentProgram._Enabled = ctx->FragmentProgram.Enabled
      && ctx->FragmentProgram.Current->Base.Instructions;
   ctx->ATIFragmentShader._Enabled = ctx->ATIFragmentShader.Enabled
      && ctx->ATIFragmentShader.Current->Instructions[0];
}


/**
 * Update the ctx->Vertex/Geometry/FragmentProgram._Current pointers to point
 * to the current/active programs.  Then call ctx->Driver.BindProgram() to
 * tell the driver which programs to use.
 *
 * Programs may come from 3 sources: GLSL shaders, ARB/NV_vertex/fragment
 * programs or programs derived from fixed-function state.
 *
 * This function needs to be called after texture state validation in case
 * we're generating a fragment program from fixed-function texture state.
 *
 * \return bitfield which will indicate _NEW_PROGRAM state if a new vertex
 * or fragment program is being used.
 */
static GLbitfield
update_program(struct gl_context *ctx)
{
   const struct gl_shader_program *vsProg =
      ctx->_Shader->CurrentProgram[MESA_SHADER_VERTEX];
   const struct gl_shader_program *gsProg =
      ctx->_Shader->CurrentProgram[MESA_SHADER_GEOMETRY];
   struct gl_shader_program *fsProg =
      ctx->_Shader->CurrentProgram[MESA_SHADER_FRAGMENT];
   const struct gl_vertex_program *prevVP = ctx->VertexProgram._Current;
   const struct gl_fragment_program *prevFP = ctx->FragmentProgram._Current;
   const struct gl_geometry_program *prevGP = ctx->GeometryProgram._Current;
   GLbitfield new_state = 0x0;

   /*
    * Set the ctx->VertexProgram._Current and ctx->FragmentProgram._Current
    * pointers to the programs that should be used for rendering.  If either
    * is NULL, use fixed-function code paths.
    *
    * These programs may come from several sources.  The priority is as
    * follows:
    *   1. OpenGL 2.0/ARB vertex/fragment shaders
    *   2. ARB/NV vertex/fragment programs
    *   3. Programs derived from fixed-function state.
    *
    * Note: it's possible for a vertex shader to get used with a fragment
    * program (and vice versa) here, but in practice that shouldn't ever
    * come up, or matter.
    */

   if (fsProg && fsProg->LinkStatus
       && fsProg->_LinkedShaders[MESA_SHADER_FRAGMENT]) {
      /* Use GLSL fragment shader */
      _mesa_reference_shader_program(ctx,
                                     &ctx->_Shader->_CurrentFragmentProgram,
				     fsProg);
      _mesa_reference_fragprog(ctx, &ctx->FragmentProgram._Current,
                               gl_fragment_program(fsProg->_LinkedShaders[MESA_SHADER_FRAGMENT]->Program));
      _mesa_reference_fragprog(ctx, &ctx->FragmentProgram._TexEnvProgram,
			       NULL);
   }
   else if (ctx->FragmentProgram._Enabled) {
      /* Use user-defined fragment program */
      _mesa_reference_shader_program(ctx,
                                     &ctx->_Shader->_CurrentFragmentProgram,
				     NULL);
      _mesa_reference_fragprog(ctx, &ctx->FragmentProgram._Current,
                               ctx->FragmentProgram.Current);
      _mesa_reference_fragprog(ctx, &ctx->FragmentProgram._TexEnvProgram,
			       NULL);
   }
   else if (ctx->FragmentProgram._MaintainTexEnvProgram) {
      /* Use fragment program generated from fixed-function state */
      struct gl_shader_program *f = _mesa_get_fixed_func_fragment_program(ctx);

      _mesa_reference_shader_program(ctx,
                                     &ctx->_Shader->_CurrentFragmentProgram,
				     f);
      _mesa_reference_fragprog(ctx, &ctx->FragmentProgram._Current,
			       gl_fragment_program(f->_LinkedShaders[MESA_SHADER_FRAGMENT]->Program));
      _mesa_reference_fragprog(ctx, &ctx->FragmentProgram._TexEnvProgram,
			       gl_fragment_program(f->_LinkedShaders[MESA_SHADER_FRAGMENT]->Program));
   }
   else {
      /* No fragment program */
      _mesa_reference_fragprog(ctx, &ctx->FragmentProgram._Current, NULL);
      _mesa_reference_fragprog(ctx, &ctx->FragmentProgram._TexEnvProgram,
			       NULL);
   }

   if (gsProg && gsProg->LinkStatus
       && gsProg->_LinkedShaders[MESA_SHADER_GEOMETRY]) {
      /* Use GLSL geometry shader */
      _mesa_reference_geomprog(ctx, &ctx->GeometryProgram._Current,
			       gl_geometry_program(gsProg->_LinkedShaders[MESA_SHADER_GEOMETRY]->Program));
   } else {
      /* No geometry program */
      _mesa_reference_geomprog(ctx, &ctx->GeometryProgram._Current, NULL);
   }

   /* Examine vertex program after fragment program as
    * _mesa_get_fixed_func_vertex_program() needs to know active
    * fragprog inputs.
    */
   if (vsProg && vsProg->LinkStatus
       && vsProg->_LinkedShaders[MESA_SHADER_VERTEX]) {
      /* Use GLSL vertex shader */
      _mesa_reference_vertprog(ctx, &ctx->VertexProgram._Current,
			       gl_vertex_program(vsProg->_LinkedShaders[MESA_SHADER_VERTEX]->Program));
   }
   else if (ctx->VertexProgram._Enabled) {
      /* Use user-defined vertex program */
      _mesa_reference_vertprog(ctx, &ctx->VertexProgram._Current,
                               ctx->VertexProgram.Current);
   }
   else if (ctx->VertexProgram._MaintainTnlProgram) {
      /* Use vertex program generated from fixed-function state */
      _mesa_reference_vertprog(ctx, &ctx->VertexProgram._Current,
                               _mesa_get_fixed_func_vertex_program(ctx));
      _mesa_reference_vertprog(ctx, &ctx->VertexProgram._TnlProgram,
                               ctx->VertexProgram._Current);
   }
   else {
      /* no vertex program */
      _mesa_reference_vertprog(ctx, &ctx->VertexProgram._Current, NULL);
   }

   /* Let the driver know what's happening:
    */
   if (ctx->FragmentProgram._Current != prevFP) {
      new_state |= _NEW_PROGRAM;
      if (ctx->Driver.BindProgram) {
         ctx->Driver.BindProgram(ctx, GL_FRAGMENT_PROGRAM_ARB,
                          (struct gl_program *) ctx->FragmentProgram._Current);
      }
   }

   if (ctx->GeometryProgram._Current != prevGP) {
      new_state |= _NEW_PROGRAM;
      if (ctx->Driver.BindProgram) {
         ctx->Driver.BindProgram(ctx, MESA_GEOMETRY_PROGRAM,
                            (struct gl_program *) ctx->GeometryProgram._Current);
      }
   }

   if (ctx->VertexProgram._Current != prevVP) {
      new_state |= _NEW_PROGRAM;
      if (ctx->Driver.BindProgram) {
         ctx->Driver.BindProgram(ctx, GL_VERTEX_PROGRAM_ARB,
                            (struct gl_program *) ctx->VertexProgram._Current);
      }
   }

   return new_state;
}


/**
 * Examine shader constants and return either _NEW_PROGRAM_CONSTANTS or 0.
 */
static GLbitfield
update_program_constants(struct gl_context *ctx)
{
   GLbitfield new_state = 0x0;

   if (ctx->FragmentProgram._Current) {
      const struct gl_program_parameter_list *params =
         ctx->FragmentProgram._Current->Base.Parameters;
      if (params && params->StateFlags & ctx->NewState) {
         new_state |= _NEW_PROGRAM_CONSTANTS;
      }
   }

   if (ctx->GeometryProgram._Current) {
      const struct gl_program_parameter_list *params =
         ctx->GeometryProgram._Current->Base.Parameters;
      /*FIXME: StateFlags is always 0 because we have unnamed constant
       *       not state changes */
      if (params /*&& params->StateFlags & ctx->NewState*/) {
         new_state |= _NEW_PROGRAM_CONSTANTS;
      }
   }

   if (ctx->VertexProgram._Current) {
      const struct gl_program_parameter_list *params =
         ctx->VertexProgram._Current->Base.Parameters;
      if (params && params->StateFlags & ctx->NewState) {
         new_state |= _NEW_PROGRAM_CONSTANTS;
      }
   }

   return new_state;
}




static void
update_viewport_matrix(struct gl_context *ctx)
{
   const GLfloat depthMax = ctx->DrawBuffer->_DepthMaxF;
   unsigned i;

   ASSERT(depthMax > 0);

   /* Compute scale and bias values. This is really driver-specific
    * and should be maintained elsewhere if at all.
    * NOTE: RasterPos uses this.
    */
   for (i = 0; i < ctx->Const.MaxViewports; i++) {
      _math_matrix_viewport(&ctx->ViewportArray[i]._WindowMap,
                            ctx->ViewportArray[i].X, ctx->ViewportArray[i].Y,
                            ctx->ViewportArray[i].Width, ctx->ViewportArray[i].Height,
                            ctx->ViewportArray[i].Near, ctx->ViewportArray[i].Far,
                            depthMax);
   }
}


/**
 * Update derived multisample state.
 */
static void
update_multisample(struct gl_context *ctx)
{
   ctx->Multisample._Enabled = GL_FALSE;
   if (ctx->Multisample.Enabled &&
       ctx->DrawBuffer &&
       ctx->DrawBuffer->Visual.sampleBuffers)
      ctx->Multisample._Enabled = GL_TRUE;
}


/**
 * Update the ctx->VertexProgram._TwoSideEnabled flag.
 */
static void
update_twoside(struct gl_context *ctx)
{
   if (ctx->_Shader->CurrentProgram[MESA_SHADER_VERTEX] ||
       ctx->VertexProgram._Enabled) {
      ctx->VertexProgram._TwoSideEnabled = ctx->VertexProgram.TwoSideEnabled;
   } else {
      ctx->VertexProgram._TwoSideEnabled = (ctx->Light.Enabled &&
					    ctx->Light.Model.TwoSide);
   }
}


/**
 * Compute derived GL state.
 * If __struct gl_contextRec::NewState is non-zero then this function \b must
 * be called before rendering anything.
 *
 * Calls dd_function_table::UpdateState to perform any internal state
 * management necessary.
 * 
 * \sa _mesa_update_modelview_project(), _mesa_update_texture(),
 * _mesa_update_buffer_bounds(),
 * _mesa_update_lighting() and _mesa_update_tnl_spaces().
 */
void
_mesa_update_state_locked( struct gl_context *ctx )
{
   GLbitfield new_state = ctx->NewState;
   GLbitfield prog_flags = _NEW_PROGRAM;
   GLbitfield new_prog_state = 0x0;

   if (new_state == _NEW_CURRENT_ATTRIB) 
      goto out;

   if (MESA_VERBOSE & VERBOSE_STATE)
      _mesa_print_state("_mesa_update_state", new_state);

   /* Determine which state flags effect vertex/fragment program state */
   if (ctx->FragmentProgram._MaintainTexEnvProgram) {
      prog_flags |= (_NEW_BUFFERS | _NEW_TEXTURE | _NEW_FOG |
		     _NEW_VARYING_VP_INPUTS | _NEW_LIGHT | _NEW_POINT |
		     _NEW_RENDERMODE | _NEW_PROGRAM | _NEW_FRAG_CLAMP |
		     _NEW_COLOR);
   }
   if (ctx->VertexProgram._MaintainTnlProgram) {
      prog_flags |= (_NEW_VARYING_VP_INPUTS | _NEW_TEXTURE |
                     _NEW_TEXTURE_MATRIX | _NEW_TRANSFORM | _NEW_POINT |
                     _NEW_FOG | _NEW_LIGHT |
                     _MESA_NEW_NEED_EYE_COORDS);
   }

   /*
    * Now update derived state info
    */

   if (new_state & prog_flags)
      update_program_enables( ctx );

   if (new_state & (_NEW_MODELVIEW|_NEW_PROJECTION))
      _mesa_update_modelview_project( ctx, new_state );

   if (new_state & (_NEW_PROGRAM|_NEW_TEXTURE|_NEW_TEXTURE_MATRIX))
      _mesa_update_texture( ctx, new_state );

   if (new_state & _NEW_BUFFERS)
      _mesa_update_framebuffer(ctx);

   if (new_state & (_NEW_SCISSOR | _NEW_BUFFERS | _NEW_VIEWPORT))
      _mesa_update_draw_buffer_bounds( ctx );

   if (new_state & _NEW_LIGHT)
      _mesa_update_lighting( ctx );

   if (new_state & (_NEW_LIGHT | _NEW_PROGRAM))
      update_twoside( ctx );

   if (new_state & (_NEW_STENCIL | _NEW_BUFFERS))
      _mesa_update_stencil( ctx );

   if (new_state & _NEW_PIXEL)
      _mesa_update_pixel( ctx, new_state );

   if (new_state & (_NEW_BUFFERS | _NEW_VIEWPORT))
      update_viewport_matrix(ctx);

   if (new_state & (_NEW_MULTISAMPLE | _NEW_BUFFERS))
      update_multisample( ctx );

   /* ctx->_NeedEyeCoords is now up to date.
    *
    * If the truth value of this variable has changed, update for the
    * new lighting space and recompute the positions of lights and the
    * normal transform.
    *
    * If the lighting space hasn't changed, may still need to recompute
    * light positions & normal transforms for other reasons.
    */
   if (new_state & _MESA_NEW_NEED_EYE_COORDS) 
      _mesa_update_tnl_spaces( ctx, new_state );

   if (new_state & prog_flags) {
      /* When we generate programs from fixed-function vertex/fragment state
       * this call may generate/bind a new program.  If so, we need to
       * propogate the _NEW_PROGRAM flag to the driver.
       */
      new_prog_state |= update_program( ctx );
   }

   if (new_state & _NEW_ARRAY)
      _mesa_update_vao_client_arrays(ctx, ctx->Array.VAO);

   if (ctx->Const.CheckArrayBounds &&
       new_state & (_NEW_ARRAY | _NEW_PROGRAM | _NEW_BUFFER_OBJECT)) {
      _mesa_update_vao_max_element(ctx, ctx->Array.VAO);
   }

 out:
   new_prog_state |= update_program_constants(ctx);

   /*
    * Give the driver a chance to act upon the new_state flags.
    * The driver might plug in different span functions, for example.
    * Also, this is where the driver can invalidate the state of any
    * active modules (such as swrast_setup, swrast, tnl, etc).
    *
    * Set ctx->NewState to zero to avoid recursion if
    * Driver.UpdateState() has to call FLUSH_VERTICES().  (fixed?)
    */
   new_state = ctx->NewState | new_prog_state;
   ctx->NewState = 0;
   ctx->Driver.UpdateState(ctx, new_state);
   ctx->Array.VAO->NewArrays = 0x0;
}


/* This is the usual entrypoint for state updates:
 */
void
_mesa_update_state( struct gl_context *ctx )
{
   _mesa_lock_context_textures(ctx);
   _mesa_update_state_locked(ctx);
   _mesa_unlock_context_textures(ctx);
}




/**
 * Want to figure out which fragment program inputs are actually
 * constant/current values from ctx->Current.  These should be
 * referenced as a tracked state variable rather than a fragment
 * program input, to save the overhead of putting a constant value in
 * every submitted vertex, transferring it to hardware, interpolating
 * it across the triangle, etc...
 *
 * When there is a VP bound, just use vp->outputs.  But when we're
 * generating vp from fixed function state, basically want to
 * calculate:
 *
 * vp_out_2_fp_in( vp_in_2_vp_out( varying_inputs ) | 
 *                 potential_vp_outputs )
 *
 * Where potential_vp_outputs is calculated by looking at enabled
 * texgen, etc.
 * 
 * The generated fragment program should then only declare inputs that
 * may vary or otherwise differ from the ctx->Current values.
 * Otherwise, the fp should track them as state values instead.
 */
void
_mesa_set_varying_vp_inputs( struct gl_context *ctx,
                             GLbitfield64 varying_inputs )
{
   if (ctx->varying_vp_inputs != varying_inputs) {
      ctx->varying_vp_inputs = varying_inputs;

      /* Only the fixed-func generated programs need to use the flag
       * and the fixed-func fragment program uses it only if there is also
       * a fixed-func vertex program, so this only depends on the latter.
       *
       * It's okay to check the VP pointer here, because this is called after
       * _mesa_update_state in the vbo module. */
      if (ctx->VertexProgram._TnlProgram ||
          ctx->FragmentProgram._TexEnvProgram) {
         ctx->NewState |= _NEW_VARYING_VP_INPUTS;
      }
      /*printf("%s %x\n", __FUNCTION__, varying_inputs);*/
   }
}


/**
 * Used by drivers to tell core Mesa that the driver is going to
 * install/ use its own vertex program.  In particular, this will
 * prevent generated fragment programs from using state vars instead
 * of ordinary varyings/inputs.
 */
void
_mesa_set_vp_override(struct gl_context *ctx, GLboolean flag)
{
   if (ctx->VertexProgram._Overriden != flag) {
      ctx->VertexProgram._Overriden = flag;

      /* Set one of the bits which will trigger fragment program
       * regeneration:
       */
      ctx->NewState |= _NEW_PROGRAM;
   }
}
@


1.12
log
@Merge Mesa 10.2.9
@
text
@@


1.11
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a53 1
#include "viewport.h"
a283 3
      double scale[3], translate[3];

      _mesa_get_viewport_xform(ctx, i, scale, translate);
d285 4
a288 1
                            scale, translate, depthMax);
a293 13
 * Update the ctx->Polygon._FrontBit flag.
 */
static void
update_frontbit(struct gl_context *ctx)
{
   if (ctx->Transform.ClipOrigin == GL_LOWER_LEFT)
      ctx->Polygon._FrontBit = (ctx->Polygon.FrontFace == GL_CW);
   else
      ctx->Polygon._FrontBit = (ctx->Polygon.FrontFace == GL_CCW);
}


/**
a374 3
   if (new_state & _NEW_POLYGON)
      update_frontbit( ctx );

d421 5
@


1.10
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d54 1
d285 3
d289 1
a289 4
                            ctx->ViewportArray[i].X, ctx->ViewportArray[i].Y,
                            ctx->ViewportArray[i].Width, ctx->ViewportArray[i].Height,
                            ctx->ViewportArray[i].Near, ctx->ViewportArray[i].Far,
                            depthMax);
d295 13
d389 3
a437 5

   if (ctx->Const.CheckArrayBounds &&
       new_state & (_NEW_ARRAY | _NEW_PROGRAM | _NEW_BUFFER_OBJECT)) {
      _mesa_update_vao_max_element(ctx, ctx->Array.VAO);
   }
@


1.9
log
@Merge Mesa 9.2.0
@
text
@d97 6
a102 3
   const struct gl_shader_program *vsProg = ctx->Shader.CurrentVertexProgram;
   const struct gl_shader_program *gsProg = ctx->Shader.CurrentGeometryProgram;
   struct gl_shader_program *fsProg = ctx->Shader.CurrentFragmentProgram;
d128 1
a128 1
				     &ctx->Shader._CurrentFragmentProgram,
d138 1
a138 1
				     &ctx->Shader._CurrentFragmentProgram,
d150 1
a150 1
				     &ctx->Shader._CurrentFragmentProgram,
d275 1
d283 7
a289 5
   _math_matrix_viewport(&ctx->Viewport._WindowMap,
                         ctx->Viewport.X, ctx->Viewport.Y,
                         ctx->Viewport.Width, ctx->Viewport.Height,
                         ctx->Viewport.Near, ctx->Viewport.Far,
                         depthMax);
d313 1
a313 1
   if (ctx->Shader.CurrentVertexProgram ||
d419 3
d424 1
a424 1
      _mesa_update_array_object_max_element(ctx, ctx->Array.ArrayObj);
d442 1
@


1.8
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a2 1
 * Version:  7.3
d19 4
a22 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
d36 1
d47 1
d54 1
a54 131


static void
update_separate_specular(struct gl_context *ctx)
{
   if (_mesa_need_secondary_color(ctx))
      ctx->_TriangleCaps |= DD_SEPARATE_SPECULAR;
   else
      ctx->_TriangleCaps &= ~DD_SEPARATE_SPECULAR;
}


/**
 * Helper for update_arrays().
 * \return  min(current min, array->_MaxElement).
 */
static GLuint
update_min(GLuint min, struct gl_client_array *array)
{
   _mesa_update_array_max_element(array);
   return MIN2(min, array->_MaxElement);
}


/**
 * Update ctx->Array._MaxElement (the max legal index into all enabled arrays).
 * Need to do this upon new array state or new buffer object state.
 */
static void
update_arrays( struct gl_context *ctx )
{
   struct gl_array_object *arrayObj = ctx->Array.ArrayObj;
   GLuint i, min = ~0;

   /* find min of _MaxElement values for all enabled arrays */

   /* 0 */
   if (ctx->VertexProgram._Current
       && arrayObj->VertexAttrib[VERT_ATTRIB_POS].Enabled) {
      min = update_min(min, &arrayObj->VertexAttrib[VERT_ATTRIB_POS]);
   }
   else if (arrayObj->Vertex.Enabled) {
      min = update_min(min, &arrayObj->Vertex);
   }

   /* 1 */
   if (ctx->VertexProgram._Enabled
       && arrayObj->VertexAttrib[VERT_ATTRIB_WEIGHT].Enabled) {
      min = update_min(min, &arrayObj->VertexAttrib[VERT_ATTRIB_WEIGHT]);
   }
   /* no conventional vertex weight array */

   /* 2 */
   if (ctx->VertexProgram._Enabled
       && arrayObj->VertexAttrib[VERT_ATTRIB_NORMAL].Enabled) {
      min = update_min(min, &arrayObj->VertexAttrib[VERT_ATTRIB_NORMAL]);
   }
   else if (arrayObj->Normal.Enabled) {
      min = update_min(min, &arrayObj->Normal);
   }

   /* 3 */
   if (ctx->VertexProgram._Enabled
       && arrayObj->VertexAttrib[VERT_ATTRIB_COLOR0].Enabled) {
      min = update_min(min, &arrayObj->VertexAttrib[VERT_ATTRIB_COLOR0]);
   }
   else if (arrayObj->Color.Enabled) {
      min = update_min(min, &arrayObj->Color);
   }

   /* 4 */
   if (ctx->VertexProgram._Enabled
       && arrayObj->VertexAttrib[VERT_ATTRIB_COLOR1].Enabled) {
      min = update_min(min, &arrayObj->VertexAttrib[VERT_ATTRIB_COLOR1]);
   }
   else if (arrayObj->SecondaryColor.Enabled) {
      min = update_min(min, &arrayObj->SecondaryColor);
   }

   /* 5 */
   if (ctx->VertexProgram._Enabled
       && arrayObj->VertexAttrib[VERT_ATTRIB_FOG].Enabled) {
      min = update_min(min, &arrayObj->VertexAttrib[VERT_ATTRIB_FOG]);
   }
   else if (arrayObj->FogCoord.Enabled) {
      min = update_min(min, &arrayObj->FogCoord);
   }

   /* 6 */
   if (ctx->VertexProgram._Enabled
       && arrayObj->VertexAttrib[VERT_ATTRIB_COLOR_INDEX].Enabled) {
      min = update_min(min, &arrayObj->VertexAttrib[VERT_ATTRIB_COLOR_INDEX]);
   }
   else if (arrayObj->Index.Enabled) {
      min = update_min(min, &arrayObj->Index);
   }

   /* 7 */
   if (ctx->VertexProgram._Enabled
       && arrayObj->VertexAttrib[VERT_ATTRIB_EDGEFLAG].Enabled) {
      min = update_min(min, &arrayObj->VertexAttrib[VERT_ATTRIB_EDGEFLAG]);
   }

   /* 8..15 */
   for (i = VERT_ATTRIB_TEX0; i <= VERT_ATTRIB_TEX7; i++) {
      if (ctx->VertexProgram._Enabled
          && arrayObj->VertexAttrib[i].Enabled) {
         min = update_min(min, &arrayObj->VertexAttrib[i]);
      }
      else if (i - VERT_ATTRIB_TEX0 < ctx->Const.MaxTextureCoordUnits
               && arrayObj->TexCoord[i - VERT_ATTRIB_TEX0].Enabled) {
         min = update_min(min, &arrayObj->TexCoord[i - VERT_ATTRIB_TEX0]);
      }
   }

   /* 16..31 */
   if (ctx->VertexProgram._Current) {
      for (i = 0; i < Elements(arrayObj->VertexAttrib); i++) {
         if (arrayObj->VertexAttrib[i].Enabled) {
            min = update_min(min, &arrayObj->VertexAttrib[i]);
         }
      }
   }

   if (arrayObj->EdgeFlag.Enabled) {
      min = update_min(min, &arrayObj->EdgeFlag);
   }

   /* _MaxElement is one past the last legal array element */
   arrayObj->_MaxElement = min;
}
d99 1
a99 1
   const struct gl_shader_program *fsProg = ctx->Shader.CurrentFragmentProgram;
d121 2
a122 1
   if (fsProg && fsProg->LinkStatus && fsProg->FragmentProgram) {
d124 3
d128 3
a130 1
                               fsProg->FragmentProgram);
d134 3
d139 2
d144 5
d150 1
a150 1
                               _mesa_get_fixed_func_fragment_program(ctx));
d152 1
a152 1
                               ctx->FragmentProgram._Current);
d157 2
d161 2
a162 1
   if (gsProg && gsProg->LinkStatus && gsProg->GeometryProgram) {
d165 1
a165 1
                               gsProg->GeometryProgram);
d175 2
a176 1
   if (vsProg && vsProg->LinkStatus && vsProg->VertexProgram) {
d179 1
a179 1
                               vsProg->VertexProgram);
d302 1
a302 1
 * Update derived color/blend/logicop state.
d305 1
a305 1
update_color(struct gl_context *ctx)
d307 6
a312 120
   /* This is needed to support 1.1's RGB logic ops AND
    * 1.0's blending logicops.
    */
   ctx->Color._LogicOpEnabled = _mesa_rgba_logicop_enabled(ctx);
}


/**
 * Update the ctx->Color._ClampFragmentColor field
 */
static void
update_clamp_fragment_color(struct gl_context *ctx)
{
   if (ctx->Color.ClampFragmentColor == GL_FIXED_ONLY_ARB)
      ctx->Color._ClampFragmentColor =
         !ctx->DrawBuffer || !ctx->DrawBuffer->Visual.floatMode;
   else
      ctx->Color._ClampFragmentColor = ctx->Color.ClampFragmentColor;
}


/**
 * Update the ctx->Color._ClampVertexColor field
 */
static void
update_clamp_vertex_color(struct gl_context *ctx)
{
   if (ctx->Light.ClampVertexColor == GL_FIXED_ONLY_ARB)
      ctx->Light._ClampVertexColor =
         !ctx->DrawBuffer || !ctx->DrawBuffer->Visual.floatMode;
   else
      ctx->Light._ClampVertexColor = ctx->Light.ClampVertexColor;
}


/**
 * Update the ctx->Color._ClampReadColor field
 */
static void
update_clamp_read_color(struct gl_context *ctx)
{
   if (ctx->Color.ClampReadColor == GL_FIXED_ONLY_ARB)
      ctx->Color._ClampReadColor =
         !ctx->ReadBuffer || !ctx->ReadBuffer->Visual.floatMode;
   else
      ctx->Color._ClampReadColor = ctx->Color.ClampReadColor;
}




/*
 * Check polygon state and set DD_TRI_CULL_FRONT_BACK and/or DD_TRI_OFFSET
 * in ctx->_TriangleCaps if needed.
 */
static void
update_polygon(struct gl_context *ctx)
{
   ctx->_TriangleCaps &= ~(DD_TRI_CULL_FRONT_BACK | DD_TRI_OFFSET);

   if (ctx->Polygon.CullFlag && ctx->Polygon.CullFaceMode == GL_FRONT_AND_BACK)
      ctx->_TriangleCaps |= DD_TRI_CULL_FRONT_BACK;

   if (   ctx->Polygon.OffsetPoint
       || ctx->Polygon.OffsetLine
       || ctx->Polygon.OffsetFill)
      ctx->_TriangleCaps |= DD_TRI_OFFSET;
}


/**
 * Update the ctx->_TriangleCaps bitfield.
 * XXX that bitfield should really go away someday!
 * This function must be called after other update_*() functions since
 * there are dependencies on some other derived values.
 */
#if 0
static void
update_tricaps(struct gl_context *ctx, GLbitfield new_state)
{
   ctx->_TriangleCaps = 0;

   /*
    * Points
    */
   if (1/*new_state & _NEW_POINT*/) {
      if (ctx->Point.SmoothFlag)
         ctx->_TriangleCaps |= DD_POINT_SMOOTH;
      if (ctx->Point._Attenuated)
         ctx->_TriangleCaps |= DD_POINT_ATTEN;
   }

   /*
    * Lines
    */
   if (1/*new_state & _NEW_LINE*/) {
      if (ctx->Line.SmoothFlag)
         ctx->_TriangleCaps |= DD_LINE_SMOOTH;
      if (ctx->Line.StippleFlag)
         ctx->_TriangleCaps |= DD_LINE_STIPPLE;
   }

   /*
    * Polygons
    */
   if (1/*new_state & _NEW_POLYGON*/) {
      if (ctx->Polygon.SmoothFlag)
         ctx->_TriangleCaps |= DD_TRI_SMOOTH;
      if (ctx->Polygon.StippleFlag)
         ctx->_TriangleCaps |= DD_TRI_STIPPLE;
      if (ctx->Polygon.FrontMode != GL_FILL
          || ctx->Polygon.BackMode != GL_FILL)
         ctx->_TriangleCaps |= DD_TRI_UNFILLED;
      if (ctx->Polygon.CullFlag
          && ctx->Polygon.CullFaceMode == GL_FRONT_AND_BACK)
         ctx->_TriangleCaps |= DD_TRI_CULL_FRONT_BACK;
      if (ctx->Polygon.OffsetPoint ||
          ctx->Polygon.OffsetLine ||
          ctx->Polygon.OffsetFill)
         ctx->_TriangleCaps |= DD_TRI_OFFSET;
a313 16

   /*
    * Lighting and shading
    */
   if (ctx->Light.Enabled && ctx->Light.Model.TwoSide)
      ctx->_TriangleCaps |= DD_TRI_LIGHT_TWOSIDE;
   if (ctx->Light.ShadeModel == GL_FLAT)
      ctx->_TriangleCaps |= DD_FLATSHADE;
   if (_mesa_need_secondary_color(ctx))
      ctx->_TriangleCaps |= DD_SEPARATE_SPECULAR;

   /*
    * Stencil
    */
   if (ctx->Stencil._TestTwoSide)
      ctx->_TriangleCaps |= DD_TRI_TWOSTENCIL;
a314 1
#endif
d345 3
a347 2
		     _NEW_ARRAY | _NEW_LIGHT | _NEW_POINT | _NEW_RENDERMODE |
		     _NEW_PROGRAM | _NEW_FRAG_CLAMP);
d350 2
a351 2
      prog_flags |= (_NEW_ARRAY | _NEW_TEXTURE | _NEW_TEXTURE_MATRIX |
                     _NEW_TRANSFORM | _NEW_POINT |
a374 3
   if (new_state & _NEW_POLYGON)
      update_polygon( ctx );

d378 2
a379 2
   if (new_state & (_NEW_LIGHT | _NEW_BUFFERS))
      update_clamp_vertex_color(ctx);
a386 3
   if (new_state & _DD_NEW_SEPARATE_SPECULAR)
      update_separate_specular( ctx );

d390 1
a390 1
   if (new_state & _NEW_MULTISAMPLE)
a392 15
   if (new_state & _NEW_COLOR)
      update_color( ctx );

   if (new_state & (_NEW_COLOR | _NEW_BUFFERS))
      update_clamp_read_color(ctx);

   if(new_state & (_NEW_FRAG_CLAMP | _NEW_BUFFERS))
      update_clamp_fragment_color(ctx);

#if 0
   if (new_state & (_NEW_POINT | _NEW_LINE | _NEW_POLYGON | _NEW_LIGHT
                    | _NEW_STENCIL | _DD_NEW_SEPARATE_SPECULAR))
      update_tricaps( ctx, new_state );
#endif

d413 4
a416 2
   if (new_state & (_NEW_ARRAY | _NEW_PROGRAM | _NEW_BUFFER_OBJECT))
      update_arrays( ctx );
a432 3
   ctx->Array.NewState = 0;
   if (!ctx->Array.RebindArrays)
      ctx->Array.RebindArrays = (new_state & (_NEW_ARRAY | _NEW_PROGRAM)) != 0;
d473 1
a473 1
                             GLbitfield varying_inputs )
d477 11
a487 1
      ctx->NewState |= _NEW_ARRAY;
@


1.7
log
@Merge Mesa 7.10.3
@
text
@d51 1
d57 1
a57 1
   if (NEED_SECONDARY_COLOR(ctx))
a64 30
 * Compute the index of the last array element that can be safely accessed
 * in a vertex array.  We can really only do this when the array lives in
 * a VBO.
 * The array->_MaxElement field will be updated.
 * Later in glDrawArrays/Elements/etc we can do some bounds checking.
 */
static void
compute_max_element(struct gl_client_array *array)
{
   assert(array->Enabled);
   if (array->BufferObj->Name) {
      GLsizeiptrARB offset = (GLsizeiptrARB) array->Ptr;
      GLsizeiptrARB obj_size = (GLsizeiptrARB) array->BufferObj->Size;

      if (offset < obj_size) {
	 array->_MaxElement = (obj_size - offset +
			       array->StrideB -
			       array->_ElementSize) / array->StrideB;
      } else {
	 array->_MaxElement = 0;
      }
   }
   else {
      /* user-space array, no idea how big it is */
      array->_MaxElement = 2 * 1000 * 1000 * 1000; /* just a big number */
   }
}


/**
d71 1
a71 1
   compute_max_element(array);
d195 4
a198 1
   /* These _Enabled flags indicate if the program is enabled AND valid. */
d209 6
a214 5
 * Update vertex/fragment program state.  In particular, update these fields:
 *   ctx->VertexProgram._Current
 *   ctx->VertexProgram._TnlProgram,
 * These point to the highest priority enabled vertex/fragment program or are
 * NULL if fixed-function processing is to be done.
d250 1
a250 1
      /* Use shader programs */
d255 1
a255 1
      /* use user-defined vertex program */
d260 1
a260 2
      /* Use fragment program generated from fixed-function state.
       */
d267 1
a267 1
      /* no fragment program */
d272 1
a272 1
      /* Use shader programs */
d276 1
a276 1
      /* no fragment program */
d285 1
a285 1
      /* Use shader programs */
d287 1
a287 1
                            vsProg->VertexProgram);
d290 1
a290 1
      /* use user-defined vertex program */
d295 1
a295 2
      /* Use vertex program generated from fixed-function state.
       */
d418 15
a432 1
   ctx->Color._LogicOpEnabled = RGBA_LOGICOP_ENABLED(ctx);
d436 30
d544 1
a544 1
   if (NEED_SECONDARY_COLOR(ctx))
d585 1
a585 1
		     _NEW_PROGRAM);
d619 3
d625 1
a625 1
   if (new_state & _MESA_NEW_TRANSFER_STATE)
d640 6
d691 2
@


1.6
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d30 1
a30 1
 * This file manages recalculation of derived values in GLcontext.
d44 2
a45 2
#include "shader/program.h"
#include "shader/prog_parameter.h"
d54 1
a54 1
update_separate_specular(GLcontext *ctx)
d110 1
a110 1
update_arrays( GLcontext *ctx )
d222 1
a222 1
update_program_enables(GLcontext *ctx)
d248 1
a248 1
update_program(GLcontext *ctx)
d250 3
a252 1
   const struct gl_shader_program *shProg = ctx->Shader.CurrentProgram;
d255 1
d274 1
a274 1
   if (shProg && shProg->LinkStatus && shProg->FragmentProgram) {
d277 1
a277 1
                               shProg->FragmentProgram);
d297 9
d310 1
a310 1
   if (shProg && shProg->LinkStatus && shProg->VertexProgram) {
d313 1
a313 1
                            shProg->VertexProgram);
d342 9
a350 1
   
d367 1
a367 1
update_program_constants(GLcontext *ctx)
d379 10
d404 1
a404 1
update_viewport_matrix(GLcontext *ctx)
d426 1
a426 1
update_multisample(GLcontext *ctx)
d440 1
a440 1
update_color(GLcontext *ctx)
d454 1
a454 1
update_polygon(GLcontext *ctx)
d476 1
a476 1
update_tricaps(GLcontext *ctx, GLbitfield new_state)
a485 2
      if (ctx->Point.Size != 1.0F)
         ctx->_TriangleCaps |= DD_POINT_SIZE;
a497 2
      if (ctx->Line.Width != 1.0)
         ctx->_TriangleCaps |= DD_LINE_WIDTH;
d541 1
a541 1
 * If __GLcontextRec::NewState is non-zero then this function \b must
d552 1
a552 1
_mesa_update_state_locked( GLcontext *ctx )
d566 1
a566 1
      prog_flags |= (_NEW_TEXTURE | _NEW_FOG |
d671 1
a671 1
_mesa_update_state( GLcontext *ctx )
d704 1
a704 1
_mesa_set_varying_vp_inputs( GLcontext *ctx,
d722 1
a722 1
_mesa_set_vp_override(GLcontext *ctx, GLboolean flag)
@


1.5
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d3 1
a3 1
 * Version:  7.1
a42 1
#if FEATURE_pixel_transfer
a43 1
#endif
d45 1
d64 44
a107 1
 * Update state dependent on vertex arrays.
d112 2
a113 1
   GLuint i, min;
d119 2
a120 2
       && ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_POS].Enabled) {
      min = ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_POS]._MaxElement;
d122 2
a123 6
   else if (ctx->Array.ArrayObj->Vertex.Enabled) {
      min = ctx->Array.ArrayObj->Vertex._MaxElement;
   }
   else {
      /* can't draw anything without vertex positions! */
      min = 0;
d128 2
a129 2
       && ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_WEIGHT].Enabled) {
      min = MIN2(min, ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_WEIGHT]._MaxElement);
d135 2
a136 2
       && ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_NORMAL].Enabled) {
      min = MIN2(min, ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_NORMAL]._MaxElement);
d138 2
a139 2
   else if (ctx->Array.ArrayObj->Normal.Enabled) {
      min = MIN2(min, ctx->Array.ArrayObj->Normal._MaxElement);
d144 2
a145 2
       && ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_COLOR0].Enabled) {
      min = MIN2(min, ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_COLOR0]._MaxElement);
d147 2
a148 2
   else if (ctx->Array.ArrayObj->Color.Enabled) {
      min = MIN2(min, ctx->Array.ArrayObj->Color._MaxElement);
d153 2
a154 2
       && ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_COLOR1].Enabled) {
      min = MIN2(min, ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_COLOR1]._MaxElement);
d156 2
a157 2
   else if (ctx->Array.ArrayObj->SecondaryColor.Enabled) {
      min = MIN2(min, ctx->Array.ArrayObj->SecondaryColor._MaxElement);
d162 2
a163 2
       && ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_FOG].Enabled) {
      min = MIN2(min, ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_FOG]._MaxElement);
d165 2
a166 2
   else if (ctx->Array.ArrayObj->FogCoord.Enabled) {
      min = MIN2(min, ctx->Array.ArrayObj->FogCoord._MaxElement);
d171 2
a172 2
       && ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_COLOR_INDEX].Enabled) {
      min = MIN2(min, ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_COLOR_INDEX]._MaxElement);
d174 2
a175 2
   else if (ctx->Array.ArrayObj->Index.Enabled) {
      min = MIN2(min, ctx->Array.ArrayObj->Index._MaxElement);
a177 1

d180 2
a181 2
       && ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_EDGEFLAG].Enabled) {
      min = MIN2(min, ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_EDGEFLAG]._MaxElement);
d187 2
a188 2
          && ctx->Array.ArrayObj->VertexAttrib[i].Enabled) {
         min = MIN2(min, ctx->Array.ArrayObj->VertexAttrib[i]._MaxElement);
d191 2
a192 2
               && ctx->Array.ArrayObj->TexCoord[i - VERT_ATTRIB_TEX0].Enabled) {
         min = MIN2(min, ctx->Array.ArrayObj->TexCoord[i - VERT_ATTRIB_TEX0]._MaxElement);
d198 3
a200 3
      for (i = VERT_ATTRIB_GENERIC0; i < VERT_ATTRIB_MAX; i++) {
         if (ctx->Array.ArrayObj->VertexAttrib[i].Enabled) {
            min = MIN2(min, ctx->Array.ArrayObj->VertexAttrib[i]._MaxElement);
d205 2
a206 2
   if (ctx->Array.ArrayObj->EdgeFlag.Enabled) {
      min = MIN2(min, ctx->Array.ArrayObj->EdgeFlag._MaxElement);
d210 1
a210 1
   ctx->Array._MaxElement = min;
d343 30
d532 3
d540 3
a542 1
      prog_flags |= (_NEW_TEXTURE | _NEW_FOG | _DD_NEW_SEPARATE_SPECULAR);
d564 1
a564 1
   if (new_state & (_NEW_BUFFERS | _NEW_COLOR | _NEW_PIXEL))
d576 1
a576 1
   if (new_state & _NEW_STENCIL)
d579 1
a579 2
#if FEATURE_pixel_transfer
   if (new_state & _IMAGE_NEW_TRANSFER_STATE)
a580 1
#endif
a584 3
   if (new_state & (_NEW_ARRAY | _NEW_PROGRAM))
      update_arrays( ctx );

d620 6
d650 56
@


1.4
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d3 1
a3 1
 * Version:  6.5.1
d5 1
a5 1
 * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
d30 1
a30 2
 * This file manages recalculation of derived values in the __GLcontextRec.
 * Also, this is where we initialize the API dispatch table.
d33 1
d35 1
a35 17
#include "accum.h"
#include "api_loopback.h"
#if FEATURE_ARB_vertex_program || FEATURE_ARB_fragment_program
#include "shader/arbprogram.h"
#endif
#if FEATURE_ATI_fragment_shader
#include "shader/atifragshader.h"
#endif
#include "attrib.h"
#include "blend.h"
#if FEATURE_ARB_vertex_buffer_object
#include "bufferobj.h"
#endif
#include "arrayobj.h"
#include "buffers.h"
#include "clip.h"
#include "colortab.h"
d37 3
a39 12
#include "convolve.h"
#include "depth.h"
#include "dlist.h"
#include "drawpix.h"
#include "enable.h"
#include "eval.h"
#include "get.h"
#include "feedback.h"
#include "fog.h"
#if FEATURE_EXT_framebuffer_object
#include "fbobject.h"
#endif
a40 3
#include "hint.h"
#include "histogram.h"
#include "imports.h"
a41 2
#include "lines.h"
#include "macros.h"
d43 1
a44 4
#include "points.h"
#include "polygon.h"
#if FEATURE_ARB_occlusion_query || FEATURE_EXT_timer_query
#include "queryobj.h"
d46 1
a46 1
#include "rastpos.h"
d49 1
a49 1
#include "teximage.h"
a51 745
#include "mtypes.h"
#include "varray.h"
#if FEATURE_NV_vertex_program
#include "shader/nvprogram.h"
#endif
#if FEATURE_NV_fragment_program
#include "shader/nvprogram.h"
#include "shader/program.h"
#include "texenvprogram.h"
#endif
#if FEATURE_ARB_shader_objects
#include "shaders.h"
#endif
#include "debug.h"
#include "glapi/dispatch.h"



/**
 * Initialize a dispatch table with pointers to Mesa's immediate-mode
 * commands.
 *
 * Pointers to glBegin()/glEnd() object commands and a few others
 * are provided via the GLvertexformat interface.
 *
 * \param ctx  GL context to which \c exec belongs.
 * \param exec dispatch table.
 */
void
_mesa_init_exec_table(struct _glapi_table *exec)
{
#if _HAVE_FULL_GL
   _mesa_loopback_init_api_table( exec );
#endif

   /* load the dispatch slots we understand */
   SET_AlphaFunc(exec, _mesa_AlphaFunc);
   SET_BlendFunc(exec, _mesa_BlendFunc);
   SET_Clear(exec, _mesa_Clear);
   SET_ClearColor(exec, _mesa_ClearColor);
   SET_ClearStencil(exec, _mesa_ClearStencil);
   SET_ColorMask(exec, _mesa_ColorMask);
   SET_CullFace(exec, _mesa_CullFace);
   SET_Disable(exec, _mesa_Disable);
   SET_DrawBuffer(exec, _mesa_DrawBuffer);
   SET_Enable(exec, _mesa_Enable);
   SET_Finish(exec, _mesa_Finish);
   SET_Flush(exec, _mesa_Flush);
   SET_FrontFace(exec, _mesa_FrontFace);
   SET_Frustum(exec, _mesa_Frustum);
   SET_GetError(exec, _mesa_GetError);
   SET_GetFloatv(exec, _mesa_GetFloatv);
   SET_GetString(exec, _mesa_GetString);
   SET_InitNames(exec, _mesa_InitNames);
   SET_LineStipple(exec, _mesa_LineStipple);
   SET_LineWidth(exec, _mesa_LineWidth);
   SET_LoadIdentity(exec, _mesa_LoadIdentity);
   SET_LoadMatrixf(exec, _mesa_LoadMatrixf);
   SET_LoadName(exec, _mesa_LoadName);
   SET_LogicOp(exec, _mesa_LogicOp);
   SET_MatrixMode(exec, _mesa_MatrixMode);
   SET_MultMatrixf(exec, _mesa_MultMatrixf);
   SET_Ortho(exec, _mesa_Ortho);
   SET_PixelStorei(exec, _mesa_PixelStorei);
   SET_PopMatrix(exec, _mesa_PopMatrix);
   SET_PopName(exec, _mesa_PopName);
   SET_PushMatrix(exec, _mesa_PushMatrix);
   SET_PushName(exec, _mesa_PushName);
   SET_RasterPos2f(exec, _mesa_RasterPos2f);
   SET_RasterPos2fv(exec, _mesa_RasterPos2fv);
   SET_RasterPos2i(exec, _mesa_RasterPos2i);
   SET_RasterPos2iv(exec, _mesa_RasterPos2iv);
   SET_ReadBuffer(exec, _mesa_ReadBuffer);
   SET_RenderMode(exec, _mesa_RenderMode);
   SET_Rotatef(exec, _mesa_Rotatef);
   SET_Scalef(exec, _mesa_Scalef);
   SET_Scissor(exec, _mesa_Scissor);
   SET_SelectBuffer(exec, _mesa_SelectBuffer);
   SET_ShadeModel(exec, _mesa_ShadeModel);
   SET_StencilFunc(exec, _mesa_StencilFunc);
   SET_StencilMask(exec, _mesa_StencilMask);
   SET_StencilOp(exec, _mesa_StencilOp);
   SET_TexEnvfv(exec, _mesa_TexEnvfv);
   SET_TexEnvi(exec, _mesa_TexEnvi);
   SET_TexImage2D(exec, _mesa_TexImage2D);
   SET_TexParameteri(exec, _mesa_TexParameteri);
   SET_Translatef(exec, _mesa_Translatef);
   SET_Viewport(exec, _mesa_Viewport);
#if _HAVE_FULL_GL
   SET_Accum(exec, _mesa_Accum);
   SET_Bitmap(exec, _mesa_Bitmap);
   SET_CallList(exec, _mesa_CallList);
   SET_CallLists(exec, _mesa_CallLists);
   SET_ClearAccum(exec, _mesa_ClearAccum);
   SET_ClearDepth(exec, _mesa_ClearDepth);
   SET_ClearIndex(exec, _mesa_ClearIndex);
   SET_ClipPlane(exec, _mesa_ClipPlane);
   SET_ColorMaterial(exec, _mesa_ColorMaterial);
   SET_CopyPixels(exec, _mesa_CopyPixels);
   SET_CullParameterfvEXT(exec, _mesa_CullParameterfvEXT);
   SET_CullParameterdvEXT(exec, _mesa_CullParameterdvEXT);
   SET_DeleteLists(exec, _mesa_DeleteLists);
   SET_DepthFunc(exec, _mesa_DepthFunc);
   SET_DepthMask(exec, _mesa_DepthMask);
   SET_DepthRange(exec, _mesa_DepthRange);
   SET_DrawPixels(exec, _mesa_DrawPixels);
   SET_EndList(exec, _mesa_EndList);
   SET_FeedbackBuffer(exec, _mesa_FeedbackBuffer);
   SET_FogCoordPointerEXT(exec, _mesa_FogCoordPointerEXT);
   SET_Fogf(exec, _mesa_Fogf);
   SET_Fogfv(exec, _mesa_Fogfv);
   SET_Fogi(exec, _mesa_Fogi);
   SET_Fogiv(exec, _mesa_Fogiv);
   SET_GenLists(exec, _mesa_GenLists);
   SET_GetClipPlane(exec, _mesa_GetClipPlane);
   SET_GetBooleanv(exec, _mesa_GetBooleanv);
   SET_GetDoublev(exec, _mesa_GetDoublev);
   SET_GetIntegerv(exec, _mesa_GetIntegerv);
   SET_GetLightfv(exec, _mesa_GetLightfv);
   SET_GetLightiv(exec, _mesa_GetLightiv);
   SET_GetMapdv(exec, _mesa_GetMapdv);
   SET_GetMapfv(exec, _mesa_GetMapfv);
   SET_GetMapiv(exec, _mesa_GetMapiv);
   SET_GetMaterialfv(exec, _mesa_GetMaterialfv);
   SET_GetMaterialiv(exec, _mesa_GetMaterialiv);
   SET_GetPixelMapfv(exec, _mesa_GetPixelMapfv);
   SET_GetPixelMapuiv(exec, _mesa_GetPixelMapuiv);
   SET_GetPixelMapusv(exec, _mesa_GetPixelMapusv);
   SET_GetPolygonStipple(exec, _mesa_GetPolygonStipple);
   SET_GetTexEnvfv(exec, _mesa_GetTexEnvfv);
   SET_GetTexEnviv(exec, _mesa_GetTexEnviv);
   SET_GetTexLevelParameterfv(exec, _mesa_GetTexLevelParameterfv);
   SET_GetTexLevelParameteriv(exec, _mesa_GetTexLevelParameteriv);
   SET_GetTexParameterfv(exec, _mesa_GetTexParameterfv);
   SET_GetTexParameteriv(exec, _mesa_GetTexParameteriv);
   SET_GetTexGendv(exec, _mesa_GetTexGendv);
   SET_GetTexGenfv(exec, _mesa_GetTexGenfv);
   SET_GetTexGeniv(exec, _mesa_GetTexGeniv);
   SET_GetTexImage(exec, _mesa_GetTexImage);
   SET_Hint(exec, _mesa_Hint);
   SET_IndexMask(exec, _mesa_IndexMask);
   SET_IsEnabled(exec, _mesa_IsEnabled);
   SET_IsList(exec, _mesa_IsList);
   SET_LightModelf(exec, _mesa_LightModelf);
   SET_LightModelfv(exec, _mesa_LightModelfv);
   SET_LightModeli(exec, _mesa_LightModeli);
   SET_LightModeliv(exec, _mesa_LightModeliv);
   SET_Lightf(exec, _mesa_Lightf);
   SET_Lightfv(exec, _mesa_Lightfv);
   SET_Lighti(exec, _mesa_Lighti);
   SET_Lightiv(exec, _mesa_Lightiv);
   SET_ListBase(exec, _mesa_ListBase);
   SET_LoadMatrixd(exec, _mesa_LoadMatrixd);
   SET_Map1d(exec, _mesa_Map1d);
   SET_Map1f(exec, _mesa_Map1f);
   SET_Map2d(exec, _mesa_Map2d);
   SET_Map2f(exec, _mesa_Map2f);
   SET_MapGrid1d(exec, _mesa_MapGrid1d);
   SET_MapGrid1f(exec, _mesa_MapGrid1f);
   SET_MapGrid2d(exec, _mesa_MapGrid2d);
   SET_MapGrid2f(exec, _mesa_MapGrid2f);
   SET_MultMatrixd(exec, _mesa_MultMatrixd);
   SET_NewList(exec, _mesa_NewList);
   SET_PassThrough(exec, _mesa_PassThrough);
   SET_PixelMapfv(exec, _mesa_PixelMapfv);
   SET_PixelMapuiv(exec, _mesa_PixelMapuiv);
   SET_PixelMapusv(exec, _mesa_PixelMapusv);
   SET_PixelStoref(exec, _mesa_PixelStoref);
   SET_PixelTransferf(exec, _mesa_PixelTransferf);
   SET_PixelTransferi(exec, _mesa_PixelTransferi);
   SET_PixelZoom(exec, _mesa_PixelZoom);
   SET_PointSize(exec, _mesa_PointSize);
   SET_PolygonMode(exec, _mesa_PolygonMode);
   SET_PolygonOffset(exec, _mesa_PolygonOffset);
   SET_PolygonStipple(exec, _mesa_PolygonStipple);
   SET_PopAttrib(exec, _mesa_PopAttrib);
   SET_PushAttrib(exec, _mesa_PushAttrib);
   SET_RasterPos2d(exec, _mesa_RasterPos2d);
   SET_RasterPos2dv(exec, _mesa_RasterPos2dv);
   SET_RasterPos2s(exec, _mesa_RasterPos2s);
   SET_RasterPos2sv(exec, _mesa_RasterPos2sv);
   SET_RasterPos3d(exec, _mesa_RasterPos3d);
   SET_RasterPos3dv(exec, _mesa_RasterPos3dv);
   SET_RasterPos3f(exec, _mesa_RasterPos3f);
   SET_RasterPos3fv(exec, _mesa_RasterPos3fv);
   SET_RasterPos3i(exec, _mesa_RasterPos3i);
   SET_RasterPos3iv(exec, _mesa_RasterPos3iv);
   SET_RasterPos3s(exec, _mesa_RasterPos3s);
   SET_RasterPos3sv(exec, _mesa_RasterPos3sv);
   SET_RasterPos4d(exec, _mesa_RasterPos4d);
   SET_RasterPos4dv(exec, _mesa_RasterPos4dv);
   SET_RasterPos4f(exec, _mesa_RasterPos4f);
   SET_RasterPos4fv(exec, _mesa_RasterPos4fv);
   SET_RasterPos4i(exec, _mesa_RasterPos4i);
   SET_RasterPos4iv(exec, _mesa_RasterPos4iv);
   SET_RasterPos4s(exec, _mesa_RasterPos4s);
   SET_RasterPos4sv(exec, _mesa_RasterPos4sv);
   SET_ReadPixels(exec, _mesa_ReadPixels);
   SET_Rotated(exec, _mesa_Rotated);
   SET_Scaled(exec, _mesa_Scaled);
   SET_SecondaryColorPointerEXT(exec, _mesa_SecondaryColorPointerEXT);
   SET_TexEnvf(exec, _mesa_TexEnvf);
   SET_TexEnviv(exec, _mesa_TexEnviv);
   SET_TexGend(exec, _mesa_TexGend);
   SET_TexGendv(exec, _mesa_TexGendv);
   SET_TexGenf(exec, _mesa_TexGenf);
   SET_TexGenfv(exec, _mesa_TexGenfv);
   SET_TexGeni(exec, _mesa_TexGeni);
   SET_TexGeniv(exec, _mesa_TexGeniv);
   SET_TexImage1D(exec, _mesa_TexImage1D);
   SET_TexParameterf(exec, _mesa_TexParameterf);
   SET_TexParameterfv(exec, _mesa_TexParameterfv);
   SET_TexParameteriv(exec, _mesa_TexParameteriv);
   SET_Translated(exec, _mesa_Translated);
#endif

   /* 1.1 */
   SET_BindTexture(exec, _mesa_BindTexture);
   SET_DeleteTextures(exec, _mesa_DeleteTextures);
   SET_GenTextures(exec, _mesa_GenTextures);
#if _HAVE_FULL_GL
   SET_AreTexturesResident(exec, _mesa_AreTexturesResident);
   SET_ColorPointer(exec, _mesa_ColorPointer);
   SET_CopyTexImage1D(exec, _mesa_CopyTexImage1D);
   SET_CopyTexImage2D(exec, _mesa_CopyTexImage2D);
   SET_CopyTexSubImage1D(exec, _mesa_CopyTexSubImage1D);
   SET_CopyTexSubImage2D(exec, _mesa_CopyTexSubImage2D);
   SET_DisableClientState(exec, _mesa_DisableClientState);
   SET_EdgeFlagPointer(exec, _mesa_EdgeFlagPointer);
   SET_EnableClientState(exec, _mesa_EnableClientState);
   SET_GetPointerv(exec, _mesa_GetPointerv);
   SET_IndexPointer(exec, _mesa_IndexPointer);
   SET_InterleavedArrays(exec, _mesa_InterleavedArrays);
   SET_IsTexture(exec, _mesa_IsTexture);
   SET_NormalPointer(exec, _mesa_NormalPointer);
   SET_PopClientAttrib(exec, _mesa_PopClientAttrib);
   SET_PrioritizeTextures(exec, _mesa_PrioritizeTextures);
   SET_PushClientAttrib(exec, _mesa_PushClientAttrib);
   SET_TexCoordPointer(exec, _mesa_TexCoordPointer);
   SET_TexSubImage1D(exec, _mesa_TexSubImage1D);
   SET_TexSubImage2D(exec, _mesa_TexSubImage2D);
   SET_VertexPointer(exec, _mesa_VertexPointer);
#endif

   /* 1.2 */
#if _HAVE_FULL_GL
   SET_CopyTexSubImage3D(exec, _mesa_CopyTexSubImage3D);
   SET_TexImage3D(exec, _mesa_TexImage3D);
   SET_TexSubImage3D(exec, _mesa_TexSubImage3D);
#endif

   /* OpenGL 1.2  GL_ARB_imaging */
#if _HAVE_FULL_GL
   SET_BlendColor(exec, _mesa_BlendColor);
   SET_BlendEquation(exec, _mesa_BlendEquation);
   SET_BlendEquationSeparateEXT(exec, _mesa_BlendEquationSeparateEXT);
   SET_ColorSubTable(exec, _mesa_ColorSubTable);
   SET_ColorTable(exec, _mesa_ColorTable);
   SET_ColorTableParameterfv(exec, _mesa_ColorTableParameterfv);
   SET_ColorTableParameteriv(exec, _mesa_ColorTableParameteriv);
   SET_ConvolutionFilter1D(exec, _mesa_ConvolutionFilter1D);
   SET_ConvolutionFilter2D(exec, _mesa_ConvolutionFilter2D);
   SET_ConvolutionParameterf(exec, _mesa_ConvolutionParameterf);
   SET_ConvolutionParameterfv(exec, _mesa_ConvolutionParameterfv);
   SET_ConvolutionParameteri(exec, _mesa_ConvolutionParameteri);
   SET_ConvolutionParameteriv(exec, _mesa_ConvolutionParameteriv);
   SET_CopyColorSubTable(exec, _mesa_CopyColorSubTable);
   SET_CopyColorTable(exec, _mesa_CopyColorTable);
   SET_CopyConvolutionFilter1D(exec, _mesa_CopyConvolutionFilter1D);
   SET_CopyConvolutionFilter2D(exec, _mesa_CopyConvolutionFilter2D);
   SET_GetColorTable(exec, _mesa_GetColorTable);
   SET_GetColorTableParameterfv(exec, _mesa_GetColorTableParameterfv);
   SET_GetColorTableParameteriv(exec, _mesa_GetColorTableParameteriv);
   SET_GetConvolutionFilter(exec, _mesa_GetConvolutionFilter);
   SET_GetConvolutionParameterfv(exec, _mesa_GetConvolutionParameterfv);
   SET_GetConvolutionParameteriv(exec, _mesa_GetConvolutionParameteriv);
   SET_GetHistogram(exec, _mesa_GetHistogram);
   SET_GetHistogramParameterfv(exec, _mesa_GetHistogramParameterfv);
   SET_GetHistogramParameteriv(exec, _mesa_GetHistogramParameteriv);
   SET_GetMinmax(exec, _mesa_GetMinmax);
   SET_GetMinmaxParameterfv(exec, _mesa_GetMinmaxParameterfv);
   SET_GetMinmaxParameteriv(exec, _mesa_GetMinmaxParameteriv);
   SET_GetSeparableFilter(exec, _mesa_GetSeparableFilter);
   SET_Histogram(exec, _mesa_Histogram);
   SET_Minmax(exec, _mesa_Minmax);
   SET_ResetHistogram(exec, _mesa_ResetHistogram);
   SET_ResetMinmax(exec, _mesa_ResetMinmax);
   SET_SeparableFilter2D(exec, _mesa_SeparableFilter2D);
#endif

   /* OpenGL 2.0 */
   SET_StencilFuncSeparate(exec, _mesa_StencilFuncSeparate);
   SET_StencilMaskSeparate(exec, _mesa_StencilMaskSeparate);
   SET_StencilOpSeparate(exec, _mesa_StencilOpSeparate);
#if FEATURE_ARB_shader_objects
   SET_AttachShader(exec, _mesa_AttachShader);
   SET_CreateProgram(exec, _mesa_CreateProgram);
   SET_CreateShader(exec, _mesa_CreateShader);
   SET_DeleteProgram(exec, _mesa_DeleteProgram);
   SET_DeleteShader(exec, _mesa_DeleteShader);
   SET_DetachShader(exec, _mesa_DetachShader);
   SET_GetAttachedShaders(exec, _mesa_GetAttachedShaders);
   SET_GetProgramiv(exec, _mesa_GetProgramiv);
   SET_GetProgramInfoLog(exec, _mesa_GetProgramInfoLog);
   SET_GetShaderiv(exec, _mesa_GetShaderiv);
   SET_GetShaderInfoLog(exec, _mesa_GetShaderInfoLog);
   SET_IsProgram(exec, _mesa_IsProgram);
   SET_IsShader(exec, _mesa_IsShader);
#endif

   /* OpenGL 2.1 */
#if FEATURE_ARB_shader_objects
   SET_UniformMatrix2x3fv(exec, _mesa_UniformMatrix2x3fv);
   SET_UniformMatrix3x2fv(exec, _mesa_UniformMatrix3x2fv);
   SET_UniformMatrix2x4fv(exec, _mesa_UniformMatrix2x4fv);
   SET_UniformMatrix4x2fv(exec, _mesa_UniformMatrix4x2fv);
   SET_UniformMatrix3x4fv(exec, _mesa_UniformMatrix3x4fv);
   SET_UniformMatrix4x3fv(exec, _mesa_UniformMatrix4x3fv);
#endif


   /* 2. GL_EXT_blend_color */
#if 0
/*    SET_BlendColorEXT(exec, _mesa_BlendColorEXT); */
#endif

   /* 3. GL_EXT_polygon_offset */
#if _HAVE_FULL_GL
   SET_PolygonOffsetEXT(exec, _mesa_PolygonOffsetEXT);
#endif

   /* 6. GL_EXT_texture3d */
#if 0
/*    SET_CopyTexSubImage3DEXT(exec, _mesa_CopyTexSubImage3D); */
/*    SET_TexImage3DEXT(exec, _mesa_TexImage3DEXT); */
/*    SET_TexSubImage3DEXT(exec, _mesa_TexSubImage3D); */
#endif

   /* 11. GL_EXT_histogram */
#if 0
   SET_GetHistogramEXT(exec, _mesa_GetHistogram);
   SET_GetHistogramParameterfvEXT(exec, _mesa_GetHistogramParameterfv);
   SET_GetHistogramParameterivEXT(exec, _mesa_GetHistogramParameteriv);
   SET_GetMinmaxEXT(exec, _mesa_GetMinmax);
   SET_GetMinmaxParameterfvEXT(exec, _mesa_GetMinmaxParameterfv);
   SET_GetMinmaxParameterivEXT(exec, _mesa_GetMinmaxParameteriv);
#endif

   /* 14. SGI_color_table */
#if 0
   SET_ColorTableSGI(exec, _mesa_ColorTable);
   SET_ColorSubTableSGI(exec, _mesa_ColorSubTable);
   SET_GetColorTableSGI(exec, _mesa_GetColorTable);
   SET_GetColorTableParameterfvSGI(exec, _mesa_GetColorTableParameterfv);
   SET_GetColorTableParameterivSGI(exec, _mesa_GetColorTableParameteriv);
#endif

   /* 30. GL_EXT_vertex_array */
#if _HAVE_FULL_GL
   SET_ColorPointerEXT(exec, _mesa_ColorPointerEXT);
   SET_EdgeFlagPointerEXT(exec, _mesa_EdgeFlagPointerEXT);
   SET_IndexPointerEXT(exec, _mesa_IndexPointerEXT);
   SET_NormalPointerEXT(exec, _mesa_NormalPointerEXT);
   SET_TexCoordPointerEXT(exec, _mesa_TexCoordPointerEXT);
   SET_VertexPointerEXT(exec, _mesa_VertexPointerEXT);
#endif

   /* 37. GL_EXT_blend_minmax */
#if 0
   SET_BlendEquationEXT(exec, _mesa_BlendEquationEXT);
#endif

   /* 54. GL_EXT_point_parameters */
#if _HAVE_FULL_GL
   SET_PointParameterfEXT(exec, _mesa_PointParameterfEXT);
   SET_PointParameterfvEXT(exec, _mesa_PointParameterfvEXT);
#endif

   /* 97. GL_EXT_compiled_vertex_array */
#if _HAVE_FULL_GL
   SET_LockArraysEXT(exec, _mesa_LockArraysEXT);
   SET_UnlockArraysEXT(exec, _mesa_UnlockArraysEXT);
#endif

   /* 148. GL_EXT_multi_draw_arrays */
#if _HAVE_FULL_GL
   SET_MultiDrawArraysEXT(exec, _mesa_MultiDrawArraysEXT);
   SET_MultiDrawElementsEXT(exec, _mesa_MultiDrawElementsEXT);
#endif

   /* 173. GL_INGR_blend_func_separate */
#if _HAVE_FULL_GL
   SET_BlendFuncSeparateEXT(exec, _mesa_BlendFuncSeparateEXT);
#endif

   /* 196. GL_MESA_resize_buffers */
#if _HAVE_FULL_GL
   SET_ResizeBuffersMESA(exec, _mesa_ResizeBuffersMESA);
#endif

   /* 197. GL_MESA_window_pos */
#if _HAVE_FULL_GL
   SET_WindowPos2dMESA(exec, _mesa_WindowPos2dMESA);
   SET_WindowPos2dvMESA(exec, _mesa_WindowPos2dvMESA);
   SET_WindowPos2fMESA(exec, _mesa_WindowPos2fMESA);
   SET_WindowPos2fvMESA(exec, _mesa_WindowPos2fvMESA);
   SET_WindowPos2iMESA(exec, _mesa_WindowPos2iMESA);
   SET_WindowPos2ivMESA(exec, _mesa_WindowPos2ivMESA);
   SET_WindowPos2sMESA(exec, _mesa_WindowPos2sMESA);
   SET_WindowPos2svMESA(exec, _mesa_WindowPos2svMESA);
   SET_WindowPos3dMESA(exec, _mesa_WindowPos3dMESA);
   SET_WindowPos3dvMESA(exec, _mesa_WindowPos3dvMESA);
   SET_WindowPos3fMESA(exec, _mesa_WindowPos3fMESA);
   SET_WindowPos3fvMESA(exec, _mesa_WindowPos3fvMESA);
   SET_WindowPos3iMESA(exec, _mesa_WindowPos3iMESA);
   SET_WindowPos3ivMESA(exec, _mesa_WindowPos3ivMESA);
   SET_WindowPos3sMESA(exec, _mesa_WindowPos3sMESA);
   SET_WindowPos3svMESA(exec, _mesa_WindowPos3svMESA);
   SET_WindowPos4dMESA(exec, _mesa_WindowPos4dMESA);
   SET_WindowPos4dvMESA(exec, _mesa_WindowPos4dvMESA);
   SET_WindowPos4fMESA(exec, _mesa_WindowPos4fMESA);
   SET_WindowPos4fvMESA(exec, _mesa_WindowPos4fvMESA);
   SET_WindowPos4iMESA(exec, _mesa_WindowPos4iMESA);
   SET_WindowPos4ivMESA(exec, _mesa_WindowPos4ivMESA);
   SET_WindowPos4sMESA(exec, _mesa_WindowPos4sMESA);
   SET_WindowPos4svMESA(exec, _mesa_WindowPos4svMESA);
#endif

   /* 200. GL_IBM_multimode_draw_arrays */
#if _HAVE_FULL_GL
   SET_MultiModeDrawArraysIBM(exec, _mesa_MultiModeDrawArraysIBM);
   SET_MultiModeDrawElementsIBM(exec, _mesa_MultiModeDrawElementsIBM);
#endif

   /* 233. GL_NV_vertex_program */
#if FEATURE_NV_vertex_program
   SET_BindProgramNV(exec, _mesa_BindProgram);
   SET_DeleteProgramsNV(exec, _mesa_DeletePrograms);
   SET_ExecuteProgramNV(exec, _mesa_ExecuteProgramNV);
   SET_GenProgramsNV(exec, _mesa_GenPrograms);
   SET_AreProgramsResidentNV(exec, _mesa_AreProgramsResidentNV);
   SET_RequestResidentProgramsNV(exec, _mesa_RequestResidentProgramsNV);
   SET_GetProgramParameterfvNV(exec, _mesa_GetProgramParameterfvNV);
   SET_GetProgramParameterdvNV(exec, _mesa_GetProgramParameterdvNV);
   SET_GetProgramivNV(exec, _mesa_GetProgramivNV);
   SET_GetProgramStringNV(exec, _mesa_GetProgramStringNV);
   SET_GetTrackMatrixivNV(exec, _mesa_GetTrackMatrixivNV);
   SET_GetVertexAttribdvNV(exec, _mesa_GetVertexAttribdvNV);
   SET_GetVertexAttribfvNV(exec, _mesa_GetVertexAttribfvNV);
   SET_GetVertexAttribivNV(exec, _mesa_GetVertexAttribivNV);
   SET_GetVertexAttribPointervNV(exec, _mesa_GetVertexAttribPointervNV);
   SET_IsProgramNV(exec, _mesa_IsProgramARB);
   SET_LoadProgramNV(exec, _mesa_LoadProgramNV);
   SET_ProgramEnvParameter4dARB(exec, _mesa_ProgramEnvParameter4dARB); /* alias to ProgramParameter4dNV */
   SET_ProgramEnvParameter4dvARB(exec, _mesa_ProgramEnvParameter4dvARB);  /* alias to ProgramParameter4dvNV */
   SET_ProgramEnvParameter4fARB(exec, _mesa_ProgramEnvParameter4fARB);  /* alias to ProgramParameter4fNV */
   SET_ProgramEnvParameter4fvARB(exec, _mesa_ProgramEnvParameter4fvARB);  /* alias to ProgramParameter4fvNV */
   SET_ProgramParameters4dvNV(exec, _mesa_ProgramParameters4dvNV);
   SET_ProgramParameters4fvNV(exec, _mesa_ProgramParameters4fvNV);
   SET_TrackMatrixNV(exec, _mesa_TrackMatrixNV);
   SET_VertexAttribPointerNV(exec, _mesa_VertexAttribPointerNV);
   /* glVertexAttrib*NV functions handled in api_loopback.c */
#endif

   /* 273. GL_APPLE_vertex_array_object */
   SET_BindVertexArrayAPPLE(exec, _mesa_BindVertexArrayAPPLE);
   SET_DeleteVertexArraysAPPLE(exec, _mesa_DeleteVertexArraysAPPLE);
   SET_GenVertexArraysAPPLE(exec, _mesa_GenVertexArraysAPPLE);
   SET_IsVertexArrayAPPLE(exec, _mesa_IsVertexArrayAPPLE);

   /* 282. GL_NV_fragment_program */
#if FEATURE_NV_fragment_program
   SET_ProgramNamedParameter4fNV(exec, _mesa_ProgramNamedParameter4fNV);
   SET_ProgramNamedParameter4dNV(exec, _mesa_ProgramNamedParameter4dNV);
   SET_ProgramNamedParameter4fvNV(exec, _mesa_ProgramNamedParameter4fvNV);
   SET_ProgramNamedParameter4dvNV(exec, _mesa_ProgramNamedParameter4dvNV);
   SET_GetProgramNamedParameterfvNV(exec, _mesa_GetProgramNamedParameterfvNV);
   SET_GetProgramNamedParameterdvNV(exec, _mesa_GetProgramNamedParameterdvNV);
   SET_ProgramLocalParameter4dARB(exec, _mesa_ProgramLocalParameter4dARB);
   SET_ProgramLocalParameter4dvARB(exec, _mesa_ProgramLocalParameter4dvARB);
   SET_ProgramLocalParameter4fARB(exec, _mesa_ProgramLocalParameter4fARB);
   SET_ProgramLocalParameter4fvARB(exec, _mesa_ProgramLocalParameter4fvARB);
   SET_GetProgramLocalParameterdvARB(exec, _mesa_GetProgramLocalParameterdvARB);
   SET_GetProgramLocalParameterfvARB(exec, _mesa_GetProgramLocalParameterfvARB);
#endif

   /* 262. GL_NV_point_sprite */
#if _HAVE_FULL_GL
   SET_PointParameteriNV(exec, _mesa_PointParameteriNV);
   SET_PointParameterivNV(exec, _mesa_PointParameterivNV);
#endif

   /* 268. GL_EXT_stencil_two_side */
#if _HAVE_FULL_GL
   SET_ActiveStencilFaceEXT(exec, _mesa_ActiveStencilFaceEXT);
#endif

   /* ???. GL_EXT_depth_bounds_test */
   SET_DepthBoundsEXT(exec, _mesa_DepthBoundsEXT);

   /* ARB 1. GL_ARB_multitexture */
#if _HAVE_FULL_GL
   SET_ActiveTextureARB(exec, _mesa_ActiveTextureARB);
   SET_ClientActiveTextureARB(exec, _mesa_ClientActiveTextureARB);
#endif

   /* ARB 3. GL_ARB_transpose_matrix */
#if _HAVE_FULL_GL
   SET_LoadTransposeMatrixdARB(exec, _mesa_LoadTransposeMatrixdARB);
   SET_LoadTransposeMatrixfARB(exec, _mesa_LoadTransposeMatrixfARB);
   SET_MultTransposeMatrixdARB(exec, _mesa_MultTransposeMatrixdARB);
   SET_MultTransposeMatrixfARB(exec, _mesa_MultTransposeMatrixfARB);
#endif

   /* ARB 5. GL_ARB_multisample */
#if _HAVE_FULL_GL
   SET_SampleCoverageARB(exec, _mesa_SampleCoverageARB);
#endif

   /* ARB 12. GL_ARB_texture_compression */
#if _HAVE_FULL_GL
   SET_CompressedTexImage3DARB(exec, _mesa_CompressedTexImage3DARB);
   SET_CompressedTexImage2DARB(exec, _mesa_CompressedTexImage2DARB);
   SET_CompressedTexImage1DARB(exec, _mesa_CompressedTexImage1DARB);
   SET_CompressedTexSubImage3DARB(exec, _mesa_CompressedTexSubImage3DARB);
   SET_CompressedTexSubImage2DARB(exec, _mesa_CompressedTexSubImage2DARB);
   SET_CompressedTexSubImage1DARB(exec, _mesa_CompressedTexSubImage1DARB);
   SET_GetCompressedTexImageARB(exec, _mesa_GetCompressedTexImageARB);
#endif

   /* ARB 14. GL_ARB_point_parameters */
   /* reuse EXT_point_parameters functions */

   /* ARB 26. GL_ARB_vertex_program */
   /* ARB 27. GL_ARB_fragment_program */
#if FEATURE_ARB_vertex_program || FEATURE_ARB_fragment_program
   /* glVertexAttrib1sARB aliases glVertexAttrib1sNV */
   /* glVertexAttrib1fARB aliases glVertexAttrib1fNV */
   /* glVertexAttrib1dARB aliases glVertexAttrib1dNV */
   /* glVertexAttrib2sARB aliases glVertexAttrib2sNV */
   /* glVertexAttrib2fARB aliases glVertexAttrib2fNV */
   /* glVertexAttrib2dARB aliases glVertexAttrib2dNV */
   /* glVertexAttrib3sARB aliases glVertexAttrib3sNV */
   /* glVertexAttrib3fARB aliases glVertexAttrib3fNV */
   /* glVertexAttrib3dARB aliases glVertexAttrib3dNV */
   /* glVertexAttrib4sARB aliases glVertexAttrib4sNV */
   /* glVertexAttrib4fARB aliases glVertexAttrib4fNV */
   /* glVertexAttrib4dARB aliases glVertexAttrib4dNV */
   /* glVertexAttrib4NubARB aliases glVertexAttrib4NubNV */
   /* glVertexAttrib1svARB aliases glVertexAttrib1svNV */
   /* glVertexAttrib1fvARB aliases glVertexAttrib1fvNV */
   /* glVertexAttrib1dvARB aliases glVertexAttrib1dvNV */
   /* glVertexAttrib2svARB aliases glVertexAttrib2svNV */
   /* glVertexAttrib2fvARB aliases glVertexAttrib2fvNV */
   /* glVertexAttrib2dvARB aliases glVertexAttrib2dvNV */
   /* glVertexAttrib3svARB aliases glVertexAttrib3svNV */
   /* glVertexAttrib3fvARB aliases glVertexAttrib3fvNV */
   /* glVertexAttrib3dvARB aliases glVertexAttrib3dvNV */
   /* glVertexAttrib4svARB aliases glVertexAttrib4svNV */
   /* glVertexAttrib4fvARB aliases glVertexAttrib4fvNV */
   /* glVertexAttrib4dvARB aliases glVertexAttrib4dvNV */
   /* glVertexAttrib4NubvARB aliases glVertexAttrib4NubvNV */
   /* glVertexAttrib4bvARB handled in api_loopback.c */
   /* glVertexAttrib4ivARB handled in api_loopback.c */
   /* glVertexAttrib4ubvARB handled in api_loopback.c */
   /* glVertexAttrib4usvARB handled in api_loopback.c */
   /* glVertexAttrib4uivARB handled in api_loopback.c */
   /* glVertexAttrib4NbvARB handled in api_loopback.c */
   /* glVertexAttrib4NsvARB handled in api_loopback.c */
   /* glVertexAttrib4NivARB handled in api_loopback.c */
   /* glVertexAttrib4NusvARB handled in api_loopback.c */
   /* glVertexAttrib4NuivARB handled in api_loopback.c */
   SET_VertexAttribPointerARB(exec, _mesa_VertexAttribPointerARB);
   SET_EnableVertexAttribArrayARB(exec, _mesa_EnableVertexAttribArrayARB);
   SET_DisableVertexAttribArrayARB(exec, _mesa_DisableVertexAttribArrayARB);
   SET_ProgramStringARB(exec, _mesa_ProgramStringARB);
   /* glBindProgramARB aliases glBindProgramNV */
   /* glDeleteProgramsARB aliases glDeleteProgramsNV */
   /* glGenProgramsARB aliases glGenProgramsNV */
   /* glIsProgramARB aliases glIsProgramNV */
   SET_GetVertexAttribdvARB(exec, _mesa_GetVertexAttribdvARB);
   SET_GetVertexAttribfvARB(exec, _mesa_GetVertexAttribfvARB);
   SET_GetVertexAttribivARB(exec, _mesa_GetVertexAttribivARB);
   /* glGetVertexAttribPointervARB aliases glGetVertexAttribPointervNV */
   SET_ProgramEnvParameter4dARB(exec, _mesa_ProgramEnvParameter4dARB);
   SET_ProgramEnvParameter4dvARB(exec, _mesa_ProgramEnvParameter4dvARB);
   SET_ProgramEnvParameter4fARB(exec, _mesa_ProgramEnvParameter4fARB);
   SET_ProgramEnvParameter4fvARB(exec, _mesa_ProgramEnvParameter4fvARB);
   SET_ProgramLocalParameter4dARB(exec, _mesa_ProgramLocalParameter4dARB);
   SET_ProgramLocalParameter4dvARB(exec, _mesa_ProgramLocalParameter4dvARB);
   SET_ProgramLocalParameter4fARB(exec, _mesa_ProgramLocalParameter4fARB);
   SET_ProgramLocalParameter4fvARB(exec, _mesa_ProgramLocalParameter4fvARB);
   SET_GetProgramEnvParameterdvARB(exec, _mesa_GetProgramEnvParameterdvARB);
   SET_GetProgramEnvParameterfvARB(exec, _mesa_GetProgramEnvParameterfvARB);
   SET_GetProgramLocalParameterdvARB(exec, _mesa_GetProgramLocalParameterdvARB);
   SET_GetProgramLocalParameterfvARB(exec, _mesa_GetProgramLocalParameterfvARB);
   SET_GetProgramivARB(exec, _mesa_GetProgramivARB);
   SET_GetProgramStringARB(exec, _mesa_GetProgramStringARB);
#endif

   /* ARB 28. GL_ARB_vertex_buffer_object */
#if FEATURE_ARB_vertex_buffer_object
   SET_BindBufferARB(exec, _mesa_BindBufferARB);
   SET_BufferDataARB(exec, _mesa_BufferDataARB);
   SET_BufferSubDataARB(exec, _mesa_BufferSubDataARB);
   SET_DeleteBuffersARB(exec, _mesa_DeleteBuffersARB);
   SET_GenBuffersARB(exec, _mesa_GenBuffersARB);
   SET_GetBufferParameterivARB(exec, _mesa_GetBufferParameterivARB);
   SET_GetBufferPointervARB(exec, _mesa_GetBufferPointervARB);
   SET_GetBufferSubDataARB(exec, _mesa_GetBufferSubDataARB);
   SET_IsBufferARB(exec, _mesa_IsBufferARB);
   SET_MapBufferARB(exec, _mesa_MapBufferARB);
   SET_UnmapBufferARB(exec, _mesa_UnmapBufferARB);
#endif

   /* ARB 29. GL_ARB_occlusion_query */
#if FEATURE_ARB_occlusion_query
   SET_GenQueriesARB(exec, _mesa_GenQueriesARB);
   SET_DeleteQueriesARB(exec, _mesa_DeleteQueriesARB);
   SET_IsQueryARB(exec, _mesa_IsQueryARB);
   SET_BeginQueryARB(exec, _mesa_BeginQueryARB);
   SET_EndQueryARB(exec, _mesa_EndQueryARB);
   SET_GetQueryivARB(exec, _mesa_GetQueryivARB);
   SET_GetQueryObjectivARB(exec, _mesa_GetQueryObjectivARB);
   SET_GetQueryObjectuivARB(exec, _mesa_GetQueryObjectuivARB);
#endif

   /* ARB 37. GL_ARB_draw_buffers */
   SET_DrawBuffersARB(exec, _mesa_DrawBuffersARB);
   
#if FEATURE_ARB_shader_objects
   SET_DeleteObjectARB(exec, _mesa_DeleteObjectARB);
   SET_GetHandleARB(exec, _mesa_GetHandleARB);
   SET_DetachObjectARB(exec, _mesa_DetachObjectARB);
   SET_CreateShaderObjectARB(exec, _mesa_CreateShaderObjectARB);
   SET_ShaderSourceARB(exec, _mesa_ShaderSourceARB);
   SET_CompileShaderARB(exec, _mesa_CompileShaderARB);
   SET_CreateProgramObjectARB(exec, _mesa_CreateProgramObjectARB);
   SET_AttachObjectARB(exec, _mesa_AttachObjectARB);
   SET_LinkProgramARB(exec, _mesa_LinkProgramARB);
   SET_UseProgramObjectARB(exec, _mesa_UseProgramObjectARB);
   SET_ValidateProgramARB(exec, _mesa_ValidateProgramARB);
   SET_Uniform1fARB(exec, _mesa_Uniform1fARB);
   SET_Uniform2fARB(exec, _mesa_Uniform2fARB);
   SET_Uniform3fARB(exec, _mesa_Uniform3fARB);
   SET_Uniform4fARB(exec, _mesa_Uniform4fARB);
   SET_Uniform1iARB(exec, _mesa_Uniform1iARB);
   SET_Uniform2iARB(exec, _mesa_Uniform2iARB);
   SET_Uniform3iARB(exec, _mesa_Uniform3iARB);
   SET_Uniform4iARB(exec, _mesa_Uniform4iARB);
   SET_Uniform1fvARB(exec, _mesa_Uniform1fvARB);
   SET_Uniform2fvARB(exec, _mesa_Uniform2fvARB);
   SET_Uniform3fvARB(exec, _mesa_Uniform3fvARB);
   SET_Uniform4fvARB(exec, _mesa_Uniform4fvARB);
   SET_Uniform1ivARB(exec, _mesa_Uniform1ivARB);
   SET_Uniform2ivARB(exec, _mesa_Uniform2ivARB);
   SET_Uniform3ivARB(exec, _mesa_Uniform3ivARB);
   SET_Uniform4ivARB(exec, _mesa_Uniform4ivARB);
   SET_UniformMatrix2fvARB(exec, _mesa_UniformMatrix2fvARB);
   SET_UniformMatrix3fvARB(exec, _mesa_UniformMatrix3fvARB);
   SET_UniformMatrix4fvARB(exec, _mesa_UniformMatrix4fvARB);
   SET_GetObjectParameterfvARB(exec, _mesa_GetObjectParameterfvARB);
   SET_GetObjectParameterivARB(exec, _mesa_GetObjectParameterivARB);
   SET_GetInfoLogARB(exec, _mesa_GetInfoLogARB);
   SET_GetAttachedObjectsARB(exec, _mesa_GetAttachedObjectsARB);
   SET_GetUniformLocationARB(exec, _mesa_GetUniformLocationARB);
   SET_GetActiveUniformARB(exec, _mesa_GetActiveUniformARB);
   SET_GetUniformfvARB(exec, _mesa_GetUniformfvARB);
   SET_GetUniformivARB(exec, _mesa_GetUniformivARB);
   SET_GetShaderSourceARB(exec, _mesa_GetShaderSourceARB);
#endif    /* FEATURE_ARB_shader_objects */

#if FEATURE_ARB_vertex_shader
   SET_BindAttribLocationARB(exec, _mesa_BindAttribLocationARB);
   SET_GetActiveAttribARB(exec, _mesa_GetActiveAttribARB);
   SET_GetAttribLocationARB(exec, _mesa_GetAttribLocationARB);
#endif    /* FEATURE_ARB_vertex_shader */

  /* GL_ATI_fragment_shader */
#if FEATURE_ATI_fragment_shader
   SET_GenFragmentShadersATI(exec, _mesa_GenFragmentShadersATI);
   SET_BindFragmentShaderATI(exec, _mesa_BindFragmentShaderATI);
   SET_DeleteFragmentShaderATI(exec, _mesa_DeleteFragmentShaderATI);
   SET_BeginFragmentShaderATI(exec, _mesa_BeginFragmentShaderATI);
   SET_EndFragmentShaderATI(exec, _mesa_EndFragmentShaderATI);
   SET_PassTexCoordATI(exec, _mesa_PassTexCoordATI);
   SET_SampleMapATI(exec, _mesa_SampleMapATI);
   SET_ColorFragmentOp1ATI(exec, _mesa_ColorFragmentOp1ATI);
   SET_ColorFragmentOp2ATI(exec, _mesa_ColorFragmentOp2ATI);
   SET_ColorFragmentOp3ATI(exec, _mesa_ColorFragmentOp3ATI);
   SET_AlphaFragmentOp1ATI(exec, _mesa_AlphaFragmentOp1ATI);
   SET_AlphaFragmentOp2ATI(exec, _mesa_AlphaFragmentOp2ATI);
   SET_AlphaFragmentOp3ATI(exec, _mesa_AlphaFragmentOp3ATI);
   SET_SetFragmentShaderConstantATI(exec, _mesa_SetFragmentShaderConstantATI);
#endif

#if FEATURE_EXT_framebuffer_object
   SET_IsRenderbufferEXT(exec, _mesa_IsRenderbufferEXT);
   SET_BindRenderbufferEXT(exec, _mesa_BindRenderbufferEXT);
   SET_DeleteRenderbuffersEXT(exec, _mesa_DeleteRenderbuffersEXT);
   SET_GenRenderbuffersEXT(exec, _mesa_GenRenderbuffersEXT);
   SET_RenderbufferStorageEXT(exec, _mesa_RenderbufferStorageEXT);
   SET_GetRenderbufferParameterivEXT(exec, _mesa_GetRenderbufferParameterivEXT);
   SET_IsFramebufferEXT(exec, _mesa_IsFramebufferEXT);
   SET_BindFramebufferEXT(exec, _mesa_BindFramebufferEXT);
   SET_DeleteFramebuffersEXT(exec, _mesa_DeleteFramebuffersEXT);
   SET_GenFramebuffersEXT(exec, _mesa_GenFramebuffersEXT);
   SET_CheckFramebufferStatusEXT(exec, _mesa_CheckFramebufferStatusEXT);
   SET_FramebufferTexture1DEXT(exec, _mesa_FramebufferTexture1DEXT);
   SET_FramebufferTexture2DEXT(exec, _mesa_FramebufferTexture2DEXT);
   SET_FramebufferTexture3DEXT(exec, _mesa_FramebufferTexture3DEXT);
   SET_FramebufferRenderbufferEXT(exec, _mesa_FramebufferRenderbufferEXT);
   SET_GetFramebufferAttachmentParameterivEXT(exec, _mesa_GetFramebufferAttachmentParameterivEXT);
   SET_GenerateMipmapEXT(exec, _mesa_GenerateMipmapEXT);
#endif

#if FEATURE_EXT_timer_query
   SET_GetQueryObjecti64vEXT(exec, _mesa_GetQueryObjecti64vEXT);
   SET_GetQueryObjectui64vEXT(exec, _mesa_GetQueryObjectui64vEXT);
#endif

#if FEATURE_EXT_framebuffer_blit
   SET_BlitFramebufferEXT(exec, _mesa_BlitFramebufferEXT);
#endif

   /* GL_EXT_gpu_program_parameters */
#if FEATURE_ARB_vertex_program || FEATURE_ARB_fragment_program
   SET_ProgramEnvParameters4fvEXT(exec, _mesa_ProgramEnvParameters4fvEXT);
   SET_ProgramLocalParameters4fvEXT(exec, _mesa_ProgramLocalParameters4fvEXT);
#endif

   /* GL_MESA_texture_array / GL_EXT_texture_array */
#if FEATURE_EXT_framebuffer_object
   SET_FramebufferTextureLayerEXT(exec, _mesa_FramebufferTextureLayerEXT);
#endif

   /* GL_ATI_separate_stencil */
   SET_StencilFuncSeparateATI(exec, _mesa_StencilFuncSeparateATI);
}



/**********************************************************************/
/** \name State update logic */
/*@@{*/
d177 5
a181 1
 * Update derived vertex/fragment program state.
d184 1
a184 1
update_program(GLcontext *ctx)
a185 2
   const struct gl_shader_program *shProg = ctx->Shader.CurrentProgram;

d193 23
d219 2
a220 1
    * pointers to the programs that should be enabled/used.
d227 4
d233 22
a254 1
   _mesa_reference_fragprog(ctx, &ctx->FragmentProgram._Current, NULL);
d256 5
a260 1
   if (shProg && shProg->LinkStatus) {
d262 10
a271 2
      /* XXX this isn't quite right, since we may have either a vertex
       * _or_ fragment shader (not always both).
d274 3
a276 3
                               shProg->VertexProgram);
      _mesa_reference_fragprog(ctx, &ctx->FragmentProgram._Current,
                               shProg->FragmentProgram);
d279 3
a281 16
      if (ctx->VertexProgram._Enabled) {
         /* use user-defined vertex program */
         _mesa_reference_vertprog(ctx, &ctx->VertexProgram._Current,
                                  ctx->VertexProgram.Current);
      }
      else if (ctx->VertexProgram._MaintainTnlProgram) {
         /* Use vertex program generated from fixed-function state.
          * The _Current pointer will get set in
          * _tnl_UpdateFixedFunctionProgram() later if appropriate.
          */
         _mesa_reference_vertprog(ctx, &ctx->VertexProgram._Current, NULL);
      }
      else {
         /* no vertex program */
         _mesa_reference_vertprog(ctx, &ctx->VertexProgram._Current, NULL);
      }
d283 7
a289 4
      if (ctx->FragmentProgram._Enabled) {
         /* use user-defined vertex program */
         _mesa_reference_fragprog(ctx, &ctx->FragmentProgram._Current,
                                  ctx->FragmentProgram.Current);
d291 7
a297 10
      else if (ctx->FragmentProgram._MaintainTexEnvProgram) {
         /* Use fragment program generated from fixed-function state.
          * The _Current pointer will get set in _mesa_UpdateTexEnvProgram()
          * later if appropriate.
          */
         _mesa_reference_fragprog(ctx, &ctx->FragmentProgram._Current, NULL);
      }
      else {
         /* no fragment program */
         _mesa_reference_fragprog(ctx, &ctx->FragmentProgram._Current, NULL);
d301 1
a301 12
   if (ctx->VertexProgram._Current)
      assert(ctx->VertexProgram._Current->Base.Parameters);
   if (ctx->FragmentProgram._Current)
      assert(ctx->FragmentProgram._Current->Base.Parameters);


   ctx->FragmentProgram._Active = ctx->FragmentProgram._Enabled;
   if (ctx->FragmentProgram._MaintainTexEnvProgram &&
       !ctx->FragmentProgram._Enabled) {
      if (ctx->FragmentProgram._UseTexEnvProgram)
	 ctx->FragmentProgram._Active = GL_TRUE;
   }
d461 2
d467 17
a483 2
   if (new_state & _NEW_PROGRAM)
      update_program( ctx );
d506 1
d509 1
a531 5
   if (ctx->FragmentProgram._MaintainTexEnvProgram) {
      if (new_state & (_NEW_TEXTURE | _DD_NEW_SEPARATE_SPECULAR | _NEW_FOG))
	 _mesa_UpdateTexEnvProgram(ctx);
   }

d544 8
d561 1
a561 1
   new_state = ctx->NewState;
a576 6



/*@@}*/


@


1.3
log
@Update to Mesa 7.0.3. tested my oga@@ and johan@@
@
text
@d38 1
a38 1
#include "arbprogram.h"
d41 1
a41 1
#include "atifragshader.h"
d88 1
a88 1
#include "nvprogram.h"
d91 2
a92 2
#include "nvprogram.h"
#include "program.h"
d99 1
a99 1
#include "dispatch.h"
d538 4
a541 4
   SET_ProgramParameter4dNV(exec, _mesa_ProgramParameter4dNV);
   SET_ProgramParameter4dvNV(exec, _mesa_ProgramParameter4dvNV);
   SET_ProgramParameter4fNV(exec, _mesa_ProgramParameter4fNV);
   SET_ProgramParameter4fvNV(exec, _mesa_ProgramParameter4fvNV);
d816 5
d833 1
a833 1
update_separate_specular( GLcontext *ctx )
d981 1
a981 1
   ctx->FragmentProgram._Current = NULL;
d988 4
a991 2
      ctx->VertexProgram._Current = shProg->VertexProgram;
      ctx->FragmentProgram._Current = shProg->FragmentProgram;
d996 2
a997 1
         ctx->VertexProgram._Current = ctx->VertexProgram.Current;
d1004 1
a1004 1
         ctx->VertexProgram._Current = NULL;
d1008 1
a1008 1
         ctx->VertexProgram._Current = NULL;
d1013 2
a1014 1
         ctx->FragmentProgram._Current = ctx->FragmentProgram.Current;
d1021 1
a1021 1
         ctx->FragmentProgram._Current = NULL;
d1025 1
a1025 1
         ctx->FragmentProgram._Current = NULL;
d1029 6
d1064 14
d1095 1
a1095 1
update_polygon( GLcontext *ctx )
d1102 3
a1104 4
   /* Any Polygon offsets enabled? */
   if (ctx->Polygon.OffsetPoint ||
       ctx->Polygon.OffsetLine ||
       ctx->Polygon.OffsetFill) {
a1105 1
   }
d1127 1
a1127 1
      if (ctx->Point._Size != 1.0F)
d1141 1
a1141 1
      if (ctx->Line._Width != 1.0)
d1239 3
@


1.2
log
@Update to Mesa 7.0.2. Tested by naddy@@ (full ports build), simon@@
and oga@@ (with dri enabled).
@
text
@d963 1
a963 1
      && ctx->ATIFragmentShader.Current->Instructions;
@


1.1
log
@Initial revision
@
text
@a72 3
#if FEATURE_ARB_occlusion_query || FEATURE_EXT_timer_query
#include "occlude.h"
#endif
d76 3
d96 1
a96 1
#include "shaderobjects.h"
a306 1
   SET_AreTexturesResidentEXT(exec, _mesa_AreTexturesResident);
a314 1
   SET_GenTexturesEXT(exec, _mesa_GenTextures);
a318 1
   SET_IsTextureEXT(exec, _mesa_IsTexture);
a355 1
   SET_GetColorTableSGI(exec, _mesa_GetColorTable);
a356 1
   SET_GetColorTableParameterfvSGI(exec, _mesa_GetColorTableParameterfv);
a357 1
   SET_GetColorTableParameterivSGI(exec, _mesa_GetColorTableParameteriv);
a358 1
   SET_GetConvolutionFilterEXT(exec, _mesa_GetConvolutionFilter);
a359 1
   SET_GetConvolutionParameterfvEXT(exec, _mesa_GetConvolutionParameterfv);
a360 1
   SET_GetConvolutionParameterivEXT(exec, _mesa_GetConvolutionParameteriv);
a361 1
   SET_GetHistogramEXT(exec, _mesa_GetHistogram);
a362 1
   SET_GetHistogramParameterfvEXT(exec, _mesa_GetHistogramParameterfv);
a363 1
   SET_GetHistogramParameterivEXT(exec, _mesa_GetHistogramParameteriv);
a364 1
   SET_GetMinmaxEXT(exec, _mesa_GetMinmax);
a365 1
   SET_GetMinmaxParameterfvEXT(exec, _mesa_GetMinmaxParameterfv);
a366 1
   SET_GetMinmaxParameterivEXT(exec, _mesa_GetMinmaxParameteriv);
a367 1
   SET_GetSeparableFilterEXT(exec, _mesa_GetSeparableFilter);
d379 26
d424 1
a424 1
#if _HAVE_FULL_GL
a436 2
#endif
#if _HAVE_FULL_GL
d536 1
a536 1
   SET_IsProgramNV(exec, _mesa_IsProgram);
d815 3
d848 1
a848 5
   if (ctx->ShaderObjects._VertexShaderPresent
       && ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_GENERIC0].Enabled) {
      min = ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_GENERIC0]._MaxElement;
   }
   else if (ctx->VertexProgram._Enabled
d915 2
a916 2
       && ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_SEVEN].Enabled) {
      min = MIN2(min, ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_SEVEN]._MaxElement);
d932 1
a932 1
   if (ctx->ShaderObjects._VertexShaderPresent) {
d955 3
a957 4
   /* For now, just set the _Enabled (really enabled) flags.
    * In the future we may have to check other state to be sure we really
    * have a runable program or shader.
    */
a963 3
      
   ctx->FragmentProgram._Current = ctx->FragmentProgram.Current;
   ctx->FragmentProgram._Active = ctx->FragmentProgram._Enabled;
d965 54
a1018 7
   if (ctx->_MaintainTexEnvProgram && !ctx->FragmentProgram._Enabled) {
#if 0
      if (!ctx->_TexEnvProgram)
	 ctx->_TexEnvProgram = (struct gl_fragment_program *)
	    ctx->Driver.NewProgram(ctx, GL_FRAGMENT_PROGRAM_ARB, 0);
      ctx->FragmentProgram._Current = ctx->_TexEnvProgram;
#endif
d1020 4
a1023 1
      if (ctx->_UseTexEnvProgram)
d1057 96
a1152 3
   ctx->Color._LogicOpEnabled = (ctx->Color.ColorLogicOpEnabled ||
                                 (ctx->Color.BlendEnabled &&
                                  ctx->Color.BlendEquationRGB == GL_LOGIC_OP));
d1154 1
d1158 3
a1160 4
 * If __GLcontextRec::NewState is non-zero then this function \b must be called
 * before rendering any primitive.  Basically, function pointers and
 * miscellaneous flags are updated to reflect the current state of the state
 * machine.
d1166 1
a1166 1
 * _mesa_update_buffer_bounds(), _mesa_update_polygon(),
d1170 1
a1170 1
_mesa_update_state( GLcontext *ctx )
a1191 3
   if (new_state & _NEW_POINT)
      _mesa_update_point( ctx );

d1193 1
a1193 1
      _mesa_update_polygon( ctx );
d1216 7
a1222 1
   if (ctx->_MaintainTexEnvProgram) {
d1254 13
d1268 2
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d307 1
d316 1
d321 1
d359 1
d361 1
d363 1
d365 1
d367 1
d369 1
d371 1
d373 1
d375 1
d377 1
d379 1
d381 1
d383 1
a394 26
#if FEATURE_ARB_shader_objects
   SET_AttachShader(exec, _mesa_AttachShader);
   SET_CreateProgram(exec, _mesa_CreateProgram);
   SET_CreateShader(exec, _mesa_CreateShader);
   SET_DeleteProgram(exec, _mesa_DeleteProgram);
   SET_DeleteShader(exec, _mesa_DeleteShader);
   SET_DetachShader(exec, _mesa_DetachShader);
   SET_GetAttachedShaders(exec, _mesa_GetAttachedShaders);
   SET_GetProgramiv(exec, _mesa_GetProgramiv);
   SET_GetProgramInfoLog(exec, _mesa_GetProgramInfoLog);
   SET_GetShaderiv(exec, _mesa_GetShaderiv);
   SET_GetShaderInfoLog(exec, _mesa_GetShaderInfoLog);
   SET_IsProgram(exec, _mesa_IsProgram);
   SET_IsShader(exec, _mesa_IsShader);
#endif

   /* OpenGL 2.1 */
#if FEATURE_ARB_shader_objects
   SET_UniformMatrix2x3fv(exec, _mesa_UniformMatrix2x3fv);
   SET_UniformMatrix3x2fv(exec, _mesa_UniformMatrix3x2fv);
   SET_UniformMatrix2x4fv(exec, _mesa_UniformMatrix2x4fv);
   SET_UniformMatrix4x2fv(exec, _mesa_UniformMatrix4x2fv);
   SET_UniformMatrix3x4fv(exec, _mesa_UniformMatrix3x4fv);
   SET_UniformMatrix4x3fv(exec, _mesa_UniformMatrix4x3fv);
#endif

d414 1
a414 1
#if 0
d427 2
d528 1
a528 1
   SET_IsProgramNV(exec, _mesa_IsProgramARB);
d1004 3
a1006 1
   ctx->Color._LogicOpEnabled = RGBA_LOGICOP_ENABLED(ctx);
d1024 1
a1024 1
_mesa_update_state_locked( GLcontext *ctx )
a1103 13


/* This is the usual entrypoint for state updates:
 */
void
_mesa_update_state( GLcontext *ctx )
{
   _mesa_lock_context_textures(ctx);
   _mesa_update_state_locked(ctx);
   _mesa_unlock_context_textures(ctx);
}


@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d73 3
a78 3
#if FEATURE_ARB_occlusion_query || FEATURE_EXT_timer_query
#include "queryobj.h"
#endif
d96 1
a96 1
#include "shaders.h"
d824 10
d845 5
a849 1
   if (ctx->VertexProgram._Current
d916 2
a917 2
       && ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_EDGEFLAG].Enabled) {
      min = MIN2(min, ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_EDGEFLAG]._MaxElement);
d933 1
a933 1
   if (ctx->VertexProgram._Current) {
d956 4
a959 3
   const struct gl_shader_program *shProg = ctx->Shader.CurrentProgram;

   /* These _Enabled flags indicate if the program is enabled AND valid. */
d966 3
d970 7
a976 10
   /*
    * Set the ctx->VertexProgram._Current and ctx->FragmentProgram._Current
    * pointers to the programs that should be enabled/used.
    *
    * These programs may come from several sources.  The priority is as
    * follows:
    *   1. OpenGL 2.0/ARB vertex/fragment shaders
    *   2. ARB/NV vertex/fragment programs
    *   3. Programs derived from fixed-function state.
    */
d978 1
a978 48
   ctx->FragmentProgram._Current = NULL;

   if (shProg && shProg->LinkStatus) {
      /* Use shader programs */
      /* XXX this isn't quite right, since we may have either a vertex
       * _or_ fragment shader (not always both).
       */
      ctx->VertexProgram._Current = shProg->VertexProgram;
      ctx->FragmentProgram._Current = shProg->FragmentProgram;
   }
   else {
      if (ctx->VertexProgram._Enabled) {
         /* use user-defined vertex program */
         ctx->VertexProgram._Current = ctx->VertexProgram.Current;
      }
      else if (ctx->VertexProgram._MaintainTnlProgram) {
         /* Use vertex program generated from fixed-function state.
          * The _Current pointer will get set in
          * _tnl_UpdateFixedFunctionProgram() later if appropriate.
          */
         ctx->VertexProgram._Current = NULL;
      }
      else {
         /* no vertex program */
         ctx->VertexProgram._Current = NULL;
      }

      if (ctx->FragmentProgram._Enabled) {
         /* use user-defined vertex program */
         ctx->FragmentProgram._Current = ctx->FragmentProgram.Current;
      }
      else if (ctx->FragmentProgram._MaintainTexEnvProgram) {
         /* Use fragment program generated from fixed-function state.
          * The _Current pointer will get set in _mesa_UpdateTexEnvProgram()
          * later if appropriate.
          */
         ctx->FragmentProgram._Current = NULL;
      }
      else {
         /* no fragment program */
         ctx->FragmentProgram._Current = NULL;
      }
   }

   ctx->FragmentProgram._Active = ctx->FragmentProgram._Enabled;
   if (ctx->FragmentProgram._MaintainTexEnvProgram &&
       !ctx->FragmentProgram._Enabled) {
      if (ctx->FragmentProgram._UseTexEnvProgram)
a1015 1

d1017 4
a1020 76
 * Update the ctx->_TriangleCaps bitfield.
 * XXX that bitfield should really go away someday!
 * This function must be called after other update_*() functions since
 * there are dependencies on some other derived values.
 */
static void
update_tricaps(GLcontext *ctx, GLbitfield new_state)
{
   ctx->_TriangleCaps = 0;

   /*
    * Points
    */
   if (1/*new_state & _NEW_POINT*/) {
      if (ctx->Point.SmoothFlag)
         ctx->_TriangleCaps |= DD_POINT_SMOOTH;
      if (ctx->Point._Size != 1.0F)
         ctx->_TriangleCaps |= DD_POINT_SIZE;
      if (ctx->Point._Attenuated)
         ctx->_TriangleCaps |= DD_POINT_ATTEN;
   }

   /*
    * Lines
    */
   if (1/*new_state & _NEW_LINE*/) {
      if (ctx->Line.SmoothFlag)
         ctx->_TriangleCaps |= DD_LINE_SMOOTH;
      if (ctx->Line.StippleFlag)
         ctx->_TriangleCaps |= DD_LINE_STIPPLE;
      if (ctx->Line._Width != 1.0)
         ctx->_TriangleCaps |= DD_LINE_WIDTH;
   }

   /*
    * Polygons
    */
   if (1/*new_state & _NEW_POLYGON*/) {
      if (ctx->Polygon.SmoothFlag)
         ctx->_TriangleCaps |= DD_TRI_SMOOTH;
      if (ctx->Polygon.StippleFlag)
         ctx->_TriangleCaps |= DD_TRI_STIPPLE;
      if (ctx->Polygon.FrontMode != GL_FILL
          || ctx->Polygon.BackMode != GL_FILL)
         ctx->_TriangleCaps |= DD_TRI_UNFILLED;
      if (ctx->Polygon.CullFlag
          && ctx->Polygon.CullFaceMode == GL_FRONT_AND_BACK)
         ctx->_TriangleCaps |= DD_TRI_CULL_FRONT_BACK;
      if (ctx->Polygon.OffsetPoint ||
          ctx->Polygon.OffsetLine ||
          ctx->Polygon.OffsetFill)
         ctx->_TriangleCaps |= DD_TRI_OFFSET;
   }

   /*
    * Lighting and shading
    */
   if (ctx->Light.Enabled && ctx->Light.Model.TwoSide)
      ctx->_TriangleCaps |= DD_TRI_LIGHT_TWOSIDE;
   if (ctx->Light.ShadeModel == GL_FLAT)
      ctx->_TriangleCaps |= DD_FLATSHADE;
   if (NEED_SECONDARY_COLOR(ctx))
      ctx->_TriangleCaps |= DD_SEPARATE_SPECULAR;

   /*
    * Stencil
    */
   if (ctx->Stencil._TestTwoSide)
      ctx->_TriangleCaps |= DD_TRI_TWOSTENCIL;
}


/**
 * Compute derived GL state.
 * If __GLcontextRec::NewState is non-zero then this function \b must
 * be called before rendering anything.
d1026 1
a1026 1
 * _mesa_update_buffer_bounds(),
d1052 6
d1067 3
d1079 1
a1079 5
   if (new_state & (_NEW_POINT | _NEW_LINE | _NEW_POLYGON | _NEW_LIGHT
                    | _NEW_STENCIL | _DD_NEW_SEPARATE_SPECULAR))
      update_tricaps( ctx, new_state );

   if (ctx->FragmentProgram._MaintainTexEnvProgram) {
a1124 2


@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d3 1
a3 1
 * Version:  7.3
d5 1
a5 1
 * Copyright (C) 1999-2008  Brian Paul   All Rights Reserved.
d30 2
a31 1
 * This file manages recalculation of derived values in struct gl_context.
a33 1

d35 17
a51 1
#include "mtypes.h"
d53 12
a64 3
#include "debug.h"
#include "macros.h"
#include "ffvertex_prog.h"
d66 3
d70 2
d74 6
a79 2
#include "program/program.h"
#include "program/prog_parameter.h"
d82 1
a82 1
#include "texenvprogram.h"
d85 15
a101 9
static void
update_separate_specular(struct gl_context *ctx)
{
   if (NEED_SECONDARY_COLOR(ctx))
      ctx->_TriangleCaps |= DD_SEPARATE_SPECULAR;
   else
      ctx->_TriangleCaps &= ~DD_SEPARATE_SPECULAR;
}

d104 8
a111 5
 * Compute the index of the last array element that can be safely accessed
 * in a vertex array.  We can really only do this when the array lives in
 * a VBO.
 * The array->_MaxElement field will be updated.
 * Later in glDrawArrays/Elements/etc we can do some bounds checking.
d113 2
a114 2
static void
compute_max_element(struct gl_client_array *array)
d116 699
a814 17
   assert(array->Enabled);
   if (array->BufferObj->Name) {
      GLsizeiptrARB offset = (GLsizeiptrARB) array->Ptr;
      GLsizeiptrARB obj_size = (GLsizeiptrARB) array->BufferObj->Size;

      if (offset < obj_size) {
	 array->_MaxElement = (obj_size - offset +
			       array->StrideB -
			       array->_ElementSize) / array->StrideB;
      } else {
	 array->_MaxElement = 0;
      }
   }
   else {
      /* user-space array, no idea how big it is */
      array->_MaxElement = 2 * 1000 * 1000 * 1000; /* just a big number */
   }
d818 4
a821 10
/**
 * Helper for update_arrays().
 * \return  min(current min, array->_MaxElement).
 */
static GLuint
update_min(GLuint min, struct gl_client_array *array)
{
   compute_max_element(array);
   return MIN2(min, array->_MaxElement);
}
d825 1
a825 2
 * Update ctx->Array._MaxElement (the max legal index into all enabled arrays).
 * Need to do this upon new array state or new buffer object state.
d828 1
a828 1
update_arrays( struct gl_context *ctx )
d830 1
a830 2
   struct gl_array_object *arrayObj = ctx->Array.ArrayObj;
   GLuint i, min = ~0;
d836 5
a840 2
       && arrayObj->VertexAttrib[VERT_ATTRIB_POS].Enabled) {
      min = update_min(min, &arrayObj->VertexAttrib[VERT_ATTRIB_POS]);
d842 3
a844 2
   else if (arrayObj->Vertex.Enabled) {
      min = update_min(min, &arrayObj->Vertex);
d849 2
a850 2
       && arrayObj->VertexAttrib[VERT_ATTRIB_WEIGHT].Enabled) {
      min = update_min(min, &arrayObj->VertexAttrib[VERT_ATTRIB_WEIGHT]);
d856 2
a857 2
       && arrayObj->VertexAttrib[VERT_ATTRIB_NORMAL].Enabled) {
      min = update_min(min, &arrayObj->VertexAttrib[VERT_ATTRIB_NORMAL]);
d859 2
a860 2
   else if (arrayObj->Normal.Enabled) {
      min = update_min(min, &arrayObj->Normal);
d865 2
a866 2
       && arrayObj->VertexAttrib[VERT_ATTRIB_COLOR0].Enabled) {
      min = update_min(min, &arrayObj->VertexAttrib[VERT_ATTRIB_COLOR0]);
d868 2
a869 2
   else if (arrayObj->Color.Enabled) {
      min = update_min(min, &arrayObj->Color);
d874 2
a875 2
       && arrayObj->VertexAttrib[VERT_ATTRIB_COLOR1].Enabled) {
      min = update_min(min, &arrayObj->VertexAttrib[VERT_ATTRIB_COLOR1]);
d877 2
a878 2
   else if (arrayObj->SecondaryColor.Enabled) {
      min = update_min(min, &arrayObj->SecondaryColor);
d883 2
a884 2
       && arrayObj->VertexAttrib[VERT_ATTRIB_FOG].Enabled) {
      min = update_min(min, &arrayObj->VertexAttrib[VERT_ATTRIB_FOG]);
d886 2
a887 2
   else if (arrayObj->FogCoord.Enabled) {
      min = update_min(min, &arrayObj->FogCoord);
d892 2
a893 2
       && arrayObj->VertexAttrib[VERT_ATTRIB_COLOR_INDEX].Enabled) {
      min = update_min(min, &arrayObj->VertexAttrib[VERT_ATTRIB_COLOR_INDEX]);
d895 2
a896 2
   else if (arrayObj->Index.Enabled) {
      min = update_min(min, &arrayObj->Index);
d899 1
d902 2
a903 2
       && arrayObj->VertexAttrib[VERT_ATTRIB_EDGEFLAG].Enabled) {
      min = update_min(min, &arrayObj->VertexAttrib[VERT_ATTRIB_EDGEFLAG]);
d909 2
a910 2
          && arrayObj->VertexAttrib[i].Enabled) {
         min = update_min(min, &arrayObj->VertexAttrib[i]);
d913 2
a914 2
               && arrayObj->TexCoord[i - VERT_ATTRIB_TEX0].Enabled) {
         min = update_min(min, &arrayObj->TexCoord[i - VERT_ATTRIB_TEX0]);
d920 3
a922 3
      for (i = 0; i < Elements(arrayObj->VertexAttrib); i++) {
         if (arrayObj->VertexAttrib[i].Enabled) {
            min = update_min(min, &arrayObj->VertexAttrib[i]);
d927 2
a928 2
   if (arrayObj->EdgeFlag.Enabled) {
      min = update_min(min, &arrayObj->EdgeFlag);
d932 1
a932 1
   arrayObj->_MaxElement = min;
d937 1
a937 5
 * Update the following fields:
 *   ctx->VertexProgram._Enabled
 *   ctx->FragmentProgram._Enabled
 *   ctx->ATIFragmentShader._Enabled
 * This needs to be done before texture state validation.
d940 1
a940 1
update_program_enables(struct gl_context *ctx)
d942 2
d950 1
a950 27
      && ctx->ATIFragmentShader.Current->Instructions[0];
}


/**
 * Update vertex/fragment program state.  In particular, update these fields:
 *   ctx->VertexProgram._Current
 *   ctx->VertexProgram._TnlProgram,
 * These point to the highest priority enabled vertex/fragment program or are
 * NULL if fixed-function processing is to be done.
 *
 * This function needs to be called after texture state validation in case
 * we're generating a fragment program from fixed-function texture state.
 *
 * \return bitfield which will indicate _NEW_PROGRAM state if a new vertex
 * or fragment program is being used.
 */
static GLbitfield
update_program(struct gl_context *ctx)
{
   const struct gl_shader_program *vsProg = ctx->Shader.CurrentVertexProgram;
   const struct gl_shader_program *gsProg = ctx->Shader.CurrentGeometryProgram;
   const struct gl_shader_program *fsProg = ctx->Shader.CurrentFragmentProgram;
   const struct gl_vertex_program *prevVP = ctx->VertexProgram._Current;
   const struct gl_fragment_program *prevFP = ctx->FragmentProgram._Current;
   const struct gl_geometry_program *prevGP = ctx->GeometryProgram._Current;
   GLbitfield new_state = 0x0;
d954 1
a954 2
    * pointers to the programs that should be used for rendering.  If either
    * is NULL, use fixed-function code paths.
a960 4
    *
    * Note: it's possible for a vertex shader to get used with a fragment
    * program (and vice versa) here, but in practice that shouldn't ever
    * come up, or matter.
d963 1
a963 31
   if (fsProg && fsProg->LinkStatus && fsProg->FragmentProgram) {
      /* Use shader programs */
      _mesa_reference_fragprog(ctx, &ctx->FragmentProgram._Current,
                               fsProg->FragmentProgram);
   }
   else if (ctx->FragmentProgram._Enabled) {
      /* use user-defined vertex program */
      _mesa_reference_fragprog(ctx, &ctx->FragmentProgram._Current,
                               ctx->FragmentProgram.Current);
   }
   else if (ctx->FragmentProgram._MaintainTexEnvProgram) {
      /* Use fragment program generated from fixed-function state.
       */
      _mesa_reference_fragprog(ctx, &ctx->FragmentProgram._Current,
                               _mesa_get_fixed_func_fragment_program(ctx));
      _mesa_reference_fragprog(ctx, &ctx->FragmentProgram._TexEnvProgram,
                               ctx->FragmentProgram._Current);
   }
   else {
      /* no fragment program */
      _mesa_reference_fragprog(ctx, &ctx->FragmentProgram._Current, NULL);
   }

   if (gsProg && gsProg->LinkStatus && gsProg->GeometryProgram) {
      /* Use shader programs */
      _mesa_reference_geomprog(ctx, &ctx->GeometryProgram._Current,
                               gsProg->GeometryProgram);
   } else {
      /* no fragment program */
      _mesa_reference_geomprog(ctx, &ctx->GeometryProgram._Current, NULL);
   }
d965 1
a965 5
   /* Examine vertex program after fragment program as
    * _mesa_get_fixed_func_vertex_program() needs to know active
    * fragprog inputs.
    */
   if (vsProg && vsProg->LinkStatus && vsProg->VertexProgram) {
d967 2
a968 10
      _mesa_reference_vertprog(ctx, &ctx->VertexProgram._Current,
                            vsProg->VertexProgram);
   }
   else if (ctx->VertexProgram._Enabled) {
      /* use user-defined vertex program */
      _mesa_reference_vertprog(ctx, &ctx->VertexProgram._Current,
                               ctx->VertexProgram.Current);
   }
   else if (ctx->VertexProgram._MaintainTnlProgram) {
      /* Use vertex program generated from fixed-function state.
d970 2
a971 4
      _mesa_reference_vertprog(ctx, &ctx->VertexProgram._Current,
                               _mesa_get_fixed_func_vertex_program(ctx));
      _mesa_reference_vertprog(ctx, &ctx->VertexProgram._TnlProgram,
                               ctx->VertexProgram._Current);
d974 10
a983 11
      /* no vertex program */
      _mesa_reference_vertprog(ctx, &ctx->VertexProgram._Current, NULL);
   }

   /* Let the driver know what's happening:
    */
   if (ctx->FragmentProgram._Current != prevFP) {
      new_state |= _NEW_PROGRAM;
      if (ctx->Driver.BindProgram) {
         ctx->Driver.BindProgram(ctx, GL_FRAGMENT_PROGRAM_ARB,
                          (struct gl_program *) ctx->FragmentProgram._Current);
d985 3
a987 7
   }

   if (ctx->GeometryProgram._Current != prevGP) {
      new_state |= _NEW_PROGRAM;
      if (ctx->Driver.BindProgram) {
         ctx->Driver.BindProgram(ctx, MESA_GEOMETRY_PROGRAM,
                            (struct gl_program *) ctx->GeometryProgram._Current);
a988 1
   }
d990 3
a992 5
   if (ctx->VertexProgram._Current != prevVP) {
      new_state |= _NEW_PROGRAM;
      if (ctx->Driver.BindProgram) {
         ctx->Driver.BindProgram(ctx, GL_VERTEX_PROGRAM_ARB,
                            (struct gl_program *) ctx->VertexProgram._Current);
d994 6
a999 19
   }

   return new_state;
}


/**
 * Examine shader constants and return either _NEW_PROGRAM_CONSTANTS or 0.
 */
static GLbitfield
update_program_constants(struct gl_context *ctx)
{
   GLbitfield new_state = 0x0;

   if (ctx->FragmentProgram._Current) {
      const struct gl_program_parameter_list *params =
         ctx->FragmentProgram._Current->Base.Parameters;
      if (params && params->StateFlags & ctx->NewState) {
         new_state |= _NEW_PROGRAM_CONSTANTS;
d1001 3
a1003 9
   }

   if (ctx->GeometryProgram._Current) {
      const struct gl_program_parameter_list *params =
         ctx->GeometryProgram._Current->Base.Parameters;
      /*FIXME: StateFlags is always 0 because we have unnamed constant
       *       not state changes */
      if (params /*&& params->StateFlags & ctx->NewState*/) {
         new_state |= _NEW_PROGRAM_CONSTANTS;
d1007 5
a1011 6
   if (ctx->VertexProgram._Current) {
      const struct gl_program_parameter_list *params =
         ctx->VertexProgram._Current->Base.Parameters;
      if (params && params->StateFlags & ctx->NewState) {
         new_state |= _NEW_PROGRAM_CONSTANTS;
      }
a1012 2

   return new_state;
a1015 2


d1017 1
a1017 1
update_viewport_matrix(struct gl_context *ctx)
a1035 14
 * Update derived multisample state.
 */
static void
update_multisample(struct gl_context *ctx)
{
   ctx->Multisample._Enabled = GL_FALSE;
   if (ctx->Multisample.Enabled &&
       ctx->DrawBuffer &&
       ctx->DrawBuffer->Visual.sampleBuffers)
      ctx->Multisample._Enabled = GL_TRUE;
}


/**
d1039 1
a1039 1
update_color(struct gl_context *ctx)
a1047 18
/*
 * Check polygon state and set DD_TRI_CULL_FRONT_BACK and/or DD_TRI_OFFSET
 * in ctx->_TriangleCaps if needed.
 */
static void
update_polygon(struct gl_context *ctx)
{
   ctx->_TriangleCaps &= ~(DD_TRI_CULL_FRONT_BACK | DD_TRI_OFFSET);

   if (ctx->Polygon.CullFlag && ctx->Polygon.CullFaceMode == GL_FRONT_AND_BACK)
      ctx->_TriangleCaps |= DD_TRI_CULL_FRONT_BACK;

   if (   ctx->Polygon.OffsetPoint
       || ctx->Polygon.OffsetLine
       || ctx->Polygon.OffsetFill)
      ctx->_TriangleCaps |= DD_TRI_OFFSET;
}

a1054 1
#if 0
d1056 1
a1056 1
update_tricaps(struct gl_context *ctx, GLbitfield new_state)
d1066 2
d1080 2
a1119 1
#endif
d1124 1
a1124 1
 * If __struct gl_contextRec::NewState is non-zero then this function \b must
d1135 1
a1135 1
_mesa_update_state_locked( struct gl_context *ctx )
a1137 5
   GLbitfield prog_flags = _NEW_PROGRAM;
   GLbitfield new_prog_state = 0x0;

   if (new_state == _NEW_CURRENT_ATTRIB) 
      goto out;
d1142 2
a1143 19
   /* Determine which state flags effect vertex/fragment program state */
   if (ctx->FragmentProgram._MaintainTexEnvProgram) {
      prog_flags |= (_NEW_BUFFERS | _NEW_TEXTURE | _NEW_FOG |
		     _NEW_ARRAY | _NEW_LIGHT | _NEW_POINT | _NEW_RENDERMODE |
		     _NEW_PROGRAM);
   }
   if (ctx->VertexProgram._MaintainTnlProgram) {
      prog_flags |= (_NEW_ARRAY | _NEW_TEXTURE | _NEW_TEXTURE_MATRIX |
                     _NEW_TRANSFORM | _NEW_POINT |
                     _NEW_FOG | _NEW_LIGHT |
                     _MESA_NEW_NEED_EYE_COORDS);
   }

   /*
    * Now update derived state info
    */

   if (new_state & prog_flags)
      update_program_enables( ctx );
d1151 1
a1151 1
   if (new_state & _NEW_BUFFERS)
a1156 3
   if (new_state & _NEW_POLYGON)
      update_polygon( ctx );

d1160 1
a1160 1
   if (new_state & (_NEW_STENCIL | _NEW_BUFFERS))
d1163 1
a1163 1
   if (new_state & _MESA_NEW_TRANSFER_STATE)
d1166 2
a1167 2
   if (new_state & _DD_NEW_SEPARATE_SPECULAR)
      update_separate_specular( ctx );
a1171 3
   if (new_state & _NEW_MULTISAMPLE)
      update_multisample( ctx );

a1174 1
#if 0
d1178 5
a1182 1
#endif
a1195 14
   if (new_state & prog_flags) {
      /* When we generate programs from fixed-function vertex/fragment state
       * this call may generate/bind a new program.  If so, we need to
       * propogate the _NEW_PROGRAM flag to the driver.
       */
      new_prog_state |= update_program( ctx );
   }

   if (new_state & (_NEW_ARRAY | _NEW_PROGRAM | _NEW_BUFFER_OBJECT))
      update_arrays( ctx );

 out:
   new_prog_state |= update_program_constants(ctx);

d1205 1
a1205 1
   new_state = ctx->NewState | new_prog_state;
d1215 1
a1215 1
_mesa_update_state( struct gl_context *ctx )
d1224 1
a1225 32
/**
 * Want to figure out which fragment program inputs are actually
 * constant/current values from ctx->Current.  These should be
 * referenced as a tracked state variable rather than a fragment
 * program input, to save the overhead of putting a constant value in
 * every submitted vertex, transferring it to hardware, interpolating
 * it across the triangle, etc...
 *
 * When there is a VP bound, just use vp->outputs.  But when we're
 * generating vp from fixed function state, basically want to
 * calculate:
 *
 * vp_out_2_fp_in( vp_in_2_vp_out( varying_inputs ) | 
 *                 potential_vp_outputs )
 *
 * Where potential_vp_outputs is calculated by looking at enabled
 * texgen, etc.
 * 
 * The generated fragment program should then only declare inputs that
 * may vary or otherwise differ from the ctx->Current values.
 * Otherwise, the fp should track them as state values instead.
 */
void
_mesa_set_varying_vp_inputs( struct gl_context *ctx,
                             GLbitfield varying_inputs )
{
   if (ctx->varying_vp_inputs != varying_inputs) {
      ctx->varying_vp_inputs = varying_inputs;
      ctx->NewState |= _NEW_ARRAY;
      /*printf("%s %x\n", __FUNCTION__, varying_inputs);*/
   }
}
a1226 19

/**
 * Used by drivers to tell core Mesa that the driver is going to
 * install/ use its own vertex program.  In particular, this will
 * prevent generated fragment programs from using state vars instead
 * of ordinary varyings/inputs.
 */
void
_mesa_set_vp_override(struct gl_context *ctx, GLboolean flag)
{
   if (ctx->VertexProgram._Overriden != flag) {
      ctx->VertexProgram._Overriden = flag;

      /* Set one of the bits which will trigger fragment program
       * regeneration:
       */
      ctx->NewState |= _NEW_PROGRAM;
   }
}
@


1.1.1.5
log
@Import Mesa 9.2.0
@
text
@d3 1
d20 3
a22 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
a35 1
#include "arrayobj.h"
a45 1
#include "shaderobj.h"
d51 161
a211 2
#include "varray.h"
#include "blend.h"
d224 1
a224 4
   /* These _Enabled flags indicate if the user-defined ARB/NV vertex/fragment
    * program is enabled AND valid.  Similarly for ATI fragment shaders.
    * GLSL shaders not relevant here.
    */
d235 5
a239 6
 * Update the ctx->Vertex/Geometry/FragmentProgram._Current pointers to point
 * to the current/active programs.  Then call ctx->Driver.BindProgram() to
 * tell the driver which programs to use.
 *
 * Programs may come from 3 sources: GLSL shaders, ARB/NV_vertex/fragment
 * programs or programs derived from fixed-function state.
d252 1
a252 1
   struct gl_shader_program *fsProg = ctx->Shader.CurrentFragmentProgram;
d274 2
a275 6
   if (fsProg && fsProg->LinkStatus
       && fsProg->_LinkedShaders[MESA_SHADER_FRAGMENT]) {
      /* Use GLSL fragment shader */
      _mesa_reference_shader_program(ctx,
				     &ctx->Shader._CurrentFragmentProgram,
				     fsProg);
d277 1
a277 3
                               gl_fragment_program(fsProg->_LinkedShaders[MESA_SHADER_FRAGMENT]->Program));
      _mesa_reference_fragprog(ctx, &ctx->FragmentProgram._TexEnvProgram,
			       NULL);
d280 1
a280 4
      /* Use user-defined fragment program */
      _mesa_reference_shader_program(ctx,
				     &ctx->Shader._CurrentFragmentProgram,
				     NULL);
a282 2
      _mesa_reference_fragprog(ctx, &ctx->FragmentProgram._TexEnvProgram,
			       NULL);
d285 2
a286 6
      /* Use fragment program generated from fixed-function state */
      struct gl_shader_program *f = _mesa_get_fixed_func_fragment_program(ctx);

      _mesa_reference_shader_program(ctx,
				     &ctx->Shader._CurrentFragmentProgram,
				     f);
d288 1
a288 1
			       gl_fragment_program(f->_LinkedShaders[MESA_SHADER_FRAGMENT]->Program));
d290 1
a290 1
			       gl_fragment_program(f->_LinkedShaders[MESA_SHADER_FRAGMENT]->Program));
d293 1
a293 1
      /* No fragment program */
a294 2
      _mesa_reference_fragprog(ctx, &ctx->FragmentProgram._TexEnvProgram,
			       NULL);
d297 2
a298 3
   if (gsProg && gsProg->LinkStatus
       && gsProg->_LinkedShaders[MESA_SHADER_GEOMETRY]) {
      /* Use GLSL geometry shader */
d300 1
a300 1
			       gl_geometry_program(gsProg->_LinkedShaders[MESA_SHADER_GEOMETRY]->Program));
d302 1
a302 1
      /* No geometry program */
d310 2
a311 3
   if (vsProg && vsProg->LinkStatus
       && vsProg->_LinkedShaders[MESA_SHADER_VERTEX]) {
      /* Use GLSL vertex shader */
d313 1
a313 1
			       gl_vertex_program(vsProg->_LinkedShaders[MESA_SHADER_VERTEX]->Program));
d316 1
a316 1
      /* Use user-defined vertex program */
d321 2
a322 1
      /* Use vertex program generated from fixed-function state */
d437 36
a472 1
 * Update the ctx->VertexProgram._TwoSideEnabled flag.
d474 1
d476 1
a476 1
update_twoside(struct gl_context *ctx)
d478 40
a517 6
   if (ctx->Shader.CurrentVertexProgram ||
       ctx->VertexProgram._Enabled) {
      ctx->VertexProgram._TwoSideEnabled = ctx->VertexProgram.TwoSideEnabled;
   } else {
      ctx->VertexProgram._TwoSideEnabled = (ctx->Light.Enabled &&
					    ctx->Light.Model.TwoSide);
d519 16
d536 1
d567 2
a568 3
		     _NEW_VARYING_VP_INPUTS | _NEW_LIGHT | _NEW_POINT |
		     _NEW_RENDERMODE | _NEW_PROGRAM | _NEW_FRAG_CLAMP |
		     _NEW_COLOR);
d571 2
a572 2
      prog_flags |= (_NEW_VARYING_VP_INPUTS | _NEW_TEXTURE |
                     _NEW_TEXTURE_MATRIX | _NEW_TRANSFORM | _NEW_POINT |
d596 3
a601 3
   if (new_state & (_NEW_LIGHT | _NEW_PROGRAM))
      update_twoside( ctx );

d605 1
a605 1
   if (new_state & _NEW_PIXEL)
d608 3
d614 1
a614 1
   if (new_state & (_NEW_MULTISAMPLE | _NEW_BUFFERS))
d617 9
d646 2
a647 4
   if (ctx->Const.CheckArrayBounds &&
       new_state & (_NEW_ARRAY | _NEW_PROGRAM | _NEW_BUFFER_OBJECT)) {
      _mesa_update_array_object_max_element(ctx, ctx->Array.ArrayObj);
   }
d664 1
d705 1
a705 1
                             GLbitfield64 varying_inputs )
d709 1
a709 11

      /* Only the fixed-func generated programs need to use the flag
       * and the fixed-func fragment program uses it only if there is also
       * a fixed-func vertex program, so this only depends on the latter.
       *
       * It's okay to check the VP pointer here, because this is called after
       * _mesa_update_state in the vbo module. */
      if (ctx->VertexProgram._TnlProgram ||
          ctx->FragmentProgram._TexEnvProgram) {
         ctx->NewState |= _NEW_VARYING_VP_INPUTS;
      }
@


1.1.1.6
log
@Import Mesa 10.2.3
@
text
@d97 3
a99 6
   const struct gl_shader_program *vsProg =
      ctx->_Shader->CurrentProgram[MESA_SHADER_VERTEX];
   const struct gl_shader_program *gsProg =
      ctx->_Shader->CurrentProgram[MESA_SHADER_GEOMETRY];
   struct gl_shader_program *fsProg =
      ctx->_Shader->CurrentProgram[MESA_SHADER_FRAGMENT];
d125 1
a125 1
                                     &ctx->_Shader->_CurrentFragmentProgram,
d135 1
a135 1
                                     &ctx->_Shader->_CurrentFragmentProgram,
d147 1
a147 1
                                     &ctx->_Shader->_CurrentFragmentProgram,
a271 1
   unsigned i;
d279 5
a283 7
   for (i = 0; i < ctx->Const.MaxViewports; i++) {
      _math_matrix_viewport(&ctx->ViewportArray[i]._WindowMap,
                            ctx->ViewportArray[i].X, ctx->ViewportArray[i].Y,
                            ctx->ViewportArray[i].Width, ctx->ViewportArray[i].Height,
                            ctx->ViewportArray[i].Near, ctx->ViewportArray[i].Far,
                            depthMax);
   }
d307 1
a307 1
   if (ctx->_Shader->CurrentProgram[MESA_SHADER_VERTEX] ||
a412 3
   if (new_state & _NEW_ARRAY)
      _mesa_update_vao_client_arrays(ctx, ctx->Array.VAO);

d415 1
a415 1
      _mesa_update_vao_max_element(ctx, ctx->Array.VAO);
a432 1
   ctx->Array.VAO->NewArrays = 0x0;
@


1.1.1.7
log
@Import Mesa 10.4.3
@
text
@a53 1
#include "viewport.h"
a283 3
      double scale[3], translate[3];

      _mesa_get_viewport_xform(ctx, i, scale, translate);
d285 4
a288 1
                            scale, translate, depthMax);
a293 13
 * Update the ctx->Polygon._FrontBit flag.
 */
static void
update_frontbit(struct gl_context *ctx)
{
   if (ctx->Transform.ClipOrigin == GL_LOWER_LEFT)
      ctx->Polygon._FrontBit = (ctx->Polygon.FrontFace == GL_CW);
   else
      ctx->Polygon._FrontBit = (ctx->Polygon.FrontFace == GL_CCW);
}


/**
a374 3
   if (new_state & _NEW_POLYGON)
      update_frontbit( ctx );

d421 5
@


1.1.1.8
log
@Import Mesa 10.2.9
@
text
@d54 1
d285 3
d289 1
a289 4
                            ctx->ViewportArray[i].X, ctx->ViewportArray[i].Y,
                            ctx->ViewportArray[i].Width, ctx->ViewportArray[i].Height,
                            ctx->ViewportArray[i].Near, ctx->ViewportArray[i].Far,
                            depthMax);
d295 13
d389 3
a437 5

   if (ctx->Const.CheckArrayBounds &&
       new_state & (_NEW_ARRAY | _NEW_PROGRAM | _NEW_BUFFER_OBJECT)) {
      _mesa_update_vao_max_element(ctx, ctx->Array.VAO);
   }
@


