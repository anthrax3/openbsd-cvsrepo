head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.12.23.05.17.53;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.5;
commitid	4ry2gvZGMXkCUD2n;

1.5
date	2015.01.25.14.41.22;	author jsg;	state Exp;
branches;
next	1.4;
commitid	mcxB0JvoI9gTDYXU;

1.4
date	2014.07.09.21.09.00;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.06.33;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.17.13.58.19;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.23.13.29.47;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.47;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.16.58;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.35.07;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.13.03;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.50.09;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 2010  VMware, Inc.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */


#ifndef UNIFORMS_H
#define UNIFORMS_H

#include "glheader.h"
#include "program/prog_parameter.h"
#include "../glsl/glsl_types.h"
#include "../glsl/ir_uniform.h"

#ifdef __cplusplus
extern "C" {
#endif


struct gl_program;
struct _glapi_table;

void GLAPIENTRY
_mesa_Uniform1f(GLint, GLfloat);
void GLAPIENTRY
_mesa_Uniform2f(GLint, GLfloat, GLfloat);
void GLAPIENTRY
_mesa_Uniform3f(GLint, GLfloat, GLfloat, GLfloat);
void GLAPIENTRY
_mesa_Uniform4f(GLint, GLfloat, GLfloat, GLfloat, GLfloat);
void GLAPIENTRY
_mesa_Uniform1i(GLint, GLint);
void GLAPIENTRY
_mesa_Uniform2i(GLint, GLint, GLint);
void GLAPIENTRY
_mesa_Uniform3i(GLint, GLint, GLint, GLint);
void GLAPIENTRY
_mesa_Uniform4i(GLint, GLint, GLint, GLint, GLint);
void GLAPIENTRY
_mesa_Uniform1fv(GLint, GLsizei, const GLfloat *);
void GLAPIENTRY
_mesa_Uniform2fv(GLint, GLsizei, const GLfloat *);
void GLAPIENTRY
_mesa_Uniform3fv(GLint, GLsizei, const GLfloat *);
void GLAPIENTRY
_mesa_Uniform4fv(GLint, GLsizei, const GLfloat *);
void GLAPIENTRY
_mesa_Uniform1iv(GLint, GLsizei, const GLint *);
void GLAPIENTRY
_mesa_Uniform2iv(GLint, GLsizei, const GLint *);
void GLAPIENTRY
_mesa_Uniform3iv(GLint, GLsizei, const GLint *);
void GLAPIENTRY
_mesa_Uniform4iv(GLint, GLsizei, const GLint *);
void GLAPIENTRY
_mesa_Uniform1ui(GLint location, GLuint v0);
void GLAPIENTRY
_mesa_Uniform2ui(GLint location, GLuint v0, GLuint v1);
void GLAPIENTRY
_mesa_Uniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2);
void GLAPIENTRY
_mesa_Uniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
void GLAPIENTRY
_mesa_Uniform1uiv(GLint location, GLsizei count, const GLuint *value);
void GLAPIENTRY
_mesa_Uniform2uiv(GLint location, GLsizei count, const GLuint *value);
void GLAPIENTRY
_mesa_Uniform3uiv(GLint location, GLsizei count, const GLuint *value);
void GLAPIENTRY
_mesa_Uniform4uiv(GLint location, GLsizei count, const GLuint *value);
void GLAPIENTRY
_mesa_UniformMatrix2fv(GLint, GLsizei, GLboolean, const GLfloat *);
void GLAPIENTRY
_mesa_UniformMatrix3fv(GLint, GLsizei, GLboolean, const GLfloat *);
void GLAPIENTRY
_mesa_UniformMatrix4fv(GLint, GLsizei, GLboolean, const GLfloat *);
void GLAPIENTRY
_mesa_UniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose,
                         const GLfloat *value);
void GLAPIENTRY
_mesa_UniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose,
                         const GLfloat *value);
void GLAPIENTRY
_mesa_UniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose,
                         const GLfloat *value);
void GLAPIENTRY
_mesa_UniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose,
                         const GLfloat *value);
void GLAPIENTRY
_mesa_UniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose,
                         const GLfloat *value);
void GLAPIENTRY
_mesa_UniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose,
                         const GLfloat *value);

void GLAPIENTRY
_mesa_ProgramUniform1f(GLuint program, GLint, GLfloat);
void GLAPIENTRY
_mesa_ProgramUniform2f(GLuint program, GLint, GLfloat, GLfloat);
void GLAPIENTRY
_mesa_ProgramUniform3f(GLuint program, GLint, GLfloat, GLfloat, GLfloat);
void GLAPIENTRY
_mesa_ProgramUniform4f(GLuint program, GLint, GLfloat, GLfloat, GLfloat, GLfloat);
void GLAPIENTRY
_mesa_ProgramUniform1i(GLuint program, GLint, GLint);
void GLAPIENTRY
_mesa_ProgramUniform2i(GLuint program, GLint, GLint, GLint);
void GLAPIENTRY
_mesa_ProgramUniform3i(GLuint program, GLint, GLint, GLint, GLint);
void GLAPIENTRY
_mesa_ProgramUniform4i(GLuint program, GLint, GLint, GLint, GLint, GLint);
void GLAPIENTRY
_mesa_ProgramUniform1fv(GLuint program, GLint, GLsizei, const GLfloat *);
void GLAPIENTRY
_mesa_ProgramUniform2fv(GLuint program, GLint, GLsizei, const GLfloat *);
void GLAPIENTRY
_mesa_ProgramUniform3fv(GLuint program, GLint, GLsizei, const GLfloat *);
void GLAPIENTRY
_mesa_ProgramUniform4fv(GLuint program, GLint, GLsizei, const GLfloat *);
void GLAPIENTRY
_mesa_ProgramUniform1iv(GLuint program, GLint, GLsizei, const GLint *);
void GLAPIENTRY
_mesa_ProgramUniform2iv(GLuint program, GLint, GLsizei, const GLint *);
void GLAPIENTRY
_mesa_ProgramUniform3iv(GLuint program, GLint, GLsizei, const GLint *);
void GLAPIENTRY
_mesa_ProgramUniform4iv(GLuint program, GLint, GLsizei, const GLint *);
void GLAPIENTRY
_mesa_ProgramUniform1ui(GLuint program, GLint location, GLuint v0);
void GLAPIENTRY
_mesa_ProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1);
void GLAPIENTRY
_mesa_ProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1,
                        GLuint v2);
void GLAPIENTRY
_mesa_ProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1,
                        GLuint v2, GLuint v3);
void GLAPIENTRY
_mesa_ProgramUniform1uiv(GLuint program, GLint location, GLsizei count,
                         const GLuint *value);
void GLAPIENTRY
_mesa_ProgramUniform2uiv(GLuint program, GLint location, GLsizei count,
                         const GLuint *value);
void GLAPIENTRY
_mesa_ProgramUniform3uiv(GLuint program, GLint location, GLsizei count,
                         const GLuint *value);
void GLAPIENTRY
_mesa_ProgramUniform4uiv(GLuint program, GLint location, GLsizei count,
                         const GLuint *value);
void GLAPIENTRY
_mesa_ProgramUniformMatrix2fv(GLuint program, GLint, GLsizei, GLboolean,
                              const GLfloat *);
void GLAPIENTRY
_mesa_ProgramUniformMatrix3fv(GLuint program, GLint, GLsizei, GLboolean,
                              const GLfloat *);
void GLAPIENTRY
_mesa_ProgramUniformMatrix4fv(GLuint program, GLint, GLsizei, GLboolean,
                              const GLfloat *);
void GLAPIENTRY
_mesa_ProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count,
                                GLboolean transpose, const GLfloat *value);
void GLAPIENTRY
_mesa_ProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count,
                                GLboolean transpose, const GLfloat *value);
void GLAPIENTRY
_mesa_ProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count,
                                GLboolean transpose, const GLfloat *value);
void GLAPIENTRY
_mesa_ProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count,
                                GLboolean transpose, const GLfloat *value);
void GLAPIENTRY
_mesa_ProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count,
                                GLboolean transpose, const GLfloat *value);
void GLAPIENTRY
_mesa_ProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count,
                                GLboolean transpose, const GLfloat *value);

void GLAPIENTRY
_mesa_GetnUniformfvARB(GLuint, GLint, GLsizei, GLfloat *);
void GLAPIENTRY
_mesa_GetUniformfv(GLuint, GLint, GLfloat *);
void GLAPIENTRY
_mesa_GetnUniformivARB(GLuint, GLint, GLsizei, GLint *);
void GLAPIENTRY
_mesa_GetUniformuiv(GLuint, GLint, GLuint *);
void GLAPIENTRY
_mesa_GetnUniformuivARB(GLuint, GLint, GLsizei, GLuint *);
void GLAPIENTRY
_mesa_GetUniformuiv(GLuint program, GLint location, GLuint *params);
void GLAPIENTRY
_mesa_GetnUniformdvARB(GLuint, GLint, GLsizei, GLdouble *);
void GLAPIENTRY
_mesa_GetUniformdv(GLuint, GLint, GLdouble *);
GLint GLAPIENTRY
_mesa_GetUniformLocation(GLuint, const GLcharARB *);
GLuint GLAPIENTRY
_mesa_GetUniformBlockIndex(GLuint program,
			   const GLchar *uniformBlockName);
void GLAPIENTRY
_mesa_GetUniformIndices(GLuint program,
			GLsizei uniformCount,
			const GLchar * const *uniformNames,
			GLuint *uniformIndices);
void GLAPIENTRY
_mesa_UniformBlockBinding(GLuint program,
			  GLuint uniformBlockIndex,
			  GLuint uniformBlockBinding);
void GLAPIENTRY
_mesa_GetActiveAtomicCounterBufferiv(GLuint program, GLuint bufferIndex,
                                     GLenum pname, GLint *params);
void GLAPIENTRY
_mesa_GetActiveUniformBlockiv(GLuint program,
			      GLuint uniformBlockIndex,
			      GLenum pname,
			      GLint *params);
void GLAPIENTRY
_mesa_GetActiveUniformBlockName(GLuint program,
				GLuint uniformBlockIndex,
				GLsizei bufSize,
				GLsizei *length,
				GLchar *uniformBlockName);
void GLAPIENTRY
_mesa_GetActiveUniformName(GLuint program, GLuint uniformIndex,
			   GLsizei bufSize, GLsizei *length,
			   GLchar *uniformName);
void GLAPIENTRY
_mesa_GetActiveUniform(GLuint, GLuint, GLsizei, GLsizei *,
                       GLint *, GLenum *, GLcharARB *);
void GLAPIENTRY
_mesa_GetActiveUniformsiv(GLuint program,
			  GLsizei uniformCount,
			  const GLuint *uniformIndices,
			  GLenum pname,
			  GLint *params);
void GLAPIENTRY
_mesa_GetUniformiv(GLuint, GLint, GLint *);

long
_mesa_parse_program_resource_name(const GLchar *name,
                                  const GLchar **out_base_name_end);

unsigned
_mesa_get_uniform_location(struct gl_context *ctx, struct gl_shader_program *shProg,
			   const GLchar *name, unsigned *offset);

void
_mesa_uniform(struct gl_context *ctx, struct gl_shader_program *shader_program,
	      GLint location, GLsizei count,
              const GLvoid *values, GLenum type);

void
_mesa_uniform_matrix(struct gl_context *ctx, struct gl_shader_program *shProg,
		     GLuint cols, GLuint rows,
                     GLint location, GLsizei count,
                     GLboolean transpose, const GLfloat *values);

void
_mesa_get_uniform(struct gl_context *ctx, GLuint program, GLint location,
		  GLsizei bufSize, enum glsl_base_type returnType,
		  GLvoid *paramsOut);

extern void
_mesa_uniform_attach_driver_storage(struct gl_uniform_storage *,
				    unsigned element_stride,
				    unsigned vector_stride,
				    enum gl_uniform_driver_format format,
				    void *data);

extern void
_mesa_uniform_detach_all_driver_storage(struct gl_uniform_storage *uni);

extern void
_mesa_propagate_uniforms_to_driver_storage(struct gl_uniform_storage *uni,
					   unsigned array_index,
					   unsigned count);

extern void
_mesa_update_shader_textures_used(struct gl_shader_program *shProg,
				  struct gl_program *prog);

extern bool
_mesa_sampler_uniforms_are_valid(const struct gl_shader_program *shProg,
				 char *errMsg, size_t errMsgLength);
extern bool
_mesa_sampler_uniforms_pipeline_are_valid(struct gl_pipeline_object *);

extern const struct gl_program_parameter *
get_uniform_parameter(struct gl_shader_program *shProg, GLint index);

extern void
_mesa_get_uniform_name(const struct gl_uniform_storage *uni,
                       GLsizei maxLength, GLsizei *length,
                       GLchar *nameOut);

struct gl_builtin_uniform_element {
   const char *field;
   int tokens[STATE_LENGTH];
   int swizzle;
};

struct gl_builtin_uniform_desc {
   const char *name;
   const struct gl_builtin_uniform_element *elements;
   unsigned int num_elements;
};

/**
 * \name GLSL uniform arrays and structs require special handling.
 *
 * The GL_ARB_shader_objects spec says that if you use
 * glGetUniformLocation to get the location of an array, you CANNOT
 * access other elements of the array by adding an offset to the
 * returned location.  For example, you must call
 * glGetUniformLocation("foo[16]") if you want to set the 16th element
 * of the array with glUniform().
 *
 * HOWEVER, some other OpenGL drivers allow accessing array elements
 * by adding an offset to the returned array location.  And some apps
 * seem to depend on that behaviour.
 *
 * Mesa's gl_uniform_list doesn't directly support this since each
 * entry in the list describes one uniform variable, not one uniform
 * element.  We could insert dummy entries in the list for each array
 * element after [0] but that causes complications elsewhere.
 *
 * We solve this problem by creating multiple entries for uniform arrays
 * in the UniformRemapTable so that their elements get sequential locations.
 *
 * Utility functions below offer functionality to split UniformRemapTable
 * location in to location of the uniform in UniformStorage + offset to the
 * array element (0 if not an array) and also merge it back again as the
 * UniformRemapTable location.
 *
 */
/*@@{*/
/**
 * Combine the uniform's storage index and the array index
 */
static inline GLint
_mesa_uniform_merge_location_offset(const struct gl_shader_program *prog,
                                    unsigned storage_index,
                                    unsigned uniform_array_index)
{
   /* location in remap table + array element offset */
   return prog->UniformStorage[storage_index].remap_location +
      uniform_array_index;
}

/**
 * Separate the uniform storage index and array index
 */
static inline void
_mesa_uniform_split_location_offset(const struct gl_shader_program *prog,
                                    GLint location, unsigned *storage_index,
				    unsigned *uniform_array_index)
{
   *storage_index = prog->UniformRemapTable[location] - prog->UniformStorage;
   *uniform_array_index = location -
      prog->UniformRemapTable[location]->remap_location;

   /*gl_uniform_storage in UniformStorage with the calculated base_location
    * must match with the entry in remap table
    */
   assert(&prog->UniformStorage[*storage_index] ==
          prog->UniformRemapTable[location]);
}
/*@@}*/


#ifdef __cplusplus
}
#endif


#endif /* UNIFORMS_H */
@


1.6
log
@Merge Mesa 10.2.9
@
text
@@


1.5
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d262 1
a262 1
_mesa_get_uniform_location(struct gl_shader_program *shProg,
d268 1
a268 3
              const GLvoid *values,
              enum glsl_base_type basicType,
              unsigned src_components);
d325 63
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d262 1
a262 1
_mesa_get_uniform_location(struct gl_context *ctx, struct gl_shader_program *shProg,
d268 3
a270 1
              const GLvoid *values, GLenum type);
a326 63

/**
 * \name GLSL uniform arrays and structs require special handling.
 *
 * The GL_ARB_shader_objects spec says that if you use
 * glGetUniformLocation to get the location of an array, you CANNOT
 * access other elements of the array by adding an offset to the
 * returned location.  For example, you must call
 * glGetUniformLocation("foo[16]") if you want to set the 16th element
 * of the array with glUniform().
 *
 * HOWEVER, some other OpenGL drivers allow accessing array elements
 * by adding an offset to the returned array location.  And some apps
 * seem to depend on that behaviour.
 *
 * Mesa's gl_uniform_list doesn't directly support this since each
 * entry in the list describes one uniform variable, not one uniform
 * element.  We could insert dummy entries in the list for each array
 * element after [0] but that causes complications elsewhere.
 *
 * We solve this problem by creating multiple entries for uniform arrays
 * in the UniformRemapTable so that their elements get sequential locations.
 *
 * Utility functions below offer functionality to split UniformRemapTable
 * location in to location of the uniform in UniformStorage + offset to the
 * array element (0 if not an array) and also merge it back again as the
 * UniformRemapTable location.
 *
 */
/*@@{*/
/**
 * Combine the uniform's storage index and the array index
 */
static inline GLint
_mesa_uniform_merge_location_offset(const struct gl_shader_program *prog,
                                    unsigned storage_index,
                                    unsigned uniform_array_index)
{
   /* location in remap table + array element offset */
   return prog->UniformStorage[storage_index].remap_location +
      uniform_array_index;
}

/**
 * Separate the uniform storage index and array index
 */
static inline void
_mesa_uniform_split_location_offset(const struct gl_shader_program *prog,
                                    GLint location, unsigned *storage_index,
				    unsigned *uniform_array_index)
{
   *storage_index = prog->UniformRemapTable[location] - prog->UniformStorage;
   *uniform_array_index = location -
      prog->UniformRemapTable[location]->remap_location;

   /*gl_uniform_storage in UniformStorage with the calculated base_location
    * must match with the entry in remap table
    */
   assert(&prog->UniformStorage[*storage_index] ==
          prog->UniformRemapTable[location]);
}
/*@@}*/

@


1.3
log
@Merge Mesa 9.2.0
@
text
@d114 40
d155 2
a156 1
_mesa_GetnUniformfvARB(GLhandleARB, GLint, GLsizei, GLfloat *);
d158 2
a159 1
_mesa_GetUniformfv(GLhandleARB, GLint, GLfloat *);
d161 2
a162 1
_mesa_GetnUniformivARB(GLhandleARB, GLint, GLsizei, GLint *);
d164 2
a165 1
_mesa_GetUniformuiv(GLhandleARB, GLint, GLuint *);
d167 2
a168 1
_mesa_GetnUniformuivARB(GLhandleARB, GLint, GLsizei, GLuint *);
d170 2
a171 1
_mesa_GetUniformuiv(GLhandleARB program, GLint location, GLuint *params);
d173 2
a174 1
_mesa_GetnUniformdvARB(GLhandleARB, GLint, GLsizei, GLdouble *);
d176 37
a212 1
_mesa_GetUniformdv(GLhandleARB, GLint, GLdouble *);
d214 1
a214 1
_mesa_GetUniformLocation(GLhandleARB, const GLcharARB *);
d228 3
d246 2
a247 2
_mesa_GetActiveUniform(GLhandleARB, GLuint, GLsizei, GLsizei *,
                          GLint *, GLenum *, GLcharARB *);
d255 1
a255 1
_mesa_GetUniformiv(GLhandleARB, GLint, GLint *);
d303 2
d322 1
a322 1
   struct gl_builtin_uniform_element *elements;
d345 8
a352 9
 * We solve this problem by encoding two values in the location that's
 * returned by glGetUniformLocation():
 *  a) index into gl_uniform_list::Uniforms[] for the uniform
 *  b) an array/field offset (0 for simple types)
 *
 * These two values are encoded in the high and low halves of a GLint.
 * By putting the uniform number in the high part and the offset in the
 * low part, we can support the unofficial ability to index into arrays
 * by adding offsets to the location value.
d356 1
a356 1
 * Combine the uniform's base location and the offset
d360 2
a361 1
                                    unsigned base_location, unsigned offset)
d363 3
a365 3
   assert(prog->UniformLocationBaseScale >= 1);
   assert(offset < prog->UniformLocationBaseScale);
   return (base_location * prog->UniformLocationBaseScale) + offset;
d369 1
a369 1
 * Separate the uniform base location and parameter offset
d373 2
a374 2
                                    GLint location, unsigned *base_location,
				    unsigned *offset)
d376 9
a384 2
   *offset = location % prog->UniformLocationBaseScale;
   *base_location = location / prog->UniformLocationBaseScale;
@


1.2
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d19 4
a22 3
 * THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
d31 7
d42 33
a74 49
extern void GLAPIENTRY
_mesa_Uniform1fARB(GLint, GLfloat);

extern void GLAPIENTRY
_mesa_Uniform2fARB(GLint, GLfloat, GLfloat);

extern void GLAPIENTRY
_mesa_Uniform3fARB(GLint, GLfloat, GLfloat, GLfloat);

extern void GLAPIENTRY
_mesa_Uniform4fARB(GLint, GLfloat, GLfloat, GLfloat, GLfloat);

extern void GLAPIENTRY
_mesa_Uniform1iARB(GLint, GLint);

extern void GLAPIENTRY
_mesa_Uniform2iARB(GLint, GLint, GLint);

extern void GLAPIENTRY
_mesa_Uniform3iARB(GLint, GLint, GLint, GLint);

extern void GLAPIENTRY
_mesa_Uniform4iARB(GLint, GLint, GLint, GLint, GLint);

extern void GLAPIENTRY
_mesa_Uniform1fvARB(GLint, GLsizei, const GLfloat *);

extern void GLAPIENTRY
_mesa_Uniform2fvARB(GLint, GLsizei, const GLfloat *);

extern void GLAPIENTRY
_mesa_Uniform3fvARB(GLint, GLsizei, const GLfloat *);

extern void GLAPIENTRY
_mesa_Uniform4fvARB(GLint, GLsizei, const GLfloat *);

extern void GLAPIENTRY
_mesa_Uniform1ivARB(GLint, GLsizei, const GLint *);

extern void GLAPIENTRY
_mesa_Uniform2ivARB(GLint, GLsizei, const GLint *);

extern void GLAPIENTRY
_mesa_Uniform3ivARB(GLint, GLsizei, const GLint *);

extern void GLAPIENTRY
_mesa_Uniform4ivARB(GLint, GLsizei, const GLint *);

extern void GLAPIENTRY
d76 1
a76 2

extern void GLAPIENTRY
d78 1
a78 2

extern void GLAPIENTRY
d80 1
a80 2

extern void GLAPIENTRY
d82 1
a82 2

extern void GLAPIENTRY
d84 1
a84 2

extern void GLAPIENTRY
d86 1
a86 2

extern void GLAPIENTRY
d88 1
a88 2

extern void GLAPIENTRY
d90 7
a96 12


extern void GLAPIENTRY
_mesa_UniformMatrix2fvARB(GLint, GLsizei, GLboolean, const GLfloat *);

extern void GLAPIENTRY
_mesa_UniformMatrix3fvARB(GLint, GLsizei, GLboolean, const GLfloat *);

extern void GLAPIENTRY
_mesa_UniformMatrix4fvARB(GLint, GLsizei, GLboolean, const GLfloat *);

extern void GLAPIENTRY
d99 1
a99 2

extern void GLAPIENTRY
d102 1
a102 2

extern void GLAPIENTRY
d105 1
a105 2

extern void GLAPIENTRY
d108 1
a108 2

extern void GLAPIENTRY
d111 1
a111 2

extern void GLAPIENTRY
d114 1
a114 10


extern void GLAPIENTRY
_mesa_GetActiveUniformARB(GLhandleARB, GLuint, GLsizei, GLsizei *,
                          GLint *, GLenum *, GLcharARB *);

extern void GLAPIENTRY
_mesa_GetUniformfvARB(GLhandleARB, GLint, GLfloat *);

extern void GLAPIENTRY
d116 3
a118 5

extern void GLAPIENTRY
_mesa_GetUniformivARB(GLhandleARB, GLint, GLint *);

extern void GLAPIENTRY
d120 1
a120 2

extern void GLAPIENTRY
d122 1
a122 2

extern void GLAPIENTRY
d124 5
a128 2

extern void GLAPIENTRY
d130 44
d175 1
a175 7
extern void GLAPIENTRY
_mesa_GetnUniformdvARB(GLhandleARB, GLint, GLsizei, GLdouble *);

extern GLint GLAPIENTRY
_mesa_GetUniformLocationARB(GLhandleARB, const GLcharARB *);

GLint
d177 1
a177 1
			   const GLchar *name);
d186 1
a186 1
		     GLint cols, GLint rows,
d190 20
d211 2
a212 1
_mesa_update_shader_textures_used(struct gl_program *prog);
d214 6
d222 3
a224 1
_mesa_init_shader_uniform_dispatch(struct _glapi_table *exec);
d238 60
a297 1
extern const struct gl_builtin_uniform_desc _mesa_builtin_uniform_desc[];
@


1.1
log
@Initial revision
@
text
@d149 3
d155 13
a167 1
_mesa_GetUniformuiv(GLhandleARB program, GLint location, GLuint *params);
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d19 3
a21 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
a29 2
#include "../glsl/glsl_types.h"
#include "../glsl/ir_uniform.h"
d31 41
a71 3
#ifdef __cplusplus
extern "C" {
#endif
d73 2
d76 5
a80 2
struct gl_program;
struct _glapi_table;
d82 1
a82 33
void GLAPIENTRY
_mesa_Uniform1f(GLint, GLfloat);
void GLAPIENTRY
_mesa_Uniform2f(GLint, GLfloat, GLfloat);
void GLAPIENTRY
_mesa_Uniform3f(GLint, GLfloat, GLfloat, GLfloat);
void GLAPIENTRY
_mesa_Uniform4f(GLint, GLfloat, GLfloat, GLfloat, GLfloat);
void GLAPIENTRY
_mesa_Uniform1i(GLint, GLint);
void GLAPIENTRY
_mesa_Uniform2i(GLint, GLint, GLint);
void GLAPIENTRY
_mesa_Uniform3i(GLint, GLint, GLint, GLint);
void GLAPIENTRY
_mesa_Uniform4i(GLint, GLint, GLint, GLint, GLint);
void GLAPIENTRY
_mesa_Uniform1fv(GLint, GLsizei, const GLfloat *);
void GLAPIENTRY
_mesa_Uniform2fv(GLint, GLsizei, const GLfloat *);
void GLAPIENTRY
_mesa_Uniform3fv(GLint, GLsizei, const GLfloat *);
void GLAPIENTRY
_mesa_Uniform4fv(GLint, GLsizei, const GLfloat *);
void GLAPIENTRY
_mesa_Uniform1iv(GLint, GLsizei, const GLint *);
void GLAPIENTRY
_mesa_Uniform2iv(GLint, GLsizei, const GLint *);
void GLAPIENTRY
_mesa_Uniform3iv(GLint, GLsizei, const GLint *);
void GLAPIENTRY
_mesa_Uniform4iv(GLint, GLsizei, const GLint *);
void GLAPIENTRY
d84 2
a85 1
void GLAPIENTRY
d87 2
a88 1
void GLAPIENTRY
d90 2
a91 1
void GLAPIENTRY
d93 2
a94 1
void GLAPIENTRY
d96 2
a97 1
void GLAPIENTRY
d99 2
a100 1
void GLAPIENTRY
d102 2
a103 1
void GLAPIENTRY
d105 12
a116 7
void GLAPIENTRY
_mesa_UniformMatrix2fv(GLint, GLsizei, GLboolean, const GLfloat *);
void GLAPIENTRY
_mesa_UniformMatrix3fv(GLint, GLsizei, GLboolean, const GLfloat *);
void GLAPIENTRY
_mesa_UniformMatrix4fv(GLint, GLsizei, GLboolean, const GLfloat *);
void GLAPIENTRY
d119 2
a120 1
void GLAPIENTRY
d123 2
a124 1
void GLAPIENTRY
d127 2
a128 1
void GLAPIENTRY
d131 2
a132 1
void GLAPIENTRY
d135 2
a136 1
void GLAPIENTRY
d139 13
a151 11
void GLAPIENTRY
_mesa_GetnUniformfvARB(GLhandleARB, GLint, GLsizei, GLfloat *);
void GLAPIENTRY
_mesa_GetUniformfv(GLhandleARB, GLint, GLfloat *);
void GLAPIENTRY
_mesa_GetnUniformivARB(GLhandleARB, GLint, GLsizei, GLint *);
void GLAPIENTRY
_mesa_GetUniformuiv(GLhandleARB, GLint, GLuint *);
void GLAPIENTRY
_mesa_GetnUniformuivARB(GLhandleARB, GLint, GLsizei, GLuint *);
void GLAPIENTRY
a152 48
void GLAPIENTRY
_mesa_GetnUniformdvARB(GLhandleARB, GLint, GLsizei, GLdouble *);
void GLAPIENTRY
_mesa_GetUniformdv(GLhandleARB, GLint, GLdouble *);
GLint GLAPIENTRY
_mesa_GetUniformLocation(GLhandleARB, const GLcharARB *);
GLuint GLAPIENTRY
_mesa_GetUniformBlockIndex(GLuint program,
			   const GLchar *uniformBlockName);
void GLAPIENTRY
_mesa_GetUniformIndices(GLuint program,
			GLsizei uniformCount,
			const GLchar * const *uniformNames,
			GLuint *uniformIndices);
void GLAPIENTRY
_mesa_UniformBlockBinding(GLuint program,
			  GLuint uniformBlockIndex,
			  GLuint uniformBlockBinding);
void GLAPIENTRY
_mesa_GetActiveUniformBlockiv(GLuint program,
			      GLuint uniformBlockIndex,
			      GLenum pname,
			      GLint *params);
void GLAPIENTRY
_mesa_GetActiveUniformBlockName(GLuint program,
				GLuint uniformBlockIndex,
				GLsizei bufSize,
				GLsizei *length,
				GLchar *uniformBlockName);
void GLAPIENTRY
_mesa_GetActiveUniformName(GLuint program, GLuint uniformIndex,
			   GLsizei bufSize, GLsizei *length,
			   GLchar *uniformName);
void GLAPIENTRY
_mesa_GetActiveUniform(GLhandleARB, GLuint, GLsizei, GLsizei *,
                          GLint *, GLenum *, GLcharARB *);
void GLAPIENTRY
_mesa_GetActiveUniformsiv(GLuint program,
			  GLsizei uniformCount,
			  const GLuint *uniformIndices,
			  GLenum pname,
			  GLint *params);
void GLAPIENTRY
_mesa_GetUniformiv(GLhandleARB, GLint, GLint *);

long
_mesa_parse_program_resource_name(const GLchar *name,
                                  const GLchar **out_base_name_end);
d154 4
a157 1
unsigned
d159 1
a159 1
			   const GLchar *name, unsigned *offset);
d168 1
a168 1
		     GLuint cols, GLuint rows,
a171 5
void
_mesa_get_uniform(struct gl_context *ctx, GLuint program, GLint location,
		  GLsizei bufSize, enum glsl_base_type returnType,
		  GLvoid *paramsOut);

d173 1
a173 5
_mesa_uniform_attach_driver_storage(struct gl_uniform_storage *,
				    unsigned element_stride,
				    unsigned vector_stride,
				    enum gl_uniform_driver_format format,
				    void *data);
a174 18
extern void
_mesa_uniform_detach_all_driver_storage(struct gl_uniform_storage *uni);

extern void
_mesa_propagate_uniforms_to_driver_storage(struct gl_uniform_storage *uni,
					   unsigned array_index,
					   unsigned count);

extern void
_mesa_update_shader_textures_used(struct gl_shader_program *shProg,
				  struct gl_program *prog);

extern bool
_mesa_sampler_uniforms_are_valid(const struct gl_shader_program *shProg,
				 char *errMsg, size_t errMsgLength);

extern const struct gl_program_parameter *
get_uniform_parameter(struct gl_shader_program *shProg, GLint index);
d177 1
a177 3
_mesa_get_uniform_name(const struct gl_uniform_storage *uni,
                       GLsizei maxLength, GLsizei *length,
                       GLchar *nameOut);
d191 1
a191 60
/**
 * \name GLSL uniform arrays and structs require special handling.
 *
 * The GL_ARB_shader_objects spec says that if you use
 * glGetUniformLocation to get the location of an array, you CANNOT
 * access other elements of the array by adding an offset to the
 * returned location.  For example, you must call
 * glGetUniformLocation("foo[16]") if you want to set the 16th element
 * of the array with glUniform().
 *
 * HOWEVER, some other OpenGL drivers allow accessing array elements
 * by adding an offset to the returned array location.  And some apps
 * seem to depend on that behaviour.
 *
 * Mesa's gl_uniform_list doesn't directly support this since each
 * entry in the list describes one uniform variable, not one uniform
 * element.  We could insert dummy entries in the list for each array
 * element after [0] but that causes complications elsewhere.
 *
 * We solve this problem by encoding two values in the location that's
 * returned by glGetUniformLocation():
 *  a) index into gl_uniform_list::Uniforms[] for the uniform
 *  b) an array/field offset (0 for simple types)
 *
 * These two values are encoded in the high and low halves of a GLint.
 * By putting the uniform number in the high part and the offset in the
 * low part, we can support the unofficial ability to index into arrays
 * by adding offsets to the location value.
 */
/*@@{*/
/**
 * Combine the uniform's base location and the offset
 */
static inline GLint
_mesa_uniform_merge_location_offset(const struct gl_shader_program *prog,
                                    unsigned base_location, unsigned offset)
{
   assert(prog->UniformLocationBaseScale >= 1);
   assert(offset < prog->UniformLocationBaseScale);
   return (base_location * prog->UniformLocationBaseScale) + offset;
}

/**
 * Separate the uniform base location and parameter offset
 */
static inline void
_mesa_uniform_split_location_offset(const struct gl_shader_program *prog,
                                    GLint location, unsigned *base_location,
				    unsigned *offset)
{
   *offset = location % prog->UniformLocationBaseScale;
   *base_location = location / prog->UniformLocationBaseScale;
}
/*@@}*/


#ifdef __cplusplus
}
#endif

@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@a113 40

void GLAPIENTRY
_mesa_ProgramUniform1f(GLuint program, GLint, GLfloat);
void GLAPIENTRY
_mesa_ProgramUniform2f(GLuint program, GLint, GLfloat, GLfloat);
void GLAPIENTRY
_mesa_ProgramUniform3f(GLuint program, GLint, GLfloat, GLfloat, GLfloat);
void GLAPIENTRY
_mesa_ProgramUniform4f(GLuint program, GLint, GLfloat, GLfloat, GLfloat, GLfloat);
void GLAPIENTRY
_mesa_ProgramUniform1i(GLuint program, GLint, GLint);
void GLAPIENTRY
_mesa_ProgramUniform2i(GLuint program, GLint, GLint, GLint);
void GLAPIENTRY
_mesa_ProgramUniform3i(GLuint program, GLint, GLint, GLint, GLint);
void GLAPIENTRY
_mesa_ProgramUniform4i(GLuint program, GLint, GLint, GLint, GLint, GLint);
void GLAPIENTRY
_mesa_ProgramUniform1fv(GLuint program, GLint, GLsizei, const GLfloat *);
void GLAPIENTRY
_mesa_ProgramUniform2fv(GLuint program, GLint, GLsizei, const GLfloat *);
void GLAPIENTRY
_mesa_ProgramUniform3fv(GLuint program, GLint, GLsizei, const GLfloat *);
void GLAPIENTRY
_mesa_ProgramUniform4fv(GLuint program, GLint, GLsizei, const GLfloat *);
void GLAPIENTRY
_mesa_ProgramUniform1iv(GLuint program, GLint, GLsizei, const GLint *);
void GLAPIENTRY
_mesa_ProgramUniform2iv(GLuint program, GLint, GLsizei, const GLint *);
void GLAPIENTRY
_mesa_ProgramUniform3iv(GLuint program, GLint, GLsizei, const GLint *);
void GLAPIENTRY
_mesa_ProgramUniform4iv(GLuint program, GLint, GLsizei, const GLint *);
void GLAPIENTRY
_mesa_ProgramUniform1ui(GLuint program, GLint location, GLuint v0);
void GLAPIENTRY
_mesa_ProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1);
void GLAPIENTRY
_mesa_ProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1,
                        GLuint v2);
d115 1
a115 2
_mesa_ProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1,
                        GLuint v2, GLuint v3);
d117 1
a117 2
_mesa_ProgramUniform1uiv(GLuint program, GLint location, GLsizei count,
                         const GLuint *value);
d119 1
a119 2
_mesa_ProgramUniform2uiv(GLuint program, GLint location, GLsizei count,
                         const GLuint *value);
d121 1
a121 2
_mesa_ProgramUniform3uiv(GLuint program, GLint location, GLsizei count,
                         const GLuint *value);
d123 1
a123 2
_mesa_ProgramUniform4uiv(GLuint program, GLint location, GLsizei count,
                         const GLuint *value);
d125 1
a125 2
_mesa_ProgramUniformMatrix2fv(GLuint program, GLint, GLsizei, GLboolean,
                              const GLfloat *);
d127 1
a127 2
_mesa_ProgramUniformMatrix3fv(GLuint program, GLint, GLsizei, GLboolean,
                              const GLfloat *);
d129 1
a129 37
_mesa_ProgramUniformMatrix4fv(GLuint program, GLint, GLsizei, GLboolean,
                              const GLfloat *);
void GLAPIENTRY
_mesa_ProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count,
                                GLboolean transpose, const GLfloat *value);
void GLAPIENTRY
_mesa_ProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count,
                                GLboolean transpose, const GLfloat *value);
void GLAPIENTRY
_mesa_ProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count,
                                GLboolean transpose, const GLfloat *value);
void GLAPIENTRY
_mesa_ProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count,
                                GLboolean transpose, const GLfloat *value);
void GLAPIENTRY
_mesa_ProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count,
                                GLboolean transpose, const GLfloat *value);
void GLAPIENTRY
_mesa_ProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count,
                                GLboolean transpose, const GLfloat *value);

void GLAPIENTRY
_mesa_GetnUniformfvARB(GLuint, GLint, GLsizei, GLfloat *);
void GLAPIENTRY
_mesa_GetUniformfv(GLuint, GLint, GLfloat *);
void GLAPIENTRY
_mesa_GetnUniformivARB(GLuint, GLint, GLsizei, GLint *);
void GLAPIENTRY
_mesa_GetUniformuiv(GLuint, GLint, GLuint *);
void GLAPIENTRY
_mesa_GetnUniformuivARB(GLuint, GLint, GLsizei, GLuint *);
void GLAPIENTRY
_mesa_GetUniformuiv(GLuint program, GLint location, GLuint *params);
void GLAPIENTRY
_mesa_GetnUniformdvARB(GLuint, GLint, GLsizei, GLdouble *);
void GLAPIENTRY
_mesa_GetUniformdv(GLuint, GLint, GLdouble *);
d131 1
a131 1
_mesa_GetUniformLocation(GLuint, const GLcharARB *);
a144 3
_mesa_GetActiveAtomicCounterBufferiv(GLuint program, GLuint bufferIndex,
                                     GLenum pname, GLint *params);
void GLAPIENTRY
d160 2
a161 2
_mesa_GetActiveUniform(GLuint, GLuint, GLsizei, GLsizei *,
                       GLint *, GLenum *, GLcharARB *);
d169 1
a169 1
_mesa_GetUniformiv(GLuint, GLint, GLint *);
a216 2
extern bool
_mesa_sampler_uniforms_pipeline_are_valid(struct gl_pipeline_object *);
d234 1
a234 1
   const struct gl_builtin_uniform_element *elements;
d257 9
a265 8
 * We solve this problem by creating multiple entries for uniform arrays
 * in the UniformRemapTable so that their elements get sequential locations.
 *
 * Utility functions below offer functionality to split UniformRemapTable
 * location in to location of the uniform in UniformStorage + offset to the
 * array element (0 if not an array) and also merge it back again as the
 * UniformRemapTable location.
 *
d269 1
a269 1
 * Combine the uniform's storage index and the array index
d273 1
a273 2
                                    unsigned storage_index,
                                    unsigned uniform_array_index)
d275 3
a277 3
   /* location in remap table + array element offset */
   return prog->UniformStorage[storage_index].remap_location +
      uniform_array_index;
d281 1
a281 1
 * Separate the uniform storage index and array index
d285 2
a286 2
                                    GLint location, unsigned *storage_index,
				    unsigned *uniform_array_index)
d288 2
a289 9
   *storage_index = prog->UniformRemapTable[location] - prog->UniformStorage;
   *uniform_array_index = location -
      prog->UniformRemapTable[location]->remap_location;

   /*gl_uniform_storage in UniformStorage with the calculated base_location
    * must match with the entry in remap table
    */
   assert(&prog->UniformStorage[*storage_index] ==
          prog->UniformRemapTable[location]);
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d262 1
a262 1
_mesa_get_uniform_location(struct gl_shader_program *shProg,
d268 1
a268 3
              const GLvoid *values,
              enum glsl_base_type basicType,
              unsigned src_components);
d325 63
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d262 1
a262 1
_mesa_get_uniform_location(struct gl_context *ctx, struct gl_shader_program *shProg,
d268 3
a270 1
              const GLvoid *values, GLenum type);
a326 63

/**
 * \name GLSL uniform arrays and structs require special handling.
 *
 * The GL_ARB_shader_objects spec says that if you use
 * glGetUniformLocation to get the location of an array, you CANNOT
 * access other elements of the array by adding an offset to the
 * returned location.  For example, you must call
 * glGetUniformLocation("foo[16]") if you want to set the 16th element
 * of the array with glUniform().
 *
 * HOWEVER, some other OpenGL drivers allow accessing array elements
 * by adding an offset to the returned array location.  And some apps
 * seem to depend on that behaviour.
 *
 * Mesa's gl_uniform_list doesn't directly support this since each
 * entry in the list describes one uniform variable, not one uniform
 * element.  We could insert dummy entries in the list for each array
 * element after [0] but that causes complications elsewhere.
 *
 * We solve this problem by creating multiple entries for uniform arrays
 * in the UniformRemapTable so that their elements get sequential locations.
 *
 * Utility functions below offer functionality to split UniformRemapTable
 * location in to location of the uniform in UniformStorage + offset to the
 * array element (0 if not an array) and also merge it back again as the
 * UniformRemapTable location.
 *
 */
/*@@{*/
/**
 * Combine the uniform's storage index and the array index
 */
static inline GLint
_mesa_uniform_merge_location_offset(const struct gl_shader_program *prog,
                                    unsigned storage_index,
                                    unsigned uniform_array_index)
{
   /* location in remap table + array element offset */
   return prog->UniformStorage[storage_index].remap_location +
      uniform_array_index;
}

/**
 * Separate the uniform storage index and array index
 */
static inline void
_mesa_uniform_split_location_offset(const struct gl_shader_program *prog,
                                    GLint location, unsigned *storage_index,
				    unsigned *uniform_array_index)
{
   *storage_index = prog->UniformRemapTable[location] - prog->UniformStorage;
   *uniform_array_index = location -
      prog->UniformRemapTable[location]->remap_location;

   /*gl_uniform_storage in UniformStorage with the calculated base_location
    * must match with the entry in remap table
    */
   assert(&prog->UniformStorage[*storage_index] ==
          prog->UniformRemapTable[location]);
}
/*@@}*/

@


