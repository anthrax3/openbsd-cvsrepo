head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.6
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.4
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.5
	v10_2_7:1.1.1.5
	OPENBSD_5_6:1.6.0.2
	OPENBSD_5_6_BASE:1.6
	v10_2_3:1.1.1.5
	OPENBSD_5_5:1.5.0.2
	OPENBSD_5_5_BASE:1.5
	v9_2_5:1.1.1.4
	v9_2_3:1.1.1.4
	v9_2_2:1.1.1.4
	v9_2_1:1.1.1.4
	v9_2_0:1.1.1.4
	OPENBSD_5_4:1.4.0.4
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.2
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.3.0.4
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.2
	v7_10_3:1.1.1.3
	OPENBSD_5_0:1.2.0.6
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.1.2.0.10
	OPENBSD_4_7_BASE:1.1.1.2
	OPENBSD_4_6:1.1.1.2.0.8
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.6
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v7_0_1:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v6_5_2:1.1.1.1
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.12.23.05.17.52;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2014.07.09.21.09.00;	author jsg;	state Exp;
branches;
next	1.5;
commitid	WPD6rgPryPkvXOr9;

1.5
date	2013.09.05.14.06.24;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2012.08.17.13.58.19;	author mpi;	state Exp;
branches;
next	1.3;

1.3
date	2011.10.23.13.37.42;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.05.22.20.06.31;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.50.11;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.50.11;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.31.13;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.10.23.13.29.46;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.09.05.13.16.42;	author jsg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2014.07.09.20.35.02;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2008  Brian Paul   All Rights Reserved.
 * Copyright (C) 2009  VMware, Inc.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */


/**
 * \file matrix.c
 * Matrix operations.
 *
 * \note
 * -# 4x4 transformation matrices are stored in memory in column major order.
 * -# Points/vertices are to be thought of as column vectors.
 * -# Transformation of a point p by a matrix M is: p' = M * p
 */


#include "glheader.h"
#include "imports.h"
#include "context.h"
#include "enums.h"
#include "macros.h"
#include "matrix.h"
#include "mtypes.h"
#include "math/m_matrix.h"


/**
 * Apply a perspective projection matrix.
 *
 * \param left left clipping plane coordinate.
 * \param right right clipping plane coordinate.
 * \param bottom bottom clipping plane coordinate.
 * \param top top clipping plane coordinate.
 * \param nearval distance to the near clipping plane.
 * \param farval distance to the far clipping plane.
 *
 * \sa glFrustum().
 *
 * Flushes vertices and validates parameters. Calls _math_matrix_frustum() with
 * the top matrix of the current matrix stack and sets
 * __struct gl_contextRec::NewState.
 */
void GLAPIENTRY
_mesa_Frustum( GLdouble left, GLdouble right,
               GLdouble bottom, GLdouble top,
               GLdouble nearval, GLdouble farval )
{
   GET_CURRENT_CONTEXT(ctx);

   FLUSH_VERTICES(ctx, 0);

   if (nearval <= 0.0 ||
       farval <= 0.0 ||
       nearval == farval ||
       left == right ||
       top == bottom)
   {
      _mesa_error( ctx,  GL_INVALID_VALUE, "glFrustum" );
      return;
   }

   _math_matrix_frustum( ctx->CurrentStack->Top,
                         (GLfloat) left, (GLfloat) right, 
			 (GLfloat) bottom, (GLfloat) top, 
			 (GLfloat) nearval, (GLfloat) farval );
   ctx->NewState |= ctx->CurrentStack->DirtyFlag;
}


/**
 * Apply an orthographic projection matrix.
 *
 * \param left left clipping plane coordinate.
 * \param right right clipping plane coordinate.
 * \param bottom bottom clipping plane coordinate.
 * \param top top clipping plane coordinate.
 * \param nearval distance to the near clipping plane.
 * \param farval distance to the far clipping plane.
 *
 * \sa glOrtho().
 *
 * Flushes vertices and validates parameters. Calls _math_matrix_ortho() with
 * the top matrix of the current matrix stack and sets
 * __struct gl_contextRec::NewState.
 */
void GLAPIENTRY
_mesa_Ortho( GLdouble left, GLdouble right,
             GLdouble bottom, GLdouble top,
             GLdouble nearval, GLdouble farval )
{
   GET_CURRENT_CONTEXT(ctx);

   FLUSH_VERTICES(ctx, 0);

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glOrtho(%f, %f, %f, %f, %f, %f)\n",
                  left, right, bottom, top, nearval, farval);

   if (left == right ||
       bottom == top ||
       nearval == farval)
   {
      _mesa_error( ctx,  GL_INVALID_VALUE, "glOrtho" );
      return;
   }

   _math_matrix_ortho( ctx->CurrentStack->Top,
                       (GLfloat) left, (GLfloat) right, 
		       (GLfloat) bottom, (GLfloat) top, 
		       (GLfloat) nearval, (GLfloat) farval );
   ctx->NewState |= ctx->CurrentStack->DirtyFlag;
}


/**
 * Set the current matrix stack.
 *
 * \param mode matrix stack.
 *
 * \sa glMatrixMode().
 *
 * Flushes the vertices, validates the parameter and updates
 * __struct gl_contextRec::CurrentStack and gl_transform_attrib::MatrixMode
 * with the specified matrix stack.
 */
void GLAPIENTRY
_mesa_MatrixMode( GLenum mode )
{
   GET_CURRENT_CONTEXT(ctx);

   if (ctx->Transform.MatrixMode == mode && mode != GL_TEXTURE)
      return;
   FLUSH_VERTICES(ctx, _NEW_TRANSFORM);

   switch (mode) {
   case GL_MODELVIEW:
      ctx->CurrentStack = &ctx->ModelviewMatrixStack;
      break;
   case GL_PROJECTION:
      ctx->CurrentStack = &ctx->ProjectionMatrixStack;
      break;
   case GL_TEXTURE:
      /* This error check is disabled because if we're called from
       * glPopAttrib() when the active texture unit is >= MaxTextureCoordUnits
       * we'll generate an unexpected error.
       * From the GL_ARB_vertex_shader spec it sounds like we should instead
       * do error checking in other places when we actually try to access
       * texture matrices beyond MaxTextureCoordUnits.
       */
#if 0
      if (ctx->Texture.CurrentUnit >= ctx->Const.MaxTextureCoordUnits) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glMatrixMode(invalid tex unit %d)",
                     ctx->Texture.CurrentUnit);
         return;
      }
#endif
      ASSERT(ctx->Texture.CurrentUnit < Elements(ctx->TextureMatrixStack));
      ctx->CurrentStack = &ctx->TextureMatrixStack[ctx->Texture.CurrentUnit];
      break;
   case GL_MATRIX0_ARB:
   case GL_MATRIX1_ARB:
   case GL_MATRIX2_ARB:
   case GL_MATRIX3_ARB:
   case GL_MATRIX4_ARB:
   case GL_MATRIX5_ARB:
   case GL_MATRIX6_ARB:
   case GL_MATRIX7_ARB:
      if (ctx->API == API_OPENGL_COMPAT
          && (ctx->Extensions.ARB_vertex_program ||
              ctx->Extensions.ARB_fragment_program)) {
         const GLuint m = mode - GL_MATRIX0_ARB;
         if (m > ctx->Const.MaxProgramMatrices) {
            _mesa_error(ctx, GL_INVALID_ENUM,
                        "glMatrixMode(GL_MATRIX%d_ARB)", m);
            return;
         }
         ctx->CurrentStack = &ctx->ProgramMatrixStack[m];
      }
      else {
         _mesa_error( ctx,  GL_INVALID_ENUM, "glMatrixMode(mode)" );
         return;
      }
      break;
   default:
      _mesa_error( ctx,  GL_INVALID_ENUM, "glMatrixMode(mode)" );
      return;
   }

   ctx->Transform.MatrixMode = mode;
}


/**
 * Push the current matrix stack.
 *
 * \sa glPushMatrix().
 * 
 * Verifies the current matrix stack is not full, and duplicates the top-most
 * matrix in the stack.
 * Marks __struct gl_contextRec::NewState with the stack dirty flag.
 */
void GLAPIENTRY
_mesa_PushMatrix( void )
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_matrix_stack *stack = ctx->CurrentStack;

   if (MESA_VERBOSE&VERBOSE_API)
      _mesa_debug(ctx, "glPushMatrix %s\n",
                  _mesa_lookup_enum_by_nr(ctx->Transform.MatrixMode));

   if (stack->Depth + 1 >= stack->MaxDepth) {
      if (ctx->Transform.MatrixMode == GL_TEXTURE) {
         _mesa_error(ctx,  GL_STACK_OVERFLOW,
                     "glPushMatrix(mode=GL_TEXTURE, unit=%d)",
                      ctx->Texture.CurrentUnit);
      }
      else {
         _mesa_error(ctx,  GL_STACK_OVERFLOW, "glPushMatrix(mode=%s)",
                     _mesa_lookup_enum_by_nr(ctx->Transform.MatrixMode));
      }
      return;
   }
   _math_matrix_copy( &stack->Stack[stack->Depth + 1],
                      &stack->Stack[stack->Depth] );
   stack->Depth++;
   stack->Top = &(stack->Stack[stack->Depth]);
   ctx->NewState |= stack->DirtyFlag;
}


/**
 * Pop the current matrix stack.
 *
 * \sa glPopMatrix().
 * 
 * Flushes the vertices, verifies the current matrix stack is not empty, and
 * moves the stack head down.
 * Marks __struct gl_contextRec::NewState with the dirty stack flag.
 */
void GLAPIENTRY
_mesa_PopMatrix( void )
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_matrix_stack *stack = ctx->CurrentStack;

   FLUSH_VERTICES(ctx, 0);

   if (MESA_VERBOSE&VERBOSE_API)
      _mesa_debug(ctx, "glPopMatrix %s\n",
                  _mesa_lookup_enum_by_nr(ctx->Transform.MatrixMode));

   if (stack->Depth == 0) {
      if (ctx->Transform.MatrixMode == GL_TEXTURE) {
         _mesa_error(ctx,  GL_STACK_UNDERFLOW,
                     "glPopMatrix(mode=GL_TEXTURE, unit=%d)",
                      ctx->Texture.CurrentUnit);
      }
      else {
         _mesa_error(ctx,  GL_STACK_UNDERFLOW, "glPopMatrix(mode=%s)",
                     _mesa_lookup_enum_by_nr(ctx->Transform.MatrixMode));
      }
      return;
   }
   stack->Depth--;
   stack->Top = &(stack->Stack[stack->Depth]);
   ctx->NewState |= stack->DirtyFlag;
}


/**
 * Replace the current matrix with the identity matrix.
 *
 * \sa glLoadIdentity().
 *
 * Flushes the vertices and calls _math_matrix_set_identity() with the
 * top-most matrix in the current stack.
 * Marks __struct gl_contextRec::NewState with the stack dirty flag.
 */
void GLAPIENTRY
_mesa_LoadIdentity( void )
{
   GET_CURRENT_CONTEXT(ctx);

   FLUSH_VERTICES(ctx, 0);

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glLoadIdentity()\n");

   _math_matrix_set_identity( ctx->CurrentStack->Top );
   ctx->NewState |= ctx->CurrentStack->DirtyFlag;
}


/**
 * Replace the current matrix with a given matrix.
 *
 * \param m matrix.
 *
 * \sa glLoadMatrixf().
 *
 * Flushes the vertices and calls _math_matrix_loadf() with the top-most
 * matrix in the current stack and the given matrix.
 * Marks __struct gl_contextRec::NewState with the dirty stack flag.
 */
void GLAPIENTRY
_mesa_LoadMatrixf( const GLfloat *m )
{
   GET_CURRENT_CONTEXT(ctx);
   if (!m) return;
   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx,
          "glLoadMatrix(%f %f %f %f, %f %f %f %f, %f %f %f %f, %f %f %f %f\n",
          m[0], m[4], m[8], m[12],
          m[1], m[5], m[9], m[13],
          m[2], m[6], m[10], m[14],
          m[3], m[7], m[11], m[15]);

   FLUSH_VERTICES(ctx, 0);
   _math_matrix_loadf( ctx->CurrentStack->Top, m );
   ctx->NewState |= ctx->CurrentStack->DirtyFlag;
}


/**
 * Multiply the current matrix with a given matrix.
 *
 * \param m matrix.
 *
 * \sa glMultMatrixf().
 *
 * Flushes the vertices and calls _math_matrix_mul_floats() with the top-most
 * matrix in the current stack and the given matrix. Marks
 * __struct gl_contextRec::NewState with the dirty stack flag.
 */
void GLAPIENTRY
_mesa_MultMatrixf( const GLfloat *m )
{
   GET_CURRENT_CONTEXT(ctx);
   if (!m) return;
   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx,
          "glMultMatrix(%f %f %f %f, %f %f %f %f, %f %f %f %f, %f %f %f %f\n",
          m[0], m[4], m[8], m[12],
          m[1], m[5], m[9], m[13],
          m[2], m[6], m[10], m[14],
          m[3], m[7], m[11], m[15]);

   FLUSH_VERTICES(ctx, 0);
   _math_matrix_mul_floats( ctx->CurrentStack->Top, m );
   ctx->NewState |= ctx->CurrentStack->DirtyFlag;
}


/**
 * Multiply the current matrix with a rotation matrix.
 *
 * \param angle angle of rotation, in degrees.
 * \param x rotation vector x coordinate.
 * \param y rotation vector y coordinate.
 * \param z rotation vector z coordinate.
 *
 * \sa glRotatef().
 *
 * Flushes the vertices and calls _math_matrix_rotate() with the top-most
 * matrix in the current stack and the given parameters. Marks
 * __struct gl_contextRec::NewState with the dirty stack flag.
 */
void GLAPIENTRY
_mesa_Rotatef( GLfloat angle, GLfloat x, GLfloat y, GLfloat z )
{
   GET_CURRENT_CONTEXT(ctx);

   FLUSH_VERTICES(ctx, 0);
   if (angle != 0.0F) {
      _math_matrix_rotate( ctx->CurrentStack->Top, angle, x, y, z);
      ctx->NewState |= ctx->CurrentStack->DirtyFlag;
   }
}


/**
 * Multiply the current matrix with a general scaling matrix.
 *
 * \param x x axis scale factor.
 * \param y y axis scale factor.
 * \param z z axis scale factor.
 *
 * \sa glScalef().
 *
 * Flushes the vertices and calls _math_matrix_scale() with the top-most
 * matrix in the current stack and the given parameters. Marks
 * __struct gl_contextRec::NewState with the dirty stack flag.
 */
void GLAPIENTRY
_mesa_Scalef( GLfloat x, GLfloat y, GLfloat z )
{
   GET_CURRENT_CONTEXT(ctx);

   FLUSH_VERTICES(ctx, 0);
   _math_matrix_scale( ctx->CurrentStack->Top, x, y, z);
   ctx->NewState |= ctx->CurrentStack->DirtyFlag;
}


/**
 * Multiply the current matrix with a translation matrix.
 *
 * \param x translation vector x coordinate.
 * \param y translation vector y coordinate.
 * \param z translation vector z coordinate.
 *
 * \sa glTranslatef().
 *
 * Flushes the vertices and calls _math_matrix_translate() with the top-most
 * matrix in the current stack and the given parameters. Marks
 * __struct gl_contextRec::NewState with the dirty stack flag.
 */
void GLAPIENTRY
_mesa_Translatef( GLfloat x, GLfloat y, GLfloat z )
{
   GET_CURRENT_CONTEXT(ctx);

   FLUSH_VERTICES(ctx, 0);
   _math_matrix_translate( ctx->CurrentStack->Top, x, y, z);
   ctx->NewState |= ctx->CurrentStack->DirtyFlag;
}

 
void GLAPIENTRY
_mesa_LoadMatrixd( const GLdouble *m )
{
   GLint i;
   GLfloat f[16];
   if (!m) return;
   for (i = 0; i < 16; i++)
      f[i] = (GLfloat) m[i];
   _mesa_LoadMatrixf(f);
}

void GLAPIENTRY
_mesa_MultMatrixd( const GLdouble *m )
{
   GLint i;
   GLfloat f[16];
   if (!m) return;
   for (i = 0; i < 16; i++)
      f[i] = (GLfloat) m[i];
   _mesa_MultMatrixf( f );
}


void GLAPIENTRY
_mesa_Rotated( GLdouble angle, GLdouble x, GLdouble y, GLdouble z )
{
   _mesa_Rotatef((GLfloat) angle, (GLfloat) x, (GLfloat) y, (GLfloat) z);
}


void GLAPIENTRY
_mesa_Scaled( GLdouble x, GLdouble y, GLdouble z )
{
   _mesa_Scalef((GLfloat) x, (GLfloat) y, (GLfloat) z);
}


void GLAPIENTRY
_mesa_Translated( GLdouble x, GLdouble y, GLdouble z )
{
   _mesa_Translatef((GLfloat) x, (GLfloat) y, (GLfloat) z);
}


void GLAPIENTRY
_mesa_LoadTransposeMatrixf( const GLfloat *m )
{
   GLfloat tm[16];
   if (!m) return;
   _math_transposef(tm, m);
   _mesa_LoadMatrixf(tm);
}


void GLAPIENTRY
_mesa_LoadTransposeMatrixd( const GLdouble *m )
{
   GLfloat tm[16];
   if (!m) return;
   _math_transposefd(tm, m);
   _mesa_LoadMatrixf(tm);
}


void GLAPIENTRY
_mesa_MultTransposeMatrixf( const GLfloat *m )
{
   GLfloat tm[16];
   if (!m) return;
   _math_transposef(tm, m);
   _mesa_MultMatrixf(tm);
}


void GLAPIENTRY
_mesa_MultTransposeMatrixd( const GLdouble *m )
{
   GLfloat tm[16];
   if (!m) return;
   _math_transposefd(tm, m);
   _mesa_MultMatrixf(tm);
}



/**********************************************************************/
/** \name State management */
/*@@{*/


/**
 * Update the projection matrix stack.
 *
 * \param ctx GL context.
 *
 * Calls _math_matrix_analyse() with the top-matrix of the projection matrix
 * stack, and recomputes user clip positions if necessary.
 * 
 * \note This routine references __struct gl_contextRec::Tranform attribute
 * values to compute userclip positions in clip space, but is only called on
 * _NEW_PROJECTION.  The _mesa_ClipPlane() function keeps these values up to
 * date across changes to the __struct gl_contextRec::Transform attributes.
 */
static void
update_projection( struct gl_context *ctx )
{
   _math_matrix_analyse( ctx->ProjectionMatrixStack.Top );

   /* Recompute clip plane positions in clipspace.  This is also done
    * in _mesa_ClipPlane().
    */
   if (ctx->Transform.ClipPlanesEnabled) {
      GLuint p;
      for (p = 0; p < ctx->Const.MaxClipPlanes; p++) {
	 if (ctx->Transform.ClipPlanesEnabled & (1 << p)) {
	    _mesa_transform_vector( ctx->Transform._ClipUserPlane[p],
				 ctx->Transform.EyeUserPlane[p],
				 ctx->ProjectionMatrixStack.Top->inv );
	 }
      }
   }
}


/**
 * Calculate the combined modelview-projection matrix.
 *
 * \param ctx GL context.
 *
 * Multiplies the top matrices of the projection and model view stacks into
 * __struct gl_contextRec::_ModelProjectMatrix via _math_matrix_mul_matrix()
 * and analyzes the resulting matrix via _math_matrix_analyse().
 */
static void
calculate_model_project_matrix( struct gl_context *ctx )
{
   _math_matrix_mul_matrix( &ctx->_ModelProjectMatrix,
                            ctx->ProjectionMatrixStack.Top,
                            ctx->ModelviewMatrixStack.Top );

   _math_matrix_analyse( &ctx->_ModelProjectMatrix );
}


/**
 * Updates the combined modelview-projection matrix.
 *
 * \param ctx GL context.
 * \param new_state new state bit mask.
 *
 * If there is a new model view matrix then analyzes it. If there is a new
 * projection matrix, updates it. Finally calls
 * calculate_model_project_matrix() to recalculate the modelview-projection
 * matrix.
 */
void _mesa_update_modelview_project( struct gl_context *ctx, GLuint new_state )
{
   if (new_state & _NEW_MODELVIEW)
      _math_matrix_analyse( ctx->ModelviewMatrixStack.Top );

   if (new_state & _NEW_PROJECTION)
      update_projection( ctx );

   /* Keep ModelviewProject up to date always to allow tnl
    * implementations that go model->clip even when eye is required.
    */
   calculate_model_project_matrix(ctx);
}

/*@@}*/


/**********************************************************************/
/** Matrix stack initialization */
/*@@{*/


/**
 * Initialize a matrix stack.
 *
 * \param stack matrix stack.
 * \param maxDepth maximum stack depth.
 * \param dirtyFlag dirty flag.
 * 
 * Allocates an array of \p maxDepth elements for the matrix stack and calls
 * _math_matrix_ctr() for each element to initialize it.
 */
static void
init_matrix_stack( struct gl_matrix_stack *stack,
                   GLuint maxDepth, GLuint dirtyFlag )
{
   GLuint i;

   stack->Depth = 0;
   stack->MaxDepth = maxDepth;
   stack->DirtyFlag = dirtyFlag;
   /* The stack */
   stack->Stack = calloc(maxDepth, sizeof(GLmatrix));
   for (i = 0; i < maxDepth; i++) {
      _math_matrix_ctr(&stack->Stack[i]);
   }
   stack->Top = stack->Stack;
}

/**
 * Free matrix stack.
 * 
 * \param stack matrix stack.
 * 
 * Calls _math_matrix_dtr() for each element of the matrix stack and
 * frees the array.
 */
static void
free_matrix_stack( struct gl_matrix_stack *stack )
{
   GLuint i;
   for (i = 0; i < stack->MaxDepth; i++) {
      _math_matrix_dtr(&stack->Stack[i]);
   }
   free(stack->Stack);
   stack->Stack = stack->Top = NULL;
}

/*@@}*/


/**********************************************************************/
/** \name Initialization */
/*@@{*/


/**
 * Initialize the context matrix data.
 *
 * \param ctx GL context.
 *
 * Initializes each of the matrix stacks and the combined modelview-projection
 * matrix.
 */
void _mesa_init_matrix( struct gl_context * ctx )
{
   GLint i;

   /* Initialize matrix stacks */
   init_matrix_stack(&ctx->ModelviewMatrixStack, MAX_MODELVIEW_STACK_DEPTH,
                     _NEW_MODELVIEW);
   init_matrix_stack(&ctx->ProjectionMatrixStack, MAX_PROJECTION_STACK_DEPTH,
                     _NEW_PROJECTION);
   for (i = 0; i < Elements(ctx->TextureMatrixStack); i++)
      init_matrix_stack(&ctx->TextureMatrixStack[i], MAX_TEXTURE_STACK_DEPTH,
                        _NEW_TEXTURE_MATRIX);
   for (i = 0; i < Elements(ctx->ProgramMatrixStack); i++)
      init_matrix_stack(&ctx->ProgramMatrixStack[i], 
		        MAX_PROGRAM_MATRIX_STACK_DEPTH, _NEW_TRACK_MATRIX);
   ctx->CurrentStack = &ctx->ModelviewMatrixStack;

   /* Init combined Modelview*Projection matrix */
   _math_matrix_ctr( &ctx->_ModelProjectMatrix );
}


/**
 * Free the context matrix data.
 * 
 * \param ctx GL context.
 *
 * Frees each of the matrix stacks and the combined modelview-projection
 * matrix.
 */
void _mesa_free_matrix_data( struct gl_context *ctx )
{
   GLint i;

   free_matrix_stack(&ctx->ModelviewMatrixStack);
   free_matrix_stack(&ctx->ProjectionMatrixStack);
   for (i = 0; i < Elements(ctx->TextureMatrixStack); i++)
      free_matrix_stack(&ctx->TextureMatrixStack[i]);
   for (i = 0; i < Elements(ctx->ProgramMatrixStack); i++)
      free_matrix_stack(&ctx->ProgramMatrixStack[i]);
   /* combined Modelview*Projection matrix */
   _math_matrix_dtr( &ctx->_ModelProjectMatrix );

}


/** 
 * Initialize the context transform attribute group.
 *
 * \param ctx GL context.
 *
 * \todo Move this to a new file with other 'transform' routines.
 */
void _mesa_init_transform( struct gl_context *ctx )
{
   GLuint i;

   /* Transformation group */
   ctx->Transform.MatrixMode = GL_MODELVIEW;
   ctx->Transform.Normalize = GL_FALSE;
   ctx->Transform.RescaleNormals = GL_FALSE;
   ctx->Transform.RasterPositionUnclipped = GL_FALSE;
   for (i=0;i<ctx->Const.MaxClipPlanes;i++) {
      ASSIGN_4V( ctx->Transform.EyeUserPlane[i], 0.0, 0.0, 0.0, 0.0 );
   }
   ctx->Transform.ClipPlanesEnabled = 0;
}


/*@@}*/
@


1.6
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.5
log
@Merge Mesa 9.2.0
@
text
@d609 1
a609 1
   if (new_state & _NEW_MODELVIEW) {
a610 8
    
      /* Bring cull position up to date.
       */
      TRANSFORM_POINT3( ctx->Transform.CullObjPos, 
			ctx->ModelviewMatrixStack.Top->inv,
			ctx->Transform.CullEyePos );
   }

a756 3

   ASSIGN_4V( ctx->Transform.CullObjPos, 0.0, 0.0, 1.0, 0.0 );
   ASSIGN_4V( ctx->Transform.CullEyePos, 0.0, 0.0, 1.0, 0.0 );
@


1.4
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a2 1
 * Version:  7.5
d20 4
a23 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
a42 1
#include "mfeatures.h"
d70 2
a71 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d113 2
a114 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
a150 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
a181 16
   case GL_MATRIX0_NV:
   case GL_MATRIX1_NV:
   case GL_MATRIX2_NV:
   case GL_MATRIX3_NV:
   case GL_MATRIX4_NV:
   case GL_MATRIX5_NV:
   case GL_MATRIX6_NV:
   case GL_MATRIX7_NV:
      if (ctx->Extensions.NV_vertex_program) {
         ctx->CurrentStack = &ctx->ProgramMatrixStack[mode - GL_MATRIX0_NV];
      }
      else {
         _mesa_error( ctx,  GL_INVALID_ENUM, "glMatrixMode(mode)" );
         return;
      }
      break;
d190 3
a192 2
      if (ctx->Extensions.ARB_vertex_program ||
          ctx->Extensions.ARB_fragment_program) {
a228 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d268 2
a269 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d306 2
a307 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d341 1
a341 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d370 2
a371 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d395 2
a396 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d421 2
a422 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d445 2
a446 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
a451 1
#if _HAVE_FULL_GL
a493 1
#endif
a495 1
#if _HAVE_FULL_GL
d497 1
a497 1
_mesa_LoadTransposeMatrixfARB( const GLfloat *m )
d507 1
a507 1
_mesa_LoadTransposeMatrixdARB( const GLdouble *m )
d517 1
a517 1
_mesa_MultTransposeMatrixfARB( const GLfloat *m )
d527 1
a527 1
_mesa_MultTransposeMatrixdARB( const GLdouble *m )
a533 1
#endif
a559 1
#if FEATURE_userclip
a572 1
#endif
d645 1
a645 2
 * _math_matrix_ctr() and _math_matrix_alloc_inv() for each element to
 * initialize it.
d657 1
a657 1
   stack->Stack = (GLmatrix *) CALLOC(maxDepth * sizeof(GLmatrix));
a659 1
      _math_matrix_alloc_inv(&stack->Stack[i]);
d679 1
a679 1
   FREE(stack->Stack);
d754 1
a754 1
   GLint i;
d761 1
a761 1
   for (i=0;i<MAX_CLIP_PLANES;i++) {
@


1.3
log
@Merge Mesa 7.10.3
@
text
@d43 1
d143 2
a144 2
 * __struct gl_contextRec::CurrentStack and gl_transform_attrib::MatrixMode with the
 * specified matrix stack.
d173 2
a174 1
         _mesa_error(ctx, GL_INVALID_OPERATION, "glMatrixMode(invalid tex unit %d)",
d236 2
a237 2
 * matrix in the stack. Marks __struct gl_contextRec::NewState with the stack dirty
 * flag.
d276 2
a277 2
 * moves the stack head down. Marks __struct gl_contextRec::NewState with the dirty
 * stack flag.
d313 3
a315 3
 * Flushes the vertices and calls _math_matrix_set_identity() with the top-most
 * matrix in the current stack. Marks __struct gl_contextRec::NewState with the stack
 * dirty flag.
d338 3
a340 3
 * Flushes the vertices and calls _math_matrix_loadf() with the top-most matrix
 * in the current stack and the given matrix. Marks __struct gl_contextRec::NewState
 * with the dirty stack flag.
d564 2
a565 2
 * \note This routine references __struct gl_contextRec::Tranform attribute values to
 * compute userclip positions in clip space, but is only called on
d598 2
a599 2
 * __struct gl_contextRec::_ModelProjectMatrix via _math_matrix_mul_matrix() and
 * analyzes the resulting matrix via _math_matrix_analyse().
d628 1
a628 1
      /* Bring cull position uptodate.
d639 1
a639 1
   /* Keep ModelviewProject uptodate always to allow tnl
@


1.2
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d62 1
a62 1
 * __GLcontextRec::NewState.
d104 1
a104 1
 * __GLcontextRec::NewState.
d142 1
a142 1
 * __GLcontextRec::CurrentStack and gl_transform_attrib::MatrixMode with the
a179 3
   case GL_COLOR:
      ctx->CurrentStack = &ctx->ColorMatrixStack;
      break;
d234 1
a234 1
 * matrix in the stack. Marks __GLcontextRec::NewState with the stack dirty
d274 1
a274 1
 * moves the stack head down. Marks __GLcontextRec::NewState with the dirty
d312 1
a312 1
 * matrix in the current stack. Marks __GLcontextRec::NewState with the stack
d337 1
a337 1
 * in the current stack and the given matrix. Marks __GLcontextRec::NewState
d368 1
a368 1
 * __GLcontextRec::NewState with the dirty stack flag.
d400 1
a400 1
 * __GLcontextRec::NewState with the dirty stack flag.
d425 1
a425 1
 * __GLcontextRec::NewState with the dirty stack flag.
d448 1
a448 1
 * __GLcontextRec::NewState with the dirty stack flag.
d562 1
a562 1
 * \note This routine references __GLcontextRec::Tranform attribute values to
d565 1
a565 1
 * date across changes to the __GLcontextRec::Transform attributes.
d568 1
a568 1
update_projection( GLcontext *ctx )
d596 1
a596 1
 * __GLcontextRec::_ModelProjectMatrix via _math_matrix_mul_matrix() and
d600 1
a600 1
calculate_model_project_matrix( GLcontext *ctx )
d621 1
a621 1
void _mesa_update_modelview_project( GLcontext *ctx, GLuint new_state )
d715 1
a715 1
void _mesa_init_matrix( GLcontext * ctx )
a723 2
   init_matrix_stack(&ctx->ColorMatrixStack, MAX_COLOR_STACK_DEPTH,
                     _NEW_COLOR_MATRIX);
d745 1
a745 1
void _mesa_free_matrix_data( GLcontext *ctx )
a750 1
   free_matrix_stack(&ctx->ColorMatrixStack);
d768 1
a768 1
void _mesa_init_transform( GLcontext *ctx )
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * Version:  6.3
d5 2
a6 1
 * Copyright (C) 1999-2005  Brian Paul   All Rights Reserved.
a45 1
#include "math/m_xform.h"
d163 8
d172 2
a173 1
         _mesa_error(ctx, GL_INVALID_OPERATION, "glMatrixMode(texcoord unit)");
d176 2
d244 1
a244 1
   struct matrix_stack *stack = ctx->CurrentStack;
d284 1
a284 1
   struct matrix_stack *stack = ctx->CurrentStack;
d325 1
a325 1
      _mesa_debug(ctx, "glLoadIdentity()");
d441 1
a441 1
 * Multiply the current matrix with a general scaling matrix.
a549 114
/**
 * Set the viewport.
 * 
 * \param x, y coordinates of the lower-left corner of the viewport rectangle.
 * \param width width of the viewport rectangle.
 * \param height height of the viewport rectangle.
 *
 * \sa Called via glViewport() or display list execution.
 *
 * Flushes the vertices and calls _mesa_set_viewport() with the given
 * parameters.
 */
void GLAPIENTRY
_mesa_Viewport( GLint x, GLint y, GLsizei width, GLsizei height )
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
   _mesa_set_viewport(ctx, x, y, width, height);
}


/**
 * Set new viewport parameters and update derived state (the _WindowMap
 * matrix).  Usually called from _mesa_Viewport().
 * 
 * \param ctx GL context.
 * \param x, y coordinates of the lower left corner of the viewport rectangle.
 * \param width width of the viewport rectangle.
 * \param height height of the viewport rectangle.
 */
void
_mesa_set_viewport( GLcontext *ctx, GLint x, GLint y,
                    GLsizei width, GLsizei height )
{
   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glViewport %d %d %d %d\n", x, y, width, height);

   if (width < 0 || height < 0) {
      _mesa_error( ctx,  GL_INVALID_VALUE,
                   "glViewport(%d, %d, %d, %d)", x, y, width, height );
      return;
   }

   /* clamp width and height to the implementation dependent range */
   width  = CLAMP(width,  1, (GLsizei) ctx->Const.MaxViewportWidth);
   height = CLAMP(height, 1, (GLsizei) ctx->Const.MaxViewportHeight);

   ctx->Viewport.X = x;
   ctx->Viewport.Width = width;
   ctx->Viewport.Y = y;
   ctx->Viewport.Height = height;
   ctx->NewState |= _NEW_VIEWPORT;

#if 1
   /* XXX remove this someday.  Currently the DRI drivers rely on
    * the WindowMap matrix being up to date in the driver's Viewport
    * and DepthRange functions.
    */
   _math_matrix_viewport(&ctx->Viewport._WindowMap,
                         ctx->Viewport.X, ctx->Viewport.Y,
                         ctx->Viewport.Width, ctx->Viewport.Height,
                         ctx->Viewport.Near, ctx->Viewport.Far,
                         ctx->DrawBuffer->_DepthMaxF);
#endif

   if (ctx->Driver.Viewport) {
      /* Many drivers will use this call to check for window size changes
       * and reallocate the z/stencil/accum/etc buffers if needed.
       */
      (*ctx->Driver.Viewport)( ctx, x, y, width, height );
   }
}


#if _HAVE_FULL_GL
/**
 * Called by glDepthRange
 *
 * \param nearval  specifies the Z buffer value which should correspond to
 *                 the near clip plane
 * \param farval  specifies the Z buffer value which should correspond to
 *                the far clip plane
 */
void GLAPIENTRY
_mesa_DepthRange( GLclampd nearval, GLclampd farval )
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

   if (MESA_VERBOSE&VERBOSE_API)
      _mesa_debug(ctx, "glDepthRange %f %f\n", nearval, farval);

   ctx->Viewport.Near = (GLfloat) CLAMP( nearval, 0.0, 1.0 );
   ctx->Viewport.Far = (GLfloat) CLAMP( farval, 0.0, 1.0 );
   ctx->NewState |= _NEW_VIEWPORT;

#if 1
   /* XXX remove this someday.  Currently the DRI drivers rely on
    * the WindowMap matrix being up to date in the driver's Viewport
    * and DepthRange functions.
    */
   _math_matrix_viewport(&ctx->Viewport._WindowMap,
                         ctx->Viewport.X, ctx->Viewport.Y,
                         ctx->Viewport.Width, ctx->Viewport.Height,
                         ctx->Viewport.Near, ctx->Viewport.Far,
                         ctx->DrawBuffer->_DepthMaxF);
#endif

   if (ctx->Driver.DepthRange) {
      (*ctx->Driver.DepthRange)( ctx, nearval, farval );
   }
}
#endif

d666 1
a666 1
init_matrix_stack( struct matrix_stack *stack,
d692 1
a692 1
free_matrix_stack( struct matrix_stack *stack )
d729 1
a729 1
   for (i = 0; i < MAX_TEXTURE_UNITS; i++)
d732 1
a732 1
   for (i = 0; i < MAX_PROGRAM_MATRICES; i++)
d757 1
a757 1
   for (i = 0; i < MAX_TEXTURE_UNITS; i++)
d759 1
a759 1
   for (i = 0; i < MAX_PROGRAM_MATRICES; i++)
a791 37

/** 
 * Initialize the context viewport attribute group.
 *
 * \param ctx GL context.
 * 
 * \todo Move this to a new file with other 'viewport' routines.
 */
void _mesa_init_viewport( GLcontext *ctx )
{
   GLfloat depthMax = 65535.0F; /* sorf of arbitrary */

   /* Viewport group */
   ctx->Viewport.X = 0;
   ctx->Viewport.Y = 0;
   ctx->Viewport.Width = 0;
   ctx->Viewport.Height = 0;
   ctx->Viewport.Near = 0.0;
   ctx->Viewport.Far = 1.0;
   _math_matrix_ctr(&ctx->Viewport._WindowMap);

   _math_matrix_viewport(&ctx->Viewport._WindowMap, 0, 0, 0, 0,
                         0.0F, 1.0F, depthMax);
}


/** 
 * Free the context viewport attribute group data.
 *
 * \param ctx GL context.
 * 
 * \todo Move this to a new file with other 'viewport' routines.
 */
void _mesa_free_viewport_data( GLcontext *ctx )
{
   _math_matrix_dtr(&ctx->Viewport._WindowMap);
}
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@Mesa 7.0.1
@
text
@d3 1
a3 1
 * Version:  6.5.3
d5 1
a5 1
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
d233 1
a233 1
   struct gl_matrix_stack *stack = ctx->CurrentStack;
d273 1
a273 1
   struct gl_matrix_stack *stack = ctx->CurrentStack;
d430 1
a430 1
 * Multiply the current matrix with a translation matrix.
d769 1
a769 1
init_matrix_stack( struct gl_matrix_stack *stack,
d795 1
a795 1
free_matrix_stack( struct gl_matrix_stack *stack )
@


1.1.1.3
log
@Import Mesa 7.10.3
@
text
@d3 1
a3 1
 * Version:  7.5
d5 1
a5 2
 * Copyright (C) 1999-2008  Brian Paul   All Rights Reserved.
 * Copyright (C) 2009  VMware, Inc.  All Rights Reserved.
d45 1
d62 1
a62 1
 * __struct gl_contextRec::NewState.
d104 1
a104 1
 * __struct gl_contextRec::NewState.
d142 1
a142 1
 * __struct gl_contextRec::CurrentStack and gl_transform_attrib::MatrixMode with the
a162 8
      /* This error check is disabled because if we're called from
       * glPopAttrib() when the active texture unit is >= MaxTextureCoordUnits
       * we'll generate an unexpected error.
       * From the GL_ARB_vertex_shader spec it sounds like we should instead
       * do error checking in other places when we actually try to access
       * texture matrices beyond MaxTextureCoordUnits.
       */
#if 0
d164 1
a164 2
         _mesa_error(ctx, GL_INVALID_OPERATION, "glMatrixMode(invalid tex unit %d)",
                     ctx->Texture.CurrentUnit);
a166 2
#endif
      ASSERT(ctx->Texture.CurrentUnit < Elements(ctx->TextureMatrixStack));
d169 3
d226 1
a226 1
 * matrix in the stack. Marks __struct gl_contextRec::NewState with the stack dirty
d266 1
a266 1
 * moves the stack head down. Marks __struct gl_contextRec::NewState with the dirty
d304 1
a304 1
 * matrix in the current stack. Marks __struct gl_contextRec::NewState with the stack
d314 1
a314 1
      _mesa_debug(ctx, "glLoadIdentity()\n");
d329 1
a329 1
 * in the current stack and the given matrix. Marks __struct gl_contextRec::NewState
d360 1
a360 1
 * __struct gl_contextRec::NewState with the dirty stack flag.
d392 1
a392 1
 * __struct gl_contextRec::NewState with the dirty stack flag.
d417 1
a417 1
 * __struct gl_contextRec::NewState with the dirty stack flag.
d440 1
a440 1
 * __struct gl_contextRec::NewState with the dirty stack flag.
d539 114
d668 1
a668 1
 * \note This routine references __struct gl_contextRec::Tranform attribute values to
d671 1
a671 1
 * date across changes to the __struct gl_contextRec::Transform attributes.
d674 1
a674 1
update_projection( struct gl_context *ctx )
d702 1
a702 1
 * __struct gl_contextRec::_ModelProjectMatrix via _math_matrix_mul_matrix() and
d706 1
a706 1
calculate_model_project_matrix( struct gl_context *ctx )
d727 1
a727 1
void _mesa_update_modelview_project( struct gl_context *ctx, GLuint new_state )
d821 1
a821 1
void _mesa_init_matrix( struct gl_context * ctx )
d830 3
a832 1
   for (i = 0; i < Elements(ctx->TextureMatrixStack); i++)
d835 1
a835 1
   for (i = 0; i < Elements(ctx->ProgramMatrixStack); i++)
d853 1
a853 1
void _mesa_free_matrix_data( struct gl_context *ctx )
d859 2
a860 1
   for (i = 0; i < Elements(ctx->TextureMatrixStack); i++)
d862 1
a862 1
   for (i = 0; i < Elements(ctx->ProgramMatrixStack); i++)
d877 1
a877 1
void _mesa_init_transform( struct gl_context *ctx )
d895 37
@


1.1.1.4
log
@Import Mesa 9.2.0
@
text
@d3 1
d21 3
a23 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
d70 1
a70 2

   FLUSH_VERTICES(ctx, 0);
d112 1
a112 2

   FLUSH_VERTICES(ctx, 0);
d142 2
a143 2
 * __struct gl_contextRec::CurrentStack and gl_transform_attrib::MatrixMode
 * with the specified matrix stack.
d149 1
d172 1
a172 2
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glMatrixMode(invalid tex unit %d)",
d180 16
d204 2
a205 3
      if (ctx->API == API_OPENGL_COMPAT
          && (ctx->Extensions.ARB_vertex_program ||
              ctx->Extensions.ARB_fragment_program)) {
d234 2
a235 2
 * matrix in the stack.
 * Marks __struct gl_contextRec::NewState with the stack dirty flag.
d242 1
d274 2
a275 2
 * moves the stack head down.
 * Marks __struct gl_contextRec::NewState with the dirty stack flag.
d282 1
a282 2

   FLUSH_VERTICES(ctx, 0);
d311 3
a313 3
 * Flushes the vertices and calls _math_matrix_set_identity() with the
 * top-most matrix in the current stack.
 * Marks __struct gl_contextRec::NewState with the stack dirty flag.
d319 1
a319 2

   FLUSH_VERTICES(ctx, 0);
d336 3
a338 3
 * Flushes the vertices and calls _math_matrix_loadf() with the top-most
 * matrix in the current stack and the given matrix.
 * Marks __struct gl_contextRec::NewState with the dirty stack flag.
d353 1
a353 1
   FLUSH_VERTICES(ctx, 0);
d382 1
a382 2

   FLUSH_VERTICES(ctx, 0);
d406 1
a406 2

   FLUSH_VERTICES(ctx, 0);
d431 1
a431 2

   FLUSH_VERTICES(ctx, 0);
d454 1
a454 2

   FLUSH_VERTICES(ctx, 0);
d460 1
d503 1
d506 1
d508 1
a508 1
_mesa_LoadTransposeMatrixf( const GLfloat *m )
d518 1
a518 1
_mesa_LoadTransposeMatrixd( const GLdouble *m )
d528 1
a528 1
_mesa_MultTransposeMatrixf( const GLfloat *m )
d538 1
a538 1
_mesa_MultTransposeMatrixd( const GLdouble *m )
d545 1
d562 2
a563 2
 * \note This routine references __struct gl_contextRec::Tranform attribute
 * values to compute userclip positions in clip space, but is only called on
d572 1
d586 1
d596 2
a597 2
 * __struct gl_contextRec::_ModelProjectMatrix via _math_matrix_mul_matrix()
 * and analyzes the resulting matrix via _math_matrix_analyse().
d626 1
a626 1
      /* Bring cull position up to date.
d637 1
a637 1
   /* Keep ModelviewProject up to date always to allow tnl
d659 2
a660 1
 * _math_matrix_ctr() for each element to initialize it.
d672 1
a672 1
   stack->Stack = calloc(maxDepth, sizeof(GLmatrix));
d675 1
d695 1
a695 1
   free(stack->Stack);
d770 1
a770 1
   GLuint i;
d777 1
a777 1
   for (i=0;i<ctx->Const.MaxClipPlanes;i++) {
@


1.1.1.5
log
@Import Mesa 10.2.3
@
text
@d609 1
a609 1
   if (new_state & _NEW_MODELVIEW)
d611 8
d765 3
@


