head	1.9;
access;
symbols
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.6.0.2
	OPENBSD_5_6_BASE:1.6
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.5.0.2
	OPENBSD_5_5_BASE:1.5
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.4.0.4
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.2
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.3.0.4
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.2.0.6
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.0.4
	OPENBSD_4_7_BASE:1.1
	OPENBSD_4_6:1.1.0.2
	OPENBSD_4_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.9
date	2015.12.23.05.17.52;	author jsg;	state dead;
branches;
next	1.8;
commitid	TnlogFl9nOv2eaRf;

1.8
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.7;
commitid	4ry2gvZGMXkCUD2n;

1.7
date	2015.01.25.14.41.22;	author jsg;	state Exp;
branches;
next	1.6;
commitid	mcxB0JvoI9gTDYXU;

1.6
date	2014.07.09.21.09.00;	author jsg;	state Exp;
branches;
next	1.5;
commitid	WPD6rgPryPkvXOr9;

1.5
date	2013.09.05.14.06.25;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2012.08.17.13.58.19;	author mpi;	state Exp;
branches;
next	1.3;

1.3
date	2011.10.23.13.37.42;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.05.22.20.06.31;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2009.05.17.20.26.41;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.46;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.16.44;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.35.03;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.12.47;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.49.54;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.9
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */


#include "main/glheader.h"
#include "main/context.h"
#include "main/macros.h"
#include "main/multisample.h"
#include "main/mtypes.h"
#include "main/fbobject.h"
#include "main/glformats.h"
#include "main/state.h"


/**
 * Called via glSampleCoverageARB
 */
void GLAPIENTRY
_mesa_SampleCoverage(GLclampf value, GLboolean invert)
{
   GET_CURRENT_CONTEXT(ctx);

   FLUSH_VERTICES(ctx, 0);

   ctx->Multisample.SampleCoverageValue = (GLfloat) CLAMP(value, 0.0, 1.0);
   ctx->Multisample.SampleCoverageInvert = invert;
   ctx->NewState |= _NEW_MULTISAMPLE;
}


/**
 * Initialize the context's multisample state.
 * \param ctx  the GL context.
 */
void
_mesa_init_multisample(struct gl_context *ctx)
{
   ctx->Multisample.Enabled = GL_TRUE;
   ctx->Multisample.SampleAlphaToCoverage = GL_FALSE;
   ctx->Multisample.SampleAlphaToOne = GL_FALSE;
   ctx->Multisample.SampleCoverage = GL_FALSE;
   ctx->Multisample.SampleCoverageValue = 1.0;
   ctx->Multisample.SampleCoverageInvert = GL_FALSE;

   /* ARB_texture_multisample / GL3.2 additions */
   ctx->Multisample.SampleMask = GL_FALSE;
   ctx->Multisample.SampleMaskValue = ~(GLbitfield)0;
}


void GLAPIENTRY
_mesa_GetMultisamplefv(GLenum pname, GLuint index, GLfloat * val)
{
   GET_CURRENT_CONTEXT(ctx);

   if (ctx->NewState & _NEW_BUFFERS) {
      _mesa_update_state(ctx);
   }

   switch (pname) {
   case GL_SAMPLE_POSITION: {
      if ((int) index >= ctx->DrawBuffer->Visual.samples) {
         _mesa_error( ctx, GL_INVALID_VALUE, "glGetMultisamplefv(index)" );
         return;
      }

      ctx->Driver.GetSamplePosition(ctx, ctx->DrawBuffer, index, val);

      /* winsys FBOs are upside down */
      if (_mesa_is_winsys_fbo(ctx->DrawBuffer))
         val[1] = 1 - val[1];

      return;
   }

   default:
      _mesa_error( ctx, GL_INVALID_ENUM, "glGetMultisamplefv(pname)" );
      return;
   }
}

void GLAPIENTRY
_mesa_SampleMaski(GLuint index, GLbitfield mask)
{
   GET_CURRENT_CONTEXT(ctx);

   if (!ctx->Extensions.ARB_texture_multisample) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glSampleMaski");
      return;
   }

   if (index != 0) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glSampleMaski(index)");
      return;
   }

   FLUSH_VERTICES(ctx, _NEW_MULTISAMPLE);
   ctx->Multisample.SampleMaskValue = mask;
}

/**
 * Called via glMinSampleShadingARB
 */
void GLAPIENTRY
_mesa_MinSampleShading(GLclampf value)
{
   GET_CURRENT_CONTEXT(ctx);

   if (!ctx->Extensions.ARB_sample_shading || !_mesa_is_desktop_gl(ctx)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glMinSampleShading");
      return;
   }

   FLUSH_VERTICES(ctx, 0);

   ctx->Multisample.MinSampleShadingValue = CLAMP(value, 0.0, 1.0);
   ctx->NewState |= _NEW_MULTISAMPLE;
}

/**
 * Helper for checking a requested sample count against the limit
 * for a particular (target, internalFormat) pair. The limit imposed,
 * and the error generated, both depend on which extensions are supported.
 *
 * Returns a GL error enum, or GL_NO_ERROR if the requested sample count is
 * acceptable.
 */
GLenum
_mesa_check_sample_count(struct gl_context *ctx, GLenum target,
                         GLenum internalFormat, GLsizei samples)
{
   /* If ARB_internalformat_query is supported, then treat its highest
    * returned sample count as the absolute maximum for this format; it is
    * allowed to exceed MAX_SAMPLES.
    *
    * From the ARB_internalformat_query spec:
    *
    * "If <samples is greater than the maximum number of samples supported
    * for <internalformat> then the error INVALID_OPERATION is generated."
    */
   if (ctx->Extensions.ARB_internalformat_query) {
      GLint buffer[16];
      int count = ctx->Driver.QuerySamplesForFormat(ctx, target,
                                                    internalFormat, buffer);
      int limit = count ? buffer[0] : -1;

      return samples > limit ? GL_INVALID_OPERATION : GL_NO_ERROR;
   }

   /* If ARB_texture_multisample is supported, we have separate limits,
    * which may be lower than MAX_SAMPLES:
    *
    * From the ARB_texture_multisample spec, when describing the operation
    * of RenderbufferStorageMultisample:
    *
    * "If <internalformat> is a signed or unsigned integer format and
    * <samples> is greater than the value of MAX_INTEGER_SAMPLES, then the
    * error INVALID_OPERATION is generated"
    *
    * And when describing the operation of TexImage*Multisample:
    *
    * "The error INVALID_OPERATION may be generated if any of the following
    * are true:
    *
    * * <internalformat> is a depth/stencil-renderable format and <samples>
    *   is greater than the value of MAX_DEPTH_TEXTURE_SAMPLES
    * * <internalformat> is a color-renderable format and <samples> is
    *   grater than the value of MAX_COLOR_TEXTURE_SAMPLES
    * * <internalformat> is a signed or unsigned integer format and
    *   <samples> is greater than the value of MAX_INTEGER_SAMPLES
    */

   if (ctx->Extensions.ARB_texture_multisample) {
      if (_mesa_is_enum_format_integer(internalFormat))
         return samples > ctx->Const.MaxIntegerSamples
            ? GL_INVALID_OPERATION : GL_NO_ERROR;

      if (target == GL_TEXTURE_2D_MULTISAMPLE ||
          target == GL_TEXTURE_2D_MULTISAMPLE_ARRAY) {

         if (_mesa_is_depth_or_stencil_format(internalFormat))
            return samples > ctx->Const.MaxDepthTextureSamples
               ? GL_INVALID_OPERATION : GL_NO_ERROR;
         else
            return samples > ctx->Const.MaxColorTextureSamples
               ? GL_INVALID_OPERATION : GL_NO_ERROR;
      }
   }

   /* No more specific limit is available, so just use MAX_SAMPLES:
    *
    * On p205 of the GL3.1 spec:
    *
    * "... or if samples is greater than MAX_SAMPLES, then the error
    * INVALID_VALUE is generated"
    */
   return (GLuint) samples > ctx->Const.MaxSamples
      ? GL_INVALID_VALUE : GL_NO_ERROR;
}
@


1.8
log
@Merge Mesa 10.2.9
@
text
@@


1.7
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d92 1
a92 1
         val[1] = 1.0f - val[1];
@


1.6
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d92 1
a92 1
         val[1] = 1 - val[1];
@


1.5
log
@Merge Mesa 9.2.0
@
text
@d122 18
@


1.4
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a2 1
 * Version:  7.1
d19 4
a22 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
d31 3
d40 1
a40 1
_mesa_SampleCoverageARB(GLclampf value, GLboolean invert)
d44 1
a44 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH( ctx );
d65 137
@


1.3
log
@Merge Mesa 7.10.3
@
text
@d30 1
@


1.2
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d53 1
a53 1
_mesa_init_multisample(GLcontext *ctx)
@


1.1
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@a39 5
   if (!ctx->Extensions.ARB_multisample) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glSampleCoverageARB");
      return;
   }

@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d40 5
d58 1
a58 1
_mesa_init_multisample(struct gl_context *ctx)
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d3 1
d20 3
a22 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
a29 4
#include "main/mtypes.h"
#include "main/fbobject.h"
#include "main/glformats.h"
#include "main/state.h"
d36 1
a36 1
_mesa_SampleCoverage(GLclampf value, GLboolean invert)
d40 1
a40 1
   FLUSH_VERTICES(ctx, 0);
a60 137

   /* ARB_texture_multisample / GL3.2 additions */
   ctx->Multisample.SampleMask = GL_FALSE;
   ctx->Multisample.SampleMaskValue = ~(GLbitfield)0;
}


void GLAPIENTRY
_mesa_GetMultisamplefv(GLenum pname, GLuint index, GLfloat * val)
{
   GET_CURRENT_CONTEXT(ctx);

   if (ctx->NewState & _NEW_BUFFERS) {
      _mesa_update_state(ctx);
   }

   switch (pname) {
   case GL_SAMPLE_POSITION: {
      if ((int) index >= ctx->DrawBuffer->Visual.samples) {
         _mesa_error( ctx, GL_INVALID_VALUE, "glGetMultisamplefv(index)" );
         return;
      }

      ctx->Driver.GetSamplePosition(ctx, ctx->DrawBuffer, index, val);

      /* winsys FBOs are upside down */
      if (_mesa_is_winsys_fbo(ctx->DrawBuffer))
         val[1] = 1 - val[1];

      return;
   }

   default:
      _mesa_error( ctx, GL_INVALID_ENUM, "glGetMultisamplefv(pname)" );
      return;
   }
}

void GLAPIENTRY
_mesa_SampleMaski(GLuint index, GLbitfield mask)
{
   GET_CURRENT_CONTEXT(ctx);

   if (!ctx->Extensions.ARB_texture_multisample) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glSampleMaski");
      return;
   }

   if (index != 0) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glSampleMaski(index)");
      return;
   }

   FLUSH_VERTICES(ctx, _NEW_MULTISAMPLE);
   ctx->Multisample.SampleMaskValue = mask;
}


/**
 * Helper for checking a requested sample count against the limit
 * for a particular (target, internalFormat) pair. The limit imposed,
 * and the error generated, both depend on which extensions are supported.
 *
 * Returns a GL error enum, or GL_NO_ERROR if the requested sample count is
 * acceptable.
 */
GLenum
_mesa_check_sample_count(struct gl_context *ctx, GLenum target,
                         GLenum internalFormat, GLsizei samples)
{
   /* If ARB_internalformat_query is supported, then treat its highest
    * returned sample count as the absolute maximum for this format; it is
    * allowed to exceed MAX_SAMPLES.
    *
    * From the ARB_internalformat_query spec:
    *
    * "If <samples is greater than the maximum number of samples supported
    * for <internalformat> then the error INVALID_OPERATION is generated."
    */
   if (ctx->Extensions.ARB_internalformat_query) {
      GLint buffer[16];
      int count = ctx->Driver.QuerySamplesForFormat(ctx, target,
                                                    internalFormat, buffer);
      int limit = count ? buffer[0] : -1;

      return samples > limit ? GL_INVALID_OPERATION : GL_NO_ERROR;
   }

   /* If ARB_texture_multisample is supported, we have separate limits,
    * which may be lower than MAX_SAMPLES:
    *
    * From the ARB_texture_multisample spec, when describing the operation
    * of RenderbufferStorageMultisample:
    *
    * "If <internalformat> is a signed or unsigned integer format and
    * <samples> is greater than the value of MAX_INTEGER_SAMPLES, then the
    * error INVALID_OPERATION is generated"
    *
    * And when describing the operation of TexImage*Multisample:
    *
    * "The error INVALID_OPERATION may be generated if any of the following
    * are true:
    *
    * * <internalformat> is a depth/stencil-renderable format and <samples>
    *   is greater than the value of MAX_DEPTH_TEXTURE_SAMPLES
    * * <internalformat> is a color-renderable format and <samples> is
    *   grater than the value of MAX_COLOR_TEXTURE_SAMPLES
    * * <internalformat> is a signed or unsigned integer format and
    *   <samples> is greater than the value of MAX_INTEGER_SAMPLES
    */

   if (ctx->Extensions.ARB_texture_multisample) {
      if (_mesa_is_enum_format_integer(internalFormat))
         return samples > ctx->Const.MaxIntegerSamples
            ? GL_INVALID_OPERATION : GL_NO_ERROR;

      if (target == GL_TEXTURE_2D_MULTISAMPLE ||
          target == GL_TEXTURE_2D_MULTISAMPLE_ARRAY) {

         if (_mesa_is_depth_or_stencil_format(internalFormat))
            return samples > ctx->Const.MaxDepthTextureSamples
               ? GL_INVALID_OPERATION : GL_NO_ERROR;
         else
            return samples > ctx->Const.MaxColorTextureSamples
               ? GL_INVALID_OPERATION : GL_NO_ERROR;
      }
   }

   /* No more specific limit is available, so just use MAX_SAMPLES:
    *
    * On p205 of the GL3.1 spec:
    *
    * "... or if samples is greater than MAX_SAMPLES, then the error
    * INVALID_VALUE is generated"
    */
   return (GLuint) samples > ctx->Const.MaxSamples
      ? GL_INVALID_VALUE : GL_NO_ERROR;
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@a121 18
/**
 * Called via glMinSampleShadingARB
 */
void GLAPIENTRY
_mesa_MinSampleShading(GLclampf value)
{
   GET_CURRENT_CONTEXT(ctx);

   if (!ctx->Extensions.ARB_sample_shading || !_mesa_is_desktop_gl(ctx)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glMinSampleShading");
      return;
   }

   FLUSH_VERTICES(ctx, 0);

   ctx->Multisample.MinSampleShadingValue = CLAMP(value, 0.0, 1.0);
   ctx->NewState |= _NEW_MULTISAMPLE;
}
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d92 1
a92 1
         val[1] = 1.0f - val[1];
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d92 1
a92 1
         val[1] = 1 - val[1];
@


