head	1.12;
access;
symbols
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	v10_2_9:1.1.1.8
	v10_4_3:1.1.1.7
	v10_2_7:1.1.1.6
	OPENBSD_5_6:1.9.0.2
	OPENBSD_5_6_BASE:1.9
	v10_2_3:1.1.1.6
	OPENBSD_5_5:1.8.0.2
	OPENBSD_5_5_BASE:1.8
	v9_2_5:1.1.1.5
	v9_2_3:1.1.1.5
	v9_2_2:1.1.1.5
	v9_2_1:1.1.1.5
	v9_2_0:1.1.1.5
	OPENBSD_5_4:1.7.0.4
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.6.0.4
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.5.0.6
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2015.12.23.05.17.52;	author jsg;	state dead;
branches;
next	1.11;
commitid	TnlogFl9nOv2eaRf;

1.11
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.10;
commitid	4ry2gvZGMXkCUD2n;

1.10
date	2015.01.25.14.41.21;	author jsg;	state Exp;
branches;
next	1.9;
commitid	mcxB0JvoI9gTDYXU;

1.9
date	2014.07.09.21.09.00;	author jsg;	state Exp;
branches;
next	1.8;
commitid	WPD6rgPryPkvXOr9;

1.8
date	2013.09.05.14.06.18;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2012.08.17.13.58.17;	author mpi;	state Exp;
branches;
next	1.6;

1.6
date	2011.10.23.13.37.42;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.05.22.20.06.30;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.05.17.20.26.41;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.14.58.20;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.05.31.16.36.48;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.49.50;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.49.50;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.56.33;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.30.53;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.45;	author matthieu;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.09.05.13.16.26;	author jsg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.07.09.20.34.59;	author jsg;	state Exp;
branches;
next	1.1.1.7;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.7
date	2015.01.25.14.12.30;	author jsg;	state Exp;
branches;
next	1.1.1.8;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.8
date	2015.02.20.22.49.37;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.12
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**
 * \file dd.h
 * Device driver interfaces.
 */

/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */


#ifndef DD_INCLUDED
#define DD_INCLUDED

/* THIS FILE ONLY INCLUDED BY mtypes.h !!!!! */

#include "glheader.h"

struct gl_buffer_object;
struct gl_context;
struct gl_display_list;
struct gl_framebuffer;
struct gl_image_unit;
struct gl_pixelstore_attrib;
struct gl_program;
struct gl_renderbuffer;
struct gl_renderbuffer_attachment;
struct gl_shader;
struct gl_shader_program;
struct gl_texture_image;
struct gl_texture_object;

/* GL_ARB_vertex_buffer_object */
/* Modifies GL_MAP_UNSYNCHRONIZED_BIT to allow driver to fail (return
 * NULL) if buffer is unavailable for immediate mapping.
 *
 * Does GL_MAP_INVALIDATE_RANGE_BIT do this?  It seems so, but it
 * would require more book-keeping in the driver than seems necessary
 * at this point.
 *
 * Does GL_MAP_INVALDIATE_BUFFER_BIT do this?  Not really -- we don't
 * want to provoke the driver to throw away the old storage, we will
 * respect the contents of already referenced data.
 */
#define MESA_MAP_NOWAIT_BIT       0x0040


/**
 * Device driver function table.
 * Core Mesa uses these function pointers to call into device drivers.
 * Most of these functions directly correspond to OpenGL state commands.
 * Core Mesa will call these functions after error checking has been done
 * so that the drivers don't have to worry about error testing.
 *
 * Vertex transformation/clipping/lighting is patched into the T&L module.
 * Rasterization functions are patched into the swrast module.
 *
 * Note: when new functions are added here, the drivers/common/driverfuncs.c
 * file should be updated too!!!
 */
struct dd_function_table {
   /**
    * Return a string as needed by glGetString().
    * Only the GL_RENDERER query must be implemented.  Otherwise, NULL can be
    * returned.
    */
   const GLubyte * (*GetString)( struct gl_context *ctx, GLenum name );

   /**
    * Notify the driver after Mesa has made some internal state changes.  
    *
    * This is in addition to any state change callbacks Mesa may already have
    * made.
    */
   void (*UpdateState)( struct gl_context *ctx, GLbitfield new_state );

   /**
    * Resize the given framebuffer to the given size.
    * XXX OBSOLETE: this function will be removed in the future.
    */
   void (*ResizeBuffers)( struct gl_context *ctx, struct gl_framebuffer *fb,
                          GLuint width, GLuint height);

   /**
    * This is called whenever glFinish() is called.
    */
   void (*Finish)( struct gl_context *ctx );

   /**
    * This is called whenever glFlush() is called.
    */
   void (*Flush)( struct gl_context *ctx );

   /**
    * Clear the color/depth/stencil/accum buffer(s).
    * \param buffers  a bitmask of BUFFER_BIT_* flags indicating which
    *                 renderbuffers need to be cleared.
    */
   void (*Clear)( struct gl_context *ctx, GLbitfield buffers );

   /**
    * Execute glAccum command.
    */
   void (*Accum)( struct gl_context *ctx, GLenum op, GLfloat value );


   /**
    * Execute glRasterPos, updating the ctx->Current.Raster fields
    */
   void (*RasterPos)( struct gl_context *ctx, const GLfloat v[4] );

   /**
    * \name Image-related functions
    */
   /*@@{*/

   /**
    * Called by glDrawPixels().
    * \p unpack describes how to unpack the source image data.
    */
   void (*DrawPixels)( struct gl_context *ctx,
		       GLint x, GLint y, GLsizei width, GLsizei height,
		       GLenum format, GLenum type,
		       const struct gl_pixelstore_attrib *unpack,
		       const GLvoid *pixels );

   /**
    * Called by glReadPixels().
    */
   void (*ReadPixels)( struct gl_context *ctx,
		       GLint x, GLint y, GLsizei width, GLsizei height,
		       GLenum format, GLenum type,
		       const struct gl_pixelstore_attrib *unpack,
		       GLvoid *dest );

   /**
    * Called by glCopyPixels().  
    */
   void (*CopyPixels)( struct gl_context *ctx, GLint srcx, GLint srcy,
                       GLsizei width, GLsizei height,
                       GLint dstx, GLint dsty, GLenum type );

   /**
    * Called by glBitmap().  
    */
   void (*Bitmap)( struct gl_context *ctx,
		   GLint x, GLint y, GLsizei width, GLsizei height,
		   const struct gl_pixelstore_attrib *unpack,
		   const GLubyte *bitmap );
   /*@@}*/

   
   /**
    * \name Texture image functions
    */
   /*@@{*/

   /**
    * Choose actual hardware texture format given the texture target, the
    * user-provided source image format and type and the desired internal
    * format.  In some cases, srcFormat and srcType can be GL_NONE.
    * Note:  target may be GL_TEXTURE_CUBE_MAP, but never
    * GL_TEXTURE_CUBE_MAP_[POSITIVE/NEGATIVE]_[XYZ].
    * Called by glTexImage(), etc.
    */
   mesa_format (*ChooseTextureFormat)(struct gl_context *ctx,
                                      GLenum target, GLint internalFormat,
                                      GLenum srcFormat, GLenum srcType );

   /**
    * Determine sample counts support for a particular target and format
    *
    * \param ctx            GL context
    * \param target         GL target enum
    * \param internalFormat GL format enum
    * \param samples        Buffer to hold the returned sample counts.
    *                       Drivers \b must \b not return more than 16 counts.
    *
    * \returns
    * The number of sample counts actually written to \c samples.  If
    * \c internaFormat is not renderable, zero is returned.
    */
   size_t (*QuerySamplesForFormat)(struct gl_context *ctx,
                                   GLenum target,
                                   GLenum internalFormat,
                                   int samples[16]);

   /**
    * Called by glTexImage[123]D() and glCopyTexImage[12]D()
    * Allocate texture memory and copy the user's image to the buffer.
    * The gl_texture_image fields, etc. will be fully initialized.
    * The parameters are the same as glTexImage3D(), plus:
    * \param dims  1, 2, or 3 indicating glTexImage1/2/3D()
    * \param packing describes how to unpack the source data.
    * \param texImage is the destination texture image.
    */
   void (*TexImage)(struct gl_context *ctx, GLuint dims,
                    struct gl_texture_image *texImage,
                    GLenum format, GLenum type, const GLvoid *pixels,
                    const struct gl_pixelstore_attrib *packing);

   /**
    * Called by glTexSubImage[123]D().
    * Replace a subset of the target texture with new texel data.
    */
   void (*TexSubImage)(struct gl_context *ctx, GLuint dims,
                       struct gl_texture_image *texImage,
                       GLint xoffset, GLint yoffset, GLint zoffset,
                       GLsizei width, GLsizei height, GLint depth,
                       GLenum format, GLenum type,
                       const GLvoid *pixels,
                       const struct gl_pixelstore_attrib *packing);


   /**
    * Called by glGetTexImage().
    */
   void (*GetTexImage)( struct gl_context *ctx,
                        GLenum format, GLenum type, GLvoid *pixels,
                        struct gl_texture_image *texImage );

   /**
    * Called by glCopyTex[Sub]Image[123]D().
    *
    * This function should copy a rectangular region in the rb to a single
    * destination slice, specified by @@slice.  In the case of 1D array
    * textures (where one GL call can potentially affect multiple destination
    * slices), core mesa takes care of calling this function multiple times,
    * once for each scanline to be copied.
    */
   void (*CopyTexSubImage)(struct gl_context *ctx, GLuint dims,
                           struct gl_texture_image *texImage,
                           GLint xoffset, GLint yoffset, GLint slice,
                           struct gl_renderbuffer *rb,
                           GLint x, GLint y,
                           GLsizei width, GLsizei height);

   /**
    * Called by glGenerateMipmap() or when GL_GENERATE_MIPMAP_SGIS is enabled.
    * Note that if the texture is a cube map, the <target> parameter will
    * indicate which cube face to generate (GL_POSITIVE/NEGATIVE_X/Y/Z).
    * texObj->BaseLevel is the level from which to generate the remaining
    * mipmap levels.
    */
   void (*GenerateMipmap)(struct gl_context *ctx, GLenum target,
                          struct gl_texture_object *texObj);

   /**
    * Called by glTexImage, glCompressedTexImage, glCopyTexImage
    * and glTexStorage to check if the dimensions of the texture image
    * are too large.
    * \param target  any GL_PROXY_TEXTURE_x target
    * \return GL_TRUE if the image is OK, GL_FALSE if too large
    */
   GLboolean (*TestProxyTexImage)(struct gl_context *ctx, GLenum target,
                                  GLint level, mesa_format format,
                                  GLint width, GLint height,
                                  GLint depth, GLint border);
   /*@@}*/

   
   /**
    * \name Compressed texture functions
    */
   /*@@{*/

   /**
    * Called by glCompressedTexImage[123]D().
    */
   void (*CompressedTexImage)(struct gl_context *ctx, GLuint dims,
                              struct gl_texture_image *texImage,
                              GLsizei imageSize, const GLvoid *data);

   /**
    * Called by glCompressedTexSubImage[123]D().
    */
   void (*CompressedTexSubImage)(struct gl_context *ctx, GLuint dims,
                                 struct gl_texture_image *texImage,
                                 GLint xoffset, GLint yoffset, GLint zoffset,
                                 GLsizei width, GLint height, GLint depth,
                                 GLenum format,
                                 GLsizei imageSize, const GLvoid *data);

   /**
    * Called by glGetCompressedTexImage.
    */
   void (*GetCompressedTexImage)(struct gl_context *ctx,
                                 struct gl_texture_image *texImage,
                                 GLvoid *data);
   /*@@}*/

   /**
    * \name Texture object / image functions
    */
   /*@@{*/

   /**
    * Called by glBindTexture() and glBindTextures().
    */
   void (*BindTexture)( struct gl_context *ctx, GLuint texUnit,
                        GLenum target, struct gl_texture_object *tObj );

   /**
    * Called to allocate a new texture object.  Drivers will usually
    * allocate/return a subclass of gl_texture_object.
    */
   struct gl_texture_object * (*NewTextureObject)(struct gl_context *ctx,
                                                  GLuint name, GLenum target);
   /**
    * Called to delete/free a texture object.  Drivers should free the
    * object and any image data it contains.
    */
   void (*DeleteTexture)(struct gl_context *ctx,
                         struct gl_texture_object *texObj);

   /** Called to allocate a new texture image object. */
   struct gl_texture_image * (*NewTextureImage)(struct gl_context *ctx);

   /** Called to free a texture image object returned by NewTextureImage() */
   void (*DeleteTextureImage)(struct gl_context *ctx,
                              struct gl_texture_image *);

   /** Called to allocate memory for a single texture image */
   GLboolean (*AllocTextureImageBuffer)(struct gl_context *ctx,
                                        struct gl_texture_image *texImage);

   /** Free the memory for a single texture image */
   void (*FreeTextureImageBuffer)(struct gl_context *ctx,
                                  struct gl_texture_image *texImage);

   /** Map a slice of a texture image into user space.
    * Note: for GL_TEXTURE_1D_ARRAY, height must be 1, y must be 0 and slice
    * indicates the 1D array index.
    * \param texImage  the texture image
    * \param slice  the 3D image slice or array texture slice
    * \param x, y, w, h  region of interest
    * \param mode  bitmask of GL_MAP_READ_BIT, GL_MAP_WRITE_BIT and
    *              GL_MAP_INVALIDATE_RANGE_BIT (if writing)
    * \param mapOut  returns start of mapping of region of interest
    * \param rowStrideOut returns row stride (in bytes).  In the case of a
    * compressed texture, this is the byte stride between one row of blocks
    * and another.
    */
   void (*MapTextureImage)(struct gl_context *ctx,
			   struct gl_texture_image *texImage,
			   GLuint slice,
			   GLuint x, GLuint y, GLuint w, GLuint h,
			   GLbitfield mode,
			   GLubyte **mapOut, GLint *rowStrideOut);

   void (*UnmapTextureImage)(struct gl_context *ctx,
			     struct gl_texture_image *texImage,
			     GLuint slice);

   /** For GL_ARB_texture_storage.  Allocate memory for whole mipmap stack.
    * All the gl_texture_images in the texture object will have their
    * dimensions, format, etc. initialized already.
    */
   GLboolean (*AllocTextureStorage)(struct gl_context *ctx,
                                    struct gl_texture_object *texObj,
                                    GLsizei levels, GLsizei width,
                                    GLsizei height, GLsizei depth);

   /** Called as part of glTextureView to add views to origTexObj */
   GLboolean (*TextureView)(struct gl_context *ctx,
                            struct gl_texture_object *texObj,
                            struct gl_texture_object *origTexObj);

   /**
    * Map a renderbuffer into user space.
    * \param mode  bitmask of GL_MAP_READ_BIT, GL_MAP_WRITE_BIT and
    *              GL_MAP_INVALIDATE_RANGE_BIT (if writing)
    */
   void (*MapRenderbuffer)(struct gl_context *ctx,
			   struct gl_renderbuffer *rb,
			   GLuint x, GLuint y, GLuint w, GLuint h,
			   GLbitfield mode,
			   GLubyte **mapOut, GLint *rowStrideOut);

   void (*UnmapRenderbuffer)(struct gl_context *ctx,
			     struct gl_renderbuffer *rb);

   /**
    * Optional driver entrypoint that binds a non-texture renderbuffer's
    * contents to a texture image.
    */
   GLboolean (*BindRenderbufferTexImage)(struct gl_context *ctx,
                                         struct gl_renderbuffer *rb,
                                         struct gl_texture_image *texImage);
   /*@@}*/


   /**
    * \name Vertex/fragment program functions
    */
   /*@@{*/
   /** Bind a vertex/fragment program */
   void (*BindProgram)(struct gl_context *ctx, GLenum target,
                       struct gl_program *prog);
   /** Allocate a new program */
   struct gl_program * (*NewProgram)(struct gl_context *ctx, GLenum target,
                                     GLuint id);
   /** Delete a program */
   void (*DeleteProgram)(struct gl_context *ctx, struct gl_program *prog);   
   /**
    * Notify driver that a program string (and GPU code) has been specified
    * or modified.  Return GL_TRUE or GL_FALSE to indicate if the program is
    * supported by the driver.
    */
   GLboolean (*ProgramStringNotify)(struct gl_context *ctx, GLenum target, 
                                    struct gl_program *prog);

   /**
    * Notify driver that the sampler uniforms for the current program have
    * changed.  On some drivers, this may require shader recompiles.
    */
   void (*SamplerUniformChange)(struct gl_context *ctx, GLenum target,
                                struct gl_program *prog);

   /** Query if program can be loaded onto hardware */
   GLboolean (*IsProgramNative)(struct gl_context *ctx, GLenum target, 
				struct gl_program *prog);
   
   /*@@}*/

   /**
    * \name GLSL shader/program functions.
    */
   /*@@{*/
   /**
    * Called when a shader program is linked.
    *
    * This gives drivers an opportunity to clone the IR and make their
    * own transformations on it for the purposes of code generation.
    */
   GLboolean (*LinkShader)(struct gl_context *ctx,
                           struct gl_shader_program *shader);
   /*@@}*/

   /**
    * \name State-changing functions.
    *
    * \note drawing functions are above.
    *
    * These functions are called by their corresponding OpenGL API functions.
    * They are \e also called by the gl_PopAttrib() function!!!
    * May add more functions like these to the device driver in the future.
    */
   /*@@{*/
   /** Specify the alpha test function */
   void (*AlphaFunc)(struct gl_context *ctx, GLenum func, GLfloat ref);
   /** Set the blend color */
   void (*BlendColor)(struct gl_context *ctx, const GLfloat color[4]);
   /** Set the blend equation */
   void (*BlendEquationSeparate)(struct gl_context *ctx,
                                 GLenum modeRGB, GLenum modeA);
   void (*BlendEquationSeparatei)(struct gl_context *ctx, GLuint buffer,
                                  GLenum modeRGB, GLenum modeA);
   /** Specify pixel arithmetic */
   void (*BlendFuncSeparate)(struct gl_context *ctx,
                             GLenum sfactorRGB, GLenum dfactorRGB,
                             GLenum sfactorA, GLenum dfactorA);
   void (*BlendFuncSeparatei)(struct gl_context *ctx, GLuint buffer,
                              GLenum sfactorRGB, GLenum dfactorRGB,
                              GLenum sfactorA, GLenum dfactorA);
   /** Specify a plane against which all geometry is clipped */
   void (*ClipPlane)(struct gl_context *ctx, GLenum plane, const GLfloat *eq);
   /** Enable and disable writing of frame buffer color components */
   void (*ColorMask)(struct gl_context *ctx, GLboolean rmask, GLboolean gmask,
                     GLboolean bmask, GLboolean amask );
   void (*ColorMaskIndexed)(struct gl_context *ctx, GLuint buf, GLboolean rmask,
                            GLboolean gmask, GLboolean bmask, GLboolean amask);
   /** Cause a material color to track the current color */
   void (*ColorMaterial)(struct gl_context *ctx, GLenum face, GLenum mode);
   /** Specify whether front- or back-facing facets can be culled */
   void (*CullFace)(struct gl_context *ctx, GLenum mode);
   /** Define front- and back-facing polygons */
   void (*FrontFace)(struct gl_context *ctx, GLenum mode);
   /** Specify the value used for depth buffer comparisons */
   void (*DepthFunc)(struct gl_context *ctx, GLenum func);
   /** Enable or disable writing into the depth buffer */
   void (*DepthMask)(struct gl_context *ctx, GLboolean flag);
   /** Specify mapping of depth values from NDC to window coordinates */
   void (*DepthRange)(struct gl_context *ctx);
   /** Specify the current buffer for writing */
   void (*DrawBuffer)( struct gl_context *ctx, GLenum buffer );
   /** Specify the buffers for writing for fragment programs*/
   void (*DrawBuffers)(struct gl_context *ctx, GLsizei n, const GLenum *buffers);
   /** Enable or disable server-side gl capabilities */
   void (*Enable)(struct gl_context *ctx, GLenum cap, GLboolean state);
   /** Specify fog parameters */
   void (*Fogfv)(struct gl_context *ctx, GLenum pname, const GLfloat *params);
   /** Specify implementation-specific hints */
   void (*Hint)(struct gl_context *ctx, GLenum target, GLenum mode);
   /** Set light source parameters.
    * Note: for GL_POSITION and GL_SPOT_DIRECTION, params will have already
    * been transformed to eye-space.
    */
   void (*Lightfv)(struct gl_context *ctx, GLenum light,
		   GLenum pname, const GLfloat *params );
   /** Set the lighting model parameters */
   void (*LightModelfv)(struct gl_context *ctx, GLenum pname,
                        const GLfloat *params);
   /** Specify the line stipple pattern */
   void (*LineStipple)(struct gl_context *ctx, GLint factor, GLushort pattern );
   /** Specify the width of rasterized lines */
   void (*LineWidth)(struct gl_context *ctx, GLfloat width);
   /** Specify a logical pixel operation for color index rendering */
   void (*LogicOpcode)(struct gl_context *ctx, GLenum opcode);
   void (*PointParameterfv)(struct gl_context *ctx, GLenum pname,
                            const GLfloat *params);
   /** Specify the diameter of rasterized points */
   void (*PointSize)(struct gl_context *ctx, GLfloat size);
   /** Select a polygon rasterization mode */
   void (*PolygonMode)(struct gl_context *ctx, GLenum face, GLenum mode);
   /** Set the scale and units used to calculate depth values */
   void (*PolygonOffset)(struct gl_context *ctx, GLfloat factor, GLfloat units);
   /** Set the polygon stippling pattern */
   void (*PolygonStipple)(struct gl_context *ctx, const GLubyte *mask );
   /* Specifies the current buffer for reading */
   void (*ReadBuffer)( struct gl_context *ctx, GLenum buffer );
   /** Set rasterization mode */
   void (*RenderMode)(struct gl_context *ctx, GLenum mode );
   /** Define the scissor box */
   void (*Scissor)(struct gl_context *ctx);
   /** Select flat or smooth shading */
   void (*ShadeModel)(struct gl_context *ctx, GLenum mode);
   /** OpenGL 2.0 two-sided StencilFunc */
   void (*StencilFuncSeparate)(struct gl_context *ctx, GLenum face, GLenum func,
                               GLint ref, GLuint mask);
   /** OpenGL 2.0 two-sided StencilMask */
   void (*StencilMaskSeparate)(struct gl_context *ctx, GLenum face, GLuint mask);
   /** OpenGL 2.0 two-sided StencilOp */
   void (*StencilOpSeparate)(struct gl_context *ctx, GLenum face, GLenum fail,
                             GLenum zfail, GLenum zpass);
   /** Control the generation of texture coordinates */
   void (*TexGen)(struct gl_context *ctx, GLenum coord, GLenum pname,
		  const GLfloat *params);
   /** Set texture environment parameters */
   void (*TexEnv)(struct gl_context *ctx, GLenum target, GLenum pname,
                  const GLfloat *param);
   /** Set texture parameters */
   void (*TexParameter)(struct gl_context *ctx,
                        struct gl_texture_object *texObj,
                        GLenum pname, const GLfloat *params);
   /** Set the viewport */
   void (*Viewport)(struct gl_context *ctx);
   /*@@}*/


   /**
    * \name Vertex/pixel buffer object functions
    */
   /*@@{*/
   struct gl_buffer_object * (*NewBufferObject)(struct gl_context *ctx,
                                                GLuint buffer, GLenum target);
   
   void (*DeleteBuffer)( struct gl_context *ctx, struct gl_buffer_object *obj );

   GLboolean (*BufferData)(struct gl_context *ctx, GLenum target,
                           GLsizeiptrARB size, const GLvoid *data, GLenum usage,
                           GLenum storageFlags, struct gl_buffer_object *obj);

   void (*BufferSubData)( struct gl_context *ctx, GLintptrARB offset,
			  GLsizeiptrARB size, const GLvoid *data,
			  struct gl_buffer_object *obj );

   void (*GetBufferSubData)( struct gl_context *ctx,
			     GLintptrARB offset, GLsizeiptrARB size,
			     GLvoid *data, struct gl_buffer_object *obj );

   void (*ClearBufferSubData)( struct gl_context *ctx,
                               GLintptr offset, GLsizeiptr size,
                               const GLvoid *clearValue,
                               GLsizeiptr clearValueSize,
                               struct gl_buffer_object *obj );

   void (*CopyBufferSubData)( struct gl_context *ctx,
                              struct gl_buffer_object *src,
                              struct gl_buffer_object *dst,
                              GLintptr readOffset, GLintptr writeOffset,
                              GLsizeiptr size );

   /* Returns pointer to the start of the mapped range.
    * May return NULL if MESA_MAP_NOWAIT_BIT is set in access:
    */
   void * (*MapBufferRange)( struct gl_context *ctx, GLintptr offset,
                             GLsizeiptr length, GLbitfield access,
                             struct gl_buffer_object *obj,
                             gl_map_buffer_index index);

   void (*FlushMappedBufferRange)(struct gl_context *ctx,
                                  GLintptr offset, GLsizeiptr length,
                                  struct gl_buffer_object *obj,
                                  gl_map_buffer_index index);

   GLboolean (*UnmapBuffer)( struct gl_context *ctx,
			     struct gl_buffer_object *obj,
                             gl_map_buffer_index index);
   /*@@}*/

   /**
    * \name Functions for GL_APPLE_object_purgeable
    */
   /*@@{*/
   /* variations on ObjectPurgeable */
   GLenum (*BufferObjectPurgeable)(struct gl_context *ctx,
                                   struct gl_buffer_object *obj, GLenum option);
   GLenum (*RenderObjectPurgeable)(struct gl_context *ctx,
                                   struct gl_renderbuffer *obj, GLenum option);
   GLenum (*TextureObjectPurgeable)(struct gl_context *ctx,
                                    struct gl_texture_object *obj,
                                    GLenum option);

   /* variations on ObjectUnpurgeable */
   GLenum (*BufferObjectUnpurgeable)(struct gl_context *ctx,
                                     struct gl_buffer_object *obj,
                                     GLenum option);
   GLenum (*RenderObjectUnpurgeable)(struct gl_context *ctx,
                                     struct gl_renderbuffer *obj,
                                     GLenum option);
   GLenum (*TextureObjectUnpurgeable)(struct gl_context *ctx,
                                      struct gl_texture_object *obj,
                                      GLenum option);
   /*@@}*/

   /**
    * \name Functions for GL_EXT_framebuffer_{object,blit,discard}.
    */
   /*@@{*/
   struct gl_framebuffer * (*NewFramebuffer)(struct gl_context *ctx,
                                             GLuint name);
   struct gl_renderbuffer * (*NewRenderbuffer)(struct gl_context *ctx,
                                               GLuint name);
   void (*BindFramebuffer)(struct gl_context *ctx, GLenum target,
                           struct gl_framebuffer *drawFb,
                           struct gl_framebuffer *readFb);
   void (*FramebufferRenderbuffer)(struct gl_context *ctx, 
                                   struct gl_framebuffer *fb,
                                   GLenum attachment,
                                   struct gl_renderbuffer *rb);
   void (*RenderTexture)(struct gl_context *ctx,
                         struct gl_framebuffer *fb,
                         struct gl_renderbuffer_attachment *att);
   void (*FinishRenderTexture)(struct gl_context *ctx,
                               struct gl_renderbuffer *rb);
   void (*ValidateFramebuffer)(struct gl_context *ctx,
                               struct gl_framebuffer *fb);
   /*@@}*/
   void (*BlitFramebuffer)(struct gl_context *ctx,
                           GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1,
                           GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1,
                           GLbitfield mask, GLenum filter);
   void (*DiscardFramebuffer)(struct gl_context *ctx,
                              GLenum target, GLsizei numAttachments,
                              const GLenum *attachments);

   /**
    * \name Query objects
    */
   /*@@{*/
   struct gl_query_object * (*NewQueryObject)(struct gl_context *ctx, GLuint id);
   void (*DeleteQuery)(struct gl_context *ctx, struct gl_query_object *q);
   void (*BeginQuery)(struct gl_context *ctx, struct gl_query_object *q);
   void (*QueryCounter)(struct gl_context *ctx, struct gl_query_object *q);
   void (*EndQuery)(struct gl_context *ctx, struct gl_query_object *q);
   void (*CheckQuery)(struct gl_context *ctx, struct gl_query_object *q);
   void (*WaitQuery)(struct gl_context *ctx, struct gl_query_object *q);
   /*@@}*/

   /**
    * \name Performance monitors
    */
   /*@@{*/
   struct gl_perf_monitor_object * (*NewPerfMonitor)(struct gl_context *ctx);
   void (*DeletePerfMonitor)(struct gl_context *ctx,
                             struct gl_perf_monitor_object *m);
   GLboolean (*BeginPerfMonitor)(struct gl_context *ctx,
                                 struct gl_perf_monitor_object *m);

   /** Stop an active performance monitor, discarding results. */
   void (*ResetPerfMonitor)(struct gl_context *ctx,
                            struct gl_perf_monitor_object *m);
   void (*EndPerfMonitor)(struct gl_context *ctx,
                          struct gl_perf_monitor_object *m);
   GLboolean (*IsPerfMonitorResultAvailable)(struct gl_context *ctx,
                                             struct gl_perf_monitor_object *m);
   void (*GetPerfMonitorResult)(struct gl_context *ctx,
                                struct gl_perf_monitor_object *m,
                                GLsizei dataSize,
                                GLuint *data,
                                GLint *bytesWritten);
   /*@@}*/


   /**
    * \name Vertex Array objects
    */
   /*@@{*/
   struct gl_vertex_array_object * (*NewArrayObject)(struct gl_context *ctx, GLuint id);
   void (*DeleteArrayObject)(struct gl_context *ctx, struct gl_vertex_array_object *);
   void (*BindArrayObject)(struct gl_context *ctx, struct gl_vertex_array_object *);
   /*@@}*/

   /**
    * \name GLSL-related functions (ARB extensions and OpenGL 2.x)
    */
   /*@@{*/
   struct gl_shader *(*NewShader)(struct gl_context *ctx,
                                  GLuint name, GLenum type);
   void (*DeleteShader)(struct gl_context *ctx, struct gl_shader *shader);
   struct gl_shader_program *(*NewShaderProgram)(struct gl_context *ctx,
                                                 GLuint name);
   void (*DeleteShaderProgram)(struct gl_context *ctx,
                               struct gl_shader_program *shProg);
   void (*UseProgram)(struct gl_context *ctx, struct gl_shader_program *shProg);
   /*@@}*/


   /**
    * \name Support for multiple T&L engines
    */
   /*@@{*/

   /**
    * Set by the driver-supplied T&L engine.  
    *
    * Set to PRIM_OUTSIDE_BEGIN_END when outside glBegin()/glEnd().
    */
   GLuint CurrentExecPrimitive;

   /**
    * Current glBegin state of an in-progress compilation.  May be
    * GL_POINTS, GL_TRIANGLE_STRIP, etc. or PRIM_OUTSIDE_BEGIN_END
    * or PRIM_UNKNOWN.
    */
   GLuint CurrentSavePrimitive;


#define FLUSH_STORED_VERTICES 0x1
#define FLUSH_UPDATE_CURRENT  0x2
   /**
    * Set by the driver-supplied T&L engine whenever vertices are buffered
    * between glBegin()/glEnd() objects or __struct gl_contextRec::Current
    * is not updated.  A bitmask of the FLUSH_x values above.
    *
    * The dd_function_table::FlushVertices call below may be used to resolve
    * these conditions.
    */
   GLbitfield NeedFlush;

   /** Need to call SaveFlushVertices() upon state change? */
   GLboolean SaveNeedFlush;

   /* Called prior to any of the GLvertexformat functions being
    * called.  Paired with Driver.FlushVertices().
    */
   void (*BeginVertices)( struct gl_context *ctx );

   /**
    * If inside glBegin()/glEnd(), it should ASSERT(0).  Otherwise, if
    * FLUSH_STORED_VERTICES bit in \p flags is set flushes any buffered
    * vertices, if FLUSH_UPDATE_CURRENT bit is set updates
    * __struct gl_contextRec::Current and gl_light_attrib::Material
    *
    * Note that the default T&L engine never clears the
    * FLUSH_UPDATE_CURRENT bit, even after performing the update.
    */
   void (*FlushVertices)( struct gl_context *ctx, GLuint flags );
   void (*SaveFlushVertices)( struct gl_context *ctx );

   /**
    * Give the driver the opportunity to hook in its own vtxfmt for
    * compiling optimized display lists.  This is called on each valid
    * glBegin() during list compilation.
    */
   GLboolean (*NotifySaveBegin)( struct gl_context *ctx, GLenum mode );

   /**
    * Notify driver that the special derived value _NeedEyeCoords has
    * changed.
    */
   void (*LightingSpaceChange)( struct gl_context *ctx );

   /**
    * Called by glNewList().
    *
    * Let the T&L component know what is going on with display lists
    * in time to make changes to dispatch tables, etc.
    */
   void (*NewList)( struct gl_context *ctx, GLuint list, GLenum mode );
   /**
    * Called by glEndList().
    *
    * \sa dd_function_table::NewList.
    */
   void (*EndList)( struct gl_context *ctx );

   /**
    * Called by glCallList(s).
    *
    * Notify the T&L component before and after calling a display list.
    */
   void (*BeginCallList)( struct gl_context *ctx, 
			  struct gl_display_list *dlist );
   /**
    * Called by glEndCallList().
    *
    * \sa dd_function_table::BeginCallList.
    */
   void (*EndCallList)( struct gl_context *ctx );

   /**@@}*/

   /**
    * \name GL_ARB_sync interfaces
    */
   /*@@{*/
   struct gl_sync_object * (*NewSyncObject)(struct gl_context *, GLenum);
   void (*FenceSync)(struct gl_context *, struct gl_sync_object *,
                     GLenum, GLbitfield);
   void (*DeleteSyncObject)(struct gl_context *, struct gl_sync_object *);
   void (*CheckSync)(struct gl_context *, struct gl_sync_object *);
   void (*ClientWaitSync)(struct gl_context *, struct gl_sync_object *,
			  GLbitfield, GLuint64);
   void (*ServerWaitSync)(struct gl_context *, struct gl_sync_object *,
			  GLbitfield, GLuint64);
   /*@@}*/

   /** GL_NV_conditional_render */
   void (*BeginConditionalRender)(struct gl_context *ctx,
                                  struct gl_query_object *q,
                                  GLenum mode);
   void (*EndConditionalRender)(struct gl_context *ctx,
                                struct gl_query_object *q);

   /**
    * \name GL_OES_draw_texture interface
    */
   /*@@{*/
   void (*DrawTex)(struct gl_context *ctx, GLfloat x, GLfloat y, GLfloat z,
                   GLfloat width, GLfloat height);
   /*@@}*/

   /**
    * \name GL_OES_EGL_image interface
    */
   void (*EGLImageTargetTexture2D)(struct gl_context *ctx, GLenum target,
				   struct gl_texture_object *texObj,
				   struct gl_texture_image *texImage,
				   GLeglImageOES image_handle);
   void (*EGLImageTargetRenderbufferStorage)(struct gl_context *ctx,
					     struct gl_renderbuffer *rb,
					     void *image_handle);

   /**
    * \name GL_EXT_transform_feedback interface
    */
   struct gl_transform_feedback_object *
        (*NewTransformFeedback)(struct gl_context *ctx, GLuint name);
   void (*DeleteTransformFeedback)(struct gl_context *ctx,
                                   struct gl_transform_feedback_object *obj);
   void (*BeginTransformFeedback)(struct gl_context *ctx, GLenum mode,
                                  struct gl_transform_feedback_object *obj);
   void (*EndTransformFeedback)(struct gl_context *ctx,
                                struct gl_transform_feedback_object *obj);
   void (*PauseTransformFeedback)(struct gl_context *ctx,
                                  struct gl_transform_feedback_object *obj);
   void (*ResumeTransformFeedback)(struct gl_context *ctx,
                                   struct gl_transform_feedback_object *obj);

   /**
    * Return the number of vertices written to a stream during the last
    * Begin/EndTransformFeedback block.
    */
   GLsizei (*GetTransformFeedbackVertexCount)(struct gl_context *ctx,
                                       struct gl_transform_feedback_object *obj,
                                       GLuint stream);

   /**
    * \name GL_NV_texture_barrier interface
    */
   void (*TextureBarrier)(struct gl_context *ctx);

   /**
    * \name GL_ARB_sampler_objects
    */
   struct gl_sampler_object * (*NewSamplerObject)(struct gl_context *ctx,
                                                  GLuint name);
   void (*DeleteSamplerObject)(struct gl_context *ctx,
                               struct gl_sampler_object *samp);

   /**
    * \name Return a timestamp in nanoseconds as defined by GL_ARB_timer_query.
    * This should be equivalent to glGetInteger64v(GL_TIMESTAMP);
    */
   uint64_t (*GetTimestamp)(struct gl_context *ctx);

   /**
    * \name GL_ARB_texture_multisample
    */
   void (*GetSamplePosition)(struct gl_context *ctx,
                             struct gl_framebuffer *fb,
                             GLuint index,
                             GLfloat *outValue);

   /**
    * \name NV_vdpau_interop interface
    */
   void (*VDPAUMapSurface)(struct gl_context *ctx, GLenum target,
                           GLenum access, GLboolean output,
                           struct gl_texture_object *texObj,
                           struct gl_texture_image *texImage,
                           const GLvoid *vdpSurface, GLuint index);
   void (*VDPAUUnmapSurface)(struct gl_context *ctx, GLenum target,
                             GLenum access, GLboolean output,
                             struct gl_texture_object *texObj,
                             struct gl_texture_image *texImage,
                             const GLvoid *vdpSurface, GLuint index);

   /**
    * Query reset status for GL_ARB_robustness
    *
    * Per \c glGetGraphicsResetStatusARB, this function should return a
    * non-zero value once after a reset.  If a reset is non-atomic, the
    * non-zero status should be returned for the duration of the reset.
    */
   GLenum (*GetGraphicsResetStatus)(struct gl_context *ctx);

   /**
    * \name GL_ARB_shader_image_load_store interface.
    */
   /** @@{ */
   void (*BindImageTexture)(struct gl_context *ctx,
                            struct gl_image_unit *unit,
                            struct gl_texture_object *texObj,
                            GLint level, GLboolean layered, GLint layer,
                            GLenum access, GLenum format);

   void (*MemoryBarrier)(struct gl_context *ctx, GLbitfield barriers);
   /** @@} */
};


/**
 * Per-vertex functions.
 *
 * These are the functions which can appear between glBegin and glEnd.
 * Depending on whether we're inside or outside a glBegin/End pair
 * and whether we're in immediate mode or building a display list, these
 * functions behave differently.  This structure allows us to switch
 * between those modes more easily.
 *
 * Generally, these pointers point to functions in the VBO module.
 */
typedef struct {
   void (GLAPIENTRYP ArrayElement)( GLint );
   void (GLAPIENTRYP Color3f)( GLfloat, GLfloat, GLfloat );
   void (GLAPIENTRYP Color3fv)( const GLfloat * );
   void (GLAPIENTRYP Color4f)( GLfloat, GLfloat, GLfloat, GLfloat );
   void (GLAPIENTRYP Color4fv)( const GLfloat * );
   void (GLAPIENTRYP EdgeFlag)( GLboolean );
   void (GLAPIENTRYP EvalCoord1f)( GLfloat );
   void (GLAPIENTRYP EvalCoord1fv)( const GLfloat * );
   void (GLAPIENTRYP EvalCoord2f)( GLfloat, GLfloat );
   void (GLAPIENTRYP EvalCoord2fv)( const GLfloat * );
   void (GLAPIENTRYP EvalPoint1)( GLint );
   void (GLAPIENTRYP EvalPoint2)( GLint, GLint );
   void (GLAPIENTRYP FogCoordfEXT)( GLfloat );
   void (GLAPIENTRYP FogCoordfvEXT)( const GLfloat * );
   void (GLAPIENTRYP Indexf)( GLfloat );
   void (GLAPIENTRYP Indexfv)( const GLfloat * );
   void (GLAPIENTRYP Materialfv)( GLenum face, GLenum pname, const GLfloat * );
   void (GLAPIENTRYP MultiTexCoord1fARB)( GLenum, GLfloat );
   void (GLAPIENTRYP MultiTexCoord1fvARB)( GLenum, const GLfloat * );
   void (GLAPIENTRYP MultiTexCoord2fARB)( GLenum, GLfloat, GLfloat );
   void (GLAPIENTRYP MultiTexCoord2fvARB)( GLenum, const GLfloat * );
   void (GLAPIENTRYP MultiTexCoord3fARB)( GLenum, GLfloat, GLfloat, GLfloat );
   void (GLAPIENTRYP MultiTexCoord3fvARB)( GLenum, const GLfloat * );
   void (GLAPIENTRYP MultiTexCoord4fARB)( GLenum, GLfloat, GLfloat, GLfloat, GLfloat );
   void (GLAPIENTRYP MultiTexCoord4fvARB)( GLenum, const GLfloat * );
   void (GLAPIENTRYP Normal3f)( GLfloat, GLfloat, GLfloat );
   void (GLAPIENTRYP Normal3fv)( const GLfloat * );
   void (GLAPIENTRYP SecondaryColor3fEXT)( GLfloat, GLfloat, GLfloat );
   void (GLAPIENTRYP SecondaryColor3fvEXT)( const GLfloat * );
   void (GLAPIENTRYP TexCoord1f)( GLfloat );
   void (GLAPIENTRYP TexCoord1fv)( const GLfloat * );
   void (GLAPIENTRYP TexCoord2f)( GLfloat, GLfloat );
   void (GLAPIENTRYP TexCoord2fv)( const GLfloat * );
   void (GLAPIENTRYP TexCoord3f)( GLfloat, GLfloat, GLfloat );
   void (GLAPIENTRYP TexCoord3fv)( const GLfloat * );
   void (GLAPIENTRYP TexCoord4f)( GLfloat, GLfloat, GLfloat, GLfloat );
   void (GLAPIENTRYP TexCoord4fv)( const GLfloat * );
   void (GLAPIENTRYP Vertex2f)( GLfloat, GLfloat );
   void (GLAPIENTRYP Vertex2fv)( const GLfloat * );
   void (GLAPIENTRYP Vertex3f)( GLfloat, GLfloat, GLfloat );
   void (GLAPIENTRYP Vertex3fv)( const GLfloat * );
   void (GLAPIENTRYP Vertex4f)( GLfloat, GLfloat, GLfloat, GLfloat );
   void (GLAPIENTRYP Vertex4fv)( const GLfloat * );
   void (GLAPIENTRYP CallList)( GLuint );
   void (GLAPIENTRYP CallLists)( GLsizei, GLenum, const GLvoid * );
   void (GLAPIENTRYP Begin)( GLenum );
   void (GLAPIENTRYP End)( void );
   void (GLAPIENTRYP PrimitiveRestartNV)( void );
   /* Originally for GL_NV_vertex_program, now used only dlist.c and friends */
   void (GLAPIENTRYP VertexAttrib1fNV)( GLuint index, GLfloat x );
   void (GLAPIENTRYP VertexAttrib1fvNV)( GLuint index, const GLfloat *v );
   void (GLAPIENTRYP VertexAttrib2fNV)( GLuint index, GLfloat x, GLfloat y );
   void (GLAPIENTRYP VertexAttrib2fvNV)( GLuint index, const GLfloat *v );
   void (GLAPIENTRYP VertexAttrib3fNV)( GLuint index, GLfloat x, GLfloat y, GLfloat z );
   void (GLAPIENTRYP VertexAttrib3fvNV)( GLuint index, const GLfloat *v );
   void (GLAPIENTRYP VertexAttrib4fNV)( GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w );
   void (GLAPIENTRYP VertexAttrib4fvNV)( GLuint index, const GLfloat *v );
   /* GL_ARB_vertex_program */
   void (GLAPIENTRYP VertexAttrib1fARB)( GLuint index, GLfloat x );
   void (GLAPIENTRYP VertexAttrib1fvARB)( GLuint index, const GLfloat *v );
   void (GLAPIENTRYP VertexAttrib2fARB)( GLuint index, GLfloat x, GLfloat y );
   void (GLAPIENTRYP VertexAttrib2fvARB)( GLuint index, const GLfloat *v );
   void (GLAPIENTRYP VertexAttrib3fARB)( GLuint index, GLfloat x, GLfloat y, GLfloat z );
   void (GLAPIENTRYP VertexAttrib3fvARB)( GLuint index, const GLfloat *v );
   void (GLAPIENTRYP VertexAttrib4fARB)( GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w );
   void (GLAPIENTRYP VertexAttrib4fvARB)( GLuint index, const GLfloat *v );

   /* GL_EXT_gpu_shader4 / GL 3.0 */
   void (GLAPIENTRYP VertexAttribI1i)( GLuint index, GLint x);
   void (GLAPIENTRYP VertexAttribI2i)( GLuint index, GLint x, GLint y);
   void (GLAPIENTRYP VertexAttribI3i)( GLuint index, GLint x, GLint y, GLint z);
   void (GLAPIENTRYP VertexAttribI4i)( GLuint index, GLint x, GLint y, GLint z, GLint w);
   void (GLAPIENTRYP VertexAttribI2iv)( GLuint index, const GLint *v);
   void (GLAPIENTRYP VertexAttribI3iv)( GLuint index, const GLint *v);
   void (GLAPIENTRYP VertexAttribI4iv)( GLuint index, const GLint *v);

   void (GLAPIENTRYP VertexAttribI1ui)( GLuint index, GLuint x);
   void (GLAPIENTRYP VertexAttribI2ui)( GLuint index, GLuint x, GLuint y);
   void (GLAPIENTRYP VertexAttribI3ui)( GLuint index, GLuint x, GLuint y, GLuint z);
   void (GLAPIENTRYP VertexAttribI4ui)( GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
   void (GLAPIENTRYP VertexAttribI2uiv)( GLuint index, const GLuint *v);
   void (GLAPIENTRYP VertexAttribI3uiv)( GLuint index, const GLuint *v);
   void (GLAPIENTRYP VertexAttribI4uiv)( GLuint index, const GLuint *v);

   /* GL_ARB_vertex_type_10_10_10_2_rev / GL3.3 */
   void (GLAPIENTRYP VertexP2ui)( GLenum type, GLuint value );
   void (GLAPIENTRYP VertexP2uiv)( GLenum type, const GLuint *value);

   void (GLAPIENTRYP VertexP3ui)( GLenum type, GLuint value );
   void (GLAPIENTRYP VertexP3uiv)( GLenum type, const GLuint *value);

   void (GLAPIENTRYP VertexP4ui)( GLenum type, GLuint value );
   void (GLAPIENTRYP VertexP4uiv)( GLenum type, const GLuint *value);

   void (GLAPIENTRYP TexCoordP1ui)( GLenum type, GLuint coords );
   void (GLAPIENTRYP TexCoordP1uiv)( GLenum type, const GLuint *coords );

   void (GLAPIENTRYP TexCoordP2ui)( GLenum type, GLuint coords );
   void (GLAPIENTRYP TexCoordP2uiv)( GLenum type, const GLuint *coords );

   void (GLAPIENTRYP TexCoordP3ui)( GLenum type, GLuint coords );
   void (GLAPIENTRYP TexCoordP3uiv)( GLenum type, const GLuint *coords );

   void (GLAPIENTRYP TexCoordP4ui)( GLenum type, GLuint coords );
   void (GLAPIENTRYP TexCoordP4uiv)( GLenum type, const GLuint *coords );

   void (GLAPIENTRYP MultiTexCoordP1ui)( GLenum texture, GLenum type, GLuint coords );
   void (GLAPIENTRYP MultiTexCoordP1uiv)( GLenum texture, GLenum type, const GLuint *coords );
   void (GLAPIENTRYP MultiTexCoordP2ui)( GLenum texture, GLenum type, GLuint coords );
   void (GLAPIENTRYP MultiTexCoordP2uiv)( GLenum texture, GLenum type, const GLuint *coords );
   void (GLAPIENTRYP MultiTexCoordP3ui)( GLenum texture, GLenum type, GLuint coords );
   void (GLAPIENTRYP MultiTexCoordP3uiv)( GLenum texture, GLenum type, const GLuint *coords );
   void (GLAPIENTRYP MultiTexCoordP4ui)( GLenum texture, GLenum type, GLuint coords );
   void (GLAPIENTRYP MultiTexCoordP4uiv)( GLenum texture, GLenum type, const GLuint *coords );

   void (GLAPIENTRYP NormalP3ui)( GLenum type, GLuint coords );
   void (GLAPIENTRYP NormalP3uiv)( GLenum type, const GLuint *coords );

   void (GLAPIENTRYP ColorP3ui)( GLenum type, GLuint color );
   void (GLAPIENTRYP ColorP3uiv)( GLenum type, const GLuint *color );

   void (GLAPIENTRYP ColorP4ui)( GLenum type, GLuint color );
   void (GLAPIENTRYP ColorP4uiv)( GLenum type, const GLuint *color );

   void (GLAPIENTRYP SecondaryColorP3ui)( GLenum type, GLuint color );
   void (GLAPIENTRYP SecondaryColorP3uiv)( GLenum type, const GLuint *color );

   void (GLAPIENTRYP VertexAttribP1ui)( GLuint index, GLenum type,
					GLboolean normalized, GLuint value);
   void (GLAPIENTRYP VertexAttribP2ui)( GLuint index, GLenum type,
					GLboolean normalized, GLuint value);
   void (GLAPIENTRYP VertexAttribP3ui)( GLuint index, GLenum type,
					GLboolean normalized, GLuint value);
   void (GLAPIENTRYP VertexAttribP4ui)( GLuint index, GLenum type,
					GLboolean normalized, GLuint value);
   void (GLAPIENTRYP VertexAttribP1uiv)( GLuint index, GLenum type,
					GLboolean normalized,
					 const GLuint *value);
   void (GLAPIENTRYP VertexAttribP2uiv)( GLuint index, GLenum type,
					GLboolean normalized,
					 const GLuint *value);
   void (GLAPIENTRYP VertexAttribP3uiv)( GLuint index, GLenum type,
					GLboolean normalized,
					 const GLuint *value);
   void (GLAPIENTRYP VertexAttribP4uiv)( GLuint index, GLenum type,
					 GLboolean normalized,
					 const GLuint *value);
} GLvertexformat;


#endif /* DD_INCLUDED */
@


1.11
log
@Merge Mesa 10.2.9
@
text
@@


1.10
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a241 14
    * Called by glClearTex[Sub]Image
    *
    * Clears a rectangular region of the image to a given value. The
    * clearValue argument is either NULL or points to a single texel to use as
    * the clear value in the same internal format as the texture image. If it
    * is NULL then the texture should be cleared to zeroes.
    */
   void (*ClearTexSubImage)(struct gl_context *ctx,
                            struct gl_texture_image *texImage,
                            GLint xoffset, GLint yoffset, GLint zoffset,
                            GLsizei width, GLsizei height, GLsizei depth,
                            const GLvoid *clearValue);

   /**
a257 16
    * Called by glCopyImageSubData().
    *
    * This function should copy one 2-D slice from srcTexImage to
    * dstTexImage.  If one of the textures is 3-D or is a 1-D or 2-D array
    * texture, this function will be called multiple times: once for each
    * slice.  If one of the textures is a cube map, this function will be
    * called once for each face to be copied.
    */
   void (*CopyImageSubData)(struct gl_context *ctx,
                            struct gl_texture_image *src_image,
                            int src_x, int src_y, int src_z,
                            struct gl_texture_image *dstTexImage,
                            int dst_x, int dst_y, int dst_z,
                            int src_width, int src_height);

   /**
d575 1
a575 1
                                                GLuint buffer);
d731 2
a732 1
   struct gl_shader_program *(*NewShaderProgram)(GLuint name);
@


1.9
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d242 14
d272 16
d605 1
a605 1
                                                GLuint buffer, GLenum target);
d761 1
a761 2
   struct gl_shader_program *(*NewShaderProgram)(struct gl_context *ctx,
                                                 GLuint name);
@


1.8
log
@Merge Mesa 9.2.0
@
text
@d42 1
d185 3
a187 3
   gl_format (*ChooseTextureFormat)( struct gl_context *ctx,
                                     GLenum target, GLint internalFormat,
                                     GLenum srcFormat, GLenum srcType );
d259 4
d275 1
a275 1
                                  GLint level, gl_format format,
d317 1
a317 1
    * Called by glBindTexture().
d319 2
a320 2
   void (*BindTexture)( struct gl_context *ctx, GLenum target,
                        struct gl_texture_object *tObj );
d383 5
d402 7
d417 2
a418 1
   void (*BindProgram)(struct gl_context *ctx, GLenum target, struct gl_program *prog);
d420 2
a421 1
   struct gl_program * (*NewProgram)(struct gl_context *ctx, GLenum target, GLuint id);
d455 2
a456 1
   GLboolean (*LinkShader)(struct gl_context *ctx, struct gl_shader_program *shader);
d474 2
a475 1
   void (*BlendEquationSeparate)(struct gl_context *ctx, GLenum modeRGB, GLenum modeA);
d486 1
a486 1
   void (*ClipPlane)(struct gl_context *ctx, GLenum plane, const GLfloat *equation );
d503 1
a503 1
   void (*DepthRange)(struct gl_context *ctx, GLclampd nearval, GLclampd farval);
d507 1
a507 1
   void (*DrawBuffers)( struct gl_context *ctx, GLsizei n, const GLenum *buffers );
d521 2
a522 1
   void (*LightModelfv)(struct gl_context *ctx, GLenum pname, const GLfloat *params);
d544 1
a544 1
   void (*Scissor)(struct gl_context *ctx, GLint x, GLint y, GLsizei w, GLsizei h);
d562 1
a562 1
   void (*TexParameter)(struct gl_context *ctx, GLenum target,
d566 1
a566 1
   void (*Viewport)(struct gl_context *ctx, GLint x, GLint y, GLsizei w, GLsizei h);
d574 2
a575 5
   void (*BindBuffer)( struct gl_context *ctx, GLenum target,
		       struct gl_buffer_object *obj );

   struct gl_buffer_object * (*NewBufferObject)( struct gl_context *ctx, GLuint buffer,
						 GLenum target );
d579 3
a581 3
   GLboolean (*BufferData)( struct gl_context *ctx, GLenum target, GLsizeiptrARB size,
                            const GLvoid *data, GLenum usage,
                            struct gl_buffer_object *obj );
d591 6
d603 2
a604 1
   /* May return NULL if MESA_MAP_NOWAIT_BIT is set in access:
d608 2
a609 1
                             struct gl_buffer_object *obj);
d613 2
a614 1
                                  struct gl_buffer_object *obj);
d617 2
a618 1
			     struct gl_buffer_object *obj );
d626 7
a632 3
   GLenum (*BufferObjectPurgeable)( struct gl_context *ctx, struct gl_buffer_object *obj, GLenum option );
   GLenum (*RenderObjectPurgeable)( struct gl_context *ctx, struct gl_renderbuffer *obj, GLenum option );
   GLenum (*TextureObjectPurgeable)( struct gl_context *ctx, struct gl_texture_object *obj, GLenum option );
d635 9
a643 3
   GLenum (*BufferObjectUnpurgeable)( struct gl_context *ctx, struct gl_buffer_object *obj, GLenum option );
   GLenum (*RenderObjectUnpurgeable)( struct gl_context *ctx, struct gl_renderbuffer *obj, GLenum option );
   GLenum (*TextureObjectUnpurgeable)( struct gl_context *ctx, struct gl_texture_object *obj, GLenum option );
d650 4
a653 2
   struct gl_framebuffer * (*NewFramebuffer)(struct gl_context *ctx, GLuint name);
   struct gl_renderbuffer * (*NewRenderbuffer)(struct gl_context *ctx, GLuint name);
d674 2
a675 1
                              GLenum target, GLsizei numAttachments, const GLenum *attachments);
d690 24
d719 3
a721 3
   struct gl_array_object * (*NewArrayObject)(struct gl_context *ctx, GLuint id);
   void (*DeleteArrayObject)(struct gl_context *ctx, struct gl_array_object *obj);
   void (*BindArrayObject)(struct gl_context *ctx, struct gl_array_object *obj);
d728 2
a729 1
   struct gl_shader *(*NewShader)(struct gl_context *ctx, GLuint name, GLenum type);
d731 2
a732 1
   struct gl_shader_program *(*NewShaderProgram)(struct gl_context *ctx, GLuint name);
d839 2
a840 1
   void (*FenceSync)(struct gl_context *, struct gl_sync_object *, GLenum, GLbitfield);
d850 2
a851 1
   void (*BeginConditionalRender)(struct gl_context *ctx, struct gl_query_object *q,
d853 2
a854 1
   void (*EndConditionalRender)(struct gl_context *ctx, struct gl_query_object *q);
d892 8
d925 36
@


1.7
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a7 1
 * Version:  6.5.2
d24 4
a27 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
a95 9
    * Get the width and height of the named buffer/window.
    *
    * Mesa uses this to determine when the driver's window size has changed.
    * XXX OBSOLETE: this function will be removed in the future.
    */
   void (*GetBufferSize)( struct gl_framebuffer *buffer,
                          GLuint *width, GLuint *height );

   /**
a102 6
    * Called whenever an error is generated.  
    * __struct gl_contextRec::ErrorValue contains the error value.
    */
   void (*Error)( struct gl_context *ctx );

   /**
d177 6
a182 5
    * Choose texture format.
    * 
    * This is called by the \c _mesa_store_tex[sub]image[123]d() fallback
    * functions.  The driver should examine \p internalFormat and return a
    * gl_format value.
d184 2
a185 1
   GLuint (*ChooseTextureFormat)( struct gl_context *ctx, GLint internalFormat,
d189 1
a189 13
    * Called by glTexImage1D().
    * 
    * \param target user specified.
    * \param format user specified.
    * \param type user specified.
    * \param pixels user specified.
    * \param packing indicates the image packing of pixels.
    * \param texObj is the target texture object.
    * \param texImage is the target texture image.  It will have the texture \p
    * width, \p height, \p depth, \p border and \p internalFormat information.
    * 
    * \p retainInternalCopy is returned by this function and indicates whether
    * core Mesa should keep an internal copy of the texture image.
d191 40
a230 35
    * Drivers should call a fallback routine from texstore.c if needed.
    */
   void (*TexImage1D)( struct gl_context *ctx, GLenum target, GLint level,
                       GLint internalFormat,
                       GLint width, GLint border,
                       GLenum format, GLenum type, const GLvoid *pixels,
                       const struct gl_pixelstore_attrib *packing,
                       struct gl_texture_object *texObj,
                       struct gl_texture_image *texImage );

   /**
    * Called by glTexImage2D().
    * 
    * \sa dd_function_table::TexImage1D.
    */
   void (*TexImage2D)( struct gl_context *ctx, GLenum target, GLint level,
                       GLint internalFormat,
                       GLint width, GLint height, GLint border,
                       GLenum format, GLenum type, const GLvoid *pixels,
                       const struct gl_pixelstore_attrib *packing,
                       struct gl_texture_object *texObj,
                       struct gl_texture_image *texImage );
   
   /**
    * Called by glTexImage3D().
    * 
    * \sa dd_function_table::TexImage1D.
    */
   void (*TexImage3D)( struct gl_context *ctx, GLenum target, GLint level,
                       GLint internalFormat,
                       GLint width, GLint height, GLint depth, GLint border,
                       GLenum format, GLenum type, const GLvoid *pixels,
                       const struct gl_pixelstore_attrib *packing,
                       struct gl_texture_object *texObj,
                       struct gl_texture_image *texImage );
a231 56
   /**
    * Called by glTexSubImage1D().
    *
    * \param target user specified.
    * \param level user specified.
    * \param xoffset user specified.
    * \param yoffset user specified.
    * \param zoffset user specified.
    * \param width user specified.
    * \param height user specified.
    * \param depth user specified.
    * \param format user specified.
    * \param type user specified.
    * \param pixels user specified.
    * \param packing indicates the image packing of pixels.
    * \param texObj is the target texture object.
    * \param texImage is the target texture image.  It will have the texture \p
    * width, \p height, \p border and \p internalFormat information.
    *
    * The driver should use a fallback routine from texstore.c if needed.
    */
   void (*TexSubImage1D)( struct gl_context *ctx, GLenum target, GLint level,
                          GLint xoffset, GLsizei width,
                          GLenum format, GLenum type,
                          const GLvoid *pixels,
                          const struct gl_pixelstore_attrib *packing,
                          struct gl_texture_object *texObj,
                          struct gl_texture_image *texImage );
   
   /**
    * Called by glTexSubImage2D().
    *
    * \sa dd_function_table::TexSubImage1D.
    */
   void (*TexSubImage2D)( struct gl_context *ctx, GLenum target, GLint level,
                          GLint xoffset, GLint yoffset,
                          GLsizei width, GLsizei height,
                          GLenum format, GLenum type,
                          const GLvoid *pixels,
                          const struct gl_pixelstore_attrib *packing,
                          struct gl_texture_object *texObj,
                          struct gl_texture_image *texImage );
   
   /**
    * Called by glTexSubImage3D().
    *
    * \sa dd_function_table::TexSubImage1D.
    */
   void (*TexSubImage3D)( struct gl_context *ctx, GLenum target, GLint level,
                          GLint xoffset, GLint yoffset, GLint zoffset,
                          GLsizei width, GLsizei height, GLint depth,
                          GLenum format, GLenum type,
                          const GLvoid *pixels,
                          const struct gl_pixelstore_attrib *packing,
                          struct gl_texture_object *texObj,
                          struct gl_texture_image *texImage );
d236 1
a236 1
   void (*GetTexImage)( struct gl_context *ctx, GLenum target, GLint level,
a237 1
                        struct gl_texture_object *texObj,
d241 14
a254 43
    * Called by glCopyTexImage1D().
    * 
    * Drivers should use a fallback routine from texstore.c if needed.
    */
   void (*CopyTexImage1D)( struct gl_context *ctx, GLenum target, GLint level,
                           GLenum internalFormat, GLint x, GLint y,
                           GLsizei width, GLint border );

   /**
    * Called by glCopyTexImage2D().
    * 
    * Drivers should use a fallback routine from texstore.c if needed.
    */
   void (*CopyTexImage2D)( struct gl_context *ctx, GLenum target, GLint level,
                           GLenum internalFormat, GLint x, GLint y,
                           GLsizei width, GLsizei height, GLint border );

   /**
    * Called by glCopyTexSubImage1D().
    * 
    * Drivers should use a fallback routine from texstore.c if needed.
    */
   void (*CopyTexSubImage1D)( struct gl_context *ctx, GLenum target, GLint level,
                              GLint xoffset,
                              GLint x, GLint y, GLsizei width );
   /**
    * Called by glCopyTexSubImage2D().
    * 
    * Drivers should use a fallback routine from texstore.c if needed.
    */
   void (*CopyTexSubImage2D)( struct gl_context *ctx, GLenum target, GLint level,
                              GLint xoffset, GLint yoffset,
                              GLint x, GLint y,
                              GLsizei width, GLsizei height );
   /**
    * Called by glCopyTexSubImage3D().
    * 
    * Drivers should use a fallback routine from texstore.c if needed.
    */
   void (*CopyTexSubImage3D)( struct gl_context *ctx, GLenum target, GLint level,
                              GLint xoffset, GLint yoffset, GLint zoffset,
                              GLint x, GLint y,
                              GLsizei width, GLsizei height );
d263 5
a267 4
    * Called by glTexImage[123]D when user specifies a proxy texture
    * target.  
    *
    * \return GL_TRUE if the proxy test passes, or GL_FALSE if the test fails.
d270 1
a270 2
                                  GLint level, GLint internalFormat,
                                  GLenum format, GLenum type,
d282 1
a282 24
    * Called by glCompressedTexImage1D().
    *
    * \param target user specified.
    * \param format user specified.
    * \param type user specified.
    * \param pixels user specified.
    * \param packing indicates the image packing of pixels.
    * \param texObj is the target texture object.
    * \param texImage is the target texture image.  It will have the texture \p
    * width, \p height, \p depth, \p border and \p internalFormat information.
    *      
    * \a retainInternalCopy is returned by this function and indicates whether
    * core Mesa should keep an internal copy of the texture image.
    */
   void (*CompressedTexImage1D)( struct gl_context *ctx, GLenum target,
                                 GLint level, GLint internalFormat,
                                 GLsizei width, GLint border,
                                 GLsizei imageSize, const GLvoid *data,
                                 struct gl_texture_object *texObj,
                                 struct gl_texture_image *texImage );
   /**
    * Called by glCompressedTexImage2D().
    *
    * \sa dd_function_table::CompressedTexImage1D.
d284 4
a287 6
   void (*CompressedTexImage2D)( struct gl_context *ctx, GLenum target,
                                 GLint level, GLint internalFormat,
                                 GLsizei width, GLsizei height, GLint border,
                                 GLsizei imageSize, const GLvoid *data,
                                 struct gl_texture_object *texObj,
                                 struct gl_texture_image *texImage );
d289 1
a289 51
    * Called by glCompressedTexImage3D().
    *
    * \sa dd_function_table::CompressedTexImage3D.
    */
   void (*CompressedTexImage3D)( struct gl_context *ctx, GLenum target,
                                 GLint level, GLint internalFormat,
                                 GLsizei width, GLsizei height, GLsizei depth,
                                 GLint border,
                                 GLsizei imageSize, const GLvoid *data,
                                 struct gl_texture_object *texObj,
                                 struct gl_texture_image *texImage );

   /**
    * Called by glCompressedTexSubImage1D().
    * 
    * \param target user specified.
    * \param level user specified.
    * \param xoffset user specified.
    * \param yoffset user specified.
    * \param zoffset user specified.
    * \param width user specified.
    * \param height user specified.
    * \param depth user specified.
    * \param imageSize user specified.
    * \param data user specified.
    * \param texObj is the target texture object.
    * \param texImage is the target texture image.  It will have the texture \p
    * width, \p height, \p depth, \p border and \p internalFormat information.
    */
   void (*CompressedTexSubImage1D)(struct gl_context *ctx, GLenum target, GLint level,
                                   GLint xoffset, GLsizei width,
                                   GLenum format,
                                   GLsizei imageSize, const GLvoid *data,
                                   struct gl_texture_object *texObj,
                                   struct gl_texture_image *texImage);
   /**
    * Called by glCompressedTexSubImage2D().
    *
    * \sa dd_function_table::CompressedTexImage3D.
    */
   void (*CompressedTexSubImage2D)(struct gl_context *ctx, GLenum target, GLint level,
                                   GLint xoffset, GLint yoffset,
                                   GLsizei width, GLint height,
                                   GLenum format,
                                   GLsizei imageSize, const GLvoid *data,
                                   struct gl_texture_object *texObj,
                                   struct gl_texture_image *texImage);
   /**
    * Called by glCompressedTexSubImage3D().
    *
    * \sa dd_function_table::CompressedTexImage3D.
d291 6
a296 8
   void (*CompressedTexSubImage3D)(struct gl_context *ctx, GLenum target, GLint level,
                                   GLint xoffset, GLint yoffset, GLint zoffset,
                                   GLsizei width, GLint height, GLint depth,
                                   GLenum format,
                                   GLsizei imageSize, const GLvoid *data,
                                   struct gl_texture_object *texObj,
                                   struct gl_texture_image *texImage);

d301 3
a303 5
   void (*GetCompressedTexImage)(struct gl_context *ctx, GLenum target, GLint level,
                                 GLvoid *img,
                                 struct gl_texture_object *texObj,
                                 struct gl_texture_image *texImage);

d307 1
a307 1
    * \name Texture object functions
d318 2
a319 21
    * Called to allocate a new texture object.
    * A new gl_texture_object should be returned.  The driver should
    * attach to it any device-specific info it needs.
    */
   struct gl_texture_object * (*NewTextureObject)( struct gl_context *ctx, GLuint name,
                                                   GLenum target );
   /**
    * Called when a texture object is about to be deallocated.  
    *
    * Driver should delete the gl_texture_object object and anything
    * hanging off of it.
    */
   void (*DeleteTexture)( struct gl_context *ctx, struct gl_texture_object *tObj );

   /**
    * Called to allocate a new texture image object.
    */
   struct gl_texture_image * (*NewTextureImage)( struct gl_context *ctx );

   /** 
    * Called to free tImage->Data.
d321 2
a322 7
   void (*FreeTexImageData)( struct gl_context *ctx, struct gl_texture_image *tImage );

   /** Map texture image data into user space */
   void (*MapTexture)( struct gl_context *ctx, struct gl_texture_object *tObj );
   /** Unmap texture images from user space */
   void (*UnmapTexture)( struct gl_context *ctx, struct gl_texture_object *tObj );

d324 2
a325 9
    * Note: no context argument.  This function doesn't initially look
    * like it belongs here, except that the driver is the only entity
    * that knows for sure how the texture memory is allocated - via
    * the above callbacks.  There is then an argument that the driver
    * knows what memcpy paths might be fast.  Typically this is invoked with
    * 
    * to -- a pointer into texture memory allocated by NewTextureImage() above.
    * from -- a pointer into client memory or a mesa temporary.
    * sz -- nr bytes to copy.
d327 61
a387 1
   void* (*TextureMemCpy)( void *to, const void *from, size_t sz );
d389 2
a390 5
   /**
    * Called by glAreTextureResident().
    */
   GLboolean (*IsTextureResident)( struct gl_context *ctx,
                                   struct gl_texture_object *t );
a391 22
   /**
    * Called when the texture's color lookup table is changed.
    * 
    * If \p tObj is NULL then the shared texture palette
    * gl_texture_object::Palette is to be updated.
    */
   void (*UpdateTexturePalette)( struct gl_context *ctx,
                                 struct gl_texture_object *tObj );
   /*@@}*/

   
   /**
    * \name Imaging functionality
    */
   /*@@{*/
   void (*CopyColorTable)( struct gl_context *ctx,
			   GLenum target, GLenum internalformat,
			   GLint x, GLint y, GLsizei width );

   void (*CopyColorSubTable)( struct gl_context *ctx,
			      GLenum target, GLsizei start,
			      GLint x, GLint y, GLsizei width );
d413 7
a463 6
   /** Specify clear values for the color buffers */
   void (*ClearColor)(struct gl_context *ctx, const GLfloat color[4]);
   /** Specify the clear value for the depth buffer */
   void (*ClearDepth)(struct gl_context *ctx, GLclampd d);
   /** Specify the clear value for the stencil buffer */
   void (*ClearStencil)(struct gl_context *ctx, GLint s);
d564 1
a564 1
   void (*BufferSubData)( struct gl_context *ctx, GLenum target, GLintptrARB offset,
d568 1
a568 1
   void (*GetBufferSubData)( struct gl_context *ctx, GLenum target,
a571 3
   void * (*MapBuffer)( struct gl_context *ctx, GLenum target, GLenum access,
			struct gl_buffer_object *obj );

d580 1
a580 1
   void * (*MapBufferRange)( struct gl_context *ctx, GLenum target, GLintptr offset,
d584 1
a584 1
   void (*FlushMappedBufferRange)(struct gl_context *ctx, GLenum target, 
d588 1
a588 1
   GLboolean (*UnmapBuffer)( struct gl_context *ctx, GLenum target,
d608 1
a608 1
    * \name Functions for GL_EXT_framebuffer_{object,blit}.
d624 1
a624 1
                               struct gl_renderbuffer_attachment *att);
d632 2
d642 1
a676 19
    * Bitmask of state changes that require the current T&L module to be
    * validated, using ValidateTnlModule() below.
    */
   GLuint NeedValidate;

   /**
    * Validate the current T&L module. 
    *
    * This is called directly after UpdateState() when a state change that has
    * occurred matches the dd_function_table::NeedValidate bitmask above.  This
    * ensures all computed values are up to date, thus allowing the driver to
    * decide if the current T&L module needs to be swapped out.
    *
    * This must be non-NULL if a driver installs a custom T&L module and sets
    * the dd_function_table::NeedValidate bitmask, but may be NULL otherwise.
    */
   void (*ValidateTnlModule)( struct gl_context *ctx, GLuint new_state );

   /**
d684 3
a686 4
    * Current state of an in-progress compilation.  
    *
    * May take on any of the additional values PRIM_OUTSIDE_BEGIN_END,
    * PRIM_INSIDE_UNKNOWN_PRIM or PRIM_UNKNOWN defined above.
d695 2
a696 2
    * between glBegin()/glEnd() objects or __struct gl_contextRec::Current is not
    * updated.
d701 1
a701 2
   GLuint NeedFlush;
   GLuint SaveNeedFlush;
d703 2
d764 1
a818 2
   void (*DrawTransformFeedback)(struct gl_context *ctx, GLenum mode,
                                 struct gl_transform_feedback_object *obj);
d832 14
d850 1
a850 5
 * Transform/Clip/Lighting interface
 *
 * Drivers present a reduced set of the functions possible in
 * glBegin()/glEnd() objects.  Core mesa provides translation stubs for the
 * remaining functions to map down to these entry points.
d852 5
a856 6
 * These are the initial values to be installed into dispatch by
 * mesa.  If the T&L driver wants to modify the dispatch table
 * while installed, it must do so itself.  It would be possible for
 * the vertexformat to install its own initial values for these
 * functions, but this way there is an obvious list of what is
 * expected of the driver.
d858 1
a858 3
 * If the driver wants to hook in entry points other than those
 * listed, it must restore them to their original values in
 * the disable() callback, below.
a860 4
   /**
    * \name Vertex
    */
   /*@@{*/
d909 1
a909 1
   /* GL_NV_vertex_program */
d945 63
a1007 58
   /*@@}*/

   void (GLAPIENTRYP Rectf)( GLfloat, GLfloat, GLfloat, GLfloat );

   /**
    * \name Array
    */
   /*@@{*/
   void (GLAPIENTRYP DrawArrays)( GLenum mode, GLint start, GLsizei count );
   void (GLAPIENTRYP DrawElements)( GLenum mode, GLsizei count, GLenum type,
			 const GLvoid *indices );
   void (GLAPIENTRYP DrawRangeElements)( GLenum mode, GLuint start,
			      GLuint end, GLsizei count,
			      GLenum type, const GLvoid *indices );
   void (GLAPIENTRYP MultiDrawElementsEXT)( GLenum mode, const GLsizei *count,
					    GLenum type,
					    const GLvoid **indices,
					    GLsizei primcount);
   void (GLAPIENTRYP DrawElementsBaseVertex)( GLenum mode, GLsizei count,
					      GLenum type,
					      const GLvoid *indices,
					      GLint basevertex );
   void (GLAPIENTRYP DrawRangeElementsBaseVertex)( GLenum mode, GLuint start,
						   GLuint end, GLsizei count,
						   GLenum type,
						   const GLvoid *indices,
						   GLint basevertex);
   void (GLAPIENTRYP MultiDrawElementsBaseVertex)( GLenum mode,
						   const GLsizei *count,
						   GLenum type,
						   const GLvoid **indices,
						   GLsizei primcount,
						   const GLint *basevertex);
   void (GLAPIENTRYP DrawArraysInstanced)(GLenum mode, GLint first,
                                          GLsizei count, GLsizei primcount);
   void (GLAPIENTRYP DrawElementsInstanced)(GLenum mode, GLsizei count,
                                            GLenum type, const GLvoid *indices,
                                            GLsizei primcount);
   void (GLAPIENTRYP DrawElementsInstancedBaseVertex)(GLenum mode, GLsizei count,
                                            GLenum type, const GLvoid *indices,
                                            GLsizei primcount, GLint basevertex);
   /*@@}*/

   /**
    * \name Eval
    *
    * If you don't support eval, fallback to the default vertex format
    * on receiving an eval call and use the pipeline mechanism to
    * provide partial T&L acceleration.
    *
    * Mesa will provide a set of helper functions to do eval within
    * accelerated vertex formats, eventually...
    */
   /*@@{*/
   void (GLAPIENTRYP EvalMesh1)( GLenum mode, GLint i1, GLint i2 );
   void (GLAPIENTRYP EvalMesh2)( GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2 );
   /*@@}*/

@


1.6
log
@Merge Mesa 7.10.3
@
text
@a604 9
    * Called when a shader is compiled.
    *
    * Note that not all shader objects get ShaderCompile called on
    * them.  Notably, the shaders containing builtin functions do not
    * have CompileShader() called, so if lowering passes are done they
    * need to also be performed in LinkShader().
    */
   GLboolean (*CompileShader)(struct gl_context *ctx, struct gl_shader *shader);
   /**
d629 2
d635 3
a874 5

#define PRIM_OUTSIDE_BEGIN_END   (GL_POLYGON+1)
#define PRIM_INSIDE_UNKNOWN_PRIM (GL_POLYGON+2)
#define PRIM_UNKNOWN             (GL_POLYGON+3)

d1019 13
d1180 3
@


1.5
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d36 6
d43 7
a49 1
struct gl_display_list;
d51 1
a51 1
#if FEATURE_ARB_vertex_buffer_object
a63 1
#endif
d85 1
a85 1
   const GLubyte * (*GetString)( GLcontext *ctx, GLenum name );
d93 1
a93 1
   void (*UpdateState)( GLcontext *ctx, GLbitfield new_state );
d101 1
a101 1
   void (*GetBufferSize)( GLframebuffer *buffer,
d108 1
a108 1
   void (*ResizeBuffers)( GLcontext *ctx, GLframebuffer *fb,
d113 1
a113 1
    * __GLcontextRec::ErrorValue contains the error value.
d115 1
a115 1
   void (*Error)( GLcontext *ctx );
d120 1
a120 1
   void (*Finish)( GLcontext *ctx );
d125 1
a125 1
   void (*Flush)( GLcontext *ctx );
d132 1
a132 1
   void (*Clear)( GLcontext *ctx, GLbitfield buffers );
d137 1
a137 1
   void (*Accum)( GLcontext *ctx, GLenum op, GLfloat value );
d143 1
a143 1
   void (*RasterPos)( GLcontext *ctx, const GLfloat v[4] );
d154 1
a154 1
   void (*DrawPixels)( GLcontext *ctx,
d163 1
a163 1
   void (*ReadPixels)( GLcontext *ctx,
d172 1
a172 1
   void (*CopyPixels)( GLcontext *ctx, GLint srcx, GLint srcy,
d179 1
a179 1
   void (*Bitmap)( GLcontext *ctx,
d198 1
a198 1
   GLuint (*ChooseTextureFormat)( GLcontext *ctx, GLint internalFormat,
d218 1
a218 1
   void (*TexImage1D)( GLcontext *ctx, GLenum target, GLint level,
d231 1
a231 1
   void (*TexImage2D)( GLcontext *ctx, GLenum target, GLint level,
d244 1
a244 1
   void (*TexImage3D)( GLcontext *ctx, GLenum target, GLint level,
d273 1
a273 1
   void (*TexSubImage1D)( GLcontext *ctx, GLenum target, GLint level,
d286 1
a286 1
   void (*TexSubImage2D)( GLcontext *ctx, GLenum target, GLint level,
d300 1
a300 1
   void (*TexSubImage3D)( GLcontext *ctx, GLenum target, GLint level,
d312 1
a312 1
   void (*GetTexImage)( GLcontext *ctx, GLenum target, GLint level,
d322 1
a322 1
   void (*CopyTexImage1D)( GLcontext *ctx, GLenum target, GLint level,
d331 1
a331 1
   void (*CopyTexImage2D)( GLcontext *ctx, GLenum target, GLint level,
d340 1
a340 1
   void (*CopyTexSubImage1D)( GLcontext *ctx, GLenum target, GLint level,
d348 1
a348 1
   void (*CopyTexSubImage2D)( GLcontext *ctx, GLenum target, GLint level,
d357 1
a357 1
   void (*CopyTexSubImage3D)( GLcontext *ctx, GLenum target, GLint level,
d365 1
a365 1
   void (*GenerateMipmap)(GLcontext *ctx, GLenum target,
d374 1
a374 1
   GLboolean (*TestProxyTexImage)(GLcontext *ctx, GLenum target,
d402 1
a402 1
   void (*CompressedTexImage1D)( GLcontext *ctx, GLenum target,
d413 1
a413 1
   void (*CompressedTexImage2D)( GLcontext *ctx, GLenum target,
d424 1
a424 1
   void (*CompressedTexImage3D)( GLcontext *ctx, GLenum target,
d449 1
a449 1
   void (*CompressedTexSubImage1D)(GLcontext *ctx, GLenum target, GLint level,
d460 1
a460 1
   void (*CompressedTexSubImage2D)(GLcontext *ctx, GLenum target, GLint level,
d472 1
a472 1
   void (*CompressedTexSubImage3D)(GLcontext *ctx, GLenum target, GLint level,
d484 1
a484 1
   void (*GetCompressedTexImage)(GLcontext *ctx, GLenum target, GLint level,
d499 1
a499 1
   void (*BindTexture)( GLcontext *ctx, GLenum target,
d507 1
a507 1
   struct gl_texture_object * (*NewTextureObject)( GLcontext *ctx, GLuint name,
d515 1
a515 1
   void (*DeleteTexture)( GLcontext *ctx, struct gl_texture_object *tObj );
d520 1
a520 1
   struct gl_texture_image * (*NewTextureImage)( GLcontext *ctx );
d525 1
a525 1
   void (*FreeTexImageData)( GLcontext *ctx, struct gl_texture_image *tImage );
d528 1
a528 1
   void (*MapTexture)( GLcontext *ctx, struct gl_texture_object *tObj );
d530 1
a530 1
   void (*UnmapTexture)( GLcontext *ctx, struct gl_texture_object *tObj );
d548 1
a548 1
   GLboolean (*IsTextureResident)( GLcontext *ctx,
d557 1
a557 1
   void (*UpdateTexturePalette)( GLcontext *ctx,
d566 1
a566 1
   void (*CopyColorTable)( GLcontext *ctx,
d570 1
a570 1
   void (*CopyColorSubTable)( GLcontext *ctx,
a572 9

   void (*CopyConvolutionFilter1D)( GLcontext *ctx, GLenum target,
				    GLenum internalFormat,
				    GLint x, GLint y, GLsizei width );

   void (*CopyConvolutionFilter2D)( GLcontext *ctx, GLenum target,
				    GLenum internalFormat,
				    GLint x, GLint y,
				    GLsizei width, GLsizei height );
d581 1
a581 1
   void (*BindProgram)(GLcontext *ctx, GLenum target, struct gl_program *prog);
d583 1
a583 1
   struct gl_program * (*NewProgram)(GLcontext *ctx, GLenum target, GLuint id);
d585 1
a585 1
   void (*DeleteProgram)(GLcontext *ctx, struct gl_program *prog);   
d591 1
a591 1
   GLboolean (*ProgramStringNotify)(GLcontext *ctx, GLenum target, 
d595 1
a595 1
   GLboolean (*IsProgramNative)(GLcontext *ctx, GLenum target, 
d600 21
d633 1
a633 1
   void (*AlphaFunc)(GLcontext *ctx, GLenum func, GLfloat ref);
d635 1
a635 1
   void (*BlendColor)(GLcontext *ctx, const GLfloat color[4]);
d637 1
a637 1
   void (*BlendEquationSeparate)(GLcontext *ctx, GLenum modeRGB, GLenum modeA);
d639 1
a639 1
   void (*BlendFuncSeparate)(GLcontext *ctx,
d643 1
a643 1
   void (*ClearColor)(GLcontext *ctx, const GLfloat color[4]);
d645 1
a645 1
   void (*ClearDepth)(GLcontext *ctx, GLclampd d);
d647 1
a647 1
   void (*ClearStencil)(GLcontext *ctx, GLint s);
d649 1
a649 1
   void (*ClipPlane)(GLcontext *ctx, GLenum plane, const GLfloat *equation );
d651 1
a651 1
   void (*ColorMask)(GLcontext *ctx, GLboolean rmask, GLboolean gmask,
d653 1
a653 1
   void (*ColorMaskIndexed)(GLcontext *ctx, GLuint buf, GLboolean rmask,
d656 1
a656 1
   void (*ColorMaterial)(GLcontext *ctx, GLenum face, GLenum mode);
d658 1
a658 1
   void (*CullFace)(GLcontext *ctx, GLenum mode);
d660 1
a660 1
   void (*FrontFace)(GLcontext *ctx, GLenum mode);
d662 1
a662 1
   void (*DepthFunc)(GLcontext *ctx, GLenum func);
d664 1
a664 1
   void (*DepthMask)(GLcontext *ctx, GLboolean flag);
d666 1
a666 1
   void (*DepthRange)(GLcontext *ctx, GLclampd nearval, GLclampd farval);
d668 1
a668 1
   void (*DrawBuffer)( GLcontext *ctx, GLenum buffer );
d670 1
a670 1
   void (*DrawBuffers)( GLcontext *ctx, GLsizei n, const GLenum *buffers );
d672 1
a672 1
   void (*Enable)(GLcontext *ctx, GLenum cap, GLboolean state);
d674 1
a674 1
   void (*Fogfv)(GLcontext *ctx, GLenum pname, const GLfloat *params);
d676 1
a676 1
   void (*Hint)(GLcontext *ctx, GLenum target, GLenum mode);
d681 1
a681 1
   void (*Lightfv)(GLcontext *ctx, GLenum light,
d684 1
a684 1
   void (*LightModelfv)(GLcontext *ctx, GLenum pname, const GLfloat *params);
d686 1
a686 1
   void (*LineStipple)(GLcontext *ctx, GLint factor, GLushort pattern );
d688 1
a688 1
   void (*LineWidth)(GLcontext *ctx, GLfloat width);
d690 2
a691 2
   void (*LogicOpcode)(GLcontext *ctx, GLenum opcode);
   void (*PointParameterfv)(GLcontext *ctx, GLenum pname,
d694 1
a694 1
   void (*PointSize)(GLcontext *ctx, GLfloat size);
d696 1
a696 1
   void (*PolygonMode)(GLcontext *ctx, GLenum face, GLenum mode);
d698 1
a698 1
   void (*PolygonOffset)(GLcontext *ctx, GLfloat factor, GLfloat units);
d700 1
a700 1
   void (*PolygonStipple)(GLcontext *ctx, const GLubyte *mask );
d702 1
a702 1
   void (*ReadBuffer)( GLcontext *ctx, GLenum buffer );
d704 1
a704 1
   void (*RenderMode)(GLcontext *ctx, GLenum mode );
d706 1
a706 1
   void (*Scissor)(GLcontext *ctx, GLint x, GLint y, GLsizei w, GLsizei h);
d708 1
a708 1
   void (*ShadeModel)(GLcontext *ctx, GLenum mode);
d710 1
a710 1
   void (*StencilFuncSeparate)(GLcontext *ctx, GLenum face, GLenum func,
d713 1
a713 1
   void (*StencilMaskSeparate)(GLcontext *ctx, GLenum face, GLuint mask);
d715 1
a715 1
   void (*StencilOpSeparate)(GLcontext *ctx, GLenum face, GLenum fail,
d718 1
a718 1
   void (*TexGen)(GLcontext *ctx, GLenum coord, GLenum pname,
d721 1
a721 1
   void (*TexEnv)(GLcontext *ctx, GLenum target, GLenum pname,
d724 1
a724 1
   void (*TexParameter)(GLcontext *ctx, GLenum target,
d728 1
a728 1
   void (*Viewport)(GLcontext *ctx, GLint x, GLint y, GLsizei w, GLsizei h);
a731 21
   /** 
    * \name State-query functions
    *
    * Return GL_TRUE if query was completed, GL_FALSE otherwise.
    */
   /*@@{*/
   /** Return the value or values of a selected parameter */
   GLboolean (*GetBooleanv)(GLcontext *ctx, GLenum pname, GLboolean *result);
   /** Return the value or values of a selected parameter */
   GLboolean (*GetDoublev)(GLcontext *ctx, GLenum pname, GLdouble *result);
   /** Return the value or values of a selected parameter */
   GLboolean (*GetFloatv)(GLcontext *ctx, GLenum pname, GLfloat *result);
   /** Return the value or values of a selected parameter */
   GLboolean (*GetIntegerv)(GLcontext *ctx, GLenum pname, GLint *result);
   /** Return the value or values of a selected parameter */
   GLboolean (*GetInteger64v)(GLcontext *ctx, GLenum pname, GLint64 *result);
   /** Return the value or values of a selected parameter */
   GLboolean (*GetPointerv)(GLcontext *ctx, GLenum pname, GLvoid **result);
   /*@@}*/
   

a734 1
#if FEATURE_ARB_vertex_buffer_object
d736 1
a736 1
   void (*BindBuffer)( GLcontext *ctx, GLenum target,
d739 1
a739 1
   struct gl_buffer_object * (*NewBufferObject)( GLcontext *ctx, GLuint buffer,
d742 1
a742 1
   void (*DeleteBuffer)( GLcontext *ctx, struct gl_buffer_object *obj );
d744 1
a744 1
   GLboolean (*BufferData)( GLcontext *ctx, GLenum target, GLsizeiptrARB size,
d748 1
a748 1
   void (*BufferSubData)( GLcontext *ctx, GLenum target, GLintptrARB offset,
d752 1
a752 1
   void (*GetBufferSubData)( GLcontext *ctx, GLenum target,
d756 1
a756 1
   void * (*MapBuffer)( GLcontext *ctx, GLenum target, GLenum access,
d759 1
a759 1
   void (*CopyBufferSubData)( GLcontext *ctx,
d767 1
a767 1
   void * (*MapBufferRange)( GLcontext *ctx, GLenum target, GLintptr offset,
d771 1
a771 1
   void (*FlushMappedBufferRange)(GLcontext *ctx, GLenum target, 
d775 1
a775 1
   GLboolean (*UnmapBuffer)( GLcontext *ctx, GLenum target,
a777 1
#endif
a781 1
#if FEATURE_APPLE_object_purgeable
d784 3
a786 3
   GLenum (*BufferObjectPurgeable)( GLcontext *ctx, struct gl_buffer_object *obj, GLenum option );
   GLenum (*RenderObjectPurgeable)( GLcontext *ctx, struct gl_renderbuffer *obj, GLenum option );
   GLenum (*TextureObjectPurgeable)( GLcontext *ctx, struct gl_texture_object *obj, GLenum option );
d789 3
a791 3
   GLenum (*BufferObjectUnpurgeable)( GLcontext *ctx, struct gl_buffer_object *obj, GLenum option );
   GLenum (*RenderObjectUnpurgeable)( GLcontext *ctx, struct gl_renderbuffer *obj, GLenum option );
   GLenum (*TextureObjectUnpurgeable)( GLcontext *ctx, struct gl_texture_object *obj, GLenum option );
a792 1
#endif
d795 1
a795 1
    * \name Functions for GL_EXT_framebuffer_object
a796 1
#if FEATURE_EXT_framebuffer_object
d798 3
a800 3
   struct gl_framebuffer * (*NewFramebuffer)(GLcontext *ctx, GLuint name);
   struct gl_renderbuffer * (*NewRenderbuffer)(GLcontext *ctx, GLuint name);
   void (*BindFramebuffer)(GLcontext *ctx, GLenum target,
d803 1
a803 1
   void (*FramebufferRenderbuffer)(GLcontext *ctx, 
d807 1
a807 1
   void (*RenderTexture)(GLcontext *ctx,
d810 1
a810 1
   void (*FinishRenderTexture)(GLcontext *ctx,
d812 1
a812 1
   void (*ValidateFramebuffer)(GLcontext *ctx,
d815 1
a815 3
#endif
#if FEATURE_EXT_framebuffer_blit
   void (*BlitFramebuffer)(GLcontext *ctx,
a818 1
#endif
d824 6
a829 6
   struct gl_query_object * (*NewQueryObject)(GLcontext *ctx, GLuint id);
   void (*DeleteQuery)(GLcontext *ctx, struct gl_query_object *q);
   void (*BeginQuery)(GLcontext *ctx, struct gl_query_object *q);
   void (*EndQuery)(GLcontext *ctx, struct gl_query_object *q);
   void (*CheckQuery)(GLcontext *ctx, struct gl_query_object *q);
   void (*WaitQuery)(GLcontext *ctx, struct gl_query_object *q);
d837 3
a839 3
   struct gl_array_object * (*NewArrayObject)(GLcontext *ctx, GLuint id);
   void (*DeleteArrayObject)(GLcontext *ctx, struct gl_array_object *obj);
   void (*BindArrayObject)(GLcontext *ctx, struct gl_array_object *obj);
d846 6
a851 48
   void (*AttachShader)(GLcontext *ctx, GLuint program, GLuint shader);
   void (*BindAttribLocation)(GLcontext *ctx, GLuint program, GLuint index,
                              const GLcharARB *name);
   void (*CompileShader)(GLcontext *ctx, GLuint shader);
   GLuint (*CreateShader)(GLcontext *ctx, GLenum type);
   GLuint (*CreateProgram)(GLcontext *ctx);
   void (*DeleteProgram2)(GLcontext *ctx, GLuint program);
   void (*DeleteShader)(GLcontext *ctx, GLuint shader);
   void (*DetachShader)(GLcontext *ctx, GLuint program, GLuint shader);
   void (*GetActiveAttrib)(GLcontext *ctx, GLuint program, GLuint index,
                           GLsizei maxLength, GLsizei * length, GLint * size,
                           GLenum * type, GLcharARB * name);
   void (*GetActiveUniform)(GLcontext *ctx, GLuint program, GLuint index,
                            GLsizei maxLength, GLsizei *length, GLint *size,
                            GLenum *type, GLcharARB *name);
   void (*GetAttachedShaders)(GLcontext *ctx, GLuint program, GLsizei maxCount,
                              GLsizei *count, GLuint *obj);
   GLint (*GetAttribLocation)(GLcontext *ctx, GLuint program,
                              const GLcharARB *name);
   GLuint (*GetHandle)(GLcontext *ctx, GLenum pname);
   void (*GetProgramiv)(GLcontext *ctx, GLuint program,
                        GLenum pname, GLint *params);
   void (*GetProgramInfoLog)(GLcontext *ctx, GLuint program, GLsizei bufSize,
                             GLsizei *length, GLchar *infoLog);
   void (*GetShaderiv)(GLcontext *ctx, GLuint shader,
                       GLenum pname, GLint *params);
   void (*GetShaderInfoLog)(GLcontext *ctx, GLuint shader, GLsizei bufSize,
                            GLsizei *length, GLchar *infoLog);
   void (*GetShaderSource)(GLcontext *ctx, GLuint shader, GLsizei maxLength,
                           GLsizei *length, GLcharARB *sourceOut);
   void (*GetUniformfv)(GLcontext *ctx, GLuint program, GLint location,
                        GLfloat *params);
   void (*GetUniformiv)(GLcontext *ctx, GLuint program, GLint location,
                        GLint *params);
   GLint (*GetUniformLocation)(GLcontext *ctx, GLuint program,
                               const GLcharARB *name);
   GLboolean (*IsProgram)(GLcontext *ctx, GLuint name);
   GLboolean (*IsShader)(GLcontext *ctx, GLuint name);
   void (*LinkProgram)(GLcontext *ctx, GLuint program);
   void (*ShaderSource)(GLcontext *ctx, GLuint shader, const GLchar *source);
   void (*Uniform)(GLcontext *ctx, GLint location, GLsizei count,
                   const GLvoid *values, GLenum type);
   void (*UniformMatrix)(GLcontext *ctx, GLint cols, GLint rows,
                         GLint location, GLsizei count,
                         GLboolean transpose, const GLfloat *values);
   void (*UseProgram)(GLcontext *ctx, GLuint program);
   void (*ValidateProgram)(GLcontext *ctx, GLuint program);
   /* XXX many more to come */
d877 1
a877 1
   void (*ValidateTnlModule)( GLcontext *ctx, GLuint new_state );
d904 1
a904 1
    * between glBegin()/glEnd() objects or __GLcontextRec::Current is not
d917 1
a917 1
   void (*BeginVertices)( GLcontext *ctx );
d923 1
a923 1
    * __GLcontextRec::Current and gl_light_attrib::Material
d928 2
a929 2
   void (*FlushVertices)( GLcontext *ctx, GLuint flags );
   void (*SaveFlushVertices)( GLcontext *ctx );
d936 1
a936 1
   GLboolean (*NotifySaveBegin)( GLcontext *ctx, GLenum mode );
d942 1
a942 1
   void (*LightingSpaceChange)( GLcontext *ctx );
d950 1
a950 1
   void (*NewList)( GLcontext *ctx, GLuint list, GLenum mode );
d956 1
a956 1
   void (*EndList)( GLcontext *ctx );
d963 1
a963 1
   void (*BeginCallList)( GLcontext *ctx, 
d970 1
a970 1
   void (*EndCallList)( GLcontext *ctx );
a972 1
#if FEATURE_ARB_sync
d977 5
a981 5
   struct gl_sync_object * (*NewSyncObject)(GLcontext *, GLenum);
   void (*FenceSync)(GLcontext *, struct gl_sync_object *, GLenum, GLbitfield);
   void (*DeleteSyncObject)(GLcontext *, struct gl_sync_object *);
   void (*CheckSync)(GLcontext *, struct gl_sync_object *);
   void (*ClientWaitSync)(GLcontext *, struct gl_sync_object *,
d983 1
a983 1
   void (*ServerWaitSync)(GLcontext *, struct gl_sync_object *,
a985 1
#endif
d988 1
a988 1
   void (*BeginConditionalRender)(GLcontext *ctx, struct gl_query_object *q,
d990 1
a990 1
   void (*EndConditionalRender)(GLcontext *ctx, struct gl_query_object *q);
a991 1
#if FEATURE_OES_draw_texture
d996 1
a996 1
   void (*DrawTex)(GLcontext *ctx, GLfloat x, GLfloat y, GLfloat z,
a998 1
#endif
d1000 4
a1003 2
#if FEATURE_OES_EGL_image
   void (*EGLImageTargetTexture2D)(GLcontext *ctx, GLenum target,
d1007 1
a1007 1
   void (*EGLImageTargetRenderbufferStorage)(GLcontext *ctx,
a1009 1
#endif
d1011 17
d1054 1
a1054 1
   void (GLAPIENTRYP ArrayElement)( GLint ); /* NOTE */
d1060 6
a1065 6
   void (GLAPIENTRYP EvalCoord1f)( GLfloat );          /* NOTE */
   void (GLAPIENTRYP EvalCoord1fv)( const GLfloat * ); /* NOTE */
   void (GLAPIENTRYP EvalCoord2f)( GLfloat, GLfloat ); /* NOTE */
   void (GLAPIENTRYP EvalCoord2fv)( const GLfloat * ); /* NOTE */
   void (GLAPIENTRYP EvalPoint1)( GLint );             /* NOTE */
   void (GLAPIENTRYP EvalPoint2)( GLint, GLint );      /* NOTE */
d1070 1
a1070 1
   void (GLAPIENTRYP Materialfv)( GLenum face, GLenum pname, const GLfloat * ); /* NOTE */
d1097 2
a1098 2
   void (GLAPIENTRYP CallList)( GLuint );	/* NOTE */
   void (GLAPIENTRYP CallLists)( GLsizei, GLenum, const GLvoid * );	/* NOTE */
d1101 1
d1111 1
a1111 1
#if FEATURE_ARB_vertex_program
d1120 18
a1137 1
#endif
a1139 2
   /*
    */
d1171 5
@


1.4
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d37 17
a53 1
struct mesa_display_list;
d185 1
a185 1
    * pointer to an appropriate gl_texture_format.
d187 2
a188 2
   const struct gl_texture_format *(*ChooseTextureFormat)( GLcontext *ctx,
                      GLint internalFormat, GLenum srcFormat, GLenum srcType );
a477 7
   /**
    * Called to query number of bytes of storage needed to store the
    * specified compressed texture.
    */
   GLuint (*CompressedTextureSize)( GLcontext *ctx, GLsizei width,
                                    GLsizei height, GLsizei depth,
                                    GLenum format );
a540 11
    * Called by glPrioritizeTextures().
    */
   void (*PrioritizeTexture)( GLcontext *ctx,  struct gl_texture_object *t,
                              GLclampf priority );

   /**
    * Called by glActiveTextureARB() to set current texture unit.
    */
   void (*ActiveTexture)( GLcontext *ctx, GLuint texUnitNumber );

   /**
d584 7
a590 6
   /** Notify driver that a program string has been specified. */
   void (*ProgramStringNotify)(GLcontext *ctx, GLenum target, 
			       struct gl_program *prog);
   /** Get value of a program register during program execution. */
   void (*GetProgramRegister)(GLcontext *ctx, enum register_file file,
                              GLuint index, GLfloat val[4]);
a622 2
   /** Specify the clear value for the color index buffers */
   void (*ClearIndex)(GLcontext *ctx, GLuint index);
d630 2
a653 2
   /** Control the writing of individual bits in the color index buffers */
   void (*IndexMask)(GLcontext *ctx, GLuint mask);
a703 1
   void (*TextureMatrix)(GLcontext *ctx, GLuint unit, const GLmatrix *mat);
a708 28
   /**
    * \name Vertex array functions
    *
    * Called by the corresponding OpenGL functions.
    */
   /*@@{*/
   void (*VertexPointer)(GLcontext *ctx, GLint size, GLenum type,
			 GLsizei stride, const GLvoid *ptr);
   void (*NormalPointer)(GLcontext *ctx, GLenum type,
			 GLsizei stride, const GLvoid *ptr);
   void (*ColorPointer)(GLcontext *ctx, GLint size, GLenum type,
			GLsizei stride, const GLvoid *ptr);
   void (*FogCoordPointer)(GLcontext *ctx, GLenum type,
			   GLsizei stride, const GLvoid *ptr);
   void (*IndexPointer)(GLcontext *ctx, GLenum type,
			GLsizei stride, const GLvoid *ptr);
   void (*SecondaryColorPointer)(GLcontext *ctx, GLint size, GLenum type,
				 GLsizei stride, const GLvoid *ptr);
   void (*TexCoordPointer)(GLcontext *ctx, GLint size, GLenum type,
			   GLsizei stride, const GLvoid *ptr);
   void (*EdgeFlagPointer)(GLcontext *ctx, GLsizei stride, const GLvoid *ptr);
   void (*VertexAttribPointer)(GLcontext *ctx, GLuint index, GLint size,
                               GLenum type, GLsizei stride, const GLvoid *ptr);
   void (*LockArraysEXT)( GLcontext *ctx, GLint first, GLsizei count );
   void (*UnlockArraysEXT)( GLcontext *ctx );
   /*@@}*/


d724 2
d743 3
a745 3
   void (*BufferData)( GLcontext *ctx, GLenum target, GLsizeiptrARB size,
		       const GLvoid *data, GLenum usage,
		       struct gl_buffer_object *obj );
d758 16
d780 17
d804 2
a805 1
                           struct gl_framebuffer *fb, struct gl_framebuffer *fbread);
d815 2
d895 1
a895 1
                         GLenum matrixType, GLint location, GLsizei count,
d961 6
d1012 1
a1012 1
			  struct mesa_display_list *dlist );
d1020 42
d1075 1
a1075 1
 * the vertexformat to install it's own initial values for these
d1170 19
@


1.3
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d114 5
d825 5
a829 3
   void (*BeginQuery)(GLcontext *ctx, GLenum target,
                      struct gl_query_object *q);
   void (*EndQuery)(GLcontext *ctx, GLenum target, struct gl_query_object *q);
d922 3
a924 3
#define PRIM_OUTSIDE_BEGIN_END   GL_POLYGON+1
#define PRIM_INSIDE_UNKNOWN_PRIM GL_POLYGON+2
#define PRIM_UNKNOWN             GL_POLYGON+3
@


1.2
log
@Update to Mesa 7.0.3. tested my oga@@ and johan@@
@
text
@d331 6
d454 2
a455 2
                                 const struct gl_texture_object *texObj,
                                 const struct gl_texture_image *texImage);
d796 1
a796 1
                           struct gl_framebuffer *fb);
d871 2
@


1.1
log
@Initial revision
@
text
@d8 1
a8 1
 * Version:  6.5
d10 1
a10 1
 * Copyright (C) 1999-2005  Brian Paul   All Rights Reserved.
d55 1
a55 2
    *
    * Only the GL_RENDERER token must be implemented.  Otherwise, NULL can be
d72 1
d79 1
a85 1
    *
d102 2
a103 9
    *
    * \param mask a bitmask of the DD_*_BIT values defined above that indicates
    * which buffers need to be cleared.
    * \param all if true then clear the whole buffer, else clear only the
    * region defined by <tt>(x, y, width, height)</tt>.
    * 
    * This function must obey the glColorMask(), glIndexMask() and
    * glStencilMask() settings!
    * Software Mesa can do masked clears if the device driver can't.
d105 1
a105 3
   void (*Clear)( GLcontext *ctx, GLbitfield mask, GLboolean all,
		  GLint x, GLint y, GLint width, GLint height );

d108 1
a108 1
    * \name For hardware accumulation buffer
d110 1
a110 7
   /*@@{*/
   /**
    * Execute glAccum command within the given scissor region.
    */
   void (*Accum)( GLcontext *ctx, GLenum op, GLfloat value,
		  GLint xpos, GLint ypos, GLint width, GLint height );
   /*@@}*/
d114 1
a114 1
    * \name glDraw(), glRead(), glCopyPixels() and glBitmap() functions
d119 1
a119 2
    * This is called by glDrawPixels().
    *
d138 1
a138 4
    * Do a glCopyPixels().  
    *
    * This function must respect all rasterization state, glPixelTransfer(),
    * glPixelZoom(), etc.
d145 1
a145 3
    * This is called by glBitmap().  
    *
    * Works the same as dd_function_table::DrawPixels, above.
d496 5
d578 3
a580 2
   

d827 52
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d8 1
a8 1
 * Version:  6.5.2
d10 1
a10 1
 * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
d55 2
a56 1
    * Only the GL_RENDERER query must be implemented.  Otherwise, NULL can be
a72 1
    * XXX OBSOLETE: this function will be removed in the future.
a78 1
    * XXX OBSOLETE: this function will be removed in the future.
d85 1
d102 9
a110 2
    * \param buffers  a bitmask of BUFFER_BIT_* flags indicating which
    *                 renderbuffers need to be cleared.
d112 2
a113 1
   void (*Clear)( GLcontext *ctx, GLbitfield buffers );
d115 5
d121 1
a121 1
    * Execute glAccum command.
d123 3
a125 1
   void (*Accum)( GLcontext *ctx, GLenum op, GLfloat value );
d129 1
a129 1
    * \name Image-related functions
d134 2
a135 1
    * Called by glDrawPixels().
d154 4
a157 1
    * Called by glCopyPixels().  
d164 3
a166 1
    * Called by glBitmap().  
d594 2
a595 3
   /** Get value of a fragment program register during program execution. */
   void (*GetFragmentProgramRegister)(GLcontext *ctx, enum register_file file,
                                      GLuint index, GLfloat val[4]);
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d573 3
a575 3
   /** Get value of a program register during program execution. */
   void (*GetProgramRegister)(GLcontext *ctx, enum register_file file,
                              GLuint index, GLfloat val[4]);
a821 52
   /*@@}*/

   /**
    * \name GLSL-related functions (ARB extensions and OpenGL 2.x)
    */
   /*@@{*/
   void (*AttachShader)(GLcontext *ctx, GLuint program, GLuint shader);
   void (*BindAttribLocation)(GLcontext *ctx, GLuint program, GLuint index,
                              const GLcharARB *name);
   void (*CompileShader)(GLcontext *ctx, GLuint shader);
   GLuint (*CreateShader)(GLcontext *ctx, GLenum type);
   GLuint (*CreateProgram)(GLcontext *ctx);
   void (*DeleteProgram2)(GLcontext *ctx, GLuint program);
   void (*DeleteShader)(GLcontext *ctx, GLuint shader);
   void (*DetachShader)(GLcontext *ctx, GLuint program, GLuint shader);
   void (*GetActiveAttrib)(GLcontext *ctx, GLuint program, GLuint index,
                           GLsizei maxLength, GLsizei * length, GLint * size,
                           GLenum * type, GLcharARB * name);
   void (*GetActiveUniform)(GLcontext *ctx, GLuint program, GLuint index,
                            GLsizei maxLength, GLsizei *length, GLint *size,
                            GLenum *type, GLcharARB *name);
   void (*GetAttachedShaders)(GLcontext *ctx, GLuint program, GLsizei maxCount,
                              GLsizei *count, GLuint *obj);
   GLint (*GetAttribLocation)(GLcontext *ctx, GLuint program,
                              const GLcharARB *name);
   GLuint (*GetHandle)(GLcontext *ctx, GLenum pname);
   void (*GetProgramiv)(GLcontext *ctx, GLuint program,
                        GLenum pname, GLint *params);
   void (*GetProgramInfoLog)(GLcontext *ctx, GLuint program, GLsizei bufSize,
                             GLsizei *length, GLchar *infoLog);
   void (*GetShaderiv)(GLcontext *ctx, GLuint shader,
                       GLenum pname, GLint *params);
   void (*GetShaderInfoLog)(GLcontext *ctx, GLuint shader, GLsizei bufSize,
                            GLsizei *length, GLchar *infoLog);
   void (*GetShaderSource)(GLcontext *ctx, GLuint shader, GLsizei maxLength,
                           GLsizei *length, GLcharARB *sourceOut);
   void (*GetUniformfv)(GLcontext *ctx, GLuint program, GLint location,
                        GLfloat *params);
   GLint (*GetUniformLocation)(GLcontext *ctx, GLuint program,
                               const GLcharARB *name);
   GLboolean (*IsProgram)(GLcontext *ctx, GLuint name);
   GLboolean (*IsShader)(GLcontext *ctx, GLuint name);
   void (*LinkProgram)(GLcontext *ctx, GLuint program);
   void (*ShaderSource)(GLcontext *ctx, GLuint shader, const GLchar *source);
   void (*Uniform)(GLcontext *ctx, GLint location, GLsizei count,
                   const GLvoid *values, GLenum type);
   void (*UniformMatrix)(GLcontext *ctx, GLint cols, GLint rows,
                         GLenum matrixType, GLint location, GLsizei count,
                         GLboolean transpose, const GLfloat *values);
   void (*UseProgram)(GLcontext *ctx, GLuint program);
   void (*ValidateProgram)(GLcontext *ctx, GLuint program);
   /* XXX many more to come */
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@a35 6
#include "glheader.h"

struct gl_buffer_object;
struct gl_context;
struct gl_display_list;
struct gl_framebuffer;
d37 1
a37 22
struct gl_program;
struct gl_renderbuffer;
struct gl_renderbuffer_attachment;
struct gl_shader;
struct gl_shader_program;
struct gl_texture_image;
struct gl_texture_object;

/* GL_ARB_vertex_buffer_object */
/* Modifies GL_MAP_UNSYNCHRONIZED_BIT to allow driver to fail (return
 * NULL) if buffer is unavailable for immediate mapping.
 *
 * Does GL_MAP_INVALIDATE_RANGE_BIT do this?  It seems so, but it
 * would require more book-keeping in the driver than seems necessary
 * at this point.
 *
 * Does GL_MAP_INVALDIATE_BUFFER_BIT do this?  Not really -- we don't
 * want to provoke the driver to throw away the old storage, we will
 * respect the contents of already referenced data.
 */
#define MESA_MAP_NOWAIT_BIT       0x0040

d58 1
a58 1
   const GLubyte * (*GetString)( struct gl_context *ctx, GLenum name );
d66 1
a66 1
   void (*UpdateState)( struct gl_context *ctx, GLbitfield new_state );
d74 1
a74 1
   void (*GetBufferSize)( struct gl_framebuffer *buffer,
d81 1
a81 1
   void (*ResizeBuffers)( struct gl_context *ctx, struct gl_framebuffer *fb,
d86 1
a86 1
    * __struct gl_contextRec::ErrorValue contains the error value.
d88 1
a88 1
   void (*Error)( struct gl_context *ctx );
d93 1
a93 1
   void (*Finish)( struct gl_context *ctx );
d98 1
a98 1
   void (*Flush)( struct gl_context *ctx );
d105 1
a105 1
   void (*Clear)( struct gl_context *ctx, GLbitfield buffers );
d110 1
a110 1
   void (*Accum)( struct gl_context *ctx, GLenum op, GLfloat value );
a113 5
    * Execute glRasterPos, updating the ctx->Current.Raster fields
    */
   void (*RasterPos)( struct gl_context *ctx, const GLfloat v[4] );

   /**
d122 1
a122 1
   void (*DrawPixels)( struct gl_context *ctx,
d131 1
a131 1
   void (*ReadPixels)( struct gl_context *ctx,
d140 1
a140 1
   void (*CopyPixels)( struct gl_context *ctx, GLint srcx, GLint srcy,
d147 1
a147 1
   void (*Bitmap)( struct gl_context *ctx,
d164 1
a164 1
    * gl_format value.
d166 2
a167 2
   GLuint (*ChooseTextureFormat)( struct gl_context *ctx, GLint internalFormat,
                                     GLenum srcFormat, GLenum srcType );
d186 1
a186 1
   void (*TexImage1D)( struct gl_context *ctx, GLenum target, GLint level,
d199 1
a199 1
   void (*TexImage2D)( struct gl_context *ctx, GLenum target, GLint level,
d212 1
a212 1
   void (*TexImage3D)( struct gl_context *ctx, GLenum target, GLint level,
d241 1
a241 1
   void (*TexSubImage1D)( struct gl_context *ctx, GLenum target, GLint level,
d254 1
a254 1
   void (*TexSubImage2D)( struct gl_context *ctx, GLenum target, GLint level,
d268 1
a268 1
   void (*TexSubImage3D)( struct gl_context *ctx, GLenum target, GLint level,
d280 1
a280 1
   void (*GetTexImage)( struct gl_context *ctx, GLenum target, GLint level,
d290 1
a290 1
   void (*CopyTexImage1D)( struct gl_context *ctx, GLenum target, GLint level,
d299 1
a299 1
   void (*CopyTexImage2D)( struct gl_context *ctx, GLenum target, GLint level,
d308 1
a308 1
   void (*CopyTexSubImage1D)( struct gl_context *ctx, GLenum target, GLint level,
d316 1
a316 1
   void (*CopyTexSubImage2D)( struct gl_context *ctx, GLenum target, GLint level,
d325 1
a325 1
   void (*CopyTexSubImage3D)( struct gl_context *ctx, GLenum target, GLint level,
a330 6
    * Called by glGenerateMipmap() or when GL_GENERATE_MIPMAP_SGIS is enabled.
    */
   void (*GenerateMipmap)(struct gl_context *ctx, GLenum target,
                          struct gl_texture_object *texObj);

   /**
d336 1
a336 1
   GLboolean (*TestProxyTexImage)(struct gl_context *ctx, GLenum target,
d364 1
a364 1
   void (*CompressedTexImage1D)( struct gl_context *ctx, GLenum target,
d375 1
a375 1
   void (*CompressedTexImage2D)( struct gl_context *ctx, GLenum target,
d386 1
a386 1
   void (*CompressedTexImage3D)( struct gl_context *ctx, GLenum target,
d411 1
a411 1
   void (*CompressedTexSubImage1D)(struct gl_context *ctx, GLenum target, GLint level,
d422 1
a422 1
   void (*CompressedTexSubImage2D)(struct gl_context *ctx, GLenum target, GLint level,
d434 1
a434 1
   void (*CompressedTexSubImage3D)(struct gl_context *ctx, GLenum target, GLint level,
d446 1
a446 1
   void (*GetCompressedTexImage)(struct gl_context *ctx, GLenum target, GLint level,
d448 2
a449 2
                                 struct gl_texture_object *texObj,
                                 struct gl_texture_image *texImage);
d451 7
d468 1
a468 1
   void (*BindTexture)( struct gl_context *ctx, GLenum target,
d476 1
a476 1
   struct gl_texture_object * (*NewTextureObject)( struct gl_context *ctx, GLuint name,
d484 1
a484 1
   void (*DeleteTexture)( struct gl_context *ctx, struct gl_texture_object *tObj );
d489 1
a489 1
   struct gl_texture_image * (*NewTextureImage)( struct gl_context *ctx );
d494 1
a494 6
   void (*FreeTexImageData)( struct gl_context *ctx, struct gl_texture_image *tImage );

   /** Map texture image data into user space */
   void (*MapTexture)( struct gl_context *ctx, struct gl_texture_object *tObj );
   /** Unmap texture images from user space */
   void (*UnmapTexture)( struct gl_context *ctx, struct gl_texture_object *tObj );
d512 1
a512 1
   GLboolean (*IsTextureResident)( struct gl_context *ctx,
d516 11
d532 1
a532 1
   void (*UpdateTexturePalette)( struct gl_context *ctx,
d541 1
a541 1
   void (*CopyColorTable)( struct gl_context *ctx,
d545 1
a545 1
   void (*CopyColorSubTable)( struct gl_context *ctx,
d548 9
d565 1
a565 1
   void (*BindProgram)(struct gl_context *ctx, GLenum target, struct gl_program *prog);
d567 1
a567 1
   struct gl_program * (*NewProgram)(struct gl_context *ctx, GLenum target, GLuint id);
d569 7
a575 8
   void (*DeleteProgram)(struct gl_context *ctx, struct gl_program *prog);   
   /**
    * Notify driver that a program string (and GPU code) has been specified
    * or modified.  Return GL_TRUE or GL_FALSE to indicate if the program is
    * supported by the driver.
    */
   GLboolean (*ProgramStringNotify)(struct gl_context *ctx, GLenum target, 
                                    struct gl_program *prog);
d578 1
a578 1
   GLboolean (*IsProgramNative)(struct gl_context *ctx, GLenum target, 
a582 21
   /**
    * \name GLSL shader/program functions.
    */
   /*@@{*/
   /**
    * Called when a shader is compiled.
    *
    * Note that not all shader objects get ShaderCompile called on
    * them.  Notably, the shaders containing builtin functions do not
    * have CompileShader() called, so if lowering passes are done they
    * need to also be performed in LinkShader().
    */
   GLboolean (*CompileShader)(struct gl_context *ctx, struct gl_shader *shader);
   /**
    * Called when a shader program is linked.
    *
    * This gives drivers an opportunity to clone the IR and make their
    * own transformations on it for the purposes of code generation.
    */
   GLboolean (*LinkShader)(struct gl_context *ctx, struct gl_shader_program *shader);
   /*@@}*/
d595 1
a595 1
   void (*AlphaFunc)(struct gl_context *ctx, GLenum func, GLfloat ref);
d597 1
a597 1
   void (*BlendColor)(struct gl_context *ctx, const GLfloat color[4]);
d599 1
a599 1
   void (*BlendEquationSeparate)(struct gl_context *ctx, GLenum modeRGB, GLenum modeA);
d601 1
a601 1
   void (*BlendFuncSeparate)(struct gl_context *ctx,
d605 1
a605 1
   void (*ClearColor)(struct gl_context *ctx, const GLfloat color[4]);
d607 3
a609 1
   void (*ClearDepth)(struct gl_context *ctx, GLclampd d);
d611 1
a611 1
   void (*ClearStencil)(struct gl_context *ctx, GLint s);
d613 1
a613 1
   void (*ClipPlane)(struct gl_context *ctx, GLenum plane, const GLfloat *equation );
d615 1
a615 1
   void (*ColorMask)(struct gl_context *ctx, GLboolean rmask, GLboolean gmask,
a616 2
   void (*ColorMaskIndexed)(struct gl_context *ctx, GLuint buf, GLboolean rmask,
                            GLboolean gmask, GLboolean bmask, GLboolean amask);
d618 1
a618 1
   void (*ColorMaterial)(struct gl_context *ctx, GLenum face, GLenum mode);
d620 1
a620 1
   void (*CullFace)(struct gl_context *ctx, GLenum mode);
d622 1
a622 1
   void (*FrontFace)(struct gl_context *ctx, GLenum mode);
d624 1
a624 1
   void (*DepthFunc)(struct gl_context *ctx, GLenum func);
d626 1
a626 1
   void (*DepthMask)(struct gl_context *ctx, GLboolean flag);
d628 1
a628 1
   void (*DepthRange)(struct gl_context *ctx, GLclampd nearval, GLclampd farval);
d630 1
a630 1
   void (*DrawBuffer)( struct gl_context *ctx, GLenum buffer );
d632 1
a632 1
   void (*DrawBuffers)( struct gl_context *ctx, GLsizei n, const GLenum *buffers );
d634 1
a634 1
   void (*Enable)(struct gl_context *ctx, GLenum cap, GLboolean state);
d636 1
a636 1
   void (*Fogfv)(struct gl_context *ctx, GLenum pname, const GLfloat *params);
d638 3
a640 1
   void (*Hint)(struct gl_context *ctx, GLenum target, GLenum mode);
d645 1
a645 1
   void (*Lightfv)(struct gl_context *ctx, GLenum light,
d648 1
a648 1
   void (*LightModelfv)(struct gl_context *ctx, GLenum pname, const GLfloat *params);
d650 1
a650 1
   void (*LineStipple)(struct gl_context *ctx, GLint factor, GLushort pattern );
d652 1
a652 1
   void (*LineWidth)(struct gl_context *ctx, GLfloat width);
d654 2
a655 2
   void (*LogicOpcode)(struct gl_context *ctx, GLenum opcode);
   void (*PointParameterfv)(struct gl_context *ctx, GLenum pname,
d658 1
a658 1
   void (*PointSize)(struct gl_context *ctx, GLfloat size);
d660 1
a660 1
   void (*PolygonMode)(struct gl_context *ctx, GLenum face, GLenum mode);
d662 1
a662 1
   void (*PolygonOffset)(struct gl_context *ctx, GLfloat factor, GLfloat units);
d664 1
a664 1
   void (*PolygonStipple)(struct gl_context *ctx, const GLubyte *mask );
d666 1
a666 1
   void (*ReadBuffer)( struct gl_context *ctx, GLenum buffer );
d668 1
a668 1
   void (*RenderMode)(struct gl_context *ctx, GLenum mode );
d670 1
a670 1
   void (*Scissor)(struct gl_context *ctx, GLint x, GLint y, GLsizei w, GLsizei h);
d672 1
a672 1
   void (*ShadeModel)(struct gl_context *ctx, GLenum mode);
d674 1
a674 1
   void (*StencilFuncSeparate)(struct gl_context *ctx, GLenum face, GLenum func,
d677 1
a677 1
   void (*StencilMaskSeparate)(struct gl_context *ctx, GLenum face, GLuint mask);
d679 1
a679 1
   void (*StencilOpSeparate)(struct gl_context *ctx, GLenum face, GLenum fail,
d682 1
a682 1
   void (*TexGen)(struct gl_context *ctx, GLenum coord, GLenum pname,
d685 1
a685 1
   void (*TexEnv)(struct gl_context *ctx, GLenum target, GLenum pname,
d688 1
a688 1
   void (*TexParameter)(struct gl_context *ctx, GLenum target,
d691 1
d693 1
a693 1
   void (*Viewport)(struct gl_context *ctx, GLint x, GLint y, GLsizei w, GLsizei h);
d698 47
d747 1
d749 1
a749 1
   void (*BindBuffer)( struct gl_context *ctx, GLenum target,
d752 1
a752 1
   struct gl_buffer_object * (*NewBufferObject)( struct gl_context *ctx, GLuint buffer,
d755 1
a755 1
   void (*DeleteBuffer)( struct gl_context *ctx, struct gl_buffer_object *obj );
d757 3
a759 3
   GLboolean (*BufferData)( struct gl_context *ctx, GLenum target, GLsizeiptrARB size,
                            const GLvoid *data, GLenum usage,
                            struct gl_buffer_object *obj );
d761 1
a761 1
   void (*BufferSubData)( struct gl_context *ctx, GLenum target, GLintptrARB offset,
d765 1
a765 1
   void (*GetBufferSubData)( struct gl_context *ctx, GLenum target,
d769 1
a769 1
   void * (*MapBuffer)( struct gl_context *ctx, GLenum target, GLenum access,
d772 1
a772 17
   void (*CopyBufferSubData)( struct gl_context *ctx,
                              struct gl_buffer_object *src,
                              struct gl_buffer_object *dst,
                              GLintptr readOffset, GLintptr writeOffset,
                              GLsizeiptr size );

   /* May return NULL if MESA_MAP_NOWAIT_BIT is set in access:
    */
   void * (*MapBufferRange)( struct gl_context *ctx, GLenum target, GLintptr offset,
                             GLsizeiptr length, GLbitfield access,
                             struct gl_buffer_object *obj);

   void (*FlushMappedBufferRange)(struct gl_context *ctx, GLenum target, 
                                  GLintptr offset, GLsizeiptr length,
                                  struct gl_buffer_object *obj);

   GLboolean (*UnmapBuffer)( struct gl_context *ctx, GLenum target,
d775 1
d778 1
a778 1
    * \name Functions for GL_APPLE_object_purgeable
d780 1
d782 5
a786 21
   /* variations on ObjectPurgeable */
   GLenum (*BufferObjectPurgeable)( struct gl_context *ctx, struct gl_buffer_object *obj, GLenum option );
   GLenum (*RenderObjectPurgeable)( struct gl_context *ctx, struct gl_renderbuffer *obj, GLenum option );
   GLenum (*TextureObjectPurgeable)( struct gl_context *ctx, struct gl_texture_object *obj, GLenum option );

   /* variations on ObjectUnpurgeable */
   GLenum (*BufferObjectUnpurgeable)( struct gl_context *ctx, struct gl_buffer_object *obj, GLenum option );
   GLenum (*RenderObjectUnpurgeable)( struct gl_context *ctx, struct gl_renderbuffer *obj, GLenum option );
   GLenum (*TextureObjectUnpurgeable)( struct gl_context *ctx, struct gl_texture_object *obj, GLenum option );
   /*@@}*/

   /**
    * \name Functions for GL_EXT_framebuffer_{object,blit}.
    */
   /*@@{*/
   struct gl_framebuffer * (*NewFramebuffer)(struct gl_context *ctx, GLuint name);
   struct gl_renderbuffer * (*NewRenderbuffer)(struct gl_context *ctx, GLuint name);
   void (*BindFramebuffer)(struct gl_context *ctx, GLenum target,
                           struct gl_framebuffer *drawFb,
                           struct gl_framebuffer *readFb);
   void (*FramebufferRenderbuffer)(struct gl_context *ctx, 
d790 1
a790 1
   void (*RenderTexture)(struct gl_context *ctx,
d793 1
a793 1
   void (*FinishRenderTexture)(struct gl_context *ctx,
a794 2
   void (*ValidateFramebuffer)(struct gl_context *ctx,
                               struct gl_framebuffer *fb);
d796 3
a798 1
   void (*BlitFramebuffer)(struct gl_context *ctx,
d802 1
d808 4
a811 6
   struct gl_query_object * (*NewQueryObject)(struct gl_context *ctx, GLuint id);
   void (*DeleteQuery)(struct gl_context *ctx, struct gl_query_object *q);
   void (*BeginQuery)(struct gl_context *ctx, struct gl_query_object *q);
   void (*EndQuery)(struct gl_context *ctx, struct gl_query_object *q);
   void (*CheckQuery)(struct gl_context *ctx, struct gl_query_object *q);
   void (*WaitQuery)(struct gl_context *ctx, struct gl_query_object *q);
d819 3
a821 3
   struct gl_array_object * (*NewArrayObject)(struct gl_context *ctx, GLuint id);
   void (*DeleteArrayObject)(struct gl_context *ctx, struct gl_array_object *obj);
   void (*BindArrayObject)(struct gl_context *ctx, struct gl_array_object *obj);
d828 46
a873 6
   struct gl_shader *(*NewShader)(struct gl_context *ctx, GLuint name, GLenum type);
   void (*DeleteShader)(struct gl_context *ctx, struct gl_shader *shader);
   struct gl_shader_program *(*NewShaderProgram)(struct gl_context *ctx, GLuint name);
   void (*DeleteShaderProgram)(struct gl_context *ctx,
                               struct gl_shader_program *shProg);
   void (*UseProgram)(struct gl_context *ctx, struct gl_shader_program *shProg);
d899 1
a899 1
   void (*ValidateTnlModule)( struct gl_context *ctx, GLuint new_state );
d902 3
a904 3
#define PRIM_OUTSIDE_BEGIN_END   (GL_POLYGON+1)
#define PRIM_INSIDE_UNKNOWN_PRIM (GL_POLYGON+2)
#define PRIM_UNKNOWN             (GL_POLYGON+3)
d926 1
a926 1
    * between glBegin()/glEnd() objects or __struct gl_contextRec::Current is not
a934 6

   /* Called prior to any of the GLvertexformat functions being
    * called.  Paired with Driver.FlushVertices().
    */
   void (*BeginVertices)( struct gl_context *ctx );

d939 1
a939 1
    * __struct gl_contextRec::Current and gl_light_attrib::Material
d944 2
a945 2
   void (*FlushVertices)( struct gl_context *ctx, GLuint flags );
   void (*SaveFlushVertices)( struct gl_context *ctx );
d952 1
a952 1
   GLboolean (*NotifySaveBegin)( struct gl_context *ctx, GLenum mode );
d958 1
a958 1
   void (*LightingSpaceChange)( struct gl_context *ctx );
d966 1
a966 1
   void (*NewList)( struct gl_context *ctx, GLuint list, GLenum mode );
d972 1
a972 1
   void (*EndList)( struct gl_context *ctx );
d979 2
a980 2
   void (*BeginCallList)( struct gl_context *ctx, 
			  struct gl_display_list *dlist );
d986 1
a986 29
   void (*EndCallList)( struct gl_context *ctx );


   /**
    * \name GL_ARB_sync interfaces
    */
   /*@@{*/
   struct gl_sync_object * (*NewSyncObject)(struct gl_context *, GLenum);
   void (*FenceSync)(struct gl_context *, struct gl_sync_object *, GLenum, GLbitfield);
   void (*DeleteSyncObject)(struct gl_context *, struct gl_sync_object *);
   void (*CheckSync)(struct gl_context *, struct gl_sync_object *);
   void (*ClientWaitSync)(struct gl_context *, struct gl_sync_object *,
			  GLbitfield, GLuint64);
   void (*ServerWaitSync)(struct gl_context *, struct gl_sync_object *,
			  GLbitfield, GLuint64);
   /*@@}*/

   /** GL_NV_conditional_render */
   void (*BeginConditionalRender)(struct gl_context *ctx, struct gl_query_object *q,
                                  GLenum mode);
   void (*EndConditionalRender)(struct gl_context *ctx, struct gl_query_object *q);

   /**
    * \name GL_OES_draw_texture interface
    */
   /*@@{*/
   void (*DrawTex)(struct gl_context *ctx, GLfloat x, GLfloat y, GLfloat z,
                   GLfloat width, GLfloat height);
   /*@@}*/
a987 28
   /**
    * \name GL_OES_EGL_image interface
    */
   void (*EGLImageTargetTexture2D)(struct gl_context *ctx, GLenum target,
				   struct gl_texture_object *texObj,
				   struct gl_texture_image *texImage,
				   GLeglImageOES image_handle);
   void (*EGLImageTargetRenderbufferStorage)(struct gl_context *ctx,
					     struct gl_renderbuffer *rb,
					     void *image_handle);

   /**
    * \name GL_EXT_transform_feedback interface
    */
   struct gl_transform_feedback_object *
        (*NewTransformFeedback)(struct gl_context *ctx, GLuint name);
   void (*DeleteTransformFeedback)(struct gl_context *ctx,
                                   struct gl_transform_feedback_object *obj);
   void (*BeginTransformFeedback)(struct gl_context *ctx, GLenum mode,
                                  struct gl_transform_feedback_object *obj);
   void (*EndTransformFeedback)(struct gl_context *ctx,
                                struct gl_transform_feedback_object *obj);
   void (*PauseTransformFeedback)(struct gl_context *ctx,
                                  struct gl_transform_feedback_object *obj);
   void (*ResumeTransformFeedback)(struct gl_context *ctx,
                                   struct gl_transform_feedback_object *obj);
   void (*DrawTransformFeedback)(struct gl_context *ctx, GLenum mode,
                                 struct gl_transform_feedback_object *obj);
d1001 1
a1001 1
 * the vertexformat to install its own initial values for these
d1014 1
a1014 1
   void (GLAPIENTRYP ArrayElement)( GLint );
d1020 6
a1025 6
   void (GLAPIENTRYP EvalCoord1f)( GLfloat );
   void (GLAPIENTRYP EvalCoord1fv)( const GLfloat * );
   void (GLAPIENTRYP EvalCoord2f)( GLfloat, GLfloat );
   void (GLAPIENTRYP EvalCoord2fv)( const GLfloat * );
   void (GLAPIENTRYP EvalPoint1)( GLint );
   void (GLAPIENTRYP EvalPoint2)( GLint, GLint );
d1030 1
a1030 1
   void (GLAPIENTRYP Materialfv)( GLenum face, GLenum pname, const GLfloat * );
d1057 2
a1058 2
   void (GLAPIENTRYP CallList)( GLuint );
   void (GLAPIENTRYP CallLists)( GLsizei, GLenum, const GLvoid * );
a1060 1
   void (GLAPIENTRYP PrimitiveRestartNV)( void );
d1070 1
a1070 1
   /* GL_ARB_vertex_program */
d1079 1
a1079 18

   /* GL_EXT_gpu_shader4 / GL 3.0 */
   void (GLAPIENTRYP VertexAttribI1i)( GLuint index, GLint x);
   void (GLAPIENTRYP VertexAttribI2i)( GLuint index, GLint x, GLint y);
   void (GLAPIENTRYP VertexAttribI3i)( GLuint index, GLint x, GLint y, GLint z);
   void (GLAPIENTRYP VertexAttribI4i)( GLuint index, GLint x, GLint y, GLint z, GLint w);
   void (GLAPIENTRYP VertexAttribI2iv)( GLuint index, const GLint *v);
   void (GLAPIENTRYP VertexAttribI3iv)( GLuint index, const GLint *v);
   void (GLAPIENTRYP VertexAttribI4iv)( GLuint index, const GLint *v);

   void (GLAPIENTRYP VertexAttribI1ui)( GLuint index, GLuint x);
   void (GLAPIENTRYP VertexAttribI2ui)( GLuint index, GLuint x, GLuint y);
   void (GLAPIENTRYP VertexAttribI3ui)( GLuint index, GLuint x, GLuint y, GLuint z);
   void (GLAPIENTRYP VertexAttribI4ui)( GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
   void (GLAPIENTRYP VertexAttribI2uiv)( GLuint index, const GLuint *v);
   void (GLAPIENTRYP VertexAttribI3uiv)( GLuint index, const GLuint *v);
   void (GLAPIENTRYP VertexAttribI4uiv)( GLuint index, const GLuint *v);

d1082 2
a1095 24
   void (GLAPIENTRYP MultiDrawElementsEXT)( GLenum mode, const GLsizei *count,
					    GLenum type,
					    const GLvoid **indices,
					    GLsizei primcount);
   void (GLAPIENTRYP DrawElementsBaseVertex)( GLenum mode, GLsizei count,
					      GLenum type,
					      const GLvoid *indices,
					      GLint basevertex );
   void (GLAPIENTRYP DrawRangeElementsBaseVertex)( GLenum mode, GLuint start,
						   GLuint end, GLsizei count,
						   GLenum type,
						   const GLvoid *indices,
						   GLint basevertex);
   void (GLAPIENTRYP MultiDrawElementsBaseVertex)( GLenum mode,
						   const GLsizei *count,
						   GLenum type,
						   const GLvoid **indices,
						   GLsizei primcount,
						   const GLint *basevertex);
   void (GLAPIENTRYP DrawArraysInstanced)(GLenum mode, GLint first,
                                          GLsizei count, GLsizei primcount);
   void (GLAPIENTRYP DrawElementsInstanced)(GLenum mode, GLsizei count,
                                            GLenum type, const GLvoid *indices,
                                            GLsizei primcount);
@


1.1.1.5
log
@Import Mesa 9.2.0
@
text
@d8 1
d25 3
a27 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
d96 9
d112 6
d192 5
a196 6
    * Choose actual hardware texture format given the texture target, the
    * user-provided source image format and type and the desired internal
    * format.  In some cases, srcFormat and srcType can be GL_NONE.
    * Note:  target may be GL_TEXTURE_CUBE_MAP, but never
    * GL_TEXTURE_CUBE_MAP_[POSITIVE/NEGATIVE]_[XYZ].
    * Called by glTexImage(), etc.
d198 1
a198 2
   gl_format (*ChooseTextureFormat)( struct gl_context *ctx,
                                     GLenum target, GLint internalFormat,
d202 13
a214 1
    * Determine sample counts support for a particular target and format
d216 35
a250 40
    * \param ctx            GL context
    * \param target         GL target enum
    * \param internalFormat GL format enum
    * \param samples        Buffer to hold the returned sample counts.
    *                       Drivers \b must \b not return more than 16 counts.
    *
    * \returns
    * The number of sample counts actually written to \c samples.  If
    * \c internaFormat is not renderable, zero is returned.
    */
   size_t (*QuerySamplesForFormat)(struct gl_context *ctx,
                                   GLenum target,
                                   GLenum internalFormat,
                                   int samples[16]);

   /**
    * Called by glTexImage[123]D() and glCopyTexImage[12]D()
    * Allocate texture memory and copy the user's image to the buffer.
    * The gl_texture_image fields, etc. will be fully initialized.
    * The parameters are the same as glTexImage3D(), plus:
    * \param dims  1, 2, or 3 indicating glTexImage1/2/3D()
    * \param packing describes how to unpack the source data.
    * \param texImage is the destination texture image.
    */
   void (*TexImage)(struct gl_context *ctx, GLuint dims,
                    struct gl_texture_image *texImage,
                    GLenum format, GLenum type, const GLvoid *pixels,
                    const struct gl_pixelstore_attrib *packing);

   /**
    * Called by glTexSubImage[123]D().
    * Replace a subset of the target texture with new texel data.
    */
   void (*TexSubImage)(struct gl_context *ctx, GLuint dims,
                       struct gl_texture_image *texImage,
                       GLint xoffset, GLint yoffset, GLint zoffset,
                       GLsizei width, GLsizei height, GLint depth,
                       GLenum format, GLenum type,
                       const GLvoid *pixels,
                       const struct gl_pixelstore_attrib *packing);
d252 56
d312 1
a312 1
   void (*GetTexImage)( struct gl_context *ctx,
d314 1
d318 43
a360 14
    * Called by glCopyTex[Sub]Image[123]D().
    *
    * This function should copy a rectangular region in the rb to a single
    * destination slice, specified by @@slice.  In the case of 1D array
    * textures (where one GL call can potentially affect multiple destination
    * slices), core mesa takes care of calling this function multiple times,
    * once for each scanline to be copied.
    */
   void (*CopyTexSubImage)(struct gl_context *ctx, GLuint dims,
                           struct gl_texture_image *texImage,
                           GLint xoffset, GLint yoffset, GLint slice,
                           struct gl_renderbuffer *rb,
                           GLint x, GLint y,
                           GLsizei width, GLsizei height);
d369 4
a372 5
    * Called by glTexImage, glCompressedTexImage, glCopyTexImage
    * and glTexStorage to check if the dimensions of the texture image
    * are too large.
    * \param target  any GL_PROXY_TEXTURE_x target
    * \return GL_TRUE if the image is OK, GL_FALSE if too large
d375 2
a376 1
                                  GLint level, gl_format format,
d388 71
a458 1
    * Called by glCompressedTexImage[123]D().
d460 7
a466 4
   void (*CompressedTexImage)(struct gl_context *ctx, GLuint dims,
                              struct gl_texture_image *texImage,
                              GLsizei imageSize, const GLvoid *data);

d468 3
a470 1
    * Called by glCompressedTexSubImage[123]D().
d472 8
a479 6
   void (*CompressedTexSubImage)(struct gl_context *ctx, GLuint dims,
                                 struct gl_texture_image *texImage,
                                 GLint xoffset, GLint yoffset, GLint zoffset,
                                 GLsizei width, GLint height, GLint depth,
                                 GLenum format,
                                 GLsizei imageSize, const GLvoid *data);
d484 5
a488 3
   void (*GetCompressedTexImage)(struct gl_context *ctx,
                                 struct gl_texture_image *texImage,
                                 GLvoid *data);
d492 1
a492 1
    * \name Texture object / image functions
d503 3
a505 2
    * Called to allocate a new texture object.  Drivers will usually
    * allocate/return a subclass of gl_texture_object.
d507 2
a508 2
   struct gl_texture_object * (*NewTextureObject)(struct gl_context *ctx,
                                                  GLuint name, GLenum target);
d510 4
a513 2
    * Called to delete/free a texture object.  Drivers should free the
    * object and any image data it contains.
d515 1
a515 61
   void (*DeleteTexture)(struct gl_context *ctx,
                         struct gl_texture_object *texObj);

   /** Called to allocate a new texture image object. */
   struct gl_texture_image * (*NewTextureImage)(struct gl_context *ctx);

   /** Called to free a texture image object returned by NewTextureImage() */
   void (*DeleteTextureImage)(struct gl_context *ctx,
                              struct gl_texture_image *);

   /** Called to allocate memory for a single texture image */
   GLboolean (*AllocTextureImageBuffer)(struct gl_context *ctx,
                                        struct gl_texture_image *texImage);

   /** Free the memory for a single texture image */
   void (*FreeTextureImageBuffer)(struct gl_context *ctx,
                                  struct gl_texture_image *texImage);

   /** Map a slice of a texture image into user space.
    * Note: for GL_TEXTURE_1D_ARRAY, height must be 1, y must be 0 and slice
    * indicates the 1D array index.
    * \param texImage  the texture image
    * \param slice  the 3D image slice or array texture slice
    * \param x, y, w, h  region of interest
    * \param mode  bitmask of GL_MAP_READ_BIT, GL_MAP_WRITE_BIT and
    *              GL_MAP_INVALIDATE_RANGE_BIT (if writing)
    * \param mapOut  returns start of mapping of region of interest
    * \param rowStrideOut returns row stride (in bytes).  In the case of a
    * compressed texture, this is the byte stride between one row of blocks
    * and another.
    */
   void (*MapTextureImage)(struct gl_context *ctx,
			   struct gl_texture_image *texImage,
			   GLuint slice,
			   GLuint x, GLuint y, GLuint w, GLuint h,
			   GLbitfield mode,
			   GLubyte **mapOut, GLint *rowStrideOut);

   void (*UnmapTextureImage)(struct gl_context *ctx,
			     struct gl_texture_image *texImage,
			     GLuint slice);

   /** For GL_ARB_texture_storage.  Allocate memory for whole mipmap stack.
    * All the gl_texture_images in the texture object will have their
    * dimensions, format, etc. initialized already.
    */
   GLboolean (*AllocTextureStorage)(struct gl_context *ctx,
                                    struct gl_texture_object *texObj,
                                    GLsizei levels, GLsizei width,
                                    GLsizei height, GLsizei depth);

   /**
    * Map a renderbuffer into user space.
    * \param mode  bitmask of GL_MAP_READ_BIT, GL_MAP_WRITE_BIT and
    *              GL_MAP_INVALIDATE_RANGE_BIT (if writing)
    */
   void (*MapRenderbuffer)(struct gl_context *ctx,
			   struct gl_renderbuffer *rb,
			   GLuint x, GLuint y, GLuint w, GLuint h,
			   GLbitfield mode,
			   GLubyte **mapOut, GLint *rowStrideOut);
d517 4
a520 2
   void (*UnmapRenderbuffer)(struct gl_context *ctx,
			     struct gl_renderbuffer *rb);
d522 51
a593 7
   /**
    * Notify driver that the sampler uniforms for the current program have
    * changed.  On some drivers, this may require shader recompiles.
    */
   void (*SamplerUniformChange)(struct gl_context *ctx, GLenum target,
                                struct gl_program *prog);

d605 9
a637 2
   void (*BlendEquationSeparatei)(struct gl_context *ctx, GLuint buffer,
                                  GLenum modeRGB, GLenum modeA);
d642 6
a647 3
   void (*BlendFuncSeparatei)(struct gl_context *ctx, GLuint buffer,
                              GLenum sfactorRGB, GLenum dfactorRGB,
                              GLenum sfactorA, GLenum dfactorA);
d748 1
a748 1
   void (*BufferSubData)( struct gl_context *ctx, GLintptrARB offset,
d752 1
a752 1
   void (*GetBufferSubData)( struct gl_context *ctx,
d756 3
d767 1
a767 1
   void * (*MapBufferRange)( struct gl_context *ctx, GLintptr offset,
d771 1
a771 1
   void (*FlushMappedBufferRange)(struct gl_context *ctx,
d775 1
a775 1
   GLboolean (*UnmapBuffer)( struct gl_context *ctx,
d795 1
a795 1
    * \name Functions for GL_EXT_framebuffer_{object,blit,discard}.
d811 1
a811 1
                               struct gl_renderbuffer *rb);
a818 2
   void (*DiscardFramebuffer)(struct gl_context *ctx,
                              GLenum target, GLsizei numAttachments, const GLenum *attachments);
a826 1
   void (*QueryCounter)(struct gl_context *ctx, struct gl_query_object *q);
d861 24
d892 4
a895 3
    * Current glBegin state of an in-progress compilation.  May be
    * GL_POINTS, GL_TRIANGLE_STRIP, etc. or PRIM_OUTSIDE_BEGIN_END
    * or PRIM_UNKNOWN.
d904 2
a905 2
    * between glBegin()/glEnd() objects or __struct gl_contextRec::Current
    * is not updated.  A bitmask of the FLUSH_x values above.
d910 2
a911 1
   GLbitfield NeedFlush;
a912 2
   /** Need to call SaveFlushVertices() upon state change? */
   GLboolean SaveNeedFlush;
a971 1
   /**@@}*/
d1026 2
a1027 27

   /**
    * \name GL_NV_texture_barrier interface
    */
   void (*TextureBarrier)(struct gl_context *ctx);

   /**
    * \name GL_ARB_sampler_objects
    */
   struct gl_sampler_object * (*NewSamplerObject)(struct gl_context *ctx,
                                                  GLuint name);
   void (*DeleteSamplerObject)(struct gl_context *ctx,
                               struct gl_sampler_object *samp);

   /**
    * \name Return a timestamp in nanoseconds as defined by GL_ARB_timer_query.
    * This should be equivalent to glGetInteger64v(GL_TIMESTAMP);
    */
   uint64_t (*GetTimestamp)(struct gl_context *ctx);

   /**
    * \name GL_ARB_texture_multisample
    */
   void (*GetSamplePosition)(struct gl_context *ctx,
                             struct gl_framebuffer *fb,
                             GLuint index,
                             GLfloat *outValue);
d1032 1
a1032 1
 * Per-vertex functions.
d1034 3
a1036 5
 * These are the functions which can appear between glBegin and glEnd.
 * Depending on whether we're inside or outside a glBegin/End pair
 * and whether we're in immediate mode or building a display list, these
 * functions behave differently.  This structure allows us to switch
 * between those modes more easily.
d1038 10
a1047 1
 * Generally, these pointers point to functions in the VBO module.
d1050 4
d1102 1
a1102 1
   /* Originally for GL_NV_vertex_program, now used only dlist.c and friends */
d1138 55
a1192 63
   /* GL_ARB_vertex_type_10_10_10_2_rev / GL3.3 */
   void (GLAPIENTRYP VertexP2ui)( GLenum type, GLuint value );
   void (GLAPIENTRYP VertexP2uiv)( GLenum type, const GLuint *value);

   void (GLAPIENTRYP VertexP3ui)( GLenum type, GLuint value );
   void (GLAPIENTRYP VertexP3uiv)( GLenum type, const GLuint *value);

   void (GLAPIENTRYP VertexP4ui)( GLenum type, GLuint value );
   void (GLAPIENTRYP VertexP4uiv)( GLenum type, const GLuint *value);

   void (GLAPIENTRYP TexCoordP1ui)( GLenum type, GLuint coords );
   void (GLAPIENTRYP TexCoordP1uiv)( GLenum type, const GLuint *coords );

   void (GLAPIENTRYP TexCoordP2ui)( GLenum type, GLuint coords );
   void (GLAPIENTRYP TexCoordP2uiv)( GLenum type, const GLuint *coords );

   void (GLAPIENTRYP TexCoordP3ui)( GLenum type, GLuint coords );
   void (GLAPIENTRYP TexCoordP3uiv)( GLenum type, const GLuint *coords );

   void (GLAPIENTRYP TexCoordP4ui)( GLenum type, GLuint coords );
   void (GLAPIENTRYP TexCoordP4uiv)( GLenum type, const GLuint *coords );

   void (GLAPIENTRYP MultiTexCoordP1ui)( GLenum texture, GLenum type, GLuint coords );
   void (GLAPIENTRYP MultiTexCoordP1uiv)( GLenum texture, GLenum type, const GLuint *coords );
   void (GLAPIENTRYP MultiTexCoordP2ui)( GLenum texture, GLenum type, GLuint coords );
   void (GLAPIENTRYP MultiTexCoordP2uiv)( GLenum texture, GLenum type, const GLuint *coords );
   void (GLAPIENTRYP MultiTexCoordP3ui)( GLenum texture, GLenum type, GLuint coords );
   void (GLAPIENTRYP MultiTexCoordP3uiv)( GLenum texture, GLenum type, const GLuint *coords );
   void (GLAPIENTRYP MultiTexCoordP4ui)( GLenum texture, GLenum type, GLuint coords );
   void (GLAPIENTRYP MultiTexCoordP4uiv)( GLenum texture, GLenum type, const GLuint *coords );

   void (GLAPIENTRYP NormalP3ui)( GLenum type, GLuint coords );
   void (GLAPIENTRYP NormalP3uiv)( GLenum type, const GLuint *coords );

   void (GLAPIENTRYP ColorP3ui)( GLenum type, GLuint color );
   void (GLAPIENTRYP ColorP3uiv)( GLenum type, const GLuint *color );

   void (GLAPIENTRYP ColorP4ui)( GLenum type, GLuint color );
   void (GLAPIENTRYP ColorP4uiv)( GLenum type, const GLuint *color );

   void (GLAPIENTRYP SecondaryColorP3ui)( GLenum type, GLuint color );
   void (GLAPIENTRYP SecondaryColorP3uiv)( GLenum type, const GLuint *color );

   void (GLAPIENTRYP VertexAttribP1ui)( GLuint index, GLenum type,
					GLboolean normalized, GLuint value);
   void (GLAPIENTRYP VertexAttribP2ui)( GLuint index, GLenum type,
					GLboolean normalized, GLuint value);
   void (GLAPIENTRYP VertexAttribP3ui)( GLuint index, GLenum type,
					GLboolean normalized, GLuint value);
   void (GLAPIENTRYP VertexAttribP4ui)( GLuint index, GLenum type,
					GLboolean normalized, GLuint value);
   void (GLAPIENTRYP VertexAttribP1uiv)( GLuint index, GLenum type,
					GLboolean normalized,
					 const GLuint *value);
   void (GLAPIENTRYP VertexAttribP2uiv)( GLuint index, GLenum type,
					GLboolean normalized,
					 const GLuint *value);
   void (GLAPIENTRYP VertexAttribP3uiv)( GLuint index, GLenum type,
					GLboolean normalized,
					 const GLuint *value);
   void (GLAPIENTRYP VertexAttribP4uiv)( GLuint index, GLenum type,
					 GLboolean normalized,
					 const GLuint *value);
@


1.1.1.6
log
@Import Mesa 10.2.3
@
text
@a41 1
struct gl_image_unit;
d184 3
a186 3
   mesa_format (*ChooseTextureFormat)(struct gl_context *ctx,
                                      GLenum target, GLint internalFormat,
                                      GLenum srcFormat, GLenum srcType );
a257 4
    * Note that if the texture is a cube map, the <target> parameter will
    * indicate which cube face to generate (GL_POSITIVE/NEGATIVE_X/Y/Z).
    * texObj->BaseLevel is the level from which to generate the remaining
    * mipmap levels.
d270 1
a270 1
                                  GLint level, mesa_format format,
d312 1
a312 1
    * Called by glBindTexture() and glBindTextures().
d314 2
a315 2
   void (*BindTexture)( struct gl_context *ctx, GLuint texUnit,
                        GLenum target, struct gl_texture_object *tObj );
a377 5
   /** Called as part of glTextureView to add views to origTexObj */
   GLboolean (*TextureView)(struct gl_context *ctx,
                            struct gl_texture_object *texObj,
                            struct gl_texture_object *origTexObj);

a391 7
   /**
    * Optional driver entrypoint that binds a non-texture renderbuffer's
    * contents to a texture image.
    */
   GLboolean (*BindRenderbufferTexImage)(struct gl_context *ctx,
                                         struct gl_renderbuffer *rb,
                                         struct gl_texture_image *texImage);
d400 1
a400 2
   void (*BindProgram)(struct gl_context *ctx, GLenum target,
                       struct gl_program *prog);
d402 1
a402 2
   struct gl_program * (*NewProgram)(struct gl_context *ctx, GLenum target,
                                     GLuint id);
d436 1
a436 2
   GLboolean (*LinkShader)(struct gl_context *ctx,
                           struct gl_shader_program *shader);
d454 1
a454 2
   void (*BlendEquationSeparate)(struct gl_context *ctx,
                                 GLenum modeRGB, GLenum modeA);
d465 1
a465 1
   void (*ClipPlane)(struct gl_context *ctx, GLenum plane, const GLfloat *eq);
d482 1
a482 1
   void (*DepthRange)(struct gl_context *ctx);
d486 1
a486 1
   void (*DrawBuffers)(struct gl_context *ctx, GLsizei n, const GLenum *buffers);
d500 1
a500 2
   void (*LightModelfv)(struct gl_context *ctx, GLenum pname,
                        const GLfloat *params);
d522 1
a522 1
   void (*Scissor)(struct gl_context *ctx);
d540 1
a540 1
   void (*TexParameter)(struct gl_context *ctx,
d544 1
a544 1
   void (*Viewport)(struct gl_context *ctx);
d552 5
a556 2
   struct gl_buffer_object * (*NewBufferObject)(struct gl_context *ctx,
                                                GLuint buffer, GLenum target);
d560 3
a562 3
   GLboolean (*BufferData)(struct gl_context *ctx, GLenum target,
                           GLsizeiptrARB size, const GLvoid *data, GLenum usage,
                           GLenum storageFlags, struct gl_buffer_object *obj);
a571 6
   void (*ClearBufferSubData)( struct gl_context *ctx,
                               GLintptr offset, GLsizeiptr size,
                               const GLvoid *clearValue,
                               GLsizeiptr clearValueSize,
                               struct gl_buffer_object *obj );

d578 1
a578 2
   /* Returns pointer to the start of the mapped range.
    * May return NULL if MESA_MAP_NOWAIT_BIT is set in access:
d582 1
a582 2
                             struct gl_buffer_object *obj,
                             gl_map_buffer_index index);
d586 1
a586 2
                                  struct gl_buffer_object *obj,
                                  gl_map_buffer_index index);
d589 1
a589 2
			     struct gl_buffer_object *obj,
                             gl_map_buffer_index index);
d597 3
a599 7
   GLenum (*BufferObjectPurgeable)(struct gl_context *ctx,
                                   struct gl_buffer_object *obj, GLenum option);
   GLenum (*RenderObjectPurgeable)(struct gl_context *ctx,
                                   struct gl_renderbuffer *obj, GLenum option);
   GLenum (*TextureObjectPurgeable)(struct gl_context *ctx,
                                    struct gl_texture_object *obj,
                                    GLenum option);
d602 3
a604 9
   GLenum (*BufferObjectUnpurgeable)(struct gl_context *ctx,
                                     struct gl_buffer_object *obj,
                                     GLenum option);
   GLenum (*RenderObjectUnpurgeable)(struct gl_context *ctx,
                                     struct gl_renderbuffer *obj,
                                     GLenum option);
   GLenum (*TextureObjectUnpurgeable)(struct gl_context *ctx,
                                      struct gl_texture_object *obj,
                                      GLenum option);
d611 2
a612 4
   struct gl_framebuffer * (*NewFramebuffer)(struct gl_context *ctx,
                                             GLuint name);
   struct gl_renderbuffer * (*NewRenderbuffer)(struct gl_context *ctx,
                                               GLuint name);
d633 1
a633 2
                              GLenum target, GLsizei numAttachments,
                              const GLenum *attachments);
a647 24
   /**
    * \name Performance monitors
    */
   /*@@{*/
   struct gl_perf_monitor_object * (*NewPerfMonitor)(struct gl_context *ctx);
   void (*DeletePerfMonitor)(struct gl_context *ctx,
                             struct gl_perf_monitor_object *m);
   GLboolean (*BeginPerfMonitor)(struct gl_context *ctx,
                                 struct gl_perf_monitor_object *m);

   /** Stop an active performance monitor, discarding results. */
   void (*ResetPerfMonitor)(struct gl_context *ctx,
                            struct gl_perf_monitor_object *m);
   void (*EndPerfMonitor)(struct gl_context *ctx,
                          struct gl_perf_monitor_object *m);
   GLboolean (*IsPerfMonitorResultAvailable)(struct gl_context *ctx,
                                             struct gl_perf_monitor_object *m);
   void (*GetPerfMonitorResult)(struct gl_context *ctx,
                                struct gl_perf_monitor_object *m,
                                GLsizei dataSize,
                                GLuint *data,
                                GLint *bytesWritten);
   /*@@}*/

d653 3
a655 3
   struct gl_vertex_array_object * (*NewArrayObject)(struct gl_context *ctx, GLuint id);
   void (*DeleteArrayObject)(struct gl_context *ctx, struct gl_vertex_array_object *);
   void (*BindArrayObject)(struct gl_context *ctx, struct gl_vertex_array_object *);
d662 1
a662 2
   struct gl_shader *(*NewShader)(struct gl_context *ctx,
                                  GLuint name, GLenum type);
d664 1
a664 2
   struct gl_shader_program *(*NewShaderProgram)(struct gl_context *ctx,
                                                 GLuint name);
d771 1
a771 2
   void (*FenceSync)(struct gl_context *, struct gl_sync_object *,
                     GLenum, GLbitfield);
d781 1
a781 2
   void (*BeginConditionalRender)(struct gl_context *ctx,
                                  struct gl_query_object *q,
d783 1
a783 2
   void (*EndConditionalRender)(struct gl_context *ctx,
                                struct gl_query_object *q);
a820 8
    * Return the number of vertices written to a stream during the last
    * Begin/EndTransformFeedback block.
    */
   GLsizei (*GetTransformFeedbackVertexCount)(struct gl_context *ctx,
                                       struct gl_transform_feedback_object *obj,
                                       GLuint stream);

   /**
a845 36

   /**
    * \name NV_vdpau_interop interface
    */
   void (*VDPAUMapSurface)(struct gl_context *ctx, GLenum target,
                           GLenum access, GLboolean output,
                           struct gl_texture_object *texObj,
                           struct gl_texture_image *texImage,
                           const GLvoid *vdpSurface, GLuint index);
   void (*VDPAUUnmapSurface)(struct gl_context *ctx, GLenum target,
                             GLenum access, GLboolean output,
                             struct gl_texture_object *texObj,
                             struct gl_texture_image *texImage,
                             const GLvoid *vdpSurface, GLuint index);

   /**
    * Query reset status for GL_ARB_robustness
    *
    * Per \c glGetGraphicsResetStatusARB, this function should return a
    * non-zero value once after a reset.  If a reset is non-atomic, the
    * non-zero status should be returned for the duration of the reset.
    */
   GLenum (*GetGraphicsResetStatus)(struct gl_context *ctx);

   /**
    * \name GL_ARB_shader_image_load_store interface.
    */
   /** @@{ */
   void (*BindImageTexture)(struct gl_context *ctx,
                            struct gl_image_unit *unit,
                            struct gl_texture_object *texObj,
                            GLint level, GLboolean layered, GLint layer,
                            GLenum access, GLenum format);

   void (*MemoryBarrier)(struct gl_context *ctx, GLbitfield barriers);
   /** @@} */
@


1.1.1.7
log
@Import Mesa 10.4.3
@
text
@a241 14
    * Called by glClearTex[Sub]Image
    *
    * Clears a rectangular region of the image to a given value. The
    * clearValue argument is either NULL or points to a single texel to use as
    * the clear value in the same internal format as the texture image. If it
    * is NULL then the texture should be cleared to zeroes.
    */
   void (*ClearTexSubImage)(struct gl_context *ctx,
                            struct gl_texture_image *texImage,
                            GLint xoffset, GLint yoffset, GLint zoffset,
                            GLsizei width, GLsizei height, GLsizei depth,
                            const GLvoid *clearValue);

   /**
a257 16
    * Called by glCopyImageSubData().
    *
    * This function should copy one 2-D slice from srcTexImage to
    * dstTexImage.  If one of the textures is 3-D or is a 1-D or 2-D array
    * texture, this function will be called multiple times: once for each
    * slice.  If one of the textures is a cube map, this function will be
    * called once for each face to be copied.
    */
   void (*CopyImageSubData)(struct gl_context *ctx,
                            struct gl_texture_image *src_image,
                            int src_x, int src_y, int src_z,
                            struct gl_texture_image *dstTexImage,
                            int dst_x, int dst_y, int dst_z,
                            int src_width, int src_height);

   /**
d575 1
a575 1
                                                GLuint buffer);
d731 2
a732 1
   struct gl_shader_program *(*NewShaderProgram)(GLuint name);
@


1.1.1.8
log
@Import Mesa 10.2.9
@
text
@d242 14
d272 16
d605 1
a605 1
                                                GLuint buffer, GLenum target);
d761 1
a761 2
   struct gl_shader_program *(*NewShaderProgram)(struct gl_context *ctx,
                                                 GLuint name);
@


