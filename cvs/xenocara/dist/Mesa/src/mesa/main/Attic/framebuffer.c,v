head	1.12;
access;
symbols
	OPENBSD_5_8:1.11.0.6
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.4
	OPENBSD_5_7_BASE:1.11
	v10_2_9:1.1.1.6
	v10_4_3:1.1.1.6
	v10_2_7:1.1.1.6
	OPENBSD_5_6:1.11.0.2
	OPENBSD_5_6_BASE:1.11
	v10_2_3:1.1.1.6
	OPENBSD_5_5:1.10.0.2
	OPENBSD_5_5_BASE:1.10
	v9_2_5:1.1.1.5
	v9_2_3:1.1.1.5
	v9_2_2:1.1.1.5
	v9_2_1:1.1.1.5
	v9_2_0:1.1.1.5
	OPENBSD_5_4:1.9.0.4
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.2
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.8.0.4
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.7.0.6
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.2
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.4
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.6.0.4
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.2
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.5.0.2
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.4.0.4
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_3:1.4.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.2.0.2
	OPENBSD_4_2_BASE:1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2015.12.23.05.17.52;	author jsg;	state dead;
branches;
next	1.11;
commitid	TnlogFl9nOv2eaRf;

1.11
date	2014.07.09.21.09.00;	author jsg;	state Exp;
branches;
next	1.10;
commitid	WPD6rgPryPkvXOr9;

1.10
date	2013.09.05.14.06.22;	author jsg;	state Exp;
branches;
next	1.9;

1.9
date	2012.08.17.13.58.19;	author mpi;	state Exp;
branches;
next	1.8;

1.8
date	2011.10.23.13.37.42;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2010.05.22.20.06.30;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2009.05.17.20.26.41;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2008.11.02.14.58.21;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2008.02.12.21.09.27;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2007.11.24.17.41.37;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2007.04.19.08.12.55;	author aanriot;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.50.01;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.50.01;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.56.35;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.31.04;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.46;	author matthieu;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.09.05.13.16.38;	author jsg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.07.09.20.35.01;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.12
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2008  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */


/**
 * Functions for allocating/managing framebuffers and renderbuffers.
 * Also, routines for reading/writing renderbuffer data as ubytes,
 * ushorts, uints, etc.
 */


#include "glheader.h"
#include "imports.h"
#include "blend.h"
#include "buffers.h"
#include "context.h"
#include "enums.h"
#include "formats.h"
#include "macros.h"
#include "mtypes.h"
#include "fbobject.h"
#include "framebuffer.h"
#include "renderbuffer.h"
#include "texobj.h"
#include "glformats.h"



/**
 * Compute/set the _DepthMax field for the given framebuffer.
 * This value depends on the Z buffer resolution.
 */
static void
compute_depth_max(struct gl_framebuffer *fb)
{
   if (fb->Visual.depthBits == 0) {
      /* Special case.  Even if we don't have a depth buffer we need
       * good values for DepthMax for Z vertex transformation purposes
       * and for per-fragment fog computation.
       */
      fb->_DepthMax = (1 << 16) - 1;
   }
   else if (fb->Visual.depthBits < 32) {
      fb->_DepthMax = (1 << fb->Visual.depthBits) - 1;
   }
   else {
      /* Special case since shift values greater than or equal to the
       * number of bits in the left hand expression's type are undefined.
       */
      fb->_DepthMax = 0xffffffff;
   }
   fb->_DepthMaxF = (GLfloat) fb->_DepthMax;

   /* Minimum resolvable depth value, for polygon offset */
   fb->_MRD = (GLfloat)1.0 / fb->_DepthMaxF;
}

/**
 * Create and initialize a gl_framebuffer object.
 * This is intended for creating _window_system_ framebuffers, not generic
 * framebuffer objects ala GL_EXT_framebuffer_object.
 *
 * \sa _mesa_new_framebuffer
 */
struct gl_framebuffer *
_mesa_create_framebuffer(const struct gl_config *visual)
{
   struct gl_framebuffer *fb = CALLOC_STRUCT(gl_framebuffer);
   assert(visual);
   if (fb) {
      _mesa_initialize_window_framebuffer(fb, visual);
   }
   return fb;
}


/**
 * Allocate a new gl_framebuffer object.
 * This is the default function for ctx->Driver.NewFramebuffer().
 * This is for allocating user-created framebuffers, not window-system
 * framebuffers!
 * \sa _mesa_create_framebuffer
 */
struct gl_framebuffer *
_mesa_new_framebuffer(struct gl_context *ctx, GLuint name)
{
   struct gl_framebuffer *fb;
   (void) ctx;
   assert(name != 0);
   fb = CALLOC_STRUCT(gl_framebuffer);
   if (fb) {
      _mesa_initialize_user_framebuffer(fb, name);
   }
   return fb;
}


/**
 * Initialize a gl_framebuffer object.  Typically used to initialize
 * window system-created framebuffers, not user-created framebuffers.
 * \sa _mesa_initialize_user_framebuffer
 */
void
_mesa_initialize_window_framebuffer(struct gl_framebuffer *fb,
				     const struct gl_config *visual)
{
   assert(fb);
   assert(visual);

   memset(fb, 0, sizeof(struct gl_framebuffer));

   mtx_init(&fb->Mutex, mtx_plain);

   fb->RefCount = 1;

   /* save the visual */
   fb->Visual = *visual;

   /* Init read/draw renderbuffer state */
   if (visual->doubleBufferMode) {
      fb->_NumColorDrawBuffers = 1;
      fb->ColorDrawBuffer[0] = GL_BACK;
      fb->_ColorDrawBufferIndexes[0] = BUFFER_BACK_LEFT;
      fb->ColorReadBuffer = GL_BACK;
      fb->_ColorReadBufferIndex = BUFFER_BACK_LEFT;
   }
   else {
      fb->_NumColorDrawBuffers = 1;
      fb->ColorDrawBuffer[0] = GL_FRONT;
      fb->_ColorDrawBufferIndexes[0] = BUFFER_FRONT_LEFT;
      fb->ColorReadBuffer = GL_FRONT;
      fb->_ColorReadBufferIndex = BUFFER_FRONT_LEFT;
   }

   fb->Delete = _mesa_destroy_framebuffer;
   fb->_Status = GL_FRAMEBUFFER_COMPLETE_EXT;
   fb->_AllColorBuffersFixedPoint = !visual->floatMode;
   fb->_HasSNormOrFloatColorBuffer = visual->floatMode;

   compute_depth_max(fb);
}


/**
 * Initialize a user-created gl_framebuffer object.
 * \sa _mesa_initialize_window_framebuffer
 */
void
_mesa_initialize_user_framebuffer(struct gl_framebuffer *fb, GLuint name)
{
   assert(fb);
   assert(name);

   memset(fb, 0, sizeof(struct gl_framebuffer));

   fb->Name = name;
   fb->RefCount = 1;
   fb->_NumColorDrawBuffers = 1;
   fb->ColorDrawBuffer[0] = GL_COLOR_ATTACHMENT0_EXT;
   fb->_ColorDrawBufferIndexes[0] = BUFFER_COLOR0;
   fb->ColorReadBuffer = GL_COLOR_ATTACHMENT0_EXT;
   fb->_ColorReadBufferIndex = BUFFER_COLOR0;
   fb->Delete = _mesa_destroy_framebuffer;
   mtx_init(&fb->Mutex, mtx_plain);
}


/**
 * Deallocate buffer and everything attached to it.
 * Typically called via the gl_framebuffer->Delete() method.
 */
void
_mesa_destroy_framebuffer(struct gl_framebuffer *fb)
{
   if (fb) {
      _mesa_free_framebuffer_data(fb);
      free(fb->Label);
      free(fb);
   }
}


/**
 * Free all the data hanging off the given gl_framebuffer, but don't free
 * the gl_framebuffer object itself.
 */
void
_mesa_free_framebuffer_data(struct gl_framebuffer *fb)
{
   GLuint i;

   assert(fb);
   assert(fb->RefCount == 0);

   mtx_destroy(&fb->Mutex);

   for (i = 0; i < BUFFER_COUNT; i++) {
      struct gl_renderbuffer_attachment *att = &fb->Attachment[i];
      if (att->Renderbuffer) {
         _mesa_reference_renderbuffer(&att->Renderbuffer, NULL);
      }
      if (att->Texture) {
         _mesa_reference_texobj(&att->Texture, NULL);
      }
      ASSERT(!att->Renderbuffer);
      ASSERT(!att->Texture);
      att->Type = GL_NONE;
   }
}


/**
 * Set *ptr to point to fb, with refcounting and locking.
 * This is normally only called from the _mesa_reference_framebuffer() macro
 * when there's a real pointer change.
 */
void
_mesa_reference_framebuffer_(struct gl_framebuffer **ptr,
                             struct gl_framebuffer *fb)
{
   if (*ptr) {
      /* unreference old renderbuffer */
      GLboolean deleteFlag = GL_FALSE;
      struct gl_framebuffer *oldFb = *ptr;

      mtx_lock(&oldFb->Mutex);
      ASSERT(oldFb->RefCount > 0);
      oldFb->RefCount--;
      deleteFlag = (oldFb->RefCount == 0);
      mtx_unlock(&oldFb->Mutex);
      
      if (deleteFlag)
         oldFb->Delete(oldFb);

      *ptr = NULL;
   }
   assert(!*ptr);

   if (fb) {
      mtx_lock(&fb->Mutex);
      fb->RefCount++;
      mtx_unlock(&fb->Mutex);
      *ptr = fb;
   }
}


/**
 * Resize the given framebuffer's renderbuffers to the new width and height.
 * This should only be used for window-system framebuffers, not
 * user-created renderbuffers (i.e. made with GL_EXT_framebuffer_object).
 * This will typically be called via ctx->Driver.ResizeBuffers() or directly
 * from a device driver.
 *
 * \note it's possible for ctx to be null since a window can be resized
 * without a currently bound rendering context.
 */
void
_mesa_resize_framebuffer(struct gl_context *ctx, struct gl_framebuffer *fb,
                         GLuint width, GLuint height)
{
   GLuint i;

   /* XXX I think we could check if the size is not changing
    * and return early.
    */

   /* Can only resize win-sys framebuffer objects */
   assert(_mesa_is_winsys_fbo(fb));

   for (i = 0; i < BUFFER_COUNT; i++) {
      struct gl_renderbuffer_attachment *att = &fb->Attachment[i];
      if (att->Type == GL_RENDERBUFFER_EXT && att->Renderbuffer) {
         struct gl_renderbuffer *rb = att->Renderbuffer;
         /* only resize if size is changing */
         if (rb->Width != width || rb->Height != height) {
            if (rb->AllocStorage(ctx, rb, rb->InternalFormat, width, height)) {
               ASSERT(rb->Width == width);
               ASSERT(rb->Height == height);
            }
            else {
               _mesa_error(ctx, GL_OUT_OF_MEMORY, "Resizing framebuffer");
               /* no return */
            }
         }
      }
   }

   fb->Width = width;
   fb->Height = height;

   if (ctx) {
      /* update scissor / window bounds */
      _mesa_update_draw_buffer_bounds(ctx);
      /* Signal new buffer state so that swrast will update its clipping
       * info (the CLIP_BIT flag).
       */
      ctx->NewState |= _NEW_BUFFERS;
   }
}

/**
 * Examine all the framebuffer's renderbuffers to update the Width/Height
 * fields of the framebuffer.  If we have renderbuffers with different
 * sizes, set the framebuffer's width and height to the min size.
 * Note: this is only intended for user-created framebuffers, not
 * window-system framebuffes.
 */
static void
update_framebuffer_size(struct gl_context *ctx, struct gl_framebuffer *fb)
{
   GLuint minWidth = ~0, minHeight = ~0;
   GLuint i;

   /* user-created framebuffers only */
   assert(_mesa_is_user_fbo(fb));

   for (i = 0; i < BUFFER_COUNT; i++) {
      struct gl_renderbuffer_attachment *att = &fb->Attachment[i];
      const struct gl_renderbuffer *rb = att->Renderbuffer;
      if (rb) {
         minWidth = MIN2(minWidth, rb->Width);
         minHeight = MIN2(minHeight, rb->Height);
      }
   }

   if (minWidth != ~0) {
      fb->Width = minWidth;
      fb->Height = minHeight;
   }
   else {
      fb->Width = 0;
      fb->Height = 0;
   }
}


/**
 * Calculate the inclusive bounding box for the scissor of a specific viewport
 *
 * \param ctx     GL context.
 * \param buffer  Framebuffer to be checked against
 * \param idx     Index of the desired viewport
 * \param bbox    Bounding box for the scissored viewport.  Stored as xmin,
 *                xmax, ymin, ymax.
 *
 * \warning This function assumes that the framebuffer dimensions are up to
 * date (e.g., update_framebuffer_size has been recently called on \c buffer).
 *
 * \sa _mesa_clip_to_region
 */
void
_mesa_scissor_bounding_box(const struct gl_context *ctx,
                           const struct gl_framebuffer *buffer,
                           unsigned idx, int *bbox)
{
   bbox[0] = 0;
   bbox[2] = 0;
   bbox[1] = buffer->Width;
   bbox[3] = buffer->Height;

   if (ctx->Scissor.EnableFlags & (1u << idx)) {
      if (ctx->Scissor.ScissorArray[idx].X > bbox[0]) {
         bbox[0] = ctx->Scissor.ScissorArray[idx].X;
      }
      if (ctx->Scissor.ScissorArray[idx].Y > bbox[2]) {
         bbox[2] = ctx->Scissor.ScissorArray[idx].Y;
      }
      if (ctx->Scissor.ScissorArray[idx].X + ctx->Scissor.ScissorArray[idx].Width < bbox[1]) {
         bbox[1] = ctx->Scissor.ScissorArray[idx].X + ctx->Scissor.ScissorArray[idx].Width;
      }
      if (ctx->Scissor.ScissorArray[idx].Y + ctx->Scissor.ScissorArray[idx].Height < bbox[3]) {
         bbox[3] = ctx->Scissor.ScissorArray[idx].Y + ctx->Scissor.ScissorArray[idx].Height;
      }
      /* finally, check for empty region */
      if (bbox[0] > bbox[1]) {
         bbox[0] = bbox[1];
      }
      if (bbox[2] > bbox[3]) {
         bbox[2] = bbox[3];
      }
   }

   ASSERT(bbox[0] <= bbox[1]);
   ASSERT(bbox[2] <= bbox[3]);
}

/**
 * Update the context's current drawing buffer's Xmin, Xmax, Ymin, Ymax fields.
 * These values are computed from the buffer's width and height and
 * the scissor box, if it's enabled.
 * \param ctx  the GL context.
 */
void
_mesa_update_draw_buffer_bounds(struct gl_context *ctx)
{
   struct gl_framebuffer *buffer = ctx->DrawBuffer;
   int bbox[4];

   if (!buffer)
      return;

   if (_mesa_is_user_fbo(buffer)) {
      /* user-created framebuffer size depends on the renderbuffers */
      update_framebuffer_size(ctx, buffer);
   }

   /* Default to the first scissor as that's always valid */
   _mesa_scissor_bounding_box(ctx, buffer, 0, bbox);
   buffer->_Xmin = bbox[0];
   buffer->_Ymin = bbox[2];
   buffer->_Xmax = bbox[1];
   buffer->_Ymax = bbox[3];
}


/**
 * The glGet queries of the framebuffer red/green/blue size, stencil size,
 * etc. are satisfied by the fields of ctx->DrawBuffer->Visual.  These can
 * change depending on the renderbuffer bindings.  This function updates
 * the given framebuffer's Visual from the current renderbuffer bindings.
 *
 * This may apply to user-created framebuffers or window system framebuffers.
 *
 * Also note: ctx->DrawBuffer->Visual.depthBits might not equal
 * ctx->DrawBuffer->Attachment[BUFFER_DEPTH].Renderbuffer.DepthBits.
 * The former one is used to convert floating point depth values into
 * integer Z values.
 */
void
_mesa_update_framebuffer_visual(struct gl_context *ctx,
				struct gl_framebuffer *fb)
{
   GLuint i;

   memset(&fb->Visual, 0, sizeof(fb->Visual));
   fb->Visual.rgbMode = GL_TRUE; /* assume this */

#if 0 /* this _might_ be needed */
   if (fb->_Status != GL_FRAMEBUFFER_COMPLETE_EXT) {
      /* leave visual fields zero'd */
      return;
   }
#endif

   /* find first RGB renderbuffer */
   for (i = 0; i < BUFFER_COUNT; i++) {
      if (fb->Attachment[i].Renderbuffer) {
         const struct gl_renderbuffer *rb = fb->Attachment[i].Renderbuffer;
         const GLenum baseFormat = _mesa_get_format_base_format(rb->Format);
         const mesa_format fmt = rb->Format;

         /* Grab samples and sampleBuffers from any attachment point (assuming
          * the framebuffer is complete, we'll get the same answer from all
          * attachments).
          */
         fb->Visual.samples = rb->NumSamples;
         fb->Visual.sampleBuffers = rb->NumSamples > 0 ? 1 : 0;

         if (_mesa_is_legal_color_format(ctx, baseFormat)) {
            fb->Visual.redBits = _mesa_get_format_bits(fmt, GL_RED_BITS);
            fb->Visual.greenBits = _mesa_get_format_bits(fmt, GL_GREEN_BITS);
            fb->Visual.blueBits = _mesa_get_format_bits(fmt, GL_BLUE_BITS);
            fb->Visual.alphaBits = _mesa_get_format_bits(fmt, GL_ALPHA_BITS);
            fb->Visual.rgbBits = fb->Visual.redBits
               + fb->Visual.greenBits + fb->Visual.blueBits;
            if (_mesa_get_format_color_encoding(fmt) == GL_SRGB)
                fb->Visual.sRGBCapable = ctx->Extensions.EXT_framebuffer_sRGB;
            break;
         }
      }
   }

   fb->Visual.floatMode = GL_FALSE;
   for (i = 0; i < BUFFER_COUNT; i++) {
      if (fb->Attachment[i].Renderbuffer) {
         const struct gl_renderbuffer *rb = fb->Attachment[i].Renderbuffer;
         const mesa_format fmt = rb->Format;

         if (_mesa_get_format_datatype(fmt) == GL_FLOAT) {
            fb->Visual.floatMode = GL_TRUE;
            break;
         }
      }
   }

   if (fb->Attachment[BUFFER_DEPTH].Renderbuffer) {
      const struct gl_renderbuffer *rb =
         fb->Attachment[BUFFER_DEPTH].Renderbuffer;
      const mesa_format fmt = rb->Format;
      fb->Visual.haveDepthBuffer = GL_TRUE;
      fb->Visual.depthBits = _mesa_get_format_bits(fmt, GL_DEPTH_BITS);
   }

   if (fb->Attachment[BUFFER_STENCIL].Renderbuffer) {
      const struct gl_renderbuffer *rb =
         fb->Attachment[BUFFER_STENCIL].Renderbuffer;
      const mesa_format fmt = rb->Format;
      fb->Visual.haveStencilBuffer = GL_TRUE;
      fb->Visual.stencilBits = _mesa_get_format_bits(fmt, GL_STENCIL_BITS);
   }

   if (fb->Attachment[BUFFER_ACCUM].Renderbuffer) {
      const struct gl_renderbuffer *rb =
         fb->Attachment[BUFFER_ACCUM].Renderbuffer;
      const mesa_format fmt = rb->Format;
      fb->Visual.haveAccumBuffer = GL_TRUE;
      fb->Visual.accumRedBits = _mesa_get_format_bits(fmt, GL_RED_BITS);
      fb->Visual.accumGreenBits = _mesa_get_format_bits(fmt, GL_GREEN_BITS);
      fb->Visual.accumBlueBits = _mesa_get_format_bits(fmt, GL_BLUE_BITS);
      fb->Visual.accumAlphaBits = _mesa_get_format_bits(fmt, GL_ALPHA_BITS);
   }

   compute_depth_max(fb);
}


/*
 * Example DrawBuffers scenarios:
 *
 * 1. glDrawBuffer(GL_FRONT_AND_BACK), fixed-func or shader writes to
 * "gl_FragColor" or program writes to the "result.color" register:
 *
 *   fragment color output   renderbuffer
 *   ---------------------   ---------------
 *   color[0]                Front, Back
 *
 *
 * 2. glDrawBuffers(3, [GL_FRONT, GL_AUX0, GL_AUX1]), shader writes to
 * gl_FragData[i] or program writes to result.color[i] registers:
 *
 *   fragment color output   renderbuffer
 *   ---------------------   ---------------
 *   color[0]                Front
 *   color[1]                Aux0
 *   color[3]                Aux1
 *
 *
 * 3. glDrawBuffers(3, [GL_FRONT, GL_AUX0, GL_AUX1]) and shader writes to
 * gl_FragColor, or fixed function:
 *
 *   fragment color output   renderbuffer
 *   ---------------------   ---------------
 *   color[0]                Front, Aux0, Aux1
 *
 *
 * In either case, the list of renderbuffers is stored in the
 * framebuffer->_ColorDrawBuffers[] array and
 * framebuffer->_NumColorDrawBuffers indicates the number of buffers.
 * The renderer (like swrast) has to look at the current fragment shader
 * to see if it writes to gl_FragColor vs. gl_FragData[i] to determine
 * how to map color outputs to renderbuffers.
 *
 * Note that these two calls are equivalent (for fixed function fragment
 * shading anyway):
 *   a)  glDrawBuffer(GL_FRONT_AND_BACK);  (assuming non-stereo framebuffer)
 *   b)  glDrawBuffers(2, [GL_FRONT_LEFT, GL_BACK_LEFT]);
 */




/**
 * Update the (derived) list of color drawing renderbuffer pointers.
 * Later, when we're rendering we'll loop from 0 to _NumColorDrawBuffers
 * writing colors.
 */
static void
update_color_draw_buffers(struct gl_context *ctx, struct gl_framebuffer *fb)
{
   GLuint output;

   /* set 0th buffer to NULL now in case _NumColorDrawBuffers is zero */
   fb->_ColorDrawBuffers[0] = NULL;

   for (output = 0; output < fb->_NumColorDrawBuffers; output++) {
      GLint buf = fb->_ColorDrawBufferIndexes[output];
      if (buf >= 0) {
         fb->_ColorDrawBuffers[output] = fb->Attachment[buf].Renderbuffer;
      }
      else {
         fb->_ColorDrawBuffers[output] = NULL;
      }
   }
}


/**
 * Update the (derived) color read renderbuffer pointer.
 * Unlike the DrawBuffer, we can only read from one (or zero) color buffers.
 */
static void
update_color_read_buffer(struct gl_context *ctx, struct gl_framebuffer *fb)
{
   (void) ctx;
   if (fb->_ColorReadBufferIndex == -1 ||
       fb->DeletePending ||
       fb->Width == 0 ||
       fb->Height == 0) {
      fb->_ColorReadBuffer = NULL; /* legal! */
   }
   else {
      ASSERT(fb->_ColorReadBufferIndex >= 0);
      ASSERT(fb->_ColorReadBufferIndex < BUFFER_COUNT);
      fb->_ColorReadBuffer
         = fb->Attachment[fb->_ColorReadBufferIndex].Renderbuffer;
   }
}


/**
 * Update a gl_framebuffer's derived state.
 *
 * Specifically, update these framebuffer fields:
 *    _ColorDrawBuffers
 *    _NumColorDrawBuffers
 *    _ColorReadBuffer
 *
 * If the framebuffer is user-created, make sure it's complete.
 *
 * The following functions (at least) can effect framebuffer state:
 * glReadBuffer, glDrawBuffer, glDrawBuffersARB, glFramebufferRenderbufferEXT,
 * glRenderbufferStorageEXT.
 */
static void
update_framebuffer(struct gl_context *ctx, struct gl_framebuffer *fb)
{
   if (_mesa_is_winsys_fbo(fb)) {
      /* This is a window-system framebuffer */
      /* Need to update the FB's GL_DRAW_BUFFER state to match the
       * context state (GL_READ_BUFFER too).
       */
      if (fb->ColorDrawBuffer[0] != ctx->Color.DrawBuffer[0]) {
         _mesa_drawbuffers(ctx, ctx->Const.MaxDrawBuffers,
                           ctx->Color.DrawBuffer, NULL);
      }
   }
   else {
      /* This is a user-created framebuffer.
       * Completeness only matters for user-created framebuffers.
       */
      if (fb->_Status != GL_FRAMEBUFFER_COMPLETE) {
         _mesa_test_framebuffer_completeness(ctx, fb);
      }
   }

   /* Strictly speaking, we don't need to update the draw-state
    * if this FB is bound as ctx->ReadBuffer (and conversely, the
    * read-state if this FB is bound as ctx->DrawBuffer), but no
    * harm.
    */
   update_color_draw_buffers(ctx, fb);
   update_color_read_buffer(ctx, fb);

   compute_depth_max(fb);
}


/**
 * Update state related to the current draw/read framebuffers.
 */
void
_mesa_update_framebuffer(struct gl_context *ctx)
{
   struct gl_framebuffer *drawFb;
   struct gl_framebuffer *readFb;

   assert(ctx);
   drawFb = ctx->DrawBuffer;
   readFb = ctx->ReadBuffer;

   update_framebuffer(ctx, drawFb);
   if (readFb != drawFb)
      update_framebuffer(ctx, readFb);

   _mesa_update_clamp_vertex_color(ctx);
   _mesa_update_clamp_fragment_color(ctx);
}


/**
 * Check if the renderbuffer for a read/draw operation exists.
 * \param format  a basic image format such as GL_RGB, GL_RGBA, GL_ALPHA,
 *                GL_DEPTH_COMPONENT, etc. or GL_COLOR, GL_DEPTH, GL_STENCIL.
 * \param reading  if TRUE, we're going to read from the buffer,
                   if FALSE, we're going to write to the buffer.
 * \return GL_TRUE if buffer exists, GL_FALSE otherwise
 */
static GLboolean
renderbuffer_exists(struct gl_context *ctx,
                    struct gl_framebuffer *fb,
                    GLenum format,
                    GLboolean reading)
{
   const struct gl_renderbuffer_attachment *att = fb->Attachment;

   /* If we don't know the framebuffer status, update it now */
   if (fb->_Status == 0) {
      _mesa_test_framebuffer_completeness(ctx, fb);
   }

   if (fb->_Status != GL_FRAMEBUFFER_COMPLETE_EXT) {
      return GL_FALSE;
   }

   switch (format) {
   case GL_COLOR:
   case GL_RED:
   case GL_GREEN:
   case GL_BLUE:
   case GL_ALPHA:
   case GL_LUMINANCE:
   case GL_LUMINANCE_ALPHA:
   case GL_INTENSITY:
   case GL_RG:
   case GL_RGB:
   case GL_BGR:
   case GL_RGBA:
   case GL_BGRA:
   case GL_ABGR_EXT:
   case GL_RED_INTEGER_EXT:
   case GL_RG_INTEGER:
   case GL_GREEN_INTEGER_EXT:
   case GL_BLUE_INTEGER_EXT:
   case GL_ALPHA_INTEGER_EXT:
   case GL_RGB_INTEGER_EXT:
   case GL_RGBA_INTEGER_EXT:
   case GL_BGR_INTEGER_EXT:
   case GL_BGRA_INTEGER_EXT:
   case GL_LUMINANCE_INTEGER_EXT:
   case GL_LUMINANCE_ALPHA_INTEGER_EXT:
      if (reading) {
         /* about to read from a color buffer */
         const struct gl_renderbuffer *readBuf = fb->_ColorReadBuffer;
         if (!readBuf) {
            return GL_FALSE;
         }
         ASSERT(_mesa_get_format_bits(readBuf->Format, GL_RED_BITS) > 0 ||
                _mesa_get_format_bits(readBuf->Format, GL_ALPHA_BITS) > 0 ||
                _mesa_get_format_bits(readBuf->Format, GL_TEXTURE_LUMINANCE_SIZE) > 0 ||
                _mesa_get_format_bits(readBuf->Format, GL_TEXTURE_INTENSITY_SIZE) > 0 ||
                _mesa_get_format_bits(readBuf->Format, GL_INDEX_BITS) > 0);
      }
      else {
         /* about to draw to zero or more color buffers (none is OK) */
         return GL_TRUE;
      }
      break;
   case GL_DEPTH:
   case GL_DEPTH_COMPONENT:
      if (att[BUFFER_DEPTH].Type == GL_NONE) {
         return GL_FALSE;
      }
      break;
   case GL_STENCIL:
   case GL_STENCIL_INDEX:
      if (att[BUFFER_STENCIL].Type == GL_NONE) {
         return GL_FALSE;
      }
      break;
   case GL_DEPTH_STENCIL_EXT:
      if (att[BUFFER_DEPTH].Type == GL_NONE ||
          att[BUFFER_STENCIL].Type == GL_NONE) {
         return GL_FALSE;
      }
      break;
   default:
      _mesa_problem(ctx,
                    "Unexpected format 0x%x in renderbuffer_exists",
                    format);
      return GL_FALSE;
   }

   /* OK */
   return GL_TRUE;
}


/**
 * Check if the renderbuffer for a read operation (glReadPixels, glCopyPixels,
 * glCopyTex[Sub]Image, etc) exists.
 * \param format  a basic image format such as GL_RGB, GL_RGBA, GL_ALPHA,
 *                GL_DEPTH_COMPONENT, etc. or GL_COLOR, GL_DEPTH, GL_STENCIL.
 * \return GL_TRUE if buffer exists, GL_FALSE otherwise
 */
GLboolean
_mesa_source_buffer_exists(struct gl_context *ctx, GLenum format)
{
   return renderbuffer_exists(ctx, ctx->ReadBuffer, format, GL_TRUE);
}


/**
 * As above, but for drawing operations.
 */
GLboolean
_mesa_dest_buffer_exists(struct gl_context *ctx, GLenum format)
{
   return renderbuffer_exists(ctx, ctx->DrawBuffer, format, GL_FALSE);
}


/**
 * Used to answer the GL_IMPLEMENTATION_COLOR_READ_FORMAT_OES query.
 */
GLenum
_mesa_get_color_read_format(struct gl_context *ctx)
{
   if (!ctx->ReadBuffer || !ctx->ReadBuffer->_ColorReadBuffer) {
      /* The spec is unclear how to handle this case, but NVIDIA's
       * driver generates GL_INVALID_OPERATION.
       */
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glGetIntegerv(GL_IMPLEMENTATION_COLOR_READ_FORMAT: "
                  "no GL_READ_BUFFER)");
      return GL_NONE;
   }
   else {
      const GLenum format = ctx->ReadBuffer->_ColorReadBuffer->Format;
      const GLenum data_type = _mesa_get_format_datatype(format);

      if (format == MESA_FORMAT_B8G8R8A8_UNORM)
         return GL_BGRA;
      else if (format == MESA_FORMAT_B5G6R5_UNORM)
         return GL_BGR;

      switch (data_type) {
      case GL_UNSIGNED_INT:
      case GL_INT:
         return GL_RGBA_INTEGER;
      default:
         return GL_RGBA;
      }
   }
}


/**
 * Used to answer the GL_IMPLEMENTATION_COLOR_READ_TYPE_OES query.
 */
GLenum
_mesa_get_color_read_type(struct gl_context *ctx)
{
   if (!ctx->ReadBuffer || !ctx->ReadBuffer->_ColorReadBuffer) {
      /* The spec is unclear how to handle this case, but NVIDIA's
       * driver generates GL_INVALID_OPERATION.
       */
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glGetIntegerv(GL_IMPLEMENTATION_COLOR_READ_TYPE: "
                  "no GL_READ_BUFFER)");
      return GL_NONE;
   }
   else {
      const GLenum format = ctx->ReadBuffer->_ColorReadBuffer->Format;
      const GLenum data_type = _mesa_get_format_datatype(format);

      if (format == MESA_FORMAT_B5G6R5_UNORM)
         return GL_UNSIGNED_SHORT_5_6_5_REV;

      switch (data_type) {
      case GL_SIGNED_NORMALIZED:
         return GL_BYTE;
      case GL_UNSIGNED_INT:
      case GL_INT:
      case GL_FLOAT:
         return data_type;
      case GL_UNSIGNED_NORMALIZED:
      default:
         return GL_UNSIGNED_BYTE;
      }
   }
}


/**
 * Returns the read renderbuffer for the specified format.
 */
struct gl_renderbuffer *
_mesa_get_read_renderbuffer_for_format(const struct gl_context *ctx,
                                       GLenum format)
{
   const struct gl_framebuffer *rfb = ctx->ReadBuffer;

   if (_mesa_is_color_format(format)) {
      return rfb->Attachment[rfb->_ColorReadBufferIndex].Renderbuffer;
   } else if (_mesa_is_depth_format(format) ||
              _mesa_is_depthstencil_format(format)) {
      return rfb->Attachment[BUFFER_DEPTH].Renderbuffer;
   } else {
      return rfb->Attachment[BUFFER_STENCIL].Renderbuffer;
   }
}


/**
 * Print framebuffer info to stderr, for debugging.
 */
void
_mesa_print_framebuffer(const struct gl_framebuffer *fb)
{
   GLuint i;

   fprintf(stderr, "Mesa Framebuffer %u at %p\n", fb->Name, (void *) fb);
   fprintf(stderr, "  Size: %u x %u  Status: %s\n", fb->Width, fb->Height,
           _mesa_lookup_enum_by_nr(fb->_Status));
   fprintf(stderr, "  Attachments:\n");

   for (i = 0; i < BUFFER_COUNT; i++) {
      const struct gl_renderbuffer_attachment *att = &fb->Attachment[i];
      if (att->Type == GL_TEXTURE) {
         const struct gl_texture_image *texImage = att->Renderbuffer->TexImage;
         fprintf(stderr,
                 "  %2d: Texture %u, level %u, face %u, slice %u, complete %d\n",
                 i, att->Texture->Name, att->TextureLevel, att->CubeMapFace,
                 att->Zoffset, att->Complete);
         fprintf(stderr, "       Size: %u x %u x %u  Format %s\n",
                 texImage->Width, texImage->Height, texImage->Depth,
                 _mesa_get_format_name(texImage->TexFormat));
      }
      else if (att->Type == GL_RENDERBUFFER) {
         fprintf(stderr, "  %2d: Renderbuffer %u, complete %d\n",
                 i, att->Renderbuffer->Name, att->Complete);
         fprintf(stderr, "       Size: %u x %u  Format %s\n",
                 att->Renderbuffer->Width, att->Renderbuffer->Height,
                 _mesa_get_format_name(att->Renderbuffer->Format));
      }
      else {
         fprintf(stderr, "  %2d: none\n", i);
      }
   }
}
@


1.11
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.10
log
@Merge Mesa 9.2.0
@
text
@d133 1
a133 1
   _glthread_INIT_MUTEX(fb->Mutex);
d185 1
a185 1
   _glthread_INIT_MUTEX(fb->Mutex);
d198 1
d216 1
a216 1
   _glthread_DESTROY_MUTEX(fb->Mutex);
d247 1
a247 1
      _glthread_LOCK_MUTEX(oldFb->Mutex);
d251 1
a251 1
      _glthread_UNLOCK_MUTEX(oldFb->Mutex);
d261 1
a261 1
      _glthread_LOCK_MUTEX(fb->Mutex);
d263 1
a263 1
      _glthread_UNLOCK_MUTEX(fb->Mutex);
d360 50
d419 1
d429 6
a434 29
   buffer->_Xmin = 0;
   buffer->_Ymin = 0;
   buffer->_Xmax = buffer->Width;
   buffer->_Ymax = buffer->Height;

   if (ctx->Scissor.Enabled) {
      if (ctx->Scissor.X > buffer->_Xmin) {
	 buffer->_Xmin = ctx->Scissor.X;
      }
      if (ctx->Scissor.Y > buffer->_Ymin) {
	 buffer->_Ymin = ctx->Scissor.Y;
      }
      if (ctx->Scissor.X + ctx->Scissor.Width < buffer->_Xmax) {
	 buffer->_Xmax = ctx->Scissor.X + ctx->Scissor.Width;
      }
      if (ctx->Scissor.Y + ctx->Scissor.Height < buffer->_Ymax) {
	 buffer->_Ymax = ctx->Scissor.Y + ctx->Scissor.Height;
      }
      /* finally, check for empty region */
      if (buffer->_Xmin > buffer->_Xmax) {
         buffer->_Xmin = buffer->_Xmax;
      }
      if (buffer->_Ymin > buffer->_Ymax) {
         buffer->_Ymin = buffer->_Ymax;
      }
   }

   ASSERT(buffer->_Xmin <= buffer->_Xmax);
   ASSERT(buffer->_Ymin <= buffer->_Ymax);
d472 1
a472 1
         const gl_format fmt = rb->Format;
d499 1
a499 1
         const gl_format fmt = rb->Format;
d511 1
a511 1
      const gl_format fmt = rb->Format;
d519 1
a519 1
      const gl_format fmt = rb->Format;
d527 1
a527 1
      const gl_format fmt = rb->Format;
d843 1
a843 1
      if (format == MESA_FORMAT_ARGB8888)
d845 1
a845 1
      else if (format == MESA_FORMAT_RGB565)
d878 1
a878 1
      if (format == MESA_FORMAT_RGB565)
@


1.9
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a2 1
 * Version:  7.2
d19 4
a22 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
d35 1
a37 1
#include "depthstencil.h"
d46 1
d158 2
a228 4

   /* unbind _Depth/_StencilBuffer to decr ref counts */
   _mesa_reference_renderbuffer(&fb->_DepthBuffer, NULL);
   _mesa_reference_renderbuffer(&fb->_StencilBuffer, NULL);
d234 2
d238 2
a239 2
_mesa_reference_framebuffer(struct gl_framebuffer **ptr,
                            struct gl_framebuffer *fb)
a240 6
   assert(ptr);
   if (*ptr == fb) {
      /* no change */
      return;
   }

d288 2
a289 2
   /* For window system framebuffers, Name is zero */
   assert(fb->Name == 0);
a308 18
   if (fb->_DepthBuffer) {
      struct gl_renderbuffer *rb = fb->_DepthBuffer;
      if (rb->Width != width || rb->Height != height) {
         if (!rb->AllocStorage(ctx, rb, rb->InternalFormat, width, height)) {
            _mesa_error(ctx, GL_OUT_OF_MEMORY, "Resizing framebuffer");
         }
      }
   }

   if (fb->_StencilBuffer) {
      struct gl_renderbuffer *rb = fb->_StencilBuffer;
      if (rb->Width != width || rb->Height != height) {
         if (!rb->AllocStorage(ctx, rb, rb->InternalFormat, width, height)) {
            _mesa_error(ctx, GL_OUT_OF_MEMORY, "Resizing framebuffer");
         }
      }
   }

a321 79


/**
 * XXX THIS IS OBSOLETE - drivers should take care of detecting window
 * size changes and act accordingly, likely calling _mesa_resize_framebuffer().
 *
 * GL_MESA_resize_buffers extension.
 *
 * When this function is called, we'll ask the window system how large
 * the current window is.  If it's a new size, we'll call the driver's
 * ResizeBuffers function.  The driver will then resize its color buffers
 * as needed, and maybe call the swrast's routine for reallocating
 * swrast-managed depth/stencil/accum/etc buffers.
 * \note This function should only be called through the GL API, not
 * from device drivers (as was done in the past).
 */
void
_mesa_resizebuffers( struct gl_context *ctx )
{
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH( ctx );

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glResizeBuffersMESA\n");

   if (!ctx->Driver.GetBufferSize) {
      return;
   }

   if (ctx->WinSysDrawBuffer) {
      GLuint newWidth, newHeight;
      struct gl_framebuffer *buffer = ctx->WinSysDrawBuffer;

      assert(buffer->Name == 0);

      /* ask device driver for size of output buffer */
      ctx->Driver.GetBufferSize( buffer, &newWidth, &newHeight );

      /* see if size of device driver's color buffer (window) has changed */
      if (buffer->Width != newWidth || buffer->Height != newHeight) {
         if (ctx->Driver.ResizeBuffers)
            ctx->Driver.ResizeBuffers(ctx, buffer, newWidth, newHeight );
      }
   }

   if (ctx->WinSysReadBuffer
       && ctx->WinSysReadBuffer != ctx->WinSysDrawBuffer) {
      GLuint newWidth, newHeight;
      struct gl_framebuffer *buffer = ctx->WinSysReadBuffer;

      assert(buffer->Name == 0);

      /* ask device driver for size of read buffer */
      ctx->Driver.GetBufferSize( buffer, &newWidth, &newHeight );

      /* see if size of device driver's color buffer (window) has changed */
      if (buffer->Width != newWidth || buffer->Height != newHeight) {
         if (ctx->Driver.ResizeBuffers)
            ctx->Driver.ResizeBuffers(ctx, buffer, newWidth, newHeight );
      }
   }

   ctx->NewState |= _NEW_BUFFERS;  /* to update scissor / window bounds */
}


/*
 * XXX THIS IS OBSOLETE
 */
void GLAPIENTRY
_mesa_ResizeBuffersMESA( void )
{
   GET_CURRENT_CONTEXT(ctx);

   if (ctx->Extensions.MESA_resize_buffers)
      _mesa_resizebuffers( ctx );
}



d336 1
a336 1
   assert(fb->Name);
d372 1
a372 1
   if (buffer->Name) {
d445 7
a458 1
            fb->Visual.samples = rb->NumSamples;
d460 1
a460 1
                fb->Visual.sRGBCapable = ctx->Const.sRGBCapable;
a509 82
/**
 * Update the framebuffer's _DepthBuffer field using the renderbuffer
 * found at the given attachment index.
 *
 * If that attachment points to a combined GL_DEPTH_STENCIL renderbuffer,
 * create and install a depth wrapper/adaptor.
 *
 * \param fb  the framebuffer whose _DepthBuffer field to update
 * \param attIndex  indicates the renderbuffer to possibly wrap
 */
void
_mesa_update_depth_buffer(struct gl_context *ctx,
                          struct gl_framebuffer *fb,
                          GLuint attIndex)
{
   struct gl_renderbuffer *depthRb;

   /* only one possiblity for now */
   ASSERT(attIndex == BUFFER_DEPTH);

   depthRb = fb->Attachment[attIndex].Renderbuffer;

   if (depthRb && _mesa_is_format_packed_depth_stencil(depthRb->Format)) {
      /* The attached depth buffer is a GL_DEPTH_STENCIL renderbuffer */
      if (!fb->_DepthBuffer
          || fb->_DepthBuffer->Wrapped != depthRb
          || _mesa_get_format_base_format(fb->_DepthBuffer->Format) != GL_DEPTH_COMPONENT) {
         /* need to update wrapper */
         struct gl_renderbuffer *wrapper
            = _mesa_new_z24_renderbuffer_wrapper(ctx, depthRb);
         _mesa_reference_renderbuffer(&fb->_DepthBuffer, wrapper);
         ASSERT(fb->_DepthBuffer->Wrapped == depthRb);
      }
   }
   else {
      /* depthRb may be null */
      _mesa_reference_renderbuffer(&fb->_DepthBuffer, depthRb);
   }
}


/**
 * Update the framebuffer's _StencilBuffer field using the renderbuffer
 * found at the given attachment index.
 *
 * If that attachment points to a combined GL_DEPTH_STENCIL renderbuffer,
 * create and install a stencil wrapper/adaptor.
 *
 * \param fb  the framebuffer whose _StencilBuffer field to update
 * \param attIndex  indicates the renderbuffer to possibly wrap
 */
void
_mesa_update_stencil_buffer(struct gl_context *ctx,
                            struct gl_framebuffer *fb,
                            GLuint attIndex)
{
   struct gl_renderbuffer *stencilRb;

   ASSERT(attIndex == BUFFER_DEPTH ||
          attIndex == BUFFER_STENCIL);

   stencilRb = fb->Attachment[attIndex].Renderbuffer;

   if (stencilRb && _mesa_is_format_packed_depth_stencil(stencilRb->Format)) {
      /* The attached stencil buffer is a GL_DEPTH_STENCIL renderbuffer */
      if (!fb->_StencilBuffer
          || fb->_StencilBuffer->Wrapped != stencilRb
          || _mesa_get_format_base_format(fb->_StencilBuffer->Format) != GL_STENCIL_INDEX) {
         /* need to update wrapper */
         struct gl_renderbuffer *wrapper
            = _mesa_new_s8_renderbuffer_wrapper(ctx, stencilRb);
         _mesa_reference_renderbuffer(&fb->_StencilBuffer, wrapper);
         ASSERT(fb->_StencilBuffer->Wrapped == stencilRb);
      }
   }
   else {
      /* stencilRb may be null */
      _mesa_reference_renderbuffer(&fb->_StencilBuffer, stencilRb);
   }
}


a609 2
 *    _DepthBuffer
 *    _StencilBuffer
d620 1
a620 1
   if (fb->Name == 0) {
a645 2
   _mesa_update_depth_buffer(ctx, fb, BUFFER_DEPTH);
   _mesa_update_stencil_buffer(ctx, fb, BUFFER_STENCIL);
d667 3
d674 1
a674 2
 * Check if the renderbuffer for a read operation (glReadPixels, glCopyPixels,
 * glCopyTex[Sub]Image, etc) exists.
d677 2
d681 5
a685 2
GLboolean
_mesa_source_buffer_exists(struct gl_context *ctx, GLenum format)
d687 1
a687 1
   const struct gl_renderbuffer_attachment *att = ctx->ReadBuffer->Attachment;
d690 2
a691 2
   if (ctx->ReadBuffer->_Status == 0) {
      _mesa_test_framebuffer_completeness(ctx, ctx->ReadBuffer);
d694 1
a694 1
   if (ctx->ReadBuffer->_Status != GL_FRAMEBUFFER_COMPLETE_EXT) {
a712 1
   case GL_COLOR_INDEX:
d714 1
d724 15
a738 2
      if (ctx->ReadBuffer->_ColorReadBuffer == NULL) {
         return GL_FALSE;
a739 5
      ASSERT(_mesa_get_format_bits(ctx->ReadBuffer->_ColorReadBuffer->Format, GL_RED_BITS) > 0 ||
             _mesa_get_format_bits(ctx->ReadBuffer->_ColorReadBuffer->Format, GL_ALPHA_BITS) > 0 ||
             _mesa_get_format_bits(ctx->ReadBuffer->_ColorReadBuffer->Format, GL_TEXTURE_LUMINANCE_SIZE) > 0 ||
             _mesa_get_format_bits(ctx->ReadBuffer->_ColorReadBuffer->Format, GL_TEXTURE_INTENSITY_SIZE) > 0 ||
             _mesa_get_format_bits(ctx->ReadBuffer->_ColorReadBuffer->Format, GL_INDEX_BITS) > 0);
d743 1
a743 1
      if (!att[BUFFER_DEPTH].Renderbuffer) {
a745 1
      /*ASSERT(att[BUFFER_DEPTH].Renderbuffer->DepthBits > 0);*/
d749 1
a749 1
      if (!att[BUFFER_STENCIL].Renderbuffer) {
a751 1
      /*ASSERT(att[BUFFER_STENCIL].Renderbuffer->StencilBits > 0);*/
d754 2
a755 2
      if (!att[BUFFER_DEPTH].Renderbuffer ||
          !att[BUFFER_STENCIL].Renderbuffer) {
a757 4
      /*
      ASSERT(att[BUFFER_DEPTH].Renderbuffer->DepthBits > 0);
      ASSERT(att[BUFFER_STENCIL].Renderbuffer->StencilBits > 0);
      */
d761 1
a761 1
                    "Unexpected format 0x%x in _mesa_source_buffer_exists",
d772 14
a786 1
 * XXX could do some code merging w/ above function.
d791 2
a792 1
   const struct gl_renderbuffer_attachment *att = ctx->DrawBuffer->Attachment;
a793 4
   /* If we don't know the framebuffer status, update it now */
   if (ctx->DrawBuffer->_Status == 0) {
      _mesa_test_framebuffer_completeness(ctx, ctx->DrawBuffer);
   }
d795 14
a808 2
   if (ctx->DrawBuffer->_Status != GL_FRAMEBUFFER_COMPLETE_EXT) {
      return GL_FALSE;
d810 3
d814 11
a824 32
   switch (format) {
   case GL_COLOR:
   case GL_RED:
   case GL_GREEN:
   case GL_BLUE:
   case GL_ALPHA:
   case GL_LUMINANCE:
   case GL_LUMINANCE_ALPHA:
   case GL_INTENSITY:
   case GL_RGB:
   case GL_BGR:
   case GL_RGBA:
   case GL_BGRA:
   case GL_ABGR_EXT:
   case GL_COLOR_INDEX:
   case GL_RED_INTEGER_EXT:
   case GL_GREEN_INTEGER_EXT:
   case GL_BLUE_INTEGER_EXT:
   case GL_ALPHA_INTEGER_EXT:
   case GL_RGB_INTEGER_EXT:
   case GL_RGBA_INTEGER_EXT:
   case GL_BGR_INTEGER_EXT:
   case GL_BGRA_INTEGER_EXT:
   case GL_LUMINANCE_INTEGER_EXT:
   case GL_LUMINANCE_ALPHA_INTEGER_EXT:
      /* Nothing special since GL_DRAW_BUFFER could be GL_NONE. */
      /* Could assert that colorbuffer has RedBits > 0 */
      break;
   case GL_DEPTH:
   case GL_DEPTH_COMPONENT:
      if (!att[BUFFER_DEPTH].Renderbuffer) {
         return GL_FALSE;
a825 24
      /*ASSERT(att[BUFFER_DEPTH].Renderbuffer->DepthBits > 0);*/
      break;
   case GL_STENCIL:
   case GL_STENCIL_INDEX:
      if (!att[BUFFER_STENCIL].Renderbuffer) {
         return GL_FALSE;
      }
      /*ASSERT(att[BUFFER_STENCIL].Renderbuffer->StencilBits > 0);*/
      break;
   case GL_DEPTH_STENCIL_EXT:
      if (!att[BUFFER_DEPTH].Renderbuffer ||
          !att[BUFFER_STENCIL].Renderbuffer) {
         return GL_FALSE;
      }
      /*
      ASSERT(att[BUFFER_DEPTH].Renderbuffer->DepthBits > 0);
      ASSERT(att[BUFFER_STENCIL].Renderbuffer->StencilBits > 0);
      */
      break;
   default:
      _mesa_problem(ctx,
                    "Unexpected format 0x%x in _mesa_dest_buffer_exists",
                    format);
      return GL_FALSE;
a826 3

   /* OK */
   return GL_TRUE;
d831 1
a831 1
 * Used to answer the GL_IMPLEMENTATION_COLOR_READ_FORMAT_OES query.
d834 1
a834 1
_mesa_get_color_read_format(struct gl_context *ctx)
d836 27
a862 7
   switch (ctx->ReadBuffer->_ColorReadBuffer->Format) {
   case MESA_FORMAT_ARGB8888:
      return GL_BGRA;
   case MESA_FORMAT_RGB565:
      return GL_BGR;
   default:
      return GL_RGBA;
d868 1
a868 1
 * Used to answer the GL_IMPLEMENTATION_COLOR_READ_TYPE_OES query.
d870 3
a872 2
GLenum
_mesa_get_color_read_type(struct gl_context *ctx)
d874 9
a882 7
   switch (ctx->ReadBuffer->_ColorReadBuffer->Format) {
   case MESA_FORMAT_ARGB8888:
      return GL_UNSIGNED_BYTE;
   case MESA_FORMAT_RGB565:
      return GL_UNSIGNED_SHORT_5_6_5_REV;
   default:
      return GL_UNSIGNED_BYTE;
d903 1
a903 2
         const struct gl_texture_image *texImage =
            _mesa_get_attachment_teximage_const(att);
@


1.8
log
@Merge Mesa 7.10.3
@
text
@d525 2
a526 1
_mesa_update_framebuffer_visual(struct gl_framebuffer *fb)
d546 2
a547 3
         
         if (baseFormat == GL_RGBA || baseFormat == GL_RGB ||
	     baseFormat == GL_ALPHA) {
a553 1
            fb->Visual.floatMode = GL_FALSE;
d555 15
a808 3
      if (fb->ColorReadBuffer != ctx->Pixel.ReadBuffer) {
         
      }
d1076 2
a1077 1
         const struct gl_texture_image *texImage;
a1081 1
         texImage = att->Texture->Image[att->CubeMapFace][att->TextureLevel];
@


1.7
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d38 1
a77 1

d86 1
a86 1
_mesa_create_framebuffer(const GLvisual *visual)
d105 1
a105 1
_mesa_new_framebuffer(GLcontext *ctx, GLuint name)
d125 1
a125 1
				     const GLvisual *visual)
d284 1
a284 1
_mesa_resize_framebuffer(GLcontext *ctx, struct gl_framebuffer *fb,
d362 1
a362 1
_mesa_resizebuffers( GLcontext *ctx )
d375 1
a375 1
      GLframebuffer *buffer = ctx->WinSysDrawBuffer;
d392 1
a392 1
      GLframebuffer *buffer = ctx->WinSysReadBuffer;
d432 1
a432 1
update_framebuffer_size(GLcontext *ctx, struct gl_framebuffer *fb)
d467 1
a467 1
_mesa_update_draw_buffer_bounds(GLcontext *ctx)
d546 2
a547 1
         if (baseFormat == GL_RGBA || baseFormat == GL_RGB) {
d603 1
a603 1
_mesa_update_depth_buffer(GLcontext *ctx,
d614 1
a614 1
   if (depthRb && depthRb->_BaseFormat == GL_DEPTH_STENCIL) {
d644 1
a644 1
_mesa_update_stencil_buffer(GLcontext *ctx,
d655 1
a655 1
   if (stencilRb && stencilRb->_BaseFormat == GL_DEPTH_STENCIL) {
d725 1
a725 1
update_color_draw_buffers(GLcontext *ctx, struct gl_framebuffer *fb)
d749 1
a749 1
update_color_read_buffer(GLcontext *ctx, struct gl_framebuffer *fb)
d784 1
a784 1
update_framebuffer(GLcontext *ctx, struct gl_framebuffer *fb)
d826 1
a826 1
_mesa_update_framebuffer(GLcontext *ctx)
d849 1
a849 1
_mesa_source_buffer_exists(GLcontext *ctx, GLenum format)
d871 1
d878 10
d892 3
d938 1
a938 1
_mesa_dest_buffer_exists(GLcontext *ctx, GLenum format)
d966 10
d1014 4
d1019 1
a1019 1
_mesa_get_color_read_format(GLcontext *ctx)
d1031 4
d1036 1
a1036 1
_mesa_get_color_read_type(GLcontext *ctx)
d1045 40
@


1.6
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d38 2
d91 1
a91 1
      _mesa_initialize_framebuffer(fb, visual);
d112 1
a112 9
      fb->Name = name;
      fb->RefCount = 1;
      fb->_NumColorDrawBuffers = 1;
      fb->ColorDrawBuffer[0] = GL_COLOR_ATTACHMENT0_EXT;
      fb->_ColorDrawBufferIndexes[0] = BUFFER_COLOR0;
      fb->ColorReadBuffer = GL_COLOR_ATTACHMENT0_EXT;
      fb->_ColorReadBufferIndex = BUFFER_COLOR0;
      fb->Delete = _mesa_destroy_framebuffer;
      _glthread_INIT_MUTEX(fb->Mutex);
d121 1
a121 1
 * \sa _mesa_create_framebuffer
d124 2
a125 1
_mesa_initialize_framebuffer(struct gl_framebuffer *fb, const GLvisual *visual)
d130 1
a130 1
   _mesa_bzero(fb, sizeof(struct gl_framebuffer));
d163 24
d195 1
a195 1
      _mesa_free(fb);
d245 1
d247 1
a247 22
      _mesa_unreference_framebuffer(ptr);
   }
   assert(!*ptr);
   assert(fb);
   _glthread_LOCK_MUTEX(fb->Mutex);
   fb->RefCount++;
   _glthread_UNLOCK_MUTEX(fb->Mutex);
   *ptr = fb;
}


/**
 * Undo/remove a reference to a framebuffer object.
 * Decrement the framebuffer object's reference count and delete it when
 * the refcount hits zero.
 * Note: we pass the address of a pointer and set it to NULL.
 */
void
_mesa_unreference_framebuffer(struct gl_framebuffer **fb)
{
   assert(fb);
   if (*fb) {
d249 1
d251 5
a255 5
      _glthread_LOCK_MUTEX((*fb)->Mutex);
      ASSERT((*fb)->RefCount > 0);
      (*fb)->RefCount--;
      deleteFlag = ((*fb)->RefCount == 0);
      _glthread_UNLOCK_MUTEX((*fb)->Mutex);
d258 5
a262 1
         (*fb)->Delete(*fb);
d264 5
a268 1
      *fb = NULL;
a272 2


a301 1
            /* could just as well pass rb->_ActualFormat here */
d427 1
a427 1
 * sizes, set the framebuffer's width and height to zero.
d432 1
a432 1
update_framebuffer_size(struct gl_framebuffer *fb)
d434 1
a434 1
   GLboolean haveSize = GL_FALSE;
d444 2
a445 13
         if (haveSize) {
            if (rb->Width != fb->Width && rb->Height != fb->Height) {
               /* size mismatch! */
               fb->Width = 0;
               fb->Height = 0;
               return;
            }
         }
         else {
            fb->Width = rb->Width;
            fb->Height = rb->Height;
            haveSize = GL_TRUE;
         }
d448 9
d476 1
a476 1
      update_framebuffer_size(buffer);
d529 1
a529 1
   _mesa_bzero(&fb->Visual, sizeof(fb->Visual));
d539 1
a539 1
   /* find first RGB or CI renderbuffer */
d543 8
a550 5
         if (rb->_BaseFormat == GL_RGBA || rb->_BaseFormat == GL_RGB) {
            fb->Visual.redBits = rb->RedBits;
            fb->Visual.greenBits = rb->GreenBits;
            fb->Visual.blueBits = rb->BlueBits;
            fb->Visual.alphaBits = rb->AlphaBits;
d554 1
a554 5
            break;
         }
         else if (rb->_BaseFormat == GL_COLOR_INDEX) {
            fb->Visual.indexBits = rb->IndexBits;
            fb->Visual.rgbMode = GL_FALSE;
d561 3
d565 1
a565 2
      fb->Visual.depthBits
         = fb->Attachment[BUFFER_DEPTH].Renderbuffer->DepthBits;
d569 3
d573 1
a573 2
      fb->Visual.stencilBits
         = fb->Attachment[BUFFER_STENCIL].Renderbuffer->StencilBits;
d577 3
d581 4
a584 8
      fb->Visual.accumRedBits
         = fb->Attachment[BUFFER_ACCUM].Renderbuffer->RedBits;
      fb->Visual.accumGreenBits
         = fb->Attachment[BUFFER_ACCUM].Renderbuffer->GreenBits;
      fb->Visual.accumBlueBits
         = fb->Attachment[BUFFER_ACCUM].Renderbuffer->BlueBits;
      fb->Visual.accumAlphaBits
         = fb->Attachment[BUFFER_ACCUM].Renderbuffer->AlphaBits;
d613 1
a613 1
   if (depthRb && depthRb->_ActualFormat == GL_DEPTH24_STENCIL8_EXT) {
d617 1
a617 1
          || fb->_DepthBuffer->_BaseFormat != GL_DEPTH_COMPONENT) {
d654 1
a654 1
   if (stencilRb && stencilRb->_ActualFormat == GL_DEPTH24_STENCIL8_EXT) {
d658 1
a658 1
          || fb->_StencilBuffer->_BaseFormat != GL_STENCIL_INDEX) {
d802 3
a804 2
      _mesa_test_framebuffer_completeness(ctx, fb);
      _mesa_update_framebuffer_visual(fb);
d827 6
a832 2
   struct gl_framebuffer *drawFb = ctx->DrawBuffer;
   struct gl_framebuffer *readFb = ctx->ReadBuffer;
d842 1
a842 1
 * glCopyTex[Sub]Image, etc. exists.
d850 6
a855 2
   const struct gl_renderbuffer_attachment *att
      = ctx->ReadBuffer->Attachment;
d879 2
a880 4
      /* XXX enable this post 6.5 release:
      ASSERT(ctx->ReadBuffer->_ColorReadBuffer->RedBits > 0 ||
             ctx->ReadBuffer->_ColorReadBuffer->IndexBits > 0);
      */
d887 1
a887 1
      ASSERT(att[BUFFER_DEPTH].Renderbuffer->DepthBits > 0);
d894 1
a894 1
      ASSERT(att[BUFFER_STENCIL].Renderbuffer->StencilBits > 0);
d901 1
d904 1
d920 1
a920 1
 * XXX code do some code merging w/ above function.
d925 6
a930 2
   const struct gl_renderbuffer_attachment *att
      = ctx->ReadBuffer->Attachment;
d951 1
a951 1
      /* nothing special */
d959 1
a959 1
      ASSERT(att[BUFFER_DEPTH].Renderbuffer->DepthBits > 0);
d966 1
a966 1
      ASSERT(att[BUFFER_STENCIL].Renderbuffer->StencilBits > 0);
d973 1
d976 1
d980 1
a980 1
                    "Unexpected format 0x%x in _mesa_source_buffer_exists",
d987 26
@


1.5
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d72 1
a72 1
   fb->_MRD = 1.0 / fb->_DepthMaxF;
d118 1
d339 78
@


1.4
log
@Update to Mesa 7.0.2. Tested by naddy@@ (full ports build), simon@@
and oga@@ (with dri enabled).
@
text
@d3 1
a3 1
 * Version:  6.5.1
d5 1
a5 1
 * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
d35 1
d70 3
a72 1
   fb->_MRD = 1.0;  /* Minimum resolvable depth value, for polygon offset */
d112 1
d114 1
a114 1
      fb->_ColorDrawBufferMask[0] = BUFFER_BIT_COLOR0;
d143 1
a143 1
   /* Init glRead/DrawBuffer state */
d145 1
d147 1
a147 1
      fb->_ColorDrawBufferMask[0] = BUFFER_BIT_BACK_LEFT;
d152 1
d154 1
a154 1
      fb->_ColorDrawBufferMask[0] = BUFFER_BIT_FRONT_LEFT;
d494 1
a494 1
         = fb->Attachment[BUFFER_DEPTH].Renderbuffer->RedBits;
d496 1
a496 1
         = fb->Attachment[BUFFER_DEPTH].Renderbuffer->GreenBits;
d498 1
a498 1
         = fb->Attachment[BUFFER_DEPTH].Renderbuffer->BlueBits;
d500 1
a500 1
         = fb->Attachment[BUFFER_DEPTH].Renderbuffer->AlphaBits;
d589 45
d635 1
a635 1
 * Update the list of color drawing renderbuffer pointers.
d644 10
a653 28
   /*
    * Fragment programs can write to multiple colorbuffers with
    * the GL_ARB_draw_buffers extension.
    */
   for (output = 0; output < ctx->Const.MaxDrawBuffers; output++) {
      GLbitfield bufferMask = fb->_ColorDrawBufferMask[output];
      GLuint count = 0;
      GLuint i;
      if (!fb->DeletePending) {
         /* We need the inner loop here because glDrawBuffer(GL_FRONT_AND_BACK)
          * can specify writing to two or four color buffers (for example).
          */
         for (i = 0; bufferMask && i < BUFFER_COUNT; i++) {
            const GLuint bufferBit = 1 << i;
            if (bufferBit & bufferMask) {
               struct gl_renderbuffer *rb = fb->Attachment[i].Renderbuffer;
               if (rb && rb->Width > 0 && rb->Height > 0) {
                  fb->_ColorDrawBuffers[output][count] = rb;
                  count++;
               }
               else {
                  /*
                  _mesa_warning(ctx, "DrawBuffer names a missing buffer!\n");
                  */
               }
               bufferMask &= ~bufferBit;
            }
         }
a654 1
      fb->_NumColorDrawBuffers[output] = count;
d660 1
a660 1
 * Update the color read renderbuffer pointer.
d683 2
a684 1
 * Update state related to the current draw/read framebuffers.
d691 5
a695 3
 * If the current framebuffer is user-created, make sure it's complete.
 * The following functions can effect this state:  glReadBuffer,
 * glDrawBuffer, glDrawBuffersARB, glFramebufferRenderbufferEXT,
d698 2
a699 2
void
_mesa_update_framebuffer(GLcontext *ctx)
d701 17
a717 4
   struct gl_framebuffer *fb = ctx->DrawBuffer;

   /* Completeness only matters for user-created framebuffers */
   if (fb->Name != 0) {
d722 5
d733 15
@


1.3
log
@merge Mesa 7.0.1
@
text
@d41 1
d194 1
a194 8
         /* render to texture */
         att->Texture->RefCount--;
         if (att->Texture->RefCount == 0) {
            GET_CURRENT_CONTEXT(ctx);
            if (ctx) {
               ctx->Driver.DeleteTexture(ctx, att->Texture);
            }
         }
d196 2
a198 1
      att->Texture = NULL;
@


1.2
log
@assorted fixes for dealing with zero-size frame/renderbuffers.

from freedesktop (mesa-commits) with help from games/bzflag;
ok matthieu@@
@
text
@a72 36
 * Set the framebuffer's _DepthBuffer field, taking care of
 * reference counts, etc.
 */
static void
set_depth_renderbuffer(struct gl_framebuffer *fb,
                       struct gl_renderbuffer *rb)
{
   if (fb->_DepthBuffer) {
      _mesa_dereference_renderbuffer(&fb->_DepthBuffer);
   }
   fb->_DepthBuffer = rb;
   if (rb) {
      rb->RefCount++;
   }
}


/**
 * Set the framebuffer's _StencilBuffer field, taking care of
 * reference counts, etc.
 */
static void
set_stencil_renderbuffer(struct gl_framebuffer *fb,
                         struct gl_renderbuffer *rb)
{
   if (fb->_StencilBuffer) {
      _mesa_dereference_renderbuffer(&fb->_StencilBuffer);
   }
   fb->_StencilBuffer = rb;
   if (rb) {
      rb->RefCount++;
   }
}


/**
d133 2
a166 1
      _glthread_DESTROY_MUTEX(fb->Mutex);
d183 3
d190 10
a199 6
         struct gl_renderbuffer *rb = att->Renderbuffer;
         /* remove framebuffer's reference to renderbuffer */
         _mesa_dereference_renderbuffer(&rb);
         if (rb && rb->Name == 0) {
            /* delete window system renderbuffer */
            _mesa_dereference_renderbuffer(&rb);
d203 1
a203 1
      att->Renderbuffer = NULL;
d206 27
a232 3
   /* unbind depth/stencil to decr ref counts */
   set_depth_renderbuffer(fb, NULL);
   set_stencil_renderbuffer(fb, NULL);
d237 2
a238 1
 * Decrement the reference count on a framebuffer and delete it when
d240 1
a240 1
 * Note: we pass the address of a pointer and set it to NULL if we delete it.
d243 1
a243 1
_mesa_dereference_framebuffer(struct gl_framebuffer **fb)
d245 3
a247 1
   GLboolean deleteFlag = GL_FALSE;
d249 1
a249 2
   _glthread_LOCK_MUTEX((*fb)->Mutex);
   {
d253 4
a256 2
   }
   _glthread_UNLOCK_MUTEX((*fb)->Mutex);
a257 2
   if (deleteFlag) {
      (*fb)->Delete(*fb);
d536 1
a536 1
         set_depth_renderbuffer(fb, wrapper);
d542 1
a542 1
      set_depth_renderbuffer(fb, depthRb);
d577 1
a577 1
         set_stencil_renderbuffer(fb, wrapper);
d583 1
a583 1
      set_stencil_renderbuffer(fb, stencilRb);
d606 18
a623 13
      /* We need the inner loop here because glDrawBuffer(GL_FRONT_AND_BACK)
       * can specify writing to two or four color buffers (for example).
       */
      for (i = 0; bufferMask && i < BUFFER_COUNT; i++) {
         const GLuint bufferBit = 1 << i;
         if (bufferBit & bufferMask) {
            struct gl_renderbuffer *rb = fb->Attachment[i].Renderbuffer;
            if (rb && rb->Width > 0 && rb->Height > 0) {
               fb->_ColorDrawBuffers[output][count] = rb;
               count++;
            }
            else {
               /*_mesa_warning(ctx, "DrawBuffer names a missing buffer!\n");*/
a624 1
            bufferMask &= ~bufferBit;
d641 1
@


1.1
log
@Initial revision
@
text
@d330 2
a331 2
   /* to update scissor / window bounds */
   if (ctx)
d333 5
d615 1
a615 1
            if (rb) {
d638 3
a640 1
   if (fb->_ColorReadBufferIndex == -1) {
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d330 2
a331 2
   if (ctx) {
      /* update scissor / window bounds */
a332 5
      /* Signal new buffer state so that swrast will update its clipping
       * info (the CLIP_BIT flag).
       */
      ctx->NewState |= _NEW_BUFFERS;
   }
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d73 36
a168 2
   fb->RefCount = 1;

d201 1
a217 3
   assert(fb->RefCount == 0);

   _glthread_DESTROY_MUTEX(fb->Mutex);
d222 6
a227 10
         _mesa_reference_renderbuffer(&att->Renderbuffer, NULL);
      }
      if (att->Texture) {
         /* render to texture */
         att->Texture->RefCount--;
         if (att->Texture->RefCount == 0) {
            GET_CURRENT_CONTEXT(ctx);
            if (ctx) {
               ctx->Driver.DeleteTexture(ctx, att->Texture);
            }
d231 1
a231 1
      att->Texture = NULL;
d234 3
a236 27
   /* unbind _Depth/_StencilBuffer to decr ref counts */
   _mesa_reference_renderbuffer(&fb->_DepthBuffer, NULL);
   _mesa_reference_renderbuffer(&fb->_StencilBuffer, NULL);
}


/**
 * Set *ptr to point to fb, with refcounting and locking.
 */
void
_mesa_reference_framebuffer(struct gl_framebuffer **ptr,
                            struct gl_framebuffer *fb)
{
   assert(ptr);
   if (*ptr == fb) {
      /* no change */
      return;
   }
   if (*ptr) {
      _mesa_unreference_framebuffer(ptr);
   }
   assert(!*ptr);
   assert(fb);
   _glthread_LOCK_MUTEX(fb->Mutex);
   fb->RefCount++;
   _glthread_UNLOCK_MUTEX(fb->Mutex);
   *ptr = fb;
d241 1
a241 2
 * Undo/remove a reference to a framebuffer object.
 * Decrement the framebuffer object's reference count and delete it when
d243 1
a243 1
 * Note: we pass the address of a pointer and set it to NULL.
d246 1
a246 1
_mesa_unreference_framebuffer(struct gl_framebuffer **fb)
d248 1
a248 3
   assert(fb);
   if (*fb) {
      GLboolean deleteFlag = GL_FALSE;
d250 2
a251 1
      _glthread_LOCK_MUTEX((*fb)->Mutex);
d255 2
a256 4
      _glthread_UNLOCK_MUTEX((*fb)->Mutex);
      
      if (deleteFlag)
         (*fb)->Delete(*fb);
d258 2
d538 1
a538 1
         _mesa_reference_renderbuffer(&fb->_DepthBuffer, wrapper);
d544 1
a544 1
      _mesa_reference_renderbuffer(&fb->_DepthBuffer, depthRb);
d579 1
a579 1
         _mesa_reference_renderbuffer(&fb->_StencilBuffer, wrapper);
d585 1
a585 1
      _mesa_reference_renderbuffer(&fb->_StencilBuffer, stencilRb);
d608 13
a620 18
      if (!fb->DeletePending) {
         /* We need the inner loop here because glDrawBuffer(GL_FRONT_AND_BACK)
          * can specify writing to two or four color buffers (for example).
          */
         for (i = 0; bufferMask && i < BUFFER_COUNT; i++) {
            const GLuint bufferBit = 1 << i;
            if (bufferBit & bufferMask) {
               struct gl_renderbuffer *rb = fb->Attachment[i].Renderbuffer;
               if (rb && rb->Width > 0 && rb->Height > 0) {
                  fb->_ColorDrawBuffers[output][count] = rb;
                  count++;
               }
               else {
                  /*
                  _mesa_warning(ctx, "DrawBuffer names a missing buffer!\n");
                  */
               }
               bufferMask &= ~bufferBit;
d622 1
d638 1
a638 4
   if (fb->_ColorReadBufferIndex == -1 ||
       fb->DeletePending ||
       fb->Width == 0 ||
       fb->Height == 0) {
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d3 1
a3 1
 * Version:  7.2
d5 1
a5 1
 * Copyright (C) 1999-2008  Brian Paul   All Rights Reserved.
a34 1
#include "buffers.h"
a36 3
#include "enums.h"
#include "formats.h"
#include "macros.h"
a40 1
#include "texobj.h"
d68 2
a70 3
   /* Minimum resolvable depth value, for polygon offset */
   fb->_MRD = (GLfloat)1.0 / fb->_DepthMaxF;
}
d80 1
a80 1
_mesa_create_framebuffer(const struct gl_config *visual)
d85 1
a85 1
      _mesa_initialize_window_framebuffer(fb, visual);
d99 1
a99 1
_mesa_new_framebuffer(struct gl_context *ctx, GLuint name)
d106 7
a112 1
      _mesa_initialize_user_framebuffer(fb, name);
d121 1
a121 1
 * \sa _mesa_initialize_user_framebuffer
d124 1
a124 2
_mesa_initialize_window_framebuffer(struct gl_framebuffer *fb,
				     const struct gl_config *visual)
d129 1
a129 1
   memset(fb, 0, sizeof(struct gl_framebuffer));
d138 1
a138 1
   /* Init read/draw renderbuffer state */
a139 1
      fb->_NumColorDrawBuffers = 1;
d141 1
a141 1
      fb->_ColorDrawBufferIndexes[0] = BUFFER_BACK_LEFT;
a145 1
      fb->_NumColorDrawBuffers = 1;
d147 1
a147 1
      fb->_ColorDrawBufferIndexes[0] = BUFFER_FRONT_LEFT;
a159 24
 * Initialize a user-created gl_framebuffer object.
 * \sa _mesa_initialize_window_framebuffer
 */
void
_mesa_initialize_user_framebuffer(struct gl_framebuffer *fb, GLuint name)
{
   assert(fb);
   assert(name);

   memset(fb, 0, sizeof(struct gl_framebuffer));

   fb->Name = name;
   fb->RefCount = 1;
   fb->_NumColorDrawBuffers = 1;
   fb->ColorDrawBuffer[0] = GL_COLOR_ATTACHMENT0_EXT;
   fb->_ColorDrawBufferIndexes[0] = BUFFER_COLOR0;
   fb->ColorReadBuffer = GL_COLOR_ATTACHMENT0_EXT;
   fb->_ColorReadBufferIndex = BUFFER_COLOR0;
   fb->Delete = _mesa_destroy_framebuffer;
   _glthread_INIT_MUTEX(fb->Mutex);
}


/**
d168 1
a168 1
      free(fb);
d193 8
a200 1
         _mesa_reference_texobj(&att->Texture, NULL);
a201 2
      ASSERT(!att->Renderbuffer);
      ASSERT(!att->Texture);
d203 1
d224 11
d236 11
a246 2
   if (*ptr) {
      /* unreference old renderbuffer */
a247 1
      struct gl_framebuffer *oldFb = *ptr;
d249 5
a253 5
      _glthread_LOCK_MUTEX(oldFb->Mutex);
      ASSERT(oldFb->RefCount > 0);
      oldFb->RefCount--;
      deleteFlag = (oldFb->RefCount == 0);
      _glthread_UNLOCK_MUTEX(oldFb->Mutex);
d256 1
a256 1
         oldFb->Delete(oldFb);
d258 1
a258 1
      *ptr = NULL;
d260 2
a261 1
   assert(!*ptr);
a262 7
   if (fb) {
      _glthread_LOCK_MUTEX(fb->Mutex);
      fb->RefCount++;
      _glthread_UNLOCK_MUTEX(fb->Mutex);
      *ptr = fb;
   }
}
d276 1
a276 1
_mesa_resize_framebuffer(struct gl_context *ctx, struct gl_framebuffer *fb,
d294 1
a338 78

/**
 * XXX THIS IS OBSOLETE - drivers should take care of detecting window
 * size changes and act accordingly, likely calling _mesa_resize_framebuffer().
 *
 * GL_MESA_resize_buffers extension.
 *
 * When this function is called, we'll ask the window system how large
 * the current window is.  If it's a new size, we'll call the driver's
 * ResizeBuffers function.  The driver will then resize its color buffers
 * as needed, and maybe call the swrast's routine for reallocating
 * swrast-managed depth/stencil/accum/etc buffers.
 * \note This function should only be called through the GL API, not
 * from device drivers (as was done in the past).
 */
void
_mesa_resizebuffers( struct gl_context *ctx )
{
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH( ctx );

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glResizeBuffersMESA\n");

   if (!ctx->Driver.GetBufferSize) {
      return;
   }

   if (ctx->WinSysDrawBuffer) {
      GLuint newWidth, newHeight;
      struct gl_framebuffer *buffer = ctx->WinSysDrawBuffer;

      assert(buffer->Name == 0);

      /* ask device driver for size of output buffer */
      ctx->Driver.GetBufferSize( buffer, &newWidth, &newHeight );

      /* see if size of device driver's color buffer (window) has changed */
      if (buffer->Width != newWidth || buffer->Height != newHeight) {
         if (ctx->Driver.ResizeBuffers)
            ctx->Driver.ResizeBuffers(ctx, buffer, newWidth, newHeight );
      }
   }

   if (ctx->WinSysReadBuffer
       && ctx->WinSysReadBuffer != ctx->WinSysDrawBuffer) {
      GLuint newWidth, newHeight;
      struct gl_framebuffer *buffer = ctx->WinSysReadBuffer;

      assert(buffer->Name == 0);

      /* ask device driver for size of read buffer */
      ctx->Driver.GetBufferSize( buffer, &newWidth, &newHeight );

      /* see if size of device driver's color buffer (window) has changed */
      if (buffer->Width != newWidth || buffer->Height != newHeight) {
         if (ctx->Driver.ResizeBuffers)
            ctx->Driver.ResizeBuffers(ctx, buffer, newWidth, newHeight );
      }
   }

   ctx->NewState |= _NEW_BUFFERS;  /* to update scissor / window bounds */
}


/*
 * XXX THIS IS OBSOLETE
 */
void GLAPIENTRY
_mesa_ResizeBuffersMESA( void )
{
   GET_CURRENT_CONTEXT(ctx);

   if (ctx->Extensions.MESA_resize_buffers)
      _mesa_resizebuffers( ctx );
}



d342 1
a342 1
 * sizes, set the framebuffer's width and height to the min size.
d347 1
a347 1
update_framebuffer_size(struct gl_context *ctx, struct gl_framebuffer *fb)
d349 1
a349 1
   GLuint minWidth = ~0, minHeight = ~0;
d359 13
a371 2
         minWidth = MIN2(minWidth, rb->Width);
         minHeight = MIN2(minHeight, rb->Height);
a373 9

   if (minWidth != ~0) {
      fb->Width = minWidth;
      fb->Height = minHeight;
   }
   else {
      fb->Width = 0;
      fb->Height = 0;
   }
d384 1
a384 1
_mesa_update_draw_buffer_bounds(struct gl_context *ctx)
d393 1
a393 1
      update_framebuffer_size(ctx, buffer);
d446 1
a446 1
   memset(&fb->Visual, 0, sizeof(fb->Visual));
d456 1
a456 1
   /* find first RGB renderbuffer */
d460 5
a464 9
         const GLenum baseFormat = _mesa_get_format_base_format(rb->Format);
         const gl_format fmt = rb->Format;
         
         if (baseFormat == GL_RGBA || baseFormat == GL_RGB ||
	     baseFormat == GL_ALPHA) {
            fb->Visual.redBits = _mesa_get_format_bits(fmt, GL_RED_BITS);
            fb->Visual.greenBits = _mesa_get_format_bits(fmt, GL_GREEN_BITS);
            fb->Visual.blueBits = _mesa_get_format_bits(fmt, GL_BLUE_BITS);
            fb->Visual.alphaBits = _mesa_get_format_bits(fmt, GL_ALPHA_BITS);
d468 5
a472 1
            fb->Visual.samples = rb->NumSamples;
a478 3
      const struct gl_renderbuffer *rb =
         fb->Attachment[BUFFER_DEPTH].Renderbuffer;
      const gl_format fmt = rb->Format;
d480 2
a481 1
      fb->Visual.depthBits = _mesa_get_format_bits(fmt, GL_DEPTH_BITS);
a484 3
      const struct gl_renderbuffer *rb =
         fb->Attachment[BUFFER_STENCIL].Renderbuffer;
      const gl_format fmt = rb->Format;
d486 2
a487 1
      fb->Visual.stencilBits = _mesa_get_format_bits(fmt, GL_STENCIL_BITS);
a490 3
      const struct gl_renderbuffer *rb =
         fb->Attachment[BUFFER_ACCUM].Renderbuffer;
      const gl_format fmt = rb->Format;
d492 8
a499 4
      fb->Visual.accumRedBits = _mesa_get_format_bits(fmt, GL_RED_BITS);
      fb->Visual.accumGreenBits = _mesa_get_format_bits(fmt, GL_GREEN_BITS);
      fb->Visual.accumBlueBits = _mesa_get_format_bits(fmt, GL_BLUE_BITS);
      fb->Visual.accumAlphaBits = _mesa_get_format_bits(fmt, GL_ALPHA_BITS);
d517 1
a517 1
_mesa_update_depth_buffer(struct gl_context *ctx,
d528 1
a528 1
   if (depthRb && _mesa_is_format_packed_depth_stencil(depthRb->Format)) {
d532 1
a532 1
          || _mesa_get_format_base_format(fb->_DepthBuffer->Format) != GL_DEPTH_COMPONENT) {
d558 1
a558 1
_mesa_update_stencil_buffer(struct gl_context *ctx,
d569 1
a569 1
   if (stencilRb && _mesa_is_format_packed_depth_stencil(stencilRb->Format)) {
d573 1
a573 1
          || _mesa_get_format_base_format(fb->_StencilBuffer->Format) != GL_STENCIL_INDEX) {
a587 45
/*
 * Example DrawBuffers scenarios:
 *
 * 1. glDrawBuffer(GL_FRONT_AND_BACK), fixed-func or shader writes to
 * "gl_FragColor" or program writes to the "result.color" register:
 *
 *   fragment color output   renderbuffer
 *   ---------------------   ---------------
 *   color[0]                Front, Back
 *
 *
 * 2. glDrawBuffers(3, [GL_FRONT, GL_AUX0, GL_AUX1]), shader writes to
 * gl_FragData[i] or program writes to result.color[i] registers:
 *
 *   fragment color output   renderbuffer
 *   ---------------------   ---------------
 *   color[0]                Front
 *   color[1]                Aux0
 *   color[3]                Aux1
 *
 *
 * 3. glDrawBuffers(3, [GL_FRONT, GL_AUX0, GL_AUX1]) and shader writes to
 * gl_FragColor, or fixed function:
 *
 *   fragment color output   renderbuffer
 *   ---------------------   ---------------
 *   color[0]                Front, Aux0, Aux1
 *
 *
 * In either case, the list of renderbuffers is stored in the
 * framebuffer->_ColorDrawBuffers[] array and
 * framebuffer->_NumColorDrawBuffers indicates the number of buffers.
 * The renderer (like swrast) has to look at the current fragment shader
 * to see if it writes to gl_FragColor vs. gl_FragData[i] to determine
 * how to map color outputs to renderbuffers.
 *
 * Note that these two calls are equivalent (for fixed function fragment
 * shading anyway):
 *   a)  glDrawBuffer(GL_FRONT_AND_BACK);  (assuming non-stereo framebuffer)
 *   b)  glDrawBuffers(2, [GL_FRONT_LEFT, GL_BACK_LEFT]);
 */




d589 1
a589 1
 * Update the (derived) list of color drawing renderbuffer pointers.
d594 1
a594 1
update_color_draw_buffers(struct gl_context *ctx, struct gl_framebuffer *fb)
d598 28
a625 10
   /* set 0th buffer to NULL now in case _NumColorDrawBuffers is zero */
   fb->_ColorDrawBuffers[0] = NULL;

   for (output = 0; output < fb->_NumColorDrawBuffers; output++) {
      GLint buf = fb->_ColorDrawBufferIndexes[output];
      if (buf >= 0) {
         fb->_ColorDrawBuffers[output] = fb->Attachment[buf].Renderbuffer;
      }
      else {
         fb->_ColorDrawBuffers[output] = NULL;
d627 1
d633 1
a633 1
 * Update the (derived) color read renderbuffer pointer.
d637 1
a637 1
update_color_read_buffer(struct gl_context *ctx, struct gl_framebuffer *fb)
d656 1
a656 2
 * Update a gl_framebuffer's derived state.
 *
d663 3
a665 5
 *
 * If the framebuffer is user-created, make sure it's complete.
 *
 * The following functions (at least) can effect framebuffer state:
 * glReadBuffer, glDrawBuffer, glDrawBuffersARB, glFramebufferRenderbufferEXT,
d668 2
a669 2
static void
update_framebuffer(struct gl_context *ctx, struct gl_framebuffer *fb)
d671 6
a676 20
   if (fb->Name == 0) {
      /* This is a window-system framebuffer */
      /* Need to update the FB's GL_DRAW_BUFFER state to match the
       * context state (GL_READ_BUFFER too).
       */
      if (fb->ColorDrawBuffer[0] != ctx->Color.DrawBuffer[0]) {
         _mesa_drawbuffers(ctx, ctx->Const.MaxDrawBuffers,
                           ctx->Color.DrawBuffer, NULL);
      }
      if (fb->ColorReadBuffer != ctx->Pixel.ReadBuffer) {
         
      }
   }
   else {
      /* This is a user-created framebuffer.
       * Completeness only matters for user-created framebuffers.
       */
      if (fb->_Status != GL_FRAMEBUFFER_COMPLETE) {
         _mesa_test_framebuffer_completeness(ctx, fb);
      }
a678 5
   /* Strictly speaking, we don't need to update the draw-state
    * if this FB is bound as ctx->ReadBuffer (and conversely, the
    * read-state if this FB is bound as ctx->DrawBuffer), but no
    * harm.
    */
a688 19
 * Update state related to the current draw/read framebuffers.
 */
void
_mesa_update_framebuffer(struct gl_context *ctx)
{
   struct gl_framebuffer *drawFb;
   struct gl_framebuffer *readFb;

   assert(ctx);
   drawFb = ctx->DrawBuffer;
   readFb = ctx->ReadBuffer;

   update_framebuffer(ctx, drawFb);
   if (readFb != drawFb)
      update_framebuffer(ctx, readFb);
}


/**
d690 1
a690 1
 * glCopyTex[Sub]Image, etc) exists.
d696 1
a696 1
_mesa_source_buffer_exists(struct gl_context *ctx, GLenum format)
d698 2
a699 6
   const struct gl_renderbuffer_attachment *att = ctx->ReadBuffer->Attachment;

   /* If we don't know the framebuffer status, update it now */
   if (ctx->ReadBuffer->_Status == 0) {
      _mesa_test_framebuffer_completeness(ctx, ctx->ReadBuffer);
   }
a713 1
   case GL_RG:
a719 10
   case GL_RED_INTEGER_EXT:
   case GL_GREEN_INTEGER_EXT:
   case GL_BLUE_INTEGER_EXT:
   case GL_ALPHA_INTEGER_EXT:
   case GL_RGB_INTEGER_EXT:
   case GL_RGBA_INTEGER_EXT:
   case GL_BGR_INTEGER_EXT:
   case GL_BGRA_INTEGER_EXT:
   case GL_LUMINANCE_INTEGER_EXT:
   case GL_LUMINANCE_ALPHA_INTEGER_EXT:
d723 4
a726 5
      ASSERT(_mesa_get_format_bits(ctx->ReadBuffer->_ColorReadBuffer->Format, GL_RED_BITS) > 0 ||
             _mesa_get_format_bits(ctx->ReadBuffer->_ColorReadBuffer->Format, GL_ALPHA_BITS) > 0 ||
             _mesa_get_format_bits(ctx->ReadBuffer->_ColorReadBuffer->Format, GL_TEXTURE_LUMINANCE_SIZE) > 0 ||
             _mesa_get_format_bits(ctx->ReadBuffer->_ColorReadBuffer->Format, GL_TEXTURE_INTENSITY_SIZE) > 0 ||
             _mesa_get_format_bits(ctx->ReadBuffer->_ColorReadBuffer->Format, GL_INDEX_BITS) > 0);
d733 1
a733 1
      /*ASSERT(att[BUFFER_DEPTH].Renderbuffer->DepthBits > 0);*/
d740 1
a740 1
      /*ASSERT(att[BUFFER_STENCIL].Renderbuffer->StencilBits > 0);*/
a746 1
      /*
a748 1
      */
d764 1
a764 1
 * XXX could do some code merging w/ above function.
d767 1
a767 1
_mesa_dest_buffer_exists(struct gl_context *ctx, GLenum format)
d769 2
a770 6
   const struct gl_renderbuffer_attachment *att = ctx->DrawBuffer->Attachment;

   /* If we don't know the framebuffer status, update it now */
   if (ctx->DrawBuffer->_Status == 0) {
      _mesa_test_framebuffer_completeness(ctx, ctx->DrawBuffer);
   }
d791 1
a791 11
   case GL_RED_INTEGER_EXT:
   case GL_GREEN_INTEGER_EXT:
   case GL_BLUE_INTEGER_EXT:
   case GL_ALPHA_INTEGER_EXT:
   case GL_RGB_INTEGER_EXT:
   case GL_RGBA_INTEGER_EXT:
   case GL_BGR_INTEGER_EXT:
   case GL_BGRA_INTEGER_EXT:
   case GL_LUMINANCE_INTEGER_EXT:
   case GL_LUMINANCE_ALPHA_INTEGER_EXT:
      /* Nothing special since GL_DRAW_BUFFER could be GL_NONE. */
d799 1
a799 1
      /*ASSERT(att[BUFFER_DEPTH].Renderbuffer->DepthBits > 0);*/
d806 1
a806 1
      /*ASSERT(att[BUFFER_STENCIL].Renderbuffer->StencilBits > 0);*/
a812 1
      /*
a814 1
      */
d818 1
a818 1
                    "Unexpected format 0x%x in _mesa_dest_buffer_exists",
a824 74
}


/**
 * Used to answer the GL_IMPLEMENTATION_COLOR_READ_FORMAT_OES query.
 */
GLenum
_mesa_get_color_read_format(struct gl_context *ctx)
{
   switch (ctx->ReadBuffer->_ColorReadBuffer->Format) {
   case MESA_FORMAT_ARGB8888:
      return GL_BGRA;
   case MESA_FORMAT_RGB565:
      return GL_BGR;
   default:
      return GL_RGBA;
   }
}


/**
 * Used to answer the GL_IMPLEMENTATION_COLOR_READ_TYPE_OES query.
 */
GLenum
_mesa_get_color_read_type(struct gl_context *ctx)
{
   switch (ctx->ReadBuffer->_ColorReadBuffer->Format) {
   case MESA_FORMAT_ARGB8888:
      return GL_UNSIGNED_BYTE;
   case MESA_FORMAT_RGB565:
      return GL_UNSIGNED_SHORT_5_6_5_REV;
   default:
      return GL_UNSIGNED_BYTE;
   }
}


/**
 * Print framebuffer info to stderr, for debugging.
 */
void
_mesa_print_framebuffer(const struct gl_framebuffer *fb)
{
   GLuint i;

   fprintf(stderr, "Mesa Framebuffer %u at %p\n", fb->Name, (void *) fb);
   fprintf(stderr, "  Size: %u x %u  Status: %s\n", fb->Width, fb->Height,
           _mesa_lookup_enum_by_nr(fb->_Status));
   fprintf(stderr, "  Attachments:\n");

   for (i = 0; i < BUFFER_COUNT; i++) {
      const struct gl_renderbuffer_attachment *att = &fb->Attachment[i];
      if (att->Type == GL_TEXTURE) {
         const struct gl_texture_image *texImage;
         fprintf(stderr,
                 "  %2d: Texture %u, level %u, face %u, slice %u, complete %d\n",
                 i, att->Texture->Name, att->TextureLevel, att->CubeMapFace,
                 att->Zoffset, att->Complete);
         texImage = att->Texture->Image[att->CubeMapFace][att->TextureLevel];
         fprintf(stderr, "       Size: %u x %u x %u  Format %s\n",
                 texImage->Width, texImage->Height, texImage->Depth,
                 _mesa_get_format_name(texImage->TexFormat));
      }
      else if (att->Type == GL_RENDERBUFFER) {
         fprintf(stderr, "  %2d: Renderbuffer %u, complete %d\n",
                 i, att->Renderbuffer->Name, att->Complete);
         fprintf(stderr, "       Size: %u x %u  Format %s\n",
                 att->Renderbuffer->Width, att->Renderbuffer->Height,
                 _mesa_get_format_name(att->Renderbuffer->Format));
      }
      else {
         fprintf(stderr, "  %2d: none\n", i);
      }
   }
@


1.1.1.5
log
@Import Mesa 9.2.0
@
text
@d3 1
d20 3
a22 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
a34 1
#include "blend.h"
d37 1
a45 1
#include "glformats.h"
a156 2
   fb->_AllColorBuffersFixedPoint = !visual->floatMode;
   fb->_HasSNormOrFloatColorBuffer = visual->floatMode;
d226 4
a234 2
 * This is normally only called from the _mesa_reference_framebuffer() macro
 * when there's a real pointer change.
d237 2
a238 2
_mesa_reference_framebuffer_(struct gl_framebuffer **ptr,
                             struct gl_framebuffer *fb)
d240 6
d293 2
a294 2
   /* Can only resize win-sys framebuffer objects */
   assert(_mesa_is_winsys_fbo(fb));
d314 18
d345 79
d438 1
a438 1
   assert(_mesa_is_user_fbo(fb));
d474 1
a474 1
   if (_mesa_is_user_fbo(buffer)) {
d525 1
a525 2
_mesa_update_framebuffer_visual(struct gl_context *ctx,
				struct gl_framebuffer *fb)
d545 3
a547 9

         /* Grab samples and sampleBuffers from any attachment point (assuming
          * the framebuffer is complete, we'll get the same answer from all
          * attachments).
          */
         fb->Visual.samples = rb->NumSamples;
         fb->Visual.sampleBuffers = rb->NumSamples > 0 ? 1 : 0;

         if (_mesa_is_legal_color_format(ctx, baseFormat)) {
d554 2
a555 15
            if (_mesa_get_format_color_encoding(fmt) == GL_SRGB)
                fb->Visual.sRGBCapable = ctx->Extensions.EXT_framebuffer_sRGB;
            break;
         }
      }
   }

   fb->Visual.floatMode = GL_FALSE;
   for (i = 0; i < BUFFER_COUNT; i++) {
      if (fb->Attachment[i].Renderbuffer) {
         const struct gl_renderbuffer *rb = fb->Attachment[i].Renderbuffer;
         const gl_format fmt = rb->Format;

         if (_mesa_get_format_datatype(fmt) == GL_FLOAT) {
            fb->Visual.floatMode = GL_TRUE;
d592 82
d774 2
d786 1
a786 1
   if (_mesa_is_winsys_fbo(fb)) {
d795 3
d815 2
a837 3

   _mesa_update_clamp_vertex_color(ctx);
   _mesa_update_clamp_fragment_color(ctx);
d842 2
a843 1
 * Check if the renderbuffer for a read/draw operation exists.
a845 2
 * \param reading  if TRUE, we're going to read from the buffer,
                   if FALSE, we're going to write to the buffer.
d848 2
a849 5
static GLboolean
renderbuffer_exists(struct gl_context *ctx,
                    struct gl_framebuffer *fb,
                    GLenum format,
                    GLboolean reading)
d851 1
a851 1
   const struct gl_renderbuffer_attachment *att = fb->Attachment;
d854 2
a855 2
   if (fb->_Status == 0) {
      _mesa_test_framebuffer_completeness(ctx, fb);
d858 1
a858 1
   if (fb->_Status != GL_FRAMEBUFFER_COMPLETE_EXT) {
d877 1
a878 1
   case GL_RG_INTEGER:
d888 2
a889 15
      if (reading) {
         /* about to read from a color buffer */
         const struct gl_renderbuffer *readBuf = fb->_ColorReadBuffer;
         if (!readBuf) {
            return GL_FALSE;
         }
         ASSERT(_mesa_get_format_bits(readBuf->Format, GL_RED_BITS) > 0 ||
                _mesa_get_format_bits(readBuf->Format, GL_ALPHA_BITS) > 0 ||
                _mesa_get_format_bits(readBuf->Format, GL_TEXTURE_LUMINANCE_SIZE) > 0 ||
                _mesa_get_format_bits(readBuf->Format, GL_TEXTURE_INTENSITY_SIZE) > 0 ||
                _mesa_get_format_bits(readBuf->Format, GL_INDEX_BITS) > 0);
      }
      else {
         /* about to draw to zero or more color buffers (none is OK) */
         return GL_TRUE;
d891 5
d899 1
a899 1
      if (att[BUFFER_DEPTH].Type == GL_NONE) {
d902 1
d906 1
a906 1
      if (att[BUFFER_STENCIL].Type == GL_NONE) {
d909 1
d912 2
a913 2
      if (att[BUFFER_DEPTH].Type == GL_NONE ||
          att[BUFFER_STENCIL].Type == GL_NONE) {
d916 4
d923 1
a923 1
                    "Unexpected format 0x%x in renderbuffer_exists",
a933 14
 * Check if the renderbuffer for a read operation (glReadPixels, glCopyPixels,
 * glCopyTex[Sub]Image, etc) exists.
 * \param format  a basic image format such as GL_RGB, GL_RGBA, GL_ALPHA,
 *                GL_DEPTH_COMPONENT, etc. or GL_COLOR, GL_DEPTH, GL_STENCIL.
 * \return GL_TRUE if buffer exists, GL_FALSE otherwise
 */
GLboolean
_mesa_source_buffer_exists(struct gl_context *ctx, GLenum format)
{
   return renderbuffer_exists(ctx, ctx->ReadBuffer, format, GL_TRUE);
}


/**
d935 1
d940 1
a940 2
   return renderbuffer_exists(ctx, ctx->DrawBuffer, format, GL_FALSE);
}
d942 4
d947 2
a948 14
/**
 * Used to answer the GL_IMPLEMENTATION_COLOR_READ_FORMAT_OES query.
 */
GLenum
_mesa_get_color_read_format(struct gl_context *ctx)
{
   if (!ctx->ReadBuffer || !ctx->ReadBuffer->_ColorReadBuffer) {
      /* The spec is unclear how to handle this case, but NVIDIA's
       * driver generates GL_INVALID_OPERATION.
       */
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glGetIntegerv(GL_IMPLEMENTATION_COLOR_READ_FORMAT: "
                  "no GL_READ_BUFFER)");
      return GL_NONE;
a949 3
   else {
      const GLenum format = ctx->ReadBuffer->_ColorReadBuffer->Format;
      const GLenum data_type = _mesa_get_format_datatype(format);
d951 32
a982 11
      if (format == MESA_FORMAT_ARGB8888)
         return GL_BGRA;
      else if (format == MESA_FORMAT_RGB565)
         return GL_BGR;

      switch (data_type) {
      case GL_UNSIGNED_INT:
      case GL_INT:
         return GL_RGBA_INTEGER;
      default:
         return GL_RGBA;
d984 24
d1009 3
d1016 1
a1016 1
 * Used to answer the GL_IMPLEMENTATION_COLOR_READ_TYPE_OES query.
d1019 1
a1019 1
_mesa_get_color_read_type(struct gl_context *ctx)
d1021 7
a1027 27
   if (!ctx->ReadBuffer || !ctx->ReadBuffer->_ColorReadBuffer) {
      /* The spec is unclear how to handle this case, but NVIDIA's
       * driver generates GL_INVALID_OPERATION.
       */
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glGetIntegerv(GL_IMPLEMENTATION_COLOR_READ_TYPE: "
                  "no GL_READ_BUFFER)");
      return GL_NONE;
   }
   else {
      const GLenum format = ctx->ReadBuffer->_ColorReadBuffer->Format;
      const GLenum data_type = _mesa_get_format_datatype(format);

      if (format == MESA_FORMAT_RGB565)
         return GL_UNSIGNED_SHORT_5_6_5_REV;

      switch (data_type) {
      case GL_SIGNED_NORMALIZED:
         return GL_BYTE;
      case GL_UNSIGNED_INT:
      case GL_INT:
      case GL_FLOAT:
         return data_type;
      case GL_UNSIGNED_NORMALIZED:
      default:
         return GL_UNSIGNED_BYTE;
      }
d1033 1
a1033 1
 * Returns the read renderbuffer for the specified format.
d1035 2
a1036 3
struct gl_renderbuffer *
_mesa_get_read_renderbuffer_for_format(const struct gl_context *ctx,
                                       GLenum format)
d1038 7
a1044 9
   const struct gl_framebuffer *rfb = ctx->ReadBuffer;

   if (_mesa_is_color_format(format)) {
      return rfb->Attachment[rfb->_ColorReadBufferIndex].Renderbuffer;
   } else if (_mesa_is_depth_format(format) ||
              _mesa_is_depthstencil_format(format)) {
      return rfb->Attachment[BUFFER_DEPTH].Renderbuffer;
   } else {
      return rfb->Attachment[BUFFER_STENCIL].Renderbuffer;
d1065 1
a1065 1
         const struct gl_texture_image *texImage = att->Renderbuffer->TexImage;
d1070 1
@


1.1.1.6
log
@Import Mesa 10.2.3
@
text
@d133 1
a133 1
   mtx_init(&fb->Mutex, mtx_plain);
d185 1
a185 1
   mtx_init(&fb->Mutex, mtx_plain);
a197 1
      free(fb->Label);
d215 1
a215 1
   mtx_destroy(&fb->Mutex);
d246 1
a246 1
      mtx_lock(&oldFb->Mutex);
d250 1
a250 1
      mtx_unlock(&oldFb->Mutex);
d260 1
a260 1
      mtx_lock(&fb->Mutex);
d262 1
a262 1
      mtx_unlock(&fb->Mutex);
a358 50
 * Calculate the inclusive bounding box for the scissor of a specific viewport
 *
 * \param ctx     GL context.
 * \param buffer  Framebuffer to be checked against
 * \param idx     Index of the desired viewport
 * \param bbox    Bounding box for the scissored viewport.  Stored as xmin,
 *                xmax, ymin, ymax.
 *
 * \warning This function assumes that the framebuffer dimensions are up to
 * date (e.g., update_framebuffer_size has been recently called on \c buffer).
 *
 * \sa _mesa_clip_to_region
 */
void
_mesa_scissor_bounding_box(const struct gl_context *ctx,
                           const struct gl_framebuffer *buffer,
                           unsigned idx, int *bbox)
{
   bbox[0] = 0;
   bbox[2] = 0;
   bbox[1] = buffer->Width;
   bbox[3] = buffer->Height;

   if (ctx->Scissor.EnableFlags & (1u << idx)) {
      if (ctx->Scissor.ScissorArray[idx].X > bbox[0]) {
         bbox[0] = ctx->Scissor.ScissorArray[idx].X;
      }
      if (ctx->Scissor.ScissorArray[idx].Y > bbox[2]) {
         bbox[2] = ctx->Scissor.ScissorArray[idx].Y;
      }
      if (ctx->Scissor.ScissorArray[idx].X + ctx->Scissor.ScissorArray[idx].Width < bbox[1]) {
         bbox[1] = ctx->Scissor.ScissorArray[idx].X + ctx->Scissor.ScissorArray[idx].Width;
      }
      if (ctx->Scissor.ScissorArray[idx].Y + ctx->Scissor.ScissorArray[idx].Height < bbox[3]) {
         bbox[3] = ctx->Scissor.ScissorArray[idx].Y + ctx->Scissor.ScissorArray[idx].Height;
      }
      /* finally, check for empty region */
      if (bbox[0] > bbox[1]) {
         bbox[0] = bbox[1];
      }
      if (bbox[2] > bbox[3]) {
         bbox[2] = bbox[3];
      }
   }

   ASSERT(bbox[0] <= bbox[1]);
   ASSERT(bbox[2] <= bbox[3]);
}

/**
a367 1
   int bbox[4];
d377 29
a405 6
   /* Default to the first scissor as that's always valid */
   _mesa_scissor_bounding_box(ctx, buffer, 0, bbox);
   buffer->_Xmin = bbox[0];
   buffer->_Ymin = bbox[2];
   buffer->_Xmax = bbox[1];
   buffer->_Ymax = bbox[3];
d443 1
a443 1
         const mesa_format fmt = rb->Format;
d470 1
a470 1
         const mesa_format fmt = rb->Format;
d482 1
a482 1
      const mesa_format fmt = rb->Format;
d490 1
a490 1
      const mesa_format fmt = rb->Format;
d498 1
a498 1
      const mesa_format fmt = rb->Format;
d814 1
a814 1
      if (format == MESA_FORMAT_B8G8R8A8_UNORM)
d816 1
a816 1
      else if (format == MESA_FORMAT_B5G6R5_UNORM)
d849 1
a849 1
      if (format == MESA_FORMAT_B5G6R5_UNORM)
@


