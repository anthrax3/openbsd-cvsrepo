head	1.11;
access;
symbols
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	v10_2_9:1.1.1.7
	v10_4_3:1.1.1.6
	v10_2_7:1.1.1.5
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	v10_2_3:1.1.1.5
	OPENBSD_5_5:1.7.0.2
	OPENBSD_5_5_BASE:1.7
	v9_2_5:1.1.1.4
	v9_2_3:1.1.1.4
	v9_2_2:1.1.1.4
	v9_2_1:1.1.1.4
	v9_2_0:1.1.1.4
	OPENBSD_5_4:1.6.0.4
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	v7_10_3:1.1.1.3
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.6
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.4
	v7_0_1:1.1.1.2
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2015.12.23.05.17.51;	author jsg;	state dead;
branches;
next	1.10;
commitid	TnlogFl9nOv2eaRf;

1.10
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.9;
commitid	4ry2gvZGMXkCUD2n;

1.9
date	2015.01.25.14.41.21;	author jsg;	state Exp;
branches;
next	1.8;
commitid	mcxB0JvoI9gTDYXU;

1.8
date	2014.07.09.21.09.00;	author jsg;	state Exp;
branches;
next	1.7;
commitid	WPD6rgPryPkvXOr9;

1.7
date	2013.09.05.14.06.14;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2012.08.17.13.58.17;	author mpi;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.23.13.37.42;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.30;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.41;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.20;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.49.40;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.49.40;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.56.31;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.10.23.13.29.45;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.09.05.13.16.21;	author jsg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2014.07.09.20.34.58;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.6
date	2015.01.25.14.12.24;	author jsg;	state Exp;
branches;
next	1.1.1.7;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.7
date	2015.02.20.22.49.31;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.11
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

/**
 * This file implements the glArrayElement() function.
 * It involves looking at the format/type of all the enabled vertex arrays
 * and emitting a list of pointers to functions which set the per-vertex
 * state for the element/index.
 */


/* Author:
 *    Keith Whitwell <keithw@@vmware.com>
 */

#include "glheader.h"
#include "arrayobj.h"
#include "api_arrayelt.h"
#include "bufferobj.h"
#include "context.h"
#include "imports.h"
#include "macros.h"
#include "mtypes.h"
#include "main/dispatch.h"

typedef void (GLAPIENTRY *array_func)( const void * );

typedef struct {
   const struct gl_client_array *array;
   int offset;
} AEarray;

typedef void (GLAPIENTRY *attrib_func)( GLuint indx, const void *data );

typedef struct {
   const struct gl_client_array *array;
   attrib_func func;
   GLuint index;
} AEattrib;

typedef struct {
   AEarray arrays[32];
   AEattrib attribs[VERT_ATTRIB_MAX + 1];
   GLuint NewState;

   /* List of VBOs we need to map before executing ArrayElements */
   struct gl_buffer_object *vbo[VERT_ATTRIB_MAX];
   GLuint nr_vbos;
   GLboolean mapped_vbos;  /**< Any currently mapped VBOs? */
} AEcontext;


/** Cast wrapper */
static INLINE AEcontext *
AE_CONTEXT(struct gl_context *ctx)
{
   return (AEcontext *) ctx->aelt_context;
}


/*
 * Convert GL_BYTE, GL_UNSIGNED_BYTE, .. GL_DOUBLE into an integer
 * in the range [0, 7].  Luckily these type tokens are sequentially
 * numbered in gl.h, except for GL_DOUBLE.
 */
static INLINE int
TYPE_IDX(GLenum t)
{
   return t == GL_DOUBLE ? 7 : t & 7;
}


#define NUM_TYPES 8


static const int ColorFuncs[2][NUM_TYPES] = {
   {
      _gloffset_Color3bv,
      _gloffset_Color3ubv,
      _gloffset_Color3sv,
      _gloffset_Color3usv,
      _gloffset_Color3iv,
      _gloffset_Color3uiv,
      _gloffset_Color3fv,
      _gloffset_Color3dv,
   },
   {
      _gloffset_Color4bv,
      _gloffset_Color4ubv,
      _gloffset_Color4sv,
      _gloffset_Color4usv,
      _gloffset_Color4iv,
      _gloffset_Color4uiv,
      _gloffset_Color4fv,
      _gloffset_Color4dv,
   },
};

static const int VertexFuncs[3][NUM_TYPES] = {
   {
      -1,
      -1,
      _gloffset_Vertex2sv,
      -1,
      _gloffset_Vertex2iv,
      -1,
      _gloffset_Vertex2fv,
      _gloffset_Vertex2dv,
   },
   {
      -1,
      -1,
      _gloffset_Vertex3sv,
      -1,
      _gloffset_Vertex3iv,
      -1,
      _gloffset_Vertex3fv,
      _gloffset_Vertex3dv,
   },
   {
      -1,
      -1,
      _gloffset_Vertex4sv,
      -1,
      _gloffset_Vertex4iv,
      -1,
      _gloffset_Vertex4fv,
      _gloffset_Vertex4dv,
   },
};

static const int IndexFuncs[NUM_TYPES] = {
   -1,
   _gloffset_Indexubv,
   _gloffset_Indexsv,
   -1,
   _gloffset_Indexiv,
   -1,
   _gloffset_Indexfv,
   _gloffset_Indexdv,
};

static const int NormalFuncs[NUM_TYPES] = {
   _gloffset_Normal3bv,
   -1,
   _gloffset_Normal3sv,
   -1,
   _gloffset_Normal3iv,
   -1,
   _gloffset_Normal3fv,
   _gloffset_Normal3dv,
};

/* Note: _gloffset_* for these may not be a compile-time constant. */
static int SecondaryColorFuncs[NUM_TYPES];
static int FogCoordFuncs[NUM_TYPES];


/**
 ** GL_NV_vertex_program
 **/

/* GL_BYTE attributes */

static void GLAPIENTRY
VertexAttrib1NbvNV(GLuint index, const GLbyte *v)
{
   CALL_VertexAttrib1fNV(GET_DISPATCH(), (index, BYTE_TO_FLOAT(v[0])));
}

static void GLAPIENTRY
VertexAttrib1bvNV(GLuint index, const GLbyte *v)
{
   CALL_VertexAttrib1fNV(GET_DISPATCH(), (index, (GLfloat)v[0]));
}

static void GLAPIENTRY
VertexAttrib2NbvNV(GLuint index, const GLbyte *v)
{
   CALL_VertexAttrib2fNV(GET_DISPATCH(), (index, BYTE_TO_FLOAT(v[0]), BYTE_TO_FLOAT(v[1])));
}

static void GLAPIENTRY
VertexAttrib2bvNV(GLuint index, const GLbyte *v)
{
   CALL_VertexAttrib2fNV(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1]));
}

static void GLAPIENTRY
VertexAttrib3NbvNV(GLuint index, const GLbyte *v)
{
   CALL_VertexAttrib3fNV(GET_DISPATCH(), (index, BYTE_TO_FLOAT(v[0]),
					       BYTE_TO_FLOAT(v[1]),
					       BYTE_TO_FLOAT(v[2])));
}

static void GLAPIENTRY
VertexAttrib3bvNV(GLuint index, const GLbyte *v)
{
   CALL_VertexAttrib3fNV(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1], (GLfloat)v[2]));
}

static void GLAPIENTRY
VertexAttrib4NbvNV(GLuint index, const GLbyte *v)
{
   CALL_VertexAttrib4fNV(GET_DISPATCH(), (index, BYTE_TO_FLOAT(v[0]),
					       BYTE_TO_FLOAT(v[1]),
					       BYTE_TO_FLOAT(v[2]),
					       BYTE_TO_FLOAT(v[3])));
}

static void GLAPIENTRY
VertexAttrib4bvNV(GLuint index, const GLbyte *v)
{
   CALL_VertexAttrib4fNV(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1], (GLfloat)v[2], (GLfloat)v[3]));
}

/* GL_UNSIGNED_BYTE attributes */

static void GLAPIENTRY
VertexAttrib1NubvNV(GLuint index, const GLubyte *v)
{
   CALL_VertexAttrib1fNV(GET_DISPATCH(), (index, UBYTE_TO_FLOAT(v[0])));
}

static void GLAPIENTRY
VertexAttrib1ubvNV(GLuint index, const GLubyte *v)
{
   CALL_VertexAttrib1fNV(GET_DISPATCH(), (index, (GLfloat)v[0]));
}

static void GLAPIENTRY
VertexAttrib2NubvNV(GLuint index, const GLubyte *v)
{
   CALL_VertexAttrib2fNV(GET_DISPATCH(), (index, UBYTE_TO_FLOAT(v[0]),
                                          UBYTE_TO_FLOAT(v[1])));
}

static void GLAPIENTRY
VertexAttrib2ubvNV(GLuint index, const GLubyte *v)
{
   CALL_VertexAttrib2fNV(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1]));
}

static void GLAPIENTRY
VertexAttrib3NubvNV(GLuint index, const GLubyte *v)
{
   CALL_VertexAttrib3fNV(GET_DISPATCH(), (index, UBYTE_TO_FLOAT(v[0]),
					       UBYTE_TO_FLOAT(v[1]),
					       UBYTE_TO_FLOAT(v[2])));
}
static void GLAPIENTRY
VertexAttrib3ubvNV(GLuint index, const GLubyte *v)
{
   CALL_VertexAttrib3fNV(GET_DISPATCH(), (index, (GLfloat)v[0],
                                          (GLfloat)v[1], (GLfloat)v[2]));
}

static void GLAPIENTRY
VertexAttrib4NubvNV(GLuint index, const GLubyte *v)
{
   CALL_VertexAttrib4fNV(GET_DISPATCH(), (index, UBYTE_TO_FLOAT(v[0]),
                                          UBYTE_TO_FLOAT(v[1]),
                                          UBYTE_TO_FLOAT(v[2]),
                                          UBYTE_TO_FLOAT(v[3])));
}

static void GLAPIENTRY
VertexAttrib4ubvNV(GLuint index, const GLubyte *v)
{
   CALL_VertexAttrib4fNV(GET_DISPATCH(), (index, (GLfloat)v[0],
                                          (GLfloat)v[1], (GLfloat)v[2],
                                          (GLfloat)v[3]));
}

/* GL_SHORT attributes */

static void GLAPIENTRY
VertexAttrib1NsvNV(GLuint index, const GLshort *v)
{
   CALL_VertexAttrib1fNV(GET_DISPATCH(), (index, SHORT_TO_FLOAT(v[0])));
}

static void GLAPIENTRY
VertexAttrib1svNV(GLuint index, const GLshort *v)
{
   CALL_VertexAttrib1fNV(GET_DISPATCH(), (index, (GLfloat)v[0]));
}

static void GLAPIENTRY
VertexAttrib2NsvNV(GLuint index, const GLshort *v)
{
   CALL_VertexAttrib2fNV(GET_DISPATCH(), (index, SHORT_TO_FLOAT(v[0]),
                                          SHORT_TO_FLOAT(v[1])));
}

static void GLAPIENTRY
VertexAttrib2svNV(GLuint index, const GLshort *v)
{
   CALL_VertexAttrib2fNV(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1]));
}

static void GLAPIENTRY
VertexAttrib3NsvNV(GLuint index, const GLshort *v)
{
   CALL_VertexAttrib3fNV(GET_DISPATCH(), (index, SHORT_TO_FLOAT(v[0]),
			     SHORT_TO_FLOAT(v[1]),
			     SHORT_TO_FLOAT(v[2])));
}

static void GLAPIENTRY
VertexAttrib3svNV(GLuint index, const GLshort *v)
{
   CALL_VertexAttrib3fNV(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1],
                                          (GLfloat)v[2]));
}

static void GLAPIENTRY
VertexAttrib4NsvNV(GLuint index, const GLshort *v)
{
   CALL_VertexAttrib4fNV(GET_DISPATCH(), (index, SHORT_TO_FLOAT(v[0]),
			     SHORT_TO_FLOAT(v[1]),
			     SHORT_TO_FLOAT(v[2]),
			     SHORT_TO_FLOAT(v[3])));
}

static void GLAPIENTRY
VertexAttrib4svNV(GLuint index, const GLshort *v)
{
   CALL_VertexAttrib4fNV(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1],
                                          (GLfloat)v[2], (GLfloat)v[3]));
}

/* GL_UNSIGNED_SHORT attributes */

static void GLAPIENTRY
VertexAttrib1NusvNV(GLuint index, const GLushort *v)
{
   CALL_VertexAttrib1fNV(GET_DISPATCH(), (index, USHORT_TO_FLOAT(v[0])));
}

static void GLAPIENTRY
VertexAttrib1usvNV(GLuint index, const GLushort *v)
{
   CALL_VertexAttrib1fNV(GET_DISPATCH(), (index, (GLfloat)v[0]));
}

static void GLAPIENTRY
VertexAttrib2NusvNV(GLuint index, const GLushort *v)
{
   CALL_VertexAttrib2fNV(GET_DISPATCH(), (index, USHORT_TO_FLOAT(v[0]),
			     USHORT_TO_FLOAT(v[1])));
}

static void GLAPIENTRY
VertexAttrib2usvNV(GLuint index, const GLushort *v)
{
   CALL_VertexAttrib2fNV(GET_DISPATCH(), (index, (GLfloat)v[0],
                                          (GLfloat)v[1]));
}

static void GLAPIENTRY
VertexAttrib3NusvNV(GLuint index, const GLushort *v)
{
   CALL_VertexAttrib3fNV(GET_DISPATCH(), (index, USHORT_TO_FLOAT(v[0]),
					       USHORT_TO_FLOAT(v[1]),
					       USHORT_TO_FLOAT(v[2])));
}

static void GLAPIENTRY
VertexAttrib3usvNV(GLuint index, const GLushort *v)
{
   CALL_VertexAttrib3fNV(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1],
                                          (GLfloat)v[2]));
}

static void GLAPIENTRY
VertexAttrib4NusvNV(GLuint index, const GLushort *v)
{
   CALL_VertexAttrib4fNV(GET_DISPATCH(), (index, USHORT_TO_FLOAT(v[0]),
					       USHORT_TO_FLOAT(v[1]),
					       USHORT_TO_FLOAT(v[2]),
					       USHORT_TO_FLOAT(v[3])));
}

static void GLAPIENTRY
VertexAttrib4usvNV(GLuint index, const GLushort *v)
{
   CALL_VertexAttrib4fNV(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1],
                                          (GLfloat)v[2], (GLfloat)v[3]));
}

/* GL_INT attributes */

static void GLAPIENTRY
VertexAttrib1NivNV(GLuint index, const GLint *v)
{
   CALL_VertexAttrib1fNV(GET_DISPATCH(), (index, INT_TO_FLOAT(v[0])));
}

static void GLAPIENTRY
VertexAttrib1ivNV(GLuint index, const GLint *v)
{
   CALL_VertexAttrib1fNV(GET_DISPATCH(), (index, (GLfloat)v[0]));
}

static void GLAPIENTRY
VertexAttrib2NivNV(GLuint index, const GLint *v)
{
   CALL_VertexAttrib2fNV(GET_DISPATCH(), (index, INT_TO_FLOAT(v[0]),
					       INT_TO_FLOAT(v[1])));
}

static void GLAPIENTRY
VertexAttrib2ivNV(GLuint index, const GLint *v)
{
   CALL_VertexAttrib2fNV(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1]));
}

static void GLAPIENTRY
VertexAttrib3NivNV(GLuint index, const GLint *v)
{
   CALL_VertexAttrib3fNV(GET_DISPATCH(), (index, INT_TO_FLOAT(v[0]),
					       INT_TO_FLOAT(v[1]),
					       INT_TO_FLOAT(v[2])));
}

static void GLAPIENTRY
VertexAttrib3ivNV(GLuint index, const GLint *v)
{
   CALL_VertexAttrib3fNV(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1],
                                          (GLfloat)v[2]));
}

static void GLAPIENTRY
VertexAttrib4NivNV(GLuint index, const GLint *v)
{
   CALL_VertexAttrib4fNV(GET_DISPATCH(), (index, INT_TO_FLOAT(v[0]),
                                          INT_TO_FLOAT(v[1]),
                                          INT_TO_FLOAT(v[2]),
                                          INT_TO_FLOAT(v[3])));
}

static void GLAPIENTRY
VertexAttrib4ivNV(GLuint index, const GLint *v)
{
   CALL_VertexAttrib4fNV(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1],
                                          (GLfloat)v[2], (GLfloat)v[3]));
}

/* GL_UNSIGNED_INT attributes */

static void GLAPIENTRY
VertexAttrib1NuivNV(GLuint index, const GLuint *v)
{
   CALL_VertexAttrib1fNV(GET_DISPATCH(), (index, UINT_TO_FLOAT(v[0])));
}

static void GLAPIENTRY
VertexAttrib1uivNV(GLuint index, const GLuint *v)
{
   CALL_VertexAttrib1fNV(GET_DISPATCH(), (index, (GLfloat)v[0]));
}

static void GLAPIENTRY
VertexAttrib2NuivNV(GLuint index, const GLuint *v)
{
   CALL_VertexAttrib2fNV(GET_DISPATCH(), (index, UINT_TO_FLOAT(v[0]),
                                          UINT_TO_FLOAT(v[1])));
}

static void GLAPIENTRY
VertexAttrib2uivNV(GLuint index, const GLuint *v)
{
   CALL_VertexAttrib2fNV(GET_DISPATCH(), (index, (GLfloat)v[0],
                                          (GLfloat)v[1]));
}

static void GLAPIENTRY
VertexAttrib3NuivNV(GLuint index, const GLuint *v)
{
   CALL_VertexAttrib3fNV(GET_DISPATCH(), (index, UINT_TO_FLOAT(v[0]),
					       UINT_TO_FLOAT(v[1]),
					       UINT_TO_FLOAT(v[2])));
}

static void GLAPIENTRY
VertexAttrib3uivNV(GLuint index, const GLuint *v)
{
   CALL_VertexAttrib3fNV(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1],
                                          (GLfloat)v[2]));
}

static void GLAPIENTRY
VertexAttrib4NuivNV(GLuint index, const GLuint *v)
{
   CALL_VertexAttrib4fNV(GET_DISPATCH(), (index, UINT_TO_FLOAT(v[0]),
					       UINT_TO_FLOAT(v[1]),
					       UINT_TO_FLOAT(v[2]),
					       UINT_TO_FLOAT(v[3])));
}

static void GLAPIENTRY
VertexAttrib4uivNV(GLuint index, const GLuint *v)
{
   CALL_VertexAttrib4fNV(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1],
                                          (GLfloat)v[2], (GLfloat)v[3]));
}

/* GL_FLOAT attributes */

static void GLAPIENTRY
VertexAttrib1fvNV(GLuint index, const GLfloat *v)
{
   CALL_VertexAttrib1fvNV(GET_DISPATCH(), (index, v));
}

static void GLAPIENTRY
VertexAttrib2fvNV(GLuint index, const GLfloat *v)
{
   CALL_VertexAttrib2fvNV(GET_DISPATCH(), (index, v));
}

static void GLAPIENTRY
VertexAttrib3fvNV(GLuint index, const GLfloat *v)
{
   CALL_VertexAttrib3fvNV(GET_DISPATCH(), (index, v));
}

static void GLAPIENTRY
VertexAttrib4fvNV(GLuint index, const GLfloat *v)
{
   CALL_VertexAttrib4fvNV(GET_DISPATCH(), (index, v));
}

/* GL_DOUBLE attributes */

static void GLAPIENTRY
VertexAttrib1dvNV(GLuint index, const GLdouble *v)
{
   CALL_VertexAttrib1dvNV(GET_DISPATCH(), (index, v));
}

static void GLAPIENTRY
VertexAttrib2dvNV(GLuint index, const GLdouble *v)
{
   CALL_VertexAttrib2dvNV(GET_DISPATCH(), (index, v));
}

static void GLAPIENTRY
VertexAttrib3dvNV(GLuint index, const GLdouble *v)
{
   CALL_VertexAttrib3dvNV(GET_DISPATCH(), (index, v));
}

static void GLAPIENTRY
VertexAttrib4dvNV(GLuint index, const GLdouble *v)
{
   CALL_VertexAttrib4dvNV(GET_DISPATCH(), (index, v));
}


/*
 * Array [size][type] of VertexAttrib functions
 */
static attrib_func AttribFuncsNV[2][4][NUM_TYPES] = {
   {
      /* non-normalized */
      {
         /* size 1 */
         (attrib_func) VertexAttrib1bvNV,
         (attrib_func) VertexAttrib1ubvNV,
         (attrib_func) VertexAttrib1svNV,
         (attrib_func) VertexAttrib1usvNV,
         (attrib_func) VertexAttrib1ivNV,
         (attrib_func) VertexAttrib1uivNV,
         (attrib_func) VertexAttrib1fvNV,
         (attrib_func) VertexAttrib1dvNV
      },
      {
         /* size 2 */
         (attrib_func) VertexAttrib2bvNV,
         (attrib_func) VertexAttrib2ubvNV,
         (attrib_func) VertexAttrib2svNV,
         (attrib_func) VertexAttrib2usvNV,
         (attrib_func) VertexAttrib2ivNV,
         (attrib_func) VertexAttrib2uivNV,
         (attrib_func) VertexAttrib2fvNV,
         (attrib_func) VertexAttrib2dvNV
      },
      {
         /* size 3 */
         (attrib_func) VertexAttrib3bvNV,
         (attrib_func) VertexAttrib3ubvNV,
         (attrib_func) VertexAttrib3svNV,
         (attrib_func) VertexAttrib3usvNV,
         (attrib_func) VertexAttrib3ivNV,
         (attrib_func) VertexAttrib3uivNV,
         (attrib_func) VertexAttrib3fvNV,
         (attrib_func) VertexAttrib3dvNV
      },
      {
         /* size 4 */
         (attrib_func) VertexAttrib4bvNV,
         (attrib_func) VertexAttrib4ubvNV,
         (attrib_func) VertexAttrib4svNV,
         (attrib_func) VertexAttrib4usvNV,
         (attrib_func) VertexAttrib4ivNV,
         (attrib_func) VertexAttrib4uivNV,
         (attrib_func) VertexAttrib4fvNV,
         (attrib_func) VertexAttrib4dvNV
      }
   },
   {
      /* normalized (except for float/double) */
      {
         /* size 1 */
         (attrib_func) VertexAttrib1NbvNV,
         (attrib_func) VertexAttrib1NubvNV,
         (attrib_func) VertexAttrib1NsvNV,
         (attrib_func) VertexAttrib1NusvNV,
         (attrib_func) VertexAttrib1NivNV,
         (attrib_func) VertexAttrib1NuivNV,
         (attrib_func) VertexAttrib1fvNV,
         (attrib_func) VertexAttrib1dvNV
      },
      {
         /* size 2 */
         (attrib_func) VertexAttrib2NbvNV,
         (attrib_func) VertexAttrib2NubvNV,
         (attrib_func) VertexAttrib2NsvNV,
         (attrib_func) VertexAttrib2NusvNV,
         (attrib_func) VertexAttrib2NivNV,
         (attrib_func) VertexAttrib2NuivNV,
         (attrib_func) VertexAttrib2fvNV,
         (attrib_func) VertexAttrib2dvNV
      },
      {
         /* size 3 */
         (attrib_func) VertexAttrib3NbvNV,
         (attrib_func) VertexAttrib3NubvNV,
         (attrib_func) VertexAttrib3NsvNV,
         (attrib_func) VertexAttrib3NusvNV,
         (attrib_func) VertexAttrib3NivNV,
         (attrib_func) VertexAttrib3NuivNV,
         (attrib_func) VertexAttrib3fvNV,
         (attrib_func) VertexAttrib3dvNV
      },
      {
         /* size 4 */
         (attrib_func) VertexAttrib4NbvNV,
         (attrib_func) VertexAttrib4NubvNV,
         (attrib_func) VertexAttrib4NsvNV,
         (attrib_func) VertexAttrib4NusvNV,
         (attrib_func) VertexAttrib4NivNV,
         (attrib_func) VertexAttrib4NuivNV,
         (attrib_func) VertexAttrib4fvNV,
         (attrib_func) VertexAttrib4dvNV
      }
   }
};


/**
 ** GL_ARB_vertex_program
 **/

/* GL_BYTE attributes */

static void GLAPIENTRY
VertexAttrib1NbvARB(GLuint index, const GLbyte *v)
{
   CALL_VertexAttrib1fARB(GET_DISPATCH(), (index, BYTE_TO_FLOAT(v[0])));
}

static void GLAPIENTRY
VertexAttrib1bvARB(GLuint index, const GLbyte *v)
{
   CALL_VertexAttrib1fARB(GET_DISPATCH(), (index, (GLfloat)v[0]));
}

static void GLAPIENTRY
VertexAttrib2NbvARB(GLuint index, const GLbyte *v)
{
   CALL_VertexAttrib2fARB(GET_DISPATCH(), (index, BYTE_TO_FLOAT(v[0]), BYTE_TO_FLOAT(v[1])));
}

static void GLAPIENTRY
VertexAttrib2bvARB(GLuint index, const GLbyte *v)
{
   CALL_VertexAttrib2fARB(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1]));
}

static void GLAPIENTRY
VertexAttrib3NbvARB(GLuint index, const GLbyte *v)
{
   CALL_VertexAttrib3fARB(GET_DISPATCH(), (index, BYTE_TO_FLOAT(v[0]),
					       BYTE_TO_FLOAT(v[1]),
					       BYTE_TO_FLOAT(v[2])));
}

static void GLAPIENTRY
VertexAttrib3bvARB(GLuint index, const GLbyte *v)
{
   CALL_VertexAttrib3fARB(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1], (GLfloat)v[2]));
}

static void GLAPIENTRY
VertexAttrib4NbvARB(GLuint index, const GLbyte *v)
{
   CALL_VertexAttrib4fARB(GET_DISPATCH(), (index, BYTE_TO_FLOAT(v[0]),
					       BYTE_TO_FLOAT(v[1]),
					       BYTE_TO_FLOAT(v[2]),
					       BYTE_TO_FLOAT(v[3])));
}

static void GLAPIENTRY
VertexAttrib4bvARB(GLuint index, const GLbyte *v)
{
   CALL_VertexAttrib4fARB(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1], (GLfloat)v[2], (GLfloat)v[3]));
}

/* GL_UNSIGNED_BYTE attributes */

static void GLAPIENTRY
VertexAttrib1NubvARB(GLuint index, const GLubyte *v)
{
   CALL_VertexAttrib1fARB(GET_DISPATCH(), (index, UBYTE_TO_FLOAT(v[0])));
}

static void GLAPIENTRY
VertexAttrib1ubvARB(GLuint index, const GLubyte *v)
{
   CALL_VertexAttrib1fARB(GET_DISPATCH(), (index, (GLfloat)v[0]));
}

static void GLAPIENTRY
VertexAttrib2NubvARB(GLuint index, const GLubyte *v)
{
   CALL_VertexAttrib2fARB(GET_DISPATCH(), (index,
                                           UBYTE_TO_FLOAT(v[0]),
                                           UBYTE_TO_FLOAT(v[1])));
}

static void GLAPIENTRY
VertexAttrib2ubvARB(GLuint index, const GLubyte *v)
{
   CALL_VertexAttrib2fARB(GET_DISPATCH(), (index,
                                           (GLfloat)v[0], (GLfloat)v[1]));
}

static void GLAPIENTRY
VertexAttrib3NubvARB(GLuint index, const GLubyte *v)
{
   CALL_VertexAttrib3fARB(GET_DISPATCH(), (index,
                                           UBYTE_TO_FLOAT(v[0]),
                                           UBYTE_TO_FLOAT(v[1]),
                                           UBYTE_TO_FLOAT(v[2])));
}
static void GLAPIENTRY
VertexAttrib3ubvARB(GLuint index, const GLubyte *v)
{
   CALL_VertexAttrib3fARB(GET_DISPATCH(), (index,
                                           (GLfloat)v[0],
                                           (GLfloat)v[1],
                                           (GLfloat)v[2]));
}

static void GLAPIENTRY
VertexAttrib4NubvARB(GLuint index, const GLubyte *v)
{
   CALL_VertexAttrib4fARB(GET_DISPATCH(),
                          (index,
                           UBYTE_TO_FLOAT(v[0]),
                           UBYTE_TO_FLOAT(v[1]),
                           UBYTE_TO_FLOAT(v[2]),
                           UBYTE_TO_FLOAT(v[3])));
}

static void GLAPIENTRY
VertexAttrib4ubvARB(GLuint index, const GLubyte *v)
{
   CALL_VertexAttrib4fARB(GET_DISPATCH(),
                          (index,
                           (GLfloat)v[0], (GLfloat)v[1],
                           (GLfloat)v[2], (GLfloat)v[3]));
}

/* GL_SHORT attributes */

static void GLAPIENTRY
VertexAttrib1NsvARB(GLuint index, const GLshort *v)
{
   CALL_VertexAttrib1fARB(GET_DISPATCH(), (index, SHORT_TO_FLOAT(v[0])));
}

static void GLAPIENTRY
VertexAttrib1svARB(GLuint index, const GLshort *v)
{
   CALL_VertexAttrib1fARB(GET_DISPATCH(), (index, (GLfloat)v[0]));
}

static void GLAPIENTRY
VertexAttrib2NsvARB(GLuint index, const GLshort *v)
{
   CALL_VertexAttrib2fARB(GET_DISPATCH(),
                          (index, SHORT_TO_FLOAT(v[0]),
                           SHORT_TO_FLOAT(v[1])));
}

static void GLAPIENTRY
VertexAttrib2svARB(GLuint index, const GLshort *v)
{
   CALL_VertexAttrib2fARB(GET_DISPATCH(),
                          (index, (GLfloat)v[0], (GLfloat)v[1]));
}

static void GLAPIENTRY
VertexAttrib3NsvARB(GLuint index, const GLshort *v)
{
   CALL_VertexAttrib3fARB(GET_DISPATCH(),
                          (index,
                           SHORT_TO_FLOAT(v[0]),
                           SHORT_TO_FLOAT(v[1]),
                           SHORT_TO_FLOAT(v[2])));
}

static void GLAPIENTRY
VertexAttrib3svARB(GLuint index, const GLshort *v)
{
   CALL_VertexAttrib3fARB(GET_DISPATCH(),
                          (index,
                           (GLfloat)v[0], (GLfloat)v[1], (GLfloat)v[2]));
}

static void GLAPIENTRY
VertexAttrib4NsvARB(GLuint index, const GLshort *v)
{
   CALL_VertexAttrib4fARB(GET_DISPATCH(),
                          (index,
                           SHORT_TO_FLOAT(v[0]),
                           SHORT_TO_FLOAT(v[1]),
                           SHORT_TO_FLOAT(v[2]),
                           SHORT_TO_FLOAT(v[3])));
}

static void GLAPIENTRY
VertexAttrib4svARB(GLuint index, const GLshort *v)
{
   CALL_VertexAttrib4fARB(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1],
                                           (GLfloat)v[2], (GLfloat)v[3]));
}

/* GL_UNSIGNED_SHORT attributes */

static void GLAPIENTRY
VertexAttrib1NusvARB(GLuint index, const GLushort *v)
{
   CALL_VertexAttrib1fARB(GET_DISPATCH(), (index, USHORT_TO_FLOAT(v[0])));
}

static void GLAPIENTRY
VertexAttrib1usvARB(GLuint index, const GLushort *v)
{
   CALL_VertexAttrib1fARB(GET_DISPATCH(), (index, (GLfloat)v[0]));
}

static void GLAPIENTRY
VertexAttrib2NusvARB(GLuint index, const GLushort *v)
{
   CALL_VertexAttrib2fARB(GET_DISPATCH(), (index, USHORT_TO_FLOAT(v[0]),
			     USHORT_TO_FLOAT(v[1])));
}

static void GLAPIENTRY
VertexAttrib2usvARB(GLuint index, const GLushort *v)
{
   CALL_VertexAttrib2fARB(GET_DISPATCH(), (index, (GLfloat)v[0],
                                           (GLfloat)v[1]));
}

static void GLAPIENTRY
VertexAttrib3NusvARB(GLuint index, const GLushort *v)
{
   CALL_VertexAttrib3fARB(GET_DISPATCH(), (index, USHORT_TO_FLOAT(v[0]),
					       USHORT_TO_FLOAT(v[1]),
					       USHORT_TO_FLOAT(v[2])));
}

static void GLAPIENTRY
VertexAttrib3usvARB(GLuint index, const GLushort *v)
{
   CALL_VertexAttrib3fARB(GET_DISPATCH(), (index, (GLfloat)v[0],
                                           (GLfloat)v[1], (GLfloat)v[2]));
}

static void GLAPIENTRY
VertexAttrib4NusvARB(GLuint index, const GLushort *v)
{
   CALL_VertexAttrib4fARB(GET_DISPATCH(), (index, USHORT_TO_FLOAT(v[0]),
					       USHORT_TO_FLOAT(v[1]),
					       USHORT_TO_FLOAT(v[2]),
					       USHORT_TO_FLOAT(v[3])));
}

static void GLAPIENTRY
VertexAttrib4usvARB(GLuint index, const GLushort *v)
{
   CALL_VertexAttrib4fARB(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1], (GLfloat)v[2], (GLfloat)v[3]));
}

/* GL_INT attributes */

static void GLAPIENTRY
VertexAttrib1NivARB(GLuint index, const GLint *v)
{
   CALL_VertexAttrib1fARB(GET_DISPATCH(), (index, INT_TO_FLOAT(v[0])));
}

static void GLAPIENTRY
VertexAttrib1ivARB(GLuint index, const GLint *v)
{
   CALL_VertexAttrib1fARB(GET_DISPATCH(), (index, (GLfloat)v[0]));
}

static void GLAPIENTRY
VertexAttrib2NivARB(GLuint index, const GLint *v)
{
   CALL_VertexAttrib2fARB(GET_DISPATCH(), (index, INT_TO_FLOAT(v[0]),
					       INT_TO_FLOAT(v[1])));
}

static void GLAPIENTRY
VertexAttrib2ivARB(GLuint index, const GLint *v)
{
   CALL_VertexAttrib2fARB(GET_DISPATCH(), (index, (GLfloat)v[0],
                                           (GLfloat)v[1]));
}

static void GLAPIENTRY
VertexAttrib3NivARB(GLuint index, const GLint *v)
{
   CALL_VertexAttrib3fARB(GET_DISPATCH(), (index, INT_TO_FLOAT(v[0]),
					       INT_TO_FLOAT(v[1]),
					       INT_TO_FLOAT(v[2])));
}

static void GLAPIENTRY
VertexAttrib3ivARB(GLuint index, const GLint *v)
{
   CALL_VertexAttrib3fARB(GET_DISPATCH(), (index, (GLfloat)v[0],
                                           (GLfloat)v[1], (GLfloat)v[2]));
}

static void GLAPIENTRY
VertexAttrib4NivARB(GLuint index, const GLint *v)
{
   CALL_VertexAttrib4fARB(GET_DISPATCH(), (index, INT_TO_FLOAT(v[0]),
					       INT_TO_FLOAT(v[1]),
					       INT_TO_FLOAT(v[2]),
					       INT_TO_FLOAT(v[3])));
}

static void GLAPIENTRY
VertexAttrib4ivARB(GLuint index, const GLint *v)
{
   CALL_VertexAttrib4fARB(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1],
                                           (GLfloat)v[2], (GLfloat)v[3]));
}

/* GL_UNSIGNED_INT attributes */

static void GLAPIENTRY
VertexAttrib1NuivARB(GLuint index, const GLuint *v)
{
   CALL_VertexAttrib1fARB(GET_DISPATCH(), (index, UINT_TO_FLOAT(v[0])));
}

static void GLAPIENTRY
VertexAttrib1uivARB(GLuint index, const GLuint *v)
{
   CALL_VertexAttrib1fARB(GET_DISPATCH(), (index, (GLfloat)v[0]));
}

static void GLAPIENTRY
VertexAttrib2NuivARB(GLuint index, const GLuint *v)
{
   CALL_VertexAttrib2fARB(GET_DISPATCH(), (index, UINT_TO_FLOAT(v[0]),
                                           UINT_TO_FLOAT(v[1])));
}

static void GLAPIENTRY
VertexAttrib2uivARB(GLuint index, const GLuint *v)
{
   CALL_VertexAttrib2fARB(GET_DISPATCH(), (index, (GLfloat)v[0],
                                           (GLfloat)v[1]));
}

static void GLAPIENTRY
VertexAttrib3NuivARB(GLuint index, const GLuint *v)
{
   CALL_VertexAttrib3fARB(GET_DISPATCH(), (index, UINT_TO_FLOAT(v[0]),
                                           UINT_TO_FLOAT(v[1]),
                                           UINT_TO_FLOAT(v[2])));
}

static void GLAPIENTRY
VertexAttrib3uivARB(GLuint index, const GLuint *v)
{
   CALL_VertexAttrib3fARB(GET_DISPATCH(), (index, (GLfloat)v[0],
                                           (GLfloat)v[1], (GLfloat)v[2]));
}

static void GLAPIENTRY
VertexAttrib4NuivARB(GLuint index, const GLuint *v)
{
   CALL_VertexAttrib4fARB(GET_DISPATCH(), (index, UINT_TO_FLOAT(v[0]),
                                           UINT_TO_FLOAT(v[1]),
                                           UINT_TO_FLOAT(v[2]),
                                           UINT_TO_FLOAT(v[3])));
}

static void GLAPIENTRY
VertexAttrib4uivARB(GLuint index, const GLuint *v)
{
   CALL_VertexAttrib4fARB(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1],
                                           (GLfloat)v[2], (GLfloat)v[3]));
}

/* GL_FLOAT attributes */

static void GLAPIENTRY
VertexAttrib1fvARB(GLuint index, const GLfloat *v)
{
   CALL_VertexAttrib1fvARB(GET_DISPATCH(), (index, v));
}

static void GLAPIENTRY
VertexAttrib2fvARB(GLuint index, const GLfloat *v)
{
   CALL_VertexAttrib2fvARB(GET_DISPATCH(), (index, v));
}

static void GLAPIENTRY
VertexAttrib3fvARB(GLuint index, const GLfloat *v)
{
   CALL_VertexAttrib3fvARB(GET_DISPATCH(), (index, v));
}

static void GLAPIENTRY
VertexAttrib4fvARB(GLuint index, const GLfloat *v)
{
   CALL_VertexAttrib4fvARB(GET_DISPATCH(), (index, v));
}

/* GL_DOUBLE attributes */

static void GLAPIENTRY
VertexAttrib1dvARB(GLuint index, const GLdouble *v)
{
   CALL_VertexAttrib1dv(GET_DISPATCH(), (index, v));
}

static void GLAPIENTRY
VertexAttrib2dvARB(GLuint index, const GLdouble *v)
{
   CALL_VertexAttrib2dv(GET_DISPATCH(), (index, v));
}

static void GLAPIENTRY
VertexAttrib3dvARB(GLuint index, const GLdouble *v)
{
   CALL_VertexAttrib3dv(GET_DISPATCH(), (index, v));
}

static void GLAPIENTRY
VertexAttrib4dvARB(GLuint index, const GLdouble *v)
{
   CALL_VertexAttrib4dv(GET_DISPATCH(), (index, v));
}


/**
 * Integer-valued attributes
 */
static void GLAPIENTRY
VertexAttribI1bv(GLuint index, const GLbyte *v)
{
   CALL_VertexAttribI1iEXT(GET_DISPATCH(), (index, v[0]));
}

static void GLAPIENTRY
VertexAttribI2bv(GLuint index, const GLbyte *v)
{
   CALL_VertexAttribI2iEXT(GET_DISPATCH(), (index, v[0], v[1]));
}

static void GLAPIENTRY
VertexAttribI3bv(GLuint index, const GLbyte *v)
{
   CALL_VertexAttribI3iEXT(GET_DISPATCH(), (index, v[0], v[1], v[2]));
}

static void GLAPIENTRY
VertexAttribI4bv(GLuint index, const GLbyte *v)
{
   CALL_VertexAttribI4bv(GET_DISPATCH(), (index, v));
}


static void GLAPIENTRY
VertexAttribI1ubv(GLuint index, const GLubyte *v)
{
   CALL_VertexAttribI1uiEXT(GET_DISPATCH(), (index, v[0]));
}

static void GLAPIENTRY
VertexAttribI2ubv(GLuint index, const GLubyte *v)
{
   CALL_VertexAttribI2uiEXT(GET_DISPATCH(), (index, v[0], v[1]));
}

static void GLAPIENTRY
VertexAttribI3ubv(GLuint index, const GLubyte *v)
{
   CALL_VertexAttribI3uiEXT(GET_DISPATCH(), (index, v[0], v[1], v[2]));
}

static void GLAPIENTRY
VertexAttribI4ubv(GLuint index, const GLubyte *v)
{
   CALL_VertexAttribI4ubv(GET_DISPATCH(), (index, v));
}



static void GLAPIENTRY
VertexAttribI1sv(GLuint index, const GLshort *v)
{
   CALL_VertexAttribI1iEXT(GET_DISPATCH(), (index, v[0]));
}

static void GLAPIENTRY
VertexAttribI2sv(GLuint index, const GLshort *v)
{
   CALL_VertexAttribI2iEXT(GET_DISPATCH(), (index, v[0], v[1]));
}

static void GLAPIENTRY
VertexAttribI3sv(GLuint index, const GLshort *v)
{
   CALL_VertexAttribI3iEXT(GET_DISPATCH(), (index, v[0], v[1], v[2]));
}

static void GLAPIENTRY
VertexAttribI4sv(GLuint index, const GLshort *v)
{
   CALL_VertexAttribI4sv(GET_DISPATCH(), (index, v));
}


static void GLAPIENTRY
VertexAttribI1usv(GLuint index, const GLushort *v)
{
   CALL_VertexAttribI1uiEXT(GET_DISPATCH(), (index, v[0]));
}

static void GLAPIENTRY
VertexAttribI2usv(GLuint index, const GLushort *v)
{
   CALL_VertexAttribI2uiEXT(GET_DISPATCH(), (index, v[0], v[1]));
}

static void GLAPIENTRY
VertexAttribI3usv(GLuint index, const GLushort *v)
{
   CALL_VertexAttribI3uiEXT(GET_DISPATCH(), (index, v[0], v[1], v[2]));
}

static void GLAPIENTRY
VertexAttribI4usv(GLuint index, const GLushort *v)
{
   CALL_VertexAttribI4usv(GET_DISPATCH(), (index, v));
}



static void GLAPIENTRY
VertexAttribI1iv(GLuint index, const GLint *v)
{
   CALL_VertexAttribI1iEXT(GET_DISPATCH(), (index, v[0]));
}

static void GLAPIENTRY
VertexAttribI2iv(GLuint index, const GLint *v)
{
   CALL_VertexAttribI2iEXT(GET_DISPATCH(), (index, v[0], v[1]));
}

static void GLAPIENTRY
VertexAttribI3iv(GLuint index, const GLint *v)
{
   CALL_VertexAttribI3iEXT(GET_DISPATCH(), (index, v[0], v[1], v[2]));
}

static void GLAPIENTRY
VertexAttribI4iv(GLuint index, const GLint *v)
{
   CALL_VertexAttribI4ivEXT(GET_DISPATCH(), (index, v));
}


static void GLAPIENTRY
VertexAttribI1uiv(GLuint index, const GLuint *v)
{
   CALL_VertexAttribI1uiEXT(GET_DISPATCH(), (index, v[0]));
}

static void GLAPIENTRY
VertexAttribI2uiv(GLuint index, const GLuint *v)
{
   CALL_VertexAttribI2uiEXT(GET_DISPATCH(), (index, v[0], v[1]));
}

static void GLAPIENTRY
VertexAttribI3uiv(GLuint index, const GLuint *v)
{
   CALL_VertexAttribI3uiEXT(GET_DISPATCH(), (index, v[0], v[1], v[2]));
}

static void GLAPIENTRY
VertexAttribI4uiv(GLuint index, const GLuint *v)
{
   CALL_VertexAttribI4uivEXT(GET_DISPATCH(), (index, v));
}


/*
 * Array [unnormalized/normalized/integer][size][type] of VertexAttrib
 * functions
 */
static attrib_func AttribFuncsARB[3][4][NUM_TYPES] = {
   {
      /* non-normalized */
      {
         /* size 1 */
         (attrib_func) VertexAttrib1bvARB,
         (attrib_func) VertexAttrib1ubvARB,
         (attrib_func) VertexAttrib1svARB,
         (attrib_func) VertexAttrib1usvARB,
         (attrib_func) VertexAttrib1ivARB,
         (attrib_func) VertexAttrib1uivARB,
         (attrib_func) VertexAttrib1fvARB,
         (attrib_func) VertexAttrib1dvARB
      },
      {
         /* size 2 */
         (attrib_func) VertexAttrib2bvARB,
         (attrib_func) VertexAttrib2ubvARB,
         (attrib_func) VertexAttrib2svARB,
         (attrib_func) VertexAttrib2usvARB,
         (attrib_func) VertexAttrib2ivARB,
         (attrib_func) VertexAttrib2uivARB,
         (attrib_func) VertexAttrib2fvARB,
         (attrib_func) VertexAttrib2dvARB
      },
      {
         /* size 3 */
         (attrib_func) VertexAttrib3bvARB,
         (attrib_func) VertexAttrib3ubvARB,
         (attrib_func) VertexAttrib3svARB,
         (attrib_func) VertexAttrib3usvARB,
         (attrib_func) VertexAttrib3ivARB,
         (attrib_func) VertexAttrib3uivARB,
         (attrib_func) VertexAttrib3fvARB,
         (attrib_func) VertexAttrib3dvARB
      },
      {
         /* size 4 */
         (attrib_func) VertexAttrib4bvARB,
         (attrib_func) VertexAttrib4ubvARB,
         (attrib_func) VertexAttrib4svARB,
         (attrib_func) VertexAttrib4usvARB,
         (attrib_func) VertexAttrib4ivARB,
         (attrib_func) VertexAttrib4uivARB,
         (attrib_func) VertexAttrib4fvARB,
         (attrib_func) VertexAttrib4dvARB
      }
   },
   {
      /* normalized (except for float/double) */
      {
         /* size 1 */
         (attrib_func) VertexAttrib1NbvARB,
         (attrib_func) VertexAttrib1NubvARB,
         (attrib_func) VertexAttrib1NsvARB,
         (attrib_func) VertexAttrib1NusvARB,
         (attrib_func) VertexAttrib1NivARB,
         (attrib_func) VertexAttrib1NuivARB,
         (attrib_func) VertexAttrib1fvARB,
         (attrib_func) VertexAttrib1dvARB
      },
      {
         /* size 2 */
         (attrib_func) VertexAttrib2NbvARB,
         (attrib_func) VertexAttrib2NubvARB,
         (attrib_func) VertexAttrib2NsvARB,
         (attrib_func) VertexAttrib2NusvARB,
         (attrib_func) VertexAttrib2NivARB,
         (attrib_func) VertexAttrib2NuivARB,
         (attrib_func) VertexAttrib2fvARB,
         (attrib_func) VertexAttrib2dvARB
      },
      {
         /* size 3 */
         (attrib_func) VertexAttrib3NbvARB,
         (attrib_func) VertexAttrib3NubvARB,
         (attrib_func) VertexAttrib3NsvARB,
         (attrib_func) VertexAttrib3NusvARB,
         (attrib_func) VertexAttrib3NivARB,
         (attrib_func) VertexAttrib3NuivARB,
         (attrib_func) VertexAttrib3fvARB,
         (attrib_func) VertexAttrib3dvARB
      },
      {
         /* size 4 */
         (attrib_func) VertexAttrib4NbvARB,
         (attrib_func) VertexAttrib4NubvARB,
         (attrib_func) VertexAttrib4NsvARB,
         (attrib_func) VertexAttrib4NusvARB,
         (attrib_func) VertexAttrib4NivARB,
         (attrib_func) VertexAttrib4NuivARB,
         (attrib_func) VertexAttrib4fvARB,
         (attrib_func) VertexAttrib4dvARB
      }
   },

   {
      /* integer-valued */
      {
         /* size 1 */
         (attrib_func) VertexAttribI1bv,
         (attrib_func) VertexAttribI1ubv,
         (attrib_func) VertexAttribI1sv,
         (attrib_func) VertexAttribI1usv,
         (attrib_func) VertexAttribI1iv,
         (attrib_func) VertexAttribI1uiv,
         NULL, /* GL_FLOAT */
         NULL  /* GL_DOUBLE */
      },
      {
         /* size 2 */
         (attrib_func) VertexAttribI2bv,
         (attrib_func) VertexAttribI2ubv,
         (attrib_func) VertexAttribI2sv,
         (attrib_func) VertexAttribI2usv,
         (attrib_func) VertexAttribI2iv,
         (attrib_func) VertexAttribI2uiv,
         NULL, /* GL_FLOAT */
         NULL  /* GL_DOUBLE */
      },
      {
         /* size 3 */
         (attrib_func) VertexAttribI3bv,
         (attrib_func) VertexAttribI3ubv,
         (attrib_func) VertexAttribI3sv,
         (attrib_func) VertexAttribI3usv,
         (attrib_func) VertexAttribI3iv,
         (attrib_func) VertexAttribI3uiv,
         NULL, /* GL_FLOAT */
         NULL  /* GL_DOUBLE */
      },
      {
         /* size 4 */
         (attrib_func) VertexAttribI4bv,
         (attrib_func) VertexAttribI4ubv,
         (attrib_func) VertexAttribI4sv,
         (attrib_func) VertexAttribI4usv,
         (attrib_func) VertexAttribI4iv,
         (attrib_func) VertexAttribI4uiv,
         NULL, /* GL_FLOAT */
         NULL  /* GL_DOUBLE */
      }
   }
};


GLboolean
_ae_create_context(struct gl_context *ctx)
{
   if (ctx->aelt_context)
      return GL_TRUE;

   /* These _gloffset_* values may not be compile-time constants */
   SecondaryColorFuncs[0] = _gloffset_SecondaryColor3bv;
   SecondaryColorFuncs[1] = _gloffset_SecondaryColor3ubv;
   SecondaryColorFuncs[2] = _gloffset_SecondaryColor3sv;
   SecondaryColorFuncs[3] = _gloffset_SecondaryColor3usv;
   SecondaryColorFuncs[4] = _gloffset_SecondaryColor3iv;
   SecondaryColorFuncs[5] = _gloffset_SecondaryColor3uiv;
   SecondaryColorFuncs[6] = _gloffset_SecondaryColor3fvEXT;
   SecondaryColorFuncs[7] = _gloffset_SecondaryColor3dv;

   FogCoordFuncs[0] = -1;
   FogCoordFuncs[1] = -1;
   FogCoordFuncs[2] = -1;
   FogCoordFuncs[3] = -1;
   FogCoordFuncs[4] = -1;
   FogCoordFuncs[5] = -1;
   FogCoordFuncs[6] = _gloffset_FogCoordfvEXT;
   FogCoordFuncs[7] = _gloffset_FogCoorddv;

   ctx->aelt_context = calloc(1, sizeof(AEcontext));
   if (!ctx->aelt_context)
      return GL_FALSE;

   AE_CONTEXT(ctx)->NewState = ~0;
   return GL_TRUE;
}


void
_ae_destroy_context(struct gl_context *ctx)
{
   if (AE_CONTEXT(ctx)) {
      free(ctx->aelt_context);
      ctx->aelt_context = NULL;
   }
}


/**
 * Check if the given vertex buffer object exists and is not mapped.
 * If so, add it to the list of buffers we must map before executing
 * an glArrayElement call.
 */
static void
check_vbo(AEcontext *actx, struct gl_buffer_object *vbo)
{
   if (_mesa_is_bufferobj(vbo) &&
       !_mesa_bufferobj_mapped(vbo, MAP_INTERNAL)) {
      GLuint i;
      for (i = 0; i < actx->nr_vbos; i++)
         if (actx->vbo[i] == vbo)
            return;  /* already in the list, we're done */
      assert(actx->nr_vbos < VERT_ATTRIB_MAX);
      actx->vbo[actx->nr_vbos++] = vbo;
   }
}


static inline void
update_derived_client_arrays(struct gl_context *ctx)
{
   struct gl_vertex_array_object *vao = ctx->Array.VAO;

   if (vao->NewArrays) {
      _mesa_update_vao_client_arrays(ctx, vao);
      vao->NewArrays = 0;
   }
}


/**
 * Make a list of per-vertex functions to call for each glArrayElement call.
 * These functions access the array data (i.e. glVertex, glColor, glNormal,
 * etc).
 * Note: this may be called during display list construction.
 */
static void
_ae_update_state(struct gl_context *ctx)
{
   AEcontext *actx = AE_CONTEXT(ctx);
   AEarray *aa = actx->arrays;  /* non-indexed arrays (ex: glNormal) */
   AEattrib *at = actx->attribs;  /* indexed arrays (ex: glMultiTexCoord) */
   GLuint i;
   struct gl_vertex_array_object *vao = ctx->Array.VAO;

   actx->nr_vbos = 0;

   /* conventional vertex arrays */
   if (vao->_VertexAttrib[VERT_ATTRIB_COLOR_INDEX].Enabled) {
      aa->array = &vao->_VertexAttrib[VERT_ATTRIB_COLOR_INDEX];
      aa->offset = IndexFuncs[TYPE_IDX(aa->array->Type)];
      check_vbo(actx, aa->array->BufferObj);
      aa++;
   }
   if (vao->_VertexAttrib[VERT_ATTRIB_EDGEFLAG].Enabled) {
      aa->array = &vao->_VertexAttrib[VERT_ATTRIB_EDGEFLAG];
      aa->offset = _gloffset_EdgeFlagv;
      check_vbo(actx, aa->array->BufferObj);
      aa++;
   }
   if (vao->_VertexAttrib[VERT_ATTRIB_NORMAL].Enabled) {
      aa->array = &vao->_VertexAttrib[VERT_ATTRIB_NORMAL];
      aa->offset = NormalFuncs[TYPE_IDX(aa->array->Type)];
      check_vbo(actx, aa->array->BufferObj);
      aa++;
   }
   if (vao->_VertexAttrib[VERT_ATTRIB_COLOR0].Enabled) {
      aa->array = &vao->_VertexAttrib[VERT_ATTRIB_COLOR0];
      aa->offset = ColorFuncs[aa->array->Size-3][TYPE_IDX(aa->array->Type)];
      check_vbo(actx, aa->array->BufferObj);
      aa++;
   }
   if (vao->_VertexAttrib[VERT_ATTRIB_COLOR1].Enabled) {
      aa->array = &vao->_VertexAttrib[VERT_ATTRIB_COLOR1];
      aa->offset = SecondaryColorFuncs[TYPE_IDX(aa->array->Type)];
      check_vbo(actx, aa->array->BufferObj);
      aa++;
   }
   if (vao->_VertexAttrib[VERT_ATTRIB_FOG].Enabled) {
      aa->array = &vao->_VertexAttrib[VERT_ATTRIB_FOG];
      aa->offset = FogCoordFuncs[TYPE_IDX(aa->array->Type)];
      check_vbo(actx, aa->array->BufferObj);
      aa++;
   }
   for (i = 0; i < ctx->Const.MaxTextureCoordUnits; i++) {
      struct gl_client_array *attribArray =
         &vao->_VertexAttrib[VERT_ATTRIB_TEX(i)];
      if (attribArray->Enabled) {
         /* NOTE: we use generic glVertexAttribNV functions here.
          * If we ever remove GL_NV_vertex_program this will have to change.
          */
         at->array = attribArray;
         ASSERT(!at->array->Normalized);
         at->func = AttribFuncsNV[at->array->Normalized]
                                 [at->array->Size-1]
                                 [TYPE_IDX(at->array->Type)];
         at->index = VERT_ATTRIB_TEX0 + i;
	 check_vbo(actx, at->array->BufferObj);
         at++;
      }
   }

   /* generic vertex attribute arrays */
   for (i = 1; i < VERT_ATTRIB_GENERIC_MAX; i++) {  /* skip zero! */
      struct gl_client_array *attribArray =
         &vao->_VertexAttrib[VERT_ATTRIB_GENERIC(i)];
      if (attribArray->Enabled) {
         GLint intOrNorm;
         at->array = attribArray;
         /* Note: we can't grab the _glapi_Dispatch->VertexAttrib1fvNV
          * function pointer here (for float arrays) since the pointer may
          * change from one execution of _ae_ArrayElement() to
          * the next.  Doing so caused UT to break.
          */
         if (at->array->Integer)
            intOrNorm = 2;
         else if (at->array->Normalized)
            intOrNorm = 1;
         else
            intOrNorm = 0;

         at->func = AttribFuncsARB[intOrNorm]
            [at->array->Size-1]
            [TYPE_IDX(at->array->Type)];

         at->index = i;
	 check_vbo(actx, at->array->BufferObj);
         at++;
      }
   }

   /* finally, vertex position */
   if (vao->_VertexAttrib[VERT_ATTRIB_GENERIC0].Enabled) {
      /* Use glVertex(v) instead of glVertexAttrib(0, v) to be sure it's
       * issued as the last (provoking) attribute).
       */
      aa->array = &vao->_VertexAttrib[VERT_ATTRIB_GENERIC0];
      assert(aa->array->Size >= 2); /* XXX fix someday? */
      aa->offset = VertexFuncs[aa->array->Size-2][TYPE_IDX(aa->array->Type)];
      check_vbo(actx, aa->array->BufferObj);
      aa++;
   }
   else if (vao->_VertexAttrib[VERT_ATTRIB_POS].Enabled) {
      aa->array = &vao->_VertexAttrib[VERT_ATTRIB_POS];
      aa->offset = VertexFuncs[aa->array->Size-2][TYPE_IDX(aa->array->Type)];
      check_vbo(actx, aa->array->BufferObj);
      aa++;
   }

   check_vbo(actx, vao->IndexBufferObj);

   ASSERT(at - actx->attribs <= VERT_ATTRIB_MAX);
   ASSERT(aa - actx->arrays < 32);
   at->func = NULL;  /* terminate the list */
   aa->offset = -1;  /* terminate the list */

   actx->NewState = 0;
}


/**
 * Before replaying glArrayElements calls we need to map (for reading) any
 * VBOs referenced by the enabled vertex arrays.
 */
void
_ae_map_vbos(struct gl_context *ctx)
{
   AEcontext *actx = AE_CONTEXT(ctx);
   GLuint i;

   if (actx->mapped_vbos)
      return;

   update_derived_client_arrays(ctx);

   if (actx->NewState)
      _ae_update_state(ctx);

   for (i = 0; i < actx->nr_vbos; i++)
      ctx->Driver.MapBufferRange(ctx, 0,
				 actx->vbo[i]->Size,
				 GL_MAP_READ_BIT,
				 actx->vbo[i],
                                 MAP_INTERNAL);

   if (actx->nr_vbos)
      actx->mapped_vbos = GL_TRUE;
}


/**
 * Unmap VBOs
 */
void
_ae_unmap_vbos(struct gl_context *ctx)
{
   AEcontext *actx = AE_CONTEXT(ctx);
   GLuint i;

   if (!actx->mapped_vbos)
      return;

   assert (!actx->NewState);

   for (i = 0; i < actx->nr_vbos; i++)
      ctx->Driver.UnmapBuffer(ctx, actx->vbo[i], MAP_INTERNAL);

   actx->mapped_vbos = GL_FALSE;
}


/**
 * Called via glArrayElement() and glDrawArrays().
 * Issue the glNormal, glVertex, glColor, glVertexAttrib, etc functions
 * for all enabled vertex arrays (for elt-th element).
 * Note: this may be called during display list construction.
 */
void GLAPIENTRY
_ae_ArrayElement(GLint elt)
{
   GET_CURRENT_CONTEXT(ctx);
   const AEcontext *actx = AE_CONTEXT(ctx);
   const AEarray *aa;
   const AEattrib *at;
   const struct _glapi_table * const disp = GET_DISPATCH();
   GLboolean do_map;

   update_derived_client_arrays(ctx);

   /* If PrimitiveRestart is enabled and the index is the RestartIndex
    * then we call PrimitiveRestartNV and return.
    */
   if (ctx->Array.PrimitiveRestart && (elt == ctx->Array.RestartIndex)) {
      CALL_PrimitiveRestartNV((struct _glapi_table *)disp, ());
      return;
   }

   if (actx->NewState) {
      assert(!actx->mapped_vbos);
      _ae_update_state(ctx);
   }

   /* Determine if we need to map/unmap VBOs */
   do_map = actx->nr_vbos && !actx->mapped_vbos;

   if (do_map)
      _ae_map_vbos(ctx);

   /* emit generic attribute elements */
   for (at = actx->attribs; at->func; at++) {
      const GLubyte *src
         = ADD_POINTERS(at->array->BufferObj->Mappings[MAP_INTERNAL].Pointer,
                        at->array->Ptr)
         + elt * at->array->StrideB;
      at->func(at->index, src);
   }

   /* emit conventional arrays elements */
   for (aa = actx->arrays; aa->offset != -1 ; aa++) {
      const GLubyte *src
         = ADD_POINTERS(aa->array->BufferObj->Mappings[MAP_INTERNAL].Pointer,
                        aa->array->Ptr)
         + elt * aa->array->StrideB;
      CALL_by_offset(disp, (array_func), aa->offset, ((const void *) src));
   }

   if (do_map)
      _ae_unmap_vbos(ctx);
}


void
_ae_invalidate_state(struct gl_context *ctx, GLuint new_state)
{
   AEcontext *actx = AE_CONTEXT(ctx);

   /* Only interested in this subset of mesa state.  Need to prune
    * this down as both tnl/ and the drivers can raise statechanges
    * for arcane reasons in the middle of seemingly atomic operations
    * like DrawElements, over which we'd like to keep a known set of
    * arrays and vbo's mapped.
    *
    * Luckily, neither the drivers nor tnl muck with the state that
    * concerns us here:
    */
   new_state &= _NEW_ARRAY | _NEW_PROGRAM;
   if (new_state) {
      assert(!actx->mapped_vbos);
      actx->NewState |= new_state;
   }
}


void
_mesa_install_arrayelt_vtxfmt(struct _glapi_table *disp,
                              const GLvertexformat *vfmt)
{
   SET_ArrayElement(disp, vfmt->ArrayElement);
}
@


1.10
log
@Merge Mesa 10.2.9
@
text
@@


1.9
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a45 1
#include "varray.h"
d50 1
a50 2
   const struct gl_vertex_attrib_array *array;
   const struct gl_vertex_buffer_binding *binding;
d57 1
a57 2
   const struct gl_vertex_attrib_array *array;
   const struct gl_vertex_buffer_binding *binding;
d75 1
a75 1
static inline AEcontext *
d87 1
a87 1
static inline int
d1473 12
d1503 2
a1504 3
   if (vao->VertexAttrib[VERT_ATTRIB_COLOR_INDEX].Enabled) {
      aa->array = &vao->VertexAttrib[VERT_ATTRIB_COLOR_INDEX];
      aa->binding = &vao->VertexBinding[aa->array->VertexBinding];
d1506 1
a1506 1
      check_vbo(actx, aa->binding->BufferObj);
d1509 2
a1510 4

   if (vao->VertexAttrib[VERT_ATTRIB_EDGEFLAG].Enabled) {
      aa->array = &vao->VertexAttrib[VERT_ATTRIB_EDGEFLAG];
      aa->binding = &vao->VertexBinding[aa->array->VertexBinding];
d1512 1
a1512 1
      check_vbo(actx, aa->binding->BufferObj);
d1515 2
a1516 4

   if (vao->VertexAttrib[VERT_ATTRIB_NORMAL].Enabled) {
      aa->array = &vao->VertexAttrib[VERT_ATTRIB_NORMAL];
      aa->binding = &vao->VertexBinding[aa->array->VertexBinding];
d1518 1
a1518 1
      check_vbo(actx, aa->binding->BufferObj);
d1521 2
a1522 4

   if (vao->VertexAttrib[VERT_ATTRIB_COLOR0].Enabled) {
      aa->array = &vao->VertexAttrib[VERT_ATTRIB_COLOR0];
      aa->binding = &vao->VertexBinding[aa->array->VertexBinding];
d1524 1
a1524 1
      check_vbo(actx, aa->binding->BufferObj);
d1527 2
a1528 4

   if (vao->VertexAttrib[VERT_ATTRIB_COLOR1].Enabled) {
      aa->array = &vao->VertexAttrib[VERT_ATTRIB_COLOR1];
      aa->binding = &vao->VertexBinding[aa->array->VertexBinding];
d1530 1
a1530 1
      check_vbo(actx, aa->binding->BufferObj);
d1533 2
a1534 4

   if (vao->VertexAttrib[VERT_ATTRIB_FOG].Enabled) {
      aa->array = &vao->VertexAttrib[VERT_ATTRIB_FOG];
      aa->binding = &vao->VertexBinding[aa->array->VertexBinding];
d1536 1
a1536 1
      check_vbo(actx, aa->binding->BufferObj);
a1538 1

d1540 2
a1541 2
      struct gl_vertex_attrib_array *attribArray =
         &vao->VertexAttrib[VERT_ATTRIB_TEX(i)];
a1546 1
         at->binding = &vao->VertexBinding[attribArray->VertexBinding];
d1552 1
a1552 1
	 check_vbo(actx, at->binding->BufferObj);
d1559 2
a1560 2
      struct gl_vertex_attrib_array *attribArray =
         &vao->VertexAttrib[VERT_ATTRIB_GENERIC(i)];
a1563 1
         at->binding = &vao->VertexBinding[attribArray->VertexBinding];
d1581 1
a1581 1
	 check_vbo(actx, at->binding->BufferObj);
d1587 1
a1587 1
   if (vao->VertexAttrib[VERT_ATTRIB_GENERIC0].Enabled) {
d1591 1
a1591 2
      aa->array = &vao->VertexAttrib[VERT_ATTRIB_GENERIC0];
      aa->binding = &vao->VertexBinding[aa->array->VertexBinding];
d1594 1
a1594 1
      check_vbo(actx, aa->binding->BufferObj);
d1597 2
a1598 3
   else if (vao->VertexAttrib[VERT_ATTRIB_POS].Enabled) {
      aa->array = &vao->VertexAttrib[VERT_ATTRIB_POS];
      aa->binding = &vao->VertexBinding[aa->array->VertexBinding];
d1600 1
a1600 1
      check_vbo(actx, aa->binding->BufferObj);
d1628 2
d1682 2
d1706 3
a1708 3
         = ADD_POINTERS(at->binding->BufferObj->Mappings[MAP_INTERNAL].Pointer,
                        _mesa_vertex_attrib_address(at->array, at->binding))
         + elt * at->binding->Stride;
d1715 3
a1717 3
         = ADD_POINTERS(aa->binding->BufferObj->Mappings[MAP_INTERNAL].Pointer,
                        _mesa_vertex_attrib_address(aa->array, aa->binding))
         + elt * aa->binding->Stride;
@


1.8
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d46 1
d51 2
a52 1
   const struct gl_client_array *array;
d59 2
a60 1
   const struct gl_client_array *array;
d78 1
a78 1
static INLINE AEcontext *
d90 1
a90 1
static INLINE int
a1475 12
static inline void
update_derived_client_arrays(struct gl_context *ctx)
{
   struct gl_vertex_array_object *vao = ctx->Array.VAO;

   if (vao->NewArrays) {
      _mesa_update_vao_client_arrays(ctx, vao);
      vao->NewArrays = 0;
   }
}


d1494 3
a1496 2
   if (vao->_VertexAttrib[VERT_ATTRIB_COLOR_INDEX].Enabled) {
      aa->array = &vao->_VertexAttrib[VERT_ATTRIB_COLOR_INDEX];
d1498 1
a1498 1
      check_vbo(actx, aa->array->BufferObj);
d1501 4
a1504 2
   if (vao->_VertexAttrib[VERT_ATTRIB_EDGEFLAG].Enabled) {
      aa->array = &vao->_VertexAttrib[VERT_ATTRIB_EDGEFLAG];
d1506 1
a1506 1
      check_vbo(actx, aa->array->BufferObj);
d1509 4
a1512 2
   if (vao->_VertexAttrib[VERT_ATTRIB_NORMAL].Enabled) {
      aa->array = &vao->_VertexAttrib[VERT_ATTRIB_NORMAL];
d1514 1
a1514 1
      check_vbo(actx, aa->array->BufferObj);
d1517 4
a1520 2
   if (vao->_VertexAttrib[VERT_ATTRIB_COLOR0].Enabled) {
      aa->array = &vao->_VertexAttrib[VERT_ATTRIB_COLOR0];
d1522 1
a1522 1
      check_vbo(actx, aa->array->BufferObj);
d1525 4
a1528 2
   if (vao->_VertexAttrib[VERT_ATTRIB_COLOR1].Enabled) {
      aa->array = &vao->_VertexAttrib[VERT_ATTRIB_COLOR1];
d1530 1
a1530 1
      check_vbo(actx, aa->array->BufferObj);
d1533 4
a1536 2
   if (vao->_VertexAttrib[VERT_ATTRIB_FOG].Enabled) {
      aa->array = &vao->_VertexAttrib[VERT_ATTRIB_FOG];
d1538 1
a1538 1
      check_vbo(actx, aa->array->BufferObj);
d1541 1
d1543 2
a1544 2
      struct gl_client_array *attribArray =
         &vao->_VertexAttrib[VERT_ATTRIB_TEX(i)];
d1550 1
d1556 1
a1556 1
	 check_vbo(actx, at->array->BufferObj);
d1563 2
a1564 2
      struct gl_client_array *attribArray =
         &vao->_VertexAttrib[VERT_ATTRIB_GENERIC(i)];
d1568 1
d1586 1
a1586 1
	 check_vbo(actx, at->array->BufferObj);
d1592 1
a1592 1
   if (vao->_VertexAttrib[VERT_ATTRIB_GENERIC0].Enabled) {
d1596 2
a1597 1
      aa->array = &vao->_VertexAttrib[VERT_ATTRIB_GENERIC0];
d1600 1
a1600 1
      check_vbo(actx, aa->array->BufferObj);
d1603 3
a1605 2
   else if (vao->_VertexAttrib[VERT_ATTRIB_POS].Enabled) {
      aa->array = &vao->_VertexAttrib[VERT_ATTRIB_POS];
d1607 1
a1607 1
      check_vbo(actx, aa->array->BufferObj);
a1634 2
   update_derived_client_arrays(ctx);

a1686 2
   update_derived_client_arrays(ctx);

d1709 3
a1711 3
         = ADD_POINTERS(at->array->BufferObj->Mappings[MAP_INTERNAL].Pointer,
                        at->array->Ptr)
         + elt * at->array->StrideB;
d1718 3
a1720 3
         = ADD_POINTERS(aa->array->BufferObj->Mappings[MAP_INTERNAL].Pointer,
                        aa->array->Ptr)
         + elt * aa->array->StrideB;
@


1.7
log
@Merge Mesa 9.2.0
@
text
@d34 1
a34 1
 *    Keith Whitwell <keith@@tungstengraphics.com>
d38 1
d1461 2
a1462 1
   if (_mesa_is_bufferobj(vbo) && !_mesa_bufferobj_mapped(vbo)) {
d1473 12
d1498 1
a1498 1
   struct gl_array_object *arrayObj = ctx->Array.ArrayObj;
d1503 2
a1504 2
   if (arrayObj->VertexAttrib[VERT_ATTRIB_COLOR_INDEX].Enabled) {
      aa->array = &arrayObj->VertexAttrib[VERT_ATTRIB_COLOR_INDEX];
d1509 2
a1510 2
   if (arrayObj->VertexAttrib[VERT_ATTRIB_EDGEFLAG].Enabled) {
      aa->array = &arrayObj->VertexAttrib[VERT_ATTRIB_EDGEFLAG];
d1515 2
a1516 2
   if (arrayObj->VertexAttrib[VERT_ATTRIB_NORMAL].Enabled) {
      aa->array = &arrayObj->VertexAttrib[VERT_ATTRIB_NORMAL];
d1521 2
a1522 2
   if (arrayObj->VertexAttrib[VERT_ATTRIB_COLOR0].Enabled) {
      aa->array = &arrayObj->VertexAttrib[VERT_ATTRIB_COLOR0];
d1527 2
a1528 2
   if (arrayObj->VertexAttrib[VERT_ATTRIB_COLOR1].Enabled) {
      aa->array = &arrayObj->VertexAttrib[VERT_ATTRIB_COLOR1];
d1533 2
a1534 2
   if (arrayObj->VertexAttrib[VERT_ATTRIB_FOG].Enabled) {
      aa->array = &arrayObj->VertexAttrib[VERT_ATTRIB_FOG];
d1541 1
a1541 1
         &arrayObj->VertexAttrib[VERT_ATTRIB_TEX(i)];
d1560 1
a1560 1
         &arrayObj->VertexAttrib[VERT_ATTRIB_GENERIC(i)];
d1587 1
a1587 1
   if (arrayObj->VertexAttrib[VERT_ATTRIB_GENERIC0].Enabled) {
d1591 1
a1591 1
      aa->array = &arrayObj->VertexAttrib[VERT_ATTRIB_GENERIC0];
d1597 2
a1598 2
   else if (arrayObj->VertexAttrib[VERT_ATTRIB_POS].Enabled) {
      aa->array = &arrayObj->VertexAttrib[VERT_ATTRIB_POS];
d1604 1
a1604 1
   check_vbo(actx, arrayObj->ElementArrayBufferObj);
d1628 2
d1637 2
a1638 1
				 actx->vbo[i]);
d1660 1
a1660 1
      ctx->Driver.UnmapBuffer(ctx, actx->vbo[i]);
d1682 2
d1706 2
a1707 1
         = ADD_POINTERS(at->array->BufferObj->Pointer, at->array->Ptr)
d1715 2
a1716 1
         = ADD_POINTERS(aa->array->BufferObj->Pointer, aa->array->Ptr)
@


1.6
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a2 1
 * Version:  6.5.1
d19 4
a22 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
a42 1
#include "mfeatures.h"
d66 1
d69 2
a70 1
   GLboolean mapped_vbos;
a71 1
} AEcontext;
d73 6
a78 1
#define AE_CONTEXT(ctx) ((AEcontext *)(ctx)->aelt_context)
d86 6
a91 1
#define TYPE_IDX(t) ( (t) == GL_DOUBLE ? 7 : (t) & 7 )
a95 3
#if FEATURE_arrayelt


d1081 1
a1081 1
   CALL_VertexAttrib1dvARB(GET_DISPATCH(), (index, v));
d1087 1
a1087 1
   CALL_VertexAttrib2dvARB(GET_DISPATCH(), (index, v));
d1093 1
a1093 1
   CALL_VertexAttrib3dvARB(GET_DISPATCH(), (index, v));
d1099 1
a1099 1
   CALL_VertexAttrib4dvARB(GET_DISPATCH(), (index, v));
d1127 1
a1127 1
   CALL_VertexAttribI4bvEXT(GET_DISPATCH(), (index, v));
d1152 1
a1152 1
   CALL_VertexAttribI4ubvEXT(GET_DISPATCH(), (index, v));
d1178 1
a1178 1
   CALL_VertexAttribI4svEXT(GET_DISPATCH(), (index, v));
d1203 1
a1203 1
   CALL_VertexAttribI4usvEXT(GET_DISPATCH(), (index, v));
a1257 2


a1406 2
/**********************************************************************/

d1408 2
a1409 1
GLboolean _ae_create_context( struct gl_context *ctx )
d1415 6
a1420 6
   SecondaryColorFuncs[0] = _gloffset_SecondaryColor3bvEXT;
   SecondaryColorFuncs[1] = _gloffset_SecondaryColor3ubvEXT;
   SecondaryColorFuncs[2] = _gloffset_SecondaryColor3svEXT;
   SecondaryColorFuncs[3] = _gloffset_SecondaryColor3usvEXT;
   SecondaryColorFuncs[4] = _gloffset_SecondaryColor3ivEXT;
   SecondaryColorFuncs[5] = _gloffset_SecondaryColor3uivEXT;
d1422 1
a1422 1
   SecondaryColorFuncs[7] = _gloffset_SecondaryColor3dvEXT;
d1431 1
a1431 1
   FogCoordFuncs[7] = _gloffset_FogCoorddvEXT;
d1433 1
a1433 1
   ctx->aelt_context = CALLOC( sizeof(AEcontext) );
d1442 2
a1443 1
void _ae_destroy_context( struct gl_context *ctx )
d1445 2
a1446 2
   if ( AE_CONTEXT( ctx ) ) {
      FREE( ctx->aelt_context );
d1451 8
a1458 2
static void check_vbo( AEcontext *actx,
		       struct gl_buffer_object *vbo )
d1463 2
a1464 2
	 if (actx->vbo[i] == vbo)
	    return;
d1477 2
a1478 1
static void _ae_update_state( struct gl_context *ctx )
d1481 2
a1482 2
   AEarray *aa = actx->arrays;
   AEattrib *at = actx->attribs;
d1489 2
a1490 2
   if (arrayObj->Index.Enabled) {
      aa->array = &arrayObj->Index;
d1495 2
a1496 2
   if (arrayObj->EdgeFlag.Enabled) {
      aa->array = &arrayObj->EdgeFlag;
d1501 2
a1502 2
   if (arrayObj->Normal.Enabled) {
      aa->array = &arrayObj->Normal;
d1507 2
a1508 2
   if (arrayObj->Color.Enabled) {
      aa->array = &arrayObj->Color;
d1513 2
a1514 2
   if (arrayObj->SecondaryColor.Enabled) {
      aa->array = &arrayObj->SecondaryColor;
d1519 2
a1520 2
   if (arrayObj->FogCoord.Enabled) {
      aa->array = &arrayObj->FogCoord;
d1526 2
a1527 1
      struct gl_client_array *attribArray = &arrayObj->TexCoord[i];
d1543 4
a1546 3
   /* generic vertex attribute arrays */   
   for (i = 1; i < Elements(arrayObj->VertexAttrib); i++) {  /* skip zero! */
      struct gl_client_array *attribArray = &arrayObj->VertexAttrib[i];
d1548 1
d1555 11
a1565 19
         if (ctx->VertexProgram._Enabled
             && ctx->VertexProgram.Current->IsNVProgram) {
            at->func = AttribFuncsNV[at->array->Normalized]
                                    [at->array->Size-1]
                                    [TYPE_IDX(at->array->Type)];
         }
         else {
            GLint intOrNorm;
            if (at->array->Integer)
               intOrNorm = 2;
            else if (at->array->Normalized)
               intOrNorm = 1;
            else
               intOrNorm = 0;

            at->func = AttribFuncsARB[intOrNorm]
                                     [at->array->Size-1]
                                     [TYPE_IDX(at->array->Type)];
         }
d1573 1
a1573 1
   if (arrayObj->VertexAttrib[0].Enabled) {
d1577 1
a1577 1
      aa->array = &arrayObj->VertexAttrib[0];
d1583 2
a1584 2
   else if (arrayObj->Vertex.Enabled) {
      aa->array = &arrayObj->Vertex;
d1590 1
a1590 1
   check_vbo(actx, ctx->Array.ElementArrayBufferObj);
d1600 7
a1606 1
void _ae_map_vbos( struct gl_context *ctx )
d1610 1
a1610 1
   
d1618 4
a1621 4
      ctx->Driver.MapBuffer(ctx,
			    GL_ARRAY_BUFFER_ARB,
			    GL_DYNAMIC_DRAW_ARB,
			    actx->vbo[i]);
d1627 6
a1632 1
void _ae_unmap_vbos( struct gl_context *ctx )
d1643 1
a1643 3
      ctx->Driver.UnmapBuffer(ctx,
			      GL_ARRAY_BUFFER_ARB,
			      actx->vbo[i]);
d1655 2
a1656 1
void GLAPIENTRY _ae_ArrayElement( GLint elt )
d1665 8
d1675 1
a1675 1
      _ae_update_state( ctx );
d1678 1
a1678 1
   /* Determine if w need to map/unmap VBOs */
d1683 1
a1683 1
   
d1689 1
a1689 1
      at->func( at->index, src );
d1697 1
a1697 2
      CALL_by_offset( disp, (array_func), aa->offset, 
		      ((const void *) src) );
d1705 2
a1706 1
void _ae_invalidate_state( struct gl_context *ctx, GLuint new_state )
a1709 1
   
d1714 1
a1714 1
    * arrays and vbo's mapped.  
d1727 3
a1729 2
void _mesa_install_arrayelt_vtxfmt(struct _glapi_table *disp,
                                   const GLvertexformat *vfmt)
a1732 3


#endif /* FEATURE_arrayelt */
@


1.5
log
@Merge Mesa 7.10.3
@
text
@d43 2
d178 1
a178 1
static void
d184 1
a184 1
static void
d190 1
a190 1
static void
d196 1
a196 1
static void
d202 1
a202 1
static void
d210 1
a210 1
static void
d216 1
a216 1
static void
d225 1
a225 1
static void
d233 1
a233 1
static void
d239 1
a239 1
static void
d245 1
a245 1
static void
d252 1
a252 1
static void
d258 1
a258 1
static void
d265 1
a265 1
static void
d272 1
a272 1
static void
d281 1
a281 1
static void
d291 1
a291 1
static void
d297 1
a297 1
static void
d303 1
a303 1
static void
d310 1
a310 1
static void
d316 1
a316 1
static void
d324 1
a324 1
static void
d331 1
a331 1
static void
d340 1
a340 1
static void
d349 1
a349 1
static void
d355 1
a355 1
static void
d361 1
a361 1
static void
d368 1
a368 1
static void
d375 1
a375 1
static void
d383 1
a383 1
static void
d390 1
a390 1
static void
d399 1
a399 1
static void
d408 1
a408 1
static void
d414 1
a414 1
static void
d420 1
a420 1
static void
d427 1
a427 1
static void
d433 1
a433 1
static void
d441 1
a441 1
static void
d448 1
a448 1
static void
d457 1
a457 1
static void
d466 1
a466 1
static void
d472 1
a472 1
static void
d478 1
a478 1
static void
d485 1
a485 1
static void
d492 1
a492 1
static void
d500 1
a500 1
static void
d507 1
a507 1
static void
d516 1
a516 1
static void
d525 1
a525 1
static void
d531 1
a531 1
static void
d537 1
a537 1
static void
d543 1
a543 1
static void
d551 1
a551 1
static void
d557 1
a557 1
static void
d563 1
a563 1
static void
d569 1
a569 1
static void
d683 1
a683 1
static void
d689 1
a689 1
static void
d695 1
a695 1
static void
d701 1
a701 1
static void
d707 1
a707 1
static void
d715 1
a715 1
static void
d721 1
a721 1
static void
d730 1
a730 1
static void
d738 1
a738 1
static void
d744 1
a744 1
static void
d750 1
a750 1
static void
d758 1
a758 1
static void
d765 1
a765 1
static void
d773 1
a773 1
static void
d782 1
a782 1
static void
d793 1
a793 1
static void
d804 1
a804 1
static void
d810 1
a810 1
static void
d816 1
a816 1
static void
d824 1
a824 1
static void
d831 1
a831 1
static void
d841 1
a841 1
static void
d849 1
a849 1
static void
d860 1
a860 1
static void
d869 1
a869 1
static void
d875 1
a875 1
static void
d881 1
a881 1
static void
d888 1
a888 1
static void
d895 1
a895 1
static void
d903 1
a903 1
static void
d910 1
a910 1
static void
d919 1
a919 1
static void
d927 1
a927 1
static void
d933 1
a933 1
static void
d939 1
a939 1
static void
d946 1
a946 1
static void
d953 1
a953 1
static void
d961 1
a961 1
static void
d968 1
a968 1
static void
d977 1
a977 1
static void
d986 1
a986 1
static void
d992 1
a992 1
static void
d998 1
a998 1
static void
d1005 1
a1005 1
static void
d1012 1
a1012 1
static void
d1020 1
a1020 1
static void
d1027 1
a1027 1
static void
d1036 1
a1036 1
static void
d1045 1
a1045 1
static void
d1051 1
a1051 1
static void
d1057 1
a1057 1
static void
d1063 1
a1063 1
static void
d1071 1
a1071 1
static void
d1077 1
a1077 1
static void
d1083 1
a1083 1
static void
d1089 1
a1089 1
static void
d1099 1
a1099 1
static void
d1105 1
a1105 1
static void
d1111 1
a1111 1
static void
d1117 1
a1117 1
static void
d1124 1
a1124 1
static void
d1130 1
a1130 1
static void
d1136 1
a1136 1
static void
d1142 1
a1142 1
static void
d1150 1
a1150 1
static void
d1156 1
a1156 1
static void
d1162 1
a1162 1
static void
d1168 1
a1168 1
static void
d1175 1
a1175 1
static void
d1181 1
a1181 1
static void
d1187 1
a1187 1
static void
d1193 1
a1193 1
static void
d1201 1
a1201 1
static void
d1207 1
a1207 1
static void
d1213 1
a1213 1
static void
d1219 1
a1219 1
static void
d1226 1
a1226 1
static void
d1232 1
a1232 1
static void
d1238 1
a1238 1
static void
d1244 1
a1244 1
static void
@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d25 8
d81 2
d87 1
a87 1
static const int ColorFuncs[2][8] = {
d110 1
a110 1
static const int VertexFuncs[3][8] = {
d143 1
a143 1
static const int IndexFuncs[8] = {
d154 1
a154 1
static const int NormalFuncs[8] = {
d166 2
a167 2
static int SecondaryColorFuncs[8];
static int FogCoordFuncs[8];
d176 2
a177 1
static void GLAPIENTRY VertexAttrib1NbvNV(GLuint index, const GLbyte *v)
d182 2
a183 1
static void GLAPIENTRY VertexAttrib1bvNV(GLuint index, const GLbyte *v)
d188 2
a189 1
static void GLAPIENTRY VertexAttrib2NbvNV(GLuint index, const GLbyte *v)
d194 2
a195 1
static void GLAPIENTRY VertexAttrib2bvNV(GLuint index, const GLbyte *v)
d200 2
a201 1
static void GLAPIENTRY VertexAttrib3NbvNV(GLuint index, const GLbyte *v)
d208 2
a209 1
static void GLAPIENTRY VertexAttrib3bvNV(GLuint index, const GLbyte *v)
d214 2
a215 1
static void GLAPIENTRY VertexAttrib4NbvNV(GLuint index, const GLbyte *v)
d223 2
a224 1
static void GLAPIENTRY VertexAttrib4bvNV(GLuint index, const GLbyte *v)
d231 2
a232 1
static void GLAPIENTRY VertexAttrib1NubvNV(GLuint index, const GLubyte *v)
d237 2
a238 1
static void GLAPIENTRY VertexAttrib1ubvNV(GLuint index, const GLubyte *v)
d243 2
a244 1
static void GLAPIENTRY VertexAttrib2NubvNV(GLuint index, const GLubyte *v)
d247 1
a247 1
					       UBYTE_TO_FLOAT(v[1])));
d250 2
a251 1
static void GLAPIENTRY VertexAttrib2ubvNV(GLuint index, const GLubyte *v)
d256 2
a257 1
static void GLAPIENTRY VertexAttrib3NubvNV(GLuint index, const GLubyte *v)
d263 2
a264 1
static void GLAPIENTRY VertexAttrib3ubvNV(GLuint index, const GLubyte *v)
d266 2
a267 1
   CALL_VertexAttrib3fNV(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1], (GLfloat)v[2]));
d270 2
a271 1
static void GLAPIENTRY VertexAttrib4NubvNV(GLuint index, const GLubyte *v)
d274 3
a276 3
                                     UBYTE_TO_FLOAT(v[1]),
                                     UBYTE_TO_FLOAT(v[2]),
                                     UBYTE_TO_FLOAT(v[3])));
d279 2
a280 1
static void GLAPIENTRY VertexAttrib4ubvNV(GLuint index, const GLubyte *v)
d282 3
a284 1
   CALL_VertexAttrib4fNV(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1], (GLfloat)v[2], (GLfloat)v[3]));
d289 2
a290 1
static void GLAPIENTRY VertexAttrib1NsvNV(GLuint index, const GLshort *v)
d295 2
a296 1
static void GLAPIENTRY VertexAttrib1svNV(GLuint index, const GLshort *v)
d301 2
a302 1
static void GLAPIENTRY VertexAttrib2NsvNV(GLuint index, const GLshort *v)
d305 1
a305 1
					       SHORT_TO_FLOAT(v[1])));
d308 2
a309 1
static void GLAPIENTRY VertexAttrib2svNV(GLuint index, const GLshort *v)
d314 2
a315 1
static void GLAPIENTRY VertexAttrib3NsvNV(GLuint index, const GLshort *v)
d322 2
a323 1
static void GLAPIENTRY VertexAttrib3svNV(GLuint index, const GLshort *v)
d325 2
a326 1
   CALL_VertexAttrib3fNV(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1], (GLfloat)v[2]));
d329 2
a330 1
static void GLAPIENTRY VertexAttrib4NsvNV(GLuint index, const GLshort *v)
d338 2
a339 1
static void GLAPIENTRY VertexAttrib4svNV(GLuint index, const GLshort *v)
d341 2
a342 1
   CALL_VertexAttrib4fNV(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1], (GLfloat)v[2], (GLfloat)v[3]));
d347 2
a348 1
static void GLAPIENTRY VertexAttrib1NusvNV(GLuint index, const GLushort *v)
d353 2
a354 1
static void GLAPIENTRY VertexAttrib1usvNV(GLuint index, const GLushort *v)
d359 2
a360 1
static void GLAPIENTRY VertexAttrib2NusvNV(GLuint index, const GLushort *v)
d366 2
a367 1
static void GLAPIENTRY VertexAttrib2usvNV(GLuint index, const GLushort *v)
d369 2
a370 1
   CALL_VertexAttrib2fNV(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1]));
d373 2
a374 1
static void GLAPIENTRY VertexAttrib3NusvNV(GLuint index, const GLushort *v)
d381 2
a382 1
static void GLAPIENTRY VertexAttrib3usvNV(GLuint index, const GLushort *v)
d384 2
a385 1
   CALL_VertexAttrib3fNV(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1], (GLfloat)v[2]));
d388 2
a389 1
static void GLAPIENTRY VertexAttrib4NusvNV(GLuint index, const GLushort *v)
d397 2
a398 1
static void GLAPIENTRY VertexAttrib4usvNV(GLuint index, const GLushort *v)
d400 2
a401 1
   CALL_VertexAttrib4fNV(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1], (GLfloat)v[2], (GLfloat)v[3]));
d406 2
a407 1
static void GLAPIENTRY VertexAttrib1NivNV(GLuint index, const GLint *v)
d412 2
a413 1
static void GLAPIENTRY VertexAttrib1ivNV(GLuint index, const GLint *v)
d418 2
a419 1
static void GLAPIENTRY VertexAttrib2NivNV(GLuint index, const GLint *v)
d425 2
a426 1
static void GLAPIENTRY VertexAttrib2ivNV(GLuint index, const GLint *v)
d431 2
a432 1
static void GLAPIENTRY VertexAttrib3NivNV(GLuint index, const GLint *v)
d439 2
a440 1
static void GLAPIENTRY VertexAttrib3ivNV(GLuint index, const GLint *v)
d442 2
a443 1
   CALL_VertexAttrib3fNV(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1], (GLfloat)v[2]));
d446 2
a447 1
static void GLAPIENTRY VertexAttrib4NivNV(GLuint index, const GLint *v)
d450 3
a452 3
					       INT_TO_FLOAT(v[1]),
					       INT_TO_FLOAT(v[2]),
					       INT_TO_FLOAT(v[3])));
d455 2
a456 1
static void GLAPIENTRY VertexAttrib4ivNV(GLuint index, const GLint *v)
d458 2
a459 1
   CALL_VertexAttrib4fNV(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1], (GLfloat)v[2], (GLfloat)v[3]));
d464 2
a465 1
static void GLAPIENTRY VertexAttrib1NuivNV(GLuint index, const GLuint *v)
d470 2
a471 1
static void GLAPIENTRY VertexAttrib1uivNV(GLuint index, const GLuint *v)
d476 2
a477 1
static void GLAPIENTRY VertexAttrib2NuivNV(GLuint index, const GLuint *v)
d480 1
a480 1
					       UINT_TO_FLOAT(v[1])));
d483 2
a484 1
static void GLAPIENTRY VertexAttrib2uivNV(GLuint index, const GLuint *v)
d486 2
a487 1
   CALL_VertexAttrib2fNV(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1]));
d490 2
a491 1
static void GLAPIENTRY VertexAttrib3NuivNV(GLuint index, const GLuint *v)
d498 2
a499 1
static void GLAPIENTRY VertexAttrib3uivNV(GLuint index, const GLuint *v)
d501 2
a502 1
   CALL_VertexAttrib3fNV(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1], (GLfloat)v[2]));
d505 2
a506 1
static void GLAPIENTRY VertexAttrib4NuivNV(GLuint index, const GLuint *v)
d514 2
a515 1
static void GLAPIENTRY VertexAttrib4uivNV(GLuint index, const GLuint *v)
d517 2
a518 1
   CALL_VertexAttrib4fNV(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1], (GLfloat)v[2], (GLfloat)v[3]));
d523 2
a524 1
static void GLAPIENTRY VertexAttrib1fvNV(GLuint index, const GLfloat *v)
d529 2
a530 1
static void GLAPIENTRY VertexAttrib2fvNV(GLuint index, const GLfloat *v)
d535 2
a536 1
static void GLAPIENTRY VertexAttrib3fvNV(GLuint index, const GLfloat *v)
d541 2
a542 1
static void GLAPIENTRY VertexAttrib4fvNV(GLuint index, const GLfloat *v)
d549 2
a550 1
static void GLAPIENTRY VertexAttrib1dvNV(GLuint index, const GLdouble *v)
d555 2
a556 1
static void GLAPIENTRY VertexAttrib2dvNV(GLuint index, const GLdouble *v)
d561 2
a562 1
static void GLAPIENTRY VertexAttrib3dvNV(GLuint index, const GLdouble *v)
d567 2
a568 1
static void GLAPIENTRY VertexAttrib4dvNV(GLuint index, const GLdouble *v)
d577 1
a577 1
static attrib_func AttribFuncsNV[2][4][8] = {
d681 2
a682 1
static void GLAPIENTRY VertexAttrib1NbvARB(GLuint index, const GLbyte *v)
d687 2
a688 1
static void GLAPIENTRY VertexAttrib1bvARB(GLuint index, const GLbyte *v)
d693 2
a694 1
static void GLAPIENTRY VertexAttrib2NbvARB(GLuint index, const GLbyte *v)
d699 2
a700 1
static void GLAPIENTRY VertexAttrib2bvARB(GLuint index, const GLbyte *v)
d705 2
a706 1
static void GLAPIENTRY VertexAttrib3NbvARB(GLuint index, const GLbyte *v)
d713 2
a714 1
static void GLAPIENTRY VertexAttrib3bvARB(GLuint index, const GLbyte *v)
d719 2
a720 1
static void GLAPIENTRY VertexAttrib4NbvARB(GLuint index, const GLbyte *v)
d728 2
a729 1
static void GLAPIENTRY VertexAttrib4bvARB(GLuint index, const GLbyte *v)
d736 2
a737 1
static void GLAPIENTRY VertexAttrib1NubvARB(GLuint index, const GLubyte *v)
d742 2
a743 1
static void GLAPIENTRY VertexAttrib1ubvARB(GLuint index, const GLubyte *v)
d748 2
a749 1
static void GLAPIENTRY VertexAttrib2NubvARB(GLuint index, const GLubyte *v)
d751 3
a753 2
   CALL_VertexAttrib2fARB(GET_DISPATCH(), (index, UBYTE_TO_FLOAT(v[0]),
					       UBYTE_TO_FLOAT(v[1])));
d756 2
a757 1
static void GLAPIENTRY VertexAttrib2ubvARB(GLuint index, const GLubyte *v)
d759 2
a760 1
   CALL_VertexAttrib2fARB(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1]));
d763 2
a764 1
static void GLAPIENTRY VertexAttrib3NubvARB(GLuint index, const GLubyte *v)
d766 4
a769 3
   CALL_VertexAttrib3fARB(GET_DISPATCH(), (index, UBYTE_TO_FLOAT(v[0]),
					       UBYTE_TO_FLOAT(v[1]),
					       UBYTE_TO_FLOAT(v[2])));
d771 2
a772 1
static void GLAPIENTRY VertexAttrib3ubvARB(GLuint index, const GLubyte *v)
d774 4
a777 1
   CALL_VertexAttrib3fARB(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1], (GLfloat)v[2]));
d780 2
a781 1
static void GLAPIENTRY VertexAttrib4NubvARB(GLuint index, const GLubyte *v)
d783 6
a788 4
   CALL_VertexAttrib4fARB(GET_DISPATCH(), (index, UBYTE_TO_FLOAT(v[0]),
                                     UBYTE_TO_FLOAT(v[1]),
                                     UBYTE_TO_FLOAT(v[2]),
                                     UBYTE_TO_FLOAT(v[3])));
d791 2
a792 1
static void GLAPIENTRY VertexAttrib4ubvARB(GLuint index, const GLubyte *v)
d794 4
a797 1
   CALL_VertexAttrib4fARB(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1], (GLfloat)v[2], (GLfloat)v[3]));
d802 2
a803 1
static void GLAPIENTRY VertexAttrib1NsvARB(GLuint index, const GLshort *v)
d808 2
a809 1
static void GLAPIENTRY VertexAttrib1svARB(GLuint index, const GLshort *v)
d814 2
a815 1
static void GLAPIENTRY VertexAttrib2NsvARB(GLuint index, const GLshort *v)
d817 3
a819 2
   CALL_VertexAttrib2fARB(GET_DISPATCH(), (index, SHORT_TO_FLOAT(v[0]),
					       SHORT_TO_FLOAT(v[1])));
d822 2
a823 1
static void GLAPIENTRY VertexAttrib2svARB(GLuint index, const GLshort *v)
d825 2
a826 1
   CALL_VertexAttrib2fARB(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1]));
d829 2
a830 1
static void GLAPIENTRY VertexAttrib3NsvARB(GLuint index, const GLshort *v)
d832 5
a836 3
   CALL_VertexAttrib3fARB(GET_DISPATCH(), (index, SHORT_TO_FLOAT(v[0]),
			     SHORT_TO_FLOAT(v[1]),
			     SHORT_TO_FLOAT(v[2])));
d839 2
a840 1
static void GLAPIENTRY VertexAttrib3svARB(GLuint index, const GLshort *v)
d842 3
a844 1
   CALL_VertexAttrib3fARB(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1], (GLfloat)v[2]));
d847 2
a848 1
static void GLAPIENTRY VertexAttrib4NsvARB(GLuint index, const GLshort *v)
d850 6
a855 4
   CALL_VertexAttrib4fARB(GET_DISPATCH(), (index, SHORT_TO_FLOAT(v[0]),
			     SHORT_TO_FLOAT(v[1]),
			     SHORT_TO_FLOAT(v[2]),
			     SHORT_TO_FLOAT(v[3])));
d858 2
a859 1
static void GLAPIENTRY VertexAttrib4svARB(GLuint index, const GLshort *v)
d861 2
a862 1
   CALL_VertexAttrib4fARB(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1], (GLfloat)v[2], (GLfloat)v[3]));
d867 2
a868 1
static void GLAPIENTRY VertexAttrib1NusvARB(GLuint index, const GLushort *v)
d873 2
a874 1
static void GLAPIENTRY VertexAttrib1usvARB(GLuint index, const GLushort *v)
d879 2
a880 1
static void GLAPIENTRY VertexAttrib2NusvARB(GLuint index, const GLushort *v)
d886 2
a887 1
static void GLAPIENTRY VertexAttrib2usvARB(GLuint index, const GLushort *v)
d889 2
a890 1
   CALL_VertexAttrib2fARB(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1]));
d893 2
a894 1
static void GLAPIENTRY VertexAttrib3NusvARB(GLuint index, const GLushort *v)
d901 2
a902 1
static void GLAPIENTRY VertexAttrib3usvARB(GLuint index, const GLushort *v)
d904 2
a905 1
   CALL_VertexAttrib3fARB(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1], (GLfloat)v[2]));
d908 2
a909 1
static void GLAPIENTRY VertexAttrib4NusvARB(GLuint index, const GLushort *v)
d917 2
a918 1
static void GLAPIENTRY VertexAttrib4usvARB(GLuint index, const GLushort *v)
d925 2
a926 1
static void GLAPIENTRY VertexAttrib1NivARB(GLuint index, const GLint *v)
d931 2
a932 1
static void GLAPIENTRY VertexAttrib1ivARB(GLuint index, const GLint *v)
d937 2
a938 1
static void GLAPIENTRY VertexAttrib2NivARB(GLuint index, const GLint *v)
d944 2
a945 1
static void GLAPIENTRY VertexAttrib2ivARB(GLuint index, const GLint *v)
d947 2
a948 1
   CALL_VertexAttrib2fARB(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1]));
d951 2
a952 1
static void GLAPIENTRY VertexAttrib3NivARB(GLuint index, const GLint *v)
d959 2
a960 1
static void GLAPIENTRY VertexAttrib3ivARB(GLuint index, const GLint *v)
d962 2
a963 1
   CALL_VertexAttrib3fARB(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1], (GLfloat)v[2]));
d966 2
a967 1
static void GLAPIENTRY VertexAttrib4NivARB(GLuint index, const GLint *v)
d975 2
a976 1
static void GLAPIENTRY VertexAttrib4ivARB(GLuint index, const GLint *v)
d978 2
a979 1
   CALL_VertexAttrib4fARB(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1], (GLfloat)v[2], (GLfloat)v[3]));
d984 2
a985 1
static void GLAPIENTRY VertexAttrib1NuivARB(GLuint index, const GLuint *v)
d990 2
a991 1
static void GLAPIENTRY VertexAttrib1uivARB(GLuint index, const GLuint *v)
d996 2
a997 1
static void GLAPIENTRY VertexAttrib2NuivARB(GLuint index, const GLuint *v)
d1000 1
a1000 1
					       UINT_TO_FLOAT(v[1])));
d1003 2
a1004 1
static void GLAPIENTRY VertexAttrib2uivARB(GLuint index, const GLuint *v)
d1006 2
a1007 1
   CALL_VertexAttrib2fARB(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1]));
d1010 2
a1011 1
static void GLAPIENTRY VertexAttrib3NuivARB(GLuint index, const GLuint *v)
d1014 2
a1015 2
					       UINT_TO_FLOAT(v[1]),
					       UINT_TO_FLOAT(v[2])));
d1018 2
a1019 1
static void GLAPIENTRY VertexAttrib3uivARB(GLuint index, const GLuint *v)
d1021 2
a1022 1
   CALL_VertexAttrib3fARB(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1], (GLfloat)v[2]));
d1025 2
a1026 1
static void GLAPIENTRY VertexAttrib4NuivARB(GLuint index, const GLuint *v)
d1029 3
a1031 3
					       UINT_TO_FLOAT(v[1]),
					       UINT_TO_FLOAT(v[2]),
					       UINT_TO_FLOAT(v[3])));
d1034 2
a1035 1
static void GLAPIENTRY VertexAttrib4uivARB(GLuint index, const GLuint *v)
d1037 2
a1038 1
   CALL_VertexAttrib4fARB(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1], (GLfloat)v[2], (GLfloat)v[3]));
d1043 2
a1044 1
static void GLAPIENTRY VertexAttrib1fvARB(GLuint index, const GLfloat *v)
d1049 2
a1050 1
static void GLAPIENTRY VertexAttrib2fvARB(GLuint index, const GLfloat *v)
d1055 2
a1056 1
static void GLAPIENTRY VertexAttrib3fvARB(GLuint index, const GLfloat *v)
d1061 2
a1062 1
static void GLAPIENTRY VertexAttrib4fvARB(GLuint index, const GLfloat *v)
d1069 2
a1070 1
static void GLAPIENTRY VertexAttrib1dvARB(GLuint index, const GLdouble *v)
d1075 2
a1076 1
static void GLAPIENTRY VertexAttrib2dvARB(GLuint index, const GLdouble *v)
d1081 2
a1082 1
static void GLAPIENTRY VertexAttrib3dvARB(GLuint index, const GLdouble *v)
d1087 2
a1088 1
static void GLAPIENTRY VertexAttrib4dvARB(GLuint index, const GLdouble *v)
d1094 157
d1252 2
a1253 1
 * Array [size][type] of VertexAttrib functions
d1255 1
a1255 1
static attrib_func AttribFuncsARB[2][4][8] = {
d1349 48
d1403 1
a1403 1
GLboolean _ae_create_context( GLcontext *ctx )
d1436 1
a1436 1
void _ae_destroy_context( GLcontext *ctx )
d1464 1
a1464 1
static void _ae_update_state( GLcontext *ctx )
d1545 9
a1553 1
            at->func = AttribFuncsARB[at->array->Normalized]
d1591 1
a1591 1
void _ae_map_vbos( GLcontext *ctx )
d1612 1
a1612 1
void _ae_unmap_vbos( GLcontext *ctx )
d1651 1
a1653 2
   /* 
    */
d1657 1
a1657 1
   /* generic attributes */
d1665 1
a1665 1
   /* conventional arrays */
d1679 1
a1679 1
void _ae_invalidate_state( GLcontext *ctx, GLuint new_state )
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d31 1
d35 1
a35 2
#include "glapi/glapioffsets.h"
#include "glapi/dispatch.h"
d73 4
d1078 1
a1078 1
   if (vbo->Name && !vbo->Pointer) {
d1101 1
d1106 2
a1107 2
  if (ctx->Array.ArrayObj->Index.Enabled) {
      aa->array = &ctx->Array.ArrayObj->Index;
d1112 2
a1113 2
   if (ctx->Array.ArrayObj->EdgeFlag.Enabled) {
      aa->array = &ctx->Array.ArrayObj->EdgeFlag;
d1118 2
a1119 2
   if (ctx->Array.ArrayObj->Normal.Enabled) {
      aa->array = &ctx->Array.ArrayObj->Normal;
d1124 2
a1125 2
   if (ctx->Array.ArrayObj->Color.Enabled) {
      aa->array = &ctx->Array.ArrayObj->Color;
d1130 2
a1131 2
   if (ctx->Array.ArrayObj->SecondaryColor.Enabled) {
      aa->array = &ctx->Array.ArrayObj->SecondaryColor;
d1136 2
a1137 2
   if (ctx->Array.ArrayObj->FogCoord.Enabled) {
      aa->array = &ctx->Array.ArrayObj->FogCoord;
d1143 1
a1143 1
      struct gl_client_array *attribArray = &ctx->Array.ArrayObj->TexCoord[i];
d1160 2
a1161 2
   for (i = 1; i < VERT_ATTRIB_MAX; i++) {  /* skip zero! */
      struct gl_client_array *attribArray = &ctx->Array.ArrayObj->VertexAttrib[i];
d1166 1
a1166 1
          * change from one execution of _ae_loopback_array_elt() to
d1187 1
a1187 1
   if (ctx->Array.ArrayObj->VertexAttrib[0].Enabled) {
d1191 1
a1191 1
      aa->array = &ctx->Array.ArrayObj->VertexAttrib[0];
d1197 2
a1198 2
   else if (ctx->Array.ArrayObj->Vertex.Enabled) {
      aa->array = &ctx->Array.ArrayObj->Vertex;
d1260 1
a1260 1
void GLAPIENTRY _ae_loopback_array_elt( GLint elt )
d1323 10
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d169 1
a169 1
   CALL_VertexAttrib1fNV(GET_DISPATCH(), (index, v[0]));
d179 1
a179 1
   CALL_VertexAttrib2fNV(GET_DISPATCH(), (index, v[0], v[1]));
d191 1
a191 1
   CALL_VertexAttrib3fNV(GET_DISPATCH(), (index, v[0], v[1], v[2]));
d204 1
a204 1
   CALL_VertexAttrib4fNV(GET_DISPATCH(), (index, v[0], v[1], v[2], v[3]));
d216 1
a216 1
   CALL_VertexAttrib1fNV(GET_DISPATCH(), (index, v[0]));
d227 1
a227 1
   CALL_VertexAttrib2fNV(GET_DISPATCH(), (index, v[0], v[1]));
d238 1
a238 1
   CALL_VertexAttrib3fNV(GET_DISPATCH(), (index, v[0], v[1], v[2]));
d251 1
a251 1
   CALL_VertexAttrib4fNV(GET_DISPATCH(), (index, v[0], v[1], v[2], v[3]));
d263 1
a263 1
   CALL_VertexAttrib1fNV(GET_DISPATCH(), (index, v[0]));
d274 1
a274 1
   CALL_VertexAttrib2fNV(GET_DISPATCH(), (index, v[0], v[1]));
d286 1
a286 1
   CALL_VertexAttrib3fNV(GET_DISPATCH(), (index, v[0], v[1], v[2]));
d299 1
a299 1
   CALL_VertexAttrib4fNV(GET_DISPATCH(), (index, v[0], v[1], v[2], v[3]));
d311 1
a311 1
   CALL_VertexAttrib1fNV(GET_DISPATCH(), (index, v[0]));
d322 1
a322 1
   CALL_VertexAttrib2fNV(GET_DISPATCH(), (index, v[0], v[1]));
d334 1
a334 1
   CALL_VertexAttrib3fNV(GET_DISPATCH(), (index, v[0], v[1], v[2]));
d347 1
a347 1
   CALL_VertexAttrib4fNV(GET_DISPATCH(), (index, v[0], v[1], v[2], v[3]));
d359 1
a359 1
   CALL_VertexAttrib1fNV(GET_DISPATCH(), (index, v[0]));
d370 1
a370 1
   CALL_VertexAttrib2fNV(GET_DISPATCH(), (index, v[0], v[1]));
d382 1
a382 1
   CALL_VertexAttrib3fNV(GET_DISPATCH(), (index, v[0], v[1], v[2]));
d395 1
a395 1
   CALL_VertexAttrib4fNV(GET_DISPATCH(), (index, v[0], v[1], v[2], v[3]));
d407 1
a407 1
   CALL_VertexAttrib1fNV(GET_DISPATCH(), (index, v[0]));
d418 1
a418 1
   CALL_VertexAttrib2fNV(GET_DISPATCH(), (index, v[0], v[1]));
d430 1
a430 1
   CALL_VertexAttrib3fNV(GET_DISPATCH(), (index, v[0], v[1], v[2]));
d443 1
a443 1
   CALL_VertexAttrib4fNV(GET_DISPATCH(), (index, v[0], v[1], v[2], v[3]));
d605 1
a605 1
   CALL_VertexAttrib1fARB(GET_DISPATCH(), (index, v[0]));
d615 1
a615 1
   CALL_VertexAttrib2fARB(GET_DISPATCH(), (index, v[0], v[1]));
d627 1
a627 1
   CALL_VertexAttrib3fARB(GET_DISPATCH(), (index, v[0], v[1], v[2]));
d640 1
a640 1
   CALL_VertexAttrib4fARB(GET_DISPATCH(), (index, v[0], v[1], v[2], v[3]));
d652 1
a652 1
   CALL_VertexAttrib1fARB(GET_DISPATCH(), (index, v[0]));
d663 1
a663 1
   CALL_VertexAttrib2fARB(GET_DISPATCH(), (index, v[0], v[1]));
d674 1
a674 1
   CALL_VertexAttrib3fARB(GET_DISPATCH(), (index, v[0], v[1], v[2]));
d687 1
a687 1
   CALL_VertexAttrib4fARB(GET_DISPATCH(), (index, v[0], v[1], v[2], v[3]));
d699 1
a699 1
   CALL_VertexAttrib1fARB(GET_DISPATCH(), (index, v[0]));
d710 1
a710 1
   CALL_VertexAttrib2fARB(GET_DISPATCH(), (index, v[0], v[1]));
d722 1
a722 1
   CALL_VertexAttrib3fARB(GET_DISPATCH(), (index, v[0], v[1], v[2]));
d735 1
a735 1
   CALL_VertexAttrib4fARB(GET_DISPATCH(), (index, v[0], v[1], v[2], v[3]));
d747 1
a747 1
   CALL_VertexAttrib1fARB(GET_DISPATCH(), (index, v[0]));
d758 1
a758 1
   CALL_VertexAttrib2fARB(GET_DISPATCH(), (index, v[0], v[1]));
d770 1
a770 1
   CALL_VertexAttrib3fARB(GET_DISPATCH(), (index, v[0], v[1], v[2]));
d783 1
a783 1
   CALL_VertexAttrib4fARB(GET_DISPATCH(), (index, v[0], v[1], v[2], v[3]));
d795 1
a795 1
   CALL_VertexAttrib1fARB(GET_DISPATCH(), (index, v[0]));
d806 1
a806 1
   CALL_VertexAttrib2fARB(GET_DISPATCH(), (index, v[0], v[1]));
d818 1
a818 1
   CALL_VertexAttrib3fARB(GET_DISPATCH(), (index, v[0], v[1], v[2]));
d831 1
a831 1
   CALL_VertexAttrib4fARB(GET_DISPATCH(), (index, v[0], v[1], v[2], v[3]));
d843 1
a843 1
   CALL_VertexAttrib1fARB(GET_DISPATCH(), (index, v[0]));
d854 1
a854 1
   CALL_VertexAttrib2fARB(GET_DISPATCH(), (index, v[0], v[1]));
d866 1
a866 1
   CALL_VertexAttrib3fARB(GET_DISPATCH(), (index, v[0], v[1], v[2]));
d879 1
a879 1
   CALL_VertexAttrib4fARB(GET_DISPATCH(), (index, v[0], v[1], v[2], v[3]));
@


1.1
log
@Initial revision
@
text
@d34 2
a35 2
#include "glapioffsets.h"
#include "dispatch.h"
d56 5
d1054 1
a1054 1
   ctx->aelt_context = MALLOC( sizeof(AEcontext) );
d1071 13
d1098 2
d1104 1
d1110 1
d1116 1
d1122 1
d1128 1
d1134 1
d1149 1
d1154 1
a1154 1
   /* generic vertex attribute arrays */
d1176 1
d1189 1
d1195 1
d1199 2
d1209 39
d1262 1
d1264 4
d1269 1
a1269 2
   if (actx->NewState)
      _ae_update_state( ctx );
d1271 5
d1279 1
a1279 1
         = ADD_POINTERS(at->array->BufferObj->Data, at->array->Ptr)
d1287 1
a1287 1
         = ADD_POINTERS(aa->array->BufferObj->Data, aa->array->Ptr)
d1292 3
d1300 17
a1316 1
   AE_CONTEXT(ctx)->NewState |= new_state;
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@a55 5

   struct gl_buffer_object *vbo[VERT_ATTRIB_MAX];
   GLuint nr_vbos;
   GLboolean mapped_vbos;

d1049 1
a1049 1
   ctx->aelt_context = CALLOC( sizeof(AEcontext) );
a1065 13
static void check_vbo( AEcontext *actx,
		       struct gl_buffer_object *vbo )
{
   if (vbo->Name && !vbo->Pointer) {
      GLuint i;
      for (i = 0; i < actx->nr_vbos; i++)
	 if (actx->vbo[i] == vbo)
	    return;
      assert(actx->nr_vbos < VERT_ATTRIB_MAX);
      actx->vbo[actx->nr_vbos++] = vbo;
   }
}

a1079 2
   actx->nr_vbos = 0;

a1083 1
      check_vbo(actx, aa->array->BufferObj);
a1088 1
      check_vbo(actx, aa->array->BufferObj);
a1093 1
      check_vbo(actx, aa->array->BufferObj);
a1098 1
      check_vbo(actx, aa->array->BufferObj);
a1103 1
      check_vbo(actx, aa->array->BufferObj);
a1108 1
      check_vbo(actx, aa->array->BufferObj);
a1122 1
	 check_vbo(actx, at->array->BufferObj);
d1127 1
a1127 1
   /* generic vertex attribute arrays */   
a1148 1
	 check_vbo(actx, at->array->BufferObj);
a1160 1
      check_vbo(actx, aa->array->BufferObj);
a1165 1
      check_vbo(actx, aa->array->BufferObj);
a1168 2
   check_vbo(actx, ctx->Array.ElementArrayBufferObj);

a1176 39
void _ae_map_vbos( GLcontext *ctx )
{
   AEcontext *actx = AE_CONTEXT(ctx);
   GLuint i;
   
   if (actx->mapped_vbos)
      return;

   if (actx->NewState)
      _ae_update_state(ctx);

   for (i = 0; i < actx->nr_vbos; i++)
      ctx->Driver.MapBuffer(ctx,
			    GL_ARRAY_BUFFER_ARB,
			    GL_DYNAMIC_DRAW_ARB,
			    actx->vbo[i]);

   if (actx->nr_vbos)
      actx->mapped_vbos = GL_TRUE;
}

void _ae_unmap_vbos( GLcontext *ctx )
{
   AEcontext *actx = AE_CONTEXT(ctx);
   GLuint i;

   if (!actx->mapped_vbos)
      return;

   assert (!actx->NewState);

   for (i = 0; i < actx->nr_vbos; i++)
      ctx->Driver.UnmapBuffer(ctx,
			      GL_ARRAY_BUFFER_ARB,
			      actx->vbo[i]);

   actx->mapped_vbos = GL_FALSE;
}

a1190 1
   GLboolean do_map;
d1192 2
a1193 2
   if (actx->NewState) {
      assert(!actx->mapped_vbos);
a1194 3
   }

   do_map = actx->nr_vbos && !actx->mapped_vbos;
a1195 5
   /* 
    */
   if (do_map)
      _ae_map_vbos(ctx);
   
d1199 1
a1199 1
         = ADD_POINTERS(at->array->BufferObj->Pointer, at->array->Ptr)
d1207 1
a1207 1
         = ADD_POINTERS(aa->array->BufferObj->Pointer, aa->array->Ptr)
a1211 3

   if (do_map)
      _ae_unmap_vbos(ctx);
d1217 1
a1217 17
   AEcontext *actx = AE_CONTEXT(ctx);

   
   /* Only interested in this subset of mesa state.  Need to prune
    * this down as both tnl/ and the drivers can raise statechanges
    * for arcane reasons in the middle of seemingly atomic operations
    * like DrawElements, over which we'd like to keep a known set of
    * arrays and vbo's mapped.  
    *
    * Luckily, neither the drivers nor tnl muck with the state that
    * concerns us here:
    */
   new_state &= _NEW_ARRAY | _NEW_PROGRAM;
   if (new_state) {
      assert(!actx->mapped_vbos);
      actx->NewState |= new_state;
   }
@


1.1.1.3
log
@Import Mesa 7.10.3
@
text
@a24 8
/**
 * This file implements the glArrayElement() function.
 * It involves looking at the format/type of all the enabled vertex arrays
 * and emitting a list of pointers to functions which set the per-vertex
 * state for the element/index.
 */


a30 1
#include "bufferobj.h"
d34 2
a35 1
#include "main/dispatch.h"
d73 1
a73 7
#define NUM_TYPES 8


#if FEATURE_arrayelt


static const int ColorFuncs[2][NUM_TYPES] = {
d96 1
a96 1
static const int VertexFuncs[3][NUM_TYPES] = {
d129 1
a129 1
static const int IndexFuncs[NUM_TYPES] = {
d140 1
a140 1
static const int NormalFuncs[NUM_TYPES] = {
d152 2
a153 2
static int SecondaryColorFuncs[NUM_TYPES];
static int FogCoordFuncs[NUM_TYPES];
d162 1
a162 2
static void
VertexAttrib1NbvNV(GLuint index, const GLbyte *v)
d167 1
a167 2
static void
VertexAttrib1bvNV(GLuint index, const GLbyte *v)
d169 1
a169 1
   CALL_VertexAttrib1fNV(GET_DISPATCH(), (index, (GLfloat)v[0]));
d172 1
a172 2
static void
VertexAttrib2NbvNV(GLuint index, const GLbyte *v)
d177 1
a177 2
static void
VertexAttrib2bvNV(GLuint index, const GLbyte *v)
d179 1
a179 1
   CALL_VertexAttrib2fNV(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1]));
d182 1
a182 2
static void
VertexAttrib3NbvNV(GLuint index, const GLbyte *v)
d189 1
a189 2
static void
VertexAttrib3bvNV(GLuint index, const GLbyte *v)
d191 1
a191 1
   CALL_VertexAttrib3fNV(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1], (GLfloat)v[2]));
d194 1
a194 2
static void
VertexAttrib4NbvNV(GLuint index, const GLbyte *v)
d202 1
a202 2
static void
VertexAttrib4bvNV(GLuint index, const GLbyte *v)
d204 1
a204 1
   CALL_VertexAttrib4fNV(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1], (GLfloat)v[2], (GLfloat)v[3]));
d209 1
a209 2
static void
VertexAttrib1NubvNV(GLuint index, const GLubyte *v)
d214 1
a214 2
static void
VertexAttrib1ubvNV(GLuint index, const GLubyte *v)
d216 1
a216 1
   CALL_VertexAttrib1fNV(GET_DISPATCH(), (index, (GLfloat)v[0]));
d219 1
a219 2
static void
VertexAttrib2NubvNV(GLuint index, const GLubyte *v)
d222 1
a222 1
                                          UBYTE_TO_FLOAT(v[1])));
d225 1
a225 2
static void
VertexAttrib2ubvNV(GLuint index, const GLubyte *v)
d227 1
a227 1
   CALL_VertexAttrib2fNV(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1]));
d230 1
a230 2
static void
VertexAttrib3NubvNV(GLuint index, const GLubyte *v)
d236 1
a236 2
static void
VertexAttrib3ubvNV(GLuint index, const GLubyte *v)
d238 1
a238 2
   CALL_VertexAttrib3fNV(GET_DISPATCH(), (index, (GLfloat)v[0],
                                          (GLfloat)v[1], (GLfloat)v[2]));
d241 1
a241 2
static void
VertexAttrib4NubvNV(GLuint index, const GLubyte *v)
d244 3
a246 3
                                          UBYTE_TO_FLOAT(v[1]),
                                          UBYTE_TO_FLOAT(v[2]),
                                          UBYTE_TO_FLOAT(v[3])));
d249 1
a249 2
static void
VertexAttrib4ubvNV(GLuint index, const GLubyte *v)
d251 1
a251 3
   CALL_VertexAttrib4fNV(GET_DISPATCH(), (index, (GLfloat)v[0],
                                          (GLfloat)v[1], (GLfloat)v[2],
                                          (GLfloat)v[3]));
d256 1
a256 2
static void
VertexAttrib1NsvNV(GLuint index, const GLshort *v)
d261 1
a261 2
static void
VertexAttrib1svNV(GLuint index, const GLshort *v)
d263 1
a263 1
   CALL_VertexAttrib1fNV(GET_DISPATCH(), (index, (GLfloat)v[0]));
d266 1
a266 2
static void
VertexAttrib2NsvNV(GLuint index, const GLshort *v)
d269 1
a269 1
                                          SHORT_TO_FLOAT(v[1])));
d272 1
a272 2
static void
VertexAttrib2svNV(GLuint index, const GLshort *v)
d274 1
a274 1
   CALL_VertexAttrib2fNV(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1]));
d277 1
a277 2
static void
VertexAttrib3NsvNV(GLuint index, const GLshort *v)
d284 1
a284 2
static void
VertexAttrib3svNV(GLuint index, const GLshort *v)
d286 1
a286 2
   CALL_VertexAttrib3fNV(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1],
                                          (GLfloat)v[2]));
d289 1
a289 2
static void
VertexAttrib4NsvNV(GLuint index, const GLshort *v)
d297 1
a297 2
static void
VertexAttrib4svNV(GLuint index, const GLshort *v)
d299 1
a299 2
   CALL_VertexAttrib4fNV(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1],
                                          (GLfloat)v[2], (GLfloat)v[3]));
d304 1
a304 2
static void
VertexAttrib1NusvNV(GLuint index, const GLushort *v)
d309 1
a309 2
static void
VertexAttrib1usvNV(GLuint index, const GLushort *v)
d311 1
a311 1
   CALL_VertexAttrib1fNV(GET_DISPATCH(), (index, (GLfloat)v[0]));
d314 1
a314 2
static void
VertexAttrib2NusvNV(GLuint index, const GLushort *v)
d320 1
a320 2
static void
VertexAttrib2usvNV(GLuint index, const GLushort *v)
d322 1
a322 2
   CALL_VertexAttrib2fNV(GET_DISPATCH(), (index, (GLfloat)v[0],
                                          (GLfloat)v[1]));
d325 1
a325 2
static void
VertexAttrib3NusvNV(GLuint index, const GLushort *v)
d332 1
a332 2
static void
VertexAttrib3usvNV(GLuint index, const GLushort *v)
d334 1
a334 2
   CALL_VertexAttrib3fNV(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1],
                                          (GLfloat)v[2]));
d337 1
a337 2
static void
VertexAttrib4NusvNV(GLuint index, const GLushort *v)
d345 1
a345 2
static void
VertexAttrib4usvNV(GLuint index, const GLushort *v)
d347 1
a347 2
   CALL_VertexAttrib4fNV(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1],
                                          (GLfloat)v[2], (GLfloat)v[3]));
d352 1
a352 2
static void
VertexAttrib1NivNV(GLuint index, const GLint *v)
d357 1
a357 2
static void
VertexAttrib1ivNV(GLuint index, const GLint *v)
d359 1
a359 1
   CALL_VertexAttrib1fNV(GET_DISPATCH(), (index, (GLfloat)v[0]));
d362 1
a362 2
static void
VertexAttrib2NivNV(GLuint index, const GLint *v)
d368 1
a368 2
static void
VertexAttrib2ivNV(GLuint index, const GLint *v)
d370 1
a370 1
   CALL_VertexAttrib2fNV(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1]));
d373 1
a373 2
static void
VertexAttrib3NivNV(GLuint index, const GLint *v)
d380 1
a380 2
static void
VertexAttrib3ivNV(GLuint index, const GLint *v)
d382 1
a382 2
   CALL_VertexAttrib3fNV(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1],
                                          (GLfloat)v[2]));
d385 1
a385 2
static void
VertexAttrib4NivNV(GLuint index, const GLint *v)
d388 3
a390 3
                                          INT_TO_FLOAT(v[1]),
                                          INT_TO_FLOAT(v[2]),
                                          INT_TO_FLOAT(v[3])));
d393 1
a393 2
static void
VertexAttrib4ivNV(GLuint index, const GLint *v)
d395 1
a395 2
   CALL_VertexAttrib4fNV(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1],
                                          (GLfloat)v[2], (GLfloat)v[3]));
d400 1
a400 2
static void
VertexAttrib1NuivNV(GLuint index, const GLuint *v)
d405 1
a405 2
static void
VertexAttrib1uivNV(GLuint index, const GLuint *v)
d407 1
a407 1
   CALL_VertexAttrib1fNV(GET_DISPATCH(), (index, (GLfloat)v[0]));
d410 1
a410 2
static void
VertexAttrib2NuivNV(GLuint index, const GLuint *v)
d413 1
a413 1
                                          UINT_TO_FLOAT(v[1])));
d416 1
a416 2
static void
VertexAttrib2uivNV(GLuint index, const GLuint *v)
d418 1
a418 2
   CALL_VertexAttrib2fNV(GET_DISPATCH(), (index, (GLfloat)v[0],
                                          (GLfloat)v[1]));
d421 1
a421 2
static void
VertexAttrib3NuivNV(GLuint index, const GLuint *v)
d428 1
a428 2
static void
VertexAttrib3uivNV(GLuint index, const GLuint *v)
d430 1
a430 2
   CALL_VertexAttrib3fNV(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1],
                                          (GLfloat)v[2]));
d433 1
a433 2
static void
VertexAttrib4NuivNV(GLuint index, const GLuint *v)
d441 1
a441 2
static void
VertexAttrib4uivNV(GLuint index, const GLuint *v)
d443 1
a443 2
   CALL_VertexAttrib4fNV(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1],
                                          (GLfloat)v[2], (GLfloat)v[3]));
d448 1
a448 2
static void
VertexAttrib1fvNV(GLuint index, const GLfloat *v)
d453 1
a453 2
static void
VertexAttrib2fvNV(GLuint index, const GLfloat *v)
d458 1
a458 2
static void
VertexAttrib3fvNV(GLuint index, const GLfloat *v)
d463 1
a463 2
static void
VertexAttrib4fvNV(GLuint index, const GLfloat *v)
d470 1
a470 2
static void
VertexAttrib1dvNV(GLuint index, const GLdouble *v)
d475 1
a475 2
static void
VertexAttrib2dvNV(GLuint index, const GLdouble *v)
d480 1
a480 2
static void
VertexAttrib3dvNV(GLuint index, const GLdouble *v)
d485 1
a485 2
static void
VertexAttrib4dvNV(GLuint index, const GLdouble *v)
d494 1
a494 1
static attrib_func AttribFuncsNV[2][4][NUM_TYPES] = {
d598 1
a598 2
static void
VertexAttrib1NbvARB(GLuint index, const GLbyte *v)
d603 1
a603 2
static void
VertexAttrib1bvARB(GLuint index, const GLbyte *v)
d605 1
a605 1
   CALL_VertexAttrib1fARB(GET_DISPATCH(), (index, (GLfloat)v[0]));
d608 1
a608 2
static void
VertexAttrib2NbvARB(GLuint index, const GLbyte *v)
d613 1
a613 2
static void
VertexAttrib2bvARB(GLuint index, const GLbyte *v)
d615 1
a615 1
   CALL_VertexAttrib2fARB(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1]));
d618 1
a618 2
static void
VertexAttrib3NbvARB(GLuint index, const GLbyte *v)
d625 1
a625 2
static void
VertexAttrib3bvARB(GLuint index, const GLbyte *v)
d627 1
a627 1
   CALL_VertexAttrib3fARB(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1], (GLfloat)v[2]));
d630 1
a630 2
static void
VertexAttrib4NbvARB(GLuint index, const GLbyte *v)
d638 1
a638 2
static void
VertexAttrib4bvARB(GLuint index, const GLbyte *v)
d640 1
a640 1
   CALL_VertexAttrib4fARB(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1], (GLfloat)v[2], (GLfloat)v[3]));
d645 1
a645 2
static void
VertexAttrib1NubvARB(GLuint index, const GLubyte *v)
d650 1
a650 2
static void
VertexAttrib1ubvARB(GLuint index, const GLubyte *v)
d652 1
a652 1
   CALL_VertexAttrib1fARB(GET_DISPATCH(), (index, (GLfloat)v[0]));
d655 1
a655 2
static void
VertexAttrib2NubvARB(GLuint index, const GLubyte *v)
d657 2
a658 3
   CALL_VertexAttrib2fARB(GET_DISPATCH(), (index,
                                           UBYTE_TO_FLOAT(v[0]),
                                           UBYTE_TO_FLOAT(v[1])));
d661 1
a661 2
static void
VertexAttrib2ubvARB(GLuint index, const GLubyte *v)
d663 1
a663 2
   CALL_VertexAttrib2fARB(GET_DISPATCH(), (index,
                                           (GLfloat)v[0], (GLfloat)v[1]));
d666 1
a666 2
static void
VertexAttrib3NubvARB(GLuint index, const GLubyte *v)
d668 3
a670 4
   CALL_VertexAttrib3fARB(GET_DISPATCH(), (index,
                                           UBYTE_TO_FLOAT(v[0]),
                                           UBYTE_TO_FLOAT(v[1]),
                                           UBYTE_TO_FLOAT(v[2])));
d672 1
a672 2
static void
VertexAttrib3ubvARB(GLuint index, const GLubyte *v)
d674 1
a674 4
   CALL_VertexAttrib3fARB(GET_DISPATCH(), (index,
                                           (GLfloat)v[0],
                                           (GLfloat)v[1],
                                           (GLfloat)v[2]));
d677 1
a677 2
static void
VertexAttrib4NubvARB(GLuint index, const GLubyte *v)
d679 4
a682 6
   CALL_VertexAttrib4fARB(GET_DISPATCH(),
                          (index,
                           UBYTE_TO_FLOAT(v[0]),
                           UBYTE_TO_FLOAT(v[1]),
                           UBYTE_TO_FLOAT(v[2]),
                           UBYTE_TO_FLOAT(v[3])));
d685 1
a685 2
static void
VertexAttrib4ubvARB(GLuint index, const GLubyte *v)
d687 1
a687 4
   CALL_VertexAttrib4fARB(GET_DISPATCH(),
                          (index,
                           (GLfloat)v[0], (GLfloat)v[1],
                           (GLfloat)v[2], (GLfloat)v[3]));
d692 1
a692 2
static void
VertexAttrib1NsvARB(GLuint index, const GLshort *v)
d697 1
a697 2
static void
VertexAttrib1svARB(GLuint index, const GLshort *v)
d699 1
a699 1
   CALL_VertexAttrib1fARB(GET_DISPATCH(), (index, (GLfloat)v[0]));
d702 1
a702 2
static void
VertexAttrib2NsvARB(GLuint index, const GLshort *v)
d704 2
a705 3
   CALL_VertexAttrib2fARB(GET_DISPATCH(),
                          (index, SHORT_TO_FLOAT(v[0]),
                           SHORT_TO_FLOAT(v[1])));
d708 1
a708 2
static void
VertexAttrib2svARB(GLuint index, const GLshort *v)
d710 1
a710 2
   CALL_VertexAttrib2fARB(GET_DISPATCH(),
                          (index, (GLfloat)v[0], (GLfloat)v[1]));
d713 1
a713 2
static void
VertexAttrib3NsvARB(GLuint index, const GLshort *v)
d715 3
a717 5
   CALL_VertexAttrib3fARB(GET_DISPATCH(),
                          (index,
                           SHORT_TO_FLOAT(v[0]),
                           SHORT_TO_FLOAT(v[1]),
                           SHORT_TO_FLOAT(v[2])));
d720 1
a720 2
static void
VertexAttrib3svARB(GLuint index, const GLshort *v)
d722 1
a722 3
   CALL_VertexAttrib3fARB(GET_DISPATCH(),
                          (index,
                           (GLfloat)v[0], (GLfloat)v[1], (GLfloat)v[2]));
d725 1
a725 2
static void
VertexAttrib4NsvARB(GLuint index, const GLshort *v)
d727 4
a730 6
   CALL_VertexAttrib4fARB(GET_DISPATCH(),
                          (index,
                           SHORT_TO_FLOAT(v[0]),
                           SHORT_TO_FLOAT(v[1]),
                           SHORT_TO_FLOAT(v[2]),
                           SHORT_TO_FLOAT(v[3])));
d733 1
a733 2
static void
VertexAttrib4svARB(GLuint index, const GLshort *v)
d735 1
a735 2
   CALL_VertexAttrib4fARB(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1],
                                           (GLfloat)v[2], (GLfloat)v[3]));
d740 1
a740 2
static void
VertexAttrib1NusvARB(GLuint index, const GLushort *v)
d745 1
a745 2
static void
VertexAttrib1usvARB(GLuint index, const GLushort *v)
d747 1
a747 1
   CALL_VertexAttrib1fARB(GET_DISPATCH(), (index, (GLfloat)v[0]));
d750 1
a750 2
static void
VertexAttrib2NusvARB(GLuint index, const GLushort *v)
d756 1
a756 2
static void
VertexAttrib2usvARB(GLuint index, const GLushort *v)
d758 1
a758 2
   CALL_VertexAttrib2fARB(GET_DISPATCH(), (index, (GLfloat)v[0],
                                           (GLfloat)v[1]));
d761 1
a761 2
static void
VertexAttrib3NusvARB(GLuint index, const GLushort *v)
d768 1
a768 2
static void
VertexAttrib3usvARB(GLuint index, const GLushort *v)
d770 1
a770 2
   CALL_VertexAttrib3fARB(GET_DISPATCH(), (index, (GLfloat)v[0],
                                           (GLfloat)v[1], (GLfloat)v[2]));
d773 1
a773 2
static void
VertexAttrib4NusvARB(GLuint index, const GLushort *v)
d781 1
a781 2
static void
VertexAttrib4usvARB(GLuint index, const GLushort *v)
d783 1
a783 1
   CALL_VertexAttrib4fARB(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1], (GLfloat)v[2], (GLfloat)v[3]));
d788 1
a788 2
static void
VertexAttrib1NivARB(GLuint index, const GLint *v)
d793 1
a793 2
static void
VertexAttrib1ivARB(GLuint index, const GLint *v)
d795 1
a795 1
   CALL_VertexAttrib1fARB(GET_DISPATCH(), (index, (GLfloat)v[0]));
d798 1
a798 2
static void
VertexAttrib2NivARB(GLuint index, const GLint *v)
d804 1
a804 2
static void
VertexAttrib2ivARB(GLuint index, const GLint *v)
d806 1
a806 2
   CALL_VertexAttrib2fARB(GET_DISPATCH(), (index, (GLfloat)v[0],
                                           (GLfloat)v[1]));
d809 1
a809 2
static void
VertexAttrib3NivARB(GLuint index, const GLint *v)
d816 1
a816 2
static void
VertexAttrib3ivARB(GLuint index, const GLint *v)
d818 1
a818 2
   CALL_VertexAttrib3fARB(GET_DISPATCH(), (index, (GLfloat)v[0],
                                           (GLfloat)v[1], (GLfloat)v[2]));
d821 1
a821 2
static void
VertexAttrib4NivARB(GLuint index, const GLint *v)
d829 1
a829 2
static void
VertexAttrib4ivARB(GLuint index, const GLint *v)
d831 1
a831 2
   CALL_VertexAttrib4fARB(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1],
                                           (GLfloat)v[2], (GLfloat)v[3]));
d836 1
a836 2
static void
VertexAttrib1NuivARB(GLuint index, const GLuint *v)
d841 1
a841 2
static void
VertexAttrib1uivARB(GLuint index, const GLuint *v)
d843 1
a843 1
   CALL_VertexAttrib1fARB(GET_DISPATCH(), (index, (GLfloat)v[0]));
d846 1
a846 2
static void
VertexAttrib2NuivARB(GLuint index, const GLuint *v)
d849 1
a849 1
                                           UINT_TO_FLOAT(v[1])));
d852 1
a852 2
static void
VertexAttrib2uivARB(GLuint index, const GLuint *v)
d854 1
a854 2
   CALL_VertexAttrib2fARB(GET_DISPATCH(), (index, (GLfloat)v[0],
                                           (GLfloat)v[1]));
d857 1
a857 2
static void
VertexAttrib3NuivARB(GLuint index, const GLuint *v)
d860 2
a861 2
                                           UINT_TO_FLOAT(v[1]),
                                           UINT_TO_FLOAT(v[2])));
d864 1
a864 2
static void
VertexAttrib3uivARB(GLuint index, const GLuint *v)
d866 1
a866 2
   CALL_VertexAttrib3fARB(GET_DISPATCH(), (index, (GLfloat)v[0],
                                           (GLfloat)v[1], (GLfloat)v[2]));
d869 1
a869 2
static void
VertexAttrib4NuivARB(GLuint index, const GLuint *v)
d872 3
a874 3
                                           UINT_TO_FLOAT(v[1]),
                                           UINT_TO_FLOAT(v[2]),
                                           UINT_TO_FLOAT(v[3])));
d877 1
a877 2
static void
VertexAttrib4uivARB(GLuint index, const GLuint *v)
d879 1
a879 2
   CALL_VertexAttrib4fARB(GET_DISPATCH(), (index, (GLfloat)v[0], (GLfloat)v[1],
                                           (GLfloat)v[2], (GLfloat)v[3]));
d884 1
a884 2
static void
VertexAttrib1fvARB(GLuint index, const GLfloat *v)
d889 1
a889 2
static void
VertexAttrib2fvARB(GLuint index, const GLfloat *v)
d894 1
a894 2
static void
VertexAttrib3fvARB(GLuint index, const GLfloat *v)
d899 1
a899 2
static void
VertexAttrib4fvARB(GLuint index, const GLfloat *v)
d906 1
a906 2
static void
VertexAttrib1dvARB(GLuint index, const GLdouble *v)
d911 1
a911 2
static void
VertexAttrib2dvARB(GLuint index, const GLdouble *v)
d916 1
a916 2
static void
VertexAttrib3dvARB(GLuint index, const GLdouble *v)
d921 1
a921 2
static void
VertexAttrib4dvARB(GLuint index, const GLdouble *v)
a926 157
/**
 * Integer-valued attributes
 */
static void
VertexAttribI1bv(GLuint index, const GLbyte *v)
{
   CALL_VertexAttribI1iEXT(GET_DISPATCH(), (index, v[0]));
}

static void
VertexAttribI2bv(GLuint index, const GLbyte *v)
{
   CALL_VertexAttribI2iEXT(GET_DISPATCH(), (index, v[0], v[1]));
}

static void
VertexAttribI3bv(GLuint index, const GLbyte *v)
{
   CALL_VertexAttribI3iEXT(GET_DISPATCH(), (index, v[0], v[1], v[2]));
}

static void
VertexAttribI4bv(GLuint index, const GLbyte *v)
{
   CALL_VertexAttribI4bvEXT(GET_DISPATCH(), (index, v));
}


static void
VertexAttribI1ubv(GLuint index, const GLubyte *v)
{
   CALL_VertexAttribI1uiEXT(GET_DISPATCH(), (index, v[0]));
}

static void
VertexAttribI2ubv(GLuint index, const GLubyte *v)
{
   CALL_VertexAttribI2uiEXT(GET_DISPATCH(), (index, v[0], v[1]));
}

static void
VertexAttribI3ubv(GLuint index, const GLubyte *v)
{
   CALL_VertexAttribI3uiEXT(GET_DISPATCH(), (index, v[0], v[1], v[2]));
}

static void
VertexAttribI4ubv(GLuint index, const GLubyte *v)
{
   CALL_VertexAttribI4ubvEXT(GET_DISPATCH(), (index, v));
}



static void
VertexAttribI1sv(GLuint index, const GLshort *v)
{
   CALL_VertexAttribI1iEXT(GET_DISPATCH(), (index, v[0]));
}

static void
VertexAttribI2sv(GLuint index, const GLshort *v)
{
   CALL_VertexAttribI2iEXT(GET_DISPATCH(), (index, v[0], v[1]));
}

static void
VertexAttribI3sv(GLuint index, const GLshort *v)
{
   CALL_VertexAttribI3iEXT(GET_DISPATCH(), (index, v[0], v[1], v[2]));
}

static void
VertexAttribI4sv(GLuint index, const GLshort *v)
{
   CALL_VertexAttribI4svEXT(GET_DISPATCH(), (index, v));
}


static void
VertexAttribI1usv(GLuint index, const GLushort *v)
{
   CALL_VertexAttribI1uiEXT(GET_DISPATCH(), (index, v[0]));
}

static void
VertexAttribI2usv(GLuint index, const GLushort *v)
{
   CALL_VertexAttribI2uiEXT(GET_DISPATCH(), (index, v[0], v[1]));
}

static void
VertexAttribI3usv(GLuint index, const GLushort *v)
{
   CALL_VertexAttribI3uiEXT(GET_DISPATCH(), (index, v[0], v[1], v[2]));
}

static void
VertexAttribI4usv(GLuint index, const GLushort *v)
{
   CALL_VertexAttribI4usvEXT(GET_DISPATCH(), (index, v));
}



static void
VertexAttribI1iv(GLuint index, const GLint *v)
{
   CALL_VertexAttribI1iEXT(GET_DISPATCH(), (index, v[0]));
}

static void
VertexAttribI2iv(GLuint index, const GLint *v)
{
   CALL_VertexAttribI2iEXT(GET_DISPATCH(), (index, v[0], v[1]));
}

static void
VertexAttribI3iv(GLuint index, const GLint *v)
{
   CALL_VertexAttribI3iEXT(GET_DISPATCH(), (index, v[0], v[1], v[2]));
}

static void
VertexAttribI4iv(GLuint index, const GLint *v)
{
   CALL_VertexAttribI4ivEXT(GET_DISPATCH(), (index, v));
}


static void
VertexAttribI1uiv(GLuint index, const GLuint *v)
{
   CALL_VertexAttribI1uiEXT(GET_DISPATCH(), (index, v[0]));
}

static void
VertexAttribI2uiv(GLuint index, const GLuint *v)
{
   CALL_VertexAttribI2uiEXT(GET_DISPATCH(), (index, v[0], v[1]));
}

static void
VertexAttribI3uiv(GLuint index, const GLuint *v)
{
   CALL_VertexAttribI3uiEXT(GET_DISPATCH(), (index, v[0], v[1], v[2]));
}

static void
VertexAttribI4uiv(GLuint index, const GLuint *v)
{
   CALL_VertexAttribI4uivEXT(GET_DISPATCH(), (index, v));
}




d928 1
a928 2
 * Array [unnormalized/normalized/integer][size][type] of VertexAttrib
 * functions
d930 1
a930 1
static attrib_func AttribFuncsARB[3][4][NUM_TYPES] = {
a1023 48
   },

   {
      /* integer-valued */
      {
         /* size 1 */
         (attrib_func) VertexAttribI1bv,
         (attrib_func) VertexAttribI1ubv,
         (attrib_func) VertexAttribI1sv,
         (attrib_func) VertexAttribI1usv,
         (attrib_func) VertexAttribI1iv,
         (attrib_func) VertexAttribI1uiv,
         NULL, /* GL_FLOAT */
         NULL  /* GL_DOUBLE */
      },
      {
         /* size 2 */
         (attrib_func) VertexAttribI2bv,
         (attrib_func) VertexAttribI2ubv,
         (attrib_func) VertexAttribI2sv,
         (attrib_func) VertexAttribI2usv,
         (attrib_func) VertexAttribI2iv,
         (attrib_func) VertexAttribI2uiv,
         NULL, /* GL_FLOAT */
         NULL  /* GL_DOUBLE */
      },
      {
         /* size 3 */
         (attrib_func) VertexAttribI3bv,
         (attrib_func) VertexAttribI3ubv,
         (attrib_func) VertexAttribI3sv,
         (attrib_func) VertexAttribI3usv,
         (attrib_func) VertexAttribI3iv,
         (attrib_func) VertexAttribI3uiv,
         NULL, /* GL_FLOAT */
         NULL  /* GL_DOUBLE */
      },
      {
         /* size 4 */
         (attrib_func) VertexAttribI4bv,
         (attrib_func) VertexAttribI4ubv,
         (attrib_func) VertexAttribI4sv,
         (attrib_func) VertexAttribI4usv,
         (attrib_func) VertexAttribI4iv,
         (attrib_func) VertexAttribI4uiv,
         NULL, /* GL_FLOAT */
         NULL  /* GL_DOUBLE */
      }
d1030 1
a1030 1
GLboolean _ae_create_context( struct gl_context *ctx )
d1063 1
a1063 1
void _ae_destroy_context( struct gl_context *ctx )
d1074 1
a1074 1
   if (_mesa_is_bufferobj(vbo) && !_mesa_bufferobj_mapped(vbo)) {
d1091 1
a1091 1
static void _ae_update_state( struct gl_context *ctx )
a1096 1
   struct gl_array_object *arrayObj = ctx->Array.ArrayObj;
d1101 2
a1102 2
   if (arrayObj->Index.Enabled) {
      aa->array = &arrayObj->Index;
d1107 2
a1108 2
   if (arrayObj->EdgeFlag.Enabled) {
      aa->array = &arrayObj->EdgeFlag;
d1113 2
a1114 2
   if (arrayObj->Normal.Enabled) {
      aa->array = &arrayObj->Normal;
d1119 2
a1120 2
   if (arrayObj->Color.Enabled) {
      aa->array = &arrayObj->Color;
d1125 2
a1126 2
   if (arrayObj->SecondaryColor.Enabled) {
      aa->array = &arrayObj->SecondaryColor;
d1131 2
a1132 2
   if (arrayObj->FogCoord.Enabled) {
      aa->array = &arrayObj->FogCoord;
d1138 1
a1138 1
      struct gl_client_array *attribArray = &arrayObj->TexCoord[i];
d1155 2
a1156 2
   for (i = 1; i < Elements(arrayObj->VertexAttrib); i++) {  /* skip zero! */
      struct gl_client_array *attribArray = &arrayObj->VertexAttrib[i];
d1161 1
a1161 1
          * change from one execution of _ae_ArrayElement() to
d1171 1
a1171 9
            GLint intOrNorm;
            if (at->array->Integer)
               intOrNorm = 2;
            else if (at->array->Normalized)
               intOrNorm = 1;
            else
               intOrNorm = 0;

            at->func = AttribFuncsARB[intOrNorm]
d1182 1
a1182 1
   if (arrayObj->VertexAttrib[0].Enabled) {
d1186 1
a1186 1
      aa->array = &arrayObj->VertexAttrib[0];
d1192 2
a1193 2
   else if (arrayObj->Vertex.Enabled) {
      aa->array = &arrayObj->Vertex;
d1209 1
a1209 1
void _ae_map_vbos( struct gl_context *ctx )
d1230 1
a1230 1
void _ae_unmap_vbos( struct gl_context *ctx )
d1255 1
a1255 1
void GLAPIENTRY _ae_ArrayElement( GLint elt )
a1268 1
   /* Determine if w need to map/unmap VBOs */
d1271 2
d1276 1
a1276 1
   /* emit generic attribute elements */
d1284 1
a1284 1
   /* emit conventional arrays elements */
d1298 1
a1298 1
void _ae_invalidate_state( struct gl_context *ctx, GLuint new_state )
a1317 10


void _mesa_install_arrayelt_vtxfmt(struct _glapi_table *disp,
                                   const GLvertexformat *vfmt)
{
   SET_ArrayElement(disp, vfmt->ArrayElement);
}


#endif /* FEATURE_arrayelt */
@


1.1.1.4
log
@Import Mesa 9.2.0
@
text
@d3 1
d20 3
a22 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
a42 1
#include "mtypes.h"
a64 1
   /* List of VBOs we need to map before executing ArrayElements */
d67 2
a68 1
   GLboolean mapped_vbos;  /**< Any currently mapped VBOs? */
d71 1
a71 7

/** Cast wrapper */
static INLINE AEcontext *
AE_CONTEXT(struct gl_context *ctx)
{
   return (AEcontext *) ctx->aelt_context;
}
d79 3
a81 5
static INLINE int
TYPE_IDX(GLenum t)
{
   return t == GL_DOUBLE ? 7 : t & 7;
}
d84 1
a84 1
#define NUM_TYPES 8
d176 1
a176 1
static void GLAPIENTRY
d182 1
a182 1
static void GLAPIENTRY
d188 1
a188 1
static void GLAPIENTRY
d194 1
a194 1
static void GLAPIENTRY
d200 1
a200 1
static void GLAPIENTRY
d208 1
a208 1
static void GLAPIENTRY
d214 1
a214 1
static void GLAPIENTRY
d223 1
a223 1
static void GLAPIENTRY
d231 1
a231 1
static void GLAPIENTRY
d237 1
a237 1
static void GLAPIENTRY
d243 1
a243 1
static void GLAPIENTRY
d250 1
a250 1
static void GLAPIENTRY
d256 1
a256 1
static void GLAPIENTRY
d263 1
a263 1
static void GLAPIENTRY
d270 1
a270 1
static void GLAPIENTRY
d279 1
a279 1
static void GLAPIENTRY
d289 1
a289 1
static void GLAPIENTRY
d295 1
a295 1
static void GLAPIENTRY
d301 1
a301 1
static void GLAPIENTRY
d308 1
a308 1
static void GLAPIENTRY
d314 1
a314 1
static void GLAPIENTRY
d322 1
a322 1
static void GLAPIENTRY
d329 1
a329 1
static void GLAPIENTRY
d338 1
a338 1
static void GLAPIENTRY
d347 1
a347 1
static void GLAPIENTRY
d353 1
a353 1
static void GLAPIENTRY
d359 1
a359 1
static void GLAPIENTRY
d366 1
a366 1
static void GLAPIENTRY
d373 1
a373 1
static void GLAPIENTRY
d381 1
a381 1
static void GLAPIENTRY
d388 1
a388 1
static void GLAPIENTRY
d397 1
a397 1
static void GLAPIENTRY
d406 1
a406 1
static void GLAPIENTRY
d412 1
a412 1
static void GLAPIENTRY
d418 1
a418 1
static void GLAPIENTRY
d425 1
a425 1
static void GLAPIENTRY
d431 1
a431 1
static void GLAPIENTRY
d439 1
a439 1
static void GLAPIENTRY
d446 1
a446 1
static void GLAPIENTRY
d455 1
a455 1
static void GLAPIENTRY
d464 1
a464 1
static void GLAPIENTRY
d470 1
a470 1
static void GLAPIENTRY
d476 1
a476 1
static void GLAPIENTRY
d483 1
a483 1
static void GLAPIENTRY
d490 1
a490 1
static void GLAPIENTRY
d498 1
a498 1
static void GLAPIENTRY
d505 1
a505 1
static void GLAPIENTRY
d514 1
a514 1
static void GLAPIENTRY
d523 1
a523 1
static void GLAPIENTRY
d529 1
a529 1
static void GLAPIENTRY
d535 1
a535 1
static void GLAPIENTRY
d541 1
a541 1
static void GLAPIENTRY
d549 1
a549 1
static void GLAPIENTRY
d555 1
a555 1
static void GLAPIENTRY
d561 1
a561 1
static void GLAPIENTRY
d567 1
a567 1
static void GLAPIENTRY
d681 1
a681 1
static void GLAPIENTRY
d687 1
a687 1
static void GLAPIENTRY
d693 1
a693 1
static void GLAPIENTRY
d699 1
a699 1
static void GLAPIENTRY
d705 1
a705 1
static void GLAPIENTRY
d713 1
a713 1
static void GLAPIENTRY
d719 1
a719 1
static void GLAPIENTRY
d728 1
a728 1
static void GLAPIENTRY
d736 1
a736 1
static void GLAPIENTRY
d742 1
a742 1
static void GLAPIENTRY
d748 1
a748 1
static void GLAPIENTRY
d756 1
a756 1
static void GLAPIENTRY
d763 1
a763 1
static void GLAPIENTRY
d771 1
a771 1
static void GLAPIENTRY
d780 1
a780 1
static void GLAPIENTRY
d791 1
a791 1
static void GLAPIENTRY
d802 1
a802 1
static void GLAPIENTRY
d808 1
a808 1
static void GLAPIENTRY
d814 1
a814 1
static void GLAPIENTRY
d822 1
a822 1
static void GLAPIENTRY
d829 1
a829 1
static void GLAPIENTRY
d839 1
a839 1
static void GLAPIENTRY
d847 1
a847 1
static void GLAPIENTRY
d858 1
a858 1
static void GLAPIENTRY
d867 1
a867 1
static void GLAPIENTRY
d873 1
a873 1
static void GLAPIENTRY
d879 1
a879 1
static void GLAPIENTRY
d886 1
a886 1
static void GLAPIENTRY
d893 1
a893 1
static void GLAPIENTRY
d901 1
a901 1
static void GLAPIENTRY
d908 1
a908 1
static void GLAPIENTRY
d917 1
a917 1
static void GLAPIENTRY
d925 1
a925 1
static void GLAPIENTRY
d931 1
a931 1
static void GLAPIENTRY
d937 1
a937 1
static void GLAPIENTRY
d944 1
a944 1
static void GLAPIENTRY
d951 1
a951 1
static void GLAPIENTRY
d959 1
a959 1
static void GLAPIENTRY
d966 1
a966 1
static void GLAPIENTRY
d975 1
a975 1
static void GLAPIENTRY
d984 1
a984 1
static void GLAPIENTRY
d990 1
a990 1
static void GLAPIENTRY
d996 1
a996 1
static void GLAPIENTRY
d1003 1
a1003 1
static void GLAPIENTRY
d1010 1
a1010 1
static void GLAPIENTRY
d1018 1
a1018 1
static void GLAPIENTRY
d1025 1
a1025 1
static void GLAPIENTRY
d1034 1
a1034 1
static void GLAPIENTRY
d1043 1
a1043 1
static void GLAPIENTRY
d1049 1
a1049 1
static void GLAPIENTRY
d1055 1
a1055 1
static void GLAPIENTRY
d1061 1
a1061 1
static void GLAPIENTRY
d1069 1
a1069 1
static void GLAPIENTRY
d1072 1
a1072 1
   CALL_VertexAttrib1dv(GET_DISPATCH(), (index, v));
d1075 1
a1075 1
static void GLAPIENTRY
d1078 1
a1078 1
   CALL_VertexAttrib2dv(GET_DISPATCH(), (index, v));
d1081 1
a1081 1
static void GLAPIENTRY
d1084 1
a1084 1
   CALL_VertexAttrib3dv(GET_DISPATCH(), (index, v));
d1087 1
a1087 1
static void GLAPIENTRY
d1090 1
a1090 1
   CALL_VertexAttrib4dv(GET_DISPATCH(), (index, v));
d1097 1
a1097 1
static void GLAPIENTRY
d1103 1
a1103 1
static void GLAPIENTRY
d1109 1
a1109 1
static void GLAPIENTRY
d1115 1
a1115 1
static void GLAPIENTRY
d1118 1
a1118 1
   CALL_VertexAttribI4bv(GET_DISPATCH(), (index, v));
d1122 1
a1122 1
static void GLAPIENTRY
d1128 1
a1128 1
static void GLAPIENTRY
d1134 1
a1134 1
static void GLAPIENTRY
d1140 1
a1140 1
static void GLAPIENTRY
d1143 1
a1143 1
   CALL_VertexAttribI4ubv(GET_DISPATCH(), (index, v));
d1148 1
a1148 1
static void GLAPIENTRY
d1154 1
a1154 1
static void GLAPIENTRY
d1160 1
a1160 1
static void GLAPIENTRY
d1166 1
a1166 1
static void GLAPIENTRY
d1169 1
a1169 1
   CALL_VertexAttribI4sv(GET_DISPATCH(), (index, v));
d1173 1
a1173 1
static void GLAPIENTRY
d1179 1
a1179 1
static void GLAPIENTRY
d1185 1
a1185 1
static void GLAPIENTRY
d1191 1
a1191 1
static void GLAPIENTRY
d1194 1
a1194 1
   CALL_VertexAttribI4usv(GET_DISPATCH(), (index, v));
d1199 1
a1199 1
static void GLAPIENTRY
d1205 1
a1205 1
static void GLAPIENTRY
d1211 1
a1211 1
static void GLAPIENTRY
d1217 1
a1217 1
static void GLAPIENTRY
d1224 1
a1224 1
static void GLAPIENTRY
d1230 1
a1230 1
static void GLAPIENTRY
d1236 1
a1236 1
static void GLAPIENTRY
d1242 1
a1242 1
static void GLAPIENTRY
d1249 2
d1400 2
d1403 1
a1403 2
GLboolean
_ae_create_context(struct gl_context *ctx)
d1409 6
a1414 6
   SecondaryColorFuncs[0] = _gloffset_SecondaryColor3bv;
   SecondaryColorFuncs[1] = _gloffset_SecondaryColor3ubv;
   SecondaryColorFuncs[2] = _gloffset_SecondaryColor3sv;
   SecondaryColorFuncs[3] = _gloffset_SecondaryColor3usv;
   SecondaryColorFuncs[4] = _gloffset_SecondaryColor3iv;
   SecondaryColorFuncs[5] = _gloffset_SecondaryColor3uiv;
d1416 1
a1416 1
   SecondaryColorFuncs[7] = _gloffset_SecondaryColor3dv;
d1425 1
a1425 1
   FogCoordFuncs[7] = _gloffset_FogCoorddv;
d1427 1
a1427 1
   ctx->aelt_context = calloc(1, sizeof(AEcontext));
d1436 1
a1436 2
void
_ae_destroy_context(struct gl_context *ctx)
d1438 2
a1439 2
   if (AE_CONTEXT(ctx)) {
      free(ctx->aelt_context);
d1444 2
a1445 8

/**
 * Check if the given vertex buffer object exists and is not mapped.
 * If so, add it to the list of buffers we must map before executing
 * an glArrayElement call.
 */
static void
check_vbo(AEcontext *actx, struct gl_buffer_object *vbo)
d1450 2
a1451 2
         if (actx->vbo[i] == vbo)
            return;  /* already in the list, we're done */
d1464 1
a1464 2
static void
_ae_update_state(struct gl_context *ctx)
d1467 2
a1468 2
   AEarray *aa = actx->arrays;  /* non-indexed arrays (ex: glNormal) */
   AEattrib *at = actx->attribs;  /* indexed arrays (ex: glMultiTexCoord) */
d1475 2
a1476 2
   if (arrayObj->VertexAttrib[VERT_ATTRIB_COLOR_INDEX].Enabled) {
      aa->array = &arrayObj->VertexAttrib[VERT_ATTRIB_COLOR_INDEX];
d1481 2
a1482 2
   if (arrayObj->VertexAttrib[VERT_ATTRIB_EDGEFLAG].Enabled) {
      aa->array = &arrayObj->VertexAttrib[VERT_ATTRIB_EDGEFLAG];
d1487 2
a1488 2
   if (arrayObj->VertexAttrib[VERT_ATTRIB_NORMAL].Enabled) {
      aa->array = &arrayObj->VertexAttrib[VERT_ATTRIB_NORMAL];
d1493 2
a1494 2
   if (arrayObj->VertexAttrib[VERT_ATTRIB_COLOR0].Enabled) {
      aa->array = &arrayObj->VertexAttrib[VERT_ATTRIB_COLOR0];
d1499 2
a1500 2
   if (arrayObj->VertexAttrib[VERT_ATTRIB_COLOR1].Enabled) {
      aa->array = &arrayObj->VertexAttrib[VERT_ATTRIB_COLOR1];
d1505 2
a1506 2
   if (arrayObj->VertexAttrib[VERT_ATTRIB_FOG].Enabled) {
      aa->array = &arrayObj->VertexAttrib[VERT_ATTRIB_FOG];
d1512 1
a1512 2
      struct gl_client_array *attribArray =
         &arrayObj->VertexAttrib[VERT_ATTRIB_TEX(i)];
d1528 3
a1530 4
   /* generic vertex attribute arrays */
   for (i = 1; i < VERT_ATTRIB_GENERIC_MAX; i++) {  /* skip zero! */
      struct gl_client_array *attribArray =
         &arrayObj->VertexAttrib[VERT_ATTRIB_GENERIC(i)];
a1531 1
         GLint intOrNorm;
d1538 19
a1556 11
         if (at->array->Integer)
            intOrNorm = 2;
         else if (at->array->Normalized)
            intOrNorm = 1;
         else
            intOrNorm = 0;

         at->func = AttribFuncsARB[intOrNorm]
            [at->array->Size-1]
            [TYPE_IDX(at->array->Type)];

d1564 1
a1564 1
   if (arrayObj->VertexAttrib[VERT_ATTRIB_GENERIC0].Enabled) {
d1568 1
a1568 1
      aa->array = &arrayObj->VertexAttrib[VERT_ATTRIB_GENERIC0];
d1574 2
a1575 2
   else if (arrayObj->VertexAttrib[VERT_ATTRIB_POS].Enabled) {
      aa->array = &arrayObj->VertexAttrib[VERT_ATTRIB_POS];
d1581 1
a1581 1
   check_vbo(actx, arrayObj->ElementArrayBufferObj);
d1591 1
a1591 7

/**
 * Before replaying glArrayElements calls we need to map (for reading) any
 * VBOs referenced by the enabled vertex arrays.
 */
void
_ae_map_vbos(struct gl_context *ctx)
d1595 1
a1595 1

d1603 4
a1606 4
      ctx->Driver.MapBufferRange(ctx, 0,
				 actx->vbo[i]->Size,
				 GL_MAP_READ_BIT,
				 actx->vbo[i]);
d1612 1
a1612 6

/**
 * Unmap VBOs
 */
void
_ae_unmap_vbos(struct gl_context *ctx)
d1623 3
a1625 1
      ctx->Driver.UnmapBuffer(ctx, actx->vbo[i]);
d1637 1
a1637 2
void GLAPIENTRY
_ae_ArrayElement(GLint elt)
a1645 8
   /* If PrimitiveRestart is enabled and the index is the RestartIndex
    * then we call PrimitiveRestartNV and return.
    */
   if (ctx->Array.PrimitiveRestart && (elt == ctx->Array.RestartIndex)) {
      CALL_PrimitiveRestartNV((struct _glapi_table *)disp, ());
      return;
   }

d1648 1
a1648 1
      _ae_update_state(ctx);
d1651 1
a1651 1
   /* Determine if we need to map/unmap VBOs */
d1656 1
a1656 1

d1662 1
a1662 1
      at->func(at->index, src);
d1670 2
a1671 1
      CALL_by_offset(disp, (array_func), aa->offset, ((const void *) src));
d1679 1
a1679 2
void
_ae_invalidate_state(struct gl_context *ctx, GLuint new_state)
d1683 1
d1688 1
a1688 1
    * arrays and vbo's mapped.
d1701 2
a1702 3
void
_mesa_install_arrayelt_vtxfmt(struct _glapi_table *disp,
                              const GLvertexformat *vfmt)
d1706 3
@


1.1.1.5
log
@Import Mesa 10.2.3
@
text
@d34 1
a34 1
 *    Keith Whitwell <keithw@@vmware.com>
a37 1
#include "arrayobj.h"
d1460 1
a1460 2
   if (_mesa_is_bufferobj(vbo) &&
       !_mesa_bufferobj_mapped(vbo, MAP_INTERNAL)) {
a1470 12
static inline void
update_derived_client_arrays(struct gl_context *ctx)
{
   struct gl_vertex_array_object *vao = ctx->Array.VAO;

   if (vao->NewArrays) {
      _mesa_update_vao_client_arrays(ctx, vao);
      vao->NewArrays = 0;
   }
}


d1484 1
a1484 1
   struct gl_vertex_array_object *vao = ctx->Array.VAO;
d1489 2
a1490 2
   if (vao->_VertexAttrib[VERT_ATTRIB_COLOR_INDEX].Enabled) {
      aa->array = &vao->_VertexAttrib[VERT_ATTRIB_COLOR_INDEX];
d1495 2
a1496 2
   if (vao->_VertexAttrib[VERT_ATTRIB_EDGEFLAG].Enabled) {
      aa->array = &vao->_VertexAttrib[VERT_ATTRIB_EDGEFLAG];
d1501 2
a1502 2
   if (vao->_VertexAttrib[VERT_ATTRIB_NORMAL].Enabled) {
      aa->array = &vao->_VertexAttrib[VERT_ATTRIB_NORMAL];
d1507 2
a1508 2
   if (vao->_VertexAttrib[VERT_ATTRIB_COLOR0].Enabled) {
      aa->array = &vao->_VertexAttrib[VERT_ATTRIB_COLOR0];
d1513 2
a1514 2
   if (vao->_VertexAttrib[VERT_ATTRIB_COLOR1].Enabled) {
      aa->array = &vao->_VertexAttrib[VERT_ATTRIB_COLOR1];
d1519 2
a1520 2
   if (vao->_VertexAttrib[VERT_ATTRIB_FOG].Enabled) {
      aa->array = &vao->_VertexAttrib[VERT_ATTRIB_FOG];
d1527 1
a1527 1
         &vao->_VertexAttrib[VERT_ATTRIB_TEX(i)];
d1546 1
a1546 1
         &vao->_VertexAttrib[VERT_ATTRIB_GENERIC(i)];
d1573 1
a1573 1
   if (vao->_VertexAttrib[VERT_ATTRIB_GENERIC0].Enabled) {
d1577 1
a1577 1
      aa->array = &vao->_VertexAttrib[VERT_ATTRIB_GENERIC0];
d1583 2
a1584 2
   else if (vao->_VertexAttrib[VERT_ATTRIB_POS].Enabled) {
      aa->array = &vao->_VertexAttrib[VERT_ATTRIB_POS];
d1590 1
a1590 1
   check_vbo(actx, vao->IndexBufferObj);
a1613 2
   update_derived_client_arrays(ctx);

d1621 1
a1621 2
				 actx->vbo[i],
                                 MAP_INTERNAL);
d1643 1
a1643 1
      ctx->Driver.UnmapBuffer(ctx, actx->vbo[i], MAP_INTERNAL);
a1664 2
   update_derived_client_arrays(ctx);

d1687 1
a1687 2
         = ADD_POINTERS(at->array->BufferObj->Mappings[MAP_INTERNAL].Pointer,
                        at->array->Ptr)
d1695 1
a1695 2
         = ADD_POINTERS(aa->array->BufferObj->Mappings[MAP_INTERNAL].Pointer,
                        aa->array->Ptr)
@


1.1.1.6
log
@Import Mesa 10.4.3
@
text
@a45 1
#include "varray.h"
d50 1
a50 2
   const struct gl_vertex_attrib_array *array;
   const struct gl_vertex_buffer_binding *binding;
d57 1
a57 2
   const struct gl_vertex_attrib_array *array;
   const struct gl_vertex_buffer_binding *binding;
d75 1
a75 1
static inline AEcontext *
d87 1
a87 1
static inline int
d1473 12
d1503 2
a1504 3
   if (vao->VertexAttrib[VERT_ATTRIB_COLOR_INDEX].Enabled) {
      aa->array = &vao->VertexAttrib[VERT_ATTRIB_COLOR_INDEX];
      aa->binding = &vao->VertexBinding[aa->array->VertexBinding];
d1506 1
a1506 1
      check_vbo(actx, aa->binding->BufferObj);
d1509 2
a1510 4

   if (vao->VertexAttrib[VERT_ATTRIB_EDGEFLAG].Enabled) {
      aa->array = &vao->VertexAttrib[VERT_ATTRIB_EDGEFLAG];
      aa->binding = &vao->VertexBinding[aa->array->VertexBinding];
d1512 1
a1512 1
      check_vbo(actx, aa->binding->BufferObj);
d1515 2
a1516 4

   if (vao->VertexAttrib[VERT_ATTRIB_NORMAL].Enabled) {
      aa->array = &vao->VertexAttrib[VERT_ATTRIB_NORMAL];
      aa->binding = &vao->VertexBinding[aa->array->VertexBinding];
d1518 1
a1518 1
      check_vbo(actx, aa->binding->BufferObj);
d1521 2
a1522 4

   if (vao->VertexAttrib[VERT_ATTRIB_COLOR0].Enabled) {
      aa->array = &vao->VertexAttrib[VERT_ATTRIB_COLOR0];
      aa->binding = &vao->VertexBinding[aa->array->VertexBinding];
d1524 1
a1524 1
      check_vbo(actx, aa->binding->BufferObj);
d1527 2
a1528 4

   if (vao->VertexAttrib[VERT_ATTRIB_COLOR1].Enabled) {
      aa->array = &vao->VertexAttrib[VERT_ATTRIB_COLOR1];
      aa->binding = &vao->VertexBinding[aa->array->VertexBinding];
d1530 1
a1530 1
      check_vbo(actx, aa->binding->BufferObj);
d1533 2
a1534 4

   if (vao->VertexAttrib[VERT_ATTRIB_FOG].Enabled) {
      aa->array = &vao->VertexAttrib[VERT_ATTRIB_FOG];
      aa->binding = &vao->VertexBinding[aa->array->VertexBinding];
d1536 1
a1536 1
      check_vbo(actx, aa->binding->BufferObj);
a1538 1

d1540 2
a1541 2
      struct gl_vertex_attrib_array *attribArray =
         &vao->VertexAttrib[VERT_ATTRIB_TEX(i)];
a1546 1
         at->binding = &vao->VertexBinding[attribArray->VertexBinding];
d1552 1
a1552 1
	 check_vbo(actx, at->binding->BufferObj);
d1559 2
a1560 2
      struct gl_vertex_attrib_array *attribArray =
         &vao->VertexAttrib[VERT_ATTRIB_GENERIC(i)];
a1563 1
         at->binding = &vao->VertexBinding[attribArray->VertexBinding];
d1581 1
a1581 1
	 check_vbo(actx, at->binding->BufferObj);
d1587 1
a1587 1
   if (vao->VertexAttrib[VERT_ATTRIB_GENERIC0].Enabled) {
d1591 1
a1591 2
      aa->array = &vao->VertexAttrib[VERT_ATTRIB_GENERIC0];
      aa->binding = &vao->VertexBinding[aa->array->VertexBinding];
d1594 1
a1594 1
      check_vbo(actx, aa->binding->BufferObj);
d1597 2
a1598 3
   else if (vao->VertexAttrib[VERT_ATTRIB_POS].Enabled) {
      aa->array = &vao->VertexAttrib[VERT_ATTRIB_POS];
      aa->binding = &vao->VertexBinding[aa->array->VertexBinding];
d1600 1
a1600 1
      check_vbo(actx, aa->binding->BufferObj);
d1628 2
d1682 2
d1706 3
a1708 3
         = ADD_POINTERS(at->binding->BufferObj->Mappings[MAP_INTERNAL].Pointer,
                        _mesa_vertex_attrib_address(at->array, at->binding))
         + elt * at->binding->Stride;
d1715 3
a1717 3
         = ADD_POINTERS(aa->binding->BufferObj->Mappings[MAP_INTERNAL].Pointer,
                        _mesa_vertex_attrib_address(aa->array, aa->binding))
         + elt * aa->binding->Stride;
@


1.1.1.7
log
@Import Mesa 10.2.9
@
text
@d46 1
d51 2
a52 1
   const struct gl_client_array *array;
d59 2
a60 1
   const struct gl_client_array *array;
d78 1
a78 1
static INLINE AEcontext *
d90 1
a90 1
static INLINE int
a1475 12
static inline void
update_derived_client_arrays(struct gl_context *ctx)
{
   struct gl_vertex_array_object *vao = ctx->Array.VAO;

   if (vao->NewArrays) {
      _mesa_update_vao_client_arrays(ctx, vao);
      vao->NewArrays = 0;
   }
}


d1494 3
a1496 2
   if (vao->_VertexAttrib[VERT_ATTRIB_COLOR_INDEX].Enabled) {
      aa->array = &vao->_VertexAttrib[VERT_ATTRIB_COLOR_INDEX];
d1498 1
a1498 1
      check_vbo(actx, aa->array->BufferObj);
d1501 4
a1504 2
   if (vao->_VertexAttrib[VERT_ATTRIB_EDGEFLAG].Enabled) {
      aa->array = &vao->_VertexAttrib[VERT_ATTRIB_EDGEFLAG];
d1506 1
a1506 1
      check_vbo(actx, aa->array->BufferObj);
d1509 4
a1512 2
   if (vao->_VertexAttrib[VERT_ATTRIB_NORMAL].Enabled) {
      aa->array = &vao->_VertexAttrib[VERT_ATTRIB_NORMAL];
d1514 1
a1514 1
      check_vbo(actx, aa->array->BufferObj);
d1517 4
a1520 2
   if (vao->_VertexAttrib[VERT_ATTRIB_COLOR0].Enabled) {
      aa->array = &vao->_VertexAttrib[VERT_ATTRIB_COLOR0];
d1522 1
a1522 1
      check_vbo(actx, aa->array->BufferObj);
d1525 4
a1528 2
   if (vao->_VertexAttrib[VERT_ATTRIB_COLOR1].Enabled) {
      aa->array = &vao->_VertexAttrib[VERT_ATTRIB_COLOR1];
d1530 1
a1530 1
      check_vbo(actx, aa->array->BufferObj);
d1533 4
a1536 2
   if (vao->_VertexAttrib[VERT_ATTRIB_FOG].Enabled) {
      aa->array = &vao->_VertexAttrib[VERT_ATTRIB_FOG];
d1538 1
a1538 1
      check_vbo(actx, aa->array->BufferObj);
d1541 1
d1543 2
a1544 2
      struct gl_client_array *attribArray =
         &vao->_VertexAttrib[VERT_ATTRIB_TEX(i)];
d1550 1
d1556 1
a1556 1
	 check_vbo(actx, at->array->BufferObj);
d1563 2
a1564 2
      struct gl_client_array *attribArray =
         &vao->_VertexAttrib[VERT_ATTRIB_GENERIC(i)];
d1568 1
d1586 1
a1586 1
	 check_vbo(actx, at->array->BufferObj);
d1592 1
a1592 1
   if (vao->_VertexAttrib[VERT_ATTRIB_GENERIC0].Enabled) {
d1596 2
a1597 1
      aa->array = &vao->_VertexAttrib[VERT_ATTRIB_GENERIC0];
d1600 1
a1600 1
      check_vbo(actx, aa->array->BufferObj);
d1603 3
a1605 2
   else if (vao->_VertexAttrib[VERT_ATTRIB_POS].Enabled) {
      aa->array = &vao->_VertexAttrib[VERT_ATTRIB_POS];
d1607 1
a1607 1
      check_vbo(actx, aa->array->BufferObj);
a1634 2
   update_derived_client_arrays(ctx);

a1686 2
   update_derived_client_arrays(ctx);

d1709 3
a1711 3
         = ADD_POINTERS(at->array->BufferObj->Mappings[MAP_INTERNAL].Pointer,
                        at->array->Ptr)
         + elt * at->array->StrideB;
d1718 3
a1720 3
         = ADD_POINTERS(aa->array->BufferObj->Mappings[MAP_INTERNAL].Pointer,
                        aa->array->Ptr)
         + elt * aa->array->StrideB;
@


