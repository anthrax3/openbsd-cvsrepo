head	1.13;
access;
symbols
	OPENBSD_5_8:1.12.0.4
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	v10_2_9:1.1.1.9
	v10_4_3:1.1.1.8
	v10_2_7:1.1.1.7
	OPENBSD_5_6:1.10.0.2
	OPENBSD_5_6_BASE:1.10
	v10_2_3:1.1.1.7
	OPENBSD_5_5:1.9.0.2
	OPENBSD_5_5_BASE:1.9
	v9_2_5:1.1.1.6
	v9_2_3:1.1.1.6
	v9_2_2:1.1.1.6
	v9_2_1:1.1.1.6
	v9_2_0:1.1.1.5
	OPENBSD_5_4:1.7.0.4
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.6.0.4
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.5.0.6
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2015.12.23.05.17.52;	author jsg;	state dead;
branches;
next	1.12;
commitid	TnlogFl9nOv2eaRf;

1.12
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.11;
commitid	4ry2gvZGMXkCUD2n;

1.11
date	2015.01.25.14.41.21;	author jsg;	state Exp;
branches;
next	1.10;
commitid	mcxB0JvoI9gTDYXU;

1.10
date	2014.07.09.21.09.00;	author jsg;	state Exp;
branches;
next	1.9;
commitid	WPD6rgPryPkvXOr9;

1.9
date	2013.10.05.09.53.59;	author jsg;	state Exp;
branches;
next	1.8;

1.8
date	2013.09.05.14.06.22;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2012.08.17.13.58.19;	author mpi;	state Exp;
branches;
next	1.6;

1.6
date	2011.10.23.13.37.42;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.05.22.20.06.30;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.05.17.20.26.41;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.14.58.21;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.05.31.16.36.48;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.50.05;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.50.05;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.56.36;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.31.07;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.46;	author matthieu;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.09.05.13.16.39;	author jsg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2013.10.05.09.26.19;	author jsg;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2014.07.09.20.35.02;	author jsg;	state Exp;
branches;
next	1.1.1.8;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.8
date	2015.01.25.14.12.42;	author jsg;	state Exp;
branches;
next	1.1.1.9;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.9
date	2015.02.20.22.49.48;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.13
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright (C) 2010  Brian Paul   All Rights Reserved.
 * Copyright (C) 2010  Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Author: Kristian HÃ¸gsberg <krh@@bitplanet.net>
 */

#include "glheader.h"
#include "context.h"
#include "blend.h"
#include "enable.h"
#include "enums.h"
#include "errors.h"
#include "extensions.h"
#include "get.h"
#include "macros.h"
#include "mtypes.h"
#include "state.h"
#include "texcompress.h"
#include "framebuffer.h"
#include "samplerobj.h"
#include "stencil.h"

/* This is a table driven implemetation of the glGet*v() functions.
 * The basic idea is that most getters just look up an int somewhere
 * in struct gl_context and then convert it to a bool or float according to
 * which of glGetIntegerv() glGetBooleanv() etc is being called.
 * Instead of generating code to do this, we can just record the enum
 * value and the offset into struct gl_context in an array of structs.  Then
 * in glGet*(), we lookup the struct for the enum in question, and use
 * the offset to get the int we need.
 *
 * Sometimes we need to look up a float, a boolean, a bit in a
 * bitfield, a matrix or other types instead, so we need to track the
 * type of the value in struct gl_context.  And sometimes the value isn't in
 * struct gl_context but in the drawbuffer, the array object, current texture
 * unit, or maybe it's a computed value.  So we need to also track
 * where or how to find the value.  Finally, we sometimes need to
 * check that one of a number of extensions are enabled, the GL
 * version or flush or call _mesa_update_state().  This is done by
 * attaching optional extra information to the value description
 * struct, it's sort of like an array of opcodes that describe extra
 * checks or actions.
 *
 * Putting all this together we end up with struct value_desc below,
 * and with a couple of macros to help, the table of struct value_desc
 * is about as concise as the specification in the old python script.
 */

#define FLOAT_TO_BOOLEAN(X)   ( (X) ? GL_TRUE : GL_FALSE )
#define FLOAT_TO_FIXED(F)     ( ((F) * 65536.0f > INT_MAX) ? INT_MAX : \
                                ((F) * 65536.0f < INT_MIN) ? INT_MIN : \
                                (GLint) ((F) * 65536.0f) )

#define INT_TO_BOOLEAN(I)     ( (I) ? GL_TRUE : GL_FALSE )
#define INT_TO_FIXED(I)       ( ((I) > SHRT_MAX) ? INT_MAX : \
                                ((I) < SHRT_MIN) ? INT_MIN : \
                                (GLint) ((I) * 65536) )

#define INT64_TO_BOOLEAN(I)   ( (I) ? GL_TRUE : GL_FALSE )
#define INT64_TO_INT(I)       ( (GLint)((I > INT_MAX) ? INT_MAX : ((I < INT_MIN) ? INT_MIN : (I))) )

#define BOOLEAN_TO_INT(B)     ( (GLint) (B) )
#define BOOLEAN_TO_INT64(B)   ( (GLint64) (B) )
#define BOOLEAN_TO_FLOAT(B)   ( (B) ? 1.0F : 0.0F )
#define BOOLEAN_TO_FIXED(B)   ( (GLint) ((B) ? 1 : 0) << 16 )

#define ENUM_TO_INT64(E)      ( (GLint64) (E) )
#define ENUM_TO_FIXED(E)      (E)

enum value_type {
   TYPE_INVALID,
   TYPE_INT,
   TYPE_INT_2,
   TYPE_INT_3,
   TYPE_INT_4,
   TYPE_INT_N,
   TYPE_INT64,
   TYPE_ENUM,
   TYPE_ENUM_2,
   TYPE_BOOLEAN,
   TYPE_BIT_0,
   TYPE_BIT_1,
   TYPE_BIT_2,
   TYPE_BIT_3,
   TYPE_BIT_4,
   TYPE_BIT_5,
   TYPE_BIT_6,
   TYPE_BIT_7,
   TYPE_FLOAT,
   TYPE_FLOAT_2,
   TYPE_FLOAT_3,
   TYPE_FLOAT_4,
   TYPE_FLOATN,
   TYPE_FLOATN_2,
   TYPE_FLOATN_3,
   TYPE_FLOATN_4,
   TYPE_DOUBLEN,
   TYPE_DOUBLEN_2,
   TYPE_MATRIX,
   TYPE_MATRIX_T,
   TYPE_CONST
};

enum value_location {
   LOC_BUFFER,
   LOC_CONTEXT,
   LOC_ARRAY,
   LOC_TEXUNIT,
   LOC_CUSTOM
};

enum value_extra {
   EXTRA_END = 0x8000,
   EXTRA_VERSION_30,
   EXTRA_VERSION_31,
   EXTRA_VERSION_32,
   EXTRA_VERSION_40,
   EXTRA_API_GL,
   EXTRA_API_GL_CORE,
   EXTRA_API_ES2,
   EXTRA_API_ES3,
   EXTRA_NEW_BUFFERS, 
   EXTRA_NEW_FRAG_CLAMP,
   EXTRA_VALID_DRAW_BUFFER,
   EXTRA_VALID_TEXTURE_UNIT,
   EXTRA_VALID_CLIP_DISTANCE,
   EXTRA_FLUSH_CURRENT,
   EXTRA_GLSL_130,
   EXTRA_EXT_UBO_GS4,
   EXTRA_EXT_ATOMICS_GS4,
   EXTRA_EXT_SHADER_IMAGE_GS4,
};

#define NO_EXTRA NULL
#define NO_OFFSET 0

struct value_desc {
   GLenum pname;
   GLubyte location;  /**< enum value_location */
   GLubyte type;      /**< enum value_type */
   int offset;
   const int *extra;
};

union value {
   GLfloat value_float;
   GLfloat value_float_4[4];
   GLdouble value_double_2[2];
   GLmatrix *value_matrix;
   GLint value_int;
   GLint value_int_4[4];
   GLint64 value_int64;
   GLenum value_enum;

   /* Sigh, see GL_COMPRESSED_TEXTURE_FORMATS_ARB handling */
   struct {
      GLint n, ints[100];
   } value_int_n;
   GLboolean value_bool;
};

#define BUFFER_FIELD(field, type) \
   LOC_BUFFER, type, offsetof(struct gl_framebuffer, field)
#define CONTEXT_FIELD(field, type) \
   LOC_CONTEXT, type, offsetof(struct gl_context, field)
#define ARRAY_FIELD(field, type) \
   LOC_ARRAY, type, offsetof(struct gl_vertex_array_object, field)
#undef CONST /* already defined through windows.h */
#define CONST(value) \
   LOC_CONTEXT, TYPE_CONST, value

#define BUFFER_INT(field) BUFFER_FIELD(field, TYPE_INT)
#define BUFFER_ENUM(field) BUFFER_FIELD(field, TYPE_ENUM)
#define BUFFER_BOOL(field) BUFFER_FIELD(field, TYPE_BOOLEAN)

#define CONTEXT_INT(field) CONTEXT_FIELD(field, TYPE_INT)
#define CONTEXT_INT2(field) CONTEXT_FIELD(field, TYPE_INT_2)
#define CONTEXT_INT64(field) CONTEXT_FIELD(field, TYPE_INT64)
#define CONTEXT_ENUM(field) CONTEXT_FIELD(field, TYPE_ENUM)
#define CONTEXT_ENUM2(field) CONTEXT_FIELD(field, TYPE_ENUM_2)
#define CONTEXT_BOOL(field) CONTEXT_FIELD(field, TYPE_BOOLEAN)
#define CONTEXT_BIT0(field) CONTEXT_FIELD(field, TYPE_BIT_0)
#define CONTEXT_BIT1(field) CONTEXT_FIELD(field, TYPE_BIT_1)
#define CONTEXT_BIT2(field) CONTEXT_FIELD(field, TYPE_BIT_2)
#define CONTEXT_BIT3(field) CONTEXT_FIELD(field, TYPE_BIT_3)
#define CONTEXT_BIT4(field) CONTEXT_FIELD(field, TYPE_BIT_4)
#define CONTEXT_BIT5(field) CONTEXT_FIELD(field, TYPE_BIT_5)
#define CONTEXT_BIT6(field) CONTEXT_FIELD(field, TYPE_BIT_6)
#define CONTEXT_BIT7(field) CONTEXT_FIELD(field, TYPE_BIT_7)
#define CONTEXT_FLOAT(field) CONTEXT_FIELD(field, TYPE_FLOAT)
#define CONTEXT_FLOAT2(field) CONTEXT_FIELD(field, TYPE_FLOAT_2)
#define CONTEXT_FLOAT3(field) CONTEXT_FIELD(field, TYPE_FLOAT_3)
#define CONTEXT_FLOAT4(field) CONTEXT_FIELD(field, TYPE_FLOAT_4)
#define CONTEXT_MATRIX(field) CONTEXT_FIELD(field, TYPE_MATRIX)
#define CONTEXT_MATRIX_T(field) CONTEXT_FIELD(field, TYPE_MATRIX_T)

#define ARRAY_INT(field) ARRAY_FIELD(field, TYPE_INT)
#define ARRAY_ENUM(field) ARRAY_FIELD(field, TYPE_ENUM)
#define ARRAY_BOOL(field) ARRAY_FIELD(field, TYPE_BOOLEAN)

#define EXT(f)					\
   offsetof(struct gl_extensions, f)

#define EXTRA_EXT(e)				\
   static const int extra_##e[] = {		\
      EXT(e), EXTRA_END				\
   }

#define EXTRA_EXT2(e1, e2)			\
   static const int extra_##e1##_##e2[] = {	\
      EXT(e1), EXT(e2), EXTRA_END		\
   }

/* The 'extra' mechanism is a way to specify extra checks (such as
 * extensions or specific gl versions) or actions (flush current, new
 * buffers) that we need to do before looking up an enum.  We need to
 * declare them all up front so we can refer to them in the value_desc
 * structs below.
 *
 * Each EXTRA_ will be executed.  For EXTRA_* enums of extensions and API
 * versions, listing multiple ones in an array means an error will be thrown
 * only if none of them are available.  If you need to check for "AND"
 * behavior, you would need to make a custom EXTRA_ enum.
 */

static const int extra_new_buffers[] = {
   EXTRA_NEW_BUFFERS,
   EXTRA_END
};

static const int extra_new_frag_clamp[] = {
   EXTRA_NEW_FRAG_CLAMP,
   EXTRA_END
};

static const int extra_valid_draw_buffer[] = {
   EXTRA_VALID_DRAW_BUFFER,
   EXTRA_END
};

static const int extra_valid_texture_unit[] = {
   EXTRA_VALID_TEXTURE_UNIT,
   EXTRA_END
};

static const int extra_valid_clip_distance[] = {
   EXTRA_VALID_CLIP_DISTANCE,
   EXTRA_END
};

static const int extra_flush_current_valid_texture_unit[] = {
   EXTRA_FLUSH_CURRENT,
   EXTRA_VALID_TEXTURE_UNIT,
   EXTRA_END
};

static const int extra_flush_current[] = {
   EXTRA_FLUSH_CURRENT,
   EXTRA_END
};

static const int extra_EXT_texture_integer[] = {
   EXT(EXT_texture_integer),
   EXTRA_END
};

static const int extra_EXT_texture_integer_and_new_buffers[] = {
   EXT(EXT_texture_integer),
   EXTRA_NEW_BUFFERS,
   EXTRA_END
};

static const int extra_GLSL_130_es3[] = {
   EXTRA_GLSL_130,
   EXTRA_API_ES3,
   EXTRA_END
};

static const int extra_texture_buffer_object[] = {
   EXTRA_API_GL_CORE,
   EXTRA_VERSION_31,
   EXT(ARB_texture_buffer_object),
   EXTRA_END
};

static const int extra_ARB_transform_feedback2_api_es3[] = {
   EXT(ARB_transform_feedback2),
   EXTRA_API_ES3,
   EXTRA_END
};

static const int extra_ARB_uniform_buffer_object_and_geometry_shader[] = {
   EXTRA_EXT_UBO_GS4,
   EXTRA_END
};

static const int extra_ARB_ES2_compatibility_api_es2[] = {
   EXT(ARB_ES2_compatibility),
   EXTRA_API_ES2,
   EXTRA_END
};

static const int extra_ARB_ES3_compatibility_api_es3[] = {
   EXT(ARB_ES3_compatibility),
   EXTRA_API_ES3,
   EXTRA_END
};

static const int extra_EXT_framebuffer_sRGB_and_new_buffers[] = {
   EXT(EXT_framebuffer_sRGB),
   EXTRA_NEW_BUFFERS,
   EXTRA_END
};

static const int extra_EXT_packed_float[] = {
   EXT(EXT_packed_float),
   EXTRA_NEW_BUFFERS,
   EXTRA_END
};

static const int extra_EXT_texture_array_es3[] = {
   EXT(EXT_texture_array),
   EXTRA_API_ES3,
   EXTRA_END
};

static const int extra_ARB_shader_atomic_counters_and_geometry_shader[] = {
   EXTRA_EXT_ATOMICS_GS4,
   EXTRA_END
};

static const int extra_ARB_shader_image_load_store_and_geometry_shader[] = {
   EXTRA_EXT_SHADER_IMAGE_GS4,
   EXTRA_END
};

EXTRA_EXT(ARB_texture_cube_map);
EXTRA_EXT(EXT_texture_array);
EXTRA_EXT(NV_fog_distance);
EXTRA_EXT(EXT_texture_filter_anisotropic);
EXTRA_EXT(NV_point_sprite);
EXTRA_EXT(NV_texture_rectangle);
EXTRA_EXT(EXT_stencil_two_side);
EXTRA_EXT(EXT_depth_bounds_test);
EXTRA_EXT(ARB_depth_clamp);
EXTRA_EXT(ATI_fragment_shader);
EXTRA_EXT(EXT_provoking_vertex);
EXTRA_EXT(ARB_fragment_shader);
EXTRA_EXT(ARB_fragment_program);
EXTRA_EXT2(ARB_framebuffer_object, EXT_framebuffer_multisample);
EXTRA_EXT(ARB_seamless_cube_map);
EXTRA_EXT(ARB_sync);
EXTRA_EXT(ARB_vertex_shader);
EXTRA_EXT(EXT_transform_feedback);
EXTRA_EXT(ARB_transform_feedback3);
EXTRA_EXT(EXT_pixel_buffer_object);
EXTRA_EXT(ARB_vertex_program);
EXTRA_EXT2(NV_point_sprite, ARB_point_sprite);
EXTRA_EXT2(ARB_vertex_program, ARB_fragment_program);
EXTRA_EXT(ARB_geometry_shader4);
EXTRA_EXT(ARB_color_buffer_float);
EXTRA_EXT(EXT_framebuffer_sRGB);
EXTRA_EXT(OES_EGL_image_external);
EXTRA_EXT(ARB_blend_func_extended);
EXTRA_EXT(ARB_uniform_buffer_object);
EXTRA_EXT(ARB_timer_query);
EXTRA_EXT(ARB_texture_cube_map_array);
EXTRA_EXT(ARB_texture_buffer_range);
EXTRA_EXT(ARB_texture_multisample);
EXTRA_EXT(ARB_texture_gather);
EXTRA_EXT(ARB_shader_atomic_counters);
EXTRA_EXT(ARB_draw_indirect);
EXTRA_EXT(ARB_shader_image_load_store);
EXTRA_EXT(ARB_viewport_array);
EXTRA_EXT(ARB_compute_shader);
EXTRA_EXT(ARB_gpu_shader5);
EXTRA_EXT2(ARB_transform_feedback3, ARB_gpu_shader5);
EXTRA_EXT(INTEL_performance_query);

static const int
extra_ARB_color_buffer_float_or_glcore[] = {
   EXT(ARB_color_buffer_float),
   EXTRA_API_GL_CORE,
   EXTRA_END
};

static const int
extra_NV_primitive_restart[] = {
   EXT(NV_primitive_restart),
   EXTRA_END
};

static const int extra_version_30[] = { EXTRA_VERSION_30, EXTRA_END };
static const int extra_version_31[] = { EXTRA_VERSION_31, EXTRA_END };
static const int extra_version_32[] = { EXTRA_VERSION_32, EXTRA_END };
static const int extra_version_40[] = { EXTRA_VERSION_40, EXTRA_END };

static const int extra_gl30_es3[] = {
    EXTRA_VERSION_30,
    EXTRA_API_ES3,
    EXTRA_END,
};

static const int extra_gl32_es3[] = {
    EXTRA_VERSION_32,
    EXTRA_API_ES3,
    EXTRA_END,
};

static const int extra_gl32_ARB_geometry_shader4[] = {
    EXTRA_VERSION_32,
    EXT(ARB_geometry_shader4),
    EXTRA_END
};

static const int extra_gl40_ARB_sample_shading[] = {
   EXTRA_VERSION_40,
   EXT(ARB_sample_shading),
   EXTRA_END
};

static const int
extra_ARB_vertex_program_api_es2[] = {
   EXT(ARB_vertex_program),
   EXTRA_API_ES2,
   EXTRA_END
};

/* The ReadBuffer get token is valid under either full GL or under
 * GLES2 if the NV_read_buffer extension is available. */
static const int
extra_NV_read_buffer_api_gl[] = {
   EXTRA_API_ES2,
   EXTRA_API_GL,
   EXTRA_END
};

static const int extra_core_ARB_color_buffer_float_and_new_buffers[] = {
   EXTRA_API_GL_CORE,
   EXT(ARB_color_buffer_float),
   EXTRA_NEW_BUFFERS,
   EXTRA_END
};

/* This is the big table describing all the enums we accept in
 * glGet*v().  The table is partitioned into six parts: enums
 * understood by all GL APIs (OpenGL, GLES and GLES2), enums shared
 * between OpenGL and GLES, enums exclusive to GLES, etc for the
 * remaining combinations. To look up the enums valid in a given API
 * we will use a hash table specific to that API. These tables are in
 * turn generated at build time and included through get_hash.h.
 */

#include "get_hash.h"

/* All we need now is a way to look up the value struct from the enum.
 * The code generated by gcc for the old generated big switch
 * statement is a big, balanced, open coded if/else tree, essentially
 * an unrolled binary search.  It would be natural to sort the new
 * enum table and use bsearch(), but we will use a read-only hash
 * table instead.  bsearch() has a nice guaranteed worst case
 * performance, but we're also guaranteed to hit that worst case
 * (log2(n) iterations) for about half the enums.  Instead, using an
 * open addressing hash table, we can find the enum on the first try
 * for 80% of the enums, 1 collision for 10% and never more than 5
 * collisions for any enum (typical numbers).  And the code is very
 * simple, even though it feels a little magic. */

#ifdef GET_DEBUG
static void
print_table_stats(int api)
{
   int i, j, collisions[11], count, hash, mask;
   const struct value_desc *d;
   const char *api_names[] = {
      [API_OPENGL_COMPAT] = "GL",
      [API_OPENGL_CORE] = "GL_CORE",
      [API_OPENGLES] = "GLES",
      [API_OPENGLES2] = "GLES2",
   };
   const char *api_name;

   api_name = api < Elements(api_names) ? api_names[api] : "N/A";
   count = 0;
   mask = Elements(table(api)) - 1;
   memset(collisions, 0, sizeof collisions);

   for (i = 0; i < Elements(table(api)); i++) {
      if (!table(api)[i])
         continue;
      count++;
      d = &values[table(api)[i]];
      hash = (d->pname * prime_factor);
      j = 0;
      while (1) {
         if (values[table(api)[hash & mask]].pname == d->pname)
            break;
         hash += prime_step;
         j++;
      }

      if (j < 10)
         collisions[j]++;
      else
         collisions[10]++;
   }

   printf("number of enums for %s: %d (total %ld)\n",
         api_name, count, Elements(values));
   for (i = 0; i < Elements(collisions) - 1; i++)
      if (collisions[i] > 0)
         printf("  %d enums with %d %scollisions\n",
               collisions[i], i, i == 10 ? "or more " : "");
}
#endif

/**
 * Initialize the enum hash for a given API 
 *
 * This is called from one_time_init() to insert the enum values that
 * are valid for the API in question into the enum hash table.
 *
 * \param the current context, for determining the API in question
 */
void _mesa_init_get_hash(struct gl_context *ctx)
{
#ifdef GET_DEBUG
   print_table_stats(ctx->API);
#else
   (void) ctx;
#endif
}

/**
 * Handle irregular enums
 *
 * Some values don't conform to the "well-known type at context
 * pointer + offset" pattern, so we have this function to catch all
 * the corner cases.  Typically, it's a computed value or a one-off
 * pointer to a custom struct or something.
 *
 * In this case we can't return a pointer to the value, so we'll have
 * to use the temporary variable 'v' declared back in the calling
 * glGet*v() function to store the result.
 *
 * \param ctx the current context
 * \param d the struct value_desc that describes the enum
 * \param v pointer to the tmp declared in the calling glGet*v() function
 */
static void
find_custom_value(struct gl_context *ctx, const struct value_desc *d, union value *v)
{
   struct gl_buffer_object **buffer_obj;
   struct gl_vertex_attrib_array *array;
   GLuint unit, *p;

   switch (d->pname) {
   case GL_MAJOR_VERSION:
      v->value_int = ctx->Version / 10;
      break;
   case GL_MINOR_VERSION:
      v->value_int = ctx->Version % 10;
      break;

   case GL_TEXTURE_1D:
   case GL_TEXTURE_2D:
   case GL_TEXTURE_3D:
   case GL_TEXTURE_CUBE_MAP_ARB:
   case GL_TEXTURE_RECTANGLE_NV:
   case GL_TEXTURE_EXTERNAL_OES:
      v->value_bool = _mesa_IsEnabled(d->pname);
      break;

   case GL_LINE_STIPPLE_PATTERN:
      /* This is the only GLushort, special case it here by promoting
       * to an int rather than introducing a new type. */
      v->value_int = ctx->Line.StipplePattern;
      break;

   case GL_CURRENT_RASTER_TEXTURE_COORDS:
      unit = ctx->Texture.CurrentUnit;
      v->value_float_4[0] = ctx->Current.RasterTexCoords[unit][0];
      v->value_float_4[1] = ctx->Current.RasterTexCoords[unit][1];
      v->value_float_4[2] = ctx->Current.RasterTexCoords[unit][2];
      v->value_float_4[3] = ctx->Current.RasterTexCoords[unit][3];
      break;

   case GL_CURRENT_TEXTURE_COORDS:
      unit = ctx->Texture.CurrentUnit;
      v->value_float_4[0] = ctx->Current.Attrib[VERT_ATTRIB_TEX0 + unit][0];
      v->value_float_4[1] = ctx->Current.Attrib[VERT_ATTRIB_TEX0 + unit][1];
      v->value_float_4[2] = ctx->Current.Attrib[VERT_ATTRIB_TEX0 + unit][2];
      v->value_float_4[3] = ctx->Current.Attrib[VERT_ATTRIB_TEX0 + unit][3];
      break;

   case GL_COLOR_WRITEMASK:
      v->value_int_4[0] = ctx->Color.ColorMask[0][RCOMP] ? 1 : 0;
      v->value_int_4[1] = ctx->Color.ColorMask[0][GCOMP] ? 1 : 0;
      v->value_int_4[2] = ctx->Color.ColorMask[0][BCOMP] ? 1 : 0;
      v->value_int_4[3] = ctx->Color.ColorMask[0][ACOMP] ? 1 : 0;
      break;

   case GL_EDGE_FLAG:
      v->value_bool = ctx->Current.Attrib[VERT_ATTRIB_EDGEFLAG][0] == 1.0;
      break;

   case GL_READ_BUFFER:
      v->value_enum = ctx->ReadBuffer->ColorReadBuffer;
      break;

   case GL_MAP2_GRID_DOMAIN:
      v->value_float_4[0] = ctx->Eval.MapGrid2u1;
      v->value_float_4[1] = ctx->Eval.MapGrid2u2;
      v->value_float_4[2] = ctx->Eval.MapGrid2v1;
      v->value_float_4[3] = ctx->Eval.MapGrid2v2;
      break;

   case GL_TEXTURE_STACK_DEPTH:
      unit = ctx->Texture.CurrentUnit;
      v->value_int = ctx->TextureMatrixStack[unit].Depth + 1;
      break;
   case GL_TEXTURE_MATRIX:
      unit = ctx->Texture.CurrentUnit;
      v->value_matrix = ctx->TextureMatrixStack[unit].Top;
      break;

   case GL_TEXTURE_COORD_ARRAY:
   case GL_TEXTURE_COORD_ARRAY_SIZE:
   case GL_TEXTURE_COORD_ARRAY_TYPE:
   case GL_TEXTURE_COORD_ARRAY_STRIDE:
      array = &ctx->Array.VAO->VertexAttrib[VERT_ATTRIB_TEX(ctx->Array.ActiveTexture)];
      v->value_int = *(GLuint *) ((char *) array + d->offset);
      break;

   case GL_ACTIVE_TEXTURE_ARB:
      v->value_int = GL_TEXTURE0_ARB + ctx->Texture.CurrentUnit;
      break;
   case GL_CLIENT_ACTIVE_TEXTURE_ARB:
      v->value_int = GL_TEXTURE0_ARB + ctx->Array.ActiveTexture;
      break;

   case GL_MODELVIEW_STACK_DEPTH:
   case GL_PROJECTION_STACK_DEPTH:
      v->value_int = *(GLint *) ((char *) ctx + d->offset) + 1;
      break;

   case GL_MAX_TEXTURE_SIZE:
   case GL_MAX_3D_TEXTURE_SIZE:
   case GL_MAX_CUBE_MAP_TEXTURE_SIZE_ARB:
      p = (GLuint *) ((char *) ctx + d->offset);
      v->value_int = 1 << (*p - 1);
      break;

   case GL_SCISSOR_BOX:
      v->value_int_4[0] = ctx->Scissor.ScissorArray[0].X;
      v->value_int_4[1] = ctx->Scissor.ScissorArray[0].Y;
      v->value_int_4[2] = ctx->Scissor.ScissorArray[0].Width;
      v->value_int_4[3] = ctx->Scissor.ScissorArray[0].Height;
      break;

   case GL_SCISSOR_TEST:
      v->value_bool = ctx->Scissor.EnableFlags & 1;
      break;

   case GL_LIST_INDEX:
      v->value_int =
	 ctx->ListState.CurrentList ? ctx->ListState.CurrentList->Name : 0;
      break;
   case GL_LIST_MODE:
      if (!ctx->CompileFlag)
	 v->value_enum = 0;
      else if (ctx->ExecuteFlag)
	 v->value_enum = GL_COMPILE_AND_EXECUTE;
      else
	 v->value_enum = GL_COMPILE;
      break;

   case GL_VIEWPORT:
      v->value_float_4[0] = ctx->ViewportArray[0].X;
      v->value_float_4[1] = ctx->ViewportArray[0].Y;
      v->value_float_4[2] = ctx->ViewportArray[0].Width;
      v->value_float_4[3] = ctx->ViewportArray[0].Height;
      break;

   case GL_DEPTH_RANGE:
      v->value_double_2[0] = ctx->ViewportArray[0].Near;
      v->value_double_2[1] = ctx->ViewportArray[0].Far;
      break;

   case GL_ACTIVE_STENCIL_FACE_EXT:
      v->value_enum = ctx->Stencil.ActiveFace ? GL_BACK : GL_FRONT;
      break;

   case GL_STENCIL_FAIL:
      v->value_enum = ctx->Stencil.FailFunc[ctx->Stencil.ActiveFace];
      break;
   case GL_STENCIL_FUNC:
      v->value_enum = ctx->Stencil.Function[ctx->Stencil.ActiveFace];
      break;
   case GL_STENCIL_PASS_DEPTH_FAIL:
      v->value_enum = ctx->Stencil.ZFailFunc[ctx->Stencil.ActiveFace];
      break;
   case GL_STENCIL_PASS_DEPTH_PASS:
      v->value_enum = ctx->Stencil.ZPassFunc[ctx->Stencil.ActiveFace];
      break;
   case GL_STENCIL_REF:
      v->value_int = _mesa_get_stencil_ref(ctx, ctx->Stencil.ActiveFace);
      break;
   case GL_STENCIL_BACK_REF:
      v->value_int = _mesa_get_stencil_ref(ctx, 1);
      break;
   case GL_STENCIL_VALUE_MASK:
      v->value_int = ctx->Stencil.ValueMask[ctx->Stencil.ActiveFace];
      break;
   case GL_STENCIL_WRITEMASK:
      v->value_int = ctx->Stencil.WriteMask[ctx->Stencil.ActiveFace];
      break;

   case GL_NUM_EXTENSIONS:
      v->value_int = _mesa_get_extension_count(ctx);
      break;

   case GL_IMPLEMENTATION_COLOR_READ_TYPE_OES:
      v->value_int = _mesa_get_color_read_type(ctx);
      break;
   case GL_IMPLEMENTATION_COLOR_READ_FORMAT_OES:
      v->value_int = _mesa_get_color_read_format(ctx);
      break;

   case GL_CURRENT_MATRIX_STACK_DEPTH_ARB:
      v->value_int = ctx->CurrentStack->Depth + 1;
      break;
   case GL_CURRENT_MATRIX_ARB:
   case GL_TRANSPOSE_CURRENT_MATRIX_ARB:
      v->value_matrix = ctx->CurrentStack->Top;
      break;

   case GL_NUM_COMPRESSED_TEXTURE_FORMATS_ARB:
      v->value_int = _mesa_get_compressed_formats(ctx, NULL);
      break;
   case GL_COMPRESSED_TEXTURE_FORMATS_ARB:
      v->value_int_n.n = 
	 _mesa_get_compressed_formats(ctx, v->value_int_n.ints);
      ASSERT(v->value_int_n.n <= (int) ARRAY_SIZE(v->value_int_n.ints));
      break;

   case GL_MAX_VARYING_FLOATS_ARB:
      v->value_int = ctx->Const.MaxVarying * 4;
      break;

   /* Various object names */

   case GL_TEXTURE_BINDING_1D:
   case GL_TEXTURE_BINDING_2D:
   case GL_TEXTURE_BINDING_3D:
   case GL_TEXTURE_BINDING_1D_ARRAY_EXT:
   case GL_TEXTURE_BINDING_2D_ARRAY_EXT:
   case GL_TEXTURE_BINDING_CUBE_MAP_ARB:
   case GL_TEXTURE_BINDING_RECTANGLE_NV:
   case GL_TEXTURE_BINDING_EXTERNAL_OES:
   case GL_TEXTURE_BINDING_CUBE_MAP_ARRAY:
   case GL_TEXTURE_BINDING_2D_MULTISAMPLE:
   case GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY:
      unit = ctx->Texture.CurrentUnit;
      v->value_int =
	 ctx->Texture.Unit[unit].CurrentTex[d->offset]->Name;
      break;

   /* GL_EXT_packed_float */
   case GL_RGBA_SIGNED_COMPONENTS_EXT:
      {
         /* Note: we only check the 0th color attachment. */
         const struct gl_renderbuffer *rb =
            ctx->DrawBuffer->_ColorDrawBuffers[0];
         if (rb && _mesa_is_format_signed(rb->Format)) {
            /* Issue 17 of GL_EXT_packed_float:  If a component (such as
             * alpha) has zero bits, the component should not be considered
             * signed and so the bit for the respective component should be
             * zeroed.
             */
            GLint r_bits =
               _mesa_get_format_bits(rb->Format, GL_RED_BITS);
            GLint g_bits =
               _mesa_get_format_bits(rb->Format, GL_GREEN_BITS);
            GLint b_bits =
               _mesa_get_format_bits(rb->Format, GL_BLUE_BITS);
            GLint a_bits =
               _mesa_get_format_bits(rb->Format, GL_ALPHA_BITS);
            GLint l_bits =
               _mesa_get_format_bits(rb->Format, GL_TEXTURE_LUMINANCE_SIZE);
            GLint i_bits =
               _mesa_get_format_bits(rb->Format, GL_TEXTURE_INTENSITY_SIZE);

            v->value_int_4[0] = r_bits + l_bits + i_bits > 0;
            v->value_int_4[1] = g_bits + l_bits + i_bits > 0;
            v->value_int_4[2] = b_bits + l_bits + i_bits > 0;
            v->value_int_4[3] = a_bits + i_bits > 0;
         }
         else {
            v->value_int_4[0] =
            v->value_int_4[1] =
            v->value_int_4[2] =
            v->value_int_4[3] = 0;
         }
      }
      break;

   /* GL_ARB_vertex_buffer_object */
   case GL_VERTEX_ARRAY_BUFFER_BINDING_ARB:
   case GL_NORMAL_ARRAY_BUFFER_BINDING_ARB:
   case GL_COLOR_ARRAY_BUFFER_BINDING_ARB:
   case GL_INDEX_ARRAY_BUFFER_BINDING_ARB:
   case GL_EDGE_FLAG_ARRAY_BUFFER_BINDING_ARB:
   case GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING_ARB:
   case GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING_ARB:
      buffer_obj = (struct gl_buffer_object **)
	 ((char *) ctx->Array.VAO + d->offset);
      v->value_int = (*buffer_obj)->Name;
      break;
   case GL_ARRAY_BUFFER_BINDING_ARB:
      v->value_int = ctx->Array.ArrayBufferObj->Name;
      break;
   case GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING_ARB:
      v->value_int =
	 ctx->Array.VAO->VertexBinding[VERT_ATTRIB_TEX(ctx->Array.ActiveTexture)].BufferObj->Name;
      break;
   case GL_ELEMENT_ARRAY_BUFFER_BINDING_ARB:
      v->value_int = ctx->Array.VAO->IndexBufferObj->Name;
      break;

   /* ARB_vertex_array_bgra */
   case GL_COLOR_ARRAY_SIZE:
      array = &ctx->Array.VAO->VertexAttrib[VERT_ATTRIB_COLOR0];
      v->value_int = array->Format == GL_BGRA ? GL_BGRA : array->Size;
      break;
   case GL_SECONDARY_COLOR_ARRAY_SIZE:
      array = &ctx->Array.VAO->VertexAttrib[VERT_ATTRIB_COLOR1];
      v->value_int = array->Format == GL_BGRA ? GL_BGRA : array->Size;
      break;

   /* ARB_copy_buffer */
   case GL_COPY_READ_BUFFER:
      v->value_int = ctx->CopyReadBuffer->Name;
      break;
   case GL_COPY_WRITE_BUFFER:
      v->value_int = ctx->CopyWriteBuffer->Name;
      break;

   case GL_PIXEL_PACK_BUFFER_BINDING_EXT:
      v->value_int = ctx->Pack.BufferObj->Name;
      break;
   case GL_PIXEL_UNPACK_BUFFER_BINDING_EXT:
      v->value_int = ctx->Unpack.BufferObj->Name;
      break;
   case GL_TRANSFORM_FEEDBACK_BUFFER_BINDING:
      v->value_int = ctx->TransformFeedback.CurrentBuffer->Name;
      break;
   case GL_TRANSFORM_FEEDBACK_BUFFER_PAUSED:
      v->value_int = ctx->TransformFeedback.CurrentObject->Paused;
      break;
   case GL_TRANSFORM_FEEDBACK_BUFFER_ACTIVE:
      v->value_int = ctx->TransformFeedback.CurrentObject->Active;
      break;
   case GL_TRANSFORM_FEEDBACK_BINDING:
      v->value_int = ctx->TransformFeedback.CurrentObject->Name;
      break;
   case GL_CURRENT_PROGRAM:
      /* The Changelog of the ARB_separate_shader_objects spec says:
       *
       * 24 25 Jul 2011  pbrown  Remove the language erroneously deleting
       *                         CURRENT_PROGRAM.  In the EXT extension, this
       *                         token was aliased to ACTIVE_PROGRAM_EXT, and
       *                         was used to indicate the last program set by
       *                         either ActiveProgramEXT or UseProgram.  In
       *                         the ARB extension, the SSO active programs
       *                         are now program pipeline object state and
       *                         CURRENT_PROGRAM should still be used to query
       *                         the last program set by UseProgram (bug 7822).
       */
      v->value_int =
	 ctx->Shader.ActiveProgram ? ctx->Shader.ActiveProgram->Name : 0;
      break;
   case GL_READ_FRAMEBUFFER_BINDING_EXT:
      v->value_int = ctx->ReadBuffer->Name;
      break;
   case GL_RENDERBUFFER_BINDING_EXT:
      v->value_int =
	 ctx->CurrentRenderbuffer ? ctx->CurrentRenderbuffer->Name : 0;
      break;
   case GL_POINT_SIZE_ARRAY_BUFFER_BINDING_OES:
      v->value_int = ctx->Array.VAO->VertexBinding[VERT_ATTRIB_POINT_SIZE].BufferObj->Name;
      break;

   case GL_FOG_COLOR:
      if (_mesa_get_clamp_fragment_color(ctx))
         COPY_4FV(v->value_float_4, ctx->Fog.Color);
      else
         COPY_4FV(v->value_float_4, ctx->Fog.ColorUnclamped);
      break;
   case GL_COLOR_CLEAR_VALUE:
      if (_mesa_get_clamp_fragment_color(ctx)) {
         v->value_float_4[0] = CLAMP(ctx->Color.ClearColor.f[0], 0.0F, 1.0F);
         v->value_float_4[1] = CLAMP(ctx->Color.ClearColor.f[1], 0.0F, 1.0F);
         v->value_float_4[2] = CLAMP(ctx->Color.ClearColor.f[2], 0.0F, 1.0F);
         v->value_float_4[3] = CLAMP(ctx->Color.ClearColor.f[3], 0.0F, 1.0F);
      } else
         COPY_4FV(v->value_float_4, ctx->Color.ClearColor.f);
      break;
   case GL_BLEND_COLOR_EXT:
      if (_mesa_get_clamp_fragment_color(ctx))
         COPY_4FV(v->value_float_4, ctx->Color.BlendColor);
      else
         COPY_4FV(v->value_float_4, ctx->Color.BlendColorUnclamped);
      break;
   case GL_ALPHA_TEST_REF:
      if (_mesa_get_clamp_fragment_color(ctx))
         v->value_float = ctx->Color.AlphaRef;
      else
         v->value_float = ctx->Color.AlphaRefUnclamped;
      break;
   case GL_MAX_VERTEX_UNIFORM_VECTORS:
      v->value_int = ctx->Const.Program[MESA_SHADER_VERTEX].MaxUniformComponents / 4;
      break;

   case GL_MAX_FRAGMENT_UNIFORM_VECTORS:
      v->value_int = ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxUniformComponents / 4;
      break;

   /* GL_ARB_texture_buffer_object */
   case GL_TEXTURE_BUFFER_ARB:
      v->value_int = ctx->Texture.BufferObject->Name;
      break;
   case GL_TEXTURE_BINDING_BUFFER_ARB:
      unit = ctx->Texture.CurrentUnit;
      v->value_int =
         ctx->Texture.Unit[unit].CurrentTex[TEXTURE_BUFFER_INDEX]->Name;
      break;
   case GL_TEXTURE_BUFFER_DATA_STORE_BINDING_ARB:
      {
         struct gl_buffer_object *buf =
            ctx->Texture.Unit[ctx->Texture.CurrentUnit]
            .CurrentTex[TEXTURE_BUFFER_INDEX]->BufferObject;
         v->value_int = buf ? buf->Name : 0;
      }
      break;
   case GL_TEXTURE_BUFFER_FORMAT_ARB:
      v->value_int = ctx->Texture.Unit[ctx->Texture.CurrentUnit]
         .CurrentTex[TEXTURE_BUFFER_INDEX]->BufferObjectFormat;
      break;

   /* GL_ARB_sampler_objects */
   case GL_SAMPLER_BINDING:
      {
         struct gl_sampler_object *samp =
            ctx->Texture.Unit[ctx->Texture.CurrentUnit].Sampler;

         /*
          * The sampler object may have been deleted on another context,
          * so we try to lookup the sampler object before returning its Name.
          */
         if (samp && _mesa_lookup_samplerobj(ctx, samp->Name)) {
            v->value_int = samp->Name;
         } else {
            v->value_int = 0;
         }
      }
      break;
   /* GL_ARB_uniform_buffer_object */
   case GL_UNIFORM_BUFFER_BINDING:
      v->value_int = ctx->UniformBuffer->Name;
      break;
   /* GL_ARB_timer_query */
   case GL_TIMESTAMP:
      if (ctx->Driver.GetTimestamp) {
         v->value_int64 = ctx->Driver.GetTimestamp(ctx);
      }
      else {
         _mesa_problem(ctx, "driver doesn't implement GetTimestamp");
      }
      break;
   /* GL_KHR_DEBUG */
   case GL_DEBUG_LOGGED_MESSAGES:
   case GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH:
   case GL_DEBUG_GROUP_STACK_DEPTH:
      v->value_int = _mesa_get_debug_state_int(ctx, d->pname);
      break;
   /* GL_ARB_shader_atomic_counters */
   case GL_ATOMIC_COUNTER_BUFFER_BINDING:
      if (ctx->AtomicBuffer) {
         v->value_int = ctx->AtomicBuffer->Name;
      } else {
         v->value_int = 0;
      }
      break;
   /* GL_ARB_draw_indirect */
   case GL_DRAW_INDIRECT_BUFFER_BINDING:
      v->value_int = ctx->DrawIndirectBuffer->Name;
      break;
   /* GL_ARB_separate_shader_objects */
   case GL_PROGRAM_PIPELINE_BINDING:
      if (ctx->Pipeline.Current) {
         v->value_int = ctx->Pipeline.Current->Name;
      } else {
         v->value_int = 0;
      }
      break;
   }
}

/**
 * Check extra constraints on a struct value_desc descriptor
 *
 * If a struct value_desc has a non-NULL extra pointer, it means that
 * there are a number of extra constraints to check or actions to
 * perform.  The extras is just an integer array where each integer
 * encode different constraints or actions.
 *
 * \param ctx current context
 * \param func name of calling glGet*v() function for error reporting
 * \param d the struct value_desc that has the extra constraints
 *
 * \return GL_FALSE if all of the constraints were not satisfied,
 *     otherwise GL_TRUE.
 */
static GLboolean
check_extra(struct gl_context *ctx, const char *func, const struct value_desc *d)
{
   const GLuint version = ctx->Version;
   GLboolean api_check = GL_FALSE;
   GLboolean api_found = GL_FALSE;
   const int *e;

   for (e = d->extra; *e != EXTRA_END; e++) {
      switch (*e) {
      case EXTRA_VERSION_30:
         api_check = GL_TRUE;
         if (version >= 30)
            api_found = GL_TRUE;
	 break;
      case EXTRA_VERSION_31:
         api_check = GL_TRUE;
         if (version >= 31)
            api_found = GL_TRUE;
	 break;
      case EXTRA_VERSION_32:
         api_check = GL_TRUE;
         if (version >= 32)
            api_found = GL_TRUE;
	 break;
      case EXTRA_NEW_FRAG_CLAMP:
         if (ctx->NewState & (_NEW_BUFFERS | _NEW_FRAG_CLAMP))
            _mesa_update_state(ctx);
         break;
      case EXTRA_API_ES2:
         api_check = GL_TRUE;
         if (ctx->API == API_OPENGLES2)
            api_found = GL_TRUE;
	 break;
      case EXTRA_API_ES3:
         api_check = GL_TRUE;
         if (_mesa_is_gles3(ctx))
            api_found = GL_TRUE;
	 break;
      case EXTRA_API_GL:
         api_check = GL_TRUE;
         if (_mesa_is_desktop_gl(ctx))
            api_found = GL_TRUE;
	 break;
      case EXTRA_API_GL_CORE:
         api_check = GL_TRUE;
         if (ctx->API == API_OPENGL_CORE)
            api_found = GL_TRUE;
	 break;
      case EXTRA_NEW_BUFFERS:
	 if (ctx->NewState & _NEW_BUFFERS)
	    _mesa_update_state(ctx);
	 break;
      case EXTRA_FLUSH_CURRENT:
	 FLUSH_CURRENT(ctx, 0);
	 break;
      case EXTRA_VALID_DRAW_BUFFER:
	 if (d->pname - GL_DRAW_BUFFER0_ARB >= ctx->Const.MaxDrawBuffers) {
	    _mesa_error(ctx, GL_INVALID_OPERATION, "%s(draw buffer %u)",
			func, d->pname - GL_DRAW_BUFFER0_ARB);
	    return GL_FALSE;
	 }
	 break;
      case EXTRA_VALID_TEXTURE_UNIT:
	 if (ctx->Texture.CurrentUnit >= ctx->Const.MaxTextureCoordUnits) {
	    _mesa_error(ctx, GL_INVALID_OPERATION, "%s(texture %u)",
			func, ctx->Texture.CurrentUnit);
	    return GL_FALSE;
	 }
	 break;
      case EXTRA_VALID_CLIP_DISTANCE:
	 if (d->pname - GL_CLIP_DISTANCE0 >= ctx->Const.MaxClipPlanes) {
	    _mesa_error(ctx, GL_INVALID_ENUM, "%s(clip distance %u)",
			func, d->pname - GL_CLIP_DISTANCE0);
	    return GL_FALSE;
	 }
	 break;
      case EXTRA_GLSL_130:
         api_check = GL_TRUE;
         if (ctx->Const.GLSLVersion >= 130)
            api_found = GL_TRUE;
	 break;
      case EXTRA_EXT_UBO_GS4:
         api_check = GL_TRUE;
         api_found = (ctx->Extensions.ARB_uniform_buffer_object &&
                      _mesa_has_geometry_shaders(ctx));
         break;
      case EXTRA_EXT_ATOMICS_GS4:
         api_check = GL_TRUE;
         api_found = (ctx->Extensions.ARB_shader_atomic_counters &&
                      _mesa_has_geometry_shaders(ctx));
         break;
      case EXTRA_EXT_SHADER_IMAGE_GS4:
         api_check = GL_TRUE;
         api_found = (ctx->Extensions.ARB_shader_image_load_store &&
                      _mesa_has_geometry_shaders(ctx));
         break;
      case EXTRA_END:
	 break;
      default: /* *e is a offset into the extension struct */
	 api_check = GL_TRUE;
	 if (*(GLboolean *) ((char *) &ctx->Extensions + *e))
	    api_found = GL_TRUE;
	 break;
      }
   }

   if (api_check && !api_found) {
      _mesa_error(ctx, GL_INVALID_ENUM, "%s(pname=%s)", func,
                  _mesa_lookup_enum_by_nr(d->pname));
      return GL_FALSE;
   }

   return GL_TRUE;
}

static const struct value_desc error_value =
   { 0, 0, TYPE_INVALID, NO_OFFSET, NO_EXTRA };

/**
 * Find the struct value_desc corresponding to the enum 'pname'.
 * 
 * We hash the enum value to get an index into the 'table' array,
 * which holds the index in the 'values' array of struct value_desc.
 * Once we've found the entry, we do the extra checks, if any, then
 * look up the value and return a pointer to it.
 *
 * If the value has to be computed (for example, it's the result of a
 * function call or we need to add 1 to it), we use the tmp 'v' to
 * store the result.
 * 
 * \param func name of glGet*v() func for error reporting
 * \param pname the enum value we're looking up
 * \param p is were we return the pointer to the value
 * \param v a tmp union value variable in the calling glGet*v() function
 *
 * \return the struct value_desc corresponding to the enum or a struct
 *     value_desc of TYPE_INVALID if not found.  This lets the calling
 *     glGet*v() function jump right into a switch statement and
 *     handle errors there instead of having to check for NULL.
 */
static const struct value_desc *
find_value(const char *func, GLenum pname, void **p, union value *v)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_texture_unit *unit;
   int mask, hash;
   const struct value_desc *d;
   int api;

   api = ctx->API;
   /* We index into the table_set[] list of per-API hash tables using the API's
    * value in the gl_api enum. Since GLES 3 doesn't have an API_OPENGL* enum
    * value since it's compatible with GLES2 its entry in table_set[] is at the
    * end.
    */
   STATIC_ASSERT(Elements(table_set) == API_OPENGL_LAST + 2);
   if (_mesa_is_gles3(ctx)) {
      api = API_OPENGL_LAST + 1;
   }
   mask = Elements(table(api)) - 1;
   hash = (pname * prime_factor);
   while (1) {
      int idx = table(api)[hash & mask];

      /* If the enum isn't valid, the hash walk ends with index 0,
       * pointing to the first entry of values[] which doesn't hold
       * any valid enum. */
      if (unlikely(idx == 0)) {
         _mesa_error(ctx, GL_INVALID_ENUM, "%s(pname=%s)", func,
               _mesa_lookup_enum_by_nr(pname));
         return &error_value;
      }

      d = &values[idx];
      if (likely(d->pname == pname))
         break;

      hash += prime_step;
   }

   if (unlikely(d->extra && !check_extra(ctx, func, d)))
      return &error_value;

   switch (d->location) {
   case LOC_BUFFER:
      *p = ((char *) ctx->DrawBuffer + d->offset);
      return d;
   case LOC_CONTEXT:
      *p = ((char *) ctx + d->offset);
      return d;
   case LOC_ARRAY:
      *p = ((char *) ctx->Array.VAO + d->offset);
      return d;
   case LOC_TEXUNIT:
      unit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
      *p = ((char *) unit + d->offset);
      return d;
   case LOC_CUSTOM:
      find_custom_value(ctx, d, v);
      *p = v;
      return d;
   default:
      assert(0);
      break;
   }

   /* silence warning */
   return &error_value;
}

static const int transpose[] = {
   0, 4,  8, 12,
   1, 5,  9, 13,
   2, 6, 10, 14,
   3, 7, 11, 15
};

void GLAPIENTRY
_mesa_GetBooleanv(GLenum pname, GLboolean *params)
{
   const struct value_desc *d;
   union value v;
   GLmatrix *m;
   int shift, i;
   void *p;

   d = find_value("glGetBooleanv", pname, &p, &v);
   switch (d->type) {
   case TYPE_INVALID:
      break;
   case TYPE_CONST:
      params[0] = INT_TO_BOOLEAN(d->offset);
      break;

   case TYPE_FLOAT_4:
   case TYPE_FLOATN_4:
      params[3] = FLOAT_TO_BOOLEAN(((GLfloat *) p)[3]);
   case TYPE_FLOAT_3:
   case TYPE_FLOATN_3:
      params[2] = FLOAT_TO_BOOLEAN(((GLfloat *) p)[2]);
   case TYPE_FLOAT_2:
   case TYPE_FLOATN_2:
      params[1] = FLOAT_TO_BOOLEAN(((GLfloat *) p)[1]);
   case TYPE_FLOAT:
   case TYPE_FLOATN:
      params[0] = FLOAT_TO_BOOLEAN(((GLfloat *) p)[0]);
      break;

   case TYPE_DOUBLEN_2:
      params[1] = FLOAT_TO_BOOLEAN(((GLdouble *) p)[1]);
   case TYPE_DOUBLEN:
      params[0] = FLOAT_TO_BOOLEAN(((GLdouble *) p)[0]);
      break;

   case TYPE_INT_4:
      params[3] = INT_TO_BOOLEAN(((GLint *) p)[3]);
   case TYPE_INT_3:
      params[2] = INT_TO_BOOLEAN(((GLint *) p)[2]);
   case TYPE_INT_2:
   case TYPE_ENUM_2:
      params[1] = INT_TO_BOOLEAN(((GLint *) p)[1]);
   case TYPE_INT:
   case TYPE_ENUM:
      params[0] = INT_TO_BOOLEAN(((GLint *) p)[0]);
      break;

   case TYPE_INT_N:
      for (i = 0; i < v.value_int_n.n; i++)
	 params[i] = INT_TO_BOOLEAN(v.value_int_n.ints[i]);
      break;

   case TYPE_INT64:
      params[0] = INT64_TO_BOOLEAN(((GLint64 *) p)[0]);
      break;

   case TYPE_BOOLEAN:
      params[0] = ((GLboolean*) p)[0];
      break;		

   case TYPE_MATRIX:
      m = *(GLmatrix **) p;
      for (i = 0; i < 16; i++)
	 params[i] = FLOAT_TO_BOOLEAN(m->m[i]);
      break;

   case TYPE_MATRIX_T:
      m = *(GLmatrix **) p;
      for (i = 0; i < 16; i++)
	 params[i] = FLOAT_TO_BOOLEAN(m->m[transpose[i]]);
      break;

   case TYPE_BIT_0:
   case TYPE_BIT_1:
   case TYPE_BIT_2:
   case TYPE_BIT_3:
   case TYPE_BIT_4:
   case TYPE_BIT_5:
   case TYPE_BIT_6:
   case TYPE_BIT_7:
      shift = d->type - TYPE_BIT_0;
      params[0] = (*(GLbitfield *) p >> shift) & 1;
      break;
   }
}

void GLAPIENTRY
_mesa_GetFloatv(GLenum pname, GLfloat *params)
{
   const struct value_desc *d;
   union value v;
   GLmatrix *m;
   int shift, i;
   void *p;

   d = find_value("glGetFloatv", pname, &p, &v);
   switch (d->type) {
   case TYPE_INVALID:
      break;
   case TYPE_CONST:
      params[0] = (GLfloat) d->offset;
      break;

   case TYPE_FLOAT_4:
   case TYPE_FLOATN_4:
      params[3] = ((GLfloat *) p)[3];
   case TYPE_FLOAT_3:
   case TYPE_FLOATN_3:
      params[2] = ((GLfloat *) p)[2];
   case TYPE_FLOAT_2:
   case TYPE_FLOATN_2:
      params[1] = ((GLfloat *) p)[1];
   case TYPE_FLOAT:
   case TYPE_FLOATN:
      params[0] = ((GLfloat *) p)[0];
      break;

   case TYPE_DOUBLEN_2:
      params[1] = (GLfloat) (((GLdouble *) p)[1]);
   case TYPE_DOUBLEN:
      params[0] = (GLfloat) (((GLdouble *) p)[0]);
      break;

   case TYPE_INT_4:
      params[3] = (GLfloat) (((GLint *) p)[3]);
   case TYPE_INT_3:
      params[2] = (GLfloat) (((GLint *) p)[2]);
   case TYPE_INT_2:
   case TYPE_ENUM_2:
      params[1] = (GLfloat) (((GLint *) p)[1]);
   case TYPE_INT:
   case TYPE_ENUM:
      params[0] = (GLfloat) (((GLint *) p)[0]);
      break;

   case TYPE_INT_N:
      for (i = 0; i < v.value_int_n.n; i++)
	 params[i] = INT_TO_FLOAT(v.value_int_n.ints[i]);
      break;

   case TYPE_INT64:
      params[0] = (GLfloat) (((GLint64 *) p)[0]);
      break;

   case TYPE_BOOLEAN:
      params[0] = BOOLEAN_TO_FLOAT(*(GLboolean*) p);
      break;		

   case TYPE_MATRIX:
      m = *(GLmatrix **) p;
      for (i = 0; i < 16; i++)
	 params[i] = m->m[i];
      break;

   case TYPE_MATRIX_T:
      m = *(GLmatrix **) p;
      for (i = 0; i < 16; i++)
	 params[i] = m->m[transpose[i]];
      break;

   case TYPE_BIT_0:
   case TYPE_BIT_1:
   case TYPE_BIT_2:
   case TYPE_BIT_3:
   case TYPE_BIT_4:
   case TYPE_BIT_5:
   case TYPE_BIT_6:
   case TYPE_BIT_7:
      shift = d->type - TYPE_BIT_0;
      params[0] = BOOLEAN_TO_FLOAT((*(GLbitfield *) p >> shift) & 1);
      break;
   }
}

void GLAPIENTRY
_mesa_GetIntegerv(GLenum pname, GLint *params)
{
   const struct value_desc *d;
   union value v;
   GLmatrix *m;
   int shift, i;
   void *p;

   d = find_value("glGetIntegerv", pname, &p, &v);
   switch (d->type) {
   case TYPE_INVALID:
      break;
   case TYPE_CONST:
      params[0] = d->offset;
      break;

   case TYPE_FLOAT_4:
      params[3] = IROUND(((GLfloat *) p)[3]);
   case TYPE_FLOAT_3:
      params[2] = IROUND(((GLfloat *) p)[2]);
   case TYPE_FLOAT_2:
      params[1] = IROUND(((GLfloat *) p)[1]);
   case TYPE_FLOAT:
      params[0] = IROUND(((GLfloat *) p)[0]);
      break;

   case TYPE_FLOATN_4:
      params[3] = FLOAT_TO_INT(((GLfloat *) p)[3]);
   case TYPE_FLOATN_3:
      params[2] = FLOAT_TO_INT(((GLfloat *) p)[2]);
   case TYPE_FLOATN_2:
      params[1] = FLOAT_TO_INT(((GLfloat *) p)[1]);
   case TYPE_FLOATN:
      params[0] = FLOAT_TO_INT(((GLfloat *) p)[0]);
      break;

   case TYPE_DOUBLEN_2:
      params[1] = FLOAT_TO_INT(((GLdouble *) p)[1]);
   case TYPE_DOUBLEN:
      params[0] = FLOAT_TO_INT(((GLdouble *) p)[0]);
      break;

   case TYPE_INT_4:
      params[3] = ((GLint *) p)[3];
   case TYPE_INT_3:
      params[2] = ((GLint *) p)[2];
   case TYPE_INT_2:
   case TYPE_ENUM_2:
      params[1] = ((GLint *) p)[1];
   case TYPE_INT:
   case TYPE_ENUM:
      params[0] = ((GLint *) p)[0];
      break;

   case TYPE_INT_N:
      for (i = 0; i < v.value_int_n.n; i++)
	 params[i] = v.value_int_n.ints[i];
      break;

   case TYPE_INT64:
      params[0] = INT64_TO_INT(((GLint64 *) p)[0]);
      break;

   case TYPE_BOOLEAN:
      params[0] = BOOLEAN_TO_INT(*(GLboolean*) p);
      break;		

   case TYPE_MATRIX:
      m = *(GLmatrix **) p;
      for (i = 0; i < 16; i++)
	 params[i] = FLOAT_TO_INT(m->m[i]);
      break;

   case TYPE_MATRIX_T:
      m = *(GLmatrix **) p;
      for (i = 0; i < 16; i++)
	 params[i] = FLOAT_TO_INT(m->m[transpose[i]]);
      break;

   case TYPE_BIT_0:
   case TYPE_BIT_1:
   case TYPE_BIT_2:
   case TYPE_BIT_3:
   case TYPE_BIT_4:
   case TYPE_BIT_5:
   case TYPE_BIT_6:
   case TYPE_BIT_7:
      shift = d->type - TYPE_BIT_0;
      params[0] = (*(GLbitfield *) p >> shift) & 1;
      break;
   }
}

void GLAPIENTRY
_mesa_GetInteger64v(GLenum pname, GLint64 *params)
{
   const struct value_desc *d;
   union value v;
   GLmatrix *m;
   int shift, i;
   void *p;

   d = find_value("glGetInteger64v", pname, &p, &v);
   switch (d->type) {
   case TYPE_INVALID:
      break;
   case TYPE_CONST:
      params[0] = d->offset;
      break;

   case TYPE_FLOAT_4:
      params[3] = IROUND64(((GLfloat *) p)[3]);
   case TYPE_FLOAT_3:
      params[2] = IROUND64(((GLfloat *) p)[2]);
   case TYPE_FLOAT_2:
      params[1] = IROUND64(((GLfloat *) p)[1]);
   case TYPE_FLOAT:
      params[0] = IROUND64(((GLfloat *) p)[0]);
      break;

   case TYPE_FLOATN_4:
      params[3] = FLOAT_TO_INT64(((GLfloat *) p)[3]);
   case TYPE_FLOATN_3:
      params[2] = FLOAT_TO_INT64(((GLfloat *) p)[2]);
   case TYPE_FLOATN_2:
      params[1] = FLOAT_TO_INT64(((GLfloat *) p)[1]);
   case TYPE_FLOATN:
      params[0] = FLOAT_TO_INT64(((GLfloat *) p)[0]);
      break;

   case TYPE_DOUBLEN_2:
      params[1] = FLOAT_TO_INT64(((GLdouble *) p)[1]);
   case TYPE_DOUBLEN:
      params[0] = FLOAT_TO_INT64(((GLdouble *) p)[0]);
      break;

   case TYPE_INT_4:
      params[3] = ((GLint *) p)[3];
   case TYPE_INT_3:
      params[2] = ((GLint *) p)[2];
   case TYPE_INT_2:
   case TYPE_ENUM_2:
      params[1] = ((GLint *) p)[1];
   case TYPE_INT:
   case TYPE_ENUM:
      params[0] = ((GLint *) p)[0];
      break;

   case TYPE_INT_N:
      for (i = 0; i < v.value_int_n.n; i++)
	 params[i] = INT_TO_BOOLEAN(v.value_int_n.ints[i]);
      break;

   case TYPE_INT64:
      params[0] = ((GLint64 *) p)[0];
      break;

   case TYPE_BOOLEAN:
      params[0] = ((GLboolean*) p)[0];
      break;		

   case TYPE_MATRIX:
      m = *(GLmatrix **) p;
      for (i = 0; i < 16; i++)
	 params[i] = FLOAT_TO_INT64(m->m[i]);
      break;

   case TYPE_MATRIX_T:
      m = *(GLmatrix **) p;
      for (i = 0; i < 16; i++)
	 params[i] = FLOAT_TO_INT64(m->m[transpose[i]]);
      break;

   case TYPE_BIT_0:
   case TYPE_BIT_1:
   case TYPE_BIT_2:
   case TYPE_BIT_3:
   case TYPE_BIT_4:
   case TYPE_BIT_5:
   case TYPE_BIT_6:
   case TYPE_BIT_7:
      shift = d->type - TYPE_BIT_0;
      params[0] = (*(GLbitfield *) p >> shift) & 1;
      break;
   }
}

void GLAPIENTRY
_mesa_GetDoublev(GLenum pname, GLdouble *params)
{
   const struct value_desc *d;
   union value v;
   GLmatrix *m;
   int shift, i;
   void *p;

   d = find_value("glGetDoublev", pname, &p, &v);
   switch (d->type) {
   case TYPE_INVALID:
      break;
   case TYPE_CONST:
      params[0] = d->offset;
      break;

   case TYPE_FLOAT_4:
   case TYPE_FLOATN_4:
      params[3] = ((GLfloat *) p)[3];
   case TYPE_FLOAT_3:
   case TYPE_FLOATN_3:
      params[2] = ((GLfloat *) p)[2];
   case TYPE_FLOAT_2:
   case TYPE_FLOATN_2:
      params[1] = ((GLfloat *) p)[1];
   case TYPE_FLOAT:
   case TYPE_FLOATN:
      params[0] = ((GLfloat *) p)[0];
      break;

   case TYPE_DOUBLEN_2:
      params[1] = ((GLdouble *) p)[1];
   case TYPE_DOUBLEN:
      params[0] = ((GLdouble *) p)[0];
      break;

   case TYPE_INT_4:
      params[3] = ((GLint *) p)[3];
   case TYPE_INT_3:
      params[2] = ((GLint *) p)[2];
   case TYPE_INT_2:
   case TYPE_ENUM_2:
      params[1] = ((GLint *) p)[1];
   case TYPE_INT:
   case TYPE_ENUM:
      params[0] = ((GLint *) p)[0];
      break;

   case TYPE_INT_N:
      for (i = 0; i < v.value_int_n.n; i++)
	 params[i] = v.value_int_n.ints[i];
      break;

   case TYPE_INT64:
      params[0] = (GLdouble) (((GLint64 *) p)[0]);
      break;

   case TYPE_BOOLEAN:
      params[0] = *(GLboolean*) p;
      break;		

   case TYPE_MATRIX:
      m = *(GLmatrix **) p;
      for (i = 0; i < 16; i++)
	 params[i] = m->m[i];
      break;

   case TYPE_MATRIX_T:
      m = *(GLmatrix **) p;
      for (i = 0; i < 16; i++)
	 params[i] = m->m[transpose[i]];
      break;

   case TYPE_BIT_0:
   case TYPE_BIT_1:
   case TYPE_BIT_2:
   case TYPE_BIT_3:
   case TYPE_BIT_4:
   case TYPE_BIT_5:
   case TYPE_BIT_6:
   case TYPE_BIT_7:
      shift = d->type - TYPE_BIT_0;
      params[0] = (*(GLbitfield *) p >> shift) & 1;
      break;
   }
}

static enum value_type
find_value_indexed(const char *func, GLenum pname, GLuint index, union value *v)
{
   GET_CURRENT_CONTEXT(ctx);

   switch (pname) {

   case GL_BLEND:
      if (index >= ctx->Const.MaxDrawBuffers)
	 goto invalid_value;
      if (!ctx->Extensions.EXT_draw_buffers2)
	 goto invalid_enum;
      v->value_int = (ctx->Color.BlendEnabled >> index) & 1;
      return TYPE_INT;

   case GL_BLEND_SRC:
      /* fall-through */
   case GL_BLEND_SRC_RGB:
      if (index >= ctx->Const.MaxDrawBuffers)
	 goto invalid_value;
      if (!ctx->Extensions.ARB_draw_buffers_blend)
	 goto invalid_enum;
      v->value_int = ctx->Color.Blend[index].SrcRGB;
      return TYPE_INT;
   case GL_BLEND_SRC_ALPHA:
      if (index >= ctx->Const.MaxDrawBuffers)
	 goto invalid_value;
      if (!ctx->Extensions.ARB_draw_buffers_blend)
	 goto invalid_enum;
      v->value_int = ctx->Color.Blend[index].SrcA;
      return TYPE_INT;
   case GL_BLEND_DST:
      /* fall-through */
   case GL_BLEND_DST_RGB:
      if (index >= ctx->Const.MaxDrawBuffers)
	 goto invalid_value;
      if (!ctx->Extensions.ARB_draw_buffers_blend)
	 goto invalid_enum;
      v->value_int = ctx->Color.Blend[index].DstRGB;
      return TYPE_INT;
   case GL_BLEND_DST_ALPHA:
      if (index >= ctx->Const.MaxDrawBuffers)
	 goto invalid_value;
      if (!ctx->Extensions.ARB_draw_buffers_blend)
	 goto invalid_enum;
      v->value_int = ctx->Color.Blend[index].DstA;
      return TYPE_INT;
   case GL_BLEND_EQUATION_RGB:
      if (index >= ctx->Const.MaxDrawBuffers)
	 goto invalid_value;
      if (!ctx->Extensions.ARB_draw_buffers_blend)
	 goto invalid_enum;
      v->value_int = ctx->Color.Blend[index].EquationRGB;
      return TYPE_INT;
   case GL_BLEND_EQUATION_ALPHA:
      if (index >= ctx->Const.MaxDrawBuffers)
	 goto invalid_value;
      if (!ctx->Extensions.ARB_draw_buffers_blend)
	 goto invalid_enum;
      v->value_int = ctx->Color.Blend[index].EquationA;
      return TYPE_INT;

   case GL_COLOR_WRITEMASK:
      if (index >= ctx->Const.MaxDrawBuffers)
	 goto invalid_value;
      if (!ctx->Extensions.EXT_draw_buffers2)
	 goto invalid_enum;
      v->value_int_4[0] = ctx->Color.ColorMask[index][RCOMP] ? 1 : 0;
      v->value_int_4[1] = ctx->Color.ColorMask[index][GCOMP] ? 1 : 0;
      v->value_int_4[2] = ctx->Color.ColorMask[index][BCOMP] ? 1 : 0;
      v->value_int_4[3] = ctx->Color.ColorMask[index][ACOMP] ? 1 : 0;
      return TYPE_INT_4;

   case GL_SCISSOR_BOX:
      if (index >= ctx->Const.MaxViewports)
         goto invalid_value;
      v->value_int_4[0] = ctx->Scissor.ScissorArray[index].X;
      v->value_int_4[1] = ctx->Scissor.ScissorArray[index].Y;
      v->value_int_4[2] = ctx->Scissor.ScissorArray[index].Width;
      v->value_int_4[3] = ctx->Scissor.ScissorArray[index].Height;
      return TYPE_INT_4;

   case GL_VIEWPORT:
      if (index >= ctx->Const.MaxViewports)
         goto invalid_value;
      v->value_float_4[0] = ctx->ViewportArray[index].X;
      v->value_float_4[1] = ctx->ViewportArray[index].Y;
      v->value_float_4[2] = ctx->ViewportArray[index].Width;
      v->value_float_4[3] = ctx->ViewportArray[index].Height;
      return TYPE_FLOAT_4;

   case GL_DEPTH_RANGE:
      if (index >= ctx->Const.MaxViewports)
         goto invalid_value;
      v->value_double_2[0] = ctx->ViewportArray[index].Near;
      v->value_double_2[1] = ctx->ViewportArray[index].Far;
      return TYPE_DOUBLEN_2;

   case GL_TRANSFORM_FEEDBACK_BUFFER_START:
      if (index >= ctx->Const.MaxTransformFeedbackBuffers)
	 goto invalid_value;
      if (!ctx->Extensions.EXT_transform_feedback)
	 goto invalid_enum;
      v->value_int64 = ctx->TransformFeedback.CurrentObject->Offset[index];
      return TYPE_INT64;

   case GL_TRANSFORM_FEEDBACK_BUFFER_SIZE:
      if (index >= ctx->Const.MaxTransformFeedbackBuffers)
	 goto invalid_value;
      if (!ctx->Extensions.EXT_transform_feedback)
	 goto invalid_enum;
      v->value_int64
         = ctx->TransformFeedback.CurrentObject->RequestedSize[index];
      return TYPE_INT64;

   case GL_TRANSFORM_FEEDBACK_BUFFER_BINDING:
      if (index >= ctx->Const.MaxTransformFeedbackBuffers)
	 goto invalid_value;
      if (!ctx->Extensions.EXT_transform_feedback)
	 goto invalid_enum;
      v->value_int = ctx->TransformFeedback.CurrentObject->BufferNames[index];
      return TYPE_INT;

   case GL_UNIFORM_BUFFER_BINDING:
      if (index >= ctx->Const.MaxUniformBufferBindings)
	 goto invalid_value;
      if (!ctx->Extensions.ARB_uniform_buffer_object)
	 goto invalid_enum;
      v->value_int = ctx->UniformBufferBindings[index].BufferObject->Name;
      return TYPE_INT;

   case GL_UNIFORM_BUFFER_START:
      if (index >= ctx->Const.MaxUniformBufferBindings)
	 goto invalid_value;
      if (!ctx->Extensions.ARB_uniform_buffer_object)
	 goto invalid_enum;
      v->value_int = ctx->UniformBufferBindings[index].Offset;
      return TYPE_INT;

   case GL_UNIFORM_BUFFER_SIZE:
      if (index >= ctx->Const.MaxUniformBufferBindings)
	 goto invalid_value;
      if (!ctx->Extensions.ARB_uniform_buffer_object)
	 goto invalid_enum;
      v->value_int = ctx->UniformBufferBindings[index].Size;
      return TYPE_INT;

   /* ARB_texture_multisample / GL3.2 */
   case GL_SAMPLE_MASK_VALUE:
      if (index != 0)
         goto invalid_value;
      if (!ctx->Extensions.ARB_texture_multisample)
         goto invalid_enum;
      v->value_int = ctx->Multisample.SampleMaskValue;
      return TYPE_INT;

   case GL_ATOMIC_COUNTER_BUFFER_BINDING:
      if (!ctx->Extensions.ARB_shader_atomic_counters)
         goto invalid_enum;
      if (index >= ctx->Const.MaxAtomicBufferBindings)
         goto invalid_value;
      v->value_int = ctx->AtomicBufferBindings[index].BufferObject->Name;
      return TYPE_INT;

   case GL_ATOMIC_COUNTER_BUFFER_START:
      if (!ctx->Extensions.ARB_shader_atomic_counters)
         goto invalid_enum;
      if (index >= ctx->Const.MaxAtomicBufferBindings)
         goto invalid_value;
      v->value_int64 = ctx->AtomicBufferBindings[index].Offset;
      return TYPE_INT64;

   case GL_ATOMIC_COUNTER_BUFFER_SIZE:
      if (!ctx->Extensions.ARB_shader_atomic_counters)
         goto invalid_enum;
      if (index >= ctx->Const.MaxAtomicBufferBindings)
         goto invalid_value;
      v->value_int64 = ctx->AtomicBufferBindings[index].Size;
      return TYPE_INT64;

   case GL_VERTEX_BINDING_DIVISOR:
      if (!_mesa_is_desktop_gl(ctx) || !ctx->Extensions.ARB_instanced_arrays)
          goto invalid_enum;
      if (index >= ctx->Const.Program[MESA_SHADER_VERTEX].MaxAttribs)
          goto invalid_value;
      v->value_int = ctx->Array.VAO->VertexBinding[VERT_ATTRIB_GENERIC(index)].InstanceDivisor;
      return TYPE_INT;

   case GL_VERTEX_BINDING_OFFSET:
      if (!_mesa_is_desktop_gl(ctx))
          goto invalid_enum;
      if (index >= ctx->Const.Program[MESA_SHADER_VERTEX].MaxAttribs)
          goto invalid_value;
      v->value_int = ctx->Array.VAO->VertexBinding[VERT_ATTRIB_GENERIC(index)].Offset;
      return TYPE_INT;

   case GL_VERTEX_BINDING_STRIDE:
      if (!_mesa_is_desktop_gl(ctx))
          goto invalid_enum;
      if (index >= ctx->Const.Program[MESA_SHADER_VERTEX].MaxAttribs)
          goto invalid_value;
      v->value_int = ctx->Array.VAO->VertexBinding[VERT_ATTRIB_GENERIC(index)].Stride;

   /* ARB_shader_image_load_store */
   case GL_IMAGE_BINDING_NAME: {
      struct gl_texture_object *t;

      if (!ctx->Extensions.ARB_shader_image_load_store)
         goto invalid_enum;
      if (index >= ctx->Const.MaxImageUnits)
         goto invalid_value;

      t = ctx->ImageUnits[index].TexObj;
      v->value_int = (t ? t->Name : 0);
      return TYPE_INT;
   }

   case GL_IMAGE_BINDING_LEVEL:
      if (!ctx->Extensions.ARB_shader_image_load_store)
         goto invalid_enum;
      if (index >= ctx->Const.MaxImageUnits)
         goto invalid_value;

      v->value_int = ctx->ImageUnits[index].Level;
      return TYPE_INT;

   case GL_IMAGE_BINDING_LAYERED:
      if (!ctx->Extensions.ARB_shader_image_load_store)
         goto invalid_enum;
      if (index >= ctx->Const.MaxImageUnits)
         goto invalid_value;

      v->value_int = ctx->ImageUnits[index].Layered;
      return TYPE_INT;

   case GL_IMAGE_BINDING_LAYER:
      if (!ctx->Extensions.ARB_shader_image_load_store)
         goto invalid_enum;
      if (index >= ctx->Const.MaxImageUnits)
         goto invalid_value;

      v->value_int = ctx->ImageUnits[index].Layer;
      return TYPE_INT;

   case GL_IMAGE_BINDING_ACCESS:
      if (!ctx->Extensions.ARB_shader_image_load_store)
         goto invalid_enum;
      if (index >= ctx->Const.MaxImageUnits)
         goto invalid_value;

      v->value_int = ctx->ImageUnits[index].Access;
      return TYPE_INT;

   case GL_IMAGE_BINDING_FORMAT:
      if (!ctx->Extensions.ARB_shader_image_load_store)
         goto invalid_enum;
      if (index >= ctx->Const.MaxImageUnits)
         goto invalid_value;

      v->value_int = ctx->ImageUnits[index].Format;
      return TYPE_INT;

   case GL_MAX_COMPUTE_WORK_GROUP_COUNT:
      if (!_mesa_is_desktop_gl(ctx) || !ctx->Extensions.ARB_compute_shader)
         goto invalid_enum;
      if (index >= 3)
         goto invalid_value;
      v->value_int = ctx->Const.MaxComputeWorkGroupCount[index];
      return TYPE_INT;

   case GL_MAX_COMPUTE_WORK_GROUP_SIZE:
      if (!_mesa_is_desktop_gl(ctx) || !ctx->Extensions.ARB_compute_shader)
         goto invalid_enum;
      if (index >= 3)
         goto invalid_value;
      v->value_int = ctx->Const.MaxComputeWorkGroupSize[index];
      return TYPE_INT;
   }

 invalid_enum:
   _mesa_error(ctx, GL_INVALID_ENUM, "%s(pname=%s)", func,
               _mesa_lookup_enum_by_nr(pname));
   return TYPE_INVALID;
 invalid_value:
   _mesa_error(ctx, GL_INVALID_VALUE, "%s(pname=%s)", func,
               _mesa_lookup_enum_by_nr(pname));
   return TYPE_INVALID;
}

void GLAPIENTRY
_mesa_GetBooleani_v( GLenum pname, GLuint index, GLboolean *params )
{
   union value v;
   enum value_type type =
      find_value_indexed("glGetBooleani_v", pname, index, &v);

   switch (type) {
   case TYPE_INT:
      params[0] = INT_TO_BOOLEAN(v.value_int);
      break;
   case TYPE_INT_4:
      params[0] = INT_TO_BOOLEAN(v.value_int_4[0]);
      params[1] = INT_TO_BOOLEAN(v.value_int_4[1]);
      params[2] = INT_TO_BOOLEAN(v.value_int_4[2]);
      params[3] = INT_TO_BOOLEAN(v.value_int_4[3]);
      break;
   case TYPE_INT64:
      params[0] = INT64_TO_BOOLEAN(v.value_int64);
      break;
   default:
      ; /* nothing - GL error was recorded */
   }
}

void GLAPIENTRY
_mesa_GetIntegeri_v( GLenum pname, GLuint index, GLint *params )
{
   union value v;
   enum value_type type =
      find_value_indexed("glGetIntegeri_v", pname, index, &v);

   switch (type) {
   case TYPE_FLOAT_4:
   case TYPE_FLOATN_4:
      params[3] = IROUND(v.value_float_4[3]);
   case TYPE_FLOAT_3:
   case TYPE_FLOATN_3:
      params[2] = IROUND(v.value_float_4[2]);
   case TYPE_FLOAT_2:
   case TYPE_FLOATN_2:
      params[1] = IROUND(v.value_float_4[1]);
   case TYPE_FLOAT:
   case TYPE_FLOATN:
      params[0] = IROUND(v.value_float_4[0]);
      break;

   case TYPE_DOUBLEN_2:
      params[1] = IROUND(v.value_double_2[1]);
   case TYPE_DOUBLEN:
      params[0] = IROUND(v.value_double_2[0]);
      break;

   case TYPE_INT:
      params[0] = v.value_int;
      break;
   case TYPE_INT_4:
      params[0] = v.value_int_4[0];
      params[1] = v.value_int_4[1];
      params[2] = v.value_int_4[2];
      params[3] = v.value_int_4[3];
      break;
   case TYPE_INT64:
      params[0] = INT64_TO_INT(v.value_int64);
      break;
   default:
      ; /* nothing - GL error was recorded */
   }
}

void GLAPIENTRY
_mesa_GetInteger64i_v( GLenum pname, GLuint index, GLint64 *params )
{
   union value v;
   enum value_type type =
      find_value_indexed("glGetInteger64i_v", pname, index, &v);

   switch (type) {
   case TYPE_INT:
      params[0] = v.value_int;
      break;
   case TYPE_INT_4:
      params[0] = v.value_int_4[0];
      params[1] = v.value_int_4[1];
      params[2] = v.value_int_4[2];
      params[3] = v.value_int_4[3];
      break;
   case TYPE_INT64:
      params[0] = v.value_int64;
      break;
   default:
      ; /* nothing - GL error was recorded */
   }
}

void GLAPIENTRY
_mesa_GetFloati_v(GLenum pname, GLuint index, GLfloat *params)
{
   int i;
   GLmatrix *m;
   union value v;
   enum value_type type =
      find_value_indexed("glGetFloati_v", pname, index, &v);

   switch (type) {
   case TYPE_FLOAT_4:
   case TYPE_FLOATN_4:
      params[3] = v.value_float_4[3];
   case TYPE_FLOAT_3:
   case TYPE_FLOATN_3:
      params[2] = v.value_float_4[2];
   case TYPE_FLOAT_2:
   case TYPE_FLOATN_2:
      params[1] = v.value_float_4[1];
   case TYPE_FLOAT:
   case TYPE_FLOATN:
      params[0] = v.value_float_4[0];
      break;

   case TYPE_DOUBLEN_2:
      params[1] = (GLfloat) v.value_double_2[1];
   case TYPE_DOUBLEN:
      params[0] = (GLfloat) v.value_double_2[0];
      break;

   case TYPE_INT_4:
      params[3] = (GLfloat) v.value_int_4[3];
   case TYPE_INT_3:
      params[2] = (GLfloat) v.value_int_4[2];
   case TYPE_INT_2:
   case TYPE_ENUM_2:
      params[1] = (GLfloat) v.value_int_4[1];
   case TYPE_INT:
   case TYPE_ENUM:
      params[0] = (GLfloat) v.value_int_4[0];
      break;

   case TYPE_INT_N:
      for (i = 0; i < v.value_int_n.n; i++)
	 params[i] = INT_TO_FLOAT(v.value_int_n.ints[i]);
      break;

   case TYPE_INT64:
      params[0] = (GLfloat) v.value_int64;
      break;

   case TYPE_BOOLEAN:
      params[0] = BOOLEAN_TO_FLOAT(v.value_bool);
      break;

   case TYPE_MATRIX:
      m = *(GLmatrix **) &v;
      for (i = 0; i < 16; i++)
	 params[i] = m->m[i];
      break;

   case TYPE_MATRIX_T:
      m = *(GLmatrix **) &v;
      for (i = 0; i < 16; i++)
	 params[i] = m->m[transpose[i]];
      break;

   default:
      ;
   }
}

void GLAPIENTRY
_mesa_GetDoublei_v(GLenum pname, GLuint index, GLdouble *params)
{
   int i;
   GLmatrix *m;
   union value v;
   enum value_type type =
      find_value_indexed("glGetDoublei_v", pname, index, &v);

   switch (type) {
   case TYPE_FLOAT_4:
   case TYPE_FLOATN_4:
      params[3] = (GLdouble) v.value_float_4[3];
   case TYPE_FLOAT_3:
   case TYPE_FLOATN_3:
      params[2] = (GLdouble) v.value_float_4[2];
   case TYPE_FLOAT_2:
   case TYPE_FLOATN_2:
      params[1] = (GLdouble) v.value_float_4[1];
   case TYPE_FLOAT:
   case TYPE_FLOATN:
      params[0] = (GLdouble) v.value_float_4[0];
      break;

   case TYPE_DOUBLEN_2:
      params[1] = v.value_double_2[1];
   case TYPE_DOUBLEN:
      params[0] = v.value_double_2[0];
      break;

   case TYPE_INT_4:
      params[3] = (GLdouble) v.value_int_4[3];
   case TYPE_INT_3:
      params[2] = (GLdouble) v.value_int_4[2];
   case TYPE_INT_2:
   case TYPE_ENUM_2:
      params[1] = (GLdouble) v.value_int_4[1];
   case TYPE_INT:
   case TYPE_ENUM:
      params[0] = (GLdouble) v.value_int_4[0];
      break;

   case TYPE_INT_N:
      for (i = 0; i < v.value_int_n.n; i++)
	 params[i] = (GLdouble) INT_TO_FLOAT(v.value_int_n.ints[i]);
      break;

   case TYPE_INT64:
      params[0] = (GLdouble) v.value_int64;
      break;

   case TYPE_BOOLEAN:
      params[0] = (GLdouble) BOOLEAN_TO_FLOAT(v.value_bool);
      break;

   case TYPE_MATRIX:
      m = *(GLmatrix **) &v;
      for (i = 0; i < 16; i++)
	 params[i] = (GLdouble) m->m[i];
      break;

   case TYPE_MATRIX_T:
      m = *(GLmatrix **) &v;
      for (i = 0; i < 16; i++)
	 params[i] = (GLdouble) m->m[transpose[i]];
      break;

   default:
      ;
   }
}

void GLAPIENTRY
_mesa_GetFixedv(GLenum pname, GLfixed *params)
{
   const struct value_desc *d;
   union value v;
   GLmatrix *m;
   int shift, i;
   void *p;

   d = find_value("glGetDoublev", pname, &p, &v);
   switch (d->type) {
   case TYPE_INVALID:
      break;
   case TYPE_CONST:
      params[0] = INT_TO_FIXED(d->offset);
      break;

   case TYPE_FLOAT_4:
   case TYPE_FLOATN_4:
      params[3] = FLOAT_TO_FIXED(((GLfloat *) p)[3]);
   case TYPE_FLOAT_3:
   case TYPE_FLOATN_3:
      params[2] = FLOAT_TO_FIXED(((GLfloat *) p)[2]);
   case TYPE_FLOAT_2:
   case TYPE_FLOATN_2:
      params[1] = FLOAT_TO_FIXED(((GLfloat *) p)[1]);
   case TYPE_FLOAT:
   case TYPE_FLOATN:
      params[0] = FLOAT_TO_FIXED(((GLfloat *) p)[0]);
      break;

   case TYPE_DOUBLEN_2:
      params[1] = FLOAT_TO_FIXED(((GLdouble *) p)[1]);
   case TYPE_DOUBLEN:
      params[0] = FLOAT_TO_FIXED(((GLdouble *) p)[0]);
      break;

   case TYPE_INT_4:
      params[3] = INT_TO_FIXED(((GLint *) p)[3]);
   case TYPE_INT_3:
      params[2] = INT_TO_FIXED(((GLint *) p)[2]);
   case TYPE_INT_2:
   case TYPE_ENUM_2:
      params[1] = INT_TO_FIXED(((GLint *) p)[1]);
   case TYPE_INT:
   case TYPE_ENUM:
      params[0] = INT_TO_FIXED(((GLint *) p)[0]);
      break;

   case TYPE_INT_N:
      for (i = 0; i < v.value_int_n.n; i++)
	 params[i] = INT_TO_FIXED(v.value_int_n.ints[i]);
      break;

   case TYPE_INT64:
      params[0] = ((GLint64 *) p)[0];
      break;

   case TYPE_BOOLEAN:
      params[0] = BOOLEAN_TO_FIXED(((GLboolean*) p)[0]);
      break;		

   case TYPE_MATRIX:
      m = *(GLmatrix **) p;
      for (i = 0; i < 16; i++)
	 params[i] = FLOAT_TO_FIXED(m->m[i]);
      break;

   case TYPE_MATRIX_T:
      m = *(GLmatrix **) p;
      for (i = 0; i < 16; i++)
	 params[i] = FLOAT_TO_FIXED(m->m[transpose[i]]);
      break;

   case TYPE_BIT_0:
   case TYPE_BIT_1:
   case TYPE_BIT_2:
   case TYPE_BIT_3:
   case TYPE_BIT_4:
   case TYPE_BIT_5:
   case TYPE_BIT_6:
   case TYPE_BIT_7:
      shift = d->type - TYPE_BIT_0;
      params[0] = BOOLEAN_TO_FIXED((*(GLbitfield *) p >> shift) & 1);
      break;
   }
}
@


1.12
log
@Merge Mesa 10.2.9
@
text
@@


1.11
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d281 5
a397 2
EXTRA_EXT(ARB_explicit_uniform_location);
EXTRA_EXT(ARB_clip_control);
@


1.10
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@a280 5
static const int extra_EXT_texture_integer[] = {
   EXT(EXT_texture_integer),
   EXTRA_END
};

d393 2
@


1.9
log
@Merge Mesa 9.2.1
@
text
@d31 1
d117 1
d136 1
d149 2
d167 1
d186 1
a186 1
   LOC_ARRAY, type, offsetof(struct gl_array_object, field)
d334 8
a341 2
static const int extra_MESA_texture_array_es3[] = {
   EXT(MESA_texture_array),
d346 10
d357 1
a357 1
EXTRA_EXT(MESA_texture_array);
a365 1
EXTRA_EXT(EXT_framebuffer_blit);
a385 1
EXTRA_EXT(ARB_map_buffer_alignment);
d389 9
d415 1
d429 12
d547 3
a549 1
   print_table_stats();
d573 1
a573 1
   struct gl_client_array *array;
a586 2
   case GL_TEXTURE_1D_ARRAY_EXT:
   case GL_TEXTURE_2D_ARRAY_EXT:
d650 1
a650 1
      array = &ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_TEX(ctx->Array.ActiveTexture)];
d674 8
a681 4
      v->value_int_4[0] = ctx->Scissor.X;
      v->value_int_4[1] = ctx->Scissor.Y;
      v->value_int_4[2] = ctx->Scissor.Width;
      v->value_int_4[3] = ctx->Scissor.Height;
d698 9
a706 4
      v->value_int_4[0] = ctx->Viewport.X;
      v->value_int_4[1] = ctx->Viewport.Y;
      v->value_int_4[2] = ctx->Viewport.Width;
      v->value_int_4[3] = ctx->Viewport.Height;
d763 1
a763 1
      ASSERT(v->value_int_n.n <= 100);
a766 2
   case GL_MAX_FRAGMENT_INPUT_COMPONENTS:
   case GL_MAX_VERTEX_OUTPUT_COMPONENTS:
d788 39
d836 1
a836 1
	 ((char *) ctx->Array.ArrayObj + d->offset);
d844 1
a844 1
	 ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_TEX(ctx->Array.ActiveTexture)].BufferObj->Name;
d847 11
a857 1
      v->value_int = ctx->Array.ArrayObj->ElementArrayBufferObj->Name;
d887 12
d910 1
a910 1
      v->value_int = ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_POINT_SIZE].BufferObj->Name;
d941 1
a941 1
      v->value_int = ctx->Const.VertexProgram.MaxUniformComponents / 4;
d945 1
a945 1
      v->value_int = ctx->Const.FragmentProgram.MaxUniformComponents / 4;
d1000 26
d1129 11
a1139 1
                      ctx->Extensions.ARB_geometry_shader4);
d1236 1
a1236 1
      *p = ((char *) ctx->Array.ArrayObj + d->offset);
d1293 2
d1381 2
d1475 2
d1569 2
d1657 2
d1787 25
d1869 122
d2021 1
a2021 1
      params[0] = INT64_TO_BOOLEAN(v.value_int);
d2036 20
d2066 1
a2066 1
      params[0] = INT64_TO_INT(v.value_int);
d2091 1
a2091 1
      params[0] = v.value_int;
d2099 144
d2273 2
@


1.8
log
@Merge Mesa 9.2.0
@
text
@d717 1
@


1.7
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d18 4
a21 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
d28 1
a33 1
#include "mfeatures.h"
d38 2
a66 2
#undef CONST

a89 1
   TYPE_API_MASK,
d105 2
d134 4
a137 1
   EXTRA_VERSION_ES2,
d142 1
d144 2
d181 1
d201 2
d231 7
a237 1
 * structs below. */
d259 5
d275 7
a281 1
static const int extra_new_buffers_OES_read_format[] = {
a282 1
   EXT(OES_read_format),
d286 10
a295 3
static const int extra_EXT_secondary_color_flush_current[] = {
   EXT(EXT_secondary_color),
   EXTRA_FLUSH_CURRENT,
d299 3
a301 3
static const int extra_EXT_fog_coord_flush_current[] = {
   EXT(EXT_fog_coord),
   EXTRA_FLUSH_CURRENT,
d305 2
a306 2
static const int extra_EXT_texture_integer[] = {
   EXT(EXT_texture_integer),
d310 3
a312 2
static const int extra_EXT_gpu_shader4[] = {
   EXT(EXT_gpu_shader4),
d316 3
a318 2
static const int extra_ARB_sampler_objects[] = {
   EXT(ARB_sampler_objects),
d322 11
a333 2
EXTRA_EXT(ARB_ES2_compatibility);
EXTRA_EXT(ARB_multitexture);
d336 1
a336 4
EXTRA_EXT2(EXT_secondary_color, ARB_vertex_program);
EXTRA_EXT(EXT_secondary_color);
EXTRA_EXT(EXT_fog_coord);
EXTRA_EXT(EXT_texture_lod_bias);
a337 1
EXTRA_EXT(IBM_rasterpos_clip);
a338 3
EXTRA_EXT(SGIS_generate_mipmap);
EXTRA_EXT(NV_vertex_program);
EXTRA_EXT(NV_fragment_program);
a340 1
EXTRA_EXT(NV_light_max_exponent);
a344 1
EXTRA_EXT(ARB_shader_objects);
a348 2
EXTRA_EXT(EXT_framebuffer_object);
EXTRA_EXT(APPLE_vertex_array_object);
a349 1
EXTRA_EXT(EXT_compiled_vertex_array);
d353 1
a353 1
EXTRA_EXT(ARB_transform_feedback2);
a356 2
EXTRA_EXT2(ARB_fragment_program, NV_fragment_program);
EXTRA_EXT2(ARB_vertex_program, NV_vertex_program);
a357 1
EXTRA_EXT(ARB_vertex_buffer_object);
d359 1
a359 1
EXTRA_EXT(ARB_copy_buffer);
d361 8
a368 9
EXTRA_EXT(ARB_texture_buffer_object);

static const int
extra_ARB_vertex_program_ARB_fragment_program_NV_vertex_program[] = {
   EXT(ARB_vertex_program),
   EXT(ARB_fragment_program),
   EXT(NV_vertex_program),
   EXTRA_END
};
d371 3
a373 5
extra_NV_vertex_program_ARB_vertex_program_ARB_fragment_program_NV_vertex_program[] = {
   EXT(NV_vertex_program),
   EXT(ARB_vertex_program),
   EXT(ARB_fragment_program),
   EXT(NV_vertex_program),
d387 12
d400 1
a400 1
extra_ARB_vertex_program_version_es2[] = {
d402 10
a411 1
   EXTRA_VERSION_ES2,
d415 6
a420 3
#define API_OPENGL_BIT (1 << API_OPENGL)
#define API_OPENGLES_BIT (1 << API_OPENGLES)
#define API_OPENGLES2_BIT (1 << API_OPENGLES2)
d426 4
a429 106
 * remaining combinations.  When we add the enums to the hash table in
 * _mesa_init_get_hash(), we only add the enums for the API we're
 * instantiating and the different sections are guarded by #if
 * FEATURE_GL etc to make sure we only compile in the enums we may
 * need. */

static const struct value_desc values[] = {
   /* Enums shared between OpenGL, GLES1 and GLES2 */
   { 0, 0, TYPE_API_MASK,
     API_OPENGL_BIT | API_OPENGLES_BIT | API_OPENGLES2_BIT, NO_EXTRA},
   { GL_ALPHA_BITS, BUFFER_INT(Visual.alphaBits), extra_new_buffers },
   { GL_BLEND, CONTEXT_BIT0(Color.BlendEnabled), NO_EXTRA },
   { GL_BLEND_SRC, CONTEXT_ENUM(Color.Blend[0].SrcRGB), NO_EXTRA },
   { GL_BLUE_BITS, BUFFER_INT(Visual.blueBits), extra_new_buffers },
   { GL_COLOR_CLEAR_VALUE, LOC_CUSTOM, TYPE_FLOATN_4, 0, extra_new_frag_clamp },
   { GL_COLOR_WRITEMASK, LOC_CUSTOM, TYPE_INT_4, 0, NO_EXTRA },
   { GL_CULL_FACE, CONTEXT_BOOL(Polygon.CullFlag), NO_EXTRA },
   { GL_CULL_FACE_MODE, CONTEXT_ENUM(Polygon.CullFaceMode), NO_EXTRA },
   { GL_DEPTH_BITS, BUFFER_INT(Visual.depthBits), NO_EXTRA },
   { GL_DEPTH_CLEAR_VALUE, CONTEXT_FIELD(Depth.Clear, TYPE_DOUBLEN), NO_EXTRA },
   { GL_DEPTH_FUNC, CONTEXT_ENUM(Depth.Func), NO_EXTRA },
   { GL_DEPTH_RANGE, CONTEXT_FIELD(Viewport.Near, TYPE_FLOATN_2), NO_EXTRA },
   { GL_DEPTH_TEST, CONTEXT_BOOL(Depth.Test), NO_EXTRA },
   { GL_DEPTH_WRITEMASK, CONTEXT_BOOL(Depth.Mask), NO_EXTRA },
   { GL_DITHER, CONTEXT_BOOL(Color.DitherFlag), NO_EXTRA },
   { GL_FRONT_FACE, CONTEXT_ENUM(Polygon.FrontFace), NO_EXTRA },
   { GL_GREEN_BITS, BUFFER_INT(Visual.greenBits), extra_new_buffers },
   { GL_LINE_WIDTH, CONTEXT_FLOAT(Line.Width), NO_EXTRA },
   { GL_ALIASED_LINE_WIDTH_RANGE, CONTEXT_FLOAT2(Const.MinLineWidth), NO_EXTRA },
   { GL_MAX_ELEMENTS_VERTICES, CONTEXT_INT(Const.MaxArrayLockSize), NO_EXTRA },
   { GL_MAX_ELEMENTS_INDICES, CONTEXT_INT(Const.MaxArrayLockSize), NO_EXTRA },
   { GL_MAX_TEXTURE_SIZE, LOC_CUSTOM, TYPE_INT,
     offsetof(struct gl_context, Const.MaxTextureLevels), NO_EXTRA },
   { GL_MAX_VIEWPORT_DIMS, CONTEXT_INT2(Const.MaxViewportWidth), NO_EXTRA },
   { GL_PACK_ALIGNMENT, CONTEXT_INT(Pack.Alignment), NO_EXTRA },
   { GL_ALIASED_POINT_SIZE_RANGE, CONTEXT_FLOAT2(Const.MinPointSize), NO_EXTRA },
   { GL_POLYGON_OFFSET_FACTOR, CONTEXT_FLOAT(Polygon.OffsetFactor ), NO_EXTRA },
   { GL_POLYGON_OFFSET_UNITS, CONTEXT_FLOAT(Polygon.OffsetUnits ), NO_EXTRA },
   { GL_POLYGON_OFFSET_FILL, CONTEXT_BOOL(Polygon.OffsetFill), NO_EXTRA },
   { GL_RED_BITS, BUFFER_INT(Visual.redBits), extra_new_buffers },
   { GL_SCISSOR_BOX, LOC_CUSTOM, TYPE_INT_4, 0, NO_EXTRA },
   { GL_SCISSOR_TEST, CONTEXT_BOOL(Scissor.Enabled), NO_EXTRA },
   { GL_STENCIL_BITS, BUFFER_INT(Visual.stencilBits), NO_EXTRA },
   { GL_STENCIL_CLEAR_VALUE, CONTEXT_INT(Stencil.Clear), NO_EXTRA },
   { GL_STENCIL_FAIL, LOC_CUSTOM, TYPE_ENUM, NO_OFFSET, NO_EXTRA },
   { GL_STENCIL_FUNC, LOC_CUSTOM, TYPE_ENUM, NO_OFFSET, NO_EXTRA },
   { GL_STENCIL_PASS_DEPTH_FAIL, LOC_CUSTOM, TYPE_ENUM, NO_OFFSET, NO_EXTRA },
   { GL_STENCIL_PASS_DEPTH_PASS, LOC_CUSTOM, TYPE_ENUM, NO_OFFSET, NO_EXTRA },
   { GL_STENCIL_REF, LOC_CUSTOM, TYPE_INT, NO_OFFSET, NO_EXTRA },
   { GL_STENCIL_TEST, CONTEXT_BOOL(Stencil.Enabled), NO_EXTRA },
   { GL_STENCIL_VALUE_MASK, LOC_CUSTOM, TYPE_INT, NO_OFFSET, NO_EXTRA },
   { GL_STENCIL_WRITEMASK, LOC_CUSTOM, TYPE_INT, NO_OFFSET, NO_EXTRA },
   { GL_SUBPIXEL_BITS, CONTEXT_INT(Const.SubPixelBits), NO_EXTRA },
   { GL_TEXTURE_BINDING_2D, LOC_CUSTOM, TYPE_INT, TEXTURE_2D_INDEX, NO_EXTRA },
   { GL_UNPACK_ALIGNMENT, CONTEXT_INT(Unpack.Alignment), NO_EXTRA },
   { GL_VIEWPORT, LOC_CUSTOM, TYPE_INT_4, 0, NO_EXTRA },

   /* GL_ARB_multitexture */
   { GL_ACTIVE_TEXTURE_ARB,
     LOC_CUSTOM, TYPE_INT, 0, extra_ARB_multitexture },

   /* Note that all the OES_* extensions require that the Mesa "struct
    * gl_extensions" include a member with the name of the extension.
    * That structure does not yet include OES extensions (and we're
    * not sure whether it will).  If it does, all the OES_*
    * extensions below should mark the dependency. */

   /* GL_ARB_texture_cube_map */
   { GL_TEXTURE_BINDING_CUBE_MAP_ARB, LOC_CUSTOM, TYPE_INT,
     TEXTURE_CUBE_INDEX, extra_ARB_texture_cube_map },
   { GL_MAX_CUBE_MAP_TEXTURE_SIZE_ARB, LOC_CUSTOM, TYPE_INT,
     offsetof(struct gl_context, Const.MaxCubeTextureLevels),
     extra_ARB_texture_cube_map }, /* XXX: OES_texture_cube_map */

   /* XXX: OES_blend_subtract */
   { GL_BLEND_SRC_RGB_EXT, CONTEXT_ENUM(Color.Blend[0].SrcRGB), NO_EXTRA },
   { GL_BLEND_DST_RGB_EXT, CONTEXT_ENUM(Color.Blend[0].DstRGB), NO_EXTRA },
   { GL_BLEND_SRC_ALPHA_EXT, CONTEXT_ENUM(Color.Blend[0].SrcA), NO_EXTRA },
   { GL_BLEND_DST_ALPHA_EXT, CONTEXT_ENUM(Color.Blend[0].DstA), NO_EXTRA },

   /* GL_BLEND_EQUATION_RGB, which is what we're really after, is
    * defined identically to GL_BLEND_EQUATION. */
   { GL_BLEND_EQUATION, CONTEXT_ENUM(Color.Blend[0].EquationRGB), NO_EXTRA },
   { GL_BLEND_EQUATION_ALPHA_EXT, CONTEXT_ENUM(Color.Blend[0].EquationA), NO_EXTRA },

   /* GL_ARB_texture_compression */
   { GL_NUM_COMPRESSED_TEXTURE_FORMATS_ARB, LOC_CUSTOM, TYPE_INT, 0, NO_EXTRA },
   { GL_COMPRESSED_TEXTURE_FORMATS_ARB, LOC_CUSTOM, TYPE_INT_N, 0, NO_EXTRA },

   /* GL_ARB_multisample */
   { GL_SAMPLE_ALPHA_TO_COVERAGE_ARB,
     CONTEXT_BOOL(Multisample.SampleAlphaToCoverage), NO_EXTRA },
   { GL_SAMPLE_COVERAGE_ARB, CONTEXT_BOOL(Multisample.SampleCoverage), NO_EXTRA },
   { GL_SAMPLE_COVERAGE_VALUE_ARB,
     CONTEXT_FLOAT(Multisample.SampleCoverageValue), NO_EXTRA },
   { GL_SAMPLE_COVERAGE_INVERT_ARB,
     CONTEXT_BOOL(Multisample.SampleCoverageInvert), NO_EXTRA },
   { GL_SAMPLE_BUFFERS_ARB, BUFFER_INT(Visual.sampleBuffers), NO_EXTRA },
   { GL_SAMPLES_ARB, BUFFER_INT(Visual.samples), NO_EXTRA },

   /* GL_SGIS_generate_mipmap */
   { GL_GENERATE_MIPMAP_HINT_SGIS, CONTEXT_ENUM(Hint.GenerateMipmap),
     extra_SGIS_generate_mipmap },

   /* GL_ARB_vertex_buffer_object */
   { GL_ARRAY_BUFFER_BINDING_ARB, LOC_CUSTOM, TYPE_INT, 0, NO_EXTRA },
d431 1
a431 806
   /* GL_ARB_vertex_buffer_object */
   /* GL_WEIGHT_ARRAY_BUFFER_BINDING_ARB - not supported */
   { GL_ELEMENT_ARRAY_BUFFER_BINDING_ARB, LOC_CUSTOM, TYPE_INT, 0,
     extra_ARB_vertex_buffer_object },

   /* GL_ARB_copy_buffer */
   { GL_COPY_READ_BUFFER, LOC_CUSTOM, TYPE_INT, 0, extra_ARB_copy_buffer },
   { GL_COPY_WRITE_BUFFER, LOC_CUSTOM, TYPE_INT, 0, extra_ARB_copy_buffer },

   /* GL_OES_read_format */
   { GL_IMPLEMENTATION_COLOR_READ_TYPE_OES, LOC_CUSTOM, TYPE_INT, 0,
     extra_new_buffers_OES_read_format },
   { GL_IMPLEMENTATION_COLOR_READ_FORMAT_OES, LOC_CUSTOM, TYPE_INT, 0,
     extra_new_buffers_OES_read_format },

   /* GL_EXT_framebuffer_object */
   { GL_FRAMEBUFFER_BINDING_EXT, BUFFER_INT(Name),
     extra_EXT_framebuffer_object },
   { GL_RENDERBUFFER_BINDING_EXT, LOC_CUSTOM, TYPE_INT, 0,
     extra_EXT_framebuffer_object },
   { GL_MAX_RENDERBUFFER_SIZE_EXT, CONTEXT_INT(Const.MaxRenderbufferSize),
     extra_EXT_framebuffer_object },

   /* This entry isn't spec'ed for GLES 2, but is needed for Mesa's
    * GLSL: */
   { GL_MAX_CLIP_PLANES, CONTEXT_INT(Const.MaxClipPlanes), NO_EXTRA },

#if FEATURE_GL || FEATURE_ES1
   /* Enums in OpenGL and GLES1 */
   { 0, 0, TYPE_API_MASK, API_OPENGL_BIT | API_OPENGLES_BIT, NO_EXTRA },
   { GL_MAX_LIGHTS, CONTEXT_INT(Const.MaxLights), NO_EXTRA },
   { GL_LIGHT0, CONTEXT_BOOL(Light.Light[0].Enabled), NO_EXTRA },
   { GL_LIGHT1, CONTEXT_BOOL(Light.Light[1].Enabled), NO_EXTRA },
   { GL_LIGHT2, CONTEXT_BOOL(Light.Light[2].Enabled), NO_EXTRA },
   { GL_LIGHT3, CONTEXT_BOOL(Light.Light[3].Enabled), NO_EXTRA },
   { GL_LIGHT4, CONTEXT_BOOL(Light.Light[4].Enabled), NO_EXTRA },
   { GL_LIGHT5, CONTEXT_BOOL(Light.Light[5].Enabled), NO_EXTRA },
   { GL_LIGHT6, CONTEXT_BOOL(Light.Light[6].Enabled), NO_EXTRA },
   { GL_LIGHT7, CONTEXT_BOOL(Light.Light[7].Enabled), NO_EXTRA },
   { GL_LIGHTING, CONTEXT_BOOL(Light.Enabled), NO_EXTRA },
   { GL_LIGHT_MODEL_AMBIENT,
     CONTEXT_FIELD(Light.Model.Ambient[0], TYPE_FLOATN_4), NO_EXTRA },
   { GL_LIGHT_MODEL_TWO_SIDE, CONTEXT_BOOL(Light.Model.TwoSide), NO_EXTRA },
   { GL_ALPHA_TEST, CONTEXT_BOOL(Color.AlphaEnabled), NO_EXTRA },
   { GL_ALPHA_TEST_FUNC, CONTEXT_ENUM(Color.AlphaFunc), NO_EXTRA },
   { GL_ALPHA_TEST_REF, LOC_CUSTOM, TYPE_FLOATN, 0, extra_new_frag_clamp },
   { GL_BLEND_DST, CONTEXT_ENUM(Color.Blend[0].DstRGB), NO_EXTRA },
   { GL_CLIP_PLANE0, CONTEXT_BIT0(Transform.ClipPlanesEnabled), NO_EXTRA },
   { GL_CLIP_PLANE1, CONTEXT_BIT1(Transform.ClipPlanesEnabled), NO_EXTRA },
   { GL_CLIP_PLANE2, CONTEXT_BIT2(Transform.ClipPlanesEnabled), NO_EXTRA },
   { GL_CLIP_PLANE3, CONTEXT_BIT3(Transform.ClipPlanesEnabled), NO_EXTRA },
   { GL_CLIP_PLANE4, CONTEXT_BIT4(Transform.ClipPlanesEnabled), NO_EXTRA },
   { GL_CLIP_PLANE5, CONTEXT_BIT5(Transform.ClipPlanesEnabled), NO_EXTRA },
   { GL_COLOR_MATERIAL, CONTEXT_BOOL(Light.ColorMaterialEnabled), NO_EXTRA },
   { GL_CURRENT_COLOR,
     CONTEXT_FIELD(Current.Attrib[VERT_ATTRIB_COLOR0][0], TYPE_FLOATN_4),
     extra_flush_current },
   { GL_CURRENT_NORMAL,
     CONTEXT_FIELD(Current.Attrib[VERT_ATTRIB_NORMAL][0], TYPE_FLOATN_3),
     extra_flush_current },
   { GL_CURRENT_TEXTURE_COORDS, LOC_CUSTOM, TYPE_FLOAT_4, 0,
     extra_flush_current_valid_texture_unit },
   { GL_DISTANCE_ATTENUATION_EXT, CONTEXT_FLOAT3(Point.Params[0]), NO_EXTRA },
   { GL_FOG, CONTEXT_BOOL(Fog.Enabled), NO_EXTRA },
   { GL_FOG_COLOR, LOC_CUSTOM, TYPE_FLOATN_4, 0, extra_new_frag_clamp },
   { GL_FOG_DENSITY, CONTEXT_FLOAT(Fog.Density), NO_EXTRA },
   { GL_FOG_END, CONTEXT_FLOAT(Fog.End), NO_EXTRA },
   { GL_FOG_HINT, CONTEXT_ENUM(Hint.Fog), NO_EXTRA },
   { GL_FOG_MODE, CONTEXT_ENUM(Fog.Mode), NO_EXTRA },
   { GL_FOG_START, CONTEXT_FLOAT(Fog.Start), NO_EXTRA },
   { GL_LINE_SMOOTH, CONTEXT_BOOL(Line.SmoothFlag), NO_EXTRA },
   { GL_LINE_SMOOTH_HINT, CONTEXT_ENUM(Hint.LineSmooth), NO_EXTRA },
   { GL_LINE_WIDTH_RANGE, CONTEXT_FLOAT2(Const.MinLineWidthAA), NO_EXTRA },
   { GL_COLOR_LOGIC_OP, CONTEXT_BOOL(Color.ColorLogicOpEnabled), NO_EXTRA },
   { GL_LOGIC_OP_MODE, CONTEXT_ENUM(Color.LogicOp), NO_EXTRA },
   { GL_MATRIX_MODE, CONTEXT_ENUM(Transform.MatrixMode), NO_EXTRA },
   { GL_MAX_MODELVIEW_STACK_DEPTH, CONST(MAX_MODELVIEW_STACK_DEPTH), NO_EXTRA },
   { GL_MAX_PROJECTION_STACK_DEPTH, CONST(MAX_PROJECTION_STACK_DEPTH), NO_EXTRA },
   { GL_MAX_TEXTURE_STACK_DEPTH, CONST(MAX_TEXTURE_STACK_DEPTH), NO_EXTRA },
   { GL_MODELVIEW_MATRIX, CONTEXT_MATRIX(ModelviewMatrixStack.Top), NO_EXTRA },
   { GL_MODELVIEW_STACK_DEPTH, LOC_CUSTOM, TYPE_INT,
     offsetof(struct gl_context, ModelviewMatrixStack.Depth), NO_EXTRA },
   { GL_NORMALIZE, CONTEXT_BOOL(Transform.Normalize), NO_EXTRA },
   { GL_PACK_SKIP_IMAGES_EXT, CONTEXT_INT(Pack.SkipImages), NO_EXTRA },
   { GL_PERSPECTIVE_CORRECTION_HINT, CONTEXT_ENUM(Hint.PerspectiveCorrection), NO_EXTRA },
   { GL_POINT_SIZE, CONTEXT_FLOAT(Point.Size), NO_EXTRA },
   { GL_POINT_SIZE_RANGE, CONTEXT_FLOAT2(Const.MinPointSizeAA), NO_EXTRA },
   { GL_POINT_SMOOTH, CONTEXT_BOOL(Point.SmoothFlag), NO_EXTRA },
   { GL_POINT_SMOOTH_HINT, CONTEXT_ENUM(Hint.PointSmooth), NO_EXTRA },
   { GL_POINT_SIZE_MIN_EXT, CONTEXT_FLOAT(Point.MinSize), NO_EXTRA },
   { GL_POINT_SIZE_MAX_EXT, CONTEXT_FLOAT(Point.MaxSize), NO_EXTRA },
   { GL_POINT_FADE_THRESHOLD_SIZE_EXT, CONTEXT_FLOAT(Point.Threshold), NO_EXTRA },
   { GL_PROJECTION_MATRIX, CONTEXT_MATRIX(ProjectionMatrixStack.Top), NO_EXTRA },
   { GL_PROJECTION_STACK_DEPTH, LOC_CUSTOM, TYPE_INT,
     offsetof(struct gl_context, ProjectionMatrixStack.Depth), NO_EXTRA },
   { GL_RESCALE_NORMAL, CONTEXT_BOOL(Transform.RescaleNormals), NO_EXTRA },
   { GL_SHADE_MODEL, CONTEXT_ENUM(Light.ShadeModel), NO_EXTRA },
   { GL_TEXTURE_2D, LOC_CUSTOM, TYPE_BOOLEAN, 0, NO_EXTRA },
   { GL_TEXTURE_MATRIX, LOC_CUSTOM, TYPE_MATRIX, 0, extra_valid_texture_unit },
   { GL_TEXTURE_STACK_DEPTH, LOC_CUSTOM, TYPE_INT, 0,
     extra_valid_texture_unit  },

   { GL_VERTEX_ARRAY, ARRAY_BOOL(Vertex.Enabled), NO_EXTRA },
   { GL_VERTEX_ARRAY_SIZE, ARRAY_INT(Vertex.Size), NO_EXTRA },
   { GL_VERTEX_ARRAY_TYPE, ARRAY_ENUM(Vertex.Type), NO_EXTRA },
   { GL_VERTEX_ARRAY_STRIDE, ARRAY_INT(Vertex.Stride), NO_EXTRA },
   { GL_NORMAL_ARRAY, ARRAY_BOOL(Normal.Enabled), NO_EXTRA },
   { GL_NORMAL_ARRAY_TYPE, ARRAY_ENUM(Normal.Type), NO_EXTRA },
   { GL_NORMAL_ARRAY_STRIDE, ARRAY_INT(Normal.Stride), NO_EXTRA },
   { GL_COLOR_ARRAY, ARRAY_BOOL(Color.Enabled), NO_EXTRA },
   { GL_COLOR_ARRAY_SIZE, ARRAY_INT(Color.Size), NO_EXTRA },
   { GL_COLOR_ARRAY_TYPE, ARRAY_ENUM(Color.Type), NO_EXTRA },
   { GL_COLOR_ARRAY_STRIDE, ARRAY_INT(Color.Stride), NO_EXTRA },
   { GL_TEXTURE_COORD_ARRAY,
     LOC_CUSTOM, TYPE_BOOLEAN, offsetof(struct gl_client_array, Enabled), NO_EXTRA },
   { GL_TEXTURE_COORD_ARRAY_SIZE,
     LOC_CUSTOM, TYPE_INT, offsetof(struct gl_client_array, Size), NO_EXTRA },
   { GL_TEXTURE_COORD_ARRAY_TYPE,
     LOC_CUSTOM, TYPE_ENUM, offsetof(struct gl_client_array, Type), NO_EXTRA },
   { GL_TEXTURE_COORD_ARRAY_STRIDE,
     LOC_CUSTOM, TYPE_INT, offsetof(struct gl_client_array, Stride), NO_EXTRA },

   /* GL_ARB_ES2_compatibility */
   { GL_SHADER_COMPILER, CONST(1), extra_ARB_ES2_compatibility },
   { GL_MAX_VARYING_VECTORS, CONTEXT_INT(Const.MaxVarying),
     extra_ARB_ES2_compatibility },
   { GL_MAX_VERTEX_UNIFORM_VECTORS, LOC_CUSTOM, TYPE_INT, 0,
     extra_ARB_ES2_compatibility },
   { GL_MAX_FRAGMENT_UNIFORM_VECTORS, LOC_CUSTOM, TYPE_INT, 0,
     extra_ARB_ES2_compatibility },

   /* GL_ARB_multitexture */
   { GL_MAX_TEXTURE_UNITS_ARB,
     CONTEXT_INT(Const.MaxTextureUnits), extra_ARB_multitexture },
   { GL_CLIENT_ACTIVE_TEXTURE_ARB,
     LOC_CUSTOM, TYPE_INT, 0, extra_ARB_multitexture },

   /* GL_ARB_texture_cube_map */
   { GL_TEXTURE_CUBE_MAP_ARB, LOC_CUSTOM, TYPE_BOOLEAN, 0, NO_EXTRA },
   /* S, T, and R are always set at the same time */
   { GL_TEXTURE_GEN_STR_OES, LOC_TEXUNIT, TYPE_BIT_0,
     offsetof(struct gl_texture_unit, TexGenEnabled), NO_EXTRA },

   /* GL_ARB_multisample */
   { GL_MULTISAMPLE_ARB, CONTEXT_BOOL(Multisample.Enabled), NO_EXTRA },
   { GL_SAMPLE_ALPHA_TO_ONE_ARB, CONTEXT_BOOL(Multisample.SampleAlphaToOne), NO_EXTRA },

   /* GL_ARB_vertex_buffer_object */
   { GL_VERTEX_ARRAY_BUFFER_BINDING_ARB, LOC_CUSTOM, TYPE_INT,
     offsetof(struct gl_array_object, Vertex.BufferObj), NO_EXTRA },
   { GL_NORMAL_ARRAY_BUFFER_BINDING_ARB, LOC_CUSTOM, TYPE_INT,
     offsetof(struct gl_array_object, Normal.BufferObj), NO_EXTRA },
   { GL_COLOR_ARRAY_BUFFER_BINDING_ARB, LOC_CUSTOM, TYPE_INT,
     offsetof(struct gl_array_object, Color.BufferObj), NO_EXTRA },
   { GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING_ARB, LOC_CUSTOM, TYPE_INT, NO_OFFSET, NO_EXTRA },

   /* GL_OES_point_sprite */
   { GL_POINT_SPRITE_NV,
     CONTEXT_BOOL(Point.PointSprite),
     extra_NV_point_sprite_ARB_point_sprite },

   /* GL_ARB_fragment_shader */
   { GL_MAX_FRAGMENT_UNIFORM_COMPONENTS_ARB,
     CONTEXT_INT(Const.FragmentProgram.MaxUniformComponents),
     extra_ARB_fragment_shader },

   /* GL_ARB_vertex_shader */
   { GL_MAX_VERTEX_UNIFORM_COMPONENTS_ARB,
     CONTEXT_INT(Const.VertexProgram.MaxUniformComponents),
     extra_ARB_vertex_shader },
   { GL_MAX_VARYING_FLOATS_ARB, LOC_CUSTOM, TYPE_INT, 0,
     extra_ARB_vertex_shader },

   /* GL_EXT_texture_lod_bias */
   { GL_MAX_TEXTURE_LOD_BIAS_EXT, CONTEXT_FLOAT(Const.MaxTextureLodBias),
	 extra_EXT_texture_lod_bias },

   /* GL_EXT_texture_filter_anisotropic */
   { GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT,
     CONTEXT_FLOAT(Const.MaxTextureMaxAnisotropy),
     extra_EXT_texture_filter_anisotropic },
#endif /* FEATURE_GL || FEATURE_ES1 */

#if FEATURE_ES1
   { 0, 0, TYPE_API_MASK, API_OPENGLES_BIT },
   /* XXX: OES_matrix_get */
   { GL_MODELVIEW_MATRIX_FLOAT_AS_INT_BITS_OES },
   { GL_PROJECTION_MATRIX_FLOAT_AS_INT_BITS_OES },
   { GL_TEXTURE_MATRIX_FLOAT_AS_INT_BITS_OES },

   /* OES_point_size_array */
   { GL_POINT_SIZE_ARRAY_OES, ARRAY_FIELD(PointSize.Enabled, TYPE_BOOLEAN) },
   { GL_POINT_SIZE_ARRAY_TYPE_OES, ARRAY_FIELD(PointSize.Type, TYPE_ENUM) },
   { GL_POINT_SIZE_ARRAY_STRIDE_OES, ARRAY_FIELD(PointSize.Stride, TYPE_INT) },
   { GL_POINT_SIZE_ARRAY_BUFFER_BINDING_OES, LOC_CUSTOM, TYPE_INT, 0 },
#endif /* FEATURE_ES1 */

#if FEATURE_GL || FEATURE_ES2
   { 0, 0, TYPE_API_MASK, API_OPENGL_BIT | API_OPENGLES2_BIT, NO_EXTRA },
   { GL_MAX_TEXTURE_COORDS_ARB, /* == GL_MAX_TEXTURE_COORDS_NV */
     CONTEXT_INT(Const.MaxTextureCoordUnits),
     extra_ARB_fragment_program_NV_fragment_program },

   /* GL_ARB_draw_buffers */
   { GL_MAX_DRAW_BUFFERS_ARB, CONTEXT_INT(Const.MaxDrawBuffers), NO_EXTRA },

   { GL_BLEND_COLOR_EXT, LOC_CUSTOM, TYPE_FLOATN_4, 0, extra_new_frag_clamp },
   /* GL_ARB_fragment_program */
   { GL_MAX_TEXTURE_IMAGE_UNITS_ARB, /* == GL_MAX_TEXTURE_IMAGE_UNITS_NV */
     CONTEXT_INT(Const.MaxTextureImageUnits),
     extra_ARB_fragment_program_NV_fragment_program },
   { GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS_ARB,
     CONTEXT_INT(Const.MaxVertexTextureImageUnits), extra_ARB_vertex_shader },
   { GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS_ARB,
     CONTEXT_INT(Const.MaxCombinedTextureImageUnits),
     extra_ARB_vertex_shader },

   /* GL_ARB_shader_objects
    * Actually, this token isn't part of GL_ARB_shader_objects, but is
    * close enough for now. */
   { GL_CURRENT_PROGRAM, LOC_CUSTOM, TYPE_INT, 0, extra_ARB_shader_objects },

   /* OpenGL 2.0 */
   { GL_STENCIL_BACK_FUNC, CONTEXT_ENUM(Stencil.Function[1]), NO_EXTRA },
   { GL_STENCIL_BACK_VALUE_MASK, CONTEXT_INT(Stencil.ValueMask[1]), NO_EXTRA },
   { GL_STENCIL_BACK_WRITEMASK, CONTEXT_INT(Stencil.WriteMask[1]), NO_EXTRA },
   { GL_STENCIL_BACK_REF, CONTEXT_INT(Stencil.Ref[1]), NO_EXTRA },
   { GL_STENCIL_BACK_FAIL, CONTEXT_ENUM(Stencil.FailFunc[1]), NO_EXTRA },
   { GL_STENCIL_BACK_PASS_DEPTH_FAIL, CONTEXT_ENUM(Stencil.ZFailFunc[1]), NO_EXTRA },
   { GL_STENCIL_BACK_PASS_DEPTH_PASS, CONTEXT_ENUM(Stencil.ZPassFunc[1]), NO_EXTRA },

   { GL_MAX_VERTEX_ATTRIBS_ARB,
     CONTEXT_INT(Const.VertexProgram.MaxAttribs),
     extra_ARB_vertex_program_version_es2 },

   /* OES_texture_3D */
   { GL_TEXTURE_BINDING_3D, LOC_CUSTOM, TYPE_INT, TEXTURE_3D_INDEX, NO_EXTRA },
   { GL_MAX_3D_TEXTURE_SIZE, LOC_CUSTOM, TYPE_INT,
     offsetof(struct gl_context, Const.Max3DTextureLevels), NO_EXTRA },

   /* GL_ARB_fragment_program/OES_standard_derivatives */
   { GL_FRAGMENT_SHADER_DERIVATIVE_HINT_ARB,
     CONTEXT_ENUM(Hint.FragmentShaderDerivative), extra_ARB_fragment_shader },
#endif /* FEATURE_GL || FEATURE_ES2 */

#if FEATURE_ES2
   /* Enums unique to OpenGL ES 2.0 */
   { 0, 0, TYPE_API_MASK, API_OPENGLES2_BIT, NO_EXTRA },
   { GL_MAX_FRAGMENT_UNIFORM_VECTORS, LOC_CUSTOM, TYPE_INT, 0, NO_EXTRA },
   { GL_MAX_VARYING_VECTORS, CONTEXT_INT(Const.MaxVarying), NO_EXTRA },
   { GL_MAX_VERTEX_UNIFORM_VECTORS, LOC_CUSTOM, TYPE_INT, 0, NO_EXTRA },
   { GL_SHADER_COMPILER, CONST(1), NO_EXTRA },
   /* OES_get_program_binary */
   { GL_NUM_SHADER_BINARY_FORMATS, CONST(0), NO_EXTRA },
   { GL_SHADER_BINARY_FORMATS, CONST(0), NO_EXTRA },
#endif /* FEATURE_ES2 */

#if FEATURE_GL
   /* Remaining enums are only in OpenGL */
   { 0, 0, TYPE_API_MASK, API_OPENGL_BIT, NO_EXTRA },
   { GL_ACCUM_RED_BITS, BUFFER_INT(Visual.accumRedBits), NO_EXTRA },
   { GL_ACCUM_GREEN_BITS, BUFFER_INT(Visual.accumGreenBits), NO_EXTRA },
   { GL_ACCUM_BLUE_BITS, BUFFER_INT(Visual.accumBlueBits), NO_EXTRA },
   { GL_ACCUM_ALPHA_BITS, BUFFER_INT(Visual.accumAlphaBits), NO_EXTRA },
   { GL_ACCUM_CLEAR_VALUE, CONTEXT_FIELD(Accum.ClearColor[0], TYPE_FLOATN_4), NO_EXTRA },
   { GL_ALPHA_BIAS, CONTEXT_FLOAT(Pixel.AlphaBias), NO_EXTRA },
   { GL_ALPHA_SCALE, CONTEXT_FLOAT(Pixel.AlphaScale), NO_EXTRA },
   { GL_ATTRIB_STACK_DEPTH, CONTEXT_INT(AttribStackDepth), NO_EXTRA },
   { GL_AUTO_NORMAL, CONTEXT_BOOL(Eval.AutoNormal), NO_EXTRA },
   { GL_AUX_BUFFERS, BUFFER_INT(Visual.numAuxBuffers), NO_EXTRA },
   { GL_BLUE_BIAS, CONTEXT_FLOAT(Pixel.BlueBias), NO_EXTRA },
   { GL_BLUE_SCALE, CONTEXT_FLOAT(Pixel.BlueScale), NO_EXTRA },
   { GL_CLIENT_ATTRIB_STACK_DEPTH, CONTEXT_INT(ClientAttribStackDepth), NO_EXTRA },
   { GL_COLOR_MATERIAL_FACE, CONTEXT_ENUM(Light.ColorMaterialFace), NO_EXTRA },
   { GL_COLOR_MATERIAL_PARAMETER, CONTEXT_ENUM(Light.ColorMaterialMode), NO_EXTRA },
   { GL_CURRENT_INDEX,
     CONTEXT_FLOAT(Current.Attrib[VERT_ATTRIB_COLOR_INDEX][0]),
     extra_flush_current },
   { GL_CURRENT_RASTER_COLOR,
     CONTEXT_FIELD(Current.RasterColor[0], TYPE_FLOATN_4), NO_EXTRA },
   { GL_CURRENT_RASTER_DISTANCE, CONTEXT_FLOAT(Current.RasterDistance), NO_EXTRA },
   { GL_CURRENT_RASTER_INDEX, CONST(1), NO_EXTRA },
   { GL_CURRENT_RASTER_POSITION, CONTEXT_FLOAT4(Current.RasterPos[0]), NO_EXTRA },
   { GL_CURRENT_RASTER_SECONDARY_COLOR,
     CONTEXT_FIELD(Current.RasterSecondaryColor[0], TYPE_FLOATN_4), NO_EXTRA },
   { GL_CURRENT_RASTER_TEXTURE_COORDS, LOC_CUSTOM, TYPE_FLOAT_4, 0,
     extra_valid_texture_unit },
   { GL_CURRENT_RASTER_POSITION_VALID, CONTEXT_BOOL(Current.RasterPosValid), NO_EXTRA },
   { GL_DEPTH_BIAS, CONTEXT_FLOAT(Pixel.DepthBias), NO_EXTRA },
   { GL_DEPTH_SCALE, CONTEXT_FLOAT(Pixel.DepthScale), NO_EXTRA },
   { GL_DOUBLEBUFFER, BUFFER_INT(Visual.doubleBufferMode), NO_EXTRA },
   { GL_DRAW_BUFFER, BUFFER_ENUM(ColorDrawBuffer[0]), NO_EXTRA },
   { GL_EDGE_FLAG, LOC_CUSTOM, TYPE_BOOLEAN, 0, NO_EXTRA },
   { GL_FEEDBACK_BUFFER_SIZE, CONTEXT_INT(Feedback.BufferSize), NO_EXTRA },
   { GL_FEEDBACK_BUFFER_TYPE, CONTEXT_ENUM(Feedback.Type), NO_EXTRA },
   { GL_FOG_INDEX, CONTEXT_FLOAT(Fog.Index), NO_EXTRA },
   { GL_GREEN_BIAS, CONTEXT_FLOAT(Pixel.GreenBias), NO_EXTRA },
   { GL_GREEN_SCALE, CONTEXT_FLOAT(Pixel.GreenScale), NO_EXTRA },
   { GL_INDEX_BITS, BUFFER_INT(Visual.indexBits), extra_new_buffers },
   { GL_INDEX_CLEAR_VALUE, CONTEXT_INT(Color.ClearIndex), NO_EXTRA },
   { GL_INDEX_MODE, CONST(0) , NO_EXTRA}, 
   { GL_INDEX_OFFSET, CONTEXT_INT(Pixel.IndexOffset), NO_EXTRA },
   { GL_INDEX_SHIFT, CONTEXT_INT(Pixel.IndexShift), NO_EXTRA },
   { GL_INDEX_WRITEMASK, CONTEXT_INT(Color.IndexMask), NO_EXTRA },
   { GL_LIGHT_MODEL_COLOR_CONTROL, CONTEXT_ENUM(Light.Model.ColorControl), NO_EXTRA },
   { GL_LIGHT_MODEL_LOCAL_VIEWER, CONTEXT_BOOL(Light.Model.LocalViewer), NO_EXTRA },
   { GL_LINE_STIPPLE, CONTEXT_BOOL(Line.StippleFlag), NO_EXTRA },
   { GL_LINE_STIPPLE_PATTERN, LOC_CUSTOM, TYPE_INT, 0, NO_EXTRA },
   { GL_LINE_STIPPLE_REPEAT, CONTEXT_INT(Line.StippleFactor), NO_EXTRA },
   { GL_LINE_WIDTH_GRANULARITY, CONTEXT_FLOAT(Const.LineWidthGranularity), NO_EXTRA },
   { GL_LIST_BASE, CONTEXT_INT(List.ListBase), NO_EXTRA },
   { GL_LIST_INDEX, LOC_CUSTOM, TYPE_INT, 0, NO_EXTRA },
   { GL_LIST_MODE, LOC_CUSTOM, TYPE_ENUM, 0, NO_EXTRA },
   { GL_INDEX_LOGIC_OP, CONTEXT_BOOL(Color.IndexLogicOpEnabled), NO_EXTRA },
   { GL_MAP1_COLOR_4, CONTEXT_BOOL(Eval.Map1Color4), NO_EXTRA },
   { GL_MAP1_GRID_DOMAIN, CONTEXT_FLOAT2(Eval.MapGrid1u1), NO_EXTRA },
   { GL_MAP1_GRID_SEGMENTS, CONTEXT_INT(Eval.MapGrid1un), NO_EXTRA },
   { GL_MAP1_INDEX, CONTEXT_BOOL(Eval.Map1Index), NO_EXTRA },
   { GL_MAP1_NORMAL, CONTEXT_BOOL(Eval.Map1Normal), NO_EXTRA },
   { GL_MAP1_TEXTURE_COORD_1, CONTEXT_BOOL(Eval.Map1TextureCoord1), NO_EXTRA },
   { GL_MAP1_TEXTURE_COORD_2, CONTEXT_BOOL(Eval.Map1TextureCoord2), NO_EXTRA },
   { GL_MAP1_TEXTURE_COORD_3, CONTEXT_BOOL(Eval.Map1TextureCoord3), NO_EXTRA },
   { GL_MAP1_TEXTURE_COORD_4, CONTEXT_BOOL(Eval.Map1TextureCoord4), NO_EXTRA },
   { GL_MAP1_VERTEX_3, CONTEXT_BOOL(Eval.Map1Vertex3), NO_EXTRA },
   { GL_MAP1_VERTEX_4, CONTEXT_BOOL(Eval.Map1Vertex4), NO_EXTRA },
   { GL_MAP2_COLOR_4, CONTEXT_BOOL(Eval.Map2Color4), NO_EXTRA },
   { GL_MAP2_GRID_DOMAIN, LOC_CUSTOM, TYPE_FLOAT_4, 0, NO_EXTRA },
   { GL_MAP2_GRID_SEGMENTS, CONTEXT_INT2(Eval.MapGrid2un), NO_EXTRA },
   { GL_MAP2_INDEX, CONTEXT_BOOL(Eval.Map2Index), NO_EXTRA },
   { GL_MAP2_NORMAL, CONTEXT_BOOL(Eval.Map2Normal), NO_EXTRA },
   { GL_MAP2_TEXTURE_COORD_1, CONTEXT_BOOL(Eval.Map2TextureCoord1), NO_EXTRA },
   { GL_MAP2_TEXTURE_COORD_2, CONTEXT_BOOL(Eval.Map2TextureCoord2), NO_EXTRA },
   { GL_MAP2_TEXTURE_COORD_3, CONTEXT_BOOL(Eval.Map2TextureCoord3), NO_EXTRA },
   { GL_MAP2_TEXTURE_COORD_4, CONTEXT_BOOL(Eval.Map2TextureCoord4), NO_EXTRA },
   { GL_MAP2_VERTEX_3, CONTEXT_BOOL(Eval.Map2Vertex3), NO_EXTRA },
   { GL_MAP2_VERTEX_4, CONTEXT_BOOL(Eval.Map2Vertex4), NO_EXTRA },
   { GL_MAP_COLOR, CONTEXT_BOOL(Pixel.MapColorFlag), NO_EXTRA },
   { GL_MAP_STENCIL, CONTEXT_BOOL(Pixel.MapStencilFlag), NO_EXTRA },
   { GL_MAX_ATTRIB_STACK_DEPTH, CONST(MAX_ATTRIB_STACK_DEPTH), NO_EXTRA },
   { GL_MAX_CLIENT_ATTRIB_STACK_DEPTH, CONST(MAX_CLIENT_ATTRIB_STACK_DEPTH), NO_EXTRA },

   { GL_MAX_EVAL_ORDER, CONST(MAX_EVAL_ORDER), NO_EXTRA },
   { GL_MAX_LIST_NESTING, CONST(MAX_LIST_NESTING), NO_EXTRA },
   { GL_MAX_NAME_STACK_DEPTH, CONST(MAX_NAME_STACK_DEPTH), NO_EXTRA },
   { GL_MAX_PIXEL_MAP_TABLE, CONST(MAX_PIXEL_MAP_TABLE), NO_EXTRA },
   { GL_NAME_STACK_DEPTH, CONTEXT_INT(Select.NameStackDepth), NO_EXTRA },
   { GL_PACK_LSB_FIRST, CONTEXT_BOOL(Pack.LsbFirst), NO_EXTRA },
   { GL_PACK_ROW_LENGTH, CONTEXT_INT(Pack.RowLength), NO_EXTRA },
   { GL_PACK_SKIP_PIXELS, CONTEXT_INT(Pack.SkipPixels), NO_EXTRA },
   { GL_PACK_SKIP_ROWS, CONTEXT_INT(Pack.SkipRows), NO_EXTRA },
   { GL_PACK_SWAP_BYTES, CONTEXT_BOOL(Pack.SwapBytes), NO_EXTRA },
   { GL_PACK_IMAGE_HEIGHT_EXT, CONTEXT_INT(Pack.ImageHeight), NO_EXTRA },
   { GL_PACK_INVERT_MESA, CONTEXT_BOOL(Pack.Invert), NO_EXTRA },
   { GL_PIXEL_MAP_A_TO_A_SIZE, CONTEXT_INT(PixelMaps.AtoA.Size), NO_EXTRA },
   { GL_PIXEL_MAP_B_TO_B_SIZE, CONTEXT_INT(PixelMaps.BtoB.Size), NO_EXTRA },
   { GL_PIXEL_MAP_G_TO_G_SIZE, CONTEXT_INT(PixelMaps.GtoG.Size), NO_EXTRA },
   { GL_PIXEL_MAP_I_TO_A_SIZE, CONTEXT_INT(PixelMaps.ItoA.Size), NO_EXTRA },
   { GL_PIXEL_MAP_I_TO_B_SIZE, CONTEXT_INT(PixelMaps.ItoB.Size), NO_EXTRA },
   { GL_PIXEL_MAP_I_TO_G_SIZE, CONTEXT_INT(PixelMaps.ItoG.Size), NO_EXTRA },
   { GL_PIXEL_MAP_I_TO_I_SIZE, CONTEXT_INT(PixelMaps.ItoI.Size), NO_EXTRA },
   { GL_PIXEL_MAP_I_TO_R_SIZE, CONTEXT_INT(PixelMaps.ItoR.Size), NO_EXTRA },
   { GL_PIXEL_MAP_R_TO_R_SIZE, CONTEXT_INT(PixelMaps.RtoR.Size), NO_EXTRA },
   { GL_PIXEL_MAP_S_TO_S_SIZE, CONTEXT_INT(PixelMaps.StoS.Size), NO_EXTRA },
   { GL_POINT_SIZE_GRANULARITY, CONTEXT_FLOAT(Const.PointSizeGranularity), NO_EXTRA },
   { GL_POLYGON_MODE, CONTEXT_ENUM2(Polygon.FrontMode), NO_EXTRA },
   { GL_POLYGON_OFFSET_BIAS_EXT, CONTEXT_FLOAT(Polygon.OffsetUnits), NO_EXTRA },
   { GL_POLYGON_OFFSET_POINT, CONTEXT_BOOL(Polygon.OffsetPoint), NO_EXTRA },
   { GL_POLYGON_OFFSET_LINE, CONTEXT_BOOL(Polygon.OffsetLine), NO_EXTRA },
   { GL_POLYGON_SMOOTH, CONTEXT_BOOL(Polygon.SmoothFlag), NO_EXTRA },
   { GL_POLYGON_SMOOTH_HINT, CONTEXT_ENUM(Hint.PolygonSmooth), NO_EXTRA },
   { GL_POLYGON_STIPPLE, CONTEXT_BOOL(Polygon.StippleFlag), NO_EXTRA },
   { GL_READ_BUFFER, LOC_CUSTOM, TYPE_ENUM, NO_OFFSET, NO_EXTRA },
   { GL_RED_BIAS, CONTEXT_FLOAT(Pixel.RedBias), NO_EXTRA },
   { GL_RED_SCALE, CONTEXT_FLOAT(Pixel.RedScale), NO_EXTRA },
   { GL_RENDER_MODE, CONTEXT_ENUM(RenderMode), NO_EXTRA },
   { GL_RGBA_MODE, CONST(1), NO_EXTRA },
   { GL_SELECTION_BUFFER_SIZE, CONTEXT_INT(Select.BufferSize), NO_EXTRA },
   { GL_SHARED_TEXTURE_PALETTE_EXT, CONTEXT_BOOL(Texture.SharedPalette), NO_EXTRA },

   { GL_STEREO, BUFFER_INT(Visual.stereoMode), NO_EXTRA },

   { GL_TEXTURE_1D, LOC_CUSTOM, TYPE_BOOLEAN, NO_OFFSET, NO_EXTRA },
   { GL_TEXTURE_3D, LOC_CUSTOM, TYPE_BOOLEAN, NO_OFFSET, NO_EXTRA },
   { GL_TEXTURE_1D_ARRAY_EXT, LOC_CUSTOM, TYPE_BOOLEAN, NO_OFFSET, NO_EXTRA },
   { GL_TEXTURE_2D_ARRAY_EXT, LOC_CUSTOM, TYPE_BOOLEAN, NO_OFFSET, NO_EXTRA },

   { GL_TEXTURE_BINDING_1D, LOC_CUSTOM, TYPE_INT, TEXTURE_1D_INDEX, NO_EXTRA },
   { GL_TEXTURE_BINDING_1D_ARRAY, LOC_CUSTOM, TYPE_INT,
     TEXTURE_1D_ARRAY_INDEX, extra_MESA_texture_array },
   { GL_TEXTURE_BINDING_2D_ARRAY, LOC_CUSTOM, TYPE_INT,
     TEXTURE_1D_ARRAY_INDEX, extra_MESA_texture_array },
   { GL_MAX_ARRAY_TEXTURE_LAYERS_EXT,
     CONTEXT_INT(Const.MaxArrayTextureLayers), extra_MESA_texture_array },

   { GL_TEXTURE_GEN_S, LOC_TEXUNIT, TYPE_BIT_0,
     offsetof(struct gl_texture_unit, TexGenEnabled), NO_EXTRA },
   { GL_TEXTURE_GEN_T, LOC_TEXUNIT, TYPE_BIT_1,
     offsetof(struct gl_texture_unit, TexGenEnabled), NO_EXTRA },
   { GL_TEXTURE_GEN_R, LOC_TEXUNIT, TYPE_BIT_2,
     offsetof(struct gl_texture_unit, TexGenEnabled), NO_EXTRA },
   { GL_TEXTURE_GEN_Q, LOC_TEXUNIT, TYPE_BIT_3,
     offsetof(struct gl_texture_unit, TexGenEnabled), NO_EXTRA },
   { GL_UNPACK_LSB_FIRST, CONTEXT_BOOL(Unpack.LsbFirst), NO_EXTRA },
   { GL_UNPACK_ROW_LENGTH, CONTEXT_INT(Unpack.RowLength), NO_EXTRA },
   { GL_UNPACK_SKIP_PIXELS, CONTEXT_INT(Unpack.SkipPixels), NO_EXTRA },
   { GL_UNPACK_SKIP_ROWS, CONTEXT_INT(Unpack.SkipRows), NO_EXTRA },
   { GL_UNPACK_SWAP_BYTES, CONTEXT_BOOL(Unpack.SwapBytes), NO_EXTRA },
   { GL_UNPACK_SKIP_IMAGES_EXT, CONTEXT_INT(Unpack.SkipImages), NO_EXTRA },
   { GL_UNPACK_IMAGE_HEIGHT_EXT, CONTEXT_INT(Unpack.ImageHeight), NO_EXTRA },
   { GL_UNPACK_CLIENT_STORAGE_APPLE, CONTEXT_BOOL(Unpack.ClientStorage), NO_EXTRA },
   { GL_ZOOM_X, CONTEXT_FLOAT(Pixel.ZoomX), NO_EXTRA },
   { GL_ZOOM_Y, CONTEXT_FLOAT(Pixel.ZoomY), NO_EXTRA },

   /* Vertex arrays */
   { GL_VERTEX_ARRAY_COUNT_EXT, CONST(0), NO_EXTRA },
   { GL_NORMAL_ARRAY_COUNT_EXT, CONST(0), NO_EXTRA },
   { GL_COLOR_ARRAY_COUNT_EXT, CONST(0), NO_EXTRA },
   { GL_INDEX_ARRAY, ARRAY_BOOL(Index.Enabled), NO_EXTRA },
   { GL_INDEX_ARRAY_TYPE, ARRAY_ENUM(Index.Type), NO_EXTRA },
   { GL_INDEX_ARRAY_STRIDE, ARRAY_INT(Index.Stride), NO_EXTRA },
   { GL_INDEX_ARRAY_COUNT_EXT, CONST(0), NO_EXTRA },
   { GL_TEXTURE_COORD_ARRAY_COUNT_EXT, CONST(0), NO_EXTRA },
   { GL_EDGE_FLAG_ARRAY, ARRAY_BOOL(EdgeFlag.Enabled), NO_EXTRA },
   { GL_EDGE_FLAG_ARRAY_STRIDE, ARRAY_INT(EdgeFlag.Stride), NO_EXTRA },
   { GL_EDGE_FLAG_ARRAY_COUNT_EXT, CONST(0), NO_EXTRA },

   /* GL_ARB_texture_compression */
   { GL_TEXTURE_COMPRESSION_HINT_ARB, CONTEXT_INT(Hint.TextureCompression), NO_EXTRA },

   /* GL_EXT_compiled_vertex_array */
   { GL_ARRAY_ELEMENT_LOCK_FIRST_EXT, CONTEXT_INT(Array.LockFirst),
     extra_EXT_compiled_vertex_array },
   { GL_ARRAY_ELEMENT_LOCK_COUNT_EXT, CONTEXT_INT(Array.LockCount),
     extra_EXT_compiled_vertex_array },

   /* GL_ARB_transpose_matrix */
   { GL_TRANSPOSE_MODELVIEW_MATRIX_ARB,
     CONTEXT_MATRIX_T(ModelviewMatrixStack), NO_EXTRA },
   { GL_TRANSPOSE_PROJECTION_MATRIX_ARB,
     CONTEXT_MATRIX_T(ProjectionMatrixStack.Top), NO_EXTRA },
   { GL_TRANSPOSE_TEXTURE_MATRIX_ARB, CONTEXT_MATRIX_T(TextureMatrixStack), NO_EXTRA },

   /* GL_EXT_secondary_color */
   { GL_COLOR_SUM_EXT, CONTEXT_BOOL(Fog.ColorSumEnabled),
     extra_EXT_secondary_color_ARB_vertex_program },
   { GL_CURRENT_SECONDARY_COLOR_EXT,
     CONTEXT_FIELD(Current.Attrib[VERT_ATTRIB_COLOR1][0], TYPE_FLOATN_4),
     extra_EXT_secondary_color_flush_current },
   { GL_SECONDARY_COLOR_ARRAY_EXT, ARRAY_BOOL(SecondaryColor.Enabled),
     extra_EXT_secondary_color },
   { GL_SECONDARY_COLOR_ARRAY_TYPE_EXT, ARRAY_ENUM(SecondaryColor.Type),
     extra_EXT_secondary_color },
   { GL_SECONDARY_COLOR_ARRAY_STRIDE_EXT, ARRAY_INT(SecondaryColor.Stride),
     extra_EXT_secondary_color },
   { GL_SECONDARY_COLOR_ARRAY_SIZE_EXT, ARRAY_INT(SecondaryColor.Size),
     extra_EXT_secondary_color },

   /* GL_EXT_fog_coord */
   { GL_CURRENT_FOG_COORDINATE_EXT,
     CONTEXT_FLOAT(Current.Attrib[VERT_ATTRIB_FOG][0]),
     extra_EXT_fog_coord_flush_current },
   { GL_FOG_COORDINATE_ARRAY_EXT, ARRAY_BOOL(FogCoord.Enabled),
     extra_EXT_fog_coord },
   { GL_FOG_COORDINATE_ARRAY_TYPE_EXT, ARRAY_ENUM(FogCoord.Type),
     extra_EXT_fog_coord },
   { GL_FOG_COORDINATE_ARRAY_STRIDE_EXT, ARRAY_INT(FogCoord.Stride),
     extra_EXT_fog_coord },
   { GL_FOG_COORDINATE_SOURCE_EXT, CONTEXT_ENUM(Fog.FogCoordinateSource),
     extra_EXT_fog_coord },

   /* GL_IBM_rasterpos_clip */
   { GL_RASTER_POSITION_UNCLIPPED_IBM,
     CONTEXT_BOOL(Transform.RasterPositionUnclipped),
     extra_IBM_rasterpos_clip },

   /* GL_NV_point_sprite */
   { GL_POINT_SPRITE_R_MODE_NV,
     CONTEXT_ENUM(Point.SpriteRMode), extra_NV_point_sprite },
   { GL_POINT_SPRITE_COORD_ORIGIN, CONTEXT_ENUM(Point.SpriteOrigin),
     extra_NV_point_sprite_ARB_point_sprite },

   /* GL_NV_vertex_program */
   { GL_VERTEX_PROGRAM_BINDING_NV, LOC_CUSTOM, TYPE_INT, 0,
     extra_NV_vertex_program },
   { GL_VERTEX_ATTRIB_ARRAY0_NV, ARRAY_BOOL(VertexAttrib[0].Enabled),
     extra_NV_vertex_program },
   { GL_VERTEX_ATTRIB_ARRAY1_NV, ARRAY_BOOL(VertexAttrib[1].Enabled),
     extra_NV_vertex_program },
   { GL_VERTEX_ATTRIB_ARRAY2_NV, ARRAY_BOOL(VertexAttrib[2].Enabled),
     extra_NV_vertex_program },
   { GL_VERTEX_ATTRIB_ARRAY3_NV, ARRAY_BOOL(VertexAttrib[3].Enabled),
     extra_NV_vertex_program },
   { GL_VERTEX_ATTRIB_ARRAY4_NV, ARRAY_BOOL(VertexAttrib[4].Enabled),
     extra_NV_vertex_program },
   { GL_VERTEX_ATTRIB_ARRAY5_NV, ARRAY_BOOL(VertexAttrib[5].Enabled),
     extra_NV_vertex_program },
   { GL_VERTEX_ATTRIB_ARRAY6_NV, ARRAY_BOOL(VertexAttrib[6].Enabled),
     extra_NV_vertex_program },
   { GL_VERTEX_ATTRIB_ARRAY7_NV, ARRAY_BOOL(VertexAttrib[7].Enabled),
     extra_NV_vertex_program },
   { GL_VERTEX_ATTRIB_ARRAY8_NV, ARRAY_BOOL(VertexAttrib[8].Enabled),
     extra_NV_vertex_program },
   { GL_VERTEX_ATTRIB_ARRAY9_NV, ARRAY_BOOL(VertexAttrib[9].Enabled),
     extra_NV_vertex_program },
   { GL_VERTEX_ATTRIB_ARRAY10_NV, ARRAY_BOOL(VertexAttrib[10].Enabled),
     extra_NV_vertex_program },
   { GL_VERTEX_ATTRIB_ARRAY11_NV, ARRAY_BOOL(VertexAttrib[11].Enabled),
     extra_NV_vertex_program },
   { GL_VERTEX_ATTRIB_ARRAY12_NV, ARRAY_BOOL(VertexAttrib[12].Enabled),
     extra_NV_vertex_program },
   { GL_VERTEX_ATTRIB_ARRAY13_NV, ARRAY_BOOL(VertexAttrib[13].Enabled),
     extra_NV_vertex_program },
   { GL_VERTEX_ATTRIB_ARRAY14_NV, ARRAY_BOOL(VertexAttrib[14].Enabled),
     extra_NV_vertex_program },
   { GL_VERTEX_ATTRIB_ARRAY15_NV, ARRAY_BOOL(VertexAttrib[15].Enabled),
     extra_NV_vertex_program },
   { GL_MAP1_VERTEX_ATTRIB0_4_NV, CONTEXT_BOOL(Eval.Map1Attrib[0]),
     extra_NV_vertex_program },
   { GL_MAP1_VERTEX_ATTRIB1_4_NV, CONTEXT_BOOL(Eval.Map1Attrib[1]),
     extra_NV_vertex_program },
   { GL_MAP1_VERTEX_ATTRIB2_4_NV, CONTEXT_BOOL(Eval.Map1Attrib[2]),
     extra_NV_vertex_program },
   { GL_MAP1_VERTEX_ATTRIB3_4_NV, CONTEXT_BOOL(Eval.Map1Attrib[3]),
     extra_NV_vertex_program },
   { GL_MAP1_VERTEX_ATTRIB4_4_NV, CONTEXT_BOOL(Eval.Map1Attrib[4]),
     extra_NV_vertex_program },
   { GL_MAP1_VERTEX_ATTRIB5_4_NV, CONTEXT_BOOL(Eval.Map1Attrib[5]),
     extra_NV_vertex_program },
   { GL_MAP1_VERTEX_ATTRIB6_4_NV, CONTEXT_BOOL(Eval.Map1Attrib[6]),
     extra_NV_vertex_program },
   { GL_MAP1_VERTEX_ATTRIB7_4_NV, CONTEXT_BOOL(Eval.Map1Attrib[7]),
     extra_NV_vertex_program },
   { GL_MAP1_VERTEX_ATTRIB8_4_NV, CONTEXT_BOOL(Eval.Map1Attrib[8]),
     extra_NV_vertex_program },
   { GL_MAP1_VERTEX_ATTRIB9_4_NV, CONTEXT_BOOL(Eval.Map1Attrib[9]),
     extra_NV_vertex_program },
   { GL_MAP1_VERTEX_ATTRIB10_4_NV, CONTEXT_BOOL(Eval.Map1Attrib[10]),
     extra_NV_vertex_program },
   { GL_MAP1_VERTEX_ATTRIB11_4_NV, CONTEXT_BOOL(Eval.Map1Attrib[11]),
     extra_NV_vertex_program },
   { GL_MAP1_VERTEX_ATTRIB12_4_NV, CONTEXT_BOOL(Eval.Map1Attrib[12]),
     extra_NV_vertex_program },
   { GL_MAP1_VERTEX_ATTRIB13_4_NV, CONTEXT_BOOL(Eval.Map1Attrib[13]),
     extra_NV_vertex_program },
   { GL_MAP1_VERTEX_ATTRIB14_4_NV, CONTEXT_BOOL(Eval.Map1Attrib[14]),
     extra_NV_vertex_program },
   { GL_MAP1_VERTEX_ATTRIB15_4_NV, CONTEXT_BOOL(Eval.Map1Attrib[15]),
     extra_NV_vertex_program },

   /* GL_NV_fragment_program */
   { GL_FRAGMENT_PROGRAM_NV, CONTEXT_BOOL(FragmentProgram.Enabled),
     extra_NV_fragment_program },
   { GL_FRAGMENT_PROGRAM_BINDING_NV, LOC_CUSTOM, TYPE_INT, 0,
     extra_NV_fragment_program },
   { GL_MAX_FRAGMENT_PROGRAM_LOCAL_PARAMETERS_NV,
     CONST(MAX_NV_FRAGMENT_PROGRAM_PARAMS),
     extra_NV_fragment_program },

   /* GL_NV_texture_rectangle */
   { GL_TEXTURE_RECTANGLE_NV,
     LOC_CUSTOM, TYPE_BOOLEAN, 0, extra_NV_texture_rectangle },
   { GL_TEXTURE_BINDING_RECTANGLE_NV,
     LOC_CUSTOM, TYPE_INT, TEXTURE_RECT_INDEX, extra_NV_texture_rectangle },
   { GL_MAX_RECTANGLE_TEXTURE_SIZE_NV,
     CONTEXT_INT(Const.MaxTextureRectSize), extra_NV_texture_rectangle },

   /* GL_EXT_stencil_two_side */
   { GL_STENCIL_TEST_TWO_SIDE_EXT, CONTEXT_BOOL(Stencil.TestTwoSide),
	 extra_EXT_stencil_two_side },
   { GL_ACTIVE_STENCIL_FACE_EXT, LOC_CUSTOM, TYPE_ENUM, NO_OFFSET, NO_EXTRA },

   /* GL_NV_light_max_exponent */
   { GL_MAX_SHININESS_NV, CONTEXT_FLOAT(Const.MaxShininess),
     extra_NV_light_max_exponent },
   { GL_MAX_SPOT_EXPONENT_NV, CONTEXT_FLOAT(Const.MaxSpotExponent),
     extra_NV_light_max_exponent },
     
   /* GL_NV_primitive_restart */
   { GL_PRIMITIVE_RESTART_NV, CONTEXT_BOOL(Array.PrimitiveRestart),
     extra_NV_primitive_restart },
   { GL_PRIMITIVE_RESTART_INDEX_NV, CONTEXT_INT(Array.RestartIndex),
     extra_NV_primitive_restart },
 
   /* GL_ARB_vertex_buffer_object */
   { GL_INDEX_ARRAY_BUFFER_BINDING_ARB, LOC_CUSTOM, TYPE_INT,
     offsetof(struct gl_array_object, Index.BufferObj), NO_EXTRA },
   { GL_EDGE_FLAG_ARRAY_BUFFER_BINDING_ARB, LOC_CUSTOM, TYPE_INT,
     offsetof(struct gl_array_object, EdgeFlag.BufferObj), NO_EXTRA },
   { GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING_ARB, LOC_CUSTOM, TYPE_INT,
     offsetof(struct gl_array_object, SecondaryColor.BufferObj), NO_EXTRA },
   { GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING_ARB, LOC_CUSTOM, TYPE_INT,
     offsetof(struct gl_array_object, FogCoord.BufferObj), NO_EXTRA },

   /* GL_EXT_pixel_buffer_object */
   { GL_PIXEL_PACK_BUFFER_BINDING_EXT, LOC_CUSTOM, TYPE_INT, 0,
     extra_EXT_pixel_buffer_object },
   { GL_PIXEL_UNPACK_BUFFER_BINDING_EXT, LOC_CUSTOM, TYPE_INT, 0,
     extra_EXT_pixel_buffer_object },

   /* GL_ARB_vertex_program */
   { GL_VERTEX_PROGRAM_ARB, /* == GL_VERTEX_PROGRAM_NV */
     CONTEXT_BOOL(VertexProgram.Enabled),
     extra_ARB_vertex_program_NV_vertex_program },
   { GL_VERTEX_PROGRAM_POINT_SIZE_ARB, /* == GL_VERTEX_PROGRAM_POINT_SIZE_NV*/
     CONTEXT_BOOL(VertexProgram.PointSizeEnabled),
     extra_ARB_vertex_program_NV_vertex_program },
   { GL_VERTEX_PROGRAM_TWO_SIDE_ARB, /* == GL_VERTEX_PROGRAM_TWO_SIDE_NV */
     CONTEXT_BOOL(VertexProgram.TwoSideEnabled),
     extra_ARB_vertex_program_NV_vertex_program },
   { GL_MAX_PROGRAM_MATRIX_STACK_DEPTH_ARB, /* == GL_MAX_TRACK_MATRIX_STACK_DEPTH_NV */
     CONTEXT_INT(Const.MaxProgramMatrixStackDepth),
     extra_ARB_vertex_program_ARB_fragment_program_NV_vertex_program },
   { GL_MAX_PROGRAM_MATRICES_ARB, /* == GL_MAX_TRACK_MATRICES_NV */
     CONTEXT_INT(Const.MaxProgramMatrices),
     extra_ARB_vertex_program_ARB_fragment_program_NV_vertex_program },
   { GL_CURRENT_MATRIX_STACK_DEPTH_ARB, /* == GL_CURRENT_MATRIX_STACK_DEPTH_NV */
     LOC_CUSTOM, TYPE_INT, 0,
     extra_ARB_vertex_program_ARB_fragment_program_NV_vertex_program },

   { GL_CURRENT_MATRIX_ARB, /* == GL_CURRENT_MATRIX_NV */
     LOC_CUSTOM, TYPE_MATRIX, 0,
     extra_ARB_vertex_program_ARB_fragment_program_NV_vertex_program },
   { GL_TRANSPOSE_CURRENT_MATRIX_ARB, /* == GL_CURRENT_MATRIX_NV */
     LOC_CUSTOM, TYPE_MATRIX, 0,
     extra_ARB_vertex_program_ARB_fragment_program },

   { GL_PROGRAM_ERROR_POSITION_ARB, /* == GL_PROGRAM_ERROR_POSITION_NV */
     CONTEXT_INT(Program.ErrorPos),
     extra_NV_vertex_program_ARB_vertex_program_ARB_fragment_program_NV_vertex_program },

   /* GL_ARB_fragment_program */
   { GL_FRAGMENT_PROGRAM_ARB, CONTEXT_BOOL(FragmentProgram.Enabled),
     extra_ARB_fragment_program },

   /* GL_EXT_depth_bounds_test */
   { GL_DEPTH_BOUNDS_TEST_EXT, CONTEXT_BOOL(Depth.BoundsTest),
     extra_EXT_depth_bounds_test },
   { GL_DEPTH_BOUNDS_EXT, CONTEXT_FLOAT2(Depth.BoundsMin),
     extra_EXT_depth_bounds_test },

   /* GL_ARB_depth_clamp*/
   { GL_DEPTH_CLAMP, CONTEXT_BOOL(Transform.DepthClamp),
     extra_ARB_depth_clamp },

   /* GL_ARB_draw_buffers */
   { GL_DRAW_BUFFER0_ARB, BUFFER_ENUM(ColorDrawBuffer[0]), NO_EXTRA },
   { GL_DRAW_BUFFER1_ARB, BUFFER_ENUM(ColorDrawBuffer[1]),
     extra_valid_draw_buffer },
   { GL_DRAW_BUFFER2_ARB, BUFFER_ENUM(ColorDrawBuffer[2]),
     extra_valid_draw_buffer },
   { GL_DRAW_BUFFER3_ARB, BUFFER_ENUM(ColorDrawBuffer[3]),
     extra_valid_draw_buffer },
   { GL_DRAW_BUFFER4_ARB, BUFFER_ENUM(ColorDrawBuffer[4]),
     extra_valid_draw_buffer },
   { GL_DRAW_BUFFER5_ARB, BUFFER_ENUM(ColorDrawBuffer[5]),
     extra_valid_draw_buffer },
   { GL_DRAW_BUFFER6_ARB, BUFFER_ENUM(ColorDrawBuffer[6]),
     extra_valid_draw_buffer },
   { GL_DRAW_BUFFER7_ARB, BUFFER_ENUM(ColorDrawBuffer[7]),
     extra_valid_draw_buffer },

   /* GL_ATI_fragment_shader */
   { GL_NUM_FRAGMENT_REGISTERS_ATI, CONST(6), extra_ATI_fragment_shader },
   { GL_NUM_FRAGMENT_CONSTANTS_ATI, CONST(8), extra_ATI_fragment_shader },
   { GL_NUM_PASSES_ATI, CONST(2), extra_ATI_fragment_shader },
   { GL_NUM_INSTRUCTIONS_PER_PASS_ATI, CONST(8), extra_ATI_fragment_shader },
   { GL_NUM_INSTRUCTIONS_TOTAL_ATI, CONST(16), extra_ATI_fragment_shader },
   { GL_COLOR_ALPHA_PAIRING_ATI, CONST(GL_TRUE), extra_ATI_fragment_shader },
   { GL_NUM_LOOPBACK_COMPONENTS_ATI, CONST(3), extra_ATI_fragment_shader },
   { GL_NUM_INPUT_INTERPOLATOR_COMPONENTS_ATI,
     CONST(3), extra_ATI_fragment_shader },

   /* GL_EXT_framebuffer_object */
   { GL_MAX_COLOR_ATTACHMENTS_EXT, CONTEXT_INT(Const.MaxColorAttachments),
     extra_EXT_framebuffer_object },
   
   /* GL_EXT_framebuffer_blit
    * NOTE: GL_DRAW_FRAMEBUFFER_BINDING_EXT == GL_FRAMEBUFFER_BINDING_EXT */
   { GL_READ_FRAMEBUFFER_BINDING_EXT, LOC_CUSTOM, TYPE_INT, 0,
     extra_EXT_framebuffer_blit },

   /* GL_EXT_provoking_vertex */
   { GL_PROVOKING_VERTEX_EXT,
     CONTEXT_ENUM(Light.ProvokingVertex), extra_EXT_provoking_vertex },
   { GL_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION_EXT,
     CONTEXT_BOOL(Const.QuadsFollowProvokingVertexConvention),
     extra_EXT_provoking_vertex },

   /* GL_ARB_framebuffer_object */
   { GL_MAX_SAMPLES, CONTEXT_INT(Const.MaxSamples),
     extra_ARB_framebuffer_object_EXT_framebuffer_multisample },

   /* GL_APPLE_vertex_array_object */
   { GL_VERTEX_ARRAY_BINDING_APPLE, ARRAY_INT(Name),
     extra_APPLE_vertex_array_object },

   /* GL_ARB_seamless_cube_map */
   { GL_TEXTURE_CUBE_MAP_SEAMLESS,
     CONTEXT_BOOL(Texture.CubeMapSeamless), extra_ARB_seamless_cube_map },

   /* GL_ARB_sync */
   { GL_MAX_SERVER_WAIT_TIMEOUT,
     CONTEXT_INT64(Const.MaxServerWaitTimeout), extra_ARB_sync },

   /* GL_EXT_texture_integer */
   { GL_RGBA_INTEGER_MODE_EXT, BUFFER_BOOL(_IntegerColor),
     extra_EXT_texture_integer },

   /* GL_EXT_transform_feedback */
   { GL_TRANSFORM_FEEDBACK_BUFFER_BINDING, LOC_CUSTOM, TYPE_INT, 0,
     extra_EXT_transform_feedback },
   { GL_RASTERIZER_DISCARD, CONTEXT_BOOL(TransformFeedback.RasterDiscard),
     extra_EXT_transform_feedback },
   { GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS,
     CONTEXT_INT(Const.MaxTransformFeedbackInterleavedComponents),
     extra_EXT_transform_feedback },
   { GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS,
     CONTEXT_INT(Const.MaxTransformFeedbackSeparateAttribs),
     extra_EXT_transform_feedback },
   { GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS,
     CONTEXT_INT(Const.MaxTransformFeedbackSeparateComponents),
     extra_EXT_transform_feedback },

   /* GL_ARB_transform_feedback2 */
   { GL_TRANSFORM_FEEDBACK_BUFFER_PAUSED, LOC_CUSTOM, TYPE_BOOLEAN, 0,
     extra_ARB_transform_feedback2 },
   { GL_TRANSFORM_FEEDBACK_BUFFER_ACTIVE, LOC_CUSTOM, TYPE_BOOLEAN, 0,
     extra_ARB_transform_feedback2 },
   { GL_TRANSFORM_FEEDBACK_BINDING, LOC_CUSTOM, TYPE_INT, 0,
     extra_ARB_transform_feedback2 },

   /* GL_ARB_geometry_shader4 */
   { GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS_ARB,
     CONTEXT_INT(Const.MaxGeometryTextureImageUnits),
     extra_ARB_geometry_shader4 },
   { GL_MAX_GEOMETRY_OUTPUT_VERTICES_ARB,
     CONTEXT_INT(Const.MaxGeometryOutputVertices),
     extra_ARB_geometry_shader4 },
   { GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS_ARB,
     CONTEXT_INT(Const.MaxGeometryTotalOutputComponents),
     extra_ARB_geometry_shader4 },
   { GL_MAX_GEOMETRY_UNIFORM_COMPONENTS_ARB,
     CONTEXT_INT(Const.GeometryProgram.MaxUniformComponents),
     extra_ARB_geometry_shader4 },
   { GL_MAX_GEOMETRY_VARYING_COMPONENTS_ARB,
     CONTEXT_INT(Const.MaxGeometryVaryingComponents),
     extra_ARB_geometry_shader4 },
   { GL_MAX_VERTEX_VARYING_COMPONENTS_ARB,
     CONTEXT_INT(Const.MaxVertexVaryingComponents),
     extra_ARB_geometry_shader4 },

   /* GL_ARB_color_buffer_float */
   { GL_RGBA_FLOAT_MODE_ARB, BUFFER_FIELD(Visual.floatMode, TYPE_BOOLEAN), 0 },

   /* GL_EXT_gpu_shader4 / GL 3.0 */
   { GL_MIN_PROGRAM_TEXEL_OFFSET,
     CONTEXT_INT(Const.MinProgramTexelOffset),
     extra_EXT_gpu_shader4 },
   { GL_MAX_PROGRAM_TEXEL_OFFSET,
     CONTEXT_INT(Const.MaxProgramTexelOffset),
     extra_EXT_gpu_shader4 },

   /* GL_ARB_texture_buffer_object */
   { GL_MAX_TEXTURE_BUFFER_SIZE_ARB, CONTEXT_INT(Const.MaxTextureBufferSize),
     extra_ARB_texture_buffer_object },
   { GL_TEXTURE_BINDING_BUFFER_ARB, LOC_CUSTOM, TYPE_INT, 0,
     extra_ARB_texture_buffer_object },
   { GL_TEXTURE_BUFFER_DATA_STORE_BINDING_ARB, LOC_CUSTOM, TYPE_INT,
     TEXTURE_BUFFER_INDEX, extra_ARB_texture_buffer_object },
   { GL_TEXTURE_BUFFER_FORMAT_ARB, LOC_CUSTOM, TYPE_INT, 0,
     extra_ARB_texture_buffer_object },
   { GL_TEXTURE_BUFFER_ARB, LOC_CUSTOM, TYPE_INT, 0,
     extra_ARB_texture_buffer_object },

   /* GL_ARB_sampler_objects / GL 3.3 */
   { GL_SAMPLER_BINDING,
     LOC_CUSTOM, TYPE_INT, GL_SAMPLER_BINDING, extra_ARB_sampler_objects },

   /* GL 3.0 */
   { GL_NUM_EXTENSIONS, LOC_CUSTOM, TYPE_INT, 0, extra_version_30 },
   { GL_MAJOR_VERSION, CONTEXT_INT(VersionMajor), extra_version_30 },
   { GL_MINOR_VERSION, CONTEXT_INT(VersionMinor), extra_version_30  },
   { GL_CONTEXT_FLAGS, CONTEXT_INT(Const.ContextFlags), extra_version_30  },

   /* GL3.0 / GL_EXT_framebuffer_sRGB */
   { GL_FRAMEBUFFER_SRGB_EXT, CONTEXT_BOOL(Color.sRGBEnabled), extra_EXT_framebuffer_sRGB },
   { GL_FRAMEBUFFER_SRGB_CAPABLE_EXT, BUFFER_INT(Visual.sRGBCapable), extra_EXT_framebuffer_sRGB },

   /* GL 3.1 */
   /* NOTE: different enum values for GL_PRIMITIVE_RESTART_NV
    * vs. GL_PRIMITIVE_RESTART!
    */
   { GL_PRIMITIVE_RESTART, CONTEXT_BOOL(Array.PrimitiveRestart),
     extra_version_31 },
   { GL_PRIMITIVE_RESTART_INDEX, CONTEXT_INT(Array.RestartIndex),
     extra_version_31 },
 

   /* GL 3.2 */
   { GL_CONTEXT_PROFILE_MASK, CONTEXT_INT(Const.ProfileMask),
     extra_version_32 },

   /* GL_ARB_robustness */
   { GL_RESET_NOTIFICATION_STRATEGY_ARB, CONTEXT_ENUM(Const.ResetStrategy), NO_EXTRA },
#endif /* FEATURE_GL */
};
a445 3
static unsigned short table[1024];
static const int prime_factor = 89, prime_step = 281;

d448 1
a448 1
print_table_stats(void)
d452 7
d460 1
d462 1
a462 1
   mask = Elements(table) - 1;
d465 3
a467 3
   for (i = 0; i < Elements(table); i++) {
      if (!table[i])
	 continue;
d469 1
a469 1
      d = &values[table[i]];
d473 4
a476 4
	 if (values[table[hash & mask]].pname == d->pname)
	    break;
	 hash += prime_step;
	 j++;
d480 1
a480 1
	 collisions[j]++;
d482 1
a482 1
	 collisions[10]++;
d485 2
a486 1
   printf("number of enums: %d (total %d)\n", count, Elements(values));
d489 2
a490 2
	 printf("  %d enums with %d %scollisions\n",
		collisions[i], i, i == 10 ? "or more " : "");
a503 25
   int i, hash, index, mask;
   int api_mask = 0, api_bit;

   mask = Elements(table) - 1;
   api_bit = 1 << ctx->API;

   for (i = 0; i < Elements(values); i++) {
      if (values[i].type == TYPE_API_MASK) {
	 api_mask = values[i].offset;
	 continue;
      }
      if (!(api_mask & api_bit))
	 continue;

      hash = (values[i].pname * prime_factor) & mask;
      while (1) {
	 index = hash & mask;
	 if (!table[index]) {
	    table[index] = i;
	    break;
	 }
	 hash += prime_step;
      }
   }

d533 7
d547 1
d608 1
a608 1
      array = &ctx->Array.ArrayObj->TexCoord[ctx->Array.ActiveTexture];
d675 4
a678 1
      v->value_int = ctx->Stencil.Ref[ctx->Stencil.ActiveFace];
d716 1
d729 4
d755 1
a755 1
	 ctx->Array.ArrayObj->TexCoord[ctx->Array.ActiveTexture].BufferObj->Name;
d758 1
a758 1
      v->value_int = ctx->Array.ElementArrayBufferObj->Name;
a768 8
   case GL_FRAGMENT_PROGRAM_BINDING_NV:
      v->value_int = 
	 ctx->FragmentProgram.Current ? ctx->FragmentProgram.Current->Base.Id : 0;
      break;
   case GL_VERTEX_PROGRAM_BINDING_NV:
      v->value_int =
	 ctx->VertexProgram.Current ? ctx->VertexProgram.Current->Base.Id : 0;
      break;
d799 1
a799 1
      v->value_int = ctx->Array.ArrayObj->PointSize.BufferObj->Name;
d803 1
a803 1
      if(ctx->Color._ClampFragmentColor)
d809 7
a815 4
      if(ctx->Color._ClampFragmentColor)
         COPY_4FV(v->value_float_4, ctx->Color.ClearColor);
      else
         COPY_4FV(v->value_float_4, ctx->Color.ClearColorUnclamped);
d818 1
a818 1
      if(ctx->Color._ClampFragmentColor)
d824 1
a824 1
      if(ctx->Color._ClampFragmentColor)
d864 23
a886 1
         v->value_int = samp ? samp->Name : 0;
d889 1
a889 1
   }   
d904 1
a904 1
 * \return GL_FALSE if one of the constraints was not satisfied,
d910 3
a912 2
   const GLuint version = ctx->VersionMajor * 10 + ctx->VersionMinor;
   int total, enabled;
d915 1
a915 3
   total = 0;
   enabled = 0;
   for (e = d->extra; *e != EXTRA_END; e++)
d918 3
a920 4
	 if (version >= 30) {
	    total++;
	    enabled++;
	 }
d923 3
a925 4
	 if (version >= 31) {
	    total++;
	    enabled++;
	 }
d928 3
a930 4
	 if (version >= 32) {
	    total++;
	    enabled++;
	 }
d936 19
a954 5
      case EXTRA_VERSION_ES2:
	 if (ctx->API == API_OPENGLES2) {
	    total++;
	    enabled++;
	 }
d977 17
d997 1
a997 1
	 total++;
d999 1
a999 1
	    enabled++;
d1002 1
d1004 1
a1004 1
   if (total > 0 && enabled == 0) {
d1045 1
d1047 11
a1057 1
   mask = Elements(table) - 1;
d1060 1
a1060 1
      d = &values[table[hash & mask]];
d1063 6
a1068 5
       * which is the API mask entry at the beginning of values[]. */
      if (unlikely(d->type == TYPE_API_MASK)) {
	 _mesa_error(ctx, GL_INVALID_ENUM, "%s(pname=%s)", func,
                     _mesa_lookup_enum_by_nr(pname));
	 return &error_value;
d1071 1
d1073 1
a1073 1
	 break;
a1122 3
   GET_CURRENT_CONTEXT(ctx);

   ASSERT_OUTSIDE_BEGIN_END(ctx);
d1193 2
a1208 3
   GET_CURRENT_CONTEXT(ctx);

   ASSERT_OUTSIDE_BEGIN_END(ctx);
d1233 1
a1233 1
      params[0] = ((GLdouble *) p)[0];
d1254 1
a1254 1
      params[0] = ((GLint64 *) p)[0];
d1279 2
a1294 3
   GET_CURRENT_CONTEXT(ctx);

   ASSERT_OUTSIDE_BEGIN_END(ctx);
d1371 2
a1378 1
#if FEATURE_ARB_sync
a1386 3
   GET_CURRENT_CONTEXT(ctx);

   ASSERT_OUTSIDE_BEGIN_END(ctx);
d1463 2
a1469 1
#endif /* FEATURE_ARB_sync */
a1478 3
   GET_CURRENT_CONTEXT(ctx);

   ASSERT_OUTSIDE_BEGIN_END(ctx);
d1524 1
a1524 1
      params[0] = ((GLint64 *) p)[0];
d1549 2
d1558 1
a1558 1
find_value_indexed(const char *func, GLenum pname, int index, union value *v)
d1631 1
a1631 1
      if (index >= ctx->Const.MaxTransformFeedbackSeparateAttribs)
d1639 1
a1639 1
      if (index >= ctx->Const.MaxTransformFeedbackSeparateAttribs)
d1643 2
a1644 1
      v->value_int64 = ctx->TransformFeedback.CurrentObject->Size[index];
d1648 1
a1648 1
      if (index >= ctx->Const.MaxTransformFeedbackSeparateAttribs)
d1652 34
a1685 1
      v->value_int = ctx->TransformFeedback.CurrentObject->Buffers[index]->Name;
d1700 1
a1700 1
_mesa_GetBooleanIndexedv( GLenum pname, GLuint index, GLboolean *params )
d1704 1
a1704 1
      find_value_indexed("glGetBooleanIndexedv", pname, index, &v);
d1725 1
a1725 1
_mesa_GetIntegerIndexedv( GLenum pname, GLuint index, GLint *params )
d1729 1
a1729 1
      find_value_indexed("glGetIntegerIndexedv", pname, index, &v);
a1748 1
#if FEATURE_ARB_sync
d1750 1
a1750 1
_mesa_GetInteger64Indexedv( GLenum pname, GLuint index, GLint64 *params )
d1754 1
a1754 1
      find_value_indexed("glGetIntegerIndexedv", pname, index, &v);      
a1772 1
#endif /* FEATURE_ARB_sync */
a1773 1
#if FEATURE_ES1
d1852 2
a1858 1
#endif
@


1.6
log
@Merge Mesa 7.10.3
@
text
@d32 1
d134 1
d227 5
d281 5
a303 1
EXTRA_EXT(SGI_texture_color_table);
d330 2
d387 1
a387 1
   { GL_BLEND_SRC, CONTEXT_ENUM(Color.BlendSrcRGB), NO_EXTRA },
d389 1
a389 1
   { GL_COLOR_CLEAR_VALUE, CONTEXT_FIELD(Color.ClearColor[0], TYPE_FLOATN_4), NO_EXTRA },
d450 4
a453 4
   { GL_BLEND_SRC_RGB_EXT, CONTEXT_ENUM(Color.BlendSrcRGB), NO_EXTRA },
   { GL_BLEND_DST_RGB_EXT, CONTEXT_ENUM(Color.BlendDstRGB), NO_EXTRA },
   { GL_BLEND_SRC_ALPHA_EXT, CONTEXT_ENUM(Color.BlendSrcA), NO_EXTRA },
   { GL_BLEND_DST_ALPHA_EXT, CONTEXT_ENUM(Color.BlendDstA), NO_EXTRA },
d457 2
a458 2
   { GL_BLEND_EQUATION, CONTEXT_ENUM(Color.BlendEquationRGB), NO_EXTRA },
   { GL_BLEND_EQUATION_ALPHA_EXT, CONTEXT_ENUM(Color.BlendEquationA), NO_EXTRA },
d512 1
d527 2
a528 2
   { GL_ALPHA_TEST_REF, CONTEXT_FIELD(Color.AlphaRef, TYPE_FLOATN), NO_EXTRA },
   { GL_BLEND_DST, CONTEXT_ENUM(Color.BlendDstRGB), NO_EXTRA },
d546 1
a546 1
   { GL_FOG_COLOR, CONTEXT_FIELD(Fog.Color[0], TYPE_FLOATN_4), NO_EXTRA },
a680 2
   /* This entry isn't spec'ed for GLES 2, but is needed for Mesa's GLSL: */
   { GL_MAX_LIGHTS, CONTEXT_INT(Const.MaxLights), NO_EXTRA },
d688 1
a688 1
   { GL_BLEND_COLOR_EXT, CONTEXT_FIELD(Color.BlendColor[0], TYPE_FLOATN_4), NO_EXTRA },
a923 5
   /* GL_SGI_texture_color_table */
   { GL_TEXTURE_COLOR_TABLE_SGI, LOC_TEXUNIT, TYPE_BOOLEAN,
     offsetof(struct gl_texture_unit, ColorTableEnabled),
     extra_SGI_texture_color_table },

d1215 1
a1215 1
     CONTEXT_INT(Const.GeometryProgram.MaxGeometryTextureImageUnits),
d1218 1
a1218 1
     CONTEXT_INT(Const.GeometryProgram.MaxGeometryOutputVertices),
d1221 1
a1221 1
     CONTEXT_INT(Const.GeometryProgram.MaxGeometryTotalOutputComponents),
d1224 1
a1224 1
     CONTEXT_INT(Const.GeometryProgram.MaxGeometryUniformComponents),
d1227 1
a1227 1
     CONTEXT_INT(Const.GeometryProgram.MaxGeometryVaryingComponents),
d1230 1
a1230 1
     CONTEXT_INT(Const.GeometryProgram.MaxVertexVaryingComponents),
d1233 3
d1244 16
d1266 4
d1283 3
d1571 1
a1571 1
      v->value_int = _mesa_get_compressed_formats(ctx, NULL, GL_FALSE);
d1575 1
a1575 1
	 _mesa_get_compressed_formats(ctx, v->value_int_n.ints, GL_FALSE);
d1669 24
d1700 31
d1778 4
d1924 3
d2011 3
d2098 3
d2192 3
d2286 3
d2378 47
@


1.5
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d1 23
a23 4

/***
 ***  NOTE!!!  DO NOT EDIT THIS FILE!!!  IT IS GENERATED BY get_gen.py
 ***/
d28 1
d37 27
d66 3
d71 3
d81 1
d84 1
d86 1192
d1279 22
a1300 7
/*
 * Check if named extension is enabled, if not generate error and return.
 */
#define CHECK_EXT1(EXT1, FUNC)                                         \
   if (!ctx->Extensions.EXT1) {                                        \
      _mesa_error(ctx, GL_INVALID_ENUM, FUNC "(0x%x)", (int) pname);  \
      return;                                                          \
d1303 15
a1317 2
/*
 * Check if either of two extensions is enabled.
d1319 25
a1343 4
#define CHECK_EXT2(EXT1, EXT2, FUNC)                                   \
   if (!ctx->Extensions.EXT1 && !ctx->Extensions.EXT2) {               \
      _mesa_error(ctx, GL_INVALID_ENUM, FUNC "(0x%x)", (int) pname);  \
      return;                                                          \
d1346 20
a1365 2
/*
 * Check if either of three extensions is enabled.
d1367 278
a1644 6
#define CHECK_EXT3(EXT1, EXT2, EXT3, FUNC)                             \
   if (!ctx->Extensions.EXT1 && !ctx->Extensions.EXT2 &&               \
       !ctx->Extensions.EXT3) {                                        \
      _mesa_error(ctx, GL_INVALID_ENUM, FUNC "(0x%x)", (int) pname);  \
      return;                                                          \
   }
d1646 14
a1659 2
/*
 * Check if either of four extensions is enabled.
d1661 69
a1729 5
#define CHECK_EXT4(EXT1, EXT2, EXT3, EXT4, FUNC)                       \
   if (!ctx->Extensions.EXT1 && !ctx->Extensions.EXT2 &&               \
       !ctx->Extensions.EXT3 && !ctx->Extensions.EXT4) {               \
      _mesa_error(ctx, GL_INVALID_ENUM, FUNC "(0x%x)", (int) pname);  \
      return;                                                          \
d1732 5
d1738 24
a1761 2
void GLAPIENTRY
_mesa_GetBooleanv( GLenum pname, GLboolean *params )
d1764 16
a1779 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d1781 2
a1782 2
   if (!params)
      return;
d1784 2
a1785 2
   if (ctx->NewState)
      _mesa_update_state(ctx);
d1787 2
a1788 3
   if (ctx->Driver.GetBooleanv &&
       ctx->Driver.GetBooleanv(ctx, pname, params))
      return;
d1790 21
a1810 1850
   switch (pname) {
      case GL_ACCUM_RED_BITS:
         params[0] = INT_TO_BOOLEAN(ctx->DrawBuffer->Visual.accumRedBits);
         break;
      case GL_ACCUM_GREEN_BITS:
         params[0] = INT_TO_BOOLEAN(ctx->DrawBuffer->Visual.accumGreenBits);
         break;
      case GL_ACCUM_BLUE_BITS:
         params[0] = INT_TO_BOOLEAN(ctx->DrawBuffer->Visual.accumBlueBits);
         break;
      case GL_ACCUM_ALPHA_BITS:
         params[0] = INT_TO_BOOLEAN(ctx->DrawBuffer->Visual.accumAlphaBits);
         break;
      case GL_ACCUM_CLEAR_VALUE:
         params[0] = FLOAT_TO_BOOLEAN(ctx->Accum.ClearColor[0]);
         params[1] = FLOAT_TO_BOOLEAN(ctx->Accum.ClearColor[1]);
         params[2] = FLOAT_TO_BOOLEAN(ctx->Accum.ClearColor[2]);
         params[3] = FLOAT_TO_BOOLEAN(ctx->Accum.ClearColor[3]);
         break;
      case GL_ALPHA_BIAS:
         params[0] = FLOAT_TO_BOOLEAN(ctx->Pixel.AlphaBias);
         break;
      case GL_ALPHA_BITS:
         params[0] = INT_TO_BOOLEAN(ctx->DrawBuffer->Visual.alphaBits);
         break;
      case GL_ALPHA_SCALE:
         params[0] = FLOAT_TO_BOOLEAN(ctx->Pixel.AlphaScale);
         break;
      case GL_ALPHA_TEST:
         params[0] = ctx->Color.AlphaEnabled;
         break;
      case GL_ALPHA_TEST_FUNC:
         params[0] = ENUM_TO_BOOLEAN(ctx->Color.AlphaFunc);
         break;
      case GL_ALPHA_TEST_REF:
         params[0] = FLOAT_TO_BOOLEAN(ctx->Color.AlphaRef);
         break;
      case GL_ATTRIB_STACK_DEPTH:
         params[0] = INT_TO_BOOLEAN(ctx->AttribStackDepth);
         break;
      case GL_AUTO_NORMAL:
         params[0] = ctx->Eval.AutoNormal;
         break;
      case GL_AUX_BUFFERS:
         params[0] = INT_TO_BOOLEAN(ctx->DrawBuffer->Visual.numAuxBuffers);
         break;
      case GL_BLEND:
         params[0] = (ctx->Color.BlendEnabled & 1);
         break;
      case GL_BLEND_DST:
         params[0] = ENUM_TO_BOOLEAN(ctx->Color.BlendDstRGB);
         break;
      case GL_BLEND_SRC:
         params[0] = ENUM_TO_BOOLEAN(ctx->Color.BlendSrcRGB);
         break;
      case GL_BLEND_SRC_RGB_EXT:
         params[0] = ENUM_TO_BOOLEAN(ctx->Color.BlendSrcRGB);
         break;
      case GL_BLEND_DST_RGB_EXT:
         params[0] = ENUM_TO_BOOLEAN(ctx->Color.BlendDstRGB);
         break;
      case GL_BLEND_SRC_ALPHA_EXT:
         params[0] = ENUM_TO_BOOLEAN(ctx->Color.BlendSrcA);
         break;
      case GL_BLEND_DST_ALPHA_EXT:
         params[0] = ENUM_TO_BOOLEAN(ctx->Color.BlendDstA);
         break;
      case GL_BLEND_EQUATION:
         params[0] = ENUM_TO_BOOLEAN(ctx->Color.BlendEquationRGB );
         break;
      case GL_BLEND_EQUATION_ALPHA_EXT:
         params[0] = ENUM_TO_BOOLEAN(ctx->Color.BlendEquationA );
         break;
      case GL_BLEND_COLOR_EXT:
         params[0] = FLOAT_TO_BOOLEAN(ctx->Color.BlendColor[0]);
         params[1] = FLOAT_TO_BOOLEAN(ctx->Color.BlendColor[1]);
         params[2] = FLOAT_TO_BOOLEAN(ctx->Color.BlendColor[2]);
         params[3] = FLOAT_TO_BOOLEAN(ctx->Color.BlendColor[3]);
         break;
      case GL_BLUE_BIAS:
         params[0] = FLOAT_TO_BOOLEAN(ctx->Pixel.BlueBias);
         break;
      case GL_BLUE_BITS:
         params[0] = INT_TO_BOOLEAN(ctx->DrawBuffer->Visual.blueBits);
         break;
      case GL_BLUE_SCALE:
         params[0] = FLOAT_TO_BOOLEAN(ctx->Pixel.BlueScale);
         break;
      case GL_CLIENT_ATTRIB_STACK_DEPTH:
         params[0] = INT_TO_BOOLEAN(ctx->ClientAttribStackDepth);
         break;
      case GL_CLIP_PLANE0:
         params[0] = (ctx->Transform.ClipPlanesEnabled >> 0) & 1;
         break;
      case GL_CLIP_PLANE1:
         params[0] = (ctx->Transform.ClipPlanesEnabled >> 1) & 1;
         break;
      case GL_CLIP_PLANE2:
         params[0] = (ctx->Transform.ClipPlanesEnabled >> 2) & 1;
         break;
      case GL_CLIP_PLANE3:
         params[0] = (ctx->Transform.ClipPlanesEnabled >> 3) & 1;
         break;
      case GL_CLIP_PLANE4:
         params[0] = (ctx->Transform.ClipPlanesEnabled >> 4) & 1;
         break;
      case GL_CLIP_PLANE5:
         params[0] = (ctx->Transform.ClipPlanesEnabled >> 5) & 1;
         break;
      case GL_COLOR_CLEAR_VALUE:
         params[0] = FLOAT_TO_BOOLEAN(ctx->Color.ClearColor[0]);
         params[1] = FLOAT_TO_BOOLEAN(ctx->Color.ClearColor[1]);
         params[2] = FLOAT_TO_BOOLEAN(ctx->Color.ClearColor[2]);
         params[3] = FLOAT_TO_BOOLEAN(ctx->Color.ClearColor[3]);
         break;
      case GL_COLOR_MATERIAL:
         params[0] = ctx->Light.ColorMaterialEnabled;
         break;
      case GL_COLOR_MATERIAL_FACE:
         params[0] = ENUM_TO_BOOLEAN(ctx->Light.ColorMaterialFace);
         break;
      case GL_COLOR_MATERIAL_PARAMETER:
         params[0] = ENUM_TO_BOOLEAN(ctx->Light.ColorMaterialMode);
         break;
      case GL_COLOR_WRITEMASK:
         params[0] = INT_TO_BOOLEAN(ctx->Color.ColorMask[0][RCOMP] ? 1 : 0);
         params[1] = INT_TO_BOOLEAN(ctx->Color.ColorMask[0][GCOMP] ? 1 : 0);
         params[2] = INT_TO_BOOLEAN(ctx->Color.ColorMask[0][BCOMP] ? 1 : 0);
         params[3] = INT_TO_BOOLEAN(ctx->Color.ColorMask[0][ACOMP] ? 1 : 0);
         break;
      case GL_CULL_FACE:
         params[0] = ctx->Polygon.CullFlag;
         break;
      case GL_CULL_FACE_MODE:
         params[0] = ENUM_TO_BOOLEAN(ctx->Polygon.CullFaceMode);
         break;
      case GL_CURRENT_COLOR:
         {
         FLUSH_CURRENT(ctx, 0);
         params[0] = FLOAT_TO_BOOLEAN(ctx->Current.Attrib[VERT_ATTRIB_COLOR0][0]);
         params[1] = FLOAT_TO_BOOLEAN(ctx->Current.Attrib[VERT_ATTRIB_COLOR0][1]);
         params[2] = FLOAT_TO_BOOLEAN(ctx->Current.Attrib[VERT_ATTRIB_COLOR0][2]);
         params[3] = FLOAT_TO_BOOLEAN(ctx->Current.Attrib[VERT_ATTRIB_COLOR0][3]);
         }
         break;
      case GL_CURRENT_INDEX:
         {
         FLUSH_CURRENT(ctx, 0);
         params[0] = FLOAT_TO_BOOLEAN(ctx->Current.Attrib[VERT_ATTRIB_COLOR_INDEX][0]);
         }
         break;
      case GL_CURRENT_NORMAL:
         {
         FLUSH_CURRENT(ctx, 0);
         params[0] = FLOAT_TO_BOOLEAN(ctx->Current.Attrib[VERT_ATTRIB_NORMAL][0]);
         params[1] = FLOAT_TO_BOOLEAN(ctx->Current.Attrib[VERT_ATTRIB_NORMAL][1]);
         params[2] = FLOAT_TO_BOOLEAN(ctx->Current.Attrib[VERT_ATTRIB_NORMAL][2]);
         }
         break;
      case GL_CURRENT_RASTER_COLOR:
         params[0] = FLOAT_TO_BOOLEAN(ctx->Current.RasterColor[0]);
         params[1] = FLOAT_TO_BOOLEAN(ctx->Current.RasterColor[1]);
         params[2] = FLOAT_TO_BOOLEAN(ctx->Current.RasterColor[2]);
         params[3] = FLOAT_TO_BOOLEAN(ctx->Current.RasterColor[3]);
         break;
      case GL_CURRENT_RASTER_DISTANCE:
         params[0] = FLOAT_TO_BOOLEAN(ctx->Current.RasterDistance);
         break;
      case GL_CURRENT_RASTER_INDEX:
         params[0] = FLOAT_TO_BOOLEAN(1.0);
         break;
      case GL_CURRENT_RASTER_POSITION:
         params[0] = FLOAT_TO_BOOLEAN(ctx->Current.RasterPos[0]);
         params[1] = FLOAT_TO_BOOLEAN(ctx->Current.RasterPos[1]);
         params[2] = FLOAT_TO_BOOLEAN(ctx->Current.RasterPos[2]);
         params[3] = FLOAT_TO_BOOLEAN(ctx->Current.RasterPos[3]);
         break;
      case GL_CURRENT_RASTER_SECONDARY_COLOR:
         params[0] = FLOAT_TO_BOOLEAN(ctx->Current.RasterSecondaryColor[0]);
         params[1] = FLOAT_TO_BOOLEAN(ctx->Current.RasterSecondaryColor[1]);
         params[2] = FLOAT_TO_BOOLEAN(ctx->Current.RasterSecondaryColor[2]);
         params[3] = FLOAT_TO_BOOLEAN(ctx->Current.RasterSecondaryColor[3]);
         break;
      case GL_CURRENT_RASTER_TEXTURE_COORDS:
         {
         const GLuint unit = ctx->Texture.CurrentUnit;
         if (unit >= ctx->Const.MaxTextureCoordUnits) {
            _mesa_error(ctx, GL_INVALID_OPERATION,
                        "glGet(raster tex coords, unit %u)", unit);
            return;
         }
         params[0] = FLOAT_TO_BOOLEAN(ctx->Current.RasterTexCoords[unit][0]);
         params[1] = FLOAT_TO_BOOLEAN(ctx->Current.RasterTexCoords[unit][1]);
         params[2] = FLOAT_TO_BOOLEAN(ctx->Current.RasterTexCoords[unit][2]);
         params[3] = FLOAT_TO_BOOLEAN(ctx->Current.RasterTexCoords[unit][3]);
         }
         break;
      case GL_CURRENT_RASTER_POSITION_VALID:
         params[0] = ctx->Current.RasterPosValid;
         break;
      case GL_CURRENT_TEXTURE_COORDS:
         {
         const GLuint unit = ctx->Texture.CurrentUnit;
         if (unit >= ctx->Const.MaxTextureCoordUnits) {
            _mesa_error(ctx, GL_INVALID_OPERATION,
                        "glGet(current tex coords, unit %u)", unit);
            return;
         }
         FLUSH_CURRENT(ctx, 0);
         params[0] = FLOAT_TO_BOOLEAN(ctx->Current.Attrib[VERT_ATTRIB_TEX0 + unit][0]);
         params[1] = FLOAT_TO_BOOLEAN(ctx->Current.Attrib[VERT_ATTRIB_TEX0 + unit][1]);
         params[2] = FLOAT_TO_BOOLEAN(ctx->Current.Attrib[VERT_ATTRIB_TEX0 + unit][2]);
         params[3] = FLOAT_TO_BOOLEAN(ctx->Current.Attrib[VERT_ATTRIB_TEX0 + unit][3]);
         }
         break;
      case GL_DEPTH_BIAS:
         params[0] = FLOAT_TO_BOOLEAN(ctx->Pixel.DepthBias);
         break;
      case GL_DEPTH_BITS:
         params[0] = INT_TO_BOOLEAN(ctx->DrawBuffer->Visual.depthBits);
         break;
      case GL_DEPTH_CLEAR_VALUE:
         params[0] = FLOAT_TO_BOOLEAN(((GLfloat) ctx->Depth.Clear));
         break;
      case GL_DEPTH_FUNC:
         params[0] = ENUM_TO_BOOLEAN(ctx->Depth.Func);
         break;
      case GL_DEPTH_RANGE:
         params[0] = FLOAT_TO_BOOLEAN(ctx->Viewport.Near);
         params[1] = FLOAT_TO_BOOLEAN(ctx->Viewport.Far);
         break;
      case GL_DEPTH_SCALE:
         params[0] = FLOAT_TO_BOOLEAN(ctx->Pixel.DepthScale);
         break;
      case GL_DEPTH_TEST:
         params[0] = ctx->Depth.Test;
         break;
      case GL_DEPTH_WRITEMASK:
         params[0] = ctx->Depth.Mask;
         break;
      case GL_DITHER:
         params[0] = ctx->Color.DitherFlag;
         break;
      case GL_DOUBLEBUFFER:
         params[0] = ctx->DrawBuffer->Visual.doubleBufferMode;
         break;
      case GL_DRAW_BUFFER:
         params[0] = ENUM_TO_BOOLEAN(ctx->DrawBuffer->ColorDrawBuffer[0]);
         break;
      case GL_EDGE_FLAG:
         {
         FLUSH_CURRENT(ctx, 0);
         params[0] = (ctx->Current.Attrib[VERT_ATTRIB_EDGEFLAG][0] == 1.0);
         }
         break;
      case GL_FEEDBACK_BUFFER_SIZE:
         params[0] = INT_TO_BOOLEAN(ctx->Feedback.BufferSize);
         break;
      case GL_FEEDBACK_BUFFER_TYPE:
         params[0] = ENUM_TO_BOOLEAN(ctx->Feedback.Type);
         break;
      case GL_FOG:
         params[0] = ctx->Fog.Enabled;
         break;
      case GL_FOG_COLOR:
         params[0] = FLOAT_TO_BOOLEAN(ctx->Fog.Color[0]);
         params[1] = FLOAT_TO_BOOLEAN(ctx->Fog.Color[1]);
         params[2] = FLOAT_TO_BOOLEAN(ctx->Fog.Color[2]);
         params[3] = FLOAT_TO_BOOLEAN(ctx->Fog.Color[3]);
         break;
      case GL_FOG_DENSITY:
         params[0] = FLOAT_TO_BOOLEAN(ctx->Fog.Density);
         break;
      case GL_FOG_END:
         params[0] = FLOAT_TO_BOOLEAN(ctx->Fog.End);
         break;
      case GL_FOG_HINT:
         params[0] = ENUM_TO_BOOLEAN(ctx->Hint.Fog);
         break;
      case GL_FOG_INDEX:
         params[0] = FLOAT_TO_BOOLEAN(ctx->Fog.Index);
         break;
      case GL_FOG_MODE:
         params[0] = ENUM_TO_BOOLEAN(ctx->Fog.Mode);
         break;
      case GL_FOG_START:
         params[0] = FLOAT_TO_BOOLEAN(ctx->Fog.Start);
         break;
      case GL_FRONT_FACE:
         params[0] = ENUM_TO_BOOLEAN(ctx->Polygon.FrontFace);
         break;
      case GL_GREEN_BIAS:
         params[0] = FLOAT_TO_BOOLEAN(ctx->Pixel.GreenBias);
         break;
      case GL_GREEN_BITS:
         params[0] = INT_TO_BOOLEAN(ctx->DrawBuffer->Visual.greenBits);
         break;
      case GL_GREEN_SCALE:
         params[0] = FLOAT_TO_BOOLEAN(ctx->Pixel.GreenScale);
         break;
      case GL_INDEX_BITS:
         params[0] = INT_TO_BOOLEAN(ctx->DrawBuffer->Visual.indexBits);
         break;
      case GL_INDEX_CLEAR_VALUE:
         params[0] = INT_TO_BOOLEAN(ctx->Color.ClearIndex);
         break;
      case GL_INDEX_MODE:
         params[0] = GL_FALSE;
         break;
      case GL_INDEX_OFFSET:
         params[0] = INT_TO_BOOLEAN(ctx->Pixel.IndexOffset);
         break;
      case GL_INDEX_SHIFT:
         params[0] = INT_TO_BOOLEAN(ctx->Pixel.IndexShift);
         break;
      case GL_INDEX_WRITEMASK:
         params[0] = INT_TO_BOOLEAN(ctx->Color.IndexMask);
         break;
      case GL_LIGHT0:
         params[0] = ctx->Light.Light[0].Enabled;
         break;
      case GL_LIGHT1:
         params[0] = ctx->Light.Light[1].Enabled;
         break;
      case GL_LIGHT2:
         params[0] = ctx->Light.Light[2].Enabled;
         break;
      case GL_LIGHT3:
         params[0] = ctx->Light.Light[3].Enabled;
         break;
      case GL_LIGHT4:
         params[0] = ctx->Light.Light[4].Enabled;
         break;
      case GL_LIGHT5:
         params[0] = ctx->Light.Light[5].Enabled;
         break;
      case GL_LIGHT6:
         params[0] = ctx->Light.Light[6].Enabled;
         break;
      case GL_LIGHT7:
         params[0] = ctx->Light.Light[7].Enabled;
         break;
      case GL_LIGHTING:
         params[0] = ctx->Light.Enabled;
         break;
      case GL_LIGHT_MODEL_AMBIENT:
         params[0] = FLOAT_TO_BOOLEAN(ctx->Light.Model.Ambient[0]);
         params[1] = FLOAT_TO_BOOLEAN(ctx->Light.Model.Ambient[1]);
         params[2] = FLOAT_TO_BOOLEAN(ctx->Light.Model.Ambient[2]);
         params[3] = FLOAT_TO_BOOLEAN(ctx->Light.Model.Ambient[3]);
         break;
      case GL_LIGHT_MODEL_COLOR_CONTROL:
         params[0] = ENUM_TO_BOOLEAN(ctx->Light.Model.ColorControl);
         break;
      case GL_LIGHT_MODEL_LOCAL_VIEWER:
         params[0] = ctx->Light.Model.LocalViewer;
         break;
      case GL_LIGHT_MODEL_TWO_SIDE:
         params[0] = ctx->Light.Model.TwoSide;
         break;
      case GL_LINE_SMOOTH:
         params[0] = ctx->Line.SmoothFlag;
         break;
      case GL_LINE_SMOOTH_HINT:
         params[0] = ENUM_TO_BOOLEAN(ctx->Hint.LineSmooth);
         break;
      case GL_LINE_STIPPLE:
         params[0] = ctx->Line.StippleFlag;
         break;
      case GL_LINE_STIPPLE_PATTERN:
         params[0] = INT_TO_BOOLEAN(ctx->Line.StipplePattern);
         break;
      case GL_LINE_STIPPLE_REPEAT:
         params[0] = INT_TO_BOOLEAN(ctx->Line.StippleFactor);
         break;
      case GL_LINE_WIDTH:
         params[0] = FLOAT_TO_BOOLEAN(ctx->Line.Width);
         break;
      case GL_LINE_WIDTH_GRANULARITY:
         params[0] = FLOAT_TO_BOOLEAN(ctx->Const.LineWidthGranularity);
         break;
      case GL_LINE_WIDTH_RANGE:
         params[0] = FLOAT_TO_BOOLEAN(ctx->Const.MinLineWidthAA);
         params[1] = FLOAT_TO_BOOLEAN(ctx->Const.MaxLineWidthAA);
         break;
      case GL_ALIASED_LINE_WIDTH_RANGE:
         params[0] = FLOAT_TO_BOOLEAN(ctx->Const.MinLineWidth);
         params[1] = FLOAT_TO_BOOLEAN(ctx->Const.MaxLineWidth);
         break;
      case GL_LIST_BASE:
         params[0] = INT_TO_BOOLEAN(ctx->List.ListBase);
         break;
      case GL_LIST_INDEX:
         params[0] = INT_TO_BOOLEAN((ctx->ListState.CurrentList ? ctx->ListState.CurrentList->Name : 0));
         break;
      case GL_LIST_MODE:
         {
         GLenum mode;
         if (!ctx->CompileFlag)
            mode = 0;
         else if (ctx->ExecuteFlag)
            mode = GL_COMPILE_AND_EXECUTE;
         else
            mode = GL_COMPILE;
         params[0] = ENUM_TO_BOOLEAN(mode);
         }
         break;
      case GL_INDEX_LOGIC_OP:
         params[0] = ctx->Color.IndexLogicOpEnabled;
         break;
      case GL_COLOR_LOGIC_OP:
         params[0] = ctx->Color.ColorLogicOpEnabled;
         break;
      case GL_LOGIC_OP_MODE:
         params[0] = ENUM_TO_BOOLEAN(ctx->Color.LogicOp);
         break;
      case GL_MAP1_COLOR_4:
         params[0] = ctx->Eval.Map1Color4;
         break;
      case GL_MAP1_GRID_DOMAIN:
         params[0] = FLOAT_TO_BOOLEAN(ctx->Eval.MapGrid1u1);
         params[1] = FLOAT_TO_BOOLEAN(ctx->Eval.MapGrid1u2);
         break;
      case GL_MAP1_GRID_SEGMENTS:
         params[0] = INT_TO_BOOLEAN(ctx->Eval.MapGrid1un);
         break;
      case GL_MAP1_INDEX:
         params[0] = ctx->Eval.Map1Index;
         break;
      case GL_MAP1_NORMAL:
         params[0] = ctx->Eval.Map1Normal;
         break;
      case GL_MAP1_TEXTURE_COORD_1:
         params[0] = ctx->Eval.Map1TextureCoord1;
         break;
      case GL_MAP1_TEXTURE_COORD_2:
         params[0] = ctx->Eval.Map1TextureCoord2;
         break;
      case GL_MAP1_TEXTURE_COORD_3:
         params[0] = ctx->Eval.Map1TextureCoord3;
         break;
      case GL_MAP1_TEXTURE_COORD_4:
         params[0] = ctx->Eval.Map1TextureCoord4;
         break;
      case GL_MAP1_VERTEX_3:
         params[0] = ctx->Eval.Map1Vertex3;
         break;
      case GL_MAP1_VERTEX_4:
         params[0] = ctx->Eval.Map1Vertex4;
         break;
      case GL_MAP2_COLOR_4:
         params[0] = ctx->Eval.Map2Color4;
         break;
      case GL_MAP2_GRID_DOMAIN:
         params[0] = FLOAT_TO_BOOLEAN(ctx->Eval.MapGrid2u1);
         params[1] = FLOAT_TO_BOOLEAN(ctx->Eval.MapGrid2u2);
         params[2] = FLOAT_TO_BOOLEAN(ctx->Eval.MapGrid2v1);
         params[3] = FLOAT_TO_BOOLEAN(ctx->Eval.MapGrid2v2);
         break;
      case GL_MAP2_GRID_SEGMENTS:
         params[0] = INT_TO_BOOLEAN(ctx->Eval.MapGrid2un);
         params[1] = INT_TO_BOOLEAN(ctx->Eval.MapGrid2vn);
         break;
      case GL_MAP2_INDEX:
         params[0] = ctx->Eval.Map2Index;
         break;
      case GL_MAP2_NORMAL:
         params[0] = ctx->Eval.Map2Normal;
         break;
      case GL_MAP2_TEXTURE_COORD_1:
         params[0] = ctx->Eval.Map2TextureCoord1;
         break;
      case GL_MAP2_TEXTURE_COORD_2:
         params[0] = ctx->Eval.Map2TextureCoord2;
         break;
      case GL_MAP2_TEXTURE_COORD_3:
         params[0] = ctx->Eval.Map2TextureCoord3;
         break;
      case GL_MAP2_TEXTURE_COORD_4:
         params[0] = ctx->Eval.Map2TextureCoord4;
         break;
      case GL_MAP2_VERTEX_3:
         params[0] = ctx->Eval.Map2Vertex3;
         break;
      case GL_MAP2_VERTEX_4:
         params[0] = ctx->Eval.Map2Vertex4;
         break;
      case GL_MAP_COLOR:
         params[0] = ctx->Pixel.MapColorFlag;
         break;
      case GL_MAP_STENCIL:
         params[0] = ctx->Pixel.MapStencilFlag;
         break;
      case GL_MATRIX_MODE:
         params[0] = ENUM_TO_BOOLEAN(ctx->Transform.MatrixMode);
         break;
      case GL_MAX_ATTRIB_STACK_DEPTH:
         params[0] = INT_TO_BOOLEAN(MAX_ATTRIB_STACK_DEPTH);
         break;
      case GL_MAX_CLIENT_ATTRIB_STACK_DEPTH:
         params[0] = INT_TO_BOOLEAN(MAX_CLIENT_ATTRIB_STACK_DEPTH);
         break;
      case GL_MAX_CLIP_PLANES:
         params[0] = INT_TO_BOOLEAN(ctx->Const.MaxClipPlanes);
         break;
      case GL_MAX_ELEMENTS_VERTICES:
         params[0] = INT_TO_BOOLEAN(ctx->Const.MaxArrayLockSize);
         break;
      case GL_MAX_ELEMENTS_INDICES:
         params[0] = INT_TO_BOOLEAN(ctx->Const.MaxArrayLockSize);
         break;
      case GL_MAX_EVAL_ORDER:
         params[0] = INT_TO_BOOLEAN(MAX_EVAL_ORDER);
         break;
      case GL_MAX_LIGHTS:
         params[0] = INT_TO_BOOLEAN(ctx->Const.MaxLights);
         break;
      case GL_MAX_LIST_NESTING:
         params[0] = INT_TO_BOOLEAN(MAX_LIST_NESTING);
         break;
      case GL_MAX_MODELVIEW_STACK_DEPTH:
         params[0] = INT_TO_BOOLEAN(MAX_MODELVIEW_STACK_DEPTH);
         break;
      case GL_MAX_NAME_STACK_DEPTH:
         params[0] = INT_TO_BOOLEAN(MAX_NAME_STACK_DEPTH);
         break;
      case GL_MAX_PIXEL_MAP_TABLE:
         params[0] = INT_TO_BOOLEAN(MAX_PIXEL_MAP_TABLE);
         break;
      case GL_MAX_PROJECTION_STACK_DEPTH:
         params[0] = INT_TO_BOOLEAN(MAX_PROJECTION_STACK_DEPTH);
         break;
      case GL_MAX_TEXTURE_SIZE:
         params[0] = INT_TO_BOOLEAN(1 << (ctx->Const.MaxTextureLevels - 1));
         break;
      case GL_MAX_3D_TEXTURE_SIZE:
         params[0] = INT_TO_BOOLEAN(1 << (ctx->Const.Max3DTextureLevels - 1));
         break;
      case GL_MAX_TEXTURE_STACK_DEPTH:
         params[0] = INT_TO_BOOLEAN(MAX_TEXTURE_STACK_DEPTH);
         break;
      case GL_MAX_VIEWPORT_DIMS:
         params[0] = INT_TO_BOOLEAN(ctx->Const.MaxViewportWidth);
         params[1] = INT_TO_BOOLEAN(ctx->Const.MaxViewportHeight);
         break;
      case GL_MODELVIEW_MATRIX:
         {
         const GLfloat *matrix = ctx->ModelviewMatrixStack.Top->m;
         params[0] = FLOAT_TO_BOOLEAN(matrix[0]);
         params[1] = FLOAT_TO_BOOLEAN(matrix[1]);
         params[2] = FLOAT_TO_BOOLEAN(matrix[2]);
         params[3] = FLOAT_TO_BOOLEAN(matrix[3]);
         params[4] = FLOAT_TO_BOOLEAN(matrix[4]);
         params[5] = FLOAT_TO_BOOLEAN(matrix[5]);
         params[6] = FLOAT_TO_BOOLEAN(matrix[6]);
         params[7] = FLOAT_TO_BOOLEAN(matrix[7]);
         params[8] = FLOAT_TO_BOOLEAN(matrix[8]);
         params[9] = FLOAT_TO_BOOLEAN(matrix[9]);
         params[10] = FLOAT_TO_BOOLEAN(matrix[10]);
         params[11] = FLOAT_TO_BOOLEAN(matrix[11]);
         params[12] = FLOAT_TO_BOOLEAN(matrix[12]);
         params[13] = FLOAT_TO_BOOLEAN(matrix[13]);
         params[14] = FLOAT_TO_BOOLEAN(matrix[14]);
         params[15] = FLOAT_TO_BOOLEAN(matrix[15]);
         }
         break;
      case GL_MODELVIEW_STACK_DEPTH:
         params[0] = INT_TO_BOOLEAN(ctx->ModelviewMatrixStack.Depth + 1);
         break;
      case GL_NAME_STACK_DEPTH:
         params[0] = INT_TO_BOOLEAN(ctx->Select.NameStackDepth);
         break;
      case GL_NORMALIZE:
         params[0] = ctx->Transform.Normalize;
         break;
      case GL_PACK_ALIGNMENT:
         params[0] = INT_TO_BOOLEAN(ctx->Pack.Alignment);
         break;
      case GL_PACK_LSB_FIRST:
         params[0] = ctx->Pack.LsbFirst;
         break;
      case GL_PACK_ROW_LENGTH:
         params[0] = INT_TO_BOOLEAN(ctx->Pack.RowLength);
         break;
      case GL_PACK_SKIP_PIXELS:
         params[0] = INT_TO_BOOLEAN(ctx->Pack.SkipPixels);
         break;
      case GL_PACK_SKIP_ROWS:
         params[0] = INT_TO_BOOLEAN(ctx->Pack.SkipRows);
         break;
      case GL_PACK_SWAP_BYTES:
         params[0] = ctx->Pack.SwapBytes;
         break;
      case GL_PACK_SKIP_IMAGES_EXT:
         params[0] = INT_TO_BOOLEAN(ctx->Pack.SkipImages);
         break;
      case GL_PACK_IMAGE_HEIGHT_EXT:
         params[0] = INT_TO_BOOLEAN(ctx->Pack.ImageHeight);
         break;
      case GL_PACK_INVERT_MESA:
         params[0] = ctx->Pack.Invert;
         break;
      case GL_PERSPECTIVE_CORRECTION_HINT:
         params[0] = ENUM_TO_BOOLEAN(ctx->Hint.PerspectiveCorrection);
         break;
      case GL_PIXEL_MAP_A_TO_A_SIZE:
         params[0] = INT_TO_BOOLEAN(ctx->PixelMaps.AtoA.Size);
         break;
      case GL_PIXEL_MAP_B_TO_B_SIZE:
         params[0] = INT_TO_BOOLEAN(ctx->PixelMaps.BtoB.Size);
         break;
      case GL_PIXEL_MAP_G_TO_G_SIZE:
         params[0] = INT_TO_BOOLEAN(ctx->PixelMaps.GtoG.Size);
         break;
      case GL_PIXEL_MAP_I_TO_A_SIZE:
         params[0] = INT_TO_BOOLEAN(ctx->PixelMaps.ItoA.Size);
         break;
      case GL_PIXEL_MAP_I_TO_B_SIZE:
         params[0] = INT_TO_BOOLEAN(ctx->PixelMaps.ItoB.Size);
         break;
      case GL_PIXEL_MAP_I_TO_G_SIZE:
         params[0] = INT_TO_BOOLEAN(ctx->PixelMaps.ItoG.Size);
         break;
      case GL_PIXEL_MAP_I_TO_I_SIZE:
         params[0] = INT_TO_BOOLEAN(ctx->PixelMaps.ItoI.Size);
         break;
      case GL_PIXEL_MAP_I_TO_R_SIZE:
         params[0] = INT_TO_BOOLEAN(ctx->PixelMaps.ItoR.Size);
         break;
      case GL_PIXEL_MAP_R_TO_R_SIZE:
         params[0] = INT_TO_BOOLEAN(ctx->PixelMaps.RtoR.Size);
         break;
      case GL_PIXEL_MAP_S_TO_S_SIZE:
         params[0] = INT_TO_BOOLEAN(ctx->PixelMaps.StoS.Size);
         break;
      case GL_POINT_SIZE:
         params[0] = FLOAT_TO_BOOLEAN(ctx->Point.Size);
         break;
      case GL_POINT_SIZE_GRANULARITY:
         params[0] = FLOAT_TO_BOOLEAN(ctx->Const.PointSizeGranularity);
         break;
      case GL_POINT_SIZE_RANGE:
         params[0] = FLOAT_TO_BOOLEAN(ctx->Const.MinPointSizeAA);
         params[1] = FLOAT_TO_BOOLEAN(ctx->Const.MaxPointSizeAA);
         break;
      case GL_ALIASED_POINT_SIZE_RANGE:
         params[0] = FLOAT_TO_BOOLEAN(ctx->Const.MinPointSize);
         params[1] = FLOAT_TO_BOOLEAN(ctx->Const.MaxPointSize);
         break;
      case GL_POINT_SMOOTH:
         params[0] = ctx->Point.SmoothFlag;
         break;
      case GL_POINT_SMOOTH_HINT:
         params[0] = ENUM_TO_BOOLEAN(ctx->Hint.PointSmooth);
         break;
      case GL_POINT_SIZE_MIN_EXT:
         params[0] = FLOAT_TO_BOOLEAN(ctx->Point.MinSize);
         break;
      case GL_POINT_SIZE_MAX_EXT:
         params[0] = FLOAT_TO_BOOLEAN(ctx->Point.MaxSize);
         break;
      case GL_POINT_FADE_THRESHOLD_SIZE_EXT:
         params[0] = FLOAT_TO_BOOLEAN(ctx->Point.Threshold);
         break;
      case GL_DISTANCE_ATTENUATION_EXT:
         params[0] = FLOAT_TO_BOOLEAN(ctx->Point.Params[0]);
         params[1] = FLOAT_TO_BOOLEAN(ctx->Point.Params[1]);
         params[2] = FLOAT_TO_BOOLEAN(ctx->Point.Params[2]);
         break;
      case GL_POLYGON_MODE:
         params[0] = ENUM_TO_BOOLEAN(ctx->Polygon.FrontMode);
         params[1] = ENUM_TO_BOOLEAN(ctx->Polygon.BackMode);
         break;
      case GL_POLYGON_OFFSET_BIAS_EXT:
         params[0] = FLOAT_TO_BOOLEAN(ctx->Polygon.OffsetUnits);
         break;
      case GL_POLYGON_OFFSET_FACTOR:
         params[0] = FLOAT_TO_BOOLEAN(ctx->Polygon.OffsetFactor );
         break;
      case GL_POLYGON_OFFSET_UNITS:
         params[0] = FLOAT_TO_BOOLEAN(ctx->Polygon.OffsetUnits );
         break;
      case GL_POLYGON_OFFSET_POINT:
         params[0] = ctx->Polygon.OffsetPoint;
         break;
      case GL_POLYGON_OFFSET_LINE:
         params[0] = ctx->Polygon.OffsetLine;
         break;
      case GL_POLYGON_OFFSET_FILL:
         params[0] = ctx->Polygon.OffsetFill;
         break;
      case GL_POLYGON_SMOOTH:
         params[0] = ctx->Polygon.SmoothFlag;
         break;
      case GL_POLYGON_SMOOTH_HINT:
         params[0] = ENUM_TO_BOOLEAN(ctx->Hint.PolygonSmooth);
         break;
      case GL_POLYGON_STIPPLE:
         params[0] = ctx->Polygon.StippleFlag;
         break;
      case GL_PROJECTION_MATRIX:
         {
         const GLfloat *matrix = ctx->ProjectionMatrixStack.Top->m;
         params[0] = FLOAT_TO_BOOLEAN(matrix[0]);
         params[1] = FLOAT_TO_BOOLEAN(matrix[1]);
         params[2] = FLOAT_TO_BOOLEAN(matrix[2]);
         params[3] = FLOAT_TO_BOOLEAN(matrix[3]);
         params[4] = FLOAT_TO_BOOLEAN(matrix[4]);
         params[5] = FLOAT_TO_BOOLEAN(matrix[5]);
         params[6] = FLOAT_TO_BOOLEAN(matrix[6]);
         params[7] = FLOAT_TO_BOOLEAN(matrix[7]);
         params[8] = FLOAT_TO_BOOLEAN(matrix[8]);
         params[9] = FLOAT_TO_BOOLEAN(matrix[9]);
         params[10] = FLOAT_TO_BOOLEAN(matrix[10]);
         params[11] = FLOAT_TO_BOOLEAN(matrix[11]);
         params[12] = FLOAT_TO_BOOLEAN(matrix[12]);
         params[13] = FLOAT_TO_BOOLEAN(matrix[13]);
         params[14] = FLOAT_TO_BOOLEAN(matrix[14]);
         params[15] = FLOAT_TO_BOOLEAN(matrix[15]);
         }
         break;
      case GL_PROJECTION_STACK_DEPTH:
         params[0] = INT_TO_BOOLEAN(ctx->ProjectionMatrixStack.Depth + 1);
         break;
      case GL_READ_BUFFER:
         params[0] = ENUM_TO_BOOLEAN(ctx->ReadBuffer->ColorReadBuffer);
         break;
      case GL_RED_BIAS:
         params[0] = FLOAT_TO_BOOLEAN(ctx->Pixel.RedBias);
         break;
      case GL_RED_BITS:
         params[0] = INT_TO_BOOLEAN(ctx->DrawBuffer->Visual.redBits);
         break;
      case GL_RED_SCALE:
         params[0] = FLOAT_TO_BOOLEAN(ctx->Pixel.RedScale);
         break;
      case GL_RENDER_MODE:
         params[0] = ENUM_TO_BOOLEAN(ctx->RenderMode);
         break;
      case GL_RESCALE_NORMAL:
         params[0] = ctx->Transform.RescaleNormals;
         break;
      case GL_RGBA_MODE:
         params[0] = GL_TRUE;
         break;
      case GL_SCISSOR_BOX:
         params[0] = INT_TO_BOOLEAN(ctx->Scissor.X);
         params[1] = INT_TO_BOOLEAN(ctx->Scissor.Y);
         params[2] = INT_TO_BOOLEAN(ctx->Scissor.Width);
         params[3] = INT_TO_BOOLEAN(ctx->Scissor.Height);
         break;
      case GL_SCISSOR_TEST:
         params[0] = ctx->Scissor.Enabled;
         break;
      case GL_SELECTION_BUFFER_SIZE:
         params[0] = INT_TO_BOOLEAN(ctx->Select.BufferSize);
         break;
      case GL_SHADE_MODEL:
         params[0] = ENUM_TO_BOOLEAN(ctx->Light.ShadeModel);
         break;
      case GL_SHARED_TEXTURE_PALETTE_EXT:
         params[0] = ctx->Texture.SharedPalette;
         break;
      case GL_STENCIL_BITS:
         params[0] = INT_TO_BOOLEAN(ctx->DrawBuffer->Visual.stencilBits);
         break;
      case GL_STENCIL_CLEAR_VALUE:
         params[0] = INT_TO_BOOLEAN(ctx->Stencil.Clear);
         break;
      case GL_STENCIL_FAIL:
         params[0] = ENUM_TO_BOOLEAN(ctx->Stencil.FailFunc[ctx->Stencil.ActiveFace]);
         break;
      case GL_STENCIL_FUNC:
         params[0] = ENUM_TO_BOOLEAN(ctx->Stencil.Function[ctx->Stencil.ActiveFace]);
         break;
      case GL_STENCIL_PASS_DEPTH_FAIL:
         params[0] = ENUM_TO_BOOLEAN(ctx->Stencil.ZFailFunc[ctx->Stencil.ActiveFace]);
         break;
      case GL_STENCIL_PASS_DEPTH_PASS:
         params[0] = ENUM_TO_BOOLEAN(ctx->Stencil.ZPassFunc[ctx->Stencil.ActiveFace]);
         break;
      case GL_STENCIL_REF:
         params[0] = INT_TO_BOOLEAN(ctx->Stencil.Ref[ctx->Stencil.ActiveFace]);
         break;
      case GL_STENCIL_TEST:
         params[0] = ctx->Stencil.Enabled;
         break;
      case GL_STENCIL_VALUE_MASK:
         params[0] = INT_TO_BOOLEAN(ctx->Stencil.ValueMask[ctx->Stencil.ActiveFace]);
         break;
      case GL_STENCIL_WRITEMASK:
         params[0] = INT_TO_BOOLEAN(ctx->Stencil.WriteMask[ctx->Stencil.ActiveFace]);
         break;
      case GL_STEREO:
         params[0] = ctx->DrawBuffer->Visual.stereoMode;
         break;
      case GL_SUBPIXEL_BITS:
         params[0] = INT_TO_BOOLEAN(ctx->Const.SubPixelBits);
         break;
      case GL_TEXTURE_1D:
         params[0] = _mesa_IsEnabled(GL_TEXTURE_1D);
         break;
      case GL_TEXTURE_2D:
         params[0] = _mesa_IsEnabled(GL_TEXTURE_2D);
         break;
      case GL_TEXTURE_3D:
         params[0] = _mesa_IsEnabled(GL_TEXTURE_3D);
         break;
      case GL_TEXTURE_1D_ARRAY_EXT:
         CHECK_EXT1(MESA_texture_array, "GetBooleanv");
         params[0] = _mesa_IsEnabled(GL_TEXTURE_1D_ARRAY_EXT);
         break;
      case GL_TEXTURE_2D_ARRAY_EXT:
         CHECK_EXT1(MESA_texture_array, "GetBooleanv");
         params[0] = _mesa_IsEnabled(GL_TEXTURE_2D_ARRAY_EXT);
         break;
      case GL_TEXTURE_BINDING_1D:
         params[0] = INT_TO_BOOLEAN(ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentTex[TEXTURE_1D_INDEX]->Name);
         break;
      case GL_TEXTURE_BINDING_2D:
         params[0] = INT_TO_BOOLEAN(ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentTex[TEXTURE_2D_INDEX]->Name);
         break;
      case GL_TEXTURE_BINDING_3D:
         params[0] = INT_TO_BOOLEAN(ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentTex[TEXTURE_3D_INDEX]->Name);
         break;
      case GL_TEXTURE_BINDING_1D_ARRAY_EXT:
         CHECK_EXT1(MESA_texture_array, "GetBooleanv");
         params[0] = INT_TO_BOOLEAN(ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentTex[TEXTURE_1D_ARRAY_INDEX]->Name);
         break;
      case GL_TEXTURE_BINDING_2D_ARRAY_EXT:
         CHECK_EXT1(MESA_texture_array, "GetBooleanv");
         params[0] = INT_TO_BOOLEAN(ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentTex[TEXTURE_2D_ARRAY_INDEX]->Name);
         break;
      case GL_TEXTURE_GEN_S:
         params[0] = ((ctx->Texture.Unit[ctx->Texture.CurrentUnit].TexGenEnabled & S_BIT) ? 1 : 0);
         break;
      case GL_TEXTURE_GEN_T:
         params[0] = ((ctx->Texture.Unit[ctx->Texture.CurrentUnit].TexGenEnabled & T_BIT) ? 1 : 0);
         break;
      case GL_TEXTURE_GEN_R:
         params[0] = ((ctx->Texture.Unit[ctx->Texture.CurrentUnit].TexGenEnabled & R_BIT) ? 1 : 0);
         break;
      case GL_TEXTURE_GEN_Q:
         params[0] = ((ctx->Texture.Unit[ctx->Texture.CurrentUnit].TexGenEnabled & Q_BIT) ? 1 : 0);
         break;
      case GL_TEXTURE_MATRIX:
         {
         const GLfloat *matrix;
         const GLuint unit = ctx->Texture.CurrentUnit;
         if (unit >= ctx->Const.MaxTextureCoordUnits) {
            _mesa_error(ctx, GL_INVALID_OPERATION, "glGet(texture matrix %u)",
                        unit);
            return;
         }
         matrix = ctx->TextureMatrixStack[unit].Top->m;
         params[0] = FLOAT_TO_BOOLEAN(matrix[0]);
         params[1] = FLOAT_TO_BOOLEAN(matrix[1]);
         params[2] = FLOAT_TO_BOOLEAN(matrix[2]);
         params[3] = FLOAT_TO_BOOLEAN(matrix[3]);
         params[4] = FLOAT_TO_BOOLEAN(matrix[4]);
         params[5] = FLOAT_TO_BOOLEAN(matrix[5]);
         params[6] = FLOAT_TO_BOOLEAN(matrix[6]);
         params[7] = FLOAT_TO_BOOLEAN(matrix[7]);
         params[8] = FLOAT_TO_BOOLEAN(matrix[8]);
         params[9] = FLOAT_TO_BOOLEAN(matrix[9]);
         params[10] = FLOAT_TO_BOOLEAN(matrix[10]);
         params[11] = FLOAT_TO_BOOLEAN(matrix[11]);
         params[12] = FLOAT_TO_BOOLEAN(matrix[12]);
         params[13] = FLOAT_TO_BOOLEAN(matrix[13]);
         params[14] = FLOAT_TO_BOOLEAN(matrix[14]);
         params[15] = FLOAT_TO_BOOLEAN(matrix[15]);
         }
         break;
      case GL_TEXTURE_STACK_DEPTH:
         {
         const GLuint unit = ctx->Texture.CurrentUnit;
         if (unit >= ctx->Const.MaxTextureCoordUnits) {
            _mesa_error(ctx, GL_INVALID_OPERATION,
                        "glGet(texture stack depth, unit %u)", unit);
            return;
         }
         params[0] = INT_TO_BOOLEAN(ctx->TextureMatrixStack[unit].Depth + 1);
         }
         break;
      case GL_UNPACK_ALIGNMENT:
         params[0] = INT_TO_BOOLEAN(ctx->Unpack.Alignment);
         break;
      case GL_UNPACK_LSB_FIRST:
         params[0] = ctx->Unpack.LsbFirst;
         break;
      case GL_UNPACK_ROW_LENGTH:
         params[0] = INT_TO_BOOLEAN(ctx->Unpack.RowLength);
         break;
      case GL_UNPACK_SKIP_PIXELS:
         params[0] = INT_TO_BOOLEAN(ctx->Unpack.SkipPixels);
         break;
      case GL_UNPACK_SKIP_ROWS:
         params[0] = INT_TO_BOOLEAN(ctx->Unpack.SkipRows);
         break;
      case GL_UNPACK_SWAP_BYTES:
         params[0] = ctx->Unpack.SwapBytes;
         break;
      case GL_UNPACK_SKIP_IMAGES_EXT:
         params[0] = INT_TO_BOOLEAN(ctx->Unpack.SkipImages);
         break;
      case GL_UNPACK_IMAGE_HEIGHT_EXT:
         params[0] = INT_TO_BOOLEAN(ctx->Unpack.ImageHeight);
         break;
      case GL_UNPACK_CLIENT_STORAGE_APPLE:
         params[0] = ctx->Unpack.ClientStorage;
         break;
      case GL_VIEWPORT:
         params[0] = INT_TO_BOOLEAN(ctx->Viewport.X);
         params[1] = INT_TO_BOOLEAN(ctx->Viewport.Y);
         params[2] = INT_TO_BOOLEAN(ctx->Viewport.Width);
         params[3] = INT_TO_BOOLEAN(ctx->Viewport.Height);
         break;
      case GL_ZOOM_X:
         params[0] = FLOAT_TO_BOOLEAN(ctx->Pixel.ZoomX);
         break;
      case GL_ZOOM_Y:
         params[0] = FLOAT_TO_BOOLEAN(ctx->Pixel.ZoomY);
         break;
      case GL_VERTEX_ARRAY:
         params[0] = ctx->Array.ArrayObj->Vertex.Enabled;
         break;
      case GL_VERTEX_ARRAY_SIZE:
         params[0] = INT_TO_BOOLEAN(ctx->Array.ArrayObj->Vertex.Size);
         break;
      case GL_VERTEX_ARRAY_TYPE:
         params[0] = ENUM_TO_BOOLEAN(ctx->Array.ArrayObj->Vertex.Type);
         break;
      case GL_VERTEX_ARRAY_STRIDE:
         params[0] = INT_TO_BOOLEAN(ctx->Array.ArrayObj->Vertex.Stride);
         break;
      case GL_VERTEX_ARRAY_COUNT_EXT:
         params[0] = INT_TO_BOOLEAN(0);
         break;
      case GL_NORMAL_ARRAY:
         params[0] = ENUM_TO_BOOLEAN(ctx->Array.ArrayObj->Normal.Enabled);
         break;
      case GL_NORMAL_ARRAY_TYPE:
         params[0] = ENUM_TO_BOOLEAN(ctx->Array.ArrayObj->Normal.Type);
         break;
      case GL_NORMAL_ARRAY_STRIDE:
         params[0] = INT_TO_BOOLEAN(ctx->Array.ArrayObj->Normal.Stride);
         break;
      case GL_NORMAL_ARRAY_COUNT_EXT:
         params[0] = INT_TO_BOOLEAN(0);
         break;
      case GL_COLOR_ARRAY:
         params[0] = ctx->Array.ArrayObj->Color.Enabled;
         break;
      case GL_COLOR_ARRAY_SIZE:
         params[0] = INT_TO_BOOLEAN(ctx->Array.ArrayObj->Color.Size);
         break;
      case GL_COLOR_ARRAY_TYPE:
         params[0] = ENUM_TO_BOOLEAN(ctx->Array.ArrayObj->Color.Type);
         break;
      case GL_COLOR_ARRAY_STRIDE:
         params[0] = INT_TO_BOOLEAN(ctx->Array.ArrayObj->Color.Stride);
         break;
      case GL_COLOR_ARRAY_COUNT_EXT:
         params[0] = INT_TO_BOOLEAN(0);
         break;
      case GL_INDEX_ARRAY:
         params[0] = ctx->Array.ArrayObj->Index.Enabled;
         break;
      case GL_INDEX_ARRAY_TYPE:
         params[0] = ENUM_TO_BOOLEAN(ctx->Array.ArrayObj->Index.Type);
         break;
      case GL_INDEX_ARRAY_STRIDE:
         params[0] = INT_TO_BOOLEAN(ctx->Array.ArrayObj->Index.Stride);
         break;
      case GL_INDEX_ARRAY_COUNT_EXT:
         params[0] = INT_TO_BOOLEAN(0);
         break;
      case GL_TEXTURE_COORD_ARRAY:
         params[0] = ctx->Array.ArrayObj->TexCoord[ctx->Array.ActiveTexture].Enabled;
         break;
      case GL_TEXTURE_COORD_ARRAY_SIZE:
         params[0] = INT_TO_BOOLEAN(ctx->Array.ArrayObj->TexCoord[ctx->Array.ActiveTexture].Size);
         break;
      case GL_TEXTURE_COORD_ARRAY_TYPE:
         params[0] = ENUM_TO_BOOLEAN(ctx->Array.ArrayObj->TexCoord[ctx->Array.ActiveTexture].Type);
         break;
      case GL_TEXTURE_COORD_ARRAY_STRIDE:
         params[0] = INT_TO_BOOLEAN(ctx->Array.ArrayObj->TexCoord[ctx->Array.ActiveTexture].Stride);
         break;
      case GL_TEXTURE_COORD_ARRAY_COUNT_EXT:
         params[0] = INT_TO_BOOLEAN(0);
         break;
      case GL_EDGE_FLAG_ARRAY:
         params[0] = ctx->Array.ArrayObj->EdgeFlag.Enabled;
         break;
      case GL_EDGE_FLAG_ARRAY_STRIDE:
         params[0] = INT_TO_BOOLEAN(ctx->Array.ArrayObj->EdgeFlag.Stride);
         break;
      case GL_EDGE_FLAG_ARRAY_COUNT_EXT:
         params[0] = INT_TO_BOOLEAN(0);
         break;
      case GL_MAX_TEXTURE_UNITS_ARB:
         CHECK_EXT1(ARB_multitexture, "GetBooleanv");
         params[0] = INT_TO_BOOLEAN(ctx->Const.MaxTextureUnits);
         break;
      case GL_ACTIVE_TEXTURE_ARB:
         CHECK_EXT1(ARB_multitexture, "GetBooleanv");
         params[0] = INT_TO_BOOLEAN(GL_TEXTURE0_ARB + ctx->Texture.CurrentUnit);
         break;
      case GL_CLIENT_ACTIVE_TEXTURE_ARB:
         CHECK_EXT1(ARB_multitexture, "GetBooleanv");
         params[0] = INT_TO_BOOLEAN(GL_TEXTURE0_ARB + ctx->Array.ActiveTexture);
         break;
      case GL_TEXTURE_CUBE_MAP_ARB:
         CHECK_EXT1(ARB_texture_cube_map, "GetBooleanv");
         params[0] = _mesa_IsEnabled(GL_TEXTURE_CUBE_MAP_ARB);
         break;
      case GL_TEXTURE_BINDING_CUBE_MAP_ARB:
         CHECK_EXT1(ARB_texture_cube_map, "GetBooleanv");
         params[0] = INT_TO_BOOLEAN(ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentTex[TEXTURE_CUBE_INDEX]->Name);
         break;
      case GL_MAX_CUBE_MAP_TEXTURE_SIZE_ARB:
         CHECK_EXT1(ARB_texture_cube_map, "GetBooleanv");
         params[0] = INT_TO_BOOLEAN((1 << (ctx->Const.MaxCubeTextureLevels - 1)));
         break;
      case GL_TEXTURE_COMPRESSION_HINT_ARB:
         params[0] = INT_TO_BOOLEAN(ctx->Hint.TextureCompression);
         break;
      case GL_NUM_COMPRESSED_TEXTURE_FORMATS_ARB:
         params[0] = INT_TO_BOOLEAN(_mesa_get_compressed_formats(ctx, NULL, GL_FALSE));
         break;
      case GL_COMPRESSED_TEXTURE_FORMATS_ARB:
         {
         GLint formats[100];
         GLuint i, n = _mesa_get_compressed_formats(ctx, formats, GL_FALSE);
         ASSERT(n <= 100);
         for (i = 0; i < n; i++)
            params[i] = ENUM_TO_BOOLEAN(formats[i]);
         }
         break;
      case GL_ARRAY_ELEMENT_LOCK_FIRST_EXT:
         CHECK_EXT1(EXT_compiled_vertex_array, "GetBooleanv");
         params[0] = INT_TO_BOOLEAN(ctx->Array.LockFirst);
         break;
      case GL_ARRAY_ELEMENT_LOCK_COUNT_EXT:
         CHECK_EXT1(EXT_compiled_vertex_array, "GetBooleanv");
         params[0] = INT_TO_BOOLEAN(ctx->Array.LockCount);
         break;
      case GL_TRANSPOSE_COLOR_MATRIX_ARB:
         {
         const GLfloat *matrix = ctx->ColorMatrixStack.Top->m;
         params[0] = FLOAT_TO_BOOLEAN(matrix[0]);
         params[1] = FLOAT_TO_BOOLEAN(matrix[4]);
         params[2] = FLOAT_TO_BOOLEAN(matrix[8]);
         params[3] = FLOAT_TO_BOOLEAN(matrix[12]);
         params[4] = FLOAT_TO_BOOLEAN(matrix[1]);
         params[5] = FLOAT_TO_BOOLEAN(matrix[5]);
         params[6] = FLOAT_TO_BOOLEAN(matrix[9]);
         params[7] = FLOAT_TO_BOOLEAN(matrix[13]);
         params[8] = FLOAT_TO_BOOLEAN(matrix[2]);
         params[9] = FLOAT_TO_BOOLEAN(matrix[6]);
         params[10] = FLOAT_TO_BOOLEAN(matrix[10]);
         params[11] = FLOAT_TO_BOOLEAN(matrix[14]);
         params[12] = FLOAT_TO_BOOLEAN(matrix[3]);
         params[13] = FLOAT_TO_BOOLEAN(matrix[7]);
         params[14] = FLOAT_TO_BOOLEAN(matrix[11]);
         params[15] = FLOAT_TO_BOOLEAN(matrix[15]);
         }
         break;
      case GL_TRANSPOSE_MODELVIEW_MATRIX_ARB:
         {
         const GLfloat *matrix = ctx->ModelviewMatrixStack.Top->m;
         params[0] = FLOAT_TO_BOOLEAN(matrix[0]);
         params[1] = FLOAT_TO_BOOLEAN(matrix[4]);
         params[2] = FLOAT_TO_BOOLEAN(matrix[8]);
         params[3] = FLOAT_TO_BOOLEAN(matrix[12]);
         params[4] = FLOAT_TO_BOOLEAN(matrix[1]);
         params[5] = FLOAT_TO_BOOLEAN(matrix[5]);
         params[6] = FLOAT_TO_BOOLEAN(matrix[9]);
         params[7] = FLOAT_TO_BOOLEAN(matrix[13]);
         params[8] = FLOAT_TO_BOOLEAN(matrix[2]);
         params[9] = FLOAT_TO_BOOLEAN(matrix[6]);
         params[10] = FLOAT_TO_BOOLEAN(matrix[10]);
         params[11] = FLOAT_TO_BOOLEAN(matrix[14]);
         params[12] = FLOAT_TO_BOOLEAN(matrix[3]);
         params[13] = FLOAT_TO_BOOLEAN(matrix[7]);
         params[14] = FLOAT_TO_BOOLEAN(matrix[11]);
         params[15] = FLOAT_TO_BOOLEAN(matrix[15]);
         }
         break;
      case GL_TRANSPOSE_PROJECTION_MATRIX_ARB:
         {
         const GLfloat *matrix = ctx->ProjectionMatrixStack.Top->m;
         params[0] = FLOAT_TO_BOOLEAN(matrix[0]);
         params[1] = FLOAT_TO_BOOLEAN(matrix[4]);
         params[2] = FLOAT_TO_BOOLEAN(matrix[8]);
         params[3] = FLOAT_TO_BOOLEAN(matrix[12]);
         params[4] = FLOAT_TO_BOOLEAN(matrix[1]);
         params[5] = FLOAT_TO_BOOLEAN(matrix[5]);
         params[6] = FLOAT_TO_BOOLEAN(matrix[9]);
         params[7] = FLOAT_TO_BOOLEAN(matrix[13]);
         params[8] = FLOAT_TO_BOOLEAN(matrix[2]);
         params[9] = FLOAT_TO_BOOLEAN(matrix[6]);
         params[10] = FLOAT_TO_BOOLEAN(matrix[10]);
         params[11] = FLOAT_TO_BOOLEAN(matrix[14]);
         params[12] = FLOAT_TO_BOOLEAN(matrix[3]);
         params[13] = FLOAT_TO_BOOLEAN(matrix[7]);
         params[14] = FLOAT_TO_BOOLEAN(matrix[11]);
         params[15] = FLOAT_TO_BOOLEAN(matrix[15]);
         }
         break;
      case GL_TRANSPOSE_TEXTURE_MATRIX_ARB:
         {
         const GLfloat *matrix = ctx->TextureMatrixStack[ctx->Texture.CurrentUnit].Top->m;
         params[0] = FLOAT_TO_BOOLEAN(matrix[0]);
         params[1] = FLOAT_TO_BOOLEAN(matrix[4]);
         params[2] = FLOAT_TO_BOOLEAN(matrix[8]);
         params[3] = FLOAT_TO_BOOLEAN(matrix[12]);
         params[4] = FLOAT_TO_BOOLEAN(matrix[1]);
         params[5] = FLOAT_TO_BOOLEAN(matrix[5]);
         params[6] = FLOAT_TO_BOOLEAN(matrix[9]);
         params[7] = FLOAT_TO_BOOLEAN(matrix[13]);
         params[8] = FLOAT_TO_BOOLEAN(matrix[2]);
         params[9] = FLOAT_TO_BOOLEAN(matrix[6]);
         params[10] = FLOAT_TO_BOOLEAN(matrix[10]);
         params[11] = FLOAT_TO_BOOLEAN(matrix[14]);
         params[12] = FLOAT_TO_BOOLEAN(matrix[3]);
         params[13] = FLOAT_TO_BOOLEAN(matrix[7]);
         params[14] = FLOAT_TO_BOOLEAN(matrix[11]);
         params[15] = FLOAT_TO_BOOLEAN(matrix[15]);
         }
         break;
      case GL_COLOR_MATRIX_SGI:
         {
         const GLfloat *matrix = ctx->ColorMatrixStack.Top->m;
         params[0] = FLOAT_TO_BOOLEAN(matrix[0]);
         params[1] = FLOAT_TO_BOOLEAN(matrix[1]);
         params[2] = FLOAT_TO_BOOLEAN(matrix[2]);
         params[3] = FLOAT_TO_BOOLEAN(matrix[3]);
         params[4] = FLOAT_TO_BOOLEAN(matrix[4]);
         params[5] = FLOAT_TO_BOOLEAN(matrix[5]);
         params[6] = FLOAT_TO_BOOLEAN(matrix[6]);
         params[7] = FLOAT_TO_BOOLEAN(matrix[7]);
         params[8] = FLOAT_TO_BOOLEAN(matrix[8]);
         params[9] = FLOAT_TO_BOOLEAN(matrix[9]);
         params[10] = FLOAT_TO_BOOLEAN(matrix[10]);
         params[11] = FLOAT_TO_BOOLEAN(matrix[11]);
         params[12] = FLOAT_TO_BOOLEAN(matrix[12]);
         params[13] = FLOAT_TO_BOOLEAN(matrix[13]);
         params[14] = FLOAT_TO_BOOLEAN(matrix[14]);
         params[15] = FLOAT_TO_BOOLEAN(matrix[15]);
         }
         break;
      case GL_COLOR_MATRIX_STACK_DEPTH_SGI:
         params[0] = INT_TO_BOOLEAN(ctx->ColorMatrixStack.Depth + 1);
         break;
      case GL_MAX_COLOR_MATRIX_STACK_DEPTH_SGI:
         params[0] = INT_TO_BOOLEAN(MAX_COLOR_STACK_DEPTH);
         break;
      case GL_POST_COLOR_MATRIX_RED_SCALE_SGI:
         params[0] = FLOAT_TO_BOOLEAN(ctx->Pixel.PostColorMatrixScale[0]);
         break;
      case GL_POST_COLOR_MATRIX_GREEN_SCALE_SGI:
         params[0] = FLOAT_TO_BOOLEAN(ctx->Pixel.PostColorMatrixScale[1]);
         break;
      case GL_POST_COLOR_MATRIX_BLUE_SCALE_SGI:
         params[0] = FLOAT_TO_BOOLEAN(ctx->Pixel.PostColorMatrixScale[2]);
         break;
      case GL_POST_COLOR_MATRIX_ALPHA_SCALE_SGI:
         params[0] = FLOAT_TO_BOOLEAN(ctx->Pixel.PostColorMatrixScale[3]);
         break;
      case GL_POST_COLOR_MATRIX_RED_BIAS_SGI:
         params[0] = FLOAT_TO_BOOLEAN(ctx->Pixel.PostColorMatrixBias[0]);
         break;
      case GL_POST_COLOR_MATRIX_GREEN_BIAS_SGI:
         params[0] = FLOAT_TO_BOOLEAN(ctx->Pixel.PostColorMatrixBias[1]);
         break;
      case GL_POST_COLOR_MATRIX_BLUE_BIAS_SGI:
         params[0] = FLOAT_TO_BOOLEAN(ctx->Pixel.PostColorMatrixBias[2]);
         break;
      case GL_POST_COLOR_MATRIX_ALPHA_BIAS_SGI:
         params[0] = FLOAT_TO_BOOLEAN(ctx->Pixel.PostColorMatrixBias[3]);
         break;
      case GL_CONVOLUTION_1D_EXT:
         CHECK_EXT1(EXT_convolution, "GetBooleanv");
         params[0] = ctx->Pixel.Convolution1DEnabled;
         break;
      case GL_CONVOLUTION_2D_EXT:
         CHECK_EXT1(EXT_convolution, "GetBooleanv");
         params[0] = ctx->Pixel.Convolution2DEnabled;
         break;
      case GL_SEPARABLE_2D_EXT:
         CHECK_EXT1(EXT_convolution, "GetBooleanv");
         params[0] = ctx->Pixel.Separable2DEnabled;
         break;
      case GL_POST_CONVOLUTION_RED_SCALE_EXT:
         CHECK_EXT1(EXT_convolution, "GetBooleanv");
         params[0] = FLOAT_TO_BOOLEAN(ctx->Pixel.PostConvolutionScale[0]);
         break;
      case GL_POST_CONVOLUTION_GREEN_SCALE_EXT:
         CHECK_EXT1(EXT_convolution, "GetBooleanv");
         params[0] = FLOAT_TO_BOOLEAN(ctx->Pixel.PostConvolutionScale[1]);
         break;
      case GL_POST_CONVOLUTION_BLUE_SCALE_EXT:
         CHECK_EXT1(EXT_convolution, "GetBooleanv");
         params[0] = FLOAT_TO_BOOLEAN(ctx->Pixel.PostConvolutionScale[2]);
         break;
      case GL_POST_CONVOLUTION_ALPHA_SCALE_EXT:
         CHECK_EXT1(EXT_convolution, "GetBooleanv");
         params[0] = FLOAT_TO_BOOLEAN(ctx->Pixel.PostConvolutionScale[3]);
         break;
      case GL_POST_CONVOLUTION_RED_BIAS_EXT:
         CHECK_EXT1(EXT_convolution, "GetBooleanv");
         params[0] = FLOAT_TO_BOOLEAN(ctx->Pixel.PostConvolutionBias[0]);
         break;
      case GL_POST_CONVOLUTION_GREEN_BIAS_EXT:
         CHECK_EXT1(EXT_convolution, "GetBooleanv");
         params[0] = FLOAT_TO_BOOLEAN(ctx->Pixel.PostConvolutionBias[1]);
         break;
      case GL_POST_CONVOLUTION_BLUE_BIAS_EXT:
         CHECK_EXT1(EXT_convolution, "GetBooleanv");
         params[0] = FLOAT_TO_BOOLEAN(ctx->Pixel.PostConvolutionBias[2]);
         break;
      case GL_POST_CONVOLUTION_ALPHA_BIAS_EXT:
         CHECK_EXT1(EXT_convolution, "GetBooleanv");
         params[0] = FLOAT_TO_BOOLEAN(ctx->Pixel.PostConvolutionBias[3]);
         break;
      case GL_HISTOGRAM:
         CHECK_EXT1(EXT_histogram, "GetBooleanv");
         params[0] = ctx->Pixel.HistogramEnabled;
         break;
      case GL_MINMAX:
         CHECK_EXT1(EXT_histogram, "GetBooleanv");
         params[0] = ctx->Pixel.MinMaxEnabled;
         break;
      case GL_COLOR_TABLE_SGI:
         CHECK_EXT1(SGI_color_table, "GetBooleanv");
         params[0] = ctx->Pixel.ColorTableEnabled[COLORTABLE_PRECONVOLUTION];
         break;
      case GL_POST_CONVOLUTION_COLOR_TABLE_SGI:
         CHECK_EXT1(SGI_color_table, "GetBooleanv");
         params[0] = ctx->Pixel.ColorTableEnabled[COLORTABLE_POSTCONVOLUTION];
         break;
      case GL_POST_COLOR_MATRIX_COLOR_TABLE_SGI:
         CHECK_EXT1(SGI_color_table, "GetBooleanv");
         params[0] = ctx->Pixel.ColorTableEnabled[COLORTABLE_POSTCOLORMATRIX];
         break;
      case GL_TEXTURE_COLOR_TABLE_SGI:
         CHECK_EXT1(SGI_texture_color_table, "GetBooleanv");
         params[0] = ctx->Texture.Unit[ctx->Texture.CurrentUnit].ColorTableEnabled;
         break;
      case GL_COLOR_SUM_EXT:
         CHECK_EXT2(EXT_secondary_color, ARB_vertex_program, "GetBooleanv");
         params[0] = ctx->Fog.ColorSumEnabled;
         break;
      case GL_CURRENT_SECONDARY_COLOR_EXT:
         CHECK_EXT1(EXT_secondary_color, "GetBooleanv");
         {
         FLUSH_CURRENT(ctx, 0);
         params[0] = FLOAT_TO_BOOLEAN(ctx->Current.Attrib[VERT_ATTRIB_COLOR1][0]);
         params[1] = FLOAT_TO_BOOLEAN(ctx->Current.Attrib[VERT_ATTRIB_COLOR1][1]);
         params[2] = FLOAT_TO_BOOLEAN(ctx->Current.Attrib[VERT_ATTRIB_COLOR1][2]);
         params[3] = FLOAT_TO_BOOLEAN(ctx->Current.Attrib[VERT_ATTRIB_COLOR1][3]);
         }
         break;
      case GL_SECONDARY_COLOR_ARRAY_EXT:
         CHECK_EXT1(EXT_secondary_color, "GetBooleanv");
         params[0] = ctx->Array.ArrayObj->SecondaryColor.Enabled;
         break;
      case GL_SECONDARY_COLOR_ARRAY_TYPE_EXT:
         CHECK_EXT1(EXT_secondary_color, "GetBooleanv");
         params[0] = ENUM_TO_BOOLEAN(ctx->Array.ArrayObj->SecondaryColor.Type);
         break;
      case GL_SECONDARY_COLOR_ARRAY_STRIDE_EXT:
         CHECK_EXT1(EXT_secondary_color, "GetBooleanv");
         params[0] = INT_TO_BOOLEAN(ctx->Array.ArrayObj->SecondaryColor.Stride);
         break;
      case GL_SECONDARY_COLOR_ARRAY_SIZE_EXT:
         CHECK_EXT1(EXT_secondary_color, "GetBooleanv");
         params[0] = INT_TO_BOOLEAN(ctx->Array.ArrayObj->SecondaryColor.Size);
         break;
      case GL_CURRENT_FOG_COORDINATE_EXT:
         CHECK_EXT1(EXT_fog_coord, "GetBooleanv");
         {
         FLUSH_CURRENT(ctx, 0);
         params[0] = FLOAT_TO_BOOLEAN(ctx->Current.Attrib[VERT_ATTRIB_FOG][0]);
         }
         break;
      case GL_FOG_COORDINATE_ARRAY_EXT:
         CHECK_EXT1(EXT_fog_coord, "GetBooleanv");
         params[0] = ctx->Array.ArrayObj->FogCoord.Enabled;
         break;
      case GL_FOG_COORDINATE_ARRAY_TYPE_EXT:
         CHECK_EXT1(EXT_fog_coord, "GetBooleanv");
         params[0] = ENUM_TO_BOOLEAN(ctx->Array.ArrayObj->FogCoord.Type);
         break;
      case GL_FOG_COORDINATE_ARRAY_STRIDE_EXT:
         CHECK_EXT1(EXT_fog_coord, "GetBooleanv");
         params[0] = INT_TO_BOOLEAN(ctx->Array.ArrayObj->FogCoord.Stride);
         break;
      case GL_FOG_COORDINATE_SOURCE_EXT:
         CHECK_EXT1(EXT_fog_coord, "GetBooleanv");
         params[0] = ENUM_TO_BOOLEAN(ctx->Fog.FogCoordinateSource);
         break;
      case GL_MAX_TEXTURE_LOD_BIAS_EXT:
         CHECK_EXT1(EXT_texture_lod_bias, "GetBooleanv");
         params[0] = FLOAT_TO_BOOLEAN(ctx->Const.MaxTextureLodBias);
         break;
      case GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT:
         CHECK_EXT1(EXT_texture_filter_anisotropic, "GetBooleanv");
         params[0] = FLOAT_TO_BOOLEAN(ctx->Const.MaxTextureMaxAnisotropy);
         break;
      case GL_MULTISAMPLE_ARB:
         params[0] = ctx->Multisample.Enabled;
         break;
      case GL_SAMPLE_ALPHA_TO_COVERAGE_ARB:
         params[0] = ctx->Multisample.SampleAlphaToCoverage;
         break;
      case GL_SAMPLE_ALPHA_TO_ONE_ARB:
         params[0] = ctx->Multisample.SampleAlphaToOne;
         break;
      case GL_SAMPLE_COVERAGE_ARB:
         params[0] = ctx->Multisample.SampleCoverage;
         break;
      case GL_SAMPLE_COVERAGE_VALUE_ARB:
         params[0] = FLOAT_TO_BOOLEAN(ctx->Multisample.SampleCoverageValue);
         break;
      case GL_SAMPLE_COVERAGE_INVERT_ARB:
         params[0] = ctx->Multisample.SampleCoverageInvert;
         break;
      case GL_SAMPLE_BUFFERS_ARB:
         params[0] = INT_TO_BOOLEAN(ctx->DrawBuffer->Visual.sampleBuffers);
         break;
      case GL_SAMPLES_ARB:
         params[0] = INT_TO_BOOLEAN(ctx->DrawBuffer->Visual.samples);
         break;
      case GL_RASTER_POSITION_UNCLIPPED_IBM:
         CHECK_EXT1(IBM_rasterpos_clip, "GetBooleanv");
         params[0] = ctx->Transform.RasterPositionUnclipped;
         break;
      case GL_POINT_SPRITE_NV:
         CHECK_EXT2(NV_point_sprite, ARB_point_sprite, "GetBooleanv");
         params[0] = ctx->Point.PointSprite;
         break;
      case GL_POINT_SPRITE_R_MODE_NV:
         CHECK_EXT1(NV_point_sprite, "GetBooleanv");
         params[0] = ENUM_TO_BOOLEAN(ctx->Point.SpriteRMode);
         break;
      case GL_POINT_SPRITE_COORD_ORIGIN:
         CHECK_EXT2(NV_point_sprite, ARB_point_sprite, "GetBooleanv");
         params[0] = ENUM_TO_BOOLEAN(ctx->Point.SpriteOrigin);
         break;
      case GL_GENERATE_MIPMAP_HINT_SGIS:
         CHECK_EXT1(SGIS_generate_mipmap, "GetBooleanv");
         params[0] = ENUM_TO_BOOLEAN(ctx->Hint.GenerateMipmap);
         break;
      case GL_VERTEX_PROGRAM_BINDING_NV:
         CHECK_EXT1(NV_vertex_program, "GetBooleanv");
         params[0] = INT_TO_BOOLEAN((ctx->VertexProgram.Current ? ctx->VertexProgram.Current->Base.Id : 0));
         break;
      case GL_VERTEX_ATTRIB_ARRAY0_NV:
         CHECK_EXT1(NV_vertex_program, "GetBooleanv");
         params[0] = ctx->Array.ArrayObj->VertexAttrib[0].Enabled;
         break;
      case GL_VERTEX_ATTRIB_ARRAY1_NV:
         CHECK_EXT1(NV_vertex_program, "GetBooleanv");
         params[0] = ctx->Array.ArrayObj->VertexAttrib[1].Enabled;
         break;
      case GL_VERTEX_ATTRIB_ARRAY2_NV:
         CHECK_EXT1(NV_vertex_program, "GetBooleanv");
         params[0] = ctx->Array.ArrayObj->VertexAttrib[2].Enabled;
         break;
      case GL_VERTEX_ATTRIB_ARRAY3_NV:
         CHECK_EXT1(NV_vertex_program, "GetBooleanv");
         params[0] = ctx->Array.ArrayObj->VertexAttrib[3].Enabled;
         break;
      case GL_VERTEX_ATTRIB_ARRAY4_NV:
         CHECK_EXT1(NV_vertex_program, "GetBooleanv");
         params[0] = ctx->Array.ArrayObj->VertexAttrib[4].Enabled;
         break;
      case GL_VERTEX_ATTRIB_ARRAY5_NV:
         CHECK_EXT1(NV_vertex_program, "GetBooleanv");
         params[0] = ctx->Array.ArrayObj->VertexAttrib[5].Enabled;
         break;
      case GL_VERTEX_ATTRIB_ARRAY6_NV:
         CHECK_EXT1(NV_vertex_program, "GetBooleanv");
         params[0] = ctx->Array.ArrayObj->VertexAttrib[6].Enabled;
         break;
      case GL_VERTEX_ATTRIB_ARRAY7_NV:
         CHECK_EXT1(NV_vertex_program, "GetBooleanv");
         params[0] = ctx->Array.ArrayObj->VertexAttrib[7].Enabled;
         break;
      case GL_VERTEX_ATTRIB_ARRAY8_NV:
         CHECK_EXT1(NV_vertex_program, "GetBooleanv");
         params[0] = ctx->Array.ArrayObj->VertexAttrib[8].Enabled;
         break;
      case GL_VERTEX_ATTRIB_ARRAY9_NV:
         CHECK_EXT1(NV_vertex_program, "GetBooleanv");
         params[0] = ctx->Array.ArrayObj->VertexAttrib[9].Enabled;
         break;
      case GL_VERTEX_ATTRIB_ARRAY10_NV:
         CHECK_EXT1(NV_vertex_program, "GetBooleanv");
         params[0] = ctx->Array.ArrayObj->VertexAttrib[10].Enabled;
         break;
      case GL_VERTEX_ATTRIB_ARRAY11_NV:
         CHECK_EXT1(NV_vertex_program, "GetBooleanv");
         params[0] = ctx->Array.ArrayObj->VertexAttrib[11].Enabled;
         break;
      case GL_VERTEX_ATTRIB_ARRAY12_NV:
         CHECK_EXT1(NV_vertex_program, "GetBooleanv");
         params[0] = ctx->Array.ArrayObj->VertexAttrib[12].Enabled;
         break;
      case GL_VERTEX_ATTRIB_ARRAY13_NV:
         CHECK_EXT1(NV_vertex_program, "GetBooleanv");
         params[0] = ctx->Array.ArrayObj->VertexAttrib[13].Enabled;
         break;
      case GL_VERTEX_ATTRIB_ARRAY14_NV:
         CHECK_EXT1(NV_vertex_program, "GetBooleanv");
         params[0] = ctx->Array.ArrayObj->VertexAttrib[14].Enabled;
         break;
      case GL_VERTEX_ATTRIB_ARRAY15_NV:
         CHECK_EXT1(NV_vertex_program, "GetBooleanv");
         params[0] = ctx->Array.ArrayObj->VertexAttrib[15].Enabled;
         break;
      case GL_MAP1_VERTEX_ATTRIB0_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetBooleanv");
         params[0] = ctx->Eval.Map1Attrib[0];
         break;
      case GL_MAP1_VERTEX_ATTRIB1_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetBooleanv");
         params[0] = ctx->Eval.Map1Attrib[1];
         break;
      case GL_MAP1_VERTEX_ATTRIB2_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetBooleanv");
         params[0] = ctx->Eval.Map1Attrib[2];
         break;
      case GL_MAP1_VERTEX_ATTRIB3_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetBooleanv");
         params[0] = ctx->Eval.Map1Attrib[3];
         break;
      case GL_MAP1_VERTEX_ATTRIB4_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetBooleanv");
         params[0] = ctx->Eval.Map1Attrib[4];
         break;
      case GL_MAP1_VERTEX_ATTRIB5_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetBooleanv");
         params[0] = ctx->Eval.Map1Attrib[5];
         break;
      case GL_MAP1_VERTEX_ATTRIB6_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetBooleanv");
         params[0] = ctx->Eval.Map1Attrib[6];
         break;
      case GL_MAP1_VERTEX_ATTRIB7_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetBooleanv");
         params[0] = ctx->Eval.Map1Attrib[7];
         break;
      case GL_MAP1_VERTEX_ATTRIB8_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetBooleanv");
         params[0] = ctx->Eval.Map1Attrib[8];
         break;
      case GL_MAP1_VERTEX_ATTRIB9_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetBooleanv");
         params[0] = ctx->Eval.Map1Attrib[9];
         break;
      case GL_MAP1_VERTEX_ATTRIB10_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetBooleanv");
         params[0] = ctx->Eval.Map1Attrib[10];
         break;
      case GL_MAP1_VERTEX_ATTRIB11_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetBooleanv");
         params[0] = ctx->Eval.Map1Attrib[11];
         break;
      case GL_MAP1_VERTEX_ATTRIB12_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetBooleanv");
         params[0] = ctx->Eval.Map1Attrib[12];
         break;
      case GL_MAP1_VERTEX_ATTRIB13_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetBooleanv");
         params[0] = ctx->Eval.Map1Attrib[13];
         break;
      case GL_MAP1_VERTEX_ATTRIB14_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetBooleanv");
         params[0] = ctx->Eval.Map1Attrib[14];
         break;
      case GL_MAP1_VERTEX_ATTRIB15_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetBooleanv");
         params[0] = ctx->Eval.Map1Attrib[15];
         break;
      case GL_FRAGMENT_PROGRAM_NV:
         CHECK_EXT1(NV_fragment_program, "GetBooleanv");
         params[0] = ctx->FragmentProgram.Enabled;
         break;
      case GL_FRAGMENT_PROGRAM_BINDING_NV:
         CHECK_EXT1(NV_fragment_program, "GetBooleanv");
         params[0] = INT_TO_BOOLEAN(ctx->FragmentProgram.Current ? ctx->FragmentProgram.Current->Base.Id : 0);
         break;
      case GL_MAX_FRAGMENT_PROGRAM_LOCAL_PARAMETERS_NV:
         CHECK_EXT1(NV_fragment_program, "GetBooleanv");
         params[0] = INT_TO_BOOLEAN(MAX_NV_FRAGMENT_PROGRAM_PARAMS);
         break;
      case GL_TEXTURE_RECTANGLE_NV:
         CHECK_EXT1(NV_texture_rectangle, "GetBooleanv");
         params[0] = _mesa_IsEnabled(GL_TEXTURE_RECTANGLE_NV);
         break;
      case GL_TEXTURE_BINDING_RECTANGLE_NV:
         CHECK_EXT1(NV_texture_rectangle, "GetBooleanv");
         params[0] = INT_TO_BOOLEAN(ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentTex[TEXTURE_RECT_INDEX]->Name);
         break;
      case GL_MAX_RECTANGLE_TEXTURE_SIZE_NV:
         CHECK_EXT1(NV_texture_rectangle, "GetBooleanv");
         params[0] = INT_TO_BOOLEAN(ctx->Const.MaxTextureRectSize);
         break;
      case GL_STENCIL_TEST_TWO_SIDE_EXT:
         CHECK_EXT1(EXT_stencil_two_side, "GetBooleanv");
         params[0] = ctx->Stencil.TestTwoSide;
         break;
      case GL_ACTIVE_STENCIL_FACE_EXT:
         CHECK_EXT1(EXT_stencil_two_side, "GetBooleanv");
         params[0] = ENUM_TO_BOOLEAN(ctx->Stencil.ActiveFace ? GL_BACK : GL_FRONT);
         break;
      case GL_MAX_SHININESS_NV:
         CHECK_EXT1(NV_light_max_exponent, "GetBooleanv");
         params[0] = FLOAT_TO_BOOLEAN(ctx->Const.MaxShininess);
         break;
      case GL_MAX_SPOT_EXPONENT_NV:
         CHECK_EXT1(NV_light_max_exponent, "GetBooleanv");
         params[0] = FLOAT_TO_BOOLEAN(ctx->Const.MaxSpotExponent);
         break;
      case GL_ARRAY_BUFFER_BINDING_ARB:
         params[0] = INT_TO_BOOLEAN(ctx->Array.ArrayBufferObj->Name);
         break;
      case GL_VERTEX_ARRAY_BUFFER_BINDING_ARB:
         params[0] = INT_TO_BOOLEAN(ctx->Array.ArrayObj->Vertex.BufferObj->Name);
         break;
      case GL_NORMAL_ARRAY_BUFFER_BINDING_ARB:
         params[0] = INT_TO_BOOLEAN(ctx->Array.ArrayObj->Normal.BufferObj->Name);
         break;
      case GL_COLOR_ARRAY_BUFFER_BINDING_ARB:
         params[0] = INT_TO_BOOLEAN(ctx->Array.ArrayObj->Color.BufferObj->Name);
         break;
      case GL_INDEX_ARRAY_BUFFER_BINDING_ARB:
         params[0] = INT_TO_BOOLEAN(ctx->Array.ArrayObj->Index.BufferObj->Name);
         break;
      case GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING_ARB:
         params[0] = INT_TO_BOOLEAN(ctx->Array.ArrayObj->TexCoord[ctx->Array.ActiveTexture].BufferObj->Name);
         break;
      case GL_EDGE_FLAG_ARRAY_BUFFER_BINDING_ARB:
         params[0] = INT_TO_BOOLEAN(ctx->Array.ArrayObj->EdgeFlag.BufferObj->Name);
         break;
      case GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING_ARB:
         params[0] = INT_TO_BOOLEAN(ctx->Array.ArrayObj->SecondaryColor.BufferObj->Name);
         break;
      case GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING_ARB:
         params[0] = INT_TO_BOOLEAN(ctx->Array.ArrayObj->FogCoord.BufferObj->Name);
         break;
      case GL_ELEMENT_ARRAY_BUFFER_BINDING_ARB:
         params[0] = INT_TO_BOOLEAN(ctx->Array.ElementArrayBufferObj->Name);
         break;
      case GL_PIXEL_PACK_BUFFER_BINDING_EXT:
         CHECK_EXT1(EXT_pixel_buffer_object, "GetBooleanv");
         params[0] = INT_TO_BOOLEAN(ctx->Pack.BufferObj->Name);
         break;
      case GL_PIXEL_UNPACK_BUFFER_BINDING_EXT:
         CHECK_EXT1(EXT_pixel_buffer_object, "GetBooleanv");
         params[0] = INT_TO_BOOLEAN(ctx->Unpack.BufferObj->Name);
         break;
      case GL_VERTEX_PROGRAM_ARB:
         CHECK_EXT2(ARB_vertex_program, NV_vertex_program, "GetBooleanv");
         params[0] = ctx->VertexProgram.Enabled;
         break;
      case GL_VERTEX_PROGRAM_POINT_SIZE_ARB:
         CHECK_EXT2(ARB_vertex_program, NV_vertex_program, "GetBooleanv");
         params[0] = ctx->VertexProgram.PointSizeEnabled;
         break;
      case GL_VERTEX_PROGRAM_TWO_SIDE_ARB:
         CHECK_EXT2(ARB_vertex_program, NV_vertex_program, "GetBooleanv");
         params[0] = ctx->VertexProgram.TwoSideEnabled;
         break;
      case GL_MAX_PROGRAM_MATRIX_STACK_DEPTH_ARB:
         CHECK_EXT3(ARB_vertex_program, ARB_fragment_program, NV_vertex_program, "GetBooleanv");
         params[0] = INT_TO_BOOLEAN(ctx->Const.MaxProgramMatrixStackDepth);
         break;
      case GL_MAX_PROGRAM_MATRICES_ARB:
         CHECK_EXT3(ARB_vertex_program, ARB_fragment_program, NV_vertex_program, "GetBooleanv");
         params[0] = INT_TO_BOOLEAN(ctx->Const.MaxProgramMatrices);
         break;
      case GL_CURRENT_MATRIX_STACK_DEPTH_ARB:
         CHECK_EXT3(ARB_vertex_program, ARB_fragment_program, NV_vertex_program, "GetBooleanv");
         params[0] = ctx->CurrentStack->Depth + 1;
         break;
      case GL_CURRENT_MATRIX_ARB:
         CHECK_EXT3(ARB_vertex_program, ARB_fragment_program, NV_fragment_program, "GetBooleanv");
         {
         const GLfloat *matrix = ctx->CurrentStack->Top->m;
         params[0] = FLOAT_TO_BOOLEAN(matrix[0]);
         params[1] = FLOAT_TO_BOOLEAN(matrix[1]);
         params[2] = FLOAT_TO_BOOLEAN(matrix[2]);
         params[3] = FLOAT_TO_BOOLEAN(matrix[3]);
         params[4] = FLOAT_TO_BOOLEAN(matrix[4]);
         params[5] = FLOAT_TO_BOOLEAN(matrix[5]);
         params[6] = FLOAT_TO_BOOLEAN(matrix[6]);
         params[7] = FLOAT_TO_BOOLEAN(matrix[7]);
         params[8] = FLOAT_TO_BOOLEAN(matrix[8]);
         params[9] = FLOAT_TO_BOOLEAN(matrix[9]);
         params[10] = FLOAT_TO_BOOLEAN(matrix[10]);
         params[11] = FLOAT_TO_BOOLEAN(matrix[11]);
         params[12] = FLOAT_TO_BOOLEAN(matrix[12]);
         params[13] = FLOAT_TO_BOOLEAN(matrix[13]);
         params[14] = FLOAT_TO_BOOLEAN(matrix[14]);
         params[15] = FLOAT_TO_BOOLEAN(matrix[15]);
         }
         break;
      case GL_TRANSPOSE_CURRENT_MATRIX_ARB:
         CHECK_EXT2(ARB_vertex_program, ARB_fragment_program, "GetBooleanv");
         {
         const GLfloat *matrix = ctx->CurrentStack->Top->m;
         params[0] = FLOAT_TO_BOOLEAN(matrix[0]);
         params[1] = FLOAT_TO_BOOLEAN(matrix[4]);
         params[2] = FLOAT_TO_BOOLEAN(matrix[8]);
         params[3] = FLOAT_TO_BOOLEAN(matrix[12]);
         params[4] = FLOAT_TO_BOOLEAN(matrix[1]);
         params[5] = FLOAT_TO_BOOLEAN(matrix[5]);
         params[6] = FLOAT_TO_BOOLEAN(matrix[9]);
         params[7] = FLOAT_TO_BOOLEAN(matrix[13]);
         params[8] = FLOAT_TO_BOOLEAN(matrix[2]);
         params[9] = FLOAT_TO_BOOLEAN(matrix[6]);
         params[10] = FLOAT_TO_BOOLEAN(matrix[10]);
         params[11] = FLOAT_TO_BOOLEAN(matrix[14]);
         params[12] = FLOAT_TO_BOOLEAN(matrix[3]);
         params[13] = FLOAT_TO_BOOLEAN(matrix[7]);
         params[14] = FLOAT_TO_BOOLEAN(matrix[11]);
         params[15] = FLOAT_TO_BOOLEAN(matrix[15]);
         }
         break;
      case GL_MAX_VERTEX_ATTRIBS_ARB:
         CHECK_EXT1(ARB_vertex_program, "GetBooleanv");
         params[0] = INT_TO_BOOLEAN(ctx->Const.VertexProgram.MaxAttribs);
         break;
      case GL_PROGRAM_ERROR_POSITION_ARB:
         CHECK_EXT4(NV_vertex_program, ARB_vertex_program, NV_fragment_program, ARB_fragment_program, "GetBooleanv");
         params[0] = INT_TO_BOOLEAN(ctx->Program.ErrorPos);
         break;
      case GL_FRAGMENT_PROGRAM_ARB:
         CHECK_EXT1(ARB_fragment_program, "GetBooleanv");
         params[0] = ctx->FragmentProgram.Enabled;
         break;
      case GL_MAX_TEXTURE_COORDS_ARB:
         CHECK_EXT2(ARB_fragment_program, NV_fragment_program, "GetBooleanv");
         params[0] = INT_TO_BOOLEAN(ctx->Const.MaxTextureCoordUnits);
         break;
      case GL_MAX_TEXTURE_IMAGE_UNITS_ARB:
         CHECK_EXT2(ARB_fragment_program, NV_fragment_program, "GetBooleanv");
         params[0] = INT_TO_BOOLEAN(ctx->Const.MaxTextureImageUnits);
         break;
      case GL_DEPTH_BOUNDS_TEST_EXT:
         CHECK_EXT1(EXT_depth_bounds_test, "GetBooleanv");
         params[0] = ctx->Depth.BoundsTest;
         break;
      case GL_DEPTH_BOUNDS_EXT:
         CHECK_EXT1(EXT_depth_bounds_test, "GetBooleanv");
         params[0] = FLOAT_TO_BOOLEAN(ctx->Depth.BoundsMin);
         params[1] = FLOAT_TO_BOOLEAN(ctx->Depth.BoundsMax);
         break;
      case GL_DEPTH_CLAMP:
         CHECK_EXT1(ARB_depth_clamp, "GetBooleanv");
         params[0] = ctx->Transform.DepthClamp;
         break;
      case GL_MAX_DRAW_BUFFERS_ARB:
         params[0] = INT_TO_BOOLEAN(ctx->Const.MaxDrawBuffers);
         break;
      case GL_DRAW_BUFFER0_ARB:
         params[0] = ENUM_TO_BOOLEAN(ctx->DrawBuffer->ColorDrawBuffer[0]);
         break;
      case GL_DRAW_BUFFER1_ARB:
         {
         GLenum buffer;
         if (pname - GL_DRAW_BUFFER0_ARB >= ctx->Const.MaxDrawBuffers) {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGet(GL_DRAW_BUFFERx_ARB)");
            return;
         }
         buffer = ctx->DrawBuffer->ColorDrawBuffer[1];
         params[0] = ENUM_TO_BOOLEAN(buffer);
         }
         break;
      case GL_DRAW_BUFFER2_ARB:
         {
         GLenum buffer;
         if (pname - GL_DRAW_BUFFER0_ARB >= ctx->Const.MaxDrawBuffers) {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGet(GL_DRAW_BUFFERx_ARB)");
            return;
         }
         buffer = ctx->DrawBuffer->ColorDrawBuffer[2];
         params[0] = ENUM_TO_BOOLEAN(buffer);
         }
         break;
      case GL_DRAW_BUFFER3_ARB:
         {
         GLenum buffer;
         if (pname - GL_DRAW_BUFFER0_ARB >= ctx->Const.MaxDrawBuffers) {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGet(GL_DRAW_BUFFERx_ARB)");
            return;
         }
         buffer = ctx->DrawBuffer->ColorDrawBuffer[3];
         params[0] = ENUM_TO_BOOLEAN(buffer);
         }
         break;
      case GL_IMPLEMENTATION_COLOR_READ_TYPE_OES:
         CHECK_EXT1(OES_read_format, "GetBooleanv");
         params[0] = INT_TO_BOOLEAN(_mesa_get_color_read_type(ctx));
         break;
      case GL_IMPLEMENTATION_COLOR_READ_FORMAT_OES:
         CHECK_EXT1(OES_read_format, "GetBooleanv");
         params[0] = INT_TO_BOOLEAN(_mesa_get_color_read_format(ctx));
         break;
      case GL_NUM_FRAGMENT_REGISTERS_ATI:
         CHECK_EXT1(ATI_fragment_shader, "GetBooleanv");
         params[0] = INT_TO_BOOLEAN(6);
         break;
      case GL_NUM_FRAGMENT_CONSTANTS_ATI:
         CHECK_EXT1(ATI_fragment_shader, "GetBooleanv");
         params[0] = INT_TO_BOOLEAN(8);
         break;
      case GL_NUM_PASSES_ATI:
         CHECK_EXT1(ATI_fragment_shader, "GetBooleanv");
         params[0] = INT_TO_BOOLEAN(2);
         break;
      case GL_NUM_INSTRUCTIONS_PER_PASS_ATI:
         CHECK_EXT1(ATI_fragment_shader, "GetBooleanv");
         params[0] = INT_TO_BOOLEAN(8);
         break;
      case GL_NUM_INSTRUCTIONS_TOTAL_ATI:
         CHECK_EXT1(ATI_fragment_shader, "GetBooleanv");
         params[0] = INT_TO_BOOLEAN(16);
         break;
      case GL_COLOR_ALPHA_PAIRING_ATI:
         CHECK_EXT1(ATI_fragment_shader, "GetBooleanv");
         params[0] = GL_TRUE;
         break;
      case GL_NUM_LOOPBACK_COMPONENTS_ATI:
         CHECK_EXT1(ATI_fragment_shader, "GetBooleanv");
         params[0] = INT_TO_BOOLEAN(3);
         break;
      case GL_NUM_INPUT_INTERPOLATOR_COMPONENTS_ATI:
         CHECK_EXT1(ATI_fragment_shader, "GetBooleanv");
         params[0] = INT_TO_BOOLEAN(3);
         break;
      case GL_STENCIL_BACK_FUNC:
         params[0] = ENUM_TO_BOOLEAN(ctx->Stencil.Function[1]);
         break;
      case GL_STENCIL_BACK_VALUE_MASK:
         params[0] = INT_TO_BOOLEAN(ctx->Stencil.ValueMask[1]);
         break;
      case GL_STENCIL_BACK_WRITEMASK:
         params[0] = INT_TO_BOOLEAN(ctx->Stencil.WriteMask[1]);
         break;
      case GL_STENCIL_BACK_REF:
         params[0] = INT_TO_BOOLEAN(ctx->Stencil.Ref[1]);
         break;
      case GL_STENCIL_BACK_FAIL:
         params[0] = ENUM_TO_BOOLEAN(ctx->Stencil.FailFunc[1]);
         break;
      case GL_STENCIL_BACK_PASS_DEPTH_FAIL:
         params[0] = ENUM_TO_BOOLEAN(ctx->Stencil.ZFailFunc[1]);
         break;
      case GL_STENCIL_BACK_PASS_DEPTH_PASS:
         params[0] = ENUM_TO_BOOLEAN(ctx->Stencil.ZPassFunc[1]);
         break;
      case GL_FRAMEBUFFER_BINDING_EXT:
         CHECK_EXT1(EXT_framebuffer_object, "GetBooleanv");
         params[0] = INT_TO_BOOLEAN(ctx->DrawBuffer->Name);
         break;
      case GL_RENDERBUFFER_BINDING_EXT:
         CHECK_EXT1(EXT_framebuffer_object, "GetBooleanv");
         params[0] = INT_TO_BOOLEAN(ctx->CurrentRenderbuffer ? ctx->CurrentRenderbuffer->Name : 0);
         break;
      case GL_MAX_COLOR_ATTACHMENTS_EXT:
         CHECK_EXT1(EXT_framebuffer_object, "GetBooleanv");
         params[0] = INT_TO_BOOLEAN(ctx->Const.MaxColorAttachments);
         break;
      case GL_MAX_RENDERBUFFER_SIZE_EXT:
         CHECK_EXT1(EXT_framebuffer_object, "GetBooleanv");
         params[0] = INT_TO_BOOLEAN(ctx->Const.MaxRenderbufferSize);
         break;
      case GL_READ_FRAMEBUFFER_BINDING_EXT:
         CHECK_EXT1(EXT_framebuffer_blit, "GetBooleanv");
         params[0] = INT_TO_BOOLEAN(ctx->ReadBuffer->Name);
         break;
      case GL_PROVOKING_VERTEX_EXT:
         CHECK_EXT1(EXT_provoking_vertex, "GetBooleanv");
         params[0] = ctx->Light.ProvokingVertex;
         break;
      case GL_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION_EXT:
         CHECK_EXT1(EXT_provoking_vertex, "GetBooleanv");
         params[0] = ctx->Const.QuadsFollowProvokingVertexConvention;
         break;
      case GL_MAX_FRAGMENT_UNIFORM_COMPONENTS_ARB:
         CHECK_EXT1(ARB_fragment_shader, "GetBooleanv");
         params[0] = INT_TO_BOOLEAN(ctx->Const.FragmentProgram.MaxUniformComponents);
         break;
      case GL_FRAGMENT_SHADER_DERIVATIVE_HINT_ARB:
         CHECK_EXT1(ARB_fragment_shader, "GetBooleanv");
         params[0] = ENUM_TO_BOOLEAN(ctx->Hint.FragmentShaderDerivative);
         break;
      case GL_MAX_VERTEX_UNIFORM_COMPONENTS_ARB:
         CHECK_EXT1(ARB_vertex_shader, "GetBooleanv");
         params[0] = INT_TO_BOOLEAN(ctx->Const.VertexProgram.MaxUniformComponents);
         break;
      case GL_MAX_VARYING_FLOATS_ARB:
         CHECK_EXT1(ARB_vertex_shader, "GetBooleanv");
         params[0] = INT_TO_BOOLEAN(ctx->Const.MaxVarying * 4);
         break;
      case GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS_ARB:
         CHECK_EXT1(ARB_vertex_shader, "GetBooleanv");
         params[0] = INT_TO_BOOLEAN(ctx->Const.MaxVertexTextureImageUnits);
         break;
      case GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS_ARB:
         CHECK_EXT1(ARB_vertex_shader, "GetBooleanv");
         params[0] = INT_TO_BOOLEAN(ctx->Const.MaxCombinedTextureImageUnits);
         break;
      case GL_CURRENT_PROGRAM:
         CHECK_EXT1(ARB_shader_objects, "GetBooleanv");
         params[0] = INT_TO_BOOLEAN(ctx->Shader.CurrentProgram ? ctx->Shader.CurrentProgram->Name : 0);
         break;
      case GL_MAX_SAMPLES:
         CHECK_EXT1(ARB_framebuffer_object, "GetBooleanv");
         params[0] = INT_TO_BOOLEAN(ctx->Const.MaxSamples);
         break;
      case GL_VERTEX_ARRAY_BINDING_APPLE:
         CHECK_EXT1(APPLE_vertex_array_object, "GetBooleanv");
         params[0] = INT_TO_BOOLEAN(ctx->Array.ArrayObj->Name);
         break;
      case GL_TEXTURE_CUBE_MAP_SEAMLESS:
         CHECK_EXT1(ARB_seamless_cube_map, "GetBooleanv");
         params[0] = ctx->Texture.CubeMapSeamless;
         break;
      case GL_MAX_SERVER_WAIT_TIMEOUT:
         CHECK_EXT1(ARB_sync, "GetBooleanv");
         params[0] = INT64_TO_BOOLEAN(ctx->Const.MaxServerWaitTimeout);
         break;
      case GL_NUM_EXTENSIONS:
         params[0] = INT_TO_BOOLEAN(_mesa_get_extension_count(ctx));
         break;
      case GL_MAJOR_VERSION:
         params[0] = INT_TO_BOOLEAN(ctx->VersionMajor);
         break;
      case GL_MINOR_VERSION:
         params[0] = INT_TO_BOOLEAN(ctx->VersionMinor);
         break;
      default:
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetBooleanv(pname=0x%x)", pname);
d1812 3
d1817 7
d1825 1
a1825 1
_mesa_GetFloatv( GLenum pname, GLfloat *params )
d1827 80
a1906 2
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d1908 81
a1988 1860
   if (!params)
      return;

   if (ctx->NewState)
      _mesa_update_state(ctx);

   if (ctx->Driver.GetFloatv &&
       ctx->Driver.GetFloatv(ctx, pname, params))
      return;

   switch (pname) {
      case GL_ACCUM_RED_BITS:
         params[0] = (GLfloat)(ctx->DrawBuffer->Visual.accumRedBits);
         break;
      case GL_ACCUM_GREEN_BITS:
         params[0] = (GLfloat)(ctx->DrawBuffer->Visual.accumGreenBits);
         break;
      case GL_ACCUM_BLUE_BITS:
         params[0] = (GLfloat)(ctx->DrawBuffer->Visual.accumBlueBits);
         break;
      case GL_ACCUM_ALPHA_BITS:
         params[0] = (GLfloat)(ctx->DrawBuffer->Visual.accumAlphaBits);
         break;
      case GL_ACCUM_CLEAR_VALUE:
         params[0] = ctx->Accum.ClearColor[0];
         params[1] = ctx->Accum.ClearColor[1];
         params[2] = ctx->Accum.ClearColor[2];
         params[3] = ctx->Accum.ClearColor[3];
         break;
      case GL_ALPHA_BIAS:
         params[0] = ctx->Pixel.AlphaBias;
         break;
      case GL_ALPHA_BITS:
         params[0] = (GLfloat)(ctx->DrawBuffer->Visual.alphaBits);
         break;
      case GL_ALPHA_SCALE:
         params[0] = ctx->Pixel.AlphaScale;
         break;
      case GL_ALPHA_TEST:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Color.AlphaEnabled);
         break;
      case GL_ALPHA_TEST_FUNC:
         params[0] = ENUM_TO_FLOAT(ctx->Color.AlphaFunc);
         break;
      case GL_ALPHA_TEST_REF:
         params[0] = ctx->Color.AlphaRef;
         break;
      case GL_ATTRIB_STACK_DEPTH:
         params[0] = (GLfloat)(ctx->AttribStackDepth);
         break;
      case GL_AUTO_NORMAL:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Eval.AutoNormal);
         break;
      case GL_AUX_BUFFERS:
         params[0] = (GLfloat)(ctx->DrawBuffer->Visual.numAuxBuffers);
         break;
      case GL_BLEND:
         params[0] = BOOLEAN_TO_FLOAT((ctx->Color.BlendEnabled & 1));
         break;
      case GL_BLEND_DST:
         params[0] = ENUM_TO_FLOAT(ctx->Color.BlendDstRGB);
         break;
      case GL_BLEND_SRC:
         params[0] = ENUM_TO_FLOAT(ctx->Color.BlendSrcRGB);
         break;
      case GL_BLEND_SRC_RGB_EXT:
         params[0] = ENUM_TO_FLOAT(ctx->Color.BlendSrcRGB);
         break;
      case GL_BLEND_DST_RGB_EXT:
         params[0] = ENUM_TO_FLOAT(ctx->Color.BlendDstRGB);
         break;
      case GL_BLEND_SRC_ALPHA_EXT:
         params[0] = ENUM_TO_FLOAT(ctx->Color.BlendSrcA);
         break;
      case GL_BLEND_DST_ALPHA_EXT:
         params[0] = ENUM_TO_FLOAT(ctx->Color.BlendDstA);
         break;
      case GL_BLEND_EQUATION:
         params[0] = ENUM_TO_FLOAT(ctx->Color.BlendEquationRGB );
         break;
      case GL_BLEND_EQUATION_ALPHA_EXT:
         params[0] = ENUM_TO_FLOAT(ctx->Color.BlendEquationA );
         break;
      case GL_BLEND_COLOR_EXT:
         params[0] = ctx->Color.BlendColor[0];
         params[1] = ctx->Color.BlendColor[1];
         params[2] = ctx->Color.BlendColor[2];
         params[3] = ctx->Color.BlendColor[3];
         break;
      case GL_BLUE_BIAS:
         params[0] = ctx->Pixel.BlueBias;
         break;
      case GL_BLUE_BITS:
         params[0] = (GLfloat)(ctx->DrawBuffer->Visual.blueBits);
         break;
      case GL_BLUE_SCALE:
         params[0] = ctx->Pixel.BlueScale;
         break;
      case GL_CLIENT_ATTRIB_STACK_DEPTH:
         params[0] = (GLfloat)(ctx->ClientAttribStackDepth);
         break;
      case GL_CLIP_PLANE0:
         params[0] = BOOLEAN_TO_FLOAT((ctx->Transform.ClipPlanesEnabled >> 0) & 1);
         break;
      case GL_CLIP_PLANE1:
         params[0] = BOOLEAN_TO_FLOAT((ctx->Transform.ClipPlanesEnabled >> 1) & 1);
         break;
      case GL_CLIP_PLANE2:
         params[0] = BOOLEAN_TO_FLOAT((ctx->Transform.ClipPlanesEnabled >> 2) & 1);
         break;
      case GL_CLIP_PLANE3:
         params[0] = BOOLEAN_TO_FLOAT((ctx->Transform.ClipPlanesEnabled >> 3) & 1);
         break;
      case GL_CLIP_PLANE4:
         params[0] = BOOLEAN_TO_FLOAT((ctx->Transform.ClipPlanesEnabled >> 4) & 1);
         break;
      case GL_CLIP_PLANE5:
         params[0] = BOOLEAN_TO_FLOAT((ctx->Transform.ClipPlanesEnabled >> 5) & 1);
         break;
      case GL_COLOR_CLEAR_VALUE:
         params[0] = ctx->Color.ClearColor[0];
         params[1] = ctx->Color.ClearColor[1];
         params[2] = ctx->Color.ClearColor[2];
         params[3] = ctx->Color.ClearColor[3];
         break;
      case GL_COLOR_MATERIAL:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Light.ColorMaterialEnabled);
         break;
      case GL_COLOR_MATERIAL_FACE:
         params[0] = ENUM_TO_FLOAT(ctx->Light.ColorMaterialFace);
         break;
      case GL_COLOR_MATERIAL_PARAMETER:
         params[0] = ENUM_TO_FLOAT(ctx->Light.ColorMaterialMode);
         break;
      case GL_COLOR_WRITEMASK:
         params[0] = (GLfloat)(ctx->Color.ColorMask[0][RCOMP] ? 1 : 0);
         params[1] = (GLfloat)(ctx->Color.ColorMask[0][GCOMP] ? 1 : 0);
         params[2] = (GLfloat)(ctx->Color.ColorMask[0][BCOMP] ? 1 : 0);
         params[3] = (GLfloat)(ctx->Color.ColorMask[0][ACOMP] ? 1 : 0);
         break;
      case GL_CULL_FACE:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Polygon.CullFlag);
         break;
      case GL_CULL_FACE_MODE:
         params[0] = ENUM_TO_FLOAT(ctx->Polygon.CullFaceMode);
         break;
      case GL_CURRENT_COLOR:
         {
         FLUSH_CURRENT(ctx, 0);
         params[0] = ctx->Current.Attrib[VERT_ATTRIB_COLOR0][0];
         params[1] = ctx->Current.Attrib[VERT_ATTRIB_COLOR0][1];
         params[2] = ctx->Current.Attrib[VERT_ATTRIB_COLOR0][2];
         params[3] = ctx->Current.Attrib[VERT_ATTRIB_COLOR0][3];
         }
         break;
      case GL_CURRENT_INDEX:
         {
         FLUSH_CURRENT(ctx, 0);
         params[0] = ctx->Current.Attrib[VERT_ATTRIB_COLOR_INDEX][0];
         }
         break;
      case GL_CURRENT_NORMAL:
         {
         FLUSH_CURRENT(ctx, 0);
         params[0] = ctx->Current.Attrib[VERT_ATTRIB_NORMAL][0];
         params[1] = ctx->Current.Attrib[VERT_ATTRIB_NORMAL][1];
         params[2] = ctx->Current.Attrib[VERT_ATTRIB_NORMAL][2];
         }
         break;
      case GL_CURRENT_RASTER_COLOR:
         params[0] = ctx->Current.RasterColor[0];
         params[1] = ctx->Current.RasterColor[1];
         params[2] = ctx->Current.RasterColor[2];
         params[3] = ctx->Current.RasterColor[3];
         break;
      case GL_CURRENT_RASTER_DISTANCE:
         params[0] = ctx->Current.RasterDistance;
         break;
      case GL_CURRENT_RASTER_INDEX:
         params[0] = 1.0;
         break;
      case GL_CURRENT_RASTER_POSITION:
         params[0] = ctx->Current.RasterPos[0];
         params[1] = ctx->Current.RasterPos[1];
         params[2] = ctx->Current.RasterPos[2];
         params[3] = ctx->Current.RasterPos[3];
         break;
      case GL_CURRENT_RASTER_SECONDARY_COLOR:
         params[0] = ctx->Current.RasterSecondaryColor[0];
         params[1] = ctx->Current.RasterSecondaryColor[1];
         params[2] = ctx->Current.RasterSecondaryColor[2];
         params[3] = ctx->Current.RasterSecondaryColor[3];
         break;
      case GL_CURRENT_RASTER_TEXTURE_COORDS:
         {
         const GLuint unit = ctx->Texture.CurrentUnit;
         if (unit >= ctx->Const.MaxTextureCoordUnits) {
            _mesa_error(ctx, GL_INVALID_OPERATION,
                        "glGet(raster tex coords, unit %u)", unit);
            return;
         }
         params[0] = ctx->Current.RasterTexCoords[unit][0];
         params[1] = ctx->Current.RasterTexCoords[unit][1];
         params[2] = ctx->Current.RasterTexCoords[unit][2];
         params[3] = ctx->Current.RasterTexCoords[unit][3];
         }
         break;
      case GL_CURRENT_RASTER_POSITION_VALID:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Current.RasterPosValid);
         break;
      case GL_CURRENT_TEXTURE_COORDS:
         {
         const GLuint unit = ctx->Texture.CurrentUnit;
         if (unit >= ctx->Const.MaxTextureCoordUnits) {
            _mesa_error(ctx, GL_INVALID_OPERATION,
                        "glGet(current tex coords, unit %u)", unit);
            return;
         }
         FLUSH_CURRENT(ctx, 0);
         params[0] = ctx->Current.Attrib[VERT_ATTRIB_TEX0 + unit][0];
         params[1] = ctx->Current.Attrib[VERT_ATTRIB_TEX0 + unit][1];
         params[2] = ctx->Current.Attrib[VERT_ATTRIB_TEX0 + unit][2];
         params[3] = ctx->Current.Attrib[VERT_ATTRIB_TEX0 + unit][3];
         }
         break;
      case GL_DEPTH_BIAS:
         params[0] = ctx->Pixel.DepthBias;
         break;
      case GL_DEPTH_BITS:
         params[0] = (GLfloat)(ctx->DrawBuffer->Visual.depthBits);
         break;
      case GL_DEPTH_CLEAR_VALUE:
         params[0] = ((GLfloat) ctx->Depth.Clear);
         break;
      case GL_DEPTH_FUNC:
         params[0] = ENUM_TO_FLOAT(ctx->Depth.Func);
         break;
      case GL_DEPTH_RANGE:
         params[0] = ctx->Viewport.Near;
         params[1] = ctx->Viewport.Far;
         break;
      case GL_DEPTH_SCALE:
         params[0] = ctx->Pixel.DepthScale;
         break;
      case GL_DEPTH_TEST:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Depth.Test);
         break;
      case GL_DEPTH_WRITEMASK:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Depth.Mask);
         break;
      case GL_DITHER:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Color.DitherFlag);
         break;
      case GL_DOUBLEBUFFER:
         params[0] = BOOLEAN_TO_FLOAT(ctx->DrawBuffer->Visual.doubleBufferMode);
         break;
      case GL_DRAW_BUFFER:
         params[0] = ENUM_TO_FLOAT(ctx->DrawBuffer->ColorDrawBuffer[0]);
         break;
      case GL_EDGE_FLAG:
         {
         FLUSH_CURRENT(ctx, 0);
         params[0] = BOOLEAN_TO_FLOAT((ctx->Current.Attrib[VERT_ATTRIB_EDGEFLAG][0] == 1.0));
         }
         break;
      case GL_FEEDBACK_BUFFER_SIZE:
         params[0] = (GLfloat)(ctx->Feedback.BufferSize);
         break;
      case GL_FEEDBACK_BUFFER_TYPE:
         params[0] = ENUM_TO_FLOAT(ctx->Feedback.Type);
         break;
      case GL_FOG:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Fog.Enabled);
         break;
      case GL_FOG_COLOR:
         params[0] = ctx->Fog.Color[0];
         params[1] = ctx->Fog.Color[1];
         params[2] = ctx->Fog.Color[2];
         params[3] = ctx->Fog.Color[3];
         break;
      case GL_FOG_DENSITY:
         params[0] = ctx->Fog.Density;
         break;
      case GL_FOG_END:
         params[0] = ctx->Fog.End;
         break;
      case GL_FOG_HINT:
         params[0] = ENUM_TO_FLOAT(ctx->Hint.Fog);
         break;
      case GL_FOG_INDEX:
         params[0] = ctx->Fog.Index;
         break;
      case GL_FOG_MODE:
         params[0] = ENUM_TO_FLOAT(ctx->Fog.Mode);
         break;
      case GL_FOG_START:
         params[0] = ctx->Fog.Start;
         break;
      case GL_FRONT_FACE:
         params[0] = ENUM_TO_FLOAT(ctx->Polygon.FrontFace);
         break;
      case GL_GREEN_BIAS:
         params[0] = ctx->Pixel.GreenBias;
         break;
      case GL_GREEN_BITS:
         params[0] = (GLfloat)(ctx->DrawBuffer->Visual.greenBits);
         break;
      case GL_GREEN_SCALE:
         params[0] = ctx->Pixel.GreenScale;
         break;
      case GL_INDEX_BITS:
         params[0] = (GLfloat)(ctx->DrawBuffer->Visual.indexBits);
         break;
      case GL_INDEX_CLEAR_VALUE:
         params[0] = (GLfloat)(ctx->Color.ClearIndex);
         break;
      case GL_INDEX_MODE:
         params[0] = BOOLEAN_TO_FLOAT(GL_FALSE);
         break;
      case GL_INDEX_OFFSET:
         params[0] = (GLfloat)(ctx->Pixel.IndexOffset);
         break;
      case GL_INDEX_SHIFT:
         params[0] = (GLfloat)(ctx->Pixel.IndexShift);
         break;
      case GL_INDEX_WRITEMASK:
         params[0] = (GLfloat)(ctx->Color.IndexMask);
         break;
      case GL_LIGHT0:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Light.Light[0].Enabled);
         break;
      case GL_LIGHT1:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Light.Light[1].Enabled);
         break;
      case GL_LIGHT2:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Light.Light[2].Enabled);
         break;
      case GL_LIGHT3:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Light.Light[3].Enabled);
         break;
      case GL_LIGHT4:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Light.Light[4].Enabled);
         break;
      case GL_LIGHT5:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Light.Light[5].Enabled);
         break;
      case GL_LIGHT6:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Light.Light[6].Enabled);
         break;
      case GL_LIGHT7:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Light.Light[7].Enabled);
         break;
      case GL_LIGHTING:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Light.Enabled);
         break;
      case GL_LIGHT_MODEL_AMBIENT:
         params[0] = ctx->Light.Model.Ambient[0];
         params[1] = ctx->Light.Model.Ambient[1];
         params[2] = ctx->Light.Model.Ambient[2];
         params[3] = ctx->Light.Model.Ambient[3];
         break;
      case GL_LIGHT_MODEL_COLOR_CONTROL:
         params[0] = ENUM_TO_FLOAT(ctx->Light.Model.ColorControl);
         break;
      case GL_LIGHT_MODEL_LOCAL_VIEWER:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Light.Model.LocalViewer);
         break;
      case GL_LIGHT_MODEL_TWO_SIDE:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Light.Model.TwoSide);
         break;
      case GL_LINE_SMOOTH:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Line.SmoothFlag);
         break;
      case GL_LINE_SMOOTH_HINT:
         params[0] = ENUM_TO_FLOAT(ctx->Hint.LineSmooth);
         break;
      case GL_LINE_STIPPLE:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Line.StippleFlag);
         break;
      case GL_LINE_STIPPLE_PATTERN:
         params[0] = (GLfloat)(ctx->Line.StipplePattern);
         break;
      case GL_LINE_STIPPLE_REPEAT:
         params[0] = (GLfloat)(ctx->Line.StippleFactor);
         break;
      case GL_LINE_WIDTH:
         params[0] = ctx->Line.Width;
         break;
      case GL_LINE_WIDTH_GRANULARITY:
         params[0] = ctx->Const.LineWidthGranularity;
         break;
      case GL_LINE_WIDTH_RANGE:
         params[0] = ctx->Const.MinLineWidthAA;
         params[1] = ctx->Const.MaxLineWidthAA;
         break;
      case GL_ALIASED_LINE_WIDTH_RANGE:
         params[0] = ctx->Const.MinLineWidth;
         params[1] = ctx->Const.MaxLineWidth;
         break;
      case GL_LIST_BASE:
         params[0] = (GLfloat)(ctx->List.ListBase);
         break;
      case GL_LIST_INDEX:
         params[0] = (GLfloat)((ctx->ListState.CurrentList ? ctx->ListState.CurrentList->Name : 0));
         break;
      case GL_LIST_MODE:
         {
         GLenum mode;
         if (!ctx->CompileFlag)
            mode = 0;
         else if (ctx->ExecuteFlag)
            mode = GL_COMPILE_AND_EXECUTE;
         else
            mode = GL_COMPILE;
         params[0] = ENUM_TO_FLOAT(mode);
         }
         break;
      case GL_INDEX_LOGIC_OP:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Color.IndexLogicOpEnabled);
         break;
      case GL_COLOR_LOGIC_OP:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Color.ColorLogicOpEnabled);
         break;
      case GL_LOGIC_OP_MODE:
         params[0] = ENUM_TO_FLOAT(ctx->Color.LogicOp);
         break;
      case GL_MAP1_COLOR_4:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Eval.Map1Color4);
         break;
      case GL_MAP1_GRID_DOMAIN:
         params[0] = ctx->Eval.MapGrid1u1;
         params[1] = ctx->Eval.MapGrid1u2;
         break;
      case GL_MAP1_GRID_SEGMENTS:
         params[0] = (GLfloat)(ctx->Eval.MapGrid1un);
         break;
      case GL_MAP1_INDEX:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Eval.Map1Index);
         break;
      case GL_MAP1_NORMAL:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Eval.Map1Normal);
         break;
      case GL_MAP1_TEXTURE_COORD_1:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Eval.Map1TextureCoord1);
         break;
      case GL_MAP1_TEXTURE_COORD_2:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Eval.Map1TextureCoord2);
         break;
      case GL_MAP1_TEXTURE_COORD_3:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Eval.Map1TextureCoord3);
         break;
      case GL_MAP1_TEXTURE_COORD_4:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Eval.Map1TextureCoord4);
         break;
      case GL_MAP1_VERTEX_3:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Eval.Map1Vertex3);
         break;
      case GL_MAP1_VERTEX_4:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Eval.Map1Vertex4);
         break;
      case GL_MAP2_COLOR_4:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Eval.Map2Color4);
         break;
      case GL_MAP2_GRID_DOMAIN:
         params[0] = ctx->Eval.MapGrid2u1;
         params[1] = ctx->Eval.MapGrid2u2;
         params[2] = ctx->Eval.MapGrid2v1;
         params[3] = ctx->Eval.MapGrid2v2;
         break;
      case GL_MAP2_GRID_SEGMENTS:
         params[0] = (GLfloat)(ctx->Eval.MapGrid2un);
         params[1] = (GLfloat)(ctx->Eval.MapGrid2vn);
         break;
      case GL_MAP2_INDEX:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Eval.Map2Index);
         break;
      case GL_MAP2_NORMAL:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Eval.Map2Normal);
         break;
      case GL_MAP2_TEXTURE_COORD_1:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Eval.Map2TextureCoord1);
         break;
      case GL_MAP2_TEXTURE_COORD_2:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Eval.Map2TextureCoord2);
         break;
      case GL_MAP2_TEXTURE_COORD_3:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Eval.Map2TextureCoord3);
         break;
      case GL_MAP2_TEXTURE_COORD_4:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Eval.Map2TextureCoord4);
         break;
      case GL_MAP2_VERTEX_3:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Eval.Map2Vertex3);
         break;
      case GL_MAP2_VERTEX_4:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Eval.Map2Vertex4);
         break;
      case GL_MAP_COLOR:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Pixel.MapColorFlag);
         break;
      case GL_MAP_STENCIL:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Pixel.MapStencilFlag);
         break;
      case GL_MATRIX_MODE:
         params[0] = ENUM_TO_FLOAT(ctx->Transform.MatrixMode);
         break;
      case GL_MAX_ATTRIB_STACK_DEPTH:
         params[0] = (GLfloat)(MAX_ATTRIB_STACK_DEPTH);
         break;
      case GL_MAX_CLIENT_ATTRIB_STACK_DEPTH:
         params[0] = (GLfloat)(MAX_CLIENT_ATTRIB_STACK_DEPTH);
         break;
      case GL_MAX_CLIP_PLANES:
         params[0] = (GLfloat)(ctx->Const.MaxClipPlanes);
         break;
      case GL_MAX_ELEMENTS_VERTICES:
         params[0] = (GLfloat)(ctx->Const.MaxArrayLockSize);
         break;
      case GL_MAX_ELEMENTS_INDICES:
         params[0] = (GLfloat)(ctx->Const.MaxArrayLockSize);
         break;
      case GL_MAX_EVAL_ORDER:
         params[0] = (GLfloat)(MAX_EVAL_ORDER);
         break;
      case GL_MAX_LIGHTS:
         params[0] = (GLfloat)(ctx->Const.MaxLights);
         break;
      case GL_MAX_LIST_NESTING:
         params[0] = (GLfloat)(MAX_LIST_NESTING);
         break;
      case GL_MAX_MODELVIEW_STACK_DEPTH:
         params[0] = (GLfloat)(MAX_MODELVIEW_STACK_DEPTH);
         break;
      case GL_MAX_NAME_STACK_DEPTH:
         params[0] = (GLfloat)(MAX_NAME_STACK_DEPTH);
         break;
      case GL_MAX_PIXEL_MAP_TABLE:
         params[0] = (GLfloat)(MAX_PIXEL_MAP_TABLE);
         break;
      case GL_MAX_PROJECTION_STACK_DEPTH:
         params[0] = (GLfloat)(MAX_PROJECTION_STACK_DEPTH);
         break;
      case GL_MAX_TEXTURE_SIZE:
         params[0] = (GLfloat)(1 << (ctx->Const.MaxTextureLevels - 1));
         break;
      case GL_MAX_3D_TEXTURE_SIZE:
         params[0] = (GLfloat)(1 << (ctx->Const.Max3DTextureLevels - 1));
         break;
      case GL_MAX_TEXTURE_STACK_DEPTH:
         params[0] = (GLfloat)(MAX_TEXTURE_STACK_DEPTH);
         break;
      case GL_MAX_VIEWPORT_DIMS:
         params[0] = (GLfloat)(ctx->Const.MaxViewportWidth);
         params[1] = (GLfloat)(ctx->Const.MaxViewportHeight);
         break;
      case GL_MODELVIEW_MATRIX:
         {
         const GLfloat *matrix = ctx->ModelviewMatrixStack.Top->m;
         params[0] = matrix[0];
         params[1] = matrix[1];
         params[2] = matrix[2];
         params[3] = matrix[3];
         params[4] = matrix[4];
         params[5] = matrix[5];
         params[6] = matrix[6];
         params[7] = matrix[7];
         params[8] = matrix[8];
         params[9] = matrix[9];
         params[10] = matrix[10];
         params[11] = matrix[11];
         params[12] = matrix[12];
         params[13] = matrix[13];
         params[14] = matrix[14];
         params[15] = matrix[15];
         }
         break;
      case GL_MODELVIEW_STACK_DEPTH:
         params[0] = (GLfloat)(ctx->ModelviewMatrixStack.Depth + 1);
         break;
      case GL_NAME_STACK_DEPTH:
         params[0] = (GLfloat)(ctx->Select.NameStackDepth);
         break;
      case GL_NORMALIZE:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Transform.Normalize);
         break;
      case GL_PACK_ALIGNMENT:
         params[0] = (GLfloat)(ctx->Pack.Alignment);
         break;
      case GL_PACK_LSB_FIRST:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Pack.LsbFirst);
         break;
      case GL_PACK_ROW_LENGTH:
         params[0] = (GLfloat)(ctx->Pack.RowLength);
         break;
      case GL_PACK_SKIP_PIXELS:
         params[0] = (GLfloat)(ctx->Pack.SkipPixels);
         break;
      case GL_PACK_SKIP_ROWS:
         params[0] = (GLfloat)(ctx->Pack.SkipRows);
         break;
      case GL_PACK_SWAP_BYTES:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Pack.SwapBytes);
         break;
      case GL_PACK_SKIP_IMAGES_EXT:
         params[0] = (GLfloat)(ctx->Pack.SkipImages);
         break;
      case GL_PACK_IMAGE_HEIGHT_EXT:
         params[0] = (GLfloat)(ctx->Pack.ImageHeight);
         break;
      case GL_PACK_INVERT_MESA:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Pack.Invert);
         break;
      case GL_PERSPECTIVE_CORRECTION_HINT:
         params[0] = ENUM_TO_FLOAT(ctx->Hint.PerspectiveCorrection);
         break;
      case GL_PIXEL_MAP_A_TO_A_SIZE:
         params[0] = (GLfloat)(ctx->PixelMaps.AtoA.Size);
         break;
      case GL_PIXEL_MAP_B_TO_B_SIZE:
         params[0] = (GLfloat)(ctx->PixelMaps.BtoB.Size);
         break;
      case GL_PIXEL_MAP_G_TO_G_SIZE:
         params[0] = (GLfloat)(ctx->PixelMaps.GtoG.Size);
         break;
      case GL_PIXEL_MAP_I_TO_A_SIZE:
         params[0] = (GLfloat)(ctx->PixelMaps.ItoA.Size);
         break;
      case GL_PIXEL_MAP_I_TO_B_SIZE:
         params[0] = (GLfloat)(ctx->PixelMaps.ItoB.Size);
         break;
      case GL_PIXEL_MAP_I_TO_G_SIZE:
         params[0] = (GLfloat)(ctx->PixelMaps.ItoG.Size);
         break;
      case GL_PIXEL_MAP_I_TO_I_SIZE:
         params[0] = (GLfloat)(ctx->PixelMaps.ItoI.Size);
         break;
      case GL_PIXEL_MAP_I_TO_R_SIZE:
         params[0] = (GLfloat)(ctx->PixelMaps.ItoR.Size);
         break;
      case GL_PIXEL_MAP_R_TO_R_SIZE:
         params[0] = (GLfloat)(ctx->PixelMaps.RtoR.Size);
         break;
      case GL_PIXEL_MAP_S_TO_S_SIZE:
         params[0] = (GLfloat)(ctx->PixelMaps.StoS.Size);
         break;
      case GL_POINT_SIZE:
         params[0] = ctx->Point.Size;
         break;
      case GL_POINT_SIZE_GRANULARITY:
         params[0] = ctx->Const.PointSizeGranularity;
         break;
      case GL_POINT_SIZE_RANGE:
         params[0] = ctx->Const.MinPointSizeAA;
         params[1] = ctx->Const.MaxPointSizeAA;
         break;
      case GL_ALIASED_POINT_SIZE_RANGE:
         params[0] = ctx->Const.MinPointSize;
         params[1] = ctx->Const.MaxPointSize;
         break;
      case GL_POINT_SMOOTH:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Point.SmoothFlag);
         break;
      case GL_POINT_SMOOTH_HINT:
         params[0] = ENUM_TO_FLOAT(ctx->Hint.PointSmooth);
         break;
      case GL_POINT_SIZE_MIN_EXT:
         params[0] = ctx->Point.MinSize;
         break;
      case GL_POINT_SIZE_MAX_EXT:
         params[0] = ctx->Point.MaxSize;
         break;
      case GL_POINT_FADE_THRESHOLD_SIZE_EXT:
         params[0] = ctx->Point.Threshold;
         break;
      case GL_DISTANCE_ATTENUATION_EXT:
         params[0] = ctx->Point.Params[0];
         params[1] = ctx->Point.Params[1];
         params[2] = ctx->Point.Params[2];
         break;
      case GL_POLYGON_MODE:
         params[0] = ENUM_TO_FLOAT(ctx->Polygon.FrontMode);
         params[1] = ENUM_TO_FLOAT(ctx->Polygon.BackMode);
         break;
      case GL_POLYGON_OFFSET_BIAS_EXT:
         params[0] = ctx->Polygon.OffsetUnits;
         break;
      case GL_POLYGON_OFFSET_FACTOR:
         params[0] = ctx->Polygon.OffsetFactor ;
         break;
      case GL_POLYGON_OFFSET_UNITS:
         params[0] = ctx->Polygon.OffsetUnits ;
         break;
      case GL_POLYGON_OFFSET_POINT:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Polygon.OffsetPoint);
         break;
      case GL_POLYGON_OFFSET_LINE:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Polygon.OffsetLine);
         break;
      case GL_POLYGON_OFFSET_FILL:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Polygon.OffsetFill);
         break;
      case GL_POLYGON_SMOOTH:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Polygon.SmoothFlag);
         break;
      case GL_POLYGON_SMOOTH_HINT:
         params[0] = ENUM_TO_FLOAT(ctx->Hint.PolygonSmooth);
         break;
      case GL_POLYGON_STIPPLE:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Polygon.StippleFlag);
         break;
      case GL_PROJECTION_MATRIX:
         {
         const GLfloat *matrix = ctx->ProjectionMatrixStack.Top->m;
         params[0] = matrix[0];
         params[1] = matrix[1];
         params[2] = matrix[2];
         params[3] = matrix[3];
         params[4] = matrix[4];
         params[5] = matrix[5];
         params[6] = matrix[6];
         params[7] = matrix[7];
         params[8] = matrix[8];
         params[9] = matrix[9];
         params[10] = matrix[10];
         params[11] = matrix[11];
         params[12] = matrix[12];
         params[13] = matrix[13];
         params[14] = matrix[14];
         params[15] = matrix[15];
         }
         break;
      case GL_PROJECTION_STACK_DEPTH:
         params[0] = (GLfloat)(ctx->ProjectionMatrixStack.Depth + 1);
         break;
      case GL_READ_BUFFER:
         params[0] = ENUM_TO_FLOAT(ctx->ReadBuffer->ColorReadBuffer);
         break;
      case GL_RED_BIAS:
         params[0] = ctx->Pixel.RedBias;
         break;
      case GL_RED_BITS:
         params[0] = (GLfloat)(ctx->DrawBuffer->Visual.redBits);
         break;
      case GL_RED_SCALE:
         params[0] = ctx->Pixel.RedScale;
         break;
      case GL_RENDER_MODE:
         params[0] = ENUM_TO_FLOAT(ctx->RenderMode);
         break;
      case GL_RESCALE_NORMAL:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Transform.RescaleNormals);
         break;
      case GL_RGBA_MODE:
         params[0] = BOOLEAN_TO_FLOAT(GL_TRUE);
         break;
      case GL_SCISSOR_BOX:
         params[0] = (GLfloat)(ctx->Scissor.X);
         params[1] = (GLfloat)(ctx->Scissor.Y);
         params[2] = (GLfloat)(ctx->Scissor.Width);
         params[3] = (GLfloat)(ctx->Scissor.Height);
         break;
      case GL_SCISSOR_TEST:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Scissor.Enabled);
         break;
      case GL_SELECTION_BUFFER_SIZE:
         params[0] = (GLfloat)(ctx->Select.BufferSize);
         break;
      case GL_SHADE_MODEL:
         params[0] = ENUM_TO_FLOAT(ctx->Light.ShadeModel);
         break;
      case GL_SHARED_TEXTURE_PALETTE_EXT:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Texture.SharedPalette);
         break;
      case GL_STENCIL_BITS:
         params[0] = (GLfloat)(ctx->DrawBuffer->Visual.stencilBits);
         break;
      case GL_STENCIL_CLEAR_VALUE:
         params[0] = (GLfloat)(ctx->Stencil.Clear);
         break;
      case GL_STENCIL_FAIL:
         params[0] = ENUM_TO_FLOAT(ctx->Stencil.FailFunc[ctx->Stencil.ActiveFace]);
         break;
      case GL_STENCIL_FUNC:
         params[0] = ENUM_TO_FLOAT(ctx->Stencil.Function[ctx->Stencil.ActiveFace]);
         break;
      case GL_STENCIL_PASS_DEPTH_FAIL:
         params[0] = ENUM_TO_FLOAT(ctx->Stencil.ZFailFunc[ctx->Stencil.ActiveFace]);
         break;
      case GL_STENCIL_PASS_DEPTH_PASS:
         params[0] = ENUM_TO_FLOAT(ctx->Stencil.ZPassFunc[ctx->Stencil.ActiveFace]);
         break;
      case GL_STENCIL_REF:
         params[0] = (GLfloat)(ctx->Stencil.Ref[ctx->Stencil.ActiveFace]);
         break;
      case GL_STENCIL_TEST:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Stencil.Enabled);
         break;
      case GL_STENCIL_VALUE_MASK:
         params[0] = (GLfloat)(ctx->Stencil.ValueMask[ctx->Stencil.ActiveFace]);
         break;
      case GL_STENCIL_WRITEMASK:
         params[0] = (GLfloat)(ctx->Stencil.WriteMask[ctx->Stencil.ActiveFace]);
         break;
      case GL_STEREO:
         params[0] = BOOLEAN_TO_FLOAT(ctx->DrawBuffer->Visual.stereoMode);
         break;
      case GL_SUBPIXEL_BITS:
         params[0] = (GLfloat)(ctx->Const.SubPixelBits);
         break;
      case GL_TEXTURE_1D:
         params[0] = BOOLEAN_TO_FLOAT(_mesa_IsEnabled(GL_TEXTURE_1D));
         break;
      case GL_TEXTURE_2D:
         params[0] = BOOLEAN_TO_FLOAT(_mesa_IsEnabled(GL_TEXTURE_2D));
         break;
      case GL_TEXTURE_3D:
         params[0] = BOOLEAN_TO_FLOAT(_mesa_IsEnabled(GL_TEXTURE_3D));
         break;
      case GL_TEXTURE_1D_ARRAY_EXT:
         CHECK_EXT1(MESA_texture_array, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(_mesa_IsEnabled(GL_TEXTURE_1D_ARRAY_EXT));
         break;
      case GL_TEXTURE_2D_ARRAY_EXT:
         CHECK_EXT1(MESA_texture_array, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(_mesa_IsEnabled(GL_TEXTURE_2D_ARRAY_EXT));
         break;
      case GL_TEXTURE_BINDING_1D:
         params[0] = (GLfloat)(ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentTex[TEXTURE_1D_INDEX]->Name);
         break;
      case GL_TEXTURE_BINDING_2D:
         params[0] = (GLfloat)(ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentTex[TEXTURE_2D_INDEX]->Name);
         break;
      case GL_TEXTURE_BINDING_3D:
         params[0] = (GLfloat)(ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentTex[TEXTURE_3D_INDEX]->Name);
         break;
      case GL_TEXTURE_BINDING_1D_ARRAY_EXT:
         CHECK_EXT1(MESA_texture_array, "GetFloatv");
         params[0] = (GLfloat)(ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentTex[TEXTURE_1D_ARRAY_INDEX]->Name);
         break;
      case GL_TEXTURE_BINDING_2D_ARRAY_EXT:
         CHECK_EXT1(MESA_texture_array, "GetFloatv");
         params[0] = (GLfloat)(ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentTex[TEXTURE_2D_ARRAY_INDEX]->Name);
         break;
      case GL_TEXTURE_GEN_S:
         params[0] = BOOLEAN_TO_FLOAT(((ctx->Texture.Unit[ctx->Texture.CurrentUnit].TexGenEnabled & S_BIT) ? 1 : 0));
         break;
      case GL_TEXTURE_GEN_T:
         params[0] = BOOLEAN_TO_FLOAT(((ctx->Texture.Unit[ctx->Texture.CurrentUnit].TexGenEnabled & T_BIT) ? 1 : 0));
         break;
      case GL_TEXTURE_GEN_R:
         params[0] = BOOLEAN_TO_FLOAT(((ctx->Texture.Unit[ctx->Texture.CurrentUnit].TexGenEnabled & R_BIT) ? 1 : 0));
         break;
      case GL_TEXTURE_GEN_Q:
         params[0] = BOOLEAN_TO_FLOAT(((ctx->Texture.Unit[ctx->Texture.CurrentUnit].TexGenEnabled & Q_BIT) ? 1 : 0));
         break;
      case GL_TEXTURE_MATRIX:
         {
         const GLfloat *matrix;
         const GLuint unit = ctx->Texture.CurrentUnit;
         if (unit >= ctx->Const.MaxTextureCoordUnits) {
            _mesa_error(ctx, GL_INVALID_OPERATION, "glGet(texture matrix %u)",
                        unit);
            return;
         }
         matrix = ctx->TextureMatrixStack[unit].Top->m;
         params[0] = matrix[0];
         params[1] = matrix[1];
         params[2] = matrix[2];
         params[3] = matrix[3];
         params[4] = matrix[4];
         params[5] = matrix[5];
         params[6] = matrix[6];
         params[7] = matrix[7];
         params[8] = matrix[8];
         params[9] = matrix[9];
         params[10] = matrix[10];
         params[11] = matrix[11];
         params[12] = matrix[12];
         params[13] = matrix[13];
         params[14] = matrix[14];
         params[15] = matrix[15];
         }
         break;
      case GL_TEXTURE_STACK_DEPTH:
         {
         const GLuint unit = ctx->Texture.CurrentUnit;
         if (unit >= ctx->Const.MaxTextureCoordUnits) {
            _mesa_error(ctx, GL_INVALID_OPERATION,
                        "glGet(texture stack depth, unit %u)", unit);
            return;
         }
         params[0] = (GLfloat)(ctx->TextureMatrixStack[unit].Depth + 1);
         }
         break;
      case GL_UNPACK_ALIGNMENT:
         params[0] = (GLfloat)(ctx->Unpack.Alignment);
         break;
      case GL_UNPACK_LSB_FIRST:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Unpack.LsbFirst);
         break;
      case GL_UNPACK_ROW_LENGTH:
         params[0] = (GLfloat)(ctx->Unpack.RowLength);
         break;
      case GL_UNPACK_SKIP_PIXELS:
         params[0] = (GLfloat)(ctx->Unpack.SkipPixels);
         break;
      case GL_UNPACK_SKIP_ROWS:
         params[0] = (GLfloat)(ctx->Unpack.SkipRows);
         break;
      case GL_UNPACK_SWAP_BYTES:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Unpack.SwapBytes);
         break;
      case GL_UNPACK_SKIP_IMAGES_EXT:
         params[0] = (GLfloat)(ctx->Unpack.SkipImages);
         break;
      case GL_UNPACK_IMAGE_HEIGHT_EXT:
         params[0] = (GLfloat)(ctx->Unpack.ImageHeight);
         break;
      case GL_UNPACK_CLIENT_STORAGE_APPLE:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Unpack.ClientStorage);
         break;
      case GL_VIEWPORT:
         params[0] = (GLfloat)(ctx->Viewport.X);
         params[1] = (GLfloat)(ctx->Viewport.Y);
         params[2] = (GLfloat)(ctx->Viewport.Width);
         params[3] = (GLfloat)(ctx->Viewport.Height);
         break;
      case GL_ZOOM_X:
         params[0] = ctx->Pixel.ZoomX;
         break;
      case GL_ZOOM_Y:
         params[0] = ctx->Pixel.ZoomY;
         break;
      case GL_VERTEX_ARRAY:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Array.ArrayObj->Vertex.Enabled);
         break;
      case GL_VERTEX_ARRAY_SIZE:
         params[0] = (GLfloat)(ctx->Array.ArrayObj->Vertex.Size);
         break;
      case GL_VERTEX_ARRAY_TYPE:
         params[0] = ENUM_TO_FLOAT(ctx->Array.ArrayObj->Vertex.Type);
         break;
      case GL_VERTEX_ARRAY_STRIDE:
         params[0] = (GLfloat)(ctx->Array.ArrayObj->Vertex.Stride);
         break;
      case GL_VERTEX_ARRAY_COUNT_EXT:
         params[0] = (GLfloat)(0);
         break;
      case GL_NORMAL_ARRAY:
         params[0] = ENUM_TO_FLOAT(ctx->Array.ArrayObj->Normal.Enabled);
         break;
      case GL_NORMAL_ARRAY_TYPE:
         params[0] = ENUM_TO_FLOAT(ctx->Array.ArrayObj->Normal.Type);
         break;
      case GL_NORMAL_ARRAY_STRIDE:
         params[0] = (GLfloat)(ctx->Array.ArrayObj->Normal.Stride);
         break;
      case GL_NORMAL_ARRAY_COUNT_EXT:
         params[0] = (GLfloat)(0);
         break;
      case GL_COLOR_ARRAY:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Array.ArrayObj->Color.Enabled);
         break;
      case GL_COLOR_ARRAY_SIZE:
         params[0] = (GLfloat)(ctx->Array.ArrayObj->Color.Size);
         break;
      case GL_COLOR_ARRAY_TYPE:
         params[0] = ENUM_TO_FLOAT(ctx->Array.ArrayObj->Color.Type);
         break;
      case GL_COLOR_ARRAY_STRIDE:
         params[0] = (GLfloat)(ctx->Array.ArrayObj->Color.Stride);
         break;
      case GL_COLOR_ARRAY_COUNT_EXT:
         params[0] = (GLfloat)(0);
         break;
      case GL_INDEX_ARRAY:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Array.ArrayObj->Index.Enabled);
         break;
      case GL_INDEX_ARRAY_TYPE:
         params[0] = ENUM_TO_FLOAT(ctx->Array.ArrayObj->Index.Type);
         break;
      case GL_INDEX_ARRAY_STRIDE:
         params[0] = (GLfloat)(ctx->Array.ArrayObj->Index.Stride);
         break;
      case GL_INDEX_ARRAY_COUNT_EXT:
         params[0] = (GLfloat)(0);
         break;
      case GL_TEXTURE_COORD_ARRAY:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Array.ArrayObj->TexCoord[ctx->Array.ActiveTexture].Enabled);
         break;
      case GL_TEXTURE_COORD_ARRAY_SIZE:
         params[0] = (GLfloat)(ctx->Array.ArrayObj->TexCoord[ctx->Array.ActiveTexture].Size);
         break;
      case GL_TEXTURE_COORD_ARRAY_TYPE:
         params[0] = ENUM_TO_FLOAT(ctx->Array.ArrayObj->TexCoord[ctx->Array.ActiveTexture].Type);
         break;
      case GL_TEXTURE_COORD_ARRAY_STRIDE:
         params[0] = (GLfloat)(ctx->Array.ArrayObj->TexCoord[ctx->Array.ActiveTexture].Stride);
         break;
      case GL_TEXTURE_COORD_ARRAY_COUNT_EXT:
         params[0] = (GLfloat)(0);
         break;
      case GL_EDGE_FLAG_ARRAY:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Array.ArrayObj->EdgeFlag.Enabled);
         break;
      case GL_EDGE_FLAG_ARRAY_STRIDE:
         params[0] = (GLfloat)(ctx->Array.ArrayObj->EdgeFlag.Stride);
         break;
      case GL_EDGE_FLAG_ARRAY_COUNT_EXT:
         params[0] = (GLfloat)(0);
         break;
      case GL_MAX_TEXTURE_UNITS_ARB:
         CHECK_EXT1(ARB_multitexture, "GetFloatv");
         params[0] = (GLfloat)(ctx->Const.MaxTextureUnits);
         break;
      case GL_ACTIVE_TEXTURE_ARB:
         CHECK_EXT1(ARB_multitexture, "GetFloatv");
         params[0] = (GLfloat)(GL_TEXTURE0_ARB + ctx->Texture.CurrentUnit);
         break;
      case GL_CLIENT_ACTIVE_TEXTURE_ARB:
         CHECK_EXT1(ARB_multitexture, "GetFloatv");
         params[0] = (GLfloat)(GL_TEXTURE0_ARB + ctx->Array.ActiveTexture);
         break;
      case GL_TEXTURE_CUBE_MAP_ARB:
         CHECK_EXT1(ARB_texture_cube_map, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(_mesa_IsEnabled(GL_TEXTURE_CUBE_MAP_ARB));
         break;
      case GL_TEXTURE_BINDING_CUBE_MAP_ARB:
         CHECK_EXT1(ARB_texture_cube_map, "GetFloatv");
         params[0] = (GLfloat)(ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentTex[TEXTURE_CUBE_INDEX]->Name);
         break;
      case GL_MAX_CUBE_MAP_TEXTURE_SIZE_ARB:
         CHECK_EXT1(ARB_texture_cube_map, "GetFloatv");
         params[0] = (GLfloat)((1 << (ctx->Const.MaxCubeTextureLevels - 1)));
         break;
      case GL_TEXTURE_COMPRESSION_HINT_ARB:
         params[0] = (GLfloat)(ctx->Hint.TextureCompression);
         break;
      case GL_NUM_COMPRESSED_TEXTURE_FORMATS_ARB:
         params[0] = (GLfloat)(_mesa_get_compressed_formats(ctx, NULL, GL_FALSE));
         break;
      case GL_COMPRESSED_TEXTURE_FORMATS_ARB:
         {
         GLint formats[100];
         GLuint i, n = _mesa_get_compressed_formats(ctx, formats, GL_FALSE);
         ASSERT(n <= 100);
         for (i = 0; i < n; i++)
            params[i] = ENUM_TO_FLOAT(formats[i]);
         }
         break;
      case GL_ARRAY_ELEMENT_LOCK_FIRST_EXT:
         CHECK_EXT1(EXT_compiled_vertex_array, "GetFloatv");
         params[0] = (GLfloat)(ctx->Array.LockFirst);
         break;
      case GL_ARRAY_ELEMENT_LOCK_COUNT_EXT:
         CHECK_EXT1(EXT_compiled_vertex_array, "GetFloatv");
         params[0] = (GLfloat)(ctx->Array.LockCount);
         break;
      case GL_TRANSPOSE_COLOR_MATRIX_ARB:
         {
         const GLfloat *matrix = ctx->ColorMatrixStack.Top->m;
         params[0] = matrix[0];
         params[1] = matrix[4];
         params[2] = matrix[8];
         params[3] = matrix[12];
         params[4] = matrix[1];
         params[5] = matrix[5];
         params[6] = matrix[9];
         params[7] = matrix[13];
         params[8] = matrix[2];
         params[9] = matrix[6];
         params[10] = matrix[10];
         params[11] = matrix[14];
         params[12] = matrix[3];
         params[13] = matrix[7];
         params[14] = matrix[11];
         params[15] = matrix[15];
         }
         break;
      case GL_TRANSPOSE_MODELVIEW_MATRIX_ARB:
         {
         const GLfloat *matrix = ctx->ModelviewMatrixStack.Top->m;
         params[0] = matrix[0];
         params[1] = matrix[4];
         params[2] = matrix[8];
         params[3] = matrix[12];
         params[4] = matrix[1];
         params[5] = matrix[5];
         params[6] = matrix[9];
         params[7] = matrix[13];
         params[8] = matrix[2];
         params[9] = matrix[6];
         params[10] = matrix[10];
         params[11] = matrix[14];
         params[12] = matrix[3];
         params[13] = matrix[7];
         params[14] = matrix[11];
         params[15] = matrix[15];
         }
         break;
      case GL_TRANSPOSE_PROJECTION_MATRIX_ARB:
         {
         const GLfloat *matrix = ctx->ProjectionMatrixStack.Top->m;
         params[0] = matrix[0];
         params[1] = matrix[4];
         params[2] = matrix[8];
         params[3] = matrix[12];
         params[4] = matrix[1];
         params[5] = matrix[5];
         params[6] = matrix[9];
         params[7] = matrix[13];
         params[8] = matrix[2];
         params[9] = matrix[6];
         params[10] = matrix[10];
         params[11] = matrix[14];
         params[12] = matrix[3];
         params[13] = matrix[7];
         params[14] = matrix[11];
         params[15] = matrix[15];
         }
         break;
      case GL_TRANSPOSE_TEXTURE_MATRIX_ARB:
         {
         const GLfloat *matrix = ctx->TextureMatrixStack[ctx->Texture.CurrentUnit].Top->m;
         params[0] = matrix[0];
         params[1] = matrix[4];
         params[2] = matrix[8];
         params[3] = matrix[12];
         params[4] = matrix[1];
         params[5] = matrix[5];
         params[6] = matrix[9];
         params[7] = matrix[13];
         params[8] = matrix[2];
         params[9] = matrix[6];
         params[10] = matrix[10];
         params[11] = matrix[14];
         params[12] = matrix[3];
         params[13] = matrix[7];
         params[14] = matrix[11];
         params[15] = matrix[15];
         }
         break;
      case GL_COLOR_MATRIX_SGI:
         {
         const GLfloat *matrix = ctx->ColorMatrixStack.Top->m;
         params[0] = matrix[0];
         params[1] = matrix[1];
         params[2] = matrix[2];
         params[3] = matrix[3];
         params[4] = matrix[4];
         params[5] = matrix[5];
         params[6] = matrix[6];
         params[7] = matrix[7];
         params[8] = matrix[8];
         params[9] = matrix[9];
         params[10] = matrix[10];
         params[11] = matrix[11];
         params[12] = matrix[12];
         params[13] = matrix[13];
         params[14] = matrix[14];
         params[15] = matrix[15];
         }
         break;
      case GL_COLOR_MATRIX_STACK_DEPTH_SGI:
         params[0] = (GLfloat)(ctx->ColorMatrixStack.Depth + 1);
         break;
      case GL_MAX_COLOR_MATRIX_STACK_DEPTH_SGI:
         params[0] = (GLfloat)(MAX_COLOR_STACK_DEPTH);
         break;
      case GL_POST_COLOR_MATRIX_RED_SCALE_SGI:
         params[0] = ctx->Pixel.PostColorMatrixScale[0];
         break;
      case GL_POST_COLOR_MATRIX_GREEN_SCALE_SGI:
         params[0] = ctx->Pixel.PostColorMatrixScale[1];
         break;
      case GL_POST_COLOR_MATRIX_BLUE_SCALE_SGI:
         params[0] = ctx->Pixel.PostColorMatrixScale[2];
         break;
      case GL_POST_COLOR_MATRIX_ALPHA_SCALE_SGI:
         params[0] = ctx->Pixel.PostColorMatrixScale[3];
         break;
      case GL_POST_COLOR_MATRIX_RED_BIAS_SGI:
         params[0] = ctx->Pixel.PostColorMatrixBias[0];
         break;
      case GL_POST_COLOR_MATRIX_GREEN_BIAS_SGI:
         params[0] = ctx->Pixel.PostColorMatrixBias[1];
         break;
      case GL_POST_COLOR_MATRIX_BLUE_BIAS_SGI:
         params[0] = ctx->Pixel.PostColorMatrixBias[2];
         break;
      case GL_POST_COLOR_MATRIX_ALPHA_BIAS_SGI:
         params[0] = ctx->Pixel.PostColorMatrixBias[3];
         break;
      case GL_CONVOLUTION_1D_EXT:
         CHECK_EXT1(EXT_convolution, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->Pixel.Convolution1DEnabled);
         break;
      case GL_CONVOLUTION_2D_EXT:
         CHECK_EXT1(EXT_convolution, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->Pixel.Convolution2DEnabled);
         break;
      case GL_SEPARABLE_2D_EXT:
         CHECK_EXT1(EXT_convolution, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->Pixel.Separable2DEnabled);
         break;
      case GL_POST_CONVOLUTION_RED_SCALE_EXT:
         CHECK_EXT1(EXT_convolution, "GetFloatv");
         params[0] = ctx->Pixel.PostConvolutionScale[0];
         break;
      case GL_POST_CONVOLUTION_GREEN_SCALE_EXT:
         CHECK_EXT1(EXT_convolution, "GetFloatv");
         params[0] = ctx->Pixel.PostConvolutionScale[1];
         break;
      case GL_POST_CONVOLUTION_BLUE_SCALE_EXT:
         CHECK_EXT1(EXT_convolution, "GetFloatv");
         params[0] = ctx->Pixel.PostConvolutionScale[2];
         break;
      case GL_POST_CONVOLUTION_ALPHA_SCALE_EXT:
         CHECK_EXT1(EXT_convolution, "GetFloatv");
         params[0] = ctx->Pixel.PostConvolutionScale[3];
         break;
      case GL_POST_CONVOLUTION_RED_BIAS_EXT:
         CHECK_EXT1(EXT_convolution, "GetFloatv");
         params[0] = ctx->Pixel.PostConvolutionBias[0];
         break;
      case GL_POST_CONVOLUTION_GREEN_BIAS_EXT:
         CHECK_EXT1(EXT_convolution, "GetFloatv");
         params[0] = ctx->Pixel.PostConvolutionBias[1];
         break;
      case GL_POST_CONVOLUTION_BLUE_BIAS_EXT:
         CHECK_EXT1(EXT_convolution, "GetFloatv");
         params[0] = ctx->Pixel.PostConvolutionBias[2];
         break;
      case GL_POST_CONVOLUTION_ALPHA_BIAS_EXT:
         CHECK_EXT1(EXT_convolution, "GetFloatv");
         params[0] = ctx->Pixel.PostConvolutionBias[3];
         break;
      case GL_HISTOGRAM:
         CHECK_EXT1(EXT_histogram, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->Pixel.HistogramEnabled);
         break;
      case GL_MINMAX:
         CHECK_EXT1(EXT_histogram, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->Pixel.MinMaxEnabled);
         break;
      case GL_COLOR_TABLE_SGI:
         CHECK_EXT1(SGI_color_table, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->Pixel.ColorTableEnabled[COLORTABLE_PRECONVOLUTION]);
         break;
      case GL_POST_CONVOLUTION_COLOR_TABLE_SGI:
         CHECK_EXT1(SGI_color_table, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->Pixel.ColorTableEnabled[COLORTABLE_POSTCONVOLUTION]);
         break;
      case GL_POST_COLOR_MATRIX_COLOR_TABLE_SGI:
         CHECK_EXT1(SGI_color_table, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->Pixel.ColorTableEnabled[COLORTABLE_POSTCOLORMATRIX]);
         break;
      case GL_TEXTURE_COLOR_TABLE_SGI:
         CHECK_EXT1(SGI_texture_color_table, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->Texture.Unit[ctx->Texture.CurrentUnit].ColorTableEnabled);
         break;
      case GL_COLOR_SUM_EXT:
         CHECK_EXT2(EXT_secondary_color, ARB_vertex_program, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->Fog.ColorSumEnabled);
         break;
      case GL_CURRENT_SECONDARY_COLOR_EXT:
         CHECK_EXT1(EXT_secondary_color, "GetFloatv");
         {
         FLUSH_CURRENT(ctx, 0);
         params[0] = ctx->Current.Attrib[VERT_ATTRIB_COLOR1][0];
         params[1] = ctx->Current.Attrib[VERT_ATTRIB_COLOR1][1];
         params[2] = ctx->Current.Attrib[VERT_ATTRIB_COLOR1][2];
         params[3] = ctx->Current.Attrib[VERT_ATTRIB_COLOR1][3];
         }
         break;
      case GL_SECONDARY_COLOR_ARRAY_EXT:
         CHECK_EXT1(EXT_secondary_color, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->Array.ArrayObj->SecondaryColor.Enabled);
         break;
      case GL_SECONDARY_COLOR_ARRAY_TYPE_EXT:
         CHECK_EXT1(EXT_secondary_color, "GetFloatv");
         params[0] = ENUM_TO_FLOAT(ctx->Array.ArrayObj->SecondaryColor.Type);
         break;
      case GL_SECONDARY_COLOR_ARRAY_STRIDE_EXT:
         CHECK_EXT1(EXT_secondary_color, "GetFloatv");
         params[0] = (GLfloat)(ctx->Array.ArrayObj->SecondaryColor.Stride);
         break;
      case GL_SECONDARY_COLOR_ARRAY_SIZE_EXT:
         CHECK_EXT1(EXT_secondary_color, "GetFloatv");
         params[0] = (GLfloat)(ctx->Array.ArrayObj->SecondaryColor.Size);
         break;
      case GL_CURRENT_FOG_COORDINATE_EXT:
         CHECK_EXT1(EXT_fog_coord, "GetFloatv");
         {
         FLUSH_CURRENT(ctx, 0);
         params[0] = ctx->Current.Attrib[VERT_ATTRIB_FOG][0];
         }
         break;
      case GL_FOG_COORDINATE_ARRAY_EXT:
         CHECK_EXT1(EXT_fog_coord, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->Array.ArrayObj->FogCoord.Enabled);
         break;
      case GL_FOG_COORDINATE_ARRAY_TYPE_EXT:
         CHECK_EXT1(EXT_fog_coord, "GetFloatv");
         params[0] = ENUM_TO_FLOAT(ctx->Array.ArrayObj->FogCoord.Type);
         break;
      case GL_FOG_COORDINATE_ARRAY_STRIDE_EXT:
         CHECK_EXT1(EXT_fog_coord, "GetFloatv");
         params[0] = (GLfloat)(ctx->Array.ArrayObj->FogCoord.Stride);
         break;
      case GL_FOG_COORDINATE_SOURCE_EXT:
         CHECK_EXT1(EXT_fog_coord, "GetFloatv");
         params[0] = ENUM_TO_FLOAT(ctx->Fog.FogCoordinateSource);
         break;
      case GL_MAX_TEXTURE_LOD_BIAS_EXT:
         CHECK_EXT1(EXT_texture_lod_bias, "GetFloatv");
         params[0] = ctx->Const.MaxTextureLodBias;
         break;
      case GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT:
         CHECK_EXT1(EXT_texture_filter_anisotropic, "GetFloatv");
         params[0] = ctx->Const.MaxTextureMaxAnisotropy;
         break;
      case GL_MULTISAMPLE_ARB:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Multisample.Enabled);
         break;
      case GL_SAMPLE_ALPHA_TO_COVERAGE_ARB:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Multisample.SampleAlphaToCoverage);
         break;
      case GL_SAMPLE_ALPHA_TO_ONE_ARB:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Multisample.SampleAlphaToOne);
         break;
      case GL_SAMPLE_COVERAGE_ARB:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Multisample.SampleCoverage);
         break;
      case GL_SAMPLE_COVERAGE_VALUE_ARB:
         params[0] = ctx->Multisample.SampleCoverageValue;
         break;
      case GL_SAMPLE_COVERAGE_INVERT_ARB:
         params[0] = BOOLEAN_TO_FLOAT(ctx->Multisample.SampleCoverageInvert);
         break;
      case GL_SAMPLE_BUFFERS_ARB:
         params[0] = (GLfloat)(ctx->DrawBuffer->Visual.sampleBuffers);
         break;
      case GL_SAMPLES_ARB:
         params[0] = (GLfloat)(ctx->DrawBuffer->Visual.samples);
         break;
      case GL_RASTER_POSITION_UNCLIPPED_IBM:
         CHECK_EXT1(IBM_rasterpos_clip, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->Transform.RasterPositionUnclipped);
         break;
      case GL_POINT_SPRITE_NV:
         CHECK_EXT2(NV_point_sprite, ARB_point_sprite, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->Point.PointSprite);
         break;
      case GL_POINT_SPRITE_R_MODE_NV:
         CHECK_EXT1(NV_point_sprite, "GetFloatv");
         params[0] = ENUM_TO_FLOAT(ctx->Point.SpriteRMode);
         break;
      case GL_POINT_SPRITE_COORD_ORIGIN:
         CHECK_EXT2(NV_point_sprite, ARB_point_sprite, "GetFloatv");
         params[0] = ENUM_TO_FLOAT(ctx->Point.SpriteOrigin);
         break;
      case GL_GENERATE_MIPMAP_HINT_SGIS:
         CHECK_EXT1(SGIS_generate_mipmap, "GetFloatv");
         params[0] = ENUM_TO_FLOAT(ctx->Hint.GenerateMipmap);
         break;
      case GL_VERTEX_PROGRAM_BINDING_NV:
         CHECK_EXT1(NV_vertex_program, "GetFloatv");
         params[0] = (GLfloat)((ctx->VertexProgram.Current ? ctx->VertexProgram.Current->Base.Id : 0));
         break;
      case GL_VERTEX_ATTRIB_ARRAY0_NV:
         CHECK_EXT1(NV_vertex_program, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->Array.ArrayObj->VertexAttrib[0].Enabled);
         break;
      case GL_VERTEX_ATTRIB_ARRAY1_NV:
         CHECK_EXT1(NV_vertex_program, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->Array.ArrayObj->VertexAttrib[1].Enabled);
         break;
      case GL_VERTEX_ATTRIB_ARRAY2_NV:
         CHECK_EXT1(NV_vertex_program, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->Array.ArrayObj->VertexAttrib[2].Enabled);
         break;
      case GL_VERTEX_ATTRIB_ARRAY3_NV:
         CHECK_EXT1(NV_vertex_program, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->Array.ArrayObj->VertexAttrib[3].Enabled);
         break;
      case GL_VERTEX_ATTRIB_ARRAY4_NV:
         CHECK_EXT1(NV_vertex_program, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->Array.ArrayObj->VertexAttrib[4].Enabled);
         break;
      case GL_VERTEX_ATTRIB_ARRAY5_NV:
         CHECK_EXT1(NV_vertex_program, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->Array.ArrayObj->VertexAttrib[5].Enabled);
         break;
      case GL_VERTEX_ATTRIB_ARRAY6_NV:
         CHECK_EXT1(NV_vertex_program, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->Array.ArrayObj->VertexAttrib[6].Enabled);
         break;
      case GL_VERTEX_ATTRIB_ARRAY7_NV:
         CHECK_EXT1(NV_vertex_program, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->Array.ArrayObj->VertexAttrib[7].Enabled);
         break;
      case GL_VERTEX_ATTRIB_ARRAY8_NV:
         CHECK_EXT1(NV_vertex_program, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->Array.ArrayObj->VertexAttrib[8].Enabled);
         break;
      case GL_VERTEX_ATTRIB_ARRAY9_NV:
         CHECK_EXT1(NV_vertex_program, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->Array.ArrayObj->VertexAttrib[9].Enabled);
         break;
      case GL_VERTEX_ATTRIB_ARRAY10_NV:
         CHECK_EXT1(NV_vertex_program, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->Array.ArrayObj->VertexAttrib[10].Enabled);
         break;
      case GL_VERTEX_ATTRIB_ARRAY11_NV:
         CHECK_EXT1(NV_vertex_program, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->Array.ArrayObj->VertexAttrib[11].Enabled);
         break;
      case GL_VERTEX_ATTRIB_ARRAY12_NV:
         CHECK_EXT1(NV_vertex_program, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->Array.ArrayObj->VertexAttrib[12].Enabled);
         break;
      case GL_VERTEX_ATTRIB_ARRAY13_NV:
         CHECK_EXT1(NV_vertex_program, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->Array.ArrayObj->VertexAttrib[13].Enabled);
         break;
      case GL_VERTEX_ATTRIB_ARRAY14_NV:
         CHECK_EXT1(NV_vertex_program, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->Array.ArrayObj->VertexAttrib[14].Enabled);
         break;
      case GL_VERTEX_ATTRIB_ARRAY15_NV:
         CHECK_EXT1(NV_vertex_program, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->Array.ArrayObj->VertexAttrib[15].Enabled);
         break;
      case GL_MAP1_VERTEX_ATTRIB0_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->Eval.Map1Attrib[0]);
         break;
      case GL_MAP1_VERTEX_ATTRIB1_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->Eval.Map1Attrib[1]);
         break;
      case GL_MAP1_VERTEX_ATTRIB2_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->Eval.Map1Attrib[2]);
         break;
      case GL_MAP1_VERTEX_ATTRIB3_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->Eval.Map1Attrib[3]);
         break;
      case GL_MAP1_VERTEX_ATTRIB4_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->Eval.Map1Attrib[4]);
         break;
      case GL_MAP1_VERTEX_ATTRIB5_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->Eval.Map1Attrib[5]);
         break;
      case GL_MAP1_VERTEX_ATTRIB6_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->Eval.Map1Attrib[6]);
         break;
      case GL_MAP1_VERTEX_ATTRIB7_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->Eval.Map1Attrib[7]);
         break;
      case GL_MAP1_VERTEX_ATTRIB8_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->Eval.Map1Attrib[8]);
         break;
      case GL_MAP1_VERTEX_ATTRIB9_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->Eval.Map1Attrib[9]);
         break;
      case GL_MAP1_VERTEX_ATTRIB10_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->Eval.Map1Attrib[10]);
         break;
      case GL_MAP1_VERTEX_ATTRIB11_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->Eval.Map1Attrib[11]);
         break;
      case GL_MAP1_VERTEX_ATTRIB12_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->Eval.Map1Attrib[12]);
         break;
      case GL_MAP1_VERTEX_ATTRIB13_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->Eval.Map1Attrib[13]);
         break;
      case GL_MAP1_VERTEX_ATTRIB14_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->Eval.Map1Attrib[14]);
         break;
      case GL_MAP1_VERTEX_ATTRIB15_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->Eval.Map1Attrib[15]);
         break;
      case GL_FRAGMENT_PROGRAM_NV:
         CHECK_EXT1(NV_fragment_program, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->FragmentProgram.Enabled);
         break;
      case GL_FRAGMENT_PROGRAM_BINDING_NV:
         CHECK_EXT1(NV_fragment_program, "GetFloatv");
         params[0] = (GLfloat)(ctx->FragmentProgram.Current ? ctx->FragmentProgram.Current->Base.Id : 0);
         break;
      case GL_MAX_FRAGMENT_PROGRAM_LOCAL_PARAMETERS_NV:
         CHECK_EXT1(NV_fragment_program, "GetFloatv");
         params[0] = (GLfloat)(MAX_NV_FRAGMENT_PROGRAM_PARAMS);
         break;
      case GL_TEXTURE_RECTANGLE_NV:
         CHECK_EXT1(NV_texture_rectangle, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(_mesa_IsEnabled(GL_TEXTURE_RECTANGLE_NV));
         break;
      case GL_TEXTURE_BINDING_RECTANGLE_NV:
         CHECK_EXT1(NV_texture_rectangle, "GetFloatv");
         params[0] = (GLfloat)(ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentTex[TEXTURE_RECT_INDEX]->Name);
         break;
      case GL_MAX_RECTANGLE_TEXTURE_SIZE_NV:
         CHECK_EXT1(NV_texture_rectangle, "GetFloatv");
         params[0] = (GLfloat)(ctx->Const.MaxTextureRectSize);
         break;
      case GL_STENCIL_TEST_TWO_SIDE_EXT:
         CHECK_EXT1(EXT_stencil_two_side, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->Stencil.TestTwoSide);
         break;
      case GL_ACTIVE_STENCIL_FACE_EXT:
         CHECK_EXT1(EXT_stencil_two_side, "GetFloatv");
         params[0] = ENUM_TO_FLOAT(ctx->Stencil.ActiveFace ? GL_BACK : GL_FRONT);
         break;
      case GL_MAX_SHININESS_NV:
         CHECK_EXT1(NV_light_max_exponent, "GetFloatv");
         params[0] = ctx->Const.MaxShininess;
         break;
      case GL_MAX_SPOT_EXPONENT_NV:
         CHECK_EXT1(NV_light_max_exponent, "GetFloatv");
         params[0] = ctx->Const.MaxSpotExponent;
         break;
      case GL_ARRAY_BUFFER_BINDING_ARB:
         params[0] = (GLfloat)(ctx->Array.ArrayBufferObj->Name);
         break;
      case GL_VERTEX_ARRAY_BUFFER_BINDING_ARB:
         params[0] = (GLfloat)(ctx->Array.ArrayObj->Vertex.BufferObj->Name);
         break;
      case GL_NORMAL_ARRAY_BUFFER_BINDING_ARB:
         params[0] = (GLfloat)(ctx->Array.ArrayObj->Normal.BufferObj->Name);
         break;
      case GL_COLOR_ARRAY_BUFFER_BINDING_ARB:
         params[0] = (GLfloat)(ctx->Array.ArrayObj->Color.BufferObj->Name);
         break;
      case GL_INDEX_ARRAY_BUFFER_BINDING_ARB:
         params[0] = (GLfloat)(ctx->Array.ArrayObj->Index.BufferObj->Name);
         break;
      case GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING_ARB:
         params[0] = (GLfloat)(ctx->Array.ArrayObj->TexCoord[ctx->Array.ActiveTexture].BufferObj->Name);
         break;
      case GL_EDGE_FLAG_ARRAY_BUFFER_BINDING_ARB:
         params[0] = (GLfloat)(ctx->Array.ArrayObj->EdgeFlag.BufferObj->Name);
         break;
      case GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING_ARB:
         params[0] = (GLfloat)(ctx->Array.ArrayObj->SecondaryColor.BufferObj->Name);
         break;
      case GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING_ARB:
         params[0] = (GLfloat)(ctx->Array.ArrayObj->FogCoord.BufferObj->Name);
         break;
      case GL_ELEMENT_ARRAY_BUFFER_BINDING_ARB:
         params[0] = (GLfloat)(ctx->Array.ElementArrayBufferObj->Name);
         break;
      case GL_PIXEL_PACK_BUFFER_BINDING_EXT:
         CHECK_EXT1(EXT_pixel_buffer_object, "GetFloatv");
         params[0] = (GLfloat)(ctx->Pack.BufferObj->Name);
         break;
      case GL_PIXEL_UNPACK_BUFFER_BINDING_EXT:
         CHECK_EXT1(EXT_pixel_buffer_object, "GetFloatv");
         params[0] = (GLfloat)(ctx->Unpack.BufferObj->Name);
         break;
      case GL_VERTEX_PROGRAM_ARB:
         CHECK_EXT2(ARB_vertex_program, NV_vertex_program, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->VertexProgram.Enabled);
         break;
      case GL_VERTEX_PROGRAM_POINT_SIZE_ARB:
         CHECK_EXT2(ARB_vertex_program, NV_vertex_program, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->VertexProgram.PointSizeEnabled);
         break;
      case GL_VERTEX_PROGRAM_TWO_SIDE_ARB:
         CHECK_EXT2(ARB_vertex_program, NV_vertex_program, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->VertexProgram.TwoSideEnabled);
         break;
      case GL_MAX_PROGRAM_MATRIX_STACK_DEPTH_ARB:
         CHECK_EXT3(ARB_vertex_program, ARB_fragment_program, NV_vertex_program, "GetFloatv");
         params[0] = (GLfloat)(ctx->Const.MaxProgramMatrixStackDepth);
         break;
      case GL_MAX_PROGRAM_MATRICES_ARB:
         CHECK_EXT3(ARB_vertex_program, ARB_fragment_program, NV_vertex_program, "GetFloatv");
         params[0] = (GLfloat)(ctx->Const.MaxProgramMatrices);
         break;
      case GL_CURRENT_MATRIX_STACK_DEPTH_ARB:
         CHECK_EXT3(ARB_vertex_program, ARB_fragment_program, NV_vertex_program, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->CurrentStack->Depth + 1);
         break;
      case GL_CURRENT_MATRIX_ARB:
         CHECK_EXT3(ARB_vertex_program, ARB_fragment_program, NV_fragment_program, "GetFloatv");
         {
         const GLfloat *matrix = ctx->CurrentStack->Top->m;
         params[0] = matrix[0];
         params[1] = matrix[1];
         params[2] = matrix[2];
         params[3] = matrix[3];
         params[4] = matrix[4];
         params[5] = matrix[5];
         params[6] = matrix[6];
         params[7] = matrix[7];
         params[8] = matrix[8];
         params[9] = matrix[9];
         params[10] = matrix[10];
         params[11] = matrix[11];
         params[12] = matrix[12];
         params[13] = matrix[13];
         params[14] = matrix[14];
         params[15] = matrix[15];
         }
         break;
      case GL_TRANSPOSE_CURRENT_MATRIX_ARB:
         CHECK_EXT2(ARB_vertex_program, ARB_fragment_program, "GetFloatv");
         {
         const GLfloat *matrix = ctx->CurrentStack->Top->m;
         params[0] = matrix[0];
         params[1] = matrix[4];
         params[2] = matrix[8];
         params[3] = matrix[12];
         params[4] = matrix[1];
         params[5] = matrix[5];
         params[6] = matrix[9];
         params[7] = matrix[13];
         params[8] = matrix[2];
         params[9] = matrix[6];
         params[10] = matrix[10];
         params[11] = matrix[14];
         params[12] = matrix[3];
         params[13] = matrix[7];
         params[14] = matrix[11];
         params[15] = matrix[15];
         }
         break;
      case GL_MAX_VERTEX_ATTRIBS_ARB:
         CHECK_EXT1(ARB_vertex_program, "GetFloatv");
         params[0] = (GLfloat)(ctx->Const.VertexProgram.MaxAttribs);
         break;
      case GL_PROGRAM_ERROR_POSITION_ARB:
         CHECK_EXT4(NV_vertex_program, ARB_vertex_program, NV_fragment_program, ARB_fragment_program, "GetFloatv");
         params[0] = (GLfloat)(ctx->Program.ErrorPos);
         break;
      case GL_FRAGMENT_PROGRAM_ARB:
         CHECK_EXT1(ARB_fragment_program, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->FragmentProgram.Enabled);
         break;
      case GL_MAX_TEXTURE_COORDS_ARB:
         CHECK_EXT2(ARB_fragment_program, NV_fragment_program, "GetFloatv");
         params[0] = (GLfloat)(ctx->Const.MaxTextureCoordUnits);
         break;
      case GL_MAX_TEXTURE_IMAGE_UNITS_ARB:
         CHECK_EXT2(ARB_fragment_program, NV_fragment_program, "GetFloatv");
         params[0] = (GLfloat)(ctx->Const.MaxTextureImageUnits);
         break;
      case GL_DEPTH_BOUNDS_TEST_EXT:
         CHECK_EXT1(EXT_depth_bounds_test, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->Depth.BoundsTest);
         break;
      case GL_DEPTH_BOUNDS_EXT:
         CHECK_EXT1(EXT_depth_bounds_test, "GetFloatv");
         params[0] = ctx->Depth.BoundsMin;
         params[1] = ctx->Depth.BoundsMax;
         break;
      case GL_DEPTH_CLAMP:
         CHECK_EXT1(ARB_depth_clamp, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->Transform.DepthClamp);
         break;
      case GL_MAX_DRAW_BUFFERS_ARB:
         params[0] = (GLfloat)(ctx->Const.MaxDrawBuffers);
         break;
      case GL_DRAW_BUFFER0_ARB:
         params[0] = ENUM_TO_FLOAT(ctx->DrawBuffer->ColorDrawBuffer[0]);
         break;
      case GL_DRAW_BUFFER1_ARB:
         {
         GLenum buffer;
         if (pname - GL_DRAW_BUFFER0_ARB >= ctx->Const.MaxDrawBuffers) {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGet(GL_DRAW_BUFFERx_ARB)");
            return;
         }
         buffer = ctx->DrawBuffer->ColorDrawBuffer[1];
         params[0] = ENUM_TO_FLOAT(buffer);
         }
         break;
      case GL_DRAW_BUFFER2_ARB:
         {
         GLenum buffer;
         if (pname - GL_DRAW_BUFFER0_ARB >= ctx->Const.MaxDrawBuffers) {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGet(GL_DRAW_BUFFERx_ARB)");
            return;
         }
         buffer = ctx->DrawBuffer->ColorDrawBuffer[2];
         params[0] = ENUM_TO_FLOAT(buffer);
         }
         break;
      case GL_DRAW_BUFFER3_ARB:
         {
         GLenum buffer;
         if (pname - GL_DRAW_BUFFER0_ARB >= ctx->Const.MaxDrawBuffers) {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGet(GL_DRAW_BUFFERx_ARB)");
            return;
         }
         buffer = ctx->DrawBuffer->ColorDrawBuffer[3];
         params[0] = ENUM_TO_FLOAT(buffer);
         }
         break;
      case GL_IMPLEMENTATION_COLOR_READ_TYPE_OES:
         CHECK_EXT1(OES_read_format, "GetFloatv");
         params[0] = (GLfloat)(_mesa_get_color_read_type(ctx));
         break;
      case GL_IMPLEMENTATION_COLOR_READ_FORMAT_OES:
         CHECK_EXT1(OES_read_format, "GetFloatv");
         params[0] = (GLfloat)(_mesa_get_color_read_format(ctx));
         break;
      case GL_NUM_FRAGMENT_REGISTERS_ATI:
         CHECK_EXT1(ATI_fragment_shader, "GetFloatv");
         params[0] = (GLfloat)(6);
         break;
      case GL_NUM_FRAGMENT_CONSTANTS_ATI:
         CHECK_EXT1(ATI_fragment_shader, "GetFloatv");
         params[0] = (GLfloat)(8);
         break;
      case GL_NUM_PASSES_ATI:
         CHECK_EXT1(ATI_fragment_shader, "GetFloatv");
         params[0] = (GLfloat)(2);
         break;
      case GL_NUM_INSTRUCTIONS_PER_PASS_ATI:
         CHECK_EXT1(ATI_fragment_shader, "GetFloatv");
         params[0] = (GLfloat)(8);
         break;
      case GL_NUM_INSTRUCTIONS_TOTAL_ATI:
         CHECK_EXT1(ATI_fragment_shader, "GetFloatv");
         params[0] = (GLfloat)(16);
         break;
      case GL_COLOR_ALPHA_PAIRING_ATI:
         CHECK_EXT1(ATI_fragment_shader, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(GL_TRUE);
         break;
      case GL_NUM_LOOPBACK_COMPONENTS_ATI:
         CHECK_EXT1(ATI_fragment_shader, "GetFloatv");
         params[0] = (GLfloat)(3);
         break;
      case GL_NUM_INPUT_INTERPOLATOR_COMPONENTS_ATI:
         CHECK_EXT1(ATI_fragment_shader, "GetFloatv");
         params[0] = (GLfloat)(3);
         break;
      case GL_STENCIL_BACK_FUNC:
         params[0] = ENUM_TO_FLOAT(ctx->Stencil.Function[1]);
         break;
      case GL_STENCIL_BACK_VALUE_MASK:
         params[0] = (GLfloat)(ctx->Stencil.ValueMask[1]);
         break;
      case GL_STENCIL_BACK_WRITEMASK:
         params[0] = (GLfloat)(ctx->Stencil.WriteMask[1]);
         break;
      case GL_STENCIL_BACK_REF:
         params[0] = (GLfloat)(ctx->Stencil.Ref[1]);
         break;
      case GL_STENCIL_BACK_FAIL:
         params[0] = ENUM_TO_FLOAT(ctx->Stencil.FailFunc[1]);
         break;
      case GL_STENCIL_BACK_PASS_DEPTH_FAIL:
         params[0] = ENUM_TO_FLOAT(ctx->Stencil.ZFailFunc[1]);
         break;
      case GL_STENCIL_BACK_PASS_DEPTH_PASS:
         params[0] = ENUM_TO_FLOAT(ctx->Stencil.ZPassFunc[1]);
         break;
      case GL_FRAMEBUFFER_BINDING_EXT:
         CHECK_EXT1(EXT_framebuffer_object, "GetFloatv");
         params[0] = (GLfloat)(ctx->DrawBuffer->Name);
         break;
      case GL_RENDERBUFFER_BINDING_EXT:
         CHECK_EXT1(EXT_framebuffer_object, "GetFloatv");
         params[0] = (GLfloat)(ctx->CurrentRenderbuffer ? ctx->CurrentRenderbuffer->Name : 0);
         break;
      case GL_MAX_COLOR_ATTACHMENTS_EXT:
         CHECK_EXT1(EXT_framebuffer_object, "GetFloatv");
         params[0] = (GLfloat)(ctx->Const.MaxColorAttachments);
         break;
      case GL_MAX_RENDERBUFFER_SIZE_EXT:
         CHECK_EXT1(EXT_framebuffer_object, "GetFloatv");
         params[0] = (GLfloat)(ctx->Const.MaxRenderbufferSize);
         break;
      case GL_READ_FRAMEBUFFER_BINDING_EXT:
         CHECK_EXT1(EXT_framebuffer_blit, "GetFloatv");
         params[0] = (GLfloat)(ctx->ReadBuffer->Name);
         break;
      case GL_PROVOKING_VERTEX_EXT:
         CHECK_EXT1(EXT_provoking_vertex, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->Light.ProvokingVertex);
         break;
      case GL_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION_EXT:
         CHECK_EXT1(EXT_provoking_vertex, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->Const.QuadsFollowProvokingVertexConvention);
         break;
      case GL_MAX_FRAGMENT_UNIFORM_COMPONENTS_ARB:
         CHECK_EXT1(ARB_fragment_shader, "GetFloatv");
         params[0] = (GLfloat)(ctx->Const.FragmentProgram.MaxUniformComponents);
         break;
      case GL_FRAGMENT_SHADER_DERIVATIVE_HINT_ARB:
         CHECK_EXT1(ARB_fragment_shader, "GetFloatv");
         params[0] = ENUM_TO_FLOAT(ctx->Hint.FragmentShaderDerivative);
         break;
      case GL_MAX_VERTEX_UNIFORM_COMPONENTS_ARB:
         CHECK_EXT1(ARB_vertex_shader, "GetFloatv");
         params[0] = (GLfloat)(ctx->Const.VertexProgram.MaxUniformComponents);
         break;
      case GL_MAX_VARYING_FLOATS_ARB:
         CHECK_EXT1(ARB_vertex_shader, "GetFloatv");
         params[0] = (GLfloat)(ctx->Const.MaxVarying * 4);
         break;
      case GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS_ARB:
         CHECK_EXT1(ARB_vertex_shader, "GetFloatv");
         params[0] = (GLfloat)(ctx->Const.MaxVertexTextureImageUnits);
         break;
      case GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS_ARB:
         CHECK_EXT1(ARB_vertex_shader, "GetFloatv");
         params[0] = (GLfloat)(ctx->Const.MaxCombinedTextureImageUnits);
         break;
      case GL_CURRENT_PROGRAM:
         CHECK_EXT1(ARB_shader_objects, "GetFloatv");
         params[0] = (GLfloat)(ctx->Shader.CurrentProgram ? ctx->Shader.CurrentProgram->Name : 0);
         break;
      case GL_MAX_SAMPLES:
         CHECK_EXT1(ARB_framebuffer_object, "GetFloatv");
         params[0] = (GLfloat)(ctx->Const.MaxSamples);
         break;
      case GL_VERTEX_ARRAY_BINDING_APPLE:
         CHECK_EXT1(APPLE_vertex_array_object, "GetFloatv");
         params[0] = (GLfloat)(ctx->Array.ArrayObj->Name);
         break;
      case GL_TEXTURE_CUBE_MAP_SEAMLESS:
         CHECK_EXT1(ARB_seamless_cube_map, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->Texture.CubeMapSeamless);
         break;
      case GL_MAX_SERVER_WAIT_TIMEOUT:
         CHECK_EXT1(ARB_sync, "GetFloatv");
         params[0] = (GLfloat)(ctx->Const.MaxServerWaitTimeout);
         break;
      case GL_NUM_EXTENSIONS:
         params[0] = (GLfloat)(_mesa_get_extension_count(ctx));
         break;
      case GL_MAJOR_VERSION:
         params[0] = (GLfloat)(ctx->VersionMajor);
         break;
      case GL_MINOR_VERSION:
         params[0] = (GLfloat)(ctx->VersionMinor);
         break;
      default:
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetFloatv(pname=0x%x)", pname);
d1993 1
a1993 1
_mesa_GetIntegerv( GLenum pname, GLint *params )
d1995 84
a2078 1863
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   if (!params)
      return;

   if (ctx->NewState)
      _mesa_update_state(ctx);

   if (ctx->Driver.GetIntegerv &&
       ctx->Driver.GetIntegerv(ctx, pname, params))
      return;

   switch (pname) {
      case GL_ACCUM_RED_BITS:
         params[0] = ctx->DrawBuffer->Visual.accumRedBits;
         break;
      case GL_ACCUM_GREEN_BITS:
         params[0] = ctx->DrawBuffer->Visual.accumGreenBits;
         break;
      case GL_ACCUM_BLUE_BITS:
         params[0] = ctx->DrawBuffer->Visual.accumBlueBits;
         break;
      case GL_ACCUM_ALPHA_BITS:
         params[0] = ctx->DrawBuffer->Visual.accumAlphaBits;
         break;
      case GL_ACCUM_CLEAR_VALUE:
         params[0] = FLOAT_TO_INT(ctx->Accum.ClearColor[0]);
         params[1] = FLOAT_TO_INT(ctx->Accum.ClearColor[1]);
         params[2] = FLOAT_TO_INT(ctx->Accum.ClearColor[2]);
         params[3] = FLOAT_TO_INT(ctx->Accum.ClearColor[3]);
         break;
      case GL_ALPHA_BIAS:
         params[0] = IROUND(ctx->Pixel.AlphaBias);
         break;
      case GL_ALPHA_BITS:
         params[0] = ctx->DrawBuffer->Visual.alphaBits;
         break;
      case GL_ALPHA_SCALE:
         params[0] = IROUND(ctx->Pixel.AlphaScale);
         break;
      case GL_ALPHA_TEST:
         params[0] = BOOLEAN_TO_INT(ctx->Color.AlphaEnabled);
         break;
      case GL_ALPHA_TEST_FUNC:
         params[0] = ENUM_TO_INT(ctx->Color.AlphaFunc);
         break;
      case GL_ALPHA_TEST_REF:
         params[0] = FLOAT_TO_INT(ctx->Color.AlphaRef);
         break;
      case GL_ATTRIB_STACK_DEPTH:
         params[0] = ctx->AttribStackDepth;
         break;
      case GL_AUTO_NORMAL:
         params[0] = BOOLEAN_TO_INT(ctx->Eval.AutoNormal);
         break;
      case GL_AUX_BUFFERS:
         params[0] = ctx->DrawBuffer->Visual.numAuxBuffers;
         break;
      case GL_BLEND:
         params[0] = BOOLEAN_TO_INT((ctx->Color.BlendEnabled & 1));
         break;
      case GL_BLEND_DST:
         params[0] = ENUM_TO_INT(ctx->Color.BlendDstRGB);
         break;
      case GL_BLEND_SRC:
         params[0] = ENUM_TO_INT(ctx->Color.BlendSrcRGB);
         break;
      case GL_BLEND_SRC_RGB_EXT:
         params[0] = ENUM_TO_INT(ctx->Color.BlendSrcRGB);
         break;
      case GL_BLEND_DST_RGB_EXT:
         params[0] = ENUM_TO_INT(ctx->Color.BlendDstRGB);
         break;
      case GL_BLEND_SRC_ALPHA_EXT:
         params[0] = ENUM_TO_INT(ctx->Color.BlendSrcA);
         break;
      case GL_BLEND_DST_ALPHA_EXT:
         params[0] = ENUM_TO_INT(ctx->Color.BlendDstA);
         break;
      case GL_BLEND_EQUATION:
         params[0] = ENUM_TO_INT(ctx->Color.BlendEquationRGB );
         break;
      case GL_BLEND_EQUATION_ALPHA_EXT:
         params[0] = ENUM_TO_INT(ctx->Color.BlendEquationA );
         break;
      case GL_BLEND_COLOR_EXT:
         params[0] = FLOAT_TO_INT(ctx->Color.BlendColor[0]);
         params[1] = FLOAT_TO_INT(ctx->Color.BlendColor[1]);
         params[2] = FLOAT_TO_INT(ctx->Color.BlendColor[2]);
         params[3] = FLOAT_TO_INT(ctx->Color.BlendColor[3]);
         break;
      case GL_BLUE_BIAS:
         params[0] = IROUND(ctx->Pixel.BlueBias);
         break;
      case GL_BLUE_BITS:
         params[0] = ctx->DrawBuffer->Visual.blueBits;
         break;
      case GL_BLUE_SCALE:
         params[0] = IROUND(ctx->Pixel.BlueScale);
         break;
      case GL_CLIENT_ATTRIB_STACK_DEPTH:
         params[0] = ctx->ClientAttribStackDepth;
         break;
      case GL_CLIP_PLANE0:
         params[0] = BOOLEAN_TO_INT((ctx->Transform.ClipPlanesEnabled >> 0) & 1);
         break;
      case GL_CLIP_PLANE1:
         params[0] = BOOLEAN_TO_INT((ctx->Transform.ClipPlanesEnabled >> 1) & 1);
         break;
      case GL_CLIP_PLANE2:
         params[0] = BOOLEAN_TO_INT((ctx->Transform.ClipPlanesEnabled >> 2) & 1);
         break;
      case GL_CLIP_PLANE3:
         params[0] = BOOLEAN_TO_INT((ctx->Transform.ClipPlanesEnabled >> 3) & 1);
         break;
      case GL_CLIP_PLANE4:
         params[0] = BOOLEAN_TO_INT((ctx->Transform.ClipPlanesEnabled >> 4) & 1);
         break;
      case GL_CLIP_PLANE5:
         params[0] = BOOLEAN_TO_INT((ctx->Transform.ClipPlanesEnabled >> 5) & 1);
         break;
      case GL_COLOR_CLEAR_VALUE:
         params[0] = FLOAT_TO_INT(ctx->Color.ClearColor[0]);
         params[1] = FLOAT_TO_INT(ctx->Color.ClearColor[1]);
         params[2] = FLOAT_TO_INT(ctx->Color.ClearColor[2]);
         params[3] = FLOAT_TO_INT(ctx->Color.ClearColor[3]);
         break;
      case GL_COLOR_MATERIAL:
         params[0] = BOOLEAN_TO_INT(ctx->Light.ColorMaterialEnabled);
         break;
      case GL_COLOR_MATERIAL_FACE:
         params[0] = ENUM_TO_INT(ctx->Light.ColorMaterialFace);
         break;
      case GL_COLOR_MATERIAL_PARAMETER:
         params[0] = ENUM_TO_INT(ctx->Light.ColorMaterialMode);
         break;
      case GL_COLOR_WRITEMASK:
         params[0] = ctx->Color.ColorMask[0][RCOMP] ? 1 : 0;
         params[1] = ctx->Color.ColorMask[0][GCOMP] ? 1 : 0;
         params[2] = ctx->Color.ColorMask[0][BCOMP] ? 1 : 0;
         params[3] = ctx->Color.ColorMask[0][ACOMP] ? 1 : 0;
         break;
      case GL_CULL_FACE:
         params[0] = BOOLEAN_TO_INT(ctx->Polygon.CullFlag);
         break;
      case GL_CULL_FACE_MODE:
         params[0] = ENUM_TO_INT(ctx->Polygon.CullFaceMode);
         break;
      case GL_CURRENT_COLOR:
         {
         FLUSH_CURRENT(ctx, 0);
         params[0] = FLOAT_TO_INT(ctx->Current.Attrib[VERT_ATTRIB_COLOR0][0]);
         params[1] = FLOAT_TO_INT(ctx->Current.Attrib[VERT_ATTRIB_COLOR0][1]);
         params[2] = FLOAT_TO_INT(ctx->Current.Attrib[VERT_ATTRIB_COLOR0][2]);
         params[3] = FLOAT_TO_INT(ctx->Current.Attrib[VERT_ATTRIB_COLOR0][3]);
         }
         break;
      case GL_CURRENT_INDEX:
         {
         FLUSH_CURRENT(ctx, 0);
         params[0] = IROUND(ctx->Current.Attrib[VERT_ATTRIB_COLOR_INDEX][0]);
         }
         break;
      case GL_CURRENT_NORMAL:
         {
         FLUSH_CURRENT(ctx, 0);
         params[0] = FLOAT_TO_INT(ctx->Current.Attrib[VERT_ATTRIB_NORMAL][0]);
         params[1] = FLOAT_TO_INT(ctx->Current.Attrib[VERT_ATTRIB_NORMAL][1]);
         params[2] = FLOAT_TO_INT(ctx->Current.Attrib[VERT_ATTRIB_NORMAL][2]);
         }
         break;
      case GL_CURRENT_RASTER_COLOR:
         params[0] = FLOAT_TO_INT(ctx->Current.RasterColor[0]);
         params[1] = FLOAT_TO_INT(ctx->Current.RasterColor[1]);
         params[2] = FLOAT_TO_INT(ctx->Current.RasterColor[2]);
         params[3] = FLOAT_TO_INT(ctx->Current.RasterColor[3]);
         break;
      case GL_CURRENT_RASTER_DISTANCE:
         params[0] = IROUND(ctx->Current.RasterDistance);
         break;
      case GL_CURRENT_RASTER_INDEX:
         params[0] = IROUND(1.0);
         break;
      case GL_CURRENT_RASTER_POSITION:
         params[0] = IROUND(ctx->Current.RasterPos[0]);
         params[1] = IROUND(ctx->Current.RasterPos[1]);
         params[2] = IROUND(ctx->Current.RasterPos[2]);
         params[3] = IROUND(ctx->Current.RasterPos[3]);
         break;
      case GL_CURRENT_RASTER_SECONDARY_COLOR:
         params[0] = FLOAT_TO_INT(ctx->Current.RasterSecondaryColor[0]);
         params[1] = FLOAT_TO_INT(ctx->Current.RasterSecondaryColor[1]);
         params[2] = FLOAT_TO_INT(ctx->Current.RasterSecondaryColor[2]);
         params[3] = FLOAT_TO_INT(ctx->Current.RasterSecondaryColor[3]);
         break;
      case GL_CURRENT_RASTER_TEXTURE_COORDS:
         {
         const GLuint unit = ctx->Texture.CurrentUnit;
         if (unit >= ctx->Const.MaxTextureCoordUnits) {
            _mesa_error(ctx, GL_INVALID_OPERATION,
                        "glGet(raster tex coords, unit %u)", unit);
            return;
         }
         params[0] = IROUND(ctx->Current.RasterTexCoords[unit][0]);
         params[1] = IROUND(ctx->Current.RasterTexCoords[unit][1]);
         params[2] = IROUND(ctx->Current.RasterTexCoords[unit][2]);
         params[3] = IROUND(ctx->Current.RasterTexCoords[unit][3]);
         }
         break;
      case GL_CURRENT_RASTER_POSITION_VALID:
         params[0] = BOOLEAN_TO_INT(ctx->Current.RasterPosValid);
         break;
      case GL_CURRENT_TEXTURE_COORDS:
         {
         const GLuint unit = ctx->Texture.CurrentUnit;
         if (unit >= ctx->Const.MaxTextureCoordUnits) {
            _mesa_error(ctx, GL_INVALID_OPERATION,
                        "glGet(current tex coords, unit %u)", unit);
            return;
         }
         FLUSH_CURRENT(ctx, 0);
         params[0] = IROUND(ctx->Current.Attrib[VERT_ATTRIB_TEX0 + unit][0]);
         params[1] = IROUND(ctx->Current.Attrib[VERT_ATTRIB_TEX0 + unit][1]);
         params[2] = IROUND(ctx->Current.Attrib[VERT_ATTRIB_TEX0 + unit][2]);
         params[3] = IROUND(ctx->Current.Attrib[VERT_ATTRIB_TEX0 + unit][3]);
         }
         break;
      case GL_DEPTH_BIAS:
         params[0] = IROUND(ctx->Pixel.DepthBias);
         break;
      case GL_DEPTH_BITS:
         params[0] = ctx->DrawBuffer->Visual.depthBits;
         break;
      case GL_DEPTH_CLEAR_VALUE:
         params[0] = FLOAT_TO_INT(((GLfloat) ctx->Depth.Clear));
         break;
      case GL_DEPTH_FUNC:
         params[0] = ENUM_TO_INT(ctx->Depth.Func);
         break;
      case GL_DEPTH_RANGE:
         params[0] = FLOAT_TO_INT(ctx->Viewport.Near);
         params[1] = FLOAT_TO_INT(ctx->Viewport.Far);
         break;
      case GL_DEPTH_SCALE:
         params[0] = IROUND(ctx->Pixel.DepthScale);
         break;
      case GL_DEPTH_TEST:
         params[0] = BOOLEAN_TO_INT(ctx->Depth.Test);
         break;
      case GL_DEPTH_WRITEMASK:
         params[0] = BOOLEAN_TO_INT(ctx->Depth.Mask);
         break;
      case GL_DITHER:
         params[0] = BOOLEAN_TO_INT(ctx->Color.DitherFlag);
         break;
      case GL_DOUBLEBUFFER:
         params[0] = BOOLEAN_TO_INT(ctx->DrawBuffer->Visual.doubleBufferMode);
         break;
      case GL_DRAW_BUFFER:
         params[0] = ENUM_TO_INT(ctx->DrawBuffer->ColorDrawBuffer[0]);
         break;
      case GL_EDGE_FLAG:
         {
         FLUSH_CURRENT(ctx, 0);
         params[0] = BOOLEAN_TO_INT((ctx->Current.Attrib[VERT_ATTRIB_EDGEFLAG][0] == 1.0));
         }
         break;
      case GL_FEEDBACK_BUFFER_SIZE:
         params[0] = ctx->Feedback.BufferSize;
         break;
      case GL_FEEDBACK_BUFFER_TYPE:
         params[0] = ENUM_TO_INT(ctx->Feedback.Type);
         break;
      case GL_FOG:
         params[0] = BOOLEAN_TO_INT(ctx->Fog.Enabled);
         break;
      case GL_FOG_COLOR:
         params[0] = FLOAT_TO_INT(ctx->Fog.Color[0]);
         params[1] = FLOAT_TO_INT(ctx->Fog.Color[1]);
         params[2] = FLOAT_TO_INT(ctx->Fog.Color[2]);
         params[3] = FLOAT_TO_INT(ctx->Fog.Color[3]);
         break;
      case GL_FOG_DENSITY:
         params[0] = IROUND(ctx->Fog.Density);
         break;
      case GL_FOG_END:
         params[0] = IROUND(ctx->Fog.End);
         break;
      case GL_FOG_HINT:
         params[0] = ENUM_TO_INT(ctx->Hint.Fog);
         break;
      case GL_FOG_INDEX:
         params[0] = IROUND(ctx->Fog.Index);
         break;
      case GL_FOG_MODE:
         params[0] = ENUM_TO_INT(ctx->Fog.Mode);
         break;
      case GL_FOG_START:
         params[0] = IROUND(ctx->Fog.Start);
         break;
      case GL_FRONT_FACE:
         params[0] = ENUM_TO_INT(ctx->Polygon.FrontFace);
         break;
      case GL_GREEN_BIAS:
         params[0] = IROUND(ctx->Pixel.GreenBias);
         break;
      case GL_GREEN_BITS:
         params[0] = ctx->DrawBuffer->Visual.greenBits;
         break;
      case GL_GREEN_SCALE:
         params[0] = IROUND(ctx->Pixel.GreenScale);
         break;
      case GL_INDEX_BITS:
         params[0] = ctx->DrawBuffer->Visual.indexBits;
         break;
      case GL_INDEX_CLEAR_VALUE:
         params[0] = ctx->Color.ClearIndex;
         break;
      case GL_INDEX_MODE:
         params[0] = BOOLEAN_TO_INT(GL_FALSE);
         break;
      case GL_INDEX_OFFSET:
         params[0] = ctx->Pixel.IndexOffset;
         break;
      case GL_INDEX_SHIFT:
         params[0] = ctx->Pixel.IndexShift;
         break;
      case GL_INDEX_WRITEMASK:
         params[0] = ctx->Color.IndexMask;
         break;
      case GL_LIGHT0:
         params[0] = BOOLEAN_TO_INT(ctx->Light.Light[0].Enabled);
         break;
      case GL_LIGHT1:
         params[0] = BOOLEAN_TO_INT(ctx->Light.Light[1].Enabled);
         break;
      case GL_LIGHT2:
         params[0] = BOOLEAN_TO_INT(ctx->Light.Light[2].Enabled);
         break;
      case GL_LIGHT3:
         params[0] = BOOLEAN_TO_INT(ctx->Light.Light[3].Enabled);
         break;
      case GL_LIGHT4:
         params[0] = BOOLEAN_TO_INT(ctx->Light.Light[4].Enabled);
         break;
      case GL_LIGHT5:
         params[0] = BOOLEAN_TO_INT(ctx->Light.Light[5].Enabled);
         break;
      case GL_LIGHT6:
         params[0] = BOOLEAN_TO_INT(ctx->Light.Light[6].Enabled);
         break;
      case GL_LIGHT7:
         params[0] = BOOLEAN_TO_INT(ctx->Light.Light[7].Enabled);
         break;
      case GL_LIGHTING:
         params[0] = BOOLEAN_TO_INT(ctx->Light.Enabled);
         break;
      case GL_LIGHT_MODEL_AMBIENT:
         params[0] = FLOAT_TO_INT(ctx->Light.Model.Ambient[0]);
         params[1] = FLOAT_TO_INT(ctx->Light.Model.Ambient[1]);
         params[2] = FLOAT_TO_INT(ctx->Light.Model.Ambient[2]);
         params[3] = FLOAT_TO_INT(ctx->Light.Model.Ambient[3]);
         break;
      case GL_LIGHT_MODEL_COLOR_CONTROL:
         params[0] = ENUM_TO_INT(ctx->Light.Model.ColorControl);
         break;
      case GL_LIGHT_MODEL_LOCAL_VIEWER:
         params[0] = BOOLEAN_TO_INT(ctx->Light.Model.LocalViewer);
         break;
      case GL_LIGHT_MODEL_TWO_SIDE:
         params[0] = BOOLEAN_TO_INT(ctx->Light.Model.TwoSide);
         break;
      case GL_LINE_SMOOTH:
         params[0] = BOOLEAN_TO_INT(ctx->Line.SmoothFlag);
         break;
      case GL_LINE_SMOOTH_HINT:
         params[0] = ENUM_TO_INT(ctx->Hint.LineSmooth);
         break;
      case GL_LINE_STIPPLE:
         params[0] = BOOLEAN_TO_INT(ctx->Line.StippleFlag);
         break;
      case GL_LINE_STIPPLE_PATTERN:
         params[0] = ctx->Line.StipplePattern;
         break;
      case GL_LINE_STIPPLE_REPEAT:
         params[0] = ctx->Line.StippleFactor;
         break;
      case GL_LINE_WIDTH:
         params[0] = IROUND(ctx->Line.Width);
         break;
      case GL_LINE_WIDTH_GRANULARITY:
         params[0] = IROUND(ctx->Const.LineWidthGranularity);
         break;
      case GL_LINE_WIDTH_RANGE:
         params[0] = IROUND(ctx->Const.MinLineWidthAA);
         params[1] = IROUND(ctx->Const.MaxLineWidthAA);
         break;
      case GL_ALIASED_LINE_WIDTH_RANGE:
         params[0] = IROUND(ctx->Const.MinLineWidth);
         params[1] = IROUND(ctx->Const.MaxLineWidth);
         break;
      case GL_LIST_BASE:
         params[0] = ctx->List.ListBase;
         break;
      case GL_LIST_INDEX:
         params[0] = (ctx->ListState.CurrentList ? ctx->ListState.CurrentList->Name : 0);
         break;
      case GL_LIST_MODE:
         {
         GLenum mode;
         if (!ctx->CompileFlag)
            mode = 0;
         else if (ctx->ExecuteFlag)
            mode = GL_COMPILE_AND_EXECUTE;
         else
            mode = GL_COMPILE;
         params[0] = ENUM_TO_INT(mode);
         }
         break;
      case GL_INDEX_LOGIC_OP:
         params[0] = BOOLEAN_TO_INT(ctx->Color.IndexLogicOpEnabled);
         break;
      case GL_COLOR_LOGIC_OP:
         params[0] = BOOLEAN_TO_INT(ctx->Color.ColorLogicOpEnabled);
         break;
      case GL_LOGIC_OP_MODE:
         params[0] = ENUM_TO_INT(ctx->Color.LogicOp);
         break;
      case GL_MAP1_COLOR_4:
         params[0] = BOOLEAN_TO_INT(ctx->Eval.Map1Color4);
         break;
      case GL_MAP1_GRID_DOMAIN:
         params[0] = IROUND(ctx->Eval.MapGrid1u1);
         params[1] = IROUND(ctx->Eval.MapGrid1u2);
         break;
      case GL_MAP1_GRID_SEGMENTS:
         params[0] = ctx->Eval.MapGrid1un;
         break;
      case GL_MAP1_INDEX:
         params[0] = BOOLEAN_TO_INT(ctx->Eval.Map1Index);
         break;
      case GL_MAP1_NORMAL:
         params[0] = BOOLEAN_TO_INT(ctx->Eval.Map1Normal);
         break;
      case GL_MAP1_TEXTURE_COORD_1:
         params[0] = BOOLEAN_TO_INT(ctx->Eval.Map1TextureCoord1);
         break;
      case GL_MAP1_TEXTURE_COORD_2:
         params[0] = BOOLEAN_TO_INT(ctx->Eval.Map1TextureCoord2);
         break;
      case GL_MAP1_TEXTURE_COORD_3:
         params[0] = BOOLEAN_TO_INT(ctx->Eval.Map1TextureCoord3);
         break;
      case GL_MAP1_TEXTURE_COORD_4:
         params[0] = BOOLEAN_TO_INT(ctx->Eval.Map1TextureCoord4);
         break;
      case GL_MAP1_VERTEX_3:
         params[0] = BOOLEAN_TO_INT(ctx->Eval.Map1Vertex3);
         break;
      case GL_MAP1_VERTEX_4:
         params[0] = BOOLEAN_TO_INT(ctx->Eval.Map1Vertex4);
         break;
      case GL_MAP2_COLOR_4:
         params[0] = BOOLEAN_TO_INT(ctx->Eval.Map2Color4);
         break;
      case GL_MAP2_GRID_DOMAIN:
         params[0] = IROUND(ctx->Eval.MapGrid2u1);
         params[1] = IROUND(ctx->Eval.MapGrid2u2);
         params[2] = IROUND(ctx->Eval.MapGrid2v1);
         params[3] = IROUND(ctx->Eval.MapGrid2v2);
         break;
      case GL_MAP2_GRID_SEGMENTS:
         params[0] = ctx->Eval.MapGrid2un;
         params[1] = ctx->Eval.MapGrid2vn;
         break;
      case GL_MAP2_INDEX:
         params[0] = BOOLEAN_TO_INT(ctx->Eval.Map2Index);
         break;
      case GL_MAP2_NORMAL:
         params[0] = BOOLEAN_TO_INT(ctx->Eval.Map2Normal);
         break;
      case GL_MAP2_TEXTURE_COORD_1:
         params[0] = BOOLEAN_TO_INT(ctx->Eval.Map2TextureCoord1);
         break;
      case GL_MAP2_TEXTURE_COORD_2:
         params[0] = BOOLEAN_TO_INT(ctx->Eval.Map2TextureCoord2);
         break;
      case GL_MAP2_TEXTURE_COORD_3:
         params[0] = BOOLEAN_TO_INT(ctx->Eval.Map2TextureCoord3);
         break;
      case GL_MAP2_TEXTURE_COORD_4:
         params[0] = BOOLEAN_TO_INT(ctx->Eval.Map2TextureCoord4);
         break;
      case GL_MAP2_VERTEX_3:
         params[0] = BOOLEAN_TO_INT(ctx->Eval.Map2Vertex3);
         break;
      case GL_MAP2_VERTEX_4:
         params[0] = BOOLEAN_TO_INT(ctx->Eval.Map2Vertex4);
         break;
      case GL_MAP_COLOR:
         params[0] = BOOLEAN_TO_INT(ctx->Pixel.MapColorFlag);
         break;
      case GL_MAP_STENCIL:
         params[0] = BOOLEAN_TO_INT(ctx->Pixel.MapStencilFlag);
         break;
      case GL_MATRIX_MODE:
         params[0] = ENUM_TO_INT(ctx->Transform.MatrixMode);
         break;
      case GL_MAX_ATTRIB_STACK_DEPTH:
         params[0] = MAX_ATTRIB_STACK_DEPTH;
         break;
      case GL_MAX_CLIENT_ATTRIB_STACK_DEPTH:
         params[0] = MAX_CLIENT_ATTRIB_STACK_DEPTH;
         break;
      case GL_MAX_CLIP_PLANES:
         params[0] = ctx->Const.MaxClipPlanes;
         break;
      case GL_MAX_ELEMENTS_VERTICES:
         params[0] = ctx->Const.MaxArrayLockSize;
         break;
      case GL_MAX_ELEMENTS_INDICES:
         params[0] = ctx->Const.MaxArrayLockSize;
         break;
      case GL_MAX_EVAL_ORDER:
         params[0] = MAX_EVAL_ORDER;
         break;
      case GL_MAX_LIGHTS:
         params[0] = ctx->Const.MaxLights;
         break;
      case GL_MAX_LIST_NESTING:
         params[0] = MAX_LIST_NESTING;
         break;
      case GL_MAX_MODELVIEW_STACK_DEPTH:
         params[0] = MAX_MODELVIEW_STACK_DEPTH;
         break;
      case GL_MAX_NAME_STACK_DEPTH:
         params[0] = MAX_NAME_STACK_DEPTH;
         break;
      case GL_MAX_PIXEL_MAP_TABLE:
         params[0] = MAX_PIXEL_MAP_TABLE;
         break;
      case GL_MAX_PROJECTION_STACK_DEPTH:
         params[0] = MAX_PROJECTION_STACK_DEPTH;
         break;
      case GL_MAX_TEXTURE_SIZE:
         params[0] = 1 << (ctx->Const.MaxTextureLevels - 1);
         break;
      case GL_MAX_3D_TEXTURE_SIZE:
         params[0] = 1 << (ctx->Const.Max3DTextureLevels - 1);
         break;
      case GL_MAX_TEXTURE_STACK_DEPTH:
         params[0] = MAX_TEXTURE_STACK_DEPTH;
         break;
      case GL_MAX_VIEWPORT_DIMS:
         params[0] = ctx->Const.MaxViewportWidth;
         params[1] = ctx->Const.MaxViewportHeight;
         break;
      case GL_MODELVIEW_MATRIX:
         {
         const GLfloat *matrix = ctx->ModelviewMatrixStack.Top->m;
         params[0] = IROUND(matrix[0]);
         params[1] = IROUND(matrix[1]);
         params[2] = IROUND(matrix[2]);
         params[3] = IROUND(matrix[3]);
         params[4] = IROUND(matrix[4]);
         params[5] = IROUND(matrix[5]);
         params[6] = IROUND(matrix[6]);
         params[7] = IROUND(matrix[7]);
         params[8] = IROUND(matrix[8]);
         params[9] = IROUND(matrix[9]);
         params[10] = IROUND(matrix[10]);
         params[11] = IROUND(matrix[11]);
         params[12] = IROUND(matrix[12]);
         params[13] = IROUND(matrix[13]);
         params[14] = IROUND(matrix[14]);
         params[15] = IROUND(matrix[15]);
         }
         break;
      case GL_MODELVIEW_STACK_DEPTH:
         params[0] = ctx->ModelviewMatrixStack.Depth + 1;
         break;
      case GL_NAME_STACK_DEPTH:
         params[0] = ctx->Select.NameStackDepth;
         break;
      case GL_NORMALIZE:
         params[0] = BOOLEAN_TO_INT(ctx->Transform.Normalize);
         break;
      case GL_PACK_ALIGNMENT:
         params[0] = ctx->Pack.Alignment;
         break;
      case GL_PACK_LSB_FIRST:
         params[0] = BOOLEAN_TO_INT(ctx->Pack.LsbFirst);
         break;
      case GL_PACK_ROW_LENGTH:
         params[0] = ctx->Pack.RowLength;
         break;
      case GL_PACK_SKIP_PIXELS:
         params[0] = ctx->Pack.SkipPixels;
         break;
      case GL_PACK_SKIP_ROWS:
         params[0] = ctx->Pack.SkipRows;
         break;
      case GL_PACK_SWAP_BYTES:
         params[0] = BOOLEAN_TO_INT(ctx->Pack.SwapBytes);
         break;
      case GL_PACK_SKIP_IMAGES_EXT:
         params[0] = ctx->Pack.SkipImages;
         break;
      case GL_PACK_IMAGE_HEIGHT_EXT:
         params[0] = ctx->Pack.ImageHeight;
         break;
      case GL_PACK_INVERT_MESA:
         params[0] = BOOLEAN_TO_INT(ctx->Pack.Invert);
         break;
      case GL_PERSPECTIVE_CORRECTION_HINT:
         params[0] = ENUM_TO_INT(ctx->Hint.PerspectiveCorrection);
         break;
      case GL_PIXEL_MAP_A_TO_A_SIZE:
         params[0] = ctx->PixelMaps.AtoA.Size;
         break;
      case GL_PIXEL_MAP_B_TO_B_SIZE:
         params[0] = ctx->PixelMaps.BtoB.Size;
         break;
      case GL_PIXEL_MAP_G_TO_G_SIZE:
         params[0] = ctx->PixelMaps.GtoG.Size;
         break;
      case GL_PIXEL_MAP_I_TO_A_SIZE:
         params[0] = ctx->PixelMaps.ItoA.Size;
         break;
      case GL_PIXEL_MAP_I_TO_B_SIZE:
         params[0] = ctx->PixelMaps.ItoB.Size;
         break;
      case GL_PIXEL_MAP_I_TO_G_SIZE:
         params[0] = ctx->PixelMaps.ItoG.Size;
         break;
      case GL_PIXEL_MAP_I_TO_I_SIZE:
         params[0] = ctx->PixelMaps.ItoI.Size;
         break;
      case GL_PIXEL_MAP_I_TO_R_SIZE:
         params[0] = ctx->PixelMaps.ItoR.Size;
         break;
      case GL_PIXEL_MAP_R_TO_R_SIZE:
         params[0] = ctx->PixelMaps.RtoR.Size;
         break;
      case GL_PIXEL_MAP_S_TO_S_SIZE:
         params[0] = ctx->PixelMaps.StoS.Size;
         break;
      case GL_POINT_SIZE:
         params[0] = IROUND(ctx->Point.Size);
         break;
      case GL_POINT_SIZE_GRANULARITY:
         params[0] = IROUND(ctx->Const.PointSizeGranularity);
         break;
      case GL_POINT_SIZE_RANGE:
         params[0] = IROUND(ctx->Const.MinPointSizeAA);
         params[1] = IROUND(ctx->Const.MaxPointSizeAA);
         break;
      case GL_ALIASED_POINT_SIZE_RANGE:
         params[0] = IROUND(ctx->Const.MinPointSize);
         params[1] = IROUND(ctx->Const.MaxPointSize);
         break;
      case GL_POINT_SMOOTH:
         params[0] = BOOLEAN_TO_INT(ctx->Point.SmoothFlag);
         break;
      case GL_POINT_SMOOTH_HINT:
         params[0] = ENUM_TO_INT(ctx->Hint.PointSmooth);
         break;
      case GL_POINT_SIZE_MIN_EXT:
         params[0] = IROUND(ctx->Point.MinSize);
         break;
      case GL_POINT_SIZE_MAX_EXT:
         params[0] = IROUND(ctx->Point.MaxSize);
         break;
      case GL_POINT_FADE_THRESHOLD_SIZE_EXT:
         params[0] = IROUND(ctx->Point.Threshold);
         break;
      case GL_DISTANCE_ATTENUATION_EXT:
         params[0] = IROUND(ctx->Point.Params[0]);
         params[1] = IROUND(ctx->Point.Params[1]);
         params[2] = IROUND(ctx->Point.Params[2]);
         break;
      case GL_POLYGON_MODE:
         params[0] = ENUM_TO_INT(ctx->Polygon.FrontMode);
         params[1] = ENUM_TO_INT(ctx->Polygon.BackMode);
         break;
      case GL_POLYGON_OFFSET_BIAS_EXT:
         params[0] = IROUND(ctx->Polygon.OffsetUnits);
         break;
      case GL_POLYGON_OFFSET_FACTOR:
         params[0] = IROUND(ctx->Polygon.OffsetFactor );
         break;
      case GL_POLYGON_OFFSET_UNITS:
         params[0] = IROUND(ctx->Polygon.OffsetUnits );
         break;
      case GL_POLYGON_OFFSET_POINT:
         params[0] = BOOLEAN_TO_INT(ctx->Polygon.OffsetPoint);
         break;
      case GL_POLYGON_OFFSET_LINE:
         params[0] = BOOLEAN_TO_INT(ctx->Polygon.OffsetLine);
         break;
      case GL_POLYGON_OFFSET_FILL:
         params[0] = BOOLEAN_TO_INT(ctx->Polygon.OffsetFill);
         break;
      case GL_POLYGON_SMOOTH:
         params[0] = BOOLEAN_TO_INT(ctx->Polygon.SmoothFlag);
         break;
      case GL_POLYGON_SMOOTH_HINT:
         params[0] = ENUM_TO_INT(ctx->Hint.PolygonSmooth);
         break;
      case GL_POLYGON_STIPPLE:
         params[0] = BOOLEAN_TO_INT(ctx->Polygon.StippleFlag);
         break;
      case GL_PROJECTION_MATRIX:
         {
         const GLfloat *matrix = ctx->ProjectionMatrixStack.Top->m;
         params[0] = IROUND(matrix[0]);
         params[1] = IROUND(matrix[1]);
         params[2] = IROUND(matrix[2]);
         params[3] = IROUND(matrix[3]);
         params[4] = IROUND(matrix[4]);
         params[5] = IROUND(matrix[5]);
         params[6] = IROUND(matrix[6]);
         params[7] = IROUND(matrix[7]);
         params[8] = IROUND(matrix[8]);
         params[9] = IROUND(matrix[9]);
         params[10] = IROUND(matrix[10]);
         params[11] = IROUND(matrix[11]);
         params[12] = IROUND(matrix[12]);
         params[13] = IROUND(matrix[13]);
         params[14] = IROUND(matrix[14]);
         params[15] = IROUND(matrix[15]);
         }
         break;
      case GL_PROJECTION_STACK_DEPTH:
         params[0] = ctx->ProjectionMatrixStack.Depth + 1;
         break;
      case GL_READ_BUFFER:
         params[0] = ENUM_TO_INT(ctx->ReadBuffer->ColorReadBuffer);
         break;
      case GL_RED_BIAS:
         params[0] = IROUND(ctx->Pixel.RedBias);
         break;
      case GL_RED_BITS:
         params[0] = ctx->DrawBuffer->Visual.redBits;
         break;
      case GL_RED_SCALE:
         params[0] = IROUND(ctx->Pixel.RedScale);
         break;
      case GL_RENDER_MODE:
         params[0] = ENUM_TO_INT(ctx->RenderMode);
         break;
      case GL_RESCALE_NORMAL:
         params[0] = BOOLEAN_TO_INT(ctx->Transform.RescaleNormals);
         break;
      case GL_RGBA_MODE:
         params[0] = BOOLEAN_TO_INT(GL_TRUE);
         break;
      case GL_SCISSOR_BOX:
         params[0] = ctx->Scissor.X;
         params[1] = ctx->Scissor.Y;
         params[2] = ctx->Scissor.Width;
         params[3] = ctx->Scissor.Height;
         break;
      case GL_SCISSOR_TEST:
         params[0] = BOOLEAN_TO_INT(ctx->Scissor.Enabled);
         break;
      case GL_SELECTION_BUFFER_SIZE:
         params[0] = ctx->Select.BufferSize;
         break;
      case GL_SHADE_MODEL:
         params[0] = ENUM_TO_INT(ctx->Light.ShadeModel);
         break;
      case GL_SHARED_TEXTURE_PALETTE_EXT:
         params[0] = BOOLEAN_TO_INT(ctx->Texture.SharedPalette);
         break;
      case GL_STENCIL_BITS:
         params[0] = ctx->DrawBuffer->Visual.stencilBits;
         break;
      case GL_STENCIL_CLEAR_VALUE:
         params[0] = ctx->Stencil.Clear;
         break;
      case GL_STENCIL_FAIL:
         params[0] = ENUM_TO_INT(ctx->Stencil.FailFunc[ctx->Stencil.ActiveFace]);
         break;
      case GL_STENCIL_FUNC:
         params[0] = ENUM_TO_INT(ctx->Stencil.Function[ctx->Stencil.ActiveFace]);
         break;
      case GL_STENCIL_PASS_DEPTH_FAIL:
         params[0] = ENUM_TO_INT(ctx->Stencil.ZFailFunc[ctx->Stencil.ActiveFace]);
         break;
      case GL_STENCIL_PASS_DEPTH_PASS:
         params[0] = ENUM_TO_INT(ctx->Stencil.ZPassFunc[ctx->Stencil.ActiveFace]);
         break;
      case GL_STENCIL_REF:
         params[0] = ctx->Stencil.Ref[ctx->Stencil.ActiveFace];
         break;
      case GL_STENCIL_TEST:
         params[0] = BOOLEAN_TO_INT(ctx->Stencil.Enabled);
         break;
      case GL_STENCIL_VALUE_MASK:
         params[0] = ctx->Stencil.ValueMask[ctx->Stencil.ActiveFace];
         break;
      case GL_STENCIL_WRITEMASK:
         params[0] = ctx->Stencil.WriteMask[ctx->Stencil.ActiveFace];
         break;
      case GL_STEREO:
         params[0] = BOOLEAN_TO_INT(ctx->DrawBuffer->Visual.stereoMode);
         break;
      case GL_SUBPIXEL_BITS:
         params[0] = ctx->Const.SubPixelBits;
         break;
      case GL_TEXTURE_1D:
         params[0] = BOOLEAN_TO_INT(_mesa_IsEnabled(GL_TEXTURE_1D));
         break;
      case GL_TEXTURE_2D:
         params[0] = BOOLEAN_TO_INT(_mesa_IsEnabled(GL_TEXTURE_2D));
         break;
      case GL_TEXTURE_3D:
         params[0] = BOOLEAN_TO_INT(_mesa_IsEnabled(GL_TEXTURE_3D));
         break;
      case GL_TEXTURE_1D_ARRAY_EXT:
         CHECK_EXT1(MESA_texture_array, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(_mesa_IsEnabled(GL_TEXTURE_1D_ARRAY_EXT));
         break;
      case GL_TEXTURE_2D_ARRAY_EXT:
         CHECK_EXT1(MESA_texture_array, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(_mesa_IsEnabled(GL_TEXTURE_2D_ARRAY_EXT));
         break;
      case GL_TEXTURE_BINDING_1D:
         params[0] = ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentTex[TEXTURE_1D_INDEX]->Name;
         break;
      case GL_TEXTURE_BINDING_2D:
         params[0] = ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentTex[TEXTURE_2D_INDEX]->Name;
         break;
      case GL_TEXTURE_BINDING_3D:
         params[0] = ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentTex[TEXTURE_3D_INDEX]->Name;
         break;
      case GL_TEXTURE_BINDING_1D_ARRAY_EXT:
         CHECK_EXT1(MESA_texture_array, "GetIntegerv");
         params[0] = ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentTex[TEXTURE_1D_ARRAY_INDEX]->Name;
         break;
      case GL_TEXTURE_BINDING_2D_ARRAY_EXT:
         CHECK_EXT1(MESA_texture_array, "GetIntegerv");
         params[0] = ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentTex[TEXTURE_2D_ARRAY_INDEX]->Name;
         break;
      case GL_TEXTURE_GEN_S:
         params[0] = BOOLEAN_TO_INT(((ctx->Texture.Unit[ctx->Texture.CurrentUnit].TexGenEnabled & S_BIT) ? 1 : 0));
         break;
      case GL_TEXTURE_GEN_T:
         params[0] = BOOLEAN_TO_INT(((ctx->Texture.Unit[ctx->Texture.CurrentUnit].TexGenEnabled & T_BIT) ? 1 : 0));
         break;
      case GL_TEXTURE_GEN_R:
         params[0] = BOOLEAN_TO_INT(((ctx->Texture.Unit[ctx->Texture.CurrentUnit].TexGenEnabled & R_BIT) ? 1 : 0));
         break;
      case GL_TEXTURE_GEN_Q:
         params[0] = BOOLEAN_TO_INT(((ctx->Texture.Unit[ctx->Texture.CurrentUnit].TexGenEnabled & Q_BIT) ? 1 : 0));
         break;
      case GL_TEXTURE_MATRIX:
         {
         const GLfloat *matrix;
         const GLuint unit = ctx->Texture.CurrentUnit;
         if (unit >= ctx->Const.MaxTextureCoordUnits) {
            _mesa_error(ctx, GL_INVALID_OPERATION, "glGet(texture matrix %u)",
                        unit);
            return;
         }
         matrix = ctx->TextureMatrixStack[unit].Top->m;
         params[0] = IROUND(matrix[0]);
         params[1] = IROUND(matrix[1]);
         params[2] = IROUND(matrix[2]);
         params[3] = IROUND(matrix[3]);
         params[4] = IROUND(matrix[4]);
         params[5] = IROUND(matrix[5]);
         params[6] = IROUND(matrix[6]);
         params[7] = IROUND(matrix[7]);
         params[8] = IROUND(matrix[8]);
         params[9] = IROUND(matrix[9]);
         params[10] = IROUND(matrix[10]);
         params[11] = IROUND(matrix[11]);
         params[12] = IROUND(matrix[12]);
         params[13] = IROUND(matrix[13]);
         params[14] = IROUND(matrix[14]);
         params[15] = IROUND(matrix[15]);
         }
         break;
      case GL_TEXTURE_STACK_DEPTH:
         {
         const GLuint unit = ctx->Texture.CurrentUnit;
         if (unit >= ctx->Const.MaxTextureCoordUnits) {
            _mesa_error(ctx, GL_INVALID_OPERATION,
                        "glGet(texture stack depth, unit %u)", unit);
            return;
         }
         params[0] = ctx->TextureMatrixStack[unit].Depth + 1;
         }
         break;
      case GL_UNPACK_ALIGNMENT:
         params[0] = ctx->Unpack.Alignment;
         break;
      case GL_UNPACK_LSB_FIRST:
         params[0] = BOOLEAN_TO_INT(ctx->Unpack.LsbFirst);
         break;
      case GL_UNPACK_ROW_LENGTH:
         params[0] = ctx->Unpack.RowLength;
         break;
      case GL_UNPACK_SKIP_PIXELS:
         params[0] = ctx->Unpack.SkipPixels;
         break;
      case GL_UNPACK_SKIP_ROWS:
         params[0] = ctx->Unpack.SkipRows;
         break;
      case GL_UNPACK_SWAP_BYTES:
         params[0] = BOOLEAN_TO_INT(ctx->Unpack.SwapBytes);
         break;
      case GL_UNPACK_SKIP_IMAGES_EXT:
         params[0] = ctx->Unpack.SkipImages;
         break;
      case GL_UNPACK_IMAGE_HEIGHT_EXT:
         params[0] = ctx->Unpack.ImageHeight;
         break;
      case GL_UNPACK_CLIENT_STORAGE_APPLE:
         params[0] = BOOLEAN_TO_INT(ctx->Unpack.ClientStorage);
         break;
      case GL_VIEWPORT:
         params[0] = ctx->Viewport.X;
         params[1] = ctx->Viewport.Y;
         params[2] = ctx->Viewport.Width;
         params[3] = ctx->Viewport.Height;
         break;
      case GL_ZOOM_X:
         params[0] = IROUND(ctx->Pixel.ZoomX);
         break;
      case GL_ZOOM_Y:
         params[0] = IROUND(ctx->Pixel.ZoomY);
         break;
      case GL_VERTEX_ARRAY:
         params[0] = BOOLEAN_TO_INT(ctx->Array.ArrayObj->Vertex.Enabled);
         break;
      case GL_VERTEX_ARRAY_SIZE:
         params[0] = ctx->Array.ArrayObj->Vertex.Size;
         break;
      case GL_VERTEX_ARRAY_TYPE:
         params[0] = ENUM_TO_INT(ctx->Array.ArrayObj->Vertex.Type);
         break;
      case GL_VERTEX_ARRAY_STRIDE:
         params[0] = ctx->Array.ArrayObj->Vertex.Stride;
         break;
      case GL_VERTEX_ARRAY_COUNT_EXT:
         params[0] = 0;
         break;
      case GL_NORMAL_ARRAY:
         params[0] = ENUM_TO_INT(ctx->Array.ArrayObj->Normal.Enabled);
         break;
      case GL_NORMAL_ARRAY_TYPE:
         params[0] = ENUM_TO_INT(ctx->Array.ArrayObj->Normal.Type);
         break;
      case GL_NORMAL_ARRAY_STRIDE:
         params[0] = ctx->Array.ArrayObj->Normal.Stride;
         break;
      case GL_NORMAL_ARRAY_COUNT_EXT:
         params[0] = 0;
         break;
      case GL_COLOR_ARRAY:
         params[0] = BOOLEAN_TO_INT(ctx->Array.ArrayObj->Color.Enabled);
         break;
      case GL_COLOR_ARRAY_SIZE:
         params[0] = ctx->Array.ArrayObj->Color.Size;
         break;
      case GL_COLOR_ARRAY_TYPE:
         params[0] = ENUM_TO_INT(ctx->Array.ArrayObj->Color.Type);
         break;
      case GL_COLOR_ARRAY_STRIDE:
         params[0] = ctx->Array.ArrayObj->Color.Stride;
         break;
      case GL_COLOR_ARRAY_COUNT_EXT:
         params[0] = 0;
         break;
      case GL_INDEX_ARRAY:
         params[0] = BOOLEAN_TO_INT(ctx->Array.ArrayObj->Index.Enabled);
         break;
      case GL_INDEX_ARRAY_TYPE:
         params[0] = ENUM_TO_INT(ctx->Array.ArrayObj->Index.Type);
         break;
      case GL_INDEX_ARRAY_STRIDE:
         params[0] = ctx->Array.ArrayObj->Index.Stride;
         break;
      case GL_INDEX_ARRAY_COUNT_EXT:
         params[0] = 0;
         break;
      case GL_TEXTURE_COORD_ARRAY:
         params[0] = BOOLEAN_TO_INT(ctx->Array.ArrayObj->TexCoord[ctx->Array.ActiveTexture].Enabled);
         break;
      case GL_TEXTURE_COORD_ARRAY_SIZE:
         params[0] = ctx->Array.ArrayObj->TexCoord[ctx->Array.ActiveTexture].Size;
         break;
      case GL_TEXTURE_COORD_ARRAY_TYPE:
         params[0] = ENUM_TO_INT(ctx->Array.ArrayObj->TexCoord[ctx->Array.ActiveTexture].Type);
         break;
      case GL_TEXTURE_COORD_ARRAY_STRIDE:
         params[0] = ctx->Array.ArrayObj->TexCoord[ctx->Array.ActiveTexture].Stride;
         break;
      case GL_TEXTURE_COORD_ARRAY_COUNT_EXT:
         params[0] = 0;
         break;
      case GL_EDGE_FLAG_ARRAY:
         params[0] = BOOLEAN_TO_INT(ctx->Array.ArrayObj->EdgeFlag.Enabled);
         break;
      case GL_EDGE_FLAG_ARRAY_STRIDE:
         params[0] = ctx->Array.ArrayObj->EdgeFlag.Stride;
         break;
      case GL_EDGE_FLAG_ARRAY_COUNT_EXT:
         params[0] = 0;
         break;
      case GL_MAX_TEXTURE_UNITS_ARB:
         CHECK_EXT1(ARB_multitexture, "GetIntegerv");
         params[0] = ctx->Const.MaxTextureUnits;
         break;
      case GL_ACTIVE_TEXTURE_ARB:
         CHECK_EXT1(ARB_multitexture, "GetIntegerv");
         params[0] = GL_TEXTURE0_ARB + ctx->Texture.CurrentUnit;
         break;
      case GL_CLIENT_ACTIVE_TEXTURE_ARB:
         CHECK_EXT1(ARB_multitexture, "GetIntegerv");
         params[0] = GL_TEXTURE0_ARB + ctx->Array.ActiveTexture;
         break;
      case GL_TEXTURE_CUBE_MAP_ARB:
         CHECK_EXT1(ARB_texture_cube_map, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(_mesa_IsEnabled(GL_TEXTURE_CUBE_MAP_ARB));
         break;
      case GL_TEXTURE_BINDING_CUBE_MAP_ARB:
         CHECK_EXT1(ARB_texture_cube_map, "GetIntegerv");
         params[0] = ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentTex[TEXTURE_CUBE_INDEX]->Name;
         break;
      case GL_MAX_CUBE_MAP_TEXTURE_SIZE_ARB:
         CHECK_EXT1(ARB_texture_cube_map, "GetIntegerv");
         params[0] = (1 << (ctx->Const.MaxCubeTextureLevels - 1));
         break;
      case GL_TEXTURE_COMPRESSION_HINT_ARB:
         params[0] = ctx->Hint.TextureCompression;
         break;
      case GL_NUM_COMPRESSED_TEXTURE_FORMATS_ARB:
         params[0] = _mesa_get_compressed_formats(ctx, NULL, GL_FALSE);
         break;
      case GL_COMPRESSED_TEXTURE_FORMATS_ARB:
         {
         GLint formats[100];
         GLuint i, n = _mesa_get_compressed_formats(ctx, formats, GL_FALSE);
         ASSERT(n <= 100);
         for (i = 0; i < n; i++)
            params[i] = ENUM_TO_INT(formats[i]);
         }
         break;
      case GL_ARRAY_ELEMENT_LOCK_FIRST_EXT:
         CHECK_EXT1(EXT_compiled_vertex_array, "GetIntegerv");
         params[0] = ctx->Array.LockFirst;
         break;
      case GL_ARRAY_ELEMENT_LOCK_COUNT_EXT:
         CHECK_EXT1(EXT_compiled_vertex_array, "GetIntegerv");
         params[0] = ctx->Array.LockCount;
         break;
      case GL_TRANSPOSE_COLOR_MATRIX_ARB:
         {
         const GLfloat *matrix = ctx->ColorMatrixStack.Top->m;
         params[0] = IROUND(matrix[0]);
         params[1] = IROUND(matrix[4]);
         params[2] = IROUND(matrix[8]);
         params[3] = IROUND(matrix[12]);
         params[4] = IROUND(matrix[1]);
         params[5] = IROUND(matrix[5]);
         params[6] = IROUND(matrix[9]);
         params[7] = IROUND(matrix[13]);
         params[8] = IROUND(matrix[2]);
         params[9] = IROUND(matrix[6]);
         params[10] = IROUND(matrix[10]);
         params[11] = IROUND(matrix[14]);
         params[12] = IROUND(matrix[3]);
         params[13] = IROUND(matrix[7]);
         params[14] = IROUND(matrix[11]);
         params[15] = IROUND(matrix[15]);
         }
         break;
      case GL_TRANSPOSE_MODELVIEW_MATRIX_ARB:
         {
         const GLfloat *matrix = ctx->ModelviewMatrixStack.Top->m;
         params[0] = IROUND(matrix[0]);
         params[1] = IROUND(matrix[4]);
         params[2] = IROUND(matrix[8]);
         params[3] = IROUND(matrix[12]);
         params[4] = IROUND(matrix[1]);
         params[5] = IROUND(matrix[5]);
         params[6] = IROUND(matrix[9]);
         params[7] = IROUND(matrix[13]);
         params[8] = IROUND(matrix[2]);
         params[9] = IROUND(matrix[6]);
         params[10] = IROUND(matrix[10]);
         params[11] = IROUND(matrix[14]);
         params[12] = IROUND(matrix[3]);
         params[13] = IROUND(matrix[7]);
         params[14] = IROUND(matrix[11]);
         params[15] = IROUND(matrix[15]);
         }
         break;
      case GL_TRANSPOSE_PROJECTION_MATRIX_ARB:
         {
         const GLfloat *matrix = ctx->ProjectionMatrixStack.Top->m;
         params[0] = IROUND(matrix[0]);
         params[1] = IROUND(matrix[4]);
         params[2] = IROUND(matrix[8]);
         params[3] = IROUND(matrix[12]);
         params[4] = IROUND(matrix[1]);
         params[5] = IROUND(matrix[5]);
         params[6] = IROUND(matrix[9]);
         params[7] = IROUND(matrix[13]);
         params[8] = IROUND(matrix[2]);
         params[9] = IROUND(matrix[6]);
         params[10] = IROUND(matrix[10]);
         params[11] = IROUND(matrix[14]);
         params[12] = IROUND(matrix[3]);
         params[13] = IROUND(matrix[7]);
         params[14] = IROUND(matrix[11]);
         params[15] = IROUND(matrix[15]);
         }
         break;
      case GL_TRANSPOSE_TEXTURE_MATRIX_ARB:
         {
         const GLfloat *matrix = ctx->TextureMatrixStack[ctx->Texture.CurrentUnit].Top->m;
         params[0] = IROUND(matrix[0]);
         params[1] = IROUND(matrix[4]);
         params[2] = IROUND(matrix[8]);
         params[3] = IROUND(matrix[12]);
         params[4] = IROUND(matrix[1]);
         params[5] = IROUND(matrix[5]);
         params[6] = IROUND(matrix[9]);
         params[7] = IROUND(matrix[13]);
         params[8] = IROUND(matrix[2]);
         params[9] = IROUND(matrix[6]);
         params[10] = IROUND(matrix[10]);
         params[11] = IROUND(matrix[14]);
         params[12] = IROUND(matrix[3]);
         params[13] = IROUND(matrix[7]);
         params[14] = IROUND(matrix[11]);
         params[15] = IROUND(matrix[15]);
         }
         break;
      case GL_COLOR_MATRIX_SGI:
         {
         const GLfloat *matrix = ctx->ColorMatrixStack.Top->m;
         params[0] = IROUND(matrix[0]);
         params[1] = IROUND(matrix[1]);
         params[2] = IROUND(matrix[2]);
         params[3] = IROUND(matrix[3]);
         params[4] = IROUND(matrix[4]);
         params[5] = IROUND(matrix[5]);
         params[6] = IROUND(matrix[6]);
         params[7] = IROUND(matrix[7]);
         params[8] = IROUND(matrix[8]);
         params[9] = IROUND(matrix[9]);
         params[10] = IROUND(matrix[10]);
         params[11] = IROUND(matrix[11]);
         params[12] = IROUND(matrix[12]);
         params[13] = IROUND(matrix[13]);
         params[14] = IROUND(matrix[14]);
         params[15] = IROUND(matrix[15]);
         }
         break;
      case GL_COLOR_MATRIX_STACK_DEPTH_SGI:
         params[0] = ctx->ColorMatrixStack.Depth + 1;
         break;
      case GL_MAX_COLOR_MATRIX_STACK_DEPTH_SGI:
         params[0] = MAX_COLOR_STACK_DEPTH;
         break;
      case GL_POST_COLOR_MATRIX_RED_SCALE_SGI:
         params[0] = IROUND(ctx->Pixel.PostColorMatrixScale[0]);
         break;
      case GL_POST_COLOR_MATRIX_GREEN_SCALE_SGI:
         params[0] = IROUND(ctx->Pixel.PostColorMatrixScale[1]);
         break;
      case GL_POST_COLOR_MATRIX_BLUE_SCALE_SGI:
         params[0] = IROUND(ctx->Pixel.PostColorMatrixScale[2]);
         break;
      case GL_POST_COLOR_MATRIX_ALPHA_SCALE_SGI:
         params[0] = IROUND(ctx->Pixel.PostColorMatrixScale[3]);
         break;
      case GL_POST_COLOR_MATRIX_RED_BIAS_SGI:
         params[0] = IROUND(ctx->Pixel.PostColorMatrixBias[0]);
         break;
      case GL_POST_COLOR_MATRIX_GREEN_BIAS_SGI:
         params[0] = IROUND(ctx->Pixel.PostColorMatrixBias[1]);
         break;
      case GL_POST_COLOR_MATRIX_BLUE_BIAS_SGI:
         params[0] = IROUND(ctx->Pixel.PostColorMatrixBias[2]);
         break;
      case GL_POST_COLOR_MATRIX_ALPHA_BIAS_SGI:
         params[0] = IROUND(ctx->Pixel.PostColorMatrixBias[3]);
         break;
      case GL_CONVOLUTION_1D_EXT:
         CHECK_EXT1(EXT_convolution, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->Pixel.Convolution1DEnabled);
         break;
      case GL_CONVOLUTION_2D_EXT:
         CHECK_EXT1(EXT_convolution, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->Pixel.Convolution2DEnabled);
         break;
      case GL_SEPARABLE_2D_EXT:
         CHECK_EXT1(EXT_convolution, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->Pixel.Separable2DEnabled);
         break;
      case GL_POST_CONVOLUTION_RED_SCALE_EXT:
         CHECK_EXT1(EXT_convolution, "GetIntegerv");
         params[0] = IROUND(ctx->Pixel.PostConvolutionScale[0]);
         break;
      case GL_POST_CONVOLUTION_GREEN_SCALE_EXT:
         CHECK_EXT1(EXT_convolution, "GetIntegerv");
         params[0] = IROUND(ctx->Pixel.PostConvolutionScale[1]);
         break;
      case GL_POST_CONVOLUTION_BLUE_SCALE_EXT:
         CHECK_EXT1(EXT_convolution, "GetIntegerv");
         params[0] = IROUND(ctx->Pixel.PostConvolutionScale[2]);
         break;
      case GL_POST_CONVOLUTION_ALPHA_SCALE_EXT:
         CHECK_EXT1(EXT_convolution, "GetIntegerv");
         params[0] = IROUND(ctx->Pixel.PostConvolutionScale[3]);
         break;
      case GL_POST_CONVOLUTION_RED_BIAS_EXT:
         CHECK_EXT1(EXT_convolution, "GetIntegerv");
         params[0] = IROUND(ctx->Pixel.PostConvolutionBias[0]);
         break;
      case GL_POST_CONVOLUTION_GREEN_BIAS_EXT:
         CHECK_EXT1(EXT_convolution, "GetIntegerv");
         params[0] = IROUND(ctx->Pixel.PostConvolutionBias[1]);
         break;
      case GL_POST_CONVOLUTION_BLUE_BIAS_EXT:
         CHECK_EXT1(EXT_convolution, "GetIntegerv");
         params[0] = IROUND(ctx->Pixel.PostConvolutionBias[2]);
         break;
      case GL_POST_CONVOLUTION_ALPHA_BIAS_EXT:
         CHECK_EXT1(EXT_convolution, "GetIntegerv");
         params[0] = IROUND(ctx->Pixel.PostConvolutionBias[3]);
         break;
      case GL_HISTOGRAM:
         CHECK_EXT1(EXT_histogram, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->Pixel.HistogramEnabled);
         break;
      case GL_MINMAX:
         CHECK_EXT1(EXT_histogram, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->Pixel.MinMaxEnabled);
         break;
      case GL_COLOR_TABLE_SGI:
         CHECK_EXT1(SGI_color_table, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->Pixel.ColorTableEnabled[COLORTABLE_PRECONVOLUTION]);
         break;
      case GL_POST_CONVOLUTION_COLOR_TABLE_SGI:
         CHECK_EXT1(SGI_color_table, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->Pixel.ColorTableEnabled[COLORTABLE_POSTCONVOLUTION]);
         break;
      case GL_POST_COLOR_MATRIX_COLOR_TABLE_SGI:
         CHECK_EXT1(SGI_color_table, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->Pixel.ColorTableEnabled[COLORTABLE_POSTCOLORMATRIX]);
         break;
      case GL_TEXTURE_COLOR_TABLE_SGI:
         CHECK_EXT1(SGI_texture_color_table, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->Texture.Unit[ctx->Texture.CurrentUnit].ColorTableEnabled);
         break;
      case GL_COLOR_SUM_EXT:
         CHECK_EXT2(EXT_secondary_color, ARB_vertex_program, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->Fog.ColorSumEnabled);
         break;
      case GL_CURRENT_SECONDARY_COLOR_EXT:
         CHECK_EXT1(EXT_secondary_color, "GetIntegerv");
         {
         FLUSH_CURRENT(ctx, 0);
         params[0] = FLOAT_TO_INT(ctx->Current.Attrib[VERT_ATTRIB_COLOR1][0]);
         params[1] = FLOAT_TO_INT(ctx->Current.Attrib[VERT_ATTRIB_COLOR1][1]);
         params[2] = FLOAT_TO_INT(ctx->Current.Attrib[VERT_ATTRIB_COLOR1][2]);
         params[3] = FLOAT_TO_INT(ctx->Current.Attrib[VERT_ATTRIB_COLOR1][3]);
         }
         break;
      case GL_SECONDARY_COLOR_ARRAY_EXT:
         CHECK_EXT1(EXT_secondary_color, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->Array.ArrayObj->SecondaryColor.Enabled);
         break;
      case GL_SECONDARY_COLOR_ARRAY_TYPE_EXT:
         CHECK_EXT1(EXT_secondary_color, "GetIntegerv");
         params[0] = ENUM_TO_INT(ctx->Array.ArrayObj->SecondaryColor.Type);
         break;
      case GL_SECONDARY_COLOR_ARRAY_STRIDE_EXT:
         CHECK_EXT1(EXT_secondary_color, "GetIntegerv");
         params[0] = ctx->Array.ArrayObj->SecondaryColor.Stride;
         break;
      case GL_SECONDARY_COLOR_ARRAY_SIZE_EXT:
         CHECK_EXT1(EXT_secondary_color, "GetIntegerv");
         params[0] = ctx->Array.ArrayObj->SecondaryColor.Size;
         break;
      case GL_CURRENT_FOG_COORDINATE_EXT:
         CHECK_EXT1(EXT_fog_coord, "GetIntegerv");
         {
         FLUSH_CURRENT(ctx, 0);
         params[0] = IROUND(ctx->Current.Attrib[VERT_ATTRIB_FOG][0]);
         }
         break;
      case GL_FOG_COORDINATE_ARRAY_EXT:
         CHECK_EXT1(EXT_fog_coord, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->Array.ArrayObj->FogCoord.Enabled);
         break;
      case GL_FOG_COORDINATE_ARRAY_TYPE_EXT:
         CHECK_EXT1(EXT_fog_coord, "GetIntegerv");
         params[0] = ENUM_TO_INT(ctx->Array.ArrayObj->FogCoord.Type);
         break;
      case GL_FOG_COORDINATE_ARRAY_STRIDE_EXT:
         CHECK_EXT1(EXT_fog_coord, "GetIntegerv");
         params[0] = ctx->Array.ArrayObj->FogCoord.Stride;
         break;
      case GL_FOG_COORDINATE_SOURCE_EXT:
         CHECK_EXT1(EXT_fog_coord, "GetIntegerv");
         params[0] = ENUM_TO_INT(ctx->Fog.FogCoordinateSource);
         break;
      case GL_MAX_TEXTURE_LOD_BIAS_EXT:
         CHECK_EXT1(EXT_texture_lod_bias, "GetIntegerv");
         params[0] = IROUND(ctx->Const.MaxTextureLodBias);
         break;
      case GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT:
         CHECK_EXT1(EXT_texture_filter_anisotropic, "GetIntegerv");
         params[0] = IROUND(ctx->Const.MaxTextureMaxAnisotropy);
         break;
      case GL_MULTISAMPLE_ARB:
         params[0] = BOOLEAN_TO_INT(ctx->Multisample.Enabled);
         break;
      case GL_SAMPLE_ALPHA_TO_COVERAGE_ARB:
         params[0] = BOOLEAN_TO_INT(ctx->Multisample.SampleAlphaToCoverage);
         break;
      case GL_SAMPLE_ALPHA_TO_ONE_ARB:
         params[0] = BOOLEAN_TO_INT(ctx->Multisample.SampleAlphaToOne);
         break;
      case GL_SAMPLE_COVERAGE_ARB:
         params[0] = BOOLEAN_TO_INT(ctx->Multisample.SampleCoverage);
         break;
      case GL_SAMPLE_COVERAGE_VALUE_ARB:
         params[0] = IROUND(ctx->Multisample.SampleCoverageValue);
         break;
      case GL_SAMPLE_COVERAGE_INVERT_ARB:
         params[0] = BOOLEAN_TO_INT(ctx->Multisample.SampleCoverageInvert);
         break;
      case GL_SAMPLE_BUFFERS_ARB:
         params[0] = ctx->DrawBuffer->Visual.sampleBuffers;
         break;
      case GL_SAMPLES_ARB:
         params[0] = ctx->DrawBuffer->Visual.samples;
         break;
      case GL_RASTER_POSITION_UNCLIPPED_IBM:
         CHECK_EXT1(IBM_rasterpos_clip, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->Transform.RasterPositionUnclipped);
         break;
      case GL_POINT_SPRITE_NV:
         CHECK_EXT2(NV_point_sprite, ARB_point_sprite, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->Point.PointSprite);
         break;
      case GL_POINT_SPRITE_R_MODE_NV:
         CHECK_EXT1(NV_point_sprite, "GetIntegerv");
         params[0] = ENUM_TO_INT(ctx->Point.SpriteRMode);
         break;
      case GL_POINT_SPRITE_COORD_ORIGIN:
         CHECK_EXT2(NV_point_sprite, ARB_point_sprite, "GetIntegerv");
         params[0] = ENUM_TO_INT(ctx->Point.SpriteOrigin);
         break;
      case GL_GENERATE_MIPMAP_HINT_SGIS:
         CHECK_EXT1(SGIS_generate_mipmap, "GetIntegerv");
         params[0] = ENUM_TO_INT(ctx->Hint.GenerateMipmap);
         break;
      case GL_VERTEX_PROGRAM_BINDING_NV:
         CHECK_EXT1(NV_vertex_program, "GetIntegerv");
         params[0] = (ctx->VertexProgram.Current ? ctx->VertexProgram.Current->Base.Id : 0);
         break;
      case GL_VERTEX_ATTRIB_ARRAY0_NV:
         CHECK_EXT1(NV_vertex_program, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->Array.ArrayObj->VertexAttrib[0].Enabled);
         break;
      case GL_VERTEX_ATTRIB_ARRAY1_NV:
         CHECK_EXT1(NV_vertex_program, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->Array.ArrayObj->VertexAttrib[1].Enabled);
         break;
      case GL_VERTEX_ATTRIB_ARRAY2_NV:
         CHECK_EXT1(NV_vertex_program, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->Array.ArrayObj->VertexAttrib[2].Enabled);
         break;
      case GL_VERTEX_ATTRIB_ARRAY3_NV:
         CHECK_EXT1(NV_vertex_program, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->Array.ArrayObj->VertexAttrib[3].Enabled);
         break;
      case GL_VERTEX_ATTRIB_ARRAY4_NV:
         CHECK_EXT1(NV_vertex_program, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->Array.ArrayObj->VertexAttrib[4].Enabled);
         break;
      case GL_VERTEX_ATTRIB_ARRAY5_NV:
         CHECK_EXT1(NV_vertex_program, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->Array.ArrayObj->VertexAttrib[5].Enabled);
         break;
      case GL_VERTEX_ATTRIB_ARRAY6_NV:
         CHECK_EXT1(NV_vertex_program, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->Array.ArrayObj->VertexAttrib[6].Enabled);
         break;
      case GL_VERTEX_ATTRIB_ARRAY7_NV:
         CHECK_EXT1(NV_vertex_program, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->Array.ArrayObj->VertexAttrib[7].Enabled);
         break;
      case GL_VERTEX_ATTRIB_ARRAY8_NV:
         CHECK_EXT1(NV_vertex_program, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->Array.ArrayObj->VertexAttrib[8].Enabled);
         break;
      case GL_VERTEX_ATTRIB_ARRAY9_NV:
         CHECK_EXT1(NV_vertex_program, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->Array.ArrayObj->VertexAttrib[9].Enabled);
         break;
      case GL_VERTEX_ATTRIB_ARRAY10_NV:
         CHECK_EXT1(NV_vertex_program, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->Array.ArrayObj->VertexAttrib[10].Enabled);
         break;
      case GL_VERTEX_ATTRIB_ARRAY11_NV:
         CHECK_EXT1(NV_vertex_program, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->Array.ArrayObj->VertexAttrib[11].Enabled);
         break;
      case GL_VERTEX_ATTRIB_ARRAY12_NV:
         CHECK_EXT1(NV_vertex_program, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->Array.ArrayObj->VertexAttrib[12].Enabled);
         break;
      case GL_VERTEX_ATTRIB_ARRAY13_NV:
         CHECK_EXT1(NV_vertex_program, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->Array.ArrayObj->VertexAttrib[13].Enabled);
         break;
      case GL_VERTEX_ATTRIB_ARRAY14_NV:
         CHECK_EXT1(NV_vertex_program, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->Array.ArrayObj->VertexAttrib[14].Enabled);
         break;
      case GL_VERTEX_ATTRIB_ARRAY15_NV:
         CHECK_EXT1(NV_vertex_program, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->Array.ArrayObj->VertexAttrib[15].Enabled);
         break;
      case GL_MAP1_VERTEX_ATTRIB0_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->Eval.Map1Attrib[0]);
         break;
      case GL_MAP1_VERTEX_ATTRIB1_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->Eval.Map1Attrib[1]);
         break;
      case GL_MAP1_VERTEX_ATTRIB2_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->Eval.Map1Attrib[2]);
         break;
      case GL_MAP1_VERTEX_ATTRIB3_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->Eval.Map1Attrib[3]);
         break;
      case GL_MAP1_VERTEX_ATTRIB4_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->Eval.Map1Attrib[4]);
         break;
      case GL_MAP1_VERTEX_ATTRIB5_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->Eval.Map1Attrib[5]);
         break;
      case GL_MAP1_VERTEX_ATTRIB6_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->Eval.Map1Attrib[6]);
         break;
      case GL_MAP1_VERTEX_ATTRIB7_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->Eval.Map1Attrib[7]);
         break;
      case GL_MAP1_VERTEX_ATTRIB8_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->Eval.Map1Attrib[8]);
         break;
      case GL_MAP1_VERTEX_ATTRIB9_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->Eval.Map1Attrib[9]);
         break;
      case GL_MAP1_VERTEX_ATTRIB10_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->Eval.Map1Attrib[10]);
         break;
      case GL_MAP1_VERTEX_ATTRIB11_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->Eval.Map1Attrib[11]);
         break;
      case GL_MAP1_VERTEX_ATTRIB12_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->Eval.Map1Attrib[12]);
         break;
      case GL_MAP1_VERTEX_ATTRIB13_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->Eval.Map1Attrib[13]);
         break;
      case GL_MAP1_VERTEX_ATTRIB14_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->Eval.Map1Attrib[14]);
         break;
      case GL_MAP1_VERTEX_ATTRIB15_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->Eval.Map1Attrib[15]);
         break;
      case GL_FRAGMENT_PROGRAM_NV:
         CHECK_EXT1(NV_fragment_program, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->FragmentProgram.Enabled);
         break;
      case GL_FRAGMENT_PROGRAM_BINDING_NV:
         CHECK_EXT1(NV_fragment_program, "GetIntegerv");
         params[0] = ctx->FragmentProgram.Current ? ctx->FragmentProgram.Current->Base.Id : 0;
         break;
      case GL_MAX_FRAGMENT_PROGRAM_LOCAL_PARAMETERS_NV:
         CHECK_EXT1(NV_fragment_program, "GetIntegerv");
         params[0] = MAX_NV_FRAGMENT_PROGRAM_PARAMS;
         break;
      case GL_TEXTURE_RECTANGLE_NV:
         CHECK_EXT1(NV_texture_rectangle, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(_mesa_IsEnabled(GL_TEXTURE_RECTANGLE_NV));
         break;
      case GL_TEXTURE_BINDING_RECTANGLE_NV:
         CHECK_EXT1(NV_texture_rectangle, "GetIntegerv");
         params[0] = ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentTex[TEXTURE_RECT_INDEX]->Name;
         break;
      case GL_MAX_RECTANGLE_TEXTURE_SIZE_NV:
         CHECK_EXT1(NV_texture_rectangle, "GetIntegerv");
         params[0] = ctx->Const.MaxTextureRectSize;
         break;
      case GL_STENCIL_TEST_TWO_SIDE_EXT:
         CHECK_EXT1(EXT_stencil_two_side, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->Stencil.TestTwoSide);
         break;
      case GL_ACTIVE_STENCIL_FACE_EXT:
         CHECK_EXT1(EXT_stencil_two_side, "GetIntegerv");
         params[0] = ENUM_TO_INT(ctx->Stencil.ActiveFace ? GL_BACK : GL_FRONT);
         break;
      case GL_MAX_SHININESS_NV:
         CHECK_EXT1(NV_light_max_exponent, "GetIntegerv");
         params[0] = IROUND(ctx->Const.MaxShininess);
         break;
      case GL_MAX_SPOT_EXPONENT_NV:
         CHECK_EXT1(NV_light_max_exponent, "GetIntegerv");
         params[0] = IROUND(ctx->Const.MaxSpotExponent);
         break;
      case GL_ARRAY_BUFFER_BINDING_ARB:
         params[0] = ctx->Array.ArrayBufferObj->Name;
         break;
      case GL_VERTEX_ARRAY_BUFFER_BINDING_ARB:
         params[0] = ctx->Array.ArrayObj->Vertex.BufferObj->Name;
         break;
      case GL_NORMAL_ARRAY_BUFFER_BINDING_ARB:
         params[0] = ctx->Array.ArrayObj->Normal.BufferObj->Name;
         break;
      case GL_COLOR_ARRAY_BUFFER_BINDING_ARB:
         params[0] = ctx->Array.ArrayObj->Color.BufferObj->Name;
         break;
      case GL_INDEX_ARRAY_BUFFER_BINDING_ARB:
         params[0] = ctx->Array.ArrayObj->Index.BufferObj->Name;
         break;
      case GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING_ARB:
         params[0] = ctx->Array.ArrayObj->TexCoord[ctx->Array.ActiveTexture].BufferObj->Name;
         break;
      case GL_EDGE_FLAG_ARRAY_BUFFER_BINDING_ARB:
         params[0] = ctx->Array.ArrayObj->EdgeFlag.BufferObj->Name;
         break;
      case GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING_ARB:
         params[0] = ctx->Array.ArrayObj->SecondaryColor.BufferObj->Name;
         break;
      case GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING_ARB:
         params[0] = ctx->Array.ArrayObj->FogCoord.BufferObj->Name;
         break;
      case GL_ELEMENT_ARRAY_BUFFER_BINDING_ARB:
         params[0] = ctx->Array.ElementArrayBufferObj->Name;
         break;
      case GL_PIXEL_PACK_BUFFER_BINDING_EXT:
         CHECK_EXT1(EXT_pixel_buffer_object, "GetIntegerv");
         params[0] = ctx->Pack.BufferObj->Name;
         break;
      case GL_PIXEL_UNPACK_BUFFER_BINDING_EXT:
         CHECK_EXT1(EXT_pixel_buffer_object, "GetIntegerv");
         params[0] = ctx->Unpack.BufferObj->Name;
         break;
      case GL_VERTEX_PROGRAM_ARB:
         CHECK_EXT2(ARB_vertex_program, NV_vertex_program, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->VertexProgram.Enabled);
         break;
      case GL_VERTEX_PROGRAM_POINT_SIZE_ARB:
         CHECK_EXT2(ARB_vertex_program, NV_vertex_program, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->VertexProgram.PointSizeEnabled);
         break;
      case GL_VERTEX_PROGRAM_TWO_SIDE_ARB:
         CHECK_EXT2(ARB_vertex_program, NV_vertex_program, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->VertexProgram.TwoSideEnabled);
         break;
      case GL_MAX_PROGRAM_MATRIX_STACK_DEPTH_ARB:
         CHECK_EXT3(ARB_vertex_program, ARB_fragment_program, NV_vertex_program, "GetIntegerv");
         params[0] = ctx->Const.MaxProgramMatrixStackDepth;
         break;
      case GL_MAX_PROGRAM_MATRICES_ARB:
         CHECK_EXT3(ARB_vertex_program, ARB_fragment_program, NV_vertex_program, "GetIntegerv");
         params[0] = ctx->Const.MaxProgramMatrices;
         break;
      case GL_CURRENT_MATRIX_STACK_DEPTH_ARB:
         CHECK_EXT3(ARB_vertex_program, ARB_fragment_program, NV_vertex_program, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->CurrentStack->Depth + 1);
         break;
      case GL_CURRENT_MATRIX_ARB:
         CHECK_EXT3(ARB_vertex_program, ARB_fragment_program, NV_fragment_program, "GetIntegerv");
         {
         const GLfloat *matrix = ctx->CurrentStack->Top->m;
         params[0] = IROUND(matrix[0]);
         params[1] = IROUND(matrix[1]);
         params[2] = IROUND(matrix[2]);
         params[3] = IROUND(matrix[3]);
         params[4] = IROUND(matrix[4]);
         params[5] = IROUND(matrix[5]);
         params[6] = IROUND(matrix[6]);
         params[7] = IROUND(matrix[7]);
         params[8] = IROUND(matrix[8]);
         params[9] = IROUND(matrix[9]);
         params[10] = IROUND(matrix[10]);
         params[11] = IROUND(matrix[11]);
         params[12] = IROUND(matrix[12]);
         params[13] = IROUND(matrix[13]);
         params[14] = IROUND(matrix[14]);
         params[15] = IROUND(matrix[15]);
         }
         break;
      case GL_TRANSPOSE_CURRENT_MATRIX_ARB:
         CHECK_EXT2(ARB_vertex_program, ARB_fragment_program, "GetIntegerv");
         {
         const GLfloat *matrix = ctx->CurrentStack->Top->m;
         params[0] = IROUND(matrix[0]);
         params[1] = IROUND(matrix[4]);
         params[2] = IROUND(matrix[8]);
         params[3] = IROUND(matrix[12]);
         params[4] = IROUND(matrix[1]);
         params[5] = IROUND(matrix[5]);
         params[6] = IROUND(matrix[9]);
         params[7] = IROUND(matrix[13]);
         params[8] = IROUND(matrix[2]);
         params[9] = IROUND(matrix[6]);
         params[10] = IROUND(matrix[10]);
         params[11] = IROUND(matrix[14]);
         params[12] = IROUND(matrix[3]);
         params[13] = IROUND(matrix[7]);
         params[14] = IROUND(matrix[11]);
         params[15] = IROUND(matrix[15]);
         }
         break;
      case GL_MAX_VERTEX_ATTRIBS_ARB:
         CHECK_EXT1(ARB_vertex_program, "GetIntegerv");
         params[0] = ctx->Const.VertexProgram.MaxAttribs;
         break;
      case GL_PROGRAM_ERROR_POSITION_ARB:
         CHECK_EXT4(NV_vertex_program, ARB_vertex_program, NV_fragment_program, ARB_fragment_program, "GetIntegerv");
         params[0] = ctx->Program.ErrorPos;
         break;
      case GL_FRAGMENT_PROGRAM_ARB:
         CHECK_EXT1(ARB_fragment_program, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->FragmentProgram.Enabled);
         break;
      case GL_MAX_TEXTURE_COORDS_ARB:
         CHECK_EXT2(ARB_fragment_program, NV_fragment_program, "GetIntegerv");
         params[0] = ctx->Const.MaxTextureCoordUnits;
         break;
      case GL_MAX_TEXTURE_IMAGE_UNITS_ARB:
         CHECK_EXT2(ARB_fragment_program, NV_fragment_program, "GetIntegerv");
         params[0] = ctx->Const.MaxTextureImageUnits;
         break;
      case GL_DEPTH_BOUNDS_TEST_EXT:
         CHECK_EXT1(EXT_depth_bounds_test, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->Depth.BoundsTest);
         break;
      case GL_DEPTH_BOUNDS_EXT:
         CHECK_EXT1(EXT_depth_bounds_test, "GetIntegerv");
         params[0] = IROUND(ctx->Depth.BoundsMin);
         params[1] = IROUND(ctx->Depth.BoundsMax);
         break;
      case GL_DEPTH_CLAMP:
         CHECK_EXT1(ARB_depth_clamp, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->Transform.DepthClamp);
         break;
      case GL_MAX_DRAW_BUFFERS_ARB:
         params[0] = ctx->Const.MaxDrawBuffers;
         break;
      case GL_DRAW_BUFFER0_ARB:
         params[0] = ENUM_TO_INT(ctx->DrawBuffer->ColorDrawBuffer[0]);
         break;
      case GL_DRAW_BUFFER1_ARB:
         {
         GLenum buffer;
         if (pname - GL_DRAW_BUFFER0_ARB >= ctx->Const.MaxDrawBuffers) {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGet(GL_DRAW_BUFFERx_ARB)");
            return;
         }
         buffer = ctx->DrawBuffer->ColorDrawBuffer[1];
         params[0] = ENUM_TO_INT(buffer);
         }
         break;
      case GL_DRAW_BUFFER2_ARB:
         {
         GLenum buffer;
         if (pname - GL_DRAW_BUFFER0_ARB >= ctx->Const.MaxDrawBuffers) {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGet(GL_DRAW_BUFFERx_ARB)");
            return;
         }
         buffer = ctx->DrawBuffer->ColorDrawBuffer[2];
         params[0] = ENUM_TO_INT(buffer);
         }
         break;
      case GL_DRAW_BUFFER3_ARB:
         {
         GLenum buffer;
         if (pname - GL_DRAW_BUFFER0_ARB >= ctx->Const.MaxDrawBuffers) {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGet(GL_DRAW_BUFFERx_ARB)");
            return;
         }
         buffer = ctx->DrawBuffer->ColorDrawBuffer[3];
         params[0] = ENUM_TO_INT(buffer);
         }
         break;
      case GL_IMPLEMENTATION_COLOR_READ_TYPE_OES:
         CHECK_EXT1(OES_read_format, "GetIntegerv");
         params[0] = _mesa_get_color_read_type(ctx);
         break;
      case GL_IMPLEMENTATION_COLOR_READ_FORMAT_OES:
         CHECK_EXT1(OES_read_format, "GetIntegerv");
         params[0] = _mesa_get_color_read_format(ctx);
         break;
      case GL_NUM_FRAGMENT_REGISTERS_ATI:
         CHECK_EXT1(ATI_fragment_shader, "GetIntegerv");
         params[0] = 6;
         break;
      case GL_NUM_FRAGMENT_CONSTANTS_ATI:
         CHECK_EXT1(ATI_fragment_shader, "GetIntegerv");
         params[0] = 8;
         break;
      case GL_NUM_PASSES_ATI:
         CHECK_EXT1(ATI_fragment_shader, "GetIntegerv");
         params[0] = 2;
         break;
      case GL_NUM_INSTRUCTIONS_PER_PASS_ATI:
         CHECK_EXT1(ATI_fragment_shader, "GetIntegerv");
         params[0] = 8;
         break;
      case GL_NUM_INSTRUCTIONS_TOTAL_ATI:
         CHECK_EXT1(ATI_fragment_shader, "GetIntegerv");
         params[0] = 16;
         break;
      case GL_COLOR_ALPHA_PAIRING_ATI:
         CHECK_EXT1(ATI_fragment_shader, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(GL_TRUE);
         break;
      case GL_NUM_LOOPBACK_COMPONENTS_ATI:
         CHECK_EXT1(ATI_fragment_shader, "GetIntegerv");
         params[0] = 3;
         break;
      case GL_NUM_INPUT_INTERPOLATOR_COMPONENTS_ATI:
         CHECK_EXT1(ATI_fragment_shader, "GetIntegerv");
         params[0] = 3;
         break;
      case GL_STENCIL_BACK_FUNC:
         params[0] = ENUM_TO_INT(ctx->Stencil.Function[1]);
         break;
      case GL_STENCIL_BACK_VALUE_MASK:
         params[0] = ctx->Stencil.ValueMask[1];
         break;
      case GL_STENCIL_BACK_WRITEMASK:
         params[0] = ctx->Stencil.WriteMask[1];
         break;
      case GL_STENCIL_BACK_REF:
         params[0] = ctx->Stencil.Ref[1];
         break;
      case GL_STENCIL_BACK_FAIL:
         params[0] = ENUM_TO_INT(ctx->Stencil.FailFunc[1]);
         break;
      case GL_STENCIL_BACK_PASS_DEPTH_FAIL:
         params[0] = ENUM_TO_INT(ctx->Stencil.ZFailFunc[1]);
         break;
      case GL_STENCIL_BACK_PASS_DEPTH_PASS:
         params[0] = ENUM_TO_INT(ctx->Stencil.ZPassFunc[1]);
         break;
      case GL_FRAMEBUFFER_BINDING_EXT:
         CHECK_EXT1(EXT_framebuffer_object, "GetIntegerv");
         params[0] = ctx->DrawBuffer->Name;
         break;
      case GL_RENDERBUFFER_BINDING_EXT:
         CHECK_EXT1(EXT_framebuffer_object, "GetIntegerv");
         params[0] = ctx->CurrentRenderbuffer ? ctx->CurrentRenderbuffer->Name : 0;
         break;
      case GL_MAX_COLOR_ATTACHMENTS_EXT:
         CHECK_EXT1(EXT_framebuffer_object, "GetIntegerv");
         params[0] = ctx->Const.MaxColorAttachments;
         break;
      case GL_MAX_RENDERBUFFER_SIZE_EXT:
         CHECK_EXT1(EXT_framebuffer_object, "GetIntegerv");
         params[0] = ctx->Const.MaxRenderbufferSize;
         break;
      case GL_READ_FRAMEBUFFER_BINDING_EXT:
         CHECK_EXT1(EXT_framebuffer_blit, "GetIntegerv");
         params[0] = ctx->ReadBuffer->Name;
         break;
      case GL_PROVOKING_VERTEX_EXT:
         CHECK_EXT1(EXT_provoking_vertex, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->Light.ProvokingVertex);
         break;
      case GL_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION_EXT:
         CHECK_EXT1(EXT_provoking_vertex, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->Const.QuadsFollowProvokingVertexConvention);
         break;
      case GL_MAX_FRAGMENT_UNIFORM_COMPONENTS_ARB:
         CHECK_EXT1(ARB_fragment_shader, "GetIntegerv");
         params[0] = ctx->Const.FragmentProgram.MaxUniformComponents;
         break;
      case GL_FRAGMENT_SHADER_DERIVATIVE_HINT_ARB:
         CHECK_EXT1(ARB_fragment_shader, "GetIntegerv");
         params[0] = ENUM_TO_INT(ctx->Hint.FragmentShaderDerivative);
         break;
      case GL_MAX_VERTEX_UNIFORM_COMPONENTS_ARB:
         CHECK_EXT1(ARB_vertex_shader, "GetIntegerv");
         params[0] = ctx->Const.VertexProgram.MaxUniformComponents;
         break;
      case GL_MAX_VARYING_FLOATS_ARB:
         CHECK_EXT1(ARB_vertex_shader, "GetIntegerv");
         params[0] = ctx->Const.MaxVarying * 4;
         break;
      case GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS_ARB:
         CHECK_EXT1(ARB_vertex_shader, "GetIntegerv");
         params[0] = ctx->Const.MaxVertexTextureImageUnits;
         break;
      case GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS_ARB:
         CHECK_EXT1(ARB_vertex_shader, "GetIntegerv");
         params[0] = ctx->Const.MaxCombinedTextureImageUnits;
         break;
      case GL_CURRENT_PROGRAM:
         CHECK_EXT1(ARB_shader_objects, "GetIntegerv");
         params[0] = ctx->Shader.CurrentProgram ? ctx->Shader.CurrentProgram->Name : 0;
         break;
      case GL_MAX_SAMPLES:
         CHECK_EXT1(ARB_framebuffer_object, "GetIntegerv");
         params[0] = ctx->Const.MaxSamples;
         break;
      case GL_VERTEX_ARRAY_BINDING_APPLE:
         CHECK_EXT1(APPLE_vertex_array_object, "GetIntegerv");
         params[0] = ctx->Array.ArrayObj->Name;
         break;
      case GL_TEXTURE_CUBE_MAP_SEAMLESS:
         CHECK_EXT1(ARB_seamless_cube_map, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->Texture.CubeMapSeamless);
         break;
      case GL_MAX_SERVER_WAIT_TIMEOUT:
         CHECK_EXT1(ARB_sync, "GetIntegerv");
         params[0] = INT64_TO_INT(ctx->Const.MaxServerWaitTimeout);
         break;
      case GL_NUM_EXTENSIONS:
         params[0] = _mesa_get_extension_count(ctx);
         break;
      case GL_MAJOR_VERSION:
         params[0] = ctx->VersionMajor;
         break;
      case GL_MINOR_VERSION:
         params[0] = ctx->VersionMinor;
         break;
      default:
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetIntegerv(pname=0x%x)", pname);
d2084 1
a2084 1
_mesa_GetInteger64v( GLenum pname, GLint64 *params )
d2086 84
a2169 1863
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   if (!params)
      return;

   if (ctx->NewState)
      _mesa_update_state(ctx);

   if (ctx->Driver.GetInteger64v &&
       ctx->Driver.GetInteger64v(ctx, pname, params))
      return;

   switch (pname) {
      case GL_ACCUM_RED_BITS:
         params[0] = (GLint64)(ctx->DrawBuffer->Visual.accumRedBits);
         break;
      case GL_ACCUM_GREEN_BITS:
         params[0] = (GLint64)(ctx->DrawBuffer->Visual.accumGreenBits);
         break;
      case GL_ACCUM_BLUE_BITS:
         params[0] = (GLint64)(ctx->DrawBuffer->Visual.accumBlueBits);
         break;
      case GL_ACCUM_ALPHA_BITS:
         params[0] = (GLint64)(ctx->DrawBuffer->Visual.accumAlphaBits);
         break;
      case GL_ACCUM_CLEAR_VALUE:
         params[0] = FLOAT_TO_INT64(ctx->Accum.ClearColor[0]);
         params[1] = FLOAT_TO_INT64(ctx->Accum.ClearColor[1]);
         params[2] = FLOAT_TO_INT64(ctx->Accum.ClearColor[2]);
         params[3] = FLOAT_TO_INT64(ctx->Accum.ClearColor[3]);
         break;
      case GL_ALPHA_BIAS:
         params[0] = IROUND64(ctx->Pixel.AlphaBias);
         break;
      case GL_ALPHA_BITS:
         params[0] = (GLint64)(ctx->DrawBuffer->Visual.alphaBits);
         break;
      case GL_ALPHA_SCALE:
         params[0] = IROUND64(ctx->Pixel.AlphaScale);
         break;
      case GL_ALPHA_TEST:
         params[0] = BOOLEAN_TO_INT64(ctx->Color.AlphaEnabled);
         break;
      case GL_ALPHA_TEST_FUNC:
         params[0] = ENUM_TO_INT64(ctx->Color.AlphaFunc);
         break;
      case GL_ALPHA_TEST_REF:
         params[0] = FLOAT_TO_INT64(ctx->Color.AlphaRef);
         break;
      case GL_ATTRIB_STACK_DEPTH:
         params[0] = (GLint64)(ctx->AttribStackDepth);
         break;
      case GL_AUTO_NORMAL:
         params[0] = BOOLEAN_TO_INT64(ctx->Eval.AutoNormal);
         break;
      case GL_AUX_BUFFERS:
         params[0] = (GLint64)(ctx->DrawBuffer->Visual.numAuxBuffers);
         break;
      case GL_BLEND:
         params[0] = BOOLEAN_TO_INT64((ctx->Color.BlendEnabled & 1));
         break;
      case GL_BLEND_DST:
         params[0] = ENUM_TO_INT64(ctx->Color.BlendDstRGB);
         break;
      case GL_BLEND_SRC:
         params[0] = ENUM_TO_INT64(ctx->Color.BlendSrcRGB);
         break;
      case GL_BLEND_SRC_RGB_EXT:
         params[0] = ENUM_TO_INT64(ctx->Color.BlendSrcRGB);
         break;
      case GL_BLEND_DST_RGB_EXT:
         params[0] = ENUM_TO_INT64(ctx->Color.BlendDstRGB);
         break;
      case GL_BLEND_SRC_ALPHA_EXT:
         params[0] = ENUM_TO_INT64(ctx->Color.BlendSrcA);
         break;
      case GL_BLEND_DST_ALPHA_EXT:
         params[0] = ENUM_TO_INT64(ctx->Color.BlendDstA);
         break;
      case GL_BLEND_EQUATION:
         params[0] = ENUM_TO_INT64(ctx->Color.BlendEquationRGB );
         break;
      case GL_BLEND_EQUATION_ALPHA_EXT:
         params[0] = ENUM_TO_INT64(ctx->Color.BlendEquationA );
         break;
      case GL_BLEND_COLOR_EXT:
         params[0] = FLOAT_TO_INT64(ctx->Color.BlendColor[0]);
         params[1] = FLOAT_TO_INT64(ctx->Color.BlendColor[1]);
         params[2] = FLOAT_TO_INT64(ctx->Color.BlendColor[2]);
         params[3] = FLOAT_TO_INT64(ctx->Color.BlendColor[3]);
         break;
      case GL_BLUE_BIAS:
         params[0] = IROUND64(ctx->Pixel.BlueBias);
         break;
      case GL_BLUE_BITS:
         params[0] = (GLint64)(ctx->DrawBuffer->Visual.blueBits);
         break;
      case GL_BLUE_SCALE:
         params[0] = IROUND64(ctx->Pixel.BlueScale);
         break;
      case GL_CLIENT_ATTRIB_STACK_DEPTH:
         params[0] = (GLint64)(ctx->ClientAttribStackDepth);
         break;
      case GL_CLIP_PLANE0:
         params[0] = BOOLEAN_TO_INT64((ctx->Transform.ClipPlanesEnabled >> 0) & 1);
         break;
      case GL_CLIP_PLANE1:
         params[0] = BOOLEAN_TO_INT64((ctx->Transform.ClipPlanesEnabled >> 1) & 1);
         break;
      case GL_CLIP_PLANE2:
         params[0] = BOOLEAN_TO_INT64((ctx->Transform.ClipPlanesEnabled >> 2) & 1);
         break;
      case GL_CLIP_PLANE3:
         params[0] = BOOLEAN_TO_INT64((ctx->Transform.ClipPlanesEnabled >> 3) & 1);
         break;
      case GL_CLIP_PLANE4:
         params[0] = BOOLEAN_TO_INT64((ctx->Transform.ClipPlanesEnabled >> 4) & 1);
         break;
      case GL_CLIP_PLANE5:
         params[0] = BOOLEAN_TO_INT64((ctx->Transform.ClipPlanesEnabled >> 5) & 1);
         break;
      case GL_COLOR_CLEAR_VALUE:
         params[0] = FLOAT_TO_INT64(ctx->Color.ClearColor[0]);
         params[1] = FLOAT_TO_INT64(ctx->Color.ClearColor[1]);
         params[2] = FLOAT_TO_INT64(ctx->Color.ClearColor[2]);
         params[3] = FLOAT_TO_INT64(ctx->Color.ClearColor[3]);
         break;
      case GL_COLOR_MATERIAL:
         params[0] = BOOLEAN_TO_INT64(ctx->Light.ColorMaterialEnabled);
         break;
      case GL_COLOR_MATERIAL_FACE:
         params[0] = ENUM_TO_INT64(ctx->Light.ColorMaterialFace);
         break;
      case GL_COLOR_MATERIAL_PARAMETER:
         params[0] = ENUM_TO_INT64(ctx->Light.ColorMaterialMode);
         break;
      case GL_COLOR_WRITEMASK:
         params[0] = (GLint64)(ctx->Color.ColorMask[0][RCOMP] ? 1 : 0);
         params[1] = (GLint64)(ctx->Color.ColorMask[0][GCOMP] ? 1 : 0);
         params[2] = (GLint64)(ctx->Color.ColorMask[0][BCOMP] ? 1 : 0);
         params[3] = (GLint64)(ctx->Color.ColorMask[0][ACOMP] ? 1 : 0);
         break;
      case GL_CULL_FACE:
         params[0] = BOOLEAN_TO_INT64(ctx->Polygon.CullFlag);
         break;
      case GL_CULL_FACE_MODE:
         params[0] = ENUM_TO_INT64(ctx->Polygon.CullFaceMode);
         break;
      case GL_CURRENT_COLOR:
         {
         FLUSH_CURRENT(ctx, 0);
         params[0] = FLOAT_TO_INT64(ctx->Current.Attrib[VERT_ATTRIB_COLOR0][0]);
         params[1] = FLOAT_TO_INT64(ctx->Current.Attrib[VERT_ATTRIB_COLOR0][1]);
         params[2] = FLOAT_TO_INT64(ctx->Current.Attrib[VERT_ATTRIB_COLOR0][2]);
         params[3] = FLOAT_TO_INT64(ctx->Current.Attrib[VERT_ATTRIB_COLOR0][3]);
         }
         break;
      case GL_CURRENT_INDEX:
         {
         FLUSH_CURRENT(ctx, 0);
         params[0] = IROUND64(ctx->Current.Attrib[VERT_ATTRIB_COLOR_INDEX][0]);
         }
         break;
      case GL_CURRENT_NORMAL:
         {
         FLUSH_CURRENT(ctx, 0);
         params[0] = FLOAT_TO_INT64(ctx->Current.Attrib[VERT_ATTRIB_NORMAL][0]);
         params[1] = FLOAT_TO_INT64(ctx->Current.Attrib[VERT_ATTRIB_NORMAL][1]);
         params[2] = FLOAT_TO_INT64(ctx->Current.Attrib[VERT_ATTRIB_NORMAL][2]);
         }
         break;
      case GL_CURRENT_RASTER_COLOR:
         params[0] = FLOAT_TO_INT64(ctx->Current.RasterColor[0]);
         params[1] = FLOAT_TO_INT64(ctx->Current.RasterColor[1]);
         params[2] = FLOAT_TO_INT64(ctx->Current.RasterColor[2]);
         params[3] = FLOAT_TO_INT64(ctx->Current.RasterColor[3]);
         break;
      case GL_CURRENT_RASTER_DISTANCE:
         params[0] = IROUND64(ctx->Current.RasterDistance);
         break;
      case GL_CURRENT_RASTER_INDEX:
         params[0] = IROUND64(1.0);
         break;
      case GL_CURRENT_RASTER_POSITION:
         params[0] = IROUND64(ctx->Current.RasterPos[0]);
         params[1] = IROUND64(ctx->Current.RasterPos[1]);
         params[2] = IROUND64(ctx->Current.RasterPos[2]);
         params[3] = IROUND64(ctx->Current.RasterPos[3]);
         break;
      case GL_CURRENT_RASTER_SECONDARY_COLOR:
         params[0] = FLOAT_TO_INT64(ctx->Current.RasterSecondaryColor[0]);
         params[1] = FLOAT_TO_INT64(ctx->Current.RasterSecondaryColor[1]);
         params[2] = FLOAT_TO_INT64(ctx->Current.RasterSecondaryColor[2]);
         params[3] = FLOAT_TO_INT64(ctx->Current.RasterSecondaryColor[3]);
         break;
      case GL_CURRENT_RASTER_TEXTURE_COORDS:
         {
         const GLuint unit = ctx->Texture.CurrentUnit;
         if (unit >= ctx->Const.MaxTextureCoordUnits) {
            _mesa_error(ctx, GL_INVALID_OPERATION,
                        "glGet(raster tex coords, unit %u)", unit);
            return;
         }
         params[0] = IROUND64(ctx->Current.RasterTexCoords[unit][0]);
         params[1] = IROUND64(ctx->Current.RasterTexCoords[unit][1]);
         params[2] = IROUND64(ctx->Current.RasterTexCoords[unit][2]);
         params[3] = IROUND64(ctx->Current.RasterTexCoords[unit][3]);
         }
         break;
      case GL_CURRENT_RASTER_POSITION_VALID:
         params[0] = BOOLEAN_TO_INT64(ctx->Current.RasterPosValid);
         break;
      case GL_CURRENT_TEXTURE_COORDS:
         {
         const GLuint unit = ctx->Texture.CurrentUnit;
         if (unit >= ctx->Const.MaxTextureCoordUnits) {
            _mesa_error(ctx, GL_INVALID_OPERATION,
                        "glGet(current tex coords, unit %u)", unit);
            return;
         }
         FLUSH_CURRENT(ctx, 0);
         params[0] = IROUND64(ctx->Current.Attrib[VERT_ATTRIB_TEX0 + unit][0]);
         params[1] = IROUND64(ctx->Current.Attrib[VERT_ATTRIB_TEX0 + unit][1]);
         params[2] = IROUND64(ctx->Current.Attrib[VERT_ATTRIB_TEX0 + unit][2]);
         params[3] = IROUND64(ctx->Current.Attrib[VERT_ATTRIB_TEX0 + unit][3]);
         }
         break;
      case GL_DEPTH_BIAS:
         params[0] = IROUND64(ctx->Pixel.DepthBias);
         break;
      case GL_DEPTH_BITS:
         params[0] = (GLint64)(ctx->DrawBuffer->Visual.depthBits);
         break;
      case GL_DEPTH_CLEAR_VALUE:
         params[0] = FLOAT_TO_INT64(((GLfloat) ctx->Depth.Clear));
         break;
      case GL_DEPTH_FUNC:
         params[0] = ENUM_TO_INT64(ctx->Depth.Func);
         break;
      case GL_DEPTH_RANGE:
         params[0] = FLOAT_TO_INT64(ctx->Viewport.Near);
         params[1] = FLOAT_TO_INT64(ctx->Viewport.Far);
         break;
      case GL_DEPTH_SCALE:
         params[0] = IROUND64(ctx->Pixel.DepthScale);
         break;
      case GL_DEPTH_TEST:
         params[0] = BOOLEAN_TO_INT64(ctx->Depth.Test);
         break;
      case GL_DEPTH_WRITEMASK:
         params[0] = BOOLEAN_TO_INT64(ctx->Depth.Mask);
         break;
      case GL_DITHER:
         params[0] = BOOLEAN_TO_INT64(ctx->Color.DitherFlag);
         break;
      case GL_DOUBLEBUFFER:
         params[0] = BOOLEAN_TO_INT64(ctx->DrawBuffer->Visual.doubleBufferMode);
         break;
      case GL_DRAW_BUFFER:
         params[0] = ENUM_TO_INT64(ctx->DrawBuffer->ColorDrawBuffer[0]);
         break;
      case GL_EDGE_FLAG:
         {
         FLUSH_CURRENT(ctx, 0);
         params[0] = BOOLEAN_TO_INT64((ctx->Current.Attrib[VERT_ATTRIB_EDGEFLAG][0] == 1.0));
         }
         break;
      case GL_FEEDBACK_BUFFER_SIZE:
         params[0] = (GLint64)(ctx->Feedback.BufferSize);
         break;
      case GL_FEEDBACK_BUFFER_TYPE:
         params[0] = ENUM_TO_INT64(ctx->Feedback.Type);
         break;
      case GL_FOG:
         params[0] = BOOLEAN_TO_INT64(ctx->Fog.Enabled);
         break;
      case GL_FOG_COLOR:
         params[0] = FLOAT_TO_INT64(ctx->Fog.Color[0]);
         params[1] = FLOAT_TO_INT64(ctx->Fog.Color[1]);
         params[2] = FLOAT_TO_INT64(ctx->Fog.Color[2]);
         params[3] = FLOAT_TO_INT64(ctx->Fog.Color[3]);
         break;
      case GL_FOG_DENSITY:
         params[0] = IROUND64(ctx->Fog.Density);
         break;
      case GL_FOG_END:
         params[0] = IROUND64(ctx->Fog.End);
         break;
      case GL_FOG_HINT:
         params[0] = ENUM_TO_INT64(ctx->Hint.Fog);
         break;
      case GL_FOG_INDEX:
         params[0] = IROUND64(ctx->Fog.Index);
         break;
      case GL_FOG_MODE:
         params[0] = ENUM_TO_INT64(ctx->Fog.Mode);
         break;
      case GL_FOG_START:
         params[0] = IROUND64(ctx->Fog.Start);
         break;
      case GL_FRONT_FACE:
         params[0] = ENUM_TO_INT64(ctx->Polygon.FrontFace);
         break;
      case GL_GREEN_BIAS:
         params[0] = IROUND64(ctx->Pixel.GreenBias);
         break;
      case GL_GREEN_BITS:
         params[0] = (GLint64)(ctx->DrawBuffer->Visual.greenBits);
         break;
      case GL_GREEN_SCALE:
         params[0] = IROUND64(ctx->Pixel.GreenScale);
         break;
      case GL_INDEX_BITS:
         params[0] = (GLint64)(ctx->DrawBuffer->Visual.indexBits);
         break;
      case GL_INDEX_CLEAR_VALUE:
         params[0] = (GLint64)(ctx->Color.ClearIndex);
         break;
      case GL_INDEX_MODE:
         params[0] = BOOLEAN_TO_INT64(GL_FALSE);
         break;
      case GL_INDEX_OFFSET:
         params[0] = (GLint64)(ctx->Pixel.IndexOffset);
         break;
      case GL_INDEX_SHIFT:
         params[0] = (GLint64)(ctx->Pixel.IndexShift);
         break;
      case GL_INDEX_WRITEMASK:
         params[0] = (GLint64)(ctx->Color.IndexMask);
         break;
      case GL_LIGHT0:
         params[0] = BOOLEAN_TO_INT64(ctx->Light.Light[0].Enabled);
         break;
      case GL_LIGHT1:
         params[0] = BOOLEAN_TO_INT64(ctx->Light.Light[1].Enabled);
         break;
      case GL_LIGHT2:
         params[0] = BOOLEAN_TO_INT64(ctx->Light.Light[2].Enabled);
         break;
      case GL_LIGHT3:
         params[0] = BOOLEAN_TO_INT64(ctx->Light.Light[3].Enabled);
         break;
      case GL_LIGHT4:
         params[0] = BOOLEAN_TO_INT64(ctx->Light.Light[4].Enabled);
         break;
      case GL_LIGHT5:
         params[0] = BOOLEAN_TO_INT64(ctx->Light.Light[5].Enabled);
         break;
      case GL_LIGHT6:
         params[0] = BOOLEAN_TO_INT64(ctx->Light.Light[6].Enabled);
         break;
      case GL_LIGHT7:
         params[0] = BOOLEAN_TO_INT64(ctx->Light.Light[7].Enabled);
         break;
      case GL_LIGHTING:
         params[0] = BOOLEAN_TO_INT64(ctx->Light.Enabled);
         break;
      case GL_LIGHT_MODEL_AMBIENT:
         params[0] = FLOAT_TO_INT64(ctx->Light.Model.Ambient[0]);
         params[1] = FLOAT_TO_INT64(ctx->Light.Model.Ambient[1]);
         params[2] = FLOAT_TO_INT64(ctx->Light.Model.Ambient[2]);
         params[3] = FLOAT_TO_INT64(ctx->Light.Model.Ambient[3]);
         break;
      case GL_LIGHT_MODEL_COLOR_CONTROL:
         params[0] = ENUM_TO_INT64(ctx->Light.Model.ColorControl);
         break;
      case GL_LIGHT_MODEL_LOCAL_VIEWER:
         params[0] = BOOLEAN_TO_INT64(ctx->Light.Model.LocalViewer);
         break;
      case GL_LIGHT_MODEL_TWO_SIDE:
         params[0] = BOOLEAN_TO_INT64(ctx->Light.Model.TwoSide);
         break;
      case GL_LINE_SMOOTH:
         params[0] = BOOLEAN_TO_INT64(ctx->Line.SmoothFlag);
         break;
      case GL_LINE_SMOOTH_HINT:
         params[0] = ENUM_TO_INT64(ctx->Hint.LineSmooth);
         break;
      case GL_LINE_STIPPLE:
         params[0] = BOOLEAN_TO_INT64(ctx->Line.StippleFlag);
         break;
      case GL_LINE_STIPPLE_PATTERN:
         params[0] = (GLint64)(ctx->Line.StipplePattern);
         break;
      case GL_LINE_STIPPLE_REPEAT:
         params[0] = (GLint64)(ctx->Line.StippleFactor);
         break;
      case GL_LINE_WIDTH:
         params[0] = IROUND64(ctx->Line.Width);
         break;
      case GL_LINE_WIDTH_GRANULARITY:
         params[0] = IROUND64(ctx->Const.LineWidthGranularity);
         break;
      case GL_LINE_WIDTH_RANGE:
         params[0] = IROUND64(ctx->Const.MinLineWidthAA);
         params[1] = IROUND64(ctx->Const.MaxLineWidthAA);
         break;
      case GL_ALIASED_LINE_WIDTH_RANGE:
         params[0] = IROUND64(ctx->Const.MinLineWidth);
         params[1] = IROUND64(ctx->Const.MaxLineWidth);
         break;
      case GL_LIST_BASE:
         params[0] = (GLint64)(ctx->List.ListBase);
         break;
      case GL_LIST_INDEX:
         params[0] = (GLint64)((ctx->ListState.CurrentList ? ctx->ListState.CurrentList->Name : 0));
         break;
      case GL_LIST_MODE:
         {
         GLenum mode;
         if (!ctx->CompileFlag)
            mode = 0;
         else if (ctx->ExecuteFlag)
            mode = GL_COMPILE_AND_EXECUTE;
         else
            mode = GL_COMPILE;
         params[0] = ENUM_TO_INT64(mode);
         }
         break;
      case GL_INDEX_LOGIC_OP:
         params[0] = BOOLEAN_TO_INT64(ctx->Color.IndexLogicOpEnabled);
         break;
      case GL_COLOR_LOGIC_OP:
         params[0] = BOOLEAN_TO_INT64(ctx->Color.ColorLogicOpEnabled);
         break;
      case GL_LOGIC_OP_MODE:
         params[0] = ENUM_TO_INT64(ctx->Color.LogicOp);
         break;
      case GL_MAP1_COLOR_4:
         params[0] = BOOLEAN_TO_INT64(ctx->Eval.Map1Color4);
         break;
      case GL_MAP1_GRID_DOMAIN:
         params[0] = IROUND64(ctx->Eval.MapGrid1u1);
         params[1] = IROUND64(ctx->Eval.MapGrid1u2);
         break;
      case GL_MAP1_GRID_SEGMENTS:
         params[0] = (GLint64)(ctx->Eval.MapGrid1un);
         break;
      case GL_MAP1_INDEX:
         params[0] = BOOLEAN_TO_INT64(ctx->Eval.Map1Index);
         break;
      case GL_MAP1_NORMAL:
         params[0] = BOOLEAN_TO_INT64(ctx->Eval.Map1Normal);
         break;
      case GL_MAP1_TEXTURE_COORD_1:
         params[0] = BOOLEAN_TO_INT64(ctx->Eval.Map1TextureCoord1);
         break;
      case GL_MAP1_TEXTURE_COORD_2:
         params[0] = BOOLEAN_TO_INT64(ctx->Eval.Map1TextureCoord2);
         break;
      case GL_MAP1_TEXTURE_COORD_3:
         params[0] = BOOLEAN_TO_INT64(ctx->Eval.Map1TextureCoord3);
         break;
      case GL_MAP1_TEXTURE_COORD_4:
         params[0] = BOOLEAN_TO_INT64(ctx->Eval.Map1TextureCoord4);
         break;
      case GL_MAP1_VERTEX_3:
         params[0] = BOOLEAN_TO_INT64(ctx->Eval.Map1Vertex3);
         break;
      case GL_MAP1_VERTEX_4:
         params[0] = BOOLEAN_TO_INT64(ctx->Eval.Map1Vertex4);
         break;
      case GL_MAP2_COLOR_4:
         params[0] = BOOLEAN_TO_INT64(ctx->Eval.Map2Color4);
         break;
      case GL_MAP2_GRID_DOMAIN:
         params[0] = IROUND64(ctx->Eval.MapGrid2u1);
         params[1] = IROUND64(ctx->Eval.MapGrid2u2);
         params[2] = IROUND64(ctx->Eval.MapGrid2v1);
         params[3] = IROUND64(ctx->Eval.MapGrid2v2);
         break;
      case GL_MAP2_GRID_SEGMENTS:
         params[0] = (GLint64)(ctx->Eval.MapGrid2un);
         params[1] = (GLint64)(ctx->Eval.MapGrid2vn);
         break;
      case GL_MAP2_INDEX:
         params[0] = BOOLEAN_TO_INT64(ctx->Eval.Map2Index);
         break;
      case GL_MAP2_NORMAL:
         params[0] = BOOLEAN_TO_INT64(ctx->Eval.Map2Normal);
         break;
      case GL_MAP2_TEXTURE_COORD_1:
         params[0] = BOOLEAN_TO_INT64(ctx->Eval.Map2TextureCoord1);
         break;
      case GL_MAP2_TEXTURE_COORD_2:
         params[0] = BOOLEAN_TO_INT64(ctx->Eval.Map2TextureCoord2);
         break;
      case GL_MAP2_TEXTURE_COORD_3:
         params[0] = BOOLEAN_TO_INT64(ctx->Eval.Map2TextureCoord3);
         break;
      case GL_MAP2_TEXTURE_COORD_4:
         params[0] = BOOLEAN_TO_INT64(ctx->Eval.Map2TextureCoord4);
         break;
      case GL_MAP2_VERTEX_3:
         params[0] = BOOLEAN_TO_INT64(ctx->Eval.Map2Vertex3);
         break;
      case GL_MAP2_VERTEX_4:
         params[0] = BOOLEAN_TO_INT64(ctx->Eval.Map2Vertex4);
         break;
      case GL_MAP_COLOR:
         params[0] = BOOLEAN_TO_INT64(ctx->Pixel.MapColorFlag);
         break;
      case GL_MAP_STENCIL:
         params[0] = BOOLEAN_TO_INT64(ctx->Pixel.MapStencilFlag);
         break;
      case GL_MATRIX_MODE:
         params[0] = ENUM_TO_INT64(ctx->Transform.MatrixMode);
         break;
      case GL_MAX_ATTRIB_STACK_DEPTH:
         params[0] = (GLint64)(MAX_ATTRIB_STACK_DEPTH);
         break;
      case GL_MAX_CLIENT_ATTRIB_STACK_DEPTH:
         params[0] = (GLint64)(MAX_CLIENT_ATTRIB_STACK_DEPTH);
         break;
      case GL_MAX_CLIP_PLANES:
         params[0] = (GLint64)(ctx->Const.MaxClipPlanes);
         break;
      case GL_MAX_ELEMENTS_VERTICES:
         params[0] = (GLint64)(ctx->Const.MaxArrayLockSize);
         break;
      case GL_MAX_ELEMENTS_INDICES:
         params[0] = (GLint64)(ctx->Const.MaxArrayLockSize);
         break;
      case GL_MAX_EVAL_ORDER:
         params[0] = (GLint64)(MAX_EVAL_ORDER);
         break;
      case GL_MAX_LIGHTS:
         params[0] = (GLint64)(ctx->Const.MaxLights);
         break;
      case GL_MAX_LIST_NESTING:
         params[0] = (GLint64)(MAX_LIST_NESTING);
         break;
      case GL_MAX_MODELVIEW_STACK_DEPTH:
         params[0] = (GLint64)(MAX_MODELVIEW_STACK_DEPTH);
         break;
      case GL_MAX_NAME_STACK_DEPTH:
         params[0] = (GLint64)(MAX_NAME_STACK_DEPTH);
         break;
      case GL_MAX_PIXEL_MAP_TABLE:
         params[0] = (GLint64)(MAX_PIXEL_MAP_TABLE);
         break;
      case GL_MAX_PROJECTION_STACK_DEPTH:
         params[0] = (GLint64)(MAX_PROJECTION_STACK_DEPTH);
         break;
      case GL_MAX_TEXTURE_SIZE:
         params[0] = (GLint64)(1 << (ctx->Const.MaxTextureLevels - 1));
         break;
      case GL_MAX_3D_TEXTURE_SIZE:
         params[0] = (GLint64)(1 << (ctx->Const.Max3DTextureLevels - 1));
         break;
      case GL_MAX_TEXTURE_STACK_DEPTH:
         params[0] = (GLint64)(MAX_TEXTURE_STACK_DEPTH);
         break;
      case GL_MAX_VIEWPORT_DIMS:
         params[0] = (GLint64)(ctx->Const.MaxViewportWidth);
         params[1] = (GLint64)(ctx->Const.MaxViewportHeight);
         break;
      case GL_MODELVIEW_MATRIX:
         {
         const GLfloat *matrix = ctx->ModelviewMatrixStack.Top->m;
         params[0] = IROUND64(matrix[0]);
         params[1] = IROUND64(matrix[1]);
         params[2] = IROUND64(matrix[2]);
         params[3] = IROUND64(matrix[3]);
         params[4] = IROUND64(matrix[4]);
         params[5] = IROUND64(matrix[5]);
         params[6] = IROUND64(matrix[6]);
         params[7] = IROUND64(matrix[7]);
         params[8] = IROUND64(matrix[8]);
         params[9] = IROUND64(matrix[9]);
         params[10] = IROUND64(matrix[10]);
         params[11] = IROUND64(matrix[11]);
         params[12] = IROUND64(matrix[12]);
         params[13] = IROUND64(matrix[13]);
         params[14] = IROUND64(matrix[14]);
         params[15] = IROUND64(matrix[15]);
         }
         break;
      case GL_MODELVIEW_STACK_DEPTH:
         params[0] = (GLint64)(ctx->ModelviewMatrixStack.Depth + 1);
         break;
      case GL_NAME_STACK_DEPTH:
         params[0] = (GLint64)(ctx->Select.NameStackDepth);
         break;
      case GL_NORMALIZE:
         params[0] = BOOLEAN_TO_INT64(ctx->Transform.Normalize);
         break;
      case GL_PACK_ALIGNMENT:
         params[0] = (GLint64)(ctx->Pack.Alignment);
         break;
      case GL_PACK_LSB_FIRST:
         params[0] = BOOLEAN_TO_INT64(ctx->Pack.LsbFirst);
         break;
      case GL_PACK_ROW_LENGTH:
         params[0] = (GLint64)(ctx->Pack.RowLength);
         break;
      case GL_PACK_SKIP_PIXELS:
         params[0] = (GLint64)(ctx->Pack.SkipPixels);
         break;
      case GL_PACK_SKIP_ROWS:
         params[0] = (GLint64)(ctx->Pack.SkipRows);
         break;
      case GL_PACK_SWAP_BYTES:
         params[0] = BOOLEAN_TO_INT64(ctx->Pack.SwapBytes);
         break;
      case GL_PACK_SKIP_IMAGES_EXT:
         params[0] = (GLint64)(ctx->Pack.SkipImages);
         break;
      case GL_PACK_IMAGE_HEIGHT_EXT:
         params[0] = (GLint64)(ctx->Pack.ImageHeight);
         break;
      case GL_PACK_INVERT_MESA:
         params[0] = BOOLEAN_TO_INT64(ctx->Pack.Invert);
         break;
      case GL_PERSPECTIVE_CORRECTION_HINT:
         params[0] = ENUM_TO_INT64(ctx->Hint.PerspectiveCorrection);
         break;
      case GL_PIXEL_MAP_A_TO_A_SIZE:
         params[0] = (GLint64)(ctx->PixelMaps.AtoA.Size);
         break;
      case GL_PIXEL_MAP_B_TO_B_SIZE:
         params[0] = (GLint64)(ctx->PixelMaps.BtoB.Size);
         break;
      case GL_PIXEL_MAP_G_TO_G_SIZE:
         params[0] = (GLint64)(ctx->PixelMaps.GtoG.Size);
         break;
      case GL_PIXEL_MAP_I_TO_A_SIZE:
         params[0] = (GLint64)(ctx->PixelMaps.ItoA.Size);
         break;
      case GL_PIXEL_MAP_I_TO_B_SIZE:
         params[0] = (GLint64)(ctx->PixelMaps.ItoB.Size);
         break;
      case GL_PIXEL_MAP_I_TO_G_SIZE:
         params[0] = (GLint64)(ctx->PixelMaps.ItoG.Size);
         break;
      case GL_PIXEL_MAP_I_TO_I_SIZE:
         params[0] = (GLint64)(ctx->PixelMaps.ItoI.Size);
         break;
      case GL_PIXEL_MAP_I_TO_R_SIZE:
         params[0] = (GLint64)(ctx->PixelMaps.ItoR.Size);
         break;
      case GL_PIXEL_MAP_R_TO_R_SIZE:
         params[0] = (GLint64)(ctx->PixelMaps.RtoR.Size);
         break;
      case GL_PIXEL_MAP_S_TO_S_SIZE:
         params[0] = (GLint64)(ctx->PixelMaps.StoS.Size);
         break;
      case GL_POINT_SIZE:
         params[0] = IROUND64(ctx->Point.Size);
         break;
      case GL_POINT_SIZE_GRANULARITY:
         params[0] = IROUND64(ctx->Const.PointSizeGranularity);
         break;
      case GL_POINT_SIZE_RANGE:
         params[0] = IROUND64(ctx->Const.MinPointSizeAA);
         params[1] = IROUND64(ctx->Const.MaxPointSizeAA);
         break;
      case GL_ALIASED_POINT_SIZE_RANGE:
         params[0] = IROUND64(ctx->Const.MinPointSize);
         params[1] = IROUND64(ctx->Const.MaxPointSize);
         break;
      case GL_POINT_SMOOTH:
         params[0] = BOOLEAN_TO_INT64(ctx->Point.SmoothFlag);
         break;
      case GL_POINT_SMOOTH_HINT:
         params[0] = ENUM_TO_INT64(ctx->Hint.PointSmooth);
         break;
      case GL_POINT_SIZE_MIN_EXT:
         params[0] = IROUND64(ctx->Point.MinSize);
         break;
      case GL_POINT_SIZE_MAX_EXT:
         params[0] = IROUND64(ctx->Point.MaxSize);
         break;
      case GL_POINT_FADE_THRESHOLD_SIZE_EXT:
         params[0] = IROUND64(ctx->Point.Threshold);
         break;
      case GL_DISTANCE_ATTENUATION_EXT:
         params[0] = IROUND64(ctx->Point.Params[0]);
         params[1] = IROUND64(ctx->Point.Params[1]);
         params[2] = IROUND64(ctx->Point.Params[2]);
         break;
      case GL_POLYGON_MODE:
         params[0] = ENUM_TO_INT64(ctx->Polygon.FrontMode);
         params[1] = ENUM_TO_INT64(ctx->Polygon.BackMode);
         break;
      case GL_POLYGON_OFFSET_BIAS_EXT:
         params[0] = IROUND64(ctx->Polygon.OffsetUnits);
         break;
      case GL_POLYGON_OFFSET_FACTOR:
         params[0] = IROUND64(ctx->Polygon.OffsetFactor );
         break;
      case GL_POLYGON_OFFSET_UNITS:
         params[0] = IROUND64(ctx->Polygon.OffsetUnits );
         break;
      case GL_POLYGON_OFFSET_POINT:
         params[0] = BOOLEAN_TO_INT64(ctx->Polygon.OffsetPoint);
         break;
      case GL_POLYGON_OFFSET_LINE:
         params[0] = BOOLEAN_TO_INT64(ctx->Polygon.OffsetLine);
         break;
      case GL_POLYGON_OFFSET_FILL:
         params[0] = BOOLEAN_TO_INT64(ctx->Polygon.OffsetFill);
         break;
      case GL_POLYGON_SMOOTH:
         params[0] = BOOLEAN_TO_INT64(ctx->Polygon.SmoothFlag);
         break;
      case GL_POLYGON_SMOOTH_HINT:
         params[0] = ENUM_TO_INT64(ctx->Hint.PolygonSmooth);
         break;
      case GL_POLYGON_STIPPLE:
         params[0] = BOOLEAN_TO_INT64(ctx->Polygon.StippleFlag);
         break;
      case GL_PROJECTION_MATRIX:
         {
         const GLfloat *matrix = ctx->ProjectionMatrixStack.Top->m;
         params[0] = IROUND64(matrix[0]);
         params[1] = IROUND64(matrix[1]);
         params[2] = IROUND64(matrix[2]);
         params[3] = IROUND64(matrix[3]);
         params[4] = IROUND64(matrix[4]);
         params[5] = IROUND64(matrix[5]);
         params[6] = IROUND64(matrix[6]);
         params[7] = IROUND64(matrix[7]);
         params[8] = IROUND64(matrix[8]);
         params[9] = IROUND64(matrix[9]);
         params[10] = IROUND64(matrix[10]);
         params[11] = IROUND64(matrix[11]);
         params[12] = IROUND64(matrix[12]);
         params[13] = IROUND64(matrix[13]);
         params[14] = IROUND64(matrix[14]);
         params[15] = IROUND64(matrix[15]);
         }
         break;
      case GL_PROJECTION_STACK_DEPTH:
         params[0] = (GLint64)(ctx->ProjectionMatrixStack.Depth + 1);
         break;
      case GL_READ_BUFFER:
         params[0] = ENUM_TO_INT64(ctx->ReadBuffer->ColorReadBuffer);
         break;
      case GL_RED_BIAS:
         params[0] = IROUND64(ctx->Pixel.RedBias);
         break;
      case GL_RED_BITS:
         params[0] = (GLint64)(ctx->DrawBuffer->Visual.redBits);
         break;
      case GL_RED_SCALE:
         params[0] = IROUND64(ctx->Pixel.RedScale);
         break;
      case GL_RENDER_MODE:
         params[0] = ENUM_TO_INT64(ctx->RenderMode);
         break;
      case GL_RESCALE_NORMAL:
         params[0] = BOOLEAN_TO_INT64(ctx->Transform.RescaleNormals);
         break;
      case GL_RGBA_MODE:
         params[0] = BOOLEAN_TO_INT64(GL_TRUE);
         break;
      case GL_SCISSOR_BOX:
         params[0] = (GLint64)(ctx->Scissor.X);
         params[1] = (GLint64)(ctx->Scissor.Y);
         params[2] = (GLint64)(ctx->Scissor.Width);
         params[3] = (GLint64)(ctx->Scissor.Height);
         break;
      case GL_SCISSOR_TEST:
         params[0] = BOOLEAN_TO_INT64(ctx->Scissor.Enabled);
         break;
      case GL_SELECTION_BUFFER_SIZE:
         params[0] = (GLint64)(ctx->Select.BufferSize);
         break;
      case GL_SHADE_MODEL:
         params[0] = ENUM_TO_INT64(ctx->Light.ShadeModel);
         break;
      case GL_SHARED_TEXTURE_PALETTE_EXT:
         params[0] = BOOLEAN_TO_INT64(ctx->Texture.SharedPalette);
         break;
      case GL_STENCIL_BITS:
         params[0] = (GLint64)(ctx->DrawBuffer->Visual.stencilBits);
         break;
      case GL_STENCIL_CLEAR_VALUE:
         params[0] = (GLint64)(ctx->Stencil.Clear);
         break;
      case GL_STENCIL_FAIL:
         params[0] = ENUM_TO_INT64(ctx->Stencil.FailFunc[ctx->Stencil.ActiveFace]);
         break;
      case GL_STENCIL_FUNC:
         params[0] = ENUM_TO_INT64(ctx->Stencil.Function[ctx->Stencil.ActiveFace]);
         break;
      case GL_STENCIL_PASS_DEPTH_FAIL:
         params[0] = ENUM_TO_INT64(ctx->Stencil.ZFailFunc[ctx->Stencil.ActiveFace]);
         break;
      case GL_STENCIL_PASS_DEPTH_PASS:
         params[0] = ENUM_TO_INT64(ctx->Stencil.ZPassFunc[ctx->Stencil.ActiveFace]);
         break;
      case GL_STENCIL_REF:
         params[0] = (GLint64)(ctx->Stencil.Ref[ctx->Stencil.ActiveFace]);
         break;
      case GL_STENCIL_TEST:
         params[0] = BOOLEAN_TO_INT64(ctx->Stencil.Enabled);
         break;
      case GL_STENCIL_VALUE_MASK:
         params[0] = (GLint64)(ctx->Stencil.ValueMask[ctx->Stencil.ActiveFace]);
         break;
      case GL_STENCIL_WRITEMASK:
         params[0] = (GLint64)(ctx->Stencil.WriteMask[ctx->Stencil.ActiveFace]);
         break;
      case GL_STEREO:
         params[0] = BOOLEAN_TO_INT64(ctx->DrawBuffer->Visual.stereoMode);
         break;
      case GL_SUBPIXEL_BITS:
         params[0] = (GLint64)(ctx->Const.SubPixelBits);
         break;
      case GL_TEXTURE_1D:
         params[0] = BOOLEAN_TO_INT64(_mesa_IsEnabled(GL_TEXTURE_1D));
         break;
      case GL_TEXTURE_2D:
         params[0] = BOOLEAN_TO_INT64(_mesa_IsEnabled(GL_TEXTURE_2D));
         break;
      case GL_TEXTURE_3D:
         params[0] = BOOLEAN_TO_INT64(_mesa_IsEnabled(GL_TEXTURE_3D));
         break;
      case GL_TEXTURE_1D_ARRAY_EXT:
         CHECK_EXT1(MESA_texture_array, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(_mesa_IsEnabled(GL_TEXTURE_1D_ARRAY_EXT));
         break;
      case GL_TEXTURE_2D_ARRAY_EXT:
         CHECK_EXT1(MESA_texture_array, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(_mesa_IsEnabled(GL_TEXTURE_2D_ARRAY_EXT));
         break;
      case GL_TEXTURE_BINDING_1D:
         params[0] = (GLint64)(ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentTex[TEXTURE_1D_INDEX]->Name);
         break;
      case GL_TEXTURE_BINDING_2D:
         params[0] = (GLint64)(ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentTex[TEXTURE_2D_INDEX]->Name);
         break;
      case GL_TEXTURE_BINDING_3D:
         params[0] = (GLint64)(ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentTex[TEXTURE_3D_INDEX]->Name);
         break;
      case GL_TEXTURE_BINDING_1D_ARRAY_EXT:
         CHECK_EXT1(MESA_texture_array, "GetInteger64v");
         params[0] = (GLint64)(ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentTex[TEXTURE_1D_ARRAY_INDEX]->Name);
         break;
      case GL_TEXTURE_BINDING_2D_ARRAY_EXT:
         CHECK_EXT1(MESA_texture_array, "GetInteger64v");
         params[0] = (GLint64)(ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentTex[TEXTURE_2D_ARRAY_INDEX]->Name);
         break;
      case GL_TEXTURE_GEN_S:
         params[0] = BOOLEAN_TO_INT64(((ctx->Texture.Unit[ctx->Texture.CurrentUnit].TexGenEnabled & S_BIT) ? 1 : 0));
         break;
      case GL_TEXTURE_GEN_T:
         params[0] = BOOLEAN_TO_INT64(((ctx->Texture.Unit[ctx->Texture.CurrentUnit].TexGenEnabled & T_BIT) ? 1 : 0));
         break;
      case GL_TEXTURE_GEN_R:
         params[0] = BOOLEAN_TO_INT64(((ctx->Texture.Unit[ctx->Texture.CurrentUnit].TexGenEnabled & R_BIT) ? 1 : 0));
         break;
      case GL_TEXTURE_GEN_Q:
         params[0] = BOOLEAN_TO_INT64(((ctx->Texture.Unit[ctx->Texture.CurrentUnit].TexGenEnabled & Q_BIT) ? 1 : 0));
         break;
      case GL_TEXTURE_MATRIX:
         {
         const GLfloat *matrix;
         const GLuint unit = ctx->Texture.CurrentUnit;
         if (unit >= ctx->Const.MaxTextureCoordUnits) {
            _mesa_error(ctx, GL_INVALID_OPERATION, "glGet(texture matrix %u)",
                        unit);
            return;
         }
         matrix = ctx->TextureMatrixStack[unit].Top->m;
         params[0] = IROUND64(matrix[0]);
         params[1] = IROUND64(matrix[1]);
         params[2] = IROUND64(matrix[2]);
         params[3] = IROUND64(matrix[3]);
         params[4] = IROUND64(matrix[4]);
         params[5] = IROUND64(matrix[5]);
         params[6] = IROUND64(matrix[6]);
         params[7] = IROUND64(matrix[7]);
         params[8] = IROUND64(matrix[8]);
         params[9] = IROUND64(matrix[9]);
         params[10] = IROUND64(matrix[10]);
         params[11] = IROUND64(matrix[11]);
         params[12] = IROUND64(matrix[12]);
         params[13] = IROUND64(matrix[13]);
         params[14] = IROUND64(matrix[14]);
         params[15] = IROUND64(matrix[15]);
         }
         break;
      case GL_TEXTURE_STACK_DEPTH:
         {
         const GLuint unit = ctx->Texture.CurrentUnit;
         if (unit >= ctx->Const.MaxTextureCoordUnits) {
            _mesa_error(ctx, GL_INVALID_OPERATION,
                        "glGet(texture stack depth, unit %u)", unit);
            return;
         }
         params[0] = (GLint64)(ctx->TextureMatrixStack[unit].Depth + 1);
         }
         break;
      case GL_UNPACK_ALIGNMENT:
         params[0] = (GLint64)(ctx->Unpack.Alignment);
         break;
      case GL_UNPACK_LSB_FIRST:
         params[0] = BOOLEAN_TO_INT64(ctx->Unpack.LsbFirst);
         break;
      case GL_UNPACK_ROW_LENGTH:
         params[0] = (GLint64)(ctx->Unpack.RowLength);
         break;
      case GL_UNPACK_SKIP_PIXELS:
         params[0] = (GLint64)(ctx->Unpack.SkipPixels);
         break;
      case GL_UNPACK_SKIP_ROWS:
         params[0] = (GLint64)(ctx->Unpack.SkipRows);
         break;
      case GL_UNPACK_SWAP_BYTES:
         params[0] = BOOLEAN_TO_INT64(ctx->Unpack.SwapBytes);
         break;
      case GL_UNPACK_SKIP_IMAGES_EXT:
         params[0] = (GLint64)(ctx->Unpack.SkipImages);
         break;
      case GL_UNPACK_IMAGE_HEIGHT_EXT:
         params[0] = (GLint64)(ctx->Unpack.ImageHeight);
         break;
      case GL_UNPACK_CLIENT_STORAGE_APPLE:
         params[0] = BOOLEAN_TO_INT64(ctx->Unpack.ClientStorage);
         break;
      case GL_VIEWPORT:
         params[0] = (GLint64)(ctx->Viewport.X);
         params[1] = (GLint64)(ctx->Viewport.Y);
         params[2] = (GLint64)(ctx->Viewport.Width);
         params[3] = (GLint64)(ctx->Viewport.Height);
         break;
      case GL_ZOOM_X:
         params[0] = IROUND64(ctx->Pixel.ZoomX);
         break;
      case GL_ZOOM_Y:
         params[0] = IROUND64(ctx->Pixel.ZoomY);
         break;
      case GL_VERTEX_ARRAY:
         params[0] = BOOLEAN_TO_INT64(ctx->Array.ArrayObj->Vertex.Enabled);
         break;
      case GL_VERTEX_ARRAY_SIZE:
         params[0] = (GLint64)(ctx->Array.ArrayObj->Vertex.Size);
         break;
      case GL_VERTEX_ARRAY_TYPE:
         params[0] = ENUM_TO_INT64(ctx->Array.ArrayObj->Vertex.Type);
         break;
      case GL_VERTEX_ARRAY_STRIDE:
         params[0] = (GLint64)(ctx->Array.ArrayObj->Vertex.Stride);
         break;
      case GL_VERTEX_ARRAY_COUNT_EXT:
         params[0] = (GLint64)(0);
         break;
      case GL_NORMAL_ARRAY:
         params[0] = ENUM_TO_INT64(ctx->Array.ArrayObj->Normal.Enabled);
         break;
      case GL_NORMAL_ARRAY_TYPE:
         params[0] = ENUM_TO_INT64(ctx->Array.ArrayObj->Normal.Type);
         break;
      case GL_NORMAL_ARRAY_STRIDE:
         params[0] = (GLint64)(ctx->Array.ArrayObj->Normal.Stride);
         break;
      case GL_NORMAL_ARRAY_COUNT_EXT:
         params[0] = (GLint64)(0);
         break;
      case GL_COLOR_ARRAY:
         params[0] = BOOLEAN_TO_INT64(ctx->Array.ArrayObj->Color.Enabled);
         break;
      case GL_COLOR_ARRAY_SIZE:
         params[0] = (GLint64)(ctx->Array.ArrayObj->Color.Size);
         break;
      case GL_COLOR_ARRAY_TYPE:
         params[0] = ENUM_TO_INT64(ctx->Array.ArrayObj->Color.Type);
         break;
      case GL_COLOR_ARRAY_STRIDE:
         params[0] = (GLint64)(ctx->Array.ArrayObj->Color.Stride);
         break;
      case GL_COLOR_ARRAY_COUNT_EXT:
         params[0] = (GLint64)(0);
         break;
      case GL_INDEX_ARRAY:
         params[0] = BOOLEAN_TO_INT64(ctx->Array.ArrayObj->Index.Enabled);
         break;
      case GL_INDEX_ARRAY_TYPE:
         params[0] = ENUM_TO_INT64(ctx->Array.ArrayObj->Index.Type);
         break;
      case GL_INDEX_ARRAY_STRIDE:
         params[0] = (GLint64)(ctx->Array.ArrayObj->Index.Stride);
         break;
      case GL_INDEX_ARRAY_COUNT_EXT:
         params[0] = (GLint64)(0);
         break;
      case GL_TEXTURE_COORD_ARRAY:
         params[0] = BOOLEAN_TO_INT64(ctx->Array.ArrayObj->TexCoord[ctx->Array.ActiveTexture].Enabled);
         break;
      case GL_TEXTURE_COORD_ARRAY_SIZE:
         params[0] = (GLint64)(ctx->Array.ArrayObj->TexCoord[ctx->Array.ActiveTexture].Size);
         break;
      case GL_TEXTURE_COORD_ARRAY_TYPE:
         params[0] = ENUM_TO_INT64(ctx->Array.ArrayObj->TexCoord[ctx->Array.ActiveTexture].Type);
         break;
      case GL_TEXTURE_COORD_ARRAY_STRIDE:
         params[0] = (GLint64)(ctx->Array.ArrayObj->TexCoord[ctx->Array.ActiveTexture].Stride);
         break;
      case GL_TEXTURE_COORD_ARRAY_COUNT_EXT:
         params[0] = (GLint64)(0);
         break;
      case GL_EDGE_FLAG_ARRAY:
         params[0] = BOOLEAN_TO_INT64(ctx->Array.ArrayObj->EdgeFlag.Enabled);
         break;
      case GL_EDGE_FLAG_ARRAY_STRIDE:
         params[0] = (GLint64)(ctx->Array.ArrayObj->EdgeFlag.Stride);
         break;
      case GL_EDGE_FLAG_ARRAY_COUNT_EXT:
         params[0] = (GLint64)(0);
         break;
      case GL_MAX_TEXTURE_UNITS_ARB:
         CHECK_EXT1(ARB_multitexture, "GetInteger64v");
         params[0] = (GLint64)(ctx->Const.MaxTextureUnits);
         break;
      case GL_ACTIVE_TEXTURE_ARB:
         CHECK_EXT1(ARB_multitexture, "GetInteger64v");
         params[0] = (GLint64)(GL_TEXTURE0_ARB + ctx->Texture.CurrentUnit);
         break;
      case GL_CLIENT_ACTIVE_TEXTURE_ARB:
         CHECK_EXT1(ARB_multitexture, "GetInteger64v");
         params[0] = (GLint64)(GL_TEXTURE0_ARB + ctx->Array.ActiveTexture);
         break;
      case GL_TEXTURE_CUBE_MAP_ARB:
         CHECK_EXT1(ARB_texture_cube_map, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(_mesa_IsEnabled(GL_TEXTURE_CUBE_MAP_ARB));
         break;
      case GL_TEXTURE_BINDING_CUBE_MAP_ARB:
         CHECK_EXT1(ARB_texture_cube_map, "GetInteger64v");
         params[0] = (GLint64)(ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentTex[TEXTURE_CUBE_INDEX]->Name);
         break;
      case GL_MAX_CUBE_MAP_TEXTURE_SIZE_ARB:
         CHECK_EXT1(ARB_texture_cube_map, "GetInteger64v");
         params[0] = (GLint64)((1 << (ctx->Const.MaxCubeTextureLevels - 1)));
         break;
      case GL_TEXTURE_COMPRESSION_HINT_ARB:
         params[0] = (GLint64)(ctx->Hint.TextureCompression);
         break;
      case GL_NUM_COMPRESSED_TEXTURE_FORMATS_ARB:
         params[0] = (GLint64)(_mesa_get_compressed_formats(ctx, NULL, GL_FALSE));
         break;
      case GL_COMPRESSED_TEXTURE_FORMATS_ARB:
         {
         GLint formats[100];
         GLuint i, n = _mesa_get_compressed_formats(ctx, formats, GL_FALSE);
         ASSERT(n <= 100);
         for (i = 0; i < n; i++)
            params[i] = ENUM_TO_INT64(formats[i]);
         }
         break;
      case GL_ARRAY_ELEMENT_LOCK_FIRST_EXT:
         CHECK_EXT1(EXT_compiled_vertex_array, "GetInteger64v");
         params[0] = (GLint64)(ctx->Array.LockFirst);
         break;
      case GL_ARRAY_ELEMENT_LOCK_COUNT_EXT:
         CHECK_EXT1(EXT_compiled_vertex_array, "GetInteger64v");
         params[0] = (GLint64)(ctx->Array.LockCount);
         break;
      case GL_TRANSPOSE_COLOR_MATRIX_ARB:
         {
         const GLfloat *matrix = ctx->ColorMatrixStack.Top->m;
         params[0] = IROUND64(matrix[0]);
         params[1] = IROUND64(matrix[4]);
         params[2] = IROUND64(matrix[8]);
         params[3] = IROUND64(matrix[12]);
         params[4] = IROUND64(matrix[1]);
         params[5] = IROUND64(matrix[5]);
         params[6] = IROUND64(matrix[9]);
         params[7] = IROUND64(matrix[13]);
         params[8] = IROUND64(matrix[2]);
         params[9] = IROUND64(matrix[6]);
         params[10] = IROUND64(matrix[10]);
         params[11] = IROUND64(matrix[14]);
         params[12] = IROUND64(matrix[3]);
         params[13] = IROUND64(matrix[7]);
         params[14] = IROUND64(matrix[11]);
         params[15] = IROUND64(matrix[15]);
         }
         break;
      case GL_TRANSPOSE_MODELVIEW_MATRIX_ARB:
         {
         const GLfloat *matrix = ctx->ModelviewMatrixStack.Top->m;
         params[0] = IROUND64(matrix[0]);
         params[1] = IROUND64(matrix[4]);
         params[2] = IROUND64(matrix[8]);
         params[3] = IROUND64(matrix[12]);
         params[4] = IROUND64(matrix[1]);
         params[5] = IROUND64(matrix[5]);
         params[6] = IROUND64(matrix[9]);
         params[7] = IROUND64(matrix[13]);
         params[8] = IROUND64(matrix[2]);
         params[9] = IROUND64(matrix[6]);
         params[10] = IROUND64(matrix[10]);
         params[11] = IROUND64(matrix[14]);
         params[12] = IROUND64(matrix[3]);
         params[13] = IROUND64(matrix[7]);
         params[14] = IROUND64(matrix[11]);
         params[15] = IROUND64(matrix[15]);
         }
         break;
      case GL_TRANSPOSE_PROJECTION_MATRIX_ARB:
         {
         const GLfloat *matrix = ctx->ProjectionMatrixStack.Top->m;
         params[0] = IROUND64(matrix[0]);
         params[1] = IROUND64(matrix[4]);
         params[2] = IROUND64(matrix[8]);
         params[3] = IROUND64(matrix[12]);
         params[4] = IROUND64(matrix[1]);
         params[5] = IROUND64(matrix[5]);
         params[6] = IROUND64(matrix[9]);
         params[7] = IROUND64(matrix[13]);
         params[8] = IROUND64(matrix[2]);
         params[9] = IROUND64(matrix[6]);
         params[10] = IROUND64(matrix[10]);
         params[11] = IROUND64(matrix[14]);
         params[12] = IROUND64(matrix[3]);
         params[13] = IROUND64(matrix[7]);
         params[14] = IROUND64(matrix[11]);
         params[15] = IROUND64(matrix[15]);
         }
         break;
      case GL_TRANSPOSE_TEXTURE_MATRIX_ARB:
         {
         const GLfloat *matrix = ctx->TextureMatrixStack[ctx->Texture.CurrentUnit].Top->m;
         params[0] = IROUND64(matrix[0]);
         params[1] = IROUND64(matrix[4]);
         params[2] = IROUND64(matrix[8]);
         params[3] = IROUND64(matrix[12]);
         params[4] = IROUND64(matrix[1]);
         params[5] = IROUND64(matrix[5]);
         params[6] = IROUND64(matrix[9]);
         params[7] = IROUND64(matrix[13]);
         params[8] = IROUND64(matrix[2]);
         params[9] = IROUND64(matrix[6]);
         params[10] = IROUND64(matrix[10]);
         params[11] = IROUND64(matrix[14]);
         params[12] = IROUND64(matrix[3]);
         params[13] = IROUND64(matrix[7]);
         params[14] = IROUND64(matrix[11]);
         params[15] = IROUND64(matrix[15]);
         }
         break;
      case GL_COLOR_MATRIX_SGI:
         {
         const GLfloat *matrix = ctx->ColorMatrixStack.Top->m;
         params[0] = IROUND64(matrix[0]);
         params[1] = IROUND64(matrix[1]);
         params[2] = IROUND64(matrix[2]);
         params[3] = IROUND64(matrix[3]);
         params[4] = IROUND64(matrix[4]);
         params[5] = IROUND64(matrix[5]);
         params[6] = IROUND64(matrix[6]);
         params[7] = IROUND64(matrix[7]);
         params[8] = IROUND64(matrix[8]);
         params[9] = IROUND64(matrix[9]);
         params[10] = IROUND64(matrix[10]);
         params[11] = IROUND64(matrix[11]);
         params[12] = IROUND64(matrix[12]);
         params[13] = IROUND64(matrix[13]);
         params[14] = IROUND64(matrix[14]);
         params[15] = IROUND64(matrix[15]);
         }
         break;
      case GL_COLOR_MATRIX_STACK_DEPTH_SGI:
         params[0] = (GLint64)(ctx->ColorMatrixStack.Depth + 1);
         break;
      case GL_MAX_COLOR_MATRIX_STACK_DEPTH_SGI:
         params[0] = (GLint64)(MAX_COLOR_STACK_DEPTH);
         break;
      case GL_POST_COLOR_MATRIX_RED_SCALE_SGI:
         params[0] = IROUND64(ctx->Pixel.PostColorMatrixScale[0]);
         break;
      case GL_POST_COLOR_MATRIX_GREEN_SCALE_SGI:
         params[0] = IROUND64(ctx->Pixel.PostColorMatrixScale[1]);
         break;
      case GL_POST_COLOR_MATRIX_BLUE_SCALE_SGI:
         params[0] = IROUND64(ctx->Pixel.PostColorMatrixScale[2]);
         break;
      case GL_POST_COLOR_MATRIX_ALPHA_SCALE_SGI:
         params[0] = IROUND64(ctx->Pixel.PostColorMatrixScale[3]);
         break;
      case GL_POST_COLOR_MATRIX_RED_BIAS_SGI:
         params[0] = IROUND64(ctx->Pixel.PostColorMatrixBias[0]);
         break;
      case GL_POST_COLOR_MATRIX_GREEN_BIAS_SGI:
         params[0] = IROUND64(ctx->Pixel.PostColorMatrixBias[1]);
         break;
      case GL_POST_COLOR_MATRIX_BLUE_BIAS_SGI:
         params[0] = IROUND64(ctx->Pixel.PostColorMatrixBias[2]);
         break;
      case GL_POST_COLOR_MATRIX_ALPHA_BIAS_SGI:
         params[0] = IROUND64(ctx->Pixel.PostColorMatrixBias[3]);
         break;
      case GL_CONVOLUTION_1D_EXT:
         CHECK_EXT1(EXT_convolution, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->Pixel.Convolution1DEnabled);
         break;
      case GL_CONVOLUTION_2D_EXT:
         CHECK_EXT1(EXT_convolution, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->Pixel.Convolution2DEnabled);
         break;
      case GL_SEPARABLE_2D_EXT:
         CHECK_EXT1(EXT_convolution, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->Pixel.Separable2DEnabled);
         break;
      case GL_POST_CONVOLUTION_RED_SCALE_EXT:
         CHECK_EXT1(EXT_convolution, "GetInteger64v");
         params[0] = IROUND64(ctx->Pixel.PostConvolutionScale[0]);
         break;
      case GL_POST_CONVOLUTION_GREEN_SCALE_EXT:
         CHECK_EXT1(EXT_convolution, "GetInteger64v");
         params[0] = IROUND64(ctx->Pixel.PostConvolutionScale[1]);
         break;
      case GL_POST_CONVOLUTION_BLUE_SCALE_EXT:
         CHECK_EXT1(EXT_convolution, "GetInteger64v");
         params[0] = IROUND64(ctx->Pixel.PostConvolutionScale[2]);
         break;
      case GL_POST_CONVOLUTION_ALPHA_SCALE_EXT:
         CHECK_EXT1(EXT_convolution, "GetInteger64v");
         params[0] = IROUND64(ctx->Pixel.PostConvolutionScale[3]);
         break;
      case GL_POST_CONVOLUTION_RED_BIAS_EXT:
         CHECK_EXT1(EXT_convolution, "GetInteger64v");
         params[0] = IROUND64(ctx->Pixel.PostConvolutionBias[0]);
         break;
      case GL_POST_CONVOLUTION_GREEN_BIAS_EXT:
         CHECK_EXT1(EXT_convolution, "GetInteger64v");
         params[0] = IROUND64(ctx->Pixel.PostConvolutionBias[1]);
         break;
      case GL_POST_CONVOLUTION_BLUE_BIAS_EXT:
         CHECK_EXT1(EXT_convolution, "GetInteger64v");
         params[0] = IROUND64(ctx->Pixel.PostConvolutionBias[2]);
         break;
      case GL_POST_CONVOLUTION_ALPHA_BIAS_EXT:
         CHECK_EXT1(EXT_convolution, "GetInteger64v");
         params[0] = IROUND64(ctx->Pixel.PostConvolutionBias[3]);
         break;
      case GL_HISTOGRAM:
         CHECK_EXT1(EXT_histogram, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->Pixel.HistogramEnabled);
         break;
      case GL_MINMAX:
         CHECK_EXT1(EXT_histogram, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->Pixel.MinMaxEnabled);
         break;
      case GL_COLOR_TABLE_SGI:
         CHECK_EXT1(SGI_color_table, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->Pixel.ColorTableEnabled[COLORTABLE_PRECONVOLUTION]);
         break;
      case GL_POST_CONVOLUTION_COLOR_TABLE_SGI:
         CHECK_EXT1(SGI_color_table, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->Pixel.ColorTableEnabled[COLORTABLE_POSTCONVOLUTION]);
         break;
      case GL_POST_COLOR_MATRIX_COLOR_TABLE_SGI:
         CHECK_EXT1(SGI_color_table, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->Pixel.ColorTableEnabled[COLORTABLE_POSTCOLORMATRIX]);
         break;
      case GL_TEXTURE_COLOR_TABLE_SGI:
         CHECK_EXT1(SGI_texture_color_table, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->Texture.Unit[ctx->Texture.CurrentUnit].ColorTableEnabled);
         break;
      case GL_COLOR_SUM_EXT:
         CHECK_EXT2(EXT_secondary_color, ARB_vertex_program, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->Fog.ColorSumEnabled);
         break;
      case GL_CURRENT_SECONDARY_COLOR_EXT:
         CHECK_EXT1(EXT_secondary_color, "GetInteger64v");
         {
         FLUSH_CURRENT(ctx, 0);
         params[0] = FLOAT_TO_INT64(ctx->Current.Attrib[VERT_ATTRIB_COLOR1][0]);
         params[1] = FLOAT_TO_INT64(ctx->Current.Attrib[VERT_ATTRIB_COLOR1][1]);
         params[2] = FLOAT_TO_INT64(ctx->Current.Attrib[VERT_ATTRIB_COLOR1][2]);
         params[3] = FLOAT_TO_INT64(ctx->Current.Attrib[VERT_ATTRIB_COLOR1][3]);
         }
         break;
      case GL_SECONDARY_COLOR_ARRAY_EXT:
         CHECK_EXT1(EXT_secondary_color, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->Array.ArrayObj->SecondaryColor.Enabled);
         break;
      case GL_SECONDARY_COLOR_ARRAY_TYPE_EXT:
         CHECK_EXT1(EXT_secondary_color, "GetInteger64v");
         params[0] = ENUM_TO_INT64(ctx->Array.ArrayObj->SecondaryColor.Type);
         break;
      case GL_SECONDARY_COLOR_ARRAY_STRIDE_EXT:
         CHECK_EXT1(EXT_secondary_color, "GetInteger64v");
         params[0] = (GLint64)(ctx->Array.ArrayObj->SecondaryColor.Stride);
         break;
      case GL_SECONDARY_COLOR_ARRAY_SIZE_EXT:
         CHECK_EXT1(EXT_secondary_color, "GetInteger64v");
         params[0] = (GLint64)(ctx->Array.ArrayObj->SecondaryColor.Size);
         break;
      case GL_CURRENT_FOG_COORDINATE_EXT:
         CHECK_EXT1(EXT_fog_coord, "GetInteger64v");
         {
         FLUSH_CURRENT(ctx, 0);
         params[0] = IROUND64(ctx->Current.Attrib[VERT_ATTRIB_FOG][0]);
         }
         break;
      case GL_FOG_COORDINATE_ARRAY_EXT:
         CHECK_EXT1(EXT_fog_coord, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->Array.ArrayObj->FogCoord.Enabled);
         break;
      case GL_FOG_COORDINATE_ARRAY_TYPE_EXT:
         CHECK_EXT1(EXT_fog_coord, "GetInteger64v");
         params[0] = ENUM_TO_INT64(ctx->Array.ArrayObj->FogCoord.Type);
         break;
      case GL_FOG_COORDINATE_ARRAY_STRIDE_EXT:
         CHECK_EXT1(EXT_fog_coord, "GetInteger64v");
         params[0] = (GLint64)(ctx->Array.ArrayObj->FogCoord.Stride);
         break;
      case GL_FOG_COORDINATE_SOURCE_EXT:
         CHECK_EXT1(EXT_fog_coord, "GetInteger64v");
         params[0] = ENUM_TO_INT64(ctx->Fog.FogCoordinateSource);
         break;
      case GL_MAX_TEXTURE_LOD_BIAS_EXT:
         CHECK_EXT1(EXT_texture_lod_bias, "GetInteger64v");
         params[0] = IROUND64(ctx->Const.MaxTextureLodBias);
         break;
      case GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT:
         CHECK_EXT1(EXT_texture_filter_anisotropic, "GetInteger64v");
         params[0] = IROUND64(ctx->Const.MaxTextureMaxAnisotropy);
         break;
      case GL_MULTISAMPLE_ARB:
         params[0] = BOOLEAN_TO_INT64(ctx->Multisample.Enabled);
         break;
      case GL_SAMPLE_ALPHA_TO_COVERAGE_ARB:
         params[0] = BOOLEAN_TO_INT64(ctx->Multisample.SampleAlphaToCoverage);
         break;
      case GL_SAMPLE_ALPHA_TO_ONE_ARB:
         params[0] = BOOLEAN_TO_INT64(ctx->Multisample.SampleAlphaToOne);
         break;
      case GL_SAMPLE_COVERAGE_ARB:
         params[0] = BOOLEAN_TO_INT64(ctx->Multisample.SampleCoverage);
         break;
      case GL_SAMPLE_COVERAGE_VALUE_ARB:
         params[0] = IROUND64(ctx->Multisample.SampleCoverageValue);
         break;
      case GL_SAMPLE_COVERAGE_INVERT_ARB:
         params[0] = BOOLEAN_TO_INT64(ctx->Multisample.SampleCoverageInvert);
         break;
      case GL_SAMPLE_BUFFERS_ARB:
         params[0] = (GLint64)(ctx->DrawBuffer->Visual.sampleBuffers);
         break;
      case GL_SAMPLES_ARB:
         params[0] = (GLint64)(ctx->DrawBuffer->Visual.samples);
         break;
      case GL_RASTER_POSITION_UNCLIPPED_IBM:
         CHECK_EXT1(IBM_rasterpos_clip, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->Transform.RasterPositionUnclipped);
         break;
      case GL_POINT_SPRITE_NV:
         CHECK_EXT2(NV_point_sprite, ARB_point_sprite, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->Point.PointSprite);
         break;
      case GL_POINT_SPRITE_R_MODE_NV:
         CHECK_EXT1(NV_point_sprite, "GetInteger64v");
         params[0] = ENUM_TO_INT64(ctx->Point.SpriteRMode);
         break;
      case GL_POINT_SPRITE_COORD_ORIGIN:
         CHECK_EXT2(NV_point_sprite, ARB_point_sprite, "GetInteger64v");
         params[0] = ENUM_TO_INT64(ctx->Point.SpriteOrigin);
         break;
      case GL_GENERATE_MIPMAP_HINT_SGIS:
         CHECK_EXT1(SGIS_generate_mipmap, "GetInteger64v");
         params[0] = ENUM_TO_INT64(ctx->Hint.GenerateMipmap);
         break;
      case GL_VERTEX_PROGRAM_BINDING_NV:
         CHECK_EXT1(NV_vertex_program, "GetInteger64v");
         params[0] = (GLint64)((ctx->VertexProgram.Current ? ctx->VertexProgram.Current->Base.Id : 0));
         break;
      case GL_VERTEX_ATTRIB_ARRAY0_NV:
         CHECK_EXT1(NV_vertex_program, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->Array.ArrayObj->VertexAttrib[0].Enabled);
         break;
      case GL_VERTEX_ATTRIB_ARRAY1_NV:
         CHECK_EXT1(NV_vertex_program, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->Array.ArrayObj->VertexAttrib[1].Enabled);
         break;
      case GL_VERTEX_ATTRIB_ARRAY2_NV:
         CHECK_EXT1(NV_vertex_program, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->Array.ArrayObj->VertexAttrib[2].Enabled);
         break;
      case GL_VERTEX_ATTRIB_ARRAY3_NV:
         CHECK_EXT1(NV_vertex_program, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->Array.ArrayObj->VertexAttrib[3].Enabled);
         break;
      case GL_VERTEX_ATTRIB_ARRAY4_NV:
         CHECK_EXT1(NV_vertex_program, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->Array.ArrayObj->VertexAttrib[4].Enabled);
         break;
      case GL_VERTEX_ATTRIB_ARRAY5_NV:
         CHECK_EXT1(NV_vertex_program, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->Array.ArrayObj->VertexAttrib[5].Enabled);
         break;
      case GL_VERTEX_ATTRIB_ARRAY6_NV:
         CHECK_EXT1(NV_vertex_program, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->Array.ArrayObj->VertexAttrib[6].Enabled);
         break;
      case GL_VERTEX_ATTRIB_ARRAY7_NV:
         CHECK_EXT1(NV_vertex_program, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->Array.ArrayObj->VertexAttrib[7].Enabled);
         break;
      case GL_VERTEX_ATTRIB_ARRAY8_NV:
         CHECK_EXT1(NV_vertex_program, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->Array.ArrayObj->VertexAttrib[8].Enabled);
         break;
      case GL_VERTEX_ATTRIB_ARRAY9_NV:
         CHECK_EXT1(NV_vertex_program, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->Array.ArrayObj->VertexAttrib[9].Enabled);
         break;
      case GL_VERTEX_ATTRIB_ARRAY10_NV:
         CHECK_EXT1(NV_vertex_program, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->Array.ArrayObj->VertexAttrib[10].Enabled);
         break;
      case GL_VERTEX_ATTRIB_ARRAY11_NV:
         CHECK_EXT1(NV_vertex_program, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->Array.ArrayObj->VertexAttrib[11].Enabled);
         break;
      case GL_VERTEX_ATTRIB_ARRAY12_NV:
         CHECK_EXT1(NV_vertex_program, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->Array.ArrayObj->VertexAttrib[12].Enabled);
         break;
      case GL_VERTEX_ATTRIB_ARRAY13_NV:
         CHECK_EXT1(NV_vertex_program, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->Array.ArrayObj->VertexAttrib[13].Enabled);
         break;
      case GL_VERTEX_ATTRIB_ARRAY14_NV:
         CHECK_EXT1(NV_vertex_program, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->Array.ArrayObj->VertexAttrib[14].Enabled);
         break;
      case GL_VERTEX_ATTRIB_ARRAY15_NV:
         CHECK_EXT1(NV_vertex_program, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->Array.ArrayObj->VertexAttrib[15].Enabled);
         break;
      case GL_MAP1_VERTEX_ATTRIB0_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->Eval.Map1Attrib[0]);
         break;
      case GL_MAP1_VERTEX_ATTRIB1_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->Eval.Map1Attrib[1]);
         break;
      case GL_MAP1_VERTEX_ATTRIB2_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->Eval.Map1Attrib[2]);
         break;
      case GL_MAP1_VERTEX_ATTRIB3_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->Eval.Map1Attrib[3]);
         break;
      case GL_MAP1_VERTEX_ATTRIB4_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->Eval.Map1Attrib[4]);
         break;
      case GL_MAP1_VERTEX_ATTRIB5_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->Eval.Map1Attrib[5]);
         break;
      case GL_MAP1_VERTEX_ATTRIB6_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->Eval.Map1Attrib[6]);
         break;
      case GL_MAP1_VERTEX_ATTRIB7_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->Eval.Map1Attrib[7]);
         break;
      case GL_MAP1_VERTEX_ATTRIB8_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->Eval.Map1Attrib[8]);
         break;
      case GL_MAP1_VERTEX_ATTRIB9_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->Eval.Map1Attrib[9]);
         break;
      case GL_MAP1_VERTEX_ATTRIB10_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->Eval.Map1Attrib[10]);
         break;
      case GL_MAP1_VERTEX_ATTRIB11_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->Eval.Map1Attrib[11]);
         break;
      case GL_MAP1_VERTEX_ATTRIB12_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->Eval.Map1Attrib[12]);
         break;
      case GL_MAP1_VERTEX_ATTRIB13_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->Eval.Map1Attrib[13]);
         break;
      case GL_MAP1_VERTEX_ATTRIB14_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->Eval.Map1Attrib[14]);
         break;
      case GL_MAP1_VERTEX_ATTRIB15_4_NV:
         CHECK_EXT1(NV_vertex_program, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->Eval.Map1Attrib[15]);
         break;
      case GL_FRAGMENT_PROGRAM_NV:
         CHECK_EXT1(NV_fragment_program, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->FragmentProgram.Enabled);
         break;
      case GL_FRAGMENT_PROGRAM_BINDING_NV:
         CHECK_EXT1(NV_fragment_program, "GetInteger64v");
         params[0] = (GLint64)(ctx->FragmentProgram.Current ? ctx->FragmentProgram.Current->Base.Id : 0);
         break;
      case GL_MAX_FRAGMENT_PROGRAM_LOCAL_PARAMETERS_NV:
         CHECK_EXT1(NV_fragment_program, "GetInteger64v");
         params[0] = (GLint64)(MAX_NV_FRAGMENT_PROGRAM_PARAMS);
         break;
      case GL_TEXTURE_RECTANGLE_NV:
         CHECK_EXT1(NV_texture_rectangle, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(_mesa_IsEnabled(GL_TEXTURE_RECTANGLE_NV));
         break;
      case GL_TEXTURE_BINDING_RECTANGLE_NV:
         CHECK_EXT1(NV_texture_rectangle, "GetInteger64v");
         params[0] = (GLint64)(ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentTex[TEXTURE_RECT_INDEX]->Name);
         break;
      case GL_MAX_RECTANGLE_TEXTURE_SIZE_NV:
         CHECK_EXT1(NV_texture_rectangle, "GetInteger64v");
         params[0] = (GLint64)(ctx->Const.MaxTextureRectSize);
         break;
      case GL_STENCIL_TEST_TWO_SIDE_EXT:
         CHECK_EXT1(EXT_stencil_two_side, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->Stencil.TestTwoSide);
         break;
      case GL_ACTIVE_STENCIL_FACE_EXT:
         CHECK_EXT1(EXT_stencil_two_side, "GetInteger64v");
         params[0] = ENUM_TO_INT64(ctx->Stencil.ActiveFace ? GL_BACK : GL_FRONT);
         break;
      case GL_MAX_SHININESS_NV:
         CHECK_EXT1(NV_light_max_exponent, "GetInteger64v");
         params[0] = IROUND64(ctx->Const.MaxShininess);
         break;
      case GL_MAX_SPOT_EXPONENT_NV:
         CHECK_EXT1(NV_light_max_exponent, "GetInteger64v");
         params[0] = IROUND64(ctx->Const.MaxSpotExponent);
         break;
      case GL_ARRAY_BUFFER_BINDING_ARB:
         params[0] = (GLint64)(ctx->Array.ArrayBufferObj->Name);
         break;
      case GL_VERTEX_ARRAY_BUFFER_BINDING_ARB:
         params[0] = (GLint64)(ctx->Array.ArrayObj->Vertex.BufferObj->Name);
         break;
      case GL_NORMAL_ARRAY_BUFFER_BINDING_ARB:
         params[0] = (GLint64)(ctx->Array.ArrayObj->Normal.BufferObj->Name);
         break;
      case GL_COLOR_ARRAY_BUFFER_BINDING_ARB:
         params[0] = (GLint64)(ctx->Array.ArrayObj->Color.BufferObj->Name);
         break;
      case GL_INDEX_ARRAY_BUFFER_BINDING_ARB:
         params[0] = (GLint64)(ctx->Array.ArrayObj->Index.BufferObj->Name);
         break;
      case GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING_ARB:
         params[0] = (GLint64)(ctx->Array.ArrayObj->TexCoord[ctx->Array.ActiveTexture].BufferObj->Name);
         break;
      case GL_EDGE_FLAG_ARRAY_BUFFER_BINDING_ARB:
         params[0] = (GLint64)(ctx->Array.ArrayObj->EdgeFlag.BufferObj->Name);
         break;
      case GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING_ARB:
         params[0] = (GLint64)(ctx->Array.ArrayObj->SecondaryColor.BufferObj->Name);
         break;
      case GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING_ARB:
         params[0] = (GLint64)(ctx->Array.ArrayObj->FogCoord.BufferObj->Name);
         break;
      case GL_ELEMENT_ARRAY_BUFFER_BINDING_ARB:
         params[0] = (GLint64)(ctx->Array.ElementArrayBufferObj->Name);
         break;
      case GL_PIXEL_PACK_BUFFER_BINDING_EXT:
         CHECK_EXT1(EXT_pixel_buffer_object, "GetInteger64v");
         params[0] = (GLint64)(ctx->Pack.BufferObj->Name);
         break;
      case GL_PIXEL_UNPACK_BUFFER_BINDING_EXT:
         CHECK_EXT1(EXT_pixel_buffer_object, "GetInteger64v");
         params[0] = (GLint64)(ctx->Unpack.BufferObj->Name);
         break;
      case GL_VERTEX_PROGRAM_ARB:
         CHECK_EXT2(ARB_vertex_program, NV_vertex_program, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->VertexProgram.Enabled);
         break;
      case GL_VERTEX_PROGRAM_POINT_SIZE_ARB:
         CHECK_EXT2(ARB_vertex_program, NV_vertex_program, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->VertexProgram.PointSizeEnabled);
         break;
      case GL_VERTEX_PROGRAM_TWO_SIDE_ARB:
         CHECK_EXT2(ARB_vertex_program, NV_vertex_program, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->VertexProgram.TwoSideEnabled);
         break;
      case GL_MAX_PROGRAM_MATRIX_STACK_DEPTH_ARB:
         CHECK_EXT3(ARB_vertex_program, ARB_fragment_program, NV_vertex_program, "GetInteger64v");
         params[0] = (GLint64)(ctx->Const.MaxProgramMatrixStackDepth);
         break;
      case GL_MAX_PROGRAM_MATRICES_ARB:
         CHECK_EXT3(ARB_vertex_program, ARB_fragment_program, NV_vertex_program, "GetInteger64v");
         params[0] = (GLint64)(ctx->Const.MaxProgramMatrices);
         break;
      case GL_CURRENT_MATRIX_STACK_DEPTH_ARB:
         CHECK_EXT3(ARB_vertex_program, ARB_fragment_program, NV_vertex_program, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->CurrentStack->Depth + 1);
         break;
      case GL_CURRENT_MATRIX_ARB:
         CHECK_EXT3(ARB_vertex_program, ARB_fragment_program, NV_fragment_program, "GetInteger64v");
         {
         const GLfloat *matrix = ctx->CurrentStack->Top->m;
         params[0] = IROUND64(matrix[0]);
         params[1] = IROUND64(matrix[1]);
         params[2] = IROUND64(matrix[2]);
         params[3] = IROUND64(matrix[3]);
         params[4] = IROUND64(matrix[4]);
         params[5] = IROUND64(matrix[5]);
         params[6] = IROUND64(matrix[6]);
         params[7] = IROUND64(matrix[7]);
         params[8] = IROUND64(matrix[8]);
         params[9] = IROUND64(matrix[9]);
         params[10] = IROUND64(matrix[10]);
         params[11] = IROUND64(matrix[11]);
         params[12] = IROUND64(matrix[12]);
         params[13] = IROUND64(matrix[13]);
         params[14] = IROUND64(matrix[14]);
         params[15] = IROUND64(matrix[15]);
         }
         break;
      case GL_TRANSPOSE_CURRENT_MATRIX_ARB:
         CHECK_EXT2(ARB_vertex_program, ARB_fragment_program, "GetInteger64v");
         {
         const GLfloat *matrix = ctx->CurrentStack->Top->m;
         params[0] = IROUND64(matrix[0]);
         params[1] = IROUND64(matrix[4]);
         params[2] = IROUND64(matrix[8]);
         params[3] = IROUND64(matrix[12]);
         params[4] = IROUND64(matrix[1]);
         params[5] = IROUND64(matrix[5]);
         params[6] = IROUND64(matrix[9]);
         params[7] = IROUND64(matrix[13]);
         params[8] = IROUND64(matrix[2]);
         params[9] = IROUND64(matrix[6]);
         params[10] = IROUND64(matrix[10]);
         params[11] = IROUND64(matrix[14]);
         params[12] = IROUND64(matrix[3]);
         params[13] = IROUND64(matrix[7]);
         params[14] = IROUND64(matrix[11]);
         params[15] = IROUND64(matrix[15]);
         }
         break;
      case GL_MAX_VERTEX_ATTRIBS_ARB:
         CHECK_EXT1(ARB_vertex_program, "GetInteger64v");
         params[0] = (GLint64)(ctx->Const.VertexProgram.MaxAttribs);
         break;
      case GL_PROGRAM_ERROR_POSITION_ARB:
         CHECK_EXT4(NV_vertex_program, ARB_vertex_program, NV_fragment_program, ARB_fragment_program, "GetInteger64v");
         params[0] = (GLint64)(ctx->Program.ErrorPos);
         break;
      case GL_FRAGMENT_PROGRAM_ARB:
         CHECK_EXT1(ARB_fragment_program, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->FragmentProgram.Enabled);
         break;
      case GL_MAX_TEXTURE_COORDS_ARB:
         CHECK_EXT2(ARB_fragment_program, NV_fragment_program, "GetInteger64v");
         params[0] = (GLint64)(ctx->Const.MaxTextureCoordUnits);
         break;
      case GL_MAX_TEXTURE_IMAGE_UNITS_ARB:
         CHECK_EXT2(ARB_fragment_program, NV_fragment_program, "GetInteger64v");
         params[0] = (GLint64)(ctx->Const.MaxTextureImageUnits);
         break;
      case GL_DEPTH_BOUNDS_TEST_EXT:
         CHECK_EXT1(EXT_depth_bounds_test, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->Depth.BoundsTest);
         break;
      case GL_DEPTH_BOUNDS_EXT:
         CHECK_EXT1(EXT_depth_bounds_test, "GetInteger64v");
         params[0] = IROUND64(ctx->Depth.BoundsMin);
         params[1] = IROUND64(ctx->Depth.BoundsMax);
         break;
      case GL_DEPTH_CLAMP:
         CHECK_EXT1(ARB_depth_clamp, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->Transform.DepthClamp);
         break;
      case GL_MAX_DRAW_BUFFERS_ARB:
         params[0] = (GLint64)(ctx->Const.MaxDrawBuffers);
         break;
      case GL_DRAW_BUFFER0_ARB:
         params[0] = ENUM_TO_INT64(ctx->DrawBuffer->ColorDrawBuffer[0]);
         break;
      case GL_DRAW_BUFFER1_ARB:
         {
         GLenum buffer;
         if (pname - GL_DRAW_BUFFER0_ARB >= ctx->Const.MaxDrawBuffers) {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGet(GL_DRAW_BUFFERx_ARB)");
            return;
         }
         buffer = ctx->DrawBuffer->ColorDrawBuffer[1];
         params[0] = ENUM_TO_INT64(buffer);
         }
         break;
      case GL_DRAW_BUFFER2_ARB:
         {
         GLenum buffer;
         if (pname - GL_DRAW_BUFFER0_ARB >= ctx->Const.MaxDrawBuffers) {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGet(GL_DRAW_BUFFERx_ARB)");
            return;
         }
         buffer = ctx->DrawBuffer->ColorDrawBuffer[2];
         params[0] = ENUM_TO_INT64(buffer);
         }
         break;
      case GL_DRAW_BUFFER3_ARB:
         {
         GLenum buffer;
         if (pname - GL_DRAW_BUFFER0_ARB >= ctx->Const.MaxDrawBuffers) {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGet(GL_DRAW_BUFFERx_ARB)");
            return;
         }
         buffer = ctx->DrawBuffer->ColorDrawBuffer[3];
         params[0] = ENUM_TO_INT64(buffer);
         }
         break;
      case GL_IMPLEMENTATION_COLOR_READ_TYPE_OES:
         CHECK_EXT1(OES_read_format, "GetInteger64v");
         params[0] = (GLint64)(_mesa_get_color_read_type(ctx));
         break;
      case GL_IMPLEMENTATION_COLOR_READ_FORMAT_OES:
         CHECK_EXT1(OES_read_format, "GetInteger64v");
         params[0] = (GLint64)(_mesa_get_color_read_format(ctx));
         break;
      case GL_NUM_FRAGMENT_REGISTERS_ATI:
         CHECK_EXT1(ATI_fragment_shader, "GetInteger64v");
         params[0] = (GLint64)(6);
         break;
      case GL_NUM_FRAGMENT_CONSTANTS_ATI:
         CHECK_EXT1(ATI_fragment_shader, "GetInteger64v");
         params[0] = (GLint64)(8);
         break;
      case GL_NUM_PASSES_ATI:
         CHECK_EXT1(ATI_fragment_shader, "GetInteger64v");
         params[0] = (GLint64)(2);
         break;
      case GL_NUM_INSTRUCTIONS_PER_PASS_ATI:
         CHECK_EXT1(ATI_fragment_shader, "GetInteger64v");
         params[0] = (GLint64)(8);
         break;
      case GL_NUM_INSTRUCTIONS_TOTAL_ATI:
         CHECK_EXT1(ATI_fragment_shader, "GetInteger64v");
         params[0] = (GLint64)(16);
         break;
      case GL_COLOR_ALPHA_PAIRING_ATI:
         CHECK_EXT1(ATI_fragment_shader, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(GL_TRUE);
         break;
      case GL_NUM_LOOPBACK_COMPONENTS_ATI:
         CHECK_EXT1(ATI_fragment_shader, "GetInteger64v");
         params[0] = (GLint64)(3);
         break;
      case GL_NUM_INPUT_INTERPOLATOR_COMPONENTS_ATI:
         CHECK_EXT1(ATI_fragment_shader, "GetInteger64v");
         params[0] = (GLint64)(3);
         break;
      case GL_STENCIL_BACK_FUNC:
         params[0] = ENUM_TO_INT64(ctx->Stencil.Function[1]);
         break;
      case GL_STENCIL_BACK_VALUE_MASK:
         params[0] = (GLint64)(ctx->Stencil.ValueMask[1]);
         break;
      case GL_STENCIL_BACK_WRITEMASK:
         params[0] = (GLint64)(ctx->Stencil.WriteMask[1]);
         break;
      case GL_STENCIL_BACK_REF:
         params[0] = (GLint64)(ctx->Stencil.Ref[1]);
         break;
      case GL_STENCIL_BACK_FAIL:
         params[0] = ENUM_TO_INT64(ctx->Stencil.FailFunc[1]);
         break;
      case GL_STENCIL_BACK_PASS_DEPTH_FAIL:
         params[0] = ENUM_TO_INT64(ctx->Stencil.ZFailFunc[1]);
         break;
      case GL_STENCIL_BACK_PASS_DEPTH_PASS:
         params[0] = ENUM_TO_INT64(ctx->Stencil.ZPassFunc[1]);
         break;
      case GL_FRAMEBUFFER_BINDING_EXT:
         CHECK_EXT1(EXT_framebuffer_object, "GetInteger64v");
         params[0] = (GLint64)(ctx->DrawBuffer->Name);
         break;
      case GL_RENDERBUFFER_BINDING_EXT:
         CHECK_EXT1(EXT_framebuffer_object, "GetInteger64v");
         params[0] = (GLint64)(ctx->CurrentRenderbuffer ? ctx->CurrentRenderbuffer->Name : 0);
         break;
      case GL_MAX_COLOR_ATTACHMENTS_EXT:
         CHECK_EXT1(EXT_framebuffer_object, "GetInteger64v");
         params[0] = (GLint64)(ctx->Const.MaxColorAttachments);
         break;
      case GL_MAX_RENDERBUFFER_SIZE_EXT:
         CHECK_EXT1(EXT_framebuffer_object, "GetInteger64v");
         params[0] = (GLint64)(ctx->Const.MaxRenderbufferSize);
         break;
      case GL_READ_FRAMEBUFFER_BINDING_EXT:
         CHECK_EXT1(EXT_framebuffer_blit, "GetInteger64v");
         params[0] = (GLint64)(ctx->ReadBuffer->Name);
         break;
      case GL_PROVOKING_VERTEX_EXT:
         CHECK_EXT1(EXT_provoking_vertex, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->Light.ProvokingVertex);
         break;
      case GL_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION_EXT:
         CHECK_EXT1(EXT_provoking_vertex, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->Const.QuadsFollowProvokingVertexConvention);
         break;
      case GL_MAX_FRAGMENT_UNIFORM_COMPONENTS_ARB:
         CHECK_EXT1(ARB_fragment_shader, "GetInteger64v");
         params[0] = (GLint64)(ctx->Const.FragmentProgram.MaxUniformComponents);
         break;
      case GL_FRAGMENT_SHADER_DERIVATIVE_HINT_ARB:
         CHECK_EXT1(ARB_fragment_shader, "GetInteger64v");
         params[0] = ENUM_TO_INT64(ctx->Hint.FragmentShaderDerivative);
         break;
      case GL_MAX_VERTEX_UNIFORM_COMPONENTS_ARB:
         CHECK_EXT1(ARB_vertex_shader, "GetInteger64v");
         params[0] = (GLint64)(ctx->Const.VertexProgram.MaxUniformComponents);
         break;
      case GL_MAX_VARYING_FLOATS_ARB:
         CHECK_EXT1(ARB_vertex_shader, "GetInteger64v");
         params[0] = (GLint64)(ctx->Const.MaxVarying * 4);
         break;
      case GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS_ARB:
         CHECK_EXT1(ARB_vertex_shader, "GetInteger64v");
         params[0] = (GLint64)(ctx->Const.MaxVertexTextureImageUnits);
         break;
      case GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS_ARB:
         CHECK_EXT1(ARB_vertex_shader, "GetInteger64v");
         params[0] = (GLint64)(ctx->Const.MaxCombinedTextureImageUnits);
         break;
      case GL_CURRENT_PROGRAM:
         CHECK_EXT1(ARB_shader_objects, "GetInteger64v");
         params[0] = (GLint64)(ctx->Shader.CurrentProgram ? ctx->Shader.CurrentProgram->Name : 0);
         break;
      case GL_MAX_SAMPLES:
         CHECK_EXT1(ARB_framebuffer_object, "GetInteger64v");
         params[0] = (GLint64)(ctx->Const.MaxSamples);
         break;
      case GL_VERTEX_ARRAY_BINDING_APPLE:
         CHECK_EXT1(APPLE_vertex_array_object, "GetInteger64v");
         params[0] = (GLint64)(ctx->Array.ArrayObj->Name);
         break;
      case GL_TEXTURE_CUBE_MAP_SEAMLESS:
         CHECK_EXT1(ARB_seamless_cube_map, "GetInteger64v");
         params[0] = BOOLEAN_TO_INT64(ctx->Texture.CubeMapSeamless);
         break;
      case GL_MAX_SERVER_WAIT_TIMEOUT:
         CHECK_EXT1(ARB_sync, "GetInteger64v");
         params[0] = ctx->Const.MaxServerWaitTimeout;
         break;
      case GL_NUM_EXTENSIONS:
         params[0] = (GLint64)(_mesa_get_extension_count(ctx));
         break;
      case GL_MAJOR_VERSION:
         params[0] = (GLint64)(ctx->VersionMajor);
         break;
      case GL_MINOR_VERSION:
         params[0] = (GLint64)(ctx->VersionMinor);
         break;
      default:
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetInteger64v(pname=0x%x)", pname);
d2174 83
d2258 2
a2259 2
void GLAPIENTRY
_mesa_GetDoublev( GLenum pname, GLdouble *params )
d2261 1
a2261 3
   const GLfloat magic = -1234.5F;
   GLfloat values[16];
   GLuint i;
d2263 1
a2263 2
   if (!params)
      return;
d2265 43
a2307 5
   /* Init temp array to magic numbers so we can figure out how many values
    * are returned by the GetFloatv() call.
    */
   for (i = 0; i < 16; i++)
      values[i] = magic;
d2309 8
a2316 4
   _mesa_GetFloatv(pname, values);
   
   for (i = 0; i < 16 && values[i] != magic; i++)
      params[i] = (GLdouble) values[i];
d2322 19
a2340 29
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   if (!params)
      return;

   if (ctx->NewState)
      _mesa_update_state(ctx);

   switch (pname) {
      case GL_BLEND:
         CHECK_EXT1(EXT_draw_buffers2, "GetBooleanIndexedv");
         if (index >= ctx->Const.MaxDrawBuffers) {
            _mesa_error(ctx, GL_INVALID_VALUE, "glGetBooleanIndexedv(index=%u), index", pname);
         }
         params[0] = INT_TO_BOOLEAN(((ctx->Color.BlendEnabled >> index) & 1));
         break;
      case GL_COLOR_WRITEMASK:
         CHECK_EXT1(EXT_draw_buffers2, "GetBooleanIndexedv");
         if (index >= ctx->Const.MaxDrawBuffers) {
            _mesa_error(ctx, GL_INVALID_VALUE, "glGetBooleanIndexedv(index=%u), index", pname);
         }
         params[0] = INT_TO_BOOLEAN(ctx->Color.ColorMask[index][RCOMP] ? 1 : 0);
         params[1] = INT_TO_BOOLEAN(ctx->Color.ColorMask[index][GCOMP] ? 1 : 0);
         params[2] = INT_TO_BOOLEAN(ctx->Color.ColorMask[index][BCOMP] ? 1 : 0);
         params[3] = INT_TO_BOOLEAN(ctx->Color.ColorMask[index][ACOMP] ? 1 : 0);
         break;
      default:
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetBooleanIndexedv(pname=0x%x)", pname);
d2347 19
a2365 29
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   if (!params)
      return;

   if (ctx->NewState)
      _mesa_update_state(ctx);

   switch (pname) {
      case GL_BLEND:
         CHECK_EXT1(EXT_draw_buffers2, "GetIntegerIndexedv");
         if (index >= ctx->Const.MaxDrawBuffers) {
            _mesa_error(ctx, GL_INVALID_VALUE, "glGetIntegerIndexedv(index=%u), index", pname);
         }
         params[0] = ((ctx->Color.BlendEnabled >> index) & 1);
         break;
      case GL_COLOR_WRITEMASK:
         CHECK_EXT1(EXT_draw_buffers2, "GetIntegerIndexedv");
         if (index >= ctx->Const.MaxDrawBuffers) {
            _mesa_error(ctx, GL_INVALID_VALUE, "glGetIntegerIndexedv(index=%u), index", pname);
         }
         params[0] = ctx->Color.ColorMask[index][RCOMP] ? 1 : 0;
         params[1] = ctx->Color.ColorMask[index][GCOMP] ? 1 : 0;
         params[2] = ctx->Color.ColorMask[index][BCOMP] ? 1 : 0;
         params[3] = ctx->Color.ColorMask[index][ACOMP] ? 1 : 0;
         break;
      default:
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetIntegerIndexedv(pname=0x%x)", pname);
d2373 19
a2391 29
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   if (!params)
      return;

   if (ctx->NewState)
      _mesa_update_state(ctx);

   switch (pname) {
      case GL_BLEND:
         CHECK_EXT1(EXT_draw_buffers2, "GetInteger64Indexedv");
         if (index >= ctx->Const.MaxDrawBuffers) {
            _mesa_error(ctx, GL_INVALID_VALUE, "glGetInteger64Indexedv(index=%u), index", pname);
         }
         params[0] = (GLint64)(((ctx->Color.BlendEnabled >> index) & 1));
         break;
      case GL_COLOR_WRITEMASK:
         CHECK_EXT1(EXT_draw_buffers2, "GetInteger64Indexedv");
         if (index >= ctx->Const.MaxDrawBuffers) {
            _mesa_error(ctx, GL_INVALID_VALUE, "glGetInteger64Indexedv(index=%u), index", pname);
         }
         params[0] = (GLint64)(ctx->Color.ColorMask[index][RCOMP] ? 1 : 0);
         params[1] = (GLint64)(ctx->Color.ColorMask[index][GCOMP] ? 1 : 0);
         params[2] = (GLint64)(ctx->Color.ColorMask[index][BCOMP] ? 1 : 0);
         params[3] = (GLint64)(ctx->Color.ColorMask[index][ACOMP] ? 1 : 0);
         break;
      default:
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetInteger64Indexedv(pname=0x%x)", pname);
d2396 85
@


1.4
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@a9 1
#include "fbobject.h"
d15 1
d22 3
d26 1
d29 2
d134 1
a134 1
         params[0] = ctx->Color.BlendEnabled;
d212 4
a215 4
         params[0] = INT_TO_BOOLEAN(ctx->Color.ColorMask[RCOMP] ? 1 : 0);
         params[1] = INT_TO_BOOLEAN(ctx->Color.ColorMask[GCOMP] ? 1 : 0);
         params[2] = INT_TO_BOOLEAN(ctx->Color.ColorMask[BCOMP] ? 1 : 0);
         params[3] = INT_TO_BOOLEAN(ctx->Color.ColorMask[ACOMP] ? 1 : 0);
d256 1
a256 1
         params[0] = FLOAT_TO_BOOLEAN(ctx->Current.RasterIndex);
d272 10
a281 5
         const GLuint texUnit = ctx->Texture.CurrentUnit;
         params[0] = FLOAT_TO_BOOLEAN(ctx->Current.RasterTexCoords[texUnit][0]);
         params[1] = FLOAT_TO_BOOLEAN(ctx->Current.RasterTexCoords[texUnit][1]);
         params[2] = FLOAT_TO_BOOLEAN(ctx->Current.RasterTexCoords[texUnit][2]);
         params[3] = FLOAT_TO_BOOLEAN(ctx->Current.RasterTexCoords[texUnit][3]);
d289 11
a299 5
         const GLuint texUnit = ctx->Texture.CurrentUnit;
         params[0] = FLOAT_TO_BOOLEAN(ctx->Current.Attrib[VERT_ATTRIB_TEX0 + texUnit][0]);
         params[1] = FLOAT_TO_BOOLEAN(ctx->Current.Attrib[VERT_ATTRIB_TEX0 + texUnit][1]);
         params[2] = FLOAT_TO_BOOLEAN(ctx->Current.Attrib[VERT_ATTRIB_TEX0 + texUnit][2]);
         params[3] = FLOAT_TO_BOOLEAN(ctx->Current.Attrib[VERT_ATTRIB_TEX0 + texUnit][3]);
d394 1
a394 1
         params[0] = !ctx->DrawBuffer->Visual.rgbMode;
d480 1
a480 1
         params[0] = INT_TO_BOOLEAN(ctx->ListState.CurrentListNum);
d830 1
a830 1
         params[0] = ctx->DrawBuffer->Visual.rgbMode;
d934 8
a941 1
         const GLfloat *matrix = ctx->TextureMatrixStack[ctx->Texture.CurrentUnit].Top->m;
d961 9
a969 1
         params[0] = INT_TO_BOOLEAN(ctx->TextureMatrixStack[ctx->Texture.CurrentUnit].Depth + 1);
a1112 1
         CHECK_EXT1(ARB_texture_compression, "GetBooleanv");
a1115 1
         CHECK_EXT1(ARB_texture_compression, "GetBooleanv");
a1118 1
         CHECK_EXT1(ARB_texture_compression, "GetBooleanv");
a1399 1
         CHECK_EXT1(ARB_multisample, "GetBooleanv");
a1402 1
         CHECK_EXT1(ARB_multisample, "GetBooleanv");
a1405 1
         CHECK_EXT1(ARB_multisample, "GetBooleanv");
a1408 1
         CHECK_EXT1(ARB_multisample, "GetBooleanv");
a1411 1
         CHECK_EXT1(ARB_multisample, "GetBooleanv");
a1414 1
         CHECK_EXT1(ARB_multisample, "GetBooleanv");
a1417 1
         CHECK_EXT1(ARB_multisample, "GetBooleanv");
a1420 1
         CHECK_EXT1(ARB_multisample, "GetBooleanv");
a1615 1
         CHECK_EXT1(ARB_vertex_buffer_object, "GetBooleanv");
a1618 1
         CHECK_EXT1(ARB_vertex_buffer_object, "GetBooleanv");
a1621 1
         CHECK_EXT1(ARB_vertex_buffer_object, "GetBooleanv");
a1624 1
         CHECK_EXT1(ARB_vertex_buffer_object, "GetBooleanv");
a1627 1
         CHECK_EXT1(ARB_vertex_buffer_object, "GetBooleanv");
a1630 1
         CHECK_EXT1(ARB_vertex_buffer_object, "GetBooleanv");
a1633 1
         CHECK_EXT1(ARB_vertex_buffer_object, "GetBooleanv");
a1636 1
         CHECK_EXT1(ARB_vertex_buffer_object, "GetBooleanv");
a1639 1
         CHECK_EXT1(ARB_vertex_buffer_object, "GetBooleanv");
a1642 1
         CHECK_EXT1(ARB_vertex_buffer_object, "GetBooleanv");
d1750 3
a1752 15
      case GL_FRAGMENT_PROGRAM_CALLBACK_MESA:
         CHECK_EXT1(MESA_program_debug, "GetBooleanv");
         params[0] = ctx->FragmentProgram.CallbackEnabled;
         break;
      case GL_VERTEX_PROGRAM_CALLBACK_MESA:
         CHECK_EXT1(MESA_program_debug, "GetBooleanv");
         params[0] = ctx->VertexProgram.CallbackEnabled;
         break;
      case GL_FRAGMENT_PROGRAM_POSITION_MESA:
         CHECK_EXT1(MESA_program_debug, "GetBooleanv");
         params[0] = INT_TO_BOOLEAN(ctx->FragmentProgram.CurrentPosition);
         break;
      case GL_VERTEX_PROGRAM_POSITION_MESA:
         CHECK_EXT1(MESA_program_debug, "GetBooleanv");
         params[0] = INT_TO_BOOLEAN(ctx->VertexProgram.CurrentPosition);
a1754 1
         CHECK_EXT1(ARB_draw_buffers, "GetBooleanv");
a1757 1
         CHECK_EXT1(ARB_draw_buffers, "GetBooleanv");
a1760 1
         CHECK_EXT1(ARB_draw_buffers, "GetBooleanv");
a1771 1
         CHECK_EXT1(ARB_draw_buffers, "GetBooleanv");
a1782 1
         CHECK_EXT1(ARB_draw_buffers, "GetBooleanv");
d1795 1
a1795 1
         params[0] = INT_TO_BOOLEAN(ctx->Const.ColorReadType);
d1799 1
a1799 1
         params[0] = INT_TO_BOOLEAN(ctx->Const.ColorReadFormat);
d1874 8
d1904 1
a1904 1
         params[0] = INT_TO_BOOLEAN(MAX_COMBINED_TEXTURE_IMAGE_UNITS);
d1910 25
d2003 1
a2003 1
         params[0] = BOOLEAN_TO_FLOAT(ctx->Color.BlendEnabled);
d2081 4
a2084 4
         params[0] = (GLfloat)(ctx->Color.ColorMask[RCOMP] ? 1 : 0);
         params[1] = (GLfloat)(ctx->Color.ColorMask[GCOMP] ? 1 : 0);
         params[2] = (GLfloat)(ctx->Color.ColorMask[BCOMP] ? 1 : 0);
         params[3] = (GLfloat)(ctx->Color.ColorMask[ACOMP] ? 1 : 0);
d2125 1
a2125 1
         params[0] = ctx->Current.RasterIndex;
d2141 10
a2150 5
         const GLuint texUnit = ctx->Texture.CurrentUnit;
         params[0] = ctx->Current.RasterTexCoords[texUnit][0];
         params[1] = ctx->Current.RasterTexCoords[texUnit][1];
         params[2] = ctx->Current.RasterTexCoords[texUnit][2];
         params[3] = ctx->Current.RasterTexCoords[texUnit][3];
d2158 11
a2168 5
         const GLuint texUnit = ctx->Texture.CurrentUnit;
         params[0] = ctx->Current.Attrib[VERT_ATTRIB_TEX0 + texUnit][0];
         params[1] = ctx->Current.Attrib[VERT_ATTRIB_TEX0 + texUnit][1];
         params[2] = ctx->Current.Attrib[VERT_ATTRIB_TEX0 + texUnit][2];
         params[3] = ctx->Current.Attrib[VERT_ATTRIB_TEX0 + texUnit][3];
d2263 1
a2263 1
         params[0] = BOOLEAN_TO_FLOAT(!ctx->DrawBuffer->Visual.rgbMode);
d2349 1
a2349 1
         params[0] = (GLfloat)(ctx->ListState.CurrentListNum);
d2699 1
a2699 1
         params[0] = BOOLEAN_TO_FLOAT(ctx->DrawBuffer->Visual.rgbMode);
d2803 8
a2810 1
         const GLfloat *matrix = ctx->TextureMatrixStack[ctx->Texture.CurrentUnit].Top->m;
d2830 9
a2838 1
         params[0] = (GLfloat)(ctx->TextureMatrixStack[ctx->Texture.CurrentUnit].Depth + 1);
a2981 1
         CHECK_EXT1(ARB_texture_compression, "GetFloatv");
a2984 1
         CHECK_EXT1(ARB_texture_compression, "GetFloatv");
a2987 1
         CHECK_EXT1(ARB_texture_compression, "GetFloatv");
a3268 1
         CHECK_EXT1(ARB_multisample, "GetFloatv");
a3271 1
         CHECK_EXT1(ARB_multisample, "GetFloatv");
a3274 1
         CHECK_EXT1(ARB_multisample, "GetFloatv");
a3277 1
         CHECK_EXT1(ARB_multisample, "GetFloatv");
a3280 1
         CHECK_EXT1(ARB_multisample, "GetFloatv");
a3283 1
         CHECK_EXT1(ARB_multisample, "GetFloatv");
a3286 1
         CHECK_EXT1(ARB_multisample, "GetFloatv");
a3289 1
         CHECK_EXT1(ARB_multisample, "GetFloatv");
a3484 1
         CHECK_EXT1(ARB_vertex_buffer_object, "GetFloatv");
a3487 1
         CHECK_EXT1(ARB_vertex_buffer_object, "GetFloatv");
a3490 1
         CHECK_EXT1(ARB_vertex_buffer_object, "GetFloatv");
a3493 1
         CHECK_EXT1(ARB_vertex_buffer_object, "GetFloatv");
a3496 1
         CHECK_EXT1(ARB_vertex_buffer_object, "GetFloatv");
a3499 1
         CHECK_EXT1(ARB_vertex_buffer_object, "GetFloatv");
a3502 1
         CHECK_EXT1(ARB_vertex_buffer_object, "GetFloatv");
a3505 1
         CHECK_EXT1(ARB_vertex_buffer_object, "GetFloatv");
a3508 1
         CHECK_EXT1(ARB_vertex_buffer_object, "GetFloatv");
a3511 1
         CHECK_EXT1(ARB_vertex_buffer_object, "GetFloatv");
d3619 3
a3621 15
      case GL_FRAGMENT_PROGRAM_CALLBACK_MESA:
         CHECK_EXT1(MESA_program_debug, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->FragmentProgram.CallbackEnabled);
         break;
      case GL_VERTEX_PROGRAM_CALLBACK_MESA:
         CHECK_EXT1(MESA_program_debug, "GetFloatv");
         params[0] = BOOLEAN_TO_FLOAT(ctx->VertexProgram.CallbackEnabled);
         break;
      case GL_FRAGMENT_PROGRAM_POSITION_MESA:
         CHECK_EXT1(MESA_program_debug, "GetFloatv");
         params[0] = (GLfloat)(ctx->FragmentProgram.CurrentPosition);
         break;
      case GL_VERTEX_PROGRAM_POSITION_MESA:
         CHECK_EXT1(MESA_program_debug, "GetFloatv");
         params[0] = (GLfloat)(ctx->VertexProgram.CurrentPosition);
a3623 1
         CHECK_EXT1(ARB_draw_buffers, "GetFloatv");
a3626 1
         CHECK_EXT1(ARB_draw_buffers, "GetFloatv");
a3629 1
         CHECK_EXT1(ARB_draw_buffers, "GetFloatv");
a3640 1
         CHECK_EXT1(ARB_draw_buffers, "GetFloatv");
a3651 1
         CHECK_EXT1(ARB_draw_buffers, "GetFloatv");
d3664 1
a3664 1
         params[0] = (GLfloat)(ctx->Const.ColorReadType);
d3668 1
a3668 1
         params[0] = (GLfloat)(ctx->Const.ColorReadFormat);
d3743 8
d3773 1
a3773 1
         params[0] = (GLfloat)(MAX_COMBINED_TEXTURE_IMAGE_UNITS);
d3779 25
d3872 1
a3872 1
         params[0] = BOOLEAN_TO_INT(ctx->Color.BlendEnabled);
d3950 4
a3953 4
         params[0] = ctx->Color.ColorMask[RCOMP] ? 1 : 0;
         params[1] = ctx->Color.ColorMask[GCOMP] ? 1 : 0;
         params[2] = ctx->Color.ColorMask[BCOMP] ? 1 : 0;
         params[3] = ctx->Color.ColorMask[ACOMP] ? 1 : 0;
d3994 1
a3994 1
         params[0] = IROUND(ctx->Current.RasterIndex);
d4010 10
a4019 5
         const GLuint texUnit = ctx->Texture.CurrentUnit;
         params[0] = IROUND(ctx->Current.RasterTexCoords[texUnit][0]);
         params[1] = IROUND(ctx->Current.RasterTexCoords[texUnit][1]);
         params[2] = IROUND(ctx->Current.RasterTexCoords[texUnit][2]);
         params[3] = IROUND(ctx->Current.RasterTexCoords[texUnit][3]);
d4027 11
a4037 5
         const GLuint texUnit = ctx->Texture.CurrentUnit;
         params[0] = IROUND(ctx->Current.Attrib[VERT_ATTRIB_TEX0 + texUnit][0]);
         params[1] = IROUND(ctx->Current.Attrib[VERT_ATTRIB_TEX0 + texUnit][1]);
         params[2] = IROUND(ctx->Current.Attrib[VERT_ATTRIB_TEX0 + texUnit][2]);
         params[3] = IROUND(ctx->Current.Attrib[VERT_ATTRIB_TEX0 + texUnit][3]);
d4132 1
a4132 1
         params[0] = BOOLEAN_TO_INT(!ctx->DrawBuffer->Visual.rgbMode);
d4218 1
a4218 1
         params[0] = ctx->ListState.CurrentListNum;
d4568 1
a4568 1
         params[0] = BOOLEAN_TO_INT(ctx->DrawBuffer->Visual.rgbMode);
d4672 8
a4679 1
         const GLfloat *matrix = ctx->TextureMatrixStack[ctx->Texture.CurrentUnit].Top->m;
d4699 9
a4707 1
         params[0] = ctx->TextureMatrixStack[ctx->Texture.CurrentUnit].Depth + 1;
a4850 1
         CHECK_EXT1(ARB_texture_compression, "GetIntegerv");
a4853 1
         CHECK_EXT1(ARB_texture_compression, "GetIntegerv");
a4856 1
         CHECK_EXT1(ARB_texture_compression, "GetIntegerv");
a5137 1
         CHECK_EXT1(ARB_multisample, "GetIntegerv");
a5140 1
         CHECK_EXT1(ARB_multisample, "GetIntegerv");
a5143 1
         CHECK_EXT1(ARB_multisample, "GetIntegerv");
a5146 1
         CHECK_EXT1(ARB_multisample, "GetIntegerv");
a5149 1
         CHECK_EXT1(ARB_multisample, "GetIntegerv");
a5152 1
         CHECK_EXT1(ARB_multisample, "GetIntegerv");
a5155 1
         CHECK_EXT1(ARB_multisample, "GetIntegerv");
a5158 1
         CHECK_EXT1(ARB_multisample, "GetIntegerv");
a5353 1
         CHECK_EXT1(ARB_vertex_buffer_object, "GetIntegerv");
a5356 1
         CHECK_EXT1(ARB_vertex_buffer_object, "GetIntegerv");
a5359 1
         CHECK_EXT1(ARB_vertex_buffer_object, "GetIntegerv");
a5362 1
         CHECK_EXT1(ARB_vertex_buffer_object, "GetIntegerv");
a5365 1
         CHECK_EXT1(ARB_vertex_buffer_object, "GetIntegerv");
a5368 1
         CHECK_EXT1(ARB_vertex_buffer_object, "GetIntegerv");
a5371 1
         CHECK_EXT1(ARB_vertex_buffer_object, "GetIntegerv");
a5374 1
         CHECK_EXT1(ARB_vertex_buffer_object, "GetIntegerv");
a5377 1
         CHECK_EXT1(ARB_vertex_buffer_object, "GetIntegerv");
a5380 1
         CHECK_EXT1(ARB_vertex_buffer_object, "GetIntegerv");
d5488 3
a5490 15
      case GL_FRAGMENT_PROGRAM_CALLBACK_MESA:
         CHECK_EXT1(MESA_program_debug, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->FragmentProgram.CallbackEnabled);
         break;
      case GL_VERTEX_PROGRAM_CALLBACK_MESA:
         CHECK_EXT1(MESA_program_debug, "GetIntegerv");
         params[0] = BOOLEAN_TO_INT(ctx->VertexProgram.CallbackEnabled);
         break;
      case GL_FRAGMENT_PROGRAM_POSITION_MESA:
         CHECK_EXT1(MESA_program_debug, "GetIntegerv");
         params[0] = ctx->FragmentProgram.CurrentPosition;
         break;
      case GL_VERTEX_PROGRAM_POSITION_MESA:
         CHECK_EXT1(MESA_program_debug, "GetIntegerv");
         params[0] = ctx->VertexProgram.CurrentPosition;
a5492 1
         CHECK_EXT1(ARB_draw_buffers, "GetIntegerv");
a5495 1
         CHECK_EXT1(ARB_draw_buffers, "GetIntegerv");
a5498 1
         CHECK_EXT1(ARB_draw_buffers, "GetIntegerv");
a5509 1
         CHECK_EXT1(ARB_draw_buffers, "GetIntegerv");
a5520 1
         CHECK_EXT1(ARB_draw_buffers, "GetIntegerv");
d5533 1
a5533 1
         params[0] = ctx->Const.ColorReadType;
d5537 1
a5537 1
         params[0] = ctx->Const.ColorReadFormat;
d5612 8
d5642 1
a5642 1
         params[0] = MAX_COMBINED_TEXTURE_IMAGE_UNITS;
d5648 25
d5678 1
a5678 1

d5680 1
a5680 1
_mesa_GetDoublev( GLenum pname, GLdouble *params )
d5682 2
a5683 3
   const GLfloat magic = -1234.5F;
   GLfloat values[16];
   GLuint i;
d5688 1877
a7564 5
   /* Init temp array to magic numbers so we can figure out how many values
    * are returned by the GetFloatv() call.
    */
   for (i = 0; i < 16; i++)
      values[i] = magic;
d7571 107
@


1.3
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@a21 4
#define ENUM_TO_BOOLEAN(E)    ( (E) ? GL_TRUE : GL_FALSE )
#define ENUM_TO_INT(E)        ( (GLint) (E) )
#define ENUM_TO_FLOAT(E)      ( (GLfloat) (E) )

d292 1
a292 1
         params[0] = FLOAT_TO_BOOLEAN(ctx->Depth.Clear);
d887 1
a887 1
         params[0] = INT_TO_BOOLEAN(ctx->Texture.Unit[ctx->Texture.CurrentUnit].Current1D->Name);
d890 1
a890 1
         params[0] = INT_TO_BOOLEAN(ctx->Texture.Unit[ctx->Texture.CurrentUnit].Current2D->Name);
d893 1
a893 1
         params[0] = INT_TO_BOOLEAN(ctx->Texture.Unit[ctx->Texture.CurrentUnit].Current3D->Name);
d897 1
a897 1
         params[0] = INT_TO_BOOLEAN(ctx->Texture.Unit[ctx->Texture.CurrentUnit].Current1DArray->Name);
d901 1
a901 1
         params[0] = INT_TO_BOOLEAN(ctx->Texture.Unit[ctx->Texture.CurrentUnit].Current2DArray->Name);
d1074 1
a1074 1
         params[0] = INT_TO_BOOLEAN(ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentCubeMap->Name);
d1095 1
a1095 1
            params[i] = ENUM_TO_INT(formats[i]);
d1572 1
a1572 1
         params[0] = INT_TO_BOOLEAN(ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentRect->Name);
d2140 1
a2140 1
         params[0] = ctx->Depth.Clear;
d2735 1
a2735 1
         params[0] = (GLfloat)(ctx->Texture.Unit[ctx->Texture.CurrentUnit].Current1D->Name);
d2738 1
a2738 1
         params[0] = (GLfloat)(ctx->Texture.Unit[ctx->Texture.CurrentUnit].Current2D->Name);
d2741 1
a2741 1
         params[0] = (GLfloat)(ctx->Texture.Unit[ctx->Texture.CurrentUnit].Current3D->Name);
d2745 1
a2745 1
         params[0] = (GLfloat)(ctx->Texture.Unit[ctx->Texture.CurrentUnit].Current1DArray->Name);
d2749 1
a2749 1
         params[0] = (GLfloat)(ctx->Texture.Unit[ctx->Texture.CurrentUnit].Current2DArray->Name);
d2922 1
a2922 1
         params[0] = (GLfloat)(ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentCubeMap->Name);
d2943 1
a2943 1
            params[i] = ENUM_TO_INT(formats[i]);
d3420 1
a3420 1
         params[0] = (GLfloat)(ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentRect->Name);
d3988 1
a3988 1
         params[0] = FLOAT_TO_INT(ctx->Depth.Clear);
d4583 1
a4583 1
         params[0] = ctx->Texture.Unit[ctx->Texture.CurrentUnit].Current1D->Name;
d4586 1
a4586 1
         params[0] = ctx->Texture.Unit[ctx->Texture.CurrentUnit].Current2D->Name;
d4589 1
a4589 1
         params[0] = ctx->Texture.Unit[ctx->Texture.CurrentUnit].Current3D->Name;
d4593 1
a4593 1
         params[0] = ctx->Texture.Unit[ctx->Texture.CurrentUnit].Current1DArray->Name;
d4597 1
a4597 1
         params[0] = ctx->Texture.Unit[ctx->Texture.CurrentUnit].Current2DArray->Name;
d4770 1
a4770 1
         params[0] = ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentCubeMap->Name;
d5268 1
a5268 1
         params[0] = ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentRect->Name;
@


1.2
log
@Update to Mesa 7.0.3. tested my oga@@ and johan@@
@
text
@d756 9
d882 8
d899 7
a905 11
      case GL_TEXTURE_ENV_COLOR:
         {
         const GLfloat *color = ctx->Texture.Unit[ctx->Texture.CurrentUnit].EnvColor;
         params[0] = FLOAT_TO_BOOLEAN(color[0]);
         params[1] = FLOAT_TO_BOOLEAN(color[1]);
         params[2] = FLOAT_TO_BOOLEAN(color[2]);
         params[3] = FLOAT_TO_BOOLEAN(color[3]);
         }
         break;
      case GL_TEXTURE_ENV_MODE:
         params[0] = ENUM_TO_BOOLEAN(ctx->Texture.Unit[ctx->Texture.CurrentUnit].EnvMode);
d2604 9
d2730 8
d2747 7
a2753 11
      case GL_TEXTURE_ENV_COLOR:
         {
         const GLfloat *color = ctx->Texture.Unit[ctx->Texture.CurrentUnit].EnvColor;
         params[0] = color[0];
         params[1] = color[1];
         params[2] = color[2];
         params[3] = color[3];
         }
         break;
      case GL_TEXTURE_ENV_MODE:
         params[0] = ENUM_TO_FLOAT(ctx->Texture.Unit[ctx->Texture.CurrentUnit].EnvMode);
d3992 1
a3992 1
         params[0] = IROUND(ctx->Depth.Clear);
d4452 9
d4578 8
d4595 7
a4601 11
      case GL_TEXTURE_ENV_COLOR:
         {
         const GLfloat *color = ctx->Texture.Unit[ctx->Texture.CurrentUnit].EnvColor;
         params[0] = FLOAT_TO_INT(color[0]);
         params[1] = FLOAT_TO_INT(color[1]);
         params[2] = FLOAT_TO_INT(color[2]);
         params[3] = FLOAT_TO_INT(color[3]);
         }
         break;
      case GL_TEXTURE_ENV_MODE:
         params[0] = ENUM_TO_INT(ctx->Texture.Unit[ctx->Texture.CurrentUnit].EnvMode);
@


1.1
log
@Initial revision
@
text
@d326 1
a326 1
         params[0] = ctx->Current.EdgeFlag;
d680 1
a680 1
         params[0] = INT_TO_BOOLEAN(ctx->Pixel.MapAtoAsize);
d683 1
a683 1
         params[0] = INT_TO_BOOLEAN(ctx->Pixel.MapBtoBsize);
d686 1
a686 1
         params[0] = INT_TO_BOOLEAN(ctx->Pixel.MapGtoGsize);
d689 1
a689 1
         params[0] = INT_TO_BOOLEAN(ctx->Pixel.MapItoAsize);
d692 1
a692 1
         params[0] = INT_TO_BOOLEAN(ctx->Pixel.MapItoBsize);
d695 1
a695 1
         params[0] = INT_TO_BOOLEAN(ctx->Pixel.MapItoGsize);
d698 1
a698 1
         params[0] = INT_TO_BOOLEAN(ctx->Pixel.MapItoIsize);
d701 1
a701 1
         params[0] = INT_TO_BOOLEAN(ctx->Pixel.MapItoRsize);
d704 1
a704 1
         params[0] = INT_TO_BOOLEAN(ctx->Pixel.MapRtoRsize);
d707 1
a707 1
         params[0] = INT_TO_BOOLEAN(ctx->Pixel.MapStoSsize);
d796 1
a796 1
         params[0] = INT_TO_BOOLEAN( ctx->DrawBuffer->Visual.redBits );
d1286 1
a1286 1
         params[0] = ctx->Pixel.ColorTableEnabled;
d1290 1
a1290 1
         params[0] = ctx->Pixel.PostConvolutionColorTableEnabled;
d1294 1
a1294 1
         params[0] = ctx->Pixel.PostColorMatrixColorTableEnabled;
d1836 3
d1867 4
d1873 1
a1873 1
         params[0] = INT_TO_BOOLEAN(MAX_FRAGMENT_UNIFORM_COMPONENTS);
d1881 1
a1881 1
         params[0] = INT_TO_BOOLEAN(MAX_VERTEX_UNIFORM_COMPONENTS);
d1885 1
a1885 1
         params[0] = INT_TO_BOOLEAN(MAX_VARYING_FLOATS);
d1889 1
a1889 1
         params[0] = INT_TO_BOOLEAN(MAX_VERTEX_TEXTURE_IMAGE_UNITS);
d1895 4
d2161 1
a2161 1
         params[0] = BOOLEAN_TO_FLOAT(ctx->Current.EdgeFlag);
d2515 1
a2515 1
         params[0] = (GLfloat)(ctx->Pixel.MapAtoAsize);
d2518 1
a2518 1
         params[0] = (GLfloat)(ctx->Pixel.MapBtoBsize);
d2521 1
a2521 1
         params[0] = (GLfloat)(ctx->Pixel.MapGtoGsize);
d2524 1
a2524 1
         params[0] = (GLfloat)(ctx->Pixel.MapItoAsize);
d2527 1
a2527 1
         params[0] = (GLfloat)(ctx->Pixel.MapItoBsize);
d2530 1
a2530 1
         params[0] = (GLfloat)(ctx->Pixel.MapItoGsize);
d2533 1
a2533 1
         params[0] = (GLfloat)(ctx->Pixel.MapItoIsize);
d2536 1
a2536 1
         params[0] = (GLfloat)(ctx->Pixel.MapItoRsize);
d2539 1
a2539 1
         params[0] = (GLfloat)(ctx->Pixel.MapRtoRsize);
d2542 1
a2542 1
         params[0] = (GLfloat)(ctx->Pixel.MapStoSsize);
d2631 1
a2631 1
         params[0] = (GLfloat)( ctx->DrawBuffer->Visual.redBits );
d3121 1
a3121 1
         params[0] = BOOLEAN_TO_FLOAT(ctx->Pixel.ColorTableEnabled);
d3125 1
a3125 1
         params[0] = BOOLEAN_TO_FLOAT(ctx->Pixel.PostConvolutionColorTableEnabled);
d3129 1
a3129 1
         params[0] = BOOLEAN_TO_FLOAT(ctx->Pixel.PostColorMatrixColorTableEnabled);
d3671 3
d3702 4
d3708 1
a3708 1
         params[0] = (GLfloat)(MAX_FRAGMENT_UNIFORM_COMPONENTS);
d3716 1
a3716 1
         params[0] = (GLfloat)(MAX_VERTEX_UNIFORM_COMPONENTS);
d3720 1
a3720 1
         params[0] = (GLfloat)(MAX_VARYING_FLOATS);
d3724 1
a3724 1
         params[0] = (GLfloat)(MAX_VERTEX_TEXTURE_IMAGE_UNITS);
d3730 4
d3996 1
a3996 1
         params[0] = BOOLEAN_TO_INT(ctx->Current.EdgeFlag);
d4350 1
a4350 1
         params[0] = ctx->Pixel.MapAtoAsize;
d4353 1
a4353 1
         params[0] = ctx->Pixel.MapBtoBsize;
d4356 1
a4356 1
         params[0] = ctx->Pixel.MapGtoGsize;
d4359 1
a4359 1
         params[0] = ctx->Pixel.MapItoAsize;
d4362 1
a4362 1
         params[0] = ctx->Pixel.MapItoBsize;
d4365 1
a4365 1
         params[0] = ctx->Pixel.MapItoGsize;
d4368 1
a4368 1
         params[0] = ctx->Pixel.MapItoIsize;
d4371 1
a4371 1
         params[0] = ctx->Pixel.MapItoRsize;
d4374 1
a4374 1
         params[0] = ctx->Pixel.MapRtoRsize;
d4377 1
a4377 1
         params[0] = ctx->Pixel.MapStoSsize;
d4466 1
a4466 1
         params[0] =  ctx->DrawBuffer->Visual.redBits ;
d4956 1
a4956 1
         params[0] = BOOLEAN_TO_INT(ctx->Pixel.ColorTableEnabled);
d4960 1
a4960 1
         params[0] = BOOLEAN_TO_INT(ctx->Pixel.PostConvolutionColorTableEnabled);
d4964 1
a4964 1
         params[0] = BOOLEAN_TO_INT(ctx->Pixel.PostColorMatrixColorTableEnabled);
d5506 3
d5537 4
d5543 1
a5543 1
         params[0] = MAX_FRAGMENT_UNIFORM_COMPONENTS;
d5551 1
a5551 1
         params[0] = MAX_VERTEX_UNIFORM_COMPONENTS;
d5555 1
a5555 1
         params[0] = MAX_VARYING_FLOATS;
d5559 1
a5559 1
         params[0] = MAX_VERTEX_TEXTURE_IMAGE_UNITS;
d5564 4
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d796 1
a796 1
         params[0] = INT_TO_BOOLEAN(ctx->DrawBuffer->Visual.redBits);
a1835 3
      case GL_STENCIL_BACK_WRITEMASK:
         params[0] = INT_TO_BOOLEAN(ctx->Stencil.WriteMask[1]);
         break;
d1866 1
a1866 1
         params[0] = INT_TO_BOOLEAN(ctx->Const.FragmentProgram.MaxUniformComponents);
d1874 1
a1874 1
         params[0] = INT_TO_BOOLEAN(ctx->Const.VertexProgram.MaxUniformComponents);
d1878 1
a1878 1
         params[0] = INT_TO_BOOLEAN(ctx->Const.MaxVaryingFloats);
d1882 1
a1882 1
         params[0] = INT_TO_BOOLEAN(ctx->Const.MaxVertexTextureImageUnits);
d2620 1
a2620 1
         params[0] = (GLfloat)(ctx->DrawBuffer->Visual.redBits);
a3659 3
      case GL_STENCIL_BACK_WRITEMASK:
         params[0] = (GLfloat)(ctx->Stencil.WriteMask[1]);
         break;
d3690 1
a3690 1
         params[0] = (GLfloat)(ctx->Const.FragmentProgram.MaxUniformComponents);
d3698 1
a3698 1
         params[0] = (GLfloat)(ctx->Const.VertexProgram.MaxUniformComponents);
d3702 1
a3702 1
         params[0] = (GLfloat)(ctx->Const.MaxVaryingFloats);
d3706 1
a3706 1
         params[0] = (GLfloat)(ctx->Const.MaxVertexTextureImageUnits);
d4444 1
a4444 1
         params[0] = ctx->DrawBuffer->Visual.redBits;
a5483 3
      case GL_STENCIL_BACK_WRITEMASK:
         params[0] = ctx->Stencil.WriteMask[1];
         break;
d5514 1
a5514 1
         params[0] = ctx->Const.FragmentProgram.MaxUniformComponents;
d5522 1
a5522 1
         params[0] = ctx->Const.VertexProgram.MaxUniformComponents;
d5526 1
a5526 1
         params[0] = ctx->Const.MaxVaryingFloats;
d5530 1
a5530 1
         params[0] = ctx->Const.MaxVertexTextureImageUnits;
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d326 1
a326 1
         params[0] = (ctx->Current.Attrib[VERT_ATTRIB_EDGEFLAG][0] == 1.0);
d680 1
a680 1
         params[0] = INT_TO_BOOLEAN(ctx->PixelMaps.AtoA.Size);
d683 1
a683 1
         params[0] = INT_TO_BOOLEAN(ctx->PixelMaps.BtoB.Size);
d686 1
a686 1
         params[0] = INT_TO_BOOLEAN(ctx->PixelMaps.GtoG.Size);
d689 1
a689 1
         params[0] = INT_TO_BOOLEAN(ctx->PixelMaps.ItoA.Size);
d692 1
a692 1
         params[0] = INT_TO_BOOLEAN(ctx->PixelMaps.ItoB.Size);
d695 1
a695 1
         params[0] = INT_TO_BOOLEAN(ctx->PixelMaps.ItoG.Size);
d698 1
a698 1
         params[0] = INT_TO_BOOLEAN(ctx->PixelMaps.ItoI.Size);
d701 1
a701 1
         params[0] = INT_TO_BOOLEAN(ctx->PixelMaps.ItoR.Size);
d704 1
a704 1
         params[0] = INT_TO_BOOLEAN(ctx->PixelMaps.RtoR.Size);
d707 1
a707 1
         params[0] = INT_TO_BOOLEAN(ctx->PixelMaps.StoS.Size);
d1286 1
a1286 1
         params[0] = ctx->Pixel.ColorTableEnabled[COLORTABLE_PRECONVOLUTION];
d1290 1
a1290 1
         params[0] = ctx->Pixel.ColorTableEnabled[COLORTABLE_POSTCONVOLUTION];
d1294 1
a1294 1
         params[0] = ctx->Pixel.ColorTableEnabled[COLORTABLE_POSTCOLORMATRIX];
d1881 1
a1881 1
         params[0] = INT_TO_BOOLEAN(ctx->Const.MaxVarying * 4);
a1890 4
      case GL_CURRENT_PROGRAM:
         CHECK_EXT1(ARB_shader_objects, "GetBooleanv");
         params[0] = INT_TO_BOOLEAN(ctx->Shader.CurrentProgram ? ctx->Shader.CurrentProgram->Name : 0);
         break;
d2153 1
a2153 1
         params[0] = BOOLEAN_TO_FLOAT((ctx->Current.Attrib[VERT_ATTRIB_EDGEFLAG][0] == 1.0));
d2507 1
a2507 1
         params[0] = (GLfloat)(ctx->PixelMaps.AtoA.Size);
d2510 1
a2510 1
         params[0] = (GLfloat)(ctx->PixelMaps.BtoB.Size);
d2513 1
a2513 1
         params[0] = (GLfloat)(ctx->PixelMaps.GtoG.Size);
d2516 1
a2516 1
         params[0] = (GLfloat)(ctx->PixelMaps.ItoA.Size);
d2519 1
a2519 1
         params[0] = (GLfloat)(ctx->PixelMaps.ItoB.Size);
d2522 1
a2522 1
         params[0] = (GLfloat)(ctx->PixelMaps.ItoG.Size);
d2525 1
a2525 1
         params[0] = (GLfloat)(ctx->PixelMaps.ItoI.Size);
d2528 1
a2528 1
         params[0] = (GLfloat)(ctx->PixelMaps.ItoR.Size);
d2531 1
a2531 1
         params[0] = (GLfloat)(ctx->PixelMaps.RtoR.Size);
d2534 1
a2534 1
         params[0] = (GLfloat)(ctx->PixelMaps.StoS.Size);
d3113 1
a3113 1
         params[0] = BOOLEAN_TO_FLOAT(ctx->Pixel.ColorTableEnabled[COLORTABLE_PRECONVOLUTION]);
d3117 1
a3117 1
         params[0] = BOOLEAN_TO_FLOAT(ctx->Pixel.ColorTableEnabled[COLORTABLE_POSTCONVOLUTION]);
d3121 1
a3121 1
         params[0] = BOOLEAN_TO_FLOAT(ctx->Pixel.ColorTableEnabled[COLORTABLE_POSTCOLORMATRIX]);
d3708 1
a3708 1
         params[0] = (GLfloat)(ctx->Const.MaxVarying * 4);
a3717 4
      case GL_CURRENT_PROGRAM:
         CHECK_EXT1(ARB_shader_objects, "GetFloatv");
         params[0] = (GLfloat)(ctx->Shader.CurrentProgram ? ctx->Shader.CurrentProgram->Name : 0);
         break;
d3980 1
a3980 1
         params[0] = BOOLEAN_TO_INT((ctx->Current.Attrib[VERT_ATTRIB_EDGEFLAG][0] == 1.0));
d4334 1
a4334 1
         params[0] = ctx->PixelMaps.AtoA.Size;
d4337 1
a4337 1
         params[0] = ctx->PixelMaps.BtoB.Size;
d4340 1
a4340 1
         params[0] = ctx->PixelMaps.GtoG.Size;
d4343 1
a4343 1
         params[0] = ctx->PixelMaps.ItoA.Size;
d4346 1
a4346 1
         params[0] = ctx->PixelMaps.ItoB.Size;
d4349 1
a4349 1
         params[0] = ctx->PixelMaps.ItoG.Size;
d4352 1
a4352 1
         params[0] = ctx->PixelMaps.ItoI.Size;
d4355 1
a4355 1
         params[0] = ctx->PixelMaps.ItoR.Size;
d4358 1
a4358 1
         params[0] = ctx->PixelMaps.RtoR.Size;
d4361 1
a4361 1
         params[0] = ctx->PixelMaps.StoS.Size;
d4940 1
a4940 1
         params[0] = BOOLEAN_TO_INT(ctx->Pixel.ColorTableEnabled[COLORTABLE_PRECONVOLUTION]);
d4944 1
a4944 1
         params[0] = BOOLEAN_TO_INT(ctx->Pixel.ColorTableEnabled[COLORTABLE_POSTCONVOLUTION]);
d4948 1
a4948 1
         params[0] = BOOLEAN_TO_INT(ctx->Pixel.ColorTableEnabled[COLORTABLE_POSTCOLORMATRIX]);
d5535 1
a5535 1
         params[0] = ctx->Const.MaxVarying * 4;
a5543 4
         break;
      case GL_CURRENT_PROGRAM:
         CHECK_EXT1(ARB_shader_objects, "GetIntegerv");
         params[0] = ctx->Shader.CurrentProgram ? ctx->Shader.CurrentProgram->Name : 0;
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d1 4
a4 23
/*
 * Copyright (C) 2010  Brian Paul   All Rights Reserved.
 * Copyright (C) 2010  Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Author: Kristian HÃ¸gsberg <krh@@bitplanet.net>
 */
a8 1
#include "enums.h"
d10 1
a15 27
#include "framebuffer.h"

/* This is a table driven implemetation of the glGet*v() functions.
 * The basic idea is that most getters just look up an int somewhere
 * in struct gl_context and then convert it to a bool or float according to
 * which of glGetIntegerv() glGetBooleanv() etc is being called.
 * Instead of generating code to do this, we can just record the enum
 * value and the offset into struct gl_context in an array of structs.  Then
 * in glGet*(), we lookup the struct for the enum in question, and use
 * the offset to get the int we need.
 *
 * Sometimes we need to look up a float, a boolean, a bit in a
 * bitfield, a matrix or other types instead, so we need to track the
 * type of the value in struct gl_context.  And sometimes the value isn't in
 * struct gl_context but in the drawbuffer, the array object, current texture
 * unit, or maybe it's a computed value.  So we need to also track
 * where or how to find the value.  Finally, we sometimes need to
 * check that one of a number of extensions are enabled, the GL
 * version or flush or call _mesa_update_state().  This is done by
 * attaching optional extra information to the value description
 * struct, it's sort of like an array of opcodes that describe extra
 * checks or actions.
 *
 * Putting all this together we end up with struct value_desc below,
 * and with a couple of macros to help, the table of struct value_desc
 * is about as concise as the specification in the old python script.
 */
a16 1
#undef CONST
a18 3
#define FLOAT_TO_FIXED(F)     ( ((F) * 65536.0f > INT_MAX) ? INT_MAX : \
                                ((F) * 65536.0f < INT_MIN) ? INT_MIN : \
                                (GLint) ((F) * 65536.0f) )
a20 3
#define INT_TO_FIXED(I)       ( ((I) > SHRT_MAX) ? INT_MAX : \
                                ((I) < SHRT_MIN) ? INT_MIN : \
                                (GLint) ((I) * 65536) )
d22 3
a24 2
#define INT64_TO_BOOLEAN(I)   ( (I) ? GL_TRUE : GL_FALSE )
#define INT64_TO_INT(I)       ( (GLint)((I > INT_MAX) ? INT_MAX : ((I < INT_MIN) ? INT_MIN : (I))) )
a26 1
#define BOOLEAN_TO_INT64(B)   ( (GLint64) (B) )
a27 1
#define BOOLEAN_TO_FIXED(B)   ( (GLint) ((B) ? 1 : 0) << 16 )
a28 2
#define ENUM_TO_INT64(E)      ( (GLint64) (E) )
#define ENUM_TO_FIXED(E)      (E)
d30 7
a36 121
enum value_type {
   TYPE_INVALID,
   TYPE_API_MASK,
   TYPE_INT,
   TYPE_INT_2,
   TYPE_INT_3,
   TYPE_INT_4,
   TYPE_INT_N,
   TYPE_INT64,
   TYPE_ENUM,
   TYPE_ENUM_2,
   TYPE_BOOLEAN,
   TYPE_BIT_0,
   TYPE_BIT_1,
   TYPE_BIT_2,
   TYPE_BIT_3,
   TYPE_BIT_4,
   TYPE_BIT_5,
   TYPE_FLOAT,
   TYPE_FLOAT_2,
   TYPE_FLOAT_3,
   TYPE_FLOAT_4,
   TYPE_FLOATN,
   TYPE_FLOATN_2,
   TYPE_FLOATN_3,
   TYPE_FLOATN_4,
   TYPE_DOUBLEN,
   TYPE_MATRIX,
   TYPE_MATRIX_T,
   TYPE_CONST
};

enum value_location {
   LOC_BUFFER,
   LOC_CONTEXT,
   LOC_ARRAY,
   LOC_TEXUNIT,
   LOC_CUSTOM
};

enum value_extra {
   EXTRA_END = 0x8000,
   EXTRA_VERSION_30,
   EXTRA_VERSION_31,
   EXTRA_VERSION_32,
   EXTRA_VERSION_ES2,
   EXTRA_NEW_BUFFERS, 
   EXTRA_VALID_DRAW_BUFFER,
   EXTRA_VALID_TEXTURE_UNIT,
   EXTRA_FLUSH_CURRENT,
};

#define NO_EXTRA NULL
#define NO_OFFSET 0

struct value_desc {
   GLenum pname;
   GLubyte location;  /**< enum value_location */
   GLubyte type;      /**< enum value_type */
   int offset;
   const int *extra;
};

union value {
   GLfloat value_float;
   GLfloat value_float_4[4];
   GLmatrix *value_matrix;
   GLint value_int;
   GLint value_int_4[4];
   GLint64 value_int64;
   GLenum value_enum;

   /* Sigh, see GL_COMPRESSED_TEXTURE_FORMATS_ARB handling */
   struct {
      GLint n, ints[100];
   } value_int_n;
   GLboolean value_bool;
};

#define BUFFER_FIELD(field, type) \
   LOC_BUFFER, type, offsetof(struct gl_framebuffer, field)
#define CONTEXT_FIELD(field, type) \
   LOC_CONTEXT, type, offsetof(struct gl_context, field)
#define ARRAY_FIELD(field, type) \
   LOC_ARRAY, type, offsetof(struct gl_array_object, field)
#define CONST(value) \
   LOC_CONTEXT, TYPE_CONST, value

#define BUFFER_INT(field) BUFFER_FIELD(field, TYPE_INT)
#define BUFFER_ENUM(field) BUFFER_FIELD(field, TYPE_ENUM)
#define BUFFER_BOOL(field) BUFFER_FIELD(field, TYPE_BOOLEAN)

#define CONTEXT_INT(field) CONTEXT_FIELD(field, TYPE_INT)
#define CONTEXT_INT2(field) CONTEXT_FIELD(field, TYPE_INT_2)
#define CONTEXT_INT64(field) CONTEXT_FIELD(field, TYPE_INT64)
#define CONTEXT_ENUM(field) CONTEXT_FIELD(field, TYPE_ENUM)
#define CONTEXT_ENUM2(field) CONTEXT_FIELD(field, TYPE_ENUM_2)
#define CONTEXT_BOOL(field) CONTEXT_FIELD(field, TYPE_BOOLEAN)
#define CONTEXT_BIT0(field) CONTEXT_FIELD(field, TYPE_BIT_0)
#define CONTEXT_BIT1(field) CONTEXT_FIELD(field, TYPE_BIT_1)
#define CONTEXT_BIT2(field) CONTEXT_FIELD(field, TYPE_BIT_2)
#define CONTEXT_BIT3(field) CONTEXT_FIELD(field, TYPE_BIT_3)
#define CONTEXT_BIT4(field) CONTEXT_FIELD(field, TYPE_BIT_4)
#define CONTEXT_BIT5(field) CONTEXT_FIELD(field, TYPE_BIT_5)
#define CONTEXT_FLOAT(field) CONTEXT_FIELD(field, TYPE_FLOAT)
#define CONTEXT_FLOAT2(field) CONTEXT_FIELD(field, TYPE_FLOAT_2)
#define CONTEXT_FLOAT3(field) CONTEXT_FIELD(field, TYPE_FLOAT_3)
#define CONTEXT_FLOAT4(field) CONTEXT_FIELD(field, TYPE_FLOAT_4)
#define CONTEXT_MATRIX(field) CONTEXT_FIELD(field, TYPE_MATRIX)
#define CONTEXT_MATRIX_T(field) CONTEXT_FIELD(field, TYPE_MATRIX_T)

#define ARRAY_INT(field) ARRAY_FIELD(field, TYPE_INT)
#define ARRAY_ENUM(field) ARRAY_FIELD(field, TYPE_ENUM)
#define ARRAY_BOOL(field) ARRAY_FIELD(field, TYPE_BOOLEAN)

#define EXT(f)					\
   offsetof(struct gl_extensions, f)

#define EXTRA_EXT(e)				\
   static const int extra_##e[] = {		\
      EXT(e), EXTRA_END				\
d39 7
a45 3
#define EXTRA_EXT2(e1, e2)			\
   static const int extra_##e1##_##e2[] = {	\
      EXT(e1), EXT(e2), EXTRA_END		\
d48 2
a49 1104
/* The 'extra' mechanism is a way to specify extra checks (such as
 * extensions or specific gl versions) or actions (flush current, new
 * buffers) that we need to do before looking up an enum.  We need to
 * declare them all up front so we can refer to them in the value_desc
 * structs below. */

static const int extra_new_buffers[] = {
   EXTRA_NEW_BUFFERS,
   EXTRA_END
};

static const int extra_valid_draw_buffer[] = {
   EXTRA_VALID_DRAW_BUFFER,
   EXTRA_END
};

static const int extra_valid_texture_unit[] = {
   EXTRA_VALID_TEXTURE_UNIT,
   EXTRA_END
};

static const int extra_flush_current_valid_texture_unit[] = {
   EXTRA_FLUSH_CURRENT,
   EXTRA_VALID_TEXTURE_UNIT,
   EXTRA_END
};

static const int extra_flush_current[] = {
   EXTRA_FLUSH_CURRENT,
   EXTRA_END
};

static const int extra_new_buffers_OES_read_format[] = {
   EXTRA_NEW_BUFFERS,
   EXT(OES_read_format),
   EXTRA_END
};

static const int extra_EXT_secondary_color_flush_current[] = {
   EXT(EXT_secondary_color),
   EXTRA_FLUSH_CURRENT,
   EXTRA_END
};

static const int extra_EXT_fog_coord_flush_current[] = {
   EXT(EXT_fog_coord),
   EXTRA_FLUSH_CURRENT,
   EXTRA_END
};

static const int extra_EXT_texture_integer[] = {
   EXT(EXT_texture_integer),
   EXTRA_END
};

static const int extra_EXT_gpu_shader4[] = {
   EXT(EXT_gpu_shader4),
   EXTRA_END
};


EXTRA_EXT(ARB_ES2_compatibility);
EXTRA_EXT(ARB_multitexture);
EXTRA_EXT(ARB_texture_cube_map);
EXTRA_EXT(MESA_texture_array);
EXTRA_EXT2(EXT_secondary_color, ARB_vertex_program);
EXTRA_EXT(EXT_secondary_color);
EXTRA_EXT(EXT_fog_coord);
EXTRA_EXT(EXT_texture_lod_bias);
EXTRA_EXT(EXT_texture_filter_anisotropic);
EXTRA_EXT(IBM_rasterpos_clip);
EXTRA_EXT(NV_point_sprite);
EXTRA_EXT(SGIS_generate_mipmap);
EXTRA_EXT(NV_vertex_program);
EXTRA_EXT(NV_fragment_program);
EXTRA_EXT(NV_texture_rectangle);
EXTRA_EXT(EXT_stencil_two_side);
EXTRA_EXT(NV_light_max_exponent);
EXTRA_EXT(SGI_texture_color_table);
EXTRA_EXT(EXT_depth_bounds_test);
EXTRA_EXT(ARB_depth_clamp);
EXTRA_EXT(ATI_fragment_shader);
EXTRA_EXT(EXT_framebuffer_blit);
EXTRA_EXT(ARB_shader_objects);
EXTRA_EXT(EXT_provoking_vertex);
EXTRA_EXT(ARB_fragment_shader);
EXTRA_EXT(ARB_fragment_program);
EXTRA_EXT2(ARB_framebuffer_object, EXT_framebuffer_multisample);
EXTRA_EXT(EXT_framebuffer_object);
EXTRA_EXT(APPLE_vertex_array_object);
EXTRA_EXT(ARB_seamless_cube_map);
EXTRA_EXT(EXT_compiled_vertex_array);
EXTRA_EXT(ARB_sync);
EXTRA_EXT(ARB_vertex_shader);
EXTRA_EXT(EXT_transform_feedback);
EXTRA_EXT(ARB_transform_feedback2);
EXTRA_EXT(EXT_pixel_buffer_object);
EXTRA_EXT(ARB_vertex_program);
EXTRA_EXT2(NV_point_sprite, ARB_point_sprite);
EXTRA_EXT2(ARB_fragment_program, NV_fragment_program);
EXTRA_EXT2(ARB_vertex_program, NV_vertex_program);
EXTRA_EXT2(ARB_vertex_program, ARB_fragment_program);
EXTRA_EXT(ARB_vertex_buffer_object);
EXTRA_EXT(ARB_geometry_shader4);
EXTRA_EXT(ARB_copy_buffer);

static const int
extra_ARB_vertex_program_ARB_fragment_program_NV_vertex_program[] = {
   EXT(ARB_vertex_program),
   EXT(ARB_fragment_program),
   EXT(NV_vertex_program),
   EXTRA_END
};

static const int
extra_NV_vertex_program_ARB_vertex_program_ARB_fragment_program_NV_vertex_program[] = {
   EXT(NV_vertex_program),
   EXT(ARB_vertex_program),
   EXT(ARB_fragment_program),
   EXT(NV_vertex_program),
   EXTRA_END
};

static const int
extra_NV_primitive_restart[] = {
   EXT(NV_primitive_restart),
   EXTRA_END
};

static const int extra_version_30[] = { EXTRA_VERSION_30, EXTRA_END };
static const int extra_version_31[] = { EXTRA_VERSION_31, EXTRA_END };
static const int extra_version_32[] = { EXTRA_VERSION_32, EXTRA_END };

static const int
extra_ARB_vertex_program_version_es2[] = {
   EXT(ARB_vertex_program),
   EXTRA_VERSION_ES2,
   EXTRA_END
};

#define API_OPENGL_BIT (1 << API_OPENGL)
#define API_OPENGLES_BIT (1 << API_OPENGLES)
#define API_OPENGLES2_BIT (1 << API_OPENGLES2)

/* This is the big table describing all the enums we accept in
 * glGet*v().  The table is partitioned into six parts: enums
 * understood by all GL APIs (OpenGL, GLES and GLES2), enums shared
 * between OpenGL and GLES, enums exclusive to GLES, etc for the
 * remaining combinations.  When we add the enums to the hash table in
 * _mesa_init_get_hash(), we only add the enums for the API we're
 * instantiating and the different sections are guarded by #if
 * FEATURE_GL etc to make sure we only compile in the enums we may
 * need. */

static const struct value_desc values[] = {
   /* Enums shared between OpenGL, GLES1 and GLES2 */
   { 0, 0, TYPE_API_MASK,
     API_OPENGL_BIT | API_OPENGLES_BIT | API_OPENGLES2_BIT, NO_EXTRA},
   { GL_ALPHA_BITS, BUFFER_INT(Visual.alphaBits), extra_new_buffers },
   { GL_BLEND, CONTEXT_BIT0(Color.BlendEnabled), NO_EXTRA },
   { GL_BLEND_SRC, CONTEXT_ENUM(Color.BlendSrcRGB), NO_EXTRA },
   { GL_BLUE_BITS, BUFFER_INT(Visual.blueBits), extra_new_buffers },
   { GL_COLOR_CLEAR_VALUE, CONTEXT_FIELD(Color.ClearColor[0], TYPE_FLOATN_4), NO_EXTRA },
   { GL_COLOR_WRITEMASK, LOC_CUSTOM, TYPE_INT_4, 0, NO_EXTRA },
   { GL_CULL_FACE, CONTEXT_BOOL(Polygon.CullFlag), NO_EXTRA },
   { GL_CULL_FACE_MODE, CONTEXT_ENUM(Polygon.CullFaceMode), NO_EXTRA },
   { GL_DEPTH_BITS, BUFFER_INT(Visual.depthBits), NO_EXTRA },
   { GL_DEPTH_CLEAR_VALUE, CONTEXT_FIELD(Depth.Clear, TYPE_DOUBLEN), NO_EXTRA },
   { GL_DEPTH_FUNC, CONTEXT_ENUM(Depth.Func), NO_EXTRA },
   { GL_DEPTH_RANGE, CONTEXT_FIELD(Viewport.Near, TYPE_FLOATN_2), NO_EXTRA },
   { GL_DEPTH_TEST, CONTEXT_BOOL(Depth.Test), NO_EXTRA },
   { GL_DEPTH_WRITEMASK, CONTEXT_BOOL(Depth.Mask), NO_EXTRA },
   { GL_DITHER, CONTEXT_BOOL(Color.DitherFlag), NO_EXTRA },
   { GL_FRONT_FACE, CONTEXT_ENUM(Polygon.FrontFace), NO_EXTRA },
   { GL_GREEN_BITS, BUFFER_INT(Visual.greenBits), extra_new_buffers },
   { GL_LINE_WIDTH, CONTEXT_FLOAT(Line.Width), NO_EXTRA },
   { GL_ALIASED_LINE_WIDTH_RANGE, CONTEXT_FLOAT2(Const.MinLineWidth), NO_EXTRA },
   { GL_MAX_ELEMENTS_VERTICES, CONTEXT_INT(Const.MaxArrayLockSize), NO_EXTRA },
   { GL_MAX_ELEMENTS_INDICES, CONTEXT_INT(Const.MaxArrayLockSize), NO_EXTRA },
   { GL_MAX_TEXTURE_SIZE, LOC_CUSTOM, TYPE_INT,
     offsetof(struct gl_context, Const.MaxTextureLevels), NO_EXTRA },
   { GL_MAX_VIEWPORT_DIMS, CONTEXT_INT2(Const.MaxViewportWidth), NO_EXTRA },
   { GL_PACK_ALIGNMENT, CONTEXT_INT(Pack.Alignment), NO_EXTRA },
   { GL_ALIASED_POINT_SIZE_RANGE, CONTEXT_FLOAT2(Const.MinPointSize), NO_EXTRA },
   { GL_POLYGON_OFFSET_FACTOR, CONTEXT_FLOAT(Polygon.OffsetFactor ), NO_EXTRA },
   { GL_POLYGON_OFFSET_UNITS, CONTEXT_FLOAT(Polygon.OffsetUnits ), NO_EXTRA },
   { GL_POLYGON_OFFSET_FILL, CONTEXT_BOOL(Polygon.OffsetFill), NO_EXTRA },
   { GL_RED_BITS, BUFFER_INT(Visual.redBits), extra_new_buffers },
   { GL_SCISSOR_BOX, LOC_CUSTOM, TYPE_INT_4, 0, NO_EXTRA },
   { GL_SCISSOR_TEST, CONTEXT_BOOL(Scissor.Enabled), NO_EXTRA },
   { GL_STENCIL_BITS, BUFFER_INT(Visual.stencilBits), NO_EXTRA },
   { GL_STENCIL_CLEAR_VALUE, CONTEXT_INT(Stencil.Clear), NO_EXTRA },
   { GL_STENCIL_FAIL, LOC_CUSTOM, TYPE_ENUM, NO_OFFSET, NO_EXTRA },
   { GL_STENCIL_FUNC, LOC_CUSTOM, TYPE_ENUM, NO_OFFSET, NO_EXTRA },
   { GL_STENCIL_PASS_DEPTH_FAIL, LOC_CUSTOM, TYPE_ENUM, NO_OFFSET, NO_EXTRA },
   { GL_STENCIL_PASS_DEPTH_PASS, LOC_CUSTOM, TYPE_ENUM, NO_OFFSET, NO_EXTRA },
   { GL_STENCIL_REF, LOC_CUSTOM, TYPE_INT, NO_OFFSET, NO_EXTRA },
   { GL_STENCIL_TEST, CONTEXT_BOOL(Stencil.Enabled), NO_EXTRA },
   { GL_STENCIL_VALUE_MASK, LOC_CUSTOM, TYPE_INT, NO_OFFSET, NO_EXTRA },
   { GL_STENCIL_WRITEMASK, LOC_CUSTOM, TYPE_INT, NO_OFFSET, NO_EXTRA },
   { GL_SUBPIXEL_BITS, CONTEXT_INT(Const.SubPixelBits), NO_EXTRA },
   { GL_TEXTURE_BINDING_2D, LOC_CUSTOM, TYPE_INT, TEXTURE_2D_INDEX, NO_EXTRA },
   { GL_UNPACK_ALIGNMENT, CONTEXT_INT(Unpack.Alignment), NO_EXTRA },
   { GL_VIEWPORT, LOC_CUSTOM, TYPE_INT_4, 0, NO_EXTRA },

   /* GL_ARB_multitexture */
   { GL_ACTIVE_TEXTURE_ARB,
     LOC_CUSTOM, TYPE_INT, 0, extra_ARB_multitexture },

   /* Note that all the OES_* extensions require that the Mesa "struct
    * gl_extensions" include a member with the name of the extension.
    * That structure does not yet include OES extensions (and we're
    * not sure whether it will).  If it does, all the OES_*
    * extensions below should mark the dependency. */

   /* GL_ARB_texture_cube_map */
   { GL_TEXTURE_BINDING_CUBE_MAP_ARB, LOC_CUSTOM, TYPE_INT,
     TEXTURE_CUBE_INDEX, extra_ARB_texture_cube_map },
   { GL_MAX_CUBE_MAP_TEXTURE_SIZE_ARB, LOC_CUSTOM, TYPE_INT,
     offsetof(struct gl_context, Const.MaxCubeTextureLevels),
     extra_ARB_texture_cube_map }, /* XXX: OES_texture_cube_map */

   /* XXX: OES_blend_subtract */
   { GL_BLEND_SRC_RGB_EXT, CONTEXT_ENUM(Color.BlendSrcRGB), NO_EXTRA },
   { GL_BLEND_DST_RGB_EXT, CONTEXT_ENUM(Color.BlendDstRGB), NO_EXTRA },
   { GL_BLEND_SRC_ALPHA_EXT, CONTEXT_ENUM(Color.BlendSrcA), NO_EXTRA },
   { GL_BLEND_DST_ALPHA_EXT, CONTEXT_ENUM(Color.BlendDstA), NO_EXTRA },

   /* GL_BLEND_EQUATION_RGB, which is what we're really after, is
    * defined identically to GL_BLEND_EQUATION. */
   { GL_BLEND_EQUATION, CONTEXT_ENUM(Color.BlendEquationRGB), NO_EXTRA },
   { GL_BLEND_EQUATION_ALPHA_EXT, CONTEXT_ENUM(Color.BlendEquationA), NO_EXTRA },

   /* GL_ARB_texture_compression */
   { GL_NUM_COMPRESSED_TEXTURE_FORMATS_ARB, LOC_CUSTOM, TYPE_INT, 0, NO_EXTRA },
   { GL_COMPRESSED_TEXTURE_FORMATS_ARB, LOC_CUSTOM, TYPE_INT_N, 0, NO_EXTRA },

   /* GL_ARB_multisample */
   { GL_SAMPLE_ALPHA_TO_COVERAGE_ARB,
     CONTEXT_BOOL(Multisample.SampleAlphaToCoverage), NO_EXTRA },
   { GL_SAMPLE_COVERAGE_ARB, CONTEXT_BOOL(Multisample.SampleCoverage), NO_EXTRA },
   { GL_SAMPLE_COVERAGE_VALUE_ARB,
     CONTEXT_FLOAT(Multisample.SampleCoverageValue), NO_EXTRA },
   { GL_SAMPLE_COVERAGE_INVERT_ARB,
     CONTEXT_BOOL(Multisample.SampleCoverageInvert), NO_EXTRA },
   { GL_SAMPLE_BUFFERS_ARB, BUFFER_INT(Visual.sampleBuffers), NO_EXTRA },
   { GL_SAMPLES_ARB, BUFFER_INT(Visual.samples), NO_EXTRA },

   /* GL_SGIS_generate_mipmap */
   { GL_GENERATE_MIPMAP_HINT_SGIS, CONTEXT_ENUM(Hint.GenerateMipmap),
     extra_SGIS_generate_mipmap },

   /* GL_ARB_vertex_buffer_object */
   { GL_ARRAY_BUFFER_BINDING_ARB, LOC_CUSTOM, TYPE_INT, 0, NO_EXTRA },

   /* GL_ARB_vertex_buffer_object */
   /* GL_WEIGHT_ARRAY_BUFFER_BINDING_ARB - not supported */
   { GL_ELEMENT_ARRAY_BUFFER_BINDING_ARB, LOC_CUSTOM, TYPE_INT, 0,
     extra_ARB_vertex_buffer_object },

   /* GL_ARB_copy_buffer */
   { GL_COPY_READ_BUFFER, LOC_CUSTOM, TYPE_INT, 0, extra_ARB_copy_buffer },
   { GL_COPY_WRITE_BUFFER, LOC_CUSTOM, TYPE_INT, 0, extra_ARB_copy_buffer },

   /* GL_OES_read_format */
   { GL_IMPLEMENTATION_COLOR_READ_TYPE_OES, LOC_CUSTOM, TYPE_INT, 0,
     extra_new_buffers_OES_read_format },
   { GL_IMPLEMENTATION_COLOR_READ_FORMAT_OES, LOC_CUSTOM, TYPE_INT, 0,
     extra_new_buffers_OES_read_format },

   /* GL_EXT_framebuffer_object */
   { GL_FRAMEBUFFER_BINDING_EXT, BUFFER_INT(Name),
     extra_EXT_framebuffer_object },
   { GL_RENDERBUFFER_BINDING_EXT, LOC_CUSTOM, TYPE_INT, 0,
     extra_EXT_framebuffer_object },
   { GL_MAX_RENDERBUFFER_SIZE_EXT, CONTEXT_INT(Const.MaxRenderbufferSize),
     extra_EXT_framebuffer_object },

   /* This entry isn't spec'ed for GLES 2, but is needed for Mesa's
    * GLSL: */
   { GL_MAX_CLIP_PLANES, CONTEXT_INT(Const.MaxClipPlanes), NO_EXTRA },

#if FEATURE_GL || FEATURE_ES1
   /* Enums in OpenGL and GLES1 */
   { 0, 0, TYPE_API_MASK, API_OPENGL_BIT | API_OPENGLES_BIT, NO_EXTRA },
   { GL_LIGHT0, CONTEXT_BOOL(Light.Light[0].Enabled), NO_EXTRA },
   { GL_LIGHT1, CONTEXT_BOOL(Light.Light[1].Enabled), NO_EXTRA },
   { GL_LIGHT2, CONTEXT_BOOL(Light.Light[2].Enabled), NO_EXTRA },
   { GL_LIGHT3, CONTEXT_BOOL(Light.Light[3].Enabled), NO_EXTRA },
   { GL_LIGHT4, CONTEXT_BOOL(Light.Light[4].Enabled), NO_EXTRA },
   { GL_LIGHT5, CONTEXT_BOOL(Light.Light[5].Enabled), NO_EXTRA },
   { GL_LIGHT6, CONTEXT_BOOL(Light.Light[6].Enabled), NO_EXTRA },
   { GL_LIGHT7, CONTEXT_BOOL(Light.Light[7].Enabled), NO_EXTRA },
   { GL_LIGHTING, CONTEXT_BOOL(Light.Enabled), NO_EXTRA },
   { GL_LIGHT_MODEL_AMBIENT,
     CONTEXT_FIELD(Light.Model.Ambient[0], TYPE_FLOATN_4), NO_EXTRA },
   { GL_LIGHT_MODEL_TWO_SIDE, CONTEXT_BOOL(Light.Model.TwoSide), NO_EXTRA },
   { GL_ALPHA_TEST, CONTEXT_BOOL(Color.AlphaEnabled), NO_EXTRA },
   { GL_ALPHA_TEST_FUNC, CONTEXT_ENUM(Color.AlphaFunc), NO_EXTRA },
   { GL_ALPHA_TEST_REF, CONTEXT_FIELD(Color.AlphaRef, TYPE_FLOATN), NO_EXTRA },
   { GL_BLEND_DST, CONTEXT_ENUM(Color.BlendDstRGB), NO_EXTRA },
   { GL_CLIP_PLANE0, CONTEXT_BIT0(Transform.ClipPlanesEnabled), NO_EXTRA },
   { GL_CLIP_PLANE1, CONTEXT_BIT1(Transform.ClipPlanesEnabled), NO_EXTRA },
   { GL_CLIP_PLANE2, CONTEXT_BIT2(Transform.ClipPlanesEnabled), NO_EXTRA },
   { GL_CLIP_PLANE3, CONTEXT_BIT3(Transform.ClipPlanesEnabled), NO_EXTRA },
   { GL_CLIP_PLANE4, CONTEXT_BIT4(Transform.ClipPlanesEnabled), NO_EXTRA },
   { GL_CLIP_PLANE5, CONTEXT_BIT5(Transform.ClipPlanesEnabled), NO_EXTRA },
   { GL_COLOR_MATERIAL, CONTEXT_BOOL(Light.ColorMaterialEnabled), NO_EXTRA },
   { GL_CURRENT_COLOR,
     CONTEXT_FIELD(Current.Attrib[VERT_ATTRIB_COLOR0][0], TYPE_FLOATN_4),
     extra_flush_current },
   { GL_CURRENT_NORMAL,
     CONTEXT_FIELD(Current.Attrib[VERT_ATTRIB_NORMAL][0], TYPE_FLOATN_3),
     extra_flush_current },
   { GL_CURRENT_TEXTURE_COORDS, LOC_CUSTOM, TYPE_FLOAT_4, 0,
     extra_flush_current_valid_texture_unit },
   { GL_DISTANCE_ATTENUATION_EXT, CONTEXT_FLOAT3(Point.Params[0]), NO_EXTRA },
   { GL_FOG, CONTEXT_BOOL(Fog.Enabled), NO_EXTRA },
   { GL_FOG_COLOR, CONTEXT_FIELD(Fog.Color[0], TYPE_FLOATN_4), NO_EXTRA },
   { GL_FOG_DENSITY, CONTEXT_FLOAT(Fog.Density), NO_EXTRA },
   { GL_FOG_END, CONTEXT_FLOAT(Fog.End), NO_EXTRA },
   { GL_FOG_HINT, CONTEXT_ENUM(Hint.Fog), NO_EXTRA },
   { GL_FOG_MODE, CONTEXT_ENUM(Fog.Mode), NO_EXTRA },
   { GL_FOG_START, CONTEXT_FLOAT(Fog.Start), NO_EXTRA },
   { GL_LINE_SMOOTH, CONTEXT_BOOL(Line.SmoothFlag), NO_EXTRA },
   { GL_LINE_SMOOTH_HINT, CONTEXT_ENUM(Hint.LineSmooth), NO_EXTRA },
   { GL_LINE_WIDTH_RANGE, CONTEXT_FLOAT2(Const.MinLineWidthAA), NO_EXTRA },
   { GL_COLOR_LOGIC_OP, CONTEXT_BOOL(Color.ColorLogicOpEnabled), NO_EXTRA },
   { GL_LOGIC_OP_MODE, CONTEXT_ENUM(Color.LogicOp), NO_EXTRA },
   { GL_MATRIX_MODE, CONTEXT_ENUM(Transform.MatrixMode), NO_EXTRA },
   { GL_MAX_MODELVIEW_STACK_DEPTH, CONST(MAX_MODELVIEW_STACK_DEPTH), NO_EXTRA },
   { GL_MAX_PROJECTION_STACK_DEPTH, CONST(MAX_PROJECTION_STACK_DEPTH), NO_EXTRA },
   { GL_MAX_TEXTURE_STACK_DEPTH, CONST(MAX_TEXTURE_STACK_DEPTH), NO_EXTRA },
   { GL_MODELVIEW_MATRIX, CONTEXT_MATRIX(ModelviewMatrixStack.Top), NO_EXTRA },
   { GL_MODELVIEW_STACK_DEPTH, LOC_CUSTOM, TYPE_INT,
     offsetof(struct gl_context, ModelviewMatrixStack.Depth), NO_EXTRA },
   { GL_NORMALIZE, CONTEXT_BOOL(Transform.Normalize), NO_EXTRA },
   { GL_PACK_SKIP_IMAGES_EXT, CONTEXT_INT(Pack.SkipImages), NO_EXTRA },
   { GL_PERSPECTIVE_CORRECTION_HINT, CONTEXT_ENUM(Hint.PerspectiveCorrection), NO_EXTRA },
   { GL_POINT_SIZE, CONTEXT_FLOAT(Point.Size), NO_EXTRA },
   { GL_POINT_SIZE_RANGE, CONTEXT_FLOAT2(Const.MinPointSizeAA), NO_EXTRA },
   { GL_POINT_SMOOTH, CONTEXT_BOOL(Point.SmoothFlag), NO_EXTRA },
   { GL_POINT_SMOOTH_HINT, CONTEXT_ENUM(Hint.PointSmooth), NO_EXTRA },
   { GL_POINT_SIZE_MIN_EXT, CONTEXT_FLOAT(Point.MinSize), NO_EXTRA },
   { GL_POINT_SIZE_MAX_EXT, CONTEXT_FLOAT(Point.MaxSize), NO_EXTRA },
   { GL_POINT_FADE_THRESHOLD_SIZE_EXT, CONTEXT_FLOAT(Point.Threshold), NO_EXTRA },
   { GL_PROJECTION_MATRIX, CONTEXT_MATRIX(ProjectionMatrixStack.Top), NO_EXTRA },
   { GL_PROJECTION_STACK_DEPTH, LOC_CUSTOM, TYPE_INT,
     offsetof(struct gl_context, ProjectionMatrixStack.Depth), NO_EXTRA },
   { GL_RESCALE_NORMAL, CONTEXT_BOOL(Transform.RescaleNormals), NO_EXTRA },
   { GL_SHADE_MODEL, CONTEXT_ENUM(Light.ShadeModel), NO_EXTRA },
   { GL_TEXTURE_2D, LOC_CUSTOM, TYPE_BOOLEAN, 0, NO_EXTRA },
   { GL_TEXTURE_MATRIX, LOC_CUSTOM, TYPE_MATRIX, 0, extra_valid_texture_unit },
   { GL_TEXTURE_STACK_DEPTH, LOC_CUSTOM, TYPE_INT, 0,
     extra_valid_texture_unit  },

   { GL_VERTEX_ARRAY, ARRAY_BOOL(Vertex.Enabled), NO_EXTRA },
   { GL_VERTEX_ARRAY_SIZE, ARRAY_INT(Vertex.Size), NO_EXTRA },
   { GL_VERTEX_ARRAY_TYPE, ARRAY_ENUM(Vertex.Type), NO_EXTRA },
   { GL_VERTEX_ARRAY_STRIDE, ARRAY_INT(Vertex.Stride), NO_EXTRA },
   { GL_NORMAL_ARRAY, ARRAY_BOOL(Normal.Enabled), NO_EXTRA },
   { GL_NORMAL_ARRAY_TYPE, ARRAY_ENUM(Normal.Type), NO_EXTRA },
   { GL_NORMAL_ARRAY_STRIDE, ARRAY_INT(Normal.Stride), NO_EXTRA },
   { GL_COLOR_ARRAY, ARRAY_BOOL(Color.Enabled), NO_EXTRA },
   { GL_COLOR_ARRAY_SIZE, ARRAY_INT(Color.Size), NO_EXTRA },
   { GL_COLOR_ARRAY_TYPE, ARRAY_ENUM(Color.Type), NO_EXTRA },
   { GL_COLOR_ARRAY_STRIDE, ARRAY_INT(Color.Stride), NO_EXTRA },
   { GL_TEXTURE_COORD_ARRAY,
     LOC_CUSTOM, TYPE_BOOLEAN, offsetof(struct gl_client_array, Enabled), NO_EXTRA },
   { GL_TEXTURE_COORD_ARRAY_SIZE,
     LOC_CUSTOM, TYPE_INT, offsetof(struct gl_client_array, Size), NO_EXTRA },
   { GL_TEXTURE_COORD_ARRAY_TYPE,
     LOC_CUSTOM, TYPE_ENUM, offsetof(struct gl_client_array, Type), NO_EXTRA },
   { GL_TEXTURE_COORD_ARRAY_STRIDE,
     LOC_CUSTOM, TYPE_INT, offsetof(struct gl_client_array, Stride), NO_EXTRA },

   /* GL_ARB_ES2_compatibility */
   { GL_SHADER_COMPILER, CONST(1), extra_ARB_ES2_compatibility },
   { GL_MAX_VARYING_VECTORS, CONTEXT_INT(Const.MaxVarying),
     extra_ARB_ES2_compatibility },
   { GL_MAX_VERTEX_UNIFORM_VECTORS, LOC_CUSTOM, TYPE_INT, 0,
     extra_ARB_ES2_compatibility },
   { GL_MAX_FRAGMENT_UNIFORM_VECTORS, LOC_CUSTOM, TYPE_INT, 0,
     extra_ARB_ES2_compatibility },

   /* GL_ARB_multitexture */
   { GL_MAX_TEXTURE_UNITS_ARB,
     CONTEXT_INT(Const.MaxTextureUnits), extra_ARB_multitexture },
   { GL_CLIENT_ACTIVE_TEXTURE_ARB,
     LOC_CUSTOM, TYPE_INT, 0, extra_ARB_multitexture },

   /* GL_ARB_texture_cube_map */
   { GL_TEXTURE_CUBE_MAP_ARB, LOC_CUSTOM, TYPE_BOOLEAN, 0, NO_EXTRA },
   /* S, T, and R are always set at the same time */
   { GL_TEXTURE_GEN_STR_OES, LOC_TEXUNIT, TYPE_BIT_0,
     offsetof(struct gl_texture_unit, TexGenEnabled), NO_EXTRA },

   /* GL_ARB_multisample */
   { GL_MULTISAMPLE_ARB, CONTEXT_BOOL(Multisample.Enabled), NO_EXTRA },
   { GL_SAMPLE_ALPHA_TO_ONE_ARB, CONTEXT_BOOL(Multisample.SampleAlphaToOne), NO_EXTRA },

   /* GL_ARB_vertex_buffer_object */
   { GL_VERTEX_ARRAY_BUFFER_BINDING_ARB, LOC_CUSTOM, TYPE_INT,
     offsetof(struct gl_array_object, Vertex.BufferObj), NO_EXTRA },
   { GL_NORMAL_ARRAY_BUFFER_BINDING_ARB, LOC_CUSTOM, TYPE_INT,
     offsetof(struct gl_array_object, Normal.BufferObj), NO_EXTRA },
   { GL_COLOR_ARRAY_BUFFER_BINDING_ARB, LOC_CUSTOM, TYPE_INT,
     offsetof(struct gl_array_object, Color.BufferObj), NO_EXTRA },
   { GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING_ARB, LOC_CUSTOM, TYPE_INT, NO_OFFSET, NO_EXTRA },

   /* GL_OES_point_sprite */
   { GL_POINT_SPRITE_NV,
     CONTEXT_BOOL(Point.PointSprite),
     extra_NV_point_sprite_ARB_point_sprite },

   /* GL_ARB_fragment_shader */
   { GL_MAX_FRAGMENT_UNIFORM_COMPONENTS_ARB,
     CONTEXT_INT(Const.FragmentProgram.MaxUniformComponents),
     extra_ARB_fragment_shader },

   /* GL_ARB_vertex_shader */
   { GL_MAX_VERTEX_UNIFORM_COMPONENTS_ARB,
     CONTEXT_INT(Const.VertexProgram.MaxUniformComponents),
     extra_ARB_vertex_shader },
   { GL_MAX_VARYING_FLOATS_ARB, LOC_CUSTOM, TYPE_INT, 0,
     extra_ARB_vertex_shader },

   /* GL_EXT_texture_lod_bias */
   { GL_MAX_TEXTURE_LOD_BIAS_EXT, CONTEXT_FLOAT(Const.MaxTextureLodBias),
	 extra_EXT_texture_lod_bias },

   /* GL_EXT_texture_filter_anisotropic */
   { GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT,
     CONTEXT_FLOAT(Const.MaxTextureMaxAnisotropy),
     extra_EXT_texture_filter_anisotropic },
#endif /* FEATURE_GL || FEATURE_ES1 */

#if FEATURE_ES1
   { 0, 0, TYPE_API_MASK, API_OPENGLES_BIT },
   /* XXX: OES_matrix_get */
   { GL_MODELVIEW_MATRIX_FLOAT_AS_INT_BITS_OES },
   { GL_PROJECTION_MATRIX_FLOAT_AS_INT_BITS_OES },
   { GL_TEXTURE_MATRIX_FLOAT_AS_INT_BITS_OES },

   /* OES_point_size_array */
   { GL_POINT_SIZE_ARRAY_OES, ARRAY_FIELD(PointSize.Enabled, TYPE_BOOLEAN) },
   { GL_POINT_SIZE_ARRAY_TYPE_OES, ARRAY_FIELD(PointSize.Type, TYPE_ENUM) },
   { GL_POINT_SIZE_ARRAY_STRIDE_OES, ARRAY_FIELD(PointSize.Stride, TYPE_INT) },
   { GL_POINT_SIZE_ARRAY_BUFFER_BINDING_OES, LOC_CUSTOM, TYPE_INT, 0 },
#endif /* FEATURE_ES1 */

#if FEATURE_GL || FEATURE_ES2
   { 0, 0, TYPE_API_MASK, API_OPENGL_BIT | API_OPENGLES2_BIT, NO_EXTRA },
   /* This entry isn't spec'ed for GLES 2, but is needed for Mesa's GLSL: */
   { GL_MAX_LIGHTS, CONTEXT_INT(Const.MaxLights), NO_EXTRA },
   { GL_MAX_TEXTURE_COORDS_ARB, /* == GL_MAX_TEXTURE_COORDS_NV */
     CONTEXT_INT(Const.MaxTextureCoordUnits),
     extra_ARB_fragment_program_NV_fragment_program },

   /* GL_ARB_draw_buffers */
   { GL_MAX_DRAW_BUFFERS_ARB, CONTEXT_INT(Const.MaxDrawBuffers), NO_EXTRA },

   { GL_BLEND_COLOR_EXT, CONTEXT_FIELD(Color.BlendColor[0], TYPE_FLOATN_4), NO_EXTRA },
   /* GL_ARB_fragment_program */
   { GL_MAX_TEXTURE_IMAGE_UNITS_ARB, /* == GL_MAX_TEXTURE_IMAGE_UNITS_NV */
     CONTEXT_INT(Const.MaxTextureImageUnits),
     extra_ARB_fragment_program_NV_fragment_program },
   { GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS_ARB,
     CONTEXT_INT(Const.MaxVertexTextureImageUnits), extra_ARB_vertex_shader },
   { GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS_ARB,
     CONTEXT_INT(Const.MaxCombinedTextureImageUnits),
     extra_ARB_vertex_shader },

   /* GL_ARB_shader_objects
    * Actually, this token isn't part of GL_ARB_shader_objects, but is
    * close enough for now. */
   { GL_CURRENT_PROGRAM, LOC_CUSTOM, TYPE_INT, 0, extra_ARB_shader_objects },

   /* OpenGL 2.0 */
   { GL_STENCIL_BACK_FUNC, CONTEXT_ENUM(Stencil.Function[1]), NO_EXTRA },
   { GL_STENCIL_BACK_VALUE_MASK, CONTEXT_INT(Stencil.ValueMask[1]), NO_EXTRA },
   { GL_STENCIL_BACK_WRITEMASK, CONTEXT_INT(Stencil.WriteMask[1]), NO_EXTRA },
   { GL_STENCIL_BACK_REF, CONTEXT_INT(Stencil.Ref[1]), NO_EXTRA },
   { GL_STENCIL_BACK_FAIL, CONTEXT_ENUM(Stencil.FailFunc[1]), NO_EXTRA },
   { GL_STENCIL_BACK_PASS_DEPTH_FAIL, CONTEXT_ENUM(Stencil.ZFailFunc[1]), NO_EXTRA },
   { GL_STENCIL_BACK_PASS_DEPTH_PASS, CONTEXT_ENUM(Stencil.ZPassFunc[1]), NO_EXTRA },

   { GL_MAX_VERTEX_ATTRIBS_ARB,
     CONTEXT_INT(Const.VertexProgram.MaxAttribs),
     extra_ARB_vertex_program_version_es2 },

   /* OES_texture_3D */
   { GL_TEXTURE_BINDING_3D, LOC_CUSTOM, TYPE_INT, TEXTURE_3D_INDEX, NO_EXTRA },
   { GL_MAX_3D_TEXTURE_SIZE, LOC_CUSTOM, TYPE_INT,
     offsetof(struct gl_context, Const.Max3DTextureLevels), NO_EXTRA },

   /* GL_ARB_fragment_program/OES_standard_derivatives */
   { GL_FRAGMENT_SHADER_DERIVATIVE_HINT_ARB,
     CONTEXT_ENUM(Hint.FragmentShaderDerivative), extra_ARB_fragment_shader },
#endif /* FEATURE_GL || FEATURE_ES2 */

#if FEATURE_ES2
   /* Enums unique to OpenGL ES 2.0 */
   { 0, 0, TYPE_API_MASK, API_OPENGLES2_BIT, NO_EXTRA },
   { GL_MAX_FRAGMENT_UNIFORM_VECTORS, LOC_CUSTOM, TYPE_INT, 0, NO_EXTRA },
   { GL_MAX_VARYING_VECTORS, CONTEXT_INT(Const.MaxVarying), NO_EXTRA },
   { GL_MAX_VERTEX_UNIFORM_VECTORS, LOC_CUSTOM, TYPE_INT, 0, NO_EXTRA },
   { GL_SHADER_COMPILER, CONST(1), NO_EXTRA },
   /* OES_get_program_binary */
   { GL_NUM_SHADER_BINARY_FORMATS, CONST(0), NO_EXTRA },
   { GL_SHADER_BINARY_FORMATS, CONST(0), NO_EXTRA },
#endif /* FEATURE_ES2 */

#if FEATURE_GL
   /* Remaining enums are only in OpenGL */
   { 0, 0, TYPE_API_MASK, API_OPENGL_BIT, NO_EXTRA },
   { GL_ACCUM_RED_BITS, BUFFER_INT(Visual.accumRedBits), NO_EXTRA },
   { GL_ACCUM_GREEN_BITS, BUFFER_INT(Visual.accumGreenBits), NO_EXTRA },
   { GL_ACCUM_BLUE_BITS, BUFFER_INT(Visual.accumBlueBits), NO_EXTRA },
   { GL_ACCUM_ALPHA_BITS, BUFFER_INT(Visual.accumAlphaBits), NO_EXTRA },
   { GL_ACCUM_CLEAR_VALUE, CONTEXT_FIELD(Accum.ClearColor[0], TYPE_FLOATN_4), NO_EXTRA },
   { GL_ALPHA_BIAS, CONTEXT_FLOAT(Pixel.AlphaBias), NO_EXTRA },
   { GL_ALPHA_SCALE, CONTEXT_FLOAT(Pixel.AlphaScale), NO_EXTRA },
   { GL_ATTRIB_STACK_DEPTH, CONTEXT_INT(AttribStackDepth), NO_EXTRA },
   { GL_AUTO_NORMAL, CONTEXT_BOOL(Eval.AutoNormal), NO_EXTRA },
   { GL_AUX_BUFFERS, BUFFER_INT(Visual.numAuxBuffers), NO_EXTRA },
   { GL_BLUE_BIAS, CONTEXT_FLOAT(Pixel.BlueBias), NO_EXTRA },
   { GL_BLUE_SCALE, CONTEXT_FLOAT(Pixel.BlueScale), NO_EXTRA },
   { GL_CLIENT_ATTRIB_STACK_DEPTH, CONTEXT_INT(ClientAttribStackDepth), NO_EXTRA },
   { GL_COLOR_MATERIAL_FACE, CONTEXT_ENUM(Light.ColorMaterialFace), NO_EXTRA },
   { GL_COLOR_MATERIAL_PARAMETER, CONTEXT_ENUM(Light.ColorMaterialMode), NO_EXTRA },
   { GL_CURRENT_INDEX,
     CONTEXT_FLOAT(Current.Attrib[VERT_ATTRIB_COLOR_INDEX][0]),
     extra_flush_current },
   { GL_CURRENT_RASTER_COLOR,
     CONTEXT_FIELD(Current.RasterColor[0], TYPE_FLOATN_4), NO_EXTRA },
   { GL_CURRENT_RASTER_DISTANCE, CONTEXT_FLOAT(Current.RasterDistance), NO_EXTRA },
   { GL_CURRENT_RASTER_INDEX, CONST(1), NO_EXTRA },
   { GL_CURRENT_RASTER_POSITION, CONTEXT_FLOAT4(Current.RasterPos[0]), NO_EXTRA },
   { GL_CURRENT_RASTER_SECONDARY_COLOR,
     CONTEXT_FIELD(Current.RasterSecondaryColor[0], TYPE_FLOATN_4), NO_EXTRA },
   { GL_CURRENT_RASTER_TEXTURE_COORDS, LOC_CUSTOM, TYPE_FLOAT_4, 0,
     extra_valid_texture_unit },
   { GL_CURRENT_RASTER_POSITION_VALID, CONTEXT_BOOL(Current.RasterPosValid), NO_EXTRA },
   { GL_DEPTH_BIAS, CONTEXT_FLOAT(Pixel.DepthBias), NO_EXTRA },
   { GL_DEPTH_SCALE, CONTEXT_FLOAT(Pixel.DepthScale), NO_EXTRA },
   { GL_DOUBLEBUFFER, BUFFER_INT(Visual.doubleBufferMode), NO_EXTRA },
   { GL_DRAW_BUFFER, BUFFER_ENUM(ColorDrawBuffer[0]), NO_EXTRA },
   { GL_EDGE_FLAG, LOC_CUSTOM, TYPE_BOOLEAN, 0, NO_EXTRA },
   { GL_FEEDBACK_BUFFER_SIZE, CONTEXT_INT(Feedback.BufferSize), NO_EXTRA },
   { GL_FEEDBACK_BUFFER_TYPE, CONTEXT_ENUM(Feedback.Type), NO_EXTRA },
   { GL_FOG_INDEX, CONTEXT_FLOAT(Fog.Index), NO_EXTRA },
   { GL_GREEN_BIAS, CONTEXT_FLOAT(Pixel.GreenBias), NO_EXTRA },
   { GL_GREEN_SCALE, CONTEXT_FLOAT(Pixel.GreenScale), NO_EXTRA },
   { GL_INDEX_BITS, BUFFER_INT(Visual.indexBits), extra_new_buffers },
   { GL_INDEX_CLEAR_VALUE, CONTEXT_INT(Color.ClearIndex), NO_EXTRA },
   { GL_INDEX_MODE, CONST(0) , NO_EXTRA}, 
   { GL_INDEX_OFFSET, CONTEXT_INT(Pixel.IndexOffset), NO_EXTRA },
   { GL_INDEX_SHIFT, CONTEXT_INT(Pixel.IndexShift), NO_EXTRA },
   { GL_INDEX_WRITEMASK, CONTEXT_INT(Color.IndexMask), NO_EXTRA },
   { GL_LIGHT_MODEL_COLOR_CONTROL, CONTEXT_ENUM(Light.Model.ColorControl), NO_EXTRA },
   { GL_LIGHT_MODEL_LOCAL_VIEWER, CONTEXT_BOOL(Light.Model.LocalViewer), NO_EXTRA },
   { GL_LINE_STIPPLE, CONTEXT_BOOL(Line.StippleFlag), NO_EXTRA },
   { GL_LINE_STIPPLE_PATTERN, LOC_CUSTOM, TYPE_INT, 0, NO_EXTRA },
   { GL_LINE_STIPPLE_REPEAT, CONTEXT_INT(Line.StippleFactor), NO_EXTRA },
   { GL_LINE_WIDTH_GRANULARITY, CONTEXT_FLOAT(Const.LineWidthGranularity), NO_EXTRA },
   { GL_LIST_BASE, CONTEXT_INT(List.ListBase), NO_EXTRA },
   { GL_LIST_INDEX, LOC_CUSTOM, TYPE_INT, 0, NO_EXTRA },
   { GL_LIST_MODE, LOC_CUSTOM, TYPE_ENUM, 0, NO_EXTRA },
   { GL_INDEX_LOGIC_OP, CONTEXT_BOOL(Color.IndexLogicOpEnabled), NO_EXTRA },
   { GL_MAP1_COLOR_4, CONTEXT_BOOL(Eval.Map1Color4), NO_EXTRA },
   { GL_MAP1_GRID_DOMAIN, CONTEXT_FLOAT2(Eval.MapGrid1u1), NO_EXTRA },
   { GL_MAP1_GRID_SEGMENTS, CONTEXT_INT(Eval.MapGrid1un), NO_EXTRA },
   { GL_MAP1_INDEX, CONTEXT_BOOL(Eval.Map1Index), NO_EXTRA },
   { GL_MAP1_NORMAL, CONTEXT_BOOL(Eval.Map1Normal), NO_EXTRA },
   { GL_MAP1_TEXTURE_COORD_1, CONTEXT_BOOL(Eval.Map1TextureCoord1), NO_EXTRA },
   { GL_MAP1_TEXTURE_COORD_2, CONTEXT_BOOL(Eval.Map1TextureCoord2), NO_EXTRA },
   { GL_MAP1_TEXTURE_COORD_3, CONTEXT_BOOL(Eval.Map1TextureCoord3), NO_EXTRA },
   { GL_MAP1_TEXTURE_COORD_4, CONTEXT_BOOL(Eval.Map1TextureCoord4), NO_EXTRA },
   { GL_MAP1_VERTEX_3, CONTEXT_BOOL(Eval.Map1Vertex3), NO_EXTRA },
   { GL_MAP1_VERTEX_4, CONTEXT_BOOL(Eval.Map1Vertex4), NO_EXTRA },
   { GL_MAP2_COLOR_4, CONTEXT_BOOL(Eval.Map2Color4), NO_EXTRA },
   { GL_MAP2_GRID_DOMAIN, LOC_CUSTOM, TYPE_FLOAT_4, 0, NO_EXTRA },
   { GL_MAP2_GRID_SEGMENTS, CONTEXT_INT2(Eval.MapGrid2un), NO_EXTRA },
   { GL_MAP2_INDEX, CONTEXT_BOOL(Eval.Map2Index), NO_EXTRA },
   { GL_MAP2_NORMAL, CONTEXT_BOOL(Eval.Map2Normal), NO_EXTRA },
   { GL_MAP2_TEXTURE_COORD_1, CONTEXT_BOOL(Eval.Map2TextureCoord1), NO_EXTRA },
   { GL_MAP2_TEXTURE_COORD_2, CONTEXT_BOOL(Eval.Map2TextureCoord2), NO_EXTRA },
   { GL_MAP2_TEXTURE_COORD_3, CONTEXT_BOOL(Eval.Map2TextureCoord3), NO_EXTRA },
   { GL_MAP2_TEXTURE_COORD_4, CONTEXT_BOOL(Eval.Map2TextureCoord4), NO_EXTRA },
   { GL_MAP2_VERTEX_3, CONTEXT_BOOL(Eval.Map2Vertex3), NO_EXTRA },
   { GL_MAP2_VERTEX_4, CONTEXT_BOOL(Eval.Map2Vertex4), NO_EXTRA },
   { GL_MAP_COLOR, CONTEXT_BOOL(Pixel.MapColorFlag), NO_EXTRA },
   { GL_MAP_STENCIL, CONTEXT_BOOL(Pixel.MapStencilFlag), NO_EXTRA },
   { GL_MAX_ATTRIB_STACK_DEPTH, CONST(MAX_ATTRIB_STACK_DEPTH), NO_EXTRA },
   { GL_MAX_CLIENT_ATTRIB_STACK_DEPTH, CONST(MAX_CLIENT_ATTRIB_STACK_DEPTH), NO_EXTRA },

   { GL_MAX_EVAL_ORDER, CONST(MAX_EVAL_ORDER), NO_EXTRA },
   { GL_MAX_LIST_NESTING, CONST(MAX_LIST_NESTING), NO_EXTRA },
   { GL_MAX_NAME_STACK_DEPTH, CONST(MAX_NAME_STACK_DEPTH), NO_EXTRA },
   { GL_MAX_PIXEL_MAP_TABLE, CONST(MAX_PIXEL_MAP_TABLE), NO_EXTRA },
   { GL_NAME_STACK_DEPTH, CONTEXT_INT(Select.NameStackDepth), NO_EXTRA },
   { GL_PACK_LSB_FIRST, CONTEXT_BOOL(Pack.LsbFirst), NO_EXTRA },
   { GL_PACK_ROW_LENGTH, CONTEXT_INT(Pack.RowLength), NO_EXTRA },
   { GL_PACK_SKIP_PIXELS, CONTEXT_INT(Pack.SkipPixels), NO_EXTRA },
   { GL_PACK_SKIP_ROWS, CONTEXT_INT(Pack.SkipRows), NO_EXTRA },
   { GL_PACK_SWAP_BYTES, CONTEXT_BOOL(Pack.SwapBytes), NO_EXTRA },
   { GL_PACK_IMAGE_HEIGHT_EXT, CONTEXT_INT(Pack.ImageHeight), NO_EXTRA },
   { GL_PACK_INVERT_MESA, CONTEXT_BOOL(Pack.Invert), NO_EXTRA },
   { GL_PIXEL_MAP_A_TO_A_SIZE, CONTEXT_INT(PixelMaps.AtoA.Size), NO_EXTRA },
   { GL_PIXEL_MAP_B_TO_B_SIZE, CONTEXT_INT(PixelMaps.BtoB.Size), NO_EXTRA },
   { GL_PIXEL_MAP_G_TO_G_SIZE, CONTEXT_INT(PixelMaps.GtoG.Size), NO_EXTRA },
   { GL_PIXEL_MAP_I_TO_A_SIZE, CONTEXT_INT(PixelMaps.ItoA.Size), NO_EXTRA },
   { GL_PIXEL_MAP_I_TO_B_SIZE, CONTEXT_INT(PixelMaps.ItoB.Size), NO_EXTRA },
   { GL_PIXEL_MAP_I_TO_G_SIZE, CONTEXT_INT(PixelMaps.ItoG.Size), NO_EXTRA },
   { GL_PIXEL_MAP_I_TO_I_SIZE, CONTEXT_INT(PixelMaps.ItoI.Size), NO_EXTRA },
   { GL_PIXEL_MAP_I_TO_R_SIZE, CONTEXT_INT(PixelMaps.ItoR.Size), NO_EXTRA },
   { GL_PIXEL_MAP_R_TO_R_SIZE, CONTEXT_INT(PixelMaps.RtoR.Size), NO_EXTRA },
   { GL_PIXEL_MAP_S_TO_S_SIZE, CONTEXT_INT(PixelMaps.StoS.Size), NO_EXTRA },
   { GL_POINT_SIZE_GRANULARITY, CONTEXT_FLOAT(Const.PointSizeGranularity), NO_EXTRA },
   { GL_POLYGON_MODE, CONTEXT_ENUM2(Polygon.FrontMode), NO_EXTRA },
   { GL_POLYGON_OFFSET_BIAS_EXT, CONTEXT_FLOAT(Polygon.OffsetUnits), NO_EXTRA },
   { GL_POLYGON_OFFSET_POINT, CONTEXT_BOOL(Polygon.OffsetPoint), NO_EXTRA },
   { GL_POLYGON_OFFSET_LINE, CONTEXT_BOOL(Polygon.OffsetLine), NO_EXTRA },
   { GL_POLYGON_SMOOTH, CONTEXT_BOOL(Polygon.SmoothFlag), NO_EXTRA },
   { GL_POLYGON_SMOOTH_HINT, CONTEXT_ENUM(Hint.PolygonSmooth), NO_EXTRA },
   { GL_POLYGON_STIPPLE, CONTEXT_BOOL(Polygon.StippleFlag), NO_EXTRA },
   { GL_READ_BUFFER, LOC_CUSTOM, TYPE_ENUM, NO_OFFSET, NO_EXTRA },
   { GL_RED_BIAS, CONTEXT_FLOAT(Pixel.RedBias), NO_EXTRA },
   { GL_RED_SCALE, CONTEXT_FLOAT(Pixel.RedScale), NO_EXTRA },
   { GL_RENDER_MODE, CONTEXT_ENUM(RenderMode), NO_EXTRA },
   { GL_RGBA_MODE, CONST(1), NO_EXTRA },
   { GL_SELECTION_BUFFER_SIZE, CONTEXT_INT(Select.BufferSize), NO_EXTRA },
   { GL_SHARED_TEXTURE_PALETTE_EXT, CONTEXT_BOOL(Texture.SharedPalette), NO_EXTRA },

   { GL_STEREO, BUFFER_INT(Visual.stereoMode), NO_EXTRA },

   { GL_TEXTURE_1D, LOC_CUSTOM, TYPE_BOOLEAN, NO_OFFSET, NO_EXTRA },
   { GL_TEXTURE_3D, LOC_CUSTOM, TYPE_BOOLEAN, NO_OFFSET, NO_EXTRA },
   { GL_TEXTURE_1D_ARRAY_EXT, LOC_CUSTOM, TYPE_BOOLEAN, NO_OFFSET, NO_EXTRA },
   { GL_TEXTURE_2D_ARRAY_EXT, LOC_CUSTOM, TYPE_BOOLEAN, NO_OFFSET, NO_EXTRA },

   { GL_TEXTURE_BINDING_1D, LOC_CUSTOM, TYPE_INT, TEXTURE_1D_INDEX, NO_EXTRA },
   { GL_TEXTURE_BINDING_1D_ARRAY, LOC_CUSTOM, TYPE_INT,
     TEXTURE_1D_ARRAY_INDEX, extra_MESA_texture_array },
   { GL_TEXTURE_BINDING_2D_ARRAY, LOC_CUSTOM, TYPE_INT,
     TEXTURE_1D_ARRAY_INDEX, extra_MESA_texture_array },
   { GL_MAX_ARRAY_TEXTURE_LAYERS_EXT,
     CONTEXT_INT(Const.MaxArrayTextureLayers), extra_MESA_texture_array },

   { GL_TEXTURE_GEN_S, LOC_TEXUNIT, TYPE_BIT_0,
     offsetof(struct gl_texture_unit, TexGenEnabled), NO_EXTRA },
   { GL_TEXTURE_GEN_T, LOC_TEXUNIT, TYPE_BIT_1,
     offsetof(struct gl_texture_unit, TexGenEnabled), NO_EXTRA },
   { GL_TEXTURE_GEN_R, LOC_TEXUNIT, TYPE_BIT_2,
     offsetof(struct gl_texture_unit, TexGenEnabled), NO_EXTRA },
   { GL_TEXTURE_GEN_Q, LOC_TEXUNIT, TYPE_BIT_3,
     offsetof(struct gl_texture_unit, TexGenEnabled), NO_EXTRA },
   { GL_UNPACK_LSB_FIRST, CONTEXT_BOOL(Unpack.LsbFirst), NO_EXTRA },
   { GL_UNPACK_ROW_LENGTH, CONTEXT_INT(Unpack.RowLength), NO_EXTRA },
   { GL_UNPACK_SKIP_PIXELS, CONTEXT_INT(Unpack.SkipPixels), NO_EXTRA },
   { GL_UNPACK_SKIP_ROWS, CONTEXT_INT(Unpack.SkipRows), NO_EXTRA },
   { GL_UNPACK_SWAP_BYTES, CONTEXT_BOOL(Unpack.SwapBytes), NO_EXTRA },
   { GL_UNPACK_SKIP_IMAGES_EXT, CONTEXT_INT(Unpack.SkipImages), NO_EXTRA },
   { GL_UNPACK_IMAGE_HEIGHT_EXT, CONTEXT_INT(Unpack.ImageHeight), NO_EXTRA },
   { GL_UNPACK_CLIENT_STORAGE_APPLE, CONTEXT_BOOL(Unpack.ClientStorage), NO_EXTRA },
   { GL_ZOOM_X, CONTEXT_FLOAT(Pixel.ZoomX), NO_EXTRA },
   { GL_ZOOM_Y, CONTEXT_FLOAT(Pixel.ZoomY), NO_EXTRA },

   /* Vertex arrays */
   { GL_VERTEX_ARRAY_COUNT_EXT, CONST(0), NO_EXTRA },
   { GL_NORMAL_ARRAY_COUNT_EXT, CONST(0), NO_EXTRA },
   { GL_COLOR_ARRAY_COUNT_EXT, CONST(0), NO_EXTRA },
   { GL_INDEX_ARRAY, ARRAY_BOOL(Index.Enabled), NO_EXTRA },
   { GL_INDEX_ARRAY_TYPE, ARRAY_ENUM(Index.Type), NO_EXTRA },
   { GL_INDEX_ARRAY_STRIDE, ARRAY_INT(Index.Stride), NO_EXTRA },
   { GL_INDEX_ARRAY_COUNT_EXT, CONST(0), NO_EXTRA },
   { GL_TEXTURE_COORD_ARRAY_COUNT_EXT, CONST(0), NO_EXTRA },
   { GL_EDGE_FLAG_ARRAY, ARRAY_BOOL(EdgeFlag.Enabled), NO_EXTRA },
   { GL_EDGE_FLAG_ARRAY_STRIDE, ARRAY_INT(EdgeFlag.Stride), NO_EXTRA },
   { GL_EDGE_FLAG_ARRAY_COUNT_EXT, CONST(0), NO_EXTRA },

   /* GL_ARB_texture_compression */
   { GL_TEXTURE_COMPRESSION_HINT_ARB, CONTEXT_INT(Hint.TextureCompression), NO_EXTRA },

   /* GL_EXT_compiled_vertex_array */
   { GL_ARRAY_ELEMENT_LOCK_FIRST_EXT, CONTEXT_INT(Array.LockFirst),
     extra_EXT_compiled_vertex_array },
   { GL_ARRAY_ELEMENT_LOCK_COUNT_EXT, CONTEXT_INT(Array.LockCount),
     extra_EXT_compiled_vertex_array },

   /* GL_ARB_transpose_matrix */
   { GL_TRANSPOSE_MODELVIEW_MATRIX_ARB,
     CONTEXT_MATRIX_T(ModelviewMatrixStack), NO_EXTRA },
   { GL_TRANSPOSE_PROJECTION_MATRIX_ARB,
     CONTEXT_MATRIX_T(ProjectionMatrixStack.Top), NO_EXTRA },
   { GL_TRANSPOSE_TEXTURE_MATRIX_ARB, CONTEXT_MATRIX_T(TextureMatrixStack), NO_EXTRA },

   /* GL_SGI_texture_color_table */
   { GL_TEXTURE_COLOR_TABLE_SGI, LOC_TEXUNIT, TYPE_BOOLEAN,
     offsetof(struct gl_texture_unit, ColorTableEnabled),
     extra_SGI_texture_color_table },

   /* GL_EXT_secondary_color */
   { GL_COLOR_SUM_EXT, CONTEXT_BOOL(Fog.ColorSumEnabled),
     extra_EXT_secondary_color_ARB_vertex_program },
   { GL_CURRENT_SECONDARY_COLOR_EXT,
     CONTEXT_FIELD(Current.Attrib[VERT_ATTRIB_COLOR1][0], TYPE_FLOATN_4),
     extra_EXT_secondary_color_flush_current },
   { GL_SECONDARY_COLOR_ARRAY_EXT, ARRAY_BOOL(SecondaryColor.Enabled),
     extra_EXT_secondary_color },
   { GL_SECONDARY_COLOR_ARRAY_TYPE_EXT, ARRAY_ENUM(SecondaryColor.Type),
     extra_EXT_secondary_color },
   { GL_SECONDARY_COLOR_ARRAY_STRIDE_EXT, ARRAY_INT(SecondaryColor.Stride),
     extra_EXT_secondary_color },
   { GL_SECONDARY_COLOR_ARRAY_SIZE_EXT, ARRAY_INT(SecondaryColor.Size),
     extra_EXT_secondary_color },

   /* GL_EXT_fog_coord */
   { GL_CURRENT_FOG_COORDINATE_EXT,
     CONTEXT_FLOAT(Current.Attrib[VERT_ATTRIB_FOG][0]),
     extra_EXT_fog_coord_flush_current },
   { GL_FOG_COORDINATE_ARRAY_EXT, ARRAY_BOOL(FogCoord.Enabled),
     extra_EXT_fog_coord },
   { GL_FOG_COORDINATE_ARRAY_TYPE_EXT, ARRAY_ENUM(FogCoord.Type),
     extra_EXT_fog_coord },
   { GL_FOG_COORDINATE_ARRAY_STRIDE_EXT, ARRAY_INT(FogCoord.Stride),
     extra_EXT_fog_coord },
   { GL_FOG_COORDINATE_SOURCE_EXT, CONTEXT_ENUM(Fog.FogCoordinateSource),
     extra_EXT_fog_coord },

   /* GL_IBM_rasterpos_clip */
   { GL_RASTER_POSITION_UNCLIPPED_IBM,
     CONTEXT_BOOL(Transform.RasterPositionUnclipped),
     extra_IBM_rasterpos_clip },

   /* GL_NV_point_sprite */
   { GL_POINT_SPRITE_R_MODE_NV,
     CONTEXT_ENUM(Point.SpriteRMode), extra_NV_point_sprite },
   { GL_POINT_SPRITE_COORD_ORIGIN, CONTEXT_ENUM(Point.SpriteOrigin),
     extra_NV_point_sprite_ARB_point_sprite },

   /* GL_NV_vertex_program */
   { GL_VERTEX_PROGRAM_BINDING_NV, LOC_CUSTOM, TYPE_INT, 0,
     extra_NV_vertex_program },
   { GL_VERTEX_ATTRIB_ARRAY0_NV, ARRAY_BOOL(VertexAttrib[0].Enabled),
     extra_NV_vertex_program },
   { GL_VERTEX_ATTRIB_ARRAY1_NV, ARRAY_BOOL(VertexAttrib[1].Enabled),
     extra_NV_vertex_program },
   { GL_VERTEX_ATTRIB_ARRAY2_NV, ARRAY_BOOL(VertexAttrib[2].Enabled),
     extra_NV_vertex_program },
   { GL_VERTEX_ATTRIB_ARRAY3_NV, ARRAY_BOOL(VertexAttrib[3].Enabled),
     extra_NV_vertex_program },
   { GL_VERTEX_ATTRIB_ARRAY4_NV, ARRAY_BOOL(VertexAttrib[4].Enabled),
     extra_NV_vertex_program },
   { GL_VERTEX_ATTRIB_ARRAY5_NV, ARRAY_BOOL(VertexAttrib[5].Enabled),
     extra_NV_vertex_program },
   { GL_VERTEX_ATTRIB_ARRAY6_NV, ARRAY_BOOL(VertexAttrib[6].Enabled),
     extra_NV_vertex_program },
   { GL_VERTEX_ATTRIB_ARRAY7_NV, ARRAY_BOOL(VertexAttrib[7].Enabled),
     extra_NV_vertex_program },
   { GL_VERTEX_ATTRIB_ARRAY8_NV, ARRAY_BOOL(VertexAttrib[8].Enabled),
     extra_NV_vertex_program },
   { GL_VERTEX_ATTRIB_ARRAY9_NV, ARRAY_BOOL(VertexAttrib[9].Enabled),
     extra_NV_vertex_program },
   { GL_VERTEX_ATTRIB_ARRAY10_NV, ARRAY_BOOL(VertexAttrib[10].Enabled),
     extra_NV_vertex_program },
   { GL_VERTEX_ATTRIB_ARRAY11_NV, ARRAY_BOOL(VertexAttrib[11].Enabled),
     extra_NV_vertex_program },
   { GL_VERTEX_ATTRIB_ARRAY12_NV, ARRAY_BOOL(VertexAttrib[12].Enabled),
     extra_NV_vertex_program },
   { GL_VERTEX_ATTRIB_ARRAY13_NV, ARRAY_BOOL(VertexAttrib[13].Enabled),
     extra_NV_vertex_program },
   { GL_VERTEX_ATTRIB_ARRAY14_NV, ARRAY_BOOL(VertexAttrib[14].Enabled),
     extra_NV_vertex_program },
   { GL_VERTEX_ATTRIB_ARRAY15_NV, ARRAY_BOOL(VertexAttrib[15].Enabled),
     extra_NV_vertex_program },
   { GL_MAP1_VERTEX_ATTRIB0_4_NV, CONTEXT_BOOL(Eval.Map1Attrib[0]),
     extra_NV_vertex_program },
   { GL_MAP1_VERTEX_ATTRIB1_4_NV, CONTEXT_BOOL(Eval.Map1Attrib[1]),
     extra_NV_vertex_program },
   { GL_MAP1_VERTEX_ATTRIB2_4_NV, CONTEXT_BOOL(Eval.Map1Attrib[2]),
     extra_NV_vertex_program },
   { GL_MAP1_VERTEX_ATTRIB3_4_NV, CONTEXT_BOOL(Eval.Map1Attrib[3]),
     extra_NV_vertex_program },
   { GL_MAP1_VERTEX_ATTRIB4_4_NV, CONTEXT_BOOL(Eval.Map1Attrib[4]),
     extra_NV_vertex_program },
   { GL_MAP1_VERTEX_ATTRIB5_4_NV, CONTEXT_BOOL(Eval.Map1Attrib[5]),
     extra_NV_vertex_program },
   { GL_MAP1_VERTEX_ATTRIB6_4_NV, CONTEXT_BOOL(Eval.Map1Attrib[6]),
     extra_NV_vertex_program },
   { GL_MAP1_VERTEX_ATTRIB7_4_NV, CONTEXT_BOOL(Eval.Map1Attrib[7]),
     extra_NV_vertex_program },
   { GL_MAP1_VERTEX_ATTRIB8_4_NV, CONTEXT_BOOL(Eval.Map1Attrib[8]),
     extra_NV_vertex_program },
   { GL_MAP1_VERTEX_ATTRIB9_4_NV, CONTEXT_BOOL(Eval.Map1Attrib[9]),
     extra_NV_vertex_program },
   { GL_MAP1_VERTEX_ATTRIB10_4_NV, CONTEXT_BOOL(Eval.Map1Attrib[10]),
     extra_NV_vertex_program },
   { GL_MAP1_VERTEX_ATTRIB11_4_NV, CONTEXT_BOOL(Eval.Map1Attrib[11]),
     extra_NV_vertex_program },
   { GL_MAP1_VERTEX_ATTRIB12_4_NV, CONTEXT_BOOL(Eval.Map1Attrib[12]),
     extra_NV_vertex_program },
   { GL_MAP1_VERTEX_ATTRIB13_4_NV, CONTEXT_BOOL(Eval.Map1Attrib[13]),
     extra_NV_vertex_program },
   { GL_MAP1_VERTEX_ATTRIB14_4_NV, CONTEXT_BOOL(Eval.Map1Attrib[14]),
     extra_NV_vertex_program },
   { GL_MAP1_VERTEX_ATTRIB15_4_NV, CONTEXT_BOOL(Eval.Map1Attrib[15]),
     extra_NV_vertex_program },

   /* GL_NV_fragment_program */
   { GL_FRAGMENT_PROGRAM_NV, CONTEXT_BOOL(FragmentProgram.Enabled),
     extra_NV_fragment_program },
   { GL_FRAGMENT_PROGRAM_BINDING_NV, LOC_CUSTOM, TYPE_INT, 0,
     extra_NV_fragment_program },
   { GL_MAX_FRAGMENT_PROGRAM_LOCAL_PARAMETERS_NV,
     CONST(MAX_NV_FRAGMENT_PROGRAM_PARAMS),
     extra_NV_fragment_program },

   /* GL_NV_texture_rectangle */
   { GL_TEXTURE_RECTANGLE_NV,
     LOC_CUSTOM, TYPE_BOOLEAN, 0, extra_NV_texture_rectangle },
   { GL_TEXTURE_BINDING_RECTANGLE_NV,
     LOC_CUSTOM, TYPE_INT, TEXTURE_RECT_INDEX, extra_NV_texture_rectangle },
   { GL_MAX_RECTANGLE_TEXTURE_SIZE_NV,
     CONTEXT_INT(Const.MaxTextureRectSize), extra_NV_texture_rectangle },

   /* GL_EXT_stencil_two_side */
   { GL_STENCIL_TEST_TWO_SIDE_EXT, CONTEXT_BOOL(Stencil.TestTwoSide),
	 extra_EXT_stencil_two_side },
   { GL_ACTIVE_STENCIL_FACE_EXT, LOC_CUSTOM, TYPE_ENUM, NO_OFFSET, NO_EXTRA },

   /* GL_NV_light_max_exponent */
   { GL_MAX_SHININESS_NV, CONTEXT_FLOAT(Const.MaxShininess),
     extra_NV_light_max_exponent },
   { GL_MAX_SPOT_EXPONENT_NV, CONTEXT_FLOAT(Const.MaxSpotExponent),
     extra_NV_light_max_exponent },
     
   /* GL_NV_primitive_restart */
   { GL_PRIMITIVE_RESTART_NV, CONTEXT_BOOL(Array.PrimitiveRestart),
     extra_NV_primitive_restart },
   { GL_PRIMITIVE_RESTART_INDEX_NV, CONTEXT_INT(Array.RestartIndex),
     extra_NV_primitive_restart },
 
   /* GL_ARB_vertex_buffer_object */
   { GL_INDEX_ARRAY_BUFFER_BINDING_ARB, LOC_CUSTOM, TYPE_INT,
     offsetof(struct gl_array_object, Index.BufferObj), NO_EXTRA },
   { GL_EDGE_FLAG_ARRAY_BUFFER_BINDING_ARB, LOC_CUSTOM, TYPE_INT,
     offsetof(struct gl_array_object, EdgeFlag.BufferObj), NO_EXTRA },
   { GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING_ARB, LOC_CUSTOM, TYPE_INT,
     offsetof(struct gl_array_object, SecondaryColor.BufferObj), NO_EXTRA },
   { GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING_ARB, LOC_CUSTOM, TYPE_INT,
     offsetof(struct gl_array_object, FogCoord.BufferObj), NO_EXTRA },

   /* GL_EXT_pixel_buffer_object */
   { GL_PIXEL_PACK_BUFFER_BINDING_EXT, LOC_CUSTOM, TYPE_INT, 0,
     extra_EXT_pixel_buffer_object },
   { GL_PIXEL_UNPACK_BUFFER_BINDING_EXT, LOC_CUSTOM, TYPE_INT, 0,
     extra_EXT_pixel_buffer_object },

   /* GL_ARB_vertex_program */
   { GL_VERTEX_PROGRAM_ARB, /* == GL_VERTEX_PROGRAM_NV */
     CONTEXT_BOOL(VertexProgram.Enabled),
     extra_ARB_vertex_program_NV_vertex_program },
   { GL_VERTEX_PROGRAM_POINT_SIZE_ARB, /* == GL_VERTEX_PROGRAM_POINT_SIZE_NV*/
     CONTEXT_BOOL(VertexProgram.PointSizeEnabled),
     extra_ARB_vertex_program_NV_vertex_program },
   { GL_VERTEX_PROGRAM_TWO_SIDE_ARB, /* == GL_VERTEX_PROGRAM_TWO_SIDE_NV */
     CONTEXT_BOOL(VertexProgram.TwoSideEnabled),
     extra_ARB_vertex_program_NV_vertex_program },
   { GL_MAX_PROGRAM_MATRIX_STACK_DEPTH_ARB, /* == GL_MAX_TRACK_MATRIX_STACK_DEPTH_NV */
     CONTEXT_INT(Const.MaxProgramMatrixStackDepth),
     extra_ARB_vertex_program_ARB_fragment_program_NV_vertex_program },
   { GL_MAX_PROGRAM_MATRICES_ARB, /* == GL_MAX_TRACK_MATRICES_NV */
     CONTEXT_INT(Const.MaxProgramMatrices),
     extra_ARB_vertex_program_ARB_fragment_program_NV_vertex_program },
   { GL_CURRENT_MATRIX_STACK_DEPTH_ARB, /* == GL_CURRENT_MATRIX_STACK_DEPTH_NV */
     LOC_CUSTOM, TYPE_INT, 0,
     extra_ARB_vertex_program_ARB_fragment_program_NV_vertex_program },

   { GL_CURRENT_MATRIX_ARB, /* == GL_CURRENT_MATRIX_NV */
     LOC_CUSTOM, TYPE_MATRIX, 0,
     extra_ARB_vertex_program_ARB_fragment_program_NV_vertex_program },
   { GL_TRANSPOSE_CURRENT_MATRIX_ARB, /* == GL_CURRENT_MATRIX_NV */
     LOC_CUSTOM, TYPE_MATRIX, 0,
     extra_ARB_vertex_program_ARB_fragment_program },

   { GL_PROGRAM_ERROR_POSITION_ARB, /* == GL_PROGRAM_ERROR_POSITION_NV */
     CONTEXT_INT(Program.ErrorPos),
     extra_NV_vertex_program_ARB_vertex_program_ARB_fragment_program_NV_vertex_program },

   /* GL_ARB_fragment_program */
   { GL_FRAGMENT_PROGRAM_ARB, CONTEXT_BOOL(FragmentProgram.Enabled),
     extra_ARB_fragment_program },

   /* GL_EXT_depth_bounds_test */
   { GL_DEPTH_BOUNDS_TEST_EXT, CONTEXT_BOOL(Depth.BoundsTest),
     extra_EXT_depth_bounds_test },
   { GL_DEPTH_BOUNDS_EXT, CONTEXT_FLOAT2(Depth.BoundsMin),
     extra_EXT_depth_bounds_test },

   /* GL_ARB_depth_clamp*/
   { GL_DEPTH_CLAMP, CONTEXT_BOOL(Transform.DepthClamp),
     extra_ARB_depth_clamp },

   /* GL_ARB_draw_buffers */
   { GL_DRAW_BUFFER0_ARB, BUFFER_ENUM(ColorDrawBuffer[0]), NO_EXTRA },
   { GL_DRAW_BUFFER1_ARB, BUFFER_ENUM(ColorDrawBuffer[1]),
     extra_valid_draw_buffer },
   { GL_DRAW_BUFFER2_ARB, BUFFER_ENUM(ColorDrawBuffer[2]),
     extra_valid_draw_buffer },
   { GL_DRAW_BUFFER3_ARB, BUFFER_ENUM(ColorDrawBuffer[3]),
     extra_valid_draw_buffer },
   { GL_DRAW_BUFFER4_ARB, BUFFER_ENUM(ColorDrawBuffer[4]),
     extra_valid_draw_buffer },
   { GL_DRAW_BUFFER5_ARB, BUFFER_ENUM(ColorDrawBuffer[5]),
     extra_valid_draw_buffer },
   { GL_DRAW_BUFFER6_ARB, BUFFER_ENUM(ColorDrawBuffer[6]),
     extra_valid_draw_buffer },
   { GL_DRAW_BUFFER7_ARB, BUFFER_ENUM(ColorDrawBuffer[7]),
     extra_valid_draw_buffer },

   /* GL_ATI_fragment_shader */
   { GL_NUM_FRAGMENT_REGISTERS_ATI, CONST(6), extra_ATI_fragment_shader },
   { GL_NUM_FRAGMENT_CONSTANTS_ATI, CONST(8), extra_ATI_fragment_shader },
   { GL_NUM_PASSES_ATI, CONST(2), extra_ATI_fragment_shader },
   { GL_NUM_INSTRUCTIONS_PER_PASS_ATI, CONST(8), extra_ATI_fragment_shader },
   { GL_NUM_INSTRUCTIONS_TOTAL_ATI, CONST(16), extra_ATI_fragment_shader },
   { GL_COLOR_ALPHA_PAIRING_ATI, CONST(GL_TRUE), extra_ATI_fragment_shader },
   { GL_NUM_LOOPBACK_COMPONENTS_ATI, CONST(3), extra_ATI_fragment_shader },
   { GL_NUM_INPUT_INTERPOLATOR_COMPONENTS_ATI,
     CONST(3), extra_ATI_fragment_shader },

   /* GL_EXT_framebuffer_object */
   { GL_MAX_COLOR_ATTACHMENTS_EXT, CONTEXT_INT(Const.MaxColorAttachments),
     extra_EXT_framebuffer_object },
   
   /* GL_EXT_framebuffer_blit
    * NOTE: GL_DRAW_FRAMEBUFFER_BINDING_EXT == GL_FRAMEBUFFER_BINDING_EXT */
   { GL_READ_FRAMEBUFFER_BINDING_EXT, LOC_CUSTOM, TYPE_INT, 0,
     extra_EXT_framebuffer_blit },

   /* GL_EXT_provoking_vertex */
   { GL_PROVOKING_VERTEX_EXT,
     CONTEXT_ENUM(Light.ProvokingVertex), extra_EXT_provoking_vertex },
   { GL_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION_EXT,
     CONTEXT_BOOL(Const.QuadsFollowProvokingVertexConvention),
     extra_EXT_provoking_vertex },

   /* GL_ARB_framebuffer_object */
   { GL_MAX_SAMPLES, CONTEXT_INT(Const.MaxSamples),
     extra_ARB_framebuffer_object_EXT_framebuffer_multisample },

   /* GL_APPLE_vertex_array_object */
   { GL_VERTEX_ARRAY_BINDING_APPLE, ARRAY_INT(Name),
     extra_APPLE_vertex_array_object },

   /* GL_ARB_seamless_cube_map */
   { GL_TEXTURE_CUBE_MAP_SEAMLESS,
     CONTEXT_BOOL(Texture.CubeMapSeamless), extra_ARB_seamless_cube_map },

   /* GL_ARB_sync */
   { GL_MAX_SERVER_WAIT_TIMEOUT,
     CONTEXT_INT64(Const.MaxServerWaitTimeout), extra_ARB_sync },

   /* GL_EXT_texture_integer */
   { GL_RGBA_INTEGER_MODE_EXT, BUFFER_BOOL(_IntegerColor),
     extra_EXT_texture_integer },

   /* GL_EXT_transform_feedback */
   { GL_TRANSFORM_FEEDBACK_BUFFER_BINDING, LOC_CUSTOM, TYPE_INT, 0,
     extra_EXT_transform_feedback },
   { GL_RASTERIZER_DISCARD, CONTEXT_BOOL(TransformFeedback.RasterDiscard),
     extra_EXT_transform_feedback },
   { GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS,
     CONTEXT_INT(Const.MaxTransformFeedbackInterleavedComponents),
     extra_EXT_transform_feedback },
   { GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS,
     CONTEXT_INT(Const.MaxTransformFeedbackSeparateAttribs),
     extra_EXT_transform_feedback },
   { GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS,
     CONTEXT_INT(Const.MaxTransformFeedbackSeparateComponents),
     extra_EXT_transform_feedback },

   /* GL_ARB_transform_feedback2 */
   { GL_TRANSFORM_FEEDBACK_BUFFER_PAUSED, LOC_CUSTOM, TYPE_BOOLEAN, 0,
     extra_ARB_transform_feedback2 },
   { GL_TRANSFORM_FEEDBACK_BUFFER_ACTIVE, LOC_CUSTOM, TYPE_BOOLEAN, 0,
     extra_ARB_transform_feedback2 },
   { GL_TRANSFORM_FEEDBACK_BINDING, LOC_CUSTOM, TYPE_INT, 0,
     extra_ARB_transform_feedback2 },

   /* GL_ARB_geometry_shader4 */
   { GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS_ARB,
     CONTEXT_INT(Const.GeometryProgram.MaxGeometryTextureImageUnits),
     extra_ARB_geometry_shader4 },
   { GL_MAX_GEOMETRY_OUTPUT_VERTICES_ARB,
     CONTEXT_INT(Const.GeometryProgram.MaxGeometryOutputVertices),
     extra_ARB_geometry_shader4 },
   { GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS_ARB,
     CONTEXT_INT(Const.GeometryProgram.MaxGeometryTotalOutputComponents),
     extra_ARB_geometry_shader4 },
   { GL_MAX_GEOMETRY_UNIFORM_COMPONENTS_ARB,
     CONTEXT_INT(Const.GeometryProgram.MaxGeometryUniformComponents),
     extra_ARB_geometry_shader4 },
   { GL_MAX_GEOMETRY_VARYING_COMPONENTS_ARB,
     CONTEXT_INT(Const.GeometryProgram.MaxGeometryVaryingComponents),
     extra_ARB_geometry_shader4 },
   { GL_MAX_VERTEX_VARYING_COMPONENTS_ARB,
     CONTEXT_INT(Const.GeometryProgram.MaxVertexVaryingComponents),
     extra_ARB_geometry_shader4 },

   /* GL_EXT_gpu_shader4 / GL 3.0 */
   { GL_MIN_PROGRAM_TEXEL_OFFSET,
     CONTEXT_INT(Const.MinProgramTexelOffset),
     extra_EXT_gpu_shader4 },
   { GL_MAX_PROGRAM_TEXEL_OFFSET,
     CONTEXT_INT(Const.MaxProgramTexelOffset),
     extra_EXT_gpu_shader4 },

   /* GL 3.0 */
   { GL_NUM_EXTENSIONS, LOC_CUSTOM, TYPE_INT, 0, extra_version_30 },
   { GL_MAJOR_VERSION, CONTEXT_INT(VersionMajor), extra_version_30 },
   { GL_MINOR_VERSION, CONTEXT_INT(VersionMinor), extra_version_30  },
   { GL_CONTEXT_FLAGS, CONTEXT_INT(Const.ContextFlags), extra_version_30  },

   /* GL 3.1 */
   /* NOTE: different enum values for GL_PRIMITIVE_RESTART_NV
    * vs. GL_PRIMITIVE_RESTART!
    */
   { GL_PRIMITIVE_RESTART, CONTEXT_BOOL(Array.PrimitiveRestart),
     extra_version_31 },
   { GL_PRIMITIVE_RESTART_INDEX, CONTEXT_INT(Array.RestartIndex),
     extra_version_31 },
 

   /* GL 3.2 */
   { GL_CONTEXT_PROFILE_MASK, CONTEXT_INT(Const.ProfileMask),
     extra_version_32 },
#endif /* FEATURE_GL */
};

/* All we need now is a way to look up the value struct from the enum.
 * The code generated by gcc for the old generated big switch
 * statement is a big, balanced, open coded if/else tree, essentially
 * an unrolled binary search.  It would be natural to sort the new
 * enum table and use bsearch(), but we will use a read-only hash
 * table instead.  bsearch() has a nice guaranteed worst case
 * performance, but we're also guaranteed to hit that worst case
 * (log2(n) iterations) for about half the enums.  Instead, using an
 * open addressing hash table, we can find the enum on the first try
 * for 80% of the enums, 1 collision for 10% and never more than 5
 * collisions for any enum (typical numbers).  And the code is very
 * simple, even though it feels a little magic. */

static unsigned short table[1024];
static const int prime_factor = 89, prime_step = 281;

#ifdef GET_DEBUG
static void
print_table_stats(void)
{
   int i, j, collisions[11], count, hash, mask;
   const struct value_desc *d;

   count = 0;
   mask = Elements(table) - 1;
   memset(collisions, 0, sizeof collisions);

   for (i = 0; i < Elements(table); i++) {
      if (!table[i])
	 continue;
      count++;
      d = &values[table[i]];
      hash = (d->pname * prime_factor);
      j = 0;
      while (1) {
	 if (values[table[hash & mask]].pname == d->pname)
	    break;
	 hash += prime_step;
	 j++;
      }

      if (j < 10)
	 collisions[j]++;
      else
	 collisions[10]++;
   }

   printf("number of enums: %d (total %d)\n", count, Elements(values));
   for (i = 0; i < Elements(collisions) - 1; i++)
      if (collisions[i] > 0)
	 printf("  %d enums with %d %scollisions\n",
		collisions[i], i, i == 10 ? "or more " : "");
}
#endif

/**
 * Initialize the enum hash for a given API 
 *
 * This is called from one_time_init() to insert the enum values that
 * are valid for the API in question into the enum hash table.
 *
 * \param the current context, for determining the API in question
d51 5
a55 25
void _mesa_init_get_hash(struct gl_context *ctx)
{
   int i, hash, index, mask;
   int api_mask = 0, api_bit;

   mask = Elements(table) - 1;
   api_bit = 1 << ctx->API;

   for (i = 0; i < Elements(values); i++) {
      if (values[i].type == TYPE_API_MASK) {
	 api_mask = values[i].offset;
	 continue;
      }
      if (!(api_mask & api_bit))
	 continue;

      hash = (values[i].pname * prime_factor) & mask;
      while (1) {
	 index = hash & mask;
	 if (!table[index]) {
	    table[index] = i;
	    break;
	 }
	 hash += prime_step;
      }
d58 2
a59 20
#ifdef GET_DEBUG
   print_table_stats();
#endif
}

/**
 * Handle irregular enums
 *
 * Some values don't conform to the "well-known type at context
 * pointer + offset" pattern, so we have this function to catch all
 * the corner cases.  Typically, it's a computed value or a one-off
 * pointer to a custom struct or something.
 *
 * In this case we can't return a pointer to the value, so we'll have
 * to use the temporary variable 'v' declared back in the calling
 * glGet*v() function to store the result.
 *
 * \param ctx the current context
 * \param d the struct value_desc that describes the enum
 * \param v pointer to the tmp declared in the calling glGet*v() function
d61 5
a65 363
static void
find_custom_value(struct gl_context *ctx, const struct value_desc *d, union value *v)
{
   struct gl_buffer_object **buffer_obj;
   struct gl_client_array *array;
   GLuint unit, *p;

   switch (d->pname) {
   case GL_TEXTURE_1D:
   case GL_TEXTURE_2D:
   case GL_TEXTURE_3D:
   case GL_TEXTURE_1D_ARRAY_EXT:
   case GL_TEXTURE_2D_ARRAY_EXT:
   case GL_TEXTURE_CUBE_MAP_ARB:
   case GL_TEXTURE_RECTANGLE_NV:
      v->value_bool = _mesa_IsEnabled(d->pname);
      break;

   case GL_LINE_STIPPLE_PATTERN:
      /* This is the only GLushort, special case it here by promoting
       * to an int rather than introducing a new type. */
      v->value_int = ctx->Line.StipplePattern;
      break;

   case GL_CURRENT_RASTER_TEXTURE_COORDS:
      unit = ctx->Texture.CurrentUnit;
      v->value_float_4[0] = ctx->Current.RasterTexCoords[unit][0];
      v->value_float_4[1] = ctx->Current.RasterTexCoords[unit][1];
      v->value_float_4[2] = ctx->Current.RasterTexCoords[unit][2];
      v->value_float_4[3] = ctx->Current.RasterTexCoords[unit][3];
      break;

   case GL_CURRENT_TEXTURE_COORDS:
      unit = ctx->Texture.CurrentUnit;
      v->value_float_4[0] = ctx->Current.Attrib[VERT_ATTRIB_TEX0 + unit][0];
      v->value_float_4[1] = ctx->Current.Attrib[VERT_ATTRIB_TEX0 + unit][1];
      v->value_float_4[2] = ctx->Current.Attrib[VERT_ATTRIB_TEX0 + unit][2];
      v->value_float_4[3] = ctx->Current.Attrib[VERT_ATTRIB_TEX0 + unit][3];
      break;

   case GL_COLOR_WRITEMASK:
      v->value_int_4[0] = ctx->Color.ColorMask[0][RCOMP] ? 1 : 0;
      v->value_int_4[1] = ctx->Color.ColorMask[0][GCOMP] ? 1 : 0;
      v->value_int_4[2] = ctx->Color.ColorMask[0][BCOMP] ? 1 : 0;
      v->value_int_4[3] = ctx->Color.ColorMask[0][ACOMP] ? 1 : 0;
      break;

   case GL_EDGE_FLAG:
      v->value_bool = ctx->Current.Attrib[VERT_ATTRIB_EDGEFLAG][0] == 1.0;
      break;

   case GL_READ_BUFFER:
      v->value_enum = ctx->ReadBuffer->ColorReadBuffer;
      break;

   case GL_MAP2_GRID_DOMAIN:
      v->value_float_4[0] = ctx->Eval.MapGrid2u1;
      v->value_float_4[1] = ctx->Eval.MapGrid2u2;
      v->value_float_4[2] = ctx->Eval.MapGrid2v1;
      v->value_float_4[3] = ctx->Eval.MapGrid2v2;
      break;

   case GL_TEXTURE_STACK_DEPTH:
      unit = ctx->Texture.CurrentUnit;
      v->value_int = ctx->TextureMatrixStack[unit].Depth + 1;
      break;
   case GL_TEXTURE_MATRIX:
      unit = ctx->Texture.CurrentUnit;
      v->value_matrix = ctx->TextureMatrixStack[unit].Top;
      break;

   case GL_TEXTURE_COORD_ARRAY:
   case GL_TEXTURE_COORD_ARRAY_SIZE:
   case GL_TEXTURE_COORD_ARRAY_TYPE:
   case GL_TEXTURE_COORD_ARRAY_STRIDE:
      array = &ctx->Array.ArrayObj->TexCoord[ctx->Array.ActiveTexture];
      v->value_int = *(GLuint *) ((char *) array + d->offset);
      break;

   case GL_ACTIVE_TEXTURE_ARB:
      v->value_int = GL_TEXTURE0_ARB + ctx->Texture.CurrentUnit;
      break;
   case GL_CLIENT_ACTIVE_TEXTURE_ARB:
      v->value_int = GL_TEXTURE0_ARB + ctx->Array.ActiveTexture;
      break;

   case GL_MODELVIEW_STACK_DEPTH:
   case GL_PROJECTION_STACK_DEPTH:
      v->value_int = *(GLint *) ((char *) ctx + d->offset) + 1;
      break;

   case GL_MAX_TEXTURE_SIZE:
   case GL_MAX_3D_TEXTURE_SIZE:
   case GL_MAX_CUBE_MAP_TEXTURE_SIZE_ARB:
      p = (GLuint *) ((char *) ctx + d->offset);
      v->value_int = 1 << (*p - 1);
      break;

   case GL_SCISSOR_BOX:
      v->value_int_4[0] = ctx->Scissor.X;
      v->value_int_4[1] = ctx->Scissor.Y;
      v->value_int_4[2] = ctx->Scissor.Width;
      v->value_int_4[3] = ctx->Scissor.Height;
      break;

   case GL_LIST_INDEX:
      v->value_int =
	 ctx->ListState.CurrentList ? ctx->ListState.CurrentList->Name : 0;
      break;
   case GL_LIST_MODE:
      if (!ctx->CompileFlag)
	 v->value_enum = 0;
      else if (ctx->ExecuteFlag)
	 v->value_enum = GL_COMPILE_AND_EXECUTE;
      else
	 v->value_enum = GL_COMPILE;
      break;

   case GL_VIEWPORT:
      v->value_int_4[0] = ctx->Viewport.X;
      v->value_int_4[1] = ctx->Viewport.Y;
      v->value_int_4[2] = ctx->Viewport.Width;
      v->value_int_4[3] = ctx->Viewport.Height;
      break;

   case GL_ACTIVE_STENCIL_FACE_EXT:
      v->value_enum = ctx->Stencil.ActiveFace ? GL_BACK : GL_FRONT;
      break;

   case GL_STENCIL_FAIL:
      v->value_enum = ctx->Stencil.FailFunc[ctx->Stencil.ActiveFace];
      break;
   case GL_STENCIL_FUNC:
      v->value_enum = ctx->Stencil.Function[ctx->Stencil.ActiveFace];
      break;
   case GL_STENCIL_PASS_DEPTH_FAIL:
      v->value_enum = ctx->Stencil.ZFailFunc[ctx->Stencil.ActiveFace];
      break;
   case GL_STENCIL_PASS_DEPTH_PASS:
      v->value_enum = ctx->Stencil.ZPassFunc[ctx->Stencil.ActiveFace];
      break;
   case GL_STENCIL_REF:
      v->value_int = ctx->Stencil.Ref[ctx->Stencil.ActiveFace];
      break;
   case GL_STENCIL_VALUE_MASK:
      v->value_int = ctx->Stencil.ValueMask[ctx->Stencil.ActiveFace];
      break;
   case GL_STENCIL_WRITEMASK:
      v->value_int = ctx->Stencil.WriteMask[ctx->Stencil.ActiveFace];
      break;

   case GL_NUM_EXTENSIONS:
      v->value_int = _mesa_get_extension_count(ctx);
      break;

   case GL_IMPLEMENTATION_COLOR_READ_TYPE_OES:
      v->value_int = _mesa_get_color_read_type(ctx);
      break;
   case GL_IMPLEMENTATION_COLOR_READ_FORMAT_OES:
      v->value_int = _mesa_get_color_read_format(ctx);
      break;

   case GL_CURRENT_MATRIX_STACK_DEPTH_ARB:
      v->value_int = ctx->CurrentStack->Depth + 1;
      break;
   case GL_CURRENT_MATRIX_ARB:
   case GL_TRANSPOSE_CURRENT_MATRIX_ARB:
      v->value_matrix = ctx->CurrentStack->Top;
      break;

   case GL_NUM_COMPRESSED_TEXTURE_FORMATS_ARB:
      v->value_int = _mesa_get_compressed_formats(ctx, NULL, GL_FALSE);
      break;
   case GL_COMPRESSED_TEXTURE_FORMATS_ARB:
      v->value_int_n.n = 
	 _mesa_get_compressed_formats(ctx, v->value_int_n.ints, GL_FALSE);
      ASSERT(v->value_int_n.n <= 100);
      break;

   case GL_MAX_VARYING_FLOATS_ARB:
      v->value_int = ctx->Const.MaxVarying * 4;
      break;

   /* Various object names */

   case GL_TEXTURE_BINDING_1D:
   case GL_TEXTURE_BINDING_2D:
   case GL_TEXTURE_BINDING_3D:
   case GL_TEXTURE_BINDING_1D_ARRAY_EXT:
   case GL_TEXTURE_BINDING_2D_ARRAY_EXT:
   case GL_TEXTURE_BINDING_CUBE_MAP_ARB:
   case GL_TEXTURE_BINDING_RECTANGLE_NV:
      unit = ctx->Texture.CurrentUnit;
      v->value_int =
	 ctx->Texture.Unit[unit].CurrentTex[d->offset]->Name;
      break;

   /* GL_ARB_vertex_buffer_object */
   case GL_VERTEX_ARRAY_BUFFER_BINDING_ARB:
   case GL_NORMAL_ARRAY_BUFFER_BINDING_ARB:
   case GL_COLOR_ARRAY_BUFFER_BINDING_ARB:
   case GL_INDEX_ARRAY_BUFFER_BINDING_ARB:
   case GL_EDGE_FLAG_ARRAY_BUFFER_BINDING_ARB:
   case GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING_ARB:
   case GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING_ARB:
      buffer_obj = (struct gl_buffer_object **)
	 ((char *) ctx->Array.ArrayObj + d->offset);
      v->value_int = (*buffer_obj)->Name;
      break;
   case GL_ARRAY_BUFFER_BINDING_ARB:
      v->value_int = ctx->Array.ArrayBufferObj->Name;
      break;
   case GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING_ARB:
      v->value_int =
	 ctx->Array.ArrayObj->TexCoord[ctx->Array.ActiveTexture].BufferObj->Name;
      break;
   case GL_ELEMENT_ARRAY_BUFFER_BINDING_ARB:
      v->value_int = ctx->Array.ElementArrayBufferObj->Name;
      break;

   /* ARB_copy_buffer */
   case GL_COPY_READ_BUFFER:
      v->value_int = ctx->CopyReadBuffer->Name;
      break;
   case GL_COPY_WRITE_BUFFER:
      v->value_int = ctx->CopyWriteBuffer->Name;
      break;

   case GL_FRAGMENT_PROGRAM_BINDING_NV:
      v->value_int = 
	 ctx->FragmentProgram.Current ? ctx->FragmentProgram.Current->Base.Id : 0;
      break;
   case GL_VERTEX_PROGRAM_BINDING_NV:
      v->value_int =
	 ctx->VertexProgram.Current ? ctx->VertexProgram.Current->Base.Id : 0;
      break;
   case GL_PIXEL_PACK_BUFFER_BINDING_EXT:
      v->value_int = ctx->Pack.BufferObj->Name;
      break;
   case GL_PIXEL_UNPACK_BUFFER_BINDING_EXT:
      v->value_int = ctx->Unpack.BufferObj->Name;
      break;
   case GL_TRANSFORM_FEEDBACK_BUFFER_BINDING:
      v->value_int = ctx->TransformFeedback.CurrentBuffer->Name;
      break;
   case GL_TRANSFORM_FEEDBACK_BUFFER_PAUSED:
      v->value_int = ctx->TransformFeedback.CurrentObject->Paused;
      break;
   case GL_TRANSFORM_FEEDBACK_BUFFER_ACTIVE:
      v->value_int = ctx->TransformFeedback.CurrentObject->Active;
      break;
   case GL_TRANSFORM_FEEDBACK_BINDING:
      v->value_int = ctx->TransformFeedback.CurrentObject->Name;
      break;
   case GL_CURRENT_PROGRAM:
      v->value_int =
	 ctx->Shader.ActiveProgram ? ctx->Shader.ActiveProgram->Name : 0;
      break;
   case GL_READ_FRAMEBUFFER_BINDING_EXT:
      v->value_int = ctx->ReadBuffer->Name;
      break;
   case GL_RENDERBUFFER_BINDING_EXT:
      v->value_int =
	 ctx->CurrentRenderbuffer ? ctx->CurrentRenderbuffer->Name : 0;
      break;
   case GL_POINT_SIZE_ARRAY_BUFFER_BINDING_OES:
      v->value_int = ctx->Array.ArrayObj->PointSize.BufferObj->Name;
      break;

   case GL_MAX_VERTEX_UNIFORM_VECTORS:
      v->value_int = ctx->Const.VertexProgram.MaxUniformComponents / 4;
      break;

   case GL_MAX_FRAGMENT_UNIFORM_VECTORS:
      v->value_int = ctx->Const.FragmentProgram.MaxUniformComponents / 4;
      break;
   }   
}

/**
 * Check extra constraints on a struct value_desc descriptor
 *
 * If a struct value_desc has a non-NULL extra pointer, it means that
 * there are a number of extra constraints to check or actions to
 * perform.  The extras is just an integer array where each integer
 * encode different constraints or actions.
 *
 * \param ctx current context
 * \param func name of calling glGet*v() function for error reporting
 * \param d the struct value_desc that has the extra constraints
 *
 * \return GL_FALSE if one of the constraints was not satisfied,
 *     otherwise GL_TRUE.
 */
static GLboolean
check_extra(struct gl_context *ctx, const char *func, const struct value_desc *d)
{
   const GLuint version = ctx->VersionMajor * 10 + ctx->VersionMinor;
   int total, enabled;
   const int *e;

   total = 0;
   enabled = 0;
   for (e = d->extra; *e != EXTRA_END; e++)
      switch (*e) {
      case EXTRA_VERSION_30:
	 if (version >= 30) {
	    total++;
	    enabled++;
	 }
	 break;
      case EXTRA_VERSION_31:
	 if (version >= 31) {
	    total++;
	    enabled++;
	 }
	 break;
      case EXTRA_VERSION_32:
	 if (version >= 32) {
	    total++;
	    enabled++;
	 }
	 break;
      case EXTRA_VERSION_ES2:
	 if (ctx->API == API_OPENGLES2) {
	    total++;
	    enabled++;
	 }
	 break;
      case EXTRA_NEW_BUFFERS:
	 if (ctx->NewState & _NEW_BUFFERS)
	    _mesa_update_state(ctx);
	 break;
      case EXTRA_FLUSH_CURRENT:
	 FLUSH_CURRENT(ctx, 0);
	 break;
      case EXTRA_VALID_DRAW_BUFFER:
	 if (d->pname - GL_DRAW_BUFFER0_ARB >= ctx->Const.MaxDrawBuffers) {
	    _mesa_error(ctx, GL_INVALID_OPERATION, "%s(draw buffer %u)",
			func, d->pname - GL_DRAW_BUFFER0_ARB);
	    return GL_FALSE;
	 }
	 break;
      case EXTRA_VALID_TEXTURE_UNIT:
	 if (ctx->Texture.CurrentUnit >= ctx->Const.MaxTextureCoordUnits) {
	    _mesa_error(ctx, GL_INVALID_OPERATION, "%s(texture %u)",
			func, ctx->Texture.CurrentUnit);
	    return GL_FALSE;
	 }
	 break;
      case EXTRA_END:
	 break;
      default: /* *e is a offset into the extension struct */
	 total++;
	 if (*(GLboolean *) ((char *) &ctx->Extensions + *e))
	    enabled++;
	 break;
      }

   if (total > 0 && enabled == 0) {
      _mesa_error(ctx, GL_INVALID_ENUM, "%s(pname=%s)", func,
                  _mesa_lookup_enum_by_nr(d->pname));
      return GL_FALSE;
a67 2
   return GL_TRUE;
}
d69 2
a70 27
static const struct value_desc error_value =
   { 0, 0, TYPE_INVALID, NO_OFFSET, NO_EXTRA };

/**
 * Find the struct value_desc corresponding to the enum 'pname'.
 * 
 * We hash the enum value to get an index into the 'table' array,
 * which holds the index in the 'values' array of struct value_desc.
 * Once we've found the entry, we do the extra checks, if any, then
 * look up the value and return a pointer to it.
 *
 * If the value has to be computed (for example, it's the result of a
 * function call or we need to add 1 to it), we use the tmp 'v' to
 * store the result.
 * 
 * \param func name of glGet*v() func for error reporting
 * \param pname the enum value we're looking up
 * \param p is were we return the pointer to the value
 * \param v a tmp union value variable in the calling glGet*v() function
 *
 * \return the struct value_desc corresponding to the enum or a struct
 *     value_desc of TYPE_INVALID if not found.  This lets the calling
 *     glGet*v() function jump right into a switch statement and
 *     handle errors there instead of having to check for NULL.
 */
static const struct value_desc *
find_value(const char *func, GLenum pname, void **p, union value *v)
d73 1
a73 16
   struct gl_texture_unit *unit;
   int mask, hash;
   const struct value_desc *d;

   mask = Elements(table) - 1;
   hash = (pname * prime_factor);
   while (1) {
      d = &values[table[hash & mask]];

      /* If the enum isn't valid, the hash walk ends with index 0,
       * which is the API mask entry at the beginning of values[]. */
      if (unlikely(d->type == TYPE_API_MASK)) {
	 _mesa_error(ctx, GL_INVALID_ENUM, "%s(pname=%s)", func,
                     _mesa_lookup_enum_by_nr(pname));
	 return &error_value;
      }
d75 2
a76 2
      if (likely(d->pname == pname))
	 break;
d78 2
a79 2
      hash += prime_step;
   }
d81 3
a83 2
   if (unlikely(d->extra && !check_extra(ctx, func, d)))
      return &error_value;
d85 1812
a1896 21
   switch (d->location) {
   case LOC_BUFFER:
      *p = ((char *) ctx->DrawBuffer + d->offset);
      return d;
   case LOC_CONTEXT:
      *p = ((char *) ctx + d->offset);
      return d;
   case LOC_ARRAY:
      *p = ((char *) ctx->Array.ArrayObj + d->offset);
      return d;
   case LOC_TEXUNIT:
      unit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
      *p = ((char *) unit + d->offset);
      return d;
   case LOC_CUSTOM:
      find_custom_value(ctx, d, v);
      *p = v;
      return d;
   default:
      assert(0);
      break;
a1897 3

   /* silence warning */
   return &error_value;
a1899 7
static const int transpose[] = {
   0, 4,  8, 12,
   1, 5,  9, 13,
   2, 6, 10, 14,
   3, 7, 11, 15
};

d1901 1
a1901 1
_mesa_GetBooleanv(GLenum pname, GLboolean *params)
d1903 5
a1907 80
   const struct value_desc *d;
   union value v;
   GLmatrix *m;
   int shift, i;
   void *p;

   d = find_value("glGetBooleanv", pname, &p, &v);
   switch (d->type) {
   case TYPE_INVALID:
      break;
   case TYPE_CONST:
      params[0] = INT_TO_BOOLEAN(d->offset);
      break;

   case TYPE_FLOAT_4:
   case TYPE_FLOATN_4:
      params[3] = FLOAT_TO_BOOLEAN(((GLfloat *) p)[3]);
   case TYPE_FLOAT_3:
   case TYPE_FLOATN_3:
      params[2] = FLOAT_TO_BOOLEAN(((GLfloat *) p)[2]);
   case TYPE_FLOAT_2:
   case TYPE_FLOATN_2:
      params[1] = FLOAT_TO_BOOLEAN(((GLfloat *) p)[1]);
   case TYPE_FLOAT:
   case TYPE_FLOATN:
      params[0] = FLOAT_TO_BOOLEAN(((GLfloat *) p)[0]);
      break;

   case TYPE_DOUBLEN:
      params[0] = FLOAT_TO_BOOLEAN(((GLdouble *) p)[0]);
      break;

   case TYPE_INT_4:
      params[3] = INT_TO_BOOLEAN(((GLint *) p)[3]);
   case TYPE_INT_3:
      params[2] = INT_TO_BOOLEAN(((GLint *) p)[2]);
   case TYPE_INT_2:
   case TYPE_ENUM_2:
      params[1] = INT_TO_BOOLEAN(((GLint *) p)[1]);
   case TYPE_INT:
   case TYPE_ENUM:
      params[0] = INT_TO_BOOLEAN(((GLint *) p)[0]);
      break;

   case TYPE_INT_N:
      for (i = 0; i < v.value_int_n.n; i++)
	 params[i] = INT_TO_BOOLEAN(v.value_int_n.ints[i]);
      break;

   case TYPE_INT64:
      params[0] = INT64_TO_BOOLEAN(((GLint64 *) p)[0]);
      break;

   case TYPE_BOOLEAN:
      params[0] = ((GLboolean*) p)[0];
      break;		

   case TYPE_MATRIX:
      m = *(GLmatrix **) p;
      for (i = 0; i < 16; i++)
	 params[i] = FLOAT_TO_BOOLEAN(m->m[i]);
      break;

   case TYPE_MATRIX_T:
      m = *(GLmatrix **) p;
      for (i = 0; i < 16; i++)
	 params[i] = FLOAT_TO_BOOLEAN(m->m[transpose[i]]);
      break;

   case TYPE_BIT_0:
   case TYPE_BIT_1:
   case TYPE_BIT_2:
   case TYPE_BIT_3:
   case TYPE_BIT_4:
   case TYPE_BIT_5:
      shift = d->type - TYPE_BIT_0;
      params[0] = (*(GLbitfield *) p >> shift) & 1;
      break;
   }
}
d1909 2
a1910 83
void GLAPIENTRY
_mesa_GetFloatv(GLenum pname, GLfloat *params)
{
   const struct value_desc *d;
   union value v;
   GLmatrix *m;
   int shift, i;
   void *p;

   d = find_value("glGetFloatv", pname, &p, &v);
   switch (d->type) {
   case TYPE_INVALID:
      break;
   case TYPE_CONST:
      params[0] = (GLfloat) d->offset;
      break;

   case TYPE_FLOAT_4:
   case TYPE_FLOATN_4:
      params[3] = ((GLfloat *) p)[3];
   case TYPE_FLOAT_3:
   case TYPE_FLOATN_3:
      params[2] = ((GLfloat *) p)[2];
   case TYPE_FLOAT_2:
   case TYPE_FLOATN_2:
      params[1] = ((GLfloat *) p)[1];
   case TYPE_FLOAT:
   case TYPE_FLOATN:
      params[0] = ((GLfloat *) p)[0];
      break;

   case TYPE_DOUBLEN:
      params[0] = ((GLdouble *) p)[0];
      break;

   case TYPE_INT_4:
      params[3] = (GLfloat) (((GLint *) p)[3]);
   case TYPE_INT_3:
      params[2] = (GLfloat) (((GLint *) p)[2]);
   case TYPE_INT_2:
   case TYPE_ENUM_2:
      params[1] = (GLfloat) (((GLint *) p)[1]);
   case TYPE_INT:
   case TYPE_ENUM:
      params[0] = (GLfloat) (((GLint *) p)[0]);
      break;

   case TYPE_INT_N:
      for (i = 0; i < v.value_int_n.n; i++)
	 params[i] = INT_TO_FLOAT(v.value_int_n.ints[i]);
      break;

   case TYPE_INT64:
      params[0] = ((GLint64 *) p)[0];
      break;

   case TYPE_BOOLEAN:
      params[0] = BOOLEAN_TO_FLOAT(*(GLboolean*) p);
      break;		

   case TYPE_MATRIX:
      m = *(GLmatrix **) p;
      for (i = 0; i < 16; i++)
	 params[i] = m->m[i];
      break;

   case TYPE_MATRIX_T:
      m = *(GLmatrix **) p;
      for (i = 0; i < 16; i++)
	 params[i] = m->m[transpose[i]];
      break;

   case TYPE_BIT_0:
   case TYPE_BIT_1:
   case TYPE_BIT_2:
   case TYPE_BIT_3:
   case TYPE_BIT_4:
   case TYPE_BIT_5:
      shift = d->type - TYPE_BIT_0;
      params[0] = BOOLEAN_TO_FLOAT((*(GLbitfield *) p >> shift) & 1);
      break;
   }
}
d1912 3
a1914 89
void GLAPIENTRY
_mesa_GetIntegerv(GLenum pname, GLint *params)
{
   const struct value_desc *d;
   union value v;
   GLmatrix *m;
   int shift, i;
   void *p;

   d = find_value("glGetIntegerv", pname, &p, &v);
   switch (d->type) {
   case TYPE_INVALID:
      break;
   case TYPE_CONST:
      params[0] = d->offset;
      break;

   case TYPE_FLOAT_4:
      params[3] = IROUND(((GLfloat *) p)[3]);
   case TYPE_FLOAT_3:
      params[2] = IROUND(((GLfloat *) p)[2]);
   case TYPE_FLOAT_2:
      params[1] = IROUND(((GLfloat *) p)[1]);
   case TYPE_FLOAT:
      params[0] = IROUND(((GLfloat *) p)[0]);
      break;

   case TYPE_FLOATN_4:
      params[3] = FLOAT_TO_INT(((GLfloat *) p)[3]);
   case TYPE_FLOATN_3:
      params[2] = FLOAT_TO_INT(((GLfloat *) p)[2]);
   case TYPE_FLOATN_2:
      params[1] = FLOAT_TO_INT(((GLfloat *) p)[1]);
   case TYPE_FLOATN:
      params[0] = FLOAT_TO_INT(((GLfloat *) p)[0]);
      break;

   case TYPE_DOUBLEN:
      params[0] = FLOAT_TO_INT(((GLdouble *) p)[0]);
      break;

   case TYPE_INT_4:
      params[3] = ((GLint *) p)[3];
   case TYPE_INT_3:
      params[2] = ((GLint *) p)[2];
   case TYPE_INT_2:
   case TYPE_ENUM_2:
      params[1] = ((GLint *) p)[1];
   case TYPE_INT:
   case TYPE_ENUM:
      params[0] = ((GLint *) p)[0];
      break;

   case TYPE_INT_N:
      for (i = 0; i < v.value_int_n.n; i++)
	 params[i] = v.value_int_n.ints[i];
      break;

   case TYPE_INT64:
      params[0] = INT64_TO_INT(((GLint64 *) p)[0]);
      break;

   case TYPE_BOOLEAN:
      params[0] = BOOLEAN_TO_INT(*(GLboolean*) p);
      break;		

   case TYPE_MATRIX:
      m = *(GLmatrix **) p;
      for (i = 0; i < 16; i++)
	 params[i] = FLOAT_TO_INT(m->m[i]);
      break;

   case TYPE_MATRIX_T:
      m = *(GLmatrix **) p;
      for (i = 0; i < 16; i++)
	 params[i] = FLOAT_TO_INT(m->m[transpose[i]]);
      break;

   case TYPE_BIT_0:
   case TYPE_BIT_1:
   case TYPE_BIT_2:
   case TYPE_BIT_3:
   case TYPE_BIT_4:
   case TYPE_BIT_5:
      shift = d->type - TYPE_BIT_0;
      params[0] = (*(GLbitfield *) p >> shift) & 1;
      break;
   }
}
d1916 1812
a3727 88
#if FEATURE_ARB_sync
void GLAPIENTRY
_mesa_GetInteger64v(GLenum pname, GLint64 *params)
{
   const struct value_desc *d;
   union value v;
   GLmatrix *m;
   int shift, i;
   void *p;

   d = find_value("glGetInteger64v", pname, &p, &v);
   switch (d->type) {
   case TYPE_INVALID:
      break;
   case TYPE_CONST:
      params[0] = d->offset;
      break;

   case TYPE_FLOAT_4:
      params[3] = IROUND64(((GLfloat *) p)[3]);
   case TYPE_FLOAT_3:
      params[2] = IROUND64(((GLfloat *) p)[2]);
   case TYPE_FLOAT_2:
      params[1] = IROUND64(((GLfloat *) p)[1]);
   case TYPE_FLOAT:
      params[0] = IROUND64(((GLfloat *) p)[0]);
      break;

   case TYPE_FLOATN_4:
      params[3] = FLOAT_TO_INT64(((GLfloat *) p)[3]);
   case TYPE_FLOATN_3:
      params[2] = FLOAT_TO_INT64(((GLfloat *) p)[2]);
   case TYPE_FLOATN_2:
      params[1] = FLOAT_TO_INT64(((GLfloat *) p)[1]);
   case TYPE_FLOATN:
      params[0] = FLOAT_TO_INT64(((GLfloat *) p)[0]);
      break;

   case TYPE_DOUBLEN:
      params[0] = FLOAT_TO_INT64(((GLdouble *) p)[0]);
      break;

   case TYPE_INT_4:
      params[3] = ((GLint *) p)[3];
   case TYPE_INT_3:
      params[2] = ((GLint *) p)[2];
   case TYPE_INT_2:
   case TYPE_ENUM_2:
      params[1] = ((GLint *) p)[1];
   case TYPE_INT:
   case TYPE_ENUM:
      params[0] = ((GLint *) p)[0];
      break;

   case TYPE_INT_N:
      for (i = 0; i < v.value_int_n.n; i++)
	 params[i] = INT_TO_BOOLEAN(v.value_int_n.ints[i]);
      break;

   case TYPE_INT64:
      params[0] = ((GLint64 *) p)[0];
      break;

   case TYPE_BOOLEAN:
      params[0] = ((GLboolean*) p)[0];
      break;		

   case TYPE_MATRIX:
      m = *(GLmatrix **) p;
      for (i = 0; i < 16; i++)
	 params[i] = FLOAT_TO_INT64(m->m[i]);
      break;

   case TYPE_MATRIX_T:
      m = *(GLmatrix **) p;
      for (i = 0; i < 16; i++)
	 params[i] = FLOAT_TO_INT64(m->m[transpose[i]]);
      break;

   case TYPE_BIT_0:
   case TYPE_BIT_1:
   case TYPE_BIT_2:
   case TYPE_BIT_3:
   case TYPE_BIT_4:
   case TYPE_BIT_5:
      shift = d->type - TYPE_BIT_0;
      params[0] = (*(GLbitfield *) p >> shift) & 1;
      break;
a3729 1
#endif /* FEATURE_ARB_sync */
d3732 1
a3732 85
_mesa_GetDoublev(GLenum pname, GLdouble *params)
{
   const struct value_desc *d;
   union value v;
   GLmatrix *m;
   int shift, i;
   void *p;

   d = find_value("glGetDoublev", pname, &p, &v);
   switch (d->type) {
   case TYPE_INVALID:
      break;
   case TYPE_CONST:
      params[0] = d->offset;
      break;

   case TYPE_FLOAT_4:
   case TYPE_FLOATN_4:
      params[3] = ((GLfloat *) p)[3];
   case TYPE_FLOAT_3:
   case TYPE_FLOATN_3:
      params[2] = ((GLfloat *) p)[2];
   case TYPE_FLOAT_2:
   case TYPE_FLOATN_2:
      params[1] = ((GLfloat *) p)[1];
   case TYPE_FLOAT:
   case TYPE_FLOATN:
      params[0] = ((GLfloat *) p)[0];
      break;

   case TYPE_DOUBLEN:
      params[0] = ((GLdouble *) p)[0];
      break;

   case TYPE_INT_4:
      params[3] = ((GLint *) p)[3];
   case TYPE_INT_3:
      params[2] = ((GLint *) p)[2];
   case TYPE_INT_2:
   case TYPE_ENUM_2:
      params[1] = ((GLint *) p)[1];
   case TYPE_INT:
   case TYPE_ENUM:
      params[0] = ((GLint *) p)[0];
      break;

   case TYPE_INT_N:
      for (i = 0; i < v.value_int_n.n; i++)
	 params[i] = v.value_int_n.ints[i];
      break;

   case TYPE_INT64:
      params[0] = ((GLint64 *) p)[0];
      break;

   case TYPE_BOOLEAN:
      params[0] = *(GLboolean*) p;
      break;		

   case TYPE_MATRIX:
      m = *(GLmatrix **) p;
      for (i = 0; i < 16; i++)
	 params[i] = m->m[i];
      break;

   case TYPE_MATRIX_T:
      m = *(GLmatrix **) p;
      for (i = 0; i < 16; i++)
	 params[i] = m->m[transpose[i]];
      break;

   case TYPE_BIT_0:
   case TYPE_BIT_1:
   case TYPE_BIT_2:
   case TYPE_BIT_3:
   case TYPE_BIT_4:
   case TYPE_BIT_5:
      shift = d->type - TYPE_BIT_0;
      params[0] = (*(GLbitfield *) p >> shift) & 1;
      break;
   }
}

static enum value_type
find_value_indexed(const char *func, GLenum pname, int index, union value *v)
d3735 1
d3737 2
a3738 1
   switch (pname) {
d3740 2
a3741 43
   case GL_BLEND:
      if (index >= ctx->Const.MaxDrawBuffers)
	 goto invalid_value;
      if (!ctx->Extensions.EXT_draw_buffers2)
	 goto invalid_enum;
      v->value_int = (ctx->Color.BlendEnabled >> index) & 1;
      return TYPE_INT;

   case GL_COLOR_WRITEMASK:
      if (index >= ctx->Const.MaxDrawBuffers)
	 goto invalid_value;
      if (!ctx->Extensions.EXT_draw_buffers2)
	 goto invalid_enum;
      v->value_int_4[0] = ctx->Color.ColorMask[index][RCOMP] ? 1 : 0;
      v->value_int_4[1] = ctx->Color.ColorMask[index][GCOMP] ? 1 : 0;
      v->value_int_4[2] = ctx->Color.ColorMask[index][BCOMP] ? 1 : 0;
      v->value_int_4[3] = ctx->Color.ColorMask[index][ACOMP] ? 1 : 0;
      return TYPE_INT_4;

   case GL_TRANSFORM_FEEDBACK_BUFFER_START:
      if (index >= ctx->Const.MaxTransformFeedbackSeparateAttribs)
	 goto invalid_value;
      if (!ctx->Extensions.EXT_transform_feedback)
	 goto invalid_enum;
      v->value_int64 = ctx->TransformFeedback.CurrentObject->Offset[index];
      return TYPE_INT64;

   case GL_TRANSFORM_FEEDBACK_BUFFER_SIZE:
      if (index >= ctx->Const.MaxTransformFeedbackSeparateAttribs)
	 goto invalid_value;
      if (!ctx->Extensions.EXT_transform_feedback)
	 goto invalid_enum;
      v->value_int64 = ctx->TransformFeedback.CurrentObject->Size[index];
      return TYPE_INT64;

   case GL_TRANSFORM_FEEDBACK_BUFFER_BINDING:
      if (index >= ctx->Const.MaxTransformFeedbackSeparateAttribs)
	 goto invalid_value;
      if (!ctx->Extensions.EXT_transform_feedback)
	 goto invalid_enum;
      v->value_int = ctx->TransformFeedback.CurrentObject->Buffers[index]->Name;
      return TYPE_INT;
   }
d3743 3
a3745 9
 invalid_enum:
   _mesa_error(ctx, GL_INVALID_ENUM, "%s(pname=%s)", func,
               _mesa_lookup_enum_by_nr(pname));
   return TYPE_INVALID;
 invalid_value:
   _mesa_error(ctx, GL_INVALID_VALUE, "%s(pname=%s)", func,
               _mesa_lookup_enum_by_nr(pname));
   return TYPE_INVALID;
}
d3747 1812
a5558 22
void GLAPIENTRY
_mesa_GetBooleanIndexedv( GLenum pname, GLuint index, GLboolean *params )
{
   union value v;
   enum value_type type =
      find_value_indexed("glGetBooleanIndexedv", pname, index, &v);

   switch (type) {
   case TYPE_INT:
      params[0] = INT_TO_BOOLEAN(v.value_int);
      break;
   case TYPE_INT_4:
      params[0] = INT_TO_BOOLEAN(v.value_int_4[0]);
      params[1] = INT_TO_BOOLEAN(v.value_int_4[1]);
      params[2] = INT_TO_BOOLEAN(v.value_int_4[2]);
      params[3] = INT_TO_BOOLEAN(v.value_int_4[3]);
      break;
   case TYPE_INT64:
      params[0] = INT64_TO_BOOLEAN(v.value_int);
      break;
   default:
      ; /* nothing - GL error was recorded */
d5562 1
d5564 1
a5564 1
_mesa_GetIntegerIndexedv( GLenum pname, GLuint index, GLint *params )
d5566 12
a5577 21
   union value v;
   enum value_type type =
      find_value_indexed("glGetIntegerIndexedv", pname, index, &v);

   switch (type) {
   case TYPE_INT:
      params[0] = v.value_int;
      break;
   case TYPE_INT_4:
      params[0] = v.value_int_4[0];
      params[1] = v.value_int_4[1];
      params[2] = v.value_int_4[2];
      params[3] = v.value_int_4[3];
      break;
   case TYPE_INT64:
      params[0] = INT64_TO_INT(v.value_int);
      break;
   default:
      ; /* nothing - GL error was recorded */
   }
}
d5579 4
a5582 24
#if FEATURE_ARB_sync
void GLAPIENTRY
_mesa_GetInteger64Indexedv( GLenum pname, GLuint index, GLint64 *params )
{
   union value v;
   enum value_type type =
      find_value_indexed("glGetIntegerIndexedv", pname, index, &v);      

   switch (type) {
   case TYPE_INT:
      params[0] = v.value_int;
      break;
   case TYPE_INT_4:
      params[0] = v.value_int_4[0];
      params[1] = v.value_int_4[1];
      params[2] = v.value_int_4[2];
      params[3] = v.value_int_4[3];
      break;
   case TYPE_INT64:
      params[0] = v.value_int;
      break;
   default:
      ; /* nothing - GL error was recorded */
   }
a5583 1
#endif /* FEATURE_ARB_sync */
a5584 85
#if FEATURE_ES1
void GLAPIENTRY
_mesa_GetFixedv(GLenum pname, GLfixed *params)
{
   const struct value_desc *d;
   union value v;
   GLmatrix *m;
   int shift, i;
   void *p;

   d = find_value("glGetDoublev", pname, &p, &v);
   switch (d->type) {
   case TYPE_INVALID:
      break;
   case TYPE_CONST:
      params[0] = INT_TO_FIXED(d->offset);
      break;

   case TYPE_FLOAT_4:
   case TYPE_FLOATN_4:
      params[3] = FLOAT_TO_FIXED(((GLfloat *) p)[3]);
   case TYPE_FLOAT_3:
   case TYPE_FLOATN_3:
      params[2] = FLOAT_TO_FIXED(((GLfloat *) p)[2]);
   case TYPE_FLOAT_2:
   case TYPE_FLOATN_2:
      params[1] = FLOAT_TO_FIXED(((GLfloat *) p)[1]);
   case TYPE_FLOAT:
   case TYPE_FLOATN:
      params[0] = FLOAT_TO_FIXED(((GLfloat *) p)[0]);
      break;

   case TYPE_DOUBLEN:
      params[0] = FLOAT_TO_FIXED(((GLdouble *) p)[0]);
      break;

   case TYPE_INT_4:
      params[3] = INT_TO_FIXED(((GLint *) p)[3]);
   case TYPE_INT_3:
      params[2] = INT_TO_FIXED(((GLint *) p)[2]);
   case TYPE_INT_2:
   case TYPE_ENUM_2:
      params[1] = INT_TO_FIXED(((GLint *) p)[1]);
   case TYPE_INT:
   case TYPE_ENUM:
      params[0] = INT_TO_FIXED(((GLint *) p)[0]);
      break;

   case TYPE_INT_N:
      for (i = 0; i < v.value_int_n.n; i++)
	 params[i] = INT_TO_FIXED(v.value_int_n.ints[i]);
      break;

   case TYPE_INT64:
      params[0] = ((GLint64 *) p)[0];
      break;

   case TYPE_BOOLEAN:
      params[0] = BOOLEAN_TO_FIXED(((GLboolean*) p)[0]);
      break;		

   case TYPE_MATRIX:
      m = *(GLmatrix **) p;
      for (i = 0; i < 16; i++)
	 params[i] = FLOAT_TO_FIXED(m->m[i]);
      break;

   case TYPE_MATRIX_T:
      m = *(GLmatrix **) p;
      for (i = 0; i < 16; i++)
	 params[i] = FLOAT_TO_FIXED(m->m[transpose[i]]);
      break;

   case TYPE_BIT_0:
   case TYPE_BIT_1:
   case TYPE_BIT_2:
   case TYPE_BIT_3:
   case TYPE_BIT_4:
   case TYPE_BIT_5:
      shift = d->type - TYPE_BIT_0;
      params[0] = BOOLEAN_TO_FIXED((*(GLbitfield *) p >> shift) & 1);
      break;
   }
}
#endif
@


1.1.1.5
log
@Import Mesa 9.2.0
@
text
@d18 3
a20 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
a26 1
#include "blend.h"
a35 2
#include "samplerobj.h"
#include "stencil.h"
d63 2
d88 1
a103 2
   TYPE_BIT_6,
   TYPE_BIT_7,
d131 1
a131 4
   EXTRA_API_GL,
   EXTRA_API_GL_CORE,
   EXTRA_API_ES2,
   EXTRA_API_ES3,
a132 1
   EXTRA_NEW_FRAG_CLAMP,
a134 1
   EXTRA_VALID_CLIP_DISTANCE,
a135 2
   EXTRA_GLSL_130,
   EXTRA_EXT_UBO_GS4,
a170 1
#undef CONST /* already defined through windows.h */
a189 2
#define CONTEXT_BIT6(field) CONTEXT_FIELD(field, TYPE_BIT_6)
#define CONTEXT_BIT7(field) CONTEXT_FIELD(field, TYPE_BIT_7)
d218 1
a218 7
 * structs below.
 *
 * Each EXTRA_ will be executed.  For EXTRA_* enums of extensions and API
 * versions, listing multiple ones in an array means an error will be thrown
 * only if none of them are available.  If you need to check for "AND"
 * behavior, you would need to make a custom EXTRA_ enum.
 */
a224 5
static const int extra_new_frag_clamp[] = {
   EXTRA_NEW_FRAG_CLAMP,
   EXTRA_END
};

a234 5
static const int extra_valid_clip_distance[] = {
   EXTRA_VALID_CLIP_DISTANCE,
   EXTRA_END
};

d246 1
a246 7
static const int extra_EXT_texture_integer[] = {
   EXT(EXT_texture_integer),
   EXTRA_END
};

static const int extra_EXT_texture_integer_and_new_buffers[] = {
   EXT(EXT_texture_integer),
d248 1
d252 3
a254 3
static const int extra_GLSL_130_es3[] = {
   EXTRA_GLSL_130,
   EXTRA_API_ES3,
d258 3
a260 4
static const int extra_texture_buffer_object[] = {
   EXTRA_API_GL_CORE,
   EXTRA_VERSION_31,
   EXT(ARB_texture_buffer_object),
d264 2
a265 3
static const int extra_ARB_transform_feedback2_api_es3[] = {
   EXT(ARB_transform_feedback2),
   EXTRA_API_ES3,
d269 2
a270 2
static const int extra_ARB_uniform_buffer_object_and_geometry_shader[] = {
   EXTRA_EXT_UBO_GS4,
a273 23
static const int extra_ARB_ES2_compatibility_api_es2[] = {
   EXT(ARB_ES2_compatibility),
   EXTRA_API_ES2,
   EXTRA_END
};

static const int extra_ARB_ES3_compatibility_api_es3[] = {
   EXT(ARB_ES3_compatibility),
   EXTRA_API_ES3,
   EXTRA_END
};

static const int extra_EXT_framebuffer_sRGB_and_new_buffers[] = {
   EXT(EXT_framebuffer_sRGB),
   EXTRA_NEW_BUFFERS,
   EXTRA_END
};

static const int extra_MESA_texture_array_es3[] = {
   EXT(MESA_texture_array),
   EXTRA_API_ES3,
   EXTRA_END
};
d275 2
d279 4
a282 1
EXTRA_EXT(NV_fog_distance);
d284 1
d286 3
d291 2
d297 1
d302 2
d305 1
d309 1
a309 1
EXTRA_EXT(ARB_transform_feedback3);
d313 2
d316 1
d318 1
a318 10
EXTRA_EXT(ARB_color_buffer_float);
EXTRA_EXT(EXT_framebuffer_sRGB);
EXTRA_EXT(OES_EGL_image_external);
EXTRA_EXT(ARB_blend_func_extended);
EXTRA_EXT(ARB_uniform_buffer_object);
EXTRA_EXT(ARB_timer_query);
EXTRA_EXT(ARB_map_buffer_alignment);
EXTRA_EXT(ARB_texture_cube_map_array);
EXTRA_EXT(ARB_texture_buffer_range);
EXTRA_EXT(ARB_texture_multisample);
d321 13
a333 3
extra_ARB_color_buffer_float_or_glcore[] = {
   EXT(ARB_color_buffer_float),
   EXTRA_API_GL_CORE,
a346 12
static const int extra_gl30_es3[] = {
    EXTRA_VERSION_30,
    EXTRA_API_ES3,
    EXTRA_END,
};

static const int extra_gl32_es3[] = {
    EXTRA_VERSION_32,
    EXTRA_API_ES3,
    EXTRA_END,
};

d348 1
a348 1
extra_ARB_vertex_program_api_es2[] = {
d350 1
a350 10
   EXTRA_API_ES2,
   EXTRA_END
};

/* The ReadBuffer get token is valid under either full GL or under
 * GLES2 if the NV_read_buffer extension is available. */
static const int
extra_NV_read_buffer_api_gl[] = {
   EXTRA_API_ES2,
   EXTRA_API_GL,
d354 3
a356 6
static const int extra_core_ARB_color_buffer_float_and_new_buffers[] = {
   EXTRA_API_GL_CORE,
   EXT(ARB_color_buffer_float),
   EXTRA_NEW_BUFFERS,
   EXTRA_END
};
d362 252
a613 4
 * remaining combinations. To look up the enums valid in a given API
 * we will use a hash table specific to that API. These tables are in
 * turn generated at build time and included through get_hash.h.
 */
d615 640
a1254 1
#include "get_hash.h"
d1269 3
d1274 1
a1274 1
print_table_stats(int api)
a1277 7
   const char *api_names[] = {
      [API_OPENGL_COMPAT] = "GL",
      [API_OPENGL_CORE] = "GL_CORE",
      [API_OPENGLES] = "GLES",
      [API_OPENGLES2] = "GLES2",
   };
   const char *api_name;
a1278 1
   api_name = api < Elements(api_names) ? api_names[api] : "N/A";
d1280 1
a1280 1
   mask = Elements(table(api)) - 1;
d1283 3
a1285 3
   for (i = 0; i < Elements(table(api)); i++) {
      if (!table(api)[i])
         continue;
d1287 1
a1287 1
      d = &values[table(api)[i]];
d1291 4
a1294 4
         if (values[table(api)[hash & mask]].pname == d->pname)
            break;
         hash += prime_step;
         j++;
d1298 1
a1298 1
         collisions[j]++;
d1300 1
a1300 1
         collisions[10]++;
d1303 1
a1303 2
   printf("number of enums for %s: %d (total %ld)\n",
         api_name, count, Elements(values));
d1306 2
a1307 2
         printf("  %d enums with %d %scollisions\n",
               collisions[i], i, i == 10 ? "or more " : "");
d1321 25
a1374 7
   case GL_MAJOR_VERSION:
      v->value_int = ctx->Version / 10;
      break;
   case GL_MINOR_VERSION:
      v->value_int = ctx->Version % 10;
      break;

a1381 1
   case GL_TEXTURE_EXTERNAL_OES:
d1442 1
a1442 1
      array = &ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_TEX(ctx->Array.ActiveTexture)];
d1509 1
a1509 4
      v->value_int = _mesa_get_stencil_ref(ctx, ctx->Stencil.ActiveFace);
      break;
   case GL_STENCIL_BACK_REF:
      v->value_int = _mesa_get_stencil_ref(ctx, 1);
d1538 1
a1538 1
      v->value_int = _mesa_get_compressed_formats(ctx, NULL);
d1542 1
a1542 1
	 _mesa_get_compressed_formats(ctx, v->value_int_n.ints);
a1546 1
   case GL_MAX_FRAGMENT_INPUT_COMPONENTS:
a1558 4
   case GL_TEXTURE_BINDING_EXTERNAL_OES:
   case GL_TEXTURE_BINDING_CUBE_MAP_ARRAY:
   case GL_TEXTURE_BINDING_2D_MULTISAMPLE:
   case GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY:
d1581 1
a1581 1
	 ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_TEX(ctx->Array.ActiveTexture)].BufferObj->Name;
d1584 1
a1584 1
      v->value_int = ctx->Array.ArrayObj->ElementArrayBufferObj->Name;
d1595 8
d1633 1
a1633 1
      v->value_int = ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_POINT_SIZE].BufferObj->Name;
a1635 27
   case GL_FOG_COLOR:
      if (_mesa_get_clamp_fragment_color(ctx))
         COPY_4FV(v->value_float_4, ctx->Fog.Color);
      else
         COPY_4FV(v->value_float_4, ctx->Fog.ColorUnclamped);
      break;
   case GL_COLOR_CLEAR_VALUE:
      if (_mesa_get_clamp_fragment_color(ctx)) {
         v->value_float_4[0] = CLAMP(ctx->Color.ClearColor.f[0], 0.0F, 1.0F);
         v->value_float_4[1] = CLAMP(ctx->Color.ClearColor.f[1], 0.0F, 1.0F);
         v->value_float_4[2] = CLAMP(ctx->Color.ClearColor.f[2], 0.0F, 1.0F);
         v->value_float_4[3] = CLAMP(ctx->Color.ClearColor.f[3], 0.0F, 1.0F);
      } else
         COPY_4FV(v->value_float_4, ctx->Color.ClearColor.f);
      break;
   case GL_BLEND_COLOR_EXT:
      if (_mesa_get_clamp_fragment_color(ctx))
         COPY_4FV(v->value_float_4, ctx->Color.BlendColor);
      else
         COPY_4FV(v->value_float_4, ctx->Color.BlendColorUnclamped);
      break;
   case GL_ALPHA_TEST_REF:
      if (_mesa_get_clamp_fragment_color(ctx))
         v->value_float = ctx->Color.AlphaRef;
      else
         v->value_float = ctx->Color.AlphaRefUnclamped;
      break;
d1643 1
a1643 54

   /* GL_ARB_texture_buffer_object */
   case GL_TEXTURE_BUFFER_ARB:
      v->value_int = ctx->Texture.BufferObject->Name;
      break;
   case GL_TEXTURE_BINDING_BUFFER_ARB:
      unit = ctx->Texture.CurrentUnit;
      v->value_int =
         ctx->Texture.Unit[unit].CurrentTex[TEXTURE_BUFFER_INDEX]->Name;
      break;
   case GL_TEXTURE_BUFFER_DATA_STORE_BINDING_ARB:
      {
         struct gl_buffer_object *buf =
            ctx->Texture.Unit[ctx->Texture.CurrentUnit]
            .CurrentTex[TEXTURE_BUFFER_INDEX]->BufferObject;
         v->value_int = buf ? buf->Name : 0;
      }
      break;
   case GL_TEXTURE_BUFFER_FORMAT_ARB:
      v->value_int = ctx->Texture.Unit[ctx->Texture.CurrentUnit]
         .CurrentTex[TEXTURE_BUFFER_INDEX]->BufferObjectFormat;
      break;

   /* GL_ARB_sampler_objects */
   case GL_SAMPLER_BINDING:
      {
         struct gl_sampler_object *samp =
            ctx->Texture.Unit[ctx->Texture.CurrentUnit].Sampler;

         /*
          * The sampler object may have been deleted on another context,
          * so we try to lookup the sampler object before returning its Name.
          */
         if (samp && _mesa_lookup_samplerobj(ctx, samp->Name)) {
            v->value_int = samp->Name;
         } else {
            v->value_int = 0;
         }
      }
      break;
   /* GL_ARB_uniform_buffer_object */
   case GL_UNIFORM_BUFFER_BINDING:
      v->value_int = ctx->UniformBuffer->Name;
      break;
   /* GL_ARB_timer_query */
   case GL_TIMESTAMP:
      if (ctx->Driver.GetTimestamp) {
         v->value_int64 = ctx->Driver.GetTimestamp(ctx);
      }
      else {
         _mesa_problem(ctx, "driver doesn't implement GetTimestamp");
      }
      break;
   }
d1658 1
a1658 1
 * \return GL_FALSE if all of the constraints were not satisfied,
d1664 2
a1665 3
   const GLuint version = ctx->Version;
   GLboolean api_check = GL_FALSE;
   GLboolean api_found = GL_FALSE;
d1668 3
a1670 1
   for (e = d->extra; *e != EXTRA_END; e++) {
d1673 4
a1676 3
         api_check = GL_TRUE;
         if (version >= 30)
            api_found = GL_TRUE;
d1679 4
a1682 3
         api_check = GL_TRUE;
         if (version >= 31)
            api_found = GL_TRUE;
d1685 4
a1688 3
         api_check = GL_TRUE;
         if (version >= 32)
            api_found = GL_TRUE;
d1690 5
a1694 23
      case EXTRA_NEW_FRAG_CLAMP:
         if (ctx->NewState & (_NEW_BUFFERS | _NEW_FRAG_CLAMP))
            _mesa_update_state(ctx);
         break;
      case EXTRA_API_ES2:
         api_check = GL_TRUE;
         if (ctx->API == API_OPENGLES2)
            api_found = GL_TRUE;
	 break;
      case EXTRA_API_ES3:
         api_check = GL_TRUE;
         if (_mesa_is_gles3(ctx))
            api_found = GL_TRUE;
	 break;
      case EXTRA_API_GL:
         api_check = GL_TRUE;
         if (_mesa_is_desktop_gl(ctx))
            api_found = GL_TRUE;
	 break;
      case EXTRA_API_GL_CORE:
         api_check = GL_TRUE;
         if (ctx->API == API_OPENGL_CORE)
            api_found = GL_TRUE;
a1716 17
      case EXTRA_VALID_CLIP_DISTANCE:
	 if (d->pname - GL_CLIP_DISTANCE0 >= ctx->Const.MaxClipPlanes) {
	    _mesa_error(ctx, GL_INVALID_ENUM, "%s(clip distance %u)",
			func, d->pname - GL_CLIP_DISTANCE0);
	    return GL_FALSE;
	 }
	 break;
      case EXTRA_GLSL_130:
         api_check = GL_TRUE;
         if (ctx->Const.GLSLVersion >= 130)
            api_found = GL_TRUE;
	 break;
      case EXTRA_EXT_UBO_GS4:
         api_check = GL_TRUE;
         api_found = (ctx->Extensions.ARB_uniform_buffer_object &&
                      ctx->Extensions.ARB_geometry_shader4);
         break;
d1720 1
a1720 1
	 api_check = GL_TRUE;
d1722 1
a1722 1
	    api_found = GL_TRUE;
a1724 1
   }
d1726 1
a1726 1
   if (api_check && !api_found) {
a1766 1
   int api;
d1768 1
a1768 11
   api = ctx->API;
   /* We index into the table_set[] list of per-API hash tables using the API's
    * value in the gl_api enum. Since GLES 3 doesn't have an API_OPENGL* enum
    * value since it's compatible with GLES2 its entry in table_set[] is at the
    * end.
    */
   STATIC_ASSERT(Elements(table_set) == API_OPENGL_LAST + 2);
   if (_mesa_is_gles3(ctx)) {
      api = API_OPENGL_LAST + 1;
   }
   mask = Elements(table(api)) - 1;
d1771 1
a1771 1
      int idx = table(api)[hash & mask];
d1774 5
a1778 6
       * pointing to the first entry of values[] which doesn't hold
       * any valid enum. */
      if (unlikely(idx == 0)) {
         _mesa_error(ctx, GL_INVALID_ENUM, "%s(pname=%s)", func,
               _mesa_lookup_enum_by_nr(pname));
         return &error_value;
a1780 1
      d = &values[idx];
d1782 1
a1782 1
         break;
a1901 2
   case TYPE_BIT_6:
   case TYPE_BIT_7:
d1940 1
a1940 1
      params[0] = (GLfloat) (((GLdouble *) p)[0]);
d1961 1
a1961 1
      params[0] = (GLfloat) (((GLint64 *) p)[0]);
a1985 2
   case TYPE_BIT_6:
   case TYPE_BIT_7:
a2075 2
   case TYPE_BIT_6:
   case TYPE_BIT_7:
d2082 1
a2166 2
   case TYPE_BIT_6:
   case TYPE_BIT_7:
d2172 1
d2227 1
a2227 1
      params[0] = (GLdouble) (((GLint64 *) p)[0]);
a2251 2
   case TYPE_BIT_6:
   case TYPE_BIT_7:
d2259 1
a2259 1
find_value_indexed(const char *func, GLenum pname, GLuint index, union value *v)
a2272 47
   case GL_BLEND_SRC:
      /* fall-through */
   case GL_BLEND_SRC_RGB:
      if (index >= ctx->Const.MaxDrawBuffers)
	 goto invalid_value;
      if (!ctx->Extensions.ARB_draw_buffers_blend)
	 goto invalid_enum;
      v->value_int = ctx->Color.Blend[index].SrcRGB;
      return TYPE_INT;
   case GL_BLEND_SRC_ALPHA:
      if (index >= ctx->Const.MaxDrawBuffers)
	 goto invalid_value;
      if (!ctx->Extensions.ARB_draw_buffers_blend)
	 goto invalid_enum;
      v->value_int = ctx->Color.Blend[index].SrcA;
      return TYPE_INT;
   case GL_BLEND_DST:
      /* fall-through */
   case GL_BLEND_DST_RGB:
      if (index >= ctx->Const.MaxDrawBuffers)
	 goto invalid_value;
      if (!ctx->Extensions.ARB_draw_buffers_blend)
	 goto invalid_enum;
      v->value_int = ctx->Color.Blend[index].DstRGB;
      return TYPE_INT;
   case GL_BLEND_DST_ALPHA:
      if (index >= ctx->Const.MaxDrawBuffers)
	 goto invalid_value;
      if (!ctx->Extensions.ARB_draw_buffers_blend)
	 goto invalid_enum;
      v->value_int = ctx->Color.Blend[index].DstA;
      return TYPE_INT;
   case GL_BLEND_EQUATION_RGB:
      if (index >= ctx->Const.MaxDrawBuffers)
	 goto invalid_value;
      if (!ctx->Extensions.ARB_draw_buffers_blend)
	 goto invalid_enum;
      v->value_int = ctx->Color.Blend[index].EquationRGB;
      return TYPE_INT;
   case GL_BLEND_EQUATION_ALPHA:
      if (index >= ctx->Const.MaxDrawBuffers)
	 goto invalid_value;
      if (!ctx->Extensions.ARB_draw_buffers_blend)
	 goto invalid_enum;
      v->value_int = ctx->Color.Blend[index].EquationA;
      return TYPE_INT;

d2285 1
a2285 1
      if (index >= ctx->Const.MaxTransformFeedbackBuffers)
d2293 1
a2293 1
      if (index >= ctx->Const.MaxTransformFeedbackBuffers)
d2297 1
a2297 2
      v->value_int64
         = ctx->TransformFeedback.CurrentObject->RequestedSize[index];
d2301 1
a2301 1
      if (index >= ctx->Const.MaxTransformFeedbackBuffers)
d2305 1
a2305 34
      v->value_int = ctx->TransformFeedback.CurrentObject->BufferNames[index];
      return TYPE_INT;

   case GL_UNIFORM_BUFFER_BINDING:
      if (index >= ctx->Const.MaxUniformBufferBindings)
	 goto invalid_value;
      if (!ctx->Extensions.ARB_uniform_buffer_object)
	 goto invalid_enum;
      v->value_int = ctx->UniformBufferBindings[index].BufferObject->Name;
      return TYPE_INT;

   case GL_UNIFORM_BUFFER_START:
      if (index >= ctx->Const.MaxUniformBufferBindings)
	 goto invalid_value;
      if (!ctx->Extensions.ARB_uniform_buffer_object)
	 goto invalid_enum;
      v->value_int = ctx->UniformBufferBindings[index].Offset;
      return TYPE_INT;

   case GL_UNIFORM_BUFFER_SIZE:
      if (index >= ctx->Const.MaxUniformBufferBindings)
	 goto invalid_value;
      if (!ctx->Extensions.ARB_uniform_buffer_object)
	 goto invalid_enum;
      v->value_int = ctx->UniformBufferBindings[index].Size;
      return TYPE_INT;

   /* ARB_texture_multisample / GL3.2 */
   case GL_SAMPLE_MASK_VALUE:
      if (index != 0)
         goto invalid_value;
      if (!ctx->Extensions.ARB_texture_multisample)
         goto invalid_enum;
      v->value_int = ctx->Multisample.SampleMaskValue;
d2320 1
a2320 1
_mesa_GetBooleani_v( GLenum pname, GLuint index, GLboolean *params )
d2324 1
a2324 1
      find_value_indexed("glGetBooleani_v", pname, index, &v);
d2345 1
a2345 1
_mesa_GetIntegeri_v( GLenum pname, GLuint index, GLint *params )
d2349 1
a2349 1
      find_value_indexed("glGetIntegeri_v", pname, index, &v);
d2369 1
d2371 1
a2371 1
_mesa_GetInteger64i_v( GLenum pname, GLuint index, GLint64 *params )
d2375 1
a2375 1
      find_value_indexed("glGetInteger64i_v", pname, index, &v);
d2394 1
d2396 1
a2474 2
   case TYPE_BIT_6:
   case TYPE_BIT_7:
d2480 1
@


1.1.1.6
log
@Import Mesa 9.2.1
@
text
@a716 1
   case GL_MAX_VERTEX_OUTPUT_COMPONENTS:
@


1.1.1.7
log
@Import Mesa 10.2.3
@
text
@a30 1
#include "errors.h"
a115 1
   TYPE_DOUBLEN_2,
a133 1
   EXTRA_VERSION_40,
a145 2
   EXTRA_EXT_ATOMICS_GS4,
   EXTRA_EXT_SHADER_IMAGE_GS4,
a161 1
   GLdouble value_double_2[2];
d180 1
a180 1
   LOC_ARRAY, type, offsetof(struct gl_vertex_array_object, field)
d328 2
a329 8
static const int extra_EXT_packed_float[] = {
   EXT(EXT_packed_float),
   EXTRA_NEW_BUFFERS,
   EXTRA_END
};

static const int extra_EXT_texture_array_es3[] = {
   EXT(EXT_texture_array),
a333 10
static const int extra_ARB_shader_atomic_counters_and_geometry_shader[] = {
   EXTRA_EXT_ATOMICS_GS4,
   EXTRA_END
};

static const int extra_ARB_shader_image_load_store_and_geometry_shader[] = {
   EXTRA_EXT_SHADER_IMAGE_GS4,
   EXTRA_END
};

d335 1
a335 1
EXTRA_EXT(EXT_texture_array);
d344 1
d365 1
a368 9
EXTRA_EXT(ARB_texture_gather);
EXTRA_EXT(ARB_shader_atomic_counters);
EXTRA_EXT(ARB_draw_indirect);
EXTRA_EXT(ARB_shader_image_load_store);
EXTRA_EXT(ARB_viewport_array);
EXTRA_EXT(ARB_compute_shader);
EXTRA_EXT(ARB_gpu_shader5);
EXTRA_EXT2(ARB_transform_feedback3, ARB_gpu_shader5);
EXTRA_EXT(INTEL_performance_query);
a385 1
static const int extra_version_40[] = { EXTRA_VERSION_40, EXTRA_END };
a398 12
static const int extra_gl32_ARB_geometry_shader4[] = {
    EXTRA_VERSION_32,
    EXT(ARB_geometry_shader4),
    EXTRA_END
};

static const int extra_gl40_ARB_sample_shading[] = {
   EXTRA_VERSION_40,
   EXT(ARB_sample_shading),
   EXTRA_END
};

d505 1
a505 3
   print_table_stats(ctx->API);
#else
   (void) ctx;
d529 1
a529 1
   struct gl_vertex_attrib_array *array;
d543 2
d608 1
a608 1
      array = &ctx->Array.VAO->VertexAttrib[VERT_ATTRIB_TEX(ctx->Array.ActiveTexture)];
d632 4
a635 8
      v->value_int_4[0] = ctx->Scissor.ScissorArray[0].X;
      v->value_int_4[1] = ctx->Scissor.ScissorArray[0].Y;
      v->value_int_4[2] = ctx->Scissor.ScissorArray[0].Width;
      v->value_int_4[3] = ctx->Scissor.ScissorArray[0].Height;
      break;

   case GL_SCISSOR_TEST:
      v->value_bool = ctx->Scissor.EnableFlags & 1;
d652 4
a655 9
      v->value_float_4[0] = ctx->ViewportArray[0].X;
      v->value_float_4[1] = ctx->ViewportArray[0].Y;
      v->value_float_4[2] = ctx->ViewportArray[0].Width;
      v->value_float_4[3] = ctx->ViewportArray[0].Height;
      break;

   case GL_DEPTH_RANGE:
      v->value_double_2[0] = ctx->ViewportArray[0].Near;
      v->value_double_2[1] = ctx->ViewportArray[0].Far;
d712 1
a712 1
      ASSERT(v->value_int_n.n <= (int) ARRAY_SIZE(v->value_int_n.ints));
d716 2
a738 39
   /* GL_EXT_packed_float */
   case GL_RGBA_SIGNED_COMPONENTS_EXT:
      {
         /* Note: we only check the 0th color attachment. */
         const struct gl_renderbuffer *rb =
            ctx->DrawBuffer->_ColorDrawBuffers[0];
         if (rb && _mesa_is_format_signed(rb->Format)) {
            /* Issue 17 of GL_EXT_packed_float:  If a component (such as
             * alpha) has zero bits, the component should not be considered
             * signed and so the bit for the respective component should be
             * zeroed.
             */
            GLint r_bits =
               _mesa_get_format_bits(rb->Format, GL_RED_BITS);
            GLint g_bits =
               _mesa_get_format_bits(rb->Format, GL_GREEN_BITS);
            GLint b_bits =
               _mesa_get_format_bits(rb->Format, GL_BLUE_BITS);
            GLint a_bits =
               _mesa_get_format_bits(rb->Format, GL_ALPHA_BITS);
            GLint l_bits =
               _mesa_get_format_bits(rb->Format, GL_TEXTURE_LUMINANCE_SIZE);
            GLint i_bits =
               _mesa_get_format_bits(rb->Format, GL_TEXTURE_INTENSITY_SIZE);

            v->value_int_4[0] = r_bits + l_bits + i_bits > 0;
            v->value_int_4[1] = g_bits + l_bits + i_bits > 0;
            v->value_int_4[2] = b_bits + l_bits + i_bits > 0;
            v->value_int_4[3] = a_bits + i_bits > 0;
         }
         else {
            v->value_int_4[0] =
            v->value_int_4[1] =
            v->value_int_4[2] =
            v->value_int_4[3] = 0;
         }
      }
      break;

d748 1
a748 1
	 ((char *) ctx->Array.VAO + d->offset);
d756 1
a756 1
	 ctx->Array.VAO->VertexBinding[VERT_ATTRIB_TEX(ctx->Array.ActiveTexture)].BufferObj->Name;
d759 1
a759 11
      v->value_int = ctx->Array.VAO->IndexBufferObj->Name;
      break;

   /* ARB_vertex_array_bgra */
   case GL_COLOR_ARRAY_SIZE:
      array = &ctx->Array.VAO->VertexAttrib[VERT_ATTRIB_COLOR0];
      v->value_int = array->Format == GL_BGRA ? GL_BGRA : array->Size;
      break;
   case GL_SECONDARY_COLOR_ARRAY_SIZE:
      array = &ctx->Array.VAO->VertexAttrib[VERT_ATTRIB_COLOR1];
      v->value_int = array->Format == GL_BGRA ? GL_BGRA : array->Size;
a788 12
      /* The Changelog of the ARB_separate_shader_objects spec says:
       *
       * 24 25 Jul 2011  pbrown  Remove the language erroneously deleting
       *                         CURRENT_PROGRAM.  In the EXT extension, this
       *                         token was aliased to ACTIVE_PROGRAM_EXT, and
       *                         was used to indicate the last program set by
       *                         either ActiveProgramEXT or UseProgram.  In
       *                         the ARB extension, the SSO active programs
       *                         are now program pipeline object state and
       *                         CURRENT_PROGRAM should still be used to query
       *                         the last program set by UseProgram (bug 7822).
       */
d800 1
a800 1
      v->value_int = ctx->Array.VAO->VertexBinding[VERT_ATTRIB_POINT_SIZE].BufferObj->Name;
d831 1
a831 1
      v->value_int = ctx->Const.Program[MESA_SHADER_VERTEX].MaxUniformComponents / 4;
d835 1
a835 1
      v->value_int = ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxUniformComponents / 4;
a889 26
   /* GL_KHR_DEBUG */
   case GL_DEBUG_LOGGED_MESSAGES:
   case GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH:
   case GL_DEBUG_GROUP_STACK_DEPTH:
      v->value_int = _mesa_get_debug_state_int(ctx, d->pname);
      break;
   /* GL_ARB_shader_atomic_counters */
   case GL_ATOMIC_COUNTER_BUFFER_BINDING:
      if (ctx->AtomicBuffer) {
         v->value_int = ctx->AtomicBuffer->Name;
      } else {
         v->value_int = 0;
      }
      break;
   /* GL_ARB_draw_indirect */
   case GL_DRAW_INDIRECT_BUFFER_BINDING:
      v->value_int = ctx->DrawIndirectBuffer->Name;
      break;
   /* GL_ARB_separate_shader_objects */
   case GL_PROGRAM_PIPELINE_BINDING:
      if (ctx->Pipeline.Current) {
         v->value_int = ctx->Pipeline.Current->Name;
      } else {
         v->value_int = 0;
      }
      break;
d993 1
a993 11
                      _mesa_has_geometry_shaders(ctx));
         break;
      case EXTRA_EXT_ATOMICS_GS4:
         api_check = GL_TRUE;
         api_found = (ctx->Extensions.ARB_shader_atomic_counters &&
                      _mesa_has_geometry_shaders(ctx));
         break;
      case EXTRA_EXT_SHADER_IMAGE_GS4:
         api_check = GL_TRUE;
         api_found = (ctx->Extensions.ARB_shader_image_load_store &&
                      _mesa_has_geometry_shaders(ctx));
d1090 1
a1090 1
      *p = ((char *) ctx->Array.VAO + d->offset);
a1146 2
   case TYPE_DOUBLEN_2:
      params[1] = FLOAT_TO_BOOLEAN(((GLdouble *) p)[1]);
a1232 2
   case TYPE_DOUBLEN_2:
      params[1] = (GLfloat) (((GLdouble *) p)[1]);
a1324 2
   case TYPE_DOUBLEN_2:
      params[1] = FLOAT_TO_INT(((GLdouble *) p)[1]);
a1416 2
   case TYPE_DOUBLEN_2:
      params[1] = FLOAT_TO_INT64(((GLdouble *) p)[1]);
a1502 2
   case TYPE_DOUBLEN_2:
      params[1] = ((GLdouble *) p)[1];
a1630 25
   case GL_SCISSOR_BOX:
      if (index >= ctx->Const.MaxViewports)
         goto invalid_value;
      v->value_int_4[0] = ctx->Scissor.ScissorArray[index].X;
      v->value_int_4[1] = ctx->Scissor.ScissorArray[index].Y;
      v->value_int_4[2] = ctx->Scissor.ScissorArray[index].Width;
      v->value_int_4[3] = ctx->Scissor.ScissorArray[index].Height;
      return TYPE_INT_4;

   case GL_VIEWPORT:
      if (index >= ctx->Const.MaxViewports)
         goto invalid_value;
      v->value_float_4[0] = ctx->ViewportArray[index].X;
      v->value_float_4[1] = ctx->ViewportArray[index].Y;
      v->value_float_4[2] = ctx->ViewportArray[index].Width;
      v->value_float_4[3] = ctx->ViewportArray[index].Height;
      return TYPE_FLOAT_4;

   case GL_DEPTH_RANGE:
      if (index >= ctx->Const.MaxViewports)
         goto invalid_value;
      v->value_double_2[0] = ctx->ViewportArray[index].Near;
      v->value_double_2[1] = ctx->ViewportArray[index].Far;
      return TYPE_DOUBLEN_2;

a1687 122

   case GL_ATOMIC_COUNTER_BUFFER_BINDING:
      if (!ctx->Extensions.ARB_shader_atomic_counters)
         goto invalid_enum;
      if (index >= ctx->Const.MaxAtomicBufferBindings)
         goto invalid_value;
      v->value_int = ctx->AtomicBufferBindings[index].BufferObject->Name;
      return TYPE_INT;

   case GL_ATOMIC_COUNTER_BUFFER_START:
      if (!ctx->Extensions.ARB_shader_atomic_counters)
         goto invalid_enum;
      if (index >= ctx->Const.MaxAtomicBufferBindings)
         goto invalid_value;
      v->value_int64 = ctx->AtomicBufferBindings[index].Offset;
      return TYPE_INT64;

   case GL_ATOMIC_COUNTER_BUFFER_SIZE:
      if (!ctx->Extensions.ARB_shader_atomic_counters)
         goto invalid_enum;
      if (index >= ctx->Const.MaxAtomicBufferBindings)
         goto invalid_value;
      v->value_int64 = ctx->AtomicBufferBindings[index].Size;
      return TYPE_INT64;

   case GL_VERTEX_BINDING_DIVISOR:
      if (!_mesa_is_desktop_gl(ctx) || !ctx->Extensions.ARB_instanced_arrays)
          goto invalid_enum;
      if (index >= ctx->Const.Program[MESA_SHADER_VERTEX].MaxAttribs)
          goto invalid_value;
      v->value_int = ctx->Array.VAO->VertexBinding[VERT_ATTRIB_GENERIC(index)].InstanceDivisor;
      return TYPE_INT;

   case GL_VERTEX_BINDING_OFFSET:
      if (!_mesa_is_desktop_gl(ctx))
          goto invalid_enum;
      if (index >= ctx->Const.Program[MESA_SHADER_VERTEX].MaxAttribs)
          goto invalid_value;
      v->value_int = ctx->Array.VAO->VertexBinding[VERT_ATTRIB_GENERIC(index)].Offset;
      return TYPE_INT;

   case GL_VERTEX_BINDING_STRIDE:
      if (!_mesa_is_desktop_gl(ctx))
          goto invalid_enum;
      if (index >= ctx->Const.Program[MESA_SHADER_VERTEX].MaxAttribs)
          goto invalid_value;
      v->value_int = ctx->Array.VAO->VertexBinding[VERT_ATTRIB_GENERIC(index)].Stride;

   /* ARB_shader_image_load_store */
   case GL_IMAGE_BINDING_NAME: {
      struct gl_texture_object *t;

      if (!ctx->Extensions.ARB_shader_image_load_store)
         goto invalid_enum;
      if (index >= ctx->Const.MaxImageUnits)
         goto invalid_value;

      t = ctx->ImageUnits[index].TexObj;
      v->value_int = (t ? t->Name : 0);
      return TYPE_INT;
   }

   case GL_IMAGE_BINDING_LEVEL:
      if (!ctx->Extensions.ARB_shader_image_load_store)
         goto invalid_enum;
      if (index >= ctx->Const.MaxImageUnits)
         goto invalid_value;

      v->value_int = ctx->ImageUnits[index].Level;
      return TYPE_INT;

   case GL_IMAGE_BINDING_LAYERED:
      if (!ctx->Extensions.ARB_shader_image_load_store)
         goto invalid_enum;
      if (index >= ctx->Const.MaxImageUnits)
         goto invalid_value;

      v->value_int = ctx->ImageUnits[index].Layered;
      return TYPE_INT;

   case GL_IMAGE_BINDING_LAYER:
      if (!ctx->Extensions.ARB_shader_image_load_store)
         goto invalid_enum;
      if (index >= ctx->Const.MaxImageUnits)
         goto invalid_value;

      v->value_int = ctx->ImageUnits[index].Layer;
      return TYPE_INT;

   case GL_IMAGE_BINDING_ACCESS:
      if (!ctx->Extensions.ARB_shader_image_load_store)
         goto invalid_enum;
      if (index >= ctx->Const.MaxImageUnits)
         goto invalid_value;

      v->value_int = ctx->ImageUnits[index].Access;
      return TYPE_INT;

   case GL_IMAGE_BINDING_FORMAT:
      if (!ctx->Extensions.ARB_shader_image_load_store)
         goto invalid_enum;
      if (index >= ctx->Const.MaxImageUnits)
         goto invalid_value;

      v->value_int = ctx->ImageUnits[index].Format;
      return TYPE_INT;

   case GL_MAX_COMPUTE_WORK_GROUP_COUNT:
      if (!_mesa_is_desktop_gl(ctx) || !ctx->Extensions.ARB_compute_shader)
         goto invalid_enum;
      if (index >= 3)
         goto invalid_value;
      v->value_int = ctx->Const.MaxComputeWorkGroupCount[index];
      return TYPE_INT;

   case GL_MAX_COMPUTE_WORK_GROUP_SIZE:
      if (!_mesa_is_desktop_gl(ctx) || !ctx->Extensions.ARB_compute_shader)
         goto invalid_enum;
      if (index >= 3)
         goto invalid_value;
      v->value_int = ctx->Const.MaxComputeWorkGroupSize[index];
      return TYPE_INT;
d1718 1
a1718 1
      params[0] = INT64_TO_BOOLEAN(v.value_int64);
a1732 20
   case TYPE_FLOAT_4:
   case TYPE_FLOATN_4:
      params[3] = IROUND(v.value_float_4[3]);
   case TYPE_FLOAT_3:
   case TYPE_FLOATN_3:
      params[2] = IROUND(v.value_float_4[2]);
   case TYPE_FLOAT_2:
   case TYPE_FLOATN_2:
      params[1] = IROUND(v.value_float_4[1]);
   case TYPE_FLOAT:
   case TYPE_FLOATN:
      params[0] = IROUND(v.value_float_4[0]);
      break;

   case TYPE_DOUBLEN_2:
      params[1] = IROUND(v.value_double_2[1]);
   case TYPE_DOUBLEN:
      params[0] = IROUND(v.value_double_2[0]);
      break;

d1743 1
a1743 1
      params[0] = INT64_TO_INT(v.value_int64);
d1768 1
a1768 1
      params[0] = v.value_int64;
a1775 144
_mesa_GetFloati_v(GLenum pname, GLuint index, GLfloat *params)
{
   int i;
   GLmatrix *m;
   union value v;
   enum value_type type =
      find_value_indexed("glGetFloati_v", pname, index, &v);

   switch (type) {
   case TYPE_FLOAT_4:
   case TYPE_FLOATN_4:
      params[3] = v.value_float_4[3];
   case TYPE_FLOAT_3:
   case TYPE_FLOATN_3:
      params[2] = v.value_float_4[2];
   case TYPE_FLOAT_2:
   case TYPE_FLOATN_2:
      params[1] = v.value_float_4[1];
   case TYPE_FLOAT:
   case TYPE_FLOATN:
      params[0] = v.value_float_4[0];
      break;

   case TYPE_DOUBLEN_2:
      params[1] = (GLfloat) v.value_double_2[1];
   case TYPE_DOUBLEN:
      params[0] = (GLfloat) v.value_double_2[0];
      break;

   case TYPE_INT_4:
      params[3] = (GLfloat) v.value_int_4[3];
   case TYPE_INT_3:
      params[2] = (GLfloat) v.value_int_4[2];
   case TYPE_INT_2:
   case TYPE_ENUM_2:
      params[1] = (GLfloat) v.value_int_4[1];
   case TYPE_INT:
   case TYPE_ENUM:
      params[0] = (GLfloat) v.value_int_4[0];
      break;

   case TYPE_INT_N:
      for (i = 0; i < v.value_int_n.n; i++)
	 params[i] = INT_TO_FLOAT(v.value_int_n.ints[i]);
      break;

   case TYPE_INT64:
      params[0] = (GLfloat) v.value_int64;
      break;

   case TYPE_BOOLEAN:
      params[0] = BOOLEAN_TO_FLOAT(v.value_bool);
      break;

   case TYPE_MATRIX:
      m = *(GLmatrix **) &v;
      for (i = 0; i < 16; i++)
	 params[i] = m->m[i];
      break;

   case TYPE_MATRIX_T:
      m = *(GLmatrix **) &v;
      for (i = 0; i < 16; i++)
	 params[i] = m->m[transpose[i]];
      break;

   default:
      ;
   }
}

void GLAPIENTRY
_mesa_GetDoublei_v(GLenum pname, GLuint index, GLdouble *params)
{
   int i;
   GLmatrix *m;
   union value v;
   enum value_type type =
      find_value_indexed("glGetDoublei_v", pname, index, &v);

   switch (type) {
   case TYPE_FLOAT_4:
   case TYPE_FLOATN_4:
      params[3] = (GLdouble) v.value_float_4[3];
   case TYPE_FLOAT_3:
   case TYPE_FLOATN_3:
      params[2] = (GLdouble) v.value_float_4[2];
   case TYPE_FLOAT_2:
   case TYPE_FLOATN_2:
      params[1] = (GLdouble) v.value_float_4[1];
   case TYPE_FLOAT:
   case TYPE_FLOATN:
      params[0] = (GLdouble) v.value_float_4[0];
      break;

   case TYPE_DOUBLEN_2:
      params[1] = v.value_double_2[1];
   case TYPE_DOUBLEN:
      params[0] = v.value_double_2[0];
      break;

   case TYPE_INT_4:
      params[3] = (GLdouble) v.value_int_4[3];
   case TYPE_INT_3:
      params[2] = (GLdouble) v.value_int_4[2];
   case TYPE_INT_2:
   case TYPE_ENUM_2:
      params[1] = (GLdouble) v.value_int_4[1];
   case TYPE_INT:
   case TYPE_ENUM:
      params[0] = (GLdouble) v.value_int_4[0];
      break;

   case TYPE_INT_N:
      for (i = 0; i < v.value_int_n.n; i++)
	 params[i] = (GLdouble) INT_TO_FLOAT(v.value_int_n.ints[i]);
      break;

   case TYPE_INT64:
      params[0] = (GLdouble) v.value_int64;
      break;

   case TYPE_BOOLEAN:
      params[0] = (GLdouble) BOOLEAN_TO_FLOAT(v.value_bool);
      break;

   case TYPE_MATRIX:
      m = *(GLmatrix **) &v;
      for (i = 0; i < 16; i++)
	 params[i] = (GLdouble) m->m[i];
      break;

   case TYPE_MATRIX_T:
      m = *(GLmatrix **) &v;
      for (i = 0; i < 16; i++)
	 params[i] = (GLdouble) m->m[transpose[i]];
      break;

   default:
      ;
   }
}

void GLAPIENTRY
a1805 2
   case TYPE_DOUBLEN_2:
      params[1] = FLOAT_TO_FIXED(((GLdouble *) p)[1]);
@


1.1.1.8
log
@Import Mesa 10.4.3
@
text
@d281 5
a397 2
EXTRA_EXT(ARB_explicit_uniform_location);
EXTRA_EXT(ARB_clip_control);
@


1.1.1.9
log
@Import Mesa 10.2.9
@
text
@a280 5
static const int extra_EXT_texture_integer[] = {
   EXT(EXT_texture_integer),
   EXTRA_END
};

d393 2
@


