head	1.14;
access;
symbols
	OPENBSD_5_8:1.13.0.4
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	v10_2_9:1.1.1.9
	v10_4_3:1.1.1.8
	v10_2_7:1.1.1.7
	OPENBSD_5_6:1.10.0.2
	OPENBSD_5_6_BASE:1.10
	v10_2_3:1.1.1.6
	OPENBSD_5_5:1.9.0.2
	OPENBSD_5_5_BASE:1.9
	v9_2_5:1.1.1.5
	v9_2_3:1.1.1.5
	v9_2_2:1.1.1.5
	v9_2_1:1.1.1.5
	v9_2_0:1.1.1.5
	OPENBSD_5_4:1.8.0.4
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.2
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.7.0.4
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.6.0.6
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.4
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.5.0.4
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.2
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.4.0.2
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2015.12.23.05.17.53;	author jsg;	state dead;
branches;
next	1.13;
commitid	TnlogFl9nOv2eaRf;

1.13
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.12;
commitid	4ry2gvZGMXkCUD2n;

1.12
date	2015.01.25.14.41.22;	author jsg;	state Exp;
branches;
next	1.11;
commitid	mcxB0JvoI9gTDYXU;

1.11
date	2014.09.07.15.20.07;	author jsg;	state Exp;
branches;
next	1.10;
commitid	7kimTMT4YlQauAIU;

1.10
date	2014.07.09.21.09.00;	author jsg;	state Exp;
branches;
next	1.9;
commitid	WPD6rgPryPkvXOr9;

1.9
date	2013.09.05.14.06.33;	author jsg;	state Exp;
branches;
next	1.8;

1.8
date	2012.08.17.13.58.19;	author mpi;	state Exp;
branches;
next	1.7;

1.7
date	2011.10.23.13.37.44;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.05.22.20.06.31;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2009.05.17.20.26.42;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2008.11.02.14.58.21;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.08.12.23.16.07;	author oga;	state Exp;
branches;
next	1.2;

1.2
date	2008.05.31.16.36.48;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.50.31;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.50.31;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.56.40;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.31.29;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.47;	author matthieu;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.09.05.13.16.57;	author jsg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.07.09.20.35.06;	author jsg;	state Exp;
branches;
next	1.1.1.7;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.7
date	2014.09.07.15.07.32;	author jsg;	state Exp;
branches;
next	1.1.1.8;
commitid	dm8VnQHhowGHmemJ;

1.1.1.8
date	2015.01.25.14.13.01;	author jsg;	state Exp;
branches;
next	1.1.1.9;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.9
date	2015.02.20.22.50.08;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.14
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2008  Brian Paul   All Rights Reserved.
 * Copyright (c) 2008-2009  VMware, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * Authors:
 *   Brian Paul
 */

/**
 * The GL texture image functions in teximage.c basically just do
 * error checking and data structure allocation.  They in turn call
 * device driver functions which actually copy/convert/store the user's
 * texture image data.
 *
 * However, most device drivers will be able to use the fallback functions
 * in this file.  That is, most drivers will have the following bit of
 * code:
 *   ctx->Driver.TexImage = _mesa_store_teximage;
 *   ctx->Driver.TexSubImage = _mesa_store_texsubimage;
 *   etc...
 *
 * Texture image processing is actually kind of complicated.  We have to do:
 *    Format/type conversions
 *    pixel unpacking
 *    pixel transfer (scale, bais, lookup, etc)
 *
 * These functions can handle most everything, including processing full
 * images and sub-images.
 */


#include "glheader.h"
#include "bufferobj.h"
#include "colormac.h"
#include "format_pack.h"
#include "image.h"
#include "macros.h"
#include "mipmap.h"
#include "mtypes.h"
#include "pack.h"
#include "pbo.h"
#include "imports.h"
#include "texcompress.h"
#include "texcompress_fxt1.h"
#include "texcompress_rgtc.h"
#include "texcompress_s3tc.h"
#include "texcompress_etc.h"
#include "teximage.h"
#include "texstore.h"
#include "enums.h"
#include "glformats.h"
#include "../../gallium/auxiliary/util/u_format_rgb9e5.h"
#include "../../gallium/auxiliary/util/u_format_r11g11b10f.h"


enum {
   ZERO = 4, 
   ONE = 5
};


/**
 * Texture image storage function.
 */
typedef GLboolean (*StoreTexImageFunc)(TEXSTORE_PARAMS);


/**
 * Return GL_TRUE if the given image format is one that be converted
 * to another format by swizzling.
 */
static GLboolean
can_swizzle(GLenum logicalBaseFormat)
{
   switch (logicalBaseFormat) {
   case GL_RGBA:
   case GL_RGB:
   case GL_LUMINANCE_ALPHA:
   case GL_INTENSITY:
   case GL_ALPHA:
   case GL_LUMINANCE:
   case GL_RED:
   case GL_GREEN:
   case GL_BLUE:
   case GL_BGR:
   case GL_BGRA:
   case GL_ABGR_EXT:
   case GL_RG:
      return GL_TRUE;
   default:
      return GL_FALSE;
   }
}



enum {
   IDX_LUMINANCE = 0,
   IDX_ALPHA,
   IDX_INTENSITY,
   IDX_LUMINANCE_ALPHA,
   IDX_RGB,
   IDX_RGBA,
   IDX_RED,
   IDX_GREEN,
   IDX_BLUE,
   IDX_BGR,
   IDX_BGRA,
   IDX_ABGR,
   IDX_RG,
   MAX_IDX
};

#define MAP1(x)       MAP4(x, ZERO, ZERO, ZERO)
#define MAP2(x,y)     MAP4(x, y, ZERO, ZERO)
#define MAP3(x,y,z)   MAP4(x, y, z, ZERO)
#define MAP4(x,y,z,w) { x, y, z, w, ZERO, ONE }


static const struct {
   GLubyte format_idx;
   GLubyte to_rgba[6];
   GLubyte from_rgba[6];
} mappings[MAX_IDX] = 
{
   {
      IDX_LUMINANCE,
      MAP4(0,0,0,ONE),
      MAP1(0)
   },

   {
      IDX_ALPHA,
      MAP4(ZERO, ZERO, ZERO, 0),
      MAP1(3)
   },

   {
      IDX_INTENSITY,
      MAP4(0, 0, 0, 0),
      MAP1(0),
   },

   {
      IDX_LUMINANCE_ALPHA,
      MAP4(0,0,0,1),
      MAP2(0,3)
   },

   {
      IDX_RGB,
      MAP4(0,1,2,ONE),
      MAP3(0,1,2)
   },

   {
      IDX_RGBA,
      MAP4(0,1,2,3),
      MAP4(0,1,2,3),
   },

   {
      IDX_RED,
      MAP4(0, ZERO, ZERO, ONE),
      MAP1(0),
   },

   {
      IDX_GREEN,
      MAP4(ZERO, 0, ZERO, ONE),
      MAP1(1),
   },

   {
      IDX_BLUE,
      MAP4(ZERO, ZERO, 0, ONE),
      MAP1(2),
   },

   {
      IDX_BGR,
      MAP4(2,1,0,ONE),
      MAP3(2,1,0)
   },

   {
      IDX_BGRA,
      MAP4(2,1,0,3),
      MAP4(2,1,0,3)
   },

   {
      IDX_ABGR,
      MAP4(3,2,1,0),
      MAP4(3,2,1,0)
   },

   {
      IDX_RG,
      MAP4(0, 1, ZERO, ONE),
      MAP2(0, 1)
   },
};



/**
 * Convert a GL image format enum to an IDX_* value (see above).
 */
static int
get_map_idx(GLenum value)
{
   switch (value) {
   case GL_LUMINANCE: return IDX_LUMINANCE;
   case GL_ALPHA: return IDX_ALPHA;
   case GL_INTENSITY: return IDX_INTENSITY;
   case GL_LUMINANCE_ALPHA: return IDX_LUMINANCE_ALPHA;
   case GL_RGB: return IDX_RGB;
   case GL_RGBA: return IDX_RGBA;
   case GL_RED: return IDX_RED;
   case GL_GREEN: return IDX_GREEN;
   case GL_BLUE: return IDX_BLUE;
   case GL_BGR: return IDX_BGR;
   case GL_BGRA: return IDX_BGRA;
   case GL_ABGR_EXT: return IDX_ABGR;
   case GL_RG: return IDX_RG;
   default:
      _mesa_problem(NULL, "Unexpected inFormat");
      return 0;
   }
}   


/**
 * When promoting texture formats (see below) we need to compute the
 * mapping of dest components back to source components.
 * This function does that.
 * \param inFormat  the incoming format of the texture
 * \param outFormat  the final texture format
 * \return map[6]  a full 6-component map
 */
static void
compute_component_mapping(GLenum inFormat, GLenum outFormat, 
			  GLubyte *map)
{
   const int inFmt = get_map_idx(inFormat);
   const int outFmt = get_map_idx(outFormat);
   const GLubyte *in2rgba = mappings[inFmt].to_rgba;
   const GLubyte *rgba2out = mappings[outFmt].from_rgba;
   int i;
   
   for (i = 0; i < 4; i++)
      map[i] = in2rgba[rgba2out[i]];

   map[ZERO] = ZERO;
   map[ONE] = ONE;   

#if 0
   printf("from %x/%s to %x/%s map %d %d %d %d %d %d\n",
	  inFormat, _mesa_lookup_enum_by_nr(inFormat),
	  outFormat, _mesa_lookup_enum_by_nr(outFormat),
	  map[0], 
	  map[1], 
	  map[2], 
	  map[3], 
	  map[4], 
	  map[5]); 
#endif
}


/**
 * Make a temporary (color) texture image with GLfloat components.
 * Apply all needed pixel unpacking and pixel transfer operations.
 * Note that there are both logicalBaseFormat and textureBaseFormat parameters.
 * Suppose the user specifies GL_LUMINANCE as the internal texture format
 * but the graphics hardware doesn't support luminance textures.  So, we might
 * use an RGB hardware format instead.
 * If logicalBaseFormat != textureBaseFormat we have some extra work to do.
 *
 * \param ctx  the rendering context
 * \param dims  image dimensions: 1, 2 or 3
 * \param logicalBaseFormat  basic texture derived from the user's
 *    internal texture format value
 * \param textureBaseFormat  the actual basic format of the texture
 * \param srcWidth  source image width
 * \param srcHeight  source image height
 * \param srcDepth  source image depth
 * \param srcFormat  source image format
 * \param srcType  source image type
 * \param srcAddr  source image address
 * \param srcPacking  source image pixel packing
 * \return resulting image with format = textureBaseFormat and type = GLfloat.
 */
GLfloat *
_mesa_make_temp_float_image(struct gl_context *ctx, GLuint dims,
			    GLenum logicalBaseFormat,
			    GLenum textureBaseFormat,
			    GLint srcWidth, GLint srcHeight, GLint srcDepth,
			    GLenum srcFormat, GLenum srcType,
			    const GLvoid *srcAddr,
			    const struct gl_pixelstore_attrib *srcPacking,
			    GLbitfield transferOps)
{
   GLfloat *tempImage;
   const GLint components = _mesa_components_in_format(logicalBaseFormat);
   const GLint srcStride =
      _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType);
   GLfloat *dst;
   GLint img, row;

   ASSERT(dims >= 1 && dims <= 3);

   ASSERT(logicalBaseFormat == GL_RGBA ||
          logicalBaseFormat == GL_RGB ||
          logicalBaseFormat == GL_RG ||
          logicalBaseFormat == GL_RED ||
          logicalBaseFormat == GL_LUMINANCE_ALPHA ||
          logicalBaseFormat == GL_LUMINANCE ||
          logicalBaseFormat == GL_ALPHA ||
          logicalBaseFormat == GL_INTENSITY ||
          logicalBaseFormat == GL_DEPTH_COMPONENT);

   ASSERT(textureBaseFormat == GL_RGBA ||
          textureBaseFormat == GL_RGB ||
          textureBaseFormat == GL_RG ||
          textureBaseFormat == GL_RED ||
          textureBaseFormat == GL_LUMINANCE_ALPHA ||
          textureBaseFormat == GL_LUMINANCE ||
          textureBaseFormat == GL_ALPHA ||
          textureBaseFormat == GL_INTENSITY ||
          textureBaseFormat == GL_DEPTH_COMPONENT);

   tempImage = malloc(srcWidth * srcHeight * srcDepth
				  * components * sizeof(GLfloat));
   if (!tempImage)
      return NULL;

   dst = tempImage;
   for (img = 0; img < srcDepth; img++) {
      const GLubyte *src
	 = (const GLubyte *) _mesa_image_address(dims, srcPacking, srcAddr,
						 srcWidth, srcHeight,
						 srcFormat, srcType,
						 img, 0, 0);
      for (row = 0; row < srcHeight; row++) {
	 _mesa_unpack_color_span_float(ctx, srcWidth, logicalBaseFormat,
				       dst, srcFormat, srcType, src,
				       srcPacking, transferOps);
	 dst += srcWidth * components;
	 src += srcStride;
      }
   }

   if (logicalBaseFormat != textureBaseFormat) {
      /* more work */
      GLint texComponents = _mesa_components_in_format(textureBaseFormat);
      GLint logComponents = _mesa_components_in_format(logicalBaseFormat);
      GLfloat *newImage;
      GLint i, n;
      GLubyte map[6];

      /* we only promote up to RGB, RGBA and LUMINANCE_ALPHA formats for now */
      ASSERT(textureBaseFormat == GL_RGB || textureBaseFormat == GL_RGBA ||
             textureBaseFormat == GL_LUMINANCE_ALPHA);

      /* The actual texture format should have at least as many components
       * as the logical texture format.
       */
      ASSERT(texComponents >= logComponents);

      newImage = malloc(srcWidth * srcHeight * srcDepth
                                          * texComponents * sizeof(GLfloat));
      if (!newImage) {
         free(tempImage);
         return NULL;
      }

      compute_component_mapping(logicalBaseFormat, textureBaseFormat, map);

      n = srcWidth * srcHeight * srcDepth;
      for (i = 0; i < n; i++) {
         GLint k;
         for (k = 0; k < texComponents; k++) {
            GLint j = map[k];
            if (j == ZERO)
               newImage[i * texComponents + k] = 0.0F;
            else if (j == ONE)
               newImage[i * texComponents + k] = 1.0F;
            else
               newImage[i * texComponents + k] = tempImage[i * logComponents + j];
         }
      }

      free(tempImage);
      tempImage = newImage;
   }

   return tempImage;
}


/**
 * Make temporary image with uint pixel values.  Used for unsigned
 * integer-valued textures.
 */
static GLuint *
make_temp_uint_image(struct gl_context *ctx, GLuint dims,
                     GLenum logicalBaseFormat,
                     GLenum textureBaseFormat,
                     GLint srcWidth, GLint srcHeight, GLint srcDepth,
                     GLenum srcFormat, GLenum srcType,
                     const GLvoid *srcAddr,
                     const struct gl_pixelstore_attrib *srcPacking)
{
   GLuint *tempImage;
   const GLint components = _mesa_components_in_format(logicalBaseFormat);
   const GLint srcStride =
      _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType);
   GLuint *dst;
   GLint img, row;

   ASSERT(dims >= 1 && dims <= 3);

   ASSERT(logicalBaseFormat == GL_RGBA ||
          logicalBaseFormat == GL_RGB ||
          logicalBaseFormat == GL_RG ||
          logicalBaseFormat == GL_RED ||
          logicalBaseFormat == GL_LUMINANCE_ALPHA ||
          logicalBaseFormat == GL_LUMINANCE ||
          logicalBaseFormat == GL_INTENSITY ||
          logicalBaseFormat == GL_ALPHA);

   ASSERT(textureBaseFormat == GL_RGBA ||
          textureBaseFormat == GL_RGB ||
          textureBaseFormat == GL_RG ||
          textureBaseFormat == GL_RED ||
          textureBaseFormat == GL_LUMINANCE_ALPHA ||
          textureBaseFormat == GL_LUMINANCE ||
          textureBaseFormat == GL_INTENSITY ||
          textureBaseFormat == GL_ALPHA);

   tempImage = malloc(srcWidth * srcHeight * srcDepth
                                 * components * sizeof(GLuint));
   if (!tempImage)
      return NULL;

   dst = tempImage;
   for (img = 0; img < srcDepth; img++) {
      const GLubyte *src
	 = (const GLubyte *) _mesa_image_address(dims, srcPacking, srcAddr,
						 srcWidth, srcHeight,
						 srcFormat, srcType,
						 img, 0, 0);
      for (row = 0; row < srcHeight; row++) {
	 _mesa_unpack_color_span_uint(ctx, srcWidth, logicalBaseFormat,
                                      dst, srcFormat, srcType, src,
                                      srcPacking);
	 dst += srcWidth * components;
	 src += srcStride;
      }
   }

   if (logicalBaseFormat != textureBaseFormat) {
      /* more work */
      GLint texComponents = _mesa_components_in_format(textureBaseFormat);
      GLint logComponents = _mesa_components_in_format(logicalBaseFormat);
      GLuint *newImage;
      GLint i, n;
      GLubyte map[6];

      /* we only promote up to RGB, RGBA and LUMINANCE_ALPHA formats for now */
      ASSERT(textureBaseFormat == GL_RGB || textureBaseFormat == GL_RGBA ||
             textureBaseFormat == GL_LUMINANCE_ALPHA);

      /* The actual texture format should have at least as many components
       * as the logical texture format.
       */
      ASSERT(texComponents >= logComponents);

      newImage = malloc(srcWidth * srcHeight * srcDepth
                                   * texComponents * sizeof(GLuint));
      if (!newImage) {
         free(tempImage);
         return NULL;
      }

      compute_component_mapping(logicalBaseFormat, textureBaseFormat, map);

      n = srcWidth * srcHeight * srcDepth;
      for (i = 0; i < n; i++) {
         GLint k;
         for (k = 0; k < texComponents; k++) {
            GLint j = map[k];
            if (j == ZERO)
               newImage[i * texComponents + k] = 0;
            else if (j == ONE)
               newImage[i * texComponents + k] = 1;
            else
               newImage[i * texComponents + k] = tempImage[i * logComponents + j];
         }
      }

      free(tempImage);
      tempImage = newImage;
   }

   return tempImage;
}



/**
 * Make a temporary (color) texture image with GLubyte components.
 * Apply all needed pixel unpacking and pixel transfer operations.
 * Note that there are both logicalBaseFormat and textureBaseFormat parameters.
 * Suppose the user specifies GL_LUMINANCE as the internal texture format
 * but the graphics hardware doesn't support luminance textures.  So, we might
 * use an RGB hardware format instead.
 * If logicalBaseFormat != textureBaseFormat we have some extra work to do.
 *
 * \param ctx  the rendering context
 * \param dims  image dimensions: 1, 2 or 3
 * \param logicalBaseFormat  basic texture derived from the user's
 *    internal texture format value
 * \param textureBaseFormat  the actual basic format of the texture
 * \param srcWidth  source image width
 * \param srcHeight  source image height
 * \param srcDepth  source image depth
 * \param srcFormat  source image format
 * \param srcType  source image type
 * \param srcAddr  source image address
 * \param srcPacking  source image pixel packing
 * \return resulting image with format = textureBaseFormat and type = GLubyte.
 */
GLubyte *
_mesa_make_temp_ubyte_image(struct gl_context *ctx, GLuint dims,
                            GLenum logicalBaseFormat,
                            GLenum textureBaseFormat,
                            GLint srcWidth, GLint srcHeight, GLint srcDepth,
                            GLenum srcFormat, GLenum srcType,
                            const GLvoid *srcAddr,
                            const struct gl_pixelstore_attrib *srcPacking)
{
   GLuint transferOps = ctx->_ImageTransferState;
   const GLint components = _mesa_components_in_format(logicalBaseFormat);
   GLint img, row;
   GLubyte *tempImage, *dst;

   ASSERT(dims >= 1 && dims <= 3);

   ASSERT(logicalBaseFormat == GL_RGBA ||
          logicalBaseFormat == GL_RGB ||
          logicalBaseFormat == GL_RG ||
          logicalBaseFormat == GL_RED ||
          logicalBaseFormat == GL_LUMINANCE_ALPHA ||
          logicalBaseFormat == GL_LUMINANCE ||
          logicalBaseFormat == GL_ALPHA ||
          logicalBaseFormat == GL_INTENSITY);

   ASSERT(textureBaseFormat == GL_RGBA ||
          textureBaseFormat == GL_RGB ||
          textureBaseFormat == GL_RG ||
          textureBaseFormat == GL_RED ||
          textureBaseFormat == GL_LUMINANCE_ALPHA ||
          textureBaseFormat == GL_LUMINANCE ||
          textureBaseFormat == GL_ALPHA ||
          textureBaseFormat == GL_INTENSITY);

   /* unpack and transfer the source image */
   tempImage = malloc(srcWidth * srcHeight * srcDepth
                                       * components * sizeof(GLubyte));
   if (!tempImage) {
      return NULL;
   }

   dst = tempImage;
   for (img = 0; img < srcDepth; img++) {
      const GLint srcStride =
         _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType);
      const GLubyte *src =
         (const GLubyte *) _mesa_image_address(dims, srcPacking, srcAddr,
                                               srcWidth, srcHeight,
                                               srcFormat, srcType,
                                               img, 0, 0);
      for (row = 0; row < srcHeight; row++) {
         _mesa_unpack_color_span_ubyte(ctx, srcWidth, logicalBaseFormat, dst,
                                       srcFormat, srcType, src, srcPacking,
                                       transferOps);
         dst += srcWidth * components;
         src += srcStride;
      }
   }

   if (logicalBaseFormat != textureBaseFormat) {
      /* one more conversion step */
      GLint texComponents = _mesa_components_in_format(textureBaseFormat);
      GLint logComponents = _mesa_components_in_format(logicalBaseFormat);
      GLubyte *newImage;
      GLint i, n;
      GLubyte map[6];

      /* we only promote up to RGB, RGBA and LUMINANCE_ALPHA formats for now */
      ASSERT(textureBaseFormat == GL_RGB || textureBaseFormat == GL_RGBA ||
             textureBaseFormat == GL_LUMINANCE_ALPHA);

      /* The actual texture format should have at least as many components
       * as the logical texture format.
       */
      ASSERT(texComponents >= logComponents);

      newImage = malloc(srcWidth * srcHeight * srcDepth
                                         * texComponents * sizeof(GLubyte));
      if (!newImage) {
         free(tempImage);
         return NULL;
      }

      compute_component_mapping(logicalBaseFormat, textureBaseFormat, map);

      n = srcWidth * srcHeight * srcDepth;
      for (i = 0; i < n; i++) {
         GLint k;
         for (k = 0; k < texComponents; k++) {
            GLint j = map[k];
            if (j == ZERO)
               newImage[i * texComponents + k] = 0;
            else if (j == ONE)
               newImage[i * texComponents + k] = 255;
            else
               newImage[i * texComponents + k] = tempImage[i * logComponents + j];
         }
      }

      free(tempImage);
      tempImage = newImage;
   }

   return tempImage;
}


/**
 * Copy GLubyte pixels from <src> to <dst> with swizzling.
 * \param dst  destination pixels
 * \param dstComponents  number of color components in destination pixels
 * \param src  source pixels
 * \param srcComponents  number of color components in source pixels
 * \param map  the swizzle mapping.  map[X] says where to find the X component
 *             in the source image's pixels.  For example, if the source image
 *             is GL_BGRA and X = red, map[0] yields 2.
 * \param count  number of pixels to copy/swizzle.
 */
static void
swizzle_copy(GLubyte *dst, GLuint dstComponents, const GLubyte *src, 
             GLuint srcComponents, const GLubyte *map, GLuint count)
{
#define SWZ_CPY(dst, src, count, dstComps, srcComps) \
   do {                                              \
      GLuint i;                                      \
      for (i = 0; i < count; i++) {                  \
         GLuint j;                                   \
         if (srcComps == 4) {                        \
            COPY_4UBV(tmp, src);                     \
         }                                           \
         else {                                      \
            for (j = 0; j < srcComps; j++) {         \
               tmp[j] = src[j];                      \
            }                                        \
         }                                           \
         src += srcComps;                            \
         for (j = 0; j < dstComps; j++) {            \
            dst[j] = tmp[map[j]];                    \
         }                                           \
         dst += dstComps;                            \
      }                                              \
   } while (0)

   GLubyte tmp[6];

   tmp[ZERO] = 0x0;
   tmp[ONE] = 0xff;

   ASSERT(srcComponents <= 4);
   ASSERT(dstComponents <= 4);

   switch (dstComponents) {
   case 4:
      switch (srcComponents) {
      case 4:
         SWZ_CPY(dst, src, count, 4, 4);
         break;
      case 3:
         SWZ_CPY(dst, src, count, 4, 3);
         break;
      case 2:
         SWZ_CPY(dst, src, count, 4, 2);
         break;
      case 1:
         SWZ_CPY(dst, src, count, 4, 1);
         break;
      default:
         ;
      }
      break;
   case 3:
      switch (srcComponents) {
      case 4:
         SWZ_CPY(dst, src, count, 3, 4);
         break;
      case 3:
         SWZ_CPY(dst, src, count, 3, 3);
         break;
      case 2:
         SWZ_CPY(dst, src, count, 3, 2);
         break;
      case 1:
         SWZ_CPY(dst, src, count, 3, 1);
         break;
      default:
         ;
      }
      break;
   case 2:
      switch (srcComponents) {
      case 4:
         SWZ_CPY(dst, src, count, 2, 4);
         break;
      case 3:
         SWZ_CPY(dst, src, count, 2, 3);
         break;
      case 2:
         SWZ_CPY(dst, src, count, 2, 2);
         break;
      case 1:
         SWZ_CPY(dst, src, count, 2, 1);
         break;
      default:
         ;
      }
      break;
   case 1:
      switch (srcComponents) {
      case 4:
         SWZ_CPY(dst, src, count, 1, 4);
         break;
      case 3:
         SWZ_CPY(dst, src, count, 1, 3);
         break;
      case 2:
         SWZ_CPY(dst, src, count, 1, 2);
         break;
      case 1:
         SWZ_CPY(dst, src, count, 1, 1);
         break;
      default:
         ;
      }
      break;
   default:
      ;
   }
#undef SWZ_CPY
}



static const GLubyte map_identity[6] = { 0, 1, 2, 3, ZERO, ONE };
static const GLubyte map_3210[6] = { 3, 2, 1, 0, ZERO, ONE };


/**
 * For 1-byte/pixel formats (or 8_8_8_8 packed formats), return a
 * mapping array depending on endianness.
 */
static const GLubyte *
type_mapping( GLenum srcType )
{
   switch (srcType) {
   case GL_BYTE:
   case GL_UNSIGNED_BYTE:
      return map_identity;
   case GL_UNSIGNED_INT_8_8_8_8:
      return _mesa_little_endian() ? map_3210 : map_identity;
   case GL_UNSIGNED_INT_8_8_8_8_REV:
      return _mesa_little_endian() ? map_identity : map_3210;
   default:
      return NULL;
   }
}


/**
 * For 1-byte/pixel formats (or 8_8_8_8 packed formats), return a
 * mapping array depending on pixelstore byte swapping state.
 */
static const GLubyte *
byteswap_mapping( GLboolean swapBytes,
		  GLenum srcType )
{
   if (!swapBytes) 
      return map_identity;

   switch (srcType) {
   case GL_BYTE:
   case GL_UNSIGNED_BYTE:
      return map_identity;
   case GL_UNSIGNED_INT_8_8_8_8:
   case GL_UNSIGNED_INT_8_8_8_8_REV:
      return map_3210;
   default:
      return NULL;
   }
}



/**
 * Transfer a GLubyte texture image with component swizzling.
 */
static void
_mesa_swizzle_ubyte_image(struct gl_context *ctx, 
			  GLuint dimensions,
			  GLenum srcFormat,
			  GLenum srcType,

			  GLenum baseInternalFormat,

			  const GLubyte *rgba2dst,
			  GLuint dstComponents,

			  GLint dstRowStride,
                          GLubyte **dstSlices,

			  GLint srcWidth, GLint srcHeight, GLint srcDepth,
			  const GLvoid *srcAddr,
			  const struct gl_pixelstore_attrib *srcPacking )
{
   GLint srcComponents = _mesa_components_in_format(srcFormat);
   const GLubyte *srctype2ubyte, *swap;
   GLubyte map[4], src2base[6], base2rgba[6];
   GLint i;
   const GLint srcRowStride =
      _mesa_image_row_stride(srcPacking, srcWidth,
                             srcFormat, GL_UNSIGNED_BYTE);
   const GLint srcImageStride
      = _mesa_image_image_stride(srcPacking, srcWidth, srcHeight, srcFormat,
                                 GL_UNSIGNED_BYTE);
   const GLubyte *srcImage
      = (const GLubyte *) _mesa_image_address(dimensions, srcPacking, srcAddr,
                                              srcWidth, srcHeight, srcFormat,
                                              GL_UNSIGNED_BYTE, 0, 0, 0);

   (void) ctx;

   /* Translate from src->baseInternal->GL_RGBA->dst.  This will
    * correctly deal with RGBA->RGB->RGBA conversions where the final
    * A value must be 0xff regardless of the incoming alpha values.
    */
   compute_component_mapping(srcFormat, baseInternalFormat, src2base);
   compute_component_mapping(baseInternalFormat, GL_RGBA, base2rgba);
   swap = byteswap_mapping(srcPacking->SwapBytes, srcType);
   srctype2ubyte = type_mapping(srcType);


   for (i = 0; i < 4; i++)
      map[i] = srctype2ubyte[swap[src2base[base2rgba[rgba2dst[i]]]]];

/*    printf("map %d %d %d %d\n", map[0], map[1], map[2], map[3]);  */

   if (srcComponents == dstComponents &&
       srcRowStride == dstRowStride &&
       srcRowStride == srcWidth * srcComponents &&
       dimensions < 3) {
      /* 1 and 2D images only */
      GLubyte *dstImage = dstSlices[0];
      swizzle_copy(dstImage, dstComponents, srcImage, srcComponents, map, 
		   srcWidth * srcHeight);
   }
   else {
      GLint img, row;
      for (img = 0; img < srcDepth; img++) {
         const GLubyte *srcRow = srcImage;
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
	    swizzle_copy(dstRow, dstComponents, srcRow, srcComponents, map, srcWidth);
            dstRow += dstRowStride;
            srcRow += srcRowStride;
         }
         srcImage += srcImageStride;
      }
   }
}


/**
 * Teximage storage routine for when a simple memcpy will do.
 * No pixel transfer operations or special texel encodings allowed.
 * 1D, 2D and 3D images supported.
 */
static void
memcpy_texture(struct gl_context *ctx,
	       GLuint dimensions,
               mesa_format dstFormat,
               GLint dstRowStride,
               GLubyte **dstSlices,
               GLint srcWidth, GLint srcHeight, GLint srcDepth,
               GLenum srcFormat, GLenum srcType,
               const GLvoid *srcAddr,
               const struct gl_pixelstore_attrib *srcPacking)
{
   const GLint srcRowStride = _mesa_image_row_stride(srcPacking, srcWidth,
                                                     srcFormat, srcType);
   const GLint srcImageStride = _mesa_image_image_stride(srcPacking,
                                      srcWidth, srcHeight, srcFormat, srcType);
   const GLubyte *srcImage = (const GLubyte *) _mesa_image_address(dimensions,
        srcPacking, srcAddr, srcWidth, srcHeight, srcFormat, srcType, 0, 0, 0);
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
   const GLint bytesPerRow = srcWidth * texelBytes;

   if (dstRowStride == srcRowStride &&
       dstRowStride == bytesPerRow) {
      /* memcpy image by image */
      GLint img;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstImage = dstSlices[img];
         memcpy(dstImage, srcImage, bytesPerRow * srcHeight);
         srcImage += srcImageStride;
      }
   }
   else {
      /* memcpy row by row */
      GLint img, row;
      for (img = 0; img < srcDepth; img++) {
         const GLubyte *srcRow = srcImage;
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            memcpy(dstRow, srcRow, bytesPerRow);
            dstRow += dstRowStride;
            srcRow += srcRowStride;
         }
         srcImage += srcImageStride;
      }
   }
}


/**
 * General-case function for storing a color texture images with
 * components that can be represented with ubytes.  Example destination
 * texture formats are MESA_FORMAT_ARGB888, ARGB4444, RGB565.
 */
static GLboolean
store_ubyte_texture(TEXSTORE_PARAMS)
{
   const GLint srcRowStride = srcWidth * 4 * sizeof(GLubyte);
   GLubyte *tempImage, *src;
   GLint img;

   tempImage = _mesa_make_temp_ubyte_image(ctx, dims,
                                           baseInternalFormat,
                                           GL_RGBA,
                                           srcWidth, srcHeight, srcDepth,
                                           srcFormat, srcType, srcAddr,
                                           srcPacking);
   if (!tempImage)
      return GL_FALSE;

   src = tempImage;
   for (img = 0; img < srcDepth; img++) {
      _mesa_pack_ubyte_rgba_rect(dstFormat, srcWidth, srcHeight,
                                 src, srcRowStride,
                                 dstSlices[img], dstRowStride);
      src += srcHeight * srcRowStride;
   }
   free(tempImage);

   return GL_TRUE;
}




/**
 * Store a 32-bit integer or float depth component texture image.
 */
static GLboolean
_mesa_texstore_z32(TEXSTORE_PARAMS)
{
   const GLuint depthScale = 0xffffffff;
   GLenum dstType;
   (void) dims;
   ASSERT(dstFormat == MESA_FORMAT_Z_UNORM32 ||
          dstFormat == MESA_FORMAT_Z_FLOAT32);
   ASSERT(_mesa_get_format_bytes(dstFormat) == sizeof(GLuint));

   if (dstFormat == MESA_FORMAT_Z_UNORM32)
      dstType = GL_UNSIGNED_INT;
   else
      dstType = GL_FLOAT;

   {
      /* general path */
      GLint img, row;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            const GLvoid *src = _mesa_image_address(dims, srcPacking,
                srcAddr, srcWidth, srcHeight, srcFormat, srcType, img, row, 0);
            _mesa_unpack_depth_span(ctx, srcWidth,
                                    dstType, dstRow,
                                    depthScale, srcType, src, srcPacking);
            dstRow += dstRowStride;
         }
      }
   }
   return GL_TRUE;
}


/**
 * Store a 24-bit integer depth component texture image.
 */
static GLboolean
_mesa_texstore_x8_z24(TEXSTORE_PARAMS)
{
   const GLuint depthScale = 0xffffff;

   (void) dims;
   ASSERT(dstFormat == MESA_FORMAT_Z24_UNORM_X8_UINT);

   {
      /* general path */
      GLint img, row;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            const GLvoid *src = _mesa_image_address(dims, srcPacking,
                srcAddr, srcWidth, srcHeight, srcFormat, srcType, img, row, 0);
            _mesa_unpack_depth_span(ctx, srcWidth,
                                    GL_UNSIGNED_INT, (GLuint *) dstRow,
                                    depthScale, srcType, src, srcPacking);
            dstRow += dstRowStride;
         }
      }
   }
   return GL_TRUE;
}


/**
 * Store a 24-bit integer depth component texture image.
 */
static GLboolean
_mesa_texstore_z24_x8(TEXSTORE_PARAMS)
{
   const GLuint depthScale = 0xffffff;

   (void) dims;
   ASSERT(dstFormat == MESA_FORMAT_X8_UINT_Z24_UNORM);

   {
      /* general path */
      GLint img, row;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            const GLvoid *src = _mesa_image_address(dims, srcPacking,
                srcAddr, srcWidth, srcHeight, srcFormat, srcType, img, row, 0);
            GLuint *dst = (GLuint *) dstRow;
            GLint i;
            _mesa_unpack_depth_span(ctx, srcWidth,
                                    GL_UNSIGNED_INT, dst,
                                    depthScale, srcType, src, srcPacking);
            for (i = 0; i < srcWidth; i++)
               dst[i] <<= 8;
            dstRow += dstRowStride;
         }
      }
   }
   return GL_TRUE;
}


/**
 * Store a 16-bit integer depth component texture image.
 */
static GLboolean
_mesa_texstore_z16(TEXSTORE_PARAMS)
{
   const GLuint depthScale = 0xffff;
   (void) dims;
   ASSERT(dstFormat == MESA_FORMAT_Z_UNORM16);
   ASSERT(_mesa_get_format_bytes(dstFormat) == sizeof(GLushort));

   {
      /* general path */
      GLint img, row;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            const GLvoid *src = _mesa_image_address(dims, srcPacking,
                srcAddr, srcWidth, srcHeight, srcFormat, srcType, img, row, 0);
            GLushort *dst16 = (GLushort *) dstRow;
            _mesa_unpack_depth_span(ctx, srcWidth,
                                    GL_UNSIGNED_SHORT, dst16, depthScale,
                                    srcType, src, srcPacking);
            dstRow += dstRowStride;
         }
      }
   }
   return GL_TRUE;
}


/**
 * Store an rgb565 or rgb565_rev texture image.
 */
static GLboolean
_mesa_texstore_rgb565(TEXSTORE_PARAMS)
{
   ASSERT(dstFormat == MESA_FORMAT_B5G6R5_UNORM ||
          dstFormat == MESA_FORMAT_R5G6B5_UNORM);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 2);

   if (!ctx->_ImageTransferState &&
       !srcPacking->SwapBytes &&
       baseInternalFormat == GL_RGB &&
       srcFormat == GL_RGB &&
       srcType == GL_UNSIGNED_BYTE &&
       dims == 2) {
      /* do optimized tex store */
      const GLint srcRowStride =
         _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType);
      const GLubyte *src = (const GLubyte *)
         _mesa_image_address(dims, srcPacking, srcAddr, srcWidth, srcHeight,
                             srcFormat, srcType, 0, 0, 0);
      GLubyte *dst = dstSlices[0];
      GLint row, col;
      for (row = 0; row < srcHeight; row++) {
         const GLubyte *srcUB = (const GLubyte *) src;
         GLushort *dstUS = (GLushort *) dst;
         /* check for byteswapped format */
         if (dstFormat == MESA_FORMAT_B5G6R5_UNORM) {
            for (col = 0; col < srcWidth; col++) {
               dstUS[col] = PACK_COLOR_565( srcUB[0], srcUB[1], srcUB[2] );
               srcUB += 3;
            }
         }
         else {
            for (col = 0; col < srcWidth; col++) {
               dstUS[col] = PACK_COLOR_565_REV( srcUB[0], srcUB[1], srcUB[2] );
               srcUB += 3;
            }
         }
         dst += dstRowStride;
         src += srcRowStride;
      }
   }
   else {
      return store_ubyte_texture(ctx, dims, baseInternalFormat,
                                 dstFormat, dstRowStride, dstSlices,
                                 srcWidth, srcHeight, srcDepth,
                                 srcFormat, srcType, srcAddr, srcPacking);
   }
   return GL_TRUE;
}


/**
 * Store a texture in MESA_FORMAT_A8B8G8R8_UNORM or MESA_FORMAT_R8G8B8A8_UNORM.
 */
static GLboolean
_mesa_texstore_rgba8888(TEXSTORE_PARAMS)
{
   const GLboolean littleEndian = _mesa_little_endian();

   ASSERT(dstFormat == MESA_FORMAT_A8B8G8R8_UNORM ||
          dstFormat == MESA_FORMAT_R8G8B8A8_UNORM ||
          dstFormat == MESA_FORMAT_X8B8G8R8_UNORM ||
          dstFormat == MESA_FORMAT_R8G8B8X8_UNORM);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 4);

   if (!ctx->_ImageTransferState &&
       (srcType == GL_UNSIGNED_BYTE ||
        srcType == GL_UNSIGNED_INT_8_8_8_8 ||
        srcType == GL_UNSIGNED_INT_8_8_8_8_REV) &&
       can_swizzle(baseInternalFormat) &&
       can_swizzle(srcFormat)) {

      GLubyte dstmap[4];

      /* dstmap - how to swizzle from RGBA to dst format:
       */
      if ((littleEndian && (dstFormat == MESA_FORMAT_A8B8G8R8_UNORM ||
                            dstFormat == MESA_FORMAT_X8B8G8R8_UNORM)) ||
	  (!littleEndian && (dstFormat == MESA_FORMAT_R8G8B8A8_UNORM ||
	                     dstFormat == MESA_FORMAT_R8G8B8X8_UNORM))) {
	 dstmap[3] = 0;
	 dstmap[2] = 1;
	 dstmap[1] = 2;
	 dstmap[0] = 3;
      }
      else {
	 dstmap[3] = 3;
	 dstmap[2] = 2;
	 dstmap[1] = 1;
	 dstmap[0] = 0;
      }
      
      _mesa_swizzle_ubyte_image(ctx, dims,
				srcFormat,
				srcType,
				baseInternalFormat,
				dstmap, 4,
				dstRowStride, dstSlices,
				srcWidth, srcHeight, srcDepth, srcAddr,
				srcPacking);      
   }
   else {
      return store_ubyte_texture(ctx, dims, baseInternalFormat,
                                 dstFormat, dstRowStride, dstSlices,
                                 srcWidth, srcHeight, srcDepth,
                                 srcFormat, srcType, srcAddr, srcPacking);
   }
   return GL_TRUE;
}


static GLboolean
_mesa_texstore_argb8888(TEXSTORE_PARAMS)
{
   const GLboolean littleEndian = _mesa_little_endian();

   ASSERT(dstFormat == MESA_FORMAT_B8G8R8A8_UNORM ||
          dstFormat == MESA_FORMAT_A8R8G8B8_UNORM ||
          dstFormat == MESA_FORMAT_B8G8R8X8_UNORM ||
          dstFormat == MESA_FORMAT_X8R8G8B8_UNORM );
   ASSERT(_mesa_get_format_bytes(dstFormat) == 4);

   if (!ctx->_ImageTransferState &&
       !srcPacking->SwapBytes &&
       (dstFormat == MESA_FORMAT_B8G8R8A8_UNORM ||
        dstFormat == MESA_FORMAT_B8G8R8X8_UNORM) &&
       srcFormat == GL_RGB &&
       (baseInternalFormat == GL_RGBA ||
        baseInternalFormat == GL_RGB) &&
       srcType == GL_UNSIGNED_BYTE) {
      int img, row, col;
      for (img = 0; img < srcDepth; img++) {
         const GLint srcRowStride =
            _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType);
         GLubyte *srcRow = (GLubyte *) _mesa_image_address(dims, srcPacking,
                  srcAddr, srcWidth, srcHeight, srcFormat, srcType, img, 0, 0);
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLuint *d4 = (GLuint *) dstRow;
            for (col = 0; col < srcWidth; col++) {
               d4[col] = PACK_COLOR_8888(0xff,
                                         srcRow[col * 3 + RCOMP],
                                         srcRow[col * 3 + GCOMP],
                                         srcRow[col * 3 + BCOMP]);
            }
            dstRow += dstRowStride;
            srcRow += srcRowStride;
         }
      }
   }
   else if (!ctx->_ImageTransferState &&
            !srcPacking->SwapBytes &&
            dstFormat == MESA_FORMAT_B8G8R8A8_UNORM &&
            srcFormat == GL_LUMINANCE_ALPHA &&
            baseInternalFormat == GL_RGBA &&
            srcType == GL_UNSIGNED_BYTE) {
      /* special case of storing LA -> ARGB8888 */
      int img, row, col;
      const GLint srcRowStride =
         _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType);
      for (img = 0; img < srcDepth; img++) {
         const GLubyte *srcRow = (const GLubyte *)
            _mesa_image_address(dims, srcPacking, srcAddr, srcWidth,
                                srcHeight, srcFormat, srcType, img, 0, 0);
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLuint *d4 = (GLuint *) dstRow;
            for (col = 0; col < srcWidth; col++) {
               GLubyte l = srcRow[col * 2 + 0], a = srcRow[col * 2 + 1];
               d4[col] = PACK_COLOR_8888(a, l, l, l);
            }
            dstRow += dstRowStride;
            srcRow += srcRowStride;
         }
      }
   }
   else if (!ctx->_ImageTransferState &&
            !srcPacking->SwapBytes &&
	    dstFormat == MESA_FORMAT_B8G8R8A8_UNORM &&
            srcFormat == GL_RGBA &&
	    baseInternalFormat == GL_RGBA &&
            srcType == GL_UNSIGNED_BYTE) {
      /* same as above case, but src data has alpha too */
      GLint img, row, col;
      /* For some reason, streaming copies to write-combined regions
       * are extremely sensitive to the characteristics of how the
       * source data is retrieved.  By reordering the source reads to
       * be in-order, the speed of this operation increases by half.
       * Strangely the same isn't required for the RGB path, above.
       */
      for (img = 0; img < srcDepth; img++) {
         const GLint srcRowStride =
            _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType);
         GLubyte *srcRow = (GLubyte *) _mesa_image_address(dims, srcPacking,
                  srcAddr, srcWidth, srcHeight, srcFormat, srcType, img, 0, 0);
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLuint *d4 = (GLuint *) dstRow;
            for (col = 0; col < srcWidth; col++) {
               d4[col] = PACK_COLOR_8888(srcRow[col * 4 + ACOMP],
                                         srcRow[col * 4 + RCOMP],
                                         srcRow[col * 4 + GCOMP],
                                         srcRow[col * 4 + BCOMP]);
            }
            dstRow += dstRowStride;
            srcRow += srcRowStride;
         }
      }
   }
   else if (!ctx->_ImageTransferState &&
	    (srcType == GL_UNSIGNED_BYTE ||
	     srcType == GL_UNSIGNED_INT_8_8_8_8 ||
	     srcType == GL_UNSIGNED_INT_8_8_8_8_REV) &&
	    can_swizzle(baseInternalFormat) &&	   
	    can_swizzle(srcFormat)) {

      GLubyte dstmap[4];

      /* dstmap - how to swizzle from RGBA to dst format:
       */
      if ((littleEndian && dstFormat == MESA_FORMAT_B8G8R8A8_UNORM) ||
          (littleEndian && dstFormat == MESA_FORMAT_B8G8R8X8_UNORM) ||
	  (!littleEndian && dstFormat == MESA_FORMAT_A8R8G8B8_UNORM) ||
	  (!littleEndian && dstFormat == MESA_FORMAT_X8R8G8B8_UNORM)) {
	 dstmap[3] = 3;		/* alpha */
	 dstmap[2] = 0;		/* red */
	 dstmap[1] = 1;		/* green */
	 dstmap[0] = 2;		/* blue */
      }
      else {
	 assert((littleEndian && dstFormat == MESA_FORMAT_A8R8G8B8_UNORM) ||
		(!littleEndian && dstFormat == MESA_FORMAT_B8G8R8A8_UNORM) ||
		(littleEndian && dstFormat == MESA_FORMAT_X8R8G8B8_UNORM) ||
		(!littleEndian && dstFormat == MESA_FORMAT_B8G8R8X8_UNORM));
	 dstmap[3] = 2;
	 dstmap[2] = 1;
	 dstmap[1] = 0;
	 dstmap[0] = 3;
      }
 
      _mesa_swizzle_ubyte_image(ctx, dims,
				srcFormat,
				srcType,
				baseInternalFormat,
				dstmap, 4,
				dstRowStride,
                                dstSlices,
				srcWidth, srcHeight, srcDepth, srcAddr,
				srcPacking);      
   }
   else {
      return store_ubyte_texture(ctx, dims, baseInternalFormat,
                                 dstFormat, dstRowStride, dstSlices,
                                 srcWidth, srcHeight, srcDepth,
                                 srcFormat, srcType, srcAddr, srcPacking);
   }
   return GL_TRUE;
}


static GLboolean
_mesa_texstore_rgb888(TEXSTORE_PARAMS)
{
   ASSERT(dstFormat == MESA_FORMAT_BGR_UNORM8);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 3);

   if (!ctx->_ImageTransferState &&
       !srcPacking->SwapBytes &&
       srcFormat == GL_RGBA &&
       srcType == GL_UNSIGNED_BYTE) {
      /* extract RGB from RGBA */
      GLint img, row, col;
      for (img = 0; img < srcDepth; img++) {
         const GLint srcRowStride =
            _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType);
         GLubyte *srcRow = (GLubyte *) _mesa_image_address(dims, srcPacking,
                  srcAddr, srcWidth, srcHeight, srcFormat, srcType, img, 0, 0);
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            for (col = 0; col < srcWidth; col++) {
               dstRow[col * 3 + 0] = srcRow[col * 4 + BCOMP];
               dstRow[col * 3 + 1] = srcRow[col * 4 + GCOMP];
               dstRow[col * 3 + 2] = srcRow[col * 4 + RCOMP];
            }
            dstRow += dstRowStride;
            srcRow += srcRowStride;
         }
      }
   }
   else if (!ctx->_ImageTransferState &&
	    srcType == GL_UNSIGNED_BYTE &&
	    can_swizzle(baseInternalFormat) &&
	    can_swizzle(srcFormat)) {

      GLubyte dstmap[4];

      /* dstmap - how to swizzle from RGBA to dst format:
       */
      dstmap[0] = 2;
      dstmap[1] = 1;
      dstmap[2] = 0;
      dstmap[3] = ONE;		/* ? */
      
      _mesa_swizzle_ubyte_image(ctx, dims,
				srcFormat,
				srcType,
				baseInternalFormat,
				dstmap, 3,
				dstRowStride, dstSlices,
				srcWidth, srcHeight, srcDepth, srcAddr,
				srcPacking);      
   }
   else {
      return store_ubyte_texture(ctx, dims, baseInternalFormat,
                                 dstFormat, dstRowStride, dstSlices,
                                 srcWidth, srcHeight, srcDepth,
                                 srcFormat, srcType, srcAddr, srcPacking);
   }
   return GL_TRUE;
}


static GLboolean
_mesa_texstore_bgr888(TEXSTORE_PARAMS)
{
   ASSERT(dstFormat == MESA_FORMAT_RGB_UNORM8);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 3);

   if (!ctx->_ImageTransferState &&
       !srcPacking->SwapBytes &&
       srcFormat == GL_RGBA &&
       srcType == GL_UNSIGNED_BYTE) {
      /* extract BGR from RGBA */
      int img, row, col;
      for (img = 0; img < srcDepth; img++) {
         const GLint srcRowStride =
            _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType);
         GLubyte *srcRow = (GLubyte *) _mesa_image_address(dims, srcPacking,
                  srcAddr, srcWidth, srcHeight, srcFormat, srcType, img, 0, 0);
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            for (col = 0; col < srcWidth; col++) {
               dstRow[col * 3 + 0] = srcRow[col * 4 + RCOMP];
               dstRow[col * 3 + 1] = srcRow[col * 4 + GCOMP];
               dstRow[col * 3 + 2] = srcRow[col * 4 + BCOMP];
            }
            dstRow += dstRowStride;
            srcRow += srcRowStride;
         }
      }
   }
   else if (!ctx->_ImageTransferState &&
	    srcType == GL_UNSIGNED_BYTE &&
	    can_swizzle(baseInternalFormat) &&
	    can_swizzle(srcFormat)) {

      GLubyte dstmap[4];

      /* dstmap - how to swizzle from RGBA to dst format:
       */
      dstmap[0] = 0;
      dstmap[1] = 1;
      dstmap[2] = 2;
      dstmap[3] = ONE;		/* ? */
      
      _mesa_swizzle_ubyte_image(ctx, dims,
				srcFormat,
				srcType,
				baseInternalFormat,
				dstmap, 3,
				dstRowStride, dstSlices,
				srcWidth, srcHeight, srcDepth, srcAddr,
				srcPacking);      
   }   
   else {
      return store_ubyte_texture(ctx, dims, baseInternalFormat,
                                 dstFormat, dstRowStride, dstSlices,
                                 srcWidth, srcHeight, srcDepth,
                                 srcFormat, srcType, srcAddr, srcPacking);
   }
   return GL_TRUE;
}


static GLboolean
_mesa_texstore_argb2101010(TEXSTORE_PARAMS)
{
   ASSERT(dstFormat == MESA_FORMAT_B10G10R10A2_UNORM ||
          dstFormat == MESA_FORMAT_B10G10R10X2_UNORM);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 4);

   {
      /* general path */
      /* Hardcode GL_RGBA as the base format, which forces alpha to 1.0
       * if the internal format is RGB. */
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 GL_RGBA,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *src = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         if (baseInternalFormat == GL_RGBA || baseInternalFormat == GL_RGB) {
            for (row = 0; row < srcHeight; row++) {
               GLuint *dstUI = (GLuint *) dstRow;
               for (col = 0; col < srcWidth; col++) {
                  GLushort a,r,g,b;

                  UNCLAMPED_FLOAT_TO_USHORT(a, src[ACOMP]);
                  UNCLAMPED_FLOAT_TO_USHORT(r, src[RCOMP]);
                  UNCLAMPED_FLOAT_TO_USHORT(g, src[GCOMP]);
                  UNCLAMPED_FLOAT_TO_USHORT(b, src[BCOMP]);
                  dstUI[col] = PACK_COLOR_2101010_US(a, r, g, b);
                  src += 4;
               }
               dstRow += dstRowStride;
            }
         } else {
            ASSERT(0);
         }
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}


/**
 * Do texstore for 2-channel, 4-bit/channel, unsigned normalized formats.
 */
static GLboolean
_mesa_texstore_unorm44(TEXSTORE_PARAMS)
{
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_L4A4_UNORM);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 1);

   {
      /* general path */
      const GLubyte *tempImage = _mesa_make_temp_ubyte_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking);
      const GLubyte *src = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLubyte *dstUS = (GLubyte *) dstRow;
            for (col = 0; col < srcWidth; col++) {
               /* src[0] is luminance, src[1] is alpha */
               dstUS[col] = PACK_COLOR_44( src[1],
                                           src[0] );
               src += 2;
            }
            dstRow += dstRowStride;
         }
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}


/**
 * Do texstore for 2-channel, 8-bit/channel, unsigned normalized formats.
 */
static GLboolean
_mesa_texstore_unorm88(TEXSTORE_PARAMS)
{
   const GLboolean littleEndian = _mesa_little_endian();
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_L8A8_UNORM ||
          dstFormat == MESA_FORMAT_A8L8_UNORM ||
          dstFormat == MESA_FORMAT_R8G8_UNORM ||
          dstFormat == MESA_FORMAT_G8R8_UNORM);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 2);

   if (!ctx->_ImageTransferState &&
       littleEndian &&
       srcType == GL_UNSIGNED_BYTE &&
       can_swizzle(baseInternalFormat) &&
       can_swizzle(srcFormat)) {
      GLubyte dstmap[4];

      /* dstmap - how to swizzle from RGBA to dst format:
       */
      if (dstFormat == MESA_FORMAT_L8A8_UNORM || dstFormat == MESA_FORMAT_A8L8_UNORM) {
	 if ((littleEndian && dstFormat == MESA_FORMAT_L8A8_UNORM) ||
	     (!littleEndian && dstFormat == MESA_FORMAT_A8L8_UNORM)) {
	    dstmap[0] = 0;
	    dstmap[1] = 3;
	 }
	 else {
	    dstmap[0] = 3;
	    dstmap[1] = 0;
	 }
      }
      else {
	 if ((littleEndian && dstFormat == MESA_FORMAT_R8G8_UNORM) ||
	     (!littleEndian && dstFormat == MESA_FORMAT_G8R8_UNORM)) {
	    dstmap[0] = 0;
	    dstmap[1] = 1;
	 }
	 else {
	    dstmap[0] = 1;
	    dstmap[1] = 0;
	 }
      }
      dstmap[2] = ZERO;		/* ? */
      dstmap[3] = ONE;		/* ? */
      
      _mesa_swizzle_ubyte_image(ctx, dims,
				srcFormat,
				srcType,
				baseInternalFormat,
				dstmap, 2,
				dstRowStride, dstSlices,
				srcWidth, srcHeight, srcDepth, srcAddr,
				srcPacking);      
   }   
   else {
      /* general path */
      const GLubyte *tempImage = _mesa_make_temp_ubyte_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking);
      const GLubyte *src = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLushort *dstUS = (GLushort *) dstRow;
            if (dstFormat == MESA_FORMAT_L8A8_UNORM ||
		dstFormat == MESA_FORMAT_R8G8_UNORM) {
               for (col = 0; col < srcWidth; col++) {
                  /* src[0] is luminance (or R), src[1] is alpha (or G) */
                 dstUS[col] = PACK_COLOR_88( src[1],
                                             src[0] );
                 src += 2;
               }
            }
            else {
               for (col = 0; col < srcWidth; col++) {
                  /* src[0] is luminance (or R), src[1] is alpha (or G) */
                 dstUS[col] = PACK_COLOR_88_REV( src[1],
                                                 src[0] );
                 src += 2;
               }
            }
            dstRow += dstRowStride;
         }
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}


/**
 * Do texstore for 2-channel, 16-bit/channel, unsigned normalized formats.
 */
static GLboolean
_mesa_texstore_unorm1616(TEXSTORE_PARAMS)
{
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_L16A16_UNORM ||
          dstFormat == MESA_FORMAT_A16L16_UNORM ||
	  dstFormat == MESA_FORMAT_R16G16_UNORM ||
          dstFormat == MESA_FORMAT_G16R16_UNORM);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 4);

   {
      /* general path */
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *src = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLuint *dstUI = (GLuint *) dstRow;
            if (dstFormat == MESA_FORMAT_L16A16_UNORM ||
		dstFormat == MESA_FORMAT_R16G16_UNORM) {
               for (col = 0; col < srcWidth; col++) {
		  GLushort l, a;

		  UNCLAMPED_FLOAT_TO_USHORT(l, src[0]);
		  UNCLAMPED_FLOAT_TO_USHORT(a, src[1]);
		  dstUI[col] = PACK_COLOR_1616(a, l);
		  src += 2;
               }
            }
            else {
               for (col = 0; col < srcWidth; col++) {
		  GLushort l, a;

		  UNCLAMPED_FLOAT_TO_USHORT(l, src[0]);
		  UNCLAMPED_FLOAT_TO_USHORT(a, src[1]);
		  dstUI[col] = PACK_COLOR_1616_REV(a, l);
		  src += 2;
               }
            }
            dstRow += dstRowStride;
         }
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}


/* Texstore for R16, A16, L16, I16. */
static GLboolean
_mesa_texstore_unorm16(TEXSTORE_PARAMS)
{
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_R_UNORM16 ||
          dstFormat == MESA_FORMAT_A_UNORM16 ||
          dstFormat == MESA_FORMAT_L_UNORM16 ||
          dstFormat == MESA_FORMAT_I_UNORM16);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 2);

   {
      /* general path */
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *src = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLushort *dstUS = (GLushort *) dstRow;
	    for (col = 0; col < srcWidth; col++) {
	       GLushort r;

	       UNCLAMPED_FLOAT_TO_USHORT(r, src[0]);
	       dstUS[col] = r;
	       src += 1;
	    }
            dstRow += dstRowStride;
         }
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}


static GLboolean
_mesa_texstore_rgba_16(TEXSTORE_PARAMS)
{
   ASSERT(dstFormat == MESA_FORMAT_RGBA_UNORM16 ||
          dstFormat == MESA_FORMAT_RGBX_UNORM16);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 8);

   {
      /* general path */
      /* Hardcode GL_RGBA as the base format, which forces alpha to 1.0
       * if the internal format is RGB. */
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 GL_RGBA,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *src = tempImage;
      GLint img, row, col;

      if (!tempImage)
         return GL_FALSE;

      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLushort *dstUS = (GLushort *) dstRow;
            for (col = 0; col < srcWidth; col++) {
               GLushort r, g, b, a;

               UNCLAMPED_FLOAT_TO_USHORT(r, src[0]);
               UNCLAMPED_FLOAT_TO_USHORT(g, src[1]);
               UNCLAMPED_FLOAT_TO_USHORT(b, src[2]);
               UNCLAMPED_FLOAT_TO_USHORT(a, src[3]);
               dstUS[col*4+0] = r;
               dstUS[col*4+1] = g;
               dstUS[col*4+2] = b;
               dstUS[col*4+3] = a;
               src += 4;
            }
            dstRow += dstRowStride;
         }
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}


static GLboolean
_mesa_texstore_signed_rgba_16(TEXSTORE_PARAMS)
{
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_RGB_SNORM16 ||
          dstFormat == MESA_FORMAT_RGBA_SNORM16 ||
          dstFormat == MESA_FORMAT_RGBX_SNORM16);

   {
      /* general path */
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *src = tempImage;
      const GLuint comps = _mesa_get_format_bytes(dstFormat) / 2;
      GLint img, row, col;

      if (!tempImage)
         return GL_FALSE;

      /* Note: tempImage is always float[4] / RGBA.  We convert to 1, 2,
       * 3 or 4 components/pixel here.
       */
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLshort *dstRowS = (GLshort *) dstRow;
            if (dstFormat == MESA_FORMAT_RGBA_SNORM16) {
               for (col = 0; col < srcWidth; col++) {
                  GLuint c;
                  for (c = 0; c < comps; c++) {
                     GLshort p;
                     UNCLAMPED_FLOAT_TO_SHORT(p, src[col * 4 + c]);
                     dstRowS[col * comps + c] = p;
                  }
               }
               dstRow += dstRowStride;
               src += 4 * srcWidth;
            }
            else if (dstFormat == MESA_FORMAT_RGBX_SNORM16) {
               for (col = 0; col < srcWidth; col++) {
                  GLuint c;

                  for (c = 0; c < 3; c++) {
                     GLshort p;
                     UNCLAMPED_FLOAT_TO_SHORT(p, src[col * 3 + c]);
                     dstRowS[col * comps + c] = p;
                  }
                  dstRowS[col * comps + 3] = 32767;
               }
               dstRow += dstRowStride;
               src += 3 * srcWidth;
            }
            else {
               for (col = 0; col < srcWidth; col++) {
                  GLuint c;
                  for (c = 0; c < comps; c++) {
                     GLshort p;
                     UNCLAMPED_FLOAT_TO_SHORT(p, src[col * 3 + c]);
                     dstRowS[col * comps + c] = p;
                  }
               }
               dstRow += dstRowStride;
               src += 3 * srcWidth;
            }
         }
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}


/**
 * Texstore for _mesa_texformat_a8, _mesa_texformat_l8, _mesa_texformat_i8.
 */
static GLboolean
_mesa_texstore_unorm8(TEXSTORE_PARAMS)
{
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_A_UNORM8 ||
          dstFormat == MESA_FORMAT_L_UNORM8 ||
          dstFormat == MESA_FORMAT_I_UNORM8 ||
          dstFormat == MESA_FORMAT_R_UNORM8);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 1);

   if (!ctx->_ImageTransferState &&
       srcType == GL_UNSIGNED_BYTE &&
       can_swizzle(baseInternalFormat) &&
       can_swizzle(srcFormat)) {
      GLubyte dstmap[4];

      /* dstmap - how to swizzle from RGBA to dst format:
       */
      if (dstFormat == MESA_FORMAT_A_UNORM8) {
	 dstmap[0] = 3;
      }
      else {
	 dstmap[0] = 0;
      }
      dstmap[1] = ZERO;		/* ? */
      dstmap[2] = ZERO;		/* ? */
      dstmap[3] = ONE;		/* ? */
      
      _mesa_swizzle_ubyte_image(ctx, dims,
				srcFormat,
				srcType,
				baseInternalFormat,
				dstmap, 1,
				dstRowStride, dstSlices,
				srcWidth, srcHeight, srcDepth, srcAddr,
				srcPacking);      
   }   
   else {
      /* general path */
      const GLubyte *tempImage = _mesa_make_temp_ubyte_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking);
      const GLubyte *src = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            for (col = 0; col < srcWidth; col++) {
               dstRow[col] = src[col];
            }
            dstRow += dstRowStride;
            src += srcWidth;
         }
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}



/**
 * Texstore for _mesa_texformat_ycbcr or _mesa_texformat_ycbcr_REV.
 */
static GLboolean
_mesa_texstore_ycbcr(TEXSTORE_PARAMS)
{
   const GLboolean littleEndian = _mesa_little_endian();

   (void) ctx; (void) dims; (void) baseInternalFormat;

   ASSERT((dstFormat == MESA_FORMAT_YCBCR) ||
          (dstFormat == MESA_FORMAT_YCBCR_REV));
   ASSERT(_mesa_get_format_bytes(dstFormat) == 2);
   ASSERT(ctx->Extensions.MESA_ycbcr_texture);
   ASSERT(srcFormat == GL_YCBCR_MESA);
   ASSERT((srcType == GL_UNSIGNED_SHORT_8_8_MESA) ||
          (srcType == GL_UNSIGNED_SHORT_8_8_REV_MESA));
   ASSERT(baseInternalFormat == GL_YCBCR_MESA);

   /* always just memcpy since no pixel transfer ops apply */
   memcpy_texture(ctx, dims,
                  dstFormat,
                  dstRowStride, dstSlices,
                  srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                  srcAddr, srcPacking);

   /* Check if we need byte swapping */
   /* XXX the logic here _might_ be wrong */
   if (srcPacking->SwapBytes ^
       (srcType == GL_UNSIGNED_SHORT_8_8_REV_MESA) ^
       (dstFormat == MESA_FORMAT_YCBCR_REV) ^
       !littleEndian) {
      GLint img, row;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            _mesa_swap2((GLushort *) dstRow, srcWidth);
            dstRow += dstRowStride;
         }
      }
   }
   return GL_TRUE;
}

static GLboolean
_mesa_texstore_dudv8(TEXSTORE_PARAMS)
{
   const GLboolean littleEndian = _mesa_little_endian();
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_DUDV8);
   ASSERT(texelBytes == 2);
   ASSERT(ctx->Extensions.ATI_envmap_bumpmap);
   ASSERT((srcFormat == GL_DU8DV8_ATI) ||
	  (srcFormat == GL_DUDV_ATI));
   ASSERT(baseInternalFormat == GL_DUDV_ATI);

   if (srcType == GL_BYTE) {
      GLubyte dstmap[4];

      /* dstmap - how to swizzle from RGBA to dst format:
       */
      if (littleEndian) {
	 dstmap[0] = 0;
	 dstmap[1] = 3;
      }
      else {
	 dstmap[0] = 3;
	 dstmap[1] = 0;
      }
      dstmap[2] = ZERO;		/* ? */
      dstmap[3] = ONE;		/* ? */
      
      _mesa_swizzle_ubyte_image(ctx, dims,
				GL_LUMINANCE_ALPHA, /* hack */
				GL_UNSIGNED_BYTE, /* hack */
				GL_LUMINANCE_ALPHA, /* hack */
				dstmap, 2,
				dstRowStride, dstSlices,
				srcWidth, srcHeight, srcDepth, srcAddr,
				srcPacking);      
   }   
   else {
      /* general path - note this is defined for 2d textures only */
      const GLint components = _mesa_components_in_format(baseInternalFormat);
      const GLint srcStride = _mesa_image_row_stride(srcPacking, srcWidth,
                                                     srcFormat, srcType);
      GLbyte *tempImage, *dst, *src;
      GLint row;

      tempImage = malloc(srcWidth * srcHeight * srcDepth
                                          * components * sizeof(GLbyte));
      if (!tempImage)
         return GL_FALSE;

      src = (GLbyte *) _mesa_image_address(dims, srcPacking, srcAddr,
                                           srcWidth, srcHeight,
                                           srcFormat, srcType,
                                           0, 0, 0);

      dst = tempImage;
      for (row = 0; row < srcHeight; row++) {
         _mesa_unpack_dudv_span_byte(ctx, srcWidth, baseInternalFormat,
                                     dst, srcFormat, srcType, src,
                                     srcPacking, 0);
         dst += srcWidth * components;
         src += srcStride;
      }
 
      src = tempImage;
      dst = (GLbyte *) dstSlices[0];
      for (row = 0; row < srcHeight; row++) {
         memcpy(dst, src, srcWidth * texelBytes);
         dst += dstRowStride;
         src += srcWidth * texelBytes;
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}


/**
 * Store a texture in a signed normalized 8-bit format.
 */
static GLboolean
_mesa_texstore_snorm8(TEXSTORE_PARAMS)
{
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_A_SNORM8 ||
          dstFormat == MESA_FORMAT_L_SNORM8 ||
          dstFormat == MESA_FORMAT_I_SNORM8 ||
          dstFormat == MESA_FORMAT_R_SNORM8);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 1);

   {
      /* general path */
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *src = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLbyte *dstRow = (GLbyte *) dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            for (col = 0; col < srcWidth; col++) {
               dstRow[col] = FLOAT_TO_BYTE_TEX(src[col]);
            }
            dstRow += dstRowStride;
            src += srcWidth;
         }
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}


/**
 * Store a texture in a signed normalized two-channel 16-bit format.
 */
static GLboolean
_mesa_texstore_snorm88(TEXSTORE_PARAMS)
{
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_L8A8_SNORM ||
          dstFormat == MESA_FORMAT_G8R8_SNORM ||
          dstFormat == MESA_FORMAT_R8G8_SNORM);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 2);

   {
      /* general path */
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *src = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLbyte *dstRow = (GLbyte *) dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLushort *dst = (GLushort *) dstRow;

            if (dstFormat == MESA_FORMAT_L8A8_SNORM ||
                dstFormat == MESA_FORMAT_R8G8_SNORM) {
               for (col = 0; col < srcWidth; col++) {
                  GLubyte l = FLOAT_TO_BYTE_TEX(src[0]);
                  GLubyte a = FLOAT_TO_BYTE_TEX(src[1]);

                  dst[col] = PACK_COLOR_88_REV(l, a);
                  src += 2;
               }
            } else {
               for (col = 0; col < srcWidth; col++) {
                  GLubyte l = FLOAT_TO_BYTE_TEX(src[0]);
                  GLubyte a = FLOAT_TO_BYTE_TEX(src[1]);

                  dst[col] = PACK_COLOR_88(l, a);
                  src += 2;
               }
            }

            dstRow += dstRowStride;
         }
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}

/* Texstore for signed R16, A16, L16, I16. */
static GLboolean
_mesa_texstore_snorm16(TEXSTORE_PARAMS)
{
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_R_SNORM16 ||
          dstFormat == MESA_FORMAT_A_SNORM16 ||
          dstFormat == MESA_FORMAT_L_SNORM16 ||
          dstFormat == MESA_FORMAT_I_SNORM16);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 2);

   {
      /* general path */
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *src = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLshort *dstUS = (GLshort *) dstRow;
	    for (col = 0; col < srcWidth; col++) {
	       GLushort r;

	       UNCLAMPED_FLOAT_TO_SHORT(r, src[0]);
	       dstUS[col] = r;
	       src += 1;
	    }
            dstRow += dstRowStride;
         }
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}

/**
 * Do texstore for 2-channel, 16-bit/channel, signed normalized formats.
 */
static GLboolean
_mesa_texstore_snorm1616(TEXSTORE_PARAMS)
{
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_LA_SNORM16 ||
          dstFormat == MESA_FORMAT_G16R16_SNORM ||
          dstFormat == MESA_FORMAT_R16G16_SNORM);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 4);

   {
      /* general path */
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *src = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLuint *dst = (GLuint *) dstRow;

            if (dstFormat == MESA_FORMAT_LA_SNORM16 ||
                dstFormat == MESA_FORMAT_R16G16_SNORM) {
               for (col = 0; col < srcWidth; col++) {
                  GLushort l, a;

                  UNCLAMPED_FLOAT_TO_SHORT(l, src[0]);
                  UNCLAMPED_FLOAT_TO_SHORT(a, src[1]);
                  dst[col] = PACK_COLOR_1616_REV(l, a);
                  src += 2;
               }
            } else {
               for (col = 0; col < srcWidth; col++) {
                  GLushort l, a;

                  UNCLAMPED_FLOAT_TO_SHORT(l, src[0]);
                  UNCLAMPED_FLOAT_TO_SHORT(a, src[1]);
                  dst[col] = PACK_COLOR_1616_REV(l, a);
                  src += 2;
               }
            }

            dstRow += dstRowStride;
         }
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}

/**
 * Store a texture in MESA_FORMAT_X8B8G8R8_SNORM or
 * MESA_FORMAT_R8G8B8X8_SNORM.
 */
static GLboolean
_mesa_texstore_signed_rgbx8888(TEXSTORE_PARAMS)
{
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_X8B8G8R8_SNORM ||
          dstFormat == MESA_FORMAT_R8G8B8X8_SNORM);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 4);

   {
      /* general path */
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *srcRow = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLbyte *dstRow = (GLbyte *) dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLbyte *dst = dstRow;
            if (dstFormat == MESA_FORMAT_X8B8G8R8_SNORM) {
               for (col = 0; col < srcWidth; col++) {
                  dst[3] = FLOAT_TO_BYTE_TEX(srcRow[RCOMP]);
                  dst[2] = FLOAT_TO_BYTE_TEX(srcRow[GCOMP]);
                  dst[1] = FLOAT_TO_BYTE_TEX(srcRow[BCOMP]);
                  dst[0] = 127;
                  srcRow += 3;
                  dst += 4;
               }
            }
            else {
               for (col = 0; col < srcWidth; col++) {
                  dst[0] = FLOAT_TO_BYTE_TEX(srcRow[RCOMP]);
                  dst[1] = FLOAT_TO_BYTE_TEX(srcRow[GCOMP]);
                  dst[2] = FLOAT_TO_BYTE_TEX(srcRow[BCOMP]);
                  dst[3] = 127;
                  srcRow += 3;
                  dst += 4;
               }
            }
            dstRow += dstRowStride;
         }
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}



/**
 * Store a texture in MESA_FORMAT_A8B8G8R8_SNORM or
 * MESA_FORMAT_R8G8B8A8_SNORM
 */
static GLboolean
_mesa_texstore_signed_rgba8888(TEXSTORE_PARAMS)
{
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_A8B8G8R8_SNORM ||
          dstFormat == MESA_FORMAT_R8G8B8A8_SNORM);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 4);

   {
      /* general path */
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *srcRow = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLbyte *dstRow = (GLbyte *) dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLbyte *dst = dstRow;
            if (dstFormat == MESA_FORMAT_A8B8G8R8_SNORM) {
               for (col = 0; col < srcWidth; col++) {
                  dst[3] = FLOAT_TO_BYTE_TEX(srcRow[RCOMP]);
                  dst[2] = FLOAT_TO_BYTE_TEX(srcRow[GCOMP]);
                  dst[1] = FLOAT_TO_BYTE_TEX(srcRow[BCOMP]);
                  dst[0] = FLOAT_TO_BYTE_TEX(srcRow[ACOMP]);
                  srcRow += 4;
                  dst += 4;
               }
            }
            else {
               for (col = 0; col < srcWidth; col++) {
                  dst[0] = FLOAT_TO_BYTE_TEX(srcRow[RCOMP]);
                  dst[1] = FLOAT_TO_BYTE_TEX(srcRow[GCOMP]);
                  dst[2] = FLOAT_TO_BYTE_TEX(srcRow[BCOMP]);
                  dst[3] = FLOAT_TO_BYTE_TEX(srcRow[ACOMP]);
                  srcRow += 4;
                  dst += 4;
               }
            }
            dstRow += dstRowStride;
         }
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}


/**
 * Store a combined depth/stencil texture image.
 */
static GLboolean
_mesa_texstore_z24_s8(TEXSTORE_PARAMS)
{
   const GLuint depthScale = 0xffffff;
   const GLint srcRowStride
      = _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType);
   GLint img, row;
   GLuint *depth = malloc(srcWidth * sizeof(GLuint));
   GLubyte *stencil = malloc(srcWidth * sizeof(GLubyte));

   ASSERT(dstFormat == MESA_FORMAT_S8_UINT_Z24_UNORM);
   ASSERT(srcFormat == GL_DEPTH_STENCIL_EXT ||
          srcFormat == GL_DEPTH_COMPONENT ||
          srcFormat == GL_STENCIL_INDEX);
   ASSERT(srcFormat != GL_DEPTH_STENCIL_EXT ||
          srcType == GL_UNSIGNED_INT_24_8_EXT ||
          srcType == GL_FLOAT_32_UNSIGNED_INT_24_8_REV);

   if (!depth || !stencil) {
      free(depth);
      free(stencil);
      return GL_FALSE;
   }

   /* In case we only upload depth we need to preserve the stencil */
   for (img = 0; img < srcDepth; img++) {
      GLuint *dstRow = (GLuint *) dstSlices[img];
      const GLubyte *src
         = (const GLubyte *) _mesa_image_address(dims, srcPacking, srcAddr,
               srcWidth, srcHeight,
               srcFormat, srcType,
               img, 0, 0);
      for (row = 0; row < srcHeight; row++) {
         GLint i;
         GLboolean keepdepth = GL_FALSE, keepstencil = GL_FALSE;

         if (srcFormat == GL_DEPTH_COMPONENT) { /* preserve stencil */
            keepstencil = GL_TRUE;
         }
         else if (srcFormat == GL_STENCIL_INDEX) { /* preserve depth */
            keepdepth = GL_TRUE;
         }

         if (keepdepth == GL_FALSE)
            /* the 24 depth bits will be in the low position: */
            _mesa_unpack_depth_span(ctx, srcWidth,
                                    GL_UNSIGNED_INT, /* dst type */
                                    keepstencil ? depth : dstRow, /* dst addr */
                                    depthScale,
                                    srcType, src, srcPacking);

         if (keepstencil == GL_FALSE)
            /* get the 8-bit stencil values */
            _mesa_unpack_stencil_span(ctx, srcWidth,
                                      GL_UNSIGNED_BYTE, /* dst type */
                                      stencil, /* dst addr */
                                      srcType, src, srcPacking,
                                      ctx->_ImageTransferState);

         for (i = 0; i < srcWidth; i++) {
            if (keepstencil)
               dstRow[i] = depth[i] << 8 | (dstRow[i] & 0x000000FF);
            else
               dstRow[i] = (dstRow[i] & 0xFFFFFF00) | (stencil[i] & 0xFF);
         }
         src += srcRowStride;
         dstRow += dstRowStride / sizeof(GLuint);
      }
   }

   free(depth);
   free(stencil);
   return GL_TRUE;
}


/**
 * Store a combined depth/stencil texture image.
 */
static GLboolean
_mesa_texstore_s8_z24(TEXSTORE_PARAMS)
{
   const GLuint depthScale = 0xffffff;
   const GLint srcRowStride
      = _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType);
   GLint img, row;
   GLuint *depth;
   GLubyte *stencil;

   ASSERT(dstFormat == MESA_FORMAT_Z24_UNORM_S8_UINT);
   ASSERT(srcFormat == GL_DEPTH_STENCIL_EXT ||
          srcFormat == GL_DEPTH_COMPONENT ||
          srcFormat == GL_STENCIL_INDEX);
   ASSERT(srcFormat != GL_DEPTH_STENCIL_EXT ||
          srcType == GL_UNSIGNED_INT_24_8_EXT ||
          srcType == GL_FLOAT_32_UNSIGNED_INT_24_8_REV);

   depth = malloc(srcWidth * sizeof(GLuint));
   stencil = malloc(srcWidth * sizeof(GLubyte));

   if (!depth || !stencil) {
      free(depth);
      free(stencil);
      return GL_FALSE;
   }

   for (img = 0; img < srcDepth; img++) {
      GLuint *dstRow = (GLuint *) dstSlices[img];
      const GLubyte *src
	 = (const GLubyte *) _mesa_image_address(dims, srcPacking, srcAddr,
						srcWidth, srcHeight,
						srcFormat, srcType,
						img, 0, 0);
      for (row = 0; row < srcHeight; row++) {
	 GLint i;
	 GLboolean keepdepth = GL_FALSE, keepstencil = GL_FALSE;
	 
	 if (srcFormat == GL_DEPTH_COMPONENT) { /* preserve stencil */
	    keepstencil = GL_TRUE;
	 }
         else if (srcFormat == GL_STENCIL_INDEX) { /* preserve depth */
	    keepdepth = GL_TRUE;
	 }

	 if (keepdepth == GL_FALSE)
	    /* the 24 depth bits will be in the low position: */
	    _mesa_unpack_depth_span(ctx, srcWidth,
				    GL_UNSIGNED_INT, /* dst type */
				    keepstencil ? depth : dstRow, /* dst addr */
				    depthScale,
				    srcType, src, srcPacking);	 

	 if (keepstencil == GL_FALSE)
	    /* get the 8-bit stencil values */
	    _mesa_unpack_stencil_span(ctx, srcWidth,
				      GL_UNSIGNED_BYTE, /* dst type */
				      stencil, /* dst addr */
				      srcType, src, srcPacking,
				      ctx->_ImageTransferState);

	 /* merge stencil values into depth values */
	 for (i = 0; i < srcWidth; i++) {
	    if (keepstencil)
	       dstRow[i] = depth[i] | (dstRow[i] & 0xFF000000);
	    else
	       dstRow[i] = (dstRow[i] & 0xFFFFFF) | (stencil[i] << 24);

	 }
	 src += srcRowStride;
	 dstRow += dstRowStride / sizeof(GLuint);
      }
   }

   free(depth);
   free(stencil);

   return GL_TRUE;
}


/**
 * Store simple 8-bit/value stencil texture data.
 */
static GLboolean
_mesa_texstore_s8(TEXSTORE_PARAMS)
{
   ASSERT(dstFormat == MESA_FORMAT_S_UINT8);
   ASSERT(srcFormat == GL_STENCIL_INDEX);

   {
      const GLint srcRowStride
	 = _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType);
      GLint img, row;
      GLubyte *stencil = malloc(srcWidth * sizeof(GLubyte));

      if (!stencil)
         return GL_FALSE;

      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         const GLubyte *src
            = (const GLubyte *) _mesa_image_address(dims, srcPacking, srcAddr,
                                                   srcWidth, srcHeight,
                                                   srcFormat, srcType,
                                                   img, 0, 0);
         for (row = 0; row < srcHeight; row++) {
            GLint i;

            /* get the 8-bit stencil values */
            _mesa_unpack_stencil_span(ctx, srcWidth,
                                      GL_UNSIGNED_BYTE, /* dst type */
                                      stencil, /* dst addr */
                                      srcType, src, srcPacking,
                                      ctx->_ImageTransferState);
            /* merge stencil values into depth values */
            for (i = 0; i < srcWidth; i++)
               dstRow[i] = stencil[i];

            src += srcRowStride;
            dstRow += dstRowStride / sizeof(GLubyte);
         }
      }

      free(stencil);
   }

   return GL_TRUE;
}


/**
 * Store an image in any of the formats:
 *   _mesa_texformat_rgba_float32
 *   _mesa_texformat_rgb_float32
 *   _mesa_texformat_alpha_float32
 *   _mesa_texformat_luminance_float32
 *   _mesa_texformat_luminance_alpha_float32
 *   _mesa_texformat_intensity_float32
 */
static GLboolean
_mesa_texstore_rgba_float32(TEXSTORE_PARAMS)
{
   GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
   GLint components = _mesa_components_in_format(baseFormat);

   /* this forces alpha to 1 in _mesa_make_temp_float_image */
   if (dstFormat == MESA_FORMAT_RGBX_FLOAT32) {
      baseFormat = GL_RGBA;
      components = 4;
   }

   ASSERT(dstFormat == MESA_FORMAT_RGBA_FLOAT32 ||
          dstFormat == MESA_FORMAT_RGB_FLOAT32 ||
          dstFormat == MESA_FORMAT_A_FLOAT32 ||
          dstFormat == MESA_FORMAT_L_FLOAT32 ||
          dstFormat == MESA_FORMAT_LA_FLOAT32 ||
          dstFormat == MESA_FORMAT_I_FLOAT32 ||
          dstFormat == MESA_FORMAT_R_FLOAT32 ||
          dstFormat == MESA_FORMAT_RG_FLOAT32 ||
          dstFormat == MESA_FORMAT_RGBX_FLOAT32);
   ASSERT(baseInternalFormat == GL_RGBA ||
          baseInternalFormat == GL_RGB ||
          baseInternalFormat == GL_ALPHA ||
          baseInternalFormat == GL_LUMINANCE ||
          baseInternalFormat == GL_LUMINANCE_ALPHA ||
          baseInternalFormat == GL_INTENSITY ||
          baseInternalFormat == GL_RED ||
          baseInternalFormat == GL_RG);
   ASSERT(_mesa_get_format_bytes(dstFormat) == components * sizeof(GLfloat));

   {
      /* general path */
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *srcRow = tempImage;
      GLint bytesPerRow;
      GLint img, row;
      if (!tempImage)
         return GL_FALSE;
      bytesPerRow = srcWidth * components * sizeof(GLfloat);
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            memcpy(dstRow, srcRow, bytesPerRow);
            dstRow += dstRowStride;
            srcRow += srcWidth * components;
         }
      }

      free((void *) tempImage);
   }
   return GL_TRUE;
}



/**
 * As above, but store 16-bit floats.
 */
static GLboolean
_mesa_texstore_rgba_float16(TEXSTORE_PARAMS)
{
   GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
   GLint components = _mesa_components_in_format(baseFormat);

   /* this forces alpha to 1 in _mesa_make_temp_float_image */
   if (dstFormat == MESA_FORMAT_RGBX_FLOAT16) {
      baseFormat = GL_RGBA;
      components = 4;
   }

   ASSERT(dstFormat == MESA_FORMAT_RGBA_FLOAT16 ||
          dstFormat == MESA_FORMAT_RGB_FLOAT16 ||
          dstFormat == MESA_FORMAT_A_FLOAT16 ||
          dstFormat == MESA_FORMAT_L_FLOAT16 ||
          dstFormat == MESA_FORMAT_LA_FLOAT16 ||
          dstFormat == MESA_FORMAT_I_FLOAT16 ||
          dstFormat == MESA_FORMAT_R_FLOAT16 ||
          dstFormat == MESA_FORMAT_RG_FLOAT16 ||
          dstFormat == MESA_FORMAT_RGBX_FLOAT16);
   ASSERT(baseInternalFormat == GL_RGBA ||
          baseInternalFormat == GL_RGB ||
          baseInternalFormat == GL_ALPHA ||
          baseInternalFormat == GL_LUMINANCE ||
          baseInternalFormat == GL_LUMINANCE_ALPHA ||
          baseInternalFormat == GL_INTENSITY ||
          baseInternalFormat == GL_RED ||
          baseInternalFormat == GL_RG);
   ASSERT(_mesa_get_format_bytes(dstFormat) == components * sizeof(GLhalfARB));

   {
      /* general path */
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *src = tempImage;
      GLint img, row;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLhalfARB *dstTexel = (GLhalfARB *) dstRow;
            GLint i;
            for (i = 0; i < srcWidth * components; i++) {
               dstTexel[i] = _mesa_float_to_half(src[i]);
            }
            dstRow += dstRowStride;
            src += srcWidth * components;
         }
      }

      free((void *) tempImage);
   }
   return GL_TRUE;
}


/* non-normalized, signed int8 */
static GLboolean
_mesa_texstore_rgba_int8(TEXSTORE_PARAMS)
{
   GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
   GLint components = _mesa_components_in_format(baseFormat);

   /* this forces alpha to 1 in make_temp_uint_image */
   if (dstFormat == MESA_FORMAT_RGBX_SINT8) {
      baseFormat = GL_RGBA;
      components = 4;
   }

   ASSERT(dstFormat == MESA_FORMAT_R_SINT8 ||
          dstFormat == MESA_FORMAT_RG_SINT8 ||
          dstFormat == MESA_FORMAT_RGB_SINT8 ||
          dstFormat == MESA_FORMAT_RGBA_SINT8 ||
          dstFormat == MESA_FORMAT_A_SINT8 ||
          dstFormat == MESA_FORMAT_I_SINT8 ||
          dstFormat == MESA_FORMAT_L_SINT8 ||
          dstFormat == MESA_FORMAT_LA_SINT8 ||
          dstFormat == MESA_FORMAT_RGBX_SINT8);
   ASSERT(baseInternalFormat == GL_RGBA ||
          baseInternalFormat == GL_RGB ||
          baseInternalFormat == GL_RG ||
          baseInternalFormat == GL_RED ||
          baseInternalFormat == GL_ALPHA ||
          baseInternalFormat == GL_LUMINANCE ||
          baseInternalFormat == GL_LUMINANCE_ALPHA ||
          baseInternalFormat == GL_INTENSITY);
   ASSERT(_mesa_get_format_bytes(dstFormat) == components * sizeof(GLbyte));

   {
      /* general path */
      const GLuint *tempImage = make_temp_uint_image(ctx, dims,
						     baseInternalFormat,
						     baseFormat,
						     srcWidth, srcHeight, srcDepth,
						     srcFormat, srcType,
						     srcAddr,
						     srcPacking);
      const GLuint *src = tempImage;
      GLint img, row;
      GLboolean is_unsigned = _mesa_is_type_unsigned(srcType);
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLbyte *dstTexel = (GLbyte *) dstRow;
            GLint i;
            if (is_unsigned) {
               for (i = 0; i < srcWidth * components; i++) {
                  dstTexel[i] = (GLbyte) MIN2(src[i], 0x7f);
               }
            } else {
               for (i = 0; i < srcWidth * components; i++) {
                  dstTexel[i] = (GLbyte) CLAMP((GLint) src[i], -0x80, 0x7f);
               }
            }
            dstRow += dstRowStride;
            src += srcWidth * components;
         }
      }

      free((void *) tempImage);
   }
   return GL_TRUE;
}


/* non-normalized, signed int16 */
static GLboolean
_mesa_texstore_rgba_int16(TEXSTORE_PARAMS)
{
   GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
   GLint components = _mesa_components_in_format(baseFormat);

   /* this forces alpha to 1 in make_temp_uint_image */
   if (dstFormat == MESA_FORMAT_RGBX_SINT16) {
      baseFormat = GL_RGBA;
      components = 4;
   }

   ASSERT(dstFormat == MESA_FORMAT_R_SINT16 ||
          dstFormat == MESA_FORMAT_RG_SINT16 ||
          dstFormat == MESA_FORMAT_RGB_SINT16 ||
          dstFormat == MESA_FORMAT_RGBA_SINT16 ||
          dstFormat == MESA_FORMAT_A_SINT16 ||
          dstFormat == MESA_FORMAT_L_SINT16 ||
          dstFormat == MESA_FORMAT_I_SINT16 ||
          dstFormat == MESA_FORMAT_LA_SINT16 ||
          dstFormat == MESA_FORMAT_RGBX_SINT16);
   ASSERT(baseInternalFormat == GL_RGBA ||
          baseInternalFormat == GL_RGB ||
          baseInternalFormat == GL_RG ||
          baseInternalFormat == GL_RED ||
          baseInternalFormat == GL_ALPHA ||
          baseInternalFormat == GL_LUMINANCE ||
          baseInternalFormat == GL_LUMINANCE_ALPHA ||
          baseInternalFormat == GL_INTENSITY);
   ASSERT(_mesa_get_format_bytes(dstFormat) == components * sizeof(GLshort));

   {
      /* general path */
      const GLuint *tempImage = make_temp_uint_image(ctx, dims,
						     baseInternalFormat,
						     baseFormat,
						     srcWidth, srcHeight, srcDepth,
						     srcFormat, srcType,
						     srcAddr,
						     srcPacking);
      const GLuint *src = tempImage;
      GLint img, row;
      GLboolean is_unsigned = _mesa_is_type_unsigned(srcType);
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLshort *dstTexel = (GLshort *) dstRow;
            GLint i;
            if (is_unsigned) {
               for (i = 0; i < srcWidth * components; i++) {
                  dstTexel[i] = (GLshort) MIN2(src[i], 0x7fff);
               }
            } else {
               for (i = 0; i < srcWidth * components; i++) {
                  dstTexel[i] = (GLshort)CLAMP((GLint) src[i], -0x8000, 0x7fff);
               }
            }
            dstRow += dstRowStride;
            src += srcWidth * components;
         }
      }

      free((void *) tempImage);
   }
   return GL_TRUE;
}


/* non-normalized, signed int32 */
static GLboolean
_mesa_texstore_rgba_int32(TEXSTORE_PARAMS)
{
   GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
   GLint components = _mesa_components_in_format(baseFormat);

   /* this forces alpha to 1 in make_temp_uint_image */
   if (dstFormat == MESA_FORMAT_RGBX_SINT32) {
      baseFormat = GL_RGBA;
      components = 4;
   }

   ASSERT(dstFormat == MESA_FORMAT_R_SINT32 ||
          dstFormat == MESA_FORMAT_RG_SINT32 ||
          dstFormat == MESA_FORMAT_RGB_SINT32 ||
          dstFormat == MESA_FORMAT_RGBA_SINT32 ||
          dstFormat == MESA_FORMAT_A_SINT32 ||
          dstFormat == MESA_FORMAT_I_SINT32 ||
          dstFormat == MESA_FORMAT_L_SINT32 ||
          dstFormat == MESA_FORMAT_LA_SINT32 ||
          dstFormat == MESA_FORMAT_RGBX_SINT32);
   ASSERT(baseInternalFormat == GL_RGBA ||
          baseInternalFormat == GL_RGB ||
          baseInternalFormat == GL_RG ||
          baseInternalFormat == GL_RED ||
          baseInternalFormat == GL_ALPHA ||
          baseInternalFormat == GL_LUMINANCE ||
          baseInternalFormat == GL_LUMINANCE_ALPHA ||
          baseInternalFormat == GL_INTENSITY);
   ASSERT(_mesa_get_format_bytes(dstFormat) == components * sizeof(GLint));

   {
      /* general path */
      const GLuint *tempImage = make_temp_uint_image(ctx, dims,
						     baseInternalFormat,
						     baseFormat,
						     srcWidth, srcHeight, srcDepth,
						     srcFormat, srcType,
						     srcAddr,
						     srcPacking);
      const GLuint *src = tempImage;
      GLint img, row;
      GLboolean is_unsigned = _mesa_is_type_unsigned(srcType);
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLint *dstTexel = (GLint *) dstRow;
            GLint i;
            if (is_unsigned) {
               for (i = 0; i < srcWidth * components; i++) {
                  dstTexel[i] = (GLint) MIN2(src[i], 0x7fffffff);
               }
            } else {
               for (i = 0; i < srcWidth * components; i++) {
                  dstTexel[i] = (GLint) src[i];
               }
            }
            dstRow += dstRowStride;
            src += srcWidth * components;
         }
      }

      free((void *) tempImage);
   }
   return GL_TRUE;
}


/* non-normalized, unsigned int8 */
static GLboolean
_mesa_texstore_rgba_uint8(TEXSTORE_PARAMS)
{
   GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
   GLint components = _mesa_components_in_format(baseFormat);

   /* this forces alpha to 1 in make_temp_uint_image */
   if (dstFormat == MESA_FORMAT_RGBX_UINT8) {
      baseFormat = GL_RGBA;
      components = 4;
   }

   ASSERT(dstFormat == MESA_FORMAT_R_UINT8 ||
          dstFormat == MESA_FORMAT_RG_UINT8 ||
          dstFormat == MESA_FORMAT_RGB_UINT8 ||
          dstFormat == MESA_FORMAT_RGBA_UINT8 ||
          dstFormat == MESA_FORMAT_A_UINT8 ||
          dstFormat == MESA_FORMAT_I_UINT8 ||
          dstFormat == MESA_FORMAT_L_UINT8 ||
          dstFormat == MESA_FORMAT_LA_UINT8 ||
          dstFormat == MESA_FORMAT_RGBX_UINT8);
   ASSERT(baseInternalFormat == GL_RGBA ||
          baseInternalFormat == GL_RGB ||
          baseInternalFormat == GL_RG ||
          baseInternalFormat == GL_RED ||
          baseInternalFormat == GL_ALPHA ||
          baseInternalFormat == GL_LUMINANCE ||
          baseInternalFormat == GL_LUMINANCE_ALPHA ||
          baseInternalFormat == GL_INTENSITY);
   ASSERT(_mesa_get_format_bytes(dstFormat) == components * sizeof(GLubyte));

   {
      /* general path */
      const GLuint *tempImage =
         make_temp_uint_image(ctx, dims, baseInternalFormat, baseFormat,
                              srcWidth, srcHeight, srcDepth,
                              srcFormat, srcType, srcAddr, srcPacking);
      const GLuint *src = tempImage;
      GLint img, row;
      GLboolean is_unsigned = _mesa_is_type_unsigned(srcType);
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLubyte *dstTexel = (GLubyte *) dstRow;
            GLint i;
            if (is_unsigned) {
               for (i = 0; i < srcWidth * components; i++) {
                  dstTexel[i] = (GLubyte) MIN2(src[i], 0xff);
               }
            } else {
               for (i = 0; i < srcWidth * components; i++) {
                  dstTexel[i] = (GLubyte) CLAMP((GLint) src[i], 0, 0xff);
               }
            }
            dstRow += dstRowStride;
            src += srcWidth * components;
         }
      }

      free((void *) tempImage);
   }
   return GL_TRUE;
}


/* non-normalized, unsigned int16 */
static GLboolean
_mesa_texstore_rgba_uint16(TEXSTORE_PARAMS)
{
   GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
   GLint components = _mesa_components_in_format(baseFormat);

   /* this forces alpha to 1 in make_temp_uint_image */
   if (dstFormat == MESA_FORMAT_RGBX_UINT16) {
      baseFormat = GL_RGBA;
      components = 4;
   }

   ASSERT(dstFormat == MESA_FORMAT_R_UINT16 ||
          dstFormat == MESA_FORMAT_RG_UINT16 ||
          dstFormat == MESA_FORMAT_RGB_UINT16 ||
          dstFormat == MESA_FORMAT_RGBA_UINT16 ||
          dstFormat == MESA_FORMAT_A_UINT16 ||
          dstFormat == MESA_FORMAT_I_UINT16 ||
          dstFormat == MESA_FORMAT_L_UINT16 ||
          dstFormat == MESA_FORMAT_LA_UINT16 ||
          dstFormat == MESA_FORMAT_RGBX_UINT16);
   ASSERT(baseInternalFormat == GL_RGBA ||
          baseInternalFormat == GL_RGB ||
          baseInternalFormat == GL_RG ||
          baseInternalFormat == GL_RED ||
          baseInternalFormat == GL_ALPHA ||
          baseInternalFormat == GL_LUMINANCE ||
          baseInternalFormat == GL_LUMINANCE_ALPHA ||
          baseInternalFormat == GL_INTENSITY);
   ASSERT(_mesa_get_format_bytes(dstFormat) == components * sizeof(GLushort));

   {
      /* general path */
      const GLuint *tempImage =
         make_temp_uint_image(ctx, dims, baseInternalFormat, baseFormat,
                              srcWidth, srcHeight, srcDepth,
                              srcFormat, srcType, srcAddr, srcPacking);
      const GLuint *src = tempImage;
      GLint img, row;
      GLboolean is_unsigned = _mesa_is_type_unsigned(srcType);
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLushort *dstTexel = (GLushort *) dstRow;
            GLint i;
            if (is_unsigned) {
               for (i = 0; i < srcWidth * components; i++) {
                  dstTexel[i] = (GLushort) MIN2(src[i], 0xffff);
              }
            } else {
               for (i = 0; i < srcWidth * components; i++) {
                  dstTexel[i] = (GLushort) CLAMP((GLint) src[i], 0, 0xffff);
               }
            }
            dstRow += dstRowStride;
            src += srcWidth * components;
         }
      }

      free((void *) tempImage);
   }
   return GL_TRUE;
}


/* non-normalized, unsigned int32 */
static GLboolean
_mesa_texstore_rgba_uint32(TEXSTORE_PARAMS)
{
   GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
   GLint components = _mesa_components_in_format(baseFormat);

   /* this forces alpha to 1 in make_temp_uint_image */
   if (dstFormat == MESA_FORMAT_RGBX_UINT32) {
      baseFormat = GL_RGBA;
      components = 4;
   }

   ASSERT(dstFormat == MESA_FORMAT_R_UINT32 ||
          dstFormat == MESA_FORMAT_RG_UINT32 ||
          dstFormat == MESA_FORMAT_RGB_UINT32 ||
          dstFormat == MESA_FORMAT_RGBA_UINT32 ||
          dstFormat == MESA_FORMAT_A_UINT32 ||
          dstFormat == MESA_FORMAT_I_UINT32 ||
          dstFormat == MESA_FORMAT_L_UINT32 ||
          dstFormat == MESA_FORMAT_LA_UINT32 ||
          dstFormat == MESA_FORMAT_RGBX_UINT32);
   ASSERT(baseInternalFormat == GL_RGBA ||
          baseInternalFormat == GL_RGB ||
          baseInternalFormat == GL_RG ||
          baseInternalFormat == GL_RED ||
          baseInternalFormat == GL_ALPHA ||
          baseInternalFormat == GL_LUMINANCE ||
          baseInternalFormat == GL_LUMINANCE_ALPHA ||
          baseInternalFormat == GL_INTENSITY);
   ASSERT(_mesa_get_format_bytes(dstFormat) == components * sizeof(GLuint));

   {
      /* general path */
      const GLuint *tempImage =
         make_temp_uint_image(ctx, dims, baseInternalFormat, baseFormat,
                              srcWidth, srcHeight, srcDepth,
                              srcFormat, srcType, srcAddr, srcPacking);
      const GLuint *src = tempImage;
      GLboolean is_unsigned = _mesa_is_type_unsigned(srcType);
      GLint img, row;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLuint *dstTexel = (GLuint *) dstRow;
            GLint i;
            if (is_unsigned) {
               for (i = 0; i < srcWidth * components; i++) {
                  dstTexel[i] = src[i];
               }
            } else {
               for (i = 0; i < srcWidth * components; i++) {
                  dstTexel[i] = MAX2((GLint) src[i], 0);
               }
            }
            dstRow += dstRowStride;
            src += srcWidth * components;
         }
      }

      free((void *) tempImage);
   }
   return GL_TRUE;
}


static GLboolean
_mesa_texstore_srgb8(TEXSTORE_PARAMS)
{
   mesa_format newDstFormat;
   GLboolean k;

   ASSERT(dstFormat == MESA_FORMAT_BGR_SRGB8);

   /* reuse normal rgb texstore code */
   newDstFormat = MESA_FORMAT_BGR_UNORM8;

   k = _mesa_texstore_rgb888(ctx, dims, baseInternalFormat,
                             newDstFormat,
                             dstRowStride, dstSlices,
                             srcWidth, srcHeight, srcDepth,
                             srcFormat, srcType,
                             srcAddr, srcPacking);
   return k;
}


static GLboolean
_mesa_texstore_srgba8(TEXSTORE_PARAMS)
{
   mesa_format newDstFormat;
   GLboolean k;

   ASSERT(dstFormat == MESA_FORMAT_A8B8G8R8_SRGB ||
          dstFormat == MESA_FORMAT_R8G8B8X8_SRGB ||
          dstFormat == MESA_FORMAT_R8G8B8A8_SRGB);

   newDstFormat = _mesa_get_srgb_format_linear(dstFormat);

   k = _mesa_texstore_rgba8888(ctx, dims, baseInternalFormat,
                               newDstFormat,
                               dstRowStride, dstSlices,
                               srcWidth, srcHeight, srcDepth,
                               srcFormat, srcType,
                               srcAddr, srcPacking);
   return k;
}


static GLboolean
_mesa_texstore_sargb8(TEXSTORE_PARAMS)
{
   mesa_format newDstFormat;
   GLboolean k;

   assert(dstFormat == MESA_FORMAT_B8G8R8A8_SRGB ||
          dstFormat == MESA_FORMAT_B8G8R8X8_SRGB);

   newDstFormat = _mesa_get_srgb_format_linear(dstFormat);

   k = _mesa_texstore_argb8888(ctx, dims, baseInternalFormat,
                               newDstFormat,
                               dstRowStride, dstSlices,
                               srcWidth, srcHeight, srcDepth,
                               srcFormat, srcType,
                               srcAddr, srcPacking);
   return k;
}


static GLboolean
_mesa_texstore_sl8(TEXSTORE_PARAMS)
{
   mesa_format newDstFormat;
   GLboolean k;

   ASSERT(dstFormat == MESA_FORMAT_L_SRGB8);

   newDstFormat = MESA_FORMAT_L_UNORM8;

   /* _mesa_textore_a8 handles luminance8 too */
   k = _mesa_texstore_unorm8(ctx, dims, baseInternalFormat,
                             newDstFormat,
                             dstRowStride, dstSlices,
                             srcWidth, srcHeight, srcDepth,
                             srcFormat, srcType,
                             srcAddr, srcPacking);
   return k;
}


static GLboolean
_mesa_texstore_sla8(TEXSTORE_PARAMS)
{
   mesa_format newDstFormat;
   GLboolean k;

   ASSERT(dstFormat == MESA_FORMAT_L8A8_SRGB);

   /* reuse normal luminance/alpha texstore code */
   newDstFormat = MESA_FORMAT_L8A8_UNORM;

   k = _mesa_texstore_unorm88(ctx, dims, baseInternalFormat,
			      newDstFormat,
			      dstRowStride, dstSlices,
			      srcWidth, srcHeight, srcDepth,
			      srcFormat, srcType,
			      srcAddr, srcPacking);
   return k;
}

static GLboolean
_mesa_texstore_rgb9_e5(TEXSTORE_PARAMS)
{
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_R9G9B9E5_FLOAT);
   ASSERT(baseInternalFormat == GL_RGB);

   {
      /* general path */
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *srcRow = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLuint *dstUI = (GLuint*)dstRow;
            for (col = 0; col < srcWidth; col++) {
               dstUI[col] = float3_to_rgb9e5(&srcRow[col * 3]);
            }
            dstRow += dstRowStride;
            srcRow += srcWidth * 3;
         }
      }

      free((void *) tempImage);
   }
   return GL_TRUE;
}

static GLboolean
_mesa_texstore_r11_g11_b10f(TEXSTORE_PARAMS)
{
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_R11G11B10_FLOAT);
   ASSERT(baseInternalFormat == GL_RGB);

   {
      /* general path */
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *srcRow = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLuint *dstUI = (GLuint*)dstRow;
            for (col = 0; col < srcWidth; col++) {
               dstUI[col] = float3_to_r11g11b10f(&srcRow[col * 3]);
            }
            dstRow += dstRowStride;
            srcRow += srcWidth * 3;
         }
      }

      free((void *) tempImage);
   }
   return GL_TRUE;
}


static GLboolean
_mesa_texstore_z32f_x24s8(TEXSTORE_PARAMS)
{
   GLint img, row;
   const GLint srcRowStride
      = _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType)
      / sizeof(uint64_t);

   ASSERT(dstFormat == MESA_FORMAT_Z32_FLOAT_S8X24_UINT);
   ASSERT(srcFormat == GL_DEPTH_STENCIL ||
          srcFormat == GL_DEPTH_COMPONENT ||
          srcFormat == GL_STENCIL_INDEX);
   ASSERT(srcFormat != GL_DEPTH_STENCIL ||
          srcType == GL_UNSIGNED_INT_24_8 ||
          srcType == GL_FLOAT_32_UNSIGNED_INT_24_8_REV);

   /* In case we only upload depth we need to preserve the stencil */
   for (img = 0; img < srcDepth; img++) {
      uint64_t *dstRow = (uint64_t *) dstSlices[img];
      const uint64_t *src
         = (const uint64_t *) _mesa_image_address(dims, srcPacking, srcAddr,
               srcWidth, srcHeight,
               srcFormat, srcType,
               img, 0, 0);
      for (row = 0; row < srcHeight; row++) {
         /* The unpack functions with:
          *    dstType = GL_FLOAT_32_UNSIGNED_INT_24_8_REV
          * only write their own dword, so the other dword (stencil
          * or depth) is preserved. */
         if (srcFormat != GL_STENCIL_INDEX)
            _mesa_unpack_depth_span(ctx, srcWidth,
                                    GL_FLOAT_32_UNSIGNED_INT_24_8_REV, /* dst type */
                                    dstRow, /* dst addr */
                                    ~0U, srcType, src, srcPacking);

         if (srcFormat != GL_DEPTH_COMPONENT)
            _mesa_unpack_stencil_span(ctx, srcWidth,
                                      GL_FLOAT_32_UNSIGNED_INT_24_8_REV, /* dst type */
                                      dstRow, /* dst addr */
                                      srcType, src, srcPacking,
                                      ctx->_ImageTransferState);

         src += srcRowStride;
         dstRow += dstRowStride / sizeof(uint64_t);
      }
   }
   return GL_TRUE;
}

static GLboolean
_mesa_texstore_argb2101010_uint(TEXSTORE_PARAMS)
{
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_B10G10R10A2_UINT);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 4);

   {
      /* general path */
      const GLuint *tempImage = make_temp_uint_image(ctx, dims,
                                                     baseInternalFormat,
                                                     baseFormat,
                                                     srcWidth, srcHeight,
                                                     srcDepth, srcFormat,
                                                     srcType, srcAddr,
                                                     srcPacking);
      const GLuint *src = tempImage;
      GLint img, row, col;
      GLboolean is_unsigned = _mesa_is_type_unsigned(srcType);
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];

         for (row = 0; row < srcHeight; row++) {
            GLuint *dstUI = (GLuint *) dstRow;
            if (is_unsigned) {
               for (col = 0; col < srcWidth; col++) {
                  GLushort a,r,g,b;
                  r = MIN2(src[RCOMP], 0x3ff);
                  g = MIN2(src[GCOMP], 0x3ff);
                  b = MIN2(src[BCOMP], 0x3ff);
                  a = MIN2(src[ACOMP], 0x003);
                  dstUI[col] = (a << 30) | (r << 20) | (g << 10) | (b);
                  src += 4;
               }
            } else {
               for (col = 0; col < srcWidth; col++) {
                  GLushort a,r,g,b;
                  r = CLAMP((GLint) src[RCOMP], 0, 0x3ff);
                  g = CLAMP((GLint) src[GCOMP], 0, 0x3ff);
                  b = CLAMP((GLint) src[BCOMP], 0, 0x3ff);
                  a = CLAMP((GLint) src[ACOMP], 0, 0x003);
                  dstUI[col] = (a << 30) | (r << 20) | (g << 10) | (b);
                  src += 4;
               }
            }
            dstRow += dstRowStride;
         }
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}

static GLboolean
_mesa_texstore_abgr2101010_uint(TEXSTORE_PARAMS)
{
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_R10G10B10A2_UINT);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 4);

   {
      /* general path */
      const GLuint *tempImage = make_temp_uint_image(ctx, dims,
                                                     baseInternalFormat,
                                                     baseFormat,
                                                     srcWidth, srcHeight,
                                                     srcDepth, srcFormat,
                                                     srcType, srcAddr,
                                                     srcPacking);
      const GLuint *src = tempImage;
      GLint img, row, col;
      GLboolean is_unsigned = _mesa_is_type_unsigned(srcType);
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];

         for (row = 0; row < srcHeight; row++) {
            GLuint *dstUI = (GLuint *) dstRow;
            if (is_unsigned) {
               for (col = 0; col < srcWidth; col++) {
                  GLushort a,r,g,b;
                  r = MIN2(src[RCOMP], 0x3ff);
                  g = MIN2(src[GCOMP], 0x3ff);
                  b = MIN2(src[BCOMP], 0x3ff);
                  a = MIN2(src[ACOMP], 0x003);
                  dstUI[col] = (a << 30) | (b << 20) | (g << 10) | (r);
                  src += 4;
               }
            } else {
               for (col = 0; col < srcWidth; col++) {
                  GLushort a,r,g,b;
                  r = CLAMP((GLint) src[RCOMP], 0, 0x3ff);
                  g = CLAMP((GLint) src[GCOMP], 0, 0x3ff);
                  b = CLAMP((GLint) src[BCOMP], 0, 0x3ff);
                  a = CLAMP((GLint) src[ACOMP], 0, 0x003);
                  dstUI[col] = (a << 30) | (b << 20) | (g << 10) | (r);
                  src += 4;
               }
            }
            dstRow += dstRowStride;
         }
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}

static GLboolean
_mesa_texstore_abgr2101010(TEXSTORE_PARAMS)
{
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_R10G10B10A2_UNORM);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 4);

   {
      /* general path */
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *src = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];

         for (row = 0; row < srcHeight; row++) {
            GLuint *dstUI = (GLuint *) dstRow;
            for (col = 0; col < srcWidth; col++) {
               GLushort a,r,g,b;

               UNCLAMPED_FLOAT_TO_USHORT(a, src[ACOMP]);
               UNCLAMPED_FLOAT_TO_USHORT(r, src[RCOMP]);
               UNCLAMPED_FLOAT_TO_USHORT(g, src[GCOMP]);
               UNCLAMPED_FLOAT_TO_USHORT(b, src[BCOMP]);
               dstUI[col] = PACK_COLOR_2101010_US(a, b, g, r);
               src += 4;
            }
            dstRow += dstRowStride;
         }
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}

static GLboolean
_mesa_texstore_null(TEXSTORE_PARAMS)
{
   (void) ctx; (void) dims;
   (void) baseInternalFormat;
   (void) dstFormat;
   (void) dstRowStride; (void) dstSlices,
   (void) srcWidth; (void) srcHeight; (void) srcDepth;
   (void) srcFormat; (void) srcType;
   (void) srcAddr;
   (void) srcPacking;

   /* should never happen */
   _mesa_problem(NULL, "_mesa_texstore_null() is called");
   return GL_FALSE;
}


/**
 * Return the StoreTexImageFunc pointer to store an image in the given format.
 */
static StoreTexImageFunc
_mesa_get_texstore_func(mesa_format format)
{
   static StoreTexImageFunc table[MESA_FORMAT_COUNT];
   static GLboolean initialized = GL_FALSE;

   if (!initialized) {
      table[MESA_FORMAT_NONE] = _mesa_texstore_null;

      table[MESA_FORMAT_A8B8G8R8_UNORM] = _mesa_texstore_rgba8888;
      table[MESA_FORMAT_R8G8B8A8_UNORM] = _mesa_texstore_rgba8888;
      table[MESA_FORMAT_B8G8R8A8_UNORM] = _mesa_texstore_argb8888;
      table[MESA_FORMAT_A8R8G8B8_UNORM] = _mesa_texstore_argb8888;
      table[MESA_FORMAT_X8B8G8R8_UNORM] = _mesa_texstore_rgba8888;
      table[MESA_FORMAT_R8G8B8X8_UNORM] = _mesa_texstore_rgba8888;
      table[MESA_FORMAT_B8G8R8X8_UNORM] = _mesa_texstore_argb8888;
      table[MESA_FORMAT_X8R8G8B8_UNORM] = _mesa_texstore_argb8888;
      table[MESA_FORMAT_BGR_UNORM8] = _mesa_texstore_rgb888;
      table[MESA_FORMAT_RGB_UNORM8] = _mesa_texstore_bgr888;
      table[MESA_FORMAT_B5G6R5_UNORM] = _mesa_texstore_rgb565;
      table[MESA_FORMAT_R5G6B5_UNORM] = _mesa_texstore_rgb565;
      table[MESA_FORMAT_B4G4R4A4_UNORM] = store_ubyte_texture;
      table[MESA_FORMAT_A4R4G4B4_UNORM] = store_ubyte_texture;
      table[MESA_FORMAT_A1B5G5R5_UNORM] = store_ubyte_texture;
      table[MESA_FORMAT_B5G5R5A1_UNORM] = store_ubyte_texture;
      table[MESA_FORMAT_A1R5G5B5_UNORM] = store_ubyte_texture;
      table[MESA_FORMAT_L4A4_UNORM] = _mesa_texstore_unorm44;
      table[MESA_FORMAT_L8A8_UNORM] = _mesa_texstore_unorm88;
      table[MESA_FORMAT_A8L8_UNORM] = _mesa_texstore_unorm88;
      table[MESA_FORMAT_L16A16_UNORM] = _mesa_texstore_unorm1616;
      table[MESA_FORMAT_A16L16_UNORM] = _mesa_texstore_unorm1616;
      table[MESA_FORMAT_B2G3R3_UNORM] = store_ubyte_texture;
      table[MESA_FORMAT_A_UNORM8] = _mesa_texstore_unorm8;
      table[MESA_FORMAT_A_UNORM16] = _mesa_texstore_unorm16;
      table[MESA_FORMAT_L_UNORM8] = _mesa_texstore_unorm8;
      table[MESA_FORMAT_L_UNORM16] = _mesa_texstore_unorm16;
      table[MESA_FORMAT_I_UNORM8] = _mesa_texstore_unorm8;
      table[MESA_FORMAT_I_UNORM16] = _mesa_texstore_unorm16;
      table[MESA_FORMAT_YCBCR] = _mesa_texstore_ycbcr;
      table[MESA_FORMAT_YCBCR_REV] = _mesa_texstore_ycbcr;
      table[MESA_FORMAT_R_UNORM8] = _mesa_texstore_unorm8;
      table[MESA_FORMAT_R8G8_UNORM] = _mesa_texstore_unorm88;
      table[MESA_FORMAT_G8R8_UNORM] = _mesa_texstore_unorm88;
      table[MESA_FORMAT_R_UNORM16] = _mesa_texstore_unorm16;
      table[MESA_FORMAT_R16G16_UNORM] = _mesa_texstore_unorm1616;
      table[MESA_FORMAT_G16R16_UNORM] = _mesa_texstore_unorm1616;
      table[MESA_FORMAT_B10G10R10A2_UNORM] = _mesa_texstore_argb2101010;
      table[MESA_FORMAT_S8_UINT_Z24_UNORM] = _mesa_texstore_z24_s8;
      table[MESA_FORMAT_Z24_UNORM_S8_UINT] = _mesa_texstore_s8_z24;
      table[MESA_FORMAT_Z_UNORM16] = _mesa_texstore_z16;
      table[MESA_FORMAT_Z24_UNORM_X8_UINT] = _mesa_texstore_x8_z24;
      table[MESA_FORMAT_X8_UINT_Z24_UNORM] = _mesa_texstore_z24_x8;
      table[MESA_FORMAT_Z_UNORM32] = _mesa_texstore_z32;
      table[MESA_FORMAT_S_UINT8] = _mesa_texstore_s8;
      table[MESA_FORMAT_BGR_SRGB8] = _mesa_texstore_srgb8;
      table[MESA_FORMAT_A8B8G8R8_SRGB] = _mesa_texstore_srgba8;
      table[MESA_FORMAT_B8G8R8A8_SRGB] = _mesa_texstore_sargb8;
      table[MESA_FORMAT_L_SRGB8] = _mesa_texstore_sl8;
      table[MESA_FORMAT_L8A8_SRGB] = _mesa_texstore_sla8;
      table[MESA_FORMAT_SRGB_DXT1] = _mesa_texstore_rgb_dxt1;
      table[MESA_FORMAT_SRGBA_DXT1] = _mesa_texstore_rgba_dxt1;
      table[MESA_FORMAT_SRGBA_DXT3] = _mesa_texstore_rgba_dxt3;
      table[MESA_FORMAT_SRGBA_DXT5] = _mesa_texstore_rgba_dxt5;
      table[MESA_FORMAT_RGB_FXT1] = _mesa_texstore_rgb_fxt1;
      table[MESA_FORMAT_RGBA_FXT1] = _mesa_texstore_rgba_fxt1;
      table[MESA_FORMAT_RGB_DXT1] = _mesa_texstore_rgb_dxt1;
      table[MESA_FORMAT_RGBA_DXT1] = _mesa_texstore_rgba_dxt1;
      table[MESA_FORMAT_RGBA_DXT3] = _mesa_texstore_rgba_dxt3;
      table[MESA_FORMAT_RGBA_DXT5] = _mesa_texstore_rgba_dxt5;
      table[MESA_FORMAT_RGBA_FLOAT32] = _mesa_texstore_rgba_float32;
      table[MESA_FORMAT_RGBA_FLOAT16] = _mesa_texstore_rgba_float16;
      table[MESA_FORMAT_RGB_FLOAT32] = _mesa_texstore_rgba_float32;
      table[MESA_FORMAT_RGB_FLOAT16] = _mesa_texstore_rgba_float16;
      table[MESA_FORMAT_A_FLOAT32] = _mesa_texstore_rgba_float32;
      table[MESA_FORMAT_A_FLOAT16] = _mesa_texstore_rgba_float16;
      table[MESA_FORMAT_L_FLOAT32] = _mesa_texstore_rgba_float32;
      table[MESA_FORMAT_L_FLOAT16] = _mesa_texstore_rgba_float16;
      table[MESA_FORMAT_LA_FLOAT32] = _mesa_texstore_rgba_float32;
      table[MESA_FORMAT_LA_FLOAT16] = _mesa_texstore_rgba_float16;
      table[MESA_FORMAT_I_FLOAT32] = _mesa_texstore_rgba_float32;
      table[MESA_FORMAT_I_FLOAT16] = _mesa_texstore_rgba_float16;
      table[MESA_FORMAT_R_FLOAT32] = _mesa_texstore_rgba_float32;
      table[MESA_FORMAT_R_FLOAT16] = _mesa_texstore_rgba_float16;
      table[MESA_FORMAT_RG_FLOAT32] = _mesa_texstore_rgba_float32;
      table[MESA_FORMAT_RG_FLOAT16] = _mesa_texstore_rgba_float16;
      table[MESA_FORMAT_DUDV8] = _mesa_texstore_dudv8;
      table[MESA_FORMAT_R_SNORM8] = _mesa_texstore_snorm8;
      table[MESA_FORMAT_R8G8_SNORM] = _mesa_texstore_snorm88;
      table[MESA_FORMAT_X8B8G8R8_SNORM] = _mesa_texstore_signed_rgbx8888;
      table[MESA_FORMAT_A8B8G8R8_SNORM] = _mesa_texstore_signed_rgba8888;
      table[MESA_FORMAT_R8G8B8A8_SNORM] = _mesa_texstore_signed_rgba8888;
      table[MESA_FORMAT_R_SNORM16] = _mesa_texstore_snorm16;
      table[MESA_FORMAT_R16G16_SNORM] = _mesa_texstore_snorm1616;
      table[MESA_FORMAT_RGB_SNORM16] = _mesa_texstore_signed_rgba_16;
      table[MESA_FORMAT_RGBA_SNORM16] = _mesa_texstore_signed_rgba_16;
      table[MESA_FORMAT_RGBA_UNORM16] = _mesa_texstore_rgba_16;
      table[MESA_FORMAT_R_RGTC1_UNORM] = _mesa_texstore_red_rgtc1;
      table[MESA_FORMAT_R_RGTC1_SNORM] = _mesa_texstore_signed_red_rgtc1;
      table[MESA_FORMAT_RG_RGTC2_UNORM] = _mesa_texstore_rg_rgtc2;
      table[MESA_FORMAT_RG_RGTC2_SNORM] = _mesa_texstore_signed_rg_rgtc2;
      table[MESA_FORMAT_L_LATC1_UNORM] = _mesa_texstore_red_rgtc1;
      table[MESA_FORMAT_L_LATC1_SNORM] = _mesa_texstore_signed_red_rgtc1;
      table[MESA_FORMAT_LA_LATC2_UNORM] = _mesa_texstore_rg_rgtc2;
      table[MESA_FORMAT_LA_LATC2_SNORM] = _mesa_texstore_signed_rg_rgtc2;
      table[MESA_FORMAT_ETC1_RGB8] = _mesa_texstore_etc1_rgb8;
      table[MESA_FORMAT_ETC2_RGB8] = _mesa_texstore_etc2_rgb8;
      table[MESA_FORMAT_ETC2_SRGB8] = _mesa_texstore_etc2_srgb8;
      table[MESA_FORMAT_ETC2_RGBA8_EAC] = _mesa_texstore_etc2_rgba8_eac;
      table[MESA_FORMAT_ETC2_SRGB8_ALPHA8_EAC] = _mesa_texstore_etc2_srgb8_alpha8_eac;
      table[MESA_FORMAT_ETC2_R11_EAC] = _mesa_texstore_etc2_r11_eac;
      table[MESA_FORMAT_ETC2_RG11_EAC] = _mesa_texstore_etc2_rg11_eac;
      table[MESA_FORMAT_ETC2_SIGNED_R11_EAC] = _mesa_texstore_etc2_signed_r11_eac;
      table[MESA_FORMAT_ETC2_SIGNED_RG11_EAC] = _mesa_texstore_etc2_signed_rg11_eac;
      table[MESA_FORMAT_ETC2_RGB8_PUNCHTHROUGH_ALPHA1] =
         _mesa_texstore_etc2_rgb8_punchthrough_alpha1;
      table[MESA_FORMAT_ETC2_SRGB8_PUNCHTHROUGH_ALPHA1] =
         _mesa_texstore_etc2_srgb8_punchthrough_alpha1;
      table[MESA_FORMAT_A_SNORM8] = _mesa_texstore_snorm8;
      table[MESA_FORMAT_L_SNORM8] = _mesa_texstore_snorm8;
      table[MESA_FORMAT_L8A8_SNORM] = _mesa_texstore_snorm88;
      table[MESA_FORMAT_I_SNORM8] = _mesa_texstore_snorm8;
      table[MESA_FORMAT_A_SNORM16] = _mesa_texstore_snorm16;
      table[MESA_FORMAT_L_SNORM16] = _mesa_texstore_snorm16;
      table[MESA_FORMAT_LA_SNORM16] = _mesa_texstore_snorm1616;
      table[MESA_FORMAT_I_SNORM16] = _mesa_texstore_snorm16;
      table[MESA_FORMAT_R9G9B9E5_FLOAT] = _mesa_texstore_rgb9_e5;
      table[MESA_FORMAT_R11G11B10_FLOAT] = _mesa_texstore_r11_g11_b10f;
      table[MESA_FORMAT_Z_FLOAT32] = _mesa_texstore_z32;
      table[MESA_FORMAT_Z32_FLOAT_S8X24_UINT] = _mesa_texstore_z32f_x24s8;

      table[MESA_FORMAT_A_UINT8] = _mesa_texstore_rgba_uint8;
      table[MESA_FORMAT_A_UINT16] = _mesa_texstore_rgba_uint16;
      table[MESA_FORMAT_A_UINT32] = _mesa_texstore_rgba_uint32;
      table[MESA_FORMAT_A_SINT8] = _mesa_texstore_rgba_int8;
      table[MESA_FORMAT_A_SINT16] = _mesa_texstore_rgba_int16;
      table[MESA_FORMAT_A_SINT32] = _mesa_texstore_rgba_int32;

      table[MESA_FORMAT_I_UINT8] = _mesa_texstore_rgba_uint8;
      table[MESA_FORMAT_I_UINT16] = _mesa_texstore_rgba_uint16;
      table[MESA_FORMAT_I_UINT32] = _mesa_texstore_rgba_uint32;
      table[MESA_FORMAT_I_SINT8] = _mesa_texstore_rgba_int8;
      table[MESA_FORMAT_I_SINT16] = _mesa_texstore_rgba_int16;
      table[MESA_FORMAT_I_SINT32] = _mesa_texstore_rgba_int32;

      table[MESA_FORMAT_L_UINT8] = _mesa_texstore_rgba_uint8;
      table[MESA_FORMAT_L_UINT16] = _mesa_texstore_rgba_uint16;
      table[MESA_FORMAT_L_UINT32] = _mesa_texstore_rgba_uint32;
      table[MESA_FORMAT_L_SINT8] = _mesa_texstore_rgba_int8;
      table[MESA_FORMAT_L_SINT16] = _mesa_texstore_rgba_int16;
      table[MESA_FORMAT_L_SINT32] = _mesa_texstore_rgba_int32;

      table[MESA_FORMAT_LA_UINT8] = _mesa_texstore_rgba_uint8;
      table[MESA_FORMAT_LA_UINT16] = _mesa_texstore_rgba_uint16;
      table[MESA_FORMAT_LA_UINT32] = _mesa_texstore_rgba_uint32;
      table[MESA_FORMAT_LA_SINT8] = _mesa_texstore_rgba_int8;
      table[MESA_FORMAT_LA_SINT16] = _mesa_texstore_rgba_int16;
      table[MESA_FORMAT_LA_SINT32] = _mesa_texstore_rgba_int32;

      table[MESA_FORMAT_R_SINT8] = _mesa_texstore_rgba_int8;
      table[MESA_FORMAT_RG_SINT8] = _mesa_texstore_rgba_int8;
      table[MESA_FORMAT_RGB_SINT8] = _mesa_texstore_rgba_int8;
      table[MESA_FORMAT_RGBA_SINT8] = _mesa_texstore_rgba_int8;
      table[MESA_FORMAT_R_SINT16] = _mesa_texstore_rgba_int16;
      table[MESA_FORMAT_RG_SINT16] = _mesa_texstore_rgba_int16;
      table[MESA_FORMAT_RGB_SINT16] = _mesa_texstore_rgba_int16;
      table[MESA_FORMAT_RGBA_SINT16] = _mesa_texstore_rgba_int16;
      table[MESA_FORMAT_R_SINT32] = _mesa_texstore_rgba_int32;
      table[MESA_FORMAT_RG_SINT32] = _mesa_texstore_rgba_int32;
      table[MESA_FORMAT_RGB_SINT32] = _mesa_texstore_rgba_int32;
      table[MESA_FORMAT_RGBA_SINT32] = _mesa_texstore_rgba_int32;

      table[MESA_FORMAT_R_UINT8] = _mesa_texstore_rgba_uint8;
      table[MESA_FORMAT_RG_UINT8] = _mesa_texstore_rgba_uint8;
      table[MESA_FORMAT_RGB_UINT8] = _mesa_texstore_rgba_uint8;
      table[MESA_FORMAT_RGBA_UINT8] = _mesa_texstore_rgba_uint8;
      table[MESA_FORMAT_R_UINT16] = _mesa_texstore_rgba_uint16;
      table[MESA_FORMAT_RG_UINT16] = _mesa_texstore_rgba_uint16;
      table[MESA_FORMAT_RGB_UINT16] = _mesa_texstore_rgba_uint16;
      table[MESA_FORMAT_RGBA_UINT16] = _mesa_texstore_rgba_uint16;
      table[MESA_FORMAT_R_UINT32] = _mesa_texstore_rgba_uint32;
      table[MESA_FORMAT_RG_UINT32] = _mesa_texstore_rgba_uint32;
      table[MESA_FORMAT_RGB_UINT32] = _mesa_texstore_rgba_uint32;
      table[MESA_FORMAT_RGBA_UINT32] = _mesa_texstore_rgba_uint32;

      table[MESA_FORMAT_B10G10R10A2_UINT] = _mesa_texstore_argb2101010_uint;
      table[MESA_FORMAT_R10G10B10A2_UINT] = _mesa_texstore_abgr2101010_uint;

      table[MESA_FORMAT_B4G4R4X4_UNORM] = store_ubyte_texture;
      table[MESA_FORMAT_B5G5R5X1_UNORM] = store_ubyte_texture;
      table[MESA_FORMAT_R8G8B8X8_SNORM] = _mesa_texstore_signed_rgbx8888;
      table[MESA_FORMAT_R8G8B8X8_SRGB] = _mesa_texstore_srgba8;
      table[MESA_FORMAT_R8G8B8A8_SRGB] = _mesa_texstore_srgba8;
      table[MESA_FORMAT_RGBX_UINT8] = _mesa_texstore_rgba_uint8;
      table[MESA_FORMAT_RGBX_SINT8] = _mesa_texstore_rgba_int8;
      table[MESA_FORMAT_B10G10R10X2_UNORM] = _mesa_texstore_argb2101010;
      table[MESA_FORMAT_RGBX_UNORM16] = _mesa_texstore_rgba_16;
      table[MESA_FORMAT_RGBX_SNORM16] = _mesa_texstore_signed_rgba_16;
      table[MESA_FORMAT_RGBX_FLOAT16] = _mesa_texstore_rgba_float16;
      table[MESA_FORMAT_RGBX_UINT16] = _mesa_texstore_rgba_uint16;
      table[MESA_FORMAT_RGBX_SINT16] = _mesa_texstore_rgba_int16;
      table[MESA_FORMAT_RGBX_FLOAT32] = _mesa_texstore_rgba_float32;
      table[MESA_FORMAT_RGBX_UINT32] = _mesa_texstore_rgba_uint32;
      table[MESA_FORMAT_RGBX_SINT32] = _mesa_texstore_rgba_int32;

      table[MESA_FORMAT_R10G10B10A2_UNORM] = _mesa_texstore_abgr2101010;

      table[MESA_FORMAT_G8R8_SNORM] = _mesa_texstore_snorm88;
      table[MESA_FORMAT_G16R16_SNORM] = _mesa_texstore_snorm1616;

      table[MESA_FORMAT_B8G8R8X8_SRGB] = _mesa_texstore_sargb8;

      initialized = GL_TRUE;
   }

   ASSERT(table[format]);
   return table[format];
}


GLboolean
_mesa_texstore_needs_transfer_ops(struct gl_context *ctx,
                                  GLenum baseInternalFormat,
                                  mesa_format dstFormat)
{
   GLenum dstType;

   /* There are different rules depending on the base format. */
   switch (baseInternalFormat) {
   case GL_DEPTH_COMPONENT:
   case GL_DEPTH_STENCIL:
      return ctx->Pixel.DepthScale != 1.0f ||
             ctx->Pixel.DepthBias != 0.0f;

   case GL_STENCIL_INDEX:
      return GL_FALSE;

   default:
      /* Color formats.
       * Pixel transfer ops (scale, bias, table lookup) do not apply
       * to integer formats.
       */
      dstType = _mesa_get_format_datatype(dstFormat);

      return dstType != GL_INT && dstType != GL_UNSIGNED_INT &&
             ctx->_ImageTransferState;
   }
}


GLboolean
_mesa_texstore_can_use_memcpy(struct gl_context *ctx,
                              GLenum baseInternalFormat, mesa_format dstFormat,
                              GLenum srcFormat, GLenum srcType,
                              const struct gl_pixelstore_attrib *srcPacking)
{
   if (_mesa_texstore_needs_transfer_ops(ctx, baseInternalFormat, dstFormat)) {
      return GL_FALSE;
   }

   /* The base internal format and the base Mesa format must match. */
   if (baseInternalFormat != _mesa_get_format_base_format(dstFormat)) {
      return GL_FALSE;
   }

   /* The Mesa format must match the input format and type. */
   if (!_mesa_format_matches_format_and_type(dstFormat, srcFormat, srcType,
                                             srcPacking->SwapBytes)) {
      return GL_FALSE;
   }

   /* Depth texture data needs clamping in following cases:
    * - Floating point dstFormat with signed srcType: clamp to [0.0, 1.0].
    * - Fixed point dstFormat with signed srcType: clamp to [0, 2^n -1].
    *
    * All the cases except one (float dstFormat with float srcType) are ruled
    * out by _mesa_format_matches_format_and_type() check above. Handle the
    * remaining case here.
    */
   if ((baseInternalFormat == GL_DEPTH_COMPONENT ||
        baseInternalFormat == GL_DEPTH_STENCIL) &&
       (srcType == GL_FLOAT ||
        srcType == GL_FLOAT_32_UNSIGNED_INT_24_8_REV)) {
      return GL_FALSE;
   }

   return GL_TRUE;
}

static GLboolean
_mesa_texstore_memcpy(TEXSTORE_PARAMS)
{
   if (!_mesa_texstore_can_use_memcpy(ctx, baseInternalFormat, dstFormat,
                                      srcFormat, srcType, srcPacking)) {
      return GL_FALSE;
   }

   memcpy_texture(ctx, dims,
                  dstFormat,
                  dstRowStride, dstSlices,
                  srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                  srcAddr, srcPacking);
   return GL_TRUE;
}


/**
 * Store user data into texture memory.
 * Called via glTex[Sub]Image1/2/3D()
 * \return GL_TRUE for success, GL_FALSE for failure (out of memory).
 */
GLboolean
_mesa_texstore(TEXSTORE_PARAMS)
{
   StoreTexImageFunc storeImage;
   GLboolean success;

   if (_mesa_texstore_memcpy(ctx, dims, baseInternalFormat,
                             dstFormat,
                             dstRowStride, dstSlices,
                             srcWidth, srcHeight, srcDepth,
                             srcFormat, srcType, srcAddr, srcPacking)) {
      return GL_TRUE;
   }

   storeImage = _mesa_get_texstore_func(dstFormat);

   success = storeImage(ctx, dims, baseInternalFormat,
                        dstFormat,
                        dstRowStride, dstSlices,
                        srcWidth, srcHeight, srcDepth,
                        srcFormat, srcType, srcAddr, srcPacking);
   return success;
}


/**
 * Normally, we'll only _write_ texel data to a texture when we map it.
 * But if the user is providing depth or stencil values and the texture
 * image is a combined depth/stencil format, we'll actually read from
 * the texture buffer too (in order to insert the depth or stencil values.
 * \param userFormat  the user-provided image format
 * \param texFormat  the destination texture format
 */
static GLbitfield
get_read_write_mode(GLenum userFormat, mesa_format texFormat)
{
   if ((userFormat == GL_STENCIL_INDEX || userFormat == GL_DEPTH_COMPONENT)
       && _mesa_get_format_base_format(texFormat) == GL_DEPTH_STENCIL)
      return GL_MAP_READ_BIT | GL_MAP_WRITE_BIT;
   else
      return GL_MAP_WRITE_BIT | GL_MAP_INVALIDATE_RANGE_BIT;
}


/**
 * Helper function for storing 1D, 2D, 3D whole and subimages into texture
 * memory.
 * The source of the image data may be user memory or a PBO.  In the later
 * case, we'll map the PBO, copy from it, then unmap it.
 */
static void
store_texsubimage(struct gl_context *ctx,
                  struct gl_texture_image *texImage,
                  GLint xoffset, GLint yoffset, GLint zoffset,
                  GLint width, GLint height, GLint depth,
                  GLenum format, GLenum type, const GLvoid *pixels,
                  const struct gl_pixelstore_attrib *packing,
                  const char *caller)

{
   const GLbitfield mapMode = get_read_write_mode(format, texImage->TexFormat);
   const GLenum target = texImage->TexObject->Target;
   GLboolean success = GL_FALSE;
   GLuint dims, slice, numSlices = 1, sliceOffset = 0;
   GLint srcImageStride = 0;
   const GLubyte *src;

   assert(xoffset + width <= texImage->Width);
   assert(yoffset + height <= texImage->Height);
   assert(zoffset + depth <= texImage->Depth);

   switch (target) {
   case GL_TEXTURE_1D:
      dims = 1;
      break;
   case GL_TEXTURE_2D_ARRAY:
   case GL_TEXTURE_CUBE_MAP_ARRAY:
   case GL_TEXTURE_3D:
      dims = 3;
      break;
   default:
      dims = 2;
   }

   /* get pointer to src pixels (may be in a pbo which we'll map here) */
   src = (const GLubyte *)
      _mesa_validate_pbo_teximage(ctx, dims, width, height, depth,
                                  format, type, pixels, packing, caller);
   if (!src)
      return;

   /* compute slice info (and do some sanity checks) */
   switch (target) {
   case GL_TEXTURE_2D:
   case GL_TEXTURE_RECTANGLE:
   case GL_TEXTURE_CUBE_MAP:
   case GL_TEXTURE_EXTERNAL_OES:
      /* one image slice, nothing special needs to be done */
      break;
   case GL_TEXTURE_1D:
      assert(height == 1);
      assert(depth == 1);
      assert(yoffset == 0);
      assert(zoffset == 0);
      break;
   case GL_TEXTURE_1D_ARRAY:
      assert(depth == 1);
      assert(zoffset == 0);
      numSlices = height;
      sliceOffset = yoffset;
      height = 1;
      yoffset = 0;
      srcImageStride = _mesa_image_row_stride(packing, width, format, type);
      break;
   case GL_TEXTURE_2D_ARRAY:
      numSlices = depth;
      sliceOffset = zoffset;
      depth = 1;
      zoffset = 0;
      srcImageStride = _mesa_image_image_stride(packing, width, height,
                                                format, type);
      break;
   case GL_TEXTURE_3D:
      /* we'll store 3D images as a series of slices */
      numSlices = depth;
      sliceOffset = zoffset;
      srcImageStride = _mesa_image_image_stride(packing, width, height,
                                                format, type);
      break;
   case GL_TEXTURE_CUBE_MAP_ARRAY:
      numSlices = depth;
      sliceOffset = zoffset;
      srcImageStride = _mesa_image_image_stride(packing, width, height,
                                                format, type);
      break;
   default:
      _mesa_warning(ctx, "Unexpected target 0x%x in store_texsubimage()", target);
      return;
   }

   assert(numSlices == 1 || srcImageStride != 0);

   for (slice = 0; slice < numSlices; slice++) {
      GLubyte *dstMap;
      GLint dstRowStride;

      ctx->Driver.MapTextureImage(ctx, texImage,
                                  slice + sliceOffset,
                                  xoffset, yoffset, width, height,
                                  mapMode, &dstMap, &dstRowStride);
      if (dstMap) {
         /* Note: we're only storing a 2D (or 1D) slice at a time but we need
          * to pass the right 'dims' value so that GL_UNPACK_SKIP_IMAGES is
          * used for 3D images.
          */
         success = _mesa_texstore(ctx, dims, texImage->_BaseFormat,
                                  texImage->TexFormat,
                                  dstRowStride,
                                  &dstMap,
                                  width, height, 1,  /* w, h, d */
                                  format, type, src, packing);

         ctx->Driver.UnmapTextureImage(ctx, texImage, slice + sliceOffset);
      }

      src += srcImageStride;

      if (!success)
         break;
   }

   if (!success)
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "%s", caller);

   _mesa_unmap_teximage_pbo(ctx, packing);
}



/**
 * Fallback code for ctx->Driver.TexImage().
 * Basically, allocate storage for the texture image, then copy the
 * user's image into it.
 */
void
_mesa_store_teximage(struct gl_context *ctx,
                     GLuint dims,
                     struct gl_texture_image *texImage,
                     GLenum format, GLenum type, const GLvoid *pixels,
                     const struct gl_pixelstore_attrib *packing)
{
   assert(dims == 1 || dims == 2 || dims == 3);

   if (texImage->Width == 0 || texImage->Height == 0 || texImage->Depth == 0)
      return;

   /* allocate storage for texture data */
   if (!ctx->Driver.AllocTextureImageBuffer(ctx, texImage)) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glTexImage%uD", dims);
      return;
   }

   store_texsubimage(ctx, texImage,
                     0, 0, 0, texImage->Width, texImage->Height, texImage->Depth,
                     format, type, pixels, packing, "glTexImage");
}


/*
 * Fallback for Driver.TexSubImage().
 */
void
_mesa_store_texsubimage(struct gl_context *ctx, GLuint dims,
                        struct gl_texture_image *texImage,
                        GLint xoffset, GLint yoffset, GLint zoffset,
                        GLint width, GLint height, GLint depth,
                        GLenum format, GLenum type, const void *pixels,
                        const struct gl_pixelstore_attrib *packing)
{
   store_texsubimage(ctx, texImage,
                     xoffset, yoffset, zoffset, width, height, depth,
                     format, type, pixels, packing, "glTexSubImage");
}


/**
 * Fallback for Driver.CompressedTexImage()
 */
void
_mesa_store_compressed_teximage(struct gl_context *ctx, GLuint dims,
                                struct gl_texture_image *texImage,
                                GLsizei imageSize, const GLvoid *data)
{
   /* only 2D and 3D compressed images are supported at this time */
   if (dims == 1) {
      _mesa_problem(ctx, "Unexpected glCompressedTexImage1D call");
      return;
   }

   /* This is pretty simple, because unlike the general texstore path we don't
    * have to worry about the usual image unpacking or image transfer
    * operations.
    */
   ASSERT(texImage);
   ASSERT(texImage->Width > 0);
   ASSERT(texImage->Height > 0);
   ASSERT(texImage->Depth > 0);

   /* allocate storage for texture data */
   if (!ctx->Driver.AllocTextureImageBuffer(ctx, texImage)) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCompressedTexImage%uD", dims);
      return;
   }

   _mesa_store_compressed_texsubimage(ctx, dims, texImage,
                                      0, 0, 0,
                                      texImage->Width, texImage->Height, texImage->Depth,
                                      texImage->TexFormat,
                                      imageSize, data);
}


/**
 * Fallback for Driver.CompressedTexSubImage()
 */
void
_mesa_store_compressed_texsubimage(struct gl_context *ctx, GLuint dims,
                                   struct gl_texture_image *texImage,
                                   GLint xoffset, GLint yoffset, GLint zoffset,
                                   GLsizei width, GLsizei height, GLsizei depth,
                                   GLenum format,
                                   GLsizei imageSize, const GLvoid *data)
{
   GLint bytesPerRow, dstRowStride, srcRowStride;
   GLint i, rows;
   GLubyte *dstMap;
   const GLubyte *src;
   const mesa_format texFormat = texImage->TexFormat;
   GLuint bw, bh;
   GLint slice;

   if (dims == 1) {
      _mesa_problem(ctx, "Unexpected 1D compressed texsubimage call");
      return;
   }

   _mesa_get_format_block_size(texFormat, &bw, &bh);

   /* get pointer to src pixels (may be in a pbo which we'll map here) */
   data = _mesa_validate_pbo_compressed_teximage(ctx, dims, imageSize, data,
                                                 &ctx->Unpack,
                                                 "glCompressedTexSubImage");
   if (!data)
      return;

   srcRowStride = _mesa_format_row_stride(texFormat, width);
   src = (const GLubyte *) data;

   for (slice = 0; slice < depth; slice++) {
      /* Map dest texture buffer */
      ctx->Driver.MapTextureImage(ctx, texImage, slice + zoffset,
                                  xoffset, yoffset, width, height,
                                  GL_MAP_WRITE_BIT | GL_MAP_INVALIDATE_RANGE_BIT,
                                  &dstMap, &dstRowStride);

      if (dstMap) {
         bytesPerRow = srcRowStride;  /* bytes per row of blocks */
         rows = (height + bh - 1) / bh;  /* rows in blocks */

         /* copy rows of blocks */
         for (i = 0; i < rows; i++) {
            memcpy(dstMap, src, bytesPerRow);
            dstMap += dstRowStride;
            src += srcRowStride;
         }

         ctx->Driver.UnmapTextureImage(ctx, texImage, slice + zoffset);
      }
      else {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCompressedTexSubImage%uD",
                     dims);
      }
   }

   _mesa_unmap_teximage_pbo(ctx, &ctx->Unpack);
}
@


1.13
log
@Merge Mesa 10.2.9
@
text
@@


1.12
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a57 1
#include "format_utils.h"
a69 1
#include "texcompress_bptc.h"
d90 29
d236 13
a248 35
   case GL_LUMINANCE:
   case GL_LUMINANCE_INTEGER_EXT:
      return IDX_LUMINANCE;
   case GL_ALPHA:
   case GL_ALPHA_INTEGER:
      return IDX_ALPHA;
   case GL_INTENSITY:
      return IDX_INTENSITY;
   case GL_LUMINANCE_ALPHA:
   case GL_LUMINANCE_ALPHA_INTEGER_EXT:
      return IDX_LUMINANCE_ALPHA;
   case GL_RGB:
   case GL_RGB_INTEGER:
      return IDX_RGB;
   case GL_RGBA:
   case GL_RGBA_INTEGER:
      return IDX_RGBA;
   case GL_RED:
   case GL_RED_INTEGER:
      return IDX_RED;
   case GL_GREEN:
      return IDX_GREEN;
   case GL_BLUE:
      return IDX_BLUE;
   case GL_BGR:
   case GL_BGR_INTEGER:
      return IDX_BGR;
   case GL_BGRA:
   case GL_BGRA_INTEGER:
      return IDX_BGRA;
   case GL_ABGR_EXT:
      return IDX_ABGR;
   case GL_RG:
   case GL_RG_INTEGER:
      return IDX_RG;
d250 1
a250 2
      _mesa_problem(NULL, "Unexpected inFormat %s",
                    _mesa_lookup_enum_by_nr(value));
d665 125
d792 124
a915 1
static const GLubyte map_1032[6] = { 1, 0, 3, 2, ZERO, ONE };
a990 4
   /* This way we will use the RGB versions of the packing functions and it
    * will work for both RGB and sRGB textures*/
   dstFormat = _mesa_get_srgb_format_linear(dstFormat);

a1180 3
      return GL_TRUE;
   } else {
      return GL_FALSE;
d1182 7
d1193 1
a1193 1
 * Texstore for _mesa_texformat_ycbcr or _mesa_texformat_ycbcr_REV.
d1196 1
a1196 1
_mesa_texstore_ycbcr(TEXSTORE_PARAMS)
d1200 51
a1250 1
   (void) ctx; (void) dims; (void) baseInternalFormat;
d1252 4
a1255 8
   ASSERT((dstFormat == MESA_FORMAT_YCBCR) ||
          (dstFormat == MESA_FORMAT_YCBCR_REV));
   ASSERT(_mesa_get_format_bytes(dstFormat) == 2);
   ASSERT(ctx->Extensions.MESA_ycbcr_texture);
   ASSERT(srcFormat == GL_YCBCR_MESA);
   ASSERT((srcType == GL_UNSIGNED_SHORT_8_8_MESA) ||
          (srcType == GL_UNSIGNED_SHORT_8_8_REV_MESA));
   ASSERT(baseInternalFormat == GL_YCBCR_MESA);
d1257 5
a1261 6
   /* always just memcpy since no pixel transfer ops apply */
   memcpy_texture(ctx, dims,
                  dstFormat,
                  dstRowStride, dstSlices,
                  srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                  srcAddr, srcPacking);
d1263 68
a1330 7
   /* Check if we need byte swapping */
   /* XXX the logic here _might_ be wrong */
   if (srcPacking->SwapBytes ^
       (srcType == GL_UNSIGNED_SHORT_8_8_REV_MESA) ^
       (dstFormat == MESA_FORMAT_YCBCR_REV) ^
       !littleEndian) {
      GLint img, row;
d1332 4
d1338 7
a1344 1
            _mesa_swap2((GLushort *) dstRow, srcWidth);
d1346 1
d1350 47
a1400 3
/**
 * Store a combined depth/stencil texture image.
 */
d1402 1
a1402 1
_mesa_texstore_z24_s8(TEXSTORE_PARAMS)
d1404 2
a1405 6
   const GLuint depthScale = 0xffffff;
   const GLint srcRowStride
      = _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType);
   GLint img, row;
   GLuint *depth = malloc(srcWidth * sizeof(GLuint));
   GLubyte *stencil = malloc(srcWidth * sizeof(GLubyte));
d1407 27
a1433 7
   ASSERT(dstFormat == MESA_FORMAT_S8_UINT_Z24_UNORM);
   ASSERT(srcFormat == GL_DEPTH_STENCIL_EXT ||
          srcFormat == GL_DEPTH_COMPONENT ||
          srcFormat == GL_STENCIL_INDEX);
   ASSERT(srcFormat != GL_DEPTH_STENCIL_EXT ||
          srcType == GL_UNSIGNED_INT_24_8_EXT ||
          srcType == GL_FLOAT_32_UNSIGNED_INT_24_8_REV);
d1435 23
a1457 4
   if (!depth || !stencil) {
      free(depth);
      free(stencil);
      return GL_FALSE;
d1459 2
a1461 11
   /* In case we only upload depth we need to preserve the stencil */
   for (img = 0; img < srcDepth; img++) {
      GLuint *dstRow = (GLuint *) dstSlices[img];
      const GLubyte *src
         = (const GLubyte *) _mesa_image_address(dims, srcPacking, srcAddr,
               srcWidth, srcHeight,
               srcFormat, srcType,
               img, 0, 0);
      for (row = 0; row < srcHeight; row++) {
         GLint i;
         GLboolean keepdepth = GL_FALSE, keepstencil = GL_FALSE;
d1463 26
a1488 5
         if (srcFormat == GL_DEPTH_COMPONENT) { /* preserve stencil */
            keepstencil = GL_TRUE;
         }
         else if (srcFormat == GL_STENCIL_INDEX) { /* preserve depth */
            keepdepth = GL_TRUE;
d1490 34
d1525 6
a1530 7
         if (keepdepth == GL_FALSE)
            /* the 24 depth bits will be in the low position: */
            _mesa_unpack_depth_span(ctx, srcWidth,
                                    GL_UNSIGNED_INT, /* dst type */
                                    keepstencil ? depth : dstRow, /* dst addr */
                                    depthScale,
                                    srcType, src, srcPacking);
d1532 22
a1553 7
         if (keepstencil == GL_FALSE)
            /* get the 8-bit stencil values */
            _mesa_unpack_stencil_span(ctx, srcWidth,
                                      GL_UNSIGNED_BYTE, /* dst type */
                                      stencil, /* dst addr */
                                      srcType, src, srcPacking,
                                      ctx->_ImageTransferState);
d1555 11
a1565 5
         for (i = 0; i < srcWidth; i++) {
            if (keepstencil)
               dstRow[i] = depth[i] << 8 | (dstRow[i] & 0x000000FF);
            else
               dstRow[i] = (dstRow[i] & 0xFFFFFF00) | (stencil[i] & 0xFF);
a1566 2
         src += srcRowStride;
         dstRow += dstRowStride / sizeof(GLuint);
d1568 1
a1569 3

   free(depth);
   free(stencil);
d1575 1
a1575 1
 * Store a combined depth/stencil texture image.
d1578 1
a1578 1
_mesa_texstore_s8_z24(TEXSTORE_PARAMS)
d1580 1
a1580 6
   const GLuint depthScale = 0xffffff;
   const GLint srcRowStride
      = _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType);
   GLint img, row;
   GLuint *depth;
   GLubyte *stencil;
d1582 2
a1583 7
   ASSERT(dstFormat == MESA_FORMAT_Z24_UNORM_S8_UINT);
   ASSERT(srcFormat == GL_DEPTH_STENCIL_EXT ||
          srcFormat == GL_DEPTH_COMPONENT ||
          srcFormat == GL_STENCIL_INDEX);
   ASSERT(srcFormat != GL_DEPTH_STENCIL_EXT ||
          srcType == GL_UNSIGNED_INT_24_8_EXT ||
          srcType == GL_FLOAT_32_UNSIGNED_INT_24_8_REV);
d1585 26
a1610 7
   depth = malloc(srcWidth * sizeof(GLuint));
   stencil = malloc(srcWidth * sizeof(GLubyte));

   if (!depth || !stencil) {
      free(depth);
      free(stencil);
      return GL_FALSE;
d1612 2
a1614 17
   for (img = 0; img < srcDepth; img++) {
      GLuint *dstRow = (GLuint *) dstSlices[img];
      const GLubyte *src
	 = (const GLubyte *) _mesa_image_address(dims, srcPacking, srcAddr,
						srcWidth, srcHeight,
						srcFormat, srcType,
						img, 0, 0);
      for (row = 0; row < srcHeight; row++) {
	 GLint i;
	 GLboolean keepdepth = GL_FALSE, keepstencil = GL_FALSE;
	 
	 if (srcFormat == GL_DEPTH_COMPONENT) { /* preserve stencil */
	    keepstencil = GL_TRUE;
	 }
         else if (srcFormat == GL_STENCIL_INDEX) { /* preserve depth */
	    keepdepth = GL_TRUE;
	 }
d1616 8
a1623 7
	 if (keepdepth == GL_FALSE)
	    /* the 24 depth bits will be in the low position: */
	    _mesa_unpack_depth_span(ctx, srcWidth,
				    GL_UNSIGNED_INT, /* dst type */
				    keepstencil ? depth : dstRow, /* dst addr */
				    depthScale,
				    srcType, src, srcPacking);	 
d1625 5
a1629 7
	 if (keepstencil == GL_FALSE)
	    /* get the 8-bit stencil values */
	    _mesa_unpack_stencil_span(ctx, srcWidth,
				      GL_UNSIGNED_BYTE, /* dst type */
				      stencil, /* dst addr */
				      srcType, src, srcPacking,
				      ctx->_ImageTransferState);
d1631 6
a1636 6
	 /* merge stencil values into depth values */
	 for (i = 0; i < srcWidth; i++) {
	    if (keepstencil)
	       dstRow[i] = depth[i] | (dstRow[i] & 0xFF000000);
	    else
	       dstRow[i] = (dstRow[i] & 0xFFFFFF) | (stencil[i] << 24);
d1638 22
a1660 2
	 src += srcRowStride;
	 dstRow += dstRowStride / sizeof(GLuint);
d1662 49
a1711 4

   free(depth);
   free(stencil);

d1717 1
a1717 1
 * Store simple 8-bit/value stencil texture data.
d1720 1
a1720 1
_mesa_texstore_s8(TEXSTORE_PARAMS)
d1722 7
a1728 2
   ASSERT(dstFormat == MESA_FORMAT_S_UINT8);
   ASSERT(srcFormat == GL_STENCIL_INDEX);
d1731 11
a1741 6
      const GLint srcRowStride
	 = _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType);
      GLint img, row;
      GLubyte *stencil = malloc(srcWidth * sizeof(GLubyte));

      if (!stencil)
a1742 1

a1744 5
         const GLubyte *src
            = (const GLubyte *) _mesa_image_address(dims, srcPacking, srcAddr,
                                                   srcWidth, srcHeight,
                                                   srcFormat, srcType,
                                                   img, 0, 0);
d1746 42
a1787 1
            GLint i;
d1789 1617
a3405 12
            /* get the 8-bit stencil values */
            _mesa_unpack_stencil_span(ctx, srcWidth,
                                      GL_UNSIGNED_BYTE, /* dst type */
                                      stencil, /* dst addr */
                                      srcType, src, srcPacking,
                                      ctx->_ImageTransferState);
            /* merge stencil values into depth values */
            for (i = 0; i < srcWidth; i++)
               dstRow[i] = stencil[i];

            src += srcRowStride;
            dstRow += dstRowStride / sizeof(GLubyte);
d3409 1
a3409 1
      free(stencil);
a3410 1

d3576 43
d3621 22
a3642 1
texstore_depth_stencil(TEXSTORE_PARAMS)
d3648 1
a3648 1
      memset(table, 0, sizeof table);
d3650 38
d3695 5
a3699 22
      table[MESA_FORMAT_Z_FLOAT32] = _mesa_texstore_z32;
      table[MESA_FORMAT_Z32_FLOAT_S8X24_UINT] = _mesa_texstore_z32f_x24s8;

      initialized = GL_TRUE;
   }

   ASSERT(table[dstFormat]);
   return table[dstFormat](ctx, dims, baseInternalFormat,
                           dstFormat, dstRowStride, dstSlices,
                           srcWidth, srcHeight, srcDepth,
                           srcFormat, srcType, srcAddr, srcPacking);
}

static GLboolean
texstore_compressed(TEXSTORE_PARAMS)
{
   static StoreTexImageFunc table[MESA_FORMAT_COUNT];
   static GLboolean initialized = GL_FALSE;

   if (!initialized) {
      memset(table, 0, sizeof table);

d3710 27
d3758 12
d3771 53
a3823 8
      table[MESA_FORMAT_BPTC_RGBA_UNORM] =
         _mesa_texstore_bptc_rgba_unorm;
      table[MESA_FORMAT_BPTC_SRGB_ALPHA_UNORM] =
         _mesa_texstore_bptc_rgba_unorm;
      table[MESA_FORMAT_BPTC_RGB_SIGNED_FLOAT] =
         _mesa_texstore_bptc_rgb_signed_float;
      table[MESA_FORMAT_BPTC_RGB_UNSIGNED_FLOAT] =
         _mesa_texstore_bptc_rgb_unsigned_float;
d3825 2
a3826 2
      initialized = GL_TRUE;
   }
d3828 16
a3843 6
   ASSERT(table[dstFormat]);
   return table[dstFormat](ctx, dims, baseInternalFormat,
                           dstFormat, dstRowStride, dstSlices,
                           srcWidth, srcHeight, srcDepth,
                           srcFormat, srcType, srcAddr, srcPacking);
}
d3845 1
a3845 4
static void
invert_swizzle(uint8_t dst[4], const uint8_t src[4])
{
   int i, j;
d3847 2
a3848 4
   dst[0] = MESA_FORMAT_SWIZZLE_NONE;
   dst[1] = MESA_FORMAT_SWIZZLE_NONE;
   dst[2] = MESA_FORMAT_SWIZZLE_NONE;
   dst[3] = MESA_FORMAT_SWIZZLE_NONE;
d3850 1
a3850 5
   for (i = 0; i < 4; ++i)
      for (j = 0; j < 4; ++j)
         if (src[j] == i && dst[i] == MESA_FORMAT_SWIZZLE_NONE)
            dst[i] = j;
}
d3852 1
a3852 148
/** Store a texture by per-channel conversions and swizzling.
 *
 * This function attempts to perform a texstore operation by doing simple
 * per-channel conversions and swizzling.  This covers a huge chunk of the
 * texture storage operations that anyone cares about.  If this function is
 * incapable of performing the operation, it bails and returns GL_FALSE.
 */
static GLboolean
texstore_swizzle(TEXSTORE_PARAMS)
{
   const GLint srcRowStride = _mesa_image_row_stride(srcPacking, srcWidth,
                                                     srcFormat, srcType);
   const GLint srcImageStride = _mesa_image_image_stride(srcPacking,
                                      srcWidth, srcHeight, srcFormat, srcType);
   const GLubyte *srcImage = (const GLubyte *) _mesa_image_address(dims,
        srcPacking, srcAddr, srcWidth, srcHeight, srcFormat, srcType, 0, 0, 0);
   const int src_components = _mesa_components_in_format(srcFormat);

   GLubyte swizzle[4], rgba2base[6], base2src[6], rgba2dst[4], dst2rgba[4];
   const GLubyte *swap;
   GLenum dst_type;
   int dst_components;
   bool is_array, normalized, need_swap;
   GLint i, img, row;
   const GLubyte *src_row;
   GLubyte *dst_row;

   is_array = _mesa_format_to_array(dstFormat, &dst_type, &dst_components,
                                    rgba2dst, &normalized);

   if (!is_array)
      return GL_FALSE;

   if (srcFormat == GL_COLOR_INDEX)
      return GL_FALSE;

   if (_mesa_texstore_needs_transfer_ops(ctx, baseInternalFormat, dstFormat))
      return GL_FALSE;

   switch (srcType) {
   case GL_FLOAT:
   case GL_UNSIGNED_BYTE:
   case GL_BYTE:
   case GL_UNSIGNED_SHORT:
   case GL_SHORT:
   case GL_UNSIGNED_INT:
   case GL_INT:
      /* If wa have to swap bytes in a multi-byte datatype, that means
       * we're not doing an array conversion anymore */
      if (srcPacking->SwapBytes)
         return GL_FALSE;
      need_swap = false;
      break;
   case GL_UNSIGNED_INT_8_8_8_8:
      need_swap = srcPacking->SwapBytes;
      if (_mesa_little_endian())
         need_swap = !need_swap;
      srcType = GL_UNSIGNED_BYTE;
      break;
   case GL_UNSIGNED_INT_8_8_8_8_REV:
      need_swap = srcPacking->SwapBytes;
      if (!_mesa_little_endian())
         need_swap = !need_swap;
      srcType = GL_UNSIGNED_BYTE;
      break;
   default:
      return GL_FALSE;
   }
   swap = need_swap ? map_3210 : map_identity;

   compute_component_mapping(srcFormat, baseInternalFormat, base2src);
   compute_component_mapping(baseInternalFormat, GL_RGBA, rgba2base);
   invert_swizzle(dst2rgba, rgba2dst);

   for (i = 0; i < 4; i++) {
      if (dst2rgba[i] == MESA_FORMAT_SWIZZLE_NONE)
         swizzle[i] = MESA_FORMAT_SWIZZLE_NONE;
      else
         swizzle[i] = swap[base2src[rgba2base[dst2rgba[i]]]];
   }

   /* Is it normalized? */
   normalized |= !_mesa_is_enum_format_integer(srcFormat);

   for (img = 0; img < srcDepth; img++) {
      if (dstRowStride == srcWidth * dst_components &&
          srcRowStride == srcWidth * src_components) {
         _mesa_swizzle_and_convert(dstSlices[img], dst_type, dst_components,
                                   srcImage, srcType, src_components,
                                   swizzle, normalized, srcWidth * srcHeight);
      } else {
         src_row = srcImage;
         dst_row = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            _mesa_swizzle_and_convert(dst_row, dst_type, dst_components,
                                      src_row, srcType, src_components,
                                      swizzle, normalized, srcWidth);
            dst_row += dstRowStride;
            src_row += srcRowStride;
         }
      }
      srcImage += srcImageStride;
   }

   return GL_TRUE;
}


/** Stores a texture by converting float and then to the texture format
 *
 * This function performs a texstore operation by converting to float,
 * applying pixel transfer ops, and then converting to the texture's
 * internal format using pixel store functions.  This function will work
 * for any rgb or srgb textore format.
 */
static GLboolean
texstore_via_float(TEXSTORE_PARAMS)
{
   GLuint i, img, row;
   const GLint src_stride =
      _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType);
   float *tmp_row;
   bool need_convert;
   uint8_t *src_row, *dst_row, map[4], rgba2base[6], base2rgba[6];

   tmp_row = malloc(srcWidth * 4 * sizeof(*tmp_row));
   if (!tmp_row)
      return GL_FALSE;

   /* The GL spec (4.0, compatibility profile) only specifies srgb
    * conversion as something that is done in the sampler during the
    * filtering process before the colors are handed to the shader.
    * Furthermore, the flowchart (Figure 3.7 in the 4.0 compatibility spec)
    * does not list RGB <-> sRGB conversions anywhere.  Therefore, we just
    * treat sRGB formats the same as RGB formats for the purposes of
    * texture upload and transfer ops.
    */
   dstFormat = _mesa_get_srgb_format_linear(dstFormat);

   need_convert = false;
   if (baseInternalFormat != _mesa_get_format_base_format(dstFormat)) {
      compute_component_mapping(GL_RGBA, baseInternalFormat, base2rgba);
      compute_component_mapping(baseInternalFormat, GL_RGBA, rgba2base);
      for (i = 0; i < 4; ++i) {
         map[i] = base2rgba[rgba2base[i]];
         if (map[i] != i)
            need_convert = true;
      }
d3855 2
a3856 95
   for (img = 0; img < srcDepth; img++) {
      dst_row = dstSlices[img];
      src_row = _mesa_image_address(dims, srcPacking, srcAddr,
                                    srcWidth, srcHeight,
                                    srcFormat, srcType,
                                    img, 0, 0);
      for (row = 0; row < srcHeight; row++) {
	 _mesa_unpack_color_span_float(ctx, srcWidth, GL_RGBA, tmp_row,
                                       srcFormat, srcType, src_row,
				       srcPacking, ctx->_ImageTransferState);
         if (need_convert)
            _mesa_swizzle_and_convert(tmp_row, GL_FLOAT, 4,
                                      tmp_row, GL_FLOAT, 4,
                                      map, false, srcWidth);
         _mesa_pack_float_rgba_row(dstFormat, srcWidth,
                                   (const GLfloat (*)[4])tmp_row,
                                   dst_row);
         dst_row += dstRowStride;
         src_row += src_stride;
      }
   }

   free(tmp_row);

   return GL_TRUE;
}

/** Stores an integer rgba texture
 *
 * This function performs an integer texture storage operation by unpacking
 * the texture to 32-bit integers, and repacking it into the internal
 * format of the texture.  This will work for any integer rgb texture
 * storage operation.
 */
static GLboolean
texstore_rgba_integer(TEXSTORE_PARAMS)
{
   GLuint i, img, row, *tmp_row;
   GLenum dst_type, tmp_type;
   const GLint src_stride =
      _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType);
   int num_dst_components;
   bool is_array, normalized;
   uint8_t *src_row, *dst_row;
   uint8_t swizzle[4], rgba2base[6], base2rgba[6], rgba2dst[4], dst2rgba[4];

   tmp_row = malloc(srcWidth * 4 * sizeof(*tmp_row));
   if (!tmp_row)
      return GL_FALSE;

   is_array = _mesa_format_to_array(dstFormat, &dst_type, &num_dst_components,
                                    rgba2dst, &normalized);

   assert(is_array && !normalized);

   if (!is_array)
      return GL_FALSE;

   invert_swizzle(dst2rgba, rgba2dst);
   compute_component_mapping(GL_RGBA, baseInternalFormat, base2rgba);
   compute_component_mapping(baseInternalFormat, GL_RGBA, rgba2base);

   for (i = 0; i < 4; ++i) {
      if (dst2rgba[i] == MESA_FORMAT_SWIZZLE_NONE)
         swizzle[i] = MESA_FORMAT_SWIZZLE_NONE;
      else
         swizzle[i] = base2rgba[rgba2base[dst2rgba[i]]];
   }

   if (_mesa_is_type_unsigned(srcType)) {
      tmp_type = GL_UNSIGNED_INT;
   } else {
      tmp_type = GL_INT;
   }

   for (img = 0; img < srcDepth; img++) {
      dst_row = dstSlices[img];
      src_row = _mesa_image_address(dims, srcPacking, srcAddr,
                                    srcWidth, srcHeight,
                                    srcFormat, srcType,
                                    img, 0, 0);
      for (row = 0; row < srcHeight; row++) {
	 _mesa_unpack_color_span_uint(ctx, srcWidth, GL_RGBA, tmp_row,
                                      srcFormat, srcType, src_row, srcPacking);
         _mesa_swizzle_and_convert(dst_row, dst_type, num_dst_components,
                                   tmp_row, tmp_type, 4,
                                   swizzle, false, srcWidth);
         dst_row += dstRowStride;
         src_row += src_stride;
      }
   }

   free(tmp_row);

   return GL_TRUE;
a3858 57
static GLboolean
texstore_rgba(TEXSTORE_PARAMS)
{
   static StoreTexImageFunc table[MESA_FORMAT_COUNT];
   static GLboolean initialized = GL_FALSE;

   if (!initialized) {
      memset(table, 0, sizeof table);

      table[MESA_FORMAT_B5G6R5_UNORM] = _mesa_texstore_rgb565;
      table[MESA_FORMAT_R5G6B5_UNORM] = _mesa_texstore_rgb565;
      table[MESA_FORMAT_YCBCR] = _mesa_texstore_ycbcr;
      table[MESA_FORMAT_YCBCR_REV] = _mesa_texstore_ycbcr;

      table[MESA_FORMAT_B10G10R10A2_UINT] = _mesa_texstore_argb2101010_uint;
      table[MESA_FORMAT_R10G10B10A2_UINT] = _mesa_texstore_abgr2101010_uint;

      initialized = GL_TRUE;
   }

   if (table[dstFormat] && table[dstFormat](ctx, dims, baseInternalFormat,
                                            dstFormat, dstRowStride, dstSlices,
                                            srcWidth, srcHeight, srcDepth,
                                            srcFormat, srcType, srcAddr,
                                            srcPacking)) {
      return GL_TRUE;
   }

   if (texstore_swizzle(ctx, dims, baseInternalFormat,
                        dstFormat,
                        dstRowStride, dstSlices,
                        srcWidth, srcHeight, srcDepth,
                        srcFormat, srcType, srcAddr, srcPacking)) {
      return GL_TRUE;
   }

   if (_mesa_is_format_integer(dstFormat)) {
      return texstore_rgba_integer(ctx, dims, baseInternalFormat,
                                   dstFormat, dstRowStride, dstSlices,
                                   srcWidth, srcHeight, srcDepth,
                                   srcFormat, srcType, srcAddr,
                                   srcPacking);
   } else if (_mesa_get_format_max_bits(dstFormat) <= 8 &&
              !_mesa_is_format_signed(dstFormat)) {
      return store_ubyte_texture(ctx, dims, baseInternalFormat,
                                 dstFormat,
                                 dstRowStride, dstSlices,
                                 srcWidth, srcHeight, srcDepth,
                                 srcFormat, srcType, srcAddr, srcPacking);
   } else {
      return texstore_via_float(ctx, dims, baseInternalFormat,
                                dstFormat, dstRowStride, dstSlices,
                                srcWidth, srcHeight, srcDepth,
                                srcFormat, srcType, srcAddr,
                                srcPacking);
   }
}
d3944 2
d3954 3
d3965 8
a3972 16
   if (_mesa_is_depth_or_stencil_format(baseInternalFormat)) {
      return texstore_depth_stencil(ctx, dims, baseInternalFormat,
                                    dstFormat, dstRowStride, dstSlices,
                                    srcWidth, srcHeight, srcDepth,
                                    srcFormat, srcType, srcAddr, srcPacking);
   } else if (_mesa_is_format_compressed(dstFormat)) {
      return texstore_compressed(ctx, dims, baseInternalFormat,
                                 dstFormat, dstRowStride, dstSlices,
                                 srcWidth, srcHeight, srcDepth,
                                 srcFormat, srcType, srcAddr, srcPacking);
   } else {
      return texstore_rgba(ctx, dims, baseInternalFormat,
                           dstFormat, dstRowStride, dstSlices,
                           srcWidth, srcHeight, srcDepth,
                           srcFormat, srcType, srcAddr, srcPacking);
   }
a4174 72
static void
clear_image_to_zero(GLubyte *dstMap, GLint dstRowStride,
                    GLsizei width, GLsizei height,
                    GLsizei clearValueSize)
{
   GLsizei y;

   for (y = 0; y < height; y++) {
      memset(dstMap, 0, clearValueSize * width);
      dstMap += dstRowStride;
   }
}

static void
clear_image_to_value(GLubyte *dstMap, GLint dstRowStride,
                     GLsizei width, GLsizei height,
                     const GLvoid *clearValue,
                     GLsizei clearValueSize)
{
   GLsizei y, x;

   for (y = 0; y < height; y++) {
      for (x = 0; x < width; x++) {
         memcpy(dstMap, clearValue, clearValueSize);
         dstMap += clearValueSize;
      }
      dstMap += dstRowStride - clearValueSize * width;
   }
}

/*
 * Fallback for Driver.ClearTexSubImage().
 */
void
_mesa_store_cleartexsubimage(struct gl_context *ctx,
                             struct gl_texture_image *texImage,
                             GLint xoffset, GLint yoffset, GLint zoffset,
                             GLsizei width, GLsizei height, GLsizei depth,
                             const GLvoid *clearValue)
{
   GLubyte *dstMap;
   GLint dstRowStride;
   GLsizeiptr clearValueSize;
   GLsizei z;

   clearValueSize = _mesa_get_format_bytes(texImage->TexFormat);

   for (z = 0; z < depth; z++) {
      ctx->Driver.MapTextureImage(ctx, texImage,
                                  z + zoffset, xoffset, yoffset,
                                  width, height,
                                  GL_MAP_WRITE_BIT,
                                  &dstMap, &dstRowStride);
      if (dstMap == NULL) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glClearTex*Image");
         return;
      }

      if (clearValue) {
         clear_image_to_value(dstMap, dstRowStride,
                              width, height,
                              clearValue,
                              clearValueSize);
      } else {
         clear_image_to_zero(dstMap, dstRowStride,
                             width, height,
                             clearValueSize);
      }

      ctx->Driver.UnmapTextureImage(ctx, texImage, z + zoffset);
   }
}
a4213 64
 * Compute compressed_pixelstore parameters for copying compressed
 * texture data.
 * \param dims  number of texture image dimensions: 1, 2 or 3
 * \param texFormat  the compressed texture format
 * \param width, height, depth  size of image to copy
 * \param packing  pixelstore parameters describing user-space image packing
 * \param store  returns the compressed_pixelstore parameters
 */
void
_mesa_compute_compressed_pixelstore(GLuint dims, mesa_format texFormat,
                                    GLsizei width, GLsizei height,
                                    GLsizei depth,
                                    const struct gl_pixelstore_attrib *packing,
                                    struct compressed_pixelstore *store)
{
   GLuint bw, bh;

   _mesa_get_format_block_size(texFormat, &bw, &bh);

   store->SkipBytes = 0;
   store->TotalBytesPerRow = store->CopyBytesPerRow =
         _mesa_format_row_stride(texFormat, width);
   store->TotalRowsPerSlice = store->CopyRowsPerSlice =
         (height + bh - 1) / bh;
   store->CopySlices = depth;

   if (packing->CompressedBlockWidth &&
       packing->CompressedBlockSize) {

      bw = packing->CompressedBlockWidth;

      if (packing->RowLength) {
         store->TotalBytesPerRow = packing->CompressedBlockSize *
            ((packing->RowLength + bw - 1) / bw);
      }

      store->SkipBytes += packing->SkipPixels * packing->CompressedBlockSize / bw;
   }

   if (dims > 1 && packing->CompressedBlockHeight &&
       packing->CompressedBlockSize) {

      bh = packing->CompressedBlockHeight;

      store->SkipBytes += packing->SkipRows * store->TotalBytesPerRow / bh;
      store->CopyRowsPerSlice = (height + bh - 1) / bh;  /* rows in blocks */

      if (packing->ImageHeight) {
         store->TotalRowsPerSlice = (packing->ImageHeight + bh - 1) / bh;
      }
   }

   if (dims > 2 && packing->CompressedBlockDepth &&
       packing->CompressedBlockSize) {

      int bd = packing->CompressedBlockDepth;

      store->SkipBytes += packing->SkipImages * store->TotalBytesPerRow *
            store->TotalRowsPerSlice / bd;
   }
}


/**
d4224 2
a4225 3
   struct compressed_pixelstore store;
   GLint dstRowStride;
   GLint i, slice;
d4228 3
d4237 1
a4237 3
   _mesa_compute_compressed_pixelstore(dims, texImage->TexFormat,
                                       width, height, depth,
                                       &ctx->Unpack, &store);
d4246 2
a4247 1
   src = (const GLubyte *) data + store.SkipBytes;
d4249 1
a4249 1
   for (slice = 0; slice < store.CopySlices; slice++) {
d4257 2
d4261 2
a4262 2
         for (i = 0; i < store.CopyRowsPerSlice; i++) {
            memcpy(dstMap, src, store.CopyBytesPerRow);
d4264 1
a4264 1
            src += store.TotalBytesPerRow;
a4267 3

         /* advance to next slice */
         src += store.TotalBytesPerRow * (store.TotalRowsPerSlice - store.CopyRowsPerSlice);
@


1.11
log
@Merge Mesa 10.2.7
@
text
@d58 1
d71 1
a91 29
/**
 * Return GL_TRUE if the given image format is one that be converted
 * to another format by swizzling.
 */
static GLboolean
can_swizzle(GLenum logicalBaseFormat)
{
   switch (logicalBaseFormat) {
   case GL_RGBA:
   case GL_RGB:
   case GL_LUMINANCE_ALPHA:
   case GL_INTENSITY:
   case GL_ALPHA:
   case GL_LUMINANCE:
   case GL_RED:
   case GL_GREEN:
   case GL_BLUE:
   case GL_BGR:
   case GL_BGRA:
   case GL_ABGR_EXT:
   case GL_RG:
      return GL_TRUE;
   default:
      return GL_FALSE;
   }
}



d209 35
a243 13
   case GL_LUMINANCE: return IDX_LUMINANCE;
   case GL_ALPHA: return IDX_ALPHA;
   case GL_INTENSITY: return IDX_INTENSITY;
   case GL_LUMINANCE_ALPHA: return IDX_LUMINANCE_ALPHA;
   case GL_RGB: return IDX_RGB;
   case GL_RGBA: return IDX_RGBA;
   case GL_RED: return IDX_RED;
   case GL_GREEN: return IDX_GREEN;
   case GL_BLUE: return IDX_BLUE;
   case GL_BGR: return IDX_BGR;
   case GL_BGRA: return IDX_BGRA;
   case GL_ABGR_EXT: return IDX_ABGR;
   case GL_RG: return IDX_RG;
d245 2
a246 1
      _mesa_problem(NULL, "Unexpected inFormat");
a660 125
/**
 * Copy GLubyte pixels from <src> to <dst> with swizzling.
 * \param dst  destination pixels
 * \param dstComponents  number of color components in destination pixels
 * \param src  source pixels
 * \param srcComponents  number of color components in source pixels
 * \param map  the swizzle mapping.  map[X] says where to find the X component
 *             in the source image's pixels.  For example, if the source image
 *             is GL_BGRA and X = red, map[0] yields 2.
 * \param count  number of pixels to copy/swizzle.
 */
static void
swizzle_copy(GLubyte *dst, GLuint dstComponents, const GLubyte *src, 
             GLuint srcComponents, const GLubyte *map, GLuint count)
{
#define SWZ_CPY(dst, src, count, dstComps, srcComps) \
   do {                                              \
      GLuint i;                                      \
      for (i = 0; i < count; i++) {                  \
         GLuint j;                                   \
         if (srcComps == 4) {                        \
            COPY_4UBV(tmp, src);                     \
         }                                           \
         else {                                      \
            for (j = 0; j < srcComps; j++) {         \
               tmp[j] = src[j];                      \
            }                                        \
         }                                           \
         src += srcComps;                            \
         for (j = 0; j < dstComps; j++) {            \
            dst[j] = tmp[map[j]];                    \
         }                                           \
         dst += dstComps;                            \
      }                                              \
   } while (0)

   GLubyte tmp[6];

   tmp[ZERO] = 0x0;
   tmp[ONE] = 0xff;

   ASSERT(srcComponents <= 4);
   ASSERT(dstComponents <= 4);

   switch (dstComponents) {
   case 4:
      switch (srcComponents) {
      case 4:
         SWZ_CPY(dst, src, count, 4, 4);
         break;
      case 3:
         SWZ_CPY(dst, src, count, 4, 3);
         break;
      case 2:
         SWZ_CPY(dst, src, count, 4, 2);
         break;
      case 1:
         SWZ_CPY(dst, src, count, 4, 1);
         break;
      default:
         ;
      }
      break;
   case 3:
      switch (srcComponents) {
      case 4:
         SWZ_CPY(dst, src, count, 3, 4);
         break;
      case 3:
         SWZ_CPY(dst, src, count, 3, 3);
         break;
      case 2:
         SWZ_CPY(dst, src, count, 3, 2);
         break;
      case 1:
         SWZ_CPY(dst, src, count, 3, 1);
         break;
      default:
         ;
      }
      break;
   case 2:
      switch (srcComponents) {
      case 4:
         SWZ_CPY(dst, src, count, 2, 4);
         break;
      case 3:
         SWZ_CPY(dst, src, count, 2, 3);
         break;
      case 2:
         SWZ_CPY(dst, src, count, 2, 2);
         break;
      case 1:
         SWZ_CPY(dst, src, count, 2, 1);
         break;
      default:
         ;
      }
      break;
   case 1:
      switch (srcComponents) {
      case 4:
         SWZ_CPY(dst, src, count, 1, 4);
         break;
      case 3:
         SWZ_CPY(dst, src, count, 1, 3);
         break;
      case 2:
         SWZ_CPY(dst, src, count, 1, 2);
         break;
      case 1:
         SWZ_CPY(dst, src, count, 1, 1);
         break;
      default:
         ;
      }
      break;
   default:
      ;
   }
#undef SWZ_CPY
}



d663 1
a663 124


/**
 * For 1-byte/pixel formats (or 8_8_8_8 packed formats), return a
 * mapping array depending on endianness.
 */
static const GLubyte *
type_mapping( GLenum srcType )
{
   switch (srcType) {
   case GL_BYTE:
   case GL_UNSIGNED_BYTE:
      return map_identity;
   case GL_UNSIGNED_INT_8_8_8_8:
      return _mesa_little_endian() ? map_3210 : map_identity;
   case GL_UNSIGNED_INT_8_8_8_8_REV:
      return _mesa_little_endian() ? map_identity : map_3210;
   default:
      return NULL;
   }
}


/**
 * For 1-byte/pixel formats (or 8_8_8_8 packed formats), return a
 * mapping array depending on pixelstore byte swapping state.
 */
static const GLubyte *
byteswap_mapping( GLboolean swapBytes,
		  GLenum srcType )
{
   if (!swapBytes) 
      return map_identity;

   switch (srcType) {
   case GL_BYTE:
   case GL_UNSIGNED_BYTE:
      return map_identity;
   case GL_UNSIGNED_INT_8_8_8_8:
   case GL_UNSIGNED_INT_8_8_8_8_REV:
      return map_3210;
   default:
      return NULL;
   }
}



/**
 * Transfer a GLubyte texture image with component swizzling.
 */
static void
_mesa_swizzle_ubyte_image(struct gl_context *ctx, 
			  GLuint dimensions,
			  GLenum srcFormat,
			  GLenum srcType,

			  GLenum baseInternalFormat,

			  const GLubyte *rgba2dst,
			  GLuint dstComponents,

			  GLint dstRowStride,
                          GLubyte **dstSlices,

			  GLint srcWidth, GLint srcHeight, GLint srcDepth,
			  const GLvoid *srcAddr,
			  const struct gl_pixelstore_attrib *srcPacking )
{
   GLint srcComponents = _mesa_components_in_format(srcFormat);
   const GLubyte *srctype2ubyte, *swap;
   GLubyte map[4], src2base[6], base2rgba[6];
   GLint i;
   const GLint srcRowStride =
      _mesa_image_row_stride(srcPacking, srcWidth,
                             srcFormat, GL_UNSIGNED_BYTE);
   const GLint srcImageStride
      = _mesa_image_image_stride(srcPacking, srcWidth, srcHeight, srcFormat,
                                 GL_UNSIGNED_BYTE);
   const GLubyte *srcImage
      = (const GLubyte *) _mesa_image_address(dimensions, srcPacking, srcAddr,
                                              srcWidth, srcHeight, srcFormat,
                                              GL_UNSIGNED_BYTE, 0, 0, 0);

   (void) ctx;

   /* Translate from src->baseInternal->GL_RGBA->dst.  This will
    * correctly deal with RGBA->RGB->RGBA conversions where the final
    * A value must be 0xff regardless of the incoming alpha values.
    */
   compute_component_mapping(srcFormat, baseInternalFormat, src2base);
   compute_component_mapping(baseInternalFormat, GL_RGBA, base2rgba);
   swap = byteswap_mapping(srcPacking->SwapBytes, srcType);
   srctype2ubyte = type_mapping(srcType);


   for (i = 0; i < 4; i++)
      map[i] = srctype2ubyte[swap[src2base[base2rgba[rgba2dst[i]]]]];

/*    printf("map %d %d %d %d\n", map[0], map[1], map[2], map[3]);  */

   if (srcComponents == dstComponents &&
       srcRowStride == dstRowStride &&
       srcRowStride == srcWidth * srcComponents &&
       dimensions < 3) {
      /* 1 and 2D images only */
      GLubyte *dstImage = dstSlices[0];
      swizzle_copy(dstImage, dstComponents, srcImage, srcComponents, map, 
		   srcWidth * srcHeight);
   }
   else {
      GLint img, row;
      for (img = 0; img < srcDepth; img++) {
         const GLubyte *srcRow = srcImage;
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
	    swizzle_copy(dstRow, dstComponents, srcRow, srcComponents, map, srcWidth);
            dstRow += dstRowStride;
            srcRow += srcRowStride;
         }
         srcImage += srcImageStride;
      }
   }
}
d739 4
d933 3
a936 7
   else {
      return store_ubyte_texture(ctx, dims, baseInternalFormat,
                                 dstFormat, dstRowStride, dstSlices,
                                 srcWidth, srcHeight, srcDepth,
                                 srcFormat, srcType, srcAddr, srcPacking);
   }
   return GL_TRUE;
d941 1
a941 1
 * Store a texture in MESA_FORMAT_A8B8G8R8_UNORM or MESA_FORMAT_R8G8B8A8_UNORM.
d944 1
a944 1
_mesa_texstore_rgba8888(TEXSTORE_PARAMS)
d948 1
a948 5
   ASSERT(dstFormat == MESA_FORMAT_A8B8G8R8_UNORM ||
          dstFormat == MESA_FORMAT_R8G8B8A8_UNORM ||
          dstFormat == MESA_FORMAT_X8B8G8R8_UNORM ||
          dstFormat == MESA_FORMAT_R8G8B8X8_UNORM);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 4);
d950 8
a957 6
   if (!ctx->_ImageTransferState &&
       (srcType == GL_UNSIGNED_BYTE ||
        srcType == GL_UNSIGNED_INT_8_8_8_8 ||
        srcType == GL_UNSIGNED_INT_8_8_8_8_REV) &&
       can_swizzle(baseInternalFormat) &&
       can_swizzle(srcFormat)) {
d959 6
a964 1
      GLubyte dstmap[4];
d966 7
a972 57
      /* dstmap - how to swizzle from RGBA to dst format:
       */
      if ((littleEndian && (dstFormat == MESA_FORMAT_A8B8G8R8_UNORM ||
                            dstFormat == MESA_FORMAT_X8B8G8R8_UNORM)) ||
	  (!littleEndian && (dstFormat == MESA_FORMAT_R8G8B8A8_UNORM ||
	                     dstFormat == MESA_FORMAT_R8G8B8X8_UNORM))) {
	 dstmap[3] = 0;
	 dstmap[2] = 1;
	 dstmap[1] = 2;
	 dstmap[0] = 3;
      }
      else {
	 dstmap[3] = 3;
	 dstmap[2] = 2;
	 dstmap[1] = 1;
	 dstmap[0] = 0;
      }
      
      _mesa_swizzle_ubyte_image(ctx, dims,
				srcFormat,
				srcType,
				baseInternalFormat,
				dstmap, 4,
				dstRowStride, dstSlices,
				srcWidth, srcHeight, srcDepth, srcAddr,
				srcPacking);      
   }
   else {
      return store_ubyte_texture(ctx, dims, baseInternalFormat,
                                 dstFormat, dstRowStride, dstSlices,
                                 srcWidth, srcHeight, srcDepth,
                                 srcFormat, srcType, srcAddr, srcPacking);
   }
   return GL_TRUE;
}


static GLboolean
_mesa_texstore_argb8888(TEXSTORE_PARAMS)
{
   const GLboolean littleEndian = _mesa_little_endian();

   ASSERT(dstFormat == MESA_FORMAT_B8G8R8A8_UNORM ||
          dstFormat == MESA_FORMAT_A8R8G8B8_UNORM ||
          dstFormat == MESA_FORMAT_B8G8R8X8_UNORM ||
          dstFormat == MESA_FORMAT_X8R8G8B8_UNORM );
   ASSERT(_mesa_get_format_bytes(dstFormat) == 4);

   if (!ctx->_ImageTransferState &&
       !srcPacking->SwapBytes &&
       (dstFormat == MESA_FORMAT_B8G8R8A8_UNORM ||
        dstFormat == MESA_FORMAT_B8G8R8X8_UNORM) &&
       srcFormat == GL_RGB &&
       (baseInternalFormat == GL_RGBA ||
        baseInternalFormat == GL_RGB) &&
       srcType == GL_UNSIGNED_BYTE) {
      int img, row, col;
a973 4
         const GLint srcRowStride =
            _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType);
         GLubyte *srcRow = (GLubyte *) _mesa_image_address(dims, srcPacking,
                  srcAddr, srcWidth, srcHeight, srcFormat, srcType, img, 0, 0);
d976 1
a976 66
            GLuint *d4 = (GLuint *) dstRow;
            for (col = 0; col < srcWidth; col++) {
               d4[col] = PACK_COLOR_8888(0xff,
                                         srcRow[col * 3 + RCOMP],
                                         srcRow[col * 3 + GCOMP],
                                         srcRow[col * 3 + BCOMP]);
            }
            dstRow += dstRowStride;
            srcRow += srcRowStride;
         }
      }
   }
   else if (!ctx->_ImageTransferState &&
            !srcPacking->SwapBytes &&
            dstFormat == MESA_FORMAT_B8G8R8A8_UNORM &&
            srcFormat == GL_LUMINANCE_ALPHA &&
            baseInternalFormat == GL_RGBA &&
            srcType == GL_UNSIGNED_BYTE) {
      /* special case of storing LA -> ARGB8888 */
      int img, row, col;
      const GLint srcRowStride =
         _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType);
      for (img = 0; img < srcDepth; img++) {
         const GLubyte *srcRow = (const GLubyte *)
            _mesa_image_address(dims, srcPacking, srcAddr, srcWidth,
                                srcHeight, srcFormat, srcType, img, 0, 0);
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLuint *d4 = (GLuint *) dstRow;
            for (col = 0; col < srcWidth; col++) {
               GLubyte l = srcRow[col * 2 + 0], a = srcRow[col * 2 + 1];
               d4[col] = PACK_COLOR_8888(a, l, l, l);
            }
            dstRow += dstRowStride;
            srcRow += srcRowStride;
         }
      }
   }
   else if (!ctx->_ImageTransferState &&
            !srcPacking->SwapBytes &&
	    dstFormat == MESA_FORMAT_B8G8R8A8_UNORM &&
            srcFormat == GL_RGBA &&
	    baseInternalFormat == GL_RGBA &&
            srcType == GL_UNSIGNED_BYTE) {
      /* same as above case, but src data has alpha too */
      GLint img, row, col;
      /* For some reason, streaming copies to write-combined regions
       * are extremely sensitive to the characteristics of how the
       * source data is retrieved.  By reordering the source reads to
       * be in-order, the speed of this operation increases by half.
       * Strangely the same isn't required for the RGB path, above.
       */
      for (img = 0; img < srcDepth; img++) {
         const GLint srcRowStride =
            _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType);
         GLubyte *srcRow = (GLubyte *) _mesa_image_address(dims, srcPacking,
                  srcAddr, srcWidth, srcHeight, srcFormat, srcType, img, 0, 0);
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLuint *d4 = (GLuint *) dstRow;
            for (col = 0; col < srcWidth; col++) {
               d4[col] = PACK_COLOR_8888(srcRow[col * 4 + ACOMP],
                                         srcRow[col * 4 + RCOMP],
                                         srcRow[col * 4 + GCOMP],
                                         srcRow[col * 4 + BCOMP]);
            }
a977 1
            srcRow += srcRowStride;
a980 47
   else if (!ctx->_ImageTransferState &&
	    (srcType == GL_UNSIGNED_BYTE ||
	     srcType == GL_UNSIGNED_INT_8_8_8_8 ||
	     srcType == GL_UNSIGNED_INT_8_8_8_8_REV) &&
	    can_swizzle(baseInternalFormat) &&	   
	    can_swizzle(srcFormat)) {

      GLubyte dstmap[4];

      /* dstmap - how to swizzle from RGBA to dst format:
       */
      if ((littleEndian && dstFormat == MESA_FORMAT_B8G8R8A8_UNORM) ||
          (littleEndian && dstFormat == MESA_FORMAT_B8G8R8X8_UNORM) ||
	  (!littleEndian && dstFormat == MESA_FORMAT_A8R8G8B8_UNORM) ||
	  (!littleEndian && dstFormat == MESA_FORMAT_X8R8G8B8_UNORM)) {
	 dstmap[3] = 3;		/* alpha */
	 dstmap[2] = 0;		/* red */
	 dstmap[1] = 1;		/* green */
	 dstmap[0] = 2;		/* blue */
      }
      else {
	 assert((littleEndian && dstFormat == MESA_FORMAT_A8R8G8B8_UNORM) ||
		(!littleEndian && dstFormat == MESA_FORMAT_B8G8R8A8_UNORM) ||
		(littleEndian && dstFormat == MESA_FORMAT_X8R8G8B8_UNORM) ||
		(!littleEndian && dstFormat == MESA_FORMAT_B8G8R8X8_UNORM));
	 dstmap[3] = 2;
	 dstmap[2] = 1;
	 dstmap[1] = 0;
	 dstmap[0] = 3;
      }
 
      _mesa_swizzle_ubyte_image(ctx, dims,
				srcFormat,
				srcType,
				baseInternalFormat,
				dstmap, 4,
				dstRowStride,
                                dstSlices,
				srcWidth, srcHeight, srcDepth, srcAddr,
				srcPacking);      
   }
   else {
      return store_ubyte_texture(ctx, dims, baseInternalFormat,
                                 dstFormat, dstRowStride, dstSlices,
                                 srcWidth, srcHeight, srcDepth,
                                 srcFormat, srcType, srcAddr, srcPacking);
   }
d985 3
d989 1
a989 1
_mesa_texstore_rgb888(TEXSTORE_PARAMS)
d991 6
a996 2
   ASSERT(dstFormat == MESA_FORMAT_BGR_UNORM8);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 3);
d998 7
a1004 27
   if (!ctx->_ImageTransferState &&
       !srcPacking->SwapBytes &&
       srcFormat == GL_RGBA &&
       srcType == GL_UNSIGNED_BYTE) {
      /* extract RGB from RGBA */
      GLint img, row, col;
      for (img = 0; img < srcDepth; img++) {
         const GLint srcRowStride =
            _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType);
         GLubyte *srcRow = (GLubyte *) _mesa_image_address(dims, srcPacking,
                  srcAddr, srcWidth, srcHeight, srcFormat, srcType, img, 0, 0);
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            for (col = 0; col < srcWidth; col++) {
               dstRow[col * 3 + 0] = srcRow[col * 4 + BCOMP];
               dstRow[col * 3 + 1] = srcRow[col * 4 + GCOMP];
               dstRow[col * 3 + 2] = srcRow[col * 4 + RCOMP];
            }
            dstRow += dstRowStride;
            srcRow += srcRowStride;
         }
      }
   }
   else if (!ctx->_ImageTransferState &&
	    srcType == GL_UNSIGNED_BYTE &&
	    can_swizzle(baseInternalFormat) &&
	    can_swizzle(srcFormat)) {
d1006 4
a1009 23
      GLubyte dstmap[4];

      /* dstmap - how to swizzle from RGBA to dst format:
       */
      dstmap[0] = 2;
      dstmap[1] = 1;
      dstmap[2] = 0;
      dstmap[3] = ONE;		/* ? */
      
      _mesa_swizzle_ubyte_image(ctx, dims,
				srcFormat,
				srcType,
				baseInternalFormat,
				dstmap, 3,
				dstRowStride, dstSlices,
				srcWidth, srcHeight, srcDepth, srcAddr,
				srcPacking);      
   }
   else {
      return store_ubyte_texture(ctx, dims, baseInternalFormat,
                                 dstFormat, dstRowStride, dstSlices,
                                 srcWidth, srcHeight, srcDepth,
                                 srcFormat, srcType, srcAddr, srcPacking);
a1010 2
   return GL_TRUE;
}
d1012 11
d1024 5
a1028 26
static GLboolean
_mesa_texstore_bgr888(TEXSTORE_PARAMS)
{
   ASSERT(dstFormat == MESA_FORMAT_RGB_UNORM8);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 3);

   if (!ctx->_ImageTransferState &&
       !srcPacking->SwapBytes &&
       srcFormat == GL_RGBA &&
       srcType == GL_UNSIGNED_BYTE) {
      /* extract BGR from RGBA */
      int img, row, col;
      for (img = 0; img < srcDepth; img++) {
         const GLint srcRowStride =
            _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType);
         GLubyte *srcRow = (GLubyte *) _mesa_image_address(dims, srcPacking,
                  srcAddr, srcWidth, srcHeight, srcFormat, srcType, img, 0, 0);
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            for (col = 0; col < srcWidth; col++) {
               dstRow[col * 3 + 0] = srcRow[col * 4 + RCOMP];
               dstRow[col * 3 + 1] = srcRow[col * 4 + GCOMP];
               dstRow[col * 3 + 2] = srcRow[col * 4 + BCOMP];
            }
            dstRow += dstRowStride;
            srcRow += srcRowStride;
a1029 6
      }
   }
   else if (!ctx->_ImageTransferState &&
	    srcType == GL_UNSIGNED_BYTE &&
	    can_swizzle(baseInternalFormat) &&
	    can_swizzle(srcFormat)) {
d1031 7
a1037 1
      GLubyte dstmap[4];
d1039 7
a1045 24
      /* dstmap - how to swizzle from RGBA to dst format:
       */
      dstmap[0] = 0;
      dstmap[1] = 1;
      dstmap[2] = 2;
      dstmap[3] = ONE;		/* ? */
      
      _mesa_swizzle_ubyte_image(ctx, dims,
				srcFormat,
				srcType,
				baseInternalFormat,
				dstmap, 3,
				dstRowStride, dstSlices,
				srcWidth, srcHeight, srcDepth, srcAddr,
				srcPacking);      
   }   
   else {
      return store_ubyte_texture(ctx, dims, baseInternalFormat,
                                 dstFormat, dstRowStride, dstSlices,
                                 srcWidth, srcHeight, srcDepth,
                                 srcFormat, srcType, srcAddr, srcPacking);
   }
   return GL_TRUE;
}
d1047 5
a1051 42

static GLboolean
_mesa_texstore_argb2101010(TEXSTORE_PARAMS)
{
   ASSERT(dstFormat == MESA_FORMAT_B10G10R10A2_UNORM ||
          dstFormat == MESA_FORMAT_B10G10R10X2_UNORM);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 4);

   {
      /* general path */
      /* Hardcode GL_RGBA as the base format, which forces alpha to 1.0
       * if the internal format is RGB. */
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 GL_RGBA,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *src = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         if (baseInternalFormat == GL_RGBA || baseInternalFormat == GL_RGB) {
            for (row = 0; row < srcHeight; row++) {
               GLuint *dstUI = (GLuint *) dstRow;
               for (col = 0; col < srcWidth; col++) {
                  GLushort a,r,g,b;

                  UNCLAMPED_FLOAT_TO_USHORT(a, src[ACOMP]);
                  UNCLAMPED_FLOAT_TO_USHORT(r, src[RCOMP]);
                  UNCLAMPED_FLOAT_TO_USHORT(g, src[GCOMP]);
                  UNCLAMPED_FLOAT_TO_USHORT(b, src[BCOMP]);
                  dstUI[col] = PACK_COLOR_2101010_US(a, r, g, b);
                  src += 4;
               }
               dstRow += dstRowStride;
            }
         } else {
            ASSERT(0);
d1053 2
a1055 1
      free((void *) tempImage);
d1057 3
d1065 1
a1065 1
 * Do texstore for 2-channel, 4-bit/channel, unsigned normalized formats.
d1068 1
a1068 1
_mesa_texstore_unorm44(TEXSTORE_PARAMS)
d1070 14
a1083 1
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
d1085 2
a1086 2
   ASSERT(dstFormat == MESA_FORMAT_L4A4_UNORM);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 1);
d1088 4
a1091 26
   {
      /* general path */
      const GLubyte *tempImage = _mesa_make_temp_ubyte_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking);
      const GLubyte *src = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLubyte *dstUS = (GLubyte *) dstRow;
            for (col = 0; col < srcWidth; col++) {
               /* src[0] is luminance, src[1] is alpha */
               dstUS[col] = PACK_COLOR_44( src[1],
                                           src[0] );
               src += 2;
            }
            dstRow += dstRowStride;
         }
      }
      free((void *) tempImage);
a1092 2
   return GL_TRUE;
}
d1094 17
d1112 7
a1118 8
/**
 * Do texstore for 2-channel, 8-bit/channel, unsigned normalized formats.
 */
static GLboolean
_mesa_texstore_unorm88(TEXSTORE_PARAMS)
{
   const GLboolean littleEndian = _mesa_little_endian();
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
d1120 7
a1126 5
   ASSERT(dstFormat == MESA_FORMAT_L8A8_UNORM ||
          dstFormat == MESA_FORMAT_A8L8_UNORM ||
          dstFormat == MESA_FORMAT_R8G8_UNORM ||
          dstFormat == MESA_FORMAT_G8R8_UNORM);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 2);
d1128 6
a1133 6
   if (!ctx->_ImageTransferState &&
       littleEndian &&
       srcType == GL_UNSIGNED_BYTE &&
       can_swizzle(baseInternalFormat) &&
       can_swizzle(srcFormat)) {
      GLubyte dstmap[4];
a1134 7
      /* dstmap - how to swizzle from RGBA to dst format:
       */
      if (dstFormat == MESA_FORMAT_L8A8_UNORM || dstFormat == MESA_FORMAT_A8L8_UNORM) {
	 if ((littleEndian && dstFormat == MESA_FORMAT_L8A8_UNORM) ||
	     (!littleEndian && dstFormat == MESA_FORMAT_A8L8_UNORM)) {
	    dstmap[0] = 0;
	    dstmap[1] = 3;
d1136 2
a1137 63
	 else {
	    dstmap[0] = 3;
	    dstmap[1] = 0;
	 }
      }
      else {
	 if ((littleEndian && dstFormat == MESA_FORMAT_R8G8_UNORM) ||
	     (!littleEndian && dstFormat == MESA_FORMAT_G8R8_UNORM)) {
	    dstmap[0] = 0;
	    dstmap[1] = 1;
	 }
	 else {
	    dstmap[0] = 1;
	    dstmap[1] = 0;
	 }
      }
      dstmap[2] = ZERO;		/* ? */
      dstmap[3] = ONE;		/* ? */
      
      _mesa_swizzle_ubyte_image(ctx, dims,
				srcFormat,
				srcType,
				baseInternalFormat,
				dstmap, 2,
				dstRowStride, dstSlices,
				srcWidth, srcHeight, srcDepth, srcAddr,
				srcPacking);      
   }   
   else {
      /* general path */
      const GLubyte *tempImage = _mesa_make_temp_ubyte_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking);
      const GLubyte *src = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLushort *dstUS = (GLushort *) dstRow;
            if (dstFormat == MESA_FORMAT_L8A8_UNORM ||
		dstFormat == MESA_FORMAT_R8G8_UNORM) {
               for (col = 0; col < srcWidth; col++) {
                  /* src[0] is luminance (or R), src[1] is alpha (or G) */
                 dstUS[col] = PACK_COLOR_88( src[1],
                                             src[0] );
                 src += 2;
               }
            }
            else {
               for (col = 0; col < srcWidth; col++) {
                  /* src[0] is luminance (or R), src[1] is alpha (or G) */
                 dstUS[col] = PACK_COLOR_88_REV( src[1],
                                                 src[0] );
                 src += 2;
               }
            }
            dstRow += dstRowStride;
         }
a1138 1
      free((void *) tempImage);
d1140 4
d1149 1
a1149 1
 * Do texstore for 2-channel, 16-bit/channel, unsigned normalized formats.
d1152 1
a1152 1
_mesa_texstore_unorm1616(TEXSTORE_PARAMS)
d1154 2
a1155 1
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
d1157 5
a1161 5
   ASSERT(dstFormat == MESA_FORMAT_L16A16_UNORM ||
          dstFormat == MESA_FORMAT_A16L16_UNORM ||
	  dstFormat == MESA_FORMAT_R16G16_UNORM ||
          dstFormat == MESA_FORMAT_G16R16_UNORM);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 4);
d1163 1
a1163 12
   {
      /* general path */
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *src = tempImage;
      GLint img, row, col;
      if (!tempImage)
d1165 1
d1168 5
d1174 1
a1174 5
            GLuint *dstUI = (GLuint *) dstRow;
            if (dstFormat == MESA_FORMAT_L16A16_UNORM ||
		dstFormat == MESA_FORMAT_R16G16_UNORM) {
               for (col = 0; col < srcWidth; col++) {
		  GLushort l, a;
d1176 9
a1184 9
		  UNCLAMPED_FLOAT_TO_USHORT(l, src[0]);
		  UNCLAMPED_FLOAT_TO_USHORT(a, src[1]);
		  dstUI[col] = PACK_COLOR_1616(a, l);
		  src += 2;
               }
            }
            else {
               for (col = 0; col < srcWidth; col++) {
		  GLushort l, a;
d1186 2
a1187 1644
		  UNCLAMPED_FLOAT_TO_USHORT(l, src[0]);
		  UNCLAMPED_FLOAT_TO_USHORT(a, src[1]);
		  dstUI[col] = PACK_COLOR_1616_REV(a, l);
		  src += 2;
               }
            }
            dstRow += dstRowStride;
         }
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}


/* Texstore for R16, A16, L16, I16. */
static GLboolean
_mesa_texstore_unorm16(TEXSTORE_PARAMS)
{
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_R_UNORM16 ||
          dstFormat == MESA_FORMAT_A_UNORM16 ||
          dstFormat == MESA_FORMAT_L_UNORM16 ||
          dstFormat == MESA_FORMAT_I_UNORM16);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 2);

   {
      /* general path */
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *src = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLushort *dstUS = (GLushort *) dstRow;
	    for (col = 0; col < srcWidth; col++) {
	       GLushort r;

	       UNCLAMPED_FLOAT_TO_USHORT(r, src[0]);
	       dstUS[col] = r;
	       src += 1;
	    }
            dstRow += dstRowStride;
         }
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}


static GLboolean
_mesa_texstore_rgba_16(TEXSTORE_PARAMS)
{
   ASSERT(dstFormat == MESA_FORMAT_RGBA_UNORM16 ||
          dstFormat == MESA_FORMAT_RGBX_UNORM16);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 8);

   {
      /* general path */
      /* Hardcode GL_RGBA as the base format, which forces alpha to 1.0
       * if the internal format is RGB. */
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 GL_RGBA,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *src = tempImage;
      GLint img, row, col;

      if (!tempImage)
         return GL_FALSE;

      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLushort *dstUS = (GLushort *) dstRow;
            for (col = 0; col < srcWidth; col++) {
               GLushort r, g, b, a;

               UNCLAMPED_FLOAT_TO_USHORT(r, src[0]);
               UNCLAMPED_FLOAT_TO_USHORT(g, src[1]);
               UNCLAMPED_FLOAT_TO_USHORT(b, src[2]);
               UNCLAMPED_FLOAT_TO_USHORT(a, src[3]);
               dstUS[col*4+0] = r;
               dstUS[col*4+1] = g;
               dstUS[col*4+2] = b;
               dstUS[col*4+3] = a;
               src += 4;
            }
            dstRow += dstRowStride;
         }
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}


static GLboolean
_mesa_texstore_signed_rgba_16(TEXSTORE_PARAMS)
{
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_RGB_SNORM16 ||
          dstFormat == MESA_FORMAT_RGBA_SNORM16 ||
          dstFormat == MESA_FORMAT_RGBX_SNORM16);

   {
      /* general path */
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *src = tempImage;
      const GLuint comps = _mesa_get_format_bytes(dstFormat) / 2;
      GLint img, row, col;

      if (!tempImage)
         return GL_FALSE;

      /* Note: tempImage is always float[4] / RGBA.  We convert to 1, 2,
       * 3 or 4 components/pixel here.
       */
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLshort *dstRowS = (GLshort *) dstRow;
            if (dstFormat == MESA_FORMAT_RGBA_SNORM16) {
               for (col = 0; col < srcWidth; col++) {
                  GLuint c;
                  for (c = 0; c < comps; c++) {
                     GLshort p;
                     UNCLAMPED_FLOAT_TO_SHORT(p, src[col * 4 + c]);
                     dstRowS[col * comps + c] = p;
                  }
               }
               dstRow += dstRowStride;
               src += 4 * srcWidth;
            }
            else if (dstFormat == MESA_FORMAT_RGBX_SNORM16) {
               for (col = 0; col < srcWidth; col++) {
                  GLuint c;

                  for (c = 0; c < 3; c++) {
                     GLshort p;
                     UNCLAMPED_FLOAT_TO_SHORT(p, src[col * 3 + c]);
                     dstRowS[col * comps + c] = p;
                  }
                  dstRowS[col * comps + 3] = 32767;
               }
               dstRow += dstRowStride;
               src += 3 * srcWidth;
            }
            else {
               for (col = 0; col < srcWidth; col++) {
                  GLuint c;
                  for (c = 0; c < comps; c++) {
                     GLshort p;
                     UNCLAMPED_FLOAT_TO_SHORT(p, src[col * 3 + c]);
                     dstRowS[col * comps + c] = p;
                  }
               }
               dstRow += dstRowStride;
               src += 3 * srcWidth;
            }
         }
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}


/**
 * Texstore for _mesa_texformat_a8, _mesa_texformat_l8, _mesa_texformat_i8.
 */
static GLboolean
_mesa_texstore_unorm8(TEXSTORE_PARAMS)
{
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_A_UNORM8 ||
          dstFormat == MESA_FORMAT_L_UNORM8 ||
          dstFormat == MESA_FORMAT_I_UNORM8 ||
          dstFormat == MESA_FORMAT_R_UNORM8);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 1);

   if (!ctx->_ImageTransferState &&
       srcType == GL_UNSIGNED_BYTE &&
       can_swizzle(baseInternalFormat) &&
       can_swizzle(srcFormat)) {
      GLubyte dstmap[4];

      /* dstmap - how to swizzle from RGBA to dst format:
       */
      if (dstFormat == MESA_FORMAT_A_UNORM8) {
	 dstmap[0] = 3;
      }
      else {
	 dstmap[0] = 0;
      }
      dstmap[1] = ZERO;		/* ? */
      dstmap[2] = ZERO;		/* ? */
      dstmap[3] = ONE;		/* ? */
      
      _mesa_swizzle_ubyte_image(ctx, dims,
				srcFormat,
				srcType,
				baseInternalFormat,
				dstmap, 1,
				dstRowStride, dstSlices,
				srcWidth, srcHeight, srcDepth, srcAddr,
				srcPacking);      
   }   
   else {
      /* general path */
      const GLubyte *tempImage = _mesa_make_temp_ubyte_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking);
      const GLubyte *src = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            for (col = 0; col < srcWidth; col++) {
               dstRow[col] = src[col];
            }
            dstRow += dstRowStride;
            src += srcWidth;
         }
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}



/**
 * Texstore for _mesa_texformat_ycbcr or _mesa_texformat_ycbcr_REV.
 */
static GLboolean
_mesa_texstore_ycbcr(TEXSTORE_PARAMS)
{
   const GLboolean littleEndian = _mesa_little_endian();

   (void) ctx; (void) dims; (void) baseInternalFormat;

   ASSERT((dstFormat == MESA_FORMAT_YCBCR) ||
          (dstFormat == MESA_FORMAT_YCBCR_REV));
   ASSERT(_mesa_get_format_bytes(dstFormat) == 2);
   ASSERT(ctx->Extensions.MESA_ycbcr_texture);
   ASSERT(srcFormat == GL_YCBCR_MESA);
   ASSERT((srcType == GL_UNSIGNED_SHORT_8_8_MESA) ||
          (srcType == GL_UNSIGNED_SHORT_8_8_REV_MESA));
   ASSERT(baseInternalFormat == GL_YCBCR_MESA);

   /* always just memcpy since no pixel transfer ops apply */
   memcpy_texture(ctx, dims,
                  dstFormat,
                  dstRowStride, dstSlices,
                  srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                  srcAddr, srcPacking);

   /* Check if we need byte swapping */
   /* XXX the logic here _might_ be wrong */
   if (srcPacking->SwapBytes ^
       (srcType == GL_UNSIGNED_SHORT_8_8_REV_MESA) ^
       (dstFormat == MESA_FORMAT_YCBCR_REV) ^
       !littleEndian) {
      GLint img, row;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            _mesa_swap2((GLushort *) dstRow, srcWidth);
            dstRow += dstRowStride;
         }
      }
   }
   return GL_TRUE;
}

static GLboolean
_mesa_texstore_dudv8(TEXSTORE_PARAMS)
{
   const GLboolean littleEndian = _mesa_little_endian();
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_DUDV8);
   ASSERT(texelBytes == 2);
   ASSERT(ctx->Extensions.ATI_envmap_bumpmap);
   ASSERT((srcFormat == GL_DU8DV8_ATI) ||
	  (srcFormat == GL_DUDV_ATI));
   ASSERT(baseInternalFormat == GL_DUDV_ATI);

   if (srcType == GL_BYTE) {
      GLubyte dstmap[4];

      /* dstmap - how to swizzle from RGBA to dst format:
       */
      if (littleEndian) {
	 dstmap[0] = 0;
	 dstmap[1] = 3;
      }
      else {
	 dstmap[0] = 3;
	 dstmap[1] = 0;
      }
      dstmap[2] = ZERO;		/* ? */
      dstmap[3] = ONE;		/* ? */
      
      _mesa_swizzle_ubyte_image(ctx, dims,
				GL_LUMINANCE_ALPHA, /* hack */
				GL_UNSIGNED_BYTE, /* hack */
				GL_LUMINANCE_ALPHA, /* hack */
				dstmap, 2,
				dstRowStride, dstSlices,
				srcWidth, srcHeight, srcDepth, srcAddr,
				srcPacking);      
   }   
   else {
      /* general path - note this is defined for 2d textures only */
      const GLint components = _mesa_components_in_format(baseInternalFormat);
      const GLint srcStride = _mesa_image_row_stride(srcPacking, srcWidth,
                                                     srcFormat, srcType);
      GLbyte *tempImage, *dst, *src;
      GLint row;

      tempImage = malloc(srcWidth * srcHeight * srcDepth
                                          * components * sizeof(GLbyte));
      if (!tempImage)
         return GL_FALSE;

      src = (GLbyte *) _mesa_image_address(dims, srcPacking, srcAddr,
                                           srcWidth, srcHeight,
                                           srcFormat, srcType,
                                           0, 0, 0);

      dst = tempImage;
      for (row = 0; row < srcHeight; row++) {
         _mesa_unpack_dudv_span_byte(ctx, srcWidth, baseInternalFormat,
                                     dst, srcFormat, srcType, src,
                                     srcPacking, 0);
         dst += srcWidth * components;
         src += srcStride;
      }
 
      src = tempImage;
      dst = (GLbyte *) dstSlices[0];
      for (row = 0; row < srcHeight; row++) {
         memcpy(dst, src, srcWidth * texelBytes);
         dst += dstRowStride;
         src += srcWidth * texelBytes;
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}


/**
 * Store a texture in a signed normalized 8-bit format.
 */
static GLboolean
_mesa_texstore_snorm8(TEXSTORE_PARAMS)
{
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_A_SNORM8 ||
          dstFormat == MESA_FORMAT_L_SNORM8 ||
          dstFormat == MESA_FORMAT_I_SNORM8 ||
          dstFormat == MESA_FORMAT_R_SNORM8);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 1);

   {
      /* general path */
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *src = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLbyte *dstRow = (GLbyte *) dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            for (col = 0; col < srcWidth; col++) {
               dstRow[col] = FLOAT_TO_BYTE_TEX(src[col]);
            }
            dstRow += dstRowStride;
            src += srcWidth;
         }
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}


/**
 * Store a texture in a signed normalized two-channel 16-bit format.
 */
static GLboolean
_mesa_texstore_snorm88(TEXSTORE_PARAMS)
{
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_L8A8_SNORM ||
          dstFormat == MESA_FORMAT_G8R8_SNORM ||
          dstFormat == MESA_FORMAT_R8G8_SNORM);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 2);

   {
      /* general path */
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *src = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLbyte *dstRow = (GLbyte *) dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLushort *dst = (GLushort *) dstRow;

            if (dstFormat == MESA_FORMAT_L8A8_SNORM ||
                dstFormat == MESA_FORMAT_R8G8_SNORM) {
               for (col = 0; col < srcWidth; col++) {
                  GLubyte l = FLOAT_TO_BYTE_TEX(src[0]);
                  GLubyte a = FLOAT_TO_BYTE_TEX(src[1]);

                  dst[col] = PACK_COLOR_88_REV(l, a);
                  src += 2;
               }
            } else {
               for (col = 0; col < srcWidth; col++) {
                  GLubyte l = FLOAT_TO_BYTE_TEX(src[0]);
                  GLubyte a = FLOAT_TO_BYTE_TEX(src[1]);

                  dst[col] = PACK_COLOR_88(l, a);
                  src += 2;
               }
            }

            dstRow += dstRowStride;
         }
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}

/* Texstore for signed R16, A16, L16, I16. */
static GLboolean
_mesa_texstore_snorm16(TEXSTORE_PARAMS)
{
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_R_SNORM16 ||
          dstFormat == MESA_FORMAT_A_SNORM16 ||
          dstFormat == MESA_FORMAT_L_SNORM16 ||
          dstFormat == MESA_FORMAT_I_SNORM16);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 2);

   {
      /* general path */
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *src = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLshort *dstUS = (GLshort *) dstRow;
	    for (col = 0; col < srcWidth; col++) {
	       GLushort r;

	       UNCLAMPED_FLOAT_TO_SHORT(r, src[0]);
	       dstUS[col] = r;
	       src += 1;
	    }
            dstRow += dstRowStride;
         }
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}

/**
 * Do texstore for 2-channel, 16-bit/channel, signed normalized formats.
 */
static GLboolean
_mesa_texstore_snorm1616(TEXSTORE_PARAMS)
{
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_LA_SNORM16 ||
          dstFormat == MESA_FORMAT_G16R16_SNORM ||
          dstFormat == MESA_FORMAT_R16G16_SNORM);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 4);

   {
      /* general path */
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *src = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLuint *dst = (GLuint *) dstRow;

            if (dstFormat == MESA_FORMAT_LA_SNORM16 ||
                dstFormat == MESA_FORMAT_R16G16_SNORM) {
               for (col = 0; col < srcWidth; col++) {
                  GLushort l, a;

                  UNCLAMPED_FLOAT_TO_SHORT(l, src[0]);
                  UNCLAMPED_FLOAT_TO_SHORT(a, src[1]);
                  dst[col] = PACK_COLOR_1616_REV(l, a);
                  src += 2;
               }
            } else {
               for (col = 0; col < srcWidth; col++) {
                  GLushort l, a;

                  UNCLAMPED_FLOAT_TO_SHORT(l, src[0]);
                  UNCLAMPED_FLOAT_TO_SHORT(a, src[1]);
                  dst[col] = PACK_COLOR_1616_REV(l, a);
                  src += 2;
               }
            }

            dstRow += dstRowStride;
         }
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}

/**
 * Store a texture in MESA_FORMAT_X8B8G8R8_SNORM or
 * MESA_FORMAT_R8G8B8X8_SNORM.
 */
static GLboolean
_mesa_texstore_signed_rgbx8888(TEXSTORE_PARAMS)
{
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_X8B8G8R8_SNORM ||
          dstFormat == MESA_FORMAT_R8G8B8X8_SNORM);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 4);

   {
      /* general path */
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *srcRow = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLbyte *dstRow = (GLbyte *) dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLbyte *dst = dstRow;
            if (dstFormat == MESA_FORMAT_X8B8G8R8_SNORM) {
               for (col = 0; col < srcWidth; col++) {
                  dst[3] = FLOAT_TO_BYTE_TEX(srcRow[RCOMP]);
                  dst[2] = FLOAT_TO_BYTE_TEX(srcRow[GCOMP]);
                  dst[1] = FLOAT_TO_BYTE_TEX(srcRow[BCOMP]);
                  dst[0] = 127;
                  srcRow += 3;
                  dst += 4;
               }
            }
            else {
               for (col = 0; col < srcWidth; col++) {
                  dst[0] = FLOAT_TO_BYTE_TEX(srcRow[RCOMP]);
                  dst[1] = FLOAT_TO_BYTE_TEX(srcRow[GCOMP]);
                  dst[2] = FLOAT_TO_BYTE_TEX(srcRow[BCOMP]);
                  dst[3] = 127;
                  srcRow += 3;
                  dst += 4;
               }
            }
            dstRow += dstRowStride;
         }
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}



/**
 * Store a texture in MESA_FORMAT_A8B8G8R8_SNORM or
 * MESA_FORMAT_R8G8B8A8_SNORM
 */
static GLboolean
_mesa_texstore_signed_rgba8888(TEXSTORE_PARAMS)
{
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_A8B8G8R8_SNORM ||
          dstFormat == MESA_FORMAT_R8G8B8A8_SNORM);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 4);

   {
      /* general path */
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *srcRow = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLbyte *dstRow = (GLbyte *) dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLbyte *dst = dstRow;
            if (dstFormat == MESA_FORMAT_A8B8G8R8_SNORM) {
               for (col = 0; col < srcWidth; col++) {
                  dst[3] = FLOAT_TO_BYTE_TEX(srcRow[RCOMP]);
                  dst[2] = FLOAT_TO_BYTE_TEX(srcRow[GCOMP]);
                  dst[1] = FLOAT_TO_BYTE_TEX(srcRow[BCOMP]);
                  dst[0] = FLOAT_TO_BYTE_TEX(srcRow[ACOMP]);
                  srcRow += 4;
                  dst += 4;
               }
            }
            else {
               for (col = 0; col < srcWidth; col++) {
                  dst[0] = FLOAT_TO_BYTE_TEX(srcRow[RCOMP]);
                  dst[1] = FLOAT_TO_BYTE_TEX(srcRow[GCOMP]);
                  dst[2] = FLOAT_TO_BYTE_TEX(srcRow[BCOMP]);
                  dst[3] = FLOAT_TO_BYTE_TEX(srcRow[ACOMP]);
                  srcRow += 4;
                  dst += 4;
               }
            }
            dstRow += dstRowStride;
         }
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}


/**
 * Store a combined depth/stencil texture image.
 */
static GLboolean
_mesa_texstore_z24_s8(TEXSTORE_PARAMS)
{
   const GLuint depthScale = 0xffffff;
   const GLint srcRowStride
      = _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType);
   GLint img, row;
   GLuint *depth = malloc(srcWidth * sizeof(GLuint));
   GLubyte *stencil = malloc(srcWidth * sizeof(GLubyte));

   ASSERT(dstFormat == MESA_FORMAT_S8_UINT_Z24_UNORM);
   ASSERT(srcFormat == GL_DEPTH_STENCIL_EXT ||
          srcFormat == GL_DEPTH_COMPONENT ||
          srcFormat == GL_STENCIL_INDEX);
   ASSERT(srcFormat != GL_DEPTH_STENCIL_EXT ||
          srcType == GL_UNSIGNED_INT_24_8_EXT ||
          srcType == GL_FLOAT_32_UNSIGNED_INT_24_8_REV);

   if (!depth || !stencil) {
      free(depth);
      free(stencil);
      return GL_FALSE;
   }

   /* In case we only upload depth we need to preserve the stencil */
   for (img = 0; img < srcDepth; img++) {
      GLuint *dstRow = (GLuint *) dstSlices[img];
      const GLubyte *src
         = (const GLubyte *) _mesa_image_address(dims, srcPacking, srcAddr,
               srcWidth, srcHeight,
               srcFormat, srcType,
               img, 0, 0);
      for (row = 0; row < srcHeight; row++) {
         GLint i;
         GLboolean keepdepth = GL_FALSE, keepstencil = GL_FALSE;

         if (srcFormat == GL_DEPTH_COMPONENT) { /* preserve stencil */
            keepstencil = GL_TRUE;
         }
         else if (srcFormat == GL_STENCIL_INDEX) { /* preserve depth */
            keepdepth = GL_TRUE;
         }

         if (keepdepth == GL_FALSE)
            /* the 24 depth bits will be in the low position: */
            _mesa_unpack_depth_span(ctx, srcWidth,
                                    GL_UNSIGNED_INT, /* dst type */
                                    keepstencil ? depth : dstRow, /* dst addr */
                                    depthScale,
                                    srcType, src, srcPacking);

         if (keepstencil == GL_FALSE)
            /* get the 8-bit stencil values */
            _mesa_unpack_stencil_span(ctx, srcWidth,
                                      GL_UNSIGNED_BYTE, /* dst type */
                                      stencil, /* dst addr */
                                      srcType, src, srcPacking,
                                      ctx->_ImageTransferState);

         for (i = 0; i < srcWidth; i++) {
            if (keepstencil)
               dstRow[i] = depth[i] << 8 | (dstRow[i] & 0x000000FF);
            else
               dstRow[i] = (dstRow[i] & 0xFFFFFF00) | (stencil[i] & 0xFF);
         }
         src += srcRowStride;
         dstRow += dstRowStride / sizeof(GLuint);
      }
   }

   free(depth);
   free(stencil);
   return GL_TRUE;
}


/**
 * Store a combined depth/stencil texture image.
 */
static GLboolean
_mesa_texstore_s8_z24(TEXSTORE_PARAMS)
{
   const GLuint depthScale = 0xffffff;
   const GLint srcRowStride
      = _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType);
   GLint img, row;
   GLuint *depth;
   GLubyte *stencil;

   ASSERT(dstFormat == MESA_FORMAT_Z24_UNORM_S8_UINT);
   ASSERT(srcFormat == GL_DEPTH_STENCIL_EXT ||
          srcFormat == GL_DEPTH_COMPONENT ||
          srcFormat == GL_STENCIL_INDEX);
   ASSERT(srcFormat != GL_DEPTH_STENCIL_EXT ||
          srcType == GL_UNSIGNED_INT_24_8_EXT ||
          srcType == GL_FLOAT_32_UNSIGNED_INT_24_8_REV);

   depth = malloc(srcWidth * sizeof(GLuint));
   stencil = malloc(srcWidth * sizeof(GLubyte));

   if (!depth || !stencil) {
      free(depth);
      free(stencil);
      return GL_FALSE;
   }

   for (img = 0; img < srcDepth; img++) {
      GLuint *dstRow = (GLuint *) dstSlices[img];
      const GLubyte *src
	 = (const GLubyte *) _mesa_image_address(dims, srcPacking, srcAddr,
						srcWidth, srcHeight,
						srcFormat, srcType,
						img, 0, 0);
      for (row = 0; row < srcHeight; row++) {
	 GLint i;
	 GLboolean keepdepth = GL_FALSE, keepstencil = GL_FALSE;
	 
	 if (srcFormat == GL_DEPTH_COMPONENT) { /* preserve stencil */
	    keepstencil = GL_TRUE;
	 }
         else if (srcFormat == GL_STENCIL_INDEX) { /* preserve depth */
	    keepdepth = GL_TRUE;
	 }

	 if (keepdepth == GL_FALSE)
	    /* the 24 depth bits will be in the low position: */
	    _mesa_unpack_depth_span(ctx, srcWidth,
				    GL_UNSIGNED_INT, /* dst type */
				    keepstencil ? depth : dstRow, /* dst addr */
				    depthScale,
				    srcType, src, srcPacking);	 

	 if (keepstencil == GL_FALSE)
	    /* get the 8-bit stencil values */
	    _mesa_unpack_stencil_span(ctx, srcWidth,
				      GL_UNSIGNED_BYTE, /* dst type */
				      stencil, /* dst addr */
				      srcType, src, srcPacking,
				      ctx->_ImageTransferState);

	 /* merge stencil values into depth values */
	 for (i = 0; i < srcWidth; i++) {
	    if (keepstencil)
	       dstRow[i] = depth[i] | (dstRow[i] & 0xFF000000);
	    else
	       dstRow[i] = (dstRow[i] & 0xFFFFFF) | (stencil[i] << 24);

	 }
	 src += srcRowStride;
	 dstRow += dstRowStride / sizeof(GLuint);
      }
   }

   free(depth);
   free(stencil);

   return GL_TRUE;
}


/**
 * Store simple 8-bit/value stencil texture data.
 */
static GLboolean
_mesa_texstore_s8(TEXSTORE_PARAMS)
{
   ASSERT(dstFormat == MESA_FORMAT_S_UINT8);
   ASSERT(srcFormat == GL_STENCIL_INDEX);

   {
      const GLint srcRowStride
	 = _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType);
      GLint img, row;
      GLubyte *stencil = malloc(srcWidth * sizeof(GLubyte));

      if (!stencil)
         return GL_FALSE;

      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         const GLubyte *src
            = (const GLubyte *) _mesa_image_address(dims, srcPacking, srcAddr,
                                                   srcWidth, srcHeight,
                                                   srcFormat, srcType,
                                                   img, 0, 0);
         for (row = 0; row < srcHeight; row++) {
            GLint i;

            /* get the 8-bit stencil values */
            _mesa_unpack_stencil_span(ctx, srcWidth,
                                      GL_UNSIGNED_BYTE, /* dst type */
                                      stencil, /* dst addr */
                                      srcType, src, srcPacking,
                                      ctx->_ImageTransferState);
            /* merge stencil values into depth values */
            for (i = 0; i < srcWidth; i++)
               dstRow[i] = stencil[i];

            src += srcRowStride;
            dstRow += dstRowStride / sizeof(GLubyte);
         }
      }

      free(stencil);
   }

   return GL_TRUE;
}


/**
 * Store an image in any of the formats:
 *   _mesa_texformat_rgba_float32
 *   _mesa_texformat_rgb_float32
 *   _mesa_texformat_alpha_float32
 *   _mesa_texformat_luminance_float32
 *   _mesa_texformat_luminance_alpha_float32
 *   _mesa_texformat_intensity_float32
 */
static GLboolean
_mesa_texstore_rgba_float32(TEXSTORE_PARAMS)
{
   GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
   GLint components = _mesa_components_in_format(baseFormat);

   /* this forces alpha to 1 in _mesa_make_temp_float_image */
   if (dstFormat == MESA_FORMAT_RGBX_FLOAT32) {
      baseFormat = GL_RGBA;
      components = 4;
   }

   ASSERT(dstFormat == MESA_FORMAT_RGBA_FLOAT32 ||
          dstFormat == MESA_FORMAT_RGB_FLOAT32 ||
          dstFormat == MESA_FORMAT_A_FLOAT32 ||
          dstFormat == MESA_FORMAT_L_FLOAT32 ||
          dstFormat == MESA_FORMAT_LA_FLOAT32 ||
          dstFormat == MESA_FORMAT_I_FLOAT32 ||
          dstFormat == MESA_FORMAT_R_FLOAT32 ||
          dstFormat == MESA_FORMAT_RG_FLOAT32 ||
          dstFormat == MESA_FORMAT_RGBX_FLOAT32);
   ASSERT(baseInternalFormat == GL_RGBA ||
          baseInternalFormat == GL_RGB ||
          baseInternalFormat == GL_ALPHA ||
          baseInternalFormat == GL_LUMINANCE ||
          baseInternalFormat == GL_LUMINANCE_ALPHA ||
          baseInternalFormat == GL_INTENSITY ||
          baseInternalFormat == GL_RED ||
          baseInternalFormat == GL_RG);
   ASSERT(_mesa_get_format_bytes(dstFormat) == components * sizeof(GLfloat));

   {
      /* general path */
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *srcRow = tempImage;
      GLint bytesPerRow;
      GLint img, row;
      if (!tempImage)
         return GL_FALSE;
      bytesPerRow = srcWidth * components * sizeof(GLfloat);
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            memcpy(dstRow, srcRow, bytesPerRow);
            dstRow += dstRowStride;
            srcRow += srcWidth * components;
         }
      }

      free((void *) tempImage);
   }
   return GL_TRUE;
}



/**
 * As above, but store 16-bit floats.
 */
static GLboolean
_mesa_texstore_rgba_float16(TEXSTORE_PARAMS)
{
   GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
   GLint components = _mesa_components_in_format(baseFormat);

   /* this forces alpha to 1 in _mesa_make_temp_float_image */
   if (dstFormat == MESA_FORMAT_RGBX_FLOAT16) {
      baseFormat = GL_RGBA;
      components = 4;
   }

   ASSERT(dstFormat == MESA_FORMAT_RGBA_FLOAT16 ||
          dstFormat == MESA_FORMAT_RGB_FLOAT16 ||
          dstFormat == MESA_FORMAT_A_FLOAT16 ||
          dstFormat == MESA_FORMAT_L_FLOAT16 ||
          dstFormat == MESA_FORMAT_LA_FLOAT16 ||
          dstFormat == MESA_FORMAT_I_FLOAT16 ||
          dstFormat == MESA_FORMAT_R_FLOAT16 ||
          dstFormat == MESA_FORMAT_RG_FLOAT16 ||
          dstFormat == MESA_FORMAT_RGBX_FLOAT16);
   ASSERT(baseInternalFormat == GL_RGBA ||
          baseInternalFormat == GL_RGB ||
          baseInternalFormat == GL_ALPHA ||
          baseInternalFormat == GL_LUMINANCE ||
          baseInternalFormat == GL_LUMINANCE_ALPHA ||
          baseInternalFormat == GL_INTENSITY ||
          baseInternalFormat == GL_RED ||
          baseInternalFormat == GL_RG);
   ASSERT(_mesa_get_format_bytes(dstFormat) == components * sizeof(GLhalfARB));

   {
      /* general path */
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *src = tempImage;
      GLint img, row;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLhalfARB *dstTexel = (GLhalfARB *) dstRow;
            GLint i;
            for (i = 0; i < srcWidth * components; i++) {
               dstTexel[i] = _mesa_float_to_half(src[i]);
            }
            dstRow += dstRowStride;
            src += srcWidth * components;
         }
      }

      free((void *) tempImage);
   }
   return GL_TRUE;
}


/* non-normalized, signed int8 */
static GLboolean
_mesa_texstore_rgba_int8(TEXSTORE_PARAMS)
{
   GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
   GLint components = _mesa_components_in_format(baseFormat);

   /* this forces alpha to 1 in make_temp_uint_image */
   if (dstFormat == MESA_FORMAT_RGBX_SINT8) {
      baseFormat = GL_RGBA;
      components = 4;
   }

   ASSERT(dstFormat == MESA_FORMAT_R_SINT8 ||
          dstFormat == MESA_FORMAT_RG_SINT8 ||
          dstFormat == MESA_FORMAT_RGB_SINT8 ||
          dstFormat == MESA_FORMAT_RGBA_SINT8 ||
          dstFormat == MESA_FORMAT_A_SINT8 ||
          dstFormat == MESA_FORMAT_I_SINT8 ||
          dstFormat == MESA_FORMAT_L_SINT8 ||
          dstFormat == MESA_FORMAT_LA_SINT8 ||
          dstFormat == MESA_FORMAT_RGBX_SINT8);
   ASSERT(baseInternalFormat == GL_RGBA ||
          baseInternalFormat == GL_RGB ||
          baseInternalFormat == GL_RG ||
          baseInternalFormat == GL_RED ||
          baseInternalFormat == GL_ALPHA ||
          baseInternalFormat == GL_LUMINANCE ||
          baseInternalFormat == GL_LUMINANCE_ALPHA ||
          baseInternalFormat == GL_INTENSITY);
   ASSERT(_mesa_get_format_bytes(dstFormat) == components * sizeof(GLbyte));

   {
      /* general path */
      const GLuint *tempImage = make_temp_uint_image(ctx, dims,
						     baseInternalFormat,
						     baseFormat,
						     srcWidth, srcHeight, srcDepth,
						     srcFormat, srcType,
						     srcAddr,
						     srcPacking);
      const GLuint *src = tempImage;
      GLint img, row;
      GLboolean is_unsigned = _mesa_is_type_unsigned(srcType);
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLbyte *dstTexel = (GLbyte *) dstRow;
            GLint i;
            if (is_unsigned) {
               for (i = 0; i < srcWidth * components; i++) {
                  dstTexel[i] = (GLbyte) MIN2(src[i], 0x7f);
               }
            } else {
               for (i = 0; i < srcWidth * components; i++) {
                  dstTexel[i] = (GLbyte) CLAMP((GLint) src[i], -0x80, 0x7f);
               }
            }
            dstRow += dstRowStride;
            src += srcWidth * components;
         }
      }

      free((void *) tempImage);
   }
   return GL_TRUE;
}


/* non-normalized, signed int16 */
static GLboolean
_mesa_texstore_rgba_int16(TEXSTORE_PARAMS)
{
   GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
   GLint components = _mesa_components_in_format(baseFormat);

   /* this forces alpha to 1 in make_temp_uint_image */
   if (dstFormat == MESA_FORMAT_RGBX_SINT16) {
      baseFormat = GL_RGBA;
      components = 4;
   }

   ASSERT(dstFormat == MESA_FORMAT_R_SINT16 ||
          dstFormat == MESA_FORMAT_RG_SINT16 ||
          dstFormat == MESA_FORMAT_RGB_SINT16 ||
          dstFormat == MESA_FORMAT_RGBA_SINT16 ||
          dstFormat == MESA_FORMAT_A_SINT16 ||
          dstFormat == MESA_FORMAT_L_SINT16 ||
          dstFormat == MESA_FORMAT_I_SINT16 ||
          dstFormat == MESA_FORMAT_LA_SINT16 ||
          dstFormat == MESA_FORMAT_RGBX_SINT16);
   ASSERT(baseInternalFormat == GL_RGBA ||
          baseInternalFormat == GL_RGB ||
          baseInternalFormat == GL_RG ||
          baseInternalFormat == GL_RED ||
          baseInternalFormat == GL_ALPHA ||
          baseInternalFormat == GL_LUMINANCE ||
          baseInternalFormat == GL_LUMINANCE_ALPHA ||
          baseInternalFormat == GL_INTENSITY);
   ASSERT(_mesa_get_format_bytes(dstFormat) == components * sizeof(GLshort));

   {
      /* general path */
      const GLuint *tempImage = make_temp_uint_image(ctx, dims,
						     baseInternalFormat,
						     baseFormat,
						     srcWidth, srcHeight, srcDepth,
						     srcFormat, srcType,
						     srcAddr,
						     srcPacking);
      const GLuint *src = tempImage;
      GLint img, row;
      GLboolean is_unsigned = _mesa_is_type_unsigned(srcType);
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLshort *dstTexel = (GLshort *) dstRow;
            GLint i;
            if (is_unsigned) {
               for (i = 0; i < srcWidth * components; i++) {
                  dstTexel[i] = (GLshort) MIN2(src[i], 0x7fff);
               }
            } else {
               for (i = 0; i < srcWidth * components; i++) {
                  dstTexel[i] = (GLshort)CLAMP((GLint) src[i], -0x8000, 0x7fff);
               }
            }
            dstRow += dstRowStride;
            src += srcWidth * components;
         }
      }

      free((void *) tempImage);
   }
   return GL_TRUE;
}


/* non-normalized, signed int32 */
static GLboolean
_mesa_texstore_rgba_int32(TEXSTORE_PARAMS)
{
   GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
   GLint components = _mesa_components_in_format(baseFormat);

   /* this forces alpha to 1 in make_temp_uint_image */
   if (dstFormat == MESA_FORMAT_RGBX_SINT32) {
      baseFormat = GL_RGBA;
      components = 4;
   }

   ASSERT(dstFormat == MESA_FORMAT_R_SINT32 ||
          dstFormat == MESA_FORMAT_RG_SINT32 ||
          dstFormat == MESA_FORMAT_RGB_SINT32 ||
          dstFormat == MESA_FORMAT_RGBA_SINT32 ||
          dstFormat == MESA_FORMAT_A_SINT32 ||
          dstFormat == MESA_FORMAT_I_SINT32 ||
          dstFormat == MESA_FORMAT_L_SINT32 ||
          dstFormat == MESA_FORMAT_LA_SINT32 ||
          dstFormat == MESA_FORMAT_RGBX_SINT32);
   ASSERT(baseInternalFormat == GL_RGBA ||
          baseInternalFormat == GL_RGB ||
          baseInternalFormat == GL_RG ||
          baseInternalFormat == GL_RED ||
          baseInternalFormat == GL_ALPHA ||
          baseInternalFormat == GL_LUMINANCE ||
          baseInternalFormat == GL_LUMINANCE_ALPHA ||
          baseInternalFormat == GL_INTENSITY);
   ASSERT(_mesa_get_format_bytes(dstFormat) == components * sizeof(GLint));

   {
      /* general path */
      const GLuint *tempImage = make_temp_uint_image(ctx, dims,
						     baseInternalFormat,
						     baseFormat,
						     srcWidth, srcHeight, srcDepth,
						     srcFormat, srcType,
						     srcAddr,
						     srcPacking);
      const GLuint *src = tempImage;
      GLint img, row;
      GLboolean is_unsigned = _mesa_is_type_unsigned(srcType);
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLint *dstTexel = (GLint *) dstRow;
            GLint i;
            if (is_unsigned) {
               for (i = 0; i < srcWidth * components; i++) {
                  dstTexel[i] = (GLint) MIN2(src[i], 0x7fffffff);
               }
            } else {
               for (i = 0; i < srcWidth * components; i++) {
                  dstTexel[i] = (GLint) src[i];
               }
            }
            dstRow += dstRowStride;
            src += srcWidth * components;
         }
      }

      free((void *) tempImage);
   }
   return GL_TRUE;
}


/* non-normalized, unsigned int8 */
static GLboolean
_mesa_texstore_rgba_uint8(TEXSTORE_PARAMS)
{
   GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
   GLint components = _mesa_components_in_format(baseFormat);

   /* this forces alpha to 1 in make_temp_uint_image */
   if (dstFormat == MESA_FORMAT_RGBX_UINT8) {
      baseFormat = GL_RGBA;
      components = 4;
   }

   ASSERT(dstFormat == MESA_FORMAT_R_UINT8 ||
          dstFormat == MESA_FORMAT_RG_UINT8 ||
          dstFormat == MESA_FORMAT_RGB_UINT8 ||
          dstFormat == MESA_FORMAT_RGBA_UINT8 ||
          dstFormat == MESA_FORMAT_A_UINT8 ||
          dstFormat == MESA_FORMAT_I_UINT8 ||
          dstFormat == MESA_FORMAT_L_UINT8 ||
          dstFormat == MESA_FORMAT_LA_UINT8 ||
          dstFormat == MESA_FORMAT_RGBX_UINT8);
   ASSERT(baseInternalFormat == GL_RGBA ||
          baseInternalFormat == GL_RGB ||
          baseInternalFormat == GL_RG ||
          baseInternalFormat == GL_RED ||
          baseInternalFormat == GL_ALPHA ||
          baseInternalFormat == GL_LUMINANCE ||
          baseInternalFormat == GL_LUMINANCE_ALPHA ||
          baseInternalFormat == GL_INTENSITY);
   ASSERT(_mesa_get_format_bytes(dstFormat) == components * sizeof(GLubyte));

   {
      /* general path */
      const GLuint *tempImage =
         make_temp_uint_image(ctx, dims, baseInternalFormat, baseFormat,
                              srcWidth, srcHeight, srcDepth,
                              srcFormat, srcType, srcAddr, srcPacking);
      const GLuint *src = tempImage;
      GLint img, row;
      GLboolean is_unsigned = _mesa_is_type_unsigned(srcType);
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLubyte *dstTexel = (GLubyte *) dstRow;
            GLint i;
            if (is_unsigned) {
               for (i = 0; i < srcWidth * components; i++) {
                  dstTexel[i] = (GLubyte) MIN2(src[i], 0xff);
               }
            } else {
               for (i = 0; i < srcWidth * components; i++) {
                  dstTexel[i] = (GLubyte) CLAMP((GLint) src[i], 0, 0xff);
               }
            }
            dstRow += dstRowStride;
            src += srcWidth * components;
         }
      }

      free((void *) tempImage);
   }
   return GL_TRUE;
}


/* non-normalized, unsigned int16 */
static GLboolean
_mesa_texstore_rgba_uint16(TEXSTORE_PARAMS)
{
   GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
   GLint components = _mesa_components_in_format(baseFormat);

   /* this forces alpha to 1 in make_temp_uint_image */
   if (dstFormat == MESA_FORMAT_RGBX_UINT16) {
      baseFormat = GL_RGBA;
      components = 4;
   }

   ASSERT(dstFormat == MESA_FORMAT_R_UINT16 ||
          dstFormat == MESA_FORMAT_RG_UINT16 ||
          dstFormat == MESA_FORMAT_RGB_UINT16 ||
          dstFormat == MESA_FORMAT_RGBA_UINT16 ||
          dstFormat == MESA_FORMAT_A_UINT16 ||
          dstFormat == MESA_FORMAT_I_UINT16 ||
          dstFormat == MESA_FORMAT_L_UINT16 ||
          dstFormat == MESA_FORMAT_LA_UINT16 ||
          dstFormat == MESA_FORMAT_RGBX_UINT16);
   ASSERT(baseInternalFormat == GL_RGBA ||
          baseInternalFormat == GL_RGB ||
          baseInternalFormat == GL_RG ||
          baseInternalFormat == GL_RED ||
          baseInternalFormat == GL_ALPHA ||
          baseInternalFormat == GL_LUMINANCE ||
          baseInternalFormat == GL_LUMINANCE_ALPHA ||
          baseInternalFormat == GL_INTENSITY);
   ASSERT(_mesa_get_format_bytes(dstFormat) == components * sizeof(GLushort));

   {
      /* general path */
      const GLuint *tempImage =
         make_temp_uint_image(ctx, dims, baseInternalFormat, baseFormat,
                              srcWidth, srcHeight, srcDepth,
                              srcFormat, srcType, srcAddr, srcPacking);
      const GLuint *src = tempImage;
      GLint img, row;
      GLboolean is_unsigned = _mesa_is_type_unsigned(srcType);
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLushort *dstTexel = (GLushort *) dstRow;
            GLint i;
            if (is_unsigned) {
               for (i = 0; i < srcWidth * components; i++) {
                  dstTexel[i] = (GLushort) MIN2(src[i], 0xffff);
              }
            } else {
               for (i = 0; i < srcWidth * components; i++) {
                  dstTexel[i] = (GLushort) CLAMP((GLint) src[i], 0, 0xffff);
               }
            }
            dstRow += dstRowStride;
            src += srcWidth * components;
         }
      }

      free((void *) tempImage);
   }
   return GL_TRUE;
}


/* non-normalized, unsigned int32 */
static GLboolean
_mesa_texstore_rgba_uint32(TEXSTORE_PARAMS)
{
   GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
   GLint components = _mesa_components_in_format(baseFormat);

   /* this forces alpha to 1 in make_temp_uint_image */
   if (dstFormat == MESA_FORMAT_RGBX_UINT32) {
      baseFormat = GL_RGBA;
      components = 4;
   }

   ASSERT(dstFormat == MESA_FORMAT_R_UINT32 ||
          dstFormat == MESA_FORMAT_RG_UINT32 ||
          dstFormat == MESA_FORMAT_RGB_UINT32 ||
          dstFormat == MESA_FORMAT_RGBA_UINT32 ||
          dstFormat == MESA_FORMAT_A_UINT32 ||
          dstFormat == MESA_FORMAT_I_UINT32 ||
          dstFormat == MESA_FORMAT_L_UINT32 ||
          dstFormat == MESA_FORMAT_LA_UINT32 ||
          dstFormat == MESA_FORMAT_RGBX_UINT32);
   ASSERT(baseInternalFormat == GL_RGBA ||
          baseInternalFormat == GL_RGB ||
          baseInternalFormat == GL_RG ||
          baseInternalFormat == GL_RED ||
          baseInternalFormat == GL_ALPHA ||
          baseInternalFormat == GL_LUMINANCE ||
          baseInternalFormat == GL_LUMINANCE_ALPHA ||
          baseInternalFormat == GL_INTENSITY);
   ASSERT(_mesa_get_format_bytes(dstFormat) == components * sizeof(GLuint));

   {
      /* general path */
      const GLuint *tempImage =
         make_temp_uint_image(ctx, dims, baseInternalFormat, baseFormat,
                              srcWidth, srcHeight, srcDepth,
                              srcFormat, srcType, srcAddr, srcPacking);
      const GLuint *src = tempImage;
      GLboolean is_unsigned = _mesa_is_type_unsigned(srcType);
      GLint img, row;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLuint *dstTexel = (GLuint *) dstRow;
            GLint i;
            if (is_unsigned) {
               for (i = 0; i < srcWidth * components; i++) {
                  dstTexel[i] = src[i];
               }
            } else {
               for (i = 0; i < srcWidth * components; i++) {
                  dstTexel[i] = MAX2((GLint) src[i], 0);
               }
            }
            dstRow += dstRowStride;
            src += srcWidth * components;
         }
      }

      free((void *) tempImage);
   }
   return GL_TRUE;
}


static GLboolean
_mesa_texstore_srgb8(TEXSTORE_PARAMS)
{
   mesa_format newDstFormat;
   GLboolean k;

   ASSERT(dstFormat == MESA_FORMAT_BGR_SRGB8);

   /* reuse normal rgb texstore code */
   newDstFormat = MESA_FORMAT_BGR_UNORM8;

   k = _mesa_texstore_rgb888(ctx, dims, baseInternalFormat,
                             newDstFormat,
                             dstRowStride, dstSlices,
                             srcWidth, srcHeight, srcDepth,
                             srcFormat, srcType,
                             srcAddr, srcPacking);
   return k;
}


static GLboolean
_mesa_texstore_srgba8(TEXSTORE_PARAMS)
{
   mesa_format newDstFormat;
   GLboolean k;

   ASSERT(dstFormat == MESA_FORMAT_A8B8G8R8_SRGB ||
          dstFormat == MESA_FORMAT_R8G8B8X8_SRGB ||
          dstFormat == MESA_FORMAT_R8G8B8A8_SRGB);

   newDstFormat = _mesa_get_srgb_format_linear(dstFormat);

   k = _mesa_texstore_rgba8888(ctx, dims, baseInternalFormat,
                               newDstFormat,
                               dstRowStride, dstSlices,
                               srcWidth, srcHeight, srcDepth,
                               srcFormat, srcType,
                               srcAddr, srcPacking);
   return k;
}


static GLboolean
_mesa_texstore_sargb8(TEXSTORE_PARAMS)
{
   mesa_format newDstFormat;
   GLboolean k;

   assert(dstFormat == MESA_FORMAT_B8G8R8A8_SRGB ||
          dstFormat == MESA_FORMAT_B8G8R8X8_SRGB);

   newDstFormat = _mesa_get_srgb_format_linear(dstFormat);

   k = _mesa_texstore_argb8888(ctx, dims, baseInternalFormat,
                               newDstFormat,
                               dstRowStride, dstSlices,
                               srcWidth, srcHeight, srcDepth,
                               srcFormat, srcType,
                               srcAddr, srcPacking);
   return k;
}


static GLboolean
_mesa_texstore_sl8(TEXSTORE_PARAMS)
{
   mesa_format newDstFormat;
   GLboolean k;

   ASSERT(dstFormat == MESA_FORMAT_L_SRGB8);

   newDstFormat = MESA_FORMAT_L_UNORM8;

   /* _mesa_textore_a8 handles luminance8 too */
   k = _mesa_texstore_unorm8(ctx, dims, baseInternalFormat,
                             newDstFormat,
                             dstRowStride, dstSlices,
                             srcWidth, srcHeight, srcDepth,
                             srcFormat, srcType,
                             srcAddr, srcPacking);
   return k;
}


static GLboolean
_mesa_texstore_sla8(TEXSTORE_PARAMS)
{
   mesa_format newDstFormat;
   GLboolean k;

   ASSERT(dstFormat == MESA_FORMAT_L8A8_SRGB);

   /* reuse normal luminance/alpha texstore code */
   newDstFormat = MESA_FORMAT_L8A8_UNORM;

   k = _mesa_texstore_unorm88(ctx, dims, baseInternalFormat,
			      newDstFormat,
			      dstRowStride, dstSlices,
			      srcWidth, srcHeight, srcDepth,
			      srcFormat, srcType,
			      srcAddr, srcPacking);
   return k;
}

static GLboolean
_mesa_texstore_rgb9_e5(TEXSTORE_PARAMS)
{
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_R9G9B9E5_FLOAT);
   ASSERT(baseInternalFormat == GL_RGB);

   {
      /* general path */
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *srcRow = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLuint *dstUI = (GLuint*)dstRow;
            for (col = 0; col < srcWidth; col++) {
               dstUI[col] = float3_to_rgb9e5(&srcRow[col * 3]);
            }
            dstRow += dstRowStride;
            srcRow += srcWidth * 3;
         }
      }

      free((void *) tempImage);
   }
   return GL_TRUE;
}

static GLboolean
_mesa_texstore_r11_g11_b10f(TEXSTORE_PARAMS)
{
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_R11G11B10_FLOAT);
   ASSERT(baseInternalFormat == GL_RGB);

   {
      /* general path */
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *srcRow = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLuint *dstUI = (GLuint*)dstRow;
            for (col = 0; col < srcWidth; col++) {
               dstUI[col] = float3_to_r11g11b10f(&srcRow[col * 3]);
            }
            dstRow += dstRowStride;
            srcRow += srcWidth * 3;
d1191 1
a1191 1
      free((void *) tempImage);
d1193 1
d1359 1
d1361 1
a1361 1
_mesa_texstore_abgr2101010(TEXSTORE_PARAMS)
d1363 2
a1364 1
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
d1366 2
a1367 2
   ASSERT(dstFormat == MESA_FORMAT_R10G10B10A2_UNORM);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 4);
d1369 9
a1377 15
   {
      /* general path */
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *src = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
d1379 2
a1380 4
         for (row = 0; row < srcHeight; row++) {
            GLuint *dstUI = (GLuint *) dstRow;
            for (col = 0; col < srcWidth; col++) {
               GLushort a,r,g,b;
d1382 5
a1386 13
               UNCLAMPED_FLOAT_TO_USHORT(a, src[ACOMP]);
               UNCLAMPED_FLOAT_TO_USHORT(r, src[RCOMP]);
               UNCLAMPED_FLOAT_TO_USHORT(g, src[GCOMP]);
               UNCLAMPED_FLOAT_TO_USHORT(b, src[BCOMP]);
               dstUI[col] = PACK_COLOR_2101010_US(a, b, g, r);
               src += 4;
            }
            dstRow += dstRowStride;
         }
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
d1390 1
a1390 22
_mesa_texstore_null(TEXSTORE_PARAMS)
{
   (void) ctx; (void) dims;
   (void) baseInternalFormat;
   (void) dstFormat;
   (void) dstRowStride; (void) dstSlices,
   (void) srcWidth; (void) srcHeight; (void) srcDepth;
   (void) srcFormat; (void) srcType;
   (void) srcAddr;
   (void) srcPacking;

   /* should never happen */
   _mesa_problem(NULL, "_mesa_texstore_null() is called");
   return GL_FALSE;
}


/**
 * Return the StoreTexImageFunc pointer to store an image in the given format.
 */
static StoreTexImageFunc
_mesa_get_texstore_func(mesa_format format)
d1396 1
a1396 1
      table[MESA_FORMAT_NONE] = _mesa_texstore_null;
a1397 50
      table[MESA_FORMAT_A8B8G8R8_UNORM] = _mesa_texstore_rgba8888;
      table[MESA_FORMAT_R8G8B8A8_UNORM] = _mesa_texstore_rgba8888;
      table[MESA_FORMAT_B8G8R8A8_UNORM] = _mesa_texstore_argb8888;
      table[MESA_FORMAT_A8R8G8B8_UNORM] = _mesa_texstore_argb8888;
      table[MESA_FORMAT_X8B8G8R8_UNORM] = _mesa_texstore_rgba8888;
      table[MESA_FORMAT_R8G8B8X8_UNORM] = _mesa_texstore_rgba8888;
      table[MESA_FORMAT_B8G8R8X8_UNORM] = _mesa_texstore_argb8888;
      table[MESA_FORMAT_X8R8G8B8_UNORM] = _mesa_texstore_argb8888;
      table[MESA_FORMAT_BGR_UNORM8] = _mesa_texstore_rgb888;
      table[MESA_FORMAT_RGB_UNORM8] = _mesa_texstore_bgr888;
      table[MESA_FORMAT_B5G6R5_UNORM] = _mesa_texstore_rgb565;
      table[MESA_FORMAT_R5G6B5_UNORM] = _mesa_texstore_rgb565;
      table[MESA_FORMAT_B4G4R4A4_UNORM] = store_ubyte_texture;
      table[MESA_FORMAT_A4R4G4B4_UNORM] = store_ubyte_texture;
      table[MESA_FORMAT_A1B5G5R5_UNORM] = store_ubyte_texture;
      table[MESA_FORMAT_B5G5R5A1_UNORM] = store_ubyte_texture;
      table[MESA_FORMAT_A1R5G5B5_UNORM] = store_ubyte_texture;
      table[MESA_FORMAT_L4A4_UNORM] = _mesa_texstore_unorm44;
      table[MESA_FORMAT_L8A8_UNORM] = _mesa_texstore_unorm88;
      table[MESA_FORMAT_A8L8_UNORM] = _mesa_texstore_unorm88;
      table[MESA_FORMAT_L16A16_UNORM] = _mesa_texstore_unorm1616;
      table[MESA_FORMAT_A16L16_UNORM] = _mesa_texstore_unorm1616;
      table[MESA_FORMAT_B2G3R3_UNORM] = store_ubyte_texture;
      table[MESA_FORMAT_A_UNORM8] = _mesa_texstore_unorm8;
      table[MESA_FORMAT_A_UNORM16] = _mesa_texstore_unorm16;
      table[MESA_FORMAT_L_UNORM8] = _mesa_texstore_unorm8;
      table[MESA_FORMAT_L_UNORM16] = _mesa_texstore_unorm16;
      table[MESA_FORMAT_I_UNORM8] = _mesa_texstore_unorm8;
      table[MESA_FORMAT_I_UNORM16] = _mesa_texstore_unorm16;
      table[MESA_FORMAT_YCBCR] = _mesa_texstore_ycbcr;
      table[MESA_FORMAT_YCBCR_REV] = _mesa_texstore_ycbcr;
      table[MESA_FORMAT_R_UNORM8] = _mesa_texstore_unorm8;
      table[MESA_FORMAT_R8G8_UNORM] = _mesa_texstore_unorm88;
      table[MESA_FORMAT_G8R8_UNORM] = _mesa_texstore_unorm88;
      table[MESA_FORMAT_R_UNORM16] = _mesa_texstore_unorm16;
      table[MESA_FORMAT_R16G16_UNORM] = _mesa_texstore_unorm1616;
      table[MESA_FORMAT_G16R16_UNORM] = _mesa_texstore_unorm1616;
      table[MESA_FORMAT_B10G10R10A2_UNORM] = _mesa_texstore_argb2101010;
      table[MESA_FORMAT_S8_UINT_Z24_UNORM] = _mesa_texstore_z24_s8;
      table[MESA_FORMAT_Z24_UNORM_S8_UINT] = _mesa_texstore_s8_z24;
      table[MESA_FORMAT_Z_UNORM16] = _mesa_texstore_z16;
      table[MESA_FORMAT_Z24_UNORM_X8_UINT] = _mesa_texstore_x8_z24;
      table[MESA_FORMAT_X8_UINT_Z24_UNORM] = _mesa_texstore_z24_x8;
      table[MESA_FORMAT_Z_UNORM32] = _mesa_texstore_z32;
      table[MESA_FORMAT_S_UINT8] = _mesa_texstore_s8;
      table[MESA_FORMAT_BGR_SRGB8] = _mesa_texstore_srgb8;
      table[MESA_FORMAT_A8B8G8R8_SRGB] = _mesa_texstore_srgba8;
      table[MESA_FORMAT_B8G8R8A8_SRGB] = _mesa_texstore_sargb8;
      table[MESA_FORMAT_L_SRGB8] = _mesa_texstore_sl8;
      table[MESA_FORMAT_L8A8_SRGB] = _mesa_texstore_sla8;
a1407 27
      table[MESA_FORMAT_RGBA_FLOAT32] = _mesa_texstore_rgba_float32;
      table[MESA_FORMAT_RGBA_FLOAT16] = _mesa_texstore_rgba_float16;
      table[MESA_FORMAT_RGB_FLOAT32] = _mesa_texstore_rgba_float32;
      table[MESA_FORMAT_RGB_FLOAT16] = _mesa_texstore_rgba_float16;
      table[MESA_FORMAT_A_FLOAT32] = _mesa_texstore_rgba_float32;
      table[MESA_FORMAT_A_FLOAT16] = _mesa_texstore_rgba_float16;
      table[MESA_FORMAT_L_FLOAT32] = _mesa_texstore_rgba_float32;
      table[MESA_FORMAT_L_FLOAT16] = _mesa_texstore_rgba_float16;
      table[MESA_FORMAT_LA_FLOAT32] = _mesa_texstore_rgba_float32;
      table[MESA_FORMAT_LA_FLOAT16] = _mesa_texstore_rgba_float16;
      table[MESA_FORMAT_I_FLOAT32] = _mesa_texstore_rgba_float32;
      table[MESA_FORMAT_I_FLOAT16] = _mesa_texstore_rgba_float16;
      table[MESA_FORMAT_R_FLOAT32] = _mesa_texstore_rgba_float32;
      table[MESA_FORMAT_R_FLOAT16] = _mesa_texstore_rgba_float16;
      table[MESA_FORMAT_RG_FLOAT32] = _mesa_texstore_rgba_float32;
      table[MESA_FORMAT_RG_FLOAT16] = _mesa_texstore_rgba_float16;
      table[MESA_FORMAT_DUDV8] = _mesa_texstore_dudv8;
      table[MESA_FORMAT_R_SNORM8] = _mesa_texstore_snorm8;
      table[MESA_FORMAT_R8G8_SNORM] = _mesa_texstore_snorm88;
      table[MESA_FORMAT_X8B8G8R8_SNORM] = _mesa_texstore_signed_rgbx8888;
      table[MESA_FORMAT_A8B8G8R8_SNORM] = _mesa_texstore_signed_rgba8888;
      table[MESA_FORMAT_R8G8B8A8_SNORM] = _mesa_texstore_signed_rgba8888;
      table[MESA_FORMAT_R_SNORM16] = _mesa_texstore_snorm16;
      table[MESA_FORMAT_R16G16_SNORM] = _mesa_texstore_snorm1616;
      table[MESA_FORMAT_RGB_SNORM16] = _mesa_texstore_signed_rgba_16;
      table[MESA_FORMAT_RGBA_SNORM16] = _mesa_texstore_signed_rgba_16;
      table[MESA_FORMAT_RGBA_UNORM16] = _mesa_texstore_rgba_16;
a1428 12
      table[MESA_FORMAT_A_SNORM8] = _mesa_texstore_snorm8;
      table[MESA_FORMAT_L_SNORM8] = _mesa_texstore_snorm8;
      table[MESA_FORMAT_L8A8_SNORM] = _mesa_texstore_snorm88;
      table[MESA_FORMAT_I_SNORM8] = _mesa_texstore_snorm8;
      table[MESA_FORMAT_A_SNORM16] = _mesa_texstore_snorm16;
      table[MESA_FORMAT_L_SNORM16] = _mesa_texstore_snorm16;
      table[MESA_FORMAT_LA_SNORM16] = _mesa_texstore_snorm1616;
      table[MESA_FORMAT_I_SNORM16] = _mesa_texstore_snorm16;
      table[MESA_FORMAT_R9G9B9E5_FLOAT] = _mesa_texstore_rgb9_e5;
      table[MESA_FORMAT_R11G11B10_FLOAT] = _mesa_texstore_r11_g11_b10f;
      table[MESA_FORMAT_Z_FLOAT32] = _mesa_texstore_z32;
      table[MESA_FORMAT_Z32_FLOAT_S8X24_UINT] = _mesa_texstore_z32f_x24s8;
d1430 278
a1707 53
      table[MESA_FORMAT_A_UINT8] = _mesa_texstore_rgba_uint8;
      table[MESA_FORMAT_A_UINT16] = _mesa_texstore_rgba_uint16;
      table[MESA_FORMAT_A_UINT32] = _mesa_texstore_rgba_uint32;
      table[MESA_FORMAT_A_SINT8] = _mesa_texstore_rgba_int8;
      table[MESA_FORMAT_A_SINT16] = _mesa_texstore_rgba_int16;
      table[MESA_FORMAT_A_SINT32] = _mesa_texstore_rgba_int32;

      table[MESA_FORMAT_I_UINT8] = _mesa_texstore_rgba_uint8;
      table[MESA_FORMAT_I_UINT16] = _mesa_texstore_rgba_uint16;
      table[MESA_FORMAT_I_UINT32] = _mesa_texstore_rgba_uint32;
      table[MESA_FORMAT_I_SINT8] = _mesa_texstore_rgba_int8;
      table[MESA_FORMAT_I_SINT16] = _mesa_texstore_rgba_int16;
      table[MESA_FORMAT_I_SINT32] = _mesa_texstore_rgba_int32;

      table[MESA_FORMAT_L_UINT8] = _mesa_texstore_rgba_uint8;
      table[MESA_FORMAT_L_UINT16] = _mesa_texstore_rgba_uint16;
      table[MESA_FORMAT_L_UINT32] = _mesa_texstore_rgba_uint32;
      table[MESA_FORMAT_L_SINT8] = _mesa_texstore_rgba_int8;
      table[MESA_FORMAT_L_SINT16] = _mesa_texstore_rgba_int16;
      table[MESA_FORMAT_L_SINT32] = _mesa_texstore_rgba_int32;

      table[MESA_FORMAT_LA_UINT8] = _mesa_texstore_rgba_uint8;
      table[MESA_FORMAT_LA_UINT16] = _mesa_texstore_rgba_uint16;
      table[MESA_FORMAT_LA_UINT32] = _mesa_texstore_rgba_uint32;
      table[MESA_FORMAT_LA_SINT8] = _mesa_texstore_rgba_int8;
      table[MESA_FORMAT_LA_SINT16] = _mesa_texstore_rgba_int16;
      table[MESA_FORMAT_LA_SINT32] = _mesa_texstore_rgba_int32;

      table[MESA_FORMAT_R_SINT8] = _mesa_texstore_rgba_int8;
      table[MESA_FORMAT_RG_SINT8] = _mesa_texstore_rgba_int8;
      table[MESA_FORMAT_RGB_SINT8] = _mesa_texstore_rgba_int8;
      table[MESA_FORMAT_RGBA_SINT8] = _mesa_texstore_rgba_int8;
      table[MESA_FORMAT_R_SINT16] = _mesa_texstore_rgba_int16;
      table[MESA_FORMAT_RG_SINT16] = _mesa_texstore_rgba_int16;
      table[MESA_FORMAT_RGB_SINT16] = _mesa_texstore_rgba_int16;
      table[MESA_FORMAT_RGBA_SINT16] = _mesa_texstore_rgba_int16;
      table[MESA_FORMAT_R_SINT32] = _mesa_texstore_rgba_int32;
      table[MESA_FORMAT_RG_SINT32] = _mesa_texstore_rgba_int32;
      table[MESA_FORMAT_RGB_SINT32] = _mesa_texstore_rgba_int32;
      table[MESA_FORMAT_RGBA_SINT32] = _mesa_texstore_rgba_int32;

      table[MESA_FORMAT_R_UINT8] = _mesa_texstore_rgba_uint8;
      table[MESA_FORMAT_RG_UINT8] = _mesa_texstore_rgba_uint8;
      table[MESA_FORMAT_RGB_UINT8] = _mesa_texstore_rgba_uint8;
      table[MESA_FORMAT_RGBA_UINT8] = _mesa_texstore_rgba_uint8;
      table[MESA_FORMAT_R_UINT16] = _mesa_texstore_rgba_uint16;
      table[MESA_FORMAT_RG_UINT16] = _mesa_texstore_rgba_uint16;
      table[MESA_FORMAT_RGB_UINT16] = _mesa_texstore_rgba_uint16;
      table[MESA_FORMAT_RGBA_UINT16] = _mesa_texstore_rgba_uint16;
      table[MESA_FORMAT_R_UINT32] = _mesa_texstore_rgba_uint32;
      table[MESA_FORMAT_RG_UINT32] = _mesa_texstore_rgba_uint32;
      table[MESA_FORMAT_RGB_UINT32] = _mesa_texstore_rgba_uint32;
      table[MESA_FORMAT_RGBA_UINT32] = _mesa_texstore_rgba_uint32;
d1709 2
a1710 2
      table[MESA_FORMAT_B10G10R10A2_UINT] = _mesa_texstore_argb2101010_uint;
      table[MESA_FORMAT_R10G10B10A2_UINT] = _mesa_texstore_abgr2101010_uint;
d1712 5
a1716 16
      table[MESA_FORMAT_B4G4R4X4_UNORM] = store_ubyte_texture;
      table[MESA_FORMAT_B5G5R5X1_UNORM] = store_ubyte_texture;
      table[MESA_FORMAT_R8G8B8X8_SNORM] = _mesa_texstore_signed_rgbx8888;
      table[MESA_FORMAT_R8G8B8X8_SRGB] = _mesa_texstore_srgba8;
      table[MESA_FORMAT_R8G8B8A8_SRGB] = _mesa_texstore_srgba8;
      table[MESA_FORMAT_RGBX_UINT8] = _mesa_texstore_rgba_uint8;
      table[MESA_FORMAT_RGBX_SINT8] = _mesa_texstore_rgba_int8;
      table[MESA_FORMAT_B10G10R10X2_UNORM] = _mesa_texstore_argb2101010;
      table[MESA_FORMAT_RGBX_UNORM16] = _mesa_texstore_rgba_16;
      table[MESA_FORMAT_RGBX_SNORM16] = _mesa_texstore_signed_rgba_16;
      table[MESA_FORMAT_RGBX_FLOAT16] = _mesa_texstore_rgba_float16;
      table[MESA_FORMAT_RGBX_UINT16] = _mesa_texstore_rgba_uint16;
      table[MESA_FORMAT_RGBX_SINT16] = _mesa_texstore_rgba_int16;
      table[MESA_FORMAT_RGBX_FLOAT32] = _mesa_texstore_rgba_float32;
      table[MESA_FORMAT_RGBX_UINT32] = _mesa_texstore_rgba_uint32;
      table[MESA_FORMAT_RGBX_SINT32] = _mesa_texstore_rgba_int32;
d1718 2
a1719 1
      table[MESA_FORMAT_R10G10B10A2_UNORM] = _mesa_texstore_abgr2101010;
d1721 4
a1724 2
      table[MESA_FORMAT_G8R8_SNORM] = _mesa_texstore_snorm88;
      table[MESA_FORMAT_G16R16_SNORM] = _mesa_texstore_snorm1616;
d1726 2
a1727 1
      table[MESA_FORMAT_B8G8R8X8_SRGB] = _mesa_texstore_sargb8;
d1732 36
a1767 2
   ASSERT(table[format]);
   return table[format];
a1769 1

a1853 2


a1861 3
   StoreTexImageFunc storeImage;
   GLboolean success;

d1870 16
a1885 8
   storeImage = _mesa_get_texstore_func(dstFormat);

   success = storeImage(ctx, dims, baseInternalFormat,
                        dstFormat,
                        dstRowStride, dstSlices,
                        srcWidth, srcHeight, srcDepth,
                        srcFormat, srcType, srcAddr, srcPacking);
   return success;
d2088 72
d2199 64
d2273 3
a2275 2
   GLint bytesPerRow, dstRowStride, srcRowStride;
   GLint i, rows;
a2277 3
   const mesa_format texFormat = texImage->TexFormat;
   GLuint bw, bh;
   GLint slice;
d2284 3
a2286 1
   _mesa_get_format_block_size(texFormat, &bw, &bh);
d2295 1
a2295 2
   srcRowStride = _mesa_format_row_stride(texFormat, width);
   src = (const GLubyte *) data;
d2297 1
a2297 1
   for (slice = 0; slice < depth; slice++) {
a2304 2
         bytesPerRow = srcRowStride;  /* bytes per row of blocks */
         rows = (height + bh - 1) / bh;  /* rows in blocks */
d2307 2
a2308 2
         for (i = 0; i < rows; i++) {
            memcpy(dstMap, src, bytesPerRow);
d2310 1
a2310 1
            src += srcRowStride;
d2314 3
@


1.10
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d3911 15
@


1.9
log
@Merge Mesa 9.2.0
@
text
@d926 1
a926 1
               gl_format dstFormat,
d1015 2
a1016 2
   ASSERT(dstFormat == MESA_FORMAT_Z32 ||
          dstFormat == MESA_FORMAT_Z32_FLOAT);
d1019 1
a1019 1
   if (dstFormat == MESA_FORMAT_Z32)
d1052 1
a1052 1
   ASSERT(dstFormat == MESA_FORMAT_X8_Z24);
d1082 1
a1082 1
   ASSERT(dstFormat == MESA_FORMAT_Z24_X8);
d1115 1
a1115 1
   ASSERT(dstFormat == MESA_FORMAT_Z16);
d1144 2
a1145 2
   ASSERT(dstFormat == MESA_FORMAT_RGB565 ||
          dstFormat == MESA_FORMAT_RGB565_REV);
d1166 1
a1166 1
         if (dstFormat == MESA_FORMAT_RGB565) {
d1193 1
a1193 1
 * Store a texture in MESA_FORMAT_RGBA8888 or MESA_FORMAT_RGBA8888_REV.
d1200 4
a1203 4
   ASSERT(dstFormat == MESA_FORMAT_RGBA8888 ||
          dstFormat == MESA_FORMAT_RGBA8888_REV ||
          dstFormat == MESA_FORMAT_RGBX8888 ||
          dstFormat == MESA_FORMAT_RGBX8888_REV);
d1217 4
a1220 4
      if ((littleEndian && (dstFormat == MESA_FORMAT_RGBA8888 ||
                            dstFormat == MESA_FORMAT_RGBX8888)) ||
	  (!littleEndian && (dstFormat == MESA_FORMAT_RGBA8888_REV ||
	                     dstFormat == MESA_FORMAT_RGBX8888_REV))) {
d1257 4
a1260 4
   ASSERT(dstFormat == MESA_FORMAT_ARGB8888 ||
          dstFormat == MESA_FORMAT_ARGB8888_REV ||
          dstFormat == MESA_FORMAT_XRGB8888 ||
          dstFormat == MESA_FORMAT_XRGB8888_REV );
d1265 2
a1266 2
       (dstFormat == MESA_FORMAT_ARGB8888 ||
        dstFormat == MESA_FORMAT_XRGB8888) &&
d1293 1
a1293 1
            dstFormat == MESA_FORMAT_ARGB8888 &&
d1319 1
a1319 1
	    dstFormat == MESA_FORMAT_ARGB8888 &&
d1361 4
a1364 4
      if ((littleEndian && dstFormat == MESA_FORMAT_ARGB8888) ||
          (littleEndian && dstFormat == MESA_FORMAT_XRGB8888) ||
	  (!littleEndian && dstFormat == MESA_FORMAT_ARGB8888_REV) ||
	  (!littleEndian && dstFormat == MESA_FORMAT_XRGB8888_REV)) {
d1371 4
a1374 4
	 assert((littleEndian && dstFormat == MESA_FORMAT_ARGB8888_REV) ||
		(!littleEndian && dstFormat == MESA_FORMAT_ARGB8888) ||
		(littleEndian && dstFormat == MESA_FORMAT_XRGB8888_REV) ||
		(!littleEndian && dstFormat == MESA_FORMAT_XRGB8888));
d1404 1
a1404 1
   ASSERT(dstFormat == MESA_FORMAT_RGB888);
d1466 1
a1466 1
   ASSERT(dstFormat == MESA_FORMAT_BGR888);
d1528 2
a1529 2
   ASSERT(dstFormat == MESA_FORMAT_ARGB2101010 ||
          dstFormat == MESA_FORMAT_XRGB2101010_UNORM);
d1582 1
a1582 1
   ASSERT(dstFormat == MESA_FORMAT_AL44);
d1625 4
a1628 4
   ASSERT(dstFormat == MESA_FORMAT_AL88 ||
          dstFormat == MESA_FORMAT_AL88_REV ||
          dstFormat == MESA_FORMAT_GR88 ||
          dstFormat == MESA_FORMAT_RG88);
d1640 3
a1642 3
      if (dstFormat == MESA_FORMAT_AL88 || dstFormat == MESA_FORMAT_AL88_REV) {
	 if ((littleEndian && dstFormat == MESA_FORMAT_AL88) ||
	     (!littleEndian && dstFormat == MESA_FORMAT_AL88_REV)) {
d1652 2
a1653 2
	 if ((littleEndian && dstFormat == MESA_FORMAT_GR88) ||
	     (!littleEndian && dstFormat == MESA_FORMAT_RG88)) {
d1690 2
a1691 2
            if (dstFormat == MESA_FORMAT_AL88 ||
		dstFormat == MESA_FORMAT_GR88) {
d1724 4
a1727 4
   ASSERT(dstFormat == MESA_FORMAT_AL1616 ||
          dstFormat == MESA_FORMAT_AL1616_REV ||
	  dstFormat == MESA_FORMAT_GR1616 ||
          dstFormat == MESA_FORMAT_RG1616);
d1747 2
a1748 2
            if (dstFormat == MESA_FORMAT_AL1616 ||
		dstFormat == MESA_FORMAT_GR1616) {
d1783 4
a1786 4
   ASSERT(dstFormat == MESA_FORMAT_R16 ||
          dstFormat == MESA_FORMAT_A16 ||
          dstFormat == MESA_FORMAT_L16 ||
          dstFormat == MESA_FORMAT_I16);
d1825 2
a1826 2
   ASSERT(dstFormat == MESA_FORMAT_RGBA_16 ||
          dstFormat == MESA_FORMAT_XBGR16161616_UNORM);
d1877 3
a1879 3
   ASSERT(dstFormat == MESA_FORMAT_SIGNED_RGB_16 ||
          dstFormat == MESA_FORMAT_SIGNED_RGBA_16 ||
          dstFormat == MESA_FORMAT_XBGR16161616_SNORM);
d1904 1
a1904 1
            if (dstFormat == MESA_FORMAT_SIGNED_RGBA_16) {
d1916 1
a1916 1
            else if (dstFormat == MESA_FORMAT_XBGR16161616_SNORM) {
d1958 4
a1961 4
   ASSERT(dstFormat == MESA_FORMAT_A8 ||
          dstFormat == MESA_FORMAT_L8 ||
          dstFormat == MESA_FORMAT_I8 ||
          dstFormat == MESA_FORMAT_R8);
d1972 1
a1972 1
      if (dstFormat == MESA_FORMAT_A8) {
d2150 4
a2153 4
   ASSERT(dstFormat == MESA_FORMAT_SIGNED_A8 ||
          dstFormat == MESA_FORMAT_SIGNED_L8 ||
          dstFormat == MESA_FORMAT_SIGNED_I8 ||
          dstFormat == MESA_FORMAT_SIGNED_R8);
d2193 3
a2195 2
   ASSERT(dstFormat == MESA_FORMAT_SIGNED_AL88 ||
          dstFormat == MESA_FORMAT_SIGNED_RG88_REV);
d2214 19
a2232 6
            GLbyte *dst = dstRow;
            for (col = 0; col < srcWidth; col++) {
               dst[0] = FLOAT_TO_BYTE_TEX(src[0]);
               dst[1] = FLOAT_TO_BYTE_TEX(src[1]);
               src += 2;
               dst += 2;
d2234 1
d2249 4
a2252 4
   ASSERT(dstFormat == MESA_FORMAT_SIGNED_R16 ||
          dstFormat == MESA_FORMAT_SIGNED_A16 ||
          dstFormat == MESA_FORMAT_SIGNED_L16 ||
          dstFormat == MESA_FORMAT_SIGNED_I16);
d2295 3
a2297 2
   ASSERT(dstFormat == MESA_FORMAT_SIGNED_AL1616 ||
          dstFormat == MESA_FORMAT_SIGNED_GR1616);
d2316 15
a2330 3
            GLshort *dst = (GLshort *) dstRow;
            for (col = 0; col < srcWidth; col++) {
               GLushort l, a;
d2332 5
a2336 6
               UNCLAMPED_FLOAT_TO_SHORT(l, src[0]);
               UNCLAMPED_FLOAT_TO_SHORT(a, src[1]);
               dst[0] = l;
               dst[1] = a;
               src += 2;
               dst += 2;
d2338 1
d2348 2
a2349 2
 * Store a texture in MESA_FORMAT_SIGNED_RGBX8888 or
 * MESA_FORMAT_XBGR8888_SNORM.
d2356 2
a2357 2
   ASSERT(dstFormat == MESA_FORMAT_SIGNED_RGBX8888 ||
          dstFormat == MESA_FORMAT_XBGR8888_SNORM);
d2377 1
a2377 1
            if (dstFormat == MESA_FORMAT_SIGNED_RGBX8888) {
d2408 2
a2409 2
 * Store a texture in MESA_FORMAT_SIGNED_RGBA8888 or
 * MESA_FORMAT_SIGNED_RGBA8888_REV
d2416 2
a2417 2
   ASSERT(dstFormat == MESA_FORMAT_SIGNED_RGBA8888 ||
          dstFormat == MESA_FORMAT_SIGNED_RGBA8888_REV);
d2437 1
a2437 1
            if (dstFormat == MESA_FORMAT_SIGNED_RGBA8888) {
d2476 2
d2479 1
a2479 1
   ASSERT(dstFormat == MESA_FORMAT_Z24_S8);
d2483 3
a2485 1
   ASSERT(srcFormat != GL_DEPTH_STENCIL_EXT || srcType == GL_UNSIGNED_INT_24_8_EXT);
d2487 5
a2491 4
   if (srcFormat == GL_DEPTH_COMPONENT ||
       srcFormat == GL_STENCIL_INDEX) {
      GLuint *depth = malloc(srcWidth * sizeof(GLuint));
      GLubyte *stencil = malloc(srcWidth * sizeof(GLubyte));
d2493 11
a2503 5
      if (!depth || !stencil) {
         free(depth);
         free(stencil);
         return GL_FALSE;
      }
d2505 6
a2510 11
      /* In case we only upload depth we need to preserve the stencil */
      for (img = 0; img < srcDepth; img++) {
	 GLuint *dstRow = (GLuint *) dstSlices[img];
         const GLubyte *src
            = (const GLubyte *) _mesa_image_address(dims, srcPacking, srcAddr,
                  srcWidth, srcHeight,
                  srcFormat, srcType,
                  img, 0, 0);
         for (row = 0; row < srcHeight; row++) {
            GLint i;
	    GLboolean keepdepth = GL_FALSE, keepstencil = GL_FALSE;
d2512 7
a2518 6
	    if (srcFormat == GL_DEPTH_COMPONENT) { /* preserve stencil */
	       keepstencil = GL_TRUE;
	    }
            else if (srcFormat == GL_STENCIL_INDEX) { /* preserve depth */
	       keepdepth = GL_TRUE;
	    }
d2520 7
a2526 22
	    if (keepdepth == GL_FALSE)
	       /* the 24 depth bits will be in the low position: */
	       _mesa_unpack_depth_span(ctx, srcWidth,
				       GL_UNSIGNED_INT, /* dst type */
				       keepstencil ? depth : dstRow, /* dst addr */
				       depthScale,
				       srcType, src, srcPacking);

	    if (keepstencil == GL_FALSE)
	       /* get the 8-bit stencil values */
	       _mesa_unpack_stencil_span(ctx, srcWidth,
					 GL_UNSIGNED_BYTE, /* dst type */
					 stencil, /* dst addr */
					 srcType, src, srcPacking,
					 ctx->_ImageTransferState);

	    for (i = 0; i < srcWidth; i++) {
	       if (keepstencil)
		  dstRow[i] = depth[i] << 8 | (dstRow[i] & 0x000000FF);
	       else
		  dstRow[i] = (dstRow[i] & 0xFFFFFF00) | (stencil[i] & 0xFF);
	    }
d2528 5
a2532 2
            src += srcRowStride;
            dstRow += dstRowStride / sizeof(GLuint);
d2534 2
d2537 1
d2539 2
a2540 3
      free(depth);
      free(stencil);
   }
d2558 1
a2558 1
   ASSERT(dstFormat == MESA_FORMAT_S8_Z24);
d2563 2
a2564 1
          srcType == GL_UNSIGNED_INT_24_8_EXT);
d2635 1
a2635 1
   ASSERT(dstFormat == MESA_FORMAT_S8);
d2695 1
a2695 1
   if (dstFormat == MESA_FORMAT_XBGR32323232_FLOAT) {
d2702 4
a2705 4
          dstFormat == MESA_FORMAT_ALPHA_FLOAT32 ||
          dstFormat == MESA_FORMAT_LUMINANCE_FLOAT32 ||
          dstFormat == MESA_FORMAT_LUMINANCE_ALPHA_FLOAT32 ||
          dstFormat == MESA_FORMAT_INTENSITY_FLOAT32 ||
d2708 1
a2708 1
          dstFormat == MESA_FORMAT_XBGR32323232_FLOAT);
d2760 1
a2760 1
   if (dstFormat == MESA_FORMAT_XBGR16161616_FLOAT) {
d2767 4
a2770 4
          dstFormat == MESA_FORMAT_ALPHA_FLOAT16 ||
          dstFormat == MESA_FORMAT_LUMINANCE_FLOAT16 ||
          dstFormat == MESA_FORMAT_LUMINANCE_ALPHA_FLOAT16 ||
          dstFormat == MESA_FORMAT_INTENSITY_FLOAT16 ||
d2773 1
a2773 1
          dstFormat == MESA_FORMAT_XBGR16161616_FLOAT);
d2824 1
a2824 1
   if (dstFormat == MESA_FORMAT_XBGR8888_SINT) {
d2829 9
a2837 9
   ASSERT(dstFormat == MESA_FORMAT_R_INT8 ||
          dstFormat == MESA_FORMAT_RG_INT8 ||
          dstFormat == MESA_FORMAT_RGB_INT8 ||
          dstFormat == MESA_FORMAT_RGBA_INT8 ||
          dstFormat == MESA_FORMAT_ALPHA_INT8 ||
          dstFormat == MESA_FORMAT_INTENSITY_INT8 ||
          dstFormat == MESA_FORMAT_LUMINANCE_INT8 ||
          dstFormat == MESA_FORMAT_LUMINANCE_ALPHA_INT8 ||
          dstFormat == MESA_FORMAT_XBGR8888_SINT);
d2895 1
a2895 1
   if (dstFormat == MESA_FORMAT_XBGR16161616_SINT) {
d2900 9
a2908 9
   ASSERT(dstFormat == MESA_FORMAT_R_INT16 ||
          dstFormat == MESA_FORMAT_RG_INT16 ||
          dstFormat == MESA_FORMAT_RGB_INT16 ||
          dstFormat == MESA_FORMAT_RGBA_INT16 ||
          dstFormat == MESA_FORMAT_ALPHA_INT16 ||
          dstFormat == MESA_FORMAT_LUMINANCE_INT16 ||
          dstFormat == MESA_FORMAT_INTENSITY_INT16 ||
          dstFormat == MESA_FORMAT_LUMINANCE_ALPHA_INT16 ||
          dstFormat == MESA_FORMAT_XBGR16161616_SINT);
d2966 1
a2966 1
   if (dstFormat == MESA_FORMAT_XBGR32323232_SINT) {
d2971 9
a2979 9
   ASSERT(dstFormat == MESA_FORMAT_R_INT32 ||
          dstFormat == MESA_FORMAT_RG_INT32 ||
          dstFormat == MESA_FORMAT_RGB_INT32 ||
          dstFormat == MESA_FORMAT_RGBA_INT32 ||
          dstFormat == MESA_FORMAT_ALPHA_INT32 ||
          dstFormat == MESA_FORMAT_INTENSITY_INT32 ||
          dstFormat == MESA_FORMAT_LUMINANCE_INT32 ||
          dstFormat == MESA_FORMAT_LUMINANCE_ALPHA_INT32 ||
          dstFormat == MESA_FORMAT_XBGR32323232_SINT);
d3037 1
a3037 1
   if (dstFormat == MESA_FORMAT_XBGR8888_UINT) {
d3046 5
a3050 5
          dstFormat == MESA_FORMAT_ALPHA_UINT8 ||
          dstFormat == MESA_FORMAT_INTENSITY_UINT8 ||
          dstFormat == MESA_FORMAT_LUMINANCE_UINT8 ||
          dstFormat == MESA_FORMAT_LUMINANCE_ALPHA_UINT8 ||
          dstFormat == MESA_FORMAT_XBGR8888_UINT);
d3105 1
a3105 1
   if (dstFormat == MESA_FORMAT_XBGR16161616_UINT) {
d3114 5
a3118 5
          dstFormat == MESA_FORMAT_ALPHA_UINT16 ||
          dstFormat == MESA_FORMAT_INTENSITY_UINT16 ||
          dstFormat == MESA_FORMAT_LUMINANCE_UINT16 ||
          dstFormat == MESA_FORMAT_LUMINANCE_ALPHA_UINT16 ||
          dstFormat == MESA_FORMAT_XBGR16161616_UINT);
d3173 1
a3173 1
   if (dstFormat == MESA_FORMAT_XBGR32323232_UINT) {
d3182 5
a3186 5
          dstFormat == MESA_FORMAT_ALPHA_UINT32 ||
          dstFormat == MESA_FORMAT_INTENSITY_UINT32 ||
          dstFormat == MESA_FORMAT_LUMINANCE_UINT32 ||
          dstFormat == MESA_FORMAT_LUMINANCE_ALPHA_UINT32 ||
          dstFormat == MESA_FORMAT_XBGR32323232_UINT);
d3236 1
a3236 1
   gl_format newDstFormat;
d3239 1
a3239 1
   ASSERT(dstFormat == MESA_FORMAT_SRGB8);
d3242 1
a3242 1
   newDstFormat = MESA_FORMAT_RGB888;
d3257 1
a3257 1
   gl_format newDstFormat;
d3260 3
a3262 2
   ASSERT(dstFormat == MESA_FORMAT_SRGBA8 ||
          dstFormat == MESA_FORMAT_XBGR8888_SRGB);
d3264 1
a3264 11
   /* reuse normal rgba texstore code */
   if (dstFormat == MESA_FORMAT_SRGBA8) {
      newDstFormat = MESA_FORMAT_RGBA8888;
   }
   else if (dstFormat == MESA_FORMAT_XBGR8888_SRGB) {
      newDstFormat = MESA_FORMAT_RGBX8888_REV;
   }
   else {
      ASSERT(0);
      return GL_TRUE;
   }
d3279 1
a3279 1
   gl_format newDstFormat;
d3282 2
a3283 1
   ASSERT(dstFormat == MESA_FORMAT_SARGB8);
d3285 1
a3285 2
   /* reuse normal rgba texstore code */
   newDstFormat = MESA_FORMAT_ARGB8888;
d3300 1
a3300 1
   gl_format newDstFormat;
d3303 1
a3303 1
   ASSERT(dstFormat == MESA_FORMAT_SL8);
d3305 1
a3305 1
   newDstFormat = MESA_FORMAT_L8;
d3321 1
a3321 1
   gl_format newDstFormat;
d3324 1
a3324 1
   ASSERT(dstFormat == MESA_FORMAT_SLA8);
d3327 1
a3327 1
   newDstFormat = MESA_FORMAT_AL88;
d3343 1
a3343 1
   ASSERT(dstFormat == MESA_FORMAT_RGB9_E5_FLOAT);
d3381 1
a3381 1
   ASSERT(dstFormat == MESA_FORMAT_R11_G11_B10_FLOAT);
d3418 6
a3423 1
   ASSERT(dstFormat == MESA_FORMAT_Z32_FLOAT_X24S8);
d3428 1
d3431 18
a3448 6
   if (srcFormat == GL_DEPTH_COMPONENT ||
       srcFormat == GL_STENCIL_INDEX) {
      GLint img, row;
      const GLint srcRowStride
         = _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType)
         / sizeof(uint64_t);
d3450 6
a3455 25
      /* In case we only upload depth we need to preserve the stencil */
      for (img = 0; img < srcDepth; img++) {
         uint64_t *dstRow = (uint64_t *) dstSlices[img];
         const uint64_t *src
            = (const uint64_t *) _mesa_image_address(dims, srcPacking, srcAddr,
                  srcWidth, srcHeight,
                  srcFormat, srcType,
                  img, 0, 0);
         for (row = 0; row < srcHeight; row++) {
            /* The unpack functions with:
             *    dstType = GL_FLOAT_32_UNSIGNED_INT_24_8_REV
             * only write their own dword, so the other dword (stencil
             * or depth) is preserved. */
            if (srcFormat != GL_STENCIL_INDEX)
               _mesa_unpack_depth_span(ctx, srcWidth,
                                       GL_FLOAT_32_UNSIGNED_INT_24_8_REV, /* dst type */
                                       dstRow, /* dst addr */
                                       ~0U, srcType, src, srcPacking);

            if (srcFormat != GL_DEPTH_COMPONENT)
               _mesa_unpack_stencil_span(ctx, srcWidth,
                                         GL_FLOAT_32_UNSIGNED_INT_24_8_REV, /* dst type */
                                         dstRow, /* dst addr */
                                         srcType, src, srcPacking,
                                         ctx->_ImageTransferState);
d3457 2
a3458 3
            src += srcRowStride;
            dstRow += dstRowStride / sizeof(uint64_t);
         }
d3469 1
a3469 1
   ASSERT(dstFormat == MESA_FORMAT_ARGB2101010_UINT);
d3525 1
a3525 1
   ASSERT(dstFormat == MESA_FORMAT_ABGR2101010_UINT);
d3577 44
d3642 1
a3642 1
_mesa_get_texstore_func(gl_format format)
d3650 29
a3678 29
      table[MESA_FORMAT_RGBA8888] = _mesa_texstore_rgba8888;
      table[MESA_FORMAT_RGBA8888_REV] = _mesa_texstore_rgba8888;
      table[MESA_FORMAT_ARGB8888] = _mesa_texstore_argb8888;
      table[MESA_FORMAT_ARGB8888_REV] = _mesa_texstore_argb8888;
      table[MESA_FORMAT_RGBX8888] = _mesa_texstore_rgba8888;
      table[MESA_FORMAT_RGBX8888_REV] = _mesa_texstore_rgba8888;
      table[MESA_FORMAT_XRGB8888] = _mesa_texstore_argb8888;
      table[MESA_FORMAT_XRGB8888_REV] = _mesa_texstore_argb8888;
      table[MESA_FORMAT_RGB888] = _mesa_texstore_rgb888;
      table[MESA_FORMAT_BGR888] = _mesa_texstore_bgr888;
      table[MESA_FORMAT_RGB565] = _mesa_texstore_rgb565;
      table[MESA_FORMAT_RGB565_REV] = _mesa_texstore_rgb565;
      table[MESA_FORMAT_ARGB4444] = store_ubyte_texture;
      table[MESA_FORMAT_ARGB4444_REV] = store_ubyte_texture;
      table[MESA_FORMAT_RGBA5551] = store_ubyte_texture;
      table[MESA_FORMAT_ARGB1555] = store_ubyte_texture;
      table[MESA_FORMAT_ARGB1555_REV] = store_ubyte_texture;
      table[MESA_FORMAT_AL44] = _mesa_texstore_unorm44;
      table[MESA_FORMAT_AL88] = _mesa_texstore_unorm88;
      table[MESA_FORMAT_AL88_REV] = _mesa_texstore_unorm88;
      table[MESA_FORMAT_AL1616] = _mesa_texstore_unorm1616;
      table[MESA_FORMAT_AL1616_REV] = _mesa_texstore_unorm1616;
      table[MESA_FORMAT_RGB332] = store_ubyte_texture;
      table[MESA_FORMAT_A8] = _mesa_texstore_unorm8;
      table[MESA_FORMAT_A16] = _mesa_texstore_unorm16;
      table[MESA_FORMAT_L8] = _mesa_texstore_unorm8;
      table[MESA_FORMAT_L16] = _mesa_texstore_unorm16;
      table[MESA_FORMAT_I8] = _mesa_texstore_unorm8;
      table[MESA_FORMAT_I16] = _mesa_texstore_unorm16;
d3681 19
a3699 19
      table[MESA_FORMAT_R8] = _mesa_texstore_unorm8;
      table[MESA_FORMAT_GR88] = _mesa_texstore_unorm88;
      table[MESA_FORMAT_RG88] = _mesa_texstore_unorm88;
      table[MESA_FORMAT_R16] = _mesa_texstore_unorm16;
      table[MESA_FORMAT_GR1616] = _mesa_texstore_unorm1616;
      table[MESA_FORMAT_RG1616] = _mesa_texstore_unorm1616;
      table[MESA_FORMAT_ARGB2101010] = _mesa_texstore_argb2101010;
      table[MESA_FORMAT_Z24_S8] = _mesa_texstore_z24_s8;
      table[MESA_FORMAT_S8_Z24] = _mesa_texstore_s8_z24;
      table[MESA_FORMAT_Z16] = _mesa_texstore_z16;
      table[MESA_FORMAT_X8_Z24] = _mesa_texstore_x8_z24;
      table[MESA_FORMAT_Z24_X8] = _mesa_texstore_z24_x8;
      table[MESA_FORMAT_Z32] = _mesa_texstore_z32;
      table[MESA_FORMAT_S8] = _mesa_texstore_s8;
      table[MESA_FORMAT_SRGB8] = _mesa_texstore_srgb8;
      table[MESA_FORMAT_SRGBA8] = _mesa_texstore_srgba8;
      table[MESA_FORMAT_SARGB8] = _mesa_texstore_sargb8;
      table[MESA_FORMAT_SL8] = _mesa_texstore_sl8;
      table[MESA_FORMAT_SLA8] = _mesa_texstore_sla8;
d3714 8
a3721 8
      table[MESA_FORMAT_ALPHA_FLOAT32] = _mesa_texstore_rgba_float32;
      table[MESA_FORMAT_ALPHA_FLOAT16] = _mesa_texstore_rgba_float16;
      table[MESA_FORMAT_LUMINANCE_FLOAT32] = _mesa_texstore_rgba_float32;
      table[MESA_FORMAT_LUMINANCE_FLOAT16] = _mesa_texstore_rgba_float16;
      table[MESA_FORMAT_LUMINANCE_ALPHA_FLOAT32] = _mesa_texstore_rgba_float32;
      table[MESA_FORMAT_LUMINANCE_ALPHA_FLOAT16] = _mesa_texstore_rgba_float16;
      table[MESA_FORMAT_INTENSITY_FLOAT32] = _mesa_texstore_rgba_float32;
      table[MESA_FORMAT_INTENSITY_FLOAT16] = _mesa_texstore_rgba_float16;
d3727 18
a3744 18
      table[MESA_FORMAT_SIGNED_R8] = _mesa_texstore_snorm8;
      table[MESA_FORMAT_SIGNED_RG88_REV] = _mesa_texstore_snorm88;
      table[MESA_FORMAT_SIGNED_RGBX8888] = _mesa_texstore_signed_rgbx8888;
      table[MESA_FORMAT_SIGNED_RGBA8888] = _mesa_texstore_signed_rgba8888;
      table[MESA_FORMAT_SIGNED_RGBA8888_REV] = _mesa_texstore_signed_rgba8888;
      table[MESA_FORMAT_SIGNED_R16] = _mesa_texstore_snorm16;
      table[MESA_FORMAT_SIGNED_GR1616] = _mesa_texstore_snorm1616;
      table[MESA_FORMAT_SIGNED_RGB_16] = _mesa_texstore_signed_rgba_16;
      table[MESA_FORMAT_SIGNED_RGBA_16] = _mesa_texstore_signed_rgba_16;
      table[MESA_FORMAT_RGBA_16] = _mesa_texstore_rgba_16;
      table[MESA_FORMAT_RED_RGTC1] = _mesa_texstore_red_rgtc1;
      table[MESA_FORMAT_SIGNED_RED_RGTC1] = _mesa_texstore_signed_red_rgtc1;
      table[MESA_FORMAT_RG_RGTC2] = _mesa_texstore_rg_rgtc2;
      table[MESA_FORMAT_SIGNED_RG_RGTC2] = _mesa_texstore_signed_rg_rgtc2;
      table[MESA_FORMAT_L_LATC1] = _mesa_texstore_red_rgtc1;
      table[MESA_FORMAT_SIGNED_L_LATC1] = _mesa_texstore_signed_red_rgtc1;
      table[MESA_FORMAT_LA_LATC2] = _mesa_texstore_rg_rgtc2;
      table[MESA_FORMAT_SIGNED_LA_LATC2] = _mesa_texstore_signed_rg_rgtc2;
d3758 53
a3810 53
      table[MESA_FORMAT_SIGNED_A8] = _mesa_texstore_snorm8;
      table[MESA_FORMAT_SIGNED_L8] = _mesa_texstore_snorm8;
      table[MESA_FORMAT_SIGNED_AL88] = _mesa_texstore_snorm88;
      table[MESA_FORMAT_SIGNED_I8] = _mesa_texstore_snorm8;
      table[MESA_FORMAT_SIGNED_A16] = _mesa_texstore_snorm16;
      table[MESA_FORMAT_SIGNED_L16] = _mesa_texstore_snorm16;
      table[MESA_FORMAT_SIGNED_AL1616] = _mesa_texstore_snorm1616;
      table[MESA_FORMAT_SIGNED_I16] = _mesa_texstore_snorm16;
      table[MESA_FORMAT_RGB9_E5_FLOAT] = _mesa_texstore_rgb9_e5;
      table[MESA_FORMAT_R11_G11_B10_FLOAT] = _mesa_texstore_r11_g11_b10f;
      table[MESA_FORMAT_Z32_FLOAT] = _mesa_texstore_z32;
      table[MESA_FORMAT_Z32_FLOAT_X24S8] = _mesa_texstore_z32f_x24s8;

      table[MESA_FORMAT_ALPHA_UINT8] = _mesa_texstore_rgba_uint8;
      table[MESA_FORMAT_ALPHA_UINT16] = _mesa_texstore_rgba_uint16;
      table[MESA_FORMAT_ALPHA_UINT32] = _mesa_texstore_rgba_uint32;
      table[MESA_FORMAT_ALPHA_INT8] = _mesa_texstore_rgba_int8;
      table[MESA_FORMAT_ALPHA_INT16] = _mesa_texstore_rgba_int16;
      table[MESA_FORMAT_ALPHA_INT32] = _mesa_texstore_rgba_int32;

      table[MESA_FORMAT_INTENSITY_UINT8] = _mesa_texstore_rgba_uint8;
      table[MESA_FORMAT_INTENSITY_UINT16] = _mesa_texstore_rgba_uint16;
      table[MESA_FORMAT_INTENSITY_UINT32] = _mesa_texstore_rgba_uint32;
      table[MESA_FORMAT_INTENSITY_INT8] = _mesa_texstore_rgba_int8;
      table[MESA_FORMAT_INTENSITY_INT16] = _mesa_texstore_rgba_int16;
      table[MESA_FORMAT_INTENSITY_INT32] = _mesa_texstore_rgba_int32;

      table[MESA_FORMAT_LUMINANCE_UINT8] = _mesa_texstore_rgba_uint8;
      table[MESA_FORMAT_LUMINANCE_UINT16] = _mesa_texstore_rgba_uint16;
      table[MESA_FORMAT_LUMINANCE_UINT32] = _mesa_texstore_rgba_uint32;
      table[MESA_FORMAT_LUMINANCE_INT8] = _mesa_texstore_rgba_int8;
      table[MESA_FORMAT_LUMINANCE_INT16] = _mesa_texstore_rgba_int16;
      table[MESA_FORMAT_LUMINANCE_INT32] = _mesa_texstore_rgba_int32;

      table[MESA_FORMAT_LUMINANCE_ALPHA_UINT8] = _mesa_texstore_rgba_uint8;
      table[MESA_FORMAT_LUMINANCE_ALPHA_UINT16] = _mesa_texstore_rgba_uint16;
      table[MESA_FORMAT_LUMINANCE_ALPHA_UINT32] = _mesa_texstore_rgba_uint32;
      table[MESA_FORMAT_LUMINANCE_ALPHA_INT8] = _mesa_texstore_rgba_int8;
      table[MESA_FORMAT_LUMINANCE_ALPHA_INT16] = _mesa_texstore_rgba_int16;
      table[MESA_FORMAT_LUMINANCE_ALPHA_INT32] = _mesa_texstore_rgba_int32;

      table[MESA_FORMAT_R_INT8] = _mesa_texstore_rgba_int8;
      table[MESA_FORMAT_RG_INT8] = _mesa_texstore_rgba_int8;
      table[MESA_FORMAT_RGB_INT8] = _mesa_texstore_rgba_int8;
      table[MESA_FORMAT_RGBA_INT8] = _mesa_texstore_rgba_int8;
      table[MESA_FORMAT_R_INT16] = _mesa_texstore_rgba_int16;
      table[MESA_FORMAT_RG_INT16] = _mesa_texstore_rgba_int16;
      table[MESA_FORMAT_RGB_INT16] = _mesa_texstore_rgba_int16;
      table[MESA_FORMAT_RGBA_INT16] = _mesa_texstore_rgba_int16;
      table[MESA_FORMAT_R_INT32] = _mesa_texstore_rgba_int32;
      table[MESA_FORMAT_RG_INT32] = _mesa_texstore_rgba_int32;
      table[MESA_FORMAT_RGB_INT32] = _mesa_texstore_rgba_int32;
      table[MESA_FORMAT_RGBA_INT32] = _mesa_texstore_rgba_int32;
d3825 24
a3848 2
      table[MESA_FORMAT_ARGB2101010_UINT] = _mesa_texstore_argb2101010_uint;
      table[MESA_FORMAT_ABGR2101010_UINT] = _mesa_texstore_abgr2101010_uint;
d3850 1
a3850 15
      table[MESA_FORMAT_XRGB4444_UNORM] = store_ubyte_texture;
      table[MESA_FORMAT_XRGB1555_UNORM] = store_ubyte_texture;
      table[MESA_FORMAT_XBGR8888_SNORM] = _mesa_texstore_signed_rgbx8888;
      table[MESA_FORMAT_XBGR8888_SRGB] = _mesa_texstore_srgba8;
      table[MESA_FORMAT_XBGR8888_UINT] = _mesa_texstore_rgba_uint8;
      table[MESA_FORMAT_XBGR8888_SINT] = _mesa_texstore_rgba_int8;
      table[MESA_FORMAT_XRGB2101010_UNORM] = _mesa_texstore_argb2101010;
      table[MESA_FORMAT_XBGR16161616_UNORM] = _mesa_texstore_rgba_16;
      table[MESA_FORMAT_XBGR16161616_SNORM] = _mesa_texstore_signed_rgba_16;
      table[MESA_FORMAT_XBGR16161616_FLOAT] = _mesa_texstore_rgba_float16;
      table[MESA_FORMAT_XBGR16161616_UINT] = _mesa_texstore_rgba_uint16;
      table[MESA_FORMAT_XBGR16161616_SINT] = _mesa_texstore_rgba_int16;
      table[MESA_FORMAT_XBGR32323232_FLOAT] = _mesa_texstore_rgba_float32;
      table[MESA_FORMAT_XBGR32323232_UINT] = _mesa_texstore_rgba_uint32;
      table[MESA_FORMAT_XBGR32323232_SINT] = _mesa_texstore_rgba_int32;
d3863 1
a3863 1
                                  gl_format dstFormat)
d3892 1
a3892 1
                              GLenum baseInternalFormat, gl_format dstFormat,
d3934 1
d3970 1
a3970 1
get_read_write_mode(GLenum userFormat, gl_format texFormat)
d4032 1
d4213 1
a4213 1
   const gl_format texFormat = texImage->TexFormat;
@


1.8
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a2 1
 * Version:  7.5
d20 4
a23 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
d40 2
a41 3
 *   ctx->Driver.TexImage1D = _mesa_store_teximage1d;
 *   ctx->Driver.TexImage2D = _mesa_store_teximage2d;
 *   ctx->Driver.TexImage3D = _mesa_store_teximage3d;
d57 1
a60 1
#include "mfeatures.h"
d69 1
d73 1
a343 1
          logicalBaseFormat == GL_COLOR_INDEX ||
a353 1
          textureBaseFormat == GL_COLOR_INDEX ||
d356 1
a356 1
   tempImage = (GLfloat *) malloc(srcWidth * srcHeight * srcDepth
d394 1
a394 1
      newImage = (GLfloat *) malloc(srcWidth * srcHeight * srcDepth
d462 1
d465 1
a465 1
   tempImage = (GLuint *) malloc(srcWidth * srcHeight * srcDepth
d503 1
a503 1
      newImage = (GLuint *) malloc(srcWidth * srcHeight * srcDepth
d518 1
a518 1
               newImage[i * texComponents + k] = 0.0F;
d520 1
a520 1
               newImage[i * texComponents + k] = 1.0F;
d536 1
a536 1
 * Make a temporary (color) texture image with GLchan components.
d556 1
a556 1
 * \return resulting image with format = textureBaseFormat and type = GLchan.
d558 8
a565 8
GLchan *
_mesa_make_temp_chan_image(struct gl_context *ctx, GLuint dims,
                           GLenum logicalBaseFormat,
                           GLenum textureBaseFormat,
                           GLint srcWidth, GLint srcHeight, GLint srcDepth,
                           GLenum srcFormat, GLenum srcType,
                           const GLvoid *srcAddr,
                           const struct gl_pixelstore_attrib *srcPacking)
d570 1
a570 1
   GLchan *tempImage, *dst;
d593 2
a594 2
   tempImage = (GLchan *) malloc(srcWidth * srcHeight * srcDepth
                                       * components * sizeof(GLchan));
d609 3
a611 3
         _mesa_unpack_color_span_chan(ctx, srcWidth, logicalBaseFormat, dst,
                                      srcFormat, srcType, src, srcPacking,
                                      transferOps);
d621 1
a621 1
      GLchan *newImage;
d634 2
a635 2
      newImage = (GLchan *) malloc(srcWidth * srcHeight * srcDepth
                                         * texComponents * sizeof(GLchan));
d651 1
a651 1
               newImage[i * texComponents + k] = CHAN_MAX;
a853 2
			  GLvoid *dstAddr,
			  GLint dstXoffset, GLint dstYoffset, GLint dstZoffset,
d855 1
a855 1
                          const GLuint *dstImageOffsets,
d898 1
a898 3
      GLubyte *dstImage = (GLubyte *) dstAddr
         + dstYoffset * dstRowStride
         + dstXoffset * dstComponents;
d906 1
a906 4
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * dstComponents
            + dstYoffset * dstRowStride
            + dstXoffset * dstComponents;
a926 2
               GLvoid *dstAddr,
               GLint dstXoffset, GLint dstYoffset, GLint dstZoffset,
d928 1
a928 1
               const GLuint *dstImageOffsets,
a942 9
#if 0
   /* XXX update/re-enable for dstImageOffsets array */
   const GLint bytesPerImage = srcHeight * bytesPerRow;
   const GLint bytesPerTexture = srcDepth * bytesPerImage;
   GLubyte *dstImage = (GLubyte *) dstAddr
                     + dstZoffset * dstImageStride
                     + dstYoffset * dstRowStride
                     + dstXoffset * texelBytes;

d944 8
a951 6
       dstRowStride == bytesPerRow &&
       ((dstImageStride == srcImageStride &&
         dstImageStride == bytesPerImage) ||
        (srcDepth == 1))) {
      /* one big memcpy */
      ctx->Driver.TextureMemCpy(dstImage, srcImage, bytesPerTexture);
d953 2
a954 2
   else
   {
d958 1
a958 1
         GLubyte *dstRow = dstImage;
d960 1
a960 1
            ctx->Driver.TextureMemCpy(dstRow, srcRow, bytesPerRow);
a964 1
         dstImage += dstImageStride;
d967 23
a989 1
#endif
d991 1
a991 1
   GLint img, row;
d993 4
a996 11
      const GLubyte *srcRow = srcImage;
      GLubyte *dstRow = (GLubyte *) dstAddr
         + dstImageOffsets[dstZoffset + img] * texelBytes
         + dstYoffset * dstRowStride
         + dstXoffset * texelBytes;
      for (row = 0; row < srcHeight; row++) {
         ctx->Driver.TextureMemCpy(dstRow, srcRow, bytesPerRow);
         dstRow += dstRowStride;
         srcRow += srcRowStride;
      }
      srcImage += srcImageStride;
d998 3
d1005 1
d1007 1
a1007 1
 * Store a 32-bit integer depth component texture image.
d1013 1
a1013 1
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
d1015 8
a1022 2
   ASSERT(dstFormat == MESA_FORMAT_Z32);
   ASSERT(texelBytes == sizeof(GLuint));
d1024 1
a1024 15
   if (ctx->Pixel.DepthScale == 1.0f &&
       ctx->Pixel.DepthBias == 0.0f &&
       !srcPacking->SwapBytes &&
       baseInternalFormat == GL_DEPTH_COMPONENT &&
       srcFormat == GL_DEPTH_COMPONENT &&
       srcType == GL_UNSIGNED_INT) {
      /* simple memcpy path */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else {
d1028 1
a1028 4
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * texelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
d1033 1
a1033 1
                                    GL_UNSIGNED_INT, (GLuint *) dstRow,
a1049 1
   const GLuint texelBytes = 4;
d1058 1
a1058 4
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * texelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
a1079 1
   const GLuint texelBytes = 4;
d1088 1
a1088 4
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * texelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
a1113 1
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
d1116 1
a1116 1
   ASSERT(texelBytes == sizeof(GLushort));
d1118 1
a1118 15
   if (ctx->Pixel.DepthScale == 1.0f &&
       ctx->Pixel.DepthBias == 0.0f &&
       !srcPacking->SwapBytes &&
       baseInternalFormat == GL_DEPTH_COMPONENT &&
       srcFormat == GL_DEPTH_COMPONENT &&
       srcType == GL_UNSIGNED_SHORT) {
      /* simple memcpy path */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else {
d1122 1
a1122 4
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * texelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
a1143 3
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

d1146 1
a1146 1
   ASSERT(texelBytes == 2);
a1149 1
       dstFormat == MESA_FORMAT_RGB565 &&
d1152 2
a1153 15
       srcType == GL_UNSIGNED_SHORT_5_6_5) {
      /* simple memcpy path */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else if (!ctx->_ImageTransferState &&
            !srcPacking->SwapBytes &&
            baseInternalFormat == GL_RGB &&
            srcFormat == GL_RGB &&
            srcType == GL_UNSIGNED_BYTE &&
            dims == 2) {
d1160 1
a1160 3
      GLubyte *dst = (GLubyte *) dstAddr
                   + dstYoffset * dstRowStride
                   + dstXoffset * texelBytes;
d1183 4
a1186 39
      /* general path */
      const GLchan *tempImage = _mesa_make_temp_chan_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking);
      const GLchan *src = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * texelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
         for (row = 0; row < srcHeight; row++) {
            GLushort *dstUS = (GLushort *) dstRow;
            /* check for byteswapped format */
            if (dstFormat == MESA_FORMAT_RGB565) {
               for (col = 0; col < srcWidth; col++) {
                  dstUS[col] = PACK_COLOR_565( CHAN_TO_UBYTE(src[RCOMP]),
                                               CHAN_TO_UBYTE(src[GCOMP]),
                                               CHAN_TO_UBYTE(src[BCOMP]) );
                  src += 3;
               }
            }
            else {
               for (col = 0; col < srcWidth; col++) {
                  dstUS[col] = PACK_COLOR_565_REV( CHAN_TO_UBYTE(src[RCOMP]),
                                                   CHAN_TO_UBYTE(src[GCOMP]),
                                                   CHAN_TO_UBYTE(src[BCOMP]) );
                  src += 3;
               }
            }
            dstRow += dstRowStride;
         }
      }
      free((void *) tempImage);
a1198 2
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
d1201 4
a1204 2
          dstFormat == MESA_FORMAT_RGBA8888_REV);
   ASSERT(texelBytes == 4);
d1207 5
a1211 37
       !srcPacking->SwapBytes &&
       dstFormat == MESA_FORMAT_RGBA8888 &&
       baseInternalFormat == GL_RGBA &&
      ((srcFormat == GL_RGBA && srcType == GL_UNSIGNED_INT_8_8_8_8) ||
       (srcFormat == GL_RGBA && srcType == GL_UNSIGNED_BYTE && !littleEndian) ||
       (srcFormat == GL_ABGR_EXT && srcType == GL_UNSIGNED_INT_8_8_8_8_REV) ||
       (srcFormat == GL_ABGR_EXT && srcType == GL_UNSIGNED_BYTE && littleEndian))) {
       /* simple memcpy path */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else if (!ctx->_ImageTransferState &&
       !srcPacking->SwapBytes &&
       dstFormat == MESA_FORMAT_RGBA8888_REV &&
       baseInternalFormat == GL_RGBA &&
      ((srcFormat == GL_RGBA && srcType == GL_UNSIGNED_INT_8_8_8_8_REV) ||
       (srcFormat == GL_RGBA && srcType == GL_UNSIGNED_BYTE && littleEndian) ||
       (srcFormat == GL_ABGR_EXT && srcType == GL_UNSIGNED_INT_8_8_8_8) ||
       (srcFormat == GL_ABGR_EXT && srcType == GL_UNSIGNED_BYTE && !littleEndian))) {
      /* simple memcpy path */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else if (!ctx->_ImageTransferState &&
	    (srcType == GL_UNSIGNED_BYTE ||
	     srcType == GL_UNSIGNED_INT_8_8_8_8 ||
	     srcType == GL_UNSIGNED_INT_8_8_8_8_REV) &&
	    can_swizzle(baseInternalFormat) &&
	    can_swizzle(srcFormat)) {
d1217 4
a1220 2
      if ((littleEndian && dstFormat == MESA_FORMAT_RGBA8888) ||
	  (!littleEndian && dstFormat == MESA_FORMAT_RGBA8888_REV)) {
d1238 1
a1238 2
				dstAddr, dstXoffset, dstYoffset, dstZoffset,
				dstRowStride, dstImageOffsets,
d1243 4
a1246 40
      /* general path */
      const GLchan *tempImage = _mesa_make_temp_chan_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking);
      const GLchan *src = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * texelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
         for (row = 0; row < srcHeight; row++) {
            GLuint *dstUI = (GLuint *) dstRow;
            if (dstFormat == MESA_FORMAT_RGBA8888) {
               for (col = 0; col < srcWidth; col++) {
                  dstUI[col] = PACK_COLOR_8888( CHAN_TO_UBYTE(src[RCOMP]),
                                                CHAN_TO_UBYTE(src[GCOMP]),
                                                CHAN_TO_UBYTE(src[BCOMP]),
                                                CHAN_TO_UBYTE(src[ACOMP]) );
                  src += 4;
               }
            }
            else {
               for (col = 0; col < srcWidth; col++) {
                  dstUI[col] = PACK_COLOR_8888_REV( CHAN_TO_UBYTE(src[RCOMP]),
                                                    CHAN_TO_UBYTE(src[GCOMP]),
                                                    CHAN_TO_UBYTE(src[BCOMP]),
                                                    CHAN_TO_UBYTE(src[ACOMP]) );
                  src += 4;
               }
            }
            dstRow += dstRowStride;
         }
      }
      free((void *) tempImage);
a1255 2
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
   const GLenum baseFormat = GL_RGBA;
d1261 1
a1261 1
   ASSERT(texelBytes == 4);
d1267 4
a1270 36
       baseInternalFormat == GL_RGBA &&
       srcFormat == GL_BGRA &&
       ((srcType == GL_UNSIGNED_BYTE && littleEndian) ||
        srcType == GL_UNSIGNED_INT_8_8_8_8_REV)) {
      /* simple memcpy path (little endian) */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else if (!ctx->_ImageTransferState &&
       !srcPacking->SwapBytes &&
       (dstFormat == MESA_FORMAT_ARGB8888_REV ||
        dstFormat == MESA_FORMAT_XRGB8888_REV) &&
       baseInternalFormat == GL_RGBA &&
       srcFormat == GL_BGRA &&
       ((srcType == GL_UNSIGNED_BYTE && !littleEndian) ||
        srcType == GL_UNSIGNED_INT_8_8_8_8)) {
      /* simple memcpy path (big endian) */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else if (!ctx->_ImageTransferState &&
            !srcPacking->SwapBytes &&
	    (dstFormat == MESA_FORMAT_ARGB8888 ||
             dstFormat == MESA_FORMAT_XRGB8888) &&
            srcFormat == GL_RGB &&
	    (baseInternalFormat == GL_RGBA ||
	     baseInternalFormat == GL_RGB) &&
            srcType == GL_UNSIGNED_BYTE) {
d1277 1
a1277 4
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * texelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
d1293 26
d1336 1
a1336 4
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * texelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
a1385 1
				dstAddr, dstXoffset, dstYoffset, dstZoffset,
d1387 1
a1387 1
                                dstImageOffsets,
d1392 4
a1395 49
      /* general path */
      const GLchan *tempImage = _mesa_make_temp_chan_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking);
      const GLchan *src = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * texelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
         for (row = 0; row < srcHeight; row++) {
            GLuint *dstUI = (GLuint *) dstRow;
            if (dstFormat == MESA_FORMAT_ARGB8888) {
               for (col = 0; col < srcWidth; col++) {
                  dstUI[col] = PACK_COLOR_8888( CHAN_TO_UBYTE(src[ACOMP]),
                                                CHAN_TO_UBYTE(src[RCOMP]),
                                                CHAN_TO_UBYTE(src[GCOMP]),
                                                CHAN_TO_UBYTE(src[BCOMP]) );
                  src += 4;
               }
            }
            else if (dstFormat == MESA_FORMAT_XRGB8888) {
               for (col = 0; col < srcWidth; col++) {
                  dstUI[col] = PACK_COLOR_8888( 0xff,
                                                CHAN_TO_UBYTE(src[RCOMP]),
                                                CHAN_TO_UBYTE(src[GCOMP]),
                                                CHAN_TO_UBYTE(src[BCOMP]) );
                  src += 4;
               }
            }
            else {
               for (col = 0; col < srcWidth; col++) {
                  dstUI[col] = PACK_COLOR_8888_REV( CHAN_TO_UBYTE(src[ACOMP]),
                                                    CHAN_TO_UBYTE(src[RCOMP]),
                                                    CHAN_TO_UBYTE(src[GCOMP]),
                                                    CHAN_TO_UBYTE(src[BCOMP]) );
                  src += 4;
               }
            }
            dstRow += dstRowStride;
         }
      }
      free((void *) tempImage);
a1403 4
   const GLboolean littleEndian = _mesa_little_endian();
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

d1405 1
a1405 1
   ASSERT(texelBytes == 3);
d1409 2
a1410 16
       baseInternalFormat == GL_RGB &&
       srcFormat == GL_BGR &&
       srcType == GL_UNSIGNED_BYTE &&
       littleEndian) {
      /* simple memcpy path */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else if (!ctx->_ImageTransferState &&
            !srcPacking->SwapBytes &&
            srcFormat == GL_RGBA &&
            srcType == GL_UNSIGNED_BYTE) {
d1418 1
a1418 4
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * texelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
d1449 1
a1449 2
				dstAddr, dstXoffset, dstYoffset, dstZoffset,
				dstRowStride, dstImageOffsets,
d1454 4
a1457 46
      /* general path */
      const GLchan *tempImage = _mesa_make_temp_chan_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking);
      const GLchan *src = (const GLchan *) tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * texelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
         for (row = 0; row < srcHeight; row++) {
#if 0
            if (littleEndian) {
               for (col = 0; col < srcWidth; col++) {
                  dstRow[col * 3 + 0] = CHAN_TO_UBYTE(src[RCOMP]);
                  dstRow[col * 3 + 1] = CHAN_TO_UBYTE(src[GCOMP]);
                  dstRow[col * 3 + 2] = CHAN_TO_UBYTE(src[BCOMP]);
                  srcUB += 3;
               }
            }
            else {
               for (col = 0; col < srcWidth; col++) {
                  dstRow[col * 3 + 0] = srcUB[BCOMP];
                  dstRow[col * 3 + 1] = srcUB[GCOMP];
                  dstRow[col * 3 + 2] = srcUB[RCOMP];
                  srcUB += 3;
               }
            }
#else
            for (col = 0; col < srcWidth; col++) {
               dstRow[col * 3 + 0] = CHAN_TO_UBYTE(src[BCOMP]);
               dstRow[col * 3 + 1] = CHAN_TO_UBYTE(src[GCOMP]);
               dstRow[col * 3 + 2] = CHAN_TO_UBYTE(src[RCOMP]);
               src += 3;
            }
#endif
            dstRow += dstRowStride;
         }
      }
      free((void *) tempImage);
a1465 4
   const GLboolean littleEndian = _mesa_little_endian();
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

d1467 1
a1467 1
   ASSERT(texelBytes == 3);
d1471 2
a1472 16
       baseInternalFormat == GL_RGB &&
       srcFormat == GL_RGB &&
       srcType == GL_UNSIGNED_BYTE &&
       littleEndian) {
      /* simple memcpy path */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else if (!ctx->_ImageTransferState &&
            !srcPacking->SwapBytes &&
            srcFormat == GL_RGBA &&
            srcType == GL_UNSIGNED_BYTE) {
d1480 1
a1480 4
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * texelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
d1511 1
a1511 2
				dstAddr, dstXoffset, dstYoffset, dstZoffset,
				dstRowStride, dstImageOffsets,
d1516 17
d1534 3
a1536 1
      const GLchan *tempImage = _mesa_make_temp_chan_image(ctx, dims,
d1538 1
a1538 1
                                                 baseFormat,
d1541 3
a1543 2
                                                 srcPacking);
      const GLchan *src = (const GLchan *) tempImage;
d1548 15
a1562 10
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * texelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
         for (row = 0; row < srcHeight; row++) {
            for (col = 0; col < srcWidth; col++) {
               dstRow[col * 3 + 0] = CHAN_TO_UBYTE(src[RCOMP]);
               dstRow[col * 3 + 1] = CHAN_TO_UBYTE(src[GCOMP]);
               dstRow[col * 3 + 2] = CHAN_TO_UBYTE(src[BCOMP]);
               src += 3;
d1564 2
a1565 1
            dstRow += dstRowStride;
d1574 3
d1578 1
a1578 1
_mesa_texstore_argb4444(TEXSTORE_PARAMS)
a1579 1
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
d1582 2
a1583 281
   ASSERT(dstFormat == MESA_FORMAT_ARGB4444 ||
          dstFormat == MESA_FORMAT_ARGB4444_REV);
   ASSERT(texelBytes == 2);

   if (!ctx->_ImageTransferState &&
       !srcPacking->SwapBytes &&
       dstFormat == MESA_FORMAT_ARGB4444 &&
       baseInternalFormat == GL_RGBA &&
       srcFormat == GL_BGRA &&
       srcType == GL_UNSIGNED_SHORT_4_4_4_4_REV) {
      /* simple memcpy path */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else {
      /* general path */
      const GLchan *tempImage = _mesa_make_temp_chan_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking);
      const GLchan *src = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * texelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
         for (row = 0; row < srcHeight; row++) {
            GLushort *dstUS = (GLushort *) dstRow;
            if (dstFormat == MESA_FORMAT_ARGB4444) {
               for (col = 0; col < srcWidth; col++) {
                  dstUS[col] = PACK_COLOR_4444( CHAN_TO_UBYTE(src[ACOMP]),
                                                CHAN_TO_UBYTE(src[RCOMP]),
                                                CHAN_TO_UBYTE(src[GCOMP]),
                                                CHAN_TO_UBYTE(src[BCOMP]) );
                  src += 4;
               }
            }
            else {
               for (col = 0; col < srcWidth; col++) {
                  dstUS[col] = PACK_COLOR_4444_REV( CHAN_TO_UBYTE(src[ACOMP]),
                                                    CHAN_TO_UBYTE(src[RCOMP]),
                                                    CHAN_TO_UBYTE(src[GCOMP]),
                                                    CHAN_TO_UBYTE(src[BCOMP]) );
                  src += 4;
               }
            }
            dstRow += dstRowStride;
         }
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}

static GLboolean
_mesa_texstore_rgba5551(TEXSTORE_PARAMS)
{
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_RGBA5551);
   ASSERT(texelBytes == 2);

   if (!ctx->_ImageTransferState &&
       !srcPacking->SwapBytes &&
       dstFormat == MESA_FORMAT_RGBA5551 &&
       baseInternalFormat == GL_RGBA &&
       srcFormat == GL_RGBA &&
       srcType == GL_UNSIGNED_SHORT_5_5_5_1) {
      /* simple memcpy path */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else {
      /* general path */
      const GLchan *tempImage = _mesa_make_temp_chan_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking);
      const GLchan *src =tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * texelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
         for (row = 0; row < srcHeight; row++) {
            GLushort *dstUS = (GLushort *) dstRow;
	    for (col = 0; col < srcWidth; col++) {
	       dstUS[col] = PACK_COLOR_5551( CHAN_TO_UBYTE(src[RCOMP]),
					     CHAN_TO_UBYTE(src[GCOMP]),
					     CHAN_TO_UBYTE(src[BCOMP]),
					     CHAN_TO_UBYTE(src[ACOMP]) );
	      src += 4;
	    }
            dstRow += dstRowStride;
         }
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}

static GLboolean
_mesa_texstore_argb1555(TEXSTORE_PARAMS)
{
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_ARGB1555 ||
          dstFormat == MESA_FORMAT_ARGB1555_REV);
   ASSERT(texelBytes == 2);

   if (!ctx->_ImageTransferState &&
       !srcPacking->SwapBytes &&
       dstFormat == MESA_FORMAT_ARGB1555 &&
       baseInternalFormat == GL_RGBA &&
       srcFormat == GL_BGRA &&
       srcType == GL_UNSIGNED_SHORT_1_5_5_5_REV) {
      /* simple memcpy path */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else {
      /* general path */
      const GLchan *tempImage = _mesa_make_temp_chan_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking);
      const GLchan *src =tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * texelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
         for (row = 0; row < srcHeight; row++) {
            GLushort *dstUS = (GLushort *) dstRow;
            if (dstFormat == MESA_FORMAT_ARGB1555) {
               for (col = 0; col < srcWidth; col++) {
                  dstUS[col] = PACK_COLOR_1555( CHAN_TO_UBYTE(src[ACOMP]),
                                                CHAN_TO_UBYTE(src[RCOMP]),
                                                CHAN_TO_UBYTE(src[GCOMP]),
                                                CHAN_TO_UBYTE(src[BCOMP]) );
                  src += 4;
               }
            }
            else {
               for (col = 0; col < srcWidth; col++) {
                  dstUS[col] = PACK_COLOR_1555_REV( CHAN_TO_UBYTE(src[ACOMP]),
                                                    CHAN_TO_UBYTE(src[RCOMP]),
                                                    CHAN_TO_UBYTE(src[GCOMP]),
                                                    CHAN_TO_UBYTE(src[BCOMP]) );
                  src += 4;
               }
            }
            dstRow += dstRowStride;
         }
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}


static GLboolean
_mesa_texstore_argb2101010(TEXSTORE_PARAMS)
{
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_ARGB2101010);
   ASSERT(texelBytes == 4);

   if (!ctx->_ImageTransferState &&
       !srcPacking->SwapBytes &&
       dstFormat == MESA_FORMAT_ARGB2101010 &&
       srcFormat == GL_BGRA &&
       srcType == GL_UNSIGNED_INT_2_10_10_10_REV &&
       baseInternalFormat == GL_RGBA) {
      /* simple memcpy path */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else {
      /* general path */
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *src = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * texelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
         if (baseInternalFormat == GL_RGBA) {
            for (row = 0; row < srcHeight; row++) {
               GLuint *dstUI = (GLuint *) dstRow;
               for (col = 0; col < srcWidth; col++) {
                  GLushort a,r,g,b;

                  UNCLAMPED_FLOAT_TO_USHORT(a, src[ACOMP]);
                  UNCLAMPED_FLOAT_TO_USHORT(r, src[RCOMP]);
                  UNCLAMPED_FLOAT_TO_USHORT(g, src[GCOMP]);
                  UNCLAMPED_FLOAT_TO_USHORT(b, src[BCOMP]);
                  dstUI[col] = PACK_COLOR_2101010_US(a, r, g, b);
                  src += 4;
               }
               dstRow += dstRowStride;
            }
         } else if (baseInternalFormat == GL_RGB) {
            for (row = 0; row < srcHeight; row++) {
               GLuint *dstUI = (GLuint *) dstRow;
               for (col = 0; col < srcWidth; col++) {
                  GLushort r,g,b;

                  UNCLAMPED_FLOAT_TO_USHORT(r, src[RCOMP]);
                  UNCLAMPED_FLOAT_TO_USHORT(g, src[GCOMP]);
                  UNCLAMPED_FLOAT_TO_USHORT(b, src[BCOMP]);
                  dstUI[col] = PACK_COLOR_2101010_US(0xffff, r, g, b);
                  src += 4;
               }
               dstRow += dstRowStride;
            }
         } else {
            ASSERT(0);
         }
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}


/**
 * Do texstore for 2-channel, 4-bit/channel, unsigned normalized formats.
 */
static GLboolean
_mesa_texstore_unorm44(TEXSTORE_PARAMS)
{
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_AL44);
   ASSERT(texelBytes == 1);
d1587 1
a1587 1
      const GLchan *tempImage = _mesa_make_temp_chan_image(ctx, dims,
d1593 1
a1593 1
      const GLchan *src = tempImage;
d1598 1
a1598 4
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * texelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
d1603 2
a1604 2
               dstUS[col] = PACK_COLOR_44( CHAN_TO_UBYTE(src[1]),
                                           CHAN_TO_UBYTE(src[0]) );
a1622 1
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
d1627 3
a1629 3
          dstFormat == MESA_FORMAT_RG88 ||
          dstFormat == MESA_FORMAT_RG88_REV);
   ASSERT(texelBytes == 2);
d1632 1
a1632 6
       !srcPacking->SwapBytes &&
       ((dstFormat == MESA_FORMAT_AL88 &&
         baseInternalFormat == GL_LUMINANCE_ALPHA &&
         srcFormat == GL_LUMINANCE_ALPHA) ||
        (dstFormat == MESA_FORMAT_RG88 &&
         baseInternalFormat == srcFormat)) &&
d1634 2
a1635 14
       littleEndian) {
      /* simple memcpy path */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else if (!ctx->_ImageTransferState &&
	    littleEndian &&
	    srcType == GL_UNSIGNED_BYTE &&
	    can_swizzle(baseInternalFormat) &&
	    can_swizzle(srcFormat)) {
d1652 2
a1653 2
	 if ((littleEndian && dstFormat == MESA_FORMAT_RG88) ||
	     (!littleEndian && dstFormat == MESA_FORMAT_RG88_REV)) {
d1670 1
a1670 2
				dstAddr, dstXoffset, dstYoffset, dstZoffset,
				dstRowStride, dstImageOffsets,
d1676 1
a1676 1
      const GLchan *tempImage = _mesa_make_temp_chan_image(ctx, dims,
d1682 1
a1682 1
      const GLchan *src = tempImage;
d1687 1
a1687 4
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * texelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
d1691 1
a1691 1
		dstFormat == MESA_FORMAT_RG88) {
d1693 3
a1695 3
                  /* src[0] is luminance, src[1] is alpha */
                 dstUS[col] = PACK_COLOR_88( CHAN_TO_UBYTE(src[1]),
                                             CHAN_TO_UBYTE(src[0]) );
d1701 3
a1703 3
                  /* src[0] is luminance, src[1] is alpha */
                 dstUS[col] = PACK_COLOR_88_REV( CHAN_TO_UBYTE(src[1]),
                                                 CHAN_TO_UBYTE(src[0]) );
a1721 2
   const GLboolean littleEndian = _mesa_little_endian();
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
d1726 3
a1728 3
	  dstFormat == MESA_FORMAT_RG1616 ||
          dstFormat == MESA_FORMAT_RG1616_REV);
   ASSERT(texelBytes == 4);
d1730 1
a1730 18
   if (!ctx->_ImageTransferState &&
       !srcPacking->SwapBytes &&
       ((dstFormat == MESA_FORMAT_AL1616 &&
         baseInternalFormat == GL_LUMINANCE_ALPHA &&
         srcFormat == GL_LUMINANCE_ALPHA) ||
        (dstFormat == MESA_FORMAT_RG1616 &&
         baseInternalFormat == srcFormat)) &&
       srcType == GL_UNSIGNED_SHORT &&
       littleEndian) {
      /* simple memcpy path */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else {
d1744 1
a1744 4
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * texelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
d1748 1
a1748 1
		dstFormat == MESA_FORMAT_RG1616) {
a1780 2
   const GLboolean littleEndian = _mesa_little_endian();
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
d1787 1
a1787 1
   ASSERT(texelBytes == 2);
d1789 1
a1789 14
   if (!ctx->_ImageTransferState &&
       !srcPacking->SwapBytes &&
       baseInternalFormat == srcFormat &&
       srcType == GL_UNSIGNED_SHORT &&
       littleEndian) {
      /* simple memcpy path */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else {
d1803 1
a1803 4
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * texelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
d1825 3
a1827 2
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
d1829 1
a1829 17
   ASSERT(dstFormat == MESA_FORMAT_RGBA_16);
   ASSERT(texelBytes == 8);

   if (!ctx->_ImageTransferState &&
       !srcPacking->SwapBytes &&
       baseInternalFormat == GL_RGBA &&
       srcFormat == GL_RGBA &&
       srcType == GL_UNSIGNED_SHORT) {
      /* simple memcpy path */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else {
d1831 2
d1835 1
a1835 1
                                                 baseFormat,
d1842 1
d1845 1
d1847 1
a1847 4
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * texelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
a1874 1
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
d1878 2
a1879 1
          dstFormat == MESA_FORMAT_SIGNED_RGBA_16);
d1881 1
a1881 15
   if (!ctx->_ImageTransferState &&
       !srcPacking->SwapBytes &&
       baseInternalFormat == GL_RGBA &&
       dstFormat == MESA_FORMAT_SIGNED_RGBA_16 &&
       srcFormat == GL_RGBA &&
       srcType == GL_SHORT) {
      /* simple memcpy path */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else {
d1901 1
a1901 4
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * texelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
d1915 16
a1930 1
            } else {
d1950 3
d1954 1
a1954 1
_mesa_texstore_rgb332(TEXSTORE_PARAMS)
a1955 1
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
d1958 5
a1962 2
   ASSERT(dstFormat == MESA_FORMAT_RGB332);
   ASSERT(texelBytes == 1);
d1965 14
a1978 86
       !srcPacking->SwapBytes &&
       baseInternalFormat == GL_RGB &&
       srcFormat == GL_RGB && srcType == GL_UNSIGNED_BYTE_3_3_2) {
      /* simple memcpy path */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else {
      /* general path */
      const GLchan *tempImage = _mesa_make_temp_chan_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking);
      const GLchan *src = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * texelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
         for (row = 0; row < srcHeight; row++) {
            for (col = 0; col < srcWidth; col++) {
               dstRow[col] = PACK_COLOR_332( CHAN_TO_UBYTE(src[RCOMP]),
                                             CHAN_TO_UBYTE(src[GCOMP]),
                                             CHAN_TO_UBYTE(src[BCOMP]) );
               src += 3;
            }
            dstRow += dstRowStride;
         }
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}


/**
 * Texstore for _mesa_texformat_a8, _mesa_texformat_l8, _mesa_texformat_i8.
 */
static GLboolean
_mesa_texstore_unorm8(TEXSTORE_PARAMS)
{
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_A8 ||
          dstFormat == MESA_FORMAT_L8 ||
          dstFormat == MESA_FORMAT_I8 ||
          dstFormat == MESA_FORMAT_R8);
   ASSERT(texelBytes == 1);

   if (!ctx->_ImageTransferState &&
       !srcPacking->SwapBytes &&
       baseInternalFormat == srcFormat &&
       srcType == GL_UNSIGNED_BYTE) {
      /* simple memcpy path */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else if (!ctx->_ImageTransferState &&
	    srcType == GL_UNSIGNED_BYTE &&
	    can_swizzle(baseInternalFormat) &&
	    can_swizzle(srcFormat)) {
      GLubyte dstmap[4];

      /* dstmap - how to swizzle from RGBA to dst format:
       */
      if (dstFormat == MESA_FORMAT_A8) {
	 dstmap[0] = 3;
      }
      else {
	 dstmap[0] = 0;
      }
      dstmap[1] = ZERO;		/* ? */
d1987 1
a1987 2
				dstAddr, dstXoffset, dstYoffset, dstZoffset,
				dstRowStride, dstImageOffsets,
d1993 1
a1993 1
      const GLchan *tempImage = _mesa_make_temp_chan_image(ctx, dims,
d1999 1
a1999 1
      const GLchan *src = tempImage;
d2004 1
a2004 4
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * texelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
d2007 1
a2007 1
               dstRow[col] = CHAN_TO_UBYTE(src[col]);
a2019 44
static GLboolean
_mesa_texstore_ci8(TEXSTORE_PARAMS)
{
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);

   (void) dims; (void) baseInternalFormat;
   ASSERT(dstFormat == MESA_FORMAT_CI8);
   ASSERT(texelBytes == 1);
   ASSERT(baseInternalFormat == GL_COLOR_INDEX);

   if (!ctx->_ImageTransferState &&
       !srcPacking->SwapBytes &&
       srcFormat == GL_COLOR_INDEX &&
       srcType == GL_UNSIGNED_BYTE) {
      /* simple memcpy path */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else {
      /* general path */
      GLint img, row;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * texelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
         for (row = 0; row < srcHeight; row++) {
            const GLvoid *src = _mesa_image_address(dims, srcPacking,
                srcAddr, srcWidth, srcHeight, srcFormat, srcType, img, row, 0);
            _mesa_unpack_index_span(ctx, srcWidth, GL_UNSIGNED_BYTE, dstRow,
                                    srcType, src, srcPacking,
                                    ctx->_ImageTransferState);
            dstRow += dstRowStride;
         }
      }
   }
   return GL_TRUE;
}


a2026 1
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
d2032 1
a2032 1
   ASSERT(texelBytes == 2);
d2041 2
a2042 3
                  dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                  dstRowStride,
                  dstImageOffsets,
d2054 1
a2054 4
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * texelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
d2077 1
a2077 11
   if (!srcPacking->SwapBytes && srcType == GL_BYTE &&
       littleEndian) {
      /* simple memcpy path */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else if (srcType == GL_BYTE) {
d2098 1
a2098 2
				dstAddr, dstXoffset, dstYoffset, dstZoffset,
				dstRowStride, dstImageOffsets,
d2110 1
a2110 1
      tempImage = (GLbyte *) malloc(srcWidth * srcHeight * srcDepth
d2130 1
a2130 3
      dst = (GLbyte *) dstAddr
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
a2147 1
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
d2154 1
a2154 1
   ASSERT(texelBytes == 1);
d2156 1
a2156 13
   if (!ctx->_ImageTransferState &&
       !srcPacking->SwapBytes &&
       baseInternalFormat == srcFormat &&
       srcType == GL_BYTE) {
      /* simple memcpy path */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else {
d2170 1
a2170 4
         GLbyte *dstRow = (GLbyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * texelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
a2190 2
   const GLboolean littleEndian = _mesa_little_endian();
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
d2195 1
a2195 1
   ASSERT(texelBytes == 2);
d2197 1
a2197 14
   if (!ctx->_ImageTransferState &&
       !srcPacking->SwapBytes &&
       baseInternalFormat == srcFormat &&
       srcType == GL_BYTE &&
       littleEndian) {
      /* simple memcpy path */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else {
d2211 1
a2211 4
         GLbyte *dstRow = (GLbyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * texelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
a2231 2
   const GLboolean littleEndian = _mesa_little_endian();
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
d2238 1
a2238 1
   ASSERT(texelBytes == 2);
d2240 1
a2240 14
   if (!ctx->_ImageTransferState &&
       !srcPacking->SwapBytes &&
       baseInternalFormat == srcFormat &&
       srcType == GL_SHORT &&
       littleEndian) {
      /* simple memcpy path */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else {
d2254 1
a2254 4
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * texelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
a2277 2
   const GLboolean littleEndian = _mesa_little_endian();
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
d2282 1
a2282 1
   ASSERT(texelBytes == 4);
d2284 1
a2284 14
   if (!ctx->_ImageTransferState &&
       !srcPacking->SwapBytes &&
       baseInternalFormat == srcFormat &&
       srcType == GL_SHORT &&
       littleEndian) {
      /* simple memcpy path */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else {
d2298 1
a2298 4
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * texelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
d2320 2
a2321 1
 * Store a texture in MESA_FORMAT_SIGNED_RGBX8888.
a2325 1
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
d2328 3
a2330 2
   ASSERT(dstFormat == MESA_FORMAT_SIGNED_RGBX8888);
   ASSERT(texelBytes == 4);
d2346 1
a2346 4
         GLbyte *dstRow = (GLbyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * texelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
d2349 19
a2367 7
            for (col = 0; col < srcWidth; col++) {
               dst[3] = FLOAT_TO_BYTE_TEX(srcRow[RCOMP]);
               dst[2] = FLOAT_TO_BYTE_TEX(srcRow[GCOMP]);
               dst[1] = FLOAT_TO_BYTE_TEX(srcRow[BCOMP]);
               dst[0] = 127;
               srcRow += 3;
               dst += 4;
a2385 2
   const GLboolean littleEndian = _mesa_little_endian();
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
d2390 1
a2390 1
   ASSERT(texelBytes == 4);
d2392 1
a2392 29
   if (!ctx->_ImageTransferState &&
       !srcPacking->SwapBytes &&
       dstFormat == MESA_FORMAT_SIGNED_RGBA8888 &&
       baseInternalFormat == GL_RGBA &&
      ((srcFormat == GL_RGBA && srcType == GL_BYTE && !littleEndian) ||
       (srcFormat == GL_ABGR_EXT && srcType == GL_BYTE && littleEndian))) {
       /* simple memcpy path */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else if (!ctx->_ImageTransferState &&
       !srcPacking->SwapBytes &&
       dstFormat == MESA_FORMAT_SIGNED_RGBA8888_REV &&
       baseInternalFormat == GL_RGBA &&
      ((srcFormat == GL_RGBA && srcType == GL_BYTE && littleEndian) ||
       (srcFormat == GL_ABGR_EXT && srcType == GL_BYTE && !littleEndian))) {
      /* simple memcpy path */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else {
d2406 1
a2406 4
         GLbyte *dstRow = (GLbyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * texelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
d2455 11
a2465 13
   if (srcFormat == GL_DEPTH_STENCIL && ctx->Pixel.DepthScale == 1.0f &&
       ctx->Pixel.DepthBias == 0.0f &&
       !srcPacking->SwapBytes) {
      /* simple path */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else if (srcFormat == GL_DEPTH_COMPONENT ||
            srcFormat == GL_STENCIL_INDEX) {
d2468 1
a2468 4
	 GLuint *dstRow = (GLuint *) dstAddr
            + dstImageOffsets[dstZoffset + img]
            + dstYoffset * dstRowStride / sizeof(GLuint)
            + dstXoffset;
a2474 2
            GLuint depth[MAX_WIDTH];
	    GLubyte stencil[MAX_WIDTH];
d2512 3
d2530 2
d2540 9
d2550 1
a2550 4
      GLuint *dstRow = (GLuint *) dstAddr
	 + dstImageOffsets[dstZoffset + img]
	 + dstYoffset * dstRowStride / sizeof(GLuint)
	 + dstXoffset;
a2556 2
	 GLuint depth[MAX_WIDTH];
	 GLubyte stencil[MAX_WIDTH];
d2595 4
d2612 1
a2612 13
   if (!ctx->_ImageTransferState &&
       !srcPacking->SwapBytes &&
       baseInternalFormat == srcFormat &&
       srcType == GL_UNSIGNED_BYTE) {
      /* simple memcpy path */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else {
d2616 5
a2620 1
      
d2622 1
a2622 4
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img]
            + dstYoffset * dstRowStride / sizeof(GLuint)
            + dstXoffset;
a2628 1
            GLubyte stencil[MAX_WIDTH];
d2646 1
d2665 8
a2672 3
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
   const GLint components = _mesa_components_in_format(baseFormat);
d2681 2
a2682 1
          dstFormat == MESA_FORMAT_RG_FLOAT32);
d2691 1
a2691 1
   ASSERT(texelBytes == components * sizeof(GLfloat));
d2693 1
a2693 14
   if (!ctx->_ImageTransferState &&
       !srcPacking->SwapBytes &&
       baseInternalFormat == srcFormat &&
       baseInternalFormat == baseFormat &&
       srcType == GL_FLOAT) {
      /* simple memcpy path */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else {
d2709 1
a2709 4
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * texelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
d2730 8
a2737 3
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
   const GLint components = _mesa_components_in_format(baseFormat);
d2746 2
a2747 1
          dstFormat == MESA_FORMAT_RG_FLOAT16);
d2756 1
a2756 1
   ASSERT(texelBytes == components * sizeof(GLhalfARB));
d2758 1
a2758 14
   if (!ctx->_ImageTransferState &&
       !srcPacking->SwapBytes &&
       baseInternalFormat == srcFormat &&
       baseInternalFormat == baseFormat &&
       srcType == GL_HALF_FLOAT_ARB) {
      /* simple memcpy path */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else {
d2772 1
a2772 4
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * texelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
d2794 2
a2795 3
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
   const GLint components = _mesa_components_in_format(baseFormat);
d2797 15
a2811 1
   ASSERT(dstFormat == MESA_FORMAT_RGBA_INT8);
d2814 2
d2820 1
a2820 1
   ASSERT(texelBytes == components * sizeof(GLbyte));
d2822 1
a2822 15
   /* Note: Pixel transfer ops (scale, bias, table lookup) do not apply
    * to integer formats.
    */
   if (!srcPacking->SwapBytes &&
       baseInternalFormat == srcFormat &&
       srcType == GL_BYTE) {
      /* simple memcpy path */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else {
d2824 8
a2831 7
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking, 0x0);
      const GLfloat *src = tempImage;
d2833 1
d2837 1
a2837 4
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * texelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
d2841 8
a2848 2
            for (i = 0; i < srcWidth * components; i++) {
               dstTexel[i] = (GLbyte) src[i];
d2865 2
a2866 3
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
   const GLint components = _mesa_components_in_format(baseFormat);
d2868 15
a2882 1
   ASSERT(dstFormat == MESA_FORMAT_RGBA_INT16);
d2885 2
d2891 1
a2891 1
   ASSERT(texelBytes == components * sizeof(GLshort));
d2893 1
a2893 15
   /* Note: Pixel transfer ops (scale, bias, table lookup) do not apply
    * to integer formats.
    */
   if (!srcPacking->SwapBytes &&
       baseInternalFormat == srcFormat &&
       srcType == GL_SHORT) {
      /* simple memcpy path */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else {
d2895 8
a2902 7
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking, 0x0);
      const GLfloat *src = tempImage;
d2904 1
d2908 1
a2908 4
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * texelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
d2912 8
a2919 2
            for (i = 0; i < srcWidth * components; i++) {
               dstTexel[i] = (GLint) src[i];
d2936 2
a2937 3
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
   const GLint components = _mesa_components_in_format(baseFormat);
d2939 15
a2953 1
   ASSERT(dstFormat == MESA_FORMAT_RGBA_INT32);
d2956 2
d2962 1
a2962 1
   ASSERT(texelBytes == components * sizeof(GLint));
d2964 1
a2964 15
   /* Note: Pixel transfer ops (scale, bias, table lookup) do not apply
    * to integer formats.
    */
   if (!srcPacking->SwapBytes &&
       baseInternalFormat == srcFormat &&
       srcType == GL_INT) {
      /* simple memcpy path */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else {
d2966 8
a2973 7
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking, 0x0);
      const GLfloat *src = tempImage;
d2975 1
d2979 1
a2979 4
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * texelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
d2983 8
a2990 2
            for (i = 0; i < srcWidth * components; i++) {
               dstTexel[i] = (GLint) src[i];
d3007 2
a3008 3
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
   const GLint components = _mesa_components_in_format(baseFormat);
d3010 15
a3024 1
   ASSERT(dstFormat == MESA_FORMAT_RGBA_UINT8);
d3027 2
d3033 1
a3033 1
   ASSERT(texelBytes == components * sizeof(GLubyte));
d3035 1
a3035 15
   /* Note: Pixel transfer ops (scale, bias, table lookup) do not apply
    * to integer formats.
    */
   if (!srcPacking->SwapBytes &&
       baseInternalFormat == srcFormat &&
       srcType == GL_UNSIGNED_BYTE) {
      /* simple memcpy path */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else {
d3043 1
d3047 1
a3047 4
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * texelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
d3051 8
a3058 2
            for (i = 0; i < srcWidth * components; i++) {
               dstTexel[i] = (GLubyte) CLAMP(src[i], 0, 0xff);
d3075 2
a3076 3
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
   const GLint components = _mesa_components_in_format(baseFormat);
d3078 15
a3092 1
   ASSERT(dstFormat == MESA_FORMAT_RGBA_UINT16);
d3095 2
d3101 1
a3101 1
   ASSERT(texelBytes == components * sizeof(GLushort));
d3103 1
a3103 15
   /* Note: Pixel transfer ops (scale, bias, table lookup) do not apply
    * to integer formats.
    */
   if (!srcPacking->SwapBytes &&
       baseInternalFormat == srcFormat &&
       srcType == GL_UNSIGNED_SHORT) {
      /* simple memcpy path */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else {
d3111 1
d3115 1
a3115 4
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * texelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
d3119 8
a3126 2
            for (i = 0; i < srcWidth * components; i++) {
               dstTexel[i] = (GLushort) CLAMP(src[i], 0, 0xffff);
d3143 2
a3144 3
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
   const GLint components = _mesa_components_in_format(baseFormat);
d3146 15
a3160 1
   ASSERT(dstFormat == MESA_FORMAT_RGBA_UINT32);
d3163 2
d3169 1
a3169 1
   ASSERT(texelBytes == components * sizeof(GLuint));
d3171 1
a3171 15
   /* Note: Pixel transfer ops (scale, bias, table lookup) do not apply
    * to integer formats.
    */
   if (!srcPacking->SwapBytes &&
       baseInternalFormat == srcFormat &&
       srcType == GL_UNSIGNED_INT) {
      /* simple memcpy path */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else {
d3178 1
d3183 1
a3183 4
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * texelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
d3187 8
a3194 2
            for (i = 0; i < srcWidth * components; i++) {
               dstTexel[i] = src[i];
a3206 3


#if FEATURE_EXT_texture_sRGB
d3219 2
a3220 3
                             newDstFormat, dstAddr,
                             dstXoffset, dstYoffset, dstZoffset,
                             dstRowStride, dstImageOffsets,
d3234 2
a3235 1
   ASSERT(dstFormat == MESA_FORMAT_SRGBA8);
d3238 11
a3248 1
   newDstFormat = MESA_FORMAT_RGBA8888;
d3250 2
a3251 3
                               newDstFormat, dstAddr,
                               dstXoffset, dstYoffset, dstZoffset,
                               dstRowStride, dstImageOffsets,
d3271 2
a3272 3
                               newDstFormat, dstAddr,
                               dstXoffset, dstYoffset, dstZoffset,
                               dstRowStride, dstImageOffsets,
d3292 5
a3296 6
                         newDstFormat, dstAddr,
                         dstXoffset, dstYoffset, dstZoffset,
                         dstRowStride, dstImageOffsets,
                         srcWidth, srcHeight, srcDepth,
                         srcFormat, srcType,
                         srcAddr, srcPacking);
d3313 2
a3314 3
			      newDstFormat, dstAddr,
			      dstXoffset, dstYoffset, dstZoffset,
			      dstRowStride, dstImageOffsets,
a3320 11
#else

/* these are used only in texstore_funcs[] below */
#define _mesa_texstore_srgb8 NULL
#define _mesa_texstore_srgba8 NULL
#define _mesa_texstore_sargb8 NULL
#define _mesa_texstore_sl8 NULL
#define _mesa_texstore_sla8 NULL

#endif /* FEATURE_EXT_texture_sRGB */

d3329 1
a3329 13
   if (!ctx->_ImageTransferState &&
       !srcPacking->SwapBytes &&
       srcFormat == GL_RGB &&
       srcType == GL_UNSIGNED_INT_5_9_9_9_REV) {
      /* simple memcpy path */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else {
d3343 1
a3343 4
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * 4
            + dstYoffset * dstRowStride
            + dstXoffset * 4;
d3367 1
a3367 13
   if (!ctx->_ImageTransferState &&
       !srcPacking->SwapBytes &&
       srcFormat == GL_RGB &&
       srcType == GL_UNSIGNED_INT_10F_11F_11F_REV) {
      /* simple memcpy path */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else {
d3381 1
a3381 4
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * 4
            + dstYoffset * dstRowStride
            + dstXoffset * 4;
d3398 50
d3449 54
a3502 7
/**
 * Table mapping MESA_FORMAT_* to _mesa_texstore_*()
 * XXX this is somewhat temporary.
 */
static const struct {
   gl_format Name;
   StoreTexImageFunc Store;
d3504 3
a3506 1
texstore_funcs[MESA_FORMAT_COUNT] =
d3508 1
a3508 120
   { MESA_FORMAT_NONE, NULL },
   { MESA_FORMAT_RGBA8888, _mesa_texstore_rgba8888 },
   { MESA_FORMAT_RGBA8888_REV, _mesa_texstore_rgba8888 },
   { MESA_FORMAT_ARGB8888, _mesa_texstore_argb8888 },
   { MESA_FORMAT_ARGB8888_REV, _mesa_texstore_argb8888 },
   { MESA_FORMAT_XRGB8888, _mesa_texstore_argb8888 },
   { MESA_FORMAT_XRGB8888_REV, _mesa_texstore_argb8888 },
   { MESA_FORMAT_RGB888, _mesa_texstore_rgb888 },
   { MESA_FORMAT_BGR888, _mesa_texstore_bgr888 },
   { MESA_FORMAT_RGB565, _mesa_texstore_rgb565 },
   { MESA_FORMAT_RGB565_REV, _mesa_texstore_rgb565 },
   { MESA_FORMAT_ARGB4444, _mesa_texstore_argb4444 },
   { MESA_FORMAT_ARGB4444_REV, _mesa_texstore_argb4444 },
   { MESA_FORMAT_RGBA5551, _mesa_texstore_rgba5551 },
   { MESA_FORMAT_ARGB1555, _mesa_texstore_argb1555 },
   { MESA_FORMAT_ARGB1555_REV, _mesa_texstore_argb1555 },
   { MESA_FORMAT_AL44, _mesa_texstore_unorm44 },
   { MESA_FORMAT_AL88, _mesa_texstore_unorm88 },
   { MESA_FORMAT_AL88_REV, _mesa_texstore_unorm88 },
   { MESA_FORMAT_AL1616, _mesa_texstore_unorm1616 },
   { MESA_FORMAT_AL1616_REV, _mesa_texstore_unorm1616 },
   { MESA_FORMAT_RGB332, _mesa_texstore_rgb332 },
   { MESA_FORMAT_A8, _mesa_texstore_unorm8 },
   { MESA_FORMAT_A16, _mesa_texstore_unorm16 },
   { MESA_FORMAT_L8, _mesa_texstore_unorm8 },
   { MESA_FORMAT_L16, _mesa_texstore_unorm16 },
   { MESA_FORMAT_I8, _mesa_texstore_unorm8 },
   { MESA_FORMAT_I16, _mesa_texstore_unorm16 },
   { MESA_FORMAT_CI8, _mesa_texstore_ci8 },
   { MESA_FORMAT_YCBCR, _mesa_texstore_ycbcr },
   { MESA_FORMAT_YCBCR_REV, _mesa_texstore_ycbcr },
   { MESA_FORMAT_R8, _mesa_texstore_unorm8 },
   { MESA_FORMAT_RG88, _mesa_texstore_unorm88 },
   { MESA_FORMAT_RG88_REV, _mesa_texstore_unorm88 },
   { MESA_FORMAT_R16, _mesa_texstore_unorm16 },
   { MESA_FORMAT_RG1616, _mesa_texstore_unorm1616 },
   { MESA_FORMAT_RG1616_REV, _mesa_texstore_unorm1616 },
   { MESA_FORMAT_ARGB2101010, _mesa_texstore_argb2101010 },
   { MESA_FORMAT_Z24_S8, _mesa_texstore_z24_s8 },
   { MESA_FORMAT_S8_Z24, _mesa_texstore_s8_z24 },
   { MESA_FORMAT_Z16, _mesa_texstore_z16 },
   { MESA_FORMAT_X8_Z24, _mesa_texstore_x8_z24 },
   { MESA_FORMAT_Z24_X8, _mesa_texstore_z24_x8 },
   { MESA_FORMAT_Z32, _mesa_texstore_z32 },
   { MESA_FORMAT_S8, _mesa_texstore_s8 },
   { MESA_FORMAT_SRGB8, _mesa_texstore_srgb8 },
   { MESA_FORMAT_SRGBA8, _mesa_texstore_srgba8 },
   { MESA_FORMAT_SARGB8, _mesa_texstore_sargb8 },
   { MESA_FORMAT_SL8, _mesa_texstore_sl8 },
   { MESA_FORMAT_SLA8, _mesa_texstore_sla8 },
   { MESA_FORMAT_SRGB_DXT1, _mesa_texstore_rgb_dxt1 },
   { MESA_FORMAT_SRGBA_DXT1, _mesa_texstore_rgba_dxt1 },
   { MESA_FORMAT_SRGBA_DXT3, _mesa_texstore_rgba_dxt3 },
   { MESA_FORMAT_SRGBA_DXT5, _mesa_texstore_rgba_dxt5 },
   { MESA_FORMAT_RGB_FXT1, _mesa_texstore_rgb_fxt1 },
   { MESA_FORMAT_RGBA_FXT1, _mesa_texstore_rgba_fxt1 },
   { MESA_FORMAT_RGB_DXT1, _mesa_texstore_rgb_dxt1 },
   { MESA_FORMAT_RGBA_DXT1, _mesa_texstore_rgba_dxt1 },
   { MESA_FORMAT_RGBA_DXT3, _mesa_texstore_rgba_dxt3 },
   { MESA_FORMAT_RGBA_DXT5, _mesa_texstore_rgba_dxt5 },
   { MESA_FORMAT_RGBA_FLOAT32, _mesa_texstore_rgba_float32 },
   { MESA_FORMAT_RGBA_FLOAT16, _mesa_texstore_rgba_float16 },
   { MESA_FORMAT_RGB_FLOAT32, _mesa_texstore_rgba_float32 },
   { MESA_FORMAT_RGB_FLOAT16, _mesa_texstore_rgba_float16 },
   { MESA_FORMAT_ALPHA_FLOAT32, _mesa_texstore_rgba_float32 },
   { MESA_FORMAT_ALPHA_FLOAT16, _mesa_texstore_rgba_float16 },
   { MESA_FORMAT_LUMINANCE_FLOAT32, _mesa_texstore_rgba_float32 },
   { MESA_FORMAT_LUMINANCE_FLOAT16, _mesa_texstore_rgba_float16 },
   { MESA_FORMAT_LUMINANCE_ALPHA_FLOAT32, _mesa_texstore_rgba_float32 },
   { MESA_FORMAT_LUMINANCE_ALPHA_FLOAT16, _mesa_texstore_rgba_float16 },
   { MESA_FORMAT_INTENSITY_FLOAT32, _mesa_texstore_rgba_float32 },
   { MESA_FORMAT_INTENSITY_FLOAT16, _mesa_texstore_rgba_float16 },
   { MESA_FORMAT_R_FLOAT32, _mesa_texstore_rgba_float32 },
   { MESA_FORMAT_R_FLOAT16, _mesa_texstore_rgba_float16 },
   { MESA_FORMAT_RG_FLOAT32, _mesa_texstore_rgba_float32 },
   { MESA_FORMAT_RG_FLOAT16, _mesa_texstore_rgba_float16 },

   { MESA_FORMAT_RGBA_INT8, _mesa_texstore_rgba_int8 },
   { MESA_FORMAT_RGBA_INT16, _mesa_texstore_rgba_int16 },
   { MESA_FORMAT_RGBA_INT32, _mesa_texstore_rgba_int32 },
   { MESA_FORMAT_RGBA_UINT8, _mesa_texstore_rgba_uint8 },
   { MESA_FORMAT_RGBA_UINT16, _mesa_texstore_rgba_uint16 },
   { MESA_FORMAT_RGBA_UINT32, _mesa_texstore_rgba_uint32 },

   { MESA_FORMAT_DUDV8, _mesa_texstore_dudv8 },

   { MESA_FORMAT_SIGNED_R8, _mesa_texstore_snorm8 },
   { MESA_FORMAT_SIGNED_RG88_REV, _mesa_texstore_snorm88 },
   { MESA_FORMAT_SIGNED_RGBX8888, _mesa_texstore_signed_rgbx8888 },

   { MESA_FORMAT_SIGNED_RGBA8888, _mesa_texstore_signed_rgba8888 },
   { MESA_FORMAT_SIGNED_RGBA8888_REV, _mesa_texstore_signed_rgba8888 },

   { MESA_FORMAT_SIGNED_R16, _mesa_texstore_snorm16 },
   { MESA_FORMAT_SIGNED_GR1616, _mesa_texstore_snorm1616 },
   { MESA_FORMAT_SIGNED_RGB_16, _mesa_texstore_signed_rgba_16 },
   { MESA_FORMAT_SIGNED_RGBA_16, _mesa_texstore_signed_rgba_16 },
   { MESA_FORMAT_RGBA_16, _mesa_texstore_rgba_16 },

   { MESA_FORMAT_RED_RGTC1, _mesa_texstore_red_rgtc1 },
   { MESA_FORMAT_SIGNED_RED_RGTC1, _mesa_texstore_signed_red_rgtc1 },
   { MESA_FORMAT_RG_RGTC2, _mesa_texstore_rg_rgtc2 },
   { MESA_FORMAT_SIGNED_RG_RGTC2, _mesa_texstore_signed_rg_rgtc2 },

   /* Re-use the R/RG texstore functions.
    * The code is generic enough to handle LATC too. */
   { MESA_FORMAT_L_LATC1, _mesa_texstore_red_rgtc1 },
   { MESA_FORMAT_SIGNED_L_LATC1, _mesa_texstore_signed_red_rgtc1 },
   { MESA_FORMAT_LA_LATC2, _mesa_texstore_rg_rgtc2 },
   { MESA_FORMAT_SIGNED_LA_LATC2, _mesa_texstore_signed_rg_rgtc2 },

   { MESA_FORMAT_SIGNED_A8, _mesa_texstore_snorm8 },
   { MESA_FORMAT_SIGNED_L8, _mesa_texstore_snorm8 },
   { MESA_FORMAT_SIGNED_AL88, _mesa_texstore_snorm88 },
   { MESA_FORMAT_SIGNED_I8, _mesa_texstore_snorm8 },

   { MESA_FORMAT_SIGNED_A16, _mesa_texstore_snorm16 },
   { MESA_FORMAT_SIGNED_L16, _mesa_texstore_snorm16 },
   { MESA_FORMAT_SIGNED_AL1616, _mesa_texstore_snorm1616 },
   { MESA_FORMAT_SIGNED_I16, _mesa_texstore_snorm16 },
d3510 2
a3511 3
   { MESA_FORMAT_RGB9_E5_FLOAT, _mesa_texstore_rgb9_e5 },
   { MESA_FORMAT_R11_G11_B10_FLOAT, _mesa_texstore_r11_g11_b10f },
};
d3513 47
d3567 1
a3567 3
   (void) dstAddr;
   (void) dstXoffset; (void) dstYoffset; (void) dstZoffset;
   (void) dstRowStride; (void) dstImageOffsets;
d3585 201
a3785 4
#ifdef DEBUG
   GLuint i;
   for (i = 0; i < MESA_FORMAT_COUNT; i++) {
      ASSERT(texstore_funcs[i].Name == i);
a3786 2
#endif
   ASSERT(texstore_funcs[format].Name == format);
d3788 2
a3789 4
   if (texstore_funcs[format].Store)
      return texstore_funcs[format].Store;
   else
      return _mesa_texstore_null;
a3792 4
/**
 * Store user data into texture memory.
 * Called via glTex[Sub]Image1/2/3D()
 */
d3794 12
a3805 4
_mesa_texstore(TEXSTORE_PARAMS)
{
   StoreTexImageFunc storeImage;
   GLboolean success;
d3807 2
a3808 1
   storeImage = _mesa_get_texstore_func(dstFormat);
d3810 6
a3815 7
   success = storeImage(ctx, dims, baseInternalFormat,
                        dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                        dstRowStride, dstImageOffsets,
                        srcWidth, srcHeight, srcDepth,
                        srcFormat, srcType, srcAddr, srcPacking);
   return success;
}
d3817 3
a3819 8

/** Return texture size in bytes */
static GLuint
texture_size(const struct gl_texture_image *texImage)
{
   GLuint sz = _mesa_format_image_size(texImage->TexFormat, texImage->Width,
                                       texImage->Height, texImage->Depth);
   return sz;
d3823 5
a3827 3
/** Return row stride in bytes */
static GLuint
texture_row_stride(const struct gl_texture_image *texImage)
d3829 3
a3831 4
   GLuint stride = _mesa_format_row_stride(texImage->TexFormat,
                                           texImage->Width);
   return stride;
}
d3833 3
a3835 25


/**
 * This is the software fallback for Driver.TexImage1D()
 * and Driver.CopyTexImage1D().
 * \sa _mesa_store_teximage2d()
 */
void
_mesa_store_teximage1d(struct gl_context *ctx, GLenum target, GLint level,
                       GLint internalFormat,
                       GLint width, GLint border,
                       GLenum format, GLenum type, const GLvoid *pixels,
                       const struct gl_pixelstore_attrib *packing,
                       struct gl_texture_object *texObj,
                       struct gl_texture_image *texImage)
{
   GLuint sizeInBytes;
   (void) border;

   /* allocate memory */
   sizeInBytes = texture_size(texImage);
   texImage->Data = _mesa_alloc_texmemory(sizeInBytes);
   if (!texImage->Data) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glTexImage1D");
      return;
d3838 4
a3841 21
   pixels = _mesa_validate_pbo_teximage(ctx, 1, width, 1, 1, format, type,
                                        pixels, packing, "glTexImage1D");
   if (!pixels) {
      /* Note: we check for a NULL image pointer here, _after_ we allocated
       * memory for the texture.  That's what the GL spec calls for.
       */
      return;
   }
   else {
      const GLint dstRowStride = 0;
      GLboolean success = _mesa_texstore(ctx, 1, texImage->_BaseFormat,
                                         texImage->TexFormat,
                                         texImage->Data,
                                         0, 0, 0,  /* dstX/Y/Zoffset */
                                         dstRowStride,
                                         texImage->ImageOffsets,
                                         width, 1, 1,
                                         format, type, pixels, packing);
      if (!success) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glTexImage1D");
      }
d3844 1
a3844 1
   _mesa_unmap_teximage_pbo(ctx, packing);
d3847 6
a3852 26

/**
 * This is the software fallback for Driver.TexImage2D()
 * and Driver.CopyTexImage2D().
 *
 * This function is oriented toward storing images in main memory, rather
 * than VRAM.  Device driver's can easily plug in their own replacement.
 */
void
_mesa_store_teximage2d(struct gl_context *ctx, GLenum target, GLint level,
                       GLint internalFormat,
                       GLint width, GLint height, GLint border,
                       GLenum format, GLenum type, const void *pixels,
                       const struct gl_pixelstore_attrib *packing,
                       struct gl_texture_object *texObj,
                       struct gl_texture_image *texImage)
{
   GLuint sizeInBytes;
   (void) border;

   /* allocate memory */
   sizeInBytes = texture_size(texImage);
   texImage->Data = _mesa_alloc_texmemory(sizeInBytes);
   if (!texImage->Data) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glTexImage2D");
      return;
d3855 6
a3860 24
   pixels = _mesa_validate_pbo_teximage(ctx, 2, width, height, 1, format, type,
                                        pixels, packing, "glTexImage2D");
   if (!pixels) {
      /* Note: we check for a NULL image pointer here, _after_ we allocated
       * memory for the texture.  That's what the GL spec calls for.
       */
      return;
   }
   else {
      GLint dstRowStride = texture_row_stride(texImage);
      GLboolean success = _mesa_texstore(ctx, 2, texImage->_BaseFormat,
                                         texImage->TexFormat,
                                         texImage->Data,
                                         0, 0, 0,  /* dstX/Y/Zoffset */
                                         dstRowStride,
                                         texImage->ImageOffsets,
                                         width, height, 1,
                                         format, type, pixels, packing);
      if (!success) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glTexImage2D");
      }
   }

   _mesa_unmap_teximage_pbo(ctx, packing);
a3863 1

d3865 2
a3866 3
 * This is the software fallback for Driver.TexImage3D()
 * and Driver.CopyTexImage3D().
 * \sa _mesa_store_teximage2d()
d3868 12
a3879 18
void
_mesa_store_teximage3d(struct gl_context *ctx, GLenum target, GLint level,
                       GLint internalFormat,
                       GLint width, GLint height, GLint depth, GLint border,
                       GLenum format, GLenum type, const void *pixels,
                       const struct gl_pixelstore_attrib *packing,
                       struct gl_texture_object *texObj,
                       struct gl_texture_image *texImage)
{
   GLuint sizeInBytes;
   (void) border;

   /* allocate memory */
   sizeInBytes = texture_size(texImage);
   texImage->Data = _mesa_alloc_texmemory(sizeInBytes);
   if (!texImage->Data) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glTexImage3D");
      return;
d3882 1
a3882 22
   pixels = _mesa_validate_pbo_teximage(ctx, 3, width, height, depth, format,
                                        type, pixels, packing, "glTexImage3D");
   if (!pixels) {
      /* Note: we check for a NULL image pointer here, _after_ we allocated
       * memory for the texture.  That's what the GL spec calls for.
       */
      return;
   }
   else {
      GLint dstRowStride = texture_row_stride(texImage);
      GLboolean success = _mesa_texstore(ctx, 3, texImage->_BaseFormat,
                                         texImage->TexFormat,
                                         texImage->Data,
                                         0, 0, 0,  /* dstX/Y/Zoffset */
                                         dstRowStride,
                                         texImage->ImageOffsets,
                                         width, height, depth,
                                         format, type, pixels, packing);
      if (!success) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glTexImage3D");
      }
   }
d3884 6
a3889 1
   _mesa_unmap_teximage_pbo(ctx, packing);
d3893 17
d3912 5
a3916 3
/*
 * This is the software fallback for Driver.TexSubImage1D()
 * and Driver.CopyTexSubImage1D().
d3918 9
a3926 7
void
_mesa_store_texsubimage1d(struct gl_context *ctx, GLenum target, GLint level,
                          GLint xoffset, GLint width,
                          GLenum format, GLenum type, const void *pixels,
                          const struct gl_pixelstore_attrib *packing,
                          struct gl_texture_object *texObj,
                          struct gl_texture_image *texImage)
d3928 24
d3953 4
a3956 3
   pixels = _mesa_validate_pbo_teximage(ctx, 1, width, 1, 1, format, type,
                                        pixels, packing, "glTexSubImage1D");
   if (!pixels)
d3959 46
a4004 13
   {
      const GLint dstRowStride = 0;
      GLboolean success = _mesa_texstore(ctx, 1, texImage->_BaseFormat,
                                         texImage->TexFormat,
                                         texImage->Data,
                                         xoffset, 0, 0,  /* offsets */
                                         dstRowStride,
                                         texImage->ImageOffsets,
                                         width, 1, 1,
                                         format, type, pixels, packing);
      if (!success) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glTexSubImage1D");
      }
d4007 1
a4007 2
   _mesa_unmap_teximage_pbo(ctx, packing);
}
d4009 19
d4029 2
d4032 1
a4032 18
/**
 * This is the software fallback for Driver.TexSubImage2D()
 * and Driver.CopyTexSubImage2D().
 */
void
_mesa_store_texsubimage2d(struct gl_context *ctx, GLenum target, GLint level,
                          GLint xoffset, GLint yoffset,
                          GLint width, GLint height,
                          GLenum format, GLenum type, const void *pixels,
                          const struct gl_pixelstore_attrib *packing,
                          struct gl_texture_object *texObj,
                          struct gl_texture_image *texImage)
{
   /* get pointer to src pixels (may be in a pbo which we'll map here) */
   pixels = _mesa_validate_pbo_teximage(ctx, 2, width, height, 1, format, type,
                                        pixels, packing, "glTexSubImage2D");
   if (!pixels)
      return;
d4034 2
a4035 13
   {
      GLint dstRowStride = texture_row_stride(texImage);
      GLboolean success = _mesa_texstore(ctx, 2, texImage->_BaseFormat,
                                         texImage->TexFormat,
                                         texImage->Data,
                                         xoffset, yoffset, 0,
                                         dstRowStride,
                                         texImage->ImageOffsets,
                                         width, height, 1,
                                         format, type, pixels, packing);
      if (!success) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glTexSubImage2D");
      }
d4038 3
d4045 5
a4049 3
/*
 * This is the software fallback for Driver.TexSubImage3D().
 * and Driver.CopyTexSubImage3D().
d4052 5
a4056 7
_mesa_store_texsubimage3d(struct gl_context *ctx, GLenum target, GLint level,
                          GLint xoffset, GLint yoffset, GLint zoffset,
                          GLint width, GLint height, GLint depth,
                          GLenum format, GLenum type, const void *pixels,
                          const struct gl_pixelstore_attrib *packing,
                          struct gl_texture_object *texObj,
                          struct gl_texture_image *texImage)
d4058 3
a4060 5
   /* get pointer to src pixels (may be in a pbo which we'll map here) */
   pixels = _mesa_validate_pbo_teximage(ctx, 3, width, height, depth, format,
                                        type, pixels, packing,
                                        "glTexSubImage3D");
   if (!pixels)
d4063 4
a4066 13
   {
      GLint dstRowStride = texture_row_stride(texImage);
      GLboolean success = _mesa_texstore(ctx, 3, texImage->_BaseFormat,
                                         texImage->TexFormat,
                                         texImage->Data,
                                         xoffset, yoffset, zoffset,
                                         dstRowStride,
                                         texImage->ImageOffsets,
                                         width, height, depth,
                                         format, type, pixels, packing);
      if (!success) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glTexSubImage3D");
      }
d4069 3
a4071 1
   _mesa_unmap_teximage_pbo(ctx, packing);
d4076 1
a4076 1
 * Fallback for Driver.CompressedTexImage1D()
d4079 6
a4084 7
_mesa_store_compressed_teximage1d(struct gl_context *ctx,
                                  GLenum target, GLint level,
                                  GLint internalFormat,
                                  GLint width, GLint border,
                                  GLsizei imageSize, const GLvoid *data,
                                  struct gl_texture_object *texObj,
                                  struct gl_texture_image *texImage)
d4086 3
a4088 8
   /* this space intentionally left blank */
   (void) ctx;
   (void) target; (void) level;
   (void) internalFormat;
   (void) width; (void) border;
   (void) imageSize; (void) data;
   (void) texObj;
   (void) texImage;
a4091 1

d4093 1
a4093 1
 * Fallback for Driver.CompressedTexImage2D()
d4096 9
a4104 9
_mesa_store_compressed_teximage2d(struct gl_context *ctx,
                                  GLenum target, GLint level,
                                  GLint internalFormat,
                                  GLint width, GLint height, GLint border,
                                  GLsizei imageSize, const GLvoid *data,
                                  struct gl_texture_object *texObj,
                                  struct gl_texture_image *texImage)
{
   (void) width; (void) height; (void) border;
d4106 3
a4108 2
   /* This is pretty simple, basically just do a memcpy without worrying
    * about the usual image unpacking or image transfer operations.
a4109 1
   ASSERT(texObj);
d4113 1
a4113 2
   ASSERT(texImage->Depth == 1);
   ASSERT(texImage->Data == NULL); /* was freed in glCompressedTexImage2DARB */
d4115 3
a4117 4
   /* allocate storage */
   texImage->Data = _mesa_alloc_texmemory(imageSize);
   if (!texImage->Data) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCompressedTexImage2DARB");
d4121 5
a4125 60
   data = _mesa_validate_pbo_compressed_teximage(ctx, imageSize, data,
                                                 &ctx->Unpack,
                                                 "glCompressedTexImage2D");
   if (!data)
      return;

   /* copy the data */
   memcpy(texImage->Data, data, imageSize);

   _mesa_unmap_teximage_pbo(ctx, &ctx->Unpack);
}



/*
 * Fallback for Driver.CompressedTexImage3D()
 */
void
_mesa_store_compressed_teximage3d(struct gl_context *ctx,
                                  GLenum target, GLint level,
                                  GLint internalFormat,
                                  GLint width, GLint height, GLint depth,
                                  GLint border,
                                  GLsizei imageSize, const GLvoid *data,
                                  struct gl_texture_object *texObj,
                                  struct gl_texture_image *texImage)
{
   /* this space intentionally left blank */
   (void) ctx;
   (void) target; (void) level;
   (void) internalFormat;
   (void) width; (void) height; (void) depth;
   (void) border;
   (void) imageSize; (void) data;
   (void) texObj;
   (void) texImage;
}



/**
 * Fallback for Driver.CompressedTexSubImage1D()
 */
void
_mesa_store_compressed_texsubimage1d(struct gl_context *ctx, GLenum target,
                                     GLint level,
                                     GLint xoffset, GLsizei width,
                                     GLenum format,
                                     GLsizei imageSize, const GLvoid *data,
                                     struct gl_texture_object *texObj,
                                     struct gl_texture_image *texImage)
{
   /* there are no compressed 1D texture formats yet */
   (void) ctx;
   (void) target; (void) level;
   (void) xoffset; (void) width;
   (void) format;
   (void) imageSize; (void) data;
   (void) texObj;
   (void) texImage;
d4130 1
a4130 1
 * Fallback for Driver.CompressedTexSubImage2D()
d4133 6
a4138 8
_mesa_store_compressed_texsubimage2d(struct gl_context *ctx, GLenum target,
                                     GLint level,
                                     GLint xoffset, GLint yoffset,
                                     GLsizei width, GLsizei height,
                                     GLenum format,
                                     GLsizei imageSize, const GLvoid *data,
                                     struct gl_texture_object *texObj,
                                     struct gl_texture_image *texImage)
d4140 1
a4140 1
   GLint bytesPerRow, destRowStride, srcRowStride;
d4142 1
a4142 1
   GLubyte *dest;
a4144 1
   const GLint destWidth = texImage->Width;
d4146 6
a4154 9
   (void) level;
   (void) format;

   /* these should have been caught sooner */
   ASSERT((width % bw) == 0 || width == 2 || width == 1);
   ASSERT((height % bh) == 0 || height == 2 || height == 1);
   ASSERT((xoffset % bw) == 0);
   ASSERT((yoffset % bh) == 0);

d4156 1
a4156 1
   data = _mesa_validate_pbo_compressed_teximage(ctx, imageSize, data,
d4158 1
a4158 1
                                                 "glCompressedTexSubImage2D");
d4165 24
a4188 13
   destRowStride = _mesa_format_row_stride(texFormat, destWidth);
   dest = _mesa_compressed_image_address(xoffset, yoffset, 0,
                                         texFormat, destWidth,
                                         (GLubyte *) texImage->Data);

   bytesPerRow = srcRowStride;  /* bytes per row of blocks */
   rows = height / bh;  /* rows in blocks */

   /* copy rows of blocks */
   for (i = 0; i < rows; i++) {
      memcpy(dest, src, bytesPerRow);
      dest += destRowStride;
      src += srcRowStride;
a4191 25
}


/**
 * Fallback for Driver.CompressedTexSubImage3D()
 */
void
_mesa_store_compressed_texsubimage3d(struct gl_context *ctx, GLenum target,
                                GLint level,
                                GLint xoffset, GLint yoffset, GLint zoffset,
                                GLsizei width, GLsizei height, GLsizei depth,
                                GLenum format,
                                GLsizei imageSize, const GLvoid *data,
                                struct gl_texture_object *texObj,
                                struct gl_texture_image *texImage)
{
   /* there are no compressed 3D texture formats yet */
   (void) ctx;
   (void) target; (void) level;
   (void) xoffset; (void) yoffset; (void) zoffset;
   (void) width; (void) height; (void) depth;
   (void) format;
   (void) imageSize; (void) data;
   (void) texObj;
   (void) texImage;
@


1.7
log
@Merge Mesa 7.10.3
@
text
@d61 2
d64 1
a65 1
#include "pack.h"
d68 1
d73 2
d316 9
a324 9
static GLfloat *
make_temp_float_image(struct gl_context *ctx, GLuint dims,
                      GLenum logicalBaseFormat,
                      GLenum textureBaseFormat,
                      GLint srcWidth, GLint srcHeight, GLint srcDepth,
                      GLenum srcFormat, GLenum srcType,
                      const GLvoid *srcAddr,
                      const struct gl_pixelstore_attrib *srcPacking,
                      GLbitfield transferOps)
d2046 126
d2329 1
a2329 1
      const GLfloat *tempImage = make_temp_float_image(ctx, dims,
d2377 1
d2379 1
a2379 1
_mesa_texstore_r16(TEXSTORE_PARAMS)
d2385 4
a2388 1
   ASSERT(dstFormat == MESA_FORMAT_R16);
d2393 1
a2393 3
       dstFormat == MESA_FORMAT_R16 &&
       baseInternalFormat == GL_RED &&
       srcFormat == GL_RED &&
d2406 1
a2406 1
      const GLfloat *tempImage = make_temp_float_image(ctx, dims,
d2464 1
a2464 1
      const GLfloat *tempImage = make_temp_float_image(ctx, dims,
d2510 1
a2510 3
   ASSERT(dstFormat == MESA_FORMAT_SIGNED_R_16 ||
          dstFormat == MESA_FORMAT_SIGNED_RG_16 ||
          dstFormat == MESA_FORMAT_SIGNED_RGB_16 ||
d2529 1
a2529 1
      const GLfloat *tempImage = make_temp_float_image(ctx, dims,
d2553 19
a2571 6
            for (col = 0; col < srcWidth; col++) {
               GLuint c;
               for (c = 0; c < comps; c++) {
                  GLshort p;
                  UNCLAMPED_FLOAT_TO_SHORT(p, src[col * 4 + c]);
                  dstRowS[col * comps + c] = p;
d2573 2
a2575 2
            dstRow += dstRowStride;
            src += 4 * srcWidth;
d2642 1
a2642 1
_mesa_texstore_a8(TEXSTORE_PARAMS)
d2910 1
a2910 1
 * Store a texture in MESA_FORMAT_SIGNED_R8 format.
d2913 1
a2913 1
_mesa_texstore_signed_r8(TEXSTORE_PARAMS)
d2918 4
a2921 1
   ASSERT(dstFormat == MESA_FORMAT_SIGNED_R8);
d2924 13
a2936 2
   /* XXX look at adding optimized paths */
   {
d2938 1
a2938 1
      const GLfloat *tempImage = make_temp_float_image(ctx, dims,
d2945 1
a2945 1
      const GLfloat *srcRow = tempImage;
d2950 1
a2950 1
         GLubyte *dstRow = (GLubyte *) dstAddr
a2954 1
            GLubyte *dstB = (GLubyte *) dstRow;
d2956 1
a2956 1
               dstB[col] = FLOAT_TO_BYTE_TEX(srcRow[RCOMP]);
d2959 1
d2969 1
a2969 1
 * Store a texture in MESA_FORMAT_SIGNED_RG88 format.
d2972 1
a2972 1
_mesa_texstore_signed_rg88(TEXSTORE_PARAMS)
d2974 1
d2978 126
a3103 2
   ASSERT(dstFormat == MESA_FORMAT_SIGNED_RG88);
   ASSERT(texelBytes == 1);
d3105 14
a3118 2
   /* XXX look at adding optimized paths */
   {
d3120 1
a3120 1
      const GLfloat *tempImage = make_temp_float_image(ctx, dims,
d3127 1
a3127 1
      const GLfloat *srcRow = tempImage;
d3137 1
a3137 1
            GLushort *dstUS = (GLushort *) dstRow;
d3139 8
a3146 2
               dstUS[col] = PACK_COLOR_88(FLOAT_TO_BYTE_TEX(srcRow[RCOMP]),
                                          FLOAT_TO_BYTE_TEX(srcRow[GCOMP]));
a3155 1

d3170 1
a3170 1
      const GLfloat *tempImage = make_temp_float_image(ctx, dims,
d3182 1
a3182 1
         GLubyte *dstRow = (GLubyte *) dstAddr
d3187 1
a3187 1
            GLuint *dstUI = (GLuint *) dstRow;
d3189 6
a3194 5
               dstUI[col] = PACK_COLOR_8888( FLOAT_TO_BYTE_TEX(srcRow[RCOMP]),
                                             FLOAT_TO_BYTE_TEX(srcRow[GCOMP]),
                                             FLOAT_TO_BYTE_TEX(srcRow[BCOMP]),
                                             0xff );
               srcRow += 4;
a3248 33
   else if (!ctx->_ImageTransferState &&
	    (srcType == GL_BYTE) &&
	    can_swizzle(baseInternalFormat) &&
	    can_swizzle(srcFormat)) {

      GLubyte dstmap[4];

      /* dstmap - how to swizzle from RGBA to dst format:
       */
      if ((littleEndian && dstFormat == MESA_FORMAT_SIGNED_RGBA8888) ||
	  (!littleEndian && dstFormat == MESA_FORMAT_SIGNED_RGBA8888_REV)) {
	 dstmap[3] = 0;
	 dstmap[2] = 1;
	 dstmap[1] = 2;
	 dstmap[0] = 3;
      }
      else {
	 dstmap[3] = 3;
	 dstmap[2] = 2;
	 dstmap[1] = 1;
	 dstmap[0] = 0;
      }
      
      _mesa_swizzle_ubyte_image(ctx, dims,
				srcFormat,
				srcType,
				baseInternalFormat,
				dstmap, 4,
				dstAddr, dstXoffset, dstYoffset, dstZoffset,
				dstRowStride, dstImageOffsets,
				srcWidth, srcHeight, srcDepth, srcAddr,
				srcPacking);      
   }
d3251 1
a3251 1
      const GLfloat *tempImage = make_temp_float_image(ctx, dims,
d3263 1
a3263 1
         GLubyte *dstRow = (GLubyte *) dstAddr
d3268 1
a3268 1
            GLuint *dstUI = (GLuint *) dstRow;
d3271 4
a3274 4
                  dstUI[col] = PACK_COLOR_8888( FLOAT_TO_BYTE_TEX(srcRow[RCOMP]),
                                                FLOAT_TO_BYTE_TEX(srcRow[GCOMP]),
                                                FLOAT_TO_BYTE_TEX(srcRow[BCOMP]),
                                                FLOAT_TO_BYTE_TEX(srcRow[ACOMP]) );
d3276 1
d3281 4
a3284 4
                  dstUI[col] = PACK_COLOR_8888_REV( FLOAT_TO_BYTE_TEX(srcRow[RCOMP]),
                                                    FLOAT_TO_BYTE_TEX(srcRow[GCOMP]),
                                                    FLOAT_TO_BYTE_TEX(srcRow[BCOMP]),
                                                    FLOAT_TO_BYTE_TEX(srcRow[ACOMP]) );
d3286 1
d3306 1
a3306 2
      = _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType)
      / sizeof(GLuint);
d3334 2
a3335 2
         const GLuint *src
            = (const GLuint *) _mesa_image_address(dims, srcPacking, srcAddr,
d3392 1
a3392 2
      = _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType)
      / sizeof(GLuint);
d3407 2
a3408 2
      const GLuint *src
	 = (const GLuint *) _mesa_image_address(dims, srcPacking, srcAddr,
d3480 1
a3480 2
	 = _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType)
	 / sizeof(GLuint);
d3488 2
a3489 2
         const GLuint *src
            = (const GLuint *) _mesa_image_address(dims, srcPacking, srcAddr,
d3539 3
a3541 1
          dstFormat == MESA_FORMAT_INTENSITY_FLOAT32);
d3547 3
a3549 1
          baseInternalFormat == GL_INTENSITY);
d3555 1
d3567 1
a3567 1
      const GLfloat *tempImage = make_temp_float_image(ctx, dims,
d3614 3
a3616 1
          dstFormat == MESA_FORMAT_INTENSITY_FLOAT16);
d3622 3
a3624 1
          baseInternalFormat == GL_INTENSITY);
d3630 1
d3642 1
a3642 1
      const GLfloat *tempImage = make_temp_float_image(ctx, dims,
d3708 1
a3708 1
      const GLfloat *tempImage = make_temp_float_image(ctx, dims,
d3773 1
a3773 1
      const GLfloat *tempImage = make_temp_float_image(ctx, dims,
d3838 1
a3838 1
      const GLfloat *tempImage = make_temp_float_image(ctx, dims,
d4138 1
a4138 1
   k = _mesa_texstore_a8(ctx, dims, baseInternalFormat,
d4181 105
d4315 1
d4321 6
a4326 3
   { MESA_FORMAT_A8, _mesa_texstore_a8 },
   { MESA_FORMAT_L8, _mesa_texstore_a8 },
   { MESA_FORMAT_I8, _mesa_texstore_a8 },
d4330 1
a4330 1
   { MESA_FORMAT_R8, _mesa_texstore_a8 },
d4333 1
a4333 1
   { MESA_FORMAT_R16, _mesa_texstore_r16 },
d4336 1
d4371 4
d4385 2
a4386 2
   { MESA_FORMAT_SIGNED_R8, _mesa_texstore_signed_r8 },
   { MESA_FORMAT_SIGNED_RG88, _mesa_texstore_signed_rg88 },
d4392 2
a4393 2
   { MESA_FORMAT_SIGNED_R_16, _mesa_texstore_signed_rgba_16 },
   { MESA_FORMAT_SIGNED_RG_16, _mesa_texstore_signed_rgba_16 },
d4396 26
a4421 1
   { MESA_FORMAT_RGBA_16, _mesa_texstore_rgba_16 }
a4483 88
}


/**
 * Check if an unpack PBO is active prior to fetching a texture image.
 * If so, do bounds checking and map the buffer into main memory.
 * Any errors detected will be recorded.
 * The caller _must_ call _mesa_unmap_teximage_pbo() too!
 */
const GLvoid *
_mesa_validate_pbo_teximage(struct gl_context *ctx, GLuint dimensions,
			    GLsizei width, GLsizei height, GLsizei depth,
			    GLenum format, GLenum type, const GLvoid *pixels,
			    const struct gl_pixelstore_attrib *unpack,
			    const char *funcName)
{
   GLubyte *buf;

   if (!_mesa_is_bufferobj(unpack->BufferObj)) {
      /* no PBO */
      return pixels;
   }
   if (!_mesa_validate_pbo_access(dimensions, unpack, width, height, depth,
                                  format, type, pixels)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, funcName, "(invalid PBO access)");
      return NULL;
   }

   buf = (GLubyte *) ctx->Driver.MapBuffer(ctx, GL_PIXEL_UNPACK_BUFFER_EXT,
                                          GL_READ_ONLY_ARB, unpack->BufferObj);
   if (!buf) {
      _mesa_error(ctx, GL_INVALID_OPERATION, funcName, "(PBO is mapped)");
      return NULL;
   }

   return ADD_POINTERS(buf, pixels);
}


/**
 * Check if an unpack PBO is active prior to fetching a compressed texture
 * image.
 * If so, do bounds checking and map the buffer into main memory.
 * Any errors detected will be recorded.
 * The caller _must_ call _mesa_unmap_teximage_pbo() too!
 */
const GLvoid *
_mesa_validate_pbo_compressed_teximage(struct gl_context *ctx,
                                 GLsizei imageSize, const GLvoid *pixels,
                                 const struct gl_pixelstore_attrib *packing,
                                 const char *funcName)
{
   GLubyte *buf;

   if (!_mesa_is_bufferobj(packing->BufferObj)) {
      /* not using a PBO - return pointer unchanged */
      return pixels;
   }
   if ((const GLubyte *) pixels + imageSize >
       ((const GLubyte *) 0) + packing->BufferObj->Size) {
      /* out of bounds read! */
      _mesa_error(ctx, GL_INVALID_OPERATION, funcName, "(invalid PBO access)");
      return NULL;
   }

   buf = (GLubyte*) ctx->Driver.MapBuffer(ctx, GL_PIXEL_UNPACK_BUFFER_EXT,
                                         GL_READ_ONLY_ARB, packing->BufferObj);
   if (!buf) {
      _mesa_error(ctx, GL_INVALID_OPERATION, funcName, "(PBO is mapped");
      return NULL;
   }

   return ADD_POINTERS(buf, pixels);
}


/**
 * This function must be called after either of the validate_pbo_*_teximage()
 * functions.  It unmaps the PBO buffer if it was mapped earlier.
 */
void
_mesa_unmap_teximage_pbo(struct gl_context *ctx,
                         const struct gl_pixelstore_attrib *unpack)
{
   if (_mesa_is_bufferobj(unpack->BufferObj)) {
      ctx->Driver.UnmapBuffer(ctx, GL_PIXEL_UNPACK_BUFFER_EXT,
                              unpack->BufferObj);
   }
@


1.6
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d48 1
a48 1
 *    pixel transfer (scale, bais, lookup, convolution!, etc)
a57 2
#include "context.h"
#include "convolve.h"
d61 1
d63 1
d104 1
d126 1
a177 1

d213 6
d242 1
d293 1
a293 1
 * but the graphics hardware doesn't support luminance textures.  So, might
d312 1
a312 1
make_temp_float_image(GLcontext *ctx, GLuint dims,
d318 2
a319 1
                      const struct gl_pixelstore_attrib *srcPacking)
a320 1
   GLuint transferOps = ctx->_ImageTransferState;
d322 5
d332 2
d343 2
d352 28
a379 1
   /* conventional color image */
d381 3
a383 11
   if ((dims == 1 && ctx->Pixel.Convolution1DEnabled) ||
       (dims >= 2 && ctx->Pixel.Convolution2DEnabled) ||
       (dims >= 2 && ctx->Pixel.Separable2DEnabled)) {
      /* need image convolution */
      const GLuint preConvTransferOps
         = (transferOps & IMAGE_PRE_CONVOLUTION_BITS) | IMAGE_CLAMP_BIT;
      const GLuint postConvTransferOps
         = (transferOps & IMAGE_POST_CONVOLUTION_BITS) | IMAGE_CLAMP_BIT;
      GLint img, row;
      GLint convWidth = srcWidth, convHeight = srcHeight;
      GLfloat *convImage;
d385 4
a388 5
      /* pre-convolution image buffer (3D) */
      tempImage = (GLfloat *) malloc(srcWidth * srcHeight * srcDepth
                                           * 4 * sizeof(GLfloat));
      if (!tempImage)
         return NULL;
d390 3
a392 4
      /* post-convolution image buffer (2D) */
      convImage = (GLfloat *) malloc(srcWidth * srcHeight
                                           * 4 * sizeof(GLfloat));
      if (!convImage) {
d397 1
a397 3
      /* loop over 3D image slices */
      for (img = 0; img < srcDepth; img++) {
         GLfloat *dst = tempImage + img * (srcWidth * srcHeight * 4);
d399 11
a409 35
         /* unpack and do transfer ops up to convolution */
         for (row = 0; row < srcHeight; row++) {
            const GLvoid *src = _mesa_image_address(dims, srcPacking,
                                              srcAddr, srcWidth, srcHeight,
                                              srcFormat, srcType, img, row, 0);
            _mesa_unpack_color_span_float(ctx, srcWidth, GL_RGBA, dst,
                                          srcFormat, srcType, src,
                                          srcPacking,
                                          preConvTransferOps);
            dst += srcWidth * 4;
         }

         /* size after optional convolution */
         convWidth = srcWidth;
         convHeight = srcHeight;

#if FEATURE_convolve
         /* do convolution */
         {
            GLfloat *src = tempImage + img * (srcWidth * srcHeight * 4);
            if (dims == 1) {
               ASSERT(ctx->Pixel.Convolution1DEnabled);
               _mesa_convolve_1d_image(ctx, &convWidth, src, convImage);
            }
            else {
               if (ctx->Pixel.Convolution2DEnabled) {
                  _mesa_convolve_2d_image(ctx, &convWidth, &convHeight,
                                          src, convImage);
               }
               else {
                  ASSERT(ctx->Pixel.Separable2DEnabled);
                  _mesa_convolve_sep_image(ctx, &convWidth, &convHeight,
                                           src, convImage);
               }
            }
d411 4
a414 24
#endif
         /* do post-convolution transfer and pack into tempImage */
         {
            const GLint logComponents
               = _mesa_components_in_format(logicalBaseFormat);
            const GLfloat *src = convImage;
            GLfloat *dst = tempImage + img * (convWidth * convHeight * 4);
            for (row = 0; row < convHeight; row++) {
               _mesa_pack_rgba_span_float(ctx, convWidth,
                                          (GLfloat (*)[4]) src,
                                          logicalBaseFormat, GL_FLOAT,
                                          dst, &ctx->DefaultPacking,
                                          postConvTransferOps);
               src += convWidth * 4;
               dst += convWidth * logComponents;
            }
         }
      } /* loop over 3D image slices */

      free(convImage);

      /* might need these below */
      srcWidth = convWidth;
      srcHeight = convHeight;
a415 7
   else {
      /* no convolution */
      const GLint components = _mesa_components_in_format(logicalBaseFormat);
      const GLint srcStride =
         _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType);
      GLfloat *dst;
      GLint img, row;
d417 47
a463 4
      tempImage = (GLfloat *) malloc(srcWidth * srcHeight * srcDepth
                                           * components * sizeof(GLfloat));
      if (!tempImage)
         return NULL;
d465 13
a477 14
      dst = tempImage;
      for (img = 0; img < srcDepth; img++) {
         const GLubyte *src
            = (const GLubyte *) _mesa_image_address(dims, srcPacking, srcAddr,
                                                    srcWidth, srcHeight,
                                                    srcFormat, srcType,
                                                    img, 0, 0);
         for (row = 0; row < srcHeight; row++) {
            _mesa_unpack_color_span_float(ctx, srcWidth, logicalBaseFormat,
                                          dst, srcFormat, srcType, src,
                                          srcPacking, transferOps);
            dst += srcWidth * components;
            src += srcStride;
         }
d485 1
a485 1
      GLfloat *newImage;
d498 2
a499 2
      newImage = (GLfloat *) malloc(srcWidth * srcHeight * srcDepth
                                          * texComponents * sizeof(GLfloat));
d529 1
d535 1
a535 1
 * but the graphics hardware doesn't support luminance textures.  So, might
d554 1
a554 1
_mesa_make_temp_chan_image(GLcontext *ctx, GLuint dims,
a563 1
   GLboolean freeSrcImage = GL_FALSE;
d571 2
d580 2
a586 24
#if FEATURE_convolve
   if ((dims == 1 && ctx->Pixel.Convolution1DEnabled) ||
       (dims >= 2 && ctx->Pixel.Convolution2DEnabled) ||
       (dims >= 2 && ctx->Pixel.Separable2DEnabled)) {
      /* get convolved image */
      GLfloat *convImage = make_temp_float_image(ctx, dims,
                                                 logicalBaseFormat,
                                                 logicalBaseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType,
                                                 srcAddr, srcPacking);
      if (!convImage)
         return NULL;
      /* the convolved image is our new source image */
      srcAddr = convImage;
      srcFormat = logicalBaseFormat;
      srcType = GL_FLOAT;
      srcPacking = &ctx->DefaultPacking;
      _mesa_adjust_image_for_convolution(ctx, dims, &srcWidth, &srcHeight);
      transferOps = 0;
      freeSrcImage = GL_TRUE;
   }
#endif

a590 3
      if (freeSrcImage) {
         free((void *) srcAddr);
      }
a611 5
   /* If we made a temporary image for convolution, free it here */
   if (freeSrcImage) {
      free((void *) srcAddr);
   }

d788 4
a791 1
/* Deal with the _REV input types:
d809 4
a812 1
/* Mapping required if input type is 
d839 1
a839 1
_mesa_swizzle_ubyte_image(GLcontext *ctx, 
d926 1
a926 1
memcpy_texture(GLcontext *ctx,
a1242 1
      _mesa_adjust_image_for_convolution(ctx, dims, &srcWidth, &srcHeight);
a1368 1
      _mesa_adjust_image_for_convolution(ctx, dims, &srcWidth, &srcHeight);
a1548 1

a1568 1
      _mesa_adjust_image_for_convolution(ctx, dims, &srcWidth, &srcHeight);
a1697 1
      _mesa_adjust_image_for_convolution(ctx, dims, &srcWidth, &srcHeight);
a1823 1
      _mesa_adjust_image_for_convolution(ctx, dims, &srcWidth, &srcHeight);
a1880 1
      _mesa_adjust_image_for_convolution(ctx, dims, &srcWidth, &srcHeight);
a1948 1
      _mesa_adjust_image_for_convolution(ctx, dims, &srcWidth, &srcHeight);
a2006 1
      _mesa_adjust_image_for_convolution(ctx, dims, &srcWidth, &srcHeight);
d2041 3
d2045 1
a2045 1
_mesa_texstore_al88(TEXSTORE_PARAMS)
d2052 3
a2054 1
          dstFormat == MESA_FORMAT_AL88_REV);
d2059 5
a2063 3
       dstFormat == MESA_FORMAT_AL88 &&
       baseInternalFormat == GL_LUMINANCE_ALPHA &&
       srcFormat == GL_LUMINANCE_ALPHA &&
a2078 1

d2083 10
a2092 4
      if ((littleEndian && dstFormat == MESA_FORMAT_AL88) ||
	  (!littleEndian && dstFormat == MESA_FORMAT_AL88_REV)) {
	 dstmap[0] = 0;
	 dstmap[1] = 3;
d2095 9
a2103 2
	 dstmap[0] = 3;
	 dstmap[1] = 0;
a2129 1
      _mesa_adjust_image_for_convolution(ctx, dims, &srcWidth, &srcHeight);
d2137 2
a2138 1
            if (dstFormat == MESA_FORMAT_AL88) {
d2163 3
d2167 1
a2167 1
_mesa_texstore_al1616(TEXSTORE_PARAMS)
d2174 3
a2176 1
          dstFormat == MESA_FORMAT_AL1616_REV);
d2181 5
a2185 3
       dstFormat == MESA_FORMAT_AL1616 &&
       baseInternalFormat == GL_LUMINANCE_ALPHA &&
       srcFormat == GL_LUMINANCE_ALPHA &&
d2203 2
a2204 1
                                                 srcPacking);
a2208 1
      _mesa_adjust_image_for_convolution(ctx, dims, &srcWidth, &srcHeight);
d2216 2
a2217 1
            if (dstFormat == MESA_FORMAT_AL1616) {
d2247 1
a2247 1
_mesa_texstore_rgb332(TEXSTORE_PARAMS)
d2249 1
d2253 2
a2254 2
   ASSERT(dstFormat == MESA_FORMAT_RGB332);
   ASSERT(texelBytes == 1);
d2258 5
a2262 2
       baseInternalFormat == GL_RGB &&
       srcFormat == GL_RGB && srcType == GL_UNSIGNED_BYTE_3_3_2) {
d2273 1
a2273 1
      const GLchan *tempImage = _mesa_make_temp_chan_image(ctx, dims,
d2278 3
a2280 2
                                                 srcPacking);
      const GLchan *src = tempImage;
a2283 1
      _mesa_adjust_image_for_convolution(ctx, dims, &srcWidth, &srcHeight);
d2290 8
a2297 6
            for (col = 0; col < srcWidth; col++) {
               dstRow[col] = PACK_COLOR_332( CHAN_TO_UBYTE(src[RCOMP]),
                                             CHAN_TO_UBYTE(src[GCOMP]),
                                             CHAN_TO_UBYTE(src[BCOMP]) );
               src += 3;
            }
a2306 3
/**
 * Texstore for _mesa_texformat_a8, _mesa_texformat_l8, _mesa_texformat_i8.
 */
d2308 1
a2308 1
_mesa_texstore_a8(TEXSTORE_PARAMS)
d2313 2
a2314 4
   ASSERT(dstFormat == MESA_FORMAT_A8 ||
          dstFormat == MESA_FORMAT_L8 ||
          dstFormat == MESA_FORMAT_I8);
   ASSERT(texelBytes == 1);
d2318 3
a2320 2
       baseInternalFormat == srcFormat &&
       srcType == GL_UNSIGNED_BYTE) {
a2328 29
   else if (!ctx->_ImageTransferState &&
	    srcType == GL_UNSIGNED_BYTE &&
	    can_swizzle(baseInternalFormat) &&
	    can_swizzle(srcFormat)) {

      GLubyte dstmap[4];

      /* dstmap - how to swizzle from RGBA to dst format:
       */
      if (dstFormat == MESA_FORMAT_A8) {
	 dstmap[0] = 3;
      }
      else {
	 dstmap[0] = 0;
      }
      dstmap[1] = ZERO;		/* ? */
      dstmap[2] = ZERO;		/* ? */
      dstmap[3] = ONE;		/* ? */
      
      _mesa_swizzle_ubyte_image(ctx, dims,
				srcFormat,
				srcType,
				baseInternalFormat,
				dstmap, 1,
				dstAddr, dstXoffset, dstYoffset, dstZoffset,
				dstRowStride, dstImageOffsets,
				srcWidth, srcHeight, srcDepth, srcAddr,
				srcPacking);      
   }   
d2331 1
a2331 1
      const GLchan *tempImage = _mesa_make_temp_chan_image(ctx, dims,
d2336 3
a2338 2
                                                 srcPacking);
      const GLchan *src = tempImage;
a2341 1
      _mesa_adjust_image_for_convolution(ctx, dims, &srcWidth, &srcHeight);
d2348 1
d2350 11
a2360 1
               dstRow[col] = CHAN_TO_UBYTE(src[col]);
a2362 1
            src += srcWidth;
a2370 1

d2372 1
a2372 1
_mesa_texstore_ci8(TEXSTORE_PARAMS)
d2375 1
d2377 4
a2380 4
   (void) dims; (void) baseInternalFormat;
   ASSERT(dstFormat == MESA_FORMAT_CI8);
   ASSERT(texelBytes == 1);
   ASSERT(baseInternalFormat == GL_COLOR_INDEX);
d2384 4
a2387 2
       srcFormat == GL_COLOR_INDEX &&
       srcType == GL_UNSIGNED_BYTE) {
d2398 17
a2414 1
      GLint img, row;
d2421 9
a2429 5
            const GLvoid *src = _mesa_image_address(dims, srcPacking,
                srcAddr, srcWidth, srcHeight, srcFormat, srcType, img, row, 0);
            _mesa_unpack_index_span(ctx, srcWidth, GL_UNSIGNED_BYTE, dstRow,
                                    srcType, src, srcPacking,
                                    ctx->_ImageTransferState);
d2431 1
d2434 1
a2439 3
/**
 * Texstore for _mesa_texformat_ycbcr or _mesa_texformat_ycbcr_REV.
 */
d2441 1
a2441 1
_mesa_texstore_ycbcr(TEXSTORE_PARAMS)
a2442 1
   const GLboolean littleEndian = _mesa_little_endian();
d2444 1
d2446 189
a2634 1
   (void) ctx; (void) dims; (void) baseInternalFormat;
a2697 1

d2764 1
d2766 1
a2766 1
 * Store a texture in MESA_FORMAT_SIGNED_RGBA8888 or MESA_FORMAT_SIGNED_RGBA8888_REV
d2769 1
a2769 1
_mesa_texstore_signed_rgba8888(TEXSTORE_PARAMS)
a2770 1
   const GLboolean littleEndian = _mesa_little_endian();
d2774 2
a2775 3
   ASSERT(dstFormat == MESA_FORMAT_SIGNED_RGBA8888 ||
          dstFormat == MESA_FORMAT_SIGNED_RGBA8888_REV);
   ASSERT(texelBytes == 4);
d2777 28
a2804 13
   if (!ctx->_ImageTransferState &&
       !srcPacking->SwapBytes &&
       dstFormat == MESA_FORMAT_SIGNED_RGBA8888 &&
       baseInternalFormat == GL_RGBA &&
      ((srcFormat == GL_RGBA && srcType == GL_BYTE && !littleEndian) ||
       (srcFormat == GL_ABGR_EXT && srcType == GL_BYTE && littleEndian))) {
       /* simple memcpy path */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
d2806 12
a2817 18
   else if (!ctx->_ImageTransferState &&
       !srcPacking->SwapBytes &&
       dstFormat == MESA_FORMAT_SIGNED_RGBA8888_REV &&
       baseInternalFormat == GL_RGBA &&
      ((srcFormat == GL_RGBA && srcType == GL_BYTE && littleEndian) ||
       (srcFormat == GL_ABGR_EXT && srcType == GL_BYTE && !littleEndian))) {
      /* simple memcpy path */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else if (!ctx->_ImageTransferState &&
	    (srcType == GL_BYTE) &&
	    can_swizzle(baseInternalFormat) &&
	    can_swizzle(srcFormat)) {
d2819 135
a2953 1
      GLubyte dstmap[4];
d2977 581
a3557 3
				dstRowStride, dstImageOffsets,
				srcWidth, srcHeight, srcDepth, srcAddr,
				srcPacking);      
d3566 3
a3568 3
                                                 srcPacking);
      const GLfloat *srcRow = tempImage;
      GLint img, row, col;
a3570 1
      _mesa_adjust_image_for_convolution(ctx, dims, &srcWidth, &srcHeight);
d3577 4
a3580 18
            GLuint *dstUI = (GLuint *) dstRow;
            if (dstFormat == MESA_FORMAT_SIGNED_RGBA8888) {
               for (col = 0; col < srcWidth; col++) {
                  dstUI[col] = PACK_COLOR_8888( FLOAT_TO_BYTE_TEX(srcRow[RCOMP]),
                                                FLOAT_TO_BYTE_TEX(srcRow[GCOMP]),
                                                FLOAT_TO_BYTE_TEX(srcRow[BCOMP]),
                                                FLOAT_TO_BYTE_TEX(srcRow[ACOMP]) );
                  srcRow += 4;
               }
            }
            else {
               for (col = 0; col < srcWidth; col++) {
                  dstUI[col] = PACK_COLOR_8888_REV( FLOAT_TO_BYTE_TEX(srcRow[RCOMP]),
                                                    FLOAT_TO_BYTE_TEX(srcRow[GCOMP]),
                                                    FLOAT_TO_BYTE_TEX(srcRow[BCOMP]),
                                                    FLOAT_TO_BYTE_TEX(srcRow[ACOMP]) );
                  srcRow += 4;
               }
d3583 1
d3586 1
d3592 2
a3593 3
/**
 * Store a combined depth/stencil texture image.
 */
d3595 1
a3595 1
_mesa_texstore_z24_s8(TEXSTORE_PARAMS)
d3597 3
a3599 5
   const GLuint depthScale = 0xffffff;
   const GLint srcRowStride
      = _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType)
      / sizeof(GLuint);
   GLint img, row;
d3601 8
a3608 3
   ASSERT(dstFormat == MESA_FORMAT_Z24_S8);
   ASSERT(srcFormat == GL_DEPTH_STENCIL_EXT || srcFormat == GL_DEPTH_COMPONENT);
   ASSERT(srcFormat != GL_DEPTH_STENCIL_EXT || srcType == GL_UNSIGNED_INT_24_8_EXT);
d3610 7
a3616 33
   /* In case we only upload depth we need to preserve the stencil */
   if (srcFormat == GL_DEPTH_COMPONENT) {
      for (img = 0; img < srcDepth; img++) {
         GLuint *dstRow = (GLuint *) dstAddr
            + dstImageOffsets[dstZoffset + img]
            + dstYoffset * dstRowStride / sizeof(GLuint)
            + dstXoffset;
         const GLuint *src
            = (const GLuint *) _mesa_image_address(dims, srcPacking, srcAddr,
                  srcWidth, srcHeight,
                  srcFormat, srcType,
                  img, 0, 0);
         for (row = 0; row < srcHeight; row++) {
            GLuint depth[MAX_WIDTH];
            GLint i;
            _mesa_unpack_depth_span(ctx, srcWidth,
                                    GL_UNSIGNED_INT, /* dst type */
                                    depth, /* dst addr */
                                    depthScale,
                                    srcType, src, srcPacking);

            for (i = 0; i < srcWidth; i++)
               dstRow[i] = depth[i] << 8 | (dstRow[i] & 0x000000FF);

            src += srcRowStride;
            dstRow += dstRowStride / sizeof(GLuint);
         }
      }
   }
   else if (ctx->Pixel.DepthScale == 1.0f &&
       ctx->Pixel.DepthBias == 0.0f &&
       !srcPacking->SwapBytes) {
      /* simple path */
d3626 5
a3630 3
      const GLint srcRowStride
         = _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType)
         / sizeof(GLuint);
d3632 2
a3633 1

d3635 4
a3638 9
         GLuint *dstRow = (GLuint *) dstAddr
            + dstImageOffsets[dstZoffset + img]
            + dstYoffset * dstRowStride / sizeof(GLuint)
            + dstXoffset;
         const GLuint *src
            = (const GLuint *) _mesa_image_address(dims, srcPacking, srcAddr,
                                                   srcWidth, srcHeight,
                                                   srcFormat, srcType,
                                                   img, 0, 0);
d3640 1
a3640 1
            GLubyte stencil[MAX_WIDTH];
d3642 5
a3646 18
            /* the 24 depth bits will be in the high position: */
            _mesa_unpack_depth_span(ctx, srcWidth,
                                    GL_UNSIGNED_INT_24_8_EXT, /* dst type */
                                    dstRow, /* dst addr */
                                    depthScale,
                                    srcType, src, srcPacking);
            /* get the 8-bit stencil values */
            _mesa_unpack_stencil_span(ctx, srcWidth,
                                      GL_UNSIGNED_BYTE, /* dst type */
                                      stencil, /* dst addr */
                                      srcType, src, srcPacking,
                                      ctx->_ImageTransferState);
            /* merge stencil values into depth values */
            for (i = 0; i < srcWidth; i++)
               dstRow[i] |= stencil[i];

            src += srcRowStride;
            dstRow += dstRowStride / sizeof(GLuint);
d3649 2
d3656 1
a3656 92
/**
 * Store a combined depth/stencil texture image.
 */
static GLboolean
_mesa_texstore_s8_z24(TEXSTORE_PARAMS)
{
   const GLuint depthScale = 0xffffff;
   const GLint srcRowStride
      = _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType)
      / sizeof(GLuint);
   GLint img, row;

   ASSERT(dstFormat == MESA_FORMAT_S8_Z24);
   ASSERT(srcFormat == GL_DEPTH_STENCIL_EXT || srcFormat == GL_DEPTH_COMPONENT);
   ASSERT(srcFormat != GL_DEPTH_STENCIL_EXT || srcType == GL_UNSIGNED_INT_24_8_EXT);

   /* In case we only upload depth we need to preserve the stencil */
   if (srcFormat == GL_DEPTH_COMPONENT) {
      for (img = 0; img < srcDepth; img++) {
         GLuint *dstRow = (GLuint *) dstAddr
            + dstImageOffsets[dstZoffset + img]
            + dstYoffset * dstRowStride / sizeof(GLuint)
            + dstXoffset;
         const GLuint *src
            = (const GLuint *) _mesa_image_address(dims, srcPacking, srcAddr,
                  srcWidth, srcHeight,
                  srcFormat, srcType,
                  img, 0, 0);
         for (row = 0; row < srcHeight; row++) {
            GLuint depth[MAX_WIDTH];
            GLint i;
            _mesa_unpack_depth_span(ctx, srcWidth,
                                    GL_UNSIGNED_INT, /* dst type */
                                    depth, /* dst addr */
                                    depthScale,
                                    srcType, src, srcPacking);

            for (i = 0; i < srcWidth; i++)
               dstRow[i] = depth[i] | (dstRow[i] & 0xFF000000);

            src += srcRowStride;
            dstRow += dstRowStride / sizeof(GLuint);
         }
      }
   }
   else {
      for (img = 0; img < srcDepth; img++) {
         GLuint *dstRow = (GLuint *) dstAddr
            + dstImageOffsets[dstZoffset + img]
            + dstYoffset * dstRowStride / sizeof(GLuint)
            + dstXoffset;
         const GLuint *src
            = (const GLuint *) _mesa_image_address(dims, srcPacking, srcAddr,
                  srcWidth, srcHeight,
                  srcFormat, srcType,
                  img, 0, 0);
         for (row = 0; row < srcHeight; row++) {
            GLubyte stencil[MAX_WIDTH];
            GLint i;
            /* the 24 depth bits will be in the low position: */
            _mesa_unpack_depth_span(ctx, srcWidth,
                                    GL_UNSIGNED_INT, /* dst type */
                                    dstRow, /* dst addr */
                                    depthScale,
                                    srcType, src, srcPacking);
            /* get the 8-bit stencil values */
            _mesa_unpack_stencil_span(ctx, srcWidth,
                                      GL_UNSIGNED_BYTE, /* dst type */
                                      stencil, /* dst addr */
                                      srcType, src, srcPacking,
                                      ctx->_ImageTransferState);
            /* merge stencil values into depth values */
            for (i = 0; i < srcWidth; i++)
               dstRow[i] |= stencil[i] << 24;

            src += srcRowStride;
            dstRow += dstRowStride / sizeof(GLuint);
         }
      }
   }
   return GL_TRUE;
}

/**
 * Store an image in any of the formats:
 *   _mesa_texformat_rgba_float32
 *   _mesa_texformat_rgb_float32
 *   _mesa_texformat_alpha_float32
 *   _mesa_texformat_luminance_float32
 *   _mesa_texformat_luminance_alpha_float32
 *   _mesa_texformat_intensity_float32
 */
d3658 1
a3658 1
_mesa_texstore_rgba_float32(TEXSTORE_PARAMS)
d3664 1
a3664 6
   ASSERT(dstFormat == MESA_FORMAT_RGBA_FLOAT32 ||
          dstFormat == MESA_FORMAT_RGB_FLOAT32 ||
          dstFormat == MESA_FORMAT_ALPHA_FLOAT32 ||
          dstFormat == MESA_FORMAT_LUMINANCE_FLOAT32 ||
          dstFormat == MESA_FORMAT_LUMINANCE_ALPHA_FLOAT32 ||
          dstFormat == MESA_FORMAT_INTENSITY_FLOAT32);
d3671 1
a3671 1
   ASSERT(texelBytes == components * sizeof(GLfloat));
d3673 4
a3676 2
   if (!ctx->_ImageTransferState &&
       !srcPacking->SwapBytes &&
d3678 1
a3678 1
       srcType == GL_FLOAT) {
d3689 5
a3693 8
      const GLfloat *tempImage = make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking);
      const GLfloat *srcRow = tempImage;
      GLint bytesPerRow;
a3696 2
      _mesa_adjust_image_for_convolution(ctx, dims, &srcWidth, &srcHeight);
      bytesPerRow = srcWidth * components * sizeof(GLfloat);
d3703 5
a3707 1
            memcpy(dstRow, srcRow, bytesPerRow);
d3709 1
a3709 1
            srcRow += srcWidth * components;
d3719 1
a3719 3
/**
 * As above, but store 16-bit floats.
 */
d3721 1
a3721 1
_mesa_texstore_rgba_float16(TEXSTORE_PARAMS)
d3727 1
a3727 6
   ASSERT(dstFormat == MESA_FORMAT_RGBA_FLOAT16 ||
          dstFormat == MESA_FORMAT_RGB_FLOAT16 ||
          dstFormat == MESA_FORMAT_ALPHA_FLOAT16 ||
          dstFormat == MESA_FORMAT_LUMINANCE_FLOAT16 ||
          dstFormat == MESA_FORMAT_LUMINANCE_ALPHA_FLOAT16 ||
          dstFormat == MESA_FORMAT_INTENSITY_FLOAT16);
d3734 1
a3734 1
   ASSERT(texelBytes == components * sizeof(GLhalfARB));
d3736 4
a3739 2
   if (!ctx->_ImageTransferState &&
       !srcPacking->SwapBytes &&
d3741 1
a3741 1
       srcType == GL_HALF_FLOAT_ARB) {
d3752 5
a3756 7
      const GLfloat *tempImage = make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking);
      const GLfloat *src = tempImage;
a3759 1
      _mesa_adjust_image_for_convolution(ctx, dims, &srcWidth, &srcHeight);
d3766 1
a3766 1
            GLhalfARB *dstTexel = (GLhalfARB *) dstRow;
d3769 1
a3769 1
               dstTexel[i] = _mesa_float_to_half(src[i]);
d3782 2
d3797 6
a3802 6
             newDstFormat, dstAddr,
             dstXoffset, dstYoffset, dstZoffset,
             dstRowStride, dstImageOffsets,
             srcWidth, srcHeight, srcDepth,
             srcFormat, srcType,
             srcAddr, srcPacking);
d3883 7
a3889 7
   k = _mesa_texstore_al88(ctx, dims, baseInternalFormat,
                           newDstFormat, dstAddr,
                           dstXoffset, dstYoffset, dstZoffset,
                           dstRowStride, dstImageOffsets,
                           srcWidth, srcHeight, srcDepth,
                           srcFormat, srcType,
                           srcAddr, srcPacking);
d3908 1
a3908 1
 * Table mapping MESA_FORMAT_8 to _mesa_texstore_*()
d3933 4
a3936 4
   { MESA_FORMAT_AL88, _mesa_texstore_al88 },
   { MESA_FORMAT_AL88_REV, _mesa_texstore_al88 },
   { MESA_FORMAT_AL1616, _mesa_texstore_al1616 },
   { MESA_FORMAT_AL1616_REV, _mesa_texstore_al1616 },
d3944 6
d3956 1
a3956 1
   { MESA_FORMAT_S8, NULL/*_mesa_texstore_s8*/ },
d3984 8
d3993 5
d4000 6
a4005 1
   { MESA_FORMAT_SIGNED_RGBA_16, NULL },
d4078 1
a4078 1
_mesa_validate_pbo_teximage(GLcontext *ctx, GLuint dimensions,
d4092 1
a4092 1
      _mesa_error(ctx, GL_INVALID_OPERATION, funcName, "(invalid PBO access");
d4099 1
a4099 1
      _mesa_error(ctx, GL_INVALID_OPERATION, funcName, "(PBO is mapped");
d4115 1
a4115 1
_mesa_validate_pbo_compressed_teximage(GLcontext *ctx,
d4129 1
a4129 1
      _mesa_error(ctx, GL_INVALID_OPERATION, funcName, "(invalid PBO access");
d4149 1
a4149 1
_mesa_unmap_teximage_pbo(GLcontext *ctx,
a4183 3
 * Note that the width may not be the actual texture width since it may
 * be changed by convolution w/ GL_REDUCE.  The texImage->Width field will
 * have the actual texture size.
d4186 1
a4186 1
_mesa_store_teximage1d(GLcontext *ctx, GLenum target, GLint level,
a4237 3
 *
 * Note: width and height may be pre-convolved dimensions, but
 * texImage->Width and texImage->Height will be post-convolved dimensions.
d4240 1
a4240 1
_mesa_store_teximage2d(GLcontext *ctx, GLenum target, GLint level,
d4293 1
a4293 1
_mesa_store_teximage3d(GLcontext *ctx, GLenum target, GLint level,
d4346 1
a4346 1
_mesa_store_texsubimage1d(GLcontext *ctx, GLenum target, GLint level,
d4384 1
a4384 1
_mesa_store_texsubimage2d(GLcontext *ctx, GLenum target, GLint level,
d4422 1
a4422 1
_mesa_store_texsubimage3d(GLcontext *ctx, GLenum target, GLint level,
d4460 2
a4461 1
_mesa_store_compressed_teximage1d(GLcontext *ctx, GLenum target, GLint level,
d4484 2
a4485 1
_mesa_store_compressed_teximage2d(GLcontext *ctx, GLenum target, GLint level,
d4529 2
a4530 1
_mesa_store_compressed_teximage3d(GLcontext *ctx, GLenum target, GLint level,
d4555 1
a4555 1
_mesa_store_compressed_texsubimage1d(GLcontext *ctx, GLenum target,
d4578 1
a4578 1
_mesa_store_compressed_texsubimage2d(GLcontext *ctx, GLenum target,
d4639 1
a4639 1
_mesa_store_compressed_texsubimage3d(GLcontext *ctx, GLenum target,
@


1.5
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d3 1
a3 1
 * Version:  7.3
d6 1
a58 1
#if FEATURE_convolve
a59 1
#endif
d65 2
a66 1
#include "texformat.h"
d79 6
d266 11
a276 20
/*
   _mesa_printf("from %x/%s to %x/%s map %d %d %d %d %d %d\n",
		inFormat, _mesa_lookup_enum_by_nr(inFormat),
		outFormat, _mesa_lookup_enum_by_nr(outFormat),
		map[0], 
		map[1], 
		map[2], 
		map[3], 
		map[4], 
		map[5]); 
*/
}


#if !FEATURE_convolve
static void
_mesa_adjust_image_for_convolution(GLcontext *ctx, GLuint dims,
                                   GLsizei *srcWidth, GLsizei *srcHeight)
{
   /* no-op */
a277 1
#endif
d346 1
a346 1
      GLint convWidth, convHeight;
d350 1
a350 1
      tempImage = (GLfloat *) _mesa_malloc(srcWidth * srcHeight * srcDepth
d356 1
a356 1
      convImage = (GLfloat *) _mesa_malloc(srcWidth * srcHeight
d359 1
a359 1
         _mesa_free(tempImage);
d422 1
a422 1
      _mesa_free(convImage);
d431 2
a432 2
      const GLint srcStride = _mesa_image_row_stride(srcPacking,
                                                 srcWidth, srcFormat, srcType);
d436 1
a436 1
      tempImage = (GLfloat *) _mesa_malloc(srcWidth * srcHeight * srcDepth
d475 1
a475 1
      newImage = (GLfloat *) _mesa_malloc(srcWidth * srcHeight * srcDepth
d478 1
a478 1
         _mesa_free(tempImage);
d498 1
a498 1
      _mesa_free(tempImage);
d585 1
a585 1
   tempImage = (GLchan *) _mesa_malloc(srcWidth * srcHeight * srcDepth
d587 4
a590 1
   if (!tempImage)
d592 1
d596 7
a602 8
      const GLint srcStride = _mesa_image_row_stride(srcPacking,
                                                     srcWidth, srcFormat,
                                                     srcType);
      const GLubyte *src
         = (const GLubyte *) _mesa_image_address(dims, srcPacking, srcAddr,
                                                 srcWidth, srcHeight,
                                                 srcFormat, srcType,
                                                 img, 0, 0);
d614 1
a614 1
      _mesa_free((void *) srcAddr);
d634 1
a634 1
      newImage = (GLchan *) _mesa_malloc(srcWidth * srcHeight * srcDepth
d637 1
a637 1
         _mesa_free(tempImage);
d657 1
a657 1
      _mesa_free(tempImage);
d799 1
d821 1
d887 1
a887 1
/*    _mesa_printf("map %d %d %d %d\n", map[0], map[1], map[2], map[3]);  */
d889 2
a890 2
   if (srcRowStride == dstRowStride &&
       srcComponents == dstComponents &&
d927 1
a927 1
               const struct gl_texture_format *dstFormat,
d943 2
a944 1
   const GLint bytesPerRow = srcWidth * dstFormat->TexelBytes;
d953 1
a953 1
                     + dstXoffset * dstFormat->TexelBytes;
d984 1
a984 1
         + dstImageOffsets[dstZoffset + img] * dstFormat->TexelBytes
d986 1
a986 1
         + dstXoffset * dstFormat->TexelBytes;
d999 1
a999 8
 * Store an image in any of the formats:
 *   _mesa_texformat_rgba
 *   _mesa_texformat_rgb
 *   _mesa_texformat_alpha
 *   _mesa_texformat_luminance
 *   _mesa_texformat_luminance_alpha
 *   _mesa_texformat_intensity
 * 
d1001 2
a1002 2
GLboolean
_mesa_texstore_rgba(TEXSTORE_PARAMS)
d1004 5
a1008 1
   const GLint components = _mesa_components_in_format(baseInternalFormat);
d1010 2
a1011 15
   ASSERT(dstFormat == &_mesa_texformat_rgba ||
          dstFormat == &_mesa_texformat_rgb ||
          dstFormat == &_mesa_texformat_alpha ||
          dstFormat == &_mesa_texformat_luminance ||
          dstFormat == &_mesa_texformat_luminance_alpha ||
          dstFormat == &_mesa_texformat_intensity);
   ASSERT(baseInternalFormat == GL_RGBA ||
          baseInternalFormat == GL_RGB ||
          baseInternalFormat == GL_ALPHA ||
          baseInternalFormat == GL_LUMINANCE ||
          baseInternalFormat == GL_LUMINANCE_ALPHA ||
          baseInternalFormat == GL_INTENSITY);
   ASSERT(dstFormat->TexelBytes == components * sizeof(GLchan));

   if (!ctx->_ImageTransferState &&
d1013 3
a1015 2
       baseInternalFormat == srcFormat &&
       srcType == CHAN_TYPE) {
d1024 3
a1026 7
   else if (!ctx->_ImageTransferState &&
            !srcPacking->SwapBytes &&
            dstFormat == &_mesa_texformat_rgb &&
            srcFormat == GL_RGBA &&
            srcType == CHAN_TYPE) {
      /* extract RGB from RGBA */
      GLint img, row, col;
d1028 4
a1031 11
         GLchan *dstImage = (GLchan *)
            ((GLubyte *) dstAddr
             + dstImageOffsets[dstZoffset + img] * dstFormat->TexelBytes
             + dstYoffset * dstRowStride
             + dstXoffset * dstFormat->TexelBytes);

         const GLint srcRowStride = _mesa_image_row_stride(srcPacking,
                                                 srcWidth, srcFormat, srcType);
         GLchan *srcRow = (GLchan *) _mesa_image_address(dims, srcPacking,
                  srcAddr, srcWidth, srcHeight, srcFormat, srcType, img, 0, 0);
         GLchan *dstRow = dstImage;
d1033 6
a1038 7
            for (col = 0; col < srcWidth; col++) {
               dstRow[col * 3 + RCOMP] = srcRow[col * 4 + RCOMP];
               dstRow[col * 3 + GCOMP] = srcRow[col * 4 + GCOMP];
               dstRow[col * 3 + BCOMP] = srcRow[col * 4 + BCOMP];
            }
            dstRow += dstRowStride / sizeof(GLchan);
            srcRow = (GLchan *) ((GLubyte *) srcRow + srcRowStride);
d1042 3
a1044 7
   else if (!ctx->_ImageTransferState &&
	    CHAN_TYPE == GL_UNSIGNED_BYTE &&
	    (srcType == GL_UNSIGNED_BYTE ||
	     srcType == GL_UNSIGNED_INT_8_8_8_8 ||
	     srcType == GL_UNSIGNED_INT_8_8_8_8_REV) &&
	    can_swizzle(baseInternalFormat) &&
	    can_swizzle(srcFormat)) {
d1046 8
a1053 2
      const GLubyte *dstmap;
      GLuint components;
d1055 2
a1056 30
      /* dstmap - how to swizzle from RGBA to dst format:
       */
      if (dstFormat == &_mesa_texformat_rgba) {
	 dstmap = mappings[IDX_RGBA].from_rgba;
	 components = 4;
      }
      else if (dstFormat == &_mesa_texformat_rgb) {
	 dstmap = mappings[IDX_RGB].from_rgba;
	 components = 3;
      }
      else if (dstFormat == &_mesa_texformat_alpha) {
	 dstmap = mappings[IDX_ALPHA].from_rgba;
	 components = 1;
      }
      else if (dstFormat == &_mesa_texformat_luminance) {
	 dstmap = mappings[IDX_LUMINANCE].from_rgba;
	 components = 1;
      }
      else if (dstFormat == &_mesa_texformat_luminance_alpha) {
	 dstmap = mappings[IDX_LUMINANCE_ALPHA].from_rgba;
	 components = 2;
      }
      else if (dstFormat == &_mesa_texformat_intensity) {
	 dstmap = mappings[IDX_INTENSITY].from_rgba;
	 components = 1;
      }
      else {
         _mesa_problem(ctx, "Unexpected dstFormat in _mesa_texstore_rgba");
         return GL_FALSE;
      }
d1058 1
a1058 11
      _mesa_swizzle_ubyte_image(ctx, dims,
				srcFormat,
				srcType,
				baseInternalFormat,
				dstmap, components,
				dstAddr, dstXoffset, dstYoffset, dstZoffset,
				dstRowStride, dstImageOffsets,
				srcWidth, srcHeight, srcDepth, srcAddr,
				srcPacking);      
   }
   else {
a1059 8
      const GLchan *tempImage = _mesa_make_temp_chan_image(ctx, dims,
                                                 baseInternalFormat,
                                                 dstFormat->BaseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking);
      const GLchan *src = tempImage;
      GLint bytesPerRow;
a1060 4
      if (!tempImage)
         return GL_FALSE;
      _mesa_adjust_image_for_convolution(ctx, dims, &srcWidth, &srcHeight);
      bytesPerRow = srcWidth * components * sizeof(GLchan);
d1063 1
a1063 1
            + dstImageOffsets[dstZoffset + img] * dstFormat->TexelBytes
d1065 1
a1065 1
            + dstXoffset * dstFormat->TexelBytes;
d1067 5
a1071 1
            _mesa_memcpy(dstRow, src, bytesPerRow);
a1072 1
            src += srcWidth * components;
a1074 2

      _mesa_free((void *) tempImage);
d1081 1
a1081 1
 * Store a 32-bit integer depth component texture image.
d1083 2
a1084 2
GLboolean
_mesa_texstore_z32(TEXSTORE_PARAMS)
d1086 3
a1088 1
   const GLuint depthScale = 0xffffffff;
d1090 1
a1090 2
   ASSERT(dstFormat == &_mesa_texformat_z32);
   ASSERT(dstFormat->TexelBytes == sizeof(GLuint));
d1092 1
a1092 15
   if (ctx->Pixel.DepthScale == 1.0f &&
       ctx->Pixel.DepthBias == 0.0f &&
       !srcPacking->SwapBytes &&
       baseInternalFormat == GL_DEPTH_COMPONENT &&
       srcFormat == GL_DEPTH_COMPONENT &&
       srcType == GL_UNSIGNED_INT) {
      /* simple memcpy path */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else {
d1097 1
a1097 1
            + dstImageOffsets[dstZoffset + img] * dstFormat->TexelBytes
d1099 1
a1099 1
            + dstXoffset * dstFormat->TexelBytes;
d1103 2
d1106 1
a1106 1
                                    GL_UNSIGNED_INT, (GLuint *) dstRow,
d1108 2
a1116 1
#define STRIDE_3D 0
d1121 1
a1121 1
GLboolean
d1125 1
d1127 2
a1128 2
   ASSERT(dstFormat == &_mesa_texformat_z16);
   ASSERT(dstFormat->TexelBytes == sizeof(GLushort));
d1149 1
a1149 1
            + dstImageOffsets[dstZoffset + img] * dstFormat->TexelBytes
d1151 1
a1151 1
            + dstXoffset * dstFormat->TexelBytes;
d1170 1
a1170 1
GLboolean
d1173 6
a1178 3
   ASSERT(dstFormat == &_mesa_texformat_rgb565 ||
          dstFormat == &_mesa_texformat_rgb565_rev);
   ASSERT(dstFormat->TexelBytes == 2);
d1182 1
a1182 1
       dstFormat == &_mesa_texformat_rgb565 &&
d1201 2
a1202 2
      const GLint srcRowStride = _mesa_image_row_stride(srcPacking, srcWidth,
                                                        srcFormat, srcType);
d1208 1
a1208 1
                   + dstXoffset * dstFormat->TexelBytes;
d1214 1
a1214 1
         if (dstFormat == &_mesa_texformat_rgb565) {
d1234 1
a1234 1
                                                 dstFormat->BaseFormat,
d1245 1
a1245 1
            + dstImageOffsets[dstZoffset + img] * dstFormat->TexelBytes
d1247 1
a1247 1
            + dstXoffset * dstFormat->TexelBytes;
d1251 1
a1251 1
            if (dstFormat == &_mesa_texformat_rgb565) {
d1270 1
a1270 1
      _mesa_free((void *) tempImage);
d1279 1
a1279 1
GLboolean
d1283 2
d1286 3
a1288 3
   ASSERT(dstFormat == &_mesa_texformat_rgba8888 ||
          dstFormat == &_mesa_texformat_rgba8888_rev);
   ASSERT(dstFormat->TexelBytes == 4);
d1292 1
a1292 1
       dstFormat == &_mesa_texformat_rgba8888 &&
d1308 1
a1308 1
       dstFormat == &_mesa_texformat_rgba8888_rev &&
d1333 2
a1334 2
      if ((littleEndian && dstFormat == &_mesa_texformat_rgba8888) ||
	  (!littleEndian && dstFormat == &_mesa_texformat_rgba8888_rev)) {
d1361 1
a1361 1
                                                 dstFormat->BaseFormat,
d1372 1
a1372 1
            + dstImageOffsets[dstZoffset + img] * dstFormat->TexelBytes
d1374 1
a1374 1
            + dstXoffset * dstFormat->TexelBytes;
d1377 1
a1377 1
            if (dstFormat == &_mesa_texformat_rgba8888) {
d1398 1
a1398 1
      _mesa_free((void *) tempImage);
d1404 1
a1404 1
GLboolean
d1408 2
d1411 5
a1415 3
   ASSERT(dstFormat == &_mesa_texformat_argb8888 ||
          dstFormat == &_mesa_texformat_argb8888_rev);
   ASSERT(dstFormat->TexelBytes == 4);
d1419 2
a1420 1
       dstFormat == &_mesa_texformat_argb8888 &&
d1435 2
a1436 1
       dstFormat == &_mesa_texformat_argb8888_rev &&
d1451 2
a1452 1
	    dstFormat == &_mesa_texformat_argb8888 &&
d1459 2
a1460 2
         const GLint srcRowStride = _mesa_image_row_stride(srcPacking,
                                                 srcWidth, srcFormat, srcType);
d1464 1
a1464 1
            + dstImageOffsets[dstZoffset + img] * dstFormat->TexelBytes
d1466 1
a1466 1
            + dstXoffset * dstFormat->TexelBytes;
d1482 1
a1482 1
	    dstFormat == &_mesa_texformat_argb8888 &&
d1495 2
a1496 2
         const GLint srcRowStride = _mesa_image_row_stride(srcPacking,
                                                 srcWidth, srcFormat, srcType);
d1500 1
a1500 1
            + dstImageOffsets[dstZoffset + img] * dstFormat->TexelBytes
d1502 1
a1502 1
            + dstXoffset * dstFormat->TexelBytes;
d1527 4
a1530 2
      if ((littleEndian && dstFormat == &_mesa_texformat_argb8888) ||
	  (!littleEndian && dstFormat == &_mesa_texformat_argb8888_rev)) {
d1537 4
a1540 2
	 assert((littleEndian && dstFormat == &_mesa_texformat_argb8888_rev) ||
		(!littleEndian && dstFormat == &_mesa_texformat_argb8888));
d1563 1
a1563 1
                                                 dstFormat->BaseFormat,
d1574 1
a1574 1
            + dstImageOffsets[dstZoffset + img] * dstFormat->TexelBytes
d1576 1
a1576 1
            + dstXoffset * dstFormat->TexelBytes;
d1579 1
a1579 1
            if (dstFormat == &_mesa_texformat_argb8888) {
d1588 9
d1609 1
a1609 1
      _mesa_free((void *) tempImage);
d1615 1
a1615 1
GLboolean
d1619 2
d1622 2
a1623 2
   ASSERT(dstFormat == &_mesa_texformat_rgb888);
   ASSERT(dstFormat->TexelBytes == 3);
d1646 2
a1647 2
         const GLint srcRowStride = _mesa_image_row_stride(srcPacking,
                                                 srcWidth, srcFormat, srcType);
d1651 1
a1651 1
            + dstImageOffsets[dstZoffset + img] * dstFormat->TexelBytes
d1653 1
a1653 1
            + dstXoffset * dstFormat->TexelBytes;
d1693 1
a1693 1
                                                 dstFormat->BaseFormat,
d1704 1
a1704 1
            + dstImageOffsets[dstZoffset + img] * dstFormat->TexelBytes
d1706 1
a1706 1
            + dstXoffset * dstFormat->TexelBytes;
d1736 1
a1736 1
      _mesa_free((void *) tempImage);
d1742 1
a1742 1
GLboolean
d1746 2
d1749 2
a1750 2
   ASSERT(dstFormat == &_mesa_texformat_bgr888);
   ASSERT(dstFormat->TexelBytes == 3);
d1773 2
a1774 2
         const GLint srcRowStride = _mesa_image_row_stride(srcPacking,
                                                 srcWidth, srcFormat, srcType);
d1778 1
a1778 1
            + dstImageOffsets[dstZoffset + img] * dstFormat->TexelBytes
d1780 1
a1780 1
            + dstXoffset * dstFormat->TexelBytes;
d1820 1
a1820 1
                                                 dstFormat->BaseFormat,
d1831 1
a1831 1
            + dstImageOffsets[dstZoffset + img] * dstFormat->TexelBytes
d1833 1
a1833 1
            + dstXoffset * dstFormat->TexelBytes;
d1844 1
a1844 1
      _mesa_free((void *) tempImage);
a1848 5
GLboolean
_mesa_texstore_rgba4444(TEXSTORE_PARAMS)
{
   ASSERT(dstFormat == &_mesa_texformat_rgba4444);
   ASSERT(dstFormat->TexelBytes == 2);
d1850 1
a1850 50
   if (!ctx->_ImageTransferState &&
       !srcPacking->SwapBytes &&
       dstFormat == &_mesa_texformat_rgba4444 &&
       baseInternalFormat == GL_RGBA &&
       srcFormat == GL_RGBA &&
       srcType == GL_UNSIGNED_SHORT_4_4_4_4){
      /* simple memcpy path */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else {
      /* general path */
      const GLchan *tempImage = _mesa_make_temp_chan_image(ctx, dims,
                                                 baseInternalFormat,
                                                 dstFormat->BaseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking);
      const GLchan *src = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      _mesa_adjust_image_for_convolution(ctx, dims, &srcWidth, &srcHeight);
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * dstFormat->TexelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * dstFormat->TexelBytes;
         for (row = 0; row < srcHeight; row++) {
            GLushort *dstUS = (GLushort *) dstRow;
	    for (col = 0; col < srcWidth; col++) {
	      dstUS[col] = PACK_COLOR_4444( CHAN_TO_UBYTE(src[RCOMP]),
					    CHAN_TO_UBYTE(src[GCOMP]),
					    CHAN_TO_UBYTE(src[BCOMP]),
					    CHAN_TO_UBYTE(src[ACOMP]) );
	      src += 4;
            }
            dstRow += dstRowStride;
         }
      }
      _mesa_free((void *) tempImage);
   }
   return GL_TRUE;
}

GLboolean
d1853 6
a1858 3
   ASSERT(dstFormat == &_mesa_texformat_argb4444 ||
          dstFormat == &_mesa_texformat_argb4444_rev);
   ASSERT(dstFormat->TexelBytes == 2);
d1862 1
a1862 1
       dstFormat == &_mesa_texformat_argb4444 &&
d1878 1
a1878 1
                                                 dstFormat->BaseFormat,
d1889 1
a1889 1
            + dstImageOffsets[dstZoffset + img] * dstFormat->TexelBytes
d1891 1
a1891 1
            + dstXoffset * dstFormat->TexelBytes;
d1894 1
a1894 1
            if (dstFormat == &_mesa_texformat_argb4444) {
d1915 1
a1915 1
      _mesa_free((void *) tempImage);
d1920 1
a1920 1
GLboolean
d1923 5
a1927 2
   ASSERT(dstFormat == &_mesa_texformat_rgba5551);
   ASSERT(dstFormat->TexelBytes == 2);
d1931 1
a1931 1
       dstFormat == &_mesa_texformat_rgba5551 &&
d1947 1
a1947 1
                                                 dstFormat->BaseFormat,
d1958 1
a1958 1
            + dstImageOffsets[dstZoffset + img] * dstFormat->TexelBytes
d1960 1
a1960 1
            + dstXoffset * dstFormat->TexelBytes;
d1973 1
a1973 1
      _mesa_free((void *) tempImage);
d1978 1
a1978 1
GLboolean
d1981 6
a1986 3
   ASSERT(dstFormat == &_mesa_texformat_argb1555 ||
          dstFormat == &_mesa_texformat_argb1555_rev);
   ASSERT(dstFormat->TexelBytes == 2);
d1990 1
a1990 1
       dstFormat == &_mesa_texformat_argb1555 &&
d2006 1
a2006 1
                                                 dstFormat->BaseFormat,
d2017 1
a2017 1
            + dstImageOffsets[dstZoffset + img] * dstFormat->TexelBytes
d2019 1
a2019 1
            + dstXoffset * dstFormat->TexelBytes;
d2022 1
a2022 1
            if (dstFormat == &_mesa_texformat_argb1555) {
d2043 1
a2043 1
      _mesa_free((void *) tempImage);
d2049 1
a2049 1
GLboolean
d2053 2
d2056 3
a2058 3
   ASSERT(dstFormat == &_mesa_texformat_al88 ||
          dstFormat == &_mesa_texformat_al88_rev);
   ASSERT(dstFormat->TexelBytes == 2);
d2062 1
a2062 1
       dstFormat == &_mesa_texformat_al88 &&
d2085 2
a2086 2
      if ((littleEndian && dstFormat == &_mesa_texformat_al88) ||
	  (!littleEndian && dstFormat == &_mesa_texformat_al88_rev)) {
d2111 1
a2111 1
                                                 dstFormat->BaseFormat,
d2122 1
a2122 1
            + dstImageOffsets[dstZoffset + img] * dstFormat->TexelBytes
d2124 1
a2124 1
            + dstXoffset * dstFormat->TexelBytes;
d2127 1
a2127 1
            if (dstFormat == &_mesa_texformat_al88) {
d2146 1
a2146 1
      _mesa_free((void *) tempImage);
d2152 2
a2153 2
GLboolean
_mesa_texstore_rgb332(TEXSTORE_PARAMS)
d2155 7
a2161 2
   ASSERT(dstFormat == &_mesa_texformat_rgb332);
   ASSERT(dstFormat->TexelBytes == 1);
d2165 5
a2169 2
       baseInternalFormat == GL_RGB &&
       srcFormat == GL_RGB && srcType == GL_UNSIGNED_BYTE_3_3_2) {
d2180 1
a2180 1
      const GLchan *tempImage = _mesa_make_temp_chan_image(ctx, dims,
d2182 1
a2182 1
                                                 dstFormat->BaseFormat,
d2186 1
a2186 1
      const GLchan *src = tempImage;
d2193 1
a2193 1
            + dstImageOffsets[dstZoffset + img] * dstFormat->TexelBytes
d2195 1
a2195 1
            + dstXoffset * dstFormat->TexelBytes;
d2197 20
a2216 5
            for (col = 0; col < srcWidth; col++) {
               dstRow[col] = PACK_COLOR_332( CHAN_TO_UBYTE(src[RCOMP]),
                                             CHAN_TO_UBYTE(src[GCOMP]),
                                             CHAN_TO_UBYTE(src[BCOMP]) );
               src += 3;
d2221 1
a2221 1
      _mesa_free((void *) tempImage);
d2227 2
a2228 5
/**
 * Texstore for _mesa_texformat_a8, _mesa_texformat_l8, _mesa_texformat_i8.
 */
GLboolean
_mesa_texstore_a8(TEXSTORE_PARAMS)
d2230 5
a2234 4
   ASSERT(dstFormat == &_mesa_texformat_a8 ||
          dstFormat == &_mesa_texformat_l8 ||
          dstFormat == &_mesa_texformat_i8);
   ASSERT(dstFormat->TexelBytes == 1);
d2238 62
a2299 2
       baseInternalFormat == srcFormat &&
       srcType == GL_UNSIGNED_BYTE) {
d2317 1
a2317 1
      if (dstFormat == &_mesa_texformat_a8) {
d2341 1
a2341 1
                                                 dstFormat->BaseFormat,
d2352 1
a2352 1
            + dstImageOffsets[dstZoffset + img] * dstFormat->TexelBytes
d2354 1
a2354 1
            + dstXoffset * dstFormat->TexelBytes;
d2363 1
a2363 1
      _mesa_free((void *) tempImage);
d2370 1
a2370 1
GLboolean
d2373 2
d2376 2
a2377 2
   ASSERT(dstFormat == &_mesa_texformat_ci8);
   ASSERT(dstFormat->TexelBytes == 1);
d2397 1
a2397 1
            + dstImageOffsets[dstZoffset + img] * dstFormat->TexelBytes
d2399 1
a2399 1
            + dstXoffset * dstFormat->TexelBytes;
d2415 1
a2415 1
 * Texstore for _mesa_texformat_ycbcr or _mesa_texformat_ycbcr_rev.
d2417 1
a2417 1
GLboolean
d2421 2
d2425 3
a2427 3
   ASSERT((dstFormat == &_mesa_texformat_ycbcr) ||
          (dstFormat == &_mesa_texformat_ycbcr_rev));
   ASSERT(dstFormat->TexelBytes == 2);
d2446 1
a2446 1
       (dstFormat == &_mesa_texformat_ycbcr_rev) ^
d2451 1
a2451 1
            + dstImageOffsets[dstZoffset + img] * dstFormat->TexelBytes
d2453 1
a2453 1
            + dstXoffset * dstFormat->TexelBytes;
d2463 139
d2603 71
d2678 1
a2678 1
GLboolean
d2681 30
a2710 1
   const GLfloat depthScale = (GLfloat) 0xffffff;
d2712 2
a2713 3
   ASSERT(dstFormat == &_mesa_texformat_z24_s8);
   ASSERT(srcFormat == GL_DEPTH_STENCIL_EXT);
   ASSERT(srcType == GL_UNSIGNED_INT_24_8_EXT);
d2715 6
a2720 1
   if (ctx->Pixel.DepthScale == 1.0f &&
d2755 1
a2755 1
                                    (GLuint) depthScale,
d2779 1
a2779 1
GLboolean
d2788 1
a2788 1
   ASSERT(dstFormat == &_mesa_texformat_s8_z24);
d2868 1
a2868 1
GLboolean
d2871 10
a2880 8
   const GLint components = _mesa_components_in_format(dstFormat->BaseFormat);

   ASSERT(dstFormat == &_mesa_texformat_rgba_float32 ||
          dstFormat == &_mesa_texformat_rgb_float32 ||
          dstFormat == &_mesa_texformat_alpha_float32 ||
          dstFormat == &_mesa_texformat_luminance_float32 ||
          dstFormat == &_mesa_texformat_luminance_alpha_float32 ||
          dstFormat == &_mesa_texformat_intensity_float32);
d2887 1
a2887 1
   ASSERT(dstFormat->TexelBytes == components * sizeof(GLfloat));
d2905 1
a2905 1
                                                 dstFormat->BaseFormat,
d2918 1
a2918 1
            + dstImageOffsets[dstZoffset + img] * dstFormat->TexelBytes
d2920 1
a2920 1
            + dstXoffset * dstFormat->TexelBytes;
d2922 1
a2922 1
            _mesa_memcpy(dstRow, srcRow, bytesPerRow);
d2928 1
a2928 1
      _mesa_free((void *) tempImage);
d2937 1
a2937 1
GLboolean
d2940 10
a2949 8
   const GLint components = _mesa_components_in_format(dstFormat->BaseFormat);

   ASSERT(dstFormat == &_mesa_texformat_rgba_float16 ||
          dstFormat == &_mesa_texformat_rgb_float16 ||
          dstFormat == &_mesa_texformat_alpha_float16 ||
          dstFormat == &_mesa_texformat_luminance_float16 ||
          dstFormat == &_mesa_texformat_luminance_alpha_float16 ||
          dstFormat == &_mesa_texformat_intensity_float16);
d2956 1
a2956 1
   ASSERT(dstFormat->TexelBytes == components * sizeof(GLhalfARB));
d2974 1
a2974 1
                                                 dstFormat->BaseFormat,
d2985 1
a2985 1
            + dstImageOffsets[dstZoffset + img] * dstFormat->TexelBytes
d2987 1
a2987 1
            + dstXoffset * dstFormat->TexelBytes;
d2999 1
a2999 1
      _mesa_free((void *) tempImage);
d3006 1
a3006 1
GLboolean
d3009 1
a3009 3
   const GLboolean littleEndian = _mesa_little_endian();
   const struct gl_texture_format *newDstFormat;
   StoreTexImageFunc store;
d3012 1
a3012 1
   ASSERT(dstFormat == &_mesa_texformat_srgb8);
d3015 1
a3015 8
   if (littleEndian) {
      newDstFormat = &_mesa_texformat_bgr888;
      store = _mesa_texstore_bgr888;
   }
   else {
      newDstFormat = &_mesa_texformat_rgb888;
      store = _mesa_texstore_rgb888;
   }
d3017 1
a3017 1
   k = store(ctx, dims, baseInternalFormat,
d3028 1
a3028 1
GLboolean
d3031 22
a3052 2
   const GLboolean littleEndian = _mesa_little_endian();
   const struct gl_texture_format *newDstFormat;
d3055 1
a3055 1
   ASSERT(dstFormat == &_mesa_texformat_srgba8);
d3058 1
a3058 4
   if (littleEndian)
      newDstFormat = &_mesa_texformat_rgba8888_rev;
   else
      newDstFormat = &_mesa_texformat_rgba8888;
d3060 1
a3060 1
   k = _mesa_texstore_rgba8888(ctx, dims, baseInternalFormat,
d3071 1
a3071 1
GLboolean
d3074 1
a3074 1
   const struct gl_texture_format *newDstFormat;
d3077 1
a3077 1
   ASSERT(dstFormat == &_mesa_texformat_sl8);
d3079 1
a3079 1
   newDstFormat = &_mesa_texformat_l8;
d3093 1
a3093 1
GLboolean
d3096 1
a3096 2
   const GLboolean littleEndian = _mesa_little_endian();
   const struct gl_texture_format *newDstFormat;
d3099 1
a3099 1
   ASSERT(dstFormat == &_mesa_texformat_sla8);
d3102 1
a3102 4
   if (littleEndian)
      newDstFormat = &_mesa_texformat_al88;
   else
      newDstFormat = &_mesa_texformat_al88_rev;
d3114 9
d3126 142
d3283 1
a3283 1
   if (unpack->BufferObj->Name == 0) {
d3319 1
a3319 1
   if (packing->BufferObj->Name == 0) {
d3349 1
a3349 1
   if (unpack->BufferObj->Name) {
d3356 3
a3358 56

/**
 * Adaptor for fetching a GLchan texel from a float-valued texture.
 */
static void
fetch_texel_float_to_chan(const struct gl_texture_image *texImage,
                          GLint i, GLint j, GLint k, GLchan *texelOut)
{
   GLfloat temp[4];
   ASSERT(texImage->FetchTexelf);
   texImage->FetchTexelf(texImage, i, j, k, temp);
   if (texImage->TexFormat->BaseFormat == GL_DEPTH_COMPONENT ||
       texImage->TexFormat->BaseFormat == GL_DEPTH_STENCIL_EXT) {
      /* just one channel */
      UNCLAMPED_FLOAT_TO_CHAN(texelOut[0], temp[0]);
   }
   else {
      /* four channels */
      UNCLAMPED_FLOAT_TO_CHAN(texelOut[0], temp[0]);
      UNCLAMPED_FLOAT_TO_CHAN(texelOut[1], temp[1]);
      UNCLAMPED_FLOAT_TO_CHAN(texelOut[2], temp[2]);
      UNCLAMPED_FLOAT_TO_CHAN(texelOut[3], temp[3]);
   }
}


/**
 * Adaptor for fetching a float texel from a GLchan-valued texture.
 */
static void
fetch_texel_chan_to_float(const struct gl_texture_image *texImage,
                          GLint i, GLint j, GLint k, GLfloat *texelOut)
{
   GLchan temp[4];
   ASSERT(texImage->FetchTexelc);
   texImage->FetchTexelc(texImage, i, j, k, temp);
   if (texImage->TexFormat->BaseFormat == GL_DEPTH_COMPONENT ||
       texImage->TexFormat->BaseFormat == GL_DEPTH_STENCIL_EXT) {
      /* just one channel */
      texelOut[0] = CHAN_TO_FLOAT(temp[0]);
   }
   else {
      /* four channels */
      texelOut[0] = CHAN_TO_FLOAT(temp[0]);
      texelOut[1] = CHAN_TO_FLOAT(temp[1]);
      texelOut[2] = CHAN_TO_FLOAT(temp[2]);
      texelOut[3] = CHAN_TO_FLOAT(temp[3]);
   }
}


/**
 * Initialize the texture image's FetchTexelc and FetchTexelf methods.
 */
void
_mesa_set_fetch_functions(struct gl_texture_image *texImage, GLuint dims)
d3360 3
a3362 31
   ASSERT(dims == 1 || dims == 2 || dims == 3);
   ASSERT(texImage->TexFormat);

   switch (dims) {
   case 1:
      texImage->FetchTexelc = texImage->TexFormat->FetchTexel1D;
      texImage->FetchTexelf = texImage->TexFormat->FetchTexel1Df;
      break;
   case 2:
      texImage->FetchTexelc = texImage->TexFormat->FetchTexel2D;
      texImage->FetchTexelf = texImage->TexFormat->FetchTexel2Df;
      break;
   case 3:
      texImage->FetchTexelc = texImage->TexFormat->FetchTexel3D;
      texImage->FetchTexelf = texImage->TexFormat->FetchTexel3Df;
      break;
   default:
      ;
   }

   /* now check if we need to use a float/chan adaptor */
   if (!texImage->FetchTexelc) {
      texImage->FetchTexelc = fetch_texel_float_to_chan;
   }
   else if (!texImage->FetchTexelf) {
      texImage->FetchTexelf = fetch_texel_chan_to_float;
   }


   ASSERT(texImage->FetchTexelc);
   ASSERT(texImage->FetchTexelf);
d3366 3
a3368 15
/**
 * Choose the actual storage format for a new texture image.
 * Mainly, this is a wrapper for the driver's ChooseTextureFormat() function.
 * Also set some other texImage fields related to texture compression, etc.
 * \param ctx  rendering context
 * \param texImage  the gl_texture_image
 * \param dims  texture dimensions (1, 2 or 3)
 * \param format  the user-specified format parameter
 * \param type  the user-specified type parameter
 * \param internalFormat  the user-specified internal format hint
 */
static void
choose_texture_format(GLcontext *ctx, struct gl_texture_image *texImage,
                      GLuint dims,
                      GLenum format, GLenum type, GLint internalFormat)
d3370 3
a3372 23
   ASSERT(dims == 1 || dims == 2 || dims == 3);
   ASSERT(ctx->Driver.ChooseTextureFormat);

   texImage->TexFormat
      = ctx->Driver.ChooseTextureFormat(ctx, internalFormat, format, type);

   ASSERT(texImage->TexFormat);

   _mesa_set_fetch_functions(texImage, dims);

   if (texImage->TexFormat->TexelBytes == 0) {
      /* must be a compressed format */
      texImage->IsCompressed = GL_TRUE;
      texImage->CompressedSize =
         ctx->Driver.CompressedTextureSize(ctx, texImage->Width,
                                           texImage->Height, texImage->Depth,
                                           texImage->TexFormat->MesaFormat);
   }
   else {
      /* non-compressed format */
      texImage->IsCompressed = GL_FALSE;
      texImage->CompressedSize = 0;
   }
d3394 1
a3394 1
   GLint sizeInBytes;
a3396 2
   choose_texture_format(ctx, texImage, 1, format, type, internalFormat);

d3398 1
a3398 4
   if (texImage->IsCompressed)
      sizeInBytes = texImage->CompressedSize;
   else
      sizeInBytes = texImage->Width * texImage->TexFormat->TexelBytes;
d3415 8
a3422 10
      GLboolean success;
      ASSERT(texImage->TexFormat->StoreImage);
      success = texImage->TexFormat->StoreImage(ctx, 1, texImage->_BaseFormat,
                                                texImage->TexFormat,
                                                texImage->Data,
                                                0, 0, 0,  /* dstX/Y/Zoffset */
                                                dstRowStride,
                                                texImage->ImageOffsets,
                                                width, 1, 1,
                                                format, type, pixels, packing);
a3427 5
   /* GL_SGIS_generate_mipmap */
   if (level == texObj->BaseLevel && texObj->GenerateMipmap) {
      ctx->Driver.GenerateMipmap(ctx, target, texObj);
   }

d3451 1
a3451 1
   GLint texelBytes, sizeInBytes;
a3453 4
   choose_texture_format(ctx, texImage, 2, format, type, internalFormat);

   texelBytes = texImage->TexFormat->TexelBytes;

d3455 1
a3455 4
   if (texImage->IsCompressed)
      sizeInBytes = texImage->CompressedSize;
   else
      sizeInBytes = texImage->Width * texImage->Height * texelBytes;
d3471 9
a3479 18
      GLint dstRowStride;
      GLboolean success;
      if (texImage->IsCompressed) {
         dstRowStride
            = _mesa_compressed_row_stride(texImage->TexFormat->MesaFormat, width);
      }
      else {
         dstRowStride = texImage->RowStride * texImage->TexFormat->TexelBytes;
      }
      ASSERT(texImage->TexFormat->StoreImage);
      success = texImage->TexFormat->StoreImage(ctx, 2, texImage->_BaseFormat,
                                                texImage->TexFormat,
                                                texImage->Data,
                                                0, 0, 0,  /* dstX/Y/Zoffset */
                                                dstRowStride,
                                                texImage->ImageOffsets,
                                                width, height, 1,
                                                format, type, pixels, packing);
a3484 5
   /* GL_SGIS_generate_mipmap */
   if (level == texObj->BaseLevel && texObj->GenerateMipmap) {
      ctx->Driver.GenerateMipmap(ctx, target, texObj);
   }

d3504 1
a3504 1
   GLint texelBytes, sizeInBytes;
a3506 4
   choose_texture_format(ctx, texImage, 3, format, type, internalFormat);

   texelBytes = texImage->TexFormat->TexelBytes;

d3508 1
a3508 4
   if (texImage->IsCompressed)
      sizeInBytes = texImage->CompressedSize;
   else
      sizeInBytes = width * height * depth * texelBytes;
d3524 9
a3532 18
      GLint dstRowStride;
      GLboolean success;
      if (texImage->IsCompressed) {
         dstRowStride
            = _mesa_compressed_row_stride(texImage->TexFormat->MesaFormat, width);
      }
      else {
         dstRowStride = texImage->RowStride * texImage->TexFormat->TexelBytes;
      }
      ASSERT(texImage->TexFormat->StoreImage);
      success = texImage->TexFormat->StoreImage(ctx, 3, texImage->_BaseFormat,
                                                texImage->TexFormat,
                                                texImage->Data,
                                                0, 0, 0,  /* dstX/Y/Zoffset */
                                                dstRowStride,
                                                texImage->ImageOffsets,
                                                width, height, depth,
                                                format, type, pixels, packing);
a3537 5
   /* GL_SGIS_generate_mipmap */
   if (level == texObj->BaseLevel && texObj->GenerateMipmap) {
      ctx->Driver.GenerateMipmap(ctx, target, texObj);
   }

d3564 8
a3571 10
      GLboolean success;
      ASSERT(texImage->TexFormat->StoreImage);
      success = texImage->TexFormat->StoreImage(ctx, 1, texImage->_BaseFormat,
                                                texImage->TexFormat,
                                                texImage->Data,
                                                xoffset, 0, 0,  /* offsets */
                                                dstRowStride,
                                                texImage->ImageOffsets,
                                                width, 1, 1,
                                                format, type, pixels, packing);
a3576 5
   /* GL_SGIS_generate_mipmap */
   if (level == texObj->BaseLevel && texObj->GenerateMipmap) {
      ctx->Driver.GenerateMipmap(ctx, target, texObj);
   }

d3602 9
a3610 18
      GLint dstRowStride = 0;
      GLboolean success;
      if (texImage->IsCompressed) {
         dstRowStride = _mesa_compressed_row_stride(texImage->TexFormat->MesaFormat,
                                                    texImage->Width);
      }
      else {
         dstRowStride = texImage->RowStride * texImage->TexFormat->TexelBytes;
      }
      ASSERT(texImage->TexFormat->StoreImage);
      success = texImage->TexFormat->StoreImage(ctx, 2, texImage->_BaseFormat,
                                                texImage->TexFormat,
                                                texImage->Data,
                                                xoffset, yoffset, 0,
                                                dstRowStride,
                                                texImage->ImageOffsets,
                                                width, height, 1,
                                                format, type, pixels, packing);
a3615 5
   /* GL_SGIS_generate_mipmap */
   if (level == texObj->BaseLevel && texObj->GenerateMipmap) {
      ctx->Driver.GenerateMipmap(ctx, target, texObj);
   }

d3641 9
a3649 18
      GLint dstRowStride;
      GLboolean success;
      if (texImage->IsCompressed) {
         dstRowStride = _mesa_compressed_row_stride(texImage->TexFormat->MesaFormat,
                                                    texImage->Width);
      }
      else {
         dstRowStride = texImage->RowStride * texImage->TexFormat->TexelBytes;
      }
      ASSERT(texImage->TexFormat->StoreImage);
      success = texImage->TexFormat->StoreImage(ctx, 3, texImage->_BaseFormat,
                                                texImage->TexFormat,
                                                texImage->Data,
                                                xoffset, yoffset, zoffset,
                                                dstRowStride,
                                                texImage->ImageOffsets,
                                                width, height, depth,
                                                format, type, pixels, packing);
a3654 5
   /* GL_SGIS_generate_mipmap */
   if (level == texObj->BaseLevel && texObj->GenerateMipmap) {
      ctx->Driver.GenerateMipmap(ctx, target, texObj);
   }

a3704 2
   choose_texture_format(ctx, texImage, 2, 0, 0, internalFormat);

d3719 1
a3719 7
   ASSERT(texImage->CompressedSize == (GLuint) imageSize);
   MEMCPY(texImage->Data, data, imageSize);

   /* GL_SGIS_generate_mipmap */
   if (level == texObj->BaseLevel && texObj->GenerateMipmap) {
      ctx->Driver.GenerateMipmap(ctx, target, texObj);
   }
d3791 3
a3793 1
   const GLuint mesaFormat = texImage->TexFormat->MesaFormat;
d3795 3
d3801 4
a3804 4
   ASSERT((width & 3) == 0 || width == 2 || width == 1);
   ASSERT((height & 3) == 0 || height == 2 || height == 1);
   ASSERT((xoffset & 3) == 0);
   ASSERT((yoffset & 3) == 0);
d3813 1
a3813 1
   srcRowStride = _mesa_compressed_row_stride(mesaFormat, width);
d3816 1
a3816 1
   destRowStride = _mesa_compressed_row_stride(mesaFormat, texImage->Width);
d3818 1
a3818 2
                                         texImage->TexFormat->MesaFormat,
                                         texImage->Width,
d3821 2
a3822 2
   bytesPerRow = srcRowStride;
   rows = height / 4;
d3824 1
d3826 1
a3826 1
      MEMCPY(dest, src, bytesPerRow);
a3830 5
   /* GL_SGIS_generate_mipmap */
   if (level == texObj->BaseLevel && texObj->GenerateMipmap) {
      ctx->Driver.GenerateMipmap(ctx, target, texObj);
   }

a3856 249
}




#if FEATURE_EXT_texture_sRGB

/**
 * Test if given texture image is an sRGB format.
 */
static GLboolean
is_srgb_teximage(const struct gl_texture_image *texImage)
{
   switch (texImage->TexFormat->MesaFormat) {
   case MESA_FORMAT_SRGB8:
   case MESA_FORMAT_SRGBA8:
   case MESA_FORMAT_SL8:
   case MESA_FORMAT_SLA8:
      return GL_TRUE;
   default:
      return GL_FALSE;
   }
}

#endif /* FEATURE_EXT_texture_sRGB */


/**
 * This is the software fallback for Driver.GetTexImage().
 * All error checking will have been done before this routine is called.
 */
void
_mesa_get_teximage(GLcontext *ctx, GLenum target, GLint level,
                   GLenum format, GLenum type, GLvoid *pixels,
                   struct gl_texture_object *texObj,
                   struct gl_texture_image *texImage)
{
   const GLuint dimensions = (target == GL_TEXTURE_3D) ? 3 : 2;

   if (ctx->Pack.BufferObj->Name) {
      /* Packing texture image into a PBO.
       * Map the (potentially) VRAM-based buffer into our process space so
       * we can write into it with the code below.
       * A hardware driver might use a sophisticated blit to move the
       * texture data to the PBO if the PBO is in VRAM along with the texture.
       */
      GLubyte *buf = (GLubyte *)
         ctx->Driver.MapBuffer(ctx, GL_PIXEL_PACK_BUFFER_EXT,
                               GL_WRITE_ONLY_ARB, ctx->Pack.BufferObj);
      if (!buf) {
         /* buffer is already mapped - that's an error */
         _mesa_error(ctx, GL_INVALID_OPERATION,"glGetTexImage(PBO is mapped)");
         return;
      }
      /* <pixels> was an offset into the PBO.
       * Now make it a real, client-side pointer inside the mapped region.
       */
      pixels = ADD_POINTERS(buf, pixels);
   }
   else if (!pixels) {
      /* not an error */
      return;
   }

   {
      const GLint width = texImage->Width;
      const GLint height = texImage->Height;
      const GLint depth = texImage->Depth;
      GLint img, row;
      for (img = 0; img < depth; img++) {
         for (row = 0; row < height; row++) {
            /* compute destination address in client memory */
            GLvoid *dest = _mesa_image_address( dimensions, &ctx->Pack, pixels,
                                                width, height, format, type,
                                                img, row, 0);
            assert(dest);

            if (format == GL_COLOR_INDEX) {
               GLuint indexRow[MAX_WIDTH];
               GLint col;
               /* Can't use FetchTexel here because that returns RGBA */
               if (texImage->TexFormat->IndexBits == 8) {
                  const GLubyte *src = (const GLubyte *) texImage->Data;
                  src += width * (img * texImage->Height + row);
                  for (col = 0; col < width; col++) {
                     indexRow[col] = src[col];
                  }
               }
               else if (texImage->TexFormat->IndexBits == 16) {
                  const GLushort *src = (const GLushort *) texImage->Data;
                  src += width * (img * texImage->Height + row);
                  for (col = 0; col < width; col++) {
                     indexRow[col] = src[col];
                  }
               }
               else {
                  _mesa_problem(ctx,
                                "Color index problem in _mesa_GetTexImage");
               }
               _mesa_pack_index_span(ctx, width, type, dest,
                                     indexRow, &ctx->Pack,
                                     0 /* no image transfer */);
            }
            else if (format == GL_DEPTH_COMPONENT) {
               GLfloat depthRow[MAX_WIDTH];
               GLint col;
               for (col = 0; col < width; col++) {
                  (*texImage->FetchTexelf)(texImage, col, row, img,
                                           depthRow + col);
               }
               _mesa_pack_depth_span(ctx, width, dest, type,
                                     depthRow, &ctx->Pack);
            }
            else if (format == GL_DEPTH_STENCIL_EXT) {
               /* XXX Note: we're bypassing texImage->FetchTexel()! */
               const GLuint *src = (const GLuint *) texImage->Data;
               src += width * row + width * height * img;
               _mesa_memcpy(dest, src, width * sizeof(GLuint));
               if (ctx->Pack.SwapBytes) {
                  _mesa_swap4((GLuint *) dest, width);
               }
            }
            else if (format == GL_YCBCR_MESA) {
               /* No pixel transfer */
               const GLint rowstride = texImage->RowStride;
               MEMCPY(dest,
                      (const GLushort *) texImage->Data + row * rowstride,
                      width * sizeof(GLushort));
               /* check for byte swapping */
               if ((texImage->TexFormat->MesaFormat == MESA_FORMAT_YCBCR
                    && type == GL_UNSIGNED_SHORT_8_8_REV_MESA) ||
                   (texImage->TexFormat->MesaFormat == MESA_FORMAT_YCBCR_REV
                    && type == GL_UNSIGNED_SHORT_8_8_MESA)) {
                  if (!ctx->Pack.SwapBytes)
                     _mesa_swap2((GLushort *) dest, width);
               }
               else if (ctx->Pack.SwapBytes) {
                  _mesa_swap2((GLushort *) dest, width);
               }
            }
#if FEATURE_EXT_texture_sRGB
            else if (is_srgb_teximage(texImage)) {
               /* no pixel transfer and no non-linear to linear conversion */
               const GLint comps = texImage->TexFormat->TexelBytes;
               const GLint rowstride = comps * texImage->RowStride;
               MEMCPY(dest,
                      (const GLubyte *) texImage->Data + row * rowstride,
                      comps * width * sizeof(GLubyte));
            }
#endif /* FEATURE_EXT_texture_sRGB */
            else {
               /* general case:  convert row to RGBA format */
               GLfloat rgba[MAX_WIDTH][4];
               GLint col;
               GLbitfield transferOps = 0x0;

               if (type == GL_FLOAT && 
                   ((ctx->Color.ClampReadColor == GL_TRUE) ||
                    (ctx->Color.ClampReadColor == GL_FIXED_ONLY_ARB &&
                     texImage->TexFormat->DataType != GL_FLOAT)))
                  transferOps |= IMAGE_CLAMP_BIT;

               for (col = 0; col < width; col++) {
                  (*texImage->FetchTexelf)(texImage, col, row, img, rgba[col]);
                  if (texImage->TexFormat->BaseFormat == GL_ALPHA) {
                     rgba[col][RCOMP] = 0.0;
                     rgba[col][GCOMP] = 0.0;
                     rgba[col][BCOMP] = 0.0;
                  }
                  else if (texImage->TexFormat->BaseFormat == GL_LUMINANCE) {
                     rgba[col][GCOMP] = 0.0;
                     rgba[col][BCOMP] = 0.0;
                     rgba[col][ACOMP] = 1.0;
                  }
                  else if (texImage->TexFormat->BaseFormat == GL_LUMINANCE_ALPHA) {
                     rgba[col][GCOMP] = 0.0;
                     rgba[col][BCOMP] = 0.0;
                  }
                  else if (texImage->TexFormat->BaseFormat == GL_INTENSITY) {
                     rgba[col][GCOMP] = 0.0;
                     rgba[col][BCOMP] = 0.0;
                     rgba[col][ACOMP] = 1.0;
                  }
               }
               _mesa_pack_rgba_span_float(ctx, width, (GLfloat (*)[4]) rgba,
                                          format, type, dest,
                                          &ctx->Pack, transferOps /*image xfer ops*/);
            } /* format */
         } /* row */
      } /* img */
   }

   if (ctx->Pack.BufferObj->Name) {
      ctx->Driver.UnmapBuffer(ctx, GL_PIXEL_PACK_BUFFER_EXT,
                              ctx->Pack.BufferObj);
   }
}



/**
 * This is the software fallback for Driver.GetCompressedTexImage().
 * All error checking will have been done before this routine is called.
 */
void
_mesa_get_compressed_teximage(GLcontext *ctx, GLenum target, GLint level,
                              GLvoid *img,
                              struct gl_texture_object *texObj,
                              struct gl_texture_image *texImage)
{
   GLuint size;

   if (ctx->Pack.BufferObj->Name) {
      /* pack texture image into a PBO */
      GLubyte *buf;
      if ((const GLubyte *) img + texImage->CompressedSize >
          (const GLubyte *) ctx->Pack.BufferObj->Size) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glGetCompressedTexImage(invalid PBO access)");
         return;
      }
      buf = (GLubyte *) ctx->Driver.MapBuffer(ctx, GL_PIXEL_PACK_BUFFER_EXT,
                                              GL_WRITE_ONLY_ARB,
                                              ctx->Pack.BufferObj);
      if (!buf) {
         /* buffer is already mapped - that's an error */
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glGetCompressedTexImage(PBO is mapped)");
         return;
      }
      img = ADD_POINTERS(buf, img);
   }
   else if (!img) {
      /* not an error */
      return;
   }

   /* don't use texImage->CompressedSize since that may be padded out */
   size = _mesa_compressed_texture_size(ctx, texImage->Width, texImage->Height,
                                        texImage->Depth,
                                        texImage->TexFormat->MesaFormat);

   /* just memcpy, no pixelstore or pixel transfer */
   _mesa_memcpy(img, texImage->Data, size);

   if (ctx->Pack.BufferObj->Name) {
      ctx->Driver.UnmapBuffer(ctx, GL_PIXEL_PACK_BUFFER_EXT,
                              ctx->Pack.BufferObj);
   }
@


1.4
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d3 1
a3 1
 * Version:  7.1
d58 1
d60 1
d274 10
d387 1
d407 1
a407 1

d564 1
d586 1
d1163 2
a1164 1
   if (!ctx->_ImageTransferState &&
d1211 2
a1212 1
   if (!ctx->_ImageTransferState &&
d1539 4
a1542 4
               d4[col] = ((0xff                    << 24) |
                          (srcRow[col * 3 + RCOMP] << 16) |
                          (srcRow[col * 3 + GCOMP] <<  8) |
                          (srcRow[col * 3 + BCOMP] <<  0));
d1554 1
a1554 2
            srcType == GL_UNSIGNED_BYTE &&
            littleEndian) {
d1575 4
a1578 33
               d4[col] = ((srcRow[col * 4 + ACOMP] << 24) |
                          (srcRow[col * 4 + RCOMP] << 16) |
                          (srcRow[col * 4 + GCOMP] <<  8) |
                          (srcRow[col * 4 + BCOMP] <<  0));
            }
            dstRow += dstRowStride;
            srcRow += srcRowStride;
         }
      }
   }
   else if (!ctx->_ImageTransferState &&
            !srcPacking->SwapBytes &&
	    dstFormat == &_mesa_texformat_argb8888 &&
            srcFormat == GL_RGBA &&
	    baseInternalFormat == GL_RGBA &&
            srcType == GL_UNSIGNED_BYTE) {

      GLint img, row, col;
      for (img = 0; img < srcDepth; img++) {
         const GLint srcRowStride = _mesa_image_row_stride(srcPacking,
                                                 srcWidth, srcFormat, srcType);
         GLubyte *srcRow = (GLubyte *) _mesa_image_address(dims, srcPacking,
                  srcAddr, srcWidth, srcHeight, srcFormat, srcType, img, 0, 0);
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * dstFormat->TexelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * dstFormat->TexelBytes;
         for (row = 0; row < srcHeight; row++) {
            for (col = 0; col < srcWidth; col++) {
               dstRow[col * 4 + 0] = srcRow[col * 4 + BCOMP];
               dstRow[col * 4 + 1] = srcRow[col * 4 + GCOMP];
               dstRow[col * 4 + 2] = srcRow[col * 4 + RCOMP];
               dstRow[col * 4 + 3] = srcRow[col * 4 + ACOMP];
d1901 54
d2023 5
d2029 48
d2487 2
a2488 1
   if (!ctx->_ImageTransferState &&
d2522 1
a2522 1
                                    depthScale,
d2559 1
a2559 1
   /* Incase we only upload depth we need to preserve the stencil */
d2587 2
a2588 1
   } else {
d3098 1
a3098 1
/*
d3102 3
a3114 1
   GLint postConvWidth = width;
a3117 4
   if (ctx->_ImageTransferState & IMAGE_CONVOLUTION_BIT) {
      _mesa_adjust_image_for_convolution(ctx, 1, &postConvWidth, NULL);
   }

d3124 1
a3124 1
      sizeInBytes = postConvWidth * texImage->TexFormat->TexelBytes;
a3183 1
   GLint postConvWidth = width, postConvHeight = height;
a3186 5
   if (ctx->_ImageTransferState & IMAGE_CONVOLUTION_BIT) {
      _mesa_adjust_image_for_convolution(ctx, 2, &postConvWidth,
                                         &postConvHeight);
   }

d3195 1
a3195 1
      sizeInBytes = postConvWidth * postConvHeight * texelBytes;
d3829 8
d3861 1
a3861 1
                                          &ctx->Pack, 0x0 /*image xfer ops*/);
@


1.3
log
@Fix out-of-bounds memory access in swizzle_copy(). My fix was different,
but this one (from mesa, prompted by my diff) should run a little faster.
Now mplayer -vo gl or gl2 works with dri enabled.

Detected by otto malloc.  Some debugging help from todd.

ok matthieu@@, todd@@.
@
text
@d371 4
a377 2
            convWidth = srcWidth;
            convHeight = srcHeight;
d1143 1
a1143 1
   const GLfloat depthScale = (GLfloat) 0xffffffff;
d1190 1
a1190 1
   const GLfloat depthScale = 65535.0f;
a1508 1

d1520 1
d1522 4
a1525 4
               dstRow[col * 4 + 0] = srcRow[col * 3 + BCOMP];
               dstRow[col * 4 + 1] = srcRow[col * 3 + GCOMP];
               dstRow[col * 4 + 2] = srcRow[col * 3 + RCOMP];
               dstRow[col * 4 + 3] = 0xff;
d1537 3
a1539 1
            (srcType == GL_UNSIGNED_BYTE && littleEndian)) {
a1555 1

d1557 1
d1559 4
a1562 4
               *(GLuint *)(dstRow + col * 4)  = (srcRow[col * 4 + RCOMP] << 16 |
						 srcRow[col * 4 + GCOMP] << 8 |
						 srcRow[col * 4 + BCOMP] << 0 |
						 srcRow[col * 4 + ACOMP] << 24);
d2387 2
d2425 1
a2425 1
                                    GL_UNSIGNED_INT, /* dst type */
d2427 1
a2427 1
                                    (GLfloat) 0xffffff, /* depthScale */
d2448 81
d3064 1
a3064 3
      _mesa_generate_mipmap(ctx, target,
                            &ctx->Texture.Unit[ctx->Texture.CurrentUnit],
                            texObj);
d3148 1
a3148 3
      _mesa_generate_mipmap(ctx, target,
                            &ctx->Texture.Unit[ctx->Texture.CurrentUnit],
                            texObj);
d3222 1
a3222 3
      _mesa_generate_mipmap(ctx, target,
                            &ctx->Texture.Unit[ctx->Texture.CurrentUnit],
                            texObj);
d3268 1
a3268 3
      _mesa_generate_mipmap(ctx, target,
                            &ctx->Texture.Unit[ctx->Texture.CurrentUnit],
                            texObj);
d3321 1
a3321 3
      _mesa_generate_mipmap(ctx, target,
                            &ctx->Texture.Unit[ctx->Texture.CurrentUnit],
                            texObj);
d3374 1
a3374 3
      _mesa_generate_mipmap(ctx, target,
                            &ctx->Texture.Unit[ctx->Texture.CurrentUnit],
                            texObj);
d3448 1
a3448 3
      _mesa_generate_mipmap(ctx, target,
                            &ctx->Texture.Unit[ctx->Texture.CurrentUnit],
                            texObj);
d3558 1
a3558 3
      _mesa_generate_mipmap(ctx, target,
                            &ctx->Texture.Unit[ctx->Texture.CurrentUnit],
                            texObj);
d3786 2
a3787 2
                              const struct gl_texture_object *texObj,
                              const struct gl_texture_image *texImage)
@


1.2
log
@Update to Mesa 7.0.3. tested my oga@@ and johan@@
@
text
@d3 1
a3 1
 * Version:  6.5.1
d5 1
a5 1
 * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
d664 21
a685 1
   GLuint i;
d690 3
d695 15
a709 8
      for (i = 0; i < count; i++) {
 	 COPY_4UBV(tmp, src); 
	 src += srcComponents;      
	 dst[0] = tmp[map[0]];
	 dst[1] = tmp[map[1]];
	 dst[2] = tmp[map[2]];
	 dst[3] = tmp[map[3]];
	 dst += 4;
d713 15
a727 7
      for (i = 0; i < count; i++) {
 	 COPY_4UBV(tmp, src); 
	 src += srcComponents;      
	 dst[0] = tmp[map[0]];
	 dst[1] = tmp[map[1]];
	 dst[2] = tmp[map[2]];
	 dst += 3;
d731 15
a745 6
      for (i = 0; i < count; i++) {
 	 COPY_4UBV(tmp, src); 
	 src += srcComponents;      
	 dst[0] = tmp[map[0]];
	 dst[1] = tmp[map[1]];
	 dst += 2;
d749 15
a763 6
      /* XXX investigate valgrind invalid read when running demos/texenv.c */
      for (i = 0; i < count; i++) {
 	 COPY_4UBV(tmp, src); 
	 src += srcComponents;      
	 dst[0] = tmp[map[0]];
	 dst += 1;
d766 2
d769 1
d771 1
@


1.1
log
@Initial revision
@
text
@d30 1
a30 1
/*
d61 1
d67 1
d70 4
a73 1
static const GLint ZERO = 4, ONE = 5;
d75 7
a81 1
static GLboolean can_swizzle(GLenum logicalBaseFormat)
d90 6
d103 131
d238 3
a240 3
 * \param logicalBaseFormat  the logical format of the texture
 * \param textureBaseFormat  the final texture format
 * \return map[4]  the four mapping values
d243 2
a244 2
compute_component_mapping(GLenum logicalBaseFormat, GLenum textureBaseFormat,
                          GLubyte map[6])
d246 9
d256 1
a256 1
   map[ONE] = ONE;
d258 11
a268 68
   /* compute mapping from dest components back to src components */
   switch (textureBaseFormat) {
   case GL_RGB:
   case GL_RGBA:
      switch (logicalBaseFormat) {
      case GL_LUMINANCE:
         map[0] = map[1] = map[2] = 0;
         if (textureBaseFormat == GL_RGBA)
            map[3] = ONE;
         break;
      case GL_ALPHA:
         ASSERT(textureBaseFormat == GL_RGBA);
         map[0] = map[1] = map[2] = ZERO;
         map[3] = 0;
         break;
      case GL_INTENSITY:
         map[0] = map[1] = map[2] = 0;
         if (textureBaseFormat == GL_RGBA)
            map[3] = 0;
         break;
      case GL_LUMINANCE_ALPHA:
         ASSERT(textureBaseFormat == GL_RGBA);
         map[0] = map[1] = map[2] = 0;
         map[3] = 1;
         break;
      case GL_RGB:
         ASSERT(textureBaseFormat == GL_RGBA);
         map[0] = 0;
         map[1] = 1;
         map[2] = 2;
         map[3] = ONE;
         break;
      case GL_RGBA:
         ASSERT(textureBaseFormat == GL_RGBA);
         map[0] = 0;
         map[1] = 1;
         map[2] = 2;
         map[3] = 3;
         break;
      default:
         _mesa_problem(NULL, "Unexpected logicalBaseFormat");
         map[0] = map[1] = map[2] = map[3] = 0;
      }
      break;
   case GL_LUMINANCE_ALPHA:
      switch (logicalBaseFormat) {
      case GL_LUMINANCE:
         map[0] = 0;
         map[1] = ONE;
         break;
      case GL_ALPHA:
         map[0] = ZERO;
         map[1] = 0;
         break;
      case GL_INTENSITY:
         map[0] = 0;
         map[1] = 0;
         break;
      default:
         _mesa_problem(NULL, "Unexpected logicalBaseFormat");
         map[0] = map[1] = 0;
      }
      break;
   default:
      _mesa_problem(NULL, "Unexpected textureBaseFormat");
      map[0] = map[1] = 0;
      break;
   }   
d401 1
a401 1
                                          (const GLfloat (*)[4]) src,
d655 3
a657 1
 * \param map  the swizzle mapping
d664 1
a664 1
   GLubyte tmp[8];
d701 50
d755 1
d763 6
a768 1
			  const GLubyte *dstmap, GLint dstComponents,
d780 2
a781 1
   GLubyte srcmap[6], map[4];
a782 1

d796 9
a804 1
   compute_component_mapping(srcFormat, GL_RGBA, srcmap);
d807 1
a807 1
      map[i] = srcmap[dstmap[i]];
d809 5
a813 1
   if (srcRowStride == srcWidth * srcComponents &&
d990 52
d1275 3
d1281 1
a1281 2
   const GLuint ui = 1;
   const GLubyte littleEndian = *((const GLubyte *) &ui);
a1282 1
   (void)littleEndian;
a1318 2
#if 0
   /* broken? */
d1320 4
a1323 10
	    !srcPacking->SwapBytes &&
	    srcType == GL_UNSIGNED_BYTE && 
	    dstFormat == &_mesa_texformat_rgba8888 &&
	    littleEndian &&
	    /* Three texture formats involved: srcFormat,
	     * baseInternalFormat and destFormat (GL_RGBA). Only two
	     * may differ. _mesa_swizzle_ubyte_image can't handle two
	     * propagations at once correctly. */
	    (srcFormat == baseInternalFormat ||
	     baseInternalFormat == GL_RGBA) &&
d1325 1
d1328 1
a1328 3
      /* dstmap - how to swizzle from GL_RGBA to dst format:
       *
       * FIXME - add !litteEndian and _rev varients:
d1330 13
a1342 4
      dstmap[3] = 0;
      dstmap[2] = 1;
      dstmap[1] = 2;
      dstmap[0] = 3;
d1346 2
d1350 1
a1350 1
				dstRowStride, dstImageStride,
a1353 1
#endif
d1404 1
a1404 2
   const GLuint ui = 1;
   const GLubyte littleEndian = *((const GLubyte *) &ui);
d1444 2
d1474 1
d1509 1
d1535 4
a1538 10
	    !srcPacking->SwapBytes &&
	    dstFormat == &_mesa_texformat_argb8888 &&
	    srcType == GL_UNSIGNED_BYTE && 
	    littleEndian &&
	    /* Three texture formats involved: srcFormat,
	     * baseInternalFormat and destFormat (GL_RGBA). Only two
	     * may differ. _mesa_swizzle_ubyte_image can't handle two
	     * propagations at once correctly. */
	    (srcFormat == baseInternalFormat ||
	     baseInternalFormat == GL_RGBA) &&
d1543 1
a1543 1
      /* dstmap - how to swizzle from GL_RGBA to dst format:
d1545 15
a1559 4
      dstmap[3] = 3;		/* alpha */
      dstmap[2] = 0;		/* red */
      dstmap[1] = 1;		/* green */
      dstmap[0] = 2;		/* blue */
d1563 3
d1623 1
a1623 2
   const GLuint ui = 1;
   const GLubyte littleEndian = *((const GLubyte *) &ui);
d1668 24
d1748 1
a1748 2
   const GLuint ui = 1;
   const GLubyte littleEndian = *((const GLubyte *) &ui);
d1793 24
d1991 1
a1991 2
   const GLuint ui = 1;
   const GLubyte littleEndian = *((const GLubyte *) &ui);
d2012 32
d2164 29
d2274 1
a2274 2
   const GLuint ui = 1;
   const GLubyte littleEndian = *((const GLubyte *) &ui);
d2529 1
a2529 2
   const GLuint ui = 1;
   const GLubyte littleEndian = *((const GLubyte *) &ui);
d2560 1
a2560 2
   const GLuint ui = 1;
   const GLubyte littleEndian = *((const GLubyte *) &ui);
d2608 1
a2608 2
   const GLuint ui = 1;
   const GLubyte littleEndian = *((const GLubyte *) &ui);
d2726 2
a2727 2
FetchTexelFloatToChan( const struct gl_texture_image *texImage,
                       GLint i, GLint j, GLint k, GLchan *texelOut )
d2751 2
a2752 2
FetchTexelChanToFloat( const struct gl_texture_image *texImage,
                       GLint i, GLint j, GLint k, GLfloat *texelOut )
d2775 2
a2776 2
static void
set_fetch_functions(struct gl_texture_image *texImage, GLuint dims)
d2800 1
a2800 1
      texImage->FetchTexelc = FetchTexelFloatToChan;
d2803 1
a2803 1
      texImage->FetchTexelf = FetchTexelChanToFloat;
d2836 1
a2836 1
   set_fetch_functions(texImage, dims);
a3458 1108
/*
 * Average together two rows of a source image to produce a single new
 * row in the dest image.  It's legal for the two source rows to point
 * to the same data.  The source width must be equal to either the
 * dest width or two times the dest width.
 */
static void
do_row(const struct gl_texture_format *format, GLint srcWidth,
       const GLvoid *srcRowA, const GLvoid *srcRowB,
       GLint dstWidth, GLvoid *dstRow)
{
   const GLuint k0 = (srcWidth == dstWidth) ? 0 : 1;
   const GLuint colStride = (srcWidth == dstWidth) ? 1 : 2;

   /* This assertion is no longer valid with non-power-of-2 textures
   assert(srcWidth == dstWidth || srcWidth == 2 * dstWidth);
   */

   switch (format->MesaFormat) {
   case MESA_FORMAT_RGBA:
      {
         GLuint i, j, k;
         const GLchan (*rowA)[4] = (const GLchan (*)[4]) srcRowA;
         const GLchan (*rowB)[4] = (const GLchan (*)[4]) srcRowB;
         GLchan (*dst)[4] = (GLchan (*)[4]) dstRow;
         for (i = j = 0, k = k0; i < (GLuint) dstWidth;
              i++, j += colStride, k += colStride) {
            dst[i][0] = (rowA[j][0] + rowA[k][0] +
                         rowB[j][0] + rowB[k][0]) / 4;
            dst[i][1] = (rowA[j][1] + rowA[k][1] +
                         rowB[j][1] + rowB[k][1]) / 4;
            dst[i][2] = (rowA[j][2] + rowA[k][2] +
                         rowB[j][2] + rowB[k][2]) / 4;
            dst[i][3] = (rowA[j][3] + rowA[k][3] +
                         rowB[j][3] + rowB[k][3]) / 4;
         }
      }
      return;
   case MESA_FORMAT_RGB:
      {
         GLuint i, j, k;
         const GLchan (*rowA)[3] = (const GLchan (*)[3]) srcRowA;
         const GLchan (*rowB)[3] = (const GLchan (*)[3]) srcRowB;
         GLchan (*dst)[3] = (GLchan (*)[3]) dstRow;
         for (i = j = 0, k = k0; i < (GLuint) dstWidth;
              i++, j += colStride, k += colStride) {
            dst[i][0] = (rowA[j][0] + rowA[k][0] +
                         rowB[j][0] + rowB[k][0]) / 4;
            dst[i][1] = (rowA[j][1] + rowA[k][1] +
                         rowB[j][1] + rowB[k][1]) / 4;
            dst[i][2] = (rowA[j][2] + rowA[k][2] +
                         rowB[j][2] + rowB[k][2]) / 4;
         }
      }
      return;
   case MESA_FORMAT_ALPHA:
   case MESA_FORMAT_LUMINANCE:
   case MESA_FORMAT_INTENSITY:
      {
         GLuint i, j, k;
         const GLchan *rowA = (const GLchan *) srcRowA;
         const GLchan *rowB = (const GLchan *) srcRowB;
         GLchan *dst = (GLchan *) dstRow;
         for (i = j = 0, k = k0; i < (GLuint) dstWidth;
              i++, j += colStride, k += colStride) {
            dst[i] = (rowA[j] + rowA[k] + rowB[j] + rowB[k]) / 4;
         }
      }
      return;
   case MESA_FORMAT_LUMINANCE_ALPHA:
      {
         GLuint i, j, k;
         const GLchan (*rowA)[2] = (const GLchan (*)[2]) srcRowA;
         const GLchan (*rowB)[2] = (const GLchan (*)[2]) srcRowB;
         GLchan (*dst)[2] = (GLchan (*)[2]) dstRow;
         for (i = j = 0, k = k0; i < (GLuint) dstWidth;
              i++, j += colStride, k += colStride) {
            dst[i][0] = (rowA[j][0] + rowA[k][0] +
                         rowB[j][0] + rowB[k][0]) / 4;
            dst[i][1] = (rowA[j][1] + rowA[k][1] +
                         rowB[j][1] + rowB[k][1]) / 4;
         }
      }
      return;
   case MESA_FORMAT_Z32:
      {
         GLuint i, j, k;
         const GLuint *rowA = (const GLuint *) srcRowA;
         const GLuint *rowB = (const GLuint *) srcRowB;
         GLfloat *dst = (GLfloat *) dstRow;
         for (i = j = 0, k = k0; i < (GLuint) dstWidth;
              i++, j += colStride, k += colStride) {
            dst[i] = rowA[j] / 4 + rowA[k] / 4 + rowB[j] / 4 + rowB[k] / 4;
         }
      }
      return;
   case MESA_FORMAT_Z16:
      {
         GLuint i, j, k;
         const GLushort *rowA = (const GLushort *) srcRowA;
         const GLushort *rowB = (const GLushort *) srcRowB;
         GLushort *dst = (GLushort *) dstRow;
         for (i = j = 0, k = k0; i < (GLuint) dstWidth;
              i++, j += colStride, k += colStride) {
            dst[i] = (rowA[j] + rowA[k] + rowB[j] + rowB[k]) / 4;
         }
      }
      return;
   /* Begin hardware formats */
   case MESA_FORMAT_RGBA8888:
   case MESA_FORMAT_RGBA8888_REV:
   case MESA_FORMAT_ARGB8888:
   case MESA_FORMAT_ARGB8888_REV:
#if FEATURE_EXT_texture_sRGB
   case MESA_FORMAT_SRGBA8:
#endif
      {
         GLuint i, j, k;
         const GLubyte (*rowA)[4] = (const GLubyte (*)[4]) srcRowA;
         const GLubyte (*rowB)[4] = (const GLubyte (*)[4]) srcRowB;
         GLubyte (*dst)[4] = (GLubyte (*)[4]) dstRow;
         for (i = j = 0, k = k0; i < (GLuint) dstWidth;
              i++, j += colStride, k += colStride) {
            dst[i][0] = (rowA[j][0] + rowA[k][0] +
                         rowB[j][0] + rowB[k][0]) / 4;
            dst[i][1] = (rowA[j][1] + rowA[k][1] +
                         rowB[j][1] + rowB[k][1]) / 4;
            dst[i][2] = (rowA[j][2] + rowA[k][2] +
                         rowB[j][2] + rowB[k][2]) / 4;
            dst[i][3] = (rowA[j][3] + rowA[k][3] +
                         rowB[j][3] + rowB[k][3]) / 4;
         }
      }
      return;
   case MESA_FORMAT_RGB888:
   case MESA_FORMAT_BGR888:
#if FEATURE_EXT_texture_sRGB
   case MESA_FORMAT_SRGB8:
#endif
      {
         GLuint i, j, k;
         const GLubyte (*rowA)[3] = (const GLubyte (*)[3]) srcRowA;
         const GLubyte (*rowB)[3] = (const GLubyte (*)[3]) srcRowB;
         GLubyte (*dst)[3] = (GLubyte (*)[3]) dstRow;
         for (i = j = 0, k = k0; i < (GLuint) dstWidth;
              i++, j += colStride, k += colStride) {
            dst[i][0] = (rowA[j][0] + rowA[k][0] +
                         rowB[j][0] + rowB[k][0]) / 4;
            dst[i][1] = (rowA[j][1] + rowA[k][1] +
                         rowB[j][1] + rowB[k][1]) / 4;
            dst[i][2] = (rowA[j][2] + rowA[k][2] +
                         rowB[j][2] + rowB[k][2]) / 4;
         }
      }
      return;
   case MESA_FORMAT_RGB565:
   case MESA_FORMAT_RGB565_REV:
      {
         GLuint i, j, k;
         const GLushort *rowA = (const GLushort *) srcRowA;
         const GLushort *rowB = (const GLushort *) srcRowB;
         GLushort *dst = (GLushort *) dstRow;
         for (i = j = 0, k = k0; i < (GLuint) dstWidth;
              i++, j += colStride, k += colStride) {
            const GLint rowAr0 = rowA[j] & 0x1f;
            const GLint rowAr1 = rowA[k] & 0x1f;
            const GLint rowBr0 = rowB[j] & 0x1f;
            const GLint rowBr1 = rowB[k] & 0x1f;
            const GLint rowAg0 = (rowA[j] >> 5) & 0x3f;
            const GLint rowAg1 = (rowA[k] >> 5) & 0x3f;
            const GLint rowBg0 = (rowB[j] >> 5) & 0x3f;
            const GLint rowBg1 = (rowB[k] >> 5) & 0x3f;
            const GLint rowAb0 = (rowA[j] >> 11) & 0x1f;
            const GLint rowAb1 = (rowA[k] >> 11) & 0x1f;
            const GLint rowBb0 = (rowB[j] >> 11) & 0x1f;
            const GLint rowBb1 = (rowB[k] >> 11) & 0x1f;
            const GLint red   = (rowAr0 + rowAr1 + rowBr0 + rowBr1) >> 2;
            const GLint green = (rowAg0 + rowAg1 + rowBg0 + rowBg1) >> 2;
            const GLint blue  = (rowAb0 + rowAb1 + rowBb0 + rowBb1) >> 2;
            dst[i] = (blue << 11) | (green << 5) | red;
         }
      }
      return;
   case MESA_FORMAT_ARGB4444:
   case MESA_FORMAT_ARGB4444_REV:
      {
         GLuint i, j, k;
         const GLushort *rowA = (const GLushort *) srcRowA;
         const GLushort *rowB = (const GLushort *) srcRowB;
         GLushort *dst = (GLushort *) dstRow;
         for (i = j = 0, k = k0; i < (GLuint) dstWidth;
              i++, j += colStride, k += colStride) {
            const GLint rowAr0 = rowA[j] & 0xf;
            const GLint rowAr1 = rowA[k] & 0xf;
            const GLint rowBr0 = rowB[j] & 0xf;
            const GLint rowBr1 = rowB[k] & 0xf;
            const GLint rowAg0 = (rowA[j] >> 4) & 0xf;
            const GLint rowAg1 = (rowA[k] >> 4) & 0xf;
            const GLint rowBg0 = (rowB[j] >> 4) & 0xf;
            const GLint rowBg1 = (rowB[k] >> 4) & 0xf;
            const GLint rowAb0 = (rowA[j] >> 8) & 0xf;
            const GLint rowAb1 = (rowA[k] >> 8) & 0xf;
            const GLint rowBb0 = (rowB[j] >> 8) & 0xf;
            const GLint rowBb1 = (rowB[k] >> 8) & 0xf;
            const GLint rowAa0 = (rowA[j] >> 12) & 0xf;
            const GLint rowAa1 = (rowA[k] >> 12) & 0xf;
            const GLint rowBa0 = (rowB[j] >> 12) & 0xf;
            const GLint rowBa1 = (rowB[k] >> 12) & 0xf;
            const GLint red   = (rowAr0 + rowAr1 + rowBr0 + rowBr1) >> 2;
            const GLint green = (rowAg0 + rowAg1 + rowBg0 + rowBg1) >> 2;
            const GLint blue  = (rowAb0 + rowAb1 + rowBb0 + rowBb1) >> 2;
            const GLint alpha = (rowAa0 + rowAa1 + rowBa0 + rowBa1) >> 2;
            dst[i] = (alpha << 12) | (blue << 8) | (green << 4) | red;
         }
      }
      return;
   case MESA_FORMAT_ARGB1555:
   case MESA_FORMAT_ARGB1555_REV: /* XXX broken? */
      {
         GLuint i, j, k;
         const GLushort *rowA = (const GLushort *) srcRowA;
         const GLushort *rowB = (const GLushort *) srcRowB;
         GLushort *dst = (GLushort *) dstRow;
         for (i = j = 0, k = k0; i < (GLuint) dstWidth;
              i++, j += colStride, k += colStride) {
            const GLint rowAr0 = rowA[j] & 0x1f;
            const GLint rowAr1 = rowA[k] & 0x1f;
            const GLint rowBr0 = rowB[j] & 0x1f;
            const GLint rowBr1 = rowB[k] & 0xf;
            const GLint rowAg0 = (rowA[j] >> 5) & 0x1f;
            const GLint rowAg1 = (rowA[k] >> 5) & 0x1f;
            const GLint rowBg0 = (rowB[j] >> 5) & 0x1f;
            const GLint rowBg1 = (rowB[k] >> 5) & 0x1f;
            const GLint rowAb0 = (rowA[j] >> 10) & 0x1f;
            const GLint rowAb1 = (rowA[k] >> 10) & 0x1f;
            const GLint rowBb0 = (rowB[j] >> 10) & 0x1f;
            const GLint rowBb1 = (rowB[k] >> 10) & 0x1f;
            const GLint rowAa0 = (rowA[j] >> 15) & 0x1;
            const GLint rowAa1 = (rowA[k] >> 15) & 0x1;
            const GLint rowBa0 = (rowB[j] >> 15) & 0x1;
            const GLint rowBa1 = (rowB[k] >> 15) & 0x1;
            const GLint red   = (rowAr0 + rowAr1 + rowBr0 + rowBr1) >> 2;
            const GLint green = (rowAg0 + rowAg1 + rowBg0 + rowBg1) >> 2;
            const GLint blue  = (rowAb0 + rowAb1 + rowBb0 + rowBb1) >> 2;
            const GLint alpha = (rowAa0 + rowAa1 + rowBa0 + rowBa1) >> 2;
            dst[i] = (alpha << 15) | (blue << 10) | (green << 5) | red;
         }
      }
      return;
   case MESA_FORMAT_AL88:
   case MESA_FORMAT_AL88_REV:
#if FEATURE_EXT_texture_sRGB
   case MESA_FORMAT_SLA8:
#endif
      {
         GLuint i, j, k;
         const GLubyte (*rowA)[2] = (const GLubyte (*)[2]) srcRowA;
         const GLubyte (*rowB)[2] = (const GLubyte (*)[2]) srcRowB;
         GLubyte (*dst)[2] = (GLubyte (*)[2]) dstRow;
         for (i = j = 0, k = k0; i < (GLuint) dstWidth;
              i++, j += colStride, k += colStride) {
            dst[i][0] = (rowA[j][0] + rowA[k][0] +
                         rowB[j][0] + rowB[k][0]) >> 2;
            dst[i][1] = (rowA[j][1] + rowA[k][1] +
                         rowB[j][1] + rowB[k][1]) >> 2;
         }
      }
      return;
   case MESA_FORMAT_RGB332:
      {
         GLuint i, j, k;
         const GLubyte *rowA = (const GLubyte *) srcRowA;
         const GLubyte *rowB = (const GLubyte *) srcRowB;
         GLubyte *dst = (GLubyte *) dstRow;
         for (i = j = 0, k = k0; i < (GLuint) dstWidth;
              i++, j += colStride, k += colStride) {
            const GLint rowAr0 = rowA[j] & 0x3;
            const GLint rowAr1 = rowA[k] & 0x3;
            const GLint rowBr0 = rowB[j] & 0x3;
            const GLint rowBr1 = rowB[k] & 0x3;
            const GLint rowAg0 = (rowA[j] >> 2) & 0x7;
            const GLint rowAg1 = (rowA[k] >> 2) & 0x7;
            const GLint rowBg0 = (rowB[j] >> 2) & 0x7;
            const GLint rowBg1 = (rowB[k] >> 2) & 0x7;
            const GLint rowAb0 = (rowA[j] >> 5) & 0x7;
            const GLint rowAb1 = (rowA[k] >> 5) & 0x7;
            const GLint rowBb0 = (rowB[j] >> 5) & 0x7;
            const GLint rowBb1 = (rowB[k] >> 5) & 0x7;
            const GLint red   = (rowAr0 + rowAr1 + rowBr0 + rowBr1) >> 2;
            const GLint green = (rowAg0 + rowAg1 + rowBg0 + rowBg1) >> 2;
            const GLint blue  = (rowAb0 + rowAb1 + rowBb0 + rowBb1) >> 2;
            dst[i] = (blue << 5) | (green << 2) | red;
         }
      }
      return;
   case MESA_FORMAT_A8:
   case MESA_FORMAT_L8:
   case MESA_FORMAT_I8:
   case MESA_FORMAT_CI8:
#if FEATURE_EXT_texture_sRGB
   case MESA_FORMAT_SL8:
#endif
      {
         GLuint i, j, k;
         const GLubyte *rowA = (const GLubyte *) srcRowA;
         const GLubyte *rowB = (const GLubyte *) srcRowB;
         GLubyte *dst = (GLubyte *) dstRow;
         for (i = j = 0, k = k0; i < (GLuint) dstWidth;
              i++, j += colStride, k += colStride) {
            dst[i] = (rowA[j] + rowA[k] + rowB[j] + rowB[k]) >> 2;
         }
      }
      return;
   case MESA_FORMAT_RGBA_FLOAT32:
      {
         GLuint i, j, k;
         const GLfloat (*rowA)[4] = (const GLfloat (*)[4]) srcRowA;
         const GLfloat (*rowB)[4] = (const GLfloat (*)[4]) srcRowB;
         GLfloat (*dst)[4] = (GLfloat (*)[4]) dstRow;
         for (i = j = 0, k = k0; i < (GLuint) dstWidth;
              i++, j += colStride, k += colStride) {
            dst[i][0] = (rowA[j][0] + rowA[k][0] +
                         rowB[j][0] + rowB[k][0]) * 0.25F;
            dst[i][1] = (rowA[j][1] + rowA[k][1] +
                         rowB[j][1] + rowB[k][1]) * 0.25F;
            dst[i][2] = (rowA[j][2] + rowA[k][2] +
                         rowB[j][2] + rowB[k][2]) * 0.25F;
            dst[i][3] = (rowA[j][3] + rowA[k][3] +
                         rowB[j][3] + rowB[k][3]) * 0.25F;
         }
      }
      return;
   case MESA_FORMAT_RGBA_FLOAT16:
      {
         GLuint i, j, k, comp;
         const GLhalfARB (*rowA)[4] = (const GLhalfARB (*)[4]) srcRowA;
         const GLhalfARB (*rowB)[4] = (const GLhalfARB (*)[4]) srcRowB;
         GLhalfARB (*dst)[4] = (GLhalfARB (*)[4]) dstRow;
         for (i = j = 0, k = k0; i < (GLuint) dstWidth;
              i++, j += colStride, k += colStride) {
            for (comp = 0; comp < 4; comp++) {
               GLfloat aj, ak, bj, bk;
               aj = _mesa_half_to_float(rowA[j][comp]);
               ak = _mesa_half_to_float(rowA[k][comp]);
               bj = _mesa_half_to_float(rowB[j][comp]);
               bk = _mesa_half_to_float(rowB[k][comp]);
               dst[i][comp] = _mesa_float_to_half((aj + ak + bj + bk) * 0.25F);
            }
         }
      }
      return;
   case MESA_FORMAT_RGB_FLOAT32:
      {
         GLuint i, j, k;
         const GLfloat (*rowA)[3] = (const GLfloat (*)[3]) srcRowA;
         const GLfloat (*rowB)[3] = (const GLfloat (*)[3]) srcRowB;
         GLfloat (*dst)[3] = (GLfloat (*)[3]) dstRow;
         for (i = j = 0, k = k0; i < (GLuint) dstWidth;
              i++, j += colStride, k += colStride) {
            dst[i][0] = (rowA[j][0] + rowA[k][0] +
                         rowB[j][0] + rowB[k][0]) * 0.25F;
            dst[i][1] = (rowA[j][1] + rowA[k][1] +
                         rowB[j][1] + rowB[k][1]) * 0.25F;
            dst[i][2] = (rowA[j][2] + rowA[k][2] +
                         rowB[j][2] + rowB[k][2]) * 0.25F;
         }
      }
      return;
   case MESA_FORMAT_RGB_FLOAT16:
      {
         GLuint i, j, k, comp;
         const GLhalfARB (*rowA)[3] = (const GLhalfARB (*)[3]) srcRowA;
         const GLhalfARB (*rowB)[3] = (const GLhalfARB (*)[3]) srcRowB;
         GLhalfARB (*dst)[3] = (GLhalfARB (*)[3]) dstRow;
         for (i = j = 0, k = k0; i < (GLuint) dstWidth;
              i++, j += colStride, k += colStride) {
            for (comp = 0; comp < 3; comp++) {
               GLfloat aj, ak, bj, bk;
               aj = _mesa_half_to_float(rowA[j][comp]);
               ak = _mesa_half_to_float(rowA[k][comp]);
               bj = _mesa_half_to_float(rowB[j][comp]);
               bk = _mesa_half_to_float(rowB[k][comp]);
               dst[i][comp] = _mesa_float_to_half((aj + ak + bj + bk) * 0.25F);
            }
         }
      }
      return;
   case MESA_FORMAT_LUMINANCE_ALPHA_FLOAT32:
      {
         GLuint i, j, k;
         const GLfloat (*rowA)[2] = (const GLfloat (*)[2]) srcRowA;
         const GLfloat (*rowB)[2] = (const GLfloat (*)[2]) srcRowB;
         GLfloat (*dst)[2] = (GLfloat (*)[2]) dstRow;
         for (i = j = 0, k = k0; i < (GLuint) dstWidth;
              i++, j += colStride, k += colStride) {
            dst[i][0] = (rowA[j][0] + rowA[k][0] +
                         rowB[j][0] + rowB[k][0]) * 0.25F;
            dst[i][1] = (rowA[j][1] + rowA[k][1] +
                         rowB[j][1] + rowB[k][1]) * 0.25F;
         }
      }
      return;
   case MESA_FORMAT_LUMINANCE_ALPHA_FLOAT16:
      {
         GLuint i, j, k, comp;
         const GLhalfARB (*rowA)[2] = (const GLhalfARB (*)[2]) srcRowA;
         const GLhalfARB (*rowB)[2] = (const GLhalfARB (*)[2]) srcRowB;
         GLhalfARB (*dst)[2] = (GLhalfARB (*)[2]) dstRow;
         for (i = j = 0, k = k0; i < (GLuint) dstWidth;
              i++, j += colStride, k += colStride) {
            for (comp = 0; comp < 2; comp++) {
               GLfloat aj, ak, bj, bk;
               aj = _mesa_half_to_float(rowA[j][comp]);
               ak = _mesa_half_to_float(rowA[k][comp]);
               bj = _mesa_half_to_float(rowB[j][comp]);
               bk = _mesa_half_to_float(rowB[k][comp]);
               dst[i][comp] = _mesa_float_to_half((aj + ak + bj + bk) * 0.25F);
            }
         }
      }
      return;
   case MESA_FORMAT_ALPHA_FLOAT32:
   case MESA_FORMAT_LUMINANCE_FLOAT32:
   case MESA_FORMAT_INTENSITY_FLOAT32:
      {
         GLuint i, j, k;
         const GLfloat *rowA = (const GLfloat *) srcRowA;
         const GLfloat *rowB = (const GLfloat *) srcRowB;
         GLfloat *dst = (GLfloat *) dstRow;
         for (i = j = 0, k = k0; i < (GLuint) dstWidth;
              i++, j += colStride, k += colStride) {
            dst[i] = (rowA[j] + rowA[k] + rowB[j] + rowB[k]) * 0.25F;
         }
      }
      return;
   case MESA_FORMAT_ALPHA_FLOAT16:
   case MESA_FORMAT_LUMINANCE_FLOAT16:
   case MESA_FORMAT_INTENSITY_FLOAT16:
      {
         GLuint i, j, k;
         const GLhalfARB *rowA = (const GLhalfARB *) srcRowA;
         const GLhalfARB *rowB = (const GLhalfARB *) srcRowB;
         GLhalfARB *dst = (GLhalfARB *) dstRow;
         for (i = j = 0, k = k0; i < (GLuint) dstWidth;
              i++, j += colStride, k += colStride) {
            GLfloat aj, ak, bj, bk;
            aj = _mesa_half_to_float(rowA[j]);
            ak = _mesa_half_to_float(rowA[k]);
            bj = _mesa_half_to_float(rowB[j]);
            bk = _mesa_half_to_float(rowB[k]);
            dst[i] = _mesa_float_to_half((aj + ak + bj + bk) * 0.25F);
         }
      }
      return;

   default:
      _mesa_problem(NULL, "bad format in do_row()");
   }
}


/*
 * These functions generate a 1/2-size mipmap image from a source image.
 * Texture borders are handled by copying or averaging the source image's
 * border texels, depending on the scale-down factor.
 */

static void
make_1d_mipmap(const struct gl_texture_format *format, GLint border,
               GLint srcWidth, const GLubyte *srcPtr,
               GLint dstWidth, GLubyte *dstPtr)
{
   const GLint bpt = format->TexelBytes;
   const GLubyte *src;
   GLubyte *dst;

   /* skip the border pixel, if any */
   src = srcPtr + border * bpt;
   dst = dstPtr + border * bpt;

   /* we just duplicate the input row, kind of hack, saves code */
   do_row(format, srcWidth - 2 * border, src, src,
          dstWidth - 2 * border, dst);

   if (border) {
      /* copy left-most pixel from source */
      MEMCPY(dstPtr, srcPtr, bpt);
      /* copy right-most pixel from source */
      MEMCPY(dstPtr + (dstWidth - 1) * bpt,
             srcPtr + (srcWidth - 1) * bpt,
             bpt);
   }
}


/**
 * XXX need to use the tex image's row stride!
 */
static void
make_2d_mipmap(const struct gl_texture_format *format, GLint border,
               GLint srcWidth, GLint srcHeight, const GLubyte *srcPtr,
               GLint dstWidth, GLint dstHeight, GLubyte *dstPtr)
{
   const GLint bpt = format->TexelBytes;
   const GLint srcWidthNB = srcWidth - 2 * border;  /* sizes w/out border */
   const GLint dstWidthNB = dstWidth - 2 * border;
   const GLint dstHeightNB = dstHeight - 2 * border;
   const GLint srcRowStride = bpt * srcWidth;
   const GLint dstRowStride = bpt * dstWidth;
   const GLubyte *srcA, *srcB;
   GLubyte *dst;
   GLint row;

   /* Compute src and dst pointers, skipping any border */
   srcA = srcPtr + border * ((srcWidth + 1) * bpt);
   if (srcHeight > 1)
      srcB = srcA + srcRowStride;
   else
      srcB = srcA;
   dst = dstPtr + border * ((dstWidth + 1) * bpt);

   for (row = 0; row < dstHeightNB; row++) {
      do_row(format, srcWidthNB, srcA, srcB,
             dstWidthNB, dst);
      srcA += 2 * srcRowStride;
      srcB += 2 * srcRowStride;
      dst += dstRowStride;
   }

   /* This is ugly but probably won't be used much */
   if (border > 0) {
      /* fill in dest border */
      /* lower-left border pixel */
      MEMCPY(dstPtr, srcPtr, bpt);
      /* lower-right border pixel */
      MEMCPY(dstPtr + (dstWidth - 1) * bpt,
             srcPtr + (srcWidth - 1) * bpt, bpt);
      /* upper-left border pixel */
      MEMCPY(dstPtr + dstWidth * (dstHeight - 1) * bpt,
             srcPtr + srcWidth * (srcHeight - 1) * bpt, bpt);
      /* upper-right border pixel */
      MEMCPY(dstPtr + (dstWidth * dstHeight - 1) * bpt,
             srcPtr + (srcWidth * srcHeight - 1) * bpt, bpt);
      /* lower border */
      do_row(format, srcWidthNB,
             srcPtr + bpt,
             srcPtr + bpt,
             dstWidthNB, dstPtr + bpt);
      /* upper border */
      do_row(format, srcWidthNB,
             srcPtr + (srcWidth * (srcHeight - 1) + 1) * bpt,
             srcPtr + (srcWidth * (srcHeight - 1) + 1) * bpt,
             dstWidthNB,
             dstPtr + (dstWidth * (dstHeight - 1) + 1) * bpt);
      /* left and right borders */
      if (srcHeight == dstHeight) {
         /* copy border pixel from src to dst */
         for (row = 1; row < srcHeight; row++) {
            MEMCPY(dstPtr + dstWidth * row * bpt,
                   srcPtr + srcWidth * row * bpt, bpt);
            MEMCPY(dstPtr + (dstWidth * row + dstWidth - 1) * bpt,
                   srcPtr + (srcWidth * row + srcWidth - 1) * bpt, bpt);
         }
      }
      else {
         /* average two src pixels each dest pixel */
         for (row = 0; row < dstHeightNB; row += 2) {
            do_row(format, 1,
                   srcPtr + (srcWidth * (row * 2 + 1)) * bpt,
                   srcPtr + (srcWidth * (row * 2 + 2)) * bpt,
                   1, dstPtr + (dstWidth * row + 1) * bpt);
            do_row(format, 1,
                   srcPtr + (srcWidth * (row * 2 + 1) + srcWidth - 1) * bpt,
                   srcPtr + (srcWidth * (row * 2 + 2) + srcWidth - 1) * bpt,
                   1, dstPtr + (dstWidth * row + 1 + dstWidth - 1) * bpt);
         }
      }
   }
}


static void
make_3d_mipmap(const struct gl_texture_format *format, GLint border,
               GLint srcWidth, GLint srcHeight, GLint srcDepth,
               const GLubyte *srcPtr,
               GLint dstWidth, GLint dstHeight, GLint dstDepth,
               GLubyte *dstPtr)
{
   const GLint bpt = format->TexelBytes;
   const GLint srcWidthNB = srcWidth - 2 * border;  /* sizes w/out border */
   const GLint srcDepthNB = srcDepth - 2 * border;
   const GLint dstWidthNB = dstWidth - 2 * border;
   const GLint dstHeightNB = dstHeight - 2 * border;
   const GLint dstDepthNB = dstDepth - 2 * border;
   GLvoid *tmpRowA, *tmpRowB;
   GLint img, row;
   GLint bytesPerSrcImage, bytesPerDstImage;
   GLint bytesPerSrcRow, bytesPerDstRow;
   GLint srcImageOffset, srcRowOffset;

   (void) srcDepthNB; /* silence warnings */

   /* Need two temporary row buffers */
   tmpRowA = _mesa_malloc(srcWidth * bpt);
   if (!tmpRowA)
      return;
   tmpRowB = _mesa_malloc(srcWidth * bpt);
   if (!tmpRowB) {
      _mesa_free(tmpRowA);
      return;
   }

   bytesPerSrcImage = srcWidth * srcHeight * bpt;
   bytesPerDstImage = dstWidth * dstHeight * bpt;

   bytesPerSrcRow = srcWidth * bpt;
   bytesPerDstRow = dstWidth * bpt;

   /* Offset between adjacent src images to be averaged together */
   srcImageOffset = (srcDepth == dstDepth) ? 0 : bytesPerSrcImage;

   /* Offset between adjacent src rows to be averaged together */
   srcRowOffset = (srcHeight == dstHeight) ? 0 : srcWidth * bpt;

   /*
    * Need to average together up to 8 src pixels for each dest pixel.
    * Break that down into 3 operations:
    *   1. take two rows from source image and average them together.
    *   2. take two rows from next source image and average them together.
    *   3. take the two averaged rows and average them for the final dst row.
    */

   /*
   _mesa_printf("mip3d %d x %d x %d  ->  %d x %d x %d\n",
          srcWidth, srcHeight, srcDepth, dstWidth, dstHeight, dstDepth);
   */

   for (img = 0; img < dstDepthNB; img++) {
      /* first source image pointer, skipping border */
      const GLubyte *imgSrcA = srcPtr
         + (bytesPerSrcImage + bytesPerSrcRow + border) * bpt * border
         + img * (bytesPerSrcImage + srcImageOffset);
      /* second source image pointer, skipping border */
      const GLubyte *imgSrcB = imgSrcA + srcImageOffset;
      /* address of the dest image, skipping border */
      GLubyte *imgDst = dstPtr
         + (bytesPerDstImage + bytesPerDstRow + border) * bpt * border
         + img * bytesPerDstImage;

      /* setup the four source row pointers and the dest row pointer */
      const GLubyte *srcImgARowA = imgSrcA;
      const GLubyte *srcImgARowB = imgSrcA + srcRowOffset;
      const GLubyte *srcImgBRowA = imgSrcB;
      const GLubyte *srcImgBRowB = imgSrcB + srcRowOffset;
      GLubyte *dstImgRow = imgDst;

      for (row = 0; row < dstHeightNB; row++) {
         /* Average together two rows from first src image */
         do_row(format, srcWidthNB, srcImgARowA, srcImgARowB,
                srcWidthNB, tmpRowA);
         /* Average together two rows from second src image */
         do_row(format, srcWidthNB, srcImgBRowA, srcImgBRowB,
                srcWidthNB, tmpRowB);
         /* Average together the temp rows to make the final row */
         do_row(format, srcWidthNB, tmpRowA, tmpRowB,
                dstWidthNB, dstImgRow);
         /* advance to next rows */
         srcImgARowA += bytesPerSrcRow + srcRowOffset;
         srcImgARowB += bytesPerSrcRow + srcRowOffset;
         srcImgBRowA += bytesPerSrcRow + srcRowOffset;
         srcImgBRowB += bytesPerSrcRow + srcRowOffset;
         dstImgRow += bytesPerDstRow;
      }
   }

   _mesa_free(tmpRowA);
   _mesa_free(tmpRowB);

   /* Luckily we can leverage the make_2d_mipmap() function here! */
   if (border > 0) {
      /* do front border image */
      make_2d_mipmap(format, 1, srcWidth, srcHeight, srcPtr,
                     dstWidth, dstHeight, dstPtr);
      /* do back border image */
      make_2d_mipmap(format, 1, srcWidth, srcHeight,
                     srcPtr + bytesPerSrcImage * (srcDepth - 1),
                     dstWidth, dstHeight,
                     dstPtr + bytesPerDstImage * (dstDepth - 1));
      /* do four remaining border edges that span the image slices */
      if (srcDepth == dstDepth) {
         /* just copy border pixels from src to dst */
         for (img = 0; img < dstDepthNB; img++) {
            const GLubyte *src;
            GLubyte *dst;

            /* do border along [img][row=0][col=0] */
            src = srcPtr + (img + 1) * bytesPerSrcImage;
            dst = dstPtr + (img + 1) * bytesPerDstImage;
            MEMCPY(dst, src, bpt);

            /* do border along [img][row=dstHeight-1][col=0] */
            src = srcPtr + (img * 2 + 1) * bytesPerSrcImage
                         + (srcHeight - 1) * bytesPerSrcRow;
            dst = dstPtr + (img + 1) * bytesPerDstImage
                         + (dstHeight - 1) * bytesPerDstRow;
            MEMCPY(dst, src, bpt);

            /* do border along [img][row=0][col=dstWidth-1] */
            src = srcPtr + (img * 2 + 1) * bytesPerSrcImage
                         + (srcWidth - 1) * bpt;
            dst = dstPtr + (img + 1) * bytesPerDstImage
                         + (dstWidth - 1) * bpt;
            MEMCPY(dst, src, bpt);

            /* do border along [img][row=dstHeight-1][col=dstWidth-1] */
            src = srcPtr + (img * 2 + 1) * bytesPerSrcImage
                         + (bytesPerSrcImage - bpt);
            dst = dstPtr + (img + 1) * bytesPerDstImage
                         + (bytesPerDstImage - bpt);
            MEMCPY(dst, src, bpt);
         }
      }
      else {
         /* average border pixels from adjacent src image pairs */
         ASSERT(srcDepthNB == 2 * dstDepthNB);
         for (img = 0; img < dstDepthNB; img++) {
            const GLubyte *src;
            GLubyte *dst;

            /* do border along [img][row=0][col=0] */
            src = srcPtr + (img * 2 + 1) * bytesPerSrcImage;
            dst = dstPtr + (img + 1) * bytesPerDstImage;
            do_row(format, 1, src, src + srcImageOffset, 1, dst);

            /* do border along [img][row=dstHeight-1][col=0] */
            src = srcPtr + (img * 2 + 1) * bytesPerSrcImage
                         + (srcHeight - 1) * bytesPerSrcRow;
            dst = dstPtr + (img + 1) * bytesPerDstImage
                         + (dstHeight - 1) * bytesPerDstRow;
            do_row(format, 1, src, src + srcImageOffset, 1, dst);

            /* do border along [img][row=0][col=dstWidth-1] */
            src = srcPtr + (img * 2 + 1) * bytesPerSrcImage
                         + (srcWidth - 1) * bpt;
            dst = dstPtr + (img + 1) * bytesPerDstImage
                         + (dstWidth - 1) * bpt;
            do_row(format, 1, src, src + srcImageOffset, 1, dst);

            /* do border along [img][row=dstHeight-1][col=dstWidth-1] */
            src = srcPtr + (img * 2 + 1) * bytesPerSrcImage
                         + (bytesPerSrcImage - bpt);
            dst = dstPtr + (img + 1) * bytesPerDstImage
                         + (bytesPerDstImage - bpt);
            do_row(format, 1, src, src + srcImageOffset, 1, dst);
         }
      }
   }
}


/**
 * For GL_SGIX_generate_mipmap:
 * Generate a complete set of mipmaps from texObj's base-level image.
 * Stop at texObj's MaxLevel or when we get to the 1x1 texture.
 */
void
_mesa_generate_mipmap(GLcontext *ctx, GLenum target,
                      const struct gl_texture_unit *texUnit,
                      struct gl_texture_object *texObj)
{
   const struct gl_texture_image *srcImage;
   const struct gl_texture_format *convertFormat;
   const GLubyte *srcData = NULL;
   GLubyte *dstData = NULL;
   GLint level, maxLevels;

   ASSERT(texObj);
   /* XXX choose cube map face here??? */
   srcImage = texObj->Image[0][texObj->BaseLevel];
   ASSERT(srcImage);

   maxLevels = _mesa_max_texture_levels(ctx, texObj->Target);
   ASSERT(maxLevels > 0);  /* bad target */

   /* Find convertFormat - the format that do_row() will process */
   if (srcImage->IsCompressed) {
      /* setup for compressed textures */
      GLuint row;
      GLint  components, size;
      GLchan *dst;

      assert(texObj->Target == GL_TEXTURE_2D);

      if (srcImage->_BaseFormat == GL_RGB) {
         convertFormat = &_mesa_texformat_rgb;
         components = 3;
      }
      else if (srcImage->_BaseFormat == GL_RGBA) {
         convertFormat = &_mesa_texformat_rgba;
         components = 4;
      }
      else {
         _mesa_problem(ctx, "bad srcImage->_BaseFormat in _mesa_generate_mipmaps");
         return;
      }

      /* allocate storage for uncompressed GL_RGB or GL_RGBA images */
      size = _mesa_bytes_per_pixel(srcImage->_BaseFormat, CHAN_TYPE)
         * srcImage->Width * srcImage->Height * srcImage->Depth + 20;
      /* 20 extra bytes, just be safe when calling last FetchTexel */
      srcData = (GLubyte *) _mesa_malloc(size);
      if (!srcData) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "generate mipmaps");
         return;
      }
      dstData = (GLubyte *) _mesa_malloc(size / 2);  /* 1/4 would probably be OK */
      if (!dstData) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "generate mipmaps");
         _mesa_free((void *) srcData);
         return;
      }

      /* decompress base image here */
      dst = (GLchan *) srcData;
      for (row = 0; row < srcImage->Height; row++) {
         GLuint col;
         for (col = 0; col < srcImage->Width; col++) {
            srcImage->FetchTexelc(srcImage, col, row, 0, dst);
            dst += components;
         }
      }
   }
   else {
      /* uncompressed */
      convertFormat = srcImage->TexFormat;
   }

   for (level = texObj->BaseLevel; level < texObj->MaxLevel
           && level < maxLevels - 1; level++) {
      /* generate image[level+1] from image[level] */
      const struct gl_texture_image *srcImage;
      struct gl_texture_image *dstImage;
      GLint srcWidth, srcHeight, srcDepth;
      GLint dstWidth, dstHeight, dstDepth;
      GLint border, bytesPerTexel;

      /* get src image parameters */
      srcImage = _mesa_select_tex_image(ctx, texUnit, target, level);
      ASSERT(srcImage);
      srcWidth = srcImage->Width;
      srcHeight = srcImage->Height;
      srcDepth = srcImage->Depth;
      border = srcImage->Border;

      /* compute next (level+1) image size */
      if (srcWidth - 2 * border > 1) {
         dstWidth = (srcWidth - 2 * border) / 2 + 2 * border;
      }
      else {
         dstWidth = srcWidth; /* can't go smaller */
      }
      if (srcHeight - 2 * border > 1) {
         dstHeight = (srcHeight - 2 * border) / 2 + 2 * border;
      }
      else {
         dstHeight = srcHeight; /* can't go smaller */
      }
      if (srcDepth - 2 * border > 1) {
         dstDepth = (srcDepth - 2 * border) / 2 + 2 * border;
      }
      else {
         dstDepth = srcDepth; /* can't go smaller */
      }

      if (dstWidth == srcWidth &&
          dstHeight == srcHeight &&
          dstDepth == srcDepth) {
         /* all done */
         if (srcImage->IsCompressed) {
            _mesa_free((void *) srcData);
            _mesa_free(dstData);
         }
         return;
      }

      /* get dest gl_texture_image */
      dstImage = _mesa_get_tex_image(ctx, texUnit, target, level + 1);
      if (!dstImage) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "generating mipmaps");
         return;
      }

      /* Free old image data */
      if (dstImage->Data)
         ctx->Driver.FreeTexImageData(ctx, dstImage);

      /* initialize new image */
      _mesa_init_teximage_fields(ctx, target, dstImage, dstWidth, dstHeight,
                                 dstDepth, border, srcImage->InternalFormat);
      dstImage->DriverData = NULL;
      dstImage->TexFormat = srcImage->TexFormat;
      dstImage->FetchTexelc = srcImage->FetchTexelc;
      dstImage->FetchTexelf = srcImage->FetchTexelf;
      dstImage->IsCompressed = srcImage->IsCompressed;
      if (dstImage->IsCompressed) {
         dstImage->CompressedSize
            = ctx->Driver.CompressedTextureSize(ctx, dstImage->Width,
                                              dstImage->Height,
                                              dstImage->Depth,
                                              dstImage->TexFormat->MesaFormat);
         ASSERT(dstImage->CompressedSize > 0);
      }

      ASSERT(dstImage->TexFormat);
      ASSERT(dstImage->FetchTexelc);
      ASSERT(dstImage->FetchTexelf);

      /* Alloc new teximage data buffer.
       * Setup src and dest data pointers.
       */
      if (dstImage->IsCompressed) {
         dstImage->Data = _mesa_alloc_texmemory(dstImage->CompressedSize);
         if (!dstImage->Data) {
            _mesa_error(ctx, GL_OUT_OF_MEMORY, "generating mipmaps");
            return;
         }
         /* srcData and dstData are already set */
         ASSERT(srcData);
         ASSERT(dstData);
      }
      else {
         bytesPerTexel = dstImage->TexFormat->TexelBytes;
         ASSERT(dstWidth * dstHeight * dstDepth * bytesPerTexel > 0);
         dstImage->Data = _mesa_alloc_texmemory(dstWidth * dstHeight
                                                * dstDepth * bytesPerTexel);
         if (!dstImage->Data) {
            _mesa_error(ctx, GL_OUT_OF_MEMORY, "generating mipmaps");
            return;
         }
         srcData = (const GLubyte *) srcImage->Data;
         dstData = (GLubyte *) dstImage->Data;
      }

      /*
       * We use simple 2x2 averaging to compute the next mipmap level.
       */
      switch (target) {
         case GL_TEXTURE_1D:
            make_1d_mipmap(convertFormat, border,
                           srcWidth, srcData,
                           dstWidth, dstData);
            break;
         case GL_TEXTURE_2D:
         case GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB:
         case GL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB:
         case GL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB:
         case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB:
         case GL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB:
         case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB:
            make_2d_mipmap(convertFormat, border,
                           srcWidth, srcHeight, srcData,
                           dstWidth, dstHeight, dstData);
            break;
         case GL_TEXTURE_3D:
            make_3d_mipmap(convertFormat, border,
                           srcWidth, srcHeight, srcDepth, srcData,
                           dstWidth, dstHeight, dstDepth, dstData);
            break;
         case GL_TEXTURE_RECTANGLE_NV:
            /* no mipmaps, do nothing */
            break;
         default:
            _mesa_problem(ctx, "bad dimensions in _mesa_generate_mipmaps");
            return;
      }

      if (dstImage->IsCompressed) {
         GLubyte *temp;
         /* compress image from dstData into dstImage->Data */
         const GLenum srcFormat = convertFormat->BaseFormat;
         GLint dstRowStride
            = _mesa_compressed_row_stride(dstImage->TexFormat->MesaFormat, dstWidth);
         ASSERT(srcFormat == GL_RGB || srcFormat == GL_RGBA);
         dstImage->TexFormat->StoreImage(ctx, 2, dstImage->_BaseFormat,
                                         dstImage->TexFormat,
                                         dstImage->Data,
                                         0, 0, 0, /* dstX/Y/Zoffset */
                                         dstRowStride, 0, /* strides */
                                         dstWidth, dstHeight, 1, /* size */
                                         srcFormat, CHAN_TYPE,
                                         dstData, /* src data, actually */
                                         &ctx->DefaultPacking);
         /* swap src and dest pointers */
         temp = (GLubyte *) srcData;
         srcData = dstData;
         dstData = temp;
      }

   } /* loop over mipmap levels */
}


/**
 * Helper function for drivers which need to rescale texture images to
 * certain aspect ratios.
 * Nearest filtering only (for broken hardware that can't support
 * all aspect ratios).  This can be made a lot faster, but I don't
 * really care enough...
 */
void
_mesa_rescale_teximage2d (GLuint bytesPerPixel,
			  GLuint srcStrideInPixels,
			  GLuint dstRowStride,
			  GLint srcWidth, GLint srcHeight,
			  GLint dstWidth, GLint dstHeight,
			  const GLvoid *srcImage, GLvoid *dstImage)
{
   GLint row, col;

#define INNER_LOOP( TYPE, HOP, WOP )					\
   for ( row = 0 ; row < dstHeight ; row++ ) {				\
      GLint srcRow = row HOP hScale;					\
      for ( col = 0 ; col < dstWidth ; col++ ) {			\
	 GLint srcCol = col WOP wScale;					\
	 dst[col] = src[srcRow * srcStrideInPixels + srcCol];		\
      }									\
      dst = (TYPE *) ((GLubyte *) dst + dstRowStride);			\
   }									\

#define RESCALE_IMAGE( TYPE )						\
do {									\
   const TYPE *src = (const TYPE *)srcImage;				\
   TYPE *dst = (TYPE *)dstImage;					\
									\
   if ( srcHeight < dstHeight ) {					\
      const GLint hScale = dstHeight / srcHeight;			\
      if ( srcWidth < dstWidth ) {					\
	 const GLint wScale = dstWidth / srcWidth;			\
	 INNER_LOOP( TYPE, /, / );					\
      }									\
      else {								\
	 const GLint wScale = srcWidth / dstWidth;			\
	 INNER_LOOP( TYPE, /, * );					\
      }									\
   }									\
   else {								\
      const GLint hScale = srcHeight / dstHeight;			\
      if ( srcWidth < dstWidth ) {					\
	 const GLint wScale = dstWidth / srcWidth;			\
	 INNER_LOOP( TYPE, *, / );					\
      }									\
      else {								\
	 const GLint wScale = srcWidth / dstWidth;			\
	 INNER_LOOP( TYPE, *, * );					\
      }									\
   }									\
} while (0)

   switch ( bytesPerPixel ) {
   case 4:
      RESCALE_IMAGE( GLuint );
      break;

   case 2:
      RESCALE_IMAGE( GLushort );
      break;

   case 1:
      RESCALE_IMAGE( GLubyte );
      break;
   default:
      _mesa_problem(NULL,"unexpected bytes/pixel in _mesa_rescale_teximage2d");
   }
}


/**
 * Upscale an image by replication, not (typical) stretching.
 * We use this when the image width or height is less than a
 * certain size (4, 8) and we need to upscale an image.
 */
void
_mesa_upscale_teximage2d (GLsizei inWidth, GLsizei inHeight,
                          GLsizei outWidth, GLsizei outHeight,
                          GLint comps, const GLchan *src, GLint srcRowStride,
                          GLchan *dest )
{
   GLint i, j, k;

   ASSERT(outWidth >= inWidth);
   ASSERT(outHeight >= inHeight);
#if 0
   ASSERT(inWidth == 1 || inWidth == 2 || inHeight == 1 || inHeight == 2);
   ASSERT((outWidth & 3) == 0);
   ASSERT((outHeight & 3) == 0);
#endif

   for (i = 0; i < outHeight; i++) {
      const GLint ii = i % inHeight;
      for (j = 0; j < outWidth; j++) {
         const GLint jj = j % inWidth;
         for (k = 0; k < comps; k++) {
            dest[(i * outWidth + j) * comps + k]
               = src[ii * srcRowStride + jj * comps + k];
         }
      }
   }
}
d3612 19
d3632 3
a3634 4
               _mesa_pack_rgba_span_float(ctx, width,
                                          (const GLfloat (*)[4]) rgba,
                                          format, type, dest, &ctx->Pack,
                                          0 /* no image transfer */);
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d30 1
a30 1
/**
a60 1
#include "mipmap.h"
a65 1
#include "enums.h"
d68 1
a68 4
enum {
   ZERO = 4, 
   ONE = 5
};
d70 1
a70 7

/**
 * Return GL_TRUE if the given image format is one that be converted
 * to another format by swizzling.
 */
static GLboolean
can_swizzle(GLenum logicalBaseFormat)
a78 6
   case GL_RED:
   case GL_GREEN:
   case GL_BLUE:
   case GL_BGR:
   case GL_BGRA:
   case GL_ABGR_EXT:
a85 131

enum {
   IDX_LUMINANCE = 0,
   IDX_ALPHA,
   IDX_INTENSITY,
   IDX_LUMINANCE_ALPHA,
   IDX_RGB,
   IDX_RGBA,
   IDX_RED,
   IDX_GREEN,
   IDX_BLUE,
   IDX_BGR,
   IDX_BGRA,
   IDX_ABGR,
   MAX_IDX
};

#define MAP1(x)       MAP4(x, ZERO, ZERO, ZERO)
#define MAP2(x,y)     MAP4(x, y, ZERO, ZERO)
#define MAP3(x,y,z)   MAP4(x, y, z, ZERO)
#define MAP4(x,y,z,w) { x, y, z, w, ZERO, ONE }


static const struct {
   GLubyte format_idx;
   GLubyte to_rgba[6];
   GLubyte from_rgba[6];
} mappings[MAX_IDX] = 
{
   {
      IDX_LUMINANCE,
      MAP4(0,0,0,ONE),
      MAP1(0)
   },

   {
      IDX_ALPHA,
      MAP4(ZERO, ZERO, ZERO, 0),
      MAP1(3)
   },

   {
      IDX_INTENSITY,
      MAP4(0, 0, 0, 0),
      MAP1(0),
   },

   {
      IDX_LUMINANCE_ALPHA,
      MAP4(0,0,0,1),
      MAP2(0,3)
   },

   {
      IDX_RGB,
      MAP4(0,1,2,ONE),
      MAP3(0,1,2)
   },

   {
      IDX_RGBA,
      MAP4(0,1,2,3),
      MAP4(0,1,2,3),
   },


   {
      IDX_RED,
      MAP4(0, ZERO, ZERO, ONE),
      MAP1(0),
   },

   {
      IDX_GREEN,
      MAP4(ZERO, 0, ZERO, ONE),
      MAP1(1),
   },

   {
      IDX_BLUE,
      MAP4(ZERO, ZERO, 0, ONE),
      MAP1(2),
   },

   {
      IDX_BGR,
      MAP4(2,1,0,ONE),
      MAP3(2,1,0)
   },

   {
      IDX_BGRA,
      MAP4(2,1,0,3),
      MAP4(2,1,0,3)
   },

   {
      IDX_ABGR,
      MAP4(3,2,1,0),
      MAP4(3,2,1,0)
   },
};



/**
 * Convert a GL image format enum to an IDX_* value (see above).
 */
static int
get_map_idx(GLenum value)
{
   switch (value) {
   case GL_LUMINANCE: return IDX_LUMINANCE;
   case GL_ALPHA: return IDX_ALPHA;
   case GL_INTENSITY: return IDX_INTENSITY;
   case GL_LUMINANCE_ALPHA: return IDX_LUMINANCE_ALPHA;
   case GL_RGB: return IDX_RGB;
   case GL_RGBA: return IDX_RGBA;
   case GL_RED: return IDX_RED;
   case GL_GREEN: return IDX_GREEN;
   case GL_BLUE: return IDX_BLUE;
   case GL_BGR: return IDX_BGR;
   case GL_BGRA: return IDX_BGRA;
   case GL_ABGR_EXT: return IDX_ABGR;
   default:
      _mesa_problem(NULL, "Unexpected inFormat");
      return 0;
   }
}   


d90 3
a92 3
 * \param inFormat  the incoming format of the texture
 * \param outFormat  the final texture format
 * \return map[6]  a full 6-component map
d95 2
a96 2
compute_component_mapping(GLenum inFormat, GLenum outFormat, 
			  GLubyte *map)
a97 9
   const int inFmt = get_map_idx(inFormat);
   const int outFmt = get_map_idx(outFormat);
   const GLubyte *in2rgba = mappings[inFmt].to_rgba;
   const GLubyte *rgba2out = mappings[outFmt].from_rgba;
   int i;
   
   for (i = 0; i < 4; i++)
      map[i] = in2rgba[rgba2out[i]];

d99 1
a99 1
   map[ONE] = ONE;   
d101 68
a168 11
/*
   _mesa_printf("from %x/%s to %x/%s map %d %d %d %d %d %d\n",
		inFormat, _mesa_lookup_enum_by_nr(inFormat),
		outFormat, _mesa_lookup_enum_by_nr(outFormat),
		map[0], 
		map[1], 
		map[2], 
		map[3], 
		map[4], 
		map[5]); 
*/
d301 1
a301 1
                                          (GLfloat (*)[4]) src,
d555 1
a555 3
 * \param map  the swizzle mapping.  map[X] says where to find the X component
 *             in the source image's pixels.  For example, if the source image
 *             is GL_BGRA and X = red, map[0] yields 2.
d562 1
a562 1
   GLubyte tmp[6];
a598 9
   case 1:
      /* XXX investigate valgrind invalid read when running demos/texenv.c */
      for (i = 0; i < count; i++) {
 	 COPY_4UBV(tmp, src); 
	 src += srcComponents;      
	 dst[0] = tmp[map[0]];
	 dst += 1;
      }
      break;
a602 42
static const GLubyte map_identity[6] = { 0, 1, 2, 3, ZERO, ONE };
static const GLubyte map_3210[6] = { 3, 2, 1, 0, ZERO, ONE };

/* Deal with the _REV input types:
 */
static const GLubyte *
type_mapping( GLenum srcType )
{
   switch (srcType) {
   case GL_UNSIGNED_BYTE:
      return map_identity;
   case GL_UNSIGNED_INT_8_8_8_8:
      return _mesa_little_endian() ? map_3210 : map_identity;
   case GL_UNSIGNED_INT_8_8_8_8_REV:
      return _mesa_little_endian() ? map_identity : map_3210;
   default:
      return NULL;
   }
}

/* Mapping required if input type is 
 */
static const GLubyte *
byteswap_mapping( GLboolean swapBytes,
		  GLenum srcType )
{
   if (!swapBytes) 
      return map_identity;

   switch (srcType) {
   case GL_UNSIGNED_BYTE:
      return map_identity;
   case GL_UNSIGNED_INT_8_8_8_8:
   case GL_UNSIGNED_INT_8_8_8_8_REV:
      return map_3210;
   default:
      return NULL;
   }
}



d610 1
a610 6
			  GLenum srcType,

			  GLenum baseInternalFormat,

			  const GLubyte *rgba2dst,
			  GLuint dstComponents,
d622 1
a622 2
   const GLubyte *srctype2ubyte, *swap;
   GLubyte map[4], src2base[6], base2rgba[6];
d624 1
d638 1
a638 9
   /* Translate from src->baseInternal->GL_RGBA->dst.  This will
    * correctly deal with RGBA->RGB->RGBA conversions where the final
    * A value must be 0xff regardless of the incoming alpha values.
    */
   compute_component_mapping(srcFormat, baseInternalFormat, src2base);
   compute_component_mapping(baseInternalFormat, GL_RGBA, base2rgba);
   swap = byteswap_mapping(srcPacking->SwapBytes, srcType);
   srctype2ubyte = type_mapping(srcType);

d641 1
a641 3
      map[i] = srctype2ubyte[swap[src2base[base2rgba[rgba2dst[i]]]]];

/*    _mesa_printf("map %d %d %d %d\n", map[0], map[1], map[2], map[3]);  */
a819 52
   else if (!ctx->_ImageTransferState &&
	    CHAN_TYPE == GL_UNSIGNED_BYTE &&
	    (srcType == GL_UNSIGNED_BYTE ||
	     srcType == GL_UNSIGNED_INT_8_8_8_8 ||
	     srcType == GL_UNSIGNED_INT_8_8_8_8_REV) &&
	    can_swizzle(baseInternalFormat) &&
	    can_swizzle(srcFormat)) {

      const GLubyte *dstmap;
      GLuint components;

      /* dstmap - how to swizzle from RGBA to dst format:
       */
      if (dstFormat == &_mesa_texformat_rgba) {
	 dstmap = mappings[IDX_RGBA].from_rgba;
	 components = 4;
      }
      else if (dstFormat == &_mesa_texformat_rgb) {
	 dstmap = mappings[IDX_RGB].from_rgba;
	 components = 3;
      }
      else if (dstFormat == &_mesa_texformat_alpha) {
	 dstmap = mappings[IDX_ALPHA].from_rgba;
	 components = 1;
      }
      else if (dstFormat == &_mesa_texformat_luminance) {
	 dstmap = mappings[IDX_LUMINANCE].from_rgba;
	 components = 1;
      }
      else if (dstFormat == &_mesa_texformat_luminance_alpha) {
	 dstmap = mappings[IDX_LUMINANCE_ALPHA].from_rgba;
	 components = 2;
      }
      else if (dstFormat == &_mesa_texformat_intensity) {
	 dstmap = mappings[IDX_INTENSITY].from_rgba;
	 components = 1;
      }
      else {
         _mesa_problem(ctx, "Unexpected dstFormat in _mesa_texstore_rgba");
         return GL_FALSE;
      }

      _mesa_swizzle_ubyte_image(ctx, dims,
				srcFormat,
				srcType,
				baseInternalFormat,
				dstmap, components,
				dstAddr, dstXoffset, dstYoffset, dstZoffset,
				dstRowStride, dstImageOffsets,
				srcWidth, srcHeight, srcDepth, srcAddr,
				srcPacking);      
   }
a1052 3
/**
 * Store a texture in MESA_FORMAT_RGBA8888 or MESA_FORMAT_RGBA8888_REV.
 */
d1056 2
a1057 1
   const GLboolean littleEndian = _mesa_little_endian();
d1059 1
d1096 2
d1099 10
a1108 4
	    (srcType == GL_UNSIGNED_BYTE ||
	     srcType == GL_UNSIGNED_INT_8_8_8_8 ||
	     srcType == GL_UNSIGNED_INT_8_8_8_8_REV) &&
	    can_swizzle(baseInternalFormat) &&
a1109 1

d1112 3
a1114 1
      /* dstmap - how to swizzle from RGBA to dst format:
d1116 4
a1119 13
      if ((littleEndian && dstFormat == &_mesa_texformat_rgba8888) ||
	  (!littleEndian && dstFormat == &_mesa_texformat_rgba8888_rev)) {
	 dstmap[3] = 0;
	 dstmap[2] = 1;
	 dstmap[1] = 2;
	 dstmap[0] = 3;
      }
      else {
	 dstmap[3] = 3;
	 dstmap[2] = 2;
	 dstmap[1] = 1;
	 dstmap[0] = 0;
      }
a1122 2
				srcType,
				baseInternalFormat,
d1125 1
a1125 1
				dstRowStride, dstImageOffsets,
d1129 1
d1180 2
a1181 1
   const GLboolean littleEndian = _mesa_little_endian();
a1220 2
	    (baseInternalFormat == GL_RGBA ||
	     baseInternalFormat == GL_RGB) &&
a1248 1
	    baseInternalFormat == GL_RGBA &&
a1282 1
	    baseInternalFormat == GL_RGBA &&
d1308 10
a1317 4
	    (srcType == GL_UNSIGNED_BYTE ||
	     srcType == GL_UNSIGNED_INT_8_8_8_8 ||
	     srcType == GL_UNSIGNED_INT_8_8_8_8_REV) &&
	    can_swizzle(baseInternalFormat) &&	   
d1322 1
a1322 1
      /* dstmap - how to swizzle from RGBA to dst format:
d1324 4
a1327 15
      if ((littleEndian && dstFormat == &_mesa_texformat_argb8888) ||
	  (!littleEndian && dstFormat == &_mesa_texformat_argb8888_rev)) {
	 dstmap[3] = 3;		/* alpha */
	 dstmap[2] = 0;		/* red */
	 dstmap[1] = 1;		/* green */
	 dstmap[0] = 2;		/* blue */
      }
      else {
	 assert((littleEndian && dstFormat == &_mesa_texformat_argb8888_rev) ||
		(!littleEndian && dstFormat == &_mesa_texformat_argb8888));
	 dstmap[3] = 2;
	 dstmap[2] = 1;
	 dstmap[1] = 0;
	 dstmap[0] = 3;
      }
a1330 3
				srcType,

				baseInternalFormat,
d1388 2
a1389 1
   const GLboolean littleEndian = _mesa_little_endian();
a1433 24
   else if (!ctx->_ImageTransferState &&
	    srcType == GL_UNSIGNED_BYTE &&
	    can_swizzle(baseInternalFormat) &&
	    can_swizzle(srcFormat)) {

      GLubyte dstmap[4];

      /* dstmap - how to swizzle from RGBA to dst format:
       */
      dstmap[0] = 2;
      dstmap[1] = 1;
      dstmap[2] = 0;
      dstmap[3] = ONE;		/* ? */
      
      _mesa_swizzle_ubyte_image(ctx, dims,
				srcFormat,
				srcType,
				baseInternalFormat,
				dstmap, 3,
				dstAddr, dstXoffset, dstYoffset, dstZoffset,
				dstRowStride, dstImageOffsets,
				srcWidth, srcHeight, srcDepth, srcAddr,
				srcPacking);      
   }
d1490 2
a1491 1
   const GLboolean littleEndian = _mesa_little_endian();
a1535 24
   else if (!ctx->_ImageTransferState &&
	    srcType == GL_UNSIGNED_BYTE &&
	    can_swizzle(baseInternalFormat) &&
	    can_swizzle(srcFormat)) {

      GLubyte dstmap[4];

      /* dstmap - how to swizzle from RGBA to dst format:
       */
      dstmap[0] = 0;
      dstmap[1] = 1;
      dstmap[2] = 2;
      dstmap[3] = ONE;		/* ? */
      
      _mesa_swizzle_ubyte_image(ctx, dims,
				srcFormat,
				srcType,
				baseInternalFormat,
				dstmap, 3,
				dstAddr, dstXoffset, dstYoffset, dstZoffset,
				dstRowStride, dstImageOffsets,
				srcWidth, srcHeight, srcDepth, srcAddr,
				srcPacking);      
   }   
d1710 2
a1711 1
   const GLboolean littleEndian = _mesa_little_endian();
a1731 32
   else if (!ctx->_ImageTransferState &&
	    littleEndian &&
	    srcType == GL_UNSIGNED_BYTE &&
	    can_swizzle(baseInternalFormat) &&
	    can_swizzle(srcFormat)) {

      GLubyte dstmap[4];

      /* dstmap - how to swizzle from RGBA to dst format:
       */
      if ((littleEndian && dstFormat == &_mesa_texformat_al88) ||
	  (!littleEndian && dstFormat == &_mesa_texformat_al88_rev)) {
	 dstmap[0] = 0;
	 dstmap[1] = 3;
      }
      else {
	 dstmap[0] = 3;
	 dstmap[1] = 0;
      }
      dstmap[2] = ZERO;		/* ? */
      dstmap[3] = ONE;		/* ? */
      
      _mesa_swizzle_ubyte_image(ctx, dims,
				srcFormat,
				srcType,
				baseInternalFormat,
				dstmap, 2,
				dstAddr, dstXoffset, dstYoffset, dstZoffset,
				dstRowStride, dstImageOffsets,
				srcWidth, srcHeight, srcDepth, srcAddr,
				srcPacking);      
   }   
a1851 29
   else if (!ctx->_ImageTransferState &&
	    srcType == GL_UNSIGNED_BYTE &&
	    can_swizzle(baseInternalFormat) &&
	    can_swizzle(srcFormat)) {

      GLubyte dstmap[4];

      /* dstmap - how to swizzle from RGBA to dst format:
       */
      if (dstFormat == &_mesa_texformat_a8) {
	 dstmap[0] = 3;
      }
      else {
	 dstmap[0] = 0;
      }
      dstmap[1] = ZERO;		/* ? */
      dstmap[2] = ZERO;		/* ? */
      dstmap[3] = ONE;		/* ? */
      
      _mesa_swizzle_ubyte_image(ctx, dims,
				srcFormat,
				srcType,
				baseInternalFormat,
				dstmap, 1,
				dstAddr, dstXoffset, dstYoffset, dstZoffset,
				dstRowStride, dstImageOffsets,
				srcWidth, srcHeight, srcDepth, srcAddr,
				srcPacking);      
   }   
d1933 2
a1934 1
   const GLboolean littleEndian = _mesa_little_endian();
d2189 2
a2190 1
   const GLboolean littleEndian = _mesa_little_endian();
d2221 2
a2222 1
   const GLboolean littleEndian = _mesa_little_endian();
d2270 2
a2271 1
   const GLboolean littleEndian = _mesa_little_endian();
d2389 2
a2390 2
fetch_texel_float_to_chan(const struct gl_texture_image *texImage,
                          GLint i, GLint j, GLint k, GLchan *texelOut)
d2414 2
a2415 2
fetch_texel_chan_to_float(const struct gl_texture_image *texImage,
                          GLint i, GLint j, GLint k, GLfloat *texelOut)
d2463 1
a2463 1
      texImage->FetchTexelc = fetch_texel_float_to_chan;
d2466 1
a2466 1
      texImage->FetchTexelf = fetch_texel_chan_to_float;
d3122 1108
d4384 4
a4387 3
               _mesa_pack_rgba_span_float(ctx, width, (GLfloat (*)[4]) rgba,
                                          format, type, dest,
                                          &ctx->Pack, 0x0 /*image xfer ops*/);
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d811 1
a811 2
   if (srcRowStride == dstRowStride &&
       srcRowStride == srcWidth * srcComponents &&
d2773 2
a2774 2
void
_mesa_set_fetch_functions(struct gl_texture_image *texImage, GLuint dims)
d2834 1
a2834 1
   _mesa_set_fetch_functions(texImage, dims);
a3609 19
                  if (texImage->TexFormat->BaseFormat == GL_ALPHA) {
                     rgba[col][RCOMP] = 0.0;
                     rgba[col][GCOMP] = 0.0;
                     rgba[col][BCOMP] = 0.0;
                  }
                  else if (texImage->TexFormat->BaseFormat == GL_LUMINANCE) {
                     rgba[col][GCOMP] = 0.0;
                     rgba[col][BCOMP] = 0.0;
                     rgba[col][ACOMP] = 1.0;
                  }
                  else if (texImage->TexFormat->BaseFormat == GL_LUMINANCE_ALPHA) {
                     rgba[col][GCOMP] = 0.0;
                     rgba[col][BCOMP] = 0.0;
                  }
                  else if (texImage->TexFormat->BaseFormat == GL_INTENSITY) {
                     rgba[col][GCOMP] = 0.0;
                     rgba[col][BCOMP] = 0.0;
                     rgba[col][ACOMP] = 1.0;
                  }
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d3 1
a3 1
 * Version:  7.5
d5 1
a5 2
 * Copyright (C) 1999-2008  Brian Paul   All Rights Reserved.
 * Copyright (c) 2008-2009  VMware, Inc.
d47 1
a47 1
 *    pixel transfer (scale, bais, lookup, etc)
d57 2
a61 1
#include "pack.h"
a62 1
#include "pack.h"
d64 1
a64 2
#include "texcompress_fxt1.h"
#include "texcompress_s3tc.h"
a76 6
 * Texture image storage function.
 */
typedef GLboolean (*StoreTexImageFunc)(TEXSTORE_PARAMS);


/**
a95 1
   case GL_RG:
a116 1
   IDX_RG,
d168 1
a203 6

   {
      IDX_RG,
      MAP4(0, 1, ZERO, ONE),
      MAP2(0, 1)
   },
a226 1
   case GL_RG: return IDX_RG;
d258 11
a268 11
#if 0
   printf("from %x/%s to %x/%s map %d %d %d %d %d %d\n",
	  inFormat, _mesa_lookup_enum_by_nr(inFormat),
	  outFormat, _mesa_lookup_enum_by_nr(outFormat),
	  map[0], 
	  map[1], 
	  map[2], 
	  map[3], 
	  map[4], 
	  map[5]); 
#endif
d277 1
a277 1
 * but the graphics hardware doesn't support luminance textures.  So, we might
d296 1
a296 1
make_temp_float_image(struct gl_context *ctx, GLuint dims,
d302 1
a302 2
                      const struct gl_pixelstore_attrib *srcPacking,
                      GLbitfield transferOps)
d304 1
a305 5
   const GLint components = _mesa_components_in_format(logicalBaseFormat);
   const GLint srcStride =
      _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType);
   GLfloat *dst;
   GLint img, row;
a310 2
          logicalBaseFormat == GL_RG ||
          logicalBaseFormat == GL_RED ||
a319 2
          textureBaseFormat == GL_RG ||
          textureBaseFormat == GL_RED ||
d327 1
a327 4
   tempImage = (GLfloat *) malloc(srcWidth * srcHeight * srcDepth
				  * components * sizeof(GLfloat));
   if (!tempImage)
      return NULL;
d329 11
a339 15
   dst = tempImage;
   for (img = 0; img < srcDepth; img++) {
      const GLubyte *src
	 = (const GLubyte *) _mesa_image_address(dims, srcPacking, srcAddr,
						 srcWidth, srcHeight,
						 srcFormat, srcType,
						 img, 0, 0);
      for (row = 0; row < srcHeight; row++) {
	 _mesa_unpack_color_span_float(ctx, srcWidth, logicalBaseFormat,
				       dst, srcFormat, srcType, src,
				       srcPacking, transferOps);
	 dst += srcWidth * components;
	 src += srcStride;
      }
   }
d341 5
a345 7
   if (logicalBaseFormat != textureBaseFormat) {
      /* more work */
      GLint texComponents = _mesa_components_in_format(textureBaseFormat);
      GLint logComponents = _mesa_components_in_format(logicalBaseFormat);
      GLfloat *newImage;
      GLint i, n;
      GLubyte map[6];
d347 5
a351 13
      /* we only promote up to RGB, RGBA and LUMINANCE_ALPHA formats for now */
      ASSERT(textureBaseFormat == GL_RGB || textureBaseFormat == GL_RGBA ||
             textureBaseFormat == GL_LUMINANCE_ALPHA);

      /* The actual texture format should have at least as many components
       * as the logical texture format.
       */
      ASSERT(texComponents >= logComponents);

      newImage = (GLfloat *) malloc(srcWidth * srcHeight * srcDepth
                                          * texComponents * sizeof(GLfloat));
      if (!newImage) {
         free(tempImage);
d355 3
a357 1
      compute_component_mapping(logicalBaseFormat, textureBaseFormat, map);
d359 32
a390 11
      n = srcWidth * srcHeight * srcDepth;
      for (i = 0; i < n; i++) {
         GLint k;
         for (k = 0; k < texComponents; k++) {
            GLint j = map[k];
            if (j == ZERO)
               newImage[i * texComponents + k] = 0.0F;
            else if (j == ONE)
               newImage[i * texComponents + k] = 1.0F;
            else
               newImage[i * texComponents + k] = tempImage[i * logComponents + j];
a391 1
      }
d393 31
a423 3
      free(tempImage);
      tempImage = newImage;
   }
d425 4
a428 2
   return tempImage;
}
d430 14
a443 58

/**
 * Make temporary image with uint pixel values.  Used for unsigned
 * integer-valued textures.
 */
static GLuint *
make_temp_uint_image(struct gl_context *ctx, GLuint dims,
                     GLenum logicalBaseFormat,
                     GLenum textureBaseFormat,
                     GLint srcWidth, GLint srcHeight, GLint srcDepth,
                     GLenum srcFormat, GLenum srcType,
                     const GLvoid *srcAddr,
                     const struct gl_pixelstore_attrib *srcPacking)
{
   GLuint *tempImage;
   const GLint components = _mesa_components_in_format(logicalBaseFormat);
   const GLint srcStride =
      _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType);
   GLuint *dst;
   GLint img, row;

   ASSERT(dims >= 1 && dims <= 3);

   ASSERT(logicalBaseFormat == GL_RGBA ||
          logicalBaseFormat == GL_RGB ||
          logicalBaseFormat == GL_RG ||
          logicalBaseFormat == GL_RED ||
          logicalBaseFormat == GL_LUMINANCE_ALPHA ||
          logicalBaseFormat == GL_LUMINANCE ||
          logicalBaseFormat == GL_INTENSITY ||
          logicalBaseFormat == GL_ALPHA);

   ASSERT(textureBaseFormat == GL_RGBA ||
          textureBaseFormat == GL_RGB ||
          textureBaseFormat == GL_RG ||
          textureBaseFormat == GL_RED ||
          textureBaseFormat == GL_LUMINANCE_ALPHA ||
          textureBaseFormat == GL_LUMINANCE ||
          textureBaseFormat == GL_ALPHA);

   tempImage = (GLuint *) malloc(srcWidth * srcHeight * srcDepth
                                 * components * sizeof(GLuint));
   if (!tempImage)
      return NULL;

   dst = tempImage;
   for (img = 0; img < srcDepth; img++) {
      const GLubyte *src
	 = (const GLubyte *) _mesa_image_address(dims, srcPacking, srcAddr,
						 srcWidth, srcHeight,
						 srcFormat, srcType,
						 img, 0, 0);
      for (row = 0; row < srcHeight; row++) {
	 _mesa_unpack_color_span_uint(ctx, srcWidth, logicalBaseFormat,
                                      dst, srcFormat, srcType, src,
                                      srcPacking);
	 dst += srcWidth * components;
	 src += srcStride;
d451 1
a451 1
      GLuint *newImage;
d464 2
a465 2
      newImage = (GLuint *) malloc(srcWidth * srcHeight * srcDepth
                                   * texComponents * sizeof(GLuint));
d467 1
a467 1
         free(tempImage);
d487 1
a487 1
      free(tempImage);
a494 1

d500 1
a500 1
 * but the graphics hardware doesn't support luminance textures.  So, we might
d519 1
a519 1
_mesa_make_temp_chan_image(struct gl_context *ctx, GLuint dims,
d529 1
a536 2
          logicalBaseFormat == GL_RG ||
          logicalBaseFormat == GL_RED ||
a543 2
          textureBaseFormat == GL_RG ||
          textureBaseFormat == GL_RED ||
d549 22
d572 1
a572 1
   tempImage = (GLchan *) malloc(srcWidth * srcHeight * srcDepth
d574 1
a574 1
   if (!tempImage) {
a575 1
   }
d579 8
a586 7
      const GLint srcStride =
         _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType);
      const GLubyte *src =
         (const GLubyte *) _mesa_image_address(dims, srcPacking, srcAddr,
                                               srcWidth, srcHeight,
                                               srcFormat, srcType,
                                               img, 0, 0);
d596 5
d618 1
a618 1
      newImage = (GLchan *) malloc(srcWidth * srcHeight * srcDepth
d621 1
a621 1
         free(tempImage);
d641 1
a641 1
      free(tempImage);
a663 21
#define SWZ_CPY(dst, src, count, dstComps, srcComps) \
   do {                                              \
      GLuint i;                                      \
      for (i = 0; i < count; i++) {                  \
         GLuint j;                                   \
         if (srcComps == 4) {                        \
            COPY_4UBV(tmp, src);                     \
         }                                           \
         else {                                      \
            for (j = 0; j < srcComps; j++) {         \
               tmp[j] = src[j];                      \
            }                                        \
         }                                           \
         src += srcComps;                            \
         for (j = 0; j < dstComps; j++) {            \
            dst[j] = tmp[map[j]];                    \
         }                                           \
         dst += dstComps;                            \
      }                                              \
   } while (0)

d665 1
a669 3
   ASSERT(srcComponents <= 4);
   ASSERT(dstComponents <= 4);

d672 8
a679 15
      switch (srcComponents) {
      case 4:
         SWZ_CPY(dst, src, count, 4, 4);
         break;
      case 3:
         SWZ_CPY(dst, src, count, 4, 3);
         break;
      case 2:
         SWZ_CPY(dst, src, count, 4, 2);
         break;
      case 1:
         SWZ_CPY(dst, src, count, 4, 1);
         break;
      default:
         ;
d683 7
a689 15
      switch (srcComponents) {
      case 4:
         SWZ_CPY(dst, src, count, 3, 4);
         break;
      case 3:
         SWZ_CPY(dst, src, count, 3, 3);
         break;
      case 2:
         SWZ_CPY(dst, src, count, 3, 2);
         break;
      case 1:
         SWZ_CPY(dst, src, count, 3, 1);
         break;
      default:
         ;
d693 6
a698 15
      switch (srcComponents) {
      case 4:
         SWZ_CPY(dst, src, count, 2, 4);
         break;
      case 3:
         SWZ_CPY(dst, src, count, 2, 3);
         break;
      case 2:
         SWZ_CPY(dst, src, count, 2, 2);
         break;
      case 1:
         SWZ_CPY(dst, src, count, 2, 1);
         break;
      default:
         ;
d702 6
a707 15
      switch (srcComponents) {
      case 4:
         SWZ_CPY(dst, src, count, 1, 4);
         break;
      case 3:
         SWZ_CPY(dst, src, count, 1, 3);
         break;
      case 2:
         SWZ_CPY(dst, src, count, 1, 2);
         break;
      case 1:
         SWZ_CPY(dst, src, count, 1, 1);
         break;
      default:
         ;
a709 2
   default:
      ;
a710 1
#undef SWZ_CPY
a713 1

d717 1
a717 4

/**
 * For 1-byte/pixel formats (or 8_8_8_8 packed formats), return a
 * mapping array depending on endianness.
a722 1
   case GL_BYTE:
d734 1
a734 4

/**
 * For 1-byte/pixel formats (or 8_8_8_8 packed formats), return a
 * mapping array depending on pixelstore byte swapping state.
a743 1
   case GL_BYTE:
d760 1
a760 1
_mesa_swizzle_ubyte_image(struct gl_context *ctx, 
d809 1
a809 1
/*    printf("map %d %d %d %d\n", map[0], map[1], map[2], map[3]);  */
d811 1
a811 2
   if (srcComponents == dstComponents &&
       srcRowStride == dstRowStride &&
d846 1
a846 1
memcpy_texture(struct gl_context *ctx,
d848 1
a848 1
               gl_format dstFormat,
d864 1
a864 2
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
   const GLint bytesPerRow = srcWidth * texelBytes;
d873 1
a873 1
                     + dstXoffset * texelBytes;
d904 1
a904 1
         + dstImageOffsets[dstZoffset + img] * texelBytes
d906 1
a906 1
         + dstXoffset * texelBytes;
d919 8
a926 1
 * Store a 32-bit integer depth component texture image.
d928 2
a929 2
static GLboolean
_mesa_texstore_z32(TEXSTORE_PARAMS)
d931 15
a945 5
   const GLuint depthScale = 0xffffffff;
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
   (void) dims;
   ASSERT(dstFormat == MESA_FORMAT_Z32);
   ASSERT(texelBytes == sizeof(GLuint));
d947 1
a947 2
   if (ctx->Pixel.DepthScale == 1.0f &&
       ctx->Pixel.DepthBias == 0.0f &&
d949 2
a950 3
       baseInternalFormat == GL_DEPTH_COMPONENT &&
       srcFormat == GL_DEPTH_COMPONENT &&
       srcType == GL_UNSIGNED_INT) {
d959 7
a965 3
   else {
      /* general path */
      GLint img, row;
d967 11
a977 4
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * texelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
d979 7
a985 6
            const GLvoid *src = _mesa_image_address(dims, srcPacking,
                srcAddr, srcWidth, srcHeight, srcFormat, srcType, img, row, 0);
            _mesa_unpack_depth_span(ctx, srcWidth,
                                    GL_UNSIGNED_INT, (GLuint *) dstRow,
                                    depthScale, srcType, src, srcPacking);
            dstRow += dstRowStride;
d989 7
a995 2
   return GL_TRUE;
}
d997 2
d1000 30
a1029 8
/**
 * Store a 24-bit integer depth component texture image.
 */
static GLboolean
_mesa_texstore_x8_z24(TEXSTORE_PARAMS)
{
   const GLuint depthScale = 0xffffff;
   const GLuint texelBytes = 4;
d1031 11
a1041 4
   (void) dims;
   ASSERT(dstFormat == MESA_FORMAT_X8_Z24);

   {
d1043 8
d1052 4
d1058 1
a1058 1
            + dstImageOffsets[dstZoffset + img] * texelBytes
d1060 1
a1060 1
            + dstXoffset * texelBytes;
d1062 1
a1062 5
            const GLvoid *src = _mesa_image_address(dims, srcPacking,
                srcAddr, srcWidth, srcHeight, srcFormat, srcType, img, row, 0);
            _mesa_unpack_depth_span(ctx, srcWidth,
                                    GL_UNSIGNED_INT, (GLuint *) dstRow,
                                    depthScale, srcType, src, srcPacking);
d1064 1
d1067 2
d1075 1
a1075 1
 * Store a 24-bit integer depth component texture image.
d1077 2
a1078 2
static GLboolean
_mesa_texstore_z24_x8(TEXSTORE_PARAMS)
d1080 1
a1080 3
   const GLuint depthScale = 0xffffff;
   const GLuint texelBytes = 4;

d1082 2
a1083 1
   ASSERT(dstFormat == MESA_FORMAT_Z24_X8);
d1085 14
a1098 1
   {
d1103 1
a1103 1
            + dstImageOffsets[dstZoffset + img] * texelBytes
d1105 1
a1105 1
            + dstXoffset * texelBytes;
a1108 2
            GLuint *dst = (GLuint *) dstRow;
            GLint i;
d1110 1
a1110 1
                                    GL_UNSIGNED_INT, dst,
a1111 2
            for (i = 0; i < srcWidth; i++)
               dst[i] <<= 8;
d1119 1
d1124 1
a1124 1
static GLboolean
d1127 1
a1127 2
   const GLuint depthScale = 0xffff;
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
d1129 2
a1130 2
   ASSERT(dstFormat == MESA_FORMAT_Z16);
   ASSERT(texelBytes == sizeof(GLushort));
d1132 1
a1132 2
   if (ctx->Pixel.DepthScale == 1.0f &&
       ctx->Pixel.DepthBias == 0.0f &&
d1150 1
a1150 1
            + dstImageOffsets[dstZoffset + img] * texelBytes
d1152 1
a1152 1
            + dstXoffset * texelBytes;
d1171 1
a1171 1
static GLboolean
d1174 3
a1176 6
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_RGB565 ||
          dstFormat == MESA_FORMAT_RGB565_REV);
   ASSERT(texelBytes == 2);
d1180 1
a1180 1
       dstFormat == MESA_FORMAT_RGB565 &&
d1199 2
a1200 2
      const GLint srcRowStride =
         _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType);
d1206 1
a1206 1
                   + dstXoffset * texelBytes;
d1212 1
a1212 1
         if (dstFormat == MESA_FORMAT_RGB565) {
d1232 1
a1232 1
                                                 baseFormat,
d1240 1
d1243 1
a1243 1
            + dstImageOffsets[dstZoffset + img] * texelBytes
d1245 1
a1245 1
            + dstXoffset * texelBytes;
d1249 1
a1249 1
            if (dstFormat == MESA_FORMAT_RGB565) {
d1268 1
a1268 1
      free((void *) tempImage);
d1277 1
a1277 1
static GLboolean
a1280 2
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
d1282 3
a1284 3
   ASSERT(dstFormat == MESA_FORMAT_RGBA8888 ||
          dstFormat == MESA_FORMAT_RGBA8888_REV);
   ASSERT(texelBytes == 4);
d1288 1
a1288 1
       dstFormat == MESA_FORMAT_RGBA8888 &&
d1304 1
a1304 1
       dstFormat == MESA_FORMAT_RGBA8888_REV &&
d1329 2
a1330 2
      if ((littleEndian && dstFormat == MESA_FORMAT_RGBA8888) ||
	  (!littleEndian && dstFormat == MESA_FORMAT_RGBA8888_REV)) {
d1357 1
a1357 1
                                                 baseFormat,
d1365 1
d1368 1
a1368 1
            + dstImageOffsets[dstZoffset + img] * texelBytes
d1370 1
a1370 1
            + dstXoffset * texelBytes;
d1373 1
a1373 1
            if (dstFormat == MESA_FORMAT_RGBA8888) {
d1394 1
a1394 1
      free((void *) tempImage);
d1400 1
a1400 1
static GLboolean
a1403 2
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
   const GLenum baseFormat = GL_RGBA;
d1405 3
a1407 5
   ASSERT(dstFormat == MESA_FORMAT_ARGB8888 ||
          dstFormat == MESA_FORMAT_ARGB8888_REV ||
          dstFormat == MESA_FORMAT_XRGB8888 ||
          dstFormat == MESA_FORMAT_XRGB8888_REV );
   ASSERT(texelBytes == 4);
d1411 1
a1411 2
       (dstFormat == MESA_FORMAT_ARGB8888 ||
        dstFormat == MESA_FORMAT_XRGB8888) &&
d1426 1
a1426 2
       (dstFormat == MESA_FORMAT_ARGB8888_REV ||
        dstFormat == MESA_FORMAT_XRGB8888_REV) &&
d1441 1
a1441 2
	    (dstFormat == MESA_FORMAT_ARGB8888 ||
             dstFormat == MESA_FORMAT_XRGB8888) &&
d1446 1
d1449 2
a1450 2
         const GLint srcRowStride =
            _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType);
d1454 1
a1454 1
            + dstImageOffsets[dstZoffset + img] * texelBytes
d1456 1
a1456 1
            + dstXoffset * texelBytes;
a1457 1
            GLuint *d4 = (GLuint *) dstRow;
d1459 4
a1462 4
               d4[col] = PACK_COLOR_8888(0xff,
                                         srcRow[col * 3 + RCOMP],
                                         srcRow[col * 3 + GCOMP],
                                         srcRow[col * 3 + BCOMP]);
d1471 1
a1471 1
	    dstFormat == MESA_FORMAT_ARGB8888 &&
d1474 1
a1474 2
            srcType == GL_UNSIGNED_BYTE) {
      /* same as above case, but src data has alpha too */
d1483 2
a1484 2
         const GLint srcRowStride =
            _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType);
d1488 1
a1488 1
            + dstImageOffsets[dstZoffset + img] * texelBytes
d1490 2
a1491 1
            + dstXoffset * texelBytes;
a1492 1
            GLuint *d4 = (GLuint *) dstRow;
d1494 4
a1497 4
               d4[col] = PACK_COLOR_8888(srcRow[col * 4 + ACOMP],
                                         srcRow[col * 4 + RCOMP],
                                         srcRow[col * 4 + GCOMP],
                                         srcRow[col * 4 + BCOMP]);
d1505 34
a1538 5
	    (srcType == GL_UNSIGNED_BYTE ||
	     srcType == GL_UNSIGNED_INT_8_8_8_8 ||
	     srcType == GL_UNSIGNED_INT_8_8_8_8_REV) &&
	    can_swizzle(baseInternalFormat) &&	   
	    can_swizzle(srcFormat)) {
d1544 2
a1545 4
      if ((littleEndian && dstFormat == MESA_FORMAT_ARGB8888) ||
          (littleEndian && dstFormat == MESA_FORMAT_XRGB8888) ||
	  (!littleEndian && dstFormat == MESA_FORMAT_ARGB8888_REV) ||
	  (!littleEndian && dstFormat == MESA_FORMAT_XRGB8888_REV)) {
d1552 2
a1553 4
	 assert((littleEndian && dstFormat == MESA_FORMAT_ARGB8888_REV) ||
		(!littleEndian && dstFormat == MESA_FORMAT_ARGB8888) ||
		(littleEndian && dstFormat == MESA_FORMAT_XRGB8888_REV) ||
		(!littleEndian && dstFormat == MESA_FORMAT_XRGB8888));
d1563 1
d1576 1
a1576 1
                                                 baseFormat,
d1584 1
d1587 1
a1587 1
            + dstImageOffsets[dstZoffset + img] * texelBytes
d1589 1
a1589 1
            + dstXoffset * texelBytes;
d1592 1
a1592 1
            if (dstFormat == MESA_FORMAT_ARGB8888) {
a1600 9
            else if (dstFormat == MESA_FORMAT_XRGB8888) {
               for (col = 0; col < srcWidth; col++) {
                  dstUI[col] = PACK_COLOR_8888( 0xff,
                                                CHAN_TO_UBYTE(src[RCOMP]),
                                                CHAN_TO_UBYTE(src[GCOMP]),
                                                CHAN_TO_UBYTE(src[BCOMP]) );
                  src += 4;
               }
            }
d1613 1
a1613 1
      free((void *) tempImage);
d1619 1
a1619 1
static GLboolean
a1622 2
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
d1624 2
a1625 2
   ASSERT(dstFormat == MESA_FORMAT_RGB888);
   ASSERT(texelBytes == 3);
d1648 2
a1649 2
         const GLint srcRowStride =
            _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType);
d1653 1
a1653 1
            + dstImageOffsets[dstZoffset + img] * texelBytes
d1655 1
a1655 1
            + dstXoffset * texelBytes;
d1695 1
a1695 1
                                                 baseFormat,
d1703 1
d1706 1
a1706 1
            + dstImageOffsets[dstZoffset + img] * texelBytes
d1708 1
a1708 1
            + dstXoffset * texelBytes;
d1738 1
a1738 1
      free((void *) tempImage);
d1744 1
a1744 1
static GLboolean
a1747 2
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
d1749 2
a1750 2
   ASSERT(dstFormat == MESA_FORMAT_BGR888);
   ASSERT(texelBytes == 3);
d1773 2
a1774 2
         const GLint srcRowStride =
            _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType);
d1778 1
a1778 1
            + dstImageOffsets[dstZoffset + img] * texelBytes
d1780 1
a1780 1
            + dstXoffset * texelBytes;
d1820 1
a1820 1
                                                 baseFormat,
d1828 1
d1831 1
a1831 1
            + dstImageOffsets[dstZoffset + img] * texelBytes
d1833 1
a1833 1
            + dstXoffset * texelBytes;
d1844 1
a1844 1
      free((void *) tempImage);
d1850 1
a1850 1
static GLboolean
d1853 3
a1855 6
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_ARGB4444 ||
          dstFormat == MESA_FORMAT_ARGB4444_REV);
   ASSERT(texelBytes == 2);
d1859 1
a1859 1
       dstFormat == MESA_FORMAT_ARGB4444 &&
d1875 1
a1875 1
                                                 baseFormat,
d1883 1
d1886 1
a1886 1
            + dstImageOffsets[dstZoffset + img] * texelBytes
d1888 1
a1888 1
            + dstXoffset * texelBytes;
d1891 1
a1891 1
            if (dstFormat == MESA_FORMAT_ARGB4444) {
d1912 1
a1912 1
      free((void *) tempImage);
a1916 5
static GLboolean
_mesa_texstore_rgba5551(TEXSTORE_PARAMS)
{
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
a1917 2
   ASSERT(dstFormat == MESA_FORMAT_RGBA5551);
   ASSERT(texelBytes == 2);
d1919 1
a1919 49
   if (!ctx->_ImageTransferState &&
       !srcPacking->SwapBytes &&
       dstFormat == MESA_FORMAT_RGBA5551 &&
       baseInternalFormat == GL_RGBA &&
       srcFormat == GL_RGBA &&
       srcType == GL_UNSIGNED_SHORT_5_5_5_1) {
      /* simple memcpy path */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else {
      /* general path */
      const GLchan *tempImage = _mesa_make_temp_chan_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking);
      const GLchan *src =tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * texelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
         for (row = 0; row < srcHeight; row++) {
            GLushort *dstUS = (GLushort *) dstRow;
	    for (col = 0; col < srcWidth; col++) {
	       dstUS[col] = PACK_COLOR_5551( CHAN_TO_UBYTE(src[RCOMP]),
					     CHAN_TO_UBYTE(src[GCOMP]),
					     CHAN_TO_UBYTE(src[BCOMP]),
					     CHAN_TO_UBYTE(src[ACOMP]) );
	      src += 4;
	    }
            dstRow += dstRowStride;
         }
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}

static GLboolean
d1922 3
a1924 6
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_ARGB1555 ||
          dstFormat == MESA_FORMAT_ARGB1555_REV);
   ASSERT(texelBytes == 2);
d1928 1
a1928 1
       dstFormat == MESA_FORMAT_ARGB1555 &&
d1944 1
a1944 1
                                                 baseFormat,
d1952 1
d1955 1
a1955 1
            + dstImageOffsets[dstZoffset + img] * texelBytes
d1957 1
a1957 1
            + dstXoffset * texelBytes;
d1960 1
a1960 1
            if (dstFormat == MESA_FORMAT_ARGB1555) {
d1981 1
a1981 1
      free((void *) tempImage);
d1987 2
a1988 5
/**
 * Do texstore for 2-channel, 8-bit/channel, unsigned normalized formats.
 */
static GLboolean
_mesa_texstore_unorm88(TEXSTORE_PARAMS)
a1990 2
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
d1992 3
a1994 5
   ASSERT(dstFormat == MESA_FORMAT_AL88 ||
          dstFormat == MESA_FORMAT_AL88_REV ||
          dstFormat == MESA_FORMAT_RG88 ||
          dstFormat == MESA_FORMAT_RG88_REV);
   ASSERT(texelBytes == 2);
d1998 3
a2000 5
       ((dstFormat == MESA_FORMAT_AL88 &&
         baseInternalFormat == GL_LUMINANCE_ALPHA &&
         srcFormat == GL_LUMINANCE_ALPHA) ||
        (dstFormat == MESA_FORMAT_RG88 &&
         baseInternalFormat == srcFormat)) &&
d2016 1
d2021 4
a2024 10
      if (dstFormat == MESA_FORMAT_AL88 || dstFormat == MESA_FORMAT_AL88_REV) {
	 if ((littleEndian && dstFormat == MESA_FORMAT_AL88) ||
	     (!littleEndian && dstFormat == MESA_FORMAT_AL88_REV)) {
	    dstmap[0] = 0;
	    dstmap[1] = 3;
	 }
	 else {
	    dstmap[0] = 3;
	    dstmap[1] = 0;
	 }
d2027 2
a2028 9
	 if ((littleEndian && dstFormat == MESA_FORMAT_RG88) ||
	     (!littleEndian && dstFormat == MESA_FORMAT_RG88_REV)) {
	    dstmap[0] = 0;
	    dstmap[1] = 1;
	 }
	 else {
	    dstmap[0] = 1;
	    dstmap[1] = 0;
	 }
d2047 1
a2047 1
                                                 baseFormat,
d2055 1
d2058 1
a2058 1
            + dstImageOffsets[dstZoffset + img] * texelBytes
d2060 1
a2060 1
            + dstXoffset * texelBytes;
d2063 1
a2063 2
            if (dstFormat == MESA_FORMAT_AL88 ||
		dstFormat == MESA_FORMAT_RG88) {
d2082 1
a2082 1
      free((void *) tempImage);
d2088 2
a2089 5
/**
 * Do texstore for 2-channel, 16-bit/channel, unsigned normalized formats.
 */
static GLboolean
_mesa_texstore_unorm1616(TEXSTORE_PARAMS)
d2091 2
a2092 9
   const GLboolean littleEndian = _mesa_little_endian();
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_AL1616 ||
          dstFormat == MESA_FORMAT_AL1616_REV ||
	  dstFormat == MESA_FORMAT_RG1616 ||
          dstFormat == MESA_FORMAT_RG1616_REV);
   ASSERT(texelBytes == 4);
d2096 2
a2097 7
       ((dstFormat == MESA_FORMAT_AL1616 &&
         baseInternalFormat == GL_LUMINANCE_ALPHA &&
         srcFormat == GL_LUMINANCE_ALPHA) ||
        (dstFormat == MESA_FORMAT_RG1616 &&
         baseInternalFormat == srcFormat)) &&
       srcType == GL_UNSIGNED_SHORT &&
       littleEndian) {
d2108 1
a2108 1
      const GLfloat *tempImage = make_temp_float_image(ctx, dims,
d2110 1
a2110 1
                                                 baseFormat,
d2113 2
a2114 3
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *src = tempImage;
d2118 1
d2121 1
a2121 1
            + dstImageOffsets[dstZoffset + img] * texelBytes
d2123 1
a2123 1
            + dstXoffset * texelBytes;
d2125 5
a2129 21
            GLuint *dstUI = (GLuint *) dstRow;
            if (dstFormat == MESA_FORMAT_AL1616 ||
		dstFormat == MESA_FORMAT_RG1616) {
               for (col = 0; col < srcWidth; col++) {
		  GLushort l, a;

		  UNCLAMPED_FLOAT_TO_USHORT(l, src[0]);
		  UNCLAMPED_FLOAT_TO_USHORT(a, src[1]);
		  dstUI[col] = PACK_COLOR_1616(a, l);
		  src += 2;
               }
            }
            else {
               for (col = 0; col < srcWidth; col++) {
		  GLushort l, a;

		  UNCLAMPED_FLOAT_TO_USHORT(l, src[0]);
		  UNCLAMPED_FLOAT_TO_USHORT(a, src[1]);
		  dstUI[col] = PACK_COLOR_1616_REV(a, l);
		  src += 2;
               }
d2134 1
a2134 1
      free((void *) tempImage);
d2140 5
a2144 2
static GLboolean
_mesa_texstore_r16(TEXSTORE_PARAMS)
d2146 4
a2149 6
   const GLboolean littleEndian = _mesa_little_endian();
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_R16);
   ASSERT(texelBytes == 2);
d2153 2
a2154 5
       dstFormat == MESA_FORMAT_R16 &&
       baseInternalFormat == GL_RED &&
       srcFormat == GL_RED &&
       srcType == GL_UNSIGNED_SHORT &&
       littleEndian) {
d2163 29
d2194 1
a2194 1
      const GLfloat *tempImage = make_temp_float_image(ctx, dims,
d2196 1
a2196 1
                                                 baseFormat,
d2199 2
a2200 3
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *src = tempImage;
d2204 1
d2207 1
a2207 1
            + dstImageOffsets[dstZoffset + img] * texelBytes
d2209 1
a2209 1
            + dstXoffset * texelBytes;
d2211 3
a2213 8
            GLushort *dstUS = (GLushort *) dstRow;
	    for (col = 0; col < srcWidth; col++) {
	       GLushort r;

	       UNCLAMPED_FLOAT_TO_USHORT(r, src[0]);
	       dstUS[col] = r;
	       src += 1;
	    }
d2215 1
d2218 1
a2218 1
      free((void *) tempImage);
d2224 3
a2226 2
static GLboolean
_mesa_texstore_rgba_16(TEXSTORE_PARAMS)
d2228 4
a2231 5
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_RGBA_16);
   ASSERT(texelBytes == 8);
d2235 2
a2236 3
       baseInternalFormat == GL_RGBA &&
       srcFormat == GL_RGBA &&
       srcType == GL_UNSIGNED_SHORT) {
d2247 1
a2247 11
      const GLfloat *tempImage = make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *src = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
d2250 1
a2250 1
            + dstImageOffsets[dstZoffset + img] * texelBytes
d2252 1
a2252 1
            + dstXoffset * texelBytes;
d2254 5
a2258 14
            GLushort *dstUS = (GLushort *) dstRow;
            for (col = 0; col < srcWidth; col++) {
               GLushort r, g, b, a;

               UNCLAMPED_FLOAT_TO_USHORT(r, src[0]);
               UNCLAMPED_FLOAT_TO_USHORT(g, src[1]);
               UNCLAMPED_FLOAT_TO_USHORT(b, src[2]);
               UNCLAMPED_FLOAT_TO_USHORT(a, src[3]);
               dstUS[col*4+0] = r;
               dstUS[col*4+1] = g;
               dstUS[col*4+2] = b;
               dstUS[col*4+3] = a;
               src += 4;
            }
a2261 1
      free((void *) tempImage);
d2267 5
a2271 2
static GLboolean
_mesa_texstore_signed_rgba_16(TEXSTORE_PARAMS)
d2273 2
a2274 2
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
d2276 8
a2283 4
   ASSERT(dstFormat == MESA_FORMAT_SIGNED_R_16 ||
          dstFormat == MESA_FORMAT_SIGNED_RG_16 ||
          dstFormat == MESA_FORMAT_SIGNED_RGB_16 ||
          dstFormat == MESA_FORMAT_SIGNED_RGBA_16);
d2285 7
a2291 26
   if (!ctx->_ImageTransferState &&
       !srcPacking->SwapBytes &&
       baseInternalFormat == GL_RGBA &&
       dstFormat == MESA_FORMAT_SIGNED_RGBA_16 &&
       srcFormat == GL_RGBA &&
       srcType == GL_SHORT) {
      /* simple memcpy path */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else {
      /* general path */
      const GLfloat *tempImage = make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *src = tempImage;
      const GLuint comps = _mesa_get_format_bytes(dstFormat) / 2;
      GLint img, row, col;
d2293 7
a2299 6
      if (!tempImage)
         return GL_FALSE;

      /* Note: tempImage is always float[4] / RGBA.  We convert to 1, 2,
       * 3 or 4 components/pixel here.
       */
d2302 1
a2302 1
            + dstImageOffsets[dstZoffset + img] * texelBytes
d2304 1
a2304 1
            + dstXoffset * texelBytes;
d2306 1
a2306 9
            GLshort *dstRowS = (GLshort *) dstRow;
            for (col = 0; col < srcWidth; col++) {
               GLuint c;
               for (c = 0; c < comps; c++) {
                  GLshort p;
                  UNCLAMPED_FLOAT_TO_SHORT(p, src[col * 4 + c]);
                  dstRowS[col * comps + c] = p;
               }
            }
a2307 1
            src += 4 * srcWidth;
a2309 1
      free((void *) tempImage);
d2315 6
a2320 2
static GLboolean
_mesa_texstore_rgb332(TEXSTORE_PARAMS)
d2322 3
a2324 5
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_RGB332);
   ASSERT(texelBytes == 1);
d2327 2
a2328 4
       !srcPacking->SwapBytes &&
       baseInternalFormat == GL_RGB &&
       srcFormat == GL_RGB && srcType == GL_UNSIGNED_BYTE_3_3_2) {
      /* simple memcpy path */
d2338 4
a2341 887
      const GLchan *tempImage = _mesa_make_temp_chan_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking);
      const GLchan *src = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * texelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
         for (row = 0; row < srcHeight; row++) {
            for (col = 0; col < srcWidth; col++) {
               dstRow[col] = PACK_COLOR_332( CHAN_TO_UBYTE(src[RCOMP]),
                                             CHAN_TO_UBYTE(src[GCOMP]),
                                             CHAN_TO_UBYTE(src[BCOMP]) );
               src += 3;
            }
            dstRow += dstRowStride;
         }
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}


/**
 * Texstore for _mesa_texformat_a8, _mesa_texformat_l8, _mesa_texformat_i8.
 */
static GLboolean
_mesa_texstore_a8(TEXSTORE_PARAMS)
{
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_A8 ||
          dstFormat == MESA_FORMAT_L8 ||
          dstFormat == MESA_FORMAT_I8 ||
          dstFormat == MESA_FORMAT_R8);
   ASSERT(texelBytes == 1);

   if (!ctx->_ImageTransferState &&
       !srcPacking->SwapBytes &&
       baseInternalFormat == srcFormat &&
       srcType == GL_UNSIGNED_BYTE) {
      /* simple memcpy path */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else if (!ctx->_ImageTransferState &&
	    srcType == GL_UNSIGNED_BYTE &&
	    can_swizzle(baseInternalFormat) &&
	    can_swizzle(srcFormat)) {
      GLubyte dstmap[4];

      /* dstmap - how to swizzle from RGBA to dst format:
       */
      if (dstFormat == MESA_FORMAT_A8) {
	 dstmap[0] = 3;
      }
      else {
	 dstmap[0] = 0;
      }
      dstmap[1] = ZERO;		/* ? */
      dstmap[2] = ZERO;		/* ? */
      dstmap[3] = ONE;		/* ? */
      
      _mesa_swizzle_ubyte_image(ctx, dims,
				srcFormat,
				srcType,
				baseInternalFormat,
				dstmap, 1,
				dstAddr, dstXoffset, dstYoffset, dstZoffset,
				dstRowStride, dstImageOffsets,
				srcWidth, srcHeight, srcDepth, srcAddr,
				srcPacking);      
   }   
   else {
      /* general path */
      const GLchan *tempImage = _mesa_make_temp_chan_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking);
      const GLchan *src = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * texelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
         for (row = 0; row < srcHeight; row++) {
            for (col = 0; col < srcWidth; col++) {
               dstRow[col] = CHAN_TO_UBYTE(src[col]);
            }
            dstRow += dstRowStride;
            src += srcWidth;
         }
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}



static GLboolean
_mesa_texstore_ci8(TEXSTORE_PARAMS)
{
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);

   (void) dims; (void) baseInternalFormat;
   ASSERT(dstFormat == MESA_FORMAT_CI8);
   ASSERT(texelBytes == 1);
   ASSERT(baseInternalFormat == GL_COLOR_INDEX);

   if (!ctx->_ImageTransferState &&
       !srcPacking->SwapBytes &&
       srcFormat == GL_COLOR_INDEX &&
       srcType == GL_UNSIGNED_BYTE) {
      /* simple memcpy path */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else {
      /* general path */
      GLint img, row;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * texelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
         for (row = 0; row < srcHeight; row++) {
            const GLvoid *src = _mesa_image_address(dims, srcPacking,
                srcAddr, srcWidth, srcHeight, srcFormat, srcType, img, row, 0);
            _mesa_unpack_index_span(ctx, srcWidth, GL_UNSIGNED_BYTE, dstRow,
                                    srcType, src, srcPacking,
                                    ctx->_ImageTransferState);
            dstRow += dstRowStride;
         }
      }
   }
   return GL_TRUE;
}


/**
 * Texstore for _mesa_texformat_ycbcr or _mesa_texformat_ycbcr_REV.
 */
static GLboolean
_mesa_texstore_ycbcr(TEXSTORE_PARAMS)
{
   const GLboolean littleEndian = _mesa_little_endian();
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);

   (void) ctx; (void) dims; (void) baseInternalFormat;

   ASSERT((dstFormat == MESA_FORMAT_YCBCR) ||
          (dstFormat == MESA_FORMAT_YCBCR_REV));
   ASSERT(texelBytes == 2);
   ASSERT(ctx->Extensions.MESA_ycbcr_texture);
   ASSERT(srcFormat == GL_YCBCR_MESA);
   ASSERT((srcType == GL_UNSIGNED_SHORT_8_8_MESA) ||
          (srcType == GL_UNSIGNED_SHORT_8_8_REV_MESA));
   ASSERT(baseInternalFormat == GL_YCBCR_MESA);

   /* always just memcpy since no pixel transfer ops apply */
   memcpy_texture(ctx, dims,
                  dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                  dstRowStride,
                  dstImageOffsets,
                  srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                  srcAddr, srcPacking);

   /* Check if we need byte swapping */
   /* XXX the logic here _might_ be wrong */
   if (srcPacking->SwapBytes ^
       (srcType == GL_UNSIGNED_SHORT_8_8_REV_MESA) ^
       (dstFormat == MESA_FORMAT_YCBCR_REV) ^
       !littleEndian) {
      GLint img, row;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * texelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
         for (row = 0; row < srcHeight; row++) {
            _mesa_swap2((GLushort *) dstRow, srcWidth);
            dstRow += dstRowStride;
         }
      }
   }
   return GL_TRUE;
}

static GLboolean
_mesa_texstore_dudv8(TEXSTORE_PARAMS)
{
   const GLboolean littleEndian = _mesa_little_endian();
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_DUDV8);
   ASSERT(texelBytes == 2);
   ASSERT(ctx->Extensions.ATI_envmap_bumpmap);
   ASSERT((srcFormat == GL_DU8DV8_ATI) ||
	  (srcFormat == GL_DUDV_ATI));
   ASSERT(baseInternalFormat == GL_DUDV_ATI);

   if (!srcPacking->SwapBytes && srcType == GL_BYTE &&
       littleEndian) {
      /* simple memcpy path */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else if (srcType == GL_BYTE) {
      GLubyte dstmap[4];

      /* dstmap - how to swizzle from RGBA to dst format:
       */
      if (littleEndian) {
	 dstmap[0] = 0;
	 dstmap[1] = 3;
      }
      else {
	 dstmap[0] = 3;
	 dstmap[1] = 0;
      }
      dstmap[2] = ZERO;		/* ? */
      dstmap[3] = ONE;		/* ? */
      
      _mesa_swizzle_ubyte_image(ctx, dims,
				GL_LUMINANCE_ALPHA, /* hack */
				GL_UNSIGNED_BYTE, /* hack */
				GL_LUMINANCE_ALPHA, /* hack */
				dstmap, 2,
				dstAddr, dstXoffset, dstYoffset, dstZoffset,
				dstRowStride, dstImageOffsets,
				srcWidth, srcHeight, srcDepth, srcAddr,
				srcPacking);      
   }   
   else {
      /* general path - note this is defined for 2d textures only */
      const GLint components = _mesa_components_in_format(baseInternalFormat);
      const GLint srcStride = _mesa_image_row_stride(srcPacking, srcWidth,
                                                     srcFormat, srcType);
      GLbyte *tempImage, *dst, *src;
      GLint row;

      tempImage = (GLbyte *) malloc(srcWidth * srcHeight * srcDepth
                                          * components * sizeof(GLbyte));
      if (!tempImage)
         return GL_FALSE;

      src = (GLbyte *) _mesa_image_address(dims, srcPacking, srcAddr,
                                           srcWidth, srcHeight,
                                           srcFormat, srcType,
                                           0, 0, 0);

      dst = tempImage;
      for (row = 0; row < srcHeight; row++) {
         _mesa_unpack_dudv_span_byte(ctx, srcWidth, baseInternalFormat,
                                     dst, srcFormat, srcType, src,
                                     srcPacking, 0);
         dst += srcWidth * components;
         src += srcStride;
      }
 
      src = tempImage;
      dst = (GLbyte *) dstAddr
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
      for (row = 0; row < srcHeight; row++) {
         memcpy(dst, src, srcWidth * texelBytes);
         dst += dstRowStride;
         src += srcWidth * texelBytes;
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}


/**
 * Store a texture in MESA_FORMAT_SIGNED_R8 format.
 */
static GLboolean
_mesa_texstore_signed_r8(TEXSTORE_PARAMS)
{
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_SIGNED_R8);
   ASSERT(texelBytes == 1);

   /* XXX look at adding optimized paths */
   {
      /* general path */
      const GLfloat *tempImage = make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *srcRow = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * texelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
         for (row = 0; row < srcHeight; row++) {
            GLubyte *dstB = (GLubyte *) dstRow;
            for (col = 0; col < srcWidth; col++) {
               dstB[col] = FLOAT_TO_BYTE_TEX(srcRow[RCOMP]);
            }
            dstRow += dstRowStride;
         }
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}


/**
 * Store a texture in MESA_FORMAT_SIGNED_RG88 format.
 */
static GLboolean
_mesa_texstore_signed_rg88(TEXSTORE_PARAMS)
{
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_SIGNED_RG88);
   ASSERT(texelBytes == 1);

   /* XXX look at adding optimized paths */
   {
      /* general path */
      const GLfloat *tempImage = make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *srcRow = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * texelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
         for (row = 0; row < srcHeight; row++) {
            GLushort *dstUS = (GLushort *) dstRow;
            for (col = 0; col < srcWidth; col++) {
               dstUS[col] = PACK_COLOR_88(FLOAT_TO_BYTE_TEX(srcRow[RCOMP]),
                                          FLOAT_TO_BYTE_TEX(srcRow[GCOMP]));
            }
            dstRow += dstRowStride;
         }
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}


/**
 * Store a texture in MESA_FORMAT_SIGNED_RGBX8888.
 */
static GLboolean
_mesa_texstore_signed_rgbx8888(TEXSTORE_PARAMS)
{
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_SIGNED_RGBX8888);
   ASSERT(texelBytes == 4);

   {
      /* general path */
      const GLfloat *tempImage = make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *srcRow = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * texelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
         for (row = 0; row < srcHeight; row++) {
            GLuint *dstUI = (GLuint *) dstRow;
            for (col = 0; col < srcWidth; col++) {
               dstUI[col] = PACK_COLOR_8888( FLOAT_TO_BYTE_TEX(srcRow[RCOMP]),
                                             FLOAT_TO_BYTE_TEX(srcRow[GCOMP]),
                                             FLOAT_TO_BYTE_TEX(srcRow[BCOMP]),
                                             0xff );
               srcRow += 4;
            }
            dstRow += dstRowStride;
         }
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}



/**
 * Store a texture in MESA_FORMAT_SIGNED_RGBA8888 or
 * MESA_FORMAT_SIGNED_RGBA8888_REV
 */
static GLboolean
_mesa_texstore_signed_rgba8888(TEXSTORE_PARAMS)
{
   const GLboolean littleEndian = _mesa_little_endian();
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_SIGNED_RGBA8888 ||
          dstFormat == MESA_FORMAT_SIGNED_RGBA8888_REV);
   ASSERT(texelBytes == 4);

   if (!ctx->_ImageTransferState &&
       !srcPacking->SwapBytes &&
       dstFormat == MESA_FORMAT_SIGNED_RGBA8888 &&
       baseInternalFormat == GL_RGBA &&
      ((srcFormat == GL_RGBA && srcType == GL_BYTE && !littleEndian) ||
       (srcFormat == GL_ABGR_EXT && srcType == GL_BYTE && littleEndian))) {
       /* simple memcpy path */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else if (!ctx->_ImageTransferState &&
       !srcPacking->SwapBytes &&
       dstFormat == MESA_FORMAT_SIGNED_RGBA8888_REV &&
       baseInternalFormat == GL_RGBA &&
      ((srcFormat == GL_RGBA && srcType == GL_BYTE && littleEndian) ||
       (srcFormat == GL_ABGR_EXT && srcType == GL_BYTE && !littleEndian))) {
      /* simple memcpy path */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else if (!ctx->_ImageTransferState &&
	    (srcType == GL_BYTE) &&
	    can_swizzle(baseInternalFormat) &&
	    can_swizzle(srcFormat)) {

      GLubyte dstmap[4];

      /* dstmap - how to swizzle from RGBA to dst format:
       */
      if ((littleEndian && dstFormat == MESA_FORMAT_SIGNED_RGBA8888) ||
	  (!littleEndian && dstFormat == MESA_FORMAT_SIGNED_RGBA8888_REV)) {
	 dstmap[3] = 0;
	 dstmap[2] = 1;
	 dstmap[1] = 2;
	 dstmap[0] = 3;
      }
      else {
	 dstmap[3] = 3;
	 dstmap[2] = 2;
	 dstmap[1] = 1;
	 dstmap[0] = 0;
      }
      
      _mesa_swizzle_ubyte_image(ctx, dims,
				srcFormat,
				srcType,
				baseInternalFormat,
				dstmap, 4,
				dstAddr, dstXoffset, dstYoffset, dstZoffset,
				dstRowStride, dstImageOffsets,
				srcWidth, srcHeight, srcDepth, srcAddr,
				srcPacking);      
   }
   else {
      /* general path */
      const GLfloat *tempImage = make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *srcRow = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * texelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
         for (row = 0; row < srcHeight; row++) {
            GLuint *dstUI = (GLuint *) dstRow;
            if (dstFormat == MESA_FORMAT_SIGNED_RGBA8888) {
               for (col = 0; col < srcWidth; col++) {
                  dstUI[col] = PACK_COLOR_8888( FLOAT_TO_BYTE_TEX(srcRow[RCOMP]),
                                                FLOAT_TO_BYTE_TEX(srcRow[GCOMP]),
                                                FLOAT_TO_BYTE_TEX(srcRow[BCOMP]),
                                                FLOAT_TO_BYTE_TEX(srcRow[ACOMP]) );
                  srcRow += 4;
               }
            }
            else {
               for (col = 0; col < srcWidth; col++) {
                  dstUI[col] = PACK_COLOR_8888_REV( FLOAT_TO_BYTE_TEX(srcRow[RCOMP]),
                                                    FLOAT_TO_BYTE_TEX(srcRow[GCOMP]),
                                                    FLOAT_TO_BYTE_TEX(srcRow[BCOMP]),
                                                    FLOAT_TO_BYTE_TEX(srcRow[ACOMP]) );
                  srcRow += 4;
               }
            }
            dstRow += dstRowStride;
         }
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}


/**
 * Store a combined depth/stencil texture image.
 */
static GLboolean
_mesa_texstore_z24_s8(TEXSTORE_PARAMS)
{
   const GLuint depthScale = 0xffffff;
   const GLint srcRowStride
      = _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType)
      / sizeof(GLuint);
   GLint img, row;

   ASSERT(dstFormat == MESA_FORMAT_Z24_S8);
   ASSERT(srcFormat == GL_DEPTH_STENCIL_EXT ||
          srcFormat == GL_DEPTH_COMPONENT ||
          srcFormat == GL_STENCIL_INDEX);
   ASSERT(srcFormat != GL_DEPTH_STENCIL_EXT || srcType == GL_UNSIGNED_INT_24_8_EXT);

   if (srcFormat == GL_DEPTH_STENCIL && ctx->Pixel.DepthScale == 1.0f &&
       ctx->Pixel.DepthBias == 0.0f &&
       !srcPacking->SwapBytes) {
      /* simple path */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else if (srcFormat == GL_DEPTH_COMPONENT ||
            srcFormat == GL_STENCIL_INDEX) {
      /* In case we only upload depth we need to preserve the stencil */
      for (img = 0; img < srcDepth; img++) {
	 GLuint *dstRow = (GLuint *) dstAddr
            + dstImageOffsets[dstZoffset + img]
            + dstYoffset * dstRowStride / sizeof(GLuint)
            + dstXoffset;
         const GLuint *src
            = (const GLuint *) _mesa_image_address(dims, srcPacking, srcAddr,
                  srcWidth, srcHeight,
                  srcFormat, srcType,
                  img, 0, 0);
         for (row = 0; row < srcHeight; row++) {
            GLuint depth[MAX_WIDTH];
	    GLubyte stencil[MAX_WIDTH];
            GLint i;
	    GLboolean keepdepth = GL_FALSE, keepstencil = GL_FALSE;

	    if (srcFormat == GL_DEPTH_COMPONENT) { /* preserve stencil */
	       keepstencil = GL_TRUE;
	    }
            else if (srcFormat == GL_STENCIL_INDEX) { /* preserve depth */
	       keepdepth = GL_TRUE;
	    }

	    if (keepdepth == GL_FALSE)
	       /* the 24 depth bits will be in the low position: */
	       _mesa_unpack_depth_span(ctx, srcWidth,
				       GL_UNSIGNED_INT, /* dst type */
				       keepstencil ? depth : dstRow, /* dst addr */
				       depthScale,
				       srcType, src, srcPacking);

	    if (keepstencil == GL_FALSE)
	       /* get the 8-bit stencil values */
	       _mesa_unpack_stencil_span(ctx, srcWidth,
					 GL_UNSIGNED_BYTE, /* dst type */
					 stencil, /* dst addr */
					 srcType, src, srcPacking,
					 ctx->_ImageTransferState);

	    for (i = 0; i < srcWidth; i++) {
	       if (keepstencil)
		  dstRow[i] = depth[i] << 8 | (dstRow[i] & 0x000000FF);
	       else
		  dstRow[i] = (dstRow[i] & 0xFFFFFF00) | (stencil[i] & 0xFF);
	    }

            src += srcRowStride;
            dstRow += dstRowStride / sizeof(GLuint);
         }
      }
   }
   return GL_TRUE;
}


/**
 * Store a combined depth/stencil texture image.
 */
static GLboolean
_mesa_texstore_s8_z24(TEXSTORE_PARAMS)
{
   const GLuint depthScale = 0xffffff;
   const GLint srcRowStride
      = _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType)
      / sizeof(GLuint);
   GLint img, row;

   ASSERT(dstFormat == MESA_FORMAT_S8_Z24);
   ASSERT(srcFormat == GL_DEPTH_STENCIL_EXT ||
          srcFormat == GL_DEPTH_COMPONENT ||
          srcFormat == GL_STENCIL_INDEX);
   ASSERT(srcFormat != GL_DEPTH_STENCIL_EXT ||
          srcType == GL_UNSIGNED_INT_24_8_EXT);

   for (img = 0; img < srcDepth; img++) {
      GLuint *dstRow = (GLuint *) dstAddr
	 + dstImageOffsets[dstZoffset + img]
	 + dstYoffset * dstRowStride / sizeof(GLuint)
	 + dstXoffset;
      const GLuint *src
	 = (const GLuint *) _mesa_image_address(dims, srcPacking, srcAddr,
						srcWidth, srcHeight,
						srcFormat, srcType,
						img, 0, 0);
      for (row = 0; row < srcHeight; row++) {
	 GLuint depth[MAX_WIDTH];
	 GLubyte stencil[MAX_WIDTH];
	 GLint i;
	 GLboolean keepdepth = GL_FALSE, keepstencil = GL_FALSE;
	 
	 if (srcFormat == GL_DEPTH_COMPONENT) { /* preserve stencil */
	    keepstencil = GL_TRUE;
	 }
         else if (srcFormat == GL_STENCIL_INDEX) { /* preserve depth */
	    keepdepth = GL_TRUE;
	 }

	 if (keepdepth == GL_FALSE)
	    /* the 24 depth bits will be in the low position: */
	    _mesa_unpack_depth_span(ctx, srcWidth,
				    GL_UNSIGNED_INT, /* dst type */
				    keepstencil ? depth : dstRow, /* dst addr */
				    depthScale,
				    srcType, src, srcPacking);	 

	 if (keepstencil == GL_FALSE)
	    /* get the 8-bit stencil values */
	    _mesa_unpack_stencil_span(ctx, srcWidth,
				      GL_UNSIGNED_BYTE, /* dst type */
				      stencil, /* dst addr */
				      srcType, src, srcPacking,
				      ctx->_ImageTransferState);

	 /* merge stencil values into depth values */
	 for (i = 0; i < srcWidth; i++) {
	    if (keepstencil)
	       dstRow[i] = depth[i] | (dstRow[i] & 0xFF000000);
	    else
	       dstRow[i] = (dstRow[i] & 0xFFFFFF) | (stencil[i] << 24);

	 }
	 src += srcRowStride;
	 dstRow += dstRowStride / sizeof(GLuint);
      }
   }
   return GL_TRUE;
}


/**
 * Store simple 8-bit/value stencil texture data.
 */
static GLboolean
_mesa_texstore_s8(TEXSTORE_PARAMS)
{
   ASSERT(dstFormat == MESA_FORMAT_S8);
   ASSERT(srcFormat == GL_STENCIL_INDEX);

   if (!ctx->_ImageTransferState &&
       !srcPacking->SwapBytes &&
       baseInternalFormat == srcFormat &&
       srcType == GL_UNSIGNED_BYTE) {
      /* simple memcpy path */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else {
      const GLint srcRowStride
	 = _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType)
	 / sizeof(GLuint);
      GLint img, row;
      
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img]
            + dstYoffset * dstRowStride / sizeof(GLuint)
            + dstXoffset;
         const GLuint *src
            = (const GLuint *) _mesa_image_address(dims, srcPacking, srcAddr,
                                                   srcWidth, srcHeight,
                                                   srcFormat, srcType,
                                                   img, 0, 0);
         for (row = 0; row < srcHeight; row++) {
            GLubyte stencil[MAX_WIDTH];
            GLint i;

            /* get the 8-bit stencil values */
            _mesa_unpack_stencil_span(ctx, srcWidth,
                                      GL_UNSIGNED_BYTE, /* dst type */
                                      stencil, /* dst addr */
                                      srcType, src, srcPacking,
                                      ctx->_ImageTransferState);
            /* merge stencil values into depth values */
            for (i = 0; i < srcWidth; i++)
               dstRow[i] = stencil[i];

            src += srcRowStride;
            dstRow += dstRowStride / sizeof(GLubyte);
         }
      }

   }

   return GL_TRUE;
}


/**
 * Store an image in any of the formats:
 *   _mesa_texformat_rgba_float32
 *   _mesa_texformat_rgb_float32
 *   _mesa_texformat_alpha_float32
 *   _mesa_texformat_luminance_float32
 *   _mesa_texformat_luminance_alpha_float32
 *   _mesa_texformat_intensity_float32
 */
static GLboolean
_mesa_texstore_rgba_float32(TEXSTORE_PARAMS)
{
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
   const GLint components = _mesa_components_in_format(baseFormat);

   ASSERT(dstFormat == MESA_FORMAT_RGBA_FLOAT32 ||
          dstFormat == MESA_FORMAT_RGB_FLOAT32 ||
          dstFormat == MESA_FORMAT_ALPHA_FLOAT32 ||
          dstFormat == MESA_FORMAT_LUMINANCE_FLOAT32 ||
          dstFormat == MESA_FORMAT_LUMINANCE_ALPHA_FLOAT32 ||
          dstFormat == MESA_FORMAT_INTENSITY_FLOAT32);
   ASSERT(baseInternalFormat == GL_RGBA ||
          baseInternalFormat == GL_RGB ||
          baseInternalFormat == GL_ALPHA ||
          baseInternalFormat == GL_LUMINANCE ||
          baseInternalFormat == GL_LUMINANCE_ALPHA ||
          baseInternalFormat == GL_INTENSITY);
   ASSERT(texelBytes == components * sizeof(GLfloat));

   if (!ctx->_ImageTransferState &&
       !srcPacking->SwapBytes &&
       baseInternalFormat == srcFormat &&
       srcType == GL_FLOAT) {
      /* simple memcpy path */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else {
      /* general path */
      const GLfloat *tempImage = make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *srcRow = tempImage;
      GLint bytesPerRow;
      GLint img, row;
      if (!tempImage)
         return GL_FALSE;
      bytesPerRow = srcWidth * components * sizeof(GLfloat);
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * texelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
         for (row = 0; row < srcHeight; row++) {
            memcpy(dstRow, srcRow, bytesPerRow);
            dstRow += dstRowStride;
            srcRow += srcWidth * components;
         }
      }

      free((void *) tempImage);
   }
   return GL_TRUE;
}



/**
 * As above, but store 16-bit floats.
 */
static GLboolean
_mesa_texstore_rgba_float16(TEXSTORE_PARAMS)
{
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
   const GLint components = _mesa_components_in_format(baseFormat);

   ASSERT(dstFormat == MESA_FORMAT_RGBA_FLOAT16 ||
          dstFormat == MESA_FORMAT_RGB_FLOAT16 ||
          dstFormat == MESA_FORMAT_ALPHA_FLOAT16 ||
          dstFormat == MESA_FORMAT_LUMINANCE_FLOAT16 ||
          dstFormat == MESA_FORMAT_LUMINANCE_ALPHA_FLOAT16 ||
          dstFormat == MESA_FORMAT_INTENSITY_FLOAT16);
   ASSERT(baseInternalFormat == GL_RGBA ||
          baseInternalFormat == GL_RGB ||
          baseInternalFormat == GL_ALPHA ||
          baseInternalFormat == GL_LUMINANCE ||
          baseInternalFormat == GL_LUMINANCE_ALPHA ||
          baseInternalFormat == GL_INTENSITY);
   ASSERT(texelBytes == components * sizeof(GLhalfARB));
a2342 25
   if (!ctx->_ImageTransferState &&
       !srcPacking->SwapBytes &&
       baseInternalFormat == srcFormat &&
       srcType == GL_HALF_FLOAT_ARB) {
      /* simple memcpy path */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else {
      /* general path */
      const GLfloat *tempImage = make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *src = tempImage;
      GLint img, row;
      if (!tempImage)
         return GL_FALSE;
d2344 9
a2352 4
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * texelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
d2354 1
a2354 1
            GLhalfARB *dstTexel = (GLhalfARB *) dstRow;
d2356 15
a2370 7
            for (i = 0; i < srcWidth * components; i++) {
               dstTexel[i] = _mesa_float_to_half(src[i]);
            }
            dstRow += dstRowStride;
            src += srcWidth * components;
         }
      }
d2372 2
a2373 62
      free((void *) tempImage);
   }
   return GL_TRUE;
}


/* non-normalized, signed int8 */
static GLboolean
_mesa_texstore_rgba_int8(TEXSTORE_PARAMS)
{
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
   const GLint components = _mesa_components_in_format(baseFormat);

   ASSERT(dstFormat == MESA_FORMAT_RGBA_INT8);
   ASSERT(baseInternalFormat == GL_RGBA ||
          baseInternalFormat == GL_RGB ||
          baseInternalFormat == GL_ALPHA ||
          baseInternalFormat == GL_LUMINANCE ||
          baseInternalFormat == GL_LUMINANCE_ALPHA ||
          baseInternalFormat == GL_INTENSITY);
   ASSERT(texelBytes == components * sizeof(GLbyte));

   /* Note: Pixel transfer ops (scale, bias, table lookup) do not apply
    * to integer formats.
    */
   if (!srcPacking->SwapBytes &&
       baseInternalFormat == srcFormat &&
       srcType == GL_BYTE) {
      /* simple memcpy path */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else {
      /* general path */
      const GLfloat *tempImage = make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking, 0x0);
      const GLfloat *src = tempImage;
      GLint img, row;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * texelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
         for (row = 0; row < srcHeight; row++) {
            GLbyte *dstTexel = (GLbyte *) dstRow;
            GLint i;
            for (i = 0; i < srcWidth * components; i++) {
               dstTexel[i] = (GLbyte) src[i];
            }
            dstRow += dstRowStride;
            src += srcWidth * components;
a2375 2

      free((void *) tempImage);
a2380 7
/* non-normalized, signed int16 */
static GLboolean
_mesa_texstore_rgba_int16(TEXSTORE_PARAMS)
{
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
   const GLint components = _mesa_components_in_format(baseFormat);
d2382 11
a2392 60
   ASSERT(dstFormat == MESA_FORMAT_RGBA_INT16);
   ASSERT(baseInternalFormat == GL_RGBA ||
          baseInternalFormat == GL_RGB ||
          baseInternalFormat == GL_ALPHA ||
          baseInternalFormat == GL_LUMINANCE ||
          baseInternalFormat == GL_LUMINANCE_ALPHA ||
          baseInternalFormat == GL_INTENSITY);
   ASSERT(texelBytes == components * sizeof(GLshort));

   /* Note: Pixel transfer ops (scale, bias, table lookup) do not apply
    * to integer formats.
    */
   if (!srcPacking->SwapBytes &&
       baseInternalFormat == srcFormat &&
       srcType == GL_SHORT) {
      /* simple memcpy path */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else {
      /* general path */
      const GLfloat *tempImage = make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking, 0x0);
      const GLfloat *src = tempImage;
      GLint img, row;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * texelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
         for (row = 0; row < srcHeight; row++) {
            GLshort *dstTexel = (GLshort *) dstRow;
            GLint i;
            for (i = 0; i < srcWidth * components; i++) {
               dstTexel[i] = (GLint) src[i];
            }
            dstRow += dstRowStride;
            src += srcWidth * components;
         }
      }

      free((void *) tempImage);
   }
   return GL_TRUE;
}


/* non-normalized, signed int32 */
static GLboolean
_mesa_texstore_rgba_int32(TEXSTORE_PARAMS)
d2394 1
a2394 3
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
   const GLint components = _mesa_components_in_format(baseFormat);
d2396 6
a2401 1
   ASSERT(dstFormat == MESA_FORMAT_RGBA_INT32);
d2408 1
a2408 1
   ASSERT(texelBytes == components * sizeof(GLint));
d2410 2
a2411 4
   /* Note: Pixel transfer ops (scale, bias, table lookup) do not apply
    * to integer formats.
    */
   if (!srcPacking->SwapBytes &&
d2413 1
a2413 1
       srcType == GL_INT) {
d2426 1
a2426 1
                                                 baseFormat,
d2429 3
a2431 128
                                                 srcPacking, 0x0);
      const GLfloat *src = tempImage;
      GLint img, row;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * texelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
         for (row = 0; row < srcHeight; row++) {
            GLint *dstTexel = (GLint *) dstRow;
            GLint i;
            for (i = 0; i < srcWidth * components; i++) {
               dstTexel[i] = (GLint) src[i];
            }
            dstRow += dstRowStride;
            src += srcWidth * components;
         }
      }

      free((void *) tempImage);
   }
   return GL_TRUE;
}


/* non-normalized, unsigned int8 */
static GLboolean
_mesa_texstore_rgba_uint8(TEXSTORE_PARAMS)
{
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
   const GLint components = _mesa_components_in_format(baseFormat);

   ASSERT(dstFormat == MESA_FORMAT_RGBA_UINT8);
   ASSERT(baseInternalFormat == GL_RGBA ||
          baseInternalFormat == GL_RGB ||
          baseInternalFormat == GL_ALPHA ||
          baseInternalFormat == GL_LUMINANCE ||
          baseInternalFormat == GL_LUMINANCE_ALPHA ||
          baseInternalFormat == GL_INTENSITY);
   ASSERT(texelBytes == components * sizeof(GLubyte));

   /* Note: Pixel transfer ops (scale, bias, table lookup) do not apply
    * to integer formats.
    */
   if (!srcPacking->SwapBytes &&
       baseInternalFormat == srcFormat &&
       srcType == GL_UNSIGNED_BYTE) {
      /* simple memcpy path */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else {
      /* general path */
      const GLuint *tempImage =
         make_temp_uint_image(ctx, dims, baseInternalFormat, baseFormat,
                              srcWidth, srcHeight, srcDepth,
                              srcFormat, srcType, srcAddr, srcPacking);
      const GLuint *src = tempImage;
      GLint img, row;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = (GLubyte *) dstAddr
            + dstImageOffsets[dstZoffset + img] * texelBytes
            + dstYoffset * dstRowStride
            + dstXoffset * texelBytes;
         for (row = 0; row < srcHeight; row++) {
            GLubyte *dstTexel = (GLubyte *) dstRow;
            GLint i;
            for (i = 0; i < srcWidth * components; i++) {
               dstTexel[i] = (GLubyte) CLAMP(src[i], 0, 0xff);
            }
            dstRow += dstRowStride;
            src += srcWidth * components;
         }
      }

      free((void *) tempImage);
   }
   return GL_TRUE;
}


/* non-normalized, unsigned int16 */
static GLboolean
_mesa_texstore_rgba_uint16(TEXSTORE_PARAMS)
{
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
   const GLint components = _mesa_components_in_format(baseFormat);

   ASSERT(dstFormat == MESA_FORMAT_RGBA_UINT16);
   ASSERT(baseInternalFormat == GL_RGBA ||
          baseInternalFormat == GL_RGB ||
          baseInternalFormat == GL_ALPHA ||
          baseInternalFormat == GL_LUMINANCE ||
          baseInternalFormat == GL_LUMINANCE_ALPHA ||
          baseInternalFormat == GL_INTENSITY);
   ASSERT(texelBytes == components * sizeof(GLushort));

   /* Note: Pixel transfer ops (scale, bias, table lookup) do not apply
    * to integer formats.
    */
   if (!srcPacking->SwapBytes &&
       baseInternalFormat == srcFormat &&
       srcType == GL_UNSIGNED_SHORT) {
      /* simple memcpy path */
      memcpy_texture(ctx, dims,
                     dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                     dstRowStride,
                     dstImageOffsets,
                     srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                     srcAddr, srcPacking);
   }
   else {
      /* general path */
      const GLuint *tempImage =
         make_temp_uint_image(ctx, dims, baseInternalFormat, baseFormat,
                              srcWidth, srcHeight, srcDepth,
                              srcFormat, srcType, srcAddr, srcPacking);
      const GLuint *src = tempImage;
d2435 2
d2439 1
a2439 1
            + dstImageOffsets[dstZoffset + img] * texelBytes
d2441 1
a2441 1
            + dstXoffset * texelBytes;
d2443 1
a2443 5
            GLushort *dstTexel = (GLushort *) dstRow;
            GLint i;
            for (i = 0; i < srcWidth * components; i++) {
               dstTexel[i] = (GLushort) CLAMP(src[i], 0, 0xffff);
            }
d2445 1
a2445 1
            src += srcWidth * components;
d2449 1
a2449 1
      free((void *) tempImage);
d2455 5
a2459 3
/* non-normalized, unsigned int32 */
static GLboolean
_mesa_texstore_rgba_uint32(TEXSTORE_PARAMS)
d2461 1
a2461 3
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
   const GLint components = _mesa_components_in_format(baseFormat);
d2463 6
a2468 1
   ASSERT(dstFormat == MESA_FORMAT_RGBA_UINT32);
d2475 1
a2475 1
   ASSERT(texelBytes == components * sizeof(GLuint));
d2477 2
a2478 4
   /* Note: Pixel transfer ops (scale, bias, table lookup) do not apply
    * to integer formats.
    */
   if (!srcPacking->SwapBytes &&
d2480 1
a2480 1
       srcType == GL_UNSIGNED_INT) {
d2491 7
a2497 5
      const GLuint *tempImage =
         make_temp_uint_image(ctx, dims, baseInternalFormat, baseFormat,
                              srcWidth, srcHeight, srcDepth,
                              srcFormat, srcType, srcAddr, srcPacking);
      const GLuint *src = tempImage;
d2501 1
d2504 1
a2504 1
            + dstImageOffsets[dstZoffset + img] * texelBytes
d2506 1
a2506 1
            + dstXoffset * texelBytes;
d2508 1
a2508 1
            GLuint *dstTexel = (GLuint *) dstRow;
d2511 1
a2511 1
               dstTexel[i] = src[i];
d2518 1
a2518 1
      free((void *) tempImage);
a2523 2


d2525 1
a2525 1
static GLboolean
d2528 3
a2530 1
   gl_format newDstFormat;
d2533 1
a2533 1
   ASSERT(dstFormat == MESA_FORMAT_SRGB8);
d2536 16
a2551 9
   newDstFormat = MESA_FORMAT_RGB888;

   k = _mesa_texstore_rgb888(ctx, dims, baseInternalFormat,
                             newDstFormat, dstAddr,
                             dstXoffset, dstYoffset, dstZoffset,
                             dstRowStride, dstImageOffsets,
                             srcWidth, srcHeight, srcDepth,
                             srcFormat, srcType,
                             srcAddr, srcPacking);
d2556 1
a2556 1
static GLboolean
d2559 2
a2560 1
   gl_format newDstFormat;
d2563 1
a2563 1
   ASSERT(dstFormat == MESA_FORMAT_SRGBA8);
d2566 5
a2570 1
   newDstFormat = MESA_FORMAT_RGBA8888;
d2582 1
a2582 23
static GLboolean
_mesa_texstore_sargb8(TEXSTORE_PARAMS)
{
   gl_format newDstFormat;
   GLboolean k;

   ASSERT(dstFormat == MESA_FORMAT_SARGB8);

   /* reuse normal rgba texstore code */
   newDstFormat = MESA_FORMAT_ARGB8888;

   k = _mesa_texstore_argb8888(ctx, dims, baseInternalFormat,
                               newDstFormat, dstAddr,
                               dstXoffset, dstYoffset, dstZoffset,
                               dstRowStride, dstImageOffsets,
                               srcWidth, srcHeight, srcDepth,
                               srcFormat, srcType,
                               srcAddr, srcPacking);
   return k;
}


static GLboolean
d2585 1
a2585 1
   gl_format newDstFormat;
d2588 1
a2588 1
   ASSERT(dstFormat == MESA_FORMAT_SL8);
d2590 1
a2590 1
   newDstFormat = MESA_FORMAT_L8;
d2604 1
a2604 1
static GLboolean
d2607 2
a2608 1
   gl_format newDstFormat;
d2611 1
a2611 1
   ASSERT(dstFormat == MESA_FORMAT_SLA8);
d2614 4
a2617 1
   newDstFormat = MESA_FORMAT_AL88;
d2619 7
a2625 7
   k = _mesa_texstore_unorm88(ctx, dims, baseInternalFormat,
			      newDstFormat, dstAddr,
			      dstXoffset, dstYoffset, dstZoffset,
			      dstRowStride, dstImageOffsets,
			      srcWidth, srcHeight, srcDepth,
			      srcFormat, srcType,
			      srcAddr, srcPacking);
a2628 9
#else

/* these are used only in texstore_funcs[] below */
#define _mesa_texstore_srgb8 NULL
#define _mesa_texstore_srgba8 NULL
#define _mesa_texstore_sargb8 NULL
#define _mesa_texstore_sl8 NULL
#define _mesa_texstore_sla8 NULL

a2631 166


/**
 * Table mapping MESA_FORMAT_* to _mesa_texstore_*()
 * XXX this is somewhat temporary.
 */
static const struct {
   gl_format Name;
   StoreTexImageFunc Store;
}
texstore_funcs[MESA_FORMAT_COUNT] =
{
   { MESA_FORMAT_NONE, NULL },
   { MESA_FORMAT_RGBA8888, _mesa_texstore_rgba8888 },
   { MESA_FORMAT_RGBA8888_REV, _mesa_texstore_rgba8888 },
   { MESA_FORMAT_ARGB8888, _mesa_texstore_argb8888 },
   { MESA_FORMAT_ARGB8888_REV, _mesa_texstore_argb8888 },
   { MESA_FORMAT_XRGB8888, _mesa_texstore_argb8888 },
   { MESA_FORMAT_XRGB8888_REV, _mesa_texstore_argb8888 },
   { MESA_FORMAT_RGB888, _mesa_texstore_rgb888 },
   { MESA_FORMAT_BGR888, _mesa_texstore_bgr888 },
   { MESA_FORMAT_RGB565, _mesa_texstore_rgb565 },
   { MESA_FORMAT_RGB565_REV, _mesa_texstore_rgb565 },
   { MESA_FORMAT_ARGB4444, _mesa_texstore_argb4444 },
   { MESA_FORMAT_ARGB4444_REV, _mesa_texstore_argb4444 },
   { MESA_FORMAT_RGBA5551, _mesa_texstore_rgba5551 },
   { MESA_FORMAT_ARGB1555, _mesa_texstore_argb1555 },
   { MESA_FORMAT_ARGB1555_REV, _mesa_texstore_argb1555 },
   { MESA_FORMAT_AL88, _mesa_texstore_unorm88 },
   { MESA_FORMAT_AL88_REV, _mesa_texstore_unorm88 },
   { MESA_FORMAT_AL1616, _mesa_texstore_unorm1616 },
   { MESA_FORMAT_AL1616_REV, _mesa_texstore_unorm1616 },
   { MESA_FORMAT_RGB332, _mesa_texstore_rgb332 },
   { MESA_FORMAT_A8, _mesa_texstore_a8 },
   { MESA_FORMAT_L8, _mesa_texstore_a8 },
   { MESA_FORMAT_I8, _mesa_texstore_a8 },
   { MESA_FORMAT_CI8, _mesa_texstore_ci8 },
   { MESA_FORMAT_YCBCR, _mesa_texstore_ycbcr },
   { MESA_FORMAT_YCBCR_REV, _mesa_texstore_ycbcr },
   { MESA_FORMAT_R8, _mesa_texstore_a8 },
   { MESA_FORMAT_RG88, _mesa_texstore_unorm88 },
   { MESA_FORMAT_RG88_REV, _mesa_texstore_unorm88 },
   { MESA_FORMAT_R16, _mesa_texstore_r16 },
   { MESA_FORMAT_RG1616, _mesa_texstore_unorm1616 },
   { MESA_FORMAT_RG1616_REV, _mesa_texstore_unorm1616 },
   { MESA_FORMAT_Z24_S8, _mesa_texstore_z24_s8 },
   { MESA_FORMAT_S8_Z24, _mesa_texstore_s8_z24 },
   { MESA_FORMAT_Z16, _mesa_texstore_z16 },
   { MESA_FORMAT_X8_Z24, _mesa_texstore_x8_z24 },
   { MESA_FORMAT_Z24_X8, _mesa_texstore_z24_x8 },
   { MESA_FORMAT_Z32, _mesa_texstore_z32 },
   { MESA_FORMAT_S8, _mesa_texstore_s8 },
   { MESA_FORMAT_SRGB8, _mesa_texstore_srgb8 },
   { MESA_FORMAT_SRGBA8, _mesa_texstore_srgba8 },
   { MESA_FORMAT_SARGB8, _mesa_texstore_sargb8 },
   { MESA_FORMAT_SL8, _mesa_texstore_sl8 },
   { MESA_FORMAT_SLA8, _mesa_texstore_sla8 },
   { MESA_FORMAT_SRGB_DXT1, _mesa_texstore_rgb_dxt1 },
   { MESA_FORMAT_SRGBA_DXT1, _mesa_texstore_rgba_dxt1 },
   { MESA_FORMAT_SRGBA_DXT3, _mesa_texstore_rgba_dxt3 },
   { MESA_FORMAT_SRGBA_DXT5, _mesa_texstore_rgba_dxt5 },
   { MESA_FORMAT_RGB_FXT1, _mesa_texstore_rgb_fxt1 },
   { MESA_FORMAT_RGBA_FXT1, _mesa_texstore_rgba_fxt1 },
   { MESA_FORMAT_RGB_DXT1, _mesa_texstore_rgb_dxt1 },
   { MESA_FORMAT_RGBA_DXT1, _mesa_texstore_rgba_dxt1 },
   { MESA_FORMAT_RGBA_DXT3, _mesa_texstore_rgba_dxt3 },
   { MESA_FORMAT_RGBA_DXT5, _mesa_texstore_rgba_dxt5 },
   { MESA_FORMAT_RGBA_FLOAT32, _mesa_texstore_rgba_float32 },
   { MESA_FORMAT_RGBA_FLOAT16, _mesa_texstore_rgba_float16 },
   { MESA_FORMAT_RGB_FLOAT32, _mesa_texstore_rgba_float32 },
   { MESA_FORMAT_RGB_FLOAT16, _mesa_texstore_rgba_float16 },
   { MESA_FORMAT_ALPHA_FLOAT32, _mesa_texstore_rgba_float32 },
   { MESA_FORMAT_ALPHA_FLOAT16, _mesa_texstore_rgba_float16 },
   { MESA_FORMAT_LUMINANCE_FLOAT32, _mesa_texstore_rgba_float32 },
   { MESA_FORMAT_LUMINANCE_FLOAT16, _mesa_texstore_rgba_float16 },
   { MESA_FORMAT_LUMINANCE_ALPHA_FLOAT32, _mesa_texstore_rgba_float32 },
   { MESA_FORMAT_LUMINANCE_ALPHA_FLOAT16, _mesa_texstore_rgba_float16 },
   { MESA_FORMAT_INTENSITY_FLOAT32, _mesa_texstore_rgba_float32 },
   { MESA_FORMAT_INTENSITY_FLOAT16, _mesa_texstore_rgba_float16 },

   { MESA_FORMAT_RGBA_INT8, _mesa_texstore_rgba_int8 },
   { MESA_FORMAT_RGBA_INT16, _mesa_texstore_rgba_int16 },
   { MESA_FORMAT_RGBA_INT32, _mesa_texstore_rgba_int32 },
   { MESA_FORMAT_RGBA_UINT8, _mesa_texstore_rgba_uint8 },
   { MESA_FORMAT_RGBA_UINT16, _mesa_texstore_rgba_uint16 },
   { MESA_FORMAT_RGBA_UINT32, _mesa_texstore_rgba_uint32 },

   { MESA_FORMAT_DUDV8, _mesa_texstore_dudv8 },

   { MESA_FORMAT_SIGNED_R8, _mesa_texstore_signed_r8 },
   { MESA_FORMAT_SIGNED_RG88, _mesa_texstore_signed_rg88 },
   { MESA_FORMAT_SIGNED_RGBX8888, _mesa_texstore_signed_rgbx8888 },

   { MESA_FORMAT_SIGNED_RGBA8888, _mesa_texstore_signed_rgba8888 },
   { MESA_FORMAT_SIGNED_RGBA8888_REV, _mesa_texstore_signed_rgba8888 },

   { MESA_FORMAT_SIGNED_R_16, _mesa_texstore_signed_rgba_16 },
   { MESA_FORMAT_SIGNED_RG_16, _mesa_texstore_signed_rgba_16 },
   { MESA_FORMAT_SIGNED_RGB_16, _mesa_texstore_signed_rgba_16 },
   { MESA_FORMAT_SIGNED_RGBA_16, _mesa_texstore_signed_rgba_16 },
   { MESA_FORMAT_RGBA_16, _mesa_texstore_rgba_16 }
};


static GLboolean
_mesa_texstore_null(TEXSTORE_PARAMS)
{
   (void) ctx; (void) dims;
   (void) baseInternalFormat;
   (void) dstFormat;
   (void) dstAddr;
   (void) dstXoffset; (void) dstYoffset; (void) dstZoffset;
   (void) dstRowStride; (void) dstImageOffsets;
   (void) srcWidth; (void) srcHeight; (void) srcDepth;
   (void) srcFormat; (void) srcType;
   (void) srcAddr;
   (void) srcPacking;

   /* should never happen */
   _mesa_problem(NULL, "_mesa_texstore_null() is called");
   return GL_FALSE;
}


/**
 * Return the StoreTexImageFunc pointer to store an image in the given format.
 */
static StoreTexImageFunc
_mesa_get_texstore_func(gl_format format)
{
#ifdef DEBUG
   GLuint i;
   for (i = 0; i < MESA_FORMAT_COUNT; i++) {
      ASSERT(texstore_funcs[i].Name == i);
   }
#endif
   ASSERT(texstore_funcs[format].Name == format);

   if (texstore_funcs[format].Store)
      return texstore_funcs[format].Store;
   else
      return _mesa_texstore_null;
}


/**
 * Store user data into texture memory.
 * Called via glTex[Sub]Image1/2/3D()
 */
GLboolean
_mesa_texstore(TEXSTORE_PARAMS)
{
   StoreTexImageFunc storeImage;
   GLboolean success;

   storeImage = _mesa_get_texstore_func(dstFormat);

   success = storeImage(ctx, dims, baseInternalFormat,
                        dstFormat, dstAddr, dstXoffset, dstYoffset, dstZoffset,
                        dstRowStride, dstImageOffsets,
                        srcWidth, srcHeight, srcDepth,
                        srcFormat, srcType, srcAddr, srcPacking);
   return success;
}


d2639 1
a2639 1
_mesa_validate_pbo_teximage(struct gl_context *ctx, GLuint dimensions,
d2647 1
a2647 1
   if (!_mesa_is_bufferobj(unpack->BufferObj)) {
d2653 1
a2653 1
      _mesa_error(ctx, GL_INVALID_OPERATION, funcName, "(invalid PBO access)");
d2660 1
a2660 1
      _mesa_error(ctx, GL_INVALID_OPERATION, funcName, "(PBO is mapped)");
d2676 1
a2676 1
_mesa_validate_pbo_compressed_teximage(struct gl_context *ctx,
d2683 1
a2683 1
   if (!_mesa_is_bufferobj(packing->BufferObj)) {
d2690 1
a2690 1
      _mesa_error(ctx, GL_INVALID_OPERATION, funcName, "(invalid PBO access)");
d2710 1
a2710 1
_mesa_unmap_teximage_pbo(struct gl_context *ctx,
d2713 1
a2713 1
   if (_mesa_is_bufferobj(unpack->BufferObj)) {
d2720 7
a2726 3
/** Return texture size in bytes */
static GLuint
texture_size(const struct gl_texture_image *texImage)
d2728 15
a2742 3
   GLuint sz = _mesa_format_image_size(texImage->TexFormat, texImage->Width,
                                       texImage->Height, texImage->Depth);
   return sz;
d2746 6
a2751 3
/** Return row stride in bytes */
static GLuint
texture_row_stride(const struct gl_texture_image *texImage)
d2753 15
a2767 3
   GLuint stride = _mesa_format_row_stride(texImage->TexFormat,
                                           texImage->Width);
   return stride;
d2771 39
d2812 43
d2860 1
a2860 1
_mesa_store_teximage1d(struct gl_context *ctx, GLenum target, GLint level,
d2868 2
a2869 1
   GLuint sizeInBytes;
d2872 6
d2879 4
a2882 1
   sizeInBytes = texture_size(texImage);
d2899 10
a2908 8
      GLboolean success = _mesa_texstore(ctx, 1, texImage->_BaseFormat,
                                         texImage->TexFormat,
                                         texImage->Data,
                                         0, 0, 0,  /* dstX/Y/Zoffset */
                                         dstRowStride,
                                         texImage->ImageOffsets,
                                         width, 1, 1,
                                         format, type, pixels, packing);
d2914 7
d2931 3
d2936 1
a2936 1
_mesa_store_teximage2d(struct gl_context *ctx, GLenum target, GLint level,
d2944 2
a2945 1
   GLuint sizeInBytes;
d2948 9
d2958 4
a2961 1
   sizeInBytes = texture_size(texImage);
d2977 18
a2994 9
      GLint dstRowStride = texture_row_stride(texImage);
      GLboolean success = _mesa_texstore(ctx, 2, texImage->_BaseFormat,
                                         texImage->TexFormat,
                                         texImage->Data,
                                         0, 0, 0,  /* dstX/Y/Zoffset */
                                         dstRowStride,
                                         texImage->ImageOffsets,
                                         width, height, 1,
                                         format, type, pixels, packing);
d3000 7
d3018 1
a3018 1
_mesa_store_teximage3d(struct gl_context *ctx, GLenum target, GLint level,
d3026 1
a3026 1
   GLuint sizeInBytes;
d3029 4
d3034 4
a3037 1
   sizeInBytes = texture_size(texImage);
d3053 18
a3070 9
      GLint dstRowStride = texture_row_stride(texImage);
      GLboolean success = _mesa_texstore(ctx, 3, texImage->_BaseFormat,
                                         texImage->TexFormat,
                                         texImage->Data,
                                         0, 0, 0,  /* dstX/Y/Zoffset */
                                         dstRowStride,
                                         texImage->ImageOffsets,
                                         width, height, depth,
                                         format, type, pixels, packing);
d3076 7
d3094 1
a3094 1
_mesa_store_texsubimage1d(struct gl_context *ctx, GLenum target, GLint level,
d3109 10
a3118 8
      GLboolean success = _mesa_texstore(ctx, 1, texImage->_BaseFormat,
                                         texImage->TexFormat,
                                         texImage->Data,
                                         xoffset, 0, 0,  /* offsets */
                                         dstRowStride,
                                         texImage->ImageOffsets,
                                         width, 1, 1,
                                         format, type, pixels, packing);
d3124 7
d3141 1
a3141 1
_mesa_store_texsubimage2d(struct gl_context *ctx, GLenum target, GLint level,
d3156 18
a3173 9
      GLint dstRowStride = texture_row_stride(texImage);
      GLboolean success = _mesa_texstore(ctx, 2, texImage->_BaseFormat,
                                         texImage->TexFormat,
                                         texImage->Data,
                                         xoffset, yoffset, 0,
                                         dstRowStride,
                                         texImage->ImageOffsets,
                                         width, height, 1,
                                         format, type, pixels, packing);
d3179 7
d3195 1
a3195 1
_mesa_store_texsubimage3d(struct gl_context *ctx, GLenum target, GLint level,
d3211 18
a3228 9
      GLint dstRowStride = texture_row_stride(texImage);
      GLboolean success = _mesa_texstore(ctx, 3, texImage->_BaseFormat,
                                         texImage->TexFormat,
                                         texImage->Data,
                                         xoffset, yoffset, zoffset,
                                         dstRowStride,
                                         texImage->ImageOffsets,
                                         width, height, depth,
                                         format, type, pixels, packing);
d3234 7
d3249 1
a3249 2
_mesa_store_compressed_teximage1d(struct gl_context *ctx,
                                  GLenum target, GLint level,
d3272 1
a3272 2
_mesa_store_compressed_teximage2d(struct gl_context *ctx,
                                  GLenum target, GLint level,
d3291 2
d3307 9
a3315 1
   memcpy(texImage->Data, data, imageSize);
d3326 1
a3326 2
_mesa_store_compressed_teximage3d(struct gl_context *ctx,
                                  GLenum target, GLint level,
d3351 1
a3351 1
_mesa_store_compressed_texsubimage1d(struct gl_context *ctx, GLenum target,
d3374 1
a3374 1
_mesa_store_compressed_texsubimage2d(struct gl_context *ctx, GLenum target,
d3387 1
a3387 3
   const gl_format texFormat = texImage->TexFormat;
   const GLint destWidth = texImage->Width;
   GLuint bw, bh;
a3388 3
   _mesa_get_format_block_size(texFormat, &bw, &bh);

   (void) level;
d3392 4
a3395 4
   ASSERT((width % bw) == 0 || width == 2 || width == 1);
   ASSERT((height % bh) == 0 || height == 2 || height == 1);
   ASSERT((xoffset % bw) == 0);
   ASSERT((yoffset % bh) == 0);
d3404 1
a3404 1
   srcRowStride = _mesa_format_row_stride(texFormat, width);
d3407 1
a3407 1
   destRowStride = _mesa_format_row_stride(texFormat, destWidth);
d3409 2
a3410 1
                                         texFormat, destWidth,
d3413 2
a3414 2
   bytesPerRow = srcRowStride;  /* bytes per row of blocks */
   rows = height / bh;  /* rows in blocks */
a3415 1
   /* copy rows of blocks */
d3417 1
a3417 1
      memcpy(dest, src, bytesPerRow);
d3422 7
d3437 1
a3437 1
_mesa_store_compressed_texsubimage3d(struct gl_context *ctx, GLenum target,
d3455 241
@


1.1.1.5
log
@Import Mesa 9.2.0
@
text
@d3 1
d21 3
a23 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
d40 3
a42 2
 *   ctx->Driver.TexImage = _mesa_store_teximage;
 *   ctx->Driver.TexSubImage = _mesa_store_texsubimage;
a57 1
#include "format_pack.h"
a60 1
#include "mtypes.h"
a61 1
#include "pbo.h"
d63 1
a65 1
#include "texcompress_rgtc.h"
a66 1
#include "texcompress_etc.h"
a69 3
#include "glformats.h"
#include "../../gallium/auxiliary/util/u_format_rgb9e5.h"
#include "../../gallium/auxiliary/util/u_format_r11g11b10f.h"
d311 9
a319 9
GLfloat *
_mesa_make_temp_float_image(struct gl_context *ctx, GLuint dims,
			    GLenum logicalBaseFormat,
			    GLenum textureBaseFormat,
			    GLint srcWidth, GLint srcHeight, GLint srcDepth,
			    GLenum srcFormat, GLenum srcType,
			    const GLvoid *srcAddr,
			    const struct gl_pixelstore_attrib *srcPacking,
			    GLbitfield transferOps)
d338 1
d349 1
d352 1
a352 1
   tempImage = malloc(srcWidth * srcHeight * srcDepth
d390 1
a390 1
      newImage = malloc(srcWidth * srcHeight * srcDepth
a457 1
          textureBaseFormat == GL_INTENSITY ||
d460 1
a460 1
   tempImage = malloc(srcWidth * srcHeight * srcDepth
d498 1
a498 1
      newImage = malloc(srcWidth * srcHeight * srcDepth
d513 1
a513 1
               newImage[i * texComponents + k] = 0;
d515 1
a515 1
               newImage[i * texComponents + k] = 1;
d531 1
a531 1
 * Make a temporary (color) texture image with GLubyte components.
d551 1
a551 1
 * \return resulting image with format = textureBaseFormat and type = GLubyte.
d553 8
a560 8
GLubyte *
_mesa_make_temp_ubyte_image(struct gl_context *ctx, GLuint dims,
                            GLenum logicalBaseFormat,
                            GLenum textureBaseFormat,
                            GLint srcWidth, GLint srcHeight, GLint srcDepth,
                            GLenum srcFormat, GLenum srcType,
                            const GLvoid *srcAddr,
                            const struct gl_pixelstore_attrib *srcPacking)
d565 1
a565 1
   GLubyte *tempImage, *dst;
d588 2
a589 2
   tempImage = malloc(srcWidth * srcHeight * srcDepth
                                       * components * sizeof(GLubyte));
d604 3
a606 3
         _mesa_unpack_color_span_ubyte(ctx, srcWidth, logicalBaseFormat, dst,
                                       srcFormat, srcType, src, srcPacking,
                                       transferOps);
d616 1
a616 1
      GLubyte *newImage;
d629 2
a630 2
      newImage = malloc(srcWidth * srcHeight * srcDepth
                                         * texComponents * sizeof(GLubyte));
d646 1
a646 1
               newImage[i * texComponents + k] = 255;
d849 2
d852 1
a852 1
                          GLubyte **dstSlices,
d895 3
a897 1
      GLubyte *dstImage = dstSlices[0];
d905 4
a908 1
         GLubyte *dstRow = dstSlices[img];
d929 2
d932 1
a932 1
               GLubyte **dstSlices,
d947 9
d957 6
a962 8
       dstRowStride == bytesPerRow) {
      /* memcpy image by image */
      GLint img;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstImage = dstSlices[img];
         memcpy(dstImage, srcImage, bytesPerRow * srcHeight);
         srcImage += srcImageStride;
      }
d964 2
a965 2
   else {
      /* memcpy row by row */
d969 1
a969 1
         GLubyte *dstRow = dstSlices[img];
d971 1
a971 1
            memcpy(dstRow, srcRow, bytesPerRow);
d976 1
d979 1
a979 1
}
d981 1
a981 23

/**
 * General-case function for storing a color texture images with
 * components that can be represented with ubytes.  Example destination
 * texture formats are MESA_FORMAT_ARGB888, ARGB4444, RGB565.
 */
static GLboolean
store_ubyte_texture(TEXSTORE_PARAMS)
{
   const GLint srcRowStride = srcWidth * 4 * sizeof(GLubyte);
   GLubyte *tempImage, *src;
   GLint img;

   tempImage = _mesa_make_temp_ubyte_image(ctx, dims,
                                           baseInternalFormat,
                                           GL_RGBA,
                                           srcWidth, srcHeight, srcDepth,
                                           srcFormat, srcType, srcAddr,
                                           srcPacking);
   if (!tempImage)
      return GL_FALSE;

   src = tempImage;
d983 11
a993 4
      _mesa_pack_ubyte_rgba_rect(dstFormat, srcWidth, srcHeight,
                                 src, srcRowStride,
                                 dstSlices[img], dstRowStride);
      src += srcHeight * srcRowStride;
a994 3
   free(tempImage);

   return GL_TRUE;
a998 1

d1000 1
a1000 1
 * Store a 32-bit integer or float depth component texture image.
d1006 1
a1006 1
   GLenum dstType;
d1008 2
a1009 3
   ASSERT(dstFormat == MESA_FORMAT_Z32 ||
          dstFormat == MESA_FORMAT_Z32_FLOAT);
   ASSERT(_mesa_get_format_bytes(dstFormat) == sizeof(GLuint));
d1011 15
a1025 6
   if (dstFormat == MESA_FORMAT_Z32)
      dstType = GL_UNSIGNED_INT;
   else
      dstType = GL_FLOAT;

   {
d1029 4
a1032 1
         GLubyte *dstRow = dstSlices[img];
d1037 1
a1037 1
                                    dstType, dstRow,
d1054 1
d1063 4
a1066 1
         GLubyte *dstRow = dstSlices[img];
d1088 1
d1097 4
a1100 1
         GLubyte *dstRow = dstSlices[img];
d1126 1
d1129 1
a1129 1
   ASSERT(_mesa_get_format_bytes(dstFormat) == sizeof(GLushort));
d1131 15
a1145 1
   {
d1149 4
a1152 1
         GLubyte *dstRow = dstSlices[img];
d1174 3
d1179 1
a1179 1
   ASSERT(_mesa_get_format_bytes(dstFormat) == 2);
d1183 1
d1186 15
a1200 2
       srcType == GL_UNSIGNED_BYTE &&
       dims == 2) {
d1207 3
a1209 1
      GLubyte *dst = dstSlices[0];
d1232 39
a1270 4
      return store_ubyte_texture(ctx, dims, baseInternalFormat,
                                 dstFormat, dstRowStride, dstSlices,
                                 srcWidth, srcHeight, srcDepth,
                                 srcFormat, srcType, srcAddr, srcPacking);
d1283 2
d1287 2
a1288 4
          dstFormat == MESA_FORMAT_RGBA8888_REV ||
          dstFormat == MESA_FORMAT_RGBX8888 ||
          dstFormat == MESA_FORMAT_RGBX8888_REV);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 4);
d1291 37
a1327 5
       (srcType == GL_UNSIGNED_BYTE ||
        srcType == GL_UNSIGNED_INT_8_8_8_8 ||
        srcType == GL_UNSIGNED_INT_8_8_8_8_REV) &&
       can_swizzle(baseInternalFormat) &&
       can_swizzle(srcFormat)) {
d1333 2
a1334 4
      if ((littleEndian && (dstFormat == MESA_FORMAT_RGBA8888 ||
                            dstFormat == MESA_FORMAT_RGBX8888)) ||
	  (!littleEndian && (dstFormat == MESA_FORMAT_RGBA8888_REV ||
	                     dstFormat == MESA_FORMAT_RGBX8888_REV))) {
d1352 2
a1353 1
				dstRowStride, dstSlices,
d1358 40
a1397 4
      return store_ubyte_texture(ctx, dims, baseInternalFormat,
                                 dstFormat, dstRowStride, dstSlices,
                                 srcWidth, srcHeight, srcDepth,
                                 srcFormat, srcType, srcAddr, srcPacking);
d1407 2
d1414 1
a1414 1
   ASSERT(_mesa_get_format_bytes(dstFormat) == 4);
d1420 36
a1455 4
       srcFormat == GL_RGB &&
       (baseInternalFormat == GL_RGBA ||
        baseInternalFormat == GL_RGB) &&
       srcType == GL_UNSIGNED_BYTE) {
d1462 4
a1465 1
         GLubyte *dstRow = dstSlices[img];
a1480 26
            dstFormat == MESA_FORMAT_ARGB8888 &&
            srcFormat == GL_LUMINANCE_ALPHA &&
            baseInternalFormat == GL_RGBA &&
            srcType == GL_UNSIGNED_BYTE) {
      /* special case of storing LA -> ARGB8888 */
      int img, row, col;
      const GLint srcRowStride =
         _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType);
      for (img = 0; img < srcDepth; img++) {
         const GLubyte *srcRow = (const GLubyte *)
            _mesa_image_address(dims, srcPacking, srcAddr, srcWidth,
                                srcHeight, srcFormat, srcType, img, 0, 0);
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLuint *d4 = (GLuint *) dstRow;
            for (col = 0; col < srcWidth; col++) {
               GLubyte l = srcRow[col * 2 + 0], a = srcRow[col * 2 + 1];
               d4[col] = PACK_COLOR_8888(a, l, l, l);
            }
            dstRow += dstRowStride;
            srcRow += srcRowStride;
         }
      }
   }
   else if (!ctx->_ImageTransferState &&
            !srcPacking->SwapBytes &&
d1498 4
a1501 1
         GLubyte *dstRow = dstSlices[img];
d1551 1
d1553 1
a1553 1
                                dstSlices,
d1558 49
a1606 4
      return store_ubyte_texture(ctx, dims, baseInternalFormat,
                                 dstFormat, dstRowStride, dstSlices,
                                 srcWidth, srcHeight, srcDepth,
                                 srcFormat, srcType, srcAddr, srcPacking);
d1615 4
d1620 1
a1620 1
   ASSERT(_mesa_get_format_bytes(dstFormat) == 3);
d1624 16
a1639 2
       srcFormat == GL_RGBA &&
       srcType == GL_UNSIGNED_BYTE) {
d1647 4
a1650 1
         GLubyte *dstRow = dstSlices[img];
d1681 2
a1682 1
				dstRowStride, dstSlices,
d1687 46
a1732 4
      return store_ubyte_texture(ctx, dims, baseInternalFormat,
                                 dstFormat, dstRowStride, dstSlices,
                                 srcWidth, srcHeight, srcDepth,
                                 srcFormat, srcType, srcAddr, srcPacking);
d1741 4
d1746 1
a1746 1
   ASSERT(_mesa_get_format_bytes(dstFormat) == 3);
d1750 16
a1765 2
       srcFormat == GL_RGBA &&
       srcType == GL_UNSIGNED_BYTE) {
d1773 4
a1776 1
         GLubyte *dstRow = dstSlices[img];
d1807 2
a1808 1
				dstRowStride, dstSlices,
a1812 17
      return store_ubyte_texture(ctx, dims, baseInternalFormat,
                                 dstFormat, dstRowStride, dstSlices,
                                 srcWidth, srcHeight, srcDepth,
                                 srcFormat, srcType, srcAddr, srcPacking);
   }
   return GL_TRUE;
}


static GLboolean
_mesa_texstore_argb2101010(TEXSTORE_PARAMS)
{
   ASSERT(dstFormat == MESA_FORMAT_ARGB2101010 ||
          dstFormat == MESA_FORMAT_XRGB2101010_UNORM);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 4);

   {
d1814 1
a1814 3
      /* Hardcode GL_RGBA as the base format, which forces alpha to 1.0
       * if the internal format is RGB. */
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
d1816 1
a1816 1
                                                 GL_RGBA,
d1819 2
a1820 3
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *src = tempImage;
d1825 10
a1834 15
         GLubyte *dstRow = dstSlices[img];
         if (baseInternalFormat == GL_RGBA || baseInternalFormat == GL_RGB) {
            for (row = 0; row < srcHeight; row++) {
               GLuint *dstUI = (GLuint *) dstRow;
               for (col = 0; col < srcWidth; col++) {
                  GLushort a,r,g,b;

                  UNCLAMPED_FLOAT_TO_USHORT(a, src[ACOMP]);
                  UNCLAMPED_FLOAT_TO_USHORT(r, src[RCOMP]);
                  UNCLAMPED_FLOAT_TO_USHORT(g, src[GCOMP]);
                  UNCLAMPED_FLOAT_TO_USHORT(b, src[BCOMP]);
                  dstUI[col] = PACK_COLOR_2101010_US(a, r, g, b);
                  src += 4;
               }
               dstRow += dstRowStride;
d1836 1
a1836 2
         } else {
            ASSERT(0);
a1844 3
/**
 * Do texstore for 2-channel, 4-bit/channel, unsigned normalized formats.
 */
d1846 1
a1846 1
_mesa_texstore_unorm44(TEXSTORE_PARAMS)
d1848 1
d1851 3
a1853 2
   ASSERT(dstFormat == MESA_FORMAT_AL44);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 1);
d1855 15
a1869 1
   {
d1871 1
a1871 1
      const GLubyte *tempImage = _mesa_make_temp_ubyte_image(ctx, dims,
d1877 1
a1877 1
      const GLubyte *src = tempImage;
d1882 4
a1885 1
         GLubyte *dstRow = dstSlices[img];
d1887 144
a2030 6
            GLubyte *dstUS = (GLubyte *) dstRow;
            for (col = 0; col < srcWidth; col++) {
               /* src[0] is luminance, src[1] is alpha */
               dstUS[col] = PACK_COLOR_44( src[1],
                                           src[0] );
               src += 2;
d2048 1
d2053 3
a2055 3
          dstFormat == MESA_FORMAT_GR88 ||
          dstFormat == MESA_FORMAT_RG88);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 2);
d2058 6
a2063 1
       littleEndian &&
d2065 14
a2078 2
       can_swizzle(baseInternalFormat) &&
       can_swizzle(srcFormat)) {
d2095 2
a2096 2
	 if ((littleEndian && dstFormat == MESA_FORMAT_GR88) ||
	     (!littleEndian && dstFormat == MESA_FORMAT_RG88)) {
d2113 2
a2114 1
				dstRowStride, dstSlices,
d2120 1
a2120 1
      const GLubyte *tempImage = _mesa_make_temp_ubyte_image(ctx, dims,
d2126 1
a2126 1
      const GLubyte *src = tempImage;
d2131 4
a2134 1
         GLubyte *dstRow = dstSlices[img];
d2138 1
a2138 1
		dstFormat == MESA_FORMAT_GR88) {
d2140 3
a2142 3
                  /* src[0] is luminance (or R), src[1] is alpha (or G) */
                 dstUS[col] = PACK_COLOR_88( src[1],
                                             src[0] );
d2148 3
a2150 3
                  /* src[0] is luminance (or R), src[1] is alpha (or G) */
                 dstUS[col] = PACK_COLOR_88_REV( src[1],
                                                 src[0] );
d2169 2
d2175 3
a2177 3
	  dstFormat == MESA_FORMAT_GR1616 ||
          dstFormat == MESA_FORMAT_RG1616);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 4);
d2179 18
a2196 1
   {
d2198 1
a2198 1
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
d2210 4
a2213 1
         GLubyte *dstRow = dstSlices[img];
d2217 1
a2217 1
		dstFormat == MESA_FORMAT_GR1616) {
a2245 1
/* Texstore for R16, A16, L16, I16. */
d2247 1
a2247 1
_mesa_texstore_unorm16(TEXSTORE_PARAMS)
d2249 2
d2253 2
a2254 5
   ASSERT(dstFormat == MESA_FORMAT_R16 ||
          dstFormat == MESA_FORMAT_A16 ||
          dstFormat == MESA_FORMAT_L16 ||
          dstFormat == MESA_FORMAT_I16);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 2);
d2256 16
a2271 1
   {
d2273 1
a2273 1
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
d2285 4
a2288 1
         GLubyte *dstRow = dstSlices[img];
d2310 2
a2311 3
   ASSERT(dstFormat == MESA_FORMAT_RGBA_16 ||
          dstFormat == MESA_FORMAT_XBGR16161616_UNORM);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 8);
d2313 17
a2329 1
   {
d2331 1
a2331 3
      /* Hardcode GL_RGBA as the base format, which forces alpha to 1.0
       * if the internal format is RGB. */
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
d2333 1
a2333 1
                                                 GL_RGBA,
a2339 1

a2341 1

d2343 4
a2346 1
         GLubyte *dstRow = dstSlices[img];
d2374 1
d2377 4
a2380 3
   ASSERT(dstFormat == MESA_FORMAT_SIGNED_RGB_16 ||
          dstFormat == MESA_FORMAT_SIGNED_RGBA_16 ||
          dstFormat == MESA_FORMAT_XBGR16161616_SNORM);
d2382 15
a2396 1
   {
d2398 1
a2398 1
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
d2416 4
a2419 1
         GLubyte *dstRow = dstSlices[img];
d2422 6
a2427 8
            if (dstFormat == MESA_FORMAT_SIGNED_RGBA_16) {
               for (col = 0; col < srcWidth; col++) {
                  GLuint c;
                  for (c = 0; c < comps; c++) {
                     GLshort p;
                     UNCLAMPED_FLOAT_TO_SHORT(p, src[col * 4 + c]);
                     dstRowS[col * comps + c] = p;
                  }
a2428 2
               dstRow += dstRowStride;
               src += 4 * srcWidth;
d2430 18
a2447 3
            else if (dstFormat == MESA_FORMAT_XBGR16161616_SNORM) {
               for (col = 0; col < srcWidth; col++) {
                  GLuint c;
d2449 35
a2483 21
                  for (c = 0; c < 3; c++) {
                     GLshort p;
                     UNCLAMPED_FLOAT_TO_SHORT(p, src[col * 3 + c]);
                     dstRowS[col * comps + c] = p;
                  }
                  dstRowS[col * comps + 3] = 32767;
               }
               dstRow += dstRowStride;
               src += 3 * srcWidth;
            }
            else {
               for (col = 0; col < srcWidth; col++) {
                  GLuint c;
                  for (c = 0; c < comps; c++) {
                     GLshort p;
                     UNCLAMPED_FLOAT_TO_SHORT(p, src[col * 3 + c]);
                     dstRowS[col * comps + c] = p;
                  }
               }
               dstRow += dstRowStride;
               src += 3 * srcWidth;
d2485 1
d2498 1
a2498 1
_mesa_texstore_unorm8(TEXSTORE_PARAMS)
d2500 1
d2507 1
a2507 1
   ASSERT(_mesa_get_format_bytes(dstFormat) == 1);
d2510 15
a2524 3
       srcType == GL_UNSIGNED_BYTE &&
       can_swizzle(baseInternalFormat) &&
       can_swizzle(srcFormat)) {
d2544 2
a2545 1
				dstRowStride, dstSlices,
d2551 1
a2551 1
      const GLubyte *tempImage = _mesa_make_temp_ubyte_image(ctx, dims,
d2557 1
a2557 1
      const GLubyte *src = tempImage;
d2562 4
a2565 1
         GLubyte *dstRow = dstSlices[img];
d2568 1
a2568 1
               dstRow[col] = src[col];
d2581 44
d2632 1
d2638 1
a2638 1
   ASSERT(_mesa_get_format_bytes(dstFormat) == 2);
d2647 3
a2649 2
                  dstFormat,
                  dstRowStride, dstSlices,
d2661 4
a2664 1
         GLubyte *dstRow = dstSlices[img];
d2687 11
a2697 1
   if (srcType == GL_BYTE) {
d2718 2
a2719 1
				dstRowStride, dstSlices,
d2731 1
a2731 1
      tempImage = malloc(srcWidth * srcHeight * srcDepth
d2751 3
a2753 1
      dst = (GLbyte *) dstSlices[0];
d2766 1
a2766 1
 * Store a texture in a signed normalized 8-bit format.
d2769 1
a2769 1
_mesa_texstore_snorm8(TEXSTORE_PARAMS)
d2771 1
d2774 2
a2775 5
   ASSERT(dstFormat == MESA_FORMAT_SIGNED_A8 ||
          dstFormat == MESA_FORMAT_SIGNED_L8 ||
          dstFormat == MESA_FORMAT_SIGNED_I8 ||
          dstFormat == MESA_FORMAT_SIGNED_R8);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 1);
d2777 1
d2780 1
a2780 1
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
d2787 1
a2787 1
      const GLfloat *src = tempImage;
d2792 4
a2795 1
         GLbyte *dstRow = (GLbyte *) dstSlices[img];
d2797 1
d2799 1
a2799 1
               dstRow[col] = FLOAT_TO_BYTE_TEX(src[col]);
a2801 1
            src += srcWidth;
d2811 1
a2811 1
 * Store a texture in a signed normalized two-channel 16-bit format.
d2814 1
a2814 1
_mesa_texstore_snorm88(TEXSTORE_PARAMS)
d2816 1
d2819 2
a2820 3
   ASSERT(dstFormat == MESA_FORMAT_SIGNED_AL88 ||
          dstFormat == MESA_FORMAT_SIGNED_RG88_REV);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 2);
d2822 1
d2825 1
a2825 1
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
d2832 1
a2832 1
      const GLfloat *src = tempImage;
d2837 4
a2840 1
         GLbyte *dstRow = (GLbyte *) dstSlices[img];
d2842 1
a2842 1
            GLbyte *dst = dstRow;
d2844 2
a2845 4
               dst[0] = FLOAT_TO_BYTE_TEX(src[0]);
               dst[1] = FLOAT_TO_BYTE_TEX(src[1]);
               src += 2;
               dst += 2;
a2854 43
/* Texstore for signed R16, A16, L16, I16. */
static GLboolean
_mesa_texstore_snorm16(TEXSTORE_PARAMS)
{
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_SIGNED_R16 ||
          dstFormat == MESA_FORMAT_SIGNED_A16 ||
          dstFormat == MESA_FORMAT_SIGNED_L16 ||
          dstFormat == MESA_FORMAT_SIGNED_I16);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 2);

   {
      /* general path */
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *src = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLshort *dstUS = (GLshort *) dstRow;
	    for (col = 0; col < srcWidth; col++) {
	       GLushort r;

	       UNCLAMPED_FLOAT_TO_SHORT(r, src[0]);
	       dstUS[col] = r;
	       src += 1;
	    }
            dstRow += dstRowStride;
         }
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}
d2857 1
a2857 1
 * Do texstore for 2-channel, 16-bit/channel, signed normalized formats.
d2860 1
a2860 1
_mesa_texstore_snorm1616(TEXSTORE_PARAMS)
d2862 1
d2865 2
a2866 3
   ASSERT(dstFormat == MESA_FORMAT_SIGNED_AL1616 ||
          dstFormat == MESA_FORMAT_SIGNED_GR1616);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 4);
d2870 1
a2870 1
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
d2877 1
a2877 1
      const GLfloat *src = tempImage;
d2882 4
a2885 1
         GLubyte *dstRow = dstSlices[img];
d2887 1
a2887 1
            GLshort *dst = (GLshort *) dstRow;
d2889 5
a2893 8
               GLushort l, a;

               UNCLAMPED_FLOAT_TO_SHORT(l, src[0]);
               UNCLAMPED_FLOAT_TO_SHORT(a, src[1]);
               dst[0] = l;
               dst[1] = a;
               src += 2;
               dst += 2;
d2903 2
d2906 2
a2907 2
 * Store a texture in MESA_FORMAT_SIGNED_RGBX8888 or
 * MESA_FORMAT_XBGR8888_SNORM.
d2910 1
a2910 1
_mesa_texstore_signed_rgbx8888(TEXSTORE_PARAMS)
d2912 2
d2916 3
a2918 3
   ASSERT(dstFormat == MESA_FORMAT_SIGNED_RGBX8888 ||
          dstFormat == MESA_FORMAT_XBGR8888_SNORM);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 4);
d2920 49
a2968 39
   {
      /* general path */
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *srcRow = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLbyte *dstRow = (GLbyte *) dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLbyte *dst = dstRow;
            if (dstFormat == MESA_FORMAT_SIGNED_RGBX8888) {
               for (col = 0; col < srcWidth; col++) {
                  dst[3] = FLOAT_TO_BYTE_TEX(srcRow[RCOMP]);
                  dst[2] = FLOAT_TO_BYTE_TEX(srcRow[GCOMP]);
                  dst[1] = FLOAT_TO_BYTE_TEX(srcRow[BCOMP]);
                  dst[0] = 127;
                  srcRow += 3;
                  dst += 4;
               }
            }
            else {
               for (col = 0; col < srcWidth; col++) {
                  dst[0] = FLOAT_TO_BYTE_TEX(srcRow[RCOMP]);
                  dst[1] = FLOAT_TO_BYTE_TEX(srcRow[GCOMP]);
                  dst[2] = FLOAT_TO_BYTE_TEX(srcRow[BCOMP]);
                  dst[3] = 127;
                  srcRow += 3;
                  dst += 4;
               }
            }
            dstRow += dstRowStride;
         }
d2970 10
a2979 1
      free((void *) tempImage);
d2981 1
a2981 19
   return GL_TRUE;
}



/**
 * Store a texture in MESA_FORMAT_SIGNED_RGBA8888 or
 * MESA_FORMAT_SIGNED_RGBA8888_REV
 */
static GLboolean
_mesa_texstore_signed_rgba8888(TEXSTORE_PARAMS)
{
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_SIGNED_RGBA8888 ||
          dstFormat == MESA_FORMAT_SIGNED_RGBA8888_REV);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 4);

   {
d2983 1
a2983 1
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
d2995 4
a2998 1
         GLbyte *dstRow = (GLbyte *) dstSlices[img];
d3000 1
a3000 1
            GLbyte *dst = dstRow;
d3003 4
a3006 4
                  dst[3] = FLOAT_TO_BYTE_TEX(srcRow[RCOMP]);
                  dst[2] = FLOAT_TO_BYTE_TEX(srcRow[GCOMP]);
                  dst[1] = FLOAT_TO_BYTE_TEX(srcRow[BCOMP]);
                  dst[0] = FLOAT_TO_BYTE_TEX(srcRow[ACOMP]);
a3007 1
                  dst += 4;
d3012 4
a3015 4
                  dst[0] = FLOAT_TO_BYTE_TEX(srcRow[RCOMP]);
                  dst[1] = FLOAT_TO_BYTE_TEX(srcRow[GCOMP]);
                  dst[2] = FLOAT_TO_BYTE_TEX(srcRow[BCOMP]);
                  dst[3] = FLOAT_TO_BYTE_TEX(srcRow[ACOMP]);
a3016 1
                  dst += 4;
d3036 2
a3037 1
      = _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType);
d3046 13
a3058 11
   if (srcFormat == GL_DEPTH_COMPONENT ||
       srcFormat == GL_STENCIL_INDEX) {
      GLuint *depth = malloc(srcWidth * sizeof(GLuint));
      GLubyte *stencil = malloc(srcWidth * sizeof(GLubyte));

      if (!depth || !stencil) {
         free(depth);
         free(stencil);
         return GL_FALSE;
      }

d3061 6
a3066 3
	 GLuint *dstRow = (GLuint *) dstSlices[img];
         const GLubyte *src
            = (const GLubyte *) _mesa_image_address(dims, srcPacking, srcAddr,
d3071 2
a3109 3

      free(depth);
      free(stencil);
d3123 2
a3124 1
      = _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType);
a3125 2
   GLuint *depth;
   GLubyte *stencil;
a3133 9
   depth = malloc(srcWidth * sizeof(GLuint));
   stencil = malloc(srcWidth * sizeof(GLubyte));

   if (!depth || !stencil) {
      free(depth);
      free(stencil);
      return GL_FALSE;
   }

d3135 6
a3140 3
      GLuint *dstRow = (GLuint *) dstSlices[img];
      const GLubyte *src
	 = (const GLubyte *) _mesa_image_address(dims, srcPacking, srcAddr,
d3145 2
a3184 4

   free(depth);
   free(stencil);

d3198 13
a3210 1
   {
d3212 2
a3213 1
	 = _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType);
d3215 1
a3215 5
      GLubyte *stencil = malloc(srcWidth * sizeof(GLubyte));

      if (!stencil)
         return GL_FALSE;

d3217 6
a3222 3
         GLubyte *dstRow = dstSlices[img];
         const GLubyte *src
            = (const GLubyte *) _mesa_image_address(dims, srcPacking, srcAddr,
d3227 1
a3244 1
      free(stencil);
d3263 3
a3265 8
   GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
   GLint components = _mesa_components_in_format(baseFormat);

   /* this forces alpha to 1 in _mesa_make_temp_float_image */
   if (dstFormat == MESA_FORMAT_XBGR32323232_FLOAT) {
      baseFormat = GL_RGBA;
      components = 4;
   }
d3272 1
a3272 4
          dstFormat == MESA_FORMAT_INTENSITY_FLOAT32 ||
          dstFormat == MESA_FORMAT_R_FLOAT32 ||
          dstFormat == MESA_FORMAT_RG_FLOAT32 ||
          dstFormat == MESA_FORMAT_XBGR32323232_FLOAT);
d3278 2
a3279 4
          baseInternalFormat == GL_INTENSITY ||
          baseInternalFormat == GL_RED ||
          baseInternalFormat == GL_RG);
   ASSERT(_mesa_get_format_bytes(dstFormat) == components * sizeof(GLfloat));
d3281 13
a3293 1
   {
d3295 1
a3295 1
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
d3309 4
a3312 1
         GLubyte *dstRow = dstSlices[img];
d3333 3
a3335 8
   GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
   GLint components = _mesa_components_in_format(baseFormat);

   /* this forces alpha to 1 in _mesa_make_temp_float_image */
   if (dstFormat == MESA_FORMAT_XBGR16161616_FLOAT) {
      baseFormat = GL_RGBA;
      components = 4;
   }
d3342 1
a3342 4
          dstFormat == MESA_FORMAT_INTENSITY_FLOAT16 ||
          dstFormat == MESA_FORMAT_R_FLOAT16 ||
          dstFormat == MESA_FORMAT_RG_FLOAT16 ||
          dstFormat == MESA_FORMAT_XBGR16161616_FLOAT);
d3348 2
a3349 4
          baseInternalFormat == GL_INTENSITY ||
          baseInternalFormat == GL_RED ||
          baseInternalFormat == GL_RG);
   ASSERT(_mesa_get_format_bytes(dstFormat) == components * sizeof(GLhalfARB));
d3351 13
a3363 1
   {
d3365 1
a3365 1
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
d3377 4
a3380 1
         GLubyte *dstRow = dstSlices[img];
d3402 3
a3404 2
   GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
   GLint components = _mesa_components_in_format(baseFormat);
d3406 1
a3406 15
   /* this forces alpha to 1 in make_temp_uint_image */
   if (dstFormat == MESA_FORMAT_XBGR8888_SINT) {
      baseFormat = GL_RGBA;
      components = 4;
   }

   ASSERT(dstFormat == MESA_FORMAT_R_INT8 ||
          dstFormat == MESA_FORMAT_RG_INT8 ||
          dstFormat == MESA_FORMAT_RGB_INT8 ||
          dstFormat == MESA_FORMAT_RGBA_INT8 ||
          dstFormat == MESA_FORMAT_ALPHA_INT8 ||
          dstFormat == MESA_FORMAT_INTENSITY_INT8 ||
          dstFormat == MESA_FORMAT_LUMINANCE_INT8 ||
          dstFormat == MESA_FORMAT_LUMINANCE_ALPHA_INT8 ||
          dstFormat == MESA_FORMAT_XBGR8888_SINT);
a3408 2
          baseInternalFormat == GL_RG ||
          baseInternalFormat == GL_RED ||
d3413 1
a3413 1
   ASSERT(_mesa_get_format_bytes(dstFormat) == components * sizeof(GLbyte));
d3415 15
a3429 1
   {
d3431 7
a3437 8
      const GLuint *tempImage = make_temp_uint_image(ctx, dims,
						     baseInternalFormat,
						     baseFormat,
						     srcWidth, srcHeight, srcDepth,
						     srcFormat, srcType,
						     srcAddr,
						     srcPacking);
      const GLuint *src = tempImage;
a3438 1
      GLboolean is_unsigned = _mesa_is_type_unsigned(srcType);
d3442 4
a3445 1
         GLubyte *dstRow = dstSlices[img];
d3449 2
a3450 8
            if (is_unsigned) {
               for (i = 0; i < srcWidth * components; i++) {
                  dstTexel[i] = (GLbyte) MIN2(src[i], 0x7f);
               }
            } else {
               for (i = 0; i < srcWidth * components; i++) {
                  dstTexel[i] = (GLbyte) CLAMP((GLint) src[i], -0x80, 0x7f);
               }
d3467 3
a3469 2
   GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
   GLint components = _mesa_components_in_format(baseFormat);
d3471 1
a3471 15
   /* this forces alpha to 1 in make_temp_uint_image */
   if (dstFormat == MESA_FORMAT_XBGR16161616_SINT) {
      baseFormat = GL_RGBA;
      components = 4;
   }

   ASSERT(dstFormat == MESA_FORMAT_R_INT16 ||
          dstFormat == MESA_FORMAT_RG_INT16 ||
          dstFormat == MESA_FORMAT_RGB_INT16 ||
          dstFormat == MESA_FORMAT_RGBA_INT16 ||
          dstFormat == MESA_FORMAT_ALPHA_INT16 ||
          dstFormat == MESA_FORMAT_LUMINANCE_INT16 ||
          dstFormat == MESA_FORMAT_INTENSITY_INT16 ||
          dstFormat == MESA_FORMAT_LUMINANCE_ALPHA_INT16 ||
          dstFormat == MESA_FORMAT_XBGR16161616_SINT);
a3473 2
          baseInternalFormat == GL_RG ||
          baseInternalFormat == GL_RED ||
d3478 1
a3478 1
   ASSERT(_mesa_get_format_bytes(dstFormat) == components * sizeof(GLshort));
d3480 15
a3494 1
   {
d3496 7
a3502 8
      const GLuint *tempImage = make_temp_uint_image(ctx, dims,
						     baseInternalFormat,
						     baseFormat,
						     srcWidth, srcHeight, srcDepth,
						     srcFormat, srcType,
						     srcAddr,
						     srcPacking);
      const GLuint *src = tempImage;
a3503 1
      GLboolean is_unsigned = _mesa_is_type_unsigned(srcType);
d3507 4
a3510 1
         GLubyte *dstRow = dstSlices[img];
d3514 2
a3515 8
            if (is_unsigned) {
               for (i = 0; i < srcWidth * components; i++) {
                  dstTexel[i] = (GLshort) MIN2(src[i], 0x7fff);
               }
            } else {
               for (i = 0; i < srcWidth * components; i++) {
                  dstTexel[i] = (GLshort)CLAMP((GLint) src[i], -0x8000, 0x7fff);
               }
d3532 3
a3534 2
   GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
   GLint components = _mesa_components_in_format(baseFormat);
d3536 1
a3536 15
   /* this forces alpha to 1 in make_temp_uint_image */
   if (dstFormat == MESA_FORMAT_XBGR32323232_SINT) {
      baseFormat = GL_RGBA;
      components = 4;
   }

   ASSERT(dstFormat == MESA_FORMAT_R_INT32 ||
          dstFormat == MESA_FORMAT_RG_INT32 ||
          dstFormat == MESA_FORMAT_RGB_INT32 ||
          dstFormat == MESA_FORMAT_RGBA_INT32 ||
          dstFormat == MESA_FORMAT_ALPHA_INT32 ||
          dstFormat == MESA_FORMAT_INTENSITY_INT32 ||
          dstFormat == MESA_FORMAT_LUMINANCE_INT32 ||
          dstFormat == MESA_FORMAT_LUMINANCE_ALPHA_INT32 ||
          dstFormat == MESA_FORMAT_XBGR32323232_SINT);
a3538 2
          baseInternalFormat == GL_RG ||
          baseInternalFormat == GL_RED ||
d3543 1
a3543 1
   ASSERT(_mesa_get_format_bytes(dstFormat) == components * sizeof(GLint));
d3545 15
a3559 1
   {
d3561 7
a3567 8
      const GLuint *tempImage = make_temp_uint_image(ctx, dims,
						     baseInternalFormat,
						     baseFormat,
						     srcWidth, srcHeight, srcDepth,
						     srcFormat, srcType,
						     srcAddr,
						     srcPacking);
      const GLuint *src = tempImage;
a3568 1
      GLboolean is_unsigned = _mesa_is_type_unsigned(srcType);
d3572 4
a3575 1
         GLubyte *dstRow = dstSlices[img];
d3579 2
a3580 8
            if (is_unsigned) {
               for (i = 0; i < srcWidth * components; i++) {
                  dstTexel[i] = (GLint) MIN2(src[i], 0x7fffffff);
               }
            } else {
               for (i = 0; i < srcWidth * components; i++) {
                  dstTexel[i] = (GLint) src[i];
               }
d3597 3
a3599 2
   GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
   GLint components = _mesa_components_in_format(baseFormat);
d3601 1
a3601 15
   /* this forces alpha to 1 in make_temp_uint_image */
   if (dstFormat == MESA_FORMAT_XBGR8888_UINT) {
      baseFormat = GL_RGBA;
      components = 4;
   }

   ASSERT(dstFormat == MESA_FORMAT_R_UINT8 ||
          dstFormat == MESA_FORMAT_RG_UINT8 ||
          dstFormat == MESA_FORMAT_RGB_UINT8 ||
          dstFormat == MESA_FORMAT_RGBA_UINT8 ||
          dstFormat == MESA_FORMAT_ALPHA_UINT8 ||
          dstFormat == MESA_FORMAT_INTENSITY_UINT8 ||
          dstFormat == MESA_FORMAT_LUMINANCE_UINT8 ||
          dstFormat == MESA_FORMAT_LUMINANCE_ALPHA_UINT8 ||
          dstFormat == MESA_FORMAT_XBGR8888_UINT);
a3603 2
          baseInternalFormat == GL_RG ||
          baseInternalFormat == GL_RED ||
d3608 1
a3608 1
   ASSERT(_mesa_get_format_bytes(dstFormat) == components * sizeof(GLubyte));
d3610 15
a3624 1
   {
a3631 1
      GLboolean is_unsigned = _mesa_is_type_unsigned(srcType);
d3635 4
a3638 1
         GLubyte *dstRow = dstSlices[img];
d3642 2
a3643 8
            if (is_unsigned) {
               for (i = 0; i < srcWidth * components; i++) {
                  dstTexel[i] = (GLubyte) MIN2(src[i], 0xff);
               }
            } else {
               for (i = 0; i < srcWidth * components; i++) {
                  dstTexel[i] = (GLubyte) CLAMP((GLint) src[i], 0, 0xff);
               }
d3660 3
a3662 2
   GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
   GLint components = _mesa_components_in_format(baseFormat);
d3664 1
a3664 15
   /* this forces alpha to 1 in make_temp_uint_image */
   if (dstFormat == MESA_FORMAT_XBGR16161616_UINT) {
      baseFormat = GL_RGBA;
      components = 4;
   }

   ASSERT(dstFormat == MESA_FORMAT_R_UINT16 ||
          dstFormat == MESA_FORMAT_RG_UINT16 ||
          dstFormat == MESA_FORMAT_RGB_UINT16 ||
          dstFormat == MESA_FORMAT_RGBA_UINT16 ||
          dstFormat == MESA_FORMAT_ALPHA_UINT16 ||
          dstFormat == MESA_FORMAT_INTENSITY_UINT16 ||
          dstFormat == MESA_FORMAT_LUMINANCE_UINT16 ||
          dstFormat == MESA_FORMAT_LUMINANCE_ALPHA_UINT16 ||
          dstFormat == MESA_FORMAT_XBGR16161616_UINT);
a3666 2
          baseInternalFormat == GL_RG ||
          baseInternalFormat == GL_RED ||
d3671 1
a3671 1
   ASSERT(_mesa_get_format_bytes(dstFormat) == components * sizeof(GLushort));
d3673 15
a3687 1
   {
a3694 1
      GLboolean is_unsigned = _mesa_is_type_unsigned(srcType);
d3698 4
a3701 1
         GLubyte *dstRow = dstSlices[img];
d3705 2
a3706 8
            if (is_unsigned) {
               for (i = 0; i < srcWidth * components; i++) {
                  dstTexel[i] = (GLushort) MIN2(src[i], 0xffff);
              }
            } else {
               for (i = 0; i < srcWidth * components; i++) {
                  dstTexel[i] = (GLushort) CLAMP((GLint) src[i], 0, 0xffff);
               }
d3723 3
a3725 2
   GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
   GLint components = _mesa_components_in_format(baseFormat);
d3727 1
a3727 15
   /* this forces alpha to 1 in make_temp_uint_image */
   if (dstFormat == MESA_FORMAT_XBGR32323232_UINT) {
      baseFormat = GL_RGBA;
      components = 4;
   }

   ASSERT(dstFormat == MESA_FORMAT_R_UINT32 ||
          dstFormat == MESA_FORMAT_RG_UINT32 ||
          dstFormat == MESA_FORMAT_RGB_UINT32 ||
          dstFormat == MESA_FORMAT_RGBA_UINT32 ||
          dstFormat == MESA_FORMAT_ALPHA_UINT32 ||
          dstFormat == MESA_FORMAT_INTENSITY_UINT32 ||
          dstFormat == MESA_FORMAT_LUMINANCE_UINT32 ||
          dstFormat == MESA_FORMAT_LUMINANCE_ALPHA_UINT32 ||
          dstFormat == MESA_FORMAT_XBGR32323232_UINT);
a3729 2
          baseInternalFormat == GL_RG ||
          baseInternalFormat == GL_RED ||
d3734 1
a3734 1
   ASSERT(_mesa_get_format_bytes(dstFormat) == components * sizeof(GLuint));
d3736 15
a3750 1
   {
a3756 1
      GLboolean is_unsigned = _mesa_is_type_unsigned(srcType);
d3761 4
a3764 1
         GLubyte *dstRow = dstSlices[img];
d3768 2
a3769 8
            if (is_unsigned) {
               for (i = 0; i < srcWidth * components; i++) {
                  dstTexel[i] = src[i];
               }
            } else {
               for (i = 0; i < srcWidth * components; i++) {
                  dstTexel[i] = MAX2((GLint) src[i], 0);
               }
d3782 3
d3797 3
a3799 2
                             newDstFormat,
                             dstRowStride, dstSlices,
d3813 1
a3813 2
   ASSERT(dstFormat == MESA_FORMAT_SRGBA8 ||
          dstFormat == MESA_FORMAT_XBGR8888_SRGB);
d3816 1
a3816 11
   if (dstFormat == MESA_FORMAT_SRGBA8) {
      newDstFormat = MESA_FORMAT_RGBA8888;
   }
   else if (dstFormat == MESA_FORMAT_XBGR8888_SRGB) {
      newDstFormat = MESA_FORMAT_RGBX8888_REV;
   }
   else {
      ASSERT(0);
      return GL_TRUE;
   }

d3818 3
a3820 2
                               newDstFormat,
                               dstRowStride, dstSlices,
d3840 3
a3842 2
                               newDstFormat,
                               dstRowStride, dstSlices,
d3861 7
a3867 6
   k = _mesa_texstore_unorm8(ctx, dims, baseInternalFormat,
                             newDstFormat,
                             dstRowStride, dstSlices,
                             srcWidth, srcHeight, srcDepth,
                             srcFormat, srcType,
                             srcAddr, srcPacking);
d3884 3
a3886 2
			      newDstFormat,
			      dstRowStride, dstSlices,
d3893 1
a3893 7
static GLboolean
_mesa_texstore_rgb9_e5(TEXSTORE_PARAMS)
{
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_RGB9_E5_FLOAT);
   ASSERT(baseInternalFormat == GL_RGB);
d3895 6
a3900 24
   {
      /* general path */
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *srcRow = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLuint *dstUI = (GLuint*)dstRow;
            for (col = 0; col < srcWidth; col++) {
               dstUI[col] = float3_to_rgb9e5(&srcRow[col * 3]);
            }
            dstRow += dstRowStride;
            srcRow += srcWidth * 3;
         }
      }
d3902 1
a3902 4
      free((void *) tempImage);
   }
   return GL_TRUE;
}
a3903 4
static GLboolean
_mesa_texstore_r11_g11_b10f(TEXSTORE_PARAMS)
{
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
a3904 2
   ASSERT(dstFormat == MESA_FORMAT_R11_G11_B10_FLOAT);
   ASSERT(baseInternalFormat == GL_RGB);
a3905 24
   {
      /* general path */
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *srcRow = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLuint *dstUI = (GLuint*)dstRow;
            for (col = 0; col < srcWidth; col++) {
               dstUI[col] = float3_to_r11g11b10f(&srcRow[col * 3]);
            }
            dstRow += dstRowStride;
            srcRow += srcWidth * 3;
         }
      }
d3907 7
a3913 3
      free((void *) tempImage);
   }
   return GL_TRUE;
d3915 92
d4010 1
a4010 1
_mesa_texstore_z32f_x24s8(TEXSTORE_PARAMS)
d4012 6
a4017 167
   ASSERT(dstFormat == MESA_FORMAT_Z32_FLOAT_X24S8);
   ASSERT(srcFormat == GL_DEPTH_STENCIL ||
          srcFormat == GL_DEPTH_COMPONENT ||
          srcFormat == GL_STENCIL_INDEX);
   ASSERT(srcFormat != GL_DEPTH_STENCIL ||
          srcType == GL_FLOAT_32_UNSIGNED_INT_24_8_REV);

   if (srcFormat == GL_DEPTH_COMPONENT ||
       srcFormat == GL_STENCIL_INDEX) {
      GLint img, row;
      const GLint srcRowStride
         = _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType)
         / sizeof(uint64_t);

      /* In case we only upload depth we need to preserve the stencil */
      for (img = 0; img < srcDepth; img++) {
         uint64_t *dstRow = (uint64_t *) dstSlices[img];
         const uint64_t *src
            = (const uint64_t *) _mesa_image_address(dims, srcPacking, srcAddr,
                  srcWidth, srcHeight,
                  srcFormat, srcType,
                  img, 0, 0);
         for (row = 0; row < srcHeight; row++) {
            /* The unpack functions with:
             *    dstType = GL_FLOAT_32_UNSIGNED_INT_24_8_REV
             * only write their own dword, so the other dword (stencil
             * or depth) is preserved. */
            if (srcFormat != GL_STENCIL_INDEX)
               _mesa_unpack_depth_span(ctx, srcWidth,
                                       GL_FLOAT_32_UNSIGNED_INT_24_8_REV, /* dst type */
                                       dstRow, /* dst addr */
                                       ~0U, srcType, src, srcPacking);

            if (srcFormat != GL_DEPTH_COMPONENT)
               _mesa_unpack_stencil_span(ctx, srcWidth,
                                         GL_FLOAT_32_UNSIGNED_INT_24_8_REV, /* dst type */
                                         dstRow, /* dst addr */
                                         srcType, src, srcPacking,
                                         ctx->_ImageTransferState);

            src += srcRowStride;
            dstRow += dstRowStride / sizeof(uint64_t);
         }
      }
   }
   return GL_TRUE;
}

static GLboolean
_mesa_texstore_argb2101010_uint(TEXSTORE_PARAMS)
{
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_ARGB2101010_UINT);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 4);

   {
      /* general path */
      const GLuint *tempImage = make_temp_uint_image(ctx, dims,
                                                     baseInternalFormat,
                                                     baseFormat,
                                                     srcWidth, srcHeight,
                                                     srcDepth, srcFormat,
                                                     srcType, srcAddr,
                                                     srcPacking);
      const GLuint *src = tempImage;
      GLint img, row, col;
      GLboolean is_unsigned = _mesa_is_type_unsigned(srcType);
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];

         for (row = 0; row < srcHeight; row++) {
            GLuint *dstUI = (GLuint *) dstRow;
            if (is_unsigned) {
               for (col = 0; col < srcWidth; col++) {
                  GLushort a,r,g,b;
                  r = MIN2(src[RCOMP], 0x3ff);
                  g = MIN2(src[GCOMP], 0x3ff);
                  b = MIN2(src[BCOMP], 0x3ff);
                  a = MIN2(src[ACOMP], 0x003);
                  dstUI[col] = (a << 30) | (r << 20) | (g << 10) | (b);
                  src += 4;
               }
            } else {
               for (col = 0; col < srcWidth; col++) {
                  GLushort a,r,g,b;
                  r = CLAMP((GLint) src[RCOMP], 0, 0x3ff);
                  g = CLAMP((GLint) src[GCOMP], 0, 0x3ff);
                  b = CLAMP((GLint) src[BCOMP], 0, 0x3ff);
                  a = CLAMP((GLint) src[ACOMP], 0, 0x003);
                  dstUI[col] = (a << 30) | (r << 20) | (g << 10) | (b);
                  src += 4;
               }
            }
            dstRow += dstRowStride;
         }
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}

static GLboolean
_mesa_texstore_abgr2101010_uint(TEXSTORE_PARAMS)
{
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_ABGR2101010_UINT);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 4);

   {
      /* general path */
      const GLuint *tempImage = make_temp_uint_image(ctx, dims,
                                                     baseInternalFormat,
                                                     baseFormat,
                                                     srcWidth, srcHeight,
                                                     srcDepth, srcFormat,
                                                     srcType, srcAddr,
                                                     srcPacking);
      const GLuint *src = tempImage;
      GLint img, row, col;
      GLboolean is_unsigned = _mesa_is_type_unsigned(srcType);
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];

         for (row = 0; row < srcHeight; row++) {
            GLuint *dstUI = (GLuint *) dstRow;
            if (is_unsigned) {
               for (col = 0; col < srcWidth; col++) {
                  GLushort a,r,g,b;
                  r = MIN2(src[RCOMP], 0x3ff);
                  g = MIN2(src[GCOMP], 0x3ff);
                  b = MIN2(src[BCOMP], 0x3ff);
                  a = MIN2(src[ACOMP], 0x003);
                  dstUI[col] = (a << 30) | (b << 20) | (g << 10) | (r);
                  src += 4;
               }
            } else {
               for (col = 0; col < srcWidth; col++) {
                  GLushort a,r,g,b;
                  r = CLAMP((GLint) src[RCOMP], 0, 0x3ff);
                  g = CLAMP((GLint) src[GCOMP], 0, 0x3ff);
                  b = CLAMP((GLint) src[BCOMP], 0, 0x3ff);
                  a = CLAMP((GLint) src[ACOMP], 0, 0x003);
                  dstUI[col] = (a << 30) | (b << 20) | (g << 10) | (r);
                  src += 4;
               }
            }
            dstRow += dstRowStride;
         }
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}

static GLboolean
_mesa_texstore_null(TEXSTORE_PARAMS)
{
   (void) ctx; (void) dims;
   (void) baseInternalFormat;
   (void) dstFormat;
   (void) dstRowStride; (void) dstSlices,
d4035 4
a4038 201
   static StoreTexImageFunc table[MESA_FORMAT_COUNT];
   static GLboolean initialized = GL_FALSE;

   if (!initialized) {
      table[MESA_FORMAT_NONE] = _mesa_texstore_null;

      table[MESA_FORMAT_RGBA8888] = _mesa_texstore_rgba8888;
      table[MESA_FORMAT_RGBA8888_REV] = _mesa_texstore_rgba8888;
      table[MESA_FORMAT_ARGB8888] = _mesa_texstore_argb8888;
      table[MESA_FORMAT_ARGB8888_REV] = _mesa_texstore_argb8888;
      table[MESA_FORMAT_RGBX8888] = _mesa_texstore_rgba8888;
      table[MESA_FORMAT_RGBX8888_REV] = _mesa_texstore_rgba8888;
      table[MESA_FORMAT_XRGB8888] = _mesa_texstore_argb8888;
      table[MESA_FORMAT_XRGB8888_REV] = _mesa_texstore_argb8888;
      table[MESA_FORMAT_RGB888] = _mesa_texstore_rgb888;
      table[MESA_FORMAT_BGR888] = _mesa_texstore_bgr888;
      table[MESA_FORMAT_RGB565] = _mesa_texstore_rgb565;
      table[MESA_FORMAT_RGB565_REV] = _mesa_texstore_rgb565;
      table[MESA_FORMAT_ARGB4444] = store_ubyte_texture;
      table[MESA_FORMAT_ARGB4444_REV] = store_ubyte_texture;
      table[MESA_FORMAT_RGBA5551] = store_ubyte_texture;
      table[MESA_FORMAT_ARGB1555] = store_ubyte_texture;
      table[MESA_FORMAT_ARGB1555_REV] = store_ubyte_texture;
      table[MESA_FORMAT_AL44] = _mesa_texstore_unorm44;
      table[MESA_FORMAT_AL88] = _mesa_texstore_unorm88;
      table[MESA_FORMAT_AL88_REV] = _mesa_texstore_unorm88;
      table[MESA_FORMAT_AL1616] = _mesa_texstore_unorm1616;
      table[MESA_FORMAT_AL1616_REV] = _mesa_texstore_unorm1616;
      table[MESA_FORMAT_RGB332] = store_ubyte_texture;
      table[MESA_FORMAT_A8] = _mesa_texstore_unorm8;
      table[MESA_FORMAT_A16] = _mesa_texstore_unorm16;
      table[MESA_FORMAT_L8] = _mesa_texstore_unorm8;
      table[MESA_FORMAT_L16] = _mesa_texstore_unorm16;
      table[MESA_FORMAT_I8] = _mesa_texstore_unorm8;
      table[MESA_FORMAT_I16] = _mesa_texstore_unorm16;
      table[MESA_FORMAT_YCBCR] = _mesa_texstore_ycbcr;
      table[MESA_FORMAT_YCBCR_REV] = _mesa_texstore_ycbcr;
      table[MESA_FORMAT_R8] = _mesa_texstore_unorm8;
      table[MESA_FORMAT_GR88] = _mesa_texstore_unorm88;
      table[MESA_FORMAT_RG88] = _mesa_texstore_unorm88;
      table[MESA_FORMAT_R16] = _mesa_texstore_unorm16;
      table[MESA_FORMAT_GR1616] = _mesa_texstore_unorm1616;
      table[MESA_FORMAT_RG1616] = _mesa_texstore_unorm1616;
      table[MESA_FORMAT_ARGB2101010] = _mesa_texstore_argb2101010;
      table[MESA_FORMAT_Z24_S8] = _mesa_texstore_z24_s8;
      table[MESA_FORMAT_S8_Z24] = _mesa_texstore_s8_z24;
      table[MESA_FORMAT_Z16] = _mesa_texstore_z16;
      table[MESA_FORMAT_X8_Z24] = _mesa_texstore_x8_z24;
      table[MESA_FORMAT_Z24_X8] = _mesa_texstore_z24_x8;
      table[MESA_FORMAT_Z32] = _mesa_texstore_z32;
      table[MESA_FORMAT_S8] = _mesa_texstore_s8;
      table[MESA_FORMAT_SRGB8] = _mesa_texstore_srgb8;
      table[MESA_FORMAT_SRGBA8] = _mesa_texstore_srgba8;
      table[MESA_FORMAT_SARGB8] = _mesa_texstore_sargb8;
      table[MESA_FORMAT_SL8] = _mesa_texstore_sl8;
      table[MESA_FORMAT_SLA8] = _mesa_texstore_sla8;
      table[MESA_FORMAT_SRGB_DXT1] = _mesa_texstore_rgb_dxt1;
      table[MESA_FORMAT_SRGBA_DXT1] = _mesa_texstore_rgba_dxt1;
      table[MESA_FORMAT_SRGBA_DXT3] = _mesa_texstore_rgba_dxt3;
      table[MESA_FORMAT_SRGBA_DXT5] = _mesa_texstore_rgba_dxt5;
      table[MESA_FORMAT_RGB_FXT1] = _mesa_texstore_rgb_fxt1;
      table[MESA_FORMAT_RGBA_FXT1] = _mesa_texstore_rgba_fxt1;
      table[MESA_FORMAT_RGB_DXT1] = _mesa_texstore_rgb_dxt1;
      table[MESA_FORMAT_RGBA_DXT1] = _mesa_texstore_rgba_dxt1;
      table[MESA_FORMAT_RGBA_DXT3] = _mesa_texstore_rgba_dxt3;
      table[MESA_FORMAT_RGBA_DXT5] = _mesa_texstore_rgba_dxt5;
      table[MESA_FORMAT_RGBA_FLOAT32] = _mesa_texstore_rgba_float32;
      table[MESA_FORMAT_RGBA_FLOAT16] = _mesa_texstore_rgba_float16;
      table[MESA_FORMAT_RGB_FLOAT32] = _mesa_texstore_rgba_float32;
      table[MESA_FORMAT_RGB_FLOAT16] = _mesa_texstore_rgba_float16;
      table[MESA_FORMAT_ALPHA_FLOAT32] = _mesa_texstore_rgba_float32;
      table[MESA_FORMAT_ALPHA_FLOAT16] = _mesa_texstore_rgba_float16;
      table[MESA_FORMAT_LUMINANCE_FLOAT32] = _mesa_texstore_rgba_float32;
      table[MESA_FORMAT_LUMINANCE_FLOAT16] = _mesa_texstore_rgba_float16;
      table[MESA_FORMAT_LUMINANCE_ALPHA_FLOAT32] = _mesa_texstore_rgba_float32;
      table[MESA_FORMAT_LUMINANCE_ALPHA_FLOAT16] = _mesa_texstore_rgba_float16;
      table[MESA_FORMAT_INTENSITY_FLOAT32] = _mesa_texstore_rgba_float32;
      table[MESA_FORMAT_INTENSITY_FLOAT16] = _mesa_texstore_rgba_float16;
      table[MESA_FORMAT_R_FLOAT32] = _mesa_texstore_rgba_float32;
      table[MESA_FORMAT_R_FLOAT16] = _mesa_texstore_rgba_float16;
      table[MESA_FORMAT_RG_FLOAT32] = _mesa_texstore_rgba_float32;
      table[MESA_FORMAT_RG_FLOAT16] = _mesa_texstore_rgba_float16;
      table[MESA_FORMAT_DUDV8] = _mesa_texstore_dudv8;
      table[MESA_FORMAT_SIGNED_R8] = _mesa_texstore_snorm8;
      table[MESA_FORMAT_SIGNED_RG88_REV] = _mesa_texstore_snorm88;
      table[MESA_FORMAT_SIGNED_RGBX8888] = _mesa_texstore_signed_rgbx8888;
      table[MESA_FORMAT_SIGNED_RGBA8888] = _mesa_texstore_signed_rgba8888;
      table[MESA_FORMAT_SIGNED_RGBA8888_REV] = _mesa_texstore_signed_rgba8888;
      table[MESA_FORMAT_SIGNED_R16] = _mesa_texstore_snorm16;
      table[MESA_FORMAT_SIGNED_GR1616] = _mesa_texstore_snorm1616;
      table[MESA_FORMAT_SIGNED_RGB_16] = _mesa_texstore_signed_rgba_16;
      table[MESA_FORMAT_SIGNED_RGBA_16] = _mesa_texstore_signed_rgba_16;
      table[MESA_FORMAT_RGBA_16] = _mesa_texstore_rgba_16;
      table[MESA_FORMAT_RED_RGTC1] = _mesa_texstore_red_rgtc1;
      table[MESA_FORMAT_SIGNED_RED_RGTC1] = _mesa_texstore_signed_red_rgtc1;
      table[MESA_FORMAT_RG_RGTC2] = _mesa_texstore_rg_rgtc2;
      table[MESA_FORMAT_SIGNED_RG_RGTC2] = _mesa_texstore_signed_rg_rgtc2;
      table[MESA_FORMAT_L_LATC1] = _mesa_texstore_red_rgtc1;
      table[MESA_FORMAT_SIGNED_L_LATC1] = _mesa_texstore_signed_red_rgtc1;
      table[MESA_FORMAT_LA_LATC2] = _mesa_texstore_rg_rgtc2;
      table[MESA_FORMAT_SIGNED_LA_LATC2] = _mesa_texstore_signed_rg_rgtc2;
      table[MESA_FORMAT_ETC1_RGB8] = _mesa_texstore_etc1_rgb8;
      table[MESA_FORMAT_ETC2_RGB8] = _mesa_texstore_etc2_rgb8;
      table[MESA_FORMAT_ETC2_SRGB8] = _mesa_texstore_etc2_srgb8;
      table[MESA_FORMAT_ETC2_RGBA8_EAC] = _mesa_texstore_etc2_rgba8_eac;
      table[MESA_FORMAT_ETC2_SRGB8_ALPHA8_EAC] = _mesa_texstore_etc2_srgb8_alpha8_eac;
      table[MESA_FORMAT_ETC2_R11_EAC] = _mesa_texstore_etc2_r11_eac;
      table[MESA_FORMAT_ETC2_RG11_EAC] = _mesa_texstore_etc2_rg11_eac;
      table[MESA_FORMAT_ETC2_SIGNED_R11_EAC] = _mesa_texstore_etc2_signed_r11_eac;
      table[MESA_FORMAT_ETC2_SIGNED_RG11_EAC] = _mesa_texstore_etc2_signed_rg11_eac;
      table[MESA_FORMAT_ETC2_RGB8_PUNCHTHROUGH_ALPHA1] =
         _mesa_texstore_etc2_rgb8_punchthrough_alpha1;
      table[MESA_FORMAT_ETC2_SRGB8_PUNCHTHROUGH_ALPHA1] =
         _mesa_texstore_etc2_srgb8_punchthrough_alpha1;
      table[MESA_FORMAT_SIGNED_A8] = _mesa_texstore_snorm8;
      table[MESA_FORMAT_SIGNED_L8] = _mesa_texstore_snorm8;
      table[MESA_FORMAT_SIGNED_AL88] = _mesa_texstore_snorm88;
      table[MESA_FORMAT_SIGNED_I8] = _mesa_texstore_snorm8;
      table[MESA_FORMAT_SIGNED_A16] = _mesa_texstore_snorm16;
      table[MESA_FORMAT_SIGNED_L16] = _mesa_texstore_snorm16;
      table[MESA_FORMAT_SIGNED_AL1616] = _mesa_texstore_snorm1616;
      table[MESA_FORMAT_SIGNED_I16] = _mesa_texstore_snorm16;
      table[MESA_FORMAT_RGB9_E5_FLOAT] = _mesa_texstore_rgb9_e5;
      table[MESA_FORMAT_R11_G11_B10_FLOAT] = _mesa_texstore_r11_g11_b10f;
      table[MESA_FORMAT_Z32_FLOAT] = _mesa_texstore_z32;
      table[MESA_FORMAT_Z32_FLOAT_X24S8] = _mesa_texstore_z32f_x24s8;

      table[MESA_FORMAT_ALPHA_UINT8] = _mesa_texstore_rgba_uint8;
      table[MESA_FORMAT_ALPHA_UINT16] = _mesa_texstore_rgba_uint16;
      table[MESA_FORMAT_ALPHA_UINT32] = _mesa_texstore_rgba_uint32;
      table[MESA_FORMAT_ALPHA_INT8] = _mesa_texstore_rgba_int8;
      table[MESA_FORMAT_ALPHA_INT16] = _mesa_texstore_rgba_int16;
      table[MESA_FORMAT_ALPHA_INT32] = _mesa_texstore_rgba_int32;

      table[MESA_FORMAT_INTENSITY_UINT8] = _mesa_texstore_rgba_uint8;
      table[MESA_FORMAT_INTENSITY_UINT16] = _mesa_texstore_rgba_uint16;
      table[MESA_FORMAT_INTENSITY_UINT32] = _mesa_texstore_rgba_uint32;
      table[MESA_FORMAT_INTENSITY_INT8] = _mesa_texstore_rgba_int8;
      table[MESA_FORMAT_INTENSITY_INT16] = _mesa_texstore_rgba_int16;
      table[MESA_FORMAT_INTENSITY_INT32] = _mesa_texstore_rgba_int32;

      table[MESA_FORMAT_LUMINANCE_UINT8] = _mesa_texstore_rgba_uint8;
      table[MESA_FORMAT_LUMINANCE_UINT16] = _mesa_texstore_rgba_uint16;
      table[MESA_FORMAT_LUMINANCE_UINT32] = _mesa_texstore_rgba_uint32;
      table[MESA_FORMAT_LUMINANCE_INT8] = _mesa_texstore_rgba_int8;
      table[MESA_FORMAT_LUMINANCE_INT16] = _mesa_texstore_rgba_int16;
      table[MESA_FORMAT_LUMINANCE_INT32] = _mesa_texstore_rgba_int32;

      table[MESA_FORMAT_LUMINANCE_ALPHA_UINT8] = _mesa_texstore_rgba_uint8;
      table[MESA_FORMAT_LUMINANCE_ALPHA_UINT16] = _mesa_texstore_rgba_uint16;
      table[MESA_FORMAT_LUMINANCE_ALPHA_UINT32] = _mesa_texstore_rgba_uint32;
      table[MESA_FORMAT_LUMINANCE_ALPHA_INT8] = _mesa_texstore_rgba_int8;
      table[MESA_FORMAT_LUMINANCE_ALPHA_INT16] = _mesa_texstore_rgba_int16;
      table[MESA_FORMAT_LUMINANCE_ALPHA_INT32] = _mesa_texstore_rgba_int32;

      table[MESA_FORMAT_R_INT8] = _mesa_texstore_rgba_int8;
      table[MESA_FORMAT_RG_INT8] = _mesa_texstore_rgba_int8;
      table[MESA_FORMAT_RGB_INT8] = _mesa_texstore_rgba_int8;
      table[MESA_FORMAT_RGBA_INT8] = _mesa_texstore_rgba_int8;
      table[MESA_FORMAT_R_INT16] = _mesa_texstore_rgba_int16;
      table[MESA_FORMAT_RG_INT16] = _mesa_texstore_rgba_int16;
      table[MESA_FORMAT_RGB_INT16] = _mesa_texstore_rgba_int16;
      table[MESA_FORMAT_RGBA_INT16] = _mesa_texstore_rgba_int16;
      table[MESA_FORMAT_R_INT32] = _mesa_texstore_rgba_int32;
      table[MESA_FORMAT_RG_INT32] = _mesa_texstore_rgba_int32;
      table[MESA_FORMAT_RGB_INT32] = _mesa_texstore_rgba_int32;
      table[MESA_FORMAT_RGBA_INT32] = _mesa_texstore_rgba_int32;

      table[MESA_FORMAT_R_UINT8] = _mesa_texstore_rgba_uint8;
      table[MESA_FORMAT_RG_UINT8] = _mesa_texstore_rgba_uint8;
      table[MESA_FORMAT_RGB_UINT8] = _mesa_texstore_rgba_uint8;
      table[MESA_FORMAT_RGBA_UINT8] = _mesa_texstore_rgba_uint8;
      table[MESA_FORMAT_R_UINT16] = _mesa_texstore_rgba_uint16;
      table[MESA_FORMAT_RG_UINT16] = _mesa_texstore_rgba_uint16;
      table[MESA_FORMAT_RGB_UINT16] = _mesa_texstore_rgba_uint16;
      table[MESA_FORMAT_RGBA_UINT16] = _mesa_texstore_rgba_uint16;
      table[MESA_FORMAT_R_UINT32] = _mesa_texstore_rgba_uint32;
      table[MESA_FORMAT_RG_UINT32] = _mesa_texstore_rgba_uint32;
      table[MESA_FORMAT_RGB_UINT32] = _mesa_texstore_rgba_uint32;
      table[MESA_FORMAT_RGBA_UINT32] = _mesa_texstore_rgba_uint32;

      table[MESA_FORMAT_ARGB2101010_UINT] = _mesa_texstore_argb2101010_uint;
      table[MESA_FORMAT_ABGR2101010_UINT] = _mesa_texstore_abgr2101010_uint;

      table[MESA_FORMAT_XRGB4444_UNORM] = store_ubyte_texture;
      table[MESA_FORMAT_XRGB1555_UNORM] = store_ubyte_texture;
      table[MESA_FORMAT_XBGR8888_SNORM] = _mesa_texstore_signed_rgbx8888;
      table[MESA_FORMAT_XBGR8888_SRGB] = _mesa_texstore_srgba8;
      table[MESA_FORMAT_XBGR8888_UINT] = _mesa_texstore_rgba_uint8;
      table[MESA_FORMAT_XBGR8888_SINT] = _mesa_texstore_rgba_int8;
      table[MESA_FORMAT_XRGB2101010_UNORM] = _mesa_texstore_argb2101010;
      table[MESA_FORMAT_XBGR16161616_UNORM] = _mesa_texstore_rgba_16;
      table[MESA_FORMAT_XBGR16161616_SNORM] = _mesa_texstore_signed_rgba_16;
      table[MESA_FORMAT_XBGR16161616_FLOAT] = _mesa_texstore_rgba_float16;
      table[MESA_FORMAT_XBGR16161616_UINT] = _mesa_texstore_rgba_uint16;
      table[MESA_FORMAT_XBGR16161616_SINT] = _mesa_texstore_rgba_int16;
      table[MESA_FORMAT_XBGR32323232_FLOAT] = _mesa_texstore_rgba_float32;
      table[MESA_FORMAT_XBGR32323232_UINT] = _mesa_texstore_rgba_uint32;
      table[MESA_FORMAT_XBGR32323232_SINT] = _mesa_texstore_rgba_int32;

      initialized = GL_TRUE;
d4040 2
d4043 4
a4046 2
   ASSERT(table[format]);
   return table[format];
d4050 4
d4055 14
a4068 12
_mesa_texstore_needs_transfer_ops(struct gl_context *ctx,
                                  GLenum baseInternalFormat,
                                  gl_format dstFormat)
{
   GLenum dstType;

   /* There are different rules depending on the base format. */
   switch (baseInternalFormat) {
   case GL_DEPTH_COMPONENT:
   case GL_DEPTH_STENCIL:
      return ctx->Pixel.DepthScale != 1.0f ||
             ctx->Pixel.DepthBias != 0.0f;
a4069 2
   case GL_STENCIL_INDEX:
      return GL_FALSE;
d4071 24
a4094 6
   default:
      /* Color formats.
       * Pixel transfer ops (scale, bias, table lookup) do not apply
       * to integer formats.
       */
      dstType = _mesa_get_format_datatype(dstFormat);
d4096 5
a4100 2
      return dstType != GL_INT && dstType != GL_UNSIGNED_INT &&
             ctx->_ImageTransferState;
d4102 2
d4107 12
a4118 5
GLboolean
_mesa_texstore_can_use_memcpy(struct gl_context *ctx,
                              GLenum baseInternalFormat, gl_format dstFormat,
                              GLenum srcFormat, GLenum srcType,
                              const struct gl_pixelstore_attrib *srcPacking)
d4120 5
a4124 2
   if (_mesa_texstore_needs_transfer_ops(ctx, baseInternalFormat, dstFormat)) {
      return GL_FALSE;
d4126 5
a4130 4

   /* The base internal format and the base Mesa format must match. */
   if (baseInternalFormat != _mesa_get_format_base_format(dstFormat)) {
      return GL_FALSE;
d4133 5
a4137 4
   /* The Mesa format must match the input format and type. */
   if (!_mesa_format_matches_format_and_type(dstFormat, srcFormat, srcType,
                                             srcPacking->SwapBytes)) {
      return GL_FALSE;
d4140 1
a4140 1
   return GL_TRUE;
d4143 8
a4150 2
static GLboolean
_mesa_texstore_memcpy(TEXSTORE_PARAMS)
d4152 3
a4154 3
   if (!_mesa_texstore_can_use_memcpy(ctx, baseInternalFormat, dstFormat,
                                      srcFormat, srcType, srcPacking)) {
      return GL_FALSE;
d4156 12
d4169 7
a4175 6
   memcpy_texture(ctx, dims,
                  dstFormat,
                  dstRowStride, dstSlices,
                  srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                  srcAddr, srcPacking);
   return GL_TRUE;
d4179 1
d4181 3
a4183 2
 * Store user data into texture memory.
 * Called via glTex[Sub]Image1/2/3D()
d4185 19
a4203 5
GLboolean
_mesa_texstore(TEXSTORE_PARAMS)
{
   StoreTexImageFunc storeImage;
   GLboolean success;
d4205 21
a4225 6
   if (_mesa_texstore_memcpy(ctx, dims, baseInternalFormat,
                             dstFormat,
                             dstRowStride, dstSlices,
                             srcWidth, srcHeight, srcDepth,
                             srcFormat, srcType, srcAddr, srcPacking)) {
      return GL_TRUE;
d4228 1
a4228 8
   storeImage = _mesa_get_texstore_func(dstFormat);

   success = storeImage(ctx, dims, baseInternalFormat,
                        dstFormat,
                        dstRowStride, dstSlices,
                        srcWidth, srcHeight, srcDepth,
                        srcFormat, srcType, srcAddr, srcPacking);
   return success;
d4233 50
a4282 15
 * Normally, we'll only _write_ texel data to a texture when we map it.
 * But if the user is providing depth or stencil values and the texture
 * image is a combined depth/stencil format, we'll actually read from
 * the texture buffer too (in order to insert the depth or stencil values.
 * \param userFormat  the user-provided image format
 * \param texFormat  the destination texture format
 */
static GLbitfield
get_read_write_mode(GLenum userFormat, gl_format texFormat)
{
   if ((userFormat == GL_STENCIL_INDEX || userFormat == GL_DEPTH_COMPONENT)
       && _mesa_get_format_base_format(texFormat) == GL_DEPTH_STENCIL)
      return GL_MAP_READ_BIT | GL_MAP_WRITE_BIT;
   else
      return GL_MAP_WRITE_BIT | GL_MAP_INVALIDATE_RANGE_BIT;
d4286 1
d4288 3
a4290 4
 * Helper function for storing 1D, 2D, 3D whole and subimages into texture
 * memory.
 * The source of the image data may be user memory or a PBO.  In the later
 * case, we'll map the PBO, copy from it, then unmap it.
d4292 46
a4337 8
static void
store_texsubimage(struct gl_context *ctx,
                  struct gl_texture_image *texImage,
                  GLint xoffset, GLint yoffset, GLint zoffset,
                  GLint width, GLint height, GLint depth,
                  GLenum format, GLenum type, const GLvoid *pixels,
                  const struct gl_pixelstore_attrib *packing,
                  const char *caller)
a4338 7
{
   const GLbitfield mapMode = get_read_write_mode(format, texImage->TexFormat);
   const GLenum target = texImage->TexObject->Target;
   GLboolean success = GL_FALSE;
   GLuint dims, slice, numSlices = 1, sliceOffset = 0;
   GLint srcImageStride = 0;
   const GLubyte *src;
a4339 16
   assert(xoffset + width <= texImage->Width);
   assert(yoffset + height <= texImage->Height);
   assert(zoffset + depth <= texImage->Depth);

   switch (target) {
   case GL_TEXTURE_1D:
      dims = 1;
      break;
   case GL_TEXTURE_2D_ARRAY:
   case GL_TEXTURE_CUBE_MAP_ARRAY:
   case GL_TEXTURE_3D:
      dims = 3;
      break;
   default:
      dims = 2;
   }
d4341 12
d4354 3
a4356 4
   src = (const GLubyte *)
      _mesa_validate_pbo_teximage(ctx, dims, width, height, depth,
                                  format, type, pixels, packing, caller);
   if (!src)
d4359 13
a4371 46
   /* compute slice info (and do some sanity checks) */
   switch (target) {
   case GL_TEXTURE_2D:
   case GL_TEXTURE_RECTANGLE:
   case GL_TEXTURE_CUBE_MAP:
      /* one image slice, nothing special needs to be done */
      break;
   case GL_TEXTURE_1D:
      assert(height == 1);
      assert(depth == 1);
      assert(yoffset == 0);
      assert(zoffset == 0);
      break;
   case GL_TEXTURE_1D_ARRAY:
      assert(depth == 1);
      assert(zoffset == 0);
      numSlices = height;
      sliceOffset = yoffset;
      height = 1;
      yoffset = 0;
      srcImageStride = _mesa_image_row_stride(packing, width, format, type);
      break;
   case GL_TEXTURE_2D_ARRAY:
      numSlices = depth;
      sliceOffset = zoffset;
      depth = 1;
      zoffset = 0;
      srcImageStride = _mesa_image_image_stride(packing, width, height,
                                                format, type);
      break;
   case GL_TEXTURE_3D:
      /* we'll store 3D images as a series of slices */
      numSlices = depth;
      sliceOffset = zoffset;
      srcImageStride = _mesa_image_image_stride(packing, width, height,
                                                format, type);
      break;
   case GL_TEXTURE_CUBE_MAP_ARRAY:
      numSlices = depth;
      sliceOffset = zoffset;
      srcImageStride = _mesa_image_image_stride(packing, width, height,
                                                format, type);
      break;
   default:
      _mesa_warning(ctx, "Unexpected target 0x%x in store_texsubimage()", target);
      return;
d4374 2
a4375 1
   assert(numSlices == 1 || srcImageStride != 0);
a4376 19
   for (slice = 0; slice < numSlices; slice++) {
      GLubyte *dstMap;
      GLint dstRowStride;

      ctx->Driver.MapTextureImage(ctx, texImage,
                                  slice + sliceOffset,
                                  xoffset, yoffset, width, height,
                                  mapMode, &dstMap, &dstRowStride);
      if (dstMap) {
         /* Note: we're only storing a 2D (or 1D) slice at a time but we need
          * to pass the right 'dims' value so that GL_UNPACK_SKIP_IMAGES is
          * used for 3D images.
          */
         success = _mesa_texstore(ctx, dims, texImage->_BaseFormat,
                                  texImage->TexFormat,
                                  dstRowStride,
                                  &dstMap,
                                  width, height, 1,  /* w, h, d */
                                  format, type, src, packing);
a4377 2
         ctx->Driver.UnmapTextureImage(ctx, texImage, slice + sliceOffset);
      }
d4379 18
a4396 1
      src += srcImageStride;
d4398 13
a4410 2
      if (!success)
         break;
a4412 3
   if (!success)
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "%s", caller);

d4417 3
a4419 5

/**
 * Fallback code for ctx->Driver.TexImage().
 * Basically, allocate storage for the texture image, then copy the
 * user's image into it.
d4422 7
a4428 5
_mesa_store_teximage(struct gl_context *ctx,
                     GLuint dims,
                     struct gl_texture_image *texImage,
                     GLenum format, GLenum type, const GLvoid *pixels,
                     const struct gl_pixelstore_attrib *packing)
d4430 5
a4434 3
   assert(dims == 1 || dims == 2 || dims == 3);

   if (texImage->Width == 0 || texImage->Height == 0 || texImage->Depth == 0)
d4437 13
a4449 4
   /* allocate storage for texture data */
   if (!ctx->Driver.AllocTextureImageBuffer(ctx, texImage)) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glTexImage%uD", dims);
      return;
d4452 1
a4452 3
   store_texsubimage(ctx, texImage,
                     0, 0, 0, texImage->Width, texImage->Height, texImage->Depth,
                     format, type, pixels, packing, "glTexImage");
d4457 1
a4457 1
 * Fallback for Driver.TexSubImage().
d4460 7
a4466 6
_mesa_store_texsubimage(struct gl_context *ctx, GLuint dims,
                        struct gl_texture_image *texImage,
                        GLint xoffset, GLint yoffset, GLint zoffset,
                        GLint width, GLint height, GLint depth,
                        GLenum format, GLenum type, const void *pixels,
                        const struct gl_pixelstore_attrib *packing)
d4468 8
a4475 3
   store_texsubimage(ctx, texImage,
                     xoffset, yoffset, zoffset, width, height, depth,
                     format, type, pixels, packing, "glTexSubImage");
d4479 1
d4481 1
a4481 1
 * Fallback for Driver.CompressedTexImage()
d4484 9
a4492 9
_mesa_store_compressed_teximage(struct gl_context *ctx, GLuint dims,
                                struct gl_texture_image *texImage,
                                GLsizei imageSize, const GLvoid *data)
{
   /* only 2D and 3D compressed images are supported at this time */
   if (dims == 1) {
      _mesa_problem(ctx, "Unexpected glCompressedTexImage1D call");
      return;
   }
d4494 2
a4495 3
   /* This is pretty simple, because unlike the general texstore path we don't
    * have to worry about the usual image unpacking or image transfer
    * operations.
d4497 1
d4501 2
a4502 1
   ASSERT(texImage->Depth > 0);
d4504 4
a4507 3
   /* allocate storage for texture data */
   if (!ctx->Driver.AllocTextureImageBuffer(ctx, texImage)) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCompressedTexImage%uD", dims);
d4511 60
a4570 5
   _mesa_store_compressed_texsubimage(ctx, dims, texImage,
                                      0, 0, 0,
                                      texImage->Width, texImage->Height, texImage->Depth,
                                      texImage->TexFormat,
                                      imageSize, data);
d4575 1
a4575 1
 * Fallback for Driver.CompressedTexSubImage()
d4578 8
a4585 6
_mesa_store_compressed_texsubimage(struct gl_context *ctx, GLuint dims,
                                   struct gl_texture_image *texImage,
                                   GLint xoffset, GLint yoffset, GLint zoffset,
                                   GLsizei width, GLsizei height, GLsizei depth,
                                   GLenum format,
                                   GLsizei imageSize, const GLvoid *data)
d4587 1
a4587 1
   GLint bytesPerRow, dstRowStride, srcRowStride;
d4589 1
a4589 1
   GLubyte *dstMap;
d4592 1
a4593 1
   GLint slice;
d4595 4
a4598 4
   if (dims == 1) {
      _mesa_problem(ctx, "Unexpected 1D compressed texsubimage call");
      return;
   }
d4600 5
a4604 1
   _mesa_get_format_block_size(texFormat, &bw, &bh);
d4607 1
a4607 1
   data = _mesa_validate_pbo_compressed_teximage(ctx, dims, imageSize, data,
d4609 1
a4609 1
                                                 "glCompressedTexSubImage");
d4616 13
a4628 24
   for (slice = 0; slice < depth; slice++) {
      /* Map dest texture buffer */
      ctx->Driver.MapTextureImage(ctx, texImage, slice + zoffset,
                                  xoffset, yoffset, width, height,
                                  GL_MAP_WRITE_BIT | GL_MAP_INVALIDATE_RANGE_BIT,
                                  &dstMap, &dstRowStride);

      if (dstMap) {
         bytesPerRow = srcRowStride;  /* bytes per row of blocks */
         rows = (height + bh - 1) / bh;  /* rows in blocks */

         /* copy rows of blocks */
         for (i = 0; i < rows; i++) {
            memcpy(dstMap, src, bytesPerRow);
            dstMap += dstRowStride;
            src += srcRowStride;
         }

         ctx->Driver.UnmapTextureImage(ctx, texImage, slice + zoffset);
      }
      else {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCompressedTexSubImage%uD",
                     dims);
      }
d4632 25
@


1.1.1.6
log
@Import Mesa 10.2.3
@
text
@d926 1
a926 1
               mesa_format dstFormat,
d1015 2
a1016 2
   ASSERT(dstFormat == MESA_FORMAT_Z_UNORM32 ||
          dstFormat == MESA_FORMAT_Z_FLOAT32);
d1019 1
a1019 1
   if (dstFormat == MESA_FORMAT_Z_UNORM32)
d1052 1
a1052 1
   ASSERT(dstFormat == MESA_FORMAT_Z24_UNORM_X8_UINT);
d1082 1
a1082 1
   ASSERT(dstFormat == MESA_FORMAT_X8_UINT_Z24_UNORM);
d1115 1
a1115 1
   ASSERT(dstFormat == MESA_FORMAT_Z_UNORM16);
d1144 2
a1145 2
   ASSERT(dstFormat == MESA_FORMAT_B5G6R5_UNORM ||
          dstFormat == MESA_FORMAT_R5G6B5_UNORM);
d1166 1
a1166 1
         if (dstFormat == MESA_FORMAT_B5G6R5_UNORM) {
d1193 1
a1193 1
 * Store a texture in MESA_FORMAT_A8B8G8R8_UNORM or MESA_FORMAT_R8G8B8A8_UNORM.
d1200 4
a1203 4
   ASSERT(dstFormat == MESA_FORMAT_A8B8G8R8_UNORM ||
          dstFormat == MESA_FORMAT_R8G8B8A8_UNORM ||
          dstFormat == MESA_FORMAT_X8B8G8R8_UNORM ||
          dstFormat == MESA_FORMAT_R8G8B8X8_UNORM);
d1217 4
a1220 4
      if ((littleEndian && (dstFormat == MESA_FORMAT_A8B8G8R8_UNORM ||
                            dstFormat == MESA_FORMAT_X8B8G8R8_UNORM)) ||
	  (!littleEndian && (dstFormat == MESA_FORMAT_R8G8B8A8_UNORM ||
	                     dstFormat == MESA_FORMAT_R8G8B8X8_UNORM))) {
d1257 4
a1260 4
   ASSERT(dstFormat == MESA_FORMAT_B8G8R8A8_UNORM ||
          dstFormat == MESA_FORMAT_A8R8G8B8_UNORM ||
          dstFormat == MESA_FORMAT_B8G8R8X8_UNORM ||
          dstFormat == MESA_FORMAT_X8R8G8B8_UNORM );
d1265 2
a1266 2
       (dstFormat == MESA_FORMAT_B8G8R8A8_UNORM ||
        dstFormat == MESA_FORMAT_B8G8R8X8_UNORM) &&
d1293 1
a1293 1
            dstFormat == MESA_FORMAT_B8G8R8A8_UNORM &&
d1319 1
a1319 1
	    dstFormat == MESA_FORMAT_B8G8R8A8_UNORM &&
d1361 4
a1364 4
      if ((littleEndian && dstFormat == MESA_FORMAT_B8G8R8A8_UNORM) ||
          (littleEndian && dstFormat == MESA_FORMAT_B8G8R8X8_UNORM) ||
	  (!littleEndian && dstFormat == MESA_FORMAT_A8R8G8B8_UNORM) ||
	  (!littleEndian && dstFormat == MESA_FORMAT_X8R8G8B8_UNORM)) {
d1371 4
a1374 4
	 assert((littleEndian && dstFormat == MESA_FORMAT_A8R8G8B8_UNORM) ||
		(!littleEndian && dstFormat == MESA_FORMAT_B8G8R8A8_UNORM) ||
		(littleEndian && dstFormat == MESA_FORMAT_X8R8G8B8_UNORM) ||
		(!littleEndian && dstFormat == MESA_FORMAT_B8G8R8X8_UNORM));
d1404 1
a1404 1
   ASSERT(dstFormat == MESA_FORMAT_BGR_UNORM8);
d1466 1
a1466 1
   ASSERT(dstFormat == MESA_FORMAT_RGB_UNORM8);
d1528 2
a1529 2
   ASSERT(dstFormat == MESA_FORMAT_B10G10R10A2_UNORM ||
          dstFormat == MESA_FORMAT_B10G10R10X2_UNORM);
d1582 1
a1582 1
   ASSERT(dstFormat == MESA_FORMAT_L4A4_UNORM);
d1625 4
a1628 4
   ASSERT(dstFormat == MESA_FORMAT_L8A8_UNORM ||
          dstFormat == MESA_FORMAT_A8L8_UNORM ||
          dstFormat == MESA_FORMAT_R8G8_UNORM ||
          dstFormat == MESA_FORMAT_G8R8_UNORM);
d1640 3
a1642 3
      if (dstFormat == MESA_FORMAT_L8A8_UNORM || dstFormat == MESA_FORMAT_A8L8_UNORM) {
	 if ((littleEndian && dstFormat == MESA_FORMAT_L8A8_UNORM) ||
	     (!littleEndian && dstFormat == MESA_FORMAT_A8L8_UNORM)) {
d1652 2
a1653 2
	 if ((littleEndian && dstFormat == MESA_FORMAT_R8G8_UNORM) ||
	     (!littleEndian && dstFormat == MESA_FORMAT_G8R8_UNORM)) {
d1690 2
a1691 2
            if (dstFormat == MESA_FORMAT_L8A8_UNORM ||
		dstFormat == MESA_FORMAT_R8G8_UNORM) {
d1724 4
a1727 4
   ASSERT(dstFormat == MESA_FORMAT_L16A16_UNORM ||
          dstFormat == MESA_FORMAT_A16L16_UNORM ||
	  dstFormat == MESA_FORMAT_R16G16_UNORM ||
          dstFormat == MESA_FORMAT_G16R16_UNORM);
d1747 2
a1748 2
            if (dstFormat == MESA_FORMAT_L16A16_UNORM ||
		dstFormat == MESA_FORMAT_R16G16_UNORM) {
d1783 4
a1786 4
   ASSERT(dstFormat == MESA_FORMAT_R_UNORM16 ||
          dstFormat == MESA_FORMAT_A_UNORM16 ||
          dstFormat == MESA_FORMAT_L_UNORM16 ||
          dstFormat == MESA_FORMAT_I_UNORM16);
d1825 2
a1826 2
   ASSERT(dstFormat == MESA_FORMAT_RGBA_UNORM16 ||
          dstFormat == MESA_FORMAT_RGBX_UNORM16);
d1877 3
a1879 3
   ASSERT(dstFormat == MESA_FORMAT_RGB_SNORM16 ||
          dstFormat == MESA_FORMAT_RGBA_SNORM16 ||
          dstFormat == MESA_FORMAT_RGBX_SNORM16);
d1904 1
a1904 1
            if (dstFormat == MESA_FORMAT_RGBA_SNORM16) {
d1916 1
a1916 1
            else if (dstFormat == MESA_FORMAT_RGBX_SNORM16) {
d1958 4
a1961 4
   ASSERT(dstFormat == MESA_FORMAT_A_UNORM8 ||
          dstFormat == MESA_FORMAT_L_UNORM8 ||
          dstFormat == MESA_FORMAT_I_UNORM8 ||
          dstFormat == MESA_FORMAT_R_UNORM8);
d1972 1
a1972 1
      if (dstFormat == MESA_FORMAT_A_UNORM8) {
d2150 4
a2153 4
   ASSERT(dstFormat == MESA_FORMAT_A_SNORM8 ||
          dstFormat == MESA_FORMAT_L_SNORM8 ||
          dstFormat == MESA_FORMAT_I_SNORM8 ||
          dstFormat == MESA_FORMAT_R_SNORM8);
d2193 2
a2194 3
   ASSERT(dstFormat == MESA_FORMAT_L8A8_SNORM ||
          dstFormat == MESA_FORMAT_G8R8_SNORM ||
          dstFormat == MESA_FORMAT_R8G8_SNORM);
d2213 6
a2218 19
            GLushort *dst = (GLushort *) dstRow;

            if (dstFormat == MESA_FORMAT_L8A8_SNORM ||
                dstFormat == MESA_FORMAT_R8G8_SNORM) {
               for (col = 0; col < srcWidth; col++) {
                  GLubyte l = FLOAT_TO_BYTE_TEX(src[0]);
                  GLubyte a = FLOAT_TO_BYTE_TEX(src[1]);

                  dst[col] = PACK_COLOR_88_REV(l, a);
                  src += 2;
               }
            } else {
               for (col = 0; col < srcWidth; col++) {
                  GLubyte l = FLOAT_TO_BYTE_TEX(src[0]);
                  GLubyte a = FLOAT_TO_BYTE_TEX(src[1]);

                  dst[col] = PACK_COLOR_88(l, a);
                  src += 2;
               }
a2219 1

d2234 4
a2237 4
   ASSERT(dstFormat == MESA_FORMAT_R_SNORM16 ||
          dstFormat == MESA_FORMAT_A_SNORM16 ||
          dstFormat == MESA_FORMAT_L_SNORM16 ||
          dstFormat == MESA_FORMAT_I_SNORM16);
d2280 2
a2281 3
   ASSERT(dstFormat == MESA_FORMAT_LA_SNORM16 ||
          dstFormat == MESA_FORMAT_G16R16_SNORM ||
          dstFormat == MESA_FORMAT_R16G16_SNORM);
d2300 3
a2302 1
            GLuint *dst = (GLuint *) dstRow;
d2304 6
a2309 19
            if (dstFormat == MESA_FORMAT_LA_SNORM16 ||
                dstFormat == MESA_FORMAT_R16G16_SNORM) {
               for (col = 0; col < srcWidth; col++) {
                  GLushort l, a;

                  UNCLAMPED_FLOAT_TO_SHORT(l, src[0]);
                  UNCLAMPED_FLOAT_TO_SHORT(a, src[1]);
                  dst[col] = PACK_COLOR_1616_REV(l, a);
                  src += 2;
               }
            } else {
               for (col = 0; col < srcWidth; col++) {
                  GLushort l, a;

                  UNCLAMPED_FLOAT_TO_SHORT(l, src[0]);
                  UNCLAMPED_FLOAT_TO_SHORT(a, src[1]);
                  dst[col] = PACK_COLOR_1616_REV(l, a);
                  src += 2;
               }
a2310 1

d2320 2
a2321 2
 * Store a texture in MESA_FORMAT_X8B8G8R8_SNORM or
 * MESA_FORMAT_R8G8B8X8_SNORM.
d2328 2
a2329 2
   ASSERT(dstFormat == MESA_FORMAT_X8B8G8R8_SNORM ||
          dstFormat == MESA_FORMAT_R8G8B8X8_SNORM);
d2349 1
a2349 1
            if (dstFormat == MESA_FORMAT_X8B8G8R8_SNORM) {
d2380 2
a2381 2
 * Store a texture in MESA_FORMAT_A8B8G8R8_SNORM or
 * MESA_FORMAT_R8G8B8A8_SNORM
d2388 2
a2389 2
   ASSERT(dstFormat == MESA_FORMAT_A8B8G8R8_SNORM ||
          dstFormat == MESA_FORMAT_R8G8B8A8_SNORM);
d2409 1
a2409 1
            if (dstFormat == MESA_FORMAT_A8B8G8R8_SNORM) {
a2447 2
   GLuint *depth = malloc(srcWidth * sizeof(GLuint));
   GLubyte *stencil = malloc(srcWidth * sizeof(GLubyte));
d2449 1
a2449 1
   ASSERT(dstFormat == MESA_FORMAT_S8_UINT_Z24_UNORM);
d2453 1
a2453 3
   ASSERT(srcFormat != GL_DEPTH_STENCIL_EXT ||
          srcType == GL_UNSIGNED_INT_24_8_EXT ||
          srcType == GL_FLOAT_32_UNSIGNED_INT_24_8_REV);
d2455 4
a2458 5
   if (!depth || !stencil) {
      free(depth);
      free(stencil);
      return GL_FALSE;
   }
d2460 5
a2464 11
   /* In case we only upload depth we need to preserve the stencil */
   for (img = 0; img < srcDepth; img++) {
      GLuint *dstRow = (GLuint *) dstSlices[img];
      const GLubyte *src
         = (const GLubyte *) _mesa_image_address(dims, srcPacking, srcAddr,
               srcWidth, srcHeight,
               srcFormat, srcType,
               img, 0, 0);
      for (row = 0; row < srcHeight; row++) {
         GLint i;
         GLboolean keepdepth = GL_FALSE, keepstencil = GL_FALSE;
d2466 11
a2476 6
         if (srcFormat == GL_DEPTH_COMPONENT) { /* preserve stencil */
            keepstencil = GL_TRUE;
         }
         else if (srcFormat == GL_STENCIL_INDEX) { /* preserve depth */
            keepdepth = GL_TRUE;
         }
d2478 6
a2483 7
         if (keepdepth == GL_FALSE)
            /* the 24 depth bits will be in the low position: */
            _mesa_unpack_depth_span(ctx, srcWidth,
                                    GL_UNSIGNED_INT, /* dst type */
                                    keepstencil ? depth : dstRow, /* dst addr */
                                    depthScale,
                                    srcType, src, srcPacking);
d2485 22
a2506 7
         if (keepstencil == GL_FALSE)
            /* get the 8-bit stencil values */
            _mesa_unpack_stencil_span(ctx, srcWidth,
                                      GL_UNSIGNED_BYTE, /* dst type */
                                      stencil, /* dst addr */
                                      srcType, src, srcPacking,
                                      ctx->_ImageTransferState);
d2508 2
a2509 5
         for (i = 0; i < srcWidth; i++) {
            if (keepstencil)
               dstRow[i] = depth[i] << 8 | (dstRow[i] & 0x000000FF);
            else
               dstRow[i] = (dstRow[i] & 0xFFFFFF00) | (stencil[i] & 0xFF);
a2510 2
         src += srcRowStride;
         dstRow += dstRowStride / sizeof(GLuint);
d2512 3
a2515 3

   free(depth);
   free(stencil);
d2533 1
a2533 1
   ASSERT(dstFormat == MESA_FORMAT_Z24_UNORM_S8_UINT);
d2538 1
a2538 2
          srcType == GL_UNSIGNED_INT_24_8_EXT ||
          srcType == GL_FLOAT_32_UNSIGNED_INT_24_8_REV);
d2609 1
a2609 1
   ASSERT(dstFormat == MESA_FORMAT_S_UINT8);
d2669 1
a2669 1
   if (dstFormat == MESA_FORMAT_RGBX_FLOAT32) {
d2676 4
a2679 4
          dstFormat == MESA_FORMAT_A_FLOAT32 ||
          dstFormat == MESA_FORMAT_L_FLOAT32 ||
          dstFormat == MESA_FORMAT_LA_FLOAT32 ||
          dstFormat == MESA_FORMAT_I_FLOAT32 ||
d2682 1
a2682 1
          dstFormat == MESA_FORMAT_RGBX_FLOAT32);
d2734 1
a2734 1
   if (dstFormat == MESA_FORMAT_RGBX_FLOAT16) {
d2741 4
a2744 4
          dstFormat == MESA_FORMAT_A_FLOAT16 ||
          dstFormat == MESA_FORMAT_L_FLOAT16 ||
          dstFormat == MESA_FORMAT_LA_FLOAT16 ||
          dstFormat == MESA_FORMAT_I_FLOAT16 ||
d2747 1
a2747 1
          dstFormat == MESA_FORMAT_RGBX_FLOAT16);
d2798 1
a2798 1
   if (dstFormat == MESA_FORMAT_RGBX_SINT8) {
d2803 9
a2811 9
   ASSERT(dstFormat == MESA_FORMAT_R_SINT8 ||
          dstFormat == MESA_FORMAT_RG_SINT8 ||
          dstFormat == MESA_FORMAT_RGB_SINT8 ||
          dstFormat == MESA_FORMAT_RGBA_SINT8 ||
          dstFormat == MESA_FORMAT_A_SINT8 ||
          dstFormat == MESA_FORMAT_I_SINT8 ||
          dstFormat == MESA_FORMAT_L_SINT8 ||
          dstFormat == MESA_FORMAT_LA_SINT8 ||
          dstFormat == MESA_FORMAT_RGBX_SINT8);
d2869 1
a2869 1
   if (dstFormat == MESA_FORMAT_RGBX_SINT16) {
d2874 9
a2882 9
   ASSERT(dstFormat == MESA_FORMAT_R_SINT16 ||
          dstFormat == MESA_FORMAT_RG_SINT16 ||
          dstFormat == MESA_FORMAT_RGB_SINT16 ||
          dstFormat == MESA_FORMAT_RGBA_SINT16 ||
          dstFormat == MESA_FORMAT_A_SINT16 ||
          dstFormat == MESA_FORMAT_L_SINT16 ||
          dstFormat == MESA_FORMAT_I_SINT16 ||
          dstFormat == MESA_FORMAT_LA_SINT16 ||
          dstFormat == MESA_FORMAT_RGBX_SINT16);
d2940 1
a2940 1
   if (dstFormat == MESA_FORMAT_RGBX_SINT32) {
d2945 9
a2953 9
   ASSERT(dstFormat == MESA_FORMAT_R_SINT32 ||
          dstFormat == MESA_FORMAT_RG_SINT32 ||
          dstFormat == MESA_FORMAT_RGB_SINT32 ||
          dstFormat == MESA_FORMAT_RGBA_SINT32 ||
          dstFormat == MESA_FORMAT_A_SINT32 ||
          dstFormat == MESA_FORMAT_I_SINT32 ||
          dstFormat == MESA_FORMAT_L_SINT32 ||
          dstFormat == MESA_FORMAT_LA_SINT32 ||
          dstFormat == MESA_FORMAT_RGBX_SINT32);
d3011 1
a3011 1
   if (dstFormat == MESA_FORMAT_RGBX_UINT8) {
d3020 5
a3024 5
          dstFormat == MESA_FORMAT_A_UINT8 ||
          dstFormat == MESA_FORMAT_I_UINT8 ||
          dstFormat == MESA_FORMAT_L_UINT8 ||
          dstFormat == MESA_FORMAT_LA_UINT8 ||
          dstFormat == MESA_FORMAT_RGBX_UINT8);
d3079 1
a3079 1
   if (dstFormat == MESA_FORMAT_RGBX_UINT16) {
d3088 5
a3092 5
          dstFormat == MESA_FORMAT_A_UINT16 ||
          dstFormat == MESA_FORMAT_I_UINT16 ||
          dstFormat == MESA_FORMAT_L_UINT16 ||
          dstFormat == MESA_FORMAT_LA_UINT16 ||
          dstFormat == MESA_FORMAT_RGBX_UINT16);
d3147 1
a3147 1
   if (dstFormat == MESA_FORMAT_RGBX_UINT32) {
d3156 5
a3160 5
          dstFormat == MESA_FORMAT_A_UINT32 ||
          dstFormat == MESA_FORMAT_I_UINT32 ||
          dstFormat == MESA_FORMAT_L_UINT32 ||
          dstFormat == MESA_FORMAT_LA_UINT32 ||
          dstFormat == MESA_FORMAT_RGBX_UINT32);
d3210 1
a3210 1
   mesa_format newDstFormat;
d3213 1
a3213 1
   ASSERT(dstFormat == MESA_FORMAT_BGR_SRGB8);
d3216 1
a3216 1
   newDstFormat = MESA_FORMAT_BGR_UNORM8;
d3231 1
a3231 1
   mesa_format newDstFormat;
d3234 2
a3235 3
   ASSERT(dstFormat == MESA_FORMAT_A8B8G8R8_SRGB ||
          dstFormat == MESA_FORMAT_R8G8B8X8_SRGB ||
          dstFormat == MESA_FORMAT_R8G8B8A8_SRGB);
d3237 11
a3247 1
   newDstFormat = _mesa_get_srgb_format_linear(dstFormat);
d3262 1
a3262 1
   mesa_format newDstFormat;
d3265 1
a3265 2
   assert(dstFormat == MESA_FORMAT_B8G8R8A8_SRGB ||
          dstFormat == MESA_FORMAT_B8G8R8X8_SRGB);
d3267 2
a3268 1
   newDstFormat = _mesa_get_srgb_format_linear(dstFormat);
d3283 1
a3283 1
   mesa_format newDstFormat;
d3286 1
a3286 1
   ASSERT(dstFormat == MESA_FORMAT_L_SRGB8);
d3288 1
a3288 1
   newDstFormat = MESA_FORMAT_L_UNORM8;
d3304 1
a3304 1
   mesa_format newDstFormat;
d3307 1
a3307 1
   ASSERT(dstFormat == MESA_FORMAT_L8A8_SRGB);
d3310 1
a3310 1
   newDstFormat = MESA_FORMAT_L8A8_UNORM;
d3326 1
a3326 1
   ASSERT(dstFormat == MESA_FORMAT_R9G9B9E5_FLOAT);
d3364 1
a3364 1
   ASSERT(dstFormat == MESA_FORMAT_R11G11B10_FLOAT);
d3401 1
a3401 6
   GLint img, row;
   const GLint srcRowStride
      = _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType)
      / sizeof(uint64_t);

   ASSERT(dstFormat == MESA_FORMAT_Z32_FLOAT_S8X24_UINT);
a3405 1
          srcType == GL_UNSIGNED_INT_24_8 ||
d3408 6
a3413 18
   /* In case we only upload depth we need to preserve the stencil */
   for (img = 0; img < srcDepth; img++) {
      uint64_t *dstRow = (uint64_t *) dstSlices[img];
      const uint64_t *src
         = (const uint64_t *) _mesa_image_address(dims, srcPacking, srcAddr,
               srcWidth, srcHeight,
               srcFormat, srcType,
               img, 0, 0);
      for (row = 0; row < srcHeight; row++) {
         /* The unpack functions with:
          *    dstType = GL_FLOAT_32_UNSIGNED_INT_24_8_REV
          * only write their own dword, so the other dword (stencil
          * or depth) is preserved. */
         if (srcFormat != GL_STENCIL_INDEX)
            _mesa_unpack_depth_span(ctx, srcWidth,
                                    GL_FLOAT_32_UNSIGNED_INT_24_8_REV, /* dst type */
                                    dstRow, /* dst addr */
                                    ~0U, srcType, src, srcPacking);
d3415 25
a3439 6
         if (srcFormat != GL_DEPTH_COMPONENT)
            _mesa_unpack_stencil_span(ctx, srcWidth,
                                      GL_FLOAT_32_UNSIGNED_INT_24_8_REV, /* dst type */
                                      dstRow, /* dst addr */
                                      srcType, src, srcPacking,
                                      ctx->_ImageTransferState);
d3441 3
a3443 2
         src += srcRowStride;
         dstRow += dstRowStride / sizeof(uint64_t);
d3454 1
a3454 1
   ASSERT(dstFormat == MESA_FORMAT_B10G10R10A2_UINT);
d3510 1
a3510 1
   ASSERT(dstFormat == MESA_FORMAT_R10G10B10A2_UINT);
a3561 44
_mesa_texstore_abgr2101010(TEXSTORE_PARAMS)
{
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_R10G10B10A2_UNORM);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 4);

   {
      /* general path */
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *src = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];

         for (row = 0; row < srcHeight; row++) {
            GLuint *dstUI = (GLuint *) dstRow;
            for (col = 0; col < srcWidth; col++) {
               GLushort a,r,g,b;

               UNCLAMPED_FLOAT_TO_USHORT(a, src[ACOMP]);
               UNCLAMPED_FLOAT_TO_USHORT(r, src[RCOMP]);
               UNCLAMPED_FLOAT_TO_USHORT(g, src[GCOMP]);
               UNCLAMPED_FLOAT_TO_USHORT(b, src[BCOMP]);
               dstUI[col] = PACK_COLOR_2101010_US(a, b, g, r);
               src += 4;
            }
            dstRow += dstRowStride;
         }
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}

static GLboolean
d3583 1
a3583 1
_mesa_get_texstore_func(mesa_format format)
d3591 29
a3619 29
      table[MESA_FORMAT_A8B8G8R8_UNORM] = _mesa_texstore_rgba8888;
      table[MESA_FORMAT_R8G8B8A8_UNORM] = _mesa_texstore_rgba8888;
      table[MESA_FORMAT_B8G8R8A8_UNORM] = _mesa_texstore_argb8888;
      table[MESA_FORMAT_A8R8G8B8_UNORM] = _mesa_texstore_argb8888;
      table[MESA_FORMAT_X8B8G8R8_UNORM] = _mesa_texstore_rgba8888;
      table[MESA_FORMAT_R8G8B8X8_UNORM] = _mesa_texstore_rgba8888;
      table[MESA_FORMAT_B8G8R8X8_UNORM] = _mesa_texstore_argb8888;
      table[MESA_FORMAT_X8R8G8B8_UNORM] = _mesa_texstore_argb8888;
      table[MESA_FORMAT_BGR_UNORM8] = _mesa_texstore_rgb888;
      table[MESA_FORMAT_RGB_UNORM8] = _mesa_texstore_bgr888;
      table[MESA_FORMAT_B5G6R5_UNORM] = _mesa_texstore_rgb565;
      table[MESA_FORMAT_R5G6B5_UNORM] = _mesa_texstore_rgb565;
      table[MESA_FORMAT_B4G4R4A4_UNORM] = store_ubyte_texture;
      table[MESA_FORMAT_A4R4G4B4_UNORM] = store_ubyte_texture;
      table[MESA_FORMAT_A1B5G5R5_UNORM] = store_ubyte_texture;
      table[MESA_FORMAT_B5G5R5A1_UNORM] = store_ubyte_texture;
      table[MESA_FORMAT_A1R5G5B5_UNORM] = store_ubyte_texture;
      table[MESA_FORMAT_L4A4_UNORM] = _mesa_texstore_unorm44;
      table[MESA_FORMAT_L8A8_UNORM] = _mesa_texstore_unorm88;
      table[MESA_FORMAT_A8L8_UNORM] = _mesa_texstore_unorm88;
      table[MESA_FORMAT_L16A16_UNORM] = _mesa_texstore_unorm1616;
      table[MESA_FORMAT_A16L16_UNORM] = _mesa_texstore_unorm1616;
      table[MESA_FORMAT_B2G3R3_UNORM] = store_ubyte_texture;
      table[MESA_FORMAT_A_UNORM8] = _mesa_texstore_unorm8;
      table[MESA_FORMAT_A_UNORM16] = _mesa_texstore_unorm16;
      table[MESA_FORMAT_L_UNORM8] = _mesa_texstore_unorm8;
      table[MESA_FORMAT_L_UNORM16] = _mesa_texstore_unorm16;
      table[MESA_FORMAT_I_UNORM8] = _mesa_texstore_unorm8;
      table[MESA_FORMAT_I_UNORM16] = _mesa_texstore_unorm16;
d3622 19
a3640 19
      table[MESA_FORMAT_R_UNORM8] = _mesa_texstore_unorm8;
      table[MESA_FORMAT_R8G8_UNORM] = _mesa_texstore_unorm88;
      table[MESA_FORMAT_G8R8_UNORM] = _mesa_texstore_unorm88;
      table[MESA_FORMAT_R_UNORM16] = _mesa_texstore_unorm16;
      table[MESA_FORMAT_R16G16_UNORM] = _mesa_texstore_unorm1616;
      table[MESA_FORMAT_G16R16_UNORM] = _mesa_texstore_unorm1616;
      table[MESA_FORMAT_B10G10R10A2_UNORM] = _mesa_texstore_argb2101010;
      table[MESA_FORMAT_S8_UINT_Z24_UNORM] = _mesa_texstore_z24_s8;
      table[MESA_FORMAT_Z24_UNORM_S8_UINT] = _mesa_texstore_s8_z24;
      table[MESA_FORMAT_Z_UNORM16] = _mesa_texstore_z16;
      table[MESA_FORMAT_Z24_UNORM_X8_UINT] = _mesa_texstore_x8_z24;
      table[MESA_FORMAT_X8_UINT_Z24_UNORM] = _mesa_texstore_z24_x8;
      table[MESA_FORMAT_Z_UNORM32] = _mesa_texstore_z32;
      table[MESA_FORMAT_S_UINT8] = _mesa_texstore_s8;
      table[MESA_FORMAT_BGR_SRGB8] = _mesa_texstore_srgb8;
      table[MESA_FORMAT_A8B8G8R8_SRGB] = _mesa_texstore_srgba8;
      table[MESA_FORMAT_B8G8R8A8_SRGB] = _mesa_texstore_sargb8;
      table[MESA_FORMAT_L_SRGB8] = _mesa_texstore_sl8;
      table[MESA_FORMAT_L8A8_SRGB] = _mesa_texstore_sla8;
d3655 8
a3662 8
      table[MESA_FORMAT_A_FLOAT32] = _mesa_texstore_rgba_float32;
      table[MESA_FORMAT_A_FLOAT16] = _mesa_texstore_rgba_float16;
      table[MESA_FORMAT_L_FLOAT32] = _mesa_texstore_rgba_float32;
      table[MESA_FORMAT_L_FLOAT16] = _mesa_texstore_rgba_float16;
      table[MESA_FORMAT_LA_FLOAT32] = _mesa_texstore_rgba_float32;
      table[MESA_FORMAT_LA_FLOAT16] = _mesa_texstore_rgba_float16;
      table[MESA_FORMAT_I_FLOAT32] = _mesa_texstore_rgba_float32;
      table[MESA_FORMAT_I_FLOAT16] = _mesa_texstore_rgba_float16;
d3668 18
a3685 18
      table[MESA_FORMAT_R_SNORM8] = _mesa_texstore_snorm8;
      table[MESA_FORMAT_R8G8_SNORM] = _mesa_texstore_snorm88;
      table[MESA_FORMAT_X8B8G8R8_SNORM] = _mesa_texstore_signed_rgbx8888;
      table[MESA_FORMAT_A8B8G8R8_SNORM] = _mesa_texstore_signed_rgba8888;
      table[MESA_FORMAT_R8G8B8A8_SNORM] = _mesa_texstore_signed_rgba8888;
      table[MESA_FORMAT_R_SNORM16] = _mesa_texstore_snorm16;
      table[MESA_FORMAT_R16G16_SNORM] = _mesa_texstore_snorm1616;
      table[MESA_FORMAT_RGB_SNORM16] = _mesa_texstore_signed_rgba_16;
      table[MESA_FORMAT_RGBA_SNORM16] = _mesa_texstore_signed_rgba_16;
      table[MESA_FORMAT_RGBA_UNORM16] = _mesa_texstore_rgba_16;
      table[MESA_FORMAT_R_RGTC1_UNORM] = _mesa_texstore_red_rgtc1;
      table[MESA_FORMAT_R_RGTC1_SNORM] = _mesa_texstore_signed_red_rgtc1;
      table[MESA_FORMAT_RG_RGTC2_UNORM] = _mesa_texstore_rg_rgtc2;
      table[MESA_FORMAT_RG_RGTC2_SNORM] = _mesa_texstore_signed_rg_rgtc2;
      table[MESA_FORMAT_L_LATC1_UNORM] = _mesa_texstore_red_rgtc1;
      table[MESA_FORMAT_L_LATC1_SNORM] = _mesa_texstore_signed_red_rgtc1;
      table[MESA_FORMAT_LA_LATC2_UNORM] = _mesa_texstore_rg_rgtc2;
      table[MESA_FORMAT_LA_LATC2_SNORM] = _mesa_texstore_signed_rg_rgtc2;
d3699 53
a3751 53
      table[MESA_FORMAT_A_SNORM8] = _mesa_texstore_snorm8;
      table[MESA_FORMAT_L_SNORM8] = _mesa_texstore_snorm8;
      table[MESA_FORMAT_L8A8_SNORM] = _mesa_texstore_snorm88;
      table[MESA_FORMAT_I_SNORM8] = _mesa_texstore_snorm8;
      table[MESA_FORMAT_A_SNORM16] = _mesa_texstore_snorm16;
      table[MESA_FORMAT_L_SNORM16] = _mesa_texstore_snorm16;
      table[MESA_FORMAT_LA_SNORM16] = _mesa_texstore_snorm1616;
      table[MESA_FORMAT_I_SNORM16] = _mesa_texstore_snorm16;
      table[MESA_FORMAT_R9G9B9E5_FLOAT] = _mesa_texstore_rgb9_e5;
      table[MESA_FORMAT_R11G11B10_FLOAT] = _mesa_texstore_r11_g11_b10f;
      table[MESA_FORMAT_Z_FLOAT32] = _mesa_texstore_z32;
      table[MESA_FORMAT_Z32_FLOAT_S8X24_UINT] = _mesa_texstore_z32f_x24s8;

      table[MESA_FORMAT_A_UINT8] = _mesa_texstore_rgba_uint8;
      table[MESA_FORMAT_A_UINT16] = _mesa_texstore_rgba_uint16;
      table[MESA_FORMAT_A_UINT32] = _mesa_texstore_rgba_uint32;
      table[MESA_FORMAT_A_SINT8] = _mesa_texstore_rgba_int8;
      table[MESA_FORMAT_A_SINT16] = _mesa_texstore_rgba_int16;
      table[MESA_FORMAT_A_SINT32] = _mesa_texstore_rgba_int32;

      table[MESA_FORMAT_I_UINT8] = _mesa_texstore_rgba_uint8;
      table[MESA_FORMAT_I_UINT16] = _mesa_texstore_rgba_uint16;
      table[MESA_FORMAT_I_UINT32] = _mesa_texstore_rgba_uint32;
      table[MESA_FORMAT_I_SINT8] = _mesa_texstore_rgba_int8;
      table[MESA_FORMAT_I_SINT16] = _mesa_texstore_rgba_int16;
      table[MESA_FORMAT_I_SINT32] = _mesa_texstore_rgba_int32;

      table[MESA_FORMAT_L_UINT8] = _mesa_texstore_rgba_uint8;
      table[MESA_FORMAT_L_UINT16] = _mesa_texstore_rgba_uint16;
      table[MESA_FORMAT_L_UINT32] = _mesa_texstore_rgba_uint32;
      table[MESA_FORMAT_L_SINT8] = _mesa_texstore_rgba_int8;
      table[MESA_FORMAT_L_SINT16] = _mesa_texstore_rgba_int16;
      table[MESA_FORMAT_L_SINT32] = _mesa_texstore_rgba_int32;

      table[MESA_FORMAT_LA_UINT8] = _mesa_texstore_rgba_uint8;
      table[MESA_FORMAT_LA_UINT16] = _mesa_texstore_rgba_uint16;
      table[MESA_FORMAT_LA_UINT32] = _mesa_texstore_rgba_uint32;
      table[MESA_FORMAT_LA_SINT8] = _mesa_texstore_rgba_int8;
      table[MESA_FORMAT_LA_SINT16] = _mesa_texstore_rgba_int16;
      table[MESA_FORMAT_LA_SINT32] = _mesa_texstore_rgba_int32;

      table[MESA_FORMAT_R_SINT8] = _mesa_texstore_rgba_int8;
      table[MESA_FORMAT_RG_SINT8] = _mesa_texstore_rgba_int8;
      table[MESA_FORMAT_RGB_SINT8] = _mesa_texstore_rgba_int8;
      table[MESA_FORMAT_RGBA_SINT8] = _mesa_texstore_rgba_int8;
      table[MESA_FORMAT_R_SINT16] = _mesa_texstore_rgba_int16;
      table[MESA_FORMAT_RG_SINT16] = _mesa_texstore_rgba_int16;
      table[MESA_FORMAT_RGB_SINT16] = _mesa_texstore_rgba_int16;
      table[MESA_FORMAT_RGBA_SINT16] = _mesa_texstore_rgba_int16;
      table[MESA_FORMAT_R_SINT32] = _mesa_texstore_rgba_int32;
      table[MESA_FORMAT_RG_SINT32] = _mesa_texstore_rgba_int32;
      table[MESA_FORMAT_RGB_SINT32] = _mesa_texstore_rgba_int32;
      table[MESA_FORMAT_RGBA_SINT32] = _mesa_texstore_rgba_int32;
d3766 2
a3767 24
      table[MESA_FORMAT_B10G10R10A2_UINT] = _mesa_texstore_argb2101010_uint;
      table[MESA_FORMAT_R10G10B10A2_UINT] = _mesa_texstore_abgr2101010_uint;

      table[MESA_FORMAT_B4G4R4X4_UNORM] = store_ubyte_texture;
      table[MESA_FORMAT_B5G5R5X1_UNORM] = store_ubyte_texture;
      table[MESA_FORMAT_R8G8B8X8_SNORM] = _mesa_texstore_signed_rgbx8888;
      table[MESA_FORMAT_R8G8B8X8_SRGB] = _mesa_texstore_srgba8;
      table[MESA_FORMAT_R8G8B8A8_SRGB] = _mesa_texstore_srgba8;
      table[MESA_FORMAT_RGBX_UINT8] = _mesa_texstore_rgba_uint8;
      table[MESA_FORMAT_RGBX_SINT8] = _mesa_texstore_rgba_int8;
      table[MESA_FORMAT_B10G10R10X2_UNORM] = _mesa_texstore_argb2101010;
      table[MESA_FORMAT_RGBX_UNORM16] = _mesa_texstore_rgba_16;
      table[MESA_FORMAT_RGBX_SNORM16] = _mesa_texstore_signed_rgba_16;
      table[MESA_FORMAT_RGBX_FLOAT16] = _mesa_texstore_rgba_float16;
      table[MESA_FORMAT_RGBX_UINT16] = _mesa_texstore_rgba_uint16;
      table[MESA_FORMAT_RGBX_SINT16] = _mesa_texstore_rgba_int16;
      table[MESA_FORMAT_RGBX_FLOAT32] = _mesa_texstore_rgba_float32;
      table[MESA_FORMAT_RGBX_UINT32] = _mesa_texstore_rgba_uint32;
      table[MESA_FORMAT_RGBX_SINT32] = _mesa_texstore_rgba_int32;

      table[MESA_FORMAT_R10G10B10A2_UNORM] = _mesa_texstore_abgr2101010;

      table[MESA_FORMAT_G8R8_SNORM] = _mesa_texstore_snorm88;
      table[MESA_FORMAT_G16R16_SNORM] = _mesa_texstore_snorm1616;
d3769 15
a3783 1
      table[MESA_FORMAT_B8G8R8X8_SRGB] = _mesa_texstore_sargb8;
d3796 1
a3796 1
                                  mesa_format dstFormat)
d3825 1
a3825 1
                              GLenum baseInternalFormat, mesa_format dstFormat,
a3866 1
 * \return GL_TRUE for success, GL_FALSE for failure (out of memory).
d3902 1
a3902 1
get_read_write_mode(GLenum userFormat, mesa_format texFormat)
a3963 1
   case GL_TEXTURE_EXTERNAL_OES:
d4144 1
a4144 1
   const mesa_format texFormat = texImage->TexFormat;
@


1.1.1.7
log
@Import Mesa 10.2.7
@
text
@a3910 15
   /* Depth texture data needs clamping in following cases:
    * - Floating point dstFormat with signed srcType: clamp to [0.0, 1.0].
    * - Fixed point dstFormat with signed srcType: clamp to [0, 2^n -1].
    *
    * All the cases except one (float dstFormat with float srcType) are ruled
    * out by _mesa_format_matches_format_and_type() check above. Handle the
    * remaining case here.
    */
   if ((baseInternalFormat == GL_DEPTH_COMPONENT ||
        baseInternalFormat == GL_DEPTH_STENCIL) &&
       (srcType == GL_FLOAT ||
        srcType == GL_FLOAT_32_UNSIGNED_INT_24_8_REV)) {
      return GL_FALSE;
   }

@


1.1.1.8
log
@Import Mesa 10.4.3
@
text
@a57 1
#include "format_utils.h"
a69 1
#include "texcompress_bptc.h"
d90 29
d236 13
a248 35
   case GL_LUMINANCE:
   case GL_LUMINANCE_INTEGER_EXT:
      return IDX_LUMINANCE;
   case GL_ALPHA:
   case GL_ALPHA_INTEGER:
      return IDX_ALPHA;
   case GL_INTENSITY:
      return IDX_INTENSITY;
   case GL_LUMINANCE_ALPHA:
   case GL_LUMINANCE_ALPHA_INTEGER_EXT:
      return IDX_LUMINANCE_ALPHA;
   case GL_RGB:
   case GL_RGB_INTEGER:
      return IDX_RGB;
   case GL_RGBA:
   case GL_RGBA_INTEGER:
      return IDX_RGBA;
   case GL_RED:
   case GL_RED_INTEGER:
      return IDX_RED;
   case GL_GREEN:
      return IDX_GREEN;
   case GL_BLUE:
      return IDX_BLUE;
   case GL_BGR:
   case GL_BGR_INTEGER:
      return IDX_BGR;
   case GL_BGRA:
   case GL_BGRA_INTEGER:
      return IDX_BGRA;
   case GL_ABGR_EXT:
      return IDX_ABGR;
   case GL_RG:
   case GL_RG_INTEGER:
      return IDX_RG;
d250 1
a250 2
      _mesa_problem(NULL, "Unexpected inFormat %s",
                    _mesa_lookup_enum_by_nr(value));
d665 125
d792 124
a915 1
static const GLubyte map_1032[6] = { 1, 0, 3, 2, ZERO, ONE };
a990 4
   /* This way we will use the RGB versions of the packing functions and it
    * will work for both RGB and sRGB textures*/
   dstFormat = _mesa_get_srgb_format_linear(dstFormat);

a1180 3
      return GL_TRUE;
   } else {
      return GL_FALSE;
d1182 7
d1193 1
a1193 1
 * Texstore for _mesa_texformat_ycbcr or _mesa_texformat_ycbcr_REV.
d1196 1
a1196 1
_mesa_texstore_ycbcr(TEXSTORE_PARAMS)
d1200 51
a1250 1
   (void) ctx; (void) dims; (void) baseInternalFormat;
d1252 4
a1255 8
   ASSERT((dstFormat == MESA_FORMAT_YCBCR) ||
          (dstFormat == MESA_FORMAT_YCBCR_REV));
   ASSERT(_mesa_get_format_bytes(dstFormat) == 2);
   ASSERT(ctx->Extensions.MESA_ycbcr_texture);
   ASSERT(srcFormat == GL_YCBCR_MESA);
   ASSERT((srcType == GL_UNSIGNED_SHORT_8_8_MESA) ||
          (srcType == GL_UNSIGNED_SHORT_8_8_REV_MESA));
   ASSERT(baseInternalFormat == GL_YCBCR_MESA);
d1257 5
a1261 6
   /* always just memcpy since no pixel transfer ops apply */
   memcpy_texture(ctx, dims,
                  dstFormat,
                  dstRowStride, dstSlices,
                  srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                  srcAddr, srcPacking);
d1263 68
a1330 7
   /* Check if we need byte swapping */
   /* XXX the logic here _might_ be wrong */
   if (srcPacking->SwapBytes ^
       (srcType == GL_UNSIGNED_SHORT_8_8_REV_MESA) ^
       (dstFormat == MESA_FORMAT_YCBCR_REV) ^
       !littleEndian) {
      GLint img, row;
d1332 4
d1338 7
a1344 1
            _mesa_swap2((GLushort *) dstRow, srcWidth);
d1346 1
d1350 47
a1400 3
/**
 * Store a combined depth/stencil texture image.
 */
d1402 1
a1402 1
_mesa_texstore_z24_s8(TEXSTORE_PARAMS)
d1404 2
a1405 6
   const GLuint depthScale = 0xffffff;
   const GLint srcRowStride
      = _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType);
   GLint img, row;
   GLuint *depth = malloc(srcWidth * sizeof(GLuint));
   GLubyte *stencil = malloc(srcWidth * sizeof(GLubyte));
d1407 27
a1433 7
   ASSERT(dstFormat == MESA_FORMAT_S8_UINT_Z24_UNORM);
   ASSERT(srcFormat == GL_DEPTH_STENCIL_EXT ||
          srcFormat == GL_DEPTH_COMPONENT ||
          srcFormat == GL_STENCIL_INDEX);
   ASSERT(srcFormat != GL_DEPTH_STENCIL_EXT ||
          srcType == GL_UNSIGNED_INT_24_8_EXT ||
          srcType == GL_FLOAT_32_UNSIGNED_INT_24_8_REV);
d1435 23
a1457 4
   if (!depth || !stencil) {
      free(depth);
      free(stencil);
      return GL_FALSE;
d1459 2
a1461 11
   /* In case we only upload depth we need to preserve the stencil */
   for (img = 0; img < srcDepth; img++) {
      GLuint *dstRow = (GLuint *) dstSlices[img];
      const GLubyte *src
         = (const GLubyte *) _mesa_image_address(dims, srcPacking, srcAddr,
               srcWidth, srcHeight,
               srcFormat, srcType,
               img, 0, 0);
      for (row = 0; row < srcHeight; row++) {
         GLint i;
         GLboolean keepdepth = GL_FALSE, keepstencil = GL_FALSE;
d1463 26
a1488 5
         if (srcFormat == GL_DEPTH_COMPONENT) { /* preserve stencil */
            keepstencil = GL_TRUE;
         }
         else if (srcFormat == GL_STENCIL_INDEX) { /* preserve depth */
            keepdepth = GL_TRUE;
d1490 34
d1525 6
a1530 7
         if (keepdepth == GL_FALSE)
            /* the 24 depth bits will be in the low position: */
            _mesa_unpack_depth_span(ctx, srcWidth,
                                    GL_UNSIGNED_INT, /* dst type */
                                    keepstencil ? depth : dstRow, /* dst addr */
                                    depthScale,
                                    srcType, src, srcPacking);
d1532 22
a1553 7
         if (keepstencil == GL_FALSE)
            /* get the 8-bit stencil values */
            _mesa_unpack_stencil_span(ctx, srcWidth,
                                      GL_UNSIGNED_BYTE, /* dst type */
                                      stencil, /* dst addr */
                                      srcType, src, srcPacking,
                                      ctx->_ImageTransferState);
d1555 11
a1565 5
         for (i = 0; i < srcWidth; i++) {
            if (keepstencil)
               dstRow[i] = depth[i] << 8 | (dstRow[i] & 0x000000FF);
            else
               dstRow[i] = (dstRow[i] & 0xFFFFFF00) | (stencil[i] & 0xFF);
a1566 2
         src += srcRowStride;
         dstRow += dstRowStride / sizeof(GLuint);
d1568 1
a1569 3

   free(depth);
   free(stencil);
d1575 1
a1575 1
 * Store a combined depth/stencil texture image.
d1578 1
a1578 1
_mesa_texstore_s8_z24(TEXSTORE_PARAMS)
d1580 1
a1580 6
   const GLuint depthScale = 0xffffff;
   const GLint srcRowStride
      = _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType);
   GLint img, row;
   GLuint *depth;
   GLubyte *stencil;
d1582 2
a1583 7
   ASSERT(dstFormat == MESA_FORMAT_Z24_UNORM_S8_UINT);
   ASSERT(srcFormat == GL_DEPTH_STENCIL_EXT ||
          srcFormat == GL_DEPTH_COMPONENT ||
          srcFormat == GL_STENCIL_INDEX);
   ASSERT(srcFormat != GL_DEPTH_STENCIL_EXT ||
          srcType == GL_UNSIGNED_INT_24_8_EXT ||
          srcType == GL_FLOAT_32_UNSIGNED_INT_24_8_REV);
d1585 26
a1610 7
   depth = malloc(srcWidth * sizeof(GLuint));
   stencil = malloc(srcWidth * sizeof(GLubyte));

   if (!depth || !stencil) {
      free(depth);
      free(stencil);
      return GL_FALSE;
d1612 2
a1614 17
   for (img = 0; img < srcDepth; img++) {
      GLuint *dstRow = (GLuint *) dstSlices[img];
      const GLubyte *src
	 = (const GLubyte *) _mesa_image_address(dims, srcPacking, srcAddr,
						srcWidth, srcHeight,
						srcFormat, srcType,
						img, 0, 0);
      for (row = 0; row < srcHeight; row++) {
	 GLint i;
	 GLboolean keepdepth = GL_FALSE, keepstencil = GL_FALSE;
	 
	 if (srcFormat == GL_DEPTH_COMPONENT) { /* preserve stencil */
	    keepstencil = GL_TRUE;
	 }
         else if (srcFormat == GL_STENCIL_INDEX) { /* preserve depth */
	    keepdepth = GL_TRUE;
	 }
d1616 8
a1623 7
	 if (keepdepth == GL_FALSE)
	    /* the 24 depth bits will be in the low position: */
	    _mesa_unpack_depth_span(ctx, srcWidth,
				    GL_UNSIGNED_INT, /* dst type */
				    keepstencil ? depth : dstRow, /* dst addr */
				    depthScale,
				    srcType, src, srcPacking);	 
d1625 5
a1629 7
	 if (keepstencil == GL_FALSE)
	    /* get the 8-bit stencil values */
	    _mesa_unpack_stencil_span(ctx, srcWidth,
				      GL_UNSIGNED_BYTE, /* dst type */
				      stencil, /* dst addr */
				      srcType, src, srcPacking,
				      ctx->_ImageTransferState);
d1631 6
a1636 6
	 /* merge stencil values into depth values */
	 for (i = 0; i < srcWidth; i++) {
	    if (keepstencil)
	       dstRow[i] = depth[i] | (dstRow[i] & 0xFF000000);
	    else
	       dstRow[i] = (dstRow[i] & 0xFFFFFF) | (stencil[i] << 24);
d1638 22
a1660 2
	 src += srcRowStride;
	 dstRow += dstRowStride / sizeof(GLuint);
d1662 49
a1711 4

   free(depth);
   free(stencil);

d1717 1
a1717 1
 * Store simple 8-bit/value stencil texture data.
d1720 1
a1720 1
_mesa_texstore_s8(TEXSTORE_PARAMS)
d1722 7
a1728 2
   ASSERT(dstFormat == MESA_FORMAT_S_UINT8);
   ASSERT(srcFormat == GL_STENCIL_INDEX);
d1731 11
a1741 6
      const GLint srcRowStride
	 = _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType);
      GLint img, row;
      GLubyte *stencil = malloc(srcWidth * sizeof(GLubyte));

      if (!stencil)
a1742 1

a1744 5
         const GLubyte *src
            = (const GLubyte *) _mesa_image_address(dims, srcPacking, srcAddr,
                                                   srcWidth, srcHeight,
                                                   srcFormat, srcType,
                                                   img, 0, 0);
d1746 42
a1787 1
            GLint i;
d1789 1617
a3405 12
            /* get the 8-bit stencil values */
            _mesa_unpack_stencil_span(ctx, srcWidth,
                                      GL_UNSIGNED_BYTE, /* dst type */
                                      stencil, /* dst addr */
                                      srcType, src, srcPacking,
                                      ctx->_ImageTransferState);
            /* merge stencil values into depth values */
            for (i = 0; i < srcWidth; i++)
               dstRow[i] = stencil[i];

            src += srcRowStride;
            dstRow += dstRowStride / sizeof(GLubyte);
d3409 1
a3409 1
      free(stencil);
a3410 1

d3576 43
d3621 22
a3642 1
texstore_depth_stencil(TEXSTORE_PARAMS)
d3648 1
a3648 1
      memset(table, 0, sizeof table);
d3650 38
d3695 5
a3699 22
      table[MESA_FORMAT_Z_FLOAT32] = _mesa_texstore_z32;
      table[MESA_FORMAT_Z32_FLOAT_S8X24_UINT] = _mesa_texstore_z32f_x24s8;

      initialized = GL_TRUE;
   }

   ASSERT(table[dstFormat]);
   return table[dstFormat](ctx, dims, baseInternalFormat,
                           dstFormat, dstRowStride, dstSlices,
                           srcWidth, srcHeight, srcDepth,
                           srcFormat, srcType, srcAddr, srcPacking);
}

static GLboolean
texstore_compressed(TEXSTORE_PARAMS)
{
   static StoreTexImageFunc table[MESA_FORMAT_COUNT];
   static GLboolean initialized = GL_FALSE;

   if (!initialized) {
      memset(table, 0, sizeof table);

d3710 27
d3758 12
d3771 53
a3823 8
      table[MESA_FORMAT_BPTC_RGBA_UNORM] =
         _mesa_texstore_bptc_rgba_unorm;
      table[MESA_FORMAT_BPTC_SRGB_ALPHA_UNORM] =
         _mesa_texstore_bptc_rgba_unorm;
      table[MESA_FORMAT_BPTC_RGB_SIGNED_FLOAT] =
         _mesa_texstore_bptc_rgb_signed_float;
      table[MESA_FORMAT_BPTC_RGB_UNSIGNED_FLOAT] =
         _mesa_texstore_bptc_rgb_unsigned_float;
d3825 2
a3826 2
      initialized = GL_TRUE;
   }
d3828 16
a3843 6
   ASSERT(table[dstFormat]);
   return table[dstFormat](ctx, dims, baseInternalFormat,
                           dstFormat, dstRowStride, dstSlices,
                           srcWidth, srcHeight, srcDepth,
                           srcFormat, srcType, srcAddr, srcPacking);
}
d3845 1
a3845 4
static void
invert_swizzle(uint8_t dst[4], const uint8_t src[4])
{
   int i, j;
d3847 2
a3848 4
   dst[0] = MESA_FORMAT_SWIZZLE_NONE;
   dst[1] = MESA_FORMAT_SWIZZLE_NONE;
   dst[2] = MESA_FORMAT_SWIZZLE_NONE;
   dst[3] = MESA_FORMAT_SWIZZLE_NONE;
d3850 1
a3850 5
   for (i = 0; i < 4; ++i)
      for (j = 0; j < 4; ++j)
         if (src[j] == i && dst[i] == MESA_FORMAT_SWIZZLE_NONE)
            dst[i] = j;
}
d3852 1
a3852 148
/** Store a texture by per-channel conversions and swizzling.
 *
 * This function attempts to perform a texstore operation by doing simple
 * per-channel conversions and swizzling.  This covers a huge chunk of the
 * texture storage operations that anyone cares about.  If this function is
 * incapable of performing the operation, it bails and returns GL_FALSE.
 */
static GLboolean
texstore_swizzle(TEXSTORE_PARAMS)
{
   const GLint srcRowStride = _mesa_image_row_stride(srcPacking, srcWidth,
                                                     srcFormat, srcType);
   const GLint srcImageStride = _mesa_image_image_stride(srcPacking,
                                      srcWidth, srcHeight, srcFormat, srcType);
   const GLubyte *srcImage = (const GLubyte *) _mesa_image_address(dims,
        srcPacking, srcAddr, srcWidth, srcHeight, srcFormat, srcType, 0, 0, 0);
   const int src_components = _mesa_components_in_format(srcFormat);

   GLubyte swizzle[4], rgba2base[6], base2src[6], rgba2dst[4], dst2rgba[4];
   const GLubyte *swap;
   GLenum dst_type;
   int dst_components;
   bool is_array, normalized, need_swap;
   GLint i, img, row;
   const GLubyte *src_row;
   GLubyte *dst_row;

   is_array = _mesa_format_to_array(dstFormat, &dst_type, &dst_components,
                                    rgba2dst, &normalized);

   if (!is_array)
      return GL_FALSE;

   if (srcFormat == GL_COLOR_INDEX)
      return GL_FALSE;

   if (_mesa_texstore_needs_transfer_ops(ctx, baseInternalFormat, dstFormat))
      return GL_FALSE;

   switch (srcType) {
   case GL_FLOAT:
   case GL_UNSIGNED_BYTE:
   case GL_BYTE:
   case GL_UNSIGNED_SHORT:
   case GL_SHORT:
   case GL_UNSIGNED_INT:
   case GL_INT:
      /* If wa have to swap bytes in a multi-byte datatype, that means
       * we're not doing an array conversion anymore */
      if (srcPacking->SwapBytes)
         return GL_FALSE;
      need_swap = false;
      break;
   case GL_UNSIGNED_INT_8_8_8_8:
      need_swap = srcPacking->SwapBytes;
      if (_mesa_little_endian())
         need_swap = !need_swap;
      srcType = GL_UNSIGNED_BYTE;
      break;
   case GL_UNSIGNED_INT_8_8_8_8_REV:
      need_swap = srcPacking->SwapBytes;
      if (!_mesa_little_endian())
         need_swap = !need_swap;
      srcType = GL_UNSIGNED_BYTE;
      break;
   default:
      return GL_FALSE;
   }
   swap = need_swap ? map_3210 : map_identity;

   compute_component_mapping(srcFormat, baseInternalFormat, base2src);
   compute_component_mapping(baseInternalFormat, GL_RGBA, rgba2base);
   invert_swizzle(dst2rgba, rgba2dst);

   for (i = 0; i < 4; i++) {
      if (dst2rgba[i] == MESA_FORMAT_SWIZZLE_NONE)
         swizzle[i] = MESA_FORMAT_SWIZZLE_NONE;
      else
         swizzle[i] = swap[base2src[rgba2base[dst2rgba[i]]]];
   }

   /* Is it normalized? */
   normalized |= !_mesa_is_enum_format_integer(srcFormat);

   for (img = 0; img < srcDepth; img++) {
      if (dstRowStride == srcWidth * dst_components &&
          srcRowStride == srcWidth * src_components) {
         _mesa_swizzle_and_convert(dstSlices[img], dst_type, dst_components,
                                   srcImage, srcType, src_components,
                                   swizzle, normalized, srcWidth * srcHeight);
      } else {
         src_row = srcImage;
         dst_row = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            _mesa_swizzle_and_convert(dst_row, dst_type, dst_components,
                                      src_row, srcType, src_components,
                                      swizzle, normalized, srcWidth);
            dst_row += dstRowStride;
            src_row += srcRowStride;
         }
      }
      srcImage += srcImageStride;
   }

   return GL_TRUE;
}


/** Stores a texture by converting float and then to the texture format
 *
 * This function performs a texstore operation by converting to float,
 * applying pixel transfer ops, and then converting to the texture's
 * internal format using pixel store functions.  This function will work
 * for any rgb or srgb textore format.
 */
static GLboolean
texstore_via_float(TEXSTORE_PARAMS)
{
   GLuint i, img, row;
   const GLint src_stride =
      _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType);
   float *tmp_row;
   bool need_convert;
   uint8_t *src_row, *dst_row, map[4], rgba2base[6], base2rgba[6];

   tmp_row = malloc(srcWidth * 4 * sizeof(*tmp_row));
   if (!tmp_row)
      return GL_FALSE;

   /* The GL spec (4.0, compatibility profile) only specifies srgb
    * conversion as something that is done in the sampler during the
    * filtering process before the colors are handed to the shader.
    * Furthermore, the flowchart (Figure 3.7 in the 4.0 compatibility spec)
    * does not list RGB <-> sRGB conversions anywhere.  Therefore, we just
    * treat sRGB formats the same as RGB formats for the purposes of
    * texture upload and transfer ops.
    */
   dstFormat = _mesa_get_srgb_format_linear(dstFormat);

   need_convert = false;
   if (baseInternalFormat != _mesa_get_format_base_format(dstFormat)) {
      compute_component_mapping(GL_RGBA, baseInternalFormat, base2rgba);
      compute_component_mapping(baseInternalFormat, GL_RGBA, rgba2base);
      for (i = 0; i < 4; ++i) {
         map[i] = base2rgba[rgba2base[i]];
         if (map[i] != i)
            need_convert = true;
      }
d3855 2
a3856 95
   for (img = 0; img < srcDepth; img++) {
      dst_row = dstSlices[img];
      src_row = _mesa_image_address(dims, srcPacking, srcAddr,
                                    srcWidth, srcHeight,
                                    srcFormat, srcType,
                                    img, 0, 0);
      for (row = 0; row < srcHeight; row++) {
	 _mesa_unpack_color_span_float(ctx, srcWidth, GL_RGBA, tmp_row,
                                       srcFormat, srcType, src_row,
				       srcPacking, ctx->_ImageTransferState);
         if (need_convert)
            _mesa_swizzle_and_convert(tmp_row, GL_FLOAT, 4,
                                      tmp_row, GL_FLOAT, 4,
                                      map, false, srcWidth);
         _mesa_pack_float_rgba_row(dstFormat, srcWidth,
                                   (const GLfloat (*)[4])tmp_row,
                                   dst_row);
         dst_row += dstRowStride;
         src_row += src_stride;
      }
   }

   free(tmp_row);

   return GL_TRUE;
}

/** Stores an integer rgba texture
 *
 * This function performs an integer texture storage operation by unpacking
 * the texture to 32-bit integers, and repacking it into the internal
 * format of the texture.  This will work for any integer rgb texture
 * storage operation.
 */
static GLboolean
texstore_rgba_integer(TEXSTORE_PARAMS)
{
   GLuint i, img, row, *tmp_row;
   GLenum dst_type, tmp_type;
   const GLint src_stride =
      _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType);
   int num_dst_components;
   bool is_array, normalized;
   uint8_t *src_row, *dst_row;
   uint8_t swizzle[4], rgba2base[6], base2rgba[6], rgba2dst[4], dst2rgba[4];

   tmp_row = malloc(srcWidth * 4 * sizeof(*tmp_row));
   if (!tmp_row)
      return GL_FALSE;

   is_array = _mesa_format_to_array(dstFormat, &dst_type, &num_dst_components,
                                    rgba2dst, &normalized);

   assert(is_array && !normalized);

   if (!is_array)
      return GL_FALSE;

   invert_swizzle(dst2rgba, rgba2dst);
   compute_component_mapping(GL_RGBA, baseInternalFormat, base2rgba);
   compute_component_mapping(baseInternalFormat, GL_RGBA, rgba2base);

   for (i = 0; i < 4; ++i) {
      if (dst2rgba[i] == MESA_FORMAT_SWIZZLE_NONE)
         swizzle[i] = MESA_FORMAT_SWIZZLE_NONE;
      else
         swizzle[i] = base2rgba[rgba2base[dst2rgba[i]]];
   }

   if (_mesa_is_type_unsigned(srcType)) {
      tmp_type = GL_UNSIGNED_INT;
   } else {
      tmp_type = GL_INT;
   }

   for (img = 0; img < srcDepth; img++) {
      dst_row = dstSlices[img];
      src_row = _mesa_image_address(dims, srcPacking, srcAddr,
                                    srcWidth, srcHeight,
                                    srcFormat, srcType,
                                    img, 0, 0);
      for (row = 0; row < srcHeight; row++) {
	 _mesa_unpack_color_span_uint(ctx, srcWidth, GL_RGBA, tmp_row,
                                      srcFormat, srcType, src_row, srcPacking);
         _mesa_swizzle_and_convert(dst_row, dst_type, num_dst_components,
                                   tmp_row, tmp_type, 4,
                                   swizzle, false, srcWidth);
         dst_row += dstRowStride;
         src_row += src_stride;
      }
   }

   free(tmp_row);

   return GL_TRUE;
a3858 57
static GLboolean
texstore_rgba(TEXSTORE_PARAMS)
{
   static StoreTexImageFunc table[MESA_FORMAT_COUNT];
   static GLboolean initialized = GL_FALSE;

   if (!initialized) {
      memset(table, 0, sizeof table);

      table[MESA_FORMAT_B5G6R5_UNORM] = _mesa_texstore_rgb565;
      table[MESA_FORMAT_R5G6B5_UNORM] = _mesa_texstore_rgb565;
      table[MESA_FORMAT_YCBCR] = _mesa_texstore_ycbcr;
      table[MESA_FORMAT_YCBCR_REV] = _mesa_texstore_ycbcr;

      table[MESA_FORMAT_B10G10R10A2_UINT] = _mesa_texstore_argb2101010_uint;
      table[MESA_FORMAT_R10G10B10A2_UINT] = _mesa_texstore_abgr2101010_uint;

      initialized = GL_TRUE;
   }

   if (table[dstFormat] && table[dstFormat](ctx, dims, baseInternalFormat,
                                            dstFormat, dstRowStride, dstSlices,
                                            srcWidth, srcHeight, srcDepth,
                                            srcFormat, srcType, srcAddr,
                                            srcPacking)) {
      return GL_TRUE;
   }

   if (texstore_swizzle(ctx, dims, baseInternalFormat,
                        dstFormat,
                        dstRowStride, dstSlices,
                        srcWidth, srcHeight, srcDepth,
                        srcFormat, srcType, srcAddr, srcPacking)) {
      return GL_TRUE;
   }

   if (_mesa_is_format_integer(dstFormat)) {
      return texstore_rgba_integer(ctx, dims, baseInternalFormat,
                                   dstFormat, dstRowStride, dstSlices,
                                   srcWidth, srcHeight, srcDepth,
                                   srcFormat, srcType, srcAddr,
                                   srcPacking);
   } else if (_mesa_get_format_max_bits(dstFormat) <= 8 &&
              !_mesa_is_format_signed(dstFormat)) {
      return store_ubyte_texture(ctx, dims, baseInternalFormat,
                                 dstFormat,
                                 dstRowStride, dstSlices,
                                 srcWidth, srcHeight, srcDepth,
                                 srcFormat, srcType, srcAddr, srcPacking);
   } else {
      return texstore_via_float(ctx, dims, baseInternalFormat,
                                dstFormat, dstRowStride, dstSlices,
                                srcWidth, srcHeight, srcDepth,
                                srcFormat, srcType, srcAddr,
                                srcPacking);
   }
}
d3944 2
d3954 3
d3965 8
a3972 16
   if (_mesa_is_depth_or_stencil_format(baseInternalFormat)) {
      return texstore_depth_stencil(ctx, dims, baseInternalFormat,
                                    dstFormat, dstRowStride, dstSlices,
                                    srcWidth, srcHeight, srcDepth,
                                    srcFormat, srcType, srcAddr, srcPacking);
   } else if (_mesa_is_format_compressed(dstFormat)) {
      return texstore_compressed(ctx, dims, baseInternalFormat,
                                 dstFormat, dstRowStride, dstSlices,
                                 srcWidth, srcHeight, srcDepth,
                                 srcFormat, srcType, srcAddr, srcPacking);
   } else {
      return texstore_rgba(ctx, dims, baseInternalFormat,
                           dstFormat, dstRowStride, dstSlices,
                           srcWidth, srcHeight, srcDepth,
                           srcFormat, srcType, srcAddr, srcPacking);
   }
a4174 72
static void
clear_image_to_zero(GLubyte *dstMap, GLint dstRowStride,
                    GLsizei width, GLsizei height,
                    GLsizei clearValueSize)
{
   GLsizei y;

   for (y = 0; y < height; y++) {
      memset(dstMap, 0, clearValueSize * width);
      dstMap += dstRowStride;
   }
}

static void
clear_image_to_value(GLubyte *dstMap, GLint dstRowStride,
                     GLsizei width, GLsizei height,
                     const GLvoid *clearValue,
                     GLsizei clearValueSize)
{
   GLsizei y, x;

   for (y = 0; y < height; y++) {
      for (x = 0; x < width; x++) {
         memcpy(dstMap, clearValue, clearValueSize);
         dstMap += clearValueSize;
      }
      dstMap += dstRowStride - clearValueSize * width;
   }
}

/*
 * Fallback for Driver.ClearTexSubImage().
 */
void
_mesa_store_cleartexsubimage(struct gl_context *ctx,
                             struct gl_texture_image *texImage,
                             GLint xoffset, GLint yoffset, GLint zoffset,
                             GLsizei width, GLsizei height, GLsizei depth,
                             const GLvoid *clearValue)
{
   GLubyte *dstMap;
   GLint dstRowStride;
   GLsizeiptr clearValueSize;
   GLsizei z;

   clearValueSize = _mesa_get_format_bytes(texImage->TexFormat);

   for (z = 0; z < depth; z++) {
      ctx->Driver.MapTextureImage(ctx, texImage,
                                  z + zoffset, xoffset, yoffset,
                                  width, height,
                                  GL_MAP_WRITE_BIT,
                                  &dstMap, &dstRowStride);
      if (dstMap == NULL) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glClearTex*Image");
         return;
      }

      if (clearValue) {
         clear_image_to_value(dstMap, dstRowStride,
                              width, height,
                              clearValue,
                              clearValueSize);
      } else {
         clear_image_to_zero(dstMap, dstRowStride,
                             width, height,
                             clearValueSize);
      }

      ctx->Driver.UnmapTextureImage(ctx, texImage, z + zoffset);
   }
}
a4213 64
 * Compute compressed_pixelstore parameters for copying compressed
 * texture data.
 * \param dims  number of texture image dimensions: 1, 2 or 3
 * \param texFormat  the compressed texture format
 * \param width, height, depth  size of image to copy
 * \param packing  pixelstore parameters describing user-space image packing
 * \param store  returns the compressed_pixelstore parameters
 */
void
_mesa_compute_compressed_pixelstore(GLuint dims, mesa_format texFormat,
                                    GLsizei width, GLsizei height,
                                    GLsizei depth,
                                    const struct gl_pixelstore_attrib *packing,
                                    struct compressed_pixelstore *store)
{
   GLuint bw, bh;

   _mesa_get_format_block_size(texFormat, &bw, &bh);

   store->SkipBytes = 0;
   store->TotalBytesPerRow = store->CopyBytesPerRow =
         _mesa_format_row_stride(texFormat, width);
   store->TotalRowsPerSlice = store->CopyRowsPerSlice =
         (height + bh - 1) / bh;
   store->CopySlices = depth;

   if (packing->CompressedBlockWidth &&
       packing->CompressedBlockSize) {

      bw = packing->CompressedBlockWidth;

      if (packing->RowLength) {
         store->TotalBytesPerRow = packing->CompressedBlockSize *
            ((packing->RowLength + bw - 1) / bw);
      }

      store->SkipBytes += packing->SkipPixels * packing->CompressedBlockSize / bw;
   }

   if (dims > 1 && packing->CompressedBlockHeight &&
       packing->CompressedBlockSize) {

      bh = packing->CompressedBlockHeight;

      store->SkipBytes += packing->SkipRows * store->TotalBytesPerRow / bh;
      store->CopyRowsPerSlice = (height + bh - 1) / bh;  /* rows in blocks */

      if (packing->ImageHeight) {
         store->TotalRowsPerSlice = (packing->ImageHeight + bh - 1) / bh;
      }
   }

   if (dims > 2 && packing->CompressedBlockDepth &&
       packing->CompressedBlockSize) {

      int bd = packing->CompressedBlockDepth;

      store->SkipBytes += packing->SkipImages * store->TotalBytesPerRow *
            store->TotalRowsPerSlice / bd;
   }
}


/**
d4224 2
a4225 3
   struct compressed_pixelstore store;
   GLint dstRowStride;
   GLint i, slice;
d4228 3
d4237 1
a4237 3
   _mesa_compute_compressed_pixelstore(dims, texImage->TexFormat,
                                       width, height, depth,
                                       &ctx->Unpack, &store);
d4246 2
a4247 1
   src = (const GLubyte *) data + store.SkipBytes;
d4249 1
a4249 1
   for (slice = 0; slice < store.CopySlices; slice++) {
d4257 2
d4261 2
a4262 2
         for (i = 0; i < store.CopyRowsPerSlice; i++) {
            memcpy(dstMap, src, store.CopyBytesPerRow);
d4264 1
a4264 1
            src += store.TotalBytesPerRow;
a4267 3

         /* advance to next slice */
         src += store.TotalBytesPerRow * (store.TotalRowsPerSlice - store.CopyRowsPerSlice);
@


1.1.1.9
log
@Import Mesa 10.2.9
@
text
@d58 1
d71 1
a91 29
/**
 * Return GL_TRUE if the given image format is one that be converted
 * to another format by swizzling.
 */
static GLboolean
can_swizzle(GLenum logicalBaseFormat)
{
   switch (logicalBaseFormat) {
   case GL_RGBA:
   case GL_RGB:
   case GL_LUMINANCE_ALPHA:
   case GL_INTENSITY:
   case GL_ALPHA:
   case GL_LUMINANCE:
   case GL_RED:
   case GL_GREEN:
   case GL_BLUE:
   case GL_BGR:
   case GL_BGRA:
   case GL_ABGR_EXT:
   case GL_RG:
      return GL_TRUE;
   default:
      return GL_FALSE;
   }
}



d209 35
a243 13
   case GL_LUMINANCE: return IDX_LUMINANCE;
   case GL_ALPHA: return IDX_ALPHA;
   case GL_INTENSITY: return IDX_INTENSITY;
   case GL_LUMINANCE_ALPHA: return IDX_LUMINANCE_ALPHA;
   case GL_RGB: return IDX_RGB;
   case GL_RGBA: return IDX_RGBA;
   case GL_RED: return IDX_RED;
   case GL_GREEN: return IDX_GREEN;
   case GL_BLUE: return IDX_BLUE;
   case GL_BGR: return IDX_BGR;
   case GL_BGRA: return IDX_BGRA;
   case GL_ABGR_EXT: return IDX_ABGR;
   case GL_RG: return IDX_RG;
d245 2
a246 1
      _mesa_problem(NULL, "Unexpected inFormat");
a660 125
/**
 * Copy GLubyte pixels from <src> to <dst> with swizzling.
 * \param dst  destination pixels
 * \param dstComponents  number of color components in destination pixels
 * \param src  source pixels
 * \param srcComponents  number of color components in source pixels
 * \param map  the swizzle mapping.  map[X] says where to find the X component
 *             in the source image's pixels.  For example, if the source image
 *             is GL_BGRA and X = red, map[0] yields 2.
 * \param count  number of pixels to copy/swizzle.
 */
static void
swizzle_copy(GLubyte *dst, GLuint dstComponents, const GLubyte *src, 
             GLuint srcComponents, const GLubyte *map, GLuint count)
{
#define SWZ_CPY(dst, src, count, dstComps, srcComps) \
   do {                                              \
      GLuint i;                                      \
      for (i = 0; i < count; i++) {                  \
         GLuint j;                                   \
         if (srcComps == 4) {                        \
            COPY_4UBV(tmp, src);                     \
         }                                           \
         else {                                      \
            for (j = 0; j < srcComps; j++) {         \
               tmp[j] = src[j];                      \
            }                                        \
         }                                           \
         src += srcComps;                            \
         for (j = 0; j < dstComps; j++) {            \
            dst[j] = tmp[map[j]];                    \
         }                                           \
         dst += dstComps;                            \
      }                                              \
   } while (0)

   GLubyte tmp[6];

   tmp[ZERO] = 0x0;
   tmp[ONE] = 0xff;

   ASSERT(srcComponents <= 4);
   ASSERT(dstComponents <= 4);

   switch (dstComponents) {
   case 4:
      switch (srcComponents) {
      case 4:
         SWZ_CPY(dst, src, count, 4, 4);
         break;
      case 3:
         SWZ_CPY(dst, src, count, 4, 3);
         break;
      case 2:
         SWZ_CPY(dst, src, count, 4, 2);
         break;
      case 1:
         SWZ_CPY(dst, src, count, 4, 1);
         break;
      default:
         ;
      }
      break;
   case 3:
      switch (srcComponents) {
      case 4:
         SWZ_CPY(dst, src, count, 3, 4);
         break;
      case 3:
         SWZ_CPY(dst, src, count, 3, 3);
         break;
      case 2:
         SWZ_CPY(dst, src, count, 3, 2);
         break;
      case 1:
         SWZ_CPY(dst, src, count, 3, 1);
         break;
      default:
         ;
      }
      break;
   case 2:
      switch (srcComponents) {
      case 4:
         SWZ_CPY(dst, src, count, 2, 4);
         break;
      case 3:
         SWZ_CPY(dst, src, count, 2, 3);
         break;
      case 2:
         SWZ_CPY(dst, src, count, 2, 2);
         break;
      case 1:
         SWZ_CPY(dst, src, count, 2, 1);
         break;
      default:
         ;
      }
      break;
   case 1:
      switch (srcComponents) {
      case 4:
         SWZ_CPY(dst, src, count, 1, 4);
         break;
      case 3:
         SWZ_CPY(dst, src, count, 1, 3);
         break;
      case 2:
         SWZ_CPY(dst, src, count, 1, 2);
         break;
      case 1:
         SWZ_CPY(dst, src, count, 1, 1);
         break;
      default:
         ;
      }
      break;
   default:
      ;
   }
#undef SWZ_CPY
}



d663 1
a663 124


/**
 * For 1-byte/pixel formats (or 8_8_8_8 packed formats), return a
 * mapping array depending on endianness.
 */
static const GLubyte *
type_mapping( GLenum srcType )
{
   switch (srcType) {
   case GL_BYTE:
   case GL_UNSIGNED_BYTE:
      return map_identity;
   case GL_UNSIGNED_INT_8_8_8_8:
      return _mesa_little_endian() ? map_3210 : map_identity;
   case GL_UNSIGNED_INT_8_8_8_8_REV:
      return _mesa_little_endian() ? map_identity : map_3210;
   default:
      return NULL;
   }
}


/**
 * For 1-byte/pixel formats (or 8_8_8_8 packed formats), return a
 * mapping array depending on pixelstore byte swapping state.
 */
static const GLubyte *
byteswap_mapping( GLboolean swapBytes,
		  GLenum srcType )
{
   if (!swapBytes) 
      return map_identity;

   switch (srcType) {
   case GL_BYTE:
   case GL_UNSIGNED_BYTE:
      return map_identity;
   case GL_UNSIGNED_INT_8_8_8_8:
   case GL_UNSIGNED_INT_8_8_8_8_REV:
      return map_3210;
   default:
      return NULL;
   }
}



/**
 * Transfer a GLubyte texture image with component swizzling.
 */
static void
_mesa_swizzle_ubyte_image(struct gl_context *ctx, 
			  GLuint dimensions,
			  GLenum srcFormat,
			  GLenum srcType,

			  GLenum baseInternalFormat,

			  const GLubyte *rgba2dst,
			  GLuint dstComponents,

			  GLint dstRowStride,
                          GLubyte **dstSlices,

			  GLint srcWidth, GLint srcHeight, GLint srcDepth,
			  const GLvoid *srcAddr,
			  const struct gl_pixelstore_attrib *srcPacking )
{
   GLint srcComponents = _mesa_components_in_format(srcFormat);
   const GLubyte *srctype2ubyte, *swap;
   GLubyte map[4], src2base[6], base2rgba[6];
   GLint i;
   const GLint srcRowStride =
      _mesa_image_row_stride(srcPacking, srcWidth,
                             srcFormat, GL_UNSIGNED_BYTE);
   const GLint srcImageStride
      = _mesa_image_image_stride(srcPacking, srcWidth, srcHeight, srcFormat,
                                 GL_UNSIGNED_BYTE);
   const GLubyte *srcImage
      = (const GLubyte *) _mesa_image_address(dimensions, srcPacking, srcAddr,
                                              srcWidth, srcHeight, srcFormat,
                                              GL_UNSIGNED_BYTE, 0, 0, 0);

   (void) ctx;

   /* Translate from src->baseInternal->GL_RGBA->dst.  This will
    * correctly deal with RGBA->RGB->RGBA conversions where the final
    * A value must be 0xff regardless of the incoming alpha values.
    */
   compute_component_mapping(srcFormat, baseInternalFormat, src2base);
   compute_component_mapping(baseInternalFormat, GL_RGBA, base2rgba);
   swap = byteswap_mapping(srcPacking->SwapBytes, srcType);
   srctype2ubyte = type_mapping(srcType);


   for (i = 0; i < 4; i++)
      map[i] = srctype2ubyte[swap[src2base[base2rgba[rgba2dst[i]]]]];

/*    printf("map %d %d %d %d\n", map[0], map[1], map[2], map[3]);  */

   if (srcComponents == dstComponents &&
       srcRowStride == dstRowStride &&
       srcRowStride == srcWidth * srcComponents &&
       dimensions < 3) {
      /* 1 and 2D images only */
      GLubyte *dstImage = dstSlices[0];
      swizzle_copy(dstImage, dstComponents, srcImage, srcComponents, map, 
		   srcWidth * srcHeight);
   }
   else {
      GLint img, row;
      for (img = 0; img < srcDepth; img++) {
         const GLubyte *srcRow = srcImage;
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
	    swizzle_copy(dstRow, dstComponents, srcRow, srcComponents, map, srcWidth);
            dstRow += dstRowStride;
            srcRow += srcRowStride;
         }
         srcImage += srcImageStride;
      }
   }
}
d739 4
d933 3
a936 7
   else {
      return store_ubyte_texture(ctx, dims, baseInternalFormat,
                                 dstFormat, dstRowStride, dstSlices,
                                 srcWidth, srcHeight, srcDepth,
                                 srcFormat, srcType, srcAddr, srcPacking);
   }
   return GL_TRUE;
d941 1
a941 1
 * Store a texture in MESA_FORMAT_A8B8G8R8_UNORM or MESA_FORMAT_R8G8B8A8_UNORM.
d944 1
a944 1
_mesa_texstore_rgba8888(TEXSTORE_PARAMS)
d948 1
a948 5
   ASSERT(dstFormat == MESA_FORMAT_A8B8G8R8_UNORM ||
          dstFormat == MESA_FORMAT_R8G8B8A8_UNORM ||
          dstFormat == MESA_FORMAT_X8B8G8R8_UNORM ||
          dstFormat == MESA_FORMAT_R8G8B8X8_UNORM);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 4);
d950 8
a957 6
   if (!ctx->_ImageTransferState &&
       (srcType == GL_UNSIGNED_BYTE ||
        srcType == GL_UNSIGNED_INT_8_8_8_8 ||
        srcType == GL_UNSIGNED_INT_8_8_8_8_REV) &&
       can_swizzle(baseInternalFormat) &&
       can_swizzle(srcFormat)) {
d959 6
a964 1
      GLubyte dstmap[4];
d966 7
a972 57
      /* dstmap - how to swizzle from RGBA to dst format:
       */
      if ((littleEndian && (dstFormat == MESA_FORMAT_A8B8G8R8_UNORM ||
                            dstFormat == MESA_FORMAT_X8B8G8R8_UNORM)) ||
	  (!littleEndian && (dstFormat == MESA_FORMAT_R8G8B8A8_UNORM ||
	                     dstFormat == MESA_FORMAT_R8G8B8X8_UNORM))) {
	 dstmap[3] = 0;
	 dstmap[2] = 1;
	 dstmap[1] = 2;
	 dstmap[0] = 3;
      }
      else {
	 dstmap[3] = 3;
	 dstmap[2] = 2;
	 dstmap[1] = 1;
	 dstmap[0] = 0;
      }
      
      _mesa_swizzle_ubyte_image(ctx, dims,
				srcFormat,
				srcType,
				baseInternalFormat,
				dstmap, 4,
				dstRowStride, dstSlices,
				srcWidth, srcHeight, srcDepth, srcAddr,
				srcPacking);      
   }
   else {
      return store_ubyte_texture(ctx, dims, baseInternalFormat,
                                 dstFormat, dstRowStride, dstSlices,
                                 srcWidth, srcHeight, srcDepth,
                                 srcFormat, srcType, srcAddr, srcPacking);
   }
   return GL_TRUE;
}


static GLboolean
_mesa_texstore_argb8888(TEXSTORE_PARAMS)
{
   const GLboolean littleEndian = _mesa_little_endian();

   ASSERT(dstFormat == MESA_FORMAT_B8G8R8A8_UNORM ||
          dstFormat == MESA_FORMAT_A8R8G8B8_UNORM ||
          dstFormat == MESA_FORMAT_B8G8R8X8_UNORM ||
          dstFormat == MESA_FORMAT_X8R8G8B8_UNORM );
   ASSERT(_mesa_get_format_bytes(dstFormat) == 4);

   if (!ctx->_ImageTransferState &&
       !srcPacking->SwapBytes &&
       (dstFormat == MESA_FORMAT_B8G8R8A8_UNORM ||
        dstFormat == MESA_FORMAT_B8G8R8X8_UNORM) &&
       srcFormat == GL_RGB &&
       (baseInternalFormat == GL_RGBA ||
        baseInternalFormat == GL_RGB) &&
       srcType == GL_UNSIGNED_BYTE) {
      int img, row, col;
a973 4
         const GLint srcRowStride =
            _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType);
         GLubyte *srcRow = (GLubyte *) _mesa_image_address(dims, srcPacking,
                  srcAddr, srcWidth, srcHeight, srcFormat, srcType, img, 0, 0);
d976 1
a976 66
            GLuint *d4 = (GLuint *) dstRow;
            for (col = 0; col < srcWidth; col++) {
               d4[col] = PACK_COLOR_8888(0xff,
                                         srcRow[col * 3 + RCOMP],
                                         srcRow[col * 3 + GCOMP],
                                         srcRow[col * 3 + BCOMP]);
            }
            dstRow += dstRowStride;
            srcRow += srcRowStride;
         }
      }
   }
   else if (!ctx->_ImageTransferState &&
            !srcPacking->SwapBytes &&
            dstFormat == MESA_FORMAT_B8G8R8A8_UNORM &&
            srcFormat == GL_LUMINANCE_ALPHA &&
            baseInternalFormat == GL_RGBA &&
            srcType == GL_UNSIGNED_BYTE) {
      /* special case of storing LA -> ARGB8888 */
      int img, row, col;
      const GLint srcRowStride =
         _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType);
      for (img = 0; img < srcDepth; img++) {
         const GLubyte *srcRow = (const GLubyte *)
            _mesa_image_address(dims, srcPacking, srcAddr, srcWidth,
                                srcHeight, srcFormat, srcType, img, 0, 0);
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLuint *d4 = (GLuint *) dstRow;
            for (col = 0; col < srcWidth; col++) {
               GLubyte l = srcRow[col * 2 + 0], a = srcRow[col * 2 + 1];
               d4[col] = PACK_COLOR_8888(a, l, l, l);
            }
            dstRow += dstRowStride;
            srcRow += srcRowStride;
         }
      }
   }
   else if (!ctx->_ImageTransferState &&
            !srcPacking->SwapBytes &&
	    dstFormat == MESA_FORMAT_B8G8R8A8_UNORM &&
            srcFormat == GL_RGBA &&
	    baseInternalFormat == GL_RGBA &&
            srcType == GL_UNSIGNED_BYTE) {
      /* same as above case, but src data has alpha too */
      GLint img, row, col;
      /* For some reason, streaming copies to write-combined regions
       * are extremely sensitive to the characteristics of how the
       * source data is retrieved.  By reordering the source reads to
       * be in-order, the speed of this operation increases by half.
       * Strangely the same isn't required for the RGB path, above.
       */
      for (img = 0; img < srcDepth; img++) {
         const GLint srcRowStride =
            _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType);
         GLubyte *srcRow = (GLubyte *) _mesa_image_address(dims, srcPacking,
                  srcAddr, srcWidth, srcHeight, srcFormat, srcType, img, 0, 0);
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLuint *d4 = (GLuint *) dstRow;
            for (col = 0; col < srcWidth; col++) {
               d4[col] = PACK_COLOR_8888(srcRow[col * 4 + ACOMP],
                                         srcRow[col * 4 + RCOMP],
                                         srcRow[col * 4 + GCOMP],
                                         srcRow[col * 4 + BCOMP]);
            }
a977 1
            srcRow += srcRowStride;
a980 47
   else if (!ctx->_ImageTransferState &&
	    (srcType == GL_UNSIGNED_BYTE ||
	     srcType == GL_UNSIGNED_INT_8_8_8_8 ||
	     srcType == GL_UNSIGNED_INT_8_8_8_8_REV) &&
	    can_swizzle(baseInternalFormat) &&	   
	    can_swizzle(srcFormat)) {

      GLubyte dstmap[4];

      /* dstmap - how to swizzle from RGBA to dst format:
       */
      if ((littleEndian && dstFormat == MESA_FORMAT_B8G8R8A8_UNORM) ||
          (littleEndian && dstFormat == MESA_FORMAT_B8G8R8X8_UNORM) ||
	  (!littleEndian && dstFormat == MESA_FORMAT_A8R8G8B8_UNORM) ||
	  (!littleEndian && dstFormat == MESA_FORMAT_X8R8G8B8_UNORM)) {
	 dstmap[3] = 3;		/* alpha */
	 dstmap[2] = 0;		/* red */
	 dstmap[1] = 1;		/* green */
	 dstmap[0] = 2;		/* blue */
      }
      else {
	 assert((littleEndian && dstFormat == MESA_FORMAT_A8R8G8B8_UNORM) ||
		(!littleEndian && dstFormat == MESA_FORMAT_B8G8R8A8_UNORM) ||
		(littleEndian && dstFormat == MESA_FORMAT_X8R8G8B8_UNORM) ||
		(!littleEndian && dstFormat == MESA_FORMAT_B8G8R8X8_UNORM));
	 dstmap[3] = 2;
	 dstmap[2] = 1;
	 dstmap[1] = 0;
	 dstmap[0] = 3;
      }
 
      _mesa_swizzle_ubyte_image(ctx, dims,
				srcFormat,
				srcType,
				baseInternalFormat,
				dstmap, 4,
				dstRowStride,
                                dstSlices,
				srcWidth, srcHeight, srcDepth, srcAddr,
				srcPacking);      
   }
   else {
      return store_ubyte_texture(ctx, dims, baseInternalFormat,
                                 dstFormat, dstRowStride, dstSlices,
                                 srcWidth, srcHeight, srcDepth,
                                 srcFormat, srcType, srcAddr, srcPacking);
   }
d985 3
d989 1
a989 1
_mesa_texstore_rgb888(TEXSTORE_PARAMS)
d991 6
a996 2
   ASSERT(dstFormat == MESA_FORMAT_BGR_UNORM8);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 3);
d998 7
a1004 27
   if (!ctx->_ImageTransferState &&
       !srcPacking->SwapBytes &&
       srcFormat == GL_RGBA &&
       srcType == GL_UNSIGNED_BYTE) {
      /* extract RGB from RGBA */
      GLint img, row, col;
      for (img = 0; img < srcDepth; img++) {
         const GLint srcRowStride =
            _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType);
         GLubyte *srcRow = (GLubyte *) _mesa_image_address(dims, srcPacking,
                  srcAddr, srcWidth, srcHeight, srcFormat, srcType, img, 0, 0);
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            for (col = 0; col < srcWidth; col++) {
               dstRow[col * 3 + 0] = srcRow[col * 4 + BCOMP];
               dstRow[col * 3 + 1] = srcRow[col * 4 + GCOMP];
               dstRow[col * 3 + 2] = srcRow[col * 4 + RCOMP];
            }
            dstRow += dstRowStride;
            srcRow += srcRowStride;
         }
      }
   }
   else if (!ctx->_ImageTransferState &&
	    srcType == GL_UNSIGNED_BYTE &&
	    can_swizzle(baseInternalFormat) &&
	    can_swizzle(srcFormat)) {
d1006 4
a1009 23
      GLubyte dstmap[4];

      /* dstmap - how to swizzle from RGBA to dst format:
       */
      dstmap[0] = 2;
      dstmap[1] = 1;
      dstmap[2] = 0;
      dstmap[3] = ONE;		/* ? */
      
      _mesa_swizzle_ubyte_image(ctx, dims,
				srcFormat,
				srcType,
				baseInternalFormat,
				dstmap, 3,
				dstRowStride, dstSlices,
				srcWidth, srcHeight, srcDepth, srcAddr,
				srcPacking);      
   }
   else {
      return store_ubyte_texture(ctx, dims, baseInternalFormat,
                                 dstFormat, dstRowStride, dstSlices,
                                 srcWidth, srcHeight, srcDepth,
                                 srcFormat, srcType, srcAddr, srcPacking);
a1010 2
   return GL_TRUE;
}
d1012 11
d1024 5
a1028 26
static GLboolean
_mesa_texstore_bgr888(TEXSTORE_PARAMS)
{
   ASSERT(dstFormat == MESA_FORMAT_RGB_UNORM8);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 3);

   if (!ctx->_ImageTransferState &&
       !srcPacking->SwapBytes &&
       srcFormat == GL_RGBA &&
       srcType == GL_UNSIGNED_BYTE) {
      /* extract BGR from RGBA */
      int img, row, col;
      for (img = 0; img < srcDepth; img++) {
         const GLint srcRowStride =
            _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType);
         GLubyte *srcRow = (GLubyte *) _mesa_image_address(dims, srcPacking,
                  srcAddr, srcWidth, srcHeight, srcFormat, srcType, img, 0, 0);
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            for (col = 0; col < srcWidth; col++) {
               dstRow[col * 3 + 0] = srcRow[col * 4 + RCOMP];
               dstRow[col * 3 + 1] = srcRow[col * 4 + GCOMP];
               dstRow[col * 3 + 2] = srcRow[col * 4 + BCOMP];
            }
            dstRow += dstRowStride;
            srcRow += srcRowStride;
a1029 6
      }
   }
   else if (!ctx->_ImageTransferState &&
	    srcType == GL_UNSIGNED_BYTE &&
	    can_swizzle(baseInternalFormat) &&
	    can_swizzle(srcFormat)) {
d1031 7
a1037 1
      GLubyte dstmap[4];
d1039 7
a1045 24
      /* dstmap - how to swizzle from RGBA to dst format:
       */
      dstmap[0] = 0;
      dstmap[1] = 1;
      dstmap[2] = 2;
      dstmap[3] = ONE;		/* ? */
      
      _mesa_swizzle_ubyte_image(ctx, dims,
				srcFormat,
				srcType,
				baseInternalFormat,
				dstmap, 3,
				dstRowStride, dstSlices,
				srcWidth, srcHeight, srcDepth, srcAddr,
				srcPacking);      
   }   
   else {
      return store_ubyte_texture(ctx, dims, baseInternalFormat,
                                 dstFormat, dstRowStride, dstSlices,
                                 srcWidth, srcHeight, srcDepth,
                                 srcFormat, srcType, srcAddr, srcPacking);
   }
   return GL_TRUE;
}
d1047 5
a1051 42

static GLboolean
_mesa_texstore_argb2101010(TEXSTORE_PARAMS)
{
   ASSERT(dstFormat == MESA_FORMAT_B10G10R10A2_UNORM ||
          dstFormat == MESA_FORMAT_B10G10R10X2_UNORM);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 4);

   {
      /* general path */
      /* Hardcode GL_RGBA as the base format, which forces alpha to 1.0
       * if the internal format is RGB. */
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 GL_RGBA,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *src = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         if (baseInternalFormat == GL_RGBA || baseInternalFormat == GL_RGB) {
            for (row = 0; row < srcHeight; row++) {
               GLuint *dstUI = (GLuint *) dstRow;
               for (col = 0; col < srcWidth; col++) {
                  GLushort a,r,g,b;

                  UNCLAMPED_FLOAT_TO_USHORT(a, src[ACOMP]);
                  UNCLAMPED_FLOAT_TO_USHORT(r, src[RCOMP]);
                  UNCLAMPED_FLOAT_TO_USHORT(g, src[GCOMP]);
                  UNCLAMPED_FLOAT_TO_USHORT(b, src[BCOMP]);
                  dstUI[col] = PACK_COLOR_2101010_US(a, r, g, b);
                  src += 4;
               }
               dstRow += dstRowStride;
            }
         } else {
            ASSERT(0);
d1053 2
a1055 1
      free((void *) tempImage);
d1057 3
d1065 1
a1065 1
 * Do texstore for 2-channel, 4-bit/channel, unsigned normalized formats.
d1068 1
a1068 1
_mesa_texstore_unorm44(TEXSTORE_PARAMS)
d1070 14
a1083 1
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
d1085 2
a1086 2
   ASSERT(dstFormat == MESA_FORMAT_L4A4_UNORM);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 1);
d1088 4
a1091 26
   {
      /* general path */
      const GLubyte *tempImage = _mesa_make_temp_ubyte_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking);
      const GLubyte *src = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLubyte *dstUS = (GLubyte *) dstRow;
            for (col = 0; col < srcWidth; col++) {
               /* src[0] is luminance, src[1] is alpha */
               dstUS[col] = PACK_COLOR_44( src[1],
                                           src[0] );
               src += 2;
            }
            dstRow += dstRowStride;
         }
      }
      free((void *) tempImage);
a1092 2
   return GL_TRUE;
}
d1094 17
d1112 7
a1118 8
/**
 * Do texstore for 2-channel, 8-bit/channel, unsigned normalized formats.
 */
static GLboolean
_mesa_texstore_unorm88(TEXSTORE_PARAMS)
{
   const GLboolean littleEndian = _mesa_little_endian();
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
d1120 7
a1126 5
   ASSERT(dstFormat == MESA_FORMAT_L8A8_UNORM ||
          dstFormat == MESA_FORMAT_A8L8_UNORM ||
          dstFormat == MESA_FORMAT_R8G8_UNORM ||
          dstFormat == MESA_FORMAT_G8R8_UNORM);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 2);
d1128 6
a1133 6
   if (!ctx->_ImageTransferState &&
       littleEndian &&
       srcType == GL_UNSIGNED_BYTE &&
       can_swizzle(baseInternalFormat) &&
       can_swizzle(srcFormat)) {
      GLubyte dstmap[4];
a1134 7
      /* dstmap - how to swizzle from RGBA to dst format:
       */
      if (dstFormat == MESA_FORMAT_L8A8_UNORM || dstFormat == MESA_FORMAT_A8L8_UNORM) {
	 if ((littleEndian && dstFormat == MESA_FORMAT_L8A8_UNORM) ||
	     (!littleEndian && dstFormat == MESA_FORMAT_A8L8_UNORM)) {
	    dstmap[0] = 0;
	    dstmap[1] = 3;
d1136 2
a1137 63
	 else {
	    dstmap[0] = 3;
	    dstmap[1] = 0;
	 }
      }
      else {
	 if ((littleEndian && dstFormat == MESA_FORMAT_R8G8_UNORM) ||
	     (!littleEndian && dstFormat == MESA_FORMAT_G8R8_UNORM)) {
	    dstmap[0] = 0;
	    dstmap[1] = 1;
	 }
	 else {
	    dstmap[0] = 1;
	    dstmap[1] = 0;
	 }
      }
      dstmap[2] = ZERO;		/* ? */
      dstmap[3] = ONE;		/* ? */
      
      _mesa_swizzle_ubyte_image(ctx, dims,
				srcFormat,
				srcType,
				baseInternalFormat,
				dstmap, 2,
				dstRowStride, dstSlices,
				srcWidth, srcHeight, srcDepth, srcAddr,
				srcPacking);      
   }   
   else {
      /* general path */
      const GLubyte *tempImage = _mesa_make_temp_ubyte_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking);
      const GLubyte *src = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLushort *dstUS = (GLushort *) dstRow;
            if (dstFormat == MESA_FORMAT_L8A8_UNORM ||
		dstFormat == MESA_FORMAT_R8G8_UNORM) {
               for (col = 0; col < srcWidth; col++) {
                  /* src[0] is luminance (or R), src[1] is alpha (or G) */
                 dstUS[col] = PACK_COLOR_88( src[1],
                                             src[0] );
                 src += 2;
               }
            }
            else {
               for (col = 0; col < srcWidth; col++) {
                  /* src[0] is luminance (or R), src[1] is alpha (or G) */
                 dstUS[col] = PACK_COLOR_88_REV( src[1],
                                                 src[0] );
                 src += 2;
               }
            }
            dstRow += dstRowStride;
         }
a1138 1
      free((void *) tempImage);
d1140 4
d1149 1
a1149 1
 * Do texstore for 2-channel, 16-bit/channel, unsigned normalized formats.
d1152 1
a1152 1
_mesa_texstore_unorm1616(TEXSTORE_PARAMS)
d1154 2
a1155 1
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
d1157 5
a1161 5
   ASSERT(dstFormat == MESA_FORMAT_L16A16_UNORM ||
          dstFormat == MESA_FORMAT_A16L16_UNORM ||
	  dstFormat == MESA_FORMAT_R16G16_UNORM ||
          dstFormat == MESA_FORMAT_G16R16_UNORM);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 4);
d1163 1
a1163 12
   {
      /* general path */
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *src = tempImage;
      GLint img, row, col;
      if (!tempImage)
d1165 1
d1168 5
d1174 1
a1174 5
            GLuint *dstUI = (GLuint *) dstRow;
            if (dstFormat == MESA_FORMAT_L16A16_UNORM ||
		dstFormat == MESA_FORMAT_R16G16_UNORM) {
               for (col = 0; col < srcWidth; col++) {
		  GLushort l, a;
d1176 9
a1184 9
		  UNCLAMPED_FLOAT_TO_USHORT(l, src[0]);
		  UNCLAMPED_FLOAT_TO_USHORT(a, src[1]);
		  dstUI[col] = PACK_COLOR_1616(a, l);
		  src += 2;
               }
            }
            else {
               for (col = 0; col < srcWidth; col++) {
		  GLushort l, a;
d1186 2
a1187 1644
		  UNCLAMPED_FLOAT_TO_USHORT(l, src[0]);
		  UNCLAMPED_FLOAT_TO_USHORT(a, src[1]);
		  dstUI[col] = PACK_COLOR_1616_REV(a, l);
		  src += 2;
               }
            }
            dstRow += dstRowStride;
         }
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}


/* Texstore for R16, A16, L16, I16. */
static GLboolean
_mesa_texstore_unorm16(TEXSTORE_PARAMS)
{
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_R_UNORM16 ||
          dstFormat == MESA_FORMAT_A_UNORM16 ||
          dstFormat == MESA_FORMAT_L_UNORM16 ||
          dstFormat == MESA_FORMAT_I_UNORM16);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 2);

   {
      /* general path */
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *src = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLushort *dstUS = (GLushort *) dstRow;
	    for (col = 0; col < srcWidth; col++) {
	       GLushort r;

	       UNCLAMPED_FLOAT_TO_USHORT(r, src[0]);
	       dstUS[col] = r;
	       src += 1;
	    }
            dstRow += dstRowStride;
         }
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}


static GLboolean
_mesa_texstore_rgba_16(TEXSTORE_PARAMS)
{
   ASSERT(dstFormat == MESA_FORMAT_RGBA_UNORM16 ||
          dstFormat == MESA_FORMAT_RGBX_UNORM16);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 8);

   {
      /* general path */
      /* Hardcode GL_RGBA as the base format, which forces alpha to 1.0
       * if the internal format is RGB. */
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 GL_RGBA,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *src = tempImage;
      GLint img, row, col;

      if (!tempImage)
         return GL_FALSE;

      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLushort *dstUS = (GLushort *) dstRow;
            for (col = 0; col < srcWidth; col++) {
               GLushort r, g, b, a;

               UNCLAMPED_FLOAT_TO_USHORT(r, src[0]);
               UNCLAMPED_FLOAT_TO_USHORT(g, src[1]);
               UNCLAMPED_FLOAT_TO_USHORT(b, src[2]);
               UNCLAMPED_FLOAT_TO_USHORT(a, src[3]);
               dstUS[col*4+0] = r;
               dstUS[col*4+1] = g;
               dstUS[col*4+2] = b;
               dstUS[col*4+3] = a;
               src += 4;
            }
            dstRow += dstRowStride;
         }
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}


static GLboolean
_mesa_texstore_signed_rgba_16(TEXSTORE_PARAMS)
{
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_RGB_SNORM16 ||
          dstFormat == MESA_FORMAT_RGBA_SNORM16 ||
          dstFormat == MESA_FORMAT_RGBX_SNORM16);

   {
      /* general path */
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *src = tempImage;
      const GLuint comps = _mesa_get_format_bytes(dstFormat) / 2;
      GLint img, row, col;

      if (!tempImage)
         return GL_FALSE;

      /* Note: tempImage is always float[4] / RGBA.  We convert to 1, 2,
       * 3 or 4 components/pixel here.
       */
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLshort *dstRowS = (GLshort *) dstRow;
            if (dstFormat == MESA_FORMAT_RGBA_SNORM16) {
               for (col = 0; col < srcWidth; col++) {
                  GLuint c;
                  for (c = 0; c < comps; c++) {
                     GLshort p;
                     UNCLAMPED_FLOAT_TO_SHORT(p, src[col * 4 + c]);
                     dstRowS[col * comps + c] = p;
                  }
               }
               dstRow += dstRowStride;
               src += 4 * srcWidth;
            }
            else if (dstFormat == MESA_FORMAT_RGBX_SNORM16) {
               for (col = 0; col < srcWidth; col++) {
                  GLuint c;

                  for (c = 0; c < 3; c++) {
                     GLshort p;
                     UNCLAMPED_FLOAT_TO_SHORT(p, src[col * 3 + c]);
                     dstRowS[col * comps + c] = p;
                  }
                  dstRowS[col * comps + 3] = 32767;
               }
               dstRow += dstRowStride;
               src += 3 * srcWidth;
            }
            else {
               for (col = 0; col < srcWidth; col++) {
                  GLuint c;
                  for (c = 0; c < comps; c++) {
                     GLshort p;
                     UNCLAMPED_FLOAT_TO_SHORT(p, src[col * 3 + c]);
                     dstRowS[col * comps + c] = p;
                  }
               }
               dstRow += dstRowStride;
               src += 3 * srcWidth;
            }
         }
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}


/**
 * Texstore for _mesa_texformat_a8, _mesa_texformat_l8, _mesa_texformat_i8.
 */
static GLboolean
_mesa_texstore_unorm8(TEXSTORE_PARAMS)
{
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_A_UNORM8 ||
          dstFormat == MESA_FORMAT_L_UNORM8 ||
          dstFormat == MESA_FORMAT_I_UNORM8 ||
          dstFormat == MESA_FORMAT_R_UNORM8);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 1);

   if (!ctx->_ImageTransferState &&
       srcType == GL_UNSIGNED_BYTE &&
       can_swizzle(baseInternalFormat) &&
       can_swizzle(srcFormat)) {
      GLubyte dstmap[4];

      /* dstmap - how to swizzle from RGBA to dst format:
       */
      if (dstFormat == MESA_FORMAT_A_UNORM8) {
	 dstmap[0] = 3;
      }
      else {
	 dstmap[0] = 0;
      }
      dstmap[1] = ZERO;		/* ? */
      dstmap[2] = ZERO;		/* ? */
      dstmap[3] = ONE;		/* ? */
      
      _mesa_swizzle_ubyte_image(ctx, dims,
				srcFormat,
				srcType,
				baseInternalFormat,
				dstmap, 1,
				dstRowStride, dstSlices,
				srcWidth, srcHeight, srcDepth, srcAddr,
				srcPacking);      
   }   
   else {
      /* general path */
      const GLubyte *tempImage = _mesa_make_temp_ubyte_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking);
      const GLubyte *src = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            for (col = 0; col < srcWidth; col++) {
               dstRow[col] = src[col];
            }
            dstRow += dstRowStride;
            src += srcWidth;
         }
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}



/**
 * Texstore for _mesa_texformat_ycbcr or _mesa_texformat_ycbcr_REV.
 */
static GLboolean
_mesa_texstore_ycbcr(TEXSTORE_PARAMS)
{
   const GLboolean littleEndian = _mesa_little_endian();

   (void) ctx; (void) dims; (void) baseInternalFormat;

   ASSERT((dstFormat == MESA_FORMAT_YCBCR) ||
          (dstFormat == MESA_FORMAT_YCBCR_REV));
   ASSERT(_mesa_get_format_bytes(dstFormat) == 2);
   ASSERT(ctx->Extensions.MESA_ycbcr_texture);
   ASSERT(srcFormat == GL_YCBCR_MESA);
   ASSERT((srcType == GL_UNSIGNED_SHORT_8_8_MESA) ||
          (srcType == GL_UNSIGNED_SHORT_8_8_REV_MESA));
   ASSERT(baseInternalFormat == GL_YCBCR_MESA);

   /* always just memcpy since no pixel transfer ops apply */
   memcpy_texture(ctx, dims,
                  dstFormat,
                  dstRowStride, dstSlices,
                  srcWidth, srcHeight, srcDepth, srcFormat, srcType,
                  srcAddr, srcPacking);

   /* Check if we need byte swapping */
   /* XXX the logic here _might_ be wrong */
   if (srcPacking->SwapBytes ^
       (srcType == GL_UNSIGNED_SHORT_8_8_REV_MESA) ^
       (dstFormat == MESA_FORMAT_YCBCR_REV) ^
       !littleEndian) {
      GLint img, row;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            _mesa_swap2((GLushort *) dstRow, srcWidth);
            dstRow += dstRowStride;
         }
      }
   }
   return GL_TRUE;
}

static GLboolean
_mesa_texstore_dudv8(TEXSTORE_PARAMS)
{
   const GLboolean littleEndian = _mesa_little_endian();
   const GLuint texelBytes = _mesa_get_format_bytes(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_DUDV8);
   ASSERT(texelBytes == 2);
   ASSERT(ctx->Extensions.ATI_envmap_bumpmap);
   ASSERT((srcFormat == GL_DU8DV8_ATI) ||
	  (srcFormat == GL_DUDV_ATI));
   ASSERT(baseInternalFormat == GL_DUDV_ATI);

   if (srcType == GL_BYTE) {
      GLubyte dstmap[4];

      /* dstmap - how to swizzle from RGBA to dst format:
       */
      if (littleEndian) {
	 dstmap[0] = 0;
	 dstmap[1] = 3;
      }
      else {
	 dstmap[0] = 3;
	 dstmap[1] = 0;
      }
      dstmap[2] = ZERO;		/* ? */
      dstmap[3] = ONE;		/* ? */
      
      _mesa_swizzle_ubyte_image(ctx, dims,
				GL_LUMINANCE_ALPHA, /* hack */
				GL_UNSIGNED_BYTE, /* hack */
				GL_LUMINANCE_ALPHA, /* hack */
				dstmap, 2,
				dstRowStride, dstSlices,
				srcWidth, srcHeight, srcDepth, srcAddr,
				srcPacking);      
   }   
   else {
      /* general path - note this is defined for 2d textures only */
      const GLint components = _mesa_components_in_format(baseInternalFormat);
      const GLint srcStride = _mesa_image_row_stride(srcPacking, srcWidth,
                                                     srcFormat, srcType);
      GLbyte *tempImage, *dst, *src;
      GLint row;

      tempImage = malloc(srcWidth * srcHeight * srcDepth
                                          * components * sizeof(GLbyte));
      if (!tempImage)
         return GL_FALSE;

      src = (GLbyte *) _mesa_image_address(dims, srcPacking, srcAddr,
                                           srcWidth, srcHeight,
                                           srcFormat, srcType,
                                           0, 0, 0);

      dst = tempImage;
      for (row = 0; row < srcHeight; row++) {
         _mesa_unpack_dudv_span_byte(ctx, srcWidth, baseInternalFormat,
                                     dst, srcFormat, srcType, src,
                                     srcPacking, 0);
         dst += srcWidth * components;
         src += srcStride;
      }
 
      src = tempImage;
      dst = (GLbyte *) dstSlices[0];
      for (row = 0; row < srcHeight; row++) {
         memcpy(dst, src, srcWidth * texelBytes);
         dst += dstRowStride;
         src += srcWidth * texelBytes;
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}


/**
 * Store a texture in a signed normalized 8-bit format.
 */
static GLboolean
_mesa_texstore_snorm8(TEXSTORE_PARAMS)
{
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_A_SNORM8 ||
          dstFormat == MESA_FORMAT_L_SNORM8 ||
          dstFormat == MESA_FORMAT_I_SNORM8 ||
          dstFormat == MESA_FORMAT_R_SNORM8);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 1);

   {
      /* general path */
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *src = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLbyte *dstRow = (GLbyte *) dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            for (col = 0; col < srcWidth; col++) {
               dstRow[col] = FLOAT_TO_BYTE_TEX(src[col]);
            }
            dstRow += dstRowStride;
            src += srcWidth;
         }
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}


/**
 * Store a texture in a signed normalized two-channel 16-bit format.
 */
static GLboolean
_mesa_texstore_snorm88(TEXSTORE_PARAMS)
{
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_L8A8_SNORM ||
          dstFormat == MESA_FORMAT_G8R8_SNORM ||
          dstFormat == MESA_FORMAT_R8G8_SNORM);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 2);

   {
      /* general path */
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *src = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLbyte *dstRow = (GLbyte *) dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLushort *dst = (GLushort *) dstRow;

            if (dstFormat == MESA_FORMAT_L8A8_SNORM ||
                dstFormat == MESA_FORMAT_R8G8_SNORM) {
               for (col = 0; col < srcWidth; col++) {
                  GLubyte l = FLOAT_TO_BYTE_TEX(src[0]);
                  GLubyte a = FLOAT_TO_BYTE_TEX(src[1]);

                  dst[col] = PACK_COLOR_88_REV(l, a);
                  src += 2;
               }
            } else {
               for (col = 0; col < srcWidth; col++) {
                  GLubyte l = FLOAT_TO_BYTE_TEX(src[0]);
                  GLubyte a = FLOAT_TO_BYTE_TEX(src[1]);

                  dst[col] = PACK_COLOR_88(l, a);
                  src += 2;
               }
            }

            dstRow += dstRowStride;
         }
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}

/* Texstore for signed R16, A16, L16, I16. */
static GLboolean
_mesa_texstore_snorm16(TEXSTORE_PARAMS)
{
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_R_SNORM16 ||
          dstFormat == MESA_FORMAT_A_SNORM16 ||
          dstFormat == MESA_FORMAT_L_SNORM16 ||
          dstFormat == MESA_FORMAT_I_SNORM16);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 2);

   {
      /* general path */
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *src = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLshort *dstUS = (GLshort *) dstRow;
	    for (col = 0; col < srcWidth; col++) {
	       GLushort r;

	       UNCLAMPED_FLOAT_TO_SHORT(r, src[0]);
	       dstUS[col] = r;
	       src += 1;
	    }
            dstRow += dstRowStride;
         }
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}

/**
 * Do texstore for 2-channel, 16-bit/channel, signed normalized formats.
 */
static GLboolean
_mesa_texstore_snorm1616(TEXSTORE_PARAMS)
{
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_LA_SNORM16 ||
          dstFormat == MESA_FORMAT_G16R16_SNORM ||
          dstFormat == MESA_FORMAT_R16G16_SNORM);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 4);

   {
      /* general path */
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *src = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLuint *dst = (GLuint *) dstRow;

            if (dstFormat == MESA_FORMAT_LA_SNORM16 ||
                dstFormat == MESA_FORMAT_R16G16_SNORM) {
               for (col = 0; col < srcWidth; col++) {
                  GLushort l, a;

                  UNCLAMPED_FLOAT_TO_SHORT(l, src[0]);
                  UNCLAMPED_FLOAT_TO_SHORT(a, src[1]);
                  dst[col] = PACK_COLOR_1616_REV(l, a);
                  src += 2;
               }
            } else {
               for (col = 0; col < srcWidth; col++) {
                  GLushort l, a;

                  UNCLAMPED_FLOAT_TO_SHORT(l, src[0]);
                  UNCLAMPED_FLOAT_TO_SHORT(a, src[1]);
                  dst[col] = PACK_COLOR_1616_REV(l, a);
                  src += 2;
               }
            }

            dstRow += dstRowStride;
         }
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}

/**
 * Store a texture in MESA_FORMAT_X8B8G8R8_SNORM or
 * MESA_FORMAT_R8G8B8X8_SNORM.
 */
static GLboolean
_mesa_texstore_signed_rgbx8888(TEXSTORE_PARAMS)
{
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_X8B8G8R8_SNORM ||
          dstFormat == MESA_FORMAT_R8G8B8X8_SNORM);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 4);

   {
      /* general path */
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *srcRow = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLbyte *dstRow = (GLbyte *) dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLbyte *dst = dstRow;
            if (dstFormat == MESA_FORMAT_X8B8G8R8_SNORM) {
               for (col = 0; col < srcWidth; col++) {
                  dst[3] = FLOAT_TO_BYTE_TEX(srcRow[RCOMP]);
                  dst[2] = FLOAT_TO_BYTE_TEX(srcRow[GCOMP]);
                  dst[1] = FLOAT_TO_BYTE_TEX(srcRow[BCOMP]);
                  dst[0] = 127;
                  srcRow += 3;
                  dst += 4;
               }
            }
            else {
               for (col = 0; col < srcWidth; col++) {
                  dst[0] = FLOAT_TO_BYTE_TEX(srcRow[RCOMP]);
                  dst[1] = FLOAT_TO_BYTE_TEX(srcRow[GCOMP]);
                  dst[2] = FLOAT_TO_BYTE_TEX(srcRow[BCOMP]);
                  dst[3] = 127;
                  srcRow += 3;
                  dst += 4;
               }
            }
            dstRow += dstRowStride;
         }
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}



/**
 * Store a texture in MESA_FORMAT_A8B8G8R8_SNORM or
 * MESA_FORMAT_R8G8B8A8_SNORM
 */
static GLboolean
_mesa_texstore_signed_rgba8888(TEXSTORE_PARAMS)
{
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_A8B8G8R8_SNORM ||
          dstFormat == MESA_FORMAT_R8G8B8A8_SNORM);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 4);

   {
      /* general path */
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *srcRow = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLbyte *dstRow = (GLbyte *) dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLbyte *dst = dstRow;
            if (dstFormat == MESA_FORMAT_A8B8G8R8_SNORM) {
               for (col = 0; col < srcWidth; col++) {
                  dst[3] = FLOAT_TO_BYTE_TEX(srcRow[RCOMP]);
                  dst[2] = FLOAT_TO_BYTE_TEX(srcRow[GCOMP]);
                  dst[1] = FLOAT_TO_BYTE_TEX(srcRow[BCOMP]);
                  dst[0] = FLOAT_TO_BYTE_TEX(srcRow[ACOMP]);
                  srcRow += 4;
                  dst += 4;
               }
            }
            else {
               for (col = 0; col < srcWidth; col++) {
                  dst[0] = FLOAT_TO_BYTE_TEX(srcRow[RCOMP]);
                  dst[1] = FLOAT_TO_BYTE_TEX(srcRow[GCOMP]);
                  dst[2] = FLOAT_TO_BYTE_TEX(srcRow[BCOMP]);
                  dst[3] = FLOAT_TO_BYTE_TEX(srcRow[ACOMP]);
                  srcRow += 4;
                  dst += 4;
               }
            }
            dstRow += dstRowStride;
         }
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
}


/**
 * Store a combined depth/stencil texture image.
 */
static GLboolean
_mesa_texstore_z24_s8(TEXSTORE_PARAMS)
{
   const GLuint depthScale = 0xffffff;
   const GLint srcRowStride
      = _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType);
   GLint img, row;
   GLuint *depth = malloc(srcWidth * sizeof(GLuint));
   GLubyte *stencil = malloc(srcWidth * sizeof(GLubyte));

   ASSERT(dstFormat == MESA_FORMAT_S8_UINT_Z24_UNORM);
   ASSERT(srcFormat == GL_DEPTH_STENCIL_EXT ||
          srcFormat == GL_DEPTH_COMPONENT ||
          srcFormat == GL_STENCIL_INDEX);
   ASSERT(srcFormat != GL_DEPTH_STENCIL_EXT ||
          srcType == GL_UNSIGNED_INT_24_8_EXT ||
          srcType == GL_FLOAT_32_UNSIGNED_INT_24_8_REV);

   if (!depth || !stencil) {
      free(depth);
      free(stencil);
      return GL_FALSE;
   }

   /* In case we only upload depth we need to preserve the stencil */
   for (img = 0; img < srcDepth; img++) {
      GLuint *dstRow = (GLuint *) dstSlices[img];
      const GLubyte *src
         = (const GLubyte *) _mesa_image_address(dims, srcPacking, srcAddr,
               srcWidth, srcHeight,
               srcFormat, srcType,
               img, 0, 0);
      for (row = 0; row < srcHeight; row++) {
         GLint i;
         GLboolean keepdepth = GL_FALSE, keepstencil = GL_FALSE;

         if (srcFormat == GL_DEPTH_COMPONENT) { /* preserve stencil */
            keepstencil = GL_TRUE;
         }
         else if (srcFormat == GL_STENCIL_INDEX) { /* preserve depth */
            keepdepth = GL_TRUE;
         }

         if (keepdepth == GL_FALSE)
            /* the 24 depth bits will be in the low position: */
            _mesa_unpack_depth_span(ctx, srcWidth,
                                    GL_UNSIGNED_INT, /* dst type */
                                    keepstencil ? depth : dstRow, /* dst addr */
                                    depthScale,
                                    srcType, src, srcPacking);

         if (keepstencil == GL_FALSE)
            /* get the 8-bit stencil values */
            _mesa_unpack_stencil_span(ctx, srcWidth,
                                      GL_UNSIGNED_BYTE, /* dst type */
                                      stencil, /* dst addr */
                                      srcType, src, srcPacking,
                                      ctx->_ImageTransferState);

         for (i = 0; i < srcWidth; i++) {
            if (keepstencil)
               dstRow[i] = depth[i] << 8 | (dstRow[i] & 0x000000FF);
            else
               dstRow[i] = (dstRow[i] & 0xFFFFFF00) | (stencil[i] & 0xFF);
         }
         src += srcRowStride;
         dstRow += dstRowStride / sizeof(GLuint);
      }
   }

   free(depth);
   free(stencil);
   return GL_TRUE;
}


/**
 * Store a combined depth/stencil texture image.
 */
static GLboolean
_mesa_texstore_s8_z24(TEXSTORE_PARAMS)
{
   const GLuint depthScale = 0xffffff;
   const GLint srcRowStride
      = _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType);
   GLint img, row;
   GLuint *depth;
   GLubyte *stencil;

   ASSERT(dstFormat == MESA_FORMAT_Z24_UNORM_S8_UINT);
   ASSERT(srcFormat == GL_DEPTH_STENCIL_EXT ||
          srcFormat == GL_DEPTH_COMPONENT ||
          srcFormat == GL_STENCIL_INDEX);
   ASSERT(srcFormat != GL_DEPTH_STENCIL_EXT ||
          srcType == GL_UNSIGNED_INT_24_8_EXT ||
          srcType == GL_FLOAT_32_UNSIGNED_INT_24_8_REV);

   depth = malloc(srcWidth * sizeof(GLuint));
   stencil = malloc(srcWidth * sizeof(GLubyte));

   if (!depth || !stencil) {
      free(depth);
      free(stencil);
      return GL_FALSE;
   }

   for (img = 0; img < srcDepth; img++) {
      GLuint *dstRow = (GLuint *) dstSlices[img];
      const GLubyte *src
	 = (const GLubyte *) _mesa_image_address(dims, srcPacking, srcAddr,
						srcWidth, srcHeight,
						srcFormat, srcType,
						img, 0, 0);
      for (row = 0; row < srcHeight; row++) {
	 GLint i;
	 GLboolean keepdepth = GL_FALSE, keepstencil = GL_FALSE;
	 
	 if (srcFormat == GL_DEPTH_COMPONENT) { /* preserve stencil */
	    keepstencil = GL_TRUE;
	 }
         else if (srcFormat == GL_STENCIL_INDEX) { /* preserve depth */
	    keepdepth = GL_TRUE;
	 }

	 if (keepdepth == GL_FALSE)
	    /* the 24 depth bits will be in the low position: */
	    _mesa_unpack_depth_span(ctx, srcWidth,
				    GL_UNSIGNED_INT, /* dst type */
				    keepstencil ? depth : dstRow, /* dst addr */
				    depthScale,
				    srcType, src, srcPacking);	 

	 if (keepstencil == GL_FALSE)
	    /* get the 8-bit stencil values */
	    _mesa_unpack_stencil_span(ctx, srcWidth,
				      GL_UNSIGNED_BYTE, /* dst type */
				      stencil, /* dst addr */
				      srcType, src, srcPacking,
				      ctx->_ImageTransferState);

	 /* merge stencil values into depth values */
	 for (i = 0; i < srcWidth; i++) {
	    if (keepstencil)
	       dstRow[i] = depth[i] | (dstRow[i] & 0xFF000000);
	    else
	       dstRow[i] = (dstRow[i] & 0xFFFFFF) | (stencil[i] << 24);

	 }
	 src += srcRowStride;
	 dstRow += dstRowStride / sizeof(GLuint);
      }
   }

   free(depth);
   free(stencil);

   return GL_TRUE;
}


/**
 * Store simple 8-bit/value stencil texture data.
 */
static GLboolean
_mesa_texstore_s8(TEXSTORE_PARAMS)
{
   ASSERT(dstFormat == MESA_FORMAT_S_UINT8);
   ASSERT(srcFormat == GL_STENCIL_INDEX);

   {
      const GLint srcRowStride
	 = _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType);
      GLint img, row;
      GLubyte *stencil = malloc(srcWidth * sizeof(GLubyte));

      if (!stencil)
         return GL_FALSE;

      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         const GLubyte *src
            = (const GLubyte *) _mesa_image_address(dims, srcPacking, srcAddr,
                                                   srcWidth, srcHeight,
                                                   srcFormat, srcType,
                                                   img, 0, 0);
         for (row = 0; row < srcHeight; row++) {
            GLint i;

            /* get the 8-bit stencil values */
            _mesa_unpack_stencil_span(ctx, srcWidth,
                                      GL_UNSIGNED_BYTE, /* dst type */
                                      stencil, /* dst addr */
                                      srcType, src, srcPacking,
                                      ctx->_ImageTransferState);
            /* merge stencil values into depth values */
            for (i = 0; i < srcWidth; i++)
               dstRow[i] = stencil[i];

            src += srcRowStride;
            dstRow += dstRowStride / sizeof(GLubyte);
         }
      }

      free(stencil);
   }

   return GL_TRUE;
}


/**
 * Store an image in any of the formats:
 *   _mesa_texformat_rgba_float32
 *   _mesa_texformat_rgb_float32
 *   _mesa_texformat_alpha_float32
 *   _mesa_texformat_luminance_float32
 *   _mesa_texformat_luminance_alpha_float32
 *   _mesa_texformat_intensity_float32
 */
static GLboolean
_mesa_texstore_rgba_float32(TEXSTORE_PARAMS)
{
   GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
   GLint components = _mesa_components_in_format(baseFormat);

   /* this forces alpha to 1 in _mesa_make_temp_float_image */
   if (dstFormat == MESA_FORMAT_RGBX_FLOAT32) {
      baseFormat = GL_RGBA;
      components = 4;
   }

   ASSERT(dstFormat == MESA_FORMAT_RGBA_FLOAT32 ||
          dstFormat == MESA_FORMAT_RGB_FLOAT32 ||
          dstFormat == MESA_FORMAT_A_FLOAT32 ||
          dstFormat == MESA_FORMAT_L_FLOAT32 ||
          dstFormat == MESA_FORMAT_LA_FLOAT32 ||
          dstFormat == MESA_FORMAT_I_FLOAT32 ||
          dstFormat == MESA_FORMAT_R_FLOAT32 ||
          dstFormat == MESA_FORMAT_RG_FLOAT32 ||
          dstFormat == MESA_FORMAT_RGBX_FLOAT32);
   ASSERT(baseInternalFormat == GL_RGBA ||
          baseInternalFormat == GL_RGB ||
          baseInternalFormat == GL_ALPHA ||
          baseInternalFormat == GL_LUMINANCE ||
          baseInternalFormat == GL_LUMINANCE_ALPHA ||
          baseInternalFormat == GL_INTENSITY ||
          baseInternalFormat == GL_RED ||
          baseInternalFormat == GL_RG);
   ASSERT(_mesa_get_format_bytes(dstFormat) == components * sizeof(GLfloat));

   {
      /* general path */
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *srcRow = tempImage;
      GLint bytesPerRow;
      GLint img, row;
      if (!tempImage)
         return GL_FALSE;
      bytesPerRow = srcWidth * components * sizeof(GLfloat);
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            memcpy(dstRow, srcRow, bytesPerRow);
            dstRow += dstRowStride;
            srcRow += srcWidth * components;
         }
      }

      free((void *) tempImage);
   }
   return GL_TRUE;
}



/**
 * As above, but store 16-bit floats.
 */
static GLboolean
_mesa_texstore_rgba_float16(TEXSTORE_PARAMS)
{
   GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
   GLint components = _mesa_components_in_format(baseFormat);

   /* this forces alpha to 1 in _mesa_make_temp_float_image */
   if (dstFormat == MESA_FORMAT_RGBX_FLOAT16) {
      baseFormat = GL_RGBA;
      components = 4;
   }

   ASSERT(dstFormat == MESA_FORMAT_RGBA_FLOAT16 ||
          dstFormat == MESA_FORMAT_RGB_FLOAT16 ||
          dstFormat == MESA_FORMAT_A_FLOAT16 ||
          dstFormat == MESA_FORMAT_L_FLOAT16 ||
          dstFormat == MESA_FORMAT_LA_FLOAT16 ||
          dstFormat == MESA_FORMAT_I_FLOAT16 ||
          dstFormat == MESA_FORMAT_R_FLOAT16 ||
          dstFormat == MESA_FORMAT_RG_FLOAT16 ||
          dstFormat == MESA_FORMAT_RGBX_FLOAT16);
   ASSERT(baseInternalFormat == GL_RGBA ||
          baseInternalFormat == GL_RGB ||
          baseInternalFormat == GL_ALPHA ||
          baseInternalFormat == GL_LUMINANCE ||
          baseInternalFormat == GL_LUMINANCE_ALPHA ||
          baseInternalFormat == GL_INTENSITY ||
          baseInternalFormat == GL_RED ||
          baseInternalFormat == GL_RG);
   ASSERT(_mesa_get_format_bytes(dstFormat) == components * sizeof(GLhalfARB));

   {
      /* general path */
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *src = tempImage;
      GLint img, row;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLhalfARB *dstTexel = (GLhalfARB *) dstRow;
            GLint i;
            for (i = 0; i < srcWidth * components; i++) {
               dstTexel[i] = _mesa_float_to_half(src[i]);
            }
            dstRow += dstRowStride;
            src += srcWidth * components;
         }
      }

      free((void *) tempImage);
   }
   return GL_TRUE;
}


/* non-normalized, signed int8 */
static GLboolean
_mesa_texstore_rgba_int8(TEXSTORE_PARAMS)
{
   GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
   GLint components = _mesa_components_in_format(baseFormat);

   /* this forces alpha to 1 in make_temp_uint_image */
   if (dstFormat == MESA_FORMAT_RGBX_SINT8) {
      baseFormat = GL_RGBA;
      components = 4;
   }

   ASSERT(dstFormat == MESA_FORMAT_R_SINT8 ||
          dstFormat == MESA_FORMAT_RG_SINT8 ||
          dstFormat == MESA_FORMAT_RGB_SINT8 ||
          dstFormat == MESA_FORMAT_RGBA_SINT8 ||
          dstFormat == MESA_FORMAT_A_SINT8 ||
          dstFormat == MESA_FORMAT_I_SINT8 ||
          dstFormat == MESA_FORMAT_L_SINT8 ||
          dstFormat == MESA_FORMAT_LA_SINT8 ||
          dstFormat == MESA_FORMAT_RGBX_SINT8);
   ASSERT(baseInternalFormat == GL_RGBA ||
          baseInternalFormat == GL_RGB ||
          baseInternalFormat == GL_RG ||
          baseInternalFormat == GL_RED ||
          baseInternalFormat == GL_ALPHA ||
          baseInternalFormat == GL_LUMINANCE ||
          baseInternalFormat == GL_LUMINANCE_ALPHA ||
          baseInternalFormat == GL_INTENSITY);
   ASSERT(_mesa_get_format_bytes(dstFormat) == components * sizeof(GLbyte));

   {
      /* general path */
      const GLuint *tempImage = make_temp_uint_image(ctx, dims,
						     baseInternalFormat,
						     baseFormat,
						     srcWidth, srcHeight, srcDepth,
						     srcFormat, srcType,
						     srcAddr,
						     srcPacking);
      const GLuint *src = tempImage;
      GLint img, row;
      GLboolean is_unsigned = _mesa_is_type_unsigned(srcType);
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLbyte *dstTexel = (GLbyte *) dstRow;
            GLint i;
            if (is_unsigned) {
               for (i = 0; i < srcWidth * components; i++) {
                  dstTexel[i] = (GLbyte) MIN2(src[i], 0x7f);
               }
            } else {
               for (i = 0; i < srcWidth * components; i++) {
                  dstTexel[i] = (GLbyte) CLAMP((GLint) src[i], -0x80, 0x7f);
               }
            }
            dstRow += dstRowStride;
            src += srcWidth * components;
         }
      }

      free((void *) tempImage);
   }
   return GL_TRUE;
}


/* non-normalized, signed int16 */
static GLboolean
_mesa_texstore_rgba_int16(TEXSTORE_PARAMS)
{
   GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
   GLint components = _mesa_components_in_format(baseFormat);

   /* this forces alpha to 1 in make_temp_uint_image */
   if (dstFormat == MESA_FORMAT_RGBX_SINT16) {
      baseFormat = GL_RGBA;
      components = 4;
   }

   ASSERT(dstFormat == MESA_FORMAT_R_SINT16 ||
          dstFormat == MESA_FORMAT_RG_SINT16 ||
          dstFormat == MESA_FORMAT_RGB_SINT16 ||
          dstFormat == MESA_FORMAT_RGBA_SINT16 ||
          dstFormat == MESA_FORMAT_A_SINT16 ||
          dstFormat == MESA_FORMAT_L_SINT16 ||
          dstFormat == MESA_FORMAT_I_SINT16 ||
          dstFormat == MESA_FORMAT_LA_SINT16 ||
          dstFormat == MESA_FORMAT_RGBX_SINT16);
   ASSERT(baseInternalFormat == GL_RGBA ||
          baseInternalFormat == GL_RGB ||
          baseInternalFormat == GL_RG ||
          baseInternalFormat == GL_RED ||
          baseInternalFormat == GL_ALPHA ||
          baseInternalFormat == GL_LUMINANCE ||
          baseInternalFormat == GL_LUMINANCE_ALPHA ||
          baseInternalFormat == GL_INTENSITY);
   ASSERT(_mesa_get_format_bytes(dstFormat) == components * sizeof(GLshort));

   {
      /* general path */
      const GLuint *tempImage = make_temp_uint_image(ctx, dims,
						     baseInternalFormat,
						     baseFormat,
						     srcWidth, srcHeight, srcDepth,
						     srcFormat, srcType,
						     srcAddr,
						     srcPacking);
      const GLuint *src = tempImage;
      GLint img, row;
      GLboolean is_unsigned = _mesa_is_type_unsigned(srcType);
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLshort *dstTexel = (GLshort *) dstRow;
            GLint i;
            if (is_unsigned) {
               for (i = 0; i < srcWidth * components; i++) {
                  dstTexel[i] = (GLshort) MIN2(src[i], 0x7fff);
               }
            } else {
               for (i = 0; i < srcWidth * components; i++) {
                  dstTexel[i] = (GLshort)CLAMP((GLint) src[i], -0x8000, 0x7fff);
               }
            }
            dstRow += dstRowStride;
            src += srcWidth * components;
         }
      }

      free((void *) tempImage);
   }
   return GL_TRUE;
}


/* non-normalized, signed int32 */
static GLboolean
_mesa_texstore_rgba_int32(TEXSTORE_PARAMS)
{
   GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
   GLint components = _mesa_components_in_format(baseFormat);

   /* this forces alpha to 1 in make_temp_uint_image */
   if (dstFormat == MESA_FORMAT_RGBX_SINT32) {
      baseFormat = GL_RGBA;
      components = 4;
   }

   ASSERT(dstFormat == MESA_FORMAT_R_SINT32 ||
          dstFormat == MESA_FORMAT_RG_SINT32 ||
          dstFormat == MESA_FORMAT_RGB_SINT32 ||
          dstFormat == MESA_FORMAT_RGBA_SINT32 ||
          dstFormat == MESA_FORMAT_A_SINT32 ||
          dstFormat == MESA_FORMAT_I_SINT32 ||
          dstFormat == MESA_FORMAT_L_SINT32 ||
          dstFormat == MESA_FORMAT_LA_SINT32 ||
          dstFormat == MESA_FORMAT_RGBX_SINT32);
   ASSERT(baseInternalFormat == GL_RGBA ||
          baseInternalFormat == GL_RGB ||
          baseInternalFormat == GL_RG ||
          baseInternalFormat == GL_RED ||
          baseInternalFormat == GL_ALPHA ||
          baseInternalFormat == GL_LUMINANCE ||
          baseInternalFormat == GL_LUMINANCE_ALPHA ||
          baseInternalFormat == GL_INTENSITY);
   ASSERT(_mesa_get_format_bytes(dstFormat) == components * sizeof(GLint));

   {
      /* general path */
      const GLuint *tempImage = make_temp_uint_image(ctx, dims,
						     baseInternalFormat,
						     baseFormat,
						     srcWidth, srcHeight, srcDepth,
						     srcFormat, srcType,
						     srcAddr,
						     srcPacking);
      const GLuint *src = tempImage;
      GLint img, row;
      GLboolean is_unsigned = _mesa_is_type_unsigned(srcType);
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLint *dstTexel = (GLint *) dstRow;
            GLint i;
            if (is_unsigned) {
               for (i = 0; i < srcWidth * components; i++) {
                  dstTexel[i] = (GLint) MIN2(src[i], 0x7fffffff);
               }
            } else {
               for (i = 0; i < srcWidth * components; i++) {
                  dstTexel[i] = (GLint) src[i];
               }
            }
            dstRow += dstRowStride;
            src += srcWidth * components;
         }
      }

      free((void *) tempImage);
   }
   return GL_TRUE;
}


/* non-normalized, unsigned int8 */
static GLboolean
_mesa_texstore_rgba_uint8(TEXSTORE_PARAMS)
{
   GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
   GLint components = _mesa_components_in_format(baseFormat);

   /* this forces alpha to 1 in make_temp_uint_image */
   if (dstFormat == MESA_FORMAT_RGBX_UINT8) {
      baseFormat = GL_RGBA;
      components = 4;
   }

   ASSERT(dstFormat == MESA_FORMAT_R_UINT8 ||
          dstFormat == MESA_FORMAT_RG_UINT8 ||
          dstFormat == MESA_FORMAT_RGB_UINT8 ||
          dstFormat == MESA_FORMAT_RGBA_UINT8 ||
          dstFormat == MESA_FORMAT_A_UINT8 ||
          dstFormat == MESA_FORMAT_I_UINT8 ||
          dstFormat == MESA_FORMAT_L_UINT8 ||
          dstFormat == MESA_FORMAT_LA_UINT8 ||
          dstFormat == MESA_FORMAT_RGBX_UINT8);
   ASSERT(baseInternalFormat == GL_RGBA ||
          baseInternalFormat == GL_RGB ||
          baseInternalFormat == GL_RG ||
          baseInternalFormat == GL_RED ||
          baseInternalFormat == GL_ALPHA ||
          baseInternalFormat == GL_LUMINANCE ||
          baseInternalFormat == GL_LUMINANCE_ALPHA ||
          baseInternalFormat == GL_INTENSITY);
   ASSERT(_mesa_get_format_bytes(dstFormat) == components * sizeof(GLubyte));

   {
      /* general path */
      const GLuint *tempImage =
         make_temp_uint_image(ctx, dims, baseInternalFormat, baseFormat,
                              srcWidth, srcHeight, srcDepth,
                              srcFormat, srcType, srcAddr, srcPacking);
      const GLuint *src = tempImage;
      GLint img, row;
      GLboolean is_unsigned = _mesa_is_type_unsigned(srcType);
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLubyte *dstTexel = (GLubyte *) dstRow;
            GLint i;
            if (is_unsigned) {
               for (i = 0; i < srcWidth * components; i++) {
                  dstTexel[i] = (GLubyte) MIN2(src[i], 0xff);
               }
            } else {
               for (i = 0; i < srcWidth * components; i++) {
                  dstTexel[i] = (GLubyte) CLAMP((GLint) src[i], 0, 0xff);
               }
            }
            dstRow += dstRowStride;
            src += srcWidth * components;
         }
      }

      free((void *) tempImage);
   }
   return GL_TRUE;
}


/* non-normalized, unsigned int16 */
static GLboolean
_mesa_texstore_rgba_uint16(TEXSTORE_PARAMS)
{
   GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
   GLint components = _mesa_components_in_format(baseFormat);

   /* this forces alpha to 1 in make_temp_uint_image */
   if (dstFormat == MESA_FORMAT_RGBX_UINT16) {
      baseFormat = GL_RGBA;
      components = 4;
   }

   ASSERT(dstFormat == MESA_FORMAT_R_UINT16 ||
          dstFormat == MESA_FORMAT_RG_UINT16 ||
          dstFormat == MESA_FORMAT_RGB_UINT16 ||
          dstFormat == MESA_FORMAT_RGBA_UINT16 ||
          dstFormat == MESA_FORMAT_A_UINT16 ||
          dstFormat == MESA_FORMAT_I_UINT16 ||
          dstFormat == MESA_FORMAT_L_UINT16 ||
          dstFormat == MESA_FORMAT_LA_UINT16 ||
          dstFormat == MESA_FORMAT_RGBX_UINT16);
   ASSERT(baseInternalFormat == GL_RGBA ||
          baseInternalFormat == GL_RGB ||
          baseInternalFormat == GL_RG ||
          baseInternalFormat == GL_RED ||
          baseInternalFormat == GL_ALPHA ||
          baseInternalFormat == GL_LUMINANCE ||
          baseInternalFormat == GL_LUMINANCE_ALPHA ||
          baseInternalFormat == GL_INTENSITY);
   ASSERT(_mesa_get_format_bytes(dstFormat) == components * sizeof(GLushort));

   {
      /* general path */
      const GLuint *tempImage =
         make_temp_uint_image(ctx, dims, baseInternalFormat, baseFormat,
                              srcWidth, srcHeight, srcDepth,
                              srcFormat, srcType, srcAddr, srcPacking);
      const GLuint *src = tempImage;
      GLint img, row;
      GLboolean is_unsigned = _mesa_is_type_unsigned(srcType);
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLushort *dstTexel = (GLushort *) dstRow;
            GLint i;
            if (is_unsigned) {
               for (i = 0; i < srcWidth * components; i++) {
                  dstTexel[i] = (GLushort) MIN2(src[i], 0xffff);
              }
            } else {
               for (i = 0; i < srcWidth * components; i++) {
                  dstTexel[i] = (GLushort) CLAMP((GLint) src[i], 0, 0xffff);
               }
            }
            dstRow += dstRowStride;
            src += srcWidth * components;
         }
      }

      free((void *) tempImage);
   }
   return GL_TRUE;
}


/* non-normalized, unsigned int32 */
static GLboolean
_mesa_texstore_rgba_uint32(TEXSTORE_PARAMS)
{
   GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
   GLint components = _mesa_components_in_format(baseFormat);

   /* this forces alpha to 1 in make_temp_uint_image */
   if (dstFormat == MESA_FORMAT_RGBX_UINT32) {
      baseFormat = GL_RGBA;
      components = 4;
   }

   ASSERT(dstFormat == MESA_FORMAT_R_UINT32 ||
          dstFormat == MESA_FORMAT_RG_UINT32 ||
          dstFormat == MESA_FORMAT_RGB_UINT32 ||
          dstFormat == MESA_FORMAT_RGBA_UINT32 ||
          dstFormat == MESA_FORMAT_A_UINT32 ||
          dstFormat == MESA_FORMAT_I_UINT32 ||
          dstFormat == MESA_FORMAT_L_UINT32 ||
          dstFormat == MESA_FORMAT_LA_UINT32 ||
          dstFormat == MESA_FORMAT_RGBX_UINT32);
   ASSERT(baseInternalFormat == GL_RGBA ||
          baseInternalFormat == GL_RGB ||
          baseInternalFormat == GL_RG ||
          baseInternalFormat == GL_RED ||
          baseInternalFormat == GL_ALPHA ||
          baseInternalFormat == GL_LUMINANCE ||
          baseInternalFormat == GL_LUMINANCE_ALPHA ||
          baseInternalFormat == GL_INTENSITY);
   ASSERT(_mesa_get_format_bytes(dstFormat) == components * sizeof(GLuint));

   {
      /* general path */
      const GLuint *tempImage =
         make_temp_uint_image(ctx, dims, baseInternalFormat, baseFormat,
                              srcWidth, srcHeight, srcDepth,
                              srcFormat, srcType, srcAddr, srcPacking);
      const GLuint *src = tempImage;
      GLboolean is_unsigned = _mesa_is_type_unsigned(srcType);
      GLint img, row;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLuint *dstTexel = (GLuint *) dstRow;
            GLint i;
            if (is_unsigned) {
               for (i = 0; i < srcWidth * components; i++) {
                  dstTexel[i] = src[i];
               }
            } else {
               for (i = 0; i < srcWidth * components; i++) {
                  dstTexel[i] = MAX2((GLint) src[i], 0);
               }
            }
            dstRow += dstRowStride;
            src += srcWidth * components;
         }
      }

      free((void *) tempImage);
   }
   return GL_TRUE;
}


static GLboolean
_mesa_texstore_srgb8(TEXSTORE_PARAMS)
{
   mesa_format newDstFormat;
   GLboolean k;

   ASSERT(dstFormat == MESA_FORMAT_BGR_SRGB8);

   /* reuse normal rgb texstore code */
   newDstFormat = MESA_FORMAT_BGR_UNORM8;

   k = _mesa_texstore_rgb888(ctx, dims, baseInternalFormat,
                             newDstFormat,
                             dstRowStride, dstSlices,
                             srcWidth, srcHeight, srcDepth,
                             srcFormat, srcType,
                             srcAddr, srcPacking);
   return k;
}


static GLboolean
_mesa_texstore_srgba8(TEXSTORE_PARAMS)
{
   mesa_format newDstFormat;
   GLboolean k;

   ASSERT(dstFormat == MESA_FORMAT_A8B8G8R8_SRGB ||
          dstFormat == MESA_FORMAT_R8G8B8X8_SRGB ||
          dstFormat == MESA_FORMAT_R8G8B8A8_SRGB);

   newDstFormat = _mesa_get_srgb_format_linear(dstFormat);

   k = _mesa_texstore_rgba8888(ctx, dims, baseInternalFormat,
                               newDstFormat,
                               dstRowStride, dstSlices,
                               srcWidth, srcHeight, srcDepth,
                               srcFormat, srcType,
                               srcAddr, srcPacking);
   return k;
}


static GLboolean
_mesa_texstore_sargb8(TEXSTORE_PARAMS)
{
   mesa_format newDstFormat;
   GLboolean k;

   assert(dstFormat == MESA_FORMAT_B8G8R8A8_SRGB ||
          dstFormat == MESA_FORMAT_B8G8R8X8_SRGB);

   newDstFormat = _mesa_get_srgb_format_linear(dstFormat);

   k = _mesa_texstore_argb8888(ctx, dims, baseInternalFormat,
                               newDstFormat,
                               dstRowStride, dstSlices,
                               srcWidth, srcHeight, srcDepth,
                               srcFormat, srcType,
                               srcAddr, srcPacking);
   return k;
}


static GLboolean
_mesa_texstore_sl8(TEXSTORE_PARAMS)
{
   mesa_format newDstFormat;
   GLboolean k;

   ASSERT(dstFormat == MESA_FORMAT_L_SRGB8);

   newDstFormat = MESA_FORMAT_L_UNORM8;

   /* _mesa_textore_a8 handles luminance8 too */
   k = _mesa_texstore_unorm8(ctx, dims, baseInternalFormat,
                             newDstFormat,
                             dstRowStride, dstSlices,
                             srcWidth, srcHeight, srcDepth,
                             srcFormat, srcType,
                             srcAddr, srcPacking);
   return k;
}


static GLboolean
_mesa_texstore_sla8(TEXSTORE_PARAMS)
{
   mesa_format newDstFormat;
   GLboolean k;

   ASSERT(dstFormat == MESA_FORMAT_L8A8_SRGB);

   /* reuse normal luminance/alpha texstore code */
   newDstFormat = MESA_FORMAT_L8A8_UNORM;

   k = _mesa_texstore_unorm88(ctx, dims, baseInternalFormat,
			      newDstFormat,
			      dstRowStride, dstSlices,
			      srcWidth, srcHeight, srcDepth,
			      srcFormat, srcType,
			      srcAddr, srcPacking);
   return k;
}

static GLboolean
_mesa_texstore_rgb9_e5(TEXSTORE_PARAMS)
{
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_R9G9B9E5_FLOAT);
   ASSERT(baseInternalFormat == GL_RGB);

   {
      /* general path */
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *srcRow = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLuint *dstUI = (GLuint*)dstRow;
            for (col = 0; col < srcWidth; col++) {
               dstUI[col] = float3_to_rgb9e5(&srcRow[col * 3]);
            }
            dstRow += dstRowStride;
            srcRow += srcWidth * 3;
         }
      }

      free((void *) tempImage);
   }
   return GL_TRUE;
}

static GLboolean
_mesa_texstore_r11_g11_b10f(TEXSTORE_PARAMS)
{
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);

   ASSERT(dstFormat == MESA_FORMAT_R11G11B10_FLOAT);
   ASSERT(baseInternalFormat == GL_RGB);

   {
      /* general path */
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *srcRow = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
         for (row = 0; row < srcHeight; row++) {
            GLuint *dstUI = (GLuint*)dstRow;
            for (col = 0; col < srcWidth; col++) {
               dstUI[col] = float3_to_r11g11b10f(&srcRow[col * 3]);
            }
            dstRow += dstRowStride;
            srcRow += srcWidth * 3;
d1191 1
a1191 1
      free((void *) tempImage);
d1193 1
d1359 1
d1361 1
a1361 1
_mesa_texstore_abgr2101010(TEXSTORE_PARAMS)
d1363 2
a1364 1
   const GLenum baseFormat = _mesa_get_format_base_format(dstFormat);
d1366 2
a1367 2
   ASSERT(dstFormat == MESA_FORMAT_R10G10B10A2_UNORM);
   ASSERT(_mesa_get_format_bytes(dstFormat) == 4);
d1369 9
a1377 15
   {
      /* general path */
      const GLfloat *tempImage = _mesa_make_temp_float_image(ctx, dims,
                                                 baseInternalFormat,
                                                 baseFormat,
                                                 srcWidth, srcHeight, srcDepth,
                                                 srcFormat, srcType, srcAddr,
                                                 srcPacking,
                                                 ctx->_ImageTransferState);
      const GLfloat *src = tempImage;
      GLint img, row, col;
      if (!tempImage)
         return GL_FALSE;
      for (img = 0; img < srcDepth; img++) {
         GLubyte *dstRow = dstSlices[img];
d1379 2
a1380 4
         for (row = 0; row < srcHeight; row++) {
            GLuint *dstUI = (GLuint *) dstRow;
            for (col = 0; col < srcWidth; col++) {
               GLushort a,r,g,b;
d1382 5
a1386 13
               UNCLAMPED_FLOAT_TO_USHORT(a, src[ACOMP]);
               UNCLAMPED_FLOAT_TO_USHORT(r, src[RCOMP]);
               UNCLAMPED_FLOAT_TO_USHORT(g, src[GCOMP]);
               UNCLAMPED_FLOAT_TO_USHORT(b, src[BCOMP]);
               dstUI[col] = PACK_COLOR_2101010_US(a, b, g, r);
               src += 4;
            }
            dstRow += dstRowStride;
         }
      }
      free((void *) tempImage);
   }
   return GL_TRUE;
d1390 1
a1390 22
_mesa_texstore_null(TEXSTORE_PARAMS)
{
   (void) ctx; (void) dims;
   (void) baseInternalFormat;
   (void) dstFormat;
   (void) dstRowStride; (void) dstSlices,
   (void) srcWidth; (void) srcHeight; (void) srcDepth;
   (void) srcFormat; (void) srcType;
   (void) srcAddr;
   (void) srcPacking;

   /* should never happen */
   _mesa_problem(NULL, "_mesa_texstore_null() is called");
   return GL_FALSE;
}


/**
 * Return the StoreTexImageFunc pointer to store an image in the given format.
 */
static StoreTexImageFunc
_mesa_get_texstore_func(mesa_format format)
d1396 1
a1396 1
      table[MESA_FORMAT_NONE] = _mesa_texstore_null;
a1397 50
      table[MESA_FORMAT_A8B8G8R8_UNORM] = _mesa_texstore_rgba8888;
      table[MESA_FORMAT_R8G8B8A8_UNORM] = _mesa_texstore_rgba8888;
      table[MESA_FORMAT_B8G8R8A8_UNORM] = _mesa_texstore_argb8888;
      table[MESA_FORMAT_A8R8G8B8_UNORM] = _mesa_texstore_argb8888;
      table[MESA_FORMAT_X8B8G8R8_UNORM] = _mesa_texstore_rgba8888;
      table[MESA_FORMAT_R8G8B8X8_UNORM] = _mesa_texstore_rgba8888;
      table[MESA_FORMAT_B8G8R8X8_UNORM] = _mesa_texstore_argb8888;
      table[MESA_FORMAT_X8R8G8B8_UNORM] = _mesa_texstore_argb8888;
      table[MESA_FORMAT_BGR_UNORM8] = _mesa_texstore_rgb888;
      table[MESA_FORMAT_RGB_UNORM8] = _mesa_texstore_bgr888;
      table[MESA_FORMAT_B5G6R5_UNORM] = _mesa_texstore_rgb565;
      table[MESA_FORMAT_R5G6B5_UNORM] = _mesa_texstore_rgb565;
      table[MESA_FORMAT_B4G4R4A4_UNORM] = store_ubyte_texture;
      table[MESA_FORMAT_A4R4G4B4_UNORM] = store_ubyte_texture;
      table[MESA_FORMAT_A1B5G5R5_UNORM] = store_ubyte_texture;
      table[MESA_FORMAT_B5G5R5A1_UNORM] = store_ubyte_texture;
      table[MESA_FORMAT_A1R5G5B5_UNORM] = store_ubyte_texture;
      table[MESA_FORMAT_L4A4_UNORM] = _mesa_texstore_unorm44;
      table[MESA_FORMAT_L8A8_UNORM] = _mesa_texstore_unorm88;
      table[MESA_FORMAT_A8L8_UNORM] = _mesa_texstore_unorm88;
      table[MESA_FORMAT_L16A16_UNORM] = _mesa_texstore_unorm1616;
      table[MESA_FORMAT_A16L16_UNORM] = _mesa_texstore_unorm1616;
      table[MESA_FORMAT_B2G3R3_UNORM] = store_ubyte_texture;
      table[MESA_FORMAT_A_UNORM8] = _mesa_texstore_unorm8;
      table[MESA_FORMAT_A_UNORM16] = _mesa_texstore_unorm16;
      table[MESA_FORMAT_L_UNORM8] = _mesa_texstore_unorm8;
      table[MESA_FORMAT_L_UNORM16] = _mesa_texstore_unorm16;
      table[MESA_FORMAT_I_UNORM8] = _mesa_texstore_unorm8;
      table[MESA_FORMAT_I_UNORM16] = _mesa_texstore_unorm16;
      table[MESA_FORMAT_YCBCR] = _mesa_texstore_ycbcr;
      table[MESA_FORMAT_YCBCR_REV] = _mesa_texstore_ycbcr;
      table[MESA_FORMAT_R_UNORM8] = _mesa_texstore_unorm8;
      table[MESA_FORMAT_R8G8_UNORM] = _mesa_texstore_unorm88;
      table[MESA_FORMAT_G8R8_UNORM] = _mesa_texstore_unorm88;
      table[MESA_FORMAT_R_UNORM16] = _mesa_texstore_unorm16;
      table[MESA_FORMAT_R16G16_UNORM] = _mesa_texstore_unorm1616;
      table[MESA_FORMAT_G16R16_UNORM] = _mesa_texstore_unorm1616;
      table[MESA_FORMAT_B10G10R10A2_UNORM] = _mesa_texstore_argb2101010;
      table[MESA_FORMAT_S8_UINT_Z24_UNORM] = _mesa_texstore_z24_s8;
      table[MESA_FORMAT_Z24_UNORM_S8_UINT] = _mesa_texstore_s8_z24;
      table[MESA_FORMAT_Z_UNORM16] = _mesa_texstore_z16;
      table[MESA_FORMAT_Z24_UNORM_X8_UINT] = _mesa_texstore_x8_z24;
      table[MESA_FORMAT_X8_UINT_Z24_UNORM] = _mesa_texstore_z24_x8;
      table[MESA_FORMAT_Z_UNORM32] = _mesa_texstore_z32;
      table[MESA_FORMAT_S_UINT8] = _mesa_texstore_s8;
      table[MESA_FORMAT_BGR_SRGB8] = _mesa_texstore_srgb8;
      table[MESA_FORMAT_A8B8G8R8_SRGB] = _mesa_texstore_srgba8;
      table[MESA_FORMAT_B8G8R8A8_SRGB] = _mesa_texstore_sargb8;
      table[MESA_FORMAT_L_SRGB8] = _mesa_texstore_sl8;
      table[MESA_FORMAT_L8A8_SRGB] = _mesa_texstore_sla8;
a1407 27
      table[MESA_FORMAT_RGBA_FLOAT32] = _mesa_texstore_rgba_float32;
      table[MESA_FORMAT_RGBA_FLOAT16] = _mesa_texstore_rgba_float16;
      table[MESA_FORMAT_RGB_FLOAT32] = _mesa_texstore_rgba_float32;
      table[MESA_FORMAT_RGB_FLOAT16] = _mesa_texstore_rgba_float16;
      table[MESA_FORMAT_A_FLOAT32] = _mesa_texstore_rgba_float32;
      table[MESA_FORMAT_A_FLOAT16] = _mesa_texstore_rgba_float16;
      table[MESA_FORMAT_L_FLOAT32] = _mesa_texstore_rgba_float32;
      table[MESA_FORMAT_L_FLOAT16] = _mesa_texstore_rgba_float16;
      table[MESA_FORMAT_LA_FLOAT32] = _mesa_texstore_rgba_float32;
      table[MESA_FORMAT_LA_FLOAT16] = _mesa_texstore_rgba_float16;
      table[MESA_FORMAT_I_FLOAT32] = _mesa_texstore_rgba_float32;
      table[MESA_FORMAT_I_FLOAT16] = _mesa_texstore_rgba_float16;
      table[MESA_FORMAT_R_FLOAT32] = _mesa_texstore_rgba_float32;
      table[MESA_FORMAT_R_FLOAT16] = _mesa_texstore_rgba_float16;
      table[MESA_FORMAT_RG_FLOAT32] = _mesa_texstore_rgba_float32;
      table[MESA_FORMAT_RG_FLOAT16] = _mesa_texstore_rgba_float16;
      table[MESA_FORMAT_DUDV8] = _mesa_texstore_dudv8;
      table[MESA_FORMAT_R_SNORM8] = _mesa_texstore_snorm8;
      table[MESA_FORMAT_R8G8_SNORM] = _mesa_texstore_snorm88;
      table[MESA_FORMAT_X8B8G8R8_SNORM] = _mesa_texstore_signed_rgbx8888;
      table[MESA_FORMAT_A8B8G8R8_SNORM] = _mesa_texstore_signed_rgba8888;
      table[MESA_FORMAT_R8G8B8A8_SNORM] = _mesa_texstore_signed_rgba8888;
      table[MESA_FORMAT_R_SNORM16] = _mesa_texstore_snorm16;
      table[MESA_FORMAT_R16G16_SNORM] = _mesa_texstore_snorm1616;
      table[MESA_FORMAT_RGB_SNORM16] = _mesa_texstore_signed_rgba_16;
      table[MESA_FORMAT_RGBA_SNORM16] = _mesa_texstore_signed_rgba_16;
      table[MESA_FORMAT_RGBA_UNORM16] = _mesa_texstore_rgba_16;
a1428 12
      table[MESA_FORMAT_A_SNORM8] = _mesa_texstore_snorm8;
      table[MESA_FORMAT_L_SNORM8] = _mesa_texstore_snorm8;
      table[MESA_FORMAT_L8A8_SNORM] = _mesa_texstore_snorm88;
      table[MESA_FORMAT_I_SNORM8] = _mesa_texstore_snorm8;
      table[MESA_FORMAT_A_SNORM16] = _mesa_texstore_snorm16;
      table[MESA_FORMAT_L_SNORM16] = _mesa_texstore_snorm16;
      table[MESA_FORMAT_LA_SNORM16] = _mesa_texstore_snorm1616;
      table[MESA_FORMAT_I_SNORM16] = _mesa_texstore_snorm16;
      table[MESA_FORMAT_R9G9B9E5_FLOAT] = _mesa_texstore_rgb9_e5;
      table[MESA_FORMAT_R11G11B10_FLOAT] = _mesa_texstore_r11_g11_b10f;
      table[MESA_FORMAT_Z_FLOAT32] = _mesa_texstore_z32;
      table[MESA_FORMAT_Z32_FLOAT_S8X24_UINT] = _mesa_texstore_z32f_x24s8;
d1430 278
a1707 53
      table[MESA_FORMAT_A_UINT8] = _mesa_texstore_rgba_uint8;
      table[MESA_FORMAT_A_UINT16] = _mesa_texstore_rgba_uint16;
      table[MESA_FORMAT_A_UINT32] = _mesa_texstore_rgba_uint32;
      table[MESA_FORMAT_A_SINT8] = _mesa_texstore_rgba_int8;
      table[MESA_FORMAT_A_SINT16] = _mesa_texstore_rgba_int16;
      table[MESA_FORMAT_A_SINT32] = _mesa_texstore_rgba_int32;

      table[MESA_FORMAT_I_UINT8] = _mesa_texstore_rgba_uint8;
      table[MESA_FORMAT_I_UINT16] = _mesa_texstore_rgba_uint16;
      table[MESA_FORMAT_I_UINT32] = _mesa_texstore_rgba_uint32;
      table[MESA_FORMAT_I_SINT8] = _mesa_texstore_rgba_int8;
      table[MESA_FORMAT_I_SINT16] = _mesa_texstore_rgba_int16;
      table[MESA_FORMAT_I_SINT32] = _mesa_texstore_rgba_int32;

      table[MESA_FORMAT_L_UINT8] = _mesa_texstore_rgba_uint8;
      table[MESA_FORMAT_L_UINT16] = _mesa_texstore_rgba_uint16;
      table[MESA_FORMAT_L_UINT32] = _mesa_texstore_rgba_uint32;
      table[MESA_FORMAT_L_SINT8] = _mesa_texstore_rgba_int8;
      table[MESA_FORMAT_L_SINT16] = _mesa_texstore_rgba_int16;
      table[MESA_FORMAT_L_SINT32] = _mesa_texstore_rgba_int32;

      table[MESA_FORMAT_LA_UINT8] = _mesa_texstore_rgba_uint8;
      table[MESA_FORMAT_LA_UINT16] = _mesa_texstore_rgba_uint16;
      table[MESA_FORMAT_LA_UINT32] = _mesa_texstore_rgba_uint32;
      table[MESA_FORMAT_LA_SINT8] = _mesa_texstore_rgba_int8;
      table[MESA_FORMAT_LA_SINT16] = _mesa_texstore_rgba_int16;
      table[MESA_FORMAT_LA_SINT32] = _mesa_texstore_rgba_int32;

      table[MESA_FORMAT_R_SINT8] = _mesa_texstore_rgba_int8;
      table[MESA_FORMAT_RG_SINT8] = _mesa_texstore_rgba_int8;
      table[MESA_FORMAT_RGB_SINT8] = _mesa_texstore_rgba_int8;
      table[MESA_FORMAT_RGBA_SINT8] = _mesa_texstore_rgba_int8;
      table[MESA_FORMAT_R_SINT16] = _mesa_texstore_rgba_int16;
      table[MESA_FORMAT_RG_SINT16] = _mesa_texstore_rgba_int16;
      table[MESA_FORMAT_RGB_SINT16] = _mesa_texstore_rgba_int16;
      table[MESA_FORMAT_RGBA_SINT16] = _mesa_texstore_rgba_int16;
      table[MESA_FORMAT_R_SINT32] = _mesa_texstore_rgba_int32;
      table[MESA_FORMAT_RG_SINT32] = _mesa_texstore_rgba_int32;
      table[MESA_FORMAT_RGB_SINT32] = _mesa_texstore_rgba_int32;
      table[MESA_FORMAT_RGBA_SINT32] = _mesa_texstore_rgba_int32;

      table[MESA_FORMAT_R_UINT8] = _mesa_texstore_rgba_uint8;
      table[MESA_FORMAT_RG_UINT8] = _mesa_texstore_rgba_uint8;
      table[MESA_FORMAT_RGB_UINT8] = _mesa_texstore_rgba_uint8;
      table[MESA_FORMAT_RGBA_UINT8] = _mesa_texstore_rgba_uint8;
      table[MESA_FORMAT_R_UINT16] = _mesa_texstore_rgba_uint16;
      table[MESA_FORMAT_RG_UINT16] = _mesa_texstore_rgba_uint16;
      table[MESA_FORMAT_RGB_UINT16] = _mesa_texstore_rgba_uint16;
      table[MESA_FORMAT_RGBA_UINT16] = _mesa_texstore_rgba_uint16;
      table[MESA_FORMAT_R_UINT32] = _mesa_texstore_rgba_uint32;
      table[MESA_FORMAT_RG_UINT32] = _mesa_texstore_rgba_uint32;
      table[MESA_FORMAT_RGB_UINT32] = _mesa_texstore_rgba_uint32;
      table[MESA_FORMAT_RGBA_UINT32] = _mesa_texstore_rgba_uint32;
d1709 2
a1710 2
      table[MESA_FORMAT_B10G10R10A2_UINT] = _mesa_texstore_argb2101010_uint;
      table[MESA_FORMAT_R10G10B10A2_UINT] = _mesa_texstore_abgr2101010_uint;
d1712 5
a1716 16
      table[MESA_FORMAT_B4G4R4X4_UNORM] = store_ubyte_texture;
      table[MESA_FORMAT_B5G5R5X1_UNORM] = store_ubyte_texture;
      table[MESA_FORMAT_R8G8B8X8_SNORM] = _mesa_texstore_signed_rgbx8888;
      table[MESA_FORMAT_R8G8B8X8_SRGB] = _mesa_texstore_srgba8;
      table[MESA_FORMAT_R8G8B8A8_SRGB] = _mesa_texstore_srgba8;
      table[MESA_FORMAT_RGBX_UINT8] = _mesa_texstore_rgba_uint8;
      table[MESA_FORMAT_RGBX_SINT8] = _mesa_texstore_rgba_int8;
      table[MESA_FORMAT_B10G10R10X2_UNORM] = _mesa_texstore_argb2101010;
      table[MESA_FORMAT_RGBX_UNORM16] = _mesa_texstore_rgba_16;
      table[MESA_FORMAT_RGBX_SNORM16] = _mesa_texstore_signed_rgba_16;
      table[MESA_FORMAT_RGBX_FLOAT16] = _mesa_texstore_rgba_float16;
      table[MESA_FORMAT_RGBX_UINT16] = _mesa_texstore_rgba_uint16;
      table[MESA_FORMAT_RGBX_SINT16] = _mesa_texstore_rgba_int16;
      table[MESA_FORMAT_RGBX_FLOAT32] = _mesa_texstore_rgba_float32;
      table[MESA_FORMAT_RGBX_UINT32] = _mesa_texstore_rgba_uint32;
      table[MESA_FORMAT_RGBX_SINT32] = _mesa_texstore_rgba_int32;
d1718 2
a1719 1
      table[MESA_FORMAT_R10G10B10A2_UNORM] = _mesa_texstore_abgr2101010;
d1721 4
a1724 2
      table[MESA_FORMAT_G8R8_SNORM] = _mesa_texstore_snorm88;
      table[MESA_FORMAT_G16R16_SNORM] = _mesa_texstore_snorm1616;
d1726 2
a1727 1
      table[MESA_FORMAT_B8G8R8X8_SRGB] = _mesa_texstore_sargb8;
d1732 36
a1767 2
   ASSERT(table[format]);
   return table[format];
a1769 1

a1853 2


a1861 3
   StoreTexImageFunc storeImage;
   GLboolean success;

d1870 16
a1885 8
   storeImage = _mesa_get_texstore_func(dstFormat);

   success = storeImage(ctx, dims, baseInternalFormat,
                        dstFormat,
                        dstRowStride, dstSlices,
                        srcWidth, srcHeight, srcDepth,
                        srcFormat, srcType, srcAddr, srcPacking);
   return success;
d2088 72
d2199 64
d2273 3
a2275 2
   GLint bytesPerRow, dstRowStride, srcRowStride;
   GLint i, rows;
a2277 3
   const mesa_format texFormat = texImage->TexFormat;
   GLuint bw, bh;
   GLint slice;
d2284 3
a2286 1
   _mesa_get_format_block_size(texFormat, &bw, &bh);
d2295 1
a2295 2
   srcRowStride = _mesa_format_row_stride(texFormat, width);
   src = (const GLubyte *) data;
d2297 1
a2297 1
   for (slice = 0; slice < depth; slice++) {
a2304 2
         bytesPerRow = srcRowStride;  /* bytes per row of blocks */
         rows = (height + bh - 1) / bh;  /* rows in blocks */
d2307 2
a2308 2
         for (i = 0; i < rows; i++) {
            memcpy(dstMap, src, bytesPerRow);
d2310 1
a2310 1
            src += srcRowStride;
d2314 3
@


