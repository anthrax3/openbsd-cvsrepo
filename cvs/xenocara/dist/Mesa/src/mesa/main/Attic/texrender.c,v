head	1.6;
access;
symbols
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	v7_10_3:1.1.1.3
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v7_0_1:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v6_5_2:1.1.1.1
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2012.08.17.13.58.19;	author mpi;	state dead;
branches;
next	1.5;

1.5
date	2011.10.23.13.37.44;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.31;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.42;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.21;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.50.26;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.50.26;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.31.26;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.10.23.13.29.47;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@
#include "context.h"
#include "colormac.h"
#include "macros.h"
#include "texfetch.h"
#include "texrender.h"
#include "renderbuffer.h"


/*
 * Render-to-texture code for GL_EXT_framebuffer_object
 */


/**
 * Derived from gl_renderbuffer class
 */
struct texture_renderbuffer
{
   struct gl_renderbuffer Base;   /**< Base class object */
   struct gl_texture_image *TexImage;
   StoreTexelFunc Store;
   GLint Yoffset;                 /**< Layer for 1D array textures. */
   GLint Zoffset;                 /**< Layer for 2D array textures, or slice
				   * for 3D textures
				   */
};


/**
 * Get row of values from the renderbuffer that wraps a texture image.
 */
static void
texture_get_row(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
                GLint x, GLint y, void *values)
{
   const struct texture_renderbuffer *trb
      = (const struct texture_renderbuffer *) rb;
   const GLint z = trb->Zoffset;
   GLuint i;

   ASSERT(trb->TexImage->Width == rb->Width);
   ASSERT(trb->TexImage->Height == rb->Height);

   y += trb->Yoffset;

   if (rb->DataType == CHAN_TYPE) {
      GLchan *rgbaOut = (GLchan *) values;
      for (i = 0; i < count; i++) {
         GLfloat rgba[4];
         trb->TexImage->FetchTexelf(trb->TexImage, x + i, y, z, rgba);
         UNCLAMPED_FLOAT_TO_RGBA_CHAN(rgbaOut + 4 * i, rgba);
      }
   }
   else if (rb->DataType == GL_UNSIGNED_SHORT) {
      GLushort *zValues = (GLushort *) values;
      for (i = 0; i < count; i++) {
         GLfloat flt;
         trb->TexImage->FetchTexelf(trb->TexImage, x + i, y, z, &flt);
         zValues[i] = (GLushort) (flt * 0xffff);
      }
   }
   else if (rb->DataType == GL_UNSIGNED_INT) {
      GLuint *zValues = (GLuint *) values;
      /*
      const GLdouble scale = (GLdouble) 0xffffffff;
      */
      for (i = 0; i < count; i++) {
         GLfloat flt;
         trb->TexImage->FetchTexelf(trb->TexImage, x + i, y, z, &flt);
#if 0
         /* this should work, but doesn't (overflow due to low precision) */
         zValues[i] = (GLuint) (flt * scale);
#else
         /* temporary hack */
         zValues[i] = ((GLuint) (flt * 0xffffff)) << 8;
#endif
      }
   }
   else if (rb->DataType == GL_UNSIGNED_INT_24_8_EXT) {
      GLuint *zValues = (GLuint *) values;
      for (i = 0; i < count; i++) {
         GLfloat flt;
         trb->TexImage->FetchTexelf(trb->TexImage, x + i, y, z, &flt);
         zValues[i] = ((GLuint) (flt * 0xffffff)) << 8;
      }
   }
   else if (rb->DataType == GL_UNSIGNED_INT_8_24_REV_MESA) {
      GLuint *zValues = (GLuint *) values;
      for (i = 0; i < count; i++) {
         GLfloat flt;
         trb->TexImage->FetchTexelf(trb->TexImage, x + i, y, z, &flt);
         zValues[i] = (GLuint) (flt * 0xffffff);
      }
   }
   else {
      _mesa_problem(ctx, "invalid rb->DataType in texture_get_row");
   }
}


static void
texture_get_values(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
                   const GLint x[], const GLint y[], void *values)
{
   const struct texture_renderbuffer *trb
      = (const struct texture_renderbuffer *) rb;
   const GLint z = trb->Zoffset;
   GLuint i;

   if (rb->DataType == CHAN_TYPE) {
      GLchan *rgbaOut = (GLchan *) values;
      for (i = 0; i < count; i++) {
         GLfloat rgba[4];
         trb->TexImage->FetchTexelf(trb->TexImage, x[i], y[i] + trb->Yoffset,
				    z, rgba);
         UNCLAMPED_FLOAT_TO_RGBA_CHAN(rgbaOut + 4 * i, rgba);
      }
   }
   else if (rb->DataType == GL_UNSIGNED_SHORT) {
      GLushort *zValues = (GLushort *) values;
      for (i = 0; i < count; i++) {
         GLfloat flt;
         trb->TexImage->FetchTexelf(trb->TexImage, x[i], y[i] + trb->Yoffset,
				    z, &flt);
         zValues[i] = (GLushort) (flt * 0xffff);
      }
   }
   else if (rb->DataType == GL_UNSIGNED_INT) {
      GLuint *zValues = (GLuint *) values;
      for (i = 0; i < count; i++) {
         GLfloat flt;
         trb->TexImage->FetchTexelf(trb->TexImage, x[i], y[i] + trb->Yoffset,
				    z, &flt);
#if 0
         zValues[i] = (GLuint) (flt * 0xffffffff);
#else
         zValues[i] = ((GLuint) (flt * 0xffffff)) << 8;
#endif
      }
   }
   else if (rb->DataType == GL_UNSIGNED_INT_24_8_EXT) {
      GLuint *zValues = (GLuint *) values;
      for (i = 0; i < count; i++) {
         GLfloat flt;
         trb->TexImage->FetchTexelf(trb->TexImage, x[i], y[i] + trb->Yoffset,
				    z, &flt);
         zValues[i] = ((GLuint) (flt * 0xffffff)) << 8;
      }
   }
   else if (rb->DataType == GL_UNSIGNED_INT_8_24_REV_MESA) {
      GLuint *zValues = (GLuint *) values;
      for (i = 0; i < count; i++) {
         GLfloat flt;
         trb->TexImage->FetchTexelf(trb->TexImage, x[i], y[i] + trb->Yoffset,
				    z, &flt);
         zValues[i] = (GLuint) (flt * 0xffffff);
      }
   }
   else {
      _mesa_problem(ctx, "invalid rb->DataType in texture_get_values");
   }
}


/**
 * Put row of values into a renderbuffer that wraps a texture image.
 */
static void
texture_put_row(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
                GLint x, GLint y, const void *values, const GLubyte *mask)
{
   const struct texture_renderbuffer *trb
      = (const struct texture_renderbuffer *) rb;
   const GLint z = trb->Zoffset;
   GLuint i;

   y += trb->Yoffset;

   if (rb->DataType == CHAN_TYPE) {
      const GLchan *rgba = (const GLchan *) values;
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            trb->Store(trb->TexImage, x + i, y, z, rgba);
         }
         rgba += 4;
      }
   }
   else if (rb->DataType == GL_UNSIGNED_SHORT) {
      const GLushort *zValues = (const GLushort *) values;
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            trb->Store(trb->TexImage, x + i, y, z, zValues + i);
         }
      }
   }
   else if (rb->DataType == GL_UNSIGNED_INT) {
      const GLuint *zValues = (const GLuint *) values;
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            trb->Store(trb->TexImage, x + i, y, z, zValues + i);
         }
      }
   }
   else if (rb->DataType == GL_UNSIGNED_INT_24_8_EXT) {
      const GLuint *zValues = (const GLuint *) values;
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            GLfloat flt = (GLfloat) ((zValues[i] >> 8) * (1.0 / 0xffffff));
            trb->Store(trb->TexImage, x + i, y, z, &flt);
         }
      }
   }
   else if (rb->DataType == GL_UNSIGNED_INT_8_24_REV_MESA) {
      const GLuint *zValues = (const GLuint *) values;
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            GLfloat flt = (GLfloat) ((zValues[i] & 0xffffff) * (1.0 / 0xffffff));
            trb->Store(trb->TexImage, x + i, y, z, &flt);
         }
      }
   }
   else {
      _mesa_problem(ctx, "invalid rb->DataType in texture_put_row");
   }
}

/**
 * Put row of RGB values into a renderbuffer that wraps a texture image.
 */
static void
texture_put_row_rgb(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
                GLint x, GLint y, const void *values, const GLubyte *mask)
{
   const struct texture_renderbuffer *trb
      = (const struct texture_renderbuffer *) rb;
   const GLint z = trb->Zoffset;
   GLuint i;

   y += trb->Yoffset;

   if (rb->DataType == CHAN_TYPE) {
      const GLchan *rgb = (const GLchan *) values;
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            trb->Store(trb->TexImage, x + i, y, z, rgb);
         }
         rgb += 3;
      }
   }
   else if (rb->DataType == GL_UNSIGNED_SHORT) {
      const GLushort *zValues = (const GLushort *) values;
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            trb->Store(trb->TexImage, x + i, y, z, zValues + i);
         }
      }
   }
   else if (rb->DataType == GL_UNSIGNED_INT) {
      const GLuint *zValues = (const GLuint *) values;
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            trb->Store(trb->TexImage, x + i, y, z, zValues + i);
         }
      }
   }
   else if (rb->DataType == GL_UNSIGNED_INT_24_8_EXT) {
      const GLuint *zValues = (const GLuint *) values;
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            GLfloat flt = (GLfloat) ((zValues[i] >> 8) * (1.0 / 0xffffff));
            trb->Store(trb->TexImage, x + i, y, z, &flt);
         }
      }
   }
   else if (rb->DataType == GL_UNSIGNED_INT_8_24_REV_MESA) {
      const GLuint *zValues = (const GLuint *) values;
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            GLfloat flt = (GLfloat) ((zValues[i] & 0xffffff) * (1.0 / 0xffffff));
            trb->Store(trb->TexImage, x + i, y, z, &flt);
         }
      }
   }
   else {
      _mesa_problem(ctx, "invalid rb->DataType in texture_put_row");
   }
}


static void
texture_put_mono_row(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
                     GLint x, GLint y, const void *value, const GLubyte *mask)
{
   const struct texture_renderbuffer *trb
      = (const struct texture_renderbuffer *) rb;
   const GLint z = trb->Zoffset;
   GLuint i;

   y += trb->Yoffset;

   if (rb->DataType == CHAN_TYPE) {
      const GLchan *rgba = (const GLchan *) value;
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            trb->Store(trb->TexImage, x + i, y, z, rgba);
         }
      }
   }
   else if (rb->DataType == GL_UNSIGNED_SHORT) {
      const GLushort zValue = *((const GLushort *) value);
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            trb->Store(trb->TexImage, x + i, y, z, &zValue);
         }
      }
   }
   else if (rb->DataType == GL_UNSIGNED_INT) {
      const GLuint zValue = *((const GLuint *) value);
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            trb->Store(trb->TexImage, x + i, y, z, &zValue);
         }
      }
   }
   else if (rb->DataType == GL_UNSIGNED_INT_24_8_EXT) {
      const GLuint zValue = *((const GLuint *) value);
      const GLfloat flt = (GLfloat) ((zValue >> 8) * (1.0 / 0xffffff));
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            trb->Store(trb->TexImage, x + i, y, z, &flt);
         }
      }
   }
   else if (rb->DataType == GL_UNSIGNED_INT_8_24_REV_MESA) {
      const GLuint zValue = *((const GLuint *) value);
      const GLfloat flt = (GLfloat) ((zValue & 0xffffff) * (1.0 / 0xffffff));
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            trb->Store(trb->TexImage, x + i, y, z, &flt);
         }
      }
   }
   else {
      _mesa_problem(ctx, "invalid rb->DataType in texture_put_mono_row");
   }
}


static void
texture_put_values(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
                   const GLint x[], const GLint y[], const void *values,
                   const GLubyte *mask)
{
   const struct texture_renderbuffer *trb
      = (const struct texture_renderbuffer *) rb;
   const GLint z = trb->Zoffset;
   GLuint i;

   if (rb->DataType == CHAN_TYPE) {
      const GLchan *rgba = (const GLchan *) values;
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            trb->Store(trb->TexImage, x[i], y[i] + trb->Yoffset, z, rgba);
         }
         rgba += 4;
      }
   }
   else if (rb->DataType == GL_UNSIGNED_SHORT) {
      const GLushort *zValues = (const GLushort *) values;
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            trb->Store(trb->TexImage, x[i], y[i] + trb->Yoffset, z, zValues + i);
         }
      }
   }
   else if (rb->DataType == GL_UNSIGNED_INT) {
      const GLuint *zValues = (const GLuint *) values;
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            trb->Store(trb->TexImage, x[i], y[i] + trb->Yoffset, z, zValues + i);
         }
      }
   }
   else if (rb->DataType == GL_UNSIGNED_INT_24_8_EXT) {
      const GLuint *zValues = (const GLuint *) values;
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            GLfloat flt = (GLfloat) ((zValues[i] >> 8) * (1.0 / 0xffffff));
            trb->Store(trb->TexImage, x[i], y[i] + trb->Yoffset, z, &flt);
         }
      }
   }
   else if (rb->DataType == GL_UNSIGNED_INT_8_24_REV_MESA) {
      const GLuint *zValues = (const GLuint *) values;
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            GLfloat flt = (GLfloat) ((zValues[i] & 0xffffff) * (1.0 / 0xffffff));
            trb->Store(trb->TexImage, x[i], y[i] + trb->Yoffset, z, &flt);
         }
      }
   }
   else {
      _mesa_problem(ctx, "invalid rb->DataType in texture_put_values");
   }
}


static void
texture_put_mono_values(struct gl_context *ctx, struct gl_renderbuffer *rb,
                        GLuint count, const GLint x[], const GLint y[],
                        const void *value, const GLubyte *mask)
{
   const struct texture_renderbuffer *trb
      = (const struct texture_renderbuffer *) rb;
   const GLint z = trb->Zoffset;
   GLuint i;

   if (rb->DataType == CHAN_TYPE) {
      const GLchan *rgba = (const GLchan *) value;
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            trb->Store(trb->TexImage, x[i], y[i] + trb->Yoffset, z, rgba);
         }
      }
   }
   else if (rb->DataType == GL_UNSIGNED_INT) {
      const GLuint zValue = *((const GLuint *) value);
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            trb->Store(trb->TexImage, x[i], y[i] + trb->Yoffset, z, &zValue);
         }
      }
   }
   else if (rb->DataType == GL_UNSIGNED_SHORT) {
      const GLushort zValue = *((const GLushort *) value);
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            trb->Store(trb->TexImage, x[i], y[i] + trb->Yoffset, z, &zValue);
         }
      }
   }
   else if (rb->DataType == GL_UNSIGNED_INT_24_8_EXT) {
      const GLuint zValue = *((const GLuint *) value);
      const GLfloat flt = (GLfloat) ((zValue >> 8) * (1.0 / 0xffffff));
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            trb->Store(trb->TexImage, x[i], y[i] + trb->Yoffset, z, &flt);
         }
      }
   }
   else if (rb->DataType == GL_UNSIGNED_INT_8_24_REV_MESA) {
      const GLuint zValue = *((const GLuint *) value);
      const GLfloat flt = (GLfloat) ((zValue & 0xffffff) * (1.0 / 0xffffff));
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            trb->Store(trb->TexImage, x[i], y[i] + trb->Yoffset, z, &flt);
         }
      }
   }
   else {
      _mesa_problem(ctx, "invalid rb->DataType in texture_put_mono_values");
   }
}


static void
store_nop(struct gl_texture_image *texImage,
          GLint col, GLint row, GLint img,
          const void *texel)
{
}


static void
delete_texture_wrapper(struct gl_renderbuffer *rb)
{
   ASSERT(rb->RefCount == 0);
   free(rb);
}


/**
 * This function creates a renderbuffer object which wraps a texture image.
 * The new renderbuffer is plugged into the given attachment point.
 * This allows rendering into the texture as if it were a renderbuffer.
 */
static void
wrap_texture(struct gl_context *ctx, struct gl_renderbuffer_attachment *att)
{
   struct texture_renderbuffer *trb;
   const GLuint name = 0;

   ASSERT(att->Type == GL_TEXTURE);
   ASSERT(att->Renderbuffer == NULL);

   trb = CALLOC_STRUCT(texture_renderbuffer);
   if (!trb) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "wrap_texture");
      return;
   }

   /* init base gl_renderbuffer fields */
   _mesa_init_renderbuffer(&trb->Base, name);
   /* plug in our texture_renderbuffer-specific functions */
   trb->Base.Delete = delete_texture_wrapper;
   trb->Base.AllocStorage = NULL; /* illegal! */
   trb->Base.GetRow = texture_get_row;
   trb->Base.GetValues = texture_get_values;
   trb->Base.PutRow = texture_put_row;
   trb->Base.PutRowRGB = texture_put_row_rgb;
   trb->Base.PutMonoRow = texture_put_mono_row;
   trb->Base.PutValues = texture_put_values;
   trb->Base.PutMonoValues = texture_put_mono_values;

   /* update attachment point */
   _mesa_reference_renderbuffer(&att->Renderbuffer, &(trb->Base));
}



/**
 * Update the renderbuffer wrapper for rendering to a texture.
 * For example, update the width, height of the RB based on the texture size,
 * update the internal format info, etc.
 */
static void
update_wrapper(struct gl_context *ctx, const struct gl_renderbuffer_attachment *att)
{
   struct texture_renderbuffer *trb
      = (struct texture_renderbuffer *) att->Renderbuffer;

   (void) ctx;
   ASSERT(trb);

   trb->TexImage = att->Texture->Image[att->CubeMapFace][att->TextureLevel];
   ASSERT(trb->TexImage);

   trb->Store = _mesa_get_texel_store_func(trb->TexImage->TexFormat);
   if (!trb->Store) {
      /* we'll never draw into some textures (compressed formats) */
      trb->Store = store_nop;
   }

   if (att->Texture->Target == GL_TEXTURE_1D_ARRAY_EXT) {
      trb->Yoffset = att->Zoffset;
      trb->Zoffset = 0;
   }
   else {
      trb->Yoffset = 0;
      trb->Zoffset = att->Zoffset;
   }

   trb->Base.Width = trb->TexImage->Width;
   trb->Base.Height = trb->TexImage->Height;
   trb->Base.InternalFormat = trb->TexImage->InternalFormat;
   trb->Base.Format = trb->TexImage->TexFormat;

   /* XXX may need more special cases here */
   switch (trb->TexImage->TexFormat) {
   case MESA_FORMAT_Z24_S8:
      trb->Base.DataType = GL_UNSIGNED_INT_24_8_EXT;
      trb->Base._BaseFormat = GL_DEPTH_STENCIL;
      break;
   case MESA_FORMAT_S8_Z24:
      trb->Base.DataType = GL_UNSIGNED_INT_8_24_REV_MESA;
      trb->Base._BaseFormat = GL_DEPTH_STENCIL;
      break;
   case MESA_FORMAT_Z24_X8:
      trb->Base.DataType = GL_UNSIGNED_INT_24_8_EXT;
      trb->Base._BaseFormat = GL_DEPTH_COMPONENT;
      break;
   case MESA_FORMAT_X8_Z24:
      trb->Base.DataType = GL_UNSIGNED_INT_8_24_REV_MESA;
      trb->Base._BaseFormat = GL_DEPTH_COMPONENT;
      break;
   case MESA_FORMAT_Z16:
      trb->Base.DataType = GL_UNSIGNED_SHORT;
      trb->Base._BaseFormat = GL_DEPTH_COMPONENT;
      break;
   case MESA_FORMAT_Z32:
      trb->Base.DataType = GL_UNSIGNED_INT;
      trb->Base._BaseFormat = GL_DEPTH_COMPONENT;
      break;
   default:
      trb->Base.DataType = CHAN_TYPE;
      trb->Base._BaseFormat = GL_RGBA;
   }
   trb->Base.Data = trb->TexImage->Data;
}



/**
 * Called when rendering to a texture image begins, or when changing
 * the dest mipmap level, cube face, etc.
 * This is a fallback routine for software render-to-texture.
 *
 * Called via the glRenderbufferTexture1D/2D/3D() functions
 * and elsewhere (such as glTexImage2D).
 *
 * The image we're rendering into is
 * att->Texture->Image[att->CubeMapFace][att->TextureLevel];
 * It'll never be NULL.
 *
 * \param fb  the framebuffer object the texture is being bound to
 * \param att  the fb attachment point of the texture
 *
 * \sa _mesa_framebuffer_renderbuffer
 */
void
_mesa_render_texture(struct gl_context *ctx,
                     struct gl_framebuffer *fb,
                     struct gl_renderbuffer_attachment *att)
{
   (void) fb;

   if (!att->Renderbuffer) {
      wrap_texture(ctx, att);
   }
   update_wrapper(ctx, att);
}


void
_mesa_finish_render_texture(struct gl_context *ctx,
                            struct gl_renderbuffer_attachment *att)
{
   /* do nothing */
   /* The renderbuffer texture wrapper will get deleted by the
    * normal mechanism for deleting renderbuffers.
    */
   (void) ctx;
   (void) att;
}
@


1.5
log
@Merge Mesa 7.10.3
@
text
@@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d4 1
d34 1
a34 1
texture_get_row(GLcontext *ctx, struct gl_renderbuffer *rb, GLuint count,
d103 1
a103 1
texture_get_values(GLcontext *ctx, struct gl_renderbuffer *rb, GLuint count,
d170 1
a170 1
texture_put_row(GLcontext *ctx, struct gl_renderbuffer *rb, GLuint count,
d232 1
a232 1
texture_put_row_rgb(GLcontext *ctx, struct gl_renderbuffer *rb, GLuint count,
d292 1
a292 1
texture_put_mono_row(GLcontext *ctx, struct gl_renderbuffer *rb, GLuint count,
d351 1
a351 1
texture_put_values(GLcontext *ctx, struct gl_renderbuffer *rb, GLuint count,
d410 1
a410 1
texture_put_mono_values(GLcontext *ctx, struct gl_renderbuffer *rb,
d489 1
a489 1
wrap_texture(GLcontext *ctx, struct gl_renderbuffer_attachment *att)
d528 1
a528 1
update_wrapper(GLcontext *ctx, const struct gl_renderbuffer_attachment *att)
d612 1
a612 1
_mesa_render_texture(GLcontext *ctx,
d626 1
a626 1
_mesa_finish_render_texture(GLcontext *ctx,
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d3 2
a4 2
#include "fbobject.h"
#include "texformat.h"
d49 3
a51 1
         trb->TexImage->FetchTexelc(trb->TexImage, x + i, y, z, rgbaOut + 4 * i);
d87 8
d113 4
a116 2
         trb->TexImage->FetchTexelc(trb->TexImage, x[i], y[i] + trb->Yoffset,
				    z, rgbaOut + 4 * i);
d150 9
d213 9
d275 9
d334 9
d393 9
d451 9
d467 8
d478 1
a478 1
   _mesa_free(rb);
d538 5
a542 2
   trb->Store = trb->TexImage->TexFormat->StoreTexel;
   ASSERT(trb->Store);
d556 2
d559 2
a560 2
   if (trb->TexImage->TexFormat->MesaFormat == MESA_FORMAT_Z24_S8) {
      trb->Base._ActualFormat = GL_DEPTH24_STENCIL8_EXT;
d562 15
a576 3
   }
   else if (trb->TexImage->TexFormat->MesaFormat == MESA_FORMAT_Z16) {
      trb->Base._ActualFormat = GL_DEPTH_COMPONENT;
d578 3
a580 3
   }
   else if (trb->TexImage->TexFormat->MesaFormat == MESA_FORMAT_Z32) {
      trb->Base._ActualFormat = GL_DEPTH_COMPONENT;
d582 3
a584 3
   }
   else {
      trb->Base._ActualFormat = trb->TexImage->InternalFormat;
d586 1
a587 7
   trb->Base._BaseFormat = trb->TexImage->TexFormat->BaseFormat;
#if 0
   /* fix/avoid this assertion someday */
   ASSERT(trb->Base._BaseFormat == GL_RGB ||
          trb->Base._BaseFormat == GL_RGBA ||
          trb->Base._BaseFormat == GL_DEPTH_COMPONENT);
#endif
a588 6

   trb->Base.RedBits = trb->TexImage->TexFormat->RedBits;
   trb->Base.GreenBits = trb->TexImage->TexFormat->GreenBits;
   trb->Base.BlueBits = trb->TexImage->TexFormat->BlueBits;
   trb->Base.AlphaBits = trb->TexImage->TexFormat->AlphaBits;
   trb->Base.DepthBits = trb->TexImage->TexFormat->DepthBits;
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d52 8
d107 9
d167 8
d187 54
a240 1
            GLfloat flt = (zValues[i] >> 8) * (1.0 / 0xffffff);
d270 8
d288 1
a288 1
      const GLfloat flt = (zValue >> 8) * (1.0 / 0xffffff);
d320 8
d332 1
a332 2
            trb->Store(trb->TexImage, x[i], y[i] + trb->Yoffset, z,
		       zValues + i);
d340 1
a340 1
            GLfloat flt = (zValues[i] >> 8) * (1.0 / 0xffffff);
d377 8
d387 1
a387 1
      const GLfloat flt = (zValue >> 8) * (1.0 / 0xffffff);
d436 1
@


1.1
log
@Initial revision
@
text
@d19 1
a19 1
   struct gl_renderbuffer Base;   /* Base class object */
d22 4
a25 1
   GLint Zoffset;
d44 2
d95 2
a96 2
         trb->TexImage->FetchTexelc(trb->TexImage, x[i], y[i], z,
                                    rgbaOut + 4 * i);
d103 2
a104 1
         trb->TexImage->FetchTexelf(trb->TexImage, x[i], y[i], z, &flt);
d116 2
a117 1
         trb->TexImage->FetchTexelf(trb->TexImage, x[i], y[i], z, &flt);
d139 2
d182 2
d229 1
a229 1
            trb->Store(trb->TexImage, x[i], y[i], z, rgba);
d238 2
a239 1
            trb->Store(trb->TexImage, x[i], y[i], z, zValues + i);
d248 1
a248 1
            trb->Store(trb->TexImage, x[i], y[i], z, &flt);
d272 1
a272 1
            trb->Store(trb->TexImage, x[i], y[i], z, rgba);
d280 1
a280 1
            trb->Store(trb->TexImage, x[i], y[i], z, &zValue);
d289 1
a289 1
            trb->Store(trb->TexImage, x[i], y[i], z, &flt);
d340 1
a340 1
   att->Renderbuffer = &(trb->Base);
d365 8
a372 1
   trb->Zoffset = att->Zoffset;
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@Mesa 7.0.1
@
text
@d328 1
a328 1
   _mesa_reference_renderbuffer(&att->Renderbuffer, &(trb->Base));
@


1.1.1.3
log
@Import Mesa 7.10.3
@
text
@d3 2
a4 3
#include "colormac.h"
#include "macros.h"
#include "texfetch.h"
d19 1
a19 1
   struct gl_renderbuffer Base;   /**< Base class object */
d22 1
a22 4
   GLint Yoffset;                 /**< Layer for 1D array textures. */
   GLint Zoffset;                 /**< Layer for 2D array textures, or slice
				   * for 3D textures
				   */
d30 1
a30 1
texture_get_row(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
a40 2
   y += trb->Yoffset;

d44 1
a44 11
         GLfloat rgba[4];
         trb->TexImage->FetchTexelf(trb->TexImage, x + i, y, z, rgba);
         UNCLAMPED_FLOAT_TO_RGBA_CHAN(rgbaOut + 4 * i, rgba);
      }
   }
   else if (rb->DataType == GL_UNSIGNED_SHORT) {
      GLushort *zValues = (GLushort *) values;
      for (i = 0; i < count; i++) {
         GLfloat flt;
         trb->TexImage->FetchTexelf(trb->TexImage, x + i, y, z, &flt);
         zValues[i] = (GLushort) (flt * 0xffff);
a71 8
   else if (rb->DataType == GL_UNSIGNED_INT_8_24_REV_MESA) {
      GLuint *zValues = (GLuint *) values;
      for (i = 0; i < count; i++) {
         GLfloat flt;
         trb->TexImage->FetchTexelf(trb->TexImage, x + i, y, z, &flt);
         zValues[i] = (GLuint) (flt * 0xffffff);
      }
   }
d79 1
a79 1
texture_get_values(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
d90 2
a91 13
         GLfloat rgba[4];
         trb->TexImage->FetchTexelf(trb->TexImage, x[i], y[i] + trb->Yoffset,
				    z, rgba);
         UNCLAMPED_FLOAT_TO_RGBA_CHAN(rgbaOut + 4 * i, rgba);
      }
   }
   else if (rb->DataType == GL_UNSIGNED_SHORT) {
      GLushort *zValues = (GLushort *) values;
      for (i = 0; i < count; i++) {
         GLfloat flt;
         trb->TexImage->FetchTexelf(trb->TexImage, x[i], y[i] + trb->Yoffset,
				    z, &flt);
         zValues[i] = (GLushort) (flt * 0xffff);
d98 1
a98 2
         trb->TexImage->FetchTexelf(trb->TexImage, x[i], y[i] + trb->Yoffset,
				    z, &flt);
d110 1
a110 2
         trb->TexImage->FetchTexelf(trb->TexImage, x[i], y[i] + trb->Yoffset,
				    z, &flt);
a113 9
   else if (rb->DataType == GL_UNSIGNED_INT_8_24_REV_MESA) {
      GLuint *zValues = (GLuint *) values;
      for (i = 0; i < count; i++) {
         GLfloat flt;
         trb->TexImage->FetchTexelf(trb->TexImage, x[i], y[i] + trb->Yoffset,
				    z, &flt);
         zValues[i] = (GLuint) (flt * 0xffffff);
      }
   }
d124 1
a124 1
texture_put_row(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
a131 2
   y += trb->Yoffset;

a140 70
   else if (rb->DataType == GL_UNSIGNED_SHORT) {
      const GLushort *zValues = (const GLushort *) values;
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            trb->Store(trb->TexImage, x + i, y, z, zValues + i);
         }
      }
   }
   else if (rb->DataType == GL_UNSIGNED_INT) {
      const GLuint *zValues = (const GLuint *) values;
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            trb->Store(trb->TexImage, x + i, y, z, zValues + i);
         }
      }
   }
   else if (rb->DataType == GL_UNSIGNED_INT_24_8_EXT) {
      const GLuint *zValues = (const GLuint *) values;
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            GLfloat flt = (GLfloat) ((zValues[i] >> 8) * (1.0 / 0xffffff));
            trb->Store(trb->TexImage, x + i, y, z, &flt);
         }
      }
   }
   else if (rb->DataType == GL_UNSIGNED_INT_8_24_REV_MESA) {
      const GLuint *zValues = (const GLuint *) values;
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            GLfloat flt = (GLfloat) ((zValues[i] & 0xffffff) * (1.0 / 0xffffff));
            trb->Store(trb->TexImage, x + i, y, z, &flt);
         }
      }
   }
   else {
      _mesa_problem(ctx, "invalid rb->DataType in texture_put_row");
   }
}

/**
 * Put row of RGB values into a renderbuffer that wraps a texture image.
 */
static void
texture_put_row_rgb(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
                GLint x, GLint y, const void *values, const GLubyte *mask)
{
   const struct texture_renderbuffer *trb
      = (const struct texture_renderbuffer *) rb;
   const GLint z = trb->Zoffset;
   GLuint i;

   y += trb->Yoffset;

   if (rb->DataType == CHAN_TYPE) {
      const GLchan *rgb = (const GLchan *) values;
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            trb->Store(trb->TexImage, x + i, y, z, rgb);
         }
         rgb += 3;
      }
   }
   else if (rb->DataType == GL_UNSIGNED_SHORT) {
      const GLushort *zValues = (const GLushort *) values;
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            trb->Store(trb->TexImage, x + i, y, z, zValues + i);
         }
      }
   }
d153 1
a153 10
            GLfloat flt = (GLfloat) ((zValues[i] >> 8) * (1.0 / 0xffffff));
            trb->Store(trb->TexImage, x + i, y, z, &flt);
         }
      }
   }
   else if (rb->DataType == GL_UNSIGNED_INT_8_24_REV_MESA) {
      const GLuint *zValues = (const GLuint *) values;
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            GLfloat flt = (GLfloat) ((zValues[i] & 0xffffff) * (1.0 / 0xffffff));
d165 1
a165 1
texture_put_mono_row(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
a172 2
   y += trb->Yoffset;

a180 8
   else if (rb->DataType == GL_UNSIGNED_SHORT) {
      const GLushort zValue = *((const GLushort *) value);
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            trb->Store(trb->TexImage, x + i, y, z, &zValue);
         }
      }
   }
d191 1
a191 10
      const GLfloat flt = (GLfloat) ((zValue >> 8) * (1.0 / 0xffffff));
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            trb->Store(trb->TexImage, x + i, y, z, &flt);
         }
      }
   }
   else if (rb->DataType == GL_UNSIGNED_INT_8_24_REV_MESA) {
      const GLuint zValue = *((const GLuint *) value);
      const GLfloat flt = (GLfloat) ((zValue & 0xffffff) * (1.0 / 0xffffff));
d205 1
a205 1
texture_put_values(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
d218 1
a218 1
            trb->Store(trb->TexImage, x[i], y[i] + trb->Yoffset, z, rgba);
a222 8
   else if (rb->DataType == GL_UNSIGNED_SHORT) {
      const GLushort *zValues = (const GLushort *) values;
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            trb->Store(trb->TexImage, x[i], y[i] + trb->Yoffset, z, zValues + i);
         }
      }
   }
d227 1
a227 1
            trb->Store(trb->TexImage, x[i], y[i] + trb->Yoffset, z, zValues + i);
d235 2
a236 11
            GLfloat flt = (GLfloat) ((zValues[i] >> 8) * (1.0 / 0xffffff));
            trb->Store(trb->TexImage, x[i], y[i] + trb->Yoffset, z, &flt);
         }
      }
   }
   else if (rb->DataType == GL_UNSIGNED_INT_8_24_REV_MESA) {
      const GLuint *zValues = (const GLuint *) values;
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            GLfloat flt = (GLfloat) ((zValues[i] & 0xffffff) * (1.0 / 0xffffff));
            trb->Store(trb->TexImage, x[i], y[i] + trb->Yoffset, z, &flt);
d247 1
a247 1
texture_put_mono_values(struct gl_context *ctx, struct gl_renderbuffer *rb,
d260 1
a260 1
            trb->Store(trb->TexImage, x[i], y[i] + trb->Yoffset, z, rgba);
d268 1
a268 9
            trb->Store(trb->TexImage, x[i], y[i] + trb->Yoffset, z, &zValue);
         }
      }
   }
   else if (rb->DataType == GL_UNSIGNED_SHORT) {
      const GLushort zValue = *((const GLushort *) value);
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            trb->Store(trb->TexImage, x[i], y[i] + trb->Yoffset, z, &zValue);
d274 1
a274 1
      const GLfloat flt = (GLfloat) ((zValue >> 8) * (1.0 / 0xffffff));
d277 1
a277 10
            trb->Store(trb->TexImage, x[i], y[i] + trb->Yoffset, z, &flt);
         }
      }
   }
   else if (rb->DataType == GL_UNSIGNED_INT_8_24_REV_MESA) {
      const GLuint zValue = *((const GLuint *) value);
      const GLfloat flt = (GLfloat) ((zValue & 0xffffff) * (1.0 / 0xffffff));
      for (i = 0; i < count; i++) {
         if (!mask || mask[i]) {
            trb->Store(trb->TexImage, x[i], y[i] + trb->Yoffset, z, &flt);
a287 8
store_nop(struct gl_texture_image *texImage,
          GLint col, GLint row, GLint img,
          const void *texel)
{
}


static void
d291 1
a291 1
   free(rb);
d301 1
a301 1
wrap_texture(struct gl_context *ctx, struct gl_renderbuffer_attachment *att)
a322 1
   trb->Base.PutRowRGB = texture_put_row_rgb;
d339 1
a339 1
update_wrapper(struct gl_context *ctx, const struct gl_renderbuffer_attachment *att)
d350 2
a351 5
   trb->Store = _mesa_get_texel_store_func(trb->TexImage->TexFormat);
   if (!trb->Store) {
      /* we'll never draw into some textures (compressed formats) */
      trb->Store = store_nop;
   }
d353 1
a353 8
   if (att->Texture->Target == GL_TEXTURE_1D_ARRAY_EXT) {
      trb->Yoffset = att->Zoffset;
      trb->Zoffset = 0;
   }
   else {
      trb->Yoffset = 0;
      trb->Zoffset = att->Zoffset;
   }
a357 2
   trb->Base.Format = trb->TexImage->TexFormat;

d359 2
a360 2
   switch (trb->TexImage->TexFormat) {
   case MESA_FORMAT_Z24_S8:
d362 3
a364 15
      trb->Base._BaseFormat = GL_DEPTH_STENCIL;
      break;
   case MESA_FORMAT_S8_Z24:
      trb->Base.DataType = GL_UNSIGNED_INT_8_24_REV_MESA;
      trb->Base._BaseFormat = GL_DEPTH_STENCIL;
      break;
   case MESA_FORMAT_Z24_X8:
      trb->Base.DataType = GL_UNSIGNED_INT_24_8_EXT;
      trb->Base._BaseFormat = GL_DEPTH_COMPONENT;
      break;
   case MESA_FORMAT_X8_Z24:
      trb->Base.DataType = GL_UNSIGNED_INT_8_24_REV_MESA;
      trb->Base._BaseFormat = GL_DEPTH_COMPONENT;
      break;
   case MESA_FORMAT_Z16:
d366 3
a368 3
      trb->Base._BaseFormat = GL_DEPTH_COMPONENT;
      break;
   case MESA_FORMAT_Z32:
d370 3
a372 3
      trb->Base._BaseFormat = GL_DEPTH_COMPONENT;
      break;
   default:
a373 1
      trb->Base._BaseFormat = GL_RGBA;
d375 7
d383 6
d411 1
a411 1
_mesa_render_texture(struct gl_context *ctx,
d425 1
a425 1
_mesa_finish_render_texture(struct gl_context *ctx,
@


