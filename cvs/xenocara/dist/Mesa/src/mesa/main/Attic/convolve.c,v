head	1.9;
access;
symbols
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	v10_2_9:1.1.1.7
	v10_4_3:1.1.1.6
	v10_2_7:1.1.1.5
	OPENBSD_5_6:1.6.0.2
	OPENBSD_5_6_BASE:1.6
	v10_2_3:1.1.1.5
	OPENBSD_5_5:1.5.0.2
	OPENBSD_5_5_BASE:1.5
	v9_2_5:1.1.1.4
	v9_2_3:1.1.1.4
	v9_2_2:1.1.1.4
	v9_2_1:1.1.1.4
	v9_2_0:1.1.1.4
	OPENBSD_5_4:1.4.0.4
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.2
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.3.0.4
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.2
	v7_10_3:1.1.1.3
	OPENBSD_5_0:1.2.0.6
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.1.2.0.12
	OPENBSD_4_7_BASE:1.1.1.2
	OPENBSD_4_6:1.1.1.2.0.10
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.8
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.6
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.4
	v7_0_1:1.1.1.2
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2015.12.23.05.17.52;	author jsg;	state dead;
branches;
next	1.8;
commitid	TnlogFl9nOv2eaRf;

1.8
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.7;
commitid	4ry2gvZGMXkCUD2n;

1.7
date	2015.01.25.14.41.21;	author jsg;	state Exp;
branches;
next	1.6;
commitid	mcxB0JvoI9gTDYXU;

1.6
date	2014.07.09.21.09.00;	author jsg;	state Exp;
branches;
next	1.5;
commitid	WPD6rgPryPkvXOr9;

1.5
date	2013.09.05.14.06.17;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2012.08.17.13.58.17;	author mpi;	state Exp;
branches;
next	1.3;

1.3
date	2011.10.23.13.37.42;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.05.22.20.06.30;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.49.49;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.49.49;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.56.33;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.10.23.13.29.45;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.09.05.13.16.26;	author jsg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2014.07.09.20.34.59;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.6
date	2015.01.25.14.12.30;	author jsg;	state Exp;
branches;
next	1.1.1.7;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.7
date	2015.02.20.22.49.36;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.9
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */


/*
 * Image convolution functions.
 *
 * Notes: filter kernel elements are indexed by <n> and <m> as in
 * the GL spec.
 */


#include "glheader.h"
#include "bufferobj.h"
#include "colormac.h"
#include "convolve.h"
#include "macros.h"
#include "mtypes.h"
#include "main/dispatch.h"


void GLAPIENTRY
_mesa_ConvolutionFilter1D(GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const GLvoid *image)
{
   GET_CURRENT_CONTEXT(ctx);

   _mesa_error(ctx, GL_INVALID_OPERATION, "glConvolutionFilter1D");
}

void GLAPIENTRY
_mesa_ConvolutionFilter2D(GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image)
{
   GET_CURRENT_CONTEXT(ctx);

   _mesa_error(ctx, GL_INVALID_OPERATION, "glConvolutionFilter2D");
}


void GLAPIENTRY
_mesa_ConvolutionParameterf(GLenum target, GLenum pname, GLfloat param)
{
   GET_CURRENT_CONTEXT(ctx);

   _mesa_error(ctx, GL_INVALID_OPERATION, "glConvolutionParameterf");
}


void GLAPIENTRY
_mesa_ConvolutionParameterfv(GLenum target, GLenum pname, const GLfloat *params)
{
   GET_CURRENT_CONTEXT(ctx);

   _mesa_error(ctx, GL_INVALID_OPERATION, "glConvolutionParameterfv");
}


void GLAPIENTRY
_mesa_ConvolutionParameteri(GLenum target, GLenum pname, GLint param)
{
   GET_CURRENT_CONTEXT(ctx);

   _mesa_error(ctx, GL_INVALID_OPERATION, "glConvolutionParameteri");
}


void GLAPIENTRY
_mesa_ConvolutionParameteriv(GLenum target, GLenum pname, const GLint *params)
{
   GET_CURRENT_CONTEXT(ctx);

   _mesa_error(ctx, GL_INVALID_OPERATION, "glConvolutionParameteriv");
}


void GLAPIENTRY
_mesa_CopyConvolutionFilter1D(GLenum target, GLenum internalFormat, GLint x, GLint y, GLsizei width)
{
   GET_CURRENT_CONTEXT(ctx);

   _mesa_error(ctx, GL_INVALID_OPERATION, "glCopyConvolutionFilter1D");
}


void GLAPIENTRY
_mesa_CopyConvolutionFilter2D(GLenum target, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLsizei height)
{
   GET_CURRENT_CONTEXT(ctx);

   _mesa_error(ctx, GL_INVALID_OPERATION, "glCopyConvolutionFilter2D");
}


void GLAPIENTRY
_mesa_GetnConvolutionFilterARB(GLenum target, GLenum format, GLenum type,
                               GLsizei bufSize, GLvoid *image)
{
   GET_CURRENT_CONTEXT(ctx);

   _mesa_error(ctx, GL_INVALID_OPERATION, "glGetConvolutionFilter");
}


void GLAPIENTRY
_mesa_GetConvolutionFilter(GLenum target, GLenum format, GLenum type,
                           GLvoid *image)
{
   _mesa_GetnConvolutionFilterARB(target, format, type, INT_MAX, image);
}


void GLAPIENTRY
_mesa_GetConvolutionParameterfv(GLenum target, GLenum pname, GLfloat *params)
{
   GET_CURRENT_CONTEXT(ctx);

   _mesa_error(ctx, GL_INVALID_OPERATION, "glGetConvolutionParameterfv");
}


void GLAPIENTRY
_mesa_GetConvolutionParameteriv(GLenum target, GLenum pname, GLint *params)
{
   GET_CURRENT_CONTEXT(ctx);

   _mesa_error(ctx, GL_INVALID_OPERATION, "glGetConvolutionParameteriv");
}


void GLAPIENTRY
_mesa_GetnSeparableFilterARB(GLenum target, GLenum format, GLenum type,
                             GLsizei rowBufSize, GLvoid *row,
                             GLsizei columnBufSize,  GLvoid *column,
                             GLvoid *span)
{
   GET_CURRENT_CONTEXT(ctx);

   _mesa_error(ctx, GL_INVALID_OPERATION, "glGetSeparableFilter");
}


void GLAPIENTRY
_mesa_GetSeparableFilter(GLenum target, GLenum format, GLenum type,
                         GLvoid *row, GLvoid *column, GLvoid *span)
{
   _mesa_GetnSeparableFilterARB(target, format, type, INT_MAX, row,
                                INT_MAX, column, span);
}


void GLAPIENTRY
_mesa_SeparableFilter2D(GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column)
{
   GET_CURRENT_CONTEXT(ctx);

   _mesa_error(ctx, GL_INVALID_OPERATION, "glSeparableFilter2D");
}
@


1.8
log
@Merge Mesa 10.2.9
@
text
@@


1.7
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d35 2
a36 1
#include "context.h"
d38 2
@


1.6
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d35 1
a35 2
#include "bufferobj.h"
#include "colormac.h"
a36 2
#include "macros.h"
#include "mtypes.h"
@


1.5
log
@Merge Mesa 9.2.0
@
text
@d48 1
a48 1
   _mesa_error(ctx, GL_INVALID_ENUM, "glConvolutionFilter1D");
d56 1
a56 1
   _mesa_error(ctx, GL_INVALID_ENUM, "glConvolutionFilter2D");
d65 1
a65 1
   _mesa_error(ctx, GL_INVALID_ENUM, "glConvolutionParameterf");
d74 1
a74 1
   _mesa_error(ctx, GL_INVALID_ENUM, "glConvolutionParameterfv");
d83 1
a83 1
   _mesa_error(ctx, GL_INVALID_ENUM, "glConvolutionParameteri");
d92 1
a92 1
   _mesa_error(ctx, GL_INVALID_ENUM, "glConvolutionParameteriv");
d101 1
a101 1
   _mesa_error(ctx, GL_INVALID_ENUM, "glCopyConvolutionFilter1D");
d110 1
a110 1
   _mesa_error(ctx, GL_INVALID_ENUM, "glCopyConvolutionFilter2D");
d137 1
a137 1
   _mesa_error(ctx, GL_INVALID_ENUM, "glGetConvolutionParameterfv");
d146 1
a146 1
   _mesa_error(ctx, GL_INVALID_ENUM, "glGetConvolutionParameteriv");
d158 1
a158 1
   _mesa_error(ctx, GL_INVALID_ENUM, "glGetSeparableFilter");
d176 1
a176 1
   _mesa_error(ctx, GL_INVALID_ENUM, "glSeparableFilter2D");
@


1.4
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a2 1
 * Version:  6.5.2
d19 4
a22 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
a38 1
#include "mfeatures.h"
d43 1
a43 3
#if FEATURE_convolve

static void GLAPIENTRY
d51 1
a51 1
static void GLAPIENTRY
d60 1
a60 1
static void GLAPIENTRY
d69 1
a69 1
static void GLAPIENTRY
d78 1
a78 1
static void GLAPIENTRY
d87 1
a87 1
static void GLAPIENTRY
d96 1
a96 1
static void GLAPIENTRY
d105 1
a105 1
static void GLAPIENTRY
d114 1
a114 1
static void GLAPIENTRY
d124 1
a124 1
static void GLAPIENTRY
d132 1
a132 1
static void GLAPIENTRY
d141 1
a141 1
static void GLAPIENTRY
d150 1
a150 1
static void GLAPIENTRY
d162 1
a162 1
static void GLAPIENTRY
d171 1
a171 1
static void GLAPIENTRY
a177 25

void
_mesa_init_convolve_dispatch(struct _glapi_table *disp)
{
   SET_ConvolutionFilter1D(disp, _mesa_ConvolutionFilter1D);
   SET_ConvolutionFilter2D(disp, _mesa_ConvolutionFilter2D);
   SET_ConvolutionParameterf(disp, _mesa_ConvolutionParameterf);
   SET_ConvolutionParameterfv(disp, _mesa_ConvolutionParameterfv);
   SET_ConvolutionParameteri(disp, _mesa_ConvolutionParameteri);
   SET_ConvolutionParameteriv(disp, _mesa_ConvolutionParameteriv);
   SET_CopyConvolutionFilter1D(disp, _mesa_CopyConvolutionFilter1D);
   SET_CopyConvolutionFilter2D(disp, _mesa_CopyConvolutionFilter2D);
   SET_GetConvolutionFilter(disp, _mesa_GetConvolutionFilter);
   SET_GetConvolutionParameterfv(disp, _mesa_GetConvolutionParameterfv);
   SET_GetConvolutionParameteriv(disp, _mesa_GetConvolutionParameteriv);
   SET_SeparableFilter2D(disp, _mesa_SeparableFilter2D);
   SET_GetSeparableFilter(disp, _mesa_GetSeparableFilter);

   /* GL_ARB_robustness */
   SET_GetnConvolutionFilterARB(disp, _mesa_GetnConvolutionFilterARB);
   SET_GetnSeparableFilterARB(disp, _mesa_GetnSeparableFilterARB);
}


#endif /* FEATURE_convolve */
@


1.3
log
@Merge Mesa 7.10.3
@
text
@d39 1
d118 2
a119 2
_mesa_GetConvolutionFilter(GLenum target, GLenum format, GLenum type,
                           GLvoid *image)
d128 8
d154 4
a157 2
_mesa_GetSeparableFilter(GLenum target, GLenum format, GLenum type,
                         GLvoid *row, GLvoid *column, GLvoid *span)
d166 9
d198 4
@


1.2
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d38 1
a38 2
#include "context.h"
#include "image.h"
a39 1
#include "state.h"
d45 1
a45 62

/*
 * Given an internalFormat token passed to glConvolutionFilter
 * or glSeparableFilter, return the corresponding base format.
 * Return -1 if invalid token.
 */
static GLint
base_filter_format( GLenum format )
{
   switch (format) {
      case GL_ALPHA:
      case GL_ALPHA4:
      case GL_ALPHA8:
      case GL_ALPHA12:
      case GL_ALPHA16:
         return GL_ALPHA;
      case GL_LUMINANCE:
      case GL_LUMINANCE4:
      case GL_LUMINANCE8:
      case GL_LUMINANCE12:
      case GL_LUMINANCE16:
         return GL_LUMINANCE;
      case GL_LUMINANCE_ALPHA:
      case GL_LUMINANCE4_ALPHA4:
      case GL_LUMINANCE6_ALPHA2:
      case GL_LUMINANCE8_ALPHA8:
      case GL_LUMINANCE12_ALPHA4:
      case GL_LUMINANCE12_ALPHA12:
      case GL_LUMINANCE16_ALPHA16:
         return GL_LUMINANCE_ALPHA;
      case GL_INTENSITY:
      case GL_INTENSITY4:
      case GL_INTENSITY8:
      case GL_INTENSITY12:
      case GL_INTENSITY16:
         return GL_INTENSITY;
      case GL_RGB:
      case GL_R3_G3_B2:
      case GL_RGB4:
      case GL_RGB5:
      case GL_RGB8:
      case GL_RGB10:
      case GL_RGB12:
      case GL_RGB16:
         return GL_RGB;
      case 4:
      case GL_RGBA:
      case GL_RGBA2:
      case GL_RGBA4:
      case GL_RGB5_A1:
      case GL_RGBA8:
      case GL_RGB10_A2:
      case GL_RGBA12:
      case GL_RGBA16:
         return GL_RGBA;
      default:
         return -1;  /* error */
   }
}


void GLAPIENTRY
a47 1
   GLint baseFormat;
a48 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d50 1
a50 61
   if (target != GL_CONVOLUTION_1D) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glConvolutionFilter1D(target)");
      return;
   }

   baseFormat = base_filter_format(internalFormat);
   if (baseFormat < 0 || baseFormat == GL_COLOR_INDEX) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glConvolutionFilter1D(internalFormat)");
      return;
   }

   if (width < 0 || width > MAX_CONVOLUTION_WIDTH) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glConvolutionFilter1D(width)");
      return;
   }

   if (!_mesa_is_legal_format_and_type(ctx, format, type)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glConvolutionFilter1D(format or type)");
      return;
   }

   if (format == GL_COLOR_INDEX ||
       format == GL_STENCIL_INDEX ||
       format == GL_DEPTH_COMPONENT ||
       format == GL_INTENSITY ||
       type == GL_BITMAP) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glConvolutionFilter1D(format or type)");
      return;
   }

   ctx->Convolution1D.Format = format;
   ctx->Convolution1D.InternalFormat = internalFormat;
   ctx->Convolution1D.Width = width;
   ctx->Convolution1D.Height = 1;

   image = _mesa_map_validate_pbo_source(ctx, 
                                        1, &ctx->Unpack, width, 1, 1,
                                        format, type, image,
                                        "glConvolutionFilter1D");
   if (!image)
      return;

   _mesa_unpack_color_span_float(ctx, width, GL_RGBA,
                                 ctx->Convolution1D.Filter,
                                 format, type, image, &ctx->Unpack,
                                 0); /* transferOps */

   _mesa_unmap_pbo_source(ctx, &ctx->Unpack);

   _mesa_scale_and_bias_rgba(width,
                             (GLfloat (*)[4]) ctx->Convolution1D.Filter,
                             ctx->Pixel.ConvolutionFilterScale[0][0],
                             ctx->Pixel.ConvolutionFilterScale[0][1],
                             ctx->Pixel.ConvolutionFilterScale[0][2],
                             ctx->Pixel.ConvolutionFilterScale[0][3],
                             ctx->Pixel.ConvolutionFilterBias[0][0],
                             ctx->Pixel.ConvolutionFilterBias[0][1],
                             ctx->Pixel.ConvolutionFilterBias[0][2],
                             ctx->Pixel.ConvolutionFilterBias[0][3]);

   ctx->NewState |= _NEW_PIXEL;
d53 1
a53 2

void GLAPIENTRY
a55 2
   GLint baseFormat;
   GLint i;
a56 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d58 1
a58 72
   if (target != GL_CONVOLUTION_2D) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glConvolutionFilter2D(target)");
      return;
   }

   baseFormat = base_filter_format(internalFormat);
   if (baseFormat < 0 || baseFormat == GL_COLOR_INDEX) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glConvolutionFilter2D(internalFormat)");
      return;
   }

   if (width < 0 || width > MAX_CONVOLUTION_WIDTH) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glConvolutionFilter2D(width)");
      return;
   }
   if (height < 0 || height > MAX_CONVOLUTION_HEIGHT) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glConvolutionFilter2D(height)");
      return;
   }

   if (!_mesa_is_legal_format_and_type(ctx, format, type)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glConvolutionFilter2D(format or type)");
      return;
   }
   if (format == GL_COLOR_INDEX ||
       format == GL_STENCIL_INDEX ||
       format == GL_DEPTH_COMPONENT ||
       format == GL_INTENSITY ||
       type == GL_BITMAP) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glConvolutionFilter2D(format or type)");
      return;
   }

   /* this should have been caught earlier */
   assert(_mesa_components_in_format(format));

   ctx->Convolution2D.Format = format;
   ctx->Convolution2D.InternalFormat = internalFormat;
   ctx->Convolution2D.Width = width;
   ctx->Convolution2D.Height = height;

   image = _mesa_map_validate_pbo_source(ctx, 
                                         2, &ctx->Unpack, width, height, 1,
                                         format, type, image,
                                         "glConvolutionFilter2D");
   if (!image)
      return;

   /* Unpack filter image.  We always store filters in RGBA format. */
   for (i = 0; i < height; i++) {
      const GLvoid *src = _mesa_image_address2d(&ctx->Unpack, image, width,
                                                height, format, type, i, 0);
      GLfloat *dst = ctx->Convolution2D.Filter + i * width * 4;
      _mesa_unpack_color_span_float(ctx, width, GL_RGBA, dst,
                                    format, type, src, &ctx->Unpack,
                                    0); /* transferOps */
   }

   _mesa_unmap_pbo_source(ctx, &ctx->Unpack);

   _mesa_scale_and_bias_rgba(width * height,
                             (GLfloat (*)[4]) ctx->Convolution2D.Filter,
                             ctx->Pixel.ConvolutionFilterScale[1][0],
                             ctx->Pixel.ConvolutionFilterScale[1][1],
                             ctx->Pixel.ConvolutionFilterScale[1][2],
                             ctx->Pixel.ConvolutionFilterScale[1][3],
                             ctx->Pixel.ConvolutionFilterBias[1][0],
                             ctx->Pixel.ConvolutionFilterBias[1][1],
                             ctx->Pixel.ConvolutionFilterBias[1][2],
                             ctx->Pixel.ConvolutionFilterBias[1][3]);

   ctx->NewState |= _NEW_PIXEL;
a65 34
   GLuint c;
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

   switch (target) {
      case GL_CONVOLUTION_1D:
         c = 0;
         break;
      case GL_CONVOLUTION_2D:
         c = 1;
         break;
      case GL_SEPARABLE_2D:
         c = 2;
         break;
      default:
         _mesa_error(ctx, GL_INVALID_ENUM, "glConvolutionParameterf(target)");
         return;
   }

   switch (pname) {
      case GL_CONVOLUTION_BORDER_MODE:
         if (param == (GLfloat) GL_REDUCE ||
             param == (GLfloat) GL_CONSTANT_BORDER ||
             param == (GLfloat) GL_REPLICATE_BORDER) {
            ctx->Pixel.ConvolutionBorderMode[c] = (GLenum) param;
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM, "glConvolutionParameterf(params)");
            return;
         }
         break;
      default:
         _mesa_error(ctx, GL_INVALID_ENUM, "glConvolutionParameterf(pname)");
         return;
   }
d67 1
a67 1
   ctx->NewState |= _NEW_PIXEL;
a74 2
   GLuint c;
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d76 1
a76 42
   switch (target) {
      case GL_CONVOLUTION_1D:
         c = 0;
         break;
      case GL_CONVOLUTION_2D:
         c = 1;
         break;
      case GL_SEPARABLE_2D:
         c = 2;
         break;
      default:
         _mesa_error(ctx, GL_INVALID_ENUM, "glConvolutionParameterfv(target)");
         return;
   }

   switch (pname) {
      case GL_CONVOLUTION_BORDER_COLOR:
         COPY_4V(ctx->Pixel.ConvolutionBorderColor[c], params);
         break;
      case GL_CONVOLUTION_BORDER_MODE:
         if (params[0] == (GLfloat) GL_REDUCE ||
             params[0] == (GLfloat) GL_CONSTANT_BORDER ||
             params[0] == (GLfloat) GL_REPLICATE_BORDER) {
            ctx->Pixel.ConvolutionBorderMode[c] = (GLenum) params[0];
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM, "glConvolutionParameterfv(params)");
            return;
         }
         break;
      case GL_CONVOLUTION_FILTER_SCALE:
         COPY_4V(ctx->Pixel.ConvolutionFilterScale[c], params);
         break;
      case GL_CONVOLUTION_FILTER_BIAS:
         COPY_4V(ctx->Pixel.ConvolutionFilterBias[c], params);
         break;
      default:
         _mesa_error(ctx, GL_INVALID_ENUM, "glConvolutionParameterfv(pname)");
         return;
   }

   ctx->NewState |= _NEW_PIXEL;
a83 34
   GLuint c;
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

   switch (target) {
      case GL_CONVOLUTION_1D:
         c = 0;
         break;
      case GL_CONVOLUTION_2D:
         c = 1;
         break;
      case GL_SEPARABLE_2D:
         c = 2;
         break;
      default:
         _mesa_error(ctx, GL_INVALID_ENUM, "glConvolutionParameteri(target)");
         return;
   }

   switch (pname) {
      case GL_CONVOLUTION_BORDER_MODE:
         if (param == (GLint) GL_REDUCE ||
             param == (GLint) GL_CONSTANT_BORDER ||
             param == (GLint) GL_REPLICATE_BORDER) {
            ctx->Pixel.ConvolutionBorderMode[c] = (GLenum) param;
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM, "glConvolutionParameteri(params)");
            return;
         }
         break;
      default:
         _mesa_error(ctx, GL_INVALID_ENUM, "glConvolutionParameteri(pname)");
         return;
   }
d85 1
a85 1
   ctx->NewState |= _NEW_PIXEL;
a92 56
   GLuint c;
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

   switch (target) {
      case GL_CONVOLUTION_1D:
         c = 0;
         break;
      case GL_CONVOLUTION_2D:
         c = 1;
         break;
      case GL_SEPARABLE_2D:
         c = 2;
         break;
      default:
         _mesa_error(ctx, GL_INVALID_ENUM, "glConvolutionParameteriv(target)");
         return;
   }

   switch (pname) {
      case GL_CONVOLUTION_BORDER_COLOR:
	 ctx->Pixel.ConvolutionBorderColor[c][0] = INT_TO_FLOAT(params[0]);
	 ctx->Pixel.ConvolutionBorderColor[c][1] = INT_TO_FLOAT(params[1]);
	 ctx->Pixel.ConvolutionBorderColor[c][2] = INT_TO_FLOAT(params[2]);
	 ctx->Pixel.ConvolutionBorderColor[c][3] = INT_TO_FLOAT(params[3]);
         break;
      case GL_CONVOLUTION_BORDER_MODE:
         if (params[0] == (GLint) GL_REDUCE ||
             params[0] == (GLint) GL_CONSTANT_BORDER ||
             params[0] == (GLint) GL_REPLICATE_BORDER) {
            ctx->Pixel.ConvolutionBorderMode[c] = (GLenum) params[0];
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM, "glConvolutionParameteriv(params)");
            return;
         }
         break;
      case GL_CONVOLUTION_FILTER_SCALE:
	 /* COPY_4V(ctx->Pixel.ConvolutionFilterScale[c], params); */
	 /* need cast to prevent compiler warnings */  
	 ctx->Pixel.ConvolutionFilterScale[c][0] = (GLfloat) params[0]; 
	 ctx->Pixel.ConvolutionFilterScale[c][1] = (GLfloat) params[1]; 
	 ctx->Pixel.ConvolutionFilterScale[c][2] = (GLfloat) params[2]; 
	 ctx->Pixel.ConvolutionFilterScale[c][3] = (GLfloat) params[3]; 
         break;
      case GL_CONVOLUTION_FILTER_BIAS:
	 /* COPY_4V(ctx->Pixel.ConvolutionFilterBias[c], params); */
	 /* need cast to prevent compiler warnings */  
	 ctx->Pixel.ConvolutionFilterBias[c][0] = (GLfloat) params[0]; 
	 ctx->Pixel.ConvolutionFilterBias[c][1] = (GLfloat) params[1]; 
	 ctx->Pixel.ConvolutionFilterBias[c][2] = (GLfloat) params[2]; 
	 ctx->Pixel.ConvolutionFilterBias[c][3] = (GLfloat) params[3]; 
         break;
      default:
         _mesa_error(ctx, GL_INVALID_ENUM, "glConvolutionParameteriv(pname)");
         return;
   }
d94 1
a94 1
   ctx->NewState |= _NEW_PIXEL;
a100 1
   GLint baseFormat;
a101 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d103 1
a103 22
   if (target != GL_CONVOLUTION_1D) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glCopyConvolutionFilter1D(target)");
      return;
   }

   baseFormat = base_filter_format(internalFormat);
   if (baseFormat < 0 || baseFormat == GL_COLOR_INDEX) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glCopyConvolutionFilter1D(internalFormat)");
      return;
   }

   if (width < 0 || width > MAX_CONVOLUTION_WIDTH) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glCopyConvolutionFilter1D(width)");
      return;
   }

   if (!ctx->ReadBuffer->_ColorReadBuffer) {
      return;      /* no readbuffer - OK */
   }

   ctx->Driver.CopyConvolutionFilter1D( ctx, target, 
					internalFormat, x, y, width);
a109 1
   GLint baseFormat;
a110 25
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

   if (target != GL_CONVOLUTION_2D) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glCopyConvolutionFilter2D(target)");
      return;
   }

   baseFormat = base_filter_format(internalFormat);
   if (baseFormat < 0 || baseFormat == GL_COLOR_INDEX) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glCopyConvolutionFilter2D(internalFormat)");
      return;
   }

   if (width < 0 || width > MAX_CONVOLUTION_WIDTH) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glCopyConvolutionFilter2D(width)");
      return;
   }
   if (height < 0 || height > MAX_CONVOLUTION_HEIGHT) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glCopyConvolutionFilter2D(height)");
      return;
   }

   if (!ctx->ReadBuffer->_ColorReadBuffer) {
      return;      /* no readbuffer - OK */
   }
d112 1
a112 2
   ctx->Driver.CopyConvolutionFilter2D( ctx, target, internalFormat, x, y, 
					width, height );
a119 2
   struct gl_convolution_attrib *filter;
   GLuint row;
a120 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d122 1
a122 47
   if (ctx->NewState) {
      _mesa_update_state(ctx);
   }

   if (!_mesa_is_legal_format_and_type(ctx, format, type)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glGetConvolutionFilter(format or type)");
      return;
   }

   if (format == GL_COLOR_INDEX ||
       format == GL_STENCIL_INDEX ||
       format == GL_DEPTH_COMPONENT ||
       format == GL_INTENSITY ||
       type == GL_BITMAP) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetConvolutionFilter(format or type)");
      return;
   }

   switch (target) {
      case GL_CONVOLUTION_1D:
         filter = &(ctx->Convolution1D);
         break;
      case GL_CONVOLUTION_2D:
         filter = &(ctx->Convolution2D);
         break;
      default:
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetConvolutionFilter(target)");
         return;
   }

   image = _mesa_map_validate_pbo_dest(ctx, 2, &ctx->Pack,
                                       filter->Width, filter->Height, 1,
                                       format, type, image,
                                       "glGetConvolutionFilter");
   if (!image)
      return;

   for (row = 0; row < filter->Height; row++) {
      GLvoid *dst = _mesa_image_address2d(&ctx->Pack, image, filter->Width,
                                          filter->Height, format, type,
                                          row, 0);
      GLfloat (*src)[4] = (GLfloat (*)[4]) (filter->Filter + row * filter->Width * 4);
      _mesa_pack_rgba_span_float(ctx, filter->Width, src,
                                 format, type, dst, &ctx->Pack, 0x0);
   }

   _mesa_unmap_pbo_dest(ctx, &ctx->Pack);
d130 2
a131 54
   const struct gl_convolution_attrib *conv;
   GLuint c;
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   switch (target) {
      case GL_CONVOLUTION_1D:
         c = 0;
         conv = &ctx->Convolution1D;
         break;
      case GL_CONVOLUTION_2D:
         c = 1;
         conv = &ctx->Convolution2D;
         break;
      case GL_SEPARABLE_2D:
         c = 2;
         conv = &ctx->Separable2D;
         break;
      default:
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetConvolutionParameterfv(target)");
         return;
   }

   switch (pname) {
      case GL_CONVOLUTION_BORDER_COLOR:
         COPY_4V(params, ctx->Pixel.ConvolutionBorderColor[c]);
         break;
      case GL_CONVOLUTION_BORDER_MODE:
         *params = (GLfloat) ctx->Pixel.ConvolutionBorderMode[c];
         break;
      case GL_CONVOLUTION_FILTER_SCALE:
         COPY_4V(params, ctx->Pixel.ConvolutionFilterScale[c]);
         break;
      case GL_CONVOLUTION_FILTER_BIAS:
         COPY_4V(params, ctx->Pixel.ConvolutionFilterBias[c]);
         break;
      case GL_CONVOLUTION_FORMAT:
         *params = (GLfloat) conv->Format;
         break;
      case GL_CONVOLUTION_WIDTH:
         *params = (GLfloat) conv->Width;
         break;
      case GL_CONVOLUTION_HEIGHT:
         *params = (GLfloat) conv->Height;
         break;
      case GL_MAX_CONVOLUTION_WIDTH:
         *params = (GLfloat) ctx->Const.MaxConvolutionWidth;
         break;
      case GL_MAX_CONVOLUTION_HEIGHT:
         *params = (GLfloat) ctx->Const.MaxConvolutionHeight;
         break;
      default:
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetConvolutionParameterfv(pname)");
         return;
   }
d139 2
a140 63
   const struct gl_convolution_attrib *conv;
   GLuint c;
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   switch (target) {
      case GL_CONVOLUTION_1D:
         c = 0;
         conv = &ctx->Convolution1D;
         break;
      case GL_CONVOLUTION_2D:
         c = 1;
         conv = &ctx->Convolution2D;
         break;
      case GL_SEPARABLE_2D:
         c = 2;
         conv = &ctx->Separable2D;
         break;
      default:
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetConvolutionParameteriv(target)");
         return;
   }

   switch (pname) {
      case GL_CONVOLUTION_BORDER_COLOR:
         params[0] = FLOAT_TO_INT(ctx->Pixel.ConvolutionBorderColor[c][0]);
         params[1] = FLOAT_TO_INT(ctx->Pixel.ConvolutionBorderColor[c][1]);
         params[2] = FLOAT_TO_INT(ctx->Pixel.ConvolutionBorderColor[c][2]);
         params[3] = FLOAT_TO_INT(ctx->Pixel.ConvolutionBorderColor[c][3]);
         break;
      case GL_CONVOLUTION_BORDER_MODE:
         *params = (GLint) ctx->Pixel.ConvolutionBorderMode[c];
         break;
      case GL_CONVOLUTION_FILTER_SCALE:
         params[0] = (GLint) ctx->Pixel.ConvolutionFilterScale[c][0];
         params[1] = (GLint) ctx->Pixel.ConvolutionFilterScale[c][1];
         params[2] = (GLint) ctx->Pixel.ConvolutionFilterScale[c][2];
         params[3] = (GLint) ctx->Pixel.ConvolutionFilterScale[c][3];
         break;
      case GL_CONVOLUTION_FILTER_BIAS:
         params[0] = (GLint) ctx->Pixel.ConvolutionFilterBias[c][0];
         params[1] = (GLint) ctx->Pixel.ConvolutionFilterBias[c][1];
         params[2] = (GLint) ctx->Pixel.ConvolutionFilterBias[c][2];
         params[3] = (GLint) ctx->Pixel.ConvolutionFilterBias[c][3];
         break;
      case GL_CONVOLUTION_FORMAT:
         *params = (GLint) conv->Format;
         break;
      case GL_CONVOLUTION_WIDTH:
         *params = (GLint) conv->Width;
         break;
      case GL_CONVOLUTION_HEIGHT:
         *params = (GLint) conv->Height;
         break;
      case GL_MAX_CONVOLUTION_WIDTH:
         *params = (GLint) ctx->Const.MaxConvolutionWidth;
         break;
      case GL_MAX_CONVOLUTION_HEIGHT:
         *params = (GLint) ctx->Const.MaxConvolutionHeight;
         break;
      default:
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetConvolutionParameteriv(pname)");
         return;
   }
a147 2
   const GLint colStart = MAX_CONVOLUTION_WIDTH * 4;
   struct gl_convolution_attrib *filter;
a148 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d150 1
a150 55
   if (ctx->NewState) {
      _mesa_update_state(ctx);
   }

   if (target != GL_SEPARABLE_2D) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetSeparableFilter(target)");
      return;
   }

   if (!_mesa_is_legal_format_and_type(ctx, format, type)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glGetConvolutionFilter(format or type)");
      return;
   }

   if (format == GL_COLOR_INDEX ||
       format == GL_STENCIL_INDEX ||
       format == GL_DEPTH_COMPONENT ||
       format == GL_INTENSITY ||
       type == GL_BITMAP) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetConvolutionFilter(format or type)");
      return;
   }

   filter = &ctx->Separable2D;

   /* Get row filter */
   row = _mesa_map_validate_pbo_dest(ctx, 1, &ctx->Pack,
                                     filter->Width, 1, 1,
                                     format, type, row,
                                     "glGetConvolutionFilter");
   if (row) {
      GLvoid *dst = _mesa_image_address1d(&ctx->Pack, row, filter->Width,
                                          format, type, 0);
      _mesa_pack_rgba_span_float(ctx, filter->Width,
                                 (GLfloat (*)[4]) filter->Filter,
                                 format, type, dst, &ctx->Pack, 0x0);
      _mesa_unmap_pbo_dest(ctx, &ctx->Pack);
   }

   /* get column filter */
   column = _mesa_map_validate_pbo_dest(ctx, 1, &ctx->Pack,
                                        filter->Height, 1, 1,
                                        format, type, column,
                                        "glGetConvolutionFilter");
   if (column) {
      GLvoid *dst = _mesa_image_address1d(&ctx->Pack, column, filter->Height,
                                          format, type, 0);
      GLfloat (*src)[4] = (GLfloat (*)[4]) (filter->Filter + colStart);
      _mesa_pack_rgba_span_float(ctx, filter->Height, src,
                                 format, type, dst, &ctx->Pack, 0x0);
      _mesa_unmap_pbo_dest(ctx, &ctx->Pack);
   }

   (void) span;  /* unused at this time */
a156 2
   const GLint colStart = MAX_CONVOLUTION_WIDTH * 4;
   GLint baseFormat;
a157 222
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

   if (target != GL_SEPARABLE_2D) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glSeparableFilter2D(target)");
      return;
   }

   baseFormat = base_filter_format(internalFormat);
   if (baseFormat < 0 || baseFormat == GL_COLOR_INDEX) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glSeparableFilter2D(internalFormat)");
      return;
   }

   if (width < 0 || width > MAX_CONVOLUTION_WIDTH) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glSeparableFilter2D(width)");
      return;
   }
   if (height < 0 || height > MAX_CONVOLUTION_HEIGHT) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glSeparableFilter2D(height)");
      return;
   }

   if (!_mesa_is_legal_format_and_type(ctx, format, type)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glSeparableFilter2D(format or type)");
      return;
   }

   if (format == GL_COLOR_INDEX ||
       format == GL_STENCIL_INDEX ||
       format == GL_DEPTH_COMPONENT ||
       format == GL_INTENSITY ||
       type == GL_BITMAP) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glSeparableFilter2D(format or type)");
      return;
   }

   ctx->Separable2D.Format = format;
   ctx->Separable2D.InternalFormat = internalFormat;
   ctx->Separable2D.Width = width;
   ctx->Separable2D.Height = height;

   /* unpack row filter */
   row = _mesa_map_validate_pbo_source(ctx, 1, &ctx->Unpack,
                                       width, 1, 1,
                                       format, type, row,
                                       "glSeparableFilter2D");
   if (row) {
      _mesa_unpack_color_span_float(ctx, width, GL_RGBA,
                                    ctx->Separable2D.Filter,
                                    format, type, row, &ctx->Unpack,
                                    0x0);  /* transferOps */
      _mesa_scale_and_bias_rgba(width,
                             (GLfloat (*)[4]) ctx->Separable2D.Filter,
                             ctx->Pixel.ConvolutionFilterScale[2][0],
                             ctx->Pixel.ConvolutionFilterScale[2][1],
                             ctx->Pixel.ConvolutionFilterScale[2][2],
                             ctx->Pixel.ConvolutionFilterScale[2][3],
                             ctx->Pixel.ConvolutionFilterBias[2][0],
                             ctx->Pixel.ConvolutionFilterBias[2][1],
                             ctx->Pixel.ConvolutionFilterBias[2][2],
                             ctx->Pixel.ConvolutionFilterBias[2][3]);
      _mesa_unmap_pbo_source(ctx, &ctx->Unpack);
   }

   /* unpack column filter */
   column = _mesa_map_validate_pbo_source(ctx, 1, &ctx->Unpack,
                                          height, 1, 1,
                                          format, type, column,
                                          "glSeparableFilter2D");
   if (column) {
      _mesa_unpack_color_span_float(ctx, height, GL_RGBA,
                                    &ctx->Separable2D.Filter[colStart],
                                    format, type, column, &ctx->Unpack,
                                    0); /* transferOps */

      _mesa_scale_and_bias_rgba(height,
                       (GLfloat (*)[4]) (ctx->Separable2D.Filter + colStart),
                       ctx->Pixel.ConvolutionFilterScale[2][0],
                       ctx->Pixel.ConvolutionFilterScale[2][1],
                       ctx->Pixel.ConvolutionFilterScale[2][2],
                       ctx->Pixel.ConvolutionFilterScale[2][3],
                       ctx->Pixel.ConvolutionFilterBias[2][0],
                       ctx->Pixel.ConvolutionFilterBias[2][1],
                       ctx->Pixel.ConvolutionFilterBias[2][2],
                       ctx->Pixel.ConvolutionFilterBias[2][3]);
      _mesa_unmap_pbo_source(ctx, &ctx->Unpack);
   }

   if (_mesa_is_bufferobj(ctx->Unpack.BufferObj)) {
      ctx->Driver.UnmapBuffer(ctx, GL_PIXEL_UNPACK_BUFFER_EXT,
                              ctx->Unpack.BufferObj);
   }

   ctx->NewState |= _NEW_PIXEL;
}


/**********************************************************************/
/***                   image convolution functions                  ***/
/**********************************************************************/

static void
convolve_1d_reduce(GLint srcWidth, const GLfloat src[][4],
                   GLint filterWidth, const GLfloat filter[][4],
                   GLfloat dest[][4])
{
   GLint dstWidth;
   GLint i, n;

   if (filterWidth >= 1)
      dstWidth = srcWidth - (filterWidth - 1);
   else
      dstWidth = srcWidth;

   if (dstWidth <= 0)
      return;  /* null result */

   for (i = 0; i < dstWidth; i++) {
      GLfloat sumR = 0.0;
      GLfloat sumG = 0.0;
      GLfloat sumB = 0.0;
      GLfloat sumA = 0.0;
      for (n = 0; n < filterWidth; n++) {
         sumR += src[i + n][RCOMP] * filter[n][RCOMP];
         sumG += src[i + n][GCOMP] * filter[n][GCOMP];
         sumB += src[i + n][BCOMP] * filter[n][BCOMP];
         sumA += src[i + n][ACOMP] * filter[n][ACOMP];
      }
      dest[i][RCOMP] = sumR;
      dest[i][GCOMP] = sumG;
      dest[i][BCOMP] = sumB;
      dest[i][ACOMP] = sumA;
   }
}


static void
convolve_1d_constant(GLint srcWidth, const GLfloat src[][4],
                     GLint filterWidth, const GLfloat filter[][4],
                     GLfloat dest[][4],
                     const GLfloat borderColor[4])
{
   const GLint halfFilterWidth = filterWidth / 2;
   GLint i, n;

   for (i = 0; i < srcWidth; i++) {
      GLfloat sumR = 0.0;
      GLfloat sumG = 0.0;
      GLfloat sumB = 0.0;
      GLfloat sumA = 0.0;
      for (n = 0; n < filterWidth; n++) {
         if (i + n < halfFilterWidth || i + n - halfFilterWidth >= srcWidth) {
            sumR += borderColor[RCOMP] * filter[n][RCOMP];
            sumG += borderColor[GCOMP] * filter[n][GCOMP];
            sumB += borderColor[BCOMP] * filter[n][BCOMP];
            sumA += borderColor[ACOMP] * filter[n][ACOMP];
         }
         else {
            sumR += src[i + n - halfFilterWidth][RCOMP] * filter[n][RCOMP];
            sumG += src[i + n - halfFilterWidth][GCOMP] * filter[n][GCOMP];
            sumB += src[i + n - halfFilterWidth][BCOMP] * filter[n][BCOMP];
            sumA += src[i + n - halfFilterWidth][ACOMP] * filter[n][ACOMP];
         }
      }
      dest[i][RCOMP] = sumR;
      dest[i][GCOMP] = sumG;
      dest[i][BCOMP] = sumB;
      dest[i][ACOMP] = sumA;
   }
}


static void
convolve_1d_replicate(GLint srcWidth, const GLfloat src[][4],
                      GLint filterWidth, const GLfloat filter[][4],
                      GLfloat dest[][4])
{
   const GLint halfFilterWidth = filterWidth / 2;
   GLint i, n;

   for (i = 0; i < srcWidth; i++) {
      GLfloat sumR = 0.0;
      GLfloat sumG = 0.0;
      GLfloat sumB = 0.0;
      GLfloat sumA = 0.0;
      for (n = 0; n < filterWidth; n++) {
         if (i + n < halfFilterWidth) {
            sumR += src[0][RCOMP] * filter[n][RCOMP];
            sumG += src[0][GCOMP] * filter[n][GCOMP];
            sumB += src[0][BCOMP] * filter[n][BCOMP];
            sumA += src[0][ACOMP] * filter[n][ACOMP];
         }
         else if (i + n - halfFilterWidth >= srcWidth) {
            sumR += src[srcWidth - 1][RCOMP] * filter[n][RCOMP];
            sumG += src[srcWidth - 1][GCOMP] * filter[n][GCOMP];
            sumB += src[srcWidth - 1][BCOMP] * filter[n][BCOMP];
            sumA += src[srcWidth - 1][ACOMP] * filter[n][ACOMP];
         }
         else {
            sumR += src[i + n - halfFilterWidth][RCOMP] * filter[n][RCOMP];
            sumG += src[i + n - halfFilterWidth][GCOMP] * filter[n][GCOMP];
            sumB += src[i + n - halfFilterWidth][BCOMP] * filter[n][BCOMP];
            sumA += src[i + n - halfFilterWidth][ACOMP] * filter[n][ACOMP];
         }
      }
      dest[i][RCOMP] = sumR;
      dest[i][GCOMP] = sumG;
      dest[i][BCOMP] = sumB;
      dest[i][ACOMP] = sumA;
   }
}


static void
convolve_2d_reduce(GLint srcWidth, GLint srcHeight,
                   const GLfloat src[][4],
                   GLint filterWidth, GLint filterHeight,
                   const GLfloat filter[][4],
                   GLfloat dest[][4])
{
   GLint dstWidth, dstHeight;
   GLint i, j, n, m;
d159 1
a159 35
   if (filterWidth >= 1)
      dstWidth = srcWidth - (filterWidth - 1);
   else
      dstWidth = srcWidth;

   if (filterHeight >= 1)
      dstHeight = srcHeight - (filterHeight - 1);
   else
      dstHeight = srcHeight;

   if (dstWidth <= 0 || dstHeight <= 0)
      return;

   for (j = 0; j < dstHeight; j++) {
      for (i = 0; i < dstWidth; i++) {
         GLfloat sumR = 0.0;
         GLfloat sumG = 0.0;
         GLfloat sumB = 0.0;
         GLfloat sumA = 0.0;
         for (m = 0; m < filterHeight; m++) {
            for (n = 0; n < filterWidth; n++) {
               const GLint k = (j + m) * srcWidth + i + n;
               const GLint f = m * filterWidth + n;
               sumR += src[k][RCOMP] * filter[f][RCOMP];
               sumG += src[k][GCOMP] * filter[f][GCOMP];
               sumB += src[k][BCOMP] * filter[f][BCOMP];
               sumA += src[k][ACOMP] * filter[f][ACOMP];
            }
         }
         dest[j * dstWidth + i][RCOMP] = sumR;
         dest[j * dstWidth + i][GCOMP] = sumG;
         dest[j * dstWidth + i][BCOMP] = sumB;
         dest[j * dstWidth + i][ACOMP] = sumA;
      }
   }
a160 385


static void
convolve_2d_constant(GLint srcWidth, GLint srcHeight,
                     const GLfloat src[][4],
                     GLint filterWidth, GLint filterHeight,
                     const GLfloat filter[][4],
                     GLfloat dest[][4],
                     const GLfloat borderColor[4])
{
   const GLint halfFilterWidth = filterWidth / 2;
   const GLint halfFilterHeight = filterHeight / 2;
   GLint i, j, n, m;

   for (j = 0; j < srcHeight; j++) {
      for (i = 0; i < srcWidth; i++) {
         GLfloat sumR = 0.0;
         GLfloat sumG = 0.0;
         GLfloat sumB = 0.0;
         GLfloat sumA = 0.0;
         for (m = 0; m < filterHeight; m++) {
            for (n = 0; n < filterWidth; n++) {
               const GLint f = m * filterWidth + n;
               const GLint is = i + n - halfFilterWidth;
               const GLint js = j + m - halfFilterHeight;
               if (is < 0 || is >= srcWidth ||
                   js < 0 || js >= srcHeight) {
                  sumR += borderColor[RCOMP] * filter[f][RCOMP];
                  sumG += borderColor[GCOMP] * filter[f][GCOMP];
                  sumB += borderColor[BCOMP] * filter[f][BCOMP];
                  sumA += borderColor[ACOMP] * filter[f][ACOMP];
               }
               else {
                  const GLint k = js * srcWidth + is;
                  sumR += src[k][RCOMP] * filter[f][RCOMP];
                  sumG += src[k][GCOMP] * filter[f][GCOMP];
                  sumB += src[k][BCOMP] * filter[f][BCOMP];
                  sumA += src[k][ACOMP] * filter[f][ACOMP];
               }
            }
         }
         dest[j * srcWidth + i][RCOMP] = sumR;
         dest[j * srcWidth + i][GCOMP] = sumG;
         dest[j * srcWidth + i][BCOMP] = sumB;
         dest[j * srcWidth + i][ACOMP] = sumA;
      }
   }
}


static void
convolve_2d_replicate(GLint srcWidth, GLint srcHeight,
                      const GLfloat src[][4],
                      GLint filterWidth, GLint filterHeight,
                      const GLfloat filter[][4],
                      GLfloat dest[][4])
{
   const GLint halfFilterWidth = filterWidth / 2;
   const GLint halfFilterHeight = filterHeight / 2;
   GLint i, j, n, m;

   for (j = 0; j < srcHeight; j++) {
      for (i = 0; i < srcWidth; i++) {
         GLfloat sumR = 0.0;
         GLfloat sumG = 0.0;
         GLfloat sumB = 0.0;
         GLfloat sumA = 0.0;
         for (m = 0; m < filterHeight; m++) {
            for (n = 0; n < filterWidth; n++) {
               const GLint f = m * filterWidth + n;
               GLint is = i + n - halfFilterWidth;
               GLint js = j + m - halfFilterHeight;
               GLint k;
               if (is < 0)
                  is = 0;
               else if (is >= srcWidth)
                  is = srcWidth - 1;
               if (js < 0)
                  js = 0;
               else if (js >= srcHeight)
                  js = srcHeight - 1;
               k = js * srcWidth + is;
               sumR += src[k][RCOMP] * filter[f][RCOMP];
               sumG += src[k][GCOMP] * filter[f][GCOMP];
               sumB += src[k][BCOMP] * filter[f][BCOMP];
               sumA += src[k][ACOMP] * filter[f][ACOMP];
            }
         }
         dest[j * srcWidth + i][RCOMP] = sumR;
         dest[j * srcWidth + i][GCOMP] = sumG;
         dest[j * srcWidth + i][BCOMP] = sumB;
         dest[j * srcWidth + i][ACOMP] = sumA;
      }
   }
}


static void
convolve_sep_reduce(GLint srcWidth, GLint srcHeight,
                    const GLfloat src[][4],
                    GLint filterWidth, GLint filterHeight,
                    const GLfloat rowFilt[][4],
                    const GLfloat colFilt[][4],
                    GLfloat dest[][4])
{
   GLint dstWidth, dstHeight;
   GLint i, j, n, m;

   if (filterWidth >= 1)
      dstWidth = srcWidth - (filterWidth - 1);
   else
      dstWidth = srcWidth;

   if (filterHeight >= 1)
      dstHeight = srcHeight - (filterHeight - 1);
   else
      dstHeight = srcHeight;

   if (dstWidth <= 0 || dstHeight <= 0)
      return;

   for (j = 0; j < dstHeight; j++) {
      for (i = 0; i < dstWidth; i++) {
         GLfloat sumR = 0.0;
         GLfloat sumG = 0.0;
         GLfloat sumB = 0.0;
         GLfloat sumA = 0.0;
         for (m = 0; m < filterHeight; m++) {
            for (n = 0; n < filterWidth; n++) {
               GLint k = (j + m) * srcWidth + i + n;
               sumR += src[k][RCOMP] * rowFilt[n][RCOMP] * colFilt[m][RCOMP];
               sumG += src[k][GCOMP] * rowFilt[n][GCOMP] * colFilt[m][GCOMP];
               sumB += src[k][BCOMP] * rowFilt[n][BCOMP] * colFilt[m][BCOMP];
               sumA += src[k][ACOMP] * rowFilt[n][ACOMP] * colFilt[m][ACOMP];
            }
         }
         dest[j * dstWidth + i][RCOMP] = sumR;
         dest[j * dstWidth + i][GCOMP] = sumG;
         dest[j * dstWidth + i][BCOMP] = sumB;
         dest[j * dstWidth + i][ACOMP] = sumA;
      }
   }
}


static void
convolve_sep_constant(GLint srcWidth, GLint srcHeight,
                      const GLfloat src[][4],
                      GLint filterWidth, GLint filterHeight,
                      const GLfloat rowFilt[][4],
                      const GLfloat colFilt[][4],
                      GLfloat dest[][4],
                      const GLfloat borderColor[4])
{
   const GLint halfFilterWidth = filterWidth / 2;
   const GLint halfFilterHeight = filterHeight / 2;
   GLint i, j, n, m;

   for (j = 0; j < srcHeight; j++) {
      for (i = 0; i < srcWidth; i++) {
         GLfloat sumR = 0.0;
         GLfloat sumG = 0.0;
         GLfloat sumB = 0.0;
         GLfloat sumA = 0.0;
         for (m = 0; m < filterHeight; m++) {
            for (n = 0; n < filterWidth; n++) {
               const GLint is = i + n - halfFilterWidth;
               const GLint js = j + m - halfFilterHeight;
               if (is < 0 || is >= srcWidth ||
                   js < 0 || js >= srcHeight) {
                  sumR += borderColor[RCOMP] * rowFilt[n][RCOMP] * colFilt[m][RCOMP];
                  sumG += borderColor[GCOMP] * rowFilt[n][GCOMP] * colFilt[m][GCOMP];
                  sumB += borderColor[BCOMP] * rowFilt[n][BCOMP] * colFilt[m][BCOMP];
                  sumA += borderColor[ACOMP] * rowFilt[n][ACOMP] * colFilt[m][ACOMP];
               }
               else {
                  GLint k = js * srcWidth + is;
                  sumR += src[k][RCOMP] * rowFilt[n][RCOMP] * colFilt[m][RCOMP];
                  sumG += src[k][GCOMP] * rowFilt[n][GCOMP] * colFilt[m][GCOMP];
                  sumB += src[k][BCOMP] * rowFilt[n][BCOMP] * colFilt[m][BCOMP];
                  sumA += src[k][ACOMP] * rowFilt[n][ACOMP] * colFilt[m][ACOMP];
               }

            }
         }
         dest[j * srcWidth + i][RCOMP] = sumR;
         dest[j * srcWidth + i][GCOMP] = sumG;
         dest[j * srcWidth + i][BCOMP] = sumB;
         dest[j * srcWidth + i][ACOMP] = sumA;
      }
   }
}


static void
convolve_sep_replicate(GLint srcWidth, GLint srcHeight,
                       const GLfloat src[][4],
                       GLint filterWidth, GLint filterHeight,
                       const GLfloat rowFilt[][4],
                       const GLfloat colFilt[][4],
                       GLfloat dest[][4])
{
   const GLint halfFilterWidth = filterWidth / 2;
   const GLint halfFilterHeight = filterHeight / 2;
   GLint i, j, n, m;

   for (j = 0; j < srcHeight; j++) {
      for (i = 0; i < srcWidth; i++) {
         GLfloat sumR = 0.0;
         GLfloat sumG = 0.0;
         GLfloat sumB = 0.0;
         GLfloat sumA = 0.0;
         for (m = 0; m < filterHeight; m++) {
            for (n = 0; n < filterWidth; n++) {
               GLint is = i + n - halfFilterWidth;
               GLint js = j + m - halfFilterHeight;
               GLint k;
               if (is < 0)
                  is = 0;
               else if (is >= srcWidth)
                  is = srcWidth - 1;
               if (js < 0)
                  js = 0;
               else if (js >= srcHeight)
                  js = srcHeight - 1;
               k = js * srcWidth + is;
               sumR += src[k][RCOMP] * rowFilt[n][RCOMP] * colFilt[m][RCOMP];
               sumG += src[k][GCOMP] * rowFilt[n][GCOMP] * colFilt[m][GCOMP];
               sumB += src[k][BCOMP] * rowFilt[n][BCOMP] * colFilt[m][BCOMP];
               sumA += src[k][ACOMP] * rowFilt[n][ACOMP] * colFilt[m][ACOMP];
            }
         }
         dest[j * srcWidth + i][RCOMP] = sumR;
         dest[j * srcWidth + i][GCOMP] = sumG;
         dest[j * srcWidth + i][BCOMP] = sumB;
         dest[j * srcWidth + i][ACOMP] = sumA;
      }
   }
}



void
_mesa_convolve_1d_image(const GLcontext *ctx, GLsizei *width,
                        const GLfloat *srcImage, GLfloat *dstImage)
{
   switch (ctx->Pixel.ConvolutionBorderMode[0]) {
      case GL_REDUCE:
         convolve_1d_reduce(*width, (const GLfloat (*)[4]) srcImage,
                            ctx->Convolution1D.Width,
                            (const GLfloat (*)[4]) ctx->Convolution1D.Filter,
                            (GLfloat (*)[4]) dstImage);
         *width = *width - (MAX2(ctx->Convolution1D.Width, 1) - 1);
         break;
      case GL_CONSTANT_BORDER:
         convolve_1d_constant(*width, (const GLfloat (*)[4]) srcImage,
                              ctx->Convolution1D.Width,
                              (const GLfloat (*)[4]) ctx->Convolution1D.Filter,
                              (GLfloat (*)[4]) dstImage,
                              ctx->Pixel.ConvolutionBorderColor[0]);
         break;
      case GL_REPLICATE_BORDER:
         convolve_1d_replicate(*width, (const GLfloat (*)[4]) srcImage,
                              ctx->Convolution1D.Width,
                              (const GLfloat (*)[4]) ctx->Convolution1D.Filter,
                              (GLfloat (*)[4]) dstImage);
         break;
      default:
         ;
   }
}


void
_mesa_convolve_2d_image(const GLcontext *ctx, GLsizei *width, GLsizei *height,
                        const GLfloat *srcImage, GLfloat *dstImage)
{
   switch (ctx->Pixel.ConvolutionBorderMode[1]) {
      case GL_REDUCE:
         convolve_2d_reduce(*width, *height,
                            (const GLfloat (*)[4]) srcImage,
                            ctx->Convolution2D.Width,
                            ctx->Convolution2D.Height,
                            (const GLfloat (*)[4]) ctx->Convolution2D.Filter,
                            (GLfloat (*)[4]) dstImage);
         *width = *width - (MAX2(ctx->Convolution2D.Width, 1) - 1);
         *height = *height - (MAX2(ctx->Convolution2D.Height, 1) - 1);
         break;
      case GL_CONSTANT_BORDER:
         convolve_2d_constant(*width, *height,
                              (const GLfloat (*)[4]) srcImage,
                              ctx->Convolution2D.Width,
                              ctx->Convolution2D.Height,
                              (const GLfloat (*)[4]) ctx->Convolution2D.Filter,
                              (GLfloat (*)[4]) dstImage,
                              ctx->Pixel.ConvolutionBorderColor[1]);
         break;
      case GL_REPLICATE_BORDER:
         convolve_2d_replicate(*width, *height,
                               (const GLfloat (*)[4]) srcImage,
                               ctx->Convolution2D.Width,
                               ctx->Convolution2D.Height,
                               (const GLfloat (*)[4])ctx->Convolution2D.Filter,
                               (GLfloat (*)[4]) dstImage);
         break;
      default:
         ;
      }
}


void
_mesa_convolve_sep_image(const GLcontext *ctx,
                         GLsizei *width, GLsizei *height,
                         const GLfloat *srcImage, GLfloat *dstImage)
{
   const GLfloat *rowFilter = ctx->Separable2D.Filter;
   const GLfloat *colFilter = rowFilter + 4 * MAX_CONVOLUTION_WIDTH;

   switch (ctx->Pixel.ConvolutionBorderMode[2]) {
      case GL_REDUCE:
         convolve_sep_reduce(*width, *height,
                             (const GLfloat (*)[4]) srcImage,
                             ctx->Separable2D.Width,
                             ctx->Separable2D.Height,
                             (const GLfloat (*)[4]) rowFilter,
                             (const GLfloat (*)[4]) colFilter,
                             (GLfloat (*)[4]) dstImage);
         *width = *width - (MAX2(ctx->Separable2D.Width, 1) - 1);
         *height = *height - (MAX2(ctx->Separable2D.Height, 1) - 1);
         break;
      case GL_CONSTANT_BORDER:
         convolve_sep_constant(*width, *height,
                               (const GLfloat (*)[4]) srcImage,
                               ctx->Separable2D.Width,
                               ctx->Separable2D.Height,
                               (const GLfloat (*)[4]) rowFilter,
                               (const GLfloat (*)[4]) colFilter,
                               (GLfloat (*)[4]) dstImage,
                               ctx->Pixel.ConvolutionBorderColor[2]);
         break;
      case GL_REPLICATE_BORDER:
         convolve_sep_replicate(*width, *height,
                                (const GLfloat (*)[4]) srcImage,
                                ctx->Separable2D.Width,
                                ctx->Separable2D.Height,
                                (const GLfloat (*)[4]) rowFilter,
                                (const GLfloat (*)[4]) colFilter,
                                (GLfloat (*)[4]) dstImage);
         break;
      default:
         ;
   }
}



/*
 * This function computes an image's size after convolution.
 * If the convolution border mode is GL_REDUCE, the post-convolution
 * image will be smaller than the original.
 */
void
_mesa_adjust_image_for_convolution(const GLcontext *ctx, GLuint dimensions,
                                   GLsizei *width, GLsizei *height)
{
   if (ctx->Pixel.Convolution1DEnabled
       && dimensions == 1
       && ctx->Pixel.ConvolutionBorderMode[0] == GL_REDUCE) {
      *width = *width - (MAX2(ctx->Convolution1D.Width, 1) - 1);
   }
   else if (ctx->Pixel.Convolution2DEnabled
            && dimensions > 1
            && ctx->Pixel.ConvolutionBorderMode[1] == GL_REDUCE) {
      *width = *width - (MAX2(ctx->Convolution2D.Width, 1) - 1);
      *height = *height - (MAX2(ctx->Convolution2D.Height, 1) - 1);
   }
   else if (ctx->Pixel.Separable2DEnabled
            && dimensions > 1
            && ctx->Pixel.ConvolutionBorderMode[2] == GL_REDUCE) {
      *width = *width - (MAX2(ctx->Separable2D.Width, 1) - 1);
      *height = *height - (MAX2(ctx->Separable2D.Height, 1) - 1);
   }
}

@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * Version:  6.3
d5 1
a5 1
 * Copyright (C) 1999-2004  Brian Paul   All Rights Reserved.
a40 1
#include "pixel.h"
d42 4
d150 5
a154 21
   if (ctx->Unpack.BufferObj->Name) {
      /* unpack filter from PBO */
      GLubyte *buf;
      if (!_mesa_validate_pbo_access(1, &ctx->Unpack, width, 1, 1,
                                     format, type, image)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glConvolutionFilter1D(invalid PBO access)");
         return;
      }
      buf = (GLubyte *) ctx->Driver.MapBuffer(ctx, GL_PIXEL_UNPACK_BUFFER_EXT,
                                              GL_READ_ONLY_ARB,
                                              ctx->Unpack.BufferObj);
      if (!buf) {
         /* buffer is already mapped - that's an error */
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glConvolutionFilter1D(PBO is mapped)");
         return;
      }
      image = ADD_POINTERS(buf, image);
   }
   else if (!image) {
a155 1
   }
d162 1
a162 4
   if (ctx->Unpack.BufferObj->Name) {
      ctx->Driver.UnmapBuffer(ctx, GL_PIXEL_UNPACK_BUFFER_EXT,
                              ctx->Unpack.BufferObj);
   }
d228 5
a232 21
   if (ctx->Unpack.BufferObj->Name) {
      /* unpack filter from PBO */
      GLubyte *buf;
      if (!_mesa_validate_pbo_access(2, &ctx->Unpack, width, height, 1,
                                     format, type, image)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glConvolutionFilter2D(invalid PBO access)");
         return;
      }
      buf = (GLubyte *) ctx->Driver.MapBuffer(ctx, GL_PIXEL_UNPACK_BUFFER_EXT,
                                              GL_READ_ONLY_ARB,
                                              ctx->Unpack.BufferObj);
      if (!buf) {
         /* buffer is already mapped - that's an error */
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glConvolutionFilter2D(PBO is mapped)");
         return;
      }
      image = ADD_POINTERS(buf, image);
   }
   else if (!image) {
a233 1
   }
d245 1
a245 4
   if (ctx->Unpack.BufferObj->Name) {
      ctx->Driver.UnmapBuffer(ctx, GL_PIXEL_UNPACK_BUFFER_EXT,
                              ctx->Unpack.BufferObj);
   }
d262 1
a262 1
void GLAPIENTRY
d305 1
a305 1
void GLAPIENTRY
d357 1
a357 1
void GLAPIENTRY
d400 1
a400 1
void GLAPIENTRY
d465 1
a465 1
void GLAPIENTRY
d488 4
d497 1
a497 1
void GLAPIENTRY
d524 4
d533 3
a535 2
void GLAPIENTRY
_mesa_GetConvolutionFilter(GLenum target, GLenum format, GLenum type, GLvoid *image)
d537 1
a537 1
   const struct gl_convolution_attrib *filter;
d572 6
a577 21
   if (ctx->Pack.BufferObj->Name) {
      /* Pack the filter into a PBO */
      GLubyte *buf;
      if (!_mesa_validate_pbo_access(2, &ctx->Pack,
                                     filter->Width, filter->Height,
                                     1, format, type, image)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glGetConvolutionFilter(invalid PBO access)");
         return;
      }
      buf = (GLubyte *) ctx->Driver.MapBuffer(ctx, GL_PIXEL_PACK_BUFFER_EXT,
                                              GL_WRITE_ONLY_ARB,
                                              ctx->Pack.BufferObj);
      if (!buf) {
         /* buffer is already mapped - that's an error */
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glGetConvolutionFilter(PBO is mapped)");
         return;
      }
      image = ADD_POINTERS(image, buf);
   }
d583 3
a585 4
      const GLfloat *src = filter->Filter + row * filter->Width * 4;
      _mesa_pack_rgba_span_float(ctx, filter->Width,
                                 (const GLfloat (*)[4]) src,
                                 format, type, dst, &ctx->Pack, 0);
d588 1
a588 4
   if (ctx->Pack.BufferObj->Name) {
      ctx->Driver.UnmapBuffer(ctx, GL_PIXEL_PACK_BUFFER_EXT,
                              ctx->Pack.BufferObj);
   }
d592 1
a592 1
void GLAPIENTRY
d653 1
a653 1
void GLAPIENTRY
d723 3
a725 2
void GLAPIENTRY
_mesa_GetSeparableFilter(GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span)
d728 1
a728 1
   const struct gl_convolution_attrib *filter;
d742 2
a743 1
      _mesa_error(ctx, GL_INVALID_OPERATION, "glGetConvolutionFilter(format or type)");
d758 5
a762 29
   if (ctx->Pack.BufferObj->Name) {
      /* Pack filter into PBO */
      GLubyte *buf;
      if (!_mesa_validate_pbo_access(1, &ctx->Pack, filter->Width, 1, 1,
                                     format, type, row)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glGetSeparableFilter(invalid PBO access, width)");
         return;
      }
      if (!_mesa_validate_pbo_access(1, &ctx->Pack, filter->Height, 1, 1,
                                     format, type, column)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glGetSeparableFilter(invalid PBO access, height)");
         return;
      }
      buf = (GLubyte *) ctx->Driver.MapBuffer(ctx, GL_PIXEL_PACK_BUFFER_EXT,
                                              GL_WRITE_ONLY_ARB,
                                              ctx->Pack.BufferObj);
      if (!buf) {
         /* buffer is already mapped - that's an error */
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glGetSeparableFilter(PBO is mapped)");
         return;
      }
      row = ADD_POINTERS(buf, row);
      column = ADD_POINTERS(buf, column);
   }

   /* Row filter */
d767 3
a769 2
                                 (const GLfloat (*)[4]) filter->Filter,
                                 format, type, dst, &ctx->Pack, 0);
d772 5
a776 1
   /* Column filter */
d780 4
a783 4
      const GLfloat *src = filter->Filter + colStart;
      _mesa_pack_rgba_span_float(ctx, filter->Height,
                                 (const GLfloat (*)[4]) src,
                                 format, type, dst, &ctx->Pack, 0);
a786 6

   if (ctx->Pack.BufferObj->Name) {
      /* Pack filter into PBO */
      ctx->Driver.UnmapBuffer(ctx, GL_PIXEL_UNPACK_BUFFER_EXT,
                              ctx->Unpack.BufferObj);
   }
d790 1
a790 1
void GLAPIENTRY
a836 28
   if (ctx->Unpack.BufferObj->Name) {
      /* unpack filter from PBO */
      GLubyte *buf;
      if (!_mesa_validate_pbo_access(1, &ctx->Unpack, width, 1, 1,
                                     format, type, row)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glSeparableFilter2D(invalid PBO access, width)");
         return;
      }
      if (!_mesa_validate_pbo_access(1, &ctx->Unpack, height, 1, 1,
                                     format, type, column)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glSeparableFilter2D(invalid PBO access, height)");
         return;
      }
      buf = (GLubyte *) ctx->Driver.MapBuffer(ctx, GL_PIXEL_UNPACK_BUFFER_EXT,
                                              GL_READ_ONLY_ARB,
                                              ctx->Unpack.BufferObj);
      if (!buf) {
         /* buffer is already mapped - that's an error */
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glSeparableFilter2D(PBO is mapped)");
         return;
      }
      row = ADD_POINTERS(buf, row);
      column = ADD_POINTERS(buf, column);
   }

d838 4
d846 1
a846 2
                                    0);  /* transferOps */

d857 1
d861 4
d881 1
d884 1
a884 1
   if (ctx->Unpack.BufferObj->Name) {
d1439 22
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d3 1
a3 1
 * Version:  6.5.2
d5 1
a5 1
 * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
d563 1
a563 2
_mesa_GetConvolutionFilter(GLenum target, GLenum format, GLenum type,
                           GLvoid *image)
d565 1
a565 1
   struct gl_convolution_attrib *filter;
d626 4
a629 3
      GLfloat (*src)[4] = (GLfloat (*)[4]) (filter->Filter + row * filter->Width * 4);
      _mesa_pack_rgba_span_float(ctx, filter->Width, src,
                                 format, type, dst, &ctx->Pack, 0x0);
d771 1
a771 2
_mesa_GetSeparableFilter(GLenum target, GLenum format, GLenum type,
                         GLvoid *row, GLvoid *column, GLvoid *span)
d774 1
a774 1
   struct gl_convolution_attrib *filter;
d788 1
a788 2
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glGetConvolutionFilter(format or type)");
d836 2
a837 2
                                 (GLfloat (*)[4]) filter->Filter,
                                 format, type, dst, &ctx->Pack, 0x0);
d844 4
a847 3
      GLfloat (*src)[4] = (GLfloat (*)[4]) (filter->Filter + colStart);
      _mesa_pack_rgba_span_float(ctx, filter->Height, src,
                                 format, type, dst, &ctx->Pack, 0x0);
@


1.1.1.3
log
@Import Mesa 7.10.3
@
text
@d38 2
a39 1
#include "macros.h"
d41 2
a42 1
#include "main/dispatch.h"
d45 59
a103 1
#if FEATURE_convolve
d105 1
a105 1
static void GLAPIENTRY
d108 1
d110 1
d112 81
a192 1
   _mesa_error(ctx, GL_INVALID_ENUM, "glConvolutionFilter1D");
d195 2
a196 1
static void GLAPIENTRY
d199 2
d202 1
d204 92
a295 1
   _mesa_error(ctx, GL_INVALID_ENUM, "glConvolutionFilter2D");
d299 1
a299 1
static void GLAPIENTRY
d303 34
d338 1
a338 1
   _mesa_error(ctx, GL_INVALID_ENUM, "glConvolutionParameterf");
d342 1
a342 1
static void GLAPIENTRY
d346 43
d390 1
a390 1
   _mesa_error(ctx, GL_INVALID_ENUM, "glConvolutionParameterfv");
d394 1
a394 1
static void GLAPIENTRY
d398 2
d401 33
a433 1
   _mesa_error(ctx, GL_INVALID_ENUM, "glConvolutionParameteri");
d437 1
a437 1
static void GLAPIENTRY
d441 56
d498 1
a498 1
   _mesa_error(ctx, GL_INVALID_ENUM, "glConvolutionParameteriv");
d502 1
a502 1
static void GLAPIENTRY
d505 1
d507 1
d509 18
a526 1
   _mesa_error(ctx, GL_INVALID_ENUM, "glCopyConvolutionFilter1D");
d530 1
a530 1
static void GLAPIENTRY
d533 1
d535 21
d557 2
a558 1
   _mesa_error(ctx, GL_INVALID_ENUM, "glCopyConvolutionFilter2D");
d562 1
a562 1
static void GLAPIENTRY
d566 2
d569 1
d571 65
a635 1
   _mesa_error(ctx, GL_INVALID_OPERATION, "glGetConvolutionFilter");
d639 1
a639 1
static void GLAPIENTRY
d643 54
a696 2

   _mesa_error(ctx, GL_INVALID_ENUM, "glGetConvolutionParameterfv");
d700 1
a700 1
static void GLAPIENTRY
d704 63
a766 2

   _mesa_error(ctx, GL_INVALID_ENUM, "glGetConvolutionParameteriv");
d770 1
a770 1
static void GLAPIENTRY
d774 2
d777 1
d779 79
a857 1
   _mesa_error(ctx, GL_INVALID_ENUM, "glGetSeparableFilter");
d861 1
a861 1
static void GLAPIENTRY
d864 2
d867 111
d979 1
a979 1
   _mesa_error(ctx, GL_INVALID_ENUM, "glSeparableFilter2D");
d982 474
d1457 3
a1459 1
_mesa_init_convolve_dispatch(struct _glapi_table *disp)
d1461 37
a1497 13
   SET_ConvolutionFilter1D(disp, _mesa_ConvolutionFilter1D);
   SET_ConvolutionFilter2D(disp, _mesa_ConvolutionFilter2D);
   SET_ConvolutionParameterf(disp, _mesa_ConvolutionParameterf);
   SET_ConvolutionParameterfv(disp, _mesa_ConvolutionParameterfv);
   SET_ConvolutionParameteri(disp, _mesa_ConvolutionParameteri);
   SET_ConvolutionParameteriv(disp, _mesa_ConvolutionParameteriv);
   SET_CopyConvolutionFilter1D(disp, _mesa_CopyConvolutionFilter1D);
   SET_CopyConvolutionFilter2D(disp, _mesa_CopyConvolutionFilter2D);
   SET_GetConvolutionFilter(disp, _mesa_GetConvolutionFilter);
   SET_GetConvolutionParameterfv(disp, _mesa_GetConvolutionParameterfv);
   SET_GetConvolutionParameteriv(disp, _mesa_GetConvolutionParameteriv);
   SET_SeparableFilter2D(disp, _mesa_SeparableFilter2D);
   SET_GetSeparableFilter(disp, _mesa_GetSeparableFilter);
d1501 28
a1528 1
#endif /* FEATURE_convolve */
@


1.1.1.4
log
@Import Mesa 9.2.0
@
text
@d3 1
d20 3
a22 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
d43 3
a45 1
void GLAPIENTRY
d53 1
a53 1
void GLAPIENTRY
d62 1
a62 1
void GLAPIENTRY
d71 1
a71 1
void GLAPIENTRY
d80 1
a80 1
void GLAPIENTRY
d89 1
a89 1
void GLAPIENTRY
d98 1
a98 1
void GLAPIENTRY
d107 1
a107 1
void GLAPIENTRY
d116 3
a118 3
void GLAPIENTRY
_mesa_GetnConvolutionFilterARB(GLenum target, GLenum format, GLenum type,
                               GLsizei bufSize, GLvoid *image)
d126 1
a126 9
void GLAPIENTRY
_mesa_GetConvolutionFilter(GLenum target, GLenum format, GLenum type,
                           GLvoid *image)
{
   _mesa_GetnConvolutionFilterARB(target, format, type, INT_MAX, image);
}


void GLAPIENTRY
d135 1
a135 1
void GLAPIENTRY
d144 3
a146 5
void GLAPIENTRY
_mesa_GetnSeparableFilterARB(GLenum target, GLenum format, GLenum type,
                             GLsizei rowBufSize, GLvoid *row,
                             GLsizei columnBufSize,  GLvoid *column,
                             GLvoid *span)
d154 1
a154 10
void GLAPIENTRY
_mesa_GetSeparableFilter(GLenum target, GLenum format, GLenum type,
                         GLvoid *row, GLvoid *column, GLvoid *span)
{
   _mesa_GetnSeparableFilterARB(target, format, type, INT_MAX, row,
                                INT_MAX, column, span);
}


void GLAPIENTRY
d161 21
@


1.1.1.5
log
@Import Mesa 10.2.3
@
text
@d48 1
a48 1
   _mesa_error(ctx, GL_INVALID_OPERATION, "glConvolutionFilter1D");
d56 1
a56 1
   _mesa_error(ctx, GL_INVALID_OPERATION, "glConvolutionFilter2D");
d65 1
a65 1
   _mesa_error(ctx, GL_INVALID_OPERATION, "glConvolutionParameterf");
d74 1
a74 1
   _mesa_error(ctx, GL_INVALID_OPERATION, "glConvolutionParameterfv");
d83 1
a83 1
   _mesa_error(ctx, GL_INVALID_OPERATION, "glConvolutionParameteri");
d92 1
a92 1
   _mesa_error(ctx, GL_INVALID_OPERATION, "glConvolutionParameteriv");
d101 1
a101 1
   _mesa_error(ctx, GL_INVALID_OPERATION, "glCopyConvolutionFilter1D");
d110 1
a110 1
   _mesa_error(ctx, GL_INVALID_OPERATION, "glCopyConvolutionFilter2D");
d137 1
a137 1
   _mesa_error(ctx, GL_INVALID_OPERATION, "glGetConvolutionParameterfv");
d146 1
a146 1
   _mesa_error(ctx, GL_INVALID_OPERATION, "glGetConvolutionParameteriv");
d158 1
a158 1
   _mesa_error(ctx, GL_INVALID_OPERATION, "glGetSeparableFilter");
d176 1
a176 1
   _mesa_error(ctx, GL_INVALID_OPERATION, "glSeparableFilter2D");
@


1.1.1.6
log
@Import Mesa 10.4.3
@
text
@d35 2
a36 1
#include "context.h"
d38 2
@


1.1.1.7
log
@Import Mesa 10.2.9
@
text
@d35 1
a35 2
#include "bufferobj.h"
#include "colormac.h"
a36 2
#include "macros.h"
#include "mtypes.h"
@


