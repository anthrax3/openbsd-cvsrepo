head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.12.23.05.17.53;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.5;
commitid	4ry2gvZGMXkCUD2n;

1.5
date	2015.01.25.14.41.22;	author jsg;	state Exp;
branches;
next	1.4;
commitid	mcxB0JvoI9gTDYXU;

1.4
date	2014.07.09.21.09.00;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.06.28;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.17.13.58.19;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.23.13.29.46;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.46;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.16.49;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.35.05;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.12.53;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.50.00;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 2004-2008  Brian Paul   All Rights Reserved.
 * Copyright (C) 2009-2010  VMware, Inc.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

/**
 * \file shaderobj.c
 * \author Brian Paul
 *
 */


#include "main/glheader.h"
#include "main/context.h"
#include "main/hash.h"
#include "main/mtypes.h"
#include "main/shaderapi.h"
#include "main/shaderobj.h"
#include "main/uniforms.h"
#include "program/program.h"
#include "program/prog_parameter.h"
#include "program/hash_table.h"
#include "ralloc.h"

/**********************************************************************/
/*** Shader object functions                                        ***/
/**********************************************************************/


/**
 * Set ptr to point to sh.
 * If ptr is pointing to another shader, decrement its refcount (and delete
 * if refcount hits zero).
 * Then set ptr to point to sh, incrementing its refcount.
 */
void
_mesa_reference_shader(struct gl_context *ctx, struct gl_shader **ptr,
                       struct gl_shader *sh)
{
   assert(ptr);
   if (*ptr == sh) {
      /* no-op */
      return;
   }
   if (*ptr) {
      /* Unreference the old shader */
      GLboolean deleteFlag = GL_FALSE;
      struct gl_shader *old = *ptr;

      ASSERT(old->RefCount > 0);
      old->RefCount--;
      /*printf("SHADER DECR %p (%d) to %d\n",
        (void*) old, old->Name, old->RefCount);*/
      deleteFlag = (old->RefCount == 0);

      if (deleteFlag) {
	 if (old->Name != 0)
	    _mesa_HashRemove(ctx->Shared->ShaderObjects, old->Name);
         ctx->Driver.DeleteShader(ctx, old);
      }

      *ptr = NULL;
   }
   assert(!*ptr);

   if (sh) {
      /* reference new */
      sh->RefCount++;
      /*printf("SHADER INCR %p (%d) to %d\n",
        (void*) sh, sh->Name, sh->RefCount);*/
      *ptr = sh;
   }
}

void
_mesa_init_shader(struct gl_context *ctx, struct gl_shader *shader)
{
   shader->RefCount = 1;
}

/**
 * Allocate a new gl_shader object, initialize it.
 * Called via ctx->Driver.NewShader()
 */
struct gl_shader *
_mesa_new_shader(struct gl_context *ctx, GLuint name, GLenum type)
{
   struct gl_shader *shader;
   assert(_mesa_validate_shader_target(ctx, type));
   shader = rzalloc(NULL, struct gl_shader);
   if (shader) {
      shader->Type = type;
      shader->Stage = _mesa_shader_enum_to_shader_stage(type);
      shader->Name = name;
      _mesa_init_shader(ctx, shader);
   }
   return shader;
}


/**
 * Delete a shader object.
 * Called via ctx->Driver.DeleteShader().
 */
static void
_mesa_delete_shader(struct gl_context *ctx, struct gl_shader *sh)
{
   free((void *)sh->Source);
   free(sh->Label);
   _mesa_reference_program(ctx, &sh->Program, NULL);
   ralloc_free(sh);
}


/**
 * Lookup a GLSL shader object.
 */
struct gl_shader *
_mesa_lookup_shader(struct gl_context *ctx, GLuint name)
{
   if (name) {
      struct gl_shader *sh = (struct gl_shader *)
         _mesa_HashLookup(ctx->Shared->ShaderObjects, name);
      /* Note that both gl_shader and gl_shader_program objects are kept
       * in the same hash table.  Check the object's type to be sure it's
       * what we're expecting.
       */
      if (sh && sh->Type == GL_SHADER_PROGRAM_MESA) {
         return NULL;
      }
      return sh;
   }
   return NULL;
}


/**
 * As above, but record an error if shader is not found.
 */
struct gl_shader *
_mesa_lookup_shader_err(struct gl_context *ctx, GLuint name, const char *caller)
{
   if (!name) {
      _mesa_error(ctx, GL_INVALID_VALUE, "%s", caller);
      return NULL;
   }
   else {
      struct gl_shader *sh = (struct gl_shader *)
         _mesa_HashLookup(ctx->Shared->ShaderObjects, name);
      if (!sh) {
         _mesa_error(ctx, GL_INVALID_VALUE, "%s", caller);
         return NULL;
      }
      if (sh->Type == GL_SHADER_PROGRAM_MESA) {
         _mesa_error(ctx, GL_INVALID_OPERATION, "%s", caller);
         return NULL;
      }
      return sh;
   }
}



/**********************************************************************/
/*** Shader Program object functions                                ***/
/**********************************************************************/


/**
 * Set ptr to point to shProg.
 * If ptr is pointing to another object, decrement its refcount (and delete
 * if refcount hits zero).
 * Then set ptr to point to shProg, incrementing its refcount.
 */
void
_mesa_reference_shader_program(struct gl_context *ctx,
                               struct gl_shader_program **ptr,
                               struct gl_shader_program *shProg)
{
   assert(ptr);
   if (*ptr == shProg) {
      /* no-op */
      return;
   }
   if (*ptr) {
      /* Unreference the old shader program */
      GLboolean deleteFlag = GL_FALSE;
      struct gl_shader_program *old = *ptr;

      ASSERT(old->RefCount > 0);
      old->RefCount--;
#if 0
      printf("ShaderProgram %p ID=%u  RefCount-- to %d\n",
             (void *) old, old->Name, old->RefCount);
#endif
      deleteFlag = (old->RefCount == 0);

      if (deleteFlag) {
	 if (old->Name != 0)
	    _mesa_HashRemove(ctx->Shared->ShaderObjects, old->Name);
         ctx->Driver.DeleteShaderProgram(ctx, old);
      }

      *ptr = NULL;
   }
   assert(!*ptr);

   if (shProg) {
      shProg->RefCount++;
#if 0
      printf("ShaderProgram %p ID=%u  RefCount++ to %d\n",
             (void *) shProg, shProg->Name, shProg->RefCount);
#endif
      *ptr = shProg;
   }
}

void
_mesa_init_shader_program(struct gl_context *ctx, struct gl_shader_program *prog)
{
   prog->Type = GL_SHADER_PROGRAM_MESA;
   prog->RefCount = 1;

   prog->AttributeBindings = string_to_uint_map_ctor();
   prog->FragDataBindings = string_to_uint_map_ctor();
   prog->FragDataIndexBindings = string_to_uint_map_ctor();

   prog->Geom.VerticesOut = 0;
   prog->Geom.InputType = GL_TRIANGLES;
   prog->Geom.OutputType = GL_TRIANGLE_STRIP;

   prog->TransformFeedback.BufferMode = GL_INTERLEAVED_ATTRIBS;

   prog->InfoLog = ralloc_strdup(prog, "");
}

/**
 * Allocate a new gl_shader_program object, initialize it.
 * Called via ctx->Driver.NewShaderProgram()
 */
static struct gl_shader_program *
_mesa_new_shader_program(struct gl_context *ctx, GLuint name)
{
   struct gl_shader_program *shProg;
   shProg = rzalloc(NULL, struct gl_shader_program);
   if (shProg) {
      shProg->Name = name;
      _mesa_init_shader_program(ctx, shProg);
   }
   return shProg;
}


/**
 * Clear (free) the shader program state that gets produced by linking.
 */
void
_mesa_clear_shader_program_data(struct gl_context *ctx,
                                struct gl_shader_program *shProg)
{
   if (shProg->UniformStorage) {
      unsigned i;
      for (i = 0; i < shProg->NumUserUniformStorage; ++i)
         _mesa_uniform_detach_all_driver_storage(&shProg->UniformStorage[i]);
      ralloc_free(shProg->UniformStorage);
      shProg->NumUserUniformStorage = 0;
      shProg->UniformStorage = NULL;
   }

   if (shProg->UniformRemapTable) {
      ralloc_free(shProg->UniformRemapTable);
      shProg->NumUniformRemapTable = 0;
      shProg->UniformRemapTable = NULL;
   }

   if (shProg->UniformHash) {
      string_to_uint_map_dtor(shProg->UniformHash);
      shProg->UniformHash = NULL;
   }

   assert(shProg->InfoLog != NULL);
   ralloc_free(shProg->InfoLog);
   shProg->InfoLog = ralloc_strdup(shProg, "");
}


/**
 * Free all the data that hangs off a shader program object, but not the
 * object itself.
 */
void
_mesa_free_shader_program_data(struct gl_context *ctx,
                               struct gl_shader_program *shProg)
{
   GLuint i;
   gl_shader_stage sh;

   assert(shProg->Type == GL_SHADER_PROGRAM_MESA);

   _mesa_clear_shader_program_data(ctx, shProg);

   if (shProg->AttributeBindings) {
      string_to_uint_map_dtor(shProg->AttributeBindings);
      shProg->AttributeBindings = NULL;
   }

   if (shProg->FragDataBindings) {
      string_to_uint_map_dtor(shProg->FragDataBindings);
      shProg->FragDataBindings = NULL;
   }

   if (shProg->FragDataIndexBindings) {
      string_to_uint_map_dtor(shProg->FragDataIndexBindings);
      shProg->FragDataIndexBindings = NULL;
   }

   /* detach shaders */
   for (i = 0; i < shProg->NumShaders; i++) {
      _mesa_reference_shader(ctx, &shProg->Shaders[i], NULL);
   }
   shProg->NumShaders = 0;

   free(shProg->Shaders);
   shProg->Shaders = NULL;

   /* Transform feedback varying vars */
   for (i = 0; i < shProg->TransformFeedback.NumVarying; i++) {
      free(shProg->TransformFeedback.VaryingNames[i]);
   }
   free(shProg->TransformFeedback.VaryingNames);
   shProg->TransformFeedback.VaryingNames = NULL;
   shProg->TransformFeedback.NumVarying = 0;


   for (sh = 0; sh < MESA_SHADER_STAGES; sh++) {
      if (shProg->_LinkedShaders[sh] != NULL) {
	 ctx->Driver.DeleteShader(ctx, shProg->_LinkedShaders[sh]);
	 shProg->_LinkedShaders[sh] = NULL;
      }
   }

   free(shProg->Label);
   shProg->Label = NULL;
}


/**
 * Free/delete a shader program object.
 * Called via ctx->Driver.DeleteShaderProgram().
 */
static void
_mesa_delete_shader_program(struct gl_context *ctx, struct gl_shader_program *shProg)
{
   _mesa_free_shader_program_data(ctx, shProg);

   ralloc_free(shProg);
}


/**
 * Lookup a GLSL program object.
 */
struct gl_shader_program *
_mesa_lookup_shader_program(struct gl_context *ctx, GLuint name)
{
   struct gl_shader_program *shProg;
   if (name) {
      shProg = (struct gl_shader_program *)
         _mesa_HashLookup(ctx->Shared->ShaderObjects, name);
      /* Note that both gl_shader and gl_shader_program objects are kept
       * in the same hash table.  Check the object's type to be sure it's
       * what we're expecting.
       */
      if (shProg && shProg->Type != GL_SHADER_PROGRAM_MESA) {
         return NULL;
      }
      return shProg;
   }
   return NULL;
}


/**
 * As above, but record an error if program is not found.
 */
struct gl_shader_program *
_mesa_lookup_shader_program_err(struct gl_context *ctx, GLuint name,
                                const char *caller)
{
   if (!name) {
      _mesa_error(ctx, GL_INVALID_VALUE, "%s", caller);
      return NULL;
   }
   else {
      struct gl_shader_program *shProg = (struct gl_shader_program *)
         _mesa_HashLookup(ctx->Shared->ShaderObjects, name);
      if (!shProg) {
         _mesa_error(ctx, GL_INVALID_VALUE, "%s", caller);
         return NULL;
      }
      if (shProg->Type != GL_SHADER_PROGRAM_MESA) {
         _mesa_error(ctx, GL_INVALID_OPERATION, "%s", caller);
         return NULL;
      }
      return shProg;
   }
}


void
_mesa_init_shader_object_functions(struct dd_function_table *driver)
{
   driver->NewShader = _mesa_new_shader;
   driver->DeleteShader = _mesa_delete_shader;
   driver->NewShaderProgram = _mesa_new_shader_program;
   driver->DeleteShaderProgram = _mesa_delete_shader_program;
   driver->LinkShader = _mesa_ir_link_shader;
}
@


1.6
log
@Merge Mesa 10.2.9
@
text
@@


1.5
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d43 1
a43 1
#include "util/ralloc.h"
d238 2
a239 2
static void
init_shader_program(struct gl_shader_program *prog)
a250 2
   prog->Geom.UsesEndPrimitive = false;
   prog->Geom.UsesStreams = false;
d262 1
a262 1
_mesa_new_shader_program(GLuint name)
d268 1
a268 1
      init_shader_program(shProg);
d278 2
a279 1
_mesa_clear_shader_program_data(struct gl_shader_program *shProg)
a280 2
   unsigned i;

d282 1
a303 12

   ralloc_free(shProg->UniformBlocks);
   shProg->UniformBlocks = NULL;
   shProg->NumUniformBlocks = 0;
   for (i = 0; i < MESA_SHADER_STAGES; i++) {
      ralloc_free(shProg->UniformBlockStageIndex[i]);
      shProg->UniformBlockStageIndex[i] = NULL;
   }

   ralloc_free(shProg->AtomicBuffers);
   shProg->AtomicBuffers = NULL;
   shProg->NumAtomicBuffers = 0;
d320 1
a320 1
   _mesa_clear_shader_program_data(shProg);
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d43 1
a43 1
#include "ralloc.h"
d238 2
a239 2
void
_mesa_init_shader_program(struct gl_context *ctx, struct gl_shader_program *prog)
d251 2
d264 1
a264 1
_mesa_new_shader_program(struct gl_context *ctx, GLuint name)
d270 1
a270 1
      _mesa_init_shader_program(ctx, shProg);
d280 1
a280 2
_mesa_clear_shader_program_data(struct gl_context *ctx,
                                struct gl_shader_program *shProg)
d282 2
a284 1
      unsigned i;
d306 12
d334 1
a334 1
   _mesa_clear_shader_program_data(ctx, shProg);
@


1.3
log
@Merge Mesa 9.2.0
@
text
@d37 1
d109 1
a109 2
   assert(type == GL_FRAGMENT_SHADER || type == GL_VERTEX_SHADER ||
          type == GL_GEOMETRY_SHADER_ARB);
d113 1
d129 1
d288 6
a293 1
      shProg->UniformLocationBaseScale = 0;
d316 1
a316 1
   gl_shader_type sh;
d355 1
a355 1
   for (sh = 0; sh < MESA_SHADER_TYPES; sh++) {
d361 3
@


1.2
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d20 4
a23 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
a35 1
#include "main/mfeatures.h"
d38 1
d41 1
a41 1
#include "program/prog_uniform.h"
d127 1
a127 2
   if (sh->Source)
      free((void *) sh->Source);
d241 5
a245 2
   prog->Attributes = _mesa_new_parameter_list();
#if FEATURE_ARB_geometry_shader4
d249 2
a250 1
#endif
d279 8
a286 7
   _mesa_reference_vertprog(ctx, &shProg->VertexProgram, NULL);
   _mesa_reference_fragprog(ctx, &shProg->FragmentProgram, NULL);
   _mesa_reference_geomprog(ctx, &shProg->GeometryProgram, NULL);

   if (shProg->Uniforms) {
      _mesa_free_uniform_list(shProg->Uniforms);
      shProg->Uniforms = NULL;
d289 3
a291 3
   if (shProg->Varying) {
      _mesa_free_parameter_list(shProg->Varying);
      shProg->Varying = NULL;
d315 13
a327 3
   if (shProg->Attributes) {
      _mesa_free_parameter_list(shProg->Attributes);
      shProg->Attributes = NULL;
d336 2
a337 4
   if (shProg->Shaders) {
      free(shProg->Shaders);
      shProg->Shaders = NULL;
   }
@


1.1
log
@Initial revision
@
text
@d35 2
d75 2
a76 1
         _mesa_HashRemove(ctx->Shared->ShaderObjects, old->Name);
d217 2
a218 1
         _mesa_HashRemove(ctx->Shared->ShaderObjects, old->Name);
d247 2
d288 4
a325 5
   if (shProg->InfoLog) {
      ralloc_free(shProg->InfoLog);
      shProg->InfoLog = NULL;
   }

a413 1
   driver->CompileShader = _mesa_ir_compile_shader;
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d20 3
a22 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
a34 1
#include "main/mtypes.h"
a35 1
#include "main/uniforms.h"
d38 1
a38 1
#include "program/hash_table.h"
d73 1
a73 2
	 if (old->Name != 0)
	    _mesa_HashRemove(ctx->Shared->ShaderObjects, old->Name);
d123 2
a124 1
   free((void *)sh->Source);
d214 1
a214 2
	 if (old->Name != 0)
	    _mesa_HashRemove(ctx->Shared->ShaderObjects, old->Name);
d237 2
a238 5

   prog->AttributeBindings = string_to_uint_map_ctor();
   prog->FragDataBindings = string_to_uint_map_ctor();
   prog->FragDataIndexBindings = string_to_uint_map_ctor();

d242 1
a242 4

   prog->TransformFeedback.BufferMode = GL_INTERLEAVED_ATTRIBS;

   prog->InfoLog = ralloc_strdup(prog, "");
d269 13
a281 18
   if (shProg->UniformStorage) {
      unsigned i;
      for (i = 0; i < shProg->NumUserUniformStorage; ++i)
         _mesa_uniform_detach_all_driver_storage(&shProg->UniformStorage[i]);
      ralloc_free(shProg->UniformStorage);
      shProg->NumUserUniformStorage = 0;
      shProg->UniformStorage = NULL;
      shProg->UniformLocationBaseScale = 0;
   }

   if (shProg->UniformHash) {
      string_to_uint_map_dtor(shProg->UniformHash);
      shProg->UniformHash = NULL;
   }

   assert(shProg->InfoLog != NULL);
   ralloc_free(shProg->InfoLog);
   shProg->InfoLog = ralloc_strdup(shProg, "");
d300 3
a302 13
   if (shProg->AttributeBindings) {
      string_to_uint_map_dtor(shProg->AttributeBindings);
      shProg->AttributeBindings = NULL;
   }

   if (shProg->FragDataBindings) {
      string_to_uint_map_dtor(shProg->FragDataBindings);
      shProg->FragDataBindings = NULL;
   }

   if (shProg->FragDataIndexBindings) {
      string_to_uint_map_dtor(shProg->FragDataIndexBindings);
      shProg->FragDataIndexBindings = NULL;
d311 9
a319 2
   free(shProg->Shaders);
   shProg->Shaders = NULL;
d409 1
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@a36 1
#include "main/shaderapi.h"
d108 2
a109 1
   assert(_mesa_validate_shader_target(ctx, type));
a112 1
      shader->Stage = _mesa_shader_enum_to_shader_stage(type);
a127 1
   free(sh->Label);
d286 1
a286 6
   }

   if (shProg->UniformRemapTable) {
      ralloc_free(shProg->UniformRemapTable);
      shProg->NumUniformRemapTable = 0;
      shProg->UniformRemapTable = NULL;
d309 1
a309 1
   gl_shader_stage sh;
d348 1
a348 1
   for (sh = 0; sh < MESA_SHADER_STAGES; sh++) {
a353 3

   free(shProg->Label);
   shProg->Label = NULL;
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d43 1
a43 1
#include "util/ralloc.h"
d238 2
a239 2
static void
init_shader_program(struct gl_shader_program *prog)
a250 2
   prog->Geom.UsesEndPrimitive = false;
   prog->Geom.UsesStreams = false;
d262 1
a262 1
_mesa_new_shader_program(GLuint name)
d268 1
a268 1
      init_shader_program(shProg);
d278 2
a279 1
_mesa_clear_shader_program_data(struct gl_shader_program *shProg)
a280 2
   unsigned i;

d282 1
a303 12

   ralloc_free(shProg->UniformBlocks);
   shProg->UniformBlocks = NULL;
   shProg->NumUniformBlocks = 0;
   for (i = 0; i < MESA_SHADER_STAGES; i++) {
      ralloc_free(shProg->UniformBlockStageIndex[i]);
      shProg->UniformBlockStageIndex[i] = NULL;
   }

   ralloc_free(shProg->AtomicBuffers);
   shProg->AtomicBuffers = NULL;
   shProg->NumAtomicBuffers = 0;
d320 1
a320 1
   _mesa_clear_shader_program_data(shProg);
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d43 1
a43 1
#include "ralloc.h"
d238 2
a239 2
void
_mesa_init_shader_program(struct gl_context *ctx, struct gl_shader_program *prog)
d251 2
d264 1
a264 1
_mesa_new_shader_program(struct gl_context *ctx, GLuint name)
d270 1
a270 1
      _mesa_init_shader_program(ctx, shProg);
d280 1
a280 2
_mesa_clear_shader_program_data(struct gl_context *ctx,
                                struct gl_shader_program *shProg)
d282 2
a284 1
      unsigned i;
d306 12
d334 1
a334 1
   _mesa_clear_shader_program_data(ctx, shProg);
@


