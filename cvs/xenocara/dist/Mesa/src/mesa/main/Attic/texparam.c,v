head	1.11;
access;
symbols
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	v10_2_9:1.1.1.7
	v10_4_3:1.1.1.6
	v10_2_7:1.1.1.5
	OPENBSD_5_6:1.7.0.2
	OPENBSD_5_6_BASE:1.7
	v10_2_3:1.1.1.4
	OPENBSD_5_5:1.6.0.2
	OPENBSD_5_5_BASE:1.6
	v9_2_5:1.1.1.3
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.4.0.4
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.2
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.3.0.4
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.2.0.6
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.0.4
	OPENBSD_4_7_BASE:1.1
	OPENBSD_4_6:1.1.0.2
	OPENBSD_4_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.11
date	2015.12.23.05.17.53;	author jsg;	state dead;
branches;
next	1.10;
commitid	TnlogFl9nOv2eaRf;

1.10
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.9;
commitid	4ry2gvZGMXkCUD2n;

1.9
date	2015.01.25.14.41.22;	author jsg;	state Exp;
branches;
next	1.8;
commitid	mcxB0JvoI9gTDYXU;

1.8
date	2014.09.07.15.20.07;	author jsg;	state Exp;
branches;
next	1.7;
commitid	7kimTMT4YlQauAIU;

1.7
date	2014.07.09.21.09.00;	author jsg;	state Exp;
branches;
next	1.6;
commitid	WPD6rgPryPkvXOr9;

1.6
date	2014.01.19.03.13.15;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2013.09.05.14.06.32;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2012.08.17.13.58.19;	author mpi;	state Exp;
branches;
next	1.3;

1.3
date	2011.10.23.13.37.44;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.05.22.20.06.31;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2009.05.17.20.26.42;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.47;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.16.55;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.01.19.03.04.40;	author jsg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.07.09.20.35.06;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.5
date	2014.09.07.15.07.31;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	dm8VnQHhowGHmemJ;

1.1.1.6
date	2015.01.25.14.13.00;	author jsg;	state Exp;
branches;
next	1.1.1.7;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.7
date	2015.02.20.22.50.06;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.11
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2008  Brian Paul   All Rights Reserved.
 * Copyright (C) 2009  VMware, Inc.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

/**
 * \file texparam.c
 *
 * glTexParameter-related functions
 */

#include <stdbool.h>
#include "main/glheader.h"
#include "main/blend.h"
#include "main/colormac.h"
#include "main/context.h"
#include "main/enums.h"
#include "main/formats.h"
#include "main/glformats.h"
#include "main/macros.h"
#include "main/mtypes.h"
#include "main/state.h"
#include "main/texcompress.h"
#include "main/texobj.h"
#include "main/texparam.h"
#include "main/teximage.h"
#include "main/texstate.h"
#include "program/prog_instruction.h"


/**
 * Check if a coordinate wrap mode is supported for the texture target.
 * \return GL_TRUE if legal, GL_FALSE otherwise
 */
static GLboolean
validate_texture_wrap_mode(struct gl_context * ctx, GLenum target, GLenum wrap)
{
   const struct gl_extensions * const e = & ctx->Extensions;
   const bool is_desktop_gl = _mesa_is_desktop_gl(ctx);
   bool supported;

   switch (wrap) {
   case GL_CLAMP:
      /* GL_CLAMP was removed in the core profile, and it has never existed in
       * OpenGL ES.
       */
      supported = (ctx->API == API_OPENGL_COMPAT)
         && (target != GL_TEXTURE_EXTERNAL_OES);
      break;

   case GL_CLAMP_TO_EDGE:
      supported = true;
      break;

   case GL_CLAMP_TO_BORDER:
      supported = is_desktop_gl && e->ARB_texture_border_clamp
         && (target != GL_TEXTURE_EXTERNAL_OES);
      break;

   case GL_REPEAT:
   case GL_MIRRORED_REPEAT:
      supported = (target != GL_TEXTURE_RECTANGLE_NV)
         && (target != GL_TEXTURE_EXTERNAL_OES);
      break;

   case GL_MIRROR_CLAMP_EXT:
      supported = is_desktop_gl
         && (e->ATI_texture_mirror_once || e->EXT_texture_mirror_clamp)
         && (target != GL_TEXTURE_RECTANGLE_NV)
         && (target != GL_TEXTURE_EXTERNAL_OES);
      break;

   case GL_MIRROR_CLAMP_TO_EDGE_EXT:
      supported = is_desktop_gl
         && (e->ATI_texture_mirror_once || e->EXT_texture_mirror_clamp || e->ARB_texture_mirror_clamp_to_edge)
         && (target != GL_TEXTURE_RECTANGLE_NV)
         && (target != GL_TEXTURE_EXTERNAL_OES);
      break;

   case GL_MIRROR_CLAMP_TO_BORDER_EXT:
      supported = is_desktop_gl && e->EXT_texture_mirror_clamp
         && (target != GL_TEXTURE_RECTANGLE_NV)
         && (target != GL_TEXTURE_EXTERNAL_OES);
      break;

   default:
      supported = false;
      break;
   }

   if (!supported)
      _mesa_error( ctx, GL_INVALID_ENUM, "glTexParameter(param=0x%x)", wrap );

   return supported;
}


/**
 * Get current texture object for given target.
 * Return NULL if any error (and record the error).
 * Note that this is different from _mesa_get_current_tex_object() in that
 * proxy targets are not accepted.
 * Only the glGetTexLevelParameter() functions accept proxy targets.
 */
static struct gl_texture_object *
get_texobj(struct gl_context *ctx, GLenum target, GLboolean get)
{
   struct gl_texture_unit *texUnit;
   int targetIndex;

   if (ctx->Texture.CurrentUnit >= ctx->Const.MaxCombinedTextureImageUnits) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "gl%sTexParameter(current unit)", get ? "Get" : "");
      return NULL;
   }

   texUnit = _mesa_get_current_tex_unit(ctx);

   targetIndex = _mesa_tex_target_to_index(ctx, target);
   if (targetIndex < 0 || targetIndex == TEXTURE_BUFFER_INDEX) {
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "gl%sTexParameter(target)", get ? "Get" : "");
      return NULL;
   }
   assert(targetIndex < NUM_TEXTURE_TARGETS);

   return texUnit->CurrentTex[targetIndex];
}


/**
 * Convert GL_RED/GREEN/BLUE/ALPHA/ZERO/ONE to SWIZZLE_X/Y/Z/W/ZERO/ONE.
 * \return -1 if error.
 */
static GLint
comp_to_swizzle(GLenum comp)
{
   switch (comp) {
   case GL_RED:
      return SWIZZLE_X;
   case GL_GREEN:
      return SWIZZLE_Y;
   case GL_BLUE:
      return SWIZZLE_Z;
   case GL_ALPHA:
      return SWIZZLE_W;
   case GL_ZERO:
      return SWIZZLE_ZERO;
   case GL_ONE:
      return SWIZZLE_ONE;
   default:
      return -1;
   }
}


static void
set_swizzle_component(GLuint *swizzle, GLuint comp, GLuint swz)
{
   ASSERT(comp < 4);
   ASSERT(swz <= SWIZZLE_NIL);
   {
      GLuint mask = 0x7 << (3 * comp);
      GLuint s = (*swizzle & ~mask) | (swz << (3 * comp));
      *swizzle = s;
   }
}


/**
 * This is called just prior to changing any texture object state which
 * will not effect texture completeness.
 */
static inline void
flush(struct gl_context *ctx)
{
   FLUSH_VERTICES(ctx, _NEW_TEXTURE);
}


/**
 * This is called just prior to changing any texture object state which
 * can effect texture completeness (texture base level, max level).
 * Any pending rendering will be flushed out, we'll set the _NEW_TEXTURE
 * state flag and then mark the texture object as 'incomplete' so that any
 * per-texture derived state gets recomputed.
 */
static inline void
incomplete(struct gl_context *ctx, struct gl_texture_object *texObj)
{
   FLUSH_VERTICES(ctx, _NEW_TEXTURE);
   _mesa_dirty_texobj(ctx, texObj);
}


static GLboolean
target_allows_setting_sampler_parameters(GLenum target)
{
   switch (target) {
   case GL_TEXTURE_2D_MULTISAMPLE:
   case GL_TEXTURE_2D_MULTISAMPLE_ARRAY:
      return GL_FALSE;

   default:
      return GL_TRUE;
   }
}


/**
 * Set an integer-valued texture parameter
 * \return GL_TRUE if legal AND the value changed, GL_FALSE otherwise
 */
static GLboolean
set_tex_parameteri(struct gl_context *ctx,
                   struct gl_texture_object *texObj,
                   GLenum pname, const GLint *params)
{
   switch (pname) {
   case GL_TEXTURE_MIN_FILTER:
      if (!target_allows_setting_sampler_parameters(texObj->Target))
         goto invalid_operation;

      if (texObj->Sampler.MinFilter == params[0])
         return GL_FALSE;
      switch (params[0]) {
      case GL_NEAREST:
      case GL_LINEAR:
         flush(ctx);
         texObj->Sampler.MinFilter = params[0];
         return GL_TRUE;
      case GL_NEAREST_MIPMAP_NEAREST:
      case GL_LINEAR_MIPMAP_NEAREST:
      case GL_NEAREST_MIPMAP_LINEAR:
      case GL_LINEAR_MIPMAP_LINEAR:
         if (texObj->Target != GL_TEXTURE_RECTANGLE_NV &&
             texObj->Target != GL_TEXTURE_EXTERNAL_OES) {
            flush(ctx);
            texObj->Sampler.MinFilter = params[0];
            return GL_TRUE;
         }
         /* fall-through */
      default:
         goto invalid_param;
      }
      return GL_FALSE;

   case GL_TEXTURE_MAG_FILTER:
      if (!target_allows_setting_sampler_parameters(texObj->Target))
         goto invalid_operation;

      if (texObj->Sampler.MagFilter == params[0])
         return GL_FALSE;
      switch (params[0]) {
      case GL_NEAREST:
      case GL_LINEAR:
         flush(ctx); /* does not effect completeness */
         texObj->Sampler.MagFilter = params[0];
         return GL_TRUE;
      default:
         goto invalid_param;
      }
      return GL_FALSE;

   case GL_TEXTURE_WRAP_S:
      if (!target_allows_setting_sampler_parameters(texObj->Target))
         goto invalid_operation;

      if (texObj->Sampler.WrapS == params[0])
         return GL_FALSE;
      if (validate_texture_wrap_mode(ctx, texObj->Target, params[0])) {
         flush(ctx);
         texObj->Sampler.WrapS = params[0];
         return GL_TRUE;
      }
      return GL_FALSE;

   case GL_TEXTURE_WRAP_T:
      if (!target_allows_setting_sampler_parameters(texObj->Target))
         goto invalid_operation;

      if (texObj->Sampler.WrapT == params[0])
         return GL_FALSE;
      if (validate_texture_wrap_mode(ctx, texObj->Target, params[0])) {
         flush(ctx);
         texObj->Sampler.WrapT = params[0];
         return GL_TRUE;
      }
      return GL_FALSE;

   case GL_TEXTURE_WRAP_R:
      if (!target_allows_setting_sampler_parameters(texObj->Target))
         goto invalid_operation;

      if (texObj->Sampler.WrapR == params[0])
         return GL_FALSE;
      if (validate_texture_wrap_mode(ctx, texObj->Target, params[0])) {
         flush(ctx);
         texObj->Sampler.WrapR = params[0];
         return GL_TRUE;
      }
      return GL_FALSE;

   case GL_TEXTURE_BASE_LEVEL:
      if (!_mesa_is_desktop_gl(ctx) && !_mesa_is_gles3(ctx))
         goto invalid_pname;

      if (texObj->BaseLevel == params[0])
         return GL_FALSE;

      if ((texObj->Target == GL_TEXTURE_2D_MULTISAMPLE ||
           texObj->Target == GL_TEXTURE_2D_MULTISAMPLE_ARRAY) && params[0] != 0)
         goto invalid_operation;

      if (params[0] < 0 ||
          (texObj->Target == GL_TEXTURE_RECTANGLE_ARB && params[0] != 0)) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glTexParameter(param=%d)", params[0]);
         return GL_FALSE;
      }
      incomplete(ctx, texObj);

      /** See note about ARB_texture_storage below */
      if (texObj->Immutable)
         texObj->BaseLevel = MIN2(texObj->ImmutableLevels - 1, params[0]);
      else
         texObj->BaseLevel = params[0];

      return GL_TRUE;

   case GL_TEXTURE_MAX_LEVEL:
      if (texObj->MaxLevel == params[0])
         return GL_FALSE;

      if (params[0] < 0 ||
          (texObj->Target == GL_TEXTURE_RECTANGLE_ARB && params[0] > 0)) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glTexParameter(param=%d)", params[0]);
         return GL_FALSE;
      }
      incomplete(ctx, texObj);

      /** From ARB_texture_storage:
       * However, if TEXTURE_IMMUTABLE_FORMAT is TRUE, then level_base is
       * clamped to the range [0, <levels> - 1] and level_max is then clamped to
       * the range [level_base, <levels> - 1], where <levels> is the parameter
       * passed the call to TexStorage* for the texture object.
       */
      if (texObj->Immutable)
          texObj->MaxLevel = CLAMP(params[0], texObj->BaseLevel,
                                   texObj->ImmutableLevels - 1);
      else
         texObj->MaxLevel = params[0];

      return GL_TRUE;

   case GL_GENERATE_MIPMAP_SGIS:
      if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
         goto invalid_pname;

      if (params[0] && texObj->Target == GL_TEXTURE_EXTERNAL_OES)
         goto invalid_param;
      if (texObj->GenerateMipmap != params[0]) {
         /* no flush() */
	 texObj->GenerateMipmap = params[0] ? GL_TRUE : GL_FALSE;
	 return GL_TRUE;
      }
      return GL_FALSE;

   case GL_TEXTURE_COMPARE_MODE_ARB:
      if ((_mesa_is_desktop_gl(ctx) && ctx->Extensions.ARB_shadow)
          || _mesa_is_gles3(ctx)) {

         if (!target_allows_setting_sampler_parameters(texObj->Target))
            goto invalid_operation;

         if (texObj->Sampler.CompareMode == params[0])
            return GL_FALSE;
         if (params[0] == GL_NONE ||
             params[0] == GL_COMPARE_R_TO_TEXTURE_ARB) {
            flush(ctx);
            texObj->Sampler.CompareMode = params[0];
            return GL_TRUE;
         }
         goto invalid_param;
      }
      goto invalid_pname;

   case GL_TEXTURE_COMPARE_FUNC_ARB:
      if ((_mesa_is_desktop_gl(ctx) && ctx->Extensions.ARB_shadow)
          || _mesa_is_gles3(ctx)) {

         if (!target_allows_setting_sampler_parameters(texObj->Target))
            goto invalid_operation;

         if (texObj->Sampler.CompareFunc == params[0])
            return GL_FALSE;
         switch (params[0]) {
         case GL_LEQUAL:
         case GL_GEQUAL:
         case GL_EQUAL:
         case GL_NOTEQUAL:
         case GL_LESS:
         case GL_GREATER:
         case GL_ALWAYS:
         case GL_NEVER:
            flush(ctx);
            texObj->Sampler.CompareFunc = params[0];
            return GL_TRUE;
         default:
            goto invalid_param;
         }
      }
      goto invalid_pname;

   case GL_DEPTH_TEXTURE_MODE_ARB:
      /* GL_DEPTH_TEXTURE_MODE_ARB is removed in core-profile and it has never
       * existed in OpenGL ES.
       */
      if (ctx->API == API_OPENGL_COMPAT && ctx->Extensions.ARB_depth_texture) {
         if (texObj->DepthMode == params[0])
            return GL_FALSE;
         if (params[0] == GL_LUMINANCE ||
             params[0] == GL_INTENSITY ||
             params[0] == GL_ALPHA ||
             (ctx->Extensions.ARB_texture_rg && params[0] == GL_RED)) {
            flush(ctx);
            texObj->DepthMode = params[0];
            return GL_TRUE;
         }
         goto invalid_param;
      }
      goto invalid_pname;

   case GL_DEPTH_STENCIL_TEXTURE_MODE:
      if (_mesa_is_desktop_gl(ctx) && ctx->Extensions.ARB_stencil_texturing) {
         bool stencil = params[0] == GL_STENCIL_INDEX;
         if (!stencil && params[0] != GL_DEPTH_COMPONENT)
            goto invalid_param;

         if (texObj->StencilSampling == stencil)
            return GL_FALSE;

         texObj->StencilSampling = stencil;
         return GL_TRUE;
      }
      goto invalid_pname;

   case GL_TEXTURE_CROP_RECT_OES:
      if (ctx->API != API_OPENGLES || !ctx->Extensions.OES_draw_texture)
         goto invalid_pname;

      texObj->CropRect[0] = params[0];
      texObj->CropRect[1] = params[1];
      texObj->CropRect[2] = params[2];
      texObj->CropRect[3] = params[3];
      return GL_TRUE;

   case GL_TEXTURE_SWIZZLE_R_EXT:
   case GL_TEXTURE_SWIZZLE_G_EXT:
   case GL_TEXTURE_SWIZZLE_B_EXT:
   case GL_TEXTURE_SWIZZLE_A_EXT:
      if ((_mesa_is_desktop_gl(ctx) && ctx->Extensions.EXT_texture_swizzle)
          || _mesa_is_gles3(ctx)) {
         const GLuint comp = pname - GL_TEXTURE_SWIZZLE_R_EXT;
         const GLint swz = comp_to_swizzle(params[0]);
         if (swz < 0) {
            _mesa_error(ctx, GL_INVALID_ENUM,
                        "glTexParameter(swizzle 0x%x)", params[0]);
            return GL_FALSE;
         }
         ASSERT(comp < 4);

         flush(ctx);
         texObj->Swizzle[comp] = params[0];
         set_swizzle_component(&texObj->_Swizzle, comp, swz);
         return GL_TRUE;
      }
      goto invalid_pname;

   case GL_TEXTURE_SWIZZLE_RGBA_EXT:
      if ((_mesa_is_desktop_gl(ctx) && ctx->Extensions.EXT_texture_swizzle)
          || _mesa_is_gles3(ctx)) {
         GLuint comp;
         flush(ctx);
         for (comp = 0; comp < 4; comp++) {
            const GLint swz = comp_to_swizzle(params[comp]);
            if (swz >= 0) {
               texObj->Swizzle[comp] = params[comp];
               set_swizzle_component(&texObj->_Swizzle, comp, swz);
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM,
                           "glTexParameter(swizzle 0x%x)", params[comp]);
               return GL_FALSE;
            }
         }
         return GL_TRUE;
      }
      goto invalid_pname;

   case GL_TEXTURE_SRGB_DECODE_EXT:
      if (_mesa_is_desktop_gl(ctx)
          && ctx->Extensions.EXT_texture_sRGB_decode) {
         GLenum decode = params[0];

         if (!target_allows_setting_sampler_parameters(texObj->Target))
            goto invalid_operation;

	 if (decode == GL_DECODE_EXT || decode == GL_SKIP_DECODE_EXT) {
	    if (texObj->Sampler.sRGBDecode != decode) {
	       flush(ctx);
	       texObj->Sampler.sRGBDecode = decode;
	    }
	    return GL_TRUE;
	 }
      }
      goto invalid_pname;

   case GL_TEXTURE_CUBE_MAP_SEAMLESS:
      if (_mesa_is_desktop_gl(ctx)
          && ctx->Extensions.AMD_seamless_cubemap_per_texture) {
         GLenum param = params[0];

         if (!target_allows_setting_sampler_parameters(texObj->Target))
            goto invalid_operation;

         if (param != GL_TRUE && param != GL_FALSE) {
            goto invalid_param;
         }
         if (param != texObj->Sampler.CubeMapSeamless) {
            flush(ctx);
            texObj->Sampler.CubeMapSeamless = param;
         }
         return GL_TRUE;
      }
      goto invalid_pname;

   default:
      goto invalid_pname;
   }

invalid_pname:
   _mesa_error(ctx, GL_INVALID_ENUM, "glTexParameter(pname=%s)",
               _mesa_lookup_enum_by_nr(pname));
   return GL_FALSE;

invalid_param:
   _mesa_error(ctx, GL_INVALID_ENUM, "glTexParameter(param=%s)",
               _mesa_lookup_enum_by_nr(params[0]));
   return GL_FALSE;

invalid_operation:
   _mesa_error(ctx, GL_INVALID_OPERATION, "glTexParameter(pname=%s)",
               _mesa_lookup_enum_by_nr(pname));
   return GL_FALSE;
}


/**
 * Set a float-valued texture parameter
 * \return GL_TRUE if legal AND the value changed, GL_FALSE otherwise
 */
static GLboolean
set_tex_parameterf(struct gl_context *ctx,
                   struct gl_texture_object *texObj,
                   GLenum pname, const GLfloat *params)
{
   switch (pname) {
   case GL_TEXTURE_MIN_LOD:
      if (!_mesa_is_desktop_gl(ctx) && !_mesa_is_gles3(ctx))
         goto invalid_pname;

      if (!target_allows_setting_sampler_parameters(texObj->Target))
         goto invalid_operation;

      if (texObj->Sampler.MinLod == params[0])
         return GL_FALSE;
      flush(ctx);
      texObj->Sampler.MinLod = params[0];
      return GL_TRUE;

   case GL_TEXTURE_MAX_LOD:
      if (!_mesa_is_desktop_gl(ctx) && !_mesa_is_gles3(ctx))
         goto invalid_pname;

      if (!target_allows_setting_sampler_parameters(texObj->Target))
         goto invalid_operation;

      if (texObj->Sampler.MaxLod == params[0])
         return GL_FALSE;
      flush(ctx);
      texObj->Sampler.MaxLod = params[0];
      return GL_TRUE;

   case GL_TEXTURE_PRIORITY:
      if (ctx->API != API_OPENGL_COMPAT)
         goto invalid_pname;

      flush(ctx);
      texObj->Priority = CLAMP(params[0], 0.0F, 1.0F);
      return GL_TRUE;

   case GL_TEXTURE_MAX_ANISOTROPY_EXT:
      if (ctx->Extensions.EXT_texture_filter_anisotropic) {
         if (!target_allows_setting_sampler_parameters(texObj->Target))
            goto invalid_operation;

         if (texObj->Sampler.MaxAnisotropy == params[0])
            return GL_FALSE;
         if (params[0] < 1.0) {
            _mesa_error(ctx, GL_INVALID_VALUE, "glTexParameter(param)" );
            return GL_FALSE;
         }
         flush(ctx);
         /* clamp to max, that's what NVIDIA does */
         texObj->Sampler.MaxAnisotropy = MIN2(params[0],
                                      ctx->Const.MaxTextureMaxAnisotropy);
         return GL_TRUE;
      }
      else {
         static GLuint count = 0;
         if (count++ < 10)
            goto invalid_pname;
      }
      return GL_FALSE;

   case GL_TEXTURE_LOD_BIAS:
      /* NOTE: this is really part of OpenGL 1.4, not EXT_texture_lod_bias. */
      if (_mesa_is_gles(ctx))
         goto invalid_pname;

      if (!target_allows_setting_sampler_parameters(texObj->Target))
         goto invalid_operation;

      if (texObj->Sampler.LodBias != params[0]) {
	 flush(ctx);
	 texObj->Sampler.LodBias = params[0];
	 return GL_TRUE;
      }
      break;

   case GL_TEXTURE_BORDER_COLOR:
      if (!_mesa_is_desktop_gl(ctx))
         goto invalid_pname;

      if (!target_allows_setting_sampler_parameters(texObj->Target))
         goto invalid_operation;

      flush(ctx);
      /* ARB_texture_float disables clamping */
      if (ctx->Extensions.ARB_texture_float) {
         texObj->Sampler.BorderColor.f[RCOMP] = params[0];
         texObj->Sampler.BorderColor.f[GCOMP] = params[1];
         texObj->Sampler.BorderColor.f[BCOMP] = params[2];
         texObj->Sampler.BorderColor.f[ACOMP] = params[3];
      } else {
         texObj->Sampler.BorderColor.f[RCOMP] = CLAMP(params[0], 0.0F, 1.0F);
         texObj->Sampler.BorderColor.f[GCOMP] = CLAMP(params[1], 0.0F, 1.0F);
         texObj->Sampler.BorderColor.f[BCOMP] = CLAMP(params[2], 0.0F, 1.0F);
         texObj->Sampler.BorderColor.f[ACOMP] = CLAMP(params[3], 0.0F, 1.0F);
      }
      return GL_TRUE;

   default:
      goto invalid_pname;
   }
   return GL_FALSE;

invalid_pname:
   _mesa_error(ctx, GL_INVALID_ENUM, "glTexParameter(pname=%s)",
               _mesa_lookup_enum_by_nr(pname));
   return GL_FALSE;

invalid_operation:
   _mesa_error(ctx, GL_INVALID_OPERATION, "glTexParameter(pname=%s)",
               _mesa_lookup_enum_by_nr(pname));
   return GL_FALSE;
}


void GLAPIENTRY
_mesa_TexParameterf(GLenum target, GLenum pname, GLfloat param)
{
   GLboolean need_update;
   struct gl_texture_object *texObj;
   GET_CURRENT_CONTEXT(ctx);

   texObj = get_texobj(ctx, target, GL_FALSE);
   if (!texObj)
      return;

   switch (pname) {
   case GL_TEXTURE_MIN_FILTER:
   case GL_TEXTURE_MAG_FILTER:
   case GL_TEXTURE_WRAP_S:
   case GL_TEXTURE_WRAP_T:
   case GL_TEXTURE_WRAP_R:
   case GL_TEXTURE_BASE_LEVEL:
   case GL_TEXTURE_MAX_LEVEL:
   case GL_GENERATE_MIPMAP_SGIS:
   case GL_TEXTURE_COMPARE_MODE_ARB:
   case GL_TEXTURE_COMPARE_FUNC_ARB:
   case GL_DEPTH_TEXTURE_MODE_ARB:
   case GL_DEPTH_STENCIL_TEXTURE_MODE:
   case GL_TEXTURE_SRGB_DECODE_EXT:
   case GL_TEXTURE_CUBE_MAP_SEAMLESS:
   case GL_TEXTURE_SWIZZLE_R_EXT:
   case GL_TEXTURE_SWIZZLE_G_EXT:
   case GL_TEXTURE_SWIZZLE_B_EXT:
   case GL_TEXTURE_SWIZZLE_A_EXT:
      {
         GLint p[4];
         p[0] = (param > 0) ?
                ((param > INT_MAX) ? INT_MAX : (GLint) (param + 0.5)) :
                ((param < INT_MIN) ? INT_MIN : (GLint) (param - 0.5));

         p[1] = p[2] = p[3] = 0;
         need_update = set_tex_parameteri(ctx, texObj, pname, p);
      }
      break;
   default:
      {
         /* this will generate an error if pname is illegal */
         GLfloat p[4];
         p[0] = param;
         p[1] = p[2] = p[3] = 0.0F;
         need_update = set_tex_parameterf(ctx, texObj, pname, p);
      }
   }

   if (ctx->Driver.TexParameter && need_update) {
      ctx->Driver.TexParameter(ctx, texObj, pname, &param);
   }
}


void GLAPIENTRY
_mesa_TexParameterfv(GLenum target, GLenum pname, const GLfloat *params)
{
   GLboolean need_update;
   struct gl_texture_object *texObj;
   GET_CURRENT_CONTEXT(ctx);

   texObj = get_texobj(ctx, target, GL_FALSE);
   if (!texObj)
      return;

   switch (pname) {
   case GL_TEXTURE_MIN_FILTER:
   case GL_TEXTURE_MAG_FILTER:
   case GL_TEXTURE_WRAP_S:
   case GL_TEXTURE_WRAP_T:
   case GL_TEXTURE_WRAP_R:
   case GL_TEXTURE_BASE_LEVEL:
   case GL_TEXTURE_MAX_LEVEL:
   case GL_GENERATE_MIPMAP_SGIS:
   case GL_TEXTURE_COMPARE_MODE_ARB:
   case GL_TEXTURE_COMPARE_FUNC_ARB:
   case GL_DEPTH_TEXTURE_MODE_ARB:
   case GL_DEPTH_STENCIL_TEXTURE_MODE:
   case GL_TEXTURE_SRGB_DECODE_EXT:
   case GL_TEXTURE_CUBE_MAP_SEAMLESS:
      {
         /* convert float param to int */
         GLint p[4];
         p[0] = (GLint) params[0];
         p[1] = p[2] = p[3] = 0;
         need_update = set_tex_parameteri(ctx, texObj, pname, p);
      }
      break;
   case GL_TEXTURE_CROP_RECT_OES:
      {
         /* convert float params to int */
         GLint iparams[4];
         iparams[0] = (GLint) params[0];
         iparams[1] = (GLint) params[1];
         iparams[2] = (GLint) params[2];
         iparams[3] = (GLint) params[3];
         need_update = set_tex_parameteri(ctx, texObj, pname, iparams);
      }
      break;
   case GL_TEXTURE_SWIZZLE_R_EXT:
   case GL_TEXTURE_SWIZZLE_G_EXT:
   case GL_TEXTURE_SWIZZLE_B_EXT:
   case GL_TEXTURE_SWIZZLE_A_EXT:
   case GL_TEXTURE_SWIZZLE_RGBA_EXT:
      {
         GLint p[4] = {0, 0, 0, 0};
         p[0] = (GLint) params[0];
         if (pname == GL_TEXTURE_SWIZZLE_RGBA_EXT) {
            p[1] = (GLint) params[1];
            p[2] = (GLint) params[2];
            p[3] = (GLint) params[3];
         }
         need_update = set_tex_parameteri(ctx, texObj, pname, p);
      }
      break;
   default:
      /* this will generate an error if pname is illegal */
      need_update = set_tex_parameterf(ctx, texObj, pname, params);
   }

   if (ctx->Driver.TexParameter && need_update) {
      ctx->Driver.TexParameter(ctx, texObj, pname, params);
   }
}


void GLAPIENTRY
_mesa_TexParameteri(GLenum target, GLenum pname, GLint param)
{
   GLboolean need_update;
   struct gl_texture_object *texObj;
   GET_CURRENT_CONTEXT(ctx);

   texObj = get_texobj(ctx, target, GL_FALSE);
   if (!texObj)
      return;

   switch (pname) {
   case GL_TEXTURE_MIN_LOD:
   case GL_TEXTURE_MAX_LOD:
   case GL_TEXTURE_PRIORITY:
   case GL_TEXTURE_MAX_ANISOTROPY_EXT:
   case GL_TEXTURE_LOD_BIAS:
   case GL_TEXTURE_COMPARE_FAIL_VALUE_ARB:
      {
         GLfloat fparam[4];
         fparam[0] = (GLfloat) param;
         fparam[1] = fparam[2] = fparam[3] = 0.0F;
         /* convert int param to float */
         need_update = set_tex_parameterf(ctx, texObj, pname, fparam);
      }
      break;
   default:
      /* this will generate an error if pname is illegal */
      {
         GLint iparam[4];
         iparam[0] = param;
         iparam[1] = iparam[2] = iparam[3] = 0;
         need_update = set_tex_parameteri(ctx, texObj, pname, iparam);
      }
   }

   if (ctx->Driver.TexParameter && need_update) {
      GLfloat fparam = (GLfloat) param;
      ctx->Driver.TexParameter(ctx, texObj, pname, &fparam);
   }
}


void GLAPIENTRY
_mesa_TexParameteriv(GLenum target, GLenum pname, const GLint *params)
{
   GLboolean need_update;
   struct gl_texture_object *texObj;
   GET_CURRENT_CONTEXT(ctx);

   texObj = get_texobj(ctx, target, GL_FALSE);
   if (!texObj)
      return;

   switch (pname) {
   case GL_TEXTURE_BORDER_COLOR:
      {
         /* convert int params to float */
         GLfloat fparams[4];
         fparams[0] = INT_TO_FLOAT(params[0]);
         fparams[1] = INT_TO_FLOAT(params[1]);
         fparams[2] = INT_TO_FLOAT(params[2]);
         fparams[3] = INT_TO_FLOAT(params[3]);
         need_update = set_tex_parameterf(ctx, texObj, pname, fparams);
      }
      break;
   case GL_TEXTURE_MIN_LOD:
   case GL_TEXTURE_MAX_LOD:
   case GL_TEXTURE_PRIORITY:
   case GL_TEXTURE_MAX_ANISOTROPY_EXT:
   case GL_TEXTURE_LOD_BIAS:
   case GL_TEXTURE_COMPARE_FAIL_VALUE_ARB:
      {
         /* convert int param to float */
         GLfloat fparams[4];
         fparams[0] = (GLfloat) params[0];
         fparams[1] = fparams[2] = fparams[3] = 0.0F;
         need_update = set_tex_parameterf(ctx, texObj, pname, fparams);
      }
      break;
   default:
      /* this will generate an error if pname is illegal */
      need_update = set_tex_parameteri(ctx, texObj, pname, params);
   }

   if (ctx->Driver.TexParameter && need_update) {
      GLfloat fparams[4];
      fparams[0] = INT_TO_FLOAT(params[0]);
      if (pname == GL_TEXTURE_BORDER_COLOR ||
          pname == GL_TEXTURE_CROP_RECT_OES) {
         fparams[1] = INT_TO_FLOAT(params[1]);
         fparams[2] = INT_TO_FLOAT(params[2]);
         fparams[3] = INT_TO_FLOAT(params[3]);
      }
      ctx->Driver.TexParameter(ctx, texObj, pname, fparams);
   }
}


/**
 * Set tex parameter to integer value(s).  Primarily intended to set
 * integer-valued texture border color (for integer-valued textures).
 * New in GL 3.0.
 */
void GLAPIENTRY
_mesa_TexParameterIiv(GLenum target, GLenum pname, const GLint *params)
{
   struct gl_texture_object *texObj;
   GET_CURRENT_CONTEXT(ctx);

   texObj = get_texobj(ctx, target, GL_FALSE);
   if (!texObj)
      return;

   switch (pname) {
   case GL_TEXTURE_BORDER_COLOR:
      FLUSH_VERTICES(ctx, _NEW_TEXTURE);
      /* set the integer-valued border color */
      COPY_4V(texObj->Sampler.BorderColor.i, params);
      break;
   default:
      _mesa_TexParameteriv(target, pname, params);
      break;
   }
   /* XXX no driver hook for TexParameterIiv() yet */
}


/**
 * Set tex parameter to unsigned integer value(s).  Primarily intended to set
 * uint-valued texture border color (for integer-valued textures).
 * New in GL 3.0
 */
void GLAPIENTRY
_mesa_TexParameterIuiv(GLenum target, GLenum pname, const GLuint *params)
{
   struct gl_texture_object *texObj;
   GET_CURRENT_CONTEXT(ctx);

   texObj = get_texobj(ctx, target, GL_FALSE);
   if (!texObj)
      return;

   switch (pname) {
   case GL_TEXTURE_BORDER_COLOR:
      FLUSH_VERTICES(ctx, _NEW_TEXTURE);
      /* set the unsigned integer-valued border color */
      COPY_4V(texObj->Sampler.BorderColor.ui, params);
      break;
   default:
      _mesa_TexParameteriv(target, pname, (const GLint *) params);
      break;
   }
   /* XXX no driver hook for TexParameterIuiv() yet */
}


static GLboolean
legal_get_tex_level_parameter_target(struct gl_context *ctx, GLenum target)
{
   switch (target) {
   case GL_TEXTURE_1D:
   case GL_PROXY_TEXTURE_1D:
   case GL_TEXTURE_2D:
   case GL_PROXY_TEXTURE_2D:
   case GL_TEXTURE_3D:
   case GL_PROXY_TEXTURE_3D:
      return GL_TRUE;
   case GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB:
   case GL_PROXY_TEXTURE_CUBE_MAP_ARB:
      return ctx->Extensions.ARB_texture_cube_map;
   case GL_TEXTURE_CUBE_MAP_ARRAY_ARB:
   case GL_PROXY_TEXTURE_CUBE_MAP_ARRAY_ARB:
      return ctx->Extensions.ARB_texture_cube_map_array;
   case GL_TEXTURE_RECTANGLE_NV:
   case GL_PROXY_TEXTURE_RECTANGLE_NV:
      return ctx->Extensions.NV_texture_rectangle;
   case GL_TEXTURE_1D_ARRAY_EXT:
   case GL_PROXY_TEXTURE_1D_ARRAY_EXT:
   case GL_TEXTURE_2D_ARRAY_EXT:
   case GL_PROXY_TEXTURE_2D_ARRAY_EXT:
      return ctx->Extensions.EXT_texture_array;
   case GL_TEXTURE_BUFFER:
      /* GetTexLevelParameter accepts GL_TEXTURE_BUFFER in GL 3.1+ contexts,
       * but not in earlier versions that expose ARB_texture_buffer_object.
       *
       * From the ARB_texture_buffer_object spec:
       * "(7) Do buffer textures support texture parameters (TexParameter) or
       *      queries (GetTexParameter, GetTexLevelParameter, GetTexImage)?
       *
       *    RESOLVED:  No. [...] Note that the spec edits above don't add
       *    explicit error language for any of these cases.  That is because
       *    each of the functions enumerate the set of valid <target>
       *    parameters.  Not editing the spec to allow TEXTURE_BUFFER_ARB in
       *    these cases means that target is not legal, and an INVALID_ENUM
       *    error should be generated."
       *
       * From the OpenGL 3.1 spec:
       * "target may also be TEXTURE_BUFFER, indicating the texture buffer."
       */
      return ctx->API == API_OPENGL_CORE && ctx->Version >= 31;
   case GL_TEXTURE_2D_MULTISAMPLE:
   case GL_TEXTURE_2D_MULTISAMPLE_ARRAY:
   case GL_PROXY_TEXTURE_2D_MULTISAMPLE:
   case GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY:
      return ctx->Extensions.ARB_texture_multisample;
   default:
      return GL_FALSE;
   }
}


static void
get_tex_level_parameter_image(struct gl_context *ctx,
                              const struct gl_texture_object *texObj,
                              GLenum target, GLint level,
                              GLenum pname, GLint *params)
{
   const struct gl_texture_image *img = NULL;
   struct gl_texture_image dummy_image;
   mesa_format texFormat;

   img = _mesa_select_tex_image(ctx, texObj, target, level);
   if (!img || img->TexFormat == MESA_FORMAT_NONE) {
      /* In case of undefined texture image return the default values.
       *
       * From OpenGL 4.0 spec, page 398:
       *    "The initial internal format of a texel array is RGBA
       *     instead of 1. TEXTURE_COMPONENTS is deprecated; always
       *     use TEXTURE_INTERNAL_FORMAT."
       */
      memset(&dummy_image, 0, sizeof(dummy_image));
      dummy_image.TexFormat = MESA_FORMAT_NONE;
      dummy_image.InternalFormat = GL_RGBA;
      dummy_image._BaseFormat = GL_NONE;

      img = &dummy_image;
   }

   texFormat = img->TexFormat;

   switch (pname) {
      case GL_TEXTURE_WIDTH:
         *params = img->Width;
         break;
      case GL_TEXTURE_HEIGHT:
         *params = img->Height;
         break;
      case GL_TEXTURE_DEPTH:
         *params = img->Depth;
         break;
      case GL_TEXTURE_INTERNAL_FORMAT:
         if (_mesa_is_format_compressed(texFormat)) {
            /* need to return the actual compressed format */
            *params = _mesa_compressed_format_to_glenum(ctx, texFormat);
         }
         else {
	    /* If the true internal format is not compressed but the user
	     * requested a generic compressed format, we have to return the
	     * generic base format that matches.
	     *
	     * From page 119 (page 129 of the PDF) of the OpenGL 1.3 spec:
	     *
	     *     "If no specific compressed format is available,
	     *     internalformat is instead replaced by the corresponding base
	     *     internal format."
	     *
	     * Otherwise just return the user's requested internal format
	     */
	    const GLenum f =
	       _mesa_gl_compressed_format_base_format(img->InternalFormat);

	    *params = (f != 0) ? f : img->InternalFormat;
	 }
         break;
      case GL_TEXTURE_BORDER:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_pname;
         *params = img->Border;
         break;
      case GL_TEXTURE_RED_SIZE:
      case GL_TEXTURE_GREEN_SIZE:
      case GL_TEXTURE_BLUE_SIZE:
      case GL_TEXTURE_ALPHA_SIZE:
         if (_mesa_base_format_has_channel(img->_BaseFormat, pname))
            *params = _mesa_get_format_bits(texFormat, pname);
         else
            *params = 0;
         break;
      case GL_TEXTURE_INTENSITY_SIZE:
      case GL_TEXTURE_LUMINANCE_SIZE:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_pname;
         if (_mesa_base_format_has_channel(img->_BaseFormat, pname)) {
            *params = _mesa_get_format_bits(texFormat, pname);
            if (*params == 0) {
               /* intensity or luminance is probably stored as RGB[A] */
               *params = MIN2(_mesa_get_format_bits(texFormat,
                                                    GL_TEXTURE_RED_SIZE),
                              _mesa_get_format_bits(texFormat,
                                                    GL_TEXTURE_GREEN_SIZE));
            }
         }
         else {
            *params = 0;
         }
         break;
      case GL_TEXTURE_DEPTH_SIZE_ARB:
         if (!ctx->Extensions.ARB_depth_texture)
            goto invalid_pname;
         *params = _mesa_get_format_bits(texFormat, pname);
         break;
      case GL_TEXTURE_STENCIL_SIZE:
         *params = _mesa_get_format_bits(texFormat, pname);
         break;
      case GL_TEXTURE_SHARED_SIZE:
         if (ctx->Version < 30 &&
             !ctx->Extensions.EXT_texture_shared_exponent)
            goto invalid_pname;
         *params = texFormat == MESA_FORMAT_R9G9B9E5_FLOAT ? 5 : 0;
         break;

      /* GL_ARB_texture_compression */
      case GL_TEXTURE_COMPRESSED_IMAGE_SIZE:
	 if (_mesa_is_format_compressed(texFormat) &&
             !_mesa_is_proxy_texture(target)) {
            *params = _mesa_format_image_size(texFormat, img->Width,
                                              img->Height, img->Depth);
	 }
	 else {
	    _mesa_error(ctx, GL_INVALID_OPERATION,
			"glGetTexLevelParameter[if]v(pname)");
	 }
         break;
      case GL_TEXTURE_COMPRESSED:
         *params = (GLint) _mesa_is_format_compressed(texFormat);
         break;

      /* GL_ARB_texture_float */
      case GL_TEXTURE_LUMINANCE_TYPE_ARB:
      case GL_TEXTURE_INTENSITY_TYPE_ARB:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_pname;
         /* FALLTHROUGH */
      case GL_TEXTURE_RED_TYPE_ARB:
      case GL_TEXTURE_GREEN_TYPE_ARB:
      case GL_TEXTURE_BLUE_TYPE_ARB:
      case GL_TEXTURE_ALPHA_TYPE_ARB:
      case GL_TEXTURE_DEPTH_TYPE_ARB:
         if (!ctx->Extensions.ARB_texture_float)
            goto invalid_pname;
	 if (_mesa_base_format_has_channel(img->_BaseFormat, pname))
	    *params = _mesa_get_format_datatype(texFormat);
	 else
	    *params = GL_NONE;
         break;

      /* GL_ARB_texture_multisample */
      case GL_TEXTURE_SAMPLES:
         if (!ctx->Extensions.ARB_texture_multisample)
            goto invalid_pname;
         *params = img->NumSamples;
         break;

      case GL_TEXTURE_FIXED_SAMPLE_LOCATIONS:
         if (!ctx->Extensions.ARB_texture_multisample)
            goto invalid_pname;
         *params = img->FixedSampleLocations;
         break;

      default:
         goto invalid_pname;
   }

   /* no error if we get here */
   return;

invalid_pname:
   _mesa_error(ctx, GL_INVALID_ENUM,
               "glGetTexLevelParameter[if]v(pname=%s)",
               _mesa_lookup_enum_by_nr(pname));
}


static void
get_tex_level_parameter_buffer(struct gl_context *ctx,
                               const struct gl_texture_object *texObj,
                               GLenum pname, GLint *params)
{
   const struct gl_buffer_object *bo = texObj->BufferObject;
   mesa_format texFormat = texObj->_BufferObjectFormat;
   GLenum internalFormat = texObj->BufferObjectFormat;
   GLenum baseFormat = _mesa_get_format_base_format(texFormat);

   if (!bo) {
      /* undefined texture buffer object */
      *params = pname == GL_TEXTURE_COMPONENTS ? 1 : 0;
      return;
   }

   switch (pname) {
      case GL_TEXTURE_BUFFER_DATA_STORE_BINDING:
         *params = bo->Name;
         break;
      case GL_TEXTURE_WIDTH:
         *params = bo->Size;
         break;
      case GL_TEXTURE_HEIGHT:
      case GL_TEXTURE_DEPTH:
      case GL_TEXTURE_BORDER:
      case GL_TEXTURE_SHARED_SIZE:
      case GL_TEXTURE_COMPRESSED:
         *params = 0;
         break;
      case GL_TEXTURE_INTERNAL_FORMAT:
         *params = internalFormat;
         break;
      case GL_TEXTURE_RED_SIZE:
      case GL_TEXTURE_GREEN_SIZE:
      case GL_TEXTURE_BLUE_SIZE:
      case GL_TEXTURE_ALPHA_SIZE:
         if (_mesa_base_format_has_channel(baseFormat, pname))
            *params = _mesa_get_format_bits(texFormat, pname);
         else
            *params = 0;
         break;
      case GL_TEXTURE_INTENSITY_SIZE:
      case GL_TEXTURE_LUMINANCE_SIZE:
         if (_mesa_base_format_has_channel(baseFormat, pname)) {
            *params = _mesa_get_format_bits(texFormat, pname);
            if (*params == 0) {
               /* intensity or luminance is probably stored as RGB[A] */
               *params = MIN2(_mesa_get_format_bits(texFormat,
                                                    GL_TEXTURE_RED_SIZE),
                              _mesa_get_format_bits(texFormat,
                                                    GL_TEXTURE_GREEN_SIZE));
            }
         } else {
            *params = 0;
         }
         break;
      case GL_TEXTURE_DEPTH_SIZE_ARB:
      case GL_TEXTURE_STENCIL_SIZE_EXT:
         *params = _mesa_get_format_bits(texFormat, pname);
         break;

      /* GL_ARB_texture_buffer_range */
      case GL_TEXTURE_BUFFER_OFFSET:
         if (!ctx->Extensions.ARB_texture_buffer_range)
            goto invalid_pname;
         *params = texObj->BufferOffset;
         break;
      case GL_TEXTURE_BUFFER_SIZE:
         if (!ctx->Extensions.ARB_texture_buffer_range)
            goto invalid_pname;
         *params = (texObj->BufferSize == -1) ? bo->Size : texObj->BufferSize;
         break;

      /* GL_ARB_texture_compression */
      case GL_TEXTURE_COMPRESSED_IMAGE_SIZE:
         /* Always illegal for GL_TEXTURE_BUFFER */
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glGetTexLevelParameter[if]v(pname)");
         break;

      /* GL_ARB_texture_float */
      case GL_TEXTURE_RED_TYPE_ARB:
      case GL_TEXTURE_GREEN_TYPE_ARB:
      case GL_TEXTURE_BLUE_TYPE_ARB:
      case GL_TEXTURE_ALPHA_TYPE_ARB:
      case GL_TEXTURE_LUMINANCE_TYPE_ARB:
      case GL_TEXTURE_INTENSITY_TYPE_ARB:
      case GL_TEXTURE_DEPTH_TYPE_ARB:
         if (!ctx->Extensions.ARB_texture_float)
            goto invalid_pname;
         if (_mesa_base_format_has_channel(baseFormat, pname))
            *params = _mesa_get_format_datatype(texFormat);
         else
            *params = GL_NONE;
         break;

      default:
         goto invalid_pname;
   }

   /* no error if we get here */
   return;

invalid_pname:
   _mesa_error(ctx, GL_INVALID_ENUM,
               "glGetTexLevelParameter[if]v(pname=%s)",
               _mesa_lookup_enum_by_nr(pname));
}


void GLAPIENTRY
_mesa_GetTexLevelParameterfv( GLenum target, GLint level,
                              GLenum pname, GLfloat *params )
{
   GLint iparam;
   _mesa_GetTexLevelParameteriv( target, level, pname, &iparam );
   *params = (GLfloat) iparam;
}


void GLAPIENTRY
_mesa_GetTexLevelParameteriv( GLenum target, GLint level,
                              GLenum pname, GLint *params )
{
   struct gl_texture_object *texObj;
   GLint maxLevels;
   GET_CURRENT_CONTEXT(ctx);

   if (ctx->Texture.CurrentUnit >= ctx->Const.MaxCombinedTextureImageUnits) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glGetTexLevelParameteriv(current unit)");
      return;
   }

   if (!legal_get_tex_level_parameter_target(ctx, target)) {
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "glGetTexLevelParameter[if]v(target=0x%x)", target);
      return;
   }

   maxLevels = _mesa_max_texture_levels(ctx, target);
   assert(maxLevels != 0);

   if (level < 0 || level >= maxLevels) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glGetTexLevelParameter[if]v" );
      return;
   }

   texObj = _mesa_get_current_tex_object(ctx, target);

   if (target == GL_TEXTURE_BUFFER)
      get_tex_level_parameter_buffer(ctx, texObj, pname, params);
   else
      get_tex_level_parameter_image(ctx, texObj, target, level, pname, params);
}


void GLAPIENTRY
_mesa_GetTexParameterfv( GLenum target, GLenum pname, GLfloat *params )
{
   struct gl_texture_object *obj;
   GET_CURRENT_CONTEXT(ctx);

   obj = get_texobj(ctx, target, GL_TRUE);
   if (!obj)
      return;

   _mesa_lock_texture(ctx, obj);
   switch (pname) {
      case GL_TEXTURE_MAG_FILTER:
	 *params = ENUM_TO_FLOAT(obj->Sampler.MagFilter);
	 break;
      case GL_TEXTURE_MIN_FILTER:
         *params = ENUM_TO_FLOAT(obj->Sampler.MinFilter);
         break;
      case GL_TEXTURE_WRAP_S:
         *params = ENUM_TO_FLOAT(obj->Sampler.WrapS);
         break;
      case GL_TEXTURE_WRAP_T:
         *params = ENUM_TO_FLOAT(obj->Sampler.WrapT);
         break;
      case GL_TEXTURE_WRAP_R:
         *params = ENUM_TO_FLOAT(obj->Sampler.WrapR);
         break;
      case GL_TEXTURE_BORDER_COLOR:
         if (!_mesa_is_desktop_gl(ctx))
            goto invalid_pname;

         if (ctx->NewState & (_NEW_BUFFERS | _NEW_FRAG_CLAMP))
            _mesa_update_state_locked(ctx);
         if (_mesa_get_clamp_fragment_color(ctx)) {
            params[0] = CLAMP(obj->Sampler.BorderColor.f[0], 0.0F, 1.0F);
            params[1] = CLAMP(obj->Sampler.BorderColor.f[1], 0.0F, 1.0F);
            params[2] = CLAMP(obj->Sampler.BorderColor.f[2], 0.0F, 1.0F);
            params[3] = CLAMP(obj->Sampler.BorderColor.f[3], 0.0F, 1.0F);
         }
         else {
            params[0] = obj->Sampler.BorderColor.f[0];
            params[1] = obj->Sampler.BorderColor.f[1];
            params[2] = obj->Sampler.BorderColor.f[2];
            params[3] = obj->Sampler.BorderColor.f[3];
         }
         break;
      case GL_TEXTURE_RESIDENT:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_pname;

         *params = 1.0F;
         break;
      case GL_TEXTURE_PRIORITY:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_pname;

         *params = obj->Priority;
         break;
      case GL_TEXTURE_MIN_LOD:
         if (!_mesa_is_desktop_gl(ctx) && !_mesa_is_gles3(ctx))
            goto invalid_pname;

         *params = obj->Sampler.MinLod;
         break;
      case GL_TEXTURE_MAX_LOD:
         if (!_mesa_is_desktop_gl(ctx) && !_mesa_is_gles3(ctx))
            goto invalid_pname;

         *params = obj->Sampler.MaxLod;
         break;
      case GL_TEXTURE_BASE_LEVEL:
         if (!_mesa_is_desktop_gl(ctx) && !_mesa_is_gles3(ctx))
            goto invalid_pname;

         *params = (GLfloat) obj->BaseLevel;
         break;
      case GL_TEXTURE_MAX_LEVEL:
         *params = (GLfloat) obj->MaxLevel;
         break;
      case GL_TEXTURE_MAX_ANISOTROPY_EXT:
         if (!ctx->Extensions.EXT_texture_filter_anisotropic)
            goto invalid_pname;
         *params = obj->Sampler.MaxAnisotropy;
         break;
      case GL_GENERATE_MIPMAP_SGIS:
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_pname;

	 *params = (GLfloat) obj->GenerateMipmap;
         break;
      case GL_TEXTURE_COMPARE_MODE_ARB:
         if ((!_mesa_is_desktop_gl(ctx) || !ctx->Extensions.ARB_shadow)
             && !_mesa_is_gles3(ctx))
            goto invalid_pname;
         *params = (GLfloat) obj->Sampler.CompareMode;
         break;
      case GL_TEXTURE_COMPARE_FUNC_ARB:
         if ((!_mesa_is_desktop_gl(ctx) || !ctx->Extensions.ARB_shadow)
             && !_mesa_is_gles3(ctx))
            goto invalid_pname;
         *params = (GLfloat) obj->Sampler.CompareFunc;
         break;
      case GL_DEPTH_TEXTURE_MODE_ARB:
         /* GL_DEPTH_TEXTURE_MODE_ARB is removed in core-profile and it has
          * never existed in OpenGL ES.
          */
         if (ctx->API != API_OPENGL_COMPAT || !ctx->Extensions.ARB_depth_texture)
            goto invalid_pname;
         *params = (GLfloat) obj->DepthMode;
         break;
      case GL_DEPTH_STENCIL_TEXTURE_MODE:
         if (!_mesa_is_desktop_gl(ctx) || !ctx->Extensions.ARB_stencil_texturing)
            goto invalid_pname;
         *params = (GLfloat)
            (obj->StencilSampling ? GL_STENCIL_INDEX : GL_DEPTH_COMPONENT);
         break;
      case GL_TEXTURE_LOD_BIAS:
         if (_mesa_is_gles(ctx))
            goto invalid_pname;

         *params = obj->Sampler.LodBias;
         break;
      case GL_TEXTURE_CROP_RECT_OES:
         if (ctx->API != API_OPENGLES || !ctx->Extensions.OES_draw_texture)
            goto invalid_pname;

         params[0] = (GLfloat) obj->CropRect[0];
         params[1] = (GLfloat) obj->CropRect[1];
         params[2] = (GLfloat) obj->CropRect[2];
         params[3] = (GLfloat) obj->CropRect[3];
         break;

      case GL_TEXTURE_SWIZZLE_R_EXT:
      case GL_TEXTURE_SWIZZLE_G_EXT:
      case GL_TEXTURE_SWIZZLE_B_EXT:
      case GL_TEXTURE_SWIZZLE_A_EXT:
         if ((!_mesa_is_desktop_gl(ctx)
              || !ctx->Extensions.EXT_texture_swizzle)
             && !_mesa_is_gles3(ctx))
            goto invalid_pname;
         *params = (GLfloat) obj->Swizzle[pname - GL_TEXTURE_SWIZZLE_R_EXT];
         break;

      case GL_TEXTURE_SWIZZLE_RGBA_EXT:
         if ((!_mesa_is_desktop_gl(ctx)
              || !ctx->Extensions.EXT_texture_swizzle)
             && !_mesa_is_gles3(ctx)) {
            goto invalid_pname;
         }
         else {
            GLuint comp;
            for (comp = 0; comp < 4; comp++) {
               params[comp] = (GLfloat) obj->Swizzle[comp];
            }
         }
         break;

      case GL_TEXTURE_CUBE_MAP_SEAMLESS:
         if (!_mesa_is_desktop_gl(ctx)
             || !ctx->Extensions.AMD_seamless_cubemap_per_texture)
            goto invalid_pname;
         *params = (GLfloat) obj->Sampler.CubeMapSeamless;
         break;

      case GL_TEXTURE_IMMUTABLE_FORMAT:
         *params = (GLfloat) obj->Immutable;
         break;

      case GL_TEXTURE_IMMUTABLE_LEVELS:
         if (_mesa_is_gles3(ctx) ||
             (_mesa_is_desktop_gl(ctx) && ctx->Extensions.ARB_texture_view))
            *params = (GLfloat) obj->ImmutableLevels;
         else
            goto invalid_pname;
         break;

      case GL_TEXTURE_VIEW_MIN_LEVEL:
         if (!ctx->Extensions.ARB_texture_view)
            goto invalid_pname;
         *params = (GLfloat) obj->MinLevel;
         break;

      case GL_TEXTURE_VIEW_NUM_LEVELS:
         if (!ctx->Extensions.ARB_texture_view)
            goto invalid_pname;
         *params = (GLfloat) obj->NumLevels;
         break;

      case GL_TEXTURE_VIEW_MIN_LAYER:
         if (!ctx->Extensions.ARB_texture_view)
            goto invalid_pname;
         *params = (GLfloat) obj->MinLayer;
         break;

      case GL_TEXTURE_VIEW_NUM_LAYERS:
         if (!ctx->Extensions.ARB_texture_view)
            goto invalid_pname;
         *params = (GLfloat) obj->NumLayers;
         break;

      case GL_REQUIRED_TEXTURE_IMAGE_UNITS_OES:
         if (!_mesa_is_gles(ctx) || !ctx->Extensions.OES_EGL_image_external)
            goto invalid_pname;
         *params = (GLfloat) obj->RequiredTextureImageUnits;
         break;

      case GL_TEXTURE_SRGB_DECODE_EXT:
         if (!ctx->Extensions.EXT_texture_sRGB_decode)
            goto invalid_pname;
         *params = (GLfloat) obj->Sampler.sRGBDecode;
         break;

      default:
         goto invalid_pname;
   }

   /* no error if we get here */
   _mesa_unlock_texture(ctx, obj);
   return;

invalid_pname:
   _mesa_unlock_texture(ctx, obj);
   _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexParameterfv(pname=0x%x)", pname);
}


void GLAPIENTRY
_mesa_GetTexParameteriv( GLenum target, GLenum pname, GLint *params )
{
   struct gl_texture_object *obj;
   GET_CURRENT_CONTEXT(ctx);

   obj = get_texobj(ctx, target, GL_TRUE);
   if (!obj)
      return;

   _mesa_lock_texture(ctx, obj);
   switch (pname) {
      case GL_TEXTURE_MAG_FILTER:
         *params = (GLint) obj->Sampler.MagFilter;
         break;
      case GL_TEXTURE_MIN_FILTER:
         *params = (GLint) obj->Sampler.MinFilter;
         break;
      case GL_TEXTURE_WRAP_S:
         *params = (GLint) obj->Sampler.WrapS;
         break;
      case GL_TEXTURE_WRAP_T:
         *params = (GLint) obj->Sampler.WrapT;
         break;
      case GL_TEXTURE_WRAP_R:
         *params = (GLint) obj->Sampler.WrapR;
         break;
      case GL_TEXTURE_BORDER_COLOR:
         if (!_mesa_is_desktop_gl(ctx))
            goto invalid_pname;

         {
            GLfloat b[4];
            b[0] = CLAMP(obj->Sampler.BorderColor.f[0], 0.0F, 1.0F);
            b[1] = CLAMP(obj->Sampler.BorderColor.f[1], 0.0F, 1.0F);
            b[2] = CLAMP(obj->Sampler.BorderColor.f[2], 0.0F, 1.0F);
            b[3] = CLAMP(obj->Sampler.BorderColor.f[3], 0.0F, 1.0F);
            params[0] = FLOAT_TO_INT(b[0]);
            params[1] = FLOAT_TO_INT(b[1]);
            params[2] = FLOAT_TO_INT(b[2]);
            params[3] = FLOAT_TO_INT(b[3]);
         }
         break;
      case GL_TEXTURE_RESIDENT:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_pname;

         *params = 1;
         break;
      case GL_TEXTURE_PRIORITY:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_pname;

         *params = FLOAT_TO_INT(obj->Priority);
         break;
      case GL_TEXTURE_MIN_LOD:
         if (!_mesa_is_desktop_gl(ctx) && !_mesa_is_gles3(ctx))
            goto invalid_pname;

         *params = (GLint) obj->Sampler.MinLod;
         break;
      case GL_TEXTURE_MAX_LOD:
         if (!_mesa_is_desktop_gl(ctx) && !_mesa_is_gles3(ctx))
            goto invalid_pname;

         *params = (GLint) obj->Sampler.MaxLod;
         break;
      case GL_TEXTURE_BASE_LEVEL:
         if (!_mesa_is_desktop_gl(ctx) && !_mesa_is_gles3(ctx))
            goto invalid_pname;

         *params = obj->BaseLevel;
         break;
      case GL_TEXTURE_MAX_LEVEL:
         *params = obj->MaxLevel;
         break;
      case GL_TEXTURE_MAX_ANISOTROPY_EXT:
         if (!ctx->Extensions.EXT_texture_filter_anisotropic)
            goto invalid_pname;
         *params = (GLint) obj->Sampler.MaxAnisotropy;
         break;
      case GL_GENERATE_MIPMAP_SGIS:
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_pname;

	 *params = (GLint) obj->GenerateMipmap;
         break;
      case GL_TEXTURE_COMPARE_MODE_ARB:
         if ((!_mesa_is_desktop_gl(ctx) || !ctx->Extensions.ARB_shadow)
             && !_mesa_is_gles3(ctx))
            goto invalid_pname;
         *params = (GLint) obj->Sampler.CompareMode;
         break;
      case GL_TEXTURE_COMPARE_FUNC_ARB:
         if ((!_mesa_is_desktop_gl(ctx) || !ctx->Extensions.ARB_shadow)
             && !_mesa_is_gles3(ctx))
            goto invalid_pname;
         *params = (GLint) obj->Sampler.CompareFunc;
         break;
      case GL_DEPTH_TEXTURE_MODE_ARB:
         if (ctx->API != API_OPENGL_COMPAT || !ctx->Extensions.ARB_depth_texture)
            goto invalid_pname;
         *params = (GLint) obj->DepthMode;
         break;
      case GL_DEPTH_STENCIL_TEXTURE_MODE:
         if (!_mesa_is_desktop_gl(ctx) || !ctx->Extensions.ARB_stencil_texturing)
            goto invalid_pname;
         *params = (GLint)
            (obj->StencilSampling ? GL_STENCIL_INDEX : GL_DEPTH_COMPONENT);
         break;
      case GL_TEXTURE_LOD_BIAS:
         if (_mesa_is_gles(ctx))
            goto invalid_pname;

         /* GL spec 'Data Conversions' section specifies that floating-point
          * value in integer Get function is rounded to nearest integer
          */
         *params = IROUND(obj->Sampler.LodBias);
         break;
      case GL_TEXTURE_CROP_RECT_OES:
         if (ctx->API != API_OPENGLES || !ctx->Extensions.OES_draw_texture)
            goto invalid_pname;

         params[0] = obj->CropRect[0];
         params[1] = obj->CropRect[1];
         params[2] = obj->CropRect[2];
         params[3] = obj->CropRect[3];
         break;
      case GL_TEXTURE_SWIZZLE_R_EXT:
      case GL_TEXTURE_SWIZZLE_G_EXT:
      case GL_TEXTURE_SWIZZLE_B_EXT:
      case GL_TEXTURE_SWIZZLE_A_EXT:
         if ((!_mesa_is_desktop_gl(ctx)
              || !ctx->Extensions.EXT_texture_swizzle)
             && !_mesa_is_gles3(ctx))
            goto invalid_pname;
         *params = obj->Swizzle[pname - GL_TEXTURE_SWIZZLE_R_EXT];
         break;

      case GL_TEXTURE_SWIZZLE_RGBA_EXT:
         if ((!_mesa_is_desktop_gl(ctx)
              || !ctx->Extensions.EXT_texture_swizzle)
             && !_mesa_is_gles3(ctx))
            goto invalid_pname;
         COPY_4V(params, obj->Swizzle);
         break;

      case GL_TEXTURE_CUBE_MAP_SEAMLESS:
         if (!_mesa_is_desktop_gl(ctx)
             || !ctx->Extensions.AMD_seamless_cubemap_per_texture)
            goto invalid_pname;
         *params = (GLint) obj->Sampler.CubeMapSeamless;
         break;

      case GL_TEXTURE_IMMUTABLE_FORMAT:
         *params = (GLint) obj->Immutable;
         break;

      case GL_TEXTURE_IMMUTABLE_LEVELS:
         if (_mesa_is_gles3(ctx) ||
             (_mesa_is_desktop_gl(ctx) && ctx->Extensions.ARB_texture_view))
            *params = obj->ImmutableLevels;
         else
            goto invalid_pname;
         break;

      case GL_TEXTURE_VIEW_MIN_LEVEL:
         if (!ctx->Extensions.ARB_texture_view)
            goto invalid_pname;
         *params = (GLint) obj->MinLevel;
         break;

      case GL_TEXTURE_VIEW_NUM_LEVELS:
         if (!ctx->Extensions.ARB_texture_view)
            goto invalid_pname;
         *params = (GLint) obj->NumLevels;
         break;

      case GL_TEXTURE_VIEW_MIN_LAYER:
         if (!ctx->Extensions.ARB_texture_view)
            goto invalid_pname;
         *params = (GLint) obj->MinLayer;
         break;

      case GL_TEXTURE_VIEW_NUM_LAYERS:
         if (!ctx->Extensions.ARB_texture_view)
            goto invalid_pname;
         *params = (GLint) obj->NumLayers;
         break;

      case GL_REQUIRED_TEXTURE_IMAGE_UNITS_OES:
         if (!_mesa_is_gles(ctx) || !ctx->Extensions.OES_EGL_image_external)
            goto invalid_pname;
         *params = obj->RequiredTextureImageUnits;
         break;

      case GL_TEXTURE_SRGB_DECODE_EXT:
         if (!ctx->Extensions.EXT_texture_sRGB_decode)
            goto invalid_pname;
         *params = obj->Sampler.sRGBDecode;
         break;

      case GL_IMAGE_FORMAT_COMPATIBILITY_TYPE:
         if (!ctx->Extensions.ARB_shader_image_load_store)
            goto invalid_pname;
         *params = obj->ImageFormatCompatibilityType;
         break;

      default:
         goto invalid_pname;
   }

   /* no error if we get here */
   _mesa_unlock_texture(ctx, obj);
   return;

invalid_pname:
   _mesa_unlock_texture(ctx, obj);
   _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexParameteriv(pname=0x%x)", pname);
}


/** New in GL 3.0 */
void GLAPIENTRY
_mesa_GetTexParameterIiv(GLenum target, GLenum pname, GLint *params)
{
   struct gl_texture_object *texObj;
   GET_CURRENT_CONTEXT(ctx);

   texObj = get_texobj(ctx, target, GL_TRUE);
   if (!texObj)
      return;

   switch (pname) {
   case GL_TEXTURE_BORDER_COLOR:
      COPY_4V(params, texObj->Sampler.BorderColor.i);
      break;
   default:
      _mesa_GetTexParameteriv(target, pname, params);
   }
}


/** New in GL 3.0 */
void GLAPIENTRY
_mesa_GetTexParameterIuiv(GLenum target, GLenum pname, GLuint *params)
{
   struct gl_texture_object *texObj;
   GET_CURRENT_CONTEXT(ctx);

   texObj = get_texobj(ctx, target, GL_TRUE);
   if (!texObj)
      return;

   switch (pname) {
   case GL_TEXTURE_BORDER_COLOR:
      COPY_4V(params, texObj->Sampler.BorderColor.i);
      break;
   default:
      {
         GLint ip[4];
         _mesa_GetTexParameteriv(target, pname, ip);
         params[0] = ip[0];
         if (pname == GL_TEXTURE_SWIZZLE_RGBA_EXT ||
             pname == GL_TEXTURE_CROP_RECT_OES) {
            params[1] = ip[1];
            params[2] = ip[2];
            params[3] = ip[3];
         }
      }
   }
}
@


1.10
log
@Merge Mesa 10.2.9
@
text
@@


1.9
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d1387 1
a1387 1
   _mesa_lock_context_textures(ctx);
d1594 1
a1594 1
   _mesa_unlock_context_textures(ctx);
d1598 1
a1598 1
   _mesa_unlock_context_textures(ctx);
@


1.8
log
@Merge Mesa 10.2.7
@
text
@d1387 1
a1387 1
   _mesa_lock_texture(ctx, obj);
d1594 1
a1594 1
   _mesa_unlock_texture(ctx, obj);
d1598 1
a1598 1
   _mesa_unlock_texture(ctx, obj);
@


1.7
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d1054 1
d1066 4
d1071 1
a1071 5
      if (pname == GL_TEXTURE_INTERNAL_FORMAT)
         *params = GL_RGBA;
      else
         *params = 0;
      return;
d1111 2
d1126 2
d1174 5
a1182 2
      case GL_TEXTURE_LUMINANCE_TYPE_ARB:
      case GL_TEXTURE_INTENSITY_TYPE_ARB:
@


1.6
log
@Merge Mesa 9.2.5
@
text
@d26 1
a26 1
/** 
d55 1
a55 1
static GLboolean 
d87 6
d94 3
a96 3
      supported = is_desktop_gl 
         && (e->ATI_texture_mirror_once || e->EXT_texture_mirror_clamp)
	 && (target != GL_TEXTURE_RECTANGLE_NV)
d102 1
a102 1
	 && (target != GL_TEXTURE_RECTANGLE_NV)
d121 2
a122 2
 * Note that this is different from _mesa_select_tex_object() in that proxy
 * targets are not accepted.
d129 1
d139 5
a143 58
   switch (target) {
   case GL_TEXTURE_1D:
      if (_mesa_is_desktop_gl(ctx))
         return texUnit->CurrentTex[TEXTURE_1D_INDEX];
      break;
   case GL_TEXTURE_2D:
      return texUnit->CurrentTex[TEXTURE_2D_INDEX];
   case GL_TEXTURE_3D:
      if (ctx->API != API_OPENGLES)
         return texUnit->CurrentTex[TEXTURE_3D_INDEX];
      break;
   case GL_TEXTURE_CUBE_MAP:
      if (ctx->Extensions.ARB_texture_cube_map) {
         return texUnit->CurrentTex[TEXTURE_CUBE_INDEX];
      }
      break;
   case GL_TEXTURE_RECTANGLE_NV:
      if (_mesa_is_desktop_gl(ctx)
          && ctx->Extensions.NV_texture_rectangle) {
         return texUnit->CurrentTex[TEXTURE_RECT_INDEX];
      }
      break;
   case GL_TEXTURE_1D_ARRAY_EXT:
      if (_mesa_is_desktop_gl(ctx)
          && (ctx->Extensions.MESA_texture_array ||
              ctx->Extensions.EXT_texture_array)) {
         return texUnit->CurrentTex[TEXTURE_1D_ARRAY_INDEX];
      }
      break;
   case GL_TEXTURE_2D_ARRAY_EXT:
      if ((_mesa_is_desktop_gl(ctx) || _mesa_is_gles3(ctx))
          && (ctx->Extensions.MESA_texture_array ||
              ctx->Extensions.EXT_texture_array)) {
         return texUnit->CurrentTex[TEXTURE_2D_ARRAY_INDEX];
      }
      break;
   case GL_TEXTURE_EXTERNAL_OES:
      if (_mesa_is_gles(ctx) && ctx->Extensions.OES_EGL_image_external) {
         return texUnit->CurrentTex[TEXTURE_EXTERNAL_INDEX];
      }
      break;
   case GL_TEXTURE_CUBE_MAP_ARRAY:
      if (ctx->Extensions.ARB_texture_cube_map_array) {
         return texUnit->CurrentTex[TEXTURE_CUBE_ARRAY_INDEX];
      }
      break;
   case GL_TEXTURE_2D_MULTISAMPLE:
      if (ctx->Extensions.ARB_texture_multisample) {
         return texUnit->CurrentTex[TEXTURE_2D_MULTISAMPLE_INDEX];
      }
      break;
   case GL_TEXTURE_2D_MULTISAMPLE_ARRAY:
      if (ctx->Extensions.ARB_texture_multisample) {
         return texUnit->CurrentTex[TEXTURE_2D_MULTISAMPLE_ARRAY_INDEX];
      }
      break;
   default:
      ;
d145 1
d147 1
a147 3
   _mesa_error(ctx, GL_INVALID_ENUM,
                  "gl%sTexParameter(target)", get ? "Get" : "");
   return NULL;
d212 1
a212 1
   _mesa_dirty_texobj(ctx, texObj, GL_TRUE);
d342 7
a348 1
      texObj->BaseLevel = params[0];
d355 2
a356 1
      if (params[0] < 0 || texObj->Target == GL_TEXTURE_RECTANGLE_ARB) {
d362 13
a374 1
      texObj->MaxLevel = params[0];
d455 14
d488 1
a488 1
            _mesa_error(ctx, GL_INVALID_OPERATION,
d513 1
a513 1
               _mesa_error(ctx, GL_INVALID_OPERATION,
d725 1
d753 1
a753 1
      ctx->Driver.TexParameter(ctx, target, texObj, pname, &param);
d781 1
d825 1
a825 1
      ctx->Driver.TexParameter(ctx, target, texObj, pname, params);
d868 1
a868 1
      ctx->Driver.TexParameter(ctx, target, texObj, pname, &fparam);
d924 1
a924 1
      ctx->Driver.TexParameter(ctx, target, texObj, pname, fparams);
d1006 3
d1016 1
a1016 2
      return (ctx->Extensions.MESA_texture_array ||
              ctx->Extensions.EXT_texture_array);
d1054 1
a1054 1
   gl_format texFormat;
d1058 10
a1067 3
      /* undefined texture image */
      if (pname == GL_TEXTURE_COMPONENTS)
         *params = 1;
d1142 1
a1142 4
      case GL_TEXTURE_STENCIL_SIZE_EXT:
         if (!ctx->Extensions.EXT_packed_depth_stencil &&
             !ctx->Extensions.ARB_framebuffer_object)
            goto invalid_pname;
d1149 1
a1149 1
         *params = texFormat == MESA_FORMAT_RGB9_E5_FLOAT ? 5 : 0;
d1217 1
a1217 1
   gl_format texFormat = texObj->_BufferObjectFormat;
a1335 1
   const struct gl_texture_unit *texUnit;
a1345 2
   texUnit = _mesa_get_current_tex_unit(ctx);

d1360 1
a1360 1
   texObj = _mesa_select_tex_object(ctx, texUnit, target);
d1479 6
d1538 21
a1558 1
         if (!_mesa_is_gles3(ctx))
d1560 7
a1566 1
         *params = (GLfloat) obj->ImmutableLevels;
d1699 6
d1712 1
a1712 1
         *params = (GLint) roundf(obj->Sampler.LodBias);
d1754 9
a1762 1
         if (!_mesa_is_gles3(ctx))
d1764 19
a1782 1
         *params = obj->ImmutableLevels;
d1797 6
d1827 1
a1827 1
   
d1848 1
a1848 1
   
d1858 1
a1858 1
         if (pname == GL_TEXTURE_SWIZZLE_RGBA_EXT || 
@


1.5
log
@Merge Mesa 9.2.0
@
text
@d663 2
a664 5
      /* NOTE: this is really part of OpenGL 1.4, not EXT_texture_lod_bias.
       * It was removed in core-profile, and it has never existed in OpenGL
       * ES.
       */
      if (ctx->API != API_OPENGL_COMPAT)
d1489 1
a1489 1
         if (ctx->API != API_OPENGL_COMPAT)
d1677 1
a1677 1
         if (ctx->API != API_OPENGL_COMPAT)
d1680 4
a1683 1
         *params = (GLint) obj->Sampler.LodBias;
@


1.4
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a2 1
 * Version:  7.5
d20 4
a23 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
d32 1
a32 1

d34 1
d39 1
a40 1
#include "main/mfeatures.h"
d44 1
a47 1
#include "main/texfetch.h"
d59 40
d100 3
a102 17
   if (wrap == GL_CLAMP || wrap == GL_CLAMP_TO_EDGE ||
       (wrap == GL_CLAMP_TO_BORDER && e->ARB_texture_border_clamp)) {
      /* any texture target */
      return GL_TRUE;
   }
   else if (target != GL_TEXTURE_RECTANGLE_NV &&
	    (wrap == GL_REPEAT ||
	     (wrap == GL_MIRRORED_REPEAT &&
	      e->ARB_texture_mirrored_repeat) ||
	     (wrap == GL_MIRROR_CLAMP_EXT &&
	      (e->ATI_texture_mirror_once || e->EXT_texture_mirror_clamp)) ||
	     (wrap == GL_MIRROR_CLAMP_TO_EDGE_EXT &&
	      (e->ATI_texture_mirror_once || e->EXT_texture_mirror_clamp)) ||
	     (wrap == GL_MIRROR_CLAMP_TO_BORDER_EXT &&
	      (e->EXT_texture_mirror_clamp)))) {
      /* non-rectangle texture */
      return GL_TRUE;
d105 4
a108 2
   _mesa_error( ctx, GL_INVALID_ENUM, "glTexParameter(param=0x%x)", wrap );
   return GL_FALSE;
d134 3
a136 1
      return texUnit->CurrentTex[TEXTURE_1D_INDEX];
d140 3
a142 1
      return texUnit->CurrentTex[TEXTURE_3D_INDEX];
d149 2
a150 1
      if (ctx->Extensions.NV_texture_rectangle) {
d155 3
a157 2
      if (ctx->Extensions.MESA_texture_array ||
          ctx->Extensions.EXT_texture_array) {
d162 3
a164 2
      if (ctx->Extensions.MESA_texture_array ||
          ctx->Extensions.EXT_texture_array) {
d168 20
d241 1
a241 1
static INLINE void
d250 1
a250 2
 * can effect texture completeness (texture base level, max level,
 * minification filter).
d255 1
a255 1
static INLINE void
d259 15
a273 1
   texObj->_Complete = GL_FALSE;
d288 3
d296 1
a296 1
         incomplete(ctx, texObj);
d303 3
a305 2
         if (texObj->Target != GL_TEXTURE_RECTANGLE_NV) {
            incomplete(ctx, texObj);
d316 3
d333 3
d346 3
d359 3
d372 3
d377 5
d395 1
d397 1
a397 1
         _mesa_error(ctx, GL_INVALID_OPERATION,
d406 5
d419 6
a424 1
      if (ctx->Extensions.ARB_shadow) {
d438 6
a443 1
      if (ctx->Extensions.ARB_shadow) {
a448 3
            flush(ctx);
            texObj->Sampler.CompareFunc = params[0];
            return GL_TRUE;
d455 3
a457 6
            if (ctx->Extensions.EXT_shadow_funcs) {
               flush(ctx);
               texObj->Sampler.CompareFunc = params[0];
               return GL_TRUE;
            }
            /* fall-through */
d465 5
a469 2
      if (ctx->Extensions.ARB_depth_texture) {
         if (texObj->Sampler.DepthMode == params[0])
d476 1
a476 1
            texObj->Sampler.DepthMode = params[0];
a482 1
#if FEATURE_OES_draw_texture
d484 3
a491 1
#endif
d497 2
a498 1
      if (ctx->Extensions.EXT_texture_swizzle) {
d507 5
a511 6
         if (swz >= 0) {
            flush(ctx);
            texObj->Swizzle[comp] = params[0];
            set_swizzle_component(&texObj->_Swizzle, comp, swz);
            return GL_TRUE;
         }
d516 2
a517 1
      if (ctx->Extensions.EXT_texture_swizzle) {
d537 7
a543 2
      if (ctx->Extensions.EXT_texture_sRGB_decode) {
	 GLenum decode = params[0];
a547 1
	       _mesa_update_fetch_functions(texObj);
d555 2
a556 1
      if (ctx->Extensions.AMD_seamless_cubemap_per_texture) {
d558 4
d586 5
d605 6
d618 6
d631 3
d640 3
d658 1
a658 2
            _mesa_error(ctx, GL_INVALID_ENUM,
                        "glTexParameter(pname=GL_TEXTURE_MAX_ANISOTROPY_EXT)");
d662 10
a671 13
   case GL_TEXTURE_COMPARE_FAIL_VALUE_ARB:
      if (ctx->Extensions.ARB_shadow_ambient) {
         if (texObj->Sampler.CompareFailValue != params[0]) {
            flush(ctx);
            texObj->Sampler.CompareFailValue = CLAMP(params[0], 0.0F, 1.0F);
            return GL_TRUE;
         }
      }
      else {
         _mesa_error(ctx, GL_INVALID_ENUM,
                    "glTexParameter(pname=GL_TEXTURE_COMPARE_FAIL_VALUE_ARB)");
      }
      return GL_FALSE;
d673 4
a676 9
   case GL_TEXTURE_LOD_BIAS:
      /* NOTE: this is really part of OpenGL 1.4, not EXT_texture_lod_bias */
      if (ctx->Extensions.EXT_texture_lod_bias) {
         if (texObj->Sampler.LodBias != params[0]) {
            flush(ctx);
            texObj->Sampler.LodBias = params[0];
            return GL_TRUE;
         }
         return GL_FALSE;
d681 6
d703 1
a703 1
      _mesa_error(ctx, GL_INVALID_ENUM, "glTexParameter(pname=0x%x)", pname);
d706 10
a724 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d744 4
a748 1
         /* convert float param to int */
d750 4
a753 1
         p[0] = (GLint) param;
a779 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
a806 2

#if FEATURE_OES_draw_texture
d818 16
a833 2
#endif

a850 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
a893 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
a953 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
a982 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d1002 2
a1003 5


void GLAPIENTRY
_mesa_GetTexLevelParameterfv( GLenum target, GLint level,
                              GLenum pname, GLfloat *params )
d1005 52
a1056 3
   GLint iparam;
   _mesa_GetTexLevelParameteriv( target, level, pname, &iparam );
   *params = (GLfloat) iparam;
d1060 5
a1064 3
void GLAPIENTRY
_mesa_GetTexLevelParameteriv( GLenum target, GLint level,
                              GLenum pname, GLint *params )
a1065 2
   const struct gl_texture_unit *texUnit;
   struct gl_texture_object *texObj;
a1066 1
   GLint maxLevels;
a1067 25
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   if (ctx->Texture.CurrentUnit >= ctx->Const.MaxCombinedTextureImageUnits) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glGetTexLevelParameteriv(current unit)");
      return;
   }

   texUnit = _mesa_get_current_tex_unit(ctx);

   /* this will catch bad target values */
   maxLevels = _mesa_max_texture_levels(ctx, target);
   if (maxLevels == 0) {
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "glGetTexLevelParameter[if]v(target=0x%x)", target);
      return;
   }

   if (level < 0 || level >= maxLevels) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glGetTexLevelParameter[if]v" );
      return;
   }

   texObj = _mesa_select_tex_object(ctx, texUnit, target);
d1070 1
a1070 1
   if (!img || !img->TexFormat) {
a1118 5
         if (img->_BaseFormat == GL_RED) {
            *params = _mesa_get_format_bits(texFormat, pname);
	    break;
	 }
	 /* FALLTHROUGH */
a1119 5
         if (img->_BaseFormat == GL_RG) {
            *params = _mesa_get_format_bits(texFormat, pname);
	    break;
	 }
	 /* FALLTHROUGH */
a1120 5
         if (img->_BaseFormat == GL_RGB || img->_BaseFormat == GL_RGBA)
            *params = _mesa_get_format_bits(texFormat, pname);
         else
            *params = 0;
         break;
d1122 1
a1122 3
         if (img->_BaseFormat == GL_ALPHA ||
             img->_BaseFormat == GL_LUMINANCE_ALPHA ||
             img->_BaseFormat == GL_RGBA)
d1128 2
a1129 3
         if (img->_BaseFormat != GL_INTENSITY)
            *params = 0;
         else {
d1132 5
a1136 3
               /* intensity probably stored as rgb texture */
               *params = MIN2(_mesa_get_format_bits(texFormat, GL_TEXTURE_RED_SIZE),
                              _mesa_get_format_bits(texFormat, GL_TEXTURE_GREEN_SIZE));
d1139 1
a1139 4
         break;
      case GL_TEXTURE_LUMINANCE_SIZE:
         if (img->_BaseFormat != GL_LUMINANCE &&
             img->_BaseFormat != GL_LUMINANCE_ALPHA)
a1140 7
         else {
            *params = _mesa_get_format_bits(texFormat, pname);
            if (*params == 0) {
               /* luminance probably stored as rgb texture */
               *params = MIN2(_mesa_get_format_bits(texFormat, GL_TEXTURE_RED_SIZE),
                              _mesa_get_format_bits(texFormat, GL_TEXTURE_GREEN_SIZE));
            }
a1142 6
      case GL_TEXTURE_INDEX_SIZE_EXT:
         if (img->_BaseFormat == GL_COLOR_INDEX)
            *params = _mesa_get_format_bits(texFormat, pname);
         else
            *params = 0;
         break;
d1144 1
a1144 3
         if (ctx->Extensions.ARB_depth_texture)
            *params = _mesa_get_format_bits(texFormat, pname);
         else
d1146 1
d1149 2
a1150 5
         if (ctx->Extensions.EXT_packed_depth_stencil ||
             ctx->Extensions.ARB_framebuffer_object) {
            *params = _mesa_get_format_bits(texFormat, pname);
         }
         else {
d1152 1
a1152 1
         }
d1155 2
a1156 5
         if (ctx->VersionMajor >= 3 ||
             ctx->Extensions.EXT_texture_shared_exponent) {
            *params = texFormat == MESA_FORMAT_RGB9_E5_FLOAT ? 5 : 0;
         }
         else {
d1158 1
a1158 1
         }
a1178 8
         if (ctx->Extensions.ARB_texture_float) {
            *params = _mesa_get_format_bits(texFormat, GL_TEXTURE_RED_SIZE) ?
               _mesa_get_format_datatype(texFormat) : GL_NONE;
         }
         else {
            goto invalid_pname;
         }
         break;
a1179 8
         if (ctx->Extensions.ARB_texture_float) {
            *params = _mesa_get_format_bits(texFormat, GL_TEXTURE_GREEN_SIZE) ?
               _mesa_get_format_datatype(texFormat) : GL_NONE;
         }
         else {
            goto invalid_pname;
         }
         break;
a1180 8
         if (ctx->Extensions.ARB_texture_float) {
            *params = _mesa_get_format_bits(texFormat, GL_TEXTURE_BLUE_SIZE) ?
               _mesa_get_format_datatype(texFormat) : GL_NONE;
         }
         else {
            goto invalid_pname;
         }
         break;
d1182 4
a1185 5
         if (ctx->Extensions.ARB_texture_float) {
            *params = _mesa_get_format_bits(texFormat, GL_TEXTURE_ALPHA_SIZE) ?
               _mesa_get_format_datatype(texFormat) : GL_NONE;
         }
         else {
d1187 4
a1190 1
         }
d1192 4
a1195 6
      case GL_TEXTURE_LUMINANCE_TYPE_ARB:
         if (ctx->Extensions.ARB_texture_float) {
            *params = _mesa_get_format_bits(texFormat, GL_TEXTURE_LUMINANCE_SIZE) ?
               _mesa_get_format_datatype(texFormat) : GL_NONE;
         }
         else {
d1197 1
a1197 1
         }
d1199 3
a1201 6
      case GL_TEXTURE_INTENSITY_TYPE_ARB:
         if (ctx->Extensions.ARB_texture_float) {
            *params = _mesa_get_format_bits(texFormat, GL_TEXTURE_INTENSITY_SIZE) ?
               _mesa_get_format_datatype(texFormat) : GL_NONE;
         }
         else {
d1203 1
a1203 1
         }
d1205 103
d1309 1
a1309 5
         if (ctx->Extensions.ARB_texture_float) {
            *params = _mesa_get_format_bits(texFormat, GL_TEXTURE_DEPTH_SIZE) ?
               _mesa_get_format_datatype(texFormat) : GL_NONE;
         }
         else {
d1311 4
a1314 1
         }
d1331 49
a1384 1
   GLboolean error = GL_FALSE;
a1385 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d1409 4
a1412 1
         if(ctx->NewState & (_NEW_BUFFERS | _NEW_FRAG_CLAMP))
d1414 1
a1414 2
         if(ctx->Color._ClampFragmentColor)
         {
d1420 1
a1420 2
         else
         {
d1428 4
a1431 8
         {
            GLboolean resident;
            if (ctx->Driver.IsTextureResident)
               resident = ctx->Driver.IsTextureResident(ctx, obj);
            else
               resident = GL_TRUE;
            *params = ENUM_TO_FLOAT(resident);
         }
d1434 3
d1440 3
d1446 3
d1452 3
d1461 3
a1463 12
         if (ctx->Extensions.EXT_texture_filter_anisotropic) {
            *params = obj->Sampler.MaxAnisotropy;
         }
	 else
	    error = GL_TRUE;
         break;
      case GL_TEXTURE_COMPARE_FAIL_VALUE_ARB:
         if (ctx->Extensions.ARB_shadow_ambient) {
            *params = obj->Sampler.CompareFailValue;
         }
	 else 
	    error = GL_TRUE;
d1466 3
d1472 4
a1475 5
         if (ctx->Extensions.ARB_shadow) {
            *params = (GLfloat) obj->Sampler.CompareMode;
         }
	 else 
	    error = GL_TRUE;
d1478 4
a1481 5
         if (ctx->Extensions.ARB_shadow) {
            *params = (GLfloat) obj->Sampler.CompareFunc;
         }
	 else 
	    error = GL_TRUE;
d1484 6
a1489 5
         if (ctx->Extensions.ARB_depth_texture) {
            *params = (GLfloat) obj->Sampler.DepthMode;
         }
	 else 
	    error = GL_TRUE;
d1492 4
a1495 5
         if (ctx->Extensions.EXT_texture_lod_bias) {
            *params = obj->Sampler.LodBias;
         }
	 else 
	    error = GL_TRUE;
a1496 1
#if FEATURE_OES_draw_texture
d1498 7
a1504 4
         params[0] = obj->CropRect[0];
         params[1] = obj->CropRect[1];
         params[2] = obj->CropRect[2];
         params[3] = obj->CropRect[3];
a1505 1
#endif
d1511 5
a1515 7
         if (ctx->Extensions.EXT_texture_swizzle) {
            GLuint comp = pname - GL_TEXTURE_SWIZZLE_R_EXT;
            *params = (GLfloat) obj->Swizzle[comp];
         }
         else {
            error = GL_TRUE;
         }
d1519 6
a1524 1
         if (ctx->Extensions.EXT_texture_swizzle) {
a1529 3
         else {
            error = GL_TRUE;
         }
d1533 26
a1558 6
         if (ctx->Extensions.AMD_seamless_cubemap_per_texture) {
            *params = (GLfloat) obj->Sampler.CubeMapSeamless;
         }
         else {
            error = GL_TRUE;
         }
d1562 1
a1562 2
	 error = GL_TRUE;
	 break;
d1565 3
a1567 3
   if (error)
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexParameterfv(pname=0x%x)",
		  pname);
d1569 1
d1571 1
a1578 1
   GLboolean error = GL_FALSE;
a1579 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d1581 3
a1583 3
    obj = get_texobj(ctx, target, GL_TRUE);
    if (!obj)
       return;
d1589 1
a1589 1
         break;;
d1592 1
a1592 1
         break;;
d1595 1
a1595 1
         break;;
d1598 1
a1598 1
         break;;
d1601 1
a1601 1
         break;;
d1603 3
d1617 1
a1617 1
         break;;
d1619 5
a1623 9
         {
            GLboolean resident;
            if (ctx->Driver.IsTextureResident)
               resident = ctx->Driver.IsTextureResident(ctx, obj);
            else
               resident = GL_TRUE;
            *params = (GLint) resident;
         }
         break;;
d1625 3
d1629 1
a1629 1
         break;;
d1631 3
d1635 1
a1635 1
         break;;
d1637 3
d1641 1
a1641 1
         break;;
d1643 3
d1647 1
a1647 1
         break;;
d1650 1
a1650 1
         break;;
d1652 3
a1654 14
         if (ctx->Extensions.EXT_texture_filter_anisotropic) {
            *params = (GLint) obj->Sampler.MaxAnisotropy;
         }
         else {
            error = GL_TRUE;
         }
         break;
      case GL_TEXTURE_COMPARE_FAIL_VALUE_ARB:
         if (ctx->Extensions.ARB_shadow_ambient) {
            *params = (GLint) FLOAT_TO_INT(obj->Sampler.CompareFailValue);
         }
         else {
            error = GL_TRUE;
         }
d1657 3
d1663 4
a1666 6
         if (ctx->Extensions.ARB_shadow) {
            *params = (GLint) obj->Sampler.CompareMode;
         }
         else {
            error = GL_TRUE;
         }
d1669 4
a1672 6
         if (ctx->Extensions.ARB_shadow) {
            *params = (GLint) obj->Sampler.CompareFunc;
         }
         else {
            error = GL_TRUE;
         }
d1675 3
a1677 6
         if (ctx->Extensions.ARB_depth_texture) {
            *params = (GLint) obj->Sampler.DepthMode;
         }
         else {
            error = GL_TRUE;
         }
d1680 4
a1683 6
         if (ctx->Extensions.EXT_texture_lod_bias) {
            *params = (GLint) obj->Sampler.LodBias;
         }
         else {
            error = GL_TRUE;
         }
a1684 1
#if FEATURE_OES_draw_texture
d1686 3
a1693 1
#endif
d1698 5
a1702 7
         if (ctx->Extensions.EXT_texture_swizzle) {
            GLuint comp = pname - GL_TEXTURE_SWIZZLE_R_EXT;
            *params = obj->Swizzle[comp];
         }
         else {
            error = GL_TRUE;
         }
d1706 5
a1710 6
         if (ctx->Extensions.EXT_texture_swizzle) {
            COPY_4V(params, obj->Swizzle);
         }
         else {
            error = GL_TRUE;
         }
d1714 26
a1739 6
         if (ctx->Extensions.AMD_seamless_cubemap_per_texture) {
            *params = (GLint) obj->Sampler.CubeMapSeamless;
         }
         else {
            error = GL_TRUE;
         }
d1743 1
a1743 1
         ; /* silence warnings */
d1746 3
a1748 3
   if (error)
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexParameteriv(pname=0x%x)",
		  pname);
d1750 1
d1752 1
a1761 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d1764 2
a1782 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d1785 2
@


1.3
log
@Merge Mesa 7.10.3
@
text
@d36 1
d39 3
d46 1
d121 2
a122 1
      if (ctx->Extensions.MESA_texture_array) {
d127 2
a128 1
      if (ctx->Extensions.MESA_texture_array) {
d182 14
a195 1
 * This is called just prior to changing any texture object state.
d201 1
a201 1
flush(struct gl_context *ctx, struct gl_texture_object *texObj)
d219 1
a219 1
      if (texObj->MinFilter == params[0])
d224 2
a225 2
         flush(ctx, texObj);
         texObj->MinFilter = params[0];
d232 2
a233 2
            flush(ctx, texObj);
            texObj->MinFilter = params[0];
d238 1
a238 2
         _mesa_error( ctx, GL_INVALID_ENUM, "glTexParameter(param=0x%x)",
                      params[0] );
d243 1
a243 1
      if (texObj->MagFilter == params[0])
d248 2
a249 2
         flush(ctx, texObj);
         texObj->MagFilter = params[0];
d252 1
a252 2
         _mesa_error( ctx, GL_INVALID_ENUM, "glTexParameter(param=0x%x)",
                      params[0]);
d257 1
a257 1
      if (texObj->WrapS == params[0])
d260 2
a261 2
         flush(ctx, texObj);
         texObj->WrapS = params[0];
d267 1
a267 1
      if (texObj->WrapT == params[0])
d270 2
a271 2
         flush(ctx, texObj);
         texObj->WrapT = params[0];
d277 1
a277 1
      if (texObj->WrapR == params[0])
d280 2
a281 2
         flush(ctx, texObj);
         texObj->WrapR = params[0];
d295 1
a295 1
      flush(ctx, texObj);
d307 1
a307 1
      flush(ctx, texObj);
d313 1
a313 1
	 flush(ctx, texObj);
d320 7
a326 6
      if (ctx->Extensions.ARB_shadow &&
          (params[0] == GL_NONE ||
           params[0] == GL_COMPARE_R_TO_TEXTURE_ARB)) {
         if (texObj->CompareMode != params[0]) {
            flush(ctx, texObj);
            texObj->CompareMode = params[0];
d329 1
a329 1
         return GL_FALSE;
d331 1
a331 5
      else {
         _mesa_error(ctx, GL_INVALID_ENUM,
                     "glTexParameter(GL_TEXTURE_COMPARE_MODE_ARB)");
      }
      return GL_FALSE;
d335 1
a335 1
         if (texObj->CompareFunc == params[0])
d340 2
a341 2
            flush(ctx, texObj);
            texObj->CompareFunc = params[0];
d350 2
a351 2
               flush(ctx, texObj);
               texObj->CompareFunc = params[0];
d356 1
a356 2
            _mesa_error(ctx, GL_INVALID_ENUM,
                        "glTexParameter(GL_TEXTURE_COMPARE_FUNC_ARB)");
d359 1
a359 4
      else {
         _mesa_error(ctx, GL_INVALID_ENUM, "glTexParameter(pname=0x%x)", pname);
      }
      return GL_FALSE;
d362 9
a370 8
      if (ctx->Extensions.ARB_depth_texture &&
          (params[0] == GL_LUMINANCE ||
           params[0] == GL_INTENSITY ||
           params[0] == GL_ALPHA ||
	   (ctx->Extensions.ARB_texture_rg && params[0] == GL_RED))) {
         if (texObj->DepthMode != params[0]) {
            flush(ctx, texObj);
            texObj->DepthMode = params[0];
d373 1
d375 1
a375 5
      else {
         _mesa_error(ctx, GL_INVALID_ENUM,
                     "glTexParameter(GL_DEPTH_TEXTURE_MODE_ARB)");
      }
      return GL_FALSE;
d400 1
a400 1
            flush(ctx, texObj);
d406 1
a406 2
      _mesa_error(ctx, GL_INVALID_ENUM, "glTexParameter(pname=0x%x)", pname);
      return GL_FALSE;
d411 1
a411 1
         flush(ctx, texObj);
d426 29
a454 2
      _mesa_error(ctx, GL_INVALID_ENUM, "glTexParameter(pname=0x%x)", pname);
      return GL_FALSE;
d457 1
a457 1
      _mesa_error(ctx, GL_INVALID_ENUM, "glTexParameter(pname=0x%x)", pname);
d459 9
d483 1
a483 1
      if (texObj->MinLod == params[0])
d485 2
a486 2
      flush(ctx, texObj);
      texObj->MinLod = params[0];
d490 1
a490 1
      if (texObj->MaxLod == params[0])
d492 2
a493 2
      flush(ctx, texObj);
      texObj->MaxLod = params[0];
d497 1
a497 1
      flush(ctx, texObj);
d503 1
a503 1
         if (texObj->MaxAnisotropy == params[0])
d509 1
a509 1
         flush(ctx, texObj);
d511 1
a511 1
         texObj->MaxAnisotropy = MIN2(params[0],
d525 3
a527 3
         if (texObj->CompareFailValue != params[0]) {
            flush(ctx, texObj);
            texObj->CompareFailValue = CLAMP(params[0], 0.0F, 1.0F);
d540 3
a542 3
         if (texObj->LodBias != params[0]) {
            flush(ctx, texObj);
            texObj->LodBias = params[0];
d550 13
a562 5
      flush(ctx, texObj);
      texObj->BorderColor.f[RCOMP] = params[0];
      texObj->BorderColor.f[GCOMP] = params[1];
      texObj->BorderColor.f[BCOMP] = params[2];
      texObj->BorderColor.f[ACOMP] = params[3];
d596 2
d646 2
d803 1
a803 1
      COPY_4V(texObj->BorderColor.i, params);
d833 1
a833 1
      COPY_4V(texObj->BorderColor.ui, params);
a861 1
   GLboolean isProxy;
a888 1
   _mesa_lock_texture(ctx, texObj);
d897 1
a897 1
      goto out;
a901 2
   isProxy = _mesa_is_proxy_texture(target);

d913 1
a913 1
         if (_mesa_is_format_compressed(img->TexFormat)) {
d915 1
a915 1
            *params = _mesa_compressed_format_to_glenum(ctx, img->TexFormat);
d918 17
a934 3
            /* return the user's requested internal format */
            *params = img->InternalFormat;
         }
d1000 1
a1000 2
            _mesa_error(ctx, GL_INVALID_ENUM,
                        "glGetTexLevelParameter[if]v(pname)");
d1008 1
a1008 2
            _mesa_error(ctx, GL_INVALID_ENUM,
                        "glGetTexLevelParameter[if]v(pname)");
d1012 3
a1014 5
         if (ctx->VersionMajor >= 3) {
            /* XXX return number of exponent bits for shared exponent texture
             * formats, like GL_RGB9_E5.
             */
            *params = 0;
d1017 1
a1017 2
            _mesa_error(ctx, GL_INVALID_ENUM,
                        "glGetTexLevelParameter[if]v(pname)");
d1023 2
a1024 1
	 if (_mesa_is_format_compressed(img->TexFormat) && !isProxy) {
d1034 1
a1034 1
         *params = (GLint) _mesa_is_format_compressed(img->TexFormat);
d1044 1
a1044 2
            _mesa_error(ctx, GL_INVALID_ENUM,
                        "glGetTexLevelParameter[if]v(pname)");
d1053 1
a1053 2
            _mesa_error(ctx, GL_INVALID_ENUM,
                        "glGetTexLevelParameter[if]v(pname)");
d1062 1
a1062 2
            _mesa_error(ctx, GL_INVALID_ENUM,
                        "glGetTexLevelParameter[if]v(pname)");
d1071 1
a1071 2
            _mesa_error(ctx, GL_INVALID_ENUM,
                        "glGetTexLevelParameter[if]v(pname)");
d1080 1
a1080 2
            _mesa_error(ctx, GL_INVALID_ENUM,
                        "glGetTexLevelParameter[if]v(pname)");
d1089 1
a1089 2
            _mesa_error(ctx, GL_INVALID_ENUM,
                        "glGetTexLevelParameter[if]v(pname)");
d1098 1
a1098 2
            _mesa_error(ctx, GL_INVALID_ENUM,
                        "glGetTexLevelParameter[if]v(pname)");
d1103 1
a1103 2
         _mesa_error(ctx, GL_INVALID_ENUM,
                     "glGetTexLevelParameter[if]v(pname)");
d1106 7
a1112 2
 out:
   _mesa_unlock_texture(ctx, texObj);
d1132 1
a1132 1
	 *params = ENUM_TO_FLOAT(obj->MagFilter);
d1135 1
a1135 1
         *params = ENUM_TO_FLOAT(obj->MinFilter);
d1138 1
a1138 1
         *params = ENUM_TO_FLOAT(obj->WrapS);
d1141 1
a1141 1
         *params = ENUM_TO_FLOAT(obj->WrapT);
d1144 1
a1144 1
         *params = ENUM_TO_FLOAT(obj->WrapR);
d1147 16
a1162 4
         params[0] = CLAMP(obj->BorderColor.f[0], 0.0F, 1.0F);
         params[1] = CLAMP(obj->BorderColor.f[1], 0.0F, 1.0F);
         params[2] = CLAMP(obj->BorderColor.f[2], 0.0F, 1.0F);
         params[3] = CLAMP(obj->BorderColor.f[3], 0.0F, 1.0F);
d1178 1
a1178 1
         *params = obj->MinLod;
d1181 1
a1181 1
         *params = obj->MaxLod;
d1191 1
a1191 1
            *params = obj->MaxAnisotropy;
d1198 1
a1198 1
            *params = obj->CompareFailValue;
d1208 1
a1208 1
            *params = (GLfloat) obj->CompareMode;
d1215 1
a1215 1
            *params = (GLfloat) obj->CompareFunc;
d1222 1
a1222 1
            *params = (GLfloat) obj->DepthMode;
d1229 1
a1229 1
            *params = obj->LodBias;
d1268 9
d1305 1
a1305 1
         *params = (GLint) obj->MagFilter;
d1308 1
a1308 1
         *params = (GLint) obj->MinFilter;
d1311 1
a1311 1
         *params = (GLint) obj->WrapS;
d1314 1
a1314 1
         *params = (GLint) obj->WrapT;
d1317 1
a1317 1
         *params = (GLint) obj->WrapR;
d1322 4
a1325 4
            b[0] = CLAMP(obj->BorderColor.f[0], 0.0F, 1.0F);
            b[1] = CLAMP(obj->BorderColor.f[1], 0.0F, 1.0F);
            b[2] = CLAMP(obj->BorderColor.f[2], 0.0F, 1.0F);
            b[3] = CLAMP(obj->BorderColor.f[3], 0.0F, 1.0F);
d1346 1
a1346 1
         *params = (GLint) obj->MinLod;
d1349 1
a1349 1
         *params = (GLint) obj->MaxLod;
d1359 1
a1359 1
            *params = (GLint) obj->MaxAnisotropy;
d1367 1
a1367 1
            *params = (GLint) FLOAT_TO_INT(obj->CompareFailValue);
d1378 1
a1378 1
            *params = (GLint) obj->CompareMode;
d1386 1
a1386 1
            *params = (GLint) obj->CompareFunc;
d1394 1
a1394 1
            *params = (GLint) obj->DepthMode;
d1402 1
a1402 1
            *params = (GLint) obj->LodBias;
d1438 9
d1471 1
a1471 1
      COPY_4V(params, texObj->BorderColor.i);
d1491 1
a1491 1
      COPY_4V(params, texObj->BorderColor.i);
@


1.2
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d42 1
a42 1
#include "shader/prog_instruction.h"
d50 1
a50 1
validate_texture_wrap_mode(GLcontext * ctx, GLenum target, GLenum wrap)
d86 1
a86 1
get_texobj(GLcontext *ctx, GLenum target, GLboolean get)
d181 1
a181 1
flush(GLcontext *ctx, struct gl_texture_object *texObj)
d193 1
a193 1
set_tex_parameteri(GLcontext *ctx,
d294 4
a297 11
      if (ctx->Extensions.SGIS_generate_mipmap) {
         if (texObj->GenerateMipmap != params[0]) {
            flush(ctx, texObj);
            texObj->GenerateMipmap = params[0] ? GL_TRUE : GL_FALSE;
            return GL_TRUE;
         }
         return GL_FALSE;
      }
      else {
         _mesa_error(ctx, GL_INVALID_ENUM,
                     "glTexParameter(pname=GL_GENERATE_MIPMAP_SGIS)");
d354 2
a355 1
           params[0] == GL_ALPHA)) {
d368 1
a368 1
#ifdef FEATURE_OES_draw_texture
d433 1
a433 1
set_tex_parameterf(GLcontext *ctx,
d601 1
a601 1
#ifdef FEATURE_OES_draw_texture
d874 5
d880 5
d947 12
d1133 1
a1133 5
         if (ctx->Extensions.SGIS_generate_mipmap) {
            *params = (GLfloat) obj->GenerateMipmap;
         }
	 else 
	    error = GL_TRUE;
d1163 1
a1163 1
#ifdef FEATURE_OES_draw_texture
d1294 1
a1294 6
         if (ctx->Extensions.SGIS_generate_mipmap) {
            *params = (GLint) obj->GenerateMipmap;
         }
         else {
            error = GL_TRUE;
         }
d1328 1
a1328 1
#ifdef FEATURE_OES_draw_texture
@


1.1
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d34 1
d36 1
a36 2
#include "main/enums.h"
#include "main/colormac.h"
d41 2
d73 1
a73 1
   _mesa_error( ctx, GL_INVALID_VALUE, "glTexParameter(param)" );
d80 4
a83 1
 * Return NULL if any error.
d86 1
a86 1
get_texobj(GLcontext *ctx, GLenum target)
d90 3
a92 2
   if (ctx->Texture.CurrentUnit >= ctx->Const.MaxTextureImageUnits) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glTexParameter(current unit)");
d96 1
a96 1
   texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
d129 2
a130 1
   _mesa_error(ctx, GL_INVALID_ENUM, "glTexParameter(target)");
d136 39
d218 2
a219 1
         _mesa_error( ctx, GL_INVALID_VALUE, "glTexParameter(param)" );
d233 2
a234 1
         _mesa_error( ctx, GL_INVALID_VALUE, "glTexParameter(param)" );
d273 2
a274 1
         _mesa_error(ctx, GL_INVALID_VALUE, "glTexParameter(param)");
d285 2
a286 1
         _mesa_error(ctx, GL_INVALID_OPERATION, "glTexParameter(param)");
a292 24
   case GL_TEXTURE_COMPARE_SGIX:
      if (ctx->Extensions.SGIX_shadow) {
         FLUSH_VERTICES(ctx, _NEW_TEXTURE);
         texObj->CompareFlag = params[0] ? GL_TRUE : GL_FALSE;
      }
      else {
         _mesa_error(ctx, GL_INVALID_ENUM,
                     "glTexParameter(pname=GL_TEXTURE_COMPARE_SGIX)");
      }
      return GL_TRUE;

   case GL_TEXTURE_COMPARE_OPERATOR_SGIX:
      if (ctx->Extensions.SGIX_shadow &&
          (params[0] == GL_TEXTURE_LEQUAL_R_SGIX || 
           params[0] == GL_TEXTURE_GEQUAL_R_SGIX)) {
         FLUSH_VERTICES(ctx, _NEW_TEXTURE);
         texObj->CompareOperator = params[0];
      }
      else {
         _mesa_error(ctx, GL_INVALID_ENUM,
                     "glTexParameter(GL_TEXTURE_COMPARE_OPERATOR_SGIX)");
      }
      return GL_TRUE;

d353 1
a353 1
         _mesa_error(ctx, GL_INVALID_ENUM, "glTexParameter(param)");
d383 44
d478 4
a481 2
         _mesa_error(ctx, GL_INVALID_ENUM,
                     "glTexParameter(pname=GL_TEXTURE_MAX_ANISOTROPY_EXT)");
d486 2
a487 2
      if (ctx->Extensions.SGIX_shadow_ambient) {
         if (texObj->ShadowAmbient != params[0]) {
d489 1
a489 1
            texObj->ShadowAmbient = CLAMP(params[0], 0.0F, 1.0F);
d495 1
a495 1
                     "glTexParameter(pname=GL_SHADOW_AMBIENT_SGIX)");
d513 4
a516 8
      texObj->BorderColor[RCOMP] = params[0];
      texObj->BorderColor[GCOMP] = params[1];
      texObj->BorderColor[BCOMP] = params[2];
      texObj->BorderColor[ACOMP] = params[3];
      UNCLAMPED_FLOAT_TO_CHAN(texObj->_BorderChan[RCOMP], params[0]);
      UNCLAMPED_FLOAT_TO_CHAN(texObj->_BorderChan[GCOMP], params[1]);
      UNCLAMPED_FLOAT_TO_CHAN(texObj->_BorderChan[BCOMP], params[2]);
      UNCLAMPED_FLOAT_TO_CHAN(texObj->_BorderChan[ACOMP], params[3]);
d534 1
a534 1
   texObj = get_texobj(ctx, target);
a545 2
   case GL_TEXTURE_COMPARE_SGIX:
   case GL_TEXTURE_COMPARE_OPERATOR_SGIX:
d552 4
a555 2
         GLint p = (GLint) param;
         need_update = set_tex_parameteri(ctx, texObj, pname, &p);
d559 7
a565 2
      /* this will generate an error if pname is illegal */
      need_update = set_tex_parameterf(ctx, texObj, pname, &param);
d582 1
a582 1
   texObj = get_texobj(ctx, target);
a593 2
   case GL_TEXTURE_COMPARE_SGIX:
   case GL_TEXTURE_COMPARE_OPERATOR_SGIX:
d600 4
a603 2
         GLint p = (GLint) params[0];
         need_update = set_tex_parameteri(ctx, texObj, pname, &p);
d616 1
a616 1
         need_update = set_tex_parameteri(ctx, target, iparams);
d640 1
a640 1
   texObj = get_texobj(ctx, target);
d650 1
a650 1
   case GL_SHADOW_AMBIENT_SGIX: /* aka GL_TEXTURE_COMPARE_FAIL_VALUE_ARB */
d652 3
a654 1
         GLfloat fparam = (GLfloat) param;
d656 1
a656 1
         need_update = set_tex_parameterf(ctx, texObj, pname, &fparam);
d661 6
a666 1
      need_update = set_tex_parameteri(ctx, texObj, pname, &param);
d684 1
a684 1
   texObj = get_texobj(ctx, target);
d705 1
a705 1
   case GL_SHADOW_AMBIENT_SGIX: /* aka GL_TEXTURE_COMPARE_FAIL_VALUE_ARB */
d708 4
a711 2
         GLfloat fparam = (GLfloat) params[0];
         need_update = set_tex_parameterf(ctx, texObj, pname, &fparam);
d733 62
a804 38
static GLuint
tex_image_dimensions(GLcontext *ctx, GLenum target)
{
   switch (target) {
      case GL_TEXTURE_1D:
      case GL_PROXY_TEXTURE_1D:
         return 1;
      case GL_TEXTURE_2D:
      case GL_PROXY_TEXTURE_2D:
         return 2;
      case GL_TEXTURE_3D:
      case GL_PROXY_TEXTURE_3D:
         return 3;
      case GL_TEXTURE_CUBE_MAP:
      case GL_PROXY_TEXTURE_CUBE_MAP:
      case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
      case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
      case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
         return ctx->Extensions.ARB_texture_cube_map ? 2 : 0;
      case GL_TEXTURE_RECTANGLE_NV:
      case GL_PROXY_TEXTURE_RECTANGLE_NV:
         return ctx->Extensions.NV_texture_rectangle ? 2 : 0;
      case GL_TEXTURE_1D_ARRAY_EXT:
      case GL_PROXY_TEXTURE_1D_ARRAY_EXT:
         return ctx->Extensions.MESA_texture_array ? 2 : 0;
      case GL_TEXTURE_2D_ARRAY_EXT:
      case GL_PROXY_TEXTURE_2D_ARRAY_EXT:
         return ctx->Extensions.MESA_texture_array ? 3 : 0;
      default:
         _mesa_problem(ctx, "bad target in _mesa_tex_target_dimensions()");
         return 0;
   }
}


a811 1
   GLuint dimensions;
d814 1
d818 1
a818 1
   if (ctx->Texture.CurrentUnit >= ctx->Const.MaxTextureImageUnits) {
d824 1
a824 1
   texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
a826 6
   dimensions = tex_image_dimensions(ctx, target);  /* 1, 2 or 3 */
   if (dimensions == 0) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexLevelParameter[if]v(target)");
      return;
   }

d829 2
a830 2
      /* should not happen since <target> was just checked above */
      _mesa_problem(ctx, "maxLevels=0 in _mesa_GetTexLevelParameter");
d852 2
d867 8
a874 1
         *params = img->InternalFormat;
a879 5
         if (img->_BaseFormat == GL_RGB || img->_BaseFormat == GL_RGBA)
            *params = img->TexFormat->RedBits;
         else
            *params = 0;
         break;
a880 5
         if (img->_BaseFormat == GL_RGB || img->_BaseFormat == GL_RGBA)
            *params = img->TexFormat->GreenBits;
         else
            *params = 0;
         break;
d883 1
a883 1
            *params = img->TexFormat->BlueBits;
d891 1
a891 1
            *params = img->TexFormat->AlphaBits;
d898 8
a905 4
         else if (img->TexFormat->IntensityBits > 0)
            *params = img->TexFormat->IntensityBits;
         else /* intensity probably stored as rgb texture */
            *params = MIN2(img->TexFormat->RedBits, img->TexFormat->GreenBits);
d911 8
a918 4
         else if (img->TexFormat->LuminanceBits > 0)
            *params = img->TexFormat->LuminanceBits;
         else /* luminance probably stored as rgb texture */
            *params = MIN2(img->TexFormat->RedBits, img->TexFormat->GreenBits);
d922 1
a922 1
            *params = img->TexFormat->IndexBits;
d928 1
a928 1
            *params = img->TexFormat->DepthBits;
d934 3
a936 2
         if (ctx->Extensions.EXT_packed_depth_stencil) {
            *params = img->TexFormat->StencilBits;
d946 8
a953 18
         if (ctx->Extensions.ARB_texture_compression) {
            if (img->IsCompressed && !isProxy) {
               /* Don't use ctx->Driver.CompressedTextureSize() since that
                * may returned a padded hardware size.
                */
               *params = _mesa_compressed_texture_size(ctx, img->Width,
                                                   img->Height, img->Depth,
                                                   img->TexFormat->MesaFormat);
            }
            else {
               _mesa_error(ctx, GL_INVALID_OPERATION,
                           "glGetTexLevelParameter[if]v(pname)");
            }
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM,
                        "glGetTexLevelParameter[if]v(pname)");
         }
d956 1
a956 7
         if (ctx->Extensions.ARB_texture_compression) {
            *params = (GLint) img->IsCompressed;
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM,
                        "glGetTexLevelParameter[if]v(pname)");
         }
d962 2
a963 1
            *params = img->TexFormat->RedBits ? img->TexFormat->DataType : GL_NONE;
d972 2
a973 1
            *params = img->TexFormat->GreenBits ? img->TexFormat->DataType : GL_NONE;
d982 2
a983 1
            *params = img->TexFormat->BlueBits ? img->TexFormat->DataType : GL_NONE;
d992 2
a993 1
            *params = img->TexFormat->AlphaBits ? img->TexFormat->DataType : GL_NONE;
d1002 2
a1003 1
            *params = img->TexFormat->LuminanceBits ? img->TexFormat->DataType : GL_NONE;
d1012 2
a1013 1
            *params = img->TexFormat->IntensityBits ? img->TexFormat->DataType : GL_NONE;
d1022 2
a1023 1
            *params = img->TexFormat->DepthBits ? img->TexFormat->DataType : GL_NONE;
a1044 1
   struct gl_texture_unit *texUnit;
d1050 2
a1051 3
   if (ctx->Texture.CurrentUnit >= ctx->Const.MaxTextureImageUnits) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glGetTexParameterfv(current unit)");
a1052 9
   }

   texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];

   obj = _mesa_select_tex_object(ctx, texUnit, target);
   if (!obj) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexParameterfv(target)");
      return;
   }
d1072 4
a1075 4
         params[0] = CLAMP(obj->BorderColor[0], 0.0F, 1.0F);
         params[1] = CLAMP(obj->BorderColor[1], 0.0F, 1.0F);
         params[2] = CLAMP(obj->BorderColor[2], 0.0F, 1.0F);
         params[3] = CLAMP(obj->BorderColor[3], 0.0F, 1.0F);
d1107 1
a1107 1
	    error = 1;
d1109 3
a1111 3
      case GL_TEXTURE_COMPARE_SGIX:
         if (ctx->Extensions.SGIX_shadow) {
            *params = (GLfloat) obj->CompareFlag;
d1114 1
a1114 15
	    error = 1;
         break;
      case GL_TEXTURE_COMPARE_OPERATOR_SGIX:
         if (ctx->Extensions.SGIX_shadow) {
            *params = (GLfloat) obj->CompareOperator;
         }
	 else 
	    error = 1;
         break;
      case GL_SHADOW_AMBIENT_SGIX: /* aka GL_TEXTURE_COMPARE_FAIL_VALUE_ARB */
         if (ctx->Extensions.SGIX_shadow_ambient) {
            *params = obj->ShadowAmbient;
         }
	 else 
	    error = 1;
d1121 1
a1121 1
	    error = 1;
d1128 1
a1128 1
	    error = 1;
d1135 1
a1135 1
	    error = 1;
d1142 1
a1142 1
	    error = 1;
d1149 1
a1149 1
	    error = 1;
d1159 26
d1186 1
a1186 1
	 error = 1;
d1189 1
a1200 1
   struct gl_texture_unit *texUnit;
d1202 1
d1206 3
a1208 13
   if (ctx->Texture.CurrentUnit >= ctx->Const.MaxTextureImageUnits) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glGetTexParameteriv(current unit)");
      return;
   }

   texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];

   obj = _mesa_select_tex_object(ctx, texUnit, target);
   if (!obj) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexParameteriv(target)");
      return;
   }
d1210 1
d1214 1
a1214 1
         return;
d1217 1
a1217 1
         return;
d1220 1
a1220 1
         return;
d1223 1
a1223 1
         return;
d1226 1
a1226 1
         return;
d1230 4
a1233 4
            b[0] = CLAMP(obj->BorderColor[0], 0.0F, 1.0F);
            b[1] = CLAMP(obj->BorderColor[1], 0.0F, 1.0F);
            b[2] = CLAMP(obj->BorderColor[2], 0.0F, 1.0F);
            b[3] = CLAMP(obj->BorderColor[3], 0.0F, 1.0F);
d1239 1
a1239 1
         return;
d1249 1
a1249 1
         return;
d1252 1
a1252 1
         return;
d1255 1
a1255 1
         return;
d1258 1
a1258 1
         return;
d1261 1
a1261 1
         return;
d1264 1
a1264 1
         return;
a1267 1
            return;
d1269 2
a1270 5
         break;
      case GL_TEXTURE_COMPARE_SGIX:
         if (ctx->Extensions.SGIX_shadow) {
            *params = (GLint) obj->CompareFlag;
            return;
d1273 3
a1275 4
      case GL_TEXTURE_COMPARE_OPERATOR_SGIX:
         if (ctx->Extensions.SGIX_shadow) {
            *params = (GLint) obj->CompareOperator;
            return;
d1277 2
a1278 5
         break;
      case GL_SHADOW_AMBIENT_SGIX: /* aka GL_TEXTURE_COMPARE_FAIL_VALUE_ARB */
         if (ctx->Extensions.SGIX_shadow_ambient) {
            *params = (GLint) FLOAT_TO_INT(obj->ShadowAmbient);
            return;
d1284 3
a1286 1
            return;
d1292 3
a1294 1
            return;
d1300 3
a1302 1
            return;
d1308 3
a1310 1
            return;
d1316 3
a1318 1
            return;
d1329 22
d1354 56
a1409 2
   /* If we get here, pname was an unrecognized enum */
   _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexParameteriv(pname=0x%x)", pname);
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d34 2
a36 2
#include "main/context.h"
#include "main/formats.h"
a40 2
#include "main/texstate.h"
#include "program/prog_instruction.h"
d48 1
a48 1
validate_texture_wrap_mode(struct gl_context * ctx, GLenum target, GLenum wrap)
d71 1
a71 1
   _mesa_error( ctx, GL_INVALID_ENUM, "glTexParameter(param=0x%x)", wrap );
d78 1
a78 4
 * Return NULL if any error (and record the error).
 * Note that this is different from _mesa_select_tex_object() in that proxy
 * targets are not accepted.
 * Only the glGetTexLevelParameter() functions accept proxy targets.
d81 1
a81 1
get_texobj(struct gl_context *ctx, GLenum target, GLboolean get)
d85 2
a86 3
   if (ctx->Texture.CurrentUnit >= ctx->Const.MaxCombinedTextureImageUnits) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "gl%sTexParameter(current unit)", get ? "Get" : "");
d90 1
a90 1
   texUnit = _mesa_get_current_tex_unit(ctx);
d123 1
a123 2
   _mesa_error(ctx, GL_INVALID_ENUM,
                  "gl%sTexParameter(target)", get ? "Get" : "");
a128 39
 * Convert GL_RED/GREEN/BLUE/ALPHA/ZERO/ONE to SWIZZLE_X/Y/Z/W/ZERO/ONE.
 * \return -1 if error.
 */
static GLint
comp_to_swizzle(GLenum comp)
{
   switch (comp) {
   case GL_RED:
      return SWIZZLE_X;
   case GL_GREEN:
      return SWIZZLE_Y;
   case GL_BLUE:
      return SWIZZLE_Z;
   case GL_ALPHA:
      return SWIZZLE_W;
   case GL_ZERO:
      return SWIZZLE_ZERO;
   case GL_ONE:
      return SWIZZLE_ONE;
   default:
      return -1;
   }
}


static void
set_swizzle_component(GLuint *swizzle, GLuint comp, GLuint swz)
{
   ASSERT(comp < 4);
   ASSERT(swz <= SWIZZLE_NIL);
   {
      GLuint mask = 0x7 << (3 * comp);
      GLuint s = (*swizzle & ~mask) | (swz << (3 * comp));
      *swizzle = s;
   }
}


/**
d135 1
a135 1
flush(struct gl_context *ctx, struct gl_texture_object *texObj)
d147 1
a147 1
set_tex_parameteri(struct gl_context *ctx,
d172 1
a172 2
         _mesa_error( ctx, GL_INVALID_ENUM, "glTexParameter(param=0x%x)",
                      params[0] );
d186 1
a186 2
         _mesa_error( ctx, GL_INVALID_ENUM, "glTexParameter(param=0x%x)",
                      params[0]);
d225 1
a225 2
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glTexParameter(param=%d)", params[0]);
d236 1
a236 2
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glTexParameter(param=%d)", params[0]);
d243 24
d268 11
a278 4
      if (texObj->GenerateMipmap != params[0]) {
	 flush(ctx, texObj);
	 texObj->GenerateMipmap = params[0] ? GL_TRUE : GL_FALSE;
	 return GL_TRUE;
d327 1
a327 1
         _mesa_error(ctx, GL_INVALID_ENUM, "glTexParameter(pname=0x%x)", pname);
d335 1
a335 2
           params[0] == GL_ALPHA ||
	   (ctx->Extensions.ARB_texture_rg && params[0] == GL_RED))) {
d348 1
a348 1
#if FEATURE_OES_draw_texture
a356 44
   case GL_TEXTURE_SWIZZLE_R_EXT:
   case GL_TEXTURE_SWIZZLE_G_EXT:
   case GL_TEXTURE_SWIZZLE_B_EXT:
   case GL_TEXTURE_SWIZZLE_A_EXT:
      if (ctx->Extensions.EXT_texture_swizzle) {
         const GLuint comp = pname - GL_TEXTURE_SWIZZLE_R_EXT;
         const GLint swz = comp_to_swizzle(params[0]);
         if (swz < 0) {
            _mesa_error(ctx, GL_INVALID_OPERATION,
                        "glTexParameter(swizzle 0x%x)", params[0]);
            return GL_FALSE;
         }
         ASSERT(comp < 4);
         if (swz >= 0) {
            flush(ctx, texObj);
            texObj->Swizzle[comp] = params[0];
            set_swizzle_component(&texObj->_Swizzle, comp, swz);
            return GL_TRUE;
         }
      }
      _mesa_error(ctx, GL_INVALID_ENUM, "glTexParameter(pname=0x%x)", pname);
      return GL_FALSE;

   case GL_TEXTURE_SWIZZLE_RGBA_EXT:
      if (ctx->Extensions.EXT_texture_swizzle) {
         GLuint comp;
         flush(ctx, texObj);
         for (comp = 0; comp < 4; comp++) {
            const GLint swz = comp_to_swizzle(params[comp]);
            if (swz >= 0) {
               texObj->Swizzle[comp] = params[comp];
               set_swizzle_component(&texObj->_Swizzle, comp, swz);
            }
            else {
               _mesa_error(ctx, GL_INVALID_OPERATION,
                           "glTexParameter(swizzle 0x%x)", params[comp]);
               return GL_FALSE;
            }
         }
         return GL_TRUE;
      }
      _mesa_error(ctx, GL_INVALID_ENUM, "glTexParameter(pname=0x%x)", pname);
      return GL_FALSE;

d369 1
a369 1
set_tex_parameterf(struct gl_context *ctx,
d408 2
a409 4
         static GLuint count = 0;
         if (count++ < 10)
            _mesa_error(ctx, GL_INVALID_ENUM,
                        "glTexParameter(pname=GL_TEXTURE_MAX_ANISOTROPY_EXT)");
d414 2
a415 2
      if (ctx->Extensions.ARB_shadow_ambient) {
         if (texObj->CompareFailValue != params[0]) {
d417 1
a417 1
            texObj->CompareFailValue = CLAMP(params[0], 0.0F, 1.0F);
d423 1
a423 1
                    "glTexParameter(pname=GL_TEXTURE_COMPARE_FAIL_VALUE_ARB)");
d441 8
a448 4
      texObj->BorderColor.f[RCOMP] = params[0];
      texObj->BorderColor.f[GCOMP] = params[1];
      texObj->BorderColor.f[BCOMP] = params[2];
      texObj->BorderColor.f[ACOMP] = params[3];
d466 1
a466 1
   texObj = get_texobj(ctx, target, GL_FALSE);
d478 2
d486 2
a487 4
         GLint p[4];
         p[0] = (GLint) param;
         p[1] = p[2] = p[3] = 0;
         need_update = set_tex_parameteri(ctx, texObj, pname, p);
d491 2
a492 7
      {
         /* this will generate an error if pname is illegal */
         GLfloat p[4];
         p[0] = param;
         p[1] = p[2] = p[3] = 0.0F;
         need_update = set_tex_parameterf(ctx, texObj, pname, p);
      }
d509 1
a509 1
   texObj = get_texobj(ctx, target, GL_FALSE);
d521 2
d529 2
a530 4
         GLint p[4];
         p[0] = (GLint) params[0];
         p[1] = p[2] = p[3] = 0;
         need_update = set_tex_parameteri(ctx, texObj, pname, p);
d534 1
a534 1
#if FEATURE_OES_draw_texture
d543 1
a543 1
         need_update = set_tex_parameteri(ctx, texObj, pname, iparams);
d567 1
a567 1
   texObj = get_texobj(ctx, target, GL_FALSE);
d577 1
a577 1
   case GL_TEXTURE_COMPARE_FAIL_VALUE_ARB:
d579 1
a579 3
         GLfloat fparam[4];
         fparam[0] = (GLfloat) param;
         fparam[1] = fparam[2] = fparam[3] = 0.0F;
d581 1
a581 1
         need_update = set_tex_parameterf(ctx, texObj, pname, fparam);
d586 1
a586 6
      {
         GLint iparam[4];
         iparam[0] = param;
         iparam[1] = iparam[2] = iparam[3] = 0;
         need_update = set_tex_parameteri(ctx, texObj, pname, iparam);
      }
d604 1
a604 1
   texObj = get_texobj(ctx, target, GL_FALSE);
d625 1
a625 1
   case GL_TEXTURE_COMPARE_FAIL_VALUE_ARB:
d628 2
a629 4
         GLfloat fparams[4];
         fparams[0] = (GLfloat) params[0];
         fparams[1] = fparams[2] = fparams[3] = 0.0F;
         need_update = set_tex_parameterf(ctx, texObj, pname, fparams);
a650 5
/**
 * Set tex parameter to integer value(s).  Primarily intended to set
 * integer-valued texture border color (for integer-valued textures).
 * New in GL 3.0.
 */
d652 2
a653 1
_mesa_TexParameterIiv(GLenum target, GLenum pname, const GLint *params)
d655 3
a657 19
   struct gl_texture_object *texObj;
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   texObj = get_texobj(ctx, target, GL_FALSE);
   if (!texObj)
      return;

   switch (pname) {
   case GL_TEXTURE_BORDER_COLOR:
      FLUSH_VERTICES(ctx, _NEW_TEXTURE);
      /* set the integer-valued border color */
      COPY_4V(texObj->BorderColor.i, params);
      break;
   default:
      _mesa_TexParameteriv(target, pname, params);
      break;
   }
   /* XXX no driver hook for TexParameterIiv() yet */
d661 2
a662 7
/**
 * Set tex parameter to unsigned integer value(s).  Primarily intended to set
 * uint-valued texture border color (for integer-valued textures).
 * New in GL 3.0
 */
void GLAPIENTRY
_mesa_TexParameterIuiv(GLenum target, GLenum pname, const GLuint *params)
d664 31
a694 17
   struct gl_texture_object *texObj;
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   texObj = get_texobj(ctx, target, GL_FALSE);
   if (!texObj)
      return;

   switch (pname) {
   case GL_TEXTURE_BORDER_COLOR:
      FLUSH_VERTICES(ctx, _NEW_TEXTURE);
      /* set the unsigned integer-valued border color */
      COPY_4V(texObj->BorderColor.ui, params);
      break;
   default:
      _mesa_TexParameteriv(target, pname, (const GLint *) params);
      break;
a695 13
   /* XXX no driver hook for TexParameterIuiv() yet */
}




void GLAPIENTRY
_mesa_GetTexLevelParameterfv( GLenum target, GLint level,
                              GLenum pname, GLfloat *params )
{
   GLint iparam;
   _mesa_GetTexLevelParameteriv( target, level, pname, &iparam );
   *params = (GLfloat) iparam;
d706 1
a708 1
   gl_format texFormat;
d712 1
a712 1
   if (ctx->Texture.CurrentUnit >= ctx->Const.MaxCombinedTextureImageUnits) {
d718 1
a718 1
   texUnit = _mesa_get_current_tex_unit(ctx);
d721 6
d729 2
a730 2
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "glGetTexLevelParameter[if]v(target=0x%x)", target);
a751 2
   texFormat = img->TexFormat;

d765 1
a765 8
         if (_mesa_is_format_compressed(img->TexFormat)) {
            /* need to return the actual compressed format */
            *params = _mesa_compressed_format_to_glenum(ctx, img->TexFormat);
         }
         else {
            /* return the user's requested internal format */
            *params = img->InternalFormat;
         }
d771 5
a775 5
         if (img->_BaseFormat == GL_RED) {
            *params = _mesa_get_format_bits(texFormat, pname);
	    break;
	 }
	 /* FALLTHROUGH */
d777 5
a781 5
         if (img->_BaseFormat == GL_RG) {
            *params = _mesa_get_format_bits(texFormat, pname);
	    break;
	 }
	 /* FALLTHROUGH */
d784 1
a784 1
            *params = _mesa_get_format_bits(texFormat, pname);
d792 1
a792 1
            *params = _mesa_get_format_bits(texFormat, pname);
d799 4
a802 8
         else {
            *params = _mesa_get_format_bits(texFormat, pname);
            if (*params == 0) {
               /* intensity probably stored as rgb texture */
               *params = MIN2(_mesa_get_format_bits(texFormat, GL_TEXTURE_RED_SIZE),
                              _mesa_get_format_bits(texFormat, GL_TEXTURE_GREEN_SIZE));
            }
         }
d808 4
a811 8
         else {
            *params = _mesa_get_format_bits(texFormat, pname);
            if (*params == 0) {
               /* luminance probably stored as rgb texture */
               *params = MIN2(_mesa_get_format_bits(texFormat, GL_TEXTURE_RED_SIZE),
                              _mesa_get_format_bits(texFormat, GL_TEXTURE_GREEN_SIZE));
            }
         }
d815 1
a815 1
            *params = _mesa_get_format_bits(texFormat, pname);
d821 1
a821 1
            *params = _mesa_get_format_bits(texFormat, pname);
d827 2
a828 3
         if (ctx->Extensions.EXT_packed_depth_stencil ||
             ctx->Extensions.ARB_framebuffer_object) {
            *params = _mesa_get_format_bits(texFormat, pname);
d835 16
a850 6
      case GL_TEXTURE_SHARED_SIZE:
         if (ctx->VersionMajor >= 3) {
            /* XXX return number of exponent bits for shared exponent texture
             * formats, like GL_RGB9_E5.
             */
            *params = 0;
a856 12

      /* GL_ARB_texture_compression */
      case GL_TEXTURE_COMPRESSED_IMAGE_SIZE:
	 if (_mesa_is_format_compressed(img->TexFormat) && !isProxy) {
            *params = _mesa_format_image_size(texFormat, img->Width,
                                              img->Height, img->Depth);
	 }
	 else {
	    _mesa_error(ctx, GL_INVALID_OPERATION,
			"glGetTexLevelParameter[if]v(pname)");
	 }
         break;
d858 7
a864 1
         *params = (GLint) _mesa_is_format_compressed(img->TexFormat);
d870 1
a870 2
            *params = _mesa_get_format_bits(texFormat, GL_TEXTURE_RED_SIZE) ?
               _mesa_get_format_datatype(texFormat) : GL_NONE;
d879 1
a879 2
            *params = _mesa_get_format_bits(texFormat, GL_TEXTURE_GREEN_SIZE) ?
               _mesa_get_format_datatype(texFormat) : GL_NONE;
d888 1
a888 2
            *params = _mesa_get_format_bits(texFormat, GL_TEXTURE_BLUE_SIZE) ?
               _mesa_get_format_datatype(texFormat) : GL_NONE;
d897 1
a897 2
            *params = _mesa_get_format_bits(texFormat, GL_TEXTURE_ALPHA_SIZE) ?
               _mesa_get_format_datatype(texFormat) : GL_NONE;
d906 1
a906 2
            *params = _mesa_get_format_bits(texFormat, GL_TEXTURE_LUMINANCE_SIZE) ?
               _mesa_get_format_datatype(texFormat) : GL_NONE;
d915 1
a915 2
            *params = _mesa_get_format_bits(texFormat, GL_TEXTURE_INTENSITY_SIZE) ?
               _mesa_get_format_datatype(texFormat) : GL_NONE;
d924 1
a924 2
            *params = _mesa_get_format_bits(texFormat, GL_TEXTURE_DEPTH_SIZE) ?
               _mesa_get_format_datatype(texFormat) : GL_NONE;
d946 1
d952 3
a954 2
   obj = get_texobj(ctx, target, GL_TRUE);
   if (!obj)
d956 9
d984 4
a987 4
         params[0] = CLAMP(obj->BorderColor.f[0], 0.0F, 1.0F);
         params[1] = CLAMP(obj->BorderColor.f[1], 0.0F, 1.0F);
         params[2] = CLAMP(obj->BorderColor.f[2], 0.0F, 1.0F);
         params[3] = CLAMP(obj->BorderColor.f[3], 0.0F, 1.0F);
d1019 15
a1033 1
	    error = GL_TRUE;
d1035 3
a1037 3
      case GL_TEXTURE_COMPARE_FAIL_VALUE_ARB:
         if (ctx->Extensions.ARB_shadow_ambient) {
            *params = obj->CompareFailValue;
d1040 1
a1040 1
	    error = GL_TRUE;
d1043 5
a1047 1
	 *params = (GLfloat) obj->GenerateMipmap;
d1054 1
a1054 1
	    error = GL_TRUE;
d1061 1
a1061 1
	    error = GL_TRUE;
d1068 1
a1068 1
	    error = GL_TRUE;
d1075 1
a1075 1
	    error = GL_TRUE;
d1077 1
a1077 1
#if FEATURE_OES_draw_texture
a1084 26

      case GL_TEXTURE_SWIZZLE_R_EXT:
      case GL_TEXTURE_SWIZZLE_G_EXT:
      case GL_TEXTURE_SWIZZLE_B_EXT:
      case GL_TEXTURE_SWIZZLE_A_EXT:
         if (ctx->Extensions.EXT_texture_swizzle) {
            GLuint comp = pname - GL_TEXTURE_SWIZZLE_R_EXT;
            *params = (GLfloat) obj->Swizzle[comp];
         }
         else {
            error = GL_TRUE;
         }
         break;

      case GL_TEXTURE_SWIZZLE_RGBA_EXT:
         if (ctx->Extensions.EXT_texture_swizzle) {
            GLuint comp;
            for (comp = 0; comp < 4; comp++) {
               params[comp] = (GLfloat) obj->Swizzle[comp];
            }
         }
         else {
            error = GL_TRUE;
         }
         break;

d1086 1
a1086 1
	 error = GL_TRUE;
a1088 1

d1100 1
a1101 1
   GLboolean error = GL_FALSE;
d1105 13
a1117 3
    obj = get_texobj(ctx, target, GL_TRUE);
    if (!obj)
       return;
a1118 1
   _mesa_lock_texture(ctx, obj);
d1122 1
a1122 1
         break;;
d1125 1
a1125 1
         break;;
d1128 1
a1128 1
         break;;
d1131 1
a1131 1
         break;;
d1134 1
a1134 1
         break;;
d1138 4
a1141 4
            b[0] = CLAMP(obj->BorderColor.f[0], 0.0F, 1.0F);
            b[1] = CLAMP(obj->BorderColor.f[1], 0.0F, 1.0F);
            b[2] = CLAMP(obj->BorderColor.f[2], 0.0F, 1.0F);
            b[3] = CLAMP(obj->BorderColor.f[3], 0.0F, 1.0F);
d1147 1
a1147 1
         break;;
d1157 1
a1157 1
         break;;
d1160 1
a1160 1
         break;;
d1163 1
a1163 1
         break;;
d1166 1
a1166 1
         break;;
d1169 1
a1169 1
         break;;
d1172 1
a1172 1
         break;;
d1176 1
d1178 5
a1182 2
         else {
            error = GL_TRUE;
d1185 4
a1188 3
      case GL_TEXTURE_COMPARE_FAIL_VALUE_ARB:
         if (ctx->Extensions.ARB_shadow_ambient) {
            *params = (GLint) FLOAT_TO_INT(obj->CompareFailValue);
d1190 5
a1194 2
         else {
            error = GL_TRUE;
d1198 4
a1201 1
	 *params = (GLint) obj->GenerateMipmap;
d1206 1
a1206 3
         }
         else {
            error = GL_TRUE;
d1212 1
a1212 3
         }
         else {
            error = GL_TRUE;
d1218 1
a1218 3
         }
         else {
            error = GL_TRUE;
d1224 1
a1224 3
         }
         else {
            error = GL_TRUE;
d1227 1
a1227 1
#if FEATURE_OES_draw_texture
a1234 22
      case GL_TEXTURE_SWIZZLE_R_EXT:
      case GL_TEXTURE_SWIZZLE_G_EXT:
      case GL_TEXTURE_SWIZZLE_B_EXT:
      case GL_TEXTURE_SWIZZLE_A_EXT:
         if (ctx->Extensions.EXT_texture_swizzle) {
            GLuint comp = pname - GL_TEXTURE_SWIZZLE_R_EXT;
            *params = obj->Swizzle[comp];
         }
         else {
            error = GL_TRUE;
         }
         break;

      case GL_TEXTURE_SWIZZLE_RGBA_EXT:
         if (ctx->Extensions.EXT_texture_swizzle) {
            COPY_4V(params, obj->Swizzle);
         }
         else {
            error = GL_TRUE;
         }
         break;

d1238 2
a1239 56

   if (error)
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexParameteriv(pname=0x%x)",
		  pname);

   _mesa_unlock_texture(ctx, obj);
}


/** New in GL 3.0 */
void GLAPIENTRY
_mesa_GetTexParameterIiv(GLenum target, GLenum pname, GLint *params)
{
   struct gl_texture_object *texObj;
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   texObj = get_texobj(ctx, target, GL_TRUE);
   
   switch (pname) {
   case GL_TEXTURE_BORDER_COLOR:
      COPY_4V(params, texObj->BorderColor.i);
      break;
   default:
      _mesa_GetTexParameteriv(target, pname, params);
   }
}


/** New in GL 3.0 */
void GLAPIENTRY
_mesa_GetTexParameterIuiv(GLenum target, GLenum pname, GLuint *params)
{
   struct gl_texture_object *texObj;
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   texObj = get_texobj(ctx, target, GL_TRUE);
   
   switch (pname) {
   case GL_TEXTURE_BORDER_COLOR:
      COPY_4V(params, texObj->BorderColor.i);
      break;
   default:
      {
         GLint ip[4];
         _mesa_GetTexParameteriv(target, pname, ip);
         params[0] = ip[0];
         if (pname == GL_TEXTURE_SWIZZLE_RGBA_EXT || 
             pname == GL_TEXTURE_CROP_RECT_OES) {
            params[1] = ip[1];
            params[2] = ip[2];
            params[3] = ip[3];
         }
      }
   }
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d3 1
d21 3
a23 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
d32 1
a32 1
#include <stdbool.h>
a33 1
#include "main/blend.h"
a35 1
#include "main/enums.h"
a36 1
#include "main/glformats.h"
a37 2
#include "main/mtypes.h"
#include "main/state.h"
a38 1
#include "main/texobj.h"
a52 2
   const bool is_desktop_gl = _mesa_is_desktop_gl(ctx);
   bool supported;
d54 17
a70 41
   switch (wrap) {
   case GL_CLAMP:
      /* GL_CLAMP was removed in the core profile, and it has never existed in
       * OpenGL ES.
       */
      supported = (ctx->API == API_OPENGL_COMPAT)
         && (target != GL_TEXTURE_EXTERNAL_OES);
      break;

   case GL_CLAMP_TO_EDGE:
      supported = true;
      break;

   case GL_CLAMP_TO_BORDER:
      supported = is_desktop_gl && e->ARB_texture_border_clamp
         && (target != GL_TEXTURE_EXTERNAL_OES);
      break;

   case GL_REPEAT:
   case GL_MIRRORED_REPEAT:
      supported = (target != GL_TEXTURE_RECTANGLE_NV)
         && (target != GL_TEXTURE_EXTERNAL_OES);
      break;

   case GL_MIRROR_CLAMP_EXT:
   case GL_MIRROR_CLAMP_TO_EDGE_EXT:
      supported = is_desktop_gl 
         && (e->ATI_texture_mirror_once || e->EXT_texture_mirror_clamp)
	 && (target != GL_TEXTURE_RECTANGLE_NV)
         && (target != GL_TEXTURE_EXTERNAL_OES);
      break;

   case GL_MIRROR_CLAMP_TO_BORDER_EXT:
      supported = is_desktop_gl && e->EXT_texture_mirror_clamp
	 && (target != GL_TEXTURE_RECTANGLE_NV)
         && (target != GL_TEXTURE_EXTERNAL_OES);
      break;

   default:
      supported = false;
      break;
d73 2
a74 4
   if (!supported)
      _mesa_error( ctx, GL_INVALID_ENUM, "glTexParameter(param=0x%x)", wrap );

   return supported;
d100 1
a100 3
      if (_mesa_is_desktop_gl(ctx))
         return texUnit->CurrentTex[TEXTURE_1D_INDEX];
      break;
d104 1
a104 3
      if (ctx->API != API_OPENGLES)
         return texUnit->CurrentTex[TEXTURE_3D_INDEX];
      break;
d111 1
a111 2
      if (_mesa_is_desktop_gl(ctx)
          && ctx->Extensions.NV_texture_rectangle) {
d116 1
a116 3
      if (_mesa_is_desktop_gl(ctx)
          && (ctx->Extensions.MESA_texture_array ||
              ctx->Extensions.EXT_texture_array)) {
d121 1
a121 3
      if ((_mesa_is_desktop_gl(ctx) || _mesa_is_gles3(ctx))
          && (ctx->Extensions.MESA_texture_array ||
              ctx->Extensions.EXT_texture_array)) {
a124 20
   case GL_TEXTURE_EXTERNAL_OES:
      if (_mesa_is_gles(ctx) && ctx->Extensions.OES_EGL_image_external) {
         return texUnit->CurrentTex[TEXTURE_EXTERNAL_INDEX];
      }
      break;
   case GL_TEXTURE_CUBE_MAP_ARRAY:
      if (ctx->Extensions.ARB_texture_cube_map_array) {
         return texUnit->CurrentTex[TEXTURE_CUBE_ARRAY_INDEX];
      }
      break;
   case GL_TEXTURE_2D_MULTISAMPLE:
      if (ctx->Extensions.ARB_texture_multisample) {
         return texUnit->CurrentTex[TEXTURE_2D_MULTISAMPLE_INDEX];
      }
      break;
   case GL_TEXTURE_2D_MULTISAMPLE_ARRAY:
      if (ctx->Extensions.ARB_texture_multisample) {
         return texUnit->CurrentTex[TEXTURE_2D_MULTISAMPLE_ARRAY_INDEX];
      }
      break;
d175 1
a175 13
 * This is called just prior to changing any texture object state which
 * will not effect texture completeness.
 */
static inline void
flush(struct gl_context *ctx)
{
   FLUSH_VERTICES(ctx, _NEW_TEXTURE);
}


/**
 * This is called just prior to changing any texture object state which
 * can effect texture completeness (texture base level, max level).
d180 2
a181 2
static inline void
incomplete(struct gl_context *ctx, struct gl_texture_object *texObj)
d184 1
a184 15
   _mesa_dirty_texobj(ctx, texObj, GL_TRUE);
}


static GLboolean
target_allows_setting_sampler_parameters(GLenum target)
{
   switch (target) {
   case GL_TEXTURE_2D_MULTISAMPLE:
   case GL_TEXTURE_2D_MULTISAMPLE_ARRAY:
      return GL_FALSE;

   default:
      return GL_TRUE;
   }
d199 1
a199 4
      if (!target_allows_setting_sampler_parameters(texObj->Target))
         goto invalid_operation;

      if (texObj->Sampler.MinFilter == params[0])
d204 2
a205 2
         flush(ctx);
         texObj->Sampler.MinFilter = params[0];
d211 3
a213 4
         if (texObj->Target != GL_TEXTURE_RECTANGLE_NV &&
             texObj->Target != GL_TEXTURE_EXTERNAL_OES) {
            flush(ctx);
            texObj->Sampler.MinFilter = params[0];
d218 2
a219 1
         goto invalid_param;
d224 1
a224 4
      if (!target_allows_setting_sampler_parameters(texObj->Target))
         goto invalid_operation;

      if (texObj->Sampler.MagFilter == params[0])
d229 2
a230 2
         flush(ctx); /* does not effect completeness */
         texObj->Sampler.MagFilter = params[0];
d233 2
a234 1
         goto invalid_param;
d239 1
a239 4
      if (!target_allows_setting_sampler_parameters(texObj->Target))
         goto invalid_operation;

      if (texObj->Sampler.WrapS == params[0])
d242 2
a243 2
         flush(ctx);
         texObj->Sampler.WrapS = params[0];
d249 1
a249 4
      if (!target_allows_setting_sampler_parameters(texObj->Target))
         goto invalid_operation;

      if (texObj->Sampler.WrapT == params[0])
d252 2
a253 2
         flush(ctx);
         texObj->Sampler.WrapT = params[0];
d259 1
a259 4
      if (!target_allows_setting_sampler_parameters(texObj->Target))
         goto invalid_operation;

      if (texObj->Sampler.WrapR == params[0])
d262 2
a263 2
         flush(ctx);
         texObj->Sampler.WrapR = params[0];
a268 3
      if (!_mesa_is_desktop_gl(ctx) && !_mesa_is_gles3(ctx))
         goto invalid_pname;

a270 5

      if ((texObj->Target == GL_TEXTURE_2D_MULTISAMPLE ||
           texObj->Target == GL_TEXTURE_2D_MULTISAMPLE_ARRAY) && params[0] != 0)
         goto invalid_operation;

d277 1
a277 1
      incomplete(ctx, texObj);
a283 1

d285 1
a285 1
         _mesa_error(ctx, GL_INVALID_VALUE,
d289 1
a289 1
      incomplete(ctx, texObj);
a293 5
      if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
         goto invalid_pname;

      if (params[0] && texObj->Target == GL_TEXTURE_EXTERNAL_OES)
         goto invalid_param;
d295 1
a295 1
         /* no flush() */
d302 6
a307 12
      if ((_mesa_is_desktop_gl(ctx) && ctx->Extensions.ARB_shadow)
          || _mesa_is_gles3(ctx)) {

         if (!target_allows_setting_sampler_parameters(texObj->Target))
            goto invalid_operation;

         if (texObj->Sampler.CompareMode == params[0])
            return GL_FALSE;
         if (params[0] == GL_NONE ||
             params[0] == GL_COMPARE_R_TO_TEXTURE_ARB) {
            flush(ctx);
            texObj->Sampler.CompareMode = params[0];
d310 1
a310 1
         goto invalid_param;
d312 5
a316 1
      goto invalid_pname;
d319 2
a320 7
      if ((_mesa_is_desktop_gl(ctx) && ctx->Extensions.ARB_shadow)
          || _mesa_is_gles3(ctx)) {

         if (!target_allows_setting_sampler_parameters(texObj->Target))
            goto invalid_operation;

         if (texObj->Sampler.CompareFunc == params[0])
d325 3
d334 6
a339 3
            flush(ctx);
            texObj->Sampler.CompareFunc = params[0];
            return GL_TRUE;
d341 2
a342 1
            goto invalid_param;
d345 4
a348 1
      goto invalid_pname;
d351 7
a357 11
      /* GL_DEPTH_TEXTURE_MODE_ARB is removed in core-profile and it has never
       * existed in OpenGL ES.
       */
      if (ctx->API == API_OPENGL_COMPAT && ctx->Extensions.ARB_depth_texture) {
         if (texObj->DepthMode == params[0])
            return GL_FALSE;
         if (params[0] == GL_LUMINANCE ||
             params[0] == GL_INTENSITY ||
             params[0] == GL_ALPHA ||
             (ctx->Extensions.ARB_texture_rg && params[0] == GL_RED)) {
            flush(ctx);
a360 1
         goto invalid_param;
d362 5
a366 1
      goto invalid_pname;
d368 1
a369 3
      if (ctx->API != API_OPENGLES || !ctx->Extensions.OES_draw_texture)
         goto invalid_pname;

d375 1
d381 1
a381 2
      if ((_mesa_is_desktop_gl(ctx) && ctx->Extensions.EXT_texture_swizzle)
          || _mesa_is_gles3(ctx)) {
d390 6
a395 5

         flush(ctx);
         texObj->Swizzle[comp] = params[0];
         set_swizzle_component(&texObj->_Swizzle, comp, swz);
         return GL_TRUE;
d397 2
a398 1
      goto invalid_pname;
d401 1
a401 2
      if ((_mesa_is_desktop_gl(ctx) && ctx->Extensions.EXT_texture_swizzle)
          || _mesa_is_gles3(ctx)) {
d403 1
a403 1
         flush(ctx);
d418 2
a419 38
      goto invalid_pname;

   case GL_TEXTURE_SRGB_DECODE_EXT:
      if (_mesa_is_desktop_gl(ctx)
          && ctx->Extensions.EXT_texture_sRGB_decode) {
         GLenum decode = params[0];

         if (!target_allows_setting_sampler_parameters(texObj->Target))
            goto invalid_operation;

	 if (decode == GL_DECODE_EXT || decode == GL_SKIP_DECODE_EXT) {
	    if (texObj->Sampler.sRGBDecode != decode) {
	       flush(ctx);
	       texObj->Sampler.sRGBDecode = decode;
	    }
	    return GL_TRUE;
	 }
      }
      goto invalid_pname;

   case GL_TEXTURE_CUBE_MAP_SEAMLESS:
      if (_mesa_is_desktop_gl(ctx)
          && ctx->Extensions.AMD_seamless_cubemap_per_texture) {
         GLenum param = params[0];

         if (!target_allows_setting_sampler_parameters(texObj->Target))
            goto invalid_operation;

         if (param != GL_TRUE && param != GL_FALSE) {
            goto invalid_param;
         }
         if (param != texObj->Sampler.CubeMapSeamless) {
            flush(ctx);
            texObj->Sampler.CubeMapSeamless = param;
         }
         return GL_TRUE;
      }
      goto invalid_pname;
d422 1
a422 1
      goto invalid_pname;
a423 14

invalid_pname:
   _mesa_error(ctx, GL_INVALID_ENUM, "glTexParameter(pname=%s)",
               _mesa_lookup_enum_by_nr(pname));
   return GL_FALSE;

invalid_param:
   _mesa_error(ctx, GL_INVALID_ENUM, "glTexParameter(param=%s)",
               _mesa_lookup_enum_by_nr(params[0]));
   return GL_FALSE;

invalid_operation:
   _mesa_error(ctx, GL_INVALID_OPERATION, "glTexParameter(pname=%s)",
               _mesa_lookup_enum_by_nr(pname));
d439 1
a439 7
      if (!_mesa_is_desktop_gl(ctx) && !_mesa_is_gles3(ctx))
         goto invalid_pname;

      if (!target_allows_setting_sampler_parameters(texObj->Target))
         goto invalid_operation;

      if (texObj->Sampler.MinLod == params[0])
d441 2
a442 2
      flush(ctx);
      texObj->Sampler.MinLod = params[0];
d446 1
a446 7
      if (!_mesa_is_desktop_gl(ctx) && !_mesa_is_gles3(ctx))
         goto invalid_pname;

      if (!target_allows_setting_sampler_parameters(texObj->Target))
         goto invalid_operation;

      if (texObj->Sampler.MaxLod == params[0])
d448 2
a449 2
      flush(ctx);
      texObj->Sampler.MaxLod = params[0];
d453 1
a453 4
      if (ctx->API != API_OPENGL_COMPAT)
         goto invalid_pname;

      flush(ctx);
d459 1
a459 4
         if (!target_allows_setting_sampler_parameters(texObj->Target))
            goto invalid_operation;

         if (texObj->Sampler.MaxAnisotropy == params[0])
d465 1
a465 1
         flush(ctx);
d467 1
a467 1
         texObj->Sampler.MaxAnisotropy = MIN2(params[0],
d474 16
a489 1
            goto invalid_pname;
d494 8
a501 14
      /* NOTE: this is really part of OpenGL 1.4, not EXT_texture_lod_bias.
       * It was removed in core-profile, and it has never existed in OpenGL
       * ES.
       */
      if (ctx->API != API_OPENGL_COMPAT)
         goto invalid_pname;

      if (!target_allows_setting_sampler_parameters(texObj->Target))
         goto invalid_operation;

      if (texObj->Sampler.LodBias != params[0]) {
	 flush(ctx);
	 texObj->Sampler.LodBias = params[0];
	 return GL_TRUE;
d506 5
a510 19
      if (!_mesa_is_desktop_gl(ctx))
         goto invalid_pname;

      if (!target_allows_setting_sampler_parameters(texObj->Target))
         goto invalid_operation;

      flush(ctx);
      /* ARB_texture_float disables clamping */
      if (ctx->Extensions.ARB_texture_float) {
         texObj->Sampler.BorderColor.f[RCOMP] = params[0];
         texObj->Sampler.BorderColor.f[GCOMP] = params[1];
         texObj->Sampler.BorderColor.f[BCOMP] = params[2];
         texObj->Sampler.BorderColor.f[ACOMP] = params[3];
      } else {
         texObj->Sampler.BorderColor.f[RCOMP] = CLAMP(params[0], 0.0F, 1.0F);
         texObj->Sampler.BorderColor.f[GCOMP] = CLAMP(params[1], 0.0F, 1.0F);
         texObj->Sampler.BorderColor.f[BCOMP] = CLAMP(params[2], 0.0F, 1.0F);
         texObj->Sampler.BorderColor.f[ACOMP] = CLAMP(params[3], 0.0F, 1.0F);
      }
d514 1
a514 1
      goto invalid_pname;
a516 10

invalid_pname:
   _mesa_error(ctx, GL_INVALID_ENUM, "glTexParameter(pname=%s)",
               _mesa_lookup_enum_by_nr(pname));
   return GL_FALSE;

invalid_operation:
   _mesa_error(ctx, GL_INVALID_OPERATION, "glTexParameter(pname=%s)",
               _mesa_lookup_enum_by_nr(pname));
   return GL_FALSE;
d526 1
a543 6
   case GL_TEXTURE_SRGB_DECODE_EXT:
   case GL_TEXTURE_CUBE_MAP_SEAMLESS:
   case GL_TEXTURE_SWIZZLE_R_EXT:
   case GL_TEXTURE_SWIZZLE_G_EXT:
   case GL_TEXTURE_SWIZZLE_B_EXT:
   case GL_TEXTURE_SWIZZLE_A_EXT:
d545 1
d547 1
a547 4
         p[0] = (param > 0) ?
                ((param > INT_MAX) ? INT_MAX : (GLint) (param + 0.5)) :
                ((param < INT_MIN) ? INT_MIN : (GLint) (param - 0.5));

d574 1
a591 2
   case GL_TEXTURE_SRGB_DECODE_EXT:
   case GL_TEXTURE_CUBE_MAP_SEAMLESS:
d600 2
d613 2
a614 16
   case GL_TEXTURE_SWIZZLE_R_EXT:
   case GL_TEXTURE_SWIZZLE_G_EXT:
   case GL_TEXTURE_SWIZZLE_B_EXT:
   case GL_TEXTURE_SWIZZLE_A_EXT:
   case GL_TEXTURE_SWIZZLE_RGBA_EXT:
      {
         GLint p[4] = {0, 0, 0, 0};
         p[0] = (GLint) params[0];
         if (pname == GL_TEXTURE_SWIZZLE_RGBA_EXT) {
            p[1] = (GLint) params[1];
            p[2] = (GLint) params[2];
            p[3] = (GLint) params[3];
         }
         need_update = set_tex_parameteri(ctx, texObj, pname, p);
      }
      break;
d632 1
d676 1
d737 1
d747 1
a747 1
      COPY_4V(texObj->Sampler.BorderColor.i, params);
d767 1
d777 1
a777 1
      COPY_4V(texObj->Sampler.BorderColor.ui, params);
d787 5
a791 2
static GLboolean
legal_get_tex_level_parameter_target(struct gl_context *ctx, GLenum target)
d793 3
a795 52
   switch (target) {
   case GL_TEXTURE_1D:
   case GL_PROXY_TEXTURE_1D:
   case GL_TEXTURE_2D:
   case GL_PROXY_TEXTURE_2D:
   case GL_TEXTURE_3D:
   case GL_PROXY_TEXTURE_3D:
      return GL_TRUE;
   case GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB:
   case GL_PROXY_TEXTURE_CUBE_MAP_ARB:
      return ctx->Extensions.ARB_texture_cube_map;
   case GL_TEXTURE_RECTANGLE_NV:
   case GL_PROXY_TEXTURE_RECTANGLE_NV:
      return ctx->Extensions.NV_texture_rectangle;
   case GL_TEXTURE_1D_ARRAY_EXT:
   case GL_PROXY_TEXTURE_1D_ARRAY_EXT:
   case GL_TEXTURE_2D_ARRAY_EXT:
   case GL_PROXY_TEXTURE_2D_ARRAY_EXT:
      return (ctx->Extensions.MESA_texture_array ||
              ctx->Extensions.EXT_texture_array);
   case GL_TEXTURE_BUFFER:
      /* GetTexLevelParameter accepts GL_TEXTURE_BUFFER in GL 3.1+ contexts,
       * but not in earlier versions that expose ARB_texture_buffer_object.
       *
       * From the ARB_texture_buffer_object spec:
       * "(7) Do buffer textures support texture parameters (TexParameter) or
       *      queries (GetTexParameter, GetTexLevelParameter, GetTexImage)?
       *
       *    RESOLVED:  No. [...] Note that the spec edits above don't add
       *    explicit error language for any of these cases.  That is because
       *    each of the functions enumerate the set of valid <target>
       *    parameters.  Not editing the spec to allow TEXTURE_BUFFER_ARB in
       *    these cases means that target is not legal, and an INVALID_ENUM
       *    error should be generated."
       *
       * From the OpenGL 3.1 spec:
       * "target may also be TEXTURE_BUFFER, indicating the texture buffer."
       */
      return ctx->API == API_OPENGL_CORE && ctx->Version >= 31;
   case GL_TEXTURE_2D_MULTISAMPLE:
   case GL_TEXTURE_2D_MULTISAMPLE_ARRAY:
   case GL_PROXY_TEXTURE_2D_MULTISAMPLE:
   case GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY:
      return ctx->Extensions.ARB_texture_multisample;
   default:
      return GL_FALSE;
   }
d799 3
a801 5
static void
get_tex_level_parameter_image(struct gl_context *ctx,
                              const struct gl_texture_object *texObj,
                              GLenum target, GLint level,
                              GLenum pname, GLint *params)
d803 2
d806 2
d809 26
d837 1
a837 1
   if (!img || img->TexFormat == MESA_FORMAT_NONE) {
d843 1
a843 1
      return;
d848 2
d861 1
a861 1
         if (_mesa_is_format_compressed(texFormat)) {
d863 1
a863 1
            *params = _mesa_compressed_format_to_glenum(ctx, texFormat);
d866 3
a868 17
	    /* If the true internal format is not compressed but the user
	     * requested a generic compressed format, we have to return the
	     * generic base format that matches.
	     *
	     * From page 119 (page 129 of the PDF) of the OpenGL 1.3 spec:
	     *
	     *     "If no specific compressed format is available,
	     *     internalformat is instead replaced by the corresponding base
	     *     internal format."
	     *
	     * Otherwise just return the user's requested internal format
	     */
	    const GLenum f =
	       _mesa_gl_compressed_format_base_format(img->InternalFormat);

	    *params = (f != 0) ? f : img->InternalFormat;
	 }
d874 5
d880 5
d886 5
d892 3
a894 1
         if (_mesa_base_format_has_channel(img->_BaseFormat, pname))
d900 11
d912 4
a915 1
         if (_mesa_base_format_has_channel(img->_BaseFormat, pname)) {
d918 3
a920 5
               /* intensity or luminance is probably stored as RGB[A] */
               *params = MIN2(_mesa_get_format_bits(texFormat,
                                                    GL_TEXTURE_RED_SIZE),
                              _mesa_get_format_bits(texFormat,
                                                    GL_TEXTURE_GREEN_SIZE));
d923 5
a927 1
         else {
a928 1
         }
d931 5
a935 3
         if (!ctx->Extensions.ARB_depth_texture)
            goto invalid_pname;
         *params = _mesa_get_format_bits(texFormat, pname);
d938 8
a945 4
         if (!ctx->Extensions.EXT_packed_depth_stencil &&
             !ctx->Extensions.ARB_framebuffer_object)
            goto invalid_pname;
         *params = _mesa_get_format_bits(texFormat, pname);
d948 10
a957 4
         if (ctx->Version < 30 &&
             !ctx->Extensions.EXT_texture_shared_exponent)
            goto invalid_pname;
         *params = texFormat == MESA_FORMAT_RGB9_E5_FLOAT ? 5 : 0;
d962 1
a962 2
	 if (_mesa_is_format_compressed(texFormat) &&
             !_mesa_is_proxy_texture(target)) {
d972 1
a972 1
         *params = (GLint) _mesa_is_format_compressed(texFormat);
d977 9
d987 9
d997 9
d1007 9
d1017 9
d1027 7
a1033 91
      case GL_TEXTURE_DEPTH_TYPE_ARB:
         if (!ctx->Extensions.ARB_texture_float)
            goto invalid_pname;
	 if (_mesa_base_format_has_channel(img->_BaseFormat, pname))
	    *params = _mesa_get_format_datatype(texFormat);
	 else
	    *params = GL_NONE;
         break;

      /* GL_ARB_texture_multisample */
      case GL_TEXTURE_SAMPLES:
         if (!ctx->Extensions.ARB_texture_multisample)
            goto invalid_pname;
         *params = img->NumSamples;
         break;

      case GL_TEXTURE_FIXED_SAMPLE_LOCATIONS:
         if (!ctx->Extensions.ARB_texture_multisample)
            goto invalid_pname;
         *params = img->FixedSampleLocations;
         break;

      default:
         goto invalid_pname;
   }

   /* no error if we get here */
   return;

invalid_pname:
   _mesa_error(ctx, GL_INVALID_ENUM,
               "glGetTexLevelParameter[if]v(pname=%s)",
               _mesa_lookup_enum_by_nr(pname));
}


static void
get_tex_level_parameter_buffer(struct gl_context *ctx,
                               const struct gl_texture_object *texObj,
                               GLenum pname, GLint *params)
{
   const struct gl_buffer_object *bo = texObj->BufferObject;
   gl_format texFormat = texObj->_BufferObjectFormat;
   GLenum internalFormat = texObj->BufferObjectFormat;
   GLenum baseFormat = _mesa_get_format_base_format(texFormat);

   if (!bo) {
      /* undefined texture buffer object */
      *params = pname == GL_TEXTURE_COMPONENTS ? 1 : 0;
      return;
   }

   switch (pname) {
      case GL_TEXTURE_BUFFER_DATA_STORE_BINDING:
         *params = bo->Name;
         break;
      case GL_TEXTURE_WIDTH:
         *params = bo->Size;
         break;
      case GL_TEXTURE_HEIGHT:
      case GL_TEXTURE_DEPTH:
      case GL_TEXTURE_BORDER:
      case GL_TEXTURE_SHARED_SIZE:
      case GL_TEXTURE_COMPRESSED:
         *params = 0;
         break;
      case GL_TEXTURE_INTERNAL_FORMAT:
         *params = internalFormat;
         break;
      case GL_TEXTURE_RED_SIZE:
      case GL_TEXTURE_GREEN_SIZE:
      case GL_TEXTURE_BLUE_SIZE:
      case GL_TEXTURE_ALPHA_SIZE:
         if (_mesa_base_format_has_channel(baseFormat, pname))
            *params = _mesa_get_format_bits(texFormat, pname);
         else
            *params = 0;
         break;
      case GL_TEXTURE_INTENSITY_SIZE:
      case GL_TEXTURE_LUMINANCE_SIZE:
         if (_mesa_base_format_has_channel(baseFormat, pname)) {
            *params = _mesa_get_format_bits(texFormat, pname);
            if (*params == 0) {
               /* intensity or luminance is probably stored as RGB[A] */
               *params = MIN2(_mesa_get_format_bits(texFormat,
                                                    GL_TEXTURE_RED_SIZE),
                              _mesa_get_format_bits(texFormat,
                                                    GL_TEXTURE_GREEN_SIZE));
            }
         } else {
            *params = 0;
a1035 31
      case GL_TEXTURE_DEPTH_SIZE_ARB:
      case GL_TEXTURE_STENCIL_SIZE_EXT:
         *params = _mesa_get_format_bits(texFormat, pname);
         break;

      /* GL_ARB_texture_buffer_range */
      case GL_TEXTURE_BUFFER_OFFSET:
         if (!ctx->Extensions.ARB_texture_buffer_range)
            goto invalid_pname;
         *params = texObj->BufferOffset;
         break;
      case GL_TEXTURE_BUFFER_SIZE:
         if (!ctx->Extensions.ARB_texture_buffer_range)
            goto invalid_pname;
         *params = (texObj->BufferSize == -1) ? bo->Size : texObj->BufferSize;
         break;

      /* GL_ARB_texture_compression */
      case GL_TEXTURE_COMPRESSED_IMAGE_SIZE:
         /* Always illegal for GL_TEXTURE_BUFFER */
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glGetTexLevelParameter[if]v(pname)");
         break;

      /* GL_ARB_texture_float */
      case GL_TEXTURE_RED_TYPE_ARB:
      case GL_TEXTURE_GREEN_TYPE_ARB:
      case GL_TEXTURE_BLUE_TYPE_ARB:
      case GL_TEXTURE_ALPHA_TYPE_ARB:
      case GL_TEXTURE_LUMINANCE_TYPE_ARB:
      case GL_TEXTURE_INTENSITY_TYPE_ARB:
d1037 8
a1044 6
         if (!ctx->Extensions.ARB_texture_float)
            goto invalid_pname;
         if (_mesa_base_format_has_channel(baseFormat, pname))
            *params = _mesa_get_format_datatype(texFormat);
         else
            *params = GL_NONE;
d1048 2
a1049 1
         goto invalid_pname;
d1052 2
a1053 7
   /* no error if we get here */
   return;

invalid_pname:
   _mesa_error(ctx, GL_INVALID_ENUM,
               "glGetTexLevelParameter[if]v(pname=%s)",
               _mesa_lookup_enum_by_nr(pname));
a1056 49
void GLAPIENTRY
_mesa_GetTexLevelParameterfv( GLenum target, GLint level,
                              GLenum pname, GLfloat *params )
{
   GLint iparam;
   _mesa_GetTexLevelParameteriv( target, level, pname, &iparam );
   *params = (GLfloat) iparam;
}


void GLAPIENTRY
_mesa_GetTexLevelParameteriv( GLenum target, GLint level,
                              GLenum pname, GLint *params )
{
   const struct gl_texture_unit *texUnit;
   struct gl_texture_object *texObj;
   GLint maxLevels;
   GET_CURRENT_CONTEXT(ctx);

   if (ctx->Texture.CurrentUnit >= ctx->Const.MaxCombinedTextureImageUnits) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glGetTexLevelParameteriv(current unit)");
      return;
   }

   texUnit = _mesa_get_current_tex_unit(ctx);

   if (!legal_get_tex_level_parameter_target(ctx, target)) {
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "glGetTexLevelParameter[if]v(target=0x%x)", target);
      return;
   }

   maxLevels = _mesa_max_texture_levels(ctx, target);
   assert(maxLevels != 0);

   if (level < 0 || level >= maxLevels) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glGetTexLevelParameter[if]v" );
      return;
   }

   texObj = _mesa_select_tex_object(ctx, texUnit, target);

   if (target == GL_TEXTURE_BUFFER)
      get_tex_level_parameter_buffer(ctx, texObj, pname, params);
   else
      get_tex_level_parameter_image(ctx, texObj, target, level, pname, params);
}

d1062 1
d1064 1
d1073 1
a1073 1
	 *params = ENUM_TO_FLOAT(obj->Sampler.MagFilter);
d1076 1
a1076 1
         *params = ENUM_TO_FLOAT(obj->Sampler.MinFilter);
d1079 1
a1079 1
         *params = ENUM_TO_FLOAT(obj->Sampler.WrapS);
d1082 1
a1082 1
         *params = ENUM_TO_FLOAT(obj->Sampler.WrapT);
d1085 1
a1085 1
         *params = ENUM_TO_FLOAT(obj->Sampler.WrapR);
d1088 4
a1091 17
         if (!_mesa_is_desktop_gl(ctx))
            goto invalid_pname;

         if (ctx->NewState & (_NEW_BUFFERS | _NEW_FRAG_CLAMP))
            _mesa_update_state_locked(ctx);
         if (_mesa_get_clamp_fragment_color(ctx)) {
            params[0] = CLAMP(obj->Sampler.BorderColor.f[0], 0.0F, 1.0F);
            params[1] = CLAMP(obj->Sampler.BorderColor.f[1], 0.0F, 1.0F);
            params[2] = CLAMP(obj->Sampler.BorderColor.f[2], 0.0F, 1.0F);
            params[3] = CLAMP(obj->Sampler.BorderColor.f[3], 0.0F, 1.0F);
         }
         else {
            params[0] = obj->Sampler.BorderColor.f[0];
            params[1] = obj->Sampler.BorderColor.f[1];
            params[2] = obj->Sampler.BorderColor.f[2];
            params[3] = obj->Sampler.BorderColor.f[3];
         }
d1094 8
a1101 4
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_pname;

         *params = 1.0F;
a1103 3
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_pname;

d1107 1
a1107 4
         if (!_mesa_is_desktop_gl(ctx) && !_mesa_is_gles3(ctx))
            goto invalid_pname;

         *params = obj->Sampler.MinLod;
d1110 1
a1110 4
         if (!_mesa_is_desktop_gl(ctx) && !_mesa_is_gles3(ctx))
            goto invalid_pname;

         *params = obj->Sampler.MaxLod;
a1112 3
         if (!_mesa_is_desktop_gl(ctx) && !_mesa_is_gles3(ctx))
            goto invalid_pname;

d1119 12
a1130 3
         if (!ctx->Extensions.EXT_texture_filter_anisotropic)
            goto invalid_pname;
         *params = obj->Sampler.MaxAnisotropy;
a1132 3
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_pname;

d1136 5
a1140 4
         if ((!_mesa_is_desktop_gl(ctx) || !ctx->Extensions.ARB_shadow)
             && !_mesa_is_gles3(ctx))
            goto invalid_pname;
         *params = (GLfloat) obj->Sampler.CompareMode;
d1143 5
a1147 4
         if ((!_mesa_is_desktop_gl(ctx) || !ctx->Extensions.ARB_shadow)
             && !_mesa_is_gles3(ctx))
            goto invalid_pname;
         *params = (GLfloat) obj->Sampler.CompareFunc;
d1150 5
a1154 6
         /* GL_DEPTH_TEXTURE_MODE_ARB is removed in core-profile and it has
          * never existed in OpenGL ES.
          */
         if (ctx->API != API_OPENGL_COMPAT || !ctx->Extensions.ARB_depth_texture)
            goto invalid_pname;
         *params = (GLfloat) obj->DepthMode;
d1157 5
a1161 4
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_pname;

         *params = obj->Sampler.LodBias;
d1163 1
d1165 4
a1168 7
         if (ctx->API != API_OPENGLES || !ctx->Extensions.OES_draw_texture)
            goto invalid_pname;

         params[0] = (GLfloat) obj->CropRect[0];
         params[1] = (GLfloat) obj->CropRect[1];
         params[2] = (GLfloat) obj->CropRect[2];
         params[3] = (GLfloat) obj->CropRect[3];
d1170 1
d1176 7
a1182 5
         if ((!_mesa_is_desktop_gl(ctx)
              || !ctx->Extensions.EXT_texture_swizzle)
             && !_mesa_is_gles3(ctx))
            goto invalid_pname;
         *params = (GLfloat) obj->Swizzle[pname - GL_TEXTURE_SWIZZLE_R_EXT];
d1186 1
a1186 6
         if ((!_mesa_is_desktop_gl(ctx)
              || !ctx->Extensions.EXT_texture_swizzle)
             && !_mesa_is_gles3(ctx)) {
            goto invalid_pname;
         }
         else {
d1192 3
a1194 29
         break;

      case GL_TEXTURE_CUBE_MAP_SEAMLESS:
         if (!_mesa_is_desktop_gl(ctx)
             || !ctx->Extensions.AMD_seamless_cubemap_per_texture)
            goto invalid_pname;
         *params = (GLfloat) obj->Sampler.CubeMapSeamless;
         break;

      case GL_TEXTURE_IMMUTABLE_FORMAT:
         *params = (GLfloat) obj->Immutable;
         break;

      case GL_TEXTURE_IMMUTABLE_LEVELS:
         if (!_mesa_is_gles3(ctx))
            goto invalid_pname;
         *params = (GLfloat) obj->ImmutableLevels;
         break;

      case GL_REQUIRED_TEXTURE_IMAGE_UNITS_OES:
         if (!_mesa_is_gles(ctx) || !ctx->Extensions.OES_EGL_image_external)
            goto invalid_pname;
         *params = (GLfloat) obj->RequiredTextureImageUnits;
         break;

      case GL_TEXTURE_SRGB_DECODE_EXT:
         if (!ctx->Extensions.EXT_texture_sRGB_decode)
            goto invalid_pname;
         *params = (GLfloat) obj->Sampler.sRGBDecode;
d1198 2
a1199 1
         goto invalid_pname;
d1202 3
a1204 3
   /* no error if we get here */
   _mesa_unlock_texture(ctx, obj);
   return;
a1205 1
invalid_pname:
a1206 1
   _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexParameterfv(pname=0x%x)", pname);
d1214 1
d1216 1
d1218 3
a1220 3
   obj = get_texobj(ctx, target, GL_TRUE);
   if (!obj)
      return;
d1225 2
a1226 2
         *params = (GLint) obj->Sampler.MagFilter;
         break;
d1228 2
a1229 2
         *params = (GLint) obj->Sampler.MinFilter;
         break;
d1231 2
a1232 2
         *params = (GLint) obj->Sampler.WrapS;
         break;
d1234 2
a1235 2
         *params = (GLint) obj->Sampler.WrapT;
         break;
d1237 2
a1238 2
         *params = (GLint) obj->Sampler.WrapR;
         break;
a1239 3
         if (!_mesa_is_desktop_gl(ctx))
            goto invalid_pname;

d1242 4
a1245 4
            b[0] = CLAMP(obj->Sampler.BorderColor.f[0], 0.0F, 1.0F);
            b[1] = CLAMP(obj->Sampler.BorderColor.f[1], 0.0F, 1.0F);
            b[2] = CLAMP(obj->Sampler.BorderColor.f[2], 0.0F, 1.0F);
            b[3] = CLAMP(obj->Sampler.BorderColor.f[3], 0.0F, 1.0F);
d1251 1
a1251 1
         break;
d1253 9
a1261 5
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_pname;

         *params = 1;
         break;
a1262 3
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_pname;

d1264 1
a1264 1
         break;
d1266 2
a1267 5
         if (!_mesa_is_desktop_gl(ctx) && !_mesa_is_gles3(ctx))
            goto invalid_pname;

         *params = (GLint) obj->Sampler.MinLod;
         break;
d1269 2
a1270 5
         if (!_mesa_is_desktop_gl(ctx) && !_mesa_is_gles3(ctx))
            goto invalid_pname;

         *params = (GLint) obj->Sampler.MaxLod;
         break;
a1271 3
         if (!_mesa_is_desktop_gl(ctx) && !_mesa_is_gles3(ctx))
            goto invalid_pname;

d1273 1
a1273 1
         break;
d1276 8
d1285 7
a1291 4
      case GL_TEXTURE_MAX_ANISOTROPY_EXT:
         if (!ctx->Extensions.EXT_texture_filter_anisotropic)
            goto invalid_pname;
         *params = (GLint) obj->Sampler.MaxAnisotropy;
a1293 3
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_pname;

d1297 6
a1302 4
         if ((!_mesa_is_desktop_gl(ctx) || !ctx->Extensions.ARB_shadow)
             && !_mesa_is_gles3(ctx))
            goto invalid_pname;
         *params = (GLint) obj->Sampler.CompareMode;
d1305 6
a1310 4
         if ((!_mesa_is_desktop_gl(ctx) || !ctx->Extensions.ARB_shadow)
             && !_mesa_is_gles3(ctx))
            goto invalid_pname;
         *params = (GLint) obj->Sampler.CompareFunc;
d1313 6
a1318 3
         if (ctx->API != API_OPENGL_COMPAT || !ctx->Extensions.ARB_depth_texture)
            goto invalid_pname;
         *params = (GLint) obj->DepthMode;
d1321 6
a1326 4
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_pname;

         *params = (GLint) obj->Sampler.LodBias;
d1328 1
a1329 3
         if (ctx->API != API_OPENGLES || !ctx->Extensions.OES_draw_texture)
            goto invalid_pname;

d1335 1
d1340 7
a1346 5
         if ((!_mesa_is_desktop_gl(ctx)
              || !ctx->Extensions.EXT_texture_swizzle)
             && !_mesa_is_gles3(ctx))
            goto invalid_pname;
         *params = obj->Swizzle[pname - GL_TEXTURE_SWIZZLE_R_EXT];
d1350 6
a1355 34
         if ((!_mesa_is_desktop_gl(ctx)
              || !ctx->Extensions.EXT_texture_swizzle)
             && !_mesa_is_gles3(ctx))
            goto invalid_pname;
         COPY_4V(params, obj->Swizzle);
         break;

      case GL_TEXTURE_CUBE_MAP_SEAMLESS:
         if (!_mesa_is_desktop_gl(ctx)
             || !ctx->Extensions.AMD_seamless_cubemap_per_texture)
            goto invalid_pname;
         *params = (GLint) obj->Sampler.CubeMapSeamless;
         break;

      case GL_TEXTURE_IMMUTABLE_FORMAT:
         *params = (GLint) obj->Immutable;
         break;

      case GL_TEXTURE_IMMUTABLE_LEVELS:
         if (!_mesa_is_gles3(ctx))
            goto invalid_pname;
         *params = obj->ImmutableLevels;
         break;

      case GL_REQUIRED_TEXTURE_IMAGE_UNITS_OES:
         if (!_mesa_is_gles(ctx) || !ctx->Extensions.OES_EGL_image_external)
            goto invalid_pname;
         *params = obj->RequiredTextureImageUnits;
         break;

      case GL_TEXTURE_SRGB_DECODE_EXT:
         if (!ctx->Extensions.EXT_texture_sRGB_decode)
            goto invalid_pname;
         *params = obj->Sampler.sRGBDecode;
d1359 1
a1359 1
         goto invalid_pname;
d1362 3
a1364 3
   /* no error if we get here */
   _mesa_unlock_texture(ctx, obj);
   return;
a1365 1
invalid_pname:
a1366 1
   _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexParameteriv(pname=0x%x)", pname);
d1376 1
a1378 2
   if (!texObj)
      return;
d1382 1
a1382 1
      COPY_4V(params, texObj->Sampler.BorderColor.i);
d1396 1
a1398 2
   if (!texObj)
      return;
d1402 1
a1402 1
      COPY_4V(params, texObj->Sampler.BorderColor.i);
@


1.1.1.3
log
@Import Mesa 9.2.5
@
text
@d663 5
a667 2
      /* NOTE: this is really part of OpenGL 1.4, not EXT_texture_lod_bias. */
      if (_mesa_is_gles(ctx))
d1492 1
a1492 1
         if (_mesa_is_gles(ctx))
d1680 1
a1680 1
         if (_mesa_is_gles(ctx))
d1683 1
a1683 4
         /* GL spec 'Data Conversions' section specifies that floating-point
          * value in integer Get function is rounded to nearest integer
          */
         *params = (GLint) roundf(obj->Sampler.LodBias);
@


1.1.1.4
log
@Import Mesa 10.2.3
@
text
@d26 1
a26 1
/**
d55 1
a55 1
static GLboolean
d87 2
a88 1
      supported = is_desktop_gl
d90 1
a90 8
         && (target != GL_TEXTURE_RECTANGLE_NV)
         && (target != GL_TEXTURE_EXTERNAL_OES);
      break;

   case GL_MIRROR_CLAMP_TO_EDGE_EXT:
      supported = is_desktop_gl
         && (e->ATI_texture_mirror_once || e->EXT_texture_mirror_clamp || e->ARB_texture_mirror_clamp_to_edge)
         && (target != GL_TEXTURE_RECTANGLE_NV)
d96 1
a96 1
         && (target != GL_TEXTURE_RECTANGLE_NV)
d115 2
a116 2
 * Note that this is different from _mesa_get_current_tex_object() in that
 * proxy targets are not accepted.
a122 1
   int targetIndex;
d132 58
a189 5
   targetIndex = _mesa_tex_target_to_index(ctx, target);
   if (targetIndex < 0 || targetIndex == TEXTURE_BUFFER_INDEX) {
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "gl%sTexParameter(target)", get ? "Get" : "");
      return NULL;
a190 1
   assert(targetIndex < NUM_TEXTURE_TARGETS);
d192 3
a194 1
   return texUnit->CurrentTex[targetIndex];
d259 1
a259 1
   _mesa_dirty_texobj(ctx, texObj);
d389 1
a389 7

      /** See note about ARB_texture_storage below */
      if (texObj->Immutable)
         texObj->BaseLevel = MIN2(texObj->ImmutableLevels - 1, params[0]);
      else
         texObj->BaseLevel = params[0];

d396 1
a396 2
      if (params[0] < 0 ||
          (texObj->Target == GL_TEXTURE_RECTANGLE_ARB && params[0] > 0)) {
d402 1
a402 13

      /** From ARB_texture_storage:
       * However, if TEXTURE_IMMUTABLE_FORMAT is TRUE, then level_base is
       * clamped to the range [0, <levels> - 1] and level_max is then clamped to
       * the range [level_base, <levels> - 1], where <levels> is the parameter
       * passed the call to TexStorage* for the texture object.
       */
      if (texObj->Immutable)
          texObj->MaxLevel = CLAMP(params[0], texObj->BaseLevel,
                                   texObj->ImmutableLevels - 1);
      else
         texObj->MaxLevel = params[0];

a482 14
   case GL_DEPTH_STENCIL_TEXTURE_MODE:
      if (_mesa_is_desktop_gl(ctx) && ctx->Extensions.ARB_stencil_texturing) {
         bool stencil = params[0] == GL_STENCIL_INDEX;
         if (!stencil && params[0] != GL_DEPTH_COMPONENT)
            goto invalid_param;

         if (texObj->StencilSampling == stencil)
            return GL_FALSE;

         texObj->StencilSampling = stencil;
         return GL_TRUE;
      }
      goto invalid_pname;

d502 1
a502 1
            _mesa_error(ctx, GL_INVALID_ENUM,
d527 1
a527 1
               _mesa_error(ctx, GL_INVALID_ENUM,
a738 1
   case GL_DEPTH_STENCIL_TEXTURE_MODE:
d766 1
a766 1
      ctx->Driver.TexParameter(ctx, texObj, pname, &param);
a793 1
   case GL_DEPTH_STENCIL_TEXTURE_MODE:
d837 1
a837 1
      ctx->Driver.TexParameter(ctx, texObj, pname, params);
d880 1
a880 1
      ctx->Driver.TexParameter(ctx, texObj, pname, &fparam);
d936 1
a936 1
      ctx->Driver.TexParameter(ctx, texObj, pname, fparams);
a1017 3
   case GL_TEXTURE_CUBE_MAP_ARRAY_ARB:
   case GL_PROXY_TEXTURE_CUBE_MAP_ARRAY_ARB:
      return ctx->Extensions.ARB_texture_cube_map_array;
d1025 2
a1026 1
      return ctx->Extensions.EXT_texture_array;
d1064 1
a1064 1
   mesa_format texFormat;
d1068 3
a1070 10
      /* In case of undefined texture image return the default values.
       *
       * From OpenGL 4.0 spec, page 398:
       *    "The initial internal format of a texel array is RGBA
       *     instead of 1. TEXTURE_COMPONENTS is deprecated; always
       *     use TEXTURE_INTERNAL_FORMAT."
       */

      if (pname == GL_TEXTURE_INTERNAL_FORMAT)
         *params = GL_RGBA;
d1145 4
a1148 1
      case GL_TEXTURE_STENCIL_SIZE:
d1155 1
a1155 1
         *params = texFormat == MESA_FORMAT_R9G9B9E5_FLOAT ? 5 : 0;
d1223 1
a1223 1
   mesa_format texFormat = texObj->_BufferObjectFormat;
d1342 1
d1353 2
d1369 1
a1369 1
   texObj = _mesa_get_current_tex_object(ctx, target);
a1487 6
      case GL_DEPTH_STENCIL_TEXTURE_MODE:
         if (!_mesa_is_desktop_gl(ctx) || !ctx->Extensions.ARB_stencil_texturing)
            goto invalid_pname;
         *params = (GLfloat)
            (obj->StencilSampling ? GL_STENCIL_INDEX : GL_DEPTH_COMPONENT);
         break;
d1541 1
a1541 21
         if (_mesa_is_gles3(ctx) ||
             (_mesa_is_desktop_gl(ctx) && ctx->Extensions.ARB_texture_view))
            *params = (GLfloat) obj->ImmutableLevels;
         else
            goto invalid_pname;
         break;

      case GL_TEXTURE_VIEW_MIN_LEVEL:
         if (!ctx->Extensions.ARB_texture_view)
            goto invalid_pname;
         *params = (GLfloat) obj->MinLevel;
         break;

      case GL_TEXTURE_VIEW_NUM_LEVELS:
         if (!ctx->Extensions.ARB_texture_view)
            goto invalid_pname;
         *params = (GLfloat) obj->NumLevels;
         break;

      case GL_TEXTURE_VIEW_MIN_LAYER:
         if (!ctx->Extensions.ARB_texture_view)
d1543 1
a1543 7
         *params = (GLfloat) obj->MinLayer;
         break;

      case GL_TEXTURE_VIEW_NUM_LAYERS:
         if (!ctx->Extensions.ARB_texture_view)
            goto invalid_pname;
         *params = (GLfloat) obj->NumLayers;
a1675 6
      case GL_DEPTH_STENCIL_TEXTURE_MODE:
         if (!_mesa_is_desktop_gl(ctx) || !ctx->Extensions.ARB_stencil_texturing)
            goto invalid_pname;
         *params = (GLint)
            (obj->StencilSampling ? GL_STENCIL_INDEX : GL_DEPTH_COMPONENT);
         break;
d1683 1
a1683 1
         *params = IROUND(obj->Sampler.LodBias);
d1725 1
a1725 9
         if (_mesa_is_gles3(ctx) ||
             (_mesa_is_desktop_gl(ctx) && ctx->Extensions.ARB_texture_view))
            *params = obj->ImmutableLevels;
         else
            goto invalid_pname;
         break;

      case GL_TEXTURE_VIEW_MIN_LEVEL:
         if (!ctx->Extensions.ARB_texture_view)
d1727 1
a1727 19
         *params = (GLint) obj->MinLevel;
         break;

      case GL_TEXTURE_VIEW_NUM_LEVELS:
         if (!ctx->Extensions.ARB_texture_view)
            goto invalid_pname;
         *params = (GLint) obj->NumLevels;
         break;

      case GL_TEXTURE_VIEW_MIN_LAYER:
         if (!ctx->Extensions.ARB_texture_view)
            goto invalid_pname;
         *params = (GLint) obj->MinLayer;
         break;

      case GL_TEXTURE_VIEW_NUM_LAYERS:
         if (!ctx->Extensions.ARB_texture_view)
            goto invalid_pname;
         *params = (GLint) obj->NumLayers;
a1741 6
      case GL_IMAGE_FORMAT_COMPATIBILITY_TYPE:
         if (!ctx->Extensions.ARB_shader_image_load_store)
            goto invalid_pname;
         *params = obj->ImageFormatCompatibilityType;
         break;

d1766 1
a1766 1

d1787 1
a1787 1

d1797 1
a1797 1
         if (pname == GL_TEXTURE_SWIZZLE_RGBA_EXT ||
@


1.1.1.5
log
@Import Mesa 10.2.7
@
text
@a1053 1
   struct gl_texture_image dummy_image;
a1064 4
      memset(&dummy_image, 0, sizeof(dummy_image));
      dummy_image.TexFormat = MESA_FORMAT_NONE;
      dummy_image.InternalFormat = GL_RGBA;
      dummy_image._BaseFormat = GL_NONE;
d1066 5
a1070 1
      img = &dummy_image;
a1109 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_pname;
a1122 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_pname;
a1168 5
      case GL_TEXTURE_LUMINANCE_TYPE_ARB:
      case GL_TEXTURE_INTENSITY_TYPE_ARB:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_pname;
         /* FALLTHROUGH */
d1173 2
@


1.1.1.6
log
@Import Mesa 10.4.3
@
text
@d1387 1
a1387 1
   _mesa_lock_context_textures(ctx);
d1594 1
a1594 1
   _mesa_unlock_context_textures(ctx);
d1598 1
a1598 1
   _mesa_unlock_context_textures(ctx);
@


1.1.1.7
log
@Import Mesa 10.2.9
@
text
@d1387 1
a1387 1
   _mesa_lock_texture(ctx, obj);
d1594 1
a1594 1
   _mesa_unlock_texture(ctx, obj);
d1598 1
a1598 1
   _mesa_unlock_texture(ctx, obj);
@


