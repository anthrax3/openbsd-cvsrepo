head	1.6;
access;
symbols
	OPENBSD_5_8:1.5.0.4
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5
	v10_2_9:1.1.1.4
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.2
	OPENBSD_5_6:1.3.0.2
	OPENBSD_5_6_BASE:1.3
	v10_2_3:1.1.1.2
	OPENBSD_5_5:1.2.0.2
	OPENBSD_5_5_BASE:1.2
	v9_2_5:1.1.1.1
	v9_2_3:1.1.1.1
	v9_2_2:1.1.1.1
	v9_2_1:1.1.1.1
	v9_2_0:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_4:1.1.0.4
	OPENBSD_5_4_BASE:1.1
	OPENBSD_5_3:1.1.0.2
	OPENBSD_5_3_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.12.23.05.17.53;	author jsg;	state dead;
branches;
next	1.5;
commitid	TnlogFl9nOv2eaRf;

1.5
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.4;
commitid	4ry2gvZGMXkCUD2n;

1.4
date	2015.01.25.14.41.22;	author jsg;	state Exp;
branches;
next	1.3;
commitid	mcxB0JvoI9gTDYXU;

1.3
date	2014.07.09.21.09.00;	author jsg;	state Exp;
branches;
next	1.2;
commitid	WPD6rgPryPkvXOr9;

1.2
date	2013.09.05.14.06.29;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2012.08.17.13.58.19;	author mpi;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.09.05.13.16.51;	author jsg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.07.09.20.35.05;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.3
date	2015.01.25.14.12.56;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.4
date	2015.02.20.22.50.02;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.6
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright (C) 2011 Red Hat Inc.
 * 
 * block compression parts are:
 * Copyright (C) 2004  Roland Scheidegger   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Author:
 *    Dave Airlie
 */

/**
 * \file texcompress_rgtc.c
 * GL_EXT_texture_compression_rgtc support.
 */


#include "glheader.h"
#include "imports.h"
#include "colormac.h"
#include "image.h"
#include "macros.h"
#include "mipmap.h"
#include "texcompress.h"
#include "texcompress_rgtc.h"
#include "texstore.h"


#define RGTC_DEBUG 0

static void unsigned_encode_rgtc_ubyte(GLubyte *blkaddr, GLubyte srccolors[4][4],
					GLint numxpixels, GLint numypixels);
static void signed_encode_rgtc_ubyte(GLbyte *blkaddr, GLbyte srccolors[4][4],
			     GLint numxpixels, GLint numypixels);

static void unsigned_fetch_texel_rgtc(unsigned srcRowStride, const GLubyte *pixdata,
				      unsigned i, unsigned j, GLubyte *value, unsigned comps);

static void signed_fetch_texel_rgtc(unsigned srcRowStride, const GLbyte *pixdata,
				      unsigned i, unsigned j, GLbyte *value, unsigned comps);

static void extractsrc_u( GLubyte srcpixels[4][4], const GLubyte *srcaddr,
			  GLint srcRowStride, GLint numxpixels, GLint numypixels, GLint comps)
{
   GLubyte i, j;
   const GLubyte *curaddr;
   for (j = 0; j < numypixels; j++) {
      curaddr = srcaddr + j * srcRowStride * comps;
      for (i = 0; i < numxpixels; i++) {
	 srcpixels[j][i] = *curaddr;
	 curaddr += comps;
      }
   }
}

static void extractsrc_s( GLbyte srcpixels[4][4], const GLfloat *srcaddr,
			  GLint srcRowStride, GLint numxpixels, GLint numypixels, GLint comps)
{
   GLubyte i, j;
   const GLfloat *curaddr;
   for (j = 0; j < numypixels; j++) {
      curaddr = srcaddr + j * srcRowStride * comps;
      for (i = 0; i < numxpixels; i++) {
	 srcpixels[j][i] = FLOAT_TO_BYTE_TEX(*curaddr);
	 curaddr += comps;
      }
   }
}


GLboolean
_mesa_texstore_red_rgtc1(TEXSTORE_PARAMS)
{
   GLubyte *dst;
   const GLubyte *tempImage = NULL;
   int i, j;
   int numxpixels, numypixels;
   const GLubyte *srcaddr;
   GLubyte srcpixels[4][4];
   GLubyte *blkaddr;
   GLint dstRowDiff;
   ASSERT(dstFormat == MESA_FORMAT_R_RGTC1_UNORM ||
          dstFormat == MESA_FORMAT_L_LATC1_UNORM);

   tempImage = _mesa_make_temp_ubyte_image(ctx, dims,
					  baseInternalFormat,
					  _mesa_get_format_base_format(dstFormat),
					  srcWidth, srcHeight, srcDepth,
					  srcFormat, srcType, srcAddr,
					  srcPacking);
   if (!tempImage)
      return GL_FALSE; /* out of memory */

   dst = dstSlices[0];

   blkaddr = dst;
   dstRowDiff = dstRowStride >= (srcWidth * 2) ? dstRowStride - (((srcWidth + 3) & ~3) * 2) : 0;
   for (j = 0; j < srcHeight; j+=4) {
      if (srcHeight > j + 3) numypixels = 4;
      else numypixels = srcHeight - j;
      srcaddr = tempImage + j * srcWidth;
      for (i = 0; i < srcWidth; i += 4) {
	 if (srcWidth > i + 3) numxpixels = 4;
	 else numxpixels = srcWidth - i;
	 extractsrc_u(srcpixels, srcaddr, srcWidth, numxpixels, numypixels, 1);
	 unsigned_encode_rgtc_ubyte(blkaddr, srcpixels, numxpixels, numypixels);
	 srcaddr += numxpixels;
	 blkaddr += 8;
      }
      blkaddr += dstRowDiff;
   }

   free((void *) tempImage);

   return GL_TRUE;
}

GLboolean
_mesa_texstore_signed_red_rgtc1(TEXSTORE_PARAMS)
{
   GLbyte *dst;
   const GLfloat *tempImage = NULL;
   int i, j;
   int numxpixels, numypixels;
   const GLfloat *srcaddr;
   GLbyte srcpixels[4][4];
   GLbyte *blkaddr;
   GLint dstRowDiff;
   ASSERT(dstFormat == MESA_FORMAT_R_RGTC1_SNORM ||
          dstFormat == MESA_FORMAT_L_LATC1_SNORM);

   tempImage = _mesa_make_temp_float_image(ctx, dims,
					   baseInternalFormat,
					   _mesa_get_format_base_format(dstFormat),
					   srcWidth, srcHeight, srcDepth,
					   srcFormat, srcType, srcAddr,
					   srcPacking, 0x0);
   if (!tempImage)
      return GL_FALSE; /* out of memory */

   dst = (GLbyte *) dstSlices[0];

   blkaddr = dst;
   dstRowDiff = dstRowStride >= (srcWidth * 2) ? dstRowStride - (((srcWidth + 3) & ~3) * 2) : 0;
   for (j = 0; j < srcHeight; j+=4) {
      if (srcHeight > j + 3) numypixels = 4;
      else numypixels = srcHeight - j;
      srcaddr = tempImage + j * srcWidth;
      for (i = 0; i < srcWidth; i += 4) {
	 if (srcWidth > i + 3) numxpixels = 4;
	 else numxpixels = srcWidth - i;
	 extractsrc_s(srcpixels, srcaddr, srcWidth, numxpixels, numypixels, 1);
	 signed_encode_rgtc_ubyte(blkaddr, srcpixels, numxpixels, numypixels);
	 srcaddr += numxpixels;
	 blkaddr += 8;
      }
      blkaddr += dstRowDiff;
   }

   free((void *) tempImage);

   return GL_TRUE;
}

GLboolean
_mesa_texstore_rg_rgtc2(TEXSTORE_PARAMS)
{
   GLubyte *dst;
   const GLubyte *tempImage = NULL;
   int i, j;
   int numxpixels, numypixels;
   const GLubyte *srcaddr;
   GLubyte srcpixels[4][4];
   GLubyte *blkaddr;
   GLint dstRowDiff;

   ASSERT(dstFormat == MESA_FORMAT_RG_RGTC2_UNORM ||
          dstFormat == MESA_FORMAT_LA_LATC2_UNORM);

   tempImage = _mesa_make_temp_ubyte_image(ctx, dims,
					  baseInternalFormat,
					  _mesa_get_format_base_format(dstFormat),
					  srcWidth, srcHeight, srcDepth,
					  srcFormat, srcType, srcAddr,
					  srcPacking);
   if (!tempImage)
      return GL_FALSE; /* out of memory */

   dst = dstSlices[0];

   blkaddr = dst;
   dstRowDiff = dstRowStride >= (srcWidth * 4) ? dstRowStride - (((srcWidth + 3) & ~3) * 4) : 0;
   for (j = 0; j < srcHeight; j+=4) {
      if (srcHeight > j + 3) numypixels = 4;
      else numypixels = srcHeight - j;
      srcaddr = tempImage + j * srcWidth * 2;
      for (i = 0; i < srcWidth; i += 4) {
	 if (srcWidth > i + 3) numxpixels = 4;
	 else numxpixels = srcWidth - i;
	 extractsrc_u(srcpixels, srcaddr, srcWidth, numxpixels, numypixels, 2);
	 unsigned_encode_rgtc_ubyte(blkaddr, srcpixels, numxpixels, numypixels);

	 blkaddr += 8;
	 extractsrc_u(srcpixels, (GLubyte *)srcaddr + 1, srcWidth, numxpixels, numypixels, 2);
	 unsigned_encode_rgtc_ubyte(blkaddr, srcpixels, numxpixels, numypixels);

	 blkaddr += 8;

	 srcaddr += numxpixels * 2;
      }
      blkaddr += dstRowDiff;
   }

   free((void *) tempImage);

   return GL_TRUE;
}

GLboolean
_mesa_texstore_signed_rg_rgtc2(TEXSTORE_PARAMS)
{
   GLbyte *dst;
   const GLfloat *tempImage = NULL;
   int i, j;
   int numxpixels, numypixels;
   const GLfloat *srcaddr;
   GLbyte srcpixels[4][4];
   GLbyte *blkaddr;
   GLint dstRowDiff;

   ASSERT(dstFormat == MESA_FORMAT_RG_RGTC2_SNORM ||
          dstFormat == MESA_FORMAT_LA_LATC2_SNORM);

   tempImage = _mesa_make_temp_float_image(ctx, dims,
					   baseInternalFormat,
					   _mesa_get_format_base_format(dstFormat),
					   srcWidth, srcHeight, srcDepth,
					   srcFormat, srcType, srcAddr,
					   srcPacking, 0x0);
   if (!tempImage)
      return GL_FALSE; /* out of memory */

   dst = (GLbyte *) dstSlices[0];

   blkaddr = dst;
   dstRowDiff = dstRowStride >= (srcWidth * 4) ? dstRowStride - (((srcWidth + 3) & ~3) * 4) : 0;
   for (j = 0; j < srcHeight; j += 4) {
      if (srcHeight > j + 3) numypixels = 4;
      else numypixels = srcHeight - j;
      srcaddr = tempImage + j * srcWidth * 2;
      for (i = 0; i < srcWidth; i += 4) {
	 if (srcWidth > i + 3) numxpixels = 4;
	 else numxpixels = srcWidth - i;

	 extractsrc_s(srcpixels, srcaddr, srcWidth, numxpixels, numypixels, 2);
	 signed_encode_rgtc_ubyte(blkaddr, srcpixels, numxpixels, numypixels);
	 blkaddr += 8;

	 extractsrc_s(srcpixels, srcaddr + 1, srcWidth, numxpixels, numypixels, 2);
	 signed_encode_rgtc_ubyte(blkaddr, srcpixels, numxpixels, numypixels);
	 blkaddr += 8;

	 srcaddr += numxpixels * 2;

      }
      blkaddr += dstRowDiff;
   }

   free((void *) tempImage);

   return GL_TRUE;
}


#define TAG(x) unsigned_##x

#define TYPE GLubyte
#define T_MIN 0
#define T_MAX 0xff

#include "texcompress_rgtc_tmp.h"

#undef TAG
#undef TYPE
#undef T_MIN
#undef T_MAX

#define TAG(x) signed_##x
#define TYPE GLbyte
#define T_MIN (GLbyte)-128
#define T_MAX (GLbyte)127

#include "texcompress_rgtc_tmp.h"

#undef TAG
#undef TYPE
#undef T_MIN
#undef T_MAX



static void
fetch_red_rgtc1(const GLubyte *map,
                GLint rowStride, GLint i, GLint j, GLfloat *texel)
{
   GLubyte red;
   unsigned_fetch_texel_rgtc(rowStride, map, i, j, &red, 1);
   texel[RCOMP] = UBYTE_TO_FLOAT(red);
   texel[GCOMP] = 0.0;
   texel[BCOMP] = 0.0;
   texel[ACOMP] = 1.0;
}

static void
fetch_l_latc1(const GLubyte *map,
              GLint rowStride, GLint i, GLint j, GLfloat *texel)
{
   GLubyte red;
   unsigned_fetch_texel_rgtc(rowStride, map, i, j, &red, 1);
   texel[RCOMP] =
   texel[GCOMP] =
   texel[BCOMP] = UBYTE_TO_FLOAT(red);
   texel[ACOMP] = 1.0;
}

static void
fetch_signed_red_rgtc1(const GLubyte *map,
                       GLint rowStride, GLint i, GLint j, GLfloat *texel)
{
   GLbyte red;
   signed_fetch_texel_rgtc(rowStride, (const GLbyte *) map,
                           i, j, &red, 1);
   texel[RCOMP] = BYTE_TO_FLOAT_TEX(red);
   texel[GCOMP] = 0.0;
   texel[BCOMP] = 0.0;
   texel[ACOMP] = 1.0;
}

static void
fetch_signed_l_latc1(const GLubyte *map,
                     GLint rowStride, GLint i, GLint j, GLfloat *texel)
{
   GLbyte red;
   signed_fetch_texel_rgtc(rowStride, (GLbyte *) map,
                           i, j, &red, 1);
   texel[RCOMP] =
   texel[GCOMP] =
   texel[BCOMP] = BYTE_TO_FLOAT(red);
   texel[ACOMP] = 1.0;
}

static void
fetch_rg_rgtc2(const GLubyte *map,
               GLint rowStride, GLint i, GLint j, GLfloat *texel)
{
   GLubyte red, green;
   unsigned_fetch_texel_rgtc(rowStride,
                             map,
                             i, j, &red, 2);
   unsigned_fetch_texel_rgtc(rowStride,
                             map + 8,
                             i, j, &green, 2);
   texel[RCOMP] = UBYTE_TO_FLOAT(red);
   texel[GCOMP] = UBYTE_TO_FLOAT(green);
   texel[BCOMP] = 0.0;
   texel[ACOMP] = 1.0;
}

static void
fetch_la_latc2(const GLubyte *map,
               GLint rowStride, GLint i, GLint j, GLfloat *texel)
{
   GLubyte red, green;
   unsigned_fetch_texel_rgtc(rowStride,
                             map,
                             i, j, &red, 2);
   unsigned_fetch_texel_rgtc(rowStride,
                             map + 8,
                             i, j, &green, 2);
   texel[RCOMP] =
   texel[GCOMP] =
   texel[BCOMP] = UBYTE_TO_FLOAT(red);
   texel[ACOMP] = UBYTE_TO_FLOAT(green);
}


static void
fetch_signed_rg_rgtc2(const GLubyte *map,
                      GLint rowStride, GLint i, GLint j, GLfloat *texel)
{
   GLbyte red, green;
   signed_fetch_texel_rgtc(rowStride,
                           (GLbyte *) map,
                           i, j, &red, 2);
   signed_fetch_texel_rgtc(rowStride,
                           (GLbyte *) map + 8,
                           i, j, &green, 2);
   texel[RCOMP] = BYTE_TO_FLOAT_TEX(red);
   texel[GCOMP] = BYTE_TO_FLOAT_TEX(green);
   texel[BCOMP] = 0.0;
   texel[ACOMP] = 1.0;
}


static void
fetch_signed_la_latc2(const GLubyte *map,
                      GLint rowStride, GLint i, GLint j, GLfloat *texel)
{
   GLbyte red, green;
   signed_fetch_texel_rgtc(rowStride,
                           (GLbyte *) map,
                           i, j, &red, 2);
   signed_fetch_texel_rgtc(rowStride,
                           (GLbyte *) map + 8,
                           i, j, &green, 2);
   texel[RCOMP] =
   texel[GCOMP] =
   texel[BCOMP] = BYTE_TO_FLOAT_TEX(red);
   texel[ACOMP] = BYTE_TO_FLOAT_TEX(green);
}


compressed_fetch_func
_mesa_get_compressed_rgtc_func(mesa_format format)
{
   switch (format) {
   case MESA_FORMAT_R_RGTC1_UNORM:
      return fetch_red_rgtc1;
   case MESA_FORMAT_L_LATC1_UNORM:
      return fetch_l_latc1;
   case MESA_FORMAT_R_RGTC1_SNORM:
      return fetch_signed_red_rgtc1;
   case MESA_FORMAT_L_LATC1_SNORM:
      return fetch_signed_l_latc1;
   case MESA_FORMAT_RG_RGTC2_UNORM:
      return fetch_rg_rgtc2;
   case MESA_FORMAT_LA_LATC2_UNORM:
      return fetch_la_latc2;
   case MESA_FORMAT_RG_RGTC2_SNORM:
      return fetch_signed_rg_rgtc2;
   case MESA_FORMAT_LA_LATC2_SNORM:
      return fetch_signed_la_latc2;
   default:
      return NULL;
   }
}
@


1.5
log
@Merge Mesa 10.2.9
@
text
@@


1.4
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a42 1
#include "util/rgtc.h"
d46 14
d124 1
a124 1
	 util_format_unsigned_encode_rgtc_ubyte(blkaddr, srcpixels, numxpixels, numypixels);
d171 1
a171 1
	 util_format_signed_encode_rgtc_ubyte(blkaddr, srcpixels, numxpixels, numypixels);
d219 1
a219 1
	 util_format_unsigned_encode_rgtc_ubyte(blkaddr, srcpixels, numxpixels, numypixels);
d223 1
a223 1
	 util_format_unsigned_encode_rgtc_ubyte(blkaddr, srcpixels, numxpixels, numypixels);
d274 1
a274 1
	 util_format_signed_encode_rgtc_ubyte(blkaddr, srcpixels, numxpixels, numypixels);
d278 1
a278 1
	 util_format_signed_encode_rgtc_ubyte(blkaddr, srcpixels, numxpixels, numypixels);
d292 28
d325 1
a325 1
   util_format_unsigned_fetch_texel_rgtc(rowStride, map, i, j, &red, 1);
d337 1
a337 1
   util_format_unsigned_fetch_texel_rgtc(rowStride, map, i, j, &red, 1);
d349 1
a349 1
   util_format_signed_fetch_texel_rgtc(rowStride, (const GLbyte *) map,
d362 1
a362 1
   util_format_signed_fetch_texel_rgtc(rowStride, (GLbyte *) map,
d375 1
a375 1
   util_format_unsigned_fetch_texel_rgtc(rowStride,
d378 1
a378 1
   util_format_unsigned_fetch_texel_rgtc(rowStride,
d392 1
a392 1
   util_format_unsigned_fetch_texel_rgtc(rowStride,
d395 1
a395 1
   util_format_unsigned_fetch_texel_rgtc(rowStride,
d410 1
a410 1
   util_format_signed_fetch_texel_rgtc(rowStride,
d413 1
a413 1
   util_format_signed_fetch_texel_rgtc(rowStride,
d428 1
a428 1
   util_format_signed_fetch_texel_rgtc(rowStride,
d431 1
a431 1
   util_format_signed_fetch_texel_rgtc(rowStride,
@


1.3
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d43 1
a46 14

#define RGTC_DEBUG 0

static void unsigned_encode_rgtc_ubyte(GLubyte *blkaddr, GLubyte srccolors[4][4],
					GLint numxpixels, GLint numypixels);
static void signed_encode_rgtc_ubyte(GLbyte *blkaddr, GLbyte srccolors[4][4],
			     GLint numxpixels, GLint numypixels);

static void unsigned_fetch_texel_rgtc(unsigned srcRowStride, const GLubyte *pixdata,
				      unsigned i, unsigned j, GLubyte *value, unsigned comps);

static void signed_fetch_texel_rgtc(unsigned srcRowStride, const GLbyte *pixdata,
				      unsigned i, unsigned j, GLbyte *value, unsigned comps);

d111 1
a111 1
	 unsigned_encode_rgtc_ubyte(blkaddr, srcpixels, numxpixels, numypixels);
d158 1
a158 1
	 signed_encode_rgtc_ubyte(blkaddr, srcpixels, numxpixels, numypixels);
d206 1
a206 1
	 unsigned_encode_rgtc_ubyte(blkaddr, srcpixels, numxpixels, numypixels);
d210 1
a210 1
	 unsigned_encode_rgtc_ubyte(blkaddr, srcpixels, numxpixels, numypixels);
d261 1
a261 1
	 signed_encode_rgtc_ubyte(blkaddr, srcpixels, numxpixels, numypixels);
d265 1
a265 1
	 signed_encode_rgtc_ubyte(blkaddr, srcpixels, numxpixels, numypixels);
a278 28

#define TAG(x) unsigned_##x

#define TYPE GLubyte
#define T_MIN 0
#define T_MAX 0xff

#include "texcompress_rgtc_tmp.h"

#undef TAG
#undef TYPE
#undef T_MIN
#undef T_MAX

#define TAG(x) signed_##x
#define TYPE GLbyte
#define T_MIN (GLbyte)-128
#define T_MAX (GLbyte)127

#include "texcompress_rgtc_tmp.h"

#undef TAG
#undef TYPE
#undef T_MIN
#undef T_MAX



d284 1
a284 1
   unsigned_fetch_texel_rgtc(rowStride, map, i, j, &red, 1);
d296 1
a296 1
   unsigned_fetch_texel_rgtc(rowStride, map, i, j, &red, 1);
d308 1
a308 1
   signed_fetch_texel_rgtc(rowStride, (const GLbyte *) map,
d321 1
a321 1
   signed_fetch_texel_rgtc(rowStride, (GLbyte *) map,
d334 1
a334 1
   unsigned_fetch_texel_rgtc(rowStride,
d337 1
a337 1
   unsigned_fetch_texel_rgtc(rowStride,
d351 1
a351 1
   unsigned_fetch_texel_rgtc(rowStride,
d354 1
a354 1
   unsigned_fetch_texel_rgtc(rowStride,
d369 1
a369 1
   signed_fetch_texel_rgtc(rowStride,
d372 1
a372 1
   signed_fetch_texel_rgtc(rowStride,
d387 1
a387 1
   signed_fetch_texel_rgtc(rowStride,
d390 1
a390 1
   signed_fetch_texel_rgtc(rowStride,
@


1.2
log
@Merge Mesa 9.2.0
@
text
@d100 2
a101 2
   ASSERT(dstFormat == MESA_FORMAT_RED_RGTC1 ||
          dstFormat == MESA_FORMAT_L_LATC1);
d147 2
a148 2
   ASSERT(dstFormat == MESA_FORMAT_SIGNED_RED_RGTC1 ||
          dstFormat == MESA_FORMAT_SIGNED_L_LATC1);
d195 2
a196 2
   ASSERT(dstFormat == MESA_FORMAT_RG_RGTC2 ||
          dstFormat == MESA_FORMAT_LA_LATC2);
d249 2
a250 2
   ASSERT(dstFormat == MESA_FORMAT_SIGNED_RG_RGTC2 ||
          dstFormat == MESA_FORMAT_SIGNED_LA_LATC2);
d442 1
a442 1
_mesa_get_compressed_rgtc_func(gl_format format)
d445 1
a445 1
   case MESA_FORMAT_RED_RGTC1:
d447 1
a447 1
   case MESA_FORMAT_L_LATC1:
d449 1
a449 1
   case MESA_FORMAT_SIGNED_RED_RGTC1:
d451 1
a451 1
   case MESA_FORMAT_SIGNED_L_LATC1:
d453 1
a453 1
   case MESA_FORMAT_RG_RGTC2:
d455 1
a455 1
   case MESA_FORMAT_LA_LATC2:
d457 1
a457 1
   case MESA_FORMAT_SIGNED_RG_RGTC2:
d459 1
a459 1
   case MESA_FORMAT_SIGNED_LA_LATC2:
@


1.1
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a40 1
#include "mfeatures.h"
d46 1
d49 1
a49 1
static void unsigned_encode_rgtc_chan(GLubyte *blkaddr, GLubyte srccolors[4][4],
d51 1
a51 1
static void signed_encode_rgtc_chan(GLbyte *blkaddr, GLbyte srccolors[4][4],
d60 1
a60 1
static void extractsrc_u( GLubyte srcpixels[4][4], const GLchan *srcaddr,
d64 1
a64 1
   const GLchan *curaddr;
d68 1
a68 1
	 srcpixels[j][i] = *curaddr / (CHAN_MAX / 255);
d93 1
a93 2
   const GLint texWidth = dstRowStride * 4 / 8; /* a bit of a hack */
   const GLchan *tempImage = NULL;
d96 1
a96 1
   const GLchan *srcaddr;
a101 6
   ASSERT(dstXoffset % 4 == 0);
   ASSERT(dstYoffset % 4 == 0);
   ASSERT(dstZoffset % 4 == 0);
   (void) dstZoffset;
   (void) dstImageOffsets;

d103 1
a103 1
   tempImage = _mesa_make_temp_chan_image(ctx, dims,
d112 1
a112 3
   dst = _mesa_compressed_image_address(dstXoffset, dstYoffset, 0,
                                        dstFormat,
                                        texWidth, (GLubyte *) dstAddr);
d124 1
a124 1
	 unsigned_encode_rgtc_chan(blkaddr, srcpixels, numxpixels, numypixels);
d130 2
a131 2
   if (tempImage)
      free((void *) tempImage);
a139 1
   const GLint texWidth = dstRowStride * 4 / 8; /* a bit of a hack */
a148 5
   ASSERT(dstXoffset % 4 == 0);
   ASSERT(dstYoffset % 4 == 0);
   ASSERT(dstZoffset % 4 == 0);
   (void) dstZoffset;
   (void) dstImageOffsets;
d159 1
a159 3
   dst = (GLbyte *)_mesa_compressed_image_address(dstXoffset, dstYoffset, 0,
						  dstFormat,
						  texWidth, (GLubyte *) dstAddr);
d171 1
a171 1
	 signed_encode_rgtc_chan(blkaddr, srcpixels, numxpixels, numypixels);
d177 2
a178 2
   if (tempImage)
      free((void *) tempImage);
d187 1
a187 2
   const GLint texWidth = dstRowStride * 4 / 16; /* a bit of a hack */
   const GLchan *tempImage = NULL;
d190 1
a190 1
   const GLchan *srcaddr;
a196 5
   ASSERT(dstXoffset % 4 == 0);
   ASSERT(dstYoffset % 4 == 0);
   ASSERT(dstZoffset % 4 == 0);
   (void) dstZoffset;
   (void) dstImageOffsets;
d198 1
a198 1
   tempImage = _mesa_make_temp_chan_image(ctx, dims,
d207 1
a207 3
   dst = _mesa_compressed_image_address(dstXoffset, dstYoffset, 0,
                                        dstFormat,
                                        texWidth, (GLubyte *) dstAddr);
d219 1
a219 1
	 unsigned_encode_rgtc_chan(blkaddr, srcpixels, numxpixels, numypixels);
d222 2
a223 2
	 extractsrc_u(srcpixels, (GLchan *)srcaddr + 1, srcWidth, numxpixels, numypixels, 2);
	 unsigned_encode_rgtc_chan(blkaddr, srcpixels, numxpixels, numypixels);
d231 2
a232 2
   if (tempImage)
      free((void *) tempImage);
a240 1
   const GLint texWidth = dstRowStride * 4 / 16; /* a bit of a hack */
a250 5
   ASSERT(dstXoffset % 4 == 0);
   ASSERT(dstYoffset % 4 == 0);
   ASSERT(dstZoffset % 4 == 0);
   (void) dstZoffset;
   (void) dstImageOffsets;
d261 1
a261 3
   dst = (GLbyte *)_mesa_compressed_image_address(dstXoffset, dstYoffset, 0,
						  dstFormat,
						  texWidth, (GLubyte *) dstAddr);
d274 1
a274 1
	 signed_encode_rgtc_chan(blkaddr, srcpixels, numxpixels, numypixels);
d278 1
a278 1
	 signed_encode_rgtc_chan(blkaddr, srcpixels, numxpixels, numypixels);
d286 2
a287 2
   if (tempImage)
      free((void *) tempImage);
d292 31
a322 3
void
_mesa_fetch_texel_2d_f_red_rgtc1(const struct gl_texture_image *texImage,
				 GLint i, GLint j, GLint k, GLfloat *texel)
d325 1
a325 2
   unsigned_fetch_texel_rgtc(texImage->RowStride, (GLubyte *)(texImage->Data),
		       i, j, &red, 1);
d332 15
a346 3
void
_mesa_fetch_texel_2d_f_signed_red_rgtc1(const struct gl_texture_image *texImage,
					GLint i, GLint j, GLint k, GLfloat *texel)
d349 2
a350 2
   signed_fetch_texel_rgtc(texImage->RowStride, (GLbyte *)(texImage->Data),
		       i, j, &red, 1);
d357 3
a359 3
void
_mesa_fetch_texel_2d_f_rg_rgtc2(const struct gl_texture_image *texImage,
				 GLint i, GLint j, GLint k, GLfloat *texel)
d361 6
a366 8
   GLubyte red, green;
   unsigned_fetch_texel_rgtc(texImage->RowStride, (GLubyte *)(texImage->Data),
		     i, j, &red, 2);
   unsigned_fetch_texel_rgtc(texImage->RowStride, (GLubyte *)(texImage->Data) + 8,
		     i, j, &green, 2);
   texel[RCOMP] = UBYTE_TO_FLOAT(red);
   texel[GCOMP] = UBYTE_TO_FLOAT(green);
   texel[BCOMP] = 0.0;
d370 3
a372 3
void
_mesa_fetch_texel_2d_f_signed_rg_rgtc2(const struct gl_texture_image *texImage,
				       GLint i, GLint j, GLint k, GLfloat *texel)
d374 9
a382 7
   GLbyte red, green;
   signed_fetch_texel_rgtc(texImage->RowStride, (GLbyte *)(texImage->Data),
		     i, j, &red, 2);
   signed_fetch_texel_rgtc(texImage->RowStride, (GLbyte *)(texImage->Data) + 8,
		     i, j, &green, 2);
   texel[RCOMP] = BYTE_TO_FLOAT_TEX(red);
   texel[GCOMP] = BYTE_TO_FLOAT_TEX(green);
d387 3
a389 3
void
_mesa_fetch_texel_2d_f_l_latc1(const struct gl_texture_image *texImage,
                                 GLint i, GLint j, GLint k, GLfloat *texel)
d391 7
a397 3
   GLubyte red;
   unsigned_fetch_texel_rgtc(texImage->RowStride, (GLubyte *)(texImage->Data),
                       i, j, &red, 1);
d401 1
a401 1
   texel[ACOMP] = 1.0;
d404 4
a407 3
void
_mesa_fetch_texel_2d_f_signed_l_latc1(const struct gl_texture_image *texImage,
                                        GLint i, GLint j, GLint k, GLfloat *texel)
d409 10
a418 6
   GLbyte red;
   signed_fetch_texel_rgtc(texImage->RowStride, (GLbyte *)(texImage->Data),
                       i, j, &red, 1);
   texel[RCOMP] =
   texel[GCOMP] =
   texel[BCOMP] = BYTE_TO_FLOAT_TEX(red);
a421 14
void
_mesa_fetch_texel_2d_f_la_latc2(const struct gl_texture_image *texImage,
                                 GLint i, GLint j, GLint k, GLfloat *texel)
{
   GLubyte red, green;
   unsigned_fetch_texel_rgtc(texImage->RowStride, (GLubyte *)(texImage->Data),
                     i, j, &red, 2);
   unsigned_fetch_texel_rgtc(texImage->RowStride, (GLubyte *)(texImage->Data) + 8,
                     i, j, &green, 2);
   texel[RCOMP] =
   texel[GCOMP] =
   texel[BCOMP] = UBYTE_TO_FLOAT(red);
   texel[ACOMP] = UBYTE_TO_FLOAT(green);
}
d423 3
a425 3
void
_mesa_fetch_texel_2d_f_signed_la_latc2(const struct gl_texture_image *texImage,
                                       GLint i, GLint j, GLint k, GLfloat *texel)
d428 6
a433 4
   signed_fetch_texel_rgtc(texImage->RowStride, (GLbyte *)(texImage->Data),
                     i, j, &red, 2);
   signed_fetch_texel_rgtc(texImage->RowStride, (GLbyte *)(texImage->Data) + 8,
                     i, j, &green, 2);
a439 5
#define TAG(x) unsigned_##x

#define TYPE GLubyte
#define T_MIN 0
#define T_MAX 0xff
d441 24
a464 18
#include "texcompress_rgtc_tmp.h"

#undef TAG
#undef TYPE
#undef T_MIN
#undef T_MAX

#define TAG(x) signed_##x
#define TYPE GLbyte
#define T_MIN (GLbyte)-128
#define T_MAX (GLbyte)127

#include "texcompress_rgtc_tmp.h"

#undef TAG
#undef TYPE
#undef T_MIN
#undef T_MAX
@


1.1.1.1
log
@Import Mesa 9.2.0
@
text
@d41 1
a46 1

d49 1
a49 1
static void unsigned_encode_rgtc_ubyte(GLubyte *blkaddr, GLubyte srccolors[4][4],
d51 1
a51 1
static void signed_encode_rgtc_ubyte(GLbyte *blkaddr, GLbyte srccolors[4][4],
d60 1
a60 1
static void extractsrc_u( GLubyte srcpixels[4][4], const GLubyte *srcaddr,
d64 1
a64 1
   const GLubyte *curaddr;
d68 1
a68 1
	 srcpixels[j][i] = *curaddr;
d93 2
a94 1
   const GLubyte *tempImage = NULL;
d97 1
a97 1
   const GLubyte *srcaddr;
d103 6
d110 1
a110 1
   tempImage = _mesa_make_temp_ubyte_image(ctx, dims,
d119 3
a121 1
   dst = dstSlices[0];
d133 1
a133 1
	 unsigned_encode_rgtc_ubyte(blkaddr, srcpixels, numxpixels, numypixels);
d139 2
a140 2

   free((void *) tempImage);
d149 1
d159 5
d174 3
a176 1
   dst = (GLbyte *) dstSlices[0];
d188 1
a188 1
	 signed_encode_rgtc_ubyte(blkaddr, srcpixels, numxpixels, numypixels);
d194 2
a195 2

   free((void *) tempImage);
d204 2
a205 1
   const GLubyte *tempImage = NULL;
d208 1
a208 1
   const GLubyte *srcaddr;
d215 5
d221 1
a221 1
   tempImage = _mesa_make_temp_ubyte_image(ctx, dims,
d230 3
a232 1
   dst = dstSlices[0];
d244 1
a244 1
	 unsigned_encode_rgtc_ubyte(blkaddr, srcpixels, numxpixels, numypixels);
d247 2
a248 2
	 extractsrc_u(srcpixels, (GLubyte *)srcaddr + 1, srcWidth, numxpixels, numypixels, 2);
	 unsigned_encode_rgtc_ubyte(blkaddr, srcpixels, numxpixels, numypixels);
d256 2
a257 2

   free((void *) tempImage);
d266 1
d277 5
d292 3
a294 1
   dst = (GLbyte *) dstSlices[0];
d307 1
a307 1
	 signed_encode_rgtc_ubyte(blkaddr, srcpixels, numxpixels, numypixels);
d311 1
a311 1
	 signed_encode_rgtc_ubyte(blkaddr, srcpixels, numxpixels, numypixels);
d319 2
a320 2

   free((void *) tempImage);
d325 3
a327 31

#define TAG(x) unsigned_##x

#define TYPE GLubyte
#define T_MIN 0
#define T_MAX 0xff

#include "texcompress_rgtc_tmp.h"

#undef TAG
#undef TYPE
#undef T_MIN
#undef T_MAX

#define TAG(x) signed_##x
#define TYPE GLbyte
#define T_MIN (GLbyte)-128
#define T_MAX (GLbyte)127

#include "texcompress_rgtc_tmp.h"

#undef TAG
#undef TYPE
#undef T_MIN
#undef T_MAX



static void
fetch_red_rgtc1(const GLubyte *map,
                GLint rowStride, GLint i, GLint j, GLfloat *texel)
d330 2
a331 1
   unsigned_fetch_texel_rgtc(rowStride, map, i, j, &red, 1);
d338 3
a340 3
static void
fetch_l_latc1(const GLubyte *map,
              GLint rowStride, GLint i, GLint j, GLfloat *texel)
d342 21
a362 5
   GLubyte red;
   unsigned_fetch_texel_rgtc(rowStride, map, i, j, &red, 1);
   texel[RCOMP] =
   texel[GCOMP] =
   texel[BCOMP] = UBYTE_TO_FLOAT(red);
d366 3
a368 3
static void
fetch_signed_red_rgtc1(const GLubyte *map,
                       GLint rowStride, GLint i, GLint j, GLfloat *texel)
d370 5
a374 3
   GLbyte red;
   signed_fetch_texel_rgtc(rowStride, (const GLbyte *) map,
                           i, j, &red, 1);
d376 1
a376 1
   texel[GCOMP] = 0.0;
d381 3
a383 3
static void
fetch_signed_l_latc1(const GLubyte *map,
                     GLint rowStride, GLint i, GLint j, GLfloat *texel)
d385 3
a387 3
   GLbyte red;
   signed_fetch_texel_rgtc(rowStride, (GLbyte *) map,
                           i, j, &red, 1);
d390 1
a390 1
   texel[BCOMP] = BYTE_TO_FLOAT(red);
d394 3
a396 3
static void
fetch_rg_rgtc2(const GLubyte *map,
               GLint rowStride, GLint i, GLint j, GLfloat *texel)
d398 6
a403 10
   GLubyte red, green;
   unsigned_fetch_texel_rgtc(rowStride,
                             map,
                             i, j, &red, 2);
   unsigned_fetch_texel_rgtc(rowStride,
                             map + 8,
                             i, j, &green, 2);
   texel[RCOMP] = UBYTE_TO_FLOAT(red);
   texel[GCOMP] = UBYTE_TO_FLOAT(green);
   texel[BCOMP] = 0.0;
d407 3
a409 3
static void
fetch_la_latc2(const GLubyte *map,
               GLint rowStride, GLint i, GLint j, GLfloat *texel)
d412 4
a415 6
   unsigned_fetch_texel_rgtc(rowStride,
                             map,
                             i, j, &red, 2);
   unsigned_fetch_texel_rgtc(rowStride,
                             map + 8,
                             i, j, &green, 2);
d422 3
a424 22

static void
fetch_signed_rg_rgtc2(const GLubyte *map,
                      GLint rowStride, GLint i, GLint j, GLfloat *texel)
{
   GLbyte red, green;
   signed_fetch_texel_rgtc(rowStride,
                           (GLbyte *) map,
                           i, j, &red, 2);
   signed_fetch_texel_rgtc(rowStride,
                           (GLbyte *) map + 8,
                           i, j, &green, 2);
   texel[RCOMP] = BYTE_TO_FLOAT_TEX(red);
   texel[GCOMP] = BYTE_TO_FLOAT_TEX(green);
   texel[BCOMP] = 0.0;
   texel[ACOMP] = 1.0;
}


static void
fetch_signed_la_latc2(const GLubyte *map,
                      GLint rowStride, GLint i, GLint j, GLfloat *texel)
d427 4
a430 6
   signed_fetch_texel_rgtc(rowStride,
                           (GLbyte *) map,
                           i, j, &red, 2);
   signed_fetch_texel_rgtc(rowStride,
                           (GLbyte *) map + 8,
                           i, j, &green, 2);
d437 5
d443 18
a460 24
compressed_fetch_func
_mesa_get_compressed_rgtc_func(gl_format format)
{
   switch (format) {
   case MESA_FORMAT_RED_RGTC1:
      return fetch_red_rgtc1;
   case MESA_FORMAT_L_LATC1:
      return fetch_l_latc1;
   case MESA_FORMAT_SIGNED_RED_RGTC1:
      return fetch_signed_red_rgtc1;
   case MESA_FORMAT_SIGNED_L_LATC1:
      return fetch_signed_l_latc1;
   case MESA_FORMAT_RG_RGTC2:
      return fetch_rg_rgtc2;
   case MESA_FORMAT_LA_LATC2:
      return fetch_la_latc2;
   case MESA_FORMAT_SIGNED_RG_RGTC2:
      return fetch_signed_rg_rgtc2;
   case MESA_FORMAT_SIGNED_LA_LATC2:
      return fetch_signed_la_latc2;
   default:
      return NULL;
   }
}
@


1.1.1.2
log
@Import Mesa 10.2.3
@
text
@d100 2
a101 2
   ASSERT(dstFormat == MESA_FORMAT_R_RGTC1_UNORM ||
          dstFormat == MESA_FORMAT_L_LATC1_UNORM);
d147 2
a148 2
   ASSERT(dstFormat == MESA_FORMAT_R_RGTC1_SNORM ||
          dstFormat == MESA_FORMAT_L_LATC1_SNORM);
d195 2
a196 2
   ASSERT(dstFormat == MESA_FORMAT_RG_RGTC2_UNORM ||
          dstFormat == MESA_FORMAT_LA_LATC2_UNORM);
d249 2
a250 2
   ASSERT(dstFormat == MESA_FORMAT_RG_RGTC2_SNORM ||
          dstFormat == MESA_FORMAT_LA_LATC2_SNORM);
d442 1
a442 1
_mesa_get_compressed_rgtc_func(mesa_format format)
d445 1
a445 1
   case MESA_FORMAT_R_RGTC1_UNORM:
d447 1
a447 1
   case MESA_FORMAT_L_LATC1_UNORM:
d449 1
a449 1
   case MESA_FORMAT_R_RGTC1_SNORM:
d451 1
a451 1
   case MESA_FORMAT_L_LATC1_SNORM:
d453 1
a453 1
   case MESA_FORMAT_RG_RGTC2_UNORM:
d455 1
a455 1
   case MESA_FORMAT_LA_LATC2_UNORM:
d457 1
a457 1
   case MESA_FORMAT_RG_RGTC2_SNORM:
d459 1
a459 1
   case MESA_FORMAT_LA_LATC2_SNORM:
@


1.1.1.3
log
@Import Mesa 10.4.3
@
text
@a42 1
#include "util/rgtc.h"
d46 14
d124 1
a124 1
	 util_format_unsigned_encode_rgtc_ubyte(blkaddr, srcpixels, numxpixels, numypixels);
d171 1
a171 1
	 util_format_signed_encode_rgtc_ubyte(blkaddr, srcpixels, numxpixels, numypixels);
d219 1
a219 1
	 util_format_unsigned_encode_rgtc_ubyte(blkaddr, srcpixels, numxpixels, numypixels);
d223 1
a223 1
	 util_format_unsigned_encode_rgtc_ubyte(blkaddr, srcpixels, numxpixels, numypixels);
d274 1
a274 1
	 util_format_signed_encode_rgtc_ubyte(blkaddr, srcpixels, numxpixels, numypixels);
d278 1
a278 1
	 util_format_signed_encode_rgtc_ubyte(blkaddr, srcpixels, numxpixels, numypixels);
d292 28
d325 1
a325 1
   util_format_unsigned_fetch_texel_rgtc(rowStride, map, i, j, &red, 1);
d337 1
a337 1
   util_format_unsigned_fetch_texel_rgtc(rowStride, map, i, j, &red, 1);
d349 1
a349 1
   util_format_signed_fetch_texel_rgtc(rowStride, (const GLbyte *) map,
d362 1
a362 1
   util_format_signed_fetch_texel_rgtc(rowStride, (GLbyte *) map,
d375 1
a375 1
   util_format_unsigned_fetch_texel_rgtc(rowStride,
d378 1
a378 1
   util_format_unsigned_fetch_texel_rgtc(rowStride,
d392 1
a392 1
   util_format_unsigned_fetch_texel_rgtc(rowStride,
d395 1
a395 1
   util_format_unsigned_fetch_texel_rgtc(rowStride,
d410 1
a410 1
   util_format_signed_fetch_texel_rgtc(rowStride,
d413 1
a413 1
   util_format_signed_fetch_texel_rgtc(rowStride,
d428 1
a428 1
   util_format_signed_fetch_texel_rgtc(rowStride,
d431 1
a431 1
   util_format_signed_fetch_texel_rgtc(rowStride,
@


1.1.1.4
log
@Import Mesa 10.2.9
@
text
@d43 1
a46 14

#define RGTC_DEBUG 0

static void unsigned_encode_rgtc_ubyte(GLubyte *blkaddr, GLubyte srccolors[4][4],
					GLint numxpixels, GLint numypixels);
static void signed_encode_rgtc_ubyte(GLbyte *blkaddr, GLbyte srccolors[4][4],
			     GLint numxpixels, GLint numypixels);

static void unsigned_fetch_texel_rgtc(unsigned srcRowStride, const GLubyte *pixdata,
				      unsigned i, unsigned j, GLubyte *value, unsigned comps);

static void signed_fetch_texel_rgtc(unsigned srcRowStride, const GLbyte *pixdata,
				      unsigned i, unsigned j, GLbyte *value, unsigned comps);

d111 1
a111 1
	 unsigned_encode_rgtc_ubyte(blkaddr, srcpixels, numxpixels, numypixels);
d158 1
a158 1
	 signed_encode_rgtc_ubyte(blkaddr, srcpixels, numxpixels, numypixels);
d206 1
a206 1
	 unsigned_encode_rgtc_ubyte(blkaddr, srcpixels, numxpixels, numypixels);
d210 1
a210 1
	 unsigned_encode_rgtc_ubyte(blkaddr, srcpixels, numxpixels, numypixels);
d261 1
a261 1
	 signed_encode_rgtc_ubyte(blkaddr, srcpixels, numxpixels, numypixels);
d265 1
a265 1
	 signed_encode_rgtc_ubyte(blkaddr, srcpixels, numxpixels, numypixels);
a278 28

#define TAG(x) unsigned_##x

#define TYPE GLubyte
#define T_MIN 0
#define T_MAX 0xff

#include "texcompress_rgtc_tmp.h"

#undef TAG
#undef TYPE
#undef T_MIN
#undef T_MAX

#define TAG(x) signed_##x
#define TYPE GLbyte
#define T_MIN (GLbyte)-128
#define T_MAX (GLbyte)127

#include "texcompress_rgtc_tmp.h"

#undef TAG
#undef TYPE
#undef T_MIN
#undef T_MAX



d284 1
a284 1
   unsigned_fetch_texel_rgtc(rowStride, map, i, j, &red, 1);
d296 1
a296 1
   unsigned_fetch_texel_rgtc(rowStride, map, i, j, &red, 1);
d308 1
a308 1
   signed_fetch_texel_rgtc(rowStride, (const GLbyte *) map,
d321 1
a321 1
   signed_fetch_texel_rgtc(rowStride, (GLbyte *) map,
d334 1
a334 1
   unsigned_fetch_texel_rgtc(rowStride,
d337 1
a337 1
   unsigned_fetch_texel_rgtc(rowStride,
d351 1
a351 1
   unsigned_fetch_texel_rgtc(rowStride,
d354 1
a354 1
   unsigned_fetch_texel_rgtc(rowStride,
d369 1
a369 1
   signed_fetch_texel_rgtc(rowStride,
d372 1
a372 1
   signed_fetch_texel_rgtc(rowStride,
d387 1
a387 1
   signed_fetch_texel_rgtc(rowStride,
d390 1
a390 1
   signed_fetch_texel_rgtc(rowStride,
@


