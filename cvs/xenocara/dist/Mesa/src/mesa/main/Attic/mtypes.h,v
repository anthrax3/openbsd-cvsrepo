head	1.13;
access;
symbols
	OPENBSD_5_8:1.12.0.4
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	v10_2_9:1.1.1.8
	v10_4_3:1.1.1.7
	v10_2_7:1.1.1.6
	OPENBSD_5_6:1.10.0.2
	OPENBSD_5_6_BASE:1.10
	v10_2_3:1.1.1.6
	OPENBSD_5_5:1.9.0.2
	OPENBSD_5_5_BASE:1.9
	v9_2_5:1.1.1.5
	v9_2_3:1.1.1.5
	v9_2_2:1.1.1.5
	v9_2_1:1.1.1.5
	v9_2_0:1.1.1.5
	OPENBSD_5_4:1.8.0.4
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.2
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.7.0.4
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.6.0.6
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.4
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.5.0.4
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.2
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.4.0.2
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.3.0.2
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_3:1.2.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2015.12.23.05.17.52;	author jsg;	state dead;
branches;
next	1.12;
commitid	TnlogFl9nOv2eaRf;

1.12
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.11;
commitid	4ry2gvZGMXkCUD2n;

1.11
date	2015.01.25.14.41.22;	author jsg;	state Exp;
branches;
next	1.10;
commitid	mcxB0JvoI9gTDYXU;

1.10
date	2014.07.09.21.09.00;	author jsg;	state Exp;
branches;
next	1.9;
commitid	WPD6rgPryPkvXOr9;

1.9
date	2013.09.05.14.06.24;	author jsg;	state Exp;
branches;
next	1.8;

1.8
date	2012.08.17.13.58.19;	author mpi;	state Exp;
branches;
next	1.7;

1.7
date	2011.10.23.13.37.42;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.05.22.20.06.31;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2009.05.17.20.26.41;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2008.11.02.14.58.21;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.05.31.16.36.48;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.02.12.21.09.27;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.50.13;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.50.13;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.56.38;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.31.15;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.46;	author matthieu;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.09.05.13.16.44;	author jsg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.07.09.20.35.03;	author jsg;	state Exp;
branches;
next	1.1.1.7;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.7
date	2015.01.25.14.12.47;	author jsg;	state Exp;
branches;
next	1.1.1.8;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.8
date	2015.02.20.22.49.54;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.13
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2008  Brian Paul   All Rights Reserved.
 * Copyright (C) 2009  VMware, Inc.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

/**
 * \file mtypes.h
 * Main Mesa data structures.
 *
 * Please try to mark derived values with a leading underscore ('_').
 */

#ifndef MTYPES_H
#define MTYPES_H


#include <stdint.h>             /* uint32_t */
#include <stdbool.h>

#include "main/glheader.h"
#include "main/config.h"
#include "glapi/glapi.h"
#include "math/m_matrix.h"	/* GLmatrix */
#include "main/simple_list.h"	/* struct simple_node */
#include "main/formats.h"       /* MESA_FORMAT_COUNT */


#ifdef __cplusplus
extern "C" {
#endif


/**
 * \name 64-bit extension of GLbitfield.
 */
/*@@{*/
typedef GLuint64 GLbitfield64;

/** Set a single bit */
#define BITFIELD64_BIT(b)      ((GLbitfield64)1 << (b))
/** Set all bits up to excluding bit b */
#define BITFIELD64_MASK(b)      \
   ((b) == 64 ? (~(GLbitfield64)0) : BITFIELD64_BIT(b) - 1)
/** Set count bits starting from bit b  */
#define BITFIELD64_RANGE(b, count) \
   (BITFIELD64_MASK((b) + (count)) & ~BITFIELD64_MASK(b))


/**
 * \name Some forward type declarations
 */
/*@@{*/
struct _mesa_HashTable;
struct gl_attrib_node;
struct gl_list_extensions;
struct gl_meta_state;
struct gl_program_cache;
struct gl_texture_object;
struct gl_debug_state;
struct gl_context;
struct st_context;
struct gl_uniform_storage;
struct prog_instruction;
struct gl_program_parameter_list;
struct set;
struct set_entry;
struct vbo_context;
/*@@}*/


/** Extra draw modes beyond GL_POINTS, GL_TRIANGLE_FAN, etc */
#define PRIM_MAX                 GL_TRIANGLE_STRIP_ADJACENCY
#define PRIM_OUTSIDE_BEGIN_END   (PRIM_MAX + 1)
#define PRIM_UNKNOWN             (PRIM_MAX + 2)



/**
 * Indexes for vertex program attributes.
 * GL_NV_vertex_program aliases generic attributes over the conventional
 * attributes.  In GL_ARB_vertex_program shader the aliasing is optional.
 * In GL_ARB_vertex_shader / OpenGL 2.0 the aliasing is disallowed (the
 * generic attributes are distinct/separate).
 */
typedef enum
{
   VERT_ATTRIB_POS = 0,
   VERT_ATTRIB_WEIGHT = 1,
   VERT_ATTRIB_NORMAL = 2,
   VERT_ATTRIB_COLOR0 = 3,
   VERT_ATTRIB_COLOR1 = 4,
   VERT_ATTRIB_FOG = 5,
   VERT_ATTRIB_COLOR_INDEX = 6,
   VERT_ATTRIB_EDGEFLAG = 7,
   VERT_ATTRIB_TEX0 = 8,
   VERT_ATTRIB_TEX1 = 9,
   VERT_ATTRIB_TEX2 = 10,
   VERT_ATTRIB_TEX3 = 11,
   VERT_ATTRIB_TEX4 = 12,
   VERT_ATTRIB_TEX5 = 13,
   VERT_ATTRIB_TEX6 = 14,
   VERT_ATTRIB_TEX7 = 15,
   VERT_ATTRIB_POINT_SIZE = 16,
   VERT_ATTRIB_GENERIC0 = 17,
   VERT_ATTRIB_GENERIC1 = 18,
   VERT_ATTRIB_GENERIC2 = 19,
   VERT_ATTRIB_GENERIC3 = 20,
   VERT_ATTRIB_GENERIC4 = 21,
   VERT_ATTRIB_GENERIC5 = 22,
   VERT_ATTRIB_GENERIC6 = 23,
   VERT_ATTRIB_GENERIC7 = 24,
   VERT_ATTRIB_GENERIC8 = 25,
   VERT_ATTRIB_GENERIC9 = 26,
   VERT_ATTRIB_GENERIC10 = 27,
   VERT_ATTRIB_GENERIC11 = 28,
   VERT_ATTRIB_GENERIC12 = 29,
   VERT_ATTRIB_GENERIC13 = 30,
   VERT_ATTRIB_GENERIC14 = 31,
   VERT_ATTRIB_GENERIC15 = 32,
   VERT_ATTRIB_MAX = 33
} gl_vert_attrib;

/**
 * Symbolic constats to help iterating over
 * specific blocks of vertex attributes.
 *
 * VERT_ATTRIB_FF
 *   includes all fixed function attributes as well as
 *   the aliased GL_NV_vertex_program shader attributes.
 * VERT_ATTRIB_TEX
 *   include the classic texture coordinate attributes.
 *   Is a subset of VERT_ATTRIB_FF.
 * VERT_ATTRIB_GENERIC
 *   include the OpenGL 2.0+ GLSL generic shader attributes.
 *   These alias the generic GL_ARB_vertex_shader attributes.
 */
#define VERT_ATTRIB_FF(i)           (VERT_ATTRIB_POS + (i))
#define VERT_ATTRIB_FF_MAX          VERT_ATTRIB_GENERIC0

#define VERT_ATTRIB_TEX(i)          (VERT_ATTRIB_TEX0 + (i))
#define VERT_ATTRIB_TEX_MAX         MAX_TEXTURE_COORD_UNITS

#define VERT_ATTRIB_GENERIC(i)      (VERT_ATTRIB_GENERIC0 + (i))
#define VERT_ATTRIB_GENERIC_MAX     MAX_VERTEX_GENERIC_ATTRIBS

/**
 * Bitflags for vertex attributes.
 * These are used in bitfields in many places.
 */
/*@@{*/
#define VERT_BIT_POS             BITFIELD64_BIT(VERT_ATTRIB_POS)
#define VERT_BIT_WEIGHT          BITFIELD64_BIT(VERT_ATTRIB_WEIGHT)
#define VERT_BIT_NORMAL          BITFIELD64_BIT(VERT_ATTRIB_NORMAL)
#define VERT_BIT_COLOR0          BITFIELD64_BIT(VERT_ATTRIB_COLOR0)
#define VERT_BIT_COLOR1          BITFIELD64_BIT(VERT_ATTRIB_COLOR1)
#define VERT_BIT_FOG             BITFIELD64_BIT(VERT_ATTRIB_FOG)
#define VERT_BIT_COLOR_INDEX     BITFIELD64_BIT(VERT_ATTRIB_COLOR_INDEX)
#define VERT_BIT_EDGEFLAG        BITFIELD64_BIT(VERT_ATTRIB_EDGEFLAG)
#define VERT_BIT_TEX0            BITFIELD64_BIT(VERT_ATTRIB_TEX0)
#define VERT_BIT_TEX1            BITFIELD64_BIT(VERT_ATTRIB_TEX1)
#define VERT_BIT_TEX2            BITFIELD64_BIT(VERT_ATTRIB_TEX2)
#define VERT_BIT_TEX3            BITFIELD64_BIT(VERT_ATTRIB_TEX3)
#define VERT_BIT_TEX4            BITFIELD64_BIT(VERT_ATTRIB_TEX4)
#define VERT_BIT_TEX5            BITFIELD64_BIT(VERT_ATTRIB_TEX5)
#define VERT_BIT_TEX6            BITFIELD64_BIT(VERT_ATTRIB_TEX6)
#define VERT_BIT_TEX7            BITFIELD64_BIT(VERT_ATTRIB_TEX7)
#define VERT_BIT_POINT_SIZE      BITFIELD64_BIT(VERT_ATTRIB_POINT_SIZE)
#define VERT_BIT_GENERIC0        BITFIELD64_BIT(VERT_ATTRIB_GENERIC0)

#define VERT_BIT(i)              BITFIELD64_BIT(i)
#define VERT_BIT_ALL             BITFIELD64_RANGE(0, VERT_ATTRIB_MAX)

#define VERT_BIT_FF(i)           VERT_BIT(i)
#define VERT_BIT_FF_ALL          BITFIELD64_RANGE(0, VERT_ATTRIB_FF_MAX)
#define VERT_BIT_TEX(i)          VERT_BIT(VERT_ATTRIB_TEX(i))
#define VERT_BIT_TEX_ALL         \
   BITFIELD64_RANGE(VERT_ATTRIB_TEX(0), VERT_ATTRIB_TEX_MAX)

#define VERT_BIT_GENERIC(i)      VERT_BIT(VERT_ATTRIB_GENERIC(i))
#define VERT_BIT_GENERIC_ALL     \
   BITFIELD64_RANGE(VERT_ATTRIB_GENERIC(0), VERT_ATTRIB_GENERIC_MAX)
/*@@}*/


/**
 * Indexes for vertex shader outputs, geometry shader inputs/outputs, and
 * fragment shader inputs.
 *
 * Note that some of these values are not available to all pipeline stages.
 *
 * When this enum is updated, the following code must be updated too:
 * - vertResults (in prog_print.c's arb_output_attrib_string())
 * - fragAttribs (in prog_print.c's arb_input_attrib_string())
 * - _mesa_varying_slot_in_fs()
 */
typedef enum
{
   VARYING_SLOT_POS,
   VARYING_SLOT_COL0, /* COL0 and COL1 must be contiguous */
   VARYING_SLOT_COL1,
   VARYING_SLOT_FOGC,
   VARYING_SLOT_TEX0, /* TEX0-TEX7 must be contiguous */
   VARYING_SLOT_TEX1,
   VARYING_SLOT_TEX2,
   VARYING_SLOT_TEX3,
   VARYING_SLOT_TEX4,
   VARYING_SLOT_TEX5,
   VARYING_SLOT_TEX6,
   VARYING_SLOT_TEX7,
   VARYING_SLOT_PSIZ, /* Does not appear in FS */
   VARYING_SLOT_BFC0, /* Does not appear in FS */
   VARYING_SLOT_BFC1, /* Does not appear in FS */
   VARYING_SLOT_EDGE, /* Does not appear in FS */
   VARYING_SLOT_CLIP_VERTEX, /* Does not appear in FS */
   VARYING_SLOT_CLIP_DIST0,
   VARYING_SLOT_CLIP_DIST1,
   VARYING_SLOT_PRIMITIVE_ID, /* Does not appear in VS */
   VARYING_SLOT_LAYER, /* Appears as VS or GS output */
   VARYING_SLOT_VIEWPORT, /* Appears as VS or GS output */
   VARYING_SLOT_FACE, /* FS only */
   VARYING_SLOT_PNTC, /* FS only */
   VARYING_SLOT_VAR0, /* First generic varying slot */
   VARYING_SLOT_MAX = VARYING_SLOT_VAR0 + MAX_VARYING
} gl_varying_slot;


/**
 * Bitflags for varying slots.
 */
/*@@{*/
#define VARYING_BIT_POS BITFIELD64_BIT(VARYING_SLOT_POS)
#define VARYING_BIT_COL0 BITFIELD64_BIT(VARYING_SLOT_COL0)
#define VARYING_BIT_COL1 BITFIELD64_BIT(VARYING_SLOT_COL1)
#define VARYING_BIT_FOGC BITFIELD64_BIT(VARYING_SLOT_FOGC)
#define VARYING_BIT_TEX0 BITFIELD64_BIT(VARYING_SLOT_TEX0)
#define VARYING_BIT_TEX1 BITFIELD64_BIT(VARYING_SLOT_TEX1)
#define VARYING_BIT_TEX2 BITFIELD64_BIT(VARYING_SLOT_TEX2)
#define VARYING_BIT_TEX3 BITFIELD64_BIT(VARYING_SLOT_TEX3)
#define VARYING_BIT_TEX4 BITFIELD64_BIT(VARYING_SLOT_TEX4)
#define VARYING_BIT_TEX5 BITFIELD64_BIT(VARYING_SLOT_TEX5)
#define VARYING_BIT_TEX6 BITFIELD64_BIT(VARYING_SLOT_TEX6)
#define VARYING_BIT_TEX7 BITFIELD64_BIT(VARYING_SLOT_TEX7)
#define VARYING_BIT_TEX(U) BITFIELD64_BIT(VARYING_SLOT_TEX0 + (U))
#define VARYING_BITS_TEX_ANY BITFIELD64_RANGE(VARYING_SLOT_TEX0, \
                                              MAX_TEXTURE_COORD_UNITS)
#define VARYING_BIT_PSIZ BITFIELD64_BIT(VARYING_SLOT_PSIZ)
#define VARYING_BIT_BFC0 BITFIELD64_BIT(VARYING_SLOT_BFC0)
#define VARYING_BIT_BFC1 BITFIELD64_BIT(VARYING_SLOT_BFC1)
#define VARYING_BIT_EDGE BITFIELD64_BIT(VARYING_SLOT_EDGE)
#define VARYING_BIT_CLIP_VERTEX BITFIELD64_BIT(VARYING_SLOT_CLIP_VERTEX)
#define VARYING_BIT_CLIP_DIST0 BITFIELD64_BIT(VARYING_SLOT_CLIP_DIST0)
#define VARYING_BIT_CLIP_DIST1 BITFIELD64_BIT(VARYING_SLOT_CLIP_DIST1)
#define VARYING_BIT_PRIMITIVE_ID BITFIELD64_BIT(VARYING_SLOT_PRIMITIVE_ID)
#define VARYING_BIT_LAYER BITFIELD64_BIT(VARYING_SLOT_LAYER)
#define VARYING_BIT_VIEWPORT BITFIELD64_BIT(VARYING_SLOT_VIEWPORT)
#define VARYING_BIT_FACE BITFIELD64_BIT(VARYING_SLOT_FACE)
#define VARYING_BIT_PNTC BITFIELD64_BIT(VARYING_SLOT_PNTC)
#define VARYING_BIT_VAR(V) BITFIELD64_BIT(VARYING_SLOT_VAR0 + (V))
/*@@}*/

/**
 * Bitflags for system values.
 */
#define SYSTEM_BIT_SAMPLE_ID BITFIELD64_BIT(SYSTEM_VALUE_SAMPLE_ID)
#define SYSTEM_BIT_SAMPLE_POS BITFIELD64_BIT(SYSTEM_VALUE_SAMPLE_POS)
#define SYSTEM_BIT_SAMPLE_MASK_IN BITFIELD64_BIT(SYSTEM_VALUE_SAMPLE_MASK_IN)

/**
 * Determine if the given gl_varying_slot appears in the fragment shader.
 */
static inline GLboolean
_mesa_varying_slot_in_fs(gl_varying_slot slot)
{
   switch (slot) {
   case VARYING_SLOT_PSIZ:
   case VARYING_SLOT_BFC0:
   case VARYING_SLOT_BFC1:
   case VARYING_SLOT_EDGE:
   case VARYING_SLOT_CLIP_VERTEX:
   case VARYING_SLOT_LAYER:
      return GL_FALSE;
   default:
      return GL_TRUE;
   }
}


/**
 * Fragment program results
 */
typedef enum
{
   FRAG_RESULT_DEPTH = 0,
   FRAG_RESULT_STENCIL = 1,
   /* If a single color should be written to all render targets, this
    * register is written.  No FRAG_RESULT_DATAn will be written.
    */
   FRAG_RESULT_COLOR = 2,
   FRAG_RESULT_SAMPLE_MASK = 3,

   /* FRAG_RESULT_DATAn are the per-render-target (GLSL gl_FragData[n]
    * or ARB_fragment_program fragment.color[n]) color results.  If
    * any are written, FRAG_RESULT_COLOR will not be written.
    */
   FRAG_RESULT_DATA0 = 4,
   FRAG_RESULT_MAX = (FRAG_RESULT_DATA0 + MAX_DRAW_BUFFERS)
} gl_frag_result;


/**
 * Indexes for all renderbuffers
 */
typedef enum
{
   /* the four standard color buffers */
   BUFFER_FRONT_LEFT,
   BUFFER_BACK_LEFT,
   BUFFER_FRONT_RIGHT,
   BUFFER_BACK_RIGHT,
   BUFFER_DEPTH,
   BUFFER_STENCIL,
   BUFFER_ACCUM,
   /* optional aux buffer */
   BUFFER_AUX0,
   /* generic renderbuffers */
   BUFFER_COLOR0,
   BUFFER_COLOR1,
   BUFFER_COLOR2,
   BUFFER_COLOR3,
   BUFFER_COLOR4,
   BUFFER_COLOR5,
   BUFFER_COLOR6,
   BUFFER_COLOR7,
   BUFFER_COUNT
} gl_buffer_index;

/**
 * Bit flags for all renderbuffers
 */
#define BUFFER_BIT_FRONT_LEFT   (1 << BUFFER_FRONT_LEFT)
#define BUFFER_BIT_BACK_LEFT    (1 << BUFFER_BACK_LEFT)
#define BUFFER_BIT_FRONT_RIGHT  (1 << BUFFER_FRONT_RIGHT)
#define BUFFER_BIT_BACK_RIGHT   (1 << BUFFER_BACK_RIGHT)
#define BUFFER_BIT_AUX0         (1 << BUFFER_AUX0)
#define BUFFER_BIT_AUX1         (1 << BUFFER_AUX1)
#define BUFFER_BIT_AUX2         (1 << BUFFER_AUX2)
#define BUFFER_BIT_AUX3         (1 << BUFFER_AUX3)
#define BUFFER_BIT_DEPTH        (1 << BUFFER_DEPTH)
#define BUFFER_BIT_STENCIL      (1 << BUFFER_STENCIL)
#define BUFFER_BIT_ACCUM        (1 << BUFFER_ACCUM)
#define BUFFER_BIT_COLOR0       (1 << BUFFER_COLOR0)
#define BUFFER_BIT_COLOR1       (1 << BUFFER_COLOR1)
#define BUFFER_BIT_COLOR2       (1 << BUFFER_COLOR2)
#define BUFFER_BIT_COLOR3       (1 << BUFFER_COLOR3)
#define BUFFER_BIT_COLOR4       (1 << BUFFER_COLOR4)
#define BUFFER_BIT_COLOR5       (1 << BUFFER_COLOR5)
#define BUFFER_BIT_COLOR6       (1 << BUFFER_COLOR6)
#define BUFFER_BIT_COLOR7       (1 << BUFFER_COLOR7)

/**
 * Mask of all the color buffer bits (but not accum).
 */
#define BUFFER_BITS_COLOR  (BUFFER_BIT_FRONT_LEFT | \
                            BUFFER_BIT_BACK_LEFT | \
                            BUFFER_BIT_FRONT_RIGHT | \
                            BUFFER_BIT_BACK_RIGHT | \
                            BUFFER_BIT_AUX0 | \
                            BUFFER_BIT_COLOR0 | \
                            BUFFER_BIT_COLOR1 | \
                            BUFFER_BIT_COLOR2 | \
                            BUFFER_BIT_COLOR3 | \
                            BUFFER_BIT_COLOR4 | \
                            BUFFER_BIT_COLOR5 | \
                            BUFFER_BIT_COLOR6 | \
                            BUFFER_BIT_COLOR7)


/**
 * Shader stages. Note that these will become 5 with tessellation.
 *
 * The order must match how shaders are ordered in the pipeline.
 * The GLSL linker assumes that if i<j, then the j-th shader is
 * executed later than the i-th shader.
 */
typedef enum
{
   MESA_SHADER_VERTEX = 0,
   MESA_SHADER_GEOMETRY = 1,
   MESA_SHADER_FRAGMENT = 2,
   MESA_SHADER_COMPUTE = 3,
} gl_shader_stage;

#define MESA_SHADER_STAGES (MESA_SHADER_COMPUTE + 1)


/**
 * Framebuffer configuration (aka visual / pixelformat)
 * Note: some of these fields should be boolean, but it appears that
 * code in drivers/dri/common/util.c requires int-sized fields.
 */
struct gl_config
{
   GLboolean rgbMode;
   GLboolean floatMode;
   GLboolean colorIndexMode;  /* XXX is this used anywhere? */
   GLuint doubleBufferMode;
   GLuint stereoMode;

   GLboolean haveAccumBuffer;
   GLboolean haveDepthBuffer;
   GLboolean haveStencilBuffer;

   GLint redBits, greenBits, blueBits, alphaBits;	/* bits per comp */
   GLuint redMask, greenMask, blueMask, alphaMask;
   GLint rgbBits;		/* total bits for rgb */
   GLint indexBits;		/* total bits for colorindex */

   GLint accumRedBits, accumGreenBits, accumBlueBits, accumAlphaBits;
   GLint depthBits;
   GLint stencilBits;

   GLint numAuxBuffers;

   GLint level;

   /* EXT_visual_rating / GLX 1.2 */
   GLint visualRating;

   /* EXT_visual_info / GLX 1.2 */
   GLint transparentPixel;
   /*    colors are floats scaled to ints */
   GLint transparentRed, transparentGreen, transparentBlue, transparentAlpha;
   GLint transparentIndex;

   /* ARB_multisample / SGIS_multisample */
   GLint sampleBuffers;
   GLint samples;

   /* SGIX_pbuffer / GLX 1.3 */
   GLint maxPbufferWidth;
   GLint maxPbufferHeight;
   GLint maxPbufferPixels;
   GLint optimalPbufferWidth;   /* Only for SGIX_pbuffer. */
   GLint optimalPbufferHeight;  /* Only for SGIX_pbuffer. */

   /* OML_swap_method */
   GLint swapMethod;

   /* EXT_texture_from_pixmap */
   GLint bindToTextureRgb;
   GLint bindToTextureRgba;
   GLint bindToMipmapTexture;
   GLint bindToTextureTargets;
   GLint yInverted;

   /* EXT_framebuffer_sRGB */
   GLint sRGBCapable;
};


/**
 * \name Bit flags used for updating material values.
 */
/*@@{*/
#define MAT_ATTRIB_FRONT_AMBIENT           0 
#define MAT_ATTRIB_BACK_AMBIENT            1
#define MAT_ATTRIB_FRONT_DIFFUSE           2 
#define MAT_ATTRIB_BACK_DIFFUSE            3
#define MAT_ATTRIB_FRONT_SPECULAR          4 
#define MAT_ATTRIB_BACK_SPECULAR           5
#define MAT_ATTRIB_FRONT_EMISSION          6
#define MAT_ATTRIB_BACK_EMISSION           7
#define MAT_ATTRIB_FRONT_SHININESS         8
#define MAT_ATTRIB_BACK_SHININESS          9
#define MAT_ATTRIB_FRONT_INDEXES           10
#define MAT_ATTRIB_BACK_INDEXES            11
#define MAT_ATTRIB_MAX                     12

#define MAT_ATTRIB_AMBIENT(f)  (MAT_ATTRIB_FRONT_AMBIENT+(f))  
#define MAT_ATTRIB_DIFFUSE(f)  (MAT_ATTRIB_FRONT_DIFFUSE+(f))  
#define MAT_ATTRIB_SPECULAR(f) (MAT_ATTRIB_FRONT_SPECULAR+(f)) 
#define MAT_ATTRIB_EMISSION(f) (MAT_ATTRIB_FRONT_EMISSION+(f)) 
#define MAT_ATTRIB_SHININESS(f)(MAT_ATTRIB_FRONT_SHININESS+(f))
#define MAT_ATTRIB_INDEXES(f)  (MAT_ATTRIB_FRONT_INDEXES+(f))  

#define MAT_INDEX_AMBIENT  0
#define MAT_INDEX_DIFFUSE  1
#define MAT_INDEX_SPECULAR 2

#define MAT_BIT_FRONT_AMBIENT         (1<<MAT_ATTRIB_FRONT_AMBIENT)
#define MAT_BIT_BACK_AMBIENT          (1<<MAT_ATTRIB_BACK_AMBIENT)
#define MAT_BIT_FRONT_DIFFUSE         (1<<MAT_ATTRIB_FRONT_DIFFUSE)
#define MAT_BIT_BACK_DIFFUSE          (1<<MAT_ATTRIB_BACK_DIFFUSE)
#define MAT_BIT_FRONT_SPECULAR        (1<<MAT_ATTRIB_FRONT_SPECULAR)
#define MAT_BIT_BACK_SPECULAR         (1<<MAT_ATTRIB_BACK_SPECULAR)
#define MAT_BIT_FRONT_EMISSION        (1<<MAT_ATTRIB_FRONT_EMISSION)
#define MAT_BIT_BACK_EMISSION         (1<<MAT_ATTRIB_BACK_EMISSION)
#define MAT_BIT_FRONT_SHININESS       (1<<MAT_ATTRIB_FRONT_SHININESS)
#define MAT_BIT_BACK_SHININESS        (1<<MAT_ATTRIB_BACK_SHININESS)
#define MAT_BIT_FRONT_INDEXES         (1<<MAT_ATTRIB_FRONT_INDEXES)
#define MAT_BIT_BACK_INDEXES          (1<<MAT_ATTRIB_BACK_INDEXES)


#define FRONT_MATERIAL_BITS	(MAT_BIT_FRONT_EMISSION | 	\
				 MAT_BIT_FRONT_AMBIENT |	\
				 MAT_BIT_FRONT_DIFFUSE | 	\
				 MAT_BIT_FRONT_SPECULAR |	\
				 MAT_BIT_FRONT_SHININESS | 	\
				 MAT_BIT_FRONT_INDEXES)

#define BACK_MATERIAL_BITS	(MAT_BIT_BACK_EMISSION |	\
				 MAT_BIT_BACK_AMBIENT |		\
				 MAT_BIT_BACK_DIFFUSE |		\
				 MAT_BIT_BACK_SPECULAR |	\
				 MAT_BIT_BACK_SHININESS |	\
				 MAT_BIT_BACK_INDEXES)

#define ALL_MATERIAL_BITS	(FRONT_MATERIAL_BITS | BACK_MATERIAL_BITS)
/*@@}*/


/**
 * Material state.
 */
struct gl_material
{
   GLfloat Attrib[MAT_ATTRIB_MAX][4];
};


/**
 * Light state flags.
 */
/*@@{*/
#define LIGHT_SPOT         0x1
#define LIGHT_LOCAL_VIEWER 0x2
#define LIGHT_POSITIONAL   0x4
#define LIGHT_NEED_VERTICES (LIGHT_POSITIONAL|LIGHT_LOCAL_VIEWER)
/*@@}*/


/**
 * Light source state.
 */
struct gl_light
{
   struct gl_light *next;	/**< double linked list with sentinel */
   struct gl_light *prev;

   GLfloat Ambient[4];		/**< ambient color */
   GLfloat Diffuse[4];		/**< diffuse color */
   GLfloat Specular[4];		/**< specular color */
   GLfloat EyePosition[4];	/**< position in eye coordinates */
   GLfloat SpotDirection[4];	/**< spotlight direction in eye coordinates */
   GLfloat SpotExponent;
   GLfloat SpotCutoff;		/**< in degrees */
   GLfloat _CosCutoff;		/**< = MAX(0, cos(SpotCutoff)) */
   GLfloat ConstantAttenuation;
   GLfloat LinearAttenuation;
   GLfloat QuadraticAttenuation;
   GLboolean Enabled;		/**< On/off flag */

   /** 
    * \name Derived fields
    */
   /*@@{*/
   GLbitfield _Flags;		/**< Mask of LIGHT_x bits defined above */

   GLfloat _Position[4];	/**< position in eye/obj coordinates */
   GLfloat _VP_inf_norm[3];	/**< Norm direction to infinite light */
   GLfloat _h_inf_norm[3];	/**< Norm( _VP_inf_norm + <0,0,1> ) */
   GLfloat _NormSpotDirection[4]; /**< normalized spotlight direction */
   GLfloat _VP_inf_spot_attenuation;

   GLfloat _MatAmbient[2][3];	/**< material ambient * light ambient */
   GLfloat _MatDiffuse[2][3];	/**< material diffuse * light diffuse */
   GLfloat _MatSpecular[2][3];	/**< material spec * light specular */
   /*@@}*/
};


/**
 * Light model state.
 */
struct gl_lightmodel
{
   GLfloat Ambient[4];		/**< ambient color */
   GLboolean LocalViewer;	/**< Local (or infinite) view point? */
   GLboolean TwoSide;		/**< Two (or one) sided lighting? */
   GLenum ColorControl;		/**< either GL_SINGLE_COLOR
				 *    or GL_SEPARATE_SPECULAR_COLOR */
};


/**
 * Accumulation buffer attribute group (GL_ACCUM_BUFFER_BIT)
 */
struct gl_accum_attrib
{
   GLfloat ClearColor[4];	/**< Accumulation buffer clear color */
};


/**
 * Used for storing clear color, texture border color, etc.
 * The float values are typically unclamped.
 */
union gl_color_union
{
   GLfloat f[4];
   GLint i[4];
   GLuint ui[4];
};


/**
 * Color buffer attribute group (GL_COLOR_BUFFER_BIT).
 */
struct gl_colorbuffer_attrib
{
   GLuint ClearIndex;                      /**< Index for glClear */
   union gl_color_union ClearColor;        /**< Color for glClear, unclamped */
   GLuint IndexMask;                       /**< Color index write mask */
   GLubyte ColorMask[MAX_DRAW_BUFFERS][4]; /**< Each flag is 0xff or 0x0 */

   GLenum DrawBuffer[MAX_DRAW_BUFFERS];	/**< Which buffer to draw into */

   /** 
    * \name alpha testing
    */
   /*@@{*/
   GLboolean AlphaEnabled;		/**< Alpha test enabled flag */
   GLenum AlphaFunc;			/**< Alpha test function */
   GLfloat AlphaRefUnclamped;
   GLclampf AlphaRef;			/**< Alpha reference value */
   /*@@}*/

   /** 
    * \name Blending
    */
   /*@@{*/
   GLbitfield BlendEnabled;		/**< Per-buffer blend enable flags */

   /* NOTE: this does _not_ depend on fragment clamping or any other clamping
    * control, only on the fixed-pointness of the render target.
    * The query does however depend on fragment color clamping.
    */
   GLfloat BlendColorUnclamped[4];               /**< Blending color */
   GLfloat BlendColor[4];		/**< Blending color */

   struct
   {
      GLenum SrcRGB;             /**< RGB blend source term */
      GLenum DstRGB;             /**< RGB blend dest term */
      GLenum SrcA;               /**< Alpha blend source term */
      GLenum DstA;               /**< Alpha blend dest term */
      GLenum EquationRGB;        /**< GL_ADD, GL_SUBTRACT, etc. */
      GLenum EquationA;          /**< GL_ADD, GL_SUBTRACT, etc. */
      /**
       * Set if any blend factor uses SRC1.  Computed at the time blend factors
       * get set.
       */
      GLboolean _UsesDualSrc;
   } Blend[MAX_DRAW_BUFFERS];
   /** Are the blend func terms currently different for each buffer/target? */
   GLboolean _BlendFuncPerBuffer;
   /** Are the blend equations currently different for each buffer/target? */
   GLboolean _BlendEquationPerBuffer;
   /*@@}*/

   /** 
    * \name Logic op
    */
   /*@@{*/
   GLenum LogicOp;			/**< Logic operator */
   GLboolean IndexLogicOpEnabled;	/**< Color index logic op enabled flag */
   GLboolean ColorLogicOpEnabled;	/**< RGBA logic op enabled flag */
   /*@@}*/

   GLboolean DitherFlag;		/**< Dither enable flag */

   GLenum ClampFragmentColor; /**< GL_TRUE, GL_FALSE or GL_FIXED_ONLY_ARB */
   GLboolean _ClampFragmentColor; /** < with GL_FIXED_ONLY_ARB resolved */
   GLenum ClampReadColor;     /**< GL_TRUE, GL_FALSE or GL_FIXED_ONLY_ARB */

   GLboolean sRGBEnabled;    /**< Framebuffer sRGB blending/updating requested */
};


/**
 * Current attribute group (GL_CURRENT_BIT).
 */
struct gl_current_attrib
{
   /**
    * \name Current vertex attributes.
    * \note Values are valid only after FLUSH_VERTICES has been called.
    * \note Index and Edgeflag current values are stored as floats in the 
    * SIX and SEVEN attribute slots.
    */
   GLfloat Attrib[VERT_ATTRIB_MAX][4];	/**< Position, color, texcoords, etc */

   /**
    * \name Current raster position attributes (always valid).
    * \note This set of attributes is very similar to the SWvertex struct.
    */
   /*@@{*/
   GLfloat RasterPos[4];
   GLfloat RasterDistance;
   GLfloat RasterColor[4];
   GLfloat RasterSecondaryColor[4];
   GLfloat RasterTexCoords[MAX_TEXTURE_COORD_UNITS][4];
   GLboolean RasterPosValid;
   /*@@}*/
};


/**
 * Depth buffer attribute group (GL_DEPTH_BUFFER_BIT).
 */
struct gl_depthbuffer_attrib
{
   GLenum Func;			/**< Function for depth buffer compare */
   GLclampd Clear;		/**< Value to clear depth buffer to */
   GLboolean Test;		/**< Depth buffering enabled flag */
   GLboolean Mask;		/**< Depth buffer writable? */
   GLboolean BoundsTest;        /**< GL_EXT_depth_bounds_test */
   GLfloat BoundsMin, BoundsMax;/**< GL_EXT_depth_bounds_test */
};


/**
 * Evaluator attribute group (GL_EVAL_BIT).
 */
struct gl_eval_attrib
{
   /**
    * \name Enable bits 
    */
   /*@@{*/
   GLboolean Map1Color4;
   GLboolean Map1Index;
   GLboolean Map1Normal;
   GLboolean Map1TextureCoord1;
   GLboolean Map1TextureCoord2;
   GLboolean Map1TextureCoord3;
   GLboolean Map1TextureCoord4;
   GLboolean Map1Vertex3;
   GLboolean Map1Vertex4;
   GLboolean Map2Color4;
   GLboolean Map2Index;
   GLboolean Map2Normal;
   GLboolean Map2TextureCoord1;
   GLboolean Map2TextureCoord2;
   GLboolean Map2TextureCoord3;
   GLboolean Map2TextureCoord4;
   GLboolean Map2Vertex3;
   GLboolean Map2Vertex4;
   GLboolean AutoNormal;
   /*@@}*/
   
   /**
    * \name Map Grid endpoints and divisions and calculated du values
    */
   /*@@{*/
   GLint MapGrid1un;
   GLfloat MapGrid1u1, MapGrid1u2, MapGrid1du;
   GLint MapGrid2un, MapGrid2vn;
   GLfloat MapGrid2u1, MapGrid2u2, MapGrid2du;
   GLfloat MapGrid2v1, MapGrid2v2, MapGrid2dv;
   /*@@}*/
};


/**
 * Fog attribute group (GL_FOG_BIT).
 */
struct gl_fog_attrib
{
   GLboolean Enabled;		/**< Fog enabled flag */
   GLfloat ColorUnclamped[4];            /**< Fog color */
   GLfloat Color[4];		/**< Fog color */
   GLfloat Density;		/**< Density >= 0.0 */
   GLfloat Start;		/**< Start distance in eye coords */
   GLfloat End;			/**< End distance in eye coords */
   GLfloat Index;		/**< Fog index */
   GLenum Mode;			/**< Fog mode */
   GLboolean ColorSumEnabled;
   GLenum FogCoordinateSource;  /**< GL_EXT_fog_coord */
   GLfloat _Scale;		/**< (End == Start) ? 1.0 : 1.0 / (End - Start) */
   GLenum FogDistanceMode;     /**< GL_NV_fog_distance */
};


/** 
 * Hint attribute group (GL_HINT_BIT).
 * 
 * Values are always one of GL_FASTEST, GL_NICEST, or GL_DONT_CARE.
 */
struct gl_hint_attrib
{
   GLenum PerspectiveCorrection;
   GLenum PointSmooth;
   GLenum LineSmooth;
   GLenum PolygonSmooth;
   GLenum Fog;
   GLenum TextureCompression;   /**< GL_ARB_texture_compression */
   GLenum GenerateMipmap;       /**< GL_SGIS_generate_mipmap */
   GLenum FragmentShaderDerivative; /**< GL_ARB_fragment_shader */
};


/**
 * Lighting attribute group (GL_LIGHT_BIT).
 */
struct gl_light_attrib
{
   struct gl_light Light[MAX_LIGHTS];	/**< Array of light sources */
   struct gl_lightmodel Model;		/**< Lighting model */

   /**
    * Front and back material values.
    * Note: must call FLUSH_VERTICES() before using.
    */
   struct gl_material Material;

   GLboolean Enabled;			/**< Lighting enabled flag */
   GLenum ShadeModel;			/**< GL_FLAT or GL_SMOOTH */
   GLenum ProvokingVertex;              /**< GL_EXT_provoking_vertex */
   GLenum ColorMaterialFace;		/**< GL_FRONT, BACK or FRONT_AND_BACK */
   GLenum ColorMaterialMode;		/**< GL_AMBIENT, GL_DIFFUSE, etc */
   GLbitfield _ColorMaterialBitmask;	/**< bitmask formed from Face and Mode */
   GLboolean ColorMaterialEnabled;
   GLenum ClampVertexColor;             /**< GL_TRUE, GL_FALSE, GL_FIXED_ONLY */
   GLboolean _ClampVertexColor;

   struct gl_light EnabledList;         /**< List sentinel */

   /** 
    * Derived state for optimizations: 
    */
   /*@@{*/
   GLboolean _NeedEyeCoords;		
   GLboolean _NeedVertices;		/**< Use fast shader? */
   GLfloat _BaseColor[2][3];
   /*@@}*/
};


/**
 * Line attribute group (GL_LINE_BIT).
 */
struct gl_line_attrib
{
   GLboolean SmoothFlag;	/**< GL_LINE_SMOOTH enabled? */
   GLboolean StippleFlag;	/**< GL_LINE_STIPPLE enabled? */
   GLushort StipplePattern;	/**< Stipple pattern */
   GLint StippleFactor;		/**< Stipple repeat factor */
   GLfloat Width;		/**< Line width */
};


/**
 * Display list attribute group (GL_LIST_BIT).
 */
struct gl_list_attrib
{
   GLuint ListBase;
};


/**
 * Multisample attribute group (GL_MULTISAMPLE_BIT).
 */
struct gl_multisample_attrib
{
   GLboolean Enabled;
   GLboolean _Enabled;   /**< true if Enabled and multisample buffer */
   GLboolean SampleAlphaToCoverage;
   GLboolean SampleAlphaToOne;
   GLboolean SampleCoverage;
   GLfloat SampleCoverageValue;
   GLboolean SampleCoverageInvert;
   GLboolean SampleShading;
   GLfloat MinSampleShadingValue;

   /* ARB_texture_multisample / GL3.2 additions */
   GLboolean SampleMask;
   /** The GL spec defines this as an array but >32x MSAA is madness */
   GLbitfield SampleMaskValue;
};


/**
 * A pixelmap (see glPixelMap)
 */
struct gl_pixelmap
{
   GLint Size;
   GLfloat Map[MAX_PIXEL_MAP_TABLE];
};


/**
 * Collection of all pixelmaps
 */
struct gl_pixelmaps
{
   struct gl_pixelmap RtoR;  /**< i.e. GL_PIXEL_MAP_R_TO_R */
   struct gl_pixelmap GtoG;
   struct gl_pixelmap BtoB;
   struct gl_pixelmap AtoA;
   struct gl_pixelmap ItoR;
   struct gl_pixelmap ItoG;
   struct gl_pixelmap ItoB;
   struct gl_pixelmap ItoA;
   struct gl_pixelmap ItoI;
   struct gl_pixelmap StoS;
};


/**
 * Pixel attribute group (GL_PIXEL_MODE_BIT).
 */
struct gl_pixel_attrib
{
   GLenum ReadBuffer;		/**< source buffer for glRead/CopyPixels() */

   /*--- Begin Pixel Transfer State ---*/
   /* Fields are in the order in which they're applied... */

   /** Scale & Bias (index shift, offset) */
   /*@@{*/
   GLfloat RedBias, RedScale;
   GLfloat GreenBias, GreenScale;
   GLfloat BlueBias, BlueScale;
   GLfloat AlphaBias, AlphaScale;
   GLfloat DepthBias, DepthScale;
   GLint IndexShift, IndexOffset;
   /*@@}*/

   /* Pixel Maps */
   /* Note: actual pixel maps are not part of this attrib group */
   GLboolean MapColorFlag;
   GLboolean MapStencilFlag;

   /*--- End Pixel Transfer State ---*/

   /** glPixelZoom */
   GLfloat ZoomX, ZoomY;
};


/**
 * Point attribute group (GL_POINT_BIT).
 */
struct gl_point_attrib
{
   GLboolean SmoothFlag;	/**< True if GL_POINT_SMOOTH is enabled */
   GLfloat Size;		/**< User-specified point size */
   GLfloat Params[3];		/**< GL_EXT_point_parameters */
   GLfloat MinSize, MaxSize;	/**< GL_EXT_point_parameters */
   GLfloat Threshold;		/**< GL_EXT_point_parameters */
   GLboolean _Attenuated;	/**< True if Params != [1, 0, 0] */
   GLboolean PointSprite;	/**< GL_NV/ARB_point_sprite */
   GLboolean CoordReplace[MAX_TEXTURE_COORD_UNITS]; /**< GL_ARB_point_sprite*/
   GLenum SpriteRMode;		/**< GL_NV_point_sprite (only!) */
   GLenum SpriteOrigin;		/**< GL_ARB_point_sprite */
};


/**
 * Polygon attribute group (GL_POLYGON_BIT).
 */
struct gl_polygon_attrib
{
   GLenum FrontFace;		/**< Either GL_CW or GL_CCW */
   GLenum FrontMode;		/**< Either GL_POINT, GL_LINE or GL_FILL */
   GLenum BackMode;		/**< Either GL_POINT, GL_LINE or GL_FILL */
   GLboolean _FrontBit;		/**< 0=GL_CCW, 1=GL_CW */
   GLboolean CullFlag;		/**< Culling on/off flag */
   GLboolean SmoothFlag;	/**< True if GL_POLYGON_SMOOTH is enabled */
   GLboolean StippleFlag;	/**< True if GL_POLYGON_STIPPLE is enabled */
   GLenum CullFaceMode;		/**< Culling mode GL_FRONT or GL_BACK */
   GLfloat OffsetFactor;	/**< Polygon offset factor, from user */
   GLfloat OffsetUnits;		/**< Polygon offset units, from user */
   GLboolean OffsetPoint;	/**< Offset in GL_POINT mode */
   GLboolean OffsetLine;	/**< Offset in GL_LINE mode */
   GLboolean OffsetFill;	/**< Offset in GL_FILL mode */
};


/**
 * Scissor attributes (GL_SCISSOR_BIT).
 */
struct gl_scissor_rect
{
   GLint X, Y;			/**< Lower left corner of box */
   GLsizei Width, Height;	/**< Size of box */
};
struct gl_scissor_attrib
{
   GLbitfield EnableFlags;	/**< Scissor test enabled? */
   struct gl_scissor_rect ScissorArray[MAX_VIEWPORTS];
};


/**
 * Stencil attribute group (GL_STENCIL_BUFFER_BIT).
 *
 * Three sets of stencil data are tracked so that OpenGL 2.0,
 * GL_EXT_stencil_two_side, and GL_ATI_separate_stencil can all be supported
 * simultaneously.  In each of the stencil state arrays, element 0 corresponds
 * to GL_FRONT.  Element 1 corresponds to the OpenGL 2.0 /
 * GL_ATI_separate_stencil GL_BACK state.  Element 2 corresponds to the
 * GL_EXT_stencil_two_side GL_BACK state.
 *
 * The derived value \c _BackFace is either 1 or 2 depending on whether or
 * not GL_STENCIL_TEST_TWO_SIDE_EXT is enabled.
 *
 * The derived value \c _TestTwoSide is set when the front-face and back-face
 * stencil state are different.
 */
struct gl_stencil_attrib
{
   GLboolean Enabled;		/**< Enabled flag */
   GLboolean TestTwoSide;	/**< GL_EXT_stencil_two_side */
   GLubyte ActiveFace;		/**< GL_EXT_stencil_two_side (0 or 2) */
   GLboolean _Enabled;          /**< Enabled and stencil buffer present */
   GLboolean _WriteEnabled;     /**< _Enabled and non-zero writemasks */
   GLboolean _TestTwoSide;
   GLubyte _BackFace;           /**< Current back stencil state (1 or 2) */
   GLenum Function[3];		/**< Stencil function */
   GLenum FailFunc[3];		/**< Fail function */
   GLenum ZPassFunc[3];		/**< Depth buffer pass function */
   GLenum ZFailFunc[3];		/**< Depth buffer fail function */
   GLint Ref[3];		/**< Reference value */
   GLuint ValueMask[3];		/**< Value mask */
   GLuint WriteMask[3];		/**< Write mask */
   GLuint Clear;		/**< Clear value */
};


/**
 * An index for each type of texture object.  These correspond to the GL
 * texture target enums, such as GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP, etc.
 * Note: the order is from highest priority to lowest priority.
 */
typedef enum
{
   TEXTURE_2D_MULTISAMPLE_INDEX,
   TEXTURE_2D_MULTISAMPLE_ARRAY_INDEX,
   TEXTURE_CUBE_ARRAY_INDEX,
   TEXTURE_BUFFER_INDEX,
   TEXTURE_2D_ARRAY_INDEX,
   TEXTURE_1D_ARRAY_INDEX,
   TEXTURE_EXTERNAL_INDEX,
   TEXTURE_CUBE_INDEX,
   TEXTURE_3D_INDEX,
   TEXTURE_RECT_INDEX,
   TEXTURE_2D_INDEX,
   TEXTURE_1D_INDEX,
   NUM_TEXTURE_TARGETS
} gl_texture_index;


/**
 * Bit flags for each type of texture object
 */
/*@@{*/
#define TEXTURE_2D_MULTISAMPLE_BIT (1 << TEXTURE_2D_MULTISAMPLE_INDEX)
#define TEXTURE_2D_MULTISAMPLE_ARRAY_BIT (1 << TEXTURE_2D_MULTISAMPLE_ARRAY_INDEX)
#define TEXTURE_CUBE_ARRAY_BIT (1 << TEXTURE_CUBE_ARRAY_INDEX)
#define TEXTURE_BUFFER_BIT   (1 << TEXTURE_BUFFER_INDEX)
#define TEXTURE_2D_ARRAY_BIT (1 << TEXTURE_2D_ARRAY_INDEX)
#define TEXTURE_1D_ARRAY_BIT (1 << TEXTURE_1D_ARRAY_INDEX)
#define TEXTURE_EXTERNAL_BIT (1 << TEXTURE_EXTERNAL_INDEX)
#define TEXTURE_CUBE_BIT     (1 << TEXTURE_CUBE_INDEX)
#define TEXTURE_3D_BIT       (1 << TEXTURE_3D_INDEX)
#define TEXTURE_RECT_BIT     (1 << TEXTURE_RECT_INDEX)
#define TEXTURE_2D_BIT       (1 << TEXTURE_2D_INDEX)
#define TEXTURE_1D_BIT       (1 << TEXTURE_1D_INDEX)
/*@@}*/


/**
 * Texture image state.  Drivers will typically create a subclass of this
 * with extra fields for memory buffers, etc.
 */
struct gl_texture_image
{
   GLint InternalFormat;	/**< Internal format as given by the user */
   GLenum _BaseFormat;		/**< Either GL_RGB, GL_RGBA, GL_ALPHA,
				 *   GL_LUMINANCE, GL_LUMINANCE_ALPHA,
				 *   GL_INTENSITY, GL_DEPTH_COMPONENT or
				 *   GL_DEPTH_STENCIL_EXT only. Used for
				 *   choosing TexEnv arithmetic.
				 */
   mesa_format TexFormat;         /**< The actual texture memory format */

   GLuint Border;		/**< 0 or 1 */
   GLuint Width;		/**< = 2^WidthLog2 + 2*Border */
   GLuint Height;		/**< = 2^HeightLog2 + 2*Border */
   GLuint Depth;		/**< = 2^DepthLog2 + 2*Border */
   GLuint Width2;		/**< = Width - 2*Border */
   GLuint Height2;		/**< = Height - 2*Border */
   GLuint Depth2;		/**< = Depth - 2*Border */
   GLuint WidthLog2;		/**< = log2(Width2) */
   GLuint HeightLog2;		/**< = log2(Height2) */
   GLuint DepthLog2;		/**< = log2(Depth2) */
   GLuint MaxNumLevels;		/**< = maximum possible number of mipmap
                                       levels, computed from the dimensions */

   struct gl_texture_object *TexObject;  /**< Pointer back to parent object */
   GLuint Level;                /**< Which mipmap level am I? */
   /** Cube map face: index into gl_texture_object::Image[] array */
   GLuint Face;

   /** GL_ARB_texture_multisample */
   GLuint NumSamples;            /**< Sample count, or 0 for non-multisample */
   GLboolean FixedSampleLocations; /**< Same sample locations for all pixels? */
};


/**
 * Indexes for cube map faces.
 */
typedef enum
{
   FACE_POS_X = 0,
   FACE_NEG_X = 1,
   FACE_POS_Y = 2,
   FACE_NEG_Y = 3,
   FACE_POS_Z = 4,
   FACE_NEG_Z = 5,
   MAX_FACES = 6
} gl_face_index;


/**
 * Sampler object state.  These objects are new with GL_ARB_sampler_objects
 * and OpenGL 3.3.  Legacy texture objects also contain a sampler object.
 */
struct gl_sampler_object
{
   GLuint Name;
   GLint RefCount;
   GLchar *Label;               /**< GL_KHR_debug */

   GLenum WrapS;		/**< S-axis texture image wrap mode */
   GLenum WrapT;		/**< T-axis texture image wrap mode */
   GLenum WrapR;		/**< R-axis texture image wrap mode */
   GLenum MinFilter;		/**< minification filter */
   GLenum MagFilter;		/**< magnification filter */
   union gl_color_union BorderColor;  /**< Interpreted according to texture format */
   GLfloat MinLod;		/**< min lambda, OpenGL 1.2 */
   GLfloat MaxLod;		/**< max lambda, OpenGL 1.2 */
   GLfloat LodBias;		/**< OpenGL 1.4 */
   GLfloat MaxAnisotropy;	/**< GL_EXT_texture_filter_anisotropic */
   GLenum CompareMode;		/**< GL_ARB_shadow */
   GLenum CompareFunc;		/**< GL_ARB_shadow */
   GLenum sRGBDecode;           /**< GL_DECODE_EXT or GL_SKIP_DECODE_EXT */
   GLboolean CubeMapSeamless;   /**< GL_AMD_seamless_cubemap_per_texture */
};


/**
 * Texture object state.  Contains the array of mipmap images, border color,
 * wrap modes, filter modes, and shadow/texcompare state.
 */
struct gl_texture_object
{
   mtx_t Mutex;      /**< for thread safety */
   GLint RefCount;             /**< reference count */
   GLuint Name;                /**< the user-visible texture object ID */
   GLchar *Label;               /**< GL_KHR_debug */
   GLenum Target;              /**< GL_TEXTURE_1D, GL_TEXTURE_2D, etc. */
   gl_texture_index TargetIndex; /**< The gl_texture_unit::CurrentTex index.
                                      Only valid when Target is valid. */

   struct gl_sampler_object Sampler;

   GLenum DepthMode;           /**< GL_ARB_depth_texture */
   bool StencilSampling;       /**< Should we sample stencil instead of depth? */

   GLfloat Priority;           /**< in [0,1] */
   GLint BaseLevel;            /**< min mipmap level, OpenGL 1.2 */
   GLint MaxLevel;             /**< max mipmap level, OpenGL 1.2 */
   GLint ImmutableLevels;      /**< ES 3.0 / ARB_texture_view */
   GLint _MaxLevel;            /**< actual max mipmap level (q in the spec) */
   GLfloat _MaxLambda;         /**< = _MaxLevel - BaseLevel (q - p in spec) */
   GLint CropRect[4];          /**< GL_OES_draw_texture */
   GLenum Swizzle[4];          /**< GL_EXT_texture_swizzle */
   GLuint _Swizzle;            /**< same as Swizzle, but SWIZZLE_* format */
   GLboolean GenerateMipmap;   /**< GL_SGIS_generate_mipmap */
   GLboolean _BaseComplete;    /**< Is the base texture level valid? */
   GLboolean _MipmapComplete;  /**< Is the whole mipmap valid? */
   GLboolean _IsIntegerFormat; /**< Does the texture store integer values? */
   GLboolean _RenderToTexture; /**< Any rendering to this texture? */
   GLboolean Purgeable;        /**< Is the buffer purgeable under memory
                                    pressure? */
   GLboolean Immutable;        /**< GL_ARB_texture_storage */

   GLuint MinLevel;            /**< GL_ARB_texture_view */
   GLuint MinLayer;            /**< GL_ARB_texture_view */
   GLuint NumLevels;           /**< GL_ARB_texture_view */
   GLuint NumLayers;           /**< GL_ARB_texture_view */

   /** Actual texture images, indexed by [cube face] and [mipmap level] */
   struct gl_texture_image *Image[MAX_FACES][MAX_TEXTURE_LEVELS];

   /** GL_ARB_texture_buffer_object */
   struct gl_buffer_object *BufferObject;
   GLenum BufferObjectFormat;
   /** Equivalent Mesa format for BufferObjectFormat. */
   mesa_format _BufferObjectFormat;
   /** GL_ARB_texture_buffer_range */
   GLintptr BufferOffset;
   GLsizeiptr BufferSize; /**< if this is -1, use BufferObject->Size instead */

   /** GL_OES_EGL_image_external */
   GLint RequiredTextureImageUnits;

   /** GL_ARB_shader_image_load_store */
   GLenum ImageFormatCompatibilityType;
};


/** Up to four combiner sources are possible with GL_NV_texture_env_combine4 */
#define MAX_COMBINER_TERMS 4


/**
 * Texture combine environment state.
 */
struct gl_tex_env_combine_state
{
   GLenum ModeRGB;       /**< GL_REPLACE, GL_DECAL, GL_ADD, etc. */
   GLenum ModeA;         /**< GL_REPLACE, GL_DECAL, GL_ADD, etc. */
   /** Source terms: GL_PRIMARY_COLOR, GL_TEXTURE, etc */
   GLenum SourceRGB[MAX_COMBINER_TERMS];
   GLenum SourceA[MAX_COMBINER_TERMS];
   /** Source operands: GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, etc */
   GLenum OperandRGB[MAX_COMBINER_TERMS];
   GLenum OperandA[MAX_COMBINER_TERMS];
   GLuint ScaleShiftRGB; /**< 0, 1 or 2 */
   GLuint ScaleShiftA;   /**< 0, 1 or 2 */
   GLuint _NumArgsRGB;   /**< Number of inputs used for the RGB combiner */
   GLuint _NumArgsA;     /**< Number of inputs used for the A combiner */
};


/**
 * TexGenEnabled flags.
 */
/*@@{*/
#define S_BIT 1
#define T_BIT 2
#define R_BIT 4
#define Q_BIT 8
#define STR_BITS (S_BIT | T_BIT | R_BIT)
/*@@}*/


/**
 * Bit flag versions of the corresponding GL_ constants.
 */
/*@@{*/
#define TEXGEN_SPHERE_MAP        0x1
#define TEXGEN_OBJ_LINEAR        0x2
#define TEXGEN_EYE_LINEAR        0x4
#define TEXGEN_REFLECTION_MAP_NV 0x8
#define TEXGEN_NORMAL_MAP_NV     0x10

#define TEXGEN_NEED_NORMALS      (TEXGEN_SPHERE_MAP        | \
				  TEXGEN_REFLECTION_MAP_NV | \
				  TEXGEN_NORMAL_MAP_NV)
#define TEXGEN_NEED_EYE_COORD    (TEXGEN_SPHERE_MAP        | \
				  TEXGEN_REFLECTION_MAP_NV | \
				  TEXGEN_NORMAL_MAP_NV     | \
				  TEXGEN_EYE_LINEAR)
/*@@}*/



/** Tex-gen enabled for texture unit? */
#define ENABLE_TEXGEN(unit) (1 << (unit))

/** Non-identity texture matrix for texture unit? */
#define ENABLE_TEXMAT(unit) (1 << (unit))


/**
 * Texture coord generation state.
 */
struct gl_texgen
{
   GLenum Mode;         /**< GL_EYE_LINEAR, GL_SPHERE_MAP, etc */
   GLbitfield _ModeBit; /**< TEXGEN_x bit corresponding to Mode */
   GLfloat ObjectPlane[4];
   GLfloat EyePlane[4];
};


/**
 * Texture unit state.  Contains enable flags, texture environment/function/
 * combiners, texgen state, and pointers to current texture objects.
 */
struct gl_texture_unit
{
   GLbitfield Enabled;          /**< bitmask of TEXTURE_*_BIT flags */

   GLenum EnvMode;              /**< GL_MODULATE, GL_DECAL, GL_BLEND, etc. */
   GLclampf EnvColor[4];
   GLfloat EnvColorUnclamped[4];

   struct gl_texgen GenS;
   struct gl_texgen GenT;
   struct gl_texgen GenR;
   struct gl_texgen GenQ;
   GLbitfield TexGenEnabled;	/**< Bitwise-OR of [STRQ]_BIT values */
   GLbitfield _GenFlags;	/**< Bitwise-OR of Gen[STRQ]._ModeBit */

   GLfloat LodBias;		/**< for biasing mipmap levels */
   GLenum BumpTarget;
   GLfloat RotMatrix[4]; /* 2x2 matrix */

   /** Current sampler object (GL_ARB_sampler_objects) */
   struct gl_sampler_object *Sampler;

   /** 
    * \name GL_EXT_texture_env_combine 
    */
   struct gl_tex_env_combine_state Combine;

   /**
    * Derived state based on \c EnvMode and the \c BaseFormat of the
    * currently enabled texture.
    */
   struct gl_tex_env_combine_state _EnvMode;

   /**
    * Currently enabled combiner state.  This will point to either
    * \c Combine or \c _EnvMode.
    */
   struct gl_tex_env_combine_state *_CurrentCombine;

   /** Current texture object pointers */
   struct gl_texture_object *CurrentTex[NUM_TEXTURE_TARGETS];

   /** Points to highest priority, complete and enabled texture object */
   struct gl_texture_object *_Current;

   /** Texture targets that have a non-default texture bound */
   GLbitfield _BoundTextures;
};


/**
 * Texture attribute group (GL_TEXTURE_BIT).
 */
struct gl_texture_attrib
{
   GLuint CurrentUnit;   /**< GL_ACTIVE_TEXTURE */
   struct gl_texture_unit Unit[MAX_COMBINED_TEXTURE_IMAGE_UNITS];

   struct gl_texture_object *ProxyTex[NUM_TEXTURE_TARGETS];

   /** GL_ARB_texture_buffer_object */
   struct gl_buffer_object *BufferObject;

   /** GL_ARB_seamless_cubemap */
   GLboolean CubeMapSeamless;

   /** Texture coord units/sets used for fragment texturing */
   GLbitfield _EnabledCoordUnits;

   /** Texture coord units that have texgen enabled */
   GLbitfield _TexGenEnabled;

   /** Texture coord units that have non-identity matrices */
   GLbitfield _TexMatEnabled;

   /** Bitwise-OR of all Texture.Unit[i]._GenFlags */
   GLbitfield _GenFlags;

   /** Largest index of a texture unit with _Current != NULL. */
   GLint _MaxEnabledTexImageUnit;

   /** Largest index + 1 of texture units that have had any CurrentTex set. */
   GLint NumCurrentTexUsed;
};


/**
 * Data structure representing a single clip plane (e.g. one of the elements
 * of the ctx->Transform.EyeUserPlane or ctx->Transform._ClipUserPlane array).
 */
typedef GLfloat gl_clip_plane[4];


/**
 * Transformation attribute group (GL_TRANSFORM_BIT).
 */
struct gl_transform_attrib
{
   GLenum MatrixMode;				/**< Matrix mode */
   gl_clip_plane EyeUserPlane[MAX_CLIP_PLANES];	/**< User clip planes */
   gl_clip_plane _ClipUserPlane[MAX_CLIP_PLANES]; /**< derived */
   GLbitfield ClipPlanesEnabled;                /**< on/off bitmask */
   GLboolean Normalize;				/**< Normalize all normals? */
   GLboolean RescaleNormals;			/**< GL_EXT_rescale_normal */
   GLboolean RasterPositionUnclipped;           /**< GL_IBM_rasterpos_clip */
   GLboolean DepthClamp;			/**< GL_ARB_depth_clamp */
};


/**
 * Viewport attribute group (GL_VIEWPORT_BIT).
 */
struct gl_viewport_attrib
{
   GLfloat X, Y;		/**< position */
   GLfloat Width, Height;	/**< size */
   GLdouble Near, Far;		/**< Depth buffer range */
   GLmatrix _WindowMap;		/**< Mapping transformation as a matrix. */
};


typedef enum {
   MAP_USER,
   MAP_INTERNAL,

   MAP_COUNT
} gl_map_buffer_index;


/**
 * Fields describing a mapped buffer range.
 */
struct gl_buffer_mapping {
   GLbitfield AccessFlags; /**< Mask of GL_MAP_x_BIT flags */
   GLvoid *Pointer;     /**< User-space address of mapping */
   GLintptr Offset;     /**< Mapped offset */
   GLsizeiptr Length;   /**< Mapped length */
};


/**
 * GL_ARB_vertex/pixel_buffer_object buffer object
 */
struct gl_buffer_object
{
   mtx_t Mutex;
   GLint RefCount;
   GLuint Name;
   GLchar *Label;       /**< GL_KHR_debug */
   GLenum Usage;        /**< GL_STREAM_DRAW_ARB, GL_STREAM_READ_ARB, etc. */
   GLbitfield StorageFlags; /**< GL_MAP_PERSISTENT_BIT, etc. */
   GLsizeiptrARB Size;  /**< Size of buffer storage in bytes */
   GLubyte *Data;       /**< Location of storage either in RAM or VRAM. */
   GLboolean DeletePending;   /**< true if buffer object is removed from the hash */
   GLboolean Written;   /**< Ever written to? (for debugging) */
   GLboolean Purgeable; /**< Is the buffer purgeable under memory pressure? */
   GLboolean Immutable; /**< GL_ARB_buffer_storage */

   struct gl_buffer_mapping Mappings[MAP_COUNT];
};


/**
 * Client pixel packing/unpacking attributes
 */
struct gl_pixelstore_attrib
{
   GLint Alignment;
   GLint RowLength;
   GLint SkipPixels;
   GLint SkipRows;
   GLint ImageHeight;
   GLint SkipImages;
   GLboolean SwapBytes;
   GLboolean LsbFirst;
   GLboolean Invert;        /**< GL_MESA_pack_invert */
   struct gl_buffer_object *BufferObj; /**< GL_ARB_pixel_buffer_object */
};


/**
 * Client vertex array attributes
 */
struct gl_client_array
{
   GLint Size;                  /**< components per element (1,2,3,4) */
   GLenum Type;                 /**< datatype: GL_FLOAT, GL_INT, etc */
   GLenum Format;               /**< default: GL_RGBA, but may be GL_BGRA */
   GLsizei Stride;		/**< user-specified stride */
   GLsizei StrideB;		/**< actual stride in bytes */
   const GLubyte *Ptr;          /**< Points to array data */
   GLboolean Enabled;		/**< Enabled flag is a boolean */
   GLboolean Normalized;        /**< GL_ARB_vertex_program */
   GLboolean Integer;           /**< Integer-valued? */
   GLuint InstanceDivisor;      /**< GL_ARB_instanced_arrays */
   GLuint _ElementSize;         /**< size of each element in bytes */

   struct gl_buffer_object *BufferObj;/**< GL_ARB_vertex_buffer_object */
   GLuint _MaxElement;          /**< max element index into array buffer + 1 */
};


/**
 * Vertex attribute array as seen by the client.
 *
 * Contains the size, type, format and normalization flag,
 * along with the index of a vertex buffer binding point.
 *
 * Note that the Stride field corresponds to VERTEX_ATTRIB_ARRAY_STRIDE
 * and is only present for backwards compatibility reasons.
 * Rendering always uses VERTEX_BINDING_STRIDE.
 * The gl*Pointer() functions will set VERTEX_ATTRIB_ARRAY_STRIDE
 * and VERTEX_BINDING_STRIDE to the same value, while
 * glBindVertexBuffer() will only set VERTEX_BINDING_STRIDE.
 */
struct gl_vertex_attrib_array
{
   GLint Size;              /**< Components per element (1,2,3,4) */
   GLenum Type;             /**< Datatype: GL_FLOAT, GL_INT, etc */
   GLenum Format;           /**< Default: GL_RGBA, but may be GL_BGRA */
   GLsizei Stride;          /**< Stride as specified with gl*Pointer() */
   const GLubyte *Ptr;      /**< Points to client array data. Not used when a VBO is bound */
   GLintptr RelativeOffset; /**< Offset of the first element relative to the binding offset */
   GLboolean Enabled;       /**< Whether the array is enabled */
   GLboolean Normalized;    /**< Fixed-point values are normalized when converted to floats */
   GLboolean Integer;       /**< Fixed-point values are not converted to floats */
   GLuint _ElementSize;     /**< Size of each element in bytes */
   GLuint VertexBinding;    /**< Vertex buffer binding */
};


/**
 * This describes the buffer object used for a vertex array (or
 * multiple vertex arrays).  If BufferObj points to the default/null
 * buffer object, then the vertex array lives in user memory and not a VBO.
 */
struct gl_vertex_buffer_binding
{
   GLintptr Offset;                    /**< User-specified offset */
   GLsizei Stride;                     /**< User-specified stride */
   GLuint InstanceDivisor;             /**< GL_ARB_instanced_arrays */
   struct gl_buffer_object *BufferObj; /**< GL_ARB_vertex_buffer_object */
   GLbitfield64 _BoundArrays;          /**< Arrays bound to this binding point */
};


/**
 * A representation of "Vertex Array Objects" (VAOs) from OpenGL 3.1+,
 * GL_ARB_vertex_array_object, or the original GL_APPLE_vertex_array_object
 * extension.
 */
struct gl_vertex_array_object
{
   /** Name of the VAO as received from glGenVertexArray. */
   GLuint Name;
   GLchar *Label;       /**< GL_KHR_debug */

   GLint RefCount;
   mtx_t Mutex;

   /**
    * Does the VAO use ARB semantics or Apple semantics?
    *
    * There are several ways in which ARB_vertex_array_object and
    * APPLE_vertex_array_object VAOs have differing semantics.  At the very
    * least,
    *
    *     - ARB VAOs require that all array data be sourced from vertex buffer
    *       objects, but Apple VAOs do not.
    *
    *     - ARB VAOs require that names come from GenVertexArrays.
    *
    * This flag notes which behavior governs this VAO.
    */
   GLboolean ARBsemantics;

   /**
    * Has this array object been bound?
    */
   GLboolean EverBound;

   /**
    * Derived vertex attribute arrays
    *
    * This is a legacy data structure created from gl_vertex_attrib_array and
    * gl_vertex_buffer_binding, for compatibility with existing driver code.
    */
   struct gl_client_array _VertexAttrib[VERT_ATTRIB_MAX];

   /** Vertex attribute arrays */
   struct gl_vertex_attrib_array VertexAttrib[VERT_ATTRIB_MAX];

   /** Vertex buffer bindings */
   struct gl_vertex_buffer_binding VertexBinding[VERT_ATTRIB_MAX];

   /** Mask of VERT_BIT_* values indicating which arrays are enabled */
   GLbitfield64 _Enabled;

   /** Mask of VERT_BIT_* values indicating changed/dirty arrays */
   GLbitfield64 NewArrays;

   /**
    * Min of all enabled arrays' _MaxElement.  When arrays reside inside VBOs
    * we can determine the max legal (in bounds) glDrawElements array index.
    */
   GLuint _MaxElement;

   /** The index buffer (also known as the element array buffer in OpenGL). */
   struct gl_buffer_object *IndexBufferObj;
};


/**
 * Vertex array state
 */
struct gl_array_attrib
{
   /** Currently bound array object. See _mesa_BindVertexArrayAPPLE() */
   struct gl_vertex_array_object *VAO;

   /** The default vertex array object */
   struct gl_vertex_array_object *DefaultVAO;

   /** Array objects (GL_ARB/APPLE_vertex_array_object) */
   struct _mesa_HashTable *Objects;

   GLint ActiveTexture;		/**< Client Active Texture */
   GLuint LockFirst;            /**< GL_EXT_compiled_vertex_array */
   GLuint LockCount;            /**< GL_EXT_compiled_vertex_array */

   /**
    * \name Primitive restart controls
    *
    * Primitive restart is enabled if either \c PrimitiveRestart or
    * \c PrimitiveRestartFixedIndex is set.
    */
   /*@@{*/
   GLboolean PrimitiveRestart;
   GLboolean PrimitiveRestartFixedIndex;
   GLboolean _PrimitiveRestart;
   GLuint RestartIndex;
   /*@@}*/

   /* GL_ARB_vertex_buffer_object */
   struct gl_buffer_object *ArrayBufferObj;

   /**
    * Vertex arrays as consumed by a driver.
    * The array pointer is set up only by the VBO module.
    */
   const struct gl_client_array **_DrawArrays; /**< 0..VERT_ATTRIB_MAX-1 */
};


/**
 * Feedback buffer state
 */
struct gl_feedback
{
   GLenum Type;
   GLbitfield _Mask;    /**< FB_* bits */
   GLfloat *Buffer;
   GLuint BufferSize;
   GLuint Count;
};


/**
 * Selection buffer state
 */
struct gl_selection
{
   GLuint *Buffer;	/**< selection buffer */
   GLuint BufferSize;	/**< size of the selection buffer */
   GLuint BufferCount;	/**< number of values in the selection buffer */
   GLuint Hits;		/**< number of records in the selection buffer */
   GLuint NameStackDepth; /**< name stack depth */
   GLuint NameStack[MAX_NAME_STACK_DEPTH]; /**< name stack */
   GLboolean HitFlag;	/**< hit flag */
   GLfloat HitMinZ;	/**< minimum hit depth */
   GLfloat HitMaxZ;	/**< maximum hit depth */
};


/**
 * 1-D Evaluator control points
 */
struct gl_1d_map
{
   GLuint Order;	/**< Number of control points */
   GLfloat u1, u2, du;	/**< u1, u2, 1.0/(u2-u1) */
   GLfloat *Points;	/**< Points to contiguous control points */
};


/**
 * 2-D Evaluator control points
 */
struct gl_2d_map
{
   GLuint Uorder;		/**< Number of control points in U dimension */
   GLuint Vorder;		/**< Number of control points in V dimension */
   GLfloat u1, u2, du;
   GLfloat v1, v2, dv;
   GLfloat *Points;		/**< Points to contiguous control points */
};


/**
 * All evaluator control point state
 */
struct gl_evaluators
{
   /** 
    * \name 1-D maps
    */
   /*@@{*/
   struct gl_1d_map Map1Vertex3;
   struct gl_1d_map Map1Vertex4;
   struct gl_1d_map Map1Index;
   struct gl_1d_map Map1Color4;
   struct gl_1d_map Map1Normal;
   struct gl_1d_map Map1Texture1;
   struct gl_1d_map Map1Texture2;
   struct gl_1d_map Map1Texture3;
   struct gl_1d_map Map1Texture4;
   /*@@}*/

   /** 
    * \name 2-D maps 
    */
   /*@@{*/
   struct gl_2d_map Map2Vertex3;
   struct gl_2d_map Map2Vertex4;
   struct gl_2d_map Map2Index;
   struct gl_2d_map Map2Color4;
   struct gl_2d_map Map2Normal;
   struct gl_2d_map Map2Texture1;
   struct gl_2d_map Map2Texture2;
   struct gl_2d_map Map2Texture3;
   struct gl_2d_map Map2Texture4;
   /*@@}*/
};


struct gl_transform_feedback_varying_info
{
   char *Name;
   GLenum Type;
   GLint Size;
};


/**
 * Per-output info vertex shaders for transform feedback.
 */
struct gl_transform_feedback_output
{
   unsigned OutputRegister;
   unsigned OutputBuffer;
   unsigned NumComponents;

   /** offset (in DWORDs) of this output within the interleaved structure */
   unsigned DstOffset;

   /**
    * Offset into the output register of the data to output.  For example,
    * if NumComponents is 2 and ComponentOffset is 1, then the data to
    * offset is in the y and z components of the output register.
    */
   unsigned ComponentOffset;
};


/** Post-link transform feedback info. */
struct gl_transform_feedback_info
{
   unsigned NumOutputs;

   /**
    * Number of transform feedback buffers in use by this program.
    */
   unsigned NumBuffers;

   struct gl_transform_feedback_output *Outputs;

   /** Transform feedback varyings used for the linking of this shader program.
    *
    * Use for glGetTransformFeedbackVarying().
    */
   struct gl_transform_feedback_varying_info *Varyings;
   GLint NumVarying;

   /**
    * Total number of components stored in each buffer.  This may be used by
    * hardware back-ends to determine the correct stride when interleaving
    * multiple transform feedback outputs in the same buffer.
    */
   unsigned BufferStride[MAX_FEEDBACK_BUFFERS];
};


/**
 * Transform feedback object state
 */
struct gl_transform_feedback_object
{
   GLuint Name;  /**< AKA the object ID */
   GLchar *Label;     /**< GL_KHR_debug */
   GLint RefCount;
   GLboolean Active;  /**< Is transform feedback enabled? */
   GLboolean Paused;  /**< Is transform feedback paused? */
   GLboolean EndedAnytime; /**< Has EndTransformFeedback been called
                                at least once? */
   GLboolean EverBound; /**< Has this object been bound? */

   /**
    * The shader program active when BeginTransformFeedback() was called.
    * When active and unpaused, this equals ctx->Shader.CurrentProgram[stage],
    * where stage is the pipeline stage that is the source of data for
    * transform feedback.
    */
   struct gl_shader_program *shader_program;

   /**
    * GLES: if Active is true, remaining number of primitives which can be
    * rendered without overflow.  This is necessary to track because GLES
    * requires us to generate INVALID_OPERATION if a call to glDrawArrays or
    * glDrawArraysInstanced would overflow transform feedback buffers.
    * Undefined if Active is false.
    *
    * Not tracked for desktop GL since it's unnecessary.
    */
   unsigned GlesRemainingPrims;

   /** The feedback buffers */
   GLuint BufferNames[MAX_FEEDBACK_BUFFERS];
   struct gl_buffer_object *Buffers[MAX_FEEDBACK_BUFFERS];

   /** Start of feedback data in dest buffer */
   GLintptr Offset[MAX_FEEDBACK_BUFFERS];

   /**
    * Max data to put into dest buffer (in bytes).  Computed based on
    * RequestedSize and the actual size of the buffer.
    */
   GLsizeiptr Size[MAX_FEEDBACK_BUFFERS];

   /**
    * Size that was specified when the buffer was bound.  If the buffer was
    * bound with glBindBufferBase() or glBindBufferOffsetEXT(), this value is
    * zero.
    */
   GLsizeiptr RequestedSize[MAX_FEEDBACK_BUFFERS];
};


/**
 * Context state for transform feedback.
 */
struct gl_transform_feedback_state
{
   GLenum Mode;       /**< GL_POINTS, GL_LINES or GL_TRIANGLES */

   /** The general binding point (GL_TRANSFORM_FEEDBACK_BUFFER) */
   struct gl_buffer_object *CurrentBuffer;

   /** The table of all transform feedback objects */
   struct _mesa_HashTable *Objects;

   /** The current xform-fb object (GL_TRANSFORM_FEEDBACK_BINDING) */
   struct gl_transform_feedback_object *CurrentObject;

   /** The default xform-fb object (Name==0) */
   struct gl_transform_feedback_object *DefaultObject;
};


/**
 * A "performance monitor" as described in AMD_performance_monitor.
 */
struct gl_perf_monitor_object
{
   GLuint Name;

   /** True if the monitor is currently active (Begin called but not End). */
   GLboolean Active;

   /**
    * True if the monitor has ended.
    *
    * This is distinct from !Active because it may never have began.
    */
   GLboolean Ended;

   /**
    * A list of groups with currently active counters.
    *
    * ActiveGroups[g] == n if there are n counters active from group 'g'.
    */
   unsigned *ActiveGroups;

   /**
    * An array of bitsets, subscripted by group ID, then indexed by counter ID.
    *
    * Checking whether counter 'c' in group 'g' is active can be done via:
    *
    *    BITSET_TEST(ActiveCounters[g], c)
    */
   GLuint **ActiveCounters;
};


union gl_perf_monitor_counter_value
{
   float f;
   uint64_t u64;
   uint32_t u32;
};


struct gl_perf_monitor_counter
{
   /** Human readable name for the counter. */
   const char *Name;

   /**
    * Data type of the counter.  Valid values are FLOAT, UNSIGNED_INT,
    * UNSIGNED_INT64_AMD, and PERCENTAGE_AMD.
    */
   GLenum Type;

   /** Minimum counter value. */
   union gl_perf_monitor_counter_value Minimum;

   /** Maximum counter value. */
   union gl_perf_monitor_counter_value Maximum;
};


struct gl_perf_monitor_group
{
   /** Human readable name for the group. */
   const char *Name;

   /**
    * Maximum number of counters in this group which can be active at the
    * same time.
    */
   GLuint MaxActiveCounters;

   /** Array of counters within this group. */
   const struct gl_perf_monitor_counter *Counters;
   GLuint NumCounters;
};


/**
 * Context state for AMD_performance_monitor.
 */
struct gl_perf_monitor_state
{
   /** Array of performance monitor groups (indexed by group ID) */
   const struct gl_perf_monitor_group *Groups;
   GLuint NumGroups;

   /** The table of all performance monitors. */
   struct _mesa_HashTable *Monitors;
};


/**
 * Names of the various vertex/fragment program register files, etc.
 *
 * NOTE: first four tokens must fit into 2 bits (see t_vb_arbprogram.c)
 * All values should fit in a 4-bit field.
 *
 * NOTE: PROGRAM_STATE_VAR, PROGRAM_CONSTANT, and PROGRAM_UNIFORM can all be
 * considered to be "uniform" variables since they can only be set outside
 * glBegin/End.  They're also all stored in the same Parameters array.
 */
typedef enum
{
   PROGRAM_TEMPORARY,   /**< machine->Temporary[] */
   PROGRAM_ARRAY,       /**< Arrays & Matrixes */
   PROGRAM_INPUT,       /**< machine->Inputs[] */
   PROGRAM_OUTPUT,      /**< machine->Outputs[] */
   PROGRAM_STATE_VAR,   /**< gl_program->Parameters[] */
   PROGRAM_CONSTANT,    /**< gl_program->Parameters[] */
   PROGRAM_UNIFORM,     /**< gl_program->Parameters[] */
   PROGRAM_WRITE_ONLY,  /**< A dummy, write-only register */
   PROGRAM_ADDRESS,     /**< machine->AddressReg */
   PROGRAM_SAMPLER,     /**< for shader samplers, compile-time only */
   PROGRAM_SYSTEM_VALUE,/**< InstanceId, PrimitiveID, etc. */
   PROGRAM_UNDEFINED,   /**< Invalid/TBD value */
   PROGRAM_FILE_MAX
} gl_register_file;


/**
 * If the register file is PROGRAM_SYSTEM_VALUE, the register index will be
 * one of these values.
 */
typedef enum
{
   SYSTEM_VALUE_FRONT_FACE,     /**< Fragment shader only (not done yet) */
   SYSTEM_VALUE_VERTEX_ID,      /**< Vertex shader only */
   SYSTEM_VALUE_INSTANCE_ID,    /**< Vertex shader only */
   SYSTEM_VALUE_SAMPLE_ID,      /**< Fragment shader only */
   SYSTEM_VALUE_SAMPLE_POS,     /**< Fragment shader only */
   SYSTEM_VALUE_SAMPLE_MASK_IN, /**< Fragment shader only */
   SYSTEM_VALUE_INVOCATION_ID,  /**< Geometry shader only */
   SYSTEM_VALUE_MAX             /**< Number of values */
} gl_system_value;


/**
 * The possible interpolation qualifiers that can be applied to a fragment
 * shader input in GLSL.
 *
 * Note: INTERP_QUALIFIER_NONE must be 0 so that memsetting the
 * gl_fragment_program data structure to 0 causes the default behavior.
 */
enum glsl_interp_qualifier
{
   INTERP_QUALIFIER_NONE = 0,
   INTERP_QUALIFIER_SMOOTH,
   INTERP_QUALIFIER_FLAT,
   INTERP_QUALIFIER_NOPERSPECTIVE,
   INTERP_QUALIFIER_COUNT /**< Number of interpolation qualifiers */
};


/**
 * \brief Layout qualifiers for gl_FragDepth.
 *
 * Extension AMD_conservative_depth allows gl_FragDepth to be redeclared with
 * a layout qualifier.
 *
 * \see enum ir_depth_layout
 */
enum gl_frag_depth_layout
{
   FRAG_DEPTH_LAYOUT_NONE, /**< No layout is specified. */
   FRAG_DEPTH_LAYOUT_ANY,
   FRAG_DEPTH_LAYOUT_GREATER,
   FRAG_DEPTH_LAYOUT_LESS,
   FRAG_DEPTH_LAYOUT_UNCHANGED
};


/**
 * Base class for any kind of program object
 */
struct gl_program
{
   GLuint Id;
   GLubyte *String;  /**< Null-terminated program text */
   GLint RefCount;
   GLenum Target;    /**< GL_VERTEX/FRAGMENT_PROGRAM_ARB, GL_GEOMETRY_PROGRAM_NV */
   GLenum Format;    /**< String encoding format */

   struct prog_instruction *Instructions;

   GLbitfield64 InputsRead;     /**< Bitmask of which input regs are read */
   GLbitfield64 OutputsWritten; /**< Bitmask of which output regs are written */
   GLbitfield SystemValuesRead;   /**< Bitmask of SYSTEM_VALUE_x inputs used */
   GLbitfield InputFlags[MAX_PROGRAM_INPUTS];   /**< PROG_PARAM_BIT_x flags */
   GLbitfield OutputFlags[MAX_PROGRAM_OUTPUTS]; /**< PROG_PARAM_BIT_x flags */
   GLbitfield TexturesUsed[MAX_COMBINED_TEXTURE_IMAGE_UNITS];  /**< TEXTURE_x_BIT bitmask */
   GLbitfield SamplersUsed;   /**< Bitfield of which samplers are used */
   GLbitfield ShadowSamplers; /**< Texture units used for shadow sampling. */

   GLboolean UsesGather; /**< Does this program use gather4 at all? */

   /**
    * For vertex and geometry shaders, true if the program uses the
    * gl_ClipDistance output.  Ignored for fragment shaders.
    */
   GLboolean UsesClipDistanceOut;


   /** Named parameters, constants, etc. from program text */
   struct gl_program_parameter_list *Parameters;

   /**
    * Local parameters used by the program.
    *
    * It's dynamically allocated because it is rarely used (just
    * assembly-style programs), and MAX_PROGRAM_LOCAL_PARAMS entries once it's
    * allocated.
    */
   GLfloat (*LocalParams)[4];

   /** Map from sampler unit to texture unit (set by glUniform1i()) */
   GLubyte SamplerUnits[MAX_SAMPLERS];

   /** Bitmask of which register files are read/written with indirect
    * addressing.  Mask of (1 << PROGRAM_x) bits.
    */
   GLbitfield IndirectRegisterFiles;

   /** Logical counts */
   /*@@{*/
   GLuint NumInstructions;
   GLuint NumTemporaries;
   GLuint NumParameters;
   GLuint NumAttributes;
   GLuint NumAddressRegs;
   GLuint NumAluInstructions;
   GLuint NumTexInstructions;
   GLuint NumTexIndirections;
   /*@@}*/
   /** Native, actual h/w counts */
   /*@@{*/
   GLuint NumNativeInstructions;
   GLuint NumNativeTemporaries;
   GLuint NumNativeParameters;
   GLuint NumNativeAttributes;
   GLuint NumNativeAddressRegs;
   GLuint NumNativeAluInstructions;
   GLuint NumNativeTexInstructions;
   GLuint NumNativeTexIndirections;
   /*@@}*/
};


/** Vertex program object */
struct gl_vertex_program
{
   struct gl_program Base;   /**< base class */
   GLboolean IsPositionInvariant;
};


/** Geometry program object */
struct gl_geometry_program
{
   struct gl_program Base;   /**< base class */

   GLint VerticesIn;
   GLint VerticesOut;
   GLint Invocations;
   GLenum InputType;  /**< GL_POINTS, GL_LINES, GL_LINES_ADJACENCY_ARB,
                           GL_TRIANGLES, or GL_TRIANGLES_ADJACENCY_ARB */
   GLenum OutputType; /**< GL_POINTS, GL_LINE_STRIP or GL_TRIANGLE_STRIP */
   GLboolean UsesEndPrimitive;
};


/** Fragment program object */
struct gl_fragment_program
{
   struct gl_program Base;   /**< base class */
   GLboolean UsesKill;          /**< shader uses KIL instruction */
   GLboolean UsesDFdy;          /**< shader uses DDY instruction */
   GLboolean OriginUpperLeft;
   GLboolean PixelCenterInteger;
   enum gl_frag_depth_layout FragDepthLayout;

   /**
    * GLSL interpolation qualifier associated with each fragment shader input.
    * For inputs that do not have an interpolation qualifier specified in
    * GLSL, the value is INTERP_QUALIFIER_NONE.
    */
   enum glsl_interp_qualifier InterpQualifier[VARYING_SLOT_MAX];

   /**
    * Bitfield indicating, for each fragment shader input, 1 if that input
    * uses centroid interpolation, 0 otherwise.  Unused inputs are 0.
    */
   GLbitfield64 IsCentroid;

   /**
    * Bitfield indicating, for each fragment shader input, 1 if that input
    * uses sample interpolation, 0 otherwise.  Unused inputs are 0.
    */
   GLbitfield64 IsSample;
};


/** Compute program object */
struct gl_compute_program
{
   struct gl_program Base;   /**< base class */

   /**
    * Size specified using local_size_{x,y,z}.
    */
   unsigned LocalSize[3];
};


/**
 * State common to vertex and fragment programs.
 */
struct gl_program_state
{
   GLint ErrorPos;                       /* GL_PROGRAM_ERROR_POSITION_ARB/NV */
   const char *ErrorString;              /* GL_PROGRAM_ERROR_STRING_ARB/NV */
};


/**
 * Context state for vertex programs.
 */
struct gl_vertex_program_state
{
   GLboolean Enabled;            /**< User-set GL_VERTEX_PROGRAM_ARB/NV flag */
   GLboolean _Enabled;           /**< Enabled and _valid_ user program? */
   GLboolean PointSizeEnabled;   /**< GL_VERTEX_PROGRAM_POINT_SIZE_ARB/NV */
   GLboolean TwoSideEnabled;     /**< GL_VERTEX_PROGRAM_TWO_SIDE_ARB/NV */
   /** Computed two sided lighting for fixed function/programs. */
   GLboolean _TwoSideEnabled;
   struct gl_vertex_program *Current;  /**< User-bound vertex program */

   /** Currently enabled and valid vertex program (including internal
    * programs, user-defined vertex programs and GLSL vertex shaders).
    * This is the program we must use when rendering.
    */
   struct gl_vertex_program *_Current;

   GLfloat Parameters[MAX_PROGRAM_ENV_PARAMS][4]; /**< Env params */

   /** Should fixed-function T&L be implemented with a vertex prog? */
   GLboolean _MaintainTnlProgram;

   /** Program to emulate fixed-function T&L (see above) */
   struct gl_vertex_program *_TnlProgram;

   /** Cache of fixed-function programs */
   struct gl_program_cache *Cache;

   GLboolean _Overriden;
};


/**
 * Context state for geometry programs.
 */
struct gl_geometry_program_state
{
   GLboolean Enabled;               /**< GL_ARB_GEOMETRY_SHADER4 */
   GLboolean _Enabled;              /**< Enabled and valid program? */
   struct gl_geometry_program *Current;  /**< user-bound geometry program */

   /** Currently enabled and valid program (including internal programs
    * and compiled shader programs).
    */
   struct gl_geometry_program *_Current;

   GLfloat Parameters[MAX_PROGRAM_ENV_PARAMS][4]; /**< Env params */

   /** Cache of fixed-function programs */
   struct gl_program_cache *Cache;
};

/**
 * Context state for fragment programs.
 */
struct gl_fragment_program_state
{
   GLboolean Enabled;     /**< User-set fragment program enable flag */
   GLboolean _Enabled;    /**< Enabled and _valid_ user program? */
   struct gl_fragment_program *Current;  /**< User-bound fragment program */

   /** Currently enabled and valid fragment program (including internal
    * programs, user-defined fragment programs and GLSL fragment shaders).
    * This is the program we must use when rendering.
    */
   struct gl_fragment_program *_Current;

   GLfloat Parameters[MAX_PROGRAM_ENV_PARAMS][4]; /**< Env params */

   /** Should fixed-function texturing be implemented with a fragment prog? */
   GLboolean _MaintainTexEnvProgram;

   /** Program to emulate fixed-function texture env/combine (see above) */
   struct gl_fragment_program *_TexEnvProgram;

   /** Cache of fixed-function programs */
   struct gl_program_cache *Cache;
};


/**
 * ATI_fragment_shader runtime state
 */
#define ATI_FS_INPUT_PRIMARY 0
#define ATI_FS_INPUT_SECONDARY 1

struct atifs_instruction;
struct atifs_setupinst;

/**
 * ATI fragment shader
 */
struct ati_fragment_shader
{
   GLuint Id;
   GLint RefCount;
   struct atifs_instruction *Instructions[2];
   struct atifs_setupinst *SetupInst[2];
   GLfloat Constants[8][4];
   GLbitfield LocalConstDef;  /**< Indicates which constants have been set */
   GLubyte numArithInstr[2];
   GLubyte regsAssigned[2];
   GLubyte NumPasses;         /**< 1 or 2 */
   GLubyte cur_pass;
   GLubyte last_optype;
   GLboolean interpinp1;
   GLboolean isValid;
   GLuint swizzlerq;
};

/**
 * Context state for GL_ATI_fragment_shader
 */
struct gl_ati_fragment_shader_state
{
   GLboolean Enabled;
   GLboolean _Enabled;                  /**< enabled and valid shader? */
   GLboolean Compiling;
   GLfloat GlobalConstants[8][4];
   struct ati_fragment_shader *Current;
};


/** Set by #pragma directives */
struct gl_sl_pragmas
{
   GLboolean IgnoreOptimize;  /**< ignore #pragma optimize(on/off) ? */
   GLboolean IgnoreDebug;     /**< ignore #pragma debug(on/off) ? */
   GLboolean Optimize;  /**< defaults on */
   GLboolean Debug;     /**< defaults off */
};


/**
 * A GLSL vertex or fragment shader object.
 */
struct gl_shader
{
   /** GL_FRAGMENT_SHADER || GL_VERTEX_SHADER || GL_GEOMETRY_SHADER_ARB.
    * Must be the first field.
    */
   GLenum Type;
   gl_shader_stage Stage;
   GLuint Name;  /**< AKA the handle */
   GLchar *Label;   /**< GL_KHR_debug */
   GLint RefCount;  /**< Reference count */
   GLboolean DeletePending;
   GLboolean CompileStatus;
   const GLchar *Source;  /**< Source code string */
   GLuint SourceChecksum;       /**< for debug/logging purposes */
   struct gl_program *Program;  /**< Post-compile assembly code */
   GLchar *InfoLog;
   struct gl_sl_pragmas Pragmas;

   unsigned Version;       /**< GLSL version used for linking */
   GLboolean IsES;         /**< True if this shader uses GLSL ES */

   /**
    * \name Sampler tracking
    *
    * \note Each of these fields is only set post-linking.
    */
   /*@@{*/
   unsigned num_samplers;	/**< Number of samplers used by this shader. */
   GLbitfield active_samplers;	/**< Bitfield of which samplers are used */
   GLbitfield shadow_samplers;	/**< Samplers used for shadow sampling. */
   /*@@}*/

   /**
    * Map from sampler unit to texture unit (set by glUniform1i())
    *
    * A sampler unit is associated with each sampler uniform by the linker.
    * The sampler unit associated with each uniform is stored in the
    * \c gl_uniform_storage::sampler field.
    */
   GLubyte SamplerUnits[MAX_SAMPLERS];
   /** Which texture target is being sampled (TEXTURE_1D/2D/3D/etc_INDEX) */
   gl_texture_index SamplerTargets[MAX_SAMPLERS];

   /**
    * Number of default uniform block components used by this shader.
    *
    * This field is only set post-linking.
    */
   unsigned num_uniform_components;

   /**
    * Number of combined uniform components used by this shader.
    *
    * This field is only set post-linking.  It is the sum of the uniform block
    * sizes divided by sizeof(float), and num_uniform_compoennts.
    */
   unsigned num_combined_uniform_components;

   /**
    * This shader's uniform block information.
    *
    * These fields are only set post-linking.
    */
   struct gl_uniform_block *UniformBlocks;
   unsigned NumUniformBlocks;

   struct exec_list *ir;
   struct glsl_symbol_table *symbols;

   bool uses_builtin_functions;
   bool uses_gl_fragcoord;
   bool redeclares_gl_fragcoord;
   bool ARB_fragment_coord_conventions_enable;

   /**
    * Fragment shader state from GLSL 1.50 layout qualifiers.
    */
   bool origin_upper_left;
   bool pixel_center_integer;

   /**
    * Geometry shader state from GLSL 1.50 layout qualifiers.
    */
   struct {
      GLint VerticesOut;
      /**
       * 0 - Invocations count not declared in shader, or
       * 1 .. MAX_GEOMETRY_SHADER_INVOCATIONS
       */
      GLint Invocations;
      /**
       * GL_POINTS, GL_LINES, GL_LINES_ADJACENCY, GL_TRIANGLES, or
       * GL_TRIANGLES_ADJACENCY, or PRIM_UNKNOWN if it's not set in this
       * shader.
       */
      GLenum InputType;
       /**
        * GL_POINTS, GL_LINE_STRIP or GL_TRIANGLE_STRIP, or PRIM_UNKNOWN if
        * it's not set in this shader.
        */
      GLenum OutputType;
   } Geom;

   /**
    * Map from image uniform index to image unit (set by glUniform1i())
    *
    * An image uniform index is associated with each image uniform by
    * the linker.  The image index associated with each uniform is
    * stored in the \c gl_uniform_storage::image field.
    */
   GLubyte ImageUnits[MAX_IMAGE_UNIFORMS];

   /**
    * Access qualifier specified in the shader for each image uniform
    * index.  Either \c GL_READ_ONLY, \c GL_WRITE_ONLY or \c
    * GL_READ_WRITE.
    *
    * It may be different, though only more strict than the value of
    * \c gl_image_unit::Access for the corresponding image unit.
    */
   GLenum ImageAccess[MAX_IMAGE_UNIFORMS];

   /**
    * Number of image uniforms defined in the shader.  It specifies
    * the number of valid elements in the \c ImageUnits and \c
    * ImageAccess arrays above.
    */
   GLuint NumImages;

   /**
    * Compute shader state from ARB_compute_shader layout qualifiers.
    */
   struct {
      /**
       * Size specified using local_size_{x,y,z}, or all 0's to indicate that
       * it's not set in this shader.
       */
      unsigned LocalSize[3];
   } Comp;
};


struct gl_uniform_buffer_variable
{
   char *Name;

   /**
    * Name of the uniform as seen by glGetUniformIndices.
    *
    * glGetUniformIndices requires that the block instance index \b not be
    * present in the name of queried uniforms.
    *
    * \note
    * \c gl_uniform_buffer_variable::IndexName and
    * \c gl_uniform_buffer_variable::Name may point to identical storage.
    */
   char *IndexName;

   const struct glsl_type *Type;
   unsigned int Offset;
   GLboolean RowMajor;
};


enum gl_uniform_block_packing
{
   ubo_packing_std140,
   ubo_packing_shared,
   ubo_packing_packed
};


struct gl_uniform_block
{
   /** Declared name of the uniform block */
   char *Name;

   /** Array of supplemental information about UBO ir_variables. */
   struct gl_uniform_buffer_variable *Uniforms;
   GLuint NumUniforms;

   /**
    * Index (GL_UNIFORM_BLOCK_BINDING) into ctx->UniformBufferBindings[] to use
    * with glBindBufferBase to bind a buffer object to this uniform block.  When
    * updated in the program, _NEW_BUFFER_OBJECT will be set.
    */
   GLuint Binding;

   /**
    * Minimum size of a buffer object to back this uniform buffer
    * (GL_UNIFORM_BLOCK_DATA_SIZE).
    */
   GLuint UniformBufferSize;

   /**
    * Layout specified in the shader
    *
    * This isn't accessible through the API, but it is used while
    * cross-validating uniform blocks.
    */
   enum gl_uniform_block_packing _Packing;
};

/**
 * Structure that represents a reference to an atomic buffer from some
 * shader program.
 */
struct gl_active_atomic_buffer
{
   /** Uniform indices of the atomic counters declared within it. */
   GLuint *Uniforms;
   GLuint NumUniforms;

   /** Binding point index associated with it. */
   GLuint Binding;

   /** Minimum reasonable size it is expected to have. */
   GLuint MinimumSize;

   /** Shader stages making use of it. */
   GLboolean StageReferences[MESA_SHADER_STAGES];
};

/**
 * A GLSL program object.
 * Basically a linked collection of vertex and fragment shaders.
 */
struct gl_shader_program
{
   GLenum Type;  /**< Always GL_SHADER_PROGRAM (internal token) */
   GLuint Name;  /**< aka handle or ID */
   GLchar *Label;   /**< GL_KHR_debug */
   GLint RefCount;  /**< Reference count */
   GLboolean DeletePending;

   /**
    * Is the application intending to glGetProgramBinary this program?
    */
   GLboolean BinaryRetreivableHint;

   /**
    * Indicates whether program can be bound for individual pipeline stages
    * using UseProgramStages after it is next linked.
    */
   GLboolean SeparateShader;

   GLuint NumShaders;          /**< number of attached shaders */
   struct gl_shader **Shaders; /**< List of attached the shaders */

   /**
    * User-defined attribute bindings
    *
    * These are set via \c glBindAttribLocation and are used to direct the
    * GLSL linker.  These are \b not the values used in the compiled shader,
    * and they are \b not the values returned by \c glGetAttribLocation.
    */
   struct string_to_uint_map *AttributeBindings;

   /**
    * User-defined fragment data bindings
    *
    * These are set via \c glBindFragDataLocation and are used to direct the
    * GLSL linker.  These are \b not the values used in the compiled shader,
    * and they are \b not the values returned by \c glGetFragDataLocation.
    */
   struct string_to_uint_map *FragDataBindings;
   struct string_to_uint_map *FragDataIndexBindings;

   /**
    * Transform feedback varyings last specified by
    * glTransformFeedbackVaryings().
    *
    * For the current set of transform feeedback varyings used for transform
    * feedback output, see LinkedTransformFeedback.
    */
   struct {
      GLenum BufferMode;
      GLuint NumVarying;
      GLchar **VaryingNames;  /**< Array [NumVarying] of char * */
   } TransformFeedback;

   /** Post-link transform feedback info. */
   struct gl_transform_feedback_info LinkedTransformFeedback;

   /** Post-link gl_FragDepth layout for ARB_conservative_depth. */
   enum gl_frag_depth_layout FragDepthLayout;

   /**
    * Geometry shader state - copied into gl_geometry_program by
    * _mesa_copy_linked_program_data().
    */
   struct {
      GLint VerticesIn;
      GLint VerticesOut;
      /**
       * 1 .. MAX_GEOMETRY_SHADER_INVOCATIONS
       */
      GLint Invocations;
      GLenum InputType;  /**< GL_POINTS, GL_LINES, GL_LINES_ADJACENCY_ARB,
                              GL_TRIANGLES, or GL_TRIANGLES_ADJACENCY_ARB */
      GLenum OutputType; /**< GL_POINTS, GL_LINE_STRIP or GL_TRIANGLE_STRIP */
      /**
       * True if gl_ClipDistance is written to.  Copied into
       * gl_geometry_program by _mesa_copy_linked_program_data().
       */
      GLboolean UsesClipDistance;
      GLuint ClipDistanceArraySize; /**< Size of the gl_ClipDistance array, or
                                         0 if not present. */
      GLboolean UsesEndPrimitive;
   } Geom;

   /** Vertex shader state */
   struct {
      /**
       * True if gl_ClipDistance is written to.  Copied into gl_vertex_program
       * by _mesa_copy_linked_program_data().
       */
      GLboolean UsesClipDistance;
      GLuint ClipDistanceArraySize; /**< Size of the gl_ClipDistance array, or
                                         0 if not present. */
   } Vert;

   /**
    * Compute shader state - copied into gl_compute_program by
    * _mesa_copy_linked_program_data().
    */
   struct {
      /**
       * If this shader contains a compute stage, size specified using
       * local_size_{x,y,z}.  Otherwise undefined.
       */
      unsigned LocalSize[3];
   } Comp;

   /* post-link info: */
   unsigned NumUserUniformStorage;
   struct gl_uniform_storage *UniformStorage;

   /**
    * Mapping from GL uniform locations returned by \c glUniformLocation to
    * UniformStorage entries. Arrays will have multiple contiguous slots
    * in the UniformRemapTable, all pointing to the same UniformStorage entry.
    */
   unsigned NumUniformRemapTable;
   struct gl_uniform_storage **UniformRemapTable;

   /**
    * Size of the gl_ClipDistance array that is output from the last pipeline
    * stage before the fragment shader.
    */
   unsigned LastClipDistanceArraySize;

   struct gl_uniform_block *UniformBlocks;
   unsigned NumUniformBlocks;

   /**
    * Indices into the _LinkedShaders's UniformBlocks[] array for each stage
    * they're used in, or -1.
    *
    * This is used to maintain the Binding values of the stage's UniformBlocks[]
    * and to answer the GL_UNIFORM_BLOCK_REFERENCED_BY_*_SHADER queries.
    */
   int *UniformBlockStageIndex[MESA_SHADER_STAGES];

   /**
    * Map of active uniform names to locations
    *
    * Maps any active uniform that is not an array element to a location.
    * Each active uniform, including individual structure members will appear
    * in this map.  This roughly corresponds to the set of names that would be
    * enumerated by \c glGetActiveUniform.
    */
   struct string_to_uint_map *UniformHash;

   struct gl_active_atomic_buffer *AtomicBuffers;
   unsigned NumAtomicBuffers;

   GLboolean LinkStatus;   /**< GL_LINK_STATUS */
   GLboolean Validated;
   GLboolean _Used;        /**< Ever used for drawing? */
   GLchar *InfoLog;

   unsigned Version;       /**< GLSL version used for linking */
   GLboolean IsES;         /**< True if this program uses GLSL ES */

   /**
    * Per-stage shaders resulting from the first stage of linking.
    *
    * Set of linked shaders for this program.  The array is accessed using the
    * \c MESA_SHADER_* defines.  Entries for non-existent stages will be
    * \c NULL.
    */
   struct gl_shader *_LinkedShaders[MESA_SHADER_STAGES];

   /* True if any of the fragment shaders attached to this program use:
    * #extension ARB_fragment_coord_conventions: enable
    */
   GLboolean ARB_fragment_coord_conventions_enable;
};   


#define GLSL_DUMP      0x1  /**< Dump shaders to stdout */
#define GLSL_LOG       0x2  /**< Write shaders to files */
#define GLSL_OPT       0x4  /**< Force optimizations (override pragmas) */
#define GLSL_NO_OPT    0x8  /**< Force no optimizations (override pragmas) */
#define GLSL_UNIFORMS 0x10  /**< Print glUniform calls */
#define GLSL_NOP_VERT 0x20  /**< Force no-op vertex shaders */
#define GLSL_NOP_FRAG 0x40  /**< Force no-op fragment shaders */
#define GLSL_USE_PROG 0x80  /**< Log glUseProgram calls */
#define GLSL_REPORT_ERRORS 0x100  /**< Print compilation errors */
#define GLSL_DUMP_ON_ERROR 0x200 /**< Dump shaders to stderr on compile error */


/**
 * Context state for GLSL vertex/fragment shaders.
 * Extended to support pipeline object
 */
struct gl_pipeline_object
{
   /** Name of the pipeline object as received from glGenProgramPipelines.
    * It would be 0 for shaders without separate shader objects.
    */
   GLuint Name;

   GLint RefCount;

   mtx_t Mutex;

   /**
    * Programs used for rendering
    *
    * There is a separate program set for each shader stage.
    */
   struct gl_shader_program *CurrentProgram[MESA_SHADER_STAGES];

   struct gl_shader_program *_CurrentFragmentProgram;

   /**
    * Program used by glUniform calls.
    *
    * Explicitly set by \c glUseProgram and \c glActiveProgramEXT.
    */
   struct gl_shader_program *ActiveProgram;

   GLbitfield Flags;                    /**< Mask of GLSL_x flags */

   GLboolean EverBound;                 /**< Has the pipeline object been created */

   GLboolean Validated;                 /**< Pipeline Validation status */

   GLchar *InfoLog;
};

/**
 * Context state for GLSL pipeline shaders.
 */
struct gl_pipeline_shader_state
{
   /** Currently bound pipeline object. See _mesa_BindProgramPipeline() */
   struct gl_pipeline_object *Current;

   /* Default Object to ensure that _Shader is never NULL */
   struct gl_pipeline_object *Default;

   /** Pipeline objects */
   struct _mesa_HashTable *Objects;
};

/**
 * Compiler options for a single GLSL shaders type
 */
struct gl_shader_compiler_options
{
   /** Driver-selectable options: */
   GLboolean EmitCondCodes;             /**< Use condition codes? */
   GLboolean EmitNoLoops;
   GLboolean EmitNoFunctions;
   GLboolean EmitNoCont;                  /**< Emit CONT opcode? */
   GLboolean EmitNoMainReturn;            /**< Emit CONT/RET opcodes? */
   GLboolean EmitNoNoise;                 /**< Emit NOISE opcodes? */
   GLboolean EmitNoPow;                   /**< Emit POW opcodes? */
   GLboolean LowerClipDistance; /**< Lower gl_ClipDistance from float[8] to vec4[2]? */

   /**
    * \name Forms of indirect addressing the driver cannot do.
    */
   /*@@{*/
   GLboolean EmitNoIndirectInput;   /**< No indirect addressing of inputs */
   GLboolean EmitNoIndirectOutput;  /**< No indirect addressing of outputs */
   GLboolean EmitNoIndirectTemp;    /**< No indirect addressing of temps */
   GLboolean EmitNoIndirectUniform; /**< No indirect addressing of constants */
   /*@@}*/

   GLuint MaxIfDepth;               /**< Maximum nested IF blocks */
   GLuint MaxUnrollIterations;

   /**
    * Optimize code for array of structures backends.
    *
    * This is a proxy for:
    *   - preferring DP4 instructions (rather than MUL/MAD) for
    *     matrix * vector operations, such as position transformation.
    */
   GLboolean OptimizeForAOS;

   struct gl_sl_pragmas DefaultPragmas; /**< Default #pragma settings */
};


/**
 * Occlusion/timer query object.
 */
struct gl_query_object
{
   GLenum Target;      /**< The query target, when active */
   GLuint Id;          /**< hash table ID/name */
   GLchar *Label;       /**< GL_KHR_debug */
   GLuint64EXT Result; /**< the counter */
   GLboolean Active;   /**< inside Begin/EndQuery */
   GLboolean Ready;    /**< result is ready? */
   GLboolean EverBound;/**< has query object ever been bound */
};


/**
 * Context state for query objects.
 */
struct gl_query_state
{
   struct _mesa_HashTable *QueryObjects;
   struct gl_query_object *CurrentOcclusionObject; /* GL_ARB_occlusion_query */
   struct gl_query_object *CurrentTimerObject;     /* GL_EXT_timer_query */

   /** GL_NV_conditional_render */
   struct gl_query_object *CondRenderQuery;

   /** GL_EXT_transform_feedback */
   struct gl_query_object *PrimitivesGenerated;
   struct gl_query_object *PrimitivesWritten;

   /** GL_ARB_timer_query */
   struct gl_query_object *TimeElapsed;

   GLenum CondRenderMode;
};


/** Sync object state */
struct gl_sync_object
{
   GLenum Type;               /**< GL_SYNC_FENCE */
   GLuint Name;               /**< Fence name */
   GLchar *Label;             /**< GL_KHR_debug */
   GLint RefCount;            /**< Reference count */
   GLboolean DeletePending;   /**< Object was deleted while there were still
			       * live references (e.g., sync not yet finished)
			       */
   GLenum SyncCondition;
   GLbitfield Flags;          /**< Flags passed to glFenceSync */
   GLuint StatusFlag:1;       /**< Has the sync object been signaled? */
};


/**
 * State which can be shared by multiple contexts:
 */
struct gl_shared_state
{
   mtx_t Mutex;		   /**< for thread safety */
   GLint RefCount;			   /**< Reference count */
   struct _mesa_HashTable *DisplayList;	   /**< Display lists hash table */
   struct _mesa_HashTable *TexObjects;	   /**< Texture objects hash table */

   /** Default texture objects (shared by all texture units) */
   struct gl_texture_object *DefaultTex[NUM_TEXTURE_TARGETS];

   /** Fallback texture used when a bound texture is incomplete */
   struct gl_texture_object *FallbackTex[NUM_TEXTURE_TARGETS];

   /**
    * \name Thread safety and statechange notification for texture
    * objects. 
    *
    * \todo Improve the granularity of locking.
    */
   /*@@{*/
   mtx_t TexMutex;		/**< texobj thread safety */
   GLuint TextureStateStamp;	        /**< state notification for shared tex */
   /*@@}*/

   /** Default buffer object for vertex arrays that aren't in VBOs */
   struct gl_buffer_object *NullBufferObj;

   /**
    * \name Vertex/geometry/fragment programs
    */
   /*@@{*/
   struct _mesa_HashTable *Programs; /**< All vertex/fragment programs */
   struct gl_vertex_program *DefaultVertexProgram;
   struct gl_fragment_program *DefaultFragmentProgram;
   struct gl_geometry_program *DefaultGeometryProgram;
   /*@@}*/

   /* GL_ATI_fragment_shader */
   struct _mesa_HashTable *ATIShaders;
   struct ati_fragment_shader *DefaultFragmentShader;

   struct _mesa_HashTable *BufferObjects;

   /** Table of both gl_shader and gl_shader_program objects */
   struct _mesa_HashTable *ShaderObjects;

   /* GL_EXT_framebuffer_object */
   struct _mesa_HashTable *RenderBuffers;
   struct _mesa_HashTable *FrameBuffers;

   /* GL_ARB_sync */
   struct set *SyncObjects;

   /** GL_ARB_sampler_objects */
   struct _mesa_HashTable *SamplerObjects;

   /**
    * Some context in this share group was affected by a GPU reset
    *
    * On the next call to \c glGetGraphicsResetStatus, contexts that have not
    * been affected by a GPU reset must also return
    * \c GL_INNOCENT_CONTEXT_RESET_ARB.
    *
    * Once this field becomes true, it is never reset to false.
    */
   bool ShareGroupReset;
};



/**
 * Renderbuffers represent drawing surfaces such as color, depth and/or
 * stencil.  A framebuffer object has a set of renderbuffers.
 * Drivers will typically derive subclasses of this type.
 */
struct gl_renderbuffer
{
   mtx_t Mutex; /**< for thread safety */
   GLuint ClassID;        /**< Useful for drivers */
   GLuint Name;
   GLchar *Label;         /**< GL_KHR_debug */
   GLint RefCount;
   GLuint Width, Height;
   GLuint Depth;
   GLboolean Purgeable;  /**< Is the buffer purgeable under memory pressure? */
   GLboolean AttachedAnytime; /**< TRUE if it was attached to a framebuffer */
   /**
    * True for renderbuffers that wrap textures, giving the driver a chance to
    * flush render caches through the FinishRenderTexture hook.
    *
    * Drivers may also set this on renderbuffers other than those generated by
    * glFramebufferTexture(), though it means FinishRenderTexture() would be
    * called without a rb->TexImage.
    */
   GLboolean NeedsFinishRenderTexture;
   GLubyte NumSamples;
   GLenum InternalFormat; /**< The user-specified format */
   GLenum _BaseFormat;    /**< Either GL_RGB, GL_RGBA, GL_DEPTH_COMPONENT or
                               GL_STENCIL_INDEX. */
   mesa_format Format;      /**< The actual renderbuffer memory format */
   /**
    * Pointer to the texture image if this renderbuffer wraps a texture,
    * otherwise NULL.
    *
    * Note that the reference on the gl_texture_object containing this
    * TexImage is held by the gl_renderbuffer_attachment.
    */
   struct gl_texture_image *TexImage;

   /** Delete this renderbuffer */
   void (*Delete)(struct gl_context *ctx, struct gl_renderbuffer *rb);

   /** Allocate new storage for this renderbuffer */
   GLboolean (*AllocStorage)(struct gl_context *ctx,
                             struct gl_renderbuffer *rb,
                             GLenum internalFormat,
                             GLuint width, GLuint height);
};


/**
 * A renderbuffer attachment points to either a texture object (and specifies
 * a mipmap level, cube face or 3D texture slice) or points to a renderbuffer.
 */
struct gl_renderbuffer_attachment
{
   GLenum Type;  /**< \c GL_NONE or \c GL_TEXTURE or \c GL_RENDERBUFFER_EXT */
   GLboolean Complete;

   /**
    * If \c Type is \c GL_RENDERBUFFER_EXT, this stores a pointer to the
    * application supplied renderbuffer object.
    */
   struct gl_renderbuffer *Renderbuffer;

   /**
    * If \c Type is \c GL_TEXTURE, this stores a pointer to the application
    * supplied texture object.
    */
   struct gl_texture_object *Texture;
   GLuint TextureLevel; /**< Attached mipmap level. */
   GLuint CubeMapFace;  /**< 0 .. 5, for cube map textures. */
   GLuint Zoffset;      /**< Slice for 3D textures,  or layer for both 1D
                         * and 2D array textures */
   GLboolean Layered;
};


/**
 * A framebuffer is a collection of renderbuffers (color, depth, stencil, etc).
 * In C++ terms, think of this as a base class from which device drivers
 * will make derived classes.
 */
struct gl_framebuffer
{
   mtx_t Mutex;  /**< for thread safety */
   /**
    * If zero, this is a window system framebuffer.  If non-zero, this
    * is a FBO framebuffer; note that for some devices (i.e. those with
    * a natural pixel coordinate system for FBOs that differs from the
    * OpenGL/Mesa coordinate system), this means that the viewport,
    * polygon face orientation, and polygon stipple will have to be inverted.
    */
   GLuint Name;
   GLchar *Label;       /**< GL_KHR_debug */

   GLint RefCount;
   GLboolean DeletePending;

   /**
    * The framebuffer's visual. Immutable if this is a window system buffer.
    * Computed from attachments if user-made FBO.
    */
   struct gl_config Visual;

   GLuint Width, Height;	/**< size of frame buffer in pixels */

   /** \name  Drawing bounds (Intersection of buffer size and scissor box) */
   /*@@{*/
   GLint _Xmin, _Xmax;  /**< inclusive */
   GLint _Ymin, _Ymax;  /**< exclusive */
   /*@@}*/

   /** \name  Derived Z buffer stuff */
   /*@@{*/
   GLuint _DepthMax;	/**< Max depth buffer value */
   GLfloat _DepthMaxF;	/**< Float max depth buffer value */
   GLfloat _MRD;	/**< minimum resolvable difference in Z values */
   /*@@}*/

   /** One of the GL_FRAMEBUFFER_(IN)COMPLETE_* tokens */
   GLenum _Status;

   /** Integer color values */
   GLboolean _IntegerColor;

   /* ARB_color_buffer_float */
   GLboolean _AllColorBuffersFixedPoint; /* no integer, no float */
   GLboolean _HasSNormOrFloatColorBuffer;

   /** Array of all renderbuffer attachments, indexed by BUFFER_* tokens. */
   struct gl_renderbuffer_attachment Attachment[BUFFER_COUNT];

   /* In unextended OpenGL these vars are part of the GL_COLOR_BUFFER
    * attribute group and GL_PIXEL attribute group, respectively.
    */
   GLenum ColorDrawBuffer[MAX_DRAW_BUFFERS];
   GLenum ColorReadBuffer;

   /** Computed from ColorDraw/ReadBuffer above */
   GLuint _NumColorDrawBuffers;
   GLint _ColorDrawBufferIndexes[MAX_DRAW_BUFFERS]; /**< BUFFER_x or -1 */
   GLint _ColorReadBufferIndex; /* -1 = None */
   struct gl_renderbuffer *_ColorDrawBuffers[MAX_DRAW_BUFFERS];
   struct gl_renderbuffer *_ColorReadBuffer;

   /**
    * The maximum number of layers in the framebuffer, or 0 if the framebuffer
    * is not layered.  For cube maps and cube map arrays, each cube face
    * counts as a layer.
    */
   GLuint MaxNumLayers;

   /** Delete this framebuffer */
   void (*Delete)(struct gl_framebuffer *fb);
};


/**
 * Precision info for shader datatypes.  See glGetShaderPrecisionFormat().
 */
struct gl_precision
{
   GLushort RangeMin;   /**< min value exponent */
   GLushort RangeMax;   /**< max value exponent */
   GLushort Precision;  /**< number of mantissa bits */
};


/**
 * Limits for vertex, geometry and fragment programs/shaders.
 */
struct gl_program_constants
{
   /* logical limits */
   GLuint MaxInstructions;
   GLuint MaxAluInstructions;
   GLuint MaxTexInstructions;
   GLuint MaxTexIndirections;
   GLuint MaxAttribs;
   GLuint MaxTemps;
   GLuint MaxAddressRegs;
   GLuint MaxAddressOffset;  /**< [-MaxAddressOffset, MaxAddressOffset-1] */
   GLuint MaxParameters;
   GLuint MaxLocalParams;
   GLuint MaxEnvParams;
   /* native/hardware limits */
   GLuint MaxNativeInstructions;
   GLuint MaxNativeAluInstructions;
   GLuint MaxNativeTexInstructions;
   GLuint MaxNativeTexIndirections;
   GLuint MaxNativeAttribs;
   GLuint MaxNativeTemps;
   GLuint MaxNativeAddressRegs;
   GLuint MaxNativeParameters;
   /* For shaders */
   GLuint MaxUniformComponents;  /**< Usually == MaxParameters * 4 */

   /**
    * \name Per-stage input / output limits
    *
    * Previous to OpenGL 3.2, the intrastage data limits were advertised with
    * a single value: GL_MAX_VARYING_COMPONENTS (GL_MAX_VARYING_VECTORS in
    * ES).  This is stored as \c gl_constants::MaxVarying.
    *
    * Starting with OpenGL 3.2, the limits are advertised with per-stage
    * variables.  Each stage as a certain number of outputs that it can feed
    * to the next stage and a certain number inputs that it can consume from
    * the previous stage.
    *
    * Vertex shader inputs do not participate this in this accounting.
    * These are tracked exclusively by \c gl_program_constants::MaxAttribs.
    *
    * Fragment shader outputs do not participate this in this accounting.
    * These are tracked exclusively by \c gl_constants::MaxDrawBuffers.
    */
   /*@@{*/
   GLuint MaxInputComponents;
   GLuint MaxOutputComponents;
   /*@@}*/

   /* ES 2.0 and GL_ARB_ES2_compatibility */
   struct gl_precision LowFloat, MediumFloat, HighFloat;
   struct gl_precision LowInt, MediumInt, HighInt;
   /* GL_ARB_uniform_buffer_object */
   GLuint MaxUniformBlocks;
   GLuint MaxCombinedUniformComponents;
   GLuint MaxTextureImageUnits;

   /* GL_ARB_shader_atomic_counters */
   GLuint MaxAtomicBuffers;
   GLuint MaxAtomicCounters;

   /* GL_ARB_shader_image_load_store */
   GLuint MaxImageUniforms;
};


/**
 * Constants which may be overridden by device driver during context creation
 * but are never changed after that.
 */
struct gl_constants
{
   GLuint MaxTextureMbytes;      /**< Max memory per image, in MB */
   GLuint MaxTextureLevels;      /**< Max mipmap levels. */ 
   GLuint Max3DTextureLevels;    /**< Max mipmap levels for 3D textures */
   GLuint MaxCubeTextureLevels;  /**< Max mipmap levels for cube textures */
   GLuint MaxArrayTextureLayers; /**< Max layers in array textures */
   GLuint MaxTextureRectSize;    /**< Max rectangle texture size, in pixes */
   GLuint MaxTextureCoordUnits;
   GLuint MaxCombinedTextureImageUnits;
   GLuint MaxTextureUnits; /**< = MIN(CoordUnits, FragmentProgram.ImageUnits) */
   GLfloat MaxTextureMaxAnisotropy;  /**< GL_EXT_texture_filter_anisotropic */
   GLfloat MaxTextureLodBias;        /**< GL_EXT_texture_lod_bias */
   GLuint MaxTextureBufferSize;      /**< GL_ARB_texture_buffer_object */

   GLuint TextureBufferOffsetAlignment; /**< GL_ARB_texture_buffer_range */

   GLuint MaxArrayLockSize;

   GLint SubPixelBits;

   GLfloat MinPointSize, MaxPointSize;	     /**< aliased */
   GLfloat MinPointSizeAA, MaxPointSizeAA;   /**< antialiased */
   GLfloat PointSizeGranularity;
   GLfloat MinLineWidth, MaxLineWidth;       /**< aliased */
   GLfloat MinLineWidthAA, MaxLineWidthAA;   /**< antialiased */
   GLfloat LineWidthGranularity;

   GLuint MaxClipPlanes;
   GLuint MaxLights;
   GLfloat MaxShininess;                     /**< GL_NV_light_max_exponent */
   GLfloat MaxSpotExponent;                  /**< GL_NV_light_max_exponent */

   GLuint MaxViewportWidth, MaxViewportHeight;
   GLuint MaxViewports;                      /**< GL_ARB_viewport_array */
   GLuint ViewportSubpixelBits;              /**< GL_ARB_viewport_array */
   struct {
      GLfloat Min;
      GLfloat Max;
   } ViewportBounds;                         /**< GL_ARB_viewport_array */

   struct gl_program_constants Program[MESA_SHADER_STAGES];
   GLuint MaxProgramMatrices;
   GLuint MaxProgramMatrixStackDepth;

   struct {
      GLuint SamplesPassed;
      GLuint TimeElapsed;
      GLuint Timestamp;
      GLuint PrimitivesGenerated;
      GLuint PrimitivesWritten;
   } QueryCounterBits;

   /** vertex array / buffer object bounds checking */
   GLboolean CheckArrayBounds;

   GLuint MaxDrawBuffers;    /**< GL_ARB_draw_buffers */

   GLuint MaxColorAttachments;   /**< GL_EXT_framebuffer_object */
   GLuint MaxRenderbufferSize;   /**< GL_EXT_framebuffer_object */
   GLuint MaxSamples;            /**< GL_ARB_framebuffer_object */

   /** Number of varying vectors between any two shader stages. */
   GLuint MaxVarying;

   /** @@{
    * GL_ARB_uniform_buffer_object
    */
   GLuint MaxCombinedUniformBlocks;
   GLuint MaxUniformBufferBindings;
   GLuint MaxUniformBlockSize;
   GLuint UniformBufferOffsetAlignment;
   /** @@} */

   /** GL_ARB_geometry_shader4 */
   GLuint MaxGeometryOutputVertices;
   GLuint MaxGeometryTotalOutputComponents;

   GLuint GLSLVersion;  /**< GLSL version supported (ex: 120 = 1.20) */

   /**
    * Changes default GLSL extension behavior from "error" to "warn".  It's out
    * of spec, but it can make some apps work that otherwise wouldn't.
    */
   GLboolean ForceGLSLExtensionsWarn;

   /**
    * If non-zero, forces GLSL shaders without the #version directive to behave
    * as if they began with "#version ForceGLSLVersion".
    */
   GLuint ForceGLSLVersion;

   /**
    * Does the driver support real 32-bit integers?  (Otherwise, integers are
    * simulated via floats.)
    */
   GLboolean NativeIntegers;

   /**
    * If the driver supports real 32-bit integers, what integer value should be
    * used for boolean true in uniform uploads?  (Usually 1 or ~0.)
    */
   GLuint UniformBooleanTrue;

   /** Which texture units support GL_ATI_envmap_bumpmap as targets */
   GLbitfield SupportedBumpUnits;

   /**
    * Maximum amount of time, measured in nanseconds, that the server can wait.
    */
   GLuint64 MaxServerWaitTimeout;

   /** GL_EXT_provoking_vertex */
   GLboolean QuadsFollowProvokingVertexConvention;

   /** OpenGL version 3.0 */
   GLbitfield ContextFlags;  /**< Ex: GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT */

   /** OpenGL version 3.2 */
   GLbitfield ProfileMask;   /**< Mask of CONTEXT_x_PROFILE_BIT */

   /** GL_EXT_transform_feedback */
   GLuint MaxTransformFeedbackBuffers;
   GLuint MaxTransformFeedbackSeparateComponents;
   GLuint MaxTransformFeedbackInterleavedComponents;
   GLuint MaxVertexStreams;

   /** GL_EXT_gpu_shader4 */
   GLint MinProgramTexelOffset, MaxProgramTexelOffset;

   /** GL_ARB_texture_gather */
   GLuint MinProgramTextureGatherOffset;
   GLuint MaxProgramTextureGatherOffset;
   GLuint MaxProgramTextureGatherComponents;

   /* GL_ARB_robustness */
   GLenum ResetStrategy;

   /* GL_ARB_blend_func_extended */
   GLuint MaxDualSourceDrawBuffers;

   /**
    * Whether the implementation strips out and ignores texture borders.
    *
    * Many GPU hardware implementations don't support rendering with texture
    * borders and mipmapped textures.  (Note: not static border color, but the
    * old 1-pixel border around each edge).  Implementations then have to do
    * slow fallbacks to be correct, or just ignore the border and be fast but
    * wrong.  Setting the flag strips the border off of TexImage calls,
    * providing "fast but wrong" at significantly reduced driver complexity.
    *
    * Texture borders are deprecated in GL 3.0.
    **/
   GLboolean StripTextureBorder;

   /**
    * For drivers which can do a better job at eliminating unused uniforms
    * than the GLSL compiler.
    *
    * XXX Remove these as soon as a better solution is available.
    */
   GLboolean GLSLSkipStrictMaxUniformLimitCheck;

   /**
    * Force software support for primitive restart in the VBO module.
    */
   GLboolean PrimitiveRestartInSoftware;

   /**
    * Always use the GetTransformFeedbackVertexCount() driver hook, rather
    * than passing the transform feedback object to the drawing function.
    */
   GLboolean AlwaysUseGetTransformFeedbackVertexCount;

   /** GL_ARB_map_buffer_alignment */
   GLuint MinMapBufferAlignment;

   /**
    * Disable varying packing.  This is out of spec, but potentially useful
    * for older platforms that supports a limited number of texture
    * indirections--on these platforms, unpacking the varyings in the fragment
    * shader increases the number of texture indirections by 1, which might
    * make some shaders not executable at all.
    *
    * Drivers that support transform feedback must set this value to GL_FALSE.
    */
   GLboolean DisableVaryingPacking;

   /*
    * Maximum value supported for an index in DrawElements and friends.
    *
    * This must be at least (1ull<<24)-1.  The default value is
    * (1ull<<32)-1.
    *
    * \since ES 3.0 or GL_ARB_ES3_compatibility
    * \sa _mesa_init_constants
    */
   GLuint64 MaxElementIndex;

   /**
    * Disable interpretation of line continuations (lines ending with a
    * backslash character ('\') in GLSL source.
    */
   GLboolean DisableGLSLLineContinuations;

   /** GL_ARB_texture_multisample */
   GLint MaxColorTextureSamples;
   GLint MaxDepthTextureSamples;
   GLint MaxIntegerSamples;

   /** GL_ARB_shader_atomic_counters */
   GLuint MaxAtomicBufferBindings;
   GLuint MaxAtomicBufferSize;
   GLuint MaxCombinedAtomicBuffers;
   GLuint MaxCombinedAtomicCounters;

   /** GL_ARB_vertex_attrib_binding */
   GLint MaxVertexAttribRelativeOffset;
   GLint MaxVertexAttribBindings;

   /* GL_ARB_shader_image_load_store */
   GLuint MaxImageUnits;
   GLuint MaxCombinedImageUnitsAndFragmentOutputs;
   GLuint MaxImageSamples;
   GLuint MaxCombinedImageUniforms;

   /** GL_ARB_compute_shader */
   GLuint MaxComputeWorkGroupCount[3]; /* Array of x, y, z dimensions */
   GLuint MaxComputeWorkGroupSize[3]; /* Array of x, y, z dimensions */
   GLuint MaxComputeWorkGroupInvocations;

   /** GL_ARB_gpu_shader5 */
   GLfloat MinFragmentInterpolationOffset;
   GLfloat MaxFragmentInterpolationOffset;

   GLboolean FakeSWMSAA;
};


/**
 * Enable flag for each OpenGL extension.  Different device drivers will
 * enable different extensions at runtime.
 */
struct gl_extensions
{
   GLboolean dummy;  /* don't remove this! */
   GLboolean dummy_true;  /* Set true by _mesa_init_extensions(). */
   GLboolean dummy_false; /* Set false by _mesa_init_extensions(). */
   GLboolean ANGLE_texture_compression_dxt;
   GLboolean ARB_ES2_compatibility;
   GLboolean ARB_ES3_compatibility;
   GLboolean ARB_arrays_of_arrays;
   GLboolean ARB_base_instance;
   GLboolean ARB_blend_func_extended;
   GLboolean ARB_buffer_storage;
   GLboolean ARB_color_buffer_float;
   GLboolean ARB_compute_shader;
   GLboolean ARB_conservative_depth;
   GLboolean ARB_depth_buffer_float;
   GLboolean ARB_depth_clamp;
   GLboolean ARB_depth_texture;
   GLboolean ARB_draw_buffers_blend;
   GLboolean ARB_draw_elements_base_vertex;
   GLboolean ARB_draw_indirect;
   GLboolean ARB_draw_instanced;
   GLboolean ARB_fragment_coord_conventions;
   GLboolean ARB_fragment_program;
   GLboolean ARB_fragment_program_shadow;
   GLboolean ARB_fragment_shader;
   GLboolean ARB_framebuffer_object;
   GLboolean ARB_explicit_attrib_location;
   GLboolean ARB_geometry_shader4;
   GLboolean ARB_gpu_shader5;
   GLboolean ARB_half_float_vertex;
   GLboolean ARB_instanced_arrays;
   GLboolean ARB_internalformat_query;
   GLboolean ARB_map_buffer_range;
   GLboolean ARB_occlusion_query;
   GLboolean ARB_occlusion_query2;
   GLboolean ARB_point_sprite;
   GLboolean ARB_sample_shading;
   GLboolean ARB_seamless_cube_map;
   GLboolean ARB_shader_atomic_counters;
   GLboolean ARB_shader_bit_encoding;
   GLboolean ARB_shader_image_load_store;
   GLboolean ARB_shader_stencil_export;
   GLboolean ARB_shader_texture_lod;
   GLboolean ARB_shading_language_packing;
   GLboolean ARB_shading_language_420pack;
   GLboolean ARB_shadow;
   GLboolean ARB_stencil_texturing;
   GLboolean ARB_sync;
   GLboolean ARB_texture_border_clamp;
   GLboolean ARB_texture_buffer_object;
   GLboolean ARB_texture_buffer_object_rgb32;
   GLboolean ARB_texture_buffer_range;
   GLboolean ARB_texture_compression_rgtc;
   GLboolean ARB_texture_cube_map;
   GLboolean ARB_texture_cube_map_array;
   GLboolean ARB_texture_env_combine;
   GLboolean ARB_texture_env_crossbar;
   GLboolean ARB_texture_env_dot3;
   GLboolean ARB_texture_float;
   GLboolean ARB_texture_gather;
   GLboolean ARB_texture_mirror_clamp_to_edge;
   GLboolean ARB_texture_multisample;
   GLboolean ARB_texture_non_power_of_two;
   GLboolean ARB_texture_stencil8;
   GLboolean ARB_texture_query_levels;
   GLboolean ARB_texture_query_lod;
   GLboolean ARB_texture_rg;
   GLboolean ARB_texture_rgb10_a2ui;
   GLboolean ARB_texture_view;
   GLboolean ARB_timer_query;
   GLboolean ARB_transform_feedback2;
   GLboolean ARB_transform_feedback3;
   GLboolean ARB_transform_feedback_instanced;
   GLboolean ARB_uniform_buffer_object;
   GLboolean ARB_vertex_program;
   GLboolean ARB_vertex_shader;
   GLboolean ARB_vertex_type_10f_11f_11f_rev;
   GLboolean ARB_vertex_type_2_10_10_10_rev;
   GLboolean ARB_viewport_array;
   GLboolean EXT_blend_color;
   GLboolean EXT_blend_equation_separate;
   GLboolean EXT_blend_func_separate;
   GLboolean EXT_blend_minmax;
   GLboolean EXT_depth_bounds_test;
   GLboolean EXT_draw_buffers2;
   GLboolean EXT_framebuffer_multisample;
   GLboolean EXT_framebuffer_multisample_blit_scaled;
   GLboolean EXT_framebuffer_sRGB;
   GLboolean EXT_gpu_program_parameters;
   GLboolean EXT_gpu_shader4;
   GLboolean EXT_packed_float;
   GLboolean EXT_pixel_buffer_object;
   GLboolean EXT_point_parameters;
   GLboolean EXT_provoking_vertex;
   GLboolean EXT_shader_integer_mix;
   GLboolean EXT_stencil_two_side;
   GLboolean EXT_texture3D;
   GLboolean EXT_texture_array;
   GLboolean EXT_texture_compression_latc;
   GLboolean EXT_texture_compression_s3tc;
   GLboolean EXT_texture_env_dot3;
   GLboolean EXT_texture_filter_anisotropic;
   GLboolean EXT_texture_integer;
   GLboolean EXT_texture_mirror_clamp;
   GLboolean EXT_texture_shared_exponent;
   GLboolean EXT_texture_snorm;
   GLboolean EXT_texture_sRGB;
   GLboolean EXT_texture_sRGB_decode;
   GLboolean EXT_texture_swizzle;
   GLboolean EXT_transform_feedback;
   GLboolean EXT_timer_query;
   GLboolean EXT_vertex_array_bgra;
   GLboolean OES_standard_derivatives;
   /* vendor extensions */
   GLboolean AMD_performance_monitor;
   GLboolean AMD_seamless_cubemap_per_texture;
   GLboolean AMD_vertex_shader_layer;
   GLboolean APPLE_object_purgeable;
   GLboolean ATI_envmap_bumpmap;
   GLboolean ATI_texture_compression_3dc;
   GLboolean ATI_texture_mirror_once;
   GLboolean ATI_texture_env_combine3;
   GLboolean ATI_fragment_shader;
   GLboolean ATI_separate_stencil;
   GLboolean INTEL_performance_query;
   GLboolean MESA_pack_invert;
   GLboolean MESA_ycbcr_texture;
   GLboolean NV_conditional_render;
   GLboolean NV_fog_distance;
   GLboolean NV_fragment_program_option;
   GLboolean NV_point_sprite;
   GLboolean NV_primitive_restart;
   GLboolean NV_texture_barrier;
   GLboolean NV_texture_env_combine4;
   GLboolean NV_texture_rectangle;
   GLboolean NV_vdpau_interop;
   GLboolean TDFX_texture_compression_FXT1;
   GLboolean OES_EGL_image;
   GLboolean OES_draw_texture;
   GLboolean OES_depth_texture_cube_map;
   GLboolean OES_EGL_image_external;
   GLboolean OES_compressed_ETC1_RGB8_texture;
   GLboolean extension_sentinel;
   /** The extension string */
   const GLubyte *String;
   /** Number of supported extensions */
   GLuint Count;
};


/**
 * A stack of matrices (projection, modelview, color, texture, etc).
 */
struct gl_matrix_stack
{
   GLmatrix *Top;      /**< points into Stack */
   GLmatrix *Stack;    /**< array [MaxDepth] of GLmatrix */
   GLuint Depth;       /**< 0 <= Depth < MaxDepth */
   GLuint MaxDepth;    /**< size of Stack[] array */
   GLuint DirtyFlag;   /**< _NEW_MODELVIEW or _NEW_PROJECTION, for example */
};


/**
 * \name Bits for image transfer operations 
 * \sa __struct gl_contextRec::ImageTransferState.
 */
/*@@{*/
#define IMAGE_SCALE_BIAS_BIT                      0x1
#define IMAGE_SHIFT_OFFSET_BIT                    0x2
#define IMAGE_MAP_COLOR_BIT                       0x4
#define IMAGE_CLAMP_BIT                           0x800


/** Pixel Transfer ops */
#define IMAGE_BITS (IMAGE_SCALE_BIAS_BIT |			\
		    IMAGE_SHIFT_OFFSET_BIT |			\
		    IMAGE_MAP_COLOR_BIT)

/**
 * \name Bits to indicate what state has changed.  
 */
/*@@{*/
#define _NEW_MODELVIEW         (1 << 0)   /**< gl_context::ModelView */
#define _NEW_PROJECTION        (1 << 1)   /**< gl_context::Projection */
#define _NEW_TEXTURE_MATRIX    (1 << 2)   /**< gl_context::TextureMatrix */
#define _NEW_COLOR             (1 << 3)   /**< gl_context::Color */
#define _NEW_DEPTH             (1 << 4)   /**< gl_context::Depth */
#define _NEW_EVAL              (1 << 5)   /**< gl_context::Eval, EvalMap */
#define _NEW_FOG               (1 << 6)   /**< gl_context::Fog */
#define _NEW_HINT              (1 << 7)   /**< gl_context::Hint */
#define _NEW_LIGHT             (1 << 8)   /**< gl_context::Light */
#define _NEW_LINE              (1 << 9)   /**< gl_context::Line */
#define _NEW_PIXEL             (1 << 10)  /**< gl_context::Pixel */
#define _NEW_POINT             (1 << 11)  /**< gl_context::Point */
#define _NEW_POLYGON           (1 << 12)  /**< gl_context::Polygon */
#define _NEW_POLYGONSTIPPLE    (1 << 13)  /**< gl_context::PolygonStipple */
#define _NEW_SCISSOR           (1 << 14)  /**< gl_context::Scissor */
#define _NEW_STENCIL           (1 << 15)  /**< gl_context::Stencil */
#define _NEW_TEXTURE           (1 << 16)  /**< gl_context::Texture */
#define _NEW_TRANSFORM         (1 << 17)  /**< gl_context::Transform */
#define _NEW_VIEWPORT          (1 << 18)  /**< gl_context::Viewport */
/* gap, re-use for core Mesa state only; use ctx->DriverFlags otherwise */
#define _NEW_ARRAY             (1 << 20)  /**< gl_context::Array */
#define _NEW_RENDERMODE        (1 << 21)  /**< gl_context::RenderMode, etc */
#define _NEW_BUFFERS           (1 << 22)  /**< gl_context::Visual, DrawBuffer, */
#define _NEW_CURRENT_ATTRIB    (1 << 23)  /**< gl_context::Current */
#define _NEW_MULTISAMPLE       (1 << 24)  /**< gl_context::Multisample */
#define _NEW_TRACK_MATRIX      (1 << 25)  /**< gl_context::VertexProgram */
#define _NEW_PROGRAM           (1 << 26)  /**< New program/shader state */
#define _NEW_PROGRAM_CONSTANTS (1 << 27)
#define _NEW_BUFFER_OBJECT     (1 << 28)
#define _NEW_FRAG_CLAMP        (1 << 29)
/* gap, re-use for core Mesa state only; use ctx->DriverFlags otherwise */
#define _NEW_VARYING_VP_INPUTS (1 << 31) /**< gl_context::varying_vp_inputs */
#define _NEW_ALL ~0
/*@@}*/


/**
 * Composite state flags
 */
/*@@{*/
#define _MESA_NEW_NEED_EYE_COORDS         (_NEW_LIGHT |		\
                                           _NEW_TEXTURE |	\
                                           _NEW_POINT |		\
                                           _NEW_PROGRAM |	\
                                           _NEW_MODELVIEW)

#define _MESA_NEW_SEPARATE_SPECULAR        (_NEW_LIGHT | \
                                            _NEW_FOG | \
                                            _NEW_PROGRAM)


/*@@}*/




/* This has to be included here. */
#include "dd.h"


/**
 * Display list flags.
 * Strictly this is a tnl-private concept, but it doesn't seem
 * worthwhile adding a tnl private structure just to hold this one bit
 * of information:
 */
#define DLIST_DANGLING_REFS     0x1 


/** Opaque declaration of display list payload data type */
union gl_dlist_node;


/**
 * Provide a location where information about a display list can be
 * collected.  Could be extended with driverPrivate structures,
 * etc. in the future.
 */
struct gl_display_list
{
   GLuint Name;
   GLchar *Label;     /**< GL_KHR_debug */
   GLbitfield Flags;  /**< DLIST_x flags */
   /** The dlist commands are in a linked list of nodes */
   union gl_dlist_node *Head;
};


/**
 * State used during display list compilation and execution.
 */
struct gl_dlist_state
{
   GLuint CallDepth;		/**< Current recursion calling depth */

   struct gl_display_list *CurrentList; /**< List currently being compiled */
   union gl_dlist_node *CurrentBlock; /**< Pointer to current block of nodes */
   GLuint CurrentPos;		/**< Index into current block of nodes */

   GLvertexformat ListVtxfmt;

   GLubyte ActiveAttribSize[VERT_ATTRIB_MAX];
   GLfloat CurrentAttrib[VERT_ATTRIB_MAX][4];
   
   GLubyte ActiveMaterialSize[MAT_ATTRIB_MAX];
   GLfloat CurrentMaterial[MAT_ATTRIB_MAX][4];

   struct {
      /* State known to have been set by the currently-compiling display
       * list.  Used to eliminate some redundant state changes.
       */
      GLenum ShadeModel;
   } Current;
};

/** @@{
 *
 * These are a mapping of the GL_ARB_debug_output/GL_KHR_debug enums
 * to small enums suitable for use as an array index.
 */

enum mesa_debug_source {
   MESA_DEBUG_SOURCE_API,
   MESA_DEBUG_SOURCE_WINDOW_SYSTEM,
   MESA_DEBUG_SOURCE_SHADER_COMPILER,
   MESA_DEBUG_SOURCE_THIRD_PARTY,
   MESA_DEBUG_SOURCE_APPLICATION,
   MESA_DEBUG_SOURCE_OTHER,
   MESA_DEBUG_SOURCE_COUNT
};

enum mesa_debug_type {
   MESA_DEBUG_TYPE_ERROR,
   MESA_DEBUG_TYPE_DEPRECATED,
   MESA_DEBUG_TYPE_UNDEFINED,
   MESA_DEBUG_TYPE_PORTABILITY,
   MESA_DEBUG_TYPE_PERFORMANCE,
   MESA_DEBUG_TYPE_OTHER,
   MESA_DEBUG_TYPE_MARKER,
   MESA_DEBUG_TYPE_PUSH_GROUP,
   MESA_DEBUG_TYPE_POP_GROUP,
   MESA_DEBUG_TYPE_COUNT
};

enum mesa_debug_severity {
   MESA_DEBUG_SEVERITY_LOW,
   MESA_DEBUG_SEVERITY_MEDIUM,
   MESA_DEBUG_SEVERITY_HIGH,
   MESA_DEBUG_SEVERITY_NOTIFICATION,
   MESA_DEBUG_SEVERITY_COUNT
};

/** @@} */

/**
 * Enum for the OpenGL APIs we know about and may support.
 *
 * NOTE: This must match the api_enum table in
 * src/mesa/main/get_hash_generator.py
 */
typedef enum
{
   API_OPENGL_COMPAT,      /* legacy / compatibility contexts */
   API_OPENGLES,
   API_OPENGLES2,
   API_OPENGL_CORE,
   API_OPENGL_LAST = API_OPENGL_CORE
} gl_api;

/**
 * Driver-specific state flags.
 *
 * These are or'd with gl_context::NewDriverState to notify a driver about
 * a state change. The driver sets the flags at context creation and
 * the meaning of the bits set is opaque to core Mesa.
 */
struct gl_driver_flags
{
   /** gl_context::Array::_DrawArrays (vertex array state) */
   GLbitfield NewArray;

   /** gl_context::TransformFeedback::CurrentObject */
   GLbitfield NewTransformFeedback;

   /** gl_context::TransformFeedback::CurrentObject::shader_program */
   GLbitfield NewTransformFeedbackProg;

   /** gl_context::RasterDiscard */
   GLbitfield NewRasterizerDiscard;

   /**
    * gl_context::UniformBufferBindings
    * gl_shader_program::UniformBlocks
    */
   GLbitfield NewUniformBuffer;

   /**
    * gl_context::AtomicBufferBindings
    */
   GLbitfield NewAtomicBuffer;

   /**
    * gl_context::ImageUnits
    */
   GLbitfield NewImageUnits;
};

struct gl_uniform_buffer_binding
{
   struct gl_buffer_object *BufferObject;
   /** Start of uniform block data in the buffer */
   GLintptr Offset;
   /** Size of data allowed to be referenced from the buffer (in bytes) */
   GLsizeiptr Size;
   /**
    * glBindBufferBase() indicates that the Size should be ignored and only
    * limited by the current size of the BufferObject.
    */
   GLboolean AutomaticSize;
};

/**
 * ARB_shader_image_load_store image unit.
 */
struct gl_image_unit
{
   /**
    * Texture object bound to this unit.
    */
   struct gl_texture_object *TexObj;

   /**
    * Level of the texture object bound to this unit.
    */
   GLuint Level;

   /**
    * \c GL_TRUE if the whole level is bound as an array of layers, \c
    * GL_FALSE if only some specific layer of the texture is bound.
    * \sa Layer
    */
   GLboolean Layered;

   /**
    * Layer of the texture object bound to this unit, or zero if the
    * whole level is bound.
    */
   GLuint Layer;

   /**
    * Access allowed to this texture image.  Either \c GL_READ_ONLY,
    * \c GL_WRITE_ONLY or \c GL_READ_WRITE.
    */
   GLenum Access;

   /**
    * GL internal format that determines the interpretation of the
    * image memory when shader image operations are performed through
    * this unit.
    */
   GLenum Format;

   /**
    * Mesa format corresponding to \c Format.
    */
   mesa_format _ActualFormat;

   /**
    * GL_TRUE if the state of this image unit is valid and access from
    * the shader is allowed.  Otherwise loads from this unit should
    * return zero and stores should have no effect.
    */
   GLboolean _Valid;
};

/**
 * Binding point for an atomic counter buffer object.
 */
struct gl_atomic_buffer_binding
{
   struct gl_buffer_object *BufferObject;
   GLintptr Offset;
   GLsizeiptr Size;
};

/**
 * Mesa rendering context.
 *
 * This is the central context data structure for Mesa.  Almost all
 * OpenGL state is contained in this structure.
 * Think of this as a base class from which device drivers will derive
 * sub classes.
 */
struct gl_context
{
   /** State possibly shared with other contexts in the address space */
   struct gl_shared_state *Shared;

   /** \name API function pointer tables */
   /*@@{*/
   gl_api API;
   /**
    * The current dispatch table for non-displaylist-saving execution, either
    * BeginEnd or OutsideBeginEnd
    */
   struct _glapi_table *Exec;
   /**
    * The normal dispatch table for non-displaylist-saving, non-begin/end
    */
   struct _glapi_table *OutsideBeginEnd;
   /** The dispatch table used between glNewList() and glEndList() */
   struct _glapi_table *Save;
   /**
    * The dispatch table used between glBegin() and glEnd() (outside of a
    * display list).  Only valid functions between those two are set, which is
    * mostly just the set in a GLvertexformat struct.
    */
   struct _glapi_table *BeginEnd;
   /**
    * Tracks the current dispatch table out of the 3 above, so that it can be
    * re-set on glXMakeCurrent().
    */
   struct _glapi_table *CurrentDispatch;
   /*@@}*/

   struct gl_config Visual;
   struct gl_framebuffer *DrawBuffer;	/**< buffer for writing */
   struct gl_framebuffer *ReadBuffer;	/**< buffer for reading */
   struct gl_framebuffer *WinSysDrawBuffer;  /**< set with MakeCurrent */
   struct gl_framebuffer *WinSysReadBuffer;  /**< set with MakeCurrent */

   /**
    * Device driver function pointer table
    */
   struct dd_function_table Driver;

   /** Core/Driver constants */
   struct gl_constants Const;

   /** \name The various 4x4 matrix stacks */
   /*@@{*/
   struct gl_matrix_stack ModelviewMatrixStack;
   struct gl_matrix_stack ProjectionMatrixStack;
   struct gl_matrix_stack TextureMatrixStack[MAX_TEXTURE_UNITS];
   struct gl_matrix_stack ProgramMatrixStack[MAX_PROGRAM_MATRICES];
   struct gl_matrix_stack *CurrentStack; /**< Points to one of the above stacks */
   /*@@}*/

   /** Combined modelview and projection matrix */
   GLmatrix _ModelProjectMatrix;

   /** \name Display lists */
   struct gl_dlist_state ListState;

   GLboolean ExecuteFlag;	/**< Execute GL commands? */
   GLboolean CompileFlag;	/**< Compile GL commands into display list? */

   /** Extension information */
   struct gl_extensions Extensions;

   /** GL version integer, for example 31 for GL 3.1, or 20 for GLES 2.0. */
   GLuint Version;
   char *VersionString;

   /** \name State attribute stack (for glPush/PopAttrib) */
   /*@@{*/
   GLuint AttribStackDepth;
   struct gl_attrib_node *AttribStack[MAX_ATTRIB_STACK_DEPTH];
   /*@@}*/

   /** \name Renderer attribute groups
    * 
    * We define a struct for each attribute group to make pushing and popping
    * attributes easy.  Also it's a good organization.
    */
   /*@@{*/
   struct gl_accum_attrib	Accum;		/**< Accum buffer attributes */
   struct gl_colorbuffer_attrib	Color;		/**< Color buffer attributes */
   struct gl_current_attrib	Current;	/**< Current attributes */
   struct gl_depthbuffer_attrib	Depth;		/**< Depth buffer attributes */
   struct gl_eval_attrib	Eval;		/**< Eval attributes */
   struct gl_fog_attrib		Fog;		/**< Fog attributes */
   struct gl_hint_attrib	Hint;		/**< Hint attributes */
   struct gl_light_attrib	Light;		/**< Light attributes */
   struct gl_line_attrib	Line;		/**< Line attributes */
   struct gl_list_attrib	List;		/**< List attributes */
   struct gl_multisample_attrib Multisample;
   struct gl_pixel_attrib	Pixel;		/**< Pixel attributes */
   struct gl_point_attrib	Point;		/**< Point attributes */
   struct gl_polygon_attrib	Polygon;	/**< Polygon attributes */
   GLuint PolygonStipple[32];			/**< Polygon stipple */
   struct gl_scissor_attrib	Scissor;	/**< Scissor attributes */
   struct gl_stencil_attrib	Stencil;	/**< Stencil buffer attributes */
   struct gl_texture_attrib	Texture;	/**< Texture attributes */
   struct gl_transform_attrib	Transform;	/**< Transformation attributes */
   struct gl_viewport_attrib	ViewportArray[MAX_VIEWPORTS];	/**< Viewport attributes */
   /*@@}*/

   /** \name Client attribute stack */
   /*@@{*/
   GLuint ClientAttribStackDepth;
   struct gl_attrib_node *ClientAttribStack[MAX_CLIENT_ATTRIB_STACK_DEPTH];
   /*@@}*/

   /** \name Client attribute groups */
   /*@@{*/
   struct gl_array_attrib	Array;	/**< Vertex arrays */
   struct gl_pixelstore_attrib	Pack;	/**< Pixel packing */
   struct gl_pixelstore_attrib	Unpack;	/**< Pixel unpacking */
   struct gl_pixelstore_attrib	DefaultPacking;	/**< Default params */
   /*@@}*/

   /** \name Other assorted state (not pushed/popped on attribute stack) */
   /*@@{*/
   struct gl_pixelmaps          PixelMaps;

   struct gl_evaluators EvalMap;   /**< All evaluators */
   struct gl_feedback   Feedback;  /**< Feedback */
   struct gl_selection  Select;    /**< Selection */

   struct gl_program_state Program;  /**< general program state */
   struct gl_vertex_program_state VertexProgram;
   struct gl_fragment_program_state FragmentProgram;
   struct gl_geometry_program_state GeometryProgram;
   struct gl_ati_fragment_shader_state ATIFragmentShader;

   struct gl_pipeline_shader_state Pipeline; /**< GLSL pipeline shader object state */
   struct gl_pipeline_object Shader; /**< GLSL shader object state */

   /**
    * Current active shader pipeline state
    *
    * Almost all internal users want ::_Shader instead of ::Shader.  The
    * exceptions are bits of legacy GLSL API that do not know about separate
    * shader objects.
    *
    * If a program is active via \c glUseProgram, this will point to
    * \c ::Shader.
    *
    * If a program pipeline is active via \c glBindProgramPipeline, this will
    * point to \c ::Pipeline.Current.
    *
    * If neither a program nor a program pipeline is active, this will point to
    * \c ::Pipeline.Default.  This ensures that \c ::_Shader will never be
    * \c NULL.
    */
   struct gl_pipeline_object *_Shader;

   struct gl_shader_compiler_options ShaderCompilerOptions[MESA_SHADER_STAGES];

   struct gl_query_state Query;  /**< occlusion, timer queries */

   struct gl_transform_feedback_state TransformFeedback;

   struct gl_perf_monitor_state PerfMonitor;

   struct gl_buffer_object *DrawIndirectBuffer; /** < GL_ARB_draw_indirect */

   struct gl_buffer_object *CopyReadBuffer; /**< GL_ARB_copy_buffer */
   struct gl_buffer_object *CopyWriteBuffer; /**< GL_ARB_copy_buffer */

   /**
    * Current GL_ARB_uniform_buffer_object binding referenced by
    * GL_UNIFORM_BUFFER target for glBufferData, glMapBuffer, etc.
    */
   struct gl_buffer_object *UniformBuffer;

   /**
    * Array of uniform buffers for GL_ARB_uniform_buffer_object and GL 3.1.
    * This is set up using glBindBufferRange() or glBindBufferBase().  They are
    * associated with uniform blocks by glUniformBlockBinding()'s state in the
    * shader program.
    */
   struct gl_uniform_buffer_binding
      UniformBufferBindings[MAX_COMBINED_UNIFORM_BUFFERS];

   /**
    * Object currently associated with the GL_ATOMIC_COUNTER_BUFFER
    * target.
    */
   struct gl_buffer_object *AtomicBuffer;

   /**
    * Array of atomic counter buffer binding points.
    */
   struct gl_atomic_buffer_binding
      AtomicBufferBindings[MAX_COMBINED_ATOMIC_BUFFERS];

   /**
    * Array of image units for ARB_shader_image_load_store.
    */
   struct gl_image_unit ImageUnits[MAX_IMAGE_UNITS];

   /*@@}*/

   struct gl_meta_state *Meta;  /**< for "meta" operations */

   /* GL_EXT_framebuffer_object */
   struct gl_renderbuffer *CurrentRenderbuffer;

   GLenum ErrorValue;        /**< Last error code */

   /**
    * Recognize and silence repeated error debug messages in buggy apps.
    */
   const char *ErrorDebugFmtString;
   GLuint ErrorDebugCount;

   /* GL_ARB_debug_output/GL_KHR_debug */
   struct gl_debug_state *Debug;

   GLenum RenderMode;        /**< either GL_RENDER, GL_SELECT, GL_FEEDBACK */
   GLbitfield NewState;      /**< bitwise-or of _NEW_* flags */
   GLbitfield NewDriverState;/**< bitwise-or of flags from DriverFlags */

   struct gl_driver_flags DriverFlags;

   GLboolean ViewportInitialized;  /**< has viewport size been initialized? */

   GLbitfield64 varying_vp_inputs;  /**< mask of VERT_BIT_* flags */

   /** \name Derived state */
   GLbitfield _ImageTransferState;/**< bitwise-or of IMAGE_*_BIT flags */
   GLfloat _EyeZDir[3];
   GLfloat _ModelViewInvScale;
   GLboolean _NeedEyeCoords;
   GLboolean _ForceEyeCoords; 

   GLuint TextureStateTimestamp; /**< detect changes to shared state */

   struct gl_list_extensions *ListExt; /**< driver dlist extensions */

   /** \name For debugging/development only */
   /*@@{*/
   GLboolean FirstTimeCurrent;
   /*@@}*/

   /**
    * False if this context was created without a config. This is needed
    * because the initial state of glDrawBuffers depends on this
    */
   GLboolean HasConfig;

   /** software compression/decompression supported or not */
   GLboolean Mesa_DXTn;

   GLboolean TextureFormatSupported[MESA_FORMAT_COUNT];

   GLboolean RasterDiscard;  /**< GL_RASTERIZER_DISCARD */

   /**
    * \name Hooks for module contexts.  
    *
    * These will eventually live in the driver or elsewhere.
    */
   /*@@{*/
   void *swrast_context;
   void *swsetup_context;
   void *swtnl_context;
   struct vbo_context *vbo_context;
   struct st_context *st;
   void *aelt_context;
   /*@@}*/

   /**
    * \name NV_vdpau_interop
    */
   /*@@{*/
   const void *vdpDevice;
   const void *vdpGetProcAddress;
   struct set *vdpSurfaces;
   /*@@}*/

   /**
    * Has this context observed a GPU reset in any context in the share group?
    *
    * Once this field becomes true, it is never reset to false.
    */
   GLboolean ShareGroupReset;
};


#ifdef DEBUG
extern int MESA_VERBOSE;
extern int MESA_DEBUG_FLAGS;
# define MESA_FUNCTION __FUNCTION__
#else
# define MESA_VERBOSE 0
# define MESA_DEBUG_FLAGS 0
# define MESA_FUNCTION "a function"
# ifndef NDEBUG
#  define NDEBUG
# endif
#endif


/** The MESA_VERBOSE var is a bitmask of these flags */
enum _verbose
{
   VERBOSE_VARRAY		= 0x0001,
   VERBOSE_TEXTURE		= 0x0002,
   VERBOSE_MATERIAL		= 0x0004,
   VERBOSE_PIPELINE		= 0x0008,
   VERBOSE_DRIVER		= 0x0010,
   VERBOSE_STATE		= 0x0020,
   VERBOSE_API			= 0x0040,
   VERBOSE_DISPLAY_LIST		= 0x0100,
   VERBOSE_LIGHTING		= 0x0200,
   VERBOSE_PRIMS		= 0x0400,
   VERBOSE_VERTS		= 0x0800,
   VERBOSE_DISASSEM		= 0x1000,
   VERBOSE_DRAW                 = 0x2000,
   VERBOSE_SWAPBUFFERS          = 0x4000
};


/** The MESA_DEBUG_FLAGS var is a bitmask of these flags */
enum _debug
{
   DEBUG_SILENT                 = (1 << 0),
   DEBUG_ALWAYS_FLUSH		= (1 << 1),
   DEBUG_INCOMPLETE_TEXTURE     = (1 << 2),
   DEBUG_INCOMPLETE_FBO         = (1 << 3)
};



#ifdef __cplusplus
}
#endif

#endif /* MTYPES_H */
@


1.12
log
@Merge Mesa 10.2.9
@
text
@@


1.11
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d1345 2
a1434 3
   /** GL_ARB_clip_control */
   GLenum ClipOrigin;     /**< GL_LOWER_LEFT or GL_UPPER_LEFT */
   GLenum ClipDepthMode;  /**< GL_NEGATIVE_ONE_TO_ONE or GL_ZERO_TO_ONE */
a1469 10
 * Usages we've seen for a buffer object.
 */
typedef enum {
   USAGE_UNIFORM_BUFFER = 0x1,
   USAGE_TEXTURE_BUFFER = 0x2,
   USAGE_ATOMIC_COUNTER_BUFFER = 0x4,
} gl_buffer_usage;


/**
a1485 1
   gl_buffer_usage UsageHistory; /**< How has this buffer been used so far? */
a1504 4
   GLint CompressedBlockWidth;   /**< GL_ARB_compressed_texture_pixel_storage */
   GLint CompressedBlockHeight;
   GLint CompressedBlockDepth;
   GLint CompressedBlockSize;
d1527 1
d1630 6
a1640 11
/** Used to signal when transitioning from one kind of drawing method
 * to another.
 */
typedef enum {
   DRAW_NONE,          /**< Initial value only */
   DRAW_BEGIN_END,
   DRAW_DISPLAY_LIST,
   DRAW_ARRAYS
} gl_draw_method;


a1679 6

   /** One of the DRAW_xxx flags, not consumed by drivers */
   gl_draw_method DrawMethod;

   /** Legal array datatypes */
   GLbitfield LegalTypesMask;
a1789 1
   unsigned StreamId;
d2034 7
a2040 107
   /**
    * \name Vertex shader system values
    */
   /*@@{*/
   /**
    * OpenGL-style vertex ID.
    *
    * Section 2.11.7 (Shader Execution), subsection Shader Inputs, of the
    * OpenGL 3.3 core profile spec says:
    *
    *     "gl_VertexID holds the integer index i implicitly passed by
    *     DrawArrays or one of the other drawing commands defined in section
    *     2.8.3."
    *
    * Section 2.8.3 (Drawing Commands) of the same spec says:
    *
    *     "The commands....are equivalent to the commands with the same base
    *     name (without the BaseVertex suffix), except that the ith element
    *     transferred by the corresponding draw call will be taken from
    *     element indices[i] + basevertex of each enabled array."
    *
    * Additionally, the overview in the GL_ARB_shader_draw_parameters spec
    * says:
    *
    *     "In unextended GL, vertex shaders have inputs named gl_VertexID and
    *     gl_InstanceID, which contain, respectively the index of the vertex
    *     and instance. The value of gl_VertexID is the implicitly passed
    *     index of the vertex being processed, which includes the value of
    *     baseVertex, for those commands that accept it."
    *
    * gl_VertexID gets basevertex added in.  This differs from DirectX where
    * SV_VertexID does \b not get basevertex added in.
    *
    * \note
    * If all system values are available, \c SYSTEM_VALUE_VERTEX_ID will be
    * equal to \c SYSTEM_VALUE_VERTEX_ID_ZERO_BASE plus
    * \c SYSTEM_VALUE_BASE_VERTEX.
    *
    * \sa SYSTEM_VALUE_VERTEX_ID_ZERO_BASE, SYSTEM_VALUE_BASE_VERTEX
    */
   SYSTEM_VALUE_VERTEX_ID,

   /**
    * Instanced ID as supplied to gl_InstanceID
    *
    * Values assigned to gl_InstanceID always begin with zero, regardless of
    * the value of baseinstance.
    *
    * Section 11.1.3.9 (Shader Inputs) of the OpenGL 4.4 core profile spec
    * says:
    *
    *     "gl_InstanceID holds the integer instance number of the current
    *     primitive in an instanced draw call (see section 10.5)."
    *
    * Through a big chain of pseudocode, section 10.5 describes that
    * baseinstance is not counted by gl_InstanceID.  In that section, notice
    *
    *     "If an enabled vertex attribute array is instanced (it has a
    *     non-zero divisor as specified by VertexAttribDivisor), the element
    *     index that is transferred to the GL, for all vertices, is given by
    *
    *         floor(instance/divisor) + baseinstance
    *
    *     If an array corresponding to an attribute required by a vertex
    *     shader is not enabled, then the corresponding element is taken from
    *     the current attribute state (see section 10.2)."
    *
    * Note that baseinstance is \b not included in the value of instance.
    */
   SYSTEM_VALUE_INSTANCE_ID,

   /**
    * DirectX-style vertex ID.
    *
    * Unlike \c SYSTEM_VALUE_VERTEX_ID, this system value does \b not include
    * the value of basevertex.
    *
    * \sa SYSTEM_VALUE_VERTEX_ID, SYSTEM_VALUE_BASE_VERTEX
    */
   SYSTEM_VALUE_VERTEX_ID_ZERO_BASE,

   /**
    * Value of \c basevertex passed to \c glDrawElementsBaseVertex and similar
    * functions.
    *
    * \sa SYSTEM_VALUE_VERTEX_ID, SYSTEM_VALUE_VERTEX_ID_ZERO_BASE
    */
   SYSTEM_VALUE_BASE_VERTEX,
   /*@@}*/

   /**
    * \name Geometry shader system values
    */
   /*@@{*/
   SYSTEM_VALUE_INVOCATION_ID,
   /*@@}*/

   /**
    * \name Fragment shader system values
    */
   /*@@{*/
   SYSTEM_VALUE_FRONT_FACE,     /**< (not done yet) */
   SYSTEM_VALUE_SAMPLE_ID,
   SYSTEM_VALUE_SAMPLE_POS,
   SYSTEM_VALUE_SAMPLE_MASK_IN,
   /*@@}*/

d2175 1
a2175 2
   bool UsesEndPrimitive;
   bool UsesStreams;
d2281 3
a2314 14
 * Context state for compute programs.
 */
struct gl_compute_program_state
{
   struct gl_compute_program *Current;  /**< user-bound compute program */

   /** Currently enabled and valid program (including internal programs
    * and compiled shader programs).
    */
   struct gl_compute_program *_Current;
};


/**
d2559 1
a2559 1
    * Minimum size (in bytes) of a buffer object to back this uniform buffer
d2642 1
a2642 1
    * For the current set of transform feedback varyings used for transform
d2678 1
a2678 2
      bool UsesEndPrimitive;
      bool UsesStreams;
a2705 1
   unsigned NumHiddenUniforms;
a2749 1
   GLboolean SamplersValidated; /**< Samplers validated against texture units? */
a2890 1
   GLuint Stream;      /**< The stream */
d2907 2
a2908 2
   struct gl_query_object *PrimitivesGenerated[MAX_VERTEX_STREAMS];
   struct gl_query_object *PrimitivesWritten[MAX_VERTEX_STREAMS];
d3301 3
a3321 5
   /**
    * GL_ARB_explicit_uniform_location
    */
   GLuint MaxUserAssignableUniformLocations;

d3326 1
a3326 1
   GLuint GLSLVersion;  /**< Desktop GLSL version supported (ex: 120 = 1.20) */
a3340 5
    * Allow GLSL #extension directives in the middle of shaders.
    */
   GLboolean AllowGLSLExtensionDirectiveMidShader;

   /**
a3346 9
    * Does VertexID count from zero or from base vertex?
    *
    * \note
    * If desktop GLSL 1.30 or GLSL ES 3.00 are not supported, this field is
    * ignored and need not be set.
    */
   bool VertexID_is_zero_based;

   /**
d3352 3
a3368 3
   /** OpenGL version 4.4 */
   GLuint MaxVertexAttribStride;

d3412 5
a3435 13
   /**
    * Should meaningful names be generated for compiler temporary variables?
    *
    * Generally, it is not useful to have the compiler generate "meaningful"
    * names for temporary variables that it creates.  This can, however, be a
    * useful debugging aid.  In Mesa debug builds or release builds when
    * MESA_GLSL is set at run-time, meaningful names will be generated.
    * Drivers can also force names to be generated by setting this field.
    * For example, the i965 driver may set it when INTEL_DEBUG=vs (to dump
    * vertex shader assembly) is set at run-time.
    */
   bool GenerateTemporaryNames;

a3457 32
   /**
    * GL_EXT_texture_multisample_blit_scaled implementation assumes that
    * samples are laid out in a rectangular grid roughly corresponding to
    * sample locations within a pixel. Below SampleMap{2,4,8}x variables
    * are used to map indices of rectangular grid to sample numbers within
    * a pixel. This mapping of indices to sample numbers must be initialized
    * by the driver for the target hardware. For example, if we have the 8X
    * MSAA sample number layout (sample positions) for XYZ hardware:
    *
    *        sample indices layout          sample number layout
    *            ---------                      ---------
    *            | 0 | 1 |                      | a | b |
    *            ---------                      ---------
    *            | 2 | 3 |                      | c | d |
    *            ---------                      ---------
    *            | 4 | 5 |                      | e | f |
    *            ---------                      ---------
    *            | 6 | 7 |                      | g | h |
    *            ---------                      ---------
    *
    * Where a,b,c,d,e,f,g,h are integers between [0-7].
    *
    * Then, initialize the SampleMap8x variable for XYZ hardware as shown
    * below:
    *    SampleMap8x = {a, b, c, d, e, f, g, h};
    *
    * Follow the logic for other sample counts.
    */
   uint8_t SampleMap2x[2];
   uint8_t SampleMap4x[4];
   uint8_t SampleMap8x[8];

a3483 5

   /** GL_KHR_context_flush_control */
   GLenum ContextReleaseBehavior;

   struct gl_shader_compiler_options ShaderCompilerOptions[MESA_SHADER_STAGES];
a3502 2
   GLboolean ARB_clear_texture;
   GLboolean ARB_clip_control;
a3504 1
   GLboolean ARB_conditional_render_inverted;
a3505 1
   GLboolean ARB_copy_image;
a3508 1
   GLboolean ARB_derivative_control;
a3513 1
   GLboolean ARB_fragment_layer_viewport;
a3518 1
   GLboolean ARB_explicit_uniform_location;
a3543 1
   GLboolean ARB_texture_compression_bptc;
a3608 1
   GLboolean AMD_vertex_shader_viewport_index;
d3610 1
d3854 1
a3854 1
   uint64_t NewArray;
d3857 1
a3857 1
   uint64_t NewTransformFeedback;
d3860 1
a3860 1
   uint64_t NewTransformFeedbackProg;
d3863 1
a3863 1
   uint64_t NewRasterizerDiscard;
d3869 1
a3869 3
   uint64_t NewUniformBuffer;

   uint64_t NewTextureBuffer;
d3874 1
a3874 1
   uint64_t NewAtomicBuffer;
d3879 1
a3879 1
   uint64_t NewImageUnits;
a4098 1
   struct gl_compute_program_state ComputeProgram;
d4123 2
a4183 1
   mtx_t DebugMutex;
d4188 1
a4188 1
   uint64_t NewDriverState;  /**< bitwise-or of flags from DriverFlags */
@


1.10
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@a1344 2
   GLenum BumpTarget;
   GLfloat RotMatrix[4]; /* 2x2 matrix */
d1433 3
d1471 10
d1497 1
d1517 4
a1542 1
   GLuint _MaxElement;          /**< max element index into array buffer + 1 */
a1644 6
   /**
    * Min of all enabled arrays' _MaxElement.  When arrays reside inside VBOs
    * we can determine the max legal (in bounds) glDrawElements array index.
    */
   GLuint _MaxElement;

d1650 11
d1700 6
d1816 1
d2061 107
a2167 7
   SYSTEM_VALUE_FRONT_FACE,     /**< Fragment shader only (not done yet) */
   SYSTEM_VALUE_VERTEX_ID,      /**< Vertex shader only */
   SYSTEM_VALUE_INSTANCE_ID,    /**< Vertex shader only */
   SYSTEM_VALUE_SAMPLE_ID,      /**< Fragment shader only */
   SYSTEM_VALUE_SAMPLE_POS,     /**< Fragment shader only */
   SYSTEM_VALUE_SAMPLE_MASK_IN, /**< Fragment shader only */
   SYSTEM_VALUE_INVOCATION_ID,  /**< Geometry shader only */
d2302 2
a2303 1
   GLboolean UsesEndPrimitive;
a2408 3

   /** Cache of fixed-function programs */
   struct gl_program_cache *Cache;
d2440 14
d2698 1
a2698 1
    * Minimum size of a buffer object to back this uniform buffer
d2781 1
a2781 1
    * For the current set of transform feeedback varyings used for transform
d2817 2
a2818 1
      GLboolean UsesEndPrimitive;
d2846 1
d2891 1
d3033 1
d3050 2
a3051 2
   struct gl_query_object *PrimitivesGenerated;
   struct gl_query_object *PrimitivesWritten;
a3443 3
   /** vertex array / buffer object bounds checking */
   GLboolean CheckArrayBounds;

d3462 5
d3471 1
a3471 1
   GLuint GLSLVersion;  /**< GLSL version supported (ex: 120 = 1.20) */
d3486 5
d3497 9
a3510 3
   /** Which texture units support GL_ATI_envmap_bumpmap as targets */
   GLbitfield SupportedBumpUnits;

d3525 3
a3570 5
    * Force software support for primitive restart in the VBO module.
    */
   GLboolean PrimitiveRestartInSoftware;

   /**
d3590 13
d3625 32
d3683 5
d3707 2
d3711 1
d3713 1
d3717 1
d3723 1
d3729 1
d3755 1
d3821 1
a3822 1
   GLboolean ATI_envmap_bumpmap;
d4066 1
a4066 1
   GLbitfield NewArray;
d4069 1
a4069 1
   GLbitfield NewTransformFeedback;
d4072 1
a4072 1
   GLbitfield NewTransformFeedbackProg;
d4075 1
a4075 1
   GLbitfield NewRasterizerDiscard;
d4081 3
a4083 1
   GLbitfield NewUniformBuffer;
d4088 1
a4088 1
   GLbitfield NewAtomicBuffer;
d4093 1
a4093 1
   GLbitfield NewImageUnits;
d4313 1
a4337 2
   struct gl_shader_compiler_options ShaderCompilerOptions[MESA_SHADER_STAGES];

d4397 1
d4402 1
a4402 1
   GLbitfield NewDriverState;/**< bitwise-or of flags from DriverFlags */
@


1.9
log
@Merge Mesa 9.2.0
@
text
@d37 3
d79 1
d87 1
d239 1
d275 1
d281 6
d319 1
d325 1
a325 1
   FRAG_RESULT_DATA0 = 3,
d399 18
d904 2
d1016 1
a1016 1
struct gl_scissor_attrib
a1017 1
   GLboolean Enabled;		/**< Scissor test enabled? */
d1021 5
a1088 1
 * Used for Texture.Unit[]._ReallyEnabled flags.
d1119 1
a1119 1
   gl_format TexFormat;         /**< The actual texture memory format */
d1168 1
d1193 7
a1199 4
   _glthread_Mutex Mutex;	/**< for thread safety */
   GLint RefCount;		/**< reference count */
   GLuint Name;			/**< the user-visible texture object ID */
   GLenum Target;               /**< GL_TEXTURE_1D, GL_TEXTURE_2D, etc. */
d1203 2
a1204 1
   GLenum DepthMode;		/**< GL_ARB_depth_texture */
d1206 22
a1227 16
   GLfloat Priority;		/**< in [0,1] */
   GLint BaseLevel;		/**< min mipmap level, OpenGL 1.2 */
   GLint MaxLevel;		/**< max mipmap level, OpenGL 1.2 */
   GLint ImmutableLevels;       /**< ES 3.0 / ARB_texture_view */
   GLint _MaxLevel;		/**< actual max mipmap level (q in the spec) */
   GLfloat _MaxLambda;		/**< = _MaxLevel - BaseLevel (q - b in spec) */
   GLint CropRect[4];           /**< GL_OES_draw_texture */
   GLenum Swizzle[4];           /**< GL_EXT_texture_swizzle */
   GLuint _Swizzle;             /**< same as Swizzle, but SWIZZLE_* format */
   GLboolean GenerateMipmap;    /**< GL_SGIS_generate_mipmap */
   GLboolean _BaseComplete;     /**< Is the base texture level valid? */
   GLboolean _MipmapComplete;   /**< Is the whole mipmap valid? */
   GLboolean _IsIntegerFormat;  /**< Does the texture store integer values? */
   GLboolean _RenderToTexture;  /**< Any rendering to this texture? */
   GLboolean Purgeable;         /**< Is the buffer purgeable under memory pressure? */
   GLboolean Immutable;         /**< GL_ARB_texture_storage */
d1236 1
a1236 1
   gl_format _BufferObjectFormat;
d1243 3
a1331 1
   GLbitfield _ReallyEnabled;   /**< 0 or exactly one of TEXTURE_*_BIT flags */
d1373 3
a1394 3
   /** Texture units/samplers used by vertex or fragment texturing */
   GLbitfield _EnabledUnits;

d1406 6
a1434 3

   GLfloat CullEyePos[4];
   GLfloat CullObjPos[4];
d1443 3
a1445 3
   GLint X, Y;			/**< position */
   GLsizei Width, Height;	/**< size */
   GLfloat Near, Far;		/**< Depth buffer range */
d1450 19
d1474 1
a1474 1
   _glthread_Mutex Mutex;
d1477 1
d1479 1
a1481 7
   /** Fields describing a mapped buffer */
   /*@@{*/
   GLbitfield AccessFlags; /**< Mask of GL_MAP_x_BIT flags */
   GLvoid *Pointer;     /**< User-space address of mapping */
   GLintptr Offset;     /**< Mapped offset */
   GLsizeiptr Length;   /**< Mapped length */
   /*@@}*/
d1485 3
d1532 32
a1563 2
 * Collection of vertex arrays.  Defined by the GL_APPLE_vertex_array_object
 * extension, but a nice encapsulation in any case.
d1565 1
a1565 1
struct gl_array_object
d1567 16
a1582 1
   /** Name of the array object as received from glGenVertexArrayAPPLE. */
d1584 1
d1587 1
a1587 1
   _glthread_Mutex Mutex;
d1610 8
d1619 4
a1622 1
   struct gl_client_array VertexAttrib[VERT_ATTRIB_MAX];
d1627 3
d1636 2
a1637 1
   struct gl_buffer_object *ElementArrayBufferObj;
d1647 1
a1647 1
   struct gl_array_object *ArrayObj;
d1650 1
a1650 1
   struct gl_array_object *DefaultArrayObj;
d1837 1
d1846 8
d1908 93
d2006 3
a2008 4
 * NOTE: PROGRAM_ENV_PARAM, PROGRAM_STATE_VAR,
 * PROGRAM_CONSTANT, and PROGRAM_UNIFORM can all be considered to
 * be "uniform" variables since they can only be set outside glBegin/End.
 * They're also all stored in the same Parameters array.
a2015 2
   PROGRAM_LOCAL_PARAM, /**< gl_program->LocalParams[] */
   PROGRAM_ENV_PARAM,   /**< gl_program->Parameters[] */
d2034 8
a2041 4
   SYSTEM_VALUE_FRONT_FACE,  /**< Fragment shader only (not done yet) */
   SYSTEM_VALUE_VERTEX_ID,   /**< Vertex shader only */
   SYSTEM_VALUE_INSTANCE_ID, /**< Vertex shader only */
   SYSTEM_VALUE_MAX          /**< Number of values */
d2088 1
a2088 1
   GLenum Target;    /**< GL_VERTEX/FRAGMENT_PROGRAM_ARB */
d2102 8
d2113 9
a2121 2
   /** Numbered local parameters */
   GLfloat LocalParams[MAX_PROGRAM_LOCAL_PARAMS][4];
a2160 1
   GLboolean UsesClipDistance;
d2169 1
d2171 1
d2175 1
d2201 18
d2376 1
d2378 1
d2431 1
a2431 2
    * The offsets of the variables are assigned only for shaders in a program's
    * _LinkedShaders[].
d2439 52
a2490 4
   /** Shaders containing built-in functions that are used for linking. */
   struct gl_shader *builtins_to_link[16];
   unsigned num_builtins_to_link;
};
d2492 6
d2499 11
a2509 14
/**
 * Shader stages. Note that these will become 5 with tessellation.
 *
 * The order must match how shaders are ordered in the pipeline.
 * The GLSL linker assumes that if i<j, then the j-th shader is
 * executed later than the i-th shader.
 */
typedef enum
{
   MESA_SHADER_VERTEX = 0,
   MESA_SHADER_GEOMETRY = 1,
   MESA_SHADER_FRAGMENT = 2,
   MESA_SHADER_TYPES = 3
} gl_shader_type;
d2573 19
d2601 1
d2611 2
a2612 7
    * Flags that the linker should not reject the program if it lacks
    * a vertex or fragment shader.  GLES2 doesn't allow separate
    * shader objects, and would reject them.  However, we internally
    * build separate shader objects for fixed function programs, which
    * we use for drivers/common/meta.c and for handling
    * _mesa_update_state with no program bound (for example in
    * glClear()).
d2614 1
a2614 1
   GLboolean InternalSeparateShader;
d2657 4
a2660 1
   /** Geometry shader state - copied into gl_geometry_program at link time */
d2662 1
d2664 4
d2671 8
d2681 1
a2681 1
   /** Vertex shader state - copied into gl_vertex_program at link time */
d2683 5
a2687 1
      GLboolean UsesClipDistance; /**< True if gl_ClipDistance is written to. */
d2692 12
d2708 7
a2714 2
   struct gl_uniform_block *UniformBlocks;
   unsigned NumUniformBlocks;
d2717 2
a2718 11
    * Scale factor for the uniform base location
    *
    * This is used to generate locations (returned by \c glGetUniformLocation)
    * of uniforms.  The base location of the uniform is multiplied by this
    * value, and the array index is added.
    *
    * \note
    * Must be >= 1.
    *
    * \sa
    * _mesa_uniform_merge_location_offset, _mesa_uniform_split_location_offset
d2720 4
a2723 1
   unsigned UniformLocationBaseScale;
d2732 1
a2732 1
   int *UniformBlockStageIndex[MESA_SHADER_TYPES];
d2744 3
d2762 6
a2767 1
   struct gl_shader *_LinkedShaders[MESA_SHADER_TYPES];
d2780 1
d2785 1
d2787 1
a2787 1
struct gl_shader_state
d2789 9
d2801 3
a2803 7
    * There is a separate program set for each shader stage.  If
    * GL_EXT_separate_shader_objects is not supported, each of these must point
    * to \c NULL or to the same program.
    */
   struct gl_shader_program *CurrentVertexProgram;
   struct gl_shader_program *CurrentGeometryProgram;
   struct gl_shader_program *CurrentFragmentProgram;
d2815 6
d2823 14
d2867 5
a2871 2
    * Prefer DP4 instructions (rather than MUL/MAD) for matrix * vector
    * operations, such as position transformation.
d2873 1
a2873 1
   GLboolean PreferDP4;
d2886 1
d2922 1
d2938 1
a2938 1
   _glthread_Mutex Mutex;		   /**< for thread safety */
d2956 1
a2956 1
   _glthread_Mutex TexMutex;		/**< texobj thread safety */
d2991 11
d3013 1
a3013 1
   _glthread_Mutex Mutex; /**< for thread safety */
d3016 1
d3035 1
a3035 1
   gl_format Format;      /**< The actual renderbuffer memory format */
d3091 1
a3091 1
   _glthread_Mutex Mutex;  /**< for thread safety */
d3100 1
d3152 6
a3157 1
   GLboolean Layered;
d3203 24
d3234 7
d3282 6
d3289 1
a3289 3
   struct gl_program_constants VertexProgram;   /**< GL_ARB_vertex_program */
   struct gl_program_constants FragmentProgram; /**< GL_ARB_fragment_program */
   struct gl_program_constants GeometryProgram;  /**< GL_ARB_geometry_shader4 */
a3311 1
   GLuint MaxVaryingComponents;
d3378 5
d3416 6
d3457 27
d3499 1
d3502 1
d3504 1
d3511 1
a3520 1
   GLboolean ARB_half_float_pixel;
a3523 1
   GLboolean ARB_map_buffer_alignment;
d3528 1
d3530 1
d3532 1
d3538 1
d3551 2
d3555 2
d3560 1
d3568 1
d3570 1
a3576 1
   GLboolean EXT_framebuffer_blit;
a3581 1
   GLboolean EXT_packed_depth_stencil;
d3586 1
a3586 1
   GLboolean EXT_separate_shader_objects;
d3606 1
d3616 1
a3618 1
   GLboolean MESA_texture_array;
d3627 1
d3756 1
d3792 2
a3793 2
 * These are a mapping of the GL_ARB_debug_output enums to small enums
 * suitable for use as an array index.
d3813 3
d3823 1
a3829 36
 * An error, warning, or other piece of debug information for an application
 * to consume via GL_ARB_debug_output.
 */
struct gl_debug_msg
{
   enum mesa_debug_source source;
   enum mesa_debug_type type;
   GLuint id;
   enum mesa_debug_severity severity;
   GLsizei length;
   GLcharARB *message;
};

struct gl_debug_namespace
{
   struct _mesa_HashTable *IDs;
   unsigned ZeroID; /* a HashTable won't take zero, so store its state here */
   /** lists of IDs in the hash table at each severity */
   struct simple_node Severity[MESA_DEBUG_SEVERITY_COUNT];
};

struct gl_debug_state
{
   GLDEBUGPROCARB Callback;
   const void *CallbackData;
   GLboolean SyncOutput;
   GLboolean Defaults[MESA_DEBUG_SEVERITY_COUNT][MESA_DEBUG_SOURCE_COUNT][MESA_DEBUG_TYPE_COUNT];
   struct gl_debug_namespace Namespaces[MESA_DEBUG_SOURCE_COUNT][MESA_DEBUG_TYPE_COUNT];
   struct gl_debug_msg Log[MAX_DEBUG_LOGGED_MESSAGES];
   GLint NumMessages;
   GLint NextMsg;
   GLint NextMsgLength; /* redundant, but copied here from Log[NextMsg].length
                           for the sake of the offsetof() code in get.c */
};

/**
d3859 3
d3870 10
d3897 64
a3966 2
 *
 * The struct gl_context typedef names this structure.
d4070 1
a4070 1
   struct gl_viewport_attrib	Viewport;	/**< Viewport attributes */
d4101 23
a4123 2
   struct gl_shader_state Shader; /**< GLSL shader object state */
   struct gl_shader_compiler_options ShaderCompilerOptions[MESA_SHADER_TYPES];
d4129 4
d4151 17
a4176 3
   /* GL_ARB_robustness */
   GLenum ResetStatus;

d4183 2
a4184 2
   /* GL_ARB_debug_output */
   struct gl_debug_state Debug;
d4212 6
d4234 1
a4234 1
   void *swtnl_im;
d4238 16
@


1.8
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a2 1
 * Version:  7.7
d20 4
a23 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
a38 1
#include "main/mfeatures.h"
d45 2
a46 32
/**
 * Color channel data type.
 */
#if CHAN_BITS == 8
   typedef GLubyte GLchan;
#define CHAN_MAX 255
#define CHAN_MAXF 255.0F
#define CHAN_TYPE GL_UNSIGNED_BYTE
#elif CHAN_BITS == 16
   typedef GLushort GLchan;
#define CHAN_MAX 65535
#define CHAN_MAXF 65535.0F
#define CHAN_TYPE GL_UNSIGNED_SHORT
#elif CHAN_BITS == 32
   typedef GLfloat GLchan;
#define CHAN_MAX 1.0
#define CHAN_MAXF 1.0F
#define CHAN_TYPE GL_FLOAT
#else
#error "illegal number of color channel bits"
#endif


/**
 * Stencil buffer data type.
 */
#if STENCIL_BITS==8
   typedef GLubyte GLstencil;
#elif STENCIL_BITS==16
   typedef GLushort GLstencil;
#else
#  error "illegal number of stencil bits"
d58 6
a73 1
struct gl_pixelstore_attrib;
a74 2
struct gl_texture_format;
struct gl_texture_image;
d78 5
d87 3
a89 16
#define PRIM_OUTSIDE_BEGIN_END   (GL_POLYGON+1)
#define PRIM_INSIDE_UNKNOWN_PRIM (GL_POLYGON+2)
#define PRIM_UNKNOWN             (GL_POLYGON+3)


/**
 * Shader stages. Note that these will become 5 with tessellation.
 * These MUST have the same values as gallium's PIPE_SHADER_*
 */
typedef enum
{
   MESA_SHADER_VERTEX = 0,
   MESA_SHADER_FRAGMENT = 1,
   MESA_SHADER_GEOMETRY = 2,
   MESA_SHADER_TYPES = 3
} gl_shader_type;
a108 1
   VERT_ATTRIB_POINT_SIZE = 6,  /*alias*/
d118 18
a135 17
   VERT_ATTRIB_GENERIC0 = 16,
   VERT_ATTRIB_GENERIC1 = 17,
   VERT_ATTRIB_GENERIC2 = 18,
   VERT_ATTRIB_GENERIC3 = 19,
   VERT_ATTRIB_GENERIC4 = 20,
   VERT_ATTRIB_GENERIC5 = 21,
   VERT_ATTRIB_GENERIC6 = 22,
   VERT_ATTRIB_GENERIC7 = 23,
   VERT_ATTRIB_GENERIC8 = 24,
   VERT_ATTRIB_GENERIC9 = 25,
   VERT_ATTRIB_GENERIC10 = 26,
   VERT_ATTRIB_GENERIC11 = 27,
   VERT_ATTRIB_GENERIC12 = 28,
   VERT_ATTRIB_GENERIC13 = 29,
   VERT_ATTRIB_GENERIC14 = 30,
   VERT_ATTRIB_GENERIC15 = 31,
   VERT_ATTRIB_MAX = 32
d139 23
d166 31
a196 35
#define VERT_BIT_POS         (1 << VERT_ATTRIB_POS)
#define VERT_BIT_WEIGHT      (1 << VERT_ATTRIB_WEIGHT)
#define VERT_BIT_NORMAL      (1 << VERT_ATTRIB_NORMAL)
#define VERT_BIT_COLOR0      (1 << VERT_ATTRIB_COLOR0)
#define VERT_BIT_COLOR1      (1 << VERT_ATTRIB_COLOR1)
#define VERT_BIT_FOG         (1 << VERT_ATTRIB_FOG)
#define VERT_BIT_COLOR_INDEX (1 << VERT_ATTRIB_COLOR_INDEX)
#define VERT_BIT_EDGEFLAG    (1 << VERT_ATTRIB_EDGEFLAG)
#define VERT_BIT_TEX0        (1 << VERT_ATTRIB_TEX0)
#define VERT_BIT_TEX1        (1 << VERT_ATTRIB_TEX1)
#define VERT_BIT_TEX2        (1 << VERT_ATTRIB_TEX2)
#define VERT_BIT_TEX3        (1 << VERT_ATTRIB_TEX3)
#define VERT_BIT_TEX4        (1 << VERT_ATTRIB_TEX4)
#define VERT_BIT_TEX5        (1 << VERT_ATTRIB_TEX5)
#define VERT_BIT_TEX6        (1 << VERT_ATTRIB_TEX6)
#define VERT_BIT_TEX7        (1 << VERT_ATTRIB_TEX7)
#define VERT_BIT_GENERIC0    (1 << VERT_ATTRIB_GENERIC0)
#define VERT_BIT_GENERIC1    (1 << VERT_ATTRIB_GENERIC1)
#define VERT_BIT_GENERIC2    (1 << VERT_ATTRIB_GENERIC2)
#define VERT_BIT_GENERIC3    (1 << VERT_ATTRIB_GENERIC3)
#define VERT_BIT_GENERIC4    (1 << VERT_ATTRIB_GENERIC4)
#define VERT_BIT_GENERIC5    (1 << VERT_ATTRIB_GENERIC5)
#define VERT_BIT_GENERIC6    (1 << VERT_ATTRIB_GENERIC6)
#define VERT_BIT_GENERIC7    (1 << VERT_ATTRIB_GENERIC7)
#define VERT_BIT_GENERIC8    (1 << VERT_ATTRIB_GENERIC8)
#define VERT_BIT_GENERIC9    (1 << VERT_ATTRIB_GENERIC9)
#define VERT_BIT_GENERIC10   (1 << VERT_ATTRIB_GENERIC10)
#define VERT_BIT_GENERIC11   (1 << VERT_ATTRIB_GENERIC11)
#define VERT_BIT_GENERIC12   (1 << VERT_ATTRIB_GENERIC12)
#define VERT_BIT_GENERIC13   (1 << VERT_ATTRIB_GENERIC13)
#define VERT_BIT_GENERIC14   (1 << VERT_ATTRIB_GENERIC14)
#define VERT_BIT_GENERIC15   (1 << VERT_ATTRIB_GENERIC15)

#define VERT_BIT_TEX(u)  (1 << (VERT_ATTRIB_TEX0 + (u)))
#define VERT_BIT_GENERIC(g)  (1 << (VERT_ATTRIB_GENERIC0 + (g)))
d201 9
a209 1
 * Indexes for vertex program result attributes
d213 26
a238 22
   VERT_RESULT_HPOS = 0,
   VERT_RESULT_COL0 = 1,
   VERT_RESULT_COL1 = 2,
   VERT_RESULT_FOGC = 3,
   VERT_RESULT_TEX0 = 4,
   VERT_RESULT_TEX1 = 5,
   VERT_RESULT_TEX2 = 6,
   VERT_RESULT_TEX3 = 7,
   VERT_RESULT_TEX4 = 8,
   VERT_RESULT_TEX5 = 9,
   VERT_RESULT_TEX6 = 10,
   VERT_RESULT_TEX7 = 11,
   VERT_RESULT_PSIZ = 12,
   VERT_RESULT_BFC0 = 13,
   VERT_RESULT_BFC1 = 14,
   VERT_RESULT_EDGE = 15,
   VERT_RESULT_VAR0 = 16,  /**< shader varying */
   VERT_RESULT_MAX = (VERT_RESULT_VAR0 + MAX_VARYING)
} gl_vert_result;


/*********************************************/
a239 19
/**
 * Indexes for geometry program attributes.
 */
typedef enum
{
   GEOM_ATTRIB_POSITION = 0,
   GEOM_ATTRIB_COLOR0 = 1,
   GEOM_ATTRIB_COLOR1 = 2,
   GEOM_ATTRIB_SECONDARY_COLOR0 = 3,
   GEOM_ATTRIB_SECONDARY_COLOR1 = 4,
   GEOM_ATTRIB_FOG_FRAG_COORD = 5,
   GEOM_ATTRIB_POINT_SIZE = 6,
   GEOM_ATTRIB_CLIP_VERTEX = 7,
   GEOM_ATTRIB_PRIMITIVE_ID = 8,
   GEOM_ATTRIB_TEX_COORD = 9,

   GEOM_ATTRIB_VAR0 = 16,
   GEOM_ATTRIB_MAX = (GEOM_ATTRIB_VAR0 + MAX_VARYING)
} gl_geom_attrib;
d242 1
a242 2
 * Bitflags for geometry attributes.
 * These are used in bitfields in many places.
d245 27
a271 13
#define GEOM_BIT_COLOR0      (1 << GEOM_ATTRIB_COLOR0)
#define GEOM_BIT_COLOR1      (1 << GEOM_ATTRIB_COLOR1)
#define GEOM_BIT_SCOLOR0     (1 << GEOM_ATTRIB_SECONDARY_COLOR0)
#define GEOM_BIT_SCOLOR1     (1 << GEOM_ATTRIB_SECONDARY_COLOR1)
#define GEOM_BIT_TEX_COORD   (1 << GEOM_ATTRIB_TEX_COORD)
#define GEOM_BIT_FOG_COORD   (1 << GEOM_ATTRIB_FOG_FRAG_COORD)
#define GEOM_BIT_POSITION    (1 << GEOM_ATTRIB_POSITION)
#define GEOM_BIT_POINT_SIDE  (1 << GEOM_ATTRIB_POINT_SIZE)
#define GEOM_BIT_CLIP_VERTEX (1 << GEOM_ATTRIB_CLIP_VERTEX)
#define GEOM_BIT_PRIM_ID     (1 << GEOM_ATTRIB_PRIMITIVE_ID)
#define GEOM_BIT_VAR0        (1 << GEOM_ATTRIB_VAR0)

#define GEOM_BIT_VAR(g)  (1 << (GEOM_BIT_VAR0 + (g)))
d276 1
a276 30
 * Indexes for geometry program result attributes
 */
typedef enum
{
   GEOM_RESULT_POS  = 0,
   GEOM_RESULT_COL0  = 1,
   GEOM_RESULT_COL1  = 2,
   GEOM_RESULT_SCOL0 = 3,
   GEOM_RESULT_SCOL1 = 4,
   GEOM_RESULT_FOGC = 5,
   GEOM_RESULT_TEX0 = 6,
   GEOM_RESULT_TEX1 = 7,
   GEOM_RESULT_TEX2 = 8,
   GEOM_RESULT_TEX3 = 9,
   GEOM_RESULT_TEX4 = 10,
   GEOM_RESULT_TEX5 = 11,
   GEOM_RESULT_TEX6 = 12,
   GEOM_RESULT_TEX7 = 13,
   GEOM_RESULT_PSIZ = 14,
   GEOM_RESULT_CLPV = 15,
   GEOM_RESULT_PRID = 16,
   GEOM_RESULT_LAYR = 17,
   GEOM_RESULT_VAR0 = 18,  /**< shader varying, should really be 16 */
   /* ### we need to -2 because var0 is 18 instead 16 like in the others */
   GEOM_RESULT_MAX  =  (GEOM_RESULT_VAR0 + MAX_VARYING - 2)
} gl_geom_result;


/**
 * Indexes for fragment program input attributes.
d278 2
a279 1
typedef enum
d281 12
a292 50
   FRAG_ATTRIB_WPOS = 0,
   FRAG_ATTRIB_COL0 = 1,
   FRAG_ATTRIB_COL1 = 2,
   FRAG_ATTRIB_FOGC = 3,
   FRAG_ATTRIB_TEX0 = 4,
   FRAG_ATTRIB_TEX1 = 5,
   FRAG_ATTRIB_TEX2 = 6,
   FRAG_ATTRIB_TEX3 = 7,
   FRAG_ATTRIB_TEX4 = 8,
   FRAG_ATTRIB_TEX5 = 9,
   FRAG_ATTRIB_TEX6 = 10,
   FRAG_ATTRIB_TEX7 = 11,
   FRAG_ATTRIB_FACE = 12,  /**< front/back face */
   FRAG_ATTRIB_PNTC = 13,  /**< sprite/point coord */
   FRAG_ATTRIB_VAR0 = 14,  /**< shader varying */
   FRAG_ATTRIB_MAX = (FRAG_ATTRIB_VAR0 + MAX_VARYING)
} gl_frag_attrib;

/**
 * Bitflags for fragment program input attributes.
 */
/*@@{*/
#define FRAG_BIT_WPOS  (1 << FRAG_ATTRIB_WPOS)
#define FRAG_BIT_COL0  (1 << FRAG_ATTRIB_COL0)
#define FRAG_BIT_COL1  (1 << FRAG_ATTRIB_COL1)
#define FRAG_BIT_FOGC  (1 << FRAG_ATTRIB_FOGC)
#define FRAG_BIT_FACE  (1 << FRAG_ATTRIB_FACE)
#define FRAG_BIT_PNTC  (1 << FRAG_ATTRIB_PNTC)
#define FRAG_BIT_TEX0  (1 << FRAG_ATTRIB_TEX0)
#define FRAG_BIT_TEX1  (1 << FRAG_ATTRIB_TEX1)
#define FRAG_BIT_TEX2  (1 << FRAG_ATTRIB_TEX2)
#define FRAG_BIT_TEX3  (1 << FRAG_ATTRIB_TEX3)
#define FRAG_BIT_TEX4  (1 << FRAG_ATTRIB_TEX4)
#define FRAG_BIT_TEX5  (1 << FRAG_ATTRIB_TEX5)
#define FRAG_BIT_TEX6  (1 << FRAG_ATTRIB_TEX6)
#define FRAG_BIT_TEX7  (1 << FRAG_ATTRIB_TEX7)
#define FRAG_BIT_VAR0  (1 << FRAG_ATTRIB_VAR0)

#define FRAG_BIT_TEX(U)  (FRAG_BIT_TEX0 << (U))
#define FRAG_BIT_VAR(V)  (FRAG_BIT_VAR0 << (V))

#define FRAG_BITS_TEX_ANY (FRAG_BIT_TEX0|	\
			   FRAG_BIT_TEX1|	\
			   FRAG_BIT_TEX2|	\
			   FRAG_BIT_TEX3|	\
			   FRAG_BIT_TEX4|	\
			   FRAG_BIT_TEX5|	\
			   FRAG_BIT_TEX6|	\
			   FRAG_BIT_TEX7)
/*@@}*/
a449 19
 * Data structure for color tables
 */
struct gl_color_table
{
   GLenum InternalFormat;      /**< The user-specified format */
   GLenum _BaseFormat;         /**< GL_ALPHA, GL_RGBA, GL_RGB, etc */
   GLuint Size;                /**< number of entries in table */
   GLfloat *TableF;            /**< Color table, floating point values */
   GLubyte *TableUB;           /**< Color table, ubyte values */
   GLubyte RedSize;
   GLubyte GreenSize;
   GLubyte BlueSize;
   GLubyte AlphaSize;
   GLubyte LuminanceSize;
   GLubyte IntensitySize;
};


/**
a509 3
#define EXP_TABLE_SIZE 512	/**< Specular exponent lookup table sizes */
#define SHINE_TABLE_SIZE 256	/**< Material shininess lookup table sizes */

d511 1
a511 1
 * Material shininess lookup table.
d513 1
a513 1
struct gl_shine_tab
d515 1
a515 4
   struct gl_shine_tab *next, *prev;
   GLfloat tab[SHINE_TABLE_SIZE+1];
   GLfloat shininess;
   GLuint refcount;
d520 11
a544 1
   GLfloat _CosCutoffNeg;	/**< = cos(SpotCutoff) */
d555 1
a555 1
   GLbitfield _Flags;		/**< State */
a562 1
   GLfloat _SpotExpTable[EXP_TABLE_SIZE][2];  /**< to replace a pow() call */
a565 2
   GLfloat _dli;		/**< CI diffuse light intensity */
   GLfloat _sli;		/**< CI specular light intensity */
d584 1
a584 1
 * Material state.
d586 1
a586 1
struct gl_material
d588 1
a588 1
   GLfloat Attrib[MAT_ATTRIB_MAX][4];
d593 2
a594 1
 * Accumulation buffer attribute group (GL_ACCUM_BUFFER_BIT)
d596 1
a596 1
struct gl_accum_attrib
d598 3
a600 1
   GLfloat ClearColor[4];	/**< Accumulation buffer clear color */
d609 4
a612 6
   GLuint ClearIndex;			/**< Index to use for glClear */
   GLfloat ClearColorUnclamped[4];              /**< Color to use for glClear*/
   GLclampf ClearColor[4];               /**< Color to use for glClear */

   GLuint IndexMask;			/**< Color index write mask */
   GLubyte ColorMask[MAX_DRAW_BUFFERS][4];/**< Each flag is 0xff or 0x0 */
d632 2
a633 2
   /* NOTE: this does _not_ depend on fragment clamping or any other clamping control,
    * only on the fixed-pointness of the render target.
d647 5
a665 1
   GLboolean _LogicOpEnabled;		/**< RGBA logic op + EXT_blend_logic_op enabled flag */
a672 1
   GLboolean _ClampReadColor;     /** < with GL_FIXED_ONLY_ARB resolved */
d674 1
a674 1
   GLboolean sRGBEnabled;	/**< Framebuffer sRGB blending/updating requested */
a737 1
   GLboolean Map1Attrib[16];  /* GL_NV_vertex_program */
a746 1
   GLboolean Map2Attrib[16];  /* GL_NV_vertex_program */
d779 1
a779 17
};


/**
 * \brief Layout qualifiers for gl_FragDepth.
 *
 * Extension AMD_conservative_depth allows gl_FragDepth to be redeclared with
 * a layout qualifier.
 *
 * \see enum ir_depth_layout
 */
enum gl_frag_depth_layout {
    FRAG_DEPTH_LAYOUT_NONE, /**< No layout is specified. */
    FRAG_DEPTH_LAYOUT_ANY,
    FRAG_DEPTH_LAYOUT_GREATER,
    FRAG_DEPTH_LAYOUT_LESS,
    FRAG_DEPTH_LAYOUT_UNCHANGED
a794 1
   GLenum ClipVolumeClipping;   /**< GL_EXT_clip_volume_hint */
a799 10
/**
 * Light state flags.
 */
/*@@{*/
#define LIGHT_SPOT         0x1
#define LIGHT_LOCAL_VIEWER 0x2
#define LIGHT_POSITIONAL   0x4
#define LIGHT_NEED_VERTICES (LIGHT_POSITIONAL|LIGHT_LOCAL_VIEWER)
/*@@}*/

d810 2
a811 1
    * Must flush FLUSH_VERTICES before referencing:
d813 1
a813 3
   /*@@{*/
   struct gl_material Material; 	/**< Includes front & back values */
   /*@@}*/
d820 1
a820 1
   GLbitfield ColorMaterialBitmask;	/**< bitmask formed from Face and Mode */
d822 1
a822 1
   GLenum ClampVertexColor;
a832 1
   GLbitfield _Flags;		        /**< LIGHT_* flags, see above */
d872 5
a886 1
   GLubyte Map8[MAX_PIXEL_MAP_TABLE];  /**< converted to 8-bit color */
d1012 1
d1033 3
d1039 1
d1054 3
d1060 1
d1070 2
a1071 73
 * TexGenEnabled flags.
 */
/*@@{*/
#define S_BIT 1
#define T_BIT 2
#define R_BIT 4
#define Q_BIT 8
#define STR_BITS (S_BIT | T_BIT | R_BIT)
/*@@}*/


/**
 * Bit flag versions of the corresponding GL_ constants.
 */
/*@@{*/
#define TEXGEN_SPHERE_MAP        0x1
#define TEXGEN_OBJ_LINEAR        0x2
#define TEXGEN_EYE_LINEAR        0x4
#define TEXGEN_REFLECTION_MAP_NV 0x8
#define TEXGEN_NORMAL_MAP_NV     0x10

#define TEXGEN_NEED_NORMALS      (TEXGEN_SPHERE_MAP        | \
				  TEXGEN_REFLECTION_MAP_NV | \
				  TEXGEN_NORMAL_MAP_NV)
#define TEXGEN_NEED_EYE_COORD    (TEXGEN_SPHERE_MAP        | \
				  TEXGEN_REFLECTION_MAP_NV | \
				  TEXGEN_NORMAL_MAP_NV     | \
				  TEXGEN_EYE_LINEAR)
/*@@}*/



/** Tex-gen enabled for texture unit? */
#define ENABLE_TEXGEN(unit) (1 << (unit))

/** Non-identity texture matrix for texture unit? */
#define ENABLE_TEXMAT(unit) (1 << (unit))


/**
 * Texel fetch function prototype.  We use texel fetch functions to
 * extract RGBA, color indexes and depth components out of 1D, 2D and 3D
 * texture images.  These functions help to isolate us from the gritty
 * details of all the various texture image encodings.
 * 
 * \param texImage texture image.
 * \param col texel column.
 * \param row texel row.
 * \param img texel image level/layer.
 * \param texelOut output texel (up to 4 GLchans)
 */
typedef void (*FetchTexelFuncC)( const struct gl_texture_image *texImage,
                                 GLint col, GLint row, GLint img,
                                 GLchan *texelOut );

/**
 * As above, but returns floats.
 * Used for depth component images and for upcoming signed/float
 * texture images.
 */
typedef void (*FetchTexelFuncF)( const struct gl_texture_image *texImage,
                                 GLint col, GLint row, GLint img,
                                 GLfloat *texelOut );


typedef void (*StoreTexelFunc)(struct gl_texture_image *texImage,
                               GLint col, GLint row, GLint img,
                               const void *texel);


/**
 * Texture image state.  Describes the dimensions of a texture image,
 * the texel format and pointers to Texel Fetch functions.
d1078 3
a1080 3
				 *   GL_INTENSITY, GL_COLOR_INDEX,
				 *   GL_DEPTH_COMPONENT or GL_DEPTH_STENCIL_EXT
                                 *   only. Used for choosing TexEnv arithmetic.
d1094 2
a1095 6
   GLuint MaxLog2;		/**< = MAX(WidthLog2, HeightLog2) */
   GLfloat WidthScale;		/**< used for mipmap LOD computation */
   GLfloat HeightScale;		/**< used for mipmap LOD computation */
   GLfloat DepthScale;		/**< used for mipmap LOD computation */
   GLboolean IsClientData;	/**< Data owned by client? */
   GLboolean _IsPowerOfTwo;	/**< Are all dimensions powers of two? */
d1098 7
a1104 15

   FetchTexelFuncC FetchTexelc;	/**< GLchan texel fetch function pointer */
   FetchTexelFuncF FetchTexelf;	/**< Float texel fetch function pointer */

   GLuint RowStride;		/**< Padded width in units of texels */
   GLuint *ImageOffsets;        /**< if 3D texture: array [Depth] of offsets to
                                     each 2D slice in 'Data', in texels */
   GLvoid *Data;		/**< Image data, accessed via FetchTexel() */

   /**
    * \name For device driver:
    */
   /*@@{*/
   void *DriverData;		/**< Arbitrary device driver data */
   /*@@}*/
d1137 1
a1137 5
   union {
      GLfloat f[4];
      GLuint ui[4];
      GLint i[4];
   } BorderColor;               /**< Interpreted according to texture format */
a1143 1
   GLfloat CompareFailValue;    /**< GL_ARB_shadow_ambient */
a1145 6

   /* deprecated sampler state */
   GLenum DepthMode;		/**< GL_ARB_depth_texture */

   /** Is the texture object complete with respect to this sampler? */
   GLboolean _CompleteTexture;
d1151 1
a1151 2
 * wrap modes, filter modes, shadow/texcompare state, and the per-texture
 * color palette.
d1162 2
d1167 1
d1174 3
a1176 1
   GLboolean _Complete;		/**< Is texture object complete? */
d1179 1
d1187 5
d1193 2
a1194 11
   /** GL_EXT_paletted_texture */
   struct gl_color_table Palette;

   /**
    * \name For device driver.
    * Note: instead of attaching driver data to this pointer, it's preferable
    * to instead use this struct as a base class for your own texture object
    * class.  Driver->NewTextureObject() can be used to implement the
    * allocation.
    */
   void *DriverData;	/**< Arbitrary device driver data */
d1223 40
a1341 4
   /** GL_EXT_shared_texture_palette */
   GLboolean SharedPalette;
   struct gl_color_table Palette;

d1360 7
d1372 2
a1373 2
   GLfloat EyeUserPlane[MAX_CLIP_PLANES][4];	/**< User clip planes */
   GLfloat _ClipUserPlane[MAX_CLIP_PLANES][4];	/**< derived */
d1415 1
a1433 1
   GLboolean ClientStorage; /**< GL_APPLE_client_storage */
a1471 1
   GLboolean VBOonly;  /**< require all arrays to live in VBOs? */
d1473 15
a1487 13
   /** Conventional vertex arrays */
   /*@@{*/
   struct gl_client_array Vertex;
   struct gl_client_array Weight;
   struct gl_client_array Normal;
   struct gl_client_array Color;
   struct gl_client_array SecondaryColor;
   struct gl_client_array FogCoord;
   struct gl_client_array Index;
   struct gl_client_array EdgeFlag;
   struct gl_client_array TexCoord[MAX_TEXTURE_COORD_UNITS];
   struct gl_client_array PointSize;
   /*@@}*/
d1490 1
a1490 4
    * Generic arrays for vertex programs/shaders.
    * For NV vertex programs, these attributes alias and take priority
    * over the conventional attribs above.  For ARB vertex programs and
    * GLSL vertex shaders, these attributes are separate.
d1492 1
a1492 1
   struct gl_client_array VertexAttrib[MAX_VERTEX_GENERIC_ATTRIBS];
d1494 5
a1498 2
   /** Mask of _NEW_ARRAY_* values indicating which arrays are enabled */
   GLbitfield _Enabled;
d1505 2
d1528 7
a1534 1
   /** GL 3.1 (slightly different from GL_NV_primitive_restart) */
d1536 2
d1539 1
a1539 3

   GLbitfield NewState;		/**< mask of _NEW_ARRAY_* values */
   GLboolean RebindArrays; /**< whether the VBO module should rebind arrays */
d1543 6
a1548 1
   struct gl_buffer_object *ElementArrayBufferObj;
a1623 1
   struct gl_1d_map Map1Attrib[16];  /**< GL_NV_vertex_program */
a1638 1
   struct gl_2d_map Map2Attrib[16];  /**< GL_NV_vertex_program */
d1643 8
d1652 1
a1652 9
 * Names of the various vertex/fragment program register files, etc.
 *
 * NOTE: first four tokens must fit into 2 bits (see t_vb_arbprogram.c)
 * All values should fit in a 4-bit field.
 *
 * NOTE: PROGRAM_ENV_PARAM, PROGRAM_STATE_VAR, PROGRAM_NAMED_PARAM,
 * PROGRAM_CONSTANT, and PROGRAM_UNIFORM can all be considered to
 * be "uniform" variables since they can only be set outside glBegin/End.
 * They're also all stored in the same Parameters array.
d1654 125
a1778 1
typedef enum
d1781 1
a1783 1
   PROGRAM_VARYING,     /**< machine->Inputs[]/Outputs[] */
a1786 1
   PROGRAM_NAMED_PARAM, /**< gl_program->Parameters[] */
d1805 1
d1811 33
a1843 4
/** Vertex and fragment instructions */
struct prog_instruction;
struct gl_program_parameter_list;
struct gl_uniform_list;
d1854 1
a1854 1
   GLenum Target;    /**< GL_VERTEX/FRAGMENT_PROGRAM_ARB, GL_FRAGMENT_PROGRAM_NV */
a1855 1
   GLboolean Resident;
d1859 1
a1859 1
   GLbitfield InputsRead;     /**< Bitmask of which input regs are read */
a1873 5
   /** Vertex/fragment shader varying vars */
   struct gl_program_parameter_list *Varying;
   /** Vertex program user-defined attributes */
   struct gl_program_parameter_list *Attributes;

a1875 2
   /** Which texture target is being sampled (TEXTURE_1D/2D/3D/etc_INDEX) */
   gl_texture_index SamplerTargets[MAX_SAMPLERS];
a1910 1
   GLboolean IsNVProgram;    /**< is this a GL_NV_vertex_program program? */
d1912 1
d1933 1
d1937 13
d1972 2
a1983 4
   /* For GL_NV_vertex_program only: */
   GLenum TrackMatrix[MAX_PROGRAM_ENV_PARAMS / 4];
   GLenum TrackMatrixTransform[MAX_PROGRAM_ENV_PARAMS / 4];

a2087 51
/**
 * Occlusion/timer query object.
 */
struct gl_query_object
{
   GLenum Target;      /**< The query target, when active */
   GLuint Id;          /**< hash table ID/name */
   GLuint64EXT Result; /**< the counter */
   GLboolean Active;   /**< inside Begin/EndQuery */
   GLboolean Ready;    /**< result is ready? */
};


/**
 * Context state for query objects.
 */
struct gl_query_state
{
   struct _mesa_HashTable *QueryObjects;
   struct gl_query_object *CurrentOcclusionObject; /* GL_ARB_occlusion_query */
   struct gl_query_object *CurrentTimerObject;     /* GL_EXT_timer_query */

   /** GL_NV_conditional_render */
   struct gl_query_object *CondRenderQuery;

   /** GL_EXT_transform_feedback */
   struct gl_query_object *PrimitivesGenerated;
   struct gl_query_object *PrimitivesWritten;

   /** GL_ARB_timer_query */
   struct gl_query_object *TimeElapsed;

   GLenum CondRenderMode;
};


/** Sync object state */
struct gl_sync_object {
   struct simple_node link;
   GLenum Type;               /**< GL_SYNC_FENCE */
   GLuint Name;               /**< Fence name */
   GLint RefCount;            /**< Reference count */
   GLboolean DeletePending;   /**< Object was deleted while there were still
			       * live references (e.g., sync not yet finished)
			       */
   GLenum SyncCondition;
   GLbitfield Flags;          /**< Flags passed to glFenceSync */
   GLuint StatusFlag:1;       /**< Has the sync object been signaled? */
};


d2103 4
a2106 1
   GLenum Type;  /**< GL_FRAGMENT_SHADER || GL_VERTEX_SHADER || GL_GEOMETRY_SHADER_ARB (first field!) */
d2118 47
d2176 78
d2264 16
d2283 18
a2300 2
   /** User-defined attribute bindings (glBindAttribLocation) */
   struct gl_program_parameter_list *Attributes;
d2302 7
a2308 1
   /** Transform feedback varyings */
d2315 6
d2329 7
d2337 40
a2376 5
   struct gl_vertex_program *VertexProgram;     /**< Linked vertex program */
   struct gl_fragment_program *FragmentProgram; /**< Linked fragment prog */
   struct gl_geometry_program *GeometryProgram; /**< Linked geometry prog */
   struct gl_uniform_list *Uniforms;
   struct gl_program_parameter_list *Varying;
d2383 1
d2404 1
d2423 2
a2431 2
   void *MemPool;

d2435 1
a2442 6
   GLboolean EmitNVTempInitialization;  /**< 0-fill NV temp registers */
   /**
    * Attempts to flatten all ir_if (OPCODE_IF) for GPUs that can't
    * support control flow.
    */
   GLboolean EmitNoIfs;
d2449 1
d2461 1
d2464 6
d2473 1
d2475 1
a2475 1
 * Transform feedback object state
d2477 1
a2477 1
struct gl_transform_feedback_object
d2479 6
a2484 13
   GLuint Name;  /**< AKA the object ID */
   GLint RefCount;
   GLboolean Active;  /**< Is transform feedback enabled? */
   GLboolean Paused;  /**< Is transform feedback paused? */

   /** The feedback buffers */
   GLuint BufferNames[MAX_FEEDBACK_ATTRIBS];
   struct gl_buffer_object *Buffers[MAX_FEEDBACK_ATTRIBS];

   /** Start of feedback data in dest buffer */
   GLintptr Offset[MAX_FEEDBACK_ATTRIBS];
   /** Max data to put into dest buffer (in bytes) */
   GLsizeiptr Size[MAX_FEEDBACK_ATTRIBS];
d2489 1
a2489 1
 * Context state for transform feedback.
d2491 1
a2491 1
struct gl_transform_feedback
d2493 6
a2498 1
   GLenum Mode;       /**< GL_POINTS, GL_LINES or GL_TRIANGLES */
d2500 3
a2502 1
   GLboolean RasterDiscard;  /**< GL_RASTERIZER_DISCARD */
d2504 2
a2505 2
   /** The general binding point (GL_TRANSFORM_FEEDBACK_BUFFER) */
   struct gl_buffer_object *CurrentBuffer;
d2507 2
a2508 2
   /** The table of all transform feedback objects */
   struct _mesa_HashTable *Objects;
a2509 2
   /** The current xform-fb object (GL_TRANSFORM_FEEDBACK_BINDING) */
   struct gl_transform_feedback_object *CurrentObject;
d2511 12
a2522 2
   /** The default xform-fb object (Name==0) */
   struct gl_transform_feedback_object *DefaultObject;
a2525 1

d2540 1
a2540 1
   struct gl_texture_object *FallbackTex;
d2580 1
a2580 1
   struct simple_node SyncObjects;
a2583 2

   void *DriverData;  /**< Device driver shared state */
a2587 1

d2589 3
a2591 7
 * A renderbuffer stores colors or depth values or stencil values.
 * A framebuffer object will have a collection of these.
 * Data are read/written to the buffer with a handful of Get/Put functions.
 *
 * Instances of this object are allocated with the Driver's NewRenderbuffer
 * hook.  Drivers will likely wrap this class inside a driver-specific
 * class to simulate inheritance.
d2595 1
a2595 1
   _glthread_Mutex Mutex;		   /**< for thread safety */
d2600 2
a2601 3
   GLint RowStride;       /**< Padded width in units of pixels */
   GLboolean Purgeable;   /**< Is the buffer purgeable under memory pressure? */

d2603 9
a2611 1

a2612 1

d2617 8
d2626 2
a2627 5
   GLenum DataType;      /**< Type of values passed to the Get/Put functions */
   GLvoid *Data;        /**< This may not be used by some kinds of RBs */

   /* Used to wrap one renderbuffer around another: */
   struct gl_renderbuffer *Wrapped;
d2629 3
a2631 5
   /* Delete this renderbuffer */
   void (*Delete)(struct gl_renderbuffer *rb);

   /* Allocate new storage for this renderbuffer */
   GLboolean (*AllocStorage)(struct gl_context *ctx, struct gl_renderbuffer *rb,
a2633 58

   /* Lock/Unlock are called before/after calling the Get/Put functions.
    * Not sure this is the right place for these yet.
   void (*Lock)(struct gl_context *ctx, struct gl_renderbuffer *rb);
   void (*Unlock)(struct gl_context *ctx, struct gl_renderbuffer *rb);
    */

   /* Return a pointer to the element/pixel at (x,y).
    * Should return NULL if the buffer memory can't be directly addressed.
    */
   void *(*GetPointer)(struct gl_context *ctx, struct gl_renderbuffer *rb,
                       GLint x, GLint y);

   /* Get/Read a row of values.
    * The values will be of format _BaseFormat and type DataType.
    */
   void (*GetRow)(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
                  GLint x, GLint y, void *values);

   /* Get/Read values at arbitrary locations.
    * The values will be of format _BaseFormat and type DataType.
    */
   void (*GetValues)(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
                     const GLint x[], const GLint y[], void *values);

   /* Put/Write a row of values.
    * The values will be of format _BaseFormat and type DataType.
    */
   void (*PutRow)(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
                  GLint x, GLint y, const void *values, const GLubyte *mask);

   /* Put/Write a row of RGB values.  This is a special-case routine that's
    * only used for RGBA renderbuffers when the source data is GL_RGB. That's
    * a common case for glDrawPixels and some triangle routines.
    * The values will be of format GL_RGB and type DataType.
    */
   void (*PutRowRGB)(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
                    GLint x, GLint y, const void *values, const GLubyte *mask);


   /* Put/Write a row of identical values.
    * The values will be of format _BaseFormat and type DataType.
    */
   void (*PutMonoRow)(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
                     GLint x, GLint y, const void *value, const GLubyte *mask);

   /* Put/Write values at arbitrary locations.
    * The values will be of format _BaseFormat and type DataType.
    */
   void (*PutValues)(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
                     const GLint x[], const GLint y[], const void *values,
                     const GLubyte *mask);
   /* Put/Write identical values at arbitrary locations.
    * The values will be of format _BaseFormat and type DataType.
    */
   void (*PutMonoValues)(struct gl_context *ctx, struct gl_renderbuffer *rb,
                         GLuint count, const GLint x[], const GLint y[],
                         const void *value, const GLubyte *mask);
d2661 1
a2690 2
   GLboolean Initialized;

d2712 4
d2732 1
a2732 4
   /** The Actual depth/stencil buffers to use.  May be wrappers around the
    * depth/stencil buffers attached above. */
   struct gl_renderbuffer *_DepthBuffer;
   struct gl_renderbuffer *_StencilBuffer;
d2781 4
d2794 6
a2799 6
   GLint MaxTextureMbytes;      /**< Max memory per image, in MB */
   GLint MaxTextureLevels;      /**< Max mipmap levels. */ 
   GLint Max3DTextureLevels;    /**< Max mipmap levels for 3D textures */
   GLint MaxCubeTextureLevels;  /**< Max mipmap levels for cube textures */
   GLint MaxArrayTextureLayers; /**< Max layers in array textures */
   GLint MaxTextureRectSize;    /**< Max rectangle texture size, in pixes */
a2800 2
   GLuint MaxTextureImageUnits;
   GLuint MaxVertexTextureImageUnits;
d2802 1
a2802 2
   GLuint MaxGeometryTextureImageUnits;
   GLuint MaxTextureUnits;           /**< = MIN(CoordUnits, ImageUnits) */
d2807 2
a2819 2
   GLuint MaxColorTableSize;

d2833 8
d2850 1
a2850 1
   /** Number of varying vectors between vertex and fragment shaders */
d2852 10
a2861 2
   GLuint MaxVertexVaryingComponents;   /**< Between vert and geom shader */
   GLuint MaxGeometryVaryingComponents; /**< Between geom and frag shader */
d2869 24
d2911 1
a2911 1
   GLuint MaxTransformFeedbackSeparateAttribs;
d2914 1
a2918 3
   /* GL_EXT_framebuffer_sRGB */
   GLboolean sRGBCapable; /* can enable sRGB blend/update on FBOs */

d2921 66
d2999 1
d3001 2
d3005 1
a3005 1
   GLboolean ARB_copy_buffer;
a3008 1
   GLboolean ARB_draw_buffers;
d3019 1
d3023 2
a3025 2
   GLboolean ARB_multisample;
   GLboolean ARB_multitexture;
a3028 1
   GLboolean ARB_sampler_objects;
d3030 1
a3030 1
   GLboolean ARB_shader_objects;
d3033 2
a3034 1
   GLboolean ARB_shading_language_100;
a3035 1
   GLboolean ARB_shadow_ambient;
d3039 2
a3040 1
   GLboolean ARB_texture_compression;
d3043 1
a3047 1
   GLboolean ARB_texture_mirrored_repeat;
d3050 1
d3055 2
a3056 1
   GLboolean ARB_transpose_matrix;
a3057 2
   GLboolean ARB_vertex_array_object;
   GLboolean ARB_vertex_buffer_object;
a3060 3
   GLboolean ARB_window_pos;
   GLboolean EXT_abgr;
   GLboolean EXT_bgra;
a3063 1
   GLboolean EXT_blend_logic_op;
a3064 4
   GLboolean EXT_blend_subtract;
   GLboolean EXT_clip_volume_hint;
   GLboolean EXT_compiled_vertex_array;
   GLboolean EXT_copy_texture;
a3066 2
   GLboolean EXT_draw_range_elements;
   GLboolean EXT_fog_coord;
d3069 1
a3069 1
   GLboolean EXT_framebuffer_object;
a3072 2
   GLboolean EXT_multi_draw_arrays;
   GLboolean EXT_paletted_texture;
a3074 1
   GLboolean EXT_packed_pixels;
a3076 1
   GLboolean EXT_polygon_offset;
a3077 3
   GLboolean EXT_rescale_normal;
   GLboolean EXT_shadow_funcs;
   GLboolean EXT_secondary_color;
a3078 3
   GLboolean EXT_separate_specular_color;
   GLboolean EXT_shared_texture_palette;
   GLboolean EXT_stencil_wrap;
a3079 3
   GLboolean EXT_subtexture;
   GLboolean EXT_texture;
   GLboolean EXT_texture_object;
a3083 2
   GLboolean EXT_texture_env_add;
   GLboolean EXT_texture_env_combine;
a3086 1
   GLboolean EXT_texture_lod_bias;
a3094 1
   GLboolean EXT_vertex_array;
a3095 1
   GLboolean EXT_vertex_array_set;
a3097 1
   GLboolean AMD_conservative_depth;
d3099 1
a3099 3
   GLboolean APPLE_client_storage;
   GLboolean APPLE_packed_pixels;
   GLboolean APPLE_vertex_array_object;
a3106 2
   GLboolean IBM_rasterpos_clip;
   GLboolean IBM_multimode_draw_arrays;
a3107 1
   GLboolean MESA_resize_buffers;
a3109 1
   GLboolean NV_blend_square;
d3111 1
a3111 1
   GLboolean NV_fragment_program;
a3112 1
   GLboolean NV_light_max_exponent;
a3115 1
   GLboolean NV_texgen_reflection;
a3117 6
   GLboolean NV_vertex_program;
   GLboolean NV_vertex_program1_1;
   GLboolean OES_read_format;
   GLboolean SGIS_generate_mipmap;
   GLboolean SGIS_texture_edge_clamp;
   GLboolean SGIS_texture_lod;
a3118 1
   GLboolean S3_s3tc;
d3121 3
a3123 1
   GLboolean EXT_texture_format_BGRA8888;
d3184 1
a3184 1
#define _NEW_PACKUNPACK        (1 << 19)  /**< gl_context::Pack, Unpack */
d3195 2
a3201 76
 * \name Bits to track array state changes 
 *
 * Also used to summarize array enabled.
 */
/*@@{*/
#define _NEW_ARRAY_VERTEX           VERT_BIT_POS
#define _NEW_ARRAY_WEIGHT           VERT_BIT_WEIGHT
#define _NEW_ARRAY_NORMAL           VERT_BIT_NORMAL
#define _NEW_ARRAY_COLOR0           VERT_BIT_COLOR0
#define _NEW_ARRAY_COLOR1           VERT_BIT_COLOR1
#define _NEW_ARRAY_FOGCOORD         VERT_BIT_FOG
#define _NEW_ARRAY_INDEX            VERT_BIT_COLOR_INDEX
#define _NEW_ARRAY_EDGEFLAG         VERT_BIT_EDGEFLAG
#define _NEW_ARRAY_POINT_SIZE       VERT_BIT_COLOR_INDEX  /* aliased */
#define _NEW_ARRAY_TEXCOORD_0       VERT_BIT_TEX0
#define _NEW_ARRAY_TEXCOORD_1       VERT_BIT_TEX1
#define _NEW_ARRAY_TEXCOORD_2       VERT_BIT_TEX2
#define _NEW_ARRAY_TEXCOORD_3       VERT_BIT_TEX3
#define _NEW_ARRAY_TEXCOORD_4       VERT_BIT_TEX4
#define _NEW_ARRAY_TEXCOORD_5       VERT_BIT_TEX5
#define _NEW_ARRAY_TEXCOORD_6       VERT_BIT_TEX6
#define _NEW_ARRAY_TEXCOORD_7       VERT_BIT_TEX7
#define _NEW_ARRAY_ATTRIB_0         VERT_BIT_GENERIC0  /* start at bit 16 */
#define _NEW_ARRAY_ALL              0xffffffff


#define _NEW_ARRAY_TEXCOORD(i) (_NEW_ARRAY_TEXCOORD_0 << (i))
#define _NEW_ARRAY_ATTRIB(i) (_NEW_ARRAY_ATTRIB_0 << (i))
/*@@}*/



/**
 * \name A bunch of flags that we think might be useful to drivers.
 * 
 * Set in the __struct gl_contextRec::_TriangleCaps bitfield.
 */
/*@@{*/
#define DD_FLATSHADE                0x1
#define DD_SEPARATE_SPECULAR        0x2
#define DD_TRI_CULL_FRONT_BACK      0x4 /* special case on some hw */
#define DD_TRI_LIGHT_TWOSIDE        0x8
#define DD_TRI_UNFILLED             0x10
#define DD_TRI_SMOOTH               0x20
#define DD_TRI_STIPPLE              0x40
#define DD_TRI_OFFSET               0x80
#define DD_LINE_SMOOTH              0x100
#define DD_LINE_STIPPLE             0x200
#define DD_POINT_SMOOTH             0x400
#define DD_POINT_ATTEN              0x800
#define DD_TRI_TWOSTENCIL           0x1000
/*@@}*/


/**
 * \name Define the state changes under which each of these bits might change
 */
/*@@{*/
#define _DD_NEW_FLATSHADE                _NEW_LIGHT
#define _DD_NEW_SEPARATE_SPECULAR        (_NEW_LIGHT | _NEW_FOG | _NEW_PROGRAM)
#define _DD_NEW_TRI_CULL_FRONT_BACK      _NEW_POLYGON
#define _DD_NEW_TRI_LIGHT_TWOSIDE        _NEW_LIGHT
#define _DD_NEW_TRI_UNFILLED             _NEW_POLYGON
#define _DD_NEW_TRI_SMOOTH               _NEW_POLYGON
#define _DD_NEW_TRI_STIPPLE              _NEW_POLYGON
#define _DD_NEW_TRI_OFFSET               _NEW_POLYGON
#define _DD_NEW_LINE_SMOOTH              _NEW_LINE
#define _DD_NEW_LINE_STIPPLE             _NEW_LINE
#define _DD_NEW_LINE_WIDTH               _NEW_LINE
#define _DD_NEW_POINT_SMOOTH             _NEW_POINT
#define _DD_NEW_POINT_SIZE               _NEW_POINT
#define _DD_NEW_POINT_ATTEN              _NEW_POINT
/*@@}*/


/**
d3210 6
a3270 6
   GLubyte ActiveIndex;
   GLfloat CurrentIndex;
   
   GLubyte ActiveEdgeFlag;
   GLboolean CurrentEdgeFlag;

d3279 70
d3352 3
d3358 1
a3358 1
   API_OPENGL,
d3360 3
a3362 1
   API_OPENGLES2
d3365 38
d3422 22
a3443 3
   struct _glapi_table *Save;	/**< Display list save functions */
   struct _glapi_table *Exec;	/**< Execute functions */
   struct _glapi_table *CurrentDispatch;  /**< == Save or Exec !! */
a3456 2
   void *DriverCtx;	/**< Points to device driver context/state */

d3481 2
a3482 2
   /** Version info */
   GLuint VersionMajor, VersionMinor;
d3552 1
a3552 1
   struct gl_transform_feedback TransformFeedback;
d3556 16
d3590 3
d3595 3
d3601 1
a3601 1
   GLbitfield varying_vp_inputs;  /**< mask of VERT_BIT_* flags */
a3603 5
   /*@@{*/
   /** Bitwise-or of DD_* flags.  Note that this bitfield may be used before
    * state validation so they need to always be current.
    */
   GLbitfield _TriangleCaps;
a3611 4
   struct gl_shine_tab *_ShineTable[2]; /**< Active shine tables */
   struct gl_shine_tab *_ShineTabList;  /**< MRU list of inactive shine tables */
   /**@@}*/

d3624 1
a3624 5
   /** 
    * Use dp4 (rather than mul/mad) instructions for position
    * transformation?
    */
   GLboolean mvp_with_dp4;
d3679 4
a3682 1
   DEBUG_ALWAYS_FLUSH		= 0x1
d3686 4
@


1.7
log
@Merge Mesa 7.10.3
@
text
@d43 1
a86 3
#define BITFIELD64_ONE         1ULL
#define BITFIELD64_ALLONES     ~0ULL

d88 1
a88 13
#define BITFIELD64_BIT(b)      (BITFIELD64_ONE << (b))

/** Set a mask of the least significant \c b bits */
#define BITFIELD64_MASK(b)     (((b) >= 64) ? BITFIELD64_ALLONES : \
				(BITFIELD64_BIT(b) - 1))

/**
 * Set all bits from l (low bit) to h (high bit), inclusive.
 *
 * \note \C BITFIELD_64_RANGE(0, 63) return 64 set bits.
 */
#define BITFIELD64_RANGE(l, h) (BITFIELD64_MASK((h) + 1) & ~BITFIELD64_MASK(l))
/*@@}*/
d109 5
d289 2
a290 2
/*@@{*/
typedef enum {
d313 1
a313 1
/*@@}*/
d379 3
d383 5
d520 3
d702 2
a703 1
   GLclampf ClearColor[4];		/**< Color to use for glClear */
d716 1
d725 6
a730 6
   GLenum BlendSrcRGB;			/**< Blending source operator */
   GLenum BlendDstRGB;			/**< Blending destination operator */
   GLenum BlendSrcA;			/**< GL_INGR_blend_func_separate */
   GLenum BlendDstA;			/**< GL_INGR_blend_func_separate */
   GLenum BlendEquationRGB;		/**< Blending equation */
   GLenum BlendEquationA;		/**< GL_EXT_blend_equation_separate */
d732 14
d761 1
d763 3
d862 1
d875 17
d944 1
a1054 4

   /** GL_SGI_texture_color_table */
   GLfloat TextureColorTableScale[4]; /**< RGBA */
   GLfloat TextureColorTableBias[4];  /**< RGBA */
d1150 1
d1167 1
d1262 1
a1262 1
   GLuint TexFormat;            /**< The actual format: MESA_FORMAT_x */
d1316 2
a1317 3
 * Texture object state.  Contains the array of mipmap images, border color,
 * wrap modes, filter modes, shadow/texcompare state, and the per-texture
 * color palette.
d1319 1
a1319 1
struct gl_texture_object
d1321 8
a1328 5
   _glthread_Mutex Mutex;	/**< for thread safety */
   GLint RefCount;		/**< reference count */
   GLuint Name;			/**< the user-visible texture object ID */
   GLenum Target;               /**< GL_TEXTURE_1D, GL_TEXTURE_2D, etc. */
   GLfloat Priority;		/**< in [0,1] */
a1333 5
   GLenum WrapS;		/**< S-axis texture image wrap mode */
   GLenum WrapT;		/**< T-axis texture image wrap mode */
   GLenum WrapR;		/**< R-axis texture image wrap mode */
   GLenum MinFilter;		/**< minification filter */
   GLenum MagFilter;		/**< magnification filter */
a1336 2
   GLint BaseLevel;		/**< min mipmap level, OpenGL 1.2 */
   GLint MaxLevel;		/**< max mipmap level, OpenGL 1.2 */
d1341 4
d1346 23
d1382 4
d1438 1
a1438 2
 * combiners, texgen state, pointers to current texture objects and
 * post-filter color tables.
d1446 2
a1447 1
   GLfloat EnvColor[4];
d1460 3
a1484 7

   /** GL_SGI_texture_color_table */
   /*@@{*/
   struct gl_color_table ColorTable;
   struct gl_color_table ProxyColorTable;
   GLboolean ColorTableEnabled;
   /*@@}*/
d1498 3
d1612 1
d1689 1
d1816 1
d1822 12
d1856 1
d1859 1
a1859 1
   GLbitfield TexturesUsed[MAX_TEXTURE_UNITS];  /**< TEXTURE_x_BIT bitmask */
a1933 1
   GLenum FogOption;
d1937 1
a2148 2
   GLboolean Main;  /**< shader defines main() */
   GLboolean UnresolvedRefs;
d2396 3
a2415 2
#define RB_MAGIC 0xaabbccdd
   int Magic; /** XXX TEMPORARY DEBUG INFO */
d2424 4
d2431 1
a2431 3
   GLuint Format;         /**< The actual format: MESA_FORMAT_x */

   GLubyte NumSamples;
a2435 2
   GLboolean AttachedAnytime; /**< TRUE if it was attached to a framebuffer */

d2621 1
a2621 1
 * Limits for vertex and fragment programs/shaders.
d2633 1
d2647 1
a2647 8
   GLuint MaxUniformComponents;
   /* GL_ARB_geometry_shader4 */
   GLuint MaxGeometryTextureImageUnits;
   GLuint MaxGeometryVaryingComponents;
   GLuint MaxVertexVaryingComponents;
   GLuint MaxGeometryUniformComponents;
   GLuint MaxGeometryOutputVertices;
   GLuint MaxGeometryTotalOutputComponents;
d2670 1
d2674 1
d2711 8
a2718 1
   GLuint MaxVarying;  /**< Number of float[4] varying parameters */
d2746 6
d2766 1
d2772 1
d2795 1
d2867 1
d2877 1
d2879 1
d2888 2
d2895 1
a2905 1
   GLboolean MESA_texture_signed_rgba;
d2913 1
a2919 1
   GLboolean SGI_texture_color_table;
a2966 2
 *
 * 4 unused flags.
d2969 30
a2998 30
#define _NEW_MODELVIEW		0x1        /**< __struct gl_contextRec::ModelView */
#define _NEW_PROJECTION		0x2        /**< __struct gl_contextRec::Projection */
#define _NEW_TEXTURE_MATRIX	0x4        /**< __struct gl_contextRec::TextureMatrix */
#define _NEW_ACCUM		0x10       /**< __struct gl_contextRec::Accum */
#define _NEW_COLOR		0x20       /**< __struct gl_contextRec::Color */
#define _NEW_DEPTH		0x40       /**< __struct gl_contextRec::Depth */
#define _NEW_EVAL		0x80       /**< __struct gl_contextRec::Eval, __struct gl_contextRec::EvalMap */
#define _NEW_FOG		0x100      /**< __struct gl_contextRec::Fog */
#define _NEW_HINT		0x200      /**< __struct gl_contextRec::Hint */
#define _NEW_LIGHT		0x400      /**< __struct gl_contextRec::Light */
#define _NEW_LINE		0x800      /**< __struct gl_contextRec::Line */
#define _NEW_PIXEL		0x1000     /**< __struct gl_contextRec::Pixel */
#define _NEW_POINT		0x2000     /**< __struct gl_contextRec::Point */
#define _NEW_POLYGON		0x4000     /**< __struct gl_contextRec::Polygon */
#define _NEW_POLYGONSTIPPLE	0x8000     /**< __struct gl_contextRec::PolygonStipple */
#define _NEW_SCISSOR		0x10000    /**< __struct gl_contextRec::Scissor */
#define _NEW_STENCIL		0x20000    /**< __struct gl_contextRec::Stencil */
#define _NEW_TEXTURE		0x40000    /**< __struct gl_contextRec::Texture */
#define _NEW_TRANSFORM		0x80000    /**< __struct gl_contextRec::Transform */
#define _NEW_VIEWPORT		0x100000   /**< __struct gl_contextRec::Viewport */
#define _NEW_PACKUNPACK		0x200000   /**< __struct gl_contextRec::Pack, __struct gl_contextRec::Unpack */
#define _NEW_ARRAY	        0x400000   /**< __struct gl_contextRec::Array */
#define _NEW_RENDERMODE		0x800000   /**< __struct gl_contextRec::RenderMode, __struct gl_contextRec::Feedback, __struct gl_contextRec::Select */
#define _NEW_BUFFERS            0x1000000  /**< __struct gl_contextRec::Visual, __struct gl_contextRec::DrawBuffer, */
#define _NEW_MULTISAMPLE        0x2000000  /**< __struct gl_contextRec::Multisample */
#define _NEW_TRACK_MATRIX       0x4000000  /**< __struct gl_contextRec::VertexProgram */
#define _NEW_PROGRAM            0x8000000  /**< __struct gl_contextRec::VertexProgram */
#define _NEW_CURRENT_ATTRIB     0x10000000  /**< __struct gl_contextRec::Current */
#define _NEW_PROGRAM_CONSTANTS  0x20000000
#define _NEW_BUFFER_OBJECT      0x40000000
a3087 5

#define _MESA_NEW_NEED_NORMALS            (_NEW_LIGHT |		\
                                           _NEW_TEXTURE)

#define _MESA_NEW_TRANSFER_STATE          (_NEW_PIXEL)
d3157 1
d3161 2
a3162 1
typedef enum {
d3168 1
d3313 3
a3353 3
   /** Dither disable via MESA_NO_DITHER env var */
   GLboolean NoDither;

d3357 2
a3378 4


/** The string names for GL_POINT, GL_LINE_LOOP, etc */
extern const char *_mesa_prim_name[GL_POLYGON+4];
@


1.6
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@a38 1
#include "main/compiler.h"
d118 1
a119 3
typedef struct __GLcontextRec GLcontext;
typedef struct __GLcontextModesRec GLvisual;
typedef struct gl_framebuffer GLframebuffer;
d125 14
d252 72
d387 3
a389 2
   FRAG_RESULT_COLOR = 1,
   FRAG_RESULT_DATA0 = 2,
d462 60
a521 8
/** The pixel transfer path has three color tables: */
typedef enum
{
   COLORTABLE_PRECONVOLUTION,
   COLORTABLE_POSTCONVOLUTION,
   COLORTABLE_POSTCOLORMATRIX,
   COLORTABLE_MAX
} gl_colortable_index;
a869 42

/**
 * Histogram attributes.
 */
struct gl_histogram_attrib
{
   GLuint Width;                            /**< number of table entries */
   GLint Format;                            /**< GL_ALPHA, GL_RGB, etc */
   GLuint Count[HISTOGRAM_TABLE_SIZE][4];   /**< the histogram */
   GLboolean Sink;                          /**< terminate image transfer? */
   GLubyte RedSize;                         /**< Bits per counter */
   GLubyte GreenSize;
   GLubyte BlueSize;
   GLubyte AlphaSize;
   GLubyte LuminanceSize;
};


/**
 * Color Min/max state.
 */
struct gl_minmax_attrib
{
   GLenum Format;
   GLboolean Sink;
   GLfloat Min[4], Max[4];   /**< RGBA */
};


/**
 * Image convolution state.
 */
struct gl_convolution_attrib
{
   GLenum Format;
   GLenum InternalFormat;
   GLuint Width;
   GLuint Height;
   GLfloat Filter[MAX_CONVOLUTION_WIDTH * MAX_CONVOLUTION_HEIGHT * 4];
};


a1009 26
   /* There are multiple color table stages: */
   GLboolean ColorTableEnabled[COLORTABLE_MAX];
   GLfloat ColorTableScale[COLORTABLE_MAX][4];  /**< RGBA */
   GLfloat ColorTableBias[COLORTABLE_MAX][4];   /**< RGBA */

   /* Convolution (GL_EXT_convolution) */
   GLboolean Convolution1DEnabled;
   GLboolean Convolution2DEnabled;
   GLboolean Separable2DEnabled;
   GLfloat ConvolutionBorderColor[3][4];  /**< RGBA */
   GLenum ConvolutionBorderMode[3];
   GLfloat ConvolutionFilterScale[3][4];  /**< RGBA */
   GLfloat ConvolutionFilterBias[3][4];   /**< RGBA */
   GLfloat PostConvolutionScale[4];  /**< RGBA */
   GLfloat PostConvolutionBias[4];   /**< RGBA */

   /* Color matrix (GL_SGI_color_matrix) */
   /* Note: the color matrix is not part of this attrib group */
   GLfloat PostColorMatrixScale[4];  /**< RGBA */
   GLfloat PostColorMatrixBias[4];   /**< RGBA */

   /* Histogram & minmax (GL_EXT_histogram) */
   /* Note: histogram and minmax data are not part of this attrib group */
   GLboolean HistogramEnabled;
   GLboolean MinMaxEnabled;

d1147 1
a1474 1
   GLboolean CullVertexFlag;	/**< True if GL_CULL_VERTEX_EXT is enabled */
d1547 1
d1619 4
d1625 1
a1625 1
#if FEATURE_ARB_vertex_buffer_object
a1627 1
#endif
d1799 5
d1838 12
d1908 20
d2022 8
d2064 1
a2064 1
   GLenum Type;  /**< GL_FRAGMENT_SHADER || GL_VERTEX_SHADER (first field!) */
d2076 9
d2105 15
d2123 1
d2130 11
d2159 28
a2186 1
   struct gl_shader_program *CurrentProgram; /**< The user-bound program */
a2187 2
   GLboolean EmitHighLevelInstructions; /**< IF/ELSE/ENDIF vs. BRA, etc. */
   GLboolean EmitContReturn;            /**< Emit CONT/RET opcodes? */
a2188 1
   GLboolean EmitComments;              /**< Annotated instructions */
d2190 24
a2213 2
   void *MemPool;
   GLbitfield Flags;                    /**< Mask of GLSL_x flags */
d2217 44
d2293 1
a2293 1
    * \name Vertex/fragment programs
a2296 1
#if FEATURE_ARB_vertex_program
a2297 2
#endif
#if FEATURE_ARB_fragment_program
d2299 1
a2299 1
#endif
d2302 1
a2302 1
#if FEATURE_ATI_fragment_shader
a2304 1
#endif
a2305 1
#if FEATURE_ARB_vertex_buffer_object || FEATURE_ARB_pixel_buffer_object
a2306 1
#endif
a2307 1
#if FEATURE_ARB_shader_objects
a2309 1
#endif
d2311 1
a2311 1
#if FEATURE_EXT_framebuffer_object
a2313 1
#endif
d2315 1
a2315 1
#if FEATURE_ARB_sync
a2316 1
#endif
d2342 1
d2355 2
d2364 1
a2364 1
   GLboolean (*AllocStorage)(GLcontext *ctx, struct gl_renderbuffer *rb,
d2370 2
a2371 2
   void (*Lock)(GLcontext *ctx, struct gl_renderbuffer *rb);
   void (*Unlock)(GLcontext *ctx, struct gl_renderbuffer *rb);
d2377 1
a2377 1
   void *(*GetPointer)(GLcontext *ctx, struct gl_renderbuffer *rb,
d2383 1
a2383 1
   void (*GetRow)(GLcontext *ctx, struct gl_renderbuffer *rb, GLuint count,
d2389 1
a2389 1
   void (*GetValues)(GLcontext *ctx, struct gl_renderbuffer *rb, GLuint count,
d2395 1
a2395 1
   void (*PutRow)(GLcontext *ctx, struct gl_renderbuffer *rb, GLuint count,
d2403 1
a2403 1
   void (*PutRowRGB)(GLcontext *ctx, struct gl_renderbuffer *rb, GLuint count,
d2410 1
a2410 1
   void (*PutMonoRow)(GLcontext *ctx, struct gl_renderbuffer *rb, GLuint count,
d2416 1
a2416 1
   void (*PutValues)(GLcontext *ctx, struct gl_renderbuffer *rb, GLuint count,
d2422 1
a2422 1
   void (*PutMonoValues)(GLcontext *ctx, struct gl_renderbuffer *rb,
d2479 1
a2479 1
   GLvisual Visual;
d2501 3
d2531 12
a2542 1
 * Limits for vertex and fragment programs.
d2548 3
a2550 3
   GLuint MaxAluInstructions; /* fragment programs only, for now */
   GLuint MaxTexInstructions; /* fragment programs only, for now */
   GLuint MaxTexIndirections; /* fragment programs only, for now */
d2553 1
a2553 1
   GLuint MaxAddressRegs; /* vertex program only, for now */
d2559 3
a2561 3
   GLuint MaxNativeAluInstructions; /* fragment programs only, for now */
   GLuint MaxNativeTexInstructions; /* fragment programs only, for now */
   GLuint MaxNativeTexIndirections; /* fragment programs only, for now */
d2564 1
a2564 1
   GLuint MaxNativeAddressRegs; /* vertex program only, for now */
d2568 10
d2587 1
a2612 2
   GLuint MaxConvolutionWidth;
   GLuint MaxConvolutionHeight;
d2623 1
d2638 4
a2641 1
   GLbitfield SupportedBumpUnits; /**> units supporting GL_ATI_envmap_bumpmap as targets */
d2648 5
d2654 10
a2663 2
   /**< GL_EXT_provoking_vertex */
   GLboolean QuadsFollowProvokingVertexConvention;
d2674 4
d2679 2
a2681 1
   GLboolean ARB_depth_clamp;
d2684 1
d2690 2
d2694 1
a2694 1
   GLboolean ARB_imaging;
d2699 1
d2701 1
d2704 1
a2705 1
   GLboolean ARB_shading_language_120;
d2707 1
a2707 1
   GLboolean ARB_shadow_ambient; /* or GL_ARB_shadow_ambient */
d2710 1
d2712 1
d2719 1
d2721 4
d2726 1
d2731 1
a2741 2
   GLboolean EXT_cull_vertex;
   GLboolean EXT_convolution;
d2751 1
d2753 1
a2753 1
   GLboolean EXT_histogram;
d2757 1
d2766 1
d2781 1
d2784 1
d2787 1
d2792 1
a2805 1
   GLboolean MESA_packed_depth_stencil;
d2816 1
a2822 2
   GLboolean SGI_color_matrix;
   GLboolean SGI_color_table;
d2829 1
a2829 1
#if FEATURE_OES_draw_texture
d2831 2
a2832 1
#endif /* FEATURE_OES_draw_texture */
d2855 1
a2855 1
 * \sa __GLcontextRec::ImageTransferState.
a2860 8
#define IMAGE_COLOR_TABLE_BIT                     0x8
#define IMAGE_CONVOLUTION_BIT                     0x10
#define IMAGE_POST_CONVOLUTION_SCALE_BIAS         0x20
#define IMAGE_POST_CONVOLUTION_COLOR_TABLE_BIT    0x40
#define IMAGE_COLOR_MATRIX_BIT                    0x80
#define IMAGE_POST_COLOR_MATRIX_COLOR_TABLE_BIT   0x100
#define IMAGE_HISTOGRAM_BIT                       0x200
#define IMAGE_MIN_MAX_BIT                         0x400
d2864 4
a2867 15
/** Pixel Transfer ops up to convolution */
#define IMAGE_PRE_CONVOLUTION_BITS (IMAGE_SCALE_BIAS_BIT |     \
                                    IMAGE_SHIFT_OFFSET_BIT |   \
                                    IMAGE_MAP_COLOR_BIT |      \
                                    IMAGE_COLOR_TABLE_BIT)

/** Pixel transfer ops after convolution */
#define IMAGE_POST_CONVOLUTION_BITS (IMAGE_POST_CONVOLUTION_SCALE_BIAS |      \
                                     IMAGE_POST_CONVOLUTION_COLOR_TABLE_BIT | \
                                     IMAGE_COLOR_MATRIX_BIT |                 \
                                     IMAGE_POST_COLOR_MATRIX_COLOR_TABLE_BIT |\
                                     IMAGE_HISTOGRAM_BIT |                    \
                                     IMAGE_MIN_MAX_BIT)
/*@@}*/

d2875 28
a2902 29
#define _NEW_MODELVIEW		0x1        /**< __GLcontextRec::ModelView */
#define _NEW_PROJECTION		0x2        /**< __GLcontextRec::Projection */
#define _NEW_TEXTURE_MATRIX	0x4        /**< __GLcontextRec::TextureMatrix */
#define _NEW_COLOR_MATRIX	0x8        /**< __GLcontextRec::ColorMatrix */
#define _NEW_ACCUM		0x10       /**< __GLcontextRec::Accum */
#define _NEW_COLOR		0x20       /**< __GLcontextRec::Color */
#define _NEW_DEPTH		0x40       /**< __GLcontextRec::Depth */
#define _NEW_EVAL		0x80       /**< __GLcontextRec::Eval, __GLcontextRec::EvalMap */
#define _NEW_FOG		0x100      /**< __GLcontextRec::Fog */
#define _NEW_HINT		0x200      /**< __GLcontextRec::Hint */
#define _NEW_LIGHT		0x400      /**< __GLcontextRec::Light */
#define _NEW_LINE		0x800      /**< __GLcontextRec::Line */
#define _NEW_PIXEL		0x1000     /**< __GLcontextRec::Pixel */
#define _NEW_POINT		0x2000     /**< __GLcontextRec::Point */
#define _NEW_POLYGON		0x4000     /**< __GLcontextRec::Polygon */
#define _NEW_POLYGONSTIPPLE	0x8000     /**< __GLcontextRec::PolygonStipple */
#define _NEW_SCISSOR		0x10000    /**< __GLcontextRec::Scissor */
#define _NEW_STENCIL		0x20000    /**< __GLcontextRec::Stencil */
#define _NEW_TEXTURE		0x40000    /**< __GLcontextRec::Texture */
#define _NEW_TRANSFORM		0x80000    /**< __GLcontextRec::Transform */
#define _NEW_VIEWPORT		0x100000   /**< __GLcontextRec::Viewport */
#define _NEW_PACKUNPACK		0x200000   /**< __GLcontextRec::Pack, __GLcontextRec::Unpack */
#define _NEW_ARRAY	        0x400000   /**< __GLcontextRec::Array */
#define _NEW_RENDERMODE		0x800000   /**< __GLcontextRec::RenderMode, __GLcontextRec::Feedback, __GLcontextRec::Select */
#define _NEW_BUFFERS            0x1000000  /**< __GLcontextRec::Visual, __GLcontextRec::DrawBuffer, */
#define _NEW_MULTISAMPLE        0x2000000  /**< __GLcontextRec::Multisample */
#define _NEW_TRACK_MATRIX       0x4000000  /**< __GLcontextRec::VertexProgram */
#define _NEW_PROGRAM            0x8000000  /**< __GLcontextRec::VertexProgram */
#define _NEW_CURRENT_ATTRIB     0x10000000  /**< __GLcontextRec::Current */
d2945 1
a2945 1
 * Set in the __GLcontextRec::_TriangleCaps bitfield.
d2958 3
a2960 5
#define DD_LINE_WIDTH               0x400
#define DD_POINT_SMOOTH             0x800
#define DD_POINT_SIZE               0x1000
#define DD_POINT_ATTEN              0x2000
#define DD_TRI_TWOSTENCIL           0x4000
d2998 1
a2998 2
#define _MESA_NEW_TRANSFER_STATE          (_NEW_PIXEL |		\
                                           _NEW_COLOR_MATRIX)
a3007 26
#define NUM_VERTEX_FORMAT_ENTRIES (sizeof(GLvertexformat) / sizeof(void *))

/**
 * Core Mesa's support for tnl modules:
 */
struct gl_tnl_module
{
   /**
    * Vertex format to be lazily swapped into current dispatch.
    */
   const GLvertexformat *Current;

   /**
    * \name Record of functions swapped out.  
    * On restore, only need to swap these functions back in.
    */
   /*@@{*/
   struct {
       _glapi_proc * location;
       _glapi_proc function;
   } Swapped[NUM_VERTEX_FORMAT_ENTRIES];
   GLuint SwapCount;
   /*@@}*/
};


d3068 8
d3085 1
a3085 1
 * The GLcontext typedef names this structure.
d3087 1
a3087 1
struct __GLcontextRec
d3094 1
d3100 5
a3104 5
   GLvisual Visual;
   GLframebuffer *DrawBuffer;	/**< buffer for writing */
   GLframebuffer *ReadBuffer;	/**< buffer for reading */
   GLframebuffer *WinSysDrawBuffer;  /**< set with MakeCurrent */
   GLframebuffer *WinSysReadBuffer;  /**< set with MakeCurrent */
a3119 1
   struct gl_matrix_stack ColorMatrixStack;
a3191 5
   struct gl_histogram_attrib	Histogram;
   struct gl_minmax_attrib	MinMax;
   struct gl_convolution_attrib Convolution1D;
   struct gl_convolution_attrib Convolution2D;
   struct gl_convolution_attrib Separable2D;
a3196 3
   struct gl_color_table ColorTable[COLORTABLE_MAX];
   struct gl_color_table ProxyColorTable[COLORTABLE_MAX];

d3200 1
d3204 1
d3208 2
d3216 1
a3216 1
#if FEATURE_EXT_framebuffer_object
a3217 1
#endif
a3269 3

   /** Core tnl module support */
   struct gl_tnl_module TnlModule;
@


1.5
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d3 1
a3 1
 * Version:  7.3
d5 2
a6 2
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
 * Copyright (C) 1999-2008  VMware, Inc.  All Rights Reserved.
d33 2
a34 2
#ifndef TYPES_H
#define TYPES_H
d37 4
a40 3
#include "glheader.h"
#include <GL/internal/glcore.h>	/* __GLcontextModes (GLvisual) */
#include "config.h"		/* Hardwired parameters */
d43 1
a43 7
#include "bitset.h"


/**
 * Special, internal token
 */
#define GL_SHADER_PROGRAM_MESA 0x9999
d82 1
a82 1
 * Fixed point data type.
d84 8
a91 7
typedef int GLfixed;
/*
 * Fixed point arithmetic macros
 */
#ifndef FIXED_FRAC_BITS
#define FIXED_FRAC_BITS 11
#endif
d93 3
a95 18
#define FIXED_SHIFT     FIXED_FRAC_BITS
#define FIXED_ONE       (1 << FIXED_SHIFT)
#define FIXED_HALF      (1 << (FIXED_SHIFT-1))
#define FIXED_FRAC_MASK (FIXED_ONE - 1)
#define FIXED_INT_MASK  (~FIXED_FRAC_MASK)
#define FIXED_EPSILON   1
#define FIXED_SCALE     ((float) FIXED_ONE)
#define FIXED_DBL_SCALE ((double) FIXED_ONE)
#define FloatToFixed(X) (IROUND((X) * FIXED_SCALE))
#define FixedToDouble(X) ((X) * (1.0 / FIXED_DBL_SCALE))
#define IntToFixed(I)   ((I) << FIXED_SHIFT)
#define FixedToInt(X)   ((X) >> FIXED_SHIFT)
#define FixedToUns(X)   (((unsigned int)(X)) >> FIXED_SHIFT)
#define FixedCeil(X)    (((X) + FIXED_ONE - FIXED_EPSILON) & FIXED_INT_MASK)
#define FixedFloor(X)   ((X) & FIXED_INT_MASK)
#define FixedToFloat(X) ((X) * (1.0F / FIXED_SCALE))
#define PosFloatToFixed(X)      FloatToFixed(X)
#define SignedFloatToFixed(X)   FloatToFixed(X)
d97 7
d111 3
d119 1
d134 1
a134 1
enum
d170 1
a170 1
};
d218 21
a238 20
/*@@{*/
#define VERT_RESULT_HPOS 0
#define VERT_RESULT_COL0 1
#define VERT_RESULT_COL1 2
#define VERT_RESULT_FOGC 3
#define VERT_RESULT_TEX0 4
#define VERT_RESULT_TEX1 5
#define VERT_RESULT_TEX2 6
#define VERT_RESULT_TEX3 7
#define VERT_RESULT_TEX4 8
#define VERT_RESULT_TEX5 9
#define VERT_RESULT_TEX6 10
#define VERT_RESULT_TEX7 11
#define VERT_RESULT_PSIZ 12
#define VERT_RESULT_BFC0 13
#define VERT_RESULT_BFC1 14
#define VERT_RESULT_EDGE 15
#define VERT_RESULT_VAR0 16  /**< shader varying */
#define VERT_RESULT_MAX  (VERT_RESULT_VAR0 + MAX_VARYING)
/*@@}*/
d244 1
a244 1
enum
d258 3
a260 1
   FRAG_ATTRIB_VAR0 = 12,  /**< shader varying */
d262 1
a262 1
};
d272 2
d301 1
a301 1
enum
d303 3
a305 4
   FRAG_RESULT_COLR = 0,
   FRAG_RESULT_COLH = 1,
   FRAG_RESULT_DEPR = 2,
   FRAG_RESULT_DATA0 = 3,
d307 1
a307 1
};
d313 23
a335 22
enum {
   BUFFER_FRONT_LEFT  = 0,  /* the four standard color buffers */
   BUFFER_BACK_LEFT   = 1,
   BUFFER_FRONT_RIGHT = 2,
   BUFFER_BACK_RIGHT  = 3,
   BUFFER_AUX0        = 4,  /* optional aux buffer */
   BUFFER_AUX1        = 5,
   BUFFER_AUX2        = 6,
   BUFFER_AUX3        = 7,
   BUFFER_DEPTH       = 8,
   BUFFER_STENCIL     = 9,
   BUFFER_ACCUM       = 10,
   BUFFER_COLOR0      = 11, /* generic renderbuffers */
   BUFFER_COLOR1      = 12,
   BUFFER_COLOR2      = 13,
   BUFFER_COLOR3      = 14,
   BUFFER_COLOR4      = 15,
   BUFFER_COLOR5      = 16,
   BUFFER_COLOR6      = 17,
   BUFFER_COLOR7      = 18,
   BUFFER_COUNT       = 19
};
a367 3
                            BUFFER_BIT_AUX1 | \
                            BUFFER_BIT_AUX2 | \
                            BUFFER_BIT_AUX3 | \
d379 7
a385 6
/*@@{*/
#define COLORTABLE_PRECONVOLUTION  0
#define COLORTABLE_POSTCONVOLUTION 1
#define COLORTABLE_POSTCOLORMATRIX 2
#define COLORTABLE_MAX 3
/*@@}*/
d495 1
a495 1
   GLfloat EyeDirection[4];	/**< spotlight dir in eye coordinates */
d514 1
a514 1
   GLfloat _NormDirection[4];	/**< normalized spotlight direction */
d567 1
a567 1
   GLubyte ColorMask[4];		/**< Each flag is 0xff or 0x0 */
d584 1
a584 1
   GLboolean BlendEnabled;		/**< Blending enabled flag */
a621 1
   /*@@{*/
a622 1
   /*@@}*/
d633 1
a633 2
   GLfloat RasterIndex;
   GLfloat RasterTexCoords[MAX_TEXTURE_UNITS][4];
a653 78
 * glEnable()/glDisable() attribute group (GL_ENABLE_BIT).
 */
struct gl_enable_attrib
{
   GLboolean AlphaTest;
   GLboolean AutoNormal;
   GLboolean Blend;
   GLbitfield ClipPlanes;
   GLboolean ColorMaterial;
   GLboolean ColorTable[COLORTABLE_MAX];
   GLboolean Convolution1D;
   GLboolean Convolution2D;
   GLboolean Separable2D;
   GLboolean CullFace;
   GLboolean DepthTest;
   GLboolean Dither;
   GLboolean Fog;
   GLboolean Histogram;
   GLboolean Light[MAX_LIGHTS];
   GLboolean Lighting;
   GLboolean LineSmooth;
   GLboolean LineStipple;
   GLboolean IndexLogicOp;
   GLboolean ColorLogicOp;
   GLboolean Map1Color4;
   GLboolean Map1Index;
   GLboolean Map1Normal;
   GLboolean Map1TextureCoord1;
   GLboolean Map1TextureCoord2;
   GLboolean Map1TextureCoord3;
   GLboolean Map1TextureCoord4;
   GLboolean Map1Vertex3;
   GLboolean Map1Vertex4;
   GLboolean Map1Attrib[16];  /* GL_NV_vertex_program */
   GLboolean Map2Color4;
   GLboolean Map2Index;
   GLboolean Map2Normal;
   GLboolean Map2TextureCoord1;
   GLboolean Map2TextureCoord2;
   GLboolean Map2TextureCoord3;
   GLboolean Map2TextureCoord4;
   GLboolean Map2Vertex3;
   GLboolean Map2Vertex4;
   GLboolean Map2Attrib[16];  /* GL_NV_vertex_program */
   GLboolean MinMax;
   GLboolean Normalize;
   GLboolean PixelTexture;
   GLboolean PointSmooth;
   GLboolean PolygonOffsetPoint;
   GLboolean PolygonOffsetLine;
   GLboolean PolygonOffsetFill;
   GLboolean PolygonSmooth;
   GLboolean PolygonStipple;
   GLboolean RescaleNormals;
   GLboolean Scissor;
   GLboolean Stencil;
   GLboolean StencilTwoSide;          /* GL_EXT_stencil_two_side */
   GLboolean MultisampleEnabled;      /* GL_ARB_multisample */
   GLboolean SampleAlphaToCoverage;   /* GL_ARB_multisample */
   GLboolean SampleAlphaToOne;        /* GL_ARB_multisample */
   GLboolean SampleCoverage;          /* GL_ARB_multisample */
   GLboolean SampleCoverageInvert;    /* GL_ARB_multisample */
   GLboolean RasterPositionUnclipped; /* GL_IBM_rasterpos_clip */
   GLuint Texture[MAX_TEXTURE_UNITS];
   GLuint TexGen[MAX_TEXTURE_UNITS];
   /* SGI_texture_color_table */
   GLboolean TextureColorTable[MAX_TEXTURE_UNITS];
   /* GL_ARB_vertex_program / GL_NV_vertex_program */
   GLboolean VertexProgram;
   GLboolean VertexProgramPointSize;
   GLboolean VertexProgramTwoSide;
   /* GL_ARB_point_sprite / GL_NV_point_sprite */
   GLboolean PointSprite;
   GLboolean FragmentShaderATI;
};


/**
d740 5
a744 5
   GLuint Width;				/**< number of table entries */
   GLint Format;				/**< GL_ALPHA, GL_RGB, etc */
   GLuint Count[HISTOGRAM_TABLE_SIZE][4];	/**< the histogram */
   GLboolean Sink;				/**< terminate image transfer? */
   GLubyte RedSize;				/**< Bits per counter */
d804 1
d819 1
a819 1
   GLbitfield  _Flags;		        /**< LIGHT_* flags, see above */
a847 23
 * Used by device drivers to hook new commands into display lists.
 */
struct gl_list_instruction
{
   GLuint Size;
   void (*Execute)( GLcontext *ctx, void *data );
   void (*Destroy)( GLcontext *ctx, void *data );
   void (*Print)( GLcontext *ctx, void *data );
};

#define MAX_DLIST_EXT_OPCODES 16

/**
 * Used by device drivers to hook new commands into display lists.
 */
struct gl_list_extensions
{
   struct gl_list_instruction Opcode[MAX_DLIST_EXT_OPCODES];
   GLuint NumOpcodes;
};


/**
d901 2
a902 1
   /* Scale & Bias (index shift, offset) */
d909 1
d925 1
a925 1
   GLfloat ConvolutionBorderColor[3][4];
d944 1
a944 1
   /* Pixel Zoom */
d948 2
a949 2
   GLfloat TextureColorTableScale[4];
   GLfloat TextureColorTableBias[4];
d965 1
a965 1
   GLboolean CoordReplace[MAX_TEXTURE_UNITS]; /**< GL_ARB_point_sprite */
d1024 1
d1038 16
a1053 1
#define NUM_TEXTURE_TARGETS 7   /* 1D, 2D, 3D, CUBE, RECT, 1D_STACK, and 2D_STACK */
a1054 12
/**
 * An index for each type of texture object
 */
/*@@{*/
#define TEXTURE_1D_INDEX       0
#define TEXTURE_2D_INDEX       1
#define TEXTURE_3D_INDEX       2
#define TEXTURE_CUBE_INDEX     3
#define TEXTURE_RECT_INDEX     4
#define TEXTURE_1D_ARRAY_INDEX 5
#define TEXTURE_2D_ARRAY_INDEX 6
/*@@}*/
d1061 3
a1063 2
#define TEXTURE_1D_BIT       (1 << TEXTURE_1D_INDEX)
#define TEXTURE_2D_BIT       (1 << TEXTURE_2D_INDEX)
a1064 1
#define TEXTURE_CUBE_BIT     (1 << TEXTURE_CUBE_INDEX)
d1066 2
a1067 2
#define TEXTURE_1D_ARRAY_BIT (1 << TEXTURE_1D_ARRAY_INDEX)
#define TEXTURE_2D_ARRAY_BIT (1 << TEXTURE_2D_ARRAY_INDEX)
a1101 18
/* A selection of state flags to make driver and module's lives easier. */
#define ENABLE_TEXGEN0        0x1
#define ENABLE_TEXGEN1        0x2
#define ENABLE_TEXGEN2        0x4
#define ENABLE_TEXGEN3        0x8
#define ENABLE_TEXGEN4        0x10
#define ENABLE_TEXGEN5        0x20
#define ENABLE_TEXGEN6        0x40
#define ENABLE_TEXGEN7        0x80

#define ENABLE_TEXMAT0        0x1	/* Ie. not the identity matrix */
#define ENABLE_TEXMAT1        0x2
#define ENABLE_TEXMAT2        0x4
#define ENABLE_TEXMAT3        0x8
#define ENABLE_TEXMAT4        0x10
#define ENABLE_TEXMAT5        0x20
#define ENABLE_TEXMAT6        0x40
#define ENABLE_TEXMAT7        0x80
d1103 5
a1107 2
#define ENABLE_TEXGEN(i) (ENABLE_TEXGEN0 << (i))
#define ENABLE_TEXMAT(i) (ENABLE_TEXMAT0 << (i))
a1141 85
 * This macro defines the (many) parameters to the texstore functions.
 * \param dims  either 1 or 2 or 3
 * \param baseInternalFormat  user-specified base internal format
 * \param dstFormat  destination Mesa texture format
 * \param dstAddr  destination image address
 * \param dstX/Y/Zoffset  destination x/y/z offset (ala TexSubImage), in texels
 * \param dstRowStride  destination image row stride, in bytes
 * \param dstImageOffsets  offset of each 2D slice within 3D texture, in texels
 * \param srcWidth/Height/Depth  source image size, in pixels
 * \param srcFormat  incoming image format
 * \param srcType  incoming image data type
 * \param srcAddr  source image address
 * \param srcPacking  source image packing parameters
 */
#define TEXSTORE_PARAMS \
	GLcontext *ctx, GLuint dims, \
	GLenum baseInternalFormat, \
	const struct gl_texture_format *dstFormat, \
	GLvoid *dstAddr, \
	GLint dstXoffset, GLint dstYoffset, GLint dstZoffset, \
	GLint dstRowStride, const GLuint *dstImageOffsets, \
	GLint srcWidth, GLint srcHeight, GLint srcDepth, \
	GLenum srcFormat, GLenum srcType, \
	const GLvoid *srcAddr, \
	const struct gl_pixelstore_attrib *srcPacking



/**
 * Texture image storage function.
 */
typedef GLboolean (*StoreTexImageFunc)(TEXSTORE_PARAMS);


/**
 * Texture format record 
 */
struct gl_texture_format
{
   GLint MesaFormat;		/**< One of the MESA_FORMAT_* values */

   GLenum BaseFormat;		/**< Either GL_RGB, GL_RGBA, GL_ALPHA,
				 *   GL_LUMINANCE, GL_LUMINANCE_ALPHA,
				 *   GL_INTENSITY, GL_COLOR_INDEX or
				 *   GL_DEPTH_COMPONENT.
				 */
   GLenum DataType;		/**< GL_FLOAT or GL_UNSIGNED_NORMALIZED_ARB */

   /**
    * Bits per texel component.  These are just rough approximations
    * for compressed texture formats.
    */
   /*@@{*/
   GLubyte RedBits;
   GLubyte GreenBits;
   GLubyte BlueBits;
   GLubyte AlphaBits;
   GLubyte LuminanceBits;
   GLubyte IntensityBits;
   GLubyte IndexBits;
   GLubyte DepthBits;
   GLubyte StencilBits; 	/**< GL_EXT_packed_depth_stencil */
   /*@@}*/

   GLuint TexelBytes;		/**< Bytes per texel, 0 if compressed format */

   StoreTexImageFunc StoreImage;

   /**
    * \name Texel fetch function pointers
    */
   /*@@{*/
   FetchTexelFuncC FetchTexel1D;
   FetchTexelFuncC FetchTexel2D;
   FetchTexelFuncC FetchTexel3D;
   FetchTexelFuncF FetchTexel1Df;
   FetchTexelFuncF FetchTexel2Df;
   FetchTexelFuncF FetchTexel3Df;
   /*@@}*/

   StoreTexelFunc StoreTexel;
};


/**
d1147 1
d1154 2
a1155 1
   GLint InternalFormat;	/**< Internal format as given by the user */
a1172 2
   const struct gl_texture_format *TexFormat;

a1177 3
   GLboolean IsCompressed;	/**< GL_ARB_texture_compression */
   GLuint CompressedSize;	/**< GL_ARB_texture_compression */

d1195 10
a1204 9
/*@@{*/
#define FACE_POS_X   0
#define FACE_NEG_X   1
#define FACE_POS_Y   2
#define FACE_NEG_Y   3
#define FACE_POS_Z   4
#define FACE_NEG_Z   5
#define MAX_FACES    6
/*@@}*/
d1219 5
a1223 2
   GLfloat BorderColor[4];	/**< unclamped */
   GLchan _BorderChan[4];	/**< clamped, as GLchan */
a1234 3
   GLboolean CompareFlag;	/**< GL_SGIX_shadow */
   GLenum CompareOperator;	/**< GL_SGIX_shadow */
   GLfloat ShadowAmbient;       /**< GL_ARB_shadow_ambient */
d1237 1
a1237 4
   GLenum _Function;		/**< Comparison function derived from 
				 * \c CompareOperator, \c CompareMode, and
				 * \c CompareFunc.
				 */
d1242 2
d1246 2
d1266 4
a1271 4
 * 
 * \todo
 * If GL_NV_texture_env_combine4 is ever supported, the arrays in this
 * structure will need to be expanded for 4 elements.
d1277 6
a1282 4
   GLenum SourceRGB[3];  /**< GL_PRIMARY_COLOR, GL_TEXTURE, etc. */
   GLenum SourceA[3];    /**< GL_PRIMARY_COLOR, GL_TEXTURE, etc. */
   GLenum OperandRGB[3]; /**< SRC_COLOR, ONE_MINUS_SRC_COLOR, etc */
   GLenum OperandA[3];   /**< SRC_ALPHA, ONE_MINUS_SRC_ALPHA, etc */
d1285 14
a1298 2
   GLuint _NumArgsRGB;   /**< Number of inputs used for the combine mode. */
   GLuint _NumArgsA;     /**< Number of inputs used for the combine mode. */
d1314 5
d1320 2
a1321 21
   /** \name Tex coord generation mode
    * Either GL_OBJECT_LINEAR, GL_EYE_LINEAR or GL_SPHERE_MAP. */
   /*@@{*/
   GLenum GenModeS;		
   GLenum GenModeT;
   GLenum GenModeR;
   GLenum GenModeQ;
   /*@@}*/
   GLbitfield _GenBitS;
   GLbitfield _GenBitT;
   GLbitfield _GenBitR;
   GLbitfield _GenBitQ;
   GLbitfield _GenFlags;	/**< bitwise or of _GenBit[STRQ] */
   GLfloat ObjectPlaneS[4];
   GLfloat ObjectPlaneT[4];
   GLfloat ObjectPlaneR[4];
   GLfloat ObjectPlaneQ[4];
   GLfloat EyePlaneS[4];
   GLfloat EyePlaneT[4];
   GLfloat EyePlaneR[4];
   GLfloat EyePlaneQ[4];
d1323 2
a1357 1

d1363 2
a1364 11
   /**
    * name multitexture 
    */
   /**@@{*/
   GLuint CurrentUnit;   /**< Active texture unit [0, MaxTextureImageUnits-1] */
   GLbitfield _EnabledUnits;  /**< one bit set for each really-enabled unit */
   GLbitfield _EnabledCoordUnits;   /**< one bit per enabled coordinate unit */
   GLbitfield _GenFlags;            /**< for texgen */
   GLbitfield _TexGenEnabled;
   GLbitfield _TexMatEnabled;
   /**@@}*/
d1366 1
a1366 1
   struct gl_texture_unit Unit[MAX_TEXTURE_UNITS];
d1368 2
a1369 2
   /** Proxy texture objects */
   struct gl_texture_object *ProxyTex[NUM_TEXTURE_TARGETS];
d1374 15
d1404 1
a1424 11
 * Node for the attribute stack.
 */
struct gl_attrib_node
{
   GLbitfield kind;
   void *data;
   struct gl_attrib_node *next;
};


/**
d1429 1
d1432 12
a1443 6
   GLenum Usage;
   GLenum Access;
   GLvoid *Pointer;          /**< Only valid while buffer is mapped */
   GLsizeiptrARB Size;       /**< Size of storage in bytes */
   GLubyte *Data;            /**< Location of storage either in RAM or VRAM. */
   GLboolean OnCard;         /**< Is buffer in VRAM? (hardware drivers) */
a1446 1

d1456 2
a1457 2
   GLint ImageHeight;     /**< for GL_EXT_texture3D */
   GLint SkipImages;      /**< for GL_EXT_texture3D */
a1465 1

d1473 1
d1479 1
d1481 2
a1482 3
   /**< GL_ARB_vertex_buffer_object */
   struct gl_buffer_object *BufferObj;
   GLuint _MaxElement;
d1495 4
d1502 1
d1513 7
a1519 2
   /** Generic arrays for vertex programs/shaders */
   struct gl_client_array VertexAttrib[VERT_ATTRIB_MAX];
d1523 6
d1537 1
d1539 2
d1543 3
a1552 1
   struct gl_buffer_object *NullBufferObj;
a1555 1
   GLuint _MaxElement;          /* Min of all enabled array's maxes */
d1565 1
a1565 1
   GLbitfield _Mask;		/* FB_* bits */
d1663 1
a1663 1
enum register_file
d1665 14
a1678 14
   PROGRAM_TEMPORARY = 0,   /**< machine->Temporary[] */
   PROGRAM_LOCAL_PARAM = 1, /**< gl_program->LocalParams[] */
   PROGRAM_ENV_PARAM = 2,   /**< gl_program->Parameters[] */
   PROGRAM_STATE_VAR = 3,   /**< gl_program->Parameters[] */
   PROGRAM_INPUT = 4,       /**< machine->Inputs[] */
   PROGRAM_OUTPUT = 5,      /**< machine->Outputs[] */
   PROGRAM_NAMED_PARAM = 6, /**< gl_program->Parameters[] */
   PROGRAM_CONSTANT = 7,    /**< gl_program->Parameters[] */
   PROGRAM_UNIFORM = 8,     /**< gl_program->Parameters[] */
   PROGRAM_VARYING = 9,     /**< machine->Inputs[]/Outputs[] */
   PROGRAM_WRITE_ONLY = 10, /**< A dummy, write-only register */
   PROGRAM_ADDRESS = 11,    /**< machine->AddressReg */
   PROGRAM_SAMPLER = 12,    /**< for shader samplers, compile-time only */
   PROGRAM_UNDEFINED = 13,  /**< Invalid value */
d1680 1
a1680 1
};
d1704 1
a1704 1
   GLbitfield OutputsWritten; /**< Bitmask of which output regs are written to */
d1725 1
a1725 1
   GLubyte SamplerTargets[MAX_SAMPLERS];
a1757 1
   void *TnlData;		/**< should probably use Base.DriverData */
d1767 2
a1768 3
   GLboolean UsesPointCoord;    /**< shader uses gl_PointCoord */
   GLboolean UsesFrontFacing;   /**< shader used gl_FrontFacing */
   GLboolean UsesFogFragCoord;  /**< shader used gl_FogFragCoord */
d1787 4
a1790 4
   GLboolean Enabled;               /**< User-set GL_VERTEX_PROGRAM_ARB/NV flag */
   GLboolean _Enabled;              /**< Enabled and _valid_ user program? */
   GLboolean PointSizeEnabled;      /**< GL_VERTEX_PROGRAM_POINT_SIZE_ARB/NV */
   GLboolean TwoSideEnabled;        /**< GL_VERTEX_PROGRAM_TWO_SIDE_ARB/NV */
d1793 2
a1794 2
   /** Currently enabled and valid vertex program (including internal programs,
    * user-defined vertex programs and GLSL vertex shaders).
d1814 1
a1814 6
#if FEATURE_MESA_program_debug
   GLprogramcallbackMESA Callback;
   GLvoid *CallbackData;
   GLboolean CallbackEnabled;
   GLuint CurrentPosition;
#endif
d1827 2
a1828 2
   /** Currently enabled and valid fragment program (including internal programs,
    * user-defined fragment programs and GLSL fragment shaders).
a1842 7

#if FEATURE_MESA_program_debug
   GLprogramcallbackMESA Callback;
   GLvoid *CallbackData;
   GLboolean CallbackEnabled;
   GLuint CurrentPosition;
#endif
d1865 1
a1865 1
   GLbitfield LocalConstDef;  /** Indicates which constants have been set */
d1868 1
a1868 1
   GLubyte NumPasses;         /** 1 or 2 */
d1882 1
a1882 1
   GLboolean _Enabled;                      /** enabled and valid shader? */
d1910 19
d1935 2
d1953 1
d1955 1
d1986 1
d1991 10
d2009 1
d2012 1
d2014 2
d2032 3
d2046 2
d2081 3
a2083 2
   /** Objects associated with the GL_APPLE_vertex_array_object extension. */
   struct _mesa_HashTable *ArrayObjects;
d2109 2
a2111 1
   GLenum _ActualFormat;  /**< The driver-chosen format */
d2114 4
a2118 7
   GLubyte RedBits;      /**< Bits of red per pixel */
   GLubyte GreenBits;
   GLubyte BlueBits;
   GLubyte AlphaBits;
   GLubyte IndexBits;
   GLubyte DepthBits;
   GLubyte StencilBits;
d2193 2
a2194 3
 * A renderbuffer attachment point points to either a texture object
 * (and specifies a mipmap level, cube face or 3D texture slice) or
 * points to a renderbuffer.
d2239 5
a2243 3
   GLvisual Visual;	/**< The framebuffer's visual.
                             Immutable if this is a window system buffer.
                             Computed from attachments if user-made FBO. */
d2262 2
a2263 1
   GLenum _Status; /* One of the GL_FRAMEBUFFER_(IN)COMPLETE_* tokens */
d2265 1
a2265 1
   /* Array of all renderbuffer attachments, indexed by BUFFER_* tokens. */
d2327 5
a2331 5
   GLint MaxTextureLevels;		/**< Maximum number of allowed mipmap levels. */ 
   GLint Max3DTextureLevels;		/**< Maximum number of allowed mipmap levels for 3D texture targets. */
   GLint MaxCubeTextureLevels;          /**< Maximum number of allowed mipmap levels for GL_ARB_texture_cube_map */
   GLint MaxArrayTextureLayers;         /**< Maximum number of layers in an array texture. */
   GLint MaxTextureRectSize;            /* GL_NV_texture_rectangle */
d2334 6
a2339 3
   GLuint MaxTextureUnits;              /**< = MIN(CoordUnits, ImageUnits) */
   GLfloat MaxTextureMaxAnisotropy;     /**< GL_EXT_texture_filter_anisotropic */
   GLfloat MaxTextureLodBias;           /**< GL_EXT_texture_lod_bias */
d2341 1
d2343 3
a2345 2
   GLfloat MinPointSize, MaxPointSize;		/* aliased */
   GLfloat MinPointSizeAA, MaxPointSizeAA;	/* antialiased */
d2347 2
a2348 2
   GLfloat MinLineWidth, MaxLineWidth;		/* aliased */
   GLfloat MinLineWidthAA, MaxLineWidthAA;	/* antialiased */
d2350 1
d2354 1
d2357 3
a2359 2
   GLfloat MaxShininess;			/* GL_NV_light_max_exponent */
   GLfloat MaxSpotExponent;			/* GL_NV_light_max_exponent */
d2361 3
a2363 3
   struct gl_program_constants VertexProgram;    /* GL_ARB_vertex_program */
   struct gl_program_constants FragmentProgram;  /* GL_ARB_fragment_program */
   /* shared by vertex and fragment program: */
d2366 2
a2367 1
   /* vertex array / buffer object bounds checking */
d2369 19
a2387 11
   /* GL_ARB_draw_buffers */
   GLuint MaxDrawBuffers;
   /* GL_OES_read_format */
   GLenum ColorReadFormat;
   GLenum ColorReadType;
   /* GL_EXT_framebuffer_object */
   GLuint MaxColorAttachments;
   GLuint MaxRenderbufferSize;
   /* GL_ARB_vertex_shader */
   GLuint MaxVertexTextureImageUnits;
   GLuint MaxVarying;  /**< Number of float[4] vectors */
a2396 6
   /**
    * \name Flags to quickly test if certain extensions are available.
    * 
    * Not every extension needs to have such a flag, but it's encouraged.
    */
   /*@@{*/
d2398 1
d2400 1
d2402 2
d2407 1
d2409 1
d2411 1
d2416 1
d2421 2
d2433 1
d2452 1
a2453 1
   GLboolean EXT_framebuffer_object;
d2456 2
d2467 1
d2479 1
d2488 1
d2491 1
d2497 2
a2506 1
   GLboolean MESA_program_debug;
d2510 1
d2512 1
d2514 1
d2518 1
a2528 2
   GLboolean SGIX_shadow;
   GLboolean SGIX_shadow_ambient; /* or GL_ARB_shadow_ambient */
d2531 4
a2534 2
   /*@@}*/
   /* The extension string */
d2536 2
a2555 1
 *
d2570 1
a2570 1
#define IMAGE_CLAMP_BIT                           0x800 /* extra */
d2623 3
d2708 4
d2721 3
a2723 3
#define _IMAGE_NEW_TRANSFER_STATE         (_NEW_PIXEL | _NEW_COLOR_MATRIX)


a2725 5
/*
 * Forward declaration of display list data types:
 */
union node;
typedef union node Node;
d2757 4
a2760 1
/* Strictly this is a tnl/ private concept, but it doesn't seem
d2764 2
a2765 1
#define MESA_DLIST_DANGLING_REFS     0x1 
d2767 6
a2772 1
/* Provide a location where information about a display list can be
d2776 1
a2776 1
struct mesa_display_list
d2778 4
a2781 3
   Node *node;
   GLuint id;
   GLbitfield flags;
d2792 2
a2793 4
   struct mesa_display_list *CurrentList;
   Node *CurrentListPtr;	/**< Head of list being compiled */
   GLuint CurrentListNum;	/**< Number of the list being compiled */
   Node *CurrentBlock;		/**< Pointer to current block of nodes */
d2809 7
d2879 4
a2945 6
#if 0
   struct gl_color_table PostConvolutionColorTable;
   struct gl_color_table ProxyPostConvolutionColorTable;
   struct gl_color_table PostColorMatrixColorTable;
   struct gl_color_table ProxyPostColorMatrixColorTable;
#endif
d2947 6
a2952 4
   struct gl_program_state Program;        /**< for vertex or fragment progs */
   struct gl_vertex_program_state VertexProgram;   /**< GL_ARB/NV_vertex_program */
   struct gl_fragment_program_state FragmentProgram;  /**< GL_ARB/NV_vertex_program */
   struct gl_ati_fragment_shader_state ATIFragmentShader;  /**< GL_ATI_fragment_shader */
d2954 1
a2954 1
   struct gl_query_state Query;  /**< GL_ARB_occlusion_query */
d2956 2
a2957 1
   struct gl_shader_state Shader; /**< GLSL shader object state */
d2960 2
d2967 7
d2977 4
a2991 1
   GLenum _CurrentProgram;    /* currently executing program */
d2993 1
a2993 1
   GLuint TextureStateTimestamp; /* detect changes to shared state */
d2999 1
a2999 1
   struct gl_list_extensions ListExt; /**< driver dlist extensions */
d3012 6
d3031 1
a3031 1
   void *acache_context;
d3055 1
d3060 1
a3060 1
   VERBOSE_IMMEDIATE		= 0x0004,
d3070 2
a3071 2
   VERBOSE_GLSL			= 0x2000,
   VERBOSE_GLSL_DUMP		= 0x4000
d3075 1
d3083 1
a3083 4
#define Elements(x) sizeof(x)/sizeof(*(x))


#endif /* TYPES_H */
@


1.4
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@a0 7
/**
 * \file mtypes.h
 * Main Mesa data structures.
 *
 * Please try to mark derived values with a leading underscore ('_').
 */

d3 1
a3 1
 * Version:  6.5.3
d6 1
d26 6
a31 1

d40 1
a40 2
#include "glapi/glapitable.h"
#include "glapi/glthread.h"
d124 1
d151 1
d641 1
a641 1
   GLfloat RasterTexCoords[MAX_TEXTURE_COORD_UNITS][4];
d725 2
a726 2
   GLuint Texture[MAX_TEXTURE_IMAGE_UNITS];
   GLuint TexGen[MAX_TEXTURE_COORD_UNITS];
d728 1
a728 1
   GLboolean TextureColorTable[MAX_TEXTURE_IMAGE_UNITS];
d1071 1
a1071 1
   GLboolean CoordReplace[MAX_TEXTURE_COORD_UNITS]; /**< GL_ARB_point_sprite */
d1111 13
d1129 1
a1129 1
   GLubyte ActiveFace;		/**< GL_EXT_stencil_two_side (0 or 1) */
d1131 8
a1138 7
   GLenum Function[2];		/**< Stencil function */
   GLenum FailFunc[2];		/**< Fail function */
   GLenum ZPassFunc[2];		/**< Depth buffer pass function */
   GLenum ZFailFunc[2];		/**< Depth buffer fail function */
   GLint Ref[2];		/**< Reference value */
   GLuint ValueMask[2];		/**< Value mask */
   GLuint WriteMask[2];		/**< Write mask */
d1448 1
a1457 1

d1544 2
a1545 7
   struct gl_texture_object *Current1D;
   struct gl_texture_object *Current2D;
   struct gl_texture_object *Current3D;
   struct gl_texture_object *CurrentCubeMap; /**< GL_ARB_texture_cube_map */
   struct gl_texture_object *CurrentRect;    /**< GL_NV_texture_rectangle */
   struct gl_texture_object *Current1DArray; /**< GL_MESA_texture_array */
   struct gl_texture_object *Current2DArray; /**< GL_MESA_texture_array */
d1547 2
a1548 1
   struct gl_texture_object *_Current; /**< Points to really enabled tex obj */
a1558 9
struct texenvprog_cache_item;

struct texenvprog_cache
{
   struct texenvprog_cache_item **items;
   GLuint size, n_items;
   GLcontext *ctx;
};

d1569 1
a1569 1
   GLuint CurrentUnit;	       /**< Active texture unit */
a1584 3
   
   /** Cached texenv fragment programs */
   struct texenvprog_cache env_fp_cache;
d1705 1
d1885 3
a1887 1
   GLbitfield TexturesUsed[MAX_TEXTURE_IMAGE_UNITS];  /**< TEXTURE_x_BIT bitmask */
d1891 1
d1947 4
a1950 1
   GLboolean UsesKill;
d1969 2
a1970 2
   GLboolean Enabled;               /**< GL_VERTEX_PROGRAM_ARB/NV */
   GLboolean _Enabled;              /**< Enabled and valid program? */
d1973 1
a1973 1
   struct gl_vertex_program *Current;  /**< user-bound vertex program */
d1975 3
a1977 2
   /** Currently enabled and valid program (including internal programs
    * and compiled shader programs).
d1993 3
d2011 1
a2011 2
   GLboolean _Enabled;    /**< Fragment program enabled and valid? */
   GLboolean _Active;
d2014 3
a2016 2
   /** Currently enabled and valid program (including internal programs
    * and compiled shader programs).
a2023 1
   GLboolean _UseTexEnvProgram;
d2028 3
d2088 5
a2092 4
   GLuint Id;
   GLuint64EXT Result; /* the counter */
   GLboolean Active;   /* inside Begin/EndQuery */
   GLboolean Ready;    /* result is ready */
d2107 7
d2124 2
a2125 1

a2126 1
   GLboolean CompileStatus;
d2129 1
a2129 1
   GLboolean Main;  /**< shader defines main() */
d2185 2
a2186 12
   /**
    * \name Default texture objects (shared by all multi-texture units)
    */
   /*@@{*/
   struct gl_texture_object *Default1D;
   struct gl_texture_object *Default2D;
   struct gl_texture_object *Default3D;
   struct gl_texture_object *DefaultCubeMap;
   struct gl_texture_object *DefaultRect;
   struct gl_texture_object *Default1DArray;
   struct gl_texture_object *Default2DArray;
   /*@@}*/
d2379 10
a2388 2
   _glthread_Mutex Mutex;		   /**< for thread safety */
   GLuint Name;      /* if zero, this is a window system framebuffer */
d2484 3
a2486 3
   GLuint MaxTextureUnits;              /* = MIN(CoordUnits, ImageUnits) */
   GLfloat MaxTextureMaxAnisotropy;	/* GL_EXT_texture_filter_anisotropic */
   GLfloat MaxTextureLodBias;           /* GL_EXT_texture_lod_bias */
d2520 1
a2520 1
   GLuint MaxVarying;
a2645 1
   GLboolean SGIX_depth_texture;
d2757 1
d2775 1
d2961 1
a2961 1
   struct gl_matrix_stack TextureMatrixStack[MAX_TEXTURE_COORD_UNITS];
d3148 3
a3150 1
   VERBOSE_DISASSEM		= 0x1000
@


1.3
log
@Update to Mesa 7.0.3. tested my oga@@ and johan@@
@
text
@d10 1
a10 1
 * Version:  7.0.3
d41 2
a42 2
#include "glapitable.h"
#include "glthread.h"
a919 1
   GLfloat _Width;		/**< Clamped Line width */
d961 1
a1065 1
   GLfloat _Size;		/**< Size clamped to user limits */
d1129 1
a1129 1
#define NUM_TEXTURE_TARGETS 5   /* 1D, 2D, 3D, CUBE and RECT */
d1135 7
a1141 5
#define TEXTURE_1D_INDEX    0
#define TEXTURE_2D_INDEX    1
#define TEXTURE_3D_INDEX    2
#define TEXTURE_CUBE_INDEX  3
#define TEXTURE_RECT_INDEX  4
d1149 7
a1155 5
#define TEXTURE_1D_BIT   (1 << TEXTURE_1D_INDEX)
#define TEXTURE_2D_BIT   (1 << TEXTURE_2D_INDEX)
#define TEXTURE_3D_BIT   (1 << TEXTURE_3D_INDEX)
#define TEXTURE_CUBE_BIT (1 << TEXTURE_CUBE_INDEX)
#define TEXTURE_RECT_BIT (1 << TEXTURE_RECT_INDEX)
d1292 9
a1300 3
   GLubyte RedBits;		/**< Bits per texel component */
   GLubyte GreenBits;		/**< These are just rough approximations for */
   GLubyte BlueBits;		/**< compressed texture formats. */
d1307 1
a1328 2
#define MAX_3D_TEXTURE_SIZE (1 << (MAX_3D_TEXTURE_LEVELS - 1))

d1369 1
a1369 1
   GLuint RowStride;		/**< == Width unless IsClientData and padded */
d1393 1
a1393 1
#define MAX_FACES  6
d1427 4
d1435 1
a1435 1
   GLboolean Complete;		/**< Is texture object complete? */
d1502 1
a1502 1
   GLbitfield _GenFlags;	/**< bitwise or of GenBit[STRQ] */
d1535 2
d1540 2
a1541 1
   /* GL_SGI_texture_color_table */
d1545 1
a1547 6
struct texenvprog_cache_item {
   GLuint hash;
   void *key;
   struct gl_fragment_program *data;
   struct texenvprog_cache_item *next;
};
d1549 4
a1552 1
struct texenvprog_cache {
d1558 1
d1578 2
a1579 5
   struct gl_texture_object *Proxy1D;
   struct gl_texture_object *Proxy2D;
   struct gl_texture_object *Proxy3D;
   struct gl_texture_object *ProxyCubeMap;
   struct gl_texture_object *ProxyRect;
d1867 1
d1887 2
d1900 5
d2097 1
a2097 1
 * A GLSL shader object.
d2108 1
a2108 2
   GLuint NumPrograms;  /**< size of Programs[] array */
   struct gl_program **Programs;  /**< Post-compile assembly code */
d2110 1
d2115 2
a2116 1
 * A GLSL program object.  Basically a linked collection of "shaders".
d2128 3
d2134 1
a2134 1
   struct gl_program_parameter_list *Uniforms; /**< Plus constants, etc */
a2135 1
   struct gl_program_parameter_list *Attributes; /**< Vertex attributes */
d2175 2
d2186 2
a2187 2
   _glthread_Mutex TexMutex;		   /**< texobj thread safety */
   GLuint TextureStateStamp;	           /**< state notification for shared tex  */
a2190 1

d2197 1
a2197 1
   struct gl_program *DefaultVertexProgram;
d2200 1
a2200 1
   struct gl_program *DefaultFragmentProgram;
d2342 1
a2342 1
   GLenum Type;  /* GL_NONE or GL_TEXTURE or GL_RENDERBUFFER_EXT */
d2345 4
a2348 1
   /* IF Type == GL_RENDERBUFFER_EXT: */
d2351 4
a2354 1
   /* IF Type == GL_TEXTURE: */
d2356 4
a2359 3
   GLuint TextureLevel;
   GLuint CubeMapFace;  /* 0 .. 5, for cube map textures */
   GLuint Zoffset;      /* for 3D textures */
d2407 3
a2409 2
   /* These are computed from ColorDrawBuffer and ColorReadBuffer */
   GLbitfield _ColorDrawBufferMask[MAX_DRAW_BUFFERS]; /* Mask of BUFFER_BIT_* flags */
d2411 1
a2411 4

   /* These are computed from _ColorDrawBufferMask and _ColorReadBufferIndex */
   GLuint _NumColorDrawBuffers[MAX_DRAW_BUFFERS];
   struct gl_renderbuffer *_ColorDrawBuffers[MAX_DRAW_BUFFERS][4];
d2463 1
d2523 1
d2613 1
d3050 4
a3053 1
   GLbitfield _TriangleCaps;      /**< bitwise-or of DD_* flags */
@


1.2
log
@Update to Mesa 7.0.2. Tested by naddy@@ (full ports build), simon@@
and oga@@ (with dri enabled).
@
text
@d10 1
a10 1
 * Version:  6.5.3
d1066 1
a1066 1
   GLfloat _Size;		/**< Size clamped to Const.Min/MaxPointSize */
a3033 6


   GLuint _Facing; /**< This is a hack for 2-sided stencil test.
		    *
		    * We don't have a better way to communicate this value from
		    * swrast_setup to swrast. */
@


1.1
log
@Initial revision
@
text
@d10 1
a10 1
 * Version:  6.5
d12 1
a12 1
 * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
d39 1
a39 1
#include <GL/internal/glcore.h>	/* GLimports/GLexports/GLcontextModes */
d48 6
d152 1
a152 1
   VERT_ATTRIB_SEVEN = 7,
d192 1
a192 1
#define VERT_BIT_SEVEN       (1 << VERT_ATTRIB_SEVEN)
a221 16
/**
 * GLSL allows shader writers to allocate vertex result attributes (varyings) in
 * single float component granularity. This is in contrast to vertex / fragment
 * programs, where result attributes (actually texcoords) were allocated
 * in 4-component vectors of floats granularity.
 * For performance reasons, it would be optimal to stick with this scheme on a scalar
 * processor. Varyings will likely be allocated as 3-component vectors, so statistically
 * we win 2 floats.
 * The constant VARYINGS_PER_VECTOR tells us how much of float components we pack into
 * one result vector. For scalar processor it would be 1, for vector processor - 4.
 * 
 * NOTE: Currently we pack varyings into vertex attributes.
 */
#define VARYINGS_PER_VECTOR 2
#define VARYING_EMIT_STYLE  EMIT_2F
#define MAX_VARYING_VECTORS ((MAX_VARYING_FLOATS + VARYINGS_PER_VECTOR - 1) / VARYINGS_PER_VECTOR)
d243 2
a244 1
#define VERT_RESULT_MAX  16
d265 2
a266 1
   FRAG_ATTRIB_MAX = 12
d285 4
d304 8
a311 6
/*@@{*/
#define FRAG_RESULT_COLR  0
#define FRAG_RESULT_COLH  1
#define FRAG_RESULT_DEPR  2
#define FRAG_RESULT_MAX   3
/*@@}*/
d384 7
d400 3
a402 3
   GLuint Size;           /**< number of entries (rows) in table */
   GLvoid *Table;         /**< points to data of <Type> */
   GLenum Type;           /**< GL_UNSIGNED_BYTE or GL_FLOAT */
d624 2
a628 2
   GLfloat Index;			/**< Current color index */
   GLboolean EdgeFlag;			/**< Current edge flag */
d671 1
a671 3
   GLboolean ColorTable;                /* SGI_color_table */
   GLboolean PostColorMatrixColorTable; /* SGI_color_table */
   GLboolean PostConvolutionColorTable; /* SGI_color_table */
d894 1
d971 29
d1005 5
d1016 3
d1021 7
a1027 46
   GLfloat ZoomX, ZoomY;
   /* XXX move these out of gl_pixel_attrib */
   GLint MapStoSsize;		/**< Size of each pixel map */
   GLint MapItoIsize;
   GLint MapItoRsize;
   GLint MapItoGsize;
   GLint MapItoBsize;
   GLint MapItoAsize;
   GLint MapRtoRsize;
   GLint MapGtoGsize;
   GLint MapBtoBsize;
   GLint MapAtoAsize;
   GLint MapStoS[MAX_PIXEL_MAP_TABLE];	/**< Pixel map tables */
   GLfloat MapItoI[MAX_PIXEL_MAP_TABLE];
   GLfloat MapItoR[MAX_PIXEL_MAP_TABLE];
   GLfloat MapItoG[MAX_PIXEL_MAP_TABLE];
   GLfloat MapItoB[MAX_PIXEL_MAP_TABLE];
   GLfloat MapItoA[MAX_PIXEL_MAP_TABLE];
   GLubyte MapItoR8[MAX_PIXEL_MAP_TABLE];  /**< converted to 8-bit color */
   GLubyte MapItoG8[MAX_PIXEL_MAP_TABLE];
   GLubyte MapItoB8[MAX_PIXEL_MAP_TABLE];
   GLubyte MapItoA8[MAX_PIXEL_MAP_TABLE];
   GLfloat MapRtoR[MAX_PIXEL_MAP_TABLE];
   GLfloat MapGtoG[MAX_PIXEL_MAP_TABLE];
   GLfloat MapBtoB[MAX_PIXEL_MAP_TABLE];
   GLfloat MapAtoA[MAX_PIXEL_MAP_TABLE];
   /** GL_EXT_histogram */
   GLboolean HistogramEnabled;
   GLboolean MinMaxEnabled;
   /** GL_SGI_color_matrix */
   GLfloat PostColorMatrixScale[4];  /**< RGBA */
   GLfloat PostColorMatrixBias[4];   /**< RGBA */
   /** GL_SGI_color_table */
   GLfloat ColorTableScale[4];
   GLfloat ColorTableBias[4];
   GLboolean ColorTableEnabled;
   GLfloat PCCTscale[4];
   GLfloat PCCTbias[4];
   GLboolean PostConvolutionColorTableEnabled;
   GLfloat PCMCTscale[4];
   GLfloat PCMCTbias[4];
   GLboolean PostColorMatrixColorTableEnabled;
   /** GL_SGI_texture_color_table */
   GLfloat TextureColorTableScale[4];
   GLfloat TextureColorTableBias[4];
   /** Convolution */
d1033 2
a1034 2
   GLfloat ConvolutionFilterScale[3][4];
   GLfloat ConvolutionFilterBias[3][4];
d1037 19
a1525 6
   struct gl_texture_object Saved1D;  /**< only used by glPush/PopAttrib */
   struct gl_texture_object Saved2D;
   struct gl_texture_object Saved3D;
   struct gl_texture_object SavedCubeMap;
   struct gl_texture_object SavedRect;

a1656 2
#define CA_CLIENT_DATA     0x1	/**< Data not allocated by mesa */

d1668 1
a1668 1
   GLbitfield Enabled;		/**< one of the _NEW_ARRAY_ bits */
a1673 2

   GLbitfield Flags;
d1694 1
a1695 1
   struct gl_client_array EdgeFlag;
a1822 12
 * State used during execution of fragment programs.
 */
struct fp_machine
{
   GLfloat Temporaries[MAX_NV_FRAGMENT_PROGRAM_TEMPS][4];
   GLfloat Inputs[MAX_NV_FRAGMENT_PROGRAM_INPUTS][4];
   GLfloat Outputs[MAX_NV_FRAGMENT_PROGRAM_OUTPUTS][4];
   GLuint CondCodes[4];
};


/**
d1824 1
d1827 5
d1835 14
a1848 11
   PROGRAM_TEMPORARY = 0,
   PROGRAM_LOCAL_PARAM = 1,
   PROGRAM_ENV_PARAM = 2,
   PROGRAM_STATE_VAR = 3,
   PROGRAM_INPUT = 4,
   PROGRAM_OUTPUT = 5,
   PROGRAM_NAMED_PARAM = 6,
   PROGRAM_CONSTANT = 7,
   PROGRAM_WRITE_ONLY = 8,
   PROGRAM_ADDRESS = 9,
   PROGRAM_UNDEFINED = 10,  /* invalid value */
d1864 1
a1864 1
   GLubyte *String;          /**< Null-terminated program text */
d1866 2
a1867 2
   GLenum Target;
   GLenum Format;            /**< String encoding format */
d1872 3
a1874 2
   GLbitfield InputsRead;     /* Bitmask of which input regs are read */
   GLbitfield OutputsWritten; /* Bitmask of which output regs are written to */
d1881 5
d1893 3
d1904 3
a1924 7
   GLbitfield TexturesUsed[MAX_TEXTURE_IMAGE_UNITS];  /**< TEXTURE_x_BIT bitmask */
   GLuint NumAluInstructions; /**< GL_ARB_fragment_program */
   GLuint NumTexInstructions;
   GLuint NumTexIndirections;
   GLuint NumNativeAluInstructions; /**< GL_ARB_fragment_program */
   GLuint NumNativeTexInstructions;
   GLuint NumNativeTexIndirections;
d1941 1
a1941 1
 * State vars for GL_ARB/GL_NV_vertex_program
d1945 22
a1966 19
   GLboolean Enabled;                  /**< GL_VERTEX_PROGRAM_ARB/NV */
   GLboolean _Enabled;                 /**< Enabled and valid program? */
   GLboolean PointSizeEnabled;         /**< GL_VERTEX_PROGRAM_POINT_SIZE_ARB/NV */
   GLboolean TwoSideEnabled;           /**< GL_VERTEX_PROGRAM_TWO_SIDE_ARB/NV */
   struct gl_vertex_program *Current;  /**< ptr to currently bound program */
   const struct gl_vertex_program *_Current;    /**< ptr to currently bound
					          program, including internal
					          (t_vp_build.c) programs */

   GLenum TrackMatrix[MAX_NV_VERTEX_PROGRAM_PARAMS / 4];
   GLenum TrackMatrixTransform[MAX_NV_VERTEX_PROGRAM_PARAMS / 4];

   GLfloat Parameters[MAX_NV_VERTEX_PROGRAM_PARAMS][4]; /* Env params */
   /* Only used during program execution (may be moved someday): */
   GLfloat Temporaries[MAX_NV_VERTEX_PROGRAM_TEMPS][4];
   GLfloat Inputs[MAX_NV_VERTEX_PROGRAM_INPUTS][4];
   GLuint InputsSize[MAX_NV_VERTEX_PROGRAM_INPUTS];
   GLfloat Outputs[MAX_NV_VERTEX_PROGRAM_OUTPUTS][4];
   GLint AddressReg[4];
d1978 1
a1978 1
 * Context state for GL_ARB/NV_fragment_program
d1982 2
a1983 2
   GLboolean Enabled;                    /* GL_VERTEX_PROGRAM_NV */
   GLboolean _Enabled;                   /* Enabled and valid program? */
d1985 15
a1999 5
   struct gl_fragment_program *Current;  /* ptr to currently bound program */
   const struct gl_fragment_program *_Current; /* ptr to currently active program 
					       (including internal programs) */
   struct fp_machine Machine;            /* machine state */
   GLfloat Parameters[MAX_NV_FRAGMENT_PROGRAM_PARAMS][4]; /* Env params */
a2019 11
 * State for executing ATI fragment shader.
 */
struct atifs_machine
{
   GLfloat Registers[6][4];         /** six temporary registers */
   GLfloat PrevPassRegisters[6][4];
   GLfloat Inputs[2][4];   /** Primary, secondary input colors */
};


/**
a2048 1
   struct atifs_machine Machine;            /* machine state */
d2076 1
d2078 1
a2078 1
 * Context state for vertex/fragment shaders.
d2080 1
a2080 1
struct gl_shader_objects_state
d2082 49
a2130 3
   struct gl2_program_intf **CurrentProgram;
   GLboolean _VertexShaderPresent;
   GLboolean _FragmentShaderPresent;
d2156 13
d2191 2
a2192 1
   struct _mesa_HashTable *GL2Objects;
d2220 2
d2239 1
a2239 1
   GLvoid *Data;
d2343 1
d2421 2
d2472 3
d2503 1
d2575 1
d2612 1
a2612 1
struct matrix_stack
d2709 1
a2709 1
#define _NEW_ARRAY_EDGEFLAG         VERT_BIT_SEVEN
d2718 1
a2718 1
#define _NEW_ARRAY_ATTRIB_0         0x10000  /* start at bit 16 */
d2775 1
d2843 1
a2843 1
struct mesa_list_state
a2844 1
   struct mesa_display_list *CallStack[MAX_LIST_NESTING];
a2880 11
   /**
    * \name OS related interfaces. 
    *
    * These \b must be the first members of this structure, because they are
    * exposed to the outside world (i.e. GLX extension).
    */
   /*@@{*/
   __GLimports imports;
   __GLexports exports;
   /*@@}*/

a2902 1
   void *DriverMgrCtx;	/**< Points to device driver manager (optional)*/
d2909 6
a2914 6
   struct matrix_stack ModelviewMatrixStack;
   struct matrix_stack ProjectionMatrixStack;
   struct matrix_stack ColorMatrixStack;
   struct matrix_stack TextureMatrixStack[MAX_TEXTURE_COORD_UNITS];
   struct matrix_stack ProgramMatrixStack[MAX_PROGRAM_MATRICES];
   struct matrix_stack *CurrentStack; /**< Points to one of the above stacks */
d2921 1
a2921 1
   struct mesa_list_state ListState;
d2979 1
d2990 3
a2992 2
   struct gl_color_table ColorTable;       /**< Pre-convolution */
   struct gl_color_table ProxyColorTable;  /**< Pre-convolution */
d2997 1
a3003 7
   struct gl_fragment_program *_TexEnvProgram;     /**< Texture state as fragment program */
   struct gl_vertex_program *_TnlProgram;          /**< Fixed func TNL state as vertex program */

   GLboolean _MaintainTnlProgram;
   GLboolean _MaintainTexEnvProgram;
   GLboolean _UseTexEnvProgram;

d3006 1
a3006 1
   struct gl_shader_objects_state ShaderObjects;	/* GL_ARB_shader_objects */
d3026 2
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d395 3
a397 3
   GLuint Size;                /**< number of entries in table */
   GLfloat *TableF;            /**< Color table, floating point values */
   GLubyte *TableUB;           /**< Color table, ubyte values */
a890 1
   GLenum ClampVertexColor;
d1812 12
d1928 1
a1928 1
 * Context state for vertex programs.
d1932 4
a1935 4
   GLboolean Enabled;               /**< GL_VERTEX_PROGRAM_ARB/NV */
   GLboolean _Enabled;              /**< Enabled and valid program? */
   GLboolean PointSizeEnabled;      /**< GL_VERTEX_PROGRAM_POINT_SIZE_ARB/NV */
   GLboolean TwoSideEnabled;        /**< GL_VERTEX_PROGRAM_TWO_SIDE_ARB/NV */
a1940 3
   GLfloat Parameters[MAX_NV_VERTEX_PROGRAM_PARAMS][4]; /**< Env params */

   /* For GL_NV_vertex_program only: */
d1944 8
d1962 1
a1962 1
 * Context state for fragment programs.
d1966 5
a1970 5
   GLboolean Enabled;     /**< User-set fragment program enable flag */
   GLboolean _Enabled;    /**< Fragment program enabled and valid? */
   GLboolean _Active;     /**< Is a user program or internal program active? */
   struct gl_fragment_program *Current;  /**< User-bound program */
   const struct gl_fragment_program *_Current; /**< currently active program 
d1972 2
a1973 1
   GLfloat Parameters[MAX_NV_FRAGMENT_PROGRAM_PARAMS][4]; /**< Env params */
d1994 11
d2034 1
a2094 13
    * \name Thread safety and statechange notification for texture
    * objects. 
    *
    * \todo Improve the granularity of locking.
    */
   /*@@{*/
   _glthread_Mutex TexMutex;		   /**< texobj thread safety */
   GLuint TextureStateStamp;	           /**< state notification for shared tex  */
   /*@@}*/



   /**
a2342 2
   /* For shaders */
   GLuint MaxUniformComponents;
a2391 3
   /* GL_ARB_vertex_shader */
   GLuint MaxVertexTextureImageUnits;
   GLuint MaxVaryingFloats;
a2419 1
   GLboolean ARB_shading_language_120;
a2956 2

   GLuint TextureStateTimestamp; /* detect changes to shared state */
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d10 1
a10 1
 * Version:  6.5.3
d12 1
a12 1
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
d39 1
a39 1
#include <GL/internal/glcore.h>	/* __GLcontextModes (GLvisual) */
a47 6
 * Special, internal token
 */
#define GL_SHADER_PROGRAM_MESA 0x9999


/**
d146 1
a146 1
   VERT_ATTRIB_EDGEFLAG = 7,
d186 1
a186 1
#define VERT_BIT_EDGEFLAG    (1 << VERT_ATTRIB_EDGEFLAG)
d216 16
d253 1
a253 2
#define VERT_RESULT_VAR0 16  /**< shader varying */
#define VERT_RESULT_MAX  (VERT_RESULT_VAR0 + MAX_VARYING)
d274 1
a274 2
   FRAG_ATTRIB_VAR0 = 12,  /**< shader varying */
   FRAG_ATTRIB_MAX = (FRAG_ATTRIB_VAR0 + MAX_VARYING)
a292 4
#define FRAG_BIT_VAR0  (1 << FRAG_ATTRIB_VAR0)

#define FRAG_BIT_TEX(U)  (FRAG_BIT_TEX0 << (U))
#define FRAG_BIT_VAR(V)  (FRAG_BIT_VAR0 << (V))
d308 6
a313 8
enum
{
   FRAG_RESULT_COLR = 0,
   FRAG_RESULT_COLH = 1,
   FRAG_RESULT_DEPR = 2,
   FRAG_RESULT_DATA0 = 3,
   FRAG_RESULT_MAX = (FRAG_RESULT_DATA0 + MAX_DRAW_BUFFERS)
};
a385 7
/** The pixel transfer path has three color tables: */
/*@@{*/
#define COLORTABLE_PRECONVOLUTION  0
#define COLORTABLE_POSTCONVOLUTION 1
#define COLORTABLE_POSTCOLORMATRIX 2
#define COLORTABLE_MAX 3
/*@@}*/
a618 2
    * \note Index and Edgeflag current values are stored as floats in the 
    * SIX and SEVEN attribute slots.
d622 2
d666 3
a668 1
   GLboolean ColorTable[COLORTABLE_MAX];
a967 29
 * A pixelmap (see glPixelMap)
 */
struct gl_pixelmap
{
   GLint Size;
   GLfloat Map[MAX_PIXEL_MAP_TABLE];
   GLubyte Map8[MAX_PIXEL_MAP_TABLE];  /**< converted to 8-bit color */
};


/**
 * Collection of all pixelmaps
 */
struct gl_pixelmaps
{
   struct gl_pixelmap RtoR;  /**< i.e. GL_PIXEL_MAP_R_TO_R */
   struct gl_pixelmap GtoG;
   struct gl_pixelmap BtoB;
   struct gl_pixelmap AtoA;
   struct gl_pixelmap ItoR;
   struct gl_pixelmap ItoG;
   struct gl_pixelmap ItoB;
   struct gl_pixelmap ItoA;
   struct gl_pixelmap ItoI;
   struct gl_pixelmap StoS;
};


/**
a972 5

   /*--- Begin Pixel Transfer State ---*/
   /* Fields are in the order in which they're applied... */

   /* Scale & Bias (index shift, offset) */
a978 3

   /* Pixel Maps */
   /* Note: actual pixel maps are not part of this attrib group */
d981 46
a1026 7

   /* There are multiple color table stages: */
   GLboolean ColorTableEnabled[COLORTABLE_MAX];
   GLfloat ColorTableScale[COLORTABLE_MAX][4];  /**< RGBA */
   GLfloat ColorTableBias[COLORTABLE_MAX][4];   /**< RGBA */

   /* Convolution (GL_EXT_convolution) */
d1032 2
a1033 2
   GLfloat ConvolutionFilterScale[3][4];  /**< RGBA */
   GLfloat ConvolutionFilterBias[3][4];   /**< RGBA */
a1035 19

   /* Color matrix (GL_SGI_color_matrix) */
   /* Note: the color matrix is not part of this attrib group */
   GLfloat PostColorMatrixScale[4];  /**< RGBA */
   GLfloat PostColorMatrixBias[4];   /**< RGBA */

   /* Histogram & minmax (GL_EXT_histogram) */
   /* Note: histogram and minmax data are not part of this attrib group */
   GLboolean HistogramEnabled;
   GLboolean MinMaxEnabled;

   /*--- End Pixel Transfer State ---*/

   /* Pixel Zoom */
   GLfloat ZoomX, ZoomY;

   /** GL_SGI_texture_color_table */
   GLfloat TextureColorTableScale[4];
   GLfloat TextureColorTableBias[4];
d1643 2
d1656 1
a1656 1
   GLboolean Enabled;		/**< Enabled flag is a boolean */
d1662 2
d1684 1
a1685 1
   struct gl_client_array TexCoord[MAX_TEXTURE_COORD_UNITS];
a1813 1
 *
a1815 5
 *
 * NOTE: PROGRAM_ENV_PARAM, PROGRAM_STATE_VAR, PROGRAM_NAMED_PARAM,
 * PROGRAM_CONSTANT, and PROGRAM_UNIFORM can all be considered to
 * be "uniform" variables since they can only be set outside glBegin/End.
 * They're also all stored in the same Parameters array.
d1819 11
a1829 14
   PROGRAM_TEMPORARY = 0,   /**< machine->Temporary[] */
   PROGRAM_LOCAL_PARAM = 1, /**< gl_program->LocalParams[] */
   PROGRAM_ENV_PARAM = 2,   /**< gl_program->Parameters[] */
   PROGRAM_STATE_VAR = 3,   /**< gl_program->Parameters[] */
   PROGRAM_INPUT = 4,       /**< machine->Inputs[] */
   PROGRAM_OUTPUT = 5,      /**< machine->Outputs[] */
   PROGRAM_NAMED_PARAM = 6, /**< gl_program->Parameters[] */
   PROGRAM_CONSTANT = 7,    /**< gl_program->Parameters[] */
   PROGRAM_UNIFORM = 8,     /**< gl_program->Parameters[] */
   PROGRAM_VARYING = 9,     /**< machine->Inputs[]/Outputs[] */
   PROGRAM_WRITE_ONLY = 10, /**< A dummy, write-only register */
   PROGRAM_ADDRESS = 11,    /**< machine->AddressReg */
   PROGRAM_SAMPLER = 12,    /**< for shader samplers, compile-time only */
   PROGRAM_UNDEFINED = 13,  /**< Invalid value */
d1845 1
a1845 1
   GLubyte *String;  /**< Null-terminated program text */
d1847 2
a1848 2
   GLenum Target;    /**< GL_VERTEX/FRAGMENT_PROGRAM_ARB, GL_FRAGMENT_PROGRAM_NV */
   GLenum Format;    /**< String encoding format */
d1853 2
a1854 3
   GLbitfield InputsRead;     /**< Bitmask of which input regs are read */
   GLbitfield OutputsWritten; /**< Bitmask of which output regs are written to */
   GLbitfield TexturesUsed[MAX_TEXTURE_IMAGE_UNITS];  /**< TEXTURE_x_BIT bitmask */
a1860 5
   /** Vertex/fragment shader varying vars */
   struct gl_program_parameter_list *Varying;
   /** Vertex program user-defined attributes */
   struct gl_program_parameter_list *Attributes;

a1867 3
   GLuint NumAluInstructions;
   GLuint NumTexInstructions;
   GLuint NumTexIndirections;
a1875 3
   GLuint NumNativeAluInstructions;
   GLuint NumNativeTexInstructions;
   GLuint NumNativeTexIndirections;
d1894 7
d1925 4
a1928 6
   struct gl_vertex_program *Current;  /**< user-bound vertex program */

   /** Currently enabled and valid program (including internal programs
    * and compiled shader programs).
    */
   struct gl_vertex_program *_Current;
d1930 1
a1930 1
   GLfloat Parameters[MAX_PROGRAM_ENV_PARAMS][4]; /**< Env params */
d1933 2
a1934 8
   GLenum TrackMatrix[MAX_PROGRAM_ENV_PARAMS / 4];
   GLenum TrackMatrixTransform[MAX_PROGRAM_ENV_PARAMS / 4];

   /** Should fixed-function T&L be implemented with a vertex prog? */
   GLboolean _MaintainTnlProgram;

   /** Program to emulate fixed-function T&L (see above) */
   struct gl_vertex_program *_TnlProgram;
d1952 5
a1956 16
   GLboolean _Active;
   struct gl_fragment_program *Current;  /**< User-bound fragment program */

   /** Currently enabled and valid program (including internal programs
    * and compiled shader programs).
    */
   struct gl_fragment_program *_Current;

   GLfloat Parameters[MAX_PROGRAM_ENV_PARAMS][4]; /**< Env params */

   /** Should fixed-function texturing be implemented with a fragment prog? */
   GLboolean _MaintainTexEnvProgram;
   GLboolean _UseTexEnvProgram;

   /** Program to emulate fixed-function texture env/combine (see above) */
   struct gl_fragment_program *_TexEnvProgram;
a2032 1

d2034 1
a2034 1
 * A GLSL shader object.
d2036 1
a2036 1
struct gl_shader
d2038 3
a2040 49
   GLenum Type;  /**< GL_FRAGMENT_SHADER || GL_VERTEX_SHADER (first field!) */
   GLuint Name;  /**< AKA the handle */
   GLint RefCount;  /**< Reference count */
   GLboolean DeletePending;

   const GLchar *Source;  /**< Source code string */
   GLboolean CompileStatus;
   GLuint NumPrograms;  /**< size of Programs[] array */
   struct gl_program **Programs;  /**< Post-compile assembly code */
   GLchar *InfoLog;
};


/**
 * A GLSL program object.  Basically a linked collection of "shaders".
 */
struct gl_shader_program
{
   GLenum Type;  /**< Always GL_SHADER_PROGRAM (internal token) */
   GLuint Name;  /**< aka handle or ID */
   GLint RefCount;  /**< Reference count */
   GLboolean DeletePending;

   GLuint NumShaders;          /**< number of attached shaders */
   struct gl_shader **Shaders; /**< List of attached the shaders */

   /* post-link info: */
   struct gl_vertex_program *VertexProgram;     /**< Linked vertex program */
   struct gl_fragment_program *FragmentProgram; /**< Linked fragment prog */
   struct gl_program_parameter_list *Uniforms; /**< Plus constants, etc */
   struct gl_program_parameter_list *Varying;
   struct gl_program_parameter_list *Attributes; /**< Vertex attributes */
   GLboolean LinkStatus;   /**< GL_LINK_STATUS */
   GLboolean Validated;
   GLchar *InfoLog;
};   


/**
 * Context state for GLSL vertex/fragment shaders.
 */
struct gl_shader_state
{
   struct gl_shader_program *CurrentProgram; /**< The user-bound program */
   /** Driver-selectable options: */
   GLboolean EmitHighLevelInstructions; /**< IF/ELSE/ENDIF vs. BRA, etc. */
   GLboolean EmitCondCodes;             /**< Use condition codes? */
   GLboolean EmitComments;              /**< Annotated instructions */
   void *MemPool;
d2101 1
a2101 2
   /** Table of both gl_shader and gl_shader_program objects */
   struct _mesa_HashTable *ShaderObjects;
a2128 2
#define RB_MAGIC 0xaabbccdd
   int Magic; /** XXX TEMPORARY DEBUG INFO */
d2146 1
a2146 1
   GLvoid *Data;        /**< This may not be used by some kinds of RBs */
a2249 1
   GLboolean DeletePending;
d2380 1
a2380 1
   GLuint MaxVarying;
a2480 1
   GLboolean ATI_separate_stencil;
d2517 1
a2517 1
struct gl_matrix_stack
d2614 1
a2614 1
#define _NEW_ARRAY_EDGEFLAG         VERT_BIT_EDGEFLAG
d2623 1
a2623 1
#define _NEW_ARRAY_ATTRIB_0         VERT_BIT_GENERIC0  /* start at bit 16 */
a2679 1
                                           _NEW_PROGRAM |	\
d2747 1
a2747 1
struct gl_dlist_state
d2786 11
d2819 1
d2826 6
a2831 6
   struct gl_matrix_stack ModelviewMatrixStack;
   struct gl_matrix_stack ProjectionMatrixStack;
   struct gl_matrix_stack ColorMatrixStack;
   struct gl_matrix_stack TextureMatrixStack[MAX_TEXTURE_COORD_UNITS];
   struct gl_matrix_stack ProgramMatrixStack[MAX_PROGRAM_MATRICES];
   struct gl_matrix_stack *CurrentStack; /**< Points to one of the above stacks */
d2838 1
a2838 1
   struct gl_dlist_state ListState;
a2895 1
   struct gl_pixelmaps          PixelMaps;
d2906 2
a2907 3
   struct gl_color_table ColorTable[COLORTABLE_MAX];
   struct gl_color_table ProxyColorTable[COLORTABLE_MAX];
#if 0
a2911 1
#endif
d2918 7
d2927 1
a2927 1
   struct gl_shader_state Shader; /**< GLSL shader object state */
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d1 7
d10 1
a10 1
 * Version:  7.7
d12 1
a12 2
 * Copyright (C) 1999-2008  Brian Paul   All Rights Reserved.
 * Copyright (C) 2009  VMware, Inc.  All Rights Reserved.
a31 6
/**
 * \file mtypes.h
 * Main Mesa data structures.
 *
 * Please try to mark derived values with a leading underscore ('_').
 */
d33 3
a35 2
#ifndef MTYPES_H
#define MTYPES_H
d38 5
a42 4
#include "main/glheader.h"
#include "main/config.h"
#include "main/mfeatures.h"
#include "glapi/glapi.h"
d44 7
a50 1
#include "main/simple_list.h"	/* struct simple_node */
d89 1
a89 1
 * \name 64-bit extension of GLbitfield.
d91 7
a97 2
/*@@{*/
typedef GLuint64 GLbitfield64;
d99 18
a116 2
#define BITFIELD64_ONE         1ULL
#define BITFIELD64_ALLONES     ~0ULL
a117 14
/** Set a single bit */
#define BITFIELD64_BIT(b)      (BITFIELD64_ONE << (b))

/** Set a mask of the least significant \c b bits */
#define BITFIELD64_MASK(b)     (((b) >= 64) ? BITFIELD64_ALLONES : \
				(BITFIELD64_BIT(b) - 1))

/**
 * Set all bits from l (low bit) to h (high bit), inclusive.
 *
 * \note \C BITFIELD_64_RANGE(0, 63) return 64 set bits.
 */
#define BITFIELD64_RANGE(l, h) (BITFIELD64_MASK((h) + 1) & ~BITFIELD64_MASK(l))
/*@@}*/
a124 3
struct gl_attrib_node;
struct gl_list_extensions;
struct gl_meta_state;
a125 1
struct gl_program_cache;
d129 3
a131 2
struct gl_context;
struct st_context;
a136 14
 * Shader stages. Note that these will become 5 with tessellation.
 * These MUST have the same values as gallium's PIPE_SHADER_*
 */
typedef enum
{
   MESA_SHADER_VERTEX = 0,
   MESA_SHADER_FRAGMENT = 1,
   MESA_SHADER_GEOMETRY = 2,
   MESA_SHADER_TYPES = 3
} gl_shader_type;



/**
d143 1
a143 1
typedef enum
a151 1
   VERT_ATTRIB_POINT_SIZE = 6,  /*alias*/
d178 1
a178 1
} gl_vert_attrib;
a225 49
typedef enum
{
   VERT_RESULT_HPOS = 0,
   VERT_RESULT_COL0 = 1,
   VERT_RESULT_COL1 = 2,
   VERT_RESULT_FOGC = 3,
   VERT_RESULT_TEX0 = 4,
   VERT_RESULT_TEX1 = 5,
   VERT_RESULT_TEX2 = 6,
   VERT_RESULT_TEX3 = 7,
   VERT_RESULT_TEX4 = 8,
   VERT_RESULT_TEX5 = 9,
   VERT_RESULT_TEX6 = 10,
   VERT_RESULT_TEX7 = 11,
   VERT_RESULT_PSIZ = 12,
   VERT_RESULT_BFC0 = 13,
   VERT_RESULT_BFC1 = 14,
   VERT_RESULT_EDGE = 15,
   VERT_RESULT_VAR0 = 16,  /**< shader varying */
   VERT_RESULT_MAX = (VERT_RESULT_VAR0 + MAX_VARYING)
} gl_vert_result;


/*********************************************/

/**
 * Indexes for geometry program attributes.
 */
typedef enum
{
   GEOM_ATTRIB_POSITION = 0,
   GEOM_ATTRIB_COLOR0 = 1,
   GEOM_ATTRIB_COLOR1 = 2,
   GEOM_ATTRIB_SECONDARY_COLOR0 = 3,
   GEOM_ATTRIB_SECONDARY_COLOR1 = 4,
   GEOM_ATTRIB_FOG_FRAG_COORD = 5,
   GEOM_ATTRIB_POINT_SIZE = 6,
   GEOM_ATTRIB_CLIP_VERTEX = 7,
   GEOM_ATTRIB_PRIMITIVE_ID = 8,
   GEOM_ATTRIB_TEX_COORD = 9,

   GEOM_ATTRIB_VAR0 = 16,
   GEOM_ATTRIB_MAX = (GEOM_ATTRIB_VAR0 + MAX_VARYING)
} gl_geom_attrib;

/**
 * Bitflags for geometry attributes.
 * These are used in bitfields in many places.
 */
d227 18
a244 13
#define GEOM_BIT_COLOR0      (1 << GEOM_ATTRIB_COLOR0)
#define GEOM_BIT_COLOR1      (1 << GEOM_ATTRIB_COLOR1)
#define GEOM_BIT_SCOLOR0     (1 << GEOM_ATTRIB_SECONDARY_COLOR0)
#define GEOM_BIT_SCOLOR1     (1 << GEOM_ATTRIB_SECONDARY_COLOR1)
#define GEOM_BIT_TEX_COORD   (1 << GEOM_ATTRIB_TEX_COORD)
#define GEOM_BIT_FOG_COORD   (1 << GEOM_ATTRIB_FOG_FRAG_COORD)
#define GEOM_BIT_POSITION    (1 << GEOM_ATTRIB_POSITION)
#define GEOM_BIT_POINT_SIDE  (1 << GEOM_ATTRIB_POINT_SIZE)
#define GEOM_BIT_CLIP_VERTEX (1 << GEOM_ATTRIB_CLIP_VERTEX)
#define GEOM_BIT_PRIM_ID     (1 << GEOM_ATTRIB_PRIMITIVE_ID)
#define GEOM_BIT_VAR0        (1 << GEOM_ATTRIB_VAR0)

#define GEOM_BIT_VAR(g)  (1 << (GEOM_BIT_VAR0 + (g)))
a248 29
 * Indexes for geometry program result attributes
 */
/*@@{*/
typedef enum {
   GEOM_RESULT_POS  = 0,
   GEOM_RESULT_COL0  = 1,
   GEOM_RESULT_COL1  = 2,
   GEOM_RESULT_SCOL0 = 3,
   GEOM_RESULT_SCOL1 = 4,
   GEOM_RESULT_FOGC = 5,
   GEOM_RESULT_TEX0 = 6,
   GEOM_RESULT_TEX1 = 7,
   GEOM_RESULT_TEX2 = 8,
   GEOM_RESULT_TEX3 = 9,
   GEOM_RESULT_TEX4 = 10,
   GEOM_RESULT_TEX5 = 11,
   GEOM_RESULT_TEX6 = 12,
   GEOM_RESULT_TEX7 = 13,
   GEOM_RESULT_PSIZ = 14,
   GEOM_RESULT_CLPV = 15,
   GEOM_RESULT_PRID = 16,
   GEOM_RESULT_LAYR = 17,
   GEOM_RESULT_VAR0 = 18,  /**< shader varying, should really be 16 */
   /* ### we need to -2 because var0 is 18 instead 16 like in the others */
   GEOM_RESULT_MAX  =  (GEOM_RESULT_VAR0 + MAX_VARYING - 2)
} gl_geom_result;
/*@@}*/

/**
d251 1
a251 1
typedef enum
d265 1
a265 3
   FRAG_ATTRIB_FACE = 12,  /**< front/back face */
   FRAG_ATTRIB_PNTC = 13,  /**< sprite/point coord */
   FRAG_ATTRIB_VAR0 = 14,  /**< shader varying */
d267 1
a267 1
} gl_frag_attrib;
a276 2
#define FRAG_BIT_FACE  (1 << FRAG_ATTRIB_FACE)
#define FRAG_BIT_PNTC  (1 << FRAG_ATTRIB_PNTC)
d304 1
a304 1
typedef enum
d306 3
a308 3
   FRAG_RESULT_DEPTH = 0,
   FRAG_RESULT_STENCIL = 1,
   FRAG_RESULT_COLOR = 2,
d311 1
a311 1
} gl_frag_result;
d317 22
a338 23
typedef enum
{
   /* the four standard color buffers */
   BUFFER_FRONT_LEFT,
   BUFFER_BACK_LEFT,
   BUFFER_FRONT_RIGHT,
   BUFFER_BACK_RIGHT,
   BUFFER_DEPTH,
   BUFFER_STENCIL,
   BUFFER_ACCUM,
   /* optional aux buffer */
   BUFFER_AUX0,
   /* generic renderbuffers */
   BUFFER_COLOR0,
   BUFFER_COLOR1,
   BUFFER_COLOR2,
   BUFFER_COLOR3,
   BUFFER_COLOR4,
   BUFFER_COLOR5,
   BUFFER_COLOR6,
   BUFFER_COLOR7,
   BUFFER_COUNT
} gl_buffer_index;
d371 3
d384 7
a390 60
/**
 * Framebuffer configuration (aka visual / pixelformat)
 * Note: some of these fields should be boolean, but it appears that
 * code in drivers/dri/common/util.c requires int-sized fields.
 */
struct gl_config
{
   GLboolean rgbMode;
   GLboolean floatMode;
   GLboolean colorIndexMode;  /* XXX is this used anywhere? */
   GLuint doubleBufferMode;
   GLuint stereoMode;

   GLboolean haveAccumBuffer;
   GLboolean haveDepthBuffer;
   GLboolean haveStencilBuffer;

   GLint redBits, greenBits, blueBits, alphaBits;	/* bits per comp */
   GLuint redMask, greenMask, blueMask, alphaMask;
   GLint rgbBits;		/* total bits for rgb */
   GLint indexBits;		/* total bits for colorindex */

   GLint accumRedBits, accumGreenBits, accumBlueBits, accumAlphaBits;
   GLint depthBits;
   GLint stencilBits;

   GLint numAuxBuffers;

   GLint level;

   /* EXT_visual_rating / GLX 1.2 */
   GLint visualRating;

   /* EXT_visual_info / GLX 1.2 */
   GLint transparentPixel;
   /*    colors are floats scaled to ints */
   GLint transparentRed, transparentGreen, transparentBlue, transparentAlpha;
   GLint transparentIndex;

   /* ARB_multisample / SGIS_multisample */
   GLint sampleBuffers;
   GLint samples;

   /* SGIX_pbuffer / GLX 1.3 */
   GLint maxPbufferWidth;
   GLint maxPbufferHeight;
   GLint maxPbufferPixels;
   GLint optimalPbufferWidth;   /* Only for SGIX_pbuffer. */
   GLint optimalPbufferHeight;  /* Only for SGIX_pbuffer. */

   /* OML_swap_method */
   GLint swapMethod;

   /* EXT_texture_from_pixmap */
   GLint bindToTextureRgb;
   GLint bindToTextureRgba;
   GLint bindToMipmapTexture;
   GLint bindToTextureTargets;
   GLint yInverted;
};
d500 1
a500 1
   GLfloat SpotDirection[4];	/**< spotlight direction in eye coordinates */
d519 1
a519 1
   GLfloat _NormSpotDirection[4]; /**< normalized spotlight direction */
d572 1
a572 1
   GLubyte ColorMask[MAX_DRAW_BUFFERS][4];/**< Each flag is 0xff or 0x0 */
d589 1
a589 1
   GLbitfield BlendEnabled;		/**< Per-buffer blend enable flags */
d627 1
d629 1
d640 1
d662 78
d820 42
a889 1
   GLenum ProvokingVertex;              /**< GL_EXT_provoking_vertex */
d904 1
a904 1
   GLbitfield _Flags;		        /**< LIGHT_* flags, see above */
d920 1
d934 23
a961 1
   GLboolean _Enabled;   /**< true if Enabled and multisample buffer */
d1009 1
a1009 2
   /** Scale & Bias (index shift, offset) */
   /*@@{*/
a1015 1
   /*@@}*/
d1022 26
d1050 1
a1050 1
   /** glPixelZoom */
d1054 2
a1055 2
   GLfloat TextureColorTableScale[4]; /**< RGBA */
   GLfloat TextureColorTableBias[4];  /**< RGBA */
d1066 1
d1072 1
a1072 1
   GLboolean CoordReplace[MAX_TEXTURE_COORD_UNITS]; /**< GL_ARB_point_sprite*/
a1111 13
 *
 * Three sets of stencil data are tracked so that OpenGL 2.0,
 * GL_EXT_stencil_two_side, and GL_ATI_separate_stencil can all be supported
 * simultaneously.  In each of the stencil state arrays, element 0 corresponds
 * to GL_FRONT.  Element 1 corresponds to the OpenGL 2.0 /
 * GL_ATI_separate_stencil GL_BACK state.  Element 2 corresponds to the
 * GL_EXT_stencil_two_side GL_BACK state.
 *
 * The derived value \c _BackFace is either 1 or 2 depending on whether or
 * not GL_STENCIL_TEST_TWO_SIDE_EXT is enabled.
 *
 * The derived value \c _TestTwoSide is set when the front-face and back-face
 * stencil state are different.
d1117 1
a1117 2
   GLubyte ActiveFace;		/**< GL_EXT_stencil_two_side (0 or 2) */
   GLboolean _Enabled;          /**< Enabled and stencil buffer present */
d1119 7
a1125 8
   GLubyte _BackFace;           /**< Current back stencil state (1 or 2) */
   GLenum Function[3];		/**< Stencil function */
   GLenum FailFunc[3];		/**< Fail function */
   GLenum ZPassFunc[3];		/**< Depth buffer pass function */
   GLenum ZFailFunc[3];		/**< Depth buffer fail function */
   GLint Ref[3];		/**< Reference value */
   GLuint ValueMask[3];		/**< Value mask */
   GLuint WriteMask[3];		/**< Write mask */
d1130 2
d1133 9
a1141 16
 * An index for each type of texture object.  These correspond to the GL
 * texture target enums, such as GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP, etc.
 * Note: the order is from highest priority to lowest priority.
 */
typedef enum
{
   TEXTURE_2D_ARRAY_INDEX,
   TEXTURE_1D_ARRAY_INDEX,
   TEXTURE_CUBE_INDEX,
   TEXTURE_3D_INDEX,
   TEXTURE_RECT_INDEX,
   TEXTURE_2D_INDEX,
   TEXTURE_1D_INDEX,
   NUM_TEXTURE_TARGETS
} gl_texture_index;

d1148 5
a1152 7
#define TEXTURE_2D_ARRAY_BIT (1 << TEXTURE_2D_ARRAY_INDEX)
#define TEXTURE_1D_ARRAY_BIT (1 << TEXTURE_1D_ARRAY_INDEX)
#define TEXTURE_CUBE_BIT     (1 << TEXTURE_CUBE_INDEX)
#define TEXTURE_3D_BIT       (1 << TEXTURE_3D_INDEX)
#define TEXTURE_RECT_BIT     (1 << TEXTURE_RECT_INDEX)
#define TEXTURE_2D_BIT       (1 << TEXTURE_2D_INDEX)
#define TEXTURE_1D_BIT       (1 << TEXTURE_1D_INDEX)
a1163 1
#define STR_BITS (S_BIT | T_BIT | R_BIT)
d1187 18
d1206 2
a1207 5
/** Tex-gen enabled for texture unit? */
#define ENABLE_TEXGEN(unit) (1 << (unit))

/** Non-identity texture matrix for texture unit? */
#define ENABLE_TEXMAT(unit) (1 << (unit))
d1242 80
a1326 1
   GLint InternalFormat;	/**< Internal format as given by the user */
d1333 1
a1333 2
   GLuint TexFormat;            /**< The actual format: MESA_FORMAT_x */

d1351 2
d1358 4
a1361 1
   GLuint RowStride;		/**< Padded width in units of texels */
d1378 9
a1386 10
typedef enum
{
   FACE_POS_X = 0,
   FACE_NEG_X = 1,
   FACE_POS_Y = 2,
   FACE_NEG_Y = 3,
   FACE_POS_Z = 4,
   FACE_NEG_Z = 5,
   MAX_FACES = 6
} gl_face_index;
d1401 2
a1402 5
   union {
      GLfloat f[4];
      GLuint ui[4];
      GLint i[4];
   } BorderColor;               /**< Interpreted according to texture format */
d1414 3
a1418 1
   GLfloat CompareFailValue;    /**< GL_ARB_shadow_ambient */
a1421 3
   GLint CropRect[4];           /**< GL_OES_draw_texture */
   GLenum Swizzle[4];           /**< GL_EXT_texture_swizzle */
   GLuint _Swizzle;             /**< same as Swizzle, but SWIZZLE_* format */
d1423 1
a1423 3
   GLboolean _Complete;		/**< Is texture object complete? */
   GLboolean _RenderToTexture;  /**< Any rendering to this texture? */
   GLboolean Purgeable;         /**< Is the buffer purgeable under memory pressure? */
d1431 1
a1442 4
/** Up to four combiner sources are possible with GL_NV_texture_env_combine4 */
#define MAX_COMBINER_TERMS 4


d1445 4
d1454 4
a1457 6
   /** Source terms: GL_PRIMARY_COLOR, GL_TEXTURE, etc */
   GLenum SourceRGB[MAX_COMBINER_TERMS];
   GLenum SourceA[MAX_COMBINER_TERMS];
   /** Source operands: GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, etc */
   GLenum OperandRGB[MAX_COMBINER_TERMS];
   GLenum OperandA[MAX_COMBINER_TERMS];
d1460 2
a1461 14
   GLuint _NumArgsRGB;   /**< Number of inputs used for the RGB combiner */
   GLuint _NumArgsA;     /**< Number of inputs used for the A combiner */
};


/**
 * Texture coord generation state.
 */
struct gl_texgen
{
   GLenum Mode;         /**< GL_EYE_LINEAR, GL_SPHERE_MAP, etc */
   GLbitfield _ModeBit; /**< TEXGEN_x bit corresponding to Mode */
   GLfloat ObjectPlane[4];
   GLfloat EyePlane[4];
a1476 5

   struct gl_texgen GenS;
   struct gl_texgen GenT;
   struct gl_texgen GenR;
   struct gl_texgen GenQ;
d1478 21
a1498 2
   GLbitfield _GenFlags;	/**< Bitwise-OR of Gen[STRQ]._ModeBit */

a1499 2
   GLenum BumpTarget;
   GLfloat RotMatrix[4]; /* 2x2 matrix */
d1518 13
a1530 5
   /** Current texture object pointers */
   struct gl_texture_object *CurrentTex[NUM_TEXTURE_TARGETS];

   /** Points to highest priority, complete and enabled texture object */
   struct gl_texture_object *_Current;
d1532 1
a1532 2
   /** GL_SGI_texture_color_table */
   /*@@{*/
a1535 1
   /*@@}*/
d1538 12
d1556 11
a1566 2
   GLuint CurrentUnit;   /**< GL_ACTIVE_TEXTURE */
   struct gl_texture_unit Unit[MAX_COMBINED_TEXTURE_IMAGE_UNITS];
d1568 1
a1568 1
   struct gl_texture_object *ProxyTex[NUM_TEXTURE_TARGETS];
d1570 5
a1574 2
   /** GL_ARB_seamless_cubemap */
   GLboolean CubeMapSeamless;
d1579 3
a1581 15

   /** Texture units/samplers used by vertex or fragment texturing */
   GLbitfield _EnabledUnits;

   /** Texture coord units/sets used for fragment texturing */
   GLbitfield _EnabledCoordUnits;

   /** Texture coord units that have texgen enabled */
   GLbitfield _TexGenEnabled;

   /** Texture coord units that have non-identity matrices */
   GLbitfield _TexMatEnabled;

   /** Bitwise-OR of all Texture.Unit[i]._GenFlags */
   GLbitfield _GenFlags;
a1596 1
   GLboolean DepthClamp;			/**< GL_ARB_depth_clamp */
d1598 1
d1617 11
a1631 1
   _glthread_Mutex Mutex;
d1634 6
a1639 12
   GLenum Usage;        /**< GL_STREAM_DRAW_ARB, GL_STREAM_READ_ARB, etc. */
   GLsizeiptrARB Size;  /**< Size of buffer storage in bytes */
   GLubyte *Data;       /**< Location of storage either in RAM or VRAM. */
   /** Fields describing a mapped buffer */
   /*@@{*/
   GLbitfield AccessFlags; /**< Mask of GL_MAP_x_BIT flags */
   GLvoid *Pointer;     /**< User-space address of mapping */
   GLintptr Offset;     /**< Mapped offset */
   GLsizeiptr Length;   /**< Mapped length */
   /*@@}*/
   GLboolean Written;   /**< Ever written to? (for debugging) */
   GLboolean Purgeable; /**< Is the buffer purgeable under memory pressure? */
d1643 1
d1653 2
a1654 2
   GLint ImageHeight;
   GLint SkipImages;
d1663 1
a1670 1
   GLenum Format;               /**< default: GL_RGBA, but may be GL_BGRA */
a1675 2
   GLboolean Integer;           /**< Integer-valued? */
   GLuint _ElementSize;         /**< size of each element in bytes */
d1677 3
a1679 2
   struct gl_buffer_object *BufferObj;/**< GL_ARB_vertex_buffer_object */
   GLuint _MaxElement;          /**< max element index into array buffer + 1 */
a1691 4
   GLint RefCount;
   _glthread_Mutex Mutex;
   GLboolean VBOonly;  /**< require all arrays to live in VBOs? */

a1694 1
   struct gl_client_array Weight;
a1701 1
   struct gl_client_array PointSize;
d1704 2
a1705 7
   /**
    * Generic arrays for vertex programs/shaders.
    * For NV vertex programs, these attributes alias and take priority
    * over the conventional attribs above.  For ARB vertex programs and
    * GLSL vertex shaders, these attributes are separate.
    */
   struct gl_client_array VertexAttrib[MAX_VERTEX_GENERIC_ATTRIBS];
a1708 6

   /**
    * Min of all enabled arrays' _MaxElement.  When arrays reside inside VBOs
    * we can determine the max legal (in bounds) glDrawElements array index.
    */
   GLuint _MaxElement;
a1716 1
   /** Currently bound array object. See _mesa_BindVertexArrayAPPLE() */
a1717 2

   /** The default vertex array object */
a1719 3
   /** Array objects (GL_ARB/APPLE_vertex_array_object) */
   struct _mesa_HashTable *Objects;

a1723 4
   /** GL 3.1 (slightly different from GL_NV_primitive_restart) */
   GLboolean PrimitiveRestart;
   GLuint RestartIndex;

d1726 2
a1727 1
   /* GL_ARB_vertex_buffer_object */
d1730 2
d1741 1
a1741 1
   GLbitfield _Mask;    /**< FB_* bits */
d1839 1
a1839 1
typedef enum
d1841 14
a1854 14
   PROGRAM_TEMPORARY,   /**< machine->Temporary[] */
   PROGRAM_INPUT,       /**< machine->Inputs[] */
   PROGRAM_OUTPUT,      /**< machine->Outputs[] */
   PROGRAM_VARYING,     /**< machine->Inputs[]/Outputs[] */
   PROGRAM_LOCAL_PARAM, /**< gl_program->LocalParams[] */
   PROGRAM_ENV_PARAM,   /**< gl_program->Parameters[] */
   PROGRAM_STATE_VAR,   /**< gl_program->Parameters[] */
   PROGRAM_NAMED_PARAM, /**< gl_program->Parameters[] */
   PROGRAM_CONSTANT,    /**< gl_program->Parameters[] */
   PROGRAM_UNIFORM,     /**< gl_program->Parameters[] */
   PROGRAM_WRITE_ONLY,  /**< A dummy, write-only register */
   PROGRAM_ADDRESS,     /**< machine->AddressReg */
   PROGRAM_SAMPLER,     /**< for shader samplers, compile-time only */
   PROGRAM_UNDEFINED,   /**< Invalid/TBD value */
d1856 1
a1856 1
} gl_register_file;
a1861 1
struct gl_uniform_list;
d1879 2
a1880 7
   GLbitfield64 OutputsWritten; /**< Bitmask of which output regs are written */
   GLbitfield InputFlags[MAX_PROGRAM_INPUTS];   /**< PROG_PARAM_BIT_x flags */
   GLbitfield OutputFlags[MAX_PROGRAM_OUTPUTS]; /**< PROG_PARAM_BIT_x flags */
   GLbitfield TexturesUsed[MAX_TEXTURE_UNITS];  /**< TEXTURE_x_BIT bitmask */
   GLbitfield SamplersUsed;   /**< Bitfield of which samplers are used */
   GLbitfield ShadowSamplers; /**< Texture units used for shadow sampling. */

a1891 10
   /** Map from sampler unit to texture unit (set by glUniform1i()) */
   GLubyte SamplerUnits[MAX_SAMPLERS];
   /** Which texture target is being sampled (TEXTURE_1D/2D/3D/etc_INDEX) */
   gl_texture_index SamplerTargets[MAX_SAMPLERS];

   /** Bitmask of which register files are read/written with indirect
    * addressing.  Mask of (1 << PROGRAM_x) bits.
    */
   GLbitfield IndirectRegisterFiles;

d1923 1
a1923 12
};


/** Geometry program object */
struct gl_geometry_program
{
   struct gl_program Base;   /**< base class */

   GLint VerticesOut;
   GLenum InputType;  /**< GL_POINTS, GL_LINES, GL_LINES_ADJACENCY_ARB,
                           GL_TRIANGLES, or GL_TRIANGLES_ADJACENCY_ARB */
   GLenum OutputType; /**< GL_POINTS, GL_LINE_STRIP or GL_TRIANGLE_STRIP */
d1932 1
a1932 3
   GLboolean UsesKill;          /**< shader uses KIL instruction */
   GLboolean OriginUpperLeft;
   GLboolean PixelCenterInteger;
d1951 8
a1958 9
   GLboolean Enabled;            /**< User-set GL_VERTEX_PROGRAM_ARB/NV flag */
   GLboolean _Enabled;           /**< Enabled and _valid_ user program? */
   GLboolean PointSizeEnabled;   /**< GL_VERTEX_PROGRAM_POINT_SIZE_ARB/NV */
   GLboolean TwoSideEnabled;     /**< GL_VERTEX_PROGRAM_TWO_SIDE_ARB/NV */
   struct gl_vertex_program *Current;  /**< User-bound vertex program */

   /** Currently enabled and valid vertex program (including internal
    * programs, user-defined vertex programs and GLSL vertex shaders).
    * This is the program we must use when rendering.
d1974 6
a1979 4
   /** Cache of fixed-function programs */
   struct gl_program_cache *Cache;

   GLboolean _Overriden;
a1983 20
 * Context state for geometry programs.
 */
struct gl_geometry_program_state
{
   GLboolean Enabled;               /**< GL_ARB_GEOMETRY_SHADER4 */
   GLboolean _Enabled;              /**< Enabled and valid program? */
   struct gl_geometry_program *Current;  /**< user-bound geometry program */

   /** Currently enabled and valid program (including internal programs
    * and compiled shader programs).
    */
   struct gl_geometry_program *_Current;

   GLfloat Parameters[MAX_PROGRAM_ENV_PARAMS][4]; /**< Env params */

   /** Cache of fixed-function programs */
   struct gl_program_cache *Cache;
};

/**
d1989 2
a1990 1
   GLboolean _Enabled;    /**< Enabled and _valid_ user program? */
d1993 2
a1994 3
   /** Currently enabled and valid fragment program (including internal
    * programs, user-defined fragment programs and GLSL fragment shaders).
    * This is the program we must use when rendering.
d2002 1
d2007 6
a2012 2
   /** Cache of fixed-function programs */
   struct gl_program_cache *Cache;
d2035 1
a2035 1
   GLbitfield LocalConstDef;  /**< Indicates which constants have been set */
d2038 1
a2038 1
   GLubyte NumPasses;         /**< 1 or 2 */
d2052 1
a2052 1
   GLboolean _Enabled;                  /**< enabled and valid shader? */
d2064 4
a2067 5
   GLenum Target;      /**< The query target, when active */
   GLuint Id;          /**< hash table ID/name */
   GLuint64EXT Result; /**< the counter */
   GLboolean Active;   /**< inside Begin/EndQuery */
   GLboolean Ready;    /**< result is ready? */
a2078 27

   /** GL_NV_conditional_render */
   struct gl_query_object *CondRenderQuery;

   /** GL_EXT_transform_feedback */
   struct gl_query_object *PrimitivesGenerated;
   struct gl_query_object *PrimitivesWritten;

   /** GL_ARB_timer_query */
   struct gl_query_object *TimeElapsed;

   GLenum CondRenderMode;
};


/** Sync object state */
struct gl_sync_object {
   struct simple_node link;
   GLenum Type;               /**< GL_SYNC_FENCE */
   GLuint Name;               /**< Fence name */
   GLint RefCount;            /**< Reference count */
   GLboolean DeletePending;   /**< Object was deleted while there were still
			       * live references (e.g., sync not yet finished)
			       */
   GLenum SyncCondition;
   GLbitfield Flags;          /**< Flags passed to glFenceSync */
   GLuint StatusFlag:1;       /**< Has the sync object been signaled? */
a2081 9
/** Set by #pragma directives */
struct gl_sl_pragmas
{
   GLboolean IgnoreOptimize;  /**< ignore #pragma optimize(on/off) ? */
   GLboolean IgnoreDebug;     /**< ignore #pragma debug(on/off) ? */
   GLboolean Optimize;  /**< defaults on */
   GLboolean Debug;     /**< defaults off */
};

d2084 1
a2084 1
 * A GLSL vertex or fragment shader object.
d2088 1
a2088 1
   GLenum Type;  /**< GL_FRAGMENT_SHADER || GL_VERTEX_SHADER || GL_GEOMETRY_SHADER_ARB (first field!) */
d2092 2
d2095 2
a2096 5
   GLboolean Main;  /**< shader defines main() */
   GLboolean UnresolvedRefs;
   const GLchar *Source;  /**< Source code string */
   GLuint SourceChecksum;       /**< for debug/logging purposes */
   struct gl_program *Program;  /**< Post-compile assembly code */
a2097 10
   struct gl_sl_pragmas Pragmas;

   unsigned Version;       /**< GLSL version used for linking */

   struct exec_list *ir;
   struct glsl_symbol_table *symbols;

   /** Shaders containing built-in functions that are used for linking. */
   struct gl_shader *builtins_to_link[16];
   unsigned num_builtins_to_link;
d2102 1
a2102 2
 * A GLSL program object.
 * Basically a linked collection of vertex and fragment shaders.
a2113 18
   /** User-defined attribute bindings (glBindAttribLocation) */
   struct gl_program_parameter_list *Attributes;

   /** Transform feedback varyings */
   struct {
      GLenum BufferMode;
      GLuint NumVarying;
      GLchar **VaryingNames;  /**< Array [NumVarying] of char * */
   } TransformFeedback;

   /** Geometry shader state - copied into gl_geometry_program at link time */
   struct {
      GLint VerticesOut;
      GLenum InputType;  /**< GL_POINTS, GL_LINES, GL_LINES_ADJACENCY_ARB,
                              GL_TRIANGLES, or GL_TRIANGLES_ADJACENCY_ARB */
      GLenum OutputType; /**< GL_POINTS, GL_LINE_STRIP or GL_TRIANGLE_STRIP */
   } Geom;

d2117 1
a2117 2
   struct gl_geometry_program *GeometryProgram; /**< Linked geometry prog */
   struct gl_uniform_list *Uniforms;
d2119 1
a2121 1
   GLboolean _Used;        /**< Ever used for drawing? */
a2122 11

   unsigned Version;       /**< GLSL version used for linking */

   /**
    * Per-stage shaders resulting from the first stage of linking.
    *
    * Set of linked shaders for this program.  The array is accessed using the
    * \c MESA_SHADER_* defines.  Entries for non-existent stages will be
    * \c NULL.
    */
   struct gl_shader *_LinkedShaders[MESA_SHADER_TYPES];
a2125 10
#define GLSL_DUMP      0x1  /**< Dump shaders to stdout */
#define GLSL_LOG       0x2  /**< Write shaders to files */
#define GLSL_OPT       0x4  /**< Force optimizations (override pragmas) */
#define GLSL_NO_OPT    0x8  /**< Force no optimizations (override pragmas) */
#define GLSL_UNIFORMS 0x10  /**< Print glUniform calls */
#define GLSL_NOP_VERT 0x20  /**< Force no-op vertex shaders */
#define GLSL_NOP_FRAG 0x40  /**< Force no-op fragment shaders */
#define GLSL_USE_PROG 0x80  /**< Log glUseProgram calls */


d2131 1
a2131 28
   /**
    * Programs used for rendering
    *
    * There is a separate program set for each shader stage.  If
    * GL_EXT_separate_shader_objects is not supported, each of these must point
    * to \c NULL or to the same program.
    */
   struct gl_shader_program *CurrentVertexProgram;
   struct gl_shader_program *CurrentGeometryProgram;
   struct gl_shader_program *CurrentFragmentProgram;

   /**
    * Program used by glUniform calls.
    *
    * Explicitly set by \c glUseProgram and \c glActiveProgramEXT.
    */
   struct gl_shader_program *ActiveProgram;

   void *MemPool;

   GLbitfield Flags;                    /**< Mask of GLSL_x flags */
};

/**
 * Compiler options for a single GLSL shaders type
 */
struct gl_shader_compiler_options
{
d2133 1
d2135 2
a2136 69
   GLboolean EmitNVTempInitialization;  /**< 0-fill NV temp registers */
   /**
    * Attempts to flatten all ir_if (OPCODE_IF) for GPUs that can't
    * support control flow.
    */
   GLboolean EmitNoIfs;
   GLboolean EmitNoLoops;
   GLboolean EmitNoFunctions;
   GLboolean EmitNoCont;                  /**< Emit CONT opcode? */
   GLboolean EmitNoMainReturn;            /**< Emit CONT/RET opcodes? */
   GLboolean EmitNoNoise;                 /**< Emit NOISE opcodes? */
   GLboolean EmitNoPow;                   /**< Emit POW opcodes? */

   /**
    * \name Forms of indirect addressing the driver cannot do.
    */
   /*@@{*/
   GLboolean EmitNoIndirectInput;   /**< No indirect addressing of inputs */
   GLboolean EmitNoIndirectOutput;  /**< No indirect addressing of outputs */
   GLboolean EmitNoIndirectTemp;    /**< No indirect addressing of temps */
   GLboolean EmitNoIndirectUniform; /**< No indirect addressing of constants */
   /*@@}*/

   GLuint MaxUnrollIterations;

   struct gl_sl_pragmas DefaultPragmas; /**< Default #pragma settings */
};

/**
 * Transform feedback object state
 */
struct gl_transform_feedback_object
{
   GLuint Name;  /**< AKA the object ID */
   GLint RefCount;
   GLboolean Active;  /**< Is transform feedback enabled? */
   GLboolean Paused;  /**< Is transform feedback paused? */

   /** The feedback buffers */
   GLuint BufferNames[MAX_FEEDBACK_ATTRIBS];
   struct gl_buffer_object *Buffers[MAX_FEEDBACK_ATTRIBS];

   /** Start of feedback data in dest buffer */
   GLintptr Offset[MAX_FEEDBACK_ATTRIBS];
   /** Max data to put into dest buffer (in bytes) */
   GLsizeiptr Size[MAX_FEEDBACK_ATTRIBS];
};


/**
 * Context state for transform feedback.
 */
struct gl_transform_feedback
{
   GLenum Mode;       /**< GL_POINTS, GL_LINES or GL_TRIANGLES */

   GLboolean RasterDiscard;  /**< GL_RASTERIZER_DISCARD */

   /** The general binding point (GL_TRANSFORM_FEEDBACK_BUFFER) */
   struct gl_buffer_object *CurrentBuffer;

   /** The table of all transform feedback objects */
   struct _mesa_HashTable *Objects;

   /** The current xform-fb object (GL_TRANSFORM_FEEDBACK_BINDING) */
   struct gl_transform_feedback_object *CurrentObject;

   /** The default xform-fb object (Name==0) */
   struct gl_transform_feedback_object *DefaultObject;
a2139 1

d2150 10
a2159 5
   /** Default texture objects (shared by all texture units) */
   struct gl_texture_object *DefaultTex[NUM_TEXTURE_TARGETS];

   /** Fallback texture used when a bound texture is incomplete */
   struct gl_texture_object *FallbackTex;
d2168 2
a2169 2
   _glthread_Mutex TexMutex;		/**< texobj thread safety */
   GLuint TextureStateStamp;	        /**< state notification for shared tex */
d2172 1
a2172 2
   /** Default buffer object for vertex arrays that aren't in VBOs */
   struct gl_buffer_object *NullBufferObj;
d2175 1
a2175 1
    * \name Vertex/geometry/fragment programs
d2179 6
a2184 3
   struct gl_vertex_program *DefaultVertexProgram;
   struct gl_fragment_program *DefaultFragmentProgram;
   struct gl_geometry_program *DefaultGeometryProgram;
d2187 1
a2187 1
   /* GL_ATI_fragment_shader */
d2190 1
d2192 1
d2194 1
d2196 1
d2199 1
d2201 1
a2201 1
   /* GL_EXT_framebuffer_object */
d2204 1
d2206 2
a2207 2
   /* GL_ARB_sync */
   struct simple_node SyncObjects;
a2232 3
   GLint RowStride;       /**< Padded width in units of pixels */
   GLboolean Purgeable;   /**< Is the buffer purgeable under memory pressure? */

d2234 1
a2236 4
   GLuint Format;         /**< The actual format: MESA_FORMAT_x */

   GLubyte NumSamples;

d2238 7
a2246 2
   GLboolean AttachedAnytime; /**< TRUE if it was attached to a framebuffer */

d2254 1
a2254 1
   GLboolean (*AllocStorage)(struct gl_context *ctx, struct gl_renderbuffer *rb,
d2260 2
a2261 2
   void (*Lock)(struct gl_context *ctx, struct gl_renderbuffer *rb);
   void (*Unlock)(struct gl_context *ctx, struct gl_renderbuffer *rb);
d2267 1
a2267 1
   void *(*GetPointer)(struct gl_context *ctx, struct gl_renderbuffer *rb,
d2273 1
a2273 1
   void (*GetRow)(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
d2279 1
a2279 1
   void (*GetValues)(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
d2285 1
a2285 1
   void (*PutRow)(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
d2293 1
a2293 1
   void (*PutRowRGB)(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
d2300 1
a2300 1
   void (*PutMonoRow)(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
d2306 1
a2306 1
   void (*PutValues)(struct gl_context *ctx, struct gl_renderbuffer *rb, GLuint count,
d2312 1
a2312 1
   void (*PutMonoValues)(struct gl_context *ctx, struct gl_renderbuffer *rb,
d2319 3
a2321 2
 * A renderbuffer attachment points to either a texture object (and specifies
 * a mipmap level, cube face or 3D texture slice) or points to a renderbuffer.
d2325 1
a2325 1
   GLenum Type;  /**< \c GL_NONE or \c GL_TEXTURE or \c GL_RENDERBUFFER_EXT */
d2328 1
a2328 4
   /**
    * If \c Type is \c GL_RENDERBUFFER_EXT, this stores a pointer to the
    * application supplied renderbuffer object.
    */
d2331 1
a2331 4
   /**
    * If \c Type is \c GL_TEXTURE, this stores a pointer to the application
    * supplied texture object.
    */
d2333 3
a2335 4
   GLuint TextureLevel; /**< Attached mipmap level. */
   GLuint CubeMapFace;  /**< 0 .. 5, for cube map textures. */
   GLuint Zoffset;      /**< Slice for 3D textures,  or layer for both 1D
                         * and 2D array textures */
d2346 2
a2347 10
   _glthread_Mutex Mutex;  /**< for thread safety */
   /**
    * If zero, this is a window system framebuffer.  If non-zero, this
    * is a FBO framebuffer; note that for some devices (i.e. those with
    * a natural pixel coordinate system for FBOs that differs from the
    * OpenGL/Mesa coordinate system), this means that the viewport,
    * polygon face orientation, and polygon stipple will have to be inverted.
    */
   GLuint Name;

d2351 3
a2353 5
   /**
    * The framebuffer's visual. Immutable if this is a window system buffer.
    * Computed from attachments if user-made FBO.
    */
   struct gl_config Visual;
d2372 1
a2372 5
   /** One of the GL_FRAMEBUFFER_(IN)COMPLETE_* tokens */
   GLenum _Status;

   /** Integer color values */
   GLboolean _IntegerColor;
d2374 1
a2374 1
   /** Array of all renderbuffer attachments, indexed by BUFFER_* tokens. */
d2383 2
a2384 3
   /** Computed from ColorDraw/ReadBuffer above */
   GLuint _NumColorDrawBuffers;
   GLint _ColorDrawBufferIndexes[MAX_DRAW_BUFFERS]; /**< BUFFER_x or -1 */
d2386 4
a2389 1
   struct gl_renderbuffer *_ColorDrawBuffers[MAX_DRAW_BUFFERS];
d2403 1
a2403 12
 * Precision info for shader datatypes.  See glGetShaderPrecisionFormat().
 */
struct gl_precision
{
   GLushort RangeMin;   /**< min value exponent */
   GLushort RangeMax;   /**< max value exponent */
   GLushort Precision;  /**< number of mantissa bits */
};


/**
 * Limits for vertex and fragment programs/shaders.
d2409 3
a2411 3
   GLuint MaxAluInstructions;
   GLuint MaxTexInstructions;
   GLuint MaxTexIndirections;
d2414 1
a2414 1
   GLuint MaxAddressRegs;
d2420 3
a2422 3
   GLuint MaxNativeAluInstructions;
   GLuint MaxNativeTexInstructions;
   GLuint MaxNativeTexIndirections;
d2425 1
a2425 1
   GLuint MaxNativeAddressRegs;
a2428 10
   /* GL_ARB_geometry_shader4 */
   GLuint MaxGeometryTextureImageUnits;
   GLuint MaxGeometryVaryingComponents;
   GLuint MaxVertexVaryingComponents;
   GLuint MaxGeometryUniformComponents;
   GLuint MaxGeometryOutputVertices;
   GLuint MaxGeometryTotalOutputComponents;
   /* ES 2.0 and GL_ARB_ES2_compatibility */
   struct gl_precision LowFloat, MediumFloat, HighFloat;
   struct gl_precision LowInt, MediumInt, HighInt;
d2438 4
a2441 6
   GLint MaxTextureMbytes;      /**< Max memory per image, in MB */
   GLint MaxTextureLevels;      /**< Max mipmap levels. */ 
   GLint Max3DTextureLevels;    /**< Max mipmap levels for 3D textures */
   GLint MaxCubeTextureLevels;  /**< Max mipmap levels for cube textures */
   GLint MaxArrayTextureLayers; /**< Max layers in array textures */
   GLint MaxTextureRectSize;    /**< Max rectangle texture size, in pixes */
d2444 3
a2446 6
   GLuint MaxVertexTextureImageUnits;
   GLuint MaxCombinedTextureImageUnits;
   GLuint MaxTextureUnits;           /**< = MIN(CoordUnits, ImageUnits) */
   GLfloat MaxTextureMaxAnisotropy;  /**< GL_EXT_texture_filter_anisotropic */
   GLfloat MaxTextureLodBias;        /**< GL_EXT_texture_lod_bias */

a2447 1

d2449 2
a2450 3

   GLfloat MinPointSize, MaxPointSize;	     /**< aliased */
   GLfloat MinPointSizeAA, MaxPointSizeAA;   /**< antialiased */
d2452 2
a2453 2
   GLfloat MinLineWidth, MaxLineWidth;       /**< aliased */
   GLfloat MinLineWidthAA, MaxLineWidthAA;   /**< antialiased */
a2454 1

d2456 2
a2457 1

d2460 2
a2461 3
   GLfloat MaxShininess;                     /**< GL_NV_light_max_exponent */
   GLfloat MaxSpotExponent;                  /**< GL_NV_light_max_exponent */

d2463 3
a2465 4

   struct gl_program_constants VertexProgram;   /**< GL_ARB_vertex_program */
   struct gl_program_constants FragmentProgram; /**< GL_ARB_fragment_program */
   struct gl_program_constants GeometryProgram;  /**< GL_ARB_geometry_shader4 */
d2468 1
a2468 2

   /** vertex array / buffer object bounds checking */
d2470 11
a2480 35

   GLuint MaxDrawBuffers;    /**< GL_ARB_draw_buffers */

   GLuint MaxColorAttachments;   /**< GL_EXT_framebuffer_object */
   GLuint MaxRenderbufferSize;   /**< GL_EXT_framebuffer_object */
   GLuint MaxSamples;            /**< GL_ARB_framebuffer_object */

   GLuint MaxVarying;  /**< Number of float[4] varying parameters */

   GLuint GLSLVersion;  /**< GLSL version supported (ex: 120 = 1.20) */

   /** Which texture units support GL_ATI_envmap_bumpmap as targets */
   GLbitfield SupportedBumpUnits;

   /**
    * Maximum amount of time, measured in nanseconds, that the server can wait.
    */
   GLuint64 MaxServerWaitTimeout;

   /** GL_EXT_provoking_vertex */
   GLboolean QuadsFollowProvokingVertexConvention;

   /** OpenGL version 3.0 */
   GLbitfield ContextFlags;  /**< Ex: GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT */

   /** OpenGL version 3.2 */
   GLbitfield ProfileMask;   /**< Mask of CONTEXT_x_PROFILE_BIT */

   /** GL_EXT_transform_feedback */
   GLuint MaxTransformFeedbackSeparateAttribs;
   GLuint MaxTransformFeedbackSeparateComponents;
   GLuint MaxTransformFeedbackInterleavedComponents;

   /** GL_EXT_gpu_shader4 */
   GLint MinProgramTexelOffset, MaxProgramTexelOffset;
d2490 6
a2496 7
   GLboolean dummy_true;  /* Set true by _mesa_init_extensions(). */
   GLboolean dummy_false; /* Set false by _mesa_init_extensions(). */
   GLboolean ARB_ES2_compatibility;
   GLboolean ARB_blend_func_extended;
   GLboolean ARB_copy_buffer;
   GLboolean ARB_depth_buffer_float;
   GLboolean ARB_depth_clamp;
a2498 3
   GLboolean ARB_draw_elements_base_vertex;
   GLboolean ARB_draw_instanced;
   GLboolean ARB_fragment_coord_conventions;
a2499 1
   GLboolean ARB_fragment_program_shadow;
a2500 3
   GLboolean ARB_framebuffer_object;
   GLboolean ARB_explicit_attrib_location;
   GLboolean ARB_geometry_shader4;
d2502 1
a2502 3
   GLboolean ARB_half_float_vertex;
   GLboolean ARB_instanced_arrays;
   GLboolean ARB_map_buffer_range;
a2505 1
   GLboolean ARB_occlusion_query2;
a2506 2
   GLboolean ARB_sampler_objects;
   GLboolean ARB_seamless_cube_map;
a2507 1
   GLboolean ARB_shader_stencil_export;
d2509 1
a2510 2
   GLboolean ARB_shadow_ambient;
   GLboolean ARB_sync;
a2511 1
   GLboolean ARB_texture_buffer_object;
a2512 1
   GLboolean ARB_texture_compression_rgtc;
a2518 1
   GLboolean ARB_texture_multisample;
a2519 4
   GLboolean ARB_texture_rg;
   GLboolean ARB_texture_rgb10_a2ui;
   GLboolean ARB_timer_query;
   GLboolean ARB_transform_feedback2;
a2520 2
   GLboolean ARB_uniform_buffer_object;
   GLboolean ARB_vertex_array_object;
a2523 1
   GLboolean ARB_vertex_type_2_10_10_10_rev;
d2534 2
a2538 1
   GLboolean EXT_draw_buffers2;
d2540 1
a2542 3
   GLboolean EXT_framebuffer_multisample;
   GLboolean EXT_framebuffer_object;
   GLboolean EXT_framebuffer_sRGB;
d2544 1
a2544 1
   GLboolean EXT_gpu_shader4;
a2547 1
   GLboolean EXT_packed_float;
a2551 1
   GLboolean EXT_provoking_vertex;
a2554 1
   GLboolean EXT_separate_shader_objects;
a2562 1
   GLboolean EXT_texture_array;
a2567 1
   GLboolean EXT_texture_integer;
a2569 1
   GLboolean EXT_texture_shared_exponent;
a2570 2
   GLboolean EXT_texture_swizzle;
   GLboolean EXT_transform_feedback;
a2572 1
   GLboolean EXT_vertex_array_bgra;
a2573 1
   GLboolean OES_standard_derivatives;
a2577 2
   GLboolean APPLE_object_purgeable;
   GLboolean ATI_envmap_bumpmap;
d2585 2
a2588 2
   GLboolean MESA_texture_array;
   GLboolean MESA_texture_signed_rgba;
a2589 1
   GLboolean NV_conditional_render;
a2590 1
   GLboolean NV_fragment_program_option;
a2592 1
   GLboolean NV_primitive_restart;
a2593 1
   GLboolean NV_texture_env_combine4;
d2598 2
d2604 3
d2609 2
a2610 5
   GLboolean OES_EGL_image;
   GLboolean OES_draw_texture;
   GLboolean EXT_texture_format_BGRA8888;
   GLboolean extension_sentinel;
   /** The extension string */
a2611 2
   /** Number of supported extensions */
   GLuint Count;
d2630 2
a2631 1
 * \sa __struct gl_contextRec::ImageTransferState.
d2637 25
a2661 2
#define IMAGE_CLAMP_BIT                           0x800

a2662 4
/** Pixel Transfer ops */
#define IMAGE_BITS (IMAGE_SCALE_BIAS_BIT |			\
		    IMAGE_SHIFT_OFFSET_BIT |			\
		    IMAGE_MAP_COLOR_BIT)
d2670 28
a2697 30
#define _NEW_MODELVIEW		0x1        /**< __struct gl_contextRec::ModelView */
#define _NEW_PROJECTION		0x2        /**< __struct gl_contextRec::Projection */
#define _NEW_TEXTURE_MATRIX	0x4        /**< __struct gl_contextRec::TextureMatrix */
#define _NEW_ACCUM		0x10       /**< __struct gl_contextRec::Accum */
#define _NEW_COLOR		0x20       /**< __struct gl_contextRec::Color */
#define _NEW_DEPTH		0x40       /**< __struct gl_contextRec::Depth */
#define _NEW_EVAL		0x80       /**< __struct gl_contextRec::Eval, __struct gl_contextRec::EvalMap */
#define _NEW_FOG		0x100      /**< __struct gl_contextRec::Fog */
#define _NEW_HINT		0x200      /**< __struct gl_contextRec::Hint */
#define _NEW_LIGHT		0x400      /**< __struct gl_contextRec::Light */
#define _NEW_LINE		0x800      /**< __struct gl_contextRec::Line */
#define _NEW_PIXEL		0x1000     /**< __struct gl_contextRec::Pixel */
#define _NEW_POINT		0x2000     /**< __struct gl_contextRec::Point */
#define _NEW_POLYGON		0x4000     /**< __struct gl_contextRec::Polygon */
#define _NEW_POLYGONSTIPPLE	0x8000     /**< __struct gl_contextRec::PolygonStipple */
#define _NEW_SCISSOR		0x10000    /**< __struct gl_contextRec::Scissor */
#define _NEW_STENCIL		0x20000    /**< __struct gl_contextRec::Stencil */
#define _NEW_TEXTURE		0x40000    /**< __struct gl_contextRec::Texture */
#define _NEW_TRANSFORM		0x80000    /**< __struct gl_contextRec::Transform */
#define _NEW_VIEWPORT		0x100000   /**< __struct gl_contextRec::Viewport */
#define _NEW_PACKUNPACK		0x200000   /**< __struct gl_contextRec::Pack, __struct gl_contextRec::Unpack */
#define _NEW_ARRAY	        0x400000   /**< __struct gl_contextRec::Array */
#define _NEW_RENDERMODE		0x800000   /**< __struct gl_contextRec::RenderMode, __struct gl_contextRec::Feedback, __struct gl_contextRec::Select */
#define _NEW_BUFFERS            0x1000000  /**< __struct gl_contextRec::Visual, __struct gl_contextRec::DrawBuffer, */
#define _NEW_MULTISAMPLE        0x2000000  /**< __struct gl_contextRec::Multisample */
#define _NEW_TRACK_MATRIX       0x4000000  /**< __struct gl_contextRec::VertexProgram */
#define _NEW_PROGRAM            0x8000000  /**< __struct gl_contextRec::VertexProgram */
#define _NEW_CURRENT_ATTRIB     0x10000000  /**< __struct gl_contextRec::Current */
#define _NEW_PROGRAM_CONSTANTS  0x20000000
#define _NEW_BUFFER_OBJECT      0x40000000
a2715 1
#define _NEW_ARRAY_POINT_SIZE       VERT_BIT_COLOR_INDEX  /* aliased */
a2732 1

d2736 1
a2736 1
 * Set in the __struct gl_contextRec::_TriangleCaps bitfield.
d2749 5
a2753 3
#define DD_POINT_SMOOTH             0x400
#define DD_POINT_ATTEN              0x800
#define DD_TRI_TWOSTENCIL           0x1000
a2777 4
/**
 * Composite state flags
 */
/*@@{*/
d2787 1
a2787 2
#define _MESA_NEW_TRANSFER_STATE          (_NEW_PIXEL)
/*@@}*/
d2792 7
d2803 2
d2806 23
a2828 2
 * Display list flags.
 * Strictly this is a tnl-private concept, but it doesn't seem
d2832 1
a2832 5
#define DLIST_DANGLING_REFS     0x1 


/** Opaque declaration of display list payload data type */
union gl_dlist_node;
d2834 1
a2834 3

/**
 * Provide a location where information about a display list can be
d2838 1
a2838 1
struct gl_display_list
d2840 3
a2842 4
   GLuint Name;
   GLbitfield Flags;  /**< DLIST_x flags */
   /** The dlist commands are in a linked list of nodes */
   union gl_dlist_node *Head;
d2851 1
d2854 4
a2857 2
   struct gl_display_list *CurrentList; /**< List currently being compiled */
   union gl_dlist_node *CurrentBlock; /**< Pointer to current block of nodes */
a2872 7

   struct {
      /* State known to have been set by the currently-compiling display
       * list.  Used to eliminate some redundant state changes.
       */
      GLenum ShadeModel;
   } Current;
a2874 8
/**
 * Enum for the OpenGL APIs we know about and may support.
 */
typedef enum {
   API_OPENGL,
   API_OPENGLES,
   API_OPENGLES2
} gl_api;
d2884 1
a2884 1
 * The struct gl_context typedef names this structure.
d2886 1
a2886 1
struct gl_context
a2892 1
   gl_api API;
d2898 5
a2902 5
   struct gl_config Visual;
   struct gl_framebuffer *DrawBuffer;	/**< buffer for writing */
   struct gl_framebuffer *ReadBuffer;	/**< buffer for reading */
   struct gl_framebuffer *WinSysDrawBuffer;  /**< set with MakeCurrent */
   struct gl_framebuffer *WinSysReadBuffer;  /**< set with MakeCurrent */
d2918 2
a2919 1
   struct gl_matrix_stack TextureMatrixStack[MAX_TEXTURE_UNITS];
a2935 4
   /** Version info */
   GLuint VersionMajor, VersionMinor;
   char *VersionString;

d2987 5
d2997 8
a3004 5
   struct gl_program_state Program;  /**< general program state */
   struct gl_vertex_program_state VertexProgram;
   struct gl_fragment_program_state FragmentProgram;
   struct gl_geometry_program_state GeometryProgram;
   struct gl_ati_fragment_shader_state ATIFragmentShader;
d3006 4
a3009 2
   struct gl_shader_state Shader; /**< GLSL shader object state */
   struct gl_shader_compiler_options ShaderCompilerOptions[MESA_SHADER_TYPES];
d3011 1
a3011 1
   struct gl_query_state Query;  /**< occlusion, timer queries */
d3013 1
a3013 4
   struct gl_transform_feedback TransformFeedback;

   struct gl_buffer_object *CopyReadBuffer; /**< GL_ARB_copy_buffer */
   struct gl_buffer_object *CopyWriteBuffer; /**< GL_ARB_copy_buffer */
d3016 1
a3016 3
   struct gl_meta_state *Meta;  /**< for "meta" operations */

   /* GL_EXT_framebuffer_object */
d3018 1
a3020 7

   /**
    * Recognize and silence repeated error debug messages in buggy apps.
    */
   const char *ErrorDebugFmtString;
   GLuint ErrorDebugCount;

a3023 4
   GLboolean ViewportInitialized;  /**< has viewport size been initialized? */

   GLbitfield varying_vp_inputs;  /**< mask of VERT_BIT_* flags */

d3026 1
a3026 4
   /** Bitwise-or of DD_* flags.  Note that this bitfield may be used before
    * state validation so they need to always be current.
    */
   GLbitfield _TriangleCaps;
d3032 1
d3034 1
a3034 1
   GLuint TextureStateTimestamp; /**< detect changes to shared state */
d3040 7
a3046 1
   struct gl_list_extensions *ListExt; /**< driver dlist extensions */
d3059 2
a3060 5
   /** 
    * Use dp4 (rather than mul/mad) instructions for position
    * transformation?
    */
   GLboolean mvp_with_dp4;
d3072 1
a3072 1
   struct st_context *st;
a3095 1
/** The MESA_VERBOSE var is a bitmask of these flags */
d3100 1
a3100 1
   VERBOSE_MATERIAL		= 0x0004,
d3109 1
a3109 3
   VERBOSE_DISASSEM		= 0x1000,
   VERBOSE_DRAW                 = 0x2000,
   VERBOSE_SWAPBUFFERS          = 0x4000
a3112 1
/** The MESA_DEBUG_FLAGS var is a bitmask of these flags */
d3120 4
a3123 1
#endif /* MTYPES_H */
@


1.1.1.5
log
@Import Mesa 9.2.0
@
text
@d3 1
d21 3
a23 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
d39 1
a42 1
#include "main/formats.h"       /* MESA_FORMAT_COUNT */
d45 32
a76 2
#ifdef __cplusplus
extern "C" {
d86 3
d90 13
a102 7
#define BITFIELD64_BIT(b)      ((GLbitfield64)1 << (b))
/** Set all bits up to excluding bit b */
#define BITFIELD64_MASK(b)      \
   ((b) == 64 ? (~(GLbitfield64)0) : BITFIELD64_BIT(b) - 1)
/** Set count bits starting from bit b  */
#define BITFIELD64_RANGE(b, count) \
   (BITFIELD64_MASK((b) + (count)) & ~BITFIELD64_MASK(b))
d113 1
d115 2
a119 5
struct gl_uniform_storage;
struct prog_instruction;
struct gl_program_parameter_list;
struct set;
struct set_entry;
d123 12
a134 4
/** Extra draw modes beyond GL_POINTS, GL_TRIANGLE_FAN, etc */
#define PRIM_MAX                 GL_TRIANGLE_STRIP_ADJACENCY
#define PRIM_OUTSIDE_BEGIN_END   (PRIM_MAX + 1)
#define PRIM_UNKNOWN             (PRIM_MAX + 2)
d154 1
d164 17
a180 18
   VERT_ATTRIB_POINT_SIZE = 16,
   VERT_ATTRIB_GENERIC0 = 17,
   VERT_ATTRIB_GENERIC1 = 18,
   VERT_ATTRIB_GENERIC2 = 19,
   VERT_ATTRIB_GENERIC3 = 20,
   VERT_ATTRIB_GENERIC4 = 21,
   VERT_ATTRIB_GENERIC5 = 22,
   VERT_ATTRIB_GENERIC6 = 23,
   VERT_ATTRIB_GENERIC7 = 24,
   VERT_ATTRIB_GENERIC8 = 25,
   VERT_ATTRIB_GENERIC9 = 26,
   VERT_ATTRIB_GENERIC10 = 27,
   VERT_ATTRIB_GENERIC11 = 28,
   VERT_ATTRIB_GENERIC12 = 29,
   VERT_ATTRIB_GENERIC13 = 30,
   VERT_ATTRIB_GENERIC14 = 31,
   VERT_ATTRIB_GENERIC15 = 32,
   VERT_ATTRIB_MAX = 33
d184 2
a185 12
 * Symbolic constats to help iterating over
 * specific blocks of vertex attributes.
 *
 * VERT_ATTRIB_FF
 *   includes all fixed function attributes as well as
 *   the aliased GL_NV_vertex_program shader attributes.
 * VERT_ATTRIB_TEX
 *   include the classic texture coordinate attributes.
 *   Is a subset of VERT_ATTRIB_FF.
 * VERT_ATTRIB_GENERIC
 *   include the OpenGL 2.0+ GLSL generic shader attributes.
 *   These alias the generic GL_ARB_vertex_shader attributes.
d187 33
a219 2
#define VERT_ATTRIB_FF(i)           (VERT_ATTRIB_POS + (i))
#define VERT_ATTRIB_FF_MAX          VERT_ATTRIB_GENERIC0
d221 3
a223 2
#define VERT_ATTRIB_TEX(i)          (VERT_ATTRIB_TEX0 + (i))
#define VERT_ATTRIB_TEX_MAX         MAX_TEXTURE_COORD_UNITS
a224 2
#define VERT_ATTRIB_GENERIC(i)      (VERT_ATTRIB_GENERIC0 + (i))
#define VERT_ATTRIB_GENERIC_MAX     MAX_VERTEX_GENERIC_ATTRIBS
d227 1
a227 2
 * Bitflags for vertex attributes.
 * These are used in bitfields in many places.
d229 22
a250 33
/*@@{*/
#define VERT_BIT_POS             BITFIELD64_BIT(VERT_ATTRIB_POS)
#define VERT_BIT_WEIGHT          BITFIELD64_BIT(VERT_ATTRIB_WEIGHT)
#define VERT_BIT_NORMAL          BITFIELD64_BIT(VERT_ATTRIB_NORMAL)
#define VERT_BIT_COLOR0          BITFIELD64_BIT(VERT_ATTRIB_COLOR0)
#define VERT_BIT_COLOR1          BITFIELD64_BIT(VERT_ATTRIB_COLOR1)
#define VERT_BIT_FOG             BITFIELD64_BIT(VERT_ATTRIB_FOG)
#define VERT_BIT_COLOR_INDEX     BITFIELD64_BIT(VERT_ATTRIB_COLOR_INDEX)
#define VERT_BIT_EDGEFLAG        BITFIELD64_BIT(VERT_ATTRIB_EDGEFLAG)
#define VERT_BIT_TEX0            BITFIELD64_BIT(VERT_ATTRIB_TEX0)
#define VERT_BIT_TEX1            BITFIELD64_BIT(VERT_ATTRIB_TEX1)
#define VERT_BIT_TEX2            BITFIELD64_BIT(VERT_ATTRIB_TEX2)
#define VERT_BIT_TEX3            BITFIELD64_BIT(VERT_ATTRIB_TEX3)
#define VERT_BIT_TEX4            BITFIELD64_BIT(VERT_ATTRIB_TEX4)
#define VERT_BIT_TEX5            BITFIELD64_BIT(VERT_ATTRIB_TEX5)
#define VERT_BIT_TEX6            BITFIELD64_BIT(VERT_ATTRIB_TEX6)
#define VERT_BIT_TEX7            BITFIELD64_BIT(VERT_ATTRIB_TEX7)
#define VERT_BIT_POINT_SIZE      BITFIELD64_BIT(VERT_ATTRIB_POINT_SIZE)
#define VERT_BIT_GENERIC0        BITFIELD64_BIT(VERT_ATTRIB_GENERIC0)

#define VERT_BIT(i)              BITFIELD64_BIT(i)
#define VERT_BIT_ALL             BITFIELD64_RANGE(0, VERT_ATTRIB_MAX)

#define VERT_BIT_FF(i)           VERT_BIT(i)
#define VERT_BIT_FF_ALL          BITFIELD64_RANGE(0, VERT_ATTRIB_FF_MAX)
#define VERT_BIT_TEX(i)          VERT_BIT(VERT_ATTRIB_TEX(i))
#define VERT_BIT_TEX_ALL         \
   BITFIELD64_RANGE(VERT_ATTRIB_TEX(0), VERT_ATTRIB_TEX_MAX)

#define VERT_BIT_GENERIC(i)      VERT_BIT(VERT_ATTRIB_GENERIC(i))
#define VERT_BIT_GENERIC_ALL     \
   BITFIELD64_RANGE(VERT_ATTRIB_GENERIC(0), VERT_ATTRIB_GENERIC_MAX)
/*@@}*/
d252 1
d255 1
a255 9
 * Indexes for vertex shader outputs, geometry shader inputs/outputs, and
 * fragment shader inputs.
 *
 * Note that some of these values are not available to all pipeline stages.
 *
 * When this enum is updated, the following code must be updated too:
 * - vertResults (in prog_print.c's arb_output_attrib_string())
 * - fragAttribs (in prog_print.c's arb_input_attrib_string())
 * - _mesa_varying_slot_in_fs()
d259 34
a292 26
   VARYING_SLOT_POS,
   VARYING_SLOT_COL0, /* COL0 and COL1 must be contiguous */
   VARYING_SLOT_COL1,
   VARYING_SLOT_FOGC,
   VARYING_SLOT_TEX0, /* TEX0-TEX7 must be contiguous */
   VARYING_SLOT_TEX1,
   VARYING_SLOT_TEX2,
   VARYING_SLOT_TEX3,
   VARYING_SLOT_TEX4,
   VARYING_SLOT_TEX5,
   VARYING_SLOT_TEX6,
   VARYING_SLOT_TEX7,
   VARYING_SLOT_PSIZ, /* Does not appear in FS */
   VARYING_SLOT_BFC0, /* Does not appear in FS */
   VARYING_SLOT_BFC1, /* Does not appear in FS */
   VARYING_SLOT_EDGE, /* Does not appear in FS */
   VARYING_SLOT_CLIP_VERTEX, /* Does not appear in FS */
   VARYING_SLOT_CLIP_DIST0,
   VARYING_SLOT_CLIP_DIST1,
   VARYING_SLOT_PRIMITIVE_ID, /* Does not appear in VS */
   VARYING_SLOT_LAYER, /* Appears as VS or GS output */
   VARYING_SLOT_FACE, /* FS only */
   VARYING_SLOT_PNTC, /* FS only */
   VARYING_SLOT_VAR0, /* First generic varying slot */
   VARYING_SLOT_MAX = VARYING_SLOT_VAR0 + MAX_VARYING
} gl_varying_slot;
d296 1
a296 1
 * Bitflags for varying slots.
d299 23
a321 27
#define VARYING_BIT_POS BITFIELD64_BIT(VARYING_SLOT_POS)
#define VARYING_BIT_COL0 BITFIELD64_BIT(VARYING_SLOT_COL0)
#define VARYING_BIT_COL1 BITFIELD64_BIT(VARYING_SLOT_COL1)
#define VARYING_BIT_FOGC BITFIELD64_BIT(VARYING_SLOT_FOGC)
#define VARYING_BIT_TEX0 BITFIELD64_BIT(VARYING_SLOT_TEX0)
#define VARYING_BIT_TEX1 BITFIELD64_BIT(VARYING_SLOT_TEX1)
#define VARYING_BIT_TEX2 BITFIELD64_BIT(VARYING_SLOT_TEX2)
#define VARYING_BIT_TEX3 BITFIELD64_BIT(VARYING_SLOT_TEX3)
#define VARYING_BIT_TEX4 BITFIELD64_BIT(VARYING_SLOT_TEX4)
#define VARYING_BIT_TEX5 BITFIELD64_BIT(VARYING_SLOT_TEX5)
#define VARYING_BIT_TEX6 BITFIELD64_BIT(VARYING_SLOT_TEX6)
#define VARYING_BIT_TEX7 BITFIELD64_BIT(VARYING_SLOT_TEX7)
#define VARYING_BIT_TEX(U) BITFIELD64_BIT(VARYING_SLOT_TEX0 + (U))
#define VARYING_BITS_TEX_ANY BITFIELD64_RANGE(VARYING_SLOT_TEX0, \
                                              MAX_TEXTURE_COORD_UNITS)
#define VARYING_BIT_PSIZ BITFIELD64_BIT(VARYING_SLOT_PSIZ)
#define VARYING_BIT_BFC0 BITFIELD64_BIT(VARYING_SLOT_BFC0)
#define VARYING_BIT_BFC1 BITFIELD64_BIT(VARYING_SLOT_BFC1)
#define VARYING_BIT_EDGE BITFIELD64_BIT(VARYING_SLOT_EDGE)
#define VARYING_BIT_CLIP_VERTEX BITFIELD64_BIT(VARYING_SLOT_CLIP_VERTEX)
#define VARYING_BIT_CLIP_DIST0 BITFIELD64_BIT(VARYING_SLOT_CLIP_DIST0)
#define VARYING_BIT_CLIP_DIST1 BITFIELD64_BIT(VARYING_SLOT_CLIP_DIST1)
#define VARYING_BIT_PRIMITIVE_ID BITFIELD64_BIT(VARYING_SLOT_PRIMITIVE_ID)
#define VARYING_BIT_LAYER BITFIELD64_BIT(VARYING_SLOT_LAYER)
#define VARYING_BIT_FACE BITFIELD64_BIT(VARYING_SLOT_FACE)
#define VARYING_BIT_PNTC BITFIELD64_BIT(VARYING_SLOT_PNTC)
#define VARYING_BIT_VAR(V) BITFIELD64_BIT(VARYING_SLOT_VAR0 + (V))
d324 22
d348 1
a348 1
 * Determine if the given gl_varying_slot appears in the fragment shader.
d350 29
a378 15
static inline GLboolean
_mesa_varying_slot_in_fs(gl_varying_slot slot)
{
   switch (slot) {
   case VARYING_SLOT_PSIZ:
   case VARYING_SLOT_BFC0:
   case VARYING_SLOT_BFC1:
   case VARYING_SLOT_EDGE:
   case VARYING_SLOT_CLIP_VERTEX:
   case VARYING_SLOT_LAYER:
      return GL_FALSE;
   default:
      return GL_TRUE;
   }
}
a387 3
   /* If a single color should be written to all render targets, this
    * register is written.  No FRAG_RESULT_DATAn will be written.
    */
a388 5

   /* FRAG_RESULT_DATAn are the per-render-target (GLSL gl_FragData[n]
    * or ARB_fragment_program fragment.color[n]) color results.  If
    * any are written, FRAG_RESULT_COLOR will not be written.
    */
d521 2
d524 16
a539 2
   /* EXT_framebuffer_sRGB */
   GLint sRGBCapable;
d604 3
d608 1
a608 1
 * Material state.
d610 1
a610 1
struct gl_material
d612 4
a615 1
   GLfloat Attrib[MAT_ATTRIB_MAX][4];
a619 11
 * Light state flags.
 */
/*@@{*/
#define LIGHT_SPOT         0x1
#define LIGHT_LOCAL_VIEWER 0x2
#define LIGHT_POSITIONAL   0x4
#define LIGHT_NEED_VERTICES (LIGHT_POSITIONAL|LIGHT_LOCAL_VIEWER)
/*@@}*/


/**
d634 1
d645 1
a645 1
   GLbitfield _Flags;		/**< Mask of LIGHT_x bits defined above */
d653 1
d657 2
d677 1
a677 1
 * Accumulation buffer attribute group (GL_ACCUM_BUFFER_BIT)
d679 1
a679 1
struct gl_accum_attrib
d681 1
a681 1
   GLfloat ClearColor[4];	/**< Accumulation buffer clear color */
d686 1
a686 2
 * Used for storing clear color, texture border color, etc.
 * The float values are typically unclamped.
d688 1
a688 1
union gl_color_union
d690 1
a690 3
   GLfloat f[4];
   GLint i[4];
   GLuint ui[4];
d699 5
a703 4
   GLuint ClearIndex;                      /**< Index for glClear */
   union gl_color_union ClearColor;        /**< Color for glClear, unclamped */
   GLuint IndexMask;                       /**< Color index write mask */
   GLubyte ColorMask[MAX_DRAW_BUFFERS][4]; /**< Each flag is 0xff or 0x0 */
a712 1
   GLfloat AlphaRefUnclamped;
d721 6
a726 6

   /* NOTE: this does _not_ depend on fragment clamping or any other clamping
    * control, only on the fixed-pointness of the render target.
    * The query does however depend on fragment color clamping.
    */
   GLfloat BlendColorUnclamped[4];               /**< Blending color */
a727 19

   struct
   {
      GLenum SrcRGB;             /**< RGB blend source term */
      GLenum DstRGB;             /**< RGB blend dest term */
      GLenum SrcA;               /**< Alpha blend source term */
      GLenum DstA;               /**< Alpha blend dest term */
      GLenum EquationRGB;        /**< GL_ADD, GL_SUBTRACT, etc. */
      GLenum EquationA;          /**< GL_ADD, GL_SUBTRACT, etc. */
      /**
       * Set if any blend factor uses SRC1.  Computed at the time blend factors
       * get set.
       */
      GLboolean _UsesDualSrc;
   } Blend[MAX_DRAW_BUFFERS];
   /** Are the blend func terms currently different for each buffer/target? */
   GLboolean _BlendFuncPerBuffer;
   /** Are the blend equations currently different for each buffer/target? */
   GLboolean _BlendEquationPerBuffer;
d737 1
a742 1
   GLboolean _ClampFragmentColor; /** < with GL_FIXED_ONLY_ARB resolved */
a743 2

   GLboolean sRGBEnabled;    /**< Framebuffer sRGB blending/updating requested */
d807 1
d817 1
a839 1
   GLfloat ColorUnclamped[4];            /**< Fog color */
a848 1
   GLenum FogDistanceMode;     /**< GL_NV_fog_distance */
d864 1
d870 10
d890 1
a890 2
    * Front and back material values.
    * Note: must call FLUSH_VERTICES() before using.
d892 3
a894 1
   struct gl_material Material;
d901 1
a901 1
   GLbitfield _ColorMaterialBitmask;	/**< bitmask formed from Face and Mode */
d903 1
a903 2
   GLenum ClampVertexColor;             /**< GL_TRUE, GL_FALSE, GL_FIXED_ONLY */
   GLboolean _ClampVertexColor;
d913 1
a952 5

   /* ARB_texture_multisample / GL3.2 additions */
   GLboolean SampleMask;
   /** The GL spec defines this as an array but >32x MSAA is madness */
   GLbitfield SampleMaskValue;
d963 1
d1014 4
a1092 1
   GLboolean _WriteEnabled;     /**< _Enabled and non-zero writemasks */
a1112 4
   TEXTURE_2D_MULTISAMPLE_INDEX,
   TEXTURE_2D_MULTISAMPLE_ARRAY_INDEX,
   TEXTURE_CUBE_ARRAY_INDEX,
   TEXTURE_BUFFER_INDEX,
a1114 1
   TEXTURE_EXTERNAL_INDEX,
a1128 4
#define TEXTURE_2D_MULTISAMPLE_BIT (1 << TEXTURE_2D_MULTISAMPLE_INDEX)
#define TEXTURE_2D_MULTISAMPLE_ARRAY_BIT (1 << TEXTURE_2D_MULTISAMPLE_ARRAY_INDEX)
#define TEXTURE_CUBE_ARRAY_BIT (1 << TEXTURE_CUBE_ARRAY_INDEX)
#define TEXTURE_BUFFER_BIT   (1 << TEXTURE_BUFFER_INDEX)
a1130 1
#define TEXTURE_EXTERNAL_BIT (1 << TEXTURE_EXTERNAL_INDEX)
d1140 73
a1212 2
 * Texture image state.  Drivers will typically create a subclass of this
 * with extra fields for memory buffers, etc.
d1219 3
a1221 3
				 *   GL_INTENSITY, GL_DEPTH_COMPONENT or
				 *   GL_DEPTH_STENCIL_EXT only. Used for
				 *   choosing TexEnv arithmetic.
d1223 1
a1223 1
   gl_format TexFormat;         /**< The actual texture memory format */
d1235 6
a1240 2
   GLuint MaxNumLevels;		/**< = maximum possible number of mipmap
                                       levels, computed from the dimensions */
d1243 15
a1257 7
   GLuint Level;                /**< Which mipmap level am I? */
   /** Cube map face: index into gl_texture_object::Image[] array */
   GLuint Face;

   /** GL_ARB_texture_multisample */
   GLuint NumSamples;            /**< Sample count, or 0 for non-multisample */
   GLboolean FixedSampleLocations; /**< Same sample locations for all pixels? */
d1277 3
a1279 2
 * Sampler object state.  These objects are new with GL_ARB_sampler_objects
 * and OpenGL 3.3.  Legacy texture objects also contain a sampler object.
d1281 1
a1281 1
struct gl_sampler_object
d1283 10
a1292 3
   GLuint Name;
   GLint RefCount;

a1297 1
   union gl_color_union BorderColor;  /**< Interpreted according to texture format */
d1301 2
d1306 1
a1306 18
   GLenum sRGBDecode;           /**< GL_DECODE_EXT or GL_SKIP_DECODE_EXT */
   GLboolean CubeMapSeamless;   /**< GL_AMD_seamless_cubemap_per_texture */
};


/**
 * Texture object state.  Contains the array of mipmap images, border color,
 * wrap modes, filter modes, and shadow/texcompare state.
 */
struct gl_texture_object
{
   _glthread_Mutex Mutex;	/**< for thread safety */
   GLint RefCount;		/**< reference count */
   GLuint Name;			/**< the user-visible texture object ID */
   GLenum Target;               /**< GL_TEXTURE_1D, GL_TEXTURE_2D, etc. */

   struct gl_sampler_object Sampler;

a1307 5

   GLfloat Priority;		/**< in [0,1] */
   GLint BaseLevel;		/**< min mipmap level, OpenGL 1.2 */
   GLint MaxLevel;		/**< max mipmap level, OpenGL 1.2 */
   GLint ImmutableLevels;       /**< ES 3.0 / ARB_texture_view */
d1314 1
a1314 3
   GLboolean _BaseComplete;     /**< Is the base texture level valid? */
   GLboolean _MipmapComplete;   /**< Is the whole mipmap valid? */
   GLboolean _IsIntegerFormat;  /**< Does the texture store integer values? */
a1316 1
   GLboolean Immutable;         /**< GL_ARB_texture_storage */
d1321 2
a1322 8
   /** GL_ARB_texture_buffer_object */
   struct gl_buffer_object *BufferObject;
   GLenum BufferObjectFormat;
   /** Equivalent Mesa format for BufferObjectFormat. */
   gl_format _BufferObjectFormat;
   /** GL_ARB_texture_buffer_range */
   GLintptr BufferOffset;
   GLsizeiptr BufferSize; /**< if this is -1, use BufferObject->Size instead */
d1324 8
a1331 2
   /** GL_OES_EGL_image_external */
   GLint RequiredTextureImageUnits;
a1359 40
 * TexGenEnabled flags.
 */
/*@@{*/
#define S_BIT 1
#define T_BIT 2
#define R_BIT 4
#define Q_BIT 8
#define STR_BITS (S_BIT | T_BIT | R_BIT)
/*@@}*/


/**
 * Bit flag versions of the corresponding GL_ constants.
 */
/*@@{*/
#define TEXGEN_SPHERE_MAP        0x1
#define TEXGEN_OBJ_LINEAR        0x2
#define TEXGEN_EYE_LINEAR        0x4
#define TEXGEN_REFLECTION_MAP_NV 0x8
#define TEXGEN_NORMAL_MAP_NV     0x10

#define TEXGEN_NEED_NORMALS      (TEXGEN_SPHERE_MAP        | \
				  TEXGEN_REFLECTION_MAP_NV | \
				  TEXGEN_NORMAL_MAP_NV)
#define TEXGEN_NEED_EYE_COORD    (TEXGEN_SPHERE_MAP        | \
				  TEXGEN_REFLECTION_MAP_NV | \
				  TEXGEN_NORMAL_MAP_NV     | \
				  TEXGEN_EYE_LINEAR)
/*@@}*/



/** Tex-gen enabled for texture unit? */
#define ENABLE_TEXGEN(unit) (1 << (unit))

/** Non-identity texture matrix for texture unit? */
#define ENABLE_TEXMAT(unit) (1 << (unit))


/**
d1373 2
a1374 1
 * combiners, texgen state, and pointers to current texture objects.
d1382 1
a1382 2
   GLclampf EnvColor[4];
   GLfloat EnvColorUnclamped[4];
a1394 3
   /** Current sampler object (GL_ARB_sampler_objects) */
   struct gl_sampler_object *Sampler;

d1417 7
a1436 3
   /** GL_ARB_texture_buffer_object */
   struct gl_buffer_object *BufferObject;

d1440 4
a1461 7
 * Data structure representing a single clip plane (e.g. one of the elements
 * of the ctx->Transform.EyeUserPlane or ctx->Transform._ClipUserPlane array).
 */
typedef GLfloat gl_clip_plane[4];


/**
d1467 2
a1468 2
   gl_clip_plane EyeUserPlane[MAX_CLIP_PLANES];	/**< User clip planes */
   gl_clip_plane _ClipUserPlane[MAX_CLIP_PLANES]; /**< derived */
a1509 1
   GLboolean DeletePending;   /**< true if buffer object is removed from the hash */
d1528 1
a1547 1
   GLuint InstanceDivisor;      /**< GL_ARB_instanced_arrays */
d1566 1
d1568 13
a1580 15
   /**
    * Does the VAO use ARB semantics or Apple semantics?
    *
    * There are several ways in which ARB_vertex_array_object and
    * APPLE_vertex_array_object VAOs have differing semantics.  At the very
    * least,
    *
    *     - ARB VAOs require that all array data be sourced from vertex buffer
    *       objects, but Apple VAOs do not.
    *
    *     - ARB VAOs require that names come from GenVertexArrays.
    *
    * This flag notes which behavior governs this VAO.
    */
   GLboolean ARBsemantics;
d1583 4
a1586 1
    * Has this array object been bound?
d1588 1
a1588 1
   GLboolean EverBound;
d1590 2
a1591 5
   /** Vertex attribute arrays */
   struct gl_client_array VertexAttrib[VERT_ATTRIB_MAX];

   /** Mask of VERT_BIT_* values indicating which arrays are enabled */
   GLbitfield64 _Enabled;
d1598 1
a1598 3

   struct gl_buffer_object *ElementArrayBufferObj;
};
d1619 1
a1619 7
   /**
    * \name Primitive restart controls
    *
    * Primitive restart is enabled if either \c PrimitiveRestart or
    * \c PrimitiveRestartFixedIndex is set.
    */
   /*@@{*/
a1620 2
   GLboolean PrimitiveRestartFixedIndex;
   GLboolean _PrimitiveRestart;
d1622 2
a1623 1
   /*@@}*/
d1627 1
a1627 6

   /**
    * Vertex arrays as consumed by a driver.
    * The array pointer is set up only by the VBO module.
    */
   const struct gl_client_array **_DrawArrays; /**< 0..VERT_ATTRIB_MAX-1 */
d1703 1
d1719 1
a1723 124
struct gl_transform_feedback_varying_info
{
   char *Name;
   GLenum Type;
   GLint Size;
};


/**
 * Per-output info vertex shaders for transform feedback.
 */
struct gl_transform_feedback_output
{
   unsigned OutputRegister;
   unsigned OutputBuffer;
   unsigned NumComponents;

   /** offset (in DWORDs) of this output within the interleaved structure */
   unsigned DstOffset;

   /**
    * Offset into the output register of the data to output.  For example,
    * if NumComponents is 2 and ComponentOffset is 1, then the data to
    * offset is in the y and z components of the output register.
    */
   unsigned ComponentOffset;
};


/** Post-link transform feedback info. */
struct gl_transform_feedback_info
{
   unsigned NumOutputs;

   /**
    * Number of transform feedback buffers in use by this program.
    */
   unsigned NumBuffers;

   struct gl_transform_feedback_output *Outputs;

   /** Transform feedback varyings used for the linking of this shader program.
    *
    * Use for glGetTransformFeedbackVarying().
    */
   struct gl_transform_feedback_varying_info *Varyings;
   GLint NumVarying;

   /**
    * Total number of components stored in each buffer.  This may be used by
    * hardware back-ends to determine the correct stride when interleaving
    * multiple transform feedback outputs in the same buffer.
    */
   unsigned BufferStride[MAX_FEEDBACK_BUFFERS];
};


/**
 * Transform feedback object state
 */
struct gl_transform_feedback_object
{
   GLuint Name;  /**< AKA the object ID */
   GLint RefCount;
   GLboolean Active;  /**< Is transform feedback enabled? */
   GLboolean Paused;  /**< Is transform feedback paused? */
   GLboolean EndedAnytime; /**< Has EndTransformFeedback been called
                                at least once? */
   GLboolean EverBound; /**< Has this object been bound? */

   /**
    * GLES: if Active is true, remaining number of primitives which can be
    * rendered without overflow.  This is necessary to track because GLES
    * requires us to generate INVALID_OPERATION if a call to glDrawArrays or
    * glDrawArraysInstanced would overflow transform feedback buffers.
    * Undefined if Active is false.
    *
    * Not tracked for desktop GL since it's unnecessary.
    */
   unsigned GlesRemainingPrims;

   /** The feedback buffers */
   GLuint BufferNames[MAX_FEEDBACK_BUFFERS];
   struct gl_buffer_object *Buffers[MAX_FEEDBACK_BUFFERS];

   /** Start of feedback data in dest buffer */
   GLintptr Offset[MAX_FEEDBACK_BUFFERS];

   /**
    * Max data to put into dest buffer (in bytes).  Computed based on
    * RequestedSize and the actual size of the buffer.
    */
   GLsizeiptr Size[MAX_FEEDBACK_BUFFERS];

   /**
    * Size that was specified when the buffer was bound.  If the buffer was
    * bound with glBindBufferBase() or glBindBufferOffsetEXT(), this value is
    * zero.
    */
   GLsizeiptr RequestedSize[MAX_FEEDBACK_BUFFERS];
};


/**
 * Context state for transform feedback.
 */
struct gl_transform_feedback_state
{
   GLenum Mode;       /**< GL_POINTS, GL_LINES or GL_TRIANGLES */

   /** The general binding point (GL_TRANSFORM_FEEDBACK_BUFFER) */
   struct gl_buffer_object *CurrentBuffer;

   /** The table of all transform feedback objects */
   struct _mesa_HashTable *Objects;

   /** The current xform-fb object (GL_TRANSFORM_FEEDBACK_BINDING) */
   struct gl_transform_feedback_object *CurrentObject;

   /** The default xform-fb object (Name==0) */
   struct gl_transform_feedback_object *DefaultObject;
};


d1730 1
a1730 1
 * NOTE: PROGRAM_ENV_PARAM, PROGRAM_STATE_VAR,
a1737 1
   PROGRAM_ARRAY,       /**< Arrays & Matrixes */
d1740 1
d1744 1
a1749 1
   PROGRAM_SYSTEM_VALUE,/**< InstanceId, PrimitiveID, etc. */
d1755 4
a1758 46
/**
 * If the register file is PROGRAM_SYSTEM_VALUE, the register index will be
 * one of these values.
 */
typedef enum
{
   SYSTEM_VALUE_FRONT_FACE,  /**< Fragment shader only (not done yet) */
   SYSTEM_VALUE_VERTEX_ID,   /**< Vertex shader only */
   SYSTEM_VALUE_INSTANCE_ID, /**< Vertex shader only */
   SYSTEM_VALUE_MAX          /**< Number of values */
} gl_system_value;


/**
 * The possible interpolation qualifiers that can be applied to a fragment
 * shader input in GLSL.
 *
 * Note: INTERP_QUALIFIER_NONE must be 0 so that memsetting the
 * gl_fragment_program data structure to 0 causes the default behavior.
 */
enum glsl_interp_qualifier
{
   INTERP_QUALIFIER_NONE = 0,
   INTERP_QUALIFIER_SMOOTH,
   INTERP_QUALIFIER_FLAT,
   INTERP_QUALIFIER_NOPERSPECTIVE,
   INTERP_QUALIFIER_COUNT /**< Number of interpolation qualifiers */
};


/**
 * \brief Layout qualifiers for gl_FragDepth.
 *
 * Extension AMD_conservative_depth allows gl_FragDepth to be redeclared with
 * a layout qualifier.
 *
 * \see enum ir_depth_layout
 */
enum gl_frag_depth_layout
{
   FRAG_DEPTH_LAYOUT_NONE, /**< No layout is specified. */
   FRAG_DEPTH_LAYOUT_ANY,
   FRAG_DEPTH_LAYOUT_GREATER,
   FRAG_DEPTH_LAYOUT_LESS,
   FRAG_DEPTH_LAYOUT_UNCHANGED
};
d1769 1
a1769 1
   GLenum Target;    /**< GL_VERTEX/FRAGMENT_PROGRAM_ARB */
d1771 1
d1775 1
a1775 1
   GLbitfield64 InputsRead;     /**< Bitmask of which input regs are read */
a1776 1
   GLbitfield SystemValuesRead;   /**< Bitmask of SYSTEM_VALUE_x inputs used */
d1779 1
a1779 1
   GLbitfield TexturesUsed[MAX_COMBINED_TEXTURE_IMAGE_UNITS];  /**< TEXTURE_x_BIT bitmask */
d1789 5
d1796 2
d1833 1
a1834 1
   GLboolean UsesClipDistance;
d1854 1
a1855 1
   GLboolean UsesDFdy;          /**< shader uses DDY instruction */
a1857 14
   enum gl_frag_depth_layout FragDepthLayout;

   /**
    * GLSL interpolation qualifier associated with each fragment shader input.
    * For inputs that do not have an interpolation qualifier specified in
    * GLSL, the value is INTERP_QUALIFIER_NONE.
    */
   enum glsl_interp_qualifier InterpQualifier[VARYING_SLOT_MAX];

   /**
    * Bitfield indicating, for each fragment shader input, 1 if that input
    * uses centroid interpolation, 0 otherwise.  Unused inputs are 0.
    */
   GLbitfield64 IsCentroid;
a1879 2
   /** Computed two sided lighting for fixed function/programs. */
   GLboolean _TwoSideEnabled;
d1890 4
d1998 51
d2064 1
a2064 4
   /** GL_FRAGMENT_SHADER || GL_VERTEX_SHADER || GL_GEOMETRY_SHADER_ARB.
    * Must be the first field.
    */
   GLenum Type;
d2069 2
a2077 47
   GLboolean IsES;         /**< True if this shader uses GLSL ES */

   /**
    * \name Sampler tracking
    *
    * \note Each of these fields is only set post-linking.
    */
   /*@@{*/
   unsigned num_samplers;	/**< Number of samplers used by this shader. */
   GLbitfield active_samplers;	/**< Bitfield of which samplers are used */
   GLbitfield shadow_samplers;	/**< Samplers used for shadow sampling. */
   /*@@}*/

   /**
    * Map from sampler unit to texture unit (set by glUniform1i())
    *
    * A sampler unit is associated with each sampler uniform by the linker.
    * The sampler unit associated with each uniform is stored in the
    * \c gl_uniform_storage::sampler field.
    */
   GLubyte SamplerUnits[MAX_SAMPLERS];
   /** Which texture target is being sampled (TEXTURE_1D/2D/3D/etc_INDEX) */
   gl_texture_index SamplerTargets[MAX_SAMPLERS];

   /**
    * Number of default uniform block components used by this shader.
    *
    * This field is only set post-linking.
    */
   unsigned num_uniform_components;

   /**
    * Number of combined uniform components used by this shader.
    *
    * This field is only set post-linking.  It is the sum of the uniform block
    * sizes divided by sizeof(float), and num_uniform_compoennts.
    */
   unsigned num_combined_uniform_components;

   /**
    * This shader's uniform block information.
    *
    * The offsets of the variables are assigned only for shaders in a program's
    * _LinkedShaders[].
    */
   struct gl_uniform_block *UniformBlocks;
   unsigned NumUniformBlocks;
a2088 78
 * Shader stages. Note that these will become 5 with tessellation.
 *
 * The order must match how shaders are ordered in the pipeline.
 * The GLSL linker assumes that if i<j, then the j-th shader is
 * executed later than the i-th shader.
 */
typedef enum
{
   MESA_SHADER_VERTEX = 0,
   MESA_SHADER_GEOMETRY = 1,
   MESA_SHADER_FRAGMENT = 2,
   MESA_SHADER_TYPES = 3
} gl_shader_type;


struct gl_uniform_buffer_variable
{
   char *Name;

   /**
    * Name of the uniform as seen by glGetUniformIndices.
    *
    * glGetUniformIndices requires that the block instance index \b not be
    * present in the name of queried uniforms.
    *
    * \note
    * \c gl_uniform_buffer_variable::IndexName and
    * \c gl_uniform_buffer_variable::Name may point to identical storage.
    */
   char *IndexName;

   const struct glsl_type *Type;
   unsigned int Offset;
   GLboolean RowMajor;
};


enum gl_uniform_block_packing
{
   ubo_packing_std140,
   ubo_packing_shared,
   ubo_packing_packed
};


struct gl_uniform_block
{
   /** Declared name of the uniform block */
   char *Name;

   /** Array of supplemental information about UBO ir_variables. */
   struct gl_uniform_buffer_variable *Uniforms;
   GLuint NumUniforms;

   /**
    * Index (GL_UNIFORM_BLOCK_BINDING) into ctx->UniformBufferBindings[] to use
    * with glBindBufferBase to bind a buffer object to this uniform block.  When
    * updated in the program, _NEW_BUFFER_OBJECT will be set.
    */
   GLuint Binding;

   /**
    * Minimum size of a buffer object to back this uniform buffer
    * (GL_UNIFORM_BLOCK_DATA_SIZE).
    */
   GLuint UniformBufferSize;

   /**
    * Layout specified in the shader
    *
    * This isn't accessible through the API, but it is used while
    * cross-validating uniform blocks.
    */
   enum gl_uniform_block_packing _Packing;
};


/**
a2098 16
   /**
    * Is the application intending to glGetProgramBinary this program?
    */
   GLboolean BinaryRetreivableHint;

   /**
    * Flags that the linker should not reject the program if it lacks
    * a vertex or fragment shader.  GLES2 doesn't allow separate
    * shader objects, and would reject them.  However, we internally
    * build separate shader objects for fixed function programs, which
    * we use for drivers/common/meta.c and for handling
    * _mesa_update_state with no program bound (for example in
    * glClear()).
    */
   GLboolean InternalSeparateShader;

d2102 2
a2103 18
   /**
    * User-defined attribute bindings
    *
    * These are set via \c glBindAttribLocation and are used to direct the
    * GLSL linker.  These are \b not the values used in the compiled shader,
    * and they are \b not the values returned by \c glGetAttribLocation.
    */
   struct string_to_uint_map *AttributeBindings;

   /**
    * User-defined fragment data bindings
    *
    * These are set via \c glBindFragDataLocation and are used to direct the
    * GLSL linker.  These are \b not the values used in the compiled shader,
    * and they are \b not the values returned by \c glGetFragDataLocation.
    */
   struct string_to_uint_map *FragDataBindings;
   struct string_to_uint_map *FragDataIndexBindings;
d2105 1
a2105 7
   /**
    * Transform feedback varyings last specified by
    * glTransformFeedbackVaryings().
    *
    * For the current set of transform feeedback varyings used for transform
    * feedback output, see LinkedTransformFeedback.
    */
a2111 6
   /** Post-link transform feedback info. */
   struct gl_transform_feedback_info LinkedTransformFeedback;

   /** Post-link gl_FragDepth layout for ARB_conservative_depth. */
   enum gl_frag_depth_layout FragDepthLayout;

d2120 6
a2125 48
   /** Vertex shader state - copied into gl_vertex_program at link time */
   struct {
      GLboolean UsesClipDistance; /**< True if gl_ClipDistance is written to. */
      GLuint ClipDistanceArraySize; /**< Size of the gl_ClipDistance array, or
                                         0 if not present. */
   } Vert;

   /* post-link info: */
   unsigned NumUserUniformStorage;
   struct gl_uniform_storage *UniformStorage;

   struct gl_uniform_block *UniformBlocks;
   unsigned NumUniformBlocks;

   /**
    * Scale factor for the uniform base location
    *
    * This is used to generate locations (returned by \c glGetUniformLocation)
    * of uniforms.  The base location of the uniform is multiplied by this
    * value, and the array index is added.
    *
    * \note
    * Must be >= 1.
    *
    * \sa
    * _mesa_uniform_merge_location_offset, _mesa_uniform_split_location_offset
    */
   unsigned UniformLocationBaseScale;

   /**
    * Indices into the _LinkedShaders's UniformBlocks[] array for each stage
    * they're used in, or -1.
    *
    * This is used to maintain the Binding values of the stage's UniformBlocks[]
    * and to answer the GL_UNIFORM_BLOCK_REFERENCED_BY_*_SHADER queries.
    */
   int *UniformBlockStageIndex[MESA_SHADER_TYPES];

   /**
    * Map of active uniform names to locations
    *
    * Maps any active uniform that is not an array element to a location.
    * Each active uniform, including individual structure members will appear
    * in this map.  This roughly corresponds to the set of names that would be
    * enumerated by \c glGetActiveUniform.
    */
   struct string_to_uint_map *UniformHash;

a2131 1
   GLboolean IsES;         /**< True if this program uses GLSL ES */
a2151 1
#define GLSL_REPORT_ERRORS 0x100  /**< Print compilation errors */
a2169 2
   struct gl_shader_program *_CurrentFragmentProgram;

d2177 2
a2181 1

d2189 6
a2200 1
   GLboolean LowerClipDistance; /**< Lower gl_ClipDistance from float[8] to vec4[2]? */
a2211 1
   GLuint MaxIfDepth;               /**< Maximum nested IF blocks */
a2213 6
   /**
    * Prefer DP4 instructions (rather than MUL/MAD) for matrix * vector
    * operations, such as position transformation.
    */
   GLboolean PreferDP4;

a2216 1

d2218 1
a2218 1
 * Occlusion/timer query object.
d2220 1
a2220 1
struct gl_query_object
d2222 13
a2234 6
   GLenum Target;      /**< The query target, when active */
   GLuint Id;          /**< hash table ID/name */
   GLuint64EXT Result; /**< the counter */
   GLboolean Active;   /**< inside Begin/EndQuery */
   GLboolean Ready;    /**< result is ready? */
   GLboolean EverBound;/**< has query object ever been bound */
d2239 1
a2239 1
 * Context state for query objects.
d2241 1
a2241 1
struct gl_query_state
d2243 3
a2245 3
   struct _mesa_HashTable *QueryObjects;
   struct gl_query_object *CurrentOcclusionObject; /* GL_ARB_occlusion_query */
   struct gl_query_object *CurrentTimerObject;     /* GL_EXT_timer_query */
d2247 2
a2248 2
   /** GL_NV_conditional_render */
   struct gl_query_object *CondRenderQuery;
d2250 2
a2251 3
   /** GL_EXT_transform_feedback */
   struct gl_query_object *PrimitivesGenerated;
   struct gl_query_object *PrimitivesWritten;
d2253 2
a2254 2
   /** GL_ARB_timer_query */
   struct gl_query_object *TimeElapsed;
d2256 2
a2257 1
   GLenum CondRenderMode;
a2260 14
/** Sync object state */
struct gl_sync_object
{
   GLenum Type;               /**< GL_SYNC_FENCE */
   GLuint Name;               /**< Fence name */
   GLint RefCount;            /**< Reference count */
   GLboolean DeletePending;   /**< Object was deleted while there were still
			       * live references (e.g., sync not yet finished)
			       */
   GLenum SyncCondition;
   GLbitfield Flags;          /**< Flags passed to glFenceSync */
   GLuint StatusFlag:1;       /**< Has the sync object been signaled? */
};

d2276 1
a2276 1
   struct gl_texture_object *FallbackTex[NUM_TEXTURE_TARGETS];
d2316 1
a2316 1
   struct set *SyncObjects;
d2318 1
a2318 2
   /** GL_ARB_sampler_objects */
   struct _mesa_HashTable *SamplerObjects;
d2323 1
d2325 7
a2331 3
 * Renderbuffers represent drawing surfaces such as color, depth and/or
 * stencil.  A framebuffer object has a set of renderbuffers.
 * Drivers will typically derive subclasses of this type.
d2335 3
a2337 1
   _glthread_Mutex Mutex; /**< for thread safety */
d2342 3
a2344 13
   GLuint Depth;
   GLboolean Purgeable;  /**< Is the buffer purgeable under memory pressure? */
   GLboolean AttachedAnytime; /**< TRUE if it was attached to a framebuffer */
   /**
    * True for renderbuffers that wrap textures, giving the driver a chance to
    * flush render caches through the FinishRenderTexture hook.
    *
    * Drivers may also set this on renderbuffers other than those generated by
    * glFramebufferTexture(), though it means FinishRenderTexture() would be
    * called without a rb->TexImage.
    */
   GLboolean NeedsFinishRenderTexture;
   GLubyte NumSamples;
d2348 11
a2358 9
   gl_format Format;      /**< The actual renderbuffer memory format */
   /**
    * Pointer to the texture image if this renderbuffer wraps a texture,
    * otherwise NULL.
    *
    * Note that the reference on the gl_texture_object containing this
    * TexImage is held by the gl_renderbuffer_attachment.
    */
   struct gl_texture_image *TexImage;
d2360 2
a2361 2
   /** Delete this renderbuffer */
   void (*Delete)(struct gl_context *ctx, struct gl_renderbuffer *rb);
d2363 2
a2364 3
   /** Allocate new storage for this renderbuffer */
   GLboolean (*AllocStorage)(struct gl_context *ctx,
                             struct gl_renderbuffer *rb,
d2367 58
a2451 1
   GLboolean Layered;
d2481 2
a2503 4
   /* ARB_color_buffer_float */
   GLboolean _AllColorBuffersFixedPoint; /* no integer, no float */
   GLboolean _HasSNormOrFloatColorBuffer;

d2520 4
a2523 1
   GLboolean Layered;
d2542 1
a2542 1
 * Limits for vertex, geometry and fragment programs/shaders.
a2553 1
   GLuint MaxAddressOffset;  /**< [-MaxAddressOffset, MaxAddressOffset-1] */
d2567 8
a2574 1
   GLuint MaxUniformComponents;  /**< Usually == MaxParameters * 4 */
a2577 4
   /* GL_ARB_uniform_buffer_object */
   GLuint MaxUniformBlocks;
   GLuint MaxCombinedUniformComponents;
   GLuint MaxTextureImageUnits;
d2587 6
a2592 6
   GLuint MaxTextureMbytes;      /**< Max memory per image, in MB */
   GLuint MaxTextureLevels;      /**< Max mipmap levels. */ 
   GLuint Max3DTextureLevels;    /**< Max mipmap levels for 3D textures */
   GLuint MaxCubeTextureLevels;  /**< Max mipmap levels for cube textures */
   GLuint MaxArrayTextureLayers; /**< Max layers in array textures */
   GLuint MaxTextureRectSize;    /**< Max rectangle texture size, in pixes */
d2594 2
d2597 1
a2597 1
   GLuint MaxTextureUnits; /**< = MIN(CoordUnits, FragmentProgram.ImageUnits) */
a2599 3
   GLuint MaxTextureBufferSize;      /**< GL_ARB_texture_buffer_object */

   GLuint TextureBufferOffsetAlignment; /**< GL_ARB_texture_buffer_range */
d2612 2
a2626 8
   struct {
      GLuint SamplesPassed;
      GLuint TimeElapsed;
      GLuint Timestamp;
      GLuint PrimitivesGenerated;
      GLuint PrimitivesWritten;
   } QueryCounterBits;

d2636 1
a2636 16
   /** Number of varying vectors between any two shader stages. */
   GLuint MaxVarying;
   GLuint MaxVaryingComponents;

   /** @@{
    * GL_ARB_uniform_buffer_object
    */
   GLuint MaxCombinedUniformBlocks;
   GLuint MaxUniformBufferBindings;
   GLuint MaxUniformBlockSize;
   GLuint UniformBufferOffsetAlignment;
   /** @@} */

   /** GL_ARB_geometry_shader4 */
   GLuint MaxGeometryOutputVertices;
   GLuint MaxGeometryTotalOutputComponents;
a2639 24
   /**
    * Changes default GLSL extension behavior from "error" to "warn".  It's out
    * of spec, but it can make some apps work that otherwise wouldn't.
    */
   GLboolean ForceGLSLExtensionsWarn;

   /**
    * If non-zero, forces GLSL shaders without the #version directive to behave
    * as if they began with "#version ForceGLSLVersion".
    */
   GLuint ForceGLSLVersion;

   /**
    * Does the driver support real 32-bit integers?  (Otherwise, integers are
    * simulated via floats.)
    */
   GLboolean NativeIntegers;

   /**
    * If the driver supports real 32-bit integers, what integer value should be
    * used for boolean true in uniform uploads?  (Usually 1 or ~0.)
    */
   GLuint UniformBooleanTrue;

d2658 1
a2658 1
   GLuint MaxTransformFeedbackBuffers;
a2660 1
   GLuint MaxVertexStreams;
a2663 69

   /* GL_ARB_robustness */
   GLenum ResetStrategy;

   /* GL_ARB_blend_func_extended */
   GLuint MaxDualSourceDrawBuffers;

   /**
    * Whether the implementation strips out and ignores texture borders.
    *
    * Many GPU hardware implementations don't support rendering with texture
    * borders and mipmapped textures.  (Note: not static border color, but the
    * old 1-pixel border around each edge).  Implementations then have to do
    * slow fallbacks to be correct, or just ignore the border and be fast but
    * wrong.  Setting the flag strips the border off of TexImage calls,
    * providing "fast but wrong" at significantly reduced driver complexity.
    *
    * Texture borders are deprecated in GL 3.0.
    **/
   GLboolean StripTextureBorder;

   /**
    * For drivers which can do a better job at eliminating unused uniforms
    * than the GLSL compiler.
    *
    * XXX Remove these as soon as a better solution is available.
    */
   GLboolean GLSLSkipStrictMaxUniformLimitCheck;

   /**
    * Force software support for primitive restart in the VBO module.
    */
   GLboolean PrimitiveRestartInSoftware;

   /** GL_ARB_map_buffer_alignment */
   GLuint MinMapBufferAlignment;

   /**
    * Disable varying packing.  This is out of spec, but potentially useful
    * for older platforms that supports a limited number of texture
    * indirections--on these platforms, unpacking the varyings in the fragment
    * shader increases the number of texture indirections by 1, which might
    * make some shaders not executable at all.
    *
    * Drivers that support transform feedback must set this value to GL_FALSE.
    */
   GLboolean DisableVaryingPacking;

   /*
    * Maximum value supported for an index in DrawElements and friends.
    *
    * This must be at least (1ull<<24)-1.  The default value is
    * (1ull<<32)-1.
    *
    * \since ES 3.0 or GL_ARB_ES3_compatibility
    * \sa _mesa_init_constants
    */
   GLuint64 MaxElementIndex;

   /**
    * Disable interpretation of line continuations (lines ending with a
    * backslash character ('\') in GLSL source.
    */
   GLboolean DisableGLSLLineContinuations;

   /** GL_ARB_texture_multisample */
   GLint MaxColorTextureSamples;
   GLint MaxDepthTextureSamples;
   GLint MaxIntegerSamples;
a2675 1
   GLboolean ANGLE_texture_compression_dxt;
a2676 2
   GLboolean ARB_ES3_compatibility;
   GLboolean ARB_base_instance;
d2678 1
a2678 2
   GLboolean ARB_color_buffer_float;
   GLboolean ARB_conservative_depth;
d2682 1
a2682 1
   GLboolean ARB_draw_buffers_blend;
a2691 1
   GLboolean ARB_gpu_shader5;
a2694 2
   GLboolean ARB_internalformat_query;
   GLboolean ARB_map_buffer_alignment;
d2696 2
d2701 1
d2703 1
a2703 1
   GLboolean ARB_shader_bit_encoding;
d2705 1
a2705 3
   GLboolean ARB_shader_texture_lod;
   GLboolean ARB_shading_language_packing;
   GLboolean ARB_shading_language_420pack;
d2707 1
d2711 1
a2711 2
   GLboolean ARB_texture_buffer_object_rgb32;
   GLboolean ARB_texture_buffer_range;
a2713 1
   GLboolean ARB_texture_cube_map_array;
d2718 1
a2720 1
   GLboolean ARB_texture_query_lod;
d2725 1
a2725 2
   GLboolean ARB_transform_feedback3;
   GLboolean ARB_transform_feedback_instanced;
d2727 2
d2732 3
d2738 1
d2740 4
d2746 2
d2750 1
a2750 1
   GLboolean EXT_framebuffer_multisample_blit_scaled;
d2754 2
d2758 1
d2761 1
d2763 3
d2767 3
d2771 3
a2775 1
   GLboolean EXT_texture_compression_latc;
d2777 2
d2782 1
a2784 1
   GLboolean EXT_texture_snorm;
a2785 1
   GLboolean EXT_texture_sRGB_decode;
d2789 1
d2791 1
d2794 3
a2796 2
   GLboolean AMD_seamless_cubemap_per_texture;
   GLboolean AMD_vertex_shader_layer;
a2798 1
   GLboolean ATI_texture_compression_3dc;
d2803 2
d2806 1
d2809 2
d2812 1
a2812 1
   GLboolean NV_fog_distance;
d2814 1
d2817 1
a2817 1
   GLboolean NV_texture_barrier;
d2820 7
d2828 1
d2831 1
a2831 3
   GLboolean OES_depth_texture_cube_map;
   GLboolean OES_EGL_image_external;
   GLboolean OES_compressed_ETC1_RGB8_texture;
d2871 2
d2875 30
a2904 32
#define _NEW_MODELVIEW         (1 << 0)   /**< gl_context::ModelView */
#define _NEW_PROJECTION        (1 << 1)   /**< gl_context::Projection */
#define _NEW_TEXTURE_MATRIX    (1 << 2)   /**< gl_context::TextureMatrix */
#define _NEW_COLOR             (1 << 3)   /**< gl_context::Color */
#define _NEW_DEPTH             (1 << 4)   /**< gl_context::Depth */
#define _NEW_EVAL              (1 << 5)   /**< gl_context::Eval, EvalMap */
#define _NEW_FOG               (1 << 6)   /**< gl_context::Fog */
#define _NEW_HINT              (1 << 7)   /**< gl_context::Hint */
#define _NEW_LIGHT             (1 << 8)   /**< gl_context::Light */
#define _NEW_LINE              (1 << 9)   /**< gl_context::Line */
#define _NEW_PIXEL             (1 << 10)  /**< gl_context::Pixel */
#define _NEW_POINT             (1 << 11)  /**< gl_context::Point */
#define _NEW_POLYGON           (1 << 12)  /**< gl_context::Polygon */
#define _NEW_POLYGONSTIPPLE    (1 << 13)  /**< gl_context::PolygonStipple */
#define _NEW_SCISSOR           (1 << 14)  /**< gl_context::Scissor */
#define _NEW_STENCIL           (1 << 15)  /**< gl_context::Stencil */
#define _NEW_TEXTURE           (1 << 16)  /**< gl_context::Texture */
#define _NEW_TRANSFORM         (1 << 17)  /**< gl_context::Transform */
#define _NEW_VIEWPORT          (1 << 18)  /**< gl_context::Viewport */
/* gap, re-use for core Mesa state only; use ctx->DriverFlags otherwise */
#define _NEW_ARRAY             (1 << 20)  /**< gl_context::Array */
#define _NEW_RENDERMODE        (1 << 21)  /**< gl_context::RenderMode, etc */
#define _NEW_BUFFERS           (1 << 22)  /**< gl_context::Visual, DrawBuffer, */
#define _NEW_CURRENT_ATTRIB    (1 << 23)  /**< gl_context::Current */
#define _NEW_MULTISAMPLE       (1 << 24)  /**< gl_context::Multisample */
#define _NEW_TRACK_MATRIX      (1 << 25)  /**< gl_context::VertexProgram */
#define _NEW_PROGRAM           (1 << 26)  /**< New program/shader state */
#define _NEW_PROGRAM_CONSTANTS (1 << 27)
#define _NEW_BUFFER_OBJECT     (1 << 28)
#define _NEW_FRAG_CLAMP        (1 << 29)
/* gap, re-use for core Mesa state only; use ctx->DriverFlags otherwise */
#define _NEW_VARYING_VP_INPUTS (1 << 31) /**< gl_context::varying_vp_inputs */
d2910 76
d2995 2
a2996 4
#define _MESA_NEW_SEPARATE_SPECULAR        (_NEW_LIGHT | \
                                            _NEW_FOG | \
                                            _NEW_PROGRAM)

d2998 1
d3054 6
a3067 71
/** @@{
 *
 * These are a mapping of the GL_ARB_debug_output enums to small enums
 * suitable for use as an array index.
 */

enum mesa_debug_source {
   MESA_DEBUG_SOURCE_API,
   MESA_DEBUG_SOURCE_WINDOW_SYSTEM,
   MESA_DEBUG_SOURCE_SHADER_COMPILER,
   MESA_DEBUG_SOURCE_THIRD_PARTY,
   MESA_DEBUG_SOURCE_APPLICATION,
   MESA_DEBUG_SOURCE_OTHER,
   MESA_DEBUG_SOURCE_COUNT
};

enum mesa_debug_type {
   MESA_DEBUG_TYPE_ERROR,
   MESA_DEBUG_TYPE_DEPRECATED,
   MESA_DEBUG_TYPE_UNDEFINED,
   MESA_DEBUG_TYPE_PORTABILITY,
   MESA_DEBUG_TYPE_PERFORMANCE,
   MESA_DEBUG_TYPE_OTHER,
   MESA_DEBUG_TYPE_COUNT
};

enum mesa_debug_severity {
   MESA_DEBUG_SEVERITY_LOW,
   MESA_DEBUG_SEVERITY_MEDIUM,
   MESA_DEBUG_SEVERITY_HIGH,
   MESA_DEBUG_SEVERITY_COUNT
};

/** @@} */

/**
 * An error, warning, or other piece of debug information for an application
 * to consume via GL_ARB_debug_output.
 */
struct gl_debug_msg
{
   enum mesa_debug_source source;
   enum mesa_debug_type type;
   GLuint id;
   enum mesa_debug_severity severity;
   GLsizei length;
   GLcharARB *message;
};

struct gl_debug_namespace
{
   struct _mesa_HashTable *IDs;
   unsigned ZeroID; /* a HashTable won't take zero, so store its state here */
   /** lists of IDs in the hash table at each severity */
   struct simple_node Severity[MESA_DEBUG_SEVERITY_COUNT];
};

struct gl_debug_state
{
   GLDEBUGPROCARB Callback;
   const void *CallbackData;
   GLboolean SyncOutput;
   GLboolean Defaults[MESA_DEBUG_SEVERITY_COUNT][MESA_DEBUG_SOURCE_COUNT][MESA_DEBUG_TYPE_COUNT];
   struct gl_debug_namespace Namespaces[MESA_DEBUG_SOURCE_COUNT][MESA_DEBUG_TYPE_COUNT];
   struct gl_debug_msg Log[MAX_DEBUG_LOGGED_MESSAGES];
   GLint NumMessages;
   GLint NextMsg;
   GLint NextMsgLength; /* redundant, but copied here from Log[NextMsg].length
                           for the sake of the offsetof() code in get.c */
};

a3069 3
 *
 * NOTE: This must match the api_enum table in
 * src/mesa/main/get_hash_generator.py
d3071 2
a3072 3
typedef enum
{
   API_OPENGL_COMPAT,      /* legacy / compatibility contexts */
d3074 1
a3074 3
   API_OPENGLES2,
   API_OPENGL_CORE,
   API_OPENGL_LAST = API_OPENGL_CORE
a3077 39
 * Driver-specific state flags.
 *
 * These are or'd with gl_context::NewDriverState to notify a driver about
 * a state change. The driver sets the flags at context creation and
 * the meaning of the bits set is opaque to core Mesa.
 */
struct gl_driver_flags
{
   /** gl_context::Array::_DrawArrays (vertex array state) */
   GLbitfield NewArray;

   /** gl_context::TransformFeedback::CurrentObject */
   GLbitfield NewTransformFeedback;

   /** gl_context::RasterDiscard */
   GLbitfield NewRasterizerDiscard;

   /**
    * gl_context::UniformBufferBindings
    * gl_shader_program::UniformBlocks
    */
   GLbitfield NewUniformBuffer;
};

struct gl_uniform_buffer_binding
{
   struct gl_buffer_object *BufferObject;
   /** Start of uniform block data in the buffer */
   GLintptr Offset;
   /** Size of data allowed to be referenced from the buffer (in bytes) */
   GLsizeiptr Size;
   /**
    * glBindBufferBase() indicates that the Size should be ignored and only
    * limited by the current size of the BufferObject.
    */
   GLboolean AutomaticSize;
};

/**
d3095 3
a3097 22
   /**
    * The current dispatch table for non-displaylist-saving execution, either
    * BeginEnd or OutsideBeginEnd
    */
   struct _glapi_table *Exec;
   /**
    * The normal dispatch table for non-displaylist-saving, non-begin/end
    */
   struct _glapi_table *OutsideBeginEnd;
   /** The dispatch table used between glNewList() and glEndList() */
   struct _glapi_table *Save;
   /**
    * The dispatch table used between glBegin() and glEnd() (outside of a
    * display list).  Only valid functions between those two are set, which is
    * mostly just the set in a GLvertexformat struct.
    */
   struct _glapi_table *BeginEnd;
   /**
    * Tracks the current dispatch table out of the 3 above, so that it can be
    * re-set on glXMakeCurrent().
    */
   struct _glapi_table *CurrentDispatch;
d3111 2
d3137 2
a3138 2
   /** GL version integer, for example 31 for GL 3.1, or 20 for GLES 2.0. */
   GLuint Version;
d3208 1
a3208 1
   struct gl_transform_feedback_state TransformFeedback;
a3211 16

   /**
    * Current GL_ARB_uniform_buffer_object binding referenced by
    * GL_UNIFORM_BUFFER target for glBufferData, glMapBuffer, etc.
    */
   struct gl_buffer_object *UniformBuffer;

   /**
    * Array of uniform buffers for GL_ARB_uniform_buffer_object and GL 3.1.
    * This is set up using glBindBufferRange() or glBindBufferBase().  They are
    * associated with uniform blocks by glUniformBlockBinding()'s state in the
    * shader program.
    */
   struct gl_uniform_buffer_binding
      UniformBufferBindings[MAX_COMBINED_UNIFORM_BUFFERS];

a3220 3
   /* GL_ARB_robustness */
   GLenum ResetStatus;

a3226 3
   /* GL_ARB_debug_output */
   struct gl_debug_state Debug;

a3228 3
   GLbitfield NewDriverState;/**< bitwise-or of flags from DriverFlags */

   struct gl_driver_flags DriverFlags;
d3232 1
a3232 1
   GLbitfield64 varying_vp_inputs;  /**< mask of VERT_BIT_* flags */
d3235 5
d3248 4
d3259 3
d3265 5
a3269 3
   GLboolean TextureFormatSupported[MESA_FORMAT_COUNT];

   GLboolean RasterDiscard;  /**< GL_RASTERIZER_DISCARD */
d3287 4
d3328 1
a3328 4
   DEBUG_SILENT                 = (1 << 0),
   DEBUG_ALWAYS_FLUSH		= (1 << 1),
   DEBUG_INCOMPLETE_TEXTURE     = (1 << 2),
   DEBUG_INCOMPLETE_FBO         = (1 << 3)
a3331 4

#ifdef __cplusplus
}
#endif
@


1.1.1.6
log
@Import Mesa 10.2.3
@
text
@a36 3
#include <stdint.h>             /* uint32_t */
#include <stdbool.h>

a75 1
struct gl_debug_state;
a82 1
struct vbo_context;
a233 1
   VARYING_SLOT_VIEWPORT, /* Appears as VS or GS output */
a268 1
#define VARYING_BIT_VIEWPORT BITFIELD64_BIT(VARYING_SLOT_VIEWPORT)
a273 6
/**
 * Bitflags for system values.
 */
#define SYSTEM_BIT_SAMPLE_ID BITFIELD64_BIT(SYSTEM_VALUE_SAMPLE_ID)
#define SYSTEM_BIT_SAMPLE_POS BITFIELD64_BIT(SYSTEM_VALUE_SAMPLE_POS)
#define SYSTEM_BIT_SAMPLE_MASK_IN BITFIELD64_BIT(SYSTEM_VALUE_SAMPLE_MASK_IN)
a305 1
   FRAG_RESULT_SAMPLE_MASK = 3,
d311 1
a311 1
   FRAG_RESULT_DATA0 = 4,
a384 18
 * Shader stages. Note that these will become 5 with tessellation.
 *
 * The order must match how shaders are ordered in the pipeline.
 * The GLSL linker assumes that if i<j, then the j-th shader is
 * executed later than the i-th shader.
 */
typedef enum
{
   MESA_SHADER_VERTEX = 0,
   MESA_SHADER_GEOMETRY = 1,
   MESA_SHADER_FRAGMENT = 2,
   MESA_SHADER_COMPUTE = 3,
} gl_shader_stage;

#define MESA_SHADER_STAGES (MESA_SHADER_COMPUTE + 1)


/**
a871 2
   GLboolean SampleShading;
   GLfloat MinSampleShadingValue;
d982 1
a982 1
struct gl_scissor_rect
d984 1
a987 5
struct gl_scissor_attrib
{
   GLbitfield EnableFlags;	/**< Scissor test enabled? */
   struct gl_scissor_rect ScissorArray[MAX_VIEWPORTS];
};
d1051 1
d1082 1
a1082 1
   mesa_format TexFormat;         /**< The actual texture memory format */
a1130 1
   GLchar *Label;               /**< GL_KHR_debug */
d1155 4
a1158 7
   mtx_t Mutex;      /**< for thread safety */
   GLint RefCount;             /**< reference count */
   GLuint Name;                /**< the user-visible texture object ID */
   GLchar *Label;               /**< GL_KHR_debug */
   GLenum Target;              /**< GL_TEXTURE_1D, GL_TEXTURE_2D, etc. */
   gl_texture_index TargetIndex; /**< The gl_texture_unit::CurrentTex index.
                                      Only valid when Target is valid. */
d1162 1
a1162 2
   GLenum DepthMode;           /**< GL_ARB_depth_texture */
   bool StencilSampling;       /**< Should we sample stencil instead of depth? */
d1164 16
a1179 22
   GLfloat Priority;           /**< in [0,1] */
   GLint BaseLevel;            /**< min mipmap level, OpenGL 1.2 */
   GLint MaxLevel;             /**< max mipmap level, OpenGL 1.2 */
   GLint ImmutableLevels;      /**< ES 3.0 / ARB_texture_view */
   GLint _MaxLevel;            /**< actual max mipmap level (q in the spec) */
   GLfloat _MaxLambda;         /**< = _MaxLevel - BaseLevel (q - p in spec) */
   GLint CropRect[4];          /**< GL_OES_draw_texture */
   GLenum Swizzle[4];          /**< GL_EXT_texture_swizzle */
   GLuint _Swizzle;            /**< same as Swizzle, but SWIZZLE_* format */
   GLboolean GenerateMipmap;   /**< GL_SGIS_generate_mipmap */
   GLboolean _BaseComplete;    /**< Is the base texture level valid? */
   GLboolean _MipmapComplete;  /**< Is the whole mipmap valid? */
   GLboolean _IsIntegerFormat; /**< Does the texture store integer values? */
   GLboolean _RenderToTexture; /**< Any rendering to this texture? */
   GLboolean Purgeable;        /**< Is the buffer purgeable under memory
                                    pressure? */
   GLboolean Immutable;        /**< GL_ARB_texture_storage */

   GLuint MinLevel;            /**< GL_ARB_texture_view */
   GLuint MinLayer;            /**< GL_ARB_texture_view */
   GLuint NumLevels;           /**< GL_ARB_texture_view */
   GLuint NumLayers;           /**< GL_ARB_texture_view */
d1188 1
a1188 1
   mesa_format _BufferObjectFormat;
a1194 3

   /** GL_ARB_shader_image_load_store */
   GLenum ImageFormatCompatibilityType;
d1281 1
a1322 3

   /** Texture targets that have a non-default texture bound */
   GLbitfield _BoundTextures;
d1342 3
a1355 6

   /** Largest index of a texture unit with _Current != NULL. */
   GLint _MaxEnabledTexImageUnit;

   /** Largest index + 1 of texture units that have had any CurrentTex set. */
   GLint NumCurrentTexUsed;
d1379 3
d1390 3
a1392 3
   GLfloat X, Y;		/**< position */
   GLfloat Width, Height;	/**< size */
   GLdouble Near, Far;		/**< Depth buffer range */
a1396 19
typedef enum {
   MAP_USER,
   MAP_INTERNAL,

   MAP_COUNT
} gl_map_buffer_index;


/**
 * Fields describing a mapped buffer range.
 */
struct gl_buffer_mapping {
   GLbitfield AccessFlags; /**< Mask of GL_MAP_x_BIT flags */
   GLvoid *Pointer;     /**< User-space address of mapping */
   GLintptr Offset;     /**< Mapped offset */
   GLsizeiptr Length;   /**< Mapped length */
};


d1402 1
a1402 1
   mtx_t Mutex;
a1404 1
   GLchar *Label;       /**< GL_KHR_debug */
a1405 1
   GLbitfield StorageFlags; /**< GL_MAP_PERSISTENT_BIT, etc. */
d1408 7
a1417 3
   GLboolean Immutable; /**< GL_ARB_buffer_storage */

   struct gl_buffer_mapping Mappings[MAP_COUNT];
d1462 2
a1463 32
 * Vertex attribute array as seen by the client.
 *
 * Contains the size, type, format and normalization flag,
 * along with the index of a vertex buffer binding point.
 *
 * Note that the Stride field corresponds to VERTEX_ATTRIB_ARRAY_STRIDE
 * and is only present for backwards compatibility reasons.
 * Rendering always uses VERTEX_BINDING_STRIDE.
 * The gl*Pointer() functions will set VERTEX_ATTRIB_ARRAY_STRIDE
 * and VERTEX_BINDING_STRIDE to the same value, while
 * glBindVertexBuffer() will only set VERTEX_BINDING_STRIDE.
 */
struct gl_vertex_attrib_array
{
   GLint Size;              /**< Components per element (1,2,3,4) */
   GLenum Type;             /**< Datatype: GL_FLOAT, GL_INT, etc */
   GLenum Format;           /**< Default: GL_RGBA, but may be GL_BGRA */
   GLsizei Stride;          /**< Stride as specified with gl*Pointer() */
   const GLubyte *Ptr;      /**< Points to client array data. Not used when a VBO is bound */
   GLintptr RelativeOffset; /**< Offset of the first element relative to the binding offset */
   GLboolean Enabled;       /**< Whether the array is enabled */
   GLboolean Normalized;    /**< Fixed-point values are normalized when converted to floats */
   GLboolean Integer;       /**< Fixed-point values are not converted to floats */
   GLuint _ElementSize;     /**< Size of each element in bytes */
   GLuint VertexBinding;    /**< Vertex buffer binding */
};


/**
 * This describes the buffer object used for a vertex array (or
 * multiple vertex arrays).  If BufferObj points to the default/null
 * buffer object, then the vertex array lives in user memory and not a VBO.
d1465 1
a1465 1
struct gl_vertex_buffer_binding
d1467 1
a1467 16
   GLintptr Offset;                    /**< User-specified offset */
   GLsizei Stride;                     /**< User-specified stride */
   GLuint InstanceDivisor;             /**< GL_ARB_instanced_arrays */
   struct gl_buffer_object *BufferObj; /**< GL_ARB_vertex_buffer_object */
   GLbitfield64 _BoundArrays;          /**< Arrays bound to this binding point */
};


/**
 * A representation of "Vertex Array Objects" (VAOs) from OpenGL 3.1+,
 * GL_ARB_vertex_array_object, or the original GL_APPLE_vertex_array_object
 * extension.
 */
struct gl_vertex_array_object
{
   /** Name of the VAO as received from glGenVertexArray. */
a1468 1
   GLchar *Label;       /**< GL_KHR_debug */
d1471 1
a1471 1
   mtx_t Mutex;
a1493 8
   /**
    * Derived vertex attribute arrays
    *
    * This is a legacy data structure created from gl_vertex_attrib_array and
    * gl_vertex_buffer_binding, for compatibility with existing driver code.
    */
   struct gl_client_array _VertexAttrib[VERT_ATTRIB_MAX];

d1495 1
a1495 4
   struct gl_vertex_attrib_array VertexAttrib[VERT_ATTRIB_MAX];

   /** Vertex buffer bindings */
   struct gl_vertex_buffer_binding VertexBinding[VERT_ATTRIB_MAX];
a1499 3
   /** Mask of VERT_BIT_* values indicating changed/dirty arrays */
   GLbitfield64 NewArrays;

d1506 1
a1506 2
   /** The index buffer (also known as the element array buffer in OpenGL). */
   struct gl_buffer_object *IndexBufferObj;
d1516 1
a1516 1
   struct gl_vertex_array_object *VAO;
d1519 1
a1519 1
   struct gl_vertex_array_object *DefaultVAO;
a1705 1
   GLchar *Label;     /**< GL_KHR_debug */
a1713 8
    * The shader program active when BeginTransformFeedback() was called.
    * When active and unpaused, this equals ctx->Shader.CurrentProgram[stage],
    * where stage is the pipeline stage that is the source of data for
    * transform feedback.
    */
   struct gl_shader_program *shader_program;

   /**
a1767 93
 * A "performance monitor" as described in AMD_performance_monitor.
 */
struct gl_perf_monitor_object
{
   GLuint Name;

   /** True if the monitor is currently active (Begin called but not End). */
   GLboolean Active;

   /**
    * True if the monitor has ended.
    *
    * This is distinct from !Active because it may never have began.
    */
   GLboolean Ended;

   /**
    * A list of groups with currently active counters.
    *
    * ActiveGroups[g] == n if there are n counters active from group 'g'.
    */
   unsigned *ActiveGroups;

   /**
    * An array of bitsets, subscripted by group ID, then indexed by counter ID.
    *
    * Checking whether counter 'c' in group 'g' is active can be done via:
    *
    *    BITSET_TEST(ActiveCounters[g], c)
    */
   GLuint **ActiveCounters;
};


union gl_perf_monitor_counter_value
{
   float f;
   uint64_t u64;
   uint32_t u32;
};


struct gl_perf_monitor_counter
{
   /** Human readable name for the counter. */
   const char *Name;

   /**
    * Data type of the counter.  Valid values are FLOAT, UNSIGNED_INT,
    * UNSIGNED_INT64_AMD, and PERCENTAGE_AMD.
    */
   GLenum Type;

   /** Minimum counter value. */
   union gl_perf_monitor_counter_value Minimum;

   /** Maximum counter value. */
   union gl_perf_monitor_counter_value Maximum;
};


struct gl_perf_monitor_group
{
   /** Human readable name for the group. */
   const char *Name;

   /**
    * Maximum number of counters in this group which can be active at the
    * same time.
    */
   GLuint MaxActiveCounters;

   /** Array of counters within this group. */
   const struct gl_perf_monitor_counter *Counters;
   GLuint NumCounters;
};


/**
 * Context state for AMD_performance_monitor.
 */
struct gl_perf_monitor_state
{
   /** Array of performance monitor groups (indexed by group ID) */
   const struct gl_perf_monitor_group *Groups;
   GLuint NumGroups;

   /** The table of all performance monitors. */
   struct _mesa_HashTable *Monitors;
};


/**
d1773 4
a1776 3
 * NOTE: PROGRAM_STATE_VAR, PROGRAM_CONSTANT, and PROGRAM_UNIFORM can all be
 * considered to be "uniform" variables since they can only be set outside
 * glBegin/End.  They're also all stored in the same Parameters array.
d1784 2
d1804 4
a1807 8
   SYSTEM_VALUE_FRONT_FACE,     /**< Fragment shader only (not done yet) */
   SYSTEM_VALUE_VERTEX_ID,      /**< Vertex shader only */
   SYSTEM_VALUE_INSTANCE_ID,    /**< Vertex shader only */
   SYSTEM_VALUE_SAMPLE_ID,      /**< Fragment shader only */
   SYSTEM_VALUE_SAMPLE_POS,     /**< Fragment shader only */
   SYSTEM_VALUE_SAMPLE_MASK_IN, /**< Fragment shader only */
   SYSTEM_VALUE_INVOCATION_ID,  /**< Geometry shader only */
   SYSTEM_VALUE_MAX             /**< Number of values */
d1854 1
a1854 1
   GLenum Target;    /**< GL_VERTEX/FRAGMENT_PROGRAM_ARB, GL_GEOMETRY_PROGRAM_NV */
a1867 8
   GLboolean UsesGather; /**< Does this program use gather4 at all? */

   /**
    * For vertex and geometry shaders, true if the program uses the
    * gl_ClipDistance output.  Ignored for fragment shaders.
    */
   GLboolean UsesClipDistanceOut;

d1871 2
a1872 9

   /**
    * Local parameters used by the program.
    *
    * It's dynamically allocated because it is rarely used (just
    * assembly-style programs), and MAX_PROGRAM_LOCAL_PARAMS entries once it's
    * allocated.
    */
   GLfloat (*LocalParams)[4];
d1912 1
a1920 1
   GLint VerticesIn;
a1921 1
   GLint Invocations;
a1924 1
   GLboolean UsesEndPrimitive;
a1949 18

   /**
    * Bitfield indicating, for each fragment shader input, 1 if that input
    * uses sample interpolation, 0 otherwise.  Unused inputs are 0.
    */
   GLbitfield64 IsSample;
};


/** Compute program object */
struct gl_compute_program
{
   struct gl_program Base;   /**< base class */

   /**
    * Size specified using local_size_{x,y,z}.
    */
   unsigned LocalSize[3];
a2106 1
   gl_shader_stage Stage;
a2107 1
   GLchar *Label;   /**< GL_KHR_debug */
d2160 2
a2161 1
    * These fields are only set post-linking.
d2169 4
a2172 4
   bool uses_builtin_functions;
   bool uses_gl_fragcoord;
   bool redeclares_gl_fragcoord;
   bool ARB_fragment_coord_conventions_enable;
a2173 5
   /**
    * Fragment shader state from GLSL 1.50 layout qualifiers.
    */
   bool origin_upper_left;
   bool pixel_center_integer;
d2175 14
a2188 60
   /**
    * Geometry shader state from GLSL 1.50 layout qualifiers.
    */
   struct {
      GLint VerticesOut;
      /**
       * 0 - Invocations count not declared in shader, or
       * 1 .. MAX_GEOMETRY_SHADER_INVOCATIONS
       */
      GLint Invocations;
      /**
       * GL_POINTS, GL_LINES, GL_LINES_ADJACENCY, GL_TRIANGLES, or
       * GL_TRIANGLES_ADJACENCY, or PRIM_UNKNOWN if it's not set in this
       * shader.
       */
      GLenum InputType;
       /**
        * GL_POINTS, GL_LINE_STRIP or GL_TRIANGLE_STRIP, or PRIM_UNKNOWN if
        * it's not set in this shader.
        */
      GLenum OutputType;
   } Geom;

   /**
    * Map from image uniform index to image unit (set by glUniform1i())
    *
    * An image uniform index is associated with each image uniform by
    * the linker.  The image index associated with each uniform is
    * stored in the \c gl_uniform_storage::image field.
    */
   GLubyte ImageUnits[MAX_IMAGE_UNIFORMS];

   /**
    * Access qualifier specified in the shader for each image uniform
    * index.  Either \c GL_READ_ONLY, \c GL_WRITE_ONLY or \c
    * GL_READ_WRITE.
    *
    * It may be different, though only more strict than the value of
    * \c gl_image_unit::Access for the corresponding image unit.
    */
   GLenum ImageAccess[MAX_IMAGE_UNIFORMS];

   /**
    * Number of image uniforms defined in the shader.  It specifies
    * the number of valid elements in the \c ImageUnits and \c
    * ImageAccess arrays above.
    */
   GLuint NumImages;

   /**
    * Compute shader state from ARB_compute_shader layout qualifiers.
    */
   struct {
      /**
       * Size specified using local_size_{x,y,z}, or all 0's to indicate that
       * it's not set in this shader.
       */
      unsigned LocalSize[3];
   } Comp;
};
a2251 19
/**
 * Structure that represents a reference to an atomic buffer from some
 * shader program.
 */
struct gl_active_atomic_buffer
{
   /** Uniform indices of the atomic counters declared within it. */
   GLuint *Uniforms;
   GLuint NumUniforms;

   /** Binding point index associated with it. */
   GLuint Binding;

   /** Minimum reasonable size it is expected to have. */
   GLuint MinimumSize;

   /** Shader stages making use of it. */
   GLboolean StageReferences[MESA_SHADER_STAGES];
};
a2260 1
   GLchar *Label;   /**< GL_KHR_debug */
d2270 7
a2276 2
    * Indicates whether program can be bound for individual pipeline stages
    * using UseProgramStages after it is next linked.
d2278 1
a2278 1
   GLboolean SeparateShader;
d2321 1
a2321 4
   /**
    * Geometry shader state - copied into gl_geometry_program by
    * _mesa_copy_linked_program_data().
    */
a2322 1
      GLint VerticesIn;
a2323 4
      /**
       * 1 .. MAX_GEOMETRY_SHADER_INVOCATIONS
       */
      GLint Invocations;
a2326 8
      /**
       * True if gl_ClipDistance is written to.  Copied into
       * gl_geometry_program by _mesa_copy_linked_program_data().
       */
      GLboolean UsesClipDistance;
      GLuint ClipDistanceArraySize; /**< Size of the gl_ClipDistance array, or
                                         0 if not present. */
      GLboolean UsesEndPrimitive;
d2329 1
a2329 1
   /** Vertex shader state */
d2331 1
a2331 5
      /**
       * True if gl_ClipDistance is written to.  Copied into gl_vertex_program
       * by _mesa_copy_linked_program_data().
       */
      GLboolean UsesClipDistance;
a2335 12
   /**
    * Compute shader state - copied into gl_compute_program by
    * _mesa_copy_linked_program_data().
    */
   struct {
      /**
       * If this shader contains a compute stage, size specified using
       * local_size_{x,y,z}.  Otherwise undefined.
       */
      unsigned LocalSize[3];
   } Comp;

d2340 2
a2341 7
   /**
    * Mapping from GL uniform locations returned by \c glUniformLocation to
    * UniformStorage entries. Arrays will have multiple contiguous slots
    * in the UniformRemapTable, all pointing to the same UniformStorage entry.
    */
   unsigned NumUniformRemapTable;
   struct gl_uniform_storage **UniformRemapTable;
d2344 11
a2354 2
    * Size of the gl_ClipDistance array that is output from the last pipeline
    * stage before the fragment shader.
d2356 1
a2356 4
   unsigned LastClipDistanceArraySize;

   struct gl_uniform_block *UniformBlocks;
   unsigned NumUniformBlocks;
d2365 1
a2365 1
   int *UniformBlockStageIndex[MESA_SHADER_STAGES];
a2376 3
   struct gl_active_atomic_buffer *AtomicBuffers;
   unsigned NumAtomicBuffers;

d2392 1
a2392 6
   struct gl_shader *_LinkedShaders[MESA_SHADER_STAGES];

   /* True if any of the fragment shaders attached to this program use:
    * #extension ARB_fragment_coord_conventions: enable
    */
   GLboolean ARB_fragment_coord_conventions_enable;
a2404 1
#define GLSL_DUMP_ON_ERROR 0x200 /**< Dump shaders to stderr on compile error */
a2408 1
 * Extended to support pipeline object
d2410 1
a2410 1
struct gl_pipeline_object
a2411 9
   /** Name of the pipeline object as received from glGenProgramPipelines.
    * It would be 0 for shaders without separate shader objects.
    */
   GLuint Name;

   GLint RefCount;

   mtx_t Mutex;

d2415 7
a2421 3
    * There is a separate program set for each shader stage.
    */
   struct gl_shader_program *CurrentProgram[MESA_SHADER_STAGES];
a2432 6

   GLboolean EverBound;                 /**< Has the pipeline object been created */

   GLboolean Validated;                 /**< Pipeline Validation status */

   GLchar *InfoLog;
a2434 14
/**
 * Context state for GLSL pipeline shaders.
 */
struct gl_pipeline_shader_state
{
   /** Currently bound pipeline object. See _mesa_BindProgramPipeline() */
   struct gl_pipeline_object *Current;

   /* Default Object to ensure that _Shader is never NULL */
   struct gl_pipeline_object *Default;

   /** Pipeline objects */
   struct _mesa_HashTable *Objects;
};
d2465 2
a2466 5
    * Optimize code for array of structures backends.
    *
    * This is a proxy for:
    *   - preferring DP4 instructions (rather than MUL/MAD) for
    *     matrix * vector operations, such as position transformation.
d2468 1
a2468 1
   GLboolean OptimizeForAOS;
a2480 1
   GLchar *Label;       /**< GL_KHR_debug */
a2515 1
   GLchar *Label;             /**< GL_KHR_debug */
d2531 1
a2531 1
   mtx_t Mutex;		   /**< for thread safety */
d2549 1
a2549 1
   mtx_t TexMutex;		/**< texobj thread safety */
a2583 11

   /**
    * Some context in this share group was affected by a GPU reset
    *
    * On the next call to \c glGetGraphicsResetStatus, contexts that have not
    * been affected by a GPU reset must also return
    * \c GL_INNOCENT_CONTEXT_RESET_ARB.
    *
    * Once this field becomes true, it is never reset to false.
    */
   bool ShareGroupReset;
d2595 1
a2595 1
   mtx_t Mutex; /**< for thread safety */
a2597 1
   GLchar *Label;         /**< GL_KHR_debug */
d2616 1
a2616 1
   mesa_format Format;      /**< The actual renderbuffer memory format */
d2672 1
a2672 1
   mtx_t Mutex;  /**< for thread safety */
a2680 1
   GLchar *Label;       /**< GL_KHR_debug */
d2732 1
a2732 6
   /**
    * The maximum number of layers in the framebuffer, or 0 if the framebuffer
    * is not layered.  For cube maps and cube map arrays, each cube face
    * counts as a layer.
    */
   GLuint MaxNumLayers;
a2777 24

   /**
    * \name Per-stage input / output limits
    *
    * Previous to OpenGL 3.2, the intrastage data limits were advertised with
    * a single value: GL_MAX_VARYING_COMPONENTS (GL_MAX_VARYING_VECTORS in
    * ES).  This is stored as \c gl_constants::MaxVarying.
    *
    * Starting with OpenGL 3.2, the limits are advertised with per-stage
    * variables.  Each stage as a certain number of outputs that it can feed
    * to the next stage and a certain number inputs that it can consume from
    * the previous stage.
    *
    * Vertex shader inputs do not participate this in this accounting.
    * These are tracked exclusively by \c gl_program_constants::MaxAttribs.
    *
    * Fragment shader outputs do not participate this in this accounting.
    * These are tracked exclusively by \c gl_constants::MaxDrawBuffers.
    */
   /*@@{*/
   GLuint MaxInputComponents;
   GLuint MaxOutputComponents;
   /*@@}*/

a2784 7

   /* GL_ARB_shader_atomic_counters */
   GLuint MaxAtomicBuffers;
   GLuint MaxAtomicCounters;

   /* GL_ARB_shader_image_load_store */
   GLuint MaxImageUniforms;
a2825 6
   GLuint MaxViewports;                      /**< GL_ARB_viewport_array */
   GLuint ViewportSubpixelBits;              /**< GL_ARB_viewport_array */
   struct {
      GLfloat Min;
      GLfloat Max;
   } ViewportBounds;                         /**< GL_ARB_viewport_array */
d2827 3
a2829 1
   struct gl_program_constants Program[MESA_SHADER_STAGES];
d2852 1
a2918 5
   /** GL_ARB_texture_gather */
   GLuint MinProgramTextureGatherOffset;
   GLuint MaxProgramTextureGatherOffset;
   GLuint MaxProgramTextureGatherComponents;

a2951 6
   /**
    * Always use the GetTransformFeedbackVertexCount() driver hook, rather
    * than passing the transform feedback object to the drawing function.
    */
   GLboolean AlwaysUseGetTransformFeedbackVertexCount;

a2986 27

   /** GL_ARB_shader_atomic_counters */
   GLuint MaxAtomicBufferBindings;
   GLuint MaxAtomicBufferSize;
   GLuint MaxCombinedAtomicBuffers;
   GLuint MaxCombinedAtomicCounters;

   /** GL_ARB_vertex_attrib_binding */
   GLint MaxVertexAttribRelativeOffset;
   GLint MaxVertexAttribBindings;

   /* GL_ARB_shader_image_load_store */
   GLuint MaxImageUnits;
   GLuint MaxCombinedImageUnitsAndFragmentOutputs;
   GLuint MaxImageSamples;
   GLuint MaxCombinedImageUniforms;

   /** GL_ARB_compute_shader */
   GLuint MaxComputeWorkGroupCount[3]; /* Array of x, y, z dimensions */
   GLuint MaxComputeWorkGroupSize[3]; /* Array of x, y, z dimensions */
   GLuint MaxComputeWorkGroupInvocations;

   /** GL_ARB_gpu_shader5 */
   GLfloat MinFragmentInterpolationOffset;
   GLfloat MaxFragmentInterpolationOffset;

   GLboolean FakeSWMSAA;
a3001 1
   GLboolean ARB_arrays_of_arrays;
a3003 1
   GLboolean ARB_buffer_storage;
a3004 1
   GLboolean ARB_compute_shader;
a3010 1
   GLboolean ARB_draw_indirect;
d3020 1
d3024 1
a3028 1
   GLboolean ARB_sample_shading;
a3029 1
   GLboolean ARB_shader_atomic_counters;
a3030 1
   GLboolean ARB_shader_image_load_store;
a3035 1
   GLboolean ARB_stencil_texturing;
a3047 2
   GLboolean ARB_texture_gather;
   GLboolean ARB_texture_mirror_clamp_to_edge;
a3049 2
   GLboolean ARB_texture_stencil8;
   GLboolean ARB_texture_query_levels;
a3052 1
   GLboolean ARB_texture_view;
a3059 1
   GLboolean ARB_vertex_type_10f_11f_11f_rev;
a3060 1
   GLboolean ARB_viewport_array;
d3067 1
d3073 1
d3078 1
a3078 1
   GLboolean EXT_shader_integer_mix;
a3097 1
   GLboolean AMD_performance_monitor;
a3106 1
   GLboolean INTEL_performance_query;
d3109 1
a3117 1
   GLboolean NV_vdpau_interop;
a3245 1
   GLchar *Label;     /**< GL_KHR_debug */
d3281 2
a3282 2
 * These are a mapping of the GL_ARB_debug_output/GL_KHR_debug enums
 * to small enums suitable for use as an array index.
a3301 3
   MESA_DEBUG_TYPE_MARKER,
   MESA_DEBUG_TYPE_PUSH_GROUP,
   MESA_DEBUG_TYPE_POP_GROUP,
a3308 1
   MESA_DEBUG_SEVERITY_NOTIFICATION,
d3315 36
a3379 3
   /** gl_context::TransformFeedback::CurrentObject::shader_program */
   GLbitfield NewTransformFeedbackProg;

a3387 10

   /**
    * gl_context::AtomicBufferBindings
    */
   GLbitfield NewAtomicBuffer;

   /**
    * gl_context::ImageUnits
    */
   GLbitfield NewImageUnits;
a3404 64
 * ARB_shader_image_load_store image unit.
 */
struct gl_image_unit
{
   /**
    * Texture object bound to this unit.
    */
   struct gl_texture_object *TexObj;

   /**
    * Level of the texture object bound to this unit.
    */
   GLuint Level;

   /**
    * \c GL_TRUE if the whole level is bound as an array of layers, \c
    * GL_FALSE if only some specific layer of the texture is bound.
    * \sa Layer
    */
   GLboolean Layered;

   /**
    * Layer of the texture object bound to this unit, or zero if the
    * whole level is bound.
    */
   GLuint Layer;

   /**
    * Access allowed to this texture image.  Either \c GL_READ_ONLY,
    * \c GL_WRITE_ONLY or \c GL_READ_WRITE.
    */
   GLenum Access;

   /**
    * GL internal format that determines the interpretation of the
    * image memory when shader image operations are performed through
    * this unit.
    */
   GLenum Format;

   /**
    * Mesa format corresponding to \c Format.
    */
   mesa_format _ActualFormat;

   /**
    * GL_TRUE if the state of this image unit is valid and access from
    * the shader is allowed.  Otherwise loads from this unit should
    * return zero and stores should have no effect.
    */
   GLboolean _Valid;
};

/**
 * Binding point for an atomic counter buffer object.
 */
struct gl_atomic_buffer_binding
{
   struct gl_buffer_object *BufferObject;
   GLintptr Offset;
   GLsizeiptr Size;
};

/**
d3411 2
d3516 1
a3516 1
   struct gl_viewport_attrib	ViewportArray[MAX_VIEWPORTS];	/**< Viewport attributes */
d3547 2
a3548 23
   struct gl_pipeline_shader_state Pipeline; /**< GLSL pipeline shader object state */
   struct gl_pipeline_object Shader; /**< GLSL shader object state */

   /**
    * Current active shader pipeline state
    *
    * Almost all internal users want ::_Shader instead of ::Shader.  The
    * exceptions are bits of legacy GLSL API that do not know about separate
    * shader objects.
    *
    * If a program is active via \c glUseProgram, this will point to
    * \c ::Shader.
    *
    * If a program pipeline is active via \c glBindProgramPipeline, this will
    * point to \c ::Pipeline.Current.
    *
    * If neither a program nor a program pipeline is active, this will point to
    * \c ::Pipeline.Default.  This ensures that \c ::_Shader will never be
    * \c NULL.
    */
   struct gl_pipeline_object *_Shader;

   struct gl_shader_compiler_options ShaderCompilerOptions[MESA_SHADER_STAGES];
a3553 4
   struct gl_perf_monitor_state PerfMonitor;

   struct gl_buffer_object *DrawIndirectBuffer; /** < GL_ARB_draw_indirect */

a3571 17
   /**
    * Object currently associated with the GL_ATOMIC_COUNTER_BUFFER
    * target.
    */
   struct gl_buffer_object *AtomicBuffer;

   /**
    * Array of atomic counter buffer binding points.
    */
   struct gl_atomic_buffer_binding
      AtomicBufferBindings[MAX_COMBINED_ATOMIC_BUFFERS];

   /**
    * Array of image units for ARB_shader_image_load_store.
    */
   struct gl_image_unit ImageUnits[MAX_IMAGE_UNITS];

d3581 3
d3590 2
a3591 2
   /* GL_ARB_debug_output/GL_KHR_debug */
   struct gl_debug_state *Debug;
a3618 6
   /**
    * False if this context was created without a config. This is needed
    * because the initial state of glDrawBuffers depends on this
    */
   GLboolean HasConfig;

d3635 1
a3635 1
   struct vbo_context *vbo_context;
a3638 16

   /**
    * \name NV_vdpau_interop
    */
   /*@@{*/
   const void *vdpDevice;
   const void *vdpGetProcAddress;
   struct set *vdpSurfaces;
   /*@@}*/

   /**
    * Has this context observed a GPU reset in any context in the share group?
    *
    * Once this field becomes true, it is never reset to false.
    */
   GLboolean ShareGroupReset;
@


1.1.1.7
log
@Import Mesa 10.4.3
@
text
@d1345 2
a1434 3
   /** GL_ARB_clip_control */
   GLenum ClipOrigin;     /**< GL_LOWER_LEFT or GL_UPPER_LEFT */
   GLenum ClipDepthMode;  /**< GL_NEGATIVE_ONE_TO_ONE or GL_ZERO_TO_ONE */
a1469 10
 * Usages we've seen for a buffer object.
 */
typedef enum {
   USAGE_UNIFORM_BUFFER = 0x1,
   USAGE_TEXTURE_BUFFER = 0x2,
   USAGE_ATOMIC_COUNTER_BUFFER = 0x4,
} gl_buffer_usage;


/**
a1485 1
   gl_buffer_usage UsageHistory; /**< How has this buffer been used so far? */
a1504 4
   GLint CompressedBlockWidth;   /**< GL_ARB_compressed_texture_pixel_storage */
   GLint CompressedBlockHeight;
   GLint CompressedBlockDepth;
   GLint CompressedBlockSize;
d1527 1
d1630 6
a1640 11
/** Used to signal when transitioning from one kind of drawing method
 * to another.
 */
typedef enum {
   DRAW_NONE,          /**< Initial value only */
   DRAW_BEGIN_END,
   DRAW_DISPLAY_LIST,
   DRAW_ARRAYS
} gl_draw_method;


a1679 6

   /** One of the DRAW_xxx flags, not consumed by drivers */
   gl_draw_method DrawMethod;

   /** Legal array datatypes */
   GLbitfield LegalTypesMask;
a1789 1
   unsigned StreamId;
d2034 7
a2040 107
   /**
    * \name Vertex shader system values
    */
   /*@@{*/
   /**
    * OpenGL-style vertex ID.
    *
    * Section 2.11.7 (Shader Execution), subsection Shader Inputs, of the
    * OpenGL 3.3 core profile spec says:
    *
    *     "gl_VertexID holds the integer index i implicitly passed by
    *     DrawArrays or one of the other drawing commands defined in section
    *     2.8.3."
    *
    * Section 2.8.3 (Drawing Commands) of the same spec says:
    *
    *     "The commands....are equivalent to the commands with the same base
    *     name (without the BaseVertex suffix), except that the ith element
    *     transferred by the corresponding draw call will be taken from
    *     element indices[i] + basevertex of each enabled array."
    *
    * Additionally, the overview in the GL_ARB_shader_draw_parameters spec
    * says:
    *
    *     "In unextended GL, vertex shaders have inputs named gl_VertexID and
    *     gl_InstanceID, which contain, respectively the index of the vertex
    *     and instance. The value of gl_VertexID is the implicitly passed
    *     index of the vertex being processed, which includes the value of
    *     baseVertex, for those commands that accept it."
    *
    * gl_VertexID gets basevertex added in.  This differs from DirectX where
    * SV_VertexID does \b not get basevertex added in.
    *
    * \note
    * If all system values are available, \c SYSTEM_VALUE_VERTEX_ID will be
    * equal to \c SYSTEM_VALUE_VERTEX_ID_ZERO_BASE plus
    * \c SYSTEM_VALUE_BASE_VERTEX.
    *
    * \sa SYSTEM_VALUE_VERTEX_ID_ZERO_BASE, SYSTEM_VALUE_BASE_VERTEX
    */
   SYSTEM_VALUE_VERTEX_ID,

   /**
    * Instanced ID as supplied to gl_InstanceID
    *
    * Values assigned to gl_InstanceID always begin with zero, regardless of
    * the value of baseinstance.
    *
    * Section 11.1.3.9 (Shader Inputs) of the OpenGL 4.4 core profile spec
    * says:
    *
    *     "gl_InstanceID holds the integer instance number of the current
    *     primitive in an instanced draw call (see section 10.5)."
    *
    * Through a big chain of pseudocode, section 10.5 describes that
    * baseinstance is not counted by gl_InstanceID.  In that section, notice
    *
    *     "If an enabled vertex attribute array is instanced (it has a
    *     non-zero divisor as specified by VertexAttribDivisor), the element
    *     index that is transferred to the GL, for all vertices, is given by
    *
    *         floor(instance/divisor) + baseinstance
    *
    *     If an array corresponding to an attribute required by a vertex
    *     shader is not enabled, then the corresponding element is taken from
    *     the current attribute state (see section 10.2)."
    *
    * Note that baseinstance is \b not included in the value of instance.
    */
   SYSTEM_VALUE_INSTANCE_ID,

   /**
    * DirectX-style vertex ID.
    *
    * Unlike \c SYSTEM_VALUE_VERTEX_ID, this system value does \b not include
    * the value of basevertex.
    *
    * \sa SYSTEM_VALUE_VERTEX_ID, SYSTEM_VALUE_BASE_VERTEX
    */
   SYSTEM_VALUE_VERTEX_ID_ZERO_BASE,

   /**
    * Value of \c basevertex passed to \c glDrawElementsBaseVertex and similar
    * functions.
    *
    * \sa SYSTEM_VALUE_VERTEX_ID, SYSTEM_VALUE_VERTEX_ID_ZERO_BASE
    */
   SYSTEM_VALUE_BASE_VERTEX,
   /*@@}*/

   /**
    * \name Geometry shader system values
    */
   /*@@{*/
   SYSTEM_VALUE_INVOCATION_ID,
   /*@@}*/

   /**
    * \name Fragment shader system values
    */
   /*@@{*/
   SYSTEM_VALUE_FRONT_FACE,     /**< (not done yet) */
   SYSTEM_VALUE_SAMPLE_ID,
   SYSTEM_VALUE_SAMPLE_POS,
   SYSTEM_VALUE_SAMPLE_MASK_IN,
   /*@@}*/

d2175 1
a2175 2
   bool UsesEndPrimitive;
   bool UsesStreams;
d2281 3
a2314 14
 * Context state for compute programs.
 */
struct gl_compute_program_state
{
   struct gl_compute_program *Current;  /**< user-bound compute program */

   /** Currently enabled and valid program (including internal programs
    * and compiled shader programs).
    */
   struct gl_compute_program *_Current;
};


/**
d2559 1
a2559 1
    * Minimum size (in bytes) of a buffer object to back this uniform buffer
d2642 1
a2642 1
    * For the current set of transform feedback varyings used for transform
d2678 1
a2678 2
      bool UsesEndPrimitive;
      bool UsesStreams;
a2705 1
   unsigned NumHiddenUniforms;
a2749 1
   GLboolean SamplersValidated; /**< Samplers validated against texture units? */
a2890 1
   GLuint Stream;      /**< The stream */
d2907 2
a2908 2
   struct gl_query_object *PrimitivesGenerated[MAX_VERTEX_STREAMS];
   struct gl_query_object *PrimitivesWritten[MAX_VERTEX_STREAMS];
d3301 3
a3321 5
   /**
    * GL_ARB_explicit_uniform_location
    */
   GLuint MaxUserAssignableUniformLocations;

d3326 1
a3326 1
   GLuint GLSLVersion;  /**< Desktop GLSL version supported (ex: 120 = 1.20) */
a3340 5
    * Allow GLSL #extension directives in the middle of shaders.
    */
   GLboolean AllowGLSLExtensionDirectiveMidShader;

   /**
a3346 9
    * Does VertexID count from zero or from base vertex?
    *
    * \note
    * If desktop GLSL 1.30 or GLSL ES 3.00 are not supported, this field is
    * ignored and need not be set.
    */
   bool VertexID_is_zero_based;

   /**
d3352 3
a3368 3
   /** OpenGL version 4.4 */
   GLuint MaxVertexAttribStride;

d3412 5
a3435 13
   /**
    * Should meaningful names be generated for compiler temporary variables?
    *
    * Generally, it is not useful to have the compiler generate "meaningful"
    * names for temporary variables that it creates.  This can, however, be a
    * useful debugging aid.  In Mesa debug builds or release builds when
    * MESA_GLSL is set at run-time, meaningful names will be generated.
    * Drivers can also force names to be generated by setting this field.
    * For example, the i965 driver may set it when INTEL_DEBUG=vs (to dump
    * vertex shader assembly) is set at run-time.
    */
   bool GenerateTemporaryNames;

a3457 32
   /**
    * GL_EXT_texture_multisample_blit_scaled implementation assumes that
    * samples are laid out in a rectangular grid roughly corresponding to
    * sample locations within a pixel. Below SampleMap{2,4,8}x variables
    * are used to map indices of rectangular grid to sample numbers within
    * a pixel. This mapping of indices to sample numbers must be initialized
    * by the driver for the target hardware. For example, if we have the 8X
    * MSAA sample number layout (sample positions) for XYZ hardware:
    *
    *        sample indices layout          sample number layout
    *            ---------                      ---------
    *            | 0 | 1 |                      | a | b |
    *            ---------                      ---------
    *            | 2 | 3 |                      | c | d |
    *            ---------                      ---------
    *            | 4 | 5 |                      | e | f |
    *            ---------                      ---------
    *            | 6 | 7 |                      | g | h |
    *            ---------                      ---------
    *
    * Where a,b,c,d,e,f,g,h are integers between [0-7].
    *
    * Then, initialize the SampleMap8x variable for XYZ hardware as shown
    * below:
    *    SampleMap8x = {a, b, c, d, e, f, g, h};
    *
    * Follow the logic for other sample counts.
    */
   uint8_t SampleMap2x[2];
   uint8_t SampleMap4x[4];
   uint8_t SampleMap8x[8];

a3483 5

   /** GL_KHR_context_flush_control */
   GLenum ContextReleaseBehavior;

   struct gl_shader_compiler_options ShaderCompilerOptions[MESA_SHADER_STAGES];
a3502 2
   GLboolean ARB_clear_texture;
   GLboolean ARB_clip_control;
a3504 1
   GLboolean ARB_conditional_render_inverted;
a3505 1
   GLboolean ARB_copy_image;
a3508 1
   GLboolean ARB_derivative_control;
a3513 1
   GLboolean ARB_fragment_layer_viewport;
a3518 1
   GLboolean ARB_explicit_uniform_location;
a3543 1
   GLboolean ARB_texture_compression_bptc;
a3608 1
   GLboolean AMD_vertex_shader_viewport_index;
d3610 1
d3854 1
a3854 1
   uint64_t NewArray;
d3857 1
a3857 1
   uint64_t NewTransformFeedback;
d3860 1
a3860 1
   uint64_t NewTransformFeedbackProg;
d3863 1
a3863 1
   uint64_t NewRasterizerDiscard;
d3869 1
a3869 3
   uint64_t NewUniformBuffer;

   uint64_t NewTextureBuffer;
d3874 1
a3874 1
   uint64_t NewAtomicBuffer;
d3879 1
a3879 1
   uint64_t NewImageUnits;
a4098 1
   struct gl_compute_program_state ComputeProgram;
d4123 2
a4183 1
   mtx_t DebugMutex;
d4188 1
a4188 1
   uint64_t NewDriverState;  /**< bitwise-or of flags from DriverFlags */
@


1.1.1.8
log
@Import Mesa 10.2.9
@
text
@a1344 2
   GLenum BumpTarget;
   GLfloat RotMatrix[4]; /* 2x2 matrix */
d1433 3
d1471 10
d1497 1
d1517 4
a1542 1
   GLuint _MaxElement;          /**< max element index into array buffer + 1 */
a1644 6
   /**
    * Min of all enabled arrays' _MaxElement.  When arrays reside inside VBOs
    * we can determine the max legal (in bounds) glDrawElements array index.
    */
   GLuint _MaxElement;

d1650 11
d1700 6
d1816 1
d2061 107
a2167 7
   SYSTEM_VALUE_FRONT_FACE,     /**< Fragment shader only (not done yet) */
   SYSTEM_VALUE_VERTEX_ID,      /**< Vertex shader only */
   SYSTEM_VALUE_INSTANCE_ID,    /**< Vertex shader only */
   SYSTEM_VALUE_SAMPLE_ID,      /**< Fragment shader only */
   SYSTEM_VALUE_SAMPLE_POS,     /**< Fragment shader only */
   SYSTEM_VALUE_SAMPLE_MASK_IN, /**< Fragment shader only */
   SYSTEM_VALUE_INVOCATION_ID,  /**< Geometry shader only */
d2302 2
a2303 1
   GLboolean UsesEndPrimitive;
a2408 3

   /** Cache of fixed-function programs */
   struct gl_program_cache *Cache;
d2440 14
d2698 1
a2698 1
    * Minimum size of a buffer object to back this uniform buffer
d2781 1
a2781 1
    * For the current set of transform feeedback varyings used for transform
d2817 2
a2818 1
      GLboolean UsesEndPrimitive;
d2846 1
d2891 1
d3033 1
d3050 2
a3051 2
   struct gl_query_object *PrimitivesGenerated;
   struct gl_query_object *PrimitivesWritten;
a3443 3
   /** vertex array / buffer object bounds checking */
   GLboolean CheckArrayBounds;

d3462 5
d3471 1
a3471 1
   GLuint GLSLVersion;  /**< GLSL version supported (ex: 120 = 1.20) */
d3486 5
d3497 9
a3510 3
   /** Which texture units support GL_ATI_envmap_bumpmap as targets */
   GLbitfield SupportedBumpUnits;

d3525 3
a3570 5
    * Force software support for primitive restart in the VBO module.
    */
   GLboolean PrimitiveRestartInSoftware;

   /**
d3590 13
d3625 32
d3683 5
d3707 2
d3711 1
d3713 1
d3717 1
d3723 1
d3729 1
d3755 1
d3821 1
a3822 1
   GLboolean ATI_envmap_bumpmap;
d4066 1
a4066 1
   GLbitfield NewArray;
d4069 1
a4069 1
   GLbitfield NewTransformFeedback;
d4072 1
a4072 1
   GLbitfield NewTransformFeedbackProg;
d4075 1
a4075 1
   GLbitfield NewRasterizerDiscard;
d4081 3
a4083 1
   GLbitfield NewUniformBuffer;
d4088 1
a4088 1
   GLbitfield NewAtomicBuffer;
d4093 1
a4093 1
   GLbitfield NewImageUnits;
d4313 1
a4337 2
   struct gl_shader_compiler_options ShaderCompilerOptions[MESA_SHADER_STAGES];

d4397 1
d4402 1
a4402 1
   GLbitfield NewDriverState;/**< bitwise-or of flags from DriverFlags */
@


