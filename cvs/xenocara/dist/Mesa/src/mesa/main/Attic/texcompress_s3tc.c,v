head	1.11;
access;
symbols
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	v10_2_9:1.1.1.8
	v10_4_3:1.1.1.7
	v10_2_7:1.1.1.6
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	v10_2_3:1.1.1.6
	OPENBSD_5_5:1.7.0.2
	OPENBSD_5_5_BASE:1.7
	v9_2_5:1.1.1.5
	v9_2_3:1.1.1.5
	v9_2_2:1.1.1.5
	v9_2_1:1.1.1.5
	v9_2_0:1.1.1.5
	OPENBSD_5_4:1.6.0.4
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.3.0.4
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2015.12.23.05.17.53;	author jsg;	state dead;
branches;
next	1.10;
commitid	TnlogFl9nOv2eaRf;

1.10
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.9;
commitid	4ry2gvZGMXkCUD2n;

1.9
date	2015.01.25.14.41.22;	author jsg;	state Exp;
branches;
next	1.8;
commitid	mcxB0JvoI9gTDYXU;

1.8
date	2014.07.09.21.09.00;	author jsg;	state Exp;
branches;
next	1.7;
commitid	WPD6rgPryPkvXOr9;

1.7
date	2013.09.05.14.06.30;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2012.08.17.13.58.19;	author mpi;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.23.13.37.42;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.31;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.41;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.21;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.50.20;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.50.20;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.56.39;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.31.21;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.47;	author matthieu;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.09.05.13.16.52;	author jsg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.07.09.20.35.05;	author jsg;	state Exp;
branches;
next	1.1.1.7;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.7
date	2015.01.25.14.12.57;	author jsg;	state Exp;
branches;
next	1.1.1.8;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.8
date	2015.02.20.22.50.03;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.11
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
 * Copyright (c) 2008 VMware, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */


/**
 * \file texcompress_s3tc.c
 * GL_EXT_texture_compression_s3tc support.
 */

#ifndef USE_EXTERNAL_DXTN_LIB
#define USE_EXTERNAL_DXTN_LIB 1
#endif

#include "glheader.h"
#include "imports.h"
#include "colormac.h"
#include "dlopen.h"
#include "image.h"
#include "macros.h"
#include "mtypes.h"
#include "texcompress.h"
#include "texcompress_s3tc.h"
#include "texstore.h"
#include "format_unpack.h"


#if defined(_WIN32) || defined(WIN32)
#define DXTN_LIBNAME "dxtn.dll"
#define RTLD_LAZY 0
#define RTLD_GLOBAL 0
#elif defined(__DJGPP__)
#define DXTN_LIBNAME "dxtn.dxe"
#else
#define DXTN_LIBNAME "libtxc_dxtn.so"
#endif

typedef void (*dxtFetchTexelFuncExt)( GLint srcRowstride, const GLubyte *pixdata, GLint col, GLint row, GLvoid *texelOut );

static dxtFetchTexelFuncExt fetch_ext_rgb_dxt1 = NULL;
static dxtFetchTexelFuncExt fetch_ext_rgba_dxt1 = NULL;
static dxtFetchTexelFuncExt fetch_ext_rgba_dxt3 = NULL;
static dxtFetchTexelFuncExt fetch_ext_rgba_dxt5 = NULL;

typedef void (*dxtCompressTexFuncExt)(GLint srccomps, GLint width,
                                      GLint height, const GLubyte *srcPixData,
                                      GLenum destformat, GLubyte *dest,
                                      GLint dstRowStride);

static dxtCompressTexFuncExt ext_tx_compress_dxtn = NULL;

static void *dxtlibhandle = NULL;


void
_mesa_init_texture_s3tc( struct gl_context *ctx )
{
   /* called during context initialization */
   ctx->Mesa_DXTn = GL_FALSE;
#if USE_EXTERNAL_DXTN_LIB
   if (!dxtlibhandle) {
      dxtlibhandle = _mesa_dlopen(DXTN_LIBNAME, 0);
      if (!dxtlibhandle) {
	 _mesa_warning(ctx, "couldn't open " DXTN_LIBNAME ", software DXTn "
	    "compression/decompression unavailable");
      }
      else {
         /* the fetch functions are not per context! Might be problematic... */
         fetch_ext_rgb_dxt1 = (dxtFetchTexelFuncExt)
            _mesa_dlsym(dxtlibhandle, "fetch_2d_texel_rgb_dxt1");
         fetch_ext_rgba_dxt1 = (dxtFetchTexelFuncExt)
            _mesa_dlsym(dxtlibhandle, "fetch_2d_texel_rgba_dxt1");
         fetch_ext_rgba_dxt3 = (dxtFetchTexelFuncExt)
            _mesa_dlsym(dxtlibhandle, "fetch_2d_texel_rgba_dxt3");
         fetch_ext_rgba_dxt5 = (dxtFetchTexelFuncExt)
            _mesa_dlsym(dxtlibhandle, "fetch_2d_texel_rgba_dxt5");
         ext_tx_compress_dxtn = (dxtCompressTexFuncExt)
            _mesa_dlsym(dxtlibhandle, "tx_compress_dxtn");

         if (!fetch_ext_rgb_dxt1 ||
             !fetch_ext_rgba_dxt1 ||
             !fetch_ext_rgba_dxt3 ||
             !fetch_ext_rgba_dxt5 ||
             !ext_tx_compress_dxtn) {
	    _mesa_warning(ctx, "couldn't reference all symbols in "
	       DXTN_LIBNAME ", software DXTn compression/decompression "
	       "unavailable");
            fetch_ext_rgb_dxt1 = NULL;
            fetch_ext_rgba_dxt1 = NULL;
            fetch_ext_rgba_dxt3 = NULL;
            fetch_ext_rgba_dxt5 = NULL;
            ext_tx_compress_dxtn = NULL;
            _mesa_dlclose(dxtlibhandle);
            dxtlibhandle = NULL;
         }
      }
   }
   if (dxtlibhandle) {
      ctx->Mesa_DXTn = GL_TRUE;
   }
#else
   (void) ctx;
#endif
}

/**
 * Store user's image in rgb_dxt1 format.
 */
GLboolean
_mesa_texstore_rgb_dxt1(TEXSTORE_PARAMS)
{
   const GLubyte *pixels;
   GLubyte *dst;
   const GLubyte *tempImage = NULL;

   ASSERT(dstFormat == MESA_FORMAT_RGB_DXT1 ||
          dstFormat == MESA_FORMAT_SRGB_DXT1);

   if (srcFormat != GL_RGB ||
       srcType != GL_UNSIGNED_BYTE ||
       ctx->_ImageTransferState ||
       srcPacking->RowLength != srcWidth ||
       srcPacking->SwapBytes) {
      /* convert image to RGB/GLubyte */
      tempImage = _mesa_make_temp_ubyte_image(ctx, dims,
                                             baseInternalFormat,
                                             _mesa_get_format_base_format(dstFormat),
                                             srcWidth, srcHeight, srcDepth,
                                             srcFormat, srcType, srcAddr,
                                             srcPacking);
      if (!tempImage)
         return GL_FALSE; /* out of memory */
      pixels = tempImage;
      srcFormat = GL_RGB;
   }
   else {
      pixels = _mesa_image_address2d(srcPacking, srcAddr, srcWidth, srcHeight,
                                     srcFormat, srcType, 0, 0);
   }

   dst = dstSlices[0];

   if (ext_tx_compress_dxtn) {
      (*ext_tx_compress_dxtn)(3, srcWidth, srcHeight, pixels,
                              GL_COMPRESSED_RGB_S3TC_DXT1_EXT,
                              dst, dstRowStride);
   }
   else {
      _mesa_warning(ctx, "external dxt library not available: texstore_rgb_dxt1");
   }

   free((void *) tempImage);

   return GL_TRUE;
}


/**
 * Store user's image in rgba_dxt1 format.
 */
GLboolean
_mesa_texstore_rgba_dxt1(TEXSTORE_PARAMS)
{
   const GLubyte *pixels;
   GLubyte *dst;
   const GLubyte *tempImage = NULL;

   ASSERT(dstFormat == MESA_FORMAT_RGBA_DXT1 ||
          dstFormat == MESA_FORMAT_SRGBA_DXT1);

   if (srcFormat != GL_RGBA ||
       srcType != GL_UNSIGNED_BYTE ||
       ctx->_ImageTransferState ||
       srcPacking->RowLength != srcWidth ||
       srcPacking->SwapBytes) {
      /* convert image to RGBA/GLubyte */
      tempImage = _mesa_make_temp_ubyte_image(ctx, dims,
                                             baseInternalFormat,
                                             _mesa_get_format_base_format(dstFormat),
                                             srcWidth, srcHeight, srcDepth,
                                             srcFormat, srcType, srcAddr,
                                             srcPacking);
      if (!tempImage)
         return GL_FALSE; /* out of memory */
      pixels = tempImage;
      srcFormat = GL_RGBA;
   }
   else {
      pixels = _mesa_image_address2d(srcPacking, srcAddr, srcWidth, srcHeight,
                                     srcFormat, srcType, 0, 0);
   }

   dst = dstSlices[0];

   if (ext_tx_compress_dxtn) {
      (*ext_tx_compress_dxtn)(4, srcWidth, srcHeight, pixels,
                              GL_COMPRESSED_RGBA_S3TC_DXT1_EXT,
                              dst, dstRowStride);
   }
   else {
      _mesa_warning(ctx, "external dxt library not available: texstore_rgba_dxt1");
   }

   free((void*) tempImage);

   return GL_TRUE;
}


/**
 * Store user's image in rgba_dxt3 format.
 */
GLboolean
_mesa_texstore_rgba_dxt3(TEXSTORE_PARAMS)
{
   const GLubyte *pixels;
   GLubyte *dst;
   const GLubyte *tempImage = NULL;

   ASSERT(dstFormat == MESA_FORMAT_RGBA_DXT3 ||
          dstFormat == MESA_FORMAT_SRGBA_DXT3);

   if (srcFormat != GL_RGBA ||
       srcType != GL_UNSIGNED_BYTE ||
       ctx->_ImageTransferState ||
       srcPacking->RowLength != srcWidth ||
       srcPacking->SwapBytes) {
      /* convert image to RGBA/GLubyte */
      tempImage = _mesa_make_temp_ubyte_image(ctx, dims,
                                             baseInternalFormat,
                                             _mesa_get_format_base_format(dstFormat),
                                             srcWidth, srcHeight, srcDepth,
                                             srcFormat, srcType, srcAddr,
                                             srcPacking);
      if (!tempImage)
         return GL_FALSE; /* out of memory */
      pixels = tempImage;
   }
   else {
      pixels = _mesa_image_address2d(srcPacking, srcAddr, srcWidth, srcHeight,
                                     srcFormat, srcType, 0, 0);
   }

   dst = dstSlices[0];

   if (ext_tx_compress_dxtn) {
      (*ext_tx_compress_dxtn)(4, srcWidth, srcHeight, pixels,
                              GL_COMPRESSED_RGBA_S3TC_DXT3_EXT,
                              dst, dstRowStride);
   }
   else {
      _mesa_warning(ctx, "external dxt library not available: texstore_rgba_dxt3");
   }

   free((void *) tempImage);

   return GL_TRUE;
}


/**
 * Store user's image in rgba_dxt5 format.
 */
GLboolean
_mesa_texstore_rgba_dxt5(TEXSTORE_PARAMS)
{
   const GLubyte *pixels;
   GLubyte *dst;
   const GLubyte *tempImage = NULL;

   ASSERT(dstFormat == MESA_FORMAT_RGBA_DXT5 ||
          dstFormat == MESA_FORMAT_SRGBA_DXT5);

   if (srcFormat != GL_RGBA ||
       srcType != GL_UNSIGNED_BYTE ||
       ctx->_ImageTransferState ||
       srcPacking->RowLength != srcWidth ||
       srcPacking->SwapBytes) {
      /* convert image to RGBA/GLubyte */
      tempImage = _mesa_make_temp_ubyte_image(ctx, dims,
                                             baseInternalFormat,
                                   	     _mesa_get_format_base_format(dstFormat),
                                             srcWidth, srcHeight, srcDepth,
                                             srcFormat, srcType, srcAddr,
                                             srcPacking);
      if (!tempImage)
         return GL_FALSE; /* out of memory */
      pixels = tempImage;
   }
   else {
      pixels = _mesa_image_address2d(srcPacking, srcAddr, srcWidth, srcHeight,
                                     srcFormat, srcType, 0, 0);
   }

   dst = dstSlices[0];

   if (ext_tx_compress_dxtn) {
      (*ext_tx_compress_dxtn)(4, srcWidth, srcHeight, pixels,
                              GL_COMPRESSED_RGBA_S3TC_DXT5_EXT,
                              dst, dstRowStride);
   }
   else {
      _mesa_warning(ctx, "external dxt library not available: texstore_rgba_dxt5");
   }

   free((void *) tempImage);

   return GL_TRUE;
}


/** Report problem with dxt texture decompression, once */
static void
problem(const char *func)
{
   static GLboolean warned = GL_FALSE;
   if (!warned) {
      _mesa_debug(NULL, "attempted to decode DXT texture without "
                  "library available: %s\n", func);
      warned = GL_TRUE;
   }
}


static void
fetch_rgb_dxt1(const GLubyte *map,
               GLint rowStride, GLint i, GLint j, GLfloat *texel)
{
   if (fetch_ext_rgb_dxt1) {
      GLubyte tex[4];
      fetch_ext_rgb_dxt1(rowStride, map, i, j, tex);
      texel[RCOMP] = UBYTE_TO_FLOAT(tex[RCOMP]);
      texel[GCOMP] = UBYTE_TO_FLOAT(tex[GCOMP]);
      texel[BCOMP] = UBYTE_TO_FLOAT(tex[BCOMP]);
      texel[ACOMP] = UBYTE_TO_FLOAT(tex[ACOMP]);
   }
   else {
      problem("rgb_dxt1");
   }
}

static void
fetch_rgba_dxt1(const GLubyte *map,
                GLint rowStride, GLint i, GLint j, GLfloat *texel)
{
   if (fetch_ext_rgba_dxt1) {
      GLubyte tex[4];
      fetch_ext_rgba_dxt1(rowStride, map, i, j, tex);
      texel[RCOMP] = UBYTE_TO_FLOAT(tex[RCOMP]);
      texel[GCOMP] = UBYTE_TO_FLOAT(tex[GCOMP]);
      texel[BCOMP] = UBYTE_TO_FLOAT(tex[BCOMP]);
      texel[ACOMP] = UBYTE_TO_FLOAT(tex[ACOMP]);
   }
   else {
      problem("rgba_dxt1");
   }
}

static void
fetch_rgba_dxt3(const GLubyte *map,
                GLint rowStride, GLint i, GLint j, GLfloat *texel)
{
   if (fetch_ext_rgba_dxt3) {
      GLubyte tex[4];
      fetch_ext_rgba_dxt3(rowStride, map, i, j, tex);
      texel[RCOMP] = UBYTE_TO_FLOAT(tex[RCOMP]);
      texel[GCOMP] = UBYTE_TO_FLOAT(tex[GCOMP]);
      texel[BCOMP] = UBYTE_TO_FLOAT(tex[BCOMP]);
      texel[ACOMP] = UBYTE_TO_FLOAT(tex[ACOMP]);
   }
   else {
      problem("rgba_dxt3");
   }
}

static void
fetch_rgba_dxt5(const GLubyte *map,
                GLint rowStride, GLint i, GLint j, GLfloat *texel)
{
   if (fetch_ext_rgba_dxt5) {
      GLubyte tex[4];
      fetch_ext_rgba_dxt5(rowStride, map, i, j, tex);
      texel[RCOMP] = UBYTE_TO_FLOAT(tex[RCOMP]);
      texel[GCOMP] = UBYTE_TO_FLOAT(tex[GCOMP]);
      texel[BCOMP] = UBYTE_TO_FLOAT(tex[BCOMP]);
      texel[ACOMP] = UBYTE_TO_FLOAT(tex[ACOMP]);
   }
   else {
      problem("rgba_dxt5");
   }
}


static void
fetch_srgb_dxt1(const GLubyte *map,
                GLint rowStride, GLint i, GLint j, GLfloat *texel)
{
   if (fetch_ext_rgb_dxt1) {
      GLubyte tex[4];
      fetch_ext_rgb_dxt1(rowStride, map, i, j, tex);
      texel[RCOMP] = _mesa_nonlinear_to_linear(tex[RCOMP]);
      texel[GCOMP] = _mesa_nonlinear_to_linear(tex[GCOMP]);
      texel[BCOMP] = _mesa_nonlinear_to_linear(tex[BCOMP]);
      texel[ACOMP] = UBYTE_TO_FLOAT(tex[ACOMP]);
   }
   else {
      problem("srgb_dxt1");
   }
}

static void
fetch_srgba_dxt1(const GLubyte *map,
                 GLint rowStride, GLint i, GLint j, GLfloat *texel)
{
   if (fetch_ext_rgba_dxt1) {
      GLubyte tex[4];
      fetch_ext_rgba_dxt1(rowStride, map, i, j, tex);
      texel[RCOMP] = _mesa_nonlinear_to_linear(tex[RCOMP]);
      texel[GCOMP] = _mesa_nonlinear_to_linear(tex[GCOMP]);
      texel[BCOMP] = _mesa_nonlinear_to_linear(tex[BCOMP]);
      texel[ACOMP] = UBYTE_TO_FLOAT(tex[ACOMP]);
   }
   else {
      problem("srgba_dxt1");
   }
}

static void
fetch_srgba_dxt3(const GLubyte *map,
                 GLint rowStride, GLint i, GLint j, GLfloat *texel)
{
   if (fetch_ext_rgba_dxt3) {
      GLubyte tex[4];
      fetch_ext_rgba_dxt3(rowStride, map, i, j, tex);
      texel[RCOMP] = _mesa_nonlinear_to_linear(tex[RCOMP]);
      texel[GCOMP] = _mesa_nonlinear_to_linear(tex[GCOMP]);
      texel[BCOMP] = _mesa_nonlinear_to_linear(tex[BCOMP]);
      texel[ACOMP] = UBYTE_TO_FLOAT(tex[ACOMP]);
   }
   else {
      problem("srgba_dxt3");
   }
}

static void
fetch_srgba_dxt5(const GLubyte *map,
                 GLint rowStride, GLint i, GLint j, GLfloat *texel)
{
   if (fetch_ext_rgba_dxt5) {
      GLubyte tex[4];
      fetch_ext_rgba_dxt5(rowStride, map, i, j, tex);
      texel[RCOMP] = _mesa_nonlinear_to_linear(tex[RCOMP]);
      texel[GCOMP] = _mesa_nonlinear_to_linear(tex[GCOMP]);
      texel[BCOMP] = _mesa_nonlinear_to_linear(tex[BCOMP]);
      texel[ACOMP] = UBYTE_TO_FLOAT(tex[ACOMP]);
   }
   else {
      problem("srgba_dxt5");
   }
}



compressed_fetch_func
_mesa_get_dxt_fetch_func(mesa_format format)
{
   switch (format) {
   case MESA_FORMAT_RGB_DXT1:
      return fetch_rgb_dxt1;
   case MESA_FORMAT_RGBA_DXT1:
      return fetch_rgba_dxt1;
   case MESA_FORMAT_RGBA_DXT3:
      return fetch_rgba_dxt3;
   case MESA_FORMAT_RGBA_DXT5:
      return fetch_rgba_dxt5;
   case MESA_FORMAT_SRGB_DXT1:
      return fetch_srgb_dxt1;
   case MESA_FORMAT_SRGBA_DXT1:
      return fetch_srgba_dxt1;
   case MESA_FORMAT_SRGBA_DXT3:
      return fetch_srgba_dxt3;
   case MESA_FORMAT_SRGBA_DXT5:
      return fetch_srgba_dxt5;
   default:
      return NULL;
   }
}
@


1.10
log
@Merge Mesa 10.2.9
@
text
@@


1.9
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a46 1
#include "util/format_srgb.h"
d53 2
d422 3
a424 3
      texel[RCOMP] = util_format_srgb_8unorm_to_linear_float(tex[RCOMP]);
      texel[GCOMP] = util_format_srgb_8unorm_to_linear_float(tex[GCOMP]);
      texel[BCOMP] = util_format_srgb_8unorm_to_linear_float(tex[BCOMP]);
d439 3
a441 3
      texel[RCOMP] = util_format_srgb_8unorm_to_linear_float(tex[RCOMP]);
      texel[GCOMP] = util_format_srgb_8unorm_to_linear_float(tex[GCOMP]);
      texel[BCOMP] = util_format_srgb_8unorm_to_linear_float(tex[BCOMP]);
d456 3
a458 3
      texel[RCOMP] = util_format_srgb_8unorm_to_linear_float(tex[RCOMP]);
      texel[GCOMP] = util_format_srgb_8unorm_to_linear_float(tex[GCOMP]);
      texel[BCOMP] = util_format_srgb_8unorm_to_linear_float(tex[BCOMP]);
d473 3
a475 3
      texel[RCOMP] = util_format_srgb_8unorm_to_linear_float(tex[RCOMP]);
      texel[GCOMP] = util_format_srgb_8unorm_to_linear_float(tex[GCOMP]);
      texel[BCOMP] = util_format_srgb_8unorm_to_linear_float(tex[BCOMP]);
@


1.8
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d47 1
a53 2
#elif defined(__DJGPP__)
#define DXTN_LIBNAME "dxtn.dxe"
d421 3
a423 3
      texel[RCOMP] = _mesa_nonlinear_to_linear(tex[RCOMP]);
      texel[GCOMP] = _mesa_nonlinear_to_linear(tex[GCOMP]);
      texel[BCOMP] = _mesa_nonlinear_to_linear(tex[BCOMP]);
d438 3
a440 3
      texel[RCOMP] = _mesa_nonlinear_to_linear(tex[RCOMP]);
      texel[GCOMP] = _mesa_nonlinear_to_linear(tex[GCOMP]);
      texel[BCOMP] = _mesa_nonlinear_to_linear(tex[BCOMP]);
d455 3
a457 3
      texel[RCOMP] = _mesa_nonlinear_to_linear(tex[RCOMP]);
      texel[GCOMP] = _mesa_nonlinear_to_linear(tex[GCOMP]);
      texel[BCOMP] = _mesa_nonlinear_to_linear(tex[BCOMP]);
d472 3
a474 3
      texel[RCOMP] = _mesa_nonlinear_to_linear(tex[RCOMP]);
      texel[GCOMP] = _mesa_nonlinear_to_linear(tex[GCOMP]);
      texel[BCOMP] = _mesa_nonlinear_to_linear(tex[BCOMP]);
@


1.7
log
@Merge Mesa 9.2.0
@
text
@d486 1
a486 1
_mesa_get_dxt_fetch_func(gl_format format)
@


1.6
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a2 1
 * Version:  6.5.3
d20 4
a23 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
a41 1
#include "mfeatures.h"
d46 1
a46 3


#if FEATURE_texture_s3tc
d59 1
a59 30
#if FEATURE_EXT_texture_sRGB
/**
 * Convert an 8-bit sRGB value from non-linear space to a
 * linear RGB value in [0, 1].
 * Implemented with a 256-entry lookup table.
 */
static INLINE GLfloat
nonlinear_to_linear(GLubyte cs8)
{
   static GLfloat table[256];
   static GLboolean tableReady = GL_FALSE;
   if (!tableReady) {
      /* compute lookup table now */
      GLuint i;
      for (i = 0; i < 256; i++) {
         const GLfloat cs = UBYTE_TO_FLOAT(i);
         if (cs <= 0.04045) {
            table[i] = cs / 12.92f;
         }
         else {
            table[i] = (GLfloat) pow((cs + 0.055) / 1.055, 2.4);
         }
      }
      tableReady = GL_TRUE;
   }
   return table[cs8];
}
#endif /* FEATURE_EXT_texture_sRGB */

typedef void (*dxtFetchTexelFuncExt)( GLint srcRowstride, GLubyte *pixdata, GLint col, GLint row, GLvoid *texelOut );
d61 4
a64 4
dxtFetchTexelFuncExt fetch_ext_rgb_dxt1 = NULL;
dxtFetchTexelFuncExt fetch_ext_rgba_dxt1 = NULL;
dxtFetchTexelFuncExt fetch_ext_rgba_dxt3 = NULL;
dxtFetchTexelFuncExt fetch_ext_rgba_dxt5 = NULL;
d67 1
a67 1
                                      GLint height, const GLchan *srcPixData,
d133 1
a133 1
   const GLchan *pixels;
d135 1
a135 2
   const GLint texWidth = dstRowStride * 4 / 8; /* a bit of a hack */
   const GLchan *tempImage = NULL;
a138 5
   ASSERT(dstXoffset % 4 == 0);
   ASSERT(dstYoffset % 4 == 0);
   ASSERT(dstZoffset % 4 == 0);
   (void) dstZoffset;
   (void) dstImageOffsets;
d141 1
a141 1
       srcType != CHAN_TYPE ||
d143 1
d145 2
a146 2
      /* convert image to RGB/GLchan */
      tempImage = _mesa_make_temp_chan_image(ctx, dims,
d158 2
a159 1
      pixels = (const GLchan *) srcAddr;
d162 1
a162 3
   dst = _mesa_compressed_image_address(dstXoffset, dstYoffset, 0,
                                        dstFormat,
                                        texWidth, (GLubyte *) dstAddr);
d173 1
a173 2
   if (tempImage)
      free((void *) tempImage);
d185 1
a185 1
   const GLchan *pixels;
d187 1
a187 2
   const GLint texWidth = dstRowStride * 4 / 8; /* a bit of a hack */
   const GLchan *tempImage = NULL;
a190 5
   ASSERT(dstXoffset % 4 == 0);
   ASSERT(dstYoffset % 4 == 0);
   ASSERT(dstZoffset % 4 == 0);
   (void) dstZoffset;
   (void) dstImageOffsets;
d193 1
a193 1
       srcType != CHAN_TYPE ||
d195 1
d197 2
a198 2
      /* convert image to RGBA/GLchan */
      tempImage = _mesa_make_temp_chan_image(ctx, dims,
d210 2
a211 1
      pixels = (const GLchan *) srcAddr;
d214 2
a215 3
   dst = _mesa_compressed_image_address(dstXoffset, dstYoffset, 0,
                                        dstFormat,
                                        texWidth, (GLubyte *) dstAddr);
d225 1
a225 2
   if (tempImage)
      free((void*) tempImage);
d237 1
a237 1
   const GLchan *pixels;
d239 1
a239 2
   const GLint texWidth = dstRowStride * 4 / 16; /* a bit of a hack */
   const GLchan *tempImage = NULL;
a242 5
   ASSERT(dstXoffset % 4 == 0);
   ASSERT(dstYoffset % 4 == 0);
   ASSERT(dstZoffset % 4 == 0);
   (void) dstZoffset;
   (void) dstImageOffsets;
d245 1
a245 1
       srcType != CHAN_TYPE ||
d247 1
d249 2
a250 2
      /* convert image to RGBA/GLchan */
      tempImage = _mesa_make_temp_chan_image(ctx, dims,
d261 2
a262 1
      pixels = (const GLchan *) srcAddr;
d265 2
a266 3
   dst = _mesa_compressed_image_address(dstXoffset, dstYoffset, 0,
                                        dstFormat,
                                        texWidth, (GLubyte *) dstAddr);
d276 1
a276 2
   if (tempImage)
      free((void *) tempImage);
d288 1
a288 1
   const GLchan *pixels;
d290 1
a290 2
   const GLint texWidth = dstRowStride * 4 / 16; /* a bit of a hack */
   const GLchan *tempImage = NULL;
a293 5
   ASSERT(dstXoffset % 4 == 0);
   ASSERT(dstYoffset % 4 == 0);
   ASSERT(dstZoffset % 4 == 0);
   (void) dstZoffset;
   (void) dstImageOffsets;
d296 1
a296 1
       srcType != CHAN_TYPE ||
d298 1
d300 2
a301 2
      /* convert image to RGBA/GLchan */
      tempImage = _mesa_make_temp_chan_image(ctx, dims,
d312 2
a313 1
      pixels = (const GLchan *) srcAddr;
d316 2
a317 3
   dst = _mesa_compressed_image_address(dstXoffset, dstYoffset, 0,
                                        dstFormat,
                                        texWidth, (GLubyte *) dstAddr);
d327 1
a327 2
   if (tempImage)
      free((void *) tempImage);
d333 1
d335 1
a335 2
fetch_texel_2d_rgb_dxt1( const struct gl_texture_image *texImage,
                         GLint i, GLint j, GLint k, GLchan *texel )
d337 5
a341 5
   (void) k;
   if (fetch_ext_rgb_dxt1) {
      ASSERT (sizeof(GLchan) == sizeof(GLubyte));
      fetch_ext_rgb_dxt1(texImage->RowStride,
                         (GLubyte *)(texImage)->Data, i, j, texel);
a342 2
   else
      _mesa_debug(NULL, "attempted to decode s3tc texture without library available: fetch_texel_2d_rgb_dxt1");
d346 3
a348 3
void
_mesa_fetch_texel_2d_f_rgb_dxt1(const struct gl_texture_image *texImage,
                                GLint i, GLint j, GLint k, GLfloat *texel)
d350 11
a360 7
   /* just sample as GLchan and convert to float here */
   GLchan rgba[4];
   fetch_texel_2d_rgb_dxt1(texImage, i, j, k, rgba);
   texel[RCOMP] = CHAN_TO_FLOAT(rgba[RCOMP]);
   texel[GCOMP] = CHAN_TO_FLOAT(rgba[GCOMP]);
   texel[BCOMP] = CHAN_TO_FLOAT(rgba[BCOMP]);
   texel[ACOMP] = CHAN_TO_FLOAT(rgba[ACOMP]);
a362 1

d364 2
a365 2
fetch_texel_2d_rgba_dxt1( const struct gl_texture_image *texImage,
                          GLint i, GLint j, GLint k, GLchan *texel )
a366 1
   (void) k;
d368 9
a376 2
      fetch_ext_rgba_dxt1(texImage->RowStride,
                          (GLubyte *)(texImage)->Data, i, j, texel);
a377 2
   else
      _mesa_debug(NULL, "attempted to decode s3tc texture without library available: fetch_texel_2d_rgba_dxt1\n");
d380 3
a382 4

void
_mesa_fetch_texel_2d_f_rgba_dxt1(const struct gl_texture_image *texImage,
                                 GLint i, GLint j, GLint k, GLfloat *texel)
d384 11
a394 7
   /* just sample as GLchan and convert to float here */
   GLchan rgba[4];
   fetch_texel_2d_rgba_dxt1(texImage, i, j, k, rgba);
   texel[RCOMP] = CHAN_TO_FLOAT(rgba[RCOMP]);
   texel[GCOMP] = CHAN_TO_FLOAT(rgba[GCOMP]);
   texel[BCOMP] = CHAN_TO_FLOAT(rgba[BCOMP]);
   texel[ACOMP] = CHAN_TO_FLOAT(rgba[ACOMP]);
a396 1

d398 2
a399 2
fetch_texel_2d_rgba_dxt3( const struct gl_texture_image *texImage,
                          GLint i, GLint j, GLint k, GLchan *texel )
d401 10
a410 5
   (void) k;
   if (fetch_ext_rgba_dxt3) {
      ASSERT (sizeof(GLchan) == sizeof(GLubyte));
      fetch_ext_rgba_dxt3(texImage->RowStride, (GLubyte *)(texImage)->Data,
                          i, j, texel);
a411 2
   else
      _mesa_debug(NULL, "attempted to decode s3tc texture without library available: fetch_texel_2d_rgba_dxt3\n");
d415 3
a417 3
void
_mesa_fetch_texel_2d_f_rgba_dxt3(const struct gl_texture_image *texImage,
                                 GLint i, GLint j, GLint k, GLfloat *texel)
d419 11
a429 7
   /* just sample as GLchan and convert to float here */
   GLchan rgba[4];
   fetch_texel_2d_rgba_dxt3(texImage, i, j, k, rgba);
   texel[RCOMP] = CHAN_TO_FLOAT(rgba[RCOMP]);
   texel[GCOMP] = CHAN_TO_FLOAT(rgba[GCOMP]);
   texel[BCOMP] = CHAN_TO_FLOAT(rgba[BCOMP]);
   texel[ACOMP] = CHAN_TO_FLOAT(rgba[ACOMP]);
a431 1

d433 2
a434 2
fetch_texel_2d_rgba_dxt5( const struct gl_texture_image *texImage,
                          GLint i, GLint j, GLint k, GLchan *texel )
d436 10
a445 4
   (void) k;
   if (fetch_ext_rgba_dxt5) {
      fetch_ext_rgba_dxt5(texImage->RowStride, (GLubyte *)(texImage)->Data,
                          i, j, texel);
a446 2
   else
      _mesa_debug(NULL, "attempted to decode s3tc texture without library available: fetch_texel_2d_rgba_dxt5\n");
d449 3
a451 4

void
_mesa_fetch_texel_2d_f_rgba_dxt5(const struct gl_texture_image *texImage,
                                 GLint i, GLint j, GLint k, GLfloat *texel)
d453 11
a463 7
   /* just sample as GLchan and convert to float here */
   GLchan rgba[4];
   fetch_texel_2d_rgba_dxt5(texImage, i, j, k, rgba);
   texel[RCOMP] = CHAN_TO_FLOAT(rgba[RCOMP]);
   texel[GCOMP] = CHAN_TO_FLOAT(rgba[GCOMP]);
   texel[BCOMP] = CHAN_TO_FLOAT(rgba[BCOMP]);
   texel[ACOMP] = CHAN_TO_FLOAT(rgba[ACOMP]);
d466 3
a468 4
#if FEATURE_EXT_texture_sRGB
void
_mesa_fetch_texel_2d_f_srgb_dxt1( const struct gl_texture_image *texImage,
                                  GLint i, GLint j, GLint k, GLfloat *texel )
d470 11
a480 7
   /* just sample as GLchan and convert to float here */
   GLchan rgba[4];
   fetch_texel_2d_rgb_dxt1(texImage, i, j, k, rgba);
   texel[RCOMP] = nonlinear_to_linear(rgba[RCOMP]);
   texel[GCOMP] = nonlinear_to_linear(rgba[GCOMP]);
   texel[BCOMP] = nonlinear_to_linear(rgba[BCOMP]);
   texel[ACOMP] = CHAN_TO_FLOAT(rgba[ACOMP]);
a482 12
void
_mesa_fetch_texel_2d_f_srgba_dxt1(const struct gl_texture_image *texImage,
                                  GLint i, GLint j, GLint k, GLfloat *texel)
{
   /* just sample as GLchan and convert to float here */
   GLchan rgba[4];
   fetch_texel_2d_rgba_dxt1(texImage, i, j, k, rgba);
   texel[RCOMP] = nonlinear_to_linear(rgba[RCOMP]);
   texel[GCOMP] = nonlinear_to_linear(rgba[GCOMP]);
   texel[BCOMP] = nonlinear_to_linear(rgba[BCOMP]);
   texel[ACOMP] = CHAN_TO_FLOAT(rgba[ACOMP]);
}
a483 12
void
_mesa_fetch_texel_2d_f_srgba_dxt3(const struct gl_texture_image *texImage,
                                  GLint i, GLint j, GLint k, GLfloat *texel)
{
   /* just sample as GLchan and convert to float here */
   GLchan rgba[4];
   fetch_texel_2d_rgba_dxt3(texImage, i, j, k, rgba);
   texel[RCOMP] = nonlinear_to_linear(rgba[RCOMP]);
   texel[GCOMP] = nonlinear_to_linear(rgba[GCOMP]);
   texel[BCOMP] = nonlinear_to_linear(rgba[BCOMP]);
   texel[ACOMP] = CHAN_TO_FLOAT(rgba[ACOMP]);
}
d485 2
a486 3
void
_mesa_fetch_texel_2d_f_srgba_dxt5(const struct gl_texture_image *texImage,
                                  GLint i, GLint j, GLint k, GLfloat *texel)
d488 20
a507 7
   /* just sample as GLchan and convert to float here */
   GLchan rgba[4];
   fetch_texel_2d_rgba_dxt5(texImage, i, j, k, rgba);
   texel[RCOMP] = nonlinear_to_linear(rgba[RCOMP]);
   texel[GCOMP] = nonlinear_to_linear(rgba[GCOMP]);
   texel[BCOMP] = nonlinear_to_linear(rgba[BCOMP]);
   texel[ACOMP] = CHAN_TO_FLOAT(rgba[ACOMP]);
a508 4
#endif /* FEATURE_EXT_texture_sRGB */


#endif /* FEATURE_texture_s3tc */
@


1.5
log
@Merge Mesa 7.10.3
@
text
@d42 2
a165 1
   GLint srcRowStride;
a191 1
      srcRowStride = 3 * srcWidth;
a195 2
      srcRowStride = _mesa_image_row_stride(srcPacking, srcWidth, srcFormat,
                                            srcType) / sizeof(GLchan);
a224 1
   GLint srcRowStride;
a250 1
      srcRowStride = 4 * srcWidth;
a254 2
      srcRowStride = _mesa_image_row_stride(srcPacking, srcWidth, srcFormat,
                                            srcType) / sizeof(GLchan);
a282 1
   GLint srcRowStride;
a308 1
      srcRowStride = 4 * srcWidth;
a311 2
      srcRowStride = _mesa_image_row_stride(srcPacking, srcWidth, srcFormat,
                                            srcType) / sizeof(GLchan);
a339 1
   GLint srcRowStride;
a365 1
      srcRowStride = 4 * srcWidth;
a368 2
      srcRowStride = _mesa_image_row_stride(srcPacking, srcWidth, srcFormat,
                                            srcType) / sizeof(GLchan);
@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@a38 2
#include "context.h"
#include "convolve.h"
d41 1
d50 1
a50 1
#ifdef __MINGW32__
d80 1
a80 1
            table[i] = (GLfloat) _mesa_pow((cs + 0.055) / 1.055, 2.4);
d107 1
a107 1
_mesa_init_texture_s3tc( GLcontext *ctx )
a150 1
      _mesa_warning(ctx, "software DXTn compression/decompression available");
d169 2
a170 1
   ASSERT(dstFormat == MESA_FORMAT_RGB_DXT1);
a189 1
      _mesa_adjust_image_for_convolution(ctx, dims, &srcWidth, &srcHeight);
d232 2
a233 1
   ASSERT(dstFormat == MESA_FORMAT_RGBA_DXT1);
a252 1
      _mesa_adjust_image_for_convolution(ctx, dims, &srcWidth, &srcHeight);
d294 2
a295 1
   ASSERT(dstFormat == MESA_FORMAT_RGBA_DXT3);
a314 1
      _mesa_adjust_image_for_convolution(ctx, dims, &srcWidth, &srcHeight);
d355 2
a356 1
   ASSERT(dstFormat == MESA_FORMAT_RGBA_DXT5);
a375 1
      _mesa_adjust_image_for_convolution(ctx, dims, &srcWidth, &srcHeight);
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d6 1
d44 1
a44 1
#include "texformat.h"
d47 4
d61 28
d160 1
a160 1
 * Called via TexFormat->StoreImage to store an RGB_DXT1 texture.
d162 2
a163 2
static GLboolean
texstore_rgb_dxt1(TEXSTORE_PARAMS)
d171 1
a171 1
   ASSERT(dstFormat == &_mesa_texformat_rgb_dxt1);
d185 1
a185 1
                                             dstFormat->BaseFormat,
d203 1
a203 1
                                        dstFormat->MesaFormat,
d212 1
a212 1
      _mesa_warning(ctx, "external dxt library not available");
d216 1
a216 1
      _mesa_free((void *) tempImage);
d223 1
a223 1
 * Called via TexFormat->StoreImage to store an RGBA_DXT1 texture.
d225 2
a226 2
static GLboolean
texstore_rgba_dxt1(TEXSTORE_PARAMS)
d234 1
a234 1
   ASSERT(dstFormat == &_mesa_texformat_rgba_dxt1);
d248 1
a248 1
                                             dstFormat->BaseFormat,
d266 1
a266 1
                                        dstFormat->MesaFormat,
d274 1
a274 1
      _mesa_warning(ctx, "external dxt library not available");
d278 1
a278 1
      _mesa_free((void*) tempImage);
d285 1
a285 1
 * Called via TexFormat->StoreImage to store an RGBA_DXT3 texture.
d287 2
a288 2
static GLboolean
texstore_rgba_dxt3(TEXSTORE_PARAMS)
d296 1
a296 1
   ASSERT(dstFormat == &_mesa_texformat_rgba_dxt3);
d310 1
a310 1
                                             dstFormat->BaseFormat,
d327 1
a327 1
                                        dstFormat->MesaFormat,
d335 1
a335 1
      _mesa_warning(ctx, "external dxt library not available");
d339 1
a339 1
      _mesa_free((void *) tempImage);
d346 1
a346 1
 * Called via TexFormat->StoreImage to store an RGBA_DXT5 texture.
d348 2
a349 2
static GLboolean
texstore_rgba_dxt5(TEXSTORE_PARAMS)
d357 1
a357 1
   ASSERT(dstFormat == &_mesa_texformat_rgba_dxt5);
d371 1
a371 1
                                             dstFormat->BaseFormat,
d388 1
a388 1
                                        dstFormat->MesaFormat,
d396 1
a396 1
      _mesa_warning(ctx, "external dxt library not available");
d400 1
a400 1
      _mesa_free((void *) tempImage);
d417 1
a417 1
      _mesa_debug(NULL, "attempted to decode s3tc texture without library available\n");
d421 3
a423 3
static void
fetch_texel_2d_f_rgb_dxt1( const struct gl_texture_image *texImage,
                            GLint i, GLint j, GLint k, GLfloat *texel )
d445 1
a445 1
      _mesa_debug(NULL, "attempted to decode s3tc texture without library available\n");
d449 3
a451 3
static void
fetch_texel_2d_f_rgba_dxt1( const struct gl_texture_image *texImage,
                            GLint i, GLint j, GLint k, GLfloat *texel )
d474 1
a474 1
      _mesa_debug(NULL, "attempted to decode s3tc texture without library available\n");
d478 3
a480 3
static void
fetch_texel_2d_f_rgba_dxt3( const struct gl_texture_image *texImage,
                            GLint i, GLint j, GLint k, GLfloat *texel )
d502 1
a502 1
      _mesa_debug(NULL, "attempted to decode s3tc texture without library available\n");
d506 3
a508 3
static void
fetch_texel_2d_f_rgba_dxt5( const struct gl_texture_image *texImage,
                            GLint i, GLint j, GLint k, GLfloat *texel )
d519 39
d559 13
a571 23
const struct gl_texture_format _mesa_texformat_rgb_dxt1 = {
   MESA_FORMAT_RGB_DXT1,		/* MesaFormat */
   GL_RGB,				/* BaseFormat */
   GL_UNSIGNED_NORMALIZED_ARB,		/* DataType */
   4, /*approx*/			/* RedBits */
   4, /*approx*/			/* GreenBits */
   4, /*approx*/			/* BlueBits */
   0,					/* AlphaBits */
   0,					/* LuminanceBits */
   0,					/* IntensityBits */
   0,					/* IndexBits */
   0,					/* DepthBits */
   0,					/* StencilBits */
   0,					/* TexelBytes */
   texstore_rgb_dxt1,			/* StoreTexImageFunc */
   NULL, /*impossible*/ 		/* FetchTexel1D */
   fetch_texel_2d_rgb_dxt1, 		/* FetchTexel2D */
   NULL, /*impossible*/ 		/* FetchTexel3D */
   NULL, /*impossible*/ 		/* FetchTexel1Df */
   fetch_texel_2d_f_rgb_dxt1, 		/* FetchTexel2Df */
   NULL, /*impossible*/ 		/* FetchTexel3Df */
   NULL					/* StoreTexel */
};
a572 25
#if FEATURE_EXT_texture_sRGB
const struct gl_texture_format _mesa_texformat_srgb_dxt1 = {
   MESA_FORMAT_SRGB_DXT1,		/* MesaFormat */
   GL_RGB,				/* BaseFormat */
   GL_UNSIGNED_NORMALIZED_ARB,		/* DataType */
   4, /*approx*/			/* RedBits */
   4, /*approx*/			/* GreenBits */
   4, /*approx*/			/* BlueBits */
   0,					/* AlphaBits */
   0,					/* LuminanceBits */
   0,					/* IntensityBits */
   0,					/* IndexBits */
   0,					/* DepthBits */
   0,					/* StencilBits */
   0,					/* TexelBytes */
   texstore_rgb_dxt1,			/* StoreTexImageFunc */
   NULL, /*impossible*/ 		/* FetchTexel1D */
   fetch_texel_2d_rgb_dxt1, 		/* FetchTexel2D */
   NULL, /*impossible*/ 		/* FetchTexel3D */
   NULL, /*impossible*/ 		/* FetchTexel1Df */
   fetch_texel_2d_f_rgb_dxt1, 		/* FetchTexel2Df */
   NULL, /*impossible*/ 		/* FetchTexel3Df */
   NULL					/* StoreTexel */
};
#endif
d574 1
a574 71
const struct gl_texture_format _mesa_texformat_rgba_dxt1 = {
   MESA_FORMAT_RGBA_DXT1,		/* MesaFormat */
   GL_RGBA,				/* BaseFormat */
   GL_UNSIGNED_NORMALIZED_ARB,		/* DataType */
   4, /*approx*/			/* RedBits */
   4, /*approx*/			/* GreenBits */
   4, /*approx*/			/* BlueBits */
   1, /*approx*/			/* AlphaBits */
   0,					/* LuminanceBits */
   0,					/* IntensityBits */
   0,					/* IndexBits */
   0,					/* DepthBits */
   0,					/* StencilBits */
   0,					/* TexelBytes */
   texstore_rgba_dxt1,			/* StoreTexImageFunc */
   NULL, /*impossible*/ 		/* FetchTexel1D */
   fetch_texel_2d_rgba_dxt1, 		/* FetchTexel2D */
   NULL, /*impossible*/ 		/* FetchTexel3D */
   NULL, /*impossible*/ 		/* FetchTexel1Df */
   fetch_texel_2d_f_rgba_dxt1, 		/* FetchTexel2Df */
   NULL, /*impossible*/ 		/* FetchTexel3Df */
   NULL					/* StoreTexel */
};

const struct gl_texture_format _mesa_texformat_rgba_dxt3 = {
   MESA_FORMAT_RGBA_DXT3,		/* MesaFormat */
   GL_RGBA,				/* BaseFormat */
   GL_UNSIGNED_NORMALIZED_ARB,		/* DataType */
   4, /*approx*/			/* RedBits */
   4, /*approx*/			/* GreenBits */
   4, /*approx*/			/* BlueBits */
   4, /*approx*/			/* AlphaBits */
   0,					/* LuminanceBits */
   0,					/* IntensityBits */
   0,					/* IndexBits */
   0,					/* DepthBits */
   0,					/* StencilBits */
   0,					/* TexelBytes */
   texstore_rgba_dxt3,			/* StoreTexImageFunc */
   NULL, /*impossible*/ 		/* FetchTexel1D */
   fetch_texel_2d_rgba_dxt3, 		/* FetchTexel2D */
   NULL, /*impossible*/ 		/* FetchTexel3D */
   NULL, /*impossible*/ 		/* FetchTexel1Df */
   fetch_texel_2d_f_rgba_dxt3, 		/* FetchTexel2Df */
   NULL, /*impossible*/ 		/* FetchTexel3Df */
   NULL					/* StoreTexel */
};

const struct gl_texture_format _mesa_texformat_rgba_dxt5 = {
   MESA_FORMAT_RGBA_DXT5,		/* MesaFormat */
   GL_RGBA,				/* BaseFormat */
   GL_UNSIGNED_NORMALIZED_ARB,		/* DataType */
   4,/*approx*/				/* RedBits */
   4,/*approx*/				/* GreenBits */
   4,/*approx*/				/* BlueBits */
   4,/*approx*/				/* AlphaBits */
   0,					/* LuminanceBits */
   0,					/* IntensityBits */
   0,					/* IndexBits */
   0,					/* DepthBits */
   0,					/* StencilBits */
   0,					/* TexelBytes */
   texstore_rgba_dxt5,			/* StoreTexImageFunc */
   NULL, /*impossible*/ 		/* FetchTexel1D */
   fetch_texel_2d_rgba_dxt5, 		/* FetchTexel2D */
   NULL, /*impossible*/ 		/* FetchTexel3D */
   NULL, /*impossible*/ 		/* FetchTexel1Df */
   fetch_texel_2d_f_rgba_dxt5, 		/* FetchTexel2Df */
   NULL, /*impossible*/ 		/* FetchTexel3Df */
   NULL					/* StoreTexel */
};
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d32 1
a32 1
#define USE_EXTERNAL_DXTN_LIB 0
d40 1
a45 4
#if USE_EXTERNAL_DXTN_LIB && !defined(__MINGW32__)
#include <dlfcn.h>
#endif

a73 66
typedef void (*GenericFunc)(void);


/**
 * Wrapper for dlopen().
 * XXX Probably move this and the following wrappers into imports.h someday.
 */
static void *
_mesa_dlopen(const char *libname, int flags)
{
#if USE_EXTERNAL_DXTN_LIB
#ifdef __MINGW32__
   return LoadLibrary(libname);
#else
   return dlopen(libname, flags);
#endif
#else
   return NULL;
#endif /* USE_EXTERNAL_DXTN_LIB */
}


/**
 * Wrapper for dlsym() that does a cast to a generic function type,
 * rather than a void *.  This reduces the number of warnings that are
 * generated.
 */
static GenericFunc
_mesa_dlsym(void *handle, const char *fname)
{
#if USE_EXTERNAL_DXTN_LIB
#ifdef __MINGW32__
   return (GenericFunc) GetProcAddress(handle, fname);
#elif defined(__DJGPP__)
   /* need '_' prefix on symbol names */
   char fname2[1000];
   fname2[0] = '_';
   _mesa_strncpy(fname2 + 1, fname, 998);
   fname2[999] = 0;
   return (GenericFunc) dlsym(handle, fname2);
#else
   return (GenericFunc) dlsym(handle, fname);
#endif
#else
   return (GenericFunc) NULL;
#endif /* USE_EXTERNAL_DXTN_LIB */
}


/**
 * Wrapper for dlclose().
 */
static void
_mesa_dlclose(void *handle)
{
#if USE_EXTERNAL_DXTN_LIB
#ifdef __MINGW32__
   FreeLibrary(handle);
#else
   dlclose(handle);
#endif
#endif
}



d81 1
a81 1
      dxtlibhandle = _mesa_dlopen(DXTN_LIBNAME, RTLD_LAZY | RTLD_GLOBAL);
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * Version:  6.5.1
d5 1
a5 1
 * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
d51 2
d94 1
a94 1
   return (GenericFunc) NULL;
d109 1
a109 1
   return (GenericFunc) GetProcAddress(handle, fname)
d248 1
a248 1
      _mesa_problem(ctx, "external dxt library not available");
d310 1
a310 1
      _mesa_problem(ctx, "external dxt library not available");
d371 1
a371 1
      _mesa_problem(ctx, "external dxt library not available");
d432 1
a432 1
      _mesa_problem(ctx, "external dxt library not available");
d579 26
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d3 1
a3 1
 * Version:  6.5.2
a50 2
#define RTLD_LAZY 0
#define RTLD_GLOBAL 0
d107 1
a107 1
   return (GenericFunc) GetProcAddress(handle, fname);
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d3 1
a3 1
 * Version:  6.5.3
d5 1
a5 1
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
d94 1
a94 1
   return NULL;
d248 1
a248 1
      _mesa_warning(ctx, "external dxt library not available");
d310 1
a310 1
      _mesa_warning(ctx, "external dxt library not available");
d371 1
a371 1
      _mesa_warning(ctx, "external dxt library not available");
d432 1
a432 1
      _mesa_warning(ctx, "external dxt library not available");
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@a5 1
 * Copyright (c) 2008 VMware, Inc.
d32 1
a32 1
#define USE_EXTERNAL_DXTN_LIB 1
d38 2
a39 1
#include "dlopen.h"
a40 1
#include "macros.h"
d42 1
a42 1
#include "texcompress_s3tc.h"
d45 3
d49 1
a49 4
#if FEATURE_texture_s3tc


#if defined(_WIN32) || defined(WIN32)
a58 28
#if FEATURE_EXT_texture_sRGB
/**
 * Convert an 8-bit sRGB value from non-linear space to a
 * linear RGB value in [0, 1].
 * Implemented with a 256-entry lookup table.
 */
static INLINE GLfloat
nonlinear_to_linear(GLubyte cs8)
{
   static GLfloat table[256];
   static GLboolean tableReady = GL_FALSE;
   if (!tableReady) {
      /* compute lookup table now */
      GLuint i;
      for (i = 0; i < 256; i++) {
         const GLfloat cs = UBYTE_TO_FLOAT(i);
         if (cs <= 0.04045) {
            table[i] = cs / 12.92f;
         }
         else {
            table[i] = (GLfloat) pow((cs + 0.055) / 1.055, 2.4);
         }
      }
      tableReady = GL_TRUE;
   }
   return table[cs8];
}
#endif /* FEATURE_EXT_texture_sRGB */
d77 66
d144 1
a144 1
_mesa_init_texture_s3tc( struct gl_context *ctx )
d150 1
a150 1
      dxtlibhandle = _mesa_dlopen(DXTN_LIBNAME, 0);
d188 1
d196 1
a196 1
 * Store user's image in rgb_dxt1 format.
d198 2
a199 2
GLboolean
_mesa_texstore_rgb_dxt1(TEXSTORE_PARAMS)
d207 1
a207 2
   ASSERT(dstFormat == MESA_FORMAT_RGB_DXT1 ||
          dstFormat == MESA_FORMAT_SRGB_DXT1);
d221 1
a221 1
                                             _mesa_get_format_base_format(dstFormat),
d227 1
d239 1
a239 1
                                        dstFormat,
d248 1
a248 1
      _mesa_warning(ctx, "external dxt library not available: texstore_rgb_dxt1");
d252 1
a252 1
      free((void *) tempImage);
d259 1
a259 1
 * Store user's image in rgba_dxt1 format.
d261 2
a262 2
GLboolean
_mesa_texstore_rgba_dxt1(TEXSTORE_PARAMS)
d270 1
a270 2
   ASSERT(dstFormat == MESA_FORMAT_RGBA_DXT1 ||
          dstFormat == MESA_FORMAT_SRGBA_DXT1);
d284 1
a284 1
                                             _mesa_get_format_base_format(dstFormat),
d290 1
d302 1
a302 1
                                        dstFormat,
d310 1
a310 1
      _mesa_warning(ctx, "external dxt library not available: texstore_rgba_dxt1");
d314 1
a314 1
      free((void*) tempImage);
d321 1
a321 1
 * Store user's image in rgba_dxt3 format.
d323 2
a324 2
GLboolean
_mesa_texstore_rgba_dxt3(TEXSTORE_PARAMS)
d332 1
a332 2
   ASSERT(dstFormat == MESA_FORMAT_RGBA_DXT3 ||
          dstFormat == MESA_FORMAT_SRGBA_DXT3);
d346 1
a346 1
                                             _mesa_get_format_base_format(dstFormat),
d352 1
d363 1
a363 1
                                        dstFormat,
d371 1
a371 1
      _mesa_warning(ctx, "external dxt library not available: texstore_rgba_dxt3");
d375 1
a375 1
      free((void *) tempImage);
d382 1
a382 1
 * Store user's image in rgba_dxt5 format.
d384 2
a385 2
GLboolean
_mesa_texstore_rgba_dxt5(TEXSTORE_PARAMS)
d393 1
a393 2
   ASSERT(dstFormat == MESA_FORMAT_RGBA_DXT5 ||
          dstFormat == MESA_FORMAT_SRGBA_DXT5);
d407 1
a407 1
                                   	     _mesa_get_format_base_format(dstFormat),
d413 1
d424 1
a424 1
                                        dstFormat,
d432 1
a432 1
      _mesa_warning(ctx, "external dxt library not available: texstore_rgba_dxt5");
d436 1
a436 1
      free((void *) tempImage);
d453 1
a453 1
      _mesa_debug(NULL, "attempted to decode s3tc texture without library available: fetch_texel_2d_rgb_dxt1");
d457 3
a459 3
void
_mesa_fetch_texel_2d_f_rgb_dxt1(const struct gl_texture_image *texImage,
                                GLint i, GLint j, GLint k, GLfloat *texel)
d481 1
a481 1
      _mesa_debug(NULL, "attempted to decode s3tc texture without library available: fetch_texel_2d_rgba_dxt1\n");
d485 3
a487 3
void
_mesa_fetch_texel_2d_f_rgba_dxt1(const struct gl_texture_image *texImage,
                                 GLint i, GLint j, GLint k, GLfloat *texel)
d510 1
a510 1
      _mesa_debug(NULL, "attempted to decode s3tc texture without library available: fetch_texel_2d_rgba_dxt3\n");
d514 3
a516 3
void
_mesa_fetch_texel_2d_f_rgba_dxt3(const struct gl_texture_image *texImage,
                                 GLint i, GLint j, GLint k, GLfloat *texel)
d538 1
a538 1
      _mesa_debug(NULL, "attempted to decode s3tc texture without library available: fetch_texel_2d_rgba_dxt5\n");
d542 3
a544 3
void
_mesa_fetch_texel_2d_f_rgba_dxt5(const struct gl_texture_image *texImage,
                                 GLint i, GLint j, GLint k, GLfloat *texel)
a554 54
#if FEATURE_EXT_texture_sRGB
void
_mesa_fetch_texel_2d_f_srgb_dxt1( const struct gl_texture_image *texImage,
                                  GLint i, GLint j, GLint k, GLfloat *texel )
{
   /* just sample as GLchan and convert to float here */
   GLchan rgba[4];
   fetch_texel_2d_rgb_dxt1(texImage, i, j, k, rgba);
   texel[RCOMP] = nonlinear_to_linear(rgba[RCOMP]);
   texel[GCOMP] = nonlinear_to_linear(rgba[GCOMP]);
   texel[BCOMP] = nonlinear_to_linear(rgba[BCOMP]);
   texel[ACOMP] = CHAN_TO_FLOAT(rgba[ACOMP]);
}

void
_mesa_fetch_texel_2d_f_srgba_dxt1(const struct gl_texture_image *texImage,
                                  GLint i, GLint j, GLint k, GLfloat *texel)
{
   /* just sample as GLchan and convert to float here */
   GLchan rgba[4];
   fetch_texel_2d_rgba_dxt1(texImage, i, j, k, rgba);
   texel[RCOMP] = nonlinear_to_linear(rgba[RCOMP]);
   texel[GCOMP] = nonlinear_to_linear(rgba[GCOMP]);
   texel[BCOMP] = nonlinear_to_linear(rgba[BCOMP]);
   texel[ACOMP] = CHAN_TO_FLOAT(rgba[ACOMP]);
}

void
_mesa_fetch_texel_2d_f_srgba_dxt3(const struct gl_texture_image *texImage,
                                  GLint i, GLint j, GLint k, GLfloat *texel)
{
   /* just sample as GLchan and convert to float here */
   GLchan rgba[4];
   fetch_texel_2d_rgba_dxt3(texImage, i, j, k, rgba);
   texel[RCOMP] = nonlinear_to_linear(rgba[RCOMP]);
   texel[GCOMP] = nonlinear_to_linear(rgba[GCOMP]);
   texel[BCOMP] = nonlinear_to_linear(rgba[BCOMP]);
   texel[ACOMP] = CHAN_TO_FLOAT(rgba[ACOMP]);
}

void
_mesa_fetch_texel_2d_f_srgba_dxt5(const struct gl_texture_image *texImage,
                                  GLint i, GLint j, GLint k, GLfloat *texel)
{
   /* just sample as GLchan and convert to float here */
   GLchan rgba[4];
   fetch_texel_2d_rgba_dxt5(texImage, i, j, k, rgba);
   texel[RCOMP] = nonlinear_to_linear(rgba[RCOMP]);
   texel[GCOMP] = nonlinear_to_linear(rgba[GCOMP]);
   texel[BCOMP] = nonlinear_to_linear(rgba[BCOMP]);
   texel[ACOMP] = CHAN_TO_FLOAT(rgba[ACOMP]);
}
#endif /* FEATURE_EXT_texture_sRGB */

d556 95
a650 1
#endif /* FEATURE_texture_s3tc */
@


1.1.1.5
log
@Import Mesa 9.2.0
@
text
@d3 1
d21 3
a23 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
a41 1
#include "mtypes.h"
d45 3
a47 1
#include "format_unpack.h"
d60 30
a89 1
typedef void (*dxtFetchTexelFuncExt)( GLint srcRowstride, const GLubyte *pixdata, GLint col, GLint row, GLvoid *texelOut );
d91 4
a94 4
static dxtFetchTexelFuncExt fetch_ext_rgb_dxt1 = NULL;
static dxtFetchTexelFuncExt fetch_ext_rgba_dxt1 = NULL;
static dxtFetchTexelFuncExt fetch_ext_rgba_dxt3 = NULL;
static dxtFetchTexelFuncExt fetch_ext_rgba_dxt5 = NULL;
d97 1
a97 1
                                      GLint height, const GLubyte *srcPixData,
d163 2
a164 1
   const GLubyte *pixels;
d166 2
a167 1
   const GLubyte *tempImage = NULL;
d171 5
d178 1
a178 1
       srcType != GL_UNSIGNED_BYTE ||
a179 1
       srcPacking->RowLength != srcWidth ||
d181 2
a182 2
      /* convert image to RGB/GLubyte */
      tempImage = _mesa_make_temp_ubyte_image(ctx, dims,
d191 1
d195 3
a197 2
      pixels = _mesa_image_address2d(srcPacking, srcAddr, srcWidth, srcHeight,
                                     srcFormat, srcType, 0, 0);
d200 3
a202 1
   dst = dstSlices[0];
d213 2
a214 1
   free((void *) tempImage);
d226 2
a227 1
   const GLubyte *pixels;
d229 2
a230 1
   const GLubyte *tempImage = NULL;
d234 5
d241 1
a241 1
       srcType != GL_UNSIGNED_BYTE ||
a242 1
       srcPacking->RowLength != srcWidth ||
d244 2
a245 2
      /* convert image to RGBA/GLubyte */
      tempImage = _mesa_make_temp_ubyte_image(ctx, dims,
d254 1
d258 3
a260 2
      pixels = _mesa_image_address2d(srcPacking, srcAddr, srcWidth, srcHeight,
                                     srcFormat, srcType, 0, 0);
d263 3
a265 2
   dst = dstSlices[0];

d275 2
a276 1
   free((void*) tempImage);
d288 2
a289 1
   const GLubyte *pixels;
d291 2
a292 1
   const GLubyte *tempImage = NULL;
d296 5
d303 1
a303 1
       srcType != GL_UNSIGNED_BYTE ||
a304 1
       srcPacking->RowLength != srcWidth ||
d306 2
a307 2
      /* convert image to RGBA/GLubyte */
      tempImage = _mesa_make_temp_ubyte_image(ctx, dims,
d316 1
d319 3
a321 2
      pixels = _mesa_image_address2d(srcPacking, srcAddr, srcWidth, srcHeight,
                                     srcFormat, srcType, 0, 0);
d324 3
a326 2
   dst = dstSlices[0];

d336 2
a337 1
   free((void *) tempImage);
d349 2
a350 1
   const GLubyte *pixels;
d352 2
a353 1
   const GLubyte *tempImage = NULL;
d357 5
d364 1
a364 1
       srcType != GL_UNSIGNED_BYTE ||
a365 1
       srcPacking->RowLength != srcWidth ||
d367 2
a368 2
      /* convert image to RGBA/GLubyte */
      tempImage = _mesa_make_temp_ubyte_image(ctx, dims,
d377 1
d380 3
a382 2
      pixels = _mesa_image_address2d(srcPacking, srcAddr, srcWidth, srcHeight,
                                     srcFormat, srcType, 0, 0);
d385 3
a387 2
   dst = dstSlices[0];

d397 2
a398 1
   free((void *) tempImage);
a403 1
/** Report problem with dxt texture decompression, once */
d405 2
a406 1
problem(const char *func)
d408 5
a412 5
   static GLboolean warned = GL_FALSE;
   if (!warned) {
      _mesa_debug(NULL, "attempted to decode DXT texture without "
                  "library available: %s\n", func);
      warned = GL_TRUE;
d414 2
d419 3
a421 3
static void
fetch_rgb_dxt1(const GLubyte *map,
               GLint rowStride, GLint i, GLint j, GLfloat *texel)
d423 7
a429 11
   if (fetch_ext_rgb_dxt1) {
      GLubyte tex[4];
      fetch_ext_rgb_dxt1(rowStride, map, i, j, tex);
      texel[RCOMP] = UBYTE_TO_FLOAT(tex[RCOMP]);
      texel[GCOMP] = UBYTE_TO_FLOAT(tex[GCOMP]);
      texel[BCOMP] = UBYTE_TO_FLOAT(tex[BCOMP]);
      texel[ACOMP] = UBYTE_TO_FLOAT(tex[ACOMP]);
   }
   else {
      problem("rgb_dxt1");
   }
d432 1
d434 2
a435 2
fetch_rgba_dxt1(const GLubyte *map,
                GLint rowStride, GLint i, GLint j, GLfloat *texel)
d437 1
d439 2
a440 9
      GLubyte tex[4];
      fetch_ext_rgba_dxt1(rowStride, map, i, j, tex);
      texel[RCOMP] = UBYTE_TO_FLOAT(tex[RCOMP]);
      texel[GCOMP] = UBYTE_TO_FLOAT(tex[GCOMP]);
      texel[BCOMP] = UBYTE_TO_FLOAT(tex[BCOMP]);
      texel[ACOMP] = UBYTE_TO_FLOAT(tex[ACOMP]);
   }
   else {
      problem("rgba_dxt1");
d442 16
d460 1
d462 2
a463 2
fetch_rgba_dxt3(const GLubyte *map,
                GLint rowStride, GLint i, GLint j, GLfloat *texel)
d465 1
d467 3
a469 9
      GLubyte tex[4];
      fetch_ext_rgba_dxt3(rowStride, map, i, j, tex);
      texel[RCOMP] = UBYTE_TO_FLOAT(tex[RCOMP]);
      texel[GCOMP] = UBYTE_TO_FLOAT(tex[GCOMP]);
      texel[BCOMP] = UBYTE_TO_FLOAT(tex[BCOMP]);
      texel[ACOMP] = UBYTE_TO_FLOAT(tex[ACOMP]);
   }
   else {
      problem("rgba_dxt3");
d471 16
d489 1
d491 2
a492 2
fetch_rgba_dxt5(const GLubyte *map,
                GLint rowStride, GLint i, GLint j, GLfloat *texel)
d494 1
d496 2
a497 9
      GLubyte tex[4];
      fetch_ext_rgba_dxt5(rowStride, map, i, j, tex);
      texel[RCOMP] = UBYTE_TO_FLOAT(tex[RCOMP]);
      texel[GCOMP] = UBYTE_TO_FLOAT(tex[GCOMP]);
      texel[BCOMP] = UBYTE_TO_FLOAT(tex[BCOMP]);
      texel[ACOMP] = UBYTE_TO_FLOAT(tex[ACOMP]);
   }
   else {
      problem("rgba_dxt5");
d499 2
d504 3
a506 3
static void
fetch_srgb_dxt1(const GLubyte *map,
                GLint rowStride, GLint i, GLint j, GLfloat *texel)
d508 7
a514 11
   if (fetch_ext_rgb_dxt1) {
      GLubyte tex[4];
      fetch_ext_rgb_dxt1(rowStride, map, i, j, tex);
      texel[RCOMP] = _mesa_nonlinear_to_linear(tex[RCOMP]);
      texel[GCOMP] = _mesa_nonlinear_to_linear(tex[GCOMP]);
      texel[BCOMP] = _mesa_nonlinear_to_linear(tex[BCOMP]);
      texel[ACOMP] = UBYTE_TO_FLOAT(tex[ACOMP]);
   }
   else {
      problem("srgb_dxt1");
   }
d517 4
a520 3
static void
fetch_srgba_dxt1(const GLubyte *map,
                 GLint rowStride, GLint i, GLint j, GLfloat *texel)
d522 7
a528 11
   if (fetch_ext_rgba_dxt1) {
      GLubyte tex[4];
      fetch_ext_rgba_dxt1(rowStride, map, i, j, tex);
      texel[RCOMP] = _mesa_nonlinear_to_linear(tex[RCOMP]);
      texel[GCOMP] = _mesa_nonlinear_to_linear(tex[GCOMP]);
      texel[BCOMP] = _mesa_nonlinear_to_linear(tex[BCOMP]);
      texel[ACOMP] = UBYTE_TO_FLOAT(tex[ACOMP]);
   }
   else {
      problem("srgba_dxt1");
   }
d531 3
a533 3
static void
fetch_srgba_dxt3(const GLubyte *map,
                 GLint rowStride, GLint i, GLint j, GLfloat *texel)
d535 7
a541 11
   if (fetch_ext_rgba_dxt3) {
      GLubyte tex[4];
      fetch_ext_rgba_dxt3(rowStride, map, i, j, tex);
      texel[RCOMP] = _mesa_nonlinear_to_linear(tex[RCOMP]);
      texel[GCOMP] = _mesa_nonlinear_to_linear(tex[GCOMP]);
      texel[BCOMP] = _mesa_nonlinear_to_linear(tex[BCOMP]);
      texel[ACOMP] = UBYTE_TO_FLOAT(tex[ACOMP]);
   }
   else {
      problem("srgba_dxt3");
   }
d544 3
a546 3
static void
fetch_srgba_dxt5(const GLubyte *map,
                 GLint rowStride, GLint i, GLint j, GLfloat *texel)
d548 7
a554 11
   if (fetch_ext_rgba_dxt5) {
      GLubyte tex[4];
      fetch_ext_rgba_dxt5(rowStride, map, i, j, tex);
      texel[RCOMP] = _mesa_nonlinear_to_linear(tex[RCOMP]);
      texel[GCOMP] = _mesa_nonlinear_to_linear(tex[GCOMP]);
      texel[BCOMP] = _mesa_nonlinear_to_linear(tex[BCOMP]);
      texel[ACOMP] = UBYTE_TO_FLOAT(tex[ACOMP]);
   }
   else {
      problem("srgba_dxt5");
   }
d557 13
d572 1
a572 24
compressed_fetch_func
_mesa_get_dxt_fetch_func(gl_format format)
{
   switch (format) {
   case MESA_FORMAT_RGB_DXT1:
      return fetch_rgb_dxt1;
   case MESA_FORMAT_RGBA_DXT1:
      return fetch_rgba_dxt1;
   case MESA_FORMAT_RGBA_DXT3:
      return fetch_rgba_dxt3;
   case MESA_FORMAT_RGBA_DXT5:
      return fetch_rgba_dxt5;
   case MESA_FORMAT_SRGB_DXT1:
      return fetch_srgb_dxt1;
   case MESA_FORMAT_SRGBA_DXT1:
      return fetch_srgba_dxt1;
   case MESA_FORMAT_SRGBA_DXT3:
      return fetch_srgba_dxt3;
   case MESA_FORMAT_SRGBA_DXT5:
      return fetch_srgba_dxt5;
   default:
      return NULL;
   }
}
@


1.1.1.6
log
@Import Mesa 10.2.3
@
text
@d486 1
a486 1
_mesa_get_dxt_fetch_func(mesa_format format)
@


1.1.1.7
log
@Import Mesa 10.4.3
@
text
@a46 1
#include "util/format_srgb.h"
d53 2
d422 3
a424 3
      texel[RCOMP] = util_format_srgb_8unorm_to_linear_float(tex[RCOMP]);
      texel[GCOMP] = util_format_srgb_8unorm_to_linear_float(tex[GCOMP]);
      texel[BCOMP] = util_format_srgb_8unorm_to_linear_float(tex[BCOMP]);
d439 3
a441 3
      texel[RCOMP] = util_format_srgb_8unorm_to_linear_float(tex[RCOMP]);
      texel[GCOMP] = util_format_srgb_8unorm_to_linear_float(tex[GCOMP]);
      texel[BCOMP] = util_format_srgb_8unorm_to_linear_float(tex[BCOMP]);
d456 3
a458 3
      texel[RCOMP] = util_format_srgb_8unorm_to_linear_float(tex[RCOMP]);
      texel[GCOMP] = util_format_srgb_8unorm_to_linear_float(tex[GCOMP]);
      texel[BCOMP] = util_format_srgb_8unorm_to_linear_float(tex[BCOMP]);
d473 3
a475 3
      texel[RCOMP] = util_format_srgb_8unorm_to_linear_float(tex[RCOMP]);
      texel[GCOMP] = util_format_srgb_8unorm_to_linear_float(tex[GCOMP]);
      texel[BCOMP] = util_format_srgb_8unorm_to_linear_float(tex[BCOMP]);
@


1.1.1.8
log
@Import Mesa 10.2.9
@
text
@d47 1
a53 2
#elif defined(__DJGPP__)
#define DXTN_LIBNAME "dxtn.dxe"
d421 3
a423 3
      texel[RCOMP] = _mesa_nonlinear_to_linear(tex[RCOMP]);
      texel[GCOMP] = _mesa_nonlinear_to_linear(tex[GCOMP]);
      texel[BCOMP] = _mesa_nonlinear_to_linear(tex[BCOMP]);
d438 3
a440 3
      texel[RCOMP] = _mesa_nonlinear_to_linear(tex[RCOMP]);
      texel[GCOMP] = _mesa_nonlinear_to_linear(tex[GCOMP]);
      texel[BCOMP] = _mesa_nonlinear_to_linear(tex[BCOMP]);
d455 3
a457 3
      texel[RCOMP] = _mesa_nonlinear_to_linear(tex[RCOMP]);
      texel[GCOMP] = _mesa_nonlinear_to_linear(tex[GCOMP]);
      texel[BCOMP] = _mesa_nonlinear_to_linear(tex[BCOMP]);
d472 3
a474 3
      texel[RCOMP] = _mesa_nonlinear_to_linear(tex[RCOMP]);
      texel[GCOMP] = _mesa_nonlinear_to_linear(tex[GCOMP]);
      texel[BCOMP] = _mesa_nonlinear_to_linear(tex[BCOMP]);
@


