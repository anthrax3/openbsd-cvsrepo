head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.4
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.5.0.2
	OPENBSD_5_5_BASE:1.5
	v9_2_5:1.1.1.3
	v9_2_3:1.1.1.3
	v9_2_2:1.1.1.3
	v9_2_1:1.1.1.3
	v9_2_0:1.1.1.3
	OPENBSD_5_4:1.4.0.4
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.2
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.3.0.4
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.2
	v7_10_3:1.1.1.2
	OPENBSD_5_0:1.2.0.6
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.1.1.0.12
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.10
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v7_0_1:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v6_5_2:1.1.1.1
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.52;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.21;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2013.09.05.14.06.21;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2012.08.17.13.58.19;	author mpi;	state Exp;
branches;
next	1.3;

1.3
date	2011.10.23.13.37.42;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.05.22.20.06.30;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.49.59;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.49.59;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2011.10.23.13.29.46;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2013.09.05.13.16.32;	author jsg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2015.01.25.14.12.35;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.49.42;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@
/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2003  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */


/*
 * eval.c was written by
 * Bernd Barsuhn (bdbarsuh@@cip.informatik.uni-erlangen.de) and
 * Volker Weiss (vrweiss@@cip.informatik.uni-erlangen.de).
 *
 * My original implementation of evaluators was simplistic and didn't
 * compute surface normal vectors properly.  Bernd and Volker applied
 * used more sophisticated methods to get better results.
 *
 * Thanks guys!
 */


#include "glheader.h"
#include "imports.h"
#include "colormac.h"
#include "context.h"
#include "eval.h"
#include "macros.h"
#include "mtypes.h"
#include "main/dispatch.h"


/*
 * Return the number of components per control point for any type of
 * evaluator.  Return 0 if bad target.
 * See table 5.1 in the OpenGL 1.2 spec.
 */
GLuint _mesa_evaluator_components( GLenum target )
{
   switch (target) {
      case GL_MAP1_VERTEX_3:		return 3;
      case GL_MAP1_VERTEX_4:		return 4;
      case GL_MAP1_INDEX:		return 1;
      case GL_MAP1_COLOR_4:		return 4;
      case GL_MAP1_NORMAL:		return 3;
      case GL_MAP1_TEXTURE_COORD_1:	return 1;
      case GL_MAP1_TEXTURE_COORD_2:	return 2;
      case GL_MAP1_TEXTURE_COORD_3:	return 3;
      case GL_MAP1_TEXTURE_COORD_4:	return 4;
      case GL_MAP2_VERTEX_3:		return 3;
      case GL_MAP2_VERTEX_4:		return 4;
      case GL_MAP2_INDEX:		return 1;
      case GL_MAP2_COLOR_4:		return 4;
      case GL_MAP2_NORMAL:		return 3;
      case GL_MAP2_TEXTURE_COORD_1:	return 1;
      case GL_MAP2_TEXTURE_COORD_2:	return 2;
      case GL_MAP2_TEXTURE_COORD_3:	return 3;
      case GL_MAP2_TEXTURE_COORD_4:	return 4;
      default:				break;
   }

   return 0;
}


/*
 * Return pointer to the gl_1d_map struct for the named target.
 */
static struct gl_1d_map *
get_1d_map( struct gl_context *ctx, GLenum target )
{
   switch (target) {
      case GL_MAP1_VERTEX_3:
         return &ctx->EvalMap.Map1Vertex3;
      case GL_MAP1_VERTEX_4:
         return &ctx->EvalMap.Map1Vertex4;
      case GL_MAP1_INDEX:
         return &ctx->EvalMap.Map1Index;
      case GL_MAP1_COLOR_4:
         return &ctx->EvalMap.Map1Color4;
      case GL_MAP1_NORMAL:
         return &ctx->EvalMap.Map1Normal;
      case GL_MAP1_TEXTURE_COORD_1:
         return &ctx->EvalMap.Map1Texture1;
      case GL_MAP1_TEXTURE_COORD_2:
         return &ctx->EvalMap.Map1Texture2;
      case GL_MAP1_TEXTURE_COORD_3:
         return &ctx->EvalMap.Map1Texture3;
      case GL_MAP1_TEXTURE_COORD_4:
         return &ctx->EvalMap.Map1Texture4;
      default:
         return NULL;
   }
}


/*
 * Return pointer to the gl_2d_map struct for the named target.
 */
static struct gl_2d_map *
get_2d_map( struct gl_context *ctx, GLenum target )
{
   switch (target) {
      case GL_MAP2_VERTEX_3:
         return &ctx->EvalMap.Map2Vertex3;
      case GL_MAP2_VERTEX_4:
         return &ctx->EvalMap.Map2Vertex4;
      case GL_MAP2_INDEX:
         return &ctx->EvalMap.Map2Index;
      case GL_MAP2_COLOR_4:
         return &ctx->EvalMap.Map2Color4;
      case GL_MAP2_NORMAL:
         return &ctx->EvalMap.Map2Normal;
      case GL_MAP2_TEXTURE_COORD_1:
         return &ctx->EvalMap.Map2Texture1;
      case GL_MAP2_TEXTURE_COORD_2:
         return &ctx->EvalMap.Map2Texture2;
      case GL_MAP2_TEXTURE_COORD_3:
         return &ctx->EvalMap.Map2Texture3;
      case GL_MAP2_TEXTURE_COORD_4:
         return &ctx->EvalMap.Map2Texture4;
      default:
         return NULL;
   }
}


/**********************************************************************/
/***            Copy and deallocate control points                  ***/
/**********************************************************************/


/*
 * Copy 1-parametric evaluator control points from user-specified
 * memory space to a buffer of contiguous control points.
 * \param see glMap1f for details
 * \return pointer to buffer of contiguous control points or NULL if out
 *          of memory.
 */
GLfloat *_mesa_copy_map_points1f( GLenum target, GLint ustride, GLint uorder,
                                  const GLfloat *points )
{
   GLfloat *buffer, *p;
   GLint i, k, size = _mesa_evaluator_components(target);

   if (!points || !size)
      return NULL;

   buffer = malloc(uorder * size * sizeof(GLfloat));

   if (buffer)
      for (i = 0, p = buffer; i < uorder; i++, points += ustride)
	for (k = 0; k < size; k++)
	  *p++ = points[k];

   return buffer;
}



/*
 * Same as above but convert doubles to floats.
 */
GLfloat *_mesa_copy_map_points1d( GLenum target, GLint ustride, GLint uorder,
                                  const GLdouble *points )
{
   GLfloat *buffer, *p;
   GLint i, k, size = _mesa_evaluator_components(target);

   if (!points || !size)
      return NULL;

   buffer = malloc(uorder * size * sizeof(GLfloat));

   if (buffer)
      for (i = 0, p = buffer; i < uorder; i++, points += ustride)
	for (k = 0; k < size; k++)
	  *p++ = (GLfloat) points[k];

   return buffer;
}



/*
 * Copy 2-parametric evaluator control points from user-specified
 * memory space to a buffer of contiguous control points.
 * Additional memory is allocated to be used by the horner and
 * de Casteljau evaluation schemes.
 *
 * \param see glMap2f for details
 * \return pointer to buffer of contiguous control points or NULL if out
 *          of memory.
 */
GLfloat *_mesa_copy_map_points2f( GLenum target,
                                  GLint ustride, GLint uorder,
                                  GLint vstride, GLint vorder,
                                  const GLfloat *points )
{
   GLfloat *buffer, *p;
   GLint i, j, k, size, dsize, hsize;
   GLint uinc;

   size = _mesa_evaluator_components(target);

   if (!points || size==0) {
      return NULL;
   }

   /* max(uorder, vorder) additional points are used in      */
   /* horner evaluation and uorder*vorder additional */
   /* values are needed for de Casteljau                     */
   dsize = (uorder == 2 && vorder == 2)? 0 : uorder*vorder;
   hsize = (uorder > vorder ? uorder : vorder)*size;

   if(hsize>dsize)
     buffer = malloc((uorder*vorder*size+hsize)*sizeof(GLfloat));
   else
     buffer = malloc((uorder*vorder*size+dsize)*sizeof(GLfloat));

   /* compute the increment value for the u-loop */
   uinc = ustride - vorder*vstride;

   if (buffer)
      for (i=0, p=buffer; i<uorder; i++, points += uinc)
	 for (j=0; j<vorder; j++, points += vstride)
	    for (k=0; k<size; k++)
	       *p++ = points[k];

   return buffer;
}



/*
 * Same as above but convert doubles to floats.
 */
GLfloat *_mesa_copy_map_points2d(GLenum target,
                                 GLint ustride, GLint uorder,
                                 GLint vstride, GLint vorder,
                                 const GLdouble *points )
{
   GLfloat *buffer, *p;
   GLint i, j, k, size, hsize, dsize;
   GLint uinc;

   size = _mesa_evaluator_components(target);

   if (!points || size==0) {
      return NULL;
   }

   /* max(uorder, vorder) additional points are used in      */
   /* horner evaluation and uorder*vorder additional */
   /* values are needed for de Casteljau                     */
   dsize = (uorder == 2 && vorder == 2)? 0 : uorder*vorder;
   hsize = (uorder > vorder ? uorder : vorder)*size;

   if(hsize>dsize)
     buffer = malloc((uorder*vorder*size+hsize)*sizeof(GLfloat));
   else
     buffer = malloc((uorder*vorder*size+dsize)*sizeof(GLfloat));

   /* compute the increment value for the u-loop */
   uinc = ustride - vorder*vstride;

   if (buffer)
      for (i=0, p=buffer; i<uorder; i++, points += uinc)
	 for (j=0; j<vorder; j++, points += vstride)
	    for (k=0; k<size; k++)
	       *p++ = (GLfloat) points[k];

   return buffer;
}




/**********************************************************************/
/***                      API entry points                          ***/
/**********************************************************************/


/*
 * This does the work of glMap1[fd].
 */
static void
map1(GLenum target, GLfloat u1, GLfloat u2, GLint ustride,
     GLint uorder, const GLvoid *points, GLenum type )
{
   GET_CURRENT_CONTEXT(ctx);
   GLint k;
   GLfloat *pnts;
   struct gl_1d_map *map = NULL;

   ASSERT(type == GL_FLOAT || type == GL_DOUBLE);

   if (u1 == u2) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glMap1(u1,u2)" );
      return;
   }
   if (uorder < 1 || uorder > MAX_EVAL_ORDER) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glMap1(order)" );
      return;
   }
   if (!points) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glMap1(points)" );
      return;
   }

   k = _mesa_evaluator_components( target );
   if (k == 0) {
      _mesa_error( ctx, GL_INVALID_ENUM, "glMap1(target)" );
      return;
   }

   if (ustride < k) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glMap1(stride)" );
      return;
   }

   if (ctx->Texture.CurrentUnit != 0) {
      /* See OpenGL 1.2.1 spec, section F.2.13 */
      _mesa_error( ctx, GL_INVALID_OPERATION, "glMap2(ACTIVE_TEXTURE != 0)" );
      return;
   }

   map = get_1d_map(ctx, target);
   if (!map) {
      _mesa_error( ctx, GL_INVALID_ENUM, "glMap1(target)" );
      return;
   }

   /* make copy of the control points */
   if (type == GL_FLOAT)
      pnts = _mesa_copy_map_points1f(target, ustride, uorder, (GLfloat*) points);
   else
      pnts = _mesa_copy_map_points1d(target, ustride, uorder, (GLdouble*) points);


   FLUSH_VERTICES(ctx, _NEW_EVAL);
   map->Order = uorder;
   map->u1 = u1;
   map->u2 = u2;
   map->du = 1.0F / (u2 - u1);
   free(map->Points);
   map->Points = pnts;
}



void GLAPIENTRY
_mesa_Map1f( GLenum target, GLfloat u1, GLfloat u2, GLint stride,
             GLint order, const GLfloat *points )
{
   map1(target, u1, u2, stride, order, points, GL_FLOAT);
}


void GLAPIENTRY
_mesa_Map1d( GLenum target, GLdouble u1, GLdouble u2, GLint stride,
             GLint order, const GLdouble *points )
{
   map1(target, (GLfloat) u1, (GLfloat) u2, stride, order, points, GL_DOUBLE);
}


static void
map2( GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder,
      GLfloat v1, GLfloat v2, GLint vstride, GLint vorder,
      const GLvoid *points, GLenum type )
{
   GET_CURRENT_CONTEXT(ctx);
   GLint k;
   GLfloat *pnts;
   struct gl_2d_map *map = NULL;

   ASSERT(type == GL_FLOAT || type == GL_DOUBLE);

   if (u1==u2) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glMap2(u1,u2)" );
      return;
   }

   if (v1==v2) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glMap2(v1,v2)" );
      return;
   }

   if (uorder<1 || uorder>MAX_EVAL_ORDER) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glMap2(uorder)" );
      return;
   }

   if (vorder<1 || vorder>MAX_EVAL_ORDER) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glMap2(vorder)" );
      return;
   }

   k = _mesa_evaluator_components( target );
   if (k==0) {
      _mesa_error( ctx, GL_INVALID_ENUM, "glMap2(target)" );
      return;
   }

   if (ustride < k) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glMap2(ustride)" );
      return;
   }
   if (vstride < k) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glMap2(vstride)" );
      return;
   }

   if (ctx->Texture.CurrentUnit != 0) {
      /* See OpenGL 1.2.1 spec, section F.2.13 */
      _mesa_error( ctx, GL_INVALID_OPERATION, "glMap2(ACTIVE_TEXTURE != 0)" );
      return;
   }

   map = get_2d_map(ctx, target);
   if (!map) {
      _mesa_error( ctx, GL_INVALID_ENUM, "glMap2(target)" );
      return;
   }

   /* make copy of the control points */
   if (type == GL_FLOAT)
      pnts = _mesa_copy_map_points2f(target, ustride, uorder,
                                  vstride, vorder, (GLfloat*) points);
   else
      pnts = _mesa_copy_map_points2d(target, ustride, uorder,
                                  vstride, vorder, (GLdouble*) points);


   FLUSH_VERTICES(ctx, _NEW_EVAL);
   map->Uorder = uorder;
   map->u1 = u1;
   map->u2 = u2;
   map->du = 1.0F / (u2 - u1);
   map->Vorder = vorder;
   map->v1 = v1;
   map->v2 = v2;
   map->dv = 1.0F / (v2 - v1);
   free(map->Points);
   map->Points = pnts;
}


void GLAPIENTRY
_mesa_Map2f( GLenum target,
             GLfloat u1, GLfloat u2, GLint ustride, GLint uorder,
             GLfloat v1, GLfloat v2, GLint vstride, GLint vorder,
             const GLfloat *points)
{
   map2(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder,
        points, GL_FLOAT);
}


void GLAPIENTRY
_mesa_Map2d( GLenum target,
             GLdouble u1, GLdouble u2, GLint ustride, GLint uorder,
             GLdouble v1, GLdouble v2, GLint vstride, GLint vorder,
             const GLdouble *points )
{
   map2(target, (GLfloat) u1, (GLfloat) u2, ustride, uorder, 
	(GLfloat) v1, (GLfloat) v2, vstride, vorder, points, GL_DOUBLE);
}



void GLAPIENTRY
_mesa_GetnMapdvARB( GLenum target, GLenum query, GLsizei bufSize, GLdouble *v )
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_1d_map *map1d;
   struct gl_2d_map *map2d;
   GLint i, n;
   GLfloat *data;
   GLuint comps;
   GLsizei numBytes;

   comps = _mesa_evaluator_components(target);
   if (!comps) {
      _mesa_error( ctx, GL_INVALID_ENUM, "glGetMapdv(target)" );
      return;
   }

   map1d = get_1d_map(ctx, target);
   map2d = get_2d_map(ctx, target);
   ASSERT(map1d || map2d);

   switch (query) {
      case GL_COEFF:
         if (map1d) {
            data = map1d->Points;
            n = map1d->Order * comps;
         }
         else {
            data = map2d->Points;
            n = map2d->Uorder * map2d->Vorder * comps;
         }
	 if (data) {
            numBytes = n * sizeof *v;
            if (bufSize < numBytes)
               goto overflow;
	    for (i=0;i<n;i++) {
	       v[i] = data[i];
	    }
	 }
         break;
      case GL_ORDER:
         if (map1d) {
            numBytes = 1 * sizeof *v;
            if (bufSize < numBytes)
               goto overflow;
            v[0] = (GLdouble) map1d->Order;
         }
         else {
            numBytes = 2 * sizeof *v;
            if (bufSize < numBytes)
               goto overflow;
            v[0] = (GLdouble) map2d->Uorder;
            v[1] = (GLdouble) map2d->Vorder;
         }
         break;
      case GL_DOMAIN:
         if (map1d) {
            numBytes = 2 * sizeof *v;
            if (bufSize < numBytes)
              goto overflow;
            v[0] = (GLdouble) map1d->u1;
            v[1] = (GLdouble) map1d->u2;
         }
         else {
            numBytes = 4 * sizeof *v;
            if (bufSize < numBytes)
               goto overflow;
            v[0] = (GLdouble) map2d->u1;
            v[1] = (GLdouble) map2d->u2;
            v[2] = (GLdouble) map2d->v1;
            v[3] = (GLdouble) map2d->v2;
         }
         break;
      default:
         _mesa_error( ctx, GL_INVALID_ENUM, "glGetMapdv(query)" );
   }
   return;

overflow:
   _mesa_error( ctx, GL_INVALID_OPERATION,
               "glGetnMapdvARB(out of bounds: bufSize is %d,"
               " but %d bytes are required)", bufSize, numBytes );
}

void GLAPIENTRY
_mesa_GetMapdv( GLenum target, GLenum query, GLdouble *v )
{
   _mesa_GetnMapdvARB(target, query, INT_MAX, v);
}

void GLAPIENTRY
_mesa_GetnMapfvARB( GLenum target, GLenum query, GLsizei bufSize, GLfloat *v )
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_1d_map *map1d;
   struct gl_2d_map *map2d;
   GLint i, n;
   GLfloat *data;
   GLuint comps;
   GLsizei numBytes;

   comps = _mesa_evaluator_components(target);
   if (!comps) {
      _mesa_error( ctx, GL_INVALID_ENUM, "glGetMapfv(target)" );
      return;
   }

   map1d = get_1d_map(ctx, target);
   map2d = get_2d_map(ctx, target);
   ASSERT(map1d || map2d);

   switch (query) {
      case GL_COEFF:
         if (map1d) {
            data = map1d->Points;
            n = map1d->Order * comps;
         }
         else {
            data = map2d->Points;
            n = map2d->Uorder * map2d->Vorder * comps;
         }
	 if (data) {
            numBytes = n * sizeof *v;
            if (bufSize < numBytes)
               goto overflow;
	    for (i=0;i<n;i++) {
	       v[i] = data[i];
	    }
	 }
         break;
      case GL_ORDER:
         if (map1d) {
            numBytes = 1 * sizeof *v;
            if (bufSize < numBytes)
               goto overflow;
            v[0] = (GLfloat) map1d->Order;
         }
         else {
            numBytes = 2 * sizeof *v;
            if (bufSize < numBytes)
               goto overflow;
            v[0] = (GLfloat) map2d->Uorder;
            v[1] = (GLfloat) map2d->Vorder;
         }
         break;
      case GL_DOMAIN:
         if (map1d) {
            numBytes = 2 * sizeof *v;
            if (bufSize < numBytes)
               goto overflow;
            v[0] = map1d->u1;
            v[1] = map1d->u2;
         }
         else {
            numBytes = 4 * sizeof *v;
            if (bufSize < numBytes)
               goto overflow;
            v[0] = map2d->u1;
            v[1] = map2d->u2;
            v[2] = map2d->v1;
            v[3] = map2d->v2;
         }
         break;
      default:
         _mesa_error( ctx, GL_INVALID_ENUM, "glGetMapfv(query)" );
   }
   return;

overflow:
   _mesa_error( ctx, GL_INVALID_OPERATION,
               "glGetnMapfvARB(out of bounds: bufSize is %d,"
               " but %d bytes are required)", bufSize, numBytes );
}


void GLAPIENTRY
_mesa_GetMapfv( GLenum target, GLenum query, GLfloat *v )
{
   _mesa_GetnMapfvARB(target, query, INT_MAX, v);
}


void GLAPIENTRY
_mesa_GetnMapivARB( GLenum target, GLenum query, GLsizei bufSize, GLint *v )
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_1d_map *map1d;
   struct gl_2d_map *map2d;
   GLuint i, n;
   GLfloat *data;
   GLuint comps;
   GLsizei numBytes;

   comps = _mesa_evaluator_components(target);
   if (!comps) {
      _mesa_error( ctx, GL_INVALID_ENUM, "glGetMapiv(target)" );
      return;
   }

   map1d = get_1d_map(ctx, target);
   map2d = get_2d_map(ctx, target);
   ASSERT(map1d || map2d);

   switch (query) {
      case GL_COEFF:
         if (map1d) {
            data = map1d->Points;
            n = map1d->Order * comps;
         }
         else {
            data = map2d->Points;
            n = map2d->Uorder * map2d->Vorder * comps;
         }
	 if (data) {
            numBytes = n * sizeof *v;
            if (bufSize < numBytes)
               goto overflow;
	    for (i=0;i<n;i++) {
	       v[i] = IROUND(data[i]);
	    }
	 }
         break;
      case GL_ORDER:
         if (map1d) {
            numBytes = 1 * sizeof *v;
            if (bufSize < numBytes)
               goto overflow;
            v[0] = map1d->Order;
         }
         else {
            numBytes = 2 * sizeof *v;
            if (bufSize < numBytes)
               goto overflow;
            v[0] = map2d->Uorder;
            v[1] = map2d->Vorder;
         }
         break;
      case GL_DOMAIN:
         if (map1d) {
            numBytes = 2 * sizeof *v;
            if (bufSize < numBytes)
               goto overflow;
            v[0] = IROUND(map1d->u1);
            v[1] = IROUND(map1d->u2);
         }
         else {
            numBytes = 4 * sizeof *v;
            if (bufSize < numBytes)
               goto overflow;
            v[0] = IROUND(map2d->u1);
            v[1] = IROUND(map2d->u2);
            v[2] = IROUND(map2d->v1);
            v[3] = IROUND(map2d->v2);
         }
         break;
      default:
         _mesa_error( ctx, GL_INVALID_ENUM, "glGetMapiv(query)" );
   }
   return;

overflow:
   _mesa_error( ctx, GL_INVALID_OPERATION,
               "glGetnMapivARB(out of bounds: bufSize is %d,"
               " but %d bytes are required)", bufSize, numBytes );
}


void GLAPIENTRY
_mesa_GetMapiv( GLenum target, GLenum query, GLint *v )
{
   _mesa_GetnMapivARB(target, query, INT_MAX, v);
}


void GLAPIENTRY
_mesa_MapGrid1f( GLint un, GLfloat u1, GLfloat u2 )
{
   GET_CURRENT_CONTEXT(ctx);

   if (un<1) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glMapGrid1f" );
      return;
   }
   FLUSH_VERTICES(ctx, _NEW_EVAL);
   ctx->Eval.MapGrid1un = un;
   ctx->Eval.MapGrid1u1 = u1;
   ctx->Eval.MapGrid1u2 = u2;
   ctx->Eval.MapGrid1du = (u2 - u1) / (GLfloat) un;
}


void GLAPIENTRY
_mesa_MapGrid1d( GLint un, GLdouble u1, GLdouble u2 )
{
   _mesa_MapGrid1f( un, (GLfloat) u1, (GLfloat) u2 );
}


void GLAPIENTRY
_mesa_MapGrid2f( GLint un, GLfloat u1, GLfloat u2,
                 GLint vn, GLfloat v1, GLfloat v2 )
{
   GET_CURRENT_CONTEXT(ctx);

   if (un<1) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glMapGrid2f(un)" );
      return;
   }
   if (vn<1) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glMapGrid2f(vn)" );
      return;
   }

   FLUSH_VERTICES(ctx, _NEW_EVAL);
   ctx->Eval.MapGrid2un = un;
   ctx->Eval.MapGrid2u1 = u1;
   ctx->Eval.MapGrid2u2 = u2;
   ctx->Eval.MapGrid2du = (u2 - u1) / (GLfloat) un;
   ctx->Eval.MapGrid2vn = vn;
   ctx->Eval.MapGrid2v1 = v1;
   ctx->Eval.MapGrid2v2 = v2;
   ctx->Eval.MapGrid2dv = (v2 - v1) / (GLfloat) vn;
}


void GLAPIENTRY
_mesa_MapGrid2d( GLint un, GLdouble u1, GLdouble u2,
                 GLint vn, GLdouble v1, GLdouble v2 )
{
   _mesa_MapGrid2f( un, (GLfloat) u1, (GLfloat) u2, 
		    vn, (GLfloat) v1, (GLfloat) v2 );
}


void
_mesa_install_eval_vtxfmt(struct _glapi_table *disp,
                          const GLvertexformat *vfmt)
{
   SET_EvalCoord1f(disp, vfmt->EvalCoord1f);
   SET_EvalCoord1fv(disp, vfmt->EvalCoord1fv);
   SET_EvalCoord2f(disp, vfmt->EvalCoord2f);
   SET_EvalCoord2fv(disp, vfmt->EvalCoord2fv);
   SET_EvalPoint1(disp, vfmt->EvalPoint1);
   SET_EvalPoint2(disp, vfmt->EvalPoint2);
}


/**********************************************************************/
/*****                      Initialization                        *****/
/**********************************************************************/

/**
 * Initialize a 1-D evaluator map.
 */
static void
init_1d_map( struct gl_1d_map *map, int n, const float *initial )
{
   map->Order = 1;
   map->u1 = 0.0;
   map->u2 = 1.0;
   map->Points = malloc(n * sizeof(GLfloat));
   if (map->Points) {
      GLint i;
      for (i=0;i<n;i++)
         map->Points[i] = initial[i];
   }
}


/**
 * Initialize a 2-D evaluator map 
 */
static void
init_2d_map( struct gl_2d_map *map, int n, const float *initial )
{
   map->Uorder = 1;
   map->Vorder = 1;
   map->u1 = 0.0;
   map->u2 = 1.0;
   map->v1 = 0.0;
   map->v2 = 1.0;
   map->Points = malloc(n * sizeof(GLfloat));
   if (map->Points) {
      GLint i;
      for (i=0;i<n;i++)
         map->Points[i] = initial[i];
   }
}


void _mesa_init_eval( struct gl_context *ctx )
{
   /* Evaluators group */
   ctx->Eval.Map1Color4 = GL_FALSE;
   ctx->Eval.Map1Index = GL_FALSE;
   ctx->Eval.Map1Normal = GL_FALSE;
   ctx->Eval.Map1TextureCoord1 = GL_FALSE;
   ctx->Eval.Map1TextureCoord2 = GL_FALSE;
   ctx->Eval.Map1TextureCoord3 = GL_FALSE;
   ctx->Eval.Map1TextureCoord4 = GL_FALSE;
   ctx->Eval.Map1Vertex3 = GL_FALSE;
   ctx->Eval.Map1Vertex4 = GL_FALSE;
   ctx->Eval.Map2Color4 = GL_FALSE;
   ctx->Eval.Map2Index = GL_FALSE;
   ctx->Eval.Map2Normal = GL_FALSE;
   ctx->Eval.Map2TextureCoord1 = GL_FALSE;
   ctx->Eval.Map2TextureCoord2 = GL_FALSE;
   ctx->Eval.Map2TextureCoord3 = GL_FALSE;
   ctx->Eval.Map2TextureCoord4 = GL_FALSE;
   ctx->Eval.Map2Vertex3 = GL_FALSE;
   ctx->Eval.Map2Vertex4 = GL_FALSE;
   ctx->Eval.AutoNormal = GL_FALSE;
   ctx->Eval.MapGrid1un = 1;
   ctx->Eval.MapGrid1u1 = 0.0;
   ctx->Eval.MapGrid1u2 = 1.0;
   ctx->Eval.MapGrid2un = 1;
   ctx->Eval.MapGrid2vn = 1;
   ctx->Eval.MapGrid2u1 = 0.0;
   ctx->Eval.MapGrid2u2 = 1.0;
   ctx->Eval.MapGrid2v1 = 0.0;
   ctx->Eval.MapGrid2v2 = 1.0;

   /* Evaluator data */
   {
      static GLfloat vertex[4] = { 0.0, 0.0, 0.0, 1.0 };
      static GLfloat normal[3] = { 0.0, 0.0, 1.0 };
      static GLfloat index[1] = { 1.0 };
      static GLfloat color[4] = { 1.0, 1.0, 1.0, 1.0 };
      static GLfloat texcoord[4] = { 0.0, 0.0, 0.0, 1.0 };

      init_1d_map( &ctx->EvalMap.Map1Vertex3, 3, vertex );
      init_1d_map( &ctx->EvalMap.Map1Vertex4, 4, vertex );
      init_1d_map( &ctx->EvalMap.Map1Index, 1, index );
      init_1d_map( &ctx->EvalMap.Map1Color4, 4, color );
      init_1d_map( &ctx->EvalMap.Map1Normal, 3, normal );
      init_1d_map( &ctx->EvalMap.Map1Texture1, 1, texcoord );
      init_1d_map( &ctx->EvalMap.Map1Texture2, 2, texcoord );
      init_1d_map( &ctx->EvalMap.Map1Texture3, 3, texcoord );
      init_1d_map( &ctx->EvalMap.Map1Texture4, 4, texcoord );

      init_2d_map( &ctx->EvalMap.Map2Vertex3, 3, vertex );
      init_2d_map( &ctx->EvalMap.Map2Vertex4, 4, vertex );
      init_2d_map( &ctx->EvalMap.Map2Index, 1, index );
      init_2d_map( &ctx->EvalMap.Map2Color4, 4, color );
      init_2d_map( &ctx->EvalMap.Map2Normal, 3, normal );
      init_2d_map( &ctx->EvalMap.Map2Texture1, 1, texcoord );
      init_2d_map( &ctx->EvalMap.Map2Texture2, 2, texcoord );
      init_2d_map( &ctx->EvalMap.Map2Texture3, 3, texcoord );
      init_2d_map( &ctx->EvalMap.Map2Texture4, 4, texcoord );
   }
}


void _mesa_free_eval_data( struct gl_context *ctx )
{
   /* Free evaluator data */
   free(ctx->EvalMap.Map1Vertex3.Points);
   free(ctx->EvalMap.Map1Vertex4.Points);
   free(ctx->EvalMap.Map1Index.Points);
   free(ctx->EvalMap.Map1Color4.Points);
   free(ctx->EvalMap.Map1Normal.Points);
   free(ctx->EvalMap.Map1Texture1.Points);
   free(ctx->EvalMap.Map1Texture2.Points);
   free(ctx->EvalMap.Map1Texture3.Points);
   free(ctx->EvalMap.Map1Texture4.Points);

   free(ctx->EvalMap.Map2Vertex3.Points);
   free(ctx->EvalMap.Map2Vertex4.Points);
   free(ctx->EvalMap.Map2Index.Points);
   free(ctx->EvalMap.Map2Color4.Points);
   free(ctx->EvalMap.Map2Normal.Points);
   free(ctx->EvalMap.Map2Texture1.Points);
   free(ctx->EvalMap.Map2Texture2.Points);
   free(ctx->EvalMap.Map2Texture3.Points);
   free(ctx->EvalMap.Map2Texture4.Points);
}
@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d42 1
@


1.5
log
@Merge Mesa 9.2.0
@
text
@a41 1
#include "colormac.h"
@


1.4
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a3 1
 * Version:  5.1
d20 4
a23 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
a45 1
#include "mfeatures.h"
a49 3
#if FEATURE_evaluators


a78 13
   /* XXX need to check for the vertex program extension
   if (!ctx->Extensions.NV_vertex_program)
      return 0;
   */

   if (target >= GL_MAP1_VERTEX_ATTRIB0_4_NV &&
       target <= GL_MAP1_VERTEX_ATTRIB15_4_NV)
      return 4;

   if (target >= GL_MAP2_VERTEX_ATTRIB0_4_NV &&
       target <= GL_MAP2_VERTEX_ATTRIB15_4_NV)
      return 4;

a107 19
      case GL_MAP1_VERTEX_ATTRIB0_4_NV:
      case GL_MAP1_VERTEX_ATTRIB1_4_NV:
      case GL_MAP1_VERTEX_ATTRIB2_4_NV:
      case GL_MAP1_VERTEX_ATTRIB3_4_NV:
      case GL_MAP1_VERTEX_ATTRIB4_4_NV:
      case GL_MAP1_VERTEX_ATTRIB5_4_NV:
      case GL_MAP1_VERTEX_ATTRIB6_4_NV:
      case GL_MAP1_VERTEX_ATTRIB7_4_NV:
      case GL_MAP1_VERTEX_ATTRIB8_4_NV:
      case GL_MAP1_VERTEX_ATTRIB9_4_NV:
      case GL_MAP1_VERTEX_ATTRIB10_4_NV:
      case GL_MAP1_VERTEX_ATTRIB11_4_NV:
      case GL_MAP1_VERTEX_ATTRIB12_4_NV:
      case GL_MAP1_VERTEX_ATTRIB13_4_NV:
      case GL_MAP1_VERTEX_ATTRIB14_4_NV:
      case GL_MAP1_VERTEX_ATTRIB15_4_NV:
         if (!ctx->Extensions.NV_vertex_program)
            return NULL;
         return &ctx->EvalMap.Map1Attrib[target - GL_MAP1_VERTEX_ATTRIB0_4_NV];
a138 19
      case GL_MAP2_VERTEX_ATTRIB0_4_NV:
      case GL_MAP2_VERTEX_ATTRIB1_4_NV:
      case GL_MAP2_VERTEX_ATTRIB2_4_NV:
      case GL_MAP2_VERTEX_ATTRIB3_4_NV:
      case GL_MAP2_VERTEX_ATTRIB4_4_NV:
      case GL_MAP2_VERTEX_ATTRIB5_4_NV:
      case GL_MAP2_VERTEX_ATTRIB6_4_NV:
      case GL_MAP2_VERTEX_ATTRIB7_4_NV:
      case GL_MAP2_VERTEX_ATTRIB8_4_NV:
      case GL_MAP2_VERTEX_ATTRIB9_4_NV:
      case GL_MAP2_VERTEX_ATTRIB10_4_NV:
      case GL_MAP2_VERTEX_ATTRIB11_4_NV:
      case GL_MAP2_VERTEX_ATTRIB12_4_NV:
      case GL_MAP2_VERTEX_ATTRIB13_4_NV:
      case GL_MAP2_VERTEX_ATTRIB14_4_NV:
      case GL_MAP2_VERTEX_ATTRIB15_4_NV:
         if (!ctx->Extensions.NV_vertex_program)
            return NULL;
         return &ctx->EvalMap.Map2Attrib[target - GL_MAP2_VERTEX_ATTRIB0_4_NV];
d166 1
a166 1
   buffer = (GLfloat *) MALLOC(uorder * size * sizeof(GLfloat));
d190 1
a190 1
   buffer = (GLfloat *) MALLOC(uorder * size * sizeof(GLfloat));
d234 1
a234 1
     buffer = (GLfloat *) MALLOC((uorder*vorder*size+hsize)*sizeof(GLfloat));
d236 1
a236 1
     buffer = (GLfloat *) MALLOC((uorder*vorder*size+dsize)*sizeof(GLfloat));
d277 1
a277 1
     buffer = (GLfloat *) MALLOC((uorder*vorder*size+hsize)*sizeof(GLfloat));
d279 1
a279 1
     buffer = (GLfloat *) MALLOC((uorder*vorder*size+dsize)*sizeof(GLfloat));
a312 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d331 1
d363 1
a363 2
   if (map->Points)
      FREE( map->Points );
d369 1
a369 1
static void GLAPIENTRY
d377 1
a377 1
static void GLAPIENTRY
a394 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d420 1
d462 1
a462 2
   if (map->Points)
      FREE( map->Points );
d467 1
a467 1
static void GLAPIENTRY
d478 1
a478 1
static void GLAPIENTRY
d490 1
a490 1
static void GLAPIENTRY
a500 2
   ASSERT_OUTSIDE_BEGIN_END(ctx);

d574 1
a574 1
static void GLAPIENTRY
d580 1
a580 1
static void GLAPIENTRY
a590 2
   ASSERT_OUTSIDE_BEGIN_END(ctx);

d665 1
a665 1
static void GLAPIENTRY
d672 1
a672 1
static void GLAPIENTRY
a682 2
   ASSERT_OUTSIDE_BEGIN_END(ctx);

d757 1
a757 1
static void GLAPIENTRY
d764 1
a764 1
static void GLAPIENTRY
a767 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d781 1
a781 1
static void GLAPIENTRY
d788 1
a788 1
static void GLAPIENTRY
a792 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d815 1
a815 1
static void GLAPIENTRY
a833 3

   SET_EvalMesh1(disp, vfmt->EvalMesh1);
   SET_EvalMesh2(disp, vfmt->EvalMesh2);
a836 25
void
_mesa_init_eval_dispatch(struct _glapi_table *disp)
{
   SET_GetMapdv(disp, _mesa_GetMapdv);
   SET_GetMapfv(disp, _mesa_GetMapfv);
   SET_GetMapiv(disp, _mesa_GetMapiv);
   SET_Map1d(disp, _mesa_Map1d);
   SET_Map1f(disp, _mesa_Map1f);
   SET_Map2d(disp, _mesa_Map2d);
   SET_Map2f(disp, _mesa_Map2f);
   SET_MapGrid1d(disp, _mesa_MapGrid1d);
   SET_MapGrid1f(disp, _mesa_MapGrid1f);
   SET_MapGrid2d(disp, _mesa_MapGrid2d);
   SET_MapGrid2f(disp, _mesa_MapGrid2f);

   /* GL_ARB_robustness */
   SET_GetnMapdvARB(disp, _mesa_GetnMapdvARB);
   SET_GetnMapfvARB(disp, _mesa_GetnMapfvARB);
   SET_GetnMapivARB(disp, _mesa_GetnMapivARB);
}


#endif /* FEATURE_evaluators */


d850 1
a850 1
   map->Points = (GLfloat *) MALLOC(n * sizeof(GLfloat));
d871 1
a871 1
   map->Points = (GLfloat *) MALLOC(n * sizeof(GLfloat));
a881 2
   int i;

a891 1
   memset(ctx->Eval.Map1Attrib, 0, sizeof(ctx->Eval.Map1Attrib));
a900 1
   memset(ctx->Eval.Map2Attrib, 0, sizeof(ctx->Eval.Map2Attrib));
a918 1
      static GLfloat attrib[4] = { 0.0, 0.0, 0.0, 1.0 };
a928 2
      for (i = 0; i < 16; i++)
         init_1d_map( ctx->EvalMap.Map1Attrib + i, 4, attrib );
a938 2
      for (i = 0; i < 16; i++)
         init_2d_map( ctx->EvalMap.Map2Attrib + i, 4, attrib );
a944 2
   int i;

d946 19
a964 41
   if (ctx->EvalMap.Map1Vertex3.Points)
      FREE( ctx->EvalMap.Map1Vertex3.Points );
   if (ctx->EvalMap.Map1Vertex4.Points)
      FREE( ctx->EvalMap.Map1Vertex4.Points );
   if (ctx->EvalMap.Map1Index.Points)
      FREE( ctx->EvalMap.Map1Index.Points );
   if (ctx->EvalMap.Map1Color4.Points)
      FREE( ctx->EvalMap.Map1Color4.Points );
   if (ctx->EvalMap.Map1Normal.Points)
      FREE( ctx->EvalMap.Map1Normal.Points );
   if (ctx->EvalMap.Map1Texture1.Points)
      FREE( ctx->EvalMap.Map1Texture1.Points );
   if (ctx->EvalMap.Map1Texture2.Points)
      FREE( ctx->EvalMap.Map1Texture2.Points );
   if (ctx->EvalMap.Map1Texture3.Points)
      FREE( ctx->EvalMap.Map1Texture3.Points );
   if (ctx->EvalMap.Map1Texture4.Points)
      FREE( ctx->EvalMap.Map1Texture4.Points );
   for (i = 0; i < 16; i++)
      FREE((ctx->EvalMap.Map1Attrib[i].Points));

   if (ctx->EvalMap.Map2Vertex3.Points)
      FREE( ctx->EvalMap.Map2Vertex3.Points );
   if (ctx->EvalMap.Map2Vertex4.Points)
      FREE( ctx->EvalMap.Map2Vertex4.Points );
   if (ctx->EvalMap.Map2Index.Points)
      FREE( ctx->EvalMap.Map2Index.Points );
   if (ctx->EvalMap.Map2Color4.Points)
      FREE( ctx->EvalMap.Map2Color4.Points );
   if (ctx->EvalMap.Map2Normal.Points)
      FREE( ctx->EvalMap.Map2Normal.Points );
   if (ctx->EvalMap.Map2Texture1.Points)
      FREE( ctx->EvalMap.Map2Texture1.Points );
   if (ctx->EvalMap.Map2Texture2.Points)
      FREE( ctx->EvalMap.Map2Texture2.Points );
   if (ctx->EvalMap.Map2Texture3.Points)
      FREE( ctx->EvalMap.Map2Texture3.Points );
   if (ctx->EvalMap.Map2Texture4.Points)
      FREE( ctx->EvalMap.Map2Texture4.Points );
   for (i = 0; i < 16; i++)
      FREE((ctx->EvalMap.Map2Attrib[i].Points));
@


1.3
log
@Merge Mesa 7.10.3
@
text
@d46 1
d548 1
a548 1
_mesa_GetMapdv( GLenum target, GLenum query, GLdouble *v )
d556 1
d581 3
d591 3
d597 3
d606 3
d613 3
d625 6
d633 5
d640 1
a640 1
_mesa_GetMapfv( GLenum target, GLenum query, GLfloat *v )
d648 1
d673 3
d683 3
d689 3
d698 3
d705 3
d717 13
d734 1
a734 1
_mesa_GetMapiv( GLenum target, GLenum query, GLint *v )
d742 1
d767 3
d777 3
d783 3
d792 3
d799 3
d811 6
d820 6
d919 5
@


1.2
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d103 1
a103 1
get_1d_map( GLcontext *ctx, GLenum target )
d153 1
a153 1
get_2d_map( GLcontext *ctx, GLenum target )
d883 1
a883 1
void _mesa_init_eval( GLcontext *ctx )
d955 1
a955 1
void _mesa_free_eval_data( GLcontext *ctx )
@


1.1
log
@Initial revision
@
text
@d47 4
d424 1
a424 1
void GLAPIENTRY
d432 1
a432 1
void GLAPIENTRY
d523 1
a523 1
void GLAPIENTRY
d534 1
a534 1
void GLAPIENTRY
d546 1
a546 1
void GLAPIENTRY
d611 1
a611 1
void GLAPIENTRY
d676 1
a676 1
void GLAPIENTRY
d742 1
a742 1
void GLAPIENTRY
d760 1
a760 1
void GLAPIENTRY
d767 1
a767 1
void GLAPIENTRY
d795 1
a795 1
void GLAPIENTRY
d804 35
d897 1
a897 1
   MEMSET(ctx->Eval.Map1Attrib, 0, sizeof(ctx->Eval.Map1Attrib));
d907 1
a907 1
   MEMSET(ctx->Eval.Map2Attrib, 0, sizeof(ctx->Eval.Map2Attrib));
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@Import Mesa 7.10.3
@
text
@a46 4
#include "main/dispatch.h"


#if FEATURE_evaluators
d99 1
a99 1
get_1d_map( struct gl_context *ctx, GLenum target )
d149 1
a149 1
get_2d_map( struct gl_context *ctx, GLenum target )
d420 1
a420 1
static void GLAPIENTRY
d428 1
a428 1
static void GLAPIENTRY
d519 1
a519 1
static void GLAPIENTRY
d530 1
a530 1
static void GLAPIENTRY
d542 1
a542 1
static void GLAPIENTRY
d607 1
a607 1
static void GLAPIENTRY
d672 1
a672 1
static void GLAPIENTRY
d738 1
a738 1
static void GLAPIENTRY
d756 1
a756 1
static void GLAPIENTRY
d763 1
a763 1
static void GLAPIENTRY
d791 1
a791 1
static void GLAPIENTRY
a799 35
void
_mesa_install_eval_vtxfmt(struct _glapi_table *disp,
                          const GLvertexformat *vfmt)
{
   SET_EvalCoord1f(disp, vfmt->EvalCoord1f);
   SET_EvalCoord1fv(disp, vfmt->EvalCoord1fv);
   SET_EvalCoord2f(disp, vfmt->EvalCoord2f);
   SET_EvalCoord2fv(disp, vfmt->EvalCoord2fv);
   SET_EvalPoint1(disp, vfmt->EvalPoint1);
   SET_EvalPoint2(disp, vfmt->EvalPoint2);

   SET_EvalMesh1(disp, vfmt->EvalMesh1);
   SET_EvalMesh2(disp, vfmt->EvalMesh2);
}


void
_mesa_init_eval_dispatch(struct _glapi_table *disp)
{
   SET_GetMapdv(disp, _mesa_GetMapdv);
   SET_GetMapfv(disp, _mesa_GetMapfv);
   SET_GetMapiv(disp, _mesa_GetMapiv);
   SET_Map1d(disp, _mesa_Map1d);
   SET_Map1f(disp, _mesa_Map1f);
   SET_Map2d(disp, _mesa_Map2d);
   SET_Map2f(disp, _mesa_Map2f);
   SET_MapGrid1d(disp, _mesa_MapGrid1d);
   SET_MapGrid1f(disp, _mesa_MapGrid1f);
   SET_MapGrid2d(disp, _mesa_MapGrid2d);
   SET_MapGrid2f(disp, _mesa_MapGrid2f);
}


#endif /* FEATURE_evaluators */

d844 1
a844 1
void _mesa_init_eval( struct gl_context *ctx )
d858 1
a858 1
   memset(ctx->Eval.Map1Attrib, 0, sizeof(ctx->Eval.Map1Attrib));
d868 1
a868 1
   memset(ctx->Eval.Map2Attrib, 0, sizeof(ctx->Eval.Map2Attrib));
d916 1
a916 1
void _mesa_free_eval_data( struct gl_context *ctx )
@


1.1.1.3
log
@Import Mesa 9.2.0
@
text
@d4 1
d21 3
a23 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
d50 3
d82 13
d124 19
d174 19
d220 1
a220 1
   buffer = malloc(uorder * size * sizeof(GLfloat));
d244 1
a244 1
   buffer = malloc(uorder * size * sizeof(GLfloat));
d288 1
a288 1
     buffer = malloc((uorder*vorder*size+hsize)*sizeof(GLfloat));
d290 1
a290 1
     buffer = malloc((uorder*vorder*size+dsize)*sizeof(GLfloat));
d331 1
a331 1
     buffer = malloc((uorder*vorder*size+hsize)*sizeof(GLfloat));
d333 1
a333 1
     buffer = malloc((uorder*vorder*size+dsize)*sizeof(GLfloat));
d367 1
a385 1
      return;
d417 2
a418 1
   free(map->Points);
d424 1
a424 1
void GLAPIENTRY
d432 1
a432 1
void GLAPIENTRY
d450 1
a475 1
      return;
d517 2
a518 1
   free(map->Points);
d523 1
a523 1
void GLAPIENTRY
d534 1
a534 1
void GLAPIENTRY
d546 2
a547 2
void GLAPIENTRY
_mesa_GetnMapdvARB( GLenum target, GLenum query, GLsizei bufSize, GLdouble *v )
d555 2
a556 1
   GLsizei numBytes;
a578 3
            numBytes = n * sizeof *v;
            if (bufSize < numBytes)
               goto overflow;
a585 3
            numBytes = 1 * sizeof *v;
            if (bufSize < numBytes)
               goto overflow;
a588 3
            numBytes = 2 * sizeof *v;
            if (bufSize < numBytes)
               goto overflow;
a594 3
            numBytes = 2 * sizeof *v;
            if (bufSize < numBytes)
              goto overflow;
a598 3
            numBytes = 4 * sizeof *v;
            if (bufSize < numBytes)
               goto overflow;
a607 6
   return;

overflow:
   _mesa_error( ctx, GL_INVALID_OPERATION,
               "glGetnMapdvARB(out of bounds: bufSize is %d,"
               " but %d bytes are required)", bufSize, numBytes );
a609 5
void GLAPIENTRY
_mesa_GetMapdv( GLenum target, GLenum query, GLdouble *v )
{
   _mesa_GetnMapdvARB(target, query, INT_MAX, v);
}
d611 2
a612 2
void GLAPIENTRY
_mesa_GetnMapfvARB( GLenum target, GLenum query, GLsizei bufSize, GLfloat *v )
d620 2
a621 1
   GLsizei numBytes;
a643 3
            numBytes = n * sizeof *v;
            if (bufSize < numBytes)
               goto overflow;
a650 3
            numBytes = 1 * sizeof *v;
            if (bufSize < numBytes)
               goto overflow;
a653 3
            numBytes = 2 * sizeof *v;
            if (bufSize < numBytes)
               goto overflow;
a659 3
            numBytes = 2 * sizeof *v;
            if (bufSize < numBytes)
               goto overflow;
a663 3
            numBytes = 4 * sizeof *v;
            if (bufSize < numBytes)
               goto overflow;
a672 6
   return;

overflow:
   _mesa_error( ctx, GL_INVALID_OPERATION,
               "glGetnMapfvARB(out of bounds: bufSize is %d,"
               " but %d bytes are required)", bufSize, numBytes );
d676 2
a677 9
void GLAPIENTRY
_mesa_GetMapfv( GLenum target, GLenum query, GLfloat *v )
{
   _mesa_GetnMapfvARB(target, query, INT_MAX, v);
}


void GLAPIENTRY
_mesa_GetnMapivARB( GLenum target, GLenum query, GLsizei bufSize, GLint *v )
d685 2
a686 1
   GLsizei numBytes;
a708 3
            numBytes = n * sizeof *v;
            if (bufSize < numBytes)
               goto overflow;
a715 3
            numBytes = 1 * sizeof *v;
            if (bufSize < numBytes)
               goto overflow;
a718 3
            numBytes = 2 * sizeof *v;
            if (bufSize < numBytes)
               goto overflow;
a724 3
            numBytes = 2 * sizeof *v;
            if (bufSize < numBytes)
               goto overflow;
a728 3
            numBytes = 4 * sizeof *v;
            if (bufSize < numBytes)
               goto overflow;
a737 6
   return;

overflow:
   _mesa_error( ctx, GL_INVALID_OPERATION,
               "glGetnMapivARB(out of bounds: bufSize is %d,"
               " but %d bytes are required)", bufSize, numBytes );
a740 5
void GLAPIENTRY
_mesa_GetMapiv( GLenum target, GLenum query, GLint *v )
{
   _mesa_GetnMapivARB(target, query, INT_MAX, v);
}
d742 1
a742 2

void GLAPIENTRY
d746 1
d760 1
a760 1
void GLAPIENTRY
d767 1
a767 1
void GLAPIENTRY
d772 1
d795 1
a795 1
void GLAPIENTRY
d814 3
d820 20
d853 1
a853 1
   map->Points = malloc(n * sizeof(GLfloat));
d874 1
a874 1
   map->Points = malloc(n * sizeof(GLfloat));
d885 2
d897 1
d907 1
d926 1
d937 2
d949 2
d957 2
d960 41
a1000 19
   free(ctx->EvalMap.Map1Vertex3.Points);
   free(ctx->EvalMap.Map1Vertex4.Points);
   free(ctx->EvalMap.Map1Index.Points);
   free(ctx->EvalMap.Map1Color4.Points);
   free(ctx->EvalMap.Map1Normal.Points);
   free(ctx->EvalMap.Map1Texture1.Points);
   free(ctx->EvalMap.Map1Texture2.Points);
   free(ctx->EvalMap.Map1Texture3.Points);
   free(ctx->EvalMap.Map1Texture4.Points);

   free(ctx->EvalMap.Map2Vertex3.Points);
   free(ctx->EvalMap.Map2Vertex4.Points);
   free(ctx->EvalMap.Map2Index.Points);
   free(ctx->EvalMap.Map2Color4.Points);
   free(ctx->EvalMap.Map2Normal.Points);
   free(ctx->EvalMap.Map2Texture1.Points);
   free(ctx->EvalMap.Map2Texture2.Points);
   free(ctx->EvalMap.Map2Texture3.Points);
   free(ctx->EvalMap.Map2Texture4.Points);
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d42 1
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@a41 1
#include "colormac.h"
@


