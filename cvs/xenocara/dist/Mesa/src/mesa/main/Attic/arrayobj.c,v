head	1.11;
access;
symbols
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	v10_2_9:1.1.1.7
	v10_4_3:1.1.1.6
	v10_2_7:1.1.1.5
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	v10_2_3:1.1.1.5
	OPENBSD_5_5:1.7.0.2
	OPENBSD_5_5_BASE:1.7
	v9_2_5:1.1.1.4
	v9_2_3:1.1.1.4
	v9_2_2:1.1.1.4
	v9_2_1:1.1.1.4
	v9_2_0:1.1.1.4
	OPENBSD_5_4:1.6.0.4
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	v7_10_3:1.1.1.3
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v7_0_1:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v6_5_2:1.1.1.1
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2015.12.23.05.17.52;	author jsg;	state dead;
branches;
next	1.10;
commitid	TnlogFl9nOv2eaRf;

1.10
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.9;
commitid	4ry2gvZGMXkCUD2n;

1.9
date	2015.01.25.14.41.21;	author jsg;	state Exp;
branches;
next	1.8;
commitid	mcxB0JvoI9gTDYXU;

1.8
date	2014.07.09.21.09.00;	author jsg;	state Exp;
branches;
next	1.7;
commitid	WPD6rgPryPkvXOr9;

1.7
date	2013.09.05.14.06.15;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2012.08.17.13.58.17;	author mpi;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.23.13.37.42;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.30;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.41;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.20;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.49.42;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.49.42;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.30.47;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.10.23.13.29.45;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.09.05.13.16.23;	author jsg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2014.07.09.20.34.58;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.6
date	2015.01.25.14.12.25;	author jsg;	state Exp;
branches;
next	1.1.1.7;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.7
date	2015.02.20.22.49.32;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.11
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2008  Brian Paul   All Rights Reserved.
 * (C) Copyright IBM Corporation 2006
 * Copyright (C) 2009  VMware, Inc.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */


/**
 * \file arrayobj.c
 *
 * Implementation of Vertex Array Objects (VAOs), from OpenGL 3.1+,
 * the GL_ARB_vertex_array_object extension, or the older
 * GL_APPLE_vertex_array_object extension.
 *
 * \todo
 * The code in this file borrows a lot from bufferobj.c.  There's a certain
 * amount of cruft left over from that origin that may be unnecessary.
 *
 * \author Ian Romanick <idr@@us.ibm.com>
 * \author Brian Paul
 */


#include "glheader.h"
#include "hash.h"
#include "image.h"
#include "imports.h"
#include "context.h"
#include "bufferobj.h"
#include "arrayobj.h"
#include "macros.h"
#include "mtypes.h"
#include "varray.h"
#include "main/dispatch.h"


/**
 * Look up the array object for the given ID.
 *
 * \returns
 * Either a pointer to the array object with the specified ID or \c NULL for
 * a non-existent ID.  The spec defines ID 0 as being technically
 * non-existent.
 */

struct gl_vertex_array_object *
_mesa_lookup_vao(struct gl_context *ctx, GLuint id)
{
   if (id == 0)
      return NULL;
   else
      return (struct gl_vertex_array_object *)
         _mesa_HashLookup(ctx->Array.Objects, id);
}


/**
 * For all the vertex binding points in the array object, unbind any pointers
 * to any buffer objects (VBOs).
 * This is done just prior to array object destruction.
 */
static void
unbind_array_object_vbos(struct gl_context *ctx, struct gl_vertex_array_object *obj)
{
   GLuint i;

   for (i = 0; i < Elements(obj->VertexBinding); i++)
      _mesa_reference_buffer_object(ctx, &obj->VertexBinding[i].BufferObj, NULL);

   for (i = 0; i < Elements(obj->_VertexAttrib); i++)
      _mesa_reference_buffer_object(ctx, &obj->_VertexAttrib[i].BufferObj, NULL);
}


/**
 * Allocate and initialize a new vertex array object.
 *
 * This function is intended to be called via
 * \c dd_function_table::NewArrayObject.
 */
struct gl_vertex_array_object *
_mesa_new_vao(struct gl_context *ctx, GLuint name)
{
   struct gl_vertex_array_object *obj = CALLOC_STRUCT(gl_vertex_array_object);
   if (obj)
      _mesa_initialize_vao(ctx, obj, name);
   return obj;
}


/**
 * Delete an array object.
 *
 * This function is intended to be called via
 * \c dd_function_table::DeleteArrayObject.
 */
void
_mesa_delete_vao(struct gl_context *ctx, struct gl_vertex_array_object *obj)
{
   unbind_array_object_vbos(ctx, obj);
   _mesa_reference_buffer_object(ctx, &obj->IndexBufferObj, NULL);
   mtx_destroy(&obj->Mutex);
   free(obj->Label);
   free(obj);
}


/**
 * Set ptr to vao w/ reference counting.
 * Note: this should only be called from the _mesa_reference_vao()
 * inline function.
 */
void
_mesa_reference_vao_(struct gl_context *ctx,
                     struct gl_vertex_array_object **ptr,
                     struct gl_vertex_array_object *vao)
{
   assert(*ptr != vao);

   if (*ptr) {
      /* Unreference the old array object */
      GLboolean deleteFlag = GL_FALSE;
      struct gl_vertex_array_object *oldObj = *ptr;

      mtx_lock(&oldObj->Mutex);
      ASSERT(oldObj->RefCount > 0);
      oldObj->RefCount--;
#if 0
      printf("ArrayObj %p %d DECR to %d\n",
             (void *) oldObj, oldObj->Name, oldObj->RefCount);
#endif
      deleteFlag = (oldObj->RefCount == 0);
      mtx_unlock(&oldObj->Mutex);

      if (deleteFlag) {
	 ASSERT(ctx->Driver.DeleteArrayObject);
         ctx->Driver.DeleteArrayObject(ctx, oldObj);
      }

      *ptr = NULL;
   }
   ASSERT(!*ptr);

   if (vao) {
      /* reference new array object */
      mtx_lock(&vao->Mutex);
      if (vao->RefCount == 0) {
         /* this array's being deleted (look just above) */
         /* Not sure this can every really happen.  Warn if it does. */
         _mesa_problem(NULL, "referencing deleted array object");
         *ptr = NULL;
      }
      else {
         vao->RefCount++;
#if 0
         printf("ArrayObj %p %d INCR to %d\n",
                (void *) vao, vao->Name, vao->RefCount);
#endif
         *ptr = vao;
      }
      mtx_unlock(&vao->Mutex);
   }
}



static void
init_array(struct gl_context *ctx,
           struct gl_vertex_array_object *obj, GLuint index, GLint size, GLint type)
{
   struct gl_vertex_attrib_array *array = &obj->VertexAttrib[index];
   struct gl_vertex_buffer_binding *binding = &obj->VertexBinding[index];

   array->Size = size;
   array->Type = type;
   array->Format = GL_RGBA; /* only significant for GL_EXT_vertex_array_bgra */
   array->Stride = 0;
   array->Ptr = NULL;
   array->RelativeOffset = 0;
   array->Enabled = GL_FALSE;
   array->Normalized = GL_FALSE;
   array->Integer = GL_FALSE;
   array->_ElementSize = size * _mesa_sizeof_type(type);
   array->VertexBinding = index;

   binding->Offset = 0;
   binding->Stride = array->_ElementSize;
   binding->BufferObj = NULL;
   binding->_BoundArrays = BITFIELD64_BIT(index);

   /* Vertex array buffers */
   _mesa_reference_buffer_object(ctx, &binding->BufferObj,
                                 ctx->Shared->NullBufferObj);
}


/**
 * Initialize a gl_vertex_array_object's arrays.
 */
void
_mesa_initialize_vao(struct gl_context *ctx,
                     struct gl_vertex_array_object *obj,
                     GLuint name)
{
   GLuint i;

   obj->Name = name;

   mtx_init(&obj->Mutex, mtx_plain);
   obj->RefCount = 1;

   /* Init the individual arrays */
   for (i = 0; i < Elements(obj->_VertexAttrib); i++) {
      switch (i) {
      case VERT_ATTRIB_WEIGHT:
         init_array(ctx, obj, VERT_ATTRIB_WEIGHT, 1, GL_FLOAT);
         break;
      case VERT_ATTRIB_NORMAL:
         init_array(ctx, obj, VERT_ATTRIB_NORMAL, 3, GL_FLOAT);
         break;
      case VERT_ATTRIB_COLOR1:
         init_array(ctx, obj, VERT_ATTRIB_COLOR1, 3, GL_FLOAT);
         break;
      case VERT_ATTRIB_FOG:
         init_array(ctx, obj, VERT_ATTRIB_FOG, 1, GL_FLOAT);
         break;
      case VERT_ATTRIB_COLOR_INDEX:
         init_array(ctx, obj, VERT_ATTRIB_COLOR_INDEX, 1, GL_FLOAT);
         break;
      case VERT_ATTRIB_EDGEFLAG:
         init_array(ctx, obj, VERT_ATTRIB_EDGEFLAG, 1, GL_BOOL);
         break;
      case VERT_ATTRIB_POINT_SIZE:
         init_array(ctx, obj, VERT_ATTRIB_POINT_SIZE, 1, GL_FLOAT);
         break;
      default:
         init_array(ctx, obj, i, 4, GL_FLOAT);
         break;
      }
   }

   _mesa_reference_buffer_object(ctx, &obj->IndexBufferObj,
                                 ctx->Shared->NullBufferObj);
}


/**
 * Add the given array object to the array object pool.
 */
static void
save_array_object( struct gl_context *ctx, struct gl_vertex_array_object *obj )
{
   if (obj->Name > 0) {
      /* insert into hash table */
      _mesa_HashInsert(ctx->Array.Objects, obj->Name, obj);
   }
}


/**
 * Remove the given array object from the array object pool.
 * Do not deallocate the array object though.
 */
static void
remove_array_object( struct gl_context *ctx, struct gl_vertex_array_object *obj )
{
   if (obj->Name > 0) {
      /* remove from hash table */
      _mesa_HashRemove(ctx->Array.Objects, obj->Name);
   }
}



/**
 * Helper for _mesa_update_vao_max_element().
 * \return  min(vao->_VertexAttrib[*]._MaxElement).
 */
static GLuint
compute_max_element(struct gl_vertex_array_object *vao, GLbitfield64 enabled)
{
   GLuint min = ~((GLuint)0);

   while (enabled) {
      struct gl_client_array *client_array;
      GLint attrib = ffsll(enabled) - 1;
      enabled ^= BITFIELD64_BIT(attrib);

      client_array = &vao->_VertexAttrib[attrib];
      assert(client_array->Enabled);
      _mesa_update_array_max_element(client_array);
      min = MIN2(min, client_array->_MaxElement);
   }

   return min;
}


/**
 * Examine vertex arrays to update the gl_vertex_array_object::_MaxElement field.
 */
void
_mesa_update_vao_max_element(struct gl_context *ctx,
                                      struct gl_vertex_array_object *vao)
{
   GLbitfield64 enabled;

   if (!ctx->VertexProgram._Current ||
       ctx->VertexProgram._Current == ctx->VertexProgram._TnlProgram) {
      enabled = _mesa_array_object_get_enabled_ff(vao);
   } else {
      enabled = _mesa_array_object_get_enabled_arb(vao);
   }

   /* _MaxElement is one past the last legal array element */
   vao->_MaxElement = compute_max_element(vao, enabled);
}


/**
 * Updates the derived gl_client_arrays when a gl_vertex_attrib_array
 * or a gl_vertex_buffer_binding has changed.
 */
void
_mesa_update_vao_client_arrays(struct gl_context *ctx,
                               struct gl_vertex_array_object *vao)
{
   GLbitfield64 arrays = vao->NewArrays;

   while (arrays) {
      struct gl_client_array *client_array;
      struct gl_vertex_attrib_array *attrib_array;
      struct gl_vertex_buffer_binding *buffer_binding;

      GLint attrib = ffsll(arrays) - 1;
      arrays ^= BITFIELD64_BIT(attrib);

      attrib_array = &vao->VertexAttrib[attrib];
      buffer_binding = &vao->VertexBinding[attrib_array->VertexBinding];
      client_array = &vao->_VertexAttrib[attrib];

      _mesa_update_client_array(ctx, client_array, attrib_array,
                                buffer_binding);
   }
}


/**********************************************************************/
/* API Functions                                                      */
/**********************************************************************/


/**
 * Helper for _mesa_BindVertexArray() and _mesa_BindVertexArrayAPPLE().
 * \param genRequired  specifies behavour when id was not generated with
 *                     glGenVertexArrays().
 */
static void
bind_vertex_array(struct gl_context *ctx, GLuint id, GLboolean genRequired)
{
   struct gl_vertex_array_object * const oldObj = ctx->Array.VAO;
   struct gl_vertex_array_object *newObj = NULL;

   ASSERT(oldObj != NULL);

   if ( oldObj->Name == id )
      return;   /* rebinding the same array object- no change */

   /*
    * Get pointer to new array object (newObj)
    */
   if (id == 0) {
      /* The spec says there is no array object named 0, but we use
       * one internally because it simplifies things.
       */
      newObj = ctx->Array.DefaultVAO;
   }
   else {
      /* non-default array object */
      newObj = _mesa_lookup_vao(ctx, id);
      if (!newObj) {
         if (genRequired) {
            _mesa_error(ctx, GL_INVALID_OPERATION,
                        "glBindVertexArray(non-gen name)");
            return;
         }

         /* For APPLE version, generate a new array object now */
	 newObj = (*ctx->Driver.NewArrayObject)(ctx, id);
         if (!newObj) {
            _mesa_error(ctx, GL_OUT_OF_MEMORY, "glBindVertexArrayAPPLE");
            return;
         }

         save_array_object(ctx, newObj);
      }

      if (!newObj->EverBound) {
         /* The "Interactions with APPLE_vertex_array_object" section of the
          * GL_ARB_vertex_array_object spec says:
          *
          *     "The first bind call, either BindVertexArray or
          *     BindVertexArrayAPPLE, determines the semantic of the object."
          */
         newObj->ARBsemantics = genRequired;
         newObj->EverBound = GL_TRUE;
      }
   }

   ctx->NewState |= _NEW_ARRAY;
   _mesa_reference_vao(ctx, &ctx->Array.VAO, newObj);

   /* Pass BindVertexArray call to device driver */
   if (ctx->Driver.BindArrayObject && newObj)
      ctx->Driver.BindArrayObject(ctx, newObj);
}


/**
 * ARB version of glBindVertexArray()
 * This function behaves differently from glBindVertexArrayAPPLE() in
 * that this function requires all ids to have been previously generated
 * by glGenVertexArrays[APPLE]().
 */
void GLAPIENTRY
_mesa_BindVertexArray( GLuint id )
{
   GET_CURRENT_CONTEXT(ctx);
   bind_vertex_array(ctx, id, GL_TRUE);
}


/**
 * Bind a new array.
 *
 * \todo
 * The binding could be done more efficiently by comparing the non-NULL
 * pointers in the old and new objects.  The only arrays that are "dirty" are
 * the ones that are non-NULL in either object.
 */
void GLAPIENTRY
_mesa_BindVertexArrayAPPLE( GLuint id )
{
   GET_CURRENT_CONTEXT(ctx);
   bind_vertex_array(ctx, id, GL_FALSE);
}


/**
 * Delete a set of array objects.
 *
 * \param n      Number of array objects to delete.
 * \param ids    Array of \c n array object IDs.
 */
void GLAPIENTRY
_mesa_DeleteVertexArrays(GLsizei n, const GLuint *ids)
{
   GET_CURRENT_CONTEXT(ctx);
   GLsizei i;

   if (n < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glDeleteVertexArray(n)");
      return;
   }

   for (i = 0; i < n; i++) {
      struct gl_vertex_array_object *obj = _mesa_lookup_vao(ctx, ids[i]);

      if ( obj != NULL ) {
	 ASSERT( obj->Name == ids[i] );

	 /* If the array object is currently bound, the spec says "the binding
	  * for that object reverts to zero and the default vertex array
	  * becomes current."
	  */
	 if ( obj == ctx->Array.VAO ) {
	    _mesa_BindVertexArray(0);
	 }

	 /* The ID is immediately freed for re-use */
	 remove_array_object(ctx, obj);

         /* Unreference the array object. 
          * If refcount hits zero, the object will be deleted.
          */
         _mesa_reference_vao(ctx, &obj, NULL);
      }
   }
}


/**
 * Generate a set of unique array object IDs and store them in \c arrays.
 * Helper for _mesa_GenVertexArrays[APPLE]() functions below.
 * \param n       Number of IDs to generate.
 * \param arrays  Array of \c n locations to store the IDs.
 * \param vboOnly Will arrays have to reside in VBOs?
 */
static void
gen_vertex_arrays(struct gl_context *ctx, GLsizei n, GLuint *arrays)
{
   GLuint first;
   GLint i;

   if (n < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glGenVertexArrays");
      return;
   }

   if (!arrays) {
      return;
   }

   first = _mesa_HashFindFreeKeyBlock(ctx->Array.Objects, n);

   /* Allocate new, empty array objects and return identifiers */
   for (i = 0; i < n; i++) {
      struct gl_vertex_array_object *obj;
      GLuint name = first + i;

      obj = (*ctx->Driver.NewArrayObject)( ctx, name );
      if (!obj) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glGenVertexArrays");
         return;
      }
      save_array_object(ctx, obj);
      arrays[i] = first + i;
   }
}


/**
 * ARB version of glGenVertexArrays()
 * All arrays will be required to live in VBOs.
 */
void GLAPIENTRY
_mesa_GenVertexArrays(GLsizei n, GLuint *arrays)
{
   GET_CURRENT_CONTEXT(ctx);
   gen_vertex_arrays(ctx, n, arrays);
}


/**
 * APPLE version of glGenVertexArraysAPPLE()
 * Arrays may live in VBOs or ordinary memory.
 */
void GLAPIENTRY
_mesa_GenVertexArraysAPPLE(GLsizei n, GLuint *arrays)
{
   GET_CURRENT_CONTEXT(ctx);
   gen_vertex_arrays(ctx, n, arrays);
}


/**
 * Determine if ID is the name of an array object.
 *
 * \param id  ID of the potential array object.
 * \return  \c GL_TRUE if \c id is the name of a array object,
 *          \c GL_FALSE otherwise.
 */
GLboolean GLAPIENTRY
_mesa_IsVertexArray( GLuint id )
{
   struct gl_vertex_array_object * obj;
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_WITH_RETVAL(ctx, GL_FALSE);

   if (id == 0)
      return GL_FALSE;

   obj = _mesa_lookup_vao(ctx, id);
   if (obj == NULL)
      return GL_FALSE;

   return obj->EverBound;
}
@


1.10
log
@Merge Mesa 10.2.9
@
text
@@


1.9
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d233 1
a233 1
   for (i = 0; i < Elements(obj->VertexAttrib); i++) {
d294 46
a427 15
   }

   if (ctx->Array.DrawMethod == DRAW_ARRAYS) {
      /* The _DrawArrays pointer is pointing at the VAO being unbound and
       * that VAO may be in the process of being deleted. If it's not going
       * to be deleted, this will have no effect, because the pointer needs
       * to be updated by the VBO module anyway.
       *
       * Before the VBO module can update the pointer, we have to set it
       * to NULL for drivers not to set up arrays which are not bound,
       * or to prevent a crash if the VAO being unbound is going to be
       * deleted.
       */
      ctx->Array._DrawArrays = NULL;
      ctx->Array.DrawMethod = DRAW_NONE;
@


1.8
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d233 1
a233 1
   for (i = 0; i < Elements(obj->_VertexAttrib); i++) {
a293 46

/**
 * Helper for _mesa_update_vao_max_element().
 * \return  min(vao->_VertexAttrib[*]._MaxElement).
 */
static GLuint
compute_max_element(struct gl_vertex_array_object *vao, GLbitfield64 enabled)
{
   GLuint min = ~((GLuint)0);

   while (enabled) {
      struct gl_client_array *client_array;
      GLint attrib = ffsll(enabled) - 1;
      enabled ^= BITFIELD64_BIT(attrib);

      client_array = &vao->_VertexAttrib[attrib];
      assert(client_array->Enabled);
      _mesa_update_array_max_element(client_array);
      min = MIN2(min, client_array->_MaxElement);
   }

   return min;
}


/**
 * Examine vertex arrays to update the gl_vertex_array_object::_MaxElement field.
 */
void
_mesa_update_vao_max_element(struct gl_context *ctx,
                                      struct gl_vertex_array_object *vao)
{
   GLbitfield64 enabled;

   if (!ctx->VertexProgram._Current ||
       ctx->VertexProgram._Current == ctx->VertexProgram._TnlProgram) {
      enabled = _mesa_array_object_get_enabled_ff(vao);
   } else {
      enabled = _mesa_array_object_get_enabled_arb(vao);
   }

   /* _MaxElement is one past the last legal array element */
   vao->_MaxElement = compute_max_element(vao, enabled);
}


d382 15
@


1.7
log
@Merge Mesa 9.2.0
@
text
@d30 4
a33 1
 * Functions for the GL_APPLE_vertex_array_object extension.
d59 1
a59 1
 * 
d66 2
a67 2
static inline struct gl_array_object *
lookup_arrayobj(struct gl_context *ctx, GLuint id)
d72 1
a72 1
      return (struct gl_array_object *)
d78 1
a78 1
 * For all the vertex arrays in the array object, unbind any pointers
d83 1
a83 1
unbind_array_object_vbos(struct gl_context *ctx, struct gl_array_object *obj)
d87 5
a91 2
   for (i = 0; i < Elements(obj->VertexAttrib); i++)
      _mesa_reference_buffer_object(ctx, &obj->VertexAttrib[i].BufferObj, NULL);
d97 1
a97 1
 * 
d101 2
a102 2
struct gl_array_object *
_mesa_new_array_object( struct gl_context *ctx, GLuint name )
d104 1
a104 1
   struct gl_array_object *obj = CALLOC_STRUCT(gl_array_object);
d106 1
a106 1
      _mesa_initialize_array_object(ctx, obj, name);
d113 1
a113 1
 * 
d118 1
a118 1
_mesa_delete_array_object( struct gl_context *ctx, struct gl_array_object *obj )
a119 1
   (void) ctx;
d121 3
a123 2
   _mesa_reference_buffer_object(ctx, &obj->ElementArrayBufferObj, NULL);
   _glthread_DESTROY_MUTEX(obj->Mutex);
d129 2
a130 2
 * Set ptr to arrayObj w/ reference counting.
 * Note: this should only be called from the _mesa_reference_array_object()
d134 3
a136 3
_mesa_reference_array_object_(struct gl_context *ctx,
                              struct gl_array_object **ptr,
                              struct gl_array_object *arrayObj)
d138 1
a138 1
   assert(*ptr != arrayObj);
d143 1
a143 1
      struct gl_array_object *oldObj = *ptr;
d145 1
a145 1
      _glthread_LOCK_MUTEX(oldObj->Mutex);
d153 1
a153 1
      _glthread_UNLOCK_MUTEX(oldObj->Mutex);
d164 1
a164 1
   if (arrayObj) {
d166 2
a167 2
      _glthread_LOCK_MUTEX(arrayObj->Mutex);
      if (arrayObj->RefCount == 0) {
d174 1
a174 1
         arrayObj->RefCount++;
d177 1
a177 1
                (void *) arrayObj, arrayObj->Name, arrayObj->RefCount);
d179 1
a179 1
         *ptr = arrayObj;
d181 1
a181 1
      _glthread_UNLOCK_MUTEX(arrayObj->Mutex);
d189 1
a189 1
           struct gl_client_array *array, GLint size, GLint type)
d191 3
a197 1
   array->StrideB = 0;
d199 1
d204 7
d212 1
a212 1
   _mesa_reference_buffer_object(ctx, &array->BufferObj,
d218 1
a218 1
 * Initialize a gl_array_object's arrays.
d221 3
a223 3
_mesa_initialize_array_object( struct gl_context *ctx,
			       struct gl_array_object *obj,
			       GLuint name )
d229 1
a229 1
   _glthread_INIT_MUTEX(obj->Mutex);
d233 1
a233 1
   for (i = 0; i < Elements(obj->VertexAttrib); i++) {
d236 1
a236 1
         init_array(ctx, &obj->VertexAttrib[VERT_ATTRIB_WEIGHT], 1, GL_FLOAT);
d239 1
a239 1
         init_array(ctx, &obj->VertexAttrib[VERT_ATTRIB_NORMAL], 3, GL_FLOAT);
d242 1
a242 1
         init_array(ctx, &obj->VertexAttrib[VERT_ATTRIB_COLOR1], 3, GL_FLOAT);
d245 1
a245 1
         init_array(ctx, &obj->VertexAttrib[VERT_ATTRIB_FOG], 1, GL_FLOAT);
d248 1
a248 1
         init_array(ctx, &obj->VertexAttrib[VERT_ATTRIB_COLOR_INDEX], 1, GL_FLOAT);
d251 1
a251 1
         init_array(ctx, &obj->VertexAttrib[VERT_ATTRIB_EDGEFLAG], 1, GL_BOOL);
d254 1
a254 1
         init_array(ctx, &obj->VertexAttrib[VERT_ATTRIB_POINT_SIZE], 1, GL_FLOAT);
d257 1
a257 1
         init_array(ctx, &obj->VertexAttrib[i], 4, GL_FLOAT);
d262 1
a262 1
   _mesa_reference_buffer_object(ctx, &obj->ElementArrayBufferObj,
d271 1
a271 1
save_array_object( struct gl_context *ctx, struct gl_array_object *obj )
d285 1
a285 1
remove_array_object( struct gl_context *ctx, struct gl_array_object *obj )
d296 2
a297 2
 * Helper for _mesa_update_array_object_max_element().
 * \return  min(arrayObj->VertexAttrib[*]._MaxElement).
d300 1
a300 1
compute_max_element(struct gl_array_object *arrayObj, GLbitfield64 enabled)
d303 1
a303 1
   
d308 2
a309 2
      
      client_array = &arrayObj->VertexAttrib[attrib];
d314 1
a314 1
   
d320 1
a320 1
 * Examine vertex arrays to update the gl_array_object::_MaxElement field.
d323 2
a324 2
_mesa_update_array_object_max_element(struct gl_context *ctx,
                                      struct gl_array_object *arrayObj)
d330 1
a330 1
      enabled = _mesa_array_object_get_enabled_ff(arrayObj);
d332 1
a332 1
      enabled = _mesa_array_object_get_enabled_arb(arrayObj);
d336 29
a364 1
   arrayObj->_MaxElement = compute_max_element(arrayObj, enabled);
d381 2
a382 2
   struct gl_array_object * const oldObj = ctx->Array.ArrayObj;
   struct gl_array_object *newObj = NULL;
d396 1
a396 1
      newObj = ctx->Array.DefaultArrayObj;
d400 1
a400 1
      newObj = lookup_arrayobj(ctx, id);
d403 2
a404 1
            _mesa_error(ctx, GL_INVALID_OPERATION, "glBindVertexArray(non-gen name)");
d431 1
a431 1
   _mesa_reference_array_object(ctx, &ctx->Array.ArrayObj, newObj);
d471 1
a471 1
 * 
d482 1
a482 1
      _mesa_error(ctx, GL_INVALID_VALUE, "glDeleteVertexArrayAPPLE(n)");
d487 1
a487 1
      struct gl_array_object *obj = lookup_arrayobj(ctx, ids[i]);
d496 1
a496 1
	 if ( obj == ctx->Array.ArrayObj ) {
d506 1
a506 1
         _mesa_reference_array_object(ctx, &obj, NULL);
d519 1
a519 1
static void 
d526 1
a526 1
      _mesa_error(ctx, GL_INVALID_VALUE, "glGenVertexArraysAPPLE");
d538 1
a538 1
      struct gl_array_object *obj;
d543 1
a543 1
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glGenVertexArraysAPPLE");
d578 1
a578 1
 * 
d580 1
a580 1
 * \return  \c GL_TRUE if \c id is the name of a array object, 
d586 1
a586 1
   struct gl_array_object * obj;
d593 1
a593 1
   obj = lookup_arrayobj(ctx, id);
@


1.6
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a2 1
 * Version:  7.6
d21 4
a24 4
 * BRIAN PAUL OR IBM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
 * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
a45 2
#include "mfeatures.h"
#if FEATURE_ARB_vertex_buffer_object
a46 1
#endif
d63 1
a63 1
static INLINE struct gl_array_object *
a83 12
   _mesa_reference_buffer_object(ctx, &obj->Vertex.BufferObj, NULL);
   _mesa_reference_buffer_object(ctx, &obj->Weight.BufferObj, NULL);
   _mesa_reference_buffer_object(ctx, &obj->Normal.BufferObj, NULL);
   _mesa_reference_buffer_object(ctx, &obj->Color.BufferObj, NULL);
   _mesa_reference_buffer_object(ctx, &obj->SecondaryColor.BufferObj, NULL);
   _mesa_reference_buffer_object(ctx, &obj->FogCoord.BufferObj, NULL);
   _mesa_reference_buffer_object(ctx, &obj->Index.BufferObj, NULL);
   _mesa_reference_buffer_object(ctx, &obj->EdgeFlag.BufferObj, NULL);

   for (i = 0; i < Elements(obj->TexCoord); i++)
      _mesa_reference_buffer_object(ctx, &obj->TexCoord[i].BufferObj, NULL);

d85 1
a85 5
      _mesa_reference_buffer_object(ctx, &obj->VertexAttrib[i].BufferObj,NULL);

#if FEATURE_point_size_array
   _mesa_reference_buffer_object(ctx, &obj->PointSize.BufferObj, NULL);
#endif
d116 1
d124 2
d128 3
a130 3
_mesa_reference_array_object(struct gl_context *ctx,
                             struct gl_array_object **ptr,
                             struct gl_array_object *arrayObj)
d132 1
a132 2
   if (*ptr == arrayObj)
      return;
d193 1
a194 1
#if FEATURE_ARB_vertex_buffer_object
a197 1
#endif
a216 11
   init_array(ctx, &obj->Vertex, 4, GL_FLOAT);
   init_array(ctx, &obj->Weight, 1, GL_FLOAT);
   init_array(ctx, &obj->Normal, 3, GL_FLOAT);
   init_array(ctx, &obj->Color, 4, GL_FLOAT);
   init_array(ctx, &obj->SecondaryColor, 3, GL_FLOAT);
   init_array(ctx, &obj->FogCoord, 1, GL_FLOAT);
   init_array(ctx, &obj->Index, 1, GL_FLOAT);
   for (i = 0; i < Elements(obj->TexCoord); i++) {
      init_array(ctx, &obj->TexCoord[i], 4, GL_FLOAT);
   }
   init_array(ctx, &obj->EdgeFlag, 1, GL_BOOL);
d218 26
a243 1
      init_array(ctx, &obj->VertexAttrib[i], 4, GL_FLOAT);
d246 2
a247 3
#if FEATURE_point_size_array
   init_array(ctx, &obj->PointSize, 1, GL_FLOAT);
#endif
d280 2
a281 2
 * Helper for update_arrays().
 * \return  min(current min, array->_MaxElement).
d284 1
a284 1
update_min(GLuint min, struct gl_client_array *array)
d286 11
a296 3
   if (array->Enabled) {
      _mesa_update_array_max_element(array);
      return MIN2(min, array->_MaxElement);
d298 2
a299 2
   else
      return min;
d310 1
a310 1
   GLuint i, min = ~0;
d312 6
a317 15
   min = update_min(min, &arrayObj->Vertex);
   min = update_min(min, &arrayObj->Weight);
   min = update_min(min, &arrayObj->Normal);
   min = update_min(min, &arrayObj->Color);
   min = update_min(min, &arrayObj->SecondaryColor);
   min = update_min(min, &arrayObj->FogCoord);
   min = update_min(min, &arrayObj->Index);
   min = update_min(min, &arrayObj->EdgeFlag);
#if FEATURE_point_size_array
   min = update_min(min, &arrayObj->PointSize);
#endif
   for (i = 0; i < ctx->Const.MaxTextureCoordUnits; i++)
      min = update_min(min, &arrayObj->TexCoord[i]);
   for (i = 0; i < Elements(arrayObj->VertexAttrib); i++)
      min = update_min(min, &arrayObj->VertexAttrib[i]);
d320 1
a320 1
   arrayObj->_MaxElement = min;
a338 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d359 1
a359 1
            _mesa_error(ctx, GL_INVALID_OPERATION, "glBindVertexArray(id)");
d369 1
d372 11
a385 1
   ctx->Array.NewState |= _NEW_ARRAY_ALL;
d431 1
a431 1
_mesa_DeleteVertexArraysAPPLE(GLsizei n, const GLuint *ids)
a434 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d452 1
a452 1
	    CALL_BindVertexArrayAPPLE( ctx->Exec, (0) );
d475 1
a475 2
gen_vertex_arrays(struct gl_context *ctx, GLsizei n, GLuint *arrays,
                  GLboolean vboOnly)
a478 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
a500 1
      obj->VBOonly = vboOnly;
d515 1
a515 1
   gen_vertex_arrays(ctx, n, arrays, GL_TRUE);
d527 1
a527 1
   gen_vertex_arrays(ctx, n, arrays, GL_FALSE);
d539 1
a539 1
_mesa_IsVertexArrayAPPLE( GLuint id )
d549 2
d552 1
a552 1
   return (obj != NULL) ? GL_TRUE : GL_FALSE;
@


1.5
log
@Merge Mesa 7.10.3
@
text
@d44 1
d47 1
d53 2
d211 1
a285 31
 * Compute the index of the last array element that can be safely accessed
 * in a vertex array.  We can really only do this when the array lives in
 * a VBO.
 * The array->_MaxElement field will be updated.
 * Later in glDrawArrays/Elements/etc we can do some bounds checking.
 */
static void
compute_max_element(struct gl_client_array *array)
{
   if (array->BufferObj->Name) {
      /* Compute the max element we can access in the VBO without going
       * out of bounds.
       */
      array->_MaxElement = ((GLsizeiptrARB) array->BufferObj->Size
                            - (GLsizeiptrARB) array->Ptr + array->StrideB
                            - array->_ElementSize) / array->StrideB;
      if (0)
         printf("%s Object %u  Size %u  MaxElement %u\n",
		__FUNCTION__,
		array->BufferObj->Name,
		(GLuint) array->BufferObj->Size,
		array->_MaxElement);
   }
   else {
      /* user-space array, no idea how big it is */
      array->_MaxElement = 2 * 1000 * 1000 * 1000; /* just a big number */
   }
}


/**
d292 2
a293 2
   compute_max_element(array);
   if (array->Enabled)
d295 1
d473 2
a474 1
gen_vertex_arrays(struct gl_context *ctx, GLsizei n, GLuint *arrays, GLboolean vboOnly)
@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d64 1
a64 1
lookup_arrayobj(GLcontext *ctx, GLuint id)
d80 1
a80 1
unbind_array_object_vbos(GLcontext *ctx, struct gl_array_object *obj)
d112 1
a112 1
_mesa_new_array_object( GLcontext *ctx, GLuint name )
d128 1
a128 1
_mesa_delete_array_object( GLcontext *ctx, struct gl_array_object *obj )
d141 1
a141 1
_mesa_reference_array_object(GLcontext *ctx,
d196 1
a196 1
init_array(GLcontext *ctx,
d219 1
a219 1
_mesa_initialize_array_object( GLcontext *ctx,
d235 1
a235 1
   init_array(ctx, &obj->SecondaryColor, 4, GL_FLOAT);
d256 1
a256 1
save_array_object( GLcontext *ctx, struct gl_array_object *obj )
d270 1
a270 1
remove_array_object( GLcontext *ctx, struct gl_array_object *obj )
d330 1
a330 1
_mesa_update_array_object_max_element(GLcontext *ctx,
d367 1
a367 1
bind_vertex_array(GLcontext *ctx, GLuint id, GLboolean genRequired)
d498 1
a498 1
gen_vertex_arrays(GLcontext *ctx, GLsizei n, GLuint *arrays, GLboolean vboOnly)
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d3 1
a3 1
 * Version:  7.2
d7 1
d50 2
a51 1
#include "glapi/dispatch.h"
d66 36
a101 4
   return (id == 0) 
     ? NULL 
     : (struct gl_array_object *) _mesa_HashLookup(ctx->Shared->ArrayObjects,
						   id);
d131 3
a133 1
   _mesa_free(obj);
d137 81
d227 17
a243 55
   /* Vertex arrays */
   obj->Vertex.Size = 4;
   obj->Vertex.Type = GL_FLOAT;
   obj->Vertex.Stride = 0;
   obj->Vertex.StrideB = 0;
   obj->Vertex.Ptr = NULL;
   obj->Vertex.Enabled = GL_FALSE;
   obj->Normal.Type = GL_FLOAT;
   obj->Normal.Stride = 0;
   obj->Normal.StrideB = 0;
   obj->Normal.Ptr = NULL;
   obj->Normal.Enabled = GL_FALSE;
   obj->Color.Size = 4;
   obj->Color.Type = GL_FLOAT;
   obj->Color.Stride = 0;
   obj->Color.StrideB = 0;
   obj->Color.Ptr = NULL;
   obj->Color.Enabled = GL_FALSE;
   obj->SecondaryColor.Size = 4;
   obj->SecondaryColor.Type = GL_FLOAT;
   obj->SecondaryColor.Stride = 0;
   obj->SecondaryColor.StrideB = 0;
   obj->SecondaryColor.Ptr = NULL;
   obj->SecondaryColor.Enabled = GL_FALSE;
   obj->FogCoord.Size = 1;
   obj->FogCoord.Type = GL_FLOAT;
   obj->FogCoord.Stride = 0;
   obj->FogCoord.StrideB = 0;
   obj->FogCoord.Ptr = NULL;
   obj->FogCoord.Enabled = GL_FALSE;
   obj->Index.Type = GL_FLOAT;
   obj->Index.Stride = 0;
   obj->Index.StrideB = 0;
   obj->Index.Ptr = NULL;
   obj->Index.Enabled = GL_FALSE;
   for (i = 0; i < MAX_TEXTURE_COORD_UNITS; i++) {
      obj->TexCoord[i].Size = 4;
      obj->TexCoord[i].Type = GL_FLOAT;
      obj->TexCoord[i].Stride = 0;
      obj->TexCoord[i].StrideB = 0;
      obj->TexCoord[i].Ptr = NULL;
      obj->TexCoord[i].Enabled = GL_FALSE;
   }
   obj->EdgeFlag.Stride = 0;
   obj->EdgeFlag.StrideB = 0;
   obj->EdgeFlag.Ptr = NULL;
   obj->EdgeFlag.Enabled = GL_FALSE;
   for (i = 0; i < VERT_ATTRIB_MAX; i++) {
      obj->VertexAttrib[i].Size = 4;
      obj->VertexAttrib[i].Type = GL_FLOAT;
      obj->VertexAttrib[i].Stride = 0;
      obj->VertexAttrib[i].StrideB = 0;
      obj->VertexAttrib[i].Ptr = NULL;
      obj->VertexAttrib[i].Enabled = GL_FALSE;
      obj->VertexAttrib[i].Normalized = GL_FALSE;
d247 1
a247 23
   obj->PointSize.Type = GL_FLOAT;
   obj->PointSize.Stride = 0;
   obj->PointSize.StrideB = 0;
   obj->PointSize.Ptr = NULL;
   obj->PointSize.Enabled = GL_FALSE;
   obj->PointSize.BufferObj = ctx->Array.NullBufferObj;
#endif

#if FEATURE_ARB_vertex_buffer_object
   /* Vertex array buffers */
   obj->Vertex.BufferObj = ctx->Array.NullBufferObj;
   obj->Normal.BufferObj = ctx->Array.NullBufferObj;
   obj->Color.BufferObj = ctx->Array.NullBufferObj;
   obj->SecondaryColor.BufferObj = ctx->Array.NullBufferObj;
   obj->FogCoord.BufferObj = ctx->Array.NullBufferObj;
   obj->Index.BufferObj = ctx->Array.NullBufferObj;
   for (i = 0; i < MAX_TEXTURE_COORD_UNITS; i++) {
      obj->TexCoord[i].BufferObj = ctx->Array.NullBufferObj;
   }
   obj->EdgeFlag.BufferObj = ctx->Array.NullBufferObj;
   for (i = 0; i < VERT_ATTRIB_MAX; i++) {
      obj->VertexAttrib[i].BufferObj = ctx->Array.NullBufferObj;
   }
d255 2
a256 2
void
_mesa_save_array_object( GLcontext *ctx, struct gl_array_object *obj )
d260 1
a260 1
      _mesa_HashInsert(ctx->Shared->ArrayObjects, obj->Name, obj);
d269 2
a270 2
void
_mesa_remove_array_object( GLcontext *ctx, struct gl_array_object *obj )
d274 1
a274 1
      _mesa_HashRemove(ctx->Shared->ArrayObjects, obj->Name);
d279 8
d288 1
a288 1
unbind_buffer_object( GLcontext *ctx, struct gl_buffer_object *bufObj )
d290 13
a302 2
   if (bufObj != ctx->Array.NullBufferObj) {
      _mesa_reference_buffer_object(ctx, &bufObj, NULL);
d304 49
d360 1
d362 3
a364 6
 * Bind a new array.
 *
 * \todo
 * The binding could be done more efficiently by comparing the non-NULL
 * pointers in the old and new objects.  The only arrays that are "dirty" are
 * the ones that are non-NULL in either object.
d366 2
a367 2
void GLAPIENTRY
_mesa_BindVertexArrayAPPLE( GLuint id )
a368 1
   GET_CURRENT_CONTEXT(ctx);
d379 1
a379 1
    * Get pointer to new array object (newBufObj)
d391 4
a394 2
         /* If this is a new array object id, allocate an array object now.
	  */
d396 1
d402 1
a402 1
         _mesa_save_array_object(ctx, newObj);
a405 1

d408 1
a408 2
   ctx->Array.ArrayObj = newObj;

d412 31
a442 1
      (*ctx->Driver.BindArrayObject)( ctx, newObj );
a463 2
   _glthread_LOCK_MUTEX(ctx->Shared->Mutex);

a469 1

d478 2
a479 18
#if FEATURE_ARB_vertex_buffer_object
	 /* Unbind any buffer objects that might be bound to arrays in
	  * this array object.
	  */
	 unbind_buffer_object( ctx, obj->Vertex.BufferObj );
	 unbind_buffer_object( ctx, obj->Normal.BufferObj );
	 unbind_buffer_object( ctx, obj->Color.BufferObj );
	 unbind_buffer_object( ctx, obj->SecondaryColor.BufferObj );
	 unbind_buffer_object( ctx, obj->FogCoord.BufferObj );
	 unbind_buffer_object( ctx, obj->Index.BufferObj );
	 for (i = 0; i < MAX_TEXTURE_COORD_UNITS; i++) {
	    unbind_buffer_object( ctx, obj->TexCoord[i].BufferObj );
	 }
	 unbind_buffer_object( ctx, obj->EdgeFlag.BufferObj );
	 for (i = 0; i < VERT_ATTRIB_MAX; i++) {
	    unbind_buffer_object( ctx, obj->VertexAttrib[i].BufferObj );
	 }
#endif
d481 4
a484 3
	 /* The ID is immediately freed for re-use */
	 _mesa_remove_array_object(ctx, obj);
	 ctx->Driver.DeleteArrayObject(ctx, obj);
a486 2

   _glthread_UNLOCK_MUTEX(ctx->Shared->Mutex);
d492 1
a492 1
 * 
d495 1
d497 2
a498 2
void GLAPIENTRY
_mesa_GenVertexArraysAPPLE(GLsizei n, GLuint *arrays)
a499 1
   GET_CURRENT_CONTEXT(ctx);
d513 1
a513 6
   /*
    * This must be atomic (generation and allocation of array object IDs)
    */
   _glthread_LOCK_MUTEX(ctx->Shared->Mutex);

   first = _mesa_HashFindFreeKeyBlock(ctx->Shared->ArrayObjects, n);
a521 1
         _glthread_UNLOCK_MUTEX(ctx->Shared->Mutex);
d525 2
a526 1
      _mesa_save_array_object(ctx, obj);
d529 14
d544 9
a552 1
   _glthread_UNLOCK_MUTEX(ctx->Shared->Mutex);
a572 1
   _glthread_LOCK_MUTEX(ctx->Shared->Mutex);
a573 1
   _glthread_UNLOCK_MUTEX(ctx->Shared->Mutex);
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d145 1
a145 1
   for (i = 0; i < MAX_TEXTURE_UNITS; i++) {
d167 9
d184 1
a184 1
   for (i = 0; i < MAX_TEXTURE_UNITS; i++) {
d338 1
a338 1
	 for (i = 0; i < MAX_TEXTURE_UNITS; i++) {
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * Version:  6.5
d5 1
a5 1
 * Copyright (C) 1999-2004  Brian Paul   All Rights Reserved.
d49 1
a49 1
#include "dispatch.h"
d80 1
a80 1
   struct gl_array_object *obj = MALLOC_STRUCT(gl_array_object);
a116 1
   obj->Vertex.Flags = CA_CLIENT_DATA;
a121 1
   obj->Normal.Flags = CA_CLIENT_DATA;
a127 1
   obj->Color.Flags = CA_CLIENT_DATA;
a133 1
   obj->SecondaryColor.Flags = CA_CLIENT_DATA;
a139 1
   obj->FogCoord.Flags = CA_CLIENT_DATA;
a144 1
   obj->Index.Flags = CA_CLIENT_DATA;
a151 1
      obj->TexCoord[i].Flags = CA_CLIENT_DATA;
a156 1
   obj->EdgeFlag.Flags = CA_CLIENT_DATA;
a164 1
      obj->VertexAttrib[i].Flags = CA_CLIENT_DATA;
d213 9
d323 6
a328 6
	 _mesa_unbind_buffer_object( ctx, obj->Vertex.BufferObj );
	 _mesa_unbind_buffer_object( ctx, obj->Normal.BufferObj );
	 _mesa_unbind_buffer_object( ctx, obj->Color.BufferObj );
	 _mesa_unbind_buffer_object( ctx, obj->SecondaryColor.BufferObj );
	 _mesa_unbind_buffer_object( ctx, obj->FogCoord.BufferObj );
	 _mesa_unbind_buffer_object( ctx, obj->Index.BufferObj );
d330 1
a330 1
	    _mesa_unbind_buffer_object( ctx, obj->TexCoord[i].BufferObj );
d332 1
a332 1
	 _mesa_unbind_buffer_object( ctx, obj->EdgeFlag.BufferObj );
d334 1
a334 1
	    _mesa_unbind_buffer_object( ctx, obj->VertexAttrib[i].BufferObj );
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@Mesa 7.0.1
@
text
@d117 1
d123 1
d130 1
d137 1
d144 1
d150 1
d158 1
d164 1
d173 1
@


1.1.1.3
log
@Import Mesa 7.10.3
@
text
@d3 1
a3 1
 * Version:  7.6
d5 1
a5 1
 * Copyright (C) 1999-2008  Brian Paul   All Rights Reserved.
a6 1
 * Copyright (C) 2009  VMware, Inc.  All Rights Reserved.
d49 1
a49 2
#include "macros.h"
#include "main/dispatch.h"
d62 1
a62 1
lookup_arrayobj(struct gl_context *ctx, GLuint id)
d64 4
a67 36
   if (id == 0)
      return NULL;
   else
      return (struct gl_array_object *)
         _mesa_HashLookup(ctx->Array.Objects, id);
}


/**
 * For all the vertex arrays in the array object, unbind any pointers
 * to any buffer objects (VBOs).
 * This is done just prior to array object destruction.
 */
static void
unbind_array_object_vbos(struct gl_context *ctx, struct gl_array_object *obj)
{
   GLuint i;

   _mesa_reference_buffer_object(ctx, &obj->Vertex.BufferObj, NULL);
   _mesa_reference_buffer_object(ctx, &obj->Weight.BufferObj, NULL);
   _mesa_reference_buffer_object(ctx, &obj->Normal.BufferObj, NULL);
   _mesa_reference_buffer_object(ctx, &obj->Color.BufferObj, NULL);
   _mesa_reference_buffer_object(ctx, &obj->SecondaryColor.BufferObj, NULL);
   _mesa_reference_buffer_object(ctx, &obj->FogCoord.BufferObj, NULL);
   _mesa_reference_buffer_object(ctx, &obj->Index.BufferObj, NULL);
   _mesa_reference_buffer_object(ctx, &obj->EdgeFlag.BufferObj, NULL);

   for (i = 0; i < Elements(obj->TexCoord); i++)
      _mesa_reference_buffer_object(ctx, &obj->TexCoord[i].BufferObj, NULL);

   for (i = 0; i < Elements(obj->VertexAttrib); i++)
      _mesa_reference_buffer_object(ctx, &obj->VertexAttrib[i].BufferObj,NULL);

#if FEATURE_point_size_array
   _mesa_reference_buffer_object(ctx, &obj->PointSize.BufferObj, NULL);
#endif
d78 1
a78 1
_mesa_new_array_object( struct gl_context *ctx, GLuint name )
d80 1
a80 1
   struct gl_array_object *obj = CALLOC_STRUCT(gl_array_object);
d94 1
a94 1
_mesa_delete_array_object( struct gl_context *ctx, struct gl_array_object *obj )
d97 1
a97 3
   unbind_array_object_vbos(ctx, obj);
   _glthread_DESTROY_MUTEX(obj->Mutex);
   free(obj);
a100 3
/**
 * Set ptr to arrayObj w/ reference counting.
 */
d102 1
a102 79
_mesa_reference_array_object(struct gl_context *ctx,
                             struct gl_array_object **ptr,
                             struct gl_array_object *arrayObj)
{
   if (*ptr == arrayObj)
      return;

   if (*ptr) {
      /* Unreference the old array object */
      GLboolean deleteFlag = GL_FALSE;
      struct gl_array_object *oldObj = *ptr;

      _glthread_LOCK_MUTEX(oldObj->Mutex);
      ASSERT(oldObj->RefCount > 0);
      oldObj->RefCount--;
#if 0
      printf("ArrayObj %p %d DECR to %d\n",
             (void *) oldObj, oldObj->Name, oldObj->RefCount);
#endif
      deleteFlag = (oldObj->RefCount == 0);
      _glthread_UNLOCK_MUTEX(oldObj->Mutex);

      if (deleteFlag) {
	 ASSERT(ctx->Driver.DeleteArrayObject);
         ctx->Driver.DeleteArrayObject(ctx, oldObj);
      }

      *ptr = NULL;
   }
   ASSERT(!*ptr);

   if (arrayObj) {
      /* reference new array object */
      _glthread_LOCK_MUTEX(arrayObj->Mutex);
      if (arrayObj->RefCount == 0) {
         /* this array's being deleted (look just above) */
         /* Not sure this can every really happen.  Warn if it does. */
         _mesa_problem(NULL, "referencing deleted array object");
         *ptr = NULL;
      }
      else {
         arrayObj->RefCount++;
#if 0
         printf("ArrayObj %p %d INCR to %d\n",
                (void *) arrayObj, arrayObj->Name, arrayObj->RefCount);
#endif
         *ptr = arrayObj;
      }
      _glthread_UNLOCK_MUTEX(arrayObj->Mutex);
   }
}



static void
init_array(struct gl_context *ctx,
           struct gl_client_array *array, GLint size, GLint type)
{
   array->Size = size;
   array->Type = type;
   array->Format = GL_RGBA; /* only significant for GL_EXT_vertex_array_bgra */
   array->Stride = 0;
   array->StrideB = 0;
   array->Ptr = NULL;
   array->Enabled = GL_FALSE;
   array->Normalized = GL_FALSE;
#if FEATURE_ARB_vertex_buffer_object
   /* Vertex array buffers */
   _mesa_reference_buffer_object(ctx, &array->BufferObj,
                                 ctx->Shared->NullBufferObj);
#endif
}


/**
 * Initialize a gl_array_object's arrays.
 */
void
_mesa_initialize_array_object( struct gl_context *ctx,
d110 56
a165 2
   _glthread_INIT_MUTEX(obj->Mutex);
   obj->RefCount = 1;
d167 14
a180 14
   /* Init the individual arrays */
   init_array(ctx, &obj->Vertex, 4, GL_FLOAT);
   init_array(ctx, &obj->Weight, 1, GL_FLOAT);
   init_array(ctx, &obj->Normal, 3, GL_FLOAT);
   init_array(ctx, &obj->Color, 4, GL_FLOAT);
   init_array(ctx, &obj->SecondaryColor, 3, GL_FLOAT);
   init_array(ctx, &obj->FogCoord, 1, GL_FLOAT);
   init_array(ctx, &obj->Index, 1, GL_FLOAT);
   for (i = 0; i < Elements(obj->TexCoord); i++) {
      init_array(ctx, &obj->TexCoord[i], 4, GL_FLOAT);
   }
   init_array(ctx, &obj->EdgeFlag, 1, GL_BOOL);
   for (i = 0; i < Elements(obj->VertexAttrib); i++) {
      init_array(ctx, &obj->VertexAttrib[i], 4, GL_FLOAT);
a181 3

#if FEATURE_point_size_array
   init_array(ctx, &obj->PointSize, 1, GL_FLOAT);
d189 2
a190 2
static void
save_array_object( struct gl_context *ctx, struct gl_array_object *obj )
d194 1
a194 1
      _mesa_HashInsert(ctx->Array.Objects, obj->Name, obj);
d203 2
a204 2
static void
remove_array_object( struct gl_context *ctx, struct gl_array_object *obj )
d208 1
a208 29
      _mesa_HashRemove(ctx->Array.Objects, obj->Name);
   }
}



/**
 * Compute the index of the last array element that can be safely accessed
 * in a vertex array.  We can really only do this when the array lives in
 * a VBO.
 * The array->_MaxElement field will be updated.
 * Later in glDrawArrays/Elements/etc we can do some bounds checking.
 */
static void
compute_max_element(struct gl_client_array *array)
{
   if (array->BufferObj->Name) {
      /* Compute the max element we can access in the VBO without going
       * out of bounds.
       */
      array->_MaxElement = ((GLsizeiptrARB) array->BufferObj->Size
                            - (GLsizeiptrARB) array->Ptr + array->StrideB
                            - array->_ElementSize) / array->StrideB;
      if (0)
         printf("%s Object %u  Size %u  MaxElement %u\n",
		__FUNCTION__,
		array->BufferObj->Name,
		(GLuint) array->BufferObj->Size,
		array->_MaxElement);
a209 49
   else {
      /* user-space array, no idea how big it is */
      array->_MaxElement = 2 * 1000 * 1000 * 1000; /* just a big number */
   }
}


/**
 * Helper for update_arrays().
 * \return  min(current min, array->_MaxElement).
 */
static GLuint
update_min(GLuint min, struct gl_client_array *array)
{
   compute_max_element(array);
   if (array->Enabled)
      return MIN2(min, array->_MaxElement);
   else
      return min;
}


/**
 * Examine vertex arrays to update the gl_array_object::_MaxElement field.
 */
void
_mesa_update_array_object_max_element(struct gl_context *ctx,
                                      struct gl_array_object *arrayObj)
{
   GLuint i, min = ~0;

   min = update_min(min, &arrayObj->Vertex);
   min = update_min(min, &arrayObj->Weight);
   min = update_min(min, &arrayObj->Normal);
   min = update_min(min, &arrayObj->Color);
   min = update_min(min, &arrayObj->SecondaryColor);
   min = update_min(min, &arrayObj->FogCoord);
   min = update_min(min, &arrayObj->Index);
   min = update_min(min, &arrayObj->EdgeFlag);
#if FEATURE_point_size_array
   min = update_min(min, &arrayObj->PointSize);
#endif
   for (i = 0; i < ctx->Const.MaxTextureCoordUnits; i++)
      min = update_min(min, &arrayObj->TexCoord[i]);
   for (i = 0; i < Elements(arrayObj->VertexAttrib); i++)
      min = update_min(min, &arrayObj->VertexAttrib[i]);

   /* _MaxElement is one past the last legal array element */
   arrayObj->_MaxElement = min;
a216 1

d218 6
a223 3
 * Helper for _mesa_BindVertexArray() and _mesa_BindVertexArrayAPPLE().
 * \param genRequired  specifies behavour when id was not generated with
 *                     glGenVertexArrays().
d225 2
a226 2
static void
bind_vertex_array(struct gl_context *ctx, GLuint id, GLboolean genRequired)
d228 1
d239 1
a239 1
    * Get pointer to new array object (newObj)
d251 2
a252 4
         if (genRequired) {
            _mesa_error(ctx, GL_INVALID_OPERATION, "glBindVertexArray(id)");
            return;
         }
a253 1
         /* For APPLE version, generate a new array object now */
d259 1
a259 1
         save_array_object(ctx, newObj);
d263 1
d266 2
a267 1
   _mesa_reference_array_object(ctx, &ctx->Array.ArrayObj, newObj);
d271 1
a271 31
      ctx->Driver.BindArrayObject(ctx, newObj);
}


/**
 * ARB version of glBindVertexArray()
 * This function behaves differently from glBindVertexArrayAPPLE() in
 * that this function requires all ids to have been previously generated
 * by glGenVertexArrays[APPLE]().
 */
void GLAPIENTRY
_mesa_BindVertexArray( GLuint id )
{
   GET_CURRENT_CONTEXT(ctx);
   bind_vertex_array(ctx, id, GL_TRUE);
}


/**
 * Bind a new array.
 *
 * \todo
 * The binding could be done more efficiently by comparing the non-NULL
 * pointers in the old and new objects.  The only arrays that are "dirty" are
 * the ones that are non-NULL in either object.
 */
void GLAPIENTRY
_mesa_BindVertexArrayAPPLE( GLuint id )
{
   GET_CURRENT_CONTEXT(ctx);
   bind_vertex_array(ctx, id, GL_FALSE);
d293 2
d301 1
d310 19
d330 2
a331 6
	 remove_array_object(ctx, obj);

         /* Unreference the array object. 
          * If refcount hits zero, the object will be deleted.
          */
         _mesa_reference_array_object(ctx, &obj, NULL);
d334 2
d341 1
a341 1
 * Helper for _mesa_GenVertexArrays[APPLE]() functions below.
a343 1
 * \param vboOnly Will arrays have to reside in VBOs?
d345 2
a346 2
static void 
gen_vertex_arrays(struct gl_context *ctx, GLsizei n, GLuint *arrays, GLboolean vboOnly)
d348 1
d362 6
a367 1
   first = _mesa_HashFindFreeKeyBlock(ctx->Array.Objects, n);
d376 1
d380 1
a380 2
      obj->VBOonly = vboOnly;
      save_array_object(ctx, obj);
a382 14
}


/**
 * ARB version of glGenVertexArrays()
 * All arrays will be required to live in VBOs.
 */
void GLAPIENTRY
_mesa_GenVertexArrays(GLsizei n, GLuint *arrays)
{
   GET_CURRENT_CONTEXT(ctx);
   gen_vertex_arrays(ctx, n, arrays, GL_TRUE);
}

d384 1
a384 9
/**
 * APPLE version of glGenVertexArraysAPPLE()
 * Arrays may live in VBOs or ordinary memory.
 */
void GLAPIENTRY
_mesa_GenVertexArraysAPPLE(GLsizei n, GLuint *arrays)
{
   GET_CURRENT_CONTEXT(ctx);
   gen_vertex_arrays(ctx, n, arrays, GL_FALSE);
d405 1
d407 1
@


1.1.1.4
log
@Import Mesa 9.2.0
@
text
@d3 1
d22 4
a25 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
a43 1
#include "image.h"
d46 1
d48 1
a50 2
#include "mtypes.h"
#include "varray.h"
d63 1
a63 1
static inline struct gl_array_object *
d84 12
d97 5
a101 1
      _mesa_reference_buffer_object(ctx, &obj->VertexAttrib[i].BufferObj, NULL);
a131 1
   _mesa_reference_buffer_object(ctx, &obj->ElementArrayBufferObj, NULL);
a138 2
 * Note: this should only be called from the _mesa_reference_array_object()
 * inline function.
d141 3
a143 3
_mesa_reference_array_object_(struct gl_context *ctx,
                              struct gl_array_object **ptr,
                              struct gl_array_object *arrayObj)
d145 2
a146 1
   assert(*ptr != arrayObj);
d207 1
a207 2
   array->Integer = GL_FALSE;
   array->_ElementSize = size * _mesa_sizeof_type(type);
d211 1
d231 11
d243 1
a243 26
      switch (i) {
      case VERT_ATTRIB_WEIGHT:
         init_array(ctx, &obj->VertexAttrib[VERT_ATTRIB_WEIGHT], 1, GL_FLOAT);
         break;
      case VERT_ATTRIB_NORMAL:
         init_array(ctx, &obj->VertexAttrib[VERT_ATTRIB_NORMAL], 3, GL_FLOAT);
         break;
      case VERT_ATTRIB_COLOR1:
         init_array(ctx, &obj->VertexAttrib[VERT_ATTRIB_COLOR1], 3, GL_FLOAT);
         break;
      case VERT_ATTRIB_FOG:
         init_array(ctx, &obj->VertexAttrib[VERT_ATTRIB_FOG], 1, GL_FLOAT);
         break;
      case VERT_ATTRIB_COLOR_INDEX:
         init_array(ctx, &obj->VertexAttrib[VERT_ATTRIB_COLOR_INDEX], 1, GL_FLOAT);
         break;
      case VERT_ATTRIB_EDGEFLAG:
         init_array(ctx, &obj->VertexAttrib[VERT_ATTRIB_EDGEFLAG], 1, GL_BOOL);
         break;
      case VERT_ATTRIB_POINT_SIZE:
         init_array(ctx, &obj->VertexAttrib[VERT_ATTRIB_POINT_SIZE], 1, GL_FLOAT);
         break;
      default:
         init_array(ctx, &obj->VertexAttrib[i], 4, GL_FLOAT);
         break;
      }
d246 3
a248 2
   _mesa_reference_buffer_object(ctx, &obj->ElementArrayBufferObj,
                                 ctx->Shared->NullBufferObj);
d281 33
a313 2
 * Helper for _mesa_update_array_object_max_element().
 * \return  min(arrayObj->VertexAttrib[*]._MaxElement).
d316 1
a316 1
compute_max_element(struct gl_array_object *arrayObj, GLbitfield64 enabled)
d318 5
a322 14
   GLuint min = ~((GLuint)0);
   
   while (enabled) {
      struct gl_client_array *client_array;
      GLint attrib = ffsll(enabled) - 1;
      enabled ^= BITFIELD64_BIT(attrib);
      
      client_array = &arrayObj->VertexAttrib[attrib];
      assert(client_array->Enabled);
      _mesa_update_array_max_element(client_array);
      min = MIN2(min, client_array->_MaxElement);
   }
   
   return min;
d333 1
a333 1
   GLbitfield64 enabled;
d335 15
a349 6
   if (!ctx->VertexProgram._Current ||
       ctx->VertexProgram._Current == ctx->VertexProgram._TnlProgram) {
      enabled = _mesa_array_object_get_enabled_ff(arrayObj);
   } else {
      enabled = _mesa_array_object_get_enabled_arb(arrayObj);
   }
d352 1
a352 1
   arrayObj->_MaxElement = compute_max_element(arrayObj, enabled);
d371 1
d392 1
a392 1
            _mesa_error(ctx, GL_INVALID_OPERATION, "glBindVertexArray(non-gen name)");
a401 1

a403 11

      if (!newObj->EverBound) {
         /* The "Interactions with APPLE_vertex_array_object" section of the
          * GL_ARB_vertex_array_object spec says:
          *
          *     "The first bind call, either BindVertexArray or
          *     BindVertexArrayAPPLE, determines the semantic of the object."
          */
         newObj->ARBsemantics = genRequired;
         newObj->EverBound = GL_TRUE;
      }
d407 1
d453 1
a453 1
_mesa_DeleteVertexArrays(GLsizei n, const GLuint *ids)
d457 1
d475 1
a475 1
	    _mesa_BindVertexArray(0);
d498 1
a498 1
gen_vertex_arrays(struct gl_context *ctx, GLsizei n, GLuint *arrays)
d502 1
d525 1
d540 1
a540 1
   gen_vertex_arrays(ctx, n, arrays);
d552 1
a552 1
   gen_vertex_arrays(ctx, n, arrays);
d564 1
a564 1
_mesa_IsVertexArray( GLuint id )
a573 2
   if (obj == NULL)
      return GL_FALSE;
d575 1
a575 1
   return obj->EverBound;
@


1.1.1.5
log
@Import Mesa 10.2.3
@
text
@d30 1
a30 4
 *
 * Implementation of Vertex Array Objects (VAOs), from OpenGL 3.1+,
 * the GL_ARB_vertex_array_object extension, or the older
 * GL_APPLE_vertex_array_object extension.
d56 1
a56 1
 *
d63 2
a64 2
struct gl_vertex_array_object *
_mesa_lookup_vao(struct gl_context *ctx, GLuint id)
d69 1
a69 1
      return (struct gl_vertex_array_object *)
d75 1
a75 1
 * For all the vertex binding points in the array object, unbind any pointers
d80 1
a80 1
unbind_array_object_vbos(struct gl_context *ctx, struct gl_vertex_array_object *obj)
d84 2
a85 5
   for (i = 0; i < Elements(obj->VertexBinding); i++)
      _mesa_reference_buffer_object(ctx, &obj->VertexBinding[i].BufferObj, NULL);

   for (i = 0; i < Elements(obj->_VertexAttrib); i++)
      _mesa_reference_buffer_object(ctx, &obj->_VertexAttrib[i].BufferObj, NULL);
d91 1
a91 1
 *
d95 2
a96 2
struct gl_vertex_array_object *
_mesa_new_vao(struct gl_context *ctx, GLuint name)
d98 1
a98 1
   struct gl_vertex_array_object *obj = CALLOC_STRUCT(gl_vertex_array_object);
d100 1
a100 1
      _mesa_initialize_vao(ctx, obj, name);
d107 1
a107 1
 *
d112 1
a112 1
_mesa_delete_vao(struct gl_context *ctx, struct gl_vertex_array_object *obj)
d114 1
d116 2
a117 3
   _mesa_reference_buffer_object(ctx, &obj->IndexBufferObj, NULL);
   mtx_destroy(&obj->Mutex);
   free(obj->Label);
d123 2
a124 2
 * Set ptr to vao w/ reference counting.
 * Note: this should only be called from the _mesa_reference_vao()
d128 3
a130 3
_mesa_reference_vao_(struct gl_context *ctx,
                     struct gl_vertex_array_object **ptr,
                     struct gl_vertex_array_object *vao)
d132 1
a132 1
   assert(*ptr != vao);
d137 1
a137 1
      struct gl_vertex_array_object *oldObj = *ptr;
d139 1
a139 1
      mtx_lock(&oldObj->Mutex);
d147 1
a147 1
      mtx_unlock(&oldObj->Mutex);
d158 1
a158 1
   if (vao) {
d160 2
a161 2
      mtx_lock(&vao->Mutex);
      if (vao->RefCount == 0) {
d168 1
a168 1
         vao->RefCount++;
d171 1
a171 1
                (void *) vao, vao->Name, vao->RefCount);
d173 1
a173 1
         *ptr = vao;
d175 1
a175 1
      mtx_unlock(&vao->Mutex);
d183 1
a183 1
           struct gl_vertex_array_object *obj, GLuint index, GLint size, GLint type)
a184 3
   struct gl_vertex_attrib_array *array = &obj->VertexAttrib[index];
   struct gl_vertex_buffer_binding *binding = &obj->VertexBinding[index];

d189 1
a190 1
   array->RelativeOffset = 0;
a194 7
   array->VertexBinding = index;

   binding->Offset = 0;
   binding->Stride = array->_ElementSize;
   binding->BufferObj = NULL;
   binding->_BoundArrays = BITFIELD64_BIT(index);

d196 1
a196 1
   _mesa_reference_buffer_object(ctx, &binding->BufferObj,
d202 1
a202 1
 * Initialize a gl_vertex_array_object's arrays.
d205 3
a207 3
_mesa_initialize_vao(struct gl_context *ctx,
                     struct gl_vertex_array_object *obj,
                     GLuint name)
d213 1
a213 1
   mtx_init(&obj->Mutex, mtx_plain);
d217 1
a217 1
   for (i = 0; i < Elements(obj->_VertexAttrib); i++) {
d220 1
a220 1
         init_array(ctx, obj, VERT_ATTRIB_WEIGHT, 1, GL_FLOAT);
d223 1
a223 1
         init_array(ctx, obj, VERT_ATTRIB_NORMAL, 3, GL_FLOAT);
d226 1
a226 1
         init_array(ctx, obj, VERT_ATTRIB_COLOR1, 3, GL_FLOAT);
d229 1
a229 1
         init_array(ctx, obj, VERT_ATTRIB_FOG, 1, GL_FLOAT);
d232 1
a232 1
         init_array(ctx, obj, VERT_ATTRIB_COLOR_INDEX, 1, GL_FLOAT);
d235 1
a235 1
         init_array(ctx, obj, VERT_ATTRIB_EDGEFLAG, 1, GL_BOOL);
d238 1
a238 1
         init_array(ctx, obj, VERT_ATTRIB_POINT_SIZE, 1, GL_FLOAT);
d241 1
a241 1
         init_array(ctx, obj, i, 4, GL_FLOAT);
d246 1
a246 1
   _mesa_reference_buffer_object(ctx, &obj->IndexBufferObj,
d255 1
a255 1
save_array_object( struct gl_context *ctx, struct gl_vertex_array_object *obj )
d269 1
a269 1
remove_array_object( struct gl_context *ctx, struct gl_vertex_array_object *obj )
d280 2
a281 2
 * Helper for _mesa_update_vao_max_element().
 * \return  min(vao->_VertexAttrib[*]._MaxElement).
d284 1
a284 1
compute_max_element(struct gl_vertex_array_object *vao, GLbitfield64 enabled)
d287 1
a287 1

d292 2
a293 2

      client_array = &vao->_VertexAttrib[attrib];
d298 1
a298 1

d304 1
a304 1
 * Examine vertex arrays to update the gl_vertex_array_object::_MaxElement field.
d307 2
a308 2
_mesa_update_vao_max_element(struct gl_context *ctx,
                                      struct gl_vertex_array_object *vao)
d314 1
a314 1
      enabled = _mesa_array_object_get_enabled_ff(vao);
d316 1
a316 1
      enabled = _mesa_array_object_get_enabled_arb(vao);
d320 1
a320 29
   vao->_MaxElement = compute_max_element(vao, enabled);
}


/**
 * Updates the derived gl_client_arrays when a gl_vertex_attrib_array
 * or a gl_vertex_buffer_binding has changed.
 */
void
_mesa_update_vao_client_arrays(struct gl_context *ctx,
                               struct gl_vertex_array_object *vao)
{
   GLbitfield64 arrays = vao->NewArrays;

   while (arrays) {
      struct gl_client_array *client_array;
      struct gl_vertex_attrib_array *attrib_array;
      struct gl_vertex_buffer_binding *buffer_binding;

      GLint attrib = ffsll(arrays) - 1;
      arrays ^= BITFIELD64_BIT(attrib);

      attrib_array = &vao->VertexAttrib[attrib];
      buffer_binding = &vao->VertexBinding[attrib_array->VertexBinding];
      client_array = &vao->_VertexAttrib[attrib];

      _mesa_update_client_array(ctx, client_array, attrib_array,
                                buffer_binding);
   }
d337 2
a338 2
   struct gl_vertex_array_object * const oldObj = ctx->Array.VAO;
   struct gl_vertex_array_object *newObj = NULL;
d352 1
a352 1
      newObj = ctx->Array.DefaultVAO;
d356 1
a356 1
      newObj = _mesa_lookup_vao(ctx, id);
d359 1
a359 2
            _mesa_error(ctx, GL_INVALID_OPERATION,
                        "glBindVertexArray(non-gen name)");
d386 1
a386 1
   _mesa_reference_vao(ctx, &ctx->Array.VAO, newObj);
d426 1
a426 1
 *
d437 1
a437 1
      _mesa_error(ctx, GL_INVALID_VALUE, "glDeleteVertexArray(n)");
d442 1
a442 1
      struct gl_vertex_array_object *obj = _mesa_lookup_vao(ctx, ids[i]);
d451 1
a451 1
	 if ( obj == ctx->Array.VAO ) {
d461 1
a461 1
         _mesa_reference_vao(ctx, &obj, NULL);
d474 1
a474 1
static void
d481 1
a481 1
      _mesa_error(ctx, GL_INVALID_VALUE, "glGenVertexArrays");
d493 1
a493 1
      struct gl_vertex_array_object *obj;
d498 1
a498 1
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glGenVertexArrays");
d533 1
a533 1
 *
d535 1
a535 1
 * \return  \c GL_TRUE if \c id is the name of a array object,
d541 1
a541 1
   struct gl_vertex_array_object * obj;
d548 1
a548 1
   obj = _mesa_lookup_vao(ctx, id);
@


1.1.1.6
log
@Import Mesa 10.4.3
@
text
@d233 1
a233 1
   for (i = 0; i < Elements(obj->VertexAttrib); i++) {
d294 46
a427 15
   }

   if (ctx->Array.DrawMethod == DRAW_ARRAYS) {
      /* The _DrawArrays pointer is pointing at the VAO being unbound and
       * that VAO may be in the process of being deleted. If it's not going
       * to be deleted, this will have no effect, because the pointer needs
       * to be updated by the VBO module anyway.
       *
       * Before the VBO module can update the pointer, we have to set it
       * to NULL for drivers not to set up arrays which are not bound,
       * or to prevent a crash if the VAO being unbound is going to be
       * deleted.
       */
      ctx->Array._DrawArrays = NULL;
      ctx->Array.DrawMethod = DRAW_NONE;
@


1.1.1.7
log
@Import Mesa 10.2.9
@
text
@d233 1
a233 1
   for (i = 0; i < Elements(obj->_VertexAttrib); i++) {
a293 46

/**
 * Helper for _mesa_update_vao_max_element().
 * \return  min(vao->_VertexAttrib[*]._MaxElement).
 */
static GLuint
compute_max_element(struct gl_vertex_array_object *vao, GLbitfield64 enabled)
{
   GLuint min = ~((GLuint)0);

   while (enabled) {
      struct gl_client_array *client_array;
      GLint attrib = ffsll(enabled) - 1;
      enabled ^= BITFIELD64_BIT(attrib);

      client_array = &vao->_VertexAttrib[attrib];
      assert(client_array->Enabled);
      _mesa_update_array_max_element(client_array);
      min = MIN2(min, client_array->_MaxElement);
   }

   return min;
}


/**
 * Examine vertex arrays to update the gl_vertex_array_object::_MaxElement field.
 */
void
_mesa_update_vao_max_element(struct gl_context *ctx,
                                      struct gl_vertex_array_object *vao)
{
   GLbitfield64 enabled;

   if (!ctx->VertexProgram._Current ||
       ctx->VertexProgram._Current == ctx->VertexProgram._TnlProgram) {
      enabled = _mesa_array_object_get_enabled_ff(vao);
   } else {
      enabled = _mesa_array_object_get_enabled_arb(vao);
   }

   /* _MaxElement is one past the last legal array element */
   vao->_MaxElement = compute_max_element(vao, enabled);
}


d382 15
@


