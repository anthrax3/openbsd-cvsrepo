head	1.12;
access;
symbols
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	v10_2_9:1.1.1.8
	v10_4_3:1.1.1.7
	v10_2_7:1.1.1.6
	OPENBSD_5_6:1.9.0.2
	OPENBSD_5_6_BASE:1.9
	v10_2_3:1.1.1.6
	OPENBSD_5_5:1.8.0.2
	OPENBSD_5_5_BASE:1.8
	v9_2_5:1.1.1.5
	v9_2_3:1.1.1.5
	v9_2_2:1.1.1.5
	v9_2_1:1.1.1.5
	v9_2_0:1.1.1.5
	OPENBSD_5_4:1.7.0.4
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.6.0.4
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.5.0.6
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.4
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_3:1.2.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2015.12.23.05.17.52;	author jsg;	state dead;
branches;
next	1.11;
commitid	TnlogFl9nOv2eaRf;

1.11
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.10;
commitid	4ry2gvZGMXkCUD2n;

1.10
date	2015.01.25.14.41.21;	author jsg;	state Exp;
branches;
next	1.9;
commitid	mcxB0JvoI9gTDYXU;

1.9
date	2014.07.09.21.09.00;	author jsg;	state Exp;
branches;
next	1.8;
commitid	WPD6rgPryPkvXOr9;

1.8
date	2013.09.05.14.06.15;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2012.08.17.13.58.17;	author mpi;	state Exp;
branches;
next	1.6;

1.6
date	2011.10.23.13.37.42;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.05.22.20.06.30;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.05.17.20.26.41;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.14.58.20;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.02.12.21.09.27;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.49.43;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.49.43;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.56.32;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.30.48;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.45;	author matthieu;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.09.05.13.16.23;	author jsg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.07.09.20.34.58;	author jsg;	state Exp;
branches;
next	1.1.1.7;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.7
date	2015.01.25.14.12.26;	author jsg;	state Exp;
branches;
next	1.1.1.8;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.8
date	2015.02.20.22.49.33;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.12
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2008  Brian Paul   All Rights Reserved.
 * Copyright (C) 2009  VMware, Inc.   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#include "glheader.h"
#include "imports.h"
#include "accum.h"
#include "arrayobj.h"
#include "attrib.h"
#include "blend.h"
#include "buffers.h"
#include "bufferobj.h"
#include "clear.h"
#include "colormac.h"
#include "context.h"
#include "depth.h"
#include "enable.h"
#include "enums.h"
#include "fog.h"
#include "hint.h"
#include "light.h"
#include "lines.h"
#include "macros.h"
#include "matrix.h"
#include "multisample.h"
#include "points.h"
#include "polygon.h"
#include "shared.h"
#include "scissor.h"
#include "stencil.h"
#include "texenv.h"
#include "texgen.h"
#include "texobj.h"
#include "texparam.h"
#include "texstate.h"
#include "varray.h"
#include "viewport.h"
#include "mtypes.h"
#include "main/dispatch.h"
#include "hash.h"
#include <stdbool.h>


/**
 * glEnable()/glDisable() attribute group (GL_ENABLE_BIT).
 */
struct gl_enable_attrib
{
   GLboolean AlphaTest;
   GLboolean AutoNormal;
   GLboolean Blend;
   GLbitfield ClipPlanes;
   GLboolean ColorMaterial;
   GLboolean CullFace;
   GLboolean DepthClamp;
   GLboolean DepthTest;
   GLboolean Dither;
   GLboolean Fog;
   GLboolean Light[MAX_LIGHTS];
   GLboolean Lighting;
   GLboolean LineSmooth;
   GLboolean LineStipple;
   GLboolean IndexLogicOp;
   GLboolean ColorLogicOp;

   GLboolean Map1Color4;
   GLboolean Map1Index;
   GLboolean Map1Normal;
   GLboolean Map1TextureCoord1;
   GLboolean Map1TextureCoord2;
   GLboolean Map1TextureCoord3;
   GLboolean Map1TextureCoord4;
   GLboolean Map1Vertex3;
   GLboolean Map1Vertex4;
   GLboolean Map2Color4;
   GLboolean Map2Index;
   GLboolean Map2Normal;
   GLboolean Map2TextureCoord1;
   GLboolean Map2TextureCoord2;
   GLboolean Map2TextureCoord3;
   GLboolean Map2TextureCoord4;
   GLboolean Map2Vertex3;
   GLboolean Map2Vertex4;

   GLboolean Normalize;
   GLboolean PixelTexture;
   GLboolean PointSmooth;
   GLboolean PolygonOffsetPoint;
   GLboolean PolygonOffsetLine;
   GLboolean PolygonOffsetFill;
   GLboolean PolygonSmooth;
   GLboolean PolygonStipple;
   GLboolean RescaleNormals;
   GLbitfield Scissor;
   GLboolean Stencil;
   GLboolean StencilTwoSide;          /* GL_EXT_stencil_two_side */
   GLboolean MultisampleEnabled;      /* GL_ARB_multisample */
   GLboolean SampleAlphaToCoverage;   /* GL_ARB_multisample */
   GLboolean SampleAlphaToOne;        /* GL_ARB_multisample */
   GLboolean SampleCoverage;          /* GL_ARB_multisample */
   GLboolean RasterPositionUnclipped; /* GL_IBM_rasterpos_clip */

   GLbitfield Texture[MAX_TEXTURE_UNITS];
   GLbitfield TexGen[MAX_TEXTURE_UNITS];

   /* GL_ARB_vertex_program */
   GLboolean VertexProgram;
   GLboolean VertexProgramPointSize;
   GLboolean VertexProgramTwoSide;

   /* GL_ARB_fragment_program */
   GLboolean FragmentProgram;

   /* GL_ARB_point_sprite / GL_NV_point_sprite */
   GLboolean PointSprite;
   GLboolean FragmentShaderATI;

   /* GL_ARB_framebuffer_sRGB / GL_EXT_framebuffer_sRGB */
   GLboolean sRGBEnabled;
};


/**
 * Node for the attribute stack.
 */
struct gl_attrib_node
{
   GLbitfield kind;
   void *data;
   struct gl_attrib_node *next;
};



/**
 * Special struct for saving/restoring texture state (GL_TEXTURE_BIT)
 */
struct texture_state
{
   struct gl_texture_attrib Texture;  /**< The usual context state */

   /** to save per texture object state (wrap modes, filters, etc): */
   struct gl_texture_object SavedObj[MAX_TEXTURE_UNITS][NUM_TEXTURE_TARGETS];

   /**
    * To save references to texture objects (so they don't get accidentally
    * deleted while saved in the attribute stack).
    */
   struct gl_texture_object *SavedTexRef[MAX_TEXTURE_UNITS][NUM_TEXTURE_TARGETS];

   /* We need to keep a reference to the shared state.  That's where the
    * default texture objects are kept.  We don't want that state to be
    * freed while the attribute stack contains pointers to any default
    * texture objects.
    */
   struct gl_shared_state *SharedRef;
};


/**
 * Allocate new attribute node of given type/kind.  Attach payload data.
 * Insert it into the linked list named by 'head'.
 */
static bool
save_attrib_data(struct gl_attrib_node **head,
                 GLbitfield kind, void *payload)
{
   struct gl_attrib_node *n = MALLOC_STRUCT(gl_attrib_node);
   if (n) {
      n->kind = kind;
      n->data = payload;
      /* insert at head */
      n->next = *head;
      *head = n;
   }
   else {
      /* out of memory! */
      return false;
   }
   return true;
}


/**
 * Helper function for_mesa_PushAttrib for simple attributes.
 * Allocates memory for attribute data and copies the given attribute data.
 * \param head  head of linked list to insert attribute data into
 * \param attr_bit  one of the GL_<attrib>_BIT flags
 * \param attr_size  number of bytes to allocate for attribute data
 * \param attr_data  the attribute data to copy
 * \return true for success, false for out of memory
 */
static bool
push_attrib(struct gl_context *ctx, struct gl_attrib_node **head,
            GLbitfield attr_bit, GLuint attr_size, const void *attr_data)
{
   void *attribute;

   attribute = malloc(attr_size);
   if (attribute == NULL) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glPushAttrib");
      return false;
   }

   if (save_attrib_data(head, attr_bit, attribute)) {
      memcpy(attribute, attr_data, attr_size);
   }
   else {
      free(attribute);
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glPushAttrib");
      return false;
   }
   return true;
}


void GLAPIENTRY
_mesa_PushAttrib(GLbitfield mask)
{
   struct gl_attrib_node *head;

   GET_CURRENT_CONTEXT(ctx);

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glPushAttrib %x\n", (int) mask);

   if (ctx->AttribStackDepth >= MAX_ATTRIB_STACK_DEPTH) {
      _mesa_error( ctx, GL_STACK_OVERFLOW, "glPushAttrib" );
      return;
   }

   /* Build linked list of attribute nodes which save all attribute */
   /* groups specified by the mask. */
   head = NULL;

   if (mask & GL_ACCUM_BUFFER_BIT) {
      if (!push_attrib(ctx, &head, GL_ACCUM_BUFFER_BIT,
                       sizeof(struct gl_accum_attrib),
                       (void*)&ctx->Accum))
         goto end;
   }

   if (mask & GL_COLOR_BUFFER_BIT) {
      GLuint i;
      struct gl_colorbuffer_attrib *attr;
      attr = MALLOC_STRUCT( gl_colorbuffer_attrib );
      if (attr == NULL) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glPushAttrib");
         goto end;
      }

    if (save_attrib_data(&head, GL_COLOR_BUFFER_BIT, attr)) {
         memcpy(attr, &ctx->Color, sizeof(struct gl_colorbuffer_attrib));
         /* push the Draw FBO's DrawBuffer[] state, not ctx->Color.DrawBuffer[] */
         for (i = 0; i < ctx->Const.MaxDrawBuffers; i ++)
            attr->DrawBuffer[i] = ctx->DrawBuffer->ColorDrawBuffer[i];
      }
      else {
         free(attr);
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glPushAttrib");
         goto end;
      }
   }

   if (mask & GL_CURRENT_BIT) {
      FLUSH_CURRENT(ctx, 0);
      if (!push_attrib(ctx, &head, GL_CURRENT_BIT,
                       sizeof(struct gl_current_attrib),
                       (void*)&ctx->Current))
         goto end;
   }

   if (mask & GL_DEPTH_BUFFER_BIT) {
      if (!push_attrib(ctx, &head, GL_DEPTH_BUFFER_BIT,
                       sizeof(struct gl_depthbuffer_attrib),
                       (void*)&ctx->Depth))
         goto end;
   }

   if (mask & GL_ENABLE_BIT) {
      struct gl_enable_attrib *attr;
      GLuint i;
      attr = MALLOC_STRUCT( gl_enable_attrib );
      if (attr == NULL) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glPushAttrib");
         goto end;
      }

      /* Copy enable flags from all other attributes into the enable struct. */
      attr->AlphaTest = ctx->Color.AlphaEnabled;
      attr->AutoNormal = ctx->Eval.AutoNormal;
      attr->Blend = ctx->Color.BlendEnabled;
      attr->ClipPlanes = ctx->Transform.ClipPlanesEnabled;
      attr->ColorMaterial = ctx->Light.ColorMaterialEnabled;
      attr->CullFace = ctx->Polygon.CullFlag;
      attr->DepthClamp = ctx->Transform.DepthClamp;
      attr->DepthTest = ctx->Depth.Test;
      attr->Dither = ctx->Color.DitherFlag;
      attr->Fog = ctx->Fog.Enabled;
      for (i = 0; i < ctx->Const.MaxLights; i++) {
         attr->Light[i] = ctx->Light.Light[i].Enabled;
      }
      attr->Lighting = ctx->Light.Enabled;
      attr->LineSmooth = ctx->Line.SmoothFlag;
      attr->LineStipple = ctx->Line.StippleFlag;
      attr->IndexLogicOp = ctx->Color.IndexLogicOpEnabled;
      attr->ColorLogicOp = ctx->Color.ColorLogicOpEnabled;
      attr->Map1Color4 = ctx->Eval.Map1Color4;
      attr->Map1Index = ctx->Eval.Map1Index;
      attr->Map1Normal = ctx->Eval.Map1Normal;
      attr->Map1TextureCoord1 = ctx->Eval.Map1TextureCoord1;
      attr->Map1TextureCoord2 = ctx->Eval.Map1TextureCoord2;
      attr->Map1TextureCoord3 = ctx->Eval.Map1TextureCoord3;
      attr->Map1TextureCoord4 = ctx->Eval.Map1TextureCoord4;
      attr->Map1Vertex3 = ctx->Eval.Map1Vertex3;
      attr->Map1Vertex4 = ctx->Eval.Map1Vertex4;
      attr->Map2Color4 = ctx->Eval.Map2Color4;
      attr->Map2Index = ctx->Eval.Map2Index;
      attr->Map2Normal = ctx->Eval.Map2Normal;
      attr->Map2TextureCoord1 = ctx->Eval.Map2TextureCoord1;
      attr->Map2TextureCoord2 = ctx->Eval.Map2TextureCoord2;
      attr->Map2TextureCoord3 = ctx->Eval.Map2TextureCoord3;
      attr->Map2TextureCoord4 = ctx->Eval.Map2TextureCoord4;
      attr->Map2Vertex3 = ctx->Eval.Map2Vertex3;
      attr->Map2Vertex4 = ctx->Eval.Map2Vertex4;
      attr->Normalize = ctx->Transform.Normalize;
      attr->RasterPositionUnclipped = ctx->Transform.RasterPositionUnclipped;
      attr->PointSmooth = ctx->Point.SmoothFlag;
      attr->PointSprite = ctx->Point.PointSprite;
      attr->PolygonOffsetPoint = ctx->Polygon.OffsetPoint;
      attr->PolygonOffsetLine = ctx->Polygon.OffsetLine;
      attr->PolygonOffsetFill = ctx->Polygon.OffsetFill;
      attr->PolygonSmooth = ctx->Polygon.SmoothFlag;
      attr->PolygonStipple = ctx->Polygon.StippleFlag;
      attr->RescaleNormals = ctx->Transform.RescaleNormals;
      attr->Scissor = ctx->Scissor.EnableFlags;
      attr->Stencil = ctx->Stencil.Enabled;
      attr->StencilTwoSide = ctx->Stencil.TestTwoSide;
      attr->MultisampleEnabled = ctx->Multisample.Enabled;
      attr->SampleAlphaToCoverage = ctx->Multisample.SampleAlphaToCoverage;
      attr->SampleAlphaToOne = ctx->Multisample.SampleAlphaToOne;
      attr->SampleCoverage = ctx->Multisample.SampleCoverage;
      for (i = 0; i < ctx->Const.MaxTextureUnits; i++) {
         attr->Texture[i] = ctx->Texture.Unit[i].Enabled;
         attr->TexGen[i] = ctx->Texture.Unit[i].TexGenEnabled;
      }
      /* GL_ARB_vertex_program */
      attr->VertexProgram = ctx->VertexProgram.Enabled;
      attr->VertexProgramPointSize = ctx->VertexProgram.PointSizeEnabled;
      attr->VertexProgramTwoSide = ctx->VertexProgram.TwoSideEnabled;

      /* GL_ARB_fragment_program */
      attr->FragmentProgram = ctx->FragmentProgram.Enabled;

      if (!save_attrib_data(&head, GL_ENABLE_BIT, attr)) {
         free(attr);
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glPushAttrib");
         goto end;
      }

      /* GL_ARB_framebuffer_sRGB / GL_EXT_framebuffer_sRGB */
      attr->sRGBEnabled = ctx->Color.sRGBEnabled;
   }

   if (mask & GL_EVAL_BIT) {
      if (!push_attrib(ctx, &head, GL_EVAL_BIT,
                       sizeof(struct gl_eval_attrib),
                       (void*)&ctx->Eval))
         goto end;
   }

   if (mask & GL_FOG_BIT) {
      if (!push_attrib(ctx, &head, GL_FOG_BIT,
                       sizeof(struct gl_fog_attrib),
                       (void*)&ctx->Fog))
         goto end;
   }

   if (mask & GL_HINT_BIT) {
      if (!push_attrib(ctx, &head, GL_HINT_BIT,
                       sizeof(struct gl_hint_attrib),
                       (void*)&ctx->Hint))
         goto end;
   }

   if (mask & GL_LIGHTING_BIT) {
      FLUSH_CURRENT(ctx, 0);   /* flush material changes */
      if (!push_attrib(ctx, &head, GL_LIGHTING_BIT,
                       sizeof(struct gl_light_attrib),
                       (void*)&ctx->Light))
         goto end;
   }

   if (mask & GL_LINE_BIT) {
      if (!push_attrib(ctx, &head, GL_LINE_BIT,
                       sizeof(struct gl_line_attrib),
                       (void*)&ctx->Line))
         goto end;
   }

   if (mask & GL_LIST_BIT) {
      if (!push_attrib(ctx, &head, GL_LIST_BIT,
                       sizeof(struct gl_list_attrib),
                       (void*)&ctx->List))
         goto end;
   }

   if (mask & GL_PIXEL_MODE_BIT) {
      struct gl_pixel_attrib *attr;
      attr = MALLOC_STRUCT( gl_pixel_attrib );
      if (attr == NULL) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glPushAttrib");
         goto end;
      }

      if (save_attrib_data(&head, GL_PIXEL_MODE_BIT, attr)) {
         memcpy(attr, &ctx->Pixel, sizeof(struct gl_pixel_attrib));
         /* push the Read FBO's ReadBuffer state, not ctx->Pixel.ReadBuffer */
         attr->ReadBuffer = ctx->ReadBuffer->ColorReadBuffer;
      }
      else {
         free(attr);
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glPushAttrib");
         goto end;
      }
   }

   if (mask & GL_POINT_BIT) {
      if (!push_attrib(ctx, &head, GL_POINT_BIT,
                       sizeof(struct gl_point_attrib),
                       (void*)&ctx->Point))
         goto end;
   }

   if (mask & GL_POLYGON_BIT) {
      if (!push_attrib(ctx, &head, GL_POLYGON_BIT,
                       sizeof(struct gl_polygon_attrib),
                       (void*)&ctx->Polygon))
         goto end;
   }

   if (mask & GL_POLYGON_STIPPLE_BIT) {
      if (!push_attrib(ctx, &head, GL_POLYGON_STIPPLE_BIT,
                       sizeof(ctx->PolygonStipple),
                       (void*)&ctx->PolygonStipple))
         goto end;
   }

   if (mask & GL_SCISSOR_BIT) {
      if (!push_attrib(ctx, &head, GL_SCISSOR_BIT,
                       sizeof(struct gl_scissor_attrib),
                       (void*)&ctx->Scissor))
         goto end;
   }

   if (mask & GL_STENCIL_BUFFER_BIT) {
      if (!push_attrib(ctx, &head, GL_STENCIL_BUFFER_BIT,
                       sizeof(struct gl_stencil_attrib),
                       (void*)&ctx->Stencil))
         goto end;
   }

   if (mask & GL_TEXTURE_BIT) {
      struct texture_state *texstate = CALLOC_STRUCT(texture_state);
      GLuint u, tex;

      if (!texstate) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glPushAttrib(GL_TEXTURE_BIT)");
         goto end;
      }

      if (!save_attrib_data(&head, GL_TEXTURE_BIT, texstate)) {
         free(texstate);
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glPushAttrib(GL_TEXTURE_BIT)");
         goto end;
      }

      _mesa_lock_context_textures(ctx);

      /* copy/save the bulk of texture state here */
      memcpy(&texstate->Texture, &ctx->Texture, sizeof(ctx->Texture));

      /* Save references to the currently bound texture objects so they don't
       * accidentally get deleted while referenced in the attribute stack.
       */
      for (u = 0; u < ctx->Const.MaxTextureUnits; u++) {
         for (tex = 0; tex < NUM_TEXTURE_TARGETS; tex++) {
            _mesa_reference_texobj(&texstate->SavedTexRef[u][tex],
                                   ctx->Texture.Unit[u].CurrentTex[tex]);
         }
      }

      /* copy state/contents of the currently bound texture objects */
      for (u = 0; u < ctx->Const.MaxTextureUnits; u++) {
         for (tex = 0; tex < NUM_TEXTURE_TARGETS; tex++) {
            _mesa_copy_texture_object(&texstate->SavedObj[u][tex],
                                      ctx->Texture.Unit[u].CurrentTex[tex]);
         }
      }

      _mesa_reference_shared_state(ctx, &texstate->SharedRef, ctx->Shared);

      _mesa_unlock_context_textures(ctx);
   }

   if (mask & GL_TRANSFORM_BIT) {
      if (!push_attrib(ctx, &head, GL_TRANSFORM_BIT,
                       sizeof(struct gl_transform_attrib),
                       (void*)&ctx->Transform))
         goto end;
   }

   if (mask & GL_VIEWPORT_BIT) {
      if (!push_attrib(ctx, &head, GL_VIEWPORT_BIT,
                       sizeof(struct gl_viewport_attrib)
                       * ctx->Const.MaxViewports,
                       (void*)&ctx->ViewportArray))
         goto end;
   }

   /* GL_ARB_multisample */
   if (mask & GL_MULTISAMPLE_BIT_ARB) {
      if (!push_attrib(ctx, &head, GL_MULTISAMPLE_BIT_ARB,
                       sizeof(struct gl_multisample_attrib),
                       (void*)&ctx->Multisample))
         goto end;
   }

end:
   if (head != NULL) {
       ctx->AttribStack[ctx->AttribStackDepth] = head;
       ctx->AttribStackDepth++;
   }
}



static void
pop_enable_group(struct gl_context *ctx, const struct gl_enable_attrib *enable)
{
   const GLuint curTexUnitSave = ctx->Texture.CurrentUnit;
   GLuint i;

#define TEST_AND_UPDATE(VALUE, NEWVALUE, ENUM)		\
	if ((VALUE) != (NEWVALUE)) {			\
	   _mesa_set_enable( ctx, ENUM, (NEWVALUE) );	\
	}

   TEST_AND_UPDATE(ctx->Color.AlphaEnabled, enable->AlphaTest, GL_ALPHA_TEST);
   if (ctx->Color.BlendEnabled != enable->Blend) {
      if (ctx->Extensions.EXT_draw_buffers2) {
         GLuint i;
         for (i = 0; i < ctx->Const.MaxDrawBuffers; i++) {
            _mesa_set_enablei(ctx, GL_BLEND, i, (enable->Blend >> i) & 1);
         }
      }
      else {
         _mesa_set_enable(ctx, GL_BLEND, (enable->Blend & 1));
      }
   }

   for (i=0;i<ctx->Const.MaxClipPlanes;i++) {
      const GLuint mask = 1 << i;
      if ((ctx->Transform.ClipPlanesEnabled & mask) != (enable->ClipPlanes & mask))
	  _mesa_set_enable(ctx, (GLenum) (GL_CLIP_PLANE0 + i),
			   !!(enable->ClipPlanes & mask));
   }

   TEST_AND_UPDATE(ctx->Light.ColorMaterialEnabled, enable->ColorMaterial,
                   GL_COLOR_MATERIAL);
   TEST_AND_UPDATE(ctx->Polygon.CullFlag, enable->CullFace, GL_CULL_FACE);
   TEST_AND_UPDATE(ctx->Transform.DepthClamp, enable->DepthClamp,
		   GL_DEPTH_CLAMP);
   TEST_AND_UPDATE(ctx->Depth.Test, enable->DepthTest, GL_DEPTH_TEST);
   TEST_AND_UPDATE(ctx->Color.DitherFlag, enable->Dither, GL_DITHER);
   TEST_AND_UPDATE(ctx->Fog.Enabled, enable->Fog, GL_FOG);
   TEST_AND_UPDATE(ctx->Light.Enabled, enable->Lighting, GL_LIGHTING);
   TEST_AND_UPDATE(ctx->Line.SmoothFlag, enable->LineSmooth, GL_LINE_SMOOTH);
   TEST_AND_UPDATE(ctx->Line.StippleFlag, enable->LineStipple,
                   GL_LINE_STIPPLE);
   TEST_AND_UPDATE(ctx->Color.IndexLogicOpEnabled, enable->IndexLogicOp,
                   GL_INDEX_LOGIC_OP);
   TEST_AND_UPDATE(ctx->Color.ColorLogicOpEnabled, enable->ColorLogicOp,
                   GL_COLOR_LOGIC_OP);

   TEST_AND_UPDATE(ctx->Eval.Map1Color4, enable->Map1Color4, GL_MAP1_COLOR_4);
   TEST_AND_UPDATE(ctx->Eval.Map1Index, enable->Map1Index, GL_MAP1_INDEX);
   TEST_AND_UPDATE(ctx->Eval.Map1Normal, enable->Map1Normal, GL_MAP1_NORMAL);
   TEST_AND_UPDATE(ctx->Eval.Map1TextureCoord1, enable->Map1TextureCoord1,
                   GL_MAP1_TEXTURE_COORD_1);
   TEST_AND_UPDATE(ctx->Eval.Map1TextureCoord2, enable->Map1TextureCoord2,
                   GL_MAP1_TEXTURE_COORD_2);
   TEST_AND_UPDATE(ctx->Eval.Map1TextureCoord3, enable->Map1TextureCoord3,
                   GL_MAP1_TEXTURE_COORD_3);
   TEST_AND_UPDATE(ctx->Eval.Map1TextureCoord4, enable->Map1TextureCoord4,
                   GL_MAP1_TEXTURE_COORD_4);
   TEST_AND_UPDATE(ctx->Eval.Map1Vertex3, enable->Map1Vertex3,
                   GL_MAP1_VERTEX_3);
   TEST_AND_UPDATE(ctx->Eval.Map1Vertex4, enable->Map1Vertex4,
                   GL_MAP1_VERTEX_4);

   TEST_AND_UPDATE(ctx->Eval.Map2Color4, enable->Map2Color4, GL_MAP2_COLOR_4);
   TEST_AND_UPDATE(ctx->Eval.Map2Index, enable->Map2Index, GL_MAP2_INDEX);
   TEST_AND_UPDATE(ctx->Eval.Map2Normal, enable->Map2Normal, GL_MAP2_NORMAL);
   TEST_AND_UPDATE(ctx->Eval.Map2TextureCoord1, enable->Map2TextureCoord1,
                   GL_MAP2_TEXTURE_COORD_1);
   TEST_AND_UPDATE(ctx->Eval.Map2TextureCoord2, enable->Map2TextureCoord2,
                   GL_MAP2_TEXTURE_COORD_2);
   TEST_AND_UPDATE(ctx->Eval.Map2TextureCoord3, enable->Map2TextureCoord3,
                   GL_MAP2_TEXTURE_COORD_3);
   TEST_AND_UPDATE(ctx->Eval.Map2TextureCoord4, enable->Map2TextureCoord4,
                   GL_MAP2_TEXTURE_COORD_4);
   TEST_AND_UPDATE(ctx->Eval.Map2Vertex3, enable->Map2Vertex3,
                   GL_MAP2_VERTEX_3);
   TEST_AND_UPDATE(ctx->Eval.Map2Vertex4, enable->Map2Vertex4,
                   GL_MAP2_VERTEX_4);

   TEST_AND_UPDATE(ctx->Eval.AutoNormal, enable->AutoNormal, GL_AUTO_NORMAL);
   TEST_AND_UPDATE(ctx->Transform.Normalize, enable->Normalize, GL_NORMALIZE);
   TEST_AND_UPDATE(ctx->Transform.RescaleNormals, enable->RescaleNormals,
                   GL_RESCALE_NORMAL_EXT);
   TEST_AND_UPDATE(ctx->Transform.RasterPositionUnclipped,
                   enable->RasterPositionUnclipped,
                   GL_RASTER_POSITION_UNCLIPPED_IBM);
   TEST_AND_UPDATE(ctx->Point.SmoothFlag, enable->PointSmooth,
                   GL_POINT_SMOOTH);
   if (ctx->Extensions.NV_point_sprite || ctx->Extensions.ARB_point_sprite) {
      TEST_AND_UPDATE(ctx->Point.PointSprite, enable->PointSprite,
                      GL_POINT_SPRITE_NV);
   }
   TEST_AND_UPDATE(ctx->Polygon.OffsetPoint, enable->PolygonOffsetPoint,
                   GL_POLYGON_OFFSET_POINT);
   TEST_AND_UPDATE(ctx->Polygon.OffsetLine, enable->PolygonOffsetLine,
                   GL_POLYGON_OFFSET_LINE);
   TEST_AND_UPDATE(ctx->Polygon.OffsetFill, enable->PolygonOffsetFill,
                   GL_POLYGON_OFFSET_FILL);
   TEST_AND_UPDATE(ctx->Polygon.SmoothFlag, enable->PolygonSmooth,
                   GL_POLYGON_SMOOTH);
   TEST_AND_UPDATE(ctx->Polygon.StippleFlag, enable->PolygonStipple,
                   GL_POLYGON_STIPPLE);
   if (ctx->Scissor.EnableFlags != enable->Scissor) {
      unsigned i;

      for (i = 0; i < ctx->Const.MaxViewports; i++) {
         _mesa_set_enablei(ctx, GL_SCISSOR_TEST, i, (enable->Scissor >> i) & 1);
      }
   }
   TEST_AND_UPDATE(ctx->Stencil.Enabled, enable->Stencil, GL_STENCIL_TEST);
   if (ctx->Extensions.EXT_stencil_two_side) {
      TEST_AND_UPDATE(ctx->Stencil.TestTwoSide, enable->StencilTwoSide, GL_STENCIL_TEST_TWO_SIDE_EXT);
   }
   TEST_AND_UPDATE(ctx->Multisample.Enabled, enable->MultisampleEnabled,
                   GL_MULTISAMPLE_ARB);
   TEST_AND_UPDATE(ctx->Multisample.SampleAlphaToCoverage,
                   enable->SampleAlphaToCoverage,
                   GL_SAMPLE_ALPHA_TO_COVERAGE_ARB);
   TEST_AND_UPDATE(ctx->Multisample.SampleAlphaToOne,
                   enable->SampleAlphaToOne,
                   GL_SAMPLE_ALPHA_TO_ONE_ARB);
   TEST_AND_UPDATE(ctx->Multisample.SampleCoverage,
                   enable->SampleCoverage,
                   GL_SAMPLE_COVERAGE_ARB);
   /* GL_ARB_vertex_program */
   TEST_AND_UPDATE(ctx->VertexProgram.Enabled,
                   enable->VertexProgram,
                   GL_VERTEX_PROGRAM_ARB);
   TEST_AND_UPDATE(ctx->VertexProgram.PointSizeEnabled,
                   enable->VertexProgramPointSize,
                   GL_VERTEX_PROGRAM_POINT_SIZE_ARB);
   TEST_AND_UPDATE(ctx->VertexProgram.TwoSideEnabled,
                   enable->VertexProgramTwoSide,
                   GL_VERTEX_PROGRAM_TWO_SIDE_ARB);

   /* GL_ARB_fragment_program */
   TEST_AND_UPDATE(ctx->FragmentProgram.Enabled,
                   enable->FragmentProgram,
                   GL_FRAGMENT_PROGRAM_ARB);

   /* GL_ARB_framebuffer_sRGB / GL_EXT_framebuffer_sRGB */
   TEST_AND_UPDATE(ctx->Color.sRGBEnabled, enable->sRGBEnabled,
                   GL_FRAMEBUFFER_SRGB);

   /* texture unit enables */
   for (i = 0; i < ctx->Const.MaxTextureUnits; i++) {
      const GLbitfield enabled = enable->Texture[i];
      const GLbitfield genEnabled = enable->TexGen[i];

      if (ctx->Texture.Unit[i].Enabled != enabled) {
         _mesa_ActiveTexture(GL_TEXTURE0 + i);

         _mesa_set_enable(ctx, GL_TEXTURE_1D, !!(enabled & TEXTURE_1D_BIT));
         _mesa_set_enable(ctx, GL_TEXTURE_2D, !!(enabled & TEXTURE_2D_BIT));
         _mesa_set_enable(ctx, GL_TEXTURE_3D, !!(enabled & TEXTURE_3D_BIT));
         if (ctx->Extensions.NV_texture_rectangle) {
            _mesa_set_enable(ctx, GL_TEXTURE_RECTANGLE_ARB,
                             !!(enabled & TEXTURE_RECT_BIT));
         }
         if (ctx->Extensions.ARB_texture_cube_map) {
            _mesa_set_enable(ctx, GL_TEXTURE_CUBE_MAP,
                             !!(enabled & TEXTURE_CUBE_BIT));
         }
      }

      if (ctx->Texture.Unit[i].TexGenEnabled != genEnabled) {
         _mesa_ActiveTexture(GL_TEXTURE0 + i);
         _mesa_set_enable(ctx, GL_TEXTURE_GEN_S, !!(genEnabled & S_BIT));
         _mesa_set_enable(ctx, GL_TEXTURE_GEN_T, !!(genEnabled & T_BIT));
         _mesa_set_enable(ctx, GL_TEXTURE_GEN_R, !!(genEnabled & R_BIT));
         _mesa_set_enable(ctx, GL_TEXTURE_GEN_Q, !!(genEnabled & Q_BIT));
      }
   }

   _mesa_ActiveTexture(GL_TEXTURE0 + curTexUnitSave);
}


/**
 * Pop/restore texture attribute/group state.
 */
static void
pop_texture_group(struct gl_context *ctx, struct texture_state *texstate)
{
   GLuint u;

   _mesa_lock_context_textures(ctx);

   for (u = 0; u < ctx->Const.MaxTextureUnits; u++) {
      const struct gl_texture_unit *unit = &texstate->Texture.Unit[u];
      GLuint tgt;

      _mesa_ActiveTexture(GL_TEXTURE0_ARB + u);
      _mesa_set_enable(ctx, GL_TEXTURE_1D, !!(unit->Enabled & TEXTURE_1D_BIT));
      _mesa_set_enable(ctx, GL_TEXTURE_2D, !!(unit->Enabled & TEXTURE_2D_BIT));
      _mesa_set_enable(ctx, GL_TEXTURE_3D, !!(unit->Enabled & TEXTURE_3D_BIT));
      if (ctx->Extensions.ARB_texture_cube_map) {
         _mesa_set_enable(ctx, GL_TEXTURE_CUBE_MAP_ARB,
                          !!(unit->Enabled & TEXTURE_CUBE_BIT));
      }
      if (ctx->Extensions.NV_texture_rectangle) {
         _mesa_set_enable(ctx, GL_TEXTURE_RECTANGLE_NV,
                          !!(unit->Enabled & TEXTURE_RECT_BIT));
      }
      _mesa_TexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, unit->EnvMode);
      _mesa_TexEnvfv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_COLOR, unit->EnvColor);
      _mesa_TexGeni(GL_S, GL_TEXTURE_GEN_MODE, unit->GenS.Mode);
      _mesa_TexGeni(GL_T, GL_TEXTURE_GEN_MODE, unit->GenT.Mode);
      _mesa_TexGeni(GL_R, GL_TEXTURE_GEN_MODE, unit->GenR.Mode);
      _mesa_TexGeni(GL_Q, GL_TEXTURE_GEN_MODE, unit->GenQ.Mode);
      _mesa_TexGenfv(GL_S, GL_OBJECT_PLANE, unit->GenS.ObjectPlane);
      _mesa_TexGenfv(GL_T, GL_OBJECT_PLANE, unit->GenT.ObjectPlane);
      _mesa_TexGenfv(GL_R, GL_OBJECT_PLANE, unit->GenR.ObjectPlane);
      _mesa_TexGenfv(GL_Q, GL_OBJECT_PLANE, unit->GenQ.ObjectPlane);
      /* Eye plane done differently to avoid re-transformation */
      {
         struct gl_texture_unit *destUnit = &ctx->Texture.Unit[u];
         COPY_4FV(destUnit->GenS.EyePlane, unit->GenS.EyePlane);
         COPY_4FV(destUnit->GenT.EyePlane, unit->GenT.EyePlane);
         COPY_4FV(destUnit->GenR.EyePlane, unit->GenR.EyePlane);
         COPY_4FV(destUnit->GenQ.EyePlane, unit->GenQ.EyePlane);
         if (ctx->Driver.TexGen) {
            ctx->Driver.TexGen(ctx, GL_S, GL_EYE_PLANE, unit->GenS.EyePlane);
            ctx->Driver.TexGen(ctx, GL_T, GL_EYE_PLANE, unit->GenT.EyePlane);
            ctx->Driver.TexGen(ctx, GL_R, GL_EYE_PLANE, unit->GenR.EyePlane);
            ctx->Driver.TexGen(ctx, GL_Q, GL_EYE_PLANE, unit->GenQ.EyePlane);
         }
      }
      _mesa_set_enable(ctx, GL_TEXTURE_GEN_S, !!(unit->TexGenEnabled & S_BIT));
      _mesa_set_enable(ctx, GL_TEXTURE_GEN_T, !!(unit->TexGenEnabled & T_BIT));
      _mesa_set_enable(ctx, GL_TEXTURE_GEN_R, !!(unit->TexGenEnabled & R_BIT));
      _mesa_set_enable(ctx, GL_TEXTURE_GEN_Q, !!(unit->TexGenEnabled & Q_BIT));
      _mesa_TexEnvf(GL_TEXTURE_FILTER_CONTROL, GL_TEXTURE_LOD_BIAS,
		    unit->LodBias);
      _mesa_TexEnvi(GL_TEXTURE_ENV, GL_COMBINE_RGB,
		    unit->Combine.ModeRGB);
      _mesa_TexEnvi(GL_TEXTURE_ENV, GL_COMBINE_ALPHA,
		    unit->Combine.ModeA);
      {
         const GLuint n = ctx->Extensions.NV_texture_env_combine4 ? 4 : 3;
         GLuint i;
         for (i = 0; i < n; i++) {
            _mesa_TexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_RGB + i,
                          unit->Combine.SourceRGB[i]);
            _mesa_TexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_ALPHA + i,
                          unit->Combine.SourceA[i]);
            _mesa_TexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_RGB + i,
                          unit->Combine.OperandRGB[i]);
            _mesa_TexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_ALPHA + i,
                          unit->Combine.OperandA[i]);
         }
      }
      _mesa_TexEnvi(GL_TEXTURE_ENV, GL_RGB_SCALE,
		    1 << unit->Combine.ScaleShiftRGB);
      _mesa_TexEnvi(GL_TEXTURE_ENV, GL_ALPHA_SCALE,
		    1 << unit->Combine.ScaleShiftA);

      /* Restore texture object state for each target */
      for (tgt = 0; tgt < NUM_TEXTURE_TARGETS; tgt++) {
         const struct gl_texture_object *obj = NULL;
         const struct gl_sampler_object *samp;
         GLenum target;

         obj = &texstate->SavedObj[u][tgt];

         /* don't restore state for unsupported targets to prevent
          * raising GL errors.
          */
         if (obj->Target == GL_TEXTURE_CUBE_MAP_ARB &&
             !ctx->Extensions.ARB_texture_cube_map) {
            continue;
         }
         else if (obj->Target == GL_TEXTURE_RECTANGLE_NV &&
                  !ctx->Extensions.NV_texture_rectangle) {
            continue;
         }
         else if ((obj->Target == GL_TEXTURE_1D_ARRAY_EXT ||
                   obj->Target == GL_TEXTURE_2D_ARRAY_EXT) &&
                  !ctx->Extensions.EXT_texture_array) {
            continue;
         }
         else if (obj->Target == GL_TEXTURE_CUBE_MAP_ARRAY &&
             !ctx->Extensions.ARB_texture_cube_map_array) {
            continue;
         } else if (obj->Target == GL_TEXTURE_BUFFER)
            continue;
         else if (obj->Target == GL_TEXTURE_EXTERNAL_OES)
            continue;
         else if (obj->Target == GL_TEXTURE_2D_MULTISAMPLE ||
                  obj->Target == GL_TEXTURE_2D_MULTISAMPLE_ARRAY)
            continue;

         target = obj->Target;

         _mesa_BindTexture(target, obj->Name);

         samp = &obj->Sampler;

         _mesa_TexParameterfv(target, GL_TEXTURE_BORDER_COLOR, samp->BorderColor.f);
         _mesa_TexParameteri(target, GL_TEXTURE_WRAP_S, samp->WrapS);
         _mesa_TexParameteri(target, GL_TEXTURE_WRAP_T, samp->WrapT);
         _mesa_TexParameteri(target, GL_TEXTURE_WRAP_R, samp->WrapR);
         _mesa_TexParameteri(target, GL_TEXTURE_MIN_FILTER, samp->MinFilter);
         _mesa_TexParameteri(target, GL_TEXTURE_MAG_FILTER, samp->MagFilter);
         _mesa_TexParameterf(target, GL_TEXTURE_MIN_LOD, samp->MinLod);
         _mesa_TexParameterf(target, GL_TEXTURE_MAX_LOD, samp->MaxLod);
         _mesa_TexParameterf(target, GL_TEXTURE_LOD_BIAS, samp->LodBias);
         _mesa_TexParameterf(target, GL_TEXTURE_PRIORITY, obj->Priority);
         _mesa_TexParameteri(target, GL_TEXTURE_BASE_LEVEL, obj->BaseLevel);
         if (target != GL_TEXTURE_RECTANGLE_ARB)
            _mesa_TexParameteri(target, GL_TEXTURE_MAX_LEVEL, obj->MaxLevel);
         if (ctx->Extensions.EXT_texture_filter_anisotropic) {
            _mesa_TexParameterf(target, GL_TEXTURE_MAX_ANISOTROPY_EXT,
                                samp->MaxAnisotropy);
         }
         if (ctx->Extensions.ARB_shadow) {
            _mesa_TexParameteri(target, GL_TEXTURE_COMPARE_MODE,
                                samp->CompareMode);
            _mesa_TexParameteri(target, GL_TEXTURE_COMPARE_FUNC,
                                samp->CompareFunc);
         }
         if (ctx->Extensions.ARB_depth_texture)
            _mesa_TexParameteri(target, GL_DEPTH_TEXTURE_MODE, obj->DepthMode);
      }

      /* remove saved references to the texture objects */
      for (tgt = 0; tgt < NUM_TEXTURE_TARGETS; tgt++) {
         _mesa_reference_texobj(&texstate->SavedTexRef[u][tgt], NULL);
      }
   }

   _mesa_ActiveTexture(GL_TEXTURE0_ARB + texstate->Texture.CurrentUnit);

   _mesa_reference_shared_state(ctx, &texstate->SharedRef, NULL);

   _mesa_unlock_context_textures(ctx);
}


/*
 * This function is kind of long just because we have to call a lot
 * of device driver functions to update device driver state.
 *
 * XXX As it is now, most of the pop-code calls immediate-mode Mesa functions
 * in order to restore GL state.  This isn't terribly efficient but it
 * ensures that dirty flags and any derived state gets updated correctly.
 * We could at least check if the value to restore equals the current value
 * and then skip the Mesa call.
 */
void GLAPIENTRY
_mesa_PopAttrib(void)
{
   struct gl_attrib_node *attr, *next;
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);

   if (ctx->AttribStackDepth == 0) {
      _mesa_error( ctx, GL_STACK_UNDERFLOW, "glPopAttrib" );
      return;
   }

   ctx->AttribStackDepth--;
   attr = ctx->AttribStack[ctx->AttribStackDepth];

   while (attr) {

      if (MESA_VERBOSE & VERBOSE_API) {
         _mesa_debug(ctx, "glPopAttrib %s\n",
                     _mesa_lookup_enum_by_nr(attr->kind));
      }

      switch (attr->kind) {
         case GL_ACCUM_BUFFER_BIT:
            {
               const struct gl_accum_attrib *accum;
               accum = (const struct gl_accum_attrib *) attr->data;
               _mesa_ClearAccum(accum->ClearColor[0],
                                accum->ClearColor[1],
                                accum->ClearColor[2],
                                accum->ClearColor[3]);
            }
            break;
         case GL_COLOR_BUFFER_BIT:
            {
               const struct gl_colorbuffer_attrib *color;

               color = (const struct gl_colorbuffer_attrib *) attr->data;
               _mesa_ClearIndex((GLfloat) color->ClearIndex);
               _mesa_ClearColor(color->ClearColor.f[0],
                                color->ClearColor.f[1],
                                color->ClearColor.f[2],
                                color->ClearColor.f[3]);
               _mesa_IndexMask(color->IndexMask);
               if (!ctx->Extensions.EXT_draw_buffers2) {
                  _mesa_ColorMask((GLboolean) (color->ColorMask[0][0] != 0),
                                  (GLboolean) (color->ColorMask[0][1] != 0),
                                  (GLboolean) (color->ColorMask[0][2] != 0),
                                  (GLboolean) (color->ColorMask[0][3] != 0));
               }
               else {
                  GLuint i;
                  for (i = 0; i < ctx->Const.MaxDrawBuffers; i++) {
                     _mesa_ColorMaski(i, 
                                  (GLboolean) (color->ColorMask[i][0] != 0),
                                  (GLboolean) (color->ColorMask[i][1] != 0),
                                  (GLboolean) (color->ColorMask[i][2] != 0),
                                  (GLboolean) (color->ColorMask[i][3] != 0));
                  }
               }
               {
                  /* Need to determine if more than one color output is
                   * specified.  If so, call glDrawBuffersARB, else call
                   * glDrawBuffer().  This is a subtle, but essential point
                   * since GL_FRONT (for example) is illegal for the former
                   * function, but legal for the later.
                   */
                  GLboolean multipleBuffers = GL_FALSE;
		  GLuint i;

		  for (i = 1; i < ctx->Const.MaxDrawBuffers; i++) {
		     if (color->DrawBuffer[i] != GL_NONE) {
			multipleBuffers = GL_TRUE;
			break;
		     }
                  }
                  /* Call the API_level functions, not _mesa_drawbuffers()
                   * since we need to do error checking on the pop'd
                   * GL_DRAW_BUFFER.
                   * Ex: if GL_FRONT were pushed, but we're popping with a
                   * user FBO bound, GL_FRONT will be illegal and we'll need
                   * to record that error.  Per OpenGL ARB decision.
                   */
                  if (multipleBuffers)
                     _mesa_DrawBuffers(ctx->Const.MaxDrawBuffers,
                                          color->DrawBuffer);
                  else
                     _mesa_DrawBuffer(color->DrawBuffer[0]);
               }
               _mesa_set_enable(ctx, GL_ALPHA_TEST, color->AlphaEnabled);
               _mesa_AlphaFunc(color->AlphaFunc, color->AlphaRefUnclamped);
               if (ctx->Color.BlendEnabled != color->BlendEnabled) {
                  if (ctx->Extensions.EXT_draw_buffers2) {
                     GLuint i;
                     for (i = 0; i < ctx->Const.MaxDrawBuffers; i++) {
                        _mesa_set_enablei(ctx, GL_BLEND, i,
                                          (color->BlendEnabled >> i) & 1);
                     }
                  }
                  else {
                     _mesa_set_enable(ctx, GL_BLEND, (color->BlendEnabled & 1));
                  }
               }
               if (ctx->Color._BlendFuncPerBuffer ||
                   ctx->Color._BlendEquationPerBuffer) {
                  /* set blend per buffer */
                  GLuint buf;
                  for (buf = 0; buf < ctx->Const.MaxDrawBuffers; buf++) {
                     _mesa_BlendFuncSeparateiARB(buf, color->Blend[buf].SrcRGB,
                                              color->Blend[buf].DstRGB,
                                              color->Blend[buf].SrcA,
                                              color->Blend[buf].DstA);
                     _mesa_BlendEquationSeparateiARB(buf,
                                                  color->Blend[buf].EquationRGB,
                                                  color->Blend[buf].EquationA);
                  }
               }
               else {
                  /* set same blend modes for all buffers */
                  _mesa_BlendFuncSeparate(color->Blend[0].SrcRGB,
                                             color->Blend[0].DstRGB,
                                             color->Blend[0].SrcA,
                                             color->Blend[0].DstA);
                  /* This special case is because glBlendEquationSeparateEXT
                   * cannot take GL_LOGIC_OP as a parameter.
                   */
                  if (color->Blend[0].EquationRGB ==
                      color->Blend[0].EquationA) {
                     _mesa_BlendEquation(color->Blend[0].EquationRGB);
                  }
                  else {
                     _mesa_BlendEquationSeparate(
                                                 color->Blend[0].EquationRGB,
                                                 color->Blend[0].EquationA);
                  }
               }
               _mesa_BlendColor(color->BlendColorUnclamped[0],
                                color->BlendColorUnclamped[1],
                                color->BlendColorUnclamped[2],
                                color->BlendColorUnclamped[3]);
               _mesa_LogicOp(color->LogicOp);
               _mesa_set_enable(ctx, GL_COLOR_LOGIC_OP,
                                color->ColorLogicOpEnabled);
               _mesa_set_enable(ctx, GL_INDEX_LOGIC_OP,
                                color->IndexLogicOpEnabled);
               _mesa_set_enable(ctx, GL_DITHER, color->DitherFlag);
               if (ctx->Extensions.ARB_color_buffer_float)
                  _mesa_ClampColor(GL_CLAMP_FRAGMENT_COLOR_ARB,
                                   color->ClampFragmentColor);
               _mesa_ClampColor(GL_CLAMP_READ_COLOR_ARB, color->ClampReadColor);

               /* GL_ARB_framebuffer_sRGB / GL_EXT_framebuffer_sRGB */
               if (ctx->Extensions.EXT_framebuffer_sRGB)
                  _mesa_set_enable(ctx, GL_FRAMEBUFFER_SRGB, color->sRGBEnabled);
            }
            break;
         case GL_CURRENT_BIT:
	    FLUSH_CURRENT( ctx, 0 );
            memcpy( &ctx->Current, attr->data,
		    sizeof(struct gl_current_attrib) );
            break;
         case GL_DEPTH_BUFFER_BIT:
            {
               const struct gl_depthbuffer_attrib *depth;
               depth = (const struct gl_depthbuffer_attrib *) attr->data;
               _mesa_DepthFunc(depth->Func);
               _mesa_ClearDepth(depth->Clear);
               _mesa_set_enable(ctx, GL_DEPTH_TEST, depth->Test);
               _mesa_DepthMask(depth->Mask);
            }
            break;
         case GL_ENABLE_BIT:
            {
               const struct gl_enable_attrib *enable;
               enable = (const struct gl_enable_attrib *) attr->data;
               pop_enable_group(ctx, enable);
	       ctx->NewState |= _NEW_ALL;
            }
            break;
         case GL_EVAL_BIT:
            memcpy( &ctx->Eval, attr->data, sizeof(struct gl_eval_attrib) );
	    ctx->NewState |= _NEW_EVAL;
            break;
         case GL_FOG_BIT:
            {
               const struct gl_fog_attrib *fog;
               fog = (const struct gl_fog_attrib *) attr->data;
               _mesa_set_enable(ctx, GL_FOG, fog->Enabled);
               _mesa_Fogfv(GL_FOG_COLOR, fog->Color);
               _mesa_Fogf(GL_FOG_DENSITY, fog->Density);
               _mesa_Fogf(GL_FOG_START, fog->Start);
               _mesa_Fogf(GL_FOG_END, fog->End);
               _mesa_Fogf(GL_FOG_INDEX, fog->Index);
               _mesa_Fogi(GL_FOG_MODE, fog->Mode);
            }
            break;
         case GL_HINT_BIT:
            {
               const struct gl_hint_attrib *hint;
               hint = (const struct gl_hint_attrib *) attr->data;
               _mesa_Hint(GL_PERSPECTIVE_CORRECTION_HINT,
                          hint->PerspectiveCorrection );
               _mesa_Hint(GL_POINT_SMOOTH_HINT, hint->PointSmooth);
               _mesa_Hint(GL_LINE_SMOOTH_HINT, hint->LineSmooth);
               _mesa_Hint(GL_POLYGON_SMOOTH_HINT, hint->PolygonSmooth);
               _mesa_Hint(GL_FOG_HINT, hint->Fog);
	       _mesa_Hint(GL_TEXTURE_COMPRESSION_HINT_ARB,
			  hint->TextureCompression);
            }
            break;
         case GL_LIGHTING_BIT:
            {
               GLuint i;
               const struct gl_light_attrib *light;
               light = (const struct gl_light_attrib *) attr->data;
               /* lighting enable */
               _mesa_set_enable(ctx, GL_LIGHTING, light->Enabled);
               /* per-light state */
               if (_math_matrix_is_dirty(ctx->ModelviewMatrixStack.Top))
                  _math_matrix_analyse( ctx->ModelviewMatrixStack.Top );
	       
               for (i = 0; i < ctx->Const.MaxLights; i++) {
                  const struct gl_light *l = &light->Light[i];
                  _mesa_set_enable(ctx, GL_LIGHT0 + i, l->Enabled);
                  _mesa_light(ctx, i, GL_AMBIENT, l->Ambient);
                  _mesa_light(ctx, i, GL_DIFFUSE, l->Diffuse);
                  _mesa_light(ctx, i, GL_SPECULAR, l->Specular );
                  _mesa_light(ctx, i, GL_POSITION, l->EyePosition);
                  _mesa_light(ctx, i, GL_SPOT_DIRECTION, l->SpotDirection);
                  {
                     GLfloat p[4] = { 0 };
                     p[0] = l->SpotExponent;
                     _mesa_light(ctx, i, GL_SPOT_EXPONENT, p);
                  }
                  {
                     GLfloat p[4] = { 0 };
                     p[0] = l->SpotCutoff;
                     _mesa_light(ctx, i, GL_SPOT_CUTOFF, p);
                  }
                  {
                     GLfloat p[4] = { 0 };
                     p[0] = l->ConstantAttenuation;
                     _mesa_light(ctx, i, GL_CONSTANT_ATTENUATION, p);
                  }
                  {
                     GLfloat p[4] = { 0 };
                     p[0] = l->LinearAttenuation;
                     _mesa_light(ctx, i, GL_LINEAR_ATTENUATION, p);
                  }
                  {
                     GLfloat p[4] = { 0 };
                     p[0] = l->QuadraticAttenuation;
                     _mesa_light(ctx, i, GL_QUADRATIC_ATTENUATION, p);
                  }
               }
               /* light model */
               _mesa_LightModelfv(GL_LIGHT_MODEL_AMBIENT,
                                  light->Model.Ambient);
               _mesa_LightModelf(GL_LIGHT_MODEL_LOCAL_VIEWER,
                                 (GLfloat) light->Model.LocalViewer);
               _mesa_LightModelf(GL_LIGHT_MODEL_TWO_SIDE,
                                 (GLfloat) light->Model.TwoSide);
               _mesa_LightModelf(GL_LIGHT_MODEL_COLOR_CONTROL,
                                 (GLfloat) light->Model.ColorControl);
               /* shade model */
               _mesa_ShadeModel(light->ShadeModel);
               /* color material */
               _mesa_ColorMaterial(light->ColorMaterialFace,
                                   light->ColorMaterialMode);
               _mesa_set_enable(ctx, GL_COLOR_MATERIAL,
                                light->ColorMaterialEnabled);
               /* materials */
               memcpy(&ctx->Light.Material, &light->Material,
                      sizeof(struct gl_material));
               if (ctx->Extensions.ARB_color_buffer_float) {
                  _mesa_ClampColor(GL_CLAMP_VERTEX_COLOR_ARB,
                                   light->ClampVertexColor);
               }
            }
            break;
         case GL_LINE_BIT:
            {
               const struct gl_line_attrib *line;
               line = (const struct gl_line_attrib *) attr->data;
               _mesa_set_enable(ctx, GL_LINE_SMOOTH, line->SmoothFlag);
               _mesa_set_enable(ctx, GL_LINE_STIPPLE, line->StippleFlag);
               _mesa_LineStipple(line->StippleFactor, line->StipplePattern);
               _mesa_LineWidth(line->Width);
            }
            break;
         case GL_LIST_BIT:
            memcpy( &ctx->List, attr->data, sizeof(struct gl_list_attrib) );
            break;
         case GL_PIXEL_MODE_BIT:
            memcpy( &ctx->Pixel, attr->data, sizeof(struct gl_pixel_attrib) );
            /* XXX what other pixel state needs to be set by function calls? */
            _mesa_ReadBuffer(ctx->Pixel.ReadBuffer);
	    ctx->NewState |= _NEW_PIXEL;
            break;
         case GL_POINT_BIT:
            {
               const struct gl_point_attrib *point;
               point = (const struct gl_point_attrib *) attr->data;
               _mesa_PointSize(point->Size);
               _mesa_set_enable(ctx, GL_POINT_SMOOTH, point->SmoothFlag);
               if (ctx->Extensions.EXT_point_parameters) {
                  _mesa_PointParameterfv(GL_DISTANCE_ATTENUATION_EXT,
                                         point->Params);
                  _mesa_PointParameterf(GL_POINT_SIZE_MIN_EXT,
                                        point->MinSize);
                  _mesa_PointParameterf(GL_POINT_SIZE_MAX_EXT,
                                        point->MaxSize);
                  _mesa_PointParameterf(GL_POINT_FADE_THRESHOLD_SIZE_EXT,
                                        point->Threshold);
               }
               if (ctx->Extensions.NV_point_sprite
		   || ctx->Extensions.ARB_point_sprite) {
                  GLuint u;
                  for (u = 0; u < ctx->Const.MaxTextureUnits; u++) {
                     _mesa_TexEnvi(GL_POINT_SPRITE_NV, GL_COORD_REPLACE_NV,
                                   (GLint) point->CoordReplace[u]);
                  }
                  _mesa_set_enable(ctx, GL_POINT_SPRITE_NV,point->PointSprite);
                  if (ctx->Extensions.NV_point_sprite)
                     _mesa_PointParameteri(GL_POINT_SPRITE_R_MODE_NV,
                                           ctx->Point.SpriteRMode);

                  if ((ctx->API == API_OPENGL_COMPAT && ctx->Version >= 20)
                      || ctx->API == API_OPENGL_CORE)
                     _mesa_PointParameterf(GL_POINT_SPRITE_COORD_ORIGIN,
                                           (GLfloat)ctx->Point.SpriteOrigin);
               }
            }
            break;
         case GL_POLYGON_BIT:
            {
               const struct gl_polygon_attrib *polygon;
               polygon = (const struct gl_polygon_attrib *) attr->data;
               _mesa_CullFace(polygon->CullFaceMode);
               _mesa_FrontFace(polygon->FrontFace);
               _mesa_PolygonMode(GL_FRONT, polygon->FrontMode);
               _mesa_PolygonMode(GL_BACK, polygon->BackMode);
               _mesa_PolygonOffset(polygon->OffsetFactor,
                                   polygon->OffsetUnits);
               _mesa_set_enable(ctx, GL_POLYGON_SMOOTH, polygon->SmoothFlag);
               _mesa_set_enable(ctx, GL_POLYGON_STIPPLE, polygon->StippleFlag);
               _mesa_set_enable(ctx, GL_CULL_FACE, polygon->CullFlag);
               _mesa_set_enable(ctx, GL_POLYGON_OFFSET_POINT,
                                polygon->OffsetPoint);
               _mesa_set_enable(ctx, GL_POLYGON_OFFSET_LINE,
                                polygon->OffsetLine);
               _mesa_set_enable(ctx, GL_POLYGON_OFFSET_FILL,
                                polygon->OffsetFill);
            }
            break;
	 case GL_POLYGON_STIPPLE_BIT:
	    memcpy( ctx->PolygonStipple, attr->data, 32*sizeof(GLuint) );
	    ctx->NewState |= _NEW_POLYGONSTIPPLE;
	    if (ctx->Driver.PolygonStipple)
	       ctx->Driver.PolygonStipple( ctx, (const GLubyte *) attr->data );
	    break;
         case GL_SCISSOR_BIT:
            {
               unsigned i;
               const struct gl_scissor_attrib *scissor;
               scissor = (const struct gl_scissor_attrib *) attr->data;

               for (i = 0; i < ctx->Const.MaxViewports; i++) {
                  _mesa_set_scissor(ctx, i,
                                    scissor->ScissorArray[i].X,
                                    scissor->ScissorArray[i].Y,
                                    scissor->ScissorArray[i].Width,
                                    scissor->ScissorArray[i].Height);
                  _mesa_set_enablei(ctx, GL_SCISSOR_TEST, i,
                                    (scissor->EnableFlags >> i) & 1);
               }
            }
            break;
         case GL_STENCIL_BUFFER_BIT:
            {
               const struct gl_stencil_attrib *stencil;
               stencil = (const struct gl_stencil_attrib *) attr->data;
               _mesa_set_enable(ctx, GL_STENCIL_TEST, stencil->Enabled);
               _mesa_ClearStencil(stencil->Clear);
               if (ctx->Extensions.EXT_stencil_two_side) {
                  _mesa_set_enable(ctx, GL_STENCIL_TEST_TWO_SIDE_EXT,
                                   stencil->TestTwoSide);
                  _mesa_ActiveStencilFaceEXT(stencil->ActiveFace
                                             ? GL_BACK : GL_FRONT);
               }
               /* front state */
               _mesa_StencilFuncSeparate(GL_FRONT,
                                         stencil->Function[0],
                                         stencil->Ref[0],
                                         stencil->ValueMask[0]);
               _mesa_StencilMaskSeparate(GL_FRONT, stencil->WriteMask[0]);
               _mesa_StencilOpSeparate(GL_FRONT, stencil->FailFunc[0],
                                       stencil->ZFailFunc[0],
                                       stencil->ZPassFunc[0]);
               /* back state */
               _mesa_StencilFuncSeparate(GL_BACK,
                                         stencil->Function[1],
                                         stencil->Ref[1],
                                         stencil->ValueMask[1]);
               _mesa_StencilMaskSeparate(GL_BACK, stencil->WriteMask[1]);
               _mesa_StencilOpSeparate(GL_BACK, stencil->FailFunc[1],
                                       stencil->ZFailFunc[1],
                                       stencil->ZPassFunc[1]);
            }
            break;
         case GL_TRANSFORM_BIT:
            {
               GLuint i;
               const struct gl_transform_attrib *xform;
               xform = (const struct gl_transform_attrib *) attr->data;
               _mesa_MatrixMode(xform->MatrixMode);
               if (_math_matrix_is_dirty(ctx->ProjectionMatrixStack.Top))
                  _math_matrix_analyse( ctx->ProjectionMatrixStack.Top );

               /* restore clip planes */
               for (i = 0; i < ctx->Const.MaxClipPlanes; i++) {
                  const GLuint mask = 1 << i;
                  const GLfloat *eyePlane = xform->EyeUserPlane[i];
                  COPY_4V(ctx->Transform.EyeUserPlane[i], eyePlane);
                  _mesa_set_enable(ctx, GL_CLIP_PLANE0 + i,
                                   !!(xform->ClipPlanesEnabled & mask));
                  if (ctx->Driver.ClipPlane)
                     ctx->Driver.ClipPlane( ctx, GL_CLIP_PLANE0 + i, eyePlane );
               }

               /* normalize/rescale */
               if (xform->Normalize != ctx->Transform.Normalize)
                  _mesa_set_enable(ctx, GL_NORMALIZE,ctx->Transform.Normalize);
               if (xform->RescaleNormals != ctx->Transform.RescaleNormals)
                  _mesa_set_enable(ctx, GL_RESCALE_NORMAL_EXT,
                                   ctx->Transform.RescaleNormals);
               if (xform->DepthClamp != ctx->Transform.DepthClamp)
                  _mesa_set_enable(ctx, GL_DEPTH_CLAMP,
                                   ctx->Transform.DepthClamp);
            }
            break;
         case GL_TEXTURE_BIT:
            {
               struct texture_state *texstate
                  = (struct texture_state *) attr->data;
               pop_texture_group(ctx, texstate);
	       ctx->NewState |= _NEW_TEXTURE;
            }
            break;
         case GL_VIEWPORT_BIT:
            {
               unsigned i;
               const struct gl_viewport_attrib *vp;
               vp = (const struct gl_viewport_attrib *) attr->data;

               for (i = 0; i < ctx->Const.MaxViewports; i++) {
                  _mesa_set_viewport(ctx, i, vp[i].X, vp[i].Y, vp[i].Width,
                                     vp[i].Height);
                  _mesa_set_depth_range(ctx, i, vp[i].Near, vp[i].Far);
               }
            }
            break;
         case GL_MULTISAMPLE_BIT_ARB:
            {
               const struct gl_multisample_attrib *ms;
               ms = (const struct gl_multisample_attrib *) attr->data;

	       TEST_AND_UPDATE(ctx->Multisample.Enabled,
			       ms->Enabled,
			       GL_MULTISAMPLE);

	       TEST_AND_UPDATE(ctx->Multisample.SampleCoverage,
			       ms->SampleCoverage,
			       GL_SAMPLE_COVERAGE);

	       TEST_AND_UPDATE(ctx->Multisample.SampleAlphaToCoverage,
			       ms->SampleAlphaToCoverage,
			       GL_SAMPLE_ALPHA_TO_COVERAGE);

	       TEST_AND_UPDATE(ctx->Multisample.SampleAlphaToOne,
			       ms->SampleAlphaToOne,
			       GL_SAMPLE_ALPHA_TO_ONE);

               _mesa_SampleCoverage(ms->SampleCoverageValue,
                                       ms->SampleCoverageInvert);
            }
            break;

         default:
            _mesa_problem( ctx, "Bad attrib flag in PopAttrib");
            break;
      }

      next = attr->next;
      free(attr->data);
      free(attr);
      attr = next;
   }
}


/**
 * Copy gl_pixelstore_attrib from src to dst, updating buffer
 * object refcounts.
 */
static void
copy_pixelstore(struct gl_context *ctx,
                struct gl_pixelstore_attrib *dst,
                const struct gl_pixelstore_attrib *src)
{
   dst->Alignment = src->Alignment;
   dst->RowLength = src->RowLength;
   dst->SkipPixels = src->SkipPixels;
   dst->SkipRows = src->SkipRows;
   dst->ImageHeight = src->ImageHeight;
   dst->SkipImages = src->SkipImages;
   dst->SwapBytes = src->SwapBytes;
   dst->LsbFirst = src->LsbFirst;
   dst->Invert = src->Invert;
   _mesa_reference_buffer_object(ctx, &dst->BufferObj, src->BufferObj);
}


#define GL_CLIENT_PACK_BIT (1<<20)
#define GL_CLIENT_UNPACK_BIT (1<<21)

/**
 * Copy gl_vertex_array_object from src to dest.
 * 'dest' must be in an initialized state.
 */
static void
copy_array_object(struct gl_context *ctx,
                  struct gl_vertex_array_object *dest,
                  struct gl_vertex_array_object *src)
{
   GLuint i;

   /* skip Name */
   /* skip RefCount */

   /* In theory must be the same anyway, but on recreate make sure it matches */
   dest->ARBsemantics = src->ARBsemantics;

   for (i = 0; i < Elements(src->_VertexAttrib); i++) {
      _mesa_copy_client_array(ctx, &dest->_VertexAttrib[i], &src->_VertexAttrib[i]);
      _mesa_copy_vertex_attrib_array(ctx, &dest->VertexAttrib[i], &src->VertexAttrib[i]);
      _mesa_copy_vertex_buffer_binding(ctx, &dest->VertexBinding[i], &src->VertexBinding[i]);
   }

   /* _Enabled must be the same than on push */
   dest->_Enabled = src->_Enabled;
   dest->NewArrays = src->NewArrays;
   dest->_MaxElement = src->_MaxElement;
}

/**
 * Copy gl_array_attrib from src to dest.
 * 'dest' must be in an initialized state.
 */
static void
copy_array_attrib(struct gl_context *ctx,
                  struct gl_array_attrib *dest,
                  struct gl_array_attrib *src,
                  bool vbo_deleted)
{
   /* skip ArrayObj */
   /* skip DefaultArrayObj, Objects */
   dest->ActiveTexture = src->ActiveTexture;
   dest->LockFirst = src->LockFirst;
   dest->LockCount = src->LockCount;
   dest->PrimitiveRestart = src->PrimitiveRestart;
   dest->PrimitiveRestartFixedIndex = src->PrimitiveRestartFixedIndex;
   dest->_PrimitiveRestart = src->_PrimitiveRestart;
   dest->RestartIndex = src->RestartIndex;
   /* skip NewState */
   /* skip RebindArrays */

   if (!vbo_deleted)
      copy_array_object(ctx, dest->VAO, src->VAO);

   /* skip ArrayBufferObj */
   /* skip IndexBufferObj */
}

/**
 * Save the content of src to dest.
 */
static void
save_array_attrib(struct gl_context *ctx,
                  struct gl_array_attrib *dest,
                  struct gl_array_attrib *src)
{
   /* Set the Name, needed for restore, but do never overwrite.
    * Needs to match value in the object hash. */
   dest->VAO->Name = src->VAO->Name;
   /* And copy all of the rest. */
   copy_array_attrib(ctx, dest, src, false);

   /* Just reference them here */
   _mesa_reference_buffer_object(ctx, &dest->ArrayBufferObj,
                                 src->ArrayBufferObj);
   _mesa_reference_buffer_object(ctx, &dest->VAO->IndexBufferObj,
                                 src->VAO->IndexBufferObj);
}

/**
 * Restore the content of src to dest.
 */
static void
restore_array_attrib(struct gl_context *ctx,
                     struct gl_array_attrib *dest,
                     struct gl_array_attrib *src)
{
   /* The ARB_vertex_array_object spec says:
    *
    *     "BindVertexArray fails and an INVALID_OPERATION error is generated
    *     if array is not a name returned from a previous call to
    *     GenVertexArrays, or if such a name has since been deleted with
    *     DeleteVertexArrays."
    *
    * Therefore popping a deleted VAO cannot magically recreate it.
    *
    * The semantics of objects created using APPLE_vertex_array_objects behave
    * differently.  These objects expect to be recreated by pop.  Alas.
    */
   const bool arb_vao = (src->VAO->Name != 0
			 && src->VAO->ARBsemantics);

   if (arb_vao && !_mesa_IsVertexArray(src->VAO->Name))
      return;

   _mesa_BindVertexArrayAPPLE(src->VAO->Name);

   /* Restore or recreate the buffer objects by the names ... */
   if (!arb_vao
       || src->ArrayBufferObj->Name == 0
       || _mesa_IsBuffer(src->ArrayBufferObj->Name)) {
      /* ... and restore its content */
      copy_array_attrib(ctx, dest, src, false);

      _mesa_BindBuffer(GL_ARRAY_BUFFER_ARB,
			  src->ArrayBufferObj->Name);
   } else {
      copy_array_attrib(ctx, dest, src, true);
   }

   if (!arb_vao
       || src->VAO->IndexBufferObj->Name == 0
       || _mesa_IsBuffer(src->VAO->IndexBufferObj->Name))
      _mesa_BindBuffer(GL_ELEMENT_ARRAY_BUFFER_ARB,
			  src->VAO->IndexBufferObj->Name);
}

/**
 * init/alloc the fields of 'attrib'.
 * Needs to the init part matching free_array_attrib_data below.
 */
static bool
init_array_attrib_data(struct gl_context *ctx,
                       struct gl_array_attrib *attrib)
{
   /* Get a non driver gl_vertex_array_object. */
   attrib->VAO = CALLOC_STRUCT( gl_vertex_array_object );

   if (attrib->VAO == NULL) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glPushClientAttrib");
      return false;
   }

   _mesa_initialize_vao(ctx, attrib->VAO, 0);
   return true;
}

/**
 * Free/unreference the fields of 'attrib' but don't delete it (that's
 * done later in the calling code).
 * Needs to the cleanup part matching init_array_attrib_data above.
 */
static void
free_array_attrib_data(struct gl_context *ctx,
                       struct gl_array_attrib *attrib)
{
   /* We use a non driver array object, so don't just unref since we would
    * end up using the drivers DeleteArrayObject function for deletion. */
   _mesa_delete_vao(ctx, attrib->VAO);
   attrib->VAO = 0;
   _mesa_reference_buffer_object(ctx, &attrib->ArrayBufferObj, NULL);
}


void GLAPIENTRY
_mesa_PushClientAttrib(GLbitfield mask)
{
   struct gl_attrib_node *head;

   GET_CURRENT_CONTEXT(ctx);

   if (ctx->ClientAttribStackDepth >= MAX_CLIENT_ATTRIB_STACK_DEPTH) {
      _mesa_error( ctx, GL_STACK_OVERFLOW, "glPushClientAttrib" );
      return;
   }

   /* Build linked list of attribute nodes which save all attribute
    * groups specified by the mask.
    */
   head = NULL;

   if (mask & GL_CLIENT_PIXEL_STORE_BIT) {
      struct gl_pixelstore_attrib *attr;
      /* packing attribs */
      attr = CALLOC_STRUCT( gl_pixelstore_attrib );
      if (attr == NULL) {
         _mesa_error( ctx, GL_OUT_OF_MEMORY, "glPushClientAttrib" );
         goto end;
      }
      if (save_attrib_data(&head, GL_CLIENT_PACK_BIT, attr)) {
         copy_pixelstore(ctx, attr, &ctx->Pack);
      }
      else {
         _mesa_error( ctx, GL_OUT_OF_MEMORY, "glPushClientAttrib" );
         free(attr);
         goto end;
      }

      /* unpacking attribs */
      attr = CALLOC_STRUCT( gl_pixelstore_attrib );
      if (attr == NULL) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glPushClientAttrib");
         goto end;
      }

      if (save_attrib_data(&head, GL_CLIENT_UNPACK_BIT, attr)) {
         copy_pixelstore(ctx, attr, &ctx->Unpack);
      }
      else {
         _mesa_error( ctx, GL_OUT_OF_MEMORY, "glPushClientAttrib" );
         free(attr);
         goto end;
       }
   }

   if (mask & GL_CLIENT_VERTEX_ARRAY_BIT) {
      struct gl_array_attrib *attr;
      attr = CALLOC_STRUCT( gl_array_attrib );
      if (attr == NULL) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glPushClientAttrib");
         goto end;
      }

      if (!init_array_attrib_data(ctx, attr)) {
         free(attr);
         goto end;
      }

      if (save_attrib_data(&head, GL_CLIENT_VERTEX_ARRAY_BIT, attr)) {
         save_array_attrib(ctx, attr, &ctx->Array);
      }
      else {
         free_array_attrib_data(ctx, attr);
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glPushClientAttrib");
         free(attr);
         /* goto to keep safe from possible later changes */
         goto end;
      }
   }
end:
   if (head != NULL) {
       ctx->ClientAttribStack[ctx->ClientAttribStackDepth] = head;
       ctx->ClientAttribStackDepth++;
   }
}




void GLAPIENTRY
_mesa_PopClientAttrib(void)
{
   struct gl_attrib_node *node, *next;

   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);

   if (ctx->ClientAttribStackDepth == 0) {
      _mesa_error( ctx, GL_STACK_UNDERFLOW, "glPopClientAttrib" );
      return;
   }

   ctx->ClientAttribStackDepth--;
   node = ctx->ClientAttribStack[ctx->ClientAttribStackDepth];

   while (node) {
      switch (node->kind) {
         case GL_CLIENT_PACK_BIT:
            {
               struct gl_pixelstore_attrib *store =
                  (struct gl_pixelstore_attrib *) node->data;
               copy_pixelstore(ctx, &ctx->Pack, store);
               _mesa_reference_buffer_object(ctx, &store->BufferObj, NULL);
            }
            break;
         case GL_CLIENT_UNPACK_BIT:
            {
               struct gl_pixelstore_attrib *store =
                  (struct gl_pixelstore_attrib *) node->data;
               copy_pixelstore(ctx, &ctx->Unpack, store);
               _mesa_reference_buffer_object(ctx, &store->BufferObj, NULL);
            }
            break;
         case GL_CLIENT_VERTEX_ARRAY_BIT: {
	    struct gl_array_attrib * attr =
	      (struct gl_array_attrib *) node->data;
            restore_array_attrib(ctx, &ctx->Array, attr);
            free_array_attrib_data(ctx, attr);
	    ctx->NewState |= _NEW_ARRAY;
            break;
	 }
         default:
            _mesa_problem( ctx, "Bad attrib flag in PopClientAttrib");
            break;
      }

      next = node->next;
      free(node->data);
      free(node);
      node = next;
   }
}


/**
 * Free any attribute state data that might be attached to the context.
 */
void
_mesa_free_attrib_data(struct gl_context *ctx)
{
   while (ctx->AttribStackDepth > 0) {
      struct gl_attrib_node *attr, *next;

      ctx->AttribStackDepth--;
      attr = ctx->AttribStack[ctx->AttribStackDepth];

      while (attr) {
         if (attr->kind == GL_TEXTURE_BIT) {
            struct texture_state *texstate = (struct texture_state*)attr->data;
            GLuint u, tgt;
            /* clear references to the saved texture objects */
            for (u = 0; u < ctx->Const.MaxTextureUnits; u++) {
               for (tgt = 0; tgt < NUM_TEXTURE_TARGETS; tgt++) {
                  _mesa_reference_texobj(&texstate->SavedTexRef[u][tgt], NULL);
               }
            }
            _mesa_reference_shared_state(ctx, &texstate->SharedRef, NULL);
         }
         else {
            /* any other chunks of state that requires special handling? */
         }

         next = attr->next;
         free(attr->data);
         free(attr);
         attr = next;
      }
   }
}


void _mesa_init_attrib( struct gl_context *ctx )
{
   /* Renderer and client attribute stacks */
   ctx->AttribStackDepth = 0;
   ctx->ClientAttribStackDepth = 0;
}
@


1.11
log
@Merge Mesa 10.2.9
@
text
@@


1.10
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a1347 2
               if (ctx->Extensions.ARB_clip_control)
                  _mesa_ClipControl(xform->ClipOrigin, xform->ClipDepthMode);
d1452 1
a1452 1
   for (i = 0; i < Elements(src->VertexAttrib); i++) {
d1461 1
a1490 4

   /* Invalidate draw state. It will be updated during the next draw. */
   dest->DrawMethod = DRAW_NONE;
   dest->_DrawArrays = NULL;
@


1.9
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d1348 2
d1454 1
a1454 1
   for (i = 0; i < Elements(src->_VertexAttrib); i++) {
a1462 1
   dest->_MaxElement = src->_MaxElement;
d1492 4
@


1.8
log
@Merge Mesa 9.2.0
@
text
@d115 1
a115 1
   GLboolean Scissor;
d185 1
a185 1
static void
d199 34
d234 1
d258 4
a261 4
      struct gl_accum_attrib *attr;
      attr = MALLOC_STRUCT( gl_accum_attrib );
      memcpy( attr, &ctx->Accum, sizeof(struct gl_accum_attrib) );
      save_attrib_data(&head, GL_ACCUM_BUFFER_BIT, attr);
d268 16
a283 5
      memcpy( attr, &ctx->Color, sizeof(struct gl_colorbuffer_attrib) );
      /* push the Draw FBO's DrawBuffer[] state, not ctx->Color.DrawBuffer[] */
      for (i = 0; i < ctx->Const.MaxDrawBuffers; i ++)
         attr->DrawBuffer[i] = ctx->DrawBuffer->ColorDrawBuffer[i];
      save_attrib_data(&head, GL_COLOR_BUFFER_BIT, attr);
d287 5
a291 5
      struct gl_current_attrib *attr;
      FLUSH_CURRENT( ctx, 0 );
      attr = MALLOC_STRUCT( gl_current_attrib );
      memcpy( attr, &ctx->Current, sizeof(struct gl_current_attrib) );
      save_attrib_data(&head, GL_CURRENT_BIT, attr);
d295 4
a298 4
      struct gl_depthbuffer_attrib *attr;
      attr = MALLOC_STRUCT( gl_depthbuffer_attrib );
      memcpy( attr, &ctx->Depth, sizeof(struct gl_depthbuffer_attrib) );
      save_attrib_data(&head, GL_DEPTH_BUFFER_BIT, attr);
d305 5
d357 1
a357 1
      attr->Scissor = ctx->Scissor.Enabled;
d376 5
a380 1
      save_attrib_data(&head, GL_ENABLE_BIT, attr);
d387 4
a390 4
      struct gl_eval_attrib *attr;
      attr = MALLOC_STRUCT( gl_eval_attrib );
      memcpy( attr, &ctx->Eval, sizeof(struct gl_eval_attrib) );
      save_attrib_data(&head, GL_EVAL_BIT, attr);
d394 4
a397 4
      struct gl_fog_attrib *attr;
      attr = MALLOC_STRUCT( gl_fog_attrib );
      memcpy( attr, &ctx->Fog, sizeof(struct gl_fog_attrib) );
      save_attrib_data(&head, GL_FOG_BIT, attr);
d401 4
a404 4
      struct gl_hint_attrib *attr;
      attr = MALLOC_STRUCT( gl_hint_attrib );
      memcpy( attr, &ctx->Hint, sizeof(struct gl_hint_attrib) );
      save_attrib_data(&head, GL_HINT_BIT, attr);
d408 5
a412 5
      struct gl_light_attrib *attr;
      FLUSH_CURRENT(ctx, 0);	/* flush material changes */
      attr = MALLOC_STRUCT( gl_light_attrib );
      memcpy( attr, &ctx->Light, sizeof(struct gl_light_attrib) );
      save_attrib_data(&head, GL_LIGHTING_BIT, attr);
d416 4
a419 4
      struct gl_line_attrib *attr;
      attr = MALLOC_STRUCT( gl_line_attrib );
      memcpy( attr, &ctx->Line, sizeof(struct gl_line_attrib) );
      save_attrib_data(&head, GL_LINE_BIT, attr);
d423 4
a426 4
      struct gl_list_attrib *attr;
      attr = MALLOC_STRUCT( gl_list_attrib );
      memcpy( attr, &ctx->List, sizeof(struct gl_list_attrib) );
      save_attrib_data(&head, GL_LIST_BIT, attr);
d432 15
a446 4
      memcpy( attr, &ctx->Pixel, sizeof(struct gl_pixel_attrib) );
      /* push the Read FBO's ReadBuffer state, not ctx->Pixel.ReadBuffer */
      attr->ReadBuffer = ctx->ReadBuffer->ColorReadBuffer;
      save_attrib_data(&head, GL_PIXEL_MODE_BIT, attr);
d450 4
a453 4
      struct gl_point_attrib *attr;
      attr = MALLOC_STRUCT( gl_point_attrib );
      memcpy( attr, &ctx->Point, sizeof(struct gl_point_attrib) );
      save_attrib_data(&head, GL_POINT_BIT, attr);
d457 4
a460 4
      struct gl_polygon_attrib *attr;
      attr = MALLOC_STRUCT( gl_polygon_attrib );
      memcpy( attr, &ctx->Polygon, sizeof(struct gl_polygon_attrib) );
      save_attrib_data(&head, GL_POLYGON_BIT, attr);
d464 4
a467 4
      GLuint *stipple;
      stipple = malloc( 32*sizeof(GLuint) );
      memcpy( stipple, ctx->PolygonStipple, 32*sizeof(GLuint) );
      save_attrib_data(&head, GL_POLYGON_STIPPLE_BIT, stipple);
d471 4
a474 4
      struct gl_scissor_attrib *attr;
      attr = MALLOC_STRUCT( gl_scissor_attrib );
      memcpy( attr, &ctx->Scissor, sizeof(struct gl_scissor_attrib) );
      save_attrib_data(&head, GL_SCISSOR_BIT, attr);
d478 4
a481 4
      struct gl_stencil_attrib *attr;
      attr = MALLOC_STRUCT( gl_stencil_attrib );
      memcpy( attr, &ctx->Stencil, sizeof(struct gl_stencil_attrib) );
      save_attrib_data(&head, GL_STENCIL_BUFFER_BIT, attr);
d493 6
a524 2

      save_attrib_data(&head, GL_TEXTURE_BIT, texstate);
d528 4
a531 4
      struct gl_transform_attrib *attr;
      attr = MALLOC_STRUCT( gl_transform_attrib );
      memcpy( attr, &ctx->Transform, sizeof(struct gl_transform_attrib) );
      save_attrib_data(&head, GL_TRANSFORM_BIT, attr);
d535 5
a539 4
      struct gl_viewport_attrib *attr;
      attr = MALLOC_STRUCT( gl_viewport_attrib );
      memcpy( attr, &ctx->Viewport, sizeof(struct gl_viewport_attrib) );
      save_attrib_data(&head, GL_VIEWPORT_BIT, attr);
d544 4
a547 4
      struct gl_multisample_attrib *attr;
      attr = MALLOC_STRUCT( gl_multisample_attrib );
      memcpy( attr, &ctx->Multisample, sizeof(struct gl_multisample_attrib) );
      save_attrib_data(&head, GL_MULTISAMPLE_BIT_ARB, attr);
d551 4
a554 2
   ctx->AttribStack[ctx->AttribStackDepth] = head;
   ctx->AttribStackDepth++;
d662 7
a668 1
   TEST_AND_UPDATE(ctx->Scissor.Enabled, enable->Scissor, GL_SCISSOR_TEST);
a722 6
         if (ctx->Extensions.MESA_texture_array) {
            _mesa_set_enable(ctx, GL_TEXTURE_1D_ARRAY_EXT,
                             !!(enabled & TEXTURE_1D_ARRAY_BIT));
            _mesa_set_enable(ctx, GL_TEXTURE_2D_ARRAY_EXT,
                             !!(enabled & TEXTURE_2D_ARRAY_BIT));
         }
a763 6
      if (ctx->Extensions.MESA_texture_array) {
         _mesa_set_enable(ctx, GL_TEXTURE_1D_ARRAY_EXT,
                          !!(unit->Enabled & TEXTURE_1D_ARRAY_BIT));
         _mesa_set_enable(ctx, GL_TEXTURE_2D_ARRAY_EXT,
                          !!(unit->Enabled & TEXTURE_2D_ARRAY_BIT));
      }
d838 1
a838 1
                  !ctx->Extensions.MESA_texture_array) {
d1272 1
d1275 10
a1284 3
               _mesa_Scissor(scissor->X, scissor->Y,
                             scissor->Width, scissor->Height);
               _mesa_set_enable(ctx, GL_SCISSOR_TEST, scissor->Enabled);
d1360 1
d1363 6
a1368 2
               _mesa_Viewport(vp->X, vp->Y, vp->Width, vp->Height);
               _mesa_DepthRange(vp->Near, vp->Far);
d1436 1
a1436 1
 * Copy gl_array_object from src to dest.
d1441 2
a1442 2
                  struct gl_array_object *dest,
                  struct gl_array_object *src)
d1452 5
a1456 2
   for (i = 0; i < Elements(src->VertexAttrib); i++)
      _mesa_copy_client_array(ctx, &dest->VertexAttrib[i], &src->VertexAttrib[i]);
d1460 1
d1487 1
a1487 1
      copy_array_object(ctx, dest->ArrayObj, src->ArrayObj);
d1490 1
a1490 1
   /* skip ElementArrayBufferObj */
d1503 1
a1503 1
   dest->ArrayObj->Name = src->ArrayObj->Name;
d1510 2
a1511 2
   _mesa_reference_buffer_object(ctx, &dest->ArrayObj->ElementArrayBufferObj,
                                 src->ArrayObj->ElementArrayBufferObj);
d1534 2
a1535 2
   const bool arb_vao = (src->ArrayObj->Name != 0
			 && src->ArrayObj->ARBsemantics);
d1537 1
a1537 1
   if (arb_vao && !_mesa_IsVertexArray(src->ArrayObj->Name))
d1540 1
a1540 1
   _mesa_BindVertexArrayAPPLE(src->ArrayObj->Name);
d1556 2
a1557 2
       || src->ArrayObj->ElementArrayBufferObj->Name == 0
       || _mesa_IsBuffer(src->ArrayObj->ElementArrayBufferObj->Name))
d1559 1
a1559 1
			  src->ArrayObj->ElementArrayBufferObj->Name);
d1566 1
a1566 1
static void
d1570 10
a1579 3
   /* Get a non driver gl_array_object. */
   attrib->ArrayObj = CALLOC_STRUCT( gl_array_object );
   _mesa_initialize_array_object(ctx, attrib->ArrayObj, 0);
d1593 2
a1594 2
   _mesa_delete_array_object(ctx, attrib->ArrayObj);
   attrib->ArrayObj = 0;
d1620 13
a1632 2
      copy_pixelstore(ctx, attr, &ctx->Pack);
      save_attrib_data(&head, GL_CLIENT_PACK_BIT, attr);
d1635 13
a1647 2
      copy_pixelstore(ctx, attr, &ctx->Unpack);
      save_attrib_data(&head, GL_CLIENT_UNPACK_BIT, attr);
d1653 25
a1677 3
      init_array_attrib_data(ctx, attr);
      save_array_attrib(ctx, attr, &ctx->Array);
      save_attrib_data(&head, GL_CLIENT_VERTEX_ARRAY_BIT, attr);
a1678 3

   ctx->ClientAttribStack[ctx->ClientAttribStackDepth] = head;
   ctx->ClientAttribStackDepth++;
@


1.7
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a2 1
 * Version:  7.6
d20 4
a23 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
a45 1
#include "mfeatures.h"
d49 1
d61 2
a95 1
   GLboolean Map1Attrib[16];  /* GL_NV_vertex_program */
a104 1
   GLboolean Map2Attrib[16];  /* GL_NV_vertex_program */
a121 1
   GLboolean SampleCoverageInvert;    /* GL_ARB_multisample */
d127 1
a127 1
   /* GL_ARB_vertex_program / GL_NV_vertex_program */
d132 3
d138 3
d171 7
a180 3
#if FEATURE_attrib_stack


a208 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
a286 1
      memcpy(attr->Map1Attrib, ctx->Eval.Map1Attrib, sizeof(ctx->Eval.Map1Attrib));
a295 1
      memcpy(attr->Map2Attrib, ctx->Eval.Map2Attrib, sizeof(ctx->Eval.Map2Attrib));
a312 1
      attr->SampleCoverageInvert = ctx->Multisample.SampleCoverageInvert;
d317 1
a317 1
      /* GL_NV_vertex_program */
d321 4
d326 3
d399 1
a399 1
      stipple = (GLuint *) MALLOC( 32*sizeof(GLuint) );
d450 2
d510 1
a510 1
   for (i=0;i<MAX_CLIP_PLANES;i++) {
d514 1
a514 1
			   (GLboolean) ((enable->ClipPlanes & mask) ? GL_TRUE : GL_FALSE));
a548 4
   for (i = 0; i < 16; i++) {
      TEST_AND_UPDATE(ctx->Eval.Map1Attrib[i], enable->Map1Attrib[i],
                      GL_MAP1_VERTEX_ATTRIB0_4_NV + i);
   }
a564 4
   for (i = 0; i < 16; i++) {
      TEST_AND_UPDATE(ctx->Eval.Map2Attrib[i], enable->Map2Attrib[i],
                      GL_MAP2_VERTEX_ATTRIB0_4_NV + i);
   }
d605 1
a605 4
   TEST_AND_UPDATE(ctx->Multisample.SampleCoverageInvert,
                   enable->SampleCoverageInvert,
                   GL_SAMPLE_COVERAGE_INVERT_ARB);
   /* GL_ARB_vertex_program, GL_NV_vertex_program */
d616 8
a623 1
#undef TEST_AND_UPDATE
d631 1
a631 1
         _mesa_ActiveTextureARB(GL_TEXTURE0 + i);
d633 3
a635 6
         _mesa_set_enable(ctx, GL_TEXTURE_1D,
                          (enabled & TEXTURE_1D_BIT) ? GL_TRUE : GL_FALSE);
         _mesa_set_enable(ctx, GL_TEXTURE_2D,
                          (enabled & TEXTURE_2D_BIT) ? GL_TRUE : GL_FALSE);
         _mesa_set_enable(ctx, GL_TEXTURE_3D,
                          (enabled & TEXTURE_3D_BIT) ? GL_TRUE : GL_FALSE);
d638 1
a638 1
                             (enabled & TEXTURE_RECT_BIT) ? GL_TRUE : GL_FALSE);
d642 1
a642 1
                             (enabled & TEXTURE_CUBE_BIT) ? GL_TRUE : GL_FALSE);
d646 1
a646 1
                           (enabled & TEXTURE_1D_ARRAY_BIT) ? GL_TRUE : GL_FALSE);
d648 1
a648 1
                           (enabled & TEXTURE_2D_ARRAY_BIT) ? GL_TRUE : GL_FALSE);
d653 5
a657 9
         _mesa_ActiveTextureARB(GL_TEXTURE0 + i);
         _mesa_set_enable(ctx, GL_TEXTURE_GEN_S,
                          (genEnabled & S_BIT) ? GL_TRUE : GL_FALSE);
         _mesa_set_enable(ctx, GL_TEXTURE_GEN_T,
                          (genEnabled & T_BIT) ? GL_TRUE : GL_FALSE);
         _mesa_set_enable(ctx, GL_TEXTURE_GEN_R,
                          (genEnabled & R_BIT) ? GL_TRUE : GL_FALSE);
         _mesa_set_enable(ctx, GL_TEXTURE_GEN_Q,
                          (genEnabled & Q_BIT) ? GL_TRUE : GL_FALSE);
d661 1
a661 1
   _mesa_ActiveTextureARB(GL_TEXTURE0 + curTexUnitSave);
d679 4
a682 7
      _mesa_ActiveTextureARB(GL_TEXTURE0_ARB + u);
      _mesa_set_enable(ctx, GL_TEXTURE_1D,
                       (unit->Enabled & TEXTURE_1D_BIT) ? GL_TRUE : GL_FALSE);
      _mesa_set_enable(ctx, GL_TEXTURE_2D,
                       (unit->Enabled & TEXTURE_2D_BIT) ? GL_TRUE : GL_FALSE);
      _mesa_set_enable(ctx, GL_TEXTURE_3D,
                       (unit->Enabled & TEXTURE_3D_BIT) ? GL_TRUE : GL_FALSE);
d685 1
a685 1
                     (unit->Enabled & TEXTURE_CUBE_BIT) ? GL_TRUE : GL_FALSE);
d689 1
a689 1
                     (unit->Enabled & TEXTURE_RECT_BIT) ? GL_TRUE : GL_FALSE);
d693 1
a693 1
                 (unit->Enabled & TEXTURE_1D_ARRAY_BIT) ? GL_TRUE : GL_FALSE);
d695 1
a695 1
                 (unit->Enabled & TEXTURE_2D_ARRAY_BIT) ? GL_TRUE : GL_FALSE);
a696 1

d721 23
a743 46
      _mesa_set_enable(ctx, GL_TEXTURE_GEN_S,
                       ((unit->TexGenEnabled & S_BIT) ? GL_TRUE : GL_FALSE));
      _mesa_set_enable(ctx, GL_TEXTURE_GEN_T,
                       ((unit->TexGenEnabled & T_BIT) ? GL_TRUE : GL_FALSE));
      _mesa_set_enable(ctx, GL_TEXTURE_GEN_R,
                       ((unit->TexGenEnabled & R_BIT) ? GL_TRUE : GL_FALSE));
      _mesa_set_enable(ctx, GL_TEXTURE_GEN_Q,
                       ((unit->TexGenEnabled & Q_BIT) ? GL_TRUE : GL_FALSE));
      if (ctx->Extensions.EXT_texture_lod_bias) {
         _mesa_TexEnvf(GL_TEXTURE_FILTER_CONTROL_EXT,
                       GL_TEXTURE_LOD_BIAS_EXT, unit->LodBias);
      }
      if (ctx->Extensions.EXT_texture_env_combine ||
          ctx->Extensions.ARB_texture_env_combine) {
         _mesa_TexEnvi(GL_TEXTURE_ENV, GL_COMBINE_RGB,
                       unit->Combine.ModeRGB);
         _mesa_TexEnvi(GL_TEXTURE_ENV, GL_COMBINE_ALPHA,
                       unit->Combine.ModeA);
         _mesa_TexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_RGB,
                       unit->Combine.SourceRGB[0]);
         _mesa_TexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_RGB,
                       unit->Combine.SourceRGB[1]);
         _mesa_TexEnvi(GL_TEXTURE_ENV, GL_SOURCE2_RGB,
                       unit->Combine.SourceRGB[2]);
         _mesa_TexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_ALPHA,
                       unit->Combine.SourceA[0]);
         _mesa_TexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_ALPHA,
                       unit->Combine.SourceA[1]);
         _mesa_TexEnvi(GL_TEXTURE_ENV, GL_SOURCE2_ALPHA,
                       unit->Combine.SourceA[2]);
         _mesa_TexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_RGB,
                       unit->Combine.OperandRGB[0]);
         _mesa_TexEnvi(GL_TEXTURE_ENV, GL_OPERAND1_RGB,
                       unit->Combine.OperandRGB[1]);
         _mesa_TexEnvi(GL_TEXTURE_ENV, GL_OPERAND2_RGB,
                       unit->Combine.OperandRGB[2]);
         _mesa_TexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_ALPHA,
                       unit->Combine.OperandA[0]);
         _mesa_TexEnvi(GL_TEXTURE_ENV, GL_OPERAND1_ALPHA,
                       unit->Combine.OperandA[1]);
         _mesa_TexEnvi(GL_TEXTURE_ENV, GL_OPERAND2_ALPHA,
                       unit->Combine.OperandA[2]);
         _mesa_TexEnvi(GL_TEXTURE_ENV, GL_RGB_SCALE,
                       1 << unit->Combine.ScaleShiftRGB);
         _mesa_TexEnvi(GL_TEXTURE_ENV, GL_ALPHA_SCALE,
                       1 << unit->Combine.ScaleShiftA);
d745 4
d774 9
a782 1
         else if (obj->Target == GL_TEXTURE_BUFFER)
d808 5
a812 3
         if (ctx->Extensions.ARB_shadow_ambient) {
            _mesa_TexParameterf(target, GL_TEXTURE_COMPARE_FAIL_VALUE_ARB,
                                samp->CompareFailValue);
d814 2
d824 3
a826 1
   _mesa_ActiveTextureARB(GL_TEXTURE0_ARB + texstate->Texture.CurrentUnit);
d847 1
a847 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d881 4
a884 4
               _mesa_ClearColor(color->ClearColorUnclamped[0],
                                color->ClearColorUnclamped[1],
                                color->ClearColorUnclamped[2],
                                color->ClearColorUnclamped[3]);
d895 1
a895 1
                     _mesa_ColorMaskIndexed(i, 
d926 1
a926 1
                     _mesa_DrawBuffersARB(ctx->Const.MaxDrawBuffers,
d950 1
a950 1
                     _mesa_BlendFuncSeparatei(buf, color->Blend[buf].SrcRGB,
d954 1
a954 1
                     _mesa_BlendEquationSeparatei(buf,
d961 1
a961 1
                  _mesa_BlendFuncSeparateEXT(color->Blend[0].SrcRGB,
d973 1
a973 1
                     _mesa_BlendEquationSeparateEXT(
d988 8
a995 2
               _mesa_ClampColorARB(GL_CLAMP_FRAGMENT_COLOR_ARB, color->ClampFragmentColor);
               _mesa_ClampColorARB(GL_CLAMP_READ_COLOR_ARB, color->ClampReadColor);
a1047 2
               _mesa_Hint(GL_CLIP_VOLUME_CLIPPING_HINT_EXT,
                          hint->ClipVolumeClipping);
d1096 1
a1096 1
                }
d1116 4
a1119 1
               _mesa_ClampColorARB(GL_CLAMP_VERTEX_COLOR_ARB, light->ClampVertexColor);
d1168 5
a1172 2
                  _mesa_PointParameterf(GL_POINT_SPRITE_COORD_ORIGIN,
                                        (GLfloat)ctx->Point.SpriteOrigin);
d1254 1
a1254 1
               for (i = 0; i < MAX_CLIP_PLANES; i++) {
d1258 2
a1259 6
                  if (xform->ClipPlanesEnabled & mask) {
                     _mesa_set_enable(ctx, GL_CLIP_PLANE0 + i, GL_TRUE);
                  }
                  else {
                     _mesa_set_enable(ctx, GL_CLIP_PLANE0 + i, GL_FALSE);
                  }
a1275 1
            /* Take care of texture object reference counters */
d1295 18
a1312 1
               _mesa_SampleCoverageARB(ms->SampleCoverageValue,
d1323 2
a1324 2
      FREE( attr->data );
      FREE( attr );
a1330 24
 * Helper for incrementing/decrementing vertex buffer object reference
 * counts when pushing/popping the GL_CLIENT_VERTEX_ARRAY_BIT attribute group.
 */
static void
adjust_buffer_object_ref_counts(struct gl_array_object *arrayObj, GLint step)
{
   GLuint i;

   arrayObj->Vertex.BufferObj->RefCount += step;
   arrayObj->Weight.BufferObj->RefCount += step;
   arrayObj->Normal.BufferObj->RefCount += step;
   arrayObj->Color.BufferObj->RefCount += step;
   arrayObj->SecondaryColor.BufferObj->RefCount += step;
   arrayObj->FogCoord.BufferObj->RefCount += step;
   arrayObj->Index.BufferObj->RefCount += step;
   arrayObj->EdgeFlag.BufferObj->RefCount += step;
   for (i = 0; i < Elements(arrayObj->TexCoord); i++)
      arrayObj->TexCoord[i].BufferObj->RefCount += step;
   for (i = 0; i < Elements(arrayObj->VertexAttrib); i++)
      arrayObj->VertexAttrib[i].BufferObj->RefCount += step;
}


/**
a1346 1
   dst->ClientStorage = src->ClientStorage;
d1355 152
a1513 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d1539 3
a1541 16
      struct gl_array_object *obj;

      attr = MALLOC_STRUCT( gl_array_attrib );
      obj = MALLOC_STRUCT( gl_array_object );

#if FEATURE_ARB_vertex_buffer_object
      /* increment ref counts since we're copying pointers to these objects */
      ctx->Array.ArrayBufferObj->RefCount++;
      ctx->Array.ElementArrayBufferObj->RefCount++;
#endif

      memcpy( attr, &ctx->Array, sizeof(struct gl_array_attrib) );
      memcpy( obj, ctx->Array.ArrayObj, sizeof(struct gl_array_object) );

      attr->ArrayObj = obj;

a1542 3

      /* bump reference counts on buffer objects */
      adjust_buffer_object_ref_counts(ctx->Array.ArrayObj, 1);
d1558 1
a1558 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
a1576 1
	    ctx->NewState |= _NEW_PACKUNPACK;
a1584 1
	    ctx->NewState |= _NEW_PACKUNPACK;
d1587 1
a1587 1
	    struct gl_array_attrib * data =
d1589 2
a1590 28

            adjust_buffer_object_ref_counts(ctx->Array.ArrayObj, -1);
	 
            ctx->Array.ActiveTexture = data->ActiveTexture;
	    if (data->LockCount != 0)
	       _mesa_LockArraysEXT(data->LockFirst, data->LockCount);
	    else if (ctx->Array.LockCount)
	       _mesa_UnlockArraysEXT();

	    _mesa_BindVertexArrayAPPLE( data->ArrayObj->Name );
	    
#if FEATURE_ARB_vertex_buffer_object
            _mesa_BindBufferARB(GL_ARRAY_BUFFER_ARB,
                                data->ArrayBufferObj->Name);
            _mesa_BindBufferARB(GL_ELEMENT_ARRAY_BUFFER_ARB,
                                data->ElementArrayBufferObj->Name);
#endif

	    memcpy( ctx->Array.ArrayObj, data->ArrayObj,
		    sizeof( struct gl_array_object ) );

	    FREE( data->ArrayObj );
	    
	    /* FIXME: Should some bits in ctx->Array->NewState also be set
	     * FIXME: here?  It seems like it should be set to inclusive-or
	     * FIXME: of the old ArrayObj->_Enabled and the new _Enabled.
	     */

d1600 2
a1601 2
      FREE( node->data );
      FREE( node );
a1606 13
void
_mesa_init_attrib_dispatch(struct _glapi_table *disp)
{
   SET_PopAttrib(disp, _mesa_PopAttrib);
   SET_PushAttrib(disp, _mesa_PushAttrib);
   SET_PopClientAttrib(disp, _mesa_PopClientAttrib);
   SET_PushClientAttrib(disp, _mesa_PushClientAttrib);
}


#endif /* FEATURE_attrib_stack */


d1629 1
@


1.6
log
@Merge Mesa 7.10.3
@
text
@d46 1
a127 3
   /* SGI_texture_color_table */
   GLboolean TextureColorTable[MAX_TEXTURE_UNITS];

a310 1
         attr->TextureColorTable[i] = ctx->Texture.Unit[i].ColorTableEnabled;
a655 3

      /* GL_SGI_texture_color_table */
      ctx->Texture.Unit[i].ColorTableEnabled = enable->TextureColorTable[i];
a697 4
      if (ctx->Extensions.SGI_texture_color_table) {
         _mesa_set_enable(ctx, GL_TEXTURE_COLOR_TABLE_SGI,
                          unit->ColorTableEnabled);
      }
d773 1
d794 2
d801 11
a811 1
         _mesa_TexParameterfv(target, GL_TEXTURE_BORDER_COLOR, obj->BorderColor.f);
a812 8
         _mesa_TexParameteri(target, GL_TEXTURE_WRAP_S, obj->WrapS);
         _mesa_TexParameteri(target, GL_TEXTURE_WRAP_T, obj->WrapT);
         _mesa_TexParameteri(target, GL_TEXTURE_WRAP_R, obj->WrapR);
         _mesa_TexParameteri(target, GL_TEXTURE_MIN_FILTER, obj->MinFilter);
         _mesa_TexParameteri(target, GL_TEXTURE_MAG_FILTER, obj->MagFilter);
         _mesa_TexParameterf(target, GL_TEXTURE_MIN_LOD, obj->MinLod);
         _mesa_TexParameterf(target, GL_TEXTURE_MAX_LOD, obj->MaxLod);
         _mesa_TexParameterf(target, GL_TEXTURE_LOD_BIAS, obj->LodBias);
d818 1
a818 1
                                obj->MaxAnisotropy);
d822 1
a822 1
                                obj->CompareFailValue);
d887 4
a890 4
               _mesa_ClearColor(color->ClearColor[0],
                                color->ClearColor[1],
                                color->ClearColor[2],
                                color->ClearColor[3]);
d938 1
a938 1
               _mesa_AlphaFunc(color->AlphaFunc, color->AlphaRef);
d951 37
a987 18
               _mesa_BlendFuncSeparateEXT(color->BlendSrcRGB,
                                          color->BlendDstRGB,
                                          color->BlendSrcA,
                                          color->BlendDstA);
	       /* This special case is because glBlendEquationSeparateEXT
		* cannot take GL_LOGIC_OP as a parameter.
		*/
	       if ( color->BlendEquationRGB == color->BlendEquationA ) {
		  _mesa_BlendEquation(color->BlendEquationRGB);
	       }
	       else {
		  _mesa_BlendEquationSeparateEXT(color->BlendEquationRGB,
						 color->BlendEquationA);
	       }
               _mesa_BlendColor(color->BlendColor[0],
                                color->BlendColor[1],
                                color->BlendColor[2],
                                color->BlendColor[3]);
d994 2
d1118 1
@


1.5
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d44 1
a49 1
#include "simple_list.h"
a71 4
   GLboolean ColorTable[COLORTABLE_MAX];
   GLboolean Convolution1D;
   GLboolean Convolution2D;
   GLboolean Separable2D;
a76 1
   GLboolean Histogram;
a104 1
   GLboolean MinMax;
a258 6
      for (i = 0; i < COLORTABLE_MAX; i++) {
         attr->ColorTable[i] = ctx->Pixel.ColorTableEnabled[i];
      }
      attr->Convolution1D = ctx->Pixel.Convolution1DEnabled;
      attr->Convolution2D = ctx->Pixel.Convolution2DEnabled;
      attr->Separable2D = ctx->Pixel.Separable2DEnabled;
a269 2
      attr->Histogram = ctx->Pixel.HistogramEnabled;
      attr->MinMax = ctx->Pixel.MinMaxEnabled;
d476 1
a476 1
pop_enable_group(GLcontext *ctx, const struct gl_enable_attrib *enable)
a507 9
   TEST_AND_UPDATE(ctx->Pixel.ColorTableEnabled[COLORTABLE_PRECONVOLUTION],
                   enable->ColorTable[COLORTABLE_PRECONVOLUTION],
                   GL_COLOR_TABLE);
   TEST_AND_UPDATE(ctx->Pixel.ColorTableEnabled[COLORTABLE_POSTCONVOLUTION],
                   enable->ColorTable[COLORTABLE_POSTCONVOLUTION],
                   GL_POST_CONVOLUTION_COLOR_TABLE);
   TEST_AND_UPDATE(ctx->Pixel.ColorTableEnabled[COLORTABLE_POSTCOLORMATRIX],
                   enable->ColorTable[COLORTABLE_POSTCOLORMATRIX],
                   GL_POST_COLOR_MATRIX_COLOR_TABLE);
a512 6
   TEST_AND_UPDATE(ctx->Pixel.Convolution1DEnabled, enable->Convolution1D,
                   GL_CONVOLUTION_1D);
   TEST_AND_UPDATE(ctx->Pixel.Convolution2DEnabled, enable->Convolution2D,
                   GL_CONVOLUTION_2D);
   TEST_AND_UPDATE(ctx->Pixel.Separable2DEnabled, enable->Separable2D,
                   GL_SEPARABLE_2D);
d672 1
a672 1
pop_texture_group(GLcontext *ctx, struct texture_state *texstate)
d1326 1
a1326 1
copy_pixelstore(GLcontext *ctx,
d1509 1
a1509 1
_mesa_free_attrib_data(GLcontext *ctx)
d1541 1
a1541 1
void _mesa_init_attrib( GLcontext *ctx )
@


1.4
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d3 1
a3 1
 * Version:  7.3
a35 1
#include "colortab.h"
d57 1
d59 99
a157 1
#include "math/m_xform.h"
d177 3
d181 2
a182 2
 * Allocate a new attribute state node.  These nodes have a
 * "kind" value and a pointer to a struct of state data.
d184 3
a186 2
static struct gl_attrib_node *
new_attrib_node( GLbitfield kind )
d188 10
a197 3
   struct gl_attrib_node *an = MALLOC_STRUCT(gl_attrib_node);
   if (an) {
      an->kind = kind;
a198 1
   return an;
a204 1
   struct gl_attrib_node *newnode;
d225 2
a226 5
      MEMCPY( attr, &ctx->Accum, sizeof(struct gl_accum_attrib) );
      newnode = new_attrib_node( GL_ACCUM_BUFFER_BIT );
      newnode->data = attr;
      newnode->next = head;
      head = newnode;
d233 1
a233 1
      MEMCPY( attr, &ctx->Color, sizeof(struct gl_colorbuffer_attrib) );
d237 1
a237 4
      newnode = new_attrib_node( GL_COLOR_BUFFER_BIT );
      newnode->data = attr;
      newnode->next = head;
      head = newnode;
d244 2
a245 5
      MEMCPY( attr, &ctx->Current, sizeof(struct gl_current_attrib) );
      newnode = new_attrib_node( GL_CURRENT_BIT );
      newnode->data = attr;
      newnode->next = head;
      head = newnode;
d251 2
a252 5
      MEMCPY( attr, &ctx->Depth, sizeof(struct gl_depthbuffer_attrib) );
      newnode = new_attrib_node( GL_DEPTH_BUFFER_BIT );
      newnode->data = attr;
      newnode->next = head;
      head = newnode;
d272 1
d295 1
a295 1
      MEMCPY(attr->Map1Attrib, ctx->Eval.Map1Attrib, sizeof(ctx->Eval.Map1Attrib));
d305 1
a305 1
      MEMCPY(attr->Map2Attrib, ctx->Eval.Map2Attrib, sizeof(ctx->Eval.Map2Attrib));
d333 1
a333 4
      newnode = new_attrib_node( GL_ENABLE_BIT );
      newnode->data = attr;
      newnode->next = head;
      head = newnode;
d339 2
a340 5
      MEMCPY( attr, &ctx->Eval, sizeof(struct gl_eval_attrib) );
      newnode = new_attrib_node( GL_EVAL_BIT );
      newnode->data = attr;
      newnode->next = head;
      head = newnode;
d346 2
a347 5
      MEMCPY( attr, &ctx->Fog, sizeof(struct gl_fog_attrib) );
      newnode = new_attrib_node( GL_FOG_BIT );
      newnode->data = attr;
      newnode->next = head;
      head = newnode;
d353 2
a354 5
      MEMCPY( attr, &ctx->Hint, sizeof(struct gl_hint_attrib) );
      newnode = new_attrib_node( GL_HINT_BIT );
      newnode->data = attr;
      newnode->next = head;
      head = newnode;
d361 2
a362 5
      MEMCPY( attr, &ctx->Light, sizeof(struct gl_light_attrib) );
      newnode = new_attrib_node( GL_LIGHTING_BIT );
      newnode->data = attr;
      newnode->next = head;
      head = newnode;
d368 2
a369 5
      MEMCPY( attr, &ctx->Line, sizeof(struct gl_line_attrib) );
      newnode = new_attrib_node( GL_LINE_BIT );
      newnode->data = attr;
      newnode->next = head;
      head = newnode;
d375 2
a376 5
      MEMCPY( attr, &ctx->List, sizeof(struct gl_list_attrib) );
      newnode = new_attrib_node( GL_LIST_BIT );
      newnode->data = attr;
      newnode->next = head;
      head = newnode;
d382 1
a382 1
      MEMCPY( attr, &ctx->Pixel, sizeof(struct gl_pixel_attrib) );
d385 1
a385 4
      newnode = new_attrib_node( GL_PIXEL_MODE_BIT );
      newnode->data = attr;
      newnode->next = head;
      head = newnode;
d391 2
a392 5
      MEMCPY( attr, &ctx->Point, sizeof(struct gl_point_attrib) );
      newnode = new_attrib_node( GL_POINT_BIT );
      newnode->data = attr;
      newnode->next = head;
      head = newnode;
d398 2
a399 5
      MEMCPY( attr, &ctx->Polygon, sizeof(struct gl_polygon_attrib) );
      newnode = new_attrib_node( GL_POLYGON_BIT );
      newnode->data = attr;
      newnode->next = head;
      head = newnode;
d405 2
a406 5
      MEMCPY( stipple, ctx->PolygonStipple, 32*sizeof(GLuint) );
      newnode = new_attrib_node( GL_POLYGON_STIPPLE_BIT );
      newnode->data = stipple;
      newnode->next = head;
      head = newnode;
d412 2
a413 5
      MEMCPY( attr, &ctx->Scissor, sizeof(struct gl_scissor_attrib) );
      newnode = new_attrib_node( GL_SCISSOR_BIT );
      newnode->data = attr;
      newnode->next = head;
      head = newnode;
d419 2
a420 5
      MEMCPY( attr, &ctx->Stencil, sizeof(struct gl_stencil_attrib) );
      newnode = new_attrib_node( GL_STENCIL_BUFFER_BIT );
      newnode->data = attr;
      newnode->next = head;
      head = newnode;
d435 1
a435 1
      _mesa_memcpy(&texstate->Texture, &ctx->Texture, sizeof(ctx->Texture));
d457 1
a457 4
      newnode = new_attrib_node( GL_TEXTURE_BIT );
      newnode->data = texstate;
      newnode->next = head;
      head = newnode;
d463 2
a464 5
      MEMCPY( attr, &ctx->Transform, sizeof(struct gl_transform_attrib) );
      newnode = new_attrib_node( GL_TRANSFORM_BIT );
      newnode->data = attr;
      newnode->next = head;
      head = newnode;
d470 2
a471 5
      MEMCPY( attr, &ctx->Viewport, sizeof(struct gl_viewport_attrib) );
      newnode = new_attrib_node( GL_VIEWPORT_BIT );
      newnode->data = attr;
      newnode->next = head;
      head = newnode;
d478 2
a479 5
      MEMCPY( attr, &ctx->Multisample, sizeof(struct gl_multisample_attrib) );
      newnode = new_attrib_node( GL_MULTISAMPLE_BIT_ARB );
      newnode->data = attr;
      newnode->next = head;
      head = newnode;
d492 1
d501 11
a511 1
   TEST_AND_UPDATE(ctx->Color.BlendEnabled, enable->Blend, GL_BLEND);
d532 2
d649 25
a673 18
      if (ctx->Texture.Unit[i].Enabled != enable->Texture[i]) {
         ctx->Texture.Unit[i].Enabled = enable->Texture[i];
         if (ctx->Driver.Enable) {
            if (ctx->Driver.ActiveTexture) {
               (*ctx->Driver.ActiveTexture)(ctx, i);
            }
            (*ctx->Driver.Enable)( ctx, GL_TEXTURE_1D,
                             (GLboolean) (enable->Texture[i] & TEXTURE_1D_BIT) );
            (*ctx->Driver.Enable)( ctx, GL_TEXTURE_2D,
                             (GLboolean) (enable->Texture[i] & TEXTURE_2D_BIT) );
            (*ctx->Driver.Enable)( ctx, GL_TEXTURE_3D,
                             (GLboolean) (enable->Texture[i] & TEXTURE_3D_BIT) );
            if (ctx->Extensions.ARB_texture_cube_map)
               (*ctx->Driver.Enable)( ctx, GL_TEXTURE_CUBE_MAP_ARB,
                          (GLboolean) (enable->Texture[i] & TEXTURE_CUBE_BIT) );
            if (ctx->Extensions.NV_texture_rectangle)
               (*ctx->Driver.Enable)( ctx, GL_TEXTURE_RECTANGLE_NV,
                          (GLboolean) (enable->Texture[i] & TEXTURE_RECT_BIT) );
d677 10
a686 23
      if (ctx->Texture.Unit[i].TexGenEnabled != enable->TexGen[i]) {
         ctx->Texture.Unit[i].TexGenEnabled = enable->TexGen[i];
         if (ctx->Driver.Enable) {
            if (ctx->Driver.ActiveTexture) {
               (*ctx->Driver.ActiveTexture)(ctx, i);
            }
            if (enable->TexGen[i] & S_BIT)
               (*ctx->Driver.Enable)( ctx, GL_TEXTURE_GEN_S, GL_TRUE);
            else
               (*ctx->Driver.Enable)( ctx, GL_TEXTURE_GEN_S, GL_FALSE);
            if (enable->TexGen[i] & T_BIT)
               (*ctx->Driver.Enable)( ctx, GL_TEXTURE_GEN_T, GL_TRUE);
            else
               (*ctx->Driver.Enable)( ctx, GL_TEXTURE_GEN_T, GL_FALSE);
            if (enable->TexGen[i] & R_BIT)
               (*ctx->Driver.Enable)( ctx, GL_TEXTURE_GEN_R, GL_TRUE);
            else
               (*ctx->Driver.Enable)( ctx, GL_TEXTURE_GEN_R, GL_FALSE);
            if (enable->TexGen[i] & Q_BIT)
               (*ctx->Driver.Enable)( ctx, GL_TEXTURE_GEN_Q, GL_TRUE);
            else
               (*ctx->Driver.Enable)( ctx, GL_TEXTURE_GEN_Q, GL_FALSE);
         }
d693 1
a693 3
   if (ctx->Driver.ActiveTexture) {
      (*ctx->Driver.ActiveTexture)(ctx, ctx->Texture.CurrentUnit);
   }
d726 7
d739 8
a746 8
      _mesa_TexGeni(GL_S, GL_TEXTURE_GEN_MODE, unit->GenModeS);
      _mesa_TexGeni(GL_T, GL_TEXTURE_GEN_MODE, unit->GenModeT);
      _mesa_TexGeni(GL_R, GL_TEXTURE_GEN_MODE, unit->GenModeR);
      _mesa_TexGeni(GL_Q, GL_TEXTURE_GEN_MODE, unit->GenModeQ);
      _mesa_TexGenfv(GL_S, GL_OBJECT_PLANE, unit->ObjectPlaneS);
      _mesa_TexGenfv(GL_T, GL_OBJECT_PLANE, unit->ObjectPlaneT);
      _mesa_TexGenfv(GL_R, GL_OBJECT_PLANE, unit->ObjectPlaneR);
      _mesa_TexGenfv(GL_Q, GL_OBJECT_PLANE, unit->ObjectPlaneQ);
d750 4
a753 4
         COPY_4FV(destUnit->EyePlaneS, unit->EyePlaneS);
         COPY_4FV(destUnit->EyePlaneT, unit->EyePlaneT);
         COPY_4FV(destUnit->EyePlaneR, unit->EyePlaneR);
         COPY_4FV(destUnit->EyePlaneQ, unit->EyePlaneQ);
d755 4
a758 4
            ctx->Driver.TexGen(ctx, GL_S, GL_EYE_PLANE, unit->EyePlaneS);
            ctx->Driver.TexGen(ctx, GL_T, GL_EYE_PLANE, unit->EyePlaneT);
            ctx->Driver.TexGen(ctx, GL_R, GL_EYE_PLANE, unit->EyePlaneR);
            ctx->Driver.TexGen(ctx, GL_Q, GL_EYE_PLANE, unit->EyePlaneQ);
a811 1
         GLfloat bordColor[4];
d837 1
a837 6
         bordColor[0] = CHAN_TO_FLOAT(obj->BorderColor[0]);
         bordColor[1] = CHAN_TO_FLOAT(obj->BorderColor[1]);
         bordColor[2] = CHAN_TO_FLOAT(obj->BorderColor[2]);
         bordColor[3] = CHAN_TO_FLOAT(obj->BorderColor[3]);

         _mesa_TexParameterfv(target, GL_TEXTURE_BORDER_COLOR, bordColor);
d854 3
a856 9
         if (ctx->Extensions.SGIX_shadow) {
            _mesa_TexParameteri(target, GL_TEXTURE_COMPARE_SGIX,
                                obj->CompareFlag);
            _mesa_TexParameteri(target, GL_TEXTURE_COMPARE_OPERATOR_SGIX,
                                obj->CompareOperator);
         }
         if (ctx->Extensions.SGIX_shadow_ambient) {
            _mesa_TexParameterf(target, GL_SHADOW_AMBIENT_SGIX,
                                obj->ShadowAmbient);
d918 1
d926 16
a941 4
               _mesa_ColorMask((GLboolean) (color->ColorMask[0] != 0),
                               (GLboolean) (color->ColorMask[1] != 0),
                               (GLboolean) (color->ColorMask[2] != 0),
                               (GLboolean) (color->ColorMask[3] != 0));
d950 7
a956 8
                  if (ctx->Extensions.ARB_draw_buffers) {
                     GLuint i;
                     for (i = 1; i < ctx->Const.MaxDrawBuffers; i++) {
                        if (color->DrawBuffer[i] != GL_NONE) {
                           multipleBuffers = GL_TRUE;
                           break;
                        }
                     }
d973 12
a984 1
               _mesa_set_enable(ctx, GL_BLEND, color->BlendEnabled);
d1013 1
a1013 1
            MEMCPY( &ctx->Current, attr->data,
d1035 1
a1035 1
            MEMCPY( &ctx->Eval, attr->data, sizeof(struct gl_eval_attrib) );
d1063 2
a1064 3
               if (ctx->Extensions.ARB_texture_compression)
                  _mesa_Hint(GL_TEXTURE_COMPRESSION_HINT_ARB,
                             hint->TextureCompression);
d1079 1
a1079 1
		  const struct gl_light *l = &light->Light[i];
d1081 31
a1111 14
		  _mesa_light(ctx, i, GL_AMBIENT, l->Ambient);
		  _mesa_light(ctx, i, GL_DIFFUSE, l->Diffuse);
		  _mesa_light(ctx, i, GL_SPECULAR, l->Specular );
		  _mesa_light(ctx, i, GL_POSITION, l->EyePosition);
		  _mesa_light(ctx, i, GL_SPOT_DIRECTION, l->EyeDirection);
		  _mesa_light(ctx, i, GL_SPOT_EXPONENT, &l->SpotExponent);
		  _mesa_light(ctx, i, GL_SPOT_CUTOFF, &l->SpotCutoff);
		  _mesa_light(ctx, i, GL_CONSTANT_ATTENUATION,
                              &l->ConstantAttenuation);
		  _mesa_light(ctx, i, GL_LINEAR_ATTENUATION,
                              &l->LinearAttenuation);
		  _mesa_light(ctx, i, GL_QUADRATIC_ATTENUATION,
                              &l->QuadraticAttenuation);
               }
d1129 1
a1129 1
               MEMCPY(&ctx->Light.Material, &light->Material,
d1144 1
a1144 1
            MEMCPY( &ctx->List, attr->data, sizeof(struct gl_list_attrib) );
d1147 1
a1147 1
            MEMCPY( &ctx->Pixel, attr->data, sizeof(struct gl_pixel_attrib) );
d1206 1
a1206 1
	    MEMCPY( ctx->PolygonStipple, attr->data, 32*sizeof(GLuint) );
d1282 3
d1331 1
a1331 1
adjust_buffer_object_ref_counts(struct gl_array_attrib *array, GLint step)
d1334 13
a1346 11
   array->ArrayObj->Vertex.BufferObj->RefCount += step;
   array->ArrayObj->Normal.BufferObj->RefCount += step;
   array->ArrayObj->Color.BufferObj->RefCount += step;
   array->ArrayObj->SecondaryColor.BufferObj->RefCount += step;
   array->ArrayObj->FogCoord.BufferObj->RefCount += step;
   array->ArrayObj->Index.BufferObj->RefCount += step;
   array->ArrayObj->EdgeFlag.BufferObj->RefCount += step;
   for (i = 0; i < MAX_TEXTURE_COORD_UNITS; i++)
      array->ArrayObj->TexCoord[i].BufferObj->RefCount += step;
   for (i = 0; i < VERT_ATTRIB_MAX; i++)
      array->ArrayObj->VertexAttrib[i].BufferObj->RefCount += step;
a1379 1
   struct gl_attrib_node *newnode;
d1400 1
a1400 4
      newnode = new_attrib_node( GL_CLIENT_PACK_BIT );
      newnode->data = attr;
      newnode->next = head;
      head = newnode;
d1404 1
a1404 4
      newnode = new_attrib_node( GL_CLIENT_UNPACK_BIT );
      newnode->data = attr;
      newnode->next = head;
      head = newnode;
d1420 2
a1421 2
      MEMCPY( attr, &ctx->Array, sizeof(struct gl_array_attrib) );
      MEMCPY( obj, ctx->Array.ArrayObj, sizeof(struct gl_array_object) );
d1425 2
a1426 4
      newnode = new_attrib_node( GL_CLIENT_VERTEX_ARRAY_BIT );
      newnode->data = attr;
      newnode->next = head;
      head = newnode;
d1428 1
a1428 1
      adjust_buffer_object_ref_counts(&ctx->Array, 1);
d1478 1
a1478 1
            adjust_buffer_object_ref_counts(&ctx->Array, -1);
d1495 1
a1495 1
	    MEMCPY( ctx->Array.ArrayObj, data->ArrayObj,
d1521 13
d1562 2
a1563 2
         _mesa_free(attr->data);
         _mesa_free(attr);
@


1.3
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d3 1
a3 1
 * Version:  7.2
d6 1
d34 1
d46 1
d49 1
d52 2
d55 1
d228 1
a228 1
      for (i=0; i<MAX_TEXTURE_UNITS; i++) {
d368 1
a368 1
      GLuint u;
d384 4
a387 14
         _mesa_reference_texobj(&texstate->SavedTexRef[u][TEXTURE_1D_INDEX],
                                ctx->Texture.Unit[u].Current1D);
         _mesa_reference_texobj(&texstate->SavedTexRef[u][TEXTURE_2D_INDEX],
                                ctx->Texture.Unit[u].Current2D);
         _mesa_reference_texobj(&texstate->SavedTexRef[u][TEXTURE_3D_INDEX],
                                ctx->Texture.Unit[u].Current3D);
         _mesa_reference_texobj(&texstate->SavedTexRef[u][TEXTURE_CUBE_INDEX],
                                ctx->Texture.Unit[u].CurrentCubeMap);
         _mesa_reference_texobj(&texstate->SavedTexRef[u][TEXTURE_RECT_INDEX],
                                ctx->Texture.Unit[u].CurrentRect);
         _mesa_reference_texobj(&texstate->SavedTexRef[u][TEXTURE_1D_ARRAY_INDEX],
                                ctx->Texture.Unit[u].Current1DArray);
         _mesa_reference_texobj(&texstate->SavedTexRef[u][TEXTURE_2D_ARRAY_INDEX],
                                ctx->Texture.Unit[u].Current2DArray);
d392 4
a395 14
         _mesa_copy_texture_object(&texstate->SavedObj[u][TEXTURE_1D_INDEX],
                                   ctx->Texture.Unit[u].Current1D);
         _mesa_copy_texture_object(&texstate->SavedObj[u][TEXTURE_2D_INDEX],
                                   ctx->Texture.Unit[u].Current2D);
         _mesa_copy_texture_object(&texstate->SavedObj[u][TEXTURE_3D_INDEX],
                                   ctx->Texture.Unit[u].Current3D);
         _mesa_copy_texture_object(&texstate->SavedObj[u][TEXTURE_CUBE_INDEX],
                                   ctx->Texture.Unit[u].CurrentCubeMap);
         _mesa_copy_texture_object(&texstate->SavedObj[u][TEXTURE_RECT_INDEX],
                                   ctx->Texture.Unit[u].CurrentRect);
         _mesa_copy_texture_object(&texstate->SavedObj[u][TEXTURE_1D_ARRAY_INDEX],
                                   ctx->Texture.Unit[u].Current1DArray);
         _mesa_copy_texture_object(&texstate->SavedObj[u][TEXTURE_2D_ARRAY_INDEX],
                                   ctx->Texture.Unit[u].Current2DArray);
d1075 8
a1082 8
                  _mesa_PointParameterfvEXT(GL_DISTANCE_ATTENUATION_EXT,
                                            point->Params);
                  _mesa_PointParameterfEXT(GL_POINT_SIZE_MIN_EXT,
                                           point->MinSize);
                  _mesa_PointParameterfEXT(GL_POINT_SIZE_MAX_EXT,
                                           point->MaxSize);
                  _mesa_PointParameterfEXT(GL_POINT_FADE_THRESHOLD_SIZE_EXT,
                                           point->Threshold);
d1093 4
a1096 4
                     _mesa_PointParameteriNV(GL_POINT_SPRITE_R_MODE_NV,
                                          ctx->Point.SpriteRMode);
                  _mesa_PointParameterfEXT(GL_POINT_SPRITE_COORD_ORIGIN,
                                           (GLfloat)ctx->Point.SpriteOrigin);
d1179 1
a1179 1
                  const GLuint mask = 1 << 1;
a1257 3

   array->ArrayBufferObj->RefCount += step;
   array->ElementArrayBufferObj->RefCount += step;
@


1.2
log
@Update to Mesa 7.0.2. Tested by naddy@@ (full ports build), simon@@
and oga@@ (with dri enabled).
@
text
@d3 1
a3 1
 * Version:  7.0.2
d5 1
a5 1
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
d50 1
a53 1

d62 1
a62 5
   struct gl_texture_object Saved1D[MAX_TEXTURE_UNITS];
   struct gl_texture_object Saved2D[MAX_TEXTURE_UNITS];
   struct gl_texture_object Saved3D[MAX_TEXTURE_UNITS];
   struct gl_texture_object SavedCube[MAX_TEXTURE_UNITS];
   struct gl_texture_object SavedRect[MAX_TEXTURE_UNITS];
d68 1
a68 5
   struct gl_texture_object *SavedRef1D[MAX_TEXTURE_UNITS];
   struct gl_texture_object *SavedRef2D[MAX_TEXTURE_UNITS];
   struct gl_texture_object *SavedRef3D[MAX_TEXTURE_UNITS];
   struct gl_texture_object *SavedRefCube[MAX_TEXTURE_UNITS];
   struct gl_texture_object *SavedRefRect[MAX_TEXTURE_UNITS];
d119 1
d123 3
d360 1
a360 1
      struct texture_state *texstate = CALLOC_STRUCT( texture_state );
d377 14
a390 5
         _mesa_reference_texobj(&texstate->SavedRef1D[u], ctx->Texture.Unit[u].Current1D);
         _mesa_reference_texobj(&texstate->SavedRef2D[u], ctx->Texture.Unit[u].Current2D);
         _mesa_reference_texobj(&texstate->SavedRef3D[u], ctx->Texture.Unit[u].Current3D);
         _mesa_reference_texobj(&texstate->SavedRefCube[u], ctx->Texture.Unit[u].CurrentCubeMap);
         _mesa_reference_texobj(&texstate->SavedRefRect[u], ctx->Texture.Unit[u].CurrentRect);
d395 1
a395 1
         _mesa_copy_texture_object(&texstate->Saved1D[u],
d397 1
a397 1
         _mesa_copy_texture_object(&texstate->Saved2D[u],
d399 1
a399 1
         _mesa_copy_texture_object(&texstate->Saved3D[u],
d401 1
a401 1
         _mesa_copy_texture_object(&texstate->SavedCube[u],
d403 1
a403 1
         _mesa_copy_texture_object(&texstate->SavedRect[u],
d405 4
d771 16
a786 27
         switch (tgt) {
         case TEXTURE_1D_INDEX:
            obj = &texstate->Saved1D[u];
            ASSERT(obj->Target == GL_TEXTURE_1D);
            break;
         case TEXTURE_2D_INDEX:
            obj = &texstate->Saved2D[u];
            ASSERT(obj->Target == GL_TEXTURE_2D);
            break;
         case TEXTURE_3D_INDEX:
            obj = &texstate->Saved3D[u];
            ASSERT(obj->Target == GL_TEXTURE_3D);
            break;
         case TEXTURE_CUBE_INDEX:
            if (!ctx->Extensions.ARB_texture_cube_map)
               continue;
            obj = &texstate->SavedCube[u];
            ASSERT(obj->Target == GL_TEXTURE_CUBE_MAP_ARB);
            break;
         case TEXTURE_RECT_INDEX:
            if (!ctx->Extensions.NV_texture_rectangle)
               continue;
            obj = &texstate->SavedRect[u];
            ASSERT(obj->Target == GL_TEXTURE_RECTANGLE_NV);
            break;
         default:
            _mesa_problem(ctx, "bad texture index in pop_texture_group");
d799 1
a800 1
         _mesa_TexParameterfv(target, GL_TEXTURE_BORDER_COLOR, bordColor);
d829 3
a831 5
      _mesa_reference_texobj(&texstate->SavedRef1D[u], NULL);
      _mesa_reference_texobj(&texstate->SavedRef2D[u], NULL);
      _mesa_reference_texobj(&texstate->SavedRef3D[u], NULL);
      _mesa_reference_texobj(&texstate->SavedRefCube[u], NULL);
      _mesa_reference_texobj(&texstate->SavedRefRect[u], NULL);
d1277 23
d1318 3
a1320 2
   /* Build linked list of attribute nodes which save all attribute */
   /* groups specified by the mask. */
a1324 4
#if FEATURE_EXT_pixel_buffer_object
      ctx->Pack.BufferObj->RefCount++;
      ctx->Unpack.BufferObj->RefCount++;
#endif
d1326 2
a1327 2
      attr = MALLOC_STRUCT( gl_pixelstore_attrib );
      MEMCPY( attr, &ctx->Pack, sizeof(struct gl_pixelstore_attrib) );
d1333 2
a1334 2
      attr = MALLOC_STRUCT( gl_pixelstore_attrib );
      MEMCPY( attr, &ctx->Unpack, sizeof(struct gl_pixelstore_attrib) );
d1340 1
d1377 1
a1377 1
   struct gl_attrib_node *attr, *next;
d1388 1
a1388 1
   attr = ctx->ClientAttribStack[ctx->ClientAttribStackDepth];
d1390 2
a1391 2
   while (attr) {
      switch (attr->kind) {
d1393 5
a1397 5
#if FEATURE_EXT_pixel_buffer_object
            ctx->Pack.BufferObj->RefCount--;
            if (ctx->Pack.BufferObj->RefCount <= 0) {
               _mesa_remove_buffer_object( ctx, ctx->Pack.BufferObj );
               (*ctx->Driver.DeleteBuffer)( ctx, ctx->Pack.BufferObj );
a1398 3
#endif
            MEMCPY( &ctx->Pack, attr->data,
                    sizeof(struct gl_pixelstore_attrib) );
d1402 5
a1406 5
#if FEATURE_EXT_pixel_buffer_object
            ctx->Unpack.BufferObj->RefCount--;
            if (ctx->Unpack.BufferObj->RefCount <= 0) {
               _mesa_remove_buffer_object( ctx, ctx->Unpack.BufferObj );
               (*ctx->Driver.DeleteBuffer)( ctx, ctx->Unpack.BufferObj );
a1407 3
#endif
            MEMCPY( &ctx->Unpack, attr->data,
                    sizeof(struct gl_pixelstore_attrib) );
d1412 1
a1412 1
	      (struct gl_array_attrib *) attr->data;
d1417 4
a1420 2
	    ctx->Array.LockFirst = data->LockFirst;
	    ctx->Array.LockCount = data->LockCount;
d1449 4
a1452 4
      next = attr->next;
      FREE( attr->data );
      FREE( attr );
      attr = next;
d1457 3
d1472 1
a1472 1
            GLuint u;
d1475 3
a1477 5
               _mesa_reference_texobj(&texstate->SavedRef1D[u], NULL);
               _mesa_reference_texobj(&texstate->SavedRef2D[u], NULL);
               _mesa_reference_texobj(&texstate->SavedRef3D[u], NULL);
               _mesa_reference_texobj(&texstate->SavedRefCube[u], NULL);
               _mesa_reference_texobj(&texstate->SavedRefRect[u], NULL);
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * Version:  6.5.1
d5 1
a5 1
 * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
d55 26
d167 3
a169 3
      attr->ColorTable = ctx->Pixel.ColorTableEnabled;
      attr->PostColorMatrixColorTable = ctx->Pixel.PostColorMatrixColorTableEnabled;
      attr->PostConvolutionColorTable = ctx->Pixel.PostConvolutionColorTableEnabled;
d364 1
a364 1
      struct gl_texture_attrib *attr;
d366 13
a378 2
      /* Bump the texture object reference counts so that they don't
       * inadvertantly get deleted.
d381 5
a385 5
	 ctx->Texture.Unit[u].Current1D->RefCount++;
	 ctx->Texture.Unit[u].Current2D->RefCount++;
	 ctx->Texture.Unit[u].Current3D->RefCount++;
	 ctx->Texture.Unit[u].CurrentCubeMap->RefCount++;
	 ctx->Texture.Unit[u].CurrentRect->RefCount++;
d387 2
a388 3
      attr = MALLOC_STRUCT( gl_texture_attrib );
      MEMCPY( attr, &ctx->Texture, sizeof(struct gl_texture_attrib) );
      /* copy state of the currently bound texture objects */
d390 10
a399 10
         _mesa_copy_texture_object(&attr->Unit[u].Saved1D,
                                   attr->Unit[u].Current1D);
         _mesa_copy_texture_object(&attr->Unit[u].Saved2D,
                                   attr->Unit[u].Current2D);
         _mesa_copy_texture_object(&attr->Unit[u].Saved3D,
                                   attr->Unit[u].Current3D);
         _mesa_copy_texture_object(&attr->Unit[u].SavedCubeMap,
                                   attr->Unit[u].CurrentCubeMap);
         _mesa_copy_texture_object(&attr->Unit[u].SavedRect,
                                   attr->Unit[u].CurrentRect);
d401 3
d405 1
a405 1
      newnode->data = attr;
d441 1
d470 2
a471 1
   TEST_AND_UPDATE(ctx->Pixel.ColorTableEnabled, enable->ColorTable,
d473 5
a477 2
   TEST_AND_UPDATE(ctx->Pixel.PostColorMatrixColorTableEnabled,
                   enable->PostColorMatrixColorTable,
a478 3
   TEST_AND_UPDATE(ctx->Pixel.PostConvolutionColorTableEnabled,
                   enable->PostConvolutionColorTable,
                   GL_POST_CONVOLUTION_COLOR_TABLE);
d651 3
d655 1
a655 1
pop_texture_group(GLcontext *ctx, const struct gl_texture_attrib *texAttrib)
d659 2
d662 2
a663 2
      const struct gl_texture_unit *unit = &texAttrib->Unit[u];
      GLuint i;
d756 2
a757 3
      /* Restore texture object state */
      for (i = 0; i < NUM_TEXTURE_TARGETS; i++) {
         GLenum target = 0;
d760 1
d762 12
a773 12
         switch (i) {
         case 0:
            target = GL_TEXTURE_1D;
            obj = &unit->Saved1D;
            break;
         case 1:
            target = GL_TEXTURE_2D;
            obj = &unit->Saved2D;
            break;
         case 2:
            target = GL_TEXTURE_3D;
            obj = &unit->Saved3D;
d775 1
a775 1
         case 3:
d778 2
a779 2
            target = GL_TEXTURE_CUBE_MAP_ARB;
            obj = &unit->SavedCubeMap;
d781 1
a781 1
         case 4:
d784 2
a785 2
            target = GL_TEXTURE_RECTANGLE_NV;
            obj = &unit->SavedRect;
d788 2
a789 1
            ; /* silence warnings */
d792 2
d810 1
d812 2
a813 1
         _mesa_TexParameteri(target, GL_TEXTURE_MAX_LEVEL, obj->MaxLevel);
d828 1
d830 6
a835 1
      }
a836 2
   _mesa_ActiveTextureARB(GL_TEXTURE0_ARB
                          + texAttrib->CurrentUnit);
d838 3
a840 11
   /* "un-bump" the texture object reference counts.  We did that so they
    * wouldn't inadvertantly get deleted while they were still referenced
    * inside the attribute state stack.
    */
   for (u = 0; u < ctx->Const.MaxTextureUnits; u++) {
      ctx->Texture.Unit[u].Current1D->RefCount--;
      ctx->Texture.Unit[u].Current2D->RefCount--;
      ctx->Texture.Unit[u].Current3D->RefCount--;
      ctx->Texture.Unit[u].CurrentCubeMap->RefCount--;
      ctx->Texture.Unit[u].CurrentRect->RefCount--;
   }
a1053 3
               /* materials */
               MEMCPY(&ctx->Light.Material, &light->Material,
                      sizeof(struct gl_material));
d1061 3
d1109 2
a1110 1
                  _mesa_PointParameteriNV(GL_POINT_SPRITE_R_MODE_NV,
d1220 3
a1222 3
               const struct gl_texture_attrib *texture;
               texture = (const struct gl_texture_attrib *) attr->data;
               pop_texture_group(ctx, texture);
d1331 6
d1411 7
d1440 35
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d3 1
a3 1
 * Version:  6.5.2
a339 2

      _mesa_lock_context_textures(ctx);
a364 3

      _mesa_unlock_context_textures(ctx);

d1007 3
a1016 3
               /* materials */
               MEMCPY(&ctx->Light.Material, &light->Material,
                      sizeof(struct gl_material));
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d3 1
a3 1
 * Version:  6.5.3
d5 1
a5 1
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
d141 3
a143 3
      for (i = 0; i < COLORTABLE_MAX; i++) {
         attr->ColorTable[i] = ctx->Pixel.ColorTableEnabled[i];
      }
d435 1
a435 2
   TEST_AND_UPDATE(ctx->Pixel.ColorTableEnabled[COLORTABLE_PRECONVOLUTION],
                   enable->ColorTable[COLORTABLE_PRECONVOLUTION],
d437 5
a441 2
   TEST_AND_UPDATE(ctx->Pixel.ColorTableEnabled[COLORTABLE_POSTCONVOLUTION],
                   enable->ColorTable[COLORTABLE_POSTCONVOLUTION],
a442 3
   TEST_AND_UPDATE(ctx->Pixel.ColorTableEnabled[COLORTABLE_POSTCOLORMATRIX],
                   enable->ColorTable[COLORTABLE_POSTCOLORMATRIX],
                   GL_POST_COLOR_MATRIX_COLOR_TABLE);
a765 1
         _mesa_TexParameterf(target, GL_TEXTURE_LOD_BIAS, obj->LodBias);
d767 1
a767 2
         if (target != GL_TEXTURE_RECTANGLE_ARB)
            _mesa_TexParameteri(target, GL_TEXTURE_MAX_LEVEL, obj->MaxLevel);
a1287 6
#if FEATURE_ARB_vertex_buffer_object
      /* increment ref counts since we're copying pointers to these objects */
      ctx->Array.ArrayBufferObj->RefCount++;
      ctx->Array.ElementArrayBufferObj->RefCount++;
#endif

a1361 7
#if FEATURE_ARB_vertex_buffer_object
            _mesa_BindBufferARB(GL_ARRAY_BUFFER_ARB,
                                data->ArrayBufferObj->Name);
            _mesa_BindBufferARB(GL_ELEMENT_ARRAY_BUFFER_ARB,
                                data->ElementArrayBufferObj->Name);
#endif

@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d3 1
a3 1
 * Version:  7.6
d5 1
a5 2
 * Copyright (C) 1999-2008  Brian Paul   All Rights Reserved.
 * Copyright (C) 2009  VMware, Inc.   All Rights Reserved.
a32 1
#include "clear.h"
d34 1
a42 1
#include "macros.h"
a43 1
#include "multisample.h"
d46 1
a46 1
#include "scissor.h"
a47 2
#include "texenv.h"
#include "texgen.h"
a48 1
#include "texparam.h"
a49 2
#include "varray.h"
#include "viewport.h"
d51 1
a51 1
#include "main/dispatch.h"
d55 2
a56 1
 * glEnable()/glDisable() attribute group (GL_ENABLE_BIT).
d58 2
a59 1
struct gl_enable_attrib
d61 3
a63 125
   GLboolean AlphaTest;
   GLboolean AutoNormal;
   GLboolean Blend;
   GLbitfield ClipPlanes;
   GLboolean ColorMaterial;
   GLboolean CullFace;
   GLboolean DepthClamp;
   GLboolean DepthTest;
   GLboolean Dither;
   GLboolean Fog;
   GLboolean Light[MAX_LIGHTS];
   GLboolean Lighting;
   GLboolean LineSmooth;
   GLboolean LineStipple;
   GLboolean IndexLogicOp;
   GLboolean ColorLogicOp;

   GLboolean Map1Color4;
   GLboolean Map1Index;
   GLboolean Map1Normal;
   GLboolean Map1TextureCoord1;
   GLboolean Map1TextureCoord2;
   GLboolean Map1TextureCoord3;
   GLboolean Map1TextureCoord4;
   GLboolean Map1Vertex3;
   GLboolean Map1Vertex4;
   GLboolean Map1Attrib[16];  /* GL_NV_vertex_program */
   GLboolean Map2Color4;
   GLboolean Map2Index;
   GLboolean Map2Normal;
   GLboolean Map2TextureCoord1;
   GLboolean Map2TextureCoord2;
   GLboolean Map2TextureCoord3;
   GLboolean Map2TextureCoord4;
   GLboolean Map2Vertex3;
   GLboolean Map2Vertex4;
   GLboolean Map2Attrib[16];  /* GL_NV_vertex_program */

   GLboolean Normalize;
   GLboolean PixelTexture;
   GLboolean PointSmooth;
   GLboolean PolygonOffsetPoint;
   GLboolean PolygonOffsetLine;
   GLboolean PolygonOffsetFill;
   GLboolean PolygonSmooth;
   GLboolean PolygonStipple;
   GLboolean RescaleNormals;
   GLboolean Scissor;
   GLboolean Stencil;
   GLboolean StencilTwoSide;          /* GL_EXT_stencil_two_side */
   GLboolean MultisampleEnabled;      /* GL_ARB_multisample */
   GLboolean SampleAlphaToCoverage;   /* GL_ARB_multisample */
   GLboolean SampleAlphaToOne;        /* GL_ARB_multisample */
   GLboolean SampleCoverage;          /* GL_ARB_multisample */
   GLboolean SampleCoverageInvert;    /* GL_ARB_multisample */
   GLboolean RasterPositionUnclipped; /* GL_IBM_rasterpos_clip */

   GLbitfield Texture[MAX_TEXTURE_UNITS];
   GLbitfield TexGen[MAX_TEXTURE_UNITS];

   /* SGI_texture_color_table */
   GLboolean TextureColorTable[MAX_TEXTURE_UNITS];

   /* GL_ARB_vertex_program / GL_NV_vertex_program */
   GLboolean VertexProgram;
   GLboolean VertexProgramPointSize;
   GLboolean VertexProgramTwoSide;

   /* GL_ARB_point_sprite / GL_NV_point_sprite */
   GLboolean PointSprite;
   GLboolean FragmentShaderATI;
};


/**
 * Node for the attribute stack.
 */
struct gl_attrib_node
{
   GLbitfield kind;
   void *data;
   struct gl_attrib_node *next;
};



/**
 * Special struct for saving/restoring texture state (GL_TEXTURE_BIT)
 */
struct texture_state
{
   struct gl_texture_attrib Texture;  /**< The usual context state */

   /** to save per texture object state (wrap modes, filters, etc): */
   struct gl_texture_object SavedObj[MAX_TEXTURE_UNITS][NUM_TEXTURE_TARGETS];

   /**
    * To save references to texture objects (so they don't get accidentally
    * deleted while saved in the attribute stack).
    */
   struct gl_texture_object *SavedTexRef[MAX_TEXTURE_UNITS][NUM_TEXTURE_TARGETS];
};


#if FEATURE_attrib_stack


/**
 * Allocate new attribute node of given type/kind.  Attach payload data.
 * Insert it into the linked list named by 'head'.
 */
static void
save_attrib_data(struct gl_attrib_node **head,
                 GLbitfield kind, void *payload)
{
   struct gl_attrib_node *n = MALLOC_STRUCT(gl_attrib_node);
   if (n) {
      n->kind = kind;
      n->data = payload;
      /* insert at head */
      n->next = *head;
      *head = n;
   }
   else {
      /* out of memory! */
d65 1
d72 1
d93 5
a97 2
      memcpy( attr, &ctx->Accum, sizeof(struct gl_accum_attrib) );
      save_attrib_data(&head, GL_ACCUM_BUFFER_BIT, attr);
a100 1
      GLuint i;
d103 5
a107 5
      memcpy( attr, &ctx->Color, sizeof(struct gl_colorbuffer_attrib) );
      /* push the Draw FBO's DrawBuffer[] state, not ctx->Color.DrawBuffer[] */
      for (i = 0; i < ctx->Const.MaxDrawBuffers; i ++)
         attr->DrawBuffer[i] = ctx->DrawBuffer->ColorDrawBuffer[i];
      save_attrib_data(&head, GL_COLOR_BUFFER_BIT, attr);
d114 5
a118 2
      memcpy( attr, &ctx->Current, sizeof(struct gl_current_attrib) );
      save_attrib_data(&head, GL_CURRENT_BIT, attr);
d124 5
a128 2
      memcpy( attr, &ctx->Depth, sizeof(struct gl_depthbuffer_attrib) );
      save_attrib_data(&head, GL_DEPTH_BUFFER_BIT, attr);
d141 6
a147 1
      attr->DepthClamp = ctx->Transform.DepthClamp;
d157 2
d170 1
a170 1
      memcpy(attr->Map1Attrib, ctx->Eval.Map1Attrib, sizeof(ctx->Eval.Map1Attrib));
d180 1
a180 1
      memcpy(attr->Map2Attrib, ctx->Eval.Map2Attrib, sizeof(ctx->Eval.Map2Attrib));
d199 1
a199 1
      for (i = 0; i < ctx->Const.MaxTextureUnits; i++) {
d208 4
a211 1
      save_attrib_data(&head, GL_ENABLE_BIT, attr);
d217 5
a221 2
      memcpy( attr, &ctx->Eval, sizeof(struct gl_eval_attrib) );
      save_attrib_data(&head, GL_EVAL_BIT, attr);
d227 5
a231 2
      memcpy( attr, &ctx->Fog, sizeof(struct gl_fog_attrib) );
      save_attrib_data(&head, GL_FOG_BIT, attr);
d237 5
a241 2
      memcpy( attr, &ctx->Hint, sizeof(struct gl_hint_attrib) );
      save_attrib_data(&head, GL_HINT_BIT, attr);
d248 5
a252 2
      memcpy( attr, &ctx->Light, sizeof(struct gl_light_attrib) );
      save_attrib_data(&head, GL_LIGHTING_BIT, attr);
d258 5
a262 2
      memcpy( attr, &ctx->Line, sizeof(struct gl_line_attrib) );
      save_attrib_data(&head, GL_LINE_BIT, attr);
d268 5
a272 2
      memcpy( attr, &ctx->List, sizeof(struct gl_list_attrib) );
      save_attrib_data(&head, GL_LIST_BIT, attr);
d278 1
a278 1
      memcpy( attr, &ctx->Pixel, sizeof(struct gl_pixel_attrib) );
d281 4
a284 1
      save_attrib_data(&head, GL_PIXEL_MODE_BIT, attr);
d290 5
a294 2
      memcpy( attr, &ctx->Point, sizeof(struct gl_point_attrib) );
      save_attrib_data(&head, GL_POINT_BIT, attr);
d300 5
a304 2
      memcpy( attr, &ctx->Polygon, sizeof(struct gl_polygon_attrib) );
      save_attrib_data(&head, GL_POLYGON_BIT, attr);
d310 5
a314 2
      memcpy( stipple, ctx->PolygonStipple, 32*sizeof(GLuint) );
      save_attrib_data(&head, GL_POLYGON_STIPPLE_BIT, stipple);
d320 5
a324 2
      memcpy( attr, &ctx->Scissor, sizeof(struct gl_scissor_attrib) );
      save_attrib_data(&head, GL_SCISSOR_BIT, attr);
d330 5
a334 2
      memcpy( attr, &ctx->Stencil, sizeof(struct gl_stencil_attrib) );
      save_attrib_data(&head, GL_STENCIL_BUFFER_BIT, attr);
d338 2
a339 7
      struct texture_state *texstate = CALLOC_STRUCT(texture_state);
      GLuint u, tex;

      if (!texstate) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glPushAttrib(GL_TEXTURE_BIT)");
         goto end;
      }
d342 2
a343 6

      /* copy/save the bulk of texture state here */
      memcpy(&texstate->Texture, &ctx->Texture, sizeof(ctx->Texture));

      /* Save references to the currently bound texture objects so they don't
       * accidentally get deleted while referenced in the attribute stack.
d346 9
a354 7
         for (tex = 0; tex < NUM_TEXTURE_TARGETS; tex++) {
            _mesa_reference_texobj(&texstate->SavedTexRef[u][tex],
                                   ctx->Texture.Unit[u].CurrentTex[tex]);
         }
      }

      /* copy state/contents of the currently bound texture objects */
d356 10
a365 4
         for (tex = 0; tex < NUM_TEXTURE_TARGETS; tex++) {
            _mesa_copy_texture_object(&texstate->SavedObj[u][tex],
                                      ctx->Texture.Unit[u].CurrentTex[tex]);
         }
d370 4
a373 1
      save_attrib_data(&head, GL_TEXTURE_BIT, texstate);
d379 5
a383 2
      memcpy( attr, &ctx->Transform, sizeof(struct gl_transform_attrib) );
      save_attrib_data(&head, GL_TRANSFORM_BIT, attr);
d389 5
a393 2
      memcpy( attr, &ctx->Viewport, sizeof(struct gl_viewport_attrib) );
      save_attrib_data(&head, GL_VIEWPORT_BIT, attr);
d400 5
a404 2
      memcpy( attr, &ctx->Multisample, sizeof(struct gl_multisample_attrib) );
      save_attrib_data(&head, GL_MULTISAMPLE_BIT_ARB, attr);
a406 1
end:
d414 1
a414 1
pop_enable_group(struct gl_context *ctx, const struct gl_enable_attrib *enable)
a415 1
   const GLuint curTexUnitSave = ctx->Texture.CurrentUnit;
d424 1
a424 11
   if (ctx->Color.BlendEnabled != enable->Blend) {
      if (ctx->Extensions.EXT_draw_buffers2) {
         GLuint i;
         for (i = 0; i < ctx->Const.MaxDrawBuffers; i++) {
            _mesa_set_enablei(ctx, GL_BLEND, i, (enable->Blend >> i) & 1);
         }
      }
      else {
         _mesa_set_enable(ctx, GL_BLEND, (enable->Blend & 1));
      }
   }
d435 9
a444 2
   TEST_AND_UPDATE(ctx->Transform.DepthClamp, enable->DepthClamp,
		   GL_DEPTH_CLAMP);
d447 6
d560 18
a577 25
      const GLbitfield enabled = enable->Texture[i];
      const GLbitfield genEnabled = enable->TexGen[i];

      if (ctx->Texture.Unit[i].Enabled != enabled) {
         _mesa_ActiveTextureARB(GL_TEXTURE0 + i);

         _mesa_set_enable(ctx, GL_TEXTURE_1D,
                          (enabled & TEXTURE_1D_BIT) ? GL_TRUE : GL_FALSE);
         _mesa_set_enable(ctx, GL_TEXTURE_2D,
                          (enabled & TEXTURE_2D_BIT) ? GL_TRUE : GL_FALSE);
         _mesa_set_enable(ctx, GL_TEXTURE_3D,
                          (enabled & TEXTURE_3D_BIT) ? GL_TRUE : GL_FALSE);
         if (ctx->Extensions.NV_texture_rectangle) {
            _mesa_set_enable(ctx, GL_TEXTURE_RECTANGLE_ARB,
                             (enabled & TEXTURE_RECT_BIT) ? GL_TRUE : GL_FALSE);
         }
         if (ctx->Extensions.ARB_texture_cube_map) {
            _mesa_set_enable(ctx, GL_TEXTURE_CUBE_MAP,
                             (enabled & TEXTURE_CUBE_BIT) ? GL_TRUE : GL_FALSE);
         }
         if (ctx->Extensions.MESA_texture_array) {
            _mesa_set_enable(ctx, GL_TEXTURE_1D_ARRAY_EXT,
                           (enabled & TEXTURE_1D_ARRAY_BIT) ? GL_TRUE : GL_FALSE);
            _mesa_set_enable(ctx, GL_TEXTURE_2D_ARRAY_EXT,
                           (enabled & TEXTURE_2D_ARRAY_BIT) ? GL_TRUE : GL_FALSE);
d581 23
a603 10
      if (ctx->Texture.Unit[i].TexGenEnabled != genEnabled) {
         _mesa_ActiveTextureARB(GL_TEXTURE0 + i);
         _mesa_set_enable(ctx, GL_TEXTURE_GEN_S,
                          (genEnabled & S_BIT) ? GL_TRUE : GL_FALSE);
         _mesa_set_enable(ctx, GL_TEXTURE_GEN_T,
                          (genEnabled & T_BIT) ? GL_TRUE : GL_FALSE);
         _mesa_set_enable(ctx, GL_TEXTURE_GEN_R,
                          (genEnabled & R_BIT) ? GL_TRUE : GL_FALSE);
         _mesa_set_enable(ctx, GL_TEXTURE_GEN_Q,
                          (genEnabled & Q_BIT) ? GL_TRUE : GL_FALSE);
d610 3
a612 1
   _mesa_ActiveTextureARB(GL_TEXTURE0 + curTexUnitSave);
a615 3
/**
 * Pop/restore texture attribute/group state.
 */
d617 1
a617 1
pop_texture_group(struct gl_context *ctx, struct texture_state *texstate)
a620 2
   _mesa_lock_context_textures(ctx);

d622 2
a623 2
      const struct gl_texture_unit *unit = &texstate->Texture.Unit[u];
      GLuint tgt;
a639 7
      if (ctx->Extensions.MESA_texture_array) {
         _mesa_set_enable(ctx, GL_TEXTURE_1D_ARRAY_EXT,
                 (unit->Enabled & TEXTURE_1D_ARRAY_BIT) ? GL_TRUE : GL_FALSE);
         _mesa_set_enable(ctx, GL_TEXTURE_2D_ARRAY_EXT,
                 (unit->Enabled & TEXTURE_2D_ARRAY_BIT) ? GL_TRUE : GL_FALSE);
      }

d646 8
a653 8
      _mesa_TexGeni(GL_S, GL_TEXTURE_GEN_MODE, unit->GenS.Mode);
      _mesa_TexGeni(GL_T, GL_TEXTURE_GEN_MODE, unit->GenT.Mode);
      _mesa_TexGeni(GL_R, GL_TEXTURE_GEN_MODE, unit->GenR.Mode);
      _mesa_TexGeni(GL_Q, GL_TEXTURE_GEN_MODE, unit->GenQ.Mode);
      _mesa_TexGenfv(GL_S, GL_OBJECT_PLANE, unit->GenS.ObjectPlane);
      _mesa_TexGenfv(GL_T, GL_OBJECT_PLANE, unit->GenT.ObjectPlane);
      _mesa_TexGenfv(GL_R, GL_OBJECT_PLANE, unit->GenR.ObjectPlane);
      _mesa_TexGenfv(GL_Q, GL_OBJECT_PLANE, unit->GenQ.ObjectPlane);
d657 4
a660 4
         COPY_4FV(destUnit->GenS.EyePlane, unit->GenS.EyePlane);
         COPY_4FV(destUnit->GenT.EyePlane, unit->GenT.EyePlane);
         COPY_4FV(destUnit->GenR.EyePlane, unit->GenR.EyePlane);
         COPY_4FV(destUnit->GenQ.EyePlane, unit->GenQ.EyePlane);
d662 4
a665 4
            ctx->Driver.TexGen(ctx, GL_S, GL_EYE_PLANE, unit->GenS.EyePlane);
            ctx->Driver.TexGen(ctx, GL_T, GL_EYE_PLANE, unit->GenT.EyePlane);
            ctx->Driver.TexGen(ctx, GL_R, GL_EYE_PLANE, unit->GenR.EyePlane);
            ctx->Driver.TexGen(ctx, GL_Q, GL_EYE_PLANE, unit->GenQ.EyePlane);
d716 3
a718 2
      /* Restore texture object state for each target */
      for (tgt = 0; tgt < NUM_TEXTURE_TARGETS; tgt++) {
d720 1
a720 1
         GLenum target;
d722 27
a748 17
         obj = &texstate->SavedObj[u][tgt];

         /* don't restore state for unsupported targets to prevent
          * raising GL errors.
          */
         if (obj->Target == GL_TEXTURE_CUBE_MAP_ARB &&
             !ctx->Extensions.ARB_texture_cube_map) {
            continue;
         }
         else if (obj->Target == GL_TEXTURE_RECTANGLE_NV &&
                  !ctx->Extensions.NV_texture_rectangle) {
            continue;
         }
         else if ((obj->Target == GL_TEXTURE_1D_ARRAY_EXT ||
                   obj->Target == GL_TEXTURE_2D_ARRAY_EXT) &&
                  !ctx->Extensions.MESA_texture_array) {
            continue;
d751 1
a751 1
         target = obj->Target;
d753 4
a756 1
         _mesa_BindTexture(target, obj->Name);
a757 1
         _mesa_TexParameterfv(target, GL_TEXTURE_BORDER_COLOR, obj->BorderColor.f);
d759 1
d775 9
a783 3
         if (ctx->Extensions.ARB_shadow_ambient) {
            _mesa_TexParameterf(target, GL_TEXTURE_COMPARE_FAIL_VALUE_ARB,
                                obj->CompareFailValue);
a784 1
      }
a785 3
      /* remove saved references to the texture objects */
      for (tgt = 0; tgt < NUM_TEXTURE_TARGETS; tgt++) {
         _mesa_reference_texobj(&texstate->SavedTexRef[u][tgt], NULL);
d788 2
d791 11
a801 3
   _mesa_ActiveTextureARB(GL_TEXTURE0_ARB + texstate->Texture.CurrentUnit);

   _mesa_unlock_context_textures(ctx);
a850 1

d858 4
a861 16
               if (!ctx->Extensions.EXT_draw_buffers2) {
                  _mesa_ColorMask((GLboolean) (color->ColorMask[0][0] != 0),
                                  (GLboolean) (color->ColorMask[0][1] != 0),
                                  (GLboolean) (color->ColorMask[0][2] != 0),
                                  (GLboolean) (color->ColorMask[0][3] != 0));
               }
               else {
                  GLuint i;
                  for (i = 0; i < ctx->Const.MaxDrawBuffers; i++) {
                     _mesa_ColorMaskIndexed(i, 
                                  (GLboolean) (color->ColorMask[i][0] != 0),
                                  (GLboolean) (color->ColorMask[i][1] != 0),
                                  (GLboolean) (color->ColorMask[i][2] != 0),
                                  (GLboolean) (color->ColorMask[i][3] != 0));
                  }
               }
d870 8
a877 7
		  GLuint i;

		  for (i = 1; i < ctx->Const.MaxDrawBuffers; i++) {
		     if (color->DrawBuffer[i] != GL_NONE) {
			multipleBuffers = GL_TRUE;
			break;
		     }
d894 1
a894 12
               if (ctx->Color.BlendEnabled != color->BlendEnabled) {
                  if (ctx->Extensions.EXT_draw_buffers2) {
                     GLuint i;
                     for (i = 0; i < ctx->Const.MaxDrawBuffers; i++) {
                        _mesa_set_enablei(ctx, GL_BLEND, i,
                                          (color->BlendEnabled >> i) & 1);
                     }
                  }
                  else {
                     _mesa_set_enable(ctx, GL_BLEND, (color->BlendEnabled & 1));
                  }
               }
d923 1
a923 1
            memcpy( &ctx->Current, attr->data,
d945 1
a945 1
            memcpy( &ctx->Eval, attr->data, sizeof(struct gl_eval_attrib) );
d973 3
a975 2
	       _mesa_Hint(GL_TEXTURE_COMPRESSION_HINT_ARB,
			  hint->TextureCompression);
d990 1
a990 1
                  const struct gl_light *l = &light->Light[i];
d992 14
a1005 31
                  _mesa_light(ctx, i, GL_AMBIENT, l->Ambient);
                  _mesa_light(ctx, i, GL_DIFFUSE, l->Diffuse);
                  _mesa_light(ctx, i, GL_SPECULAR, l->Specular );
                  _mesa_light(ctx, i, GL_POSITION, l->EyePosition);
                  _mesa_light(ctx, i, GL_SPOT_DIRECTION, l->SpotDirection);
                  {
                     GLfloat p[4] = { 0 };
                     p[0] = l->SpotExponent;
                     _mesa_light(ctx, i, GL_SPOT_EXPONENT, p);
                  }
                  {
                     GLfloat p[4] = { 0 };
                     p[0] = l->SpotCutoff;
                     _mesa_light(ctx, i, GL_SPOT_CUTOFF, p);
                  }
                  {
                     GLfloat p[4] = { 0 };
                     p[0] = l->ConstantAttenuation;
                     _mesa_light(ctx, i, GL_CONSTANT_ATTENUATION, p);
                  }
                  {
                     GLfloat p[4] = { 0 };
                     p[0] = l->LinearAttenuation;
                     _mesa_light(ctx, i, GL_LINEAR_ATTENUATION, p);
                  }
                  {
                     GLfloat p[4] = { 0 };
                     p[0] = l->QuadraticAttenuation;
                     _mesa_light(ctx, i, GL_QUADRATIC_ATTENUATION, p);
                  }
                }
d1023 1
a1023 1
               memcpy(&ctx->Light.Material, &light->Material,
d1038 1
a1038 1
            memcpy( &ctx->List, attr->data, sizeof(struct gl_list_attrib) );
d1041 1
a1041 1
            memcpy( &ctx->Pixel, attr->data, sizeof(struct gl_pixel_attrib) );
d1053 8
a1060 8
                  _mesa_PointParameterfv(GL_DISTANCE_ATTENUATION_EXT,
                                         point->Params);
                  _mesa_PointParameterf(GL_POINT_SIZE_MIN_EXT,
                                        point->MinSize);
                  _mesa_PointParameterf(GL_POINT_SIZE_MAX_EXT,
                                        point->MaxSize);
                  _mesa_PointParameterf(GL_POINT_FADE_THRESHOLD_SIZE_EXT,
                                        point->Threshold);
d1070 4
a1073 5
                  if (ctx->Extensions.NV_point_sprite)
                     _mesa_PointParameteri(GL_POINT_SPRITE_R_MODE_NV,
                                           ctx->Point.SpriteRMode);
                  _mesa_PointParameterf(GL_POINT_SPRITE_COORD_ORIGIN,
                                        (GLfloat)ctx->Point.SpriteOrigin);
d1099 1
a1099 1
	    memcpy( ctx->PolygonStipple, attr->data, 32*sizeof(GLuint) );
d1156 1
a1156 1
                  const GLuint mask = 1 << i;
a1174 3
               if (xform->DepthClamp != ctx->Transform.DepthClamp)
                  _mesa_set_enable(ctx, GL_DEPTH_CLAMP,
                                   ctx->Transform.DepthClamp);
d1180 3
a1182 3
               struct texture_state *texstate
                  = (struct texture_state *) attr->data;
               pop_texture_group(ctx, texstate);
d1221 1
a1221 1
adjust_buffer_object_ref_counts(struct gl_array_object *arrayObj, GLint step)
d1224 11
d1236 2
a1237 35
   arrayObj->Vertex.BufferObj->RefCount += step;
   arrayObj->Weight.BufferObj->RefCount += step;
   arrayObj->Normal.BufferObj->RefCount += step;
   arrayObj->Color.BufferObj->RefCount += step;
   arrayObj->SecondaryColor.BufferObj->RefCount += step;
   arrayObj->FogCoord.BufferObj->RefCount += step;
   arrayObj->Index.BufferObj->RefCount += step;
   arrayObj->EdgeFlag.BufferObj->RefCount += step;
   for (i = 0; i < Elements(arrayObj->TexCoord); i++)
      arrayObj->TexCoord[i].BufferObj->RefCount += step;
   for (i = 0; i < Elements(arrayObj->VertexAttrib); i++)
      arrayObj->VertexAttrib[i].BufferObj->RefCount += step;
}


/**
 * Copy gl_pixelstore_attrib from src to dst, updating buffer
 * object refcounts.
 */
static void
copy_pixelstore(struct gl_context *ctx,
                struct gl_pixelstore_attrib *dst,
                const struct gl_pixelstore_attrib *src)
{
   dst->Alignment = src->Alignment;
   dst->RowLength = src->RowLength;
   dst->SkipPixels = src->SkipPixels;
   dst->SkipRows = src->SkipRows;
   dst->ImageHeight = src->ImageHeight;
   dst->SkipImages = src->SkipImages;
   dst->SwapBytes = src->SwapBytes;
   dst->LsbFirst = src->LsbFirst;
   dst->ClientStorage = src->ClientStorage;
   dst->Invert = src->Invert;
   _mesa_reference_buffer_object(ctx, &dst->BufferObj, src->BufferObj);
d1248 1
d1259 2
a1260 3
   /* Build linked list of attribute nodes which save all attribute
    * groups specified by the mask.
    */
d1265 4
d1270 6
a1275 3
      attr = CALLOC_STRUCT( gl_pixelstore_attrib );
      copy_pixelstore(ctx, attr, &ctx->Pack);
      save_attrib_data(&head, GL_CLIENT_PACK_BIT, attr);
d1277 6
a1282 3
      attr = CALLOC_STRUCT( gl_pixelstore_attrib );
      copy_pixelstore(ctx, attr, &ctx->Unpack);
      save_attrib_data(&head, GL_CLIENT_UNPACK_BIT, attr);
a1283 1

d1297 2
a1298 2
      memcpy( attr, &ctx->Array, sizeof(struct gl_array_attrib) );
      memcpy( obj, ctx->Array.ArrayObj, sizeof(struct gl_array_object) );
d1302 4
a1305 2
      save_attrib_data(&head, GL_CLIENT_VERTEX_ARRAY_BIT, attr);

d1307 1
a1307 1
      adjust_buffer_object_ref_counts(ctx->Array.ArrayObj, 1);
d1320 1
a1320 1
   struct gl_attrib_node *node, *next;
d1331 1
a1331 1
   node = ctx->ClientAttribStack[ctx->ClientAttribStackDepth];
d1333 2
a1334 2
   while (node) {
      switch (node->kind) {
d1336 5
a1340 5
            {
               struct gl_pixelstore_attrib *store =
                  (struct gl_pixelstore_attrib *) node->data;
               copy_pixelstore(ctx, &ctx->Pack, store);
               _mesa_reference_buffer_object(ctx, &store->BufferObj, NULL);
d1342 3
d1348 5
a1352 5
            {
               struct gl_pixelstore_attrib *store =
                  (struct gl_pixelstore_attrib *) node->data;
               copy_pixelstore(ctx, &ctx->Unpack, store);
               _mesa_reference_buffer_object(ctx, &store->BufferObj, NULL);
d1354 3
d1361 1
a1361 1
	      (struct gl_array_attrib *) node->data;
d1363 1
a1363 1
            adjust_buffer_object_ref_counts(ctx->Array.ArrayObj, -1);
d1366 2
a1367 4
	    if (data->LockCount != 0)
	       _mesa_LockArraysEXT(data->LockFirst, data->LockCount);
	    else if (ctx->Array.LockCount)
	       _mesa_UnlockArraysEXT();
d1378 1
a1378 1
	    memcpy( ctx->Array.ArrayObj, data->ArrayObj,
d1396 4
a1399 53
      next = node->next;
      FREE( node->data );
      FREE( node );
      node = next;
   }
}


void
_mesa_init_attrib_dispatch(struct _glapi_table *disp)
{
   SET_PopAttrib(disp, _mesa_PopAttrib);
   SET_PushAttrib(disp, _mesa_PushAttrib);
   SET_PopClientAttrib(disp, _mesa_PopClientAttrib);
   SET_PushClientAttrib(disp, _mesa_PushClientAttrib);
}


#endif /* FEATURE_attrib_stack */


/**
 * Free any attribute state data that might be attached to the context.
 */
void
_mesa_free_attrib_data(struct gl_context *ctx)
{
   while (ctx->AttribStackDepth > 0) {
      struct gl_attrib_node *attr, *next;

      ctx->AttribStackDepth--;
      attr = ctx->AttribStack[ctx->AttribStackDepth];

      while (attr) {
         if (attr->kind == GL_TEXTURE_BIT) {
            struct texture_state *texstate = (struct texture_state*)attr->data;
            GLuint u, tgt;
            /* clear references to the saved texture objects */
            for (u = 0; u < ctx->Const.MaxTextureUnits; u++) {
               for (tgt = 0; tgt < NUM_TEXTURE_TARGETS; tgt++) {
                  _mesa_reference_texobj(&texstate->SavedTexRef[u][tgt], NULL);
               }
            }
         }
         else {
            /* any other chunks of state that requires special handling? */
         }

         next = attr->next;
         free(attr->data);
         free(attr);
         attr = next;
      }
d1404 1
a1404 1
void _mesa_init_attrib( struct gl_context *ctx )
@


1.1.1.5
log
@Import Mesa 9.2.0
@
text
@d3 1
d21 3
a23 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
a48 1
#include "shared.h"
a59 2
#include "hash.h"
#include <stdbool.h>
d93 1
d103 1
d121 1
d127 4
a130 1
   /* GL_ARB_vertex_program */
a134 3
   /* GL_ARB_fragment_program */
   GLboolean FragmentProgram;

a137 3

   /* GL_ARB_framebuffer_sRGB / GL_EXT_framebuffer_sRGB */
   GLboolean sRGBEnabled;
d168 1
d170 2
a171 7
   /* We need to keep a reference to the shared state.  That's where the
    * default texture objects are kept.  We don't want that state to be
    * freed while the attribute stack contains pointers to any default
    * texture objects.
    */
   struct gl_shared_state *SharedRef;
};
d202 1
d281 1
d291 1
d309 1
d313 1
d315 1
a315 1
      /* GL_ARB_vertex_program */
a318 4

      /* GL_ARB_fragment_program */
      attr->FragmentProgram = ctx->FragmentProgram.Enabled;

a319 3

      /* GL_ARB_framebuffer_sRGB / GL_EXT_framebuffer_sRGB */
      attr->sRGBEnabled = ctx->Color.sRGBEnabled;
d390 1
a390 1
      stipple = malloc( 32*sizeof(GLuint) );
a440 2
      _mesa_reference_shared_state(ctx, &texstate->SharedRef, ctx->Shared);

d499 1
a499 1
   for (i=0;i<ctx->Const.MaxClipPlanes;i++) {
d503 1
a503 1
			   !!(enable->ClipPlanes & mask));
d538 4
d558 4
d602 4
a605 1
   /* GL_ARB_vertex_program */
d616 1
a616 8
   /* GL_ARB_fragment_program */
   TEST_AND_UPDATE(ctx->FragmentProgram.Enabled,
                   enable->FragmentProgram,
                   GL_FRAGMENT_PROGRAM_ARB);

   /* GL_ARB_framebuffer_sRGB / GL_EXT_framebuffer_sRGB */
   TEST_AND_UPDATE(ctx->Color.sRGBEnabled, enable->sRGBEnabled,
                   GL_FRAMEBUFFER_SRGB);
d624 1
a624 1
         _mesa_ActiveTexture(GL_TEXTURE0 + i);
d626 6
a631 3
         _mesa_set_enable(ctx, GL_TEXTURE_1D, !!(enabled & TEXTURE_1D_BIT));
         _mesa_set_enable(ctx, GL_TEXTURE_2D, !!(enabled & TEXTURE_2D_BIT));
         _mesa_set_enable(ctx, GL_TEXTURE_3D, !!(enabled & TEXTURE_3D_BIT));
d634 1
a634 1
                             !!(enabled & TEXTURE_RECT_BIT));
d638 1
a638 1
                             !!(enabled & TEXTURE_CUBE_BIT));
d642 1
a642 1
                             !!(enabled & TEXTURE_1D_ARRAY_BIT));
d644 1
a644 1
                             !!(enabled & TEXTURE_2D_ARRAY_BIT));
d649 9
a657 5
         _mesa_ActiveTexture(GL_TEXTURE0 + i);
         _mesa_set_enable(ctx, GL_TEXTURE_GEN_S, !!(genEnabled & S_BIT));
         _mesa_set_enable(ctx, GL_TEXTURE_GEN_T, !!(genEnabled & T_BIT));
         _mesa_set_enable(ctx, GL_TEXTURE_GEN_R, !!(genEnabled & R_BIT));
         _mesa_set_enable(ctx, GL_TEXTURE_GEN_Q, !!(genEnabled & Q_BIT));
d659 3
d664 1
a664 1
   _mesa_ActiveTexture(GL_TEXTURE0 + curTexUnitSave);
d682 7
a688 4
      _mesa_ActiveTexture(GL_TEXTURE0_ARB + u);
      _mesa_set_enable(ctx, GL_TEXTURE_1D, !!(unit->Enabled & TEXTURE_1D_BIT));
      _mesa_set_enable(ctx, GL_TEXTURE_2D, !!(unit->Enabled & TEXTURE_2D_BIT));
      _mesa_set_enable(ctx, GL_TEXTURE_3D, !!(unit->Enabled & TEXTURE_3D_BIT));
d691 1
a691 1
                          !!(unit->Enabled & TEXTURE_CUBE_BIT));
d695 1
a695 1
                          !!(unit->Enabled & TEXTURE_RECT_BIT));
d699 1
a699 1
                          !!(unit->Enabled & TEXTURE_1D_ARRAY_BIT));
d701 6
a706 1
                          !!(unit->Enabled & TEXTURE_2D_ARRAY_BIT));
d732 46
a777 23
      _mesa_set_enable(ctx, GL_TEXTURE_GEN_S, !!(unit->TexGenEnabled & S_BIT));
      _mesa_set_enable(ctx, GL_TEXTURE_GEN_T, !!(unit->TexGenEnabled & T_BIT));
      _mesa_set_enable(ctx, GL_TEXTURE_GEN_R, !!(unit->TexGenEnabled & R_BIT));
      _mesa_set_enable(ctx, GL_TEXTURE_GEN_Q, !!(unit->TexGenEnabled & Q_BIT));
      _mesa_TexEnvf(GL_TEXTURE_FILTER_CONTROL, GL_TEXTURE_LOD_BIAS,
		    unit->LodBias);
      _mesa_TexEnvi(GL_TEXTURE_ENV, GL_COMBINE_RGB,
		    unit->Combine.ModeRGB);
      _mesa_TexEnvi(GL_TEXTURE_ENV, GL_COMBINE_ALPHA,
		    unit->Combine.ModeA);
      {
         const GLuint n = ctx->Extensions.NV_texture_env_combine4 ? 4 : 3;
         GLuint i;
         for (i = 0; i < n; i++) {
            _mesa_TexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_RGB + i,
                          unit->Combine.SourceRGB[i]);
            _mesa_TexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_ALPHA + i,
                          unit->Combine.SourceA[i]);
            _mesa_TexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_RGB + i,
                          unit->Combine.OperandRGB[i]);
            _mesa_TexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_ALPHA + i,
                          unit->Combine.OperandA[i]);
         }
a778 4
      _mesa_TexEnvi(GL_TEXTURE_ENV, GL_RGB_SCALE,
		    1 << unit->Combine.ScaleShiftRGB);
      _mesa_TexEnvi(GL_TEXTURE_ENV, GL_ALPHA_SCALE,
		    1 << unit->Combine.ScaleShiftA);
a782 1
         const struct gl_sampler_object *samp;
a802 10
         else if (obj->Target == GL_TEXTURE_CUBE_MAP_ARRAY &&
             !ctx->Extensions.ARB_texture_cube_map_array) {
            continue;
         } else if (obj->Target == GL_TEXTURE_BUFFER)
            continue;
         else if (obj->Target == GL_TEXTURE_EXTERNAL_OES)
            continue;
         else if (obj->Target == GL_TEXTURE_2D_MULTISAMPLE ||
                  obj->Target == GL_TEXTURE_2D_MULTISAMPLE_ARRAY)
            continue;
d808 1
a808 11
         samp = &obj->Sampler;

         _mesa_TexParameterfv(target, GL_TEXTURE_BORDER_COLOR, samp->BorderColor.f);
         _mesa_TexParameteri(target, GL_TEXTURE_WRAP_S, samp->WrapS);
         _mesa_TexParameteri(target, GL_TEXTURE_WRAP_T, samp->WrapT);
         _mesa_TexParameteri(target, GL_TEXTURE_WRAP_R, samp->WrapR);
         _mesa_TexParameteri(target, GL_TEXTURE_MIN_FILTER, samp->MinFilter);
         _mesa_TexParameteri(target, GL_TEXTURE_MAG_FILTER, samp->MagFilter);
         _mesa_TexParameterf(target, GL_TEXTURE_MIN_LOD, samp->MinLod);
         _mesa_TexParameterf(target, GL_TEXTURE_MAX_LOD, samp->MaxLod);
         _mesa_TexParameterf(target, GL_TEXTURE_LOD_BIAS, samp->LodBias);
d810 8
d823 1
a823 1
                                samp->MaxAnisotropy);
d825 3
a827 5
         if (ctx->Extensions.ARB_shadow) {
            _mesa_TexParameteri(target, GL_TEXTURE_COMPARE_MODE,
                                samp->CompareMode);
            _mesa_TexParameteri(target, GL_TEXTURE_COMPARE_FUNC,
                                samp->CompareFunc);
a828 2
         if (ctx->Extensions.ARB_depth_texture)
            _mesa_TexParameteri(target, GL_DEPTH_TEXTURE_MODE, obj->DepthMode);
d837 1
a837 3
   _mesa_ActiveTexture(GL_TEXTURE0_ARB + texstate->Texture.CurrentUnit);

   _mesa_reference_shared_state(ctx, &texstate->SharedRef, NULL);
d858 1
a858 1
   FLUSH_VERTICES(ctx, 0);
d892 4
a895 4
               _mesa_ClearColor(color->ClearColor.f[0],
                                color->ClearColor.f[1],
                                color->ClearColor.f[2],
                                color->ClearColor.f[3]);
d906 1
a906 1
                     _mesa_ColorMaski(i, 
d937 1
a937 1
                     _mesa_DrawBuffers(ctx->Const.MaxDrawBuffers,
d943 1
a943 1
               _mesa_AlphaFunc(color->AlphaFunc, color->AlphaRefUnclamped);
d956 18
a973 37
               if (ctx->Color._BlendFuncPerBuffer ||
                   ctx->Color._BlendEquationPerBuffer) {
                  /* set blend per buffer */
                  GLuint buf;
                  for (buf = 0; buf < ctx->Const.MaxDrawBuffers; buf++) {
                     _mesa_BlendFuncSeparateiARB(buf, color->Blend[buf].SrcRGB,
                                              color->Blend[buf].DstRGB,
                                              color->Blend[buf].SrcA,
                                              color->Blend[buf].DstA);
                     _mesa_BlendEquationSeparateiARB(buf,
                                                  color->Blend[buf].EquationRGB,
                                                  color->Blend[buf].EquationA);
                  }
               }
               else {
                  /* set same blend modes for all buffers */
                  _mesa_BlendFuncSeparate(color->Blend[0].SrcRGB,
                                             color->Blend[0].DstRGB,
                                             color->Blend[0].SrcA,
                                             color->Blend[0].DstA);
                  /* This special case is because glBlendEquationSeparateEXT
                   * cannot take GL_LOGIC_OP as a parameter.
                   */
                  if (color->Blend[0].EquationRGB ==
                      color->Blend[0].EquationA) {
                     _mesa_BlendEquation(color->Blend[0].EquationRGB);
                  }
                  else {
                     _mesa_BlendEquationSeparate(
                                                 color->Blend[0].EquationRGB,
                                                 color->Blend[0].EquationA);
                  }
               }
               _mesa_BlendColor(color->BlendColorUnclamped[0],
                                color->BlendColorUnclamped[1],
                                color->BlendColorUnclamped[2],
                                color->BlendColorUnclamped[3]);
a979 8
               if (ctx->Extensions.ARB_color_buffer_float)
                  _mesa_ClampColor(GL_CLAMP_FRAGMENT_COLOR_ARB,
                                   color->ClampFragmentColor);
               _mesa_ClampColor(GL_CLAMP_READ_COLOR_ARB, color->ClampReadColor);

               /* GL_ARB_framebuffer_sRGB / GL_EXT_framebuffer_sRGB */
               if (ctx->Extensions.EXT_framebuffer_sRGB)
                  _mesa_set_enable(ctx, GL_FRAMEBUFFER_SRGB, color->sRGBEnabled);
d1032 2
d1082 1
a1082 1
               }
a1101 4
               if (ctx->Extensions.ARB_color_buffer_float) {
                  _mesa_ClampColor(GL_CLAMP_VERTEX_COLOR_ARB,
                                   light->ClampVertexColor);
               }
d1150 2
a1151 5

                  if ((ctx->API == API_OPENGL_COMPAT && ctx->Version >= 20)
                      || ctx->API == API_OPENGL_CORE)
                     _mesa_PointParameterf(GL_POINT_SPRITE_COORD_ORIGIN,
                                           (GLfloat)ctx->Point.SpriteOrigin);
d1233 1
a1233 1
               for (i = 0; i < ctx->Const.MaxClipPlanes; i++) {
d1237 6
a1242 2
                  _mesa_set_enable(ctx, GL_CLIP_PLANE0 + i,
                                   !!(xform->ClipPlanesEnabled & mask));
d1259 1
d1279 1
a1279 18

	       TEST_AND_UPDATE(ctx->Multisample.Enabled,
			       ms->Enabled,
			       GL_MULTISAMPLE);

	       TEST_AND_UPDATE(ctx->Multisample.SampleCoverage,
			       ms->SampleCoverage,
			       GL_SAMPLE_COVERAGE);

	       TEST_AND_UPDATE(ctx->Multisample.SampleAlphaToCoverage,
			       ms->SampleAlphaToCoverage,
			       GL_SAMPLE_ALPHA_TO_COVERAGE);

	       TEST_AND_UPDATE(ctx->Multisample.SampleAlphaToOne,
			       ms->SampleAlphaToOne,
			       GL_SAMPLE_ALPHA_TO_ONE);

               _mesa_SampleCoverage(ms->SampleCoverageValue,
d1290 2
a1291 2
      free(attr->data);
      free(attr);
d1298 24
d1338 1
a1346 152
/**
 * Copy gl_array_object from src to dest.
 * 'dest' must be in an initialized state.
 */
static void
copy_array_object(struct gl_context *ctx,
                  struct gl_array_object *dest,
                  struct gl_array_object *src)
{
   GLuint i;

   /* skip Name */
   /* skip RefCount */

   /* In theory must be the same anyway, but on recreate make sure it matches */
   dest->ARBsemantics = src->ARBsemantics;

   for (i = 0; i < Elements(src->VertexAttrib); i++)
      _mesa_copy_client_array(ctx, &dest->VertexAttrib[i], &src->VertexAttrib[i]);

   /* _Enabled must be the same than on push */
   dest->_Enabled = src->_Enabled;
   dest->_MaxElement = src->_MaxElement;
}

/**
 * Copy gl_array_attrib from src to dest.
 * 'dest' must be in an initialized state.
 */
static void
copy_array_attrib(struct gl_context *ctx,
                  struct gl_array_attrib *dest,
                  struct gl_array_attrib *src,
                  bool vbo_deleted)
{
   /* skip ArrayObj */
   /* skip DefaultArrayObj, Objects */
   dest->ActiveTexture = src->ActiveTexture;
   dest->LockFirst = src->LockFirst;
   dest->LockCount = src->LockCount;
   dest->PrimitiveRestart = src->PrimitiveRestart;
   dest->PrimitiveRestartFixedIndex = src->PrimitiveRestartFixedIndex;
   dest->_PrimitiveRestart = src->_PrimitiveRestart;
   dest->RestartIndex = src->RestartIndex;
   /* skip NewState */
   /* skip RebindArrays */

   if (!vbo_deleted)
      copy_array_object(ctx, dest->ArrayObj, src->ArrayObj);

   /* skip ArrayBufferObj */
   /* skip ElementArrayBufferObj */
}

/**
 * Save the content of src to dest.
 */
static void
save_array_attrib(struct gl_context *ctx,
                  struct gl_array_attrib *dest,
                  struct gl_array_attrib *src)
{
   /* Set the Name, needed for restore, but do never overwrite.
    * Needs to match value in the object hash. */
   dest->ArrayObj->Name = src->ArrayObj->Name;
   /* And copy all of the rest. */
   copy_array_attrib(ctx, dest, src, false);

   /* Just reference them here */
   _mesa_reference_buffer_object(ctx, &dest->ArrayBufferObj,
                                 src->ArrayBufferObj);
   _mesa_reference_buffer_object(ctx, &dest->ArrayObj->ElementArrayBufferObj,
                                 src->ArrayObj->ElementArrayBufferObj);
}

/**
 * Restore the content of src to dest.
 */
static void
restore_array_attrib(struct gl_context *ctx,
                     struct gl_array_attrib *dest,
                     struct gl_array_attrib *src)
{
   /* The ARB_vertex_array_object spec says:
    *
    *     "BindVertexArray fails and an INVALID_OPERATION error is generated
    *     if array is not a name returned from a previous call to
    *     GenVertexArrays, or if such a name has since been deleted with
    *     DeleteVertexArrays."
    *
    * Therefore popping a deleted VAO cannot magically recreate it.
    *
    * The semantics of objects created using APPLE_vertex_array_objects behave
    * differently.  These objects expect to be recreated by pop.  Alas.
    */
   const bool arb_vao = (src->ArrayObj->Name != 0
			 && src->ArrayObj->ARBsemantics);

   if (arb_vao && !_mesa_IsVertexArray(src->ArrayObj->Name))
      return;

   _mesa_BindVertexArrayAPPLE(src->ArrayObj->Name);

   /* Restore or recreate the buffer objects by the names ... */
   if (!arb_vao
       || src->ArrayBufferObj->Name == 0
       || _mesa_IsBuffer(src->ArrayBufferObj->Name)) {
      /* ... and restore its content */
      copy_array_attrib(ctx, dest, src, false);

      _mesa_BindBuffer(GL_ARRAY_BUFFER_ARB,
			  src->ArrayBufferObj->Name);
   } else {
      copy_array_attrib(ctx, dest, src, true);
   }

   if (!arb_vao
       || src->ArrayObj->ElementArrayBufferObj->Name == 0
       || _mesa_IsBuffer(src->ArrayObj->ElementArrayBufferObj->Name))
      _mesa_BindBuffer(GL_ELEMENT_ARRAY_BUFFER_ARB,
			  src->ArrayObj->ElementArrayBufferObj->Name);
}

/**
 * init/alloc the fields of 'attrib'.
 * Needs to the init part matching free_array_attrib_data below.
 */
static void
init_array_attrib_data(struct gl_context *ctx,
                       struct gl_array_attrib *attrib)
{
   /* Get a non driver gl_array_object. */
   attrib->ArrayObj = CALLOC_STRUCT( gl_array_object );
   _mesa_initialize_array_object(ctx, attrib->ArrayObj, 0);
}

/**
 * Free/unreference the fields of 'attrib' but don't delete it (that's
 * done later in the calling code).
 * Needs to the cleanup part matching init_array_attrib_data above.
 */
static void
free_array_attrib_data(struct gl_context *ctx,
                       struct gl_array_attrib *attrib)
{
   /* We use a non driver array object, so don't just unref since we would
    * end up using the drivers DeleteArrayObject function for deletion. */
   _mesa_delete_array_object(ctx, attrib->ArrayObj);
   attrib->ArrayObj = 0;
   _mesa_reference_buffer_object(ctx, &attrib->ArrayBufferObj, NULL);
}

d1354 1
d1380 16
a1395 3
      attr = CALLOC_STRUCT( gl_array_attrib );
      init_array_attrib_data(ctx, attr);
      save_array_attrib(ctx, attr, &ctx->Array);
d1397 3
d1415 1
a1415 1
   FLUSH_VERTICES(ctx, 0);
d1434 1
d1443 1
d1446 1
a1446 1
	    struct gl_array_attrib * attr =
d1448 28
a1475 2
            restore_array_attrib(ctx, &ctx->Array, attr);
            free_array_attrib_data(ctx, attr);
d1485 2
a1486 2
      free(node->data);
      free(node);
d1492 13
a1526 1
            _mesa_reference_shared_state(ctx, &texstate->SharedRef, NULL);
@


1.1.1.6
log
@Import Mesa 10.2.3
@
text
@d115 1
a115 1
   GLbitfield Scissor;
d185 1
a185 1
static bool
a198 34
      return false;
   }
   return true;
}


/**
 * Helper function for_mesa_PushAttrib for simple attributes.
 * Allocates memory for attribute data and copies the given attribute data.
 * \param head  head of linked list to insert attribute data into
 * \param attr_bit  one of the GL_<attrib>_BIT flags
 * \param attr_size  number of bytes to allocate for attribute data
 * \param attr_data  the attribute data to copy
 * \return true for success, false for out of memory
 */
static bool
push_attrib(struct gl_context *ctx, struct gl_attrib_node **head,
            GLbitfield attr_bit, GLuint attr_size, const void *attr_data)
{
   void *attribute;

   attribute = malloc(attr_size);
   if (attribute == NULL) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glPushAttrib");
      return false;
   }

   if (save_attrib_data(head, attr_bit, attribute)) {
      memcpy(attribute, attr_data, attr_size);
   }
   else {
      free(attribute);
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glPushAttrib");
      return false;
a199 1
   return true;
d223 4
a226 4
      if (!push_attrib(ctx, &head, GL_ACCUM_BUFFER_BIT,
                       sizeof(struct gl_accum_attrib),
                       (void*)&ctx->Accum))
         goto end;
d233 5
a237 16
      if (attr == NULL) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glPushAttrib");
         goto end;
      }

    if (save_attrib_data(&head, GL_COLOR_BUFFER_BIT, attr)) {
         memcpy(attr, &ctx->Color, sizeof(struct gl_colorbuffer_attrib));
         /* push the Draw FBO's DrawBuffer[] state, not ctx->Color.DrawBuffer[] */
         for (i = 0; i < ctx->Const.MaxDrawBuffers; i ++)
            attr->DrawBuffer[i] = ctx->DrawBuffer->ColorDrawBuffer[i];
      }
      else {
         free(attr);
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glPushAttrib");
         goto end;
      }
d241 5
a245 5
      FLUSH_CURRENT(ctx, 0);
      if (!push_attrib(ctx, &head, GL_CURRENT_BIT,
                       sizeof(struct gl_current_attrib),
                       (void*)&ctx->Current))
         goto end;
d249 4
a252 4
      if (!push_attrib(ctx, &head, GL_DEPTH_BUFFER_BIT,
                       sizeof(struct gl_depthbuffer_attrib),
                       (void*)&ctx->Depth))
         goto end;
a258 5
      if (attr == NULL) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glPushAttrib");
         goto end;
      }

d306 1
a306 1
      attr->Scissor = ctx->Scissor.EnableFlags;
d325 1
a325 5
      if (!save_attrib_data(&head, GL_ENABLE_BIT, attr)) {
         free(attr);
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glPushAttrib");
         goto end;
      }
d332 4
a335 4
      if (!push_attrib(ctx, &head, GL_EVAL_BIT,
                       sizeof(struct gl_eval_attrib),
                       (void*)&ctx->Eval))
         goto end;
d339 4
a342 4
      if (!push_attrib(ctx, &head, GL_FOG_BIT,
                       sizeof(struct gl_fog_attrib),
                       (void*)&ctx->Fog))
         goto end;
d346 4
a349 4
      if (!push_attrib(ctx, &head, GL_HINT_BIT,
                       sizeof(struct gl_hint_attrib),
                       (void*)&ctx->Hint))
         goto end;
d353 5
a357 5
      FLUSH_CURRENT(ctx, 0);   /* flush material changes */
      if (!push_attrib(ctx, &head, GL_LIGHTING_BIT,
                       sizeof(struct gl_light_attrib),
                       (void*)&ctx->Light))
         goto end;
d361 4
a364 4
      if (!push_attrib(ctx, &head, GL_LINE_BIT,
                       sizeof(struct gl_line_attrib),
                       (void*)&ctx->Line))
         goto end;
d368 4
a371 4
      if (!push_attrib(ctx, &head, GL_LIST_BIT,
                       sizeof(struct gl_list_attrib),
                       (void*)&ctx->List))
         goto end;
d377 4
a380 15
      if (attr == NULL) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glPushAttrib");
         goto end;
      }

      if (save_attrib_data(&head, GL_PIXEL_MODE_BIT, attr)) {
         memcpy(attr, &ctx->Pixel, sizeof(struct gl_pixel_attrib));
         /* push the Read FBO's ReadBuffer state, not ctx->Pixel.ReadBuffer */
         attr->ReadBuffer = ctx->ReadBuffer->ColorReadBuffer;
      }
      else {
         free(attr);
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glPushAttrib");
         goto end;
      }
d384 4
a387 4
      if (!push_attrib(ctx, &head, GL_POINT_BIT,
                       sizeof(struct gl_point_attrib),
                       (void*)&ctx->Point))
         goto end;
d391 4
a394 4
      if (!push_attrib(ctx, &head, GL_POLYGON_BIT,
                       sizeof(struct gl_polygon_attrib),
                       (void*)&ctx->Polygon))
         goto end;
d398 4
a401 4
      if (!push_attrib(ctx, &head, GL_POLYGON_STIPPLE_BIT,
                       sizeof(ctx->PolygonStipple),
                       (void*)&ctx->PolygonStipple))
         goto end;
d405 4
a408 4
      if (!push_attrib(ctx, &head, GL_SCISSOR_BIT,
                       sizeof(struct gl_scissor_attrib),
                       (void*)&ctx->Scissor))
         goto end;
d412 4
a415 4
      if (!push_attrib(ctx, &head, GL_STENCIL_BUFFER_BIT,
                       sizeof(struct gl_stencil_attrib),
                       (void*)&ctx->Stencil))
         goto end;
a426 6
      if (!save_attrib_data(&head, GL_TEXTURE_BIT, texstate)) {
         free(texstate);
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glPushAttrib(GL_TEXTURE_BIT)");
         goto end;
      }

d453 2
d458 4
a461 4
      if (!push_attrib(ctx, &head, GL_TRANSFORM_BIT,
                       sizeof(struct gl_transform_attrib),
                       (void*)&ctx->Transform))
         goto end;
d465 4
a468 5
      if (!push_attrib(ctx, &head, GL_VIEWPORT_BIT,
                       sizeof(struct gl_viewport_attrib)
                       * ctx->Const.MaxViewports,
                       (void*)&ctx->ViewportArray))
         goto end;
d473 4
a476 4
      if (!push_attrib(ctx, &head, GL_MULTISAMPLE_BIT_ARB,
                       sizeof(struct gl_multisample_attrib),
                       (void*)&ctx->Multisample))
         goto end;
d480 2
a481 4
   if (head != NULL) {
       ctx->AttribStack[ctx->AttribStackDepth] = head;
       ctx->AttribStackDepth++;
   }
d589 1
a589 7
   if (ctx->Scissor.EnableFlags != enable->Scissor) {
      unsigned i;

      for (i = 0; i < ctx->Const.MaxViewports; i++) {
         _mesa_set_enablei(ctx, GL_SCISSOR_TEST, i, (enable->Scissor >> i) & 1);
      }
   }
d644 6
d691 6
d771 1
a771 1
                  !ctx->Extensions.EXT_texture_array) {
a1204 1
               unsigned i;
d1207 3
a1209 10

               for (i = 0; i < ctx->Const.MaxViewports; i++) {
                  _mesa_set_scissor(ctx, i,
                                    scissor->ScissorArray[i].X,
                                    scissor->ScissorArray[i].Y,
                                    scissor->ScissorArray[i].Width,
                                    scissor->ScissorArray[i].Height);
                  _mesa_set_enablei(ctx, GL_SCISSOR_TEST, i,
                                    (scissor->EnableFlags >> i) & 1);
               }
a1284 1
               unsigned i;
d1287 2
a1288 6

               for (i = 0; i < ctx->Const.MaxViewports; i++) {
                  _mesa_set_viewport(ctx, i, vp[i].X, vp[i].Y, vp[i].Width,
                                     vp[i].Height);
                  _mesa_set_depth_range(ctx, i, vp[i].Near, vp[i].Far);
               }
d1356 1
a1356 1
 * Copy gl_vertex_array_object from src to dest.
d1361 2
a1362 2
                  struct gl_vertex_array_object *dest,
                  struct gl_vertex_array_object *src)
d1372 2
a1373 5
   for (i = 0; i < Elements(src->_VertexAttrib); i++) {
      _mesa_copy_client_array(ctx, &dest->_VertexAttrib[i], &src->_VertexAttrib[i]);
      _mesa_copy_vertex_attrib_array(ctx, &dest->VertexAttrib[i], &src->VertexAttrib[i]);
      _mesa_copy_vertex_buffer_binding(ctx, &dest->VertexBinding[i], &src->VertexBinding[i]);
   }
a1376 1
   dest->NewArrays = src->NewArrays;
d1403 1
a1403 1
      copy_array_object(ctx, dest->VAO, src->VAO);
d1406 1
a1406 1
   /* skip IndexBufferObj */
d1419 1
a1419 1
   dest->VAO->Name = src->VAO->Name;
d1426 2
a1427 2
   _mesa_reference_buffer_object(ctx, &dest->VAO->IndexBufferObj,
                                 src->VAO->IndexBufferObj);
d1450 2
a1451 2
   const bool arb_vao = (src->VAO->Name != 0
			 && src->VAO->ARBsemantics);
d1453 1
a1453 1
   if (arb_vao && !_mesa_IsVertexArray(src->VAO->Name))
d1456 1
a1456 1
   _mesa_BindVertexArrayAPPLE(src->VAO->Name);
d1472 2
a1473 2
       || src->VAO->IndexBufferObj->Name == 0
       || _mesa_IsBuffer(src->VAO->IndexBufferObj->Name))
d1475 1
a1475 1
			  src->VAO->IndexBufferObj->Name);
d1482 1
a1482 1
static bool
d1486 3
a1488 10
   /* Get a non driver gl_vertex_array_object. */
   attrib->VAO = CALLOC_STRUCT( gl_vertex_array_object );

   if (attrib->VAO == NULL) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glPushClientAttrib");
      return false;
   }

   _mesa_initialize_vao(ctx, attrib->VAO, 0);
   return true;
d1502 2
a1503 2
   _mesa_delete_vao(ctx, attrib->VAO);
   attrib->VAO = 0;
d1529 2
a1530 13
      if (attr == NULL) {
         _mesa_error( ctx, GL_OUT_OF_MEMORY, "glPushClientAttrib" );
         goto end;
      }
      if (save_attrib_data(&head, GL_CLIENT_PACK_BIT, attr)) {
         copy_pixelstore(ctx, attr, &ctx->Pack);
      }
      else {
         _mesa_error( ctx, GL_OUT_OF_MEMORY, "glPushClientAttrib" );
         free(attr);
         goto end;
      }

d1533 2
a1534 13
      if (attr == NULL) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glPushClientAttrib");
         goto end;
      }

      if (save_attrib_data(&head, GL_CLIENT_UNPACK_BIT, attr)) {
         copy_pixelstore(ctx, attr, &ctx->Unpack);
      }
      else {
         _mesa_error( ctx, GL_OUT_OF_MEMORY, "glPushClientAttrib" );
         free(attr);
         goto end;
       }
d1540 4
a1543 9
      if (attr == NULL) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glPushClientAttrib");
         goto end;
      }

      if (!init_array_attrib_data(ctx, attr)) {
         free(attr);
         goto end;
      }
d1545 2
a1546 16
      if (save_attrib_data(&head, GL_CLIENT_VERTEX_ARRAY_BIT, attr)) {
         save_array_attrib(ctx, attr, &ctx->Array);
      }
      else {
         free_array_attrib_data(ctx, attr);
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glPushClientAttrib");
         free(attr);
         /* goto to keep safe from possible later changes */
         goto end;
      }
   }
end:
   if (head != NULL) {
       ctx->ClientAttribStack[ctx->ClientAttribStackDepth] = head;
       ctx->ClientAttribStackDepth++;
   }
@


1.1.1.7
log
@Import Mesa 10.4.3
@
text
@a1347 2
               if (ctx->Extensions.ARB_clip_control)
                  _mesa_ClipControl(xform->ClipOrigin, xform->ClipDepthMode);
d1452 1
a1452 1
   for (i = 0; i < Elements(src->VertexAttrib); i++) {
d1461 1
a1490 4

   /* Invalidate draw state. It will be updated during the next draw. */
   dest->DrawMethod = DRAW_NONE;
   dest->_DrawArrays = NULL;
@


1.1.1.8
log
@Import Mesa 10.2.9
@
text
@d1348 2
d1454 1
a1454 1
   for (i = 0; i < Elements(src->_VertexAttrib); i++) {
a1462 1
   dest->_MaxElement = src->_MaxElement;
d1492 4
@


