head	1.14;
access;
symbols
	OPENBSD_5_8:1.13.0.4
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	v10_2_9:1.1.1.10
	v10_4_3:1.1.1.9
	v10_2_7:1.1.1.8
	OPENBSD_5_6:1.10.0.2
	OPENBSD_5_6_BASE:1.10
	v10_2_3:1.1.1.7
	OPENBSD_5_5:1.9.0.2
	OPENBSD_5_5_BASE:1.9
	v9_2_5:1.1.1.6
	v9_2_3:1.1.1.6
	v9_2_2:1.1.1.6
	v9_2_1:1.1.1.5
	v9_2_0:1.1.1.5
	OPENBSD_5_4:1.7.0.4
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.6.0.4
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.5.0.6
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2015.12.23.05.17.53;	author jsg;	state dead;
branches;
next	1.13;
commitid	TnlogFl9nOv2eaRf;

1.13
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.12;
commitid	4ry2gvZGMXkCUD2n;

1.12
date	2015.01.25.14.41.22;	author jsg;	state Exp;
branches;
next	1.11;
commitid	mcxB0JvoI9gTDYXU;

1.11
date	2014.09.07.15.20.07;	author jsg;	state Exp;
branches;
next	1.10;
commitid	7kimTMT4YlQauAIU;

1.10
date	2014.07.09.21.09.00;	author jsg;	state Exp;
branches;
next	1.9;
commitid	WPD6rgPryPkvXOr9;

1.9
date	2013.11.09.02.46.54;	author jsg;	state Exp;
branches;
next	1.8;

1.8
date	2013.09.05.14.06.31;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2012.08.17.13.58.19;	author mpi;	state Exp;
branches;
next	1.6;

1.6
date	2011.10.23.13.37.44;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.05.22.20.06.31;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.05.17.20.26.41;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.14.58.21;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.05.31.16.36.48;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.50.26;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.50.26;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.56.39;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.31.25;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.47;	author matthieu;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.09.05.13.16.54;	author jsg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2013.11.09.02.36.03;	author jsg;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2014.07.09.20.35.06;	author jsg;	state Exp;
branches;
next	1.1.1.8;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.8
date	2014.09.07.15.07.29;	author jsg;	state Exp;
branches;
next	1.1.1.9;
commitid	dm8VnQHhowGHmemJ;

1.1.1.9
date	2015.01.25.14.12.59;	author jsg;	state Exp;
branches;
next	1.1.1.10;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.10
date	2015.02.20.22.50.05;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.14
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2008  Brian Paul   All Rights Reserved.
 * Copyright (C) 2009  VMware, Inc.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */


/**
 * \file teximage.c
 * Texture image-related functions.
 */

#include <stdbool.h>
#include "glheader.h"
#include "bufferobj.h"
#include "context.h"
#include "enums.h"
#include "fbobject.h"
#include "framebuffer.h"
#include "hash.h"
#include "image.h"
#include "imports.h"
#include "macros.h"
#include "multisample.h"
#include "state.h"
#include "texcompress.h"
#include "texcompress_cpal.h"
#include "teximage.h"
#include "texobj.h"
#include "texstate.h"
#include "texstorage.h"
#include "textureview.h"
#include "mtypes.h"
#include "glformats.h"


/**
 * State changes which we care about for glCopyTex[Sub]Image() calls.
 * In particular, we care about pixel transfer state and buffer state
 * (such as glReadBuffer to make sure we read from the right renderbuffer).
 */
#define NEW_COPY_TEX_STATE (_NEW_BUFFERS | _NEW_PIXEL)



/**
 * Return the simple base format for a given internal texture format.
 * For example, given GL_LUMINANCE12_ALPHA4, return GL_LUMINANCE_ALPHA.
 *
 * \param ctx GL context.
 * \param internalFormat the internal texture format token or 1, 2, 3, or 4.
 *
 * \return the corresponding \u base internal format (GL_ALPHA, GL_LUMINANCE,
 * GL_LUMANCE_ALPHA, GL_INTENSITY, GL_RGB, or GL_RGBA), or -1 if invalid enum.
 *
 * This is the format which is used during texture application (i.e. the
 * texture format and env mode determine the arithmetic used.
 */
GLint
_mesa_base_tex_format( struct gl_context *ctx, GLint internalFormat )
{
   switch (internalFormat) {
      case GL_ALPHA:
      case GL_ALPHA4:
      case GL_ALPHA8:
      case GL_ALPHA12:
      case GL_ALPHA16:
         return (ctx->API != API_OPENGL_CORE) ? GL_ALPHA : -1;
      case 1:
      case GL_LUMINANCE:
      case GL_LUMINANCE4:
      case GL_LUMINANCE8:
      case GL_LUMINANCE12:
      case GL_LUMINANCE16:
         return (ctx->API != API_OPENGL_CORE) ? GL_LUMINANCE : -1;
      case 2:
      case GL_LUMINANCE_ALPHA:
      case GL_LUMINANCE4_ALPHA4:
      case GL_LUMINANCE6_ALPHA2:
      case GL_LUMINANCE8_ALPHA8:
      case GL_LUMINANCE12_ALPHA4:
      case GL_LUMINANCE12_ALPHA12:
      case GL_LUMINANCE16_ALPHA16:
         return (ctx->API != API_OPENGL_CORE) ? GL_LUMINANCE_ALPHA : -1;
      case GL_INTENSITY:
      case GL_INTENSITY4:
      case GL_INTENSITY8:
      case GL_INTENSITY12:
      case GL_INTENSITY16:
         return (ctx->API != API_OPENGL_CORE) ? GL_INTENSITY : -1;
      case 3:
         return (ctx->API != API_OPENGL_CORE) ? GL_RGB : -1;
      case GL_RGB:
      case GL_R3_G3_B2:
      case GL_RGB4:
      case GL_RGB5:
      case GL_RGB8:
      case GL_RGB10:
      case GL_RGB12:
      case GL_RGB16:
         return GL_RGB;
      case 4:
         return (ctx->API != API_OPENGL_CORE) ? GL_RGBA : -1;
      case GL_RGBA:
      case GL_RGBA2:
      case GL_RGBA4:
      case GL_RGB5_A1:
      case GL_RGBA8:
      case GL_RGB10_A2:
      case GL_RGBA12:
      case GL_RGBA16:
         return GL_RGBA;
      default:
         ; /* fallthrough */
   }

   /* GL_BGRA can be an internal format *only* in OpenGL ES (1.x or 2.0).
    */
   if (_mesa_is_gles(ctx)) {
      switch (internalFormat) {
         case GL_BGRA:
            return GL_RGBA;
         default:
            ; /* fallthrough */
      }
   }

   if (ctx->Extensions.ARB_ES2_compatibility) {
      switch (internalFormat) {
         case GL_RGB565:
            return GL_RGB;
         default:
            ; /* fallthrough */
      }
   }

   if (ctx->Extensions.ARB_depth_texture) {
      switch (internalFormat) {
         case GL_DEPTH_COMPONENT:
         case GL_DEPTH_COMPONENT16:
         case GL_DEPTH_COMPONENT24:
         case GL_DEPTH_COMPONENT32:
            return GL_DEPTH_COMPONENT;
         case GL_DEPTH_STENCIL:
         case GL_DEPTH24_STENCIL8:
            return GL_DEPTH_STENCIL;
         default:
            ; /* fallthrough */
      }
   }

   switch (internalFormat) {
   case GL_COMPRESSED_ALPHA:
      return GL_ALPHA;
   case GL_COMPRESSED_LUMINANCE:
      return GL_LUMINANCE;
   case GL_COMPRESSED_LUMINANCE_ALPHA:
      return GL_LUMINANCE_ALPHA;
   case GL_COMPRESSED_INTENSITY:
      return GL_INTENSITY;
   case GL_COMPRESSED_RGB:
      return GL_RGB;
   case GL_COMPRESSED_RGBA:
      return GL_RGBA;
   default:
      ; /* fallthrough */
   }

   if (ctx->Extensions.TDFX_texture_compression_FXT1) {
      switch (internalFormat) {
         case GL_COMPRESSED_RGB_FXT1_3DFX:
            return GL_RGB;
         case GL_COMPRESSED_RGBA_FXT1_3DFX:
            return GL_RGBA;
         default:
            ; /* fallthrough */
      }
   }

   /* Assume that the ANGLE flag will always be set if the EXT flag is set.
    */
   if (ctx->Extensions.ANGLE_texture_compression_dxt) {
      switch (internalFormat) {
         case GL_COMPRESSED_RGB_S3TC_DXT1_EXT:
            return GL_RGB;
         case GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:
         case GL_COMPRESSED_RGBA_S3TC_DXT3_EXT:
         case GL_COMPRESSED_RGBA_S3TC_DXT5_EXT:
            return GL_RGBA;
         default:
            ; /* fallthrough */
      }
   }

   if (_mesa_is_desktop_gl(ctx)
       && ctx->Extensions.ANGLE_texture_compression_dxt) {
      switch (internalFormat) {
         case GL_RGB_S3TC:
         case GL_RGB4_S3TC:
            return GL_RGB;
         case GL_RGBA_S3TC:
         case GL_RGBA4_S3TC:
            return GL_RGBA;
         default:
            ; /* fallthrough */
      }
   }

   if (ctx->Extensions.MESA_ycbcr_texture) {
      if (internalFormat == GL_YCBCR_MESA)
         return GL_YCBCR_MESA;
   }

   if (ctx->Extensions.ARB_texture_float) {
      switch (internalFormat) {
         case GL_ALPHA16F_ARB:
         case GL_ALPHA32F_ARB:
            return GL_ALPHA;
         case GL_RGBA16F_ARB:
         case GL_RGBA32F_ARB:
            return GL_RGBA;
         case GL_RGB16F_ARB:
         case GL_RGB32F_ARB:
            return GL_RGB;
         case GL_INTENSITY16F_ARB:
         case GL_INTENSITY32F_ARB:
            return GL_INTENSITY;
         case GL_LUMINANCE16F_ARB:
         case GL_LUMINANCE32F_ARB:
            return GL_LUMINANCE;
         case GL_LUMINANCE_ALPHA16F_ARB:
         case GL_LUMINANCE_ALPHA32F_ARB:
            return GL_LUMINANCE_ALPHA;
         default:
            ; /* fallthrough */
      }
   }

   if (ctx->Extensions.ATI_envmap_bumpmap) {
      switch (internalFormat) {
         case GL_DUDV_ATI:
         case GL_DU8DV8_ATI:
            return GL_DUDV_ATI;
         default:
            ; /* fallthrough */
      }
   }

   if (ctx->Extensions.EXT_texture_snorm) {
      switch (internalFormat) {
         case GL_RED_SNORM:
         case GL_R8_SNORM:
         case GL_R16_SNORM:
            return GL_RED;
         case GL_RG_SNORM:
         case GL_RG8_SNORM:
         case GL_RG16_SNORM:
            return GL_RG;
         case GL_RGB_SNORM:
         case GL_RGB8_SNORM:
         case GL_RGB16_SNORM:
            return GL_RGB;
         case GL_RGBA_SNORM:
         case GL_RGBA8_SNORM:
         case GL_RGBA16_SNORM:
            return GL_RGBA;
         case GL_ALPHA_SNORM:
         case GL_ALPHA8_SNORM:
         case GL_ALPHA16_SNORM:
            return GL_ALPHA;
         case GL_LUMINANCE_SNORM:
         case GL_LUMINANCE8_SNORM:
         case GL_LUMINANCE16_SNORM:
            return GL_LUMINANCE;
         case GL_LUMINANCE_ALPHA_SNORM:
         case GL_LUMINANCE8_ALPHA8_SNORM:
         case GL_LUMINANCE16_ALPHA16_SNORM:
            return GL_LUMINANCE_ALPHA;
         case GL_INTENSITY_SNORM:
         case GL_INTENSITY8_SNORM:
         case GL_INTENSITY16_SNORM:
            return GL_INTENSITY;
         default:
            ; /* fallthrough */
      }
   }

   if (ctx->Extensions.EXT_texture_sRGB) {
      switch (internalFormat) {
      case GL_SRGB_EXT:
      case GL_SRGB8_EXT:
      case GL_COMPRESSED_SRGB_EXT:
         return GL_RGB;
      case GL_COMPRESSED_SRGB_S3TC_DXT1_EXT:
         return ctx->Extensions.EXT_texture_compression_s3tc ? GL_RGB : -1;
      case GL_SRGB_ALPHA_EXT:
      case GL_SRGB8_ALPHA8_EXT:
      case GL_COMPRESSED_SRGB_ALPHA_EXT:
         return GL_RGBA;
      case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:
      case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:
      case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:
         return ctx->Extensions.EXT_texture_compression_s3tc ? GL_RGBA : -1;
      case GL_SLUMINANCE_ALPHA_EXT:
      case GL_SLUMINANCE8_ALPHA8_EXT:
      case GL_COMPRESSED_SLUMINANCE_ALPHA_EXT:
         return GL_LUMINANCE_ALPHA;
      case GL_SLUMINANCE_EXT:
      case GL_SLUMINANCE8_EXT:
      case GL_COMPRESSED_SLUMINANCE_EXT:
         return GL_LUMINANCE;
      default:
         ; /* fallthrough */
      }
   }

   if (ctx->Version >= 30 ||
       ctx->Extensions.EXT_texture_integer) {
      switch (internalFormat) {
      case GL_RGBA8UI_EXT:
      case GL_RGBA16UI_EXT:
      case GL_RGBA32UI_EXT:
      case GL_RGBA8I_EXT:
      case GL_RGBA16I_EXT:
      case GL_RGBA32I_EXT:
      case GL_RGB10_A2UI:
         return GL_RGBA;
      case GL_RGB8UI_EXT:
      case GL_RGB16UI_EXT:
      case GL_RGB32UI_EXT:
      case GL_RGB8I_EXT:
      case GL_RGB16I_EXT:
      case GL_RGB32I_EXT:
         return GL_RGB;
      }
   }

   if (ctx->Extensions.EXT_texture_integer) {
      switch (internalFormat) {
      case GL_ALPHA8UI_EXT:
      case GL_ALPHA16UI_EXT:
      case GL_ALPHA32UI_EXT:
      case GL_ALPHA8I_EXT:
      case GL_ALPHA16I_EXT:
      case GL_ALPHA32I_EXT:
         return GL_ALPHA;
      case GL_INTENSITY8UI_EXT:
      case GL_INTENSITY16UI_EXT:
      case GL_INTENSITY32UI_EXT:
      case GL_INTENSITY8I_EXT:
      case GL_INTENSITY16I_EXT:
      case GL_INTENSITY32I_EXT:
         return GL_INTENSITY;
      case GL_LUMINANCE8UI_EXT:
      case GL_LUMINANCE16UI_EXT:
      case GL_LUMINANCE32UI_EXT:
      case GL_LUMINANCE8I_EXT:
      case GL_LUMINANCE16I_EXT:
      case GL_LUMINANCE32I_EXT:
         return GL_LUMINANCE;
      case GL_LUMINANCE_ALPHA8UI_EXT:
      case GL_LUMINANCE_ALPHA16UI_EXT:
      case GL_LUMINANCE_ALPHA32UI_EXT:
      case GL_LUMINANCE_ALPHA8I_EXT:
      case GL_LUMINANCE_ALPHA16I_EXT:
      case GL_LUMINANCE_ALPHA32I_EXT:
         return GL_LUMINANCE_ALPHA;
      default:
         ; /* fallthrough */
      }
   }

   if (ctx->Extensions.ARB_texture_rg) {
      switch (internalFormat) {
      case GL_R16F:
      case GL_R32F:
	 if (!ctx->Extensions.ARB_texture_float)
	    break;
         return GL_RED;
      case GL_R8I:
      case GL_R8UI:
      case GL_R16I:
      case GL_R16UI:
      case GL_R32I:
      case GL_R32UI:
	 if (ctx->Version < 30 && !ctx->Extensions.EXT_texture_integer)
	    break;
	 /* FALLTHROUGH */
      case GL_R8:
      case GL_R16:
      case GL_RED:
      case GL_COMPRESSED_RED:
         return GL_RED;

      case GL_RG16F:
      case GL_RG32F:
	 if (!ctx->Extensions.ARB_texture_float)
	    break;
         return GL_RG;
      case GL_RG8I:
      case GL_RG8UI:
      case GL_RG16I:
      case GL_RG16UI:
      case GL_RG32I:
      case GL_RG32UI:
	 if (ctx->Version < 30 && !ctx->Extensions.EXT_texture_integer)
	    break;
	 /* FALLTHROUGH */
      case GL_RG:
      case GL_RG8:
      case GL_RG16:
      case GL_COMPRESSED_RG:
         return GL_RG;
      default:
         ; /* fallthrough */
      }
   }

   if (ctx->Extensions.EXT_texture_shared_exponent) {
      switch (internalFormat) {
      case GL_RGB9_E5_EXT:
         return GL_RGB;
      default:
         ; /* fallthrough */
      }
   }

   if (ctx->Extensions.EXT_packed_float) {
      switch (internalFormat) {
      case GL_R11F_G11F_B10F_EXT:
         return GL_RGB;
      default:
         ; /* fallthrough */
      }
   }

   if (ctx->Extensions.ARB_depth_buffer_float) {
      switch (internalFormat) {
      case GL_DEPTH_COMPONENT32F:
         return GL_DEPTH_COMPONENT;
      case GL_DEPTH32F_STENCIL8:
         return GL_DEPTH_STENCIL;
      default:
         ; /* fallthrough */
      }
   }

   if (ctx->Extensions.ARB_texture_compression_rgtc) {
      switch (internalFormat) {
      case GL_COMPRESSED_RED_RGTC1:
      case GL_COMPRESSED_SIGNED_RED_RGTC1:
         return GL_RED;
      case GL_COMPRESSED_RG_RGTC2:
      case GL_COMPRESSED_SIGNED_RG_RGTC2:
         return GL_RG;
      default:
         ; /* fallthrough */
      }
   }

   if (ctx->Extensions.EXT_texture_compression_latc) {
      switch (internalFormat) {
      case GL_COMPRESSED_LUMINANCE_LATC1_EXT:
      case GL_COMPRESSED_SIGNED_LUMINANCE_LATC1_EXT:
         return GL_LUMINANCE;
      case GL_COMPRESSED_LUMINANCE_ALPHA_LATC2_EXT:
      case GL_COMPRESSED_SIGNED_LUMINANCE_ALPHA_LATC2_EXT:
         return GL_LUMINANCE_ALPHA;
      default:
         ; /* fallthrough */
      }
   }

   if (ctx->Extensions.ATI_texture_compression_3dc) {
      switch (internalFormat) {
      case GL_COMPRESSED_LUMINANCE_ALPHA_3DC_ATI:
         return GL_LUMINANCE_ALPHA;
      default:
         ; /* fallthrough */
      }
   }

   if (ctx->Extensions.OES_compressed_ETC1_RGB8_texture) {
      switch (internalFormat) {
      case GL_ETC1_RGB8_OES:
         return GL_RGB;
      default:
         ; /* fallthrough */
      }
   }

   if (_mesa_is_gles3(ctx) || ctx->Extensions.ARB_ES3_compatibility) {
      switch (internalFormat) {
      case GL_COMPRESSED_RGB8_ETC2:
      case GL_COMPRESSED_SRGB8_ETC2:
         return GL_RGB;
      case GL_COMPRESSED_RGBA8_ETC2_EAC:
      case GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:
      case GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:
      case GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:
         return GL_RGBA;
      case GL_COMPRESSED_R11_EAC:
      case GL_COMPRESSED_SIGNED_R11_EAC:
         return GL_RED;
      case GL_COMPRESSED_RG11_EAC:
      case GL_COMPRESSED_SIGNED_RG11_EAC:
         return GL_RG;
      default:
         ; /* fallthrough */
      }
   }

   if (ctx->API == API_OPENGLES) {
      switch (internalFormat) {
      case GL_PALETTE4_RGB8_OES:
      case GL_PALETTE4_R5_G6_B5_OES:
      case GL_PALETTE8_RGB8_OES:
      case GL_PALETTE8_R5_G6_B5_OES:
	 return GL_RGB;
      case GL_PALETTE4_RGBA8_OES:
      case GL_PALETTE8_RGB5_A1_OES:
      case GL_PALETTE4_RGBA4_OES:
      case GL_PALETTE4_RGB5_A1_OES:
      case GL_PALETTE8_RGBA8_OES:
      case GL_PALETTE8_RGBA4_OES:
	 return GL_RGBA;
      default:
         ; /* fallthrough */
      }
   }

   return -1; /* error */
}


/**
 * For cube map faces, return a face index in [0,5].
 * For other targets return 0;
 */
GLuint
_mesa_tex_target_to_face(GLenum target)
{
   if (_mesa_is_cube_face(target))
      return (GLuint) target - (GLuint) GL_TEXTURE_CUBE_MAP_POSITIVE_X;
   else
      return 0;
}



/**
 * Install gl_texture_image in a gl_texture_object according to the target
 * and level parameters.
 * 
 * \param tObj texture object.
 * \param target texture target.
 * \param level image level.
 * \param texImage texture image.
 */
static void
set_tex_image(struct gl_texture_object *tObj,
              GLenum target, GLint level,
              struct gl_texture_image *texImage)
{
   const GLuint face = _mesa_tex_target_to_face(target);

   ASSERT(tObj);
   ASSERT(texImage);
   if (target == GL_TEXTURE_RECTANGLE_NV || target == GL_TEXTURE_EXTERNAL_OES)
      assert(level == 0);

   tObj->Image[face][level] = texImage;

   /* Set the 'back' pointer */
   texImage->TexObject = tObj;
   texImage->Level = level;
   texImage->Face = face;
}


/**
 * Allocate a texture image structure.
 *
 * Called via ctx->Driver.NewTextureImage() unless overriden by a device
 * driver.
 *
 * \return a pointer to gl_texture_image struct with all fields initialized to
 * zero.
 */
struct gl_texture_image *
_mesa_new_texture_image( struct gl_context *ctx )
{
   (void) ctx;
   return CALLOC_STRUCT(gl_texture_image);
}


/**
 * Free a gl_texture_image and associated data.
 * This function is a fallback called via ctx->Driver.DeleteTextureImage().
 *
 * \param texImage texture image.
 *
 * Free the texture image structure and the associated image data.
 */
void
_mesa_delete_texture_image(struct gl_context *ctx,
                           struct gl_texture_image *texImage)
{
   /* Free texImage->Data and/or any other driver-specific texture
    * image storage.
    */
   ASSERT(ctx->Driver.FreeTextureImageBuffer);
   ctx->Driver.FreeTextureImageBuffer( ctx, texImage );
   free(texImage);
}


/**
 * Test if a target is a proxy target.
 *
 * \param target texture target.
 *
 * \return GL_TRUE if the target is a proxy target, GL_FALSE otherwise.
 */
GLboolean
_mesa_is_proxy_texture(GLenum target)
{
   unsigned i;
   static const GLenum targets[] = {
      GL_PROXY_TEXTURE_1D,
      GL_PROXY_TEXTURE_2D,
      GL_PROXY_TEXTURE_3D,
      GL_PROXY_TEXTURE_CUBE_MAP,
      GL_PROXY_TEXTURE_RECTANGLE,
      GL_PROXY_TEXTURE_1D_ARRAY,
      GL_PROXY_TEXTURE_2D_ARRAY,
      GL_PROXY_TEXTURE_CUBE_MAP_ARRAY,
      GL_PROXY_TEXTURE_2D_MULTISAMPLE,
      GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY
   };
   /*
    * NUM_TEXTURE_TARGETS should match number of terms above, except there's no
    * proxy for GL_TEXTURE_BUFFER and GL_TEXTURE_EXTERNAL_OES.
    */
   STATIC_ASSERT(NUM_TEXTURE_TARGETS == Elements(targets) + 2);

   for (i = 0; i < Elements(targets); ++i)
      if (target == targets[i])
         return GL_TRUE;
   return GL_FALSE;
}


/**
 * Return the proxy target which corresponds to the given texture target
 */
static GLenum
proxy_target(GLenum target)
{
   switch (target) {
   case GL_TEXTURE_1D:
   case GL_PROXY_TEXTURE_1D:
      return GL_PROXY_TEXTURE_1D;
   case GL_TEXTURE_2D:
   case GL_PROXY_TEXTURE_2D:
      return GL_PROXY_TEXTURE_2D;
   case GL_TEXTURE_3D:
   case GL_PROXY_TEXTURE_3D:
      return GL_PROXY_TEXTURE_3D;
   case GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB:
   case GL_TEXTURE_CUBE_MAP_ARB:
   case GL_PROXY_TEXTURE_CUBE_MAP_ARB:
      return GL_PROXY_TEXTURE_CUBE_MAP_ARB;
   case GL_TEXTURE_RECTANGLE_NV:
   case GL_PROXY_TEXTURE_RECTANGLE_NV:
      return GL_PROXY_TEXTURE_RECTANGLE_NV;
   case GL_TEXTURE_1D_ARRAY_EXT:
   case GL_PROXY_TEXTURE_1D_ARRAY_EXT:
      return GL_PROXY_TEXTURE_1D_ARRAY_EXT;
   case GL_TEXTURE_2D_ARRAY_EXT:
   case GL_PROXY_TEXTURE_2D_ARRAY_EXT:
      return GL_PROXY_TEXTURE_2D_ARRAY_EXT;
   case GL_TEXTURE_CUBE_MAP_ARRAY:
   case GL_PROXY_TEXTURE_CUBE_MAP_ARRAY:
      return GL_PROXY_TEXTURE_CUBE_MAP_ARRAY;
   case GL_TEXTURE_2D_MULTISAMPLE:
   case GL_PROXY_TEXTURE_2D_MULTISAMPLE:
      return GL_PROXY_TEXTURE_2D_MULTISAMPLE;
   case GL_TEXTURE_2D_MULTISAMPLE_ARRAY:
   case GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY:
      return GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY;
   default:
      _mesa_problem(NULL, "unexpected target in proxy_target()");
      return 0;
   }
}


/**
 * Return a pointer to the current texture object for the given target
 * on the current texture unit.
 * Note: all <target> error checking should have been done by this point.
 */
struct gl_texture_object *
_mesa_get_current_tex_object(struct gl_context *ctx, GLenum target)
{
   struct gl_texture_unit *texUnit = _mesa_get_current_tex_unit(ctx);
   const GLboolean arrayTex = ctx->Extensions.EXT_texture_array;

   switch (target) {
      case GL_TEXTURE_1D:
         return texUnit->CurrentTex[TEXTURE_1D_INDEX];
      case GL_PROXY_TEXTURE_1D:
         return ctx->Texture.ProxyTex[TEXTURE_1D_INDEX];
      case GL_TEXTURE_2D:
         return texUnit->CurrentTex[TEXTURE_2D_INDEX];
      case GL_PROXY_TEXTURE_2D:
         return ctx->Texture.ProxyTex[TEXTURE_2D_INDEX];
      case GL_TEXTURE_3D:
         return texUnit->CurrentTex[TEXTURE_3D_INDEX];
      case GL_PROXY_TEXTURE_3D:
         return ctx->Texture.ProxyTex[TEXTURE_3D_INDEX];
      case GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB:
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB:
      case GL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB:
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB:
      case GL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB:
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB:
      case GL_TEXTURE_CUBE_MAP_ARB:
         return ctx->Extensions.ARB_texture_cube_map
                ? texUnit->CurrentTex[TEXTURE_CUBE_INDEX] : NULL;
      case GL_PROXY_TEXTURE_CUBE_MAP_ARB:
         return ctx->Extensions.ARB_texture_cube_map
                ? ctx->Texture.ProxyTex[TEXTURE_CUBE_INDEX] : NULL;
      case GL_TEXTURE_CUBE_MAP_ARRAY:
         return ctx->Extensions.ARB_texture_cube_map_array
                ? texUnit->CurrentTex[TEXTURE_CUBE_ARRAY_INDEX] : NULL;
      case GL_PROXY_TEXTURE_CUBE_MAP_ARRAY:
         return ctx->Extensions.ARB_texture_cube_map_array
                ? ctx->Texture.ProxyTex[TEXTURE_CUBE_ARRAY_INDEX] : NULL;
      case GL_TEXTURE_RECTANGLE_NV:
         return ctx->Extensions.NV_texture_rectangle
                ? texUnit->CurrentTex[TEXTURE_RECT_INDEX] : NULL;
      case GL_PROXY_TEXTURE_RECTANGLE_NV:
         return ctx->Extensions.NV_texture_rectangle
                ? ctx->Texture.ProxyTex[TEXTURE_RECT_INDEX] : NULL;
      case GL_TEXTURE_1D_ARRAY_EXT:
         return arrayTex ? texUnit->CurrentTex[TEXTURE_1D_ARRAY_INDEX] : NULL;
      case GL_PROXY_TEXTURE_1D_ARRAY_EXT:
         return arrayTex ? ctx->Texture.ProxyTex[TEXTURE_1D_ARRAY_INDEX] : NULL;
      case GL_TEXTURE_2D_ARRAY_EXT:
         return arrayTex ? texUnit->CurrentTex[TEXTURE_2D_ARRAY_INDEX] : NULL;
      case GL_PROXY_TEXTURE_2D_ARRAY_EXT:
         return arrayTex ? ctx->Texture.ProxyTex[TEXTURE_2D_ARRAY_INDEX] : NULL;
      case GL_TEXTURE_BUFFER:
         return ctx->API == API_OPENGL_CORE &&
                ctx->Extensions.ARB_texture_buffer_object ?
                texUnit->CurrentTex[TEXTURE_BUFFER_INDEX] : NULL;
      case GL_TEXTURE_EXTERNAL_OES:
         return _mesa_is_gles(ctx) && ctx->Extensions.OES_EGL_image_external
            ? texUnit->CurrentTex[TEXTURE_EXTERNAL_INDEX] : NULL;
      case GL_TEXTURE_2D_MULTISAMPLE:
         return ctx->Extensions.ARB_texture_multisample
            ? texUnit->CurrentTex[TEXTURE_2D_MULTISAMPLE_INDEX] : NULL;
      case GL_PROXY_TEXTURE_2D_MULTISAMPLE:
         return ctx->Extensions.ARB_texture_multisample
            ? ctx->Texture.ProxyTex[TEXTURE_2D_MULTISAMPLE_INDEX] : NULL;
      case GL_TEXTURE_2D_MULTISAMPLE_ARRAY:
         return ctx->Extensions.ARB_texture_multisample
            ? texUnit->CurrentTex[TEXTURE_2D_MULTISAMPLE_ARRAY_INDEX] : NULL;
      case GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY:
         return ctx->Extensions.ARB_texture_multisample
            ? ctx->Texture.ProxyTex[TEXTURE_2D_MULTISAMPLE_ARRAY_INDEX] : NULL;
      default:
         _mesa_problem(NULL, "bad target in _mesa_get_current_tex_object()");
         return NULL;
   }
}



/**
 * Get a texture image pointer from a texture object, given a texture
 * target and mipmap level.  The target and level parameters should
 * have already been error-checked.
 *
 * \param ctx GL context.
 * \param texObj texture unit.
 * \param target texture target.
 * \param level image level.
 *
 * \return pointer to the texture image structure, or NULL on failure.
 */
struct gl_texture_image *
_mesa_select_tex_image(struct gl_context *ctx,
                       const struct gl_texture_object *texObj,
		       GLenum target, GLint level)
{
   const GLuint face = _mesa_tex_target_to_face(target);

   ASSERT(texObj);
   ASSERT(level >= 0);
   ASSERT(level < MAX_TEXTURE_LEVELS);

   return texObj->Image[face][level];
}


/**
 * Like _mesa_select_tex_image() but if the image doesn't exist, allocate
 * it and install it.  Only return NULL if passed a bad parameter or run
 * out of memory.
 */
struct gl_texture_image *
_mesa_get_tex_image(struct gl_context *ctx, struct gl_texture_object *texObj,
                    GLenum target, GLint level)
{
   struct gl_texture_image *texImage;

   if (!texObj)
      return NULL;

   texImage = _mesa_select_tex_image(ctx, texObj, target, level);
   if (!texImage) {
      texImage = ctx->Driver.NewTextureImage(ctx);
      if (!texImage) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "texture image allocation");
         return NULL;
      }

      set_tex_image(texObj, target, level, texImage);
   }

   return texImage;
}


/**
 * Return pointer to the specified proxy texture image.
 * Note that proxy textures are per-context, not per-texture unit.
 * \return pointer to texture image or NULL if invalid target, invalid
 *         level, or out of memory.
 */
static struct gl_texture_image *
get_proxy_tex_image(struct gl_context *ctx, GLenum target, GLint level)
{
   struct gl_texture_image *texImage;
   GLuint texIndex;

   if (level < 0)
      return NULL;

   switch (target) {
   case GL_PROXY_TEXTURE_1D:
      if (level >= ctx->Const.MaxTextureLevels)
         return NULL;
      texIndex = TEXTURE_1D_INDEX;
      break;
   case GL_PROXY_TEXTURE_2D:
      if (level >= ctx->Const.MaxTextureLevels)
         return NULL;
      texIndex = TEXTURE_2D_INDEX;
      break;
   case GL_PROXY_TEXTURE_3D:
      if (level >= ctx->Const.Max3DTextureLevels)
         return NULL;
      texIndex = TEXTURE_3D_INDEX;
      break;
   case GL_PROXY_TEXTURE_CUBE_MAP:
      if (level >= ctx->Const.MaxCubeTextureLevels)
         return NULL;
      texIndex = TEXTURE_CUBE_INDEX;
      break;
   case GL_PROXY_TEXTURE_RECTANGLE_NV:
      if (level > 0)
         return NULL;
      texIndex = TEXTURE_RECT_INDEX;
      break;
   case GL_PROXY_TEXTURE_1D_ARRAY_EXT:
      if (level >= ctx->Const.MaxTextureLevels)
         return NULL;
      texIndex = TEXTURE_1D_ARRAY_INDEX;
      break;
   case GL_PROXY_TEXTURE_2D_ARRAY_EXT:
      if (level >= ctx->Const.MaxTextureLevels)
         return NULL;
      texIndex = TEXTURE_2D_ARRAY_INDEX;
      break;
   case GL_PROXY_TEXTURE_CUBE_MAP_ARRAY:
      if (level >= ctx->Const.MaxCubeTextureLevels)
         return NULL;
      texIndex = TEXTURE_CUBE_ARRAY_INDEX;
      break;
   case GL_PROXY_TEXTURE_2D_MULTISAMPLE:
      if (level > 0)
         return 0;
      texIndex = TEXTURE_2D_MULTISAMPLE_INDEX;
      break;
   case GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY:
      if (level > 0)
         return 0;
      texIndex = TEXTURE_2D_MULTISAMPLE_ARRAY_INDEX;
      break;
   default:
      return NULL;
   }

   texImage = ctx->Texture.ProxyTex[texIndex]->Image[0][level];
   if (!texImage) {
      texImage = ctx->Driver.NewTextureImage(ctx);
      if (!texImage) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "proxy texture allocation");
         return NULL;
      }
      ctx->Texture.ProxyTex[texIndex]->Image[0][level] = texImage;
      /* Set the 'back' pointer */
      texImage->TexObject = ctx->Texture.ProxyTex[texIndex];
   }
   return texImage;
}


/**
 * Get the maximum number of allowed mipmap levels.
 *
 * \param ctx GL context.
 * \param target texture target.
 *
 * \return the maximum number of allowed mipmap levels for the given
 * texture target, or zero if passed a bad target.
 *
 * \sa gl_constants.
 */
GLint
_mesa_max_texture_levels(struct gl_context *ctx, GLenum target)
{
   switch (target) {
   case GL_TEXTURE_1D:
   case GL_PROXY_TEXTURE_1D:
   case GL_TEXTURE_2D:
   case GL_PROXY_TEXTURE_2D:
      return ctx->Const.MaxTextureLevels;
   case GL_TEXTURE_3D:
   case GL_PROXY_TEXTURE_3D:
      return ctx->Const.Max3DTextureLevels;
   case GL_TEXTURE_CUBE_MAP:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB:
   case GL_PROXY_TEXTURE_CUBE_MAP_ARB:
      return ctx->Extensions.ARB_texture_cube_map
         ? ctx->Const.MaxCubeTextureLevels : 0;
   case GL_TEXTURE_RECTANGLE_NV:
   case GL_PROXY_TEXTURE_RECTANGLE_NV:
      return ctx->Extensions.NV_texture_rectangle ? 1 : 0;
   case GL_TEXTURE_1D_ARRAY_EXT:
   case GL_PROXY_TEXTURE_1D_ARRAY_EXT:
   case GL_TEXTURE_2D_ARRAY_EXT:
   case GL_PROXY_TEXTURE_2D_ARRAY_EXT:
      return ctx->Extensions.EXT_texture_array
         ? ctx->Const.MaxTextureLevels : 0;
   case GL_TEXTURE_CUBE_MAP_ARRAY:
   case GL_PROXY_TEXTURE_CUBE_MAP_ARRAY:
      return ctx->Extensions.ARB_texture_cube_map_array
         ? ctx->Const.MaxCubeTextureLevels : 0;
   case GL_TEXTURE_BUFFER:
      return ctx->API == API_OPENGL_CORE &&
             ctx->Extensions.ARB_texture_buffer_object ? 1 : 0;
   case GL_TEXTURE_2D_MULTISAMPLE:
   case GL_PROXY_TEXTURE_2D_MULTISAMPLE:
   case GL_TEXTURE_2D_MULTISAMPLE_ARRAY:
   case GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY:
      return _mesa_is_desktop_gl(ctx)
         && ctx->Extensions.ARB_texture_multisample
         ? 1 : 0;
   case GL_TEXTURE_EXTERNAL_OES:
      /* fall-through */
   default:
      return 0; /* bad target */
   }
}


/**
 * Return number of dimensions per mipmap level for the given texture target.
 */
GLint
_mesa_get_texture_dimensions(GLenum target)
{
   switch (target) {
   case GL_TEXTURE_1D:
   case GL_PROXY_TEXTURE_1D:
      return 1;
   case GL_TEXTURE_2D:
   case GL_TEXTURE_RECTANGLE:
   case GL_TEXTURE_CUBE_MAP:
   case GL_PROXY_TEXTURE_2D:
   case GL_PROXY_TEXTURE_RECTANGLE:
   case GL_PROXY_TEXTURE_CUBE_MAP:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
   case GL_TEXTURE_1D_ARRAY:
   case GL_PROXY_TEXTURE_1D_ARRAY:
   case GL_TEXTURE_EXTERNAL_OES:
   case GL_TEXTURE_2D_MULTISAMPLE:
   case GL_PROXY_TEXTURE_2D_MULTISAMPLE:
      return 2;
   case GL_TEXTURE_3D:
   case GL_PROXY_TEXTURE_3D:
   case GL_TEXTURE_2D_ARRAY:
   case GL_PROXY_TEXTURE_2D_ARRAY:
   case GL_TEXTURE_CUBE_MAP_ARRAY:
   case GL_PROXY_TEXTURE_CUBE_MAP_ARRAY:
   case GL_TEXTURE_2D_MULTISAMPLE_ARRAY:
   case GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY:
      return 3;
   case GL_TEXTURE_BUFFER:
      /* fall-through */
   default:
      _mesa_problem(NULL, "invalid target 0x%x in get_texture_dimensions()",
                    target);
      return 2;
   }
}


/**
 * Check if a texture target can have more than one layer.
 */
GLboolean
_mesa_tex_target_is_layered(GLenum target)
{
   switch (target) {
   case GL_TEXTURE_1D:
   case GL_PROXY_TEXTURE_1D:
   case GL_TEXTURE_2D:
   case GL_PROXY_TEXTURE_2D:
   case GL_TEXTURE_RECTANGLE:
   case GL_PROXY_TEXTURE_RECTANGLE:
   case GL_TEXTURE_2D_MULTISAMPLE:
   case GL_PROXY_TEXTURE_2D_MULTISAMPLE:
   case GL_TEXTURE_BUFFER:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
   case GL_TEXTURE_EXTERNAL_OES:
      return GL_FALSE;

   case GL_TEXTURE_3D:
   case GL_PROXY_TEXTURE_3D:
   case GL_TEXTURE_CUBE_MAP:
   case GL_PROXY_TEXTURE_CUBE_MAP:
   case GL_TEXTURE_1D_ARRAY:
   case GL_PROXY_TEXTURE_1D_ARRAY:
   case GL_TEXTURE_2D_ARRAY:
   case GL_PROXY_TEXTURE_2D_ARRAY:
   case GL_TEXTURE_CUBE_MAP_ARRAY:
   case GL_PROXY_TEXTURE_CUBE_MAP_ARRAY:
   case GL_TEXTURE_2D_MULTISAMPLE_ARRAY:
   case GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY:
      return GL_TRUE;

   default:
      assert(!"Invalid texture target.");
      return GL_FALSE;
   }
}


/**
 * Return the number of layers present in the given level of an array,
 * cubemap or 3D texture.  If the texture is not layered return zero.
 */
GLuint
_mesa_get_texture_layers(const struct gl_texture_object *texObj, GLint level)
{
   assert(level >= 0 && level < MAX_TEXTURE_LEVELS);

   switch (texObj->Target) {
   case GL_TEXTURE_1D:
   case GL_TEXTURE_2D:
   case GL_TEXTURE_RECTANGLE:
   case GL_TEXTURE_2D_MULTISAMPLE:
   case GL_TEXTURE_BUFFER:
   case GL_TEXTURE_EXTERNAL_OES:
      return 0;

   case GL_TEXTURE_CUBE_MAP:
      return 6;

   case GL_TEXTURE_1D_ARRAY: {
      struct gl_texture_image *img = texObj->Image[0][level];
      return img ? img->Height : 0;
   }

   case GL_TEXTURE_3D:
   case GL_TEXTURE_2D_ARRAY:
   case GL_TEXTURE_CUBE_MAP_ARRAY:
   case GL_TEXTURE_2D_MULTISAMPLE_ARRAY: {
      struct gl_texture_image *img = texObj->Image[0][level];
      return img ? img->Depth : 0;
   }

   default:
      assert(!"Invalid texture target.");
      return 0;
   }
}


/**
 * Return the maximum number of mipmap levels for the given target
 * and the dimensions.
 * The dimensions are expected not to include the border.
 */
GLsizei
_mesa_get_tex_max_num_levels(GLenum target, GLsizei width, GLsizei height,
                             GLsizei depth)
{
   GLsizei size;

   switch (target) {
   case GL_TEXTURE_1D:
   case GL_TEXTURE_1D_ARRAY:
   case GL_PROXY_TEXTURE_1D:
   case GL_PROXY_TEXTURE_1D_ARRAY:
      size = width;
      break;
   case GL_TEXTURE_CUBE_MAP:
   case GL_TEXTURE_CUBE_MAP_ARRAY:
   case GL_PROXY_TEXTURE_CUBE_MAP:
   case GL_PROXY_TEXTURE_CUBE_MAP_ARRAY:
      size = width;
      break;
   case GL_TEXTURE_2D:
   case GL_TEXTURE_2D_ARRAY:
   case GL_PROXY_TEXTURE_2D:
   case GL_PROXY_TEXTURE_2D_ARRAY:
      size = MAX2(width, height);
      break;
   case GL_TEXTURE_3D:
   case GL_PROXY_TEXTURE_3D:
      size = MAX3(width, height, depth);
      break;
   case GL_TEXTURE_RECTANGLE:
   case GL_TEXTURE_EXTERNAL_OES:
   case GL_TEXTURE_2D_MULTISAMPLE:
   case GL_TEXTURE_2D_MULTISAMPLE_ARRAY:
   case GL_PROXY_TEXTURE_RECTANGLE:
   case GL_PROXY_TEXTURE_2D_MULTISAMPLE:
   case GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY:
      return 1;
   default:
      assert(0);
      return 1;
   }

   return _mesa_logbase2(size) + 1;
}


#if 000 /* not used anymore */
/*
 * glTexImage[123]D can accept a NULL image pointer.  In this case we
 * create a texture image with unspecified image contents per the OpenGL
 * spec.
 */
static GLubyte *
make_null_texture(GLint width, GLint height, GLint depth, GLenum format)
{
   const GLint components = _mesa_components_in_format(format);
   const GLint numPixels = width * height * depth;
   GLubyte *data = (GLubyte *) malloc(numPixels * components * sizeof(GLubyte));

#ifdef DEBUG
   /*
    * Let's see if anyone finds this.  If glTexImage2D() is called with
    * a NULL image pointer then load the texture image with something
    * interesting instead of leaving it indeterminate.
    */
   if (data) {
      static const char message[8][32] = {
         "   X   X  XXXXX   XXX     X    ",
         "   XX XX  X      X   X   X X   ",
         "   X X X  X      X      X   X  ",
         "   X   X  XXXX    XXX   XXXXX  ",
         "   X   X  X          X  X   X  ",
         "   X   X  X      X   X  X   X  ",
         "   X   X  XXXXX   XXX   X   X  ",
         "                               "
      };

      GLubyte *imgPtr = data;
      GLint h, i, j, k;
      for (h = 0; h < depth; h++) {
         for (i = 0; i < height; i++) {
            GLint srcRow = 7 - (i % 8);
            for (j = 0; j < width; j++) {
               GLint srcCol = j % 32;
               GLubyte texel = (message[srcRow][srcCol]=='X') ? 255 : 70;
               for (k = 0; k < components; k++) {
                  *imgPtr++ = texel;
               }
            }
         }
      }
   }
#endif

   return data;
}
#endif



/**
 * Set the size and format-related fields of a gl_texture_image struct
 * to zero.  This is used when a proxy texture test fails.
 */
static void
clear_teximage_fields(struct gl_texture_image *img)
{
   ASSERT(img);
   img->_BaseFormat = 0;
   img->InternalFormat = 0;
   img->Border = 0;
   img->Width = 0;
   img->Height = 0;
   img->Depth = 0;
   img->Width2 = 0;
   img->Height2 = 0;
   img->Depth2 = 0;
   img->WidthLog2 = 0;
   img->HeightLog2 = 0;
   img->DepthLog2 = 0;
   img->TexFormat = MESA_FORMAT_NONE;
   img->NumSamples = 0;
   img->FixedSampleLocations = GL_TRUE;
}


/**
 * Initialize basic fields of the gl_texture_image struct.
 *
 * \param ctx GL context.
 * \param img texture image structure to be initialized.
 * \param width image width.
 * \param height image height.
 * \param depth image depth.
 * \param border image border.
 * \param internalFormat internal format.
 * \param format  the actual hardware format (one of MESA_FORMAT_*)
 * \param numSamples  number of samples per texel, or zero for non-MS.
 * \param fixedSampleLocations  are sample locations fixed?
 *
 * Fills in the fields of \p img with the given information.
 * Note: width, height and depth include the border.
 */
static void
init_teximage_fields_ms(struct gl_context *ctx,
                        struct gl_texture_image *img,
                        GLsizei width, GLsizei height, GLsizei depth,
                        GLint border, GLenum internalFormat,
                        mesa_format format,
                        GLuint numSamples, GLboolean fixedSampleLocations)
{
   GLenum target;
   ASSERT(img);
   ASSERT(width >= 0);
   ASSERT(height >= 0);
   ASSERT(depth >= 0);

   target = img->TexObject->Target;
   img->_BaseFormat = _mesa_base_tex_format( ctx, internalFormat );
   ASSERT(img->_BaseFormat > 0);
   img->InternalFormat = internalFormat;
   img->Border = border;
   img->Width = width;
   img->Height = height;
   img->Depth = depth;

   img->Width2 = width - 2 * border;   /* == 1 << img->WidthLog2; */
   img->WidthLog2 = _mesa_logbase2(img->Width2);

   img->NumSamples = 0;
   img->FixedSampleLocations = GL_TRUE;

   switch(target) {
   case GL_TEXTURE_1D:
   case GL_TEXTURE_BUFFER:
   case GL_PROXY_TEXTURE_1D:
      if (height == 0)
         img->Height2 = 0;
      else
         img->Height2 = 1;
      img->HeightLog2 = 0;
      if (depth == 0)
         img->Depth2 = 0;
      else
         img->Depth2 = 1;
      img->DepthLog2 = 0;
      break;
   case GL_TEXTURE_1D_ARRAY:
   case GL_PROXY_TEXTURE_1D_ARRAY:
      img->Height2 = height; /* no border */
      img->HeightLog2 = 0; /* not used */
      if (depth == 0)
         img->Depth2 = 0;
      else
         img->Depth2 = 1;
      img->DepthLog2 = 0;
      break;
   case GL_TEXTURE_2D:
   case GL_TEXTURE_RECTANGLE:
   case GL_TEXTURE_CUBE_MAP:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
   case GL_TEXTURE_EXTERNAL_OES:
   case GL_PROXY_TEXTURE_2D:
   case GL_PROXY_TEXTURE_RECTANGLE:
   case GL_PROXY_TEXTURE_CUBE_MAP:
   case GL_TEXTURE_2D_MULTISAMPLE:
   case GL_PROXY_TEXTURE_2D_MULTISAMPLE:
      img->Height2 = height - 2 * border; /* == 1 << img->HeightLog2; */
      img->HeightLog2 = _mesa_logbase2(img->Height2);
      if (depth == 0)
         img->Depth2 = 0;
      else
         img->Depth2 = 1;
      img->DepthLog2 = 0;
      break;
   case GL_TEXTURE_2D_ARRAY:
   case GL_PROXY_TEXTURE_2D_ARRAY:
   case GL_TEXTURE_CUBE_MAP_ARRAY:
   case GL_PROXY_TEXTURE_CUBE_MAP_ARRAY:
   case GL_TEXTURE_2D_MULTISAMPLE_ARRAY:
   case GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY:
      img->Height2 = height - 2 * border; /* == 1 << img->HeightLog2; */
      img->HeightLog2 = _mesa_logbase2(img->Height2);
      img->Depth2 = depth; /* no border */
      img->DepthLog2 = 0; /* not used */
      break;
   case GL_TEXTURE_3D:
   case GL_PROXY_TEXTURE_3D:
      img->Height2 = height - 2 * border; /* == 1 << img->HeightLog2; */
      img->HeightLog2 = _mesa_logbase2(img->Height2);
      img->Depth2 = depth - 2 * border;   /* == 1 << img->DepthLog2; */
      img->DepthLog2 = _mesa_logbase2(img->Depth2);
      break;
   default:
      _mesa_problem(NULL, "invalid target 0x%x in _mesa_init_teximage_fields()",
                    target);
   }

   img->MaxNumLevels =
      _mesa_get_tex_max_num_levels(target,
                                   img->Width2, img->Height2, img->Depth2);
   img->TexFormat = format;
   img->NumSamples = numSamples;
   img->FixedSampleLocations = fixedSampleLocations;
}


void
_mesa_init_teximage_fields(struct gl_context *ctx,
                           struct gl_texture_image *img,
                           GLsizei width, GLsizei height, GLsizei depth,
                           GLint border, GLenum internalFormat,
                           mesa_format format)
{
   init_teximage_fields_ms(ctx, img, width, height, depth, border,
                           internalFormat, format, 0, GL_TRUE);
}


/**
 * Free and clear fields of the gl_texture_image struct.
 *
 * \param ctx GL context.
 * \param texImage texture image structure to be cleared.
 *
 * After the call, \p texImage will have no data associated with it.  Its
 * fields are cleared so that its parent object will test incomplete.
 */
void
_mesa_clear_texture_image(struct gl_context *ctx,
                          struct gl_texture_image *texImage)
{
   ctx->Driver.FreeTextureImageBuffer(ctx, texImage);
   clear_teximage_fields(texImage);
}


/**
 * Check the width, height, depth and border of a texture image are legal.
 * Used by all the glTexImage, glCompressedTexImage and glCopyTexImage
 * functions.
 * The target and level parameters will have already been validated.
 * \return GL_TRUE if size is OK, GL_FALSE otherwise.
 */
GLboolean
_mesa_legal_texture_dimensions(struct gl_context *ctx, GLenum target,
                               GLint level, GLint width, GLint height,
                               GLint depth, GLint border)
{
   GLint maxSize;

   switch (target) {
   case GL_TEXTURE_1D:
   case GL_PROXY_TEXTURE_1D:
      maxSize = 1 << (ctx->Const.MaxTextureLevels - 1); /* level zero size */
      maxSize >>= level;  /* level size */
      if (width < 2 * border || width > 2 * border + maxSize)
         return GL_FALSE;
      if (!ctx->Extensions.ARB_texture_non_power_of_two) {
         if (width > 0 && !_mesa_is_pow_two(width - 2 * border))
            return GL_FALSE;
      }
      return GL_TRUE;

   case GL_TEXTURE_2D:
   case GL_PROXY_TEXTURE_2D:
   case GL_TEXTURE_2D_MULTISAMPLE:
   case GL_PROXY_TEXTURE_2D_MULTISAMPLE:
      maxSize = 1 << (ctx->Const.MaxTextureLevels - 1);
      maxSize >>= level;
      if (width < 2 * border || width > 2 * border + maxSize)
         return GL_FALSE;
      if (height < 2 * border || height > 2 * border + maxSize)
         return GL_FALSE;
      if (!ctx->Extensions.ARB_texture_non_power_of_two) {
         if (width > 0 && !_mesa_is_pow_two(width - 2 * border))
            return GL_FALSE;
         if (height > 0 && !_mesa_is_pow_two(height - 2 * border))
            return GL_FALSE;
      }
      return GL_TRUE;

   case GL_TEXTURE_3D:
   case GL_PROXY_TEXTURE_3D:
      maxSize = 1 << (ctx->Const.Max3DTextureLevels - 1);
      maxSize >>= level;
      if (width < 2 * border || width > 2 * border + maxSize)
         return GL_FALSE;
      if (height < 2 * border || height > 2 * border + maxSize)
         return GL_FALSE;
      if (depth < 2 * border || depth > 2 * border + maxSize)
         return GL_FALSE;
      if (!ctx->Extensions.ARB_texture_non_power_of_two) {
         if (width > 0 && !_mesa_is_pow_two(width - 2 * border))
            return GL_FALSE;
         if (height > 0 && !_mesa_is_pow_two(height - 2 * border))
            return GL_FALSE;
         if (depth > 0 && !_mesa_is_pow_two(depth - 2 * border))
            return GL_FALSE;
      }
      return GL_TRUE;

   case GL_TEXTURE_RECTANGLE_NV:
   case GL_PROXY_TEXTURE_RECTANGLE_NV:
      if (level != 0)
         return GL_FALSE;
      maxSize = ctx->Const.MaxTextureRectSize;
      if (width < 0 || width > maxSize)
         return GL_FALSE;
      if (height < 0 || height > maxSize)
         return GL_FALSE;
      return GL_TRUE;

   case GL_TEXTURE_CUBE_MAP:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
   case GL_PROXY_TEXTURE_CUBE_MAP_ARB:
      maxSize = 1 << (ctx->Const.MaxCubeTextureLevels - 1);
      maxSize >>= level;
      if (width != height)
         return GL_FALSE;
      if (width < 2 * border || width > 2 * border + maxSize)
         return GL_FALSE;
      if (height < 2 * border || height > 2 * border + maxSize)
         return GL_FALSE;
      if (!ctx->Extensions.ARB_texture_non_power_of_two) {
         if (width > 0 && !_mesa_is_pow_two(width - 2 * border))
            return GL_FALSE;
         if (height > 0 && !_mesa_is_pow_two(height - 2 * border))
            return GL_FALSE;
      }
      return GL_TRUE;

   case GL_TEXTURE_1D_ARRAY_EXT:
   case GL_PROXY_TEXTURE_1D_ARRAY_EXT:
      maxSize = 1 << (ctx->Const.MaxTextureLevels - 1);
      maxSize >>= level;
      if (width < 2 * border || width > 2 * border + maxSize)
         return GL_FALSE;
      if (height < 1 || height > ctx->Const.MaxArrayTextureLayers)
         return GL_FALSE;
      if (!ctx->Extensions.ARB_texture_non_power_of_two) {
         if (width > 0 && !_mesa_is_pow_two(width - 2 * border))
            return GL_FALSE;
      }
      return GL_TRUE;

   case GL_TEXTURE_2D_ARRAY_EXT:
   case GL_PROXY_TEXTURE_2D_ARRAY_EXT:
   case GL_TEXTURE_2D_MULTISAMPLE_ARRAY:
   case GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY:
      maxSize = 1 << (ctx->Const.MaxTextureLevels - 1);
      maxSize >>= level;
      if (width < 2 * border || width > 2 * border + maxSize)
         return GL_FALSE;
      if (height < 2 * border || height > 2 * border + maxSize)
         return GL_FALSE;
      if (depth < 0 || depth > ctx->Const.MaxArrayTextureLayers)
         return GL_FALSE;
      if (!ctx->Extensions.ARB_texture_non_power_of_two) {
         if (width > 0 && !_mesa_is_pow_two(width - 2 * border))
            return GL_FALSE;
         if (height > 0 && !_mesa_is_pow_two(height - 2 * border))
            return GL_FALSE;
      }
      return GL_TRUE;

   case GL_TEXTURE_CUBE_MAP_ARRAY:
   case GL_PROXY_TEXTURE_CUBE_MAP_ARRAY:
      maxSize = 1 << (ctx->Const.MaxCubeTextureLevels - 1);
      if (width < 2 * border || width > 2 * border + maxSize)
         return GL_FALSE;
      if (height < 2 * border || height > 2 * border + maxSize)
         return GL_FALSE;
      if (depth < 0 || depth > ctx->Const.MaxArrayTextureLayers || depth % 6)
         return GL_FALSE;
      if (width != height)
         return GL_FALSE;
      if (level >= ctx->Const.MaxCubeTextureLevels)
         return GL_FALSE;
      if (!ctx->Extensions.ARB_texture_non_power_of_two) {
         if (width > 0 && !_mesa_is_pow_two(width - 2 * border))
            return GL_FALSE;
         if (height > 0 && !_mesa_is_pow_two(height - 2 * border))
            return GL_FALSE;
      }
      return GL_TRUE;
   default:
      _mesa_problem(ctx, "Invalid target in _mesa_legal_texture_dimensions()");
      return GL_FALSE;
   }
}


/**
 * Do error checking of xoffset, yoffset, zoffset, width, height and depth
 * for glTexSubImage, glCopyTexSubImage and glCompressedTexSubImage.
 * \param destImage  the destination texture image.
 * \return GL_TRUE if error found, GL_FALSE otherwise.
 */
static GLboolean
error_check_subtexture_dimensions(struct gl_context *ctx,
                                  const char *function, GLuint dims,
                                  const struct gl_texture_image *destImage,
                                  GLint xoffset, GLint yoffset, GLint zoffset,
                                  GLsizei subWidth, GLsizei subHeight,
                                  GLsizei subDepth)
{
   const GLenum target = destImage->TexObject->Target;
   GLuint bw, bh;

   /* Check size */
   if (subWidth < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "%s%dD(width=%d)", function, dims, subWidth);
      return GL_TRUE;
   }

   if (dims > 1 && subHeight < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "%s%dD(height=%d)", function, dims, subHeight);
      return GL_TRUE;
   }

   if (dims > 2 && subDepth < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "%s%dD(depth=%d)", function, dims, subDepth);
      return GL_TRUE;
   }

   /* check xoffset and width */
   if (xoffset < - (GLint) destImage->Border) {
      _mesa_error(ctx, GL_INVALID_VALUE, "%s%dD(xoffset)",
                  function, dims);
      return GL_TRUE;
   }

   if (xoffset + subWidth > (GLint) destImage->Width) {
      _mesa_error(ctx, GL_INVALID_VALUE, "%s%dD(xoffset+width)",
                  function, dims);
      return GL_TRUE;
   }

   /* check yoffset and height */
   if (dims > 1) {
      GLint yBorder = (target == GL_TEXTURE_1D_ARRAY) ? 0 : destImage->Border;
      if (yoffset < -yBorder) {
         _mesa_error(ctx, GL_INVALID_VALUE, "%s%dD(yoffset)",
                     function, dims);
         return GL_TRUE;
      }
      if (yoffset + subHeight > (GLint) destImage->Height) {
         _mesa_error(ctx, GL_INVALID_VALUE, "%s%dD(yoffset+height)",
                     function, dims);
         return GL_TRUE;
      }
   }

   /* check zoffset and depth */
   if (dims > 2) {
      GLint zBorder = (target == GL_TEXTURE_2D_ARRAY ||
                       target == GL_TEXTURE_CUBE_MAP_ARRAY) ?
                         0 : destImage->Border;

      if (zoffset < -zBorder) {
         _mesa_error(ctx, GL_INVALID_VALUE, "%s3D(zoffset)", function);
         return GL_TRUE;
      }
      if (zoffset + subDepth  > (GLint) destImage->Depth) {
         _mesa_error(ctx, GL_INVALID_VALUE, "%s3D(zoffset+depth)", function);
         return GL_TRUE;
      }
   }

   /*
    * The OpenGL spec (and GL_ARB_texture_compression) says only whole
    * compressed texture images can be updated.  But, that restriction may be
    * relaxed for particular compressed formats.  At this time, all the
    * compressed formats supported by Mesa allow sub-textures to be updated
    * along compressed block boundaries.
    */
   _mesa_get_format_block_size(destImage->TexFormat, &bw, &bh);

   if (bw != 1 || bh != 1) {
      /* offset must be multiple of block size */
      if ((xoffset % bw != 0) || (yoffset % bh != 0)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "%s%dD(xoffset = %d, yoffset = %d)",
                     function, dims, xoffset, yoffset);
         return GL_TRUE;
      }

      /* The size must be a multiple of bw x bh, or we must be using a
       * offset+size that exactly hits the edge of the image.  This
       * is important for small mipmap levels (1x1, 2x1, etc) and for
       * NPOT textures.
       */
      if ((subWidth % bw != 0) &&
          (xoffset + subWidth != (GLint) destImage->Width)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "%s%dD(width = %d)", function, dims, subWidth);
         return GL_TRUE;
      }

      if ((subHeight % bh != 0) &&
          (yoffset + subHeight != (GLint) destImage->Height)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "%s%dD(height = %d)", function, dims, subHeight);
         return GL_TRUE;
      }
   }

   return GL_FALSE;
}




/**
 * This is the fallback for Driver.TestProxyTexImage() for doing device-
 * specific texture image size checks.
 *
 * A hardware driver might override this function if, for example, the
 * max 3D texture size is 512x512x64 (i.e. not a cube).
 *
 * Note that width, height, depth == 0 is not an error.  However, a
 * texture with zero width/height/depth will be considered "incomplete"
 * and texturing will effectively be disabled.
 *
 * \param target  any texture target/type
 * \param level  as passed to glTexImage
 * \param format  the MESA_FORMAT_x for the tex image
 * \param width  as passed to glTexImage
 * \param height  as passed to glTexImage
 * \param depth  as passed to glTexImage
 * \param border  as passed to glTexImage
 * \return GL_TRUE if the image is acceptable, GL_FALSE if not acceptable.
 */
GLboolean
_mesa_test_proxy_teximage(struct gl_context *ctx, GLenum target, GLint level,
                          mesa_format format,
                          GLint width, GLint height, GLint depth, GLint border)
{
   /* We just check if the image size is less than MaxTextureMbytes.
    * Some drivers may do more specific checks.
    */
   uint64_t bytes = _mesa_format_image_size64(format, width, height, depth);
   uint64_t mbytes = bytes / (1024 * 1024); /* convert to MB */
   mbytes *= _mesa_num_tex_faces(target);
   return mbytes <= (uint64_t) ctx->Const.MaxTextureMbytes;
}


/**
 * Return true if the format is only valid for glCompressedTexImage.
 */
static GLboolean
compressedteximage_only_format(const struct gl_context *ctx, GLenum format)
{
   switch (format) {
   case GL_ETC1_RGB8_OES:
   case GL_PALETTE4_RGB8_OES:
   case GL_PALETTE4_RGBA8_OES:
   case GL_PALETTE4_R5_G6_B5_OES:
   case GL_PALETTE4_RGBA4_OES:
   case GL_PALETTE4_RGB5_A1_OES:
   case GL_PALETTE8_RGB8_OES:
   case GL_PALETTE8_RGBA8_OES:
   case GL_PALETTE8_R5_G6_B5_OES:
   case GL_PALETTE8_RGBA4_OES:
   case GL_PALETTE8_RGB5_A1_OES:
      return GL_TRUE;
   default:
      return GL_FALSE;
   }
}


/**
 * Helper function to determine whether a target and specific compression
 * format are supported.
 */
GLboolean
_mesa_target_can_be_compressed(const struct gl_context *ctx, GLenum target,
                               GLenum intFormat)
{
   (void) intFormat;  /* not used yet */

   switch (target) {
   case GL_TEXTURE_2D:
   case GL_PROXY_TEXTURE_2D:
      return GL_TRUE; /* true for any compressed format so far */
   case GL_PROXY_TEXTURE_CUBE_MAP:
   case GL_TEXTURE_CUBE_MAP:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
      return ctx->Extensions.ARB_texture_cube_map;
   case GL_PROXY_TEXTURE_2D_ARRAY_EXT:
   case GL_TEXTURE_2D_ARRAY_EXT:
      return ctx->Extensions.EXT_texture_array;
   case GL_PROXY_TEXTURE_CUBE_MAP_ARRAY:
   case GL_TEXTURE_CUBE_MAP_ARRAY:
      return ctx->Extensions.ARB_texture_cube_map_array;
   default:
      return GL_FALSE;
   }
}


/**
 * Check if the given texture target value is legal for a
 * glTexImage1/2/3D call.
 */
static GLboolean
legal_teximage_target(struct gl_context *ctx, GLuint dims, GLenum target)
{
   switch (dims) {
   case 1:
      switch (target) {
      case GL_TEXTURE_1D:
      case GL_PROXY_TEXTURE_1D:
         return _mesa_is_desktop_gl(ctx);
      default:
         return GL_FALSE;
      }
   case 2:
      switch (target) {
      case GL_TEXTURE_2D:
         return GL_TRUE;
      case GL_PROXY_TEXTURE_2D:
         return _mesa_is_desktop_gl(ctx);
      case GL_PROXY_TEXTURE_CUBE_MAP:
         return _mesa_is_desktop_gl(ctx)
            && ctx->Extensions.ARB_texture_cube_map;
      case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
      case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
      case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
         return ctx->Extensions.ARB_texture_cube_map;
      case GL_TEXTURE_RECTANGLE_NV:
      case GL_PROXY_TEXTURE_RECTANGLE_NV:
         return _mesa_is_desktop_gl(ctx)
            && ctx->Extensions.NV_texture_rectangle;
      case GL_TEXTURE_1D_ARRAY_EXT:
      case GL_PROXY_TEXTURE_1D_ARRAY_EXT:
         return _mesa_is_desktop_gl(ctx) && ctx->Extensions.EXT_texture_array;
      default:
         return GL_FALSE;
      }
   case 3:
      switch (target) {
      case GL_TEXTURE_3D:
         return GL_TRUE;
      case GL_PROXY_TEXTURE_3D:
         return _mesa_is_desktop_gl(ctx);
      case GL_TEXTURE_2D_ARRAY_EXT:
         return (_mesa_is_desktop_gl(ctx) && ctx->Extensions.EXT_texture_array)
            || _mesa_is_gles3(ctx);
      case GL_PROXY_TEXTURE_2D_ARRAY_EXT:
         return _mesa_is_desktop_gl(ctx) && ctx->Extensions.EXT_texture_array;
      case GL_TEXTURE_CUBE_MAP_ARRAY:
      case GL_PROXY_TEXTURE_CUBE_MAP_ARRAY:
         return ctx->Extensions.ARB_texture_cube_map_array;
      default:
         return GL_FALSE;
      }
   default:
      _mesa_problem(ctx, "invalid dims=%u in legal_teximage_target()", dims);
      return GL_FALSE;
   }
}


/**
 * Check if the given texture target value is legal for a
 * glTexSubImage, glCopyTexSubImage or glCopyTexImage call.
 * The difference compared to legal_teximage_target() above is that
 * proxy targets are not supported.
 */
static GLboolean
legal_texsubimage_target(struct gl_context *ctx, GLuint dims, GLenum target)
{
   switch (dims) {
   case 1:
      return _mesa_is_desktop_gl(ctx) && target == GL_TEXTURE_1D;
   case 2:
      switch (target) {
      case GL_TEXTURE_2D:
         return GL_TRUE;
      case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
      case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
      case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
         return ctx->Extensions.ARB_texture_cube_map;
      case GL_TEXTURE_RECTANGLE_NV:
         return _mesa_is_desktop_gl(ctx)
            && ctx->Extensions.NV_texture_rectangle;
      case GL_TEXTURE_1D_ARRAY_EXT:
         return _mesa_is_desktop_gl(ctx) && ctx->Extensions.EXT_texture_array;
      default:
         return GL_FALSE;
      }
   case 3:
      switch (target) {
      case GL_TEXTURE_3D:
         return GL_TRUE;
      case GL_TEXTURE_2D_ARRAY_EXT:
         return (_mesa_is_desktop_gl(ctx) && ctx->Extensions.EXT_texture_array)
            || _mesa_is_gles3(ctx);
      case GL_TEXTURE_CUBE_MAP_ARRAY:
      case GL_PROXY_TEXTURE_CUBE_MAP_ARRAY:
         return ctx->Extensions.ARB_texture_cube_map_array;
      default:
         return GL_FALSE;
      }
   default:
      _mesa_problem(ctx, "invalid dims=%u in legal_texsubimage_target()",
                    dims);
      return GL_FALSE;
   }
}


/**
 * Helper function to determine if a texture object is mutable (in terms
 * of GL_ARB_texture_storage).
 */
static GLboolean
mutable_tex_object(struct gl_context *ctx, GLenum target)
{
   struct gl_texture_object *texObj = _mesa_get_current_tex_object(ctx, target);
   return !texObj->Immutable;
}


/**
 * Return expected size of a compressed texture.
 */
static GLuint
compressed_tex_size(GLsizei width, GLsizei height, GLsizei depth,
                    GLenum glformat)
{
   mesa_format mesaFormat = _mesa_glenum_to_compressed_format(glformat);
   return _mesa_format_image_size(mesaFormat, width, height, depth);
}

/**
 * Verify that a texture format is valid with a particular target
 *
 * In particular, textures with base format of \c GL_DEPTH_COMPONENT or
 * \c GL_DEPTH_STENCIL are only valid with certain, context dependent texture
 * targets.
 *
 * \param ctx             GL context
 * \param target          Texture target
 * \param internalFormat  Internal format of the texture image
 * \param dimensions      Dimensionality at the caller.  This is \b not used
 *                        in the validation.  It is only used when logging
 *                        error messages.
 * \param caller          Base name of the calling function (e.g.,
 *                        "glTexImage" or "glTexStorage").
 *
 * \returns true if the combination is legal, false otherwise.
 */
bool
_mesa_legal_texture_base_format_for_target(struct gl_context *ctx,
                                           GLenum target, GLenum internalFormat,
                                           unsigned dimensions,
                                           const char *caller)
{
   if (_mesa_base_tex_format(ctx, internalFormat) == GL_DEPTH_COMPONENT
       || _mesa_base_tex_format(ctx, internalFormat) == GL_DEPTH_STENCIL) {
      /* Section 3.8.3 (Texture Image Specification) of the OpenGL 3.3 Core
       * Profile spec says:
       *
       *     "Textures with a base internal format of DEPTH_COMPONENT or
       *     DEPTH_STENCIL are supported by texture image specification
       *     commands only if target is TEXTURE_1D, TEXTURE_2D,
       *     TEXTURE_1D_ARRAY, TEXTURE_2D_ARRAY, TEXTURE_RECTANGLE,
       *     TEXTURE_CUBE_MAP, PROXY_TEXTURE_1D, PROXY_TEXTURE_2D,
       *     PROXY_TEXTURE_1D_ARRAY, PROXY_TEXTURE_2D_ARRAY,
       *     PROXY_TEXTURE_RECTANGLE, or PROXY_TEXTURE_CUBE_MAP. Using these
       *     formats in conjunction with any other target will result in an
       *     INVALID_OPERATION error."
       *
       * Cubemaps are only supported with desktop OpenGL version >= 3.0,
       * EXT_gpu_shader4, or, on OpenGL ES 2.0+, OES_depth_texture_cube_map.
       */
      if (target != GL_TEXTURE_1D &&
          target != GL_PROXY_TEXTURE_1D &&
          target != GL_TEXTURE_2D &&
          target != GL_PROXY_TEXTURE_2D &&
          target != GL_TEXTURE_1D_ARRAY &&
          target != GL_PROXY_TEXTURE_1D_ARRAY &&
          target != GL_TEXTURE_2D_ARRAY &&
          target != GL_PROXY_TEXTURE_2D_ARRAY &&
          target != GL_TEXTURE_RECTANGLE_ARB &&
          target != GL_PROXY_TEXTURE_RECTANGLE_ARB &&
         !((_mesa_is_cube_face(target) ||
            target == GL_TEXTURE_CUBE_MAP ||
            target == GL_PROXY_TEXTURE_CUBE_MAP) &&
           (ctx->Version >= 30 || ctx->Extensions.EXT_gpu_shader4
            || (ctx->API == API_OPENGLES2 && ctx->Extensions.OES_depth_texture_cube_map))) &&
          !((target == GL_TEXTURE_CUBE_MAP_ARRAY ||
             target == GL_PROXY_TEXTURE_CUBE_MAP_ARRAY) &&
            ctx->Extensions.ARB_texture_cube_map_array)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "%s%dD(bad target for depth texture)",
                     caller, dimensions);
         return false;
      }
   }

   return true;
}

/**
 * Test the glTexImage[123]D() parameters for errors.
 *
 * \param ctx GL context.
 * \param dimensions texture image dimensions (must be 1, 2 or 3).
 * \param target texture target given by the user (already validated).
 * \param level image level given by the user.
 * \param internalFormat internal format given by the user.
 * \param format pixel data format given by the user.
 * \param type pixel data type given by the user.
 * \param width image width given by the user.
 * \param height image height given by the user.
 * \param depth image depth given by the user.
 * \param border image border given by the user.
 *
 * \return GL_TRUE if a error is found, GL_FALSE otherwise
 *
 * Verifies each of the parameters against the constants specified in
 * __struct gl_contextRec::Const and the supported extensions, and according
 * to the OpenGL specification.
 * Note that we don't fully error-check the width, height, depth values
 * here.  That's done in _mesa_legal_texture_dimensions() which is used
 * by several other GL entrypoints.  Plus, texture dims have a special
 * interaction with proxy textures.
 */
static GLboolean
texture_error_check( struct gl_context *ctx,
                     GLuint dimensions, GLenum target,
                     GLint level, GLint internalFormat,
                     GLenum format, GLenum type,
                     GLint width, GLint height,
                     GLint depth, GLint border )
{
   GLboolean colorFormat;
   GLboolean is_format_depth_or_depthstencil;
   GLboolean is_internalFormat_depth_or_depthstencil;
   GLenum err;

   /* Even though there are no color-index textures, we still have to support
    * uploading color-index data and remapping it to RGB via the
    * GL_PIXEL_MAP_I_TO_[RGBA] tables.
    */
   const GLboolean indexFormat = (format == GL_COLOR_INDEX);

   /* Note: for proxy textures, some error conditions immediately generate
    * a GL error in the usual way.  But others do not generate a GL error.
    * Instead, they cause the width, height, depth, format fields of the
    * texture image to be zeroed-out.  The GL spec seems to indicate that the
    * zero-out behaviour is only used in cases related to memory allocation.
    */

   /* level check */
   if (level < 0 || level >= _mesa_max_texture_levels(ctx, target)) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glTexImage%dD(level=%d)", dimensions, level);
      return GL_TRUE;
   }

   /* Check border */
   if (border < 0 || border > 1 ||
       ((ctx->API != API_OPENGL_COMPAT ||
         target == GL_TEXTURE_RECTANGLE_NV ||
         target == GL_PROXY_TEXTURE_RECTANGLE_NV) && border != 0)) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glTexImage%dD(border=%d)", dimensions, border);
      return GL_TRUE;
   }

   if (width < 0 || height < 0 || depth < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glTexImage%dD(width, height or depth < 0)", dimensions);
      return GL_TRUE;
   }

   /* OpenGL ES 1.x and OpenGL ES 2.0 impose additional restrictions on the
    * combinations of format, internalFormat, and type that can be used.
    * Formats and types that require additional extensions (e.g., GL_FLOAT
    * requires GL_OES_texture_float) are filtered elsewhere.
    */

   if (_mesa_is_gles(ctx)) {
      if (_mesa_is_gles3(ctx)) {
         err = _mesa_es3_error_check_format_and_type(format, type,
                                                     internalFormat);
      } else {
         if (format != internalFormat) {
            _mesa_error(ctx, GL_INVALID_OPERATION,
                        "glTexImage%dD(format = %s, internalFormat = %s)",
                        dimensions,
                        _mesa_lookup_enum_by_nr(format),
                        _mesa_lookup_enum_by_nr(internalFormat));
            return GL_TRUE;
         }

         err = _mesa_es_error_check_format_and_type(format, type, dimensions);
      }
      if (err != GL_NO_ERROR) {
         _mesa_error(ctx, err,
                     "glTexImage%dD(format = %s, type = %s, internalFormat = %s)",
                     dimensions,
                     _mesa_lookup_enum_by_nr(format),
                     _mesa_lookup_enum_by_nr(type),
                     _mesa_lookup_enum_by_nr(internalFormat));
         return GL_TRUE;
      }
   }

   /* Check internalFormat */
   if (_mesa_base_tex_format(ctx, internalFormat) < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glTexImage%dD(internalFormat=%s)",
                  dimensions, _mesa_lookup_enum_by_nr(internalFormat));
      return GL_TRUE;
   }

   /* Check incoming image format and type */
   err = _mesa_error_check_format_and_type(ctx, format, type);
   if (err != GL_NO_ERROR) {
      _mesa_error(ctx, err,
                  "glTexImage%dD(incompatible format = %s, type = %s)",
                  dimensions, _mesa_lookup_enum_by_nr(format),
                  _mesa_lookup_enum_by_nr(type));
      return GL_TRUE;
   }

   /* make sure internal format and format basically agree */
   is_internalFormat_depth_or_depthstencil =
      _mesa_is_depth_format(internalFormat) ||
      _mesa_is_depthstencil_format(internalFormat);

   is_format_depth_or_depthstencil =
      _mesa_is_depth_format(format) ||
      _mesa_is_depthstencil_format(format);

   colorFormat = _mesa_is_color_format(format);
   if ((_mesa_is_color_format(internalFormat) && !colorFormat && !indexFormat) ||
       (is_internalFormat_depth_or_depthstencil != is_format_depth_or_depthstencil) ||
       (_mesa_is_ycbcr_format(internalFormat) != _mesa_is_ycbcr_format(format)) ||
       (_mesa_is_dudv_format(internalFormat) != _mesa_is_dudv_format(format))) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glTexImage%dD(incompatible internalFormat = %s, format = %s)",
                  dimensions, _mesa_lookup_enum_by_nr(internalFormat),
                  _mesa_lookup_enum_by_nr(format));
      return GL_TRUE;
   }

   /* additional checks for ycbcr textures */
   if (internalFormat == GL_YCBCR_MESA) {
      ASSERT(ctx->Extensions.MESA_ycbcr_texture);
      if (type != GL_UNSIGNED_SHORT_8_8_MESA &&
          type != GL_UNSIGNED_SHORT_8_8_REV_MESA) {
         char message[100];
         _mesa_snprintf(message, sizeof(message),
                        "glTexImage%dD(format/type YCBCR mismatch)",
                        dimensions);
         _mesa_error(ctx, GL_INVALID_ENUM, "%s", message);
         return GL_TRUE; /* error */
      }
      if (target != GL_TEXTURE_2D &&
          target != GL_PROXY_TEXTURE_2D &&
          target != GL_TEXTURE_RECTANGLE_NV &&
          target != GL_PROXY_TEXTURE_RECTANGLE_NV) {
         _mesa_error(ctx, GL_INVALID_ENUM,
                     "glTexImage%dD(bad target for YCbCr texture)",
                     dimensions);
         return GL_TRUE;
      }
      if (border != 0) {
         char message[100];
         _mesa_snprintf(message, sizeof(message),
                        "glTexImage%dD(format=GL_YCBCR_MESA and border=%d)",
                        dimensions, border);
         _mesa_error(ctx, GL_INVALID_VALUE, "%s", message);
         return GL_TRUE;
      }
   }

   /* additional checks for depth textures */
   if (!_mesa_legal_texture_base_format_for_target(ctx, target, internalFormat,
                                                   dimensions, "glTexImage"))
      return GL_TRUE;

   /* additional checks for compressed textures */
   if (_mesa_is_compressed_format(ctx, internalFormat)) {
      if (!_mesa_target_can_be_compressed(ctx, target, internalFormat)) {
         _mesa_error(ctx, GL_INVALID_ENUM,
                     "glTexImage%dD(target can't be compressed)", dimensions);
         return GL_TRUE;
      }
      if (compressedteximage_only_format(ctx, internalFormat)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glTexImage%dD(no compression for format)", dimensions);
         return GL_TRUE;
      }
      if (border != 0) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glTexImage%dD(border!=0)", dimensions);
         return GL_TRUE;
      }
   }

   /* additional checks for integer textures */
   if ((ctx->Version >= 30 || ctx->Extensions.EXT_texture_integer) &&
       (_mesa_is_enum_format_integer(format) !=
        _mesa_is_enum_format_integer(internalFormat))) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glTexImage%dD(integer/non-integer format mismatch)",
                  dimensions);
      return GL_TRUE;
   }

   if (!mutable_tex_object(ctx, target)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glTexImage%dD(immutable texture)", dimensions);
      return GL_TRUE;
   }

   /* if we get here, the parameters are OK */
   return GL_FALSE;
}


/**
 * Error checking for glCompressedTexImage[123]D().
 * Note that the width, height and depth values are not fully error checked
 * here.
 * \return GL_TRUE if a error is found, GL_FALSE otherwise
 */
static GLenum
compressed_texture_error_check(struct gl_context *ctx, GLint dimensions,
                               GLenum target, GLint level,
                               GLenum internalFormat, GLsizei width,
                               GLsizei height, GLsizei depth, GLint border,
                               GLsizei imageSize)
{
   const GLint maxLevels = _mesa_max_texture_levels(ctx, target);
   GLint expectedSize;
   GLenum error = GL_NO_ERROR;
   char *reason = ""; /* no error */

   if (!_mesa_target_can_be_compressed(ctx, target, internalFormat)) {
      reason = "target";
      /* From section 3.8.6, page 146 of OpenGL ES 3.0 spec:
       *
       *    "The ETC2/EAC texture compression algorithm supports only
       *     two-dimensional images. If internalformat is an ETC2/EAC format,
       *     CompressedTexImage3D will generate an INVALID_OPERATION error if
       *     target is not TEXTURE_2D_ARRAY."
       */
      error = _mesa_is_desktop_gl(ctx) ? GL_INVALID_ENUM : GL_INVALID_OPERATION;
      goto error;
   }

   /* This will detect any invalid internalFormat value */
   if (!_mesa_is_compressed_format(ctx, internalFormat)) {
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "glCompressedTexImage%dD(internalFormat=%s)",
                  dimensions, _mesa_lookup_enum_by_nr(internalFormat));
      return GL_TRUE;
   }

   switch (internalFormat) {
   case GL_PALETTE4_RGB8_OES:
   case GL_PALETTE4_RGBA8_OES:
   case GL_PALETTE4_R5_G6_B5_OES:
   case GL_PALETTE4_RGBA4_OES:
   case GL_PALETTE4_RGB5_A1_OES:
   case GL_PALETTE8_RGB8_OES:
   case GL_PALETTE8_RGBA8_OES:
   case GL_PALETTE8_R5_G6_B5_OES:
   case GL_PALETTE8_RGBA4_OES:
   case GL_PALETTE8_RGB5_A1_OES:
      /* check level (note that level should be zero or less!) */
      if (level > 0 || level < -maxLevels) {
	 reason = "level";
	 error = GL_INVALID_VALUE;
         goto error;
      }

      if (dimensions != 2) {
	 reason = "compressed paletted textures must be 2D";
	 error = GL_INVALID_OPERATION;
         goto error;
      }

      /* Figure out the expected texture size (in bytes).  This will be
       * checked against the actual size later.
       */
      expectedSize = _mesa_cpal_compressed_size(level, internalFormat,
						width, height);

      /* This is for the benefit of the TestProxyTexImage below.  It expects
       * level to be non-negative.  OES_compressed_paletted_texture uses a
       * weird mechanism where the level specified to glCompressedTexImage2D
       * is -(n-1) number of levels in the texture, and the data specifies the
       * complete mipmap stack.  This is done to ensure the palette is the
       * same for all levels.
       */
      level = -level;
      break;

   default:
      /* check level */
      if (level < 0 || level >= maxLevels) {
	 reason = "level";
	 error = GL_INVALID_VALUE;
         goto error;
      }

      /* Figure out the expected texture size (in bytes).  This will be
       * checked against the actual size later.
       */
      expectedSize = compressed_tex_size(width, height, depth, internalFormat);
      break;
   }

   /* This should really never fail */
   if (_mesa_base_tex_format(ctx, internalFormat) < 0) {
      reason = "internalFormat";
      error = GL_INVALID_ENUM;
      goto error;
   }

   /* No compressed formats support borders at this time */
   if (border != 0) {
      reason = "border != 0";
      error = GL_INVALID_VALUE;
      goto error;
   }

   /* check image size in bytes */
   if (expectedSize != imageSize) {
      /* Per GL_ARB_texture_compression:  GL_INVALID_VALUE is generated [...]
       * if <imageSize> is not consistent with the format, dimensions, and
       * contents of the specified image.
       */
      reason = "imageSize inconsistant with width/height/format";
      error = GL_INVALID_VALUE;
      goto error;
   }

   if (!mutable_tex_object(ctx, target)) {
      reason = "immutable texture";
      error = GL_INVALID_OPERATION;
      goto error;
   }

   return GL_FALSE;

error:
   /* Note: not all error paths exit through here. */
   _mesa_error(ctx, error, "glCompressedTexImage%dD(%s)", dimensions, reason);
   return GL_TRUE;
}



/**
 * Test glTexSubImage[123]D() parameters for errors.
 *
 * \param ctx GL context.
 * \param dimensions texture image dimensions (must be 1, 2 or 3).
 * \param target texture target given by the user (already validated)
 * \param level image level given by the user.
 * \param xoffset sub-image x offset given by the user.
 * \param yoffset sub-image y offset given by the user.
 * \param zoffset sub-image z offset given by the user.
 * \param format pixel data format given by the user.
 * \param type pixel data type given by the user.
 * \param width image width given by the user.
 * \param height image height given by the user.
 * \param depth image depth given by the user.
 *
 * \return GL_TRUE if an error was detected, or GL_FALSE if no errors.
 *
 * Verifies each of the parameters against the constants specified in
 * __struct gl_contextRec::Const and the supported extensions, and according
 * to the OpenGL specification.
 */
static GLboolean
texsubimage_error_check(struct gl_context *ctx, GLuint dimensions,
                        GLenum target, GLint level,
                        GLint xoffset, GLint yoffset, GLint zoffset,
                        GLint width, GLint height, GLint depth,
                        GLenum format, GLenum type)
{
   struct gl_texture_object *texObj;
   struct gl_texture_image *texImage;
   GLenum err;

   /* check target (proxies not allowed) */
   if (!legal_texsubimage_target(ctx, dimensions, target)) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glTexSubImage%uD(target=%s)",
                  dimensions, _mesa_lookup_enum_by_nr(target));
      return GL_TRUE;
   }

   /* level check */
   if (level < 0 || level >= _mesa_max_texture_levels(ctx, target)) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glTexSubImage%uD(level=%d)",
                  dimensions, level);
      return GL_TRUE;
   }

   /* OpenGL ES 1.x and OpenGL ES 2.0 impose additional restrictions on the
    * combinations of format and type that can be used.  Formats and types
    * that require additional extensions (e.g., GL_FLOAT requires
    * GL_OES_texture_float) are filtered elsewhere.
    */
   if (_mesa_is_gles(ctx) && !_mesa_is_gles3(ctx)) {
      err = _mesa_es_error_check_format_and_type(format, type, dimensions);
      if (err != GL_NO_ERROR) {
         _mesa_error(ctx, err,
                     "glTexSubImage%dD(format = %s, type = %s)",
                     dimensions,
                     _mesa_lookup_enum_by_nr(format),
                     _mesa_lookup_enum_by_nr(type));
         return GL_TRUE;
      }
   }

   err = _mesa_error_check_format_and_type(ctx, format, type);
   if (err != GL_NO_ERROR) {
      _mesa_error(ctx, err,
                  "glTexSubImage%dD(incompatible format = %s, type = %s)",
                  dimensions, _mesa_lookup_enum_by_nr(format),
                  _mesa_lookup_enum_by_nr(type));
      return GL_TRUE;
   }

   /* Get dest texture object / image pointers */
   texObj = _mesa_get_current_tex_object(ctx, target);
   if (!texObj) {
      /* must be out of memory */
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glTexSubImage%dD()", dimensions);
      return GL_TRUE;
   }

   texImage = _mesa_select_tex_image(ctx, texObj, target, level);
   if (!texImage) {
      /* non-existant texture level */
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glTexSubImage%dD(invalid texture image)", dimensions);
      return GL_TRUE;
   }

   if (error_check_subtexture_dimensions(ctx, "glTexSubImage", dimensions,
                                         texImage, xoffset, yoffset, 0,
                                         width, height, 1)) {
      return GL_TRUE;
   }

   if (_mesa_is_format_compressed(texImage->TexFormat)) {
      if (compressedteximage_only_format(ctx, texImage->InternalFormat)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
               "glTexSubImage%dD(no compression for format)", dimensions);
         return GL_TRUE;
      }
   }

   if (ctx->Version >= 30 || ctx->Extensions.EXT_texture_integer) {
      /* both source and dest must be integer-valued, or neither */
      if (_mesa_is_format_integer_color(texImage->TexFormat) !=
          _mesa_is_enum_format_integer(format)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glTexSubImage%dD(integer/non-integer format mismatch)",
                     dimensions);
         return GL_TRUE;
      }
   }

   return GL_FALSE;
}


/**
 * Test glCopyTexImage[12]D() parameters for errors.
 *
 * \param ctx GL context.
 * \param dimensions texture image dimensions (must be 1, 2 or 3).
 * \param target texture target given by the user.
 * \param level image level given by the user.
 * \param internalFormat internal format given by the user.
 * \param width image width given by the user.
 * \param height image height given by the user.
 * \param border texture border.
 *
 * \return GL_TRUE if an error was detected, or GL_FALSE if no errors.
 *
 * Verifies each of the parameters against the constants specified in
 * __struct gl_contextRec::Const and the supported extensions, and according
 * to the OpenGL specification.
 */
static GLboolean
copytexture_error_check( struct gl_context *ctx, GLuint dimensions,
                         GLenum target, GLint level, GLint internalFormat,
                         GLint width, GLint height, GLint border )
{
   GLint baseFormat;
   GLint rb_base_format;
   struct gl_renderbuffer *rb;
   GLenum rb_internal_format;

   /* check target */
   if (!legal_texsubimage_target(ctx, dimensions, target)) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glCopyTexImage%uD(target=%s)",
                  dimensions, _mesa_lookup_enum_by_nr(target));
      return GL_TRUE;
   }

   /* level check */
   if (level < 0 || level >= _mesa_max_texture_levels(ctx, target)) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glCopyTexImage%dD(level=%d)", dimensions, level);
      return GL_TRUE;
   }

   /* Check that the source buffer is complete */
   if (_mesa_is_user_fbo(ctx->ReadBuffer)) {
      if (ctx->ReadBuffer->_Status == 0) {
         _mesa_test_framebuffer_completeness(ctx, ctx->ReadBuffer);
      }
      if (ctx->ReadBuffer->_Status != GL_FRAMEBUFFER_COMPLETE_EXT) {
         _mesa_error(ctx, GL_INVALID_FRAMEBUFFER_OPERATION_EXT,
                     "glCopyTexImage%dD(invalid readbuffer)", dimensions);
         return GL_TRUE;
      }

      if (ctx->ReadBuffer->Visual.samples > 0) {
	 _mesa_error(ctx, GL_INVALID_OPERATION,
		     "glCopyTexImage%dD(multisample FBO)",
		     dimensions);
	 return GL_TRUE;
      }
   }

   /* Check border */
   if (border < 0 || border > 1 ||
       ((ctx->API != API_OPENGL_COMPAT ||
         target == GL_TEXTURE_RECTANGLE_NV ||
         target == GL_PROXY_TEXTURE_RECTANGLE_NV) && border != 0)) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glCopyTexImage%dD(border=%d)", dimensions, border);
      return GL_TRUE;
   }

   rb = _mesa_get_read_renderbuffer_for_format(ctx, internalFormat);
   if (rb == NULL) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glCopyTexImage%dD(read buffer)", dimensions);
      return GL_TRUE;
   }

   /* OpenGL ES 1.x and OpenGL ES 2.0 impose additional restrictions on the
    * internalFormat.
    */
   if (_mesa_is_gles(ctx) && !_mesa_is_gles3(ctx)) {
      switch (internalFormat) {
      case GL_ALPHA:
      case GL_RGB:
      case GL_RGBA:
      case GL_LUMINANCE:
      case GL_LUMINANCE_ALPHA:
         break;
      default:
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glCopyTexImage%dD(internalFormat=%s)", dimensions,
                     _mesa_lookup_enum_by_nr(internalFormat));
         return GL_TRUE;
      }
   }

   baseFormat = _mesa_base_tex_format(ctx, internalFormat);
   if (baseFormat < 0) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glCopyTexImage%dD(internalFormat=%s)", dimensions,
                  _mesa_lookup_enum_by_nr(internalFormat));
      return GL_TRUE;
   }

   rb_internal_format = rb->InternalFormat;
   rb_base_format = _mesa_base_tex_format(ctx, rb->InternalFormat);
   if (_mesa_is_color_format(internalFormat)) {
      if (rb_base_format < 0) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glCopyTexImage%dD(internalFormat=%s)", dimensions,
                     _mesa_lookup_enum_by_nr(internalFormat));
         return GL_TRUE;
      }
   }

   if (_mesa_is_gles(ctx)) {
      bool valid = true;
      if (_mesa_base_format_component_count(baseFormat) >
          _mesa_base_format_component_count(rb_base_format)) {
         valid = false;
      }
      if (baseFormat == GL_DEPTH_COMPONENT ||
          baseFormat == GL_DEPTH_STENCIL ||
          rb_base_format == GL_DEPTH_COMPONENT ||
          rb_base_format == GL_DEPTH_STENCIL ||
          ((baseFormat == GL_LUMINANCE_ALPHA ||
            baseFormat == GL_ALPHA) &&
           rb_base_format != GL_RGBA) ||
          internalFormat == GL_RGB9_E5) {
         valid = false;
      }
      if (internalFormat == GL_RGB9_E5) {
         valid = false;
      }
      if (!valid) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glCopyTexImage%dD(internalFormat=%s)", dimensions,
                     _mesa_lookup_enum_by_nr(internalFormat));
         return GL_TRUE;
      }
   }

   if (_mesa_is_gles3(ctx)) {
      bool rb_is_srgb = false;
      bool dst_is_srgb = false;

      if (ctx->Extensions.EXT_framebuffer_sRGB &&
          _mesa_get_format_color_encoding(rb->Format) == GL_SRGB) {
         rb_is_srgb = true;
      }

      if (_mesa_get_linear_internalformat(internalFormat) != internalFormat) {
         dst_is_srgb = true;
      }

      if (rb_is_srgb != dst_is_srgb) {
         /* Page 137 (page 149 of the PDF) in section 3.8.5 of the
          * OpenGLES 3.0.0 spec says:
          *
          *     "The error INVALID_OPERATION is also generated if the
          *     value of FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING for the
          *     framebuffer attachment corresponding to the read buffer
          *     is LINEAR (see section 6.1.13) and internalformat is
          *     one of the sRGB formats described in section 3.8.16, or
          *     if the value of FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING is
          *     SRGB and internalformat is not one of the sRGB formats."
          */
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glCopyTexImage%dD(srgb usage mismatch)", dimensions);
         return GL_TRUE;
      }

      /* Page 139, Table 3.15 of OpenGL ES 3.0 spec does not define ReadPixels
       * types for SNORM formats. Also, conversion to SNORM formats is not
       * allowed by Table 3.2 on Page 110.
       */
      if(_mesa_is_enum_format_snorm(internalFormat)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glCopyTexImage%dD(internalFormat=%s)", dimensions,
                     _mesa_lookup_enum_by_nr(internalFormat));
         return GL_TRUE;
      }
   }

   if (!_mesa_source_buffer_exists(ctx, baseFormat)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glCopyTexImage%dD(missing readbuffer)", dimensions);
      return GL_TRUE;
   }

   /* From the EXT_texture_integer spec:
    *
    *     "INVALID_OPERATION is generated by CopyTexImage* and CopyTexSubImage*
    *      if the texture internalformat is an integer format and the read color
    *      buffer is not an integer format, or if the internalformat is not an
    *      integer format and the read color buffer is an integer format."
    */
   if (_mesa_is_color_format(internalFormat)) {
      bool is_int = _mesa_is_enum_format_integer(internalFormat);
      bool is_rbint = _mesa_is_enum_format_integer(rb_internal_format);
      bool is_unorm = _mesa_is_enum_format_unorm(internalFormat);
      bool is_rbunorm = _mesa_is_enum_format_unorm(rb_internal_format);
      if (is_int || is_rbint) {
         if (is_int != is_rbint) {
            _mesa_error(ctx, GL_INVALID_OPERATION,
                        "glCopyTexImage%dD(integer vs non-integer)", dimensions);
            return GL_TRUE;
         } else if (_mesa_is_gles(ctx) &&
                    _mesa_is_enum_format_unsigned_int(internalFormat) !=
                      _mesa_is_enum_format_unsigned_int(rb_internal_format)) {
            _mesa_error(ctx, GL_INVALID_OPERATION,
                        "glCopyTexImage%dD(signed vs unsigned integer)", dimensions);
            return GL_TRUE;
         }
      }

      /* From page 138 of OpenGL ES 3.0 spec:
       *    "The error INVALID_OPERATION is generated if floating-point RGBA
       *    data is required; if signed integer RGBA data is required and the
       *    format of the current color buffer is not signed integer; if
       *    unsigned integer RGBA data is required and the format of the
       *    current color buffer is not unsigned integer; or if fixed-point
       *    RGBA data is required and the format of the current color buffer
       *    is not fixed-point.
       */
      if (_mesa_is_gles(ctx) && is_unorm != is_rbunorm)
            _mesa_error(ctx, GL_INVALID_OPERATION,
                        "glCopyTexImage%dD(unorm vs non-unorm)", dimensions);
   }

   if (_mesa_is_compressed_format(ctx, internalFormat)) {
      if (!_mesa_target_can_be_compressed(ctx, target, internalFormat)) {
         _mesa_error(ctx, GL_INVALID_ENUM,
                     "glCopyTexImage%dD(target)", dimensions);
         return GL_TRUE;
      }
      if (compressedteximage_only_format(ctx, internalFormat)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
               "glCopyTexImage%dD(no compression for format)", dimensions);
         return GL_TRUE;
      }
      if (border != 0) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glCopyTexImage%dD(border!=0)", dimensions);
         return GL_TRUE;
      }
   }

   if (!mutable_tex_object(ctx, target)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glCopyTexImage%dD(immutable texture)", dimensions);
      return GL_TRUE;
   }

   /* if we get here, the parameters are OK */
   return GL_FALSE;
}


/**
 * Test glCopyTexSubImage[12]D() parameters for errors.
 * \return GL_TRUE if an error was detected, or GL_FALSE if no errors.
 */
static GLboolean
copytexsubimage_error_check(struct gl_context *ctx, GLuint dimensions,
                            GLenum target, GLint level,
                            GLint xoffset, GLint yoffset, GLint zoffset,
                            GLint width, GLint height)
{
   struct gl_texture_object *texObj;
   struct gl_texture_image *texImage;

   /* Check that the source buffer is complete */
   if (_mesa_is_user_fbo(ctx->ReadBuffer)) {
      if (ctx->ReadBuffer->_Status == 0) {
         _mesa_test_framebuffer_completeness(ctx, ctx->ReadBuffer);
      }
      if (ctx->ReadBuffer->_Status != GL_FRAMEBUFFER_COMPLETE_EXT) {
         _mesa_error(ctx, GL_INVALID_FRAMEBUFFER_OPERATION_EXT,
                     "glCopyTexImage%dD(invalid readbuffer)", dimensions);
         return GL_TRUE;
      }

      if (ctx->ReadBuffer->Visual.samples > 0) {
	 _mesa_error(ctx, GL_INVALID_OPERATION,
		     "glCopyTexSubImage%dD(multisample FBO)",
		     dimensions);
	 return GL_TRUE;
      }
   }

   /* check target (proxies not allowed) */
   if (!legal_texsubimage_target(ctx, dimensions, target)) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glCopyTexSubImage%uD(target=%s)",
                  dimensions, _mesa_lookup_enum_by_nr(target));
      return GL_TRUE;
   }

   /* Check level */
   if (level < 0 || level >= _mesa_max_texture_levels(ctx, target)) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glCopyTexSubImage%dD(level=%d)", dimensions, level);
      return GL_TRUE;
   }

   /* Get dest texture object / image pointers */
   texObj = _mesa_get_current_tex_object(ctx, target);
   if (!texObj) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCopyTexSubImage%dD()", dimensions);
      return GL_TRUE;
   }

   texImage = _mesa_select_tex_image(ctx, texObj, target, level);
   if (!texImage) {
      /* destination image does not exist */
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glCopyTexSubImage%dD(invalid texture image)", dimensions);
      return GL_TRUE;
   }

   if (error_check_subtexture_dimensions(ctx, "glCopyTexSubImage",
                                         dimensions, texImage,
                                         xoffset, yoffset, zoffset,
                                         width, height, 1)) {
      return GL_TRUE;
   }

   if (_mesa_is_format_compressed(texImage->TexFormat)) {
      if (compressedteximage_only_format(ctx, texImage->InternalFormat)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
               "glCopyTexSubImage%dD(no compression for format)", dimensions);
         return GL_TRUE;
      }
   }

   if (texImage->InternalFormat == GL_YCBCR_MESA) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glCopyTexSubImage2D");
      return GL_TRUE;
   }

   if (!_mesa_source_buffer_exists(ctx, texImage->_BaseFormat)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glCopyTexSubImage%dD(missing readbuffer, format=0x%x)",
                  dimensions, texImage->_BaseFormat);
      return GL_TRUE;
   }

   /* From the EXT_texture_integer spec:
    *
    *     "INVALID_OPERATION is generated by CopyTexImage* and CopyTexSubImage*
    *      if the texture internalformat is an integer format and the read color
    *      buffer is not an integer format, or if the internalformat is not an
    *      integer format and the read color buffer is an integer format."
    */
   if (_mesa_is_color_format(texImage->InternalFormat)) {
      struct gl_renderbuffer *rb = ctx->ReadBuffer->_ColorReadBuffer;

      if (_mesa_is_format_integer_color(rb->Format) !=
	  _mesa_is_format_integer_color(texImage->TexFormat)) {
	 _mesa_error(ctx, GL_INVALID_OPERATION,
		     "glCopyTexImage%dD(integer vs non-integer)", dimensions);
	 return GL_TRUE;
      }
   }

   /* if we get here, the parameters are OK */
   return GL_FALSE;
}


/** Callback info for walking over FBO hash table */
struct cb_info
{
   struct gl_context *ctx;
   struct gl_texture_object *texObj;
   GLuint level, face;
};


/**
 * Check render to texture callback.  Called from _mesa_HashWalk().
 */
static void
check_rtt_cb(GLuint key, void *data, void *userData)
{
   struct gl_framebuffer *fb = (struct gl_framebuffer *) data;
   const struct cb_info *info = (struct cb_info *) userData;
   struct gl_context *ctx = info->ctx;
   const struct gl_texture_object *texObj = info->texObj;
   const GLuint level = info->level, face = info->face;

   /* If this is a user-created FBO */
   if (_mesa_is_user_fbo(fb)) {
      GLuint i;
      /* check if any of the FBO's attachments point to 'texObj' */
      for (i = 0; i < BUFFER_COUNT; i++) {
         struct gl_renderbuffer_attachment *att = fb->Attachment + i;
         if (att->Type == GL_TEXTURE &&
             att->Texture == texObj &&
             att->TextureLevel == level &&
             att->CubeMapFace == face) {
            _mesa_update_texture_renderbuffer(ctx, ctx->DrawBuffer, att);
            ASSERT(att->Renderbuffer->TexImage);
            /* Mark fb status as indeterminate to force re-validation */
            fb->_Status = 0;
         }
      }
   }
}


/**
 * When a texture image is specified we have to check if it's bound to
 * any framebuffer objects (render to texture) in order to detect changes
 * in size or format since that effects FBO completeness.
 * Any FBOs rendering into the texture must be re-validated.
 */
void
_mesa_update_fbo_texture(struct gl_context *ctx,
                         struct gl_texture_object *texObj,
                         GLuint face, GLuint level)
{
   /* Only check this texture if it's been marked as RenderToTexture */
   if (texObj->_RenderToTexture) {
      struct cb_info info;
      info.ctx = ctx;
      info.texObj = texObj;
      info.level = level;
      info.face = face;
      _mesa_HashWalk(ctx->Shared->FrameBuffers, check_rtt_cb, &info);
   }
}


/**
 * If the texture object's GenerateMipmap flag is set and we've
 * changed the texture base level image, regenerate the rest of the
 * mipmap levels now.
 */
static inline void
check_gen_mipmap(struct gl_context *ctx, GLenum target,
                 struct gl_texture_object *texObj, GLint level)
{
   ASSERT(target != GL_TEXTURE_CUBE_MAP);
   if (texObj->GenerateMipmap &&
       level == texObj->BaseLevel &&
       level < texObj->MaxLevel) {
      ASSERT(ctx->Driver.GenerateMipmap);
      ctx->Driver.GenerateMipmap(ctx, target, texObj);
   }
}


/** Debug helper: override the user-requested internal format */
static GLenum
override_internal_format(GLenum internalFormat, GLint width, GLint height)
{
#if 0
   if (internalFormat == GL_RGBA16F_ARB ||
       internalFormat == GL_RGBA32F_ARB) {
      printf("Convert rgba float tex to int %d x %d\n", width, height);
      return GL_RGBA;
   }
   else if (internalFormat == GL_RGB16F_ARB ||
            internalFormat == GL_RGB32F_ARB) {
      printf("Convert rgb float tex to int %d x %d\n", width, height);
      return GL_RGB;
   }
   else if (internalFormat == GL_LUMINANCE_ALPHA16F_ARB ||
            internalFormat == GL_LUMINANCE_ALPHA32F_ARB) {
      printf("Convert luminance float tex to int %d x %d\n", width, height);
      return GL_LUMINANCE_ALPHA;
   }
   else if (internalFormat == GL_LUMINANCE16F_ARB ||
            internalFormat == GL_LUMINANCE32F_ARB) {
      printf("Convert luminance float tex to int %d x %d\n", width, height);
      return GL_LUMINANCE;
   }
   else if (internalFormat == GL_ALPHA16F_ARB ||
            internalFormat == GL_ALPHA32F_ARB) {
      printf("Convert luminance float tex to int %d x %d\n", width, height);
      return GL_ALPHA;
   }
   /*
   else if (internalFormat == GL_COMPRESSED_RGBA_S3TC_DXT1_EXT) {
      internalFormat = GL_RGBA;
   }
   */
   else {
      return internalFormat;
   }
#else
   return internalFormat;
#endif
}


/**
 * Choose the actual hardware format for a texture image.
 * Try to use the same format as the previous image level when possible.
 * Otherwise, ask the driver for the best format.
 * It's important to try to choose a consistant format for all levels
 * for efficient texture memory layout/allocation.  In particular, this
 * comes up during automatic mipmap generation.
 */
mesa_format
_mesa_choose_texture_format(struct gl_context *ctx,
                            struct gl_texture_object *texObj,
                            GLenum target, GLint level,
                            GLenum internalFormat, GLenum format, GLenum type)
{
   mesa_format f;

   /* see if we've already chosen a format for the previous level */
   if (level > 0) {
      struct gl_texture_image *prevImage =
	 _mesa_select_tex_image(ctx, texObj, target, level - 1);
      /* See if the prev level is defined and has an internal format which
       * matches the new internal format.
       */
      if (prevImage &&
          prevImage->Width > 0 &&
          prevImage->InternalFormat == internalFormat) {
         /* use the same format */
         ASSERT(prevImage->TexFormat != MESA_FORMAT_NONE);
         return prevImage->TexFormat;
      }
   }

   /* If the application requested compression to an S3TC format but we don't
    * have the DXTn library, force a generic compressed format instead.
    */
   if (internalFormat != format && format != GL_NONE) {
      const GLenum before = internalFormat;

      switch (internalFormat) {
      case GL_COMPRESSED_RGB_S3TC_DXT1_EXT:
         if (!ctx->Mesa_DXTn)
            internalFormat = GL_COMPRESSED_RGB;
         break;
      case GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:
      case GL_COMPRESSED_RGBA_S3TC_DXT3_EXT:
      case GL_COMPRESSED_RGBA_S3TC_DXT5_EXT:
         if (!ctx->Mesa_DXTn)
            internalFormat = GL_COMPRESSED_RGBA;
         break;
      default:
         break;
      }

      if (before != internalFormat) {
         _mesa_warning(ctx,
                       "DXT compression requested (%s), "
                       "but libtxc_dxtn library not installed.  Using %s "
                       "instead.",
                       _mesa_lookup_enum_by_nr(before),
                       _mesa_lookup_enum_by_nr(internalFormat));
      }
   }

   /* choose format from scratch */
   f = ctx->Driver.ChooseTextureFormat(ctx, texObj->Target, internalFormat,
                                       format, type);
   ASSERT(f != MESA_FORMAT_NONE);
   return f;
}


/**
 * Adjust pixel unpack params and image dimensions to strip off the
 * one-pixel texture border.
 *
 * Gallium and intel don't support texture borders.  They've seldem been used
 * and seldom been implemented correctly anyway.
 *
 * \param unpackNew returns the new pixel unpack parameters
 */
static void
strip_texture_border(GLenum target,
                     GLint *width, GLint *height, GLint *depth,
                     const struct gl_pixelstore_attrib *unpack,
                     struct gl_pixelstore_attrib *unpackNew)
{
   assert(width);
   assert(height);
   assert(depth);

   *unpackNew = *unpack;

   if (unpackNew->RowLength == 0)
      unpackNew->RowLength = *width;

   if (unpackNew->ImageHeight == 0)
      unpackNew->ImageHeight = *height;

   assert(*width >= 3);
   unpackNew->SkipPixels++;  /* skip the border */
   *width = *width - 2;      /* reduce the width by two border pixels */

   /* The min height of a texture with a border is 3 */
   if (*height >= 3 && target != GL_TEXTURE_1D_ARRAY) {
      unpackNew->SkipRows++;  /* skip the border */
      *height = *height - 2;  /* reduce the height by two border pixels */
   }

   if (*depth >= 3 &&
       target != GL_TEXTURE_2D_ARRAY &&
       target != GL_TEXTURE_CUBE_MAP_ARRAY) {
      unpackNew->SkipImages++;  /* skip the border */
      *depth = *depth - 2;      /* reduce the depth by two border pixels */
   }
}


/**
 * Common code to implement all the glTexImage1D/2D/3D functions
 * as well as glCompressedTexImage1D/2D/3D.
 * \param compressed  only GL_TRUE for glCompressedTexImage1D/2D/3D calls.
 * \param format  the user's image format (only used if !compressed)
 * \param type  the user's image type (only used if !compressed)
 * \param imageSize  only used for glCompressedTexImage1D/2D/3D calls.
 */
static void
teximage(struct gl_context *ctx, GLboolean compressed, GLuint dims,
         GLenum target, GLint level, GLint internalFormat,
         GLsizei width, GLsizei height, GLsizei depth,
         GLint border, GLenum format, GLenum type,
         GLsizei imageSize, const GLvoid *pixels)
{
   const char *func = compressed ? "glCompressedTexImage" : "glTexImage";
   struct gl_pixelstore_attrib unpack_no_border;
   const struct gl_pixelstore_attrib *unpack = &ctx->Unpack;
   struct gl_texture_object *texObj;
   mesa_format texFormat;
   GLboolean dimensionsOK, sizeOK;

   FLUSH_VERTICES(ctx, 0);

   if (MESA_VERBOSE & (VERBOSE_API|VERBOSE_TEXTURE)) {
      if (compressed)
         _mesa_debug(ctx,
                     "glCompressedTexImage%uD %s %d %s %d %d %d %d %p\n",
                     dims,
                     _mesa_lookup_enum_by_nr(target), level,
                     _mesa_lookup_enum_by_nr(internalFormat),
                     width, height, depth, border, pixels);
      else
         _mesa_debug(ctx,
                     "glTexImage%uD %s %d %s %d %d %d %d %s %s %p\n",
                     dims,
                     _mesa_lookup_enum_by_nr(target), level,
                     _mesa_lookup_enum_by_nr(internalFormat),
                     width, height, depth, border,
                     _mesa_lookup_enum_by_nr(format),
                     _mesa_lookup_enum_by_nr(type), pixels);
   }

   internalFormat = override_internal_format(internalFormat, width, height);

   /* target error checking */
   if (!legal_teximage_target(ctx, dims, target)) {
      _mesa_error(ctx, GL_INVALID_ENUM, "%s%uD(target=%s)",
                  func, dims, _mesa_lookup_enum_by_nr(target));
      return;
   }

   /* general error checking */
   if (compressed) {
      if (compressed_texture_error_check(ctx, dims, target, level,
                                         internalFormat,
                                         width, height, depth,
                                         border, imageSize))
         return;
   }
   else {
      if (texture_error_check(ctx, dims, target, level, internalFormat,
                              format, type, width, height, depth, border))
         return;
   }

   /* Here we convert a cpal compressed image into a regular glTexImage2D
    * call by decompressing the texture.  If we really want to support cpal
    * textures in any driver this would have to be changed.
    */
   if (ctx->API == API_OPENGLES && compressed && dims == 2) {
      switch (internalFormat) {
      case GL_PALETTE4_RGB8_OES:
      case GL_PALETTE4_RGBA8_OES:
      case GL_PALETTE4_R5_G6_B5_OES:
      case GL_PALETTE4_RGBA4_OES:
      case GL_PALETTE4_RGB5_A1_OES:
      case GL_PALETTE8_RGB8_OES:
      case GL_PALETTE8_RGBA8_OES:
      case GL_PALETTE8_R5_G6_B5_OES:
      case GL_PALETTE8_RGBA4_OES:
      case GL_PALETTE8_RGB5_A1_OES:
         _mesa_cpal_compressed_teximage2d(target, level, internalFormat,
                                          width, height, imageSize, pixels);
         return;
      }
   }

   texObj = _mesa_get_current_tex_object(ctx, target);
   assert(texObj);

   if (compressed) {
      /* For glCompressedTexImage() the driver has no choice about the
       * texture format since we'll never transcode the user's compressed
       * image data.  The internalFormat was error checked earlier.
       */
      texFormat = _mesa_glenum_to_compressed_format(internalFormat);
   }
   else {
      texFormat = _mesa_choose_texture_format(ctx, texObj, target, level,
                                              internalFormat, format, type);
   }

   assert(texFormat != MESA_FORMAT_NONE);

   /* check that width, height, depth are legal for the mipmap level */
   dimensionsOK = _mesa_legal_texture_dimensions(ctx, target, level, width,
                                                 height, depth, border);

   /* check that the texture won't take too much memory, etc */
   sizeOK = ctx->Driver.TestProxyTexImage(ctx, proxy_target(target),
                                          level, texFormat,
                                          width, height, depth, border);

   if (_mesa_is_proxy_texture(target)) {
      /* Proxy texture: just clear or set state depending on error checking */
      struct gl_texture_image *texImage =
         get_proxy_tex_image(ctx, target, level);

      if (!texImage)
         return;  /* GL_OUT_OF_MEMORY already recorded */

      if (dimensionsOK && sizeOK) {
         _mesa_init_teximage_fields(ctx, texImage, width, height, depth,
                                    border, internalFormat, texFormat);
      }
      else {
         clear_teximage_fields(texImage);
      }
   }
   else {
      /* non-proxy target */
      const GLuint face = _mesa_tex_target_to_face(target);
      struct gl_texture_image *texImage;

      if (!dimensionsOK) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glTexImage%uD(invalid width or height or depth)",
                     dims);
         return;
      }

      if (!sizeOK) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY,
                     "glTexImage%uD(image too large)", dims);
         return;
      }

      /* Allow a hardware driver to just strip out the border, to provide
       * reliable but slightly incorrect hardware rendering instead of
       * rarely-tested software fallback rendering.
       */
      if (border && ctx->Const.StripTextureBorder) {
	 strip_texture_border(target, &width, &height, &depth, unpack,
			      &unpack_no_border);
         border = 0;
	 unpack = &unpack_no_border;
      }

      if (ctx->NewState & _NEW_PIXEL)
	 _mesa_update_state(ctx);

      _mesa_lock_texture(ctx, texObj);
      {
	 texImage = _mesa_get_tex_image(ctx, texObj, target, level);

	 if (!texImage) {
	    _mesa_error(ctx, GL_OUT_OF_MEMORY, "%s%uD", func, dims);
	 }
         else {
            ctx->Driver.FreeTextureImageBuffer(ctx, texImage);

            _mesa_init_teximage_fields(ctx, texImage,
                                       width, height, depth,
                                       border, internalFormat, texFormat);

            /* Give the texture to the driver.  <pixels> may be null. */
            if (width > 0 && height > 0 && depth > 0) {
               if (compressed) {
                  ctx->Driver.CompressedTexImage(ctx, dims, texImage,
                                                 imageSize, pixels);
               }
               else {
                  ctx->Driver.TexImage(ctx, dims, texImage, format,
                                       type, pixels, unpack);
               }
            }

            check_gen_mipmap(ctx, target, texObj, level);

            _mesa_update_fbo_texture(ctx, texObj, face, level);

            _mesa_dirty_texobj(ctx, texObj);
         }
      }
      _mesa_unlock_texture(ctx, texObj);
   }
}



/*
 * Called from the API.  Note that width includes the border.
 */
void GLAPIENTRY
_mesa_TexImage1D( GLenum target, GLint level, GLint internalFormat,
                  GLsizei width, GLint border, GLenum format,
                  GLenum type, const GLvoid *pixels )
{
   GET_CURRENT_CONTEXT(ctx);
   teximage(ctx, GL_FALSE, 1, target, level, internalFormat, width, 1, 1,
            border, format, type, 0, pixels);
}


void GLAPIENTRY
_mesa_TexImage2D( GLenum target, GLint level, GLint internalFormat,
                  GLsizei width, GLsizei height, GLint border,
                  GLenum format, GLenum type,
                  const GLvoid *pixels )
{
   GET_CURRENT_CONTEXT(ctx);
   teximage(ctx, GL_FALSE, 2, target, level, internalFormat, width, height, 1,
            border, format, type, 0, pixels);
}


/*
 * Called by the API or display list executor.
 * Note that width and height include the border.
 */
void GLAPIENTRY
_mesa_TexImage3D( GLenum target, GLint level, GLint internalFormat,
                  GLsizei width, GLsizei height, GLsizei depth,
                  GLint border, GLenum format, GLenum type,
                  const GLvoid *pixels )
{
   GET_CURRENT_CONTEXT(ctx);
   teximage(ctx, GL_FALSE, 3, target, level, internalFormat,
            width, height, depth,
            border, format, type, 0, pixels);
}


void GLAPIENTRY
_mesa_TexImage3DEXT( GLenum target, GLint level, GLenum internalFormat,
                     GLsizei width, GLsizei height, GLsizei depth,
                     GLint border, GLenum format, GLenum type,
                     const GLvoid *pixels )
{
   _mesa_TexImage3D(target, level, (GLint) internalFormat, width, height,
                    depth, border, format, type, pixels);
}


void GLAPIENTRY
_mesa_EGLImageTargetTexture2DOES (GLenum target, GLeglImageOES image)
{
   struct gl_texture_object *texObj;
   struct gl_texture_image *texImage;
   bool valid_target;
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);

   switch (target) {
   case GL_TEXTURE_2D:
      valid_target = ctx->Extensions.OES_EGL_image;
      break;
   case GL_TEXTURE_EXTERNAL_OES:
      valid_target =
         _mesa_is_gles(ctx) ? ctx->Extensions.OES_EGL_image_external : false;
      break;
   default:
      valid_target = false;
      break;
   }

   if (!valid_target) {
      _mesa_error(ctx, GL_INVALID_ENUM,
		  "glEGLImageTargetTexture2D(target=%d)", target);
      return;
   }

   if (!image) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
		  "glEGLImageTargetTexture2D(image=%p)", image);
      return;
   }

   if (ctx->NewState & _NEW_PIXEL)
      _mesa_update_state(ctx);

   texObj = _mesa_get_current_tex_object(ctx, target);
   _mesa_lock_texture(ctx, texObj);

   if (texObj->Immutable) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
		  "glEGLImageTargetTexture2D(texture is immutable)");
      _mesa_unlock_texture(ctx, texObj);
      return;
   }

   texImage = _mesa_get_tex_image(ctx, texObj, target, 0);
   if (!texImage) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glEGLImageTargetTexture2D");
   } else {
      ctx->Driver.FreeTextureImageBuffer(ctx, texImage);

      ctx->Driver.EGLImageTargetTexture2D(ctx, target,
					  texObj, texImage, image);

      _mesa_dirty_texobj(ctx, texObj);
   }
   _mesa_unlock_texture(ctx, texObj);

}



/**
 * Implement all the glTexSubImage1/2/3D() functions.
 */
static void
texsubimage(struct gl_context *ctx, GLuint dims, GLenum target, GLint level,
            GLint xoffset, GLint yoffset, GLint zoffset,
            GLsizei width, GLsizei height, GLsizei depth,
            GLenum format, GLenum type, const GLvoid *pixels )
{
   struct gl_texture_object *texObj;
   struct gl_texture_image *texImage;

   FLUSH_VERTICES(ctx, 0);

   if (MESA_VERBOSE & (VERBOSE_API|VERBOSE_TEXTURE))
      _mesa_debug(ctx, "glTexSubImage%uD %s %d %d %d %d %d %d %d %s %s %p\n",
                  dims,
                  _mesa_lookup_enum_by_nr(target), level,
                  xoffset, yoffset, zoffset, width, height, depth,
                  _mesa_lookup_enum_by_nr(format),
                  _mesa_lookup_enum_by_nr(type), pixels);

   /* check target (proxies not allowed) */
   if (!legal_texsubimage_target(ctx, dims, target)) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glTexSubImage%uD(target=%s)",
                  dims, _mesa_lookup_enum_by_nr(target));
      return;
   }

   if (ctx->NewState & _NEW_PIXEL)
      _mesa_update_state(ctx);

   if (texsubimage_error_check(ctx, dims, target, level,
                               xoffset, yoffset, zoffset,
                               width, height, depth, format, type)) {
      return;   /* error was detected */
   }

   texObj = _mesa_get_current_tex_object(ctx, target);

   _mesa_lock_texture(ctx, texObj);
   {
      texImage = _mesa_select_tex_image(ctx, texObj, target, level);

      if (width > 0 && height > 0 && depth > 0) {
         /* If we have a border, offset=-1 is legal.  Bias by border width. */
         switch (dims) {
         case 3:
            if (target != GL_TEXTURE_2D_ARRAY)
               zoffset += texImage->Border;
            /* fall-through */
         case 2:
            if (target != GL_TEXTURE_1D_ARRAY)
               yoffset += texImage->Border;
            /* fall-through */
         case 1:
            xoffset += texImage->Border;
         }

         ctx->Driver.TexSubImage(ctx, dims, texImage,
                                 xoffset, yoffset, zoffset,
                                 width, height, depth,
                                 format, type, pixels, &ctx->Unpack);

         check_gen_mipmap(ctx, target, texObj, level);

         /* NOTE: Don't signal _NEW_TEXTURE since we've only changed
          * the texel data, not the texture format, size, etc.
          */
      }
   }
   _mesa_unlock_texture(ctx, texObj);
}


void GLAPIENTRY
_mesa_TexSubImage1D( GLenum target, GLint level,
                     GLint xoffset, GLsizei width,
                     GLenum format, GLenum type,
                     const GLvoid *pixels )
{
   GET_CURRENT_CONTEXT(ctx);
   texsubimage(ctx, 1, target, level,
               xoffset, 0, 0,
               width, 1, 1,
               format, type, pixels);
}


void GLAPIENTRY
_mesa_TexSubImage2D( GLenum target, GLint level,
                     GLint xoffset, GLint yoffset,
                     GLsizei width, GLsizei height,
                     GLenum format, GLenum type,
                     const GLvoid *pixels )
{
   GET_CURRENT_CONTEXT(ctx);
   texsubimage(ctx, 2, target, level,
               xoffset, yoffset, 0,
               width, height, 1,
               format, type, pixels);
}



void GLAPIENTRY
_mesa_TexSubImage3D( GLenum target, GLint level,
                     GLint xoffset, GLint yoffset, GLint zoffset,
                     GLsizei width, GLsizei height, GLsizei depth,
                     GLenum format, GLenum type,
                     const GLvoid *pixels )
{
   GET_CURRENT_CONTEXT(ctx);
   texsubimage(ctx, 3, target, level,
               xoffset, yoffset, zoffset,
               width, height, depth,
               format, type, pixels);
}



/**
 * For glCopyTexSubImage, return the source renderbuffer to copy texel data
 * from.  This depends on whether the texture contains color or depth values.
 */
static struct gl_renderbuffer *
get_copy_tex_image_source(struct gl_context *ctx, mesa_format texFormat)
{
   if (_mesa_get_format_bits(texFormat, GL_DEPTH_BITS) > 0) {
      /* reading from depth/stencil buffer */
      return ctx->ReadBuffer->Attachment[BUFFER_DEPTH].Renderbuffer;
   }
   else {
      /* copying from color buffer */
      return ctx->ReadBuffer->_ColorReadBuffer;
   }
}

static void
copytexsubimage_by_slice(struct gl_context *ctx,
                         struct gl_texture_image *texImage,
                         GLuint dims,
                         GLint xoffset, GLint yoffset, GLint zoffset,
                         struct gl_renderbuffer *rb,
                         GLint x, GLint y,
                         GLsizei width, GLsizei height)
{
   if (texImage->TexObject->Target == GL_TEXTURE_1D_ARRAY) {
      int slice;

      /* For 1D arrays, we copy each scanline of the source rectangle into the
       * next array slice.
       */
      assert(zoffset == 0);

      for (slice = 0; slice < height; slice++) {
         assert(yoffset + slice < texImage->Height);
         ctx->Driver.CopyTexSubImage(ctx, 2, texImage,
                                     xoffset, 0, yoffset + slice,
                                     rb, x, y + slice, width, 1);
      }
   } else {
      ctx->Driver.CopyTexSubImage(ctx, dims, texImage,
                                  xoffset, yoffset, zoffset,
                                  rb, x, y, width, height);
   }
}

static GLboolean
formats_differ_in_component_sizes (mesa_format f1,
                                   mesa_format f2)
{
   GLint f1_r_bits = _mesa_get_format_bits(f1, GL_RED_BITS);
   GLint f1_g_bits = _mesa_get_format_bits(f1, GL_GREEN_BITS);
   GLint f1_b_bits = _mesa_get_format_bits(f1, GL_BLUE_BITS);
   GLint f1_a_bits = _mesa_get_format_bits(f1, GL_ALPHA_BITS);

   GLint f2_r_bits = _mesa_get_format_bits(f2, GL_RED_BITS);
   GLint f2_g_bits = _mesa_get_format_bits(f2, GL_GREEN_BITS);
   GLint f2_b_bits = _mesa_get_format_bits(f2, GL_BLUE_BITS);
   GLint f2_a_bits = _mesa_get_format_bits(f2, GL_ALPHA_BITS);

   if ((f1_r_bits && f2_r_bits && f1_r_bits != f2_r_bits)
       || (f1_g_bits && f2_g_bits && f1_g_bits != f2_g_bits)
       || (f1_b_bits && f2_b_bits && f1_b_bits != f2_b_bits)
       || (f1_a_bits && f2_a_bits && f1_a_bits != f2_a_bits))
      return GL_TRUE;

   return GL_FALSE;
}

/**
 * Implement the glCopyTexImage1/2D() functions.
 */
static void
copyteximage(struct gl_context *ctx, GLuint dims,
             GLenum target, GLint level, GLenum internalFormat,
             GLint x, GLint y, GLsizei width, GLsizei height, GLint border )
{
   struct gl_texture_object *texObj;
   struct gl_texture_image *texImage;
   const GLuint face = _mesa_tex_target_to_face(target);
   mesa_format texFormat;
   struct gl_renderbuffer *rb;

   FLUSH_VERTICES(ctx, 0);

   if (MESA_VERBOSE & (VERBOSE_API|VERBOSE_TEXTURE))
      _mesa_debug(ctx, "glCopyTexImage%uD %s %d %s %d %d %d %d %d\n",
                  dims,
                  _mesa_lookup_enum_by_nr(target), level,
                  _mesa_lookup_enum_by_nr(internalFormat),
                  x, y, width, height, border);

   if (ctx->NewState & NEW_COPY_TEX_STATE)
      _mesa_update_state(ctx);

   if (copytexture_error_check(ctx, dims, target, level, internalFormat,
                               width, height, border))
      return;

   if (!_mesa_legal_texture_dimensions(ctx, target, level, width, height,
                                       1, border)) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glCopyTexImage%uD(invalid width or height)", dims);
      return;
   }

   texObj = _mesa_get_current_tex_object(ctx, target);
   assert(texObj);

   texFormat = _mesa_choose_texture_format(ctx, texObj, target, level,
                                           internalFormat, GL_NONE, GL_NONE);

   rb = _mesa_get_read_renderbuffer_for_format(ctx, internalFormat);

   if (_mesa_is_gles3(ctx)) {
      if (_mesa_is_enum_format_unsized(internalFormat)) {
      /* Conversion from GL_RGB10_A2 source buffer format is not allowed in
       * OpenGL ES 3.0. Khronos bug# 9807.
       */
         if (rb->InternalFormat == GL_RGB10_A2) {
               _mesa_error(ctx, GL_INVALID_OPERATION,
                           "glCopyTexImage%uD(Reading from GL_RGB10_A2 buffer and"
                           " writing to unsized internal format)", dims);
               return;
         }
      }
      /* From Page 139 of OpenGL ES 3.0 spec:
       *    "If internalformat is sized, the internal format of the new texel
       *    array is internalformat, and this is also the new texel array’s
       *    effective internal format. If the component sizes of internalformat
       *    do not exactly match the corresponding component sizes of the source
       *    buffer’s effective internal format, described below, an
       *    INVALID_OPERATION error is generated. If internalformat is unsized,
       *    the internal format of the new texel array is the effective internal
       *    format of the source buffer, and this is also the new texel array’s
       *    effective internal format.
       */
      else if (formats_differ_in_component_sizes (texFormat, rb->Format)) {
            _mesa_error(ctx, GL_INVALID_OPERATION,
                        "glCopyTexImage%uD(componenet size changed in"
                        " internal format)", dims);
            return;
      }
   }

   assert(texFormat != MESA_FORMAT_NONE);

   if (!ctx->Driver.TestProxyTexImage(ctx, proxy_target(target),
                                      level, texFormat,
                                      width, height, 1, border)) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY,
                  "glCopyTexImage%uD(image too large)", dims);
      return;
   }

   if (border && ctx->Const.StripTextureBorder) {
      x += border;
      width -= border * 2;
      if (dims == 2) {
	 y += border;
	 height -= border * 2;
      }
      border = 0;
   }

   _mesa_lock_texture(ctx, texObj);
   {
      texImage = _mesa_get_tex_image(ctx, texObj, target, level);

      if (!texImage) {
	 _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCopyTexImage%uD", dims);
      }
      else {
         GLint srcX = x, srcY = y, dstX = 0, dstY = 0, dstZ = 0;

         /* Free old texture image */
         ctx->Driver.FreeTextureImageBuffer(ctx, texImage);

         _mesa_init_teximage_fields(ctx, texImage, width, height, 1,
                                    border, internalFormat, texFormat);

         if (width && height) {
            /* Allocate texture memory (no pixel data yet) */
            ctx->Driver.AllocTextureImageBuffer(ctx, texImage);

            if (_mesa_clip_copytexsubimage(ctx, &dstX, &dstY, &srcX, &srcY,
                                           &width, &height)) {
               struct gl_renderbuffer *srcRb =
                  get_copy_tex_image_source(ctx, texImage->TexFormat);

               copytexsubimage_by_slice(ctx, texImage, dims,
                                        dstX, dstY, dstZ,
                                        srcRb, srcX, srcY, width, height);
            }

            check_gen_mipmap(ctx, target, texObj, level);
         }

         _mesa_update_fbo_texture(ctx, texObj, face, level);

         _mesa_dirty_texobj(ctx, texObj);
      }
   }
   _mesa_unlock_texture(ctx, texObj);
}



void GLAPIENTRY
_mesa_CopyTexImage1D( GLenum target, GLint level,
                      GLenum internalFormat,
                      GLint x, GLint y,
                      GLsizei width, GLint border )
{
   GET_CURRENT_CONTEXT(ctx);
   copyteximage(ctx, 1, target, level, internalFormat, x, y, width, 1, border);
}



void GLAPIENTRY
_mesa_CopyTexImage2D( GLenum target, GLint level, GLenum internalFormat,
                      GLint x, GLint y, GLsizei width, GLsizei height,
                      GLint border )
{
   GET_CURRENT_CONTEXT(ctx);
   copyteximage(ctx, 2, target, level, internalFormat,
                x, y, width, height, border);
}



/**
 * Implementation for glCopyTexSubImage1/2/3D() functions.
 */
static void
copytexsubimage(struct gl_context *ctx, GLuint dims, GLenum target, GLint level,
                GLint xoffset, GLint yoffset, GLint zoffset,
                GLint x, GLint y, GLsizei width, GLsizei height)
{
   struct gl_texture_object *texObj;
   struct gl_texture_image *texImage;

   FLUSH_VERTICES(ctx, 0);

   if (MESA_VERBOSE & (VERBOSE_API|VERBOSE_TEXTURE))
      _mesa_debug(ctx, "glCopyTexSubImage%uD %s %d %d %d %d %d %d %d %d\n",
                  dims,
                  _mesa_lookup_enum_by_nr(target),
                  level, xoffset, yoffset, zoffset, x, y, width, height);

   if (ctx->NewState & NEW_COPY_TEX_STATE)
      _mesa_update_state(ctx);

   if (copytexsubimage_error_check(ctx, dims, target, level,
                                   xoffset, yoffset, zoffset, width, height)) {
      return;
   }

   texObj = _mesa_get_current_tex_object(ctx, target);

   _mesa_lock_texture(ctx, texObj);
   {
      texImage = _mesa_select_tex_image(ctx, texObj, target, level);

      /* If we have a border, offset=-1 is legal.  Bias by border width. */
      switch (dims) {
      case 3:
         if (target != GL_TEXTURE_2D_ARRAY)
            zoffset += texImage->Border;
         /* fall-through */
      case 2:
         if (target != GL_TEXTURE_1D_ARRAY)
            yoffset += texImage->Border;
         /* fall-through */
      case 1:
         xoffset += texImage->Border;
      }

      if (_mesa_clip_copytexsubimage(ctx, &xoffset, &yoffset, &x, &y,
                                     &width, &height)) {
         struct gl_renderbuffer *srcRb =
            get_copy_tex_image_source(ctx, texImage->TexFormat);

         copytexsubimage_by_slice(ctx, texImage, dims,
                                  xoffset, yoffset, zoffset,
                                  srcRb, x, y, width, height);

         check_gen_mipmap(ctx, target, texObj, level);

         /* NOTE: Don't signal _NEW_TEXTURE since we've only changed
          * the texel data, not the texture format, size, etc.
          */
      }
   }
   _mesa_unlock_texture(ctx, texObj);
}


void GLAPIENTRY
_mesa_CopyTexSubImage1D( GLenum target, GLint level,
                         GLint xoffset, GLint x, GLint y, GLsizei width )
{
   GET_CURRENT_CONTEXT(ctx);
   copytexsubimage(ctx, 1, target, level, xoffset, 0, 0, x, y, width, 1);
}



void GLAPIENTRY
_mesa_CopyTexSubImage2D( GLenum target, GLint level,
                         GLint xoffset, GLint yoffset,
                         GLint x, GLint y, GLsizei width, GLsizei height )
{
   GET_CURRENT_CONTEXT(ctx);
   copytexsubimage(ctx, 2, target, level, xoffset, yoffset, 0, x, y,
                   width, height);
}



void GLAPIENTRY
_mesa_CopyTexSubImage3D( GLenum target, GLint level,
                         GLint xoffset, GLint yoffset, GLint zoffset,
                         GLint x, GLint y, GLsizei width, GLsizei height )
{
   GET_CURRENT_CONTEXT(ctx);
   copytexsubimage(ctx, 3, target, level, xoffset, yoffset, zoffset,
                   x, y, width, height);
}




/**********************************************************************/
/******                   Compressed Textures                    ******/
/**********************************************************************/


/**
 * Error checking for glCompressedTexSubImage[123]D().
 * \return error code or GL_NO_ERROR.
 */
static GLenum
compressed_subtexture_error_check(struct gl_context *ctx, GLint dims,
                                  GLenum target, GLint level,
                                  GLint xoffset, GLint yoffset, GLint zoffset,
                                  GLsizei width, GLsizei height, GLsizei depth,
                                  GLenum format, GLsizei imageSize)
{
   struct gl_texture_object *texObj;
   struct gl_texture_image *texImage;
   GLint expectedSize;
   GLboolean targetOK;

   switch (dims) {
   case 2:
      switch (target) {
      case GL_TEXTURE_2D:
      case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
      case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
      case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
         targetOK = GL_TRUE;
         break;
      default:
         targetOK = GL_FALSE;
         break;
      }
      break;
   case 3:
      targetOK = (target == GL_TEXTURE_2D_ARRAY);
      break;
   default:
      assert(dims == 1);
      /* no 1D compressed textures at this time */
      targetOK = GL_FALSE;
      break;
   }

   if (!targetOK) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glCompressedTexImage%uD(target)",
                  dims);
      return GL_TRUE;
   }

   /* this will catch any invalid compressed format token */
   if (!_mesa_is_compressed_format(ctx, format)) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glCompressedTexImage%uD(format)",
                  dims);
      return GL_TRUE;
   }

   if (level < 0 || level >= _mesa_max_texture_levels(ctx, target)) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glCompressedTexImage%uD(level=%d)",
                  dims, level);
      return GL_TRUE;
   }

   expectedSize = compressed_tex_size(width, height, depth, format);
   if (expectedSize != imageSize) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glCompressedTexImage%uD(size=%d)",
                  dims, imageSize);
      return GL_TRUE;
   }

   texObj = _mesa_get_current_tex_object(ctx, target);
   if (!texObj) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY,
                  "glCompressedTexSubImage%uD()", dims);
      return GL_TRUE;
   }

   texImage = _mesa_select_tex_image(ctx, texObj, target, level);
   if (!texImage) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glCompressedTexSubImage%uD(invalid texture image)", dims);
      return GL_TRUE;
   }

   if ((GLint) format != texImage->InternalFormat) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glCompressedTexSubImage%uD(format=0x%x)", dims, format);
      return GL_TRUE;
   }

   if (compressedteximage_only_format(ctx, format)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glCompressedTexSubImage%uD(format=0x%x cannot be updated)"
                  , dims, format);
      return GL_TRUE;
   }

   if (error_check_subtexture_dimensions(ctx, "glCompressedTexSubImage", dims,
                                         texImage, xoffset, yoffset, zoffset,
                                         width, height, depth)) {
      return GL_TRUE;
   }

   return GL_FALSE;
}


void GLAPIENTRY
_mesa_CompressedTexImage1D(GLenum target, GLint level,
                              GLenum internalFormat, GLsizei width,
                              GLint border, GLsizei imageSize,
                              const GLvoid *data)
{
   GET_CURRENT_CONTEXT(ctx);
   teximage(ctx, GL_TRUE, 1, target, level, internalFormat,
            width, 1, 1, border, GL_NONE, GL_NONE, imageSize, data);
}


void GLAPIENTRY
_mesa_CompressedTexImage2D(GLenum target, GLint level,
                              GLenum internalFormat, GLsizei width,
                              GLsizei height, GLint border, GLsizei imageSize,
                              const GLvoid *data)
{
   GET_CURRENT_CONTEXT(ctx);
   teximage(ctx, GL_TRUE, 2, target, level, internalFormat,
            width, height, 1, border, GL_NONE, GL_NONE, imageSize, data);
}


void GLAPIENTRY
_mesa_CompressedTexImage3D(GLenum target, GLint level,
                              GLenum internalFormat, GLsizei width,
                              GLsizei height, GLsizei depth, GLint border,
                              GLsizei imageSize, const GLvoid *data)
{
   GET_CURRENT_CONTEXT(ctx);
   teximage(ctx, GL_TRUE, 3, target, level, internalFormat,
            width, height, depth, border, GL_NONE, GL_NONE, imageSize, data);
}


/**
 * Common helper for glCompressedTexSubImage1/2/3D().
 */
static void
compressed_tex_sub_image(GLuint dims, GLenum target, GLint level,
                         GLint xoffset, GLint yoffset, GLint zoffset,
                         GLsizei width, GLsizei height, GLsizei depth,
                         GLenum format, GLsizei imageSize, const GLvoid *data)
{
   struct gl_texture_object *texObj;
   struct gl_texture_image *texImage;
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);

   if (compressed_subtexture_error_check(ctx, dims, target, level,
                                         xoffset, yoffset, zoffset,
                                         width, height, depth,
                                         format, imageSize)) {
      return;
   }

   texObj = _mesa_get_current_tex_object(ctx, target);

   _mesa_lock_texture(ctx, texObj);
   {
      texImage = _mesa_select_tex_image(ctx, texObj, target, level);
      assert(texImage);

      if (width > 0 && height > 0 && depth > 0) {
         ctx->Driver.CompressedTexSubImage(ctx, dims, texImage,
                                           xoffset, yoffset, zoffset,
                                           width, height, depth,
                                           format, imageSize, data);

         check_gen_mipmap(ctx, target, texObj, level);

         /* NOTE: Don't signal _NEW_TEXTURE since we've only changed
          * the texel data, not the texture format, size, etc.
          */
      }
   }
   _mesa_unlock_texture(ctx, texObj);
}


void GLAPIENTRY
_mesa_CompressedTexSubImage1D(GLenum target, GLint level, GLint xoffset,
                                 GLsizei width, GLenum format,
                                 GLsizei imageSize, const GLvoid *data)
{
   compressed_tex_sub_image(1, target, level, xoffset, 0, 0, width, 1, 1,
                            format, imageSize, data);
}


void GLAPIENTRY
_mesa_CompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset,
                                 GLint yoffset, GLsizei width, GLsizei height,
                                 GLenum format, GLsizei imageSize,
                                 const GLvoid *data)
{
   compressed_tex_sub_image(2, target, level, xoffset, yoffset, 0,
                            width, height, 1, format, imageSize, data);
}


void GLAPIENTRY
_mesa_CompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset,
                                 GLint yoffset, GLint zoffset, GLsizei width,
                                 GLsizei height, GLsizei depth, GLenum format,
                                 GLsizei imageSize, const GLvoid *data)
{
   compressed_tex_sub_image(3, target, level, xoffset, yoffset, zoffset,
                            width, height, depth, format, imageSize, data);
}

static mesa_format
get_texbuffer_format(const struct gl_context *ctx, GLenum internalFormat)
{
   if (ctx->API != API_OPENGL_CORE) {
      switch (internalFormat) {
      case GL_ALPHA8:
         return MESA_FORMAT_A_UNORM8;
      case GL_ALPHA16:
         return MESA_FORMAT_A_UNORM16;
      case GL_ALPHA16F_ARB:
         return MESA_FORMAT_A_FLOAT16;
      case GL_ALPHA32F_ARB:
         return MESA_FORMAT_A_FLOAT32;
      case GL_ALPHA8I_EXT:
         return MESA_FORMAT_A_SINT8;
      case GL_ALPHA16I_EXT:
         return MESA_FORMAT_A_SINT16;
      case GL_ALPHA32I_EXT:
         return MESA_FORMAT_A_SINT32;
      case GL_ALPHA8UI_EXT:
         return MESA_FORMAT_A_UINT8;
      case GL_ALPHA16UI_EXT:
         return MESA_FORMAT_A_UINT16;
      case GL_ALPHA32UI_EXT:
         return MESA_FORMAT_A_UINT32;
      case GL_LUMINANCE8:
         return MESA_FORMAT_L_UNORM8;
      case GL_LUMINANCE16:
         return MESA_FORMAT_L_UNORM16;
      case GL_LUMINANCE16F_ARB:
         return MESA_FORMAT_L_FLOAT16;
      case GL_LUMINANCE32F_ARB:
         return MESA_FORMAT_L_FLOAT32;
      case GL_LUMINANCE8I_EXT:
         return MESA_FORMAT_L_SINT8;
      case GL_LUMINANCE16I_EXT:
         return MESA_FORMAT_L_SINT16;
      case GL_LUMINANCE32I_EXT:
         return MESA_FORMAT_L_SINT32;
      case GL_LUMINANCE8UI_EXT:
         return MESA_FORMAT_L_UINT8;
      case GL_LUMINANCE16UI_EXT:
         return MESA_FORMAT_L_UINT16;
      case GL_LUMINANCE32UI_EXT:
         return MESA_FORMAT_L_UINT32;
      case GL_LUMINANCE8_ALPHA8:
         return MESA_FORMAT_L8A8_UNORM;
      case GL_LUMINANCE16_ALPHA16:
         return MESA_FORMAT_L16A16_UNORM;
      case GL_LUMINANCE_ALPHA16F_ARB:
         return MESA_FORMAT_LA_FLOAT16;
      case GL_LUMINANCE_ALPHA32F_ARB:
         return MESA_FORMAT_LA_FLOAT32;
      case GL_LUMINANCE_ALPHA8I_EXT:
         return MESA_FORMAT_LA_SINT8;
      case GL_LUMINANCE_ALPHA16I_EXT:
         return MESA_FORMAT_LA_SINT8;
      case GL_LUMINANCE_ALPHA32I_EXT:
         return MESA_FORMAT_LA_SINT16;
      case GL_LUMINANCE_ALPHA8UI_EXT:
         return MESA_FORMAT_LA_UINT8;
      case GL_LUMINANCE_ALPHA16UI_EXT:
         return MESA_FORMAT_LA_UINT16;
      case GL_LUMINANCE_ALPHA32UI_EXT:
         return MESA_FORMAT_LA_UINT32;
      case GL_INTENSITY8:
         return MESA_FORMAT_I_UNORM8;
      case GL_INTENSITY16:
         return MESA_FORMAT_I_UNORM16;
      case GL_INTENSITY16F_ARB:
         return MESA_FORMAT_I_FLOAT16;
      case GL_INTENSITY32F_ARB:
         return MESA_FORMAT_I_FLOAT32;
      case GL_INTENSITY8I_EXT:
         return MESA_FORMAT_I_SINT8;
      case GL_INTENSITY16I_EXT:
         return MESA_FORMAT_I_SINT16;
      case GL_INTENSITY32I_EXT:
         return MESA_FORMAT_I_SINT32;
      case GL_INTENSITY8UI_EXT:
         return MESA_FORMAT_I_UINT8;
      case GL_INTENSITY16UI_EXT:
         return MESA_FORMAT_I_UINT16;
      case GL_INTENSITY32UI_EXT:
         return MESA_FORMAT_I_UINT32;
      default:
         break;
      }
   }

   if (ctx->API == API_OPENGL_CORE &&
       ctx->Extensions.ARB_texture_buffer_object_rgb32) {
      switch (internalFormat) {
      case GL_RGB32F:
         return MESA_FORMAT_RGB_FLOAT32;
      case GL_RGB32UI:
         return MESA_FORMAT_RGB_UINT32;
      case GL_RGB32I:
         return MESA_FORMAT_RGB_SINT32;
      default:
         break;
      }
   }

   switch (internalFormat) {
   case GL_RGBA8:
      return MESA_FORMAT_R8G8B8A8_UNORM;
   case GL_RGBA16:
      return MESA_FORMAT_RGBA_UNORM16;
   case GL_RGBA16F_ARB:
      return MESA_FORMAT_RGBA_FLOAT16;
   case GL_RGBA32F_ARB:
      return MESA_FORMAT_RGBA_FLOAT32;
   case GL_RGBA8I_EXT:
      return MESA_FORMAT_RGBA_SINT8;
   case GL_RGBA16I_EXT:
      return MESA_FORMAT_RGBA_SINT16;
   case GL_RGBA32I_EXT:
      return MESA_FORMAT_RGBA_SINT32;
   case GL_RGBA8UI_EXT:
      return MESA_FORMAT_RGBA_UINT8;
   case GL_RGBA16UI_EXT:
      return MESA_FORMAT_RGBA_UINT16;
   case GL_RGBA32UI_EXT:
      return MESA_FORMAT_RGBA_UINT32;

   case GL_RG8:
      return MESA_FORMAT_R8G8_UNORM;
   case GL_RG16:
      return MESA_FORMAT_R16G16_UNORM;
   case GL_RG16F:
      return MESA_FORMAT_RG_FLOAT16;
   case GL_RG32F:
      return MESA_FORMAT_RG_FLOAT32;
   case GL_RG8I:
      return MESA_FORMAT_RG_SINT8;
   case GL_RG16I:
      return MESA_FORMAT_RG_SINT16;
   case GL_RG32I:
      return MESA_FORMAT_RG_SINT32;
   case GL_RG8UI:
      return MESA_FORMAT_RG_UINT8;
   case GL_RG16UI:
      return MESA_FORMAT_RG_UINT16;
   case GL_RG32UI:
      return MESA_FORMAT_RG_UINT32;

   case GL_R8:
      return MESA_FORMAT_R_UNORM8;
   case GL_R16:
      return MESA_FORMAT_R_UNORM16;
   case GL_R16F:
      return MESA_FORMAT_R_FLOAT16;
   case GL_R32F:
      return MESA_FORMAT_R_FLOAT32;
   case GL_R8I:
      return MESA_FORMAT_R_SINT8;
   case GL_R16I:
      return MESA_FORMAT_R_SINT16;
   case GL_R32I:
      return MESA_FORMAT_R_SINT32;
   case GL_R8UI:
      return MESA_FORMAT_R_UINT8;
   case GL_R16UI:
      return MESA_FORMAT_R_UINT16;
   case GL_R32UI:
      return MESA_FORMAT_R_UINT32;

   default:
      return MESA_FORMAT_NONE;
   }
}


mesa_format
_mesa_validate_texbuffer_format(const struct gl_context *ctx,
                                GLenum internalFormat)
{
   mesa_format format = get_texbuffer_format(ctx, internalFormat);
   GLenum datatype;

   if (format == MESA_FORMAT_NONE)
      return MESA_FORMAT_NONE;

   datatype = _mesa_get_format_datatype(format);

   /* The GL_ARB_texture_buffer_object spec says:
    *
    *     "If ARB_texture_float is not supported, references to the
    *     floating-point internal formats provided by that extension should be
    *     removed, and such formats may not be passed to TexBufferARB."
    *
    * As a result, GL_HALF_FLOAT internal format depends on both
    * GL_ARB_texture_float and GL_ARB_half_float_pixel.
    */
   if ((datatype == GL_FLOAT || datatype == GL_HALF_FLOAT) &&
       !ctx->Extensions.ARB_texture_float)
      return MESA_FORMAT_NONE;

   if (!ctx->Extensions.ARB_texture_rg) {
      GLenum base_format = _mesa_get_format_base_format(format);
      if (base_format == GL_R || base_format == GL_RG)
         return MESA_FORMAT_NONE;
   }

   if (!ctx->Extensions.ARB_texture_buffer_object_rgb32) {
      GLenum base_format = _mesa_get_format_base_format(format);
      if (base_format == GL_RGB)
         return MESA_FORMAT_NONE;
   }
   return format;
}


static void
texbufferrange(struct gl_context *ctx, GLenum target, GLenum internalFormat,
               struct gl_buffer_object *bufObj,
               GLintptr offset, GLsizeiptr size)
{
   struct gl_texture_object *texObj;
   mesa_format format;

   FLUSH_VERTICES(ctx, 0);

   if (target != GL_TEXTURE_BUFFER_ARB) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glTexBuffer(target)");
      return;
   }

   format = _mesa_validate_texbuffer_format(ctx, internalFormat);
   if (format == MESA_FORMAT_NONE) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glTexBuffer(internalFormat 0x%x)",
                  internalFormat);
      return;
   }

   texObj = _mesa_get_current_tex_object(ctx, target);

   _mesa_lock_texture(ctx, texObj);
   {
      _mesa_reference_buffer_object(ctx, &texObj->BufferObject, bufObj);
      texObj->BufferObjectFormat = internalFormat;
      texObj->_BufferObjectFormat = format;
      texObj->BufferOffset = offset;
      texObj->BufferSize = size;
   }
   _mesa_unlock_texture(ctx, texObj);
}


/** GL_ARB_texture_buffer_object */
void GLAPIENTRY
_mesa_TexBuffer(GLenum target, GLenum internalFormat, GLuint buffer)
{
   struct gl_buffer_object *bufObj;

   GET_CURRENT_CONTEXT(ctx);

   /* NOTE: ARB_texture_buffer_object has interactions with
    * the compatibility profile that are not implemented.
    */
   if (!(ctx->API == API_OPENGL_CORE &&
         ctx->Extensions.ARB_texture_buffer_object)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glTexBuffer");
      return;
   }

   bufObj = _mesa_lookup_bufferobj(ctx, buffer);
   if (!bufObj && buffer) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glTexBuffer(buffer %u)", buffer);
      return;
   }

   texbufferrange(ctx, target, internalFormat, bufObj, 0, buffer ? -1 : 0);
}


/** GL_ARB_texture_buffer_range */
void GLAPIENTRY
_mesa_TexBufferRange(GLenum target, GLenum internalFormat, GLuint buffer,
                     GLintptr offset, GLsizeiptr size)
{
   struct gl_buffer_object *bufObj;

   GET_CURRENT_CONTEXT(ctx);

   if (!(ctx->API == API_OPENGL_CORE &&
         ctx->Extensions.ARB_texture_buffer_range)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glTexBufferRange");
      return;
   }

   bufObj = _mesa_lookup_bufferobj(ctx, buffer);
   if (bufObj) {
      if (offset < 0 ||
          size <= 0 ||
          (offset + size) > bufObj->Size) {
         _mesa_error(ctx, GL_INVALID_VALUE, "glTexBufferRange");
         return;
      }
      if (offset % ctx->Const.TextureBufferOffsetAlignment) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glTexBufferRange(invalid offset alignment)");
         return;
      }
   } else if (buffer) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glTexBufferRange(buffer %u)",
                  buffer);
      return;
   } else {
      offset = 0;
      size = 0;
   }

   texbufferrange(ctx, target, internalFormat, bufObj, offset, size);
}


static GLboolean
is_renderable_texture_format(struct gl_context *ctx, GLenum internalformat)
{
   /* Everything that is allowed for renderbuffers,
    * except for a base format of GL_STENCIL_INDEX.
    */
   GLenum baseFormat = _mesa_base_fbo_format(ctx, internalformat);
   return baseFormat != 0 && baseFormat != GL_STENCIL_INDEX;
}


/** GL_ARB_texture_multisample */
static GLboolean
check_multisample_target(GLuint dims, GLenum target)
{
   switch(target) {
   case GL_TEXTURE_2D_MULTISAMPLE:
   case GL_PROXY_TEXTURE_2D_MULTISAMPLE:
      return dims == 2;

   case GL_TEXTURE_2D_MULTISAMPLE_ARRAY:
   case GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY:
      return dims == 3;

   default:
      return GL_FALSE;
   }
}


static void
teximagemultisample(GLuint dims, GLenum target, GLsizei samples,
                    GLint internalformat, GLsizei width, GLsizei height,
                    GLsizei depth, GLboolean fixedsamplelocations,
                    GLboolean immutable, const char *func)
{
   struct gl_texture_object *texObj;
   struct gl_texture_image *texImage;
   GLboolean sizeOK, dimensionsOK, samplesOK;
   mesa_format texFormat;
   GLenum sample_count_error;

   GET_CURRENT_CONTEXT(ctx);

   if (!(ctx->Extensions.ARB_texture_multisample
      && _mesa_is_desktop_gl(ctx))) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "%s(unsupported)", func);
      return;
   }

   if (!check_multisample_target(dims, target)) {
      _mesa_error(ctx, GL_INVALID_ENUM, "%s(target)", func);
      return;
   }

   /* check that the specified internalformat is color/depth/stencil-renderable;
    * refer GL3.1 spec 4.4.4
    */

   if (immutable && !_mesa_is_legal_tex_storage_format(ctx, internalformat)) {
      _mesa_error(ctx, GL_INVALID_ENUM,
            "%s(internalformat=%s not legal for immutable-format)",
            func, _mesa_lookup_enum_by_nr(internalformat));
      return;
   }

   if (!is_renderable_texture_format(ctx, internalformat)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
            "%s(internalformat=%s)",
            func, _mesa_lookup_enum_by_nr(internalformat));
      return;
   }

   sample_count_error = _mesa_check_sample_count(ctx, target,
         internalformat, samples);
   samplesOK = sample_count_error == GL_NO_ERROR;

   /* Page 254 of OpenGL 4.4 spec says:
    *   "Proxy arrays for two-dimensional multisample and two-dimensional
    *    multisample array textures are operated on in the same way when
    *    TexImage2DMultisample is called with target specified as
    *    PROXY_TEXTURE_2D_MULTISAMPLE, or TexImage3DMultisample is called
    *    with target specified as PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY.
    *    However, if samples is not supported, then no error is generated.
    */
   if (!samplesOK && !_mesa_is_proxy_texture(target)) {
      _mesa_error(ctx, sample_count_error, "%s(samples)", func);
      return;
   }

   texObj = _mesa_get_current_tex_object(ctx, target);

   if (immutable && (!texObj || (texObj->Name == 0))) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
            "%s(texture object 0)",
            func);
      return;
   }

   texImage = _mesa_get_tex_image(ctx, texObj, 0, 0);

   if (texImage == NULL) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "%s()", func);
      return;
   }

   texFormat = _mesa_choose_texture_format(ctx, texObj, target, 0,
         internalformat, GL_NONE, GL_NONE);
   assert(texFormat != MESA_FORMAT_NONE);

   dimensionsOK = _mesa_legal_texture_dimensions(ctx, target, 0,
         width, height, depth, 0);

   sizeOK = ctx->Driver.TestProxyTexImage(ctx, target, 0, texFormat,
         width, height, depth, 0);

   if (_mesa_is_proxy_texture(target)) {
      if (samplesOK && dimensionsOK && sizeOK) {
         init_teximage_fields_ms(ctx, texImage, width, height, depth, 0,
                                 internalformat, texFormat,
                                 samples, fixedsamplelocations);
      }
      else {
         /* clear all image fields */
         clear_teximage_fields(texImage);
      }
   }
   else {
      if (!dimensionsOK) {
         _mesa_error(ctx, GL_INVALID_VALUE,
               "%s(invalid width or height)", func);
         return;
      }

      if (!sizeOK) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY,
               "%s(texture too large)", func);
         return;
      }

      /* Check if texObj->Immutable is set */
      if (texObj->Immutable) {
         _mesa_error(ctx, GL_INVALID_OPERATION, "%s(immutable)", func);
         return;
      }

      ctx->Driver.FreeTextureImageBuffer(ctx, texImage);

      init_teximage_fields_ms(ctx, texImage, width, height, depth, 0,
                              internalformat, texFormat,
                              samples, fixedsamplelocations);

      if (width > 0 && height > 0 && depth > 0) {
         if (!ctx->Driver.AllocTextureStorage(ctx, texObj, 1,
                  width, height, depth)) {
            /* tidy up the texture image state. strictly speaking,
             * we're allowed to just leave this in whatever state we
             * like, but being tidy is good.
             */
            _mesa_init_teximage_fields(ctx, texImage,
                  0, 0, 0, 0, GL_NONE, MESA_FORMAT_NONE);
         }
      }

      texObj->Immutable = immutable;

      if (immutable) {
         _mesa_set_texture_view_state(ctx, texObj, target, 1);
      }

      _mesa_update_fbo_texture(ctx, texObj, 0, 0);
   }
}


void GLAPIENTRY
_mesa_TexImage2DMultisample(GLenum target, GLsizei samples,
                            GLenum internalformat, GLsizei width,
                            GLsizei height, GLboolean fixedsamplelocations)
{
   teximagemultisample(2, target, samples, internalformat,
                       width, height, 1, fixedsamplelocations, GL_FALSE,
                       "glTexImage2DMultisample");
}


void GLAPIENTRY
_mesa_TexImage3DMultisample(GLenum target, GLsizei samples,
                            GLenum internalformat, GLsizei width,
                            GLsizei height, GLsizei depth,
                            GLboolean fixedsamplelocations)
{
   teximagemultisample(3, target, samples, internalformat,
                       width, height, depth, fixedsamplelocations, GL_FALSE,
                       "glTexImage3DMultisample");
}


void GLAPIENTRY
_mesa_TexStorage2DMultisample(GLenum target, GLsizei samples,
                              GLenum internalformat, GLsizei width,
                              GLsizei height, GLboolean fixedsamplelocations)
{
   teximagemultisample(2, target, samples, internalformat,
                       width, height, 1, fixedsamplelocations, GL_TRUE,
                       "glTexStorage2DMultisample");
}


void GLAPIENTRY
_mesa_TexStorage3DMultisample(GLenum target, GLsizei samples,
                              GLenum internalformat, GLsizei width,
                              GLsizei height, GLsizei depth,
                              GLboolean fixedsamplelocations)
{
   teximagemultisample(3, target, samples, internalformat,
                       width, height, depth, fixedsamplelocations, GL_TRUE,
                       "glTexStorage3DMultisample");
}
@


1.13
log
@Merge Mesa 10.2.9
@
text
@@


1.12
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a43 1
#include "pixelstore.h"
a53 1
#include "texstore.h"
d258 10
a531 14
   if (_mesa_is_desktop_gl(ctx) &&
       ctx->Extensions.ARB_texture_compression_bptc) {
      switch (internalFormat) {
      case GL_COMPRESSED_RGBA_BPTC_UNORM:
      case GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:
         return GL_RGBA;
      case GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:
      case GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:
         return GL_RGB;
      default:
         ; /* fallthrough */
      }
   }

d1539 1
a1539 1
      if (height < 0 || height > ctx->Const.MaxArrayTextureLayers)
a2023 37
static bool
texture_formats_agree(GLenum internalFormat,
                      GLenum format)
{
   GLboolean colorFormat;
   GLboolean is_format_depth_or_depthstencil;
   GLboolean is_internalFormat_depth_or_depthstencil;

   /* Even though there are no color-index textures, we still have to support
    * uploading color-index data and remapping it to RGB via the
    * GL_PIXEL_MAP_I_TO_[RGBA] tables.
    */
   const GLboolean indexFormat = (format == GL_COLOR_INDEX);

   is_internalFormat_depth_or_depthstencil =
      _mesa_is_depth_format(internalFormat) ||
      _mesa_is_depthstencil_format(internalFormat);

   is_format_depth_or_depthstencil =
      _mesa_is_depth_format(format) ||
      _mesa_is_depthstencil_format(format);

   colorFormat = _mesa_is_color_format(format);

   if (_mesa_is_color_format(internalFormat) && !colorFormat && !indexFormat)
      return false;

   if (is_internalFormat_depth_or_depthstencil !=
       is_format_depth_or_depthstencil)
      return false;

   if (_mesa_is_ycbcr_format(internalFormat) != _mesa_is_ycbcr_format(format))
      return false;

   return true;
}

d2057 3
d2062 6
d2150 13
a2162 1
   if (!texture_formats_agree(internalFormat, format)) {
a2353 7
   /* Check for invalid pixel storage modes */
   if (!_mesa_compressed_pixel_storage_error_check(ctx, dimensions,
                                                   &ctx->Unpack,
                                                   "glCompressedTexImage")) {
      return GL_FALSE;
   }

d2423 1
a2423 1
      _mesa_error(ctx, GL_INVALID_VALUE, "glTexSubImage%uD(level=%d)",
d3061 1
a3061 1
   f = ctx->Driver.ChooseTextureFormat(ctx, target, internalFormat,
a3885 260
static bool
check_clear_tex_image(struct gl_context *ctx,
                      const char *function,
                      struct gl_texture_image *texImage,
                      GLenum format, GLenum type,
                      const void *data,
                      GLubyte *clearValue)
{
   struct gl_texture_object *texObj = texImage->TexObject;
   static const GLubyte zeroData[MAX_PIXEL_BYTES];
   GLenum internalFormat = texImage->InternalFormat;
   GLenum err;

   if (texObj->Target == GL_TEXTURE_BUFFER) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "%s(buffer texture)", function);
      return false;
   }

   if (_mesa_is_compressed_format(ctx, internalFormat)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "%s(compressed texture)", function);
      return false;
   }

   err = _mesa_error_check_format_and_type(ctx, format, type);
   if (err != GL_NO_ERROR) {
      _mesa_error(ctx, err,
                  "%s(incompatible format = %s, type = %s)",
                  function,
                  _mesa_lookup_enum_by_nr(format),
                  _mesa_lookup_enum_by_nr(type));
      return false;
   }

   /* make sure internal format and format basically agree */
   if (!texture_formats_agree(internalFormat, format)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "%s(incompatible internalFormat = %s, format = %s)",
                  function,
                  _mesa_lookup_enum_by_nr(internalFormat),
                  _mesa_lookup_enum_by_nr(format));
      return false;
   }

   if (ctx->Version >= 30 || ctx->Extensions.EXT_texture_integer) {
      /* both source and dest must be integer-valued, or neither */
      if (_mesa_is_format_integer_color(texImage->TexFormat) !=
          _mesa_is_enum_format_integer(format)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "%s(integer/non-integer format mismatch)",
                     function);
         return false;
      }
   }

   if (!_mesa_texstore(ctx,
                       1, /* dims */
                       texImage->_BaseFormat,
                       texImage->TexFormat,
                       0, /* dstRowStride */
                       &clearValue,
                       1, 1, 1, /* srcWidth/Height/Depth */
                       format, type,
                       data ? data : zeroData,
                       &ctx->DefaultPacking)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "%s(invalid format)", function);
      return false;
   }

   return true;
}

static struct gl_texture_object *
get_tex_obj_for_clear(struct gl_context *ctx,
                      const char *function,
                      GLuint texture)
{
   struct gl_texture_object *texObj;

   if (texture == 0) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "%s(zero texture)", function);
      return NULL;
   }

   texObj = _mesa_lookup_texture(ctx, texture);

   if (texObj == NULL) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "%s(non-gen name)", function);
      return NULL;
   }

   if (texObj->Target == 0) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "%s(unbound tex)", function);
      return NULL;
   }

   return texObj;
}

static int
get_tex_images_for_clear(struct gl_context *ctx,
                         const char *function,
                         struct gl_texture_object *texObj,
                         GLint level,
                         struct gl_texture_image **texImages)
{
   GLenum target;
   int i;

   if (level < 0 || level >= MAX_TEXTURE_LEVELS) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "%s(invalid level)", function);
      return 0;
   }

   if (texObj->Target == GL_TEXTURE_CUBE_MAP) {
      for (i = 0; i < MAX_FACES; i++) {
         target = GL_TEXTURE_CUBE_MAP_POSITIVE_X + i;

         texImages[i] = _mesa_select_tex_image(ctx, texObj, target, level);
         if (texImages[i] == NULL) {
            _mesa_error(ctx, GL_INVALID_OPERATION,
                        "%s(invalid level)", function);
            return 0;
         }
      }

      return MAX_FACES;
   }

   texImages[0] = _mesa_select_tex_image(ctx, texObj, texObj->Target, level);

   if (texImages[0] == NULL) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "%s(invalid level)", function);
      return 0;
   }

   return 1;
}

void GLAPIENTRY
_mesa_ClearTexSubImage( GLuint texture, GLint level,
                        GLint xoffset, GLint yoffset, GLint zoffset,
                        GLsizei width, GLsizei height, GLsizei depth,
                        GLenum format, GLenum type, const void *data )
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_texture_object *texObj;
   struct gl_texture_image *texImages[MAX_FACES];
   GLubyte clearValue[MAX_FACES][MAX_PIXEL_BYTES];
   int i, numImages;
   int minDepth, maxDepth;

   texObj = get_tex_obj_for_clear(ctx, "glClearTexSubImage", texture);

   if (texObj == NULL)
      return;

   _mesa_lock_texture(ctx, texObj);

   numImages = get_tex_images_for_clear(ctx, "glClearTexSubImage",
                                        texObj, level, texImages);
   if (numImages == 0)
      goto out;

   if (numImages == 1) {
      minDepth = -(int) texImages[0]->Border;
      maxDepth = texImages[0]->Depth;
   } else {
      minDepth = 0;
      maxDepth = numImages;
   }

   if (xoffset < -(GLint) texImages[0]->Border ||
       yoffset < -(GLint) texImages[0]->Border ||
       zoffset < minDepth ||
       width < 0 ||
       height < 0 ||
       depth < 0 ||
       xoffset + width > texImages[0]->Width ||
       yoffset + height > texImages[0]->Height ||
       zoffset + depth > maxDepth) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glClearSubTexImage(invalid dimensions)");
      goto out;
   }

   if (numImages == 1) {
      if (check_clear_tex_image(ctx, "glClearTexSubImage",
                                texImages[0],
                                format, type, data, clearValue[0])) {
         ctx->Driver.ClearTexSubImage(ctx,
                                      texImages[0],
                                      xoffset, yoffset, zoffset,
                                      width, height, depth,
                                      data ? clearValue[0] : NULL);
      }
   } else {
      for (i = zoffset; i < zoffset + depth; i++) {
         if (!check_clear_tex_image(ctx, "glClearTexSubImage",
                                    texImages[i],
                                    format, type, data, clearValue[i]))
            goto out;
      }
      for (i = zoffset; i < zoffset + depth; i++) {
         ctx->Driver.ClearTexSubImage(ctx,
                                      texImages[i],
                                      xoffset, yoffset, 0,
                                      width, height, 1,
                                      data ? clearValue[i] : NULL);
      }
   }

 out:
   _mesa_unlock_texture(ctx, texObj);
}

void GLAPIENTRY
_mesa_ClearTexImage( GLuint texture, GLint level,
                     GLenum format, GLenum type, const void *data )
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_texture_object *texObj;
   struct gl_texture_image *texImages[MAX_FACES];
   GLubyte clearValue[MAX_FACES][MAX_PIXEL_BYTES];
   int i, numImages;

   texObj = get_tex_obj_for_clear(ctx, "glClearTexImage", texture);

   if (texObj == NULL)
      return;

   _mesa_lock_texture(ctx, texObj);

   numImages = get_tex_images_for_clear(ctx, "glClearTexImage",
                                        texObj, level, texImages);

   for (i = 0; i < numImages; i++) {
      if (!check_clear_tex_image(ctx, "glClearTexImage",
                                 texImages[i],
                                 format, type, data,
                                 clearValue[i]))
         goto out;
   }

   for (i = 0; i < numImages; i++) {
      ctx->Driver.ClearTexSubImage(ctx, texImages[i],
                                   -(GLint) texImages[i]->Border, /* xoffset */
                                   -(GLint) texImages[i]->Border, /* yoffset */
                                   -(GLint) texImages[i]->Border, /* zoffset */
                                   texImages[i]->Width,
                                   texImages[i]->Height,
                                   texImages[i]->Depth,
                                   data ? clearValue[i] : NULL);
   }

out:
   _mesa_unlock_texture(ctx, texObj);
}

d3896 1
a3896 1
 * \return GL_TRUE if error, GL_FALSE if no error
d3898 1
a3898 1
static GLboolean
d3938 1
a3938 1
      _mesa_error(ctx, GL_INVALID_ENUM, "glCompressedTexSubImage%uD(target)",
d3951 1
a3951 1
      _mesa_error(ctx, GL_INVALID_VALUE, "glCompressedTexSubImage%uD(level=%d)",
a3955 7
   /* Check for invalid pixel storage modes */
   if (!_mesa_compressed_pixel_storage_error_check(ctx, dims,
                                                &ctx->Unpack,
                                                "glCompressedTexSubImage")) {
      return GL_TRUE;
   }

d3958 1
a3958 1
      _mesa_error(ctx, GL_INVALID_VALUE, "glCompressedTexSubImage%uD(size=%d)",
a4358 6

   ctx->NewDriverState |= ctx->DriverFlags.NewTextureBuffer;

   if (bufObj) {
      bufObj->UsageHistory |= USAGE_TEXTURE_BUFFER;
   }
d4637 1
@


1.11
log
@Merge Mesa 10.2.7
@
text
@d44 1
d55 1
a259 10
   if (ctx->Extensions.ATI_envmap_bumpmap) {
      switch (internalFormat) {
         case GL_DUDV_ATI:
         case GL_DU8DV8_ATI:
            return GL_DUDV_ATI;
         default:
            ; /* fallthrough */
      }
   }

d524 14
d1545 1
a1545 1
      if (height < 1 || height > ctx->Const.MaxArrayTextureLayers)
d2030 37
a2099 3
   GLboolean colorFormat;
   GLboolean is_format_depth_or_depthstencil;
   GLboolean is_internalFormat_depth_or_depthstencil;
a2101 6
   /* Even though there are no color-index textures, we still have to support
    * uploading color-index data and remapping it to RGB via the
    * GL_PIXEL_MAP_I_TO_[RGBA] tables.
    */
   const GLboolean indexFormat = (format == GL_COLOR_INDEX);

d2184 1
a2184 13
   is_internalFormat_depth_or_depthstencil =
      _mesa_is_depth_format(internalFormat) ||
      _mesa_is_depthstencil_format(internalFormat);

   is_format_depth_or_depthstencil =
      _mesa_is_depth_format(format) ||
      _mesa_is_depthstencil_format(format);

   colorFormat = _mesa_is_color_format(format);
   if ((_mesa_is_color_format(internalFormat) && !colorFormat && !indexFormat) ||
       (is_internalFormat_depth_or_depthstencil != is_format_depth_or_depthstencil) ||
       (_mesa_is_ycbcr_format(internalFormat) != _mesa_is_ycbcr_format(format)) ||
       (_mesa_is_dudv_format(internalFormat) != _mesa_is_dudv_format(format))) {
d2376 7
d2452 1
a2452 1
      _mesa_error(ctx, GL_INVALID_ENUM, "glTexSubImage%uD(level=%d)",
d3090 1
a3090 1
   f = ctx->Driver.ChooseTextureFormat(ctx, texObj->Target, internalFormat,
d3915 260
d4185 1
a4185 1
 * \return error code or GL_NO_ERROR.
d4187 1
a4187 1
static GLenum
d4227 1
a4227 1
      _mesa_error(ctx, GL_INVALID_ENUM, "glCompressedTexImage%uD(target)",
d4240 1
a4240 1
      _mesa_error(ctx, GL_INVALID_VALUE, "glCompressedTexImage%uD(level=%d)",
d4245 7
d4254 1
a4254 1
      _mesa_error(ctx, GL_INVALID_VALUE, "glCompressedTexImage%uD(size=%d)",
d4655 6
a4938 1

@


1.10
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d1782 3
a1784 3
static GLboolean
target_can_be_compressed(const struct gl_context *ctx, GLenum target,
                         GLenum intFormat)
d1793 1
d2208 1
a2208 1
      if (!target_can_be_compressed(ctx, target, internalFormat)) {
d2264 1
a2264 1
   if (!target_can_be_compressed(ctx, target, internalFormat)) {
d2266 8
a2273 1
      error = GL_INVALID_ENUM;
d2671 11
d2700 2
d2715 13
d2731 1
a2731 1
      if (!target_can_be_compressed(ctx, target, internalFormat)) {
d3601 22
d3636 1
d3666 34
@


1.9
log
@Merge Mesa 9.2.2
@
text
@d51 1
d163 3
a306 10
   if (ctx->Extensions.EXT_packed_depth_stencil) {
      switch (internalFormat) {
         case GL_DEPTH_STENCIL_EXT:
         case GL_DEPTH24_STENCIL8_EXT:
            return GL_DEPTH_STENCIL_EXT;
         default:
            ; /* fallthrough */
      }
   }

a394 5
	 /* R16F depends on both ARB_half_float_pixel and ARB_texture_float.
	  */
	 if (!ctx->Extensions.ARB_half_float_pixel)
	    break;
	 /* FALLTHROUGH */
a414 5
	 /* RG16F depends on both ARB_half_float_pixel and ARB_texture_float.
	  */
	 if (!ctx->Extensions.ARB_half_float_pixel)
	    break;
	 /* FALLTHROUGH */
d648 13
d662 1
a662 1
    * NUM_TEXTURE_TARGETS should match number of terms below, except there's no
d665 1
a665 1
   assert(NUM_TEXTURE_TARGETS == 10 + 2);
d667 4
a670 10
   return (target == GL_PROXY_TEXTURE_1D ||
           target == GL_PROXY_TEXTURE_2D ||
           target == GL_PROXY_TEXTURE_3D ||
           target == GL_PROXY_TEXTURE_CUBE_MAP_ARB ||
           target == GL_PROXY_TEXTURE_RECTANGLE_NV ||
           target == GL_PROXY_TEXTURE_1D_ARRAY_EXT ||
           target == GL_PROXY_TEXTURE_2D_ARRAY_EXT ||
           target == GL_PROXY_TEXTURE_CUBE_MAP_ARRAY ||
           target == GL_PROXY_TEXTURE_2D_MULTISAMPLE ||
           target == GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY);
d677 2
a678 2
GLenum
_mesa_get_proxy_target(GLenum target)
d718 1
a718 1
      _mesa_problem(NULL, "unexpected target in _mesa_get_proxy_target()");
d725 3
a727 8
 * Get the texture object that corresponds to the target of the given
 * texture unit.  The target should have already been checked for validity.
 *
 * \param ctx GL context.
 * \param texUnit texture unit.
 * \param target texture target.
 *
 * \return pointer to the texture object on success, or NULL on failure.
d730 1
a730 3
_mesa_select_tex_object(struct gl_context *ctx,
                        const struct gl_texture_unit *texUnit,
                        GLenum target)
d732 2
a733 2
   const GLboolean arrayTex = (ctx->Extensions.MESA_texture_array ||
                               ctx->Extensions.EXT_texture_array);
d800 1
a800 1
         _mesa_problem(NULL, "bad target in _mesa_select_tex_object()");
a805 10
/**
 * Return pointer to texture object for given target on current texture unit.
 */
struct gl_texture_object *
_mesa_get_current_tex_object(struct gl_context *ctx, GLenum target)
{
   struct gl_texture_unit *texUnit = _mesa_get_current_tex_unit(ctx);
   return _mesa_select_tex_object(ctx, texUnit, target);
}

d988 1
a988 2
      return (ctx->Extensions.MESA_texture_array ||
              ctx->Extensions.EXT_texture_array)
d1060 87
d1288 2
d1294 7
a1300 6
void
_mesa_init_teximage_fields(struct gl_context *ctx,
                           struct gl_texture_image *img,
                           GLsizei width, GLsizei height, GLsizei depth,
                           GLint border, GLenum internalFormat,
                           gl_format format)
d1398 14
d1557 1
a1557 1
      if (depth < 1 || depth > ctx->Const.MaxArrayTextureLayers)
d1574 1
a1574 1
      if (depth < 1 || depth > ctx->Const.MaxArrayTextureLayers || depth % 6)
d1660 4
a1663 1
      GLint zBorder = (target == GL_TEXTURE_2D_ARRAY) ? 0 : destImage->Border;
d1740 1
a1740 1
                          gl_format format,
d1802 1
a1802 2
      return (ctx->Extensions.MESA_texture_array ||
              ctx->Extensions.EXT_texture_array);
d1850 1
a1850 3
         return _mesa_is_desktop_gl(ctx)
            && (ctx->Extensions.MESA_texture_array ||
                ctx->Extensions.EXT_texture_array);
d1861 1
a1861 3
         return (_mesa_is_desktop_gl(ctx)
                 && (ctx->Extensions.MESA_texture_array ||
                     ctx->Extensions.EXT_texture_array))
d1864 1
a1864 3
         return _mesa_is_desktop_gl(ctx)
            && (ctx->Extensions.MESA_texture_array ||
                ctx->Extensions.EXT_texture_array);
d1905 1
a1905 3
         return _mesa_is_desktop_gl(ctx)
            && (ctx->Extensions.MESA_texture_array ||
                ctx->Extensions.EXT_texture_array);
d1914 1
a1914 3
         return (_mesa_is_desktop_gl(ctx)
                 && (ctx->Extensions.MESA_texture_array ||
                     ctx->Extensions.EXT_texture_array))
d1949 1
a1949 1
   gl_format mesaFormat = _mesa_glenum_to_compressed_format(glformat);
d1953 69
d2057 2
d2149 8
d2159 1
a2159 1
       (_mesa_is_depth_format(internalFormat) != _mesa_is_depth_format(format)) ||
a2160 1
       (_mesa_is_depthstencil_format(internalFormat) != _mesa_is_depthstencil_format(format)) ||
d2201 3
a2203 26
   if (_mesa_base_tex_format(ctx, internalFormat) == GL_DEPTH_COMPONENT
       || _mesa_base_tex_format(ctx, internalFormat) == GL_DEPTH_STENCIL) {
      /* Only 1D, 2D, rect, array and cube textures supported, not 3D
       * Cubemaps are only supported for GL version > 3.0 or with EXT_gpu_shader4 */
      if (target != GL_TEXTURE_1D &&
          target != GL_PROXY_TEXTURE_1D &&
          target != GL_TEXTURE_2D &&
          target != GL_PROXY_TEXTURE_2D &&
          target != GL_TEXTURE_1D_ARRAY &&
          target != GL_PROXY_TEXTURE_1D_ARRAY &&
          target != GL_TEXTURE_2D_ARRAY &&
          target != GL_PROXY_TEXTURE_2D_ARRAY &&
          target != GL_TEXTURE_RECTANGLE_ARB &&
          target != GL_PROXY_TEXTURE_RECTANGLE_ARB &&
         !((_mesa_is_cube_face(target) || target == GL_PROXY_TEXTURE_CUBE_MAP) &&
           (ctx->Version >= 30 || ctx->Extensions.EXT_gpu_shader4
            || (ctx->API == API_OPENGLES2 && ctx->Extensions.OES_depth_texture_cube_map))) &&
          !((target == GL_TEXTURE_CUBE_MAP_ARRAY ||
             target == GL_PROXY_TEXTURE_CUBE_MAP_ARRAY) &&
            ctx->Extensions.ARB_texture_cube_map_array)) {
         _mesa_error(ctx, GL_INVALID_ENUM,
                     "glTexImage%dD(bad target for depth texture)",
                     dimensions);
         return GL_TRUE;
      }
   }
d2271 4
a2274 3
      reason = "internalFormat";
      error = GL_INVALID_ENUM;
      goto error;
d2366 1
d2582 2
a2583 1
                     "glCopyTexImage%dD(internalFormat)", dimensions);
d2591 2
a2592 1
                  "glCopyTexImage%dD(internalFormat)", dimensions);
d2601 2
a2602 1
                     "glCopyTexImage%dD(internalFormat)", dimensions);
d2628 2
a2629 1
                     "glCopyTexImage%dD(internalFormat)", dimensions);
d2971 1
a2971 1
gl_format
d2977 1
a2977 1
   gl_format f;
d2996 1
a2996 1
    * have the DTXn library, force a generic compressed format instead.
d3099 1
a3099 1
   gl_format texFormat;
d3190 1
a3190 1
   sizeOK = ctx->Driver.TestProxyTexImage(ctx, _mesa_get_proxy_target(target),
d3272 1
a3272 1
            _mesa_dirty_texobj(ctx, texObj, GL_TRUE);
d3391 1
a3391 1
      _mesa_dirty_texobj(ctx, texObj, GL_TRUE);
d3465 3
a3467 1
         ctx->NewState |= _NEW_TEXTURE;
d3525 1
a3525 1
get_copy_tex_image_source(struct gl_context *ctx, gl_format texFormat)
d3579 1
a3579 1
   gl_format texFormat;
d3611 1
a3611 1
   if (!ctx->Driver.TestProxyTexImage(ctx, _mesa_get_proxy_target(target),
d3664 1
a3664 1
         _mesa_dirty_texobj(ctx, texObj, GL_TRUE);
d3754 3
a3756 1
         ctx->NewState |= _NEW_TEXTURE;
d3981 3
a3983 1
         ctx->NewState |= _NEW_TEXTURE;
d4021 1
a4021 1
static gl_format
d4024 101
a4125 80
   case GL_ALPHA8:
      return MESA_FORMAT_A8;
   case GL_ALPHA16:
      return MESA_FORMAT_A16;
   case GL_ALPHA16F_ARB:
      return MESA_FORMAT_ALPHA_FLOAT16;
   case GL_ALPHA32F_ARB:
      return MESA_FORMAT_ALPHA_FLOAT32;
   case GL_ALPHA8I_EXT:
      return MESA_FORMAT_ALPHA_INT8;
   case GL_ALPHA16I_EXT:
      return MESA_FORMAT_ALPHA_INT16;
   case GL_ALPHA32I_EXT:
      return MESA_FORMAT_ALPHA_INT32;
   case GL_ALPHA8UI_EXT:
      return MESA_FORMAT_ALPHA_UINT8;
   case GL_ALPHA16UI_EXT:
      return MESA_FORMAT_ALPHA_UINT16;
   case GL_ALPHA32UI_EXT:
      return MESA_FORMAT_ALPHA_UINT32;
   case GL_LUMINANCE8:
      return MESA_FORMAT_L8;
   case GL_LUMINANCE16:
      return MESA_FORMAT_L16;
   case GL_LUMINANCE16F_ARB:
      return MESA_FORMAT_LUMINANCE_FLOAT16;
   case GL_LUMINANCE32F_ARB:
      return MESA_FORMAT_LUMINANCE_FLOAT32;
   case GL_LUMINANCE8I_EXT:
      return MESA_FORMAT_LUMINANCE_INT8;
   case GL_LUMINANCE16I_EXT:
      return MESA_FORMAT_LUMINANCE_INT16;
   case GL_LUMINANCE32I_EXT:
      return MESA_FORMAT_LUMINANCE_INT32;
   case GL_LUMINANCE8UI_EXT:
      return MESA_FORMAT_LUMINANCE_UINT8;
   case GL_LUMINANCE16UI_EXT:
      return MESA_FORMAT_LUMINANCE_UINT16;
   case GL_LUMINANCE32UI_EXT:
      return MESA_FORMAT_LUMINANCE_UINT32;
   case GL_LUMINANCE8_ALPHA8:
      return MESA_FORMAT_AL88;
   case GL_LUMINANCE16_ALPHA16:
      return MESA_FORMAT_AL1616;
   case GL_LUMINANCE_ALPHA16F_ARB:
      return MESA_FORMAT_LUMINANCE_ALPHA_FLOAT16;
   case GL_LUMINANCE_ALPHA32F_ARB:
      return MESA_FORMAT_LUMINANCE_ALPHA_FLOAT32;
   case GL_LUMINANCE_ALPHA8I_EXT:
      return MESA_FORMAT_LUMINANCE_ALPHA_INT8;
   case GL_LUMINANCE_ALPHA16I_EXT:
      return MESA_FORMAT_LUMINANCE_ALPHA_INT8;
   case GL_LUMINANCE_ALPHA32I_EXT:
      return MESA_FORMAT_LUMINANCE_ALPHA_INT16;
   case GL_LUMINANCE_ALPHA8UI_EXT:
      return MESA_FORMAT_LUMINANCE_ALPHA_UINT8;
   case GL_LUMINANCE_ALPHA16UI_EXT:
      return MESA_FORMAT_LUMINANCE_ALPHA_UINT16;
   case GL_LUMINANCE_ALPHA32UI_EXT:
      return MESA_FORMAT_LUMINANCE_ALPHA_UINT32;
   case GL_INTENSITY8:
      return MESA_FORMAT_I8;
   case GL_INTENSITY16:
      return MESA_FORMAT_I16;
   case GL_INTENSITY16F_ARB:
      return MESA_FORMAT_INTENSITY_FLOAT16;
   case GL_INTENSITY32F_ARB:
      return MESA_FORMAT_INTENSITY_FLOAT32;
   case GL_INTENSITY8I_EXT:
      return MESA_FORMAT_INTENSITY_INT8;
   case GL_INTENSITY16I_EXT:
      return MESA_FORMAT_INTENSITY_INT16;
   case GL_INTENSITY32I_EXT:
      return MESA_FORMAT_INTENSITY_INT32;
   case GL_INTENSITY8UI_EXT:
      return MESA_FORMAT_INTENSITY_UINT8;
   case GL_INTENSITY16UI_EXT:
      return MESA_FORMAT_INTENSITY_UINT16;
   case GL_INTENSITY32UI_EXT:
      return MESA_FORMAT_INTENSITY_UINT32;
d4127 1
a4127 1
      return MESA_FORMAT_RGBA8888_REV;
d4129 1
a4129 1
      return MESA_FORMAT_RGBA_16;
d4135 1
a4135 1
      return MESA_FORMAT_RGBA_INT8;
d4137 1
a4137 1
      return MESA_FORMAT_RGBA_INT16;
d4139 1
a4139 1
      return MESA_FORMAT_RGBA_INT32;
d4148 1
a4148 1
      return MESA_FORMAT_GR88;
d4150 1
a4150 1
      return MESA_FORMAT_GR1616;
d4156 1
a4156 1
      return MESA_FORMAT_RG_INT8;
d4158 1
a4158 1
      return MESA_FORMAT_RG_INT16;
d4160 1
a4160 1
      return MESA_FORMAT_RG_INT32;
d4169 1
a4169 1
      return MESA_FORMAT_R8;
d4171 1
a4171 1
      return MESA_FORMAT_R16;
d4177 1
a4177 1
      return MESA_FORMAT_R_INT8;
d4179 1
a4179 1
      return MESA_FORMAT_R_INT16;
d4181 1
a4181 1
      return MESA_FORMAT_R_INT32;
a4188 7
   case GL_RGB32F:
      return MESA_FORMAT_RGB_FLOAT32;
   case GL_RGB32UI:
      return MESA_FORMAT_RGB_UINT32;
   case GL_RGB32I:
      return MESA_FORMAT_RGB_INT32;

d4195 3
a4197 2
static gl_format
validate_texbuffer_format(const struct gl_context *ctx, GLenum internalFormat)
d4199 1
a4199 1
   gl_format format = get_texbuffer_format(ctx, internalFormat);
a4205 2
   if (datatype == GL_FLOAT && !ctx->Extensions.ARB_texture_float)
      return MESA_FORMAT_NONE;
d4207 11
a4217 1
   if (datatype == GL_HALF_FLOAT && !ctx->Extensions.ARB_half_float_pixel)
d4220 1
a4220 5
   /* The GL_ARB_texture_rg and GL_ARB_texture_buffer_object specs don't make
    * any mention of R/RG formats, but they appear in the GL 3.1 core
    * specification.
    */
   if (ctx->Version <= 30) {
a4221 1

d4223 1
a4223 1
	 return MESA_FORMAT_NONE;
d4241 1
a4241 1
   gl_format format;
d4250 1
a4250 1
   format = validate_texbuffer_format(ctx, internalFormat);
d4377 2
a4378 2
   GLboolean sizeOK, dimensionsOK;
   gl_format texFormat;
d4414 11
a4424 1
   if (sample_count_error != GL_NO_ERROR) {
d4456 4
a4459 5
      if (dimensionsOK && sizeOK) {
         _mesa_init_teximage_fields(ctx, texImage,
               width, height, depth, 0, internalformat, texFormat);
         texImage->NumSamples = samples;
         texImage->FixedSampleLocations = fixedsamplelocations;
d4463 1
a4463 2
         _mesa_init_teximage_fields(ctx, texImage,
               0, 0, 0, 0, GL_NONE, MESA_FORMAT_NONE);
d4487 3
a4489 5
      _mesa_init_teximage_fields(ctx, texImage,
            width, height, depth, 0, internalformat, texFormat);

      texImage->NumSamples = samples;
      texImage->FixedSampleLocations = fixedsamplelocations;
d4504 5
d4516 1
a4516 1
                            GLint internalformat, GLsizei width,
d4527 1
a4527 1
                            GLint internalformat, GLsizei width,
@


1.8
log
@Merge Mesa 9.2.0
@
text
@a1107 1
      ASSERT(width == height);
d1442 2
d1497 3
a1499 1
      if (depth < 1 || depth > ctx->Const.MaxArrayTextureLayers)
a1989 21
   if ((target == GL_PROXY_TEXTURE_CUBE_MAP_ARB ||
        _mesa_is_cube_face(target)) && width != height) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glTexImage2D(cube width != height)");
      return GL_TRUE;
   }

   if ((target == GL_PROXY_TEXTURE_CUBE_MAP_ARRAY ||
        target == GL_TEXTURE_CUBE_MAP_ARRAY) && width != height) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glTexImage3D(cube array width != height)");
      return GL_TRUE;
   }

   if ((target == GL_PROXY_TEXTURE_CUBE_MAP_ARRAY ||
        target == GL_TEXTURE_CUBE_MAP_ARRAY) && (depth % 6)) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glTexImage3D(cube array depth not multiple of 6)");
      return GL_TRUE;
   }

a2220 8
   /* For cube map, width must equal height */
   if ((target == GL_PROXY_TEXTURE_CUBE_MAP_ARB ||
        _mesa_is_cube_face(target)) && width != height) {
      reason = "width != height";
      error = GL_INVALID_VALUE;
      goto error;
   }

a2563 7
   }

   if ((target == GL_PROXY_TEXTURE_CUBE_MAP_ARB ||
        _mesa_is_cube_face(target)) && width != height) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glTexImage2D(cube width != height)");
      return GL_TRUE;
@


1.7
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d2 1
a2 2
 * mesa 3-D graphics library
 * Version:  7.6
d20 4
a23 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
d32 1
a32 1

d43 1
a43 1
#include "mfeatures.h"
d46 1
a46 1
#include "texfetch.h"
d48 1
d50 1
a50 1
#include "texpal.h"
d52 1
a64 21
 * We allocate texture memory on 512-byte boundaries so we can use MMX/SSE
 * elsewhere.
 */
void *
_mesa_alloc_texmemory(GLsizei bytes)
{
   return _mesa_align_malloc(bytes, 512);
}


/**
 * Free texture memory allocated with _mesa_alloc_texmemory()
 */
void
_mesa_free_texmemory(void *m)
{
   _mesa_align_free(m);
}


/**
a75 2
 *
 * XXX this could be static
d86 1
a86 1
         return GL_ALPHA;
d93 1
a93 1
         return GL_LUMINANCE;
d102 1
a102 1
         return GL_LUMINANCE_ALPHA;
d108 1
a108 1
         return GL_INTENSITY;
d110 1
d121 1
d135 3
a137 1
   if (ctx->Extensions.EXT_texture_format_BGRA8888) {
d139 1
a139 1
         case GL_BGRA_EXT:
d146 1
a146 1
   if (ctx->Extensions.EXT_paletted_texture) {
d148 2
a149 8
         case GL_COLOR_INDEX:
         case GL_COLOR_INDEX1_EXT:
         case GL_COLOR_INDEX2_EXT:
         case GL_COLOR_INDEX4_EXT:
         case GL_COLOR_INDEX8_EXT:
         case GL_COLOR_INDEX12_EXT:
         case GL_COLOR_INDEX16_EXT:
            return GL_COLOR_INDEX;
d183 1
a183 1
         
d195 3
a197 1
   if (ctx->Extensions.EXT_texture_compression_s3tc) {
d210 2
a211 1
   if (ctx->Extensions.S3_s3tc) {
a312 1
#if FEATURE_EXT_texture_sRGB
d318 1
d320 1
a320 1
         return GL_RGB;
d324 1
d328 1
a328 1
         return GL_RGBA;
a340 1
#endif /* FEATURE_EXT_texture_sRGB */
d342 2
a343 1
   if (ctx->Extensions.EXT_texture_integer) {
d351 1
d360 5
d416 1
a416 1
	 if (!ctx->Extensions.EXT_texture_integer)
d441 1
a441 1
	 if (!ctx->Extensions.EXT_texture_integer)
d518 30
d578 1
a578 2
   if (target >= GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB &&
       target <= GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB)
d587 2
a588 2
 * Store a gl_texture_image pointer in a gl_texture_object structure
 * according to the target and level parameters.
a593 2
 * 
 * This was basically prompted by the introduction of cube maps.
d595 4
a598 4
void
_mesa_set_tex_image(struct gl_texture_object *tObj,
                    GLenum target, GLint level,
                    struct gl_texture_image *texImage)
d604 2
a605 1
   ASSERT(target != GL_TEXTURE_RECTANGLE_NV || level == 0);
d611 2
d618 1
a618 1
 * 
d634 2
a635 24
 * Free texture image data.
 * This function is a fallback called via ctx->Driver.FreeTexImageData().
 *
 * \param texImage texture image.
 *
 * Free the texture image data if it's not marked as client data.
 */
void
_mesa_free_texture_image_data(struct gl_context *ctx,
                              struct gl_texture_image *texImage)
{
   (void) ctx;

   if (texImage->Data && !texImage->IsClientData) {
      /* free the old texture data */
      _mesa_free_texmemory(texImage->Data);
   }

   texImage->Data = NULL;
}


/**
 * Free texture image.
d648 2
a649 6
   ASSERT(ctx->Driver.FreeTexImageData);
   ctx->Driver.FreeTexImageData( ctx, texImage );

   ASSERT(texImage->Data == NULL);
   if (texImage->ImageOffsets)
      free(texImage->ImageOffsets);
d664 3
a666 2
   /* NUM_TEXTURE_TARGETS should match number of terms below,
    * except there's no proxy for GL_TEXTURE_BUFFER.
d668 1
a668 1
   assert(NUM_TEXTURE_TARGETS == 8);
d676 4
a679 1
           target == GL_PROXY_TEXTURE_2D_ARRAY_EXT);
d686 2
a687 2
static GLenum
get_proxy_target(GLenum target)
d717 9
d727 1
a727 1
      _mesa_problem(NULL, "unexpected target in get_proxy_target()");
d735 1
a735 1
 * texture unit.
a741 2
 * 
 * \sa gl_texture_unit.
d776 6
d797 18
a814 2
         return ctx->Extensions.ARB_texture_buffer_object
            ? texUnit->CurrentTex[TEXTURE_BUFFER_INDEX] : NULL;
d873 1
a873 1
   
d882 1
a882 1
      _mesa_set_tex_image(texObj, target, level, texImage);
d895 2
a896 2
struct gl_texture_image *
_mesa_get_proxy_tex_image(struct gl_context *ctx, GLenum target, GLint level)
d901 1
a901 1
   if (level < 0 )
d940 15
d979 1
a979 1
 * 
d997 1
a1003 1
   case GL_TEXTURE_CUBE_MAP_ARB:
d1017 4
d1022 10
d1063 3
d1071 4
d1086 50
d1149 1
a1149 1
   GLubyte *data = (GLubyte *) MALLOC(numPixels * components * sizeof(GLubyte));
d1193 2
a1194 9
 * Reset the fields of a gl_texture_image struct to zero.
 * 
 * \param img texture image structure.
 *
 * This is called when a proxy texture test fails, we set all the
 * image members (except DriverData) to zero.
 * It's also used in glTexImage[123]D as a safeguard to be sure all
 * required fields get initialized properly by the Driver.TexImage[123]D
 * functions.
a1205 5
   img->RowStride = 0;
   if (img->ImageOffsets) {
      free(img->ImageOffsets);
      img->ImageOffsets = NULL;
   }
a1211 1
   img->Data = NULL;
d1213 2
a1214 2
   img->FetchTexelc = NULL;
   img->FetchTexelf = NULL;
a1221 1
 * \param target texture target (GL_TEXTURE_1D, GL_TEXTURE_RECTANGLE, etc).
d1234 1
a1234 1
_mesa_init_teximage_fields(struct gl_context *ctx, GLenum target,
d1240 1
a1240 2
   GLint i, dims;

d1246 1
d1258 11
a1268 2
   if (height == 1) { /* 1-D texture */
      img->Height2 = 1;
d1270 31
a1300 2
   }
   else {
d1303 4
a1306 4
   }

   if (depth == 1) {  /* 2-D texture */
      img->Depth2 = 1;
d1308 16
a1323 2
   }
   else {
d1326 4
d1332 3
a1334 35
   img->MaxLog2 = MAX2(img->WidthLog2, img->HeightLog2);

   if ((width == 1 || _mesa_is_pow_two(img->Width2)) &&
       (height == 1 || _mesa_is_pow_two(img->Height2)) &&
       (depth == 1 || _mesa_is_pow_two(img->Depth2)))
      img->_IsPowerOfTwo = GL_TRUE;
   else
      img->_IsPowerOfTwo = GL_FALSE;

   /* RowStride and ImageOffsets[] describe how to address texels in 'Data' */
   img->RowStride = width;
   /* Allocate the ImageOffsets array and initialize to typical values.
    * We allocate the array for 1D/2D textures too in order to avoid special-
    * case code in the texstore routines.
    */
   if (img->ImageOffsets)
      free(img->ImageOffsets);
   img->ImageOffsets = (GLuint *) malloc(depth * sizeof(GLuint));
   for (i = 0; i < depth; i++) {
      img->ImageOffsets[i] = i * width * height;
   }

   /* Compute Width/Height/DepthScale for mipmap lod computation */
   if (target == GL_TEXTURE_RECTANGLE_NV) {
      /* scale = 1.0 since texture coords directly map to texels */
      img->WidthScale = 1.0;
      img->HeightScale = 1.0;
      img->DepthScale = 1.0;
   }
   else {
      img->WidthScale = (GLfloat) img->Width;
      img->HeightScale = (GLfloat) img->Height;
      img->DepthScale = (GLfloat) img->Depth;
   }

a1335 4

   dims = _mesa_get_texture_dimensions(target);

   _mesa_set_fetch_functions(img, dims);
d1352 1
a1352 1
   ctx->Driver.FreeTexImageData(ctx, texImage);
d1358 5
a1362 22
 * This is the fallback for Driver.TestProxyTexImage().  Test the texture
 * level, width, height and depth against the ctx->Const limits for textures.
 *
 * A hardware driver might override this function if, for example, the
 * max 3D texture size is 512x512x64 (i.e. not a cube).
 *
 * Note that width, height, depth == 0 is not an error.  However, a
 * texture with zero width/height/depth will be considered "incomplete"
 * and texturing will effectively be disabled.
 *
 * \param target  one of GL_PROXY_TEXTURE_1D, GL_PROXY_TEXTURE_2D,
 *                GL_PROXY_TEXTURE_3D, GL_PROXY_TEXTURE_RECTANGLE_NV,
 *                GL_PROXY_TEXTURE_CUBE_MAP_ARB.
 * \param level  as passed to glTexImage
 * \param internalFormat  as passed to glTexImage
 * \param format  as passed to glTexImage
 * \param type  as passed to glTexImage
 * \param width  as passed to glTexImage
 * \param height  as passed to glTexImage
 * \param depth  as passed to glTexImage
 * \param border  as passed to glTexImage
 * \return GL_TRUE if the image is acceptable, GL_FALSE if not acceptable.
d1365 3
a1367 3
_mesa_test_proxy_teximage(struct gl_context *ctx, GLenum target, GLint level,
                          GLint internalFormat, GLenum format, GLenum type,
                          GLint width, GLint height, GLint depth, GLint border)
a1370 4
   (void) internalFormat;
   (void) format;
   (void) type;

d1372 1
d1374 3
a1376 4
      maxSize = 1 << (ctx->Const.MaxTextureLevels - 1);
      if (width < 2 * border || width > 2 + maxSize)
         return GL_FALSE;
      if (level >= ctx->Const.MaxTextureLevels)
d1384 1
d1386 2
d1389 2
a1390 1
      if (width < 2 * border || width > 2 + maxSize)
d1392 1
a1392 3
      if (height < 2 * border || height > 2 + maxSize)
         return GL_FALSE;
      if (level >= ctx->Const.MaxTextureLevels)
d1402 1
d1405 2
a1406 3
      if (width < 2 * border || width > 2 + maxSize)
         return GL_FALSE;
      if (height < 2 * border || height > 2 + maxSize)
d1408 1
a1408 1
      if (depth < 2 * border || depth > 2 + maxSize)
d1410 1
a1410 1
      if (level >= ctx->Const.Max3DTextureLevels)
d1422 1
d1424 2
a1430 2
      if (level != 0)
         return GL_FALSE;
d1433 7
d1442 2
a1443 3
      if (width < 2 * border || width > 2 + maxSize)
         return GL_FALSE;
      if (height < 2 * border || height > 2 + maxSize)
d1445 1
a1445 1
      if (level >= ctx->Const.MaxCubeTextureLevels)
d1455 1
d1458 2
a1459 1
      if (width < 2 * border || width > 2 + maxSize)
a1462 2
      if (level >= ctx->Const.MaxTextureLevels)
         return GL_FALSE;
d1469 1
d1471 2
d1474 19
a1492 1
      if (width < 2 * border || width > 2 + maxSize)
d1494 1
a1494 1
      if (height < 2 * border || height > 2 + maxSize)
d1498 1
a1498 1
      if (level >= ctx->Const.MaxTextureLevels)
a1506 1

d1508 1
a1508 1
      _mesa_problem(ctx, "Invalid target in _mesa_test_proxy_teximage");
d1515 4
a1518 5
 * Check if the memory used by the texture would exceed the driver's limit.
 * This lets us support a max 3D texture size of 8K (for example) but
 * prevents allocating a full 8K x 8K x 8K texture.
 * XXX this could be rolled into the proxy texture size test (above) but
 * we don't have the actual texture internal format at that point.
d1521 6
a1526 2
legal_texture_size(struct gl_context *ctx, gl_format format,
                   GLint width, GLint height, GLint depth)
d1528 15
a1542 4
   uint64_t bytes = _mesa_format_image_size64(format, width, height, depth);
   uint64_t mbytes = bytes / (1024 * 1024); /* convert to MB */
   return mbytes <= (uint64_t) ctx->Const.MaxTextureMbytes;
}
d1544 149
d1721 3
d1726 1
a1726 1
   }      
d1742 1
a1742 1
         return GL_TRUE;
d1749 1
d1751 1
a1751 1
         return GL_TRUE;
d1753 2
d1764 2
a1765 1
         return ctx->Extensions.NV_texture_rectangle;
d1768 3
a1770 2
         return (ctx->Extensions.MESA_texture_array ||
                 ctx->Extensions.EXT_texture_array);
d1777 1
d1779 1
a1779 1
         return GL_TRUE;
d1781 4
d1786 6
a1791 2
         return (ctx->Extensions.MESA_texture_array ||
                 ctx->Extensions.EXT_texture_array);
d1813 1
a1813 1
      return target == GL_TEXTURE_1D;
d1826 2
a1827 1
         return ctx->Extensions.NV_texture_rectangle;
d1829 3
a1831 2
         return (ctx->Extensions.MESA_texture_array ||
                 ctx->Extensions.EXT_texture_array);
d1840 7
a1846 2
         return (ctx->Extensions.MESA_texture_array ||
                 ctx->Extensions.EXT_texture_array);
d1859 24
d1884 1
a1884 1
 * 
d1887 1
a1887 1
 * \param target texture target given by the user.
d1896 2
a1897 2
 * 
 * \return GL_TRUE if an error was detected, or GL_FALSE if no errors.
d1902 4
d1915 20
a1934 11
   const GLenum proxyTarget = get_proxy_target(target);
   const GLboolean isProxy = target == proxyTarget;
   GLboolean sizeOK = GL_TRUE;
   GLboolean colorFormat, indexFormat;

   /* Basic level check (more checking in ctx->Driver.TestProxyTexImage) */
   if (level < 0 || level >= MAX_TEXTURE_LEVELS) {
      if (!isProxy) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glTexImage%dD(level=%d)", dimensions, level);
      }
d1940 2
a1941 1
       ((target == GL_TEXTURE_RECTANGLE_NV ||
d1943 2
a1944 4
      if (!isProxy) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glTexImage%dD(border=%d)", dimensions, border);
      }
d1949 35
a1983 3
      if (!isProxy) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glTexImage%dD(width, height or depth < 0)", dimensions);
d1985 6
d1994 5
a1998 3
   /* Do this simple check before calling the TestProxyTexImage() function */
   if (proxyTarget == GL_PROXY_TEXTURE_CUBE_MAP_ARB) {
      sizeOK = (width == height);
d2001 4
a2004 14
   /*
    * Use the proxy texture driver hook to see if the size/level/etc are
    * legal.
    */
   sizeOK = sizeOK && ctx->Driver.TestProxyTexImage(ctx, proxyTarget, level,
                                                    internalFormat, format,
                                                    type, width, height,
                                                    depth, border);
   if (!sizeOK) {
      if (!isProxy) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glTexImage%dD(level=%d, width=%d, height=%d, depth=%d)",
                     dimensions, level, width, height, depth);
      }
d2010 3
a2012 5
      if (!isProxy) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glTexImage%dD(internalFormat=%s)",
                     dimensions, _mesa_lookup_enum_by_nr(internalFormat));
      }
d2017 6
a2022 13
   if (!_mesa_is_legal_format_and_type(ctx, format, type)) {
      /* Normally, GL_INVALID_OPERATION is generated by a format/type
       * mismatch (see the 1.2 spec page 94, sec 3.6.4.).  But with the
       * GL_EXT_texture_integer extension, some combinations should generate
       * GL_INVALID_ENUM instead (grr!).
       */
      if (!isProxy) {
         GLenum error = _mesa_is_integer_format(format)
            ? GL_INVALID_ENUM : GL_INVALID_OPERATION;
         _mesa_error(ctx, error,
                     "glTexImage%dD(incompatible format 0x%x, type 0x%x)",
                     dimensions, format, type);
      }
a2027 1
   indexFormat = _mesa_is_index_format(format);
a2028 1
       (_mesa_is_index_format(internalFormat) && !indexFormat) ||
d2033 4
a2036 4
      if (!isProxy)
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glTexImage%dD(incompatible internalFormat 0x%x, format 0x%x)",
                     dimensions, internalFormat, format);
d2047 2
a2048 1
                        "glTexImage%dD(format/type YCBCR mismatch", dimensions);
d2056 3
a2058 2
         if (!isProxy)
            _mesa_error(ctx, GL_INVALID_ENUM, "glTexImage(target)");
d2062 5
a2066 7
         if (!isProxy) {
            char message[100];
            _mesa_snprintf(message, sizeof(message),
                           "glTexImage%dD(format=GL_YCBCR_MESA and border=%d)",
                           dimensions, border);
            _mesa_error(ctx, GL_INVALID_VALUE, "%s", message);
         }
d2072 4
a2075 2
   if (_mesa_base_tex_format(ctx, internalFormat) == GL_DEPTH_COMPONENT) {
      /* Only 1D, 2D, rect and array textures supported, not 3D or cubes */
d2085 10
a2094 4
          target != GL_PROXY_TEXTURE_RECTANGLE_ARB) {
         if (!isProxy)
            _mesa_error(ctx, GL_INVALID_ENUM,
                        "glTexImage(target/internalFormat)");
d2102 7
a2108 3
         if (!isProxy)
            _mesa_error(ctx, GL_INVALID_ENUM,
                        "glTexImage%dD(target)", dimensions);
d2112 2
a2113 4
         if (!isProxy) {
            _mesa_error(ctx, GL_INVALID_OPERATION,
                        "glTexImage%dD(border!=0)", dimensions);
         }
d2119 12
a2130 8
   if (ctx->Extensions.EXT_texture_integer &&
       (_mesa_is_integer_format(format) !=
        _mesa_is_integer_format(internalFormat))) {
      if (!isProxy) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glTexImage%dD(integer/non-integer format mismatch)",
                     dimensions);
      }
d2140 4
a2143 20
 * Test glTexSubImage[123]D() parameters for errors.
 * 
 * \param ctx GL context.
 * \param dimensions texture image dimensions (must be 1, 2 or 3).
 * \param target texture target given by the user.
 * \param level image level given by the user.
 * \param xoffset sub-image x offset given by the user.
 * \param yoffset sub-image y offset given by the user.
 * \param zoffset sub-image z offset given by the user.
 * \param format pixel data format given by the user.
 * \param type pixel data type given by the user.
 * \param width image width given by the user.
 * \param height image height given by the user.
 * \param depth image depth given by the user.
 * 
 * \return GL_TRUE if an error was detected, or GL_FALSE if no errors.
 *
 * Verifies each of the parameters against the constants specified in
 * __struct gl_contextRec::Const and the supported extensions, and according
 * to the OpenGL specification.
d2145 6
a2150 6
static GLboolean
subtexture_error_check( struct gl_context *ctx, GLuint dimensions,
                        GLenum target, GLint level,
                        GLint xoffset, GLint yoffset, GLint zoffset,
                        GLint width, GLint height, GLint depth,
                        GLenum format, GLenum type )
d2152 9
a2160 4
   /* Basic level check */
   if (level < 0 || level >= MAX_TEXTURE_LEVELS) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glTexSubImage2D(level=%d)", level);
      return GL_TRUE;
d2163 5
a2167 15
   /* Check for negative sizes */
   if (width < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glTexSubImage%dD(width=%d)", dimensions, width);
      return GL_TRUE;
   }
   if (height < 0 && dimensions > 1) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glTexSubImage%dD(height=%d)", dimensions, height);
      return GL_TRUE;
   }
   if (depth < 0 && dimensions > 2) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glTexSubImage%dD(depth=%d)", dimensions, depth);
      return GL_TRUE;
d2170 100
a2269 11
   if (!_mesa_is_legal_format_and_type(ctx, format, type)) {
      /* As with the glTexImage2D check above, the error code here
       * depends on texture integer.
       */
      GLenum error = _mesa_is_integer_format(format)
         ? GL_INVALID_OPERATION : GL_INVALID_ENUM;
      _mesa_error(ctx, error,
                  "glTexSubImage%dD(incompatible format 0x%x, type 0x%x)",
                  dimensions, format, type);
      return GL_TRUE;
   }
a2270 2
   return GL_FALSE;
}
d2274 20
a2293 2
 * Do second part of glTexSubImage which depends on the destination texture.
 * \return GL_TRUE if error recorded, GL_FALSE otherwise
d2296 5
a2300 6
subtexture_error_check2( struct gl_context *ctx, GLuint dimensions,
			 GLenum target, GLint level,
			 GLint xoffset, GLint yoffset, GLint zoffset,
			 GLint width, GLint height, GLint depth,
			 GLenum format, GLenum type,
			 const struct gl_texture_image *destTex )
d2302 8
a2309 3
   if (!destTex) {
      /* undefined image level */
      _mesa_error(ctx, GL_INVALID_OPERATION, "glTexSubImage%dD", dimensions);
d2313 4
a2316 3
   if (xoffset < -((GLint)destTex->Border)) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glTexSubImage%dD(xoffset)",
                  dimensions);
d2319 14
a2332 14
   if (xoffset + width > (GLint) (destTex->Width + destTex->Border)) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glTexSubImage%dD(xoffset+width)",
                  dimensions);
      return GL_TRUE;
   }
   if (dimensions > 1) {
      if (yoffset < -((GLint)destTex->Border)) {
         _mesa_error(ctx, GL_INVALID_VALUE, "glTexSubImage%dD(yoffset)",
                     dimensions);
         return GL_TRUE;
      }
      if (yoffset + height > (GLint) (destTex->Height + destTex->Border)) {
         _mesa_error(ctx, GL_INVALID_VALUE, "glTexSubImage%dD(yoffset+height)",
                     dimensions);
d2336 16
a2351 9
   if (dimensions > 2) {
      if (zoffset < -((GLint)destTex->Border)) {
         _mesa_error(ctx, GL_INVALID_VALUE, "glTexSubImage3D(zoffset)");
         return GL_TRUE;
      }
      if (zoffset + depth  > (GLint) (destTex->Depth + destTex->Border)) {
         _mesa_error(ctx, GL_INVALID_VALUE, "glTexSubImage3D(zoffset+depth)");
         return GL_TRUE;
      }
d2354 7
a2360 2
   if (_mesa_is_format_compressed(destTex->TexFormat)) {
      GLuint bw, bh;
d2362 5
a2366 2
      /* do tests which depend on compression block size */
      _mesa_get_format_block_size(destTex->TexFormat, &bw, &bh);
d2368 2
a2369 2
      /* offset must be multiple of block size */
      if ((xoffset % bw != 0) || (yoffset % bh != 0)) {
d2371 1
a2371 2
                     "glTexSubImage%dD(xoffset = %d, yoffset = %d)",
                     dimensions, xoffset, yoffset);
d2374 6
a2379 2
      /* size must be multiple of bw by bh or equal to whole texture size */
      if ((width % bw != 0) && (GLuint) width != destTex->Width) {
d2381 2
a2382 1
                     "glTexSubImage%dD(width = %d)", dimensions, width);
d2384 1
a2384 6
      }         
      if ((height % bh != 0) && (GLuint) height != destTex->Height) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glTexSubImage%dD(height = %d)", dimensions, height);
         return GL_TRUE;
      }         
d2393 1
a2393 1
 * 
d2402 1
a2402 1
 * 
d2404 1
a2404 1
 * 
d2414 4
a2417 4
   const GLenum proxyTarget = get_proxy_target(target);
   const GLenum type = GL_FLOAT;
   GLboolean sizeOK;
   GLint format;
d2424 1
a2424 1
   }       
d2426 2
a2427 2
   /* Basic level check (more checking in ctx->Driver.TestProxyTexImage) */
   if (level < 0 || level >= MAX_TEXTURE_LEVELS) {
d2434 1
a2434 1
   if (ctx->ReadBuffer->Name) {
d2443 7
d2454 2
a2455 1
       ((target == GL_TEXTURE_RECTANGLE_NV ||
d2457 9
d2469 21
a2489 3
   format = _mesa_base_tex_format(ctx, internalFormat);
   if (format < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
d2494 68
a2561 1
   if (!_mesa_source_buffer_exists(ctx, format)) {
d2567 24
a2590 8
   /* Do size, level checking */
   sizeOK = (proxyTarget == GL_PROXY_TEXTURE_CUBE_MAP_ARB)
      ? (width == height) : 1;

   sizeOK = sizeOK && ctx->Driver.TestProxyTexImage(ctx, proxyTarget, level,
                                                    internalFormat, format,
                                                    type, width, height,
                                                    1, border);
d2592 4
a2595 10
   if (!sizeOK) {
      if (dimensions == 1) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glCopyTexImage1D(width=%d)", width);
      }
      else {
         ASSERT(dimensions == 2);
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glCopyTexImage2D(width=%d, height=%d)", width, height);
      }
d2605 1
a2605 1
      if (border != 0) {
d2607 1
a2607 1
                     "glCopyTexImage%dD(border!=0)", dimensions);
d2610 1
a2610 4
   }
   else if (_mesa_is_depth_format(internalFormat)) {
      /* make sure we have depth/stencil buffers */
      if (!ctx->ReadBuffer->_DepthBuffer) {
d2612 1
a2612 1
                     "glCopyTexImage%dD(no depth)", dimensions);
d2616 5
a2620 7
   else if (_mesa_is_depthstencil_format(internalFormat)) {
      /* make sure we have depth/stencil buffers */
      if (!ctx->ReadBuffer->_DepthBuffer || !ctx->ReadBuffer->_StencilBuffer) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glCopyTexImage%dD(no depth/stencil buffer)", dimensions);
         return GL_TRUE;
      }
a2629 8
 * Note that this is the first part of error checking.
 * See also copytexsubimage_error_check2() below for the second part.
 * 
 * \param ctx GL context.
 * \param dimensions texture image dimensions (must be 1, 2 or 3).
 * \param target texture target given by the user.
 * \param level image level given by the user.
 * 
d2633 4
a2636 2
copytexsubimage_error_check1( struct gl_context *ctx, GLuint dimensions,
                              GLenum target, GLint level)
d2638 3
d2642 1
a2642 1
   if (ctx->ReadBuffer->Name) {
d2651 7
d2668 1
a2668 1
   if (level < 0 || level >= MAX_TEXTURE_LEVELS) {
d2674 4
a2677 24
   return GL_FALSE;
}


/**
 * Second part of error checking for glCopyTexSubImage[12]D().
 * \param xoffset sub-image x offset given by the user.
 * \param yoffset sub-image y offset given by the user.
 * \param zoffset sub-image z offset given by the user.
 * \param width image width given by the user.
 * \param height image height given by the user.
 */
static GLboolean
copytexsubimage_error_check2( struct gl_context *ctx, GLuint dimensions,
			      GLenum target, GLint level,
			      GLint xoffset, GLint yoffset, GLint zoffset,
			      GLsizei width, GLsizei height,
			      const struct gl_texture_image *teximage )
{
   /* check that dest tex image exists */
   if (!teximage) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glCopyTexSubImage%dD(undefined texture level: %d)",
                  dimensions, level);
d2681 5
a2685 9
   /* Check size */
   if (width < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glCopyTexSubImage%dD(width=%d)", dimensions, width);
      return GL_TRUE;
   }
   if (dimensions > 1 && height < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glCopyTexSubImage%dD(height=%d)", dimensions, height);
d2689 4
a2692 9
   /* check x/y offsets */
   if (xoffset < -((GLint)teximage->Border)) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glCopyTexSubImage%dD(xoffset=%d)", dimensions, xoffset);
      return GL_TRUE;
   }
   if (xoffset + width > (GLint) (teximage->Width + teximage->Border)) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glCopyTexSubImage%dD(xoffset+width)", dimensions);
a2694 13
   if (dimensions > 1) {
      if (yoffset < -((GLint)teximage->Border)) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glCopyTexSubImage%dD(yoffset=%d)", dimensions, yoffset);
         return GL_TRUE;
      }
      /* NOTE: we're adding the border here, not subtracting! */
      if (yoffset + height > (GLint) (teximage->Height + teximage->Border)) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glCopyTexSubImage%dD(yoffset+height)", dimensions);
         return GL_TRUE;
      }
   }
d2696 4
a2699 19
   /* check z offset */
   if (dimensions > 2) {
      if (zoffset < -((GLint)teximage->Border)) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glCopyTexSubImage%dD(zoffset)", dimensions);
         return GL_TRUE;
      }
      if (zoffset > (GLint) (teximage->Depth + teximage->Border)) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glCopyTexSubImage%dD(zoffset+depth)", dimensions);
         return GL_TRUE;
      }
   }

   if (_mesa_is_format_compressed(teximage->TexFormat)) {
      /* offset must be multiple of 4 */
      if ((xoffset & 3) || (yoffset & 3)) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glCopyTexSubImage%dD(xoffset or yoffset)", dimensions);
a2701 11
      /* size must be multiple of 4 */
      if ((width & 3) != 0 && (GLuint) width != teximage->Width) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glCopyTexSubImage%dD(width)", dimensions);
         return GL_TRUE;
      }         
      if ((height & 3) != 0 && (GLuint) height != teximage->Height) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glCopyTexSubImage%dD(height)", dimensions);
         return GL_TRUE;
      }         
d2704 1
a2704 1
   if (teximage->InternalFormat == GL_YCBCR_MESA) {
d2709 1
a2709 1
   if (!_mesa_source_buffer_exists(ctx, teximage->_BaseFormat)) {
d2712 1
a2712 1
                  dimensions, teximage->_BaseFormat);
d2716 15
a2730 14
   if (teximage->_BaseFormat == GL_DEPTH_COMPONENT) {
      if (!ctx->ReadBuffer->_DepthBuffer) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glCopyTexSubImage%dD(no depth buffer)",
                     dimensions);
         return GL_TRUE;
      }
   }
   else if (teximage->_BaseFormat == GL_DEPTH_STENCIL_EXT) {
      if (!ctx->ReadBuffer->_DepthBuffer || !ctx->ReadBuffer->_StencilBuffer) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glCopyTexSubImage%dD(no depth/stencil buffer)",
                     dimensions);
         return GL_TRUE;
d2734 3
a2736 16
   /* If copying into an integer texture, the source buffer must also be
    * integer-valued.
    */
   if (_mesa_is_format_integer_color(teximage->TexFormat)) {
      struct gl_renderbuffer *rb = ctx->ReadBuffer->_ColorReadBuffer;
      if (!_mesa_is_format_integer_color(rb->Format)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glCopyTexSubImage%dD(source buffer is not integer format)",
                  dimensions);
         return GL_TRUE;
      }
   }

   /* if we get here, the parameters are OK */
   return GL_FALSE;
}
d2761 1
a2761 1
   if (fb->Name) {
d2770 2
a2771 3
            ASSERT(_mesa_get_attachment_teximage(att));
            /* Tell driver about the new renderbuffer texture */
            ctx->Driver.RenderTexture(ctx, ctx->DrawBuffer, att);
d2786 4
a2789 3
static void
update_fbo_texture(struct gl_context *ctx, struct gl_texture_object *texObj,
                   GLuint face, GLuint level)
d2808 1
a2808 1
static INLINE void
d2898 31
d2930 2
a2931 1
   f = ctx->Driver.ChooseTextureFormat(ctx, internalFormat, format, type);
d2938 7
a2944 1
 * Common code to implement all the glTexImage1D/2D/3D functions.
d2947 46
a2992 1
teximage(struct gl_context *ctx, GLuint dims,
d2996 1
a2996 1
         const GLvoid *pixels)
d2998 6
a3003 1
   GLboolean error;
d3005 1
a3005 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d3007 18
a3024 8
   if (MESA_VERBOSE & (VERBOSE_API|VERBOSE_TEXTURE))
      _mesa_debug(ctx, "glTexImage%uD %s %d %s %d %d %d %d %s %s %p\n",
                  dims,
                  _mesa_lookup_enum_by_nr(target), level,
                  _mesa_lookup_enum_by_nr(internalFormat),
                  width, height, depth, border,
                  _mesa_lookup_enum_by_nr(format),
                  _mesa_lookup_enum_by_nr(type), pixels);
d3030 2
a3031 2
      _mesa_error(ctx, GL_INVALID_ENUM, "glTexImage%uD(target=%s)",
                  dims, _mesa_lookup_enum_by_nr(target));
d3036 60
a3095 2
   error = texture_error_check(ctx, dims, target, level, internalFormat,
                               format, type, width, height, depth, border);
d3100 4
a3103 1
         _mesa_get_proxy_tex_image(ctx, target, level);
d3105 3
a3107 4
      if (error) {
         /* when error, clear all proxy texture image parameters */
         if (texImage)
            clear_teximage_fields(texImage);
d3110 1
a3110 16
         /* no error, set the tex image parameters */
         struct gl_texture_object *texObj =
            _mesa_get_current_tex_object(ctx, target);
         gl_format texFormat = _mesa_choose_texture_format(ctx, texObj,
                                                           target, level,
                                                           internalFormat,
                                                           format, type);

         if (legal_texture_size(ctx, texFormat, width, height, depth)) {
            _mesa_init_teximage_fields(ctx, target, texImage, width, height,
                                       depth, border, internalFormat,
                                       texFormat);
         }
         else if (texImage) {
            clear_teximage_fields(texImage);
         }
a3115 1
      struct gl_texture_object *texObj;
d3118 22
a3139 2
      if (error) {
         return;   /* error was recorded */
a3144 2
      texObj = _mesa_get_current_tex_object(ctx, target);

d3150 1
a3150 1
	    _mesa_error(ctx, GL_OUT_OF_MEMORY, "glTexImage%uD", dims);
d3153 1
a3153 1
            gl_format texFormat;
d3155 3
a3157 3
            if (texImage->Data) {
               ctx->Driver.FreeTexImageData( ctx, texImage );
            }
d3159 9
a3167 33
            ASSERT(texImage->Data == NULL);
            texFormat = _mesa_choose_texture_format(ctx, texObj, target, level,
                                                    internalFormat, format,
                                                    type);

            if (legal_texture_size(ctx, texFormat, width, height, depth)) {
               _mesa_init_teximage_fields(ctx, target, texImage,
                                          width, height, depth,
                                          border, internalFormat, texFormat);

               /* Give the texture to the driver.  <pixels> may be null. */
               ASSERT(ctx->Driver.TexImage3D);
               switch (dims) {
               case 1:
                  ctx->Driver.TexImage1D(ctx, target, level, internalFormat,
                                         width, border, format,
                                         type, pixels, &ctx->Unpack, texObj,
                                         texImage);
                  break;
               case 2:
                  ctx->Driver.TexImage2D(ctx, target, level, internalFormat,
                                         width, height, border, format,
                                         type, pixels, &ctx->Unpack, texObj,
                                         texImage);
                  break;
               case 3:
                  ctx->Driver.TexImage3D(ctx, target, level, internalFormat,
                                         width, height, depth, border, format,
                                         type, pixels, &ctx->Unpack, texObj,
                                         texImage);
                  break;
               default:
                  _mesa_problem(ctx, "invalid dims=%u in teximage()", dims);
d3169 1
d3171 1
a3171 1
               check_gen_mipmap(ctx, target, texObj, level);
d3173 1
a3173 1
               update_fbo_texture(ctx, texObj, face, level);
d3175 1
a3175 7
               /* state update */
               texObj->_Complete = GL_FALSE;
               ctx->NewState |= _NEW_TEXTURE;
            }
            else {
               _mesa_error(ctx, GL_OUT_OF_MEMORY, "glTexImage%uD", dims);
            }
d3183 1
d3193 2
a3194 2
   teximage(ctx, 1, target, level, internalFormat, width, 1, 1,
            border, format, type, pixels);
d3205 2
a3206 2
   teximage(ctx, 2, target, level, internalFormat, width, height, 1,
            border, format, type, pixels);
d3221 3
a3223 2
   teximage(ctx, 3, target, level, internalFormat, width, height, depth,
            border, format, type, pixels);
a3237 1
#if FEATURE_OES_EGL_image
d3243 1
d3245 1
a3245 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d3247 11
a3257 4
   if (!ctx->Extensions.OES_EGL_image) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glEGLImageTargetTexture2DOES(unsupported)");
      return;
d3260 1
a3260 1
   if (target != GL_TEXTURE_2D) {
d3266 6
d3278 7
d3289 1
a3289 2
      if (texImage->Data)
	 ctx->Driver.FreeTexImageData( ctx, texImage );
a3290 1
      ASSERT(texImage->Data == NULL);
d3294 1
a3294 3
      /* state update */
      texObj->_Complete = GL_FALSE;
      ctx->NewState |= _NEW_TEXTURE;
a3298 1
#endif
d3314 1
a3314 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d3329 1
a3329 1
   }       
d3334 3
a3336 2
   if (subtexture_error_check(ctx, dims, target, level, xoffset, yoffset, zoffset,
                              width, height, depth, format, type)) {
d3346 1
a3346 7
      if (subtexture_error_check2(ctx, dims, target, level,
                                  xoffset, yoffset, zoffset,
				  width, height, depth,
                                  format, type, texImage)) {
         /* error was recorded */
      }
      else if (width > 0 && height > 0 && depth > 0) {
d3350 2
a3351 1
            zoffset += texImage->Border;
d3354 2
a3355 1
            yoffset += texImage->Border;
d3361 4
a3364 23
         switch (dims) {
         case 1:
            ctx->Driver.TexSubImage1D(ctx, target, level,
                                      xoffset, width,
                                      format, type, pixels,
                                      &ctx->Unpack, texObj, texImage );
            break;
         case 2:
            ctx->Driver.TexSubImage2D(ctx, target, level,
                                      xoffset, yoffset, width, height,
                                      format, type, pixels,
                                      &ctx->Unpack, texObj, texImage );
            break;
         case 3:
            ctx->Driver.TexSubImage3D(ctx, target, level,
                                      xoffset, yoffset, zoffset,
                                      width, height, depth,
                                      format, type, pixels,
                                      &ctx->Unpack, texObj, texImage );
            break;
         default:
            _mesa_problem(ctx, "unexpected dims in subteximage()");
         }
d3422 48
d3480 1
d3482 1
a3482 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d3498 7
d3506 23
d3538 1
a3538 8
         /* choose actual hw format */
         gl_format texFormat = _mesa_choose_texture_format(ctx, texObj,
                                                           target, level,
                                                           internalFormat,
                                                           GL_NONE, GL_NONE);

         if (legal_texture_size(ctx, texFormat, width, height, 1)) {
            GLint srcX = x, srcY = y, dstX = 0, dstY = 0;
d3540 2
a3541 2
            /* Free old texture image */
            ctx->Driver.FreeTexImageData(ctx, texImage);
d3543 2
a3544 2
            _mesa_init_teximage_fields(ctx, target, texImage, width, height, 1,
                                       border, internalFormat, texFormat);
d3546 1
d3548 1
a3548 10
            if (dims == 1) {
               ctx->Driver.TexImage1D(ctx, target, level, internalFormat,
                                      width, border, GL_NONE, GL_NONE, NULL,
                                      &ctx->Unpack, texObj, texImage);
            }
            else {
               ctx->Driver.TexImage2D(ctx, target, level, internalFormat,
                                      width, height, border, GL_NONE, GL_NONE,
                                      NULL, &ctx->Unpack, texObj, texImage);
            }
d3552 6
a3557 7
               if (dims == 1)
                  ctx->Driver.CopyTexSubImage1D(ctx, target, level, dstX,
                                                srcX, srcY, width);
                                                
               else
                  ctx->Driver.CopyTexSubImage2D(ctx, target, level, dstX, dstY,
                                                srcX, srcY, width, height);
d3561 1
d3563 1
a3563 1
            update_fbo_texture(ctx, texObj, face, level);
d3565 1
a3565 8
            /* state update */
            texObj->_Complete = GL_FALSE;
            ctx->NewState |= _NEW_TEXTURE;
         }
         else {
            /* probably too large of image */
            _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCopyTexImage%uD", dims);
         }
d3608 1
a3608 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d3619 2
a3620 1
   if (copytexsubimage_error_check1(ctx, dims, target, level))
d3622 1
d3630 4
a3633 8
      if (copytexsubimage_error_check2(ctx, dims, target, level, xoffset, yoffset,
				       zoffset, width, height, texImage)) {
         /* error was recored */
      }
      else {
         /* If we have a border, offset=-1 is legal.  Bias by border width. */
         switch (dims) {
         case 3:
d3635 3
a3637 2
            /* fall-through */
         case 2:
d3639 9
a3647 4
            /* fall-through */
         case 1:
            xoffset += texImage->Border;
         }
d3649 3
a3651 20
         if (_mesa_clip_copytexsubimage(ctx, &xoffset, &yoffset, &x, &y,
                                        &width, &height)) {
            switch (dims) {
            case 1:
               ctx->Driver.CopyTexSubImage1D(ctx, target, level,
                                             xoffset, x, y, width);
               break;
            case 2:
               ctx->Driver.CopyTexSubImage2D(ctx, target, level,
                                             xoffset, yoffset,
                                             x, y, width, height);
               break;
            case 3:
               ctx->Driver.CopyTexSubImage3D(ctx, target, level,
                                             xoffset, yoffset, zoffset,
                                             x, y, width, height);
               break;
            default:
               _mesa_problem(ctx, "bad dims in copytexsubimage()");
            }
d3653 1
a3653 1
            check_gen_mipmap(ctx, target, texObj, level);
d3655 1
a3655 2
            ctx->NewState |= _NEW_TEXTURE;
         }
d3703 1
a3703 25
 * Return expected size of a compressed texture.
 */
static GLuint
compressed_tex_size(GLsizei width, GLsizei height, GLsizei depth,
                    GLenum glformat)
{
   gl_format mesaFormat = _mesa_glenum_to_compressed_format(glformat);
   return _mesa_format_image_size(mesaFormat, width, height, depth);
}


/*
 * Return compressed texture block size, in pixels.
 */
static void
get_compressed_block_size(GLenum glformat, GLuint *bw, GLuint *bh)
{
   gl_format mesaFormat = _mesa_glenum_to_compressed_format(glformat);
   _mesa_get_format_block_size(mesaFormat, bw, bh);
}


/**
 * Error checking for glCompressedTexImage[123]D().
 * \param reason  returns reason for error, if any
d3707 5
a3711 5
compressed_texture_error_check(struct gl_context *ctx, GLint dimensions,
                               GLenum target, GLint level,
                               GLenum internalFormat, GLsizei width,
                               GLsizei height, GLsizei depth, GLint border,
                               GLsizei imageSize, char **reason)
d3713 2
a3714 2
   const GLenum proxyTarget = get_proxy_target(target);
   const GLint maxLevels = _mesa_max_texture_levels(ctx, target);
d3716 1
a3716 3
   GLenum choose_format;
   GLenum choose_type;
   GLenum proxy_format;
d3718 15
a3732 33
   *reason = ""; /* no error */

   if (!target_can_be_compressed(ctx, target, internalFormat)) {
      *reason = "target";
      return GL_INVALID_ENUM;
   }

   /* This will detect any invalid internalFormat value */
   if (!_mesa_is_compressed_format(ctx, internalFormat)) {
      *reason = "internalFormat";
      return GL_INVALID_ENUM;
   }

   switch (internalFormat) {
#if FEATURE_ES
   case GL_PALETTE4_RGB8_OES:
   case GL_PALETTE4_RGBA8_OES:
   case GL_PALETTE4_R5_G6_B5_OES:
   case GL_PALETTE4_RGBA4_OES:
   case GL_PALETTE4_RGB5_A1_OES:
   case GL_PALETTE8_RGB8_OES:
   case GL_PALETTE8_RGBA8_OES:
   case GL_PALETTE8_R5_G6_B5_OES:
   case GL_PALETTE8_RGBA4_OES:
   case GL_PALETTE8_RGB5_A1_OES:
      _mesa_cpal_compressed_format_type(internalFormat, &choose_format,
					&choose_type);
      proxy_format = choose_format;

      /* check level */
      if (level > 0 || level < -maxLevels) {
	 *reason = "level";
	 return GL_INVALID_VALUE;
a3733 20

      if (dimensions != 2) {
	 *reason = "compressed paletted textures must be 2D";
	 return GL_INVALID_OPERATION;
      }

      /* Figure out the expected texture size (in bytes).  This will be
       * checked against the actual size later.
       */
      expectedSize = _mesa_cpal_compressed_size(level, internalFormat,
						width, height);

      /* This is for the benefit of the TestProxyTexImage below.  It expects
       * level to be non-negative.  OES_compressed_paletted_texture uses a
       * weird mechanism where the level specified to glCompressedTexImage2D
       * is -(n-1) number of levels in the texture, and the data specifies the
       * complete mipmap stack.  This is done to ensure the palette is the
       * same for all levels.
       */
      level = -level;
d3735 3
a3737 2
#endif

d3739 3
a3741 14
      choose_format = GL_NONE;
      choose_type = GL_NONE;
      proxy_format = internalFormat;

      /* check level */
      if (level < 0 || level >= maxLevels) {
	 *reason = "level";
	 return GL_INVALID_VALUE;
      }

      /* Figure out the expected texture size (in bytes).  This will be
       * checked against the actual size later.
       */
      expectedSize = compressed_tex_size(width, height, depth, internalFormat);
d3745 4
a3748 4
   /* This should really never fail */
   if (_mesa_base_tex_format(ctx, internalFormat) < 0) {
      *reason = "internalFormat";
      return GL_INVALID_ENUM;
d3751 5
a3755 4
   /* No compressed formats support borders at this time */
   if (border != 0) {
      *reason = "border != 0";
      return GL_INVALID_VALUE;
d3758 4
a3761 5
   /* For cube map, width must equal height */
   if (target >= GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB &&
       target <= GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB && width != height) {
      *reason = "width != height";
      return GL_INVALID_VALUE;
d3764 1
a3764 31
   /* check image size against compression block size */
   {
      gl_format texFormat =
         ctx->Driver.ChooseTextureFormat(ctx, proxy_format,
					 choose_format, choose_type);
      GLuint bw, bh;

      _mesa_get_format_block_size(texFormat, &bw, &bh);
      if ((width > bw && width % bw > 0) ||
          (height > bh && height % bh > 0)) {
         /*
          * Per GL_ARB_texture_compression:  GL_INVALID_OPERATION is
          * generated [...] if any parameter combinations are not
          * supported by the specific compressed internal format. 
          */
         *reason = "invalid width or height for compression format";
         return GL_INVALID_OPERATION;
      }
   }

   /* check image sizes */
   if (!ctx->Driver.TestProxyTexImage(ctx, proxyTarget, level,
				      proxy_format, choose_format,
				      choose_type,
				      width, height, depth, border)) {
      /* See error comment above */
      *reason = "invalid width, height or format";
      return GL_INVALID_OPERATION;
   }

   /* check image size in bytes */
d3766 2
a3767 113
      /* Per GL_ARB_texture_compression:  GL_INVALID_VALUE is generated [...]
       * if <imageSize> is not consistent with the format, dimensions, and
       * contents of the specified image.
       */
      *reason = "imageSize inconsistant with width/height/format";
      return GL_INVALID_VALUE;
   }

   return GL_NO_ERROR;
}


/**
 * Error checking for glCompressedTexSubImage[123]D().
 * \warning  There are some bad assumptions here about the size of compressed
 *           texture tiles (multiple of 4) used to test the validity of the
 *           offset and size parameters.
 * \return error code or GL_NO_ERROR.
 */
static GLenum
compressed_subtexture_error_check(struct gl_context *ctx, GLint dimensions,
                                  GLenum target, GLint level,
                                  GLint xoffset, GLint yoffset, GLint zoffset,
                                  GLsizei width, GLsizei height, GLsizei depth,
                                  GLenum format, GLsizei imageSize)
{
   GLint expectedSize, maxLevels = 0, maxTextureSize;
   GLuint bw, bh;
   (void) zoffset;

   if (dimensions == 1) {
      /* 1D compressed textures not allowed */
      return GL_INVALID_ENUM;
   }
   else if (dimensions == 2) {
      if (target == GL_PROXY_TEXTURE_2D) {
         maxLevels = ctx->Const.MaxTextureLevels;
      }
      else if (target == GL_TEXTURE_2D) {
         maxLevels = ctx->Const.MaxTextureLevels;
      }
      else if (target == GL_PROXY_TEXTURE_CUBE_MAP_ARB) {
         if (!ctx->Extensions.ARB_texture_cube_map)
            return GL_INVALID_ENUM; /*target*/
         maxLevels = ctx->Const.MaxCubeTextureLevels;
      }
      else if (target >= GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB &&
               target <= GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB) {
         if (!ctx->Extensions.ARB_texture_cube_map)
            return GL_INVALID_ENUM; /*target*/
         maxLevels = ctx->Const.MaxCubeTextureLevels;
      }
      else {
         return GL_INVALID_ENUM; /*target*/
      }
   }
   else if (dimensions == 3) {
      /* 3D compressed textures not allowed */
      return GL_INVALID_ENUM;
   }

   maxTextureSize = 1 << (maxLevels - 1);

   /* this will catch any invalid compressed format token */
   if (!_mesa_is_compressed_format(ctx, format))
      return GL_INVALID_ENUM;

   if (width < 1 || width > maxTextureSize)
      return GL_INVALID_VALUE;

   if ((height < 1 || height > maxTextureSize)
       && dimensions > 1)
      return GL_INVALID_VALUE;

   if (level < 0 || level >= maxLevels)
      return GL_INVALID_VALUE;

   /*
    * do checks which depend on compression block size
    */
   get_compressed_block_size(format, &bw, &bh);

   if ((xoffset % bw != 0) || (yoffset % bh != 0))
      return GL_INVALID_VALUE;

   if ((width % bw != 0) && width != 2 && width != 1)
      return GL_INVALID_VALUE;

   if ((height % bh != 0) && height != 2 && height != 1)
      return GL_INVALID_VALUE;

   expectedSize = compressed_tex_size(width, height, depth, format);
   if (expectedSize != imageSize)
      return GL_INVALID_VALUE;

   return GL_NO_ERROR;
}


/**
 * Do second part of glCompressedTexSubImage error checking.
 * \return GL_TRUE if error found, GL_FALSE otherwise.
 */
static GLboolean
compressed_subtexture_error_check2(struct gl_context *ctx, GLuint dims,
                                   GLsizei width, GLsizei height,
                                   GLsizei depth, GLenum format,
                                   struct gl_texture_image *texImage)
{

   if ((GLint) format != texImage->InternalFormat) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glCompressedTexSubImage%uD(format=0x%x)", dims, format);
d3771 4
a3774 5
   if (((width == 1 || width == 2) &&
        width != (GLsizei) texImage->Width) ||
       (width > (GLsizei) texImage->Width)) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glCompressedTexSubImage%uD(width=%d)", dims, width);
d3778 6
a3783 139
   if (dims >= 2) {
      if (((height == 1 || height == 2) &&
           height != (GLsizei) texImage->Height) ||
          (height > (GLsizei) texImage->Height)) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glCompressedTexSubImage%uD(height=%d)", dims, height);
         return GL_TRUE;
      }
   }

   if (dims >= 3) {
      if (((depth == 1 || depth == 2) &&
           depth != (GLsizei) texImage->Depth) ||
          (depth > (GLsizei) texImage->Depth)) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glCompressedTexSubImage%uD(depth=%d)", dims, depth);
         return GL_TRUE;
      }
   }

   return GL_FALSE;
}


/**
 * Implementation of the glCompressedTexImage1/2/3D() functions.
 */
static void
compressedteximage(struct gl_context *ctx, GLuint dims,
                   GLenum target, GLint level,
                   GLenum internalFormat, GLsizei width,
                   GLsizei height, GLsizei depth, GLint border,
                   GLsizei imageSize, const GLvoid *data)
{
   GLenum error;
   char *reason = "";

   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

   if (MESA_VERBOSE & (VERBOSE_API|VERBOSE_TEXTURE))
      _mesa_debug(ctx,
                  "glCompressedTexImage%uDARB %s %d %s %d %d %d %d %d %p\n",
                  dims,
                  _mesa_lookup_enum_by_nr(target), level,
                  _mesa_lookup_enum_by_nr(internalFormat),
                  width, height, depth, border, imageSize, data);

   /* check target */
   if (!legal_teximage_target(ctx, dims, target)) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glCompressedTexImage%uD(target=%s)",
                  dims, _mesa_lookup_enum_by_nr(target));
      return;
   }

   error = compressed_texture_error_check(ctx, dims, target, level,
                                          internalFormat, width, height, depth,
                                          border, imageSize, &reason);

   if (error) {
      _mesa_error(ctx, error, "glCompressedTexImage%uD(%s)", dims, reason);
      return;
   }

#if FEATURE_ES
   /* XXX this is kind of a hack */
   if (dims == 2) {
      switch (internalFormat) {
      case GL_PALETTE4_RGB8_OES:
      case GL_PALETTE4_RGBA8_OES:
      case GL_PALETTE4_R5_G6_B5_OES:
      case GL_PALETTE4_RGBA4_OES:
      case GL_PALETTE4_RGB5_A1_OES:
      case GL_PALETTE8_RGB8_OES:
      case GL_PALETTE8_RGBA8_OES:
      case GL_PALETTE8_R5_G6_B5_OES:
      case GL_PALETTE8_RGBA4_OES:
      case GL_PALETTE8_RGB5_A1_OES:
         _mesa_cpal_compressed_teximage2d(target, level, internalFormat,
                                          width, height, imageSize, data);
         return;
      }
   }
#endif

   if (_mesa_is_proxy_texture(target)) {
      /* Proxy texture: just check for errors and update proxy state */
      struct gl_texture_image *texImage;

      if (!error) {
         struct gl_texture_object *texObj =
            _mesa_get_current_tex_object(ctx, target);
         gl_format texFormat =
            _mesa_choose_texture_format(ctx, texObj, target, level,
                                        internalFormat, GL_NONE, GL_NONE);
         if (!legal_texture_size(ctx, texFormat, width, height, depth)) {
            error = GL_OUT_OF_MEMORY;
         }
      }

      texImage = _mesa_get_proxy_tex_image(ctx, target, level);
      if (texImage) {
         if (error) {
            /* if error, clear all proxy texture image parameters */
            clear_teximage_fields(texImage);
         }
         else {
            /* no error: store the teximage parameters */
            _mesa_init_teximage_fields(ctx, target, texImage, width, height,
                                       depth, border, internalFormat,
                                       MESA_FORMAT_NONE);
         }
      }
   }
   else {
      /* non-proxy target */
      struct gl_texture_object *texObj;
      struct gl_texture_image *texImage;

      if (error) {
         _mesa_error(ctx, error, "glCompressedTexImage%uD", dims);
         return;
      }

      texObj = _mesa_get_current_tex_object(ctx, target);

      _mesa_lock_texture(ctx, texObj);
      {
	 texImage = _mesa_get_tex_image(ctx, texObj, target, level);
	 if (!texImage) {
	    _mesa_error(ctx, GL_OUT_OF_MEMORY,
                        "glCompressedTexImage%uD", dims);
	 }
         else {
            gl_format texFormat;

            if (texImage->Data) {
               ctx->Driver.FreeTexImageData( ctx, texImage );
            }
            ASSERT(texImage->Data == NULL);
d3785 5
a3789 37
            texFormat = _mesa_choose_texture_format(ctx, texObj, target, level,
                                                    internalFormat, GL_NONE,
                                                    GL_NONE);

            if (legal_texture_size(ctx, texFormat, width, height, depth)) {
               _mesa_init_teximage_fields(ctx, target, texImage,
                                          width, height, depth,
                                          border, internalFormat, texFormat);

               switch (dims) {
               case 1:
                  ASSERT(ctx->Driver.CompressedTexImage1D);
                  ctx->Driver.CompressedTexImage1D(ctx, target, level,
                                                   internalFormat,
                                                   width,
                                                   border, imageSize, data,
                                                   texObj, texImage);
                  break;
               case 2:
                  ASSERT(ctx->Driver.CompressedTexImage2D);
                  ctx->Driver.CompressedTexImage2D(ctx, target, level,
                                                   internalFormat,
                                                   width, height,
                                                   border, imageSize, data,
                                                   texObj, texImage);
                  break;
               case 3:
                  ASSERT(ctx->Driver.CompressedTexImage3D);
                  ctx->Driver.CompressedTexImage3D(ctx, target, level,
                                                   internalFormat,
                                                   width, height, depth,
                                                   border, imageSize, data,
                                                   texObj, texImage);
                  break;
               default:
                  _mesa_problem(ctx, "bad dims in compressedteximage");
               }
d3791 6
a3796 1
               check_gen_mipmap(ctx, target, texObj, level);
d3798 4
a3801 11
               /* state update */
               texObj->_Complete = GL_FALSE;
               ctx->NewState |= _NEW_TEXTURE;
            }
            else {
               _mesa_error(ctx, GL_OUT_OF_MEMORY,
                           "glCompressedTexImage%uD", dims);
            }
         }
      }
      _mesa_unlock_texture(ctx, texObj);
d3803 2
d3809 1
a3809 1
_mesa_CompressedTexImage1DARB(GLenum target, GLint level,
d3815 2
a3816 2
   compressedteximage(ctx, 1, target, level, internalFormat,
                      width, 1, 1, border, imageSize, data);
d3821 1
a3821 1
_mesa_CompressedTexImage2DARB(GLenum target, GLint level,
d3827 2
a3828 2
   compressedteximage(ctx, 2, target, level, internalFormat,
                      width, height, 1, border, imageSize, data);
d3833 1
a3833 1
_mesa_CompressedTexImage3DARB(GLenum target, GLint level,
d3839 2
a3840 2
   compressedteximage(ctx, 3, target, level, internalFormat,
                      width, height, depth, border, imageSize, data);
a3854 1
   GLenum error;
d3856 1
a3856 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d3858 4
a3861 6
   error = compressed_subtexture_error_check(ctx, dims, target, level,
                                             xoffset, 0, 0, /* pos */
                                             width, height, depth,   /* size */
                                             format, imageSize);
   if (error) {
      _mesa_error(ctx, error, "glCompressedTexSubImage%uD", dims);
d3872 5
a3876 35
      if (compressed_subtexture_error_check2(ctx, dims, width, height, depth,
                                             format, texImage)) {
         /* error was recorded */
      }
      else if (width > 0 && height > 0 && depth > 0) {
         switch (dims) {
         case 1:
            if (ctx->Driver.CompressedTexSubImage1D) {
               ctx->Driver.CompressedTexSubImage1D(ctx, target, level,
                                                   xoffset, width,
                                                   format, imageSize, data,
                                                   texObj, texImage);
            }
            break;
         case 2:
            if (ctx->Driver.CompressedTexSubImage2D) {
               ctx->Driver.CompressedTexSubImage2D(ctx, target, level,
                                                   xoffset, yoffset,
                                                   width, height,
                                                   format, imageSize, data,
                                                   texObj, texImage);
            }
            break;
         case 3:
            if (ctx->Driver.CompressedTexSubImage3D) {
               ctx->Driver.CompressedTexSubImage3D(ctx, target, level,
                                                   xoffset, yoffset, zoffset,
                                                   width, height, depth,
                                                   format, imageSize, data,
                                                   texObj, texImage);
            }
            break;
         default:
            ;
         }
d3888 1
a3888 1
_mesa_CompressedTexSubImage1DARB(GLenum target, GLint level, GLint xoffset,
d3898 1
a3898 1
_mesa_CompressedTexSubImage2DARB(GLenum target, GLint level, GLint xoffset,
d3909 1
a3909 1
_mesa_CompressedTexSubImage3DARB(GLenum target, GLint level, GLint xoffset,
d3918 2
a3919 9

/**
 * Helper for glTexBuffer().  Check if internalFormat is legal.  If so,
 * return the basic data type and number of components for the format.
 * \param return  GL_TRUE if internalFormat is legal, GL_FALSE otherwise
 */
static GLboolean
get_sized_format_info(const struct gl_context *ctx, GLenum internalFormat,
                      GLenum *datatype, GLuint *components)
d3923 1
a3923 3
      *datatype = GL_UNSIGNED_BYTE;
      *components = 1;
      break;
d3925 1
a3925 3
      *datatype = GL_UNSIGNED_SHORT;
      *components = 1;
      break;
d3927 1
a3927 3
      *datatype = GL_HALF_FLOAT;
      *components = 1;
      break;
d3929 1
a3929 3
      *datatype = GL_FLOAT;
      *components = 1;
      break;
d3931 1
a3931 3
      *datatype = GL_BYTE;
      *components = 1;
      break;
d3933 1
a3933 3
      *datatype = GL_SHORT;
      *components = 1;
      break;
d3935 1
a3935 3
      *datatype = GL_INT;
      *components = 1;
      break;
d3937 1
a3937 3
      *datatype = GL_UNSIGNED_BYTE;
      *components = 1;
      break;
d3939 1
a3939 3
      *datatype = GL_UNSIGNED_SHORT;
      *components = 1;
      break;
d3941 1
a3941 3
      *datatype = GL_UNSIGNED_INT;
      *components = 1;
      break;
d3943 1
a3943 3
      *datatype = GL_UNSIGNED_BYTE;
      *components = 1;
      break;
d3945 1
a3945 3
      *datatype = GL_UNSIGNED_SHORT;
      *components = 1;
      break;
d3947 1
a3947 3
      *datatype = GL_HALF_FLOAT;
      *components = 1;
      break;
d3949 1
a3949 3
      *datatype = GL_FLOAT;
      *components = 1;
      break;
d3951 1
a3951 3
      *datatype = GL_BYTE;
      *components = 1;
      break;
d3953 1
a3953 3
      *datatype = GL_SHORT;
      *components = 1;
      break;
d3955 1
a3955 3
      *datatype = GL_INT;
      *components = 1;
      break;
d3957 1
a3957 3
      *datatype = GL_UNSIGNED_BYTE;
      *components = 1;
      break;
d3959 1
a3959 3
      *datatype = GL_UNSIGNED_SHORT;
      *components = 1;
      break;
d3961 1
a3961 3
      *datatype = GL_UNSIGNED_INT;
      *components = 1;
      break;
d3963 1
a3963 3
      *datatype = GL_UNSIGNED_BYTE;
      *components = 2;
      break;
d3965 1
a3965 3
      *datatype = GL_UNSIGNED_SHORT;
      *components = 2;
      break;
d3967 1
a3967 3
      *datatype = GL_HALF_FLOAT;
      *components = 2;
      break;
d3969 1
a3969 3
      *datatype = GL_FLOAT;
      *components = 2;
      break;
d3971 1
a3971 3
      *datatype = GL_BYTE;
      *components = 2;
      break;
d3973 1
a3973 3
      *datatype = GL_SHORT;
      *components = 2;
      break;
d3975 1
a3975 3
      *datatype = GL_INT;
      *components = 2;
      break;
d3977 1
a3977 3
      *datatype = GL_UNSIGNED_BYTE;
      *components = 2;
      break;
d3979 1
a3979 3
      *datatype = GL_UNSIGNED_SHORT;
      *components = 2;
      break;
d3981 1
a3981 3
      *datatype = GL_UNSIGNED_INT;
      *components = 2;
      break;
d3983 1
a3983 3
      *datatype = GL_UNSIGNED_BYTE;
      *components = 1;
      break;
d3985 1
a3985 3
      *datatype = GL_UNSIGNED_SHORT;
      *components = 1;
      break;
d3987 1
a3987 3
      *datatype = GL_HALF_FLOAT;
      *components = 1;
      break;
d3989 1
a3989 3
      *datatype = GL_FLOAT;
      *components = 1;
      break;
d3991 1
a3991 3
      *datatype = GL_BYTE;
      *components = 1;
      break;
d3993 1
a3993 3
      *datatype = GL_SHORT;
      *components = 1;
      break;
d3995 1
a3995 3
      *datatype = GL_INT;
      *components = 1;
      break;
d3997 1
a3997 3
      *datatype = GL_UNSIGNED_BYTE;
      *components = 1;
      break;
d3999 1
a3999 3
      *datatype = GL_UNSIGNED_SHORT;
      *components = 1;
      break;
d4001 1
a4001 3
      *datatype = GL_UNSIGNED_INT;
      *components = 1;
      break;
d4003 1
a4003 3
      *datatype = GL_UNSIGNED_BYTE;
      *components = 4;
      break;
d4005 1
a4005 3
      *datatype = GL_UNSIGNED_SHORT;
      *components = 4;
      break;
d4007 1
a4007 3
      *datatype = GL_HALF_FLOAT;
      *components = 4;
      break;
d4009 1
a4009 3
      *datatype = GL_FLOAT;
      *components = 4;
      break;
d4011 1
a4011 3
      *datatype = GL_BYTE;
      *components = 4;
      break;
d4013 1
a4013 3
      *datatype = GL_SHORT;
      *components = 4;
      break;
d4015 1
a4015 3
      *datatype = GL_INT;
      *components = 4;
      break;
d4017 1
a4017 3
      *datatype = GL_UNSIGNED_BYTE;
      *components = 4;
      break;
d4019 1
a4019 3
      *datatype = GL_UNSIGNED_SHORT;
      *components = 4;
      break;
d4021 51
a4071 3
      *datatype = GL_UNSIGNED_INT;
      *components = 4;
      break;
d4073 54
a4126 1
      return GL_FALSE;
d4129 6
a4134 2
   if (*datatype == GL_FLOAT && !ctx->Extensions.ARB_texture_float)
      return GL_FALSE;
d4136 1
a4136 2
   if (*datatype == GL_HALF_FLOAT && !ctx->Extensions.ARB_half_float_pixel)
      return GL_FALSE;
d4138 9
a4146 1
   return GL_TRUE;
a4153 1
   struct gl_texture_object *texObj;
a4154 2
   GLenum dataType;
   GLuint comps;
a4156 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d4158 5
a4162 1
   if (!ctx->Extensions.ARB_texture_buffer_object) {
d4167 3
a4169 2
   if (target != GL_TEXTURE_BUFFER_ARB) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glTexBuffer(target)");
d4173 16
a4188 3
   if (!get_sized_format_info(ctx, internalFormat, &dataType, &comps)) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glTexBuffer(internalFormat 0x%x)",
                  internalFormat);
d4193 102
a4294 2
   if (buffer && !bufObj) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glTexBuffer(buffer %u)", buffer);
d4300 78
a4377 4
   _mesa_lock_texture(ctx, texObj);
   {
      _mesa_reference_buffer_object(ctx, &texObj->BufferObject, bufObj);
      texObj->BufferObjectFormat = internalFormat;
d4379 46
a4424 1
   _mesa_unlock_texture(ctx, texObj);
@


1.6
log
@Merge Mesa 7.10.3
@
text
@d43 1
d58 1
a58 3
#define NEW_COPY_TEX_STATE (_MESA_NEW_TRANSFER_STATE | \
                            _NEW_BUFFERS | \
                            _NEW_PIXEL)
a82 30
/*
 * Compute floor(log_base_2(n)).
 * If n < 0 return -1.
 */
static int
logbase2( int n )
{
   GLint i = 1;
   GLint log2 = 0;

   if (n < 0)
      return -1;

   if (n == 0)
      return 0;

   while ( n > i ) {
      i *= 2;
      log2++;
   }
   if (i != n) {
      return log2 - 1;
   }
   else {
      return log2;
   }
}



d154 9
d284 1
a284 1
   if (ctx->Extensions.MESA_texture_signed_rgba) {
d286 12
d300 1
d302 16
a349 1
      case GL_COMPRESSED_SLUMINANCE_EXT:
d354 1
d509 41
d673 4
a676 2
   /* NUM_TEXTURE_TARGETS should match number of terms below */
   assert(NUM_TEXTURE_TARGETS == 7);
d746 3
d781 1
a781 2
         return ctx->Extensions.MESA_texture_array
                ? texUnit->CurrentTex[TEXTURE_1D_ARRAY_INDEX] : NULL;
d783 1
a783 2
         return ctx->Extensions.MESA_texture_array
                ? ctx->Texture.ProxyTex[TEXTURE_1D_ARRAY_INDEX] : NULL;
d785 1
a785 2
         return ctx->Extensions.MESA_texture_array
                ? texUnit->CurrentTex[TEXTURE_2D_ARRAY_INDEX] : NULL;
d787 4
a790 2
         return ctx->Extensions.MESA_texture_array
                ? ctx->Texture.ProxyTex[TEXTURE_2D_ARRAY_INDEX] : NULL;
d975 2
a976 1
      return ctx->Extensions.MESA_texture_array
d978 2
d989 2
a990 2
static GLint
get_texture_dimensions(GLenum target)
d1016 2
d1160 1
a1160 1
   img->WidthLog2 = logbase2(img->Width2);
d1168 1
a1168 1
      img->HeightLog2 = logbase2(img->Height2);
d1177 1
a1177 1
      img->DepthLog2 = logbase2(img->Depth2);
d1217 1
a1217 1
   dims = get_texture_dimensions(target);
d1432 2
a1433 1
      return ctx->Extensions.MESA_texture_array;
d1474 2
a1475 1
         return ctx->Extensions.MESA_texture_array;
d1486 2
a1487 1
         return ctx->Extensions.MESA_texture_array;
d1524 2
a1525 1
         return ctx->Extensions.MESA_texture_array;
d1534 2
a1535 1
         return ctx->Extensions.MESA_texture_array;
d1707 1
a1707 1
      /* Only 1D, 2D and rectangular textures supported, not 3D or cubes */
d1712 4
d1952 3
a1954 1
      _mesa_test_framebuffer_completeness(ctx, ctx->ReadBuffer);
d2056 3
a2058 1
      _mesa_test_framebuffer_completeness(ctx, ctx->ReadBuffer);
d2256 1
a2256 1
            ASSERT(att->Texture->Image[att->CubeMapFace][att->TextureLevel]);
d2466 1
a2466 1
      if (ctx->NewState & _MESA_NEW_TRANSFER_STATE)
d2612 1
a2612 1
   if (ctx->NewState & _MESA_NEW_TRANSFER_STATE)
d2669 1
a2669 1
   if (ctx->NewState & _MESA_NEW_TRANSFER_STATE)
d2819 5
a2823 1
         gl_format texFormat;
d2825 2
a2826 5
         if (texImage->Data) {
            ctx->Driver.FreeTexImageData( ctx, texImage );
         }

         ASSERT(texImage->Data == NULL);
d2828 2
a2829 3
         texFormat = _mesa_choose_texture_format(ctx, texObj, target, level,
                                                 internalFormat, GL_NONE,
                                                 GL_NONE);
a2830 1
         if (legal_texture_size(ctx, texFormat, width, height, 1)) {
d2834 22
a2855 7
            ASSERT(ctx->Driver.CopyTexImage2D);
            if (dims == 1)
               ctx->Driver.CopyTexImage1D(ctx, target, level, internalFormat,
                                          x, y, width, border);
            else
               ctx->Driver.CopyTexImage2D(ctx, target, level, internalFormat,
                                          x, y, width, height, border);
d2866 1
d3044 1
d3052 1
a3052 1
                               GLsizei imageSize)
d3057 3
d3061 1
a3061 3
   /* check level */
   if (level < 0 || level >= maxLevels)
      return GL_INVALID_VALUE;
d3064 1
d3069 2
a3070 1
   if (!_mesa_is_compressed_format(ctx, internalFormat))
d3072 63
d3137 2
a3138 1
   if (_mesa_base_tex_format(ctx, internalFormat) < 0)
d3140 1
d3143 2
a3144 1
   if (border != 0)
d3146 1
d3150 2
a3151 1
       target <= GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB && width != height)
d3153 1
d3158 2
a3159 2
         ctx->Driver.ChooseTextureFormat(ctx, internalFormat,
                                         GL_NONE, GL_NONE);
d3170 1
d3177 3
a3179 2
                                      internalFormat, GL_NONE, GL_NONE,
                                      width, height, depth, border)) {
d3181 1
a3185 1
   expectedSize = compressed_tex_size(width, height, depth, internalFormat);
d3191 1
d3346 1
d3367 1
a3367 1
                                          border, imageSize);
a3368 2
#if FEATURE_ES
   /* XXX this is kind of a hack */
d3370 1
a3370 1
      _mesa_error(ctx, error, "glTexImage2D");
d3374 2
d3647 269
@


1.5
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@a35 1
#include "convolve.h"
d48 1
d130 1
a130 1
_mesa_base_tex_format( GLcontext *ctx, GLint internalFormat )
d350 51
a400 1
            ; /* fallthrough */
d404 55
a458 1
#endif /* FEATURE_EXT_texture_sRGB */
d460 8
a467 2
   return -1; /* error */
}
d469 8
d478 10
a487 16
/**
 * Test if it is a supported compressed format.
 * 
 * \param internalFormat the internal format token provided by the user.
 * 
 * \ret GL_TRUE if \p internalFormat is a supported compressed format, or
 * GL_FALSE otherwise.
 *
 * Currently only GL_COMPRESSED_RGB_FXT1_3DFX and GL_COMPRESSED_RGBA_FXT1_3DFX
 * are supported.
 */
static GLboolean
is_compressed_format(GLcontext *ctx, GLenum internalFormat)
{
   GLint supported[100]; /* 100 should be plenty */
   GLuint i, n;
d489 10
a498 5
   n = _mesa_get_compressed_formats(ctx, supported, GL_TRUE);
   ASSERT(n < 100);
   for (i = 0; i < n; i++) {
      if ((GLint) internalFormat == supported[i]) {
         return GL_TRUE;
d501 2
a502 1
   return GL_FALSE;
d561 1
a561 1
_mesa_new_texture_image( GLcontext *ctx )
d577 1
a577 1
_mesa_free_texture_image_data(GLcontext *ctx,
d599 2
a600 1
_mesa_delete_texture_image( GLcontext *ctx, struct gl_texture_image *texImage )
d639 43
a681 1
 * Get the texture object that corresponds to the target of the given texture unit.
d692 2
a693 1
_mesa_select_tex_object(GLcontext *ctx, const struct gl_texture_unit *texUnit,
d750 1
a750 1
_mesa_get_current_tex_object(GLcontext *ctx, GLenum target)
d770 2
a771 1
_mesa_select_tex_image(GLcontext *ctx, const struct gl_texture_object *texObj,
d790 1
a790 1
_mesa_get_tex_image(GLcontext *ctx, struct gl_texture_object *texObj,
d820 1
a820 1
_mesa_get_proxy_tex_image(GLcontext *ctx, GLenum target, GLint level)
d895 1
a895 1
_mesa_max_texture_levels(GLcontext *ctx, GLenum target)
d931 39
d1075 1
d1081 1
a1081 1
_mesa_init_teximage_fields(GLcontext *ctx, GLenum target,
d1084 2
a1085 1
                           GLint border, GLenum internalFormat)
d1087 1
a1087 1
   GLint i;
d1158 5
a1162 2
   img->FetchTexelc = NULL;
   img->FetchTexelf = NULL;
d1176 2
a1177 1
_mesa_clear_texture_image(GLcontext *ctx, struct gl_texture_image *texImage)
d1209 1
a1209 1
_mesa_test_proxy_teximage(GLcontext *ctx, GLenum target, GLint level,
d1222 3
a1224 5
      if (width < 2 * border || width > 2 + maxSize ||
          (!ctx->Extensions.ARB_texture_non_power_of_two &&
           width >0 && !_mesa_is_pow_two(width - 2 * border)) ||
          level >= ctx->Const.MaxTextureLevels) {
         /* bad width or level */
d1226 3
d1231 1
d1234 5
a1238 8
      if (width < 2 * border || width > 2 + maxSize ||
          (!ctx->Extensions.ARB_texture_non_power_of_two &&
           width > 0 && !_mesa_is_pow_two(width - 2 * border)) ||
          height < 2 * border || height > 2 + maxSize ||
          (!ctx->Extensions.ARB_texture_non_power_of_two &&
           height > 0 && !_mesa_is_pow_two(height - 2 * border)) ||
          level >= ctx->Const.MaxTextureLevels) {
         /* bad width or height or level */
d1240 5
d1247 1
d1250 7
a1256 11
      if (width < 2 * border || width > 2 + maxSize ||
          (!ctx->Extensions.ARB_texture_non_power_of_two &&
           width > 0 && !_mesa_is_pow_two(width - 2 * border)) ||
          height < 2 * border || height > 2 + maxSize ||
          (!ctx->Extensions.ARB_texture_non_power_of_two &&
           height > 0 && !_mesa_is_pow_two(height - 2 * border)) ||
          depth < 2 * border || depth > 2 + maxSize ||
          (!ctx->Extensions.ARB_texture_non_power_of_two &&
           depth > 0 && !_mesa_is_pow_two(depth - 2 * border)) ||
          level >= ctx->Const.Max3DTextureLevels) {
         /* bad width or height or depth or level */
d1258 7
d1267 1
d1269 6
a1274 4
      if (width < 0 || width > ctx->Const.MaxTextureRectSize ||
          height < 0 || height > ctx->Const.MaxTextureRectSize ||
          level != 0) {
         /* bad width or height or level */
a1275 1
      }
d1277 1
d1280 5
a1284 8
      if (width < 2 * border || width > 2 + maxSize ||
          (!ctx->Extensions.ARB_texture_non_power_of_two &&
           width > 0 && !_mesa_is_pow_two(width - 2 * border)) ||
          height < 2 * border || height > 2 + maxSize ||
          (!ctx->Extensions.ARB_texture_non_power_of_two &&
           height > 0 && !_mesa_is_pow_two(height - 2 * border)) ||
          level >= ctx->Const.MaxCubeTextureLevels) {
         /* bad width or height */
d1286 5
d1293 1
d1296 5
a1300 5
      if (width < 2 * border || width > 2 + maxSize ||
          (!ctx->Extensions.ARB_texture_non_power_of_two &&
           width > 0 && !_mesa_is_pow_two(width - 2 * border)) ||
          level >= ctx->Const.MaxTextureLevels) {
         /* bad width or level */
d1302 3
d1306 1
d1308 9
a1316 1
      if (height < 1 || height > ctx->Const.MaxArrayTextureLayers) {
d1318 5
d1325 48
d1374 44
a1417 9
      maxSize = 1 << (ctx->Const.MaxTextureLevels - 1);
      if (width < 2 * border || width > 2 + maxSize ||
          (!ctx->Extensions.ARB_texture_non_power_of_two &&
           width > 0 && !_mesa_is_pow_two(width - 2 * border)) ||
          height < 2 * border || height > 2 + maxSize ||
          (!ctx->Extensions.ARB_texture_non_power_of_two &&
           height > 0 && !_mesa_is_pow_two(height - 2 * border)) ||
          level >= ctx->Const.MaxTextureLevels) {
         /* bad width or height or level */
d1420 9
a1428 1
      if (depth < 1 || depth > ctx->Const.MaxArrayTextureLayers) {
a1430 1
      return GL_TRUE;
d1432 1
a1432 1
      _mesa_problem(ctx, "Invalid target in _mesa_test_proxy_teximage");
d1439 4
a1442 1
 * Helper function to determine whether a target supports compressed textures
d1445 1
a1445 1
target_can_be_compressed(GLcontext *ctx, GLenum target)
d1447 35
a1481 8
   return (((target == GL_TEXTURE_2D || target == GL_PROXY_TEXTURE_2D))
           || ((ctx->Extensions.ARB_texture_cube_map &&
                (target == GL_PROXY_TEXTURE_CUBE_MAP ||
                 (target >= GL_TEXTURE_CUBE_MAP_POSITIVE_X &&
                  target <= GL_TEXTURE_CUBE_MAP_NEGATIVE_Z))))
           || ((ctx->Extensions.MESA_texture_array &&
                ((target == GL_PROXY_TEXTURE_2D_ARRAY_EXT) ||
                 (target == GL_TEXTURE_2D_ARRAY_EXT)))));
d1489 1
a1494 1
 * \param dimensions texture image dimensions (must be 1, 2 or 3).
d1503 2
a1504 2
 * __GLcontextRec::Const and the supported extensions, and according to the
 * OpenGL specification.
d1507 2
a1508 1
texture_error_check( GLcontext *ctx, GLenum target,
a1510 1
                     GLuint dimensions,
d1514 2
a1515 1
   const GLboolean isProxy = _mesa_is_proxy_texture(target);
a1517 1
   GLenum proxy_target;
d1547 3
a1549 62
   /* Check target and call ctx->Driver.TestProxyTexImage() to check the
    * level, width, height and depth.
    */
   if (dimensions == 1) {
      if (target == GL_PROXY_TEXTURE_1D || target == GL_TEXTURE_1D) {
         proxy_target = GL_PROXY_TEXTURE_1D;
         height = 1;
         depth = 1;
      }
      else {
         _mesa_error( ctx, GL_INVALID_ENUM, "glTexImage1D(target)" );
         return GL_TRUE;
      }
   }
   else if (dimensions == 2) {
      depth = 1;
      if (target == GL_PROXY_TEXTURE_2D || target == GL_TEXTURE_2D) {
         proxy_target = GL_PROXY_TEXTURE_2D;
      }
      else if (target == GL_PROXY_TEXTURE_CUBE_MAP_ARB ||
               (target >= GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB &&
                target <= GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB)) {
         if (!ctx->Extensions.ARB_texture_cube_map) {
            _mesa_error(ctx, GL_INVALID_ENUM, "glTexImage2D(target)");
            return GL_TRUE;
         }
         proxy_target = GL_PROXY_TEXTURE_CUBE_MAP_ARB;
         sizeOK = (width == height);
      }
      else if (target == GL_PROXY_TEXTURE_RECTANGLE_NV ||
               target == GL_TEXTURE_RECTANGLE_NV) {
         if (!ctx->Extensions.NV_texture_rectangle) {
            _mesa_error(ctx, GL_INVALID_ENUM, "glTexImage2D(target)");
            return GL_TRUE;
         }
         proxy_target = GL_PROXY_TEXTURE_RECTANGLE_NV;
      }
      else if (target == GL_PROXY_TEXTURE_1D_ARRAY_EXT ||
               target == GL_TEXTURE_1D_ARRAY_EXT) {
         proxy_target = GL_PROXY_TEXTURE_1D_ARRAY_EXT;
      }
      else {
         _mesa_error(ctx, GL_INVALID_ENUM, "glTexImage2D(target)");
         return GL_TRUE;
      }
   }
   else if (dimensions == 3) {
      if (target == GL_PROXY_TEXTURE_3D || target == GL_TEXTURE_3D) {
         proxy_target = GL_PROXY_TEXTURE_3D;
      }
      else if (target == GL_PROXY_TEXTURE_2D_ARRAY_EXT ||
               target == GL_TEXTURE_2D_ARRAY_EXT) {
         proxy_target = GL_PROXY_TEXTURE_2D_ARRAY_EXT;
      }
      else {
         _mesa_error( ctx, GL_INVALID_ENUM, "glTexImage3D(target)" );
         return GL_TRUE;
      }
   }
   else {
      _mesa_problem( ctx, "bad dims in texture_error_check" );
      return GL_TRUE;
d1552 5
a1556 1
   sizeOK = sizeOK && ctx->Driver.TestProxyTexImage(ctx, proxy_target, level,
d1581 4
a1584 2
      /* Yes, generate GL_INVALID_OPERATION, not GL_INVALID_ENUM, if there
       * is a type/format mismatch.  See 1.2 spec page 94, sec 3.6.4.
d1587 3
a1589 1
         _mesa_error(ctx, GL_INVALID_OPERATION,
d1618 3
a1620 3
         sprintf(message,
                 "glTexImage%d(format/type YCBCR mismatch", dimensions);
         _mesa_error(ctx, GL_INVALID_ENUM, message);
d1634 4
a1637 4
            sprintf(message,
                    "glTexImage%d(format=GL_YCBCR_MESA and border=%d)",
                    dimensions, border);
            _mesa_error(ctx, GL_INVALID_VALUE, message);
d1660 5
a1664 4
   if (is_compressed_format(ctx, internalFormat)) {
      if (!target_can_be_compressed(ctx, target) && !isProxy) {
         _mesa_error(ctx, GL_INVALID_ENUM,
                     "glTexImage%d(target)", dimensions);
d1670 1
a1670 1
                        "glTexImage%D(border!=0)", dimensions);
d1676 12
d1712 2
a1713 2
 * __GLcontextRec::Const and the supported extensions, and according to the
 * OpenGL specification.
d1716 1
a1716 1
subtexture_error_check( GLcontext *ctx, GLuint dimensions,
d1722 5
a1726 54
   /* Check target */
   if (dimensions == 1) {
      if (target != GL_TEXTURE_1D) {
         _mesa_error( ctx, GL_INVALID_ENUM, "glTexSubImage1D(target)" );
         return GL_TRUE;
      }
   }
   else if (dimensions == 2) {
      if (target >= GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB &&
          target <= GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB) {
         if (!ctx->Extensions.ARB_texture_cube_map) {
            _mesa_error( ctx, GL_INVALID_ENUM, "glTexSubImage2D(target)" );
            return GL_TRUE;
         }
      }
      else if (target == GL_TEXTURE_RECTANGLE_NV) {
         if (!ctx->Extensions.NV_texture_rectangle) {
            _mesa_error( ctx, GL_INVALID_ENUM, "glTexSubImage2D(target)" );
            return GL_TRUE;
         }
      }
      else if (target == GL_TEXTURE_1D_ARRAY_EXT) {
        if (!ctx->Extensions.MESA_texture_array) {
           _mesa_error( ctx, GL_INVALID_ENUM, "glTexSubImage2D(target)" );
           return GL_TRUE;
        }
      }
      else if (target != GL_TEXTURE_2D) {
         _mesa_error( ctx, GL_INVALID_ENUM, "glTexSubImage2D(target)" );
         return GL_TRUE;
      }
   }
   else if (dimensions == 3) {
      if (target == GL_TEXTURE_2D_ARRAY_EXT) {
         if (!ctx->Extensions.MESA_texture_array) {
            _mesa_error( ctx, GL_INVALID_ENUM, "glTexSubImage3D(target)" );
            return GL_TRUE;
         }
      }
      else if (target != GL_TEXTURE_3D) {
         _mesa_error( ctx, GL_INVALID_ENUM, "glTexSubImage3D(target)" );
         return GL_TRUE;
      }
   }
   else {
      _mesa_problem( ctx, "invalid dims in texture_error_check" );
      return GL_TRUE;
   }

   /* Basic level check */
   if (level < 0 || level >= MAX_TEXTURE_LEVELS) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glTexSubImage2D(level=%d)", level);
      return GL_TRUE;
   }
d1728 1
d1746 6
a1751 1
      _mesa_error(ctx, GL_INVALID_ENUM,
d1766 1
a1766 1
subtexture_error_check2( GLcontext *ctx, GLuint dimensions,
a1814 7
      if (!target_can_be_compressed(ctx, target)) {
         _mesa_error(ctx, GL_INVALID_ENUM,
                     "glTexSubImage%D(target=%s)", dimensions,
                     _mesa_lookup_enum_by_nr(target));
         return GL_TRUE;
      }

d1821 1
a1821 1
                     "glTexSubImage%D(xoffset = %d, yoffset = %d)",
d1828 1
a1828 1
                     "glTexSubImage%D(width = %d)", dimensions, width);
d1833 1
a1833 1
                     "glTexSubImage%D(height = %d)", dimensions, height);
d1857 2
a1858 2
 * __GLcontextRec::Const and the supported extensions, and according to the
 * OpenGL specification.
d1861 1
a1861 1
copytexture_error_check( GLcontext *ctx, GLuint dimensions,
d1865 2
a1866 1
   GLenum type;
d1870 7
d1914 3
a1916 4
   /* NOTE: the format and type aren't really significant for
    * TestProxyTexImage().  Only the internalformat really matters.
    */
   type = GL_FLOAT;
d1918 4
a1921 64
   /* Check target and call ctx->Driver.TestProxyTexImage() to check the
    * level, width, height and depth.
    */
   if (dimensions == 1) {
      if (target == GL_TEXTURE_1D) {
         sizeOK = ctx->Driver.TestProxyTexImage(ctx, GL_PROXY_TEXTURE_1D,
                                                level, internalFormat,
                                                format, type,
                                                width, 1, 1, border);
      }
      else {
         _mesa_error( ctx, GL_INVALID_ENUM, "glCopyTexImage1D(target)" );
         return GL_TRUE;
      }
   }
   else if (dimensions == 2) {
      if (target == GL_TEXTURE_2D) {
         sizeOK = ctx->Driver.TestProxyTexImage(ctx, GL_PROXY_TEXTURE_2D,
                                                level, internalFormat,
                                                format, type,
                                                width, height, 1, border);
      }
      else if (target >= GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB &&
               target <= GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB) {
         if (!ctx->Extensions.ARB_texture_cube_map) {
            _mesa_error( ctx, GL_INVALID_ENUM, "glCopyTexImage2D(target)" );
            return GL_TRUE;
         }
         sizeOK = (width == height) &&
            ctx->Driver.TestProxyTexImage(ctx, GL_PROXY_TEXTURE_CUBE_MAP_ARB,
                                          level, internalFormat, format, type,
                                          width, height, 1, border);
      }
      else if (target == GL_TEXTURE_RECTANGLE_NV) {
         if (!ctx->Extensions.NV_texture_rectangle) {
            _mesa_error( ctx, GL_INVALID_ENUM, "glCopyTexImage2D(target)" );
            return GL_TRUE;
         }
         sizeOK = ctx->Driver.TestProxyTexImage(ctx,
                                                GL_PROXY_TEXTURE_RECTANGLE_NV,
                                                level, internalFormat,
                                                format, type,
                                                width, height, 1, border);
      }
      else if (target == GL_TEXTURE_1D_ARRAY_EXT) {
         if (!ctx->Extensions.MESA_texture_array) {
            _mesa_error(ctx, GL_INVALID_ENUM, "glCopyTexImage2D(target)");
            return GL_TRUE;
         }
         sizeOK = ctx->Driver.TestProxyTexImage(ctx,
                                                GL_PROXY_TEXTURE_1D_ARRAY_EXT,
                                                level, internalFormat,
                                                format, type,
                                                width, height, 1, border);
      }
      else {
         _mesa_error( ctx, GL_INVALID_ENUM, "glCopyTexImage2D(target)" );
         return GL_TRUE;
      }
   }
   else {
      _mesa_problem(ctx, "invalid dimensions in copytexture_error_check");
      return GL_TRUE;
   }
d1936 2
a1937 2
   if (is_compressed_format(ctx, internalFormat)) {
      if (!target_can_be_compressed(ctx, target)) {
d1939 1
a1939 1
                     "glCopyTexImage%d(target)", dimensions);
d1944 1
a1944 1
                     "glCopyTexImage%D(border!=0)", dimensions);
d1952 1
a1952 1
                     "glCopyTexImage%D(no depth)", dimensions);
d1960 1
a1960 1
                     "glCopyTexImage%D(no depth/stencil buffer)", dimensions);
d1983 1
a1983 1
copytexsubimage_error_check1( GLcontext *ctx, GLuint dimensions,
d1996 5
a2000 39
   /* Check target */
   if (dimensions == 1) {
      if (target != GL_TEXTURE_1D) {
         _mesa_error( ctx, GL_INVALID_ENUM, "glCopyTexSubImage1D(target)" );
         return GL_TRUE;
      }
   }
   else if (dimensions == 2) {
      if (target >= GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB &&
          target <= GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB) {
         if (!ctx->Extensions.ARB_texture_cube_map) {
            _mesa_error( ctx, GL_INVALID_ENUM, "glCopyTexSubImage2D(target)" );
            return GL_TRUE;
         }
      }
      else if (target == GL_TEXTURE_RECTANGLE_NV) {
         if (!ctx->Extensions.NV_texture_rectangle) {
            _mesa_error( ctx, GL_INVALID_ENUM, "glCopyTexSubImage2D(target)" );
            return GL_TRUE;
         }
      }
      else if (target == GL_TEXTURE_1D_ARRAY_EXT) {
         if (!ctx->Extensions.MESA_texture_array) {
            _mesa_error( ctx, GL_INVALID_ENUM, "glCopyTexSubImage2D(target)" );
            return GL_TRUE;
         }
      }
      else if (target != GL_TEXTURE_2D) {
         _mesa_error( ctx, GL_INVALID_ENUM, "glCopyTexSubImage2D(target)" );
         return GL_TRUE;
      }
   }
   else if (dimensions == 3) {
      if (((target != GL_TEXTURE_2D_ARRAY_EXT) ||
	   (!ctx->Extensions.MESA_texture_array))
	  && (target != GL_TEXTURE_3D)) {
	 _mesa_error( ctx, GL_INVALID_ENUM, "glCopyTexSubImage3D(target)" );
	 return GL_TRUE;
      }
d2023 1
a2023 1
copytexsubimage_error_check2( GLcontext *ctx, GLuint dimensions,
a2088 5
      if (!target_can_be_compressed(ctx, target)) {
         _mesa_error(ctx, GL_INVALID_ENUM,
                     "glCopyTexSubImage%d(target)", dimensions);
         return GL_TRUE;
      }
d2092 1
a2092 1
                     "glCopyTexSubImage%D(xoffset or yoffset)", dimensions);
d2098 1
a2098 1
                     "glCopyTexSubImage%D(width)", dimensions);
d2103 1
a2103 1
                     "glCopyTexSubImage%D(height)", dimensions);
d2123 1
a2123 1
                     "glCopyTexSubImage%D(no depth buffer)",
d2131 1
a2131 1
                     "glCopyTexSubImage%D(no depth/stencil buffer)",
d2137 13
d2158 1
a2158 1
   GLcontext *ctx;
d2172 1
a2172 1
   GLcontext *ctx = info->ctx;
d2204 1
a2204 1
update_fbo_texture(GLcontext *ctx, struct gl_texture_object *texObj,
d2225 1
a2225 1
check_gen_mipmap(GLcontext *ctx, GLenum target,
d2282 41
a2322 2
/*
 * Called from the API.  Note that width includes the border.
d2324 6
a2329 4
void GLAPIENTRY
_mesa_TexImage1D( GLenum target, GLint level, GLint internalFormat,
                  GLsizei width, GLint border, GLenum format,
                  GLenum type, const GLvoid *pixels )
d2331 2
a2332 2
   GLsizei postConvWidth = width;
   GET_CURRENT_CONTEXT(ctx);
d2336 2
a2337 1
      _mesa_debug(ctx, "glTexImage1D %s %d %s %d %d %s %s %p\n",
d2339 2
a2340 1
                  _mesa_lookup_enum_by_nr(internalFormat), width, border,
d2344 1
a2344 1
   internalFormat = override_internal_format(internalFormat, width, 1);
d2346 5
a2350 3
#if FEATURE_convolve
   if (_mesa_is_color_format(internalFormat)) {
      _mesa_adjust_image_for_convolution(ctx, 1, &postConvWidth, NULL);
a2351 1
#endif
d2353 34
a2386 1
   if (target == GL_TEXTURE_1D) {
d2388 1
a2390 1
      const GLuint face = _mesa_tex_target_to_face(target);
d2392 1
a2392 2
      if (texture_error_check(ctx, target, level, internalFormat,
                              format, type, 1, postConvWidth, 1, 1, border)) {
d2400 1
d2404 1
d2406 1
a2406 1
	    _mesa_error(ctx, GL_OUT_OF_MEMORY, "glTexImage1D");
d2409 2
d2416 3
d2420 29
a2448 16
            clear_teximage_fields(texImage); /* not really needed, but helpful */
            _mesa_init_teximage_fields(ctx, target, texImage,
                                       postConvWidth, 1, 1,
                                       border, internalFormat);

            /* Choose actual texture format */
            texImage->TexFormat =
               ctx->Driver.ChooseTextureFormat(ctx, internalFormat,
                                               format, type);
            ASSERT(texImage->TexFormat != MESA_FORMAT_NONE);

            /* Give the texture to the driver.  <pixels> may be null. */
            ASSERT(ctx->Driver.TexImage1D);
            ctx->Driver.TexImage1D(ctx, target, level, internalFormat,
                                   width, border, format, type, pixels,
                                   &ctx->Unpack, texObj, texImage);
d2450 1
a2450 1
            ASSERT(texImage->TexFormat);
d2452 1
a2452 1
            _mesa_set_fetch_functions(texImage, 1);
d2454 7
a2460 7
            check_gen_mipmap(ctx, target, texObj, level);

            update_fbo_texture(ctx, texObj, face, level);

            /* state update */
            texObj->_Complete = GL_FALSE;
            ctx->NewState |= _NEW_TEXTURE;
d2465 14
a2478 24
   else if (target == GL_PROXY_TEXTURE_1D) {
      /* Proxy texture: check for errors and update proxy state */
      struct gl_texture_image *texImage;
      texImage = _mesa_get_proxy_tex_image(ctx, target, level);
      if (texture_error_check(ctx, target, level, internalFormat,
                              format, type, 1, postConvWidth, 1, 1, border)) {
         /* when error, clear all proxy texture image parameters */
         if (texImage)
            clear_teximage_fields(texImage);
      }
      else {
         /* no error, set the tex image parameters */
         ASSERT(texImage);
         _mesa_init_teximage_fields(ctx, target, texImage,
                                    postConvWidth, 1, 1,
                                    border, internalFormat);
         texImage->TexFormat =
            ctx->Driver.ChooseTextureFormat(ctx, internalFormat, format, type);
      }
   }
   else {
      _mesa_error( ctx, GL_INVALID_ENUM, "glTexImage1D(target)" );
      return;
   }
a2487 1
   GLsizei postConvWidth = width, postConvHeight = height;
d2489 2
a2490 115
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

   if (MESA_VERBOSE & (VERBOSE_API|VERBOSE_TEXTURE))
      _mesa_debug(ctx, "glTexImage2D %s %d %s %d %d %d %s %s %p\n",
                  _mesa_lookup_enum_by_nr(target), level,
                  _mesa_lookup_enum_by_nr(internalFormat), width, height,
                  border, _mesa_lookup_enum_by_nr(format),
                  _mesa_lookup_enum_by_nr(type), pixels);

   internalFormat = override_internal_format(internalFormat, width, height);

#if FEATURE_convolve
   if (_mesa_is_color_format(internalFormat)) {
      _mesa_adjust_image_for_convolution(ctx, 2, &postConvWidth,
					 &postConvHeight);
   }
#endif

   if (target == GL_TEXTURE_2D ||
       (ctx->Extensions.ARB_texture_cube_map &&
        target >= GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB &&
        target <= GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB) ||
       (ctx->Extensions.NV_texture_rectangle &&
        target == GL_TEXTURE_RECTANGLE_NV) ||
       (ctx->Extensions.MESA_texture_array &&
        target == GL_TEXTURE_1D_ARRAY_EXT)) {
      /* non-proxy target */
      struct gl_texture_object *texObj;
      struct gl_texture_image *texImage;
      const GLuint face = _mesa_tex_target_to_face(target);

      if (texture_error_check(ctx, target, level, internalFormat,
                              format, type, 2, postConvWidth, postConvHeight,
                              1, border)) {
         return;   /* error was recorded */
      }

      if (ctx->NewState & _MESA_NEW_TRANSFER_STATE)
	 _mesa_update_state(ctx);

      texObj = _mesa_get_current_tex_object(ctx, target);
      _mesa_lock_texture(ctx, texObj);
      {
	 texImage = _mesa_get_tex_image(ctx, texObj, target, level);
	 if (!texImage) {
	    _mesa_error(ctx, GL_OUT_OF_MEMORY, "glTexImage2D");
	 }
         else {
            if (texImage->Data) {
               ctx->Driver.FreeTexImageData( ctx, texImage );
            }

            ASSERT(texImage->Data == NULL);
            clear_teximage_fields(texImage); /* not really needed, but helpful */
            _mesa_init_teximage_fields(ctx, target, texImage,
                                       postConvWidth, postConvHeight, 1,
                                       border, internalFormat);

            /* Choose actual texture format */
            texImage->TexFormat =
               ctx->Driver.ChooseTextureFormat(ctx, internalFormat,
                                               format, type);
            ASSERT(texImage->TexFormat != MESA_FORMAT_NONE);

            /* Give the texture to the driver.  <pixels> may be null. */
            ASSERT(ctx->Driver.TexImage2D);
            ctx->Driver.TexImage2D(ctx, target, level, internalFormat,
                                   width, height, border, format, type,
                                   pixels, &ctx->Unpack, texObj, texImage);

            ASSERT(texImage->TexFormat);

            _mesa_set_fetch_functions(texImage, 2);

            check_gen_mipmap(ctx, target, texObj, level);

            update_fbo_texture(ctx, texObj, face, level);

            /* state update */
            texObj->_Complete = GL_FALSE;
            ctx->NewState |= _NEW_TEXTURE;
         }
      }
      _mesa_unlock_texture(ctx, texObj);
   }
   else if (target == GL_PROXY_TEXTURE_2D ||
            (target == GL_PROXY_TEXTURE_CUBE_MAP_ARB &&
             ctx->Extensions.ARB_texture_cube_map) ||
            (target == GL_PROXY_TEXTURE_RECTANGLE_NV &&
             ctx->Extensions.NV_texture_rectangle) ||
            (ctx->Extensions.MESA_texture_array &&
             target == GL_PROXY_TEXTURE_1D_ARRAY_EXT)) {
      /* Proxy texture: check for errors and update proxy state */
      struct gl_texture_image *texImage;
      texImage = _mesa_get_proxy_tex_image(ctx, target, level);
      if (texture_error_check(ctx, target, level, internalFormat,
                              format, type, 2, postConvWidth, postConvHeight,
                              1, border)) {
         /* when error, clear all proxy texture image parameters */
         if (texImage)
            clear_teximage_fields(texImage);
      }
      else {
         /* no error, set the tex image parameters */
         _mesa_init_teximage_fields(ctx, target, texImage,
                                    postConvWidth, postConvHeight, 1,
                                    border, internalFormat);
         texImage->TexFormat =
            ctx->Driver.ChooseTextureFormat(ctx, internalFormat, format, type);
      }
   }
   else {
      _mesa_error( ctx, GL_INVALID_ENUM, "glTexImage2D(target)" );
      return;
   }
d2505 3
a2507 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
a2508 6
   if (MESA_VERBOSE & (VERBOSE_API|VERBOSE_TEXTURE))
      _mesa_debug(ctx, "glTexImage3D %s %d %s %d %d %d %d %s %s %p\n",
                  _mesa_lookup_enum_by_nr(target), level,
                  _mesa_lookup_enum_by_nr(internalFormat), width, height,
                  depth, border, _mesa_lookup_enum_by_nr(format),
                  _mesa_lookup_enum_by_nr(type), pixels);
d2510 9
a2518 1
   internalFormat = override_internal_format(internalFormat, width, height);
a2519 7
   if (target == GL_TEXTURE_3D ||
       (ctx->Extensions.MESA_texture_array &&
        target == GL_TEXTURE_2D_ARRAY_EXT)) {
      /* non-proxy target */
      struct gl_texture_object *texObj;
      struct gl_texture_image *texImage;
      const GLuint face = _mesa_tex_target_to_face(target);
d2521 8
a2528 4
      if (texture_error_check(ctx, target, level, (GLint) internalFormat,
                              format, type, 3, width, height, depth, border)) {
         return;   /* error was recorded */
      }
d2530 3
a2532 70
      if (ctx->NewState & _MESA_NEW_TRANSFER_STATE)
	 _mesa_update_state(ctx);

      texObj = _mesa_get_current_tex_object(ctx, target);
      _mesa_lock_texture(ctx, texObj);
      {
	 texImage = _mesa_get_tex_image(ctx, texObj, target, level);
	 if (!texImage) {
	    _mesa_error(ctx, GL_OUT_OF_MEMORY, "glTexImage3D");
	 }
         else {
            if (texImage->Data) {
               ctx->Driver.FreeTexImageData( ctx, texImage );
            }

            ASSERT(texImage->Data == NULL);
            clear_teximage_fields(texImage); /* not really needed, but helpful */
            _mesa_init_teximage_fields(ctx, target, texImage,
                                       width, height, depth,
                                       border, internalFormat);

            /* Choose actual texture format */
            texImage->TexFormat =
               ctx->Driver.ChooseTextureFormat(ctx, internalFormat,
                                               format, type);
            ASSERT(texImage->TexFormat != MESA_FORMAT_NONE);

            /* Give the texture to the driver.  <pixels> may be null. */
            ASSERT(ctx->Driver.TexImage3D);
            ctx->Driver.TexImage3D(ctx, target, level, internalFormat,
                                   width, height, depth, border, format, type,
                                   pixels, &ctx->Unpack, texObj, texImage);

            ASSERT(texImage->TexFormat);

            _mesa_set_fetch_functions(texImage, 3);

            check_gen_mipmap(ctx, target, texObj, level);

            update_fbo_texture(ctx, texObj, face, level);

            /* state update */
            texObj->_Complete = GL_FALSE;
            ctx->NewState |= _NEW_TEXTURE;
         }
      }
      _mesa_unlock_texture(ctx, texObj);
   }
   else if (target == GL_PROXY_TEXTURE_3D ||
       (ctx->Extensions.MESA_texture_array &&
        target == GL_PROXY_TEXTURE_2D_ARRAY_EXT)) {
      /* Proxy texture: check for errors and update proxy state */
      struct gl_texture_image *texImage;
      texImage = _mesa_get_proxy_tex_image(ctx, target, level);
      if (texture_error_check(ctx, target, level, internalFormat,
                              format, type, 3, width, height, depth, border)) {
         /* when error, clear all proxy texture image parameters */
         if (texImage)
            clear_teximage_fields(texImage);
      }
      else {
         /* no error, set the tex image parameters */
         _mesa_init_teximage_fields(ctx, target, texImage, width, height,
                                    depth, border, internalFormat);
         texImage->TexFormat =
            ctx->Driver.ChooseTextureFormat(ctx, internalFormat, format, type);
      }
   }
   else {
      _mesa_error( ctx, GL_INVALID_ENUM, "glTexImage3D(target)" );
a2534 22
}


void GLAPIENTRY
_mesa_TexImage3DEXT( GLenum target, GLint level, GLenum internalFormat,
                     GLsizei width, GLsizei height, GLsizei depth,
                     GLint border, GLenum format, GLenum type,
                     const GLvoid *pixels )
{
   _mesa_TexImage3D(target, level, (GLint) internalFormat, width, height,
                    depth, border, format, type, pixels);
}


#if FEATURE_OES_EGL_image
void GLAPIENTRY
_mesa_EGLImageTargetTexture2DOES (GLenum target, GLeglImageOES image)
{
   struct gl_texture_object *texObj;
   struct gl_texture_image *texImage;
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d2569 9
a2577 5
void GLAPIENTRY
_mesa_TexSubImage1D( GLenum target, GLint level,
                     GLint xoffset, GLsizei width,
                     GLenum format, GLenum type,
                     const GLvoid *pixels )
a2578 1
   GLsizei postConvWidth = width;
d2581 1
a2581 1
   GET_CURRENT_CONTEXT(ctx);
d2585 2
a2586 1
      _mesa_debug(ctx, "glTexSubImage1D %s %d %d %d %s %s %p\n",
d2588 2
a2589 1
                  xoffset, width, _mesa_lookup_enum_by_nr(format),
d2592 7
d2602 2
a2603 9
#if FEATURE_convolve
   /* XXX should test internal format */
   if (_mesa_is_color_format(format)) {
      _mesa_adjust_image_for_convolution(ctx, 1, &postConvWidth, NULL);
   }
#endif

   if (subtexture_error_check(ctx, 1, target, level, xoffset, 0, 0,
			       postConvWidth, 1, 1, format, type)) {
a2606 1

a2607 1
   assert(texObj);
d2613 3
a2615 2
      if (subtexture_error_check2(ctx, 1, target, level, xoffset, 0, 0,
				  postConvWidth, 1, 1,
d2619 36
a2654 8
      else if (width > 0) {
         /* If we have a border, xoffset=-1 is legal.  Bias by border width */
         xoffset += texImage->Border;

         ASSERT(ctx->Driver.TexSubImage1D);
         ctx->Driver.TexSubImage1D(ctx, target, level, xoffset, width,
                                   format, type, pixels, &ctx->Unpack,
                                   texObj, texImage);
d2666 14
a2685 3
   GLsizei postConvWidth = width, postConvHeight = height;
   struct gl_texture_object *texObj;
   struct gl_texture_image *texImage;
d2687 4
a2690 52
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

   if (MESA_VERBOSE & (VERBOSE_API|VERBOSE_TEXTURE))
      _mesa_debug(ctx, "glTexSubImage2D %s %d %d %d %d %d %s %s %p\n",
                  _mesa_lookup_enum_by_nr(target), level,
                  xoffset, yoffset, width, height,
                  _mesa_lookup_enum_by_nr(format),
                  _mesa_lookup_enum_by_nr(type), pixels);

   if (ctx->NewState & _MESA_NEW_TRANSFER_STATE)
      _mesa_update_state(ctx);

#if FEATURE_convolve
   /* XXX should test internal format */
   if (_mesa_is_color_format(format)) {
      _mesa_adjust_image_for_convolution(ctx, 2, &postConvWidth,
                                         &postConvHeight);
   }
#endif

   if (subtexture_error_check(ctx, 2, target, level, xoffset, yoffset, 0,
			      postConvWidth, postConvHeight, 1, format, type)) {
      return;   /* error was detected */
   }

   texObj = _mesa_get_current_tex_object(ctx, target);

   _mesa_lock_texture(ctx, texObj);
   {
      texImage = _mesa_select_tex_image(ctx, texObj, target, level);

      if (subtexture_error_check2(ctx, 2, target, level, xoffset, yoffset, 0,
				  postConvWidth, postConvHeight, 1,
                                  format, type, texImage)) {
	 /* error was recorded */
      }
      else if (width > 0 && height >= 0) {
         /* If we have a border, xoffset=-1 is legal.  Bias by border width */
         xoffset += texImage->Border;
         yoffset += texImage->Border;

         ASSERT(ctx->Driver.TexSubImage2D);
         ctx->Driver.TexSubImage2D(ctx, target, level, xoffset, yoffset,
                                   width, height, format, type, pixels,
                                   &ctx->Unpack, texObj, texImage);

         check_gen_mipmap(ctx, target, texObj, level);

         ctx->NewState |= _NEW_TEXTURE;
      }
   }
   _mesa_unlock_texture(ctx, texObj);
a2701 2
   struct gl_texture_object *texObj;
   struct gl_texture_image *texImage;
d2703 4
a2706 48
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

   if (MESA_VERBOSE & (VERBOSE_API|VERBOSE_TEXTURE))
      _mesa_debug(ctx, "glTexSubImage3D %s %d %d %d %d %d %d %d %s %s %p\n",
                  _mesa_lookup_enum_by_nr(target), level,
                  xoffset, yoffset, zoffset, width, height, depth,
                  _mesa_lookup_enum_by_nr(format),
                  _mesa_lookup_enum_by_nr(type), pixels);

   if (ctx->NewState & _MESA_NEW_TRANSFER_STATE)
      _mesa_update_state(ctx);

   if (subtexture_error_check(ctx, 3, target, level, xoffset, yoffset, zoffset,
                              width, height, depth, format, type)) {
      return;   /* error was detected */
   }

   texObj = _mesa_get_current_tex_object(ctx, target);

   _mesa_lock_texture(ctx, texObj);
   {
      texImage = _mesa_select_tex_image(ctx, texObj, target, level);

      if (subtexture_error_check2(ctx, 3, target, level,
                                  xoffset, yoffset, zoffset,
				  width, height, depth,
                                  format, type, texImage)) {
         /* error was recorded */
      }
      else if (width > 0 && height > 0 && height > 0) {
         /* If we have a border, xoffset=-1 is legal.  Bias by border width */
         xoffset += texImage->Border;
         yoffset += texImage->Border;
         zoffset += texImage->Border;

         ASSERT(ctx->Driver.TexSubImage3D);
         ctx->Driver.TexSubImage3D(ctx, target, level,
                                   xoffset, yoffset, zoffset,
                                   width, height, depth,
                                   format, type, pixels,
                                   &ctx->Unpack, texObj, texImage );

         check_gen_mipmap(ctx, target, texObj, level);

         ctx->NewState |= _NEW_TEXTURE;
      }
   }
   _mesa_unlock_texture(ctx, texObj);
d2711 7
a2717 5
void GLAPIENTRY
_mesa_CopyTexImage1D( GLenum target, GLint level,
                      GLenum internalFormat,
                      GLint x, GLint y,
                      GLsizei width, GLint border )
a2720 1
   GLsizei postConvWidth = width;
d2722 1
a2722 1
   GET_CURRENT_CONTEXT(ctx);
d2726 2
a2727 1
      _mesa_debug(ctx, "glCopyTexImage1D %s %d %s %d %d %d %d\n",
d2730 1
a2730 1
                  x, y, width, border);
d2735 2
a2736 8
#if FEATURE_convolve
   if (_mesa_is_color_format(internalFormat)) {
      _mesa_adjust_image_for_convolution(ctx, 1, &postConvWidth, NULL);
   }
#endif

   if (copytexture_error_check(ctx, 1, target, level, internalFormat,
                               postConvWidth, 1, border))
d2744 1
d2746 1
a2746 1
	 _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCopyTexImage1D");
d2749 2
d2757 3
a2759 13
         clear_teximage_fields(texImage); /* not really needed, but helpful */
         _mesa_init_teximage_fields(ctx, target, texImage, postConvWidth, 1, 1,
                                    border, internalFormat);

         /* Choose actual texture format */
         texImage->TexFormat =
            ctx->Driver.ChooseTextureFormat(ctx, internalFormat,
                                            GL_NONE, GL_NONE);
         ASSERT(texImage->TexFormat != MESA_FORMAT_NONE);

         ASSERT(ctx->Driver.CopyTexImage1D);
         ctx->Driver.CopyTexImage1D(ctx, target, level, internalFormat,
                                    x, y, width, border);
d2761 3
a2763 1
         ASSERT(texImage->TexFormat);
d2765 7
a2771 1
         _mesa_set_fetch_functions(texImage, 1);
d2773 1
a2773 1
         check_gen_mipmap(ctx, target, texObj, level);
d2775 1
a2775 1
         update_fbo_texture(ctx, texObj, face, level);
d2777 7
a2783 3
         /* state update */
         texObj->_Complete = GL_FALSE;
         ctx->NewState |= _NEW_TEXTURE;
d2792 12
a2807 4
   struct gl_texture_object *texObj;
   struct gl_texture_image *texImage;
   GLsizei postConvWidth = width, postConvHeight = height;
   const GLuint face = _mesa_tex_target_to_face(target);
d2809 3
a2811 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
a2812 5
   if (MESA_VERBOSE & (VERBOSE_API|VERBOSE_TEXTURE))
      _mesa_debug(ctx, "glCopyTexImage2D %s %d %s %d %d %d %d %d\n",
                  _mesa_lookup_enum_by_nr(target), level,
                  _mesa_lookup_enum_by_nr(internalFormat),
                  x, y, width, height, border);
a2813 2
   if (ctx->NewState & NEW_COPY_TEX_STATE)
      _mesa_update_state(ctx);
d2815 7
a2821 62
#if FEATURE_convolve
   if (_mesa_is_color_format(internalFormat)) {
      _mesa_adjust_image_for_convolution(ctx, 2, &postConvWidth,
                                         &postConvHeight);
   }
#endif

   if (copytexture_error_check(ctx, 2, target, level, internalFormat,
                               postConvWidth, postConvHeight, border))
      return;

   texObj = _mesa_get_current_tex_object(ctx, target);

   _mesa_lock_texture(ctx, texObj);
   {
      texImage = _mesa_get_tex_image(ctx, texObj, target, level);

      if (!texImage) {
	 _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCopyTexImage2D");
      }
      else {
         if (texImage->Data) {
            ctx->Driver.FreeTexImageData( ctx, texImage );
         }

         ASSERT(texImage->Data == NULL);

         clear_teximage_fields(texImage); /* not really needed, but helpful */
         _mesa_init_teximage_fields(ctx, target, texImage,
                                    postConvWidth, postConvHeight, 1,
                                    border, internalFormat);

         /* Choose actual texture format */
         texImage->TexFormat =
            ctx->Driver.ChooseTextureFormat(ctx, internalFormat,
                                            GL_NONE, GL_NONE);
         ASSERT(texImage->TexFormat != MESA_FORMAT_NONE);

         ASSERT(ctx->Driver.CopyTexImage2D);
         ctx->Driver.CopyTexImage2D(ctx, target, level, internalFormat,
                                    x, y, width, height, border);

         ASSERT(texImage->TexFormat);

         _mesa_set_fetch_functions(texImage, 2);

         check_gen_mipmap(ctx, target, texObj, level);

         update_fbo_texture(ctx, texObj, face, level);

         /* state update */
         texObj->_Complete = GL_FALSE;
         ctx->NewState |= _NEW_TEXTURE;
      }
   }
   _mesa_unlock_texture(ctx, texObj);
}


void GLAPIENTRY
_mesa_CopyTexSubImage1D( GLenum target, GLint level,
                         GLint xoffset, GLint x, GLint y, GLsizei width )
a2824 3
   GLsizei postConvWidth = width;
   GLint yoffset = 0;
   GLsizei height = 1;
a2825 1
   GET_CURRENT_CONTEXT(ctx);
d2829 2
a2830 1
      _mesa_debug(ctx, "glCopyTexSubImage1D %s %d %d %d %d %d\n",
d2832 1
a2832 1
                  level, xoffset, x, y, width);
d2837 1
a2837 1
   if (copytexsubimage_error_check1(ctx, 1, target, level))
d2846 3
a2848 10
#if FEATURE_convolve
      if (texImage && _mesa_is_color_format(texImage->InternalFormat)) {
         _mesa_adjust_image_for_convolution(ctx, 1, &postConvWidth, NULL);
      }
#endif

      if (copytexsubimage_error_check2(ctx, 1, target, level,
				       xoffset, 0, 0, postConvWidth, 1,
				       texImage)) {
         /* error was recorded */
d2851 11
a2861 2
         /* If we have a border, xoffset=-1 is legal.  Bias by border width */
         xoffset += texImage->Border;
d2865 18
a2882 3
            ASSERT(ctx->Driver.CopyTexSubImage1D);
            ctx->Driver.CopyTexSubImage1D(ctx, target, level,
                                          xoffset, x, y, width);
a2893 1

d2895 2
a2896 3
_mesa_CopyTexSubImage2D( GLenum target, GLint level,
                         GLint xoffset, GLint yoffset,
                         GLint x, GLint y, GLsizei width, GLsizei height )
a2897 3
   struct gl_texture_object *texObj;
   struct gl_texture_image *texImage;
   GLsizei postConvWidth = width, postConvHeight = height;
d2899 1
a2899 50
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

   if (MESA_VERBOSE & (VERBOSE_API|VERBOSE_TEXTURE))
      _mesa_debug(ctx, "glCopyTexSubImage2D %s %d %d %d %d %d %d %d\n",
                  _mesa_lookup_enum_by_nr(target),
                  level, xoffset, yoffset, x, y, width, height);

   if (ctx->NewState & NEW_COPY_TEX_STATE)
      _mesa_update_state(ctx);

   if (copytexsubimage_error_check1(ctx, 2, target, level))
      return;

   texObj = _mesa_get_current_tex_object(ctx, target);

   _mesa_lock_texture(ctx, texObj);
   {
      texImage = _mesa_select_tex_image(ctx, texObj, target, level);

#if FEATURE_convolve
      if (texImage && _mesa_is_color_format(texImage->InternalFormat)) {
         _mesa_adjust_image_for_convolution(ctx, 2,
                                            &postConvWidth, &postConvHeight);
      }
#endif

      if (copytexsubimage_error_check2(ctx, 2, target, level,
                                       xoffset, yoffset, 0,
				       postConvWidth, postConvHeight,
                                       texImage)) {
         /* error was recorded */
      }
      else {
         /* If we have a border, xoffset=-1 is legal.  Bias by border width */
         xoffset += texImage->Border;
         yoffset += texImage->Border;

         if (_mesa_clip_copytexsubimage(ctx, &xoffset, &yoffset, &x, &y,
                                        &width, &height)) {
            ASSERT(ctx->Driver.CopyTexSubImage2D);
            ctx->Driver.CopyTexSubImage2D(ctx, target, level, xoffset, yoffset,
                                          x, y, width, height);

            check_gen_mipmap(ctx, target, texObj, level);

            ctx->NewState |= _NEW_TEXTURE;
         }
      }
   }
   _mesa_unlock_texture(ctx, texObj);
d2905 2
a2906 2
_mesa_CopyTexSubImage3D( GLenum target, GLint level,
                         GLint xoffset, GLint yoffset, GLint zoffset,
a2908 3
   struct gl_texture_object *texObj;
   struct gl_texture_image *texImage;
   GLsizei postConvWidth = width, postConvHeight = height;
d2910 3
a2912 36
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

   if (MESA_VERBOSE & (VERBOSE_API|VERBOSE_TEXTURE))
      _mesa_debug(ctx, "glCopyTexSubImage3D %s %d %d %d %d %d %d %d %d\n",
                  _mesa_lookup_enum_by_nr(target),
                  level, xoffset, yoffset, zoffset, x, y, width, height);

   if (ctx->NewState & NEW_COPY_TEX_STATE)
      _mesa_update_state(ctx);

   if (copytexsubimage_error_check1(ctx, 3, target, level))
      return;

   texObj = _mesa_get_current_tex_object(ctx, target);

   _mesa_lock_texture(ctx, texObj);
   {
      texImage = _mesa_select_tex_image(ctx, texObj, target, level);

#if FEATURE_convolve
      if (texImage && _mesa_is_color_format(texImage->InternalFormat)) {
         _mesa_adjust_image_for_convolution(ctx, 2,
                                            &postConvWidth, &postConvHeight);
      }
#endif

      if (copytexsubimage_error_check2(ctx, 3, target, level, xoffset, yoffset,
				       zoffset, postConvWidth, postConvHeight,
				       texImage)) {
         /* error was recored */
      }
      else {
         /* If we have a border, xoffset=-1 is legal.  Bias by border width */
         xoffset += texImage->Border;
         yoffset += texImage->Border;
         zoffset += texImage->Border;
a2913 6
         if (_mesa_clip_copytexsubimage(ctx, &xoffset, &yoffset, &x, &y,
                                        &width, &height)) {
            ASSERT(ctx->Driver.CopyTexSubImage3D);
            ctx->Driver.CopyTexSubImage3D(ctx, target, level,
                                          xoffset, yoffset, zoffset,
                                          x, y, width, height);
a2914 1
            check_gen_mipmap(ctx, target, texObj, level);
d2916 8
a2923 5
            ctx->NewState |= _NEW_TEXTURE;
         }
      }
   }
   _mesa_unlock_texture(ctx, texObj);
d2962 1
a2962 1
compressed_texture_error_check(GLcontext *ctx, GLint dimensions,
d2968 7
a2974 1
   GLint expectedSize, maxLevels = 0, maxTextureSize;
d2976 1
a2976 28
   if (dimensions == 1) {
      /* 1D compressed textures not allowed */
      return GL_INVALID_ENUM;
   }
   else if (dimensions == 2) {
      if (target == GL_PROXY_TEXTURE_2D) {
         maxLevels = ctx->Const.MaxTextureLevels;
      }
      else if (target == GL_TEXTURE_2D) {
         maxLevels = ctx->Const.MaxTextureLevels;
      }
      else if (target == GL_PROXY_TEXTURE_CUBE_MAP_ARB) {
         if (!ctx->Extensions.ARB_texture_cube_map)
            return GL_INVALID_ENUM; /*target*/
         maxLevels = ctx->Const.MaxCubeTextureLevels;
      }
      else if (target >= GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB &&
               target <= GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB) {
         if (!ctx->Extensions.ARB_texture_cube_map)
            return GL_INVALID_ENUM; /*target*/
         maxLevels = ctx->Const.MaxCubeTextureLevels;
      }
      else {
         return GL_INVALID_ENUM; /*target*/
      }
   }
   else if (dimensions == 3) {
      /* 3D compressed textures not allowed */
a2979 2
   maxTextureSize = 1 << (maxLevels - 1);

d2981 1
a2981 1
   if (!is_compressed_format(ctx, internalFormat))
d2988 1
a2991 17
   /*
    * XXX We should probably use the proxy texture error check function here.
    */
   if (width < 1 || width > maxTextureSize ||
       (!ctx->Extensions.ARB_texture_non_power_of_two && !_mesa_is_pow_two(width)))
      return GL_INVALID_VALUE;

   if ((height < 1 || height > maxTextureSize ||
       (!ctx->Extensions.ARB_texture_non_power_of_two && !_mesa_is_pow_two(height)))
       && dimensions > 1)
      return GL_INVALID_VALUE;

   if ((depth < 1 || depth > maxTextureSize ||
       (!ctx->Extensions.ARB_texture_non_power_of_two && !_mesa_is_pow_two(depth)))
       && dimensions > 2)
      return GL_INVALID_VALUE;

d2997 26
a3022 2
   if (level < 0 || level >= maxLevels)
      return GL_INVALID_VALUE;
d3024 1
d3026 5
a3030 1
   if (expectedSize != imageSize)
a3031 8

#if FEATURE_EXT_texture_sRGB
   if ((internalFormat == GL_COMPRESSED_SRGB_S3TC_DXT1_EXT ||
        internalFormat == GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT ||
        internalFormat == GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT ||
        internalFormat == GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT)
       && border != 0) {
      return GL_INVALID_OPERATION;
a3032 1
#endif
d3046 1
a3046 1
compressed_subtexture_error_check(GLcontext *ctx, GLint dimensions,
d3090 1
a3090 1
   if (!is_compressed_format(ctx, format))
d3130 1
a3130 1
compressed_subtexture_error_check2(GLcontext *ctx, GLuint dims,
d3174 11
a3185 7
void GLAPIENTRY
_mesa_CompressedTexImage1DARB(GLenum target, GLint level,
                              GLenum internalFormat, GLsizei width,
                              GLint border, GLsizei imageSize,
                              const GLvoid *data)
{
   GET_CURRENT_CONTEXT(ctx);
d3189 3
a3191 1
      _mesa_debug(ctx, "glCompressedTexImage1DARB %s %d %s %d %d %d %p\n",
d3194 1
a3194 1
                  width, border, imageSize, data);
d3196 6
a3201 10
   if (target == GL_TEXTURE_1D) {
      /* non-proxy target */
      struct gl_texture_object *texObj;
      struct gl_texture_image *texImage;
      GLenum error = compressed_texture_error_check(ctx, 1, target, level,
                               internalFormat, width, 1, 1, border, imageSize);
      if (error) {
         _mesa_error(ctx, error, "glCompressedTexImage1D");
         return;
      }
d3203 3
a3205 1
      texObj = _mesa_get_current_tex_object(ctx, target);
d3207 6
a3212 11
      _mesa_lock_texture(ctx, texObj);
      {
	 texImage = _mesa_get_tex_image(ctx, texObj, target, level);
	 if (!texImage) {
	    _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCompressedTexImage1D");
	 }
         else {
            if (texImage->Data) {
               ctx->Driver.FreeTexImageData( ctx, texImage );
            }
            ASSERT(texImage->Data == NULL);
d3214 18
a3231 2
            _mesa_init_teximage_fields(ctx, target, texImage, width, 1, 1,
                                       border, internalFormat);
d3233 3
a3235 11
            /* Choose actual texture format */
            texImage->TexFormat =
               ctx->Driver.ChooseTextureFormat(ctx, internalFormat,
                                               GL_NONE, GL_NONE);
            ASSERT(texImage->TexFormat != MESA_FORMAT_NONE);

            ASSERT(ctx->Driver.CompressedTexImage1D);
            ctx->Driver.CompressedTexImage1D(ctx, target, level,
                                             internalFormat, width, border,
                                             imageSize, data,
                                             texObj, texImage);
d3237 8
a3244 7
            _mesa_set_fetch_functions(texImage, 1);

            check_gen_mipmap(ctx, target, texObj, level);

            /* state update */
            texObj->_Complete = GL_FALSE;
            ctx->NewState |= _NEW_TEXTURE;
d3247 5
a3251 17
      _mesa_unlock_texture(ctx, texObj);
   }
   else if (target == GL_PROXY_TEXTURE_1D) {
      /* Proxy texture: check for errors and update proxy state */
      GLenum error = compressed_texture_error_check(ctx, 1, target, level,
                               internalFormat, width, 1, 1, border, imageSize);
      if (!error) {
         ASSERT(ctx->Driver.TestProxyTexImage);
         error = !(*ctx->Driver.TestProxyTexImage)(ctx, target, level,
                                             internalFormat, GL_NONE, GL_NONE,
                                             width, 1, 1, border);
      }
      if (error) {
         /* if error, clear all proxy texture image parameters */
         struct gl_texture_image *texImage;
         texImage = _mesa_get_proxy_tex_image(ctx, target, level);
         if (texImage)
d3253 7
a3259 15
      }
      else {
         /* store the teximage parameters */
         struct gl_texture_object *texObj;
         struct gl_texture_image *texImage;

         texObj = _mesa_get_current_tex_object(ctx, target);

	 _mesa_lock_texture(ctx, texObj);
	 {
	    texImage = _mesa_select_tex_image(ctx, texObj, target, level);
	    _mesa_init_teximage_fields(ctx, target, texImage, width, 1, 1,
				       border, internalFormat);
	 }
	 _mesa_unlock_texture(ctx, texObj);
a3262 25
      _mesa_error(ctx, GL_INVALID_ENUM, "glCompressedTexImage1D(target)");
      return;
   }
}


void GLAPIENTRY
_mesa_CompressedTexImage2DARB(GLenum target, GLint level,
                              GLenum internalFormat, GLsizei width,
                              GLsizei height, GLint border, GLsizei imageSize,
                              const GLvoid *data)
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

   if (MESA_VERBOSE & (VERBOSE_API|VERBOSE_TEXTURE))
      _mesa_debug(ctx, "glCompressedTexImage2DARB %s %d %s %d %d %d %d %p\n",
                  _mesa_lookup_enum_by_nr(target), level,
                  _mesa_lookup_enum_by_nr(internalFormat),
                  width, height, border, imageSize, data);

   if (target == GL_TEXTURE_2D ||
       (ctx->Extensions.ARB_texture_cube_map &&
        target >= GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB &&
        target <= GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB)) {
a3266 2
      GLenum error = compressed_texture_error_check(ctx, 2, target, level,
                          internalFormat, width, height, 1, border, imageSize);
d3268 1
a3268 1
         _mesa_error(ctx, error, "glCompressedTexImage2D");
d3278 2
a3279 1
	    _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCompressedTexImage2D");
d3282 2
d3289 37
a3325 2
            _mesa_init_teximage_fields(ctx, target, texImage, width, height, 1,
                                       border, internalFormat);
d3327 1
a3327 11
            /* Choose actual texture format */
            texImage->TexFormat =
               ctx->Driver.ChooseTextureFormat(ctx, internalFormat,
                                               GL_NONE, GL_NONE);
            ASSERT(texImage->TexFormat != MESA_FORMAT_NONE);

            ASSERT(ctx->Driver.CompressedTexImage2D);
            ctx->Driver.CompressedTexImage2D(ctx, target, level,
                                             internalFormat, width, height,
                                             border, imageSize, data,
                                             texObj, texImage);
d3329 8
a3336 7
            _mesa_set_fetch_functions(texImage, 2);

            check_gen_mipmap(ctx, target, texObj, level);

            /* state update */
            texObj->_Complete = GL_FALSE;
            ctx->NewState |= _NEW_TEXTURE;
a3340 39
   else if (target == GL_PROXY_TEXTURE_2D ||
            (target == GL_PROXY_TEXTURE_CUBE_MAP_ARB &&
             ctx->Extensions.ARB_texture_cube_map)) {
      /* Proxy texture: check for errors and update proxy state */
      GLenum error = compressed_texture_error_check(ctx, 2, target, level,
                          internalFormat, width, height, 1, border, imageSize);
      if (!error) {
         ASSERT(ctx->Driver.TestProxyTexImage);
         error = !(*ctx->Driver.TestProxyTexImage)(ctx, target, level,
                                              internalFormat, GL_NONE, GL_NONE,
                                              width, height, 1, border);
      }
      if (error) {
         /* if error, clear all proxy texture image parameters */
         struct gl_texture_image *texImage;
         texImage = _mesa_get_proxy_tex_image(ctx, target, level);
         if (texImage)
            clear_teximage_fields(texImage);
      }
      else {
         /* store the teximage parameters */
         struct gl_texture_object *texObj;
         struct gl_texture_image *texImage;

         texObj = _mesa_get_current_tex_object(ctx, target);

	 _mesa_lock_texture(ctx, texObj);
	 {
	    texImage = _mesa_select_tex_image(ctx, texObj, target, level);
	    _mesa_init_teximage_fields(ctx, target, texImage, width, height, 1,
				       border, internalFormat);
	 }
	 _mesa_unlock_texture(ctx, texObj);
      }
   }
   else {
      _mesa_error(ctx, GL_INVALID_ENUM, "glCompressedTexImage2D(target)");
      return;
   }
d3345 1
a3345 1
_mesa_CompressedTexImage3DARB(GLenum target, GLint level,
d3347 2
a3348 2
                              GLsizei height, GLsizei depth, GLint border,
                              GLsizei imageSize, const GLvoid *data)
d3351 3
a3353 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
a3354 5
   if (MESA_VERBOSE & (VERBOSE_API|VERBOSE_TEXTURE))
      _mesa_debug(ctx, "glCompressedTexImage3DARB %s %d %s %d %d %d %d %d %p\n",
                  _mesa_lookup_enum_by_nr(target), level,
                  _mesa_lookup_enum_by_nr(internalFormat),
                  width, height, depth, border, imageSize, data);
d3356 10
a3365 10
   if (target == GL_TEXTURE_3D) {
      /* non-proxy target */
      struct gl_texture_object *texObj;
      struct gl_texture_image *texImage;
      GLenum error = compressed_texture_error_check(ctx, 3, target, level,
                      internalFormat, width, height, depth, border, imageSize);
      if (error) {
         _mesa_error(ctx, error, "glCompressedTexImage3D");
         return;
      }
a3366 1
      texObj = _mesa_get_current_tex_object(ctx, target);
d3368 9
a3376 77
      _mesa_lock_texture(ctx, texObj);
      {
	 texImage = _mesa_get_tex_image(ctx, texObj, target, level);
	 if (!texImage) {
	    _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCompressedTexImage3D");
	 }
         else {
            if (texImage->Data) {
               ctx->Driver.FreeTexImageData( ctx, texImage );
            }
            ASSERT(texImage->Data == NULL);

            _mesa_init_teximage_fields(ctx, target, texImage,
                                       width, height, depth,
                                       border, internalFormat);

            /* Choose actual texture format */
            texImage->TexFormat =
               ctx->Driver.ChooseTextureFormat(ctx, internalFormat,
                                               GL_NONE, GL_NONE);
            ASSERT(texImage->TexFormat != MESA_FORMAT_NONE);

            ASSERT(ctx->Driver.CompressedTexImage3D);
            ctx->Driver.CompressedTexImage3D(ctx, target, level,
                                             internalFormat,
                                             width, height, depth,
                                             border, imageSize, data,
                                             texObj, texImage);

            _mesa_set_fetch_functions(texImage, 3);

            check_gen_mipmap(ctx, target, texObj, level);

            /* state update */
            texObj->_Complete = GL_FALSE;
            ctx->NewState |= _NEW_TEXTURE;
         }
      }
      _mesa_unlock_texture(ctx, texObj);
   }
   else if (target == GL_PROXY_TEXTURE_3D) {
      /* Proxy texture: check for errors and update proxy state */
      GLenum error = compressed_texture_error_check(ctx, 3, target, level,
                      internalFormat, width, height, depth, border, imageSize);
      if (!error) {
         ASSERT(ctx->Driver.TestProxyTexImage);
         error = !(*ctx->Driver.TestProxyTexImage)(ctx, target, level,
                                             internalFormat, GL_NONE, GL_NONE,
                                             width, height, depth, border);
      }
      if (error) {
         /* if error, clear all proxy texture image parameters */
         struct gl_texture_image *texImage;
         texImage = _mesa_get_proxy_tex_image(ctx, target, level);
         if (texImage)
            clear_teximage_fields(texImage);
      }
      else {
         /* store the teximage parameters */
         struct gl_texture_object *texObj;
         struct gl_texture_image *texImage;

         texObj = _mesa_get_current_tex_object(ctx, target);

	 _mesa_lock_texture(ctx, texObj);
	 {
	    texImage = _mesa_select_tex_image(ctx, texObj, target, level);
	    _mesa_init_teximage_fields(ctx, target, texImage, width, height,
				       depth, border, internalFormat);
	 }
	 _mesa_unlock_texture(ctx, texObj);
      }
   }
   else {
      _mesa_error(ctx, GL_INVALID_ENUM, "glCompressedTexImage3D(target)");
      return;
   }
a3485 2


@


1.4
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d3 1
a3 1
 * Version:  7.1
d6 1
a35 1
#if FEATURE_convolve
d37 1
a37 1
#endif
d40 1
d46 1
a46 1
#include "texformat.h"
a48 1
#include "texstore.h"
d57 1
a57 1
#define NEW_COPY_TEX_STATE (_IMAGE_NEW_TRANSFER_STATE | \
a83 57


#if 0
static void PrintTexture(GLcontext *ctx, const struct gl_texture_image *img)
{
#if CHAN_TYPE != GL_UNSIGNED_BYTE
   _mesa_problem(NULL, "PrintTexture not supported");
#else
   GLuint i, j, c;
   const GLubyte *data = (const GLubyte *) img->Data;

   if (!data) {
      _mesa_printf("No texture data\n");
      return;
   }

   switch (img->Format) {
      case GL_ALPHA:
      case GL_LUMINANCE:
      case GL_INTENSITY:
      case GL_COLOR_INDEX:
         c = 1;
         break;
      case GL_LUMINANCE_ALPHA:
         c = 2;
         break;
      case GL_RGB:
         c = 3;
         break;
      case GL_RGBA:
         c = 4;
         break;
      default:
         _mesa_problem(NULL, "error in PrintTexture\n");
         return;
   }

   for (i = 0; i < img->Height; i++) {
      for (j = 0; j < img->Width; j++) {
         if (c==1)
            _mesa_printf("%02x  ", data[0]);
         else if (c==2)
            _mesa_printf("%02x%02x  ", data[0], data[1]);
         else if (c==3)
            _mesa_printf("%02x%02x%02x  ", data[0], data[1], data[2]);
         else if (c==4)
            _mesa_printf("%02x%02x%02x%02x  ", data[0], data[1], data[2], data[3]);
         data += (img->RowStride - img->Width) * c;
      }
      /* XXX use img->ImageStride here */
      _mesa_printf("\n");
   }
#endif
}
#endif


d126 2
d212 15
a226 17
   if (ctx->Extensions.ARB_texture_compression) {
      switch (internalFormat) {
         case GL_COMPRESSED_ALPHA:
            return GL_ALPHA;
         case GL_COMPRESSED_LUMINANCE:
            return GL_LUMINANCE;
         case GL_COMPRESSED_LUMINANCE_ALPHA:
            return GL_LUMINANCE_ALPHA;
         case GL_COMPRESSED_INTENSITY:
            return GL_INTENSITY;
         case GL_COMPRESSED_RGB:
            return GL_RGB;
         case GL_COMPRESSED_RGBA:
            return GL_RGBA;
         default:
            ; /* fallthrough */
      }
d296 20
a360 187
 * Test if the given image format is a color/RGBA format (i.e., not color
 * index, depth, stencil, etc).
 * \param format  the image format value (may by an internal texture format)
 * \return GL_TRUE if its a color/RGBA format, GL_FALSE otherwise.
 * XXX maybe move this func to image.c
 */
GLboolean
_mesa_is_color_format(GLenum format)
{
   switch (format) {
      case GL_RED:
      case GL_GREEN:
      case GL_BLUE:
      case GL_ALPHA:
      case GL_ALPHA4:
      case GL_ALPHA8:
      case GL_ALPHA12:
      case GL_ALPHA16:
      case 1:
      case GL_LUMINANCE:
      case GL_LUMINANCE4:
      case GL_LUMINANCE8:
      case GL_LUMINANCE12:
      case GL_LUMINANCE16:
      case 2:
      case GL_LUMINANCE_ALPHA:
      case GL_LUMINANCE4_ALPHA4:
      case GL_LUMINANCE6_ALPHA2:
      case GL_LUMINANCE8_ALPHA8:
      case GL_LUMINANCE12_ALPHA4:
      case GL_LUMINANCE12_ALPHA12:
      case GL_LUMINANCE16_ALPHA16:
      case GL_INTENSITY:
      case GL_INTENSITY4:
      case GL_INTENSITY8:
      case GL_INTENSITY12:
      case GL_INTENSITY16:
      case 3:
      case GL_RGB:
      case GL_BGR:
      case GL_R3_G3_B2:
      case GL_RGB4:
      case GL_RGB5:
      case GL_RGB8:
      case GL_RGB10:
      case GL_RGB12:
      case GL_RGB16:
      case 4:
      case GL_ABGR_EXT:
      case GL_RGBA:
      case GL_BGRA:
      case GL_RGBA2:
      case GL_RGBA4:
      case GL_RGB5_A1:
      case GL_RGBA8:
      case GL_RGB10_A2:
      case GL_RGBA12:
      case GL_RGBA16:
      /* float texture formats */
      case GL_ALPHA16F_ARB:
      case GL_ALPHA32F_ARB:
      case GL_LUMINANCE16F_ARB:
      case GL_LUMINANCE32F_ARB:
      case GL_LUMINANCE_ALPHA16F_ARB:
      case GL_LUMINANCE_ALPHA32F_ARB:
      case GL_INTENSITY16F_ARB:
      case GL_INTENSITY32F_ARB:
      case GL_RGB16F_ARB:
      case GL_RGB32F_ARB:
      case GL_RGBA16F_ARB:
      case GL_RGBA32F_ARB:
      /* compressed formats */
      case GL_COMPRESSED_ALPHA:
      case GL_COMPRESSED_LUMINANCE:
      case GL_COMPRESSED_LUMINANCE_ALPHA:
      case GL_COMPRESSED_INTENSITY:
      case GL_COMPRESSED_RGB:
      case GL_COMPRESSED_RGBA:
      case GL_RGB_S3TC:
      case GL_RGB4_S3TC:
      case GL_RGBA_S3TC:
      case GL_RGBA4_S3TC:
      case GL_COMPRESSED_RGB_S3TC_DXT1_EXT:
      case GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:
      case GL_COMPRESSED_RGBA_S3TC_DXT3_EXT:
      case GL_COMPRESSED_RGBA_S3TC_DXT5_EXT:
      case GL_COMPRESSED_RGB_FXT1_3DFX:
      case GL_COMPRESSED_RGBA_FXT1_3DFX:
#if FEATURE_EXT_texture_sRGB
      case GL_SRGB_EXT:
      case GL_SRGB8_EXT:
      case GL_SRGB_ALPHA_EXT:
      case GL_SRGB8_ALPHA8_EXT:
      case GL_SLUMINANCE_ALPHA_EXT:
      case GL_SLUMINANCE8_ALPHA8_EXT:
      case GL_SLUMINANCE_EXT:
      case GL_SLUMINANCE8_EXT:
      case GL_COMPRESSED_SRGB_EXT:
      case GL_COMPRESSED_SRGB_S3TC_DXT1_EXT:
      case GL_COMPRESSED_SRGB_ALPHA_EXT:
      case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:
      case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:
      case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:
      case GL_COMPRESSED_SLUMINANCE_EXT:
      case GL_COMPRESSED_SLUMINANCE_ALPHA_EXT:
#endif /* FEATURE_EXT_texture_sRGB */
         return GL_TRUE;
      case GL_YCBCR_MESA:  /* not considered to be RGB */
         /* fall-through */
      default:
         return GL_FALSE;
   }
}


/**
 * Test if the given image format is a color index format.
 */
static GLboolean
is_index_format(GLenum format)
{
   switch (format) {
      case GL_COLOR_INDEX:
      case GL_COLOR_INDEX1_EXT:
      case GL_COLOR_INDEX2_EXT:
      case GL_COLOR_INDEX4_EXT:
      case GL_COLOR_INDEX8_EXT:
      case GL_COLOR_INDEX12_EXT:
      case GL_COLOR_INDEX16_EXT:
         return GL_TRUE;
      default:
         return GL_FALSE;
   }
}


/**
 * Test if the given image format is a depth component format.
 */
static GLboolean
is_depth_format(GLenum format)
{
   switch (format) {
      case GL_DEPTH_COMPONENT16:
      case GL_DEPTH_COMPONENT24:
      case GL_DEPTH_COMPONENT32:
      case GL_DEPTH_COMPONENT:
         return GL_TRUE;
      default:
         return GL_FALSE;
   }
}


/**
 * Test if the given image format is a YCbCr format.
 */
static GLboolean
is_ycbcr_format(GLenum format)
{
   switch (format) {
      case GL_YCBCR_MESA:
         return GL_TRUE;
      default:
         return GL_FALSE;
   }
}


/**
 * Test if the given image format is a Depth/Stencil format.
 */
static GLboolean
is_depthstencil_format(GLenum format)
{
   switch (format) {
      case GL_DEPTH24_STENCIL8_EXT:
      case GL_DEPTH_STENCIL_EXT:
         return GL_TRUE;
      default:
         return GL_FALSE;
   }
}



/**
d420 2
d424 4
a427 29
   /* XXX simplify this with _mesa_tex_target_to_face() */
   switch (target) {
      case GL_TEXTURE_1D:
      case GL_TEXTURE_2D:
      case GL_TEXTURE_3D:
      case GL_TEXTURE_1D_ARRAY_EXT:
      case GL_TEXTURE_2D_ARRAY_EXT:
         tObj->Image[0][level] = texImage;
         break;
      case GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB:
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB:
      case GL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB:
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB:
      case GL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB:
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB:
         {
            GLuint face = ((GLuint) target - 
                           (GLuint) GL_TEXTURE_CUBE_MAP_POSITIVE_X);
            tObj->Image[face][level] = texImage;
         }
         break;
      case GL_TEXTURE_RECTANGLE_NV:
         ASSERT(level == 0);
         tObj->Image[0][level] = texImage;
         break;
      default:
         _mesa_problem(NULL, "bad target in _mesa_set_tex_image()");
         return;
   }
d454 1
a454 1
 * \param teximage texture image.
d476 1
a476 1
 * \param teximage texture image.
d491 2
a492 2
      _mesa_free(texImage->ImageOffsets);
   _mesa_free(texImage);
d506 3
d585 14
a598 2
 * Get the texture image struct which corresponds to target and level
 * of the given texture unit.
d601 1
a601 1
 * \param texUnit texture unit.
d605 1
a605 3
 * \return pointer to the texture image structure on success, or NULL on failure.
 *
 * \sa gl_texture_unit.
d611 2
d614 2
d617 1
a617 50
   if (level < 0 || level >= MAX_TEXTURE_LEVELS) 
      return NULL;

   /* XXX simplify this with _mesa_tex_target_to_face() */
   switch (target) {
      case GL_TEXTURE_1D:
      case GL_PROXY_TEXTURE_1D:
      case GL_TEXTURE_2D:
      case GL_PROXY_TEXTURE_2D:
      case GL_TEXTURE_3D:
      case GL_PROXY_TEXTURE_3D:
         return texObj->Image[0][level];

      case GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB:
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB:
      case GL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB:
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB:
      case GL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB:
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB: 
         if (ctx->Extensions.ARB_texture_cube_map) {
	    GLuint face = ((GLuint) target - 
			   (GLuint) GL_TEXTURE_CUBE_MAP_POSITIVE_X);
            return texObj->Image[face][level];
	 }
         else
            return NULL;

      case GL_PROXY_TEXTURE_CUBE_MAP_ARB:
         if (ctx->Extensions.ARB_texture_cube_map)
            return texObj->Image[0][level];
         else
            return NULL;

      case GL_TEXTURE_RECTANGLE_NV:
      case GL_PROXY_TEXTURE_RECTANGLE_NV:
         if (ctx->Extensions.NV_texture_rectangle && level == 0) 
            return texObj->Image[0][level];
         else 
            return NULL;

      case GL_TEXTURE_1D_ARRAY_EXT:
      case GL_PROXY_TEXTURE_1D_ARRAY_EXT:
      case GL_TEXTURE_2D_ARRAY_EXT:
      case GL_PROXY_TEXTURE_2D_ARRAY_EXT:
         return (ctx->Extensions.MESA_texture_array)
            ? texObj->Image[0][level] : NULL;

      default:
         return NULL;
   }
d660 1
d669 2
a670 12
      texImage = ctx->Texture.ProxyTex[TEXTURE_1D_INDEX]->Image[0][level];
      if (!texImage) {
         texImage = ctx->Driver.NewTextureImage(ctx);
         if (!texImage) {
            _mesa_error(ctx, GL_OUT_OF_MEMORY, "proxy texture allocation");
            return NULL;
         }
         ctx->Texture.ProxyTex[TEXTURE_1D_INDEX]->Image[0][level] = texImage;
         /* Set the 'back' pointer */
         texImage->TexObject = ctx->Texture.ProxyTex[TEXTURE_1D_INDEX];
      }
      return texImage;
d674 2
a675 12
      texImage = ctx->Texture.ProxyTex[TEXTURE_2D_INDEX]->Image[0][level];
      if (!texImage) {
         texImage = ctx->Driver.NewTextureImage(ctx);
         if (!texImage) {
            _mesa_error(ctx, GL_OUT_OF_MEMORY, "proxy texture allocation");
            return NULL;
         }
         ctx->Texture.ProxyTex[TEXTURE_2D_INDEX]->Image[0][level] = texImage;
         /* Set the 'back' pointer */
         texImage->TexObject = ctx->Texture.ProxyTex[TEXTURE_2D_INDEX];
      }
      return texImage;
d679 2
a680 12
      texImage = ctx->Texture.ProxyTex[TEXTURE_3D_INDEX]->Image[0][level];
      if (!texImage) {
         texImage = ctx->Driver.NewTextureImage(ctx);
         if (!texImage) {
            _mesa_error(ctx, GL_OUT_OF_MEMORY, "proxy texture allocation");
            return NULL;
         }
         ctx->Texture.ProxyTex[TEXTURE_3D_INDEX]->Image[0][level] = texImage;
         /* Set the 'back' pointer */
         texImage->TexObject = ctx->Texture.ProxyTex[TEXTURE_3D_INDEX];
      }
      return texImage;
d684 2
a685 12
      texImage = ctx->Texture.ProxyTex[TEXTURE_CUBE_INDEX]->Image[0][level];
      if (!texImage) {
         texImage = ctx->Driver.NewTextureImage(ctx);
         if (!texImage) {
            _mesa_error(ctx, GL_OUT_OF_MEMORY, "proxy texture allocation");
            return NULL;
         }
         ctx->Texture.ProxyTex[TEXTURE_CUBE_INDEX]->Image[0][level] = texImage;
         /* Set the 'back' pointer */
         texImage->TexObject = ctx->Texture.ProxyTex[TEXTURE_CUBE_INDEX];
      }
      return texImage;
d689 2
a690 12
      texImage = ctx->Texture.ProxyTex[TEXTURE_RECT_INDEX]->Image[0][level];
      if (!texImage) {
         texImage = ctx->Driver.NewTextureImage(ctx);
         if (!texImage) {
            _mesa_error(ctx, GL_OUT_OF_MEMORY, "proxy texture allocation");
            return NULL;
         }
         ctx->Texture.ProxyTex[TEXTURE_RECT_INDEX]->Image[0][level] = texImage;
         /* Set the 'back' pointer */
         texImage->TexObject = ctx->Texture.ProxyTex[TEXTURE_RECT_INDEX];
      }
      return texImage;
d694 2
a695 12
      texImage = ctx->Texture.ProxyTex[TEXTURE_1D_ARRAY_INDEX]->Image[0][level];
      if (!texImage) {
         texImage = ctx->Driver.NewTextureImage(ctx);
         if (!texImage) {
            _mesa_error(ctx, GL_OUT_OF_MEMORY, "proxy texture allocation");
            return NULL;
         }
         ctx->Texture.ProxyTex[TEXTURE_1D_ARRAY_INDEX]->Image[0][level] = texImage;
         /* Set the 'back' pointer */
         texImage->TexObject = ctx->Texture.ProxyTex[TEXTURE_1D_ARRAY_INDEX];
      }
      return texImage;
d699 9
a707 1
      texImage = ctx->Texture.ProxyTex[TEXTURE_2D_ARRAY_INDEX]->Image[0][level];
d709 2
a710 8
         texImage = ctx->Driver.NewTextureImage(ctx);
         if (!texImage) {
            _mesa_error(ctx, GL_OUT_OF_MEMORY, "proxy texture allocation");
            return NULL;
         }
         ctx->Texture.ProxyTex[TEXTURE_2D_ARRAY_INDEX]->Image[0][level] = texImage;
         /* Set the 'back' pointer */
         texImage->TexObject = ctx->Texture.ProxyTex[TEXTURE_2D_ARRAY_INDEX];
d712 3
a714 3
      return texImage;
   default:
      return NULL;
d716 1
a738 4
   case GL_TEXTURE_1D_ARRAY_EXT:
   case GL_PROXY_TEXTURE_1D_ARRAY_EXT:
   case GL_TEXTURE_2D_ARRAY_EXT:
   case GL_PROXY_TEXTURE_2D_ARRAY_EXT:
d751 2
a752 1
      return ctx->Const.MaxCubeTextureLevels;
d755 7
a761 1
      return 1;
d846 1
a846 1
      _mesa_free(img->ImageOffsets);
d856 1
a856 1
   img->TexFormat = &_mesa_null_texformat;
a858 2
   img->IsCompressed = 0;
   img->CompressedSize = 0;
d897 1
a898 2
   img->Height2 = height - 2 * border; /* == 1 << img->HeightLog2; */
   img->Depth2 = depth - 2 * border;   /* == 1 << img->DepthLog2; */
d900 3
a902 1
   if (height == 1)  /* 1-D texture */
d904 3
a906 1
   else
d908 4
a911 1
   if (depth == 1)   /* 2-D texture */
d913 3
a915 1
   else
d917 2
a919 2
   img->IsCompressed = GL_FALSE;
   img->CompressedSize = 0;
d934 3
a936 1
   img->ImageOffsets = (GLuint *) _mesa_malloc(depth * sizeof(GLuint));
d953 20
d1269 2
a1270 2
                     "glTexImage%dD(internalFormat=0x%x)",
                     dimensions, internalFormat);
d1282 2
a1283 1
                     "glTexImage%dD(format or type)", dimensions);
d1290 1
a1290 1
   indexFormat = is_index_format(format);
d1292 5
a1296 4
       (is_index_format(internalFormat) && !indexFormat) ||
       (is_depth_format(internalFormat) != is_depth_format(format)) ||
       (is_ycbcr_format(internalFormat) != is_ycbcr_format(format)) ||
       (is_depthstencil_format(internalFormat) != is_depthstencil_format(format))) {
d1299 2
a1300 1
                     "glTexImage(internalFormat/format)");
d1310 1
a1310 1
         _mesa_sprintf(message,
d1326 1
a1326 1
            _mesa_sprintf(message,
d1474 2
a1475 1
                  "glTexSubImage%dD(format or type)", dimensions);
d1482 5
d1534 2
a1535 13
#if FEATURE_EXT_texture_sRGB
   if (destTex->InternalFormat == GL_COMPRESSED_SRGB_S3TC_DXT1_EXT ||
       destTex->InternalFormat == GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT ||
       destTex->InternalFormat == GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT ||
       destTex->InternalFormat == GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT) {
      if ((width & 0x3) || (height & 0x3) ||
          (xoffset & 0x3) || (yoffset & 0x3))
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glTexSubImage%dD(size or offset not multiple of 4)",
                     dimensions);
      return GL_TRUE;
   }
#endif
a1536 1
   if (destTex->IsCompressed) {
d1539 2
a1540 1
                     "glTexSubImage%D(target)", dimensions);
d1543 6
a1548 2
      /* offset must be multiple of 4 */
      if ((xoffset & 3) || (yoffset & 3)) {
d1550 2
a1551 1
                     "glTexSubImage%D(xoffset or yoffset)", dimensions);
d1554 2
a1555 2
      /* size must be multiple of 4 or equal to whole texture size */
      if ((width & 3) && (GLuint) width != destTex->Width) {
d1557 1
a1557 1
                     "glTexSubImage%D(width)", dimensions);
d1560 1
a1560 1
      if ((height & 3) && (GLuint) height != destTex->Height) {
d1562 1
a1562 1
                     "glTexSubImage%D(width)", dimensions);
a1580 1
 * \param depth image depth given by the user.
a1628 2
   /* NOTE: the format and type aren't really significant for
    * TestProxyTexImage().  Only the internalformat really matters.
d1635 2
d1730 1
a1730 1
   else if (is_depth_format(internalFormat)) {
d1738 1
a1738 1
   else if (is_depthstencil_format(internalFormat)) {
d1904 1
a1904 1
   if (teximage->IsCompressed) {
d1963 2
a1964 12
/**
 * Get texture image.  Called by glGetTexImage.
 *
 * \param target texture target.
 * \param level image level.
 * \param format pixel data format for returned image.
 * \param type pixel data type for returned image.
 * \param pixels returned pixel data.
 */
void GLAPIENTRY
_mesa_GetTexImage( GLenum target, GLint level, GLenum format,
                   GLenum type, GLvoid *pixels )
d1966 1
a1966 1
   const struct gl_texture_unit *texUnit;
d1968 2
a1969 114
   struct gl_texture_image *texImage;
   GLint maxLevels = 0;
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

   texUnit = &(ctx->Texture.Unit[ctx->Texture.CurrentUnit]);
   texObj = _mesa_select_tex_object(ctx, texUnit, target);
   if (!texObj || _mesa_is_proxy_texture(target)) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexImage(target)");
      return;
   }

   maxLevels = _mesa_max_texture_levels(ctx, target);
   ASSERT(maxLevels > 0);  /* 0 indicates bad target, caught above */

   if (level < 0 || level >= maxLevels) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glGetTexImage(level)" );
      return;
   }

   if (_mesa_sizeof_packed_type(type) <= 0) {
      _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexImage(type)" );
      return;
   }

   if (_mesa_components_in_format(format) <= 0 ||
       format == GL_STENCIL_INDEX) {
      _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexImage(format)" );
      return;
   }

   if (!ctx->Extensions.EXT_paletted_texture && is_index_format(format)) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexImage(format)");
      return;
   }

   if (!ctx->Extensions.ARB_depth_texture && is_depth_format(format)) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexImage(format)");
      return;
   }

   if (!ctx->Extensions.MESA_ycbcr_texture && is_ycbcr_format(format)) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexImage(format)");
      return;
   }

   if (!ctx->Extensions.EXT_packed_depth_stencil
       && is_depthstencil_format(format)) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexImage(format)");
      return;
   }

   _mesa_lock_texture(ctx, texObj);
   {
      texImage = _mesa_select_tex_image(ctx, texObj, target, level);
      if (!texImage) {
	 /* invalid mipmap level, not an error */
	 goto out;
      }


      /* Make sure the requested image format is compatible with the
       * texture's format.  Note that a color index texture can be converted
       * to RGBA so that combo is allowed.
       */
      if (_mesa_is_color_format(format)
	  && !_mesa_is_color_format(texImage->TexFormat->BaseFormat)
	  && !is_index_format(texImage->TexFormat->BaseFormat)) {
	 _mesa_error(ctx, GL_INVALID_OPERATION, "glGetTexImage(format mismatch)");
	 goto out;
      }
      else if (is_index_format(format)
	       && !is_index_format(texImage->TexFormat->BaseFormat)) {
	 _mesa_error(ctx, GL_INVALID_OPERATION, "glGetTexImage(format mismatch)");
	 goto out;
      }
      else if (is_depth_format(format)
	       && !is_depth_format(texImage->TexFormat->BaseFormat)
	       && !is_depthstencil_format(texImage->TexFormat->BaseFormat)) {
	 _mesa_error(ctx, GL_INVALID_OPERATION, "glGetTexImage(format mismatch)");
	 goto out;
      }
      else if (is_ycbcr_format(format)
	       && !is_ycbcr_format(texImage->TexFormat->BaseFormat)) {
	 _mesa_error(ctx, GL_INVALID_OPERATION, "glGetTexImage(format mismatch)");
	 goto out;
      }
      else if (is_depthstencil_format(format)
	       && !is_depthstencil_format(texImage->TexFormat->BaseFormat)) {
	 _mesa_error(ctx, GL_INVALID_OPERATION, "glGetTexImage(format mismatch)");
	 goto out;
      }

      if (ctx->Pack.BufferObj->Name) {
	 /* packing texture image into a PBO */
	 const GLuint dimensions = (target == GL_TEXTURE_3D) ? 3 : 2;
	 if (!_mesa_validate_pbo_access(dimensions, &ctx->Pack, texImage->Width,
					texImage->Height, texImage->Depth,
					format, type, pixels)) {
	    _mesa_error(ctx, GL_INVALID_OPERATION,
			"glGetTexImage(invalid PBO access)");
	    goto out;
	 }
      }

      /* typically, this will call _mesa_get_teximage() */
      ctx->Driver.GetTexImage(ctx, target, level, format, type, pixels,
			      texObj, texImage);

   }
 out:
   _mesa_unlock_texture(ctx, texObj);
}

d1973 1
a1973 5
 * Check if the given texture image is bound to any framebuffer objects
 * and update/invalidate them.
 * XXX We're only checking the currently bound framebuffer object for now.
 * In the future, perhaps struct gl_texture_image should have a pointer (or
 * list of pointers (yikes)) to the gl_framebuffer(s) which it's bound to.
d1976 1
a1976 2
update_fbo_texture(GLcontext *ctx, struct gl_texture_object *texObj,
                   GLuint face, GLuint level)
d1978 8
a1985 1
   if (ctx->DrawBuffer->Name) {
d1987 1
d1989 1
a1989 2
         struct gl_renderbuffer_attachment *att = 
            ctx->DrawBuffer->Attachment + i;
d1997 2
d2005 84
d2102 9
a2118 1
      struct gl_texture_unit *texUnit;
d2128 1
a2128 1
      if (ctx->NewState & _IMAGE_NEW_TRANSFER_STATE)
d2131 1
a2131 2
      texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
      texObj = _mesa_select_tex_object(ctx, texUnit, target);
a2136 5
	    goto out;
	 }
      
	 if (texImage->Data) {
	    ctx->Driver.FreeTexImageData( ctx, texImage );
d2138 29
d2168 1
a2168 1
	 ASSERT(texImage->Data == NULL);
d2170 4
a2173 19
	 clear_teximage_fields(texImage); /* not really needed, but helpful */
	 _mesa_init_teximage_fields(ctx, target, texImage,
				    postConvWidth, 1, 1,
				    border, internalFormat);
	 
	 ASSERT(ctx->Driver.TexImage1D);

	 /* Give the texture to the driver!  <pixels> may be null! */
	 (*ctx->Driver.TexImage1D)(ctx, target, level, internalFormat,
				   width, border, format, type, pixels,
				   &ctx->Unpack, texObj, texImage);
	 
	 ASSERT(texImage->TexFormat);

	 update_fbo_texture(ctx, texObj, face, level);
	 
	 /* state update */
	 texObj->_Complete = GL_FALSE;
	 ctx->NewState |= _NEW_TEXTURE;
a2174 1
   out:
d2193 2
a2194 2
         texImage->TexFormat = (*ctx->Driver.ChooseTextureFormat)(ctx,
                                          internalFormat, format, type);
d2214 9
a2238 1
      struct gl_texture_unit *texUnit;
d2249 1
a2249 1
      if (ctx->NewState & _IMAGE_NEW_TRANSFER_STATE)
d2252 1
a2252 2
      texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
      texObj = _mesa_select_tex_object(ctx, texUnit, target);
a2257 1
	    goto out;
d2259 35
a2293 25
	 
	 if (texImage->Data) {
	    ctx->Driver.FreeTexImageData( ctx, texImage );
	 }
	 
	 ASSERT(texImage->Data == NULL);
	 clear_teximage_fields(texImage); /* not really needed, but helpful */
	 _mesa_init_teximage_fields(ctx, target, texImage,
				    postConvWidth, postConvHeight, 1,
				    border, internalFormat);
	 
	 ASSERT(ctx->Driver.TexImage2D);

	 /* Give the texture to the driver!  <pixels> may be null! */
	 (*ctx->Driver.TexImage2D)(ctx, target, level, internalFormat,
				   width, height, border, format, type, pixels,
				   &ctx->Unpack, texObj, texImage);
	 
	 ASSERT(texImage->TexFormat);

	 update_fbo_texture(ctx, texObj, face, level);

	 /* state update */
	 texObj->_Complete = GL_FALSE;
	 ctx->NewState |= _NEW_TEXTURE;
a2294 1
   out:
d2319 2
a2320 2
         texImage->TexFormat = (*ctx->Driver.ChooseTextureFormat)(ctx,
                                          internalFormat, format, type);
d2343 9
a2355 1
      struct gl_texture_unit *texUnit;
d2365 1
a2365 1
      if (ctx->NewState & _IMAGE_NEW_TRANSFER_STATE)
d2368 1
a2368 2
      texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
      texObj = _mesa_select_tex_object(ctx, texUnit, target);
a2373 1
	    goto out;
d2375 4
a2378 10
	 
	 if (texImage->Data) {
	    ctx->Driver.FreeTexImageData( ctx, texImage );
	 }
	 
	 ASSERT(texImage->Data == NULL);
	 clear_teximage_fields(texImage); /* not really needed, but helpful */
	 _mesa_init_teximage_fields(ctx, target, texImage,
				    width, height, depth,
				    border, internalFormat);
d2380 30
a2409 14
	 ASSERT(ctx->Driver.TexImage3D);

	 /* Give the texture to the driver!  <pixels> may be null! */
	 (*ctx->Driver.TexImage3D)(ctx, target, level, internalFormat,
				   width, height, depth, border, format, type,
				   pixels, &ctx->Unpack, texObj, texImage);

	 ASSERT(texImage->TexFormat);

	 update_fbo_texture(ctx, texObj, face, level);

	 /* state update */
	 texObj->_Complete = GL_FALSE;
	 ctx->NewState |= _NEW_TEXTURE;
a2410 1
   out:
d2429 2
a2430 2
         texImage->TexFormat = (*ctx->Driver.ChooseTextureFormat)(ctx,
                                          internalFormat, format, type);
d2434 29
a2462 1
      _mesa_error( ctx, GL_INVALID_ENUM, "glTexImage3D(target)" );
a2464 1
}
d2466 22
a2488 8
void GLAPIENTRY
_mesa_TexImage3DEXT( GLenum target, GLint level, GLenum internalFormat,
                     GLsizei width, GLsizei height, GLsizei depth,
                     GLint border, GLenum format, GLenum type,
                     const GLvoid *pixels )
{
   _mesa_TexImage3D(target, level, (GLint) internalFormat, width, height,
                    depth, border, format, type, pixels);
d2490 1
a2490 1

a2499 1
   struct gl_texture_unit *texUnit;
d2501 1
a2501 1
   struct gl_texture_image *texImage = NULL;
d2505 7
a2511 1
   if (ctx->NewState & _IMAGE_NEW_TRANSFER_STATE)
d2527 1
a2527 2
   texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
   texObj = _mesa_select_tex_object(ctx, texUnit, target);
d2535 12
a2546 3
				  postConvWidth, 1, 1, format, type, texImage)) {
	 goto out;   /* error was detected */
      }
d2548 1
a2548 2
      if (width == 0)
	 goto out;  /* no-op, not an error */
d2550 2
a2551 8
      /* If we have a border, xoffset=-1 is legal.  Bias by border width */
      xoffset += texImage->Border;

      ASSERT(ctx->Driver.TexSubImage1D);
      (*ctx->Driver.TexSubImage1D)(ctx, target, level, xoffset, width,
				   format, type, pixels, &ctx->Unpack,
				   texObj, texImage);
      ctx->NewState |= _NEW_TEXTURE;
a2552 1
 out:
a2564 1
   struct gl_texture_unit *texUnit;
d2570 8
a2577 1
   if (ctx->NewState & _IMAGE_NEW_TRANSFER_STATE)
d2593 2
a2594 2
   texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
   texObj = _mesa_select_tex_object(ctx, texUnit, target);
d2600 18
a2617 17
				  postConvWidth, postConvHeight, 1, format, type, 
				  texImage)) {
	 goto out;   /* error was detected */
      }

      if (width == 0 || height == 0)
	 goto out;  /* no-op, not an error */

      /* If we have a border, xoffset=-1 is legal.  Bias by border width */
      xoffset += texImage->Border;
      yoffset += texImage->Border;
      
      ASSERT(ctx->Driver.TexSubImage2D);
      (*ctx->Driver.TexSubImage2D)(ctx, target, level, xoffset, yoffset,
				   width, height, format, type, pixels,
				   &ctx->Unpack, texObj, texImage);
      ctx->NewState |= _NEW_TEXTURE;
a2618 1
 out:
a2630 1
   struct gl_texture_unit *texUnit;
d2636 8
a2643 1
   if (ctx->NewState & _IMAGE_NEW_TRANSFER_STATE)
d2651 1
a2651 2
   texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
   texObj = _mesa_select_tex_object(ctx, texUnit, target);
d2657 23
a2679 20
      if (subtexture_error_check2(ctx, 3, target, level, xoffset, yoffset, zoffset,
				  width, height, depth, format, type, texImage)) {
	 goto out;   /* error was detected */
      }

      if (width == 0 || height == 0 || height == 0)
	 goto out;  /* no-op, not an error */

      /* If we have a border, xoffset=-1 is legal.  Bias by border width */
      xoffset += texImage->Border;
      yoffset += texImage->Border;
      zoffset += texImage->Border;

      ASSERT(ctx->Driver.TexSubImage3D);
      (*ctx->Driver.TexSubImage3D)(ctx, target, level,
				   xoffset, yoffset, zoffset,
				   width, height, depth,
				   format, type, pixels,
				   &ctx->Unpack, texObj, texImage );
      ctx->NewState |= _NEW_TEXTURE;
a2680 1
 out:
a2691 1
   struct gl_texture_unit *texUnit;
d2699 6
d2718 2
a2719 2
   texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
   texObj = _mesa_select_tex_object(ctx, texUnit, target);
a2724 1
	 goto out;
d2726 6
d2733 9
a2741 5
      if (texImage->Data) {
	 ctx->Driver.FreeTexImageData( ctx, texImage );
      }
      
      ASSERT(texImage->Data == NULL);
d2743 3
a2745 3
      clear_teximage_fields(texImage); /* not really needed, but helpful */
      _mesa_init_teximage_fields(ctx, target, texImage, postConvWidth, 1, 1,
				 border, internalFormat);
d2747 1
d2749 1
a2749 3
      ASSERT(ctx->Driver.CopyTexImage1D);
      (*ctx->Driver.CopyTexImage1D)(ctx, target, level, internalFormat,
				    x, y, width, border);
d2751 1
a2751 1
      ASSERT(texImage->TexFormat);
d2753 1
a2753 1
      update_fbo_texture(ctx, texObj, face, level);
d2755 4
a2758 3
      /* state update */
      texObj->_Complete = GL_FALSE;
      ctx->NewState |= _NEW_TEXTURE;
a2759 1
 out:
a2769 1
   struct gl_texture_unit *texUnit;
d2777 6
d2797 1
a2797 2
   texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
   texObj = _mesa_select_tex_object(ctx, texUnit, target);
a2804 1
	 goto out;
d2806 25
a2830 6
      
      if (texImage->Data) {
	 ctx->Driver.FreeTexImageData( ctx, texImage );
      }
      
      ASSERT(texImage->Data == NULL);
d2832 1
a2832 10
      clear_teximage_fields(texImage); /* not really needed, but helpful */
      _mesa_init_teximage_fields(ctx, target, texImage,
				 postConvWidth, postConvHeight, 1,
				 border, internalFormat);
      
      ASSERT(ctx->Driver.CopyTexImage2D);
      (*ctx->Driver.CopyTexImage2D)(ctx, target, level, internalFormat,
				    x, y, width, height, border);
      
      ASSERT(texImage->TexFormat);
d2834 1
a2834 1
      update_fbo_texture(ctx, texObj, face, level);
d2836 4
a2839 3
      /* state update */
      texObj->_Complete = GL_FALSE;
      ctx->NewState |= _NEW_TEXTURE;
a2840 1
 out:
a2848 1
   struct gl_texture_unit *texUnit;
d2858 5
d2869 1
a2869 2
   texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
   texObj = _mesa_select_tex_object(ctx, texUnit, target);
d2883 2
a2884 12
				       texImage))
	 goto out;
      

      /* If we have a border, xoffset=-1 is legal.  Bias by border width */
      xoffset += texImage->Border;

      if (_mesa_clip_copytexsubimage(ctx, &xoffset, &yoffset, &x, &y,
                                     &width, &height)) {
         ASSERT(ctx->Driver.CopyTexSubImage1D);
         ctx->Driver.CopyTexSubImage1D(ctx, target, level,
                                       xoffset, x, y, width);
d2886 11
d2898 3
a2900 1
      ctx->NewState |= _NEW_TEXTURE;
a2901 1
 out:
a2911 1
   struct gl_texture_unit *texUnit;
d2918 5
d2929 1
a2929 2
   texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
   texObj = _mesa_select_tex_object(ctx, texUnit, target);
d2942 5
a2946 13
      if (copytexsubimage_error_check2(ctx, 2, target, level, xoffset, yoffset, 0,
				       postConvWidth, postConvHeight, texImage))
	 goto out;

      /* If we have a border, xoffset=-1 is legal.  Bias by border width */
      xoffset += texImage->Border;
      yoffset += texImage->Border;

      if (_mesa_clip_copytexsubimage(ctx, &xoffset, &yoffset, &x, &y,
                                     &width, &height)) {
         ASSERT(ctx->Driver.CopyTexSubImage2D);
         ctx->Driver.CopyTexSubImage2D(ctx, target, level,
				       xoffset, yoffset, x, y, width, height);
d2948 12
d2961 3
a2963 1
      ctx->NewState |= _NEW_TEXTURE;
a2964 1
 out:
a2974 1
   struct gl_texture_unit *texUnit;
d2981 5
d2992 1
a2992 2
   texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
   texObj = _mesa_select_tex_object(ctx, texUnit, target);
d3007 15
a3021 2
				       texImage))
	 goto out;
d3023 4
a3026 11
      /* If we have a border, xoffset=-1 is legal.  Bias by border width */
      xoffset += texImage->Border;
      yoffset += texImage->Border;
      zoffset += texImage->Border;
      
      if (_mesa_clip_copytexsubimage(ctx, &xoffset, &yoffset, &x, &y,
                                     &width, &height)) {
         ASSERT(ctx->Driver.CopyTexSubImage3D);
         ctx->Driver.CopyTexSubImage3D(ctx, target, level,
				       xoffset, yoffset, zoffset,
				       x, y, width, height);
a3027 2

      ctx->NewState |= _NEW_TEXTURE;
a3028 1
 out:
d3041 23
d3145 1
a3145 2
   expectedSize = _mesa_compressed_texture_size_glenum(ctx, width, height,
                                                       depth, internalFormat);
d3178 1
d3228 2
a3229 2
   /* XXX these tests are specific to the compressed format.
    * this code should be generalized in some way.
d3231 3
a3233 1
   if ((xoffset & 3) != 0 || (yoffset & 3) != 0)
d3236 1
a3236 1
   if ((width & 3) != 0 && width != 2 && width != 1)
d3239 1
a3239 1
   if ((height & 3) != 0 && height != 2 && height != 1)
d3242 1
a3242 2
   expectedSize = _mesa_compressed_texture_size_glenum(ctx, width, height,
                                                       depth, format);
d3250 49
d3309 6
a3316 1
      struct gl_texture_unit *texUnit;
d3326 1
a3326 2
      texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
      texObj = _mesa_select_tex_object(ctx, texUnit, target);
a3332 1
	    goto out;
d3334 5
a3338 5
	 
	 if (texImage->Data) {
	    ctx->Driver.FreeTexImageData( ctx, texImage );
	 }
	 ASSERT(texImage->Data == NULL);
d3340 2
a3341 2
	 _mesa_init_teximage_fields(ctx, target, texImage, width, 1, 1,
				    border, internalFormat);
d3343 20
a3362 9
	 ASSERT(ctx->Driver.CompressedTexImage1D);
	 (*ctx->Driver.CompressedTexImage1D)(ctx, target, level,
					     internalFormat, width, border,
					     imageSize, data,
					     texObj, texImage);

	 /* state update */
	 texObj->_Complete = GL_FALSE;
	 ctx->NewState |= _NEW_TEXTURE;
a3363 1
   out:
a3384 1
         struct gl_texture_unit *texUnit;
d3387 2
a3388 2
         texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
	 texObj = _mesa_select_tex_object(ctx, texUnit, target);
d3415 6
a3425 1
      struct gl_texture_unit *texUnit;
d3428 1
d3436 1
a3436 2
      texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
      texObj = _mesa_select_tex_object(ctx, texUnit, target);
a3442 1
	    goto out;
d3444 5
a3448 5
	 
	 if (texImage->Data) {
	    ctx->Driver.FreeTexImageData( ctx, texImage );
	 }
	 ASSERT(texImage->Data == NULL);
d3450 2
a3451 2
	 _mesa_init_teximage_fields(ctx, target, texImage, width, height, 1,
				    border, internalFormat);
d3453 20
a3472 9
	 ASSERT(ctx->Driver.CompressedTexImage2D);
	 (*ctx->Driver.CompressedTexImage2D)(ctx, target, level,
					     internalFormat, width, height,
					     border, imageSize, data,
					     texObj, texImage);
	 
	 /* state update */
	 texObj->_Complete = GL_FALSE;
	 ctx->NewState |= _NEW_TEXTURE;
a3473 1
   out:
a3496 1
         struct gl_texture_unit *texUnit;
d3499 2
a3500 2
         texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
	 texObj = _mesa_select_tex_object(ctx, texUnit, target);
d3527 6
a3534 1
      struct gl_texture_unit *texUnit;
d3544 2
a3545 2
      texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
      texObj = _mesa_select_tex_object(ctx, texUnit, target);
a3550 1
	    goto out;
d3552 5
a3556 5
	 
	 if (texImage->Data) {
	    ctx->Driver.FreeTexImageData( ctx, texImage );
	 }
	 ASSERT(texImage->Data == NULL);
d3558 25
a3582 13
	 _mesa_init_teximage_fields(ctx, target, texImage, width, height, depth,
				    border, internalFormat);

	 ASSERT(ctx->Driver.CompressedTexImage3D);
	 (*ctx->Driver.CompressedTexImage3D)(ctx, target, level,
					     internalFormat,
					     width, height, depth,
					     border, imageSize, data,
					     texObj, texImage);
	 
	 /* state update */
	 texObj->_Complete = GL_FALSE;
	 ctx->NewState |= _NEW_TEXTURE;
a3583 1
   out:
a3604 1
         struct gl_texture_unit *texUnit;
d3607 3
a3609 2
         texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
	 texObj = _mesa_select_tex_object(ctx, texUnit, target);
d3626 8
a3633 4
void GLAPIENTRY
_mesa_CompressedTexSubImage1DARB(GLenum target, GLint level, GLint xoffset,
                                 GLsizei width, GLenum format,
                                 GLsizei imageSize, const GLvoid *data)
a3634 1
   struct gl_texture_unit *texUnit;
d3641 1
a3641 1
   error = compressed_subtexture_error_check(ctx, 1, target, level,
d3643 1
a3643 1
                                             width, 1, 1,   /* size */
d3646 1
a3646 1
      _mesa_error(ctx, error, "glCompressedTexSubImage1D");
d3650 2
a3651 2
   texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
   texObj = _mesa_select_tex_object(ctx, texUnit, target);
d3657 39
a3695 19
      if ((GLint) format != texImage->InternalFormat) {
	 _mesa_error(ctx, GL_INVALID_OPERATION,
		     "glCompressedTexSubImage1D(format)");
	 goto out;
      }

      if ((width == 1 || width == 2) && (GLuint) width != texImage->Width) {
	 _mesa_error(ctx, GL_INVALID_VALUE, "glCompressedTexSubImage1D(width)");
	 goto out;
      }
      
      if (width == 0)
	 goto out;  /* no-op, not an error */

      if (ctx->Driver.CompressedTexSubImage1D) {
	 (*ctx->Driver.CompressedTexSubImage1D)(ctx, target, level,
						xoffset, width,
						format, imageSize, data,
						texObj, texImage);
a3696 1
      ctx->NewState |= _NEW_TEXTURE;
a3697 1
 out:
d3703 10
d3718 2
a3719 49
   struct gl_texture_unit *texUnit;
   struct gl_texture_object *texObj;
   struct gl_texture_image *texImage;
   GLenum error;
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

   error = compressed_subtexture_error_check(ctx, 2, target, level,
                                             xoffset, yoffset, 0, /* pos */
                                             width, height, 1,    /* size */
                                             format, imageSize);
   if (error) {
      /* XXX proxy target? */
      _mesa_error(ctx, error, "glCompressedTexSubImage2D");
      return;
   }

   texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
   texObj = _mesa_select_tex_object(ctx, texUnit, target);
   _mesa_lock_texture(ctx, texObj);
   {
      texImage = _mesa_select_tex_image(ctx, texObj, target, level);
      assert(texImage);

      if ((GLint) format != texImage->InternalFormat) {
	 _mesa_error(ctx, GL_INVALID_OPERATION,
		     "glCompressedTexSubImage2D(format)");
	 goto out;
      }

      if (((width == 1 || width == 2) && (GLuint) width != texImage->Width) ||
	  ((height == 1 || height == 2) && (GLuint) height != texImage->Height)) {
	 _mesa_error(ctx, GL_INVALID_VALUE, "glCompressedTexSubImage2D(size)");
	 goto out;
      }
      
      if (width == 0 || height == 0)
	 goto out;  /* no-op, not an error */

      if (ctx->Driver.CompressedTexSubImage2D) {
	 (*ctx->Driver.CompressedTexSubImage2D)(ctx, target, level,
						xoffset, yoffset, width, height,
						format, imageSize, data,
						texObj, texImage);
      }
      ctx->NewState |= _NEW_TEXTURE;
   }
 out:
   _mesa_unlock_texture(ctx, texObj);
d3729 2
a3730 50
   struct gl_texture_unit *texUnit;
   struct gl_texture_object *texObj;
   struct gl_texture_image *texImage;
   GLenum error;
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

   error = compressed_subtexture_error_check(ctx, 3, target, level,
                                             xoffset, yoffset, zoffset,/*pos*/
                                             width, height, depth, /*size*/
                                             format, imageSize);
   if (error) {
      _mesa_error(ctx, error, "glCompressedTexSubImage3D");
      return;
   }

   texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
   texObj = _mesa_select_tex_object(ctx, texUnit, target);
   _mesa_lock_texture(ctx, texObj);
   {
      texImage = _mesa_select_tex_image(ctx, texObj, target, level);
      assert(texImage);

      if ((GLint) format != texImage->InternalFormat) {
	 _mesa_error(ctx, GL_INVALID_OPERATION,
		     "glCompressedTexSubImage3D(format)");
	 goto out;
      }

      if (((width == 1 || width == 2) && (GLuint) width != texImage->Width) ||
	  ((height == 1 || height == 2) && (GLuint) height != texImage->Height) ||
	  ((depth == 1 || depth == 2) && (GLuint) depth != texImage->Depth)) {
	 _mesa_error(ctx, GL_INVALID_VALUE, "glCompressedTexSubImage3D(size)");
	 goto out;
      }
      
      if (width == 0 || height == 0 || depth == 0)
	 goto out;  /* no-op, not an error */

      if (ctx->Driver.CompressedTexSubImage3D) {
	 (*ctx->Driver.CompressedTexSubImage3D)(ctx, target, level,
						xoffset, yoffset, zoffset,
						width, height, depth,
						format, imageSize, data,
						texObj, texImage);
      }
      ctx->NewState |= _NEW_TEXTURE;
   }
 out:
   _mesa_unlock_texture(ctx, texObj);
a3733 52
void GLAPIENTRY
_mesa_GetCompressedTexImageARB(GLenum target, GLint level, GLvoid *img)
{
   const struct gl_texture_unit *texUnit;
   struct gl_texture_object *texObj;
   struct gl_texture_image *texImage;
   GLint maxLevels;
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

   texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
   texObj = _mesa_select_tex_object(ctx, texUnit, target);
   if (!texObj) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetCompressedTexImageARB");
      return;
   }

   maxLevels = _mesa_max_texture_levels(ctx, target);
   ASSERT(maxLevels > 0); /* 0 indicates bad target, caught above */

   if (level < 0 || level >= maxLevels) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glGetCompressedTexImageARB(level)");
      return;
   }

   if (_mesa_is_proxy_texture(target)) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetCompressedTexImageARB(target)");
      return;
   }

   _mesa_lock_texture(ctx, texObj);
   {
      texImage = _mesa_select_tex_image(ctx, texObj, target, level);
      if (texImage) {
         if (texImage->IsCompressed) {
            /* this typically calls _mesa_get_compressed_teximage() */
            ctx->Driver.GetCompressedTexImage(ctx, target, level, img,
                                              texObj, texImage);
         }
         else {
            _mesa_error(ctx, GL_INVALID_OPERATION,
                        "glGetCompressedTexImageARB");
         }
      }
      else {
         /* probably invalid mipmap level */
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glGetCompressedTexImageARB(level)");
      }
   }
   _mesa_unlock_texture(ctx, texObj);
}
@


1.3
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d2 1
a2 1
 * Mesa 3-D graphics library
d35 1
d37 1
d53 11
d255 1
a255 2
   if (ctx->Extensions.SGIX_depth_texture ||
       ctx->Extensions.ARB_depth_texture) {
d258 3
a260 3
         case GL_DEPTH_COMPONENT16_SGIX:
         case GL_DEPTH_COMPONENT24_SGIX:
         case GL_DEPTH_COMPONENT32_SGIX:
d402 1
d404 2
a405 2
static GLboolean
is_color_format(GLenum format)
d506 1
d541 3
a543 3
      case GL_DEPTH_COMPONENT16_ARB:
      case GL_DEPTH_COMPONENT24_ARB:
      case GL_DEPTH_COMPONENT32_ARB:
d612 6
a617 2
static GLuint
texture_face(GLenum target)
d646 1
d780 1
a780 1
         return texUnit->Current1D;
d784 1
a784 1
         return texUnit->Current2D;
d788 1
a788 1
         return texUnit->Current3D;
d799 1
a799 1
                ? texUnit->CurrentCubeMap : NULL;
d805 1
a805 1
                ? texUnit->CurrentRect : NULL;
d811 1
a811 1
                ? texUnit->Current1DArray : NULL;
d817 1
a817 1
                ? texUnit->Current2DArray : NULL;
d850 1
d1247 3
a1249 3
   if ((width == 1 || _mesa_bitcount(img->Width2) == 1) &&
       (height == 1 || _mesa_bitcount(img->Height2) == 1) &&
       (depth == 1 || _mesa_bitcount(img->Depth2) == 1))
d1320 1
a1320 1
           width >0 && _mesa_bitcount(width - 2 * border) != 1) ||
d1330 1
a1330 1
           width > 0 && _mesa_bitcount(width - 2 * border) != 1) ||
d1333 1
a1333 1
           height > 0 && _mesa_bitcount(height - 2 * border) != 1) ||
d1343 1
a1343 1
           width > 0 && _mesa_bitcount(width - 2 * border) != 1) ||
d1346 1
a1346 1
           height > 0 && _mesa_bitcount(height - 2 * border) != 1) ||
d1349 1
a1349 1
           depth > 0 && _mesa_bitcount(depth - 2 * border) != 1) ||
d1367 1
a1367 1
           width > 0 && _mesa_bitcount(width - 2 * border) != 1) ||
d1370 1
a1370 1
           height > 0 && _mesa_bitcount(height - 2 * border) != 1) ||
d1380 1
a1380 1
           width > 0 && _mesa_bitcount(width - 2 * border) != 1) ||
d1394 1
a1394 1
           width > 0 && _mesa_bitcount(width - 2 * border) != 1) ||
d1397 1
a1397 1
           height > 0 && _mesa_bitcount(height - 2 * border) != 1) ||
d1592 1
a1592 1
   colorFormat = is_color_format(format);
d1594 1
a1594 1
   if ((is_color_format(internalFormat) && !colorFormat && !indexFormat) ||
d2056 2
a2062 5
 * \param xoffset sub-image x offset given by the user.
 * \param yoffset sub-image y offset given by the user.
 * \param zoffset sub-image z offset given by the user.
 * \param width image width given by the user.
 * \param height image height given by the user.
a2064 4
 * 
 * Verifies each of the parameters against the constants specified in
 * __GLcontextRec::Const and the supported extensions, and according to the
 * OpenGL specification.
d2067 2
a2068 4
copytexsubimage_error_check( GLcontext *ctx, GLuint dimensions,
                             GLenum target, GLint level,
                             GLint xoffset, GLint yoffset, GLint zoffset,
                             GLsizei width, GLsizei height)
a2069 1
   /* Check target */
d2080 1
a2127 12
   /* Check size */
   if (width < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glCopyTexSubImage%dD(width=%d)", dimensions, width);
      return GL_TRUE;
   }
   if (dimensions > 1 && height < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glCopyTexSubImage%dD(height=%d)", dimensions, height);
      return GL_TRUE;
   }

d2131 9
d2147 1
d2155 13
d2192 1
d2238 2
a2239 1
               "glCopyTexSubImage%dD(missing readbuffer)", dimensions);
d2316 1
a2316 2
   if (!ctx->Extensions.SGIX_depth_texture &&
       !ctx->Extensions.ARB_depth_texture && is_depth_format(format)) {
d2345 2
a2346 2
      if (is_color_format(format)
	  && !is_color_format(texImage->TexFormat->BaseFormat)
d2438 2
a2439 1
   if (is_color_format(internalFormat)) {
d2442 1
d2449 1
a2449 1
      const GLuint face = texture_face(target);
d2535 2
a2536 1
   if (is_color_format(internalFormat)) {
d2540 1
d2554 1
a2554 1
      const GLuint face = texture_face(target);
d2618 1
a2618 1
            clear_teximage_fields(ctx->Texture.ProxyTex[TEXTURE_2D_INDEX]->Image[0][level]);
d2656 1
a2656 1
      const GLuint face = texture_face(target);
d2759 1
d2761 1
a2761 1
   if (is_color_format(format)) {
d2764 1
d2819 1
d2821 1
a2821 1
   if (is_color_format(format)) {
d2825 1
d2928 1
a2928 1
   const GLuint face = texture_face(target);
d2932 1
a2932 1
   if (ctx->NewState & _IMAGE_NEW_TRANSFER_STATE)
d2935 2
a2936 1
   if (is_color_format(internalFormat)) {
d2939 1
d2993 1
a2993 1
   const GLuint face = texture_face(target);
d2997 1
a2997 1
   if (ctx->NewState & _IMAGE_NEW_TRANSFER_STATE)
d3000 2
a3001 1
   if (is_color_format(internalFormat)) {
d3005 1
d3059 3
d3065 1
a3065 1
   if (ctx->NewState & _IMAGE_NEW_TRANSFER_STATE)
d3068 1
a3068 5
   /* XXX should test internal format */
   _mesa_adjust_image_for_convolution(ctx, 1, &postConvWidth, NULL);

   if (copytexsubimage_error_check(ctx, 1, target, level,
                                   xoffset, 0, 0, postConvWidth, 1))
d3078 6
d3093 7
a3099 2
      ASSERT(ctx->Driver.CopyTexSubImage1D);
      (*ctx->Driver.CopyTexSubImage1D)(ctx, target, level, xoffset, x, y, width);
d3120 1
a3120 1
   if (ctx->NewState & _IMAGE_NEW_TRANSFER_STATE)
d3123 1
a3123 5
   /* XXX should test internal format */
   _mesa_adjust_image_for_convolution(ctx, 2, &postConvWidth, &postConvHeight);

   if (copytexsubimage_error_check(ctx, 2, target, level, xoffset, yoffset, 0,
                                   postConvWidth, postConvHeight))
d3133 7
d3147 5
a3151 3
      
      ASSERT(ctx->Driver.CopyTexSubImage2D);
      (*ctx->Driver.CopyTexSubImage2D)(ctx, target, level,
d3153 2
d3175 1
a3175 1
   if (ctx->NewState & _IMAGE_NEW_TRANSFER_STATE)
d3178 1
a3178 5
   /* XXX should test internal format */
   _mesa_adjust_image_for_convolution(ctx, 2, &postConvWidth, &postConvHeight);

   if (copytexsubimage_error_check(ctx, 3, target, level, xoffset, yoffset,
                                   zoffset, postConvWidth, postConvHeight))
d3188 7
d3205 4
a3208 2
      ASSERT(ctx->Driver.CopyTexSubImage3D);
      (*ctx->Driver.CopyTexSubImage3D)(ctx, target, level,
d3211 2
d3288 1
a3288 1
       (!ctx->Extensions.ARB_texture_non_power_of_two && _mesa_bitcount(width) != 1))
d3292 1
a3292 1
       (!ctx->Extensions.ARB_texture_non_power_of_two && _mesa_bitcount(height) != 1))
d3297 1
a3297 1
       (!ctx->Extensions.ARB_texture_non_power_of_two && _mesa_bitcount(depth) != 1))
@


1.2
log
@Update to Mesa 7.0.3. tested my oga@@ and johan@@
@
text
@d3 1
a3 1
 * Version:  7.0.3
d632 2
d738 3
a740 1
           target == GL_PROXY_TEXTURE_RECTANGLE_NV);
d763 1
a763 1
         return ctx->Texture.Proxy1D;
d767 1
a767 1
         return ctx->Texture.Proxy2D;
d771 1
a771 1
         return ctx->Texture.Proxy3D;
d783 1
a783 1
                ? ctx->Texture.ProxyCubeMap : NULL;
d789 13
a801 1
                ? ctx->Texture.ProxyRect : NULL;
d867 7
d927 1
a927 1
      texImage = ctx->Texture.Proxy1D->Image[0][level];
d934 1
a934 1
         ctx->Texture.Proxy1D->Image[0][level] = texImage;
d936 1
a936 1
         texImage->TexObject = ctx->Texture.Proxy1D;
d942 1
a942 1
      texImage = ctx->Texture.Proxy2D->Image[0][level];
d949 1
a949 1
         ctx->Texture.Proxy2D->Image[0][level] = texImage;
d951 1
a951 1
         texImage->TexObject = ctx->Texture.Proxy2D;
d957 1
a957 1
      texImage = ctx->Texture.Proxy3D->Image[0][level];
d964 1
a964 1
         ctx->Texture.Proxy3D->Image[0][level] = texImage;
d966 1
a966 1
         texImage->TexObject = ctx->Texture.Proxy3D;
d972 1
a972 1
      texImage = ctx->Texture.ProxyCubeMap->Image[0][level];
d979 1
a979 1
         ctx->Texture.ProxyCubeMap->Image[0][level] = texImage;
d981 1
a981 1
         texImage->TexObject = ctx->Texture.ProxyCubeMap;
d987 16
a1002 1
      texImage = ctx->Texture.ProxyRect->Image[0][level];
d1009 1
a1009 1
         ctx->Texture.ProxyRect->Image[0][level] = texImage;
d1011 16
a1026 1
         texImage->TexObject = ctx->Texture.ProxyRect;
d1054 4
d1300 1
a1300 1
           width > 0 && _mesa_bitcount(width - 2 * border) != 1) ||
d1356 30
d1403 4
a1406 1
                  target <= GL_TEXTURE_CUBE_MAP_NEGATIVE_Z)))));
d1509 4
d1522 4
d1703 6
d1715 7
a1721 1
      if (target != GL_TEXTURE_3D) {
d1966 11
d2001 1
a2001 1
      if (target != GL_TEXTURE_2D) {
d2090 6
d2102 5
a2106 3
      if (target != GL_TEXTURE_3D) {
         _mesa_error( ctx, GL_INVALID_ENUM, "glCopyTexSubImage3D(target)" );
         return GL_TRUE;
d2184 1
a2184 1
      if (target != GL_TEXTURE_2D) {
d2467 1
a2467 1
	 texObj->Complete = GL_FALSE;
d2520 3
a2522 1
        target == GL_TEXTURE_RECTANGLE_NV)) {
d2570 1
a2570 1
	 texObj->Complete = GL_FALSE;
d2580 3
a2582 1
             ctx->Extensions.NV_texture_rectangle)) {
d2591 1
a2591 1
            clear_teximage_fields(ctx->Texture.Proxy2D->Image[0][level]);
d2622 3
a2624 1
   if (target == GL_TEXTURE_3D) {
d2671 1
a2671 1
	 texObj->Complete = GL_FALSE;
d2677 3
a2679 1
   else if (target == GL_PROXY_TEXTURE_3D) {
d2942 1
a2942 1
      texObj->Complete = GL_FALSE;
d3008 1
a3008 1
      texObj->Complete = GL_FALSE;
d3402 1
a3402 1
	 texObj->Complete = GL_FALSE;
d3499 1
a3499 1
	 texObj->Complete = GL_FALSE;
d3595 1
a3595 1
	 texObj->Complete = GL_FALSE;
d3772 1
a3772 1
      _mesa_error(ctx, error, "glCompressedTexSubImage2D");
a3822 1

a3842 1

d3846 10
a3855 4
      if (!texImage) {
	 /* probably invalid mipmap level */
	 _mesa_error(ctx, GL_INVALID_VALUE, "glGetCompressedTexImageARB(level)");
	 goto out;
d3857 4
a3860 4

      if (!texImage->IsCompressed) {
	 _mesa_error(ctx, GL_INVALID_OPERATION, "glGetCompressedTexImageARB");
	 goto out;
a3861 3

      /* this typically calls _mesa_get_compressed_teximage() */
      ctx->Driver.GetCompressedTexImage(ctx, target, level, img, texObj,texImage);
a3862 1
 out:
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * Version:  6.5.1
d5 1
a5 1
 * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
d76 2
a77 2
#if CHAN_TYPE == GL_FLOAT
   _mesa_problem(NULL, "PrintTexture doesn't support float channels");
d80 1
a80 1
   const GLchan *data = (const GLchan *) img->Data;
d709 6
a714 3
   if (texImage->Data) {
      ctx->Driver.FreeTexImageData( ctx, texImage );
   }
d807 2
a808 2
_mesa_select_tex_image(GLcontext *ctx, const struct gl_texture_unit *texUnit,
                       GLenum target, GLint level)
d810 5
a814 2
   ASSERT(texUnit);
   ASSERT(level < MAX_TEXTURE_LEVELS);
a816 1
         return texUnit->Current1D->Image[0][level];
a817 1
         return ctx->Texture.Proxy1D->Image[0][level];
a818 1
         return texUnit->Current2D->Image[0][level];
a819 1
         return ctx->Texture.Proxy2D->Image[0][level];
a820 1
         return texUnit->Current3D->Image[0][level];
d822 2
a823 1
         return ctx->Texture.Proxy3D->Image[0][level];
d833 1
a833 1
            return texUnit->CurrentCubeMap->Image[face][level];
d837 1
d840 1
a840 1
            return ctx->Texture.ProxyCubeMap->Image[0][level];
d843 1
a844 7
         if (ctx->Extensions.NV_texture_rectangle) {
            ASSERT(level == 0);
            return texUnit->CurrentRect->Image[0][level];
         }
         else {
            return NULL;
         }
d846 3
a848 5
         if (ctx->Extensions.NV_texture_rectangle) {
            ASSERT(level == 0);
            return ctx->Texture.ProxyRect->Image[0][level];
         }
         else {
d850 1
a850 1
         }
a851 1
         _mesa_problem(ctx, "bad target in _mesa_select_tex_image()");
d863 1
a863 1
_mesa_get_tex_image(GLcontext *ctx, const struct gl_texture_unit *texUnit,
d867 5
a871 1
   texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
a872 1
      struct gl_texture_object *texObj;
d878 1
a878 2
      texObj = _mesa_select_tex_object(ctx, texUnit, target);
      ASSERT(texObj);
d881 1
d1210 4
d1243 1
a1243 1
           _mesa_bitcount(width - 2 * border) != 1) ||
d1253 1
a1253 1
           _mesa_bitcount(width - 2 * border) != 1) ||
d1256 1
a1256 1
           _mesa_bitcount(height - 2 * border) != 1) ||
d1266 1
a1266 1
           _mesa_bitcount(width - 2 * border) != 1) ||
d1269 1
a1269 1
           _mesa_bitcount(height - 2 * border) != 1) ||
d1272 1
a1272 1
           _mesa_bitcount(depth - 2 * border) != 1) ||
d1279 2
a1280 2
      if (width < 1 || width > ctx->Const.MaxTextureRectSize ||
          height < 1 || height > ctx->Const.MaxTextureRectSize ||
d1290 1
a1290 1
           _mesa_bitcount(width - 2 * border) != 1) ||
d1293 1
a1293 1
           _mesa_bitcount(height - 2 * border) != 1) ||
d1307 14
d1350 1
a1350 1
   GLboolean sizeOK;
d1352 1
d1387 3
a1389 4
         sizeOK = ctx->Driver.TestProxyTexImage(ctx, GL_PROXY_TEXTURE_1D,
                                                level, internalFormat,
                                                format, type,
                                                width, 1, 1, border);
d1397 1
d1399 1
a1399 4
         sizeOK = ctx->Driver.TestProxyTexImage(ctx, GL_PROXY_TEXTURE_2D,
                                                level, internalFormat,
                                                format, type,
                                                width, height, 1, border);
d1408 2
a1409 4
         sizeOK = (width == height) &&
            ctx->Driver.TestProxyTexImage(ctx, GL_PROXY_TEXTURE_CUBE_MAP_ARB,
                                          level, internalFormat, format, type,
                                          width, height, 1, border);
d1417 1
a1417 5
         sizeOK = ctx->Driver.TestProxyTexImage(ctx,
                                                GL_PROXY_TEXTURE_RECTANGLE_NV,
                                                level, internalFormat,
                                                format, type,
                                                width, height, 1, border);
d1426 1
a1426 4
         sizeOK = ctx->Driver.TestProxyTexImage(ctx, GL_PROXY_TEXTURE_3D,
                                                level, internalFormat,
                                                format, type,
                                                width, height, depth, border);
d1438 4
d1536 4
a1539 15
      if (target == GL_TEXTURE_2D || target == GL_PROXY_TEXTURE_2D) {
         /* OK */
      }
      else if (ctx->Extensions.ARB_texture_cube_map &&
               (target == GL_PROXY_TEXTURE_CUBE_MAP ||
                (target >= GL_TEXTURE_CUBE_MAP_POSITIVE_X &&
                 target <= GL_TEXTURE_CUBE_MAP_NEGATIVE_Z))) {
         /* OK */
      }
      else {
         if (!isProxy) {
            _mesa_error(ctx, GL_INVALID_ENUM,
                        "glTexImage%d(target)", dimensions);
            return GL_TRUE;
         }
a1583 3
   struct gl_texture_unit *texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
   struct gl_texture_image *destTex;

d1593 1
a1593 1
          target <=GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB) {
d1599 1
a1599 2
      else if (ctx->Extensions.NV_texture_rectangle &&
               target == GL_TEXTURE_RECTANGLE_NV) {
d1643 8
a1650 1
   destTex = _mesa_select_tex_image(ctx, texUnit, target, level);
d1652 8
a1698 6
   if (!_mesa_is_legal_format_and_type(ctx, format, type)) {
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "glTexSubImage%dD(format or type)", dimensions);
      return GL_TRUE;
   }

d1714 1
a1714 15
      const struct gl_texture_unit *texUnit;
      const struct gl_texture_image *texImage;
      texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
      texImage = _mesa_select_tex_image(ctx, texUnit, target, level);

      if (target == GL_TEXTURE_2D || target == GL_PROXY_TEXTURE_2D) {
         /* OK */
      }
      else if (ctx->Extensions.ARB_texture_cube_map &&
               (target == GL_PROXY_TEXTURE_CUBE_MAP ||
                (target >= GL_TEXTURE_CUBE_MAP_POSITIVE_X &&
                 target <= GL_TEXTURE_CUBE_MAP_NEGATIVE_Z))) {
         /* OK */
      }
      else {
d1726 1
a1726 1
      if ((width & 3) && (GLuint) width != texImage->Width) {
d1731 1
a1731 1
      if ((height & 3) && (GLuint) height != texImage->Height) {
d1772 5
a1786 5
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glCopyTexImage%dD(level=%d)", dimensions, level);
      return GL_TRUE;
   }

d1936 1
a1936 1
                             GLsizei width, GLsizei height )
a1937 3
   struct gl_texture_unit *texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
   struct gl_texture_image *teximage;

d2000 10
a2009 1
   teximage = _mesa_select_tex_image(ctx, texUnit, target, level);
a2054 6
      if (!_mesa_source_buffer_exists(ctx, teximage->_BaseFormat)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glCopyTexSubImage%dD(missing readbuffer)", dimensions);
         return GL_TRUE;
      }

d2084 6
d2180 8
a2187 2
   if (!pixels)
      return;
d2189 43
a2231 5
   texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
   if (!texImage) {
      /* invalid mipmap level, not an error */
      return;
   }
d2233 3
a2235 31
   /* Make sure the requested image format is compatible with the
    * texture's format.  Note that a color index texture can be converted
    * to RGBA so that combo is allowed.
    */
   if (is_color_format(format)
       && !is_color_format(texImage->TexFormat->BaseFormat)
       && !is_index_format(texImage->TexFormat->BaseFormat)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glGetTexImage(format mismatch)");
      return;
   }
   else if (is_index_format(format)
       && !is_index_format(texImage->TexFormat->BaseFormat)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glGetTexImage(format mismatch)");
      return;
   }
   else if (is_depth_format(format)
       && !is_depth_format(texImage->TexFormat->BaseFormat)
       && !is_depthstencil_format(texImage->TexFormat->BaseFormat)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glGetTexImage(format mismatch)");
      return;
   }
   else if (is_ycbcr_format(format)
       && !is_ycbcr_format(texImage->TexFormat->BaseFormat)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glGetTexImage(format mismatch)");
      return;
   }
   else if (is_depthstencil_format(format)
       && !is_depthstencil_format(texImage->TexFormat->BaseFormat)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glGetTexImage(format mismatch)");
      return;
   }
a2236 10
   if (ctx->Pack.BufferObj->Name) {
      /* packing texture image into a PBO */
      const GLuint dimensions = (target == GL_TEXTURE_3D) ? 3 : 2;
      if (!_mesa_validate_pbo_access(dimensions, &ctx->Pack, texImage->Width,
                                     texImage->Height, texImage->Depth,
                                     format, type, pixels)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glGetTexImage(invalid PBO access)");
         return;
      }
d2238 2
a2239 4

   /* typically, this will call _mesa_get_teximage() */
   ctx->Driver.GetTexImage(ctx, target, level, format, type, pixels,
                           texObj, texImage);
d2302 3
d2307 13
a2319 1
      texImage = _mesa_get_tex_image(ctx, texUnit, target, level);
d2321 19
a2339 6
      if (!texImage) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glTexImage1D");
         return;
      }
      else if (texImage->Data) {
	 ctx->Driver.FreeTexImageData( ctx, texImage );
d2341 2
a2342 23
      ASSERT(texImage->Data == NULL);
      clear_teximage_fields(texImage); /* not really needed, but helpful */
      _mesa_init_teximage_fields(ctx, target, texImage,
                                 postConvWidth, 1, 1,
                                 border, internalFormat);

      if (ctx->NewState & _IMAGE_NEW_TRANSFER_STATE)
         _mesa_update_state(ctx);

      ASSERT(ctx->Driver.TexImage1D);

      /* Give the texture to the driver!  <pixels> may be null! */
      (*ctx->Driver.TexImage1D)(ctx, target, level, internalFormat,
                                width, border, format, type, pixels,
                                &ctx->Unpack, texObj, texImage);

      ASSERT(texImage->TexFormat);

      update_fbo_texture(ctx, texObj, face, level);

      /* state update */
      texObj->Complete = GL_FALSE;
      ctx->NewState |= _NEW_TEXTURE;
d2404 3
d2409 32
a2440 7
      texImage = _mesa_get_tex_image(ctx, texUnit, target, level);
      if (!texImage) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glTexImage2D");
         return;
      }
      else if (texImage->Data) {
	 ctx->Driver.FreeTexImageData( ctx, texImage );
d2442 2
a2443 23
      ASSERT(texImage->Data == NULL);
      clear_teximage_fields(texImage); /* not really needed, but helpful */
      _mesa_init_teximage_fields(ctx, target, texImage,
                                 postConvWidth, postConvHeight, 1,
                                 border, internalFormat);

      if (ctx->NewState & _IMAGE_NEW_TRANSFER_STATE)
         _mesa_update_state(ctx);

      ASSERT(ctx->Driver.TexImage2D);

      /* Give the texture to the driver!  <pixels> may be null! */
      (*ctx->Driver.TexImage2D)(ctx, target, level, internalFormat,
                                width, height, border, format, type, pixels,
                                &ctx->Unpack, texObj, texImage);

      ASSERT(texImage->TexFormat);

      update_fbo_texture(ctx, texObj, face, level);

      /* state update */
      texObj->Complete = GL_FALSE;
      ctx->NewState |= _NEW_TEXTURE;
d2501 3
d2506 32
a2537 7
      texImage = _mesa_get_tex_image(ctx, texUnit, target, level);
      if (!texImage) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glTexImage3D");
         return;
      }
      else if (texImage->Data) {
	 ctx->Driver.FreeTexImageData( ctx, texImage );
d2539 2
a2540 23
      ASSERT(texImage->Data == NULL);
      clear_teximage_fields(texImage); /* not really needed, but helpful */
      _mesa_init_teximage_fields(ctx, target, texImage,
                                 width, height, depth,
                                 border, internalFormat);

      if (ctx->NewState & _IMAGE_NEW_TRANSFER_STATE)
         _mesa_update_state(ctx);

      ASSERT(ctx->Driver.TexImage3D);

      /* Give the texture to the driver!  <pixels> may be null! */
      (*ctx->Driver.TexImage3D)(ctx, target, level, internalFormat,
                                width, height, depth, border, format, type,
                                pixels, &ctx->Unpack, texObj, texImage);

      ASSERT(texImage->TexFormat);

      update_fbo_texture(ctx, texObj, face, level);

      /* state update */
      texObj->Complete = GL_FALSE;
      ctx->NewState |= _NEW_TEXTURE;
d2554 2
a2555 2
         _mesa_init_teximage_fields(ctx, target, texImage, width, height, 1,
                                    border, internalFormat);
d2588 1
a2588 1
   struct gl_texture_image *texImage;
d2601 1
a2601 1
                              postConvWidth, 1, 1, format, type)) {
d2605 1
d2608 5
a2612 2
   texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
   assert(texImage);
d2614 7
a2620 2
   if (width == 0)
      return;  /* no-op, not an error */
d2622 2
a2623 2
   /* If we have a border, xoffset=-1 is legal.  Bias by border width */
   xoffset += texImage->Border;
d2625 8
a2632 5
   ASSERT(ctx->Driver.TexSubImage1D);
   (*ctx->Driver.TexSubImage1D)(ctx, target, level, xoffset, width,
                                format, type, pixels, &ctx->Unpack,
                                texObj, texImage);
   ctx->NewState |= _NEW_TEXTURE;
d2660 1
a2660 1
                             postConvWidth, postConvHeight, 1, format, type)) {
d2666 25
a2690 15
   texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
   assert(texImage);

   if (width == 0 || height == 0)
      return;  /* no-op, not an error */

   /* If we have a border, xoffset=-1 is legal.  Bias by border width */
   xoffset += texImage->Border;
   yoffset += texImage->Border;

   ASSERT(ctx->Driver.TexSubImage2D);
   (*ctx->Driver.TexSubImage2D)(ctx, target, level, xoffset, yoffset,
                                width, height, format, type, pixels,
                                &ctx->Unpack, texObj, texImage);
   ctx->NewState |= _NEW_TEXTURE;
a2717 2
   texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
   assert(texImage);
d2719 27
a2745 15
   if (width == 0 || height == 0 || height == 0)
      return;  /* no-op, not an error */

   /* If we have a border, xoffset=-1 is legal.  Bias by border width */
   xoffset += texImage->Border;
   yoffset += texImage->Border;
   zoffset += texImage->Border;

   ASSERT(ctx->Driver.TexSubImage3D);
   (*ctx->Driver.TexSubImage3D)(ctx, target, level,
                                xoffset, yoffset, zoffset,
                                width, height, depth,
                                format, type, pixels,
                                &ctx->Unpack, texObj, texImage );
   ctx->NewState |= _NEW_TEXTURE;
d2777 13
a2789 9
   texImage = _mesa_get_tex_image(ctx, texUnit, target, level);
   if (!texImage) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCopyTexImage1D");
      return;
   }
   else if (texImage->Data) {
      ctx->Driver.FreeTexImageData( ctx, texImage );
   }
   ASSERT(texImage->Data == NULL);
d2791 3
a2793 3
   clear_teximage_fields(texImage); /* not really needed, but helpful */
   _mesa_init_teximage_fields(ctx, target, texImage, postConvWidth, 1, 1,
                              border, internalFormat);
d2796 3
a2798 3
   ASSERT(ctx->Driver.CopyTexImage1D);
   (*ctx->Driver.CopyTexImage1D)(ctx, target, level, internalFormat,
                                 x, y, width, border);
d2800 1
a2800 1
   ASSERT(texImage->TexFormat);
d2802 1
a2802 1
   update_fbo_texture(ctx, texObj, face, level);
d2804 6
a2809 3
   /* state update */
   texObj->Complete = GL_FALSE;
   ctx->NewState |= _NEW_TEXTURE;
d2841 32
a2872 7
   texImage = _mesa_get_tex_image(ctx, texUnit, target, level);
   if (!texImage) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCopyTexImage2D");
      return;
   }
   else if (texImage->Data) {
      ctx->Driver.FreeTexImageData( ctx, texImage );
d2874 2
a2875 18
   ASSERT(texImage->Data == NULL);

   clear_teximage_fields(texImage); /* not really needed, but helpful */
   _mesa_init_teximage_fields(ctx, target, texImage,
                              postConvWidth, postConvHeight, 1,
                              border, internalFormat);

   ASSERT(ctx->Driver.CopyTexImage2D);
   (*ctx->Driver.CopyTexImage2D)(ctx, target, level, internalFormat,
                                 x, y, width, height, border);

   ASSERT(texImage->TexFormat);

   update_fbo_texture(ctx, texObj, face, level);

   /* state update */
   texObj->Complete = GL_FALSE;
   ctx->NewState |= _NEW_TEXTURE;
a2878 1

d2884 1
d2901 11
a2911 2
   texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
   ASSERT(texImage);
d2913 2
a2914 2
   /* If we have a border, xoffset=-1 is legal.  Bias by border width */
   xoffset += texImage->Border;
d2916 6
a2921 3
   ASSERT(ctx->Driver.CopyTexSubImage1D);
   (*ctx->Driver.CopyTexSubImage1D)(ctx, target, level, xoffset, x, y, width);
   ctx->NewState |= _NEW_TEXTURE;
d2932 1
d2949 1
a2949 2
   texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
   ASSERT(texImage);
d2951 19
a2969 8
   /* If we have a border, xoffset=-1 is legal.  Bias by border width */
   xoffset += texImage->Border;
   yoffset += texImage->Border;

   ASSERT(ctx->Driver.CopyTexSubImage2D);
   (*ctx->Driver.CopyTexSubImage2D)(ctx, target, level,
                                    xoffset, yoffset, x, y, width, height);
   ctx->NewState |= _NEW_TEXTURE;
d2980 1
d2997 1
a2997 2
   texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
   ASSERT(texImage);
d2999 22
a3020 10
   /* If we have a border, xoffset=-1 is legal.  Bias by border width */
   xoffset += texImage->Border;
   yoffset += texImage->Border;
   zoffset += texImage->Border;

   ASSERT(ctx->Driver.CopyTexSubImage3D);
   (*ctx->Driver.CopyTexSubImage3D)(ctx, target, level,
                                    xoffset, yoffset, zoffset,
                                    x, y, width, height);
   ctx->NewState |= _NEW_TEXTURE;
a3240 9
      texImage = _mesa_get_tex_image(ctx, texUnit, target, level);
      if (!texImage) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCompressedTexImage1D");
         return;
      }
      else if (texImage->Data) {
	 ctx->Driver.FreeTexImageData( ctx, texImage );
      }
      ASSERT(texImage->Data == NULL);
d3242 12
a3253 2
      _mesa_init_teximage_fields(ctx, target, texImage, width, 1, 1,
                                 border, internalFormat);
d3255 2
a3256 5
      ASSERT(ctx->Driver.CompressedTexImage1D);
      (*ctx->Driver.CompressedTexImage1D)(ctx, target, level,
                                          internalFormat, width, border,
                                          imageSize, data,
                                          texObj, texImage);
d3258 12
a3269 3
      /* state update */
      texObj->Complete = GL_FALSE;
      ctx->NewState |= _NEW_TEXTURE;
d3291 1
d3294 9
a3302 3
         texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
         _mesa_init_teximage_fields(ctx, target, texImage, width, 1, 1,
                                    border, internalFormat);
a3337 9
      texImage = _mesa_get_tex_image(ctx, texUnit, target, level);
      if (!texImage) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCompressedTexImage2D");
         return;
      }
      else if (texImage->Data) {
	 ctx->Driver.FreeTexImageData( ctx, texImage );
      }
      ASSERT(texImage->Data == NULL);
d3339 12
a3350 2
      _mesa_init_teximage_fields(ctx, target, texImage, width, height, 1,
                                 border, internalFormat);
d3352 2
a3353 5
      ASSERT(ctx->Driver.CompressedTexImage2D);
      (*ctx->Driver.CompressedTexImage2D)(ctx, target, level,
                                          internalFormat, width, height,
                                          border, imageSize, data,
                                          texObj, texImage);
d3355 12
a3366 3
      /* state update */
      texObj->Complete = GL_FALSE;
      ctx->NewState |= _NEW_TEXTURE;
d3390 1
d3393 9
a3401 3
         texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
         _mesa_init_teximage_fields(ctx, target, texImage, width, height, 1,
                                    border, internalFormat);
d3434 12
a3445 9
      texImage = _mesa_get_tex_image(ctx, texUnit, target, level);
      if (!texImage) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCompressedTexImage3D");
         return;
      }
      else if (texImage->Data) {
	 ctx->Driver.FreeTexImageData( ctx, texImage );
      }
      ASSERT(texImage->Data == NULL);
d3447 2
a3448 2
      _mesa_init_teximage_fields(ctx, target, texImage, width, height, depth,
                                 border, internalFormat);
d3450 13
a3462 10
      ASSERT(ctx->Driver.CompressedTexImage3D);
      (*ctx->Driver.CompressedTexImage3D)(ctx, target, level,
                                          internalFormat,
                                          width, height, depth,
                                          border, imageSize, data,
                                          texObj, texImage);

      /* state update */
      texObj->Complete = GL_FALSE;
      ctx->NewState |= _NEW_TEXTURE;
d3484 1
d3487 8
a3494 3
         texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
         _mesa_init_teximage_fields(ctx, target, texImage, width, height,
                                    depth, border, internalFormat);
d3527 10
a3536 2
   texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
   assert(texImage);
d3538 4
a3541 10
   if ((GLint) format != texImage->InternalFormat) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glCompressedTexSubImage1D(format)");
      return;
   }

   if ((width == 1 || width == 2) && (GLuint) width != texImage->Width) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glCompressedTexSubImage1D(width)");
      return;
   }
d3543 2
a3544 2
   if (width == 0)
      return;  /* no-op, not an error */
d3546 7
a3552 5
   if (ctx->Driver.CompressedTexSubImage1D) {
      (*ctx->Driver.CompressedTexSubImage1D)(ctx, target, level,
                                             xoffset, width,
                                             format, imageSize, data,
                                             texObj, texImage);
d3554 2
a3555 1
   ctx->NewState |= _NEW_TEXTURE;
d3584 10
a3593 2
   texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
   assert(texImage);
d3595 5
a3599 11
   if ((GLint) format != texImage->InternalFormat) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glCompressedTexSubImage2D(format)");
      return;
   }

   if (((width == 1 || width == 2) && (GLuint) width != texImage->Width) ||
       ((height == 1 || height == 2) && (GLuint) height != texImage->Height)) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glCompressedTexSubImage2D(size)");
      return;
   }
d3601 2
a3602 2
   if (width == 0 || height == 0)
      return;  /* no-op, not an error */
d3604 7
a3610 5
   if (ctx->Driver.CompressedTexSubImage2D) {
      (*ctx->Driver.CompressedTexSubImage2D)(ctx, target, level,
                                             xoffset, yoffset, width, height,
                                             format, imageSize, data,
                                             texObj, texImage);
d3612 2
a3613 1
   ctx->NewState |= _NEW_TEXTURE;
d3641 17
a3657 15
   texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
   assert(texImage);

   if ((GLint) format != texImage->InternalFormat) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glCompressedTexSubImage3D(format)");
      return;
   }

   if (((width == 1 || width == 2) && (GLuint) width != texImage->Width) ||
       ((height == 1 || height == 2) && (GLuint) height != texImage->Height) ||
       ((depth == 1 || depth == 2) && (GLuint) depth != texImage->Depth)) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glCompressedTexSubImage3D(size)");
      return;
   }
d3659 2
a3660 2
   if (width == 0 || height == 0 || depth == 0)
      return;  /* no-op, not an error */
d3662 8
a3669 6
   if (ctx->Driver.CompressedTexSubImage3D) {
      (*ctx->Driver.CompressedTexSubImage3D)(ctx, target, level,
                                             xoffset, yoffset, zoffset,
                                             width, height, depth,
                                             format, imageSize, data,
                                             texObj, texImage);
d3671 2
a3672 1
   ctx->NewState |= _NEW_TEXTURE;
d3680 1
a3680 1
   const struct gl_texture_object *texObj;
d3686 1
a3706 6
   texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
   if (!texImage) {
      /* probably invalid mipmap level */
      _mesa_error(ctx, GL_INVALID_VALUE, "glGetCompressedTexImageARB(level)");
      return;
   }
d3708 16
a3723 3
   if (!texImage->IsCompressed) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glGetCompressedTexImageARB");
      return;
d3725 2
a3726 3

   /* this typically calls _mesa_get_compressed_teximage() */
   ctx->Driver.GetCompressedTexImage(ctx, target, level, img, texObj,texImage);
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d76 2
a77 2
#if CHAN_TYPE != GL_UNSIGNED_BYTE
   _mesa_problem(NULL, "PrintTexture not supported");
d80 1
a80 1
   const GLubyte *data = (const GLubyte *) img->Data;
d709 3
a711 6
   /* Free texImage->Data and/or any other driver-specific texture
    * image storage.
    */
   ASSERT(ctx->Driver.FreeTexImageData);
   ctx->Driver.FreeTexImageData( ctx, texImage );

d804 2
a805 2
_mesa_select_tex_image(GLcontext *ctx, const struct gl_texture_object *texObj,
		       GLenum target, GLint level)
d807 2
a808 5
   ASSERT(texObj);

   if (level < 0 || level >= MAX_TEXTURE_LEVELS) 
      return NULL;

d811 1
d813 1
d815 1
d817 1
d819 1
d821 1
a821 2
         return texObj->Image[0][level];

d831 1
a831 1
            return texObj->Image[face][level];
a834 1

d837 1
a837 1
            return texObj->Image[0][level];
a839 1

d841 7
d849 5
a853 3
         if (ctx->Extensions.NV_texture_rectangle && level == 0) 
            return texObj->Image[0][level];
         else 
d855 1
a855 1

d857 1
d869 1
a869 1
_mesa_get_tex_image(GLcontext *ctx, struct gl_texture_object *texObj,
d873 1
a873 5

   if (!texObj)
      return NULL;
   
   texImage = _mesa_select_tex_image(ctx, texObj, target, level);
d875 1
d881 2
a882 1

a884 1

d1587 3
d1599 1
a1599 1
          target <= GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB) {
d1605 2
a1606 1
      else if (target == GL_TEXTURE_RECTANGLE_NV) {
d1650 1
a1650 8
   if (!_mesa_is_legal_format_and_type(ctx, format, type)) {
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "glTexSubImage%dD(format or type)", dimensions);
      return GL_TRUE;
   }

   return GL_FALSE;
}
a1651 8
static GLboolean
subtexture_error_check2( GLcontext *ctx, GLuint dimensions,
			 GLenum target, GLint level,
			 GLint xoffset, GLint yoffset, GLint zoffset,
			 GLint width, GLint height, GLint depth,
			 GLenum format, GLenum type,
			 const struct gl_texture_image *destTex )
{
d1691 6
d1712 5
d1738 1
a1738 1
      if ((width & 3) && (GLuint) width != destTex->Width) {
d1743 1
a1743 1
      if ((height & 3) && (GLuint) height != destTex->Height) {
a1783 5
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glCopyTexImage%dD(level=%d)", dimensions, level);
      return GL_TRUE;
   }

d1794 5
d1948 1
a1948 1
                             GLsizei width, GLsizei height)
d1950 3
d2015 1
a2015 10
   return GL_FALSE;
}

static GLboolean
copytexsubimage_error_check2( GLcontext *ctx, GLuint dimensions,
			      GLenum target, GLint level,
			      GLint xoffset, GLint yoffset, GLint zoffset,
			      GLsizei width, GLsizei height,
			      const struct gl_texture_image *teximage )
{
d2189 5
a2193 7
   _mesa_lock_texture(ctx, texObj);
   {
      texImage = _mesa_select_tex_image(ctx, texObj, target, level);
      if (!texImage) {
	 /* invalid mipmap level, not an error */
	 goto out;
      }
d2195 31
d2227 9
a2235 42
      /* Make sure the requested image format is compatible with the
       * texture's format.  Note that a color index texture can be converted
       * to RGBA so that combo is allowed.
       */
      if (is_color_format(format)
	  && !is_color_format(texImage->TexFormat->BaseFormat)
	  && !is_index_format(texImage->TexFormat->BaseFormat)) {
	 _mesa_error(ctx, GL_INVALID_OPERATION, "glGetTexImage(format mismatch)");
	 goto out;
      }
      else if (is_index_format(format)
	       && !is_index_format(texImage->TexFormat->BaseFormat)) {
	 _mesa_error(ctx, GL_INVALID_OPERATION, "glGetTexImage(format mismatch)");
	 goto out;
      }
      else if (is_depth_format(format)
	       && !is_depth_format(texImage->TexFormat->BaseFormat)
	       && !is_depthstencil_format(texImage->TexFormat->BaseFormat)) {
	 _mesa_error(ctx, GL_INVALID_OPERATION, "glGetTexImage(format mismatch)");
	 goto out;
      }
      else if (is_ycbcr_format(format)
	       && !is_ycbcr_format(texImage->TexFormat->BaseFormat)) {
	 _mesa_error(ctx, GL_INVALID_OPERATION, "glGetTexImage(format mismatch)");
	 goto out;
      }
      else if (is_depthstencil_format(format)
	       && !is_depthstencil_format(texImage->TexFormat->BaseFormat)) {
	 _mesa_error(ctx, GL_INVALID_OPERATION, "glGetTexImage(format mismatch)");
	 goto out;
      }

      if (ctx->Pack.BufferObj->Name) {
	 /* packing texture image into a PBO */
	 const GLuint dimensions = (target == GL_TEXTURE_3D) ? 3 : 2;
	 if (!_mesa_validate_pbo_access(dimensions, &ctx->Pack, texImage->Width,
					texImage->Height, texImage->Depth,
					format, type, pixels)) {
	    _mesa_error(ctx, GL_INVALID_OPERATION,
			"glGetTexImage(invalid PBO access)");
	    goto out;
	 }
d2237 1
d2239 3
a2241 7
      /* typically, this will call _mesa_get_teximage() */
      ctx->Driver.GetTexImage(ctx, target, level, format, type, pixels,
			      texObj, texImage);

   }
 out:
   _mesa_unlock_texture(ctx, texObj);
d2304 17
d2322 8
a2329 1
	 _mesa_update_state(ctx);
d2331 1
a2331 13
      texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
      texObj = _mesa_select_tex_object(ctx, texUnit, target);
      _mesa_lock_texture(ctx, texObj);
      {
	 texImage = _mesa_get_tex_image(ctx, texObj, target, level);
	 if (!texImage) {
	    _mesa_error(ctx, GL_OUT_OF_MEMORY, "glTexImage1D");
	    goto out;
	 }
      
	 if (texImage->Data) {
	    ctx->Driver.FreeTexImageData( ctx, texImage );
	 }
d2333 1
a2333 1
	 ASSERT(texImage->Data == NULL);
d2335 3
a2337 22
	 clear_teximage_fields(texImage); /* not really needed, but helpful */
	 _mesa_init_teximage_fields(ctx, target, texImage,
				    postConvWidth, 1, 1,
				    border, internalFormat);
	 
	 ASSERT(ctx->Driver.TexImage1D);

	 /* Give the texture to the driver!  <pixels> may be null! */
	 (*ctx->Driver.TexImage1D)(ctx, target, level, internalFormat,
				   width, border, format, type, pixels,
				   &ctx->Unpack, texObj, texImage);
	 
	 ASSERT(texImage->TexFormat);

	 update_fbo_texture(ctx, texObj, face, level);
	 
	 /* state update */
	 texObj->Complete = GL_FALSE;
	 ctx->NewState |= _NEW_TEXTURE;
      }
   out:
      _mesa_unlock_texture(ctx, texObj);
a2398 3
      if (ctx->NewState & _IMAGE_NEW_TRANSFER_STATE)
	 _mesa_update_state(ctx);

d2401 7
a2407 32
      _mesa_lock_texture(ctx, texObj);
      {
	 texImage = _mesa_get_tex_image(ctx, texObj, target, level);
	 if (!texImage) {
	    _mesa_error(ctx, GL_OUT_OF_MEMORY, "glTexImage2D");
	    goto out;
	 }
	 
	 if (texImage->Data) {
	    ctx->Driver.FreeTexImageData( ctx, texImage );
	 }
	 
	 ASSERT(texImage->Data == NULL);
	 clear_teximage_fields(texImage); /* not really needed, but helpful */
	 _mesa_init_teximage_fields(ctx, target, texImage,
				    postConvWidth, postConvHeight, 1,
				    border, internalFormat);
	 
	 ASSERT(ctx->Driver.TexImage2D);

	 /* Give the texture to the driver!  <pixels> may be null! */
	 (*ctx->Driver.TexImage2D)(ctx, target, level, internalFormat,
				   width, height, border, format, type, pixels,
				   &ctx->Unpack, texObj, texImage);
	 
	 ASSERT(texImage->TexFormat);

	 update_fbo_texture(ctx, texObj, face, level);

	 /* state update */
	 texObj->Complete = GL_FALSE;
	 ctx->NewState |= _NEW_TEXTURE;
d2409 23
a2431 2
   out:
      _mesa_unlock_texture(ctx, texObj);
a2488 3
      if (ctx->NewState & _IMAGE_NEW_TRANSFER_STATE)
	 _mesa_update_state(ctx);

d2491 7
a2497 32
      _mesa_lock_texture(ctx, texObj);
      {
	 texImage = _mesa_get_tex_image(ctx, texObj, target, level);
	 if (!texImage) {
	    _mesa_error(ctx, GL_OUT_OF_MEMORY, "glTexImage3D");
	    goto out;
	 }
	 
	 if (texImage->Data) {
	    ctx->Driver.FreeTexImageData( ctx, texImage );
	 }
	 
	 ASSERT(texImage->Data == NULL);
	 clear_teximage_fields(texImage); /* not really needed, but helpful */
	 _mesa_init_teximage_fields(ctx, target, texImage,
				    width, height, depth,
				    border, internalFormat);

	 ASSERT(ctx->Driver.TexImage3D);

	 /* Give the texture to the driver!  <pixels> may be null! */
	 (*ctx->Driver.TexImage3D)(ctx, target, level, internalFormat,
				   width, height, depth, border, format, type,
				   pixels, &ctx->Unpack, texObj, texImage);

	 ASSERT(texImage->TexFormat);

	 update_fbo_texture(ctx, texObj, face, level);

	 /* state update */
	 texObj->Complete = GL_FALSE;
	 ctx->NewState |= _NEW_TEXTURE;
d2499 23
a2521 2
   out:
      _mesa_unlock_texture(ctx, texObj);
d2569 1
a2569 1
   struct gl_texture_image *texImage = NULL;
d2582 1
a2582 1
			       postConvWidth, 1, 1, format, type)) {
a2585 1

d2588 2
a2589 5
   assert(texObj);

   _mesa_lock_texture(ctx, texObj);
   {
      texImage = _mesa_select_tex_image(ctx, texObj, target, level);
d2591 2
a2592 7
      if (subtexture_error_check2(ctx, 1, target, level, xoffset, 0, 0,
				  postConvWidth, 1, 1, format, type, texImage)) {
	 goto out;   /* error was detected */
      }

      if (width == 0)
	 goto out;  /* no-op, not an error */
d2594 2
a2595 2
      /* If we have a border, xoffset=-1 is legal.  Bias by border width */
      xoffset += texImage->Border;
d2597 5
a2601 8
      ASSERT(ctx->Driver.TexSubImage1D);
      (*ctx->Driver.TexSubImage1D)(ctx, target, level, xoffset, width,
				   format, type, pixels, &ctx->Unpack,
				   texObj, texImage);
      ctx->NewState |= _NEW_TEXTURE;
   }
 out:
   _mesa_unlock_texture(ctx, texObj);
d2629 1
a2629 1
			      postConvWidth, postConvHeight, 1, format, type)) {
d2635 15
a2649 25
   _mesa_lock_texture(ctx, texObj);
   {
      texImage = _mesa_select_tex_image(ctx, texObj, target, level);

      if (subtexture_error_check2(ctx, 2, target, level, xoffset, yoffset, 0,
				  postConvWidth, postConvHeight, 1, format, type, 
				  texImage)) {
	 goto out;   /* error was detected */
      }

      if (width == 0 || height == 0)
	 goto out;  /* no-op, not an error */

      /* If we have a border, xoffset=-1 is legal.  Bias by border width */
      xoffset += texImage->Border;
      yoffset += texImage->Border;
      
      ASSERT(ctx->Driver.TexSubImage2D);
      (*ctx->Driver.TexSubImage2D)(ctx, target, level, xoffset, yoffset,
				   width, height, format, type, pixels,
				   &ctx->Unpack, texObj, texImage);
      ctx->NewState |= _NEW_TEXTURE;
   }
 out:
   _mesa_unlock_texture(ctx, texObj);
d2677 5
d2683 12
a2694 27
   _mesa_lock_texture(ctx, texObj);
   {
      texImage = _mesa_select_tex_image(ctx, texObj, target, level);

      if (subtexture_error_check2(ctx, 3, target, level, xoffset, yoffset, zoffset,
				  width, height, depth, format, type, texImage)) {
	 goto out;   /* error was detected */
      }

      if (width == 0 || height == 0 || height == 0)
	 goto out;  /* no-op, not an error */

      /* If we have a border, xoffset=-1 is legal.  Bias by border width */
      xoffset += texImage->Border;
      yoffset += texImage->Border;
      zoffset += texImage->Border;

      ASSERT(ctx->Driver.TexSubImage3D);
      (*ctx->Driver.TexSubImage3D)(ctx, target, level,
				   xoffset, yoffset, zoffset,
				   width, height, depth,
				   format, type, pixels,
				   &ctx->Unpack, texObj, texImage );
      ctx->NewState |= _NEW_TEXTURE;
   }
 out:
   _mesa_unlock_texture(ctx, texObj);
d2726 9
a2734 13
   _mesa_lock_texture(ctx, texObj);
   {
      texImage = _mesa_get_tex_image(ctx, texObj, target, level);
      if (!texImage) {
	 _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCopyTexImage1D");
	 goto out;
      }

      if (texImage->Data) {
	 ctx->Driver.FreeTexImageData( ctx, texImage );
      }
      
      ASSERT(texImage->Data == NULL);
d2736 3
a2738 3
      clear_teximage_fields(texImage); /* not really needed, but helpful */
      _mesa_init_teximage_fields(ctx, target, texImage, postConvWidth, 1, 1,
				 border, internalFormat);
d2741 3
a2743 3
      ASSERT(ctx->Driver.CopyTexImage1D);
      (*ctx->Driver.CopyTexImage1D)(ctx, target, level, internalFormat,
				    x, y, width, border);
d2745 1
a2745 1
      ASSERT(texImage->TexFormat);
d2747 1
a2747 1
      update_fbo_texture(ctx, texObj, face, level);
d2749 3
a2751 6
      /* state update */
      texObj->Complete = GL_FALSE;
      ctx->NewState |= _NEW_TEXTURE;
   }
 out:
   _mesa_unlock_texture(ctx, texObj);
d2783 9
d2793 17
a2809 14
   _mesa_lock_texture(ctx, texObj);
   {
      texImage = _mesa_get_tex_image(ctx, texObj, target, level);

      if (!texImage) {
	 _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCopyTexImage2D");
	 goto out;
      }
      
      if (texImage->Data) {
	 ctx->Driver.FreeTexImageData( ctx, texImage );
      }
      
      ASSERT(texImage->Data == NULL);
a2810 20
      clear_teximage_fields(texImage); /* not really needed, but helpful */
      _mesa_init_teximage_fields(ctx, target, texImage,
				 postConvWidth, postConvHeight, 1,
				 border, internalFormat);
      
      ASSERT(ctx->Driver.CopyTexImage2D);
      (*ctx->Driver.CopyTexImage2D)(ctx, target, level, internalFormat,
				    x, y, width, height, border);
      
      ASSERT(texImage->TexFormat);

      update_fbo_texture(ctx, texObj, face, level);

      /* state update */
      texObj->Complete = GL_FALSE;
      ctx->NewState |= _NEW_TEXTURE;
   }
 out:
   _mesa_unlock_texture(ctx, texObj);
}
a2817 1
   struct gl_texture_object *texObj;
d2834 2
a2835 11
   texObj = _mesa_select_tex_object(ctx, texUnit, target);

   _mesa_lock_texture(ctx, texObj);
   {
      texImage = _mesa_select_tex_image(ctx, texObj, target, level);

      if (copytexsubimage_error_check2(ctx, 1, target, level,
				       xoffset, 0, 0, postConvWidth, 1,
				       texImage))
	 goto out;
      
d2837 2
a2838 2
      /* If we have a border, xoffset=-1 is legal.  Bias by border width */
      xoffset += texImage->Border;
d2840 3
a2842 6
      ASSERT(ctx->Driver.CopyTexSubImage1D);
      (*ctx->Driver.CopyTexSubImage1D)(ctx, target, level, xoffset, x, y, width);
      ctx->NewState |= _NEW_TEXTURE;
   }
 out:
   _mesa_unlock_texture(ctx, texObj);
a2852 1
   struct gl_texture_object *texObj;
d2869 2
a2870 1
   texObj = _mesa_select_tex_object(ctx, texUnit, target);
d2872 8
a2879 19
   _mesa_lock_texture(ctx, texObj);
   {
      texImage = _mesa_select_tex_image(ctx, texObj, target, level);

      if (copytexsubimage_error_check2(ctx, 2, target, level, xoffset, yoffset, 0,
				       postConvWidth, postConvHeight, texImage))
	 goto out;

      /* If we have a border, xoffset=-1 is legal.  Bias by border width */
      xoffset += texImage->Border;
      yoffset += texImage->Border;
      
      ASSERT(ctx->Driver.CopyTexSubImage2D);
      (*ctx->Driver.CopyTexSubImage2D)(ctx, target, level,
				       xoffset, yoffset, x, y, width, height);
      ctx->NewState |= _NEW_TEXTURE;
   }
 out:
   _mesa_unlock_texture(ctx, texObj);
a2889 1
   struct gl_texture_object *texObj;
d2906 2
a2907 1
   texObj = _mesa_select_tex_object(ctx, texUnit, target);
d2909 10
a2918 22
   _mesa_lock_texture(ctx, texObj);
   {
      texImage = _mesa_select_tex_image(ctx, texObj, target, level);

      if (copytexsubimage_error_check2(ctx, 3, target, level, xoffset, yoffset,
				       zoffset, postConvWidth, postConvHeight,
				       texImage))
	 goto out;

      /* If we have a border, xoffset=-1 is legal.  Bias by border width */
      xoffset += texImage->Border;
      yoffset += texImage->Border;
      zoffset += texImage->Border;
      
      ASSERT(ctx->Driver.CopyTexSubImage3D);
      (*ctx->Driver.CopyTexSubImage3D)(ctx, target, level,
				       xoffset, yoffset, zoffset,
				       x, y, width, height);
      ctx->NewState |= _NEW_TEXTURE;
   }
 out:
   _mesa_unlock_texture(ctx, texObj);
d3139 9
d3149 2
a3150 12
      _mesa_lock_texture(ctx, texObj);
      {
	 texImage = _mesa_get_tex_image(ctx, texObj, target, level);
	 if (!texImage) {
	    _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCompressedTexImage1D");
	    goto out;
	 }
	 
	 if (texImage->Data) {
	    ctx->Driver.FreeTexImageData( ctx, texImage );
	 }
	 ASSERT(texImage->Data == NULL);
d3152 5
a3156 2
	 _mesa_init_teximage_fields(ctx, target, texImage, width, 1, 1,
				    border, internalFormat);
d3158 3
a3160 12
	 ASSERT(ctx->Driver.CompressedTexImage1D);
	 (*ctx->Driver.CompressedTexImage1D)(ctx, target, level,
					     internalFormat, width, border,
					     imageSize, data,
					     texObj, texImage);

	 /* state update */
	 texObj->Complete = GL_FALSE;
	 ctx->NewState |= _NEW_TEXTURE;
      }
   out:
      _mesa_unlock_texture(ctx, texObj);
a3181 1
         struct gl_texture_object *texObj;
d3184 3
a3186 9
	 texObj = _mesa_select_tex_object(ctx, texUnit, target);

	 _mesa_lock_texture(ctx, texObj);
	 {
	    texImage = _mesa_select_tex_image(ctx, texObj, target, level);
	    _mesa_init_teximage_fields(ctx, target, texImage, width, 1, 1,
				       border, internalFormat);
	 }
	 _mesa_unlock_texture(ctx, texObj);
d3222 9
d3232 2
a3233 12
      _mesa_lock_texture(ctx, texObj);
      {
	 texImage = _mesa_get_tex_image(ctx, texObj, target, level);
	 if (!texImage) {
	    _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCompressedTexImage2D");
	    goto out;
	 }
	 
	 if (texImage->Data) {
	    ctx->Driver.FreeTexImageData( ctx, texImage );
	 }
	 ASSERT(texImage->Data == NULL);
d3235 5
a3239 2
	 _mesa_init_teximage_fields(ctx, target, texImage, width, height, 1,
				    border, internalFormat);
d3241 3
a3243 12
	 ASSERT(ctx->Driver.CompressedTexImage2D);
	 (*ctx->Driver.CompressedTexImage2D)(ctx, target, level,
					     internalFormat, width, height,
					     border, imageSize, data,
					     texObj, texImage);
	 
	 /* state update */
	 texObj->Complete = GL_FALSE;
	 ctx->NewState |= _NEW_TEXTURE;
      }
   out:
      _mesa_unlock_texture(ctx, texObj);
a3266 1
         struct gl_texture_object *texObj;
d3269 3
a3271 9
	 texObj = _mesa_select_tex_object(ctx, texUnit, target);

	 _mesa_lock_texture(ctx, texObj);
	 {
	    texImage = _mesa_select_tex_image(ctx, texObj, target, level);
	    _mesa_init_teximage_fields(ctx, target, texImage, width, height, 1,
				       border, internalFormat);
	 }
	 _mesa_unlock_texture(ctx, texObj);
d3304 12
a3315 12
      _mesa_lock_texture(ctx, texObj);
      {
	 texImage = _mesa_get_tex_image(ctx, texObj, target, level);
	 if (!texImage) {
	    _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCompressedTexImage3D");
	    goto out;
	 }
	 
	 if (texImage->Data) {
	    ctx->Driver.FreeTexImageData( ctx, texImage );
	 }
	 ASSERT(texImage->Data == NULL);
d3317 6
a3322 2
	 _mesa_init_teximage_fields(ctx, target, texImage, width, height, depth,
				    border, internalFormat);
d3324 3
a3326 13
	 ASSERT(ctx->Driver.CompressedTexImage3D);
	 (*ctx->Driver.CompressedTexImage3D)(ctx, target, level,
					     internalFormat,
					     width, height, depth,
					     border, imageSize, data,
					     texObj, texImage);
	 
	 /* state update */
	 texObj->Complete = GL_FALSE;
	 ctx->NewState |= _NEW_TEXTURE;
      }
   out:
      _mesa_unlock_texture(ctx, texObj);
a3347 1
         struct gl_texture_object *texObj;
d3350 3
a3352 8
	 texObj = _mesa_select_tex_object(ctx, texUnit, target);
	 _mesa_lock_texture(ctx, texObj);
	 {
	    texImage = _mesa_select_tex_image(ctx, texObj, target, level);
	    _mesa_init_teximage_fields(ctx, target, texImage, width, height,
				       depth, border, internalFormat);
	 }
	 _mesa_unlock_texture(ctx, texObj);
d3385 8
a3392 10
   _mesa_lock_texture(ctx, texObj);
   {
      texImage = _mesa_select_tex_image(ctx, texObj, target, level);
      assert(texImage);

      if ((GLint) format != texImage->InternalFormat) {
	 _mesa_error(ctx, GL_INVALID_OPERATION,
		     "glCompressedTexSubImage1D(format)");
	 goto out;
      }
d3394 4
a3397 4
      if ((width == 1 || width == 2) && (GLuint) width != texImage->Width) {
	 _mesa_error(ctx, GL_INVALID_VALUE, "glCompressedTexSubImage1D(width)");
	 goto out;
      }
d3399 2
a3400 2
      if (width == 0)
	 goto out;  /* no-op, not an error */
d3402 5
a3406 7
      if (ctx->Driver.CompressedTexSubImage1D) {
	 (*ctx->Driver.CompressedTexSubImage1D)(ctx, target, level,
						xoffset, width,
						format, imageSize, data,
						texObj, texImage);
      }
      ctx->NewState |= _NEW_TEXTURE;
d3408 1
a3408 2
 out:
   _mesa_unlock_texture(ctx, texObj);
d3437 8
a3444 10
   _mesa_lock_texture(ctx, texObj);
   {
      texImage = _mesa_select_tex_image(ctx, texObj, target, level);
      assert(texImage);

      if ((GLint) format != texImage->InternalFormat) {
	 _mesa_error(ctx, GL_INVALID_OPERATION,
		     "glCompressedTexSubImage2D(format)");
	 goto out;
      }
d3446 5
a3450 5
      if (((width == 1 || width == 2) && (GLuint) width != texImage->Width) ||
	  ((height == 1 || height == 2) && (GLuint) height != texImage->Height)) {
	 _mesa_error(ctx, GL_INVALID_VALUE, "glCompressedTexSubImage2D(size)");
	 goto out;
      }
d3452 2
a3453 2
      if (width == 0 || height == 0)
	 goto out;  /* no-op, not an error */
d3455 5
a3459 7
      if (ctx->Driver.CompressedTexSubImage2D) {
	 (*ctx->Driver.CompressedTexSubImage2D)(ctx, target, level,
						xoffset, yoffset, width, height,
						format, imageSize, data,
						texObj, texImage);
      }
      ctx->NewState |= _NEW_TEXTURE;
d3461 1
a3461 2
 out:
   _mesa_unlock_texture(ctx, texObj);
d3489 15
a3503 17
   _mesa_lock_texture(ctx, texObj);
   {
      texImage = _mesa_select_tex_image(ctx, texObj, target, level);
      assert(texImage);

      if ((GLint) format != texImage->InternalFormat) {
	 _mesa_error(ctx, GL_INVALID_OPERATION,
		     "glCompressedTexSubImage3D(format)");
	 goto out;
      }

      if (((width == 1 || width == 2) && (GLuint) width != texImage->Width) ||
	  ((height == 1 || height == 2) && (GLuint) height != texImage->Height) ||
	  ((depth == 1 || depth == 2) && (GLuint) depth != texImage->Depth)) {
	 _mesa_error(ctx, GL_INVALID_VALUE, "glCompressedTexSubImage3D(size)");
	 goto out;
      }
d3505 2
a3506 2
      if (width == 0 || height == 0 || depth == 0)
	 goto out;  /* no-op, not an error */
d3508 6
a3513 8
      if (ctx->Driver.CompressedTexSubImage3D) {
	 (*ctx->Driver.CompressedTexSubImage3D)(ctx, target, level,
						xoffset, yoffset, zoffset,
						width, height, depth,
						format, imageSize, data,
						texObj, texImage);
      }
      ctx->NewState |= _NEW_TEXTURE;
d3515 1
a3515 2
 out:
   _mesa_unlock_texture(ctx, texObj);
d3523 1
a3523 1
   struct gl_texture_object *texObj;
a3528 1

d3549 6
d3556 4
a3559 8
   _mesa_lock_texture(ctx, texObj);
   {
      texImage = _mesa_select_tex_image(ctx, texObj, target, level);
      if (!texImage) {
	 /* probably invalid mipmap level */
	 _mesa_error(ctx, GL_INVALID_VALUE, "glGetCompressedTexImageARB(level)");
	 goto out;
      }
d3561 2
a3562 10
      if (!texImage->IsCompressed) {
	 _mesa_error(ctx, GL_INVALID_OPERATION, "glGetCompressedTexImageARB");
	 goto out;
      }

      /* this typically calls _mesa_get_compressed_teximage() */
      ctx->Driver.GetCompressedTexImage(ctx, target, level, img, texObj,texImage);
   }
 out:
   _mesa_unlock_texture(ctx, texObj);
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d3 1
a3 1
 * Version:  7.0.1
d5 1
a5 1
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
a1209 4
 * Note that width, height, depth == 0 is not an error.  However, a
 * texture with zero width/height/depth will be considered "incomplete"
 * and texturing will effectively be disabled.
 *
d1239 1
a1239 1
           width > 0 && _mesa_bitcount(width - 2 * border) != 1) ||
d1249 1
a1249 1
           width > 0 && _mesa_bitcount(width - 2 * border) != 1) ||
d1252 1
a1252 1
           height > 0 && _mesa_bitcount(height - 2 * border) != 1) ||
d1262 1
a1262 1
           width > 0 && _mesa_bitcount(width - 2 * border) != 1) ||
d1265 1
a1265 1
           height > 0 && _mesa_bitcount(height - 2 * border) != 1) ||
d1268 1
a1268 1
           depth > 0 && _mesa_bitcount(depth - 2 * border) != 1) ||
d1275 2
a1276 2
      if (width < 0 || width > ctx->Const.MaxTextureRectSize ||
          height < 0 || height > ctx->Const.MaxTextureRectSize ||
d1286 1
a1286 1
           width > 0 && _mesa_bitcount(width - 2 * border) != 1) ||
d1289 1
a1289 1
           height > 0 && _mesa_bitcount(height - 2 * border) != 1) ||
a1302 14
 * Helper function to determine whether a target supports compressed textures
 */
static GLboolean
target_can_be_compressed(GLcontext *ctx, GLenum target)
{
   return (((target == GL_TEXTURE_2D || target == GL_PROXY_TEXTURE_2D))
           || ((ctx->Extensions.ARB_texture_cube_map &&
                (target == GL_PROXY_TEXTURE_CUBE_MAP ||
                 (target >= GL_TEXTURE_CUBE_MAP_POSITIVE_X &&
                  target <= GL_TEXTURE_CUBE_MAP_NEGATIVE_Z)))));
}


/**
d1332 1
a1332 1
   GLboolean sizeOK = GL_TRUE;
a1333 1
   GLenum proxy_target;
d1368 4
a1371 3
         proxy_target = GL_PROXY_TEXTURE_1D;
         height = 1;
         depth = 1;
a1378 1
      depth = 1;
d1380 4
a1383 1
         proxy_target = GL_PROXY_TEXTURE_2D;
d1392 4
a1395 2
         proxy_target = GL_PROXY_TEXTURE_CUBE_MAP_ARB;
         sizeOK = (width == height);
d1403 5
a1407 1
         proxy_target = GL_PROXY_TEXTURE_RECTANGLE_NV;
d1416 4
a1419 1
         proxy_target = GL_PROXY_TEXTURE_3D;
a1430 4
   sizeOK = sizeOK && ctx->Driver.TestProxyTexImage(ctx, proxy_target, level,
                                                    internalFormat, format,
                                                    type, width, height,
                                                    depth, border);
d1525 15
a1539 4
      if (!target_can_be_compressed(ctx, target) && !isProxy) {
         _mesa_error(ctx, GL_INVALID_ENUM,
                     "glTexImage%d(target)", dimensions);
         return GL_TRUE;
d1714 10
a1723 1
      if (!target_can_be_compressed(ctx, target)) {
d2064 6
a2095 6
      return GL_TRUE;
   }

   if (!_mesa_source_buffer_exists(ctx, teximage->_BaseFormat)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
               "glCopyTexSubImage%dD(missing readbuffer)", dimensions);
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d2 2
a3 2
 * mesa 3-D graphics library
 * Version:  7.6
d5 1
a5 2
 * Copyright (C) 1999-2008  Brian Paul   All Rights Reserved.
 * Copyright (C) 2009  VMware, Inc.  All Rights Reserved.
d35 1
a35 1
#include "enums.h"
a37 1
#include "hash.h"
d43 1
a43 1
#include "texfetch.h"
d46 1
a46 1
#include "texpal.h"
a50 11
 * State changes which we care about for glCopyTex[Sub]Image() calls.
 * In particular, we care about pixel transfer state and buffer state
 * (such as glReadBuffer to make sure we read from the right renderbuffer).
 */
#define NEW_COPY_TEX_STATE (_MESA_NEW_TRANSFER_STATE | \
                            _NEW_BUFFERS | \
                            _NEW_PIXEL)



/**
d71 57
a169 2
 *
 * XXX this could be static
d172 1
a172 1
_mesa_base_tex_format( struct gl_context *ctx, GLint internalFormat )
d242 2
a243 1
   if (ctx->Extensions.ARB_depth_texture) {
d246 3
a248 3
         case GL_DEPTH_COMPONENT16:
         case GL_DEPTH_COMPONENT24:
         case GL_DEPTH_COMPONENT32:
d255 17
a271 15
   switch (internalFormat) {
   case GL_COMPRESSED_ALPHA:
      return GL_ALPHA;
   case GL_COMPRESSED_LUMINANCE:
      return GL_LUMINANCE;
   case GL_COMPRESSED_LUMINANCE_ALPHA:
      return GL_LUMINANCE_ALPHA;
   case GL_COMPRESSED_INTENSITY:
      return GL_INTENSITY;
   case GL_COMPRESSED_RGB:
      return GL_RGB;
   case GL_COMPRESSED_RGBA:
      return GL_RGBA;
   default:
      ; /* fallthrough */
a340 20
   if (ctx->Extensions.ATI_envmap_bumpmap) {
      switch (internalFormat) {
         case GL_DUDV_ATI:
         case GL_DU8DV8_ATI:
            return GL_DUDV_ATI;
         default:
            ; /* fallthrough */
      }
   }

   if (ctx->Extensions.MESA_texture_signed_rgba) {
      switch (internalFormat) {
         case GL_RGBA_SNORM:
         case GL_RGBA8_SNORM:
            return GL_RGBA;
         default:
            ; /* fallthrough */
      }
   }

d375 1
a375 1
         ; /* fallthrough */
d378 1
d381 112
a492 44
   if (ctx->Extensions.EXT_texture_integer) {
      switch (internalFormat) {
      case GL_RGBA8UI_EXT:
      case GL_RGBA16UI_EXT:
      case GL_RGBA32UI_EXT:
      case GL_RGBA8I_EXT:
      case GL_RGBA16I_EXT:
      case GL_RGBA32I_EXT:
         return GL_RGBA;
      case GL_RGB8UI_EXT:
      case GL_RGB16UI_EXT:
      case GL_RGB32UI_EXT:
      case GL_RGB8I_EXT:
      case GL_RGB16I_EXT:
      case GL_RGB32I_EXT:
         return GL_RGB;
      case GL_ALPHA8UI_EXT:
      case GL_ALPHA16UI_EXT:
      case GL_ALPHA32UI_EXT:
      case GL_ALPHA8I_EXT:
      case GL_ALPHA16I_EXT:
      case GL_ALPHA32I_EXT:
         return GL_ALPHA;
      case GL_INTENSITY8UI_EXT:
      case GL_INTENSITY16UI_EXT:
      case GL_INTENSITY32UI_EXT:
      case GL_INTENSITY8I_EXT:
      case GL_INTENSITY16I_EXT:
      case GL_INTENSITY32I_EXT:
         return GL_INTENSITY;
      case GL_LUMINANCE8UI_EXT:
      case GL_LUMINANCE16UI_EXT:
      case GL_LUMINANCE32UI_EXT:
      case GL_LUMINANCE8I_EXT:
      case GL_LUMINANCE16I_EXT:
      case GL_LUMINANCE32I_EXT:
         return GL_LUMINANCE;
      case GL_LUMINANCE_ALPHA8UI_EXT:
      case GL_LUMINANCE_ALPHA16UI_EXT:
      case GL_LUMINANCE_ALPHA32UI_EXT:
      case GL_LUMINANCE_ALPHA8I_EXT:
      case GL_LUMINANCE_ALPHA16I_EXT:
      case GL_LUMINANCE_ALPHA32I_EXT:
         return GL_LUMINANCE_ALPHA;
d494 1
a494 2
         ; /* fallthrough */
      }
d496 1
a497 26
   if (ctx->Extensions.ARB_texture_rg) {
      switch (internalFormat) {
      case GL_R16F:
	 /* R16F depends on both ARB_half_float_pixel and ARB_texture_float.
	  */
	 if (!ctx->Extensions.ARB_half_float_pixel)
	    break;
	 /* FALLTHROUGH */
      case GL_R32F:
	 if (!ctx->Extensions.ARB_texture_float)
	    break;
         return GL_RED;
      case GL_R8I:
      case GL_R8UI:
      case GL_R16I:
      case GL_R16UI:
      case GL_R32I:
      case GL_R32UI:
	 if (!ctx->Extensions.EXT_texture_integer)
	    break;
	 /* FALLTHROUGH */
      case GL_R8:
      case GL_R16:
      case GL_RED:
      case GL_COMPRESSED_RED:
         return GL_RED;
d499 15
a513 24
      case GL_RG16F:
	 /* RG16F depends on both ARB_half_float_pixel and ARB_texture_float.
	  */
	 if (!ctx->Extensions.ARB_half_float_pixel)
	    break;
	 /* FALLTHROUGH */
      case GL_RG32F:
	 if (!ctx->Extensions.ARB_texture_float)
	    break;
         return GL_RG;
      case GL_RG8I:
      case GL_RG8UI:
      case GL_RG16I:
      case GL_RG16UI:
      case GL_RG32I:
      case GL_RG32UI:
	 if (!ctx->Extensions.EXT_texture_integer)
	    break;
	 /* FALLTHROUGH */
      case GL_RG:
      case GL_RG8:
      case GL_RG16:
      case GL_COMPRESSED_RG:
         return GL_RG;
d515 1
a515 2
         ; /* fallthrough */
      }
d517 2
d520 12
a531 4
   if (ctx->Extensions.EXT_texture_shared_exponent) {
      switch (internalFormat) {
      case GL_RGB9_E5_EXT:
         return GL_RGB;
d533 1
a533 2
         ; /* fallthrough */
      }
d535 2
d538 9
a546 4
   if (ctx->Extensions.EXT_packed_float) {
      switch (internalFormat) {
      case GL_R11F_G11F_B10F_EXT:
         return GL_RGB;
d548 1
a548 2
         ; /* fallthrough */
      }
d550 2
d553 10
a562 6
   if (ctx->Extensions.ARB_depth_buffer_float) {
      switch (internalFormat) {
      case GL_DEPTH_COMPONENT32F:
         return GL_DEPTH_COMPONENT;
      case GL_DEPTH32F_STENCIL8:
         return GL_DEPTH_STENCIL;
d564 1
a564 2
         ; /* fallthrough */
      }
d566 20
d587 5
a591 10
   if (ctx->Extensions.ARB_texture_compression_rgtc) {
      switch (internalFormat) {
      case GL_COMPRESSED_RED_RGTC1:
      case GL_COMPRESSED_SIGNED_RED_RGTC1:
         return GL_RED;
      case GL_COMPRESSED_RG_RGTC2:
      case GL_COMPRESSED_SIGNED_RG_RGTC2:
         return GL_RG;
      default:
         ; /* fallthrough */
d594 1
a594 2

   return -1; /* error */
d598 2
a599 6
/**
 * For cube map faces, return a face index in [0,5].
 * For other targets return 0;
 */
GLuint
_mesa_tex_target_to_face(GLenum target)
a625 2
   const GLuint face = _mesa_tex_target_to_face(target);

d628 26
a653 4
   ASSERT(target != GL_TEXTURE_RECTANGLE_NV || level == 0);

   tObj->Image[face][level] = texImage;

d669 1
a669 1
_mesa_new_texture_image( struct gl_context *ctx )
d680 1
a680 1
 * \param texImage texture image.
d685 1
a685 1
_mesa_free_texture_image_data(struct gl_context *ctx,
d702 1
a702 1
 * \param texImage texture image.
d707 1
a707 2
_mesa_delete_texture_image(struct gl_context *ctx,
                           struct gl_texture_image *texImage)
d717 2
a718 2
      free(texImage->ImageOffsets);
   free(texImage);
a731 3
   /* NUM_TEXTURE_TARGETS should match number of terms below */
   assert(NUM_TEXTURE_TARGETS == 7);

d736 1
a736 44
           target == GL_PROXY_TEXTURE_RECTANGLE_NV ||
           target == GL_PROXY_TEXTURE_1D_ARRAY_EXT ||
           target == GL_PROXY_TEXTURE_2D_ARRAY_EXT);
}


/**
 * Return the proxy target which corresponds to the given texture target
 */
static GLenum
get_proxy_target(GLenum target)
{
   switch (target) {
   case GL_TEXTURE_1D:
   case GL_PROXY_TEXTURE_1D:
      return GL_PROXY_TEXTURE_1D;
   case GL_TEXTURE_2D:
   case GL_PROXY_TEXTURE_2D:
      return GL_PROXY_TEXTURE_2D;
   case GL_TEXTURE_3D:
   case GL_PROXY_TEXTURE_3D:
      return GL_PROXY_TEXTURE_3D;
   case GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB:
   case GL_TEXTURE_CUBE_MAP_ARB:
   case GL_PROXY_TEXTURE_CUBE_MAP_ARB:
      return GL_PROXY_TEXTURE_CUBE_MAP_ARB;
   case GL_TEXTURE_RECTANGLE_NV:
   case GL_PROXY_TEXTURE_RECTANGLE_NV:
      return GL_PROXY_TEXTURE_RECTANGLE_NV;
   case GL_TEXTURE_1D_ARRAY_EXT:
   case GL_PROXY_TEXTURE_1D_ARRAY_EXT:
      return GL_PROXY_TEXTURE_1D_ARRAY_EXT;
   case GL_TEXTURE_2D_ARRAY_EXT:
   case GL_PROXY_TEXTURE_2D_ARRAY_EXT:
      return GL_PROXY_TEXTURE_2D_ARRAY_EXT;
   default:
      _mesa_problem(NULL, "unexpected target in get_proxy_target()");
      return 0;
   }
d741 1
a741 2
 * Get the texture object that corresponds to the target of the given
 * texture unit.
d752 1
a752 2
_mesa_select_tex_object(struct gl_context *ctx,
                        const struct gl_texture_unit *texUnit,
d757 1
a757 1
         return texUnit->CurrentTex[TEXTURE_1D_INDEX];
d759 1
a759 1
         return ctx->Texture.ProxyTex[TEXTURE_1D_INDEX];
d761 1
a761 1
         return texUnit->CurrentTex[TEXTURE_2D_INDEX];
d763 1
a763 1
         return ctx->Texture.ProxyTex[TEXTURE_2D_INDEX];
d765 1
a765 1
         return texUnit->CurrentTex[TEXTURE_3D_INDEX];
d767 1
a767 1
         return ctx->Texture.ProxyTex[TEXTURE_3D_INDEX];
d776 1
a776 1
                ? texUnit->CurrentTex[TEXTURE_CUBE_INDEX] : NULL;
d779 1
a779 1
                ? ctx->Texture.ProxyTex[TEXTURE_CUBE_INDEX] : NULL;
d782 1
a782 1
                ? texUnit->CurrentTex[TEXTURE_RECT_INDEX] : NULL;
d785 1
a785 13
                ? ctx->Texture.ProxyTex[TEXTURE_RECT_INDEX] : NULL;
      case GL_TEXTURE_1D_ARRAY_EXT:
         return ctx->Extensions.MESA_texture_array
                ? texUnit->CurrentTex[TEXTURE_1D_ARRAY_INDEX] : NULL;
      case GL_PROXY_TEXTURE_1D_ARRAY_EXT:
         return ctx->Extensions.MESA_texture_array
                ? ctx->Texture.ProxyTex[TEXTURE_1D_ARRAY_INDEX] : NULL;
      case GL_TEXTURE_2D_ARRAY_EXT:
         return ctx->Extensions.MESA_texture_array
                ? texUnit->CurrentTex[TEXTURE_2D_ARRAY_INDEX] : NULL;
      case GL_PROXY_TEXTURE_2D_ARRAY_EXT:
         return ctx->Extensions.MESA_texture_array
                ? ctx->Texture.ProxyTex[TEXTURE_2D_ARRAY_INDEX] : NULL;
d794 5
a798 17
 * Return pointer to texture object for given target on current texture unit.
 */
struct gl_texture_object *
_mesa_get_current_tex_object(struct gl_context *ctx, GLenum target)
{
   struct gl_texture_unit *texUnit = _mesa_get_current_tex_unit(ctx);
   return _mesa_select_tex_object(ctx, texUnit, target);
}


/**
 * Get a texture image pointer from a texture object, given a texture
 * target and mipmap level.  The target and level parameters should
 * have already been error-checked.
 *
 * \param ctx GL context.
 * \param texObj texture unit.
d802 3
a804 1
 * \return pointer to the texture image structure, or NULL on failure.
d807 1
a807 2
_mesa_select_tex_image(struct gl_context *ctx,
                       const struct gl_texture_object *texObj,
d810 33
a842 1
   const GLuint face = _mesa_tex_target_to_face(target);
d844 6
a849 3
   ASSERT(texObj);
   ASSERT(level >= 0);
   ASSERT(level < MAX_TEXTURE_LEVELS);
d851 3
a853 1
   return texObj->Image[face][level];
d863 1
a863 1
_mesa_get_tex_image(struct gl_context *ctx, struct gl_texture_object *texObj,
d893 1
a893 1
_mesa_get_proxy_tex_image(struct gl_context *ctx, GLenum target, GLint level)
a895 1
   GLuint texIndex;
d904 12
a915 2
      texIndex = TEXTURE_1D_INDEX;
      break;
d919 12
a930 2
      texIndex = TEXTURE_2D_INDEX;
      break;
d934 12
a945 2
      texIndex = TEXTURE_3D_INDEX;
      break;
d949 12
a960 2
      texIndex = TEXTURE_CUBE_INDEX;
      break;
d964 12
a975 12
      texIndex = TEXTURE_RECT_INDEX;
      break;
   case GL_PROXY_TEXTURE_1D_ARRAY_EXT:
      if (level >= ctx->Const.MaxTextureLevels)
         return NULL;
      texIndex = TEXTURE_1D_ARRAY_INDEX;
      break;
   case GL_PROXY_TEXTURE_2D_ARRAY_EXT:
      if (level >= ctx->Const.MaxTextureLevels)
         return NULL;
      texIndex = TEXTURE_2D_ARRAY_INDEX;
      break;
a978 13

   texImage = ctx->Texture.ProxyTex[texIndex]->Image[0][level];
   if (!texImage) {
      texImage = ctx->Driver.NewTextureImage(ctx);
      if (!texImage) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "proxy texture allocation");
         return NULL;
      }
      ctx->Texture.ProxyTex[texIndex]->Image[0][level] = texImage;
      /* Set the 'back' pointer */
      texImage->TexObject = ctx->Texture.ProxyTex[texIndex];
   }
   return texImage;
d994 1
a994 1
_mesa_max_texture_levels(struct gl_context *ctx, GLenum target)
d1013 1
a1013 2
      return ctx->Extensions.ARB_texture_cube_map
         ? ctx->Const.MaxCubeTextureLevels : 0;
d1016 1
a1016 7
      return ctx->Extensions.NV_texture_rectangle ? 1 : 0;
   case GL_TEXTURE_1D_ARRAY_EXT:
   case GL_PROXY_TEXTURE_1D_ARRAY_EXT:
   case GL_TEXTURE_2D_ARRAY_EXT:
   case GL_PROXY_TEXTURE_2D_ARRAY_EXT:
      return ctx->Extensions.MESA_texture_array
         ? ctx->Const.MaxTextureLevels : 0;
a1022 39
/**
 * Return number of dimensions per mipmap level for the given texture target.
 */
static GLint
get_texture_dimensions(GLenum target)
{
   switch (target) {
   case GL_TEXTURE_1D:
   case GL_PROXY_TEXTURE_1D:
      return 1;
   case GL_TEXTURE_2D:
   case GL_TEXTURE_RECTANGLE:
   case GL_TEXTURE_CUBE_MAP:
   case GL_PROXY_TEXTURE_2D:
   case GL_PROXY_TEXTURE_RECTANGLE:
   case GL_PROXY_TEXTURE_CUBE_MAP:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
   case GL_TEXTURE_1D_ARRAY:
   case GL_PROXY_TEXTURE_1D_ARRAY:
      return 2;
   case GL_TEXTURE_3D:
   case GL_PROXY_TEXTURE_3D:
   case GL_TEXTURE_2D_ARRAY:
   case GL_PROXY_TEXTURE_2D_ARRAY:
      return 3;
   default:
      _mesa_problem(NULL, "invalid target 0x%x in get_texture_dimensions()",
                    target);
      return 2;
   }
}



d1101 1
a1101 1
      free(img->ImageOffsets);
d1111 1
a1111 1
   img->TexFormat = MESA_FORMAT_NONE;
d1114 2
a1129 1
 * \param format  the actual hardware format (one of MESA_FORMAT_*)
d1135 1
a1135 1
_mesa_init_teximage_fields(struct gl_context *ctx, GLenum target,
d1138 1
a1138 2
                           GLint border, GLenum internalFormat,
                           gl_format format)
d1140 1
a1140 1
   GLint i, dims;
a1153 1

d1155 2
d1158 1
a1158 3

   if (height == 1) { /* 1-D texture */
      img->Height2 = 1;
d1160 1
a1160 3
   }
   else {
      img->Height2 = height - 2 * border; /* == 1 << img->HeightLog2; */
d1162 1
a1162 4
   }

   if (depth == 1) {  /* 2-D texture */
      img->Depth2 = 1;
d1164 1
a1164 3
   }
   else {
      img->Depth2 = depth - 2 * border;   /* == 1 << img->DepthLog2; */
a1165 2
   }

d1167 2
d1170 3
a1172 3
   if ((width == 1 || _mesa_is_pow_two(img->Width2)) &&
       (height == 1 || _mesa_is_pow_two(img->Height2)) &&
       (depth == 1 || _mesa_is_pow_two(img->Depth2)))
d1183 1
a1183 3
   if (img->ImageOffsets)
      free(img->ImageOffsets);
   img->ImageOffsets = (GLuint *) malloc(depth * sizeof(GLuint));
a1199 24

   img->TexFormat = format;

   dims = get_texture_dimensions(target);

   _mesa_set_fetch_functions(img, dims);
}


/**
 * Free and clear fields of the gl_texture_image struct.
 *
 * \param ctx GL context.
 * \param texImage texture image structure to be cleared.
 *
 * After the call, \p texImage will have no data associated with it.  Its
 * fields are cleared so that its parent object will test incomplete.
 */
void
_mesa_clear_texture_image(struct gl_context *ctx,
                          struct gl_texture_image *texImage)
{
   ctx->Driver.FreeTexImageData(ctx, texImage);
   clear_teximage_fields(texImage);
d1228 1
a1228 1
_mesa_test_proxy_teximage(struct gl_context *ctx, GLenum target, GLint level,
d1241 5
a1245 3
      if (width < 2 * border || width > 2 + maxSize)
         return GL_FALSE;
      if (level >= ctx->Const.MaxTextureLevels)
a1246 3
      if (!ctx->Extensions.ARB_texture_non_power_of_two) {
         if (width > 0 && !_mesa_is_pow_two(width - 2 * border))
            return GL_FALSE;
a1248 1

d1251 8
a1258 1
      if (width < 2 * border || width > 2 + maxSize)
a1259 9
      if (height < 2 * border || height > 2 + maxSize)
         return GL_FALSE;
      if (level >= ctx->Const.MaxTextureLevels)
         return GL_FALSE;
      if (!ctx->Extensions.ARB_texture_non_power_of_two) {
         if (width > 0 && !_mesa_is_pow_two(width - 2 * border))
            return GL_FALSE;
         if (height > 0 && !_mesa_is_pow_two(height - 2 * border))
            return GL_FALSE;
a1261 1

d1264 11
a1274 7
      if (width < 2 * border || width > 2 + maxSize)
         return GL_FALSE;
      if (height < 2 * border || height > 2 + maxSize)
         return GL_FALSE;
      if (depth < 2 * border || depth > 2 + maxSize)
         return GL_FALSE;
      if (level >= ctx->Const.Max3DTextureLevels)
a1275 7
      if (!ctx->Extensions.ARB_texture_non_power_of_two) {
         if (width > 0 && !_mesa_is_pow_two(width - 2 * border))
            return GL_FALSE;
         if (height > 0 && !_mesa_is_pow_two(height - 2 * border))
            return GL_FALSE;
         if (depth > 0 && !_mesa_is_pow_two(depth - 2 * border))
            return GL_FALSE;
a1277 1

d1279 4
a1282 6
      maxSize = ctx->Const.MaxTextureRectSize;
      if (width < 0 || width > maxSize)
         return GL_FALSE;
      if (height < 0 || height > maxSize)
         return GL_FALSE;
      if (level != 0)
d1284 1
a1285 1

d1288 8
a1295 5
      if (width < 2 * border || width > 2 + maxSize)
         return GL_FALSE;
      if (height < 2 * border || height > 2 + maxSize)
         return GL_FALSE;
      if (level >= ctx->Const.MaxCubeTextureLevels)
a1296 5
      if (!ctx->Extensions.ARB_texture_non_power_of_two) {
         if (width > 0 && !_mesa_is_pow_two(width - 2 * border))
            return GL_FALSE;
         if (height > 0 && !_mesa_is_pow_two(height - 2 * border))
            return GL_FALSE;
a1298 33

   case GL_PROXY_TEXTURE_1D_ARRAY_EXT:
      maxSize = 1 << (ctx->Const.MaxTextureLevels - 1);
      if (width < 2 * border || width > 2 + maxSize)
         return GL_FALSE;
      if (height < 1 || height > ctx->Const.MaxArrayTextureLayers)
         return GL_FALSE;
      if (level >= ctx->Const.MaxTextureLevels)
         return GL_FALSE;
      if (!ctx->Extensions.ARB_texture_non_power_of_two) {
         if (width > 0 && !_mesa_is_pow_two(width - 2 * border))
            return GL_FALSE;
      }
      return GL_TRUE;

   case GL_PROXY_TEXTURE_2D_ARRAY_EXT:
      maxSize = 1 << (ctx->Const.MaxTextureLevels - 1);
      if (width < 2 * border || width > 2 + maxSize)
         return GL_FALSE;
      if (height < 2 * border || height > 2 + maxSize)
         return GL_FALSE;
      if (depth < 1 || depth > ctx->Const.MaxArrayTextureLayers)
         return GL_FALSE;
      if (level >= ctx->Const.MaxTextureLevels)
         return GL_FALSE;
      if (!ctx->Extensions.ARB_texture_non_power_of_two) {
         if (width > 0 && !_mesa_is_pow_two(width - 2 * border))
            return GL_FALSE;
         if (height > 0 && !_mesa_is_pow_two(height - 2 * border))
            return GL_FALSE;
      }
      return GL_TRUE;

d1307 1
a1307 109
 * Check if the memory used by the texture would exceed the driver's limit.
 * This lets us support a max 3D texture size of 8K (for example) but
 * prevents allocating a full 8K x 8K x 8K texture.
 * XXX this could be rolled into the proxy texture size test (above) but
 * we don't have the actual texture internal format at that point.
 */
static GLboolean
legal_texture_size(struct gl_context *ctx, gl_format format,
                   GLint width, GLint height, GLint depth)
{
   uint64_t bytes = _mesa_format_image_size64(format, width, height, depth);
   uint64_t mbytes = bytes / (1024 * 1024); /* convert to MB */
   return mbytes <= (uint64_t) ctx->Const.MaxTextureMbytes;
}



/**
 * Helper function to determine whether a target and specific compression
 * format are supported.
 */
static GLboolean
target_can_be_compressed(const struct gl_context *ctx, GLenum target,
                         GLenum intFormat)
{
   (void) intFormat;  /* not used yet */

   switch (target) {
   case GL_TEXTURE_2D:
   case GL_PROXY_TEXTURE_2D:
      return GL_TRUE; /* true for any compressed format so far */
   case GL_PROXY_TEXTURE_CUBE_MAP:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
      return ctx->Extensions.ARB_texture_cube_map;
   case GL_PROXY_TEXTURE_2D_ARRAY_EXT:
   case GL_TEXTURE_2D_ARRAY_EXT:
      return ctx->Extensions.MESA_texture_array;
   default:
      return GL_FALSE;
   }      
}


/**
 * Check if the given texture target value is legal for a
 * glTexImage1/2/3D call.
 */
static GLboolean
legal_teximage_target(struct gl_context *ctx, GLuint dims, GLenum target)
{
   switch (dims) {
   case 1:
      switch (target) {
      case GL_TEXTURE_1D:
      case GL_PROXY_TEXTURE_1D:
         return GL_TRUE;
      default:
         return GL_FALSE;
      }
   case 2:
      switch (target) {
      case GL_TEXTURE_2D:
      case GL_PROXY_TEXTURE_2D:
         return GL_TRUE;
      case GL_PROXY_TEXTURE_CUBE_MAP:
      case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
      case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
      case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
         return ctx->Extensions.ARB_texture_cube_map;
      case GL_TEXTURE_RECTANGLE_NV:
      case GL_PROXY_TEXTURE_RECTANGLE_NV:
         return ctx->Extensions.NV_texture_rectangle;
      case GL_TEXTURE_1D_ARRAY_EXT:
      case GL_PROXY_TEXTURE_1D_ARRAY_EXT:
         return ctx->Extensions.MESA_texture_array;
      default:
         return GL_FALSE;
      }
   case 3:
      switch (target) {
      case GL_TEXTURE_3D:
      case GL_PROXY_TEXTURE_3D:
         return GL_TRUE;
      case GL_TEXTURE_2D_ARRAY_EXT:
      case GL_PROXY_TEXTURE_2D_ARRAY_EXT:
         return ctx->Extensions.MESA_texture_array;
      default:
         return GL_FALSE;
      }
   default:
      _mesa_problem(ctx, "invalid dims=%u in legal_teximage_target()", dims);
      return GL_FALSE;
   }
}


/**
 * Check if the given texture target value is legal for a
 * glTexSubImage, glCopyTexSubImage or glCopyTexImage call.
 * The difference compared to legal_teximage_target() above is that
 * proxy targets are not supported.
d1310 1
a1310 1
legal_texsubimage_target(struct gl_context *ctx, GLuint dims, GLenum target)
d1312 5
a1316 35
   switch (dims) {
   case 1:
      return target == GL_TEXTURE_1D;
   case 2:
      switch (target) {
      case GL_TEXTURE_2D:
         return GL_TRUE;
      case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
      case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
      case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
         return ctx->Extensions.ARB_texture_cube_map;
      case GL_TEXTURE_RECTANGLE_NV:
         return ctx->Extensions.NV_texture_rectangle;
      case GL_TEXTURE_1D_ARRAY_EXT:
         return ctx->Extensions.MESA_texture_array;
      default:
         return GL_FALSE;
      }
   case 3:
      switch (target) {
      case GL_TEXTURE_3D:
         return GL_TRUE;
      case GL_TEXTURE_2D_ARRAY_EXT:
         return ctx->Extensions.MESA_texture_array;
      default:
         return GL_FALSE;
      }
   default:
      _mesa_problem(ctx, "invalid dims=%u in legal_texsubimage_target()",
                    dims);
      return GL_FALSE;
   }
a1323 1
 * \param dimensions texture image dimensions (must be 1, 2 or 3).
d1329 1
d1338 2
a1339 2
 * __struct gl_contextRec::Const and the supported extensions, and according
 * to the OpenGL specification.
d1342 1
a1342 2
texture_error_check( struct gl_context *ctx,
                     GLuint dimensions, GLenum target,
d1345 1
d1349 1
a1349 2
   const GLenum proxyTarget = get_proxy_target(target);
   const GLboolean isProxy = target == proxyTarget;
d1352 1
d1382 54
a1435 3
   /* Do this simple check before calling the TestProxyTexImage() function */
   if (proxyTarget == GL_PROXY_TEXTURE_CUBE_MAP_ARB) {
      sizeOK = (width == height);
d1438 1
a1438 5
   /*
    * Use the proxy texture driver hook to see if the size/level/etc are
    * legal.
    */
   sizeOK = sizeOK && ctx->Driver.TestProxyTexImage(ctx, proxyTarget, level,
d1455 2
a1456 2
                     "glTexImage%dD(internalFormat=%s)",
                     dimensions, _mesa_lookup_enum_by_nr(internalFormat));
d1463 2
a1464 4
      /* Normally, GL_INVALID_OPERATION is generated by a format/type
       * mismatch (see the 1.2 spec page 94, sec 3.6.4.).  But with the
       * GL_EXT_texture_integer extension, some combinations should generate
       * GL_INVALID_ENUM instead (grr!).
d1467 2
a1468 5
         GLenum error = _mesa_is_integer_format(format)
            ? GL_INVALID_ENUM : GL_INVALID_OPERATION;
         _mesa_error(ctx, error,
                     "glTexImage%dD(incompatible format 0x%x, type 0x%x)",
                     dimensions, format, type);
d1474 7
a1480 8
   colorFormat = _mesa_is_color_format(format);
   indexFormat = _mesa_is_index_format(format);
   if ((_mesa_is_color_format(internalFormat) && !colorFormat && !indexFormat) ||
       (_mesa_is_index_format(internalFormat) && !indexFormat) ||
       (_mesa_is_depth_format(internalFormat) != _mesa_is_depth_format(format)) ||
       (_mesa_is_ycbcr_format(internalFormat) != _mesa_is_ycbcr_format(format)) ||
       (_mesa_is_depthstencil_format(internalFormat) != _mesa_is_depthstencil_format(format)) ||
       (_mesa_is_dudv_format(internalFormat) != _mesa_is_dudv_format(format))) {
d1483 1
a1483 2
                     "glTexImage%dD(incompatible internalFormat 0x%x, format 0x%x)",
                     dimensions, internalFormat, format);
d1493 3
a1495 3
         _mesa_snprintf(message, sizeof(message),
                        "glTexImage%dD(format/type YCBCR mismatch", dimensions);
         _mesa_error(ctx, GL_INVALID_ENUM, "%s", message);
d1509 4
a1512 4
            _mesa_snprintf(message, sizeof(message),
                           "glTexImage%dD(format=GL_YCBCR_MESA and border=%d)",
                           dimensions, border);
            _mesa_error(ctx, GL_INVALID_VALUE, "%s", message);
d1535 4
a1538 5
   if (_mesa_is_compressed_format(ctx, internalFormat)) {
      if (!target_can_be_compressed(ctx, target, internalFormat)) {
         if (!isProxy)
            _mesa_error(ctx, GL_INVALID_ENUM,
                        "glTexImage%dD(target)", dimensions);
d1544 1
a1544 1
                        "glTexImage%dD(border!=0)", dimensions);
a1549 12
   /* additional checks for integer textures */
   if (ctx->Extensions.EXT_texture_integer &&
       (_mesa_is_integer_format(format) !=
        _mesa_is_integer_format(internalFormat))) {
      if (!isProxy) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glTexImage%dD(integer/non-integer format mismatch)",
                     dimensions);
      }
      return GL_TRUE;
   }

d1574 2
a1575 2
 * __struct gl_contextRec::Const and the supported extensions, and according
 * to the OpenGL specification.
d1578 1
a1578 1
subtexture_error_check( struct gl_context *ctx, GLuint dimensions,
d1584 37
a1626 1
   /* Check for negative sizes */
d1644 2
a1645 8
      /* As with the glTexImage2D check above, the error code here
       * depends on texture integer.
       */
      GLenum error = _mesa_is_integer_format(format)
         ? GL_INVALID_OPERATION : GL_INVALID_ENUM;
      _mesa_error(ctx, error,
                  "glTexSubImage%dD(incompatible format 0x%x, type 0x%x)",
                  dimensions, format, type);
a1651 5

/**
 * Do second part of glTexSubImage which depends on the destination texture.
 * \return GL_TRUE if error recorded, GL_FALSE otherwise
 */
d1653 1
a1653 1
subtexture_error_check2( struct gl_context *ctx, GLuint dimensions,
d1699 13
a1711 2
   if (_mesa_is_format_compressed(destTex->TexFormat)) {
      GLuint bw, bh;
d1713 8
a1720 5
      /* do tests which depend on compression block size */
      _mesa_get_format_block_size(destTex->TexFormat, &bw, &bh);

      /* offset must be multiple of block size */
      if ((xoffset % bw != 0) || (yoffset % bh != 0)) {
d1722 1
a1722 2
                     "glTexSubImage%dD(xoffset = %d, yoffset = %d)",
                     dimensions, xoffset, yoffset);
d1725 2
a1726 2
      /* size must be multiple of bw by bh or equal to whole texture size */
      if ((width % bw != 0) && (GLuint) width != destTex->Width) {
d1728 1
a1728 1
                     "glTexSubImage%dD(width = %d)", dimensions, width);
d1731 1
a1731 1
      if ((height % bh != 0) && (GLuint) height != destTex->Height) {
d1733 1
a1733 1
                     "glTexSubImage%dD(height = %d)", dimensions, height);
d1752 1
d1758 2
a1759 2
 * __struct gl_contextRec::Const and the supported extensions, and according
 * to the OpenGL specification.
d1762 1
a1762 1
copytexture_error_check( struct gl_context *ctx, GLuint dimensions,
d1766 1
a1766 2
   const GLenum proxyTarget = get_proxy_target(target);
   const GLenum type = GL_FLOAT;
a1769 7
   /* check target */
   if (!legal_texsubimage_target(ctx, dimensions, target)) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glCopyTexImage%uD(target=%s)",
                  dimensions, _mesa_lookup_enum_by_nr(target));
      return GL_TRUE;
   }       

d1801 2
d1809 2
a1810 3
   /* Do size, level checking */
   sizeOK = (proxyTarget == GL_PROXY_TEXTURE_CUBE_MAP_ARB)
      ? (width == height) : 1;
d1812 53
a1864 4
   sizeOK = sizeOK && ctx->Driver.TestProxyTexImage(ctx, proxyTarget, level,
                                                    internalFormat, format,
                                                    type, width, height,
                                                    1, border);
d1879 2
a1880 2
   if (_mesa_is_compressed_format(ctx, internalFormat)) {
      if (!target_can_be_compressed(ctx, target, internalFormat)) {
d1882 1
a1882 1
                     "glCopyTexImage%dD(target)", dimensions);
d1887 1
a1887 1
                     "glCopyTexImage%dD(border!=0)", dimensions);
d1891 1
a1891 1
   else if (_mesa_is_depth_format(internalFormat)) {
d1895 1
a1895 1
                     "glCopyTexImage%dD(no depth)", dimensions);
d1899 1
a1899 1
   else if (_mesa_is_depthstencil_format(internalFormat)) {
d1903 1
a1903 1
                     "glCopyTexImage%dD(no depth/stencil buffer)", dimensions);
a1914 2
 * Note that this is the first part of error checking.
 * See also copytexsubimage_error_check2() below for the second part.
d1920 5
d1927 4
d1933 4
a1936 2
copytexsubimage_error_check1( struct gl_context *ctx, GLuint dimensions,
                              GLenum target, GLint level)
d1938 1
d1949 30
a1978 5
   /* check target (proxies not allowed) */
   if (!legal_texsubimage_target(ctx, dimensions, target)) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glCopyTexSubImage%uD(target=%s)",
                  dimensions, _mesa_lookup_enum_by_nr(target));
      return GL_TRUE;
d1988 12
a2002 9

/**
 * Second part of error checking for glCopyTexSubImage[12]D().
 * \param xoffset sub-image x offset given by the user.
 * \param yoffset sub-image y offset given by the user.
 * \param zoffset sub-image z offset given by the user.
 * \param width image width given by the user.
 * \param height image height given by the user.
 */
d2004 1
a2004 1
copytexsubimage_error_check2( struct gl_context *ctx, GLuint dimensions,
a2009 1
   /* check that dest tex image exists */
a2016 13
   /* Check size */
   if (width < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glCopyTexSubImage%dD(width=%d)", dimensions, width);
      return GL_TRUE;
   }
   if (dimensions > 1 && height < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glCopyTexSubImage%dD(height=%d)", dimensions, height);
      return GL_TRUE;
   }

   /* check x/y offsets */
a2040 1
   /* check z offset */
d2054 6
a2059 1
   if (_mesa_is_format_compressed(teximage->TexFormat)) {
d2063 1
a2063 1
                     "glCopyTexSubImage%dD(xoffset or yoffset)", dimensions);
d2069 1
a2069 1
                     "glCopyTexSubImage%dD(width)", dimensions);
d2074 1
a2074 1
                     "glCopyTexSubImage%dD(height)", dimensions);
d2086 1
a2086 2
                  "glCopyTexSubImage%dD(missing readbuffer, format=0x%x)",
                  dimensions, teximage->_BaseFormat);
d2093 1
a2093 1
                     "glCopyTexSubImage%dD(no depth buffer)",
d2101 1
a2101 1
                     "glCopyTexSubImage%dD(no depth/stencil buffer)",
a2106 13
   /* If copying into an integer texture, the source buffer must also be
    * integer-valued.
    */
   if (_mesa_is_format_integer_color(teximage->TexFormat)) {
      struct gl_renderbuffer *rb = ctx->ReadBuffer->_ColorReadBuffer;
      if (!_mesa_is_format_integer_color(rb->Format)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glCopyTexSubImage%dD(source buffer is not integer format)",
                  dimensions);
         return GL_TRUE;
      }
   }

a2111 9
/** Callback info for walking over FBO hash table */
struct cb_info
{
   struct gl_context *ctx;
   struct gl_texture_object *texObj;
   GLuint level, face;
};


d2113 7
a2119 1
 * Check render to texture callback.  Called from _mesa_HashWalk().
d2121 3
a2123 2
static void
check_rtt_cb(GLuint key, void *data, void *userData)
d2125 6
a2130 5
   struct gl_framebuffer *fb = (struct gl_framebuffer *) data;
   const struct cb_info *info = (struct cb_info *) userData;
   struct gl_context *ctx = info->ctx;
   const struct gl_texture_object *texObj = info->texObj;
   const GLuint level = info->level, face = info->face;
d2132 5
a2136 17
   /* If this is a user-created FBO */
   if (fb->Name) {
      GLuint i;
      /* check if any of the FBO's attachments point to 'texObj' */
      for (i = 0; i < BUFFER_COUNT; i++) {
         struct gl_renderbuffer_attachment *att = fb->Attachment + i;
         if (att->Type == GL_TEXTURE &&
             att->Texture == texObj &&
             att->TextureLevel == level &&
             att->CubeMapFace == face) {
            ASSERT(att->Texture->Image[att->CubeMapFace][att->TextureLevel]);
            /* Tell driver about the new renderbuffer texture */
            ctx->Driver.RenderTexture(ctx, ctx->DrawBuffer, att);
            /* Mark fb status as indeterminate to force re-validation */
            fb->_Status = 0;
         }
      }
a2137 1
}
d2139 2
d2142 3
a2144 18
/**
 * When a texture image is specified we have to check if it's bound to
 * any framebuffer objects (render to texture) in order to detect changes
 * in size or format since that effects FBO completeness.
 * Any FBOs rendering into the texture must be re-validated.
 */
static void
update_fbo_texture(struct gl_context *ctx, struct gl_texture_object *texObj,
                   GLuint face, GLuint level)
{
   /* Only check this texture if it's been marked as RenderToTexture */
   if (texObj->_RenderToTexture) {
      struct cb_info info;
      info.ctx = ctx;
      info.texObj = texObj;
      info.level = level;
      info.face = face;
      _mesa_HashWalk(ctx->Shared->FrameBuffers, check_rtt_cb, &info);
a2145 1
}
d2147 4
d2152 4
a2155 15
/**
 * If the texture object's GenerateMipmap flag is set and we've
 * changed the texture base level image, regenerate the rest of the
 * mipmap levels now.
 */
static INLINE void
check_gen_mipmap(struct gl_context *ctx, GLenum target,
                 struct gl_texture_object *texObj, GLint level)
{
   ASSERT(target != GL_TEXTURE_CUBE_MAP);
   if (texObj->GenerateMipmap &&
       level == texObj->BaseLevel &&
       level < texObj->MaxLevel) {
      ASSERT(ctx->Driver.GenerateMipmap);
      ctx->Driver.GenerateMipmap(ctx, target, texObj);
a2156 1
}
d2158 4
d2163 4
a2166 29
/** Debug helper: override the user-requested internal format */
static GLenum
override_internal_format(GLenum internalFormat, GLint width, GLint height)
{
#if 0
   if (internalFormat == GL_RGBA16F_ARB ||
       internalFormat == GL_RGBA32F_ARB) {
      printf("Convert rgba float tex to int %d x %d\n", width, height);
      return GL_RGBA;
   }
   else if (internalFormat == GL_RGB16F_ARB ||
            internalFormat == GL_RGB32F_ARB) {
      printf("Convert rgb float tex to int %d x %d\n", width, height);
      return GL_RGB;
   }
   else if (internalFormat == GL_LUMINANCE_ALPHA16F_ARB ||
            internalFormat == GL_LUMINANCE_ALPHA32F_ARB) {
      printf("Convert luminance float tex to int %d x %d\n", width, height);
      return GL_LUMINANCE_ALPHA;
   }
   else if (internalFormat == GL_LUMINANCE16F_ARB ||
            internalFormat == GL_LUMINANCE32F_ARB) {
      printf("Convert luminance float tex to int %d x %d\n", width, height);
      return GL_LUMINANCE;
   }
   else if (internalFormat == GL_ALPHA16F_ARB ||
            internalFormat == GL_ALPHA32F_ARB) {
      printf("Convert luminance float tex to int %d x %d\n", width, height);
      return GL_ALPHA;
d2168 4
a2171 3
   /*
   else if (internalFormat == GL_COMPRESSED_RGBA_S3TC_DXT1_EXT) {
      internalFormat = GL_RGBA;
d2173 5
a2177 3
   */
   else {
      return internalFormat;
d2179 11
a2189 4
#else
   return internalFormat;
#endif
}
d2192 3
a2194 22
/**
 * Choose the actual hardware format for a texture image.
 * Try to use the same format as the previous image level when possible.
 * Otherwise, ask the driver for the best format.
 * It's important to try to choose a consistant format for all levels
 * for efficient texture memory layout/allocation.  In particular, this
 * comes up during automatic mipmap generation.
 */
gl_format
_mesa_choose_texture_format(struct gl_context *ctx,
                            struct gl_texture_object *texObj,
                            GLenum target, GLint level,
                            GLenum internalFormat, GLenum format, GLenum type)
{
   gl_format f;

   /* see if we've already chosen a format for the previous level */
   if (level > 0) {
      struct gl_texture_image *prevImage =
	 _mesa_select_tex_image(ctx, texObj, target, level - 1);
      /* See if the prev level is defined and has an internal format which
       * matches the new internal format.
d2196 38
a2233 6
      if (prevImage &&
          prevImage->Width > 0 &&
          prevImage->InternalFormat == internalFormat) {
         /* use the same format */
         ASSERT(prevImage->TexFormat != MESA_FORMAT_NONE);
         return prevImage->TexFormat;
d2235 5
d2241 3
a2244 5
   /* choose format from scratch */
   f = ctx->Driver.ChooseTextureFormat(ctx, internalFormat, format, type);
   ASSERT(f != MESA_FORMAT_NONE);
   return f;
}
d2248 5
a2252 1
 * Common code to implement all the glTexImage1D/2D/3D functions.
d2255 2
a2256 5
teximage(struct gl_context *ctx, GLuint dims,
         GLenum target, GLint level, GLint internalFormat,
         GLsizei width, GLsizei height, GLsizei depth,
         GLint border, GLenum format, GLenum type,
         const GLvoid *pixels)
d2258 16
a2273 1
   GLboolean error;
d2275 12
d2289 2
a2290 16
   if (MESA_VERBOSE & (VERBOSE_API|VERBOSE_TEXTURE))
      _mesa_debug(ctx, "glTexImage%uD %s %d %s %d %d %d %d %s %s %p\n",
                  dims,
                  _mesa_lookup_enum_by_nr(target), level,
                  _mesa_lookup_enum_by_nr(internalFormat),
                  width, height, depth, border,
                  _mesa_lookup_enum_by_nr(format),
                  _mesa_lookup_enum_by_nr(type), pixels);

   internalFormat = override_internal_format(internalFormat, width, height);

   /* target error checking */
   if (!legal_teximage_target(ctx, dims, target)) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glTexImage%uD(target=%s)",
                  dims, _mesa_lookup_enum_by_nr(target));
      return;
d2293 1
a2293 34
   /* general error checking */
   error = texture_error_check(ctx, dims, target, level, internalFormat,
                               format, type, width, height, depth, border);

   if (_mesa_is_proxy_texture(target)) {
      /* Proxy texture: just clear or set state depending on error checking */
      struct gl_texture_image *texImage =
         _mesa_get_proxy_tex_image(ctx, target, level);

      if (error) {
         /* when error, clear all proxy texture image parameters */
         if (texImage)
            clear_teximage_fields(texImage);
      }
      else {
         /* no error, set the tex image parameters */
         struct gl_texture_object *texObj =
            _mesa_get_current_tex_object(ctx, target);
         gl_format texFormat = _mesa_choose_texture_format(ctx, texObj,
                                                           target, level,
                                                           internalFormat,
                                                           format, type);

         if (legal_texture_size(ctx, texFormat, width, height, depth)) {
            _mesa_init_teximage_fields(ctx, target, texImage, width, height,
                                       depth, border, internalFormat,
                                       texFormat);
         }
         else if (texImage) {
            clear_teximage_fields(texImage);
         }
      }
   }
   else {
d2295 1
a2295 1
      const GLuint face = _mesa_tex_target_to_face(target);
d2298 1
d2300 2
a2301 1
      if (error) {
d2305 1
a2305 1
      if (ctx->NewState & _MESA_NEW_TRANSFER_STATE)
d2308 2
a2309 2
      texObj = _mesa_get_current_tex_object(ctx, target);

a2312 1

d2314 6
a2319 1
	    _mesa_error(ctx, GL_OUT_OF_MEMORY, "glTexImage%uD", dims);
a2320 2
         else {
            gl_format texFormat;
d2322 1
a2322 40
            if (texImage->Data) {
               ctx->Driver.FreeTexImageData( ctx, texImage );
            }

            ASSERT(texImage->Data == NULL);
            texFormat = _mesa_choose_texture_format(ctx, texObj, target, level,
                                                    internalFormat, format,
                                                    type);

            if (legal_texture_size(ctx, texFormat, width, height, depth)) {
               _mesa_init_teximage_fields(ctx, target, texImage,
                                          width, height, depth,
                                          border, internalFormat, texFormat);

               /* Give the texture to the driver.  <pixels> may be null. */
               ASSERT(ctx->Driver.TexImage3D);
               switch (dims) {
               case 1:
                  ctx->Driver.TexImage1D(ctx, target, level, internalFormat,
                                         width, border, format,
                                         type, pixels, &ctx->Unpack, texObj,
                                         texImage);
                  break;
               case 2:
                  ctx->Driver.TexImage2D(ctx, target, level, internalFormat,
                                         width, height, border, format,
                                         type, pixels, &ctx->Unpack, texObj,
                                         texImage);
                  break;
               case 3:
                  ctx->Driver.TexImage3D(ctx, target, level, internalFormat,
                                         width, height, depth, border, format,
                                         type, pixels, &ctx->Unpack, texObj,
                                         texImage);
                  break;
               default:
                  _mesa_problem(ctx, "invalid dims=%u in teximage()", dims);
               }

               check_gen_mipmap(ctx, target, texObj, level);
d2324 19
a2342 10
               update_fbo_texture(ctx, texObj, face, level);

               /* state update */
               texObj->_Complete = GL_FALSE;
               ctx->NewState |= _NEW_TEXTURE;
            }
            else {
               _mesa_error(ctx, GL_OUT_OF_MEMORY, "glTexImage%uD", dims);
            }
         }
d2344 1
d2347 24
a2370 14
}


/*
 * Called from the API.  Note that width includes the border.
 */
void GLAPIENTRY
_mesa_TexImage1D( GLenum target, GLint level, GLint internalFormat,
                  GLsizei width, GLint border, GLenum format,
                  GLenum type, const GLvoid *pixels )
{
   GET_CURRENT_CONTEXT(ctx);
   teximage(ctx, 1, target, level, internalFormat, width, 1, 1,
            border, format, type, pixels);
d2380 1
d2382 94
a2475 2
   teximage(ctx, 2, target, level, internalFormat, width, height, 1,
            border, format, type, pixels);
d2490 77
a2566 2
   teximage(ctx, 3, target, level, internalFormat, width, height, depth,
            border, format, type, pixels);
d2581 1
a2581 1
#if FEATURE_OES_EGL_image
d2583 4
a2586 1
_mesa_EGLImageTargetTexture2DOES (GLenum target, GLeglImageOES image)
d2588 2
d2591 1
a2591 1
   struct gl_texture_image *texImage;
d2595 6
a2600 4
   if (!ctx->Extensions.OES_EGL_image) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glEGLImageTargetTexture2DOES(unsupported)");
      return;
d2603 3
a2605 4
   if (target != GL_TEXTURE_2D) {
      _mesa_error(ctx, GL_INVALID_ENUM,
		  "glEGLImageTargetTexture2D(target=%d)", target);
      return;
a2607 2
   if (ctx->NewState & _MESA_NEW_TRANSFER_STATE)
      _mesa_update_state(ctx);
d2609 4
a2612 1
   texObj = _mesa_get_current_tex_object(ctx, target);
d2614 7
d2622 2
a2623 6
   texImage = _mesa_get_tex_image(ctx, texObj, target, 0);
   if (!texImage) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glEGLImageTargetTexture2D");
   } else {
      if (texImage->Data)
	 ctx->Driver.FreeTexImageData( ctx, texImage );
d2625 2
a2626 3
      ASSERT(texImage->Data == NULL);
      ctx->Driver.EGLImageTargetTexture2D(ctx, target,
					  texObj, texImage, image);
d2628 4
a2631 2
      /* state update */
      texObj->_Complete = GL_FALSE;
d2634 1
a2635 1

a2636 1
#endif
d2639 6
a2644 9

/**
 * Implement all the glTexSubImage1/2/3D() functions.
 */
static void
texsubimage(struct gl_context *ctx, GLuint dims, GLenum target, GLint level,
            GLint xoffset, GLint yoffset, GLint zoffset,
            GLsizei width, GLsizei height, GLsizei depth,
            GLenum format, GLenum type, const GLvoid *pixels )
d2646 2
d2650 1
a2650 1

d2653 2
a2654 14
   if (MESA_VERBOSE & (VERBOSE_API|VERBOSE_TEXTURE))
      _mesa_debug(ctx, "glTexSubImage%uD %s %d %d %d %d %d %d %d %s %s %p\n",
                  dims,
                  _mesa_lookup_enum_by_nr(target), level,
                  xoffset, yoffset, zoffset, width, height, depth,
                  _mesa_lookup_enum_by_nr(format),
                  _mesa_lookup_enum_by_nr(type), pixels);

   /* check target (proxies not allowed) */
   if (!legal_texsubimage_target(ctx, dims, target)) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glTexSubImage%uD(target=%s)",
                  dims, _mesa_lookup_enum_by_nr(target));
      return;
   }       
d2656 5
a2660 2
   if (ctx->NewState & _MESA_NEW_TRANSFER_STATE)
      _mesa_update_state(ctx);
d2662 2
a2663 2
   if (subtexture_error_check(ctx, dims, target, level, xoffset, yoffset, zoffset,
                              width, height, depth, format, type)) {
d2667 2
a2668 2
   texObj = _mesa_get_current_tex_object(ctx, target);

d2673 18
a2690 47
      if (subtexture_error_check2(ctx, dims, target, level,
                                  xoffset, yoffset, zoffset,
				  width, height, depth,
                                  format, type, texImage)) {
         /* error was recorded */
      }
      else if (width > 0 && height > 0 && depth > 0) {
         /* If we have a border, offset=-1 is legal.  Bias by border width. */
         switch (dims) {
         case 3:
            zoffset += texImage->Border;
            /* fall-through */
         case 2:
            yoffset += texImage->Border;
            /* fall-through */
         case 1:
            xoffset += texImage->Border;
         }

         switch (dims) {
         case 1:
            ctx->Driver.TexSubImage1D(ctx, target, level,
                                      xoffset, width,
                                      format, type, pixels,
                                      &ctx->Unpack, texObj, texImage );
            break;
         case 2:
            ctx->Driver.TexSubImage2D(ctx, target, level,
                                      xoffset, yoffset, width, height,
                                      format, type, pixels,
                                      &ctx->Unpack, texObj, texImage );
            break;
         case 3:
            ctx->Driver.TexSubImage3D(ctx, target, level,
                                      xoffset, yoffset, zoffset,
                                      width, height, depth,
                                      format, type, pixels,
                                      &ctx->Unpack, texObj, texImage );
            break;
         default:
            _mesa_problem(ctx, "unexpected dims in subteximage()");
         }

         check_gen_mipmap(ctx, target, texObj, level);

         ctx->NewState |= _NEW_TEXTURE;
      }
d2692 1
d2697 1
d2699 3
a2701 2
_mesa_TexSubImage1D( GLenum target, GLint level,
                     GLint xoffset, GLsizei width,
d2705 3
d2709 1
a2709 5
   texsubimage(ctx, 1, target, level,
               xoffset, 0, 0,
               width, 1, 1,
               format, type, pixels);
}
d2711 2
d2714 4
a2717 13
void GLAPIENTRY
_mesa_TexSubImage2D( GLenum target, GLint level,
                     GLint xoffset, GLint yoffset,
                     GLsizei width, GLsizei height,
                     GLenum format, GLenum type,
                     const GLvoid *pixels )
{
   GET_CURRENT_CONTEXT(ctx);
   texsubimage(ctx, 2, target, level,
               xoffset, yoffset, 0,
               width, height, 1,
               format, type, pixels);
}
d2719 2
d2722 3
d2726 23
a2748 12
void GLAPIENTRY
_mesa_TexSubImage3D( GLenum target, GLint level,
                     GLint xoffset, GLint yoffset, GLint zoffset,
                     GLsizei width, GLsizei height, GLsizei depth,
                     GLenum format, GLenum type,
                     const GLvoid *pixels )
{
   GET_CURRENT_CONTEXT(ctx);
   texsubimage(ctx, 3, target, level,
               xoffset, yoffset, zoffset,
               width, height, depth,
               format, type, pixels);
d2753 5
a2757 7
/**
 * Implement the glCopyTexImage1/2D() functions.
 */
static void
copyteximage(struct gl_context *ctx, GLuint dims,
             GLenum target, GLint level, GLenum internalFormat,
             GLint x, GLint y, GLsizei width, GLsizei height, GLint border )
d2759 1
d2762 3
a2764 2
   const GLuint face = _mesa_tex_target_to_face(target);

d2767 2
a2768 6
   if (MESA_VERBOSE & (VERBOSE_API|VERBOSE_TEXTURE))
      _mesa_debug(ctx, "glCopyTexImage%uD %s %d %s %d %d %d %d %d\n",
                  dims,
                  _mesa_lookup_enum_by_nr(target), level,
                  _mesa_lookup_enum_by_nr(internalFormat),
                  x, y, width, height, border);
d2770 3
a2772 2
   if (ctx->NewState & NEW_COPY_TEX_STATE)
      _mesa_update_state(ctx);
d2774 2
a2775 2
   if (copytexture_error_check(ctx, dims, target, level, internalFormat,
                               width, height, border))
d2778 2
a2779 2
   texObj = _mesa_get_current_tex_object(ctx, target);

d2783 4
d2788 2
a2789 2
      if (!texImage) {
	 _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCopyTexImage%uD", dims);
d2791 2
a2792 2
      else {
         gl_format texFormat;
d2794 3
a2796 3
         if (texImage->Data) {
            ctx->Driver.FreeTexImageData( ctx, texImage );
         }
a2797 1
         ASSERT(texImage->Data == NULL);
d2799 3
a2801 31
         texFormat = _mesa_choose_texture_format(ctx, texObj, target, level,
                                                 internalFormat, GL_NONE,
                                                 GL_NONE);

         if (legal_texture_size(ctx, texFormat, width, height, 1)) {
            _mesa_init_teximage_fields(ctx, target, texImage, width, height, 1,
                                       border, internalFormat, texFormat);

            ASSERT(ctx->Driver.CopyTexImage2D);
            if (dims == 1)
               ctx->Driver.CopyTexImage1D(ctx, target, level, internalFormat,
                                          x, y, width, border);
            else
               ctx->Driver.CopyTexImage2D(ctx, target, level, internalFormat,
                                          x, y, width, height, border);

            check_gen_mipmap(ctx, target, texObj, level);

            update_fbo_texture(ctx, texObj, face, level);

            /* state update */
            texObj->_Complete = GL_FALSE;
            ctx->NewState |= _NEW_TEXTURE;
         }
         else {
            _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCopyTexImage%uD", dims);
         }
      }
   }
   _mesa_unlock_texture(ctx, texObj);
}
d2803 1
d2805 1
d2807 6
a2812 8
void GLAPIENTRY
_mesa_CopyTexImage1D( GLenum target, GLint level,
                      GLenum internalFormat,
                      GLint x, GLint y,
                      GLsizei width, GLint border )
{
   GET_CURRENT_CONTEXT(ctx);
   copyteximage(ctx, 1, target, level, internalFormat, x, y, width, 1, border);
d2822 1
a2822 15
   GET_CURRENT_CONTEXT(ctx);
   copyteximage(ctx, 2, target, level, internalFormat,
                x, y, width, height, border);
}



/**
 * Implementation for glCopyTexSubImage1/2/3D() functions.
 */
static void
copytexsubimage(struct gl_context *ctx, GLuint dims, GLenum target, GLint level,
                GLint xoffset, GLint yoffset, GLint zoffset,
                GLint x, GLint y, GLsizei width, GLsizei height)
{
d2825 3
a2827 1

d2830 2
a2831 5
   if (MESA_VERBOSE & (VERBOSE_API|VERBOSE_TEXTURE))
      _mesa_debug(ctx, "glCopyTexSubImage%uD %s %d %d %d %d %d %d %d %d\n",
                  dims,
                  _mesa_lookup_enum_by_nr(target),
                  level, xoffset, yoffset, zoffset, x, y, width, height);
d2833 4
a2836 2
   if (ctx->NewState & NEW_COPY_TEX_STATE)
      _mesa_update_state(ctx);
d2838 2
a2839 1
   if (copytexsubimage_error_check1(ctx, dims, target, level))
d2842 2
a2843 1
   texObj = _mesa_get_current_tex_object(ctx, target);
d2847 1
a2847 1
      texImage = _mesa_select_tex_image(ctx, texObj, target, level);
d2849 7
a2855 3
      if (copytexsubimage_error_check2(ctx, dims, target, level, xoffset, yoffset,
				       zoffset, width, height, texImage)) {
         /* error was recored */
d2857 2
a2858 12
      else {
         /* If we have a border, offset=-1 is legal.  Bias by border width. */
         switch (dims) {
         case 3:
            zoffset += texImage->Border;
            /* fall-through */
         case 2:
            yoffset += texImage->Border;
            /* fall-through */
         case 1:
            xoffset += texImage->Border;
         }
d2860 10
a2869 20
         if (_mesa_clip_copytexsubimage(ctx, &xoffset, &yoffset, &x, &y,
                                        &width, &height)) {
            switch (dims) {
            case 1:
               ctx->Driver.CopyTexSubImage1D(ctx, target, level,
                                             xoffset, x, y, width);
               break;
            case 2:
               ctx->Driver.CopyTexSubImage2D(ctx, target, level,
                                             xoffset, yoffset,
                                             x, y, width, height);
               break;
            case 3:
               ctx->Driver.CopyTexSubImage3D(ctx, target, level,
                                             xoffset, yoffset, zoffset,
                                             x, y, width, height);
               break;
            default:
               _mesa_problem(ctx, "bad dims in copytexsubimage()");
            }
d2871 1
a2871 1
            check_gen_mipmap(ctx, target, texObj, level);
d2873 3
a2875 3
            ctx->NewState |= _NEW_TEXTURE;
         }
      }
d2877 1
d2886 4
d2891 34
a2924 1
   copytexsubimage(ctx, 1, target, level, xoffset, 0, 0, x, y, width, 1);
d2934 4
d2939 34
a2972 2
   copytexsubimage(ctx, 2, target, level, xoffset, yoffset, 0, x, y,
                   width, height);
d2982 4
d2987 1
a2987 3
   copytexsubimage(ctx, 3, target, level, xoffset, yoffset, zoffset,
                   x, y, width, height);
}
d2989 2
d2992 2
d2995 3
d2999 2
a3000 3
/**********************************************************************/
/******                   Compressed Textures                    ******/
/**********************************************************************/
d3002 3
d3006 18
a3023 9
/**
 * Return expected size of a compressed texture.
 */
static GLuint
compressed_tex_size(GLsizei width, GLsizei height, GLsizei depth,
                    GLenum glformat)
{
   gl_format mesaFormat = _mesa_glenum_to_compressed_format(glformat);
   return _mesa_format_image_size(mesaFormat, width, height, depth);
d3027 5
a3031 9
/*
 * Return compressed texture block size, in pixels.
 */
static void
get_compressed_block_size(GLenum glformat, GLuint *bw, GLuint *bh)
{
   gl_format mesaFormat = _mesa_glenum_to_compressed_format(glformat);
   _mesa_get_format_block_size(mesaFormat, bw, bh);
}
d3039 1
a3039 1
compressed_texture_error_check(struct gl_context *ctx, GLint dimensions,
d3045 1
a3045 3
   const GLenum proxyTarget = get_proxy_target(target);
   const GLint maxLevels = _mesa_max_texture_levels(ctx, target);
   GLint expectedSize;
d3047 28
a3074 5
   /* check level */
   if (level < 0 || level >= maxLevels)
      return GL_INVALID_VALUE;

   if (!target_can_be_compressed(ctx, target, internalFormat)) {
d3078 2
d3081 1
a3081 1
   if (!_mesa_is_compressed_format(ctx, internalFormat))
a3087 1
   /* No compressed formats support borders at this time */
d3091 17
d3113 7
a3119 18
   /* check image size against compression block size */
   {
      gl_format texFormat =
         ctx->Driver.ChooseTextureFormat(ctx, internalFormat,
                                         GL_NONE, GL_NONE);
      GLuint bw, bh;

      _mesa_get_format_block_size(texFormat, &bw, &bh);
      if ((width > bw && width % bw > 0) ||
          (height > bh && height % bh > 0)) {
         /*
          * Per GL_ARB_texture_compression:  GL_INVALID_OPERATION is
          * generated [...] if any parameter combinations are not
          * supported by the specific compressed internal format. 
          */
         return GL_INVALID_OPERATION;
      }
   }
d3121 6
a3126 5
   /* check image sizes */
   if (!ctx->Driver.TestProxyTexImage(ctx, proxyTarget, level,
                                      internalFormat, GL_NONE, GL_NONE,
                                      width, height, depth, border)) {
      /* See error comment above */
d3129 1
a3129 10

   /* check image size in bytes */
   expectedSize = compressed_tex_size(width, height, depth, internalFormat);
   if (expectedSize != imageSize) {
      /* Per GL_ARB_texture_compression:  GL_INVALID_VALUE is generated [...]
       * if <imageSize> is not consistent with the format, dimensions, and
       * contents of the specified image.
       */
      return GL_INVALID_VALUE;
   }
d3143 1
a3143 1
compressed_subtexture_error_check(struct gl_context *ctx, GLint dimensions,
a3149 1
   GLuint bw, bh;
d3186 1
a3186 1
   if (!_mesa_is_compressed_format(ctx, format))
d3199 2
a3200 2
   /*
    * do checks which depend on compression block size
d3202 1
a3202 3
   get_compressed_block_size(format, &bw, &bh);

   if ((xoffset % bw != 0) || (yoffset % bh != 0))
d3205 1
a3205 1
   if ((width % bw != 0) && width != 2 && width != 1)
d3208 1
a3208 1
   if ((height % bh != 0) && height != 2 && height != 1)
d3211 2
a3212 1
   expectedSize = compressed_tex_size(width, height, depth, format);
d3220 6
a3225 9
/**
 * Do second part of glCompressedTexSubImage error checking.
 * \return GL_TRUE if error found, GL_FALSE otherwise.
 */
static GLboolean
compressed_subtexture_error_check2(struct gl_context *ctx, GLuint dims,
                                   GLsizei width, GLsizei height,
                                   GLsizei depth, GLenum format,
                                   struct gl_texture_image *texImage)
d3227 14
d3242 15
a3256 5
   if ((GLint) format != texImage->InternalFormat) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glCompressedTexSubImage%uD(format=0x%x)", dims, format);
      return GL_TRUE;
   }
d3258 2
a3259 7
   if (((width == 1 || width == 2) &&
        width != (GLsizei) texImage->Width) ||
       (width > (GLsizei) texImage->Width)) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glCompressedTexSubImage%uD(width=%d)", dims, width);
      return GL_TRUE;
   }
d3261 9
a3269 7
   if (dims >= 2) {
      if (((height == 1 || height == 2) &&
           height != (GLsizei) texImage->Height) ||
          (height > (GLsizei) texImage->Height)) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glCompressedTexSubImage%uD(height=%d)", dims, height);
         return GL_TRUE;
d3271 2
d3274 32
a3305 8

   if (dims >= 3) {
      if (((depth == 1 || depth == 2) &&
           depth != (GLsizei) texImage->Depth) ||
          (depth > (GLsizei) texImage->Depth)) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glCompressedTexSubImage%uD(depth=%d)", dims, depth);
         return GL_TRUE;
d3308 4
a3311 2

   return GL_FALSE;
d3315 5
a3319 9
/**
 * Implementation of the glCompressedTexImage1/2/3D() functions.
 */
static void
compressedteximage(struct gl_context *ctx, GLuint dims,
                   GLenum target, GLint level,
                   GLenum internalFormat, GLsizei width,
                   GLsizei height, GLsizei depth, GLint border,
                   GLsizei imageSize, const GLvoid *data)
d3321 2
a3322 1
   GLenum error;
d3324 14
a3337 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d3339 2
a3340 14
   if (MESA_VERBOSE & (VERBOSE_API|VERBOSE_TEXTURE))
      _mesa_debug(ctx,
                  "glCompressedTexImage%uDARB %s %d %s %d %d %d %d %d %p\n",
                  dims,
                  _mesa_lookup_enum_by_nr(target), level,
                  _mesa_lookup_enum_by_nr(internalFormat),
                  width, height, depth, border, imageSize, data);

   /* check target */
   if (!legal_teximage_target(ctx, dims, target)) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glCompressedTexImage%uD(target=%s)",
                  dims, _mesa_lookup_enum_by_nr(target));
      return;
   }
d3342 12
a3353 3
   error = compressed_texture_error_check(ctx, dims, target, level,
                                          internalFormat, width, height, depth,
                                          border, imageSize);
d3355 2
a3356 6
#if FEATURE_ES
   /* XXX this is kind of a hack */
   if (error) {
      _mesa_error(ctx, error, "glTexImage2D");
      return;
   }
d3358 9
a3366 15
   if (dims == 2) {
      switch (internalFormat) {
      case GL_PALETTE4_RGB8_OES:
      case GL_PALETTE4_RGBA8_OES:
      case GL_PALETTE4_R5_G6_B5_OES:
      case GL_PALETTE4_RGBA4_OES:
      case GL_PALETTE4_RGB5_A1_OES:
      case GL_PALETTE8_RGB8_OES:
      case GL_PALETTE8_RGBA8_OES:
      case GL_PALETTE8_R5_G6_B5_OES:
      case GL_PALETTE8_RGBA4_OES:
      case GL_PALETTE8_RGB5_A1_OES:
         _mesa_cpal_compressed_teximage2d(target, level, internalFormat,
                                          width, height, imageSize, data);
         return;
d3368 2
d3371 6
a3376 6
#endif

   if (_mesa_is_proxy_texture(target)) {
      /* Proxy texture: just check for errors and update proxy state */
      struct gl_texture_image *texImage;

d3378 4
a3381 8
         struct gl_texture_object *texObj =
            _mesa_get_current_tex_object(ctx, target);
         gl_format texFormat =
            _mesa_choose_texture_format(ctx, texObj, target, level,
                                        internalFormat, GL_NONE, GL_NONE);
         if (!legal_texture_size(ctx, texFormat, width, height, depth)) {
            error = GL_OUT_OF_MEMORY;
         }
d3383 5
a3387 5

      texImage = _mesa_get_proxy_tex_image(ctx, target, level);
      if (texImage) {
         if (error) {
            /* if error, clear all proxy texture image parameters */
d3389 16
a3404 7
         }
         else {
            /* no error: store the teximage parameters */
            _mesa_init_teximage_fields(ctx, target, texImage, width, height,
                                       depth, border, internalFormat,
                                       MESA_FORMAT_NONE);
         }
d3408 16
d3425 1
d3428 2
a3429 1

d3431 1
a3431 1
         _mesa_error(ctx, error, "glCompressedTexImage%uD", dims);
d3435 2
a3436 2
      texObj = _mesa_get_current_tex_object(ctx, target);

d3441 6
a3446 2
	    _mesa_error(ctx, GL_OUT_OF_MEMORY,
                        "glCompressedTexImage%uD", dims);
d3448 1
a3448 45
         else {
            gl_format texFormat;

            if (texImage->Data) {
               ctx->Driver.FreeTexImageData( ctx, texImage );
            }
            ASSERT(texImage->Data == NULL);

            texFormat = _mesa_choose_texture_format(ctx, texObj, target, level,
                                                    internalFormat, GL_NONE,
                                                    GL_NONE);

            if (legal_texture_size(ctx, texFormat, width, height, depth)) {
               _mesa_init_teximage_fields(ctx, target, texImage,
                                          width, height, depth,
                                          border, internalFormat, texFormat);

               switch (dims) {
               case 1:
                  ASSERT(ctx->Driver.CompressedTexImage1D);
                  ctx->Driver.CompressedTexImage1D(ctx, target, level,
                                                   internalFormat,
                                                   width,
                                                   border, imageSize, data,
                                                   texObj, texImage);
                  break;
               case 2:
                  ASSERT(ctx->Driver.CompressedTexImage2D);
                  ctx->Driver.CompressedTexImage2D(ctx, target, level,
                                                   internalFormat,
                                                   width, height,
                                                   border, imageSize, data,
                                                   texObj, texImage);
                  break;
               case 3:
                  ASSERT(ctx->Driver.CompressedTexImage3D);
                  ctx->Driver.CompressedTexImage3D(ctx, target, level,
                                                   internalFormat,
                                                   width, height, depth,
                                                   border, imageSize, data,
                                                   texObj, texImage);
                  break;
               default:
                  _mesa_problem(ctx, "bad dims in compressedteximage");
               }
d3450 2
a3451 1
               check_gen_mipmap(ctx, target, texObj, level);
d3453 10
a3462 9
               /* state update */
               texObj->_Complete = GL_FALSE;
               ctx->NewState |= _NEW_TEXTURE;
            }
            else {
               _mesa_error(ctx, GL_OUT_OF_MEMORY,
                           "glCompressedTexImage%uD", dims);
            }
         }
d3464 1
d3467 37
d3508 3
a3510 4
_mesa_CompressedTexImage1DARB(GLenum target, GLint level,
                              GLenum internalFormat, GLsizei width,
                              GLint border, GLsizei imageSize,
                              const GLvoid *data)
d3512 4
d3517 42
a3558 2
   compressedteximage(ctx, 1, target, level, internalFormat,
                      width, 1, 1, border, imageSize, data);
d3563 4
a3566 4
_mesa_CompressedTexImage2DARB(GLenum target, GLint level,
                              GLenum internalFormat, GLsizei width,
                              GLsizei height, GLint border, GLsizei imageSize,
                              const GLvoid *data)
d3568 4
d3573 11
a3583 3
   compressedteximage(ctx, 2, target, level, internalFormat,
                      width, height, 1, border, imageSize, data);
}
d3585 6
d3592 25
a3616 9
void GLAPIENTRY
_mesa_CompressedTexImage3DARB(GLenum target, GLint level,
                              GLenum internalFormat, GLsizei width,
                              GLsizei height, GLsizei depth, GLint border,
                              GLsizei imageSize, const GLvoid *data)
{
   GET_CURRENT_CONTEXT(ctx);
   compressedteximage(ctx, 3, target, level, internalFormat,
                      width, height, depth, border, imageSize, data);
d3620 5
a3624 8
/**
 * Common helper for glCompressedTexSubImage1/2/3D().
 */
static void
compressed_tex_sub_image(GLuint dims, GLenum target, GLint level,
                         GLint xoffset, GLint yoffset, GLint zoffset,
                         GLsizei width, GLsizei height, GLsizei depth,
                         GLenum format, GLsizei imageSize, const GLvoid *data)
d3626 1
d3633 3
a3635 3
   error = compressed_subtexture_error_check(ctx, dims, target, level,
                                             xoffset, 0, 0, /* pos */
                                             width, height, depth,   /* size */
d3638 1
a3638 1
      _mesa_error(ctx, error, "glCompressedTexSubImage%uD", dims);
d3642 2
a3643 2
   texObj = _mesa_get_current_tex_object(ctx, target);

d3649 22
a3670 39
      if (compressed_subtexture_error_check2(ctx, dims, width, height, depth,
                                             format, texImage)) {
         /* error was recorded */
      }
      else if (width > 0 && height > 0 && depth > 0) {
         switch (dims) {
         case 1:
            if (ctx->Driver.CompressedTexSubImage1D) {
               ctx->Driver.CompressedTexSubImage1D(ctx, target, level,
                                                   xoffset, width,
                                                   format, imageSize, data,
                                                   texObj, texImage);
            }
            break;
         case 2:
            if (ctx->Driver.CompressedTexSubImage2D) {
               ctx->Driver.CompressedTexSubImage2D(ctx, target, level,
                                                   xoffset, yoffset,
                                                   width, height,
                                                   format, imageSize, data,
                                                   texObj, texImage);
            }
            break;
         case 3:
            if (ctx->Driver.CompressedTexSubImage3D) {
               ctx->Driver.CompressedTexSubImage3D(ctx, target, level,
                                                   xoffset, yoffset, zoffset,
                                                   width, height, depth,
                                                   format, imageSize, data,
                                                   texObj, texImage);
            }
            break;
         default:
            ;
         }

         check_gen_mipmap(ctx, target, texObj, level);

         ctx->NewState |= _NEW_TEXTURE;
d3672 1
d3674 1
d3680 1
a3680 3
_mesa_CompressedTexSubImage1DARB(GLenum target, GLint level, GLint xoffset,
                                 GLsizei width, GLenum format,
                                 GLsizei imageSize, const GLvoid *data)
d3682 27
a3708 3
   compressed_tex_sub_image(1, target, level, xoffset, 0, 0, width, 1, 1,
                            format, imageSize, data);
}
d3711 8
a3718 9
void GLAPIENTRY
_mesa_CompressedTexSubImage2DARB(GLenum target, GLint level, GLint xoffset,
                                 GLint yoffset, GLsizei width, GLsizei height,
                                 GLenum format, GLsizei imageSize,
                                 const GLvoid *data)
{
   compressed_tex_sub_image(2, target, level, xoffset, yoffset, 0,
                            width, height, 1, format, imageSize, data);
}
d3720 4
d3725 5
a3729 8
void GLAPIENTRY
_mesa_CompressedTexSubImage3DARB(GLenum target, GLint level, GLint xoffset,
                                 GLint yoffset, GLint zoffset, GLsizei width,
                                 GLsizei height, GLsizei depth, GLenum format,
                                 GLsizei imageSize, const GLvoid *data)
{
   compressed_tex_sub_image(3, target, level, xoffset, yoffset, zoffset,
                            width, height, depth, format, imageSize, data);
@


1.1.1.5
log
@Import Mesa 9.2.0
@
text
@d2 2
a3 1
 * Mesa 3-D graphics library
d21 3
a23 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
d32 1
a32 1
#include <stdbool.h>
a42 1
#include "multisample.h"
d45 1
a45 1
#include "texcompress_cpal.h"
a46 1
#include "texobj.h"
d48 1
a48 1
#include "texstorage.h"
a49 1
#include "glformats.h"
d57 54
a110 1
#define NEW_COPY_TEX_STATE (_NEW_BUFFERS | _NEW_PIXEL)
d126 2
d138 1
a138 1
         return (ctx->API != API_OPENGL_CORE) ? GL_ALPHA : -1;
d145 1
a145 1
         return (ctx->API != API_OPENGL_CORE) ? GL_LUMINANCE : -1;
d154 1
a154 1
         return (ctx->API != API_OPENGL_CORE) ? GL_LUMINANCE_ALPHA : -1;
d160 1
a160 1
         return (ctx->API != API_OPENGL_CORE) ? GL_INTENSITY : -1;
a161 1
         return (ctx->API != API_OPENGL_CORE) ? GL_RGB : -1;
a171 1
         return (ctx->API != API_OPENGL_CORE) ? GL_RGBA : -1;
d185 1
a185 12
   /* GL_BGRA can be an internal format *only* in OpenGL ES (1.x or 2.0).
    */
   if (_mesa_is_gles(ctx)) {
      switch (internalFormat) {
         case GL_BGRA:
            return GL_RGBA;
         default:
            ; /* fallthrough */
      }
   }

   if (ctx->Extensions.ARB_ES2_compatibility) {
d187 8
a194 2
         case GL_RGB565:
            return GL_RGB;
d228 1
a228 1

d240 1
a240 3
   /* Assume that the ANGLE flag will always be set if the EXT flag is set.
    */
   if (ctx->Extensions.ANGLE_texture_compression_dxt) {
d253 1
a253 2
   if (_mesa_is_desktop_gl(ctx)
       && ctx->Extensions.ANGLE_texture_compression_dxt) {
d306 1
a306 1
   if (ctx->Extensions.EXT_texture_snorm) {
a307 12
         case GL_RED_SNORM:
         case GL_R8_SNORM:
         case GL_R16_SNORM:
            return GL_RED;
         case GL_RG_SNORM:
         case GL_RG8_SNORM:
         case GL_RG16_SNORM:
            return GL_RG;
         case GL_RGB_SNORM:
         case GL_RGB8_SNORM:
         case GL_RGB16_SNORM:
            return GL_RGB;
a309 1
         case GL_RGBA16_SNORM:
a310 16
         case GL_ALPHA_SNORM:
         case GL_ALPHA8_SNORM:
         case GL_ALPHA16_SNORM:
            return GL_ALPHA;
         case GL_LUMINANCE_SNORM:
         case GL_LUMINANCE8_SNORM:
         case GL_LUMINANCE16_SNORM:
            return GL_LUMINANCE;
         case GL_LUMINANCE_ALPHA_SNORM:
         case GL_LUMINANCE8_ALPHA8_SNORM:
         case GL_LUMINANCE16_ALPHA16_SNORM:
            return GL_LUMINANCE_ALPHA;
         case GL_INTENSITY_SNORM:
         case GL_INTENSITY8_SNORM:
         case GL_INTENSITY16_SNORM:
            return GL_INTENSITY;
d326 1
d332 1
a333 2
      case GL_COMPRESSED_SRGB_S3TC_DXT1_EXT:
         return ctx->Extensions.EXT_texture_compression_s3tc ? GL_RGB : -1;
a336 1
         return GL_RGBA;
d340 1
a340 1
         return ctx->Extensions.EXT_texture_compression_s3tc ? GL_RGBA : -1;
d343 1
a347 1
      case GL_COMPRESSED_SLUMINANCE_EXT:
d353 1
d355 1
a355 2
   if (ctx->Version >= 30 ||
       ctx->Extensions.EXT_texture_integer) {
a362 1
      case GL_RGB10_A2UI:
a370 5
      }
   }

   if (ctx->Extensions.EXT_texture_integer) {
      switch (internalFormat) {
d422 1
a422 1
	 if (ctx->Version < 30 && !ctx->Extensions.EXT_texture_integer)
d447 1
a447 1
	 if (ctx->Version < 30 && !ctx->Extensions.EXT_texture_integer)
a501 71
   if (ctx->Extensions.EXT_texture_compression_latc) {
      switch (internalFormat) {
      case GL_COMPRESSED_LUMINANCE_LATC1_EXT:
      case GL_COMPRESSED_SIGNED_LUMINANCE_LATC1_EXT:
         return GL_LUMINANCE;
      case GL_COMPRESSED_LUMINANCE_ALPHA_LATC2_EXT:
      case GL_COMPRESSED_SIGNED_LUMINANCE_ALPHA_LATC2_EXT:
         return GL_LUMINANCE_ALPHA;
      default:
         ; /* fallthrough */
      }
   }

   if (ctx->Extensions.ATI_texture_compression_3dc) {
      switch (internalFormat) {
      case GL_COMPRESSED_LUMINANCE_ALPHA_3DC_ATI:
         return GL_LUMINANCE_ALPHA;
      default:
         ; /* fallthrough */
      }
   }

   if (ctx->Extensions.OES_compressed_ETC1_RGB8_texture) {
      switch (internalFormat) {
      case GL_ETC1_RGB8_OES:
         return GL_RGB;
      default:
         ; /* fallthrough */
      }
   }

   if (_mesa_is_gles3(ctx) || ctx->Extensions.ARB_ES3_compatibility) {
      switch (internalFormat) {
      case GL_COMPRESSED_RGB8_ETC2:
      case GL_COMPRESSED_SRGB8_ETC2:
         return GL_RGB;
      case GL_COMPRESSED_RGBA8_ETC2_EAC:
      case GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:
      case GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:
      case GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:
         return GL_RGBA;
      case GL_COMPRESSED_R11_EAC:
      case GL_COMPRESSED_SIGNED_R11_EAC:
         return GL_RED;
      case GL_COMPRESSED_RG11_EAC:
      case GL_COMPRESSED_SIGNED_RG11_EAC:
         return GL_RG;
      default:
         ; /* fallthrough */
      }
   }

   if (ctx->API == API_OPENGLES) {
      switch (internalFormat) {
      case GL_PALETTE4_RGB8_OES:
      case GL_PALETTE4_R5_G6_B5_OES:
      case GL_PALETTE8_RGB8_OES:
      case GL_PALETTE8_R5_G6_B5_OES:
	 return GL_RGB;
      case GL_PALETTE4_RGBA8_OES:
      case GL_PALETTE8_RGB5_A1_OES:
      case GL_PALETTE4_RGBA4_OES:
      case GL_PALETTE4_RGB5_A1_OES:
      case GL_PALETTE8_RGBA8_OES:
      case GL_PALETTE8_RGBA4_OES:
	 return GL_RGBA;
      default:
         ; /* fallthrough */
      }
   }

d513 2
a514 1
   if (_mesa_is_cube_face(target))
d523 2
a524 2
 * Install gl_texture_image in a gl_texture_object according to the target
 * and level parameters.
d530 2
d533 4
a536 4
static void
set_tex_image(struct gl_texture_object *tObj,
              GLenum target, GLint level,
              struct gl_texture_image *texImage)
d542 1
a542 2
   if (target == GL_TEXTURE_RECTANGLE_NV || target == GL_TEXTURE_EXTERNAL_OES)
      assert(level == 0);
a547 2
   texImage->Level = level;
   texImage->Face = face;
d553 1
a553 1
 *
d569 24
a592 2
 * Free a gl_texture_image and associated data.
 * This function is a fallback called via ctx->Driver.DeleteTextureImage().
d605 6
a610 2
   ASSERT(ctx->Driver.FreeTextureImageBuffer);
   ctx->Driver.FreeTextureImageBuffer( ctx, texImage );
d625 2
a626 5
   /*
    * NUM_TEXTURE_TARGETS should match number of terms below, except there's no
    * proxy for GL_TEXTURE_BUFFER and GL_TEXTURE_EXTERNAL_OES.
    */
   assert(NUM_TEXTURE_TARGETS == 10 + 2);
d634 1
a634 4
           target == GL_PROXY_TEXTURE_2D_ARRAY_EXT ||
           target == GL_PROXY_TEXTURE_CUBE_MAP_ARRAY ||
           target == GL_PROXY_TEXTURE_2D_MULTISAMPLE ||
           target == GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY);
d641 2
a642 2
GLenum
_mesa_get_proxy_target(GLenum target)
a671 9
   case GL_TEXTURE_CUBE_MAP_ARRAY:
   case GL_PROXY_TEXTURE_CUBE_MAP_ARRAY:
      return GL_PROXY_TEXTURE_CUBE_MAP_ARRAY;
   case GL_TEXTURE_2D_MULTISAMPLE:
   case GL_PROXY_TEXTURE_2D_MULTISAMPLE:
      return GL_PROXY_TEXTURE_2D_MULTISAMPLE;
   case GL_TEXTURE_2D_MULTISAMPLE_ARRAY:
   case GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY:
      return GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY;
d673 1
a673 1
      _mesa_problem(NULL, "unexpected target in _mesa_get_proxy_target()");
d681 1
a681 1
 * texture unit.  The target should have already been checked for validity.
d688 2
a695 3
   const GLboolean arrayTex = (ctx->Extensions.MESA_texture_array ||
                               ctx->Extensions.EXT_texture_array);

a720 6
      case GL_TEXTURE_CUBE_MAP_ARRAY:
         return ctx->Extensions.ARB_texture_cube_map_array
                ? texUnit->CurrentTex[TEXTURE_CUBE_ARRAY_INDEX] : NULL;
      case GL_PROXY_TEXTURE_CUBE_MAP_ARRAY:
         return ctx->Extensions.ARB_texture_cube_map_array
                ? ctx->Texture.ProxyTex[TEXTURE_CUBE_ARRAY_INDEX] : NULL;
d728 2
a729 1
         return arrayTex ? texUnit->CurrentTex[TEXTURE_1D_ARRAY_INDEX] : NULL;
d731 2
a732 1
         return arrayTex ? ctx->Texture.ProxyTex[TEXTURE_1D_ARRAY_INDEX] : NULL;
d734 2
a735 1
         return arrayTex ? texUnit->CurrentTex[TEXTURE_2D_ARRAY_INDEX] : NULL;
d737 2
a738 20
         return arrayTex ? ctx->Texture.ProxyTex[TEXTURE_2D_ARRAY_INDEX] : NULL;
      case GL_TEXTURE_BUFFER:
         return ctx->API == API_OPENGL_CORE &&
                ctx->Extensions.ARB_texture_buffer_object ?
                texUnit->CurrentTex[TEXTURE_BUFFER_INDEX] : NULL;
      case GL_TEXTURE_EXTERNAL_OES:
         return _mesa_is_gles(ctx) && ctx->Extensions.OES_EGL_image_external
            ? texUnit->CurrentTex[TEXTURE_EXTERNAL_INDEX] : NULL;
      case GL_TEXTURE_2D_MULTISAMPLE:
         return ctx->Extensions.ARB_texture_multisample
            ? texUnit->CurrentTex[TEXTURE_2D_MULTISAMPLE_INDEX] : NULL;
      case GL_PROXY_TEXTURE_2D_MULTISAMPLE:
         return ctx->Extensions.ARB_texture_multisample
            ? ctx->Texture.ProxyTex[TEXTURE_2D_MULTISAMPLE_INDEX] : NULL;
      case GL_TEXTURE_2D_MULTISAMPLE_ARRAY:
         return ctx->Extensions.ARB_texture_multisample
            ? texUnit->CurrentTex[TEXTURE_2D_MULTISAMPLE_ARRAY_INDEX] : NULL;
      case GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY:
         return ctx->Extensions.ARB_texture_multisample
            ? ctx->Texture.ProxyTex[TEXTURE_2D_MULTISAMPLE_ARRAY_INDEX] : NULL;
d797 1
a797 1

d806 1
a806 1
      set_tex_image(texObj, target, level, texImage);
d819 2
a820 2
static struct gl_texture_image *
get_proxy_tex_image(struct gl_context *ctx, GLenum target, GLint level)
d825 1
a825 1
   if (level < 0)
a863 15
   case GL_PROXY_TEXTURE_CUBE_MAP_ARRAY:
      if (level >= ctx->Const.MaxCubeTextureLevels)
         return NULL;
      texIndex = TEXTURE_CUBE_ARRAY_INDEX;
      break;
   case GL_PROXY_TEXTURE_2D_MULTISAMPLE:
      if (level > 0)
         return 0;
      texIndex = TEXTURE_2D_MULTISAMPLE_INDEX;
      break;
   case GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY:
      if (level > 0)
         return 0;
      texIndex = TEXTURE_2D_MULTISAMPLE_ARRAY_INDEX;
      break;
d888 1
a888 1
 *
a905 1
   case GL_TEXTURE_CUBE_MAP:
d912 1
d923 1
a923 2
      return (ctx->Extensions.MESA_texture_array ||
              ctx->Extensions.EXT_texture_array)
a924 16
   case GL_TEXTURE_CUBE_MAP_ARRAY:
   case GL_PROXY_TEXTURE_CUBE_MAP_ARRAY:
      return ctx->Extensions.ARB_texture_cube_map_array
         ? ctx->Const.MaxCubeTextureLevels : 0;
   case GL_TEXTURE_BUFFER:
      return ctx->API == API_OPENGL_CORE &&
             ctx->Extensions.ARB_texture_buffer_object ? 1 : 0;
   case GL_TEXTURE_2D_MULTISAMPLE:
   case GL_PROXY_TEXTURE_2D_MULTISAMPLE:
   case GL_TEXTURE_2D_MULTISAMPLE_ARRAY:
   case GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY:
      return _mesa_is_desktop_gl(ctx)
         && ctx->Extensions.ARB_texture_multisample
         ? 1 : 0;
   case GL_TEXTURE_EXTERNAL_OES:
      /* fall-through */
d934 2
a935 2
GLint
_mesa_get_texture_dimensions(GLenum target)
a954 3
   case GL_TEXTURE_EXTERNAL_OES:
   case GL_TEXTURE_2D_MULTISAMPLE:
   case GL_PROXY_TEXTURE_2D_MULTISAMPLE:
a959 4
   case GL_TEXTURE_CUBE_MAP_ARRAY:
   case GL_PROXY_TEXTURE_CUBE_MAP_ARRAY:
   case GL_TEXTURE_2D_MULTISAMPLE_ARRAY:
   case GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY:
a960 2
   case GL_TEXTURE_BUFFER:
      /* fall-through */
a968 50
/**
 * Return the maximum number of mipmap levels for the given target
 * and the dimensions.
 * The dimensions are expected not to include the border.
 */
GLsizei
_mesa_get_tex_max_num_levels(GLenum target, GLsizei width, GLsizei height,
                             GLsizei depth)
{
   GLsizei size;

   switch (target) {
   case GL_TEXTURE_1D:
   case GL_TEXTURE_1D_ARRAY:
   case GL_PROXY_TEXTURE_1D:
   case GL_PROXY_TEXTURE_1D_ARRAY:
      size = width;
      break;
   case GL_TEXTURE_CUBE_MAP:
   case GL_TEXTURE_CUBE_MAP_ARRAY:
   case GL_PROXY_TEXTURE_CUBE_MAP:
   case GL_PROXY_TEXTURE_CUBE_MAP_ARRAY:
      ASSERT(width == height);
      size = width;
      break;
   case GL_TEXTURE_2D:
   case GL_TEXTURE_2D_ARRAY:
   case GL_PROXY_TEXTURE_2D:
   case GL_PROXY_TEXTURE_2D_ARRAY:
      size = MAX2(width, height);
      break;
   case GL_TEXTURE_3D:
   case GL_PROXY_TEXTURE_3D:
      size = MAX3(width, height, depth);
      break;
   case GL_TEXTURE_RECTANGLE:
   case GL_TEXTURE_EXTERNAL_OES:
   case GL_TEXTURE_2D_MULTISAMPLE:
   case GL_TEXTURE_2D_MULTISAMPLE_ARRAY:
   case GL_PROXY_TEXTURE_RECTANGLE:
   case GL_PROXY_TEXTURE_2D_MULTISAMPLE:
   case GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY:
      return 1;
   default:
      assert(0);
      return 1;
   }

   return _mesa_logbase2(size) + 1;
}
d982 1
a982 1
   GLubyte *data = (GLubyte *) malloc(numPixels * components * sizeof(GLubyte));
d1026 9
a1034 2
 * Set the size and format-related fields of a gl_texture_image struct
 * to zero.  This is used when a proxy texture test fails.
d1046 5
d1057 1
d1059 2
a1060 2
   img->NumSamples = 0;
   img->FixedSampleLocations = GL_TRUE;
d1068 1
d1081 1
a1081 1
_mesa_init_teximage_fields(struct gl_context *ctx,
d1087 2
a1088 1
   GLenum target;
a1093 1
   target = img->TexObject->Target;
d1103 1
a1103 4
   img->WidthLog2 = _mesa_logbase2(img->Width2);

   img->NumSamples = 0;
   img->FixedSampleLocations = GL_TRUE;
d1105 2
a1106 8
   switch(target) {
   case GL_TEXTURE_1D:
   case GL_TEXTURE_BUFFER:
   case GL_PROXY_TEXTURE_1D:
      if (height == 0)
         img->Height2 = 0;
      else
         img->Height2 = 1;
d1108 2
a1109 31
      if (depth == 0)
         img->Depth2 = 0;
      else
         img->Depth2 = 1;
      img->DepthLog2 = 0;
      break;
   case GL_TEXTURE_1D_ARRAY:
   case GL_PROXY_TEXTURE_1D_ARRAY:
      img->Height2 = height; /* no border */
      img->HeightLog2 = 0; /* not used */
      if (depth == 0)
         img->Depth2 = 0;
      else
         img->Depth2 = 1;
      img->DepthLog2 = 0;
      break;
   case GL_TEXTURE_2D:
   case GL_TEXTURE_RECTANGLE:
   case GL_TEXTURE_CUBE_MAP:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
   case GL_TEXTURE_EXTERNAL_OES:
   case GL_PROXY_TEXTURE_2D:
   case GL_PROXY_TEXTURE_RECTANGLE:
   case GL_PROXY_TEXTURE_CUBE_MAP:
   case GL_TEXTURE_2D_MULTISAMPLE:
   case GL_PROXY_TEXTURE_2D_MULTISAMPLE:
d1111 5
a1115 5
      img->HeightLog2 = _mesa_logbase2(img->Height2);
      if (depth == 0)
         img->Depth2 = 0;
      else
         img->Depth2 = 1;
d1117 2
a1118 16
      break;
   case GL_TEXTURE_2D_ARRAY:
   case GL_PROXY_TEXTURE_2D_ARRAY:
   case GL_TEXTURE_CUBE_MAP_ARRAY:
   case GL_PROXY_TEXTURE_CUBE_MAP_ARRAY:
   case GL_TEXTURE_2D_MULTISAMPLE_ARRAY:
   case GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY:
      img->Height2 = height - 2 * border; /* == 1 << img->HeightLog2; */
      img->HeightLog2 = _mesa_logbase2(img->Height2);
      img->Depth2 = depth; /* no border */
      img->DepthLog2 = 0; /* not used */
      break;
   case GL_TEXTURE_3D:
   case GL_PROXY_TEXTURE_3D:
      img->Height2 = height - 2 * border; /* == 1 << img->HeightLog2; */
      img->HeightLog2 = _mesa_logbase2(img->Height2);
d1120 36
a1155 5
      img->DepthLog2 = _mesa_logbase2(img->Depth2);
      break;
   default:
      _mesa_problem(NULL, "invalid target 0x%x in _mesa_init_teximage_fields()",
                    target);
a1157 3
   img->MaxNumLevels =
      _mesa_get_tex_max_num_levels(target,
                                   img->Width2, img->Height2, img->Depth2);
d1159 4
d1179 1
a1179 1
   ctx->Driver.FreeTextureImageBuffer(ctx, texImage);
d1185 22
a1206 5
 * Check the width, height, depth and border of a texture image are legal.
 * Used by all the glTexImage, glCompressedTexImage and glCopyTexImage
 * functions.
 * The target and level parameters will have already been validated.
 * \return GL_TRUE if size is OK, GL_FALSE otherwise.
d1209 3
a1211 3
_mesa_legal_texture_dimensions(struct gl_context *ctx, GLenum target,
                               GLint level, GLint width, GLint height,
                               GLint depth, GLint border)
d1215 4
a1219 1
   case GL_TEXTURE_1D:
d1221 4
a1224 3
      maxSize = 1 << (ctx->Const.MaxTextureLevels - 1); /* level zero size */
      maxSize >>= level;  /* level size */
      if (width < 2 * border || width > 2 * border + maxSize)
a1231 1
   case GL_TEXTURE_2D:
a1232 2
   case GL_TEXTURE_2D_MULTISAMPLE:
   case GL_PROXY_TEXTURE_2D_MULTISAMPLE:
d1234 1
a1234 2
      maxSize >>= level;
      if (width < 2 * border || width > 2 * border + maxSize)
d1236 3
a1238 1
      if (height < 2 * border || height > 2 * border + maxSize)
a1247 1
   case GL_TEXTURE_3D:
d1250 3
a1252 2
      maxSize >>= level;
      if (width < 2 * border || width > 2 * border + maxSize)
d1254 1
a1254 1
      if (height < 2 * border || height > 2 * border + maxSize)
d1256 1
a1256 1
      if (depth < 2 * border || depth > 2 * border + maxSize)
a1267 1
   case GL_TEXTURE_RECTANGLE_NV:
a1268 2
      if (level != 0)
         return GL_FALSE;
d1274 2
a1277 7
   case GL_TEXTURE_CUBE_MAP:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
d1280 3
a1282 2
      maxSize >>= level;
      if (width < 2 * border || width > 2 * border + maxSize)
d1284 1
a1284 1
      if (height < 2 * border || height > 2 * border + maxSize)
a1293 1
   case GL_TEXTURE_1D_ARRAY_EXT:
d1296 1
a1296 2
      maxSize >>= level;
      if (width < 2 * border || width > 2 * border + maxSize)
d1300 2
a1307 1
   case GL_TEXTURE_2D_ARRAY_EXT:
a1308 2
   case GL_TEXTURE_2D_MULTISAMPLE_ARRAY:
   case GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY:
d1310 1
a1310 2
      maxSize >>= level;
      if (width < 2 * border || width > 2 * border + maxSize)
d1312 1
a1312 1
      if (height < 2 * border || height > 2 * border + maxSize)
d1316 2
a1325 18
   case GL_TEXTURE_CUBE_MAP_ARRAY:
   case GL_PROXY_TEXTURE_CUBE_MAP_ARRAY:
      maxSize = 1 << (ctx->Const.MaxCubeTextureLevels - 1);
      if (width < 2 * border || width > 2 * border + maxSize)
         return GL_FALSE;
      if (height < 2 * border || height > 2 * border + maxSize)
         return GL_FALSE;
      if (depth < 1 || depth > ctx->Const.MaxArrayTextureLayers)
         return GL_FALSE;
      if (level >= ctx->Const.MaxCubeTextureLevels)
         return GL_FALSE;
      if (!ctx->Extensions.ARB_texture_non_power_of_two) {
         if (width > 0 && !_mesa_is_pow_two(width - 2 * border))
            return GL_FALSE;
         if (height > 0 && !_mesa_is_pow_two(height - 2 * border))
            return GL_FALSE;
      }
      return GL_TRUE;
d1327 1
a1327 1
      _mesa_problem(ctx, "Invalid target in _mesa_legal_texture_dimensions()");
d1334 5
a1338 4
 * Do error checking of xoffset, yoffset, zoffset, width, height and depth
 * for glTexSubImage, glCopyTexSubImage and glCompressedTexSubImage.
 * \param destImage  the destination texture image.
 * \return GL_TRUE if error found, GL_FALSE otherwise.
d1341 2
a1342 138
error_check_subtexture_dimensions(struct gl_context *ctx,
                                  const char *function, GLuint dims,
                                  const struct gl_texture_image *destImage,
                                  GLint xoffset, GLint yoffset, GLint zoffset,
                                  GLsizei subWidth, GLsizei subHeight,
                                  GLsizei subDepth)
{
   const GLenum target = destImage->TexObject->Target;
   GLuint bw, bh;

   /* Check size */
   if (subWidth < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "%s%dD(width=%d)", function, dims, subWidth);
      return GL_TRUE;
   }

   if (dims > 1 && subHeight < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "%s%dD(height=%d)", function, dims, subHeight);
      return GL_TRUE;
   }

   if (dims > 2 && subDepth < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "%s%dD(depth=%d)", function, dims, subDepth);
      return GL_TRUE;
   }

   /* check xoffset and width */
   if (xoffset < - (GLint) destImage->Border) {
      _mesa_error(ctx, GL_INVALID_VALUE, "%s%dD(xoffset)",
                  function, dims);
      return GL_TRUE;
   }

   if (xoffset + subWidth > (GLint) destImage->Width) {
      _mesa_error(ctx, GL_INVALID_VALUE, "%s%dD(xoffset+width)",
                  function, dims);
      return GL_TRUE;
   }

   /* check yoffset and height */
   if (dims > 1) {
      GLint yBorder = (target == GL_TEXTURE_1D_ARRAY) ? 0 : destImage->Border;
      if (yoffset < -yBorder) {
         _mesa_error(ctx, GL_INVALID_VALUE, "%s%dD(yoffset)",
                     function, dims);
         return GL_TRUE;
      }
      if (yoffset + subHeight > (GLint) destImage->Height) {
         _mesa_error(ctx, GL_INVALID_VALUE, "%s%dD(yoffset+height)",
                     function, dims);
         return GL_TRUE;
      }
   }

   /* check zoffset and depth */
   if (dims > 2) {
      GLint zBorder = (target == GL_TEXTURE_2D_ARRAY) ? 0 : destImage->Border;
      if (zoffset < -zBorder) {
         _mesa_error(ctx, GL_INVALID_VALUE, "%s3D(zoffset)", function);
         return GL_TRUE;
      }
      if (zoffset + subDepth  > (GLint) destImage->Depth) {
         _mesa_error(ctx, GL_INVALID_VALUE, "%s3D(zoffset+depth)", function);
         return GL_TRUE;
      }
   }

   /*
    * The OpenGL spec (and GL_ARB_texture_compression) says only whole
    * compressed texture images can be updated.  But, that restriction may be
    * relaxed for particular compressed formats.  At this time, all the
    * compressed formats supported by Mesa allow sub-textures to be updated
    * along compressed block boundaries.
    */
   _mesa_get_format_block_size(destImage->TexFormat, &bw, &bh);

   if (bw != 1 || bh != 1) {
      /* offset must be multiple of block size */
      if ((xoffset % bw != 0) || (yoffset % bh != 0)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "%s%dD(xoffset = %d, yoffset = %d)",
                     function, dims, xoffset, yoffset);
         return GL_TRUE;
      }

      /* The size must be a multiple of bw x bh, or we must be using a
       * offset+size that exactly hits the edge of the image.  This
       * is important for small mipmap levels (1x1, 2x1, etc) and for
       * NPOT textures.
       */
      if ((subWidth % bw != 0) &&
          (xoffset + subWidth != (GLint) destImage->Width)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "%s%dD(width = %d)", function, dims, subWidth);
         return GL_TRUE;
      }

      if ((subHeight % bh != 0) &&
          (yoffset + subHeight != (GLint) destImage->Height)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "%s%dD(height = %d)", function, dims, subHeight);
         return GL_TRUE;
      }
   }

   return GL_FALSE;
}




/**
 * This is the fallback for Driver.TestProxyTexImage() for doing device-
 * specific texture image size checks.
 *
 * A hardware driver might override this function if, for example, the
 * max 3D texture size is 512x512x64 (i.e. not a cube).
 *
 * Note that width, height, depth == 0 is not an error.  However, a
 * texture with zero width/height/depth will be considered "incomplete"
 * and texturing will effectively be disabled.
 *
 * \param target  any texture target/type
 * \param level  as passed to glTexImage
 * \param format  the MESA_FORMAT_x for the tex image
 * \param width  as passed to glTexImage
 * \param height  as passed to glTexImage
 * \param depth  as passed to glTexImage
 * \param border  as passed to glTexImage
 * \return GL_TRUE if the image is acceptable, GL_FALSE if not acceptable.
 */
GLboolean
_mesa_test_proxy_teximage(struct gl_context *ctx, GLenum target, GLint level,
                          gl_format format,
                          GLint width, GLint height, GLint depth, GLint border)
a1343 3
   /* We just check if the image size is less than MaxTextureMbytes.
    * Some drivers may do more specific checks.
    */
a1345 1
   mbytes *= _mesa_num_tex_faces(target);
a1349 24
/**
 * Return true if the format is only valid for glCompressedTexImage.
 */
static GLboolean
compressedteximage_only_format(const struct gl_context *ctx, GLenum format)
{
   switch (format) {
   case GL_ETC1_RGB8_OES:
   case GL_PALETTE4_RGB8_OES:
   case GL_PALETTE4_RGBA8_OES:
   case GL_PALETTE4_R5_G6_B5_OES:
   case GL_PALETTE4_RGBA4_OES:
   case GL_PALETTE4_RGB5_A1_OES:
   case GL_PALETTE8_RGB8_OES:
   case GL_PALETTE8_RGBA8_OES:
   case GL_PALETTE8_R5_G6_B5_OES:
   case GL_PALETTE8_RGBA4_OES:
   case GL_PALETTE8_RGB5_A1_OES:
      return GL_TRUE;
   default:
      return GL_FALSE;
   }
}

d1375 1
a1375 5
      return (ctx->Extensions.MESA_texture_array ||
              ctx->Extensions.EXT_texture_array);
   case GL_PROXY_TEXTURE_CUBE_MAP_ARRAY:
   case GL_TEXTURE_CUBE_MAP_ARRAY:
      return ctx->Extensions.ARB_texture_cube_map_array;
d1378 1
a1378 1
   }
d1394 1
a1394 1
         return _mesa_is_desktop_gl(ctx);
d1401 1
a1402 2
      case GL_PROXY_TEXTURE_2D:
         return _mesa_is_desktop_gl(ctx);
a1403 2
         return _mesa_is_desktop_gl(ctx)
            && ctx->Extensions.ARB_texture_cube_map;
d1413 1
a1413 2
         return _mesa_is_desktop_gl(ctx)
            && ctx->Extensions.NV_texture_rectangle;
d1416 1
a1416 3
         return _mesa_is_desktop_gl(ctx)
            && (ctx->Extensions.MESA_texture_array ||
                ctx->Extensions.EXT_texture_array);
d1423 1
a1424 2
      case GL_PROXY_TEXTURE_3D:
         return _mesa_is_desktop_gl(ctx);
a1425 4
         return (_mesa_is_desktop_gl(ctx)
                 && (ctx->Extensions.MESA_texture_array ||
                     ctx->Extensions.EXT_texture_array))
            || _mesa_is_gles3(ctx);
d1427 1
a1427 6
         return _mesa_is_desktop_gl(ctx)
            && (ctx->Extensions.MESA_texture_array ||
                ctx->Extensions.EXT_texture_array);
      case GL_TEXTURE_CUBE_MAP_ARRAY:
      case GL_PROXY_TEXTURE_CUBE_MAP_ARRAY:
         return ctx->Extensions.ARB_texture_cube_map_array;
d1449 1
a1449 1
      return _mesa_is_desktop_gl(ctx) && target == GL_TEXTURE_1D;
d1462 1
a1462 2
         return _mesa_is_desktop_gl(ctx)
            && ctx->Extensions.NV_texture_rectangle;
d1464 1
a1464 3
         return _mesa_is_desktop_gl(ctx)
            && (ctx->Extensions.MESA_texture_array ||
                ctx->Extensions.EXT_texture_array);
d1473 1
a1473 7
         return (_mesa_is_desktop_gl(ctx)
                 && (ctx->Extensions.MESA_texture_array ||
                     ctx->Extensions.EXT_texture_array))
            || _mesa_is_gles3(ctx);
      case GL_TEXTURE_CUBE_MAP_ARRAY:
      case GL_PROXY_TEXTURE_CUBE_MAP_ARRAY:
         return ctx->Extensions.ARB_texture_cube_map_array;
a1485 24
 * Helper function to determine if a texture object is mutable (in terms
 * of GL_ARB_texture_storage).
 */
static GLboolean
mutable_tex_object(struct gl_context *ctx, GLenum target)
{
   struct gl_texture_object *texObj = _mesa_get_current_tex_object(ctx, target);
   return !texObj->Immutable;
}


/**
 * Return expected size of a compressed texture.
 */
static GLuint
compressed_tex_size(GLsizei width, GLsizei height, GLsizei depth,
                    GLenum glformat)
{
   gl_format mesaFormat = _mesa_glenum_to_compressed_format(glformat);
   return _mesa_format_image_size(mesaFormat, width, height, depth);
}


/**
d1487 1
a1487 1
 *
d1490 1
a1490 1
 * \param target texture target given by the user (already validated).
d1499 2
a1500 2
 *
 * \return GL_TRUE if a error is found, GL_FALSE otherwise
a1504 4
 * Note that we don't fully error-check the width, height, depth values
 * here.  That's done in _mesa_legal_texture_dimensions() which is used
 * by several other GL entrypoints.  Plus, texture dims have a special
 * interaction with proxy textures.
d1514 11
a1524 20
   GLboolean colorFormat;
   GLenum err;

   /* Even though there are no color-index textures, we still have to support
    * uploading color-index data and remapping it to RGB via the
    * GL_PIXEL_MAP_I_TO_[RGBA] tables.
    */
   const GLboolean indexFormat = (format == GL_COLOR_INDEX);

   /* Note: for proxy textures, some error conditions immediately generate
    * a GL error in the usual way.  But others do not generate a GL error.
    * Instead, they cause the width, height, depth, format fields of the
    * texture image to be zeroed-out.  The GL spec seems to indicate that the
    * zero-out behaviour is only used in cases related to memory allocation.
    */

   /* level check */
   if (level < 0 || level >= _mesa_max_texture_levels(ctx, target)) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glTexImage%dD(level=%d)", dimensions, level);
d1530 1
a1530 2
       ((ctx->API != API_OPENGL_COMPAT ||
         target == GL_TEXTURE_RECTANGLE_NV ||
d1532 4
a1535 2
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glTexImage%dD(border=%d)", dimensions, border);
d1540 3
a1542 35
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glTexImage%dD(width, height or depth < 0)", dimensions);
      return GL_TRUE;
   }

   /* OpenGL ES 1.x and OpenGL ES 2.0 impose additional restrictions on the
    * combinations of format, internalFormat, and type that can be used.
    * Formats and types that require additional extensions (e.g., GL_FLOAT
    * requires GL_OES_texture_float) are filtered elsewhere.
    */

   if (_mesa_is_gles(ctx)) {
      if (_mesa_is_gles3(ctx)) {
         err = _mesa_es3_error_check_format_and_type(format, type,
                                                     internalFormat);
      } else {
         if (format != internalFormat) {
            _mesa_error(ctx, GL_INVALID_OPERATION,
                        "glTexImage%dD(format = %s, internalFormat = %s)",
                        dimensions,
                        _mesa_lookup_enum_by_nr(format),
                        _mesa_lookup_enum_by_nr(internalFormat));
            return GL_TRUE;
         }

         err = _mesa_es_error_check_format_and_type(format, type, dimensions);
      }
      if (err != GL_NO_ERROR) {
         _mesa_error(ctx, err,
                     "glTexImage%dD(format = %s, type = %s, internalFormat = %s)",
                     dimensions,
                     _mesa_lookup_enum_by_nr(format),
                     _mesa_lookup_enum_by_nr(type),
                     _mesa_lookup_enum_by_nr(internalFormat));
         return GL_TRUE;
a1543 6
   }

   if ((target == GL_PROXY_TEXTURE_CUBE_MAP_ARB ||
        _mesa_is_cube_face(target)) && width != height) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glTexImage2D(cube width != height)");
d1547 3
a1549 5
   if ((target == GL_PROXY_TEXTURE_CUBE_MAP_ARRAY ||
        target == GL_TEXTURE_CUBE_MAP_ARRAY) && width != height) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glTexImage3D(cube array width != height)");
      return GL_TRUE;
d1552 14
a1565 4
   if ((target == GL_PROXY_TEXTURE_CUBE_MAP_ARRAY ||
        target == GL_TEXTURE_CUBE_MAP_ARRAY) && (depth % 6)) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glTexImage3D(cube array depth not multiple of 6)");
d1571 5
a1575 3
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glTexImage%dD(internalFormat=%s)",
                  dimensions, _mesa_lookup_enum_by_nr(internalFormat));
d1580 13
a1592 6
   err = _mesa_error_check_format_and_type(ctx, format, type);
   if (err != GL_NO_ERROR) {
      _mesa_error(ctx, err,
                  "glTexImage%dD(incompatible format = %s, type = %s)",
                  dimensions, _mesa_lookup_enum_by_nr(format),
                  _mesa_lookup_enum_by_nr(type));
d1598 1
d1600 1
d1605 4
a1608 4
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glTexImage%dD(incompatible internalFormat = %s, format = %s)",
                  dimensions, _mesa_lookup_enum_by_nr(internalFormat),
                  _mesa_lookup_enum_by_nr(format));
d1619 1
a1619 2
                        "glTexImage%dD(format/type YCBCR mismatch)",
                        dimensions);
d1627 2
a1628 3
         _mesa_error(ctx, GL_INVALID_ENUM,
                     "glTexImage%dD(bad target for YCbCr texture)",
                     dimensions);
d1632 7
a1638 5
         char message[100];
         _mesa_snprintf(message, sizeof(message),
                        "glTexImage%dD(format=GL_YCBCR_MESA and border=%d)",
                        dimensions, border);
         _mesa_error(ctx, GL_INVALID_VALUE, "%s", message);
d1644 2
a1645 4
   if (_mesa_base_tex_format(ctx, internalFormat) == GL_DEPTH_COMPONENT
       || _mesa_base_tex_format(ctx, internalFormat) == GL_DEPTH_STENCIL) {
      /* Only 1D, 2D, rect, array and cube textures supported, not 3D
       * Cubemaps are only supported for GL version > 3.0 or with EXT_gpu_shader4 */
a1649 4
          target != GL_TEXTURE_1D_ARRAY &&
          target != GL_PROXY_TEXTURE_1D_ARRAY &&
          target != GL_TEXTURE_2D_ARRAY &&
          target != GL_PROXY_TEXTURE_2D_ARRAY &&
d1651 4
a1654 10
          target != GL_PROXY_TEXTURE_RECTANGLE_ARB &&
         !((_mesa_is_cube_face(target) || target == GL_PROXY_TEXTURE_CUBE_MAP) &&
           (ctx->Version >= 30 || ctx->Extensions.EXT_gpu_shader4
            || (ctx->API == API_OPENGLES2 && ctx->Extensions.OES_depth_texture_cube_map))) &&
          !((target == GL_TEXTURE_CUBE_MAP_ARRAY ||
             target == GL_PROXY_TEXTURE_CUBE_MAP_ARRAY) &&
            ctx->Extensions.ARB_texture_cube_map_array)) {
         _mesa_error(ctx, GL_INVALID_ENUM,
                     "glTexImage%dD(bad target for depth texture)",
                     dimensions);
d1662 3
a1664 7
         _mesa_error(ctx, GL_INVALID_ENUM,
                     "glTexImage%dD(target can't be compressed)", dimensions);
         return GL_TRUE;
      }
      if (compressedteximage_only_format(ctx, internalFormat)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glTexImage%dD(no compression for format)", dimensions);
d1668 4
a1671 2
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glTexImage%dD(border!=0)", dimensions);
d1677 8
a1684 12
   if ((ctx->Version >= 30 || ctx->Extensions.EXT_texture_integer) &&
       (_mesa_is_enum_format_integer(format) !=
        _mesa_is_enum_format_integer(internalFormat))) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glTexImage%dD(integer/non-integer format mismatch)",
                  dimensions);
      return GL_TRUE;
   }

   if (!mutable_tex_object(ctx, target)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glTexImage%dD(immutable texture)", dimensions);
d1694 20
a1713 4
 * Error checking for glCompressedTexImage[123]D().
 * Note that the width, height and depth values are not fully error checked
 * here.
 * \return GL_TRUE if a error is found, GL_FALSE otherwise
d1715 6
a1720 6
static GLenum
compressed_texture_error_check(struct gl_context *ctx, GLint dimensions,
                               GLenum target, GLint level,
                               GLenum internalFormat, GLsizei width,
                               GLsizei height, GLsizei depth, GLint border,
                               GLsizei imageSize)
d1722 4
a1725 9
   const GLint maxLevels = _mesa_max_texture_levels(ctx, target);
   GLint expectedSize;
   GLenum error = GL_NO_ERROR;
   char *reason = ""; /* no error */

   if (!target_can_be_compressed(ctx, target, internalFormat)) {
      reason = "target";
      error = GL_INVALID_ENUM;
      goto error;
d1728 5
a1732 5
   /* This will detect any invalid internalFormat value */
   if (!_mesa_is_compressed_format(ctx, internalFormat)) {
      reason = "internalFormat";
      error = GL_INVALID_ENUM;
      goto error;
d1734 4
a1737 54

   switch (internalFormat) {
   case GL_PALETTE4_RGB8_OES:
   case GL_PALETTE4_RGBA8_OES:
   case GL_PALETTE4_R5_G6_B5_OES:
   case GL_PALETTE4_RGBA4_OES:
   case GL_PALETTE4_RGB5_A1_OES:
   case GL_PALETTE8_RGB8_OES:
   case GL_PALETTE8_RGBA8_OES:
   case GL_PALETTE8_R5_G6_B5_OES:
   case GL_PALETTE8_RGBA4_OES:
   case GL_PALETTE8_RGB5_A1_OES:
      /* check level (note that level should be zero or less!) */
      if (level > 0 || level < -maxLevels) {
	 reason = "level";
	 error = GL_INVALID_VALUE;
         goto error;
      }

      if (dimensions != 2) {
	 reason = "compressed paletted textures must be 2D";
	 error = GL_INVALID_OPERATION;
         goto error;
      }

      /* Figure out the expected texture size (in bytes).  This will be
       * checked against the actual size later.
       */
      expectedSize = _mesa_cpal_compressed_size(level, internalFormat,
						width, height);

      /* This is for the benefit of the TestProxyTexImage below.  It expects
       * level to be non-negative.  OES_compressed_paletted_texture uses a
       * weird mechanism where the level specified to glCompressedTexImage2D
       * is -(n-1) number of levels in the texture, and the data specifies the
       * complete mipmap stack.  This is done to ensure the palette is the
       * same for all levels.
       */
      level = -level;
      break;

   default:
      /* check level */
      if (level < 0 || level >= maxLevels) {
	 reason = "level";
	 error = GL_INVALID_VALUE;
         goto error;
      }

      /* Figure out the expected texture size (in bytes).  This will be
       * checked against the actual size later.
       */
      expectedSize = compressed_tex_size(width, height, depth, internalFormat);
      break;
d1739 4
a1742 21

   /* This should really never fail */
   if (_mesa_base_tex_format(ctx, internalFormat) < 0) {
      reason = "internalFormat";
      error = GL_INVALID_ENUM;
      goto error;
   }

   /* No compressed formats support borders at this time */
   if (border != 0) {
      reason = "border != 0";
      error = GL_INVALID_VALUE;
      goto error;
   }

   /* For cube map, width must equal height */
   if ((target == GL_PROXY_TEXTURE_CUBE_MAP_ARB ||
        _mesa_is_cube_face(target)) && width != height) {
      reason = "width != height";
      error = GL_INVALID_VALUE;
      goto error;
d1745 3
a1747 5
   /* check image size in bytes */
   if (expectedSize != imageSize) {
      /* Per GL_ARB_texture_compression:  GL_INVALID_VALUE is generated [...]
       * if <imageSize> is not consistent with the format, dimensions, and
       * contents of the specified image.
d1749 6
a1754 9
      reason = "imageSize inconsistant with width/height/format";
      error = GL_INVALID_VALUE;
      goto error;
   }

   if (!mutable_tex_object(ctx, target)) {
      reason = "immutable texture";
      error = GL_INVALID_OPERATION;
      goto error;
a1757 4

error:
   _mesa_error(ctx, error, "glCompressedTexImage%dD(%s)", dimensions, reason);
   return GL_TRUE;
a1760 1

d1762 2
a1763 20
 * Test glTexSubImage[123]D() parameters for errors.
 *
 * \param ctx GL context.
 * \param dimensions texture image dimensions (must be 1, 2 or 3).
 * \param target texture target given by the user (already validated)
 * \param level image level given by the user.
 * \param xoffset sub-image x offset given by the user.
 * \param yoffset sub-image y offset given by the user.
 * \param zoffset sub-image z offset given by the user.
 * \param format pixel data format given by the user.
 * \param type pixel data type given by the user.
 * \param width image width given by the user.
 * \param height image height given by the user.
 * \param depth image depth given by the user.
 *
 * \return GL_TRUE if an error was detected, or GL_FALSE if no errors.
 *
 * Verifies each of the parameters against the constants specified in
 * __struct gl_contextRec::Const and the supported extensions, and according
 * to the OpenGL specification.
d1766 6
a1771 5
texsubimage_error_check(struct gl_context *ctx, GLuint dimensions,
                        GLenum target, GLint level,
                        GLint xoffset, GLint yoffset, GLint zoffset,
                        GLint width, GLint height, GLint depth,
                        GLenum format, GLenum type)
d1773 5
a1777 3
   struct gl_texture_object *texObj;
   struct gl_texture_image *texImage;
   GLenum err;
d1779 3
a1781 4
   /* check target (proxies not allowed) */
   if (!legal_texsubimage_target(ctx, dimensions, target)) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glTexSubImage%uD(target=%s)",
                  dimensions, _mesa_lookup_enum_by_nr(target));
d1784 3
a1786 5

   /* level check */
   if (level < 0 || level >= _mesa_max_texture_levels(ctx, target)) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glTexSubImage%uD(level=%d)",
                  dimensions, level);
d1789 9
a1797 14

   /* OpenGL ES 1.x and OpenGL ES 2.0 impose additional restrictions on the
    * combinations of format and type that can be used.  Formats and types
    * that require additional extensions (e.g., GL_FLOAT requires
    * GL_OES_texture_float) are filtered elsewhere.
    */
   if (_mesa_is_gles(ctx) && !_mesa_is_gles3(ctx)) {
      err = _mesa_es_error_check_format_and_type(format, type, dimensions);
      if (err != GL_NO_ERROR) {
         _mesa_error(ctx, err,
                     "glTexSubImage%dD(format = %s, type = %s)",
                     dimensions,
                     _mesa_lookup_enum_by_nr(format),
                     _mesa_lookup_enum_by_nr(type));
d1801 9
a1809 16

   err = _mesa_error_check_format_and_type(ctx, format, type);
   if (err != GL_NO_ERROR) {
      _mesa_error(ctx, err,
                  "glTexSubImage%dD(incompatible format = %s, type = %s)",
                  dimensions, _mesa_lookup_enum_by_nr(format),
                  _mesa_lookup_enum_by_nr(type));
      return GL_TRUE;
   }

   /* Get dest texture object / image pointers */
   texObj = _mesa_get_current_tex_object(ctx, target);
   if (!texObj) {
      /* must be out of memory */
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glTexSubImage%dD()", dimensions);
      return GL_TRUE;
d1812 2
a1813 7
   texImage = _mesa_select_tex_image(ctx, texObj, target, level);
   if (!texImage) {
      /* non-existant texture level */
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glTexSubImage%dD(invalid texture image)", dimensions);
      return GL_TRUE;
   }
d1815 2
a1816 5
   if (error_check_subtexture_dimensions(ctx, "glTexSubImage", dimensions,
                                         texImage, xoffset, yoffset, 0,
                                         width, height, 1)) {
      return GL_TRUE;
   }
d1818 2
a1819 2
   if (_mesa_is_format_compressed(texImage->TexFormat)) {
      if (compressedteximage_only_format(ctx, texImage->InternalFormat)) {
d1821 2
a1822 1
               "glTexSubImage%dD(no compression for format)", dimensions);
d1825 7
a1831 6
   }

   if (ctx->Version >= 30 || ctx->Extensions.EXT_texture_integer) {
      /* both source and dest must be integer-valued, or neither */
      if (_mesa_is_format_integer_color(texImage->TexFormat) !=
          _mesa_is_enum_format_integer(format)) {
d1833 1
a1833 2
                     "glTexSubImage%dD(integer/non-integer format mismatch)",
                     dimensions);
d1835 1
a1835 1
      }
d1844 1
a1844 1
 *
d1853 1
a1853 1
 *
d1855 1
a1855 1
 *
d1865 4
a1868 4
   GLint baseFormat;
   GLint rb_base_format;
   struct gl_renderbuffer *rb;
   GLenum rb_internal_format;
d1875 1
a1875 1
   }
d1877 2
a1878 2
   /* level check */
   if (level < 0 || level >= _mesa_max_texture_levels(ctx, target)) {
d1885 2
a1886 4
   if (_mesa_is_user_fbo(ctx->ReadBuffer)) {
      if (ctx->ReadBuffer->_Status == 0) {
         _mesa_test_framebuffer_completeness(ctx, ctx->ReadBuffer);
      }
a1891 7

      if (ctx->ReadBuffer->Visual.samples > 0) {
	 _mesa_error(ctx, GL_INVALID_OPERATION,
		     "glCopyTexImage%dD(multisample FBO)",
		     dimensions);
	 return GL_TRUE;
      }
d1896 1
a1896 2
       ((ctx->API != API_OPENGL_COMPAT ||
         target == GL_TEXTURE_RECTANGLE_NV ||
a1897 2
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glCopyTexImage%dD(border=%d)", dimensions, border);
d1901 4
a1904 4
   rb = _mesa_get_read_renderbuffer_for_format(ctx, internalFormat);
   if (rb == NULL) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glCopyTexImage%dD(read buffer)", dimensions);
d1908 1
a1908 20
   /* OpenGL ES 1.x and OpenGL ES 2.0 impose additional restrictions on the
    * internalFormat.
    */
   if (_mesa_is_gles(ctx) && !_mesa_is_gles3(ctx)) {
      switch (internalFormat) {
      case GL_ALPHA:
      case GL_RGB:
      case GL_RGBA:
      case GL_LUMINANCE:
      case GL_LUMINANCE_ALPHA:
         break;
      default:
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glCopyTexImage%dD(internalFormat)", dimensions);
         return GL_TRUE;
      }
   }

   baseFormat = _mesa_base_tex_format(ctx, internalFormat);
   if (baseFormat < 0) {
d1910 1
a1910 1
                  "glCopyTexImage%dD(internalFormat)", dimensions);
d1914 11
a1924 4
   rb_internal_format = rb->InternalFormat;
   rb_base_format = _mesa_base_tex_format(ctx, rb->InternalFormat);
   if (_mesa_is_color_format(internalFormat)) {
      if (rb_base_format < 0) {
d1926 1
a1926 2
                     "glCopyTexImage%dD(internalFormat)", dimensions);
         return GL_TRUE;
d1928 4
a1931 87
   }

   if (_mesa_is_gles(ctx)) {
      bool valid = true;
      if (_mesa_base_format_component_count(baseFormat) >
          _mesa_base_format_component_count(rb_base_format)) {
         valid = false;
      }
      if (baseFormat == GL_DEPTH_COMPONENT ||
          baseFormat == GL_DEPTH_STENCIL ||
          rb_base_format == GL_DEPTH_COMPONENT ||
          rb_base_format == GL_DEPTH_STENCIL ||
          ((baseFormat == GL_LUMINANCE_ALPHA ||
            baseFormat == GL_ALPHA) &&
           rb_base_format != GL_RGBA) ||
          internalFormat == GL_RGB9_E5) {
         valid = false;
      }
      if (internalFormat == GL_RGB9_E5) {
         valid = false;
      }
      if (!valid) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glCopyTexImage%dD(internalFormat)", dimensions);
         return GL_TRUE;
      }
   }

   if (_mesa_is_gles3(ctx)) {
      bool rb_is_srgb = false;
      bool dst_is_srgb = false;

      if (ctx->Extensions.EXT_framebuffer_sRGB &&
          _mesa_get_format_color_encoding(rb->Format) == GL_SRGB) {
         rb_is_srgb = true;
      }

      if (_mesa_get_linear_internalformat(internalFormat) != internalFormat) {
         dst_is_srgb = true;
      }

      if (rb_is_srgb != dst_is_srgb) {
         /* Page 137 (page 149 of the PDF) in section 3.8.5 of the
          * OpenGLES 3.0.0 spec says:
          *
          *     "The error INVALID_OPERATION is also generated if the
          *     value of FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING for the
          *     framebuffer attachment corresponding to the read buffer
          *     is LINEAR (see section 6.1.13) and internalformat is
          *     one of the sRGB formats described in section 3.8.16, or
          *     if the value of FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING is
          *     SRGB and internalformat is not one of the sRGB formats."
          */
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glCopyTexImage%dD(srgb usage mismatch)", dimensions);
         return GL_TRUE;
      }
   }

   if (!_mesa_source_buffer_exists(ctx, baseFormat)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glCopyTexImage%dD(missing readbuffer)", dimensions);
      return GL_TRUE;
   }

   /* From the EXT_texture_integer spec:
    *
    *     "INVALID_OPERATION is generated by CopyTexImage* and CopyTexSubImage*
    *      if the texture internalformat is an integer format and the read color
    *      buffer is not an integer format, or if the internalformat is not an
    *      integer format and the read color buffer is an integer format."
    */
   if (_mesa_is_color_format(internalFormat)) {
      bool is_int = _mesa_is_enum_format_integer(internalFormat);
      bool is_rbint = _mesa_is_enum_format_integer(rb_internal_format);
      if (is_int || is_rbint) {
         if (is_int != is_rbint) {
            _mesa_error(ctx, GL_INVALID_OPERATION,
                        "glCopyTexImage%dD(integer vs non-integer)", dimensions);
            return GL_TRUE;
         } else if (_mesa_is_gles(ctx) &&
                    _mesa_is_enum_format_unsigned_int(internalFormat) !=
                      _mesa_is_enum_format_unsigned_int(rb_internal_format)) {
            _mesa_error(ctx, GL_INVALID_OPERATION,
                        "glCopyTexImage%dD(signed vs unsigned integer)", dimensions);
            return GL_TRUE;
         }
a1932 6
   }

   if ((target == GL_PROXY_TEXTURE_CUBE_MAP_ARB ||
        _mesa_is_cube_face(target)) && width != height) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glTexImage2D(cube width != height)");
d1942 1
a1942 1
      if (compressedteximage_only_format(ctx, internalFormat)) {
d1944 1
a1944 1
               "glCopyTexImage%dD(no compression for format)", dimensions);
d1947 4
a1950 1
      if (border != 0) {
d1952 1
a1952 1
                     "glCopyTexImage%dD(border!=0)", dimensions);
d1956 7
a1962 5

   if (!mutable_tex_object(ctx, target)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glCopyTexImage%dD(immutable texture)", dimensions);
      return GL_TRUE;
d1972 8
d1983 2
a1984 4
copytexsubimage_error_check(struct gl_context *ctx, GLuint dimensions,
                            GLenum target, GLint level,
                            GLint xoffset, GLint yoffset, GLint zoffset,
                            GLint width, GLint height)
a1985 3
   struct gl_texture_object *texObj;
   struct gl_texture_image *texImage;

d1987 2
a1988 4
   if (_mesa_is_user_fbo(ctx->ReadBuffer)) {
      if (ctx->ReadBuffer->_Status == 0) {
         _mesa_test_framebuffer_completeness(ctx, ctx->ReadBuffer);
      }
a1993 7

      if (ctx->ReadBuffer->Visual.samples > 0) {
	 _mesa_error(ctx, GL_INVALID_OPERATION,
		     "glCopyTexSubImage%dD(multisample FBO)",
		     dimensions);
	 return GL_TRUE;
      }
d2004 1
a2004 1
   if (level < 0 || level >= _mesa_max_texture_levels(ctx, target)) {
d2010 24
a2033 4
   /* Get dest texture object / image pointers */
   texObj = _mesa_get_current_tex_object(ctx, target);
   if (!texObj) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCopyTexSubImage%dD()", dimensions);
d2037 9
a2045 5
   texImage = _mesa_select_tex_image(ctx, texObj, target, level);
   if (!texImage) {
      /* destination image does not exist */
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glCopyTexSubImage%dD(invalid texture image)", dimensions);
d2049 9
a2057 4
   if (error_check_subtexture_dimensions(ctx, "glCopyTexSubImage",
                                         dimensions, texImage,
                                         xoffset, yoffset, zoffset,
                                         width, height, 1)) {
d2060 27
d2088 5
a2092 4
   if (_mesa_is_format_compressed(texImage->TexFormat)) {
      if (compressedteximage_only_format(ctx, texImage->InternalFormat)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
               "glCopyTexSubImage%dD(no compression for format)", dimensions);
d2095 11
d2108 1
a2108 1
   if (texImage->InternalFormat == GL_YCBCR_MESA) {
d2113 1
a2113 1
   if (!_mesa_source_buffer_exists(ctx, texImage->_BaseFormat)) {
d2116 1
a2116 1
                  dimensions, texImage->_BaseFormat);
d2120 27
a2146 15
   /* From the EXT_texture_integer spec:
    *
    *     "INVALID_OPERATION is generated by CopyTexImage* and CopyTexSubImage*
    *      if the texture internalformat is an integer format and the read color
    *      buffer is not an integer format, or if the internalformat is not an
    *      integer format and the read color buffer is an integer format."
    */
   if (_mesa_is_color_format(texImage->InternalFormat)) {
      struct gl_renderbuffer *rb = ctx->ReadBuffer->_ColorReadBuffer;

      if (_mesa_is_format_integer_color(rb->Format) !=
	  _mesa_is_format_integer_color(texImage->TexFormat)) {
	 _mesa_error(ctx, GL_INVALID_OPERATION,
		     "glCopyTexImage%dD(integer vs non-integer)", dimensions);
	 return GL_TRUE;
d2177 1
a2177 1
   if (_mesa_is_user_fbo(fb)) {
d2186 3
a2188 2
            _mesa_update_texture_renderbuffer(ctx, ctx->DrawBuffer, att);
            ASSERT(att->Renderbuffer->TexImage);
d2203 3
a2205 4
void
_mesa_update_fbo_texture(struct gl_context *ctx,
                         struct gl_texture_object *texObj,
                         GLuint face, GLuint level)
d2224 1
a2224 1
static inline void
a2313 31
   /* If the application requested compression to an S3TC format but we don't
    * have the DTXn library, force a generic compressed format instead.
    */
   if (internalFormat != format && format != GL_NONE) {
      const GLenum before = internalFormat;

      switch (internalFormat) {
      case GL_COMPRESSED_RGB_S3TC_DXT1_EXT:
         if (!ctx->Mesa_DXTn)
            internalFormat = GL_COMPRESSED_RGB;
         break;
      case GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:
      case GL_COMPRESSED_RGBA_S3TC_DXT3_EXT:
      case GL_COMPRESSED_RGBA_S3TC_DXT5_EXT:
         if (!ctx->Mesa_DXTn)
            internalFormat = GL_COMPRESSED_RGBA;
         break;
      default:
         break;
      }

      if (before != internalFormat) {
         _mesa_warning(ctx,
                       "DXT compression requested (%s), "
                       "but libtxc_dxtn library not installed.  Using %s "
                       "instead.",
                       _mesa_lookup_enum_by_nr(before),
                       _mesa_lookup_enum_by_nr(internalFormat));
      }
   }

d2315 1
a2315 2
   f = ctx->Driver.ChooseTextureFormat(ctx, texObj->Target, internalFormat,
                                       format, type);
d2322 1
a2322 52
 * Adjust pixel unpack params and image dimensions to strip off the
 * one-pixel texture border.
 *
 * Gallium and intel don't support texture borders.  They've seldem been used
 * and seldom been implemented correctly anyway.
 *
 * \param unpackNew returns the new pixel unpack parameters
 */
static void
strip_texture_border(GLenum target,
                     GLint *width, GLint *height, GLint *depth,
                     const struct gl_pixelstore_attrib *unpack,
                     struct gl_pixelstore_attrib *unpackNew)
{
   assert(width);
   assert(height);
   assert(depth);

   *unpackNew = *unpack;

   if (unpackNew->RowLength == 0)
      unpackNew->RowLength = *width;

   if (unpackNew->ImageHeight == 0)
      unpackNew->ImageHeight = *height;

   assert(*width >= 3);
   unpackNew->SkipPixels++;  /* skip the border */
   *width = *width - 2;      /* reduce the width by two border pixels */

   /* The min height of a texture with a border is 3 */
   if (*height >= 3 && target != GL_TEXTURE_1D_ARRAY) {
      unpackNew->SkipRows++;  /* skip the border */
      *height = *height - 2;  /* reduce the height by two border pixels */
   }

   if (*depth >= 3 &&
       target != GL_TEXTURE_2D_ARRAY &&
       target != GL_TEXTURE_CUBE_MAP_ARRAY) {
      unpackNew->SkipImages++;  /* skip the border */
      *depth = *depth - 2;      /* reduce the depth by two border pixels */
   }
}


/**
 * Common code to implement all the glTexImage1D/2D/3D functions
 * as well as glCompressedTexImage1D/2D/3D.
 * \param compressed  only GL_TRUE for glCompressedTexImage1D/2D/3D calls.
 * \param format  the user's image format (only used if !compressed)
 * \param type  the user's image type (only used if !compressed)
 * \param imageSize  only used for glCompressedTexImage1D/2D/3D calls.
d2325 1
a2325 1
teximage(struct gl_context *ctx, GLboolean compressed, GLuint dims,
d2329 1
a2329 1
         GLsizei imageSize, const GLvoid *pixels)
d2331 1
a2331 6
   const char *func = compressed ? "glCompressedTexImage" : "glTexImage";
   struct gl_pixelstore_attrib unpack_no_border;
   const struct gl_pixelstore_attrib *unpack = &ctx->Unpack;
   struct gl_texture_object *texObj;
   gl_format texFormat;
   GLboolean dimensionsOK, sizeOK;
d2333 1
a2333 1
   FLUSH_VERTICES(ctx, 0);
d2335 8
a2342 18
   if (MESA_VERBOSE & (VERBOSE_API|VERBOSE_TEXTURE)) {
      if (compressed)
         _mesa_debug(ctx,
                     "glCompressedTexImage%uD %s %d %s %d %d %d %d %p\n",
                     dims,
                     _mesa_lookup_enum_by_nr(target), level,
                     _mesa_lookup_enum_by_nr(internalFormat),
                     width, height, depth, border, pixels);
      else
         _mesa_debug(ctx,
                     "glTexImage%uD %s %d %s %d %d %d %d %s %s %p\n",
                     dims,
                     _mesa_lookup_enum_by_nr(target), level,
                     _mesa_lookup_enum_by_nr(internalFormat),
                     width, height, depth, border,
                     _mesa_lookup_enum_by_nr(format),
                     _mesa_lookup_enum_by_nr(type), pixels);
   }
d2348 2
a2349 2
      _mesa_error(ctx, GL_INVALID_ENUM, "%s%uD(target=%s)",
                  func, dims, _mesa_lookup_enum_by_nr(target));
d2354 2
a2355 60
   if (compressed) {
      if (compressed_texture_error_check(ctx, dims, target, level,
                                         internalFormat,
                                         width, height, depth,
                                         border, imageSize))
         return;
   }
   else {
      if (texture_error_check(ctx, dims, target, level, internalFormat,
                              format, type, width, height, depth, border))
         return;
   }

   /* Here we convert a cpal compressed image into a regular glTexImage2D
    * call by decompressing the texture.  If we really want to support cpal
    * textures in any driver this would have to be changed.
    */
   if (ctx->API == API_OPENGLES && compressed && dims == 2) {
      switch (internalFormat) {
      case GL_PALETTE4_RGB8_OES:
      case GL_PALETTE4_RGBA8_OES:
      case GL_PALETTE4_R5_G6_B5_OES:
      case GL_PALETTE4_RGBA4_OES:
      case GL_PALETTE4_RGB5_A1_OES:
      case GL_PALETTE8_RGB8_OES:
      case GL_PALETTE8_RGBA8_OES:
      case GL_PALETTE8_R5_G6_B5_OES:
      case GL_PALETTE8_RGBA4_OES:
      case GL_PALETTE8_RGB5_A1_OES:
         _mesa_cpal_compressed_teximage2d(target, level, internalFormat,
                                          width, height, imageSize, pixels);
         return;
      }
   }

   texObj = _mesa_get_current_tex_object(ctx, target);
   assert(texObj);

   if (compressed) {
      /* For glCompressedTexImage() the driver has no choice about the
       * texture format since we'll never transcode the user's compressed
       * image data.  The internalFormat was error checked earlier.
       */
      texFormat = _mesa_glenum_to_compressed_format(internalFormat);
   }
   else {
      texFormat = _mesa_choose_texture_format(ctx, texObj, target, level,
                                              internalFormat, format, type);
   }

   assert(texFormat != MESA_FORMAT_NONE);

   /* check that width, height, depth are legal for the mipmap level */
   dimensionsOK = _mesa_legal_texture_dimensions(ctx, target, level, width,
                                                 height, depth, border);

   /* check that the texture won't take too much memory, etc */
   sizeOK = ctx->Driver.TestProxyTexImage(ctx, _mesa_get_proxy_target(target),
                                          level, texFormat,
                                          width, height, depth, border);
d2360 1
a2360 1
         get_proxy_tex_image(ctx, target, level);
d2362 4
a2365 6
      if (!texImage)
         return;  /* GL_OUT_OF_MEMORY already recorded */

      if (dimensionsOK && sizeOK) {
         _mesa_init_teximage_fields(ctx, texImage, width, height, depth,
                                    border, internalFormat, texFormat);
d2368 16
a2383 1
         clear_teximage_fields(texImage);
d2389 1
d2392 2
a2393 5
      if (!dimensionsOK) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glTexImage%uD(invalid width or height or depth)",
                     dims);
         return;
d2396 2
a2397 16
      if (!sizeOK) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY,
                     "glTexImage%uD(image too large)", dims);
         return;
      }

      /* Allow a hardware driver to just strip out the border, to provide
       * reliable but slightly incorrect hardware rendering instead of
       * rarely-tested software fallback rendering.
       */
      if (border && ctx->Const.StripTextureBorder) {
	 strip_texture_border(target, &width, &height, &depth, unpack,
			      &unpack_no_border);
         border = 0;
	 unpack = &unpack_no_border;
      }
d2399 1
a2399 2
      if (ctx->NewState & _NEW_PIXEL)
	 _mesa_update_state(ctx);
d2406 1
a2406 1
	    _mesa_error(ctx, GL_OUT_OF_MEMORY, "%s%uD", func, dims);
d2409 1
a2409 1
            ctx->Driver.FreeTextureImageBuffer(ctx, texImage);
d2411 3
a2413 3
            _mesa_init_teximage_fields(ctx, texImage,
                                       width, height, depth,
                                       border, internalFormat, texFormat);
d2415 33
a2447 5
            /* Give the texture to the driver.  <pixels> may be null. */
            if (width > 0 && height > 0 && depth > 0) {
               if (compressed) {
                  ctx->Driver.CompressedTexImage(ctx, dims, texImage,
                                                 imageSize, pixels);
a2448 5
               else {
                  ctx->Driver.TexImage(ctx, dims, texImage, format,
                                       type, pixels, unpack);
               }
            }
d2450 1
a2450 1
            check_gen_mipmap(ctx, target, texObj, level);
d2452 1
a2452 1
            _mesa_update_fbo_texture(ctx, texObj, face, level);
d2454 7
a2460 1
            _mesa_dirty_texobj(ctx, texObj, GL_TRUE);
a2467 1

d2477 2
a2478 2
   teximage(ctx, GL_FALSE, 1, target, level, internalFormat, width, 1, 1,
            border, format, type, 0, pixels);
d2489 2
a2490 2
   teximage(ctx, GL_FALSE, 2, target, level, internalFormat, width, height, 1,
            border, format, type, 0, pixels);
d2505 2
a2506 3
   teximage(ctx, GL_FALSE, 3, target, level, internalFormat,
            width, height, depth,
            border, format, type, 0, pixels);
d2521 1
a2526 1
   bool valid_target;
d2528 1
a2528 1
   FLUSH_VERTICES(ctx, 0);
d2530 4
a2533 11
   switch (target) {
   case GL_TEXTURE_2D:
      valid_target = ctx->Extensions.OES_EGL_image;
      break;
   case GL_TEXTURE_EXTERNAL_OES:
      valid_target =
         _mesa_is_gles(ctx) ? ctx->Extensions.OES_EGL_image_external : false;
      break;
   default:
      valid_target = false;
      break;
d2536 1
a2536 1
   if (!valid_target) {
d2542 1
a2542 7
   if (!image) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
		  "glEGLImageTargetTexture2D(image=%p)", image);
      return;
   }

   if (ctx->NewState & _NEW_PIXEL)
a2547 7
   if (texObj->Immutable) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
		  "glEGLImageTargetTexture2D(texture is immutable)");
      _mesa_unlock_texture(ctx, texObj);
      return;
   }

d2552 2
a2553 1
      ctx->Driver.FreeTextureImageBuffer(ctx, texImage);
d2555 1
d2559 3
a2561 1
      _mesa_dirty_texobj(ctx, texObj, GL_TRUE);
d2566 1
d2582 1
a2582 1
   FLUSH_VERTICES(ctx, 0);
d2597 1
a2597 1
   }
d2599 1
a2599 1
   if (ctx->NewState & _NEW_PIXEL)
d2602 2
a2603 3
   if (texsubimage_error_check(ctx, dims, target, level,
                               xoffset, yoffset, zoffset,
                               width, height, depth, format, type)) {
d2613 7
a2619 1
      if (width > 0 && height > 0 && depth > 0) {
d2623 1
a2623 2
            if (target != GL_TEXTURE_2D_ARRAY)
               zoffset += texImage->Border;
d2626 1
a2626 2
            if (target != GL_TEXTURE_1D_ARRAY)
               yoffset += texImage->Border;
d2632 23
a2654 4
         ctx->Driver.TexSubImage(ctx, dims, texImage,
                                 xoffset, yoffset, zoffset,
                                 width, height, depth,
                                 format, type, pixels, &ctx->Unpack);
a2711 48
 * For glCopyTexSubImage, return the source renderbuffer to copy texel data
 * from.  This depends on whether the texture contains color or depth values.
 */
static struct gl_renderbuffer *
get_copy_tex_image_source(struct gl_context *ctx, gl_format texFormat)
{
   if (_mesa_get_format_bits(texFormat, GL_DEPTH_BITS) > 0) {
      /* reading from depth/stencil buffer */
      return ctx->ReadBuffer->Attachment[BUFFER_DEPTH].Renderbuffer;
   }
   else {
      /* copying from color buffer */
      return ctx->ReadBuffer->_ColorReadBuffer;
   }
}

static void
copytexsubimage_by_slice(struct gl_context *ctx,
                         struct gl_texture_image *texImage,
                         GLuint dims,
                         GLint xoffset, GLint yoffset, GLint zoffset,
                         struct gl_renderbuffer *rb,
                         GLint x, GLint y,
                         GLsizei width, GLsizei height)
{
   if (texImage->TexObject->Target == GL_TEXTURE_1D_ARRAY) {
      int slice;

      /* For 1D arrays, we copy each scanline of the source rectangle into the
       * next array slice.
       */
      assert(zoffset == 0);

      for (slice = 0; slice < height; slice++) {
         assert(yoffset + slice < texImage->Height);
         ctx->Driver.CopyTexSubImage(ctx, 2, texImage,
                                     xoffset, 0, yoffset + slice,
                                     rb, x, y + slice, width, 1);
      }
   } else {
      ctx->Driver.CopyTexSubImage(ctx, dims, texImage,
                                  xoffset, yoffset, zoffset,
                                  rb, x, y, width, height);
   }
}


/**
a2721 1
   gl_format texFormat;
d2723 1
a2723 1
   FLUSH_VERTICES(ctx, 0);
a2738 7
   if (!_mesa_legal_texture_dimensions(ctx, target, level, width, height,
                                       1, border)) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glCopyTexImage%uD(invalid width or height)", dims);
      return;
   }

a2739 23
   assert(texObj);

   texFormat = _mesa_choose_texture_format(ctx, texObj, target, level,
                                           internalFormat, GL_NONE, GL_NONE);
   assert(texFormat != MESA_FORMAT_NONE);

   if (!ctx->Driver.TestProxyTexImage(ctx, _mesa_get_proxy_target(target),
                                      level, texFormat,
                                      width, height, 1, border)) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY,
                  "glCopyTexImage%uD(image too large)", dims);
      return;
   }

   if (border && ctx->Const.StripTextureBorder) {
      x += border;
      width -= border * 2;
      if (dims == 2) {
	 y += border;
	 height -= border * 2;
      }
      border = 0;
   }
d2749 5
a2753 1
         GLint srcX = x, srcY = y, dstX = 0, dstY = 0, dstZ = 0;
d2755 1
a2755 2
         /* Free old texture image */
         ctx->Driver.FreeTextureImageBuffer(ctx, texImage);
d2757 3
a2759 2
         _mesa_init_teximage_fields(ctx, texImage, width, height, 1,
                                    border, internalFormat, texFormat);
d2761 11
a2771 13
         if (width && height) {
            /* Allocate texture memory (no pixel data yet) */
            ctx->Driver.AllocTextureImageBuffer(ctx, texImage);

            if (_mesa_clip_copytexsubimage(ctx, &dstX, &dstY, &srcX, &srcY,
                                           &width, &height)) {
               struct gl_renderbuffer *srcRb =
                  get_copy_tex_image_source(ctx, texImage->TexFormat);

               copytexsubimage_by_slice(ctx, texImage, dims,
                                        dstX, dstY, dstZ,
                                        srcRb, srcX, srcY, width, height);
            }
a2773 1
         }
d2775 1
a2775 1
         _mesa_update_fbo_texture(ctx, texObj, face, level);
d2777 7
a2783 1
         _mesa_dirty_texobj(ctx, texObj, GL_TRUE);
d2826 1
a2826 1
   FLUSH_VERTICES(ctx, 0);
d2837 1
a2837 2
   if (copytexsubimage_error_check(ctx, dims, target, level,
                                   xoffset, yoffset, zoffset, width, height)) {
a2838 1
   }
d2846 8
a2853 4
      /* If we have a border, offset=-1 is legal.  Bias by border width. */
      switch (dims) {
      case 3:
         if (target != GL_TEXTURE_2D_ARRAY)
d2855 2
a2856 3
         /* fall-through */
      case 2:
         if (target != GL_TEXTURE_1D_ARRAY)
d2858 4
a2861 4
         /* fall-through */
      case 1:
         xoffset += texImage->Border;
      }
d2863 20
a2882 4
      if (_mesa_clip_copytexsubimage(ctx, &xoffset, &yoffset, &x, &y,
                                     &width, &height)) {
         struct gl_renderbuffer *srcRb =
            get_copy_tex_image_source(ctx, texImage->TexFormat);
d2884 1
a2884 3
         copytexsubimage_by_slice(ctx, texImage, dims,
                                  xoffset, yoffset, zoffset,
                                  srcRb, x, y, width, height);
d2886 2
a2887 3
         check_gen_mipmap(ctx, target, texObj, level);

         ctx->NewState |= _NEW_TEXTURE;
d2935 24
a2958 1
 * Error checking for glCompressedTexSubImage[123]D().
d2962 5
a2966 5
compressed_subtexture_error_check(struct gl_context *ctx, GLint dims,
                                  GLenum target, GLint level,
                                  GLint xoffset, GLint yoffset, GLint zoffset,
                                  GLsizei width, GLsizei height, GLsizei depth,
                                  GLenum format, GLsizei imageSize)
d2968 2
a2969 2
   struct gl_texture_object *texObj;
   struct gl_texture_image *texImage;
a2970 1
   GLboolean targetOK;
d2972 6
a2977 25
   switch (dims) {
   case 2:
      switch (target) {
      case GL_TEXTURE_2D:
      case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
      case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
      case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
         targetOK = GL_TRUE;
         break;
      default:
         targetOK = GL_FALSE;
         break;
      }
      break;
   case 3:
      targetOK = (target == GL_TEXTURE_2D_ARRAY);
      break;
   default:
      assert(dims == 1);
      /* no 1D compressed textures at this time */
      targetOK = GL_FALSE;
      break;
d2980 16
a2995 5
   if (!targetOK) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glCompressedTexImage%uD(target)",
                  dims);
      return GL_TRUE;
   }
d2997 17
a3013 5
   /* this will catch any invalid compressed format token */
   if (!_mesa_is_compressed_format(ctx, format)) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glCompressedTexImage%uD(format)",
                  dims);
      return GL_TRUE;
d3016 6
a3021 4
   if (level < 0 || level >= _mesa_max_texture_levels(ctx, target)) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glCompressedTexImage%uD(level=%d)",
                  dims, level);
      return GL_TRUE;
d3024 2
a3025 1
   expectedSize = compressed_tex_size(width, height, depth, format);
d3027 5
a3031 3
      _mesa_error(ctx, GL_INVALID_VALUE, "glCompressedTexImage%uD(size=%d)",
                  dims, imageSize);
      return GL_TRUE;
d3034 51
a3084 5
   texObj = _mesa_get_current_tex_object(ctx, target);
   if (!texObj) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY,
                  "glCompressedTexSubImage%uD()", dims);
      return GL_TRUE;
d3087 48
a3134 6
   texImage = _mesa_select_tex_image(ctx, texObj, target, level);
   if (!texImage) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glCompressedTexSubImage%uD(invalid texture image)", dims);
      return GL_TRUE;
   }
d3142 5
a3146 4
   if (compressedteximage_only_format(ctx, format)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glCompressedTexSubImage%uD(format=0x%x cannot be updated)"
                  , dims, format);
d3150 18
a3167 4
   if (error_check_subtexture_dimensions(ctx, "glCompressedTexSubImage", dims,
                                         texImage, xoffset, yoffset, zoffset,
                                         width, height, depth)) {
      return GL_TRUE;
d3174 170
d3345 1
a3345 1
_mesa_CompressedTexImage1D(GLenum target, GLint level,
d3351 2
a3352 2
   teximage(ctx, GL_TRUE, 1, target, level, internalFormat,
            width, 1, 1, border, GL_NONE, GL_NONE, imageSize, data);
d3357 1
a3357 1
_mesa_CompressedTexImage2D(GLenum target, GLint level,
d3363 2
a3364 2
   teximage(ctx, GL_TRUE, 2, target, level, internalFormat,
            width, height, 1, border, GL_NONE, GL_NONE, imageSize, data);
d3369 1
a3369 1
_mesa_CompressedTexImage3D(GLenum target, GLint level,
d3375 2
a3376 2
   teximage(ctx, GL_TRUE, 3, target, level, internalFormat,
            width, height, depth, border, GL_NONE, GL_NONE, imageSize, data);
d3391 1
d3393 1
a3393 1
   FLUSH_VERTICES(ctx, 0);
d3395 6
a3400 4
   if (compressed_subtexture_error_check(ctx, dims, target, level,
                                         xoffset, yoffset, zoffset,
                                         width, height, depth,
                                         format, imageSize)) {
d3411 35
a3445 5
      if (width > 0 && height > 0 && depth > 0) {
         ctx->Driver.CompressedTexSubImage(ctx, dims, texImage,
                                           xoffset, yoffset, zoffset,
                                           width, height, depth,
                                           format, imageSize, data);
d3457 1
a3457 1
_mesa_CompressedTexSubImage1D(GLenum target, GLint level, GLint xoffset,
d3467 1
a3467 1
_mesa_CompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset,
d3478 1
a3478 1
_mesa_CompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset,
a3484 509
}

static gl_format
get_texbuffer_format(const struct gl_context *ctx, GLenum internalFormat)
{
   switch (internalFormat) {
   case GL_ALPHA8:
      return MESA_FORMAT_A8;
   case GL_ALPHA16:
      return MESA_FORMAT_A16;
   case GL_ALPHA16F_ARB:
      return MESA_FORMAT_ALPHA_FLOAT16;
   case GL_ALPHA32F_ARB:
      return MESA_FORMAT_ALPHA_FLOAT32;
   case GL_ALPHA8I_EXT:
      return MESA_FORMAT_ALPHA_INT8;
   case GL_ALPHA16I_EXT:
      return MESA_FORMAT_ALPHA_INT16;
   case GL_ALPHA32I_EXT:
      return MESA_FORMAT_ALPHA_INT32;
   case GL_ALPHA8UI_EXT:
      return MESA_FORMAT_ALPHA_UINT8;
   case GL_ALPHA16UI_EXT:
      return MESA_FORMAT_ALPHA_UINT16;
   case GL_ALPHA32UI_EXT:
      return MESA_FORMAT_ALPHA_UINT32;
   case GL_LUMINANCE8:
      return MESA_FORMAT_L8;
   case GL_LUMINANCE16:
      return MESA_FORMAT_L16;
   case GL_LUMINANCE16F_ARB:
      return MESA_FORMAT_LUMINANCE_FLOAT16;
   case GL_LUMINANCE32F_ARB:
      return MESA_FORMAT_LUMINANCE_FLOAT32;
   case GL_LUMINANCE8I_EXT:
      return MESA_FORMAT_LUMINANCE_INT8;
   case GL_LUMINANCE16I_EXT:
      return MESA_FORMAT_LUMINANCE_INT16;
   case GL_LUMINANCE32I_EXT:
      return MESA_FORMAT_LUMINANCE_INT32;
   case GL_LUMINANCE8UI_EXT:
      return MESA_FORMAT_LUMINANCE_UINT8;
   case GL_LUMINANCE16UI_EXT:
      return MESA_FORMAT_LUMINANCE_UINT16;
   case GL_LUMINANCE32UI_EXT:
      return MESA_FORMAT_LUMINANCE_UINT32;
   case GL_LUMINANCE8_ALPHA8:
      return MESA_FORMAT_AL88;
   case GL_LUMINANCE16_ALPHA16:
      return MESA_FORMAT_AL1616;
   case GL_LUMINANCE_ALPHA16F_ARB:
      return MESA_FORMAT_LUMINANCE_ALPHA_FLOAT16;
   case GL_LUMINANCE_ALPHA32F_ARB:
      return MESA_FORMAT_LUMINANCE_ALPHA_FLOAT32;
   case GL_LUMINANCE_ALPHA8I_EXT:
      return MESA_FORMAT_LUMINANCE_ALPHA_INT8;
   case GL_LUMINANCE_ALPHA16I_EXT:
      return MESA_FORMAT_LUMINANCE_ALPHA_INT8;
   case GL_LUMINANCE_ALPHA32I_EXT:
      return MESA_FORMAT_LUMINANCE_ALPHA_INT16;
   case GL_LUMINANCE_ALPHA8UI_EXT:
      return MESA_FORMAT_LUMINANCE_ALPHA_UINT8;
   case GL_LUMINANCE_ALPHA16UI_EXT:
      return MESA_FORMAT_LUMINANCE_ALPHA_UINT16;
   case GL_LUMINANCE_ALPHA32UI_EXT:
      return MESA_FORMAT_LUMINANCE_ALPHA_UINT32;
   case GL_INTENSITY8:
      return MESA_FORMAT_I8;
   case GL_INTENSITY16:
      return MESA_FORMAT_I16;
   case GL_INTENSITY16F_ARB:
      return MESA_FORMAT_INTENSITY_FLOAT16;
   case GL_INTENSITY32F_ARB:
      return MESA_FORMAT_INTENSITY_FLOAT32;
   case GL_INTENSITY8I_EXT:
      return MESA_FORMAT_INTENSITY_INT8;
   case GL_INTENSITY16I_EXT:
      return MESA_FORMAT_INTENSITY_INT16;
   case GL_INTENSITY32I_EXT:
      return MESA_FORMAT_INTENSITY_INT32;
   case GL_INTENSITY8UI_EXT:
      return MESA_FORMAT_INTENSITY_UINT8;
   case GL_INTENSITY16UI_EXT:
      return MESA_FORMAT_INTENSITY_UINT16;
   case GL_INTENSITY32UI_EXT:
      return MESA_FORMAT_INTENSITY_UINT32;
   case GL_RGBA8:
      return MESA_FORMAT_RGBA8888_REV;
   case GL_RGBA16:
      return MESA_FORMAT_RGBA_16;
   case GL_RGBA16F_ARB:
      return MESA_FORMAT_RGBA_FLOAT16;
   case GL_RGBA32F_ARB:
      return MESA_FORMAT_RGBA_FLOAT32;
   case GL_RGBA8I_EXT:
      return MESA_FORMAT_RGBA_INT8;
   case GL_RGBA16I_EXT:
      return MESA_FORMAT_RGBA_INT16;
   case GL_RGBA32I_EXT:
      return MESA_FORMAT_RGBA_INT32;
   case GL_RGBA8UI_EXT:
      return MESA_FORMAT_RGBA_UINT8;
   case GL_RGBA16UI_EXT:
      return MESA_FORMAT_RGBA_UINT16;
   case GL_RGBA32UI_EXT:
      return MESA_FORMAT_RGBA_UINT32;

   case GL_RG8:
      return MESA_FORMAT_GR88;
   case GL_RG16:
      return MESA_FORMAT_GR1616;
   case GL_RG16F:
      return MESA_FORMAT_RG_FLOAT16;
   case GL_RG32F:
      return MESA_FORMAT_RG_FLOAT32;
   case GL_RG8I:
      return MESA_FORMAT_RG_INT8;
   case GL_RG16I:
      return MESA_FORMAT_RG_INT16;
   case GL_RG32I:
      return MESA_FORMAT_RG_INT32;
   case GL_RG8UI:
      return MESA_FORMAT_RG_UINT8;
   case GL_RG16UI:
      return MESA_FORMAT_RG_UINT16;
   case GL_RG32UI:
      return MESA_FORMAT_RG_UINT32;

   case GL_R8:
      return MESA_FORMAT_R8;
   case GL_R16:
      return MESA_FORMAT_R16;
   case GL_R16F:
      return MESA_FORMAT_R_FLOAT16;
   case GL_R32F:
      return MESA_FORMAT_R_FLOAT32;
   case GL_R8I:
      return MESA_FORMAT_R_INT8;
   case GL_R16I:
      return MESA_FORMAT_R_INT16;
   case GL_R32I:
      return MESA_FORMAT_R_INT32;
   case GL_R8UI:
      return MESA_FORMAT_R_UINT8;
   case GL_R16UI:
      return MESA_FORMAT_R_UINT16;
   case GL_R32UI:
      return MESA_FORMAT_R_UINT32;

   case GL_RGB32F:
      return MESA_FORMAT_RGB_FLOAT32;
   case GL_RGB32UI:
      return MESA_FORMAT_RGB_UINT32;
   case GL_RGB32I:
      return MESA_FORMAT_RGB_INT32;

   default:
      return MESA_FORMAT_NONE;
   }
}


static gl_format
validate_texbuffer_format(const struct gl_context *ctx, GLenum internalFormat)
{
   gl_format format = get_texbuffer_format(ctx, internalFormat);
   GLenum datatype;

   if (format == MESA_FORMAT_NONE)
      return MESA_FORMAT_NONE;

   datatype = _mesa_get_format_datatype(format);
   if (datatype == GL_FLOAT && !ctx->Extensions.ARB_texture_float)
      return MESA_FORMAT_NONE;

   if (datatype == GL_HALF_FLOAT && !ctx->Extensions.ARB_half_float_pixel)
      return MESA_FORMAT_NONE;

   /* The GL_ARB_texture_rg and GL_ARB_texture_buffer_object specs don't make
    * any mention of R/RG formats, but they appear in the GL 3.1 core
    * specification.
    */
   if (ctx->Version <= 30) {
      GLenum base_format = _mesa_get_format_base_format(format);

      if (base_format == GL_R || base_format == GL_RG)
	 return MESA_FORMAT_NONE;
   }

   if (!ctx->Extensions.ARB_texture_buffer_object_rgb32) {
      GLenum base_format = _mesa_get_format_base_format(format);
      if (base_format == GL_RGB)
         return MESA_FORMAT_NONE;
   }
   return format;
}


static void
texbufferrange(struct gl_context *ctx, GLenum target, GLenum internalFormat,
               struct gl_buffer_object *bufObj,
               GLintptr offset, GLsizeiptr size)
{
   struct gl_texture_object *texObj;
   gl_format format;

   FLUSH_VERTICES(ctx, 0);

   if (target != GL_TEXTURE_BUFFER_ARB) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glTexBuffer(target)");
      return;
   }

   format = validate_texbuffer_format(ctx, internalFormat);
   if (format == MESA_FORMAT_NONE) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glTexBuffer(internalFormat 0x%x)",
                  internalFormat);
      return;
   }

   texObj = _mesa_get_current_tex_object(ctx, target);

   _mesa_lock_texture(ctx, texObj);
   {
      _mesa_reference_buffer_object(ctx, &texObj->BufferObject, bufObj);
      texObj->BufferObjectFormat = internalFormat;
      texObj->_BufferObjectFormat = format;
      texObj->BufferOffset = offset;
      texObj->BufferSize = size;
   }
   _mesa_unlock_texture(ctx, texObj);
}


/** GL_ARB_texture_buffer_object */
void GLAPIENTRY
_mesa_TexBuffer(GLenum target, GLenum internalFormat, GLuint buffer)
{
   struct gl_buffer_object *bufObj;

   GET_CURRENT_CONTEXT(ctx);

   /* NOTE: ARB_texture_buffer_object has interactions with
    * the compatibility profile that are not implemented.
    */
   if (!(ctx->API == API_OPENGL_CORE &&
         ctx->Extensions.ARB_texture_buffer_object)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glTexBuffer");
      return;
   }

   bufObj = _mesa_lookup_bufferobj(ctx, buffer);
   if (!bufObj && buffer) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glTexBuffer(buffer %u)", buffer);
      return;
   }

   texbufferrange(ctx, target, internalFormat, bufObj, 0, buffer ? -1 : 0);
}


/** GL_ARB_texture_buffer_range */
void GLAPIENTRY
_mesa_TexBufferRange(GLenum target, GLenum internalFormat, GLuint buffer,
                     GLintptr offset, GLsizeiptr size)
{
   struct gl_buffer_object *bufObj;

   GET_CURRENT_CONTEXT(ctx);

   if (!(ctx->API == API_OPENGL_CORE &&
         ctx->Extensions.ARB_texture_buffer_range)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glTexBufferRange");
      return;
   }

   bufObj = _mesa_lookup_bufferobj(ctx, buffer);
   if (bufObj) {
      if (offset < 0 ||
          size <= 0 ||
          (offset + size) > bufObj->Size) {
         _mesa_error(ctx, GL_INVALID_VALUE, "glTexBufferRange");
         return;
      }
      if (offset % ctx->Const.TextureBufferOffsetAlignment) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glTexBufferRange(invalid offset alignment)");
         return;
      }
   } else if (buffer) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glTexBufferRange(buffer %u)",
                  buffer);
      return;
   } else {
      offset = 0;
      size = 0;
   }

   texbufferrange(ctx, target, internalFormat, bufObj, offset, size);
}


static GLboolean
is_renderable_texture_format(struct gl_context *ctx, GLenum internalformat)
{
   /* Everything that is allowed for renderbuffers,
    * except for a base format of GL_STENCIL_INDEX.
    */
   GLenum baseFormat = _mesa_base_fbo_format(ctx, internalformat);
   return baseFormat != 0 && baseFormat != GL_STENCIL_INDEX;
}


/** GL_ARB_texture_multisample */
static GLboolean
check_multisample_target(GLuint dims, GLenum target)
{
   switch(target) {
   case GL_TEXTURE_2D_MULTISAMPLE:
   case GL_PROXY_TEXTURE_2D_MULTISAMPLE:
      return dims == 2;

   case GL_TEXTURE_2D_MULTISAMPLE_ARRAY:
   case GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY:
      return dims == 3;

   default:
      return GL_FALSE;
   }
}


static void
teximagemultisample(GLuint dims, GLenum target, GLsizei samples,
                    GLint internalformat, GLsizei width, GLsizei height,
                    GLsizei depth, GLboolean fixedsamplelocations,
                    GLboolean immutable, const char *func)
{
   struct gl_texture_object *texObj;
   struct gl_texture_image *texImage;
   GLboolean sizeOK, dimensionsOK;
   gl_format texFormat;
   GLenum sample_count_error;

   GET_CURRENT_CONTEXT(ctx);

   if (!(ctx->Extensions.ARB_texture_multisample
      && _mesa_is_desktop_gl(ctx))) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "%s(unsupported)", func);
      return;
   }

   if (!check_multisample_target(dims, target)) {
      _mesa_error(ctx, GL_INVALID_ENUM, "%s(target)", func);
      return;
   }

   /* check that the specified internalformat is color/depth/stencil-renderable;
    * refer GL3.1 spec 4.4.4
    */

   if (immutable && !_mesa_is_legal_tex_storage_format(ctx, internalformat)) {
      _mesa_error(ctx, GL_INVALID_ENUM,
            "%s(internalformat=%s not legal for immutable-format)",
            func, _mesa_lookup_enum_by_nr(internalformat));
      return;
   }

   if (!is_renderable_texture_format(ctx, internalformat)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
            "%s(internalformat=%s)",
            func, _mesa_lookup_enum_by_nr(internalformat));
      return;
   }

   sample_count_error = _mesa_check_sample_count(ctx, target,
         internalformat, samples);
   if (sample_count_error != GL_NO_ERROR) {
      _mesa_error(ctx, sample_count_error, "%s(samples)", func);
      return;
   }

   texObj = _mesa_get_current_tex_object(ctx, target);

   if (immutable && (!texObj || (texObj->Name == 0))) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
            "%s(texture object 0)",
            func);
      return;
   }

   texImage = _mesa_get_tex_image(ctx, texObj, 0, 0);

   if (texImage == NULL) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "%s()", func);
      return;
   }

   texFormat = _mesa_choose_texture_format(ctx, texObj, target, 0,
         internalformat, GL_NONE, GL_NONE);
   assert(texFormat != MESA_FORMAT_NONE);

   dimensionsOK = _mesa_legal_texture_dimensions(ctx, target, 0,
         width, height, depth, 0);

   sizeOK = ctx->Driver.TestProxyTexImage(ctx, target, 0, texFormat,
         width, height, depth, 0);

   if (_mesa_is_proxy_texture(target)) {
      if (dimensionsOK && sizeOK) {
         _mesa_init_teximage_fields(ctx, texImage,
               width, height, depth, 0, internalformat, texFormat);
         texImage->NumSamples = samples;
         texImage->FixedSampleLocations = fixedsamplelocations;
      }
      else {
         /* clear all image fields */
         _mesa_init_teximage_fields(ctx, texImage,
               0, 0, 0, 0, GL_NONE, MESA_FORMAT_NONE);
      }
   }
   else {
      if (!dimensionsOK) {
         _mesa_error(ctx, GL_INVALID_VALUE,
               "%s(invalid width or height)", func);
         return;
      }

      if (!sizeOK) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY,
               "%s(texture too large)", func);
         return;
      }

      /* Check if texObj->Immutable is set */
      if (texObj->Immutable) {
         _mesa_error(ctx, GL_INVALID_OPERATION, "%s(immutable)", func);
         return;
      }

      ctx->Driver.FreeTextureImageBuffer(ctx, texImage);

      _mesa_init_teximage_fields(ctx, texImage,
            width, height, depth, 0, internalformat, texFormat);

      texImage->NumSamples = samples;
      texImage->FixedSampleLocations = fixedsamplelocations;

      if (width > 0 && height > 0 && depth > 0) {
         if (!ctx->Driver.AllocTextureStorage(ctx, texObj, 1,
                  width, height, depth)) {
            /* tidy up the texture image state. strictly speaking,
             * we're allowed to just leave this in whatever state we
             * like, but being tidy is good.
             */
            _mesa_init_teximage_fields(ctx, texImage,
                  0, 0, 0, 0, GL_NONE, MESA_FORMAT_NONE);
         }
      }

      texObj->Immutable = immutable;
      _mesa_update_fbo_texture(ctx, texObj, 0, 0);
   }
}


void GLAPIENTRY
_mesa_TexImage2DMultisample(GLenum target, GLsizei samples,
                            GLint internalformat, GLsizei width,
                            GLsizei height, GLboolean fixedsamplelocations)
{
   teximagemultisample(2, target, samples, internalformat,
                       width, height, 1, fixedsamplelocations, GL_FALSE,
                       "glTexImage2DMultisample");
}


void GLAPIENTRY
_mesa_TexImage3DMultisample(GLenum target, GLsizei samples,
                            GLint internalformat, GLsizei width,
                            GLsizei height, GLsizei depth,
                            GLboolean fixedsamplelocations)
{
   teximagemultisample(3, target, samples, internalformat,
                       width, height, depth, fixedsamplelocations, GL_FALSE,
                       "glTexImage3DMultisample");
}


void GLAPIENTRY
_mesa_TexStorage2DMultisample(GLenum target, GLsizei samples,
                              GLenum internalformat, GLsizei width,
                              GLsizei height, GLboolean fixedsamplelocations)
{
   teximagemultisample(2, target, samples, internalformat,
                       width, height, 1, fixedsamplelocations, GL_TRUE,
                       "glTexStorage2DMultisample");
}


void GLAPIENTRY
_mesa_TexStorage3DMultisample(GLenum target, GLsizei samples,
                              GLenum internalformat, GLsizei width,
                              GLsizei height, GLsizei depth,
                              GLboolean fixedsamplelocations)
{
   teximagemultisample(3, target, samples, internalformat,
                       width, height, depth, fixedsamplelocations, GL_TRUE,
                       "glTexStorage3DMultisample");
@


1.1.1.6
log
@Import Mesa 9.2.2
@
text
@d1108 1
a1442 2
      if (width != height)
         return GL_FALSE;
d1496 1
a1496 3
      if (depth < 1 || depth > ctx->Const.MaxArrayTextureLayers || depth % 6)
         return GL_FALSE;
      if (width != height)
d1987 21
d2239 8
d2590 7
@


1.1.1.7
log
@Import Mesa 10.2.3
@
text
@a50 1
#include "textureview.h"
a161 3
         case GL_DEPTH_STENCIL:
         case GL_DEPTH24_STENCIL8:
            return GL_DEPTH_STENCIL;
d303 10
d401 5
d426 5
a663 13
   unsigned i;
   static const GLenum targets[] = {
      GL_PROXY_TEXTURE_1D,
      GL_PROXY_TEXTURE_2D,
      GL_PROXY_TEXTURE_3D,
      GL_PROXY_TEXTURE_CUBE_MAP,
      GL_PROXY_TEXTURE_RECTANGLE,
      GL_PROXY_TEXTURE_1D_ARRAY,
      GL_PROXY_TEXTURE_2D_ARRAY,
      GL_PROXY_TEXTURE_CUBE_MAP_ARRAY,
      GL_PROXY_TEXTURE_2D_MULTISAMPLE,
      GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY
   };
d665 1
a665 1
    * NUM_TEXTURE_TARGETS should match number of terms above, except there's no
d668 1
a668 1
   STATIC_ASSERT(NUM_TEXTURE_TARGETS == Elements(targets) + 2);
d670 10
a679 4
   for (i = 0; i < Elements(targets); ++i)
      if (target == targets[i])
         return GL_TRUE;
   return GL_FALSE;
d686 2
a687 2
static GLenum
proxy_target(GLenum target)
d727 1
a727 1
      _mesa_problem(NULL, "unexpected target in proxy_target()");
d734 8
a741 3
 * Return a pointer to the current texture object for the given target
 * on the current texture unit.
 * Note: all <target> error checking should have been done by this point.
d744 3
a746 1
_mesa_get_current_tex_object(struct gl_context *ctx, GLenum target)
d748 2
a749 2
   struct gl_texture_unit *texUnit = _mesa_get_current_tex_unit(ctx);
   const GLboolean arrayTex = ctx->Extensions.EXT_texture_array;
d816 1
a816 1
         _mesa_problem(NULL, "bad target in _mesa_get_current_tex_object()");
d822 10
d1014 2
a1015 1
      return ctx->Extensions.EXT_texture_array
a1086 87
 * Check if a texture target can have more than one layer.
 */
GLboolean
_mesa_tex_target_is_layered(GLenum target)
{
   switch (target) {
   case GL_TEXTURE_1D:
   case GL_PROXY_TEXTURE_1D:
   case GL_TEXTURE_2D:
   case GL_PROXY_TEXTURE_2D:
   case GL_TEXTURE_RECTANGLE:
   case GL_PROXY_TEXTURE_RECTANGLE:
   case GL_TEXTURE_2D_MULTISAMPLE:
   case GL_PROXY_TEXTURE_2D_MULTISAMPLE:
   case GL_TEXTURE_BUFFER:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
   case GL_TEXTURE_EXTERNAL_OES:
      return GL_FALSE;

   case GL_TEXTURE_3D:
   case GL_PROXY_TEXTURE_3D:
   case GL_TEXTURE_CUBE_MAP:
   case GL_PROXY_TEXTURE_CUBE_MAP:
   case GL_TEXTURE_1D_ARRAY:
   case GL_PROXY_TEXTURE_1D_ARRAY:
   case GL_TEXTURE_2D_ARRAY:
   case GL_PROXY_TEXTURE_2D_ARRAY:
   case GL_TEXTURE_CUBE_MAP_ARRAY:
   case GL_PROXY_TEXTURE_CUBE_MAP_ARRAY:
   case GL_TEXTURE_2D_MULTISAMPLE_ARRAY:
   case GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY:
      return GL_TRUE;

   default:
      assert(!"Invalid texture target.");
      return GL_FALSE;
   }
}


/**
 * Return the number of layers present in the given level of an array,
 * cubemap or 3D texture.  If the texture is not layered return zero.
 */
GLuint
_mesa_get_texture_layers(const struct gl_texture_object *texObj, GLint level)
{
   assert(level >= 0 && level < MAX_TEXTURE_LEVELS);

   switch (texObj->Target) {
   case GL_TEXTURE_1D:
   case GL_TEXTURE_2D:
   case GL_TEXTURE_RECTANGLE:
   case GL_TEXTURE_2D_MULTISAMPLE:
   case GL_TEXTURE_BUFFER:
   case GL_TEXTURE_EXTERNAL_OES:
      return 0;

   case GL_TEXTURE_CUBE_MAP:
      return 6;

   case GL_TEXTURE_1D_ARRAY: {
      struct gl_texture_image *img = texObj->Image[0][level];
      return img ? img->Height : 0;
   }

   case GL_TEXTURE_3D:
   case GL_TEXTURE_2D_ARRAY:
   case GL_TEXTURE_CUBE_MAP_ARRAY:
   case GL_TEXTURE_2D_MULTISAMPLE_ARRAY: {
      struct gl_texture_image *img = texObj->Image[0][level];
      return img ? img->Depth : 0;
   }

   default:
      assert(!"Invalid texture target.");
      return 0;
   }
}


/**
a1227 2
 * \param numSamples  number of samples per texel, or zero for non-MS.
 * \param fixedSampleLocations  are sample locations fixed?
d1232 6
a1237 7
static void
init_teximage_fields_ms(struct gl_context *ctx,
                        struct gl_texture_image *img,
                        GLsizei width, GLsizei height, GLsizei depth,
                        GLint border, GLenum internalFormat,
                        mesa_format format,
                        GLuint numSamples, GLboolean fixedSampleLocations)
a1334 14
   img->NumSamples = numSamples;
   img->FixedSampleLocations = fixedSampleLocations;
}


void
_mesa_init_teximage_fields(struct gl_context *ctx,
                           struct gl_texture_image *img,
                           GLsizei width, GLsizei height, GLsizei depth,
                           GLint border, GLenum internalFormat,
                           mesa_format format)
{
   init_teximage_fields_ms(ctx, img, width, height, depth, border,
                           internalFormat, format, 0, GL_TRUE);
d1480 1
a1480 1
      if (depth < 0 || depth > ctx->Const.MaxArrayTextureLayers)
d1497 1
a1497 1
      if (depth < 0 || depth > ctx->Const.MaxArrayTextureLayers || depth % 6)
d1583 1
a1583 4
      GLint zBorder = (target == GL_TEXTURE_2D_ARRAY ||
                       target == GL_TEXTURE_CUBE_MAP_ARRAY) ?
                         0 : destImage->Border;

d1660 1
a1660 1
                          mesa_format format,
d1722 2
a1723 1
      return ctx->Extensions.EXT_texture_array;
d1771 3
a1773 1
         return _mesa_is_desktop_gl(ctx) && ctx->Extensions.EXT_texture_array;
d1784 3
a1786 1
         return (_mesa_is_desktop_gl(ctx) && ctx->Extensions.EXT_texture_array)
d1789 3
a1791 1
         return _mesa_is_desktop_gl(ctx) && ctx->Extensions.EXT_texture_array;
d1832 3
a1834 1
         return _mesa_is_desktop_gl(ctx) && ctx->Extensions.EXT_texture_array;
d1843 3
a1845 1
         return (_mesa_is_desktop_gl(ctx) && ctx->Extensions.EXT_texture_array)
d1880 1
a1880 1
   mesa_format mesaFormat = _mesa_glenum_to_compressed_format(glformat);
a1883 69
/**
 * Verify that a texture format is valid with a particular target
 *
 * In particular, textures with base format of \c GL_DEPTH_COMPONENT or
 * \c GL_DEPTH_STENCIL are only valid with certain, context dependent texture
 * targets.
 *
 * \param ctx             GL context
 * \param target          Texture target
 * \param internalFormat  Internal format of the texture image
 * \param dimensions      Dimensionality at the caller.  This is \b not used
 *                        in the validation.  It is only used when logging
 *                        error messages.
 * \param caller          Base name of the calling function (e.g.,
 *                        "glTexImage" or "glTexStorage").
 *
 * \returns true if the combination is legal, false otherwise.
 */
bool
_mesa_legal_texture_base_format_for_target(struct gl_context *ctx,
                                           GLenum target, GLenum internalFormat,
                                           unsigned dimensions,
                                           const char *caller)
{
   if (_mesa_base_tex_format(ctx, internalFormat) == GL_DEPTH_COMPONENT
       || _mesa_base_tex_format(ctx, internalFormat) == GL_DEPTH_STENCIL) {
      /* Section 3.8.3 (Texture Image Specification) of the OpenGL 3.3 Core
       * Profile spec says:
       *
       *     "Textures with a base internal format of DEPTH_COMPONENT or
       *     DEPTH_STENCIL are supported by texture image specification
       *     commands only if target is TEXTURE_1D, TEXTURE_2D,
       *     TEXTURE_1D_ARRAY, TEXTURE_2D_ARRAY, TEXTURE_RECTANGLE,
       *     TEXTURE_CUBE_MAP, PROXY_TEXTURE_1D, PROXY_TEXTURE_2D,
       *     PROXY_TEXTURE_1D_ARRAY, PROXY_TEXTURE_2D_ARRAY,
       *     PROXY_TEXTURE_RECTANGLE, or PROXY_TEXTURE_CUBE_MAP. Using these
       *     formats in conjunction with any other target will result in an
       *     INVALID_OPERATION error."
       *
       * Cubemaps are only supported with desktop OpenGL version >= 3.0,
       * EXT_gpu_shader4, or, on OpenGL ES 2.0+, OES_depth_texture_cube_map.
       */
      if (target != GL_TEXTURE_1D &&
          target != GL_PROXY_TEXTURE_1D &&
          target != GL_TEXTURE_2D &&
          target != GL_PROXY_TEXTURE_2D &&
          target != GL_TEXTURE_1D_ARRAY &&
          target != GL_PROXY_TEXTURE_1D_ARRAY &&
          target != GL_TEXTURE_2D_ARRAY &&
          target != GL_PROXY_TEXTURE_2D_ARRAY &&
          target != GL_TEXTURE_RECTANGLE_ARB &&
          target != GL_PROXY_TEXTURE_RECTANGLE_ARB &&
         !((_mesa_is_cube_face(target) ||
            target == GL_TEXTURE_CUBE_MAP ||
            target == GL_PROXY_TEXTURE_CUBE_MAP) &&
           (ctx->Version >= 30 || ctx->Extensions.EXT_gpu_shader4
            || (ctx->API == API_OPENGLES2 && ctx->Extensions.OES_depth_texture_cube_map))) &&
          !((target == GL_TEXTURE_CUBE_MAP_ARRAY ||
             target == GL_PROXY_TEXTURE_CUBE_MAP_ARRAY) &&
            ctx->Extensions.ARB_texture_cube_map_array)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "%s%dD(bad target for depth texture)",
                     caller, dimensions);
         return false;
      }
   }

   return true;
}
a1918 2
   GLboolean is_format_depth_or_depthstencil;
   GLboolean is_internalFormat_depth_or_depthstencil;
a2008 8
   is_internalFormat_depth_or_depthstencil =
      _mesa_is_depth_format(internalFormat) ||
      _mesa_is_depthstencil_format(internalFormat);

   is_format_depth_or_depthstencil =
      _mesa_is_depth_format(format) ||
      _mesa_is_depthstencil_format(format);

d2011 1
a2011 1
       (is_internalFormat_depth_or_depthstencil != is_format_depth_or_depthstencil) ||
d2013 1
d2054 26
a2079 3
   if (!_mesa_legal_texture_base_format_for_target(ctx, target, internalFormat,
                                                   dimensions, "glTexImage"))
      return GL_TRUE;
d2147 3
a2149 4
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "glCompressedTexImage%dD(internalFormat=%s)",
                  dimensions, _mesa_lookup_enum_by_nr(internalFormat));
      return GL_TRUE;
a2240 1
   /* Note: not all error paths exit through here. */
d2456 1
a2456 2
                     "glCopyTexImage%dD(internalFormat=%s)", dimensions,
                     _mesa_lookup_enum_by_nr(internalFormat));
d2464 1
a2464 2
                  "glCopyTexImage%dD(internalFormat=%s)", dimensions,
                  _mesa_lookup_enum_by_nr(internalFormat));
d2473 1
a2473 2
                     "glCopyTexImage%dD(internalFormat=%s)", dimensions,
                     _mesa_lookup_enum_by_nr(internalFormat));
d2499 1
a2499 2
                     "glCopyTexImage%dD(internalFormat=%s)", dimensions,
                     _mesa_lookup_enum_by_nr(internalFormat));
d2841 1
a2841 1
mesa_format
d2847 1
a2847 1
   mesa_format f;
d2866 1
a2866 1
    * have the DXTn library, force a generic compressed format instead.
d2969 1
a2969 1
   mesa_format texFormat;
d3060 1
a3060 1
   sizeOK = ctx->Driver.TestProxyTexImage(ctx, proxy_target(target),
d3142 1
a3142 1
            _mesa_dirty_texobj(ctx, texObj);
d3261 1
a3261 1
      _mesa_dirty_texobj(ctx, texObj);
d3335 1
a3335 3
         /* NOTE: Don't signal _NEW_TEXTURE since we've only changed
          * the texel data, not the texture format, size, etc.
          */
d3393 1
a3393 1
get_copy_tex_image_source(struct gl_context *ctx, mesa_format texFormat)
d3447 1
a3447 1
   mesa_format texFormat;
d3479 1
a3479 1
   if (!ctx->Driver.TestProxyTexImage(ctx, proxy_target(target),
d3532 1
a3532 1
         _mesa_dirty_texobj(ctx, texObj);
d3622 1
a3622 3
         /* NOTE: Don't signal _NEW_TEXTURE since we've only changed
          * the texel data, not the texture format, size, etc.
          */
d3847 1
a3847 3
         /* NOTE: Don't signal _NEW_TEXTURE since we've only changed
          * the texel data, not the texture format, size, etc.
          */
d3885 1
a3885 1
static mesa_format
a3887 101
   if (ctx->API != API_OPENGL_CORE) {
      switch (internalFormat) {
      case GL_ALPHA8:
         return MESA_FORMAT_A_UNORM8;
      case GL_ALPHA16:
         return MESA_FORMAT_A_UNORM16;
      case GL_ALPHA16F_ARB:
         return MESA_FORMAT_A_FLOAT16;
      case GL_ALPHA32F_ARB:
         return MESA_FORMAT_A_FLOAT32;
      case GL_ALPHA8I_EXT:
         return MESA_FORMAT_A_SINT8;
      case GL_ALPHA16I_EXT:
         return MESA_FORMAT_A_SINT16;
      case GL_ALPHA32I_EXT:
         return MESA_FORMAT_A_SINT32;
      case GL_ALPHA8UI_EXT:
         return MESA_FORMAT_A_UINT8;
      case GL_ALPHA16UI_EXT:
         return MESA_FORMAT_A_UINT16;
      case GL_ALPHA32UI_EXT:
         return MESA_FORMAT_A_UINT32;
      case GL_LUMINANCE8:
         return MESA_FORMAT_L_UNORM8;
      case GL_LUMINANCE16:
         return MESA_FORMAT_L_UNORM16;
      case GL_LUMINANCE16F_ARB:
         return MESA_FORMAT_L_FLOAT16;
      case GL_LUMINANCE32F_ARB:
         return MESA_FORMAT_L_FLOAT32;
      case GL_LUMINANCE8I_EXT:
         return MESA_FORMAT_L_SINT8;
      case GL_LUMINANCE16I_EXT:
         return MESA_FORMAT_L_SINT16;
      case GL_LUMINANCE32I_EXT:
         return MESA_FORMAT_L_SINT32;
      case GL_LUMINANCE8UI_EXT:
         return MESA_FORMAT_L_UINT8;
      case GL_LUMINANCE16UI_EXT:
         return MESA_FORMAT_L_UINT16;
      case GL_LUMINANCE32UI_EXT:
         return MESA_FORMAT_L_UINT32;
      case GL_LUMINANCE8_ALPHA8:
         return MESA_FORMAT_L8A8_UNORM;
      case GL_LUMINANCE16_ALPHA16:
         return MESA_FORMAT_L16A16_UNORM;
      case GL_LUMINANCE_ALPHA16F_ARB:
         return MESA_FORMAT_LA_FLOAT16;
      case GL_LUMINANCE_ALPHA32F_ARB:
         return MESA_FORMAT_LA_FLOAT32;
      case GL_LUMINANCE_ALPHA8I_EXT:
         return MESA_FORMAT_LA_SINT8;
      case GL_LUMINANCE_ALPHA16I_EXT:
         return MESA_FORMAT_LA_SINT8;
      case GL_LUMINANCE_ALPHA32I_EXT:
         return MESA_FORMAT_LA_SINT16;
      case GL_LUMINANCE_ALPHA8UI_EXT:
         return MESA_FORMAT_LA_UINT8;
      case GL_LUMINANCE_ALPHA16UI_EXT:
         return MESA_FORMAT_LA_UINT16;
      case GL_LUMINANCE_ALPHA32UI_EXT:
         return MESA_FORMAT_LA_UINT32;
      case GL_INTENSITY8:
         return MESA_FORMAT_I_UNORM8;
      case GL_INTENSITY16:
         return MESA_FORMAT_I_UNORM16;
      case GL_INTENSITY16F_ARB:
         return MESA_FORMAT_I_FLOAT16;
      case GL_INTENSITY32F_ARB:
         return MESA_FORMAT_I_FLOAT32;
      case GL_INTENSITY8I_EXT:
         return MESA_FORMAT_I_SINT8;
      case GL_INTENSITY16I_EXT:
         return MESA_FORMAT_I_SINT16;
      case GL_INTENSITY32I_EXT:
         return MESA_FORMAT_I_SINT32;
      case GL_INTENSITY8UI_EXT:
         return MESA_FORMAT_I_UINT8;
      case GL_INTENSITY16UI_EXT:
         return MESA_FORMAT_I_UINT16;
      case GL_INTENSITY32UI_EXT:
         return MESA_FORMAT_I_UINT32;
      default:
         break;
      }
   }

   if (ctx->API == API_OPENGL_CORE &&
       ctx->Extensions.ARB_texture_buffer_object_rgb32) {
      switch (internalFormat) {
      case GL_RGB32F:
         return MESA_FORMAT_RGB_FLOAT32;
      case GL_RGB32UI:
         return MESA_FORMAT_RGB_UINT32;
      case GL_RGB32I:
         return MESA_FORMAT_RGB_SINT32;
      default:
         break;
      }
   }

d3889 80
d3970 1
a3970 1
      return MESA_FORMAT_R8G8B8A8_UNORM;
d3972 1
a3972 1
      return MESA_FORMAT_RGBA_UNORM16;
d3978 1
a3978 1
      return MESA_FORMAT_RGBA_SINT8;
d3980 1
a3980 1
      return MESA_FORMAT_RGBA_SINT16;
d3982 1
a3982 1
      return MESA_FORMAT_RGBA_SINT32;
d3991 1
a3991 1
      return MESA_FORMAT_R8G8_UNORM;
d3993 1
a3993 1
      return MESA_FORMAT_R16G16_UNORM;
d3999 1
a3999 1
      return MESA_FORMAT_RG_SINT8;
d4001 1
a4001 1
      return MESA_FORMAT_RG_SINT16;
d4003 1
a4003 1
      return MESA_FORMAT_RG_SINT32;
d4012 1
a4012 1
      return MESA_FORMAT_R_UNORM8;
d4014 1
a4014 1
      return MESA_FORMAT_R_UNORM16;
d4020 1
a4020 1
      return MESA_FORMAT_R_SINT8;
d4022 1
a4022 1
      return MESA_FORMAT_R_SINT16;
d4024 1
a4024 1
      return MESA_FORMAT_R_SINT32;
d4032 7
d4045 2
a4046 3
mesa_format
_mesa_validate_texbuffer_format(const struct gl_context *ctx,
                                GLenum internalFormat)
d4048 1
a4048 1
   mesa_format format = get_texbuffer_format(ctx, internalFormat);
d4055 2
d4058 1
a4058 11
   /* The GL_ARB_texture_buffer_object spec says:
    *
    *     "If ARB_texture_float is not supported, references to the
    *     floating-point internal formats provided by that extension should be
    *     removed, and such formats may not be passed to TexBufferARB."
    *
    * As a result, GL_HALF_FLOAT internal format depends on both
    * GL_ARB_texture_float and GL_ARB_half_float_pixel.
    */
   if ((datatype == GL_FLOAT || datatype == GL_HALF_FLOAT) &&
       !ctx->Extensions.ARB_texture_float)
d4061 5
a4065 1
   if (!ctx->Extensions.ARB_texture_rg) {
d4067 1
d4069 1
a4069 1
         return MESA_FORMAT_NONE;
d4087 1
a4087 1
   mesa_format format;
d4096 1
a4096 1
   format = _mesa_validate_texbuffer_format(ctx, internalFormat);
d4223 2
a4224 2
   GLboolean sizeOK, dimensionsOK, samplesOK;
   mesa_format texFormat;
d4260 1
a4260 11
   samplesOK = sample_count_error == GL_NO_ERROR;

   /* Page 254 of OpenGL 4.4 spec says:
    *   "Proxy arrays for two-dimensional multisample and two-dimensional
    *    multisample array textures are operated on in the same way when
    *    TexImage2DMultisample is called with target specified as
    *    PROXY_TEXTURE_2D_MULTISAMPLE, or TexImage3DMultisample is called
    *    with target specified as PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY.
    *    However, if samples is not supported, then no error is generated.
    */
   if (!samplesOK && !_mesa_is_proxy_texture(target)) {
d4292 5
a4296 4
      if (samplesOK && dimensionsOK && sizeOK) {
         init_teximage_fields_ms(ctx, texImage, width, height, depth, 0,
                                 internalformat, texFormat,
                                 samples, fixedsamplelocations);
d4300 2
a4301 1
         clear_teximage_fields(texImage);
d4325 5
a4329 3
      init_teximage_fields_ms(ctx, texImage, width, height, depth, 0,
                              internalformat, texFormat,
                              samples, fixedsamplelocations);
a4343 5

      if (immutable) {
         _mesa_set_texture_view_state(ctx, texObj, target, 1);
      }

d4351 1
a4351 1
                            GLenum internalformat, GLsizei width,
d4362 1
a4362 1
                            GLenum internalformat, GLsizei width,
@


1.1.1.8
log
@Import Mesa 10.2.7
@
text
@d1782 3
a1784 3
GLboolean
_mesa_target_can_be_compressed(const struct gl_context *ctx, GLenum target,
                               GLenum intFormat)
a1792 1
   case GL_TEXTURE_CUBE_MAP:
d2207 1
a2207 1
      if (!_mesa_target_can_be_compressed(ctx, target, internalFormat)) {
d2263 1
a2263 1
   if (!_mesa_target_can_be_compressed(ctx, target, internalFormat)) {
d2265 1
a2265 8
      /* From section 3.8.6, page 146 of OpenGL ES 3.0 spec:
       *
       *    "The ETC2/EAC texture compression algorithm supports only
       *     two-dimensional images. If internalformat is an ETC2/EAC format,
       *     CompressedTexImage3D will generate an INVALID_OPERATION error if
       *     target is not TEXTURE_2D_ARRAY."
       */
      error = _mesa_is_desktop_gl(ctx) ? GL_INVALID_ENUM : GL_INVALID_OPERATION;
a2662 11

      /* Page 139, Table 3.15 of OpenGL ES 3.0 spec does not define ReadPixels
       * types for SNORM formats. Also, conversion to SNORM formats is not
       * allowed by Table 3.2 on Page 110.
       */
      if(_mesa_is_enum_format_snorm(internalFormat)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glCopyTexImage%dD(internalFormat=%s)", dimensions,
                     _mesa_lookup_enum_by_nr(internalFormat));
         return GL_TRUE;
      }
a2680 2
      bool is_unorm = _mesa_is_enum_format_unorm(internalFormat);
      bool is_rbunorm = _mesa_is_enum_format_unorm(rb_internal_format);
a2693 13

      /* From page 138 of OpenGL ES 3.0 spec:
       *    "The error INVALID_OPERATION is generated if floating-point RGBA
       *    data is required; if signed integer RGBA data is required and the
       *    format of the current color buffer is not signed integer; if
       *    unsigned integer RGBA data is required and the format of the
       *    current color buffer is not unsigned integer; or if fixed-point
       *    RGBA data is required and the format of the current color buffer
       *    is not fixed-point.
       */
      if (_mesa_is_gles(ctx) && is_unorm != is_rbunorm)
            _mesa_error(ctx, GL_INVALID_OPERATION,
                        "glCopyTexImage%dD(unorm vs non-unorm)", dimensions);
d2697 1
a2697 1
      if (!_mesa_target_can_be_compressed(ctx, target, internalFormat)) {
a3566 22
static GLboolean
formats_differ_in_component_sizes (mesa_format f1,
                                   mesa_format f2)
{
   GLint f1_r_bits = _mesa_get_format_bits(f1, GL_RED_BITS);
   GLint f1_g_bits = _mesa_get_format_bits(f1, GL_GREEN_BITS);
   GLint f1_b_bits = _mesa_get_format_bits(f1, GL_BLUE_BITS);
   GLint f1_a_bits = _mesa_get_format_bits(f1, GL_ALPHA_BITS);

   GLint f2_r_bits = _mesa_get_format_bits(f2, GL_RED_BITS);
   GLint f2_g_bits = _mesa_get_format_bits(f2, GL_GREEN_BITS);
   GLint f2_b_bits = _mesa_get_format_bits(f2, GL_BLUE_BITS);
   GLint f2_a_bits = _mesa_get_format_bits(f2, GL_ALPHA_BITS);

   if ((f1_r_bits && f2_r_bits && f1_r_bits != f2_r_bits)
       || (f1_g_bits && f2_g_bits && f1_g_bits != f2_g_bits)
       || (f1_b_bits && f2_b_bits && f1_b_bits != f2_b_bits)
       || (f1_a_bits && f2_a_bits && f1_a_bits != f2_a_bits))
      return GL_TRUE;

   return GL_FALSE;
}
a3579 1
   struct gl_renderbuffer *rb;
a3608 34

   rb = _mesa_get_read_renderbuffer_for_format(ctx, internalFormat);

   if (_mesa_is_gles3(ctx)) {
      if (_mesa_is_enum_format_unsized(internalFormat)) {
      /* Conversion from GL_RGB10_A2 source buffer format is not allowed in
       * OpenGL ES 3.0. Khronos bug# 9807.
       */
         if (rb->InternalFormat == GL_RGB10_A2) {
               _mesa_error(ctx, GL_INVALID_OPERATION,
                           "glCopyTexImage%uD(Reading from GL_RGB10_A2 buffer and"
                           " writing to unsized internal format)", dims);
               return;
         }
      }
      /* From Page 139 of OpenGL ES 3.0 spec:
       *    "If internalformat is sized, the internal format of the new texel
       *    array is internalformat, and this is also the new texel array’s
       *    effective internal format. If the component sizes of internalformat
       *    do not exactly match the corresponding component sizes of the source
       *    buffer’s effective internal format, described below, an
       *    INVALID_OPERATION error is generated. If internalformat is unsized,
       *    the internal format of the new texel array is the effective internal
       *    format of the source buffer, and this is also the new texel array’s
       *    effective internal format.
       */
      else if (formats_differ_in_component_sizes (texFormat, rb->Format)) {
            _mesa_error(ctx, GL_INVALID_OPERATION,
                        "glCopyTexImage%uD(componenet size changed in"
                        " internal format)", dims);
            return;
      }
   }

@


1.1.1.9
log
@Import Mesa 10.4.3
@
text
@a43 1
#include "pixelstore.h"
a53 1
#include "texstore.h"
d258 10
a531 14
   if (_mesa_is_desktop_gl(ctx) &&
       ctx->Extensions.ARB_texture_compression_bptc) {
      switch (internalFormat) {
      case GL_COMPRESSED_RGBA_BPTC_UNORM:
      case GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:
         return GL_RGBA;
      case GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:
      case GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:
         return GL_RGB;
      default:
         ; /* fallthrough */
      }
   }

d1539 1
a1539 1
      if (height < 0 || height > ctx->Const.MaxArrayTextureLayers)
a2023 37
static bool
texture_formats_agree(GLenum internalFormat,
                      GLenum format)
{
   GLboolean colorFormat;
   GLboolean is_format_depth_or_depthstencil;
   GLboolean is_internalFormat_depth_or_depthstencil;

   /* Even though there are no color-index textures, we still have to support
    * uploading color-index data and remapping it to RGB via the
    * GL_PIXEL_MAP_I_TO_[RGBA] tables.
    */
   const GLboolean indexFormat = (format == GL_COLOR_INDEX);

   is_internalFormat_depth_or_depthstencil =
      _mesa_is_depth_format(internalFormat) ||
      _mesa_is_depthstencil_format(internalFormat);

   is_format_depth_or_depthstencil =
      _mesa_is_depth_format(format) ||
      _mesa_is_depthstencil_format(format);

   colorFormat = _mesa_is_color_format(format);

   if (_mesa_is_color_format(internalFormat) && !colorFormat && !indexFormat)
      return false;

   if (is_internalFormat_depth_or_depthstencil !=
       is_format_depth_or_depthstencil)
      return false;

   if (_mesa_is_ycbcr_format(internalFormat) != _mesa_is_ycbcr_format(format))
      return false;

   return true;
}

d2057 3
d2062 6
d2150 13
a2162 1
   if (!texture_formats_agree(internalFormat, format)) {
a2353 7
   /* Check for invalid pixel storage modes */
   if (!_mesa_compressed_pixel_storage_error_check(ctx, dimensions,
                                                   &ctx->Unpack,
                                                   "glCompressedTexImage")) {
      return GL_FALSE;
   }

d2423 1
a2423 1
      _mesa_error(ctx, GL_INVALID_VALUE, "glTexSubImage%uD(level=%d)",
d3061 1
a3061 1
   f = ctx->Driver.ChooseTextureFormat(ctx, target, internalFormat,
a3885 260
static bool
check_clear_tex_image(struct gl_context *ctx,
                      const char *function,
                      struct gl_texture_image *texImage,
                      GLenum format, GLenum type,
                      const void *data,
                      GLubyte *clearValue)
{
   struct gl_texture_object *texObj = texImage->TexObject;
   static const GLubyte zeroData[MAX_PIXEL_BYTES];
   GLenum internalFormat = texImage->InternalFormat;
   GLenum err;

   if (texObj->Target == GL_TEXTURE_BUFFER) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "%s(buffer texture)", function);
      return false;
   }

   if (_mesa_is_compressed_format(ctx, internalFormat)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "%s(compressed texture)", function);
      return false;
   }

   err = _mesa_error_check_format_and_type(ctx, format, type);
   if (err != GL_NO_ERROR) {
      _mesa_error(ctx, err,
                  "%s(incompatible format = %s, type = %s)",
                  function,
                  _mesa_lookup_enum_by_nr(format),
                  _mesa_lookup_enum_by_nr(type));
      return false;
   }

   /* make sure internal format and format basically agree */
   if (!texture_formats_agree(internalFormat, format)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "%s(incompatible internalFormat = %s, format = %s)",
                  function,
                  _mesa_lookup_enum_by_nr(internalFormat),
                  _mesa_lookup_enum_by_nr(format));
      return false;
   }

   if (ctx->Version >= 30 || ctx->Extensions.EXT_texture_integer) {
      /* both source and dest must be integer-valued, or neither */
      if (_mesa_is_format_integer_color(texImage->TexFormat) !=
          _mesa_is_enum_format_integer(format)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "%s(integer/non-integer format mismatch)",
                     function);
         return false;
      }
   }

   if (!_mesa_texstore(ctx,
                       1, /* dims */
                       texImage->_BaseFormat,
                       texImage->TexFormat,
                       0, /* dstRowStride */
                       &clearValue,
                       1, 1, 1, /* srcWidth/Height/Depth */
                       format, type,
                       data ? data : zeroData,
                       &ctx->DefaultPacking)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "%s(invalid format)", function);
      return false;
   }

   return true;
}

static struct gl_texture_object *
get_tex_obj_for_clear(struct gl_context *ctx,
                      const char *function,
                      GLuint texture)
{
   struct gl_texture_object *texObj;

   if (texture == 0) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "%s(zero texture)", function);
      return NULL;
   }

   texObj = _mesa_lookup_texture(ctx, texture);

   if (texObj == NULL) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "%s(non-gen name)", function);
      return NULL;
   }

   if (texObj->Target == 0) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "%s(unbound tex)", function);
      return NULL;
   }

   return texObj;
}

static int
get_tex_images_for_clear(struct gl_context *ctx,
                         const char *function,
                         struct gl_texture_object *texObj,
                         GLint level,
                         struct gl_texture_image **texImages)
{
   GLenum target;
   int i;

   if (level < 0 || level >= MAX_TEXTURE_LEVELS) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "%s(invalid level)", function);
      return 0;
   }

   if (texObj->Target == GL_TEXTURE_CUBE_MAP) {
      for (i = 0; i < MAX_FACES; i++) {
         target = GL_TEXTURE_CUBE_MAP_POSITIVE_X + i;

         texImages[i] = _mesa_select_tex_image(ctx, texObj, target, level);
         if (texImages[i] == NULL) {
            _mesa_error(ctx, GL_INVALID_OPERATION,
                        "%s(invalid level)", function);
            return 0;
         }
      }

      return MAX_FACES;
   }

   texImages[0] = _mesa_select_tex_image(ctx, texObj, texObj->Target, level);

   if (texImages[0] == NULL) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "%s(invalid level)", function);
      return 0;
   }

   return 1;
}

void GLAPIENTRY
_mesa_ClearTexSubImage( GLuint texture, GLint level,
                        GLint xoffset, GLint yoffset, GLint zoffset,
                        GLsizei width, GLsizei height, GLsizei depth,
                        GLenum format, GLenum type, const void *data )
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_texture_object *texObj;
   struct gl_texture_image *texImages[MAX_FACES];
   GLubyte clearValue[MAX_FACES][MAX_PIXEL_BYTES];
   int i, numImages;
   int minDepth, maxDepth;

   texObj = get_tex_obj_for_clear(ctx, "glClearTexSubImage", texture);

   if (texObj == NULL)
      return;

   _mesa_lock_texture(ctx, texObj);

   numImages = get_tex_images_for_clear(ctx, "glClearTexSubImage",
                                        texObj, level, texImages);
   if (numImages == 0)
      goto out;

   if (numImages == 1) {
      minDepth = -(int) texImages[0]->Border;
      maxDepth = texImages[0]->Depth;
   } else {
      minDepth = 0;
      maxDepth = numImages;
   }

   if (xoffset < -(GLint) texImages[0]->Border ||
       yoffset < -(GLint) texImages[0]->Border ||
       zoffset < minDepth ||
       width < 0 ||
       height < 0 ||
       depth < 0 ||
       xoffset + width > texImages[0]->Width ||
       yoffset + height > texImages[0]->Height ||
       zoffset + depth > maxDepth) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glClearSubTexImage(invalid dimensions)");
      goto out;
   }

   if (numImages == 1) {
      if (check_clear_tex_image(ctx, "glClearTexSubImage",
                                texImages[0],
                                format, type, data, clearValue[0])) {
         ctx->Driver.ClearTexSubImage(ctx,
                                      texImages[0],
                                      xoffset, yoffset, zoffset,
                                      width, height, depth,
                                      data ? clearValue[0] : NULL);
      }
   } else {
      for (i = zoffset; i < zoffset + depth; i++) {
         if (!check_clear_tex_image(ctx, "glClearTexSubImage",
                                    texImages[i],
                                    format, type, data, clearValue[i]))
            goto out;
      }
      for (i = zoffset; i < zoffset + depth; i++) {
         ctx->Driver.ClearTexSubImage(ctx,
                                      texImages[i],
                                      xoffset, yoffset, 0,
                                      width, height, 1,
                                      data ? clearValue[i] : NULL);
      }
   }

 out:
   _mesa_unlock_texture(ctx, texObj);
}

void GLAPIENTRY
_mesa_ClearTexImage( GLuint texture, GLint level,
                     GLenum format, GLenum type, const void *data )
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_texture_object *texObj;
   struct gl_texture_image *texImages[MAX_FACES];
   GLubyte clearValue[MAX_FACES][MAX_PIXEL_BYTES];
   int i, numImages;

   texObj = get_tex_obj_for_clear(ctx, "glClearTexImage", texture);

   if (texObj == NULL)
      return;

   _mesa_lock_texture(ctx, texObj);

   numImages = get_tex_images_for_clear(ctx, "glClearTexImage",
                                        texObj, level, texImages);

   for (i = 0; i < numImages; i++) {
      if (!check_clear_tex_image(ctx, "glClearTexImage",
                                 texImages[i],
                                 format, type, data,
                                 clearValue[i]))
         goto out;
   }

   for (i = 0; i < numImages; i++) {
      ctx->Driver.ClearTexSubImage(ctx, texImages[i],
                                   -(GLint) texImages[i]->Border, /* xoffset */
                                   -(GLint) texImages[i]->Border, /* yoffset */
                                   -(GLint) texImages[i]->Border, /* zoffset */
                                   texImages[i]->Width,
                                   texImages[i]->Height,
                                   texImages[i]->Depth,
                                   data ? clearValue[i] : NULL);
   }

out:
   _mesa_unlock_texture(ctx, texObj);
}

d3896 1
a3896 1
 * \return GL_TRUE if error, GL_FALSE if no error
d3898 1
a3898 1
static GLboolean
d3938 1
a3938 1
      _mesa_error(ctx, GL_INVALID_ENUM, "glCompressedTexSubImage%uD(target)",
d3951 1
a3951 1
      _mesa_error(ctx, GL_INVALID_VALUE, "glCompressedTexSubImage%uD(level=%d)",
a3955 7
   /* Check for invalid pixel storage modes */
   if (!_mesa_compressed_pixel_storage_error_check(ctx, dims,
                                                &ctx->Unpack,
                                                "glCompressedTexSubImage")) {
      return GL_TRUE;
   }

d3958 1
a3958 1
      _mesa_error(ctx, GL_INVALID_VALUE, "glCompressedTexSubImage%uD(size=%d)",
a4358 6

   ctx->NewDriverState |= ctx->DriverFlags.NewTextureBuffer;

   if (bufObj) {
      bufObj->UsageHistory |= USAGE_TEXTURE_BUFFER;
   }
d4637 1
@


1.1.1.10
log
@Import Mesa 10.2.9
@
text
@d44 1
d55 1
a259 10
   if (ctx->Extensions.ATI_envmap_bumpmap) {
      switch (internalFormat) {
         case GL_DUDV_ATI:
         case GL_DU8DV8_ATI:
            return GL_DUDV_ATI;
         default:
            ; /* fallthrough */
      }
   }

d524 14
d1545 1
a1545 1
      if (height < 1 || height > ctx->Const.MaxArrayTextureLayers)
d2030 37
a2099 3
   GLboolean colorFormat;
   GLboolean is_format_depth_or_depthstencil;
   GLboolean is_internalFormat_depth_or_depthstencil;
a2101 6
   /* Even though there are no color-index textures, we still have to support
    * uploading color-index data and remapping it to RGB via the
    * GL_PIXEL_MAP_I_TO_[RGBA] tables.
    */
   const GLboolean indexFormat = (format == GL_COLOR_INDEX);

d2184 1
a2184 13
   is_internalFormat_depth_or_depthstencil =
      _mesa_is_depth_format(internalFormat) ||
      _mesa_is_depthstencil_format(internalFormat);

   is_format_depth_or_depthstencil =
      _mesa_is_depth_format(format) ||
      _mesa_is_depthstencil_format(format);

   colorFormat = _mesa_is_color_format(format);
   if ((_mesa_is_color_format(internalFormat) && !colorFormat && !indexFormat) ||
       (is_internalFormat_depth_or_depthstencil != is_format_depth_or_depthstencil) ||
       (_mesa_is_ycbcr_format(internalFormat) != _mesa_is_ycbcr_format(format)) ||
       (_mesa_is_dudv_format(internalFormat) != _mesa_is_dudv_format(format))) {
d2376 7
d2452 1
a2452 1
      _mesa_error(ctx, GL_INVALID_ENUM, "glTexSubImage%uD(level=%d)",
d3090 1
a3090 1
   f = ctx->Driver.ChooseTextureFormat(ctx, texObj->Target, internalFormat,
d3915 260
d4185 1
a4185 1
 * \return error code or GL_NO_ERROR.
d4187 1
a4187 1
static GLenum
d4227 1
a4227 1
      _mesa_error(ctx, GL_INVALID_ENUM, "glCompressedTexImage%uD(target)",
d4240 1
a4240 1
      _mesa_error(ctx, GL_INVALID_VALUE, "glCompressedTexImage%uD(level=%d)",
d4245 7
d4254 1
a4254 1
      _mesa_error(ctx, GL_INVALID_VALUE, "glCompressedTexImage%uD(size=%d)",
d4655 6
a4938 1

@


