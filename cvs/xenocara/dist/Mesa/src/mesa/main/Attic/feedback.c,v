head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.4
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.5.0.2
	OPENBSD_5_5_BASE:1.5
	v9_2_5:1.1.1.3
	v9_2_3:1.1.1.3
	v9_2_2:1.1.1.3
	v9_2_1:1.1.1.3
	v9_2_0:1.1.1.3
	OPENBSD_5_4:1.4.0.4
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.2
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.3.0.4
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.2
	v7_10_3:1.1.1.2
	OPENBSD_5_0:1.2.0.6
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.1.1.0.12
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.10
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v7_0_1:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v6_5_2:1.1.1.1
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.52;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.21;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2013.09.05.14.06.21;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2012.08.17.13.58.19;	author mpi;	state Exp;
branches;
next	1.3;

1.3
date	2011.10.23.13.37.42;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.05.22.20.06.30;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.50.01;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.50.01;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2011.10.23.13.29.46;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2013.09.05.13.16.34;	author jsg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2015.01.25.14.12.37;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.49.43;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2008  Brian Paul   All Rights Reserved.
 * Copyright (C) 2009  VMware, Inc.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

/**
 * \file feedback.c
 * Selection and feedback modes functions.
 */


#include "glheader.h"
#include "colormac.h"
#include "context.h"
#include "enums.h"
#include "feedback.h"
#include "macros.h"
#include "mtypes.h"
#include "main/dispatch.h"


#define FB_3D		0x01
#define FB_4D		0x02
#define FB_COLOR	0x04
#define FB_TEXTURE	0X08



void GLAPIENTRY
_mesa_FeedbackBuffer( GLsizei size, GLenum type, GLfloat *buffer )
{
   GET_CURRENT_CONTEXT(ctx);

   if (ctx->RenderMode==GL_FEEDBACK) {
      _mesa_error( ctx, GL_INVALID_OPERATION, "glFeedbackBuffer" );
      return;
   }
   if (size<0) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glFeedbackBuffer(size<0)" );
      return;
   }
   if (!buffer && size > 0) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glFeedbackBuffer(buffer==NULL)" );
      ctx->Feedback.BufferSize = 0;
      return;
   }

   switch (type) {
      case GL_2D:
	 ctx->Feedback._Mask = 0;
	 break;
      case GL_3D:
	 ctx->Feedback._Mask = FB_3D;
	 break;
      case GL_3D_COLOR:
	 ctx->Feedback._Mask = (FB_3D | FB_COLOR);
	 break;
      case GL_3D_COLOR_TEXTURE:
	 ctx->Feedback._Mask = (FB_3D | FB_COLOR | FB_TEXTURE);
	 break;
      case GL_4D_COLOR_TEXTURE:
	 ctx->Feedback._Mask = (FB_3D | FB_4D | FB_COLOR | FB_TEXTURE);
	 break;
      default:
         _mesa_error( ctx, GL_INVALID_ENUM, "glFeedbackBuffer" );
	 return;
   }

   FLUSH_VERTICES(ctx, _NEW_RENDERMODE); /* Always flush */
   ctx->Feedback.Type = type;
   ctx->Feedback.BufferSize = size;
   ctx->Feedback.Buffer = buffer;
   ctx->Feedback.Count = 0;	              /* Becaues of this. */
}


void GLAPIENTRY
_mesa_PassThrough( GLfloat token )
{
   GET_CURRENT_CONTEXT(ctx);

   if (ctx->RenderMode==GL_FEEDBACK) {
      FLUSH_VERTICES(ctx, 0);
      _mesa_feedback_token( ctx, (GLfloat) (GLint) GL_PASS_THROUGH_TOKEN );
      _mesa_feedback_token( ctx, token );
   }
}


/**
 * Put a vertex into the feedback buffer.
 */
void
_mesa_feedback_vertex(struct gl_context *ctx,
                      const GLfloat win[4],
                      const GLfloat color[4],
                      const GLfloat texcoord[4])
{
   _mesa_feedback_token( ctx, win[0] );
   _mesa_feedback_token( ctx, win[1] );
   if (ctx->Feedback._Mask & FB_3D) {
      _mesa_feedback_token( ctx, win[2] );
   }
   if (ctx->Feedback._Mask & FB_4D) {
      _mesa_feedback_token( ctx, win[3] );
   }
   if (ctx->Feedback._Mask & FB_COLOR) {
      _mesa_feedback_token( ctx, color[0] );
      _mesa_feedback_token( ctx, color[1] );
      _mesa_feedback_token( ctx, color[2] );
      _mesa_feedback_token( ctx, color[3] );
   }
   if (ctx->Feedback._Mask & FB_TEXTURE) {
      _mesa_feedback_token( ctx, texcoord[0] );
      _mesa_feedback_token( ctx, texcoord[1] );
      _mesa_feedback_token( ctx, texcoord[2] );
      _mesa_feedback_token( ctx, texcoord[3] );
   }
}


/**********************************************************************/
/** \name Selection */
/*@@{*/

/**
 * Establish a buffer for selection mode values.
 * 
 * \param size buffer size.
 * \param buffer buffer.
 *
 * \sa glSelectBuffer().
 * 
 * \note this function can't be put in a display list.
 * 
 * Verifies we're not in selection mode, flushes the vertices and initialize
 * the fields in __struct gl_contextRec::Select with the given buffer.
 */
void GLAPIENTRY
_mesa_SelectBuffer( GLsizei size, GLuint *buffer )
{
   GET_CURRENT_CONTEXT(ctx);

   if (size < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glSelectBuffer(size)");
      return;
   }

   if (ctx->RenderMode==GL_SELECT) {
      _mesa_error( ctx, GL_INVALID_OPERATION, "glSelectBuffer" );
      return;			/* KW: added return */
   }

   FLUSH_VERTICES(ctx, _NEW_RENDERMODE); 
   ctx->Select.Buffer = buffer;
   ctx->Select.BufferSize = size;
   ctx->Select.BufferCount = 0;
   ctx->Select.HitFlag = GL_FALSE;
   ctx->Select.HitMinZ = 1.0;
   ctx->Select.HitMaxZ = 0.0;
}


/**
 * Write a value of a record into the selection buffer.
 * 
 * \param ctx GL context.
 * \param value value.
 *
 * Verifies there is free space in the buffer to write the value and
 * increments the pointer.
 */
static inline void
write_record(struct gl_context *ctx, GLuint value)
{
   if (ctx->Select.BufferCount < ctx->Select.BufferSize) {
      ctx->Select.Buffer[ctx->Select.BufferCount] = value;
   }
   ctx->Select.BufferCount++;
}


/**
 * Update the hit flag and the maximum and minimum depth values.
 *
 * \param ctx GL context.
 * \param z depth.
 *
 * Sets gl_selection::HitFlag and updates gl_selection::HitMinZ and
 * gl_selection::HitMaxZ.
 */
void
_mesa_update_hitflag(struct gl_context *ctx, GLfloat z)
{
   ctx->Select.HitFlag = GL_TRUE;
   if (z < ctx->Select.HitMinZ) {
      ctx->Select.HitMinZ = z;
   }
   if (z > ctx->Select.HitMaxZ) {
      ctx->Select.HitMaxZ = z;
   }
}


/**
 * Write the hit record.
 *
 * \param ctx GL context.
 *
 * Write the hit record, i.e., the number of names in the stack, the minimum and
 * maximum depth values and the number of names in the name stack at the time
 * of the event. Resets the hit flag. 
 *
 * \sa gl_selection.
 */
static void
write_hit_record(struct gl_context *ctx)
{
   GLuint i;
   GLuint zmin, zmax, zscale = (~0u);

   /* HitMinZ and HitMaxZ are in [0,1].  Multiply these values by */
   /* 2^32-1 and round to nearest unsigned integer. */

   assert( ctx != NULL ); /* this line magically fixes a SunOS 5.x/gcc bug */
   zmin = (GLuint) ((GLfloat) zscale * ctx->Select.HitMinZ);
   zmax = (GLuint) ((GLfloat) zscale * ctx->Select.HitMaxZ);

   write_record( ctx, ctx->Select.NameStackDepth );
   write_record( ctx, zmin );
   write_record( ctx, zmax );
   for (i = 0; i < ctx->Select.NameStackDepth; i++) {
      write_record( ctx, ctx->Select.NameStack[i] );
   }

   ctx->Select.Hits++;
   ctx->Select.HitFlag = GL_FALSE;
   ctx->Select.HitMinZ = 1.0;
   ctx->Select.HitMaxZ = -1.0;
}


/**
 * Initialize the name stack.
 *
 * Verifies we are in select mode and resets the name stack depth and resets
 * the hit record data in gl_selection. Marks new render mode in
 * __struct gl_contextRec::NewState.
 */
void GLAPIENTRY
_mesa_InitNames( void )
{
   GET_CURRENT_CONTEXT(ctx);
   FLUSH_VERTICES(ctx, 0);

   /* Record the hit before the HitFlag is wiped out again. */
   if (ctx->RenderMode == GL_SELECT) {
      if (ctx->Select.HitFlag) {
         write_hit_record( ctx );
      }
   }
   ctx->Select.NameStackDepth = 0;
   ctx->Select.HitFlag = GL_FALSE;
   ctx->Select.HitMinZ = 1.0;
   ctx->Select.HitMaxZ = 0.0;
   ctx->NewState |= _NEW_RENDERMODE;
}


/**
 * Load the top-most name of the name stack.
 *
 * \param name name.
 *
 * Verifies we are in selection mode and that the name stack is not empty.
 * Flushes vertices. If there is a hit flag writes it (via write_hit_record()),
 * and replace the top-most name in the stack.
 *
 * sa __struct gl_contextRec::Select.
 */
void GLAPIENTRY
_mesa_LoadName( GLuint name )
{
   GET_CURRENT_CONTEXT(ctx);

   if (ctx->RenderMode != GL_SELECT) {
      return;
   }
   if (ctx->Select.NameStackDepth == 0) {
      _mesa_error( ctx, GL_INVALID_OPERATION, "glLoadName" );
      return;
   }

   FLUSH_VERTICES(ctx, _NEW_RENDERMODE);

   if (ctx->Select.HitFlag) {
      write_hit_record( ctx );
   }
   if (ctx->Select.NameStackDepth < MAX_NAME_STACK_DEPTH) {
      ctx->Select.NameStack[ctx->Select.NameStackDepth-1] = name;
   }
   else {
      ctx->Select.NameStack[MAX_NAME_STACK_DEPTH-1] = name;
   }
}


/**
 * Push a name into the name stack.
 *
 * \param name name.
 *
 * Verifies we are in selection mode and that the name stack is not full.
 * Flushes vertices. If there is a hit flag writes it (via write_hit_record()),
 * and adds the name to the top of the name stack.
 *
 * sa __struct gl_contextRec::Select.
 */
void GLAPIENTRY
_mesa_PushName( GLuint name )
{
   GET_CURRENT_CONTEXT(ctx);

   if (ctx->RenderMode != GL_SELECT) {
      return;
   }

   FLUSH_VERTICES(ctx, _NEW_RENDERMODE);
   if (ctx->Select.HitFlag) {
      write_hit_record( ctx );
   }
   if (ctx->Select.NameStackDepth >= MAX_NAME_STACK_DEPTH) {
      _mesa_error( ctx, GL_STACK_OVERFLOW, "glPushName" );
   }
   else
      ctx->Select.NameStack[ctx->Select.NameStackDepth++] = name;
}


/**
 * Pop a name into the name stack.
 *
 * Verifies we are in selection mode and that the name stack is not empty.
 * Flushes vertices. If there is a hit flag writes it (via write_hit_record()),
 * and removes top-most name in the name stack.
 *
 * sa __struct gl_contextRec::Select.
 */
void GLAPIENTRY
_mesa_PopName( void )
{
   GET_CURRENT_CONTEXT(ctx);

   if (ctx->RenderMode != GL_SELECT) {
      return;
   }

   FLUSH_VERTICES(ctx, _NEW_RENDERMODE);
   if (ctx->Select.HitFlag) {
      write_hit_record( ctx );
   }
   if (ctx->Select.NameStackDepth == 0) {
      _mesa_error( ctx, GL_STACK_UNDERFLOW, "glPopName" );
   }
   else
      ctx->Select.NameStackDepth--;
}

/*@@}*/


/**********************************************************************/
/** \name Render Mode */
/*@@{*/

/**
 * Set rasterization mode.
 *
 * \param mode rasterization mode.
 *
 * \note this function can't be put in a display list.
 *
 * \sa glRenderMode().
 * 
 * Flushes the vertices and do the necessary cleanup according to the previous
 * rasterization mode, such as writing the hit record or resent the select
 * buffer index when exiting the select mode. Updates
 * __struct gl_contextRec::RenderMode and notifies the driver via the
 * dd_function_table::RenderMode callback.
 */
GLint GLAPIENTRY
_mesa_RenderMode( GLenum mode )
{
   GET_CURRENT_CONTEXT(ctx);
   GLint result;
   ASSERT_OUTSIDE_BEGIN_END_WITH_RETVAL(ctx, 0);

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glRenderMode %s\n", _mesa_lookup_enum_by_nr(mode));

   FLUSH_VERTICES(ctx, _NEW_RENDERMODE);

   switch (ctx->RenderMode) {
      case GL_RENDER:
	 result = 0;
	 break;
      case GL_SELECT:
	 if (ctx->Select.HitFlag) {
	    write_hit_record( ctx );
	 }
	 if (ctx->Select.BufferCount > ctx->Select.BufferSize) {
	    /* overflow */
#ifdef DEBUG
            _mesa_warning(ctx, "Feedback buffer overflow");
#endif
	    result = -1;
	 }
	 else {
	    result = ctx->Select.Hits;
	 }
	 ctx->Select.BufferCount = 0;
	 ctx->Select.Hits = 0;
	 ctx->Select.NameStackDepth = 0;
	 break;
      case GL_FEEDBACK:
	 if (ctx->Feedback.Count > ctx->Feedback.BufferSize) {
	    /* overflow */
	    result = -1;
	 }
	 else {
	    result = ctx->Feedback.Count;
	 }
	 ctx->Feedback.Count = 0;
	 break;
      default:
	 _mesa_error( ctx, GL_INVALID_ENUM, "glRenderMode" );
	 return 0;
   }

   switch (mode) {
      case GL_RENDER:
         break;
      case GL_SELECT:
	 if (ctx->Select.BufferSize==0) {
	    /* haven't called glSelectBuffer yet */
	    _mesa_error( ctx, GL_INVALID_OPERATION, "glRenderMode" );
	 }
	 break;
      case GL_FEEDBACK:
	 if (ctx->Feedback.BufferSize==0) {
	    /* haven't called glFeedbackBuffer yet */
	    _mesa_error( ctx, GL_INVALID_OPERATION, "glRenderMode" );
	 }
	 break;
      default:
	 _mesa_error( ctx, GL_INVALID_ENUM, "glRenderMode" );
	 return 0;
   }

   ctx->RenderMode = mode;
   if (ctx->Driver.RenderMode)
      ctx->Driver.RenderMode( ctx, mode );

   return result;
}

/*@@}*/


/**********************************************************************/
/** \name Initialization */
/*@@{*/

/**
 * Initialize context feedback data.
 */
void _mesa_init_feedback( struct gl_context * ctx )
{
   /* Feedback */
   ctx->Feedback.Type = GL_2D;   /* TODO: verify */
   ctx->Feedback.Buffer = NULL;
   ctx->Feedback.BufferSize = 0;
   ctx->Feedback.Count = 0;

   /* Selection/picking */
   ctx->Select.Buffer = NULL;
   ctx->Select.BufferSize = 0;
   ctx->Select.BufferCount = 0;
   ctx->Select.Hits = 0;
   ctx->Select.NameStackDepth = 0;

   /* Miscellaneous */
   ctx->RenderMode = GL_RENDER;
}

/*@@}*/
@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d33 1
@


1.5
log
@Merge Mesa 9.2.0
@
text
@a32 1
#include "colormac.h"
@


1.4
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a2 1
 * Version:  7.5
d20 4
a23 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
a37 1
#include "mfeatures.h"
a41 3
#if FEATURE_feedback


d49 1
a49 1
static void GLAPIENTRY
a52 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d97 1
a97 1
static void GLAPIENTRY
a100 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d159 1
a159 1
static void GLAPIENTRY
a162 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d193 1
a193 1
static INLINE void
d270 1
a270 1
static void GLAPIENTRY
d274 1
a274 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d301 1
a301 1
static void GLAPIENTRY
a304 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d339 1
a339 1
static void GLAPIENTRY
a342 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d369 1
a369 1
static void GLAPIENTRY
a372 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d411 1
a411 1
static GLint GLAPIENTRY
a444 1
#if _HAVE_FULL_GL
a454 1
#endif
a468 1
#if _HAVE_FULL_GL
a474 1
#endif
a487 17


void
_mesa_init_feedback_dispatch(struct _glapi_table *disp)
{
   SET_InitNames(disp, _mesa_InitNames);
   SET_FeedbackBuffer(disp, _mesa_FeedbackBuffer);
   SET_LoadName(disp, _mesa_LoadName);
   SET_PassThrough(disp, _mesa_PassThrough);
   SET_PopName(disp, _mesa_PopName);
   SET_PushName(disp, _mesa_PushName);
   SET_SelectBuffer(disp, _mesa_SelectBuffer);
   SET_RenderMode(disp, _mesa_RenderMode);
}


#endif /* FEATURE_feedback */
@


1.3
log
@Merge Mesa 7.10.3
@
text
@d38 1
d67 1
a67 1
   if (!buffer) {
d170 5
@


1.2
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d119 1
a119 1
_mesa_feedback_vertex(GLcontext *ctx,
d162 1
a162 1
 * the fields in __GLcontextRec::Select with the given buffer.
d195 1
a195 1
write_record(GLcontext *ctx, GLuint value)
d214 1
a214 1
_mesa_update_hitflag(GLcontext *ctx, GLfloat z)
d238 1
a238 1
write_hit_record(GLcontext *ctx)
d269 1
a269 1
 * __GLcontextRec::NewState.
d300 1
a300 1
 * sa __GLcontextRec::Select.
d339 1
a339 1
 * sa __GLcontextRec::Select.
d370 1
a370 1
 * sa __GLcontextRec::Select.
d412 1
a412 1
 * __GLcontextRec::RenderMode and notifies the driver via the
d522 1
a522 1
void _mesa_init_feedback( GLcontext * ctx )
@


1.1
log
@Initial revision
@
text
@a0 5
/**
 * \file feedback.c
 * Selection and feedback modes functions.
 */

d3 1
a3 1
 * Version:  5.1
d5 2
a6 1
 * Copyright (C) 1999-2003  Brian Paul   All Rights Reserved.
d26 5
d39 1
d42 1
a42 1
#if _HAVE_FULL_GL
d47 2
a48 3
#define FB_INDEX	0x04
#define FB_COLOR	0x08
#define FB_TEXTURE	0X10
d52 1
a52 1
void GLAPIENTRY
d80 1
a80 2
	 ctx->Feedback._Mask = (FB_3D |
				(ctx->Visual.rgbMode ? FB_COLOR : FB_INDEX));
d83 1
a83 3
	 ctx->Feedback._Mask = (FB_3D |
				(ctx->Visual.rgbMode ? FB_COLOR : FB_INDEX) |
				FB_TEXTURE);
d86 1
a86 3
	 ctx->Feedback._Mask = (FB_3D | FB_4D |
				(ctx->Visual.rgbMode ? FB_COLOR : FB_INDEX) |
				FB_TEXTURE);
d101 1
a101 1
void GLAPIENTRY
d109 2
a110 2
      FEEDBACK_TOKEN( ctx, (GLfloat) (GLint) GL_PASS_THROUGH_TOKEN );
      FEEDBACK_TOKEN( ctx, token );
d115 1
a115 2

/*
d118 8
a125 20
void _mesa_feedback_vertex( GLcontext *ctx,
                            const GLfloat win[4],
                            const GLfloat color[4],
                            GLfloat index,
                            const GLfloat texcoord[4] )
{
#if 0
   {
      /* snap window x, y to fractional pixel position */
      const GLint snapMask = ~((FIXED_ONE / (1 << SUB_PIXEL_BITS)) - 1);
      GLfixed x, y;
      x = FloatToFixed(win[0]) & snapMask;
      y = FloatToFixed(win[1]) & snapMask;
      FEEDBACK_TOKEN(ctx, FixedToFloat(x));
      FEEDBACK_TOKEN(ctx, FixedToFloat(y) );
   }
#else
   FEEDBACK_TOKEN( ctx, win[0] );
   FEEDBACK_TOKEN( ctx, win[1] );
#endif
d127 1
a127 1
      FEEDBACK_TOKEN( ctx, win[2] );
d130 1
a130 4
      FEEDBACK_TOKEN( ctx, win[3] );
   }
   if (ctx->Feedback._Mask & FB_INDEX) {
      FEEDBACK_TOKEN( ctx, (GLfloat) index );
d133 4
a136 4
      FEEDBACK_TOKEN( ctx, color[0] );
      FEEDBACK_TOKEN( ctx, color[1] );
      FEEDBACK_TOKEN( ctx, color[2] );
      FEEDBACK_TOKEN( ctx, color[3] );
d139 4
a142 4
      FEEDBACK_TOKEN( ctx, texcoord[0] );
      FEEDBACK_TOKEN( ctx, texcoord[1] );
      FEEDBACK_TOKEN( ctx, texcoord[2] );
      FEEDBACK_TOKEN( ctx, texcoord[3] );
a145 2
#endif

d164 1
a164 1
void GLAPIENTRY
d188 2
a189 2
 * \param CTX GL context.
 * \param V value.
d194 8
a201 5
#define WRITE_RECORD( CTX, V )					\
	if (CTX->Select.BufferCount < CTX->Select.BufferSize) {	\
	   CTX->Select.Buffer[CTX->Select.BufferCount] = (V);	\
	}							\
	CTX->Select.BufferCount++;
d213 2
a214 1
void _mesa_update_hitflag( GLcontext *ctx, GLfloat z )
d237 2
a238 1
static void write_hit_record( GLcontext *ctx )
d250 3
a252 3
   WRITE_RECORD( ctx, ctx->Select.NameStackDepth );
   WRITE_RECORD( ctx, zmin );
   WRITE_RECORD( ctx, zmax );
d254 1
a254 1
      WRITE_RECORD( ctx, ctx->Select.NameStack[i] );
d271 1
a271 1
void GLAPIENTRY
d302 1
a302 1
void GLAPIENTRY
d341 1
a341 1
void GLAPIENTRY
d372 1
a372 1
void GLAPIENTRY
d415 1
a415 1
GLint GLAPIENTRY
d496 17
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@Import Mesa 7.10.3
@
text
@d1 5
d8 1
a8 1
 * Version:  7.5
d10 1
a10 2
 * Copyright (C) 1999-2008  Brian Paul   All Rights Reserved.
 * Copyright (C) 2009  VMware, Inc.  All Rights Reserved.
a29 5
/**
 * \file feedback.c
 * Selection and feedback modes functions.
 */

a37 1
#include "main/dispatch.h"
d40 1
a40 1
#if FEATURE_feedback
d45 3
a47 2
#define FB_COLOR	0x04
#define FB_TEXTURE	0X08
d51 1
a51 1
static void GLAPIENTRY
d79 2
a80 1
	 ctx->Feedback._Mask = (FB_3D | FB_COLOR);
d83 3
a85 1
	 ctx->Feedback._Mask = (FB_3D | FB_COLOR | FB_TEXTURE);
d88 3
a90 1
	 ctx->Feedback._Mask = (FB_3D | FB_4D | FB_COLOR | FB_TEXTURE);
d105 1
a105 1
static void GLAPIENTRY
d113 2
a114 2
      _mesa_feedback_token( ctx, (GLfloat) (GLint) GL_PASS_THROUGH_TOKEN );
      _mesa_feedback_token( ctx, token );
d119 2
a120 1
/**
d123 20
a142 8
void
_mesa_feedback_vertex(struct gl_context *ctx,
                      const GLfloat win[4],
                      const GLfloat color[4],
                      const GLfloat texcoord[4])
{
   _mesa_feedback_token( ctx, win[0] );
   _mesa_feedback_token( ctx, win[1] );
d144 1
a144 1
      _mesa_feedback_token( ctx, win[2] );
d147 4
a150 1
      _mesa_feedback_token( ctx, win[3] );
d153 4
a156 4
      _mesa_feedback_token( ctx, color[0] );
      _mesa_feedback_token( ctx, color[1] );
      _mesa_feedback_token( ctx, color[2] );
      _mesa_feedback_token( ctx, color[3] );
d159 4
a162 4
      _mesa_feedback_token( ctx, texcoord[0] );
      _mesa_feedback_token( ctx, texcoord[1] );
      _mesa_feedback_token( ctx, texcoord[2] );
      _mesa_feedback_token( ctx, texcoord[3] );
d166 2
d184 1
a184 1
 * the fields in __struct gl_contextRec::Select with the given buffer.
d186 1
a186 1
static void GLAPIENTRY
d210 2
a211 2
 * \param ctx GL context.
 * \param value value.
d216 5
a220 8
static INLINE void
write_record(struct gl_context *ctx, GLuint value)
{
   if (ctx->Select.BufferCount < ctx->Select.BufferSize) {
      ctx->Select.Buffer[ctx->Select.BufferCount] = value;
   }
   ctx->Select.BufferCount++;
}
d232 1
a232 2
void
_mesa_update_hitflag(struct gl_context *ctx, GLfloat z)
d255 1
a255 2
static void
write_hit_record(struct gl_context *ctx)
d267 3
a269 3
   write_record( ctx, ctx->Select.NameStackDepth );
   write_record( ctx, zmin );
   write_record( ctx, zmax );
d271 1
a271 1
      write_record( ctx, ctx->Select.NameStack[i] );
d286 1
a286 1
 * __struct gl_contextRec::NewState.
d288 1
a288 1
static void GLAPIENTRY
d317 1
a317 1
 * sa __struct gl_contextRec::Select.
d319 1
a319 1
static void GLAPIENTRY
d356 1
a356 1
 * sa __struct gl_contextRec::Select.
d358 1
a358 1
static void GLAPIENTRY
d387 1
a387 1
 * sa __struct gl_contextRec::Select.
d389 1
a389 1
static void GLAPIENTRY
d429 1
a429 1
 * __struct gl_contextRec::RenderMode and notifies the driver via the
d432 1
a432 1
static GLint GLAPIENTRY
a514 17
void
_mesa_init_feedback_dispatch(struct _glapi_table *disp)
{
   SET_InitNames(disp, _mesa_InitNames);
   SET_FeedbackBuffer(disp, _mesa_FeedbackBuffer);
   SET_LoadName(disp, _mesa_LoadName);
   SET_PassThrough(disp, _mesa_PassThrough);
   SET_PopName(disp, _mesa_PopName);
   SET_PushName(disp, _mesa_PushName);
   SET_SelectBuffer(disp, _mesa_SelectBuffer);
   SET_RenderMode(disp, _mesa_RenderMode);
}


#endif /* FEATURE_feedback */


d522 1
a522 1
void _mesa_init_feedback( struct gl_context * ctx )
@


1.1.1.3
log
@Import Mesa 9.2.0
@
text
@d3 1
d21 3
a23 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
d42 3
d52 1
a52 1
void GLAPIENTRY
d56 1
d66 1
a66 1
   if (!buffer && size > 0) {
d101 1
a101 1
void GLAPIENTRY
d105 1
d164 1
a164 1
void GLAPIENTRY
d168 1
a168 5

   if (size < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glSelectBuffer(size)");
      return;
   }
d194 1
a194 1
static inline void
d271 1
a271 1
void GLAPIENTRY
d275 1
a275 1
   FLUSH_VERTICES(ctx, 0);
d302 1
a302 1
void GLAPIENTRY
d306 1
d341 1
a341 1
void GLAPIENTRY
d345 1
d372 1
a372 1
void GLAPIENTRY
d376 1
d415 1
a415 1
GLint GLAPIENTRY
d449 1
d460 1
d475 1
d482 1
d496 17
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d33 1
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@a32 1
#include "colormac.h"
@


