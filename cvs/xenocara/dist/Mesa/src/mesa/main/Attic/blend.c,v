head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.6
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.4
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.5
	v10_2_7:1.1.1.5
	OPENBSD_5_6:1.7.0.2
	OPENBSD_5_6_BASE:1.7
	v10_2_3:1.1.1.5
	OPENBSD_5_5:1.6.0.2
	OPENBSD_5_5_BASE:1.6
	v9_2_5:1.1.1.4
	v9_2_3:1.1.1.4
	v9_2_2:1.1.1.4
	v9_2_1:1.1.1.4
	v9_2_0:1.1.1.4
	OPENBSD_5_4:1.5.0.4
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.2
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.4.0.4
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	v7_10_3:1.1.1.3
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.1.2.0.8
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.6
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.4
	v7_0_1:1.1.1.2
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.52;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2014.07.09.21.09.00;	author jsg;	state Exp;
branches;
next	1.6;
commitid	WPD6rgPryPkvXOr9;

1.6
date	2013.09.05.14.06.16;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2012.08.17.13.58.17;	author mpi;	state Exp;
branches;
next	1.4;

1.4
date	2011.10.23.13.37.42;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.05.22.20.06.30;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.05.17.20.26.41;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.49.44;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.49.44;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.56.32;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.10.23.13.29.45;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.09.05.13.16.24;	author jsg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2014.07.09.20.34.58;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**
 * \file blend.c
 * Blending operations.
 */

/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */



#include "glheader.h"
#include "blend.h"
#include "context.h"
#include "enums.h"
#include "macros.h"
#include "mtypes.h"



/**
 * Check if given blend source factor is legal.
 * \return GL_TRUE if legal, GL_FALSE otherwise.
 */
static GLboolean
legal_src_factor(const struct gl_context *ctx, GLenum factor)
{
   switch (factor) {
   case GL_SRC_COLOR:
   case GL_ONE_MINUS_SRC_COLOR:
   case GL_ZERO:
   case GL_ONE:
   case GL_DST_COLOR:
   case GL_ONE_MINUS_DST_COLOR:
   case GL_SRC_ALPHA:
   case GL_ONE_MINUS_SRC_ALPHA:
   case GL_DST_ALPHA:
   case GL_ONE_MINUS_DST_ALPHA:
   case GL_SRC_ALPHA_SATURATE:
      return GL_TRUE;
   case GL_CONSTANT_COLOR:
   case GL_ONE_MINUS_CONSTANT_COLOR:
   case GL_CONSTANT_ALPHA:
   case GL_ONE_MINUS_CONSTANT_ALPHA:
      return _mesa_is_desktop_gl(ctx) || ctx->API == API_OPENGLES2;
   case GL_SRC1_COLOR:
   case GL_SRC1_ALPHA:
   case GL_ONE_MINUS_SRC1_COLOR:
   case GL_ONE_MINUS_SRC1_ALPHA:
      return _mesa_is_desktop_gl(ctx)
         && ctx->Extensions.ARB_blend_func_extended;
   default:
      return GL_FALSE;
   }
}


/**
 * Check if given blend destination factor is legal.
 * \return GL_TRUE if legal, GL_FALSE otherwise.
 */
static GLboolean
legal_dst_factor(const struct gl_context *ctx, GLenum factor)
{
   switch (factor) {
   case GL_DST_COLOR:
   case GL_ONE_MINUS_DST_COLOR:
   case GL_ZERO:
   case GL_ONE:
   case GL_SRC_COLOR:
   case GL_ONE_MINUS_SRC_COLOR:
   case GL_SRC_ALPHA:
   case GL_ONE_MINUS_SRC_ALPHA:
   case GL_DST_ALPHA:
   case GL_ONE_MINUS_DST_ALPHA:
      return GL_TRUE;
   case GL_CONSTANT_COLOR:
   case GL_ONE_MINUS_CONSTANT_COLOR:
   case GL_CONSTANT_ALPHA:
   case GL_ONE_MINUS_CONSTANT_ALPHA:
      return _mesa_is_desktop_gl(ctx) || ctx->API == API_OPENGLES2;
   case GL_SRC_ALPHA_SATURATE:
      return (_mesa_is_desktop_gl(ctx)
              && ctx->Extensions.ARB_blend_func_extended)
         || _mesa_is_gles3(ctx);
   case GL_SRC1_COLOR:
   case GL_SRC1_ALPHA:
   case GL_ONE_MINUS_SRC1_COLOR:
   case GL_ONE_MINUS_SRC1_ALPHA:
      return _mesa_is_desktop_gl(ctx)
         && ctx->Extensions.ARB_blend_func_extended;
   default:
      return GL_FALSE;
   }
}


/**
 * Check if src/dest RGB/A blend factors are legal.  If not generate
 * a GL error.
 * \return GL_TRUE if factors are legal, GL_FALSE otherwise.
 */
static GLboolean
validate_blend_factors(struct gl_context *ctx, const char *func,
                       GLenum sfactorRGB, GLenum dfactorRGB,
                       GLenum sfactorA, GLenum dfactorA)
{
   if (!legal_src_factor(ctx, sfactorRGB)) {
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "%s(sfactorRGB = %s)", func,
                  _mesa_lookup_enum_by_nr(sfactorRGB));
      return GL_FALSE;
   }

   if (!legal_dst_factor(ctx, dfactorRGB)) {
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "%s(dfactorRGB = %s)", func,
                  _mesa_lookup_enum_by_nr(dfactorRGB));
      return GL_FALSE;
   }

   if (sfactorA != sfactorRGB && !legal_src_factor(ctx, sfactorA)) {
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "%s(sfactorA = %s)", func,
                  _mesa_lookup_enum_by_nr(sfactorA));
      return GL_FALSE;
   }

   if (dfactorA != dfactorRGB && !legal_dst_factor(ctx, dfactorA)) {
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "%s(dfactorA = %s)", func,
                  _mesa_lookup_enum_by_nr(dfactorA));
      return GL_FALSE;
   }

   return GL_TRUE;
}


/**
 * Specify the blending operation.
 *
 * \param sfactor source factor operator.
 * \param dfactor destination factor operator.
 *
 * \sa glBlendFunc, glBlendFuncSeparateEXT
 */
void GLAPIENTRY
_mesa_BlendFunc( GLenum sfactor, GLenum dfactor )
{
   _mesa_BlendFuncSeparate(sfactor, dfactor, sfactor, dfactor);
}

static GLboolean
blend_factor_is_dual_src(GLenum factor)
{
   return (factor == GL_SRC1_COLOR ||
	   factor == GL_SRC1_ALPHA ||
	   factor == GL_ONE_MINUS_SRC1_COLOR ||
	   factor == GL_ONE_MINUS_SRC1_ALPHA);
}

static void
update_uses_dual_src(struct gl_context *ctx, int buf)
{
   ctx->Color.Blend[buf]._UsesDualSrc =
      (blend_factor_is_dual_src(ctx->Color.Blend[buf].SrcRGB) ||
       blend_factor_is_dual_src(ctx->Color.Blend[buf].DstRGB) ||
       blend_factor_is_dual_src(ctx->Color.Blend[buf].SrcA) ||
       blend_factor_is_dual_src(ctx->Color.Blend[buf].DstA));
}

/**
 * Set the separate blend source/dest factors for all draw buffers.
 *
 * \param sfactorRGB RGB source factor operator.
 * \param dfactorRGB RGB destination factor operator.
 * \param sfactorA alpha source factor operator.
 * \param dfactorA alpha destination factor operator.
 */
void GLAPIENTRY
_mesa_BlendFuncSeparate( GLenum sfactorRGB, GLenum dfactorRGB,
                            GLenum sfactorA, GLenum dfactorA )
{
   GLuint buf, numBuffers;
   GLboolean changed;
   GET_CURRENT_CONTEXT(ctx);

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glBlendFuncSeparate %s %s %s %s\n",
                  _mesa_lookup_enum_by_nr(sfactorRGB),
                  _mesa_lookup_enum_by_nr(dfactorRGB),
                  _mesa_lookup_enum_by_nr(sfactorA),
                  _mesa_lookup_enum_by_nr(dfactorA));

   if (!validate_blend_factors(ctx, "glBlendFuncSeparate",
                               sfactorRGB, dfactorRGB,
                               sfactorA, dfactorA)) {
      return;
   }

   numBuffers = ctx->Extensions.ARB_draw_buffers_blend
      ? ctx->Const.MaxDrawBuffers : 1;

   changed = GL_FALSE;
   for (buf = 0; buf < numBuffers; buf++) {
      if (ctx->Color.Blend[buf].SrcRGB != sfactorRGB ||
          ctx->Color.Blend[buf].DstRGB != dfactorRGB ||
          ctx->Color.Blend[buf].SrcA != sfactorA ||
          ctx->Color.Blend[buf].DstA != dfactorA) {
         changed = GL_TRUE;
         break;
      }
   }
   if (!changed)
      return;

   FLUSH_VERTICES(ctx, _NEW_COLOR);

   for (buf = 0; buf < numBuffers; buf++) {
      ctx->Color.Blend[buf].SrcRGB = sfactorRGB;
      ctx->Color.Blend[buf].DstRGB = dfactorRGB;
      ctx->Color.Blend[buf].SrcA = sfactorA;
      ctx->Color.Blend[buf].DstA = dfactorA;
      update_uses_dual_src(ctx, buf);
   }
   ctx->Color._BlendFuncPerBuffer = GL_FALSE;

   if (ctx->Driver.BlendFuncSeparate) {
      ctx->Driver.BlendFuncSeparate(ctx, sfactorRGB, dfactorRGB,
                                    sfactorA, dfactorA);
   }
}


/**
 * Set blend source/dest factors for one color buffer/target.
 */
void GLAPIENTRY
_mesa_BlendFunciARB(GLuint buf, GLenum sfactor, GLenum dfactor)
{
   _mesa_BlendFuncSeparateiARB(buf, sfactor, dfactor, sfactor, dfactor);
}


/**
 * Set separate blend source/dest factors for one color buffer/target.
 */
void GLAPIENTRY
_mesa_BlendFuncSeparateiARB(GLuint buf, GLenum sfactorRGB, GLenum dfactorRGB,
                         GLenum sfactorA, GLenum dfactorA)
{
   GET_CURRENT_CONTEXT(ctx);

   if (!ctx->Extensions.ARB_draw_buffers_blend) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glBlendFunc[Separate]i()");
      return;
   }

   if (buf >= ctx->Const.MaxDrawBuffers) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glBlendFuncSeparatei(buffer=%u)",
                  buf);
      return;
   }

   if (!validate_blend_factors(ctx, "glBlendFuncSeparatei",
                               sfactorRGB, dfactorRGB,
                               sfactorA, dfactorA)) {
      return;
   }

   if (ctx->Color.Blend[buf].SrcRGB == sfactorRGB &&
       ctx->Color.Blend[buf].DstRGB == dfactorRGB &&
       ctx->Color.Blend[buf].SrcA == sfactorA &&
       ctx->Color.Blend[buf].DstA == dfactorA)
      return; /* no change */

   FLUSH_VERTICES(ctx, _NEW_COLOR);

   ctx->Color.Blend[buf].SrcRGB = sfactorRGB;
   ctx->Color.Blend[buf].DstRGB = dfactorRGB;
   ctx->Color.Blend[buf].SrcA = sfactorA;
   ctx->Color.Blend[buf].DstA = dfactorA;
   update_uses_dual_src(ctx, buf);
   ctx->Color._BlendFuncPerBuffer = GL_TRUE;

   if (ctx->Driver.BlendFuncSeparatei) {
      ctx->Driver.BlendFuncSeparatei(ctx, buf, sfactorRGB, dfactorRGB,
                                     sfactorA, dfactorA);
   }
}


/**
 * Check if given blend equation is legal.
 * \return GL_TRUE if legal, GL_FALSE otherwise.
 */
static GLboolean
legal_blend_equation(const struct gl_context *ctx, GLenum mode)
{
   switch (mode) {
   case GL_FUNC_ADD:
   case GL_FUNC_SUBTRACT:
   case GL_FUNC_REVERSE_SUBTRACT:
      return GL_TRUE;
   case GL_MIN:
   case GL_MAX:
      return ctx->Extensions.EXT_blend_minmax;
   default:
      return GL_FALSE;
   }
}


/* This is really an extension function! */
void GLAPIENTRY
_mesa_BlendEquation( GLenum mode )
{
   GLuint buf, numBuffers;
   GLboolean changed;
   GET_CURRENT_CONTEXT(ctx);

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glBlendEquation(%s)\n",
                  _mesa_lookup_enum_by_nr(mode));

   if (!legal_blend_equation(ctx, mode)) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glBlendEquation");
      return;
   }

   numBuffers = ctx->Extensions.ARB_draw_buffers_blend
      ? ctx->Const.MaxDrawBuffers : 1;

   changed = GL_FALSE;
   for (buf = 0; buf < numBuffers; buf++) {
      if (ctx->Color.Blend[buf].EquationRGB != mode ||
          ctx->Color.Blend[buf].EquationA != mode) {
         changed = GL_TRUE;
         break;
      }
   }
   if (!changed)
      return;

   FLUSH_VERTICES(ctx, _NEW_COLOR);
   for (buf = 0; buf < numBuffers; buf++) {
      ctx->Color.Blend[buf].EquationRGB = mode;
      ctx->Color.Blend[buf].EquationA = mode;
   }
   ctx->Color._BlendEquationPerBuffer = GL_FALSE;

   if (ctx->Driver.BlendEquationSeparate)
      (*ctx->Driver.BlendEquationSeparate)( ctx, mode, mode );
}


/**
 * Set blend equation for one color buffer/target.
 */
void GLAPIENTRY
_mesa_BlendEquationiARB(GLuint buf, GLenum mode)
{
   GET_CURRENT_CONTEXT(ctx);

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glBlendEquationi(%u, %s)\n",
                  buf, _mesa_lookup_enum_by_nr(mode));

   if (buf >= ctx->Const.MaxDrawBuffers) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glBlendFuncSeparatei(buffer=%u)",
                  buf);
      return;
   }

   if (!legal_blend_equation(ctx, mode)) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glBlendEquationi");
      return;
   }

   if (ctx->Color.Blend[buf].EquationRGB == mode &&
       ctx->Color.Blend[buf].EquationA == mode)
      return;  /* no change */

   FLUSH_VERTICES(ctx, _NEW_COLOR);
   ctx->Color.Blend[buf].EquationRGB = mode;
   ctx->Color.Blend[buf].EquationA = mode;
   ctx->Color._BlendEquationPerBuffer = GL_TRUE;

   if (ctx->Driver.BlendEquationSeparatei)
      ctx->Driver.BlendEquationSeparatei(ctx, buf, mode, mode);
}


void GLAPIENTRY
_mesa_BlendEquationSeparate( GLenum modeRGB, GLenum modeA )
{
   GLuint buf, numBuffers;
   GLboolean changed;
   GET_CURRENT_CONTEXT(ctx);

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glBlendEquationSeparateEXT(%s %s)\n",
                  _mesa_lookup_enum_by_nr(modeRGB),
                  _mesa_lookup_enum_by_nr(modeA));

   if ( (modeRGB != modeA) && !ctx->Extensions.EXT_blend_equation_separate ) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
		  "glBlendEquationSeparateEXT not supported by driver");
      return;
   }

   if (!legal_blend_equation(ctx, modeRGB)) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glBlendEquationSeparateEXT(modeRGB)");
      return;
   }

   if (!legal_blend_equation(ctx, modeA)) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glBlendEquationSeparateEXT(modeA)");
      return;
   }

   numBuffers = ctx->Extensions.ARB_draw_buffers_blend
      ? ctx->Const.MaxDrawBuffers : 1;

   changed = GL_FALSE;
   for (buf = 0; buf < numBuffers; buf++) {
      if (ctx->Color.Blend[buf].EquationRGB != modeRGB ||
          ctx->Color.Blend[buf].EquationA != modeA) {
         changed = GL_TRUE;
         break;
      }
   }
   if (!changed)
      return;

   FLUSH_VERTICES(ctx, _NEW_COLOR);
   for (buf = 0; buf < numBuffers; buf++) {
      ctx->Color.Blend[buf].EquationRGB = modeRGB;
      ctx->Color.Blend[buf].EquationA = modeA;
   }
   ctx->Color._BlendEquationPerBuffer = GL_FALSE;

   if (ctx->Driver.BlendEquationSeparate)
      ctx->Driver.BlendEquationSeparate(ctx, modeRGB, modeA);
}


/**
 * Set separate blend equations for one color buffer/target.
 */
void GLAPIENTRY
_mesa_BlendEquationSeparateiARB(GLuint buf, GLenum modeRGB, GLenum modeA)
{
   GET_CURRENT_CONTEXT(ctx);

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glBlendEquationSeparatei(%u, %s %s)\n", buf,
                  _mesa_lookup_enum_by_nr(modeRGB),
                  _mesa_lookup_enum_by_nr(modeA));

   if (buf >= ctx->Const.MaxDrawBuffers) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glBlendEquationSeparatei(buffer=%u)",
                  buf);
      return;
   }

   if (!legal_blend_equation(ctx, modeRGB)) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glBlendEquationSeparatei(modeRGB)");
      return;
   }

   if (!legal_blend_equation(ctx, modeA)) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glBlendEquationSeparatei(modeA)");
      return;
   }

   if (ctx->Color.Blend[buf].EquationRGB == modeRGB &&
       ctx->Color.Blend[buf].EquationA == modeA)
      return;  /* no change */

   FLUSH_VERTICES(ctx, _NEW_COLOR);
   ctx->Color.Blend[buf].EquationRGB = modeRGB;
   ctx->Color.Blend[buf].EquationA = modeA;
   ctx->Color._BlendEquationPerBuffer = GL_TRUE;

   if (ctx->Driver.BlendEquationSeparatei)
      ctx->Driver.BlendEquationSeparatei(ctx, buf, modeRGB, modeA);
}


/**
 * Set the blending color.
 *
 * \param red red color component.
 * \param green green color component.
 * \param blue blue color component.
 * \param alpha alpha color component.
 *
 * \sa glBlendColor().
 *
 * Clamps the parameters and updates gl_colorbuffer_attrib::BlendColor.  On a
 * change, flushes the vertices and notifies the driver via
 * dd_function_table::BlendColor callback.
 */
void GLAPIENTRY
_mesa_BlendColor( GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha )
{
   GLfloat tmp[4];
   GET_CURRENT_CONTEXT(ctx);

   tmp[0] = red;
   tmp[1] = green;
   tmp[2] = blue;
   tmp[3] = alpha;

   if (TEST_EQ_4V(tmp, ctx->Color.BlendColorUnclamped))
      return;

   FLUSH_VERTICES(ctx, _NEW_COLOR);
   COPY_4FV( ctx->Color.BlendColorUnclamped, tmp );

   ctx->Color.BlendColor[0] = CLAMP(tmp[0], 0.0F, 1.0F);
   ctx->Color.BlendColor[1] = CLAMP(tmp[1], 0.0F, 1.0F);
   ctx->Color.BlendColor[2] = CLAMP(tmp[2], 0.0F, 1.0F);
   ctx->Color.BlendColor[3] = CLAMP(tmp[3], 0.0F, 1.0F);

   if (ctx->Driver.BlendColor)
      (*ctx->Driver.BlendColor)(ctx, ctx->Color.BlendColor);
}


/**
 * Specify the alpha test function.
 *
 * \param func alpha comparison function.
 * \param ref reference value.
 *
 * Verifies the parameters and updates gl_colorbuffer_attrib. 
 * On a change, flushes the vertices and notifies the driver via
 * dd_function_table::AlphaFunc callback.
 */
void GLAPIENTRY
_mesa_AlphaFunc( GLenum func, GLclampf ref )
{
   GET_CURRENT_CONTEXT(ctx);

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glAlphaFunc(%s, %f)\n",
                  _mesa_lookup_enum_by_nr(func), ref);

   switch (func) {
   case GL_NEVER:
   case GL_LESS:
   case GL_EQUAL:
   case GL_LEQUAL:
   case GL_GREATER:
   case GL_NOTEQUAL:
   case GL_GEQUAL:
   case GL_ALWAYS:
      if (ctx->Color.AlphaFunc == func && ctx->Color.AlphaRefUnclamped == ref)
         return; /* no change */

      FLUSH_VERTICES(ctx, _NEW_COLOR);
      ctx->Color.AlphaFunc = func;
      ctx->Color.AlphaRefUnclamped = ref;
      ctx->Color.AlphaRef = CLAMP(ref, 0.0F, 1.0F);

      if (ctx->Driver.AlphaFunc)
         ctx->Driver.AlphaFunc(ctx, func, ctx->Color.AlphaRef);
      return;

   default:
      _mesa_error( ctx, GL_INVALID_ENUM, "glAlphaFunc(func)" );
      return;
   }
}


/**
 * Specify a logic pixel operation for color index rendering.
 *
 * \param opcode operation.
 *
 * Verifies that \p opcode is a valid enum and updates
gl_colorbuffer_attrib::LogicOp.
 * On a change, flushes the vertices and notifies the driver via the
 * dd_function_table::LogicOpcode callback.
 */
void GLAPIENTRY
_mesa_LogicOp( GLenum opcode )
{
   GET_CURRENT_CONTEXT(ctx);

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glLogicOp(%s)\n", _mesa_lookup_enum_by_nr(opcode));

   switch (opcode) {
      case GL_CLEAR:
      case GL_SET:
      case GL_COPY:
      case GL_COPY_INVERTED:
      case GL_NOOP:
      case GL_INVERT:
      case GL_AND:
      case GL_NAND:
      case GL_OR:
      case GL_NOR:
      case GL_XOR:
      case GL_EQUIV:
      case GL_AND_REVERSE:
      case GL_AND_INVERTED:
      case GL_OR_REVERSE:
      case GL_OR_INVERTED:
	 break;
      default:
         _mesa_error( ctx, GL_INVALID_ENUM, "glLogicOp" );
	 return;
   }

   if (ctx->Color.LogicOp == opcode)
      return;

   FLUSH_VERTICES(ctx, _NEW_COLOR);
   ctx->Color.LogicOp = opcode;

   if (ctx->Driver.LogicOpcode)
      ctx->Driver.LogicOpcode( ctx, opcode );
}


void GLAPIENTRY
_mesa_IndexMask( GLuint mask )
{
   GET_CURRENT_CONTEXT(ctx);

   if (ctx->Color.IndexMask == mask)
      return;

   FLUSH_VERTICES(ctx, _NEW_COLOR);
   ctx->Color.IndexMask = mask;
}


/**
 * Enable or disable writing of frame buffer color components.
 *
 * \param red whether to mask writing of the red color component.
 * \param green whether to mask writing of the green color component.
 * \param blue whether to mask writing of the blue color component.
 * \param alpha whether to mask writing of the alpha color component.
 *
 * \sa glColorMask().
 *
 * Sets the appropriate value of gl_colorbuffer_attrib::ColorMask.  On a
 * change, flushes the vertices and notifies the driver via the
 * dd_function_table::ColorMask callback.
 */
void GLAPIENTRY
_mesa_ColorMask( GLboolean red, GLboolean green,
                 GLboolean blue, GLboolean alpha )
{
   GET_CURRENT_CONTEXT(ctx);
   GLubyte tmp[4];
   GLuint i;
   GLboolean flushed;

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glColorMask(%d, %d, %d, %d)\n",
                  red, green, blue, alpha);

   /* Shouldn't have any information about channel depth in core mesa
    * -- should probably store these as the native booleans:
    */
   tmp[RCOMP] = red    ? 0xff : 0x0;
   tmp[GCOMP] = green  ? 0xff : 0x0;
   tmp[BCOMP] = blue   ? 0xff : 0x0;
   tmp[ACOMP] = alpha  ? 0xff : 0x0;

   flushed = GL_FALSE;
   for (i = 0; i < ctx->Const.MaxDrawBuffers; i++) {
      if (!TEST_EQ_4V(tmp, ctx->Color.ColorMask[i])) {
         if (!flushed) {
            FLUSH_VERTICES(ctx, _NEW_COLOR);
         }
         flushed = GL_TRUE;
         COPY_4UBV(ctx->Color.ColorMask[i], tmp);
      }
   }

   if (ctx->Driver.ColorMask)
      ctx->Driver.ColorMask( ctx, red, green, blue, alpha );
}


/**
 * For GL_EXT_draw_buffers2 and GL3
 */
void GLAPIENTRY
_mesa_ColorMaski( GLuint buf, GLboolean red, GLboolean green,
                        GLboolean blue, GLboolean alpha )
{
   GLubyte tmp[4];
   GET_CURRENT_CONTEXT(ctx);

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glColorMaskIndexed %u %d %d %d %d\n",
                  buf, red, green, blue, alpha);

   if (buf >= ctx->Const.MaxDrawBuffers) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glColorMaskIndexed(buf=%u)", buf);
      return;
   }

   /* Shouldn't have any information about channel depth in core mesa
    * -- should probably store these as the native booleans:
    */
   tmp[RCOMP] = red    ? 0xff : 0x0;
   tmp[GCOMP] = green  ? 0xff : 0x0;
   tmp[BCOMP] = blue   ? 0xff : 0x0;
   tmp[ACOMP] = alpha  ? 0xff : 0x0;

   if (TEST_EQ_4V(tmp, ctx->Color.ColorMask[buf]))
      return;

   FLUSH_VERTICES(ctx, _NEW_COLOR);
   COPY_4UBV(ctx->Color.ColorMask[buf], tmp);

   if (ctx->Driver.ColorMaskIndexed)
      ctx->Driver.ColorMaskIndexed(ctx, buf, red, green, blue, alpha);
}


void GLAPIENTRY
_mesa_ClampColor(GLenum target, GLenum clamp)
{
   GET_CURRENT_CONTEXT(ctx);

   if (clamp != GL_TRUE && clamp != GL_FALSE && clamp != GL_FIXED_ONLY_ARB) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glClampColorARB(clamp)");
      return;
   }

   switch (target) {
   case GL_CLAMP_VERTEX_COLOR_ARB:
      if (ctx->API == API_OPENGL_CORE &&
          !ctx->Extensions.ARB_color_buffer_float) {
         goto invalid_enum;
      }
      FLUSH_VERTICES(ctx, _NEW_LIGHT);
      ctx->Light.ClampVertexColor = clamp;
      _mesa_update_clamp_vertex_color(ctx);
      break;
   case GL_CLAMP_FRAGMENT_COLOR_ARB:
      if (ctx->API == API_OPENGL_CORE &&
          !ctx->Extensions.ARB_color_buffer_float) {
         goto invalid_enum;
      }
      FLUSH_VERTICES(ctx, _NEW_FRAG_CLAMP);
      ctx->Color.ClampFragmentColor = clamp;
      _mesa_update_clamp_fragment_color(ctx);
      break;
   case GL_CLAMP_READ_COLOR_ARB:
      ctx->Color.ClampReadColor = clamp;
      break;
   default:
      goto invalid_enum;
   }
   return;

invalid_enum:
   _mesa_error(ctx, GL_INVALID_ENUM, "glClampColor(%s)",
               _mesa_lookup_enum_by_nr(target));
}

static GLboolean
get_clamp_color(const struct gl_framebuffer *fb, GLenum clamp)
{
   if (clamp == GL_TRUE || clamp == GL_FALSE)
      return clamp;

   ASSERT(clamp == GL_FIXED_ONLY);
   if (!fb)
      return GL_TRUE;

   return fb->_AllColorBuffersFixedPoint;
}

GLboolean
_mesa_get_clamp_fragment_color(const struct gl_context *ctx)
{
   return get_clamp_color(ctx->DrawBuffer,
                                ctx->Color.ClampFragmentColor);
}

GLboolean
_mesa_get_clamp_vertex_color(const struct gl_context *ctx)
{
   return get_clamp_color(ctx->DrawBuffer, ctx->Light.ClampVertexColor);
}

GLboolean
_mesa_get_clamp_read_color(const struct gl_context *ctx)
{
   return get_clamp_color(ctx->ReadBuffer, ctx->Color.ClampReadColor);
}

/**
 * Update the ctx->Color._ClampFragmentColor field
 */
void
_mesa_update_clamp_fragment_color(struct gl_context *ctx)
{
   struct gl_framebuffer *fb = ctx->DrawBuffer;

   /* Don't clamp if:
    * - there is no colorbuffer
    * - all colorbuffers are unsigned normalized, so clamping has no effect
    * - there is an integer colorbuffer
    */
   if (!fb || !fb->_HasSNormOrFloatColorBuffer || fb->_IntegerColor)
      ctx->Color._ClampFragmentColor = GL_FALSE;
   else
      ctx->Color._ClampFragmentColor = _mesa_get_clamp_fragment_color(ctx);
}

/**
 * Update the ctx->Color._ClampVertexColor field
 */
void
_mesa_update_clamp_vertex_color(struct gl_context *ctx)
{
   ctx->Light._ClampVertexColor = _mesa_get_clamp_vertex_color(ctx);
}

/**
 * Returns an appropriate mesa_format for color rendering based on the
 * GL_FRAMEBUFFER_SRGB state.
 *
 * Some drivers implement GL_FRAMEBUFFER_SRGB using a flag on the blend state
 * (which GL_FRAMEBUFFER_SRGB maps to reasonably), but some have to do so by
 * overriding the format of the surface.  This is a helper for doing the
 * surface format override variant.
 */
mesa_format
_mesa_get_render_format(const struct gl_context *ctx, mesa_format format)
{
   if (ctx->Color.sRGBEnabled)
      return format;
   else
      return _mesa_get_srgb_format_linear(format);
}

/**********************************************************************/
/** \name Initialization */
/*@@{*/

/**
 * Initialization of the context's Color attribute group.
 *
 * \param ctx GL context.
 *
 * Initializes the related fields in the context color attribute group,
 * __struct gl_contextRec::Color.
 */
void _mesa_init_color( struct gl_context * ctx )
{
   GLuint i;

   /* Color buffer group */
   ctx->Color.IndexMask = ~0u;
   memset(ctx->Color.ColorMask, 0xff, sizeof(ctx->Color.ColorMask));
   ctx->Color.ClearIndex = 0;
   ASSIGN_4V( ctx->Color.ClearColor.f, 0, 0, 0, 0 );
   ctx->Color.AlphaEnabled = GL_FALSE;
   ctx->Color.AlphaFunc = GL_ALWAYS;
   ctx->Color.AlphaRef = 0;
   ctx->Color.BlendEnabled = 0x0;
   for (i = 0; i < Elements(ctx->Color.Blend); i++) {
      ctx->Color.Blend[i].SrcRGB = GL_ONE;
      ctx->Color.Blend[i].DstRGB = GL_ZERO;
      ctx->Color.Blend[i].SrcA = GL_ONE;
      ctx->Color.Blend[i].DstA = GL_ZERO;
      ctx->Color.Blend[i].EquationRGB = GL_FUNC_ADD;
      ctx->Color.Blend[i].EquationA = GL_FUNC_ADD;
   }
   ASSIGN_4V( ctx->Color.BlendColor, 0.0, 0.0, 0.0, 0.0 );
   ASSIGN_4V( ctx->Color.BlendColorUnclamped, 0.0, 0.0, 0.0, 0.0 );
   ctx->Color.IndexLogicOpEnabled = GL_FALSE;
   ctx->Color.ColorLogicOpEnabled = GL_FALSE;
   ctx->Color.LogicOp = GL_COPY;
   ctx->Color.DitherFlag = GL_TRUE;

   /* GL_FRONT is not possible on GLES. Instead GL_BACK will render to either
    * the front or the back buffer depending on the config */
   if (ctx->Visual.doubleBufferMode || _mesa_is_gles(ctx)) {
      ctx->Color.DrawBuffer[0] = GL_BACK;
   }
   else {
      ctx->Color.DrawBuffer[0] = GL_FRONT;
   }

   ctx->Color.ClampFragmentColor = ctx->API == API_OPENGL_COMPAT ?
                                   GL_FIXED_ONLY_ARB : GL_FALSE;
   ctx->Color._ClampFragmentColor = GL_FALSE;
   ctx->Color.ClampReadColor = GL_FIXED_ONLY_ARB;

   if (ctx->API == API_OPENGLES2) {
      /* GLES 3 behaves as though GL_FRAMEBUFFER_SRGB is always enabled. */
      ctx->Color.sRGBEnabled = GL_TRUE;
   } else {
      ctx->Color.sRGBEnabled = GL_FALSE;
   }
}

/*@@}*/
@


1.7
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.6
log
@Merge Mesa 9.2.0
@
text
@d857 1
a857 1
 * Returns an appropriate gl_format for color rendering based on the
d865 2
a866 2
gl_format
_mesa_get_render_format(const struct gl_context *ctx, gl_format format)
d914 3
a916 1
   if (ctx->Visual.doubleBufferMode) {
@


1.5
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a7 1
 * Version:  6.5.1
d24 4
a27 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
a50 1
      return ctx->Extensions.NV_blend_square;
d60 1
d65 7
a71 1
      return GL_TRUE;
a87 1
      return ctx->Extensions.NV_blend_square;
d96 1
d101 11
a111 1
      return GL_TRUE;
d171 1
a171 1
   _mesa_BlendFuncSeparateEXT(sfactor, dfactor, sfactor, dfactor);
d174 18
d202 1
a202 1
_mesa_BlendFuncSeparateEXT( GLenum sfactorRGB, GLenum dfactorRGB,
a207 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d245 1
a255 3
#if _HAVE_FULL_GL


d260 1
a260 1
_mesa_BlendFunci(GLuint buf, GLenum sfactor, GLenum dfactor)
d262 1
a262 1
   _mesa_BlendFuncSeparatei(buf, sfactor, dfactor, sfactor, dfactor);
d270 1
a270 1
_mesa_BlendFuncSeparatei(GLuint buf, GLenum sfactorRGB, GLenum dfactorRGB,
a273 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d304 1
d319 1
a319 2
legal_blend_equation(const struct gl_context *ctx,
                     GLenum mode, GLboolean is_separate)
d323 2
a328 7
   case GL_LOGIC_OP:
      /* glBlendEquationSeparate cannot take GL_LOGIC_OP as a parameter.
       */
      return ctx->Extensions.EXT_blend_logic_op && !is_separate;
   case GL_FUNC_SUBTRACT:
   case GL_FUNC_REVERSE_SUBTRACT:
      return ctx->Extensions.EXT_blend_subtract;
a341 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d347 1
a347 1
   if (!legal_blend_equation(ctx, mode, GL_FALSE)) {
d382 1
a382 1
_mesa_BlendEquationi(GLuint buf, GLenum mode)
a384 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d396 1
a396 1
   if (!legal_blend_equation(ctx, mode, GL_FALSE)) {
d416 1
a416 1
_mesa_BlendEquationSeparateEXT( GLenum modeRGB, GLenum modeA )
a420 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d433 1
a433 1
   if (!legal_blend_equation(ctx, modeRGB, GL_TRUE)) {
d438 1
a438 1
   if (!legal_blend_equation(ctx, modeA, GL_TRUE)) {
d473 1
a473 1
_mesa_BlendEquationSeparatei(GLuint buf, GLenum modeRGB, GLenum modeA)
a475 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d488 1
a488 1
   if (!legal_blend_equation(ctx, modeRGB, GL_TRUE)) {
d493 1
a493 1
   if (!legal_blend_equation(ctx, modeA, GL_TRUE)) {
a511 4

#endif /* _HAVE_FULL_GL */


a530 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
a566 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
a613 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d651 1
a651 1
#if _HAVE_FULL_GL
a655 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
a662 1
#endif
a686 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d720 1
a720 1
_mesa_ColorMaskIndexed( GLuint buf, GLboolean red, GLboolean green,
a724 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d755 1
a755 1
_mesa_ClampColorARB(GLenum target, GLenum clamp)
a758 2
   ASSERT_OUTSIDE_BEGIN_END(ctx);

d766 4
d772 1
d775 4
d781 1
a783 1
      FLUSH_VERTICES(ctx, _NEW_COLOR);
d787 1
a787 2
      _mesa_error(ctx, GL_INVALID_ENUM, "glClampColorARB(target)");
      return;
d789 5
d796 5
d802 3
d806 67
d894 1
a894 2
   ASSIGN_4V( ctx->Color.ClearColor, 0, 0, 0, 0 );
   ASSIGN_4V( ctx->Color.ClearColorUnclamped, 0, 0, 0, 0 );
a910 1
   ctx->Color._LogicOpEnabled = GL_FALSE;
d921 3
a923 2
   ctx->Color.ClampFragmentColor = GL_FIXED_ONLY_ARB;
   ctx->Color._ClampFragmentColor = GL_TRUE;
d925 7
a931 1
   ctx->Color._ClampReadColor = GL_TRUE;
@


1.4
log
@Merge Mesa 7.10.3
@
text
@d40 104
d160 1
a160 1
 * Process GL_EXT_blend_func_separate().
a165 4
 *
 * Verifies the parameters and updates gl_colorbuffer_attrib.
 * On a change, flush the vertices and notify the driver via
 * dd_function_table::BlendFuncSeparate.
d171 2
d183 16
a198 21
   switch (sfactorRGB) {
      case GL_SRC_COLOR:
      case GL_ONE_MINUS_SRC_COLOR:
         if (!ctx->Extensions.NV_blend_square) {
            _mesa_error(ctx, GL_INVALID_ENUM, "glBlendFunc or glBlendFuncSeparate (sfactorRGB)");
            return;
         }
         /* fall-through */
      case GL_ZERO:
      case GL_ONE:
      case GL_DST_COLOR:
      case GL_ONE_MINUS_DST_COLOR:
      case GL_SRC_ALPHA:
      case GL_ONE_MINUS_SRC_ALPHA:
      case GL_DST_ALPHA:
      case GL_ONE_MINUS_DST_ALPHA:
      case GL_SRC_ALPHA_SATURATE:
      case GL_CONSTANT_COLOR:
      case GL_ONE_MINUS_CONSTANT_COLOR:
      case GL_CONSTANT_ALPHA:
      case GL_ONE_MINUS_CONSTANT_ALPHA:
d200 12
a211 3
      default:
         _mesa_error(ctx, GL_INVALID_ENUM, "glBlendFunc or glBlendFuncSeparate (sfactorRGB)");
         return;
d213 1
d215 3
a217 24
   switch (dfactorRGB) {
      case GL_DST_COLOR:
      case GL_ONE_MINUS_DST_COLOR:
         if (!ctx->Extensions.NV_blend_square) {
            _mesa_error(ctx, GL_INVALID_ENUM, "glBlendFunc or glBlendFuncSeparate (dfactorRGB)");
            return;
         }
         /* fall-through */
      case GL_ZERO:
      case GL_ONE:
      case GL_SRC_COLOR:
      case GL_ONE_MINUS_SRC_COLOR:
      case GL_SRC_ALPHA:
      case GL_ONE_MINUS_SRC_ALPHA:
      case GL_DST_ALPHA:
      case GL_ONE_MINUS_DST_ALPHA:
      case GL_CONSTANT_COLOR:
      case GL_ONE_MINUS_CONSTANT_COLOR:
      case GL_CONSTANT_ALPHA:
      case GL_ONE_MINUS_CONSTANT_ALPHA:
         break;
      default:
         _mesa_error(ctx, GL_INVALID_ENUM, "glBlendFunc or glBlendFuncSeparate (dfactorRGB)");
         return;
d219 2
d222 26
a247 25
   switch (sfactorA) {
      case GL_SRC_COLOR:
      case GL_ONE_MINUS_SRC_COLOR:
         if (!ctx->Extensions.NV_blend_square) {
            _mesa_error(ctx, GL_INVALID_ENUM, "glBlendFunc or glBlendFuncSeparate (sfactorA)");
            return;
         }
         /* fall-through */
      case GL_ZERO:
      case GL_ONE:
      case GL_DST_COLOR:
      case GL_ONE_MINUS_DST_COLOR:
      case GL_SRC_ALPHA:
      case GL_ONE_MINUS_SRC_ALPHA:
      case GL_DST_ALPHA:
      case GL_ONE_MINUS_DST_ALPHA:
      case GL_SRC_ALPHA_SATURATE:
      case GL_CONSTANT_COLOR:
      case GL_ONE_MINUS_CONSTANT_COLOR:
      case GL_CONSTANT_ALPHA:
      case GL_ONE_MINUS_CONSTANT_ALPHA:
         break;
      default:
         _mesa_error(ctx, GL_INVALID_ENUM, "glBlendFunc or glBlendFuncSeparate (sfactorA)");
         return;
d250 4
a253 24
   switch (dfactorA) {
      case GL_DST_COLOR:
      case GL_ONE_MINUS_DST_COLOR:
         if (!ctx->Extensions.NV_blend_square) {
            _mesa_error(ctx, GL_INVALID_ENUM, "glBlendFunc or glBlendFuncSeparate (dfactorA)");
            return;
         }
         /* fall-through */
      case GL_ZERO:
      case GL_ONE:
      case GL_SRC_COLOR:
      case GL_ONE_MINUS_SRC_COLOR:
      case GL_SRC_ALPHA:
      case GL_ONE_MINUS_SRC_ALPHA:
      case GL_DST_ALPHA:
      case GL_ONE_MINUS_DST_ALPHA:
      case GL_CONSTANT_COLOR:
      case GL_ONE_MINUS_CONSTANT_COLOR:
      case GL_CONSTANT_ALPHA:
      case GL_ONE_MINUS_CONSTANT_ALPHA:
         break;
      default:
         _mesa_error( ctx, GL_INVALID_ENUM, "glBlendFunc or glBlendFuncSeparate (dfactorA)" );
         return;
d256 3
a258 4
   if (ctx->Color.BlendSrcRGB == sfactorRGB &&
       ctx->Color.BlendDstRGB == dfactorRGB &&
       ctx->Color.BlendSrcA == sfactorA &&
       ctx->Color.BlendDstA == dfactorA)
d260 7
d270 9
a278 8
   ctx->Color.BlendSrcRGB = sfactorRGB;
   ctx->Color.BlendDstRGB = dfactorRGB;
   ctx->Color.BlendSrcA = sfactorA;
   ctx->Color.BlendDstA = dfactorA;

   if (ctx->Driver.BlendFuncSeparate) {
      (*ctx->Driver.BlendFuncSeparate)( ctx, sfactorRGB, dfactorRGB,
					sfactorA, dfactorA );
d283 4
a286 2
#if _HAVE_FULL_GL

d288 2
a289 2
_mesa_validate_blend_equation( struct gl_context *ctx,
			       GLenum mode, GLboolean is_separate )
d292 6
a297 8
      case GL_FUNC_ADD:
         break;
      case GL_MIN:
      case GL_MAX:
         if (!ctx->Extensions.EXT_blend_minmax) {
            return GL_FALSE;
         }
         break;
d300 6
a305 13
      case GL_LOGIC_OP:
         if (!ctx->Extensions.EXT_blend_logic_op || is_separate) {
            return GL_FALSE;
         }
         break;
      case GL_FUNC_SUBTRACT:
      case GL_FUNC_REVERSE_SUBTRACT:
         if (!ctx->Extensions.EXT_blend_subtract) {
            return GL_FALSE;
         }
         break;
      default:
         return GL_FALSE;
a306 2

   return GL_TRUE;
d314 2
d320 1
a320 1
      _mesa_debug(ctx, "glBlendEquation %s\n",
d323 1
a323 1
   if ( ! _mesa_validate_blend_equation( ctx, mode, GL_FALSE ) ) {
d328 12
a339 2
   if ( (ctx->Color.BlendEquationRGB == mode) &&
	(ctx->Color.BlendEquationA == mode) )
d343 5
a347 2
   ctx->Color.BlendEquationRGB = mode;
   ctx->Color.BlendEquationA = mode;
d354 38
d395 2
d401 1
a401 1
      _mesa_debug(ctx, "glBlendEquationSeparateEXT %s %s\n",
d411 1
a411 1
   if ( ! _mesa_validate_blend_equation( ctx, modeRGB, GL_TRUE ) ) {
d416 1
a416 1
   if ( ! _mesa_validate_blend_equation( ctx, modeA, GL_TRUE ) ) {
d421 2
d424 9
a432 2
   if ( (ctx->Color.BlendEquationRGB == modeRGB) &&
	(ctx->Color.BlendEquationA == modeA) )
d436 5
a440 2
   ctx->Color.BlendEquationRGB = modeRGB;
   ctx->Color.BlendEquationA = modeA;
d443 45
a487 1
      (*ctx->Driver.BlendEquationSeparate)( ctx, modeRGB, modeA );
d489 4
a492 1
#endif
d516 4
a519 4
   tmp[0] = CLAMP( red,   0.0F, 1.0F );
   tmp[1] = CLAMP( green, 0.0F, 1.0F );
   tmp[2] = CLAMP( blue,  0.0F, 1.0F );
   tmp[3] = CLAMP( alpha, 0.0F, 1.0F );
d521 1
a521 1
   if (TEST_EQ_4V(tmp, ctx->Color.BlendColor))
d525 6
a530 1
   COPY_4FV( ctx->Color.BlendColor, tmp );
d533 1
a533 1
      (*ctx->Driver.BlendColor)(ctx, tmp);
d553 4
d566 1
a566 3
      ref = CLAMP(ref, 0.0F, 1.0F);

      if (ctx->Color.AlphaFunc == func && ctx->Color.AlphaRef == ref)
d571 2
a572 1
      ctx->Color.AlphaRef = ref;
d575 1
a575 1
         ctx->Driver.AlphaFunc(ctx, func, ref);
d601 3
d678 2
a679 1
      _mesa_debug(ctx, "glColorMask %d %d %d %d\n", red, green, blue, alpha);
d744 1
a744 1
extern void GLAPIENTRY
d758 1
d762 1
d766 1
d792 2
d799 1
d804 8
a811 6
   ctx->Color.BlendSrcRGB = GL_ONE;
   ctx->Color.BlendDstRGB = GL_ZERO;
   ctx->Color.BlendSrcA = GL_ONE;
   ctx->Color.BlendDstA = GL_ZERO;
   ctx->Color.BlendEquationRGB = GL_FUNC_ADD;
   ctx->Color.BlendEquationA = GL_FUNC_ADD;
d813 1
d828 1
d830 1
@


1.3
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d210 1
a210 1
_mesa_validate_blend_equation( GLcontext *ctx,
d218 1
a218 2
         if (!ctx->Extensions.EXT_blend_minmax &&
             !ctx->Extensions.ARB_imaging) {
d231 1
a231 2
         if (!ctx->Extensions.EXT_blend_subtract &&
             !ctx->Extensions.ARB_imaging) {
d592 1
a592 1
 * __GLcontextRec::Color.
d594 1
a594 1
void _mesa_init_color( GLcontext * ctx )
@


1.2
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@a37 1
#include "glapi/glapitable.h"
d74 1
a74 1
   if (MESA_VERBOSE & (VERBOSE_API|VERBOSE_TEXTURE))
d252 1
a252 1
   if (MESA_VERBOSE & (VERBOSE_API|VERBOSE_TEXTURE))
d280 1
a280 1
   if (MESA_VERBOSE & (VERBOSE_API|VERBOSE_TEXTURE))
a458 3

   if (ctx->Driver.IndexMask)
      ctx->Driver.IndexMask( ctx, mask );
d483 2
d498 45
a542 1
   if (TEST_EQ_4UBV(tmp, ctx->Color.ColorMask))
d546 1
a546 1
   COPY_4UBV(ctx->Color.ColorMask, tmp);
d548 2
a549 2
   if (ctx->Driver.ColorMask)
      ctx->Driver.ColorMask( ctx, red, green, blue, alpha );
d600 1
a600 4
   ctx->Color.ColorMask[0] = 0xff;
   ctx->Color.ColorMask[1] = 0xff;
   ctx->Color.ColorMask[2] = 0xff;
   ctx->Color.ColorMask[3] = 0xff;
d606 1
a606 1
   ctx->Color.BlendEnabled = GL_FALSE;
@


1.1
log
@Initial revision
@
text
@a33 1
#include "colormac.h"
d38 1
a47 5
 *
 * Swizzles the inputs and calls \c glBlendFuncSeparateEXT.  This is done
 * using the \c CurrentDispatch table in the context, so this same function
 * can be used while compiling display lists.  Therefore, there is no need
 * for the display list code to save and restore this function.
d52 1
a52 4
   GET_CURRENT_CONTEXT(ctx);

   (*ctx->CurrentDispatch->BlendFuncSeparateEXT)( sfactor, dfactor,
						  sfactor, dfactor );
d509 31
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@a518 31
extern void GLAPIENTRY
_mesa_ClampColorARB(GLenum target, GLenum clamp)
{
   GET_CURRENT_CONTEXT(ctx);

   ASSERT_OUTSIDE_BEGIN_END(ctx);

   if (clamp != GL_TRUE && clamp != GL_FALSE && clamp != GL_FIXED_ONLY_ARB) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glClampColorARB(clamp)");
      return;
   }

   switch (target) {
   case GL_CLAMP_VERTEX_COLOR_ARB:
      ctx->Light.ClampVertexColor = clamp;
      break;
   case GL_CLAMP_FRAGMENT_COLOR_ARB:
      ctx->Color.ClampFragmentColor = clamp;
      break;
   case GL_CLAMP_READ_COLOR_ARB:
      ctx->Color.ClampReadColor = clamp;
      break;
   default:
      _mesa_error(ctx, GL_INVALID_ENUM, "glClampColorARB(target)");
      return;
   }
}




@


1.1.1.3
log
@Import Mesa 7.10.3
@
text
@d34 1
d48 5
d57 4
a60 1
   _mesa_BlendFuncSeparateEXT(sfactor, dfactor, sfactor, dfactor);
d83 1
a83 1
   if (MESA_VERBOSE & VERBOSE_API)
d219 1
a219 1
_mesa_validate_blend_equation( struct gl_context *ctx,
d227 2
a228 1
         if (!ctx->Extensions.EXT_blend_minmax) {
d241 2
a242 1
         if (!ctx->Extensions.EXT_blend_subtract) {
d261 1
a261 1
   if (MESA_VERBOSE & VERBOSE_API)
d289 1
a289 1
   if (MESA_VERBOSE & VERBOSE_API)
d468 3
a494 2
   GLuint i;
   GLboolean flushed;
d508 1
a508 45
   flushed = GL_FALSE;
   for (i = 0; i < ctx->Const.MaxDrawBuffers; i++) {
      if (!TEST_EQ_4V(tmp, ctx->Color.ColorMask[i])) {
         if (!flushed) {
            FLUSH_VERTICES(ctx, _NEW_COLOR);
         }
         flushed = GL_TRUE;
         COPY_4UBV(ctx->Color.ColorMask[i], tmp);
      }
   }

   if (ctx->Driver.ColorMask)
      ctx->Driver.ColorMask( ctx, red, green, blue, alpha );
}


/**
 * For GL_EXT_draw_buffers2 and GL3
 */
void GLAPIENTRY
_mesa_ColorMaskIndexed( GLuint buf, GLboolean red, GLboolean green,
                        GLboolean blue, GLboolean alpha )
{
   GLubyte tmp[4];
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glColorMaskIndexed %u %d %d %d %d\n",
                  buf, red, green, blue, alpha);

   if (buf >= ctx->Const.MaxDrawBuffers) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glColorMaskIndexed(buf=%u)", buf);
      return;
   }

   /* Shouldn't have any information about channel depth in core mesa
    * -- should probably store these as the native booleans:
    */
   tmp[RCOMP] = red    ? 0xff : 0x0;
   tmp[GCOMP] = green  ? 0xff : 0x0;
   tmp[BCOMP] = blue   ? 0xff : 0x0;
   tmp[ACOMP] = alpha  ? 0xff : 0x0;

   if (TEST_EQ_4V(tmp, ctx->Color.ColorMask[buf]))
d512 1
a512 1
   COPY_4UBV(ctx->Color.ColorMask[buf], tmp);
d514 2
a515 2
   if (ctx->Driver.ColorMaskIndexed)
      ctx->Driver.ColorMaskIndexed(ctx, buf, red, green, blue, alpha);
d560 1
a560 1
 * __struct gl_contextRec::Color.
d562 1
a562 1
void _mesa_init_color( struct gl_context * ctx )
d566 4
a569 1
   memset(ctx->Color.ColorMask, 0xff, sizeof(ctx->Color.ColorMask));
d575 1
a575 1
   ctx->Color.BlendEnabled = 0x0;
@


1.1.1.4
log
@Import Mesa 9.2.0
@
text
@d8 1
d25 3
a27 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
a39 120

/**
 * Check if given blend source factor is legal.
 * \return GL_TRUE if legal, GL_FALSE otherwise.
 */
static GLboolean
legal_src_factor(const struct gl_context *ctx, GLenum factor)
{
   switch (factor) {
   case GL_SRC_COLOR:
   case GL_ONE_MINUS_SRC_COLOR:
   case GL_ZERO:
   case GL_ONE:
   case GL_DST_COLOR:
   case GL_ONE_MINUS_DST_COLOR:
   case GL_SRC_ALPHA:
   case GL_ONE_MINUS_SRC_ALPHA:
   case GL_DST_ALPHA:
   case GL_ONE_MINUS_DST_ALPHA:
   case GL_SRC_ALPHA_SATURATE:
      return GL_TRUE;
   case GL_CONSTANT_COLOR:
   case GL_ONE_MINUS_CONSTANT_COLOR:
   case GL_CONSTANT_ALPHA:
   case GL_ONE_MINUS_CONSTANT_ALPHA:
      return _mesa_is_desktop_gl(ctx) || ctx->API == API_OPENGLES2;
   case GL_SRC1_COLOR:
   case GL_SRC1_ALPHA:
   case GL_ONE_MINUS_SRC1_COLOR:
   case GL_ONE_MINUS_SRC1_ALPHA:
      return _mesa_is_desktop_gl(ctx)
         && ctx->Extensions.ARB_blend_func_extended;
   default:
      return GL_FALSE;
   }
}


/**
 * Check if given blend destination factor is legal.
 * \return GL_TRUE if legal, GL_FALSE otherwise.
 */
static GLboolean
legal_dst_factor(const struct gl_context *ctx, GLenum factor)
{
   switch (factor) {
   case GL_DST_COLOR:
   case GL_ONE_MINUS_DST_COLOR:
   case GL_ZERO:
   case GL_ONE:
   case GL_SRC_COLOR:
   case GL_ONE_MINUS_SRC_COLOR:
   case GL_SRC_ALPHA:
   case GL_ONE_MINUS_SRC_ALPHA:
   case GL_DST_ALPHA:
   case GL_ONE_MINUS_DST_ALPHA:
      return GL_TRUE;
   case GL_CONSTANT_COLOR:
   case GL_ONE_MINUS_CONSTANT_COLOR:
   case GL_CONSTANT_ALPHA:
   case GL_ONE_MINUS_CONSTANT_ALPHA:
      return _mesa_is_desktop_gl(ctx) || ctx->API == API_OPENGLES2;
   case GL_SRC_ALPHA_SATURATE:
      return (_mesa_is_desktop_gl(ctx)
              && ctx->Extensions.ARB_blend_func_extended)
         || _mesa_is_gles3(ctx);
   case GL_SRC1_COLOR:
   case GL_SRC1_ALPHA:
   case GL_ONE_MINUS_SRC1_COLOR:
   case GL_ONE_MINUS_SRC1_ALPHA:
      return _mesa_is_desktop_gl(ctx)
         && ctx->Extensions.ARB_blend_func_extended;
   default:
      return GL_FALSE;
   }
}


/**
 * Check if src/dest RGB/A blend factors are legal.  If not generate
 * a GL error.
 * \return GL_TRUE if factors are legal, GL_FALSE otherwise.
 */
static GLboolean
validate_blend_factors(struct gl_context *ctx, const char *func,
                       GLenum sfactorRGB, GLenum dfactorRGB,
                       GLenum sfactorA, GLenum dfactorA)
{
   if (!legal_src_factor(ctx, sfactorRGB)) {
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "%s(sfactorRGB = %s)", func,
                  _mesa_lookup_enum_by_nr(sfactorRGB));
      return GL_FALSE;
   }

   if (!legal_dst_factor(ctx, dfactorRGB)) {
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "%s(dfactorRGB = %s)", func,
                  _mesa_lookup_enum_by_nr(dfactorRGB));
      return GL_FALSE;
   }

   if (sfactorA != sfactorRGB && !legal_src_factor(ctx, sfactorA)) {
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "%s(sfactorA = %s)", func,
                  _mesa_lookup_enum_by_nr(sfactorA));
      return GL_FALSE;
   }

   if (dfactorA != dfactorRGB && !legal_dst_factor(ctx, dfactorA)) {
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "%s(dfactorA = %s)", func,
                  _mesa_lookup_enum_by_nr(dfactorA));
      return GL_FALSE;
   }

   return GL_TRUE;
}


d51 1
a51 1
   _mesa_BlendFuncSeparate(sfactor, dfactor, sfactor, dfactor);
a53 18
static GLboolean
blend_factor_is_dual_src(GLenum factor)
{
   return (factor == GL_SRC1_COLOR ||
	   factor == GL_SRC1_ALPHA ||
	   factor == GL_ONE_MINUS_SRC1_COLOR ||
	   factor == GL_ONE_MINUS_SRC1_ALPHA);
}

static void
update_uses_dual_src(struct gl_context *ctx, int buf)
{
   ctx->Color.Blend[buf]._UsesDualSrc =
      (blend_factor_is_dual_src(ctx->Color.Blend[buf].SrcRGB) ||
       blend_factor_is_dual_src(ctx->Color.Blend[buf].DstRGB) ||
       blend_factor_is_dual_src(ctx->Color.Blend[buf].SrcA) ||
       blend_factor_is_dual_src(ctx->Color.Blend[buf].DstA));
}
d56 1
a56 1
 * Set the separate blend source/dest factors for all draw buffers.
d62 4
d68 1
a68 1
_mesa_BlendFuncSeparate( GLenum sfactorRGB, GLenum dfactorRGB,
a70 2
   GLuint buf, numBuffers;
   GLboolean changed;
d72 1
d81 25
a105 4
   if (!validate_blend_factors(ctx, "glBlendFuncSeparate",
                               sfactorRGB, dfactorRGB,
                               sfactorA, dfactorA)) {
      return;
d108 20
a127 10
   numBuffers = ctx->Extensions.ARB_draw_buffers_blend
      ? ctx->Const.MaxDrawBuffers : 1;

   changed = GL_FALSE;
   for (buf = 0; buf < numBuffers; buf++) {
      if (ctx->Color.Blend[buf].SrcRGB != sfactorRGB ||
          ctx->Color.Blend[buf].DstRGB != dfactorRGB ||
          ctx->Color.Blend[buf].SrcA != sfactorA ||
          ctx->Color.Blend[buf].DstA != dfactorA) {
         changed = GL_TRUE;
d129 3
a131 1
      }
a132 2
   if (!changed)
      return;
d134 25
a158 8
   FLUSH_VERTICES(ctx, _NEW_COLOR);

   for (buf = 0; buf < numBuffers; buf++) {
      ctx->Color.Blend[buf].SrcRGB = sfactorRGB;
      ctx->Color.Blend[buf].DstRGB = dfactorRGB;
      ctx->Color.Blend[buf].SrcA = sfactorA;
      ctx->Color.Blend[buf].DstA = dfactorA;
      update_uses_dual_src(ctx, buf);
a159 1
   ctx->Color._BlendFuncPerBuffer = GL_FALSE;
d161 24
a184 3
   if (ctx->Driver.BlendFuncSeparate) {
      ctx->Driver.BlendFuncSeparate(ctx, sfactorRGB, dfactorRGB,
                                    sfactorA, dfactorA);
a185 21
}


/**
 * Set blend source/dest factors for one color buffer/target.
 */
void GLAPIENTRY
_mesa_BlendFunciARB(GLuint buf, GLenum sfactor, GLenum dfactor)
{
   _mesa_BlendFuncSeparateiARB(buf, sfactor, dfactor, sfactor, dfactor);
}


/**
 * Set separate blend source/dest factors for one color buffer/target.
 */
void GLAPIENTRY
_mesa_BlendFuncSeparateiARB(GLuint buf, GLenum sfactorRGB, GLenum dfactorRGB,
                         GLenum sfactorA, GLenum dfactorA)
{
   GET_CURRENT_CONTEXT(ctx);
d187 4
a190 2
   if (!ctx->Extensions.ARB_draw_buffers_blend) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glBlendFunc[Separate]i()");
a191 1
   }
d193 1
a193 5
   if (buf >= ctx->Const.MaxDrawBuffers) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glBlendFuncSeparatei(buffer=%u)",
                  buf);
      return;
   }
d195 4
a198 5
   if (!validate_blend_factors(ctx, "glBlendFuncSeparatei",
                               sfactorRGB, dfactorRGB,
                               sfactorA, dfactorA)) {
      return;
   }
d200 3
a202 18
   if (ctx->Color.Blend[buf].SrcRGB == sfactorRGB &&
       ctx->Color.Blend[buf].DstRGB == dfactorRGB &&
       ctx->Color.Blend[buf].SrcA == sfactorA &&
       ctx->Color.Blend[buf].DstA == dfactorA)
      return; /* no change */

   FLUSH_VERTICES(ctx, _NEW_COLOR);

   ctx->Color.Blend[buf].SrcRGB = sfactorRGB;
   ctx->Color.Blend[buf].DstRGB = dfactorRGB;
   ctx->Color.Blend[buf].SrcA = sfactorA;
   ctx->Color.Blend[buf].DstA = dfactorA;
   update_uses_dual_src(ctx, buf);
   ctx->Color._BlendFuncPerBuffer = GL_TRUE;

   if (ctx->Driver.BlendFuncSeparatei) {
      ctx->Driver.BlendFuncSeparatei(ctx, buf, sfactorRGB, dfactorRGB,
                                     sfactorA, dfactorA);
d207 2
a208 4
/**
 * Check if given blend equation is legal.
 * \return GL_TRUE if legal, GL_FALSE otherwise.
 */
d210 2
a211 1
legal_blend_equation(const struct gl_context *ctx, GLenum mode)
d214 23
a236 9
   case GL_FUNC_ADD:
   case GL_FUNC_SUBTRACT:
   case GL_FUNC_REVERSE_SUBTRACT:
      return GL_TRUE;
   case GL_MIN:
   case GL_MAX:
      return ctx->Extensions.EXT_blend_minmax;
   default:
      return GL_FALSE;
d238 2
a246 2
   GLuint buf, numBuffers;
   GLboolean changed;
d248 1
d251 1
a251 1
      _mesa_debug(ctx, "glBlendEquation(%s)\n",
d254 1
a254 1
   if (!legal_blend_equation(ctx, mode)) {
d259 2
a260 12
   numBuffers = ctx->Extensions.ARB_draw_buffers_blend
      ? ctx->Const.MaxDrawBuffers : 1;

   changed = GL_FALSE;
   for (buf = 0; buf < numBuffers; buf++) {
      if (ctx->Color.Blend[buf].EquationRGB != mode ||
          ctx->Color.Blend[buf].EquationA != mode) {
         changed = GL_TRUE;
         break;
      }
   }
   if (!changed)
d264 2
a265 5
   for (buf = 0; buf < numBuffers; buf++) {
      ctx->Color.Blend[buf].EquationRGB = mode;
      ctx->Color.Blend[buf].EquationA = mode;
   }
   ctx->Color._BlendEquationPerBuffer = GL_FALSE;
a271 37
/**
 * Set blend equation for one color buffer/target.
 */
void GLAPIENTRY
_mesa_BlendEquationiARB(GLuint buf, GLenum mode)
{
   GET_CURRENT_CONTEXT(ctx);

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glBlendEquationi(%u, %s)\n",
                  buf, _mesa_lookup_enum_by_nr(mode));

   if (buf >= ctx->Const.MaxDrawBuffers) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glBlendFuncSeparatei(buffer=%u)",
                  buf);
      return;
   }

   if (!legal_blend_equation(ctx, mode)) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glBlendEquationi");
      return;
   }

   if (ctx->Color.Blend[buf].EquationRGB == mode &&
       ctx->Color.Blend[buf].EquationA == mode)
      return;  /* no change */

   FLUSH_VERTICES(ctx, _NEW_COLOR);
   ctx->Color.Blend[buf].EquationRGB = mode;
   ctx->Color.Blend[buf].EquationA = mode;
   ctx->Color._BlendEquationPerBuffer = GL_TRUE;

   if (ctx->Driver.BlendEquationSeparatei)
      ctx->Driver.BlendEquationSeparatei(ctx, buf, mode, mode);
}


d273 1
a273 1
_mesa_BlendEquationSeparate( GLenum modeRGB, GLenum modeA )
a274 2
   GLuint buf, numBuffers;
   GLboolean changed;
d276 1
d279 1
a279 1
      _mesa_debug(ctx, "glBlendEquationSeparateEXT(%s %s)\n",
d289 1
a289 1
   if (!legal_blend_equation(ctx, modeRGB)) {
d294 1
a294 1
   if (!legal_blend_equation(ctx, modeA)) {
a298 2
   numBuffers = ctx->Extensions.ARB_draw_buffers_blend
      ? ctx->Const.MaxDrawBuffers : 1;
d300 2
a301 9
   changed = GL_FALSE;
   for (buf = 0; buf < numBuffers; buf++) {
      if (ctx->Color.Blend[buf].EquationRGB != modeRGB ||
          ctx->Color.Blend[buf].EquationA != modeA) {
         changed = GL_TRUE;
         break;
      }
   }
   if (!changed)
d305 2
a306 5
   for (buf = 0; buf < numBuffers; buf++) {
      ctx->Color.Blend[buf].EquationRGB = modeRGB;
      ctx->Color.Blend[buf].EquationA = modeA;
   }
   ctx->Color._BlendEquationPerBuffer = GL_FALSE;
d309 1
a309 44
      ctx->Driver.BlendEquationSeparate(ctx, modeRGB, modeA);
}


/**
 * Set separate blend equations for one color buffer/target.
 */
void GLAPIENTRY
_mesa_BlendEquationSeparateiARB(GLuint buf, GLenum modeRGB, GLenum modeA)
{
   GET_CURRENT_CONTEXT(ctx);

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glBlendEquationSeparatei(%u, %s %s)\n", buf,
                  _mesa_lookup_enum_by_nr(modeRGB),
                  _mesa_lookup_enum_by_nr(modeA));

   if (buf >= ctx->Const.MaxDrawBuffers) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glBlendEquationSeparatei(buffer=%u)",
                  buf);
      return;
   }

   if (!legal_blend_equation(ctx, modeRGB)) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glBlendEquationSeparatei(modeRGB)");
      return;
   }

   if (!legal_blend_equation(ctx, modeA)) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glBlendEquationSeparatei(modeA)");
      return;
   }

   if (ctx->Color.Blend[buf].EquationRGB == modeRGB &&
       ctx->Color.Blend[buf].EquationA == modeA)
      return;  /* no change */

   FLUSH_VERTICES(ctx, _NEW_COLOR);
   ctx->Color.Blend[buf].EquationRGB = modeRGB;
   ctx->Color.Blend[buf].EquationA = modeA;
   ctx->Color._BlendEquationPerBuffer = GL_TRUE;

   if (ctx->Driver.BlendEquationSeparatei)
      ctx->Driver.BlendEquationSeparatei(ctx, buf, modeRGB, modeA);
d311 1
d333 1
d335 4
a338 4
   tmp[0] = red;
   tmp[1] = green;
   tmp[2] = blue;
   tmp[3] = alpha;
d340 1
a340 1
   if (TEST_EQ_4V(tmp, ctx->Color.BlendColorUnclamped))
d344 1
a344 6
   COPY_4FV( ctx->Color.BlendColorUnclamped, tmp );

   ctx->Color.BlendColor[0] = CLAMP(tmp[0], 0.0F, 1.0F);
   ctx->Color.BlendColor[1] = CLAMP(tmp[1], 0.0F, 1.0F);
   ctx->Color.BlendColor[2] = CLAMP(tmp[2], 0.0F, 1.0F);
   ctx->Color.BlendColor[3] = CLAMP(tmp[3], 0.0F, 1.0F);
d347 1
a347 1
      (*ctx->Driver.BlendColor)(ctx, ctx->Color.BlendColor);
d365 1
a365 4

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glAlphaFunc(%s, %f)\n",
                  _mesa_lookup_enum_by_nr(func), ref);
d376 3
a378 1
      if (ctx->Color.AlphaFunc == func && ctx->Color.AlphaRefUnclamped == ref)
d383 1
a383 2
      ctx->Color.AlphaRefUnclamped = ref;
      ctx->Color.AlphaRef = CLAMP(ref, 0.0F, 1.0F);
d386 1
a386 1
         ctx->Driver.AlphaFunc(ctx, func, ctx->Color.AlphaRef);
d410 1
a410 3

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glLogicOp(%s)\n", _mesa_lookup_enum_by_nr(opcode));
d445 1
a445 1

d450 1
d458 1
d483 1
d486 1
a486 2
      _mesa_debug(ctx, "glColorMask(%d, %d, %d, %d)\n",
                  red, green, blue, alpha);
d516 1
a516 1
_mesa_ColorMaski( GLuint buf, GLboolean red, GLboolean green,
d521 1
d551 2
a552 2
void GLAPIENTRY
_mesa_ClampColor(GLenum target, GLenum clamp)
d556 2
a564 5
      if (ctx->API == API_OPENGL_CORE &&
          !ctx->Extensions.ARB_color_buffer_float) {
         goto invalid_enum;
      }
      FLUSH_VERTICES(ctx, _NEW_LIGHT);
a565 1
      _mesa_update_clamp_vertex_color(ctx);
a567 5
      if (ctx->API == API_OPENGL_CORE &&
          !ctx->Extensions.ARB_color_buffer_float) {
         goto invalid_enum;
      }
      FLUSH_VERTICES(ctx, _NEW_FRAG_CLAMP);
a568 1
      _mesa_update_clamp_fragment_color(ctx);
d574 2
a575 1
      goto invalid_enum;
a576 37
   return;

invalid_enum:
   _mesa_error(ctx, GL_INVALID_ENUM, "glClampColor(%s)",
               _mesa_lookup_enum_by_nr(target));
}

static GLboolean
get_clamp_color(const struct gl_framebuffer *fb, GLenum clamp)
{
   if (clamp == GL_TRUE || clamp == GL_FALSE)
      return clamp;

   ASSERT(clamp == GL_FIXED_ONLY);
   if (!fb)
      return GL_TRUE;

   return fb->_AllColorBuffersFixedPoint;
}

GLboolean
_mesa_get_clamp_fragment_color(const struct gl_context *ctx)
{
   return get_clamp_color(ctx->DrawBuffer,
                                ctx->Color.ClampFragmentColor);
}

GLboolean
_mesa_get_clamp_vertex_color(const struct gl_context *ctx)
{
   return get_clamp_color(ctx->DrawBuffer, ctx->Light.ClampVertexColor);
}

GLboolean
_mesa_get_clamp_read_color(const struct gl_context *ctx)
{
   return get_clamp_color(ctx->ReadBuffer, ctx->Color.ClampReadColor);
a578 18
/**
 * Update the ctx->Color._ClampFragmentColor field
 */
void
_mesa_update_clamp_fragment_color(struct gl_context *ctx)
{
   struct gl_framebuffer *fb = ctx->DrawBuffer;

   /* Don't clamp if:
    * - there is no colorbuffer
    * - all colorbuffers are unsigned normalized, so clamping has no effect
    * - there is an integer colorbuffer
    */
   if (!fb || !fb->_HasSNormOrFloatColorBuffer || fb->_IntegerColor)
      ctx->Color._ClampFragmentColor = GL_FALSE;
   else
      ctx->Color._ClampFragmentColor = _mesa_get_clamp_fragment_color(ctx);
}
a579 8
/**
 * Update the ctx->Color._ClampVertexColor field
 */
void
_mesa_update_clamp_vertex_color(struct gl_context *ctx)
{
   ctx->Light._ClampVertexColor = _mesa_get_clamp_vertex_color(ctx);
}
a580 17
/**
 * Returns an appropriate gl_format for color rendering based on the
 * GL_FRAMEBUFFER_SRGB state.
 *
 * Some drivers implement GL_FRAMEBUFFER_SRGB using a flag on the blend state
 * (which GL_FRAMEBUFFER_SRGB maps to reasonably), but some have to do so by
 * overriding the format of the surface.  This is a helper for doing the
 * surface format override variant.
 */
gl_format
_mesa_get_render_format(const struct gl_context *ctx, gl_format format)
{
   if (ctx->Color.sRGBEnabled)
      return format;
   else
      return _mesa_get_srgb_format_linear(format);
}
a595 2
   GLuint i;

d600 1
a600 1
   ASSIGN_4V( ctx->Color.ClearColor.f, 0, 0, 0, 0 );
d605 6
a610 8
   for (i = 0; i < Elements(ctx->Color.Blend); i++) {
      ctx->Color.Blend[i].SrcRGB = GL_ONE;
      ctx->Color.Blend[i].DstRGB = GL_ZERO;
      ctx->Color.Blend[i].SrcA = GL_ONE;
      ctx->Color.Blend[i].DstA = GL_ZERO;
      ctx->Color.Blend[i].EquationRGB = GL_FUNC_ADD;
      ctx->Color.Blend[i].EquationA = GL_FUNC_ADD;
   }
a611 1
   ASSIGN_4V( ctx->Color.BlendColorUnclamped, 0.0, 0.0, 0.0, 0.0 );
d614 1
d625 1
a625 3
   ctx->Color.ClampFragmentColor = ctx->API == API_OPENGL_COMPAT ?
                                   GL_FIXED_ONLY_ARB : GL_FALSE;
   ctx->Color._ClampFragmentColor = GL_FALSE;
a626 7

   if (ctx->API == API_OPENGLES2) {
      /* GLES 3 behaves as though GL_FRAMEBUFFER_SRGB is always enabled. */
      ctx->Color.sRGBEnabled = GL_TRUE;
   } else {
      ctx->Color.sRGBEnabled = GL_FALSE;
   }
@


1.1.1.5
log
@Import Mesa 10.2.3
@
text
@d857 1
a857 1
 * Returns an appropriate mesa_format for color rendering based on the
d865 2
a866 2
mesa_format
_mesa_get_render_format(const struct gl_context *ctx, mesa_format format)
d914 1
a914 3
   /* GL_FRONT is not possible on GLES. Instead GL_BACK will render to either
    * the front or the back buffer depending on the config */
   if (ctx->Visual.doubleBufferMode || _mesa_is_gles(ctx)) {
@


