head	1.11;
access;
symbols
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	v10_2_9:1.1.1.7
	v10_4_3:1.1.1.6
	v10_2_7:1.1.1.5
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	v10_2_3:1.1.1.5
	OPENBSD_5_5:1.7.0.2
	OPENBSD_5_5_BASE:1.7
	v9_2_5:1.1.1.4
	v9_2_3:1.1.1.4
	v9_2_2:1.1.1.4
	v9_2_1:1.1.1.4
	v9_2_0:1.1.1.4
	OPENBSD_5_4:1.6.0.4
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	v7_10_3:1.1.1.3
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v7_0_1:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v6_5_2:1.1.1.1
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2015.12.23.05.17.52;	author jsg;	state dead;
branches;
next	1.10;
commitid	TnlogFl9nOv2eaRf;

1.10
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.9;
commitid	4ry2gvZGMXkCUD2n;

1.9
date	2015.01.25.14.41.22;	author jsg;	state Exp;
branches;
next	1.8;
commitid	mcxB0JvoI9gTDYXU;

1.8
date	2014.07.09.21.09.00;	author jsg;	state Exp;
branches;
next	1.7;
commitid	WPD6rgPryPkvXOr9;

1.7
date	2013.09.05.14.06.23;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2012.08.17.13.58.19;	author mpi;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.23.13.37.42;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.31;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.41;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.21;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.50.09;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.50.09;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.31.11;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.10.23.13.29.46;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.09.05.13.16.40;	author jsg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2014.07.09.20.35.02;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.6
date	2015.01.25.14.12.44;	author jsg;	state Exp;
branches;
next	1.1.1.7;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.7
date	2015.02.20.22.49.51;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.11
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**
 * \file imports.c
 * Standard C library function wrappers.
 * 
 * Imports are services which the device driver or window system or
 * operating system provides to the core renderer.  The core renderer (Mesa)
 * will call these functions in order to do memory allocation, simple I/O,
 * etc.
 *
 * Some drivers will want to override/replace this file with something
 * specialized, but that'll be rare.
 *
 * Eventually, I want to move roll the glheader.h file into this.
 *
 * \todo Functions still needed:
 * - scanf
 * - qsort
 * - rand and RAND_MAX
 */

/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */



#include "imports.h"
#include "context.h"
#include "mtypes.h"
#include "version.h"

#ifdef _GNU_SOURCE
#include <locale.h>
#ifdef __APPLE__
#include <xlocale.h>
#endif
#endif


#ifdef _WIN32
#define vsnprintf _vsnprintf
#elif defined(__IBMC__) || defined(__IBMCPP__)
extern int vsnprintf(char *str, size_t count, const char *fmt, va_list arg);
#endif

/**********************************************************************/
/** \name Memory */
/*@@{*/

/**
 * Allocate aligned memory.
 *
 * \param bytes number of bytes to allocate.
 * \param alignment alignment (must be greater than zero).
 * 
 * Allocates extra memory to accommodate rounding up the address for
 * alignment and to record the real malloc address.
 *
 * \sa _mesa_align_free().
 */
void *
_mesa_align_malloc(size_t bytes, unsigned long alignment)
{
#if defined(HAVE_POSIX_MEMALIGN)
   void *mem;
   int err = posix_memalign(& mem, alignment, bytes);
   if (err)
      return NULL;
   return mem;
#elif defined(_WIN32) && defined(_MSC_VER)
   return _aligned_malloc(bytes, alignment);
#else
   uintptr_t ptr, buf;

   ASSERT( alignment > 0 );

   ptr = (uintptr_t)malloc(bytes + alignment + sizeof(void *));
   if (!ptr)
      return NULL;

   buf = (ptr + alignment + sizeof(void *)) & ~(uintptr_t)(alignment - 1);
   *(uintptr_t *)(buf - sizeof(void *)) = ptr;

#ifdef DEBUG
   /* mark the non-aligned area */
   while ( ptr < buf - sizeof(void *) ) {
      *(unsigned long *)ptr = 0xcdcdcdcd;
      ptr += sizeof(unsigned long);
   }
#endif

   return (void *) buf;
#endif /* defined(HAVE_POSIX_MEMALIGN) */
}

/**
 * Same as _mesa_align_malloc(), but using calloc(1, ) instead of
 * malloc()
 */
void *
_mesa_align_calloc(size_t bytes, unsigned long alignment)
{
#if defined(HAVE_POSIX_MEMALIGN)
   void *mem;
   
   mem = _mesa_align_malloc(bytes, alignment);
   if (mem != NULL) {
      (void) memset(mem, 0, bytes);
   }

   return mem;
#elif defined(_WIN32) && defined(_MSC_VER)
   void *mem;

   mem = _aligned_malloc(bytes, alignment);
   if (mem != NULL) {
      (void) memset(mem, 0, bytes);
   }

   return mem;
#else
   uintptr_t ptr, buf;

   ASSERT( alignment > 0 );

   ptr = (uintptr_t)calloc(1, bytes + alignment + sizeof(void *));
   if (!ptr)
      return NULL;

   buf = (ptr + alignment + sizeof(void *)) & ~(uintptr_t)(alignment - 1);
   *(uintptr_t *)(buf - sizeof(void *)) = ptr;

#ifdef DEBUG
   /* mark the non-aligned area */
   while ( ptr < buf - sizeof(void *) ) {
      *(unsigned long *)ptr = 0xcdcdcdcd;
      ptr += sizeof(unsigned long);
   }
#endif

   return (void *)buf;
#endif /* defined(HAVE_POSIX_MEMALIGN) */
}

/**
 * Free memory which was allocated with either _mesa_align_malloc()
 * or _mesa_align_calloc().
 * \param ptr pointer to the memory to be freed.
 * The actual address to free is stored in the word immediately before the
 * address the client sees.
 * Note that it is legal to pass NULL pointer to this function and will be
 * handled accordingly.
 */
void
_mesa_align_free(void *ptr)
{
#if defined(HAVE_POSIX_MEMALIGN)
   free(ptr);
#elif defined(_WIN32) && defined(_MSC_VER)
   _aligned_free(ptr);
#else
   if (ptr) {
      void **cubbyHole = (void **) ((char *) ptr - sizeof(void *));
      void *realAddr = *cubbyHole;
      free(realAddr);
   }
#endif /* defined(HAVE_POSIX_MEMALIGN) */
}

/**
 * Reallocate memory, with alignment.
 */
void *
_mesa_align_realloc(void *oldBuffer, size_t oldSize, size_t newSize,
                    unsigned long alignment)
{
#if defined(_WIN32) && defined(_MSC_VER)
   (void) oldSize;
   return _aligned_realloc(oldBuffer, newSize, alignment);
#else
   const size_t copySize = (oldSize < newSize) ? oldSize : newSize;
   void *newBuf = _mesa_align_malloc(newSize, alignment);
   if (newBuf && oldBuffer && copySize > 0) {
      memcpy(newBuf, oldBuffer, copySize);
   }

   _mesa_align_free(oldBuffer);
   return newBuf;
#endif
}



/** Reallocate memory */
void *
_mesa_realloc(void *oldBuffer, size_t oldSize, size_t newSize)
{
   const size_t copySize = (oldSize < newSize) ? oldSize : newSize;
   void *newBuffer = malloc(newSize);
   if (newBuffer && oldBuffer && copySize > 0)
      memcpy(newBuffer, oldBuffer, copySize);
   free(oldBuffer);
   return newBuffer;
}

/*@@}*/


/**********************************************************************/
/** \name Math */
/*@@{*/


#ifndef __GNUC__
/**
 * Find the first bit set in a word.
 */
int
ffs(int i)
{
   register int bit = 0;
   if (i != 0) {
      if ((i & 0xffff) == 0) {
         bit += 16;
         i >>= 16;
      }
      if ((i & 0xff) == 0) {
         bit += 8;
         i >>= 8;
      }
      if ((i & 0xf) == 0) {
         bit += 4;
         i >>= 4;
      }
      while ((i & 1) == 0) {
         bit++;
         i >>= 1;
      }
      bit++;
   }
   return bit;
}


/**
 * Find position of first bit set in given value.
 * XXX Warning: this function can only be used on 64-bit systems!
 * \return  position of least-significant bit set, starting at 1, return zero
 *          if no bits set.
 */
int
ffsll(long long int val)
{
   int bit;

   assert(sizeof(val) == 8);

   bit = ffs((int) val);
   if (bit != 0)
      return bit;

   bit = ffs((int) (val >> 32));
   if (bit != 0)
      return 32 + bit;

   return 0;
}
#endif /* __GNUC__ */


#if !defined(__GNUC__) ||\
   ((__GNUC__ * 100 + __GNUC_MINOR__) < 304) /* Not gcc 3.4 or later */
/**
 * Return number of bits set in given GLuint.
 */
unsigned int
_mesa_bitcount(unsigned int n)
{
   unsigned int bits;
   for (bits = 0; n > 0; n = n >> 1) {
      bits += (n & 1);
   }
   return bits;
}

/**
 * Return number of bits set in given 64-bit uint.
 */
unsigned int
_mesa_bitcount_64(uint64_t n)
{
   unsigned int bits;
   for (bits = 0; n > 0; n = n >> 1) {
      bits += (n & 1);
   }
   return bits;
}
#endif


/* Using C99 rounding functions for roundToEven() implementation is
 * difficult, because round(), rint, and nearbyint() are affected by
 * fesetenv(), which the application may have done for its own
 * purposes.  Mesa's IROUND macro is close to what we want, but it
 * rounds away from 0 on n + 0.5.
 */
int
_mesa_round_to_even(float val)
{
   int rounded = IROUND(val);

   if (val - floor(val) == 0.5) {
      if (rounded % 2 != 0)
         rounded += val > 0 ? -1 : 1;
   }

   return rounded;
}


/**
 * Convert a 4-byte float to a 2-byte half float.
 *
 * Not all float32 values can be represented exactly as a float16 value. We
 * round such intermediate float32 values to the nearest float16. When the
 * float32 lies exactly between to float16 values, we round to the one with
 * an even mantissa.
 *
 * This rounding behavior has several benefits:
 *   - It has no sign bias.
 *
 *   - It reproduces the behavior of real hardware: opcode F32TO16 in Intel's
 *     GPU ISA.
 *
 *   - By reproducing the behavior of the GPU (at least on Intel hardware),
 *     compile-time evaluation of constant packHalf2x16 GLSL expressions will
 *     result in the same value as if the expression were executed on the GPU.
 */
GLhalfARB
_mesa_float_to_half(float val)
{
   const fi_type fi = {val};
   const int flt_m = fi.i & 0x7fffff;
   const int flt_e = (fi.i >> 23) & 0xff;
   const int flt_s = (fi.i >> 31) & 0x1;
   int s, e, m = 0;
   GLhalfARB result;
   
   /* sign bit */
   s = flt_s;

   /* handle special cases */
   if ((flt_e == 0) && (flt_m == 0)) {
      /* zero */
      /* m = 0; - already set */
      e = 0;
   }
   else if ((flt_e == 0) && (flt_m != 0)) {
      /* denorm -- denorm float maps to 0 half */
      /* m = 0; - already set */
      e = 0;
   }
   else if ((flt_e == 0xff) && (flt_m == 0)) {
      /* infinity */
      /* m = 0; - already set */
      e = 31;
   }
   else if ((flt_e == 0xff) && (flt_m != 0)) {
      /* NaN */
      m = 1;
      e = 31;
   }
   else {
      /* regular number */
      const int new_exp = flt_e - 127;
      if (new_exp < -14) {
         /* The float32 lies in the range (0.0, min_normal16) and is rounded
          * to a nearby float16 value. The result will be either zero, subnormal,
          * or normal.
          */
         e = 0;
         m = _mesa_round_to_even((1 << 24) * fabsf(fi.f));
      }
      else if (new_exp > 15) {
         /* map this value to infinity */
         /* m = 0; - already set */
         e = 31;
      }
      else {
         /* The float32 lies in the range
          *   [min_normal16, max_normal16 + max_step16)
          * and is rounded to a nearby float16 value. The result will be
          * either normal or infinite.
          */
         e = new_exp + 15;
         m = _mesa_round_to_even(flt_m / (float) (1 << 13));
      }
   }

   assert(0 <= m && m <= 1024);
   if (m == 1024) {
      /* The float32 was rounded upwards into the range of the next exponent,
       * so bump the exponent. This correctly handles the case where f32
       * should be rounded up to float16 infinity.
       */
      ++e;
      m = 0;
   }

   result = (s << 15) | (e << 10) | m;
   return result;
}


/**
 * Convert a 2-byte half float to a 4-byte float.
 * Based on code from:
 * http://www.opengl.org/discussion_boards/ubb/Forum3/HTML/008786.html
 */
float
_mesa_half_to_float(GLhalfARB val)
{
   /* XXX could also use a 64K-entry lookup table */
   const int m = val & 0x3ff;
   const int e = (val >> 10) & 0x1f;
   const int s = (val >> 15) & 0x1;
   int flt_m, flt_e, flt_s;
   fi_type fi;
   float result;

   /* sign bit */
   flt_s = s;

   /* handle special cases */
   if ((e == 0) && (m == 0)) {
      /* zero */
      flt_m = 0;
      flt_e = 0;
   }
   else if ((e == 0) && (m != 0)) {
      /* denorm -- denorm half will fit in non-denorm single */
      const float half_denorm = 1.0f / 16384.0f; /* 2^-14 */
      float mantissa = ((float) (m)) / 1024.0f;
      float sign = s ? -1.0f : 1.0f;
      return sign * mantissa * half_denorm;
   }
   else if ((e == 31) && (m == 0)) {
      /* infinity */
      flt_e = 0xff;
      flt_m = 0;
   }
   else if ((e == 31) && (m != 0)) {
      /* NaN */
      flt_e = 0xff;
      flt_m = 1;
   }
   else {
      /* regular */
      flt_e = e + 112;
      flt_m = m << 13;
   }

   fi.i = (flt_s << 31) | (flt_e << 23) | flt_m;
   result = fi.f;
   return result;
}

/*@@}*/


/**********************************************************************/
/** \name Sort & Search */
/*@@{*/

/**
 * Wrapper for bsearch().
 */
void *
_mesa_bsearch( const void *key, const void *base, size_t nmemb, size_t size, 
               int (*compar)(const void *, const void *) )
{
#if defined(_WIN32_WCE)
   void *mid;
   int cmp;
   while (nmemb) {
      nmemb >>= 1;
      mid = (char *)base + nmemb * size;
      cmp = (*compar)(key, mid);
      if (cmp == 0)
	 return mid;
      if (cmp > 0) {
	 base = (char *)mid + size;
	 --nmemb;
      }
   }
   return NULL;
#else
   return bsearch(key, base, nmemb, size, compar);
#endif
}

/*@@}*/


/**********************************************************************/
/** \name Environment vars */
/*@@{*/

/**
 * Wrapper for getenv().
 */
char *
_mesa_getenv( const char *var )
{
#if defined(_XBOX) || defined(_WIN32_WCE)
   return NULL;
#else
   return getenv(var);
#endif
}

/*@@}*/


/**********************************************************************/
/** \name String */
/*@@{*/

/**
 * Implemented using malloc() and strcpy.
 * Note that NULL is handled accordingly.
 */
char *
_mesa_strdup( const char *s )
{
   if (s) {
      size_t l = strlen(s);
      char *s2 = malloc(l + 1);
      if (s2)
         strcpy(s2, s);
      return s2;
   }
   else {
      return NULL;
   }
}

/** Wrapper around strtof() */
float
_mesa_strtof( const char *s, char **end )
{
#if defined(_GNU_SOURCE) && !defined(__CYGWIN__) && !defined(__FreeBSD__) && \
   !defined(ANDROID) && !defined(__HAIKU__) && !defined(__UCLIBC__) && \
   !defined(__NetBSD__)
   static locale_t loc = NULL;
   if (!loc) {
      loc = newlocale(LC_CTYPE_MASK, "C", NULL);
   }
   return strtof_l(s, end, loc);
#elif defined(_ISOC99_SOURCE) || (defined(_XOPEN_SOURCE) && _XOPEN_SOURCE >= 600)
   return strtof(s, end);
#else
   return (float)strtod(s, end);
#endif
}

/** Compute simple checksum/hash for a string */
unsigned int
_mesa_str_checksum(const char *str)
{
   /* This could probably be much better */
   unsigned int sum, i;
   const char *c;
   sum = i = 1;
   for (c = str; *c; c++, i++)
      sum += *c * (i % 100);
   return sum + i;
}


/*@@}*/


/** Needed due to #ifdef's, above. */
int
_mesa_vsnprintf(char *str, size_t size, const char *fmt, va_list args)
{
   return vsnprintf( str, size, fmt, args);
}

/** Wrapper around vsnprintf() */
int
_mesa_snprintf( char *str, size_t size, const char *fmt, ... )
{
   int r;
   va_list args;
   va_start( args, fmt );  
   r = vsnprintf( str, size, fmt, args );
   va_end( args );
   return r;
}


@


1.10
log
@Merge Mesa 10.2.9
@
text
@@


1.9
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d212 14
d234 1
a234 1
#ifndef HAVE___BUILTIN_FFS
a262 1
#endif
d264 1
a264 1
#ifndef HAVE___BUILTIN_FFSLL
d288 1
a288 1
#endif
d291 2
a292 1
#ifndef HAVE___BUILTIN_POPCOUNT
a304 1
#endif
a305 1
#ifndef HAVE___BUILTIN_POPCOUNTLL
d492 54
d566 19
@


1.8
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@a211 14


/** Reallocate memory */
void *
_mesa_realloc(void *oldBuffer, size_t oldSize, size_t newSize)
{
   const size_t copySize = (oldSize < newSize) ? oldSize : newSize;
   void *newBuffer = malloc(newSize);
   if (newBuffer && oldBuffer && copySize > 0)
      memcpy(newBuffer, oldBuffer, copySize);
   free(oldBuffer);
   return newBuffer;
}

d220 1
a220 1
#ifndef __GNUC__
d249 1
d251 1
a251 1

d275 1
a275 1
#endif /* __GNUC__ */
d278 1
a278 2
#if !defined(__GNUC__) ||\
   ((__GNUC__ * 100 + __GNUC_MINOR__) < 304) /* Not gcc 3.4 or later */
d291 1
d293 1
a479 54
/** \name Sort & Search */
/*@@{*/

/**
 * Wrapper for bsearch().
 */
void *
_mesa_bsearch( const void *key, const void *base, size_t nmemb, size_t size, 
               int (*compar)(const void *, const void *) )
{
#if defined(_WIN32_WCE)
   void *mid;
   int cmp;
   while (nmemb) {
      nmemb >>= 1;
      mid = (char *)base + nmemb * size;
      cmp = (*compar)(key, mid);
      if (cmp == 0)
	 return mid;
      if (cmp > 0) {
	 base = (char *)mid + size;
	 --nmemb;
      }
   }
   return NULL;
#else
   return bsearch(key, base, nmemb, size, compar);
#endif
}

/*@@}*/


/**********************************************************************/
/** \name Environment vars */
/*@@{*/

/**
 * Wrapper for getenv().
 */
char *
_mesa_getenv( const char *var )
{
#if defined(_XBOX) || defined(_WIN32_WCE)
   return NULL;
#else
   return getenv(var);
#endif
}

/*@@}*/


/**********************************************************************/
a499 19
}

/** Wrapper around strtof() */
float
_mesa_strtof( const char *s, char **end )
{
#if defined(_GNU_SOURCE) && !defined(__CYGWIN__) && !defined(__FreeBSD__) && \
   !defined(ANDROID) && !defined(__HAIKU__) && !defined(__UCLIBC__) && \
   !defined(__NetBSD__)
   static locale_t loc = NULL;
   if (!loc) {
      loc = newlocale(LC_CTYPE_MASK, "C", NULL);
   }
   return strtof_l(s, end, loc);
#elif defined(_ISOC99_SOURCE) || (defined(_XOPEN_SOURCE) && _XOPEN_SOURCE >= 600)
   return strtof(s, end);
#else
   return (float)strtod(s, end);
#endif
@


1.7
log
@Merge Mesa 9.2.0
@
text
@d171 2
d182 5
a186 3
   void **cubbyHole = (void **) ((char *) ptr - sizeof(void *));
   void *realAddr = *cubbyHole;
   free(realAddr);
d206 2
a207 2
   if (oldBuffer)
      _mesa_align_free(oldBuffer);
d573 2
a574 1
   !defined(ANDROID) && !defined(__HAIKU__) && !defined(__UCLIBC__)
@


1.6
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a22 1
 * Version:  7.1
d39 4
a42 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
d60 1
a60 3
#define MAXSTRING 4000  /* for vsnprintf() */

#ifdef WIN32
d62 1
a62 1
#elif defined(__IBMC__) || defined(__IBMCPP__) || ( defined(__VMS) && __CRTL_VER < 70312000 )
a63 3
#ifdef __VMS
#include "vsnprintf.c"
#endif
d97 1
a97 1
   ptr = (uintptr_t) malloc(bytes + alignment + sizeof(void *));
d146 1
a146 1
   ptr = (uintptr_t) calloc(1, bytes + alignment + sizeof(void *));
d218 1
a218 2
   if (oldBuffer)
      free(oldBuffer);
a221 13
/**
 * Fill memory with a constant 16bit word.
 * \param dst destination pointer.
 * \param val value.
 * \param n number of words.
 */
void
_mesa_memset16( unsigned short *dst, unsigned short val, size_t n )
{
   while (n-- > 0)
      *dst++ = val;
}

a228 207
/** Wrapper around sqrt() */
double
_mesa_sqrtd(double x)
{
   return sqrt(x);
}


/*
 * A High Speed, Low Precision Square Root
 * by Paul Lalonde and Robert Dawson
 * from "Graphics Gems", Academic Press, 1990
 *
 * SPARC implementation of a fast square root by table
 * lookup.
 * SPARC floating point format is as follows:
 *
 * BIT 31 	30 	23 	22 	0
 *     sign	exponent	mantissa
 */
static short sqrttab[0x100];    /* declare table of square roots */

void
_mesa_init_sqrt_table(void)
{
#if defined(USE_IEEE) && !defined(DEBUG)
   unsigned short i;
   fi_type fi;     /* to access the bits of a float in  C quickly  */
                   /* we use a union defined in glheader.h         */

   for(i=0; i<= 0x7f; i++) {
      fi.i = 0;

      /*
       * Build a float with the bit pattern i as mantissa
       * and an exponent of 0, stored as 127
       */

      fi.i = (i << 16) | (127 << 23);
      fi.f = _mesa_sqrtd(fi.f);

      /*
       * Take the square root then strip the first 7 bits of
       * the mantissa into the table
       */

      sqrttab[i] = (fi.i & 0x7fffff) >> 16;

      /*
       * Repeat the process, this time with an exponent of
       * 1, stored as 128
       */

      fi.i = 0;
      fi.i = (i << 16) | (128 << 23);
      fi.f = sqrt(fi.f);
      sqrttab[i+0x80] = (fi.i & 0x7fffff) >> 16;
   }
#else
   (void) sqrttab;  /* silence compiler warnings */
#endif /*HAVE_FAST_MATH*/
}


/**
 * Single precision square root.
 */
float
_mesa_sqrtf( float x )
{
#if defined(USE_IEEE) && !defined(DEBUG)
   fi_type num;
                                /* to access the bits of a float in C
                                 * we use a union from glheader.h     */

   short e;                     /* the exponent */
   if (x == 0.0F) return 0.0F;  /* check for square root of 0 */
   num.f = x;
   e = (num.i >> 23) - 127;     /* get the exponent - on a SPARC the */
                                /* exponent is stored with 127 added */
   num.i &= 0x7fffff;           /* leave only the mantissa */
   if (e & 0x01) num.i |= 0x800000;
                                /* the exponent is odd so we have to */
                                /* look it up in the second half of  */
                                /* the lookup table, so we set the   */
                                /* high bit                                */
   e >>= 1;                     /* divide the exponent by two */
                                /* note that in C the shift */
                                /* operators are sign preserving */
                                /* for signed operands */
   /* Do the table lookup, based on the quaternary mantissa,
    * then reconstruct the result back into a float
    */
   num.i = ((sqrttab[num.i >> 16]) << 16) | ((e + 127) << 23);

   return num.f;
#else
   return (float) _mesa_sqrtd((double) x);
#endif
}


/**
 inv_sqrt - A single precision 1/sqrt routine for IEEE format floats.
 written by Josh Vanderhoof, based on newsgroup posts by James Van Buskirk
 and Vesa Karvonen.
*/
float
_mesa_inv_sqrtf(float n)
{
#if defined(USE_IEEE) && !defined(DEBUG)
        float r0, x0, y0;
        float r1, x1, y1;
        float r2, x2, y2;
#if 0 /* not used, see below -BP */
        float r3, x3, y3;
#endif
        fi_type u;
        unsigned int magic;

        /*
         Exponent part of the magic number -

         We want to:
         1. subtract the bias from the exponent,
         2. negate it
         3. divide by two (rounding towards -inf)
         4. add the bias back

         Which is the same as subtracting the exponent from 381 and dividing
         by 2.

         floor(-(x - 127) / 2) + 127 = floor((381 - x) / 2)
        */

        magic = 381 << 23;

        /*
         Significand part of magic number -

         With the current magic number, "(magic - u.i) >> 1" will give you:

         for 1 <= u.f <= 2: 1.25 - u.f / 4
         for 2 <= u.f <= 4: 1.00 - u.f / 8

         This isn't a bad approximation of 1/sqrt.  The maximum difference from
         1/sqrt will be around .06.  After three Newton-Raphson iterations, the
         maximum difference is less than 4.5e-8.  (Which is actually close
         enough to make the following bias academic...)

         To get a better approximation you can add a bias to the magic
         number.  For example, if you subtract 1/2 of the maximum difference in
         the first approximation (.03), you will get the following function:

         for 1 <= u.f <= 2:    1.22 - u.f / 4
         for 2 <= u.f <= 3.76: 0.97 - u.f / 8
         for 3.76 <= u.f <= 4: 0.72 - u.f / 16
         (The 3.76 to 4 range is where the result is < .5.)

         This is the closest possible initial approximation, but with a maximum
         error of 8e-11 after three NR iterations, it is still not perfect.  If
         you subtract 0.0332281 instead of .03, the maximum error will be
         2.5e-11 after three NR iterations, which should be about as close as
         is possible.

         for 1 <= u.f <= 2:    1.2167719 - u.f / 4
         for 2 <= u.f <= 3.73: 0.9667719 - u.f / 8
         for 3.73 <= u.f <= 4: 0.7167719 - u.f / 16

        */

        magic -= (int)(0.0332281 * (1 << 25));

        u.f = n;
        u.i = (magic - u.i) >> 1;

        /*
         Instead of Newton-Raphson, we use Goldschmidt's algorithm, which
         allows more parallelism.  From what I understand, the parallelism
         comes at the cost of less precision, because it lets error
         accumulate across iterations.
        */
        x0 = 1.0f;
        y0 = 0.5f * n;
        r0 = u.f;

        x1 = x0 * r0;
        y1 = y0 * r0 * r0;
        r1 = 1.5f - y1;

        x2 = x1 * r1;
        y2 = y1 * r1 * r1;
        r2 = 1.5f - y2;

#if 1
        return x2 * r2;  /* we can stop here, and be conformant -BP */
#else
        x3 = x2 * r2;
        y3 = y2 * r2 * r2;
        r3 = 1.5f - y3;

        return x3 * r3;
#endif
#else
        return (float) (1.0 / sqrt(n));
#endif
}
d235 1
a235 1
_mesa_ffs(int32_t i)
a236 1
#if (defined(_WIN32) ) || defined(__IBMC__) || defined(__IBMCPP__)
a257 3
#else
   return ffs(i);
#endif
d268 1
a268 1
_mesa_ffsll(int64_t val)
d274 1
a274 1
   bit = _mesa_ffs((int32_t)val);
d278 1
a278 1
   bit = _mesa_ffs((int32_t)(val >> 32));
d284 2
a285 1
#endif
d288 1
a288 1
   ((_GNUC__ == 3 && __GNUC_MINOR__ < 4) && __GNUC__ < 4)
d301 13
d317 20
d339 15
a353 2
 * Based on code from:
 * http://www.opengl.org/discussion_boards/ubb/Forum3/HTML/008786.html
d392 5
a396 8
      if (new_exp < -24) {
         /* this maps to 0 */
         /* m = 0; - already set */
         e = 0;
      }
      else if (new_exp < -14) {
         /* this maps to a denorm */
         unsigned int exp_val = (unsigned int) (-14 - new_exp); /* 2^-exp_val*/
d398 1
a398 17
         switch (exp_val) {
            case 0:
               _mesa_warning(NULL,
                   "float_to_half: logical error in denorm creation!\n");
               /* m = 0; - already set */
               break;
            case 1: m = 512 + (flt_m >> 14); break;
            case 2: m = 256 + (flt_m >> 15); break;
            case 3: m = 128 + (flt_m >> 16); break;
            case 4: m = 64 + (flt_m >> 17); break;
            case 5: m = 32 + (flt_m >> 18); break;
            case 6: m = 16 + (flt_m >> 19); break;
            case 7: m = 8 + (flt_m >> 20); break;
            case 8: m = 4 + (flt_m >> 21); break;
            case 9: m = 2 + (flt_m >> 22); break;
            case 10: m = 1; break;
         }
d406 5
a410 1
         /* regular */
d412 1
a412 1
         m = flt_m >> 13;
d416 10
d554 1
a554 1
      char *s2 = (char *) malloc(l + 1);
d568 2
a569 1
#if defined(_GNU_SOURCE) && !defined(__CYGWIN__) && !defined(__FreeBSD__)
d599 7
a618 236
/**********************************************************************/
/** \name Diagnostics */
/*@@{*/

static void
output_if_debug(const char *prefixString, const char *outputString,
                GLboolean newline)
{
   static int debug = -1;

   /* Check the MESA_DEBUG environment variable if it hasn't
    * been checked yet.  We only have to check it once...
    */
   if (debug == -1) {
      char *env = _mesa_getenv("MESA_DEBUG");

      /* In a debug build, we print warning messages *unless*
       * MESA_DEBUG is 0.  In a non-debug build, we don't
       * print warning messages *unless* MESA_DEBUG is
       * set *to any value*.
       */
#ifdef DEBUG
      debug = (env != NULL && atoi(env) == 0) ? 0 : 1;
#else
      debug = (env != NULL) ? 1 : 0;
#endif
   }

   /* Now only print the string if we're required to do so. */
   if (debug) {
      fprintf(stderr, "%s: %s", prefixString, outputString);
      if (newline)
         fprintf(stderr, "\n");

#if defined(_WIN32) && !defined(_WIN32_WCE)
      /* stderr from windows applications without console is not usually 
       * visible, so communicate with the debugger instead */ 
      {
         char buf[4096];
         _mesa_snprintf(buf, sizeof(buf), "%s: %s%s", prefixString, outputString, newline ? "\n" : "");
         OutputDebugStringA(buf);
      }
#endif
   }
}


/**
 * Return string version of GL error code.
 */
static const char *
error_string( GLenum error )
{
   switch (error) {
   case GL_NO_ERROR:
      return "GL_NO_ERROR";
   case GL_INVALID_VALUE:
      return "GL_INVALID_VALUE";
   case GL_INVALID_ENUM:
      return "GL_INVALID_ENUM";
   case GL_INVALID_OPERATION:
      return "GL_INVALID_OPERATION";
   case GL_STACK_OVERFLOW:
      return "GL_STACK_OVERFLOW";
   case GL_STACK_UNDERFLOW:
      return "GL_STACK_UNDERFLOW";
   case GL_OUT_OF_MEMORY:
      return "GL_OUT_OF_MEMORY";
   case GL_TABLE_TOO_LARGE:
      return "GL_TABLE_TOO_LARGE";
   case GL_INVALID_FRAMEBUFFER_OPERATION_EXT:
      return "GL_INVALID_FRAMEBUFFER_OPERATION";
   default:
      return "unknown";
   }
}


/**
 * When a new type of error is recorded, print a message describing
 * previous errors which were accumulated.
 */
static void
flush_delayed_errors( struct gl_context *ctx )
{
   char s[MAXSTRING];

   if (ctx->ErrorDebugCount) {
      _mesa_snprintf(s, MAXSTRING, "%d similar %s errors", 
                     ctx->ErrorDebugCount,
                     error_string(ctx->ErrorValue));

      output_if_debug("Mesa", s, GL_TRUE);

      ctx->ErrorDebugCount = 0;
   }
}


/**
 * Report a warning (a recoverable error condition) to stderr if
 * either DEBUG is defined or the MESA_DEBUG env var is set.
 *
 * \param ctx GL context.
 * \param fmtString printf()-like format string.
 */
void
_mesa_warning( struct gl_context *ctx, const char *fmtString, ... )
{
   char str[MAXSTRING];
   va_list args;
   va_start( args, fmtString );  
   (void) vsnprintf( str, MAXSTRING, fmtString, args );
   va_end( args );
   
   if (ctx)
      flush_delayed_errors( ctx );

   output_if_debug("Mesa warning", str, GL_TRUE);
}


/**
 * Report an internal implementation problem.
 * Prints the message to stderr via fprintf().
 *
 * \param ctx GL context.
 * \param fmtString problem description string.
 */
void
_mesa_problem( const struct gl_context *ctx, const char *fmtString, ... )
{
   va_list args;
   char str[MAXSTRING];
   static int numCalls = 0;

   (void) ctx;

   if (numCalls < 50) {
      numCalls++;

      va_start( args, fmtString );  
      vsnprintf( str, MAXSTRING, fmtString, args );
      va_end( args );
      fprintf(stderr, "Mesa %s implementation error: %s\n",
              MESA_VERSION_STRING, str);
      fprintf(stderr, "Please report at bugs.freedesktop.org\n");
   }
}


/**
 * Record an OpenGL state error.  These usually occur when the user
 * passes invalid parameters to a GL function.
 *
 * If debugging is enabled (either at compile-time via the DEBUG macro, or
 * run-time via the MESA_DEBUG environment variable), report the error with
 * _mesa_debug().
 * 
 * \param ctx the GL context.
 * \param error the error value.
 * \param fmtString printf() style format string, followed by optional args
 */
void
_mesa_error( struct gl_context *ctx, GLenum error, const char *fmtString, ... )
{
   static GLint debug = -1;

   /* Check debug environment variable only once:
    */
   if (debug == -1) {
      const char *debugEnv = _mesa_getenv("MESA_DEBUG");

#ifdef DEBUG
      if (debugEnv && strstr(debugEnv, "silent"))
         debug = GL_FALSE;
      else
         debug = GL_TRUE;
#else
      if (debugEnv)
         debug = GL_TRUE;
      else
         debug = GL_FALSE;
#endif
   }

   if (debug) {      
      if (ctx->ErrorValue == error &&
          ctx->ErrorDebugFmtString == fmtString) {
         ctx->ErrorDebugCount++;
      }
      else {
         char s[MAXSTRING], s2[MAXSTRING];
         va_list args;

         flush_delayed_errors( ctx );
         
         va_start(args, fmtString);
         vsnprintf(s, MAXSTRING, fmtString, args);
         va_end(args);

         _mesa_snprintf(s2, MAXSTRING, "%s in %s", error_string(error), s);
         output_if_debug("Mesa: User error", s2, GL_TRUE);
         
         ctx->ErrorDebugFmtString = fmtString;
         ctx->ErrorDebugCount = 0;
      }
   }

   _mesa_record_error(ctx, error);
}


/**
 * Report debug information.  Print error message to stderr via fprintf().
 * No-op if DEBUG mode not enabled.
 * 
 * \param ctx GL context.
 * \param fmtString printf()-style format string, followed by optional args.
 */
void
_mesa_debug( const struct gl_context *ctx, const char *fmtString, ... )
{
#ifdef DEBUG
   char s[MAXSTRING];
   va_list args;
   va_start(args, fmtString);
   vsnprintf(s, MAXSTRING, fmtString, args);
   va_end(args);
   output_if_debug("Mesa", s, GL_FALSE);
#endif /* DEBUG */
   (void) ctx;
   (void) fmtString;
}

/*@@}*/
@


1.5
log
@Merge Mesa 7.10.3
@
text
@d49 1
d456 1
a499 3
#ifdef ffsll
   return ffsll(val);
#else
d513 1
a514 2
}

d516 2
a523 4
#if defined(__GNUC__) && \
	((_GNUC__ == 3 && __GNUC_MINOR__ >= 4) || __GNUC__ >= 4)
   return __builtin_popcount(n);
#else
d529 1
a530 1
}
d933 2
d937 2
a938 3
   va_start( args, fmtString );  
   vsnprintf( str, MAXSTRING, fmtString, args );
   va_end( args );
d940 7
a946 2
   fprintf(stderr, "Mesa %s implementation error: %s\n", MESA_VERSION_STRING, str);
   fprintf(stderr, "Please report at bugs.freedesktop.org\n");
@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d91 2
a92 1
   (void) err;
a246 35
/** Wrapper around sin() */
double
_mesa_sin(double a)
{
   return sin(a);
}

/** Single precision wrapper around sin() */
float
_mesa_sinf(float a)
{
   return (float) sin((double) a);
}

/** Wrapper around cos() */
double
_mesa_cos(double a)
{
   return cos(a);
}

/** Single precision wrapper around asin() */
float
_mesa_asinf(float x)
{
   return (float) asin((double) x);
}

/** Single precision wrapper around atan() */
float
_mesa_atanf(float x)
{
   return (float) atan((double) x);
}

a454 9

/** Wrapper around pow() */
double
_mesa_pow(double x, double y)
{
   return pow(x, y);
}


d760 1
a760 1
#ifdef _GNU_SOURCE
d886 1
a886 1
flush_delayed_errors( GLcontext *ctx )
d910 1
a910 1
_mesa_warning( GLcontext *ctx, const char *fmtString, ... )
d933 1
a933 1
_mesa_problem( const GLcontext *ctx, const char *fmtString, ... )
d944 1
a944 1
   fprintf(stderr, "Please report at bugzilla.freedesktop.org\n");
d961 1
a961 1
_mesa_error( GLcontext *ctx, GLenum error, const char *fmtString, ... )
d1018 1
a1018 1
_mesa_debug( const GLcontext *ctx, const char *fmtString, ... )
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d51 7
a73 21
/** Wrapper around malloc() */
void *
_mesa_malloc(size_t bytes)
{
   return malloc(bytes);
}

/** Wrapper around calloc() */
void *
_mesa_calloc(size_t bytes)
{
   return calloc(1, bytes);
}

/** Wrapper around free() */
void
_mesa_free(void *ptr)
{
   free(ptr);
}

d90 2
a91 2

   (void) posix_memalign(& mem, alignment, bytes);
d100 1
a100 1
   ptr = (uintptr_t) _mesa_malloc(bytes + alignment + sizeof(void *));
d120 2
a121 2
 * Same as _mesa_align_malloc(), but using _mesa_calloc() instead of
 * _mesa_malloc()
d149 1
a149 1
   ptr = (uintptr_t) _mesa_calloc(bytes + alignment + sizeof(void *));
d185 1
a185 1
   _mesa_free(realAddr);
d203 1
a203 1
      _mesa_memcpy(newBuf, oldBuffer, copySize);
d218 1
a218 1
   void *newBuffer = _mesa_malloc(newSize);
d220 1
a220 1
      _mesa_memcpy(newBuffer, oldBuffer, copySize);
d222 1
a222 1
      _mesa_free(oldBuffer);
a225 22
/** memcpy wrapper */
void *
_mesa_memcpy(void *dest, const void *src, size_t n)
{
#if defined(SUNOS4)
   return memcpy((char *) dest, (char *) src, (int) n);
#else
   return memcpy(dest, src, n);
#endif
}

/** Wrapper around memset() */
void
_mesa_memset( void *dst, int val, size_t n )
{
#if defined(SUNOS4)
   memset( (char *) dst, (int) val, (int) n );
#else
   memset(dst, val, n);
#endif
}

a238 22
/** Wrapper around either memset() or bzero() */
void
_mesa_bzero( void *dst, size_t n )
{
#if defined(__FreeBSD__)
   bzero( dst, n );
#else
   memset( dst, 0, n );
#endif
}

/** Wrapper around memcmp() */
int
_mesa_memcmp( const void *s1, const void *s2, size_t n )
{
#if defined(SUNOS4)
   return memcmp( (char *) s1, (char *) s2, (int) n );
#else
   return memcmp(s1, s2, n);
#endif
}

d398 1
a398 1
        union { float f; unsigned int i; } u;
d502 1
a502 1
_mesa_ffs(int i)
d539 1
a539 5
#ifdef __MINGW32__
_mesa_ffsll(long val)
#else
_mesa_ffsll(long long val)
#endif
d548 1
a548 1
   bit = _mesa_ffs(val);
d552 1
a552 1
   bit = _mesa_ffs(val >> 32);
d567 4
d576 1
d588 4
a591 4
   const int flt = *((int *) (void *) &val);
   const int flt_m = flt & 0x7fffff;
   const int flt_e = (flt >> 23) & 0xff;
   const int flt_s = (flt >> 31) & 0x1;
d678 2
a679 1
   int flt_m, flt_e, flt_s, flt;
d714 2
a715 2
   flt = (flt_s << 31) | (flt_e << 23) | flt_m;
   result = *((float *) (void *) &flt);
a779 49
/** Wrapper around strstr() */
char *
_mesa_strstr( const char *haystack, const char *needle )
{
   return strstr(haystack, needle);
}

/** Wrapper around strncat() */
char *
_mesa_strncat( char *dest, const char *src, size_t n )
{
   return strncat(dest, src, n);
}

/** Wrapper around strcpy() */
char *
_mesa_strcpy( char *dest, const char *src )
{
   return strcpy(dest, src);
}

/** Wrapper around strncpy() */
char *
_mesa_strncpy( char *dest, const char *src, size_t n )
{
   return strncpy(dest, src, n);
}

/** Wrapper around strlen() */
size_t
_mesa_strlen( const char *s )
{
   return strlen(s);
}

/** Wrapper around strcmp() */
int
_mesa_strcmp( const char *s1, const char *s2 )
{
   return strcmp(s1, s2);
}

/** Wrapper around strncmp() */
int
_mesa_strncmp( const char *s1, const char *s2, size_t n )
{
   return strncmp(s1, s2, n);
}

d781 1
a781 1
 * Implemented using _mesa_malloc() and _mesa_strcpy.
d788 2
a789 2
      size_t l = _mesa_strlen(s);
      char *s2 = (char *) _mesa_malloc(l + 1);
d791 1
a791 1
         _mesa_strcpy(s2, s);
d799 3
a801 3
/** Wrapper around atoi() */
int
_mesa_atoi(const char *s)
d803 11
a813 1
   return atoi(s);
d816 3
a818 3
/** Wrapper around strtod() */
double
_mesa_strtod( const char *s, char **end )
d820 7
a826 1
   return strtod(s, end);
d829 1
a832 16
/**********************************************************************/
/** \name I/O */
/*@@{*/

/** Wrapper around vsprintf() */
int
_mesa_sprintf( char *str, const char *fmt, ... )
{
   int r;
   va_list args;
   va_start( args, fmt );  
   r = vsprintf( str, fmt, args );
   va_end( args );
   return r;
}

d845 8
a852 3
/** Wrapper around printf(), using vsprintf() for the formatting. */
void
_mesa_printf( const char *fmtString, ... )
d854 36
a889 6
   char s[MAXSTRING];
   va_list args;
   va_start( args, fmtString );  
   vsnprintf(s, MAXSTRING, fmtString, args);
   va_end( args );
   fprintf(stderr, "%s", s);
d892 6
a897 3
/** Wrapper around fprintf(), using vsprintf() for the formatting. */
void
_mesa_fprintf( FILE *f, const char *fmtString, ... )
d899 22
a920 6
   char s[MAXSTRING];
   va_list args;
   va_start( args, fmtString );  
   vsnprintf(s, MAXSTRING, fmtString, args);
   va_end( args );
   fprintf(f, "%s", s);
d924 6
a929 3
/** Wrapper around vsprintf() */
int
_mesa_vsprintf( char *str, const char *fmt, va_list args )
d931 6
a936 2
   return vsprintf( str, fmt, args );
}
d938 1
a938 1
/*@@}*/
d940 3
a943 3
/**********************************************************************/
/** \name Diagnostics */
/*@@{*/
d950 1
a950 1
 * \param fmtString printf() alike format string.
a954 1
   GLboolean debug;
a956 1
   (void) ctx;
d960 5
a964 8
#ifdef DEBUG
   debug = GL_TRUE; /* always print warning */
#else
   debug = _mesa_getenv("MESA_DEBUG") ? GL_TRUE : GL_FALSE;
#endif
   if (debug) {
      fprintf(stderr, "Mesa warning: %s\n", str);
   }
d967 1
d969 1
a969 1
 * Report an internla implementation problem.
d973 1
a973 1
 * \param s problem description string.
d990 1
d992 1
a992 1
 * Record an OpenGL state error.  These usually occur when the users
d1006 1
a1006 2
   const char *debugEnv;
   GLboolean debug;
d1008 4
a1011 1
   debugEnv = _mesa_getenv("MESA_DEBUG");
d1014 4
a1017 4
   if (debugEnv && _mesa_strstr(debugEnv, "silent"))
      debug = GL_FALSE;
   else
      debug = GL_TRUE;
d1019 4
a1022 4
   if (debugEnv)
      debug = GL_TRUE;
   else
      debug = GL_FALSE;
d1024 10
d1035 11
a1045 40
   if (debug) {
      va_list args;
      char where[MAXSTRING];
      const char *errstr;

      va_start( args, fmtString );  
      vsnprintf( where, MAXSTRING, fmtString, args );
      va_end( args );

      switch (error) {
	 case GL_NO_ERROR:
	    errstr = "GL_NO_ERROR";
	    break;
	 case GL_INVALID_VALUE:
	    errstr = "GL_INVALID_VALUE";
	    break;
	 case GL_INVALID_ENUM:
	    errstr = "GL_INVALID_ENUM";
	    break;
	 case GL_INVALID_OPERATION:
	    errstr = "GL_INVALID_OPERATION";
	    break;
	 case GL_STACK_OVERFLOW:
	    errstr = "GL_STACK_OVERFLOW";
	    break;
	 case GL_STACK_UNDERFLOW:
	    errstr = "GL_STACK_UNDERFLOW";
	    break;
	 case GL_OUT_OF_MEMORY:
	    errstr = "GL_OUT_OF_MEMORY";
	    break;
         case GL_TABLE_TOO_LARGE:
            errstr = "GL_TABLE_TOO_LARGE";
            break;
         case GL_INVALID_FRAMEBUFFER_OPERATION_EXT:
            errstr = "GL_INVALID_FRAMEBUFFER_OPERATION";
            break;
	 default:
	    errstr = "unknown";
	    break;
a1046 1
      _mesa_debug(ctx, "User error: %s in %s\n", errstr, where);
d1050 2
a1051 1
}  
d1069 1
a1069 1
   fprintf(stderr, "Mesa: %s", s);
a1075 10


/**
 * Wrapper for exit().
 */
void
_mesa_exit( int status )
{
   exit(status);
}
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d789 16
d806 1
d822 1
a822 1
#if defined(_XBOX)
d937 12
d958 1
a958 1
   fprintf(stderr,"%s", s);
d960 13
@


1.1
log
@Initial revision
@
text
@a14 8
 * The OpenGL SI's __GLimports structure allows per-context specification of
 * replacements for the standard C lib functions.  In practice that's probably
 * never needed; compile-time replacements are far more likely.
 *
 * The _mesa_*() functions defined here don't in general take a context
 * parameter.  I guess we can change that someday, if need be.
 * So for now, the __GLimports stuff really isn't used.
 *
a18 3
 *
 * \note When compiled into a XFree86 module these functions wrap around
 * XFree86 own wrappers.
d23 1
a23 1
 * Version:  6.5
d25 1
a25 1
 * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
a62 9
/* If we don't actually want to use the libcwrapper junk (even though we're
 * building an Xorg server module), then just undef IN_MODULE to signal that to
 * the following code.  It's left around for now to allow compiling of newish
 * Mesa with older servers, but this whole mess should go away at some point.
 */
#ifdef NO_LIBCWRAPPER
#undef IN_MODULE
#endif

d67 1
a67 1
/** Wrapper around either malloc() or xf86malloc() */
a70 3
#if defined(XFree86LOADER) && defined(IN_MODULE)
   return xf86malloc(bytes);
#else
a71 1
#endif
d74 1
a74 1
/** Wrapper around either calloc() or xf86calloc() */
a77 3
#if defined(XFree86LOADER) && defined(IN_MODULE)
   return xf86calloc(1, bytes);
#else
a78 1
#endif
d81 1
a81 1
/** Wrapper around either free() or xf86free() */
a84 3
#if defined(XFree86LOADER) && defined(IN_MODULE)
   xf86free(ptr);
#else
a85 1
#endif
d102 1
a102 1
#if defined(HAVE_POSIX_MEMALIGN) && !(defined(XFree86LOADER) && defined(IN_MODULE))
d107 2
d130 1
a130 1
#endif /* defined(HAVE_POSIX_MEMALIGN) && !(defined(XFree86LOADER) && defined(IN_MODULE)) */
d140 1
a140 1
#if defined(HAVE_POSIX_MEMALIGN) && !(defined(XFree86LOADER) && defined(IN_MODULE))
d149 9
d179 1
a179 1
#endif /* defined(HAVE_POSIX_MEMALIGN) && !(defined(XFree86LOADER) && defined(IN_MODULE)) */
d192 1
a192 1
#if defined(HAVE_POSIX_MEMALIGN) && !(defined(XFree86LOADER) && defined(IN_MODULE))
d194 2
d200 1
a200 1
#endif /* defined(HAVE_POSIX_MEMALIGN) && !(defined(XFree86LOADER) && defined(IN_MODULE)) */
d210 4
d222 1
d244 1
a244 3
#if defined(XFree86LOADER) && defined(IN_MODULE)
   return xf86memcpy(dest, src, n);
#elif defined(SUNOS4)
d251 1
a251 1
/** Wrapper around either memset() or xf86memset() */
d255 1
a255 3
#if defined(XFree86LOADER) && defined(IN_MODULE)
   xf86memset( dst, val, n );
#elif defined(SUNOS4)
d275 1
a275 1
/** Wrapper around either memcpy() or xf86memcpy() or bzero() */
d279 1
a279 3
#if defined(XFree86LOADER) && defined(IN_MODULE)
   xf86memset( dst, 0, n );
#elif defined(__FreeBSD__)
d286 1
a286 1
/** Wrapper around either memcmp() or xf86memcmp() */
d290 1
a290 3
#if defined(XFree86LOADER) && defined(IN_MODULE)
   return xf86memcmp( s1, s2, n );
#elif defined(SUNOS4)
d304 1
a304 1
/** Wrapper around either sin() or xf86sin() */
a307 3
#if defined(XFree86LOADER) && defined(IN_MODULE)
   return xf86sin(a);
#else
a308 1
#endif
d311 1
a311 1
/** Single precision wrapper around either sin() or xf86sin() */
a314 3
#if defined(XFree86LOADER) && defined(IN_MODULE)
   return (float) xf86sin((double) a);
#else
a315 1
#endif
d318 1
a318 1
/** Wrapper around either cos() or xf86cos() */
a321 3
#if defined(XFree86LOADER) && defined(IN_MODULE)
   return xf86cos(a);
#else
a322 1
#endif
d325 1
a325 1
/** Single precision wrapper around either asin() or xf86asin() */
a328 3
#if defined(XFree86LOADER) && defined(IN_MODULE)
   return (float) xf86asin((double) x);
#else
a329 1
#endif
d332 1
a332 1
/** Single precision wrapper around either atan() or xf86atan() */
a335 3
#if defined(XFree86LOADER) && defined(IN_MODULE)
   return (float) xf86atan((double) x);
#else
a336 1
#endif
d339 1
a339 1
/** Wrapper around either sqrt() or xf86sqrt() */
a342 3
#if defined(XFree86LOADER) && defined(IN_MODULE)
   return xf86sqrt(x);
#else
a343 1
#endif
d361 2
a362 1
static void init_sqrt_table(void)
a541 2
#elif defined(XFree86LOADER) && defined(IN_MODULE)
        return 1.0F / xf86sqrt(n);
d548 1
a548 3
/**
 * Wrapper around either pow() or xf86pow().
 */
a551 3
#if defined(XFree86LOADER) && defined(IN_MODULE)
   return xf86pow(x, y);
#else
a552 1
#endif
d562 1
a562 1
#if (defined(_WIN32) && !defined(__MINGW32__) ) || defined(__IBMC__) || defined(__IBMCPP__)
d581 1
a583 2
#elif defined(XFree86LOADER) && defined(IN_MODULE)
   return xf86ffs(i);
d591 33
a788 3
#if defined(XFree86LOADER) && defined(IN_MODULE)
   return xf86bsearch(key, base, nmemb, size, compar);
#else
a789 1
#endif
d805 1
a805 3
#if defined(XFree86LOADER) && defined(IN_MODULE)
   return xf86getenv(var);
#elif defined(_XBOX)
d819 1
a819 1
/** Wrapper around either strstr() or xf86strstr() */
a822 3
#if defined(XFree86LOADER) && defined(IN_MODULE)
   return xf86strstr(haystack, needle);
#else
a823 1
#endif
d826 1
a826 1
/** Wrapper around either strncat() or xf86strncat() */
a829 3
#if defined(XFree86LOADER) && defined(IN_MODULE)
   return xf86strncat(dest, src, n);
#else
a830 1
#endif
d833 1
a833 1
/** Wrapper around either strcpy() or xf86strcpy() */
a836 3
#if defined(XFree86LOADER) && defined(IN_MODULE)
   return xf86strcpy(dest, src);
#else
a837 1
#endif
d840 1
a840 1
/** Wrapper around either strncpy() or xf86strncpy() */
a843 3
#if defined(XFree86LOADER) && defined(IN_MODULE)
   return xf86strncpy(dest, src, n);
#else
a844 1
#endif
d847 1
a847 1
/** Wrapper around either strlen() or xf86strlen() */
a850 3
#if defined(XFree86LOADER) && defined(IN_MODULE)
   return xf86strlen(s);
#else
a851 1
#endif
d854 1
a854 1
/** Wrapper around either strcmp() or xf86strcmp() */
a857 3
#if defined(XFree86LOADER) && defined(IN_MODULE)
   return xf86strcmp(s1, s2);
#else
a858 1
#endif
d861 1
a861 1
/** Wrapper around either strncmp() or xf86strncmp() */
a864 3
#if defined(XFree86LOADER) && defined(IN_MODULE)
   return xf86strncmp(s1, s2, n);
#else
a865 1
#endif
d868 4
a871 1
/** Implemented using _mesa_malloc() and _mesa_strcpy */
d875 10
a884 5
   size_t l = _mesa_strlen(s);
   char *s2 = (char *) _mesa_malloc(l + 1);
   if (s2)
      _mesa_strcpy(s2, s);
   return s2;
d887 1
a887 1
/** Wrapper around either atoi() or xf86atoi() */
a890 3
#if defined(XFree86LOADER) && defined(IN_MODULE)
   return xf86atoi(s);
#else
a891 1
#endif
d894 1
a894 1
/** Wrapper around either strtod() or xf86strtod() */
a897 3
#if defined(XFree86LOADER) && defined(IN_MODULE)
   return xf86strtod(s, end);
#else
a898 1
#endif
d908 1
a908 1
/** Wrapper around either vsprintf() or xf86vsprintf() */
a914 3
#if defined(XFree86LOADER) && defined(IN_MODULE)
   r = xf86vsprintf( str, fmt, args );
#else
a915 1
#endif
d920 1
a920 2
/** Wrapper around either printf() or xf86printf(), using vsprintf() for
 * the formatting. */
a928 3
#if defined(XFree86LOADER) && defined(IN_MODULE)
   xf86printf("%s", s);
#else
a929 1
#endif
d932 1
a932 1
/** Wrapper around either vsprintf() or xf86vsprintf() */
a935 3
#if defined(XFree86LOADER) && defined(IN_MODULE)
   return xf86vsprintf( str, fmt, args );
#else
a936 1
#endif
d947 2
a948 1
 * Display a warning.
a951 4
 * 
 * If debugging is enabled (either at compile-time via the DEBUG macro, or
 * run-time via the MESA_DEBUG environment variable), prints the warning to
 * stderr, either via fprintf() or xf86printf().
a968 3
#if defined(XFree86LOADER) && defined(IN_MODULE)
      xf86fprintf(stderr, "Mesa warning: %s\n", str);
#else
a969 1
#endif
d974 2
a975 2
 * This function is called when the Mesa user has stumbled into a code
 * path which may not be implemented fully or correctly.
a978 2
 *
 * Prints the message to stderr, either via fprintf() or xf86fprintf().
a990 4
#if defined(XFree86LOADER) && defined(IN_MODULE)
   xf86fprintf(stderr, "Mesa %s implementation error: %s\n", MESA_VERSION_STRING, str);
   xf86fprintf(stderr, "Please report at bugzilla.freedesktop.org\n");
#else
a992 1
#endif
d996 2
a997 1
 * Display an error message.
d999 3
a1001 2
 * If in debug mode, print error message.
 * Also, record the error code by calling _mesa_record_error().
a1005 4
 *         
 * If debugging is enabled (either at compile-time via the DEBUG macro, or
 * run-time via the MESA_DEBUG environment variable), interperts the error code and 
 * prints the error message via _mesa_debug().
d1075 2
a1076 1
 * Report debug information.
d1079 1
a1079 3
 * \param fmtString printf() alike format string.
 * 
 * Prints the message to stderr, either via fprintf() or xf86printf().
a1089 3
#if defined(XFree86LOADER) && defined(IN_MODULE)
   xf86fprintf(stderr, "Mesa: %s", s);
#else
a1090 1
#endif
a1098 4
/**********************************************************************/
/** \name Exit */
/*@@{*/

a1104 3
#if defined(XFree86LOADER) && defined(IN_MODULE)
   xf86exit(status);
#else
a1105 167
#endif
}

/*@@}*/


/**********************************************************************/
/** \name Default Imports Wrapper */
/*@@{*/

/** Wrapper around _mesa_malloc() */
static void *
default_malloc(__GLcontext *gc, size_t size)
{
   (void) gc;
   return _mesa_malloc(size);
}

/** Wrapper around _mesa_malloc() */
static void *
default_calloc(__GLcontext *gc, size_t numElem, size_t elemSize)
{
   (void) gc;
   return _mesa_calloc(numElem * elemSize);
}

/** Wrapper around either realloc() or xf86realloc() */
static void *
default_realloc(__GLcontext *gc, void *oldAddr, size_t newSize)
{
   (void) gc;
#if defined(XFree86LOADER) && defined(IN_MODULE)
   return xf86realloc(oldAddr, newSize);
#else
   return realloc(oldAddr, newSize);
#endif
}

/** Wrapper around _mesa_free() */
static void
default_free(__GLcontext *gc, void *addr)
{
   (void) gc;
   _mesa_free(addr);
}

/** Wrapper around _mesa_getenv() */
static char * CAPI
default_getenv( __GLcontext *gc, const char *var )
{
   (void) gc;
   return _mesa_getenv(var);
}

/** Wrapper around _mesa_warning() */
static void
default_warning(__GLcontext *gc, char *str)
{
   _mesa_warning(gc, str);
}

/** Wrapper around _mesa_problem() */
static void
default_fatal(__GLcontext *gc, char *str)
{
   _mesa_problem(gc, str);
   abort();
}

/** Wrapper around atoi() */
static int CAPI
default_atoi(__GLcontext *gc, const char *str)
{
   (void) gc;
   return atoi(str);
}

/** Wrapper around vsprintf() */
static int CAPI
default_sprintf(__GLcontext *gc, char *str, const char *fmt, ...)
{
   int r;
   va_list args;
   (void) gc;
   va_start( args, fmt );  
   r = vsprintf( str, fmt, args );
   va_end( args );
   return r;
}

/** Wrapper around fopen() */
static void * CAPI
default_fopen(__GLcontext *gc, const char *path, const char *mode)
{
   (void) gc;
   return fopen(path, mode);
}

/** Wrapper around fclose() */
static int CAPI
default_fclose(__GLcontext *gc, void *stream)
{
   (void) gc;
   return fclose((FILE *) stream);
}

/** Wrapper around vfprintf() */
static int CAPI
default_fprintf(__GLcontext *gc, void *stream, const char *fmt, ...)
{
   int r;
   va_list args;
   (void) gc;
   va_start( args, fmt );  
   r = vfprintf( (FILE *) stream, fmt, args );
   va_end( args );
   return r;
}

/**
 * \todo this really is driver-specific and can't be here 
 */
static __GLdrawablePrivate *
default_GetDrawablePrivate(__GLcontext *gc)
{
   (void) gc;
   return NULL;
}

/*@@}*/


/**
 * Initialize a __GLimports object to point to the functions in this
 * file.  
 *
 * This is to be called from device drivers.
 * 
 * Also, do some one-time initializations.
 * 
 * \param imports the object to initialize.
 * \param driverCtx pointer to device driver-specific data.
 */
void
_mesa_init_default_imports(__GLimports *imports, void *driverCtx)
{
   /* XXX maybe move this one-time init stuff into context.c */
   static GLboolean initialized = GL_FALSE;
   if (!initialized) {
      init_sqrt_table();
      initialized = GL_TRUE;
   }

   imports->malloc = default_malloc;
   imports->calloc = default_calloc;
   imports->realloc = default_realloc;
   imports->free = default_free;
   imports->warning = default_warning;
   imports->fatal = default_fatal;
   imports->getenv = default_getenv; /* not used for now */
   imports->atoi = default_atoi;
   imports->sprintf = default_sprintf;
   imports->fopen = default_fopen;
   imports->fclose = default_fclose;
   imports->fprintf = default_fprintf;
   imports->getDrawablePrivate = default_GetDrawablePrivate;
   imports->other = driverCtx;
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@Mesa 7.0.1
@
text
@d15 8
d27 3
d34 1
a34 1
 * Version:  7.0
d36 1
a36 1
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
d74 9
d87 1
a87 1
/** Wrapper around malloc() */
d91 3
d95 1
d98 1
a98 1
/** Wrapper around calloc() */
d102 3
d106 1
d109 1
a109 1
/** Wrapper around free() */
d113 3
d117 1
d134 1
a134 1
#if defined(HAVE_POSIX_MEMALIGN)
d160 1
a160 1
#endif /* defined(HAVE_POSIX_MEMALIGN) */
d170 1
a170 1
#if defined(HAVE_POSIX_MEMALIGN)
d200 1
a200 1
#endif /* defined(HAVE_POSIX_MEMALIGN) */
d213 1
a213 1
#if defined(HAVE_POSIX_MEMALIGN)
d219 1
a219 1
#endif /* defined(HAVE_POSIX_MEMALIGN) */
d258 3
a260 1
#if defined(SUNOS4)
d267 1
a267 1
/** Wrapper around memset() */
d271 3
a273 1
#if defined(SUNOS4)
d293 1
a293 1
/** Wrapper around either memcpy() or bzero() */
d297 3
a299 1
#if defined(__FreeBSD__)
d306 1
a306 1
/** Wrapper around memcmp() */
d310 3
a312 1
#if defined(SUNOS4)
d326 1
a326 1
/** Wrapper around sin() */
d330 3
d334 1
d337 1
a337 1
/** Single precision wrapper around sin() */
d341 3
d345 1
d348 1
a348 1
/** Wrapper around cos() */
d352 3
d356 1
d359 1
a359 1
/** Single precision wrapper around asin() */
d363 3
d367 1
d370 1
a370 1
/** Single precision wrapper around atan() */
d374 3
d378 1
d381 1
a381 1
/** Wrapper around sqrt() */
d385 3
d389 1
d407 1
a407 2
void
_mesa_init_sqrt_table(void)
d587 2
d595 3
a597 1
/** Wrapper around pow() */
d601 3
d605 1
d636 2
a644 33
 * Find position of first bit set in given value.
 * XXX Warning: this function can only be used on 64-bit systems!
 * \return  position of least-significant bit set, starting at 1, return zero
 *          if no bits set.
 */
int
#ifdef __MINGW32__
_mesa_ffsll(long val)
#else
_mesa_ffsll(long long val)
#endif
{
#ifdef ffsll
   return ffsll(val);
#else
   int bit;

   assert(sizeof(val) == 8);

   bit = _mesa_ffs(val);
   if (bit != 0)
      return bit;

   bit = _mesa_ffs(val >> 32);
   if (bit != 0)
      return 32 + bit;

   return 0;
#endif
}


/**
d810 3
d814 1
d830 3
a832 1
#if defined(_XBOX)
d846 1
a846 1
/** Wrapper around strstr() */
d850 3
d854 1
d857 1
a857 1
/** Wrapper around strncat() */
d861 3
d865 1
d868 1
a868 1
/** Wrapper around strcpy() */
d872 3
d876 1
d879 1
a879 1
/** Wrapper around strncpy() */
d883 3
d887 1
d890 1
a890 1
/** Wrapper around strlen() */
d894 3
d898 1
d901 1
a901 1
/** Wrapper around strcmp() */
d905 3
d909 1
d912 1
a912 1
/** Wrapper around strncmp() */
d916 3
d920 1
d923 1
a923 4
/**
 * Implemented using _mesa_malloc() and _mesa_strcpy.
 * Note that NULL is handled accordingly.
 */
d927 5
a931 10
   if (s) {
      size_t l = _mesa_strlen(s);
      char *s2 = (char *) _mesa_malloc(l + 1);
      if (s2)
         _mesa_strcpy(s2, s);
      return s2;
   }
   else {
      return NULL;
   }
d934 1
a934 1
/** Wrapper around atoi() */
d938 3
d942 1
d945 1
a945 1
/** Wrapper around strtod() */
d949 3
d953 1
d963 1
a963 1
/** Wrapper around vsprintf() */
d970 3
d974 1
d979 2
a980 1
/** Wrapper around printf(), using vsprintf() for the formatting. */
d989 3
d993 1
d996 1
a996 1
/** Wrapper around vsprintf() */
d1000 3
d1004 1
d1015 1
a1015 2
 * Report a warning (a recoverable error condition) to stderr if
 * either DEBUG is defined or the MESA_DEBUG env var is set.
d1019 4
d1040 3
d1044 1
d1049 2
a1050 2
 * Report an internla implementation problem.
 * Prints the message to stderr via fprintf().
d1054 2
d1068 4
d1074 1
d1078 1
a1078 2
 * Record an OpenGL state error.  These usually occur when the users
 * passes invalid parameters to a GL function.
d1080 2
a1081 3
 * If debugging is enabled (either at compile-time via the DEBUG macro, or
 * run-time via the MESA_DEBUG environment variable), report the error with
 * _mesa_debug().
d1086 4
d1159 1
a1159 2
 * Report debug information.  Print error message to stderr via fprintf().
 * No-op if DEBUG mode not enabled.
d1162 3
a1164 1
 * \param fmtString printf()-style format string, followed by optional args.
d1175 3
d1179 1
d1188 4
d1198 3
d1202 167
@


1.1.1.3
log
@Import Mesa 7.10.3
@
text
@d23 1
a23 1
 * Version:  7.1
a50 7
#ifdef _GNU_SOURCE
#include <locale.h>
#ifdef __APPLE__
#include <xlocale.h>
#endif
#endif

d67 21
d104 2
a105 3
   int err = posix_memalign(& mem, alignment, bytes);
   if (err)
      return NULL;
a106 2
#elif defined(_WIN32) && defined(_MSC_VER)
   return _aligned_malloc(bytes, alignment);
d112 1
a112 1
   ptr = (uintptr_t) malloc(bytes + alignment + sizeof(void *));
d132 2
a133 2
 * Same as _mesa_align_malloc(), but using calloc(1, ) instead of
 * malloc()
a146 9
#elif defined(_WIN32) && defined(_MSC_VER)
   void *mem;

   mem = _aligned_malloc(bytes, alignment);
   if (mem != NULL) {
      (void) memset(mem, 0, bytes);
   }

   return mem;
d152 1
a152 1
   ptr = (uintptr_t) calloc(1, bytes + alignment + sizeof(void *));
a182 2
#elif defined(_WIN32) && defined(_MSC_VER)
   _aligned_free(ptr);
d186 1
a186 1
   free(realAddr);
a196 4
#if defined(_WIN32) && defined(_MSC_VER)
   (void) oldSize;
   return _aligned_realloc(oldBuffer, newSize, alignment);
#else
d200 1
a200 1
      memcpy(newBuf, oldBuffer, copySize);
a204 1
#endif
d214 1
a214 1
   void *newBuffer = malloc(newSize);
d216 1
a216 1
      memcpy(newBuffer, oldBuffer, copySize);
d218 1
a218 1
      free(oldBuffer);
d222 22
d257 22
d286 35
d438 1
a438 1
        fi_type u;
d529 9
d542 1
a542 1
_mesa_ffs(int32_t i)
d544 1
a544 1
#if (defined(_WIN32) ) || defined(__IBMC__) || defined(__IBMCPP__)
a562 1
      bit++;
d578 5
a582 1
_mesa_ffsll(int64_t val)
d591 1
a591 1
   bit = _mesa_ffs((int32_t)val);
d595 1
a595 1
   bit = _mesa_ffs((int32_t)(val >> 32));
a609 4
#if defined(__GNUC__) && \
	((_GNUC__ == 3 && __GNUC_MINOR__ >= 4) || __GNUC__ >= 4)
   return __builtin_popcount(n);
#else
a614 1
#endif
d626 4
a629 4
   const fi_type fi = {val};
   const int flt_m = fi.i & 0x7fffff;
   const int flt_e = (fi.i >> 23) & 0xff;
   const int flt_s = (fi.i >> 31) & 0x1;
d716 1
a716 2
   int flt_m, flt_e, flt_s;
   fi_type fi;
d751 2
a752 2
   fi.i = (flt_s << 31) | (flt_e << 23) | flt_m;
   result = fi.f;
a769 16
#if defined(_WIN32_WCE)
   void *mid;
   int cmp;
   while (nmemb) {
      nmemb >>= 1;
      mid = (char *)base + nmemb * size;
      cmp = (*compar)(key, mid);
      if (cmp == 0)
	 return mid;
      if (cmp > 0) {
	 base = (char *)mid + size;
	 --nmemb;
      }
   }
   return NULL;
#else
a770 1
#endif
d786 1
a786 1
#if defined(_XBOX) || defined(_WIN32_WCE)
d800 49
d850 1
a850 1
 * Implemented using malloc() and strcpy.
d857 2
a858 2
      size_t l = strlen(s);
      char *s2 = (char *) malloc(l + 1);
d860 1
a860 1
         strcpy(s2, s);
d868 3
a870 3
/** Wrapper around strtof() */
float
_mesa_strtof( const char *s, char **end )
d872 1
a872 11
#if defined(_GNU_SOURCE) && !defined(__CYGWIN__) && !defined(__FreeBSD__)
   static locale_t loc = NULL;
   if (!loc) {
      loc = newlocale(LC_CTYPE_MASK, "C", NULL);
   }
   return strtof_l(s, end, loc);
#elif defined(_ISOC99_SOURCE) || (defined(_XOPEN_SOURCE) && _XOPEN_SOURCE >= 600)
   return strtof(s, end);
#else
   return (float)strtod(s, end);
#endif
d875 3
a877 3
/** Compute simple checksum/hash for a string */
unsigned int
_mesa_str_checksum(const char *str)
d879 1
a879 7
   /* This could probably be much better */
   unsigned int sum, i;
   const char *c;
   sum = i = 1;
   for (c = str; *c; c++, i++)
      sum += *c * (i % 100);
   return sum + i;
d882 1
a883 1
/*@@}*/
d885 3
d889 1
a889 1
/** Wrapper around vsnprintf() */
d891 1
a891 1
_mesa_snprintf( char *str, size_t size, const char *fmt, ... )
d896 1
a896 1
   r = vsnprintf( str, size, fmt, args );
d901 3
a903 8

/**********************************************************************/
/** \name Diagnostics */
/*@@{*/

static void
output_if_debug(const char *prefixString, const char *outputString,
                GLboolean newline)
d905 6
a910 36
   static int debug = -1;

   /* Check the MESA_DEBUG environment variable if it hasn't
    * been checked yet.  We only have to check it once...
    */
   if (debug == -1) {
      char *env = _mesa_getenv("MESA_DEBUG");

      /* In a debug build, we print warning messages *unless*
       * MESA_DEBUG is 0.  In a non-debug build, we don't
       * print warning messages *unless* MESA_DEBUG is
       * set *to any value*.
       */
#ifdef DEBUG
      debug = (env != NULL && atoi(env) == 0) ? 0 : 1;
#else
      debug = (env != NULL) ? 1 : 0;
#endif
   }

   /* Now only print the string if we're required to do so. */
   if (debug) {
      fprintf(stderr, "%s: %s", prefixString, outputString);
      if (newline)
         fprintf(stderr, "\n");

#if defined(_WIN32) && !defined(_WIN32_WCE)
      /* stderr from windows applications without console is not usually 
       * visible, so communicate with the debugger instead */ 
      {
         char buf[4096];
         _mesa_snprintf(buf, sizeof(buf), "%s: %s%s", prefixString, outputString, newline ? "\n" : "");
         OutputDebugStringA(buf);
      }
#endif
   }
d913 3
a915 6

/**
 * Return string version of GL error code.
 */
static const char *
error_string( GLenum error )
d917 1
a917 22
   switch (error) {
   case GL_NO_ERROR:
      return "GL_NO_ERROR";
   case GL_INVALID_VALUE:
      return "GL_INVALID_VALUE";
   case GL_INVALID_ENUM:
      return "GL_INVALID_ENUM";
   case GL_INVALID_OPERATION:
      return "GL_INVALID_OPERATION";
   case GL_STACK_OVERFLOW:
      return "GL_STACK_OVERFLOW";
   case GL_STACK_UNDERFLOW:
      return "GL_STACK_UNDERFLOW";
   case GL_OUT_OF_MEMORY:
      return "GL_OUT_OF_MEMORY";
   case GL_TABLE_TOO_LARGE:
      return "GL_TABLE_TOO_LARGE";
   case GL_INVALID_FRAMEBUFFER_OPERATION_EXT:
      return "GL_INVALID_FRAMEBUFFER_OPERATION";
   default:
      return "unknown";
   }
d920 1
a921 19
/**
 * When a new type of error is recorded, print a message describing
 * previous errors which were accumulated.
 */
static void
flush_delayed_errors( struct gl_context *ctx )
{
   char s[MAXSTRING];

   if (ctx->ErrorDebugCount) {
      _mesa_snprintf(s, MAXSTRING, "%d similar %s errors", 
                     ctx->ErrorDebugCount,
                     error_string(ctx->ErrorValue));

      output_if_debug("Mesa", s, GL_TRUE);

      ctx->ErrorDebugCount = 0;
   }
}
d923 3
d932 1
a932 1
 * \param fmtString printf()-like format string.
d935 1
a935 1
_mesa_warning( struct gl_context *ctx, const char *fmtString, ... )
d937 1
d940 1
d944 8
a951 5
   
   if (ctx)
      flush_delayed_errors( ctx );

   output_if_debug("Mesa warning", str, GL_TRUE);
a953 1

d955 1
a955 1
 * Report an internal implementation problem.
d959 1
a959 1
 * \param fmtString problem description string.
d962 1
a962 1
_mesa_problem( const struct gl_context *ctx, const char *fmtString, ... )
d973 1
a973 1
   fprintf(stderr, "Please report at bugs.freedesktop.org\n");
a975 1

d977 1
a977 1
 * Record an OpenGL state error.  These usually occur when the user
d989 1
a989 1
_mesa_error( struct gl_context *ctx, GLenum error, const char *fmtString, ... )
d991 2
a992 1
   static GLint debug = -1;
d994 1
a994 4
   /* Check debug environment variable only once:
    */
   if (debug == -1) {
      const char *debugEnv = _mesa_getenv("MESA_DEBUG");
d997 9
a1005 9
      if (debugEnv && strstr(debugEnv, "silent"))
         debug = GL_FALSE;
      else
         debug = GL_TRUE;
#else
      if (debugEnv)
         debug = GL_TRUE;
      else
         debug = GL_FALSE;
a1006 1
   }
d1008 40
a1047 20
   if (debug) {      
      if (ctx->ErrorValue == error &&
          ctx->ErrorDebugFmtString == fmtString) {
         ctx->ErrorDebugCount++;
      }
      else {
         char s[MAXSTRING], s2[MAXSTRING];
         va_list args;

         flush_delayed_errors( ctx );
         
         va_start(args, fmtString);
         vsnprintf(s, MAXSTRING, fmtString, args);
         va_end(args);

         _mesa_snprintf(s2, MAXSTRING, "%s in %s", error_string(error), s);
         output_if_debug("Mesa: User error", s2, GL_TRUE);
         
         ctx->ErrorDebugFmtString = fmtString;
         ctx->ErrorDebugCount = 0;
d1049 1
d1053 1
a1053 2
}

d1063 1
a1063 1
_mesa_debug( const struct gl_context *ctx, const char *fmtString, ... )
d1071 1
a1071 1
   output_if_debug("Mesa", s, GL_FALSE);
d1078 10
@


1.1.1.4
log
@Import Mesa 9.2.0
@
text
@d23 1
d40 3
a42 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
a48 1
#include "mtypes.h"
d59 3
a61 1
#ifdef _WIN32
d63 1
a63 1
#elif defined(__IBMC__) || defined(__IBMCPP__)
d65 3
d101 1
a101 1
   ptr = (uintptr_t)malloc(bytes + alignment + sizeof(void *));
d150 1
a150 1
   ptr = (uintptr_t)calloc(1, bytes + alignment + sizeof(void *));
d222 2
a223 1
   free(oldBuffer);
d227 13
d247 207
a454 1
#ifndef __GNUC__
d459 1
a459 1
ffs(int i)
d461 1
d483 3
d496 1
a496 1
ffsll(long long int val)
d498 3
d505 1
a505 1
   bit = ffs((int) val);
d509 1
a509 1
   bit = ffs((int) (val >> 32));
d514 1
a515 1
#endif /* __GNUC__ */
a517 2
#if !defined(__GNUC__) ||\
   ((__GNUC__ * 100 + __GNUC_MINOR__) < 304) /* Not gcc 3.4 or later */
d524 4
a532 14
}

/**
 * Return number of bits set in given 64-bit uint.
 */
unsigned int
_mesa_bitcount_64(uint64_t n)
{
   unsigned int bits;
   for (bits = 0; n > 0; n = n >> 1) {
      bits += (n & 1);
   }
   return bits;
}
a533 19


/* Using C99 rounding functions for roundToEven() implementation is
 * difficult, because round(), rint, and nearbyint() are affected by
 * fesetenv(), which the application may have done for its own
 * purposes.  Mesa's IROUND macro is close to what we want, but it
 * rounds away from 0 on n + 0.5.
 */
int
_mesa_round_to_even(float val)
{
   int rounded = IROUND(val);

   if (val - floor(val) == 0.5) {
      if (rounded % 2 != 0)
         rounded += val > 0 ? -1 : 1;
   }

   return rounded;
d539 2
a540 15
 *
 * Not all float32 values can be represented exactly as a float16 value. We
 * round such intermediate float32 values to the nearest float16. When the
 * float32 lies exactly between to float16 values, we round to the one with
 * an even mantissa.
 *
 * This rounding behavior has several benefits:
 *   - It has no sign bias.
 *
 *   - It reproduces the behavior of real hardware: opcode F32TO16 in Intel's
 *     GPU ISA.
 *
 *   - By reproducing the behavior of the GPU (at least on Intel hardware),
 *     compile-time evaluation of constant packHalf2x16 GLSL expressions will
 *     result in the same value as if the expression were executed on the GPU.
d579 8
a586 5
      if (new_exp < -14) {
         /* The float32 lies in the range (0.0, min_normal16) and is rounded
          * to a nearby float16 value. The result will be either zero, subnormal,
          * or normal.
          */
d588 17
a604 1
         m = _mesa_round_to_even((1 << 24) * fabsf(fi.f));
d612 1
a612 5
         /* The float32 lies in the range
          *   [min_normal16, max_normal16 + max_step16)
          * and is rounded to a nearby float16 value. The result will be
          * either normal or infinite.
          */
d614 1
a614 1
         m = _mesa_round_to_even(flt_m / (float) (1 << 13));
a617 10
   assert(0 <= m && m <= 1024);
   if (m == 1024) {
      /* The float32 was rounded upwards into the range of the next exponent,
       * so bump the exponent. This correctly handles the case where f32
       * should be rounded up to float16 infinity.
       */
      ++e;
      m = 0;
   }

d746 1
a746 1
      char *s2 = malloc(l + 1);
d760 1
a760 2
#if defined(_GNU_SOURCE) && !defined(__CYGWIN__) && !defined(__FreeBSD__) && \
   !defined(ANDROID) && !defined(__HAIKU__) && !defined(__UCLIBC__)
a789 7
/** Needed due to #ifdef's, above. */
int
_mesa_vsnprintf(char *str, size_t size, const char *fmt, va_list args)
{
   return vsnprintf( str, size, fmt, args);
}

d803 230
@


1.1.1.5
log
@Import Mesa 10.2.3
@
text
@a170 2
 * Note that it is legal to pass NULL pointer to this function and will be
 * handled accordingly.
d180 3
a182 5
   if (ptr) {
      void **cubbyHole = (void **) ((char *) ptr - sizeof(void *));
      void *realAddr = *cubbyHole;
      free(realAddr);
   }
d202 2
a203 2

   _mesa_align_free(oldBuffer);
d569 1
a569 2
   !defined(ANDROID) && !defined(__HAIKU__) && !defined(__UCLIBC__) && \
   !defined(__NetBSD__)
@


1.1.1.6
log
@Import Mesa 10.4.3
@
text
@d212 14
d234 1
a234 1
#ifndef HAVE___BUILTIN_FFS
a262 1
#endif
d264 1
a264 1
#ifndef HAVE___BUILTIN_FFSLL
d288 1
a288 1
#endif
d291 2
a292 1
#ifndef HAVE___BUILTIN_POPCOUNT
a304 1
#endif
a305 1
#ifndef HAVE___BUILTIN_POPCOUNTLL
d492 54
d566 19
@


1.1.1.7
log
@Import Mesa 10.2.9
@
text
@a211 14


/** Reallocate memory */
void *
_mesa_realloc(void *oldBuffer, size_t oldSize, size_t newSize)
{
   const size_t copySize = (oldSize < newSize) ? oldSize : newSize;
   void *newBuffer = malloc(newSize);
   if (newBuffer && oldBuffer && copySize > 0)
      memcpy(newBuffer, oldBuffer, copySize);
   free(oldBuffer);
   return newBuffer;
}

d220 1
a220 1
#ifndef __GNUC__
d249 1
d251 1
a251 1

d275 1
a275 1
#endif /* __GNUC__ */
d278 1
a278 2
#if !defined(__GNUC__) ||\
   ((__GNUC__ * 100 + __GNUC_MINOR__) < 304) /* Not gcc 3.4 or later */
d291 1
d293 1
a479 54
/** \name Sort & Search */
/*@@{*/

/**
 * Wrapper for bsearch().
 */
void *
_mesa_bsearch( const void *key, const void *base, size_t nmemb, size_t size, 
               int (*compar)(const void *, const void *) )
{
#if defined(_WIN32_WCE)
   void *mid;
   int cmp;
   while (nmemb) {
      nmemb >>= 1;
      mid = (char *)base + nmemb * size;
      cmp = (*compar)(key, mid);
      if (cmp == 0)
	 return mid;
      if (cmp > 0) {
	 base = (char *)mid + size;
	 --nmemb;
      }
   }
   return NULL;
#else
   return bsearch(key, base, nmemb, size, compar);
#endif
}

/*@@}*/


/**********************************************************************/
/** \name Environment vars */
/*@@{*/

/**
 * Wrapper for getenv().
 */
char *
_mesa_getenv( const char *var )
{
#if defined(_XBOX) || defined(_WIN32_WCE)
   return NULL;
#else
   return getenv(var);
#endif
}

/*@@}*/


/**********************************************************************/
a499 19
}

/** Wrapper around strtof() */
float
_mesa_strtof( const char *s, char **end )
{
#if defined(_GNU_SOURCE) && !defined(__CYGWIN__) && !defined(__FreeBSD__) && \
   !defined(ANDROID) && !defined(__HAIKU__) && !defined(__UCLIBC__) && \
   !defined(__NetBSD__)
   static locale_t loc = NULL;
   if (!loc) {
      loc = newlocale(LC_CTYPE_MASK, "C", NULL);
   }
   return strtof_l(s, end, loc);
#elif defined(_ISOC99_SOURCE) || (defined(_XOPEN_SOURCE) && _XOPEN_SOURCE >= 600)
   return strtof(s, end);
#else
   return (float)strtod(s, end);
#endif
@


