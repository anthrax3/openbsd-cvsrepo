head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.8
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.6
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.5
	v10_2_7:1.1.1.5
	OPENBSD_5_6:1.6.0.4
	OPENBSD_5_6_BASE:1.6
	v10_2_3:1.1.1.5
	OPENBSD_5_5:1.6.0.2
	OPENBSD_5_5_BASE:1.6
	v9_2_5:1.1.1.5
	v9_2_3:1.1.1.5
	v9_2_2:1.1.1.5
	v9_2_1:1.1.1.5
	v9_2_0:1.1.1.5
	OPENBSD_5_4:1.5.0.4
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.2
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.4.0.4
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.1.3.0.6
	OPENBSD_4_5_BASE:1.1.1.3
	OPENBSD_4_4:1.1.1.3.0.4
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.12.23.05.17.53;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2013.09.05.14.06.25;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2012.08.17.13.58.19;	author mpi;	state Exp;
branches;
next	1.4;

1.4
date	2011.10.23.13.37.42;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.05.22.20.06.31;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.05.17.20.26.41;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.50.14;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.50.14;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.56.38;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.31.16;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.46;	author matthieu;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.09.05.13.16.46;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2008  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */


/**
 * \file pixel.c
 * Pixel transfer functions (glPixelZoom, glPixelMap, glPixelTransfer)
 */

#include "glheader.h"
#include "bufferobj.h"
#include "colormac.h"
#include "context.h"
#include "macros.h"
#include "pixel.h"
#include "pbo.h"
#include "mtypes.h"
#include "main/dispatch.h"


/**********************************************************************/
/*****                    glPixelZoom                             *****/
/**********************************************************************/

void GLAPIENTRY
_mesa_PixelZoom( GLfloat xfactor, GLfloat yfactor )
{
   GET_CURRENT_CONTEXT(ctx);

   if (ctx->Pixel.ZoomX == xfactor &&
       ctx->Pixel.ZoomY == yfactor)
      return;

   FLUSH_VERTICES(ctx, _NEW_PIXEL);
   ctx->Pixel.ZoomX = xfactor;
   ctx->Pixel.ZoomY = yfactor;
}



/**********************************************************************/
/*****                         glPixelMap                         *****/
/**********************************************************************/

/**
 * Return pointer to a pixelmap by name.
 */
static struct gl_pixelmap *
get_pixelmap(struct gl_context *ctx, GLenum map)
{
   switch (map) {
   case GL_PIXEL_MAP_I_TO_I:
      return &ctx->PixelMaps.ItoI;
   case GL_PIXEL_MAP_S_TO_S:
      return &ctx->PixelMaps.StoS;
   case GL_PIXEL_MAP_I_TO_R:
      return &ctx->PixelMaps.ItoR;
   case GL_PIXEL_MAP_I_TO_G:
      return &ctx->PixelMaps.ItoG;
   case GL_PIXEL_MAP_I_TO_B:
      return &ctx->PixelMaps.ItoB;
   case GL_PIXEL_MAP_I_TO_A:
      return &ctx->PixelMaps.ItoA;
   case GL_PIXEL_MAP_R_TO_R:
      return &ctx->PixelMaps.RtoR;
   case GL_PIXEL_MAP_G_TO_G:
      return &ctx->PixelMaps.GtoG;
   case GL_PIXEL_MAP_B_TO_B:
      return &ctx->PixelMaps.BtoB;
   case GL_PIXEL_MAP_A_TO_A:
      return &ctx->PixelMaps.AtoA;
   default:
      return NULL;
   }
}


/**
 * Helper routine used by the other _mesa_PixelMap() functions.
 */
static void
store_pixelmap(struct gl_context *ctx, GLenum map, GLsizei mapsize,
               const GLfloat *values)
{
   GLint i;
   struct gl_pixelmap *pm = get_pixelmap(ctx, map);
   if (!pm) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glPixelMap(map)");
      return;
   }

   switch (map) {
   case GL_PIXEL_MAP_S_TO_S:
      /* special case */
      ctx->PixelMaps.StoS.Size = mapsize;
      for (i = 0; i < mapsize; i++) {
         ctx->PixelMaps.StoS.Map[i] = (GLfloat)IROUND(values[i]);
      }
      break;
   case GL_PIXEL_MAP_I_TO_I:
      /* special case */
      ctx->PixelMaps.ItoI.Size = mapsize;
      for (i = 0; i < mapsize; i++) {
         ctx->PixelMaps.ItoI.Map[i] = values[i];
      }
      break;
   default:
      /* general case */
      pm->Size = mapsize;
      for (i = 0; i < mapsize; i++) {
         GLfloat val = CLAMP(values[i], 0.0F, 1.0F);
         pm->Map[i] = val;
      }
   }
}


/**
 * Convenience wrapper for _mesa_validate_pbo_access() for gl[Get]PixelMap().
 */
static GLboolean
validate_pbo_access(struct gl_context *ctx,
                    struct gl_pixelstore_attrib *pack, GLsizei mapsize,
                    GLenum format, GLenum type, GLsizei clientMemSize,
                    const GLvoid *ptr)
{
   GLboolean ok;

   /* Note, need to use DefaultPacking and Unpack's buffer object */
   _mesa_reference_buffer_object(ctx,
                                 &ctx->DefaultPacking.BufferObj,
                                 pack->BufferObj);

   ok = _mesa_validate_pbo_access(1, &ctx->DefaultPacking, mapsize, 1, 1,
                                  format, type, clientMemSize, ptr);

   /* restore */
   _mesa_reference_buffer_object(ctx,
                                 &ctx->DefaultPacking.BufferObj,
                                 ctx->Shared->NullBufferObj);

   if (!ok) {
      if (_mesa_is_bufferobj(pack->BufferObj)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "gl[Get]PixelMap*v(out of bounds PBO access)");
      } else {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glGetnPixelMap*vARB(out of bounds access:"
                     " bufSize (%d) is too small)", clientMemSize);
      }
   }
   return ok;
}


void GLAPIENTRY
_mesa_PixelMapfv( GLenum map, GLsizei mapsize, const GLfloat *values )
{
   GET_CURRENT_CONTEXT(ctx);

   /* XXX someday, test against ctx->Const.MaxPixelMapTableSize */
   if (mapsize < 1 || mapsize > MAX_PIXEL_MAP_TABLE) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glPixelMapfv(mapsize)" );
      return;
   }

   if (map >= GL_PIXEL_MAP_S_TO_S && map <= GL_PIXEL_MAP_I_TO_A) {
      /* test that mapsize is a power of two */
      if (!_mesa_is_pow_two(mapsize)) {
	 _mesa_error( ctx, GL_INVALID_VALUE, "glPixelMapfv(mapsize)" );
         return;
      }
   }

   FLUSH_VERTICES(ctx, _NEW_PIXEL);

   if (!validate_pbo_access(ctx, &ctx->Unpack, mapsize, GL_INTENSITY,
                            GL_FLOAT, INT_MAX, values)) {
      return;
   }

   values = (const GLfloat *) _mesa_map_pbo_source(ctx, &ctx->Unpack, values);
   if (!values) {
      if (_mesa_is_bufferobj(ctx->Unpack.BufferObj)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glPixelMapfv(PBO is mapped)");
      }
      return;
   }

   store_pixelmap(ctx, map, mapsize, values);

   _mesa_unmap_pbo_source(ctx, &ctx->Unpack);
}


void GLAPIENTRY
_mesa_PixelMapuiv(GLenum map, GLsizei mapsize, const GLuint *values )
{
   GLfloat fvalues[MAX_PIXEL_MAP_TABLE];
   GET_CURRENT_CONTEXT(ctx);

   if (mapsize < 1 || mapsize > MAX_PIXEL_MAP_TABLE) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glPixelMapuiv(mapsize)" );
      return;
   }

   if (map >= GL_PIXEL_MAP_S_TO_S && map <= GL_PIXEL_MAP_I_TO_A) {
      /* test that mapsize is a power of two */
      if (!_mesa_is_pow_two(mapsize)) {
	 _mesa_error( ctx, GL_INVALID_VALUE, "glPixelMapuiv(mapsize)" );
         return;
      }
   }

   FLUSH_VERTICES(ctx, _NEW_PIXEL);

   if (!validate_pbo_access(ctx, &ctx->Unpack, mapsize, GL_INTENSITY,
                            GL_UNSIGNED_INT, INT_MAX, values)) {
      return;
   }

   values = (const GLuint *) _mesa_map_pbo_source(ctx, &ctx->Unpack, values);
   if (!values) {
      if (_mesa_is_bufferobj(ctx->Unpack.BufferObj)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glPixelMapuiv(PBO is mapped)");
      }
      return;
   }

   /* convert to floats */
   if (map == GL_PIXEL_MAP_I_TO_I || map == GL_PIXEL_MAP_S_TO_S) {
      GLint i;
      for (i = 0; i < mapsize; i++) {
         fvalues[i] = (GLfloat) values[i];
      }
   }
   else {
      GLint i;
      for (i = 0; i < mapsize; i++) {
         fvalues[i] = UINT_TO_FLOAT( values[i] );
      }
   }

   _mesa_unmap_pbo_source(ctx, &ctx->Unpack);

   store_pixelmap(ctx, map, mapsize, fvalues);
}


void GLAPIENTRY
_mesa_PixelMapusv(GLenum map, GLsizei mapsize, const GLushort *values )
{
   GLfloat fvalues[MAX_PIXEL_MAP_TABLE];
   GET_CURRENT_CONTEXT(ctx);

   if (mapsize < 1 || mapsize > MAX_PIXEL_MAP_TABLE) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glPixelMapusv(mapsize)" );
      return;
   }

   if (map >= GL_PIXEL_MAP_S_TO_S && map <= GL_PIXEL_MAP_I_TO_A) {
      /* test that mapsize is a power of two */
      if (!_mesa_is_pow_two(mapsize)) {
	 _mesa_error( ctx, GL_INVALID_VALUE, "glPixelMapuiv(mapsize)" );
         return;
      }
   }

   FLUSH_VERTICES(ctx, _NEW_PIXEL);

   if (!validate_pbo_access(ctx, &ctx->Unpack, mapsize, GL_INTENSITY,
                            GL_UNSIGNED_SHORT, INT_MAX, values)) {
      return;
   }

   values = (const GLushort *) _mesa_map_pbo_source(ctx, &ctx->Unpack, values);
   if (!values) {
      if (_mesa_is_bufferobj(ctx->Unpack.BufferObj)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glPixelMapusv(PBO is mapped)");
      }
      return;
   }

   /* convert to floats */
   if (map == GL_PIXEL_MAP_I_TO_I || map == GL_PIXEL_MAP_S_TO_S) {
      GLint i;
      for (i = 0; i < mapsize; i++) {
         fvalues[i] = (GLfloat) values[i];
      }
   }
   else {
      GLint i;
      for (i = 0; i < mapsize; i++) {
         fvalues[i] = USHORT_TO_FLOAT( values[i] );
      }
   }

   _mesa_unmap_pbo_source(ctx, &ctx->Unpack);

   store_pixelmap(ctx, map, mapsize, fvalues);
}


void GLAPIENTRY
_mesa_GetnPixelMapfvARB( GLenum map, GLsizei bufSize, GLfloat *values )
{
   GET_CURRENT_CONTEXT(ctx);
   GLint mapsize, i;
   const struct gl_pixelmap *pm;

   pm = get_pixelmap(ctx, map);
   if (!pm) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetPixelMapfv(map)");
      return;
   }

   mapsize = pm->Size;

   if (!validate_pbo_access(ctx, &ctx->Pack, mapsize, GL_INTENSITY,
                            GL_FLOAT, bufSize, values)) {
      return;
   }

   values = (GLfloat *) _mesa_map_pbo_dest(ctx, &ctx->Pack, values);
   if (!values) {
      if (_mesa_is_bufferobj(ctx->Pack.BufferObj)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glGetPixelMapfv(PBO is mapped)");
      }
      return;
   }

   if (map == GL_PIXEL_MAP_S_TO_S) {
      /* special case */
      for (i = 0; i < mapsize; i++) {
         values[i] = (GLfloat) ctx->PixelMaps.StoS.Map[i];
      }
   }
   else {
      memcpy(values, pm->Map, mapsize * sizeof(GLfloat));
   }

   _mesa_unmap_pbo_dest(ctx, &ctx->Pack);
}


void GLAPIENTRY
_mesa_GetPixelMapfv( GLenum map, GLfloat *values )
{
   _mesa_GetnPixelMapfvARB(map, INT_MAX, values);
}

void GLAPIENTRY
_mesa_GetnPixelMapuivARB( GLenum map, GLsizei bufSize, GLuint *values )
{
   GET_CURRENT_CONTEXT(ctx);
   GLint mapsize, i;
   const struct gl_pixelmap *pm;

   pm = get_pixelmap(ctx, map);
   if (!pm) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetPixelMapuiv(map)");
      return;
   }

   mapsize = pm->Size;

   if (!validate_pbo_access(ctx, &ctx->Pack, mapsize, GL_INTENSITY,
                            GL_UNSIGNED_INT, bufSize, values)) {
      return;
   }

   values = (GLuint *) _mesa_map_pbo_dest(ctx, &ctx->Pack, values);
   if (!values) {
      if (_mesa_is_bufferobj(ctx->Pack.BufferObj)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glGetPixelMapuiv(PBO is mapped)");
      }
      return;
   }

   if (map == GL_PIXEL_MAP_S_TO_S) {
      /* special case */
      memcpy(values, ctx->PixelMaps.StoS.Map, mapsize * sizeof(GLint));
   }
   else {
      for (i = 0; i < mapsize; i++) {
         values[i] = FLOAT_TO_UINT( pm->Map[i] );
      }
   }

   _mesa_unmap_pbo_dest(ctx, &ctx->Pack);
}


void GLAPIENTRY
_mesa_GetPixelMapuiv( GLenum map, GLuint *values )
{
   _mesa_GetnPixelMapuivARB(map, INT_MAX, values);
}

void GLAPIENTRY
_mesa_GetnPixelMapusvARB( GLenum map, GLsizei bufSize, GLushort *values )
{
   GET_CURRENT_CONTEXT(ctx);
   GLint mapsize, i;
   const struct gl_pixelmap *pm;

   pm = get_pixelmap(ctx, map);
   if (!pm) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetPixelMapusv(map)");
      return;
   }

   mapsize = pm->Size;

   if (!validate_pbo_access(ctx, &ctx->Pack, mapsize, GL_INTENSITY,
                            GL_UNSIGNED_SHORT, bufSize, values)) {
      return;
   }

   values = (GLushort *) _mesa_map_pbo_dest(ctx, &ctx->Pack, values);
   if (!values) {
      if (_mesa_is_bufferobj(ctx->Pack.BufferObj)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glGetPixelMapusv(PBO is mapped)");
      }
      return;
   }

   switch (map) {
   /* special cases */
   case GL_PIXEL_MAP_I_TO_I:
      for (i = 0; i < mapsize; i++) {
         values[i] = (GLushort) CLAMP(ctx->PixelMaps.ItoI.Map[i], 0.0, 65535.);
      }
      break;
   case GL_PIXEL_MAP_S_TO_S:
      for (i = 0; i < mapsize; i++) {
         values[i] = (GLushort) CLAMP(ctx->PixelMaps.StoS.Map[i], 0.0, 65535.);
      }
      break;
   default:
      for (i = 0; i < mapsize; i++) {
         CLAMPED_FLOAT_TO_USHORT(values[i], pm->Map[i] );
      }
   }

   _mesa_unmap_pbo_dest(ctx, &ctx->Pack);
}


void GLAPIENTRY
_mesa_GetPixelMapusv( GLenum map, GLushort *values )
{
   _mesa_GetnPixelMapusvARB(map, INT_MAX, values);
}


/**********************************************************************/
/*****                       glPixelTransfer                      *****/
/**********************************************************************/


/*
 * Implements glPixelTransfer[fi] whether called immediately or from a
 * display list.
 */
void GLAPIENTRY
_mesa_PixelTransferf( GLenum pname, GLfloat param )
{
   GET_CURRENT_CONTEXT(ctx);

   switch (pname) {
      case GL_MAP_COLOR:
         if (ctx->Pixel.MapColorFlag == (param ? GL_TRUE : GL_FALSE))
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
         ctx->Pixel.MapColorFlag = param ? GL_TRUE : GL_FALSE;
	 break;
      case GL_MAP_STENCIL:
         if (ctx->Pixel.MapStencilFlag == (param ? GL_TRUE : GL_FALSE))
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
         ctx->Pixel.MapStencilFlag = param ? GL_TRUE : GL_FALSE;
	 break;
      case GL_INDEX_SHIFT:
         if (ctx->Pixel.IndexShift == (GLint) param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
         ctx->Pixel.IndexShift = (GLint) param;
	 break;
      case GL_INDEX_OFFSET:
         if (ctx->Pixel.IndexOffset == (GLint) param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
         ctx->Pixel.IndexOffset = (GLint) param;
	 break;
      case GL_RED_SCALE:
         if (ctx->Pixel.RedScale == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
         ctx->Pixel.RedScale = param;
	 break;
      case GL_RED_BIAS:
         if (ctx->Pixel.RedBias == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
         ctx->Pixel.RedBias = param;
	 break;
      case GL_GREEN_SCALE:
         if (ctx->Pixel.GreenScale == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
         ctx->Pixel.GreenScale = param;
	 break;
      case GL_GREEN_BIAS:
         if (ctx->Pixel.GreenBias == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
         ctx->Pixel.GreenBias = param;
	 break;
      case GL_BLUE_SCALE:
         if (ctx->Pixel.BlueScale == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
         ctx->Pixel.BlueScale = param;
	 break;
      case GL_BLUE_BIAS:
         if (ctx->Pixel.BlueBias == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
         ctx->Pixel.BlueBias = param;
	 break;
      case GL_ALPHA_SCALE:
         if (ctx->Pixel.AlphaScale == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
         ctx->Pixel.AlphaScale = param;
	 break;
      case GL_ALPHA_BIAS:
         if (ctx->Pixel.AlphaBias == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
         ctx->Pixel.AlphaBias = param;
	 break;
      case GL_DEPTH_SCALE:
         if (ctx->Pixel.DepthScale == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
         ctx->Pixel.DepthScale = param;
	 break;
      case GL_DEPTH_BIAS:
         if (ctx->Pixel.DepthBias == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
         ctx->Pixel.DepthBias = param;
	 break;
      default:
         _mesa_error( ctx, GL_INVALID_ENUM, "glPixelTransfer(pname)" );
         return;
   }
}


void GLAPIENTRY
_mesa_PixelTransferi( GLenum pname, GLint param )
{
   _mesa_PixelTransferf( pname, (GLfloat) param );
}



/**********************************************************************/
/*****                    State Management                        *****/
/**********************************************************************/

/*
 * Return a bitmask of IMAGE_*_BIT flags which to indicate which
 * pixel transfer operations are enabled.
 */
static void
update_image_transfer_state(struct gl_context *ctx)
{
   GLuint mask = 0;

   if (ctx->Pixel.RedScale   != 1.0F || ctx->Pixel.RedBias   != 0.0F ||
       ctx->Pixel.GreenScale != 1.0F || ctx->Pixel.GreenBias != 0.0F ||
       ctx->Pixel.BlueScale  != 1.0F || ctx->Pixel.BlueBias  != 0.0F ||
       ctx->Pixel.AlphaScale != 1.0F || ctx->Pixel.AlphaBias != 0.0F)
      mask |= IMAGE_SCALE_BIAS_BIT;

   if (ctx->Pixel.IndexShift || ctx->Pixel.IndexOffset)
      mask |= IMAGE_SHIFT_OFFSET_BIT;

   if (ctx->Pixel.MapColorFlag)
      mask |= IMAGE_MAP_COLOR_BIT;

   ctx->_ImageTransferState = mask;
}


/**
 * Update mesa pixel transfer derived state.
 */
void _mesa_update_pixel( struct gl_context *ctx, GLuint new_state )
{
   if (new_state & _NEW_PIXEL)
      update_image_transfer_state(ctx);
}


/**********************************************************************/
/*****                      Initialization                        *****/
/**********************************************************************/

static void
init_pixelmap(struct gl_pixelmap *map)
{
   map->Size = 1;
   map->Map[0] = 0.0;
}


/**
 * Initialize the context's PIXEL attribute group.
 */
void
_mesa_init_pixel( struct gl_context *ctx )
{
   /* Pixel group */
   ctx->Pixel.RedBias = 0.0;
   ctx->Pixel.RedScale = 1.0;
   ctx->Pixel.GreenBias = 0.0;
   ctx->Pixel.GreenScale = 1.0;
   ctx->Pixel.BlueBias = 0.0;
   ctx->Pixel.BlueScale = 1.0;
   ctx->Pixel.AlphaBias = 0.0;
   ctx->Pixel.AlphaScale = 1.0;
   ctx->Pixel.DepthBias = 0.0;
   ctx->Pixel.DepthScale = 1.0;
   ctx->Pixel.IndexOffset = 0;
   ctx->Pixel.IndexShift = 0;
   ctx->Pixel.ZoomX = 1.0;
   ctx->Pixel.ZoomY = 1.0;
   ctx->Pixel.MapColorFlag = GL_FALSE;
   ctx->Pixel.MapStencilFlag = GL_FALSE;
   init_pixelmap(&ctx->PixelMaps.StoS);
   init_pixelmap(&ctx->PixelMaps.ItoI);
   init_pixelmap(&ctx->PixelMaps.ItoR);
   init_pixelmap(&ctx->PixelMaps.ItoG);
   init_pixelmap(&ctx->PixelMaps.ItoB);
   init_pixelmap(&ctx->PixelMaps.ItoA);
   init_pixelmap(&ctx->PixelMaps.RtoR);
   init_pixelmap(&ctx->PixelMaps.GtoG);
   init_pixelmap(&ctx->PixelMaps.BtoB);
   init_pixelmap(&ctx->PixelMaps.AtoA);

   if (ctx->Visual.doubleBufferMode) {
      ctx->Pixel.ReadBuffer = GL_BACK;
   }
   else {
      ctx->Pixel.ReadBuffer = GL_FRONT;
   }

   /* Miscellaneous */
   ctx->_ImageTransferState = 0;
}
@


1.6
log
@Merge Mesa 9.2.0
@
text
@@


1.5
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a2 1
 * Version:  7.1
d19 4
a22 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
a35 1
#include "mfeatures.h"
a41 3
#if FEATURE_pixel_transfer


d46 1
a46 1
static void GLAPIENTRY
a50 2
   ASSERT_OUTSIDE_BEGIN_END(ctx);

a133 1
         pm->Map8[i] = (GLint) (val * 255.0F);
d177 1
a177 1
static void GLAPIENTRY
a180 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d218 1
a218 1
static void GLAPIENTRY
a222 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d273 1
a273 1
static void GLAPIENTRY
a277 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d328 1
a328 1
static void GLAPIENTRY
a334 2
   ASSERT_OUTSIDE_BEGIN_END(ctx);

d371 1
a371 1
static void GLAPIENTRY
d377 1
a377 1
static void GLAPIENTRY
a383 2
   ASSERT_OUTSIDE_BEGIN_END(ctx);

d420 1
a420 1
static void GLAPIENTRY
d426 1
a426 1
static void GLAPIENTRY
a432 2
   ASSERT_OUTSIDE_BEGIN_END(ctx);

d477 1
a477 1
static void GLAPIENTRY
d493 1
a493 1
static void GLAPIENTRY
a496 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d590 1
a590 1
static void GLAPIENTRY
a636 23
void
_mesa_init_pixel_dispatch(struct _glapi_table *disp)
{
   SET_GetPixelMapfv(disp, _mesa_GetPixelMapfv);
   SET_GetPixelMapuiv(disp, _mesa_GetPixelMapuiv);
   SET_GetPixelMapusv(disp, _mesa_GetPixelMapusv);
   SET_PixelMapfv(disp, _mesa_PixelMapfv);
   SET_PixelMapuiv(disp, _mesa_PixelMapuiv);
   SET_PixelMapusv(disp, _mesa_PixelMapusv);
   SET_PixelTransferf(disp, _mesa_PixelTransferf);
   SET_PixelTransferi(disp, _mesa_PixelTransferi);
   SET_PixelZoom(disp, _mesa_PixelZoom);

   /* GL_ARB_robustness */
   SET_GetnPixelMapfvARB(disp, _mesa_GetnPixelMapfvARB);
   SET_GetnPixelMapuivARB(disp, _mesa_GetnPixelMapuivARB);
   SET_GetnPixelMapusvARB(disp, _mesa_GetnPixelMapusvARB);
}


#endif /* FEATURE_pixel_transfer */


a645 1
   map->Map8[0] = 0;
@


1.4
log
@Merge Mesa 7.10.3
@
text
@d36 1
d38 1
d55 2
d150 3
a152 2
validate_pbo_access(struct gl_context *ctx, struct gl_pixelstore_attrib *pack,
                    GLsizei mapsize, GLenum format, GLenum type,
d163 1
a163 1
                                  format, type, ptr);
d171 8
a178 2
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glPixelMap(invalid PBO access)");
d206 2
a207 2
   if (!validate_pbo_access(ctx, &ctx->Unpack, mapsize,
                            GL_INTENSITY, GL_FLOAT, values)) {
d248 2
a249 2
   if (!validate_pbo_access(ctx, &ctx->Unpack, mapsize,
                            GL_INTENSITY, GL_UNSIGNED_INT, values)) {
d304 2
a305 2
   if (!validate_pbo_access(ctx, &ctx->Unpack, mapsize,
                            GL_INTENSITY, GL_UNSIGNED_SHORT, values)) {
d339 1
a339 1
_mesa_GetPixelMapfv( GLenum map, GLfloat *values )
d342 1
a342 1
   GLuint mapsize, i;
d355 2
a356 2
   if (!validate_pbo_access(ctx, &ctx->Pack, mapsize,
                            GL_INTENSITY, GL_FLOAT, values)) {
d384 7
a390 1
_mesa_GetPixelMapuiv( GLenum map, GLuint *values )
d403 1
d406 2
a407 2
   if (!validate_pbo_access(ctx, &ctx->Pack, mapsize,
                            GL_INTENSITY, GL_UNSIGNED_INT, values)) {
d435 7
a441 1
_mesa_GetPixelMapusv( GLenum map, GLushort *values )
d454 1
d457 2
a458 2
   if (!validate_pbo_access(ctx, &ctx->Pack, mapsize,
                            GL_INTENSITY, GL_UNSIGNED_SHORT, values)) {
d493 6
d649 1
a649 1
   if (new_state & _MESA_NEW_TRANSFER_STATE)
d666 5
a722 3
   /* GL_SGI_texture_color_table */
   ASSIGN_4V(ctx->Pixel.TextureColorTableScale, 1.0, 1.0, 1.0, 1.0);
   ASSIGN_4V(ctx->Pixel.TextureColorTableBias, 0.0, 0.0, 0.0, 0.0);
@


1.3
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d72 1
a72 1
get_pixelmap(GLcontext *ctx, GLenum map)
d105 1
a105 1
store_pixelmap(GLcontext *ctx, GLenum map, GLsizei mapsize,
d146 1
a146 1
validate_pbo_access(GLcontext *ctx, struct gl_pixelstore_attrib *pack,
a568 96
      case GL_POST_COLOR_MATRIX_RED_SCALE:
         if (ctx->Pixel.PostColorMatrixScale[0] == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
         ctx->Pixel.PostColorMatrixScale[0] = param;
	 break;
      case GL_POST_COLOR_MATRIX_RED_BIAS:
         if (ctx->Pixel.PostColorMatrixBias[0] == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
         ctx->Pixel.PostColorMatrixBias[0] = param;
	 break;
      case GL_POST_COLOR_MATRIX_GREEN_SCALE:
         if (ctx->Pixel.PostColorMatrixScale[1] == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
         ctx->Pixel.PostColorMatrixScale[1] = param;
	 break;
      case GL_POST_COLOR_MATRIX_GREEN_BIAS:
         if (ctx->Pixel.PostColorMatrixBias[1] == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
         ctx->Pixel.PostColorMatrixBias[1] = param;
	 break;
      case GL_POST_COLOR_MATRIX_BLUE_SCALE:
         if (ctx->Pixel.PostColorMatrixScale[2] == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
         ctx->Pixel.PostColorMatrixScale[2] = param;
	 break;
      case GL_POST_COLOR_MATRIX_BLUE_BIAS:
         if (ctx->Pixel.PostColorMatrixBias[2] == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
         ctx->Pixel.PostColorMatrixBias[2] = param;
	 break;
      case GL_POST_COLOR_MATRIX_ALPHA_SCALE:
         if (ctx->Pixel.PostColorMatrixScale[3] == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
         ctx->Pixel.PostColorMatrixScale[3] = param;
	 break;
      case GL_POST_COLOR_MATRIX_ALPHA_BIAS:
         if (ctx->Pixel.PostColorMatrixBias[3] == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
         ctx->Pixel.PostColorMatrixBias[3] = param;
	 break;
      case GL_POST_CONVOLUTION_RED_SCALE:
         if (ctx->Pixel.PostConvolutionScale[0] == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
         ctx->Pixel.PostConvolutionScale[0] = param;
	 break;
      case GL_POST_CONVOLUTION_RED_BIAS:
         if (ctx->Pixel.PostConvolutionBias[0] == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
         ctx->Pixel.PostConvolutionBias[0] = param;
	 break;
      case GL_POST_CONVOLUTION_GREEN_SCALE:
         if (ctx->Pixel.PostConvolutionScale[1] == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
         ctx->Pixel.PostConvolutionScale[1] = param;
	 break;
      case GL_POST_CONVOLUTION_GREEN_BIAS:
         if (ctx->Pixel.PostConvolutionBias[1] == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
         ctx->Pixel.PostConvolutionBias[1] = param;
	 break;
      case GL_POST_CONVOLUTION_BLUE_SCALE:
         if (ctx->Pixel.PostConvolutionScale[2] == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
         ctx->Pixel.PostConvolutionScale[2] = param;
	 break;
      case GL_POST_CONVOLUTION_BLUE_BIAS:
         if (ctx->Pixel.PostConvolutionBias[2] == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
         ctx->Pixel.PostConvolutionBias[2] = param;
	 break;
      case GL_POST_CONVOLUTION_ALPHA_SCALE:
         if (ctx->Pixel.PostConvolutionScale[3] == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
         ctx->Pixel.PostConvolutionScale[3] = param;
	 break;
      case GL_POST_CONVOLUTION_ALPHA_BIAS:
         if (ctx->Pixel.PostConvolutionBias[3] == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
         ctx->Pixel.PostConvolutionBias[3] = param;
	 break;
d593 1
a593 1
update_image_transfer_state(GLcontext *ctx)
a608 42
   if (ctx->Pixel.ColorTableEnabled[COLORTABLE_PRECONVOLUTION])
      mask |= IMAGE_COLOR_TABLE_BIT;

   if (ctx->Pixel.Convolution1DEnabled ||
       ctx->Pixel.Convolution2DEnabled ||
       ctx->Pixel.Separable2DEnabled) {
      mask |= IMAGE_CONVOLUTION_BIT;
      if (ctx->Pixel.PostConvolutionScale[0] != 1.0F ||
          ctx->Pixel.PostConvolutionScale[1] != 1.0F ||
          ctx->Pixel.PostConvolutionScale[2] != 1.0F ||
          ctx->Pixel.PostConvolutionScale[3] != 1.0F ||
          ctx->Pixel.PostConvolutionBias[0] != 0.0F ||
          ctx->Pixel.PostConvolutionBias[1] != 0.0F ||
          ctx->Pixel.PostConvolutionBias[2] != 0.0F ||
          ctx->Pixel.PostConvolutionBias[3] != 0.0F) {
         mask |= IMAGE_POST_CONVOLUTION_SCALE_BIAS;
      }
   }

   if (ctx->Pixel.ColorTableEnabled[COLORTABLE_POSTCONVOLUTION])
      mask |= IMAGE_POST_CONVOLUTION_COLOR_TABLE_BIT;

   if (ctx->ColorMatrixStack.Top->type != MATRIX_IDENTITY ||
       ctx->Pixel.PostColorMatrixScale[0] != 1.0F ||
       ctx->Pixel.PostColorMatrixBias[0]  != 0.0F ||
       ctx->Pixel.PostColorMatrixScale[1] != 1.0F ||
       ctx->Pixel.PostColorMatrixBias[1]  != 0.0F ||
       ctx->Pixel.PostColorMatrixScale[2] != 1.0F ||
       ctx->Pixel.PostColorMatrixBias[2]  != 0.0F ||
       ctx->Pixel.PostColorMatrixScale[3] != 1.0F ||
       ctx->Pixel.PostColorMatrixBias[3]  != 0.0F)
      mask |= IMAGE_COLOR_MATRIX_BIT;

   if (ctx->Pixel.ColorTableEnabled[COLORTABLE_POSTCOLORMATRIX])
      mask |= IMAGE_POST_COLOR_MATRIX_COLOR_TABLE_BIT;

   if (ctx->Pixel.HistogramEnabled)
      mask |= IMAGE_HISTOGRAM_BIT;

   if (ctx->Pixel.MinMaxEnabled)
      mask |= IMAGE_MIN_MAX_BIT;

d616 1
a616 1
void _mesa_update_pixel( GLcontext *ctx, GLuint new_state )
a617 5
   if (new_state & _NEW_COLOR_MATRIX)
      _math_matrix_analyse( ctx->ColorMatrixStack.Top );

   /* References ColorMatrix.type (derived above).
    */
d658 1
a658 1
_mesa_init_pixel( GLcontext *ctx )
a659 2
   int i;

a686 25
   ctx->Pixel.HistogramEnabled = GL_FALSE;
   ctx->Pixel.MinMaxEnabled = GL_FALSE;
   ASSIGN_4V(ctx->Pixel.PostColorMatrixScale, 1.0, 1.0, 1.0, 1.0);
   ASSIGN_4V(ctx->Pixel.PostColorMatrixBias, 0.0, 0.0, 0.0, 0.0);
   for (i = 0; i < COLORTABLE_MAX; i++) {
      ASSIGN_4V(ctx->Pixel.ColorTableScale[i], 1.0, 1.0, 1.0, 1.0);
      ASSIGN_4V(ctx->Pixel.ColorTableBias[i], 0.0, 0.0, 0.0, 0.0);
      ctx->Pixel.ColorTableEnabled[i] = GL_FALSE;
   }
   ctx->Pixel.Convolution1DEnabled = GL_FALSE;
   ctx->Pixel.Convolution2DEnabled = GL_FALSE;
   ctx->Pixel.Separable2DEnabled = GL_FALSE;
   for (i = 0; i < 3; i++) {
      ASSIGN_4V(ctx->Pixel.ConvolutionBorderColor[i], 0.0, 0.0, 0.0, 0.0);
      ctx->Pixel.ConvolutionBorderMode[i] = GL_REDUCE;
      ASSIGN_4V(ctx->Pixel.ConvolutionFilterScale[i], 1.0, 1.0, 1.0, 1.0);
      ASSIGN_4V(ctx->Pixel.ConvolutionFilterBias[i], 0.0, 0.0, 0.0, 0.0);
   }
   for (i = 0; i < MAX_CONVOLUTION_WIDTH * MAX_CONVOLUTION_WIDTH * 4; i++) {
      ctx->Convolution1D.Filter[i] = 0.0;
      ctx->Convolution2D.Filter[i] = 0.0;
      ctx->Separable2D.Filter[i] = 0.0;
   }
   ASSIGN_4V(ctx->Pixel.PostConvolutionScale, 1.0, 1.0, 1.0, 1.0);
   ASSIGN_4V(ctx->Pixel.PostConvolutionBias, 0.0, 0.0, 0.0, 0.0);
@


1.2
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@a34 1
#include "image.h"
d38 4
d48 1
a48 1
void GLAPIENTRY
d142 32
a173 1
void GLAPIENTRY
d195 8
a202 18
   if (ctx->Unpack.BufferObj->Name) {
      /* unpack pixelmap from PBO */
      GLubyte *buf;
      /* Note, need to use DefaultPacking and Unpack's buffer object */
      ctx->DefaultPacking.BufferObj = ctx->Unpack.BufferObj;
      if (!_mesa_validate_pbo_access(1, &ctx->DefaultPacking, mapsize, 1, 1,
                                     GL_INTENSITY, GL_FLOAT, values)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glPixelMapfv(invalid PBO access)");
         return;
      }
      /* restore */
      ctx->DefaultPacking.BufferObj = ctx->Array.NullBufferObj;
      buf = (GLubyte *) ctx->Driver.MapBuffer(ctx, GL_PIXEL_UNPACK_BUFFER_EXT,
                                              GL_READ_ONLY_ARB,
                                              ctx->Unpack.BufferObj);
      if (!buf) {
         /* buffer is already mapped - that's an error */
a204 1
         return;
a205 3
      values = (const GLfloat *) ADD_POINTERS(buf, values);
   }
   else if (!values) {
d211 1
a211 4
   if (ctx->Unpack.BufferObj->Name) {
      ctx->Driver.UnmapBuffer(ctx, GL_PIXEL_UNPACK_BUFFER_EXT,
                              ctx->Unpack.BufferObj);
   }
d215 1
a215 1
void GLAPIENTRY
d237 8
a244 18
   if (ctx->Unpack.BufferObj->Name) {
      /* unpack pixelmap from PBO */
      GLubyte *buf;
      /* Note, need to use DefaultPacking and Unpack's buffer object */
      ctx->DefaultPacking.BufferObj = ctx->Unpack.BufferObj;
      if (!_mesa_validate_pbo_access(1, &ctx->DefaultPacking, mapsize, 1, 1,
                                     GL_INTENSITY, GL_UNSIGNED_INT, values)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glPixelMapuiv(invalid PBO access)");
         return;
      }
      /* restore */
      ctx->DefaultPacking.BufferObj = ctx->Array.NullBufferObj;
      buf = (GLubyte *) ctx->Driver.MapBuffer(ctx, GL_PIXEL_UNPACK_BUFFER_EXT,
                                              GL_READ_ONLY_ARB,
                                              ctx->Unpack.BufferObj);
      if (!buf) {
         /* buffer is already mapped - that's an error */
a246 1
         return;
a247 3
      values = (const GLuint *) ADD_POINTERS(buf, values);
   }
   else if (!values) {
d265 1
a265 4
   if (ctx->Unpack.BufferObj->Name) {
      ctx->Driver.UnmapBuffer(ctx, GL_PIXEL_UNPACK_BUFFER_EXT,
                              ctx->Unpack.BufferObj);
   }
d271 1
a271 1
void GLAPIENTRY
d293 8
a300 19
   if (ctx->Unpack.BufferObj->Name) {
      /* unpack pixelmap from PBO */
      GLubyte *buf;
      /* Note, need to use DefaultPacking and Unpack's buffer object */
      ctx->DefaultPacking.BufferObj = ctx->Unpack.BufferObj;
      if (!_mesa_validate_pbo_access(1, &ctx->DefaultPacking, mapsize, 1, 1,
                                     GL_INTENSITY, GL_UNSIGNED_SHORT,
                                     values)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glPixelMapusv(invalid PBO access)");
         return;
      }
      /* restore */
      ctx->DefaultPacking.BufferObj = ctx->Array.NullBufferObj;
      buf = (GLubyte *) ctx->Driver.MapBuffer(ctx, GL_PIXEL_UNPACK_BUFFER_EXT,
                                              GL_READ_ONLY_ARB,
                                              ctx->Unpack.BufferObj);
      if (!buf) {
         /* buffer is already mapped - that's an error */
a302 1
         return;
a303 3
      values = (const GLushort *) ADD_POINTERS(buf, values);
   }
   else if (!values) {
d321 1
a321 4
   if (ctx->Unpack.BufferObj->Name) {
      ctx->Driver.UnmapBuffer(ctx, GL_PIXEL_UNPACK_BUFFER_EXT,
                              ctx->Unpack.BufferObj);
   }
d327 1
a327 1
void GLAPIENTRY
d344 8
a351 18
   if (ctx->Pack.BufferObj->Name) {
      /* pack pixelmap into PBO */
      GLubyte *buf;
      /* Note, need to use DefaultPacking and Pack's buffer object */
      ctx->DefaultPacking.BufferObj = ctx->Pack.BufferObj;
      if (!_mesa_validate_pbo_access(1, &ctx->DefaultPacking, mapsize, 1, 1,
                                     GL_INTENSITY, GL_FLOAT, values)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glGetPixelMapfv(invalid PBO access)");
         return;
      }
      /* restore */
      ctx->DefaultPacking.BufferObj = ctx->Array.NullBufferObj;
      buf = (GLubyte *) ctx->Driver.MapBuffer(ctx, GL_PIXEL_PACK_BUFFER_EXT,
                                              GL_WRITE_ONLY_ARB,
                                              ctx->Pack.BufferObj);
      if (!buf) {
         /* buffer is already mapped - that's an error */
a353 1
         return;
a354 3
      values = (GLfloat *) ADD_POINTERS(buf, values);
   }
   else if (!values) {
d365 1
a365 1
      MEMCPY(values, pm->Map, mapsize * sizeof(GLfloat));
d368 1
a368 4
   if (ctx->Pack.BufferObj->Name) {
      ctx->Driver.UnmapBuffer(ctx, GL_PIXEL_PACK_BUFFER_EXT,
                              ctx->Pack.BufferObj);
   }
d372 1
a372 1
void GLAPIENTRY
d388 8
a395 18
   if (ctx->Pack.BufferObj->Name) {
      /* pack pixelmap into PBO */
      GLubyte *buf;
      /* Note, need to use DefaultPacking and Pack's buffer object */
      ctx->DefaultPacking.BufferObj = ctx->Pack.BufferObj;
      if (!_mesa_validate_pbo_access(1, &ctx->DefaultPacking, mapsize, 1, 1,
                                     GL_INTENSITY, GL_UNSIGNED_INT, values)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glGetPixelMapuiv(invalid PBO access)");
         return;
      }
      /* restore */
      ctx->DefaultPacking.BufferObj = ctx->Array.NullBufferObj;
      buf = (GLubyte *) ctx->Driver.MapBuffer(ctx, GL_PIXEL_PACK_BUFFER_EXT,
                                              GL_WRITE_ONLY_ARB,
                                              ctx->Pack.BufferObj);
      if (!buf) {
         /* buffer is already mapped - that's an error */
a397 1
         return;
a398 3
      values = (GLuint *) ADD_POINTERS(buf, values);
   }
   else if (!values) {
d404 1
a404 1
      MEMCPY(values, ctx->PixelMaps.StoS.Map, mapsize * sizeof(GLint));
d412 1
a412 4
   if (ctx->Pack.BufferObj->Name) {
      ctx->Driver.UnmapBuffer(ctx, GL_PIXEL_PACK_BUFFER_EXT,
                              ctx->Pack.BufferObj);
   }
d416 1
a416 1
void GLAPIENTRY
d430 1
a430 1
   mapsize = pm ? pm->Size : 0;
d432 8
a439 19
   if (ctx->Pack.BufferObj->Name) {
      /* pack pixelmap into PBO */
      GLubyte *buf;
      /* Note, need to use DefaultPacking and Pack's buffer object */
      ctx->DefaultPacking.BufferObj = ctx->Pack.BufferObj;
      if (!_mesa_validate_pbo_access(1, &ctx->DefaultPacking, mapsize, 1, 1,
                                     GL_INTENSITY, GL_UNSIGNED_SHORT,
                                     values)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glGetPixelMapusv(invalid PBO access)");
         return;
      }
      /* restore */
      ctx->DefaultPacking.BufferObj = ctx->Array.NullBufferObj;
      buf = (GLubyte *) ctx->Driver.MapBuffer(ctx, GL_PIXEL_PACK_BUFFER_EXT,
                                              GL_WRITE_ONLY_ARB,
                                              ctx->Pack.BufferObj);
      if (!buf) {
         /* buffer is already mapped - that's an error */
a441 1
         return;
a442 3
      values = (GLushort *) ADD_POINTERS(buf, values);
   }
   else if (!values) {
d464 1
a464 4
   if (ctx->Pack.BufferObj->Name) {
      ctx->Driver.UnmapBuffer(ctx, GL_PIXEL_PACK_BUFFER_EXT,
                              ctx->Pack.BufferObj);
   }
d478 1
a478 1
void GLAPIENTRY
d672 1
a672 1
void GLAPIENTRY
d752 1
a752 1
 * Update meas pixel transfer derived state.
d761 1
a761 1
   if (new_state & _IMAGE_NEW_TRANSFER_STATE)
d764 18
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * Version:  6.5
d5 1
a5 1
 * Copyright (C) 1999-2005  Brian Paul   All Rights Reserved.
d25 6
a44 2


d62 1
a62 1
/*****                    glPixelStore                            *****/
d65 5
a69 3

void GLAPIENTRY
_mesa_PixelStorei( GLenum pname, GLint param )
d71 23
a93 174
   /* NOTE: this call can't be compiled into the display list */
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   switch (pname) {
      case GL_PACK_SWAP_BYTES:
	 if (param == (GLint)ctx->Pack.SwapBytes)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PACKUNPACK);
         ctx->Pack.SwapBytes = param ? GL_TRUE : GL_FALSE;
	 break;
      case GL_PACK_LSB_FIRST:
	 if (param == (GLint)ctx->Pack.LsbFirst)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PACKUNPACK);
         ctx->Pack.LsbFirst = param ? GL_TRUE : GL_FALSE;
	 break;
      case GL_PACK_ROW_LENGTH:
	 if (param<0) {
	    _mesa_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
	    return;
	 }
	 if (ctx->Pack.RowLength == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PACKUNPACK);
	 ctx->Pack.RowLength = param;
	 break;
      case GL_PACK_IMAGE_HEIGHT:
         if (param<0) {
            _mesa_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
	    return;
	 }
	 if (ctx->Pack.ImageHeight == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PACKUNPACK);
	 ctx->Pack.ImageHeight = param;
         break;
      case GL_PACK_SKIP_PIXELS:
	 if (param<0) {
	    _mesa_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
	    return;
	 }
	 if (ctx->Pack.SkipPixels == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PACKUNPACK);
	 ctx->Pack.SkipPixels = param;
	 break;
      case GL_PACK_SKIP_ROWS:
	 if (param<0) {
	    _mesa_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
	    return;
	 }
	 if (ctx->Pack.SkipRows == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PACKUNPACK);
	 ctx->Pack.SkipRows = param;
	 break;
      case GL_PACK_SKIP_IMAGES:
	 if (param<0) {
	    _mesa_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
	    return;
	 }
	 if (ctx->Pack.SkipImages == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PACKUNPACK);
	 ctx->Pack.SkipImages = param;
	 break;
      case GL_PACK_ALIGNMENT:
         if (param!=1 && param!=2 && param!=4 && param!=8) {
	    _mesa_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
	    return;
	 }
	 if (ctx->Pack.Alignment == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PACKUNPACK);
	 ctx->Pack.Alignment = param;
	 break;
      case GL_PACK_INVERT_MESA:
         if (!ctx->Extensions.MESA_pack_invert) {
            _mesa_error( ctx, GL_INVALID_ENUM, "glPixelstore(pname)" );
            return;
         }
         if (ctx->Pack.Invert == param)
            return;
         FLUSH_VERTICES(ctx, _NEW_PACKUNPACK);
         ctx->Pack.Invert = param;
         break;

      case GL_UNPACK_SWAP_BYTES:
	 if (param == (GLint)ctx->Unpack.SwapBytes)
	    return;
	 if ((GLint)ctx->Unpack.SwapBytes == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PACKUNPACK);
	 ctx->Unpack.SwapBytes = param ? GL_TRUE : GL_FALSE;
         break;
      case GL_UNPACK_LSB_FIRST:
	 if (param == (GLint)ctx->Unpack.LsbFirst)
	    return;
	 if ((GLint)ctx->Unpack.LsbFirst == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PACKUNPACK);
	 ctx->Unpack.LsbFirst = param ? GL_TRUE : GL_FALSE;
	 break;
      case GL_UNPACK_ROW_LENGTH:
	 if (param<0) {
	    _mesa_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
	    return;
	 }
	 if (ctx->Unpack.RowLength == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PACKUNPACK);
	 ctx->Unpack.RowLength = param;
	 break;
      case GL_UNPACK_IMAGE_HEIGHT:
         if (param<0) {
            _mesa_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
	    return;
	 }
	 if (ctx->Unpack.ImageHeight == param)
	    return;

	 FLUSH_VERTICES(ctx, _NEW_PACKUNPACK);
	 ctx->Unpack.ImageHeight = param;
         break;
      case GL_UNPACK_SKIP_PIXELS:
	 if (param<0) {
	    _mesa_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
	    return;
	 }
	 if (ctx->Unpack.SkipPixels == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PACKUNPACK);
	 ctx->Unpack.SkipPixels = param;
	 break;
      case GL_UNPACK_SKIP_ROWS:
	 if (param<0) {
	    _mesa_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
	    return;
	 }
	 if (ctx->Unpack.SkipRows == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PACKUNPACK);
	 ctx->Unpack.SkipRows = param;
	 break;
      case GL_UNPACK_SKIP_IMAGES:
	 if (param < 0) {
	    _mesa_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
	    return;
	 }
	 if (ctx->Unpack.SkipImages == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PACKUNPACK);
	 ctx->Unpack.SkipImages = param;
	 break;
      case GL_UNPACK_ALIGNMENT:
         if (param!=1 && param!=2 && param!=4 && param!=8) {
	    _mesa_error( ctx, GL_INVALID_VALUE, "glPixelStore" );
	    return;
	 }
	 if (ctx->Unpack.Alignment == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PACKUNPACK);
	 ctx->Unpack.Alignment = param;
	 break;
      case GL_UNPACK_CLIENT_STORAGE_APPLE:
         if (param == (GLint)ctx->Unpack.ClientStorage)
            return;
         FLUSH_VERTICES(ctx, _NEW_PACKUNPACK);
         ctx->Unpack.ClientStorage = param ? GL_TRUE : GL_FALSE;
         break;
      default:
	 _mesa_error( ctx, GL_INVALID_ENUM, "glPixelStore" );
	 return;
a97 13
void GLAPIENTRY
_mesa_PixelStoref( GLenum pname, GLfloat param )
{
   _mesa_PixelStorei( pname, (GLint) param );
}



/**********************************************************************/
/*****                         glPixelMap                         *****/
/**********************************************************************/


d102 2
a103 1
pixelmap(GLcontext *ctx, GLenum map, GLsizei mapsize, const GLfloat *values)
d106 6
d113 22
a134 70
      case GL_PIXEL_MAP_S_TO_S:
         ctx->Pixel.MapStoSsize = mapsize;
         for (i = 0; i < mapsize; i++) {
	    ctx->Pixel.MapStoS[i] = IROUND(values[i]);
	 }
	 break;
      case GL_PIXEL_MAP_I_TO_I:
         ctx->Pixel.MapItoIsize = mapsize;
         for (i = 0; i < mapsize; i++) {
	    ctx->Pixel.MapItoI[i] = values[i];
	 }
	 break;
      case GL_PIXEL_MAP_I_TO_R:
         ctx->Pixel.MapItoRsize = mapsize;
         for (i = 0; i < mapsize; i++) {
            GLfloat val = CLAMP( values[i], 0.0F, 1.0F );
	    ctx->Pixel.MapItoR[i] = val;
	    ctx->Pixel.MapItoR8[i] = (GLint) (val * 255.0F);
	 }
	 break;
      case GL_PIXEL_MAP_I_TO_G:
         ctx->Pixel.MapItoGsize = mapsize;
         for (i = 0; i < mapsize; i++) {
            GLfloat val = CLAMP( values[i], 0.0F, 1.0F );
	    ctx->Pixel.MapItoG[i] = val;
	    ctx->Pixel.MapItoG8[i] = (GLint) (val * 255.0F);
	 }
	 break;
      case GL_PIXEL_MAP_I_TO_B:
         ctx->Pixel.MapItoBsize = mapsize;
         for (i = 0; i < mapsize; i++) {
            GLfloat val = CLAMP( values[i], 0.0F, 1.0F );
	    ctx->Pixel.MapItoB[i] = val;
	    ctx->Pixel.MapItoB8[i] = (GLint) (val * 255.0F);
	 }
	 break;
      case GL_PIXEL_MAP_I_TO_A:
         ctx->Pixel.MapItoAsize = mapsize;
         for (i = 0; i < mapsize; i++) {
            GLfloat val = CLAMP( values[i], 0.0F, 1.0F );
	    ctx->Pixel.MapItoA[i] = val;
	    ctx->Pixel.MapItoA8[i] = (GLint) (val * 255.0F);
	 }
	 break;
      case GL_PIXEL_MAP_R_TO_R:
         ctx->Pixel.MapRtoRsize = mapsize;
         for (i = 0; i < mapsize; i++) {
	    ctx->Pixel.MapRtoR[i] = CLAMP( values[i], 0.0F, 1.0F );
	 }
	 break;
      case GL_PIXEL_MAP_G_TO_G:
         ctx->Pixel.MapGtoGsize = mapsize;
         for (i = 0; i < mapsize; i++) {
	    ctx->Pixel.MapGtoG[i] = CLAMP( values[i], 0.0F, 1.0F );
	 }
	 break;
      case GL_PIXEL_MAP_B_TO_B:
         ctx->Pixel.MapBtoBsize = mapsize;
         for (i = 0; i < mapsize; i++) {
	    ctx->Pixel.MapBtoB[i] = CLAMP( values[i], 0.0F, 1.0F );
	 }
	 break;
      case GL_PIXEL_MAP_A_TO_A:
         ctx->Pixel.MapAtoAsize = mapsize;
         for (i = 0; i < mapsize; i++) {
	    ctx->Pixel.MapAtoA[i] = CLAMP( values[i], 0.0F, 1.0F );
	 }
	 break;
      default:
         _mesa_error( ctx, GL_INVALID_ENUM, "glPixelMap(map)" );
d153 1
a153 1
      if (_mesa_bitcount((GLuint) mapsize) != 1) {
d189 1
a189 1
   pixelmap(ctx, map, mapsize, values);
a197 1

d212 1
a212 1
      if (_mesa_bitcount((GLuint) mapsize) != 1) {
d267 1
a267 1
   pixelmap(ctx, map, mapsize, fvalues);
a270 1

d285 1
a285 1
      if (_mesa_bitcount((GLuint) mapsize) != 1) {
d322 1
a322 1
    /* convert to floats */
d341 1
a341 34
   pixelmap(ctx, map, mapsize, fvalues);
}


/**
 * Return size of the named map.
 */
static GLuint
get_map_size(GLcontext *ctx, GLenum map)
{
   switch (map) {
      case GL_PIXEL_MAP_I_TO_I:
         return ctx->Pixel.MapItoIsize;
      case GL_PIXEL_MAP_S_TO_S:
         return ctx->Pixel.MapStoSsize;
      case GL_PIXEL_MAP_I_TO_R:
         return ctx->Pixel.MapItoRsize;
      case GL_PIXEL_MAP_I_TO_G:
         return ctx->Pixel.MapItoGsize;
      case GL_PIXEL_MAP_I_TO_B:
         return ctx->Pixel.MapItoBsize;
      case GL_PIXEL_MAP_I_TO_A:
         return ctx->Pixel.MapItoAsize;
      case GL_PIXEL_MAP_R_TO_R:
         return ctx->Pixel.MapRtoRsize;
      case GL_PIXEL_MAP_G_TO_G:
         return ctx->Pixel.MapGtoGsize;
      case GL_PIXEL_MAP_B_TO_B:
         return ctx->Pixel.MapBtoBsize;
      case GL_PIXEL_MAP_A_TO_A:
         return ctx->Pixel.MapAtoAsize;
      default:
         return 0;
   }
d350 2
d354 7
a360 1
   mapsize = get_map_size(ctx, map);
d390 8
a397 35
   switch (map) {
      case GL_PIXEL_MAP_I_TO_I:
         MEMCPY(values, ctx->Pixel.MapItoI, mapsize * sizeof(GLfloat));
	 break;
      case GL_PIXEL_MAP_S_TO_S:
         for (i = 0; i < mapsize; i++) {
	    values[i] = (GLfloat) ctx->Pixel.MapStoS[i];
	 }
	 break;
      case GL_PIXEL_MAP_I_TO_R:
         MEMCPY(values, ctx->Pixel.MapItoR, mapsize * sizeof(GLfloat));
	 break;
      case GL_PIXEL_MAP_I_TO_G:
         MEMCPY(values, ctx->Pixel.MapItoG, mapsize * sizeof(GLfloat));
	 break;
      case GL_PIXEL_MAP_I_TO_B:
         MEMCPY(values, ctx->Pixel.MapItoB, mapsize * sizeof(GLfloat));
	 break;
      case GL_PIXEL_MAP_I_TO_A:
         MEMCPY(values, ctx->Pixel.MapItoA, mapsize * sizeof(GLfloat));
	 break;
      case GL_PIXEL_MAP_R_TO_R:
         MEMCPY(values, ctx->Pixel.MapRtoR, mapsize * sizeof(GLfloat));
	 break;
      case GL_PIXEL_MAP_G_TO_G:
         MEMCPY(values, ctx->Pixel.MapGtoG, mapsize * sizeof(GLfloat));
	 break;
      case GL_PIXEL_MAP_B_TO_B:
         MEMCPY(values, ctx->Pixel.MapBtoB, mapsize * sizeof(GLfloat));
	 break;
      case GL_PIXEL_MAP_A_TO_A:
         MEMCPY(values, ctx->Pixel.MapAtoA, mapsize * sizeof(GLfloat));
	 break;
      default:
         _mesa_error( ctx, GL_INVALID_ENUM, "glGetPixelMapfv" );
d412 2
d416 6
a421 1
   mapsize = get_map_size(ctx, map);
d451 8
a458 51
   switch (map) {
      case GL_PIXEL_MAP_I_TO_I:
	 for (i = 0; i < mapsize; i++) {
	    values[i] = FLOAT_TO_UINT( ctx->Pixel.MapItoI[i] );
	 }
	 break;
      case GL_PIXEL_MAP_S_TO_S:
         MEMCPY(values, ctx->Pixel.MapStoS, mapsize * sizeof(GLint));
	 break;
      case GL_PIXEL_MAP_I_TO_R:
	 for (i = 0; i < mapsize; i++) {
	    values[i] = FLOAT_TO_UINT( ctx->Pixel.MapItoR[i] );
	 }
	 break;
      case GL_PIXEL_MAP_I_TO_G:
	 for (i = 0; i < mapsize; i++) {
	    values[i] = FLOAT_TO_UINT( ctx->Pixel.MapItoG[i] );
	 }
	 break;
      case GL_PIXEL_MAP_I_TO_B:
	 for (i = 0; i < mapsize; i++) {
	    values[i] = FLOAT_TO_UINT( ctx->Pixel.MapItoB[i] );
	 }
	 break;
      case GL_PIXEL_MAP_I_TO_A:
	 for (i = 0; i < mapsize; i++) {
	    values[i] = FLOAT_TO_UINT( ctx->Pixel.MapItoA[i] );
	 }
	 break;
      case GL_PIXEL_MAP_R_TO_R:
	 for (i = 0; i < mapsize; i++) {
	    values[i] = FLOAT_TO_UINT( ctx->Pixel.MapRtoR[i] );
	 }
	 break;
      case GL_PIXEL_MAP_G_TO_G:
	 for (i = 0; i < mapsize; i++) {
	    values[i] = FLOAT_TO_UINT( ctx->Pixel.MapGtoG[i] );
	 }
	 break;
      case GL_PIXEL_MAP_B_TO_B:
	 for (i = 0; i < mapsize; i++) {
	    values[i] = FLOAT_TO_UINT( ctx->Pixel.MapBtoB[i] );
	 }
	 break;
      case GL_PIXEL_MAP_A_TO_A:
	 for (i = 0; i < mapsize; i++) {
	    values[i] = FLOAT_TO_UINT( ctx->Pixel.MapAtoA[i] );
	 }
	 break;
      default:
         _mesa_error( ctx, GL_INVALID_ENUM, "glGetPixelMapfv" );
d473 2
d477 6
a482 1
   mapsize = get_map_size(ctx, map);
d514 15
a528 52
      case GL_PIXEL_MAP_I_TO_I:
	 for (i = 0; i < mapsize; i++) {
            values[i] = (GLushort) CLAMP(ctx->Pixel.MapItoI[i], 0.0, 65535.0);
	 }
	 break;
      case GL_PIXEL_MAP_S_TO_S:
	 for (i = 0; i < mapsize; i++) {
            values[i] = (GLushort) CLAMP(ctx->Pixel.MapStoS[i], 0.0, 65535.0);
	 }
	 break;
      case GL_PIXEL_MAP_I_TO_R:
	 for (i = 0; i < mapsize; i++) {
	    CLAMPED_FLOAT_TO_USHORT(values[i] , ctx->Pixel.MapItoR[i] );
	 }
	 break;
      case GL_PIXEL_MAP_I_TO_G:
	 for (i = 0; i < mapsize; i++) {
	    CLAMPED_FLOAT_TO_USHORT(values[i] , ctx->Pixel.MapItoG[i] );
	 }
	 break;
      case GL_PIXEL_MAP_I_TO_B:
	 for (i = 0; i < mapsize; i++) {
	    CLAMPED_FLOAT_TO_USHORT(values[i] , ctx->Pixel.MapItoB[i] );
	 }
	 break;
      case GL_PIXEL_MAP_I_TO_A:
	 for (i = 0; i < mapsize; i++) {
	    CLAMPED_FLOAT_TO_USHORT(values[i] , ctx->Pixel.MapItoA[i] );
	 }
	 break;
      case GL_PIXEL_MAP_R_TO_R:
	 for (i = 0; i < mapsize; i++) {
	    CLAMPED_FLOAT_TO_USHORT(values[i] , ctx->Pixel.MapRtoR[i] );
	 }
	 break;
      case GL_PIXEL_MAP_G_TO_G:
	 for (i = 0; i < mapsize; i++) {
	    CLAMPED_FLOAT_TO_USHORT(values[i] , ctx->Pixel.MapGtoG[i] );
	 }
	 break;
      case GL_PIXEL_MAP_B_TO_B:
	 for (i = 0; i < mapsize; i++) {
	    CLAMPED_FLOAT_TO_USHORT(values[i] , ctx->Pixel.MapBtoB[i] );
	 }
	 break;
      case GL_PIXEL_MAP_A_TO_A:
	 for (i = 0; i < mapsize; i++) {
	    CLAMPED_FLOAT_TO_USHORT(values[i] , ctx->Pixel.MapAtoA[i] );
	 }
	 break;
      default:
         _mesa_error( ctx, GL_INVALID_ENUM, "glGetPixelMapfv" );
d724 1
a724 1
         if (ctx->Pixel.PostConvolutionScale[2] == param)
d727 1
a727 1
         ctx->Pixel.PostConvolutionScale[2] = param;
d730 1
a730 1
         if (ctx->Pixel.PostConvolutionBias[2] == param)
d733 1
a733 1
         ctx->Pixel.PostConvolutionBias[2] = param;
a750 833
/*****                  Pixel processing functions               ******/
/**********************************************************************/

/*
 * Apply scale and bias factors to an array of RGBA pixels.
 */
void
_mesa_scale_and_bias_rgba(GLuint n, GLfloat rgba[][4],
                          GLfloat rScale, GLfloat gScale,
                          GLfloat bScale, GLfloat aScale,
                          GLfloat rBias, GLfloat gBias,
                          GLfloat bBias, GLfloat aBias)
{
   if (rScale != 1.0 || rBias != 0.0) {
      GLuint i;
      for (i = 0; i < n; i++) {
         rgba[i][RCOMP] = rgba[i][RCOMP] * rScale + rBias;
      }
   }
   if (gScale != 1.0 || gBias != 0.0) {
      GLuint i;
      for (i = 0; i < n; i++) {
         rgba[i][GCOMP] = rgba[i][GCOMP] * gScale + gBias;
      }
   }
   if (bScale != 1.0 || bBias != 0.0) {
      GLuint i;
      for (i = 0; i < n; i++) {
         rgba[i][BCOMP] = rgba[i][BCOMP] * bScale + bBias;
      }
   }
   if (aScale != 1.0 || aBias != 0.0) {
      GLuint i;
      for (i = 0; i < n; i++) {
         rgba[i][ACOMP] = rgba[i][ACOMP] * aScale + aBias;
      }
   }
}


/*
 * Apply pixel mapping to an array of floating point RGBA pixels.
 */
void
_mesa_map_rgba( const GLcontext *ctx, GLuint n, GLfloat rgba[][4] )
{
   const GLfloat rscale = (GLfloat) (ctx->Pixel.MapRtoRsize - 1);
   const GLfloat gscale = (GLfloat) (ctx->Pixel.MapGtoGsize - 1);
   const GLfloat bscale = (GLfloat) (ctx->Pixel.MapBtoBsize - 1);
   const GLfloat ascale = (GLfloat) (ctx->Pixel.MapAtoAsize - 1);
   const GLfloat *rMap = ctx->Pixel.MapRtoR;
   const GLfloat *gMap = ctx->Pixel.MapGtoG;
   const GLfloat *bMap = ctx->Pixel.MapBtoB;
   const GLfloat *aMap = ctx->Pixel.MapAtoA;
   GLuint i;
   for (i=0;i<n;i++) {
      GLfloat r = CLAMP(rgba[i][RCOMP], 0.0F, 1.0F);
      GLfloat g = CLAMP(rgba[i][GCOMP], 0.0F, 1.0F);
      GLfloat b = CLAMP(rgba[i][BCOMP], 0.0F, 1.0F);
      GLfloat a = CLAMP(rgba[i][ACOMP], 0.0F, 1.0F);
      rgba[i][RCOMP] = rMap[IROUND(r * rscale)];
      rgba[i][GCOMP] = gMap[IROUND(g * gscale)];
      rgba[i][BCOMP] = bMap[IROUND(b * bscale)];
      rgba[i][ACOMP] = aMap[IROUND(a * ascale)];
   }
}


/*
 * Apply the color matrix and post color matrix scaling and biasing.
 */
void
_mesa_transform_rgba(const GLcontext *ctx, GLuint n, GLfloat rgba[][4])
{
   const GLfloat rs = ctx->Pixel.PostColorMatrixScale[0];
   const GLfloat rb = ctx->Pixel.PostColorMatrixBias[0];
   const GLfloat gs = ctx->Pixel.PostColorMatrixScale[1];
   const GLfloat gb = ctx->Pixel.PostColorMatrixBias[1];
   const GLfloat bs = ctx->Pixel.PostColorMatrixScale[2];
   const GLfloat bb = ctx->Pixel.PostColorMatrixBias[2];
   const GLfloat as = ctx->Pixel.PostColorMatrixScale[3];
   const GLfloat ab = ctx->Pixel.PostColorMatrixBias[3];
   const GLfloat *m = ctx->ColorMatrixStack.Top->m;
   GLuint i;
   for (i = 0; i < n; i++) {
      const GLfloat r = rgba[i][RCOMP];
      const GLfloat g = rgba[i][GCOMP];
      const GLfloat b = rgba[i][BCOMP];
      const GLfloat a = rgba[i][ACOMP];
      rgba[i][RCOMP] = (m[0] * r + m[4] * g + m[ 8] * b + m[12] * a) * rs + rb;
      rgba[i][GCOMP] = (m[1] * r + m[5] * g + m[ 9] * b + m[13] * a) * gs + gb;
      rgba[i][BCOMP] = (m[2] * r + m[6] * g + m[10] * b + m[14] * a) * bs + bb;
      rgba[i][ACOMP] = (m[3] * r + m[7] * g + m[11] * b + m[15] * a) * as + ab;
   }
}


/**
 * Apply a color table lookup to an array of floating point RGBA colors.
 */
void
_mesa_lookup_rgba_float(const struct gl_color_table *table,
                        GLuint n, GLfloat rgba[][4])
{
   if (!table->Table || table->Size == 0)
      return;

   switch (table->_BaseFormat) {
      case GL_INTENSITY:
         /* replace RGBA with I */
         if (table->Type == GL_FLOAT) {
            const GLint max = table->Size - 1;
            const GLfloat scale = (GLfloat) max;
            const GLfloat *lut = (const GLfloat *) table->Table;
            GLuint i;
            for (i = 0; i < n; i++) {
               GLint j = IROUND(rgba[i][RCOMP] * scale);
               GLfloat c = lut[CLAMP(j, 0, max)];
               rgba[i][RCOMP] = rgba[i][GCOMP] =
                  rgba[i][BCOMP] = rgba[i][ACOMP] = c;
            }
         }
         else {
            const GLint max = table->Size - 1;
            const GLfloat scale = (GLfloat) max;
            const GLchan *lut = (const GLchan *) table->Table;
            GLuint i;
            for (i = 0; i < n; i++) {
               GLint j = IROUND(rgba[i][RCOMP] * scale);
               GLfloat c = CHAN_TO_FLOAT(lut[CLAMP(j, 0, max)]);
               rgba[i][RCOMP] = rgba[i][GCOMP] =
                  rgba[i][BCOMP] = rgba[i][ACOMP] = c;
            }
         }
         break;
      case GL_LUMINANCE:
         /* replace RGB with L */
         if (table->Type == GL_FLOAT) {
            const GLint max = table->Size - 1;
            const GLfloat scale = (GLfloat) max;
            const GLfloat *lut = (const GLfloat *) table->Table;
            GLuint i;
            for (i = 0; i < n; i++) {
               GLint j = IROUND(rgba[i][RCOMP] * scale);
               GLfloat c = lut[CLAMP(j, 0, max)];
               rgba[i][RCOMP] = rgba[i][GCOMP] = rgba[i][BCOMP] = c;
            }
         }
         else {
            const GLint max = table->Size - 1;
            const GLfloat scale = (GLfloat) max;
            const GLchan *lut = (const GLchan *) table->Table;
            GLuint i;
            for (i = 0; i < n; i++) {
               GLint j = IROUND(rgba[i][RCOMP] * scale);
               GLfloat c = CHAN_TO_FLOAT(lut[CLAMP(j, 0, max)]);
               rgba[i][RCOMP] = rgba[i][GCOMP] = rgba[i][BCOMP] = c;
            }
         }
         break;
      case GL_ALPHA:
         /* replace A with A */
         if (table->Type == GL_FLOAT) {
            const GLint max = table->Size - 1;
            const GLfloat scale = (GLfloat) max;
            const GLfloat *lut = (const GLfloat *) table->Table;
            GLuint i;
            for (i = 0; i < n; i++) {
               GLint j = IROUND(rgba[i][ACOMP] * scale);
               rgba[i][ACOMP] = lut[CLAMP(j, 0, max)];
            }
         }
         else {
            const GLint max = table->Size - 1;
            const GLfloat scale = (GLfloat) max;
            const GLchan *lut = (const GLchan *) table->Table;
            GLuint i;
            for (i = 0; i < n; i++) {
               GLint j = IROUND(rgba[i][ACOMP] * scale);
               rgba[i][ACOMP] = CHAN_TO_FLOAT(lut[CLAMP(j, 0, max)]);
            }
         }
         break;
      case GL_LUMINANCE_ALPHA:
         /* replace RGBA with LLLA */
         if (table->Type == GL_FLOAT) {
            const GLint max = table->Size - 1;
            const GLfloat scale = (GLfloat) max;
            const GLfloat *lut = (const GLfloat *) table->Table;
            GLuint i;
            for (i = 0; i < n; i++) {
               GLint jL = IROUND(rgba[i][RCOMP] * scale);
               GLint jA = IROUND(rgba[i][ACOMP] * scale);
               GLfloat luminance, alpha;
               jL = CLAMP(jL, 0, max);
               jA = CLAMP(jA, 0, max);
               luminance = lut[jL * 2 + 0];
               alpha     = lut[jA * 2 + 1];
               rgba[i][RCOMP] = rgba[i][GCOMP] = rgba[i][BCOMP] = luminance;
               rgba[i][ACOMP] = alpha;;
            }
         }
         else {
            const GLint max = table->Size - 1;
            const GLfloat scale = (GLfloat) max;
            const GLchan *lut = (const GLchan *) table->Table;
            GLuint i;
            for (i = 0; i < n; i++) {
               GLint jL = IROUND(rgba[i][RCOMP] * scale);
               GLint jA = IROUND(rgba[i][ACOMP] * scale);
               GLfloat luminance, alpha;
               jL = CLAMP(jL, 0, max);
               jA = CLAMP(jA, 0, max);
               luminance = CHAN_TO_FLOAT(lut[jL * 2 + 0]);
               alpha     = CHAN_TO_FLOAT(lut[jA * 2 + 1]);
               rgba[i][RCOMP] = rgba[i][GCOMP] = rgba[i][BCOMP] = luminance;
               rgba[i][ACOMP] = alpha;;
            }
         }
         break;
      case GL_RGB:
         /* replace RGB with RGB */
         if (table->Type == GL_FLOAT) {
            const GLint max = table->Size - 1;
            const GLfloat scale = (GLfloat) max;
            const GLfloat *lut = (const GLfloat *) table->Table;
            GLuint i;
            for (i = 0; i < n; i++) {
               GLint jR = IROUND(rgba[i][RCOMP] * scale);
               GLint jG = IROUND(rgba[i][GCOMP] * scale);
               GLint jB = IROUND(rgba[i][BCOMP] * scale);
               jR = CLAMP(jR, 0, max);
               jG = CLAMP(jG, 0, max);
               jB = CLAMP(jB, 0, max);
               rgba[i][RCOMP] = lut[jR * 3 + 0];
               rgba[i][GCOMP] = lut[jG * 3 + 1];
               rgba[i][BCOMP] = lut[jB * 3 + 2];
            }
         }
         else {
            const GLint max = table->Size - 1;
            const GLfloat scale = (GLfloat) max;
            const GLchan *lut = (const GLchan *) table->Table;
            GLuint i;
            for (i = 0; i < n; i++) {
               GLint jR = IROUND(rgba[i][RCOMP] * scale);
               GLint jG = IROUND(rgba[i][GCOMP] * scale);
               GLint jB = IROUND(rgba[i][BCOMP] * scale);
               jR = CLAMP(jR, 0, max);
               jG = CLAMP(jG, 0, max);
               jB = CLAMP(jB, 0, max);
               rgba[i][RCOMP] = CHAN_TO_FLOAT(lut[jR * 3 + 0]);
               rgba[i][GCOMP] = CHAN_TO_FLOAT(lut[jG * 3 + 1]);
               rgba[i][BCOMP] = CHAN_TO_FLOAT(lut[jB * 3 + 2]);
            }
         }
         break;
      case GL_RGBA:
         /* replace RGBA with RGBA */
         if (table->Type == GL_FLOAT) {
            const GLint max = table->Size - 1;
            const GLfloat scale = (GLfloat) max;
            const GLfloat *lut = (const GLfloat *) table->Table;
            GLuint i;
            for (i = 0; i < n; i++) {
               GLint jR = IROUND(rgba[i][RCOMP] * scale);
               GLint jG = IROUND(rgba[i][GCOMP] * scale);
               GLint jB = IROUND(rgba[i][BCOMP] * scale);
               GLint jA = IROUND(rgba[i][ACOMP] * scale);
               jR = CLAMP(jR, 0, max);
               jG = CLAMP(jG, 0, max);
               jB = CLAMP(jB, 0, max);
               jA = CLAMP(jA, 0, max);
               rgba[i][RCOMP] = lut[jR * 4 + 0];
               rgba[i][GCOMP] = lut[jG * 4 + 1];
               rgba[i][BCOMP] = lut[jB * 4 + 2];
               rgba[i][ACOMP] = lut[jA * 4 + 3];
            }
         }
         else {
            const GLint max = table->Size - 1;
            const GLfloat scale = (GLfloat) max;
            const GLchan *lut = (const GLchan *) table->Table;
            GLuint i;
            for (i = 0; i < n; i++) {
               GLint jR = IROUND(rgba[i][RCOMP] * scale);
               GLint jG = IROUND(rgba[i][GCOMP] * scale);
               GLint jB = IROUND(rgba[i][BCOMP] * scale);
               GLint jA = IROUND(rgba[i][ACOMP] * scale);
               jR = CLAMP(jR, 0, max);
               jG = CLAMP(jG, 0, max);
               jB = CLAMP(jB, 0, max);
               jA = CLAMP(jA, 0, max);
               rgba[i][RCOMP] = CHAN_TO_FLOAT(lut[jR * 4 + 0]);
               rgba[i][GCOMP] = CHAN_TO_FLOAT(lut[jG * 4 + 1]);
               rgba[i][BCOMP] = CHAN_TO_FLOAT(lut[jB * 4 + 2]);
               rgba[i][ACOMP] = CHAN_TO_FLOAT(lut[jA * 4 + 3]);
            }
         }
         break;
      default:
         _mesa_problem(NULL, "Bad format in _mesa_lookup_rgba_float");
         return;
   }
}



/**
 * Apply a color table lookup to an array of GLchan RGBA colors.
 */
void
_mesa_lookup_rgba_chan(const struct gl_color_table *table,
                       GLuint n, GLchan rgba[][4])
{
   if (!table->Table || table->Size == 0)
      return;

   switch (table->_BaseFormat) {
      case GL_INTENSITY:
         /* replace RGBA with I */
         if (table->Type == GL_FLOAT) {
            const GLfloat scale = (GLfloat) (table->Size - 1) / CHAN_MAXF;
            const GLfloat *lut = (const GLfloat *) table->Table;
            GLuint i;
            for (i = 0; i < n; i++) {
               GLint j = IROUND((GLfloat) rgba[i][RCOMP] * scale);
               GLchan c;
               CLAMPED_FLOAT_TO_CHAN(c, lut[j]);
               rgba[i][RCOMP] = rgba[i][GCOMP] =
                  rgba[i][BCOMP] = rgba[i][ACOMP] = c;
            }
         }
         else {
#if CHAN_TYPE == GL_UNSIGNED_BYTE
            if (table->Size == 256) {
               /* common case */
               const GLchan *lut = (const GLchan *) table->Table;
               GLuint i;
               for (i = 0; i < n; i++) {
                  const GLchan c = lut[rgba[i][RCOMP]];
                  rgba[i][RCOMP] = rgba[i][GCOMP] =
                     rgba[i][BCOMP] = rgba[i][ACOMP] = c;
               }
            }
            else
#endif
            {
               const GLfloat scale = (GLfloat) (table->Size - 1) / CHAN_MAXF;
               const GLchan *lut = (const GLchan *) table->Table;
               GLuint i;
               for (i = 0; i < n; i++) {
                  GLint j = IROUND((GLfloat) rgba[i][RCOMP] * scale);
                  rgba[i][RCOMP] = rgba[i][GCOMP] =
                     rgba[i][BCOMP] = rgba[i][ACOMP] = lut[j];
               }
            }
         }
         break;
      case GL_LUMINANCE:
         /* replace RGB with L */
         if (table->Type == GL_FLOAT) {
            const GLfloat scale = (GLfloat) (table->Size - 1) / CHAN_MAXF;
            const GLfloat *lut = (const GLfloat *) table->Table;
            GLuint i;
            for (i = 0; i < n; i++) {
               GLint j = IROUND((GLfloat) rgba[i][RCOMP] * scale);
               GLchan c;
               CLAMPED_FLOAT_TO_CHAN(c, lut[j]);
               rgba[i][RCOMP] = rgba[i][GCOMP] = rgba[i][BCOMP] = c;
            }
         }
         else {
#if CHAN_TYPE == GL_UNSIGNED_BYTE
            if (table->Size == 256) {
               /* common case */
               const GLchan *lut = (const GLchan *) table->Table;
               GLuint i;
               for (i = 0; i < n; i++) {
                  const GLchan c = lut[rgba[i][RCOMP]];
                  rgba[i][RCOMP] = rgba[i][GCOMP] = rgba[i][BCOMP] = c;
               }
            }
            else
#endif
            {
               const GLfloat scale = (GLfloat) (table->Size - 1) / CHAN_MAXF;
               const GLchan *lut = (const GLchan *) table->Table;
               GLuint i;
               for (i = 0; i < n; i++) {
                  GLint j = IROUND((GLfloat) rgba[i][RCOMP] * scale);
                  rgba[i][RCOMP] = rgba[i][GCOMP] = rgba[i][BCOMP] = lut[j];
               }
            }
         }
         break;
      case GL_ALPHA:
         /* replace A with A */
         if (table->Type == GL_FLOAT) {
            const GLfloat scale = (GLfloat) (table->Size - 1) / CHAN_MAXF;
            const GLfloat *lut = (const GLfloat *) table->Table;
            GLuint i;
            for (i = 0; i < n; i++) {
               GLint j = IROUND((GLfloat) rgba[i][ACOMP] * scale);
               GLchan c;
               CLAMPED_FLOAT_TO_CHAN(c, lut[j]);
               rgba[i][ACOMP] = c;
            }
         }
         else {
#if CHAN_TYPE == GL_UNSIGNED_BYTE
            if (table->Size == 256) {
               /* common case */
               const GLchan *lut = (const GLchan *) table->Table;
               GLuint i;
               for (i = 0; i < n; i++) {
                  rgba[i][ACOMP] = lut[rgba[i][ACOMP]];
               }
            }
            else
#endif
            {
               const GLfloat scale = (GLfloat) (table->Size - 1) / CHAN_MAXF;
               const GLchan *lut = (const GLchan *) table->Table;
               GLuint i;
               for (i = 0; i < n; i++) {
                  GLint j = IROUND((GLfloat) rgba[i][ACOMP] * scale);
                  rgba[i][ACOMP] = lut[j];
               }
            }
         }
         break;
      case GL_LUMINANCE_ALPHA:
         /* replace RGBA with LLLA */
         if (table->Type == GL_FLOAT) {
            const GLfloat scale = (GLfloat) (table->Size - 1) / CHAN_MAXF;
            const GLfloat *lut = (const GLfloat *) table->Table;
            GLuint i;
            for (i = 0; i < n; i++) {
               GLint jL = IROUND((GLfloat) rgba[i][RCOMP] * scale);
               GLint jA = IROUND((GLfloat) rgba[i][ACOMP] * scale);
               GLchan luminance, alpha;
               CLAMPED_FLOAT_TO_CHAN(luminance, lut[jL * 2 + 0]);
               CLAMPED_FLOAT_TO_CHAN(alpha, lut[jA * 2 + 1]);
               rgba[i][RCOMP] = rgba[i][GCOMP] = rgba[i][BCOMP] = luminance;
               rgba[i][ACOMP] = alpha;;
            }
         }
         else {
#if CHAN_TYPE == GL_UNSIGNED_BYTE
            if (table->Size == 256) {
               /* common case */
               const GLchan *lut = (const GLchan *) table->Table;
               GLuint i;
               for (i = 0; i < n; i++) {
                  GLchan l = lut[rgba[i][RCOMP] * 2 + 0];
                  GLchan a = lut[rgba[i][ACOMP] * 2 + 1];;
                  rgba[i][RCOMP] = rgba[i][GCOMP] = rgba[i][BCOMP] = l;
                  rgba[i][ACOMP] = a;
               }
            }
            else
#endif
            {
               const GLfloat scale = (GLfloat) (table->Size - 1) / CHAN_MAXF;
               const GLchan *lut = (const GLchan *) table->Table;
               GLuint i;
               for (i = 0; i < n; i++) {
                  GLint jL = IROUND((GLfloat) rgba[i][RCOMP] * scale);
                  GLint jA = IROUND((GLfloat) rgba[i][ACOMP] * scale);
                  GLchan luminance = lut[jL * 2 + 0];
                  GLchan alpha     = lut[jA * 2 + 1];
                  rgba[i][RCOMP] = rgba[i][GCOMP] = rgba[i][BCOMP] = luminance;
                  rgba[i][ACOMP] = alpha;
               }
            }
         }
         break;
      case GL_RGB:
         /* replace RGB with RGB */
         if (table->Type == GL_FLOAT) {
            const GLfloat scale = (GLfloat) (table->Size - 1) / CHAN_MAXF;
            const GLfloat *lut = (const GLfloat *) table->Table;
            GLuint i;
            for (i = 0; i < n; i++) {
               GLint jR = IROUND((GLfloat) rgba[i][RCOMP] * scale);
               GLint jG = IROUND((GLfloat) rgba[i][GCOMP] * scale);
               GLint jB = IROUND((GLfloat) rgba[i][BCOMP] * scale);
               CLAMPED_FLOAT_TO_CHAN(rgba[i][RCOMP], lut[jR * 3 + 0]);
               CLAMPED_FLOAT_TO_CHAN(rgba[i][GCOMP], lut[jG * 3 + 1]);
               CLAMPED_FLOAT_TO_CHAN(rgba[i][BCOMP], lut[jB * 3 + 2]);
            }
         }
         else {
#if CHAN_TYPE == GL_UNSIGNED_BYTE
            if (table->Size == 256) {
               /* common case */
               const GLchan *lut = (const GLchan *) table->Table;
               GLuint i;
               for (i = 0; i < n; i++) {
                  rgba[i][RCOMP] = lut[rgba[i][RCOMP] * 3 + 0];
                  rgba[i][GCOMP] = lut[rgba[i][GCOMP] * 3 + 1];
                  rgba[i][BCOMP] = lut[rgba[i][BCOMP] * 3 + 2];
               }
            }
            else
#endif
            {
               const GLfloat scale = (GLfloat) (table->Size - 1) / CHAN_MAXF;
               const GLchan *lut = (const GLchan *) table->Table;
               GLuint i;
               for (i = 0; i < n; i++) {
                  GLint jR = IROUND((GLfloat) rgba[i][RCOMP] * scale);
                  GLint jG = IROUND((GLfloat) rgba[i][GCOMP] * scale);
                  GLint jB = IROUND((GLfloat) rgba[i][BCOMP] * scale);
                  rgba[i][RCOMP] = lut[jR * 3 + 0];
                  rgba[i][GCOMP] = lut[jG * 3 + 1];
                  rgba[i][BCOMP] = lut[jB * 3 + 2];
               }
            }
         }
         break;
      case GL_RGBA:
         /* replace RGBA with RGBA */
         if (table->Type == GL_FLOAT) {
            const GLfloat scale = (GLfloat) (table->Size - 1) / CHAN_MAXF;
            const GLfloat *lut = (const GLfloat *) table->Table;
            GLuint i;
            for (i = 0; i < n; i++) {
               GLint jR = IROUND((GLfloat) rgba[i][RCOMP] * scale);
               GLint jG = IROUND((GLfloat) rgba[i][GCOMP] * scale);
               GLint jB = IROUND((GLfloat) rgba[i][BCOMP] * scale);
               GLint jA = IROUND((GLfloat) rgba[i][ACOMP] * scale);
               CLAMPED_FLOAT_TO_CHAN(rgba[i][RCOMP], lut[jR * 4 + 0]);
               CLAMPED_FLOAT_TO_CHAN(rgba[i][GCOMP], lut[jG * 4 + 1]);
               CLAMPED_FLOAT_TO_CHAN(rgba[i][BCOMP], lut[jB * 4 + 2]);
               CLAMPED_FLOAT_TO_CHAN(rgba[i][ACOMP], lut[jA * 4 + 3]);
            }
         }
         else {
#if CHAN_TYPE == GL_UNSIGNED_BYTE
            if (table->Size == 256) {
               /* common case */
               const GLchan *lut = (const GLchan *) table->Table;
               GLuint i;
               for (i = 0; i < n; i++) {
                  rgba[i][RCOMP] = lut[rgba[i][RCOMP] * 4 + 0];
                  rgba[i][GCOMP] = lut[rgba[i][GCOMP] * 4 + 1];
                  rgba[i][BCOMP] = lut[rgba[i][BCOMP] * 4 + 2];
                  rgba[i][ACOMP] = lut[rgba[i][ACOMP] * 4 + 3];
               }
            }
            else
#endif
            {
               const GLfloat scale = (GLfloat) (table->Size - 1) / CHAN_MAXF;
               const GLfloat *lut = (const GLfloat *) table->Table;
               GLuint i;
               for (i = 0; i < n; i++) {
                  GLint jR = IROUND((GLfloat) rgba[i][RCOMP] * scale);
                  GLint jG = IROUND((GLfloat) rgba[i][GCOMP] * scale);
                  GLint jB = IROUND((GLfloat) rgba[i][BCOMP] * scale);
                  GLint jA = IROUND((GLfloat) rgba[i][ACOMP] * scale);
                  CLAMPED_FLOAT_TO_CHAN(rgba[i][RCOMP], lut[jR * 4 + 0]);
                  CLAMPED_FLOAT_TO_CHAN(rgba[i][GCOMP], lut[jG * 4 + 1]);
                  CLAMPED_FLOAT_TO_CHAN(rgba[i][BCOMP], lut[jB * 4 + 2]);
                  CLAMPED_FLOAT_TO_CHAN(rgba[i][ACOMP], lut[jA * 4 + 3]);
               }
            }
         }
         break;
      default:
         _mesa_problem(NULL, "Bad format in _mesa_lookup_rgba_chan");
         return;
   }
}



/*
 * Apply color index shift and offset to an array of pixels.
 */
void
_mesa_shift_and_offset_ci( const GLcontext *ctx, GLuint n, GLuint indexes[] )
{
   GLint shift = ctx->Pixel.IndexShift;
   GLint offset = ctx->Pixel.IndexOffset;
   GLuint i;
   if (shift > 0) {
      for (i=0;i<n;i++) {
         indexes[i] = (indexes[i] << shift) + offset;
      }
   }
   else if (shift < 0) {
      shift = -shift;
      for (i=0;i<n;i++) {
         indexes[i] = (indexes[i] >> shift) + offset;
      }
   }
   else {
      for (i=0;i<n;i++) {
         indexes[i] = indexes[i] + offset;
      }
   }
}


/*
 * Apply color index mapping to color indexes.
 */
void
_mesa_map_ci( const GLcontext *ctx, GLuint n, GLuint index[] )
{
   const GLuint mask = ctx->Pixel.MapItoIsize - 1;
   GLuint i;
   for (i = 0; i < n; i++) {
      const GLuint j = index[i] & mask;
      index[i] = IROUND(ctx->Pixel.MapItoI[j]);
   }
}


/*
 * Map color indexes to rgba values.
 */
void
_mesa_map_ci_to_rgba_chan( const GLcontext *ctx, GLuint n,
                           const GLuint index[], GLchan rgba[][4] )
{
#if CHAN_BITS == 8
   GLuint rmask = ctx->Pixel.MapItoRsize - 1;
   GLuint gmask = ctx->Pixel.MapItoGsize - 1;
   GLuint bmask = ctx->Pixel.MapItoBsize - 1;
   GLuint amask = ctx->Pixel.MapItoAsize - 1;
   const GLubyte *rMap = ctx->Pixel.MapItoR8;
   const GLubyte *gMap = ctx->Pixel.MapItoG8;
   const GLubyte *bMap = ctx->Pixel.MapItoB8;
   const GLubyte *aMap = ctx->Pixel.MapItoA8;
   GLuint i;
   for (i=0;i<n;i++) {
      rgba[i][RCOMP] = rMap[index[i] & rmask];
      rgba[i][GCOMP] = gMap[index[i] & gmask];
      rgba[i][BCOMP] = bMap[index[i] & bmask];
      rgba[i][ACOMP] = aMap[index[i] & amask];
   }
#else
   GLuint rmask = ctx->Pixel.MapItoRsize - 1;
   GLuint gmask = ctx->Pixel.MapItoGsize - 1;
   GLuint bmask = ctx->Pixel.MapItoBsize - 1;
   GLuint amask = ctx->Pixel.MapItoAsize - 1;
   const GLfloat *rMap = ctx->Pixel.MapItoR;
   const GLfloat *gMap = ctx->Pixel.MapItoG;
   const GLfloat *bMap = ctx->Pixel.MapItoB;
   const GLfloat *aMap = ctx->Pixel.MapItoA;
   GLuint i;
   for (i=0;i<n;i++) {
      CLAMPED_FLOAT_TO_CHAN(rgba[i][RCOMP], rMap[index[i] & rmask]);
      CLAMPED_FLOAT_TO_CHAN(rgba[i][GCOMP], gMap[index[i] & gmask]);
      CLAMPED_FLOAT_TO_CHAN(rgba[i][BCOMP], bMap[index[i] & bmask]);
      CLAMPED_FLOAT_TO_CHAN(rgba[i][ACOMP], aMap[index[i] & amask]);
   }
#endif
}


/*
 * Map color indexes to float rgba values.
 */
void
_mesa_map_ci_to_rgba( const GLcontext *ctx, GLuint n,
                      const GLuint index[], GLfloat rgba[][4] )
{
   GLuint rmask = ctx->Pixel.MapItoRsize - 1;
   GLuint gmask = ctx->Pixel.MapItoGsize - 1;
   GLuint bmask = ctx->Pixel.MapItoBsize - 1;
   GLuint amask = ctx->Pixel.MapItoAsize - 1;
   const GLfloat *rMap = ctx->Pixel.MapItoR;
   const GLfloat *gMap = ctx->Pixel.MapItoG;
   const GLfloat *bMap = ctx->Pixel.MapItoB;
   const GLfloat *aMap = ctx->Pixel.MapItoA;
   GLuint i;
   for (i=0;i<n;i++) {
      rgba[i][RCOMP] = rMap[index[i] & rmask];
      rgba[i][GCOMP] = gMap[index[i] & gmask];
      rgba[i][BCOMP] = bMap[index[i] & bmask];
      rgba[i][ACOMP] = aMap[index[i] & amask];
   }
}


/*
 * Map 8-bit color indexes to rgb values.
 */
void
_mesa_map_ci8_to_rgba( const GLcontext *ctx, GLuint n, const GLubyte index[],
                       GLchan rgba[][4] )
{
#if CHAN_BITS == 8
   GLuint rmask = ctx->Pixel.MapItoRsize - 1;
   GLuint gmask = ctx->Pixel.MapItoGsize - 1;
   GLuint bmask = ctx->Pixel.MapItoBsize - 1;
   GLuint amask = ctx->Pixel.MapItoAsize - 1;
   const GLubyte *rMap = ctx->Pixel.MapItoR8;
   const GLubyte *gMap = ctx->Pixel.MapItoG8;
   const GLubyte *bMap = ctx->Pixel.MapItoB8;
   const GLubyte *aMap = ctx->Pixel.MapItoA8;
   GLuint i;
   for (i=0;i<n;i++) {
      rgba[i][RCOMP] = rMap[index[i] & rmask];
      rgba[i][GCOMP] = gMap[index[i] & gmask];
      rgba[i][BCOMP] = bMap[index[i] & bmask];
      rgba[i][ACOMP] = aMap[index[i] & amask];
   }
#else
   GLuint rmask = ctx->Pixel.MapItoRsize - 1;
   GLuint gmask = ctx->Pixel.MapItoGsize - 1;
   GLuint bmask = ctx->Pixel.MapItoBsize - 1;
   GLuint amask = ctx->Pixel.MapItoAsize - 1;
   const GLfloat *rMap = ctx->Pixel.MapItoR;
   const GLfloat *gMap = ctx->Pixel.MapItoG;
   const GLfloat *bMap = ctx->Pixel.MapItoB;
   const GLfloat *aMap = ctx->Pixel.MapItoA;
   GLuint i;
   for (i=0;i<n;i++) {
      CLAMPED_FLOAT_TO_CHAN(rgba[i][RCOMP], rMap[index[i] & rmask]);
      CLAMPED_FLOAT_TO_CHAN(rgba[i][GCOMP], gMap[index[i] & gmask]);
      CLAMPED_FLOAT_TO_CHAN(rgba[i][BCOMP], bMap[index[i] & bmask]);
      CLAMPED_FLOAT_TO_CHAN(rgba[i][ACOMP], aMap[index[i] & amask]);
   }
#endif
}


void
_mesa_shift_and_offset_stencil( const GLcontext *ctx, GLuint n,
                                GLstencil stencil[] )
{
   GLuint i;
   GLint shift = ctx->Pixel.IndexShift;
   GLint offset = ctx->Pixel.IndexOffset;
   if (shift > 0) {
      for (i=0;i<n;i++) {
         stencil[i] = (stencil[i] << shift) + offset;
      }
   }
   else if (shift < 0) {
      shift = -shift;
      for (i=0;i<n;i++) {
         stencil[i] = (stencil[i] >> shift) + offset;
      }
   }
   else {
      for (i=0;i<n;i++) {
         stencil[i] = stencil[i] + offset;
      }
   }

}


void
_mesa_map_stencil( const GLcontext *ctx, GLuint n, GLstencil stencil[] )
{
   GLuint mask = ctx->Pixel.MapStoSsize - 1;
   GLuint i;
   for (i=0;i<n;i++) {
      stencil[i] = ctx->Pixel.MapStoS[ stencil[i] & mask ];
   }
}


void
_mesa_scale_and_bias_depth(const GLcontext *ctx, GLuint n,
                           GLfloat depthValues[])
{
   const GLfloat scale = ctx->Pixel.DepthScale;
   const GLfloat bias = ctx->Pixel.DepthBias;
   GLuint i;
   for (i = 0; i < n; i++) {
      GLfloat d = depthValues[i] * scale + bias;
      depthValues[i] = CLAMP(d, 0.0F, 1.0F);
   }
}


/*
 * This function converts an array of GLchan colors to GLfloat colors.
 * Most importantly, it undoes the non-uniform quantization of pixel
 * values introduced when we convert shallow (< 8 bit) pixel values
 * to GLubytes in the ctx->Driver.ReadRGBASpan() functions.
 * This fixes a number of OpenGL conformance failures when running on
 * 16bpp displays, for example.
 */
void
_mesa_chan_to_float_span(const GLcontext *ctx, GLuint n,
                         CONST GLchan rgba[][4], GLfloat rgbaf[][4])
{
#if CHAN_TYPE == GL_FLOAT
   MEMCPY(rgbaf, rgba, n * 4 * sizeof(GLfloat));
#else
   const GLuint rShift = CHAN_BITS - ctx->Visual.redBits;
   const GLuint gShift = CHAN_BITS - ctx->Visual.greenBits;
   const GLuint bShift = CHAN_BITS - ctx->Visual.blueBits;
   GLuint aShift;
   const GLfloat rScale = 1.0F / (GLfloat) ((1 << ctx->Visual.redBits  ) - 1);
   const GLfloat gScale = 1.0F / (GLfloat) ((1 << ctx->Visual.greenBits) - 1);
   const GLfloat bScale = 1.0F / (GLfloat) ((1 << ctx->Visual.blueBits ) - 1);
   GLfloat aScale;
   GLuint i;

   if (ctx->Visual.alphaBits > 0) {
      aShift = CHAN_BITS - ctx->Visual.alphaBits;
      aScale = 1.0F / (GLfloat) ((1 << ctx->Visual.alphaBits) - 1);
   }
   else {
      aShift = 0;
      aScale = 1.0F / CHAN_MAXF;
   }

   for (i = 0; i < n; i++) {
      const GLint r = rgba[i][RCOMP] >> rShift;
      const GLint g = rgba[i][GCOMP] >> gShift;
      const GLint b = rgba[i][BCOMP] >> bShift;
      const GLint a = rgba[i][ACOMP] >> aShift;
      rgbaf[i][RCOMP] = (GLfloat) r * rScale;
      rgbaf[i][GCOMP] = (GLfloat) g * gScale;
      rgbaf[i][BCOMP] = (GLfloat) b * bScale;
      rgbaf[i][ACOMP] = (GLfloat) a * aScale;
   }
#endif
}

/**********************************************************************/
d775 1
a775 1
   if (ctx->Pixel.ColorTableEnabled)
d794 1
a794 1
   if (ctx->Pixel.PostConvolutionColorTableEnabled)
d808 1
a808 1
   if (ctx->Pixel.PostColorMatrixColorTableEnabled)
d821 3
d840 8
d874 10
a883 24
   ctx->Pixel.MapStoSsize = 1;
   ctx->Pixel.MapItoIsize = 1;
   ctx->Pixel.MapItoRsize = 1;
   ctx->Pixel.MapItoGsize = 1;
   ctx->Pixel.MapItoBsize = 1;
   ctx->Pixel.MapItoAsize = 1;
   ctx->Pixel.MapRtoRsize = 1;
   ctx->Pixel.MapGtoGsize = 1;
   ctx->Pixel.MapBtoBsize = 1;
   ctx->Pixel.MapAtoAsize = 1;
   ctx->Pixel.MapStoS[0] = 0;
   ctx->Pixel.MapItoI[0] = 0.0;
   ctx->Pixel.MapItoR[0] = 0.0;
   ctx->Pixel.MapItoG[0] = 0.0;
   ctx->Pixel.MapItoB[0] = 0.0;
   ctx->Pixel.MapItoA[0] = 0.0;
   ctx->Pixel.MapItoR8[0] = 0;
   ctx->Pixel.MapItoG8[0] = 0;
   ctx->Pixel.MapItoB8[0] = 0;
   ctx->Pixel.MapItoA8[0] = 0;
   ctx->Pixel.MapRtoR[0] = 0.0;
   ctx->Pixel.MapGtoG[0] = 0.0;
   ctx->Pixel.MapBtoB[0] = 0.0;
   ctx->Pixel.MapAtoA[0] = 0.0;
d888 5
a892 9
   ASSIGN_4V(ctx->Pixel.ColorTableScale, 1.0, 1.0, 1.0, 1.0);
   ASSIGN_4V(ctx->Pixel.ColorTableBias, 0.0, 0.0, 0.0, 0.0);
   ASSIGN_4V(ctx->Pixel.PCCTscale, 1.0, 1.0, 1.0, 1.0);
   ASSIGN_4V(ctx->Pixel.PCCTbias, 0.0, 0.0, 0.0, 0.0);
   ASSIGN_4V(ctx->Pixel.PCMCTscale, 1.0, 1.0, 1.0, 1.0);
   ASSIGN_4V(ctx->Pixel.PCMCTbias, 0.0, 0.0, 0.0, 0.0);
   ctx->Pixel.ColorTableEnabled = GL_FALSE;
   ctx->Pixel.PostConvolutionColorTableEnabled = GL_FALSE;
   ctx->Pixel.PostColorMatrixColorTableEnabled = GL_FALSE;
a911 48

   /* Pixel transfer */
   ctx->Pack.Alignment = 4;
   ctx->Pack.RowLength = 0;
   ctx->Pack.ImageHeight = 0;
   ctx->Pack.SkipPixels = 0;
   ctx->Pack.SkipRows = 0;
   ctx->Pack.SkipImages = 0;
   ctx->Pack.SwapBytes = GL_FALSE;
   ctx->Pack.LsbFirst = GL_FALSE;
   ctx->Pack.ClientStorage = GL_FALSE;
   ctx->Pack.Invert = GL_FALSE;
#if FEATURE_EXT_pixel_buffer_object
   ctx->Pack.BufferObj = ctx->Array.NullBufferObj;
#endif
   ctx->Unpack.Alignment = 4;
   ctx->Unpack.RowLength = 0;
   ctx->Unpack.ImageHeight = 0;
   ctx->Unpack.SkipPixels = 0;
   ctx->Unpack.SkipRows = 0;
   ctx->Unpack.SkipImages = 0;
   ctx->Unpack.SwapBytes = GL_FALSE;
   ctx->Unpack.LsbFirst = GL_FALSE;
   ctx->Unpack.ClientStorage = GL_FALSE;
   ctx->Unpack.Invert = GL_FALSE;
#if FEATURE_EXT_pixel_buffer_object
   ctx->Unpack.BufferObj = ctx->Array.NullBufferObj;
#endif

   /*
    * _mesa_unpack_image() returns image data in this format.  When we
    * execute image commands (glDrawPixels(), glTexImage(), etc) from
    * within display lists we have to be sure to set the current
    * unpacking parameters to these values!
    */
   ctx->DefaultPacking.Alignment = 1;
   ctx->DefaultPacking.RowLength = 0;
   ctx->DefaultPacking.SkipPixels = 0;
   ctx->DefaultPacking.SkipRows = 0;
   ctx->DefaultPacking.ImageHeight = 0;
   ctx->DefaultPacking.SkipImages = 0;
   ctx->DefaultPacking.SwapBytes = GL_FALSE;
   ctx->DefaultPacking.LsbFirst = GL_FALSE;
   ctx->DefaultPacking.ClientStorage = GL_FALSE;
   ctx->DefaultPacking.Invert = GL_FALSE;
#if FEATURE_EXT_pixel_buffer_object
   ctx->DefaultPacking.BufferObj = ctx->Array.NullBufferObj;
#endif
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d3 1
a3 1
 * Version:  6.5.2
d5 1
a5 1
 * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
d1174 1
a1174 6
   const GLint max = table->Size - 1;
   const GLfloat scale = (GLfloat) max;
   const GLfloat *lut = table->TableF;
   GLuint i;

   if (!table->TableF || table->Size == 0)
d1180 23
a1202 7
         for (i = 0; i < n; i++) {
            GLint j = IROUND(rgba[i][RCOMP] * scale);
            GLfloat c = lut[CLAMP(j, 0, max)];
            rgba[i][RCOMP] =
            rgba[i][GCOMP] =
            rgba[i][BCOMP] =
            rgba[i][ACOMP] = c;
d1207 21
a1227 6
         for (i = 0; i < n; i++) {
            GLint j = IROUND(rgba[i][RCOMP] * scale);
            GLfloat c = lut[CLAMP(j, 0, max)];
            rgba[i][RCOMP] =
            rgba[i][GCOMP] =
            rgba[i][BCOMP] = c;
d1232 19
a1250 3
         for (i = 0; i < n; i++) {
            GLint j = IROUND(rgba[i][ACOMP] * scale);
            rgba[i][ACOMP] = lut[CLAMP(j, 0, max)];
d1255 33
a1287 12
         for (i = 0; i < n; i++) {
            GLint jL = IROUND(rgba[i][RCOMP] * scale);
            GLint jA = IROUND(rgba[i][ACOMP] * scale);
            GLfloat luminance, alpha;
            jL = CLAMP(jL, 0, max);
            jA = CLAMP(jA, 0, max);
            luminance = lut[jL * 2 + 0];
            alpha     = lut[jA * 2 + 1];
            rgba[i][RCOMP] =
            rgba[i][GCOMP] =
            rgba[i][BCOMP] = luminance;
            rgba[i][ACOMP] = alpha;;
d1292 33
a1324 10
         for (i = 0; i < n; i++) {
            GLint jR = IROUND(rgba[i][RCOMP] * scale);
            GLint jG = IROUND(rgba[i][GCOMP] * scale);
            GLint jB = IROUND(rgba[i][BCOMP] * scale);
            jR = CLAMP(jR, 0, max);
            jG = CLAMP(jG, 0, max);
            jB = CLAMP(jB, 0, max);
            rgba[i][RCOMP] = lut[jR * 3 + 0];
            rgba[i][GCOMP] = lut[jG * 3 + 1];
            rgba[i][BCOMP] = lut[jB * 3 + 2];
d1329 39
a1367 13
         for (i = 0; i < n; i++) {
            GLint jR = IROUND(rgba[i][RCOMP] * scale);
            GLint jG = IROUND(rgba[i][GCOMP] * scale);
            GLint jB = IROUND(rgba[i][BCOMP] * scale);
            GLint jA = IROUND(rgba[i][ACOMP] * scale);
            jR = CLAMP(jR, 0, max);
            jG = CLAMP(jG, 0, max);
            jB = CLAMP(jB, 0, max);
            jA = CLAMP(jA, 0, max);
            rgba[i][RCOMP] = lut[jR * 4 + 0];
            rgba[i][GCOMP] = lut[jG * 4 + 1];
            rgba[i][BCOMP] = lut[jB * 4 + 2];
            rgba[i][ACOMP] = lut[jA * 4 + 3];
d1379 1
a1379 1
 * Apply a color table lookup to an array of ubyte/RGBA colors.
d1382 2
a1383 2
_mesa_lookup_rgba_ubyte(const struct gl_color_table *table,
                        GLuint n, GLubyte rgba[][4])
d1385 1
a1385 5
   const GLubyte *lut = table->TableUB;
   const GLfloat scale = (GLfloat) (table->Size - 1) / 255.0;
   GLuint i;

   if (!table->TableUB || table->Size == 0)
d1389 284
a1672 123
   case GL_INTENSITY:
      /* replace RGBA with I */
      if (table->Size == 256) {
         for (i = 0; i < n; i++) {
            const GLubyte c = lut[rgba[i][RCOMP]];
            rgba[i][RCOMP] =
            rgba[i][GCOMP] =
            rgba[i][BCOMP] =
            rgba[i][ACOMP] = c;
         }
      }
      else {
         for (i = 0; i < n; i++) {
            GLint j = IROUND((GLfloat) rgba[i][RCOMP] * scale);
            rgba[i][RCOMP] =
            rgba[i][GCOMP] =
            rgba[i][BCOMP] =
            rgba[i][ACOMP] = lut[j];
         }
      }
      break;
   case GL_LUMINANCE:
      /* replace RGB with L */
      if (table->Size == 256) {
         for (i = 0; i < n; i++) {
            const GLubyte c = lut[rgba[i][RCOMP]];
            rgba[i][RCOMP] =
            rgba[i][GCOMP] =
            rgba[i][BCOMP] = c;
         }
      }
      else {
         for (i = 0; i < n; i++) {
            GLint j = IROUND((GLfloat) rgba[i][RCOMP] * scale);
            rgba[i][RCOMP] =
            rgba[i][GCOMP] =
            rgba[i][BCOMP] = lut[j];
         }
      }
      break;
   case GL_ALPHA:
      /* replace A with A */
      if (table->Size == 256) {
         for (i = 0; i < n; i++) {
            rgba[i][ACOMP] = lut[rgba[i][ACOMP]];
         }
      }
      else {
         for (i = 0; i < n; i++) {
            GLint j = IROUND((GLfloat) rgba[i][ACOMP] * scale);
            rgba[i][ACOMP] = lut[j];
         }
      }
      break;
   case GL_LUMINANCE_ALPHA:
      /* replace RGBA with LLLA */
      if (table->Size == 256) {
         for (i = 0; i < n; i++) {
            GLubyte l = lut[rgba[i][RCOMP] * 2 + 0];
            GLubyte a = lut[rgba[i][ACOMP] * 2 + 1];;
            rgba[i][RCOMP] =
            rgba[i][GCOMP] =
            rgba[i][BCOMP] = l;
            rgba[i][ACOMP] = a;
         }
      }
      else {
         for (i = 0; i < n; i++) {
            GLint jL = IROUND((GLfloat) rgba[i][RCOMP] * scale);
            GLint jA = IROUND((GLfloat) rgba[i][ACOMP] * scale);
            GLubyte luminance = lut[jL * 2 + 0];
            GLubyte alpha     = lut[jA * 2 + 1];
            rgba[i][RCOMP] =
            rgba[i][GCOMP] =
            rgba[i][BCOMP] = luminance;
            rgba[i][ACOMP] = alpha;
         }
      }
      break;
   case GL_RGB:
      if (table->Size == 256) {
         for (i = 0; i < n; i++) {
            rgba[i][RCOMP] = lut[rgba[i][RCOMP] * 3 + 0];
            rgba[i][GCOMP] = lut[rgba[i][GCOMP] * 3 + 1];
            rgba[i][BCOMP] = lut[rgba[i][BCOMP] * 3 + 2];
         }
      }
      else {
         for (i = 0; i < n; i++) {
            GLint jR = IROUND((GLfloat) rgba[i][RCOMP] * scale);
            GLint jG = IROUND((GLfloat) rgba[i][GCOMP] * scale);
            GLint jB = IROUND((GLfloat) rgba[i][BCOMP] * scale);
            rgba[i][RCOMP] = lut[jR * 3 + 0];
            rgba[i][GCOMP] = lut[jG * 3 + 1];
            rgba[i][BCOMP] = lut[jB * 3 + 2];
         }
      }
      break;
   case GL_RGBA:
      if (table->Size == 256) {
         for (i = 0; i < n; i++) {
            rgba[i][RCOMP] = lut[rgba[i][RCOMP] * 4 + 0];
            rgba[i][GCOMP] = lut[rgba[i][GCOMP] * 4 + 1];
            rgba[i][BCOMP] = lut[rgba[i][BCOMP] * 4 + 2];
            rgba[i][ACOMP] = lut[rgba[i][ACOMP] * 4 + 3];
         }
      }
      else {
         for (i = 0; i < n; i++) {
            GLint jR = IROUND((GLfloat) rgba[i][RCOMP] * scale);
            GLint jG = IROUND((GLfloat) rgba[i][GCOMP] * scale);
            GLint jB = IROUND((GLfloat) rgba[i][BCOMP] * scale);
            GLint jA = IROUND((GLfloat) rgba[i][ACOMP] * scale);
            CLAMPED_FLOAT_TO_CHAN(rgba[i][RCOMP], lut[jR * 4 + 0]);
            CLAMPED_FLOAT_TO_CHAN(rgba[i][GCOMP], lut[jG * 4 + 1]);
            CLAMPED_FLOAT_TO_CHAN(rgba[i][BCOMP], lut[jB * 4 + 2]);
            CLAMPED_FLOAT_TO_CHAN(rgba[i][ACOMP], lut[jA * 4 + 3]);
         }
      }
      break;
   default:
      _mesa_problem(NULL, "Bad format in _mesa_lookup_rgba_chan");
      return;
d1677 57
d1760 2
a1761 2
/**
 * Map ubyte color indexes to ubyte/RGBA values.
d1764 2
a1765 2
_mesa_map_ci8_to_rgba8(const GLcontext *ctx, GLuint n, const GLubyte index[],
                       GLubyte rgba[][4])
d1767 1
d1783 55
d1855 46
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d3 1
a3 1
 * Version:  6.5.3
d5 1
a5 1
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
a254 32
/**
 * Return pointer to a pixelmap by name.
 */
static struct gl_pixelmap *
get_pixelmap(GLcontext *ctx, GLenum map)
{
   switch (map) {
   case GL_PIXEL_MAP_I_TO_I:
      return &ctx->PixelMaps.ItoI;
   case GL_PIXEL_MAP_S_TO_S:
      return &ctx->PixelMaps.StoS;
   case GL_PIXEL_MAP_I_TO_R:
      return &ctx->PixelMaps.ItoR;
   case GL_PIXEL_MAP_I_TO_G:
      return &ctx->PixelMaps.ItoG;
   case GL_PIXEL_MAP_I_TO_B:
      return &ctx->PixelMaps.ItoB;
   case GL_PIXEL_MAP_I_TO_A:
      return &ctx->PixelMaps.ItoA;
   case GL_PIXEL_MAP_R_TO_R:
      return &ctx->PixelMaps.RtoR;
   case GL_PIXEL_MAP_G_TO_G:
      return &ctx->PixelMaps.GtoG;
   case GL_PIXEL_MAP_B_TO_B:
      return &ctx->PixelMaps.BtoB;
   case GL_PIXEL_MAP_A_TO_A:
      return &ctx->PixelMaps.AtoA;
   default:
      return NULL;
   }
}

d260 1
a260 2
store_pixelmap(GLcontext *ctx, GLenum map, GLsizei mapsize,
               const GLfloat *values)
a262 6
   struct gl_pixelmap *pm = get_pixelmap(ctx, map);
   if (!pm) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glPixelMap(map)");
      return;
   }

d264 70
a333 22
   case GL_PIXEL_MAP_S_TO_S:
      /* special case */
      ctx->PixelMaps.StoS.Size = mapsize;
      for (i = 0; i < mapsize; i++) {
         ctx->PixelMaps.StoS.Map[i] = IROUND(values[i]);
      }
      break;
   case GL_PIXEL_MAP_I_TO_I:
      /* special case */
      ctx->PixelMaps.ItoI.Size = mapsize;
      for (i = 0; i < mapsize; i++) {
         ctx->PixelMaps.ItoI.Map[i] = values[i];
      }
      break;
   default:
      /* general case */
      pm->Size = mapsize;
      for (i = 0; i < mapsize; i++) {
         GLfloat val = CLAMP(values[i], 0.0F, 1.0F);
         pm->Map[i] = val;
         pm->Map8[i] = (GLint) (val * 255.0F);
      }
d388 1
a388 1
   store_pixelmap(ctx, map, mapsize, values);
d397 1
d467 1
a467 1
   store_pixelmap(ctx, map, mapsize, fvalues);
d471 1
d523 1
a523 1
   /* convert to floats */
d542 34
a575 1
   store_pixelmap(ctx, map, mapsize, fvalues);
a583 2
   const struct gl_pixelmap *pm;

d586 1
a586 7
   pm = get_pixelmap(ctx, map);
   if (!pm) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetPixelMapfv(map)");
      return;
   }

   mapsize = pm->Size;
d616 35
a650 8
   if (map == GL_PIXEL_MAP_S_TO_S) {
      /* special case */
      for (i = 0; i < mapsize; i++) {
         values[i] = (GLfloat) ctx->PixelMaps.StoS.Map[i];
      }
   }
   else {
      MEMCPY(values, pm->Map, mapsize * sizeof(GLfloat));
a664 2
   const struct gl_pixelmap *pm;

d667 1
a667 6
   pm = get_pixelmap(ctx, map);
   if (!pm) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetPixelMapuiv(map)");
      return;
   }
   mapsize = pm->Size;
d697 51
a747 8
   if (map == GL_PIXEL_MAP_S_TO_S) {
      /* special case */
      MEMCPY(values, ctx->PixelMaps.StoS.Map, mapsize * sizeof(GLint));
   }
   else {
      for (i = 0; i < mapsize; i++) {
         values[i] = FLOAT_TO_UINT( pm->Map[i] );
      }
a761 2
   const struct gl_pixelmap *pm;

d764 1
a764 6
   pm = get_pixelmap(ctx, map);
   if (!pm) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetPixelMapusv(map)");
      return;
   }
   mapsize = pm ? pm->Size : 0;
d796 52
a847 15
   /* special cases */
   case GL_PIXEL_MAP_I_TO_I:
      for (i = 0; i < mapsize; i++) {
         values[i] = (GLushort) CLAMP(ctx->PixelMaps.ItoI.Map[i], 0.0, 65535.);
      }
      break;
   case GL_PIXEL_MAP_S_TO_S:
      for (i = 0; i < mapsize; i++) {
         values[i] = (GLushort) CLAMP(ctx->PixelMaps.StoS.Map[i], 0.0, 65535.);
      }
      break;
   default:
      for (i = 0; i < mapsize; i++) {
         CLAMPED_FLOAT_TO_USHORT(values[i], pm->Map[i] );
      }
d1043 1
a1043 1
         if (ctx->Pixel.PostConvolutionScale[3] == param)
d1046 1
a1046 1
         ctx->Pixel.PostConvolutionScale[3] = param;
d1049 1
a1049 1
         if (ctx->Pixel.PostConvolutionBias[3] == param)
d1052 1
a1052 1
         ctx->Pixel.PostConvolutionBias[3] = param;
d1116 8
a1123 8
   const GLfloat rscale = (GLfloat) (ctx->PixelMaps.RtoR.Size - 1);
   const GLfloat gscale = (GLfloat) (ctx->PixelMaps.GtoG.Size - 1);
   const GLfloat bscale = (GLfloat) (ctx->PixelMaps.BtoB.Size - 1);
   const GLfloat ascale = (GLfloat) (ctx->PixelMaps.AtoA.Size - 1);
   const GLfloat *rMap = ctx->PixelMaps.RtoR.Map;
   const GLfloat *gMap = ctx->PixelMaps.GtoG.Map;
   const GLfloat *bMap = ctx->PixelMaps.BtoB.Map;
   const GLfloat *aMap = ctx->PixelMaps.AtoA.Map;
d1416 8
a1423 8
   GLuint rmask = ctx->PixelMaps.ItoR.Size - 1;
   GLuint gmask = ctx->PixelMaps.ItoG.Size - 1;
   GLuint bmask = ctx->PixelMaps.ItoB.Size - 1;
   GLuint amask = ctx->PixelMaps.ItoA.Size - 1;
   const GLfloat *rMap = ctx->PixelMaps.ItoR.Map;
   const GLfloat *gMap = ctx->PixelMaps.ItoG.Map;
   const GLfloat *bMap = ctx->PixelMaps.ItoB.Map;
   const GLfloat *aMap = ctx->PixelMaps.ItoA.Map;
d1441 8
a1448 8
   GLuint rmask = ctx->PixelMaps.ItoR.Size - 1;
   GLuint gmask = ctx->PixelMaps.ItoG.Size - 1;
   GLuint bmask = ctx->PixelMaps.ItoB.Size - 1;
   GLuint amask = ctx->PixelMaps.ItoA.Size - 1;
   const GLubyte *rMap = ctx->PixelMaps.ItoR.Map8;
   const GLubyte *gMap = ctx->PixelMaps.ItoG.Map8;
   const GLubyte *bMap = ctx->PixelMaps.ItoB.Map8;
   const GLubyte *aMap = ctx->PixelMaps.ItoA.Map8;
d1499 1
a1499 1
   if (ctx->Pixel.ColorTableEnabled[COLORTABLE_PRECONVOLUTION])
d1518 1
a1518 1
   if (ctx->Pixel.ColorTableEnabled[COLORTABLE_POSTCONVOLUTION])
d1532 1
a1532 1
   if (ctx->Pixel.ColorTableEnabled[COLORTABLE_POSTCOLORMATRIX])
a1560 8
static void
init_pixelmap(struct gl_pixelmap *map)
{
   map->Size = 1;
   map->Map[0] = 0.0;
   map->Map8[0] = 0;
}

d1587 24
a1610 10
   init_pixelmap(&ctx->PixelMaps.StoS);
   init_pixelmap(&ctx->PixelMaps.ItoI);
   init_pixelmap(&ctx->PixelMaps.ItoR);
   init_pixelmap(&ctx->PixelMaps.ItoG);
   init_pixelmap(&ctx->PixelMaps.ItoB);
   init_pixelmap(&ctx->PixelMaps.ItoA);
   init_pixelmap(&ctx->PixelMaps.RtoR);
   init_pixelmap(&ctx->PixelMaps.GtoG);
   init_pixelmap(&ctx->PixelMaps.BtoB);
   init_pixelmap(&ctx->PixelMaps.AtoA);
d1615 9
a1623 5
   for (i = 0; i < COLORTABLE_MAX; i++) {
      ASSIGN_4V(ctx->Pixel.ColorTableScale[i], 1.0, 1.0, 1.0, 1.0);
      ASSIGN_4V(ctx->Pixel.ColorTableBias[i], 0.0, 0.0, 0.0, 0.0);
      ctx->Pixel.ColorTableEnabled[i] = GL_FALSE;
   }
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d3 1
a3 1
 * Version:  7.1
d5 1
a5 1
 * Copyright (C) 1999-2008  Brian Paul   All Rights Reserved.
a24 6

/**
 * \file pixel.c
 * Pixel transfer functions (glPixelZoom, glPixelMap, glPixelTransfer)
 */

d29 1
a32 4
#include "main/dispatch.h"


#if FEATURE_pixel_transfer
d39 3
a41 1
static void GLAPIENTRY
d58 194
d259 1
a259 1
get_pixelmap(struct gl_context *ctx, GLenum map)
d292 1
a292 1
store_pixelmap(struct gl_context *ctx, GLenum map, GLsizei mapsize,
d307 1
a307 1
         ctx->PixelMaps.StoS.Map[i] = (GLfloat)IROUND(values[i]);
d329 1
a329 32
/**
 * Convenience wrapper for _mesa_validate_pbo_access() for gl[Get]PixelMap().
 */
static GLboolean
validate_pbo_access(struct gl_context *ctx, struct gl_pixelstore_attrib *pack,
                    GLsizei mapsize, GLenum format, GLenum type,
                    const GLvoid *ptr)
{
   GLboolean ok;

   /* Note, need to use DefaultPacking and Unpack's buffer object */
   _mesa_reference_buffer_object(ctx,
                                 &ctx->DefaultPacking.BufferObj,
                                 pack->BufferObj);

   ok = _mesa_validate_pbo_access(1, &ctx->DefaultPacking, mapsize, 1, 1,
                                  format, type, ptr);

   /* restore */
   _mesa_reference_buffer_object(ctx,
                                 &ctx->DefaultPacking.BufferObj,
                                 ctx->Shared->NullBufferObj);

   if (!ok) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glPixelMap(invalid PBO access)");
   }
   return ok;
}


static void GLAPIENTRY
d343 1
a343 1
      if (!_mesa_is_pow_two(mapsize)) {
d351 18
a368 8
   if (!validate_pbo_access(ctx, &ctx->Unpack, mapsize,
                            GL_INTENSITY, GL_FLOAT, values)) {
      return;
   }

   values = (const GLfloat *) _mesa_map_pbo_source(ctx, &ctx->Unpack, values);
   if (!values) {
      if (_mesa_is_bufferobj(ctx->Unpack.BufferObj)) {
d371 1
d373 3
d381 4
a384 1
   _mesa_unmap_pbo_source(ctx, &ctx->Unpack);
d388 1
a388 1
static void GLAPIENTRY
d402 1
a402 1
      if (!_mesa_is_pow_two(mapsize)) {
d410 18
a427 8
   if (!validate_pbo_access(ctx, &ctx->Unpack, mapsize,
                            GL_INTENSITY, GL_UNSIGNED_INT, values)) {
      return;
   }

   values = (const GLuint *) _mesa_map_pbo_source(ctx, &ctx->Unpack, values);
   if (!values) {
      if (_mesa_is_bufferobj(ctx->Unpack.BufferObj)) {
d430 1
d432 3
d452 4
a455 1
   _mesa_unmap_pbo_source(ctx, &ctx->Unpack);
d461 1
a461 1
static void GLAPIENTRY
d475 1
a475 1
      if (!_mesa_is_pow_two(mapsize)) {
d483 19
a501 8
   if (!validate_pbo_access(ctx, &ctx->Unpack, mapsize,
                            GL_INTENSITY, GL_UNSIGNED_SHORT, values)) {
      return;
   }

   values = (const GLushort *) _mesa_map_pbo_source(ctx, &ctx->Unpack, values);
   if (!values) {
      if (_mesa_is_bufferobj(ctx->Unpack.BufferObj)) {
d504 1
d506 3
d526 4
a529 1
   _mesa_unmap_pbo_source(ctx, &ctx->Unpack);
d535 1
a535 1
static void GLAPIENTRY
d552 18
a569 8
   if (!validate_pbo_access(ctx, &ctx->Pack, mapsize,
                            GL_INTENSITY, GL_FLOAT, values)) {
      return;
   }

   values = (GLfloat *) _mesa_map_pbo_dest(ctx, &ctx->Pack, values);
   if (!values) {
      if (_mesa_is_bufferobj(ctx->Pack.BufferObj)) {
d572 1
d574 3
d587 1
a587 1
      memcpy(values, pm->Map, mapsize * sizeof(GLfloat));
d590 4
a593 1
   _mesa_unmap_pbo_dest(ctx, &ctx->Pack);
d597 1
a597 1
static void GLAPIENTRY
d613 18
a630 8
   if (!validate_pbo_access(ctx, &ctx->Pack, mapsize,
                            GL_INTENSITY, GL_UNSIGNED_INT, values)) {
      return;
   }

   values = (GLuint *) _mesa_map_pbo_dest(ctx, &ctx->Pack, values);
   if (!values) {
      if (_mesa_is_bufferobj(ctx->Pack.BufferObj)) {
d633 1
d635 3
d643 1
a643 1
      memcpy(values, ctx->PixelMaps.StoS.Map, mapsize * sizeof(GLint));
d651 4
a654 1
   _mesa_unmap_pbo_dest(ctx, &ctx->Pack);
d658 1
a658 1
static void GLAPIENTRY
d672 1
a672 1
   mapsize = pm->Size;
d674 19
a692 8
   if (!validate_pbo_access(ctx, &ctx->Pack, mapsize,
                            GL_INTENSITY, GL_UNSIGNED_SHORT, values)) {
      return;
   }

   values = (GLushort *) _mesa_map_pbo_dest(ctx, &ctx->Pack, values);
   if (!values) {
      if (_mesa_is_bufferobj(ctx->Pack.BufferObj)) {
d695 1
d697 3
d721 4
a724 1
   _mesa_unmap_pbo_dest(ctx, &ctx->Pack);
d738 1
a738 1
static void GLAPIENTRY
d829 96
d932 1
a932 1
static void GLAPIENTRY
d941 405
d1354 1
a1354 1
update_image_transfer_state(struct gl_context *ctx)
d1370 42
d1416 1
a1416 4
/**
 * Update mesa pixel transfer derived state.
 */
void _mesa_update_pixel( struct gl_context *ctx, GLuint new_state )
d1418 6
a1423 1
   if (new_state & _MESA_NEW_TRANSFER_STATE)
a1427 18
void
_mesa_init_pixel_dispatch(struct _glapi_table *disp)
{
   SET_GetPixelMapfv(disp, _mesa_GetPixelMapfv);
   SET_GetPixelMapuiv(disp, _mesa_GetPixelMapuiv);
   SET_GetPixelMapusv(disp, _mesa_GetPixelMapusv);
   SET_PixelMapfv(disp, _mesa_PixelMapfv);
   SET_PixelMapuiv(disp, _mesa_PixelMapuiv);
   SET_PixelMapusv(disp, _mesa_PixelMapusv);
   SET_PixelTransferf(disp, _mesa_PixelTransferf);
   SET_PixelTransferi(disp, _mesa_PixelTransferi);
   SET_PixelZoom(disp, _mesa_PixelZoom);
}


#endif /* FEATURE_pixel_transfer */


d1445 1
a1445 1
_mesa_init_pixel( struct gl_context *ctx )
d1447 2
d1476 25
d1504 48
@


1.1.1.5
log
@Import Mesa 9.2.0
@
text
@d3 1
d20 3
a22 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
a36 1
#include "pbo.h"
d41 3
d48 1
a48 1
void GLAPIENTRY
d136 1
d146 2
a147 3
validate_pbo_access(struct gl_context *ctx,
                    struct gl_pixelstore_attrib *pack, GLsizei mapsize,
                    GLenum format, GLenum type, GLsizei clientMemSize,
d158 1
a158 1
                                  format, type, clientMemSize, ptr);
d166 2
a167 8
      if (_mesa_is_bufferobj(pack->BufferObj)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "gl[Get]PixelMap*v(out of bounds PBO access)");
      } else {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glGetnPixelMap*vARB(out of bounds access:"
                     " bufSize (%d) is too small)", clientMemSize);
      }
d173 1
a173 1
void GLAPIENTRY
d177 1
d195 2
a196 2
   if (!validate_pbo_access(ctx, &ctx->Unpack, mapsize, GL_INTENSITY,
                            GL_FLOAT, INT_MAX, values)) {
d215 1
a215 1
void GLAPIENTRY
d220 1
d237 2
a238 2
   if (!validate_pbo_access(ctx, &ctx->Unpack, mapsize, GL_INTENSITY,
                            GL_UNSIGNED_INT, INT_MAX, values)) {
d271 1
a271 1
void GLAPIENTRY
d276 1
d293 2
a294 2
   if (!validate_pbo_access(ctx, &ctx->Unpack, mapsize, GL_INTENSITY,
                            GL_UNSIGNED_SHORT, INT_MAX, values)) {
d327 2
a328 2
void GLAPIENTRY
_mesa_GetnPixelMapfvARB( GLenum map, GLsizei bufSize, GLfloat *values )
d331 1
a331 1
   GLint mapsize, i;
d334 2
d344 2
a345 2
   if (!validate_pbo_access(ctx, &ctx->Pack, mapsize, GL_INTENSITY,
                            GL_FLOAT, bufSize, values)) {
d372 2
a373 8
void GLAPIENTRY
_mesa_GetPixelMapfv( GLenum map, GLfloat *values )
{
   _mesa_GetnPixelMapfvARB(map, INT_MAX, values);
}

void GLAPIENTRY
_mesa_GetnPixelMapuivARB( GLenum map, GLsizei bufSize, GLuint *values )
d379 2
a385 1

d388 2
a389 2
   if (!validate_pbo_access(ctx, &ctx->Pack, mapsize, GL_INTENSITY,
                            GL_UNSIGNED_INT, bufSize, values)) {
d416 2
a417 8
void GLAPIENTRY
_mesa_GetPixelMapuiv( GLenum map, GLuint *values )
{
   _mesa_GetnPixelMapuivARB(map, INT_MAX, values);
}

void GLAPIENTRY
_mesa_GetnPixelMapusvARB( GLenum map, GLsizei bufSize, GLushort *values )
d423 2
a429 1

d432 2
a433 2
   if (!validate_pbo_access(ctx, &ctx->Pack, mapsize, GL_INTENSITY,
                            GL_UNSIGNED_SHORT, bufSize, values)) {
a467 6
void GLAPIENTRY
_mesa_GetPixelMapusv( GLenum map, GLushort *values )
{
   _mesa_GetnPixelMapusvARB(map, INT_MAX, values);
}

d478 1
a478 1
void GLAPIENTRY
d482 1
d576 1
a576 1
void GLAPIENTRY
d618 1
a618 1
   if (new_state & _NEW_PIXEL)
d623 18
d650 1
d687 3
@


