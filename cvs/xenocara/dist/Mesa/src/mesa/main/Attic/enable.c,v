head	1.13;
access;
symbols
	OPENBSD_5_8:1.12.0.4
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	v10_2_9:1.1.1.7
	v10_4_3:1.1.1.6
	v10_2_7:1.1.1.5
	OPENBSD_5_6:1.10.0.2
	OPENBSD_5_6_BASE:1.10
	v10_2_3:1.1.1.5
	OPENBSD_5_5:1.9.0.2
	OPENBSD_5_5_BASE:1.9
	v9_2_5:1.1.1.4
	v9_2_3:1.1.1.4
	v9_2_2:1.1.1.4
	v9_2_1:1.1.1.4
	v9_2_0:1.1.1.4
	OPENBSD_5_4:1.8.0.4
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.2
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.7.0.4
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	v7_10_3:1.1.1.3
	OPENBSD_5_0:1.6.0.6
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.4
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.5.0.4
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.2
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.4.0.2
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.3.0.2
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_3:1.2.0.2
	v7_0_1:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v6_5_2:1.1.1.1
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2015.12.23.05.17.52;	author jsg;	state dead;
branches;
next	1.12;
commitid	TnlogFl9nOv2eaRf;

1.12
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.11;
commitid	4ry2gvZGMXkCUD2n;

1.11
date	2015.01.25.14.41.21;	author jsg;	state Exp;
branches;
next	1.10;
commitid	mcxB0JvoI9gTDYXU;

1.10
date	2014.07.09.21.09.00;	author jsg;	state Exp;
branches;
next	1.9;
commitid	WPD6rgPryPkvXOr9;

1.9
date	2013.09.05.14.06.20;	author jsg;	state Exp;
branches;
next	1.8;

1.8
date	2012.08.17.13.58.19;	author mpi;	state Exp;
branches;
next	1.7;

1.7
date	2011.10.23.13.37.42;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.05.22.20.06.30;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2009.05.17.20.26.41;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2008.11.02.14.58.20;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.05.31.16.36.48;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.02.12.21.09.27;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.49.55;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.49.55;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.30.58;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.10.23.13.29.45;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.09.05.13.16.31;	author jsg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2014.07.09.20.34.59;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.6
date	2015.01.25.14.12.34;	author jsg;	state Exp;
branches;
next	1.1.1.7;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.7
date	2015.02.20.22.49.41;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.13
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**
 * \file enable.c
 * Enable/disable/query GL capabilities.
 */

/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */


#include "glheader.h"
#include "clip.h"
#include "context.h"
#include "enable.h"
#include "errors.h"
#include "light.h"
#include "simple_list.h"
#include "mtypes.h"
#include "enums.h"
#include "api_arrayelt.h"
#include "texstate.h"
#include "drivers/common/meta.h"



#define CHECK_EXTENSION(EXTNAME, CAP)					\
   if (!ctx->Extensions.EXTNAME) {					\
      goto invalid_enum_error;						\
   }


static void
update_derived_primitive_restart_state(struct gl_context *ctx)
{
   /* Update derived primitive restart state.
    */
   ctx->Array._PrimitiveRestart = ctx->Array.PrimitiveRestart
      || ctx->Array.PrimitiveRestartFixedIndex;
}

/**
 * Helper to enable/disable client-side state.
 */
static void
client_state(struct gl_context *ctx, GLenum cap, GLboolean state)
{
   struct gl_vertex_array_object *vao = ctx->Array.VAO;
   GLbitfield64 flag;
   GLboolean *var;

   switch (cap) {
      case GL_VERTEX_ARRAY:
         var = &vao->VertexAttrib[VERT_ATTRIB_POS].Enabled;
         flag = VERT_BIT_POS;
         break;
      case GL_NORMAL_ARRAY:
         var = &vao->VertexAttrib[VERT_ATTRIB_NORMAL].Enabled;
         flag = VERT_BIT_NORMAL;
         break;
      case GL_COLOR_ARRAY:
         var = &vao->VertexAttrib[VERT_ATTRIB_COLOR0].Enabled;
         flag = VERT_BIT_COLOR0;
         break;
      case GL_INDEX_ARRAY:
         var = &vao->VertexAttrib[VERT_ATTRIB_COLOR_INDEX].Enabled;
         flag = VERT_BIT_COLOR_INDEX;
         break;
      case GL_TEXTURE_COORD_ARRAY:
         var = &vao->VertexAttrib[VERT_ATTRIB_TEX(ctx->Array.ActiveTexture)].Enabled;
         flag = VERT_BIT_TEX(ctx->Array.ActiveTexture);
         break;
      case GL_EDGE_FLAG_ARRAY:
         var = &vao->VertexAttrib[VERT_ATTRIB_EDGEFLAG].Enabled;
         flag = VERT_BIT_EDGEFLAG;
         break;
      case GL_FOG_COORDINATE_ARRAY_EXT:
         var = &vao->VertexAttrib[VERT_ATTRIB_FOG].Enabled;
         flag = VERT_BIT_FOG;
         break;
      case GL_SECONDARY_COLOR_ARRAY_EXT:
         var = &vao->VertexAttrib[VERT_ATTRIB_COLOR1].Enabled;
         flag = VERT_BIT_COLOR1;
         break;

      case GL_POINT_SIZE_ARRAY_OES:
         var = &vao->VertexAttrib[VERT_ATTRIB_POINT_SIZE].Enabled;
         flag = VERT_BIT_POINT_SIZE;
         break;

      /* GL_NV_primitive_restart */
      case GL_PRIMITIVE_RESTART_NV:
	 if (!ctx->Extensions.NV_primitive_restart) {
            goto invalid_enum_error;
         }
         var = &ctx->Array.PrimitiveRestart;
         flag = 0;
         break;

      default:
         goto invalid_enum_error;
   }

   if (*var == state)
      return;

   FLUSH_VERTICES(ctx, _NEW_ARRAY);

   _ae_invalidate_state(ctx, _NEW_ARRAY);

   *var = state;

   update_derived_primitive_restart_state(ctx);

   if (state)
      vao->_Enabled |= flag;
   else
      vao->_Enabled &= ~flag;

   vao->NewArrays |= flag;

   if (ctx->Driver.Enable) {
      ctx->Driver.Enable( ctx, cap, state );
   }

   return;

invalid_enum_error:
   _mesa_error(ctx, GL_INVALID_ENUM, "gl%sClientState(%s)",
               state ? "Enable" : "Disable", _mesa_lookup_enum_by_nr(cap));
}


/**
 * Enable GL capability.
 * \param cap  state to enable/disable.
 *
 * Get's the current context, assures that we're outside glBegin()/glEnd() and
 * calls client_state().
 */
void GLAPIENTRY
_mesa_EnableClientState( GLenum cap )
{
   GET_CURRENT_CONTEXT(ctx);
   client_state( ctx, cap, GL_TRUE );
}


/**
 * Disable GL capability.
 * \param cap  state to enable/disable.
 *
 * Get's the current context, assures that we're outside glBegin()/glEnd() and
 * calls client_state().
 */
void GLAPIENTRY
_mesa_DisableClientState( GLenum cap )
{
   GET_CURRENT_CONTEXT(ctx);
   client_state( ctx, cap, GL_FALSE );
}


#undef CHECK_EXTENSION
#define CHECK_EXTENSION(EXTNAME, CAP)					\
   if (!ctx->Extensions.EXTNAME) {					\
      goto invalid_enum_error;						\
   }

#define CHECK_EXTENSION2(EXT1, EXT2, CAP)				\
   if (!ctx->Extensions.EXT1 && !ctx->Extensions.EXT2) {		\
      goto invalid_enum_error;						\
   }

/**
 * Return pointer to current texture unit for setting/getting coordinate
 * state.
 * Note that we'll set GL_INVALID_OPERATION and return NULL if the active
 * texture unit is higher than the number of supported coordinate units.
 */
static struct gl_texture_unit *
get_texcoord_unit(struct gl_context *ctx)
{
   if (ctx->Texture.CurrentUnit >= ctx->Const.MaxTextureCoordUnits) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glEnable/Disable(texcoord unit)");
      return NULL;
   }
   else {
      return &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
   }
}


/**
 * Helper function to enable or disable a texture target.
 * \param bit  one of the TEXTURE_x_BIT values
 * \return GL_TRUE if state is changing or GL_FALSE if no change
 */
static GLboolean
enable_texture(struct gl_context *ctx, GLboolean state, GLbitfield texBit)
{
   struct gl_texture_unit *texUnit = _mesa_get_current_tex_unit(ctx);
   const GLbitfield newenabled = state
      ? (texUnit->Enabled | texBit) : (texUnit->Enabled & ~texBit);

   if (texUnit->Enabled == newenabled)
       return GL_FALSE;

   FLUSH_VERTICES(ctx, _NEW_TEXTURE);
   texUnit->Enabled = newenabled;
   return GL_TRUE;
}


/**
 * Helper function to enable or disable GL_MULTISAMPLE, skipping the check for
 * whether the API supports it (GLES doesn't).
 */
void
_mesa_set_multisample(struct gl_context *ctx, GLboolean state)
{
   if (ctx->Multisample.Enabled == state)
      return;
   FLUSH_VERTICES(ctx, _NEW_MULTISAMPLE);
   ctx->Multisample.Enabled = state;

   if (ctx->Driver.Enable) {
      ctx->Driver.Enable(ctx, GL_MULTISAMPLE, state);
   }
}

/**
 * Helper function to enable or disable GL_FRAMEBUFFER_SRGB, skipping the
 * check for whether the API supports it (GLES doesn't).
 */
void
_mesa_set_framebuffer_srgb(struct gl_context *ctx, GLboolean state)
{
   if (ctx->Color.sRGBEnabled == state)
      return;
   FLUSH_VERTICES(ctx, _NEW_BUFFERS);
   ctx->Color.sRGBEnabled = state;

   if (ctx->Driver.Enable) {
      ctx->Driver.Enable(ctx, GL_FRAMEBUFFER_SRGB, state);
   }
}

/**
 * Helper function to enable or disable state.
 *
 * \param ctx GL context.
 * \param cap  the state to enable/disable
 * \param state whether to enable or disable the specified capability.
 *
 * Updates the current context and flushes the vertices as needed. For
 * capabilities associated with extensions it verifies that those extensions
 * are effectivly present before updating. Notifies the driver via
 * dd_function_table::Enable.
 */
void
_mesa_set_enable(struct gl_context *ctx, GLenum cap, GLboolean state)
{
   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "%s %s (newstate is %x)\n",
                  state ? "glEnable" : "glDisable",
                  _mesa_lookup_enum_by_nr(cap),
                  ctx->NewState);

   switch (cap) {
      case GL_ALPHA_TEST:
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
         if (ctx->Color.AlphaEnabled == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_COLOR);
         ctx->Color.AlphaEnabled = state;
         break;
      case GL_AUTO_NORMAL:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
         if (ctx->Eval.AutoNormal == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_EVAL);
         ctx->Eval.AutoNormal = state;
         break;
      case GL_BLEND:
         {
            GLbitfield newEnabled =
               state * ((1 << ctx->Const.MaxDrawBuffers) - 1);
            if (newEnabled != ctx->Color.BlendEnabled) {
               FLUSH_VERTICES(ctx, _NEW_COLOR);
               ctx->Color.BlendEnabled = newEnabled;
            }
         }
         break;
      case GL_CLIP_DISTANCE0:
      case GL_CLIP_DISTANCE1:
      case GL_CLIP_DISTANCE2:
      case GL_CLIP_DISTANCE3:
      case GL_CLIP_DISTANCE4:
      case GL_CLIP_DISTANCE5:
      case GL_CLIP_DISTANCE6:
      case GL_CLIP_DISTANCE7:
         {
            const GLuint p = cap - GL_CLIP_DISTANCE0;

            if (p >= ctx->Const.MaxClipPlanes)
               goto invalid_enum_error;

            if ((ctx->Transform.ClipPlanesEnabled & (1 << p))
                == ((GLuint) state << p))
               return;

            FLUSH_VERTICES(ctx, _NEW_TRANSFORM);

            if (state) {
               ctx->Transform.ClipPlanesEnabled |= (1 << p);
               _mesa_update_clip_plane(ctx, p);
            }
            else {
               ctx->Transform.ClipPlanesEnabled &= ~(1 << p);
            }               
         }
         break;
      case GL_COLOR_MATERIAL:
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
         if (ctx->Light.ColorMaterialEnabled == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_LIGHT);
         FLUSH_CURRENT(ctx, 0);
         ctx->Light.ColorMaterialEnabled = state;
         if (state) {
            _mesa_update_color_material( ctx,
                                  ctx->Current.Attrib[VERT_ATTRIB_COLOR0] );
         }
         break;
      case GL_CULL_FACE:
         if (ctx->Polygon.CullFlag == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_POLYGON);
         ctx->Polygon.CullFlag = state;
         break;
      case GL_DEPTH_TEST:
         if (ctx->Depth.Test == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_DEPTH);
         ctx->Depth.Test = state;
         break;
      case GL_DEBUG_OUTPUT:
      case GL_DEBUG_OUTPUT_SYNCHRONOUS_ARB:
         if (!_mesa_is_desktop_gl(ctx))
            goto invalid_enum_error;
         else
            _mesa_set_debug_state_int(ctx, cap, state);
         break;
      case GL_DITHER:
         if (ctx->Color.DitherFlag == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_COLOR);
         ctx->Color.DitherFlag = state;
         break;
      case GL_FOG:
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
         if (ctx->Fog.Enabled == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_FOG);
         ctx->Fog.Enabled = state;
         break;
      case GL_LIGHT0:
      case GL_LIGHT1:
      case GL_LIGHT2:
      case GL_LIGHT3:
      case GL_LIGHT4:
      case GL_LIGHT5:
      case GL_LIGHT6:
      case GL_LIGHT7:
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
         if (ctx->Light.Light[cap-GL_LIGHT0].Enabled == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_LIGHT);
         ctx->Light.Light[cap-GL_LIGHT0].Enabled = state;
         if (state) {
            insert_at_tail(&ctx->Light.EnabledList,
                           &ctx->Light.Light[cap-GL_LIGHT0]);
         }
         else {
            remove_from_list(&ctx->Light.Light[cap-GL_LIGHT0]);
         }
         break;
      case GL_LIGHTING:
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
         if (ctx->Light.Enabled == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_LIGHT);
         ctx->Light.Enabled = state;
         break;
      case GL_LINE_SMOOTH:
         if (!_mesa_is_desktop_gl(ctx) && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
         if (ctx->Line.SmoothFlag == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_LINE);
         ctx->Line.SmoothFlag = state;
         break;
      case GL_LINE_STIPPLE:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
         if (ctx->Line.StippleFlag == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_LINE);
         ctx->Line.StippleFlag = state;
         break;
      case GL_INDEX_LOGIC_OP:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
         if (ctx->Color.IndexLogicOpEnabled == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_COLOR);
         ctx->Color.IndexLogicOpEnabled = state;
         break;
      case GL_COLOR_LOGIC_OP:
         if (!_mesa_is_desktop_gl(ctx) && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
         if (ctx->Color.ColorLogicOpEnabled == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_COLOR);
         ctx->Color.ColorLogicOpEnabled = state;
         break;
      case GL_MAP1_COLOR_4:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
         if (ctx->Eval.Map1Color4 == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_EVAL);
         ctx->Eval.Map1Color4 = state;
         break;
      case GL_MAP1_INDEX:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
         if (ctx->Eval.Map1Index == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_EVAL);
         ctx->Eval.Map1Index = state;
         break;
      case GL_MAP1_NORMAL:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
         if (ctx->Eval.Map1Normal == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_EVAL);
         ctx->Eval.Map1Normal = state;
         break;
      case GL_MAP1_TEXTURE_COORD_1:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
         if (ctx->Eval.Map1TextureCoord1 == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_EVAL);
         ctx->Eval.Map1TextureCoord1 = state;
         break;
      case GL_MAP1_TEXTURE_COORD_2:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
         if (ctx->Eval.Map1TextureCoord2 == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_EVAL);
         ctx->Eval.Map1TextureCoord2 = state;
         break;
      case GL_MAP1_TEXTURE_COORD_3:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
         if (ctx->Eval.Map1TextureCoord3 == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_EVAL);
         ctx->Eval.Map1TextureCoord3 = state;
         break;
      case GL_MAP1_TEXTURE_COORD_4:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
         if (ctx->Eval.Map1TextureCoord4 == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_EVAL);
         ctx->Eval.Map1TextureCoord4 = state;
         break;
      case GL_MAP1_VERTEX_3:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
         if (ctx->Eval.Map1Vertex3 == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_EVAL);
         ctx->Eval.Map1Vertex3 = state;
         break;
      case GL_MAP1_VERTEX_4:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
         if (ctx->Eval.Map1Vertex4 == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_EVAL);
         ctx->Eval.Map1Vertex4 = state;
         break;
      case GL_MAP2_COLOR_4:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
         if (ctx->Eval.Map2Color4 == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_EVAL);
         ctx->Eval.Map2Color4 = state;
         break;
      case GL_MAP2_INDEX:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
         if (ctx->Eval.Map2Index == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_EVAL);
         ctx->Eval.Map2Index = state;
         break;
      case GL_MAP2_NORMAL:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
         if (ctx->Eval.Map2Normal == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_EVAL);
         ctx->Eval.Map2Normal = state;
         break;
      case GL_MAP2_TEXTURE_COORD_1:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
         if (ctx->Eval.Map2TextureCoord1 == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_EVAL);
         ctx->Eval.Map2TextureCoord1 = state;
         break;
      case GL_MAP2_TEXTURE_COORD_2:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
         if (ctx->Eval.Map2TextureCoord2 == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_EVAL);
         ctx->Eval.Map2TextureCoord2 = state;
         break;
      case GL_MAP2_TEXTURE_COORD_3:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
         if (ctx->Eval.Map2TextureCoord3 == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_EVAL);
         ctx->Eval.Map2TextureCoord3 = state;
         break;
      case GL_MAP2_TEXTURE_COORD_4:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
         if (ctx->Eval.Map2TextureCoord4 == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_EVAL);
         ctx->Eval.Map2TextureCoord4 = state;
         break;
      case GL_MAP2_VERTEX_3:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
         if (ctx->Eval.Map2Vertex3 == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_EVAL);
         ctx->Eval.Map2Vertex3 = state;
         break;
      case GL_MAP2_VERTEX_4:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
         if (ctx->Eval.Map2Vertex4 == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_EVAL);
         ctx->Eval.Map2Vertex4 = state;
         break;
      case GL_NORMALIZE:
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
         if (ctx->Transform.Normalize == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_TRANSFORM);
         ctx->Transform.Normalize = state;
         break;
      case GL_POINT_SMOOTH:
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
         if (ctx->Point.SmoothFlag == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_POINT);
         ctx->Point.SmoothFlag = state;
         break;
      case GL_POLYGON_SMOOTH:
         if (!_mesa_is_desktop_gl(ctx))
            goto invalid_enum_error;
         if (ctx->Polygon.SmoothFlag == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_POLYGON);
         ctx->Polygon.SmoothFlag = state;
         break;
      case GL_POLYGON_STIPPLE:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
         if (ctx->Polygon.StippleFlag == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_POLYGON);
         ctx->Polygon.StippleFlag = state;
         break;
      case GL_POLYGON_OFFSET_POINT:
         if (!_mesa_is_desktop_gl(ctx))
            goto invalid_enum_error;
         if (ctx->Polygon.OffsetPoint == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_POLYGON);
         ctx->Polygon.OffsetPoint = state;
         break;
      case GL_POLYGON_OFFSET_LINE:
         if (!_mesa_is_desktop_gl(ctx))
            goto invalid_enum_error;
         if (ctx->Polygon.OffsetLine == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_POLYGON);
         ctx->Polygon.OffsetLine = state;
         break;
      case GL_POLYGON_OFFSET_FILL:
         if (ctx->Polygon.OffsetFill == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_POLYGON);
         ctx->Polygon.OffsetFill = state;
         break;
      case GL_RESCALE_NORMAL_EXT:
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
         if (ctx->Transform.RescaleNormals == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_TRANSFORM);
         ctx->Transform.RescaleNormals = state;
         break;
      case GL_SCISSOR_TEST:
         {
            /* Must expand glEnable to all scissors */
            GLbitfield newEnabled =
               state * ((1 << ctx->Const.MaxViewports) - 1);
            if (newEnabled != ctx->Scissor.EnableFlags) {
               FLUSH_VERTICES(ctx, _NEW_SCISSOR);
               ctx->Scissor.EnableFlags = newEnabled;
            }
         }
         break;
      case GL_STENCIL_TEST:
         if (ctx->Stencil.Enabled == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_STENCIL);
         ctx->Stencil.Enabled = state;
         break;
      case GL_TEXTURE_1D:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
         if (!enable_texture(ctx, state, TEXTURE_1D_BIT)) {
            return;
         }
         break;
      case GL_TEXTURE_2D:
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
         if (!enable_texture(ctx, state, TEXTURE_2D_BIT)) {
            return;
         }
         break;
      case GL_TEXTURE_3D:
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
         if (!enable_texture(ctx, state, TEXTURE_3D_BIT)) {
            return;
         }
         break;
      case GL_TEXTURE_GEN_S:
      case GL_TEXTURE_GEN_T:
      case GL_TEXTURE_GEN_R:
      case GL_TEXTURE_GEN_Q:
         {
            struct gl_texture_unit *texUnit = get_texcoord_unit(ctx);

            if (ctx->API != API_OPENGL_COMPAT)
               goto invalid_enum_error;

            if (texUnit) {
               GLbitfield coordBit = S_BIT << (cap - GL_TEXTURE_GEN_S);
               GLbitfield newenabled = texUnit->TexGenEnabled & ~coordBit;
               if (state)
                  newenabled |= coordBit;
               if (texUnit->TexGenEnabled == newenabled)
                  return;
               FLUSH_VERTICES(ctx, _NEW_TEXTURE);
               texUnit->TexGenEnabled = newenabled;
            }
         }
         break;

      case GL_TEXTURE_GEN_STR_OES:
	 /* disable S, T, and R at the same time */
	 {
            struct gl_texture_unit *texUnit = get_texcoord_unit(ctx);

            if (ctx->API != API_OPENGLES)
               goto invalid_enum_error;

            if (texUnit) {
               GLuint newenabled =
		  texUnit->TexGenEnabled & ~STR_BITS;
               if (state)
                  newenabled |= STR_BITS;
               if (texUnit->TexGenEnabled == newenabled)
                  return;
               FLUSH_VERTICES(ctx, _NEW_TEXTURE);
               texUnit->TexGenEnabled = newenabled;
            }
         }
         break;

      /* client-side state */
      case GL_VERTEX_ARRAY:
      case GL_NORMAL_ARRAY:
      case GL_COLOR_ARRAY:
      case GL_INDEX_ARRAY:
      case GL_TEXTURE_COORD_ARRAY:
      case GL_EDGE_FLAG_ARRAY:
      case GL_FOG_COORDINATE_ARRAY_EXT:
      case GL_SECONDARY_COLOR_ARRAY_EXT:
      case GL_POINT_SIZE_ARRAY_OES:
         client_state( ctx, cap, state );
         return;

      /* GL_ARB_texture_cube_map */
      case GL_TEXTURE_CUBE_MAP_ARB:
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
         CHECK_EXTENSION(ARB_texture_cube_map, cap);
         if (!enable_texture(ctx, state, TEXTURE_CUBE_BIT)) {
            return;
         }
         break;

      /* GL_EXT_secondary_color */
      case GL_COLOR_SUM_EXT:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
         if (ctx->Fog.ColorSumEnabled == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_FOG);
         ctx->Fog.ColorSumEnabled = state;
         break;

      /* GL_ARB_multisample */
      case GL_MULTISAMPLE_ARB:
         if (!_mesa_is_desktop_gl(ctx) && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
         _mesa_set_multisample(ctx, state);
         return;
      case GL_SAMPLE_ALPHA_TO_COVERAGE_ARB:
         if (ctx->Multisample.SampleAlphaToCoverage == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_MULTISAMPLE);
         ctx->Multisample.SampleAlphaToCoverage = state;
         break;
      case GL_SAMPLE_ALPHA_TO_ONE_ARB:
         if (!_mesa_is_desktop_gl(ctx) && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
         if (ctx->Multisample.SampleAlphaToOne == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_MULTISAMPLE);
         ctx->Multisample.SampleAlphaToOne = state;
         break;
      case GL_SAMPLE_COVERAGE_ARB:
         if (ctx->Multisample.SampleCoverage == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_MULTISAMPLE);
         ctx->Multisample.SampleCoverage = state;
         break;
      case GL_SAMPLE_COVERAGE_INVERT_ARB:
         if (!_mesa_is_desktop_gl(ctx))
            goto invalid_enum_error;
         if (ctx->Multisample.SampleCoverageInvert == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_MULTISAMPLE);
         ctx->Multisample.SampleCoverageInvert = state;
         break;

      /* GL_ARB_sample_shading */
      case GL_SAMPLE_SHADING:
         if (!_mesa_is_desktop_gl(ctx))
            goto invalid_enum_error;
         CHECK_EXTENSION(ARB_sample_shading, cap);
         if (ctx->Multisample.SampleShading == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_MULTISAMPLE);
         ctx->Multisample.SampleShading = state;
         break;

      /* GL_IBM_rasterpos_clip */
      case GL_RASTER_POSITION_UNCLIPPED_IBM:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
         if (ctx->Transform.RasterPositionUnclipped == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_TRANSFORM);
         ctx->Transform.RasterPositionUnclipped = state;
         break;

      /* GL_NV_point_sprite */
      case GL_POINT_SPRITE_NV:
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
         CHECK_EXTENSION2(NV_point_sprite, ARB_point_sprite, cap);
         if (ctx->Point.PointSprite == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_POINT);
         ctx->Point.PointSprite = state;
         break;

      case GL_VERTEX_PROGRAM_ARB:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
         CHECK_EXTENSION(ARB_vertex_program, cap);
         if (ctx->VertexProgram.Enabled == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_PROGRAM); 
         ctx->VertexProgram.Enabled = state;
         break;
      case GL_VERTEX_PROGRAM_POINT_SIZE_ARB:
         /* This was added with ARB_vertex_program, but it is also used with
          * GLSL vertex shaders on desktop.
          */
         if (!_mesa_is_desktop_gl(ctx))
            goto invalid_enum_error;
         CHECK_EXTENSION(ARB_vertex_program, cap);
         if (ctx->VertexProgram.PointSizeEnabled == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_PROGRAM);
         ctx->VertexProgram.PointSizeEnabled = state;
         break;
      case GL_VERTEX_PROGRAM_TWO_SIDE_ARB:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
         CHECK_EXTENSION(ARB_vertex_program, cap);
         if (ctx->VertexProgram.TwoSideEnabled == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_PROGRAM); 
         ctx->VertexProgram.TwoSideEnabled = state;
         break;

      /* GL_NV_texture_rectangle */
      case GL_TEXTURE_RECTANGLE_NV:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
         CHECK_EXTENSION(NV_texture_rectangle, cap);
         if (!enable_texture(ctx, state, TEXTURE_RECT_BIT)) {
            return;
         }
         break;

      /* GL_EXT_stencil_two_side */
      case GL_STENCIL_TEST_TWO_SIDE_EXT:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
         CHECK_EXTENSION(EXT_stencil_two_side, cap);
         if (ctx->Stencil.TestTwoSide == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_STENCIL);
         ctx->Stencil.TestTwoSide = state;
         if (state) {
            ctx->Stencil._BackFace = 2;
         } else {
            ctx->Stencil._BackFace = 1;
         }
         break;

      case GL_FRAGMENT_PROGRAM_ARB:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
         CHECK_EXTENSION(ARB_fragment_program, cap);
         if (ctx->FragmentProgram.Enabled == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_PROGRAM);
         ctx->FragmentProgram.Enabled = state;
         break;

      /* GL_EXT_depth_bounds_test */
      case GL_DEPTH_BOUNDS_TEST_EXT:
         if (!_mesa_is_desktop_gl(ctx))
            goto invalid_enum_error;
         CHECK_EXTENSION(EXT_depth_bounds_test, cap);
         if (ctx->Depth.BoundsTest == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_DEPTH);
         ctx->Depth.BoundsTest = state;
         break;

      case GL_DEPTH_CLAMP:
         if (!_mesa_is_desktop_gl(ctx))
            goto invalid_enum_error;
	 CHECK_EXTENSION(ARB_depth_clamp, cap);
         if (ctx->Transform.DepthClamp == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_TRANSFORM);
	 ctx->Transform.DepthClamp = state;
	 break;

      case GL_FRAGMENT_SHADER_ATI:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
        CHECK_EXTENSION(ATI_fragment_shader, cap);
	if (ctx->ATIFragmentShader.Enabled == state)
	  return;
	FLUSH_VERTICES(ctx, _NEW_PROGRAM);
	ctx->ATIFragmentShader.Enabled = state;
        break;

      case GL_TEXTURE_CUBE_MAP_SEAMLESS:
         if (!_mesa_is_desktop_gl(ctx))
            goto invalid_enum_error;
	 CHECK_EXTENSION(ARB_seamless_cube_map, cap);
	 if (ctx->Texture.CubeMapSeamless != state) {
	    FLUSH_VERTICES(ctx, _NEW_TEXTURE);
	    ctx->Texture.CubeMapSeamless = state;
	 }
	 break;

      case GL_RASTERIZER_DISCARD:
         if (!_mesa_is_desktop_gl(ctx) && !_mesa_is_gles3(ctx))
            goto invalid_enum_error;
	 CHECK_EXTENSION(EXT_transform_feedback, cap);
         if (ctx->RasterDiscard != state) {
            FLUSH_VERTICES(ctx, 0);
            ctx->NewDriverState |= ctx->DriverFlags.NewRasterizerDiscard;
            ctx->RasterDiscard = state;
         }
         break;

      /* GL 3.1 primitive restart.  Note: this enum is different from
       * GL_PRIMITIVE_RESTART_NV (which is client state).
       */
      case GL_PRIMITIVE_RESTART:
         if (!_mesa_is_desktop_gl(ctx) || ctx->Version < 31) {
            goto invalid_enum_error;
         }
         if (ctx->Array.PrimitiveRestart != state) {
            FLUSH_VERTICES(ctx, _NEW_TRANSFORM);
            ctx->Array.PrimitiveRestart = state;
            update_derived_primitive_restart_state(ctx);
         }
         break;

      case GL_PRIMITIVE_RESTART_FIXED_INDEX:
	 if (!_mesa_is_gles3(ctx) && !ctx->Extensions.ARB_ES3_compatibility)
            goto invalid_enum_error;
         if (ctx->Array.PrimitiveRestartFixedIndex != state) {
            FLUSH_VERTICES(ctx, _NEW_TRANSFORM);
            ctx->Array.PrimitiveRestartFixedIndex = state;
            update_derived_primitive_restart_state(ctx);
         }
         break;

      /* GL3.0 - GL_framebuffer_sRGB */
      case GL_FRAMEBUFFER_SRGB_EXT:
         if (!_mesa_is_desktop_gl(ctx))
            goto invalid_enum_error;
         CHECK_EXTENSION(EXT_framebuffer_sRGB, cap);
         _mesa_set_framebuffer_srgb(ctx, state);
         return;

      /* GL_OES_EGL_image_external */
      case GL_TEXTURE_EXTERNAL_OES:
         if (!_mesa_is_gles(ctx))
            goto invalid_enum_error;
         CHECK_EXTENSION(OES_EGL_image_external, cap);
         if (!enable_texture(ctx, state, TEXTURE_EXTERNAL_BIT)) {
            return;
         }
         break;

      /* ARB_texture_multisample */
      case GL_SAMPLE_MASK:
         if (!_mesa_is_desktop_gl(ctx))
            goto invalid_enum_error;
         CHECK_EXTENSION(ARB_texture_multisample, cap);
         if (ctx->Multisample.SampleMask == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_MULTISAMPLE);
         ctx->Multisample.SampleMask = state;
         break;

      default:
         goto invalid_enum_error;
   }

   if (ctx->Driver.Enable) {
      ctx->Driver.Enable( ctx, cap, state );
   }

   return;

invalid_enum_error:
   _mesa_error(ctx, GL_INVALID_ENUM, "gl%s(%s)",
               state ? "Enable" : "Disable", _mesa_lookup_enum_by_nr(cap));
}


/**
 * Enable GL capability.  Called by glEnable()
 * \param cap  state to enable.
 */
void GLAPIENTRY
_mesa_Enable( GLenum cap )
{
   GET_CURRENT_CONTEXT(ctx);

   _mesa_set_enable( ctx, cap, GL_TRUE );
}


/**
 * Disable GL capability.  Called by glDisable()
 * \param cap  state to disable.
 */
void GLAPIENTRY
_mesa_Disable( GLenum cap )
{
   GET_CURRENT_CONTEXT(ctx);

   _mesa_set_enable( ctx, cap, GL_FALSE );
}



/**
 * Enable/disable an indexed state var.
 */
void
_mesa_set_enablei(struct gl_context *ctx, GLenum cap,
                  GLuint index, GLboolean state)
{
   ASSERT(state == 0 || state == 1);
   switch (cap) {
   case GL_BLEND:
      if (!ctx->Extensions.EXT_draw_buffers2) {
         goto invalid_enum_error;
      }
      if (index >= ctx->Const.MaxDrawBuffers) {
         _mesa_error(ctx, GL_INVALID_VALUE, "%s(index=%u)",
                     state ? "glEnableIndexed" : "glDisableIndexed", index);
         return;
      }
      if (((ctx->Color.BlendEnabled >> index) & 1) != state) {
         FLUSH_VERTICES(ctx, _NEW_COLOR);
         if (state)
            ctx->Color.BlendEnabled |= (1 << index);
         else
            ctx->Color.BlendEnabled &= ~(1 << index);
      }
      break;
   case GL_SCISSOR_TEST:
      if (index >= ctx->Const.MaxViewports) {
         _mesa_error(ctx, GL_INVALID_VALUE, "%s(index=%u)",
                     state ? "glEnablei" : "glDisablei", index);
         return;
      }
      if (((ctx->Scissor.EnableFlags >> index) & 1) != state) {
         FLUSH_VERTICES(ctx, _NEW_SCISSOR);
         if (state)
            ctx->Scissor.EnableFlags |= (1 << index);
         else
            ctx->Scissor.EnableFlags &= ~(1 << index);
      }
      break;
   default:
      goto invalid_enum_error;
   }
   return;

invalid_enum_error:
    _mesa_error(ctx, GL_INVALID_ENUM, "%s(cap=%s)",
                state ? "glEnablei" : "glDisablei",
                _mesa_lookup_enum_by_nr(cap));
}


void GLAPIENTRY
_mesa_Disablei( GLenum cap, GLuint index )
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_set_enablei(ctx, cap, index, GL_FALSE);
}


void GLAPIENTRY
_mesa_Enablei( GLenum cap, GLuint index )
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_set_enablei(ctx, cap, index, GL_TRUE);
}


GLboolean GLAPIENTRY
_mesa_IsEnabledi( GLenum cap, GLuint index )
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_WITH_RETVAL(ctx, 0);
   switch (cap) {
   case GL_BLEND:
      if (index >= ctx->Const.MaxDrawBuffers) {
         _mesa_error(ctx, GL_INVALID_VALUE, "glIsEnabledIndexed(index=%u)",
                     index);
         return GL_FALSE;
      }
      return (ctx->Color.BlendEnabled >> index) & 1;
   case GL_SCISSOR_TEST:
      if (index >= ctx->Const.MaxViewports) {
         _mesa_error(ctx, GL_INVALID_VALUE, "glIsEnabledIndexed(index=%u)",
                     index);
         return GL_FALSE;
      }
      return (ctx->Scissor.EnableFlags >> index) & 1;
   default:
      _mesa_error(ctx, GL_INVALID_ENUM, "glIsEnabledIndexed(cap=%s)",
                  _mesa_lookup_enum_by_nr(cap));
      return GL_FALSE;
   }
}




#undef CHECK_EXTENSION
#define CHECK_EXTENSION(EXTNAME)			\
   if (!ctx->Extensions.EXTNAME) {			\
      goto invalid_enum_error;				\
   }

#undef CHECK_EXTENSION2
#define CHECK_EXTENSION2(EXT1, EXT2)				\
   if (!ctx->Extensions.EXT1 && !ctx->Extensions.EXT2) {	\
      goto invalid_enum_error;					\
   }


/**
 * Helper function to determine whether a texture target is enabled.
 */
static GLboolean
is_texture_enabled(struct gl_context *ctx, GLbitfield bit)
{
   const struct gl_texture_unit *const texUnit =
       &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
   return (texUnit->Enabled & bit) ? GL_TRUE : GL_FALSE;
}


/**
 * Return simple enable/disable state.
 *
 * \param cap  state variable to query.
 *
 * Returns the state of the specified capability from the current GL context.
 * For the capabilities associated with extensions verifies that those
 * extensions are effectively present before reporting.
 */
GLboolean GLAPIENTRY
_mesa_IsEnabled( GLenum cap )
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_WITH_RETVAL(ctx, 0);

   switch (cap) {
      case GL_ALPHA_TEST:
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
         return ctx->Color.AlphaEnabled;
      case GL_AUTO_NORMAL:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
	 return ctx->Eval.AutoNormal;
      case GL_BLEND:
         return ctx->Color.BlendEnabled & 1;  /* return state for buffer[0] */
      case GL_CLIP_DISTANCE0:
      case GL_CLIP_DISTANCE1:
      case GL_CLIP_DISTANCE2:
      case GL_CLIP_DISTANCE3:
      case GL_CLIP_DISTANCE4:
      case GL_CLIP_DISTANCE5:
      case GL_CLIP_DISTANCE6:
      case GL_CLIP_DISTANCE7: {
         const GLuint p = cap - GL_CLIP_DISTANCE0;

         if (p >= ctx->Const.MaxClipPlanes)
            goto invalid_enum_error;

	 return (ctx->Transform.ClipPlanesEnabled >> p) & 1;
      }
      case GL_COLOR_MATERIAL:
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
	 return ctx->Light.ColorMaterialEnabled;
      case GL_CULL_FACE:
         return ctx->Polygon.CullFlag;
      case GL_DEBUG_OUTPUT:
      case GL_DEBUG_OUTPUT_SYNCHRONOUS_ARB:
         if (!_mesa_is_desktop_gl(ctx))
            goto invalid_enum_error;
         else
            return (GLboolean) _mesa_get_debug_state_int(ctx, cap);
      case GL_DEPTH_TEST:
         return ctx->Depth.Test;
      case GL_DITHER:
	 return ctx->Color.DitherFlag;
      case GL_FOG:
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
	 return ctx->Fog.Enabled;
      case GL_LIGHTING:
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
         return ctx->Light.Enabled;
      case GL_LIGHT0:
      case GL_LIGHT1:
      case GL_LIGHT2:
      case GL_LIGHT3:
      case GL_LIGHT4:
      case GL_LIGHT5:
      case GL_LIGHT6:
      case GL_LIGHT7:
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
         return ctx->Light.Light[cap-GL_LIGHT0].Enabled;
      case GL_LINE_SMOOTH:
         if (!_mesa_is_desktop_gl(ctx) && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
	 return ctx->Line.SmoothFlag;
      case GL_LINE_STIPPLE:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
	 return ctx->Line.StippleFlag;
      case GL_INDEX_LOGIC_OP:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
	 return ctx->Color.IndexLogicOpEnabled;
      case GL_COLOR_LOGIC_OP:
         if (!_mesa_is_desktop_gl(ctx) && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
	 return ctx->Color.ColorLogicOpEnabled;
      case GL_MAP1_COLOR_4:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
	 return ctx->Eval.Map1Color4;
      case GL_MAP1_INDEX:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
	 return ctx->Eval.Map1Index;
      case GL_MAP1_NORMAL:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
	 return ctx->Eval.Map1Normal;
      case GL_MAP1_TEXTURE_COORD_1:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
	 return ctx->Eval.Map1TextureCoord1;
      case GL_MAP1_TEXTURE_COORD_2:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
	 return ctx->Eval.Map1TextureCoord2;
      case GL_MAP1_TEXTURE_COORD_3:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
	 return ctx->Eval.Map1TextureCoord3;
      case GL_MAP1_TEXTURE_COORD_4:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
	 return ctx->Eval.Map1TextureCoord4;
      case GL_MAP1_VERTEX_3:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
	 return ctx->Eval.Map1Vertex3;
      case GL_MAP1_VERTEX_4:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
	 return ctx->Eval.Map1Vertex4;
      case GL_MAP2_COLOR_4:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
	 return ctx->Eval.Map2Color4;
      case GL_MAP2_INDEX:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
	 return ctx->Eval.Map2Index;
      case GL_MAP2_NORMAL:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
	 return ctx->Eval.Map2Normal;
      case GL_MAP2_TEXTURE_COORD_1:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
	 return ctx->Eval.Map2TextureCoord1;
      case GL_MAP2_TEXTURE_COORD_2:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
	 return ctx->Eval.Map2TextureCoord2;
      case GL_MAP2_TEXTURE_COORD_3:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
	 return ctx->Eval.Map2TextureCoord3;
      case GL_MAP2_TEXTURE_COORD_4:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
	 return ctx->Eval.Map2TextureCoord4;
      case GL_MAP2_VERTEX_3:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
	 return ctx->Eval.Map2Vertex3;
      case GL_MAP2_VERTEX_4:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
	 return ctx->Eval.Map2Vertex4;
      case GL_NORMALIZE:
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
	 return ctx->Transform.Normalize;
      case GL_POINT_SMOOTH:
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
	 return ctx->Point.SmoothFlag;
      case GL_POLYGON_SMOOTH:
         if (!_mesa_is_desktop_gl(ctx))
            goto invalid_enum_error;
	 return ctx->Polygon.SmoothFlag;
      case GL_POLYGON_STIPPLE:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
	 return ctx->Polygon.StippleFlag;
      case GL_POLYGON_OFFSET_POINT:
         if (!_mesa_is_desktop_gl(ctx))
            goto invalid_enum_error;
	 return ctx->Polygon.OffsetPoint;
      case GL_POLYGON_OFFSET_LINE:
         if (!_mesa_is_desktop_gl(ctx))
            goto invalid_enum_error;
	 return ctx->Polygon.OffsetLine;
      case GL_POLYGON_OFFSET_FILL:
	 return ctx->Polygon.OffsetFill;
      case GL_RESCALE_NORMAL_EXT:
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
         return ctx->Transform.RescaleNormals;
      case GL_SCISSOR_TEST:
	 return ctx->Scissor.EnableFlags & 1;  /* return state for index 0 */
      case GL_STENCIL_TEST:
	 return ctx->Stencil.Enabled;
      case GL_TEXTURE_1D:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
         return is_texture_enabled(ctx, TEXTURE_1D_BIT);
      case GL_TEXTURE_2D:
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
         return is_texture_enabled(ctx, TEXTURE_2D_BIT);
      case GL_TEXTURE_3D:
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
         return is_texture_enabled(ctx, TEXTURE_3D_BIT);
      case GL_TEXTURE_GEN_S:
      case GL_TEXTURE_GEN_T:
      case GL_TEXTURE_GEN_R:
      case GL_TEXTURE_GEN_Q:
         {
            const struct gl_texture_unit *texUnit = get_texcoord_unit(ctx);

            if (ctx->API != API_OPENGL_COMPAT)
               goto invalid_enum_error;

            if (texUnit) {
               GLbitfield coordBit = S_BIT << (cap - GL_TEXTURE_GEN_S);
               return (texUnit->TexGenEnabled & coordBit) ? GL_TRUE : GL_FALSE;
            }
         }
         return GL_FALSE;
      case GL_TEXTURE_GEN_STR_OES:
	 {
            const struct gl_texture_unit *texUnit = get_texcoord_unit(ctx);

            if (ctx->API != API_OPENGLES)
               goto invalid_enum_error;

            if (texUnit) {
               return (texUnit->TexGenEnabled & STR_BITS) == STR_BITS
                  ? GL_TRUE : GL_FALSE;
            }
         }

      /* client-side state */
      case GL_VERTEX_ARRAY:
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
         return ctx->Array.VAO->VertexAttrib[VERT_ATTRIB_POS].Enabled;
      case GL_NORMAL_ARRAY:
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
         return ctx->Array.VAO->VertexAttrib[VERT_ATTRIB_NORMAL].Enabled;
      case GL_COLOR_ARRAY:
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
         return ctx->Array.VAO->VertexAttrib[VERT_ATTRIB_COLOR0].Enabled;
      case GL_INDEX_ARRAY:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
         return ctx->Array.VAO->
            VertexAttrib[VERT_ATTRIB_COLOR_INDEX].Enabled;
      case GL_TEXTURE_COORD_ARRAY:
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
         return ctx->Array.VAO->
            VertexAttrib[VERT_ATTRIB_TEX(ctx->Array.ActiveTexture)].Enabled;
      case GL_EDGE_FLAG_ARRAY:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
         return ctx->Array.VAO->VertexAttrib[VERT_ATTRIB_EDGEFLAG].Enabled;
      case GL_FOG_COORDINATE_ARRAY_EXT:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
         return ctx->Array.VAO->VertexAttrib[VERT_ATTRIB_FOG].Enabled;
      case GL_SECONDARY_COLOR_ARRAY_EXT:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
         return ctx->Array.VAO->VertexAttrib[VERT_ATTRIB_COLOR1].Enabled;
      case GL_POINT_SIZE_ARRAY_OES:
         if (ctx->API != API_OPENGLES)
            goto invalid_enum_error;
         return ctx->Array.VAO->VertexAttrib[VERT_ATTRIB_POINT_SIZE].Enabled;

      /* GL_ARB_texture_cube_map */
      case GL_TEXTURE_CUBE_MAP_ARB:
         CHECK_EXTENSION(ARB_texture_cube_map);
         return is_texture_enabled(ctx, TEXTURE_CUBE_BIT);

      /* GL_EXT_secondary_color */
      case GL_COLOR_SUM_EXT:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
         return ctx->Fog.ColorSumEnabled;

      /* GL_ARB_multisample */
      case GL_MULTISAMPLE_ARB:
         if (!_mesa_is_desktop_gl(ctx) && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
         return ctx->Multisample.Enabled;
      case GL_SAMPLE_ALPHA_TO_COVERAGE_ARB:
         return ctx->Multisample.SampleAlphaToCoverage;
      case GL_SAMPLE_ALPHA_TO_ONE_ARB:
         if (!_mesa_is_desktop_gl(ctx) && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
         return ctx->Multisample.SampleAlphaToOne;
      case GL_SAMPLE_COVERAGE_ARB:
         return ctx->Multisample.SampleCoverage;
      case GL_SAMPLE_COVERAGE_INVERT_ARB:
         if (!_mesa_is_desktop_gl(ctx))
            goto invalid_enum_error;
         return ctx->Multisample.SampleCoverageInvert;

      /* GL_IBM_rasterpos_clip */
      case GL_RASTER_POSITION_UNCLIPPED_IBM:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
         return ctx->Transform.RasterPositionUnclipped;

      /* GL_NV_point_sprite */
      case GL_POINT_SPRITE_NV:
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
         CHECK_EXTENSION2(NV_point_sprite, ARB_point_sprite)
         return ctx->Point.PointSprite;

      case GL_VERTEX_PROGRAM_ARB:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
         CHECK_EXTENSION(ARB_vertex_program);
         return ctx->VertexProgram.Enabled;
      case GL_VERTEX_PROGRAM_POINT_SIZE_ARB:
         /* This was added with ARB_vertex_program, but it is also used with
          * GLSL vertex shaders on desktop.
          */
         if (!_mesa_is_desktop_gl(ctx))
            goto invalid_enum_error;
         CHECK_EXTENSION(ARB_vertex_program);
         return ctx->VertexProgram.PointSizeEnabled;
      case GL_VERTEX_PROGRAM_TWO_SIDE_ARB:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
         CHECK_EXTENSION(ARB_vertex_program);
         return ctx->VertexProgram.TwoSideEnabled;

      /* GL_NV_texture_rectangle */
      case GL_TEXTURE_RECTANGLE_NV:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
         CHECK_EXTENSION(NV_texture_rectangle);
         return is_texture_enabled(ctx, TEXTURE_RECT_BIT);

      /* GL_EXT_stencil_two_side */
      case GL_STENCIL_TEST_TWO_SIDE_EXT:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
         CHECK_EXTENSION(EXT_stencil_two_side);
         return ctx->Stencil.TestTwoSide;

      case GL_FRAGMENT_PROGRAM_ARB:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
         return ctx->FragmentProgram.Enabled;

      /* GL_EXT_depth_bounds_test */
      case GL_DEPTH_BOUNDS_TEST_EXT:
         if (!_mesa_is_desktop_gl(ctx))
            goto invalid_enum_error;
         CHECK_EXTENSION(EXT_depth_bounds_test);
         return ctx->Depth.BoundsTest;

      /* GL_ARB_depth_clamp */
      case GL_DEPTH_CLAMP:
         if (!_mesa_is_desktop_gl(ctx))
            goto invalid_enum_error;
         CHECK_EXTENSION(ARB_depth_clamp);
         return ctx->Transform.DepthClamp;

      case GL_FRAGMENT_SHADER_ATI:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
	 CHECK_EXTENSION(ATI_fragment_shader);
	 return ctx->ATIFragmentShader.Enabled;

      case GL_TEXTURE_CUBE_MAP_SEAMLESS:
         if (!_mesa_is_desktop_gl(ctx))
            goto invalid_enum_error;
	 CHECK_EXTENSION(ARB_seamless_cube_map);
	 return ctx->Texture.CubeMapSeamless;

      case GL_RASTERIZER_DISCARD:
         if (!_mesa_is_desktop_gl(ctx) && !_mesa_is_gles3(ctx))
            goto invalid_enum_error;
	 CHECK_EXTENSION(EXT_transform_feedback);
         return ctx->RasterDiscard;

      /* GL_NV_primitive_restart */
      case GL_PRIMITIVE_RESTART_NV:
         if (ctx->API != API_OPENGL_COMPAT || !ctx->Extensions.NV_primitive_restart) {
            goto invalid_enum_error;
         }
         return ctx->Array.PrimitiveRestart;

      /* GL 3.1 primitive restart */
      case GL_PRIMITIVE_RESTART:
         if (!_mesa_is_desktop_gl(ctx) || ctx->Version < 31) {
            goto invalid_enum_error;
         }
         return ctx->Array.PrimitiveRestart;

      case GL_PRIMITIVE_RESTART_FIXED_INDEX:
	 if (!_mesa_is_gles3(ctx) && !ctx->Extensions.ARB_ES3_compatibility) {
            goto invalid_enum_error;
         }
         return ctx->Array.PrimitiveRestartFixedIndex;

      /* GL3.0 - GL_framebuffer_sRGB */
      case GL_FRAMEBUFFER_SRGB_EXT:
         if (!_mesa_is_desktop_gl(ctx))
            goto invalid_enum_error;
	 CHECK_EXTENSION(EXT_framebuffer_sRGB);
	 return ctx->Color.sRGBEnabled;

      /* GL_OES_EGL_image_external */
      case GL_TEXTURE_EXTERNAL_OES:
         if (!_mesa_is_gles(ctx))
            goto invalid_enum_error;
	 CHECK_EXTENSION(OES_EGL_image_external);
         return is_texture_enabled(ctx, TEXTURE_EXTERNAL_BIT);

      /* ARB_texture_multisample */
      case GL_SAMPLE_MASK:
         if (!_mesa_is_desktop_gl(ctx))
            goto invalid_enum_error;
         CHECK_EXTENSION(ARB_texture_multisample);
         return ctx->Multisample.SampleMask;

      /* ARB_sample_shading */
      case GL_SAMPLE_SHADING:
         if (!_mesa_is_desktop_gl(ctx))
            goto invalid_enum_error;
         CHECK_EXTENSION(ARB_sample_shading);
         return ctx->Multisample.SampleShading;

      default:
         goto invalid_enum_error;
   }

   return GL_FALSE;

invalid_enum_error:
   _mesa_error(ctx, GL_INVALID_ENUM, "glIsEnabled(%s)",
               _mesa_lookup_enum_by_nr(cap));
   return GL_FALSE;
}
@


1.12
log
@Merge Mesa 10.2.9
@
text
@@


1.11
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d316 1
a316 1
      case GL_CLIP_DISTANCE0: /* aka GL_CLIP_PLANE0 */
d1205 1
a1205 1
      case GL_CLIP_DISTANCE0: /* aka GL_CLIP_PLANE0 */
@


1.10
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d316 1
a316 1
      case GL_CLIP_DISTANCE0:
d1205 1
a1205 1
      case GL_CLIP_DISTANCE0:
@


1.9
log
@Merge Mesa 9.2.0
@
text
@d35 1
d67 1
a67 1
   struct gl_array_object *arrayObj = ctx->Array.ArrayObj;
d73 1
a73 1
         var = &arrayObj->VertexAttrib[VERT_ATTRIB_POS].Enabled;
d77 1
a77 1
         var = &arrayObj->VertexAttrib[VERT_ATTRIB_NORMAL].Enabled;
d81 1
a81 1
         var = &arrayObj->VertexAttrib[VERT_ATTRIB_COLOR0].Enabled;
d85 1
a85 1
         var = &arrayObj->VertexAttrib[VERT_ATTRIB_COLOR_INDEX].Enabled;
d89 1
a89 1
         var = &arrayObj->VertexAttrib[VERT_ATTRIB_TEX(ctx->Array.ActiveTexture)].Enabled;
d93 1
a93 1
         var = &arrayObj->VertexAttrib[VERT_ATTRIB_EDGEFLAG].Enabled;
d97 1
a97 1
         var = &arrayObj->VertexAttrib[VERT_ATTRIB_FOG].Enabled;
d101 1
a101 1
         var = &arrayObj->VertexAttrib[VERT_ATTRIB_COLOR1].Enabled;
d106 1
a106 1
         var = &arrayObj->VertexAttrib[VERT_ATTRIB_POINT_SIZE].Enabled;
d135 1
a135 1
      arrayObj->_Enabled |= flag;
d137 3
a139 1
      arrayObj->_Enabled &= ~flag;
d370 1
d374 2
a375 1
         ctx->Debug.SyncOutput = state;
d660 9
a668 4
         if (ctx->Scissor.Enabled == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_SCISSOR);
         ctx->Scissor.Enabled = state;
a767 1
         CHECK_EXTENSION(ARB_vertex_program, cap);
d809 11
a938 19
      /* GL_MESA_texture_array */
      case GL_TEXTURE_1D_ARRAY_EXT:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
         CHECK_EXTENSION(MESA_texture_array, cap);
         if (!enable_texture(ctx, state, TEXTURE_1D_ARRAY_BIT)) {
            return;
         }
         break;

      case GL_TEXTURE_2D_ARRAY_EXT:
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
         CHECK_EXTENSION(MESA_texture_array, cap);
         if (!enable_texture(ctx, state, TEXTURE_2D_ARRAY_BIT)) {
            return;
         }
         break;

d1082 14
d1137 7
d1226 1
d1230 2
a1231 1
         return ctx->Debug.SyncOutput;
d1374 1
a1374 1
	 return ctx->Scissor.Enabled;
d1422 1
a1422 1
         return ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_POS].Enabled;
d1426 1
a1426 1
         return ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_NORMAL].Enabled;
d1430 1
a1430 1
         return ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_COLOR0].Enabled;
d1434 1
a1434 1
         return ctx->Array.ArrayObj->
d1439 1
a1439 1
         return ctx->Array.ArrayObj->
d1444 1
a1444 1
         return ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_EDGEFLAG].Enabled;
d1448 1
a1448 1
         return ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_FOG].Enabled;
d1452 1
a1452 1
         return ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_COLOR1].Enabled;
d1456 1
a1456 1
         return ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_POINT_SIZE].Enabled;
a1466 1
         CHECK_EXTENSION(ARB_vertex_program);
d1610 7
@


1.8
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a7 1
 * Version:  7.0.3
d24 4
a27 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
a36 1
#include "mfeatures.h"
d41 1
d51 9
d67 1
a67 1
   GLuint flag;
d72 2
a73 2
         var = &arrayObj->Vertex.Enabled;
         flag = _NEW_ARRAY_VERTEX;
d76 2
a77 2
         var = &arrayObj->Normal.Enabled;
         flag = _NEW_ARRAY_NORMAL;
d80 2
a81 2
         var = &arrayObj->Color.Enabled;
         flag = _NEW_ARRAY_COLOR0;
d84 2
a85 2
         var = &arrayObj->Index.Enabled;
         flag = _NEW_ARRAY_INDEX;
d88 2
a89 2
         var = &arrayObj->TexCoord[ctx->Array.ActiveTexture].Enabled;
         flag = _NEW_ARRAY_TEXCOORD(ctx->Array.ActiveTexture);
d92 2
a93 2
         var = &arrayObj->EdgeFlag.Enabled;
         flag = _NEW_ARRAY_EDGEFLAG;
d96 2
a97 2
         var = &arrayObj->FogCoord.Enabled;
         flag = _NEW_ARRAY_FOGCOORD;
d100 2
a101 2
         var = &arrayObj->SecondaryColor.Enabled;
         flag = _NEW_ARRAY_COLOR1;
a103 1
#if FEATURE_point_size_array
d105 2
a106 29
         var = &arrayObj->PointSize.Enabled;
         flag = _NEW_ARRAY_POINT_SIZE;
         break;
#endif

#if FEATURE_NV_vertex_program
      case GL_VERTEX_ATTRIB_ARRAY0_NV:
      case GL_VERTEX_ATTRIB_ARRAY1_NV:
      case GL_VERTEX_ATTRIB_ARRAY2_NV:
      case GL_VERTEX_ATTRIB_ARRAY3_NV:
      case GL_VERTEX_ATTRIB_ARRAY4_NV:
      case GL_VERTEX_ATTRIB_ARRAY5_NV:
      case GL_VERTEX_ATTRIB_ARRAY6_NV:
      case GL_VERTEX_ATTRIB_ARRAY7_NV:
      case GL_VERTEX_ATTRIB_ARRAY8_NV:
      case GL_VERTEX_ATTRIB_ARRAY9_NV:
      case GL_VERTEX_ATTRIB_ARRAY10_NV:
      case GL_VERTEX_ATTRIB_ARRAY11_NV:
      case GL_VERTEX_ATTRIB_ARRAY12_NV:
      case GL_VERTEX_ATTRIB_ARRAY13_NV:
      case GL_VERTEX_ATTRIB_ARRAY14_NV:
      case GL_VERTEX_ATTRIB_ARRAY15_NV:
         CHECK_EXTENSION(NV_vertex_program, cap);
         {
            GLint n = (GLint) cap - GL_VERTEX_ATTRIB_ARRAY0_NV;
            ASSERT(n < Elements(ctx->Array.ArrayObj->VertexAttrib));
            var = &arrayObj->VertexAttrib[n].Enabled;
            flag = _NEW_ARRAY_ATTRIB(n);
         }
a107 1
#endif /* FEATURE_NV_vertex_program */
a125 1
   ctx->Array.NewState |= flag;
d131 2
d134 1
a134 1
      ctx->Array.ArrayObj->_Enabled |= flag;
d136 1
a136 1
      ctx->Array.ArrayObj->_Enabled &= ~flag;
d145 2
a146 2
   _mesa_error(ctx, GL_INVALID_ENUM, "gl%sClientState(0x%x)",
               state ? "Enable" : "Disable", cap);
a160 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
a175 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
a190 2


d232 34
d288 2
d296 2
d313 8
a320 7
#if FEATURE_userclip
      case GL_CLIP_PLANE0:
      case GL_CLIP_PLANE1:
      case GL_CLIP_PLANE2:
      case GL_CLIP_PLANE3:
      case GL_CLIP_PLANE4:
      case GL_CLIP_PLANE5:
d322 4
a325 1
            const GLuint p = cap - GL_CLIP_PLANE0;
a341 1
#endif
d343 2
d367 5
d379 2
d394 2
d409 2
a414 4
         if (ctx->Light.Enabled && ctx->Light.Model.TwoSide)
            ctx->_TriangleCaps |= DD_TRI_LIGHT_TWOSIDE;
         else
            ctx->_TriangleCaps &= ~DD_TRI_LIGHT_TWOSIDE;
d417 2
a422 1
         ctx->_TriangleCaps ^= DD_LINE_SMOOTH;
d425 2
a430 1
         ctx->_TriangleCaps ^= DD_LINE_STIPPLE;
d433 2
d441 2
d449 2
d457 2
d465 2
d473 2
d481 2
d489 2
d497 2
d505 2
d513 2
d521 2
d529 2
d537 2
d545 2
d553 2
d561 2
d569 2
d577 2
d585 2
d593 2
d601 2
a606 1
         ctx->_TriangleCaps ^= DD_POINT_SMOOTH;
d609 2
a614 1
         ctx->_TriangleCaps ^= DD_TRI_SMOOTH;
d617 2
a622 1
         ctx->_TriangleCaps ^= DD_TRI_STIPPLE;
d625 2
d633 2
a640 1
         /*case GL_POLYGON_OFFSET_EXT:*/
d647 2
a659 6
      case GL_SHARED_TEXTURE_PALETTE_EXT:
         if (ctx->Texture.SharedPalette == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_TEXTURE);
         ctx->Texture.SharedPalette = state;
         break;
d667 2
d674 2
d681 2
d693 4
a709 1
#if FEATURE_ES1
d714 4
a729 1
#endif
d731 1
a731 3
      /*
       * CLIENT STATE!!!
       */
d746 2
d756 3
a758 1
         CHECK_EXTENSION2(EXT_secondary_color, ARB_vertex_program, cap);
d767 4
a770 5
         if (ctx->Multisample.Enabled == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_MULTISAMPLE);
         ctx->Multisample.Enabled = state;
         break;
d778 2
d792 2
d802 2
a803 1
         CHECK_EXTENSION(IBM_rasterpos_clip, cap);
d812 2
a820 1
#if FEATURE_NV_vertex_program || FEATURE_ARB_vertex_program
d822 3
a824 1
         CHECK_EXTENSION2(ARB_vertex_program, NV_vertex_program, cap);
d831 6
a836 1
         CHECK_EXTENSION2(ARB_vertex_program, NV_vertex_program, cap);
d843 3
a845 1
         CHECK_EXTENSION2(ARB_vertex_program, NV_vertex_program, cap);
a850 59
#endif
#if FEATURE_NV_vertex_program
      case GL_MAP1_VERTEX_ATTRIB0_4_NV:
      case GL_MAP1_VERTEX_ATTRIB1_4_NV:
      case GL_MAP1_VERTEX_ATTRIB2_4_NV:
      case GL_MAP1_VERTEX_ATTRIB3_4_NV:
      case GL_MAP1_VERTEX_ATTRIB4_4_NV:
      case GL_MAP1_VERTEX_ATTRIB5_4_NV:
      case GL_MAP1_VERTEX_ATTRIB6_4_NV:
      case GL_MAP1_VERTEX_ATTRIB7_4_NV:
      case GL_MAP1_VERTEX_ATTRIB8_4_NV:
      case GL_MAP1_VERTEX_ATTRIB9_4_NV:
      case GL_MAP1_VERTEX_ATTRIB10_4_NV:
      case GL_MAP1_VERTEX_ATTRIB11_4_NV:
      case GL_MAP1_VERTEX_ATTRIB12_4_NV:
      case GL_MAP1_VERTEX_ATTRIB13_4_NV:
      case GL_MAP1_VERTEX_ATTRIB14_4_NV:
      case GL_MAP1_VERTEX_ATTRIB15_4_NV:
         CHECK_EXTENSION(NV_vertex_program, cap);
         {
            const GLuint map = (GLuint) (cap - GL_MAP1_VERTEX_ATTRIB0_4_NV);
            FLUSH_VERTICES(ctx, _NEW_EVAL);
            ctx->Eval.Map1Attrib[map] = state;
         }
         break;
      case GL_MAP2_VERTEX_ATTRIB0_4_NV:
      case GL_MAP2_VERTEX_ATTRIB1_4_NV:
      case GL_MAP2_VERTEX_ATTRIB2_4_NV:
      case GL_MAP2_VERTEX_ATTRIB3_4_NV:
      case GL_MAP2_VERTEX_ATTRIB4_4_NV:
      case GL_MAP2_VERTEX_ATTRIB5_4_NV:
      case GL_MAP2_VERTEX_ATTRIB6_4_NV:
      case GL_MAP2_VERTEX_ATTRIB7_4_NV:
      case GL_MAP2_VERTEX_ATTRIB8_4_NV:
      case GL_MAP2_VERTEX_ATTRIB9_4_NV:
      case GL_MAP2_VERTEX_ATTRIB10_4_NV:
      case GL_MAP2_VERTEX_ATTRIB11_4_NV:
      case GL_MAP2_VERTEX_ATTRIB12_4_NV:
      case GL_MAP2_VERTEX_ATTRIB13_4_NV:
      case GL_MAP2_VERTEX_ATTRIB14_4_NV:
      case GL_MAP2_VERTEX_ATTRIB15_4_NV:
         CHECK_EXTENSION(NV_vertex_program, cap);
         {
            const GLuint map = (GLuint) (cap - GL_MAP2_VERTEX_ATTRIB0_4_NV);
            FLUSH_VERTICES(ctx, _NEW_EVAL);
            ctx->Eval.Map2Attrib[map] = state;
         }
         break;
#endif /* FEATURE_NV_vertex_program */

#if FEATURE_NV_fragment_program
      case GL_FRAGMENT_PROGRAM_NV:
         CHECK_EXTENSION(NV_fragment_program, cap);
         if (ctx->FragmentProgram.Enabled == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_PROGRAM);
         ctx->FragmentProgram.Enabled = state;
         break;
#endif /* FEATURE_NV_fragment_program */
d854 2
d864 2
a872 1
            ctx->_TriangleCaps |= DD_TRI_TWOSTENCIL;
a874 1
            ctx->_TriangleCaps &= ~DD_TRI_TWOSTENCIL;
a877 1
#if FEATURE_ARB_fragment_program
d879 2
a886 1
#endif /* FEATURE_ARB_fragment_program */
d890 2
d900 3
a904 1
	 CHECK_EXTENSION(ARB_depth_clamp, cap);
a908 1
#if FEATURE_ATI_fragment_shader
d910 2
a917 1
#endif
d921 2
d930 2
d939 2
a947 1
#if FEATURE_EXT_transform_feedback
d949 2
d952 4
a955 3
         if (ctx->TransformFeedback.RasterDiscard != state) {
            FLUSH_VERTICES(ctx, _NEW_TRANSFORM);
            ctx->TransformFeedback.RasterDiscard = state;
a957 1
#endif
d963 1
a963 1
         if (ctx->VersionMajor * 10 + ctx->VersionMinor < 31) {
d969 11
d985 2
d988 22
a1009 2
         FLUSH_VERTICES(ctx, _NEW_BUFFERS);
         ctx->Color.sRGBEnabled = state;
d1023 2
a1024 2
   _mesa_error(ctx, GL_INVALID_ENUM, "gl%s(0x%x)",
               state ? "Enable" : "Disable", cap);
a1035 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
a1048 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d1094 1
a1094 1
_mesa_DisableIndexed( GLenum cap, GLuint index )
a1096 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d1102 1
a1102 1
_mesa_EnableIndexed( GLenum cap, GLuint index )
a1104 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d1110 1
a1110 1
_mesa_IsEnabledIndexed( GLenum cap, GLuint index )
d1174 2
d1178 2
d1183 15
a1197 7
      case GL_CLIP_PLANE0:
      case GL_CLIP_PLANE1:
      case GL_CLIP_PLANE2:
      case GL_CLIP_PLANE3:
      case GL_CLIP_PLANE4:
      case GL_CLIP_PLANE5:
	 return (ctx->Transform.ClipPlanesEnabled >> (cap - GL_CLIP_PLANE0)) & 1;
d1199 2
d1204 4
d1213 2
d1217 2
d1228 2
d1232 2
d1236 2
d1240 2
d1244 2
d1248 2
d1252 2
d1256 2
d1260 2
d1264 2
d1268 2
d1272 2
d1276 2
d1280 2
d1284 2
d1288 2
d1292 2
d1296 2
d1300 2
d1304 2
d1308 2
d1312 2
d1316 2
d1320 2
d1324 2
d1328 2
d1332 2
d1336 2
d1340 2
a1343 1
      /*case GL_POLYGON_OFFSET_EXT:*/
d1346 2
a1350 2
      case GL_SHARED_TEXTURE_PALETTE_EXT:
         return ctx->Texture.SharedPalette;
d1354 2
d1358 2
d1362 2
d1371 4
a1380 1
#if FEATURE_ES1
d1384 4
a1392 1
#endif
d1394 1
a1394 3
      /*
       * CLIENT STATE!!!
       */
d1396 3
a1398 1
         return (ctx->Array.ArrayObj->Vertex.Enabled != 0);
d1400 3
a1402 1
         return (ctx->Array.ArrayObj->Normal.Enabled != 0);
d1404 3
a1406 1
         return (ctx->Array.ArrayObj->Color.Enabled != 0);
d1408 4
a1411 1
         return (ctx->Array.ArrayObj->Index.Enabled != 0);
d1413 4
a1416 2
         return (ctx->Array.ArrayObj->TexCoord[ctx->Array.ActiveTexture]
                 .Enabled != 0);
d1418 3
a1420 1
         return (ctx->Array.ArrayObj->EdgeFlag.Enabled != 0);
d1422 3
a1424 2
         CHECK_EXTENSION(EXT_fog_coord);
         return (ctx->Array.ArrayObj->FogCoord.Enabled != 0);
d1426 3
a1428 3
         CHECK_EXTENSION(EXT_secondary_color);
         return (ctx->Array.ArrayObj->SecondaryColor.Enabled != 0);
#if FEATURE_point_size_array
d1430 3
a1432 2
         return (ctx->Array.ArrayObj->PointSize.Enabled != 0);
#endif
d1441 3
a1443 1
         CHECK_EXTENSION2(EXT_secondary_color, ARB_vertex_program);
d1448 2
d1454 2
d1460 2
d1466 2
a1467 1
         CHECK_EXTENSION(IBM_rasterpos_clip);
d1472 2
a1476 1
#if FEATURE_NV_vertex_program || FEATURE_ARB_vertex_program
d1478 3
a1480 1
         CHECK_EXTENSION2(ARB_vertex_program, NV_vertex_program);
d1483 6
a1488 1
         CHECK_EXTENSION2(ARB_vertex_program, NV_vertex_program);
d1491 3
a1493 1
         CHECK_EXTENSION2(ARB_vertex_program, NV_vertex_program);
a1494 73
#endif
#if FEATURE_NV_vertex_program
      case GL_VERTEX_ATTRIB_ARRAY0_NV:
      case GL_VERTEX_ATTRIB_ARRAY1_NV:
      case GL_VERTEX_ATTRIB_ARRAY2_NV:
      case GL_VERTEX_ATTRIB_ARRAY3_NV:
      case GL_VERTEX_ATTRIB_ARRAY4_NV:
      case GL_VERTEX_ATTRIB_ARRAY5_NV:
      case GL_VERTEX_ATTRIB_ARRAY6_NV:
      case GL_VERTEX_ATTRIB_ARRAY7_NV:
      case GL_VERTEX_ATTRIB_ARRAY8_NV:
      case GL_VERTEX_ATTRIB_ARRAY9_NV:
      case GL_VERTEX_ATTRIB_ARRAY10_NV:
      case GL_VERTEX_ATTRIB_ARRAY11_NV:
      case GL_VERTEX_ATTRIB_ARRAY12_NV:
      case GL_VERTEX_ATTRIB_ARRAY13_NV:
      case GL_VERTEX_ATTRIB_ARRAY14_NV:
      case GL_VERTEX_ATTRIB_ARRAY15_NV:
         CHECK_EXTENSION(NV_vertex_program);
         {
            GLint n = (GLint) cap - GL_VERTEX_ATTRIB_ARRAY0_NV;
            ASSERT(n < Elements(ctx->Array.ArrayObj->VertexAttrib));
            return (ctx->Array.ArrayObj->VertexAttrib[n].Enabled != 0);
         }
      case GL_MAP1_VERTEX_ATTRIB0_4_NV:
      case GL_MAP1_VERTEX_ATTRIB1_4_NV:
      case GL_MAP1_VERTEX_ATTRIB2_4_NV:
      case GL_MAP1_VERTEX_ATTRIB3_4_NV:
      case GL_MAP1_VERTEX_ATTRIB4_4_NV:
      case GL_MAP1_VERTEX_ATTRIB5_4_NV:
      case GL_MAP1_VERTEX_ATTRIB6_4_NV:
      case GL_MAP1_VERTEX_ATTRIB7_4_NV:
      case GL_MAP1_VERTEX_ATTRIB8_4_NV:
      case GL_MAP1_VERTEX_ATTRIB9_4_NV:
      case GL_MAP1_VERTEX_ATTRIB10_4_NV:
      case GL_MAP1_VERTEX_ATTRIB11_4_NV:
      case GL_MAP1_VERTEX_ATTRIB12_4_NV:
      case GL_MAP1_VERTEX_ATTRIB13_4_NV:
      case GL_MAP1_VERTEX_ATTRIB14_4_NV:
      case GL_MAP1_VERTEX_ATTRIB15_4_NV:
         CHECK_EXTENSION(NV_vertex_program);
         {
            const GLuint map = (GLuint) (cap - GL_MAP1_VERTEX_ATTRIB0_4_NV);
            return ctx->Eval.Map1Attrib[map];
         }
      case GL_MAP2_VERTEX_ATTRIB0_4_NV:
      case GL_MAP2_VERTEX_ATTRIB1_4_NV:
      case GL_MAP2_VERTEX_ATTRIB2_4_NV:
      case GL_MAP2_VERTEX_ATTRIB3_4_NV:
      case GL_MAP2_VERTEX_ATTRIB4_4_NV:
      case GL_MAP2_VERTEX_ATTRIB5_4_NV:
      case GL_MAP2_VERTEX_ATTRIB6_4_NV:
      case GL_MAP2_VERTEX_ATTRIB7_4_NV:
      case GL_MAP2_VERTEX_ATTRIB8_4_NV:
      case GL_MAP2_VERTEX_ATTRIB9_4_NV:
      case GL_MAP2_VERTEX_ATTRIB10_4_NV:
      case GL_MAP2_VERTEX_ATTRIB11_4_NV:
      case GL_MAP2_VERTEX_ATTRIB12_4_NV:
      case GL_MAP2_VERTEX_ATTRIB13_4_NV:
      case GL_MAP2_VERTEX_ATTRIB14_4_NV:
      case GL_MAP2_VERTEX_ATTRIB15_4_NV:
         CHECK_EXTENSION(NV_vertex_program);
         {
            const GLuint map = (GLuint) (cap - GL_MAP2_VERTEX_ATTRIB0_4_NV);
            return ctx->Eval.Map2Attrib[map];
         }
#endif /* FEATURE_NV_vertex_program */

#if FEATURE_NV_fragment_program
      case GL_FRAGMENT_PROGRAM_NV:
         CHECK_EXTENSION(NV_fragment_program);
         return ctx->FragmentProgram.Enabled;
#endif /* FEATURE_NV_fragment_program */
d1498 2
d1505 2
a1509 1
#if FEATURE_ARB_fragment_program
d1511 2
a1513 1
#endif /* FEATURE_ARB_fragment_program */
d1517 2
d1524 2
a1528 1
#if FEATURE_ATI_fragment_shader
d1530 2
a1533 1
#endif /* FEATURE_ATI_fragment_shader */
d1536 2
a1540 1
#if FEATURE_EXT_transform_feedback
d1542 2
d1545 1
a1545 2
         return ctx->TransformFeedback.RasterDiscard;
#endif
d1549 1
a1549 1
	 if (!ctx->Extensions.NV_primitive_restart) {
d1556 1
a1556 1
         if (ctx->VersionMajor * 10 + ctx->VersionMinor < 31) {
d1561 6
d1569 2
d1574 14
d1595 2
a1596 1
   _mesa_error(ctx, GL_INVALID_ENUM, "glIsEnabled(0x%x)", (int) cap);
@


1.7
log
@Merge Mesa 7.10.3
@
text
@d32 1
d37 1
d217 2
a218 2
 * Note that we'll set GL_INVALID_OPERATION if the active texture unit is
 * higher than the number of supported coordinate units.  And we'll return NULL.
d290 2
a291 1
            GLbitfield newEnabled = state * ((1 << ctx->Const.MaxDrawBuffers) - 1);
d308 2
a309 1
            if ((ctx->Transform.ClipPlanesEnabled & (1 << p)) == ((GLuint) state << p))
d316 1
a316 11

               if (_math_matrix_is_dirty(ctx->ProjectionMatrixStack.Top))
                  _math_matrix_analyse( ctx->ProjectionMatrixStack.Top );

               /* This derived state also calculated in clip.c and
                * from _mesa_update_state() on changes to EyeUserPlane
                * and ctx->ProjectionMatrix respectively.
                */
               _mesa_transform_vector( ctx->Transform._ClipUserPlane[p],
                                    ctx->Transform.EyeUserPlane[p],
                                    ctx->ProjectionMatrixStack.Top->inv );
a347 3
         if (ctx->NoDither) {
            state = GL_FALSE; /* MESA_NO_DITHER env var */
         }
a607 28
      case GL_TEXTURE_GEN_Q:
         {
            struct gl_texture_unit *texUnit = get_texcoord_unit(ctx);
            if (texUnit) {
               GLuint newenabled = texUnit->TexGenEnabled & ~Q_BIT;
               if (state)
                  newenabled |= Q_BIT;
               if (texUnit->TexGenEnabled == newenabled)
                  return;
               FLUSH_VERTICES(ctx, _NEW_TEXTURE);
               texUnit->TexGenEnabled = newenabled;
            }
         }
         break;
      case GL_TEXTURE_GEN_R:
         {
            struct gl_texture_unit *texUnit = get_texcoord_unit(ctx);
            if (texUnit) {
               GLuint newenabled = texUnit->TexGenEnabled & ~R_BIT;
               if (state)
                  newenabled |= R_BIT;
               if (texUnit->TexGenEnabled == newenabled)
                  return;
               FLUSH_VERTICES(ctx, _NEW_TEXTURE);
               texUnit->TexGenEnabled = newenabled;
            }
         }
         break;
a608 13
         {
            struct gl_texture_unit *texUnit = get_texcoord_unit(ctx);
            if (texUnit) {
               GLuint newenabled = texUnit->TexGenEnabled & ~S_BIT;
               if (state)
                  newenabled |= S_BIT;
               if (texUnit->TexGenEnabled == newenabled)
                  return;
               FLUSH_VERTICES(ctx, _NEW_TEXTURE);
               texUnit->TexGenEnabled = newenabled;
            }
         }
         break;
d610 2
d615 2
a616 1
               GLuint newenabled = texUnit->TexGenEnabled & ~T_BIT;
d618 1
a618 1
                  newenabled |= T_BIT;
a660 9
      /* GL_SGI_texture_color_table */
      case GL_TEXTURE_COLOR_TABLE_SGI:
         CHECK_EXTENSION(SGI_texture_color_table, cap);
         if (ctx->Texture.Unit[ctx->Texture.CurrentUnit].ColorTableEnabled == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_TEXTURE);
         ctx->Texture.Unit[ctx->Texture.CurrentUnit].ColorTableEnabled = state;
         break;

d888 4
a891 1
	 ctx->Texture.CubeMapSeamless = state;
d898 1
a899 1
            FLUSH_VERTICES(ctx, _NEW_TRANSFORM);
d917 7
d973 2
a974 1
_mesa_set_enablei(struct gl_context *ctx, GLenum cap, GLuint index, GLboolean state)
d1029 1
d1086 2
a1195 16
      case GL_TEXTURE_GEN_Q:
         {
            const struct gl_texture_unit *texUnit = get_texcoord_unit(ctx);
            if (texUnit) {
               return (texUnit->TexGenEnabled & Q_BIT) ? GL_TRUE : GL_FALSE;
            }
         }
         return GL_FALSE;
      case GL_TEXTURE_GEN_R:
         {
            const struct gl_texture_unit *texUnit = get_texcoord_unit(ctx);
            if (texUnit) {
               return (texUnit->TexGenEnabled & R_BIT) ? GL_TRUE : GL_FALSE;
            }
         }
         return GL_FALSE;
a1196 7
         {
            const struct gl_texture_unit *texUnit = get_texcoord_unit(ctx);
            if (texUnit) {
               return (texUnit->TexGenEnabled & S_BIT) ? GL_TRUE : GL_FALSE;
            }
         }
         return GL_FALSE;
d1198 2
d1203 2
a1204 1
               return (texUnit->TexGenEnabled & T_BIT) ? GL_TRUE : GL_FALSE;
d1213 2
a1214 1
		    return (texUnit->TexGenEnabled & STR_BITS) == STR_BITS ? GL_TRUE : GL_FALSE;
d1231 2
a1232 1
         return (ctx->Array.ArrayObj->TexCoord[ctx->Array.ActiveTexture].Enabled != 0);
a1245 5
      /* GL_SGI_texture_color_table */
      case GL_TEXTURE_COLOR_TABLE_SGI:
         CHECK_EXTENSION(SGI_texture_color_table);
         return ctx->Texture.Unit[ctx->Texture.CurrentUnit].ColorTableEnabled;

d1416 5
@


1.6
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d45 1
a45 3
      _mesa_error(ctx, GL_INVALID_ENUM, "gl%sClientState(0x%x)",	\
                  state ? "Enable" : "Disable", CAP);			\
      return;								\
d53 1
a53 1
client_state(GLcontext *ctx, GLenum cap, GLboolean state)
d127 9
d137 1
a137 3
         _mesa_error( ctx, GL_INVALID_ENUM,
                      "glEnable/DisableClientState(0x%x)", cap);
         return;
d158 6
d202 1
a202 3
      _mesa_error(ctx, GL_INVALID_ENUM, "gl%s(0x%x)",			\
                  state ? "Enable" : "Disable", CAP);			\
      return;								\
d207 1
a207 3
      _mesa_error(ctx, GL_INVALID_ENUM, "gl%s(0x%x)",			\
                  state ? "Enable" : "Disable", CAP);			\
      return;								\
d219 1
a219 1
get_texcoord_unit(GLcontext *ctx)
d237 1
a237 1
enable_texture(GLcontext *ctx, GLboolean state, GLbitfield texBit)
d265 1
a265 1
_mesa_set_enable(GLcontext *ctx, GLenum cap, GLboolean state)
a346 7
      case GL_CULL_VERTEX_EXT:
         CHECK_EXTENSION(EXT_cull_vertex, cap);
         if (ctx->Transform.CullVertexFlag == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_TRANSFORM);
         ctx->Transform.CullVertexFlag = state;
         break;
a367 7
      case GL_HISTOGRAM:
         CHECK_EXTENSION(EXT_histogram, cap);
         if (ctx->Pixel.HistogramEnabled == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_PIXEL);
         ctx->Pixel.HistogramEnabled = state;
         break;
a531 6
      case GL_MINMAX:
         if (ctx->Pixel.MinMaxEnabled == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_PIXEL);
         ctx->Pixel.MinMaxEnabled = state;
         break;
d674 19
d708 1
a708 22
      /* GL_SGI_color_table */
      case GL_COLOR_TABLE_SGI:
         CHECK_EXTENSION(SGI_color_table, cap);
         if (ctx->Pixel.ColorTableEnabled[COLORTABLE_PRECONVOLUTION] == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_PIXEL);
         ctx->Pixel.ColorTableEnabled[COLORTABLE_PRECONVOLUTION] = state;
         break;
      case GL_POST_CONVOLUTION_COLOR_TABLE_SGI:
         CHECK_EXTENSION(SGI_color_table, cap);
         if (ctx->Pixel.ColorTableEnabled[COLORTABLE_POSTCONVOLUTION] == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_PIXEL);
         ctx->Pixel.ColorTableEnabled[COLORTABLE_POSTCONVOLUTION] = state;
         break;
      case GL_POST_COLOR_MATRIX_COLOR_TABLE_SGI:
         CHECK_EXTENSION(SGI_color_table, cap);
         if (ctx->Pixel.ColorTableEnabled[COLORTABLE_POSTCOLORMATRIX] == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_PIXEL);
         ctx->Pixel.ColorTableEnabled[COLORTABLE_POSTCOLORMATRIX] = state;
         break;
a716 23
      /* GL_EXT_convolution */
      case GL_CONVOLUTION_1D:
         CHECK_EXTENSION(EXT_convolution, cap);
         if (ctx->Pixel.Convolution1DEnabled == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_PIXEL);
         ctx->Pixel.Convolution1DEnabled = state;
         break;
      case GL_CONVOLUTION_2D:
         CHECK_EXTENSION(EXT_convolution, cap);
         if (ctx->Pixel.Convolution2DEnabled == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_PIXEL);
         ctx->Pixel.Convolution2DEnabled = state;
         break;
      case GL_SEPARABLE_2D:
         CHECK_EXTENSION(EXT_convolution, cap);
         if (ctx->Pixel.Separable2DEnabled == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_PIXEL);
         ctx->Pixel.Separable2DEnabled = state;
         break;

d947 23
d971 1
a971 3
         _mesa_error(ctx, GL_INVALID_ENUM,
                     "%s(0x%x)", state ? "glEnable" : "glDisable", cap);
         return;
d977 6
d1019 1
a1019 1
_mesa_set_enablei(GLcontext *ctx, GLenum cap, GLuint index, GLboolean state)
d1025 1
a1025 1
         goto bad_cap_error;
d1041 1
a1041 1
      goto bad_cap_error;
d1045 1
a1045 1
bad_cap_error:
d1095 1
a1095 2
      _mesa_error(ctx, GL_INVALID_ENUM, "glIsEnabled");	\
      return GL_FALSE;					\
d1101 1
a1101 2
      _mesa_error(ctx, GL_INVALID_ENUM, "glIsEnabled");		\
      return GL_FALSE;						\
d1109 1
a1109 1
is_texture_enabled(GLcontext *ctx, GLbitfield bit)
d1270 9
a1305 19
      /* GL_EXT_histogram */
      case GL_HISTOGRAM:
         CHECK_EXTENSION(EXT_histogram);
         return ctx->Pixel.HistogramEnabled;
      case GL_MINMAX:
         CHECK_EXTENSION(EXT_histogram);
         return ctx->Pixel.MinMaxEnabled;

      /* GL_SGI_color_table */
      case GL_COLOR_TABLE_SGI:
         CHECK_EXTENSION(SGI_color_table);
         return ctx->Pixel.ColorTableEnabled[COLORTABLE_PRECONVOLUTION];
      case GL_POST_CONVOLUTION_COLOR_TABLE_SGI:
         CHECK_EXTENSION(SGI_color_table);
         return ctx->Pixel.ColorTableEnabled[COLORTABLE_POSTCONVOLUTION];
      case GL_POST_COLOR_MATRIX_COLOR_TABLE_SGI:
         CHECK_EXTENSION(SGI_color_table);
         return ctx->Pixel.ColorTableEnabled[COLORTABLE_POSTCOLORMATRIX];

a1310 11
      /* GL_EXT_convolution */
      case GL_CONVOLUTION_1D:
         CHECK_EXTENSION(EXT_convolution);
         return ctx->Pixel.Convolution1DEnabled;
      case GL_CONVOLUTION_2D:
         CHECK_EXTENSION(EXT_convolution);
         return ctx->Pixel.Convolution2DEnabled;
      case GL_SEPARABLE_2D:
         CHECK_EXTENSION(EXT_convolution);
         return ctx->Pixel.Separable2DEnabled;

d1462 20
d1483 1
a1483 2
         _mesa_error(ctx, GL_INVALID_ENUM, "glIsEnabled(0x%x)", (int) cap);
	 return GL_FALSE;
d1485 6
@


1.5
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@a34 1
#include "macros.h"
a37 2
#include "math/m_matrix.h"
#include "math/m_xform.h"
d39 1
d57 1
d63 1
a63 1
         var = &ctx->Array.ArrayObj->Vertex.Enabled;
d67 1
a67 1
         var = &ctx->Array.ArrayObj->Normal.Enabled;
d71 1
a71 1
         var = &ctx->Array.ArrayObj->Color.Enabled;
d75 1
a75 1
         var = &ctx->Array.ArrayObj->Index.Enabled;
d79 1
a79 1
         var = &ctx->Array.ArrayObj->TexCoord[ctx->Array.ActiveTexture].Enabled;
d83 1
a83 1
         var = &ctx->Array.ArrayObj->EdgeFlag.Enabled;
d87 1
a87 1
         var = &ctx->Array.ArrayObj->FogCoord.Enabled;
d91 1
a91 1
         var = &ctx->Array.ArrayObj->SecondaryColor.Enabled;
d97 1
a97 1
         var = &ctx->Array.ArrayObj->PointSize.Enabled;
d122 2
a123 1
            var = &ctx->Array.ArrayObj->VertexAttrib[n].Enabled;
d226 2
d230 1
a230 1
enable_texture(GLcontext *ctx, GLboolean state, GLbitfield bit)
d232 3
a234 4
   const GLuint curr = ctx->Texture.CurrentUnit;
   struct gl_texture_unit *texUnit = &ctx->Texture.Unit[curr];
   const GLuint newenabled = (!state)
       ? (texUnit->Enabled & ~bit) :  (texUnit->Enabled | bit);
d236 1
a236 1
   if (!ctx->DrawBuffer->Visual.rgbMode || texUnit->Enabled == newenabled)
d280 7
a286 4
         if (ctx->Color.BlendEnabled == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_COLOR);
         ctx->Color.BlendEnabled = state;
a609 5
         if (state && ctx->DrawBuffer->Visual.stencilBits == 0) {
            _mesa_warning(ctx,
                          "glEnable(GL_STENCIL_TEST) but no stencil buffer");
            return;
         }
a773 1
         CHECK_EXTENSION(ARB_multisample, cap);
a779 1
         CHECK_EXTENSION(ARB_multisample, cap);
a785 1
         CHECK_EXTENSION(ARB_multisample, cap);
a791 1
         CHECK_EXTENSION(ARB_multisample, cap);
a797 1
         CHECK_EXTENSION(ARB_multisample, cap);
a940 5
         if (state && ctx->DrawBuffer->Visual.depthBits == 0) {
            _mesa_warning(ctx,
                   "glEnable(GL_DEPTH_BOUNDS_TEST_EXT) but no depth buffer");
            return;
         }
d947 7
a953 9
      /* GL_MESA_program_debug */
      case GL_FRAGMENT_PROGRAM_CALLBACK_MESA:
         CHECK_EXTENSION(MESA_program_debug, cap);
         ctx->FragmentProgram.CallbackEnabled = state;
         break;
      case GL_VERTEX_PROGRAM_CALLBACK_MESA:
         CHECK_EXTENSION(MESA_program_debug, cap);
         ctx->VertexProgram.CallbackEnabled = state;
         break;
d980 5
d1025 78
d1149 1
a1149 1
         return ctx->Color.BlendEnabled;
a1356 1
         CHECK_EXTENSION(ARB_multisample);
a1358 1
         CHECK_EXTENSION(ARB_multisample);
a1360 1
         CHECK_EXTENSION(ARB_multisample);
a1362 1
         CHECK_EXTENSION(ARB_multisample);
a1364 1
         CHECK_EXTENSION(ARB_multisample);
d1408 1
d1481 5
a1485 7
      /* GL_MESA_program_debug */
      case GL_FRAGMENT_PROGRAM_CALLBACK_MESA:
         CHECK_EXTENSION(MESA_program_debug);
         return ctx->FragmentProgram.CallbackEnabled;
      case GL_VERTEX_PROGRAM_CALLBACK_MESA:
         CHECK_EXTENSION(MESA_program_debug);
         return ctx->VertexProgram.CallbackEnabled;
d1491 5
@


1.4
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d96 7
d204 20
a343 4
         if (state && ctx->DrawBuffer->Visual.depthBits == 0) {
            _mesa_warning(ctx,"glEnable(GL_DEPTH_TEST) but no depth buffer");
            return;
         }
d631 13
a643 10
      case GL_TEXTURE_GEN_Q: {
         GLuint unit = ctx->Texture.CurrentUnit;
         struct gl_texture_unit *texUnit = &ctx->Texture.Unit[unit];
         GLuint newenabled = texUnit->TexGenEnabled & ~Q_BIT;
         if (state)
            newenabled |= Q_BIT;
         if (texUnit->TexGenEnabled == newenabled)
            return;
         FLUSH_VERTICES(ctx, _NEW_TEXTURE);
         texUnit->TexGenEnabled = newenabled;
d645 13
a657 11
      }
      case GL_TEXTURE_GEN_R: {
         GLuint unit = ctx->Texture.CurrentUnit;
         struct gl_texture_unit *texUnit = &ctx->Texture.Unit[unit];
         GLuint newenabled = texUnit->TexGenEnabled & ~R_BIT;
         if (state)
            newenabled |= R_BIT;
         if (texUnit->TexGenEnabled == newenabled)
            return;
         FLUSH_VERTICES(ctx, _NEW_TEXTURE);
         texUnit->TexGenEnabled = newenabled;
d659 13
a671 11
      }
      case GL_TEXTURE_GEN_S: {
         GLuint unit = ctx->Texture.CurrentUnit;
         struct gl_texture_unit *texUnit = &ctx->Texture.Unit[unit];
         GLuint newenabled = texUnit->TexGenEnabled & ~S_BIT;
         if (state)
            newenabled |= S_BIT;
         if (texUnit->TexGenEnabled == newenabled)
            return;
         FLUSH_VERTICES(ctx, _NEW_TEXTURE);
         texUnit->TexGenEnabled = newenabled;
d673 13
a685 11
      }
      case GL_TEXTURE_GEN_T: {
         GLuint unit = ctx->Texture.CurrentUnit;
         struct gl_texture_unit *texUnit = &ctx->Texture.Unit[unit];
         GLuint newenabled = texUnit->TexGenEnabled & ~T_BIT;
         if (state)
            newenabled |= T_BIT;
         if (texUnit->TexGenEnabled == newenabled)
            return;
         FLUSH_VERTICES(ctx, _NEW_TEXTURE);
         texUnit->TexGenEnabled = newenabled;
a686 1
      }
d699 1
d925 2
a926 1
         if (state)
d928 2
a929 1
         else
d931 1
d1183 4
a1186 3
            const struct gl_texture_unit *texUnit;
            texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
            return (texUnit->TexGenEnabled & Q_BIT) ? GL_TRUE : GL_FALSE;
d1188 1
d1191 4
a1194 3
            const struct gl_texture_unit *texUnit;
            texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
            return (texUnit->TexGenEnabled & R_BIT) ? GL_TRUE : GL_FALSE;
d1196 1
d1199 4
a1202 3
            const struct gl_texture_unit *texUnit;
            texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
            return (texUnit->TexGenEnabled & S_BIT) ? GL_TRUE : GL_FALSE;
d1204 1
d1207 4
a1210 3
            const struct gl_texture_unit *texUnit;
            texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
            return (texUnit->TexGenEnabled & T_BIT) ? GL_TRUE : GL_FALSE;
d1212 1
d1235 4
@


1.3
log
@Update to Mesa 7.0.3. tested my oga@@ and johan@@
@
text
@d41 1
d133 3
d942 16
@


1.2
log
@Update to Mesa 7.0.2. Tested by naddy@@ (full ports build), simon@@
and oga@@ (with dri enabled).
@
text
@d8 1
a8 1
 * Version:  6.5.1
d10 1
a10 1
 * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
d367 2
a372 2
         FLUSH_VERTICES(ctx, _NEW_LIGHT);
         ctx->Light.Enabled = state;
@


1.1
log
@Initial revision
@
text
@d52 3
d56 1
a56 1
client_state( GLcontext *ctx, GLenum cap, GLboolean state )
d59 1
a59 1
   GLuint *var;
d140 1
a140 1
      (*ctx->Driver.Enable)( ctx, cap, state );
d147 1
a147 4
 *
 * \param cap capability.
 *
 * \sa glEnable().
d163 1
a163 4
 *
 * \param cap capability.
 *
 * \sa glDisable().
d193 19
d214 1
a214 1
 * Perform glEnable() and glDisable() calls.
d217 1
a217 1
 * \param cap capability.
d225 2
a226 1
void _mesa_set_enable( GLcontext *ctx, GLenum cap, GLboolean state )
a304 1

a311 1

d317 1
a317 1
         if (ctx->Depth.Test==state)
d326 1
a326 1
         if (ctx->Color.DitherFlag==state)
d332 1
a332 1
         if (ctx->Fog.Enabled==state)
d367 4
a372 6

         if (ctx->Light.Enabled && ctx->Light.Model.TwoSide)
   	   ctx->_TriangleCaps |= DD_TRI_LIGHT_TWOSIDE;
         else
 	   ctx->_TriangleCaps &= ~DD_TRI_LIGHT_TWOSIDE;
 
d521 1
a521 1
         if (ctx->Point.SmoothFlag==state)
d528 1
a528 1
         if (ctx->Polygon.SmoothFlag==state)
d535 1
a535 1
         if (ctx->Polygon.StippleFlag==state)
d542 1
a542 1
         if (ctx->Polygon.OffsetPoint==state)
d548 1
a548 1
         if (ctx->Polygon.OffsetLine==state)
d555 1
a555 1
         if (ctx->Polygon.OffsetFill==state)
d567 1
a567 1
         if (ctx->Scissor.Enabled==state)
d584 1
a584 1
         if (ctx->Stencil.Enabled==state)
d589 2
a590 8
      case GL_TEXTURE_1D: {
         const GLuint curr = ctx->Texture.CurrentUnit;
         struct gl_texture_unit *texUnit = &ctx->Texture.Unit[curr];
         GLuint newenabled = texUnit->Enabled & ~TEXTURE_1D_BIT;
         if (state)
            newenabled |= TEXTURE_1D_BIT;
         if (!ctx->DrawBuffer->Visual.rgbMode
             || texUnit->Enabled == newenabled)
d592 1
a592 2
         FLUSH_VERTICES(ctx, _NEW_TEXTURE);
         texUnit->Enabled = newenabled;
d594 2
a595 9
      }
      case GL_TEXTURE_2D: {
         const GLuint curr = ctx->Texture.CurrentUnit;
         struct gl_texture_unit *texUnit = &ctx->Texture.Unit[curr];
         GLuint newenabled = texUnit->Enabled & ~TEXTURE_2D_BIT;
         if (state)
            newenabled |= TEXTURE_2D_BIT;
         if (!ctx->DrawBuffer->Visual.rgbMode
             || texUnit->Enabled == newenabled)
d597 1
a597 2
         FLUSH_VERTICES(ctx, _NEW_TEXTURE);
         texUnit->Enabled = newenabled;
d599 2
a600 9
      }
      case GL_TEXTURE_3D: {
         const GLuint curr = ctx->Texture.CurrentUnit;
         struct gl_texture_unit *texUnit = &ctx->Texture.Unit[curr];
         GLuint newenabled = texUnit->Enabled & ~TEXTURE_3D_BIT;
         if (state)
            newenabled |= TEXTURE_3D_BIT;
         if (!ctx->DrawBuffer->Visual.rgbMode
             || texUnit->Enabled == newenabled)
d602 1
a602 2
         FLUSH_VERTICES(ctx, _NEW_TEXTURE);
         texUnit->Enabled = newenabled;
a603 1
      }
d670 1
a670 1
         if (ctx->Pixel.ColorTableEnabled == state)
d673 1
a673 1
         ctx->Pixel.ColorTableEnabled = state;
d677 1
a677 1
         if (ctx->Pixel.PostConvolutionColorTableEnabled == state)
d680 1
a680 1
         ctx->Pixel.PostConvolutionColorTableEnabled = state;
d684 1
a684 1
         if (ctx->Pixel.PostColorMatrixColorTableEnabled == state)
d687 1
a687 1
         ctx->Pixel.PostColorMatrixColorTableEnabled = state;
d722 3
a724 12
         {
            const GLuint curr = ctx->Texture.CurrentUnit;
            struct gl_texture_unit *texUnit = &ctx->Texture.Unit[curr];
            GLuint newenabled = texUnit->Enabled & ~TEXTURE_CUBE_BIT;
            CHECK_EXTENSION(ARB_texture_cube_map, cap);
            if (state)
               newenabled |= TEXTURE_CUBE_BIT;
            if (!ctx->DrawBuffer->Visual.rgbMode
                || texUnit->Enabled == newenabled)
               return;
            FLUSH_VERTICES(ctx, _NEW_TEXTURE);
            texUnit->Enabled = newenabled;
d877 2
a878 12
         {
            const GLuint curr = ctx->Texture.CurrentUnit;
            struct gl_texture_unit *texUnit = &ctx->Texture.Unit[curr];
            GLuint newenabled = texUnit->Enabled & ~TEXTURE_RECT_BIT;
            CHECK_EXTENSION(NV_texture_rectangle, cap);
            if (state)
               newenabled |= TEXTURE_RECT_BIT;
            if (!ctx->DrawBuffer->Visual.rgbMode
                || texUnit->Enabled == newenabled)
               return;
            FLUSH_VERTICES(ctx, _NEW_TEXTURE);
            texUnit->Enabled = newenabled;
d889 1
a889 1
         if (state) {
d891 1
a891 1
         } else {
a892 1
         }
d945 1
a945 1
      (*ctx->Driver.Enable)( ctx, cap, state );
d951 2
a952 8
 * Enable GL capability.
 *
 * \param cap capability.
 *
 * \sa glEnable().
 *
 * Get's the current context, assures that we're outside glBegin()/glEnd() and
 * calls _mesa_set_enable().
d965 2
a966 8
 * Disable GL capability.
 *
 * \param cap capability.
 *
 * \sa glDisable().
 *
 * Get's the current context, assures that we're outside glBegin()/glEnd() and
 * calls _mesa_set_enable().
d992 13
d1006 1
a1006 1
 * Test whether a capability is enabled.
d1008 1
a1008 1
 * \param cap capability.
d1121 1
a1121 5
         {
            const struct gl_texture_unit *texUnit;
            texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
            return (texUnit->Enabled & TEXTURE_1D_BIT) ? GL_TRUE : GL_FALSE;
         }
d1123 1
a1123 5
         {
            const struct gl_texture_unit *texUnit;
            texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
            return (texUnit->Enabled & TEXTURE_2D_BIT) ? GL_TRUE : GL_FALSE;
         }
d1125 1
a1125 5
         {
            const struct gl_texture_unit *texUnit;
            texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
            return (texUnit->Enabled & TEXTURE_3D_BIT) ? GL_TRUE : GL_FALSE;
         }
d1184 1
a1184 1
         return ctx->Pixel.ColorTableEnabled;
d1187 1
a1187 1
         return ctx->Pixel.PostConvolutionColorTableEnabled;
d1190 1
a1190 1
         return ctx->Pixel.PostColorMatrixColorTableEnabled;
d1211 1
a1211 5
         {
            const struct gl_texture_unit *texUnit;
            texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
            return (texUnit->Enabled & TEXTURE_CUBE_BIT) ? GL_TRUE : GL_FALSE;
         }
d1331 1
a1331 5
         {
            const struct gl_texture_unit *texUnit;
            texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
            return (texUnit->Enabled & TEXTURE_RECT_BIT) ? GL_TRUE : GL_FALSE;
         }
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@Mesa 7.0.1
@
text
@a51 3
/**
 * Helper to enable/disable client-side state.
 */
d53 1
a53 1
client_state(GLcontext *ctx, GLenum cap, GLboolean state)
d56 1
a56 1
   GLboolean *var;
d137 1
a137 1
      ctx->Driver.Enable( ctx, cap, state );
d144 4
a147 1
 * \param cap  state to enable/disable.
d163 4
a166 1
 * \param cap  state to enable/disable.
a195 19
/**
 * Helper function to enable or disable a texture target.
 */
static GLboolean
enable_texture(GLcontext *ctx, GLboolean state, GLbitfield bit)
{
   const GLuint curr = ctx->Texture.CurrentUnit;
   struct gl_texture_unit *texUnit = &ctx->Texture.Unit[curr];
   const GLuint newenabled = (!state)
       ? (texUnit->Enabled & ~bit) :  (texUnit->Enabled | bit);

   if (!ctx->DrawBuffer->Visual.rgbMode || texUnit->Enabled == newenabled)
       return GL_FALSE;

   FLUSH_VERTICES(ctx, _NEW_TEXTURE);
   texUnit->Enabled = newenabled;
   return GL_TRUE;
}

d198 1
a198 1
 * Helper function to enable or disable state.
d201 1
a201 1
 * \param cap  the state to enable/disable
d209 1
a209 2
void
_mesa_set_enable(GLcontext *ctx, GLenum cap, GLboolean state)
d288 1
d296 1
d302 1
a302 1
         if (ctx->Depth.Test == state)
d311 1
a311 1
         if (ctx->Color.DitherFlag == state)
d317 1
a317 1
         if (ctx->Fog.Enabled == state)
d354 6
d366 1
d373 1
d508 1
a508 1
         if (ctx->Point.SmoothFlag == state)
d512 1
d515 1
a515 1
         if (ctx->Polygon.SmoothFlag == state)
d519 1
d522 1
a522 1
         if (ctx->Polygon.StippleFlag == state)
d526 1
d529 1
a529 1
         if (ctx->Polygon.OffsetPoint == state)
d535 1
a535 1
         if (ctx->Polygon.OffsetLine == state)
d542 1
a542 1
         if (ctx->Polygon.OffsetFill == state)
d554 1
a554 1
         if (ctx->Scissor.Enabled == state)
d571 1
a571 1
         if (ctx->Stencil.Enabled == state)
d576 8
a583 2
      case GL_TEXTURE_1D:
         if (!enable_texture(ctx, state, TEXTURE_1D_BIT)) {
d585 2
a586 1
         }
d588 9
a596 2
      case GL_TEXTURE_2D:
         if (!enable_texture(ctx, state, TEXTURE_2D_BIT)) {
d598 2
a599 1
         }
d601 9
a609 2
      case GL_TEXTURE_3D:
         if (!enable_texture(ctx, state, TEXTURE_3D_BIT)) {
d611 2
a612 1
         }
d614 1
d681 1
a681 1
         if (ctx->Pixel.ColorTableEnabled[COLORTABLE_PRECONVOLUTION] == state)
d684 1
a684 1
         ctx->Pixel.ColorTableEnabled[COLORTABLE_PRECONVOLUTION] = state;
d688 1
a688 1
         if (ctx->Pixel.ColorTableEnabled[COLORTABLE_POSTCONVOLUTION] == state)
d691 1
a691 1
         ctx->Pixel.ColorTableEnabled[COLORTABLE_POSTCONVOLUTION] = state;
d695 1
a695 1
         if (ctx->Pixel.ColorTableEnabled[COLORTABLE_POSTCOLORMATRIX] == state)
d698 1
a698 1
         ctx->Pixel.ColorTableEnabled[COLORTABLE_POSTCOLORMATRIX] = state;
d733 12
a744 3
         CHECK_EXTENSION(ARB_texture_cube_map, cap);
         if (!enable_texture(ctx, state, TEXTURE_CUBE_BIT)) {
            return;
d897 12
a908 2
         if (!enable_texture(ctx, state, TEXTURE_RECT_BIT)) {
            return;
d919 5
d976 1
a976 1
      ctx->Driver.Enable( ctx, cap, state );
d982 8
a989 2
 * Enable GL capability.  Called by glEnable()
 * \param cap  state to enable.
d1002 8
a1009 2
 * Disable GL capability.  Called by glDisable()
 * \param cap  state to disable.
a1034 1

d1036 1
a1036 13
 * Helper function to determine whether a texture target is enabled.
 */
static GLboolean
is_texture_enabled(GLcontext *ctx, GLbitfield bit)
{
   const struct gl_texture_unit *const texUnit =
       &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
   return (texUnit->Enabled & bit) ? GL_TRUE : GL_FALSE;
}


/**
 * Return simple enable/disable state.
d1038 1
a1038 1
 * \param cap  state variable to query.
d1151 5
a1155 1
         return is_texture_enabled(ctx, TEXTURE_1D_BIT);
d1157 5
a1161 1
         return is_texture_enabled(ctx, TEXTURE_2D_BIT);
d1163 5
a1167 1
         return is_texture_enabled(ctx, TEXTURE_3D_BIT);
d1226 1
a1226 1
         return ctx->Pixel.ColorTableEnabled[COLORTABLE_PRECONVOLUTION];
d1229 1
a1229 1
         return ctx->Pixel.ColorTableEnabled[COLORTABLE_POSTCONVOLUTION];
d1232 1
a1232 1
         return ctx->Pixel.ColorTableEnabled[COLORTABLE_POSTCOLORMATRIX];
d1253 5
a1257 1
         return is_texture_enabled(ctx, TEXTURE_CUBE_BIT);
d1377 5
a1381 1
         return is_texture_enabled(ctx, TEXTURE_RECT_BIT);
@


1.1.1.3
log
@Import Mesa 7.10.3
@
text
@d8 1
a8 1
 * Version:  7.0.3
d10 1
a10 1
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
d35 1
d39 2
a40 2
#include "api_arrayelt.h"
#include "texstate.h"
d46 3
a48 1
      goto invalid_enum_error;						\
d56 1
a56 1
client_state(struct gl_context *ctx, GLenum cap, GLboolean state)
a57 1
   struct gl_array_object *arrayObj = ctx->Array.ArrayObj;
d63 1
a63 1
         var = &arrayObj->Vertex.Enabled;
d67 1
a67 1
         var = &arrayObj->Normal.Enabled;
d71 1
a71 1
         var = &arrayObj->Color.Enabled;
d75 1
a75 1
         var = &arrayObj->Index.Enabled;
d79 1
a79 1
         var = &arrayObj->TexCoord[ctx->Array.ActiveTexture].Enabled;
d83 1
a83 1
         var = &arrayObj->EdgeFlag.Enabled;
d87 1
a87 1
         var = &arrayObj->FogCoord.Enabled;
d91 1
a91 1
         var = &arrayObj->SecondaryColor.Enabled;
a94 7
#if FEATURE_point_size_array
      case GL_POINT_SIZE_ARRAY_OES:
         var = &arrayObj->PointSize.Enabled;
         flag = _NEW_ARRAY_POINT_SIZE;
         break;
#endif

d115 1
a115 2
            ASSERT(n < Elements(ctx->Array.ArrayObj->VertexAttrib));
            var = &arrayObj->VertexAttrib[n].Enabled;
a120 9
      /* GL_NV_primitive_restart */
      case GL_PRIMITIVE_RESTART_NV:
	 if (!ctx->Extensions.NV_primitive_restart) {
            goto invalid_enum_error;
         }
         var = &ctx->Array.PrimitiveRestart;
         flag = 0;
         break;

d122 3
a124 1
         goto invalid_enum_error;
a131 3

   _ae_invalidate_state(ctx, _NEW_ARRAY);

a141 6

   return;

invalid_enum_error:
   _mesa_error(ctx, GL_INVALID_ENUM, "gl%sClientState(0x%x)",
               state ? "Enable" : "Disable", cap);
d180 3
a182 1
      goto invalid_enum_error;						\
d187 3
a189 1
      goto invalid_enum_error;						\
a192 20

/**
 * Return pointer to current texture unit for setting/getting coordinate
 * state.
 * Note that we'll set GL_INVALID_OPERATION if the active texture unit is
 * higher than the number of supported coordinate units.  And we'll return NULL.
 */
static struct gl_texture_unit *
get_texcoord_unit(struct gl_context *ctx)
{
   if (ctx->Texture.CurrentUnit >= ctx->Const.MaxTextureCoordUnits) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glEnable/Disable(texcoord unit)");
      return NULL;
   }
   else {
      return &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
   }
}


a194 2
 * \param bit  one of the TEXTURE_x_BIT values
 * \return GL_TRUE if state is changing or GL_FALSE if no change
d197 1
a197 1
enable_texture(struct gl_context *ctx, GLboolean state, GLbitfield texBit)
d199 4
a202 3
   struct gl_texture_unit *texUnit = _mesa_get_current_tex_unit(ctx);
   const GLbitfield newenabled = state
      ? (texUnit->Enabled | texBit) : (texUnit->Enabled & ~texBit);
d204 1
a204 1
   if (texUnit->Enabled == newenabled)
d226 1
a226 1
_mesa_set_enable(struct gl_context *ctx, GLenum cap, GLboolean state)
d248 4
a251 7
         {
            GLbitfield newEnabled = state * ((1 << ctx->Const.MaxDrawBuffers) - 1);
            if (newEnabled != ctx->Color.BlendEnabled) {
               FLUSH_VERTICES(ctx, _NEW_COLOR);
               ctx->Color.BlendEnabled = newEnabled;
            }
         }
d305 7
d313 4
d337 7
a368 4
         if (ctx->Light.Enabled && ctx->Light.Model.TwoSide)
            ctx->_TriangleCaps |= DD_TRI_LIGHT_TWOSIDE;
         else
            ctx->_TriangleCaps &= ~DD_TRI_LIGHT_TWOSIDE;
a374 1
         ctx->_TriangleCaps ^= DD_LINE_SMOOTH;
a380 1
         ctx->_TriangleCaps ^= DD_LINE_STIPPLE;
d502 6
a518 1
         ctx->_TriangleCaps ^= DD_POINT_SMOOTH;
a524 1
         ctx->_TriangleCaps ^= DD_TRI_SMOOTH;
a530 1
         ctx->_TriangleCaps ^= DD_TRI_STIPPLE;
d570 5
d595 10
a604 13
      case GL_TEXTURE_GEN_Q:
         {
            struct gl_texture_unit *texUnit = get_texcoord_unit(ctx);
            if (texUnit) {
               GLuint newenabled = texUnit->TexGenEnabled & ~Q_BIT;
               if (state)
                  newenabled |= Q_BIT;
               if (texUnit->TexGenEnabled == newenabled)
                  return;
               FLUSH_VERTICES(ctx, _NEW_TEXTURE);
               texUnit->TexGenEnabled = newenabled;
            }
         }
d606 11
a616 13
      case GL_TEXTURE_GEN_R:
         {
            struct gl_texture_unit *texUnit = get_texcoord_unit(ctx);
            if (texUnit) {
               GLuint newenabled = texUnit->TexGenEnabled & ~R_BIT;
               if (state)
                  newenabled |= R_BIT;
               if (texUnit->TexGenEnabled == newenabled)
                  return;
               FLUSH_VERTICES(ctx, _NEW_TEXTURE);
               texUnit->TexGenEnabled = newenabled;
            }
         }
d618 11
a628 13
      case GL_TEXTURE_GEN_S:
         {
            struct gl_texture_unit *texUnit = get_texcoord_unit(ctx);
            if (texUnit) {
               GLuint newenabled = texUnit->TexGenEnabled & ~S_BIT;
               if (state)
                  newenabled |= S_BIT;
               if (texUnit->TexGenEnabled == newenabled)
                  return;
               FLUSH_VERTICES(ctx, _NEW_TEXTURE);
               texUnit->TexGenEnabled = newenabled;
            }
         }
d630 11
a640 13
      case GL_TEXTURE_GEN_T:
         {
            struct gl_texture_unit *texUnit = get_texcoord_unit(ctx);
            if (texUnit) {
               GLuint newenabled = texUnit->TexGenEnabled & ~T_BIT;
               if (state)
                  newenabled |= T_BIT;
               if (texUnit->TexGenEnabled == newenabled)
                  return;
               FLUSH_VERTICES(ctx, _NEW_TEXTURE);
               texUnit->TexGenEnabled = newenabled;
            }
         }
d642 1
a642 19

#if FEATURE_ES1
      case GL_TEXTURE_GEN_STR_OES:
	 /* disable S, T, and R at the same time */
	 {
            struct gl_texture_unit *texUnit = get_texcoord_unit(ctx);
            if (texUnit) {
               GLuint newenabled =
		  texUnit->TexGenEnabled & ~STR_BITS;
               if (state)
                  newenabled |= STR_BITS;
               if (texUnit->TexGenEnabled == newenabled)
                  return;
               FLUSH_VERTICES(ctx, _NEW_TEXTURE);
               texUnit->TexGenEnabled = newenabled;
            }
         }
         break;
#endif
a654 1
      case GL_POINT_SIZE_ARRAY_OES:
d658 22
a679 1
      /* GL_SGI_texture_color_table */
d688 23
d730 1
d737 1
d744 1
d751 1
d758 1
a879 7
         if (state) {
            ctx->Stencil._BackFace = 2;
            ctx->_TriangleCaps |= DD_TRI_TWOSTENCIL;
         } else {
            ctx->Stencil._BackFace = 1;
            ctx->_TriangleCaps &= ~DD_TRI_TWOSTENCIL;
         }
d895 5
d906 9
a914 7
      case GL_DEPTH_CLAMP:
         if (ctx->Transform.DepthClamp == state)
            return;
	 CHECK_EXTENSION(ARB_depth_clamp, cap);
         FLUSH_VERTICES(ctx, _NEW_TRANSFORM);
	 ctx->Transform.DepthClamp = state;
	 break;
a924 44

      /* GL_MESA_texture_array */
      case GL_TEXTURE_1D_ARRAY_EXT:
         CHECK_EXTENSION(MESA_texture_array, cap);
         if (!enable_texture(ctx, state, TEXTURE_1D_ARRAY_BIT)) {
            return;
         }
         break;

      case GL_TEXTURE_2D_ARRAY_EXT:
         CHECK_EXTENSION(MESA_texture_array, cap);
         if (!enable_texture(ctx, state, TEXTURE_2D_ARRAY_BIT)) {
            return;
         }
         break;

      case GL_TEXTURE_CUBE_MAP_SEAMLESS:
	 CHECK_EXTENSION(ARB_seamless_cube_map, cap);
	 ctx->Texture.CubeMapSeamless = state;
	 break;

#if FEATURE_EXT_transform_feedback
      case GL_RASTERIZER_DISCARD:
	 CHECK_EXTENSION(EXT_transform_feedback, cap);
         if (ctx->TransformFeedback.RasterDiscard != state) {
            ctx->TransformFeedback.RasterDiscard = state;
            FLUSH_VERTICES(ctx, _NEW_TRANSFORM);
         }
         break;
#endif

      /* GL 3.1 primitive restart.  Note: this enum is different from
       * GL_PRIMITIVE_RESTART_NV (which is client state).
       */
      case GL_PRIMITIVE_RESTART:
         if (ctx->VersionMajor * 10 + ctx->VersionMinor < 31) {
            goto invalid_enum_error;
         }
         if (ctx->Array.PrimitiveRestart != state) {
            FLUSH_VERTICES(ctx, _NEW_TRANSFORM);
            ctx->Array.PrimitiveRestart = state;
         }
         break;

d926 3
a928 1
         goto invalid_enum_error;
a933 6

   return;

invalid_enum_error:
   _mesa_error(ctx, GL_INVALID_ENUM, "gl%s(0x%x)",
               state ? "Enable" : "Disable", cap);
a964 78

/**
 * Enable/disable an indexed state var.
 */
void
_mesa_set_enablei(struct gl_context *ctx, GLenum cap, GLuint index, GLboolean state)
{
   ASSERT(state == 0 || state == 1);
   switch (cap) {
   case GL_BLEND:
      if (!ctx->Extensions.EXT_draw_buffers2) {
         goto invalid_enum_error;
      }
      if (index >= ctx->Const.MaxDrawBuffers) {
         _mesa_error(ctx, GL_INVALID_VALUE, "%s(index=%u)",
                     state ? "glEnableIndexed" : "glDisableIndexed", index);
         return;
      }
      if (((ctx->Color.BlendEnabled >> index) & 1) != state) {
         FLUSH_VERTICES(ctx, _NEW_COLOR);
         if (state)
            ctx->Color.BlendEnabled |= (1 << index);
         else
            ctx->Color.BlendEnabled &= ~(1 << index);
      }
      break;
   default:
      goto invalid_enum_error;
   }
   return;

invalid_enum_error:
    _mesa_error(ctx, GL_INVALID_ENUM, "%s(cap=%s)",
                state ? "glEnablei" : "glDisablei",
                _mesa_lookup_enum_by_nr(cap));
}


void GLAPIENTRY
_mesa_DisableIndexed( GLenum cap, GLuint index )
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END(ctx);
   _mesa_set_enablei(ctx, cap, index, GL_FALSE);
}


void GLAPIENTRY
_mesa_EnableIndexed( GLenum cap, GLuint index )
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END(ctx);
   _mesa_set_enablei(ctx, cap, index, GL_TRUE);
}


GLboolean GLAPIENTRY
_mesa_IsEnabledIndexed( GLenum cap, GLuint index )
{
   GET_CURRENT_CONTEXT(ctx);
   switch (cap) {
   case GL_BLEND:
      if (index >= ctx->Const.MaxDrawBuffers) {
         _mesa_error(ctx, GL_INVALID_VALUE, "glIsEnabledIndexed(index=%u)",
                     index);
         return GL_FALSE;
      }
      return (ctx->Color.BlendEnabled >> index) & 1;
   default:
      _mesa_error(ctx, GL_INVALID_ENUM, "glIsEnabledIndexed(cap=%s)",
                  _mesa_lookup_enum_by_nr(cap));
      return GL_FALSE;
   }
}




d968 2
a969 1
      goto invalid_enum_error;				\
d975 2
a976 1
      goto invalid_enum_error;					\
d984 1
a984 1
is_texture_enabled(struct gl_context *ctx, GLbitfield bit)
d1011 1
a1011 1
         return ctx->Color.BlendEnabled & 1;  /* return state for buffer[0] */
d1115 3
a1117 4
            const struct gl_texture_unit *texUnit = get_texcoord_unit(ctx);
            if (texUnit) {
               return (texUnit->TexGenEnabled & Q_BIT) ? GL_TRUE : GL_FALSE;
            }
a1118 1
         return GL_FALSE;
d1121 3
a1123 4
            const struct gl_texture_unit *texUnit = get_texcoord_unit(ctx);
            if (texUnit) {
               return (texUnit->TexGenEnabled & R_BIT) ? GL_TRUE : GL_FALSE;
            }
a1124 1
         return GL_FALSE;
d1127 3
a1129 4
            const struct gl_texture_unit *texUnit = get_texcoord_unit(ctx);
            if (texUnit) {
               return (texUnit->TexGenEnabled & S_BIT) ? GL_TRUE : GL_FALSE;
            }
a1130 1
         return GL_FALSE;
d1133 3
a1135 13
            const struct gl_texture_unit *texUnit = get_texcoord_unit(ctx);
            if (texUnit) {
               return (texUnit->TexGenEnabled & T_BIT) ? GL_TRUE : GL_FALSE;
            }
         }
         return GL_FALSE;
#if FEATURE_ES1
      case GL_TEXTURE_GEN_STR_OES:
	 {
            const struct gl_texture_unit *texUnit = get_texcoord_unit(ctx);
            if (texUnit) {
		    return (texUnit->TexGenEnabled & STR_BITS) == STR_BITS ? GL_TRUE : GL_FALSE;
            }
a1136 1
#endif
d1159 19
a1177 4
#if FEATURE_point_size_array
      case GL_POINT_SIZE_ARRAY_OES:
         return (ctx->Array.ArrayObj->PointSize.Enabled != 0);
#endif
d1184 11
d1207 1
d1210 1
d1213 1
d1216 1
d1219 1
a1262 1
            ASSERT(n < Elements(ctx->Array.ArrayObj->VertexAttrib));
d1335 7
a1341 5
      /* GL_ARB_depth_clamp */
      case GL_DEPTH_CLAMP:
         CHECK_EXTENSION(ARB_depth_clamp);
         return ctx->Transform.DepthClamp;

a1346 25

      case GL_TEXTURE_CUBE_MAP_SEAMLESS:
	 CHECK_EXTENSION(ARB_seamless_cube_map);
	 return ctx->Texture.CubeMapSeamless;

#if FEATURE_EXT_transform_feedback
      case GL_RASTERIZER_DISCARD:
	 CHECK_EXTENSION(EXT_transform_feedback);
         return ctx->TransformFeedback.RasterDiscard;
#endif

      /* GL_NV_primitive_restart */
      case GL_PRIMITIVE_RESTART_NV:
	 if (!ctx->Extensions.NV_primitive_restart) {
            goto invalid_enum_error;
         }
         return ctx->Array.PrimitiveRestart;

      /* GL 3.1 primitive restart */
      case GL_PRIMITIVE_RESTART:
         if (ctx->VersionMajor * 10 + ctx->VersionMinor < 31) {
            goto invalid_enum_error;
         }
         return ctx->Array.PrimitiveRestart;

d1348 2
a1349 1
         goto invalid_enum_error;
a1350 6

   return GL_FALSE;

invalid_enum_error:
   _mesa_error(ctx, GL_INVALID_ENUM, "glIsEnabled(0x%x)", (int) cap);
   return GL_FALSE;
@


1.1.1.4
log
@Import Mesa 9.2.0
@
text
@d8 1
d25 3
a27 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
a31 1
#include "clip.h"
a39 1
#include "drivers/common/meta.h"
a48 9
static void
update_derived_primitive_restart_state(struct gl_context *ctx)
{
   /* Update derived primitive restart state.
    */
   ctx->Array._PrimitiveRestart = ctx->Array.PrimitiveRestart
      || ctx->Array.PrimitiveRestartFixedIndex;
}

d56 1
a56 1
   GLbitfield64 flag;
d61 2
a62 2
         var = &arrayObj->VertexAttrib[VERT_ATTRIB_POS].Enabled;
         flag = VERT_BIT_POS;
d65 2
a66 2
         var = &arrayObj->VertexAttrib[VERT_ATTRIB_NORMAL].Enabled;
         flag = VERT_BIT_NORMAL;
d69 2
a70 2
         var = &arrayObj->VertexAttrib[VERT_ATTRIB_COLOR0].Enabled;
         flag = VERT_BIT_COLOR0;
d73 2
a74 2
         var = &arrayObj->VertexAttrib[VERT_ATTRIB_COLOR_INDEX].Enabled;
         flag = VERT_BIT_COLOR_INDEX;
d77 2
a78 2
         var = &arrayObj->VertexAttrib[VERT_ATTRIB_TEX(ctx->Array.ActiveTexture)].Enabled;
         flag = VERT_BIT_TEX(ctx->Array.ActiveTexture);
d81 2
a82 2
         var = &arrayObj->VertexAttrib[VERT_ATTRIB_EDGEFLAG].Enabled;
         flag = VERT_BIT_EDGEFLAG;
d85 2
a86 2
         var = &arrayObj->VertexAttrib[VERT_ATTRIB_FOG].Enabled;
         flag = VERT_BIT_FOG;
d89 2
a90 2
         var = &arrayObj->VertexAttrib[VERT_ATTRIB_COLOR1].Enabled;
         flag = VERT_BIT_COLOR1;
d93 1
d95 29
a123 2
         var = &arrayObj->VertexAttrib[VERT_ATTRIB_POINT_SIZE].Enabled;
         flag = VERT_BIT_POINT_SIZE;
d125 1
d144 1
a149 2
   update_derived_primitive_restart_state(ctx);

d151 1
a151 1
      arrayObj->_Enabled |= flag;
d153 1
a153 1
      arrayObj->_Enabled &= ~flag;
d162 2
a163 2
   _mesa_error(ctx, GL_INVALID_ENUM, "gl%sClientState(%s)",
               state ? "Enable" : "Disable", _mesa_lookup_enum_by_nr(cap));
d178 1
d194 1
d210 2
d215 2
a216 2
 * Note that we'll set GL_INVALID_OPERATION and return NULL if the active
 * texture unit is higher than the number of supported coordinate units.
a252 34
 * Helper function to enable or disable GL_MULTISAMPLE, skipping the check for
 * whether the API supports it (GLES doesn't).
 */
void
_mesa_set_multisample(struct gl_context *ctx, GLboolean state)
{
   if (ctx->Multisample.Enabled == state)
      return;
   FLUSH_VERTICES(ctx, _NEW_MULTISAMPLE);
   ctx->Multisample.Enabled = state;

   if (ctx->Driver.Enable) {
      ctx->Driver.Enable(ctx, GL_MULTISAMPLE, state);
   }
}

/**
 * Helper function to enable or disable GL_FRAMEBUFFER_SRGB, skipping the
 * check for whether the API supports it (GLES doesn't).
 */
void
_mesa_set_framebuffer_srgb(struct gl_context *ctx, GLboolean state)
{
   if (ctx->Color.sRGBEnabled == state)
      return;
   FLUSH_VERTICES(ctx, _NEW_BUFFERS);
   ctx->Color.sRGBEnabled = state;

   if (ctx->Driver.Enable) {
      ctx->Driver.Enable(ctx, GL_FRAMEBUFFER_SRGB, state);
   }
}

/**
a274 2
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
a280 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
d288 1
a288 2
            GLbitfield newEnabled =
               state * ((1 << ctx->Const.MaxDrawBuffers) - 1);
d295 7
a301 8
      case GL_CLIP_DISTANCE0:
      case GL_CLIP_DISTANCE1:
      case GL_CLIP_DISTANCE2:
      case GL_CLIP_DISTANCE3:
      case GL_CLIP_DISTANCE4:
      case GL_CLIP_DISTANCE5:
      case GL_CLIP_DISTANCE6:
      case GL_CLIP_DISTANCE7:
d303 1
a303 1
            const GLuint p = cap - GL_CLIP_DISTANCE0;
d305 1
a305 5
            if (p >= ctx->Const.MaxClipPlanes)
               goto invalid_enum_error;

            if ((ctx->Transform.ClipPlanesEnabled & (1 << p))
                == ((GLuint) state << p))
d312 11
a322 1
               _mesa_update_clip_plane(ctx, p);
d329 1
a330 2
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
a352 5
      case GL_DEBUG_OUTPUT_SYNCHRONOUS_ARB:
         if (!_mesa_is_desktop_gl(ctx))
            goto invalid_enum_error;
         ctx->Debug.SyncOutput = state;
         break;
d354 3
a362 2
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
a375 2
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
a388 2
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
d393 4
a398 2
         if (!_mesa_is_desktop_gl(ctx) && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
d403 1
a405 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
d410 1
a412 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
a418 2
         if (!_mesa_is_desktop_gl(ctx) && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
a424 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
a430 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
a436 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
a442 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
a448 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
a454 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
a460 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
a466 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
a472 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
a478 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
a484 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
a490 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
a496 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
a502 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
a508 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
a514 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
a520 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
a526 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
a532 2
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
a538 2
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
d543 1
a545 2
         if (!_mesa_is_desktop_gl(ctx))
            goto invalid_enum_error;
d550 1
a552 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
d557 1
a559 2
         if (!_mesa_is_desktop_gl(ctx))
            goto invalid_enum_error;
a565 2
         if (!_mesa_is_desktop_gl(ctx))
            goto invalid_enum_error;
d572 1
a578 2
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
d590 6
a602 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
a607 2
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
a612 2
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
d617 28
d646 13
a659 2
      case GL_TEXTURE_GEN_R:
      case GL_TEXTURE_GEN_Q:
a661 4

            if (ctx->API != API_OPENGL_COMPAT)
               goto invalid_enum_error;

d663 1
a663 2
               GLbitfield coordBit = S_BIT << (cap - GL_TEXTURE_GEN_S);
               GLbitfield newenabled = texUnit->TexGenEnabled & ~coordBit;
d665 1
a665 1
                  newenabled |= coordBit;
d674 1
a678 4

            if (ctx->API != API_OPENGLES)
               goto invalid_enum_error;

d691 1
d693 3
a695 1
      /* client-side state */
d708 9
a718 2
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
d727 1
a727 3
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
         CHECK_EXTENSION(ARB_vertex_program, cap);
d736 5
a740 4
         if (!_mesa_is_desktop_gl(ctx) && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
         _mesa_set_multisample(ctx, state);
         return;
a747 2
         if (!_mesa_is_desktop_gl(ctx) && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
a759 2
         if (!_mesa_is_desktop_gl(ctx))
            goto invalid_enum_error;
d768 1
a768 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
a776 2
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
d784 1
d786 1
a786 3
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
         CHECK_EXTENSION(ARB_vertex_program, cap);
d793 1
a793 6
         /* This was added with ARB_vertex_program, but it is also used with
          * GLSL vertex shaders on desktop.
          */
         if (!_mesa_is_desktop_gl(ctx))
            goto invalid_enum_error;
         CHECK_EXTENSION(ARB_vertex_program, cap);
d800 1
a800 3
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
         CHECK_EXTENSION(ARB_vertex_program, cap);
d806 59
a867 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
a875 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
d883 1
d886 1
d890 1
a891 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
d898 1
a901 2
         if (!_mesa_is_desktop_gl(ctx))
            goto invalid_enum_error;
a909 3
         if (!_mesa_is_desktop_gl(ctx))
            goto invalid_enum_error;
	 CHECK_EXTENSION(ARB_depth_clamp, cap);
d912 1
d917 1
a918 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
d925 1
a928 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
a935 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
a942 2
         if (!_mesa_is_desktop_gl(ctx))
            goto invalid_enum_error;
d944 1
a944 4
	 if (ctx->Texture.CubeMapSeamless != state) {
	    FLUSH_VERTICES(ctx, _NEW_TEXTURE);
	    ctx->Texture.CubeMapSeamless = state;
	 }
d947 1
a948 2
         if (!_mesa_is_desktop_gl(ctx) && !_mesa_is_gles3(ctx))
            goto invalid_enum_error;
d950 3
a952 4
         if (ctx->RasterDiscard != state) {
            FLUSH_VERTICES(ctx, 0);
            ctx->NewDriverState |= ctx->DriverFlags.NewRasterizerDiscard;
            ctx->RasterDiscard = state;
d955 1
d961 1
a961 1
         if (!_mesa_is_desktop_gl(ctx) || ctx->Version < 31) {
a966 1
            update_derived_primitive_restart_state(ctx);
a969 39
      case GL_PRIMITIVE_RESTART_FIXED_INDEX:
	 if (!_mesa_is_gles3(ctx) && !ctx->Extensions.ARB_ES3_compatibility)
            goto invalid_enum_error;
         if (ctx->Array.PrimitiveRestartFixedIndex != state) {
            FLUSH_VERTICES(ctx, _NEW_TRANSFORM);
            ctx->Array.PrimitiveRestartFixedIndex = state;
            update_derived_primitive_restart_state(ctx);
         }
         break;

      /* GL3.0 - GL_framebuffer_sRGB */
      case GL_FRAMEBUFFER_SRGB_EXT:
         if (!_mesa_is_desktop_gl(ctx))
            goto invalid_enum_error;
         CHECK_EXTENSION(EXT_framebuffer_sRGB, cap);
         _mesa_set_framebuffer_srgb(ctx, state);
         return;

      /* GL_OES_EGL_image_external */
      case GL_TEXTURE_EXTERNAL_OES:
         if (!_mesa_is_gles(ctx))
            goto invalid_enum_error;
         CHECK_EXTENSION(OES_EGL_image_external, cap);
         if (!enable_texture(ctx, state, TEXTURE_EXTERNAL_BIT)) {
            return;
         }
         break;

      /* ARB_texture_multisample */
      case GL_SAMPLE_MASK:
         if (!_mesa_is_desktop_gl(ctx))
            goto invalid_enum_error;
         CHECK_EXTENSION(ARB_texture_multisample, cap);
         if (ctx->Multisample.SampleMask == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_MULTISAMPLE);
         ctx->Multisample.SampleMask = state;
         break;

d981 2
a982 2
   _mesa_error(ctx, GL_INVALID_ENUM, "gl%s(%s)",
               state ? "Enable" : "Disable", _mesa_lookup_enum_by_nr(cap));
d994 1
d1008 1
d1019 1
a1019 2
_mesa_set_enablei(struct gl_context *ctx, GLenum cap,
                  GLuint index, GLboolean state)
d1053 1
a1053 1
_mesa_Disablei( GLenum cap, GLuint index )
d1056 1
d1062 1
a1062 1
_mesa_Enablei( GLenum cap, GLuint index )
d1065 1
d1071 1
a1071 1
_mesa_IsEnabledi( GLenum cap, GLuint index )
a1073 1
   ASSERT_OUTSIDE_BEGIN_END_WITH_RETVAL(ctx, 0);
a1129 2
   ASSERT_OUTSIDE_BEGIN_END_WITH_RETVAL(ctx, 0);

a1131 2
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
a1133 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
d1137 7
a1143 15
      case GL_CLIP_DISTANCE0:
      case GL_CLIP_DISTANCE1:
      case GL_CLIP_DISTANCE2:
      case GL_CLIP_DISTANCE3:
      case GL_CLIP_DISTANCE4:
      case GL_CLIP_DISTANCE5:
      case GL_CLIP_DISTANCE6:
      case GL_CLIP_DISTANCE7: {
         const GLuint p = cap - GL_CLIP_DISTANCE0;

         if (p >= ctx->Const.MaxClipPlanes)
            goto invalid_enum_error;

	 return (ctx->Transform.ClipPlanesEnabled >> p) & 1;
      }
a1144 2
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
a1147 4
      case GL_DEBUG_OUTPUT_SYNCHRONOUS_ARB:
         if (!_mesa_is_desktop_gl(ctx))
            goto invalid_enum_error;
         return ctx->Debug.SyncOutput;
a1152 2
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
a1154 2
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
a1163 2
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
a1165 2
         if (!_mesa_is_desktop_gl(ctx) && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
a1167 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
a1169 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
a1171 2
         if (!_mesa_is_desktop_gl(ctx) && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
a1173 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
a1175 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
a1177 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
a1179 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
a1181 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
a1183 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
a1185 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
a1187 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
a1189 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
a1191 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
a1193 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
a1195 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
a1197 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
a1199 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
a1201 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
a1203 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
a1205 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
a1207 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
a1209 2
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
a1211 2
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
a1213 2
         if (!_mesa_is_desktop_gl(ctx))
            goto invalid_enum_error;
a1215 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
a1217 2
         if (!_mesa_is_desktop_gl(ctx))
            goto invalid_enum_error;
a1219 2
         if (!_mesa_is_desktop_gl(ctx))
            goto invalid_enum_error;
d1222 1
a1224 2
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
d1228 2
a1232 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
a1234 2
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
a1236 2
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
d1238 16
d1255 7
a1262 2
      case GL_TEXTURE_GEN_R:
      case GL_TEXTURE_GEN_Q:
a1264 4

            if (ctx->API != API_OPENGL_COMPAT)
               goto invalid_enum_error;

d1266 1
a1266 2
               GLbitfield coordBit = S_BIT << (cap - GL_TEXTURE_GEN_S);
               return (texUnit->TexGenEnabled & coordBit) ? GL_TRUE : GL_FALSE;
d1270 1
a1273 4

            if (ctx->API != API_OPENGLES)
               goto invalid_enum_error;

d1275 1
a1275 2
               return (texUnit->TexGenEnabled & STR_BITS) == STR_BITS
                  ? GL_TRUE : GL_FALSE;
d1278 1
d1280 3
a1282 1
      /* client-side state */
d1284 1
a1284 3
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
         return ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_POS].Enabled;
d1286 1
a1286 3
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
         return ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_NORMAL].Enabled;
d1288 1
a1288 3
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
         return ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_COLOR0].Enabled;
d1290 1
a1290 4
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
         return ctx->Array.ArrayObj->
            VertexAttrib[VERT_ATTRIB_COLOR_INDEX].Enabled;
d1292 1
a1292 4
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
         return ctx->Array.ArrayObj->
            VertexAttrib[VERT_ATTRIB_TEX(ctx->Array.ActiveTexture)].Enabled;
d1294 1
a1294 3
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
         return ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_EDGEFLAG].Enabled;
d1296 2
a1297 3
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
         return ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_FOG].Enabled;
d1299 3
a1301 3
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
         return ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_COLOR1].Enabled;
d1303 7
a1309 3
         if (ctx->API != API_OPENGLES)
            goto invalid_enum_error;
         return ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_POINT_SIZE].Enabled;
d1318 1
a1318 3
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
         CHECK_EXTENSION(ARB_vertex_program);
a1322 2
         if (!_mesa_is_desktop_gl(ctx) && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
a1326 2
         if (!_mesa_is_desktop_gl(ctx) && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
a1330 2
         if (!_mesa_is_desktop_gl(ctx))
            goto invalid_enum_error;
d1335 1
a1335 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
a1339 2
         if (ctx->API != API_OPENGL_COMPAT && ctx->API != API_OPENGLES)
            goto invalid_enum_error;
d1343 1
d1345 1
a1345 3
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
         CHECK_EXTENSION(ARB_vertex_program);
d1348 1
a1348 6
         /* This was added with ARB_vertex_program, but it is also used with
          * GLSL vertex shaders on desktop.
          */
         if (!_mesa_is_desktop_gl(ctx))
            goto invalid_enum_error;
         CHECK_EXTENSION(ARB_vertex_program);
d1351 1
a1351 3
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
         CHECK_EXTENSION(ARB_vertex_program);
d1353 73
a1428 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
a1433 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
d1437 1
a1438 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
d1440 1
a1443 2
         if (!_mesa_is_desktop_gl(ctx))
            goto invalid_enum_error;
a1448 2
         if (!_mesa_is_desktop_gl(ctx))
            goto invalid_enum_error;
d1452 1
a1453 2
         if (ctx->API != API_OPENGL_COMPAT)
            goto invalid_enum_error;
d1456 1
a1458 2
         if (!_mesa_is_desktop_gl(ctx))
            goto invalid_enum_error;
d1462 1
a1463 2
         if (!_mesa_is_desktop_gl(ctx) && !_mesa_is_gles3(ctx))
            goto invalid_enum_error;
d1465 2
a1466 1
         return ctx->RasterDiscard;
d1470 1
a1470 1
         if (ctx->API != API_OPENGL_COMPAT || !ctx->Extensions.NV_primitive_restart) {
d1477 1
a1477 1
         if (!_mesa_is_desktop_gl(ctx) || ctx->Version < 31) {
a1481 27
      case GL_PRIMITIVE_RESTART_FIXED_INDEX:
	 if (!_mesa_is_gles3(ctx) && !ctx->Extensions.ARB_ES3_compatibility) {
            goto invalid_enum_error;
         }
         return ctx->Array.PrimitiveRestartFixedIndex;

      /* GL3.0 - GL_framebuffer_sRGB */
      case GL_FRAMEBUFFER_SRGB_EXT:
         if (!_mesa_is_desktop_gl(ctx))
            goto invalid_enum_error;
	 CHECK_EXTENSION(EXT_framebuffer_sRGB);
	 return ctx->Color.sRGBEnabled;

      /* GL_OES_EGL_image_external */
      case GL_TEXTURE_EXTERNAL_OES:
         if (!_mesa_is_gles(ctx))
            goto invalid_enum_error;
	 CHECK_EXTENSION(OES_EGL_image_external);
         return is_texture_enabled(ctx, TEXTURE_EXTERNAL_BIT);

      /* ARB_texture_multisample */
      case GL_SAMPLE_MASK:
         if (!_mesa_is_desktop_gl(ctx))
            goto invalid_enum_error;
         CHECK_EXTENSION(ARB_texture_multisample);
         return ctx->Multisample.SampleMask;

d1489 1
a1489 2
   _mesa_error(ctx, GL_INVALID_ENUM, "glIsEnabled(%s)",
               _mesa_lookup_enum_by_nr(cap));
@


1.1.1.5
log
@Import Mesa 10.2.3
@
text
@a34 1
#include "errors.h"
d66 1
a66 1
   struct gl_vertex_array_object *vao = ctx->Array.VAO;
d72 1
a72 1
         var = &vao->VertexAttrib[VERT_ATTRIB_POS].Enabled;
d76 1
a76 1
         var = &vao->VertexAttrib[VERT_ATTRIB_NORMAL].Enabled;
d80 1
a80 1
         var = &vao->VertexAttrib[VERT_ATTRIB_COLOR0].Enabled;
d84 1
a84 1
         var = &vao->VertexAttrib[VERT_ATTRIB_COLOR_INDEX].Enabled;
d88 1
a88 1
         var = &vao->VertexAttrib[VERT_ATTRIB_TEX(ctx->Array.ActiveTexture)].Enabled;
d92 1
a92 1
         var = &vao->VertexAttrib[VERT_ATTRIB_EDGEFLAG].Enabled;
d96 1
a96 1
         var = &vao->VertexAttrib[VERT_ATTRIB_FOG].Enabled;
d100 1
a100 1
         var = &vao->VertexAttrib[VERT_ATTRIB_COLOR1].Enabled;
d105 1
a105 1
         var = &vao->VertexAttrib[VERT_ATTRIB_POINT_SIZE].Enabled;
d134 1
a134 1
      vao->_Enabled |= flag;
d136 1
a136 3
      vao->_Enabled &= ~flag;

   vao->NewArrays |= flag;
a366 1
      case GL_DEBUG_OUTPUT:
d370 1
a370 2
         else
            _mesa_set_debug_state_int(ctx, cap, state);
d655 4
a658 9
         {
            /* Must expand glEnable to all scissors */
            GLbitfield newEnabled =
               state * ((1 << ctx->Const.MaxViewports) - 1);
            if (newEnabled != ctx->Scissor.EnableFlags) {
               FLUSH_VERTICES(ctx, _NEW_SCISSOR);
               ctx->Scissor.EnableFlags = newEnabled;
            }
         }
d758 1
a799 11
      /* GL_ARB_sample_shading */
      case GL_SAMPLE_SHADING:
         if (!_mesa_is_desktop_gl(ctx))
            goto invalid_enum_error;
         CHECK_EXTENSION(ARB_sample_shading, cap);
         if (ctx->Multisample.SampleShading == state)
            return;
         FLUSH_VERTICES(ctx, _NEW_MULTISAMPLE);
         ctx->Multisample.SampleShading = state;
         break;

d919 19
a1080 14
   case GL_SCISSOR_TEST:
      if (index >= ctx->Const.MaxViewports) {
         _mesa_error(ctx, GL_INVALID_VALUE, "%s(index=%u)",
                     state ? "glEnablei" : "glDisablei", index);
         return;
      }
      if (((ctx->Scissor.EnableFlags >> index) & 1) != state) {
         FLUSH_VERTICES(ctx, _NEW_SCISSOR);
         if (state)
            ctx->Scissor.EnableFlags |= (1 << index);
         else
            ctx->Scissor.EnableFlags &= ~(1 << index);
      }
      break;
a1121 7
   case GL_SCISSOR_TEST:
      if (index >= ctx->Const.MaxViewports) {
         _mesa_error(ctx, GL_INVALID_VALUE, "glIsEnabledIndexed(index=%u)",
                     index);
         return GL_FALSE;
      }
      return (ctx->Scissor.EnableFlags >> index) & 1;
a1203 1
      case GL_DEBUG_OUTPUT:
d1207 1
a1207 2
         else
            return (GLboolean) _mesa_get_debug_state_int(ctx, cap);
d1350 1
a1350 1
	 return ctx->Scissor.EnableFlags & 1;  /* return state for index 0 */
d1398 1
a1398 1
         return ctx->Array.VAO->VertexAttrib[VERT_ATTRIB_POS].Enabled;
d1402 1
a1402 1
         return ctx->Array.VAO->VertexAttrib[VERT_ATTRIB_NORMAL].Enabled;
d1406 1
a1406 1
         return ctx->Array.VAO->VertexAttrib[VERT_ATTRIB_COLOR0].Enabled;
d1410 1
a1410 1
         return ctx->Array.VAO->
d1415 1
a1415 1
         return ctx->Array.VAO->
d1420 1
a1420 1
         return ctx->Array.VAO->VertexAttrib[VERT_ATTRIB_EDGEFLAG].Enabled;
d1424 1
a1424 1
         return ctx->Array.VAO->VertexAttrib[VERT_ATTRIB_FOG].Enabled;
d1428 1
a1428 1
         return ctx->Array.VAO->VertexAttrib[VERT_ATTRIB_COLOR1].Enabled;
d1432 1
a1432 1
         return ctx->Array.VAO->VertexAttrib[VERT_ATTRIB_POINT_SIZE].Enabled;
d1443 1
a1586 7

      /* ARB_sample_shading */
      case GL_SAMPLE_SHADING:
         if (!_mesa_is_desktop_gl(ctx))
            goto invalid_enum_error;
         CHECK_EXTENSION(ARB_sample_shading);
         return ctx->Multisample.SampleShading;
@


1.1.1.6
log
@Import Mesa 10.4.3
@
text
@d316 1
a316 1
      case GL_CLIP_DISTANCE0: /* aka GL_CLIP_PLANE0 */
d1205 1
a1205 1
      case GL_CLIP_DISTANCE0: /* aka GL_CLIP_PLANE0 */
@


1.1.1.7
log
@Import Mesa 10.2.9
@
text
@d316 1
a316 1
      case GL_CLIP_DISTANCE0:
d1205 1
a1205 1
      case GL_CLIP_DISTANCE0:
@


