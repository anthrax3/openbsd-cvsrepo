head	1.9;
access;
symbols
	OPENBSD_5_8:1.8.0.6
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.4
	OPENBSD_5_7_BASE:1.8
	v10_2_9:1.1.1.6
	v10_4_3:1.1.1.6
	v10_2_7:1.1.1.6
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	v10_2_3:1.1.1.6
	OPENBSD_5_5:1.7.0.2
	OPENBSD_5_5_BASE:1.7
	v9_2_5:1.1.1.5
	v9_2_3:1.1.1.5
	v9_2_2:1.1.1.5
	v9_2_1:1.1.1.5
	v9_2_0:1.1.1.5
	OPENBSD_5_4:1.6.0.4
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.3.0.4
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2015.12.23.05.17.52;	author jsg;	state dead;
branches;
next	1.8;
commitid	TnlogFl9nOv2eaRf;

1.8
date	2014.07.09.21.09.00;	author jsg;	state Exp;
branches;
next	1.7;
commitid	WPD6rgPryPkvXOr9;

1.7
date	2013.09.05.14.06.17;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2012.08.17.13.58.17;	author mpi;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.23.13.37.42;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.30;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.41;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.20;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.49.46;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.49.46;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.56.32;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.30.51;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.45;	author matthieu;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.09.05.13.16.25;	author jsg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.07.09.20.34.59;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.9
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */


#include "glheader.h"
#include "bufferobj.h"
#include "colortab.h"
#include "context.h"
#include "image.h"
#include "macros.h"
#include "mtypes.h"
#include "pack.h"
#include "pbo.h"
#include "state.h"
#include "teximage.h"
#include "texstate.h"
#include "main/dispatch.h"


void GLAPIENTRY
_mesa_ColorTable( GLenum target, GLenum internalFormat,
                  GLsizei width, GLenum format, GLenum type,
                  const GLvoid *data )
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_error(ctx, GL_INVALID_OPERATION, "glColorTable");
}



void GLAPIENTRY
_mesa_ColorSubTable( GLenum target, GLsizei start,
                     GLsizei count, GLenum format, GLenum type,
                     const GLvoid *data )
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_error(ctx, GL_INVALID_OPERATION, "glColorSubTable");
}



void GLAPIENTRY
_mesa_CopyColorTable(GLenum target, GLenum internalformat,
                     GLint x, GLint y, GLsizei width)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_error(ctx, GL_INVALID_OPERATION, "glCopyColorTable");
}



void GLAPIENTRY
_mesa_CopyColorSubTable(GLenum target, GLsizei start,
                        GLint x, GLint y, GLsizei width)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_error(ctx, GL_INVALID_OPERATION, "glCopyColorSubTable");
}



void GLAPIENTRY
_mesa_GetnColorTableARB( GLenum target, GLenum format, GLenum type,
                         GLsizei bufSize, GLvoid *data )
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_error(ctx, GL_INVALID_OPERATION, "glGetnColorTableARB");
}


void GLAPIENTRY
_mesa_GetColorTable( GLenum target, GLenum format,
                     GLenum type, GLvoid *data )
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_error(ctx, GL_INVALID_OPERATION, "glGetColorTable");
}


void GLAPIENTRY
_mesa_ColorTableParameterfv(GLenum target, GLenum pname, const GLfloat *params)
{
   /* no extensions use this function */
   GET_CURRENT_CONTEXT(ctx);
   _mesa_error(ctx, GL_INVALID_OPERATION, "glColorTableParameterfv");
}



void GLAPIENTRY
_mesa_ColorTableParameteriv(GLenum target, GLenum pname, const GLint *params)
{
   /* no extensions use this function */
   GET_CURRENT_CONTEXT(ctx);
   _mesa_error(ctx, GL_INVALID_OPERATION, "glColorTableParameteriv");
}



void GLAPIENTRY
_mesa_GetColorTableParameterfv( GLenum target, GLenum pname, GLfloat *params )
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_error(ctx, GL_INVALID_OPERATION, "glGetColorTableParameterfv");
}



void GLAPIENTRY
_mesa_GetColorTableParameteriv( GLenum target, GLenum pname, GLint *params )
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_error(ctx, GL_INVALID_OPERATION, "glGetColorTableParameteriv");
}
@


1.8
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.7
log
@Merge Mesa 9.2.0
@
text
@d47 1
a47 1
   _mesa_error(ctx, GL_INVALID_ENUM, "glColorTable(target)");
d58 1
a58 1
   _mesa_error(ctx, GL_INVALID_ENUM, "glColorSubTable(target)");
d68 1
a68 1
   _mesa_error(ctx, GL_INVALID_ENUM, "glCopyColorTable(target)");
d78 1
a78 1
   _mesa_error(ctx, GL_INVALID_ENUM, "glCopyColorSubTable(target)");
d88 1
a88 1
   _mesa_error(ctx, GL_INVALID_ENUM, "glGetnColorTableARB(target)");
d97 1
a97 1
   _mesa_error(ctx, GL_INVALID_ENUM, "glGetColorTable(target)");
d106 1
a106 1
   _mesa_error(ctx, GL_INVALID_ENUM, "glColorTableParameterfv(target)");
d116 1
a116 1
   _mesa_error(ctx, GL_INVALID_ENUM, "glColorTableParameteriv(target)");
d125 1
a125 1
   _mesa_error(ctx, GL_INVALID_ENUM, "glGetColorTableParameterfv(target)");
d134 1
a134 1
   _mesa_error(ctx, GL_INVALID_ENUM, "glGetColorTableParameteriv(target)");
@


1.6
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a2 1
 * Version:  7.1
d19 4
a22 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
a31 1
#include "mfeatures.h"
a40 240
#if FEATURE_colortable


/**
 * Given an internalFormat token passed to glColorTable,
 * return the corresponding base format.
 * Return -1 if invalid token.
 */
static GLint
base_colortab_format( GLenum format )
{
   switch (format) {
      case GL_ALPHA:
      case GL_ALPHA4:
      case GL_ALPHA8:
      case GL_ALPHA12:
      case GL_ALPHA16:
         return GL_ALPHA;
      case GL_LUMINANCE:
      case GL_LUMINANCE4:
      case GL_LUMINANCE8:
      case GL_LUMINANCE12:
      case GL_LUMINANCE16:
         return GL_LUMINANCE;
      case GL_LUMINANCE_ALPHA:
      case GL_LUMINANCE4_ALPHA4:
      case GL_LUMINANCE6_ALPHA2:
      case GL_LUMINANCE8_ALPHA8:
      case GL_LUMINANCE12_ALPHA4:
      case GL_LUMINANCE12_ALPHA12:
      case GL_LUMINANCE16_ALPHA16:
         return GL_LUMINANCE_ALPHA;
      case GL_INTENSITY:
      case GL_INTENSITY4:
      case GL_INTENSITY8:
      case GL_INTENSITY12:
      case GL_INTENSITY16:
         return GL_INTENSITY;
      case GL_RGB:
      case GL_R3_G3_B2:
      case GL_RGB4:
      case GL_RGB5:
      case GL_RGB8:
      case GL_RGB10:
      case GL_RGB12:
      case GL_RGB16:
         return GL_RGB;
      case GL_RGBA:
      case GL_RGBA2:
      case GL_RGBA4:
      case GL_RGB5_A1:
      case GL_RGBA8:
      case GL_RGB10_A2:
      case GL_RGBA12:
      case GL_RGBA16:
         return GL_RGBA;
      default:
         return -1;  /* error */
   }
}



/**
 * Examine table's format and set the component sizes accordingly.
 */
static void
set_component_sizes( struct gl_color_table *table )
{
   /* assuming the ubyte table */
   const GLubyte sz = 8;

   switch (table->_BaseFormat) {
      case GL_ALPHA:
         table->RedSize = 0;
         table->GreenSize = 0;
         table->BlueSize = 0;
         table->AlphaSize = sz;
         table->IntensitySize = 0;
         table->LuminanceSize = 0;
         break;
      case GL_LUMINANCE:
         table->RedSize = 0;
         table->GreenSize = 0;
         table->BlueSize = 0;
         table->AlphaSize = 0;
         table->IntensitySize = 0;
         table->LuminanceSize = sz;
         break;
      case GL_LUMINANCE_ALPHA:
         table->RedSize = 0;
         table->GreenSize = 0;
         table->BlueSize = 0;
         table->AlphaSize = sz;
         table->IntensitySize = 0;
         table->LuminanceSize = sz;
         break;
      case GL_INTENSITY:
         table->RedSize = 0;
         table->GreenSize = 0;
         table->BlueSize = 0;
         table->AlphaSize = 0;
         table->IntensitySize = sz;
         table->LuminanceSize = 0;
         break;
      case GL_RGB:
         table->RedSize = sz;
         table->GreenSize = sz;
         table->BlueSize = sz;
         table->AlphaSize = 0;
         table->IntensitySize = 0;
         table->LuminanceSize = 0;
         break;
      case GL_RGBA:
         table->RedSize = sz;
         table->GreenSize = sz;
         table->BlueSize = sz;
         table->AlphaSize = sz;
         table->IntensitySize = 0;
         table->LuminanceSize = 0;
         break;
      default:
         _mesa_problem(NULL, "unexpected format in set_component_sizes");
   }
}



/**
 * Update/replace all or part of a color table.  Helper function
 * used by _mesa_ColorTable() and _mesa_ColorSubTable().
 * The table->Table buffer should already be allocated.
 * \param start first entry to update
 * \param count number of entries to update
 * \param format format of user-provided table data
 * \param type datatype of user-provided table data
 * \param data user-provided table data
 * \param [rgba]Scale - RGBA scale factors
 * \param [rgba]Bias - RGBA bias factors
 */
static void
store_colortable_entries(struct gl_context *ctx, struct gl_color_table *table,
			 GLsizei start, GLsizei count,
			 GLenum format, GLenum type, const GLvoid *data,
			 GLfloat rScale, GLfloat rBias,
			 GLfloat gScale, GLfloat gBias,
			 GLfloat bScale, GLfloat bBias,
			 GLfloat aScale, GLfloat aBias)
{
   data = _mesa_map_validate_pbo_source(ctx, 
                                        1, &ctx->Unpack, count, 1, 1,
                                        format, type, INT_MAX, data,
                                        "glColor[Sub]Table");
   if (!data)
      return;

   {
      /* convert user-provided data to GLfloat values */
      GLfloat tempTab[MAX_COLOR_TABLE_SIZE * 4];
      GLfloat *tableF;
      GLint i;

      _mesa_unpack_color_span_float(ctx,
                                    count,         /* number of pixels */
                                    table->_BaseFormat, /* dest format */
                                    tempTab,       /* dest address */
                                    format, type,  /* src format/type */
                                    data,          /* src data */
                                    &ctx->Unpack,
                                    IMAGE_CLAMP_BIT); /* transfer ops */

      /* the destination */
      tableF = table->TableF;

      /* Apply scale & bias & clamp now */
      switch (table->_BaseFormat) {
         case GL_INTENSITY:
            for (i = 0; i < count; i++) {
               GLuint j = start + i;
               tableF[j] = CLAMP(tempTab[i] * rScale + rBias, 0.0F, 1.0F);
            }
            break;
         case GL_LUMINANCE:
            for (i = 0; i < count; i++) {
               GLuint j = start + i;
               tableF[j] = CLAMP(tempTab[i] * rScale + rBias, 0.0F, 1.0F);
            }
            break;
         case GL_ALPHA:
            for (i = 0; i < count; i++) {
               GLuint j = start + i;
               tableF[j] = CLAMP(tempTab[i] * aScale + aBias, 0.0F, 1.0F);
            }
            break;
         case GL_LUMINANCE_ALPHA:
            for (i = 0; i < count; i++) {
               GLuint j = start + i;
               tableF[j*2+0] = CLAMP(tempTab[i*2+0] * rScale + rBias, 0.0F, 1.0F);
               tableF[j*2+1] = CLAMP(tempTab[i*2+1] * aScale + aBias, 0.0F, 1.0F);
            }
            break;
         case GL_RGB:
            for (i = 0; i < count; i++) {
               GLuint j = start + i;
               tableF[j*3+0] = CLAMP(tempTab[i*3+0] * rScale + rBias, 0.0F, 1.0F);
               tableF[j*3+1] = CLAMP(tempTab[i*3+1] * gScale + gBias, 0.0F, 1.0F);
               tableF[j*3+2] = CLAMP(tempTab[i*3+2] * bScale + bBias, 0.0F, 1.0F);
            }
            break;
         case GL_RGBA:
            for (i = 0; i < count; i++) {
               GLuint j = start + i;
               tableF[j*4+0] = CLAMP(tempTab[i*4+0] * rScale + rBias, 0.0F, 1.0F);
               tableF[j*4+1] = CLAMP(tempTab[i*4+1] * gScale + gBias, 0.0F, 1.0F);
               tableF[j*4+2] = CLAMP(tempTab[i*4+2] * bScale + bBias, 0.0F, 1.0F);
               tableF[j*4+3] = CLAMP(tempTab[i*4+3] * aScale + aBias, 0.0F, 1.0F);
            }
            break;
         default:
            _mesa_problem(ctx, "Bad format in store_colortable_entries");
            return;
         }
   }

   /* update the ubyte table */
   {
      const GLint comps = _mesa_components_in_format(table->_BaseFormat);
      const GLfloat *tableF = table->TableF + start * comps;
      GLubyte *tableUB = table->TableUB + start * comps;
      GLint i;
      for (i = 0; i < count * comps; i++) {
         CLAMPED_FLOAT_TO_UBYTE(tableUB[i], tableF[i]);
      }
   }

   _mesa_unmap_pbo_source(ctx, &ctx->Unpack);
}



a45 2
   static const GLfloat one[4] = { 1.0, 1.0, 1.0, 1.0 };
   static const GLfloat zero[4] = { 0.0, 0.0, 0.0, 0.0 };
d47 1
a47 109
   struct gl_texture_unit *texUnit = _mesa_get_current_tex_unit(ctx);
   struct gl_texture_object *texObj = NULL;
   struct gl_color_table *table = NULL;
   GLboolean proxy = GL_FALSE;
   GLint baseFormat;
   const GLfloat *scale = one, *bias = zero;
   GLint comps;

   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx); /* too complex */

   switch (target) {
      case GL_SHARED_TEXTURE_PALETTE_EXT:
         table = &ctx->Texture.Palette;
         break;
      default:
         /* try texture targets */
         {
            struct gl_texture_object *texobj
               = _mesa_select_tex_object(ctx, texUnit, target);
            if (texobj) {
               table = &texobj->Palette;
               proxy = _mesa_is_proxy_texture(target);
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glColorTable(target)");
               return;
            }
         }
   }

   assert(table);

   if (!_mesa_is_legal_format_and_type(ctx, format, type) ||
       format == GL_INTENSITY) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glColorTable(format or type)");
      return;
   }

   baseFormat = base_colortab_format(internalFormat);
   if (baseFormat < 0) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glColorTable(internalFormat)");
      return;
   }

   if (width < 0 || (width != 0 && !_mesa_is_pow_two(width))) {
      /* error */
      if (proxy) {
         table->Size = 0;
         table->InternalFormat = (GLenum) 0;
         table->_BaseFormat = (GLenum) 0;
      }
      else {
         _mesa_error(ctx, GL_INVALID_VALUE, "glColorTable(width=%d)", width);
      }
      return;
   }

   if (width > (GLsizei) ctx->Const.MaxColorTableSize) {
      if (proxy) {
         table->Size = 0;
         table->InternalFormat = (GLenum) 0;
         table->_BaseFormat = (GLenum) 0;
      }
      else {
         _mesa_error(ctx, GL_TABLE_TOO_LARGE, "glColorTable(width)");
      }
      return;
   }

   table->Size = width;
   table->InternalFormat = internalFormat;
   table->_BaseFormat = (GLenum) baseFormat;

   comps = _mesa_components_in_format(table->_BaseFormat);
   assert(comps > 0);  /* error should have been caught sooner */

   if (!proxy) {
      _mesa_free_colortable_data(table);

      if (width > 0) {
         table->TableF = (GLfloat *) malloc(comps * width * sizeof(GLfloat));
         table->TableUB = (GLubyte *) malloc(comps * width * sizeof(GLubyte));

	 if (!table->TableF || !table->TableUB) {
	    _mesa_error(ctx, GL_OUT_OF_MEMORY, "glColorTable");
	    return;
	 }

	 store_colortable_entries(ctx, table,
				  0, width,  /* start, count */
				  format, type, data,
				  scale[0], bias[0],
				  scale[1], bias[1],
				  scale[2], bias[2],
				  scale[3], bias[3]);
      }
   } /* proxy */

   /* do this after the table's Type and Format are set */
   set_component_sizes(table);

   if (texObj || target == GL_SHARED_TEXTURE_PALETTE_EXT) {
      /* texture object palette, texObj==NULL means the shared palette */
      if (ctx->Driver.UpdateTexturePalette) {
         (*ctx->Driver.UpdateTexturePalette)( ctx, texObj );
      }
   }

   ctx->NewState |= _NEW_PIXEL;
a56 2
   static const GLfloat one[4] = { 1.0, 1.0, 1.0, 1.0 };
   static const GLfloat zero[4] = { 0.0, 0.0, 0.0, 0.0 };
d58 1
a58 64
   struct gl_texture_unit *texUnit = _mesa_get_current_tex_unit(ctx);
   struct gl_texture_object *texObj = NULL;
   struct gl_color_table *table = NULL;
   const GLfloat *scale = one, *bias = zero;

   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

   switch (target) {
      case GL_SHARED_TEXTURE_PALETTE_EXT:
         table = &ctx->Texture.Palette;
         break;
      default:
         /* try texture targets */
         texObj = _mesa_select_tex_object(ctx, texUnit, target);
         if (texObj && !_mesa_is_proxy_texture(target)) {
            table = &texObj->Palette;
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM, "glColorSubTable(target)");
            return;
         }
   }

   assert(table);

   if (!_mesa_is_legal_format_and_type(ctx, format, type) ||
       format == GL_INTENSITY) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glColorSubTable(format or type)");
      return;
   }

   if (count < 1) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glColorSubTable(count)");
      return;
   }

   /* error should have been caught sooner */
   assert(_mesa_components_in_format(table->_BaseFormat) > 0);

   if (start + count > (GLint) table->Size) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glColorSubTable(count)");
      return;
   }

   if (!table->TableF || !table->TableUB) {
      /* a GL_OUT_OF_MEMORY error would have been recorded previously */
      return;
   }

   store_colortable_entries(ctx, table, start, count,
			    format, type, data,
                            scale[0], bias[0],
                            scale[1], bias[1],
                            scale[2], bias[2],
                            scale[3], bias[3]);

   if (texObj || target == GL_SHARED_TEXTURE_PALETTE_EXT) {
      /* per-texture object palette */
      if (ctx->Driver.UpdateTexturePalette) {
         (*ctx->Driver.UpdateTexturePalette)( ctx, texObj );
      }
   }

   ctx->NewState |= _NEW_PIXEL;
d63 1
a63 1
static void GLAPIENTRY
d68 1
a68 7
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

   if (!ctx->ReadBuffer->_ColorReadBuffer) {
      return;      /* no readbuffer - OK */
   }

   ctx->Driver.CopyColorTable( ctx, target, internalformat, x, y, width );
d73 1
a73 1
static void GLAPIENTRY
d78 1
a78 7
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

   if (!ctx->ReadBuffer->_ColorReadBuffer) {
      return;      /* no readbuffer - OK */
   }

   ctx->Driver.CopyColorSubTable( ctx, target, start, x, y, width );
d83 1
a83 1
static void GLAPIENTRY
d88 1
a88 114
   struct gl_texture_unit *texUnit = _mesa_get_current_tex_unit(ctx);
   struct gl_color_table *table = NULL;
   GLfloat rgba[MAX_COLOR_TABLE_SIZE][4];
   GLbitfield transferOps = 0;
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

   if (ctx->NewState) {
      _mesa_update_state(ctx);
   }

   switch (target) {
      case GL_SHARED_TEXTURE_PALETTE_EXT:
         table = &ctx->Texture.Palette;
         break;
      default:
         /* try texture targets */
         {
            struct gl_texture_object *texobj
               = _mesa_select_tex_object(ctx, texUnit, target);
            if (texobj && !_mesa_is_proxy_texture(target)) {
               table = &texobj->Palette;
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetColorTable(target)");
               return;
            }
         }
   }

   ASSERT(table);

   if (table->Size <= 0) {
      return;
   }

   switch (table->_BaseFormat) {
   case GL_ALPHA:
      {
         GLuint i;
         for (i = 0; i < table->Size; i++) {
            rgba[i][RCOMP] = 0;
            rgba[i][GCOMP] = 0;
            rgba[i][BCOMP] = 0;
            rgba[i][ACOMP] = table->TableF[i];
         }
      }
      break;
   case GL_LUMINANCE:
      {
         GLuint i;
         for (i = 0; i < table->Size; i++) {
            rgba[i][RCOMP] =
            rgba[i][GCOMP] =
            rgba[i][BCOMP] = table->TableF[i];
            rgba[i][ACOMP] = 1.0F;
         }
      }
      break;
   case GL_LUMINANCE_ALPHA:
      {
         GLuint i;
         for (i = 0; i < table->Size; i++) {
            rgba[i][RCOMP] =
            rgba[i][GCOMP] =
            rgba[i][BCOMP] = table->TableF[i*2+0];
            rgba[i][ACOMP] = table->TableF[i*2+1];
         }
      }
      break;
   case GL_INTENSITY:
      {
         GLuint i;
         for (i = 0; i < table->Size; i++) {
            rgba[i][RCOMP] =
            rgba[i][GCOMP] =
            rgba[i][BCOMP] =
            rgba[i][ACOMP] = table->TableF[i];
         }
      }
      break;
   case GL_RGB:
      {
         GLuint i;
         for (i = 0; i < table->Size; i++) {
            rgba[i][RCOMP] = table->TableF[i*3+0];
            rgba[i][GCOMP] = table->TableF[i*3+1];
            rgba[i][BCOMP] = table->TableF[i*3+2];
            rgba[i][ACOMP] = 1.0F;
         }
      }
      break;
   case GL_RGBA:
      memcpy(rgba, table->TableF, 4 * table->Size * sizeof(GLfloat));
      break;
   default:
      _mesa_problem(ctx, "bad table format in glGetColorTable");
      return;
   }

   data = _mesa_map_validate_pbo_dest(ctx, 
                                      1, &ctx->Pack, table->Size, 1, 1,
                                      format, type, bufSize, data,
                                      "glGetColorTable");
   if (!data)
      return;

   /* TODO: is this correct? */
   if(ctx->Color._ClampReadColor)
      transferOps |= IMAGE_CLAMP_BIT;

   _mesa_pack_rgba_span_float(ctx, table->Size, rgba,
                              format, type, data, &ctx->Pack, transferOps);

   _mesa_unmap_pbo_dest(ctx, &ctx->Pack);
d92 1
a92 1
static void GLAPIENTRY
d96 2
a97 1
   _mesa_GetnColorTableARB(target, format, type, INT_MAX, data);
d101 1
a101 1
static void GLAPIENTRY
a105 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d111 1
a111 1
static void GLAPIENTRY
a115 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d121 1
a121 1
static void GLAPIENTRY
d125 1
a125 55
   struct gl_texture_unit *texUnit = _mesa_get_current_tex_unit(ctx);
   struct gl_color_table *table = NULL;
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   switch (target) {
      case GL_SHARED_TEXTURE_PALETTE_EXT:
         table = &ctx->Texture.Palette;
         break;
      default:
         /* try texture targets */
         {
            struct gl_texture_object *texobj
               = _mesa_select_tex_object(ctx, texUnit, target);
            if (texobj) {
               table = &texobj->Palette;
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM,
                           "glGetColorTableParameterfv(target)");
               return;
            }
         }
   }

   assert(table);

   switch (pname) {
      case GL_COLOR_TABLE_FORMAT:
         *params = (GLfloat) table->InternalFormat;
         break;
      case GL_COLOR_TABLE_WIDTH:
         *params = (GLfloat) table->Size;
         break;
      case GL_COLOR_TABLE_RED_SIZE:
         *params = (GLfloat) table->RedSize;
         break;
      case GL_COLOR_TABLE_GREEN_SIZE:
         *params = (GLfloat) table->GreenSize;
         break;
      case GL_COLOR_TABLE_BLUE_SIZE:
         *params = (GLfloat) table->BlueSize;
         break;
      case GL_COLOR_TABLE_ALPHA_SIZE:
         *params = (GLfloat) table->AlphaSize;
         break;
      case GL_COLOR_TABLE_LUMINANCE_SIZE:
         *params = (GLfloat) table->LuminanceSize;
         break;
      case GL_COLOR_TABLE_INTENSITY_SIZE:
         *params = (GLfloat) table->IntensitySize;
         break;
      default:
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetColorTableParameterfv(pname)" );
         return;
   }
d130 1
a130 1
static void GLAPIENTRY
d134 1
a134 106
   struct gl_texture_unit *texUnit = _mesa_get_current_tex_unit(ctx);
   struct gl_color_table *table = NULL;
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   switch (target) {
      case GL_SHARED_TEXTURE_PALETTE_EXT:
         table = &ctx->Texture.Palette;
         break;
      default:
         /* Try texture targets */
         {
            struct gl_texture_object *texobj
               = _mesa_select_tex_object(ctx, texUnit, target);
            if (texobj) {
               table = &texobj->Palette;
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM,
                           "glGetColorTableParameteriv(target)");
               return;
            }
         }
   }

   assert(table);

   switch (pname) {
      case GL_COLOR_TABLE_FORMAT:
         *params = table->InternalFormat;
         break;
      case GL_COLOR_TABLE_WIDTH:
         *params = table->Size;
         break;
      case GL_COLOR_TABLE_RED_SIZE:
         *params = table->RedSize;
         break;
      case GL_COLOR_TABLE_GREEN_SIZE:
         *params = table->GreenSize;
         break;
      case GL_COLOR_TABLE_BLUE_SIZE:
         *params = table->BlueSize;
         break;
      case GL_COLOR_TABLE_ALPHA_SIZE:
         *params = table->AlphaSize;
         break;
      case GL_COLOR_TABLE_LUMINANCE_SIZE:
         *params = table->LuminanceSize;
         break;
      case GL_COLOR_TABLE_INTENSITY_SIZE:
         *params = table->IntensitySize;
         break;
      default:
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetColorTableParameteriv(pname)" );
         return;
   }
}


void
_mesa_init_colortable_dispatch(struct _glapi_table *disp)
{
   SET_ColorSubTable(disp, _mesa_ColorSubTable);
   SET_ColorTable(disp, _mesa_ColorTable);
   SET_ColorTableParameterfv(disp, _mesa_ColorTableParameterfv);
   SET_ColorTableParameteriv(disp, _mesa_ColorTableParameteriv);
   SET_CopyColorSubTable(disp, _mesa_CopyColorSubTable);
   SET_CopyColorTable(disp, _mesa_CopyColorTable);
   SET_GetColorTable(disp, _mesa_GetColorTable);
   SET_GetColorTableParameterfv(disp, _mesa_GetColorTableParameterfv);
   SET_GetColorTableParameteriv(disp, _mesa_GetColorTableParameteriv);

   /* GL_ARB_robustness */
   SET_GetnColorTableARB(disp, _mesa_GetnColorTableARB);
}


#endif /* FEATURE_colortable */


/**********************************************************************/
/*****                      Initialization                        *****/
/**********************************************************************/


void
_mesa_init_colortable( struct gl_color_table *p )
{
   p->TableF = NULL;
   p->TableUB = NULL;
   p->Size = 0;
   p->InternalFormat = GL_RGBA;
}



void
_mesa_free_colortable_data( struct gl_color_table *p )
{
   if (p->TableF) {
      free(p->TableF);
      p->TableF = NULL;
   }
   if (p->TableUB) {
      free(p->TableUB);
      p->TableUB = NULL;
   }
@


1.5
log
@Merge Mesa 7.10.3
@
text
@d32 2
d35 1
d193 1
a193 1
                                        format, type, data,
a303 17
      case GL_TEXTURE_COLOR_TABLE_SGI:
         if (!ctx->Extensions.SGI_texture_color_table) {
            _mesa_error(ctx, GL_INVALID_ENUM, "glColorTable(target)");
            return;
         }
         table = &(texUnit->ColorTable);
         scale = ctx->Pixel.TextureColorTableScale;
         bias = ctx->Pixel.TextureColorTableBias;
         break;
      case GL_PROXY_TEXTURE_COLOR_TABLE_SGI:
         if (!ctx->Extensions.SGI_texture_color_table) {
            _mesa_error(ctx, GL_INVALID_ENUM, "glColorTable(target)");
            return;
         }
         table = &(texUnit->ProxyColorTable);
         proxy = GL_TRUE;
         break;
a421 9
      case GL_TEXTURE_COLOR_TABLE_SGI:
         if (!ctx->Extensions.SGI_texture_color_table) {
            _mesa_error(ctx, GL_INVALID_ENUM, "glColorSubTable(target)");
            return;
         }
         table = &(texUnit->ColorTable);
         scale = ctx->Pixel.TextureColorTableScale;
         bias = ctx->Pixel.TextureColorTableBias;
         break;
d512 2
a513 2
_mesa_GetColorTable( GLenum target, GLenum format,
                     GLenum type, GLvoid *data )
d519 1
a529 7
      case GL_TEXTURE_COLOR_TABLE_SGI:
         if (!ctx->Extensions.SGI_texture_color_table) {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetColorTable(target)");
            return;
         }
         table = &(texUnit->ColorTable);
         break;
d617 1
a617 1
                                      format, type, data,
d622 4
d627 1
a627 1
                              format, type, data, &ctx->Pack, 0x0);
d633 7
d644 1
a644 1
   GLfloat *scale, *bias;
d647 1
a647 23

   switch (target) {
   case GL_TEXTURE_COLOR_TABLE_SGI:
      scale = ctx->Pixel.TextureColorTableScale;
      bias  = ctx->Pixel.TextureColorTableBias;
      break;
   default:
      _mesa_error(ctx, GL_INVALID_ENUM, "glColorTableParameter(target)");
      return;
   }

   if (pname == GL_COLOR_TABLE_SCALE_SGI) {
      COPY_4V(scale, params);
   }
   else if (pname == GL_COLOR_TABLE_BIAS_SGI) {
      COPY_4V(bias, params);
   }
   else {
      _mesa_error(ctx, GL_INVALID_ENUM, "glColorTableParameterfv(pname)");
      return;
   }

   ctx->NewState |= _NEW_PIXEL;
d655 4
a658 13
   GLfloat fparams[4];
   if (pname == GL_TEXTURE_COLOR_TABLE_SGI) {
      /* four values */
      fparams[0] = (GLfloat) params[0];
      fparams[1] = (GLfloat) params[1];
      fparams[2] = (GLfloat) params[2];
      fparams[3] = (GLfloat) params[3];
   }
   else {
      /* one values */
      fparams[0] = (GLfloat) params[0];
   }
   _mesa_ColorTableParameterfv(target, pname, fparams);
a674 22
      case GL_TEXTURE_COLOR_TABLE_SGI:
         if (!ctx->Extensions.SGI_texture_color_table) {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetColorTableParameter(target)");
            return;
         }
         table = &(texUnit->ColorTable);
         if (pname == GL_COLOR_TABLE_SCALE_SGI) {
            COPY_4V(params, ctx->Pixel.TextureColorTableScale);
            return;
         }
         else if (pname == GL_COLOR_TABLE_BIAS_SGI) {
            COPY_4V(params, ctx->Pixel.TextureColorTableBias);
            return;
         }
         break;
      case GL_PROXY_TEXTURE_COLOR_TABLE_SGI:
         if (!ctx->Extensions.SGI_texture_color_table) {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetColorTableParameter(target)");
            return;
         }
         table = &(texUnit->ProxyColorTable);
         break;
a737 28
      case GL_TEXTURE_COLOR_TABLE_SGI:
         if (!ctx->Extensions.SGI_texture_color_table) {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetColorTableParameter(target)");
            return;
         }
         table = &(texUnit->ColorTable);
         if (pname == GL_COLOR_TABLE_SCALE_SGI) {
            params[0] = (GLint) ctx->Pixel.TextureColorTableScale[0];
            params[1] = (GLint) ctx->Pixel.TextureColorTableScale[1];
            params[2] = (GLint) ctx->Pixel.TextureColorTableScale[2];
            params[3] = (GLint) ctx->Pixel.TextureColorTableScale[3];
            return;
         }
         else if (pname == GL_COLOR_TABLE_BIAS_SGI) {
            params[0] = (GLint) ctx->Pixel.TextureColorTableBias[0];
            params[1] = (GLint) ctx->Pixel.TextureColorTableBias[1];
            params[2] = (GLint) ctx->Pixel.TextureColorTableBias[2];
            params[3] = (GLint) ctx->Pixel.TextureColorTableBias[3];
            return;
         }
         break;
      case GL_PROXY_TEXTURE_COLOR_TABLE_SGI:
         if (!ctx->Extensions.SGI_texture_color_table) {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetColorTableParameter(target)");
            return;
         }
         table = &(texUnit->ProxyColorTable);
         break;
d800 3
@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d32 1
d180 1
a180 1
store_colortable_entries(GLcontext *ctx, struct gl_color_table *table,
a300 9
      case GL_COLOR_TABLE:
         table = &ctx->ColorTable[COLORTABLE_PRECONVOLUTION];
         scale = ctx->Pixel.ColorTableScale[COLORTABLE_PRECONVOLUTION];
         bias = ctx->Pixel.ColorTableBias[COLORTABLE_PRECONVOLUTION];
         break;
      case GL_PROXY_COLOR_TABLE:
         table = &ctx->ProxyColorTable[COLORTABLE_PRECONVOLUTION];
         proxy = GL_TRUE;
         break;
a317 18
      case GL_POST_CONVOLUTION_COLOR_TABLE:
         table = &ctx->ColorTable[COLORTABLE_POSTCONVOLUTION];
         scale = ctx->Pixel.ColorTableScale[COLORTABLE_POSTCONVOLUTION];
         bias = ctx->Pixel.ColorTableBias[COLORTABLE_POSTCONVOLUTION];
         break;
      case GL_PROXY_POST_CONVOLUTION_COLOR_TABLE:
         table = &ctx->ProxyColorTable[COLORTABLE_POSTCONVOLUTION];
         proxy = GL_TRUE;
         break;
      case GL_POST_COLOR_MATRIX_COLOR_TABLE:
         table = &ctx->ColorTable[COLORTABLE_POSTCOLORMATRIX];
         scale = ctx->Pixel.ColorTableScale[COLORTABLE_POSTCOLORMATRIX];
         bias = ctx->Pixel.ColorTableBias[COLORTABLE_POSTCOLORMATRIX];
         break;
      case GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE:
         table = &ctx->ProxyColorTable[COLORTABLE_POSTCOLORMATRIX];
         proxy = GL_TRUE;
         break;
a435 5
      case GL_COLOR_TABLE:
         table = &ctx->ColorTable[COLORTABLE_PRECONVOLUTION];
         scale = ctx->Pixel.ColorTableScale[COLORTABLE_PRECONVOLUTION];
         bias = ctx->Pixel.ColorTableBias[COLORTABLE_PRECONVOLUTION];
         break;
a444 10
      case GL_POST_CONVOLUTION_COLOR_TABLE:
         table = &ctx->ColorTable[COLORTABLE_POSTCONVOLUTION];
         scale = ctx->Pixel.ColorTableScale[COLORTABLE_POSTCONVOLUTION];
         bias = ctx->Pixel.ColorTableBias[COLORTABLE_POSTCONVOLUTION];
         break;
      case GL_POST_COLOR_MATRIX_COLOR_TABLE:
         table = &ctx->ColorTable[COLORTABLE_POSTCOLORMATRIX];
         scale = ctx->Pixel.ColorTableScale[COLORTABLE_POSTCOLORMATRIX];
         bias = ctx->Pixel.ColorTableBias[COLORTABLE_POSTCOLORMATRIX];
         break;
a551 3
      case GL_COLOR_TABLE:
         table = &ctx->ColorTable[COLORTABLE_PRECONVOLUTION];
         break;
a558 6
      case GL_POST_CONVOLUTION_COLOR_TABLE:
         table = &ctx->ColorTable[COLORTABLE_POSTCONVOLUTION];
         break;
      case GL_POST_COLOR_MATRIX_COLOR_TABLE:
         table = &ctx->ColorTable[COLORTABLE_POSTCOLORMATRIX];
         break;
a666 4
   case GL_COLOR_TABLE_SGI:
      scale = ctx->Pixel.ColorTableScale[COLORTABLE_PRECONVOLUTION];
      bias  = ctx->Pixel.ColorTableBias[COLORTABLE_PRECONVOLUTION];
      break;
a670 8
   case GL_POST_CONVOLUTION_COLOR_TABLE_SGI:
      scale = ctx->Pixel.ColorTableScale[COLORTABLE_POSTCONVOLUTION];
      bias  = ctx->Pixel.ColorTableBias[COLORTABLE_POSTCONVOLUTION];
      break;
   case GL_POST_COLOR_MATRIX_COLOR_TABLE_SGI:
      scale = ctx->Pixel.ColorTableScale[COLORTABLE_POSTCOLORMATRIX];
      bias  = ctx->Pixel.ColorTableBias[COLORTABLE_POSTCOLORMATRIX];
      break;
d696 1
a696 4
   if (pname == GL_COLOR_TABLE_SGI ||
       pname == GL_TEXTURE_COLOR_TABLE_SGI ||
       pname == GL_POST_CONVOLUTION_COLOR_TABLE_SGI ||
       pname == GL_POST_COLOR_MATRIX_COLOR_TABLE_SGI) {
a723 14
      case GL_COLOR_TABLE:
         table = &ctx->ColorTable[COLORTABLE_PRECONVOLUTION];
         if (pname == GL_COLOR_TABLE_SCALE_SGI) {
            COPY_4V(params, ctx->Pixel.ColorTableScale[COLORTABLE_PRECONVOLUTION]);
            return;
         }
         else if (pname == GL_COLOR_TABLE_BIAS_SGI) {
            COPY_4V(params, ctx->Pixel.ColorTableBias[COLORTABLE_PRECONVOLUTION]);
            return;
         }
         break;
      case GL_PROXY_COLOR_TABLE:
         table = &ctx->ProxyColorTable[COLORTABLE_PRECONVOLUTION];
         break;
a745 28
      case GL_POST_CONVOLUTION_COLOR_TABLE:
         table = &ctx->ColorTable[COLORTABLE_POSTCONVOLUTION];
         if (pname == GL_COLOR_TABLE_SCALE_SGI) {
            COPY_4V(params, ctx->Pixel.ColorTableScale[COLORTABLE_POSTCONVOLUTION]);
            return;
         }
         else if (pname == GL_COLOR_TABLE_BIAS_SGI) {
            COPY_4V(params, ctx->Pixel.ColorTableBias[COLORTABLE_POSTCONVOLUTION]);
            return;
         }
         break;
      case GL_PROXY_POST_CONVOLUTION_COLOR_TABLE:
         table = &ctx->ProxyColorTable[COLORTABLE_POSTCONVOLUTION];
         break;
      case GL_POST_COLOR_MATRIX_COLOR_TABLE:
         table = &ctx->ColorTable[COLORTABLE_POSTCOLORMATRIX];
         if (pname == GL_COLOR_TABLE_SCALE_SGI) {
            COPY_4V(params, ctx->Pixel.ColorTableScale[COLORTABLE_POSTCOLORMATRIX]);
            return;
         }
         else if (pname == GL_COLOR_TABLE_BIAS_SGI) {
            COPY_4V(params, ctx->Pixel.ColorTableBias[COLORTABLE_POSTCOLORMATRIX]);
            return;
         }
         break;
      case GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE:
         table = &ctx->ProxyColorTable[COLORTABLE_POSTCOLORMATRIX];
         break;
a808 22
      case GL_COLOR_TABLE:
         table = &ctx->ColorTable[COLORTABLE_PRECONVOLUTION];
         if (pname == GL_COLOR_TABLE_SCALE_SGI) {
            GLfloat *scale = ctx->Pixel.ColorTableScale[COLORTABLE_PRECONVOLUTION];
            params[0] = (GLint) scale[0];
            params[1] = (GLint) scale[1];
            params[2] = (GLint) scale[2];
            params[3] = (GLint) scale[3];
            return;
         }
         else if (pname == GL_COLOR_TABLE_BIAS_SGI) {
            GLfloat *bias = ctx->Pixel.ColorTableBias[COLORTABLE_PRECONVOLUTION];
            params[0] = (GLint) bias[0];
            params[1] = (GLint) bias[1];
            params[2] = (GLint) bias[2];
            params[3] = (GLint) bias[3];
            return;
         }
         break;
      case GL_PROXY_COLOR_TABLE:
         table = &ctx->ProxyColorTable[COLORTABLE_PRECONVOLUTION];
         break;
a836 44
      case GL_POST_CONVOLUTION_COLOR_TABLE:
         table = &ctx->ColorTable[COLORTABLE_POSTCONVOLUTION];
         if (pname == GL_COLOR_TABLE_SCALE_SGI) {
            GLfloat *scale = ctx->Pixel.ColorTableScale[COLORTABLE_POSTCONVOLUTION];
            params[0] = (GLint) scale[0];
            params[1] = (GLint) scale[1];
            params[2] = (GLint) scale[2];
            params[3] = (GLint) scale[3];
            return;
         }
         else if (pname == GL_COLOR_TABLE_BIAS_SGI) {
            GLfloat *bias = ctx->Pixel.ColorTableBias[COLORTABLE_POSTCONVOLUTION];
            params[0] = (GLint) bias[0];
            params[1] = (GLint) bias[1];
            params[2] = (GLint) bias[2];
            params[3] = (GLint) bias[3];
            return;
         }
         break;
      case GL_PROXY_POST_CONVOLUTION_COLOR_TABLE:
         table = &ctx->ProxyColorTable[COLORTABLE_POSTCONVOLUTION];
         break;
      case GL_POST_COLOR_MATRIX_COLOR_TABLE:
         table = &ctx->ColorTable[COLORTABLE_POSTCOLORMATRIX];
         if (pname == GL_COLOR_TABLE_SCALE_SGI) {
            GLfloat *scale = ctx->Pixel.ColorTableScale[COLORTABLE_POSTCOLORMATRIX];
            params[0] = (GLint) scale[0];
            params[0] = (GLint) scale[1];
            params[0] = (GLint) scale[2];
            params[0] = (GLint) scale[3];
            return;
         }
         else if (pname == GL_COLOR_TABLE_BIAS_SGI) {
            GLfloat *bias = ctx->Pixel.ColorTableScale[COLORTABLE_POSTCOLORMATRIX];
            params[0] = (GLint) bias[0];
            params[1] = (GLint) bias[1];
            params[2] = (GLint) bias[2];
            params[3] = (GLint) bias[3];
            return;
         }
         break;
      case GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE:
         table = &ctx->ProxyColorTable[COLORTABLE_POSTCOLORMATRIX];
         break;
a930 28
   }
}


/*
 * Initialize all colortables for a context.
 */
void
_mesa_init_colortables( GLcontext * ctx )
{
   GLuint i;
   for (i = 0; i < COLORTABLE_MAX; i++) {
      _mesa_init_colortable(&ctx->ColorTable[i]);
      _mesa_init_colortable(&ctx->ProxyColorTable[i]);
   }
}


/*
 * Free all colortable data for a context
 */
void
_mesa_free_colortables_data( GLcontext *ctx )
{
   GLuint i;
   for (i = 0; i < COLORTABLE_MAX; i++) {
      _mesa_free_colortable_data(&ctx->ColorTable[i]);
      _mesa_free_colortable_data(&ctx->ProxyColorTable[i]);
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d34 5
d187 6
a192 20
   if (ctx->Unpack.BufferObj->Name) {
      /* Get/unpack the color table data from a PBO */
      GLubyte *buf;
      if (!_mesa_validate_pbo_access(1, &ctx->Unpack, count, 1, 1,
                                     format, type, data)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glColor[Sub]Table(bad PBO access)");
         return;
      }
      buf = (GLubyte *) ctx->Driver.MapBuffer(ctx, GL_PIXEL_UNPACK_BUFFER_EXT,
                                              GL_READ_ONLY_ARB,
                                              ctx->Unpack.BufferObj);
      if (!buf) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glColor[Sub]Table(PBO mapped)");
         return;
      }
      data = ADD_POINTERS(buf, data);
   }

d273 1
a273 4
   if (ctx->Unpack.BufferObj->Name) {
      ctx->Driver.UnmapBuffer(ctx, GL_PIXEL_UNPACK_BUFFER_EXT,
                              ctx->Unpack.BufferObj);
   }
d286 1
a286 1
   struct gl_texture_unit *texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
d410 2
a411 2
         table->TableF = (GLfloat *) _mesa_malloc(comps * width * sizeof(GLfloat));
         table->TableUB = (GLubyte *) _mesa_malloc(comps * width * sizeof(GLubyte));
d451 1
a451 1
   struct gl_texture_unit *texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
d543 1
a543 1
void GLAPIENTRY
d550 4
a553 1
   /* Select buffer to read from */
d559 1
a559 1
void GLAPIENTRY
d566 4
d575 1
a575 1
void GLAPIENTRY
d580 1
a580 1
   struct gl_texture_unit *texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
d687 1
a687 1
      _mesa_memcpy(rgba, table->TableF, 4 * table->Size * sizeof(GLfloat));
d694 6
a699 20
   if (ctx->Pack.BufferObj->Name) {
      /* pack color table into PBO */
      GLubyte *buf;
      if (!_mesa_validate_pbo_access(1, &ctx->Pack, table->Size, 1, 1,
                                     format, type, data)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glGetColorTable(invalid PBO access)");
         return;
      }
      buf = (GLubyte *) ctx->Driver.MapBuffer(ctx, GL_PIXEL_PACK_BUFFER_EXT,
                                              GL_WRITE_ONLY_ARB,
                                              ctx->Pack.BufferObj);
      if (!buf) {
         /* buffer is already mapped - that's an error */
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glGetColorTable(PBO is mapped)");
         return;
      }
      data = ADD_POINTERS(buf, data);
   }
d704 1
a704 4
   if (ctx->Pack.BufferObj->Name) {
      ctx->Driver.UnmapBuffer(ctx, GL_PIXEL_PACK_BUFFER_EXT,
                              ctx->Pack.BufferObj);
   }
d709 1
a709 1
void GLAPIENTRY
d754 1
a754 1
void GLAPIENTRY
d777 1
a777 1
void GLAPIENTRY
d781 1
a781 1
   struct gl_texture_unit *texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
d904 1
a904 1
void GLAPIENTRY
d908 1
a908 1
   struct gl_texture_unit *texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
d1059 19
d1098 1
a1098 1
      _mesa_free(p->TableF);
d1102 1
a1102 1
      _mesa_free(p->TableUB);
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d386 1
a386 1
   if (width < 0 || (width != 0 && _mesa_bitcount(width) != 1)) {
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * Version:  6.5
d5 1
a5 1
 * Copyright (C) 1999-2005  Brian Paul   All Rights Reserved.
d33 1
d36 1
a36 1
/*
d96 1
a96 1
/*
d102 2
a103 20
   GLubyte sz;

   switch (table->Type) {
   case GL_UNSIGNED_BYTE:
      sz = 8 * sizeof(GLubyte);
      break;
   case GL_UNSIGNED_SHORT:
      sz = 8 * sizeof(GLushort);
      break;
   case GL_FLOAT:
      /* Don't actually return 32 here since that causes the conformance
       * tests to blow up.  Conform thinks the component is an integer,
       * not a float.
       */
      sz = 8;  /** 8 * sizeof(GLfloat); **/
      break;
   default:
      _mesa_problem(NULL, "bad color table type in set_component_sizes 0x%x", table->Type);
      return;
   }
d203 1
a203 1
   if (table->Type == GL_FLOAT) {
d219 1
a219 1
      tableF = (GLfloat *) table->Table;
d270 3
a272 2
   else {
      /* non-float (GLchan) */
d274 6
a279 7
      GLchan *dest = (GLchan *) table->Table + start * comps;
      _mesa_unpack_color_span_chan(ctx, count,         /* number of entries */
				   table->_BaseFormat, /* dest format */
				   dest,               /* dest address */
                                   format, type, data, /* src data */
				   &ctx->Unpack,
				   0);                 /* transfer ops */
d295 2
d303 1
a303 3
   GLfloat rScale = 1.0, gScale = 1.0, bScale = 1.0, aScale = 1.0;
   GLfloat rBias  = 0.0, gBias  = 0.0, bBias  = 0.0, aBias  = 0.0;
   GLenum tableType = CHAN_TYPE;
d305 1
a308 43
      case GL_TEXTURE_1D:
         texObj = texUnit->Current1D;
         table = &texObj->Palette;
         break;
      case GL_TEXTURE_2D:
         texObj = texUnit->Current2D;
         table = &texObj->Palette;
         break;
      case GL_TEXTURE_3D:
         texObj = texUnit->Current3D;
         table = &texObj->Palette;
         break;
      case GL_TEXTURE_CUBE_MAP_ARB:
         if (!ctx->Extensions.ARB_texture_cube_map) {
            _mesa_error(ctx, GL_INVALID_ENUM, "glColorTable(target)");
            return;
         }
         texObj = texUnit->CurrentCubeMap;
         table = &texObj->Palette;
         break;
      case GL_PROXY_TEXTURE_1D:
         texObj = ctx->Texture.Proxy1D;
         table = &texObj->Palette;
         proxy = GL_TRUE;
         break;
      case GL_PROXY_TEXTURE_2D:
         texObj = ctx->Texture.Proxy2D;
         table = &texObj->Palette;
         proxy = GL_TRUE;
         break;
      case GL_PROXY_TEXTURE_3D:
         texObj = ctx->Texture.Proxy3D;
         table = &texObj->Palette;
         proxy = GL_TRUE;
         break;
      case GL_PROXY_TEXTURE_CUBE_MAP_ARB:
         if (!ctx->Extensions.ARB_texture_cube_map) {
            _mesa_error(ctx, GL_INVALID_ENUM, "glColorTable(target)");
            return;
         }
         texObj = ctx->Texture.ProxyCubeMap;
         table = &texObj->Palette;
         break;
a310 1
	 tableType = GL_FLOAT;
d313 3
a315 10
         table = &ctx->ColorTable;
	 tableType = GL_FLOAT;
         rScale = ctx->Pixel.ColorTableScale[0];
         gScale = ctx->Pixel.ColorTableScale[1];
         bScale = ctx->Pixel.ColorTableScale[2];
         aScale = ctx->Pixel.ColorTableScale[3];
         rBias = ctx->Pixel.ColorTableBias[0];
         gBias = ctx->Pixel.ColorTableBias[1];
         bBias = ctx->Pixel.ColorTableBias[2];
         aBias = ctx->Pixel.ColorTableBias[3];
d318 1
a318 1
         table = &ctx->ProxyColorTable;
d327 2
a328 9
	 tableType = GL_FLOAT;
         rScale = ctx->Pixel.TextureColorTableScale[0];
         gScale = ctx->Pixel.TextureColorTableScale[1];
         bScale = ctx->Pixel.TextureColorTableScale[2];
         aScale = ctx->Pixel.TextureColorTableScale[3];
         rBias = ctx->Pixel.TextureColorTableBias[0];
         gBias = ctx->Pixel.TextureColorTableBias[1];
         bBias = ctx->Pixel.TextureColorTableBias[2];
         aBias = ctx->Pixel.TextureColorTableBias[3];
a335 1
	 tableType = GL_FLOAT;
d339 3
a341 10
         table = &ctx->PostConvolutionColorTable;
	 tableType = GL_FLOAT;
         rScale = ctx->Pixel.PCCTscale[0];
         gScale = ctx->Pixel.PCCTscale[1];
         bScale = ctx->Pixel.PCCTscale[2];
         aScale = ctx->Pixel.PCCTscale[3];
         rBias = ctx->Pixel.PCCTbias[0];
         gBias = ctx->Pixel.PCCTbias[1];
         bBias = ctx->Pixel.PCCTbias[2];
         aBias = ctx->Pixel.PCCTbias[3];
d344 1
a344 2
         table = &ctx->ProxyPostConvolutionColorTable;
	 tableType = GL_FLOAT;
d348 3
a350 10
         table = &ctx->PostColorMatrixColorTable;
	 tableType = GL_FLOAT;
         rScale = ctx->Pixel.PCMCTscale[0];
         gScale = ctx->Pixel.PCMCTscale[1];
         bScale = ctx->Pixel.PCMCTscale[2];
         aScale = ctx->Pixel.PCMCTscale[3];
         rBias = ctx->Pixel.PCMCTbias[0];
         gBias = ctx->Pixel.PCMCTbias[1];
         bBias = ctx->Pixel.PCMCTbias[2];
         aBias = ctx->Pixel.PCMCTbias[3];
d353 1
a353 2
         table = &ctx->ProxyPostColorMatrixColorTable;
	 tableType = GL_FLOAT;
d357 13
a369 2
         _mesa_error(ctx, GL_INVALID_ENUM, "glColorTable(target)");
         return;
a413 1
   table->Type = (tableType == GL_FLOAT) ? GL_FLOAT : CHAN_TYPE;
d419 1
a419 5
      /* free old table, if any */
      if (table->Table) {
         FREE(table->Table);
         table->Table = NULL;
      }
d422 2
a423 6
         if (table->Type == GL_FLOAT) {
	    table->Table = MALLOC(comps * width * sizeof(GLfloat));
	 }
	 else {
            table->Table = MALLOC(comps * width * sizeof(GLchan));
	 }
d425 1
a425 1
	 if (!table->Table) {
d433 4
a436 4
				  rScale, rBias,
				  gScale, gBias,
				  bScale, bBias,
				  aScale, aBias);
d460 2
d466 2
a467 2
   GLfloat rScale = 1.0, gScale = 1.0, bScale = 1.0, aScale = 1.0;
   GLfloat rBias  = 0.0, gBias  = 0.0, bBias  = 0.0, aBias  = 0.0;
a470 20
      case GL_TEXTURE_1D:
         texObj = texUnit->Current1D;
         table = &texObj->Palette;
         break;
      case GL_TEXTURE_2D:
         texObj = texUnit->Current2D;
         table = &texObj->Palette;
         break;
      case GL_TEXTURE_3D:
         texObj = texUnit->Current3D;
         table = &texObj->Palette;
         break;
      case GL_TEXTURE_CUBE_MAP_ARB:
         if (!ctx->Extensions.ARB_texture_cube_map) {
            _mesa_error(ctx, GL_INVALID_ENUM, "glColorSubTable(target)");
            return;
         }
         texObj = texUnit->CurrentCubeMap;
         table = &texObj->Palette;
         break;
d475 3
a477 9
         table = &ctx->ColorTable;
         rScale = ctx->Pixel.ColorTableScale[0];
         gScale = ctx->Pixel.ColorTableScale[1];
         bScale = ctx->Pixel.ColorTableScale[2];
         aScale = ctx->Pixel.ColorTableScale[3];
         rBias = ctx->Pixel.ColorTableBias[0];
         gBias = ctx->Pixel.ColorTableBias[1];
         bBias = ctx->Pixel.ColorTableBias[2];
         aBias = ctx->Pixel.ColorTableBias[3];
d485 2
a486 8
         rScale = ctx->Pixel.TextureColorTableScale[0];
         gScale = ctx->Pixel.TextureColorTableScale[1];
         bScale = ctx->Pixel.TextureColorTableScale[2];
         aScale = ctx->Pixel.TextureColorTableScale[3];
         rBias = ctx->Pixel.TextureColorTableBias[0];
         gBias = ctx->Pixel.TextureColorTableBias[1];
         bBias = ctx->Pixel.TextureColorTableBias[2];
         aBias = ctx->Pixel.TextureColorTableBias[3];
d489 3
a491 9
         table = &ctx->PostConvolutionColorTable;
         rScale = ctx->Pixel.PCCTscale[0];
         gScale = ctx->Pixel.PCCTscale[1];
         bScale = ctx->Pixel.PCCTscale[2];
         aScale = ctx->Pixel.PCCTscale[3];
         rBias = ctx->Pixel.PCCTbias[0];
         gBias = ctx->Pixel.PCCTbias[1];
         bBias = ctx->Pixel.PCCTbias[2];
         aBias = ctx->Pixel.PCCTbias[3];
d494 3
a496 9
         table = &ctx->PostColorMatrixColorTable;
         rScale = ctx->Pixel.PCMCTscale[0];
         gScale = ctx->Pixel.PCMCTscale[1];
         bScale = ctx->Pixel.PCMCTscale[2];
         aScale = ctx->Pixel.PCMCTscale[3];
         rBias = ctx->Pixel.PCMCTbias[0];
         gBias = ctx->Pixel.PCMCTbias[1];
         bBias = ctx->Pixel.PCMCTbias[2];
         aBias = ctx->Pixel.PCMCTbias[3];
d499 9
a507 2
         _mesa_error(ctx, GL_INVALID_ENUM, "glColorSubTable(target)");
         return;
d531 2
a532 2
   if (!table->Table) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glColorSubTable");
d538 4
a541 4
			    rScale, rBias,
			    gScale, gBias,
			    bScale, bBias,
			    aScale, aBias);
d587 1
a587 1
   GLchan rgba[MAX_COLOR_TABLE_SIZE][4];
a594 16
      case GL_TEXTURE_1D:
         table = &texUnit->Current1D->Palette;
         break;
      case GL_TEXTURE_2D:
         table = &texUnit->Current2D->Palette;
         break;
      case GL_TEXTURE_3D:
         table = &texUnit->Current3D->Palette;
         break;
      case GL_TEXTURE_CUBE_MAP_ARB:
         if (!ctx->Extensions.ARB_texture_cube_map) {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetColorTable(target)");
            return;
         }
         table = &texUnit->CurrentCubeMap->Palette;
         break;
d599 1
a599 1
         table = &ctx->ColorTable;
d609 1
a609 1
         table = &ctx->PostConvolutionColorTable;
d612 1
a612 1
         table = &ctx->PostColorMatrixColorTable;
d615 12
a626 2
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetColorTable(target)");
         return;
d631 4
d636 8
a643 14
      case GL_ALPHA:
         if (table->Type == GL_FLOAT) {
            const GLfloat *tableF = (const GLfloat *) table->Table;
            GLuint i;
            for (i = 0; i < table->Size; i++) {
               rgba[i][RCOMP] = 0;
               rgba[i][GCOMP] = 0;
               rgba[i][BCOMP] = 0;
#if CHAN_BITS==32
               rgba[i][ACOMP] = tableF[i];
#else
               rgba[i][ACOMP] = IROUND_POS(tableF[i] * CHAN_MAXF);
#endif
            }
d645 10
a654 9
         else {
            const GLchan *tableUB = (const GLchan *) table->Table;
            GLuint i;
            for (i = 0; i < table->Size; i++) {
               rgba[i][RCOMP] = 0;
               rgba[i][GCOMP] = 0;
               rgba[i][BCOMP] = 0;
               rgba[i][ACOMP] = tableUB[i];
            }
d656 10
a665 18
         break;
      case GL_LUMINANCE:
         if (table->Type == GL_FLOAT) {
            const GLfloat *tableF = (const GLfloat *) table->Table;
            GLuint i;
            for (i = 0; i < table->Size; i++) {
#if CHAN_BITS==32
               rgba[i][RCOMP] =
               rgba[i][GCOMP] =
               rgba[i][BCOMP] = tableF[i];
               rgba[i][ACOMP] = CHAN_MAX;
#else
               rgba[i][RCOMP] =
               rgba[i][GCOMP] =
               rgba[i][BCOMP] = IROUND_POS(tableF[i] * CHAN_MAXF);
               rgba[i][ACOMP] = CHAN_MAX;
#endif
            }
d667 10
a676 9
         else {
            const GLchan *tableUB = (const GLchan *) table->Table;
            GLuint i;
            for (i = 0; i < table->Size; i++) {
               rgba[i][RCOMP] =
               rgba[i][GCOMP] =
               rgba[i][BCOMP] = tableUB[i];
               rgba[i][ACOMP] = CHAN_MAX;
            }
d678 10
a687 18
         break;
      case GL_LUMINANCE_ALPHA:
         if (table->Type == GL_FLOAT) {
            const GLfloat *tableF = (const GLfloat *) table->Table;
            GLuint i;
            for (i = 0; i < table->Size; i++) {
#if CHAN_BITS==32
               rgba[i][RCOMP] =
               rgba[i][GCOMP] =
               rgba[i][BCOMP] = tableF[i*2+0];
               rgba[i][ACOMP] = tableF[i*2+1];
#else
               rgba[i][RCOMP] =
               rgba[i][GCOMP] =
               rgba[i][BCOMP] = IROUND_POS(tableF[i*2+0] * CHAN_MAXF);
               rgba[i][ACOMP] = IROUND_POS(tableF[i*2+1] * CHAN_MAXF);
#endif
            }
d689 8
a696 98
         else {
            const GLchan *tableUB = (const GLchan *) table->Table;
            GLuint i;
            for (i = 0; i < table->Size; i++) {
               rgba[i][RCOMP] =
               rgba[i][GCOMP] =
               rgba[i][BCOMP] = tableUB[i*2+0];
               rgba[i][ACOMP] = tableUB[i*2+1];
            }
         }
         break;
      case GL_INTENSITY:
         if (table->Type == GL_FLOAT) {
            const GLfloat *tableF = (const GLfloat *) table->Table;
            GLuint i;
            for (i = 0; i < table->Size; i++) {
#if CHAN_BITS==32
               rgba[i][RCOMP] =
               rgba[i][GCOMP] =
               rgba[i][BCOMP] =
               rgba[i][ACOMP] = tableF[i];
#else
               rgba[i][RCOMP] =
               rgba[i][GCOMP] =
               rgba[i][BCOMP] =
               rgba[i][ACOMP] = IROUND_POS(tableF[i] * CHAN_MAXF);
#endif
            }
         }
         else {
            const GLchan *tableUB = (const GLchan *) table->Table;
            GLuint i;
            for (i = 0; i < table->Size; i++) {
               rgba[i][RCOMP] =
               rgba[i][GCOMP] =
               rgba[i][BCOMP] =
               rgba[i][ACOMP] = tableUB[i];
            }
         }
         break;
      case GL_RGB:
         if (table->Type == GL_FLOAT) {
            const GLfloat *tableF = (const GLfloat *) table->Table;
            GLuint i;
            for (i = 0; i < table->Size; i++) {
#if CHAN_BITS==32
               rgba[i][RCOMP] = tableF[i*3+0];
               rgba[i][GCOMP] = tableF[i*3+1];
               rgba[i][BCOMP] = tableF[i*3+2];
               rgba[i][ACOMP] = CHAN_MAX;
#else
               rgba[i][RCOMP] = IROUND_POS(tableF[i*3+0] * CHAN_MAXF);
               rgba[i][GCOMP] = IROUND_POS(tableF[i*3+1] * CHAN_MAXF);
               rgba[i][BCOMP] = IROUND_POS(tableF[i*3+2] * CHAN_MAXF);
               rgba[i][ACOMP] = CHAN_MAX;
#endif
            }
         }
         else {
            const GLchan *tableUB = (const GLchan *) table->Table;
            GLuint i;
            for (i = 0; i < table->Size; i++) {
               rgba[i][RCOMP] = tableUB[i*3+0];
               rgba[i][GCOMP] = tableUB[i*3+1];
               rgba[i][BCOMP] = tableUB[i*3+2];
               rgba[i][ACOMP] = CHAN_MAX;
            }
         }
         break;
      case GL_RGBA:
         if (table->Type == GL_FLOAT) {
            const GLfloat *tableF = (const GLfloat *) table->Table;
#if CHAN_BITS==32
            _mesa_memcpy(rgba, tableF, 4 * table->Size * sizeof(GLfloat));
#else
            GLuint i;
            for (i = 0; i < table->Size; i++) {
               rgba[i][RCOMP] = IROUND_POS(tableF[i*4+0] * CHAN_MAXF);
               rgba[i][GCOMP] = IROUND_POS(tableF[i*4+1] * CHAN_MAXF);
               rgba[i][BCOMP] = IROUND_POS(tableF[i*4+2] * CHAN_MAXF);
               rgba[i][ACOMP] = IROUND_POS(tableF[i*4+3] * CHAN_MAXF);
            }
#endif
         }
         else {
            const GLchan *tableUB = (const GLchan *) table->Table;
            GLuint i;
            for (i = 0; i < table->Size; i++) {
               rgba[i][RCOMP] = tableUB[i*4+0];
               rgba[i][GCOMP] = tableUB[i*4+1];
               rgba[i][BCOMP] = tableUB[i*4+2];
               rgba[i][ACOMP] = tableUB[i*4+3];
            }
         }
         break;
      default:
         _mesa_problem(ctx, "bad table format in glGetColorTable");
         return;
d720 2
a721 2
   _mesa_pack_rgba_span_chan(ctx, table->Size, (const GLchan (*)[4]) rgba,
                        format, type, data, &ctx->Pack, GL_FALSE);
d734 1
d739 30
a768 79
      case GL_COLOR_TABLE_SGI:
         if (pname == GL_COLOR_TABLE_SCALE_SGI) {
            ctx->Pixel.ColorTableScale[0] = params[0];
            ctx->Pixel.ColorTableScale[1] = params[1];
            ctx->Pixel.ColorTableScale[2] = params[2];
            ctx->Pixel.ColorTableScale[3] = params[3];
         }
         else if (pname == GL_COLOR_TABLE_BIAS_SGI) {
            ctx->Pixel.ColorTableBias[0] = params[0];
            ctx->Pixel.ColorTableBias[1] = params[1];
            ctx->Pixel.ColorTableBias[2] = params[2];
            ctx->Pixel.ColorTableBias[3] = params[3];
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM, "glColorTableParameterfv(pname)");
            return;
         }
         break;
      case GL_TEXTURE_COLOR_TABLE_SGI:
         if (!ctx->Extensions.SGI_texture_color_table) {
            _mesa_error(ctx, GL_INVALID_ENUM, "glColorTableParameter(target)");
            return;
         }
         if (pname == GL_COLOR_TABLE_SCALE_SGI) {
            ctx->Pixel.TextureColorTableScale[0] = params[0];
            ctx->Pixel.TextureColorTableScale[1] = params[1];
            ctx->Pixel.TextureColorTableScale[2] = params[2];
            ctx->Pixel.TextureColorTableScale[3] = params[3];
         }
         else if (pname == GL_COLOR_TABLE_BIAS_SGI) {
            ctx->Pixel.TextureColorTableBias[0] = params[0];
            ctx->Pixel.TextureColorTableBias[1] = params[1];
            ctx->Pixel.TextureColorTableBias[2] = params[2];
            ctx->Pixel.TextureColorTableBias[3] = params[3];
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM, "glColorTableParameterfv(pname)");
            return;
         }
         break;
      case GL_POST_CONVOLUTION_COLOR_TABLE_SGI:
         if (pname == GL_COLOR_TABLE_SCALE_SGI) {
            ctx->Pixel.PCCTscale[0] = params[0];
            ctx->Pixel.PCCTscale[1] = params[1];
            ctx->Pixel.PCCTscale[2] = params[2];
            ctx->Pixel.PCCTscale[3] = params[3];
         }
         else if (pname == GL_COLOR_TABLE_BIAS_SGI) {
            ctx->Pixel.PCCTbias[0] = params[0];
            ctx->Pixel.PCCTbias[1] = params[1];
            ctx->Pixel.PCCTbias[2] = params[2];
            ctx->Pixel.PCCTbias[3] = params[3];
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM, "glColorTableParameterfv(pname)");
            return;
         }
         break;
      case GL_POST_COLOR_MATRIX_COLOR_TABLE_SGI:
         if (pname == GL_COLOR_TABLE_SCALE_SGI) {
            ctx->Pixel.PCMCTscale[0] = params[0];
            ctx->Pixel.PCMCTscale[1] = params[1];
            ctx->Pixel.PCMCTscale[2] = params[2];
            ctx->Pixel.PCMCTscale[3] = params[3];
         }
         else if (pname == GL_COLOR_TABLE_BIAS_SGI) {
            ctx->Pixel.PCMCTbias[0] = params[0];
            ctx->Pixel.PCMCTbias[1] = params[1];
            ctx->Pixel.PCMCTbias[2] = params[2];
            ctx->Pixel.PCMCTbias[3] = params[3];
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM, "glColorTableParameterfv(pname)");
            return;
         }
         break;
      default:
         _mesa_error(ctx, GL_INVALID_ENUM, "glColorTableParameter(target)");
         return;
a807 34
      case GL_TEXTURE_1D:
         table = &texUnit->Current1D->Palette;
         break;
      case GL_TEXTURE_2D:
         table = &texUnit->Current2D->Palette;
         break;
      case GL_TEXTURE_3D:
         table = &texUnit->Current3D->Palette;
         break;
      case GL_TEXTURE_CUBE_MAP_ARB:
         if (!ctx->Extensions.ARB_texture_cube_map) {
            _mesa_error(ctx, GL_INVALID_ENUM,
                        "glGetColorTableParameterfv(target)");
            return;
         }
         table = &texUnit->CurrentCubeMap->Palette;
         break;
      case GL_PROXY_TEXTURE_1D:
         table = &ctx->Texture.Proxy1D->Palette;
         break;
      case GL_PROXY_TEXTURE_2D:
         table = &ctx->Texture.Proxy2D->Palette;
         break;
      case GL_PROXY_TEXTURE_3D:
         table = &ctx->Texture.Proxy3D->Palette;
         break;
      case GL_PROXY_TEXTURE_CUBE_MAP_ARB:
         if (!ctx->Extensions.ARB_texture_cube_map) {
            _mesa_error(ctx, GL_INVALID_ENUM,
                        "glGetColorTableParameterfv(target)");
            return;
         }
         table = &ctx->Texture.ProxyCubeMap->Palette;
         break;
d812 1
a812 1
         table = &ctx->ColorTable;
d814 1
a814 4
            params[0] = ctx->Pixel.ColorTableScale[0];
            params[1] = ctx->Pixel.ColorTableScale[1];
            params[2] = ctx->Pixel.ColorTableScale[2];
            params[3] = ctx->Pixel.ColorTableScale[3];
d818 1
a818 4
            params[0] = ctx->Pixel.ColorTableBias[0];
            params[1] = ctx->Pixel.ColorTableBias[1];
            params[2] = ctx->Pixel.ColorTableBias[2];
            params[3] = ctx->Pixel.ColorTableBias[3];
d823 1
a823 1
         table = &ctx->ProxyColorTable;
d832 1
a832 4
            params[0] = ctx->Pixel.TextureColorTableScale[0];
            params[1] = ctx->Pixel.TextureColorTableScale[1];
            params[2] = ctx->Pixel.TextureColorTableScale[2];
            params[3] = ctx->Pixel.TextureColorTableScale[3];
d836 1
a836 4
            params[0] = ctx->Pixel.TextureColorTableBias[0];
            params[1] = ctx->Pixel.TextureColorTableBias[1];
            params[2] = ctx->Pixel.TextureColorTableBias[2];
            params[3] = ctx->Pixel.TextureColorTableBias[3];
d848 1
a848 1
         table = &ctx->PostConvolutionColorTable;
d850 1
a850 4
            params[0] = ctx->Pixel.PCCTscale[0];
            params[1] = ctx->Pixel.PCCTscale[1];
            params[2] = ctx->Pixel.PCCTscale[2];
            params[3] = ctx->Pixel.PCCTscale[3];
d854 1
a854 4
            params[0] = ctx->Pixel.PCCTbias[0];
            params[1] = ctx->Pixel.PCCTbias[1];
            params[2] = ctx->Pixel.PCCTbias[2];
            params[3] = ctx->Pixel.PCCTbias[3];
d859 1
a859 1
         table = &ctx->ProxyPostConvolutionColorTable;
d862 1
a862 1
         table = &ctx->PostColorMatrixColorTable;
d864 1
a864 4
            params[0] = ctx->Pixel.PCMCTscale[0];
            params[1] = ctx->Pixel.PCMCTscale[1];
            params[2] = ctx->Pixel.PCMCTscale[2];
            params[3] = ctx->Pixel.PCMCTscale[3];
d868 1
a868 4
            params[0] = ctx->Pixel.PCMCTbias[0];
            params[1] = ctx->Pixel.PCMCTbias[1];
            params[2] = ctx->Pixel.PCMCTbias[2];
            params[3] = ctx->Pixel.PCMCTbias[3];
d873 1
a873 1
         table = &ctx->ProxyPostColorMatrixColorTable;
d876 13
a888 2
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetColorTableParameterfv(target)");
         return;
a934 34
      case GL_TEXTURE_1D:
         table = &texUnit->Current1D->Palette;
         break;
      case GL_TEXTURE_2D:
         table = &texUnit->Current2D->Palette;
         break;
      case GL_TEXTURE_3D:
         table = &texUnit->Current3D->Palette;
         break;
      case GL_TEXTURE_CUBE_MAP_ARB:
         if (!ctx->Extensions.ARB_texture_cube_map) {
            _mesa_error(ctx, GL_INVALID_ENUM,
                        "glGetColorTableParameteriv(target)");
            return;
         }
         table = &texUnit->CurrentCubeMap->Palette;
         break;
      case GL_PROXY_TEXTURE_1D:
         table = &ctx->Texture.Proxy1D->Palette;
         break;
      case GL_PROXY_TEXTURE_2D:
         table = &ctx->Texture.Proxy2D->Palette;
         break;
      case GL_PROXY_TEXTURE_3D:
         table = &ctx->Texture.Proxy3D->Palette;
         break;
      case GL_PROXY_TEXTURE_CUBE_MAP_ARB:
         if (!ctx->Extensions.ARB_texture_cube_map) {
            _mesa_error(ctx, GL_INVALID_ENUM,
                        "glGetColorTableParameteriv(target)");
            return;
         }
         table = &ctx->Texture.ProxyCubeMap->Palette;
         break;
d939 1
a939 1
         table = &ctx->ColorTable;
d941 5
a945 4
            params[0] = (GLint) ctx->Pixel.ColorTableScale[0];
            params[1] = (GLint) ctx->Pixel.ColorTableScale[1];
            params[2] = (GLint) ctx->Pixel.ColorTableScale[2];
            params[3] = (GLint) ctx->Pixel.ColorTableScale[3];
d949 5
a953 4
            params[0] = (GLint) ctx->Pixel.ColorTableBias[0];
            params[1] = (GLint) ctx->Pixel.ColorTableBias[1];
            params[2] = (GLint) ctx->Pixel.ColorTableBias[2];
            params[3] = (GLint) ctx->Pixel.ColorTableBias[3];
d958 1
a958 1
         table = &ctx->ProxyColorTable;
d989 1
a989 1
         table = &ctx->PostConvolutionColorTable;
d991 5
a995 4
            params[0] = (GLint) ctx->Pixel.PCCTscale[0];
            params[1] = (GLint) ctx->Pixel.PCCTscale[1];
            params[2] = (GLint) ctx->Pixel.PCCTscale[2];
            params[3] = (GLint) ctx->Pixel.PCCTscale[3];
d999 5
a1003 4
            params[0] = (GLint) ctx->Pixel.PCCTbias[0];
            params[1] = (GLint) ctx->Pixel.PCCTbias[1];
            params[2] = (GLint) ctx->Pixel.PCCTbias[2];
            params[3] = (GLint) ctx->Pixel.PCCTbias[3];
d1008 1
a1008 1
         table = &ctx->ProxyPostConvolutionColorTable;
d1011 1
a1011 1
         table = &ctx->PostColorMatrixColorTable;
d1013 5
a1017 4
            params[0] = (GLint) ctx->Pixel.PCMCTscale[0];
            params[1] = (GLint) ctx->Pixel.PCMCTscale[1];
            params[2] = (GLint) ctx->Pixel.PCMCTscale[2];
            params[3] = (GLint) ctx->Pixel.PCMCTscale[3];
d1021 5
a1025 4
            params[0] = (GLint) ctx->Pixel.PCMCTbias[0];
            params[1] = (GLint) ctx->Pixel.PCMCTbias[1];
            params[2] = (GLint) ctx->Pixel.PCMCTbias[2];
            params[3] = (GLint) ctx->Pixel.PCMCTbias[3];
d1030 1
a1030 1
         table = &ctx->ProxyPostColorMatrixColorTable;
d1033 13
a1045 2
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetColorTableParameteriv(target)");
         return;
d1089 2
a1090 2
   p->Type = CHAN_TYPE;
   p->Table = NULL;
d1100 7
a1106 3
   if (p->Table) {
      FREE(p->Table);
      p->Table = NULL;
d1114 2
a1115 1
void _mesa_init_colortables( GLcontext * ctx )
d1117 5
a1121 7
   /* Color tables */
   _mesa_init_colortable(&ctx->ColorTable);
   _mesa_init_colortable(&ctx->ProxyColorTable);
   _mesa_init_colortable(&ctx->PostConvolutionColorTable);
   _mesa_init_colortable(&ctx->ProxyPostConvolutionColorTable);
   _mesa_init_colortable(&ctx->PostColorMatrixColorTable);
   _mesa_init_colortable(&ctx->ProxyPostColorMatrixColorTable);
d1128 2
a1129 1
void _mesa_free_colortables_data( GLcontext *ctx )
d1131 5
a1135 6
   _mesa_free_colortable_data(&ctx->ColorTable);
   _mesa_free_colortable_data(&ctx->ProxyColorTable);
   _mesa_free_colortable_data(&ctx->PostConvolutionColorTable);
   _mesa_free_colortable_data(&ctx->ProxyPostConvolutionColorTable);
   _mesa_free_colortable_data(&ctx->PostColorMatrixColorTable);
   _mesa_free_colortable_data(&ctx->ProxyPostColorMatrixColorTable);
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d3 1
a3 1
 * Version:  6.5.2
d5 1
a5 1
 * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
d35 1
a35 1
/**
d95 1
a95 1
/**
d101 20
a120 2
   /* assuming the ubyte table */
   const GLubyte sz = 8;
d220 1
a220 1
   {
d236 1
a236 1
      tableF = table->TableF;
d287 2
a288 3

   /* update the ubyte table */
   {
d290 7
a296 6
      const GLfloat *tableF = table->TableF + start * comps;
      GLubyte *tableUB = table->TableUB + start * comps;
      GLint i;
      for (i = 0; i < count * comps; i++) {
         CLAMPED_FLOAT_TO_UBYTE(tableUB[i], tableF[i]);
      }
d320 1
d370 1
d374 1
d394 1
d410 1
d415 1
d427 1
d432 1
d444 1
d494 1
d500 5
a504 1
      _mesa_free_colortable_data(table);
d507 6
a512 2
         table->TableF = _mesa_malloc(comps * width * sizeof(GLfloat));
         table->TableUB = _mesa_malloc(comps * width * sizeof(GLubyte));
d514 1
a514 1
	 if (!table->TableF || !table->TableUB) {
d655 2
a656 2
   if (!table->TableF || !table->TableUB) {
      /* a GL_OUT_OF_MEMORY error would have been recorded previously */
d711 1
a711 1
   GLfloat rgba[MAX_COLOR_TABLE_SIZE][4];
d762 101
a862 8
   case GL_ALPHA:
      {
         GLuint i;
         for (i = 0; i < table->Size; i++) {
            rgba[i][RCOMP] = 0;
            rgba[i][GCOMP] = 0;
            rgba[i][BCOMP] = 0;
            rgba[i][ACOMP] = table->TableF[i];
d864 28
a891 10
      }
      break;
   case GL_LUMINANCE:
      {
         GLuint i;
         for (i = 0; i < table->Size; i++) {
            rgba[i][RCOMP] =
            rgba[i][GCOMP] =
            rgba[i][BCOMP] = table->TableF[i];
            rgba[i][ACOMP] = 1.0F;
d893 9
a901 10
      }
      break;
   case GL_LUMINANCE_ALPHA:
      {
         GLuint i;
         for (i = 0; i < table->Size; i++) {
            rgba[i][RCOMP] =
            rgba[i][GCOMP] =
            rgba[i][BCOMP] = table->TableF[i*2+0];
            rgba[i][ACOMP] = table->TableF[i*2+1];
d903 15
a917 10
      }
      break;
   case GL_INTENSITY:
      {
         GLuint i;
         for (i = 0; i < table->Size; i++) {
            rgba[i][RCOMP] =
            rgba[i][GCOMP] =
            rgba[i][BCOMP] =
            rgba[i][ACOMP] = table->TableF[i];
d919 9
a927 10
      }
      break;
   case GL_RGB:
      {
         GLuint i;
         for (i = 0; i < table->Size; i++) {
            rgba[i][RCOMP] = table->TableF[i*3+0];
            rgba[i][GCOMP] = table->TableF[i*3+1];
            rgba[i][BCOMP] = table->TableF[i*3+2];
            rgba[i][ACOMP] = 1.0F;
d929 4
a932 8
      }
      break;
   case GL_RGBA:
      _mesa_memcpy(rgba, table->TableF, 4 * table->Size * sizeof(GLfloat));
      break;
   default:
      _mesa_problem(ctx, "bad table format in glGetColorTable");
      return;
d956 2
a957 2
   _mesa_pack_rgba_span_float(ctx, table->Size, rgba,
                              format, type, data, &ctx->Pack, 0x0);
d1437 2
a1438 2
   p->TableF = NULL;
   p->TableUB = NULL;
d1448 3
a1450 7
   if (p->TableF) {
      _mesa_free(p->TableF);
      p->TableF = NULL;
   }
   if (p->TableUB) {
      _mesa_free(p->TableUB);
      p->TableUB = NULL;
d1458 1
a1458 2
void
_mesa_init_colortables( GLcontext * ctx )
d1473 1
a1473 2
void
_mesa_free_colortables_data( GLcontext *ctx )
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d3 1
a3 1
 * Version:  6.5.3
d5 1
a5 1
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
a293 2
   static const GLfloat one[4] = { 1.0, 1.0, 1.0, 1.0 };
   static const GLfloat zero[4] = { 0.0, 0.0, 0.0, 0.0 };
d300 2
a301 1
   const GLfloat *scale = one, *bias = zero;
a302 1

d353 9
a361 3
         table = &ctx->ColorTable[COLORTABLE_PRECONVOLUTION];
         scale = ctx->Pixel.ColorTableScale[COLORTABLE_PRECONVOLUTION];
         bias = ctx->Pixel.ColorTableBias[COLORTABLE_PRECONVOLUTION];
d364 1
a364 1
         table = &ctx->ProxyColorTable[COLORTABLE_PRECONVOLUTION];
d373 8
a380 2
         scale = ctx->Pixel.TextureColorTableScale;
         bias = ctx->Pixel.TextureColorTableBias;
d391 9
a399 3
         table = &ctx->ColorTable[COLORTABLE_POSTCONVOLUTION];
         scale = ctx->Pixel.ColorTableScale[COLORTABLE_POSTCONVOLUTION];
         bias = ctx->Pixel.ColorTableBias[COLORTABLE_POSTCONVOLUTION];
d402 1
a402 1
         table = &ctx->ProxyColorTable[COLORTABLE_POSTCONVOLUTION];
d406 9
a414 3
         table = &ctx->ColorTable[COLORTABLE_POSTCOLORMATRIX];
         scale = ctx->Pixel.ColorTableScale[COLORTABLE_POSTCOLORMATRIX];
         bias = ctx->Pixel.ColorTableBias[COLORTABLE_POSTCOLORMATRIX];
d417 1
a417 1
         table = &ctx->ProxyColorTable[COLORTABLE_POSTCOLORMATRIX];
d475 2
a476 2
         table->TableF = (GLfloat *) _mesa_malloc(comps * width * sizeof(GLfloat));
         table->TableUB = (GLubyte *) _mesa_malloc(comps * width * sizeof(GLubyte));
d486 4
a489 4
				  scale[0], bias[0],
				  scale[1], bias[1],
				  scale[2], bias[2],
				  scale[3], bias[3]);
a512 2
   static const GLfloat one[4] = { 1.0, 1.0, 1.0, 1.0 };
   static const GLfloat zero[4] = { 0.0, 0.0, 0.0, 0.0 };
d517 2
a518 2
   const GLfloat *scale = one, *bias = zero;

d546 9
a554 3
         table = &ctx->ColorTable[COLORTABLE_PRECONVOLUTION];
         scale = ctx->Pixel.ColorTableScale[COLORTABLE_PRECONVOLUTION];
         bias = ctx->Pixel.ColorTableBias[COLORTABLE_PRECONVOLUTION];
d562 8
a569 2
         scale = ctx->Pixel.TextureColorTableScale;
         bias = ctx->Pixel.TextureColorTableBias;
d572 9
a580 3
         table = &ctx->ColorTable[COLORTABLE_POSTCONVOLUTION];
         scale = ctx->Pixel.ColorTableScale[COLORTABLE_POSTCONVOLUTION];
         bias = ctx->Pixel.ColorTableBias[COLORTABLE_POSTCONVOLUTION];
d583 9
a591 3
         table = &ctx->ColorTable[COLORTABLE_POSTCOLORMATRIX];
         scale = ctx->Pixel.ColorTableScale[COLORTABLE_POSTCOLORMATRIX];
         bias = ctx->Pixel.ColorTableBias[COLORTABLE_POSTCOLORMATRIX];
d626 4
a629 4
                            scale[0], bias[0],
                            scale[1], bias[1],
                            scale[2], bias[2],
                            scale[3], bias[3]);
d703 1
a703 1
         table = &ctx->ColorTable[COLORTABLE_PRECONVOLUTION];
d713 1
a713 1
         table = &ctx->ColorTable[COLORTABLE_POSTCONVOLUTION];
d716 1
a716 1
         table = &ctx->ColorTable[COLORTABLE_POSTCOLORMATRIX];
a724 4
   if (table->Size <= 0) {
      return;
   }

d830 4
a833 1
            COPY_4V(ctx->Pixel.ColorTableScale[COLORTABLE_PRECONVOLUTION], params);
d836 4
a839 1
            COPY_4V(ctx->Pixel.ColorTableBias[COLORTABLE_PRECONVOLUTION], params);
d852 4
a855 1
            COPY_4V(ctx->Pixel.TextureColorTableScale, params);
d858 4
a861 1
            COPY_4V(ctx->Pixel.TextureColorTableBias, params);
d870 4
a873 1
            COPY_4V(ctx->Pixel.ColorTableScale[COLORTABLE_POSTCONVOLUTION], params);
d876 4
a879 1
            COPY_4V(ctx->Pixel.ColorTableBias[COLORTABLE_POSTCONVOLUTION], params);
d888 4
a891 1
            COPY_4V(ctx->Pixel.ColorTableScale[COLORTABLE_POSTCOLORMATRIX], params);
d894 4
a897 1
            COPY_4V(ctx->Pixel.ColorTableBias[COLORTABLE_POSTCOLORMATRIX], params);
d984 1
a984 1
         table = &ctx->ColorTable[COLORTABLE_PRECONVOLUTION];
d986 4
a989 1
            COPY_4V(params, ctx->Pixel.ColorTableScale[COLORTABLE_PRECONVOLUTION]);
d993 4
a996 1
            COPY_4V(params, ctx->Pixel.ColorTableBias[COLORTABLE_PRECONVOLUTION]);
d1001 1
a1001 1
         table = &ctx->ProxyColorTable[COLORTABLE_PRECONVOLUTION];
d1010 4
a1013 1
            COPY_4V(params, ctx->Pixel.TextureColorTableScale);
d1017 4
a1020 1
            COPY_4V(params, ctx->Pixel.TextureColorTableBias);
d1032 1
a1032 1
         table = &ctx->ColorTable[COLORTABLE_POSTCONVOLUTION];
d1034 4
a1037 1
            COPY_4V(params, ctx->Pixel.ColorTableScale[COLORTABLE_POSTCONVOLUTION]);
d1041 4
a1044 1
            COPY_4V(params, ctx->Pixel.ColorTableBias[COLORTABLE_POSTCONVOLUTION]);
d1049 1
a1049 1
         table = &ctx->ProxyColorTable[COLORTABLE_POSTCONVOLUTION];
d1052 1
a1052 1
         table = &ctx->ColorTable[COLORTABLE_POSTCOLORMATRIX];
d1054 4
a1057 1
            COPY_4V(params, ctx->Pixel.ColorTableScale[COLORTABLE_POSTCOLORMATRIX]);
d1061 4
a1064 1
            COPY_4V(params, ctx->Pixel.ColorTableBias[COLORTABLE_POSTCOLORMATRIX]);
d1069 1
a1069 1
         table = &ctx->ProxyColorTable[COLORTABLE_POSTCOLORMATRIX];
d1158 1
a1158 1
         table = &ctx->ColorTable[COLORTABLE_PRECONVOLUTION];
d1160 4
a1163 5
            GLfloat *scale = ctx->Pixel.ColorTableScale[COLORTABLE_PRECONVOLUTION];
            params[0] = (GLint) scale[0];
            params[1] = (GLint) scale[1];
            params[2] = (GLint) scale[2];
            params[3] = (GLint) scale[3];
d1167 4
a1170 5
            GLfloat *bias = ctx->Pixel.ColorTableBias[COLORTABLE_PRECONVOLUTION];
            params[0] = (GLint) bias[0];
            params[1] = (GLint) bias[1];
            params[2] = (GLint) bias[2];
            params[3] = (GLint) bias[3];
d1175 1
a1175 1
         table = &ctx->ProxyColorTable[COLORTABLE_PRECONVOLUTION];
d1206 1
a1206 1
         table = &ctx->ColorTable[COLORTABLE_POSTCONVOLUTION];
d1208 4
a1211 5
            GLfloat *scale = ctx->Pixel.ColorTableScale[COLORTABLE_POSTCONVOLUTION];
            params[0] = (GLint) scale[0];
            params[1] = (GLint) scale[1];
            params[2] = (GLint) scale[2];
            params[3] = (GLint) scale[3];
d1215 4
a1218 5
            GLfloat *bias = ctx->Pixel.ColorTableBias[COLORTABLE_POSTCONVOLUTION];
            params[0] = (GLint) bias[0];
            params[1] = (GLint) bias[1];
            params[2] = (GLint) bias[2];
            params[3] = (GLint) bias[3];
d1223 1
a1223 1
         table = &ctx->ProxyColorTable[COLORTABLE_POSTCONVOLUTION];
d1226 1
a1226 1
         table = &ctx->ColorTable[COLORTABLE_POSTCOLORMATRIX];
d1228 4
a1231 5
            GLfloat *scale = ctx->Pixel.ColorTableScale[COLORTABLE_POSTCOLORMATRIX];
            params[0] = (GLint) scale[0];
            params[0] = (GLint) scale[1];
            params[0] = (GLint) scale[2];
            params[0] = (GLint) scale[3];
d1235 4
a1238 5
            GLfloat *bias = ctx->Pixel.ColorTableScale[COLORTABLE_POSTCOLORMATRIX];
            params[0] = (GLint) bias[0];
            params[1] = (GLint) bias[1];
            params[2] = (GLint) bias[2];
            params[3] = (GLint) bias[3];
d1243 1
a1243 1
         table = &ctx->ProxyColorTable[COLORTABLE_POSTCOLORMATRIX];
d1319 7
a1325 5
   GLuint i;
   for (i = 0; i < COLORTABLE_MAX; i++) {
      _mesa_init_colortable(&ctx->ColorTable[i]);
      _mesa_init_colortable(&ctx->ProxyColorTable[i]);
   }
d1335 6
a1340 5
   GLuint i;
   for (i = 0; i < COLORTABLE_MAX; i++) {
      _mesa_free_colortable_data(&ctx->ColorTable[i]);
      _mesa_free_colortable_data(&ctx->ProxyColorTable[i]);
   }
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d3 1
a3 1
 * Version:  7.1
a31 1
#include "pack.h"
a32 6
#include "teximage.h"
#include "texstate.h"
#include "main/dispatch.h"


#if FEATURE_colortable
d173 1
a173 1
store_colortable_entries(struct gl_context *ctx, struct gl_color_table *table,
d181 20
a200 6
   data = _mesa_map_validate_pbo_source(ctx, 
                                        1, &ctx->Unpack, count, 1, 1,
                                        format, type, data,
                                        "glColor[Sub]Table");
   if (!data)
      return;
d281 4
a284 1
   _mesa_unmap_pbo_source(ctx, &ctx->Unpack);
d297 1
a297 1
   struct gl_texture_unit *texUnit = _mesa_get_current_tex_unit(ctx);
d308 43
d354 9
d380 18
d399 2
a400 13
         /* try texture targets */
         {
            struct gl_texture_object *texobj
               = _mesa_select_tex_object(ctx, texUnit, target);
            if (texobj) {
               table = &texobj->Palette;
               proxy = _mesa_is_proxy_texture(target);
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glColorTable(target)");
               return;
            }
         }
d417 1
a417 1
   if (width < 0 || (width != 0 && !_mesa_is_pow_two(width))) {
d453 2
a454 2
         table->TableF = (GLfloat *) malloc(comps * width * sizeof(GLfloat));
         table->TableUB = (GLubyte *) malloc(comps * width * sizeof(GLubyte));
d494 1
a494 1
   struct gl_texture_unit *texUnit = _mesa_get_current_tex_unit(ctx);
d502 20
d525 5
d539 10
d550 2
a551 9
         /* try texture targets */
         texObj = _mesa_select_tex_object(ctx, texUnit, target);
         if (texObj && !_mesa_is_proxy_texture(target)) {
            table = &texObj->Palette;
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM, "glColorSubTable(target)");
            return;
         }
d599 1
a599 1
static void GLAPIENTRY
d606 1
a606 4
   if (!ctx->ReadBuffer->_ColorReadBuffer) {
      return;      /* no readbuffer - OK */
   }

d612 1
a612 1
static void GLAPIENTRY
a618 4
   if (!ctx->ReadBuffer->_ColorReadBuffer) {
      return;      /* no readbuffer - OK */
   }

d624 1
a624 1
static void GLAPIENTRY
d629 1
a629 1
   struct gl_texture_unit *texUnit = _mesa_get_current_tex_unit(ctx);
d639 16
d658 3
d668 6
d675 2
a676 12
         /* try texture targets */
         {
            struct gl_texture_object *texobj
               = _mesa_select_tex_object(ctx, texUnit, target);
            if (texobj && !_mesa_is_proxy_texture(target)) {
               table = &texobj->Palette;
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetColorTable(target)");
               return;
            }
         }
d742 1
a742 1
      memcpy(rgba, table->TableF, 4 * table->Size * sizeof(GLfloat));
d749 20
a768 6
   data = _mesa_map_validate_pbo_dest(ctx, 
                                      1, &ctx->Pack, table->Size, 1, 1,
                                      format, type, data,
                                      "glGetColorTable");
   if (!data)
      return;
d773 4
a776 1
   _mesa_unmap_pbo_dest(ctx, &ctx->Pack);
d781 1
a781 1
static void GLAPIENTRY
a783 1
   GLfloat *scale, *bias;
d788 55
a842 18
   case GL_TEXTURE_COLOR_TABLE_SGI:
      scale = ctx->Pixel.TextureColorTableScale;
      bias  = ctx->Pixel.TextureColorTableBias;
      break;
   default:
      _mesa_error(ctx, GL_INVALID_ENUM, "glColorTableParameter(target)");
      return;
   }

   if (pname == GL_COLOR_TABLE_SCALE_SGI) {
      COPY_4V(scale, params);
   }
   else if (pname == GL_COLOR_TABLE_BIAS_SGI) {
      COPY_4V(bias, params);
   }
   else {
      _mesa_error(ctx, GL_INVALID_ENUM, "glColorTableParameterfv(pname)");
      return;
d850 1
a850 1
static void GLAPIENTRY
d854 4
a857 1
   if (pname == GL_TEXTURE_COLOR_TABLE_SGI) {
d873 1
a873 1
static void GLAPIENTRY
d877 1
a877 1
   struct gl_texture_unit *texUnit = _mesa_get_current_tex_unit(ctx);
d882 34
d919 14
d955 28
d984 2
a985 13
         /* try texture targets */
         {
            struct gl_texture_object *texobj
               = _mesa_select_tex_object(ctx, texUnit, target);
            if (texobj) {
               table = &texobj->Palette;
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM,
                           "glGetColorTableParameterfv(target)");
               return;
            }
         }
d1023 1
a1023 1
static void GLAPIENTRY
d1027 1
a1027 1
   struct gl_texture_unit *texUnit = _mesa_get_current_tex_unit(ctx);
d1032 34
d1069 22
d1119 44
d1164 2
a1165 13
         /* Try texture targets */
         {
            struct gl_texture_object *texobj
               = _mesa_select_tex_object(ctx, texUnit, target);
            if (texobj) {
               table = &texobj->Palette;
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM,
                           "glGetColorTableParameteriv(target)");
               return;
            }
         }
a1200 19

void
_mesa_init_colortable_dispatch(struct _glapi_table *disp)
{
   SET_ColorSubTable(disp, _mesa_ColorSubTable);
   SET_ColorTable(disp, _mesa_ColorTable);
   SET_ColorTableParameterfv(disp, _mesa_ColorTableParameterfv);
   SET_ColorTableParameteriv(disp, _mesa_ColorTableParameteriv);
   SET_CopyColorSubTable(disp, _mesa_CopyColorSubTable);
   SET_CopyColorTable(disp, _mesa_CopyColorTable);
   SET_GetColorTable(disp, _mesa_GetColorTable);
   SET_GetColorTableParameterfv(disp, _mesa_GetColorTableParameterfv);
   SET_GetColorTableParameteriv(disp, _mesa_GetColorTableParameteriv);
}


#endif /* FEATURE_colortable */


d1221 1
a1221 1
      free(p->TableF);
d1225 1
a1225 1
      free(p->TableUB);
d1227 28
@


1.1.1.5
log
@Import Mesa 9.2.0
@
text
@d3 1
d20 3
a22 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
a31 1
#include "mtypes.h"
a32 1
#include "pbo.h"
d39 240
d284 2
d287 126
a412 1
   _mesa_error(ctx, GL_INVALID_ENUM, "glColorTable(target)");
d422 2
d425 73
a497 1
   _mesa_error(ctx, GL_INVALID_ENUM, "glColorSubTable(target)");
d502 1
a502 1
void GLAPIENTRY
d507 7
a513 1
   _mesa_error(ctx, GL_INVALID_ENUM, "glCopyColorTable(target)");
d518 1
a518 1
void GLAPIENTRY
d523 1
a523 2
   _mesa_error(ctx, GL_INVALID_ENUM, "glCopyColorSubTable(target)");
}
d525 3
d529 2
a531 7
void GLAPIENTRY
_mesa_GetnColorTableARB( GLenum target, GLenum format, GLenum type,
                         GLsizei bufSize, GLvoid *data )
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_error(ctx, GL_INVALID_ENUM, "glGetnColorTableARB(target)");
}
d534 1
a534 1
void GLAPIENTRY
d539 116
a654 1
   _mesa_error(ctx, GL_INVALID_ENUM, "glGetColorTable(target)");
d658 2
a659 1
void GLAPIENTRY
d662 1
a662 1
   /* no extensions use this function */
d664 24
a687 1
   _mesa_error(ctx, GL_INVALID_ENUM, "glColorTableParameterfv(target)");
d692 1
a692 1
void GLAPIENTRY
d695 13
a707 3
   /* no extensions use this function */
   GET_CURRENT_CONTEXT(ctx);
   _mesa_error(ctx, GL_INVALID_ENUM, "glColorTableParameteriv(target)");
d712 1
a712 1
void GLAPIENTRY
d716 77
a792 1
   _mesa_error(ctx, GL_INVALID_ENUM, "glGetColorTableParameterfv(target)");
d797 1
a797 1
void GLAPIENTRY
d801 131
a931 1
   _mesa_error(ctx, GL_INVALID_ENUM, "glGetColorTableParameteriv(target)");
@


1.1.1.6
log
@Import Mesa 10.2.3
@
text
@d47 1
a47 1
   _mesa_error(ctx, GL_INVALID_OPERATION, "glColorTable");
d58 1
a58 1
   _mesa_error(ctx, GL_INVALID_OPERATION, "glColorSubTable");
d68 1
a68 1
   _mesa_error(ctx, GL_INVALID_OPERATION, "glCopyColorTable");
d78 1
a78 1
   _mesa_error(ctx, GL_INVALID_OPERATION, "glCopyColorSubTable");
d88 1
a88 1
   _mesa_error(ctx, GL_INVALID_OPERATION, "glGetnColorTableARB");
d97 1
a97 1
   _mesa_error(ctx, GL_INVALID_OPERATION, "glGetColorTable");
d106 1
a106 1
   _mesa_error(ctx, GL_INVALID_OPERATION, "glColorTableParameterfv");
d116 1
a116 1
   _mesa_error(ctx, GL_INVALID_OPERATION, "glColorTableParameteriv");
d125 1
a125 1
   _mesa_error(ctx, GL_INVALID_OPERATION, "glGetColorTableParameterfv");
d134 1
a134 1
   _mesa_error(ctx, GL_INVALID_OPERATION, "glGetColorTableParameteriv");
@


