head	1.16;
access;
symbols
	OPENBSD_5_8:1.15.0.4
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	v10_2_9:1.1.1.9
	v10_4_3:1.1.1.8
	v10_2_7:1.1.1.7
	OPENBSD_5_6:1.12.0.2
	OPENBSD_5_6_BASE:1.12
	v10_2_3:1.1.1.6
	OPENBSD_5_5:1.11.0.2
	OPENBSD_5_5_BASE:1.11
	v9_2_5:1.1.1.5
	v9_2_3:1.1.1.5
	v9_2_2:1.1.1.5
	v9_2_1:1.1.1.5
	v9_2_0:1.1.1.5
	OPENBSD_5_4:1.10.0.4
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.2
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.9.0.4
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.8.0.6
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.2
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.7.0.4
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.2
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.6.0.2
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.5.0.2
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_3:1.2.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.16
date	2015.12.23.05.17.52;	author jsg;	state dead;
branches;
next	1.15;
commitid	TnlogFl9nOv2eaRf;

1.15
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.14;
commitid	4ry2gvZGMXkCUD2n;

1.14
date	2015.01.25.14.41.21;	author jsg;	state Exp;
branches;
next	1.13;
commitid	mcxB0JvoI9gTDYXU;

1.13
date	2014.09.07.15.20.07;	author jsg;	state Exp;
branches;
next	1.12;
commitid	7kimTMT4YlQauAIU;

1.12
date	2014.07.09.21.09.00;	author jsg;	state Exp;
branches;
next	1.11;
commitid	WPD6rgPryPkvXOr9;

1.11
date	2013.09.05.14.06.17;	author jsg;	state Exp;
branches;
next	1.10;

1.10
date	2012.08.17.13.58.17;	author mpi;	state Exp;
branches;
next	1.9;

1.9
date	2011.10.23.13.37.42;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2010.05.22.20.06.30;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2009.05.17.20.26.41;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2008.11.02.14.58.20;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2008.08.02.23.04.55;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2008.08.02.16.01.32;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.05.31.16.36.48;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.02.12.21.09.27;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.49.47;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.49.47;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.56.32;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.30.52;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.45;	author matthieu;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.09.05.13.16.26;	author jsg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.07.09.20.34.59;	author jsg;	state Exp;
branches;
next	1.1.1.7;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.7
date	2014.09.07.15.06.59;	author jsg;	state Exp;
branches;
next	1.1.1.8;
commitid	dm8VnQHhowGHmemJ;

1.1.1.8
date	2015.01.25.14.12.29;	author jsg;	state Exp;
branches;
next	1.1.1.9;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.9
date	2015.02.20.22.49.36;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.16
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
 * Copyright (C) 2008  VMware, Inc.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

/**
 * \file context.c
 * Mesa context/visual/framebuffer management functions.
 * \author Brian Paul
 */

/**
 * \mainpage Mesa Main Module
 *
 * \section MainIntroduction Introduction
 *
 * The Mesa Main module consists of all the files in the main/ directory.
 * Among the features of this module are:
 * <UL>
 * <LI> Structures to represent most GL state </LI>
 * <LI> State set/get functions </LI>
 * <LI> Display lists </LI>
 * <LI> Texture unit, object and image handling </LI>
 * <LI> Matrix and attribute stacks </LI>
 * </UL>
 *
 * Other modules are responsible for API dispatch, vertex transformation,
 * point/line/triangle setup, rasterization, vertex array caching,
 * vertex/fragment programs/shaders, etc.
 *
 *
 * \section AboutDoxygen About Doxygen
 *
 * If you're viewing this information as Doxygen-generated HTML you'll
 * see the documentation index at the top of this page.
 *
 * The first line lists the Mesa source code modules.
 * The second line lists the indexes available for viewing the documentation
 * for each module.
 *
 * Selecting the <b>Main page</b> link will display a summary of the module
 * (this page).
 *
 * Selecting <b>Data Structures</b> will list all C structures.
 *
 * Selecting the <b>File List</b> link will list all the source files in
 * the module.
 * Selecting a filename will show a list of all functions defined in that file.
 *
 * Selecting the <b>Data Fields</b> link will display a list of all
 * documented structure members.
 *
 * Selecting the <b>Globals</b> link will display a list
 * of all functions, structures, global variables and macros in the module.
 *
 */


#include "glheader.h"
#include "imports.h"
#include "accum.h"
#include "api_exec.h"
#include "api_loopback.h"
#include "arrayobj.h"
#include "attrib.h"
#include "blend.h"
#include "buffers.h"
#include "bufferobj.h"
#include "context.h"
#include "cpuinfo.h"
#include "debug.h"
#include "depth.h"
#include "dlist.h"
#include "eval.h"
#include "extensions.h"
#include "fbobject.h"
#include "feedback.h"
#include "fog.h"
#include "formats.h"
#include "framebuffer.h"
#include "hint.h"
#include "hash.h"
#include "light.h"
#include "lines.h"
#include "macros.h"
#include "matrix.h"
#include "multisample.h"
#include "performance_monitor.h"
#include "pipelineobj.h"
#include "pixel.h"
#include "pixelstore.h"
#include "points.h"
#include "polygon.h"
#include "queryobj.h"
#include "syncobj.h"
#include "rastpos.h"
#include "remap.h"
#include "scissor.h"
#include "shared.h"
#include "shaderobj.h"
#include "simple_list.h"
#include "state.h"
#include "stencil.h"
#include "texcompress_s3tc.h"
#include "texstate.h"
#include "transformfeedback.h"
#include "mtypes.h"
#include "varray.h"
#include "version.h"
#include "viewport.h"
#include "vtxfmt.h"
#include "program/program.h"
#include "program/prog_print.h"
#include "math/m_matrix.h"
#include "main/dispatch.h" /* for _gloffset_COUNT */

#ifdef USE_SPARC_ASM
#include "sparc/sparc.h"
#endif

#include "glsl_parser_extras.h"
#include <stdbool.h>


#ifndef MESA_VERBOSE
int MESA_VERBOSE = 0;
#endif

#ifndef MESA_DEBUG_FLAGS
int MESA_DEBUG_FLAGS = 0;
#endif


/* ubyte -> float conversion */
GLfloat _mesa_ubyte_to_float_color_tab[256];



/**
 * Swap buffers notification callback.
 * 
 * \param ctx GL context.
 *
 * Called by window system just before swapping buffers.
 * We have to finish any pending rendering.
 */
void
_mesa_notifySwapBuffers(struct gl_context *ctx)
{
   if (MESA_VERBOSE & VERBOSE_SWAPBUFFERS)
      _mesa_debug(ctx, "SwapBuffers\n");
   FLUSH_CURRENT( ctx, 0 );
   if (ctx->Driver.Flush) {
      ctx->Driver.Flush(ctx);
   }
}


/**********************************************************************/
/** \name GL Visual allocation/destruction                            */
/**********************************************************************/
/*@@{*/

/**
 * Allocates a struct gl_config structure and initializes it via
 * _mesa_initialize_visual().
 * 
 * \param dbFlag double buffering
 * \param stereoFlag stereo buffer
 * \param depthBits requested bits per depth buffer value. Any value in [0, 32]
 * is acceptable but the actual depth type will be GLushort or GLuint as
 * needed.
 * \param stencilBits requested minimum bits per stencil buffer value
 * \param accumRedBits, accumGreenBits, accumBlueBits, accumAlphaBits number
 * of bits per color component in accum buffer.
 * \param indexBits number of bits per pixel if \p rgbFlag is GL_FALSE
 * \param redBits number of bits per color component in frame buffer for RGB(A)
 * mode.  We always use 8 in core Mesa though.
 * \param greenBits same as above.
 * \param blueBits same as above.
 * \param alphaBits same as above.
 * \param numSamples not really used.
 * 
 * \return pointer to new struct gl_config or NULL if requested parameters
 * can't be met.
 *
 * \note Need to add params for level and numAuxBuffers (at least)
 */
struct gl_config *
_mesa_create_visual( GLboolean dbFlag,
                     GLboolean stereoFlag,
                     GLint redBits,
                     GLint greenBits,
                     GLint blueBits,
                     GLint alphaBits,
                     GLint depthBits,
                     GLint stencilBits,
                     GLint accumRedBits,
                     GLint accumGreenBits,
                     GLint accumBlueBits,
                     GLint accumAlphaBits,
                     GLint numSamples )
{
   struct gl_config *vis = CALLOC_STRUCT(gl_config);
   if (vis) {
      if (!_mesa_initialize_visual(vis, dbFlag, stereoFlag,
                                   redBits, greenBits, blueBits, alphaBits,
                                   depthBits, stencilBits,
                                   accumRedBits, accumGreenBits,
                                   accumBlueBits, accumAlphaBits,
                                   numSamples)) {
         free(vis);
         return NULL;
      }
   }
   return vis;
}


/**
 * Makes some sanity checks and fills in the fields of the struct
 * gl_config object with the given parameters.  If the caller needs to
 * set additional fields, he should just probably init the whole
 * gl_config object himself.
 *
 * \return GL_TRUE on success, or GL_FALSE on failure.
 *
 * \sa _mesa_create_visual() above for the parameter description.
 */
GLboolean
_mesa_initialize_visual( struct gl_config *vis,
                         GLboolean dbFlag,
                         GLboolean stereoFlag,
                         GLint redBits,
                         GLint greenBits,
                         GLint blueBits,
                         GLint alphaBits,
                         GLint depthBits,
                         GLint stencilBits,
                         GLint accumRedBits,
                         GLint accumGreenBits,
                         GLint accumBlueBits,
                         GLint accumAlphaBits,
                         GLint numSamples )
{
   assert(vis);

   if (depthBits < 0 || depthBits > 32) {
      return GL_FALSE;
   }
   if (stencilBits < 0 || stencilBits > 8) {
      return GL_FALSE;
   }
   assert(accumRedBits >= 0);
   assert(accumGreenBits >= 0);
   assert(accumBlueBits >= 0);
   assert(accumAlphaBits >= 0);

   vis->rgbMode          = GL_TRUE;
   vis->doubleBufferMode = dbFlag;
   vis->stereoMode       = stereoFlag;

   vis->redBits          = redBits;
   vis->greenBits        = greenBits;
   vis->blueBits         = blueBits;
   vis->alphaBits        = alphaBits;
   vis->rgbBits          = redBits + greenBits + blueBits;

   vis->indexBits      = 0;
   vis->depthBits      = depthBits;
   vis->stencilBits    = stencilBits;

   vis->accumRedBits   = accumRedBits;
   vis->accumGreenBits = accumGreenBits;
   vis->accumBlueBits  = accumBlueBits;
   vis->accumAlphaBits = accumAlphaBits;

   vis->haveAccumBuffer   = accumRedBits > 0;
   vis->haveDepthBuffer   = depthBits > 0;
   vis->haveStencilBuffer = stencilBits > 0;

   vis->numAuxBuffers = 0;
   vis->level = 0;
   vis->sampleBuffers = numSamples > 0 ? 1 : 0;
   vis->samples = numSamples;

   return GL_TRUE;
}


/**
 * Destroy a visual and free its memory.
 *
 * \param vis visual.
 * 
 * Frees the visual structure.
 */
void
_mesa_destroy_visual( struct gl_config *vis )
{
   free(vis);
}

/*@@}*/


/**********************************************************************/
/** \name Context allocation, initialization, destroying
 *
 * The purpose of the most initialization functions here is to provide the
 * default state values according to the OpenGL specification.
 */
/**********************************************************************/
/*@@{*/


/**
 * This is lame.  gdb only seems to recognize enum types that are
 * actually used somewhere.  We want to be able to print/use enum
 * values such as TEXTURE_2D_INDEX in gdb.  But we don't actually use
 * the gl_texture_index type anywhere.  Thus, this lame function.
 */
static void
dummy_enum_func(void)
{
   gl_buffer_index bi = BUFFER_FRONT_LEFT;
   gl_face_index fi = FACE_POS_X;
   gl_frag_result fr = FRAG_RESULT_DEPTH;
   gl_texture_index ti = TEXTURE_2D_ARRAY_INDEX;
   gl_vert_attrib va = VERT_ATTRIB_POS;
   gl_varying_slot vs = VARYING_SLOT_POS;

   (void) bi;
   (void) fi;
   (void) fr;
   (void) ti;
   (void) va;
   (void) vs;
}


/**
 * One-time initialization mutex lock.
 *
 * \sa Used by one_time_init().
 */
mtx_t OneTimeLock = _MTX_INITIALIZER_NP;



/**
 * Calls all the various one-time-init functions in Mesa.
 *
 * While holding a global mutex lock, calls several initialization functions,
 * and sets the glapi callbacks if the \c MESA_DEBUG environment variable is
 * defined.
 *
 * \sa _math_init().
 */
static void
one_time_init( struct gl_context *ctx )
{
   static GLbitfield api_init_mask = 0x0;

   mtx_lock(&OneTimeLock);

   /* truly one-time init */
   if (!api_init_mask) {
      GLuint i;

      /* do some implementation tests */
      assert( sizeof(GLbyte) == 1 );
      assert( sizeof(GLubyte) == 1 );
      assert( sizeof(GLshort) == 2 );
      assert( sizeof(GLushort) == 2 );
      assert( sizeof(GLint) == 4 );
      assert( sizeof(GLuint) == 4 );

      _mesa_get_cpu_features();

      for (i = 0; i < 256; i++) {
         _mesa_ubyte_to_float_color_tab[i] = (float) i / 255.0F;
      }

#if defined(DEBUG) && defined(__DATE__) && defined(__TIME__)
      if (MESA_VERBOSE != 0) {
	 _mesa_debug(ctx, "Mesa %s DEBUG build %s %s\n",
		     PACKAGE_VERSION, __DATE__, __TIME__);
      }
#endif

#ifdef DEBUG
      _mesa_test_formats();
#endif
   }

   /* per-API one-time init */
   if (!(api_init_mask & (1 << ctx->API))) {
      _mesa_init_get_hash(ctx);

      _mesa_init_remap_table();
   }

   api_init_mask |= 1 << ctx->API;

   mtx_unlock(&OneTimeLock);

   /* Hopefully atexit() is widely available.  If not, we may need some
    * #ifdef tests here.
    */
   atexit(_mesa_destroy_shader_compiler);

   dummy_enum_func();
}


/**
 * Initialize fields of gl_current_attrib (aka ctx->Current.*)
 */
static void
_mesa_init_current(struct gl_context *ctx)
{
   GLuint i;

   /* Init all to (0,0,0,1) */
   for (i = 0; i < Elements(ctx->Current.Attrib); i++) {
      ASSIGN_4V( ctx->Current.Attrib[i], 0.0, 0.0, 0.0, 1.0 );
   }

   /* redo special cases: */
   ASSIGN_4V( ctx->Current.Attrib[VERT_ATTRIB_WEIGHT], 1.0, 0.0, 0.0, 0.0 );
   ASSIGN_4V( ctx->Current.Attrib[VERT_ATTRIB_NORMAL], 0.0, 0.0, 1.0, 1.0 );
   ASSIGN_4V( ctx->Current.Attrib[VERT_ATTRIB_COLOR0], 1.0, 1.0, 1.0, 1.0 );
   ASSIGN_4V( ctx->Current.Attrib[VERT_ATTRIB_COLOR1], 0.0, 0.0, 0.0, 1.0 );
   ASSIGN_4V( ctx->Current.Attrib[VERT_ATTRIB_COLOR_INDEX], 1.0, 0.0, 0.0, 1.0 );
   ASSIGN_4V( ctx->Current.Attrib[VERT_ATTRIB_EDGEFLAG], 1.0, 0.0, 0.0, 1.0 );
}


/**
 * Init vertex/fragment/geometry program limits.
 * Important: drivers should override these with actual limits.
 */
static void
init_program_limits(struct gl_context *ctx, gl_shader_stage stage,
                    struct gl_program_constants *prog)
{
   prog->MaxInstructions = MAX_PROGRAM_INSTRUCTIONS;
   prog->MaxAluInstructions = MAX_PROGRAM_INSTRUCTIONS;
   prog->MaxTexInstructions = MAX_PROGRAM_INSTRUCTIONS;
   prog->MaxTexIndirections = MAX_PROGRAM_INSTRUCTIONS;
   prog->MaxTemps = MAX_PROGRAM_TEMPS;
   prog->MaxEnvParams = MAX_PROGRAM_ENV_PARAMS;
   prog->MaxLocalParams = MAX_PROGRAM_LOCAL_PARAMS;
   prog->MaxAddressOffset = MAX_PROGRAM_LOCAL_PARAMS;

   switch (stage) {
   case MESA_SHADER_VERTEX:
      prog->MaxParameters = MAX_VERTEX_PROGRAM_PARAMS;
      prog->MaxAttribs = MAX_VERTEX_GENERIC_ATTRIBS;
      prog->MaxAddressRegs = MAX_VERTEX_PROGRAM_ADDRESS_REGS;
      prog->MaxUniformComponents = 4 * MAX_UNIFORMS;
      prog->MaxInputComponents = 0; /* value not used */
      prog->MaxOutputComponents = 16 * 4; /* old limit not to break tnl and swrast */
      break;
   case MESA_SHADER_FRAGMENT:
      prog->MaxParameters = MAX_NV_FRAGMENT_PROGRAM_PARAMS;
      prog->MaxAttribs = MAX_NV_FRAGMENT_PROGRAM_INPUTS;
      prog->MaxAddressRegs = MAX_FRAGMENT_PROGRAM_ADDRESS_REGS;
      prog->MaxUniformComponents = 4 * MAX_UNIFORMS;
      prog->MaxInputComponents = 16 * 4; /* old limit not to break tnl and swrast */
      prog->MaxOutputComponents = 0; /* value not used */
      break;
   case MESA_SHADER_GEOMETRY:
      prog->MaxParameters = MAX_VERTEX_PROGRAM_PARAMS;
      prog->MaxAttribs = MAX_VERTEX_GENERIC_ATTRIBS;
      prog->MaxAddressRegs = MAX_VERTEX_PROGRAM_ADDRESS_REGS;
      prog->MaxUniformComponents = 4 * MAX_UNIFORMS;
      prog->MaxInputComponents = 16 * 4; /* old limit not to break tnl and swrast */
      prog->MaxOutputComponents = 16 * 4; /* old limit not to break tnl and swrast */
      break;
   case MESA_SHADER_COMPUTE:
      prog->MaxParameters = 0; /* not meaningful for compute shaders */
      prog->MaxAttribs = 0; /* not meaningful for compute shaders */
      prog->MaxAddressRegs = 0; /* not meaningful for compute shaders */
      prog->MaxUniformComponents = 4 * MAX_UNIFORMS;
      prog->MaxInputComponents = 0; /* not meaningful for compute shaders */
      prog->MaxOutputComponents = 0; /* not meaningful for compute shaders */
      break;
   default:
      assert(0 && "Bad shader stage in init_program_limits()");
   }

   /* Set the native limits to zero.  This implies that there is no native
    * support for shaders.  Let the drivers fill in the actual values.
    */
   prog->MaxNativeInstructions = 0;
   prog->MaxNativeAluInstructions = 0;
   prog->MaxNativeTexInstructions = 0;
   prog->MaxNativeTexIndirections = 0;
   prog->MaxNativeAttribs = 0;
   prog->MaxNativeTemps = 0;
   prog->MaxNativeAddressRegs = 0;
   prog->MaxNativeParameters = 0;

   /* Set GLSL datatype range/precision info assuming IEEE float values.
    * Drivers should override these defaults as needed.
    */
   prog->MediumFloat.RangeMin = 127;
   prog->MediumFloat.RangeMax = 127;
   prog->MediumFloat.Precision = 23;
   prog->LowFloat = prog->HighFloat = prog->MediumFloat;

   /* Assume ints are stored as floats for now, since this is the least-common
    * denominator.  The OpenGL ES spec implies (page 132) that the precision
    * of integer types should be 0.  Practically speaking, IEEE
    * single-precision floating point values can only store integers in the
    * range [-0x01000000, 0x01000000] without loss of precision.
    */
   prog->MediumInt.RangeMin = 24;
   prog->MediumInt.RangeMax = 24;
   prog->MediumInt.Precision = 0;
   prog->LowInt = prog->HighInt = prog->MediumInt;

   prog->MaxUniformBlocks = 12;
   prog->MaxCombinedUniformComponents = (prog->MaxUniformComponents +
                                         ctx->Const.MaxUniformBlockSize / 4 *
                                         prog->MaxUniformBlocks);

   prog->MaxAtomicBuffers = 0;
   prog->MaxAtomicCounters = 0;
}


/**
 * Initialize fields of gl_constants (aka ctx->Const.*).
 * Use defaults from config.h.  The device drivers will often override
 * some of these values (such as number of texture units).
 */
static void 
_mesa_init_constants(struct gl_context *ctx)
{
   int i;
   assert(ctx);

   /* Constants, may be overriden (usually only reduced) by device drivers */
   ctx->Const.MaxTextureMbytes = MAX_TEXTURE_MBYTES;
   ctx->Const.MaxTextureLevels = MAX_TEXTURE_LEVELS;
   ctx->Const.Max3DTextureLevels = MAX_3D_TEXTURE_LEVELS;
   ctx->Const.MaxCubeTextureLevels = MAX_CUBE_TEXTURE_LEVELS;
   ctx->Const.MaxTextureRectSize = MAX_TEXTURE_RECT_SIZE;
   ctx->Const.MaxArrayTextureLayers = MAX_ARRAY_TEXTURE_LAYERS;
   ctx->Const.MaxTextureCoordUnits = MAX_TEXTURE_COORD_UNITS;
   ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits = MAX_TEXTURE_IMAGE_UNITS;
   ctx->Const.MaxTextureUnits = MIN2(ctx->Const.MaxTextureCoordUnits,
                                     ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits);
   ctx->Const.MaxTextureMaxAnisotropy = MAX_TEXTURE_MAX_ANISOTROPY;
   ctx->Const.MaxTextureLodBias = MAX_TEXTURE_LOD_BIAS;
   ctx->Const.MaxTextureBufferSize = 65536;
   ctx->Const.TextureBufferOffsetAlignment = 1;
   ctx->Const.MaxArrayLockSize = MAX_ARRAY_LOCK_SIZE;
   ctx->Const.SubPixelBits = SUB_PIXEL_BITS;
   ctx->Const.MinPointSize = MIN_POINT_SIZE;
   ctx->Const.MaxPointSize = MAX_POINT_SIZE;
   ctx->Const.MinPointSizeAA = MIN_POINT_SIZE;
   ctx->Const.MaxPointSizeAA = MAX_POINT_SIZE;
   ctx->Const.PointSizeGranularity = (GLfloat) POINT_SIZE_GRANULARITY;
   ctx->Const.MinLineWidth = MIN_LINE_WIDTH;
   ctx->Const.MaxLineWidth = MAX_LINE_WIDTH;
   ctx->Const.MinLineWidthAA = MIN_LINE_WIDTH;
   ctx->Const.MaxLineWidthAA = MAX_LINE_WIDTH;
   ctx->Const.LineWidthGranularity = (GLfloat) LINE_WIDTH_GRANULARITY;
   ctx->Const.MaxClipPlanes = 6;
   ctx->Const.MaxLights = MAX_LIGHTS;
   ctx->Const.MaxShininess = 128.0;
   ctx->Const.MaxSpotExponent = 128.0;
   ctx->Const.MaxViewportWidth = MAX_VIEWPORT_WIDTH;
   ctx->Const.MaxViewportHeight = MAX_VIEWPORT_HEIGHT;
   ctx->Const.MinMapBufferAlignment = 64;

   /* Driver must override these values if ARB_viewport_array is supported. */
   ctx->Const.MaxViewports = 1;
   ctx->Const.ViewportSubpixelBits = 0;
   ctx->Const.ViewportBounds.Min = 0;
   ctx->Const.ViewportBounds.Max = 0;

   /** GL_ARB_uniform_buffer_object */
   ctx->Const.MaxCombinedUniformBlocks = 36;
   ctx->Const.MaxUniformBufferBindings = 36;
   ctx->Const.MaxUniformBlockSize = 16384;
   ctx->Const.UniformBufferOffsetAlignment = 1;

   for (i = 0; i < MESA_SHADER_STAGES; i++)
      init_program_limits(ctx, i, &ctx->Const.Program[i]);

   ctx->Const.MaxProgramMatrices = MAX_PROGRAM_MATRICES;
   ctx->Const.MaxProgramMatrixStackDepth = MAX_PROGRAM_MATRIX_STACK_DEPTH;

   /* CheckArrayBounds is overriden by drivers/x11 for X server */
   ctx->Const.CheckArrayBounds = GL_FALSE;

   /* GL_ARB_draw_buffers */
   ctx->Const.MaxDrawBuffers = MAX_DRAW_BUFFERS;

   ctx->Const.MaxColorAttachments = MAX_COLOR_ATTACHMENTS;
   ctx->Const.MaxRenderbufferSize = MAX_RENDERBUFFER_SIZE;

   ctx->Const.Program[MESA_SHADER_VERTEX].MaxTextureImageUnits = MAX_TEXTURE_IMAGE_UNITS;
   ctx->Const.MaxCombinedTextureImageUnits = MAX_COMBINED_TEXTURE_IMAGE_UNITS;
   ctx->Const.MaxVarying = 16; /* old limit not to break tnl and swrast */
   ctx->Const.Program[MESA_SHADER_GEOMETRY].MaxTextureImageUnits = MAX_TEXTURE_IMAGE_UNITS;
   ctx->Const.MaxGeometryOutputVertices = MAX_GEOMETRY_OUTPUT_VERTICES;
   ctx->Const.MaxGeometryTotalOutputComponents = MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS;

   /* Shading language version */
   if (_mesa_is_desktop_gl(ctx)) {
      ctx->Const.GLSLVersion = 120;
      _mesa_override_glsl_version(ctx);
   }
   else if (ctx->API == API_OPENGLES2) {
      ctx->Const.GLSLVersion = 100;
   }
   else if (ctx->API == API_OPENGLES) {
      ctx->Const.GLSLVersion = 0; /* GLSL not supported */
   }

   /* GL_ARB_framebuffer_object */
   ctx->Const.MaxSamples = 0;

   /* GLSL default if NativeIntegers == FALSE */
   ctx->Const.UniformBooleanTrue = FLT_AS_UINT(1.0f);

   /* GL_ARB_sync */
   ctx->Const.MaxServerWaitTimeout = 0x1fff7fffffffULL;

   /* GL_ATI_envmap_bumpmap */
   ctx->Const.SupportedBumpUnits = SUPPORTED_ATI_BUMP_UNITS;

   /* GL_EXT_provoking_vertex */
   ctx->Const.QuadsFollowProvokingVertexConvention = GL_TRUE;

   /* GL_EXT_transform_feedback */
   ctx->Const.MaxTransformFeedbackBuffers = MAX_FEEDBACK_BUFFERS;
   ctx->Const.MaxTransformFeedbackSeparateComponents = 4 * MAX_FEEDBACK_ATTRIBS;
   ctx->Const.MaxTransformFeedbackInterleavedComponents = 4 * MAX_FEEDBACK_ATTRIBS;
   ctx->Const.MaxVertexStreams = 1;

   /* GL 3.2  */
   ctx->Const.ProfileMask = ctx->API == API_OPENGL_CORE
                          ? GL_CONTEXT_CORE_PROFILE_BIT
                          : GL_CONTEXT_COMPATIBILITY_PROFILE_BIT;

   /** GL_EXT_gpu_shader4 */
   ctx->Const.MinProgramTexelOffset = -8;
   ctx->Const.MaxProgramTexelOffset = 7;

   /* GL_ARB_texture_gather */
   ctx->Const.MinProgramTextureGatherOffset = -8;
   ctx->Const.MaxProgramTextureGatherOffset = 7;

   /* GL_ARB_robustness */
   ctx->Const.ResetStrategy = GL_NO_RESET_NOTIFICATION_ARB;

   /* PrimitiveRestart */
   ctx->Const.PrimitiveRestartInSoftware = GL_FALSE;

   /* ES 3.0 or ARB_ES3_compatibility */
   ctx->Const.MaxElementIndex = 0xffffffffu;

   /* GL_ARB_texture_multisample */
   ctx->Const.MaxColorTextureSamples = 1;
   ctx->Const.MaxDepthTextureSamples = 1;
   ctx->Const.MaxIntegerSamples = 1;

   /* GL_ARB_shader_atomic_counters */
   ctx->Const.MaxAtomicBufferBindings = MAX_COMBINED_ATOMIC_BUFFERS;
   ctx->Const.MaxAtomicBufferSize = MAX_ATOMIC_COUNTERS * ATOMIC_COUNTER_SIZE;
   ctx->Const.MaxCombinedAtomicBuffers = MAX_COMBINED_ATOMIC_BUFFERS;
   ctx->Const.MaxCombinedAtomicCounters = MAX_ATOMIC_COUNTERS;

   /* GL_ARB_vertex_attrib_binding */
   ctx->Const.MaxVertexAttribRelativeOffset = 2047;
   ctx->Const.MaxVertexAttribBindings = MAX_VERTEX_GENERIC_ATTRIBS;

   /* GL_ARB_compute_shader */
   ctx->Const.MaxComputeWorkGroupCount[0] = 65535;
   ctx->Const.MaxComputeWorkGroupCount[1] = 65535;
   ctx->Const.MaxComputeWorkGroupCount[2] = 65535;
   ctx->Const.MaxComputeWorkGroupSize[0] = 1024;
   ctx->Const.MaxComputeWorkGroupSize[1] = 1024;
   ctx->Const.MaxComputeWorkGroupSize[2] = 64;
   ctx->Const.MaxComputeWorkGroupInvocations = 1024;

   /** GL_ARB_gpu_shader5 */
   ctx->Const.MinFragmentInterpolationOffset = MIN_FRAGMENT_INTERPOLATION_OFFSET;
   ctx->Const.MaxFragmentInterpolationOffset = MAX_FRAGMENT_INTERPOLATION_OFFSET;
}


/**
 * Do some sanity checks on the limits/constants for the given context.
 * Only called the first time a context is bound.
 */
static void
check_context_limits(struct gl_context *ctx)
{
   /* check that we don't exceed the size of various bitfields */
   assert(VARYING_SLOT_MAX <=
	  (8 * sizeof(ctx->VertexProgram._Current->Base.OutputsWritten)));
   assert(VARYING_SLOT_MAX <=
	  (8 * sizeof(ctx->FragmentProgram._Current->Base.InputsRead)));

   /* shader-related checks */
   assert(ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxLocalParams <= MAX_PROGRAM_LOCAL_PARAMS);
   assert(ctx->Const.Program[MESA_SHADER_VERTEX].MaxLocalParams <= MAX_PROGRAM_LOCAL_PARAMS);

   /* Texture unit checks */
   assert(ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits > 0);
   assert(ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits <= MAX_TEXTURE_IMAGE_UNITS);
   assert(ctx->Const.MaxTextureCoordUnits > 0);
   assert(ctx->Const.MaxTextureCoordUnits <= MAX_TEXTURE_COORD_UNITS);
   assert(ctx->Const.MaxTextureUnits > 0);
   assert(ctx->Const.MaxTextureUnits <= MAX_TEXTURE_IMAGE_UNITS);
   assert(ctx->Const.MaxTextureUnits <= MAX_TEXTURE_COORD_UNITS);
   assert(ctx->Const.MaxTextureUnits == MIN2(ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits,
                                             ctx->Const.MaxTextureCoordUnits));
   assert(ctx->Const.MaxCombinedTextureImageUnits > 0);
   assert(ctx->Const.MaxCombinedTextureImageUnits <= MAX_COMBINED_TEXTURE_IMAGE_UNITS);
   assert(ctx->Const.MaxTextureCoordUnits <= MAX_COMBINED_TEXTURE_IMAGE_UNITS);
   /* number of coord units cannot be greater than number of image units */
   assert(ctx->Const.MaxTextureCoordUnits <= ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits);


   /* Texture size checks */
   assert(ctx->Const.MaxTextureLevels <= MAX_TEXTURE_LEVELS);
   assert(ctx->Const.Max3DTextureLevels <= MAX_3D_TEXTURE_LEVELS);
   assert(ctx->Const.MaxCubeTextureLevels <= MAX_CUBE_TEXTURE_LEVELS);
   assert(ctx->Const.MaxTextureRectSize <= MAX_TEXTURE_RECT_SIZE);

   /* Texture level checks */
   assert(MAX_TEXTURE_LEVELS >= MAX_3D_TEXTURE_LEVELS);
   assert(MAX_TEXTURE_LEVELS >= MAX_CUBE_TEXTURE_LEVELS);

   /* Max texture size should be <= max viewport size (render to texture) */
   assert((1U << (ctx->Const.MaxTextureLevels - 1))
          <= ctx->Const.MaxViewportWidth);
   assert((1U << (ctx->Const.MaxTextureLevels - 1))
          <= ctx->Const.MaxViewportHeight);

   assert(ctx->Const.MaxDrawBuffers <= MAX_DRAW_BUFFERS);

   /* if this fails, add more enum values to gl_buffer_index */
   assert(BUFFER_COLOR0 + MAX_DRAW_BUFFERS <= BUFFER_COUNT);

   /* XXX probably add more tests */
}


/**
 * Initialize the attribute groups in a GL context.
 *
 * \param ctx GL context.
 *
 * Initializes all the attributes, calling the respective <tt>init*</tt>
 * functions for the more complex data structures.
 */
static GLboolean
init_attrib_groups(struct gl_context *ctx)
{
   assert(ctx);

   /* Constants */
   _mesa_init_constants( ctx );

   /* Extensions */
   _mesa_init_extensions( ctx );

   /* Attribute Groups */
   _mesa_init_accum( ctx );
   _mesa_init_attrib( ctx );
   _mesa_init_buffer_objects( ctx );
   _mesa_init_color( ctx );
   _mesa_init_current( ctx );
   _mesa_init_depth( ctx );
   _mesa_init_debug( ctx );
   _mesa_init_display_list( ctx );
   _mesa_init_errors( ctx );
   _mesa_init_eval( ctx );
   _mesa_init_fbobjects( ctx );
   _mesa_init_feedback( ctx );
   _mesa_init_fog( ctx );
   _mesa_init_hint( ctx );
   _mesa_init_line( ctx );
   _mesa_init_lighting( ctx );
   _mesa_init_matrix( ctx );
   _mesa_init_multisample( ctx );
   _mesa_init_performance_monitors( ctx );
   _mesa_init_pipeline( ctx );
   _mesa_init_pixel( ctx );
   _mesa_init_pixelstore( ctx );
   _mesa_init_point( ctx );
   _mesa_init_polygon( ctx );
   _mesa_init_program( ctx );
   _mesa_init_queryobj( ctx );
   _mesa_init_sync( ctx );
   _mesa_init_rastpos( ctx );
   _mesa_init_scissor( ctx );
   _mesa_init_shader_state( ctx );
   _mesa_init_stencil( ctx );
   _mesa_init_transform( ctx );
   _mesa_init_transform_feedback( ctx );
   _mesa_init_varray( ctx );
   _mesa_init_viewport( ctx );

   if (!_mesa_init_texture( ctx ))
      return GL_FALSE;

   _mesa_init_texture_s3tc( ctx );

   /* Miscellaneous */
   ctx->NewState = _NEW_ALL;
   ctx->NewDriverState = ~0;
   ctx->ErrorValue = GL_NO_ERROR;
   ctx->ShareGroupReset = false;
   ctx->varying_vp_inputs = VERT_BIT_ALL;

   return GL_TRUE;
}


/**
 * Update default objects in a GL context with respect to shared state.
 *
 * \param ctx GL context.
 *
 * Removes references to old default objects, (texture objects, program
 * objects, etc.) and changes to reference those from the current shared
 * state.
 */
static GLboolean
update_default_objects(struct gl_context *ctx)
{
   assert(ctx);

   _mesa_update_default_objects_program(ctx);
   _mesa_update_default_objects_texture(ctx);
   _mesa_update_default_objects_buffer_objects(ctx);

   return GL_TRUE;
}


/**
 * This is the default function we plug into all dispatch table slots
 * This helps prevents a segfault when someone calls a GL function without
 * first checking if the extension's supported.
 */
int
_mesa_generic_nop(void)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_error(ctx, GL_INVALID_OPERATION,
               "unsupported function called "
               "(unsupported extension or deprecated function?)");
   return 0;
}


/**
 * Allocate and initialize a new dispatch table.
 */
struct _glapi_table *
_mesa_alloc_dispatch_table()
{
   /* Find the larger of Mesa's dispatch table and libGL's dispatch table.
    * In practice, this'll be the same for stand-alone Mesa.  But for DRI
    * Mesa we do this to accomodate different versions of libGL and various
    * DRI drivers.
    */
   GLint numEntries = MAX2(_glapi_get_dispatch_table_size(), _gloffset_COUNT);
   struct _glapi_table *table;

   table = malloc(numEntries * sizeof(_glapi_proc));
   if (table) {
      _glapi_proc *entry = (_glapi_proc *) table;
      GLint i;
      for (i = 0; i < numEntries; i++) {
         entry[i] = (_glapi_proc) _mesa_generic_nop;
      }
   }
   return table;
}

/**
 * Creates a minimal dispatch table for use within glBegin()/glEnd().
 *
 * This ensures that we generate GL_INVALID_OPERATION errors from most
 * functions, since the set of functions that are valid within Begin/End is
 * very small.
 *
 * From the GL 1.0 specification section 2.6.3, "GL Commands within
 * Begin/End"
 *
 *     "The only GL commands that are allowed within any Begin/End pairs are
 *      the commands for specifying vertex coordinates, vertex color, normal
 *      coordinates, and texture coordinates (Vertex, Color, Index, Normal,
 *      TexCoord), EvalCoord and EvalPoint commands (see section 5.1),
 *      commands for specifying lighting material parameters (Material
 *      commands see section 2.12.2), display list invocation commands
 *      (CallList and CallLists see section 5.4), and the EdgeFlag
 *      command. Executing Begin after Begin has already been executed but
 *      before an End is issued generates the INVALID OPERATION error, as does
 *      executing End without a previous corresponding Begin. Executing any
 *      other GL command within Begin/End results in the error INVALID
 *      OPERATION."
 *
 * The table entries for specifying vertex attributes are set up by
 * install_vtxfmt() and _mesa_loopback_init_api_table(), and End() and dlists
 * are set by install_vtxfmt() as well.
 */
static struct _glapi_table *
create_beginend_table(const struct gl_context *ctx)
{
   struct _glapi_table *table;

   table = _mesa_alloc_dispatch_table();
   if (!table)
      return NULL;

   /* Fill in functions which return a value, since they should return some
    * specific value even if they emit a GL_INVALID_OPERATION error from them
    * being called within glBegin()/glEnd().
    */
#define COPY_DISPATCH(func) SET_##func(table, GET_##func(ctx->Exec))

   COPY_DISPATCH(GenLists);
   COPY_DISPATCH(IsProgram);
   COPY_DISPATCH(IsVertexArray);
   COPY_DISPATCH(IsBuffer);
   COPY_DISPATCH(IsEnabled);
   COPY_DISPATCH(IsEnabledi);
   COPY_DISPATCH(IsRenderbuffer);
   COPY_DISPATCH(IsFramebuffer);
   COPY_DISPATCH(CheckFramebufferStatus);
   COPY_DISPATCH(RenderMode);
   COPY_DISPATCH(GetString);
   COPY_DISPATCH(GetStringi);
   COPY_DISPATCH(GetPointerv);
   COPY_DISPATCH(IsQuery);
   COPY_DISPATCH(IsSampler);
   COPY_DISPATCH(IsSync);
   COPY_DISPATCH(IsTexture);
   COPY_DISPATCH(IsTransformFeedback);
   COPY_DISPATCH(DeleteQueries);
   COPY_DISPATCH(AreTexturesResident);
   COPY_DISPATCH(FenceSync);
   COPY_DISPATCH(ClientWaitSync);
   COPY_DISPATCH(MapBuffer);
   COPY_DISPATCH(UnmapBuffer);
   COPY_DISPATCH(MapBufferRange);
   COPY_DISPATCH(ObjectPurgeableAPPLE);
   COPY_DISPATCH(ObjectUnpurgeableAPPLE);

   _mesa_loopback_init_api_table(ctx, table);

   return table;
}

void
_mesa_initialize_dispatch_tables(struct gl_context *ctx)
{
   /* Do the code-generated setup of the exec table in api_exec.c. */
   _mesa_initialize_exec_table(ctx);

   if (ctx->Save)
      _mesa_initialize_save_table(ctx);
}

/**
 * Initialize a struct gl_context struct (rendering context).
 *
 * This includes allocating all the other structs and arrays which hang off of
 * the context by pointers.
 * Note that the driver needs to pass in its dd_function_table here since
 * we need to at least call driverFunctions->NewTextureObject to create the
 * default texture objects.
 * 
 * Called by _mesa_create_context().
 *
 * Performs the imports and exports callback tables initialization, and
 * miscellaneous one-time initializations. If no shared context is supplied one
 * is allocated, and increase its reference count.  Setups the GL API dispatch
 * tables.  Initialize the TNL module. Sets the maximum Z buffer depth.
 * Finally queries the \c MESA_DEBUG and \c MESA_VERBOSE environment variables
 * for debug flags.
 *
 * \param ctx the context to initialize
 * \param api the GL API type to create the context for
 * \param visual describes the visual attributes for this context or NULL to
 *               create a configless context
 * \param share_list points to context to share textures, display lists,
 *        etc with, or NULL
 * \param driverFunctions table of device driver functions for this context
 *        to use
 */
GLboolean
_mesa_initialize_context(struct gl_context *ctx,
                         gl_api api,
                         const struct gl_config *visual,
                         struct gl_context *share_list,
                         const struct dd_function_table *driverFunctions)
{
   struct gl_shared_state *shared;
   int i;

   assert(driverFunctions->NewTextureObject);
   assert(driverFunctions->FreeTextureImageBuffer);

   ctx->API = api;
   ctx->DrawBuffer = NULL;
   ctx->ReadBuffer = NULL;
   ctx->WinSysDrawBuffer = NULL;
   ctx->WinSysReadBuffer = NULL;

   if (visual) {
      ctx->Visual = *visual;
      ctx->HasConfig = GL_TRUE;
   }
   else {
      memset(&ctx->Visual, 0, sizeof ctx->Visual);
      ctx->HasConfig = GL_FALSE;
   }

   if (_mesa_is_desktop_gl(ctx)) {
      _mesa_override_gl_version(ctx);
   }

   /* misc one-time initializations */
   one_time_init(ctx);

   /* Plug in driver functions and context pointer here.
    * This is important because when we call alloc_shared_state() below
    * we'll call ctx->Driver.NewTextureObject() to create the default
    * textures.
    */
   ctx->Driver = *driverFunctions;

   if (share_list) {
      /* share state with another context */
      shared = share_list->Shared;
   }
   else {
      /* allocate new, unshared state */
      shared = _mesa_alloc_shared_state(ctx);
      if (!shared)
         return GL_FALSE;
   }

   _mesa_reference_shared_state(ctx, &ctx->Shared, shared);

   if (!init_attrib_groups( ctx ))
      goto fail;

   /* setup the API dispatch tables with all nop functions */
   ctx->OutsideBeginEnd = _mesa_alloc_dispatch_table();
   if (!ctx->OutsideBeginEnd)
      goto fail;
   ctx->Exec = ctx->OutsideBeginEnd;
   ctx->CurrentDispatch = ctx->OutsideBeginEnd;

   ctx->FragmentProgram._MaintainTexEnvProgram
      = (_mesa_getenv("MESA_TEX_PROG") != NULL);

   ctx->VertexProgram._MaintainTnlProgram
      = (_mesa_getenv("MESA_TNL_PROG") != NULL);
   if (ctx->VertexProgram._MaintainTnlProgram) {
      /* this is required... */
      ctx->FragmentProgram._MaintainTexEnvProgram = GL_TRUE;
   }

   /* Mesa core handles all the formats that mesa core knows about.
    * Drivers will want to override this list with just the formats
    * they can handle, and confirm that appropriate fallbacks exist in
    * _mesa_choose_tex_format().
    */
   memset(&ctx->TextureFormatSupported, GL_TRUE,
	  sizeof(ctx->TextureFormatSupported));

   switch (ctx->API) {
   case API_OPENGL_COMPAT:
      ctx->BeginEnd = create_beginend_table(ctx);
      ctx->Save = _mesa_alloc_dispatch_table();
      if (!ctx->BeginEnd || !ctx->Save)
         goto fail;

      /* fall-through */
   case API_OPENGL_CORE:
      break;
   case API_OPENGLES:
      /**
       * GL_OES_texture_cube_map says
       * "Initially all texture generation modes are set to REFLECTION_MAP_OES"
       */
      for (i = 0; i < MAX_TEXTURE_UNITS; i++) {
	 struct gl_texture_unit *texUnit = &ctx->Texture.Unit[i];
	 texUnit->GenS.Mode = GL_REFLECTION_MAP_NV;
	 texUnit->GenT.Mode = GL_REFLECTION_MAP_NV;
	 texUnit->GenR.Mode = GL_REFLECTION_MAP_NV;
	 texUnit->GenS._ModeBit = TEXGEN_REFLECTION_MAP_NV;
	 texUnit->GenT._ModeBit = TEXGEN_REFLECTION_MAP_NV;
	 texUnit->GenR._ModeBit = TEXGEN_REFLECTION_MAP_NV;
      }
      break;
   case API_OPENGLES2:
      ctx->FragmentProgram._MaintainTexEnvProgram = GL_TRUE;
      ctx->VertexProgram._MaintainTnlProgram = GL_TRUE;
      break;
   }

   ctx->FirstTimeCurrent = GL_TRUE;

   return GL_TRUE;

fail:
   _mesa_reference_shared_state(ctx, &ctx->Shared, NULL);
   free(ctx->BeginEnd);
   free(ctx->OutsideBeginEnd);
   free(ctx->Save);
   return GL_FALSE;
}


/**
 * Allocate and initialize a struct gl_context structure.
 * Note that the driver needs to pass in its dd_function_table here since
 * we need to at least call driverFunctions->NewTextureObject to initialize
 * the rendering context.
 *
 * \param api the GL API type to create the context for
 * \param visual a struct gl_config pointer (we copy the struct contents) or
 *               NULL to create a configless context
 * \param share_list another context to share display lists with or NULL
 * \param driverFunctions points to the dd_function_table into which the
 *        driver has plugged in all its special functions.
 * 
 * \return pointer to a new __struct gl_contextRec or NULL if error.
 */
struct gl_context *
_mesa_create_context(gl_api api,
                     const struct gl_config *visual,
                     struct gl_context *share_list,
                     const struct dd_function_table *driverFunctions)
{
   struct gl_context *ctx;

   ctx = calloc(1, sizeof(struct gl_context));
   if (!ctx)
      return NULL;

   if (_mesa_initialize_context(ctx, api, visual, share_list,
                                driverFunctions)) {
      return ctx;
   }
   else {
      free(ctx);
      return NULL;
   }
}


/**
 * Free the data associated with the given context.
 * 
 * But doesn't free the struct gl_context struct itself.
 *
 * \sa _mesa_initialize_context() and init_attrib_groups().
 */
void
_mesa_free_context_data( struct gl_context *ctx )
{
   if (!_mesa_get_current_context()){
      /* No current context, but we may need one in order to delete
       * texture objs, etc.  So temporarily bind the context now.
       */
      _mesa_make_current(ctx, NULL, NULL);
   }

   /* unreference WinSysDraw/Read buffers */
   _mesa_reference_framebuffer(&ctx->WinSysDrawBuffer, NULL);
   _mesa_reference_framebuffer(&ctx->WinSysReadBuffer, NULL);
   _mesa_reference_framebuffer(&ctx->DrawBuffer, NULL);
   _mesa_reference_framebuffer(&ctx->ReadBuffer, NULL);

   _mesa_reference_vertprog(ctx, &ctx->VertexProgram.Current, NULL);
   _mesa_reference_vertprog(ctx, &ctx->VertexProgram._Current, NULL);
   _mesa_reference_vertprog(ctx, &ctx->VertexProgram._TnlProgram, NULL);

   _mesa_reference_geomprog(ctx, &ctx->GeometryProgram.Current, NULL);
   _mesa_reference_geomprog(ctx, &ctx->GeometryProgram._Current, NULL);

   _mesa_reference_fragprog(ctx, &ctx->FragmentProgram.Current, NULL);
   _mesa_reference_fragprog(ctx, &ctx->FragmentProgram._Current, NULL);
   _mesa_reference_fragprog(ctx, &ctx->FragmentProgram._TexEnvProgram, NULL);

   _mesa_reference_vao(ctx, &ctx->Array.VAO, NULL);
   _mesa_reference_vao(ctx, &ctx->Array.DefaultVAO, NULL);

   _mesa_free_attrib_data(ctx);
   _mesa_free_buffer_objects(ctx);
   _mesa_free_lighting_data( ctx );
   _mesa_free_eval_data( ctx );
   _mesa_free_texture_data( ctx );
   _mesa_free_matrix_data( ctx );
   _mesa_free_viewport_data( ctx );
   _mesa_free_pipeline_data(ctx);
   _mesa_free_program_data(ctx);
   _mesa_free_shader_state(ctx);
   _mesa_free_queryobj_data(ctx);
   _mesa_free_sync_data(ctx);
   _mesa_free_varray_data(ctx);
   _mesa_free_transform_feedback(ctx);
   _mesa_free_performance_monitors(ctx);

   _mesa_reference_buffer_object(ctx, &ctx->Pack.BufferObj, NULL);
   _mesa_reference_buffer_object(ctx, &ctx->Unpack.BufferObj, NULL);
   _mesa_reference_buffer_object(ctx, &ctx->DefaultPacking.BufferObj, NULL);
   _mesa_reference_buffer_object(ctx, &ctx->Array.ArrayBufferObj, NULL);

   /* free dispatch tables */
   free(ctx->BeginEnd);
   free(ctx->OutsideBeginEnd);
   free(ctx->Save);

   /* Shared context state (display lists, textures, etc) */
   _mesa_reference_shared_state(ctx, &ctx->Shared, NULL);

   /* needs to be after freeing shared state */
   _mesa_free_display_list_data(ctx);

   _mesa_free_errors_data(ctx);

   free((void *)ctx->Extensions.String);

   free(ctx->VersionString);

   /* unbind the context if it's currently bound */
   if (ctx == _mesa_get_current_context()) {
      _mesa_make_current(NULL, NULL, NULL);
   }
}


/**
 * Destroy a struct gl_context structure.
 *
 * \param ctx GL context.
 * 
 * Calls _mesa_free_context_data() and frees the gl_context object itself.
 */
void
_mesa_destroy_context( struct gl_context *ctx )
{
   if (ctx) {
      _mesa_free_context_data(ctx);
      free( (void *) ctx );
   }
}


/**
 * Copy attribute groups from one context to another.
 * 
 * \param src source context
 * \param dst destination context
 * \param mask bitwise OR of GL_*_BIT flags
 *
 * According to the bits specified in \p mask, copies the corresponding
 * attributes from \p src into \p dst.  For many of the attributes a simple \c
 * memcpy is not enough due to the existence of internal pointers in their data
 * structures.
 */
void
_mesa_copy_context( const struct gl_context *src, struct gl_context *dst,
                    GLuint mask )
{
   if (mask & GL_ACCUM_BUFFER_BIT) {
      /* OK to memcpy */
      dst->Accum = src->Accum;
   }
   if (mask & GL_COLOR_BUFFER_BIT) {
      /* OK to memcpy */
      dst->Color = src->Color;
   }
   if (mask & GL_CURRENT_BIT) {
      /* OK to memcpy */
      dst->Current = src->Current;
   }
   if (mask & GL_DEPTH_BUFFER_BIT) {
      /* OK to memcpy */
      dst->Depth = src->Depth;
   }
   if (mask & GL_ENABLE_BIT) {
      /* no op */
   }
   if (mask & GL_EVAL_BIT) {
      /* OK to memcpy */
      dst->Eval = src->Eval;
   }
   if (mask & GL_FOG_BIT) {
      /* OK to memcpy */
      dst->Fog = src->Fog;
   }
   if (mask & GL_HINT_BIT) {
      /* OK to memcpy */
      dst->Hint = src->Hint;
   }
   if (mask & GL_LIGHTING_BIT) {
      GLuint i;
      /* begin with memcpy */
      dst->Light = src->Light;
      /* fixup linked lists to prevent pointer insanity */
      make_empty_list( &(dst->Light.EnabledList) );
      for (i = 0; i < MAX_LIGHTS; i++) {
         if (dst->Light.Light[i].Enabled) {
            insert_at_tail(&(dst->Light.EnabledList), &(dst->Light.Light[i]));
         }
      }
   }
   if (mask & GL_LINE_BIT) {
      /* OK to memcpy */
      dst->Line = src->Line;
   }
   if (mask & GL_LIST_BIT) {
      /* OK to memcpy */
      dst->List = src->List;
   }
   if (mask & GL_PIXEL_MODE_BIT) {
      /* OK to memcpy */
      dst->Pixel = src->Pixel;
   }
   if (mask & GL_POINT_BIT) {
      /* OK to memcpy */
      dst->Point = src->Point;
   }
   if (mask & GL_POLYGON_BIT) {
      /* OK to memcpy */
      dst->Polygon = src->Polygon;
   }
   if (mask & GL_POLYGON_STIPPLE_BIT) {
      /* Use loop instead of memcpy due to problem with Portland Group's
       * C compiler.  Reported by John Stone.
       */
      GLuint i;
      for (i = 0; i < 32; i++) {
         dst->PolygonStipple[i] = src->PolygonStipple[i];
      }
   }
   if (mask & GL_SCISSOR_BIT) {
      /* OK to memcpy */
      dst->Scissor = src->Scissor;
   }
   if (mask & GL_STENCIL_BUFFER_BIT) {
      /* OK to memcpy */
      dst->Stencil = src->Stencil;
   }
   if (mask & GL_TEXTURE_BIT) {
      /* Cannot memcpy because of pointers */
      _mesa_copy_texture_state(src, dst);
   }
   if (mask & GL_TRANSFORM_BIT) {
      /* OK to memcpy */
      dst->Transform = src->Transform;
   }
   if (mask & GL_VIEWPORT_BIT) {
      /* Cannot use memcpy, because of pointers in GLmatrix _WindowMap */
      unsigned i;
      for (i = 0; i < src->Const.MaxViewports; i++) {
         dst->ViewportArray[i].X = src->ViewportArray[i].X;
         dst->ViewportArray[i].Y = src->ViewportArray[i].Y;
         dst->ViewportArray[i].Width = src->ViewportArray[i].Width;
         dst->ViewportArray[i].Height = src->ViewportArray[i].Height;
         dst->ViewportArray[i].Near = src->ViewportArray[i].Near;
         dst->ViewportArray[i].Far = src->ViewportArray[i].Far;
         _math_matrix_copy(&dst->ViewportArray[i]._WindowMap,
                           &src->ViewportArray[i]._WindowMap);
      }
   }

   /* XXX FIXME:  Call callbacks?
    */
   dst->NewState = _NEW_ALL;
   dst->NewDriverState = ~0;
}


/**
 * Check if the given context can render into the given framebuffer
 * by checking visual attributes.
 *
 * Most of these tests could go away because Mesa is now pretty flexible
 * in terms of mixing rendering contexts with framebuffers.  As long
 * as RGB vs. CI mode agree, we're probably good.
 *
 * \return GL_TRUE if compatible, GL_FALSE otherwise.
 */
static GLboolean 
check_compatible(const struct gl_context *ctx,
                 const struct gl_framebuffer *buffer)
{
   const struct gl_config *ctxvis = &ctx->Visual;
   const struct gl_config *bufvis = &buffer->Visual;

   if (buffer == _mesa_get_incomplete_framebuffer())
      return GL_TRUE;

#if 0
   /* disabling this fixes the fgl_glxgears pbuffer demo */
   if (ctxvis->doubleBufferMode && !bufvis->doubleBufferMode)
      return GL_FALSE;
#endif
   if (ctxvis->stereoMode && !bufvis->stereoMode)
      return GL_FALSE;
   if (ctxvis->haveAccumBuffer && !bufvis->haveAccumBuffer)
      return GL_FALSE;
   if (ctxvis->haveDepthBuffer && !bufvis->haveDepthBuffer)
      return GL_FALSE;
   if (ctxvis->haveStencilBuffer && !bufvis->haveStencilBuffer)
      return GL_FALSE;
   if (ctxvis->redMask && ctxvis->redMask != bufvis->redMask)
      return GL_FALSE;
   if (ctxvis->greenMask && ctxvis->greenMask != bufvis->greenMask)
      return GL_FALSE;
   if (ctxvis->blueMask && ctxvis->blueMask != bufvis->blueMask)
      return GL_FALSE;
#if 0
   /* disabled (see bug 11161) */
   if (ctxvis->depthBits && ctxvis->depthBits != bufvis->depthBits)
      return GL_FALSE;
#endif
   if (ctxvis->stencilBits && ctxvis->stencilBits != bufvis->stencilBits)
      return GL_FALSE;

   return GL_TRUE;
}


/**
 * Check if the viewport/scissor size has not yet been initialized.
 * Initialize the size if the given width and height are non-zero.
 */
void
_mesa_check_init_viewport(struct gl_context *ctx, GLuint width, GLuint height)
{
   if (!ctx->ViewportInitialized && width > 0 && height > 0) {
      unsigned i;

      /* Note: set flag here, before calling _mesa_set_viewport(), to prevent
       * potential infinite recursion.
       */
      ctx->ViewportInitialized = GL_TRUE;

      /* Note: ctx->Const.MaxViewports may not have been set by the driver
       * yet, so just initialize all of them.
       */
      for (i = 0; i < MAX_VIEWPORTS; i++) {
         _mesa_set_viewport(ctx, i, 0, 0, width, height);
         _mesa_set_scissor(ctx, i, 0, 0, width, height);
      }
   }
}

static void
handle_first_current(struct gl_context *ctx)
{
   GLenum buffer;
   GLint bufferIndex;

   assert(ctx->Version > 0);

   ctx->Extensions.String = _mesa_make_extension_string(ctx);

   check_context_limits(ctx);

   /* According to GL_MESA_configless_context the default value of
    * glDrawBuffers depends on the config of the first surface it is bound to.
    * For GLES it is always GL_BACK which has a magic interpretation */
   if (!ctx->HasConfig && _mesa_is_desktop_gl(ctx)) {
      if (ctx->DrawBuffer != _mesa_get_incomplete_framebuffer()) {
         if (ctx->DrawBuffer->Visual.doubleBufferMode)
            buffer = GL_BACK;
         else
            buffer = GL_FRONT;

         _mesa_drawbuffers(ctx, 1, &buffer, NULL /* destMask */);
      }

      if (ctx->ReadBuffer != _mesa_get_incomplete_framebuffer()) {
         if (ctx->ReadBuffer->Visual.doubleBufferMode) {
            buffer = GL_BACK;
            bufferIndex = BUFFER_BACK_LEFT;
         }
         else {
            buffer = GL_FRONT;
            bufferIndex = BUFFER_FRONT_LEFT;
         }

         _mesa_readbuffer(ctx, buffer, bufferIndex);
      }
   }

   /* We can use this to help debug user's problems.  Tell them to set
    * the MESA_INFO env variable before running their app.  Then the
    * first time each context is made current we'll print some useful
    * information.
    */
   if (_mesa_getenv("MESA_INFO")) {
      _mesa_print_info(ctx);
   }
}

/**
 * Bind the given context to the given drawBuffer and readBuffer and
 * make it the current context for the calling thread.
 * We'll render into the drawBuffer and read pixels from the
 * readBuffer (i.e. glRead/CopyPixels, glCopyTexImage, etc).
 *
 * We check that the context's and framebuffer's visuals are compatible
 * and return immediately if they're not.
 *
 * \param newCtx  the new GL context. If NULL then there will be no current GL
 *                context.
 * \param drawBuffer  the drawing framebuffer
 * \param readBuffer  the reading framebuffer
 */
GLboolean
_mesa_make_current( struct gl_context *newCtx,
                    struct gl_framebuffer *drawBuffer,
                    struct gl_framebuffer *readBuffer )
{
   GET_CURRENT_CONTEXT(curCtx);

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(newCtx, "_mesa_make_current()\n");

   /* Check that the context's and framebuffer's visuals are compatible.
    */
   if (newCtx && drawBuffer && newCtx->WinSysDrawBuffer != drawBuffer) {
      if (!check_compatible(newCtx, drawBuffer)) {
         _mesa_warning(newCtx,
              "MakeCurrent: incompatible visuals for context and drawbuffer");
         return GL_FALSE;
      }
   }
   if (newCtx && readBuffer && newCtx->WinSysReadBuffer != readBuffer) {
      if (!check_compatible(newCtx, readBuffer)) {
         _mesa_warning(newCtx,
              "MakeCurrent: incompatible visuals for context and readbuffer");
         return GL_FALSE;
      }
   }

   if (curCtx && 
      (curCtx->WinSysDrawBuffer || curCtx->WinSysReadBuffer) &&
       /* make sure this context is valid for flushing */
      curCtx != newCtx)
      _mesa_flush(curCtx);

   /* We used to call _glapi_check_multithread() here.  Now do it in drivers */
   _glapi_set_context((void *) newCtx);
   ASSERT(_mesa_get_current_context() == newCtx);

   if (!newCtx) {
      _glapi_set_dispatch(NULL);  /* none current */
   }
   else {
      _glapi_set_dispatch(newCtx->CurrentDispatch);

      if (drawBuffer && readBuffer) {
         ASSERT(_mesa_is_winsys_fbo(drawBuffer));
         ASSERT(_mesa_is_winsys_fbo(readBuffer));
         _mesa_reference_framebuffer(&newCtx->WinSysDrawBuffer, drawBuffer);
         _mesa_reference_framebuffer(&newCtx->WinSysReadBuffer, readBuffer);

         /*
          * Only set the context's Draw/ReadBuffer fields if they're NULL
          * or not bound to a user-created FBO.
          */
         if (!newCtx->DrawBuffer || _mesa_is_winsys_fbo(newCtx->DrawBuffer)) {
            _mesa_reference_framebuffer(&newCtx->DrawBuffer, drawBuffer);
            /* Update the FBO's list of drawbuffers/renderbuffers.
             * For winsys FBOs this comes from the GL state (which may have
             * changed since the last time this FBO was bound).
             */
            _mesa_update_draw_buffers(newCtx);
         }
         if (!newCtx->ReadBuffer || _mesa_is_winsys_fbo(newCtx->ReadBuffer)) {
            _mesa_reference_framebuffer(&newCtx->ReadBuffer, readBuffer);
         }

         /* XXX only set this flag if we're really changing the draw/read
          * framebuffer bindings.
          */
	 newCtx->NewState |= _NEW_BUFFERS;

         if (drawBuffer) {
            _mesa_check_init_viewport(newCtx,
                                      drawBuffer->Width, drawBuffer->Height);
         }
      }

      if (newCtx->FirstTimeCurrent) {
         handle_first_current(newCtx);
	 newCtx->FirstTimeCurrent = GL_FALSE;
      }
   }
   
   return GL_TRUE;
}


/**
 * Make context 'ctx' share the display lists, textures and programs
 * that are associated with 'ctxToShare'.
 * Any display lists, textures or programs associated with 'ctx' will
 * be deleted if nobody else is sharing them.
 */
GLboolean
_mesa_share_state(struct gl_context *ctx, struct gl_context *ctxToShare)
{
   if (ctx && ctxToShare && ctx->Shared && ctxToShare->Shared) {
      struct gl_shared_state *oldShared = NULL;

      /* save ref to old state to prevent it from being deleted immediately */
      _mesa_reference_shared_state(ctx, &oldShared, ctx->Shared);

      /* update ctx's Shared pointer */
      _mesa_reference_shared_state(ctx, &ctx->Shared, ctxToShare->Shared);

      update_default_objects(ctx);

      /* release the old shared state */
      _mesa_reference_shared_state(ctx, &oldShared, NULL);

      return GL_TRUE;
   }
   else {
      return GL_FALSE;
   }
}



/**
 * \return pointer to the current GL context for this thread.
 * 
 * Calls _glapi_get_context(). This isn't the fastest way to get the current
 * context.  If you need speed, see the #GET_CURRENT_CONTEXT macro in
 * context.h.
 */
struct gl_context *
_mesa_get_current_context( void )
{
   return (struct gl_context *) _glapi_get_context();
}


/**
 * Get context's current API dispatch table.
 *
 * It'll either be the immediate-mode execute dispatcher or the display list
 * compile dispatcher.
 * 
 * \param ctx GL context.
 *
 * \return pointer to dispatch_table.
 *
 * Simply returns __struct gl_contextRec::CurrentDispatch.
 */
struct _glapi_table *
_mesa_get_dispatch(struct gl_context *ctx)
{
   return ctx->CurrentDispatch;
}

/*@@}*/


/**********************************************************************/
/** \name Miscellaneous functions                                     */
/**********************************************************************/
/*@@{*/

/**
 * Record an error.
 *
 * \param ctx GL context.
 * \param error error code.
 * 
 * Records the given error code and call the driver's dd_function_table::Error
 * function if defined.
 *
 * \sa
 * This is called via _mesa_error().
 */
void
_mesa_record_error(struct gl_context *ctx, GLenum error)
{
   if (!ctx)
      return;

   if (ctx->ErrorValue == GL_NO_ERROR) {
      ctx->ErrorValue = error;
   }
}


/**
 * Flush commands and wait for completion.
 */
void
_mesa_finish(struct gl_context *ctx)
{
   FLUSH_VERTICES( ctx, 0 );
   FLUSH_CURRENT( ctx, 0 );
   if (ctx->Driver.Finish) {
      ctx->Driver.Finish(ctx);
   }
}


/**
 * Flush commands.
 */
void
_mesa_flush(struct gl_context *ctx)
{
   FLUSH_VERTICES( ctx, 0 );
   FLUSH_CURRENT( ctx, 0 );
   if (ctx->Driver.Flush) {
      ctx->Driver.Flush(ctx);
   }
}



/**
 * Execute glFinish().
 *
 * Calls the #ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH macro and the
 * dd_function_table::Finish driver callback, if not NULL.
 */
void GLAPIENTRY
_mesa_Finish(void)
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END(ctx);
   _mesa_finish(ctx);
}


/**
 * Execute glFlush().
 *
 * Calls the #ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH macro and the
 * dd_function_table::Flush driver callback, if not NULL.
 */
void GLAPIENTRY
_mesa_Flush(void)
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END(ctx);
   _mesa_flush(ctx);
}


/*
 * ARB_blend_func_extended - ERRORS section
 * "The error INVALID_OPERATION is generated by Begin or any procedure that
 *  implicitly calls Begin if any draw buffer has a blend function requiring the
 *  second color input (SRC1_COLOR, ONE_MINUS_SRC1_COLOR, SRC1_ALPHA or
 *  ONE_MINUS_SRC1_ALPHA), and a framebuffer is bound that has more than
 *  the value of MAX_DUAL_SOURCE_DRAW_BUFFERS-1 active color attachements."
 */
static GLboolean
_mesa_check_blend_func_error(struct gl_context *ctx)
{
   GLuint i;
   for (i = ctx->Const.MaxDualSourceDrawBuffers;
	i < ctx->DrawBuffer->_NumColorDrawBuffers;
	i++) {
      if (ctx->Color.Blend[i]._UsesDualSrc) {
	 _mesa_error(ctx, GL_INVALID_OPERATION,
		     "dual source blend on illegal attachment");
	 return GL_FALSE;
      }
   }
   return GL_TRUE;
}

static bool
shader_linked_or_absent(struct gl_context *ctx,
                        const struct gl_shader_program *shProg,
                        bool *shader_present, const char *where)
{
   if (shProg) {
      *shader_present = true;

      if (!shProg->LinkStatus) {
         _mesa_error(ctx, GL_INVALID_OPERATION, "%s(shader not linked)", where);
         return false;
      }
#if 0 /* not normally enabled */
      {
         char errMsg[100];
         if (!_mesa_validate_shader_program(ctx, shProg, errMsg)) {
            _mesa_warning(ctx, "Shader program %u is invalid: %s",
                          shProg->Name, errMsg);
         }
      }
#endif
   }

   return true;
}

/**
 * Prior to drawing anything with glBegin, glDrawArrays, etc. this function
 * is called to see if it's valid to render.  This involves checking that
 * the current shader is valid and the framebuffer is complete.
 * It also check the current pipeline object is valid if any.
 * If an error is detected it'll be recorded here.
 * \return GL_TRUE if OK to render, GL_FALSE if not
 */
GLboolean
_mesa_valid_to_render(struct gl_context *ctx, const char *where)
{
   bool from_glsl_shader[MESA_SHADER_COMPUTE] = { false };
   unsigned i;

   /* This depends on having up to date derived state (shaders) */
   if (ctx->NewState)
      _mesa_update_state(ctx);

   for (i = 0; i < MESA_SHADER_COMPUTE; i++) {
      if (!shader_linked_or_absent(ctx, ctx->_Shader->CurrentProgram[i],
                                   &from_glsl_shader[i], where))
         return GL_FALSE;
   }

   /* Any shader stages that are not supplied by the GLSL shader and have
    * assembly shaders enabled must now be validated.
    */
   if (!from_glsl_shader[MESA_SHADER_VERTEX]
       && ctx->VertexProgram.Enabled && !ctx->VertexProgram._Enabled) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
		  "%s(vertex program not valid)", where);
      return GL_FALSE;
   }

   /* FINISHME: If GL_NV_geometry_program4 is ever supported, the current
    * FINISHME: geometry program should validated here.
    */
   (void) from_glsl_shader[MESA_SHADER_GEOMETRY];

   if (!from_glsl_shader[MESA_SHADER_FRAGMENT]) {
      if (ctx->FragmentProgram.Enabled && !ctx->FragmentProgram._Enabled) {
	 _mesa_error(ctx, GL_INVALID_OPERATION,
		     "%s(fragment program not valid)", where);
	 return GL_FALSE;
      }

      /* If drawing to integer-valued color buffers, there must be an
       * active fragment shader (GL_EXT_texture_integer).
       */
      if (ctx->DrawBuffer && ctx->DrawBuffer->_IntegerColor) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "%s(integer format but no fragment shader)", where);
         return GL_FALSE;
      }
   }

   /* A pipeline object is bound */
   if (ctx->_Shader->Name && !ctx->_Shader->Validated) {
      /* Error message will be printed inside _mesa_validate_program_pipeline.
       */
      if (!_mesa_validate_program_pipeline(ctx, ctx->_Shader, GL_TRUE)) {
         return GL_FALSE;
      }
   }

   if (ctx->DrawBuffer->_Status != GL_FRAMEBUFFER_COMPLETE_EXT) {
      _mesa_error(ctx, GL_INVALID_FRAMEBUFFER_OPERATION_EXT,
                  "%s(incomplete framebuffer)", where);
      return GL_FALSE;
   }

   if (_mesa_check_blend_func_error(ctx) == GL_FALSE) {
      return GL_FALSE;
   }

#ifdef DEBUG
   if (ctx->_Shader->Flags & GLSL_LOG) {
      struct gl_shader_program **shProg = ctx->_Shader->CurrentProgram;
      gl_shader_stage i;

      for (i = 0; i < MESA_SHADER_STAGES; i++) {
	 if (shProg[i] == NULL || shProg[i]->_Used
	     || shProg[i]->_LinkedShaders[i] == NULL)
	    continue;

	 /* This is the first time this shader is being used.
	  * Append shader's constants/uniforms to log file.
	  *
	  * Only log data for the program target that matches the shader
	  * target.  It's possible to have a program bound to the vertex
	  * shader target that also supplied a fragment shader.  If that
	  * program isn't also bound to the fragment shader target we don't
	  * want to log its fragment data.
	  */
	 _mesa_append_uniforms_to_file(shProg[i]->_LinkedShaders[i]);
      }

      for (i = 0; i < MESA_SHADER_STAGES; i++) {
	 if (shProg[i] != NULL)
	    shProg[i]->_Used = GL_TRUE;
      }
   }
#endif

   return GL_TRUE;
}


/*@@}*/
@


1.15
log
@Merge Mesa 10.2.9
@
text
@@


1.14
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a135 1
#include "uniforms.h"
a398 2
      _mesa_one_time_init_extension_overrides();

d465 1
a465 1
init_program_limits(struct gl_constants *consts, gl_shader_stage stage,
d547 1
a547 1
                                         consts->MaxUniformBlockSize / 4 *
d560 2
a561 2
void
_mesa_init_constants(struct gl_constants *consts, gl_api api)
d564 1
a564 1
   assert(consts);
d567 33
a599 33
   consts->MaxTextureMbytes = MAX_TEXTURE_MBYTES;
   consts->MaxTextureLevels = MAX_TEXTURE_LEVELS;
   consts->Max3DTextureLevels = MAX_3D_TEXTURE_LEVELS;
   consts->MaxCubeTextureLevels = MAX_CUBE_TEXTURE_LEVELS;
   consts->MaxTextureRectSize = MAX_TEXTURE_RECT_SIZE;
   consts->MaxArrayTextureLayers = MAX_ARRAY_TEXTURE_LAYERS;
   consts->MaxTextureCoordUnits = MAX_TEXTURE_COORD_UNITS;
   consts->Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits = MAX_TEXTURE_IMAGE_UNITS;
   consts->MaxTextureUnits = MIN2(consts->MaxTextureCoordUnits,
                                     consts->Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits);
   consts->MaxTextureMaxAnisotropy = MAX_TEXTURE_MAX_ANISOTROPY;
   consts->MaxTextureLodBias = MAX_TEXTURE_LOD_BIAS;
   consts->MaxTextureBufferSize = 65536;
   consts->TextureBufferOffsetAlignment = 1;
   consts->MaxArrayLockSize = MAX_ARRAY_LOCK_SIZE;
   consts->SubPixelBits = SUB_PIXEL_BITS;
   consts->MinPointSize = MIN_POINT_SIZE;
   consts->MaxPointSize = MAX_POINT_SIZE;
   consts->MinPointSizeAA = MIN_POINT_SIZE;
   consts->MaxPointSizeAA = MAX_POINT_SIZE;
   consts->PointSizeGranularity = (GLfloat) POINT_SIZE_GRANULARITY;
   consts->MinLineWidth = MIN_LINE_WIDTH;
   consts->MaxLineWidth = MAX_LINE_WIDTH;
   consts->MinLineWidthAA = MIN_LINE_WIDTH;
   consts->MaxLineWidthAA = MAX_LINE_WIDTH;
   consts->LineWidthGranularity = (GLfloat) LINE_WIDTH_GRANULARITY;
   consts->MaxClipPlanes = 6;
   consts->MaxLights = MAX_LIGHTS;
   consts->MaxShininess = 128.0;
   consts->MaxSpotExponent = 128.0;
   consts->MaxViewportWidth = MAX_VIEWPORT_WIDTH;
   consts->MaxViewportHeight = MAX_VIEWPORT_HEIGHT;
   consts->MinMapBufferAlignment = 64;
d602 4
a605 4
   consts->MaxViewports = 1;
   consts->ViewportSubpixelBits = 0;
   consts->ViewportBounds.Min = 0;
   consts->ViewportBounds.Max = 0;
d608 4
a611 8
   consts->MaxCombinedUniformBlocks = 36;
   consts->MaxUniformBufferBindings = 36;
   consts->MaxUniformBlockSize = 16384;
   consts->UniformBufferOffsetAlignment = 1;

   /* GL_ARB_explicit_uniform_location, GL_MAX_UNIFORM_LOCATIONS */
   consts->MaxUserAssignableUniformLocations =
      4 * MESA_SHADER_STAGES * MAX_UNIFORMS;
d614 1
a614 1
      init_program_limits(consts, i, &consts->Program[i]);
d616 2
a617 2
   consts->MaxProgramMatrices = MAX_PROGRAM_MATRICES;
   consts->MaxProgramMatrixStackDepth = MAX_PROGRAM_MATRIX_STACK_DEPTH;
d619 2
a620 5
   /* Assume that if GLSL 1.30+ (or GLSL ES 3.00+) is supported that
    * gl_VertexID is implemented using a native hardware register with OpenGL
    * semantics.
    */
   consts->VertexID_is_zero_based = false;
d623 1
a623 1
   consts->MaxDrawBuffers = MAX_DRAW_BUFFERS;
d625 2
a626 2
   consts->MaxColorAttachments = MAX_COLOR_ATTACHMENTS;
   consts->MaxRenderbufferSize = MAX_RENDERBUFFER_SIZE;
d628 6
a633 6
   consts->Program[MESA_SHADER_VERTEX].MaxTextureImageUnits = MAX_TEXTURE_IMAGE_UNITS;
   consts->MaxCombinedTextureImageUnits = MAX_COMBINED_TEXTURE_IMAGE_UNITS;
   consts->MaxVarying = 16; /* old limit not to break tnl and swrast */
   consts->Program[MESA_SHADER_GEOMETRY].MaxTextureImageUnits = MAX_TEXTURE_IMAGE_UNITS;
   consts->MaxGeometryOutputVertices = MAX_GEOMETRY_OUTPUT_VERTICES;
   consts->MaxGeometryTotalOutputComponents = MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS;
d636 10
a645 8
   consts->GLSLVersion = 120;
   _mesa_override_glsl_version(consts);

#ifdef DEBUG
   consts->GenerateTemporaryNames = true;
#else
   consts->GenerateTemporaryNames = false;
#endif
d648 1
a648 1
   consts->MaxSamples = 0;
d651 1
a651 1
   consts->UniformBooleanTrue = FLT_AS_UINT(1.0f);
d654 4
a657 1
   consts->MaxServerWaitTimeout = 0x1fff7fffffffULL;
d660 1
a660 1
   consts->QuadsFollowProvokingVertexConvention = GL_TRUE;
d663 4
a666 4
   consts->MaxTransformFeedbackBuffers = MAX_FEEDBACK_BUFFERS;
   consts->MaxTransformFeedbackSeparateComponents = 4 * MAX_FEEDBACK_ATTRIBS;
   consts->MaxTransformFeedbackInterleavedComponents = 4 * MAX_FEEDBACK_ATTRIBS;
   consts->MaxVertexStreams = 1;
d669 1
a669 1
   consts->ProfileMask = api == API_OPENGL_CORE
a672 3
   /* GL 4.4 */
   consts->MaxVertexAttribStride = 2048;

d674 2
a675 2
   consts->MinProgramTexelOffset = -8;
   consts->MaxProgramTexelOffset = 7;
d678 2
a679 2
   consts->MinProgramTextureGatherOffset = -8;
   consts->MaxProgramTextureGatherOffset = 7;
d682 4
a685 1
   consts->ResetStrategy = GL_NO_RESET_NOTIFICATION_ARB;
d688 1
a688 1
   consts->MaxElementIndex = 0xffffffffu;
d691 3
a693 3
   consts->MaxColorTextureSamples = 1;
   consts->MaxDepthTextureSamples = 1;
   consts->MaxIntegerSamples = 1;
d696 4
a699 4
   consts->MaxAtomicBufferBindings = MAX_COMBINED_ATOMIC_BUFFERS;
   consts->MaxAtomicBufferSize = MAX_ATOMIC_COUNTERS * ATOMIC_COUNTER_SIZE;
   consts->MaxCombinedAtomicBuffers = MAX_COMBINED_ATOMIC_BUFFERS;
   consts->MaxCombinedAtomicCounters = MAX_ATOMIC_COUNTERS;
d702 2
a703 2
   consts->MaxVertexAttribRelativeOffset = 2047;
   consts->MaxVertexAttribBindings = MAX_VERTEX_GENERIC_ATTRIBS;
d706 7
a712 7
   consts->MaxComputeWorkGroupCount[0] = 65535;
   consts->MaxComputeWorkGroupCount[1] = 65535;
   consts->MaxComputeWorkGroupCount[2] = 65535;
   consts->MaxComputeWorkGroupSize[0] = 1024;
   consts->MaxComputeWorkGroupSize[1] = 1024;
   consts->MaxComputeWorkGroupSize[2] = 64;
   consts->MaxComputeWorkGroupInvocations = 1024;
d715 2
a716 5
   consts->MinFragmentInterpolationOffset = MIN_FRAGMENT_INTERPOLATION_OFFSET;
   consts->MaxFragmentInterpolationOffset = MAX_FRAGMENT_INTERPOLATION_OFFSET;

   /** GL_KHR_context_flush_control */
   consts->ContextReleaseBehavior = GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH;
a726 2
   (void) ctx;

d793 1
a793 1
   _mesa_init_constants(&ctx->Const, ctx->API);
d796 1
a796 1
   _mesa_init_extensions(&ctx->Extensions);
d890 1
a890 15
 * Special no-op glFlush, see below.
 */
#if defined(_WIN32)
static void GLAPIENTRY
nop_glFlush(void)
{
   /* don't record an error like we do in _mesa_generic_nop() */
}
#endif


/**
 * Allocate and initialize a new dispatch table.  All the dispatch
 * function pointers will point at the _mesa_generic_nop() function
 * which raises GL_INVALID_OPERATION.
d893 1
a893 1
_mesa_alloc_dispatch_table(void)
a909 20

#if defined(_WIN32)
      /* This is a special case for Windows in the event that
       * wglGetProcAddress is called between glBegin/End().
       *
       * The MS opengl32.dll library apparently calls glFlush from
       * wglGetProcAddress().  If we're inside glBegin/End(), glFlush
       * will dispatch to _mesa_generic_nop() and we'll generate a
       * GL_INVALID_OPERATION error.
       *
       * The specific case which hits this is piglit's primitive-restart
       * test which calls glPrimitiveRestartNV() inside glBegin/End.  The
       * first time we call glPrimitiveRestartNV() Piglit's API dispatch
       * code will try to resolve the function by calling wglGetProcAddress.
       * This raises GL_INVALID_OPERATION and an assert(glGetError()==0)
       * will fail causing the test to fail.  By suppressing the error, the
       * assertion passes and the test continues.
       */
      SET_Flush(table, nop_glFlush);
#endif
d1092 1
a1092 1
      = (getenv("MESA_TEX_PROG") != NULL);
d1095 1
a1095 1
      = (getenv("MESA_TNL_PROG") != NULL);
d1498 1
a1498 4
   if (ctx->Version == 0) {
      /* probably in the process of tearing down the context */
      return;
   }
d1536 1
a1536 1
   if (getenv("MESA_INFO")) {
d1583 1
a1583 1
       (curCtx->WinSysDrawBuffer || curCtx->WinSysReadBuffer) &&
d1585 1
a1585 3
       curCtx != newCtx &&
       curCtx->Const.ContextReleaseBehavior ==
       GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH)
a1906 11
         return GL_FALSE;
      }
   }

   /* If a program is active and SSO not in use, check if validation of
    * samplers succeeded for the active program. */
   if (ctx->_Shader->ActiveProgram && ctx->_Shader != ctx->Pipeline.Current) {
      char errMsg[100];
      if (!_mesa_sampler_uniforms_are_valid(ctx->_Shader->ActiveProgram,
                                            errMsg, 100)) {
         _mesa_error(ctx, GL_INVALID_OPERATION, "%s", errMsg);
@


1.13
log
@Merge Mesa 10.2.7
@
text
@d136 1
d400 2
d468 1
a468 1
init_program_limits(struct gl_context *ctx, gl_shader_stage stage,
d550 1
a550 1
                                         ctx->Const.MaxUniformBlockSize / 4 *
d563 2
a564 2
static void 
_mesa_init_constants(struct gl_context *ctx)
d567 1
a567 1
   assert(ctx);
d570 33
a602 33
   ctx->Const.MaxTextureMbytes = MAX_TEXTURE_MBYTES;
   ctx->Const.MaxTextureLevels = MAX_TEXTURE_LEVELS;
   ctx->Const.Max3DTextureLevels = MAX_3D_TEXTURE_LEVELS;
   ctx->Const.MaxCubeTextureLevels = MAX_CUBE_TEXTURE_LEVELS;
   ctx->Const.MaxTextureRectSize = MAX_TEXTURE_RECT_SIZE;
   ctx->Const.MaxArrayTextureLayers = MAX_ARRAY_TEXTURE_LAYERS;
   ctx->Const.MaxTextureCoordUnits = MAX_TEXTURE_COORD_UNITS;
   ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits = MAX_TEXTURE_IMAGE_UNITS;
   ctx->Const.MaxTextureUnits = MIN2(ctx->Const.MaxTextureCoordUnits,
                                     ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits);
   ctx->Const.MaxTextureMaxAnisotropy = MAX_TEXTURE_MAX_ANISOTROPY;
   ctx->Const.MaxTextureLodBias = MAX_TEXTURE_LOD_BIAS;
   ctx->Const.MaxTextureBufferSize = 65536;
   ctx->Const.TextureBufferOffsetAlignment = 1;
   ctx->Const.MaxArrayLockSize = MAX_ARRAY_LOCK_SIZE;
   ctx->Const.SubPixelBits = SUB_PIXEL_BITS;
   ctx->Const.MinPointSize = MIN_POINT_SIZE;
   ctx->Const.MaxPointSize = MAX_POINT_SIZE;
   ctx->Const.MinPointSizeAA = MIN_POINT_SIZE;
   ctx->Const.MaxPointSizeAA = MAX_POINT_SIZE;
   ctx->Const.PointSizeGranularity = (GLfloat) POINT_SIZE_GRANULARITY;
   ctx->Const.MinLineWidth = MIN_LINE_WIDTH;
   ctx->Const.MaxLineWidth = MAX_LINE_WIDTH;
   ctx->Const.MinLineWidthAA = MIN_LINE_WIDTH;
   ctx->Const.MaxLineWidthAA = MAX_LINE_WIDTH;
   ctx->Const.LineWidthGranularity = (GLfloat) LINE_WIDTH_GRANULARITY;
   ctx->Const.MaxClipPlanes = 6;
   ctx->Const.MaxLights = MAX_LIGHTS;
   ctx->Const.MaxShininess = 128.0;
   ctx->Const.MaxSpotExponent = 128.0;
   ctx->Const.MaxViewportWidth = MAX_VIEWPORT_WIDTH;
   ctx->Const.MaxViewportHeight = MAX_VIEWPORT_HEIGHT;
   ctx->Const.MinMapBufferAlignment = 64;
d605 4
a608 4
   ctx->Const.MaxViewports = 1;
   ctx->Const.ViewportSubpixelBits = 0;
   ctx->Const.ViewportBounds.Min = 0;
   ctx->Const.ViewportBounds.Max = 0;
d611 8
a618 4
   ctx->Const.MaxCombinedUniformBlocks = 36;
   ctx->Const.MaxUniformBufferBindings = 36;
   ctx->Const.MaxUniformBlockSize = 16384;
   ctx->Const.UniformBufferOffsetAlignment = 1;
d621 1
a621 1
      init_program_limits(ctx, i, &ctx->Const.Program[i]);
d623 2
a624 2
   ctx->Const.MaxProgramMatrices = MAX_PROGRAM_MATRICES;
   ctx->Const.MaxProgramMatrixStackDepth = MAX_PROGRAM_MATRIX_STACK_DEPTH;
d626 5
a630 2
   /* CheckArrayBounds is overriden by drivers/x11 for X server */
   ctx->Const.CheckArrayBounds = GL_FALSE;
d633 1
a633 1
   ctx->Const.MaxDrawBuffers = MAX_DRAW_BUFFERS;
d635 2
a636 2
   ctx->Const.MaxColorAttachments = MAX_COLOR_ATTACHMENTS;
   ctx->Const.MaxRenderbufferSize = MAX_RENDERBUFFER_SIZE;
d638 6
a643 6
   ctx->Const.Program[MESA_SHADER_VERTEX].MaxTextureImageUnits = MAX_TEXTURE_IMAGE_UNITS;
   ctx->Const.MaxCombinedTextureImageUnits = MAX_COMBINED_TEXTURE_IMAGE_UNITS;
   ctx->Const.MaxVarying = 16; /* old limit not to break tnl and swrast */
   ctx->Const.Program[MESA_SHADER_GEOMETRY].MaxTextureImageUnits = MAX_TEXTURE_IMAGE_UNITS;
   ctx->Const.MaxGeometryOutputVertices = MAX_GEOMETRY_OUTPUT_VERTICES;
   ctx->Const.MaxGeometryTotalOutputComponents = MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS;
d646 8
a653 10
   if (_mesa_is_desktop_gl(ctx)) {
      ctx->Const.GLSLVersion = 120;
      _mesa_override_glsl_version(ctx);
   }
   else if (ctx->API == API_OPENGLES2) {
      ctx->Const.GLSLVersion = 100;
   }
   else if (ctx->API == API_OPENGLES) {
      ctx->Const.GLSLVersion = 0; /* GLSL not supported */
   }
d656 4
a659 1
   ctx->Const.MaxSamples = 0;
d662 1
a662 4
   ctx->Const.MaxServerWaitTimeout = 0x1fff7fffffffULL;

   /* GL_ATI_envmap_bumpmap */
   ctx->Const.SupportedBumpUnits = SUPPORTED_ATI_BUMP_UNITS;
d665 1
a665 1
   ctx->Const.QuadsFollowProvokingVertexConvention = GL_TRUE;
d668 4
a671 4
   ctx->Const.MaxTransformFeedbackBuffers = MAX_FEEDBACK_BUFFERS;
   ctx->Const.MaxTransformFeedbackSeparateComponents = 4 * MAX_FEEDBACK_ATTRIBS;
   ctx->Const.MaxTransformFeedbackInterleavedComponents = 4 * MAX_FEEDBACK_ATTRIBS;
   ctx->Const.MaxVertexStreams = 1;
d674 1
a674 1
   ctx->Const.ProfileMask = ctx->API == API_OPENGL_CORE
d678 3
d682 2
a683 2
   ctx->Const.MinProgramTexelOffset = -8;
   ctx->Const.MaxProgramTexelOffset = 7;
d686 2
a687 2
   ctx->Const.MinProgramTextureGatherOffset = -8;
   ctx->Const.MaxProgramTextureGatherOffset = 7;
d690 1
a690 4
   ctx->Const.ResetStrategy = GL_NO_RESET_NOTIFICATION_ARB;

   /* PrimitiveRestart */
   ctx->Const.PrimitiveRestartInSoftware = GL_FALSE;
d693 1
a693 1
   ctx->Const.MaxElementIndex = 0xffffffffu;
d696 3
a698 3
   ctx->Const.MaxColorTextureSamples = 1;
   ctx->Const.MaxDepthTextureSamples = 1;
   ctx->Const.MaxIntegerSamples = 1;
d701 4
a704 4
   ctx->Const.MaxAtomicBufferBindings = MAX_COMBINED_ATOMIC_BUFFERS;
   ctx->Const.MaxAtomicBufferSize = MAX_ATOMIC_COUNTERS * ATOMIC_COUNTER_SIZE;
   ctx->Const.MaxCombinedAtomicBuffers = MAX_COMBINED_ATOMIC_BUFFERS;
   ctx->Const.MaxCombinedAtomicCounters = MAX_ATOMIC_COUNTERS;
d707 2
a708 2
   ctx->Const.MaxVertexAttribRelativeOffset = 2047;
   ctx->Const.MaxVertexAttribBindings = MAX_VERTEX_GENERIC_ATTRIBS;
d711 7
a717 7
   ctx->Const.MaxComputeWorkGroupCount[0] = 65535;
   ctx->Const.MaxComputeWorkGroupCount[1] = 65535;
   ctx->Const.MaxComputeWorkGroupCount[2] = 65535;
   ctx->Const.MaxComputeWorkGroupSize[0] = 1024;
   ctx->Const.MaxComputeWorkGroupSize[1] = 1024;
   ctx->Const.MaxComputeWorkGroupSize[2] = 64;
   ctx->Const.MaxComputeWorkGroupInvocations = 1024;
d720 5
a724 2
   ctx->Const.MinFragmentInterpolationOffset = MIN_FRAGMENT_INTERPOLATION_OFFSET;
   ctx->Const.MaxFragmentInterpolationOffset = MAX_FRAGMENT_INTERPOLATION_OFFSET;
d735 2
d803 1
a803 1
   _mesa_init_constants( ctx );
d806 1
a806 1
   _mesa_init_extensions( ctx );
d900 15
a914 1
 * Allocate and initialize a new dispatch table.
d917 1
a917 1
_mesa_alloc_dispatch_table()
d934 20
d1136 1
a1136 1
      = (_mesa_getenv("MESA_TEX_PROG") != NULL);
d1139 1
a1139 1
      = (_mesa_getenv("MESA_TNL_PROG") != NULL);
d1542 4
a1545 1
   assert(ctx->Version > 0);
d1583 1
a1583 1
   if (_mesa_getenv("MESA_INFO")) {
d1630 1
a1630 1
      (curCtx->WinSysDrawBuffer || curCtx->WinSysReadBuffer) &&
d1632 3
a1634 1
      curCtx != newCtx)
d1956 11
@


1.12
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d1215 3
@


1.11
log
@Merge Mesa 9.2.0
@
text
@d108 2
d367 1
a367 1
_glthread_DECLARE_STATIC_MUTEX(OneTimeLock);
d385 1
a385 1
   _glthread_LOCK_MUTEX(OneTimeLock);
d426 1
a426 1
   _glthread_UNLOCK_MUTEX(OneTimeLock);
d465 1
a465 1
init_program_limits(struct gl_context *ctx, GLenum type,
d477 2
a478 2
   switch (type) {
   case GL_VERTEX_PROGRAM_ARB:
d483 2
d486 1
a486 1
   case GL_FRAGMENT_PROGRAM_ARB:
d491 2
d494 1
a494 1
   case MESA_GEOMETRY_PROGRAM:
d498 11
a508 1
      prog->MaxUniformComponents = MAX_GEOMETRY_UNIFORM_COMPONENTS;
d511 1
a511 1
      assert(0 && "Bad program type in init_program_limits()");
d549 3
d563 1
d574 1
a574 1
   ctx->Const.FragmentProgram.MaxTextureImageUnits = MAX_TEXTURE_IMAGE_UNITS;
d576 1
a576 1
                                     ctx->Const.FragmentProgram.MaxTextureImageUnits);
d599 7
d613 2
a614 3
   init_program_limits(ctx, GL_VERTEX_PROGRAM_ARB, &ctx->Const.VertexProgram);
   init_program_limits(ctx, GL_FRAGMENT_PROGRAM_ARB, &ctx->Const.FragmentProgram);
   init_program_limits(ctx, MESA_GEOMETRY_PROGRAM, &ctx->Const.GeometryProgram);
d628 1
a628 1
   ctx->Const.VertexProgram.MaxTextureImageUnits = MAX_TEXTURE_IMAGE_UNITS;
d631 1
a631 1
   ctx->Const.GeometryProgram.MaxTextureImageUnits = MAX_TEXTURE_IMAGE_UNITS;
d674 4
d691 23
d731 2
a732 2
   assert(ctx->Const.FragmentProgram.MaxLocalParams <= MAX_PROGRAM_LOCAL_PARAMS);
   assert(ctx->Const.VertexProgram.MaxLocalParams <= MAX_PROGRAM_LOCAL_PARAMS);
d735 2
a736 2
   assert(ctx->Const.FragmentProgram.MaxTextureImageUnits > 0);
   assert(ctx->Const.FragmentProgram.MaxTextureImageUnits <= MAX_TEXTURE_IMAGE_UNITS);
d742 1
a742 1
   assert(ctx->Const.MaxTextureUnits == MIN2(ctx->Const.FragmentProgram.MaxTextureImageUnits,
d748 1
a748 1
   assert(ctx->Const.MaxTextureCoordUnits <= ctx->Const.FragmentProgram.MaxTextureImageUnits);
d814 2
d841 1
a841 1
   ctx->ResetStatus = GL_NO_ERROR;
d1016 2
a1017 1
 * \param visual describes the visual attributes for this context
a1036 1
   ctx->Visual = *visual;
d1042 9
d1144 1
a1144 1
   free(ctx->Exec);
d1157 2
a1158 1
 * \param visual a struct gl_config pointer (we copy the struct contents)
a1172 2
   ASSERT(visual);

d1219 2
a1220 2
   _mesa_reference_array_object(ctx, &ctx->Array.ArrayObj, NULL);
   _mesa_reference_array_object(ctx, &ctx->Array.DefaultArrayObj, NULL);
d1229 1
d1236 1
d1245 1
a1245 1
   free(ctx->Exec);
d1390 11
a1400 7
      dst->Viewport.X = src->Viewport.X;
      dst->Viewport.Y = src->Viewport.Y;
      dst->Viewport.Width = src->Viewport.Width;
      dst->Viewport.Height = src->Viewport.Height;
      dst->Viewport.Near = src->Viewport.Near;
      dst->Viewport.Far = src->Viewport.Far;
      _math_matrix_copy(&dst->Viewport._WindowMap, &src->Viewport._WindowMap);
d1469 2
d1475 8
a1482 2
      _mesa_set_viewport(ctx, 0, 0, width, height);
      _mesa_set_scissor(ctx, 0, 0, width, height);
d1486 48
d1626 1
a1626 15
         assert(newCtx->Version > 0);

         newCtx->Extensions.String = _mesa_make_extension_string(newCtx);

         check_context_limits(newCtx);

         /* We can use this to help debug user's problems.  Tell them to set
          * the MESA_INFO env variable before running their app.  Then the
          * first time each context is made current we'll print some useful
          * information.
          */
	 if (_mesa_getenv("MESA_INFO")) {
	    _mesa_print_info();
	 }

d1814 26
d1844 1
d1851 2
a1852 3
   bool vert_from_glsl_shader = false;
   bool geom_from_glsl_shader = false;
   bool frag_from_glsl_shader = false;
d1858 3
a1860 6
   if (ctx->Shader.CurrentVertexProgram) {
      vert_from_glsl_shader = true;

      if (!ctx->Shader.CurrentVertexProgram->LinkStatus) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "%s(shader not linked)", where);
a1861 54
      }
#if 0 /* not normally enabled */
      {
         char errMsg[100];
         if (!_mesa_validate_shader_program(ctx,
					    ctx->Shader.CurrentVertexProgram,
                                            errMsg)) {
            _mesa_warning(ctx, "Shader program %u is invalid: %s",
                          ctx->Shader.CurrentVertexProgram->Name, errMsg);
         }
      }
#endif
   }

   if (ctx->Shader.CurrentGeometryProgram) {
      geom_from_glsl_shader = true;

      if (!ctx->Shader.CurrentGeometryProgram->LinkStatus) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "%s(shader not linked)", where);
         return GL_FALSE;
      }
#if 0 /* not normally enabled */
      {
         char errMsg[100];
         if (!_mesa_validate_shader_program(ctx,
					    ctx->Shader.CurrentGeometryProgram,
                                            errMsg)) {
            _mesa_warning(ctx, "Shader program %u is invalid: %s",
                          ctx->Shader.CurrentGeometryProgram->Name, errMsg);
         }
      }
#endif
   }

   if (ctx->Shader.CurrentFragmentProgram) {
      frag_from_glsl_shader = true;

      if (!ctx->Shader.CurrentFragmentProgram->LinkStatus) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "%s(shader not linked)", where);
         return GL_FALSE;
      }
#if 0 /* not normally enabled */
      {
         char errMsg[100];
         if (!_mesa_validate_shader_program(ctx,
					    ctx->Shader.CurrentFragmentProgram,
                                            errMsg)) {
            _mesa_warning(ctx, "Shader program %u is invalid: %s",
                          ctx->Shader.CurrentFragmentProgram->Name, errMsg);
         }
      }
#endif
d1867 1
a1867 1
   if (!vert_from_glsl_shader
d1877 1
a1877 1
   (void) geom_from_glsl_shader;
d1879 1
a1879 1
   if (!frag_from_glsl_shader) {
d1896 9
d1916 3
a1918 7
   if (ctx->Shader.Flags & GLSL_LOG) {
      struct gl_shader_program *shProg[MESA_SHADER_TYPES];
      gl_shader_type i;

      shProg[MESA_SHADER_VERTEX] = ctx->Shader.CurrentVertexProgram;
      shProg[MESA_SHADER_GEOMETRY] = ctx->Shader.CurrentGeometryProgram;
      shProg[MESA_SHADER_FRAGMENT] = ctx->Shader.CurrentFragmentProgram;
d1920 1
a1920 1
      for (i = 0; i < MESA_SHADER_TYPES; i++) {
d1937 1
a1937 1
      for (i = 0; i < MESA_SHADER_TYPES; i++) {
@


1.10
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a2 1
 * Version:  7.3
d20 4
a23 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
a79 1
#include "mfeatures.h"
d83 1
a131 1
#if _HAVE_FULL_GL
a132 1
#endif
d269 1
a269 1
   if (stencilBits < 0 || stencilBits > STENCIL_BITS) {
a345 1
   gl_frag_attrib fa = FRAG_ATTRIB_WPOS;
d349 1
a349 3
   gl_vert_result vr = VERT_RESULT_HPOS;
   gl_geom_attrib ga = GEOM_ATTRIB_POSITION;
   gl_geom_result gr = GEOM_RESULT_POS;
a352 1
   (void) fa;
d356 1
a356 3
   (void) vr;
   (void) ga;
   (void) gr;
a398 5
      _mesa_init_sqrt_table();

      /* context dependence is never a one-time thing... */
      _mesa_init_get_hash(ctx);

d406 1
a406 1
		     MESA_VERSION_STRING, __DATE__, __TIME__);
d417 3
a419 8
      /*
       * This is fine as ES does not use the remap table, but it may not be
       * future-proof.  We cannot always initialize the remap table because
       * when an app is linked to libGLES*, there are not enough dynamic
       * entries.
       */
      if (ctx->API == API_OPENGL)
         _mesa_init_remap_table();
d463 2
a464 1
init_program_limits(GLenum type, struct gl_program_constants *prog)
d478 1
a478 1
      prog->MaxAttribs = MAX_NV_VERTEX_PROGRAM_INPUTS;
d489 2
a490 2
      prog->MaxParameters = MAX_NV_VERTEX_PROGRAM_PARAMS;
      prog->MaxAttribs = MAX_NV_VERTEX_PROGRAM_INPUTS;
d528 5
d554 1
a554 1
   ctx->Const.MaxTextureImageUnits = MAX_TEXTURE_IMAGE_UNITS;
d556 1
a556 1
                                     ctx->Const.MaxTextureImageUnits);
d560 1
d573 1
a573 2
   ctx->Const.MaxColorTableSize = MAX_COLOR_TABLE_SIZE;
   ctx->Const.MaxClipPlanes = MAX_CLIP_PLANES;
d577 13
a589 11
   ctx->Const.MaxViewportWidth = MAX_WIDTH;
   ctx->Const.MaxViewportHeight = MAX_HEIGHT;
#if FEATURE_ARB_vertex_program
   init_program_limits(GL_VERTEX_PROGRAM_ARB, &ctx->Const.VertexProgram);
#endif
#if FEATURE_ARB_fragment_program
   init_program_limits(GL_FRAGMENT_PROGRAM_ARB, &ctx->Const.FragmentProgram);
#endif
#if FEATURE_ARB_geometry_shader4
   init_program_limits(MESA_GEOMETRY_PROGRAM, &ctx->Const.GeometryProgram);
#endif
a598 1
#if FEATURE_EXT_framebuffer_object
d600 1
a600 2
   ctx->Const.MaxRenderbufferSize = MAX_WIDTH;
#endif
d602 1
a602 2
#if FEATURE_ARB_vertex_shader
   ctx->Const.MaxVertexTextureImageUnits = MAX_VERTEX_TEXTURE_IMAGE_UNITS;
d604 2
a605 6
   ctx->Const.MaxVarying = MAX_VARYING;
#endif
#if FEATURE_ARB_geometry_shader4
   ctx->Const.MaxGeometryTextureImageUnits = MAX_GEOMETRY_TEXTURE_IMAGE_UNITS;
   ctx->Const.MaxVertexVaryingComponents = MAX_VERTEX_VARYING_COMPONENTS;
   ctx->Const.MaxGeometryVaryingComponents = MAX_GEOMETRY_VARYING_COMPONENTS;
a607 1
#endif
d610 1
a610 1
   if (ctx->API == API_OPENGL) {
d612 1
d625 1
a625 1
   ctx->Const.MaxServerWaitTimeout = (GLuint64) ~0;
d634 1
a634 1
   ctx->Const.MaxTransformFeedbackSeparateAttribs = MAX_FEEDBACK_ATTRIBS;
d637 1
d639 4
a642 2
   /* GL 3.2: hard-coded for now: */
   ctx->Const.ProfileMask = GL_CONTEXT_COMPATIBILITY_PROFILE_BIT;
d650 11
d672 1
a672 1
   assert(VERT_RESULT_MAX <=
d674 1
a674 1
   assert(FRAG_ATTRIB_MAX <=
a676 2
   assert(MAX_COMBINED_TEXTURE_IMAGE_UNITS <= 8 * sizeof(GLbitfield));

a680 5
   assert(MAX_NV_FRAGMENT_PROGRAM_TEMPS <= MAX_PROGRAM_TEMPS);
   assert(MAX_NV_VERTEX_PROGRAM_TEMPS <= MAX_PROGRAM_TEMPS);
   assert(MAX_NV_VERTEX_PROGRAM_INPUTS <= VERT_ATTRIB_MAX);
   assert(MAX_NV_VERTEX_PROGRAM_OUTPUTS <= VERT_RESULT_MAX);

d682 2
a683 2
   assert(ctx->Const.MaxTextureImageUnits > 0);
   assert(ctx->Const.MaxTextureImageUnits <= MAX_TEXTURE_IMAGE_UNITS);
d689 1
a689 1
   assert(ctx->Const.MaxTextureUnits == MIN2(ctx->Const.MaxTextureImageUnits,
d695 1
a695 1
   assert(ctx->Const.MaxTextureCoordUnits <= ctx->Const.MaxTextureImageUnits);
a703 5
   /* make sure largest texture image is <= MAX_WIDTH in size */
   assert((1 << (ctx->Const.MaxTextureLevels - 1)) <= MAX_WIDTH);
   assert((1 << (ctx->Const.MaxCubeTextureLevels - 1)) <= MAX_WIDTH);
   assert((1 << (ctx->Const.Max3DTextureLevels - 1)) <= MAX_WIDTH);

d709 4
a712 4
   assert((1 << (MAX_TEXTURE_LEVELS - 1)) <= MAX_WIDTH);

   assert(ctx->Const.MaxViewportWidth <= MAX_WIDTH);
   assert(ctx->Const.MaxViewportHeight <= MAX_WIDTH);
d751 1
d784 4
a787 3
   ctx->ErrorValue = (GLenum) GL_NO_ERROR;
   ctx->ResetStatus = (GLenum) GL_NO_ERROR;
   ctx->varying_vp_inputs = ~0;
d820 2
a821 2
static int
generic_nop(void)
d823 4
a826 1
   _mesa_warning(NULL, "User called no-op dispatch function (an unsupported extension function?)");
d835 1
a835 1
_mesa_alloc_dispatch_table(int size)
d845 1
a845 4
   /* should never happen, but just in case */
   numEntries = MAX2(numEntries, size);

   table = (struct _glapi_table *) malloc(numEntries * sizeof(_glapi_proc));
d850 1
a850 1
         entry[i] = (_glapi_proc) generic_nop;
d856 84
a965 1
 * \param driverContext pointer to driver-specific context data
d972 1
a972 2
                         const struct dd_function_table *driverFunctions,
                         void *driverContext)
a976 1
   /*ASSERT(driverContext);*/
d978 1
a978 1
   assert(driverFunctions->FreeTexImageData);
d987 4
a999 1
   ctx->DriverCtx = driverContext;
d1012 1
a1012 9
   _glthread_LOCK_MUTEX(shared->Mutex);
   ctx->Shared = shared;
   shared->RefCount++;
   _glthread_UNLOCK_MUTEX(shared->Mutex);

   if (!init_attrib_groups( ctx )) {
      _mesa_release_shared_state(ctx, ctx->Shared);
      return GL_FALSE;
   }
d1014 2
a1015 22
#if FEATURE_dispatch
   /* setup the API dispatch tables */
   switch (ctx->API) {
#if FEATURE_GL
   case API_OPENGL:
      ctx->Exec = _mesa_create_exec_table();
      break;
#endif
#if FEATURE_ES1
   case API_OPENGLES:
      ctx->Exec = _mesa_create_exec_table_es1();
      break;
#endif
#if FEATURE_ES2
   case API_OPENGLES2:
      ctx->Exec = _mesa_create_exec_table_es2();
      break;
#endif
   default:
      _mesa_problem(ctx, "unknown or unsupported API");
      break;
   }
d1017 6
a1022 6
   if (!ctx->Exec) {
      _mesa_release_shared_state(ctx, ctx->Shared);
      return GL_FALSE;
   }
#endif
   ctx->CurrentDispatch = ctx->Exec;
d1043 5
a1047 8
   case API_OPENGL:
#if FEATURE_dlist
      ctx->Save = _mesa_create_save_table();
      if (!ctx->Save) {
	 _mesa_release_shared_state(ctx, ctx->Shared);
	 free(ctx->Exec);
	 return GL_FALSE;
      }
d1049 2
a1050 2
      _mesa_install_save_vtxfmt( ctx, &ctx->ListState.ListVtxfmt );
#endif
a1069 1
      ctx->Point.PointSprite = GL_TRUE;  /* always on for ES 2.x */
d1076 7
a1096 1
 * \param driverContext points to the device driver's private context state
d1104 1
a1104 2
                     const struct dd_function_table *driverFunctions,
                     void *driverContext)
a1108 1
   /*ASSERT(driverContext);*/
d1110 1
a1110 1
   ctx = (struct gl_context *) calloc(1, sizeof(struct gl_context));
d1115 1
a1115 1
                                driverFunctions, driverContext)) {
d1156 3
a1172 3
   _mesa_delete_array_object(ctx, ctx->Array.DefaultArrayObj);

#if FEATURE_ARB_pixel_buffer_object
a1175 3
#endif

#if FEATURE_ARB_vertex_buffer_object
a1176 2
   _mesa_reference_buffer_object(ctx, &ctx->Array.ElementArrayBufferObj, NULL);
#endif
d1179 1
d1184 1
a1184 1
   _mesa_release_shared_state( ctx, ctx->Shared );
d1189 1
a1189 2
   if (ctx->Extensions.String)
      free((void *) ctx->Extensions.String);
d1191 3
a1193 2
   if (ctx->VersionString)
      free(ctx->VersionString);
a1218 1
#if _HAVE_FULL_GL
d1337 1
a1338 1
#endif
a1392 19
 * Do one-time initialization for the given framebuffer.  Specifically,
 * ask the driver for the window's current size and update the framebuffer
 * object to match.
 * Really, the device driver should totally take care of this.
 */
static void
initialize_framebuffer_size(struct gl_context *ctx, struct gl_framebuffer *fb)
{
   GLuint width, height;
   if (ctx->Driver.GetBufferSize) {
      ctx->Driver.GetBufferSize(fb, &width, &height);
      if (ctx->Driver.ResizeBuffers)
         ctx->Driver.ResizeBuffers(ctx, fb, width, height);
      fb->Initialized = GL_TRUE;
   }
}


/**
d1468 2
a1469 2
         ASSERT(drawBuffer->Name == 0);
         ASSERT(readBuffer->Name == 0);
d1477 1
a1477 1
         if (!newCtx->DrawBuffer || newCtx->DrawBuffer->Name == 0) {
d1485 1
a1485 1
         if (!newCtx->ReadBuffer || newCtx->ReadBuffer->Name == 0) {
a1493 30
#if 1
         /* We want to get rid of these lines: */

#if _HAVE_FULL_GL
         if (!drawBuffer->Initialized) {
            initialize_framebuffer_size(newCtx, drawBuffer);
         }
         if (readBuffer != drawBuffer && !readBuffer->Initialized) {
            initialize_framebuffer_size(newCtx, readBuffer);
         }

	 _mesa_resizebuffers(newCtx);
#endif

#else
         /* We want the drawBuffer and readBuffer to be initialized by
          * the driver.
          * This generally means the Width and Height match the actual
          * window size and the renderbuffers (both hardware and software
          * based) are allocated to match.  The later can generally be
          * done with a call to _mesa_resize_framebuffer().
          *
          * It's theoretically possible for a buffer to have zero width
          * or height, but for now, assert check that the driver did what's
          * expected of it.
          */
         ASSERT(drawBuffer->Width > 0);
         ASSERT(drawBuffer->Height > 0);
#endif

d1501 1
a1501 1
         _mesa_compute_version(newCtx);
d1534 1
a1534 1
      struct gl_shared_state *oldSharedState = ctx->Shared;
d1536 5
a1540 5
      ctx->Shared = ctxToShare->Shared;
      
      _glthread_LOCK_MUTEX(ctx->Shared->Mutex);
      ctx->Shared->RefCount++;
      _glthread_UNLOCK_MUTEX(ctx->Shared->Mutex);
d1544 2
a1545 1
      _mesa_release_shared_state(ctx, oldSharedState);
a1616 5

   /* Call device driver's error handler, if any.  This is used on the Mac. */
   if (ctx->Driver.Error) {
      ctx->Driver.Error(ctx);
   }
d1626 1
d1640 1
d1659 1
a1659 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d1674 1
a1674 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d1679 7
a1685 4
/**
 * Set mvp_with_dp4 flag.  If a driver has a preference for DP4 over
 * MUL/MAD, or vice versa, call this function to register that.
 * Otherwise we default to MUL/MAD.
d1687 2
a1688 3
void
_mesa_set_mvp_with_dp4( struct gl_context *ctx,
                        GLboolean flag )
d1690 11
a1700 1
   ctx->mvp_with_dp4 = flag;
a1702 2


d1822 4
a1835 2
	 struct gl_shader *sh;

d1843 2
a1844 3
	  * The logic is a little odd here.  We only want to log data for each
	  * shader target that will actually be used, and we only want to log
	  * it once.  It's possible to have a program bound to the vertex
d1849 1
a1849 16
	 sh = shProg[i]->_LinkedShaders[i];
	 switch (sh->Type) {
	 case GL_VERTEX_SHADER:
	    _mesa_append_uniforms_to_file(sh, &shProg[i]->VertexProgram->Base);
	    break;

	 case GL_GEOMETRY_SHADER_ARB:
	    _mesa_append_uniforms_to_file(sh,
					  &shProg[i]->GeometryProgram->Base);
	    break;

	 case GL_FRAGMENT_SHADER:
	    _mesa_append_uniforms_to_file(sh,
					  &shProg[i]->FragmentProgram->Base);
	    break;
	 }
@


1.9
log
@Merge Mesa 7.10.3
@
text
@d99 1
d194 2
a195 1
 * \param accumRedBits, accumGreenBits, accumBlueBits, accumAlphaBits number of bits per color component in accum buffer.
d204 2
a205 2
 * \return pointer to new struct gl_config or NULL if requested parameters can't be
 * met.
d422 4
d490 1
a490 1
   prog->MaxUniformComponents = 4 * MAX_UNIFORMS;
d497 1
d503 1
d509 1
a509 7

      prog->MaxGeometryTextureImageUnits = MAX_GEOMETRY_TEXTURE_IMAGE_UNITS;
      prog->MaxGeometryVaryingComponents = MAX_GEOMETRY_VARYING_COMPONENTS;
      prog->MaxVertexVaryingComponents = MAX_VERTEX_VARYING_COMPONENTS;
      prog->MaxGeometryUniformComponents = MAX_GEOMETRY_UNIFORM_COMPONENTS;
      prog->MaxGeometryOutputVertices = MAX_GEOMETRY_OUTPUT_VERTICES;
      prog->MaxGeometryTotalOutputComponents = MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS;
d534 11
a544 2
   /* assume ints are stored as floats for now */
   prog->LowInt = prog->MediumInt = prog->HighInt = prog->MediumFloat;
d571 1
d619 7
d661 3
d799 1
d898 6
a903 6
_mesa_initialize_context_for_api(struct gl_context *ctx,
				 gl_api api,
				 const struct gl_config *visual,
				 struct gl_context *share_list,
				 const struct dd_function_table *driverFunctions,
				 void *driverContext)
d991 8
a1040 19
 * Initialize an OpenGL context.
 */
GLboolean
_mesa_initialize_context(struct gl_context *ctx,
                         const struct gl_config *visual,
                         struct gl_context *share_list,
                         const struct dd_function_table *driverFunctions,
                         void *driverContext)
{
   return _mesa_initialize_context_for_api(ctx,
					   API_OPENGL,
					   visual,
					   share_list,
					   driverFunctions,
					   driverContext);
}


/**
d1056 5
a1060 5
_mesa_create_context_for_api(gl_api api,
			     const struct gl_config *visual,
			     struct gl_context *share_list,
			     const struct dd_function_table *driverFunctions,
			     void *driverContext)
d1071 2
a1072 2
   if (_mesa_initialize_context_for_api(ctx, api, visual, share_list,
					driverFunctions, driverContext)) {
a1082 16
 * Create an OpenGL context.
 */
struct gl_context *
_mesa_create_context(const struct gl_config *visual,
		     struct gl_context *share_list,
		     const struct dd_function_table *driverFunctions,
		     void *driverContext)
{
   return _mesa_create_context_for_api(API_OPENGL, visual,
				       share_list,
				       driverFunctions,
				       driverContext);
}


/**
d1194 2
a1195 1
_mesa_copy_context( const struct gl_context *src, struct gl_context *dst, GLuint mask )
d1433 2
a1434 1
      (curCtx->WinSysDrawBuffer || curCtx->WinSysReadBuffer) && /* make sure this context is valid for flushing */
a1448 2
	 /* TODO: check if newCtx and buffer's visual match??? */

d1459 4
a1462 1
            /* KW: merge conflict here, revisit. 
d1464 1
a1464 15
            /* fix up the fb fields - these will end up wrong otherwise
             * if the DRIdrawable changes, and everything relies on them.
             * This is a bit messy (same as needed in _mesa_BindFramebufferEXT)
             */
            unsigned int i;
            GLenum buffers[MAX_DRAW_BUFFERS];

            _mesa_reference_framebuffer(&newCtx->DrawBuffer, drawBuffer);

            for(i = 0; i < newCtx->Const.MaxDrawBuffers; i++) {
               buffers[i] = newCtx->Color.DrawBuffer[i];
            }

            _mesa_drawbuffers(newCtx, newCtx->Const.MaxDrawBuffers,
                              buffers, NULL);
@


1.8
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@a88 1
#include "colortab.h"
a99 1
#include "histogram.h"
a111 1
#if FEATURE_ARB_sync
a112 1
#endif
d117 1
d123 1
d129 2
a130 5
#include "glapi/glthread.h"
#include "glapi/glapitable.h"
#include "shader/program.h"
#include "shader/prog_print.h"
#include "shader/shader_api.h"
d134 1
d140 4
d167 1
a167 1
_mesa_notifySwapBuffers(__GLcontext *ctx)
d184 1
a184 1
 * Allocates a GLvisual structure and initializes it via
d202 1
a202 1
 * \return pointer to new GLvisual or NULL if requested parameters can't be
d207 1
a207 1
GLvisual *
d222 1
a222 1
   GLvisual *vis = (GLvisual *) calloc(1, sizeof(GLvisual));
d237 1
d239 5
a243 4
 * Makes some sanity checks and fills in the fields of the
 * GLvisual object with the given parameters.  If the caller needs
 * to set additional fields, he should just probably init the whole GLvisual
 * object himself.
d249 1
a249 1
_mesa_initialize_visual( GLvisual *vis,
a301 1
   vis->pixmapMode = 0;
d317 1
a317 1
_mesa_destroy_visual( GLvisual *vis )
d344 9
a352 8
   gl_buffer_index bi;
   gl_colortable_index ci;
   gl_face_index fi;
   gl_frag_attrib fa;
   gl_frag_result fr;
   gl_texture_index ti;
   gl_vert_attrib va;
   gl_vert_result vr;
a354 1
   (void) ci;
d361 2
d373 2
d385 1
a385 1
one_time_init( GLcontext *ctx )
d387 2
a388 2
   static GLboolean alreadyCalled = GL_FALSE;
   (void) ctx;
d390 3
a392 1
   if (!alreadyCalled) {
d405 1
a405 1
      _mesa_init_remap_table();
d407 2
a408 1
      _mesa_init_sqrt_table();
d415 4
a418 2
      _mesa_debug(ctx, "Mesa %s DEBUG build %s %s\n",
                  MESA_VERSION_STRING, __DATE__, __TIME__);
d420 1
d422 10
a431 1
      alreadyCalled = GL_TRUE;
d433 3
d438 5
d451 1
a451 1
_mesa_init_current(GLcontext *ctx)
d471 1
a471 1
 * Init vertex/fragment program limits.
d486 2
a487 1
   if (type == GL_VERTEX_PROGRAM_ARB) {
d491 2
a492 2
   }
   else {
d496 15
d524 10
d543 1
a543 1
_mesa_init_constants(GLcontext *ctx)
d548 1
a572 2
   ctx->Const.MaxConvolutionWidth = MAX_CONVOLUTION_WIDTH;
   ctx->Const.MaxConvolutionHeight = MAX_CONVOLUTION_HEIGHT;
d585 3
d608 11
d630 12
d650 1
a650 1
check_context_limits(GLcontext *ctx)
d709 3
d725 1
a725 1
init_attrib_groups(GLcontext *ctx)
a739 1
   _mesa_init_colortables( ctx );
a747 1
   _mesa_init_histogram( ctx );
a758 1
#if FEATURE_ARB_sync
a759 1
#endif
d765 1
d793 1
a793 1
update_default_objects(GLcontext *ctx)
d821 2
a822 2
static struct _glapi_table *
alloc_dispatch_table(void)
d829 7
a835 4
   GLint numEntries = MAX2(_glapi_get_dispatch_table_size(),
                           sizeof(struct _glapi_table) / sizeof(_glapi_proc));
   struct _glapi_table *table =
      (struct _glapi_table *) malloc(numEntries * sizeof(_glapi_proc));
d848 1
a848 1
 * Initialize a GLcontext struct (rendering context).
d866 1
d875 6
a880 5
_mesa_initialize_context(GLcontext *ctx,
                         const GLvisual *visual,
                         GLcontext *share_list,
                         const struct dd_function_table *driverFunctions,
                         void *driverContext)
d883 1
d889 1
a889 3
   /* misc one-time initializations */
   one_time_init(ctx);

d896 3
d928 1
d930 22
a951 3
   ctx->Exec = alloc_dispatch_table();
   ctx->Save = alloc_dispatch_table();
   if (!ctx->Exec || !ctx->Save) {
a952 2
      if (ctx->Exec)
         free(ctx->Exec);
a954 2
#if FEATURE_dispatch
   _mesa_init_exec_table(ctx->Exec);
a957 10
#if FEATURE_dlist
   _mesa_init_save_table(ctx->Save);
   _mesa_install_save_vtxfmt( ctx, &ctx->ListState.ListVtxfmt );
#endif

   /* Neutral tnl module stuff */
   _mesa_init_exec_vtxfmt( ctx ); 
   ctx->TnlModule.Current = NULL;
   ctx->TnlModule.SwapCount = 0;

d968 11
a978 2
#ifdef FEATURE_extra_context_init
   _mesa_initialize_context_extra(ctx);
d980 22
d1010 20
a1029 1
 * Allocate and initialize a GLcontext structure.
d1034 2
a1035 1
 * \param visual a GLvisual pointer (we copy the struct contents)
d1041 1
a1041 1
 * \return pointer to a new __GLcontextRec or NULL if error.
d1043 6
a1048 5
GLcontext *
_mesa_create_context(const GLvisual *visual,
                     GLcontext *share_list,
                     const struct dd_function_table *driverFunctions,
                     void *driverContext)
d1050 1
a1050 1
   GLcontext *ctx;
d1055 1
a1055 1
   ctx = (GLcontext *) calloc(1, sizeof(GLcontext));
d1059 2
a1060 2
   if (_mesa_initialize_context(ctx, visual, share_list,
                                driverFunctions, driverContext)) {
d1071 16
d1089 1
a1089 1
 * But doesn't free the GLcontext struct itself.
d1094 1
a1094 1
_mesa_free_context_data( GLcontext *ctx )
a1123 1
   _mesa_free_colortables_data( ctx );
a1126 1
#if FEATURE_ARB_sync
a1127 1
#endif
d1129 1
d1168 1
a1168 1
 * Destroy a GLcontext structure.
d1172 1
a1172 1
 * Calls _mesa_free_context_data() and frees the GLcontext structure itself.
d1175 1
a1175 1
_mesa_destroy_context( GLcontext *ctx )
d1198 1
a1198 1
_mesa_copy_context( const GLcontext *src, GLcontext *dst, GLuint mask )
d1317 2
a1318 1
check_compatible(const GLcontext *ctx, const GLframebuffer *buffer)
d1320 2
a1321 2
   const GLvisual *ctxvis = &ctx->Visual;
   const GLvisual *bufvis = &buffer->Visual;
d1323 1
a1323 1
   if (ctxvis == bufvis)
d1364 1
a1364 1
initialize_framebuffer_size(GLcontext *ctx, GLframebuffer *fb)
d1381 1
a1381 1
_mesa_check_init_viewport(GLcontext *ctx, GLuint width, GLuint height)
d1409 3
a1411 2
_mesa_make_current( GLcontext *newCtx, GLframebuffer *drawBuffer,
                    GLframebuffer *readBuffer )
d1413 2
d1435 5
d1478 2
a1479 1
            _mesa_drawbuffers(newCtx, newCtx->Const.MaxDrawBuffers, buffers, NULL);
d1529 2
d1557 1
a1557 1
_mesa_share_state(GLcontext *ctx, GLcontext *ctxToShare)
d1588 1
a1588 1
GLcontext *
d1591 1
a1591 1
   return (GLcontext *) _glapi_get_context();
d1605 1
a1605 1
 * Simply returns __GLcontextRec::CurrentDispatch.
d1608 1
a1608 1
_mesa_get_dispatch(GLcontext *ctx)
d1634 1
a1634 1
_mesa_record_error(GLcontext *ctx, GLenum error)
d1654 1
a1654 1
_mesa_finish(GLcontext *ctx)
d1667 1
a1667 1
_mesa_flush(GLcontext *ctx)
d1713 1
a1713 1
_mesa_set_mvp_with_dp4( GLcontext *ctx,
d1729 1
a1729 1
_mesa_valid_to_render(GLcontext *ctx, const char *where)
d1731 4
d1739 4
a1742 3
   if (ctx->Shader.CurrentProgram) {
      /* using shaders */
      if (!ctx->Shader.CurrentProgram->LinkStatus) {
d1744 1
a1744 1
                     "%s(shader not linked), where");
d1750 2
a1751 1
         if (!_mesa_validate_shader_program(ctx, ctx->Shader.CurrentProgram,
d1754 1
a1754 1
                          ctx->Shader.CurrentProgram->Name, errMsg);
d1759 26
a1784 2
   else {
      if (ctx->VertexProgram.Enabled && !ctx->VertexProgram._Enabled) {
d1786 1
a1786 1
                     "%s(vertex program not valid)", where);
d1789 29
d1819 9
d1829 1
a1829 1
                     "%s(fragment program not valid)", where);
d1842 45
a1886 20
      struct gl_shader_program *shProg = ctx->Shader.CurrentProgram;
      if (shProg) {
         if (!shProg->_Used) {
            /* This is the first time this shader is being used.
             * Append shader's constants/uniforms to log file.
             */
            GLuint i;
            for (i = 0; i < shProg->NumShaders; i++) {
               struct gl_shader *sh = shProg->Shaders[i];
               if (sh->Type == GL_VERTEX_SHADER) {
                  _mesa_append_uniforms_to_file(sh,
                                                &shProg->VertexProgram->Base);
               }
               else if (sh->Type == GL_FRAGMENT_SHADER) {
                  _mesa_append_uniforms_to_file(sh,
                                                &shProg->FragmentProgram->Base);
               }
            }
            shProg->_Used = GL_TRUE;
         }
@


1.7
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d80 1
a81 1
#if FEATURE_accum
a82 1
#endif
a84 1
#if FEATURE_attrib_stack
a85 1
#endif
a88 1
#if FEATURE_colortable
a89 1
#endif
d91 1
a93 1
#if FEATURE_dlist
a94 2
#endif
#if FEATURE_evaluators
a95 2
#endif
#include "enums.h"
a97 1
#if FEATURE_feedback
a98 1
#endif
a100 2
#include "get.h"
#if FEATURE_histogram
a101 1
#endif
a112 1
#if FEATURE_ARB_occlusion_query
d114 2
a116 1
#if FEATURE_drawpix
d118 1
a118 1
#endif
d120 1
d124 1
a124 3
#include "texcompress.h"
#include "teximage.h"
#include "texobj.h"
d129 1
a131 1
#include "glapi/glapioffsets.h"
a132 1
#if FEATURE_NV_vertex_program || FEATURE_NV_fragment_program
d134 1
a134 1
#endif
a135 3
#if FEATURE_ATI_fragment_shader
#include "shader/atifragshader.h"
#endif
a136 1
#include "math/m_translate.h"
a137 2
#include "math/m_xform.h"
#include "math/mathmod.h"
d161 1
a161 1
 * \param gc GL context.
d167 1
a167 1
_mesa_notifySwapBuffers(__GLcontext *gc)
d169 6
a174 1
   FLUSH_VERTICES( gc, 0 );
a186 1
 * \param rgbFlag GL_TRUE for RGB(A) mode, GL_FALSE for Color Index mode.
d208 1
a208 2
_mesa_create_visual( GLboolean rgbFlag,
                     GLboolean dbFlag,
a213 1
                     GLint indexBits,
d222 1
a222 1
   GLvisual *vis = (GLvisual *) _mesa_calloc(sizeof(GLvisual));
d224 1
a224 1
      if (!_mesa_initialize_visual(vis, rgbFlag, dbFlag, stereoFlag,
d226 1
a226 1
                                   indexBits, depthBits, stencilBits,
d230 1
a230 1
         _mesa_free(vis);
a247 1
                         GLboolean rgbFlag,
a253 1
                         GLint indexBits,
d275 1
a275 1
   vis->rgbMode          = rgbFlag;
d285 1
a285 1
   vis->indexBits      = indexBits;
d318 1
a318 1
   _mesa_free(vis);
d333 30
d396 4
a401 3
#if _HAVE_FULL_GL
      _math_init();

a404 12
#endif

#ifdef USE_SPARC_ASM
      _mesa_init_sparc_glapi_relocs();
#endif
      if (_mesa_getenv("MESA_DEBUG")) {
         _glapi_noop_enable_warnings(GL_TRUE);
         _glapi_set_warning_func( (_glapi_warning_func) _mesa_warning );
      }
      else {
         _glapi_noop_enable_warnings(GL_FALSE);
      }
a413 352
}


/**
 * Allocate and initialize a shared context state structure.
 * Initializes the display list, texture objects and vertex programs hash
 * tables, allocates the texture objects. If it runs out of memory, frees
 * everything already allocated before returning NULL.
 *
 * \return pointer to a gl_shared_state structure on success, or NULL on
 * failure.
 */
static GLboolean
alloc_shared_state( GLcontext *ctx )
{
   GLuint i;
   struct gl_shared_state *ss = CALLOC_STRUCT(gl_shared_state);
   if (!ss)
      return GL_FALSE;

   ctx->Shared = ss;

   _glthread_INIT_MUTEX(ss->Mutex);

   ss->DisplayList = _mesa_NewHashTable();
   ss->TexObjects = _mesa_NewHashTable();
   ss->Programs = _mesa_NewHashTable();

#if FEATURE_ARB_vertex_program
   ss->DefaultVertexProgram = (struct gl_vertex_program *)
      ctx->Driver.NewProgram(ctx, GL_VERTEX_PROGRAM_ARB, 0);
   if (!ss->DefaultVertexProgram)
      goto cleanup;
#endif
#if FEATURE_ARB_fragment_program
   ss->DefaultFragmentProgram = (struct gl_fragment_program *)
      ctx->Driver.NewProgram(ctx, GL_FRAGMENT_PROGRAM_ARB, 0);
   if (!ss->DefaultFragmentProgram)
      goto cleanup;
#endif
#if FEATURE_ATI_fragment_shader
   ss->ATIShaders = _mesa_NewHashTable();
   ss->DefaultFragmentShader = _mesa_new_ati_fragment_shader(ctx, 0);
   if (!ss->DefaultFragmentShader)
      goto cleanup;
#endif

#if FEATURE_ARB_vertex_buffer_object || FEATURE_ARB_pixel_buffer_object
   ss->BufferObjects = _mesa_NewHashTable();
#endif

   ss->ArrayObjects = _mesa_NewHashTable();

#if FEATURE_ARB_shader_objects
   ss->ShaderObjects = _mesa_NewHashTable();
#endif

   /* Create default texture objects */
   for (i = 0; i < NUM_TEXTURE_TARGETS; i++) {
      static const GLenum targets[NUM_TEXTURE_TARGETS] = {
         GL_TEXTURE_1D,
         GL_TEXTURE_2D,
         GL_TEXTURE_3D,
         GL_TEXTURE_CUBE_MAP,
         GL_TEXTURE_RECTANGLE_NV,
         GL_TEXTURE_1D_ARRAY_EXT,
         GL_TEXTURE_2D_ARRAY_EXT
      };
      ss->DefaultTex[i] = ctx->Driver.NewTextureObject(ctx, 0, targets[i]);
      if (!ss->DefaultTex[i])
         goto cleanup;
   }

   /* sanity check */
   assert(ss->DefaultTex[TEXTURE_1D_INDEX]->RefCount == 1);

   _glthread_INIT_MUTEX(ss->TexMutex);
   ss->TextureStateStamp = 0;

#if FEATURE_EXT_framebuffer_object
   ss->FrameBuffers = _mesa_NewHashTable();
   if (!ss->FrameBuffers)
      goto cleanup;
   ss->RenderBuffers = _mesa_NewHashTable();
   if (!ss->RenderBuffers)
      goto cleanup;
#endif

   return GL_TRUE;

cleanup:
   /* Ran out of memory at some point.  Free everything and return NULL */
   if (ss->DisplayList)
      _mesa_DeleteHashTable(ss->DisplayList);
   if (ss->TexObjects)
      _mesa_DeleteHashTable(ss->TexObjects);
   if (ss->Programs)
      _mesa_DeleteHashTable(ss->Programs);
#if FEATURE_ARB_vertex_program
   _mesa_reference_vertprog(ctx, &ss->DefaultVertexProgram, NULL);
#endif
#if FEATURE_ARB_fragment_program
   _mesa_reference_fragprog(ctx, &ss->DefaultFragmentProgram, NULL);
#endif
#if FEATURE_ATI_fragment_shader
   if (ss->DefaultFragmentShader)
      _mesa_delete_ati_fragment_shader(ctx, ss->DefaultFragmentShader);
#endif
#if FEATURE_ARB_vertex_buffer_object || FEATURE_ARB_pixel_buffer_object
   if (ss->BufferObjects)
      _mesa_DeleteHashTable(ss->BufferObjects);
#endif

   if (ss->ArrayObjects)
      _mesa_DeleteHashTable (ss->ArrayObjects);

#if FEATURE_ARB_shader_objects
   if (ss->ShaderObjects)
      _mesa_DeleteHashTable (ss->ShaderObjects);
#endif

#if FEATURE_EXT_framebuffer_object
   if (ss->FrameBuffers)
      _mesa_DeleteHashTable(ss->FrameBuffers);
   if (ss->RenderBuffers)
      _mesa_DeleteHashTable(ss->RenderBuffers);
#endif

   for (i = 0; i < NUM_TEXTURE_TARGETS; i++) {
      if (ss->DefaultTex[i])
         ctx->Driver.DeleteTexture(ctx, ss->DefaultTex[i]);
   }

   _mesa_free(ss);

   return GL_FALSE;
}


/**
 * Callback for deleting a display list.  Called by _mesa_HashDeleteAll().
 */
static void
delete_displaylist_cb(GLuint id, void *data, void *userData)
{
#if FEATURE_dlist
   struct mesa_display_list *list = (struct mesa_display_list *) data;
   GLcontext *ctx = (GLcontext *) userData;
   _mesa_delete_list(ctx, list);
#endif
}

/**
 * Callback for deleting a texture object.  Called by _mesa_HashDeleteAll().
 */
static void
delete_texture_cb(GLuint id, void *data, void *userData)
{
   struct gl_texture_object *texObj = (struct gl_texture_object *) data;
   GLcontext *ctx = (GLcontext *) userData;
   ctx->Driver.DeleteTexture(ctx, texObj);
}

/**
 * Callback for deleting a program object.  Called by _mesa_HashDeleteAll().
 */
static void
delete_program_cb(GLuint id, void *data, void *userData)
{
   struct gl_program *prog = (struct gl_program *) data;
   GLcontext *ctx = (GLcontext *) userData;
   ASSERT(prog->RefCount == 1); /* should only be referenced by hash table */
   prog->RefCount = 0;  /* now going away */
   ctx->Driver.DeleteProgram(ctx, prog);
}

/**
 * Callback for deleting an ATI fragment shader object.
 * Called by _mesa_HashDeleteAll().
 */
static void
delete_fragshader_cb(GLuint id, void *data, void *userData)
{
   struct ati_fragment_shader *shader = (struct ati_fragment_shader *) data;
   GLcontext *ctx = (GLcontext *) userData;
   _mesa_delete_ati_fragment_shader(ctx, shader);
}

/**
 * Callback for deleting a buffer object.  Called by _mesa_HashDeleteAll().
 */
static void
delete_bufferobj_cb(GLuint id, void *data, void *userData)
{
   struct gl_buffer_object *bufObj = (struct gl_buffer_object *) data;
   GLcontext *ctx = (GLcontext *) userData;
   ctx->Driver.DeleteBuffer(ctx, bufObj);
}

/**
 * Callback for deleting an array object.  Called by _mesa_HashDeleteAll().
 */
static void
delete_arrayobj_cb(GLuint id, void *data, void *userData)
{
   struct gl_array_object *arrayObj = (struct gl_array_object *) data;
   GLcontext *ctx = (GLcontext *) userData;
   _mesa_delete_array_object(ctx, arrayObj);
}

/**
 * Callback for freeing shader program data. Call it before delete_shader_cb
 * to avoid memory access error.
 */
static void
free_shader_program_data_cb(GLuint id, void *data, void *userData)
{
   GLcontext *ctx = (GLcontext *) userData;
   struct gl_shader_program *shProg = (struct gl_shader_program *) data;

   if (shProg->Type == GL_SHADER_PROGRAM_MESA) {
       _mesa_free_shader_program_data(ctx, shProg);
   }
}

/**
 * Callback for deleting shader and shader programs objects.
 * Called by _mesa_HashDeleteAll().
 */
static void
delete_shader_cb(GLuint id, void *data, void *userData)
{
   GLcontext *ctx = (GLcontext *) userData;
   struct gl_shader *sh = (struct gl_shader *) data;
   if (sh->Type == GL_FRAGMENT_SHADER || sh->Type == GL_VERTEX_SHADER) {
      _mesa_free_shader(ctx, sh);
   }
   else {
      struct gl_shader_program *shProg = (struct gl_shader_program *) data;
      ASSERT(shProg->Type == GL_SHADER_PROGRAM_MESA);
      _mesa_free_shader_program(ctx, shProg);
   }
}

/**
 * Callback for deleting a framebuffer object.  Called by _mesa_HashDeleteAll()
 */
static void
delete_framebuffer_cb(GLuint id, void *data, void *userData)
{
   struct gl_framebuffer *fb = (struct gl_framebuffer *) data;
   /* The fact that the framebuffer is in the hashtable means its refcount
    * is one, but we're removing from the hashtable now.  So clear refcount.
    */
   /*assert(fb->RefCount == 1);*/
   fb->RefCount = 0;

   /* NOTE: Delete should always be defined but there are two reports
    * of it being NULL (bugs 13507, 14293).  Work-around for now.
    */
   if (fb->Delete)
      fb->Delete(fb);
}

/**
 * Callback for deleting a renderbuffer object. Called by _mesa_HashDeleteAll()
 */
static void
delete_renderbuffer_cb(GLuint id, void *data, void *userData)
{
   struct gl_renderbuffer *rb = (struct gl_renderbuffer *) data;
   rb->RefCount = 0;  /* see comment for FBOs above */
   if (rb->Delete)
      rb->Delete(rb);
}



/**
 * Deallocate a shared state object and all children structures.
 *
 * \param ctx GL context.
 * \param ss shared state pointer.
 * 
 * Frees the display lists, the texture objects (calling the driver texture
 * deletion callback to free its private data) and the vertex programs, as well
 * as their hash tables.
 *
 * \sa alloc_shared_state().
 */
static void
free_shared_state( GLcontext *ctx, struct gl_shared_state *ss )
{
   GLuint i;

   /*
    * Free display lists
    */
   _mesa_HashDeleteAll(ss->DisplayList, delete_displaylist_cb, ctx);
   _mesa_DeleteHashTable(ss->DisplayList);

#if FEATURE_ARB_shader_objects
   _mesa_HashWalk(ss->ShaderObjects, free_shader_program_data_cb, ctx);
   _mesa_HashDeleteAll(ss->ShaderObjects, delete_shader_cb, ctx);
   _mesa_DeleteHashTable(ss->ShaderObjects);
#endif

   _mesa_HashDeleteAll(ss->Programs, delete_program_cb, ctx);
   _mesa_DeleteHashTable(ss->Programs);

#if FEATURE_ARB_vertex_program
   _mesa_reference_vertprog(ctx, &ss->DefaultVertexProgram, NULL);
#endif
#if FEATURE_ARB_fragment_program
   _mesa_reference_fragprog(ctx, &ss->DefaultFragmentProgram, NULL);
#endif

#if FEATURE_ATI_fragment_shader
   _mesa_HashDeleteAll(ss->ATIShaders, delete_fragshader_cb, ctx);
   _mesa_DeleteHashTable(ss->ATIShaders);
   _mesa_delete_ati_fragment_shader(ctx, ss->DefaultFragmentShader);
#endif

#if FEATURE_ARB_vertex_buffer_object || FEATURE_ARB_pixel_buffer_object
   _mesa_HashDeleteAll(ss->BufferObjects, delete_bufferobj_cb, ctx);
   _mesa_DeleteHashTable(ss->BufferObjects);
#endif

   _mesa_HashDeleteAll(ss->ArrayObjects, delete_arrayobj_cb, ctx);
   _mesa_DeleteHashTable(ss->ArrayObjects);

#if FEATURE_EXT_framebuffer_object
   _mesa_HashDeleteAll(ss->FrameBuffers, delete_framebuffer_cb, ctx);
   _mesa_DeleteHashTable(ss->FrameBuffers);
   _mesa_HashDeleteAll(ss->RenderBuffers, delete_renderbuffer_cb, ctx);
   _mesa_DeleteHashTable(ss->RenderBuffers);
#endif

   /*
    * Free texture objects (after FBOs since some textures might have
    * been bound to FBOs).
    */
   ASSERT(ctx->Driver.DeleteTexture);
   /* the default textures */
   for (i = 0; i < NUM_TEXTURE_TARGETS; i++) {
      ctx->Driver.DeleteTexture(ctx, ss->DefaultTex[i]);
   }
   /* all other textures */
   _mesa_HashDeleteAll(ss->TexObjects, delete_texture_cb, ctx);
   _mesa_DeleteHashTable(ss->TexObjects);

   _glthread_DESTROY_MUTEX(ss->Mutex);
d415 1
a415 1
   _mesa_free(ss);
d428 1
a428 1
   for (i = 0; i < VERT_ATTRIB_MAX; i++) {
d443 2
a444 1
 * Init vertex/fragment program native limits from logical limits.
d447 1
a447 1
init_natives(struct gl_program_constants *prog)
d449 31
a479 8
   prog->MaxNativeInstructions = prog->MaxInstructions;
   prog->MaxNativeAluInstructions = prog->MaxAluInstructions;
   prog->MaxNativeTexInstructions = prog->MaxTexInstructions;
   prog->MaxNativeTexIndirections = prog->MaxTexIndirections;
   prog->MaxNativeAttribs = prog->MaxAttribs;
   prog->MaxNativeTemps = prog->MaxTemps;
   prog->MaxNativeAddressRegs = prog->MaxAddressRegs;
   prog->MaxNativeParameters = prog->MaxParameters;
a492 3
   assert(MAX_TEXTURE_LEVELS >= MAX_3D_TEXTURE_LEVELS);
   assert(MAX_TEXTURE_LEVELS >= MAX_CUBE_TEXTURE_LEVELS);

d527 1
a527 12
   ctx->Const.VertexProgram.MaxInstructions = MAX_NV_VERTEX_PROGRAM_INSTRUCTIONS;
   ctx->Const.VertexProgram.MaxAluInstructions = 0;
   ctx->Const.VertexProgram.MaxTexInstructions = 0;
   ctx->Const.VertexProgram.MaxTexIndirections = 0;
   ctx->Const.VertexProgram.MaxAttribs = MAX_NV_VERTEX_PROGRAM_INPUTS;
   ctx->Const.VertexProgram.MaxTemps = MAX_PROGRAM_TEMPS;
   ctx->Const.VertexProgram.MaxParameters = MAX_NV_VERTEX_PROGRAM_PARAMS;
   ctx->Const.VertexProgram.MaxLocalParams = MAX_PROGRAM_LOCAL_PARAMS;
   ctx->Const.VertexProgram.MaxEnvParams = MAX_PROGRAM_ENV_PARAMS;
   ctx->Const.VertexProgram.MaxAddressRegs = MAX_VERTEX_PROGRAM_ADDRESS_REGS;
   ctx->Const.VertexProgram.MaxUniformComponents = 4 * MAX_UNIFORMS;
   init_natives(&ctx->Const.VertexProgram);
a528 1

d530 1
a530 12
   ctx->Const.FragmentProgram.MaxInstructions = MAX_NV_FRAGMENT_PROGRAM_INSTRUCTIONS;
   ctx->Const.FragmentProgram.MaxAluInstructions = MAX_FRAGMENT_PROGRAM_ALU_INSTRUCTIONS;
   ctx->Const.FragmentProgram.MaxTexInstructions = MAX_FRAGMENT_PROGRAM_TEX_INSTRUCTIONS;
   ctx->Const.FragmentProgram.MaxTexIndirections = MAX_FRAGMENT_PROGRAM_TEX_INDIRECTIONS;
   ctx->Const.FragmentProgram.MaxAttribs = MAX_NV_FRAGMENT_PROGRAM_INPUTS;
   ctx->Const.FragmentProgram.MaxTemps = MAX_PROGRAM_TEMPS;
   ctx->Const.FragmentProgram.MaxParameters = MAX_NV_FRAGMENT_PROGRAM_PARAMS;
   ctx->Const.FragmentProgram.MaxLocalParams = MAX_PROGRAM_LOCAL_PARAMS;
   ctx->Const.FragmentProgram.MaxEnvParams = MAX_PROGRAM_ENV_PARAMS;
   ctx->Const.FragmentProgram.MaxAddressRegs = MAX_FRAGMENT_PROGRAM_ADDRESS_REGS;
   ctx->Const.FragmentProgram.MaxUniformComponents = 4 * MAX_UNIFORMS;
   init_natives(&ctx->Const.FragmentProgram);
a540 4
   /* GL_OES_read_format */
   ctx->Const.ColorReadFormat = GL_RGBA;
   ctx->Const.ColorReadType = GL_UNSIGNED_BYTE;

d548 1
d552 8
a559 5
   /* sanity checks */
   ASSERT(ctx->Const.MaxTextureUnits == MIN2(ctx->Const.MaxTextureImageUnits,
                                             ctx->Const.MaxTextureCoordUnits));
   ASSERT(ctx->Const.FragmentProgram.MaxLocalParams <= MAX_PROGRAM_LOCAL_PARAMS);
   ASSERT(ctx->Const.VertexProgram.MaxLocalParams <= MAX_PROGRAM_LOCAL_PARAMS);
d561 2
a562 4
   ASSERT(MAX_NV_FRAGMENT_PROGRAM_TEMPS <= MAX_PROGRAM_TEMPS);
   ASSERT(MAX_NV_VERTEX_PROGRAM_TEMPS <= MAX_PROGRAM_TEMPS);
   ASSERT(MAX_NV_VERTEX_PROGRAM_INPUTS <= VERT_ATTRIB_MAX);
   ASSERT(MAX_NV_VERTEX_PROGRAM_OUTPUTS <= VERT_RESULT_MAX);
d573 19
a591 3
   /* Many context limits/constants are limited by the size of
    * internal arrays.
    */
d593 1
d595 1
d598 5
a602 1

d606 19
a627 5
   /* make sure largest texture image is <= MAX_WIDTH in size */
   assert((1 << (ctx->Const.MaxTextureLevels -1 )) <= MAX_WIDTH);
   assert((1 << (ctx->Const.MaxCubeTextureLevels -1 )) <= MAX_WIDTH);
   assert((1 << (ctx->Const.Max3DTextureLevels -1 )) <= MAX_WIDTH);

a653 1
#if FEATURE_accum
a654 2
#endif
#if FEATURE_attrib_stack
a655 1
#endif
a657 1
#if FEATURE_colortable
a658 1
#endif
a661 1
#if FEATURE_dlist
a662 2
#endif
#if FEATURE_evaluators
a663 1
#endif
a664 1
#if FEATURE_feedback
a665 3
#else
   ctx->RenderMode = GL_RENDER;
#endif
a666 1
#if FEATURE_histogram
a667 1
#endif
d678 3
a680 2
#if FEATURE_ARB_occlusion_query
   _mesa_init_query( ctx );
a681 1
#if FEATURE_drawpix
a682 1
#endif
a692 1
#if FEATURE_texture_s3tc
a693 4
#endif
#if FEATURE_texture_fxt1
   _mesa_init_texture_fxt1( ctx );
#endif
d698 1
d753 1
a753 1
      (struct _glapi_table *) _mesa_malloc(numEntries * sizeof(_glapi_proc));
d798 3
a800 1
   ASSERT(driverContext);
d823 1
a823 1
      ctx->Shared = share_list->Shared;
d827 2
a828 1
      if (!alloc_shared_state( ctx )) {
a829 1
      }
d831 5
a835 3
   _glthread_LOCK_MUTEX(ctx->Shared->Mutex);
   ctx->Shared->RefCount++;
   _glthread_UNLOCK_MUTEX(ctx->Shared->Mutex);
d838 1
a838 1
      free_shared_state(ctx, ctx->Shared);
d846 1
a846 1
      free_shared_state(ctx, ctx->Shared);
d848 2
a849 1
         _mesa_free(ctx->Exec);
d855 1
d857 1
a857 1
   _mesa_init_dlist_table(ctx->Save);
d860 1
d896 1
a896 1
 * \param driverCtx points to the device driver's private context state
d909 1
a909 1
   ASSERT(driverContext);
d911 1
a911 1
   ctx = (GLcontext *) _mesa_calloc(sizeof(GLcontext));
d920 1
a920 1
      _mesa_free(ctx);
a935 2
   GLint RefCount;

d944 4
a947 4
   _mesa_unreference_framebuffer(&ctx->WinSysDrawBuffer);
   _mesa_unreference_framebuffer(&ctx->WinSysReadBuffer);
   _mesa_unreference_framebuffer(&ctx->DrawBuffer);
   _mesa_unreference_framebuffer(&ctx->ReadBuffer);
d958 1
a959 1
#if FEATURE_evaluators
a960 1
#endif
a963 1
#if FEATURE_colortable
a964 1
#endif
d967 12
a978 2
#if FEATURE_ARB_occlusion_query
   _mesa_free_query_data(ctx);
d982 2
a983 1
   _mesa_delete_buffer_object(ctx, ctx->Array.NullBufferObj);
a984 1
   _mesa_delete_array_object(ctx, ctx->Array.DefaultArrayObj);
d987 2
a988 2
   _mesa_free(ctx->Exec);
   _mesa_free(ctx->Save);
d991 4
a994 8
   _glthread_LOCK_MUTEX(ctx->Shared->Mutex);
   RefCount = --ctx->Shared->RefCount;
   _glthread_UNLOCK_MUTEX(ctx->Shared->Mutex);
   assert(RefCount >= 0);
   if (RefCount == 0) {
      /* free shared state */
      free_shared_state( ctx, ctx->Shared );
   }
d997 4
a1000 1
      _mesa_free((void *) ctx->Extensions.String);
d1021 1
a1021 1
      _mesa_free( (void *) ctx );
d1106 1
a1106 1
      /* Use loop instead of MEMCPY due to problem with Portland Group's
a1166 2
   if (ctxvis->rgbMode != bufvis->rgbMode)
      return GL_FALSE;
d1218 18
d1249 1
a1249 1
void
d1262 1
a1262 1
         return;
d1269 1
a1269 1
         return;
d1296 9
d1306 6
d1352 3
a1354 7
         if (newCtx->FirstTimeCurrent) {
            /* set initial viewport and scissor size now */
            _mesa_set_viewport(newCtx, 0, 0,
                               drawBuffer->Width, drawBuffer->Height);
	    _mesa_set_scissor(newCtx, 0, 0,
			      drawBuffer->Width, drawBuffer->Height );
            check_context_limits(newCtx);
a1357 5
      /* We can use this to help debug user's problems.  Tell them to set
       * the MESA_INFO env variable before running their app.  Then the
       * first time each context is made current we'll print some useful
       * information.
       */
d1359 9
d1371 1
d1375 2
d1393 2
d1396 1
d1400 1
a1400 4
      oldSharedState->RefCount--;
      if (oldSharedState->RefCount == 0) {
         free_shared_state(ctx, oldSharedState);
      }
d1481 27
d1518 1
a1518 3
   if (ctx->Driver.Finish) {
      ctx->Driver.Finish(ctx);
   }
d1533 92
a1624 2
   if (ctx->Driver.Flush) {
      ctx->Driver.Flush(ctx);
d1626 3
@


1.6
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@a0 6
/**
 * \file context.c
 * Mesa context/visual/framebuffer management functions.
 * \author Brian Paul
 */

d3 1
a3 1
 * Version:  7.1
d6 1
d26 5
d81 1
d83 2
d86 1
d88 1
d92 1
d94 1
d98 1
d100 2
d103 1
d107 1
d109 1
d113 1
d115 1
d122 1
d124 1
d127 1
d129 2
d132 2
d146 2
d152 1
d154 1
d432 1
a442 1
#if FEATURE_NV_vertex_program || FEATURE_NV_fragment_program
a443 1
#endif
d474 15
a488 27
   ss->Default1D = (*ctx->Driver.NewTextureObject)(ctx, 0, GL_TEXTURE_1D);
   if (!ss->Default1D)
      goto cleanup;

   ss->Default2D = (*ctx->Driver.NewTextureObject)(ctx, 0, GL_TEXTURE_2D);
   if (!ss->Default2D)
      goto cleanup;

   ss->Default3D = (*ctx->Driver.NewTextureObject)(ctx, 0, GL_TEXTURE_3D);
   if (!ss->Default3D)
      goto cleanup;

   ss->DefaultCubeMap = (*ctx->Driver.NewTextureObject)(ctx, 0, GL_TEXTURE_CUBE_MAP_ARB);
   if (!ss->DefaultCubeMap)
      goto cleanup;

   ss->DefaultRect = (*ctx->Driver.NewTextureObject)(ctx, 0, GL_TEXTURE_RECTANGLE_NV);
   if (!ss->DefaultRect)
      goto cleanup;

   ss->Default1DArray = (*ctx->Driver.NewTextureObject)(ctx, 0, GL_TEXTURE_1D_ARRAY_EXT);
   if (!ss->Default1DArray)
      goto cleanup;

   ss->Default2DArray = (*ctx->Driver.NewTextureObject)(ctx, 0, GL_TEXTURE_2D_ARRAY_EXT);
   if (!ss->Default2DArray)
      goto cleanup;
d491 1
a491 1
   assert(ss->Default1D->RefCount == 1);
a512 1
#if FEATURE_NV_vertex_program
a514 1
#endif
d545 4
a548 14
   if (ss->Default1D)
      (*ctx->Driver.DeleteTexture)(ctx, ss->Default1D);
   if (ss->Default2D)
      (*ctx->Driver.DeleteTexture)(ctx, ss->Default2D);
   if (ss->Default3D)
      (*ctx->Driver.DeleteTexture)(ctx, ss->Default3D);
   if (ss->DefaultCubeMap)
      (*ctx->Driver.DeleteTexture)(ctx, ss->DefaultCubeMap);
   if (ss->DefaultRect)
      (*ctx->Driver.DeleteTexture)(ctx, ss->DefaultRect);
   if (ss->Default1DArray)
      (*ctx->Driver.DeleteTexture)(ctx, ss->Default1DArray);
   if (ss->Default2DArray)
      (*ctx->Driver.DeleteTexture)(ctx, ss->Default2DArray);
d562 1
d566 1
d710 2
a723 1
#if defined(FEATURE_NV_vertex_program) || defined(FEATURE_NV_fragment_program)
d726 1
a726 1
#endif
d761 3
a763 7
   ctx->Driver.DeleteTexture(ctx, ss->Default1D);
   ctx->Driver.DeleteTexture(ctx, ss->Default2D);
   ctx->Driver.DeleteTexture(ctx, ss->Default3D);
   ctx->Driver.DeleteTexture(ctx, ss->DefaultCubeMap);
   ctx->Driver.DeleteTexture(ctx, ss->DefaultRect);
   ctx->Driver.DeleteTexture(ctx, ss->Default1DArray);
   ctx->Driver.DeleteTexture(ctx, ss->Default2DArray);
a826 3
   assert(MAX_TEXTURE_UNITS >= MAX_TEXTURE_COORD_UNITS);
   assert(MAX_TEXTURE_UNITS >= MAX_TEXTURE_IMAGE_UNITS);

d940 3
d977 1
d979 2
d982 1
d985 1
d987 1
d991 1
d993 2
d996 1
d998 1
d1000 3
d1004 1
d1006 1
d1013 1
d1017 1
d1019 2
d1022 1
d1033 1
d1035 2
d1038 1
d1190 1
d1192 1
d1194 1
a1194 1
#if _HAVE_FULL_GL
d1197 1
a1201 1
#endif
a1204 1
   ctx->FragmentProgram._UseTexEnvProgram = ctx->FragmentProgram._MaintainTexEnvProgram;
d1213 4
d1273 2
d1298 1
d1300 1
d1304 1
d1306 1
d1309 1
d1311 1
d1324 1
a1324 2
   ctx->Shared->RefCount--;
   assert(ctx->Shared->RefCount >= 0);
d1326 2
a1327 1
   if (ctx->Shared->RefCount == 0) {
@


1.5
log
@unbreak biuld. From Travers Buda. Thanks.
@
text
@d9 1
a9 1
 * Version:  7.0.2
a99 2
#include "glthread.h"
#include "glapioffsets.h"
a102 1
#include "atifragshader.h"
a109 3
#if FEATURE_NV_vertex_program || FEATURE_NV_fragment_program
#include "program.h"
#endif
d123 6
a134 1
#include "shader_api.h"
a151 2
static void
free_shared_state( GLcontext *ctx, struct gl_shared_state *ss );
d421 2
a422 1
   ss->DefaultVertexProgram = ctx->Driver.NewProgram(ctx, GL_VERTEX_PROGRAM_ARB, 0);
d427 2
a428 1
   ss->DefaultFragmentProgram = ctx->Driver.NewProgram(ctx, GL_FRAGMENT_PROGRAM_ARB, 0);
d469 8
d505 1
a505 2
   if (ss->DefaultVertexProgram)
      ctx->Driver.DeleteProgram(ctx, ss->DefaultVertexProgram);
d508 1
a508 2
   if (ss->DefaultFragmentProgram)
      ctx->Driver.DeleteProgram(ctx, ss->DefaultFragmentProgram);
d544 7
a550 2
   if (ss)
      _mesa_free(ss);
d585 2
d625 15
a685 1

d687 1
a687 1
     rb->Delete(rb);
d713 6
d724 1
a724 1
   ctx->Driver.DeleteProgram(ctx, ss->DefaultVertexProgram);
d727 1
a727 1
   ctx->Driver.DeleteProgram(ctx, ss->DefaultFragmentProgram);
a743 5
#if FEATURE_ARB_shader_objects
   _mesa_HashDeleteAll(ss->ShaderObjects, delete_shader_cb, ctx);
   _mesa_DeleteHashTable(ss->ShaderObjects);
#endif

d762 2
d835 1
d987 1
d1024 22
d1053 1
a1053 1
   _mesa_problem(NULL, "User called no-op dispatch function (an unsupported extension function?)");
d1256 8
d1447 3
a1449 3
 * XXX this may go away someday because we're moving toward more freedom
 * in binding contexts to drawables with different visual attributes.
 * The GL_EXT_f_b_o extension is prompting some of that.
d1581 3
d1651 2
a1652 4
      ctx->Shared->RefCount--;
      if (ctx->Shared->RefCount == 0) {
         free_shared_state(ctx, ctx->Shared);
      }
d1655 8
@


1.4
log
@Prevent a crash if  Delete is not defined for the given renderbuffer.
Patch from OUSADOU Azwaw. Thanks. ok oga@@.
@
text
@d660 1
a660 1
   if (rb-Delete)
@


1.3
log
@Update to Mesa 7.0.3. tested my oga@@ and johan@@
@
text
@d659 3
a661 1
   rb->Delete(rb);
@


1.2
log
@Update to Mesa 7.0.2. Tested by naddy@@ (full ports build), simon@@
and oga@@ (with dri enabled).
@
text
@d643 6
a648 1
   fb->Delete(fb);
d690 1
a690 1
   _mesa_delete_program(ctx, ss->DefaultVertexProgram);
d693 1
a693 1
   _mesa_delete_program(ctx, ss->DefaultFragmentProgram);
d757 1
a757 1
   ASSIGN_4V( ctx->Current.Attrib[VERT_ATTRIB_WEIGHT], 1.0, 0.0, 0.0, 1.0 );
a984 1
   ctx->_Facing = 0;
@


1.1
log
@Initial revision
@
text
@d9 1
a9 1
 * Version:  6.5
d11 1
a11 1
 * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
d98 1
a109 1
#include "occlude.h"
d116 1
d135 1
a135 1
#include "shaderobjects.h"
a156 165
/**********************************************************************/
/** \name OpenGL SI-style interface (new in Mesa 3.5)
 *
 * \if subset
 * \note Most of these functions are never called in the Mesa subset.
 * \endif
 */
/*@@{*/

/**
 * Destroy context callback.
 * 
 * \param gc context.
 * \return GL_TRUE on success, or GL_FALSE on failure.
 * 
 * \ifnot subset
 * Called by window system/device driver (via __GLexports::destroyCurrent) when
 * the rendering context is to be destroyed.
 * \endif
 *
 * Frees the context data and the context structure.
 */
GLboolean
_mesa_destroyContext(__GLcontext *gc)
{
   if (gc) {
      _mesa_free_context_data(gc);
      _mesa_free(gc);
   }
   return GL_TRUE;
}

/**
 * Unbind context callback.
 * 
 * \param gc context.
 * \return GL_TRUE on success, or GL_FALSE on failure.
 *
 * \ifnot subset
 * Called by window system/device driver (via __GLexports::loseCurrent)
 * when the rendering context is made non-current.
 * \endif
 *
 * No-op
 */
GLboolean
_mesa_loseCurrent(__GLcontext *gc)
{
   /* XXX unbind context from thread */
   (void) gc;
   return GL_TRUE;
}

/**
 * Bind context callback.
 * 
 * \param gc context.
 * \return GL_TRUE on success, or GL_FALSE on failure.
 *
 * \ifnot subset
 * Called by window system/device driver (via __GLexports::makeCurrent)
 * when the rendering context is made current.
 * \endif
 *
 * No-op
 */
GLboolean
_mesa_makeCurrent(__GLcontext *gc)
{
   /* XXX bind context to thread */
   (void) gc;
   return GL_TRUE;
}

/**
 * Share context callback.
 * 
 * \param gc context.
 * \param gcShare shared context.
 * \return GL_TRUE on success, or GL_FALSE on failure.
 *
 * \ifnot subset
 * Called by window system/device driver (via __GLexports::shareContext)
 * \endif
 *
 * Update the shared context reference count, gl_shared_state::RefCount.
 */
GLboolean
_mesa_shareContext(__GLcontext *gc, __GLcontext *gcShare)
{
   if (gc && gcShare && gc->Shared && gcShare->Shared) {
      gc->Shared->RefCount--;
      if (gc->Shared->RefCount == 0) {
         free_shared_state(gc, gc->Shared);
      }
      gc->Shared = gcShare->Shared;
      gc->Shared->RefCount++;
      return GL_TRUE;
   }
   else {
      return GL_FALSE;
   }
}


#if _HAVE_FULL_GL
/**
 * Copy context callback.
 */
GLboolean
_mesa_copyContext(__GLcontext *dst, const __GLcontext *src, GLuint mask)
{
   if (dst && src) {
      _mesa_copy_context( src, dst, mask );
      return GL_TRUE;
   }
   else {
      return GL_FALSE;
   }
}
#endif

/** No-op */
GLboolean
_mesa_forceCurrent(__GLcontext *gc)
{
   (void) gc;
   return GL_TRUE;
}

/**
 * Windows/buffer resizing notification callback.
 *
 * \param gc GL context.
 * \return GL_TRUE on success, or GL_FALSE on failure.
 */
GLboolean
_mesa_notifyResize(__GLcontext *gc)
{
   GLint x, y;
   GLuint width, height;
   __GLdrawablePrivate *d = gc->imports.getDrawablePrivate(gc);
   if (!d || !d->getDrawableSize)
      return GL_FALSE;
   d->getDrawableSize( d, &x, &y, &width, &height );
   /* update viewport, resize software buffers, etc. */
   return GL_TRUE;
}

/**
 * Window/buffer destruction notification callback.
 *
 * \param gc GL context.
 * 
 * Called when the context's window/buffer is going to be destroyed. 
 *
 * No-op
 */
void
_mesa_notifyDestroy(__GLcontext *gc)
{
   /* Unbind from it. */
   (void) gc;
}

a170 99
/** No-op */
struct __GLdispatchStateRec *
_mesa_dispatchExec(__GLcontext *gc)
{
   (void) gc;
   return NULL;
}

/** No-op */
void
_mesa_beginDispatchOverride(__GLcontext *gc)
{
   (void) gc;
}

/** No-op */
void
_mesa_endDispatchOverride(__GLcontext *gc)
{
   (void) gc;
}

/**
 * \ifnot subset
 * Setup the exports.  
 *
 * The window system will call these functions when it needs Mesa to do
 * something.
 * 
 * \note Device drivers should override these functions!  For example,
 * the Xlib driver should plug in the XMesa*-style functions into this
 * structure.  The XMesa-style functions should then call the _mesa_*
 * version of these functions.  This is an approximation to OO design
 * (inheritance and virtual functions).
 * \endif
 *
 * \if subset
 * No-op.
 * 
 * \endif
 */
static void
_mesa_init_default_exports(__GLexports *exports)
{
#if _HAVE_FULL_GL
    exports->destroyContext = _mesa_destroyContext;
    exports->loseCurrent = _mesa_loseCurrent;
    exports->makeCurrent = _mesa_makeCurrent;
    exports->shareContext = _mesa_shareContext;
    exports->copyContext = _mesa_copyContext;
    exports->forceCurrent = _mesa_forceCurrent;
    exports->notifyResize = _mesa_notifyResize;
    exports->notifyDestroy = _mesa_notifyDestroy;
    exports->notifySwapBuffers = _mesa_notifySwapBuffers;
    exports->dispatchExec = _mesa_dispatchExec;
    exports->beginDispatchOverride = _mesa_beginDispatchOverride;
    exports->endDispatchOverride = _mesa_endDispatchOverride;
#else
    (void) exports;
#endif
}

/**
 * Exported OpenGL SI interface.
 */
__GLcontext *
__glCoreCreateContext(__GLimports *imports, __GLcontextModes *modes)
{
    GLcontext *ctx;

    ctx = (GLcontext *) (*imports->calloc)(NULL, 1, sizeof(GLcontext));
    if (ctx == NULL) {
	return NULL;
    }

    /* XXX doesn't work at this time */
    _mesa_initialize_context(ctx, modes, NULL, NULL, NULL);
    ctx->imports = *imports;

    return ctx;
}

/**
 * Exported OpenGL SI interface.
 */
void
__glCoreNopDispatch(void)
{
#if 0
   /* SI */
   __gl_dispatch = __glNopDispatchState;
#else
   /* Mesa */
   _glapi_set_dispatch(NULL);
#endif
}

/*@@}*/

d365 2
d447 1
a447 1
   ss->GL2Objects = _mesa_NewHashTable ();
d470 5
a474 6
   /* Effectively bind the default textures to all texture units */
   ss->Default1D->RefCount += MAX_TEXTURE_IMAGE_UNITS;
   ss->Default2D->RefCount += MAX_TEXTURE_IMAGE_UNITS;
   ss->Default3D->RefCount += MAX_TEXTURE_IMAGE_UNITS;
   ss->DefaultCubeMap->RefCount += MAX_TEXTURE_IMAGE_UNITS;
   ss->DefaultRect->RefCount += MAX_TEXTURE_IMAGE_UNITS;
a484 1

d487 1
a487 1
 cleanup:
d518 2
a519 2
   if (ss->GL2Objects)
      _mesa_DeleteHashTable (ss->GL2Objects);
d612 46
a679 14
   /*
    * Free texture objects
    */
   ASSERT(ctx->Driver.DeleteTexture);
   /* the default textures */
   ctx->Driver.DeleteTexture(ctx, ss->Default1D);
   ctx->Driver.DeleteTexture(ctx, ss->Default2D);
   ctx->Driver.DeleteTexture(ctx, ss->Default3D);
   ctx->Driver.DeleteTexture(ctx, ss->DefaultCubeMap);
   ctx->Driver.DeleteTexture(ctx, ss->DefaultRect);
   /* all other textures */
   _mesa_HashDeleteAll(ss->TexObjects, delete_texture_cb, ctx);
   _mesa_DeleteHashTable(ss->TexObjects);

d706 2
a707 1
   _mesa_DeleteHashTable(ss->GL2Objects);
d711 1
d713 1
d717 15
d742 1
a742 1
_mesa_init_current( GLcontext *ctx )
d756 2
a757 3
   ASSIGN_4V( ctx->Current.Attrib[VERT_ATTRIB_FOG], 0.0, 0.0, 0.0, 0.0 );
   ctx->Current.Attrib[VERT_ATTRIB_COLOR_INDEX][0] = 1.0;
   ctx->Current.EdgeFlag = GL_TRUE;
d784 1
a784 1
_mesa_init_constants( GLcontext *ctx )
d832 1
a832 1
   ctx->Const.VertexProgram.MaxTemps = MAX_NV_VERTEX_PROGRAM_TEMPS;
d835 1
a835 1
   ctx->Const.VertexProgram.MaxEnvParams = MAX_NV_VERTEX_PROGRAM_PARAMS;
d837 1
d840 1
d847 1
a847 1
   ctx->Const.FragmentProgram.MaxTemps = MAX_NV_FRAGMENT_PROGRAM_TEMPS;
d850 1
a850 1
   ctx->Const.FragmentProgram.MaxEnvParams = MAX_NV_FRAGMENT_PROGRAM_PARAMS;
d852 1
d858 1
a858 6
   /* If we're running in the X server, do bounds checking to prevent
    * segfaults and server crashes!
    */
#if defined(XFree86LOADER) && defined(IN_MODULE)
   ctx->Const.CheckArrayBounds = GL_TRUE;
#else
a859 1
#endif
d873 5
d883 5
d929 1
a929 1
init_attrib_groups( GLcontext *ctx )
d965 1
a965 1
   _mesa_init_shaderobjects (ctx);
d1052 5
a1056 5
_mesa_initialize_context( GLcontext *ctx,
                          const GLvisual *visual,
                          GLcontext *share_list,
                          const struct dd_function_table *driverFunctions,
                          void *driverContext )
a1061 8
   /* If the driver wants core Mesa to use special imports, it'll have to
    * override these defaults.
    */
   _mesa_init_default_imports( &(ctx->imports), driverContext );

   /* initialize the exports (Mesa functions called by the window system) */
   _mesa_init_default_exports( &(ctx->exports) );

d1117 10
a1126 6
   ctx->_MaintainTexEnvProgram = (_mesa_getenv("MESA_TEX_PROG") != NULL);
   ctx->_UseTexEnvProgram = ctx->_MaintainTexEnvProgram;

   ctx->_MaintainTnlProgram = (_mesa_getenv("MESA_TNL_PROG") != NULL);
   if (ctx->_MaintainTnlProgram)
      ctx->_MaintainTexEnvProgram = 1; /* this is required... */
d1149 4
a1152 5
_mesa_create_context( const GLvisual *visual,
                      GLcontext *share_list,
                      const struct dd_function_table *driverFunctions,
                      void *driverContext )

d1184 5
a1188 3
   /* if we're destroying the current context, unbind it first */
   if (ctx == _mesa_get_current_context()) {
      _mesa_make_current(NULL, NULL, NULL);
d1191 7
d1205 1
d1229 5
d1416 2
d1420 1
d1438 6
a1443 5
   ASSERT(ctx->Driver.GetBufferSize);
   ctx->Driver.GetBufferSize(fb, &width, &height);
   if (ctx->Driver.ResizeBuffers)
      ctx->Driver.ResizeBuffers(ctx, fb, width, height);
   fb->Initialized = GL_TRUE;
d1500 2
a1501 2
         newCtx->WinSysDrawBuffer = drawBuffer;
         newCtx->WinSysReadBuffer = readBuffer;
d1508 1
a1508 1
            newCtx->DrawBuffer = drawBuffer;
d1511 1
a1511 1
            newCtx->ReadBuffer = readBuffer;
d1516 3
d1526 18
d1545 1
d1597 1
a1597 3
 * Get current context for the calling thread.
 * 
 * \return pointer to the current GL context.
d1600 2
a1601 1
 * context.  If you need speed, see the #GET_CURRENT_CONTEXT macro in context.h.
d1609 1
d1649 1
a1649 1
_mesa_record_error( GLcontext *ctx, GLenum error )
d1660 1
a1660 1
      (*ctx->Driver.Error)( ctx );
d1664 1
d1672 1
a1672 1
_mesa_Finish( void )
d1677 1
a1677 1
      (*ctx->Driver.Finish)( ctx );
d1681 1
d1689 1
a1689 1
_mesa_Flush( void )
d1694 1
a1694 1
      (*ctx->Driver.Flush)( ctx );
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@a737 4
   _glthread_INIT_MUTEX(ss->TexMutex);
   ss->TextureStateStamp = 0;


a874 10
/**
 * Callback for deleting an shader object.  Called by _mesa_HashDeleteAll().
 */
static void
delete_shaderobj_cb(GLuint id, void *data, void *userData)
{
   /* XXX probably need to fix this */
   _mesa_free(data);
}

a936 1
   _mesa_HashDeleteAll(ss->GL2Objects, delete_shaderobj_cb, ctx);
a1050 1
   ctx->Const.VertexProgram.MaxUniformComponents = MAX_VERTEX_UNIFORM_COMPONENTS;
a1063 1
   ctx->Const.FragmentProgram.MaxUniformComponents = MAX_FRAGMENT_UNIFORM_COMPONENTS;
d1072 1
a1072 1
#if defined(XFree86Server)
a1089 5
#if FEATURE_ARB_vertex_shader
   ctx->Const.MaxVertexTextureImageUnits = MAX_VERTEX_TEXTURE_IMAGE_UNITS;
   ctx->Const.MaxVaryingFloats = MAX_VARYING_FLOATS;
#endif

d1632 5
a1636 6
   if (ctx->Driver.GetBufferSize) {
      ctx->Driver.GetBufferSize(fb, &width, &height);
      if (ctx->Driver.ResizeBuffers)
         ctx->Driver.ResizeBuffers(ctx, fb, width, height);
      fb->Initialized = GL_TRUE;
   }
a1708 3
#if 1
         /* We want to get rid of these lines: */

a1715 2

	 _mesa_resizebuffers(newCtx);
a1716 17

#else
         /* We want the drawBuffer and readBuffer to be initialized by
          * the driver.
          * This generally means the Width and Height match the actual
          * window size and the renderbuffers (both hardware and software
          * based) are allocated to match.  The later can generally be
          * done with a call to _mesa_resize_framebuffer().
          *
          * It's theoretically possible for a buffer to have zero width
          * or height, but for now, assert check that the driver did what's
          * expected of it.
          */
         ASSERT(drawBuffer->Width > 0);
         ASSERT(drawBuffer->Height > 0);
#endif

@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d9 1
a9 1
 * Version:  7.0
d11 1
a11 1
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
a97 1
#include "framebuffer.h"
d109 1
a115 1
#include "queryobj.h"
d134 1
a134 1
#include "shader_api.h"
d156 165
d335 99
a627 2
      _mesa_init_sqrt_table();

d708 1
a708 1
   ss->ShaderObjects = _mesa_NewHashTable();
d785 2
a786 2
   if (ss->ShaderObjects)
      _mesa_DeleteHashTable (ss->ShaderObjects);
d880 1
a880 2
 * Callback for deleting shader and shader programs objects.
 * Called by _mesa_HashDeleteAll().
d883 1
a883 1
delete_shader_cb(GLuint id, void *data, void *userData)
d885 2
a886 10
   GLcontext *ctx = (GLcontext *) userData;
   struct gl_shader *sh = (struct gl_shader *) data;
   if (sh->Type == GL_FRAGMENT_SHADER || sh->Type == GL_VERTEX_SHADER) {
      _mesa_free_shader(ctx, sh);
   }
   else {
      struct gl_shader_program *shProg = (struct gl_shader_program *) data;
      ASSERT(shProg->Type == GL_SHADER_PROGRAM_MESA);
      _mesa_free_shader_program(ctx, shProg);
   }
d951 2
a952 2
   _mesa_HashDeleteAll(ss->ShaderObjects, delete_shader_cb, ctx);
   _mesa_DeleteHashTable(ss->ShaderObjects);
d970 1
a970 1
_mesa_init_current(GLcontext *ctx)
d984 3
a986 2
   ASSIGN_4V( ctx->Current.Attrib[VERT_ATTRIB_COLOR_INDEX], 1.0, 0.0, 0.0, 1.0 );
   ASSIGN_4V( ctx->Current.Attrib[VERT_ATTRIB_EDGEFLAG], 1.0, 0.0, 0.0, 1.0 );
d1013 1
a1013 1
_mesa_init_constants(GLcontext *ctx)
d1061 1
a1061 1
   ctx->Const.VertexProgram.MaxTemps = MAX_PROGRAM_TEMPS;
d1064 1
a1064 1
   ctx->Const.VertexProgram.MaxEnvParams = MAX_PROGRAM_ENV_PARAMS;
d1066 1
a1066 1
   ctx->Const.VertexProgram.MaxUniformComponents = 4 * MAX_UNIFORMS;
a1068 1

d1075 1
a1075 1
   ctx->Const.FragmentProgram.MaxTemps = MAX_PROGRAM_TEMPS;
d1078 1
a1078 1
   ctx->Const.FragmentProgram.MaxEnvParams = MAX_PROGRAM_ENV_PARAMS;
d1080 1
a1080 1
   ctx->Const.FragmentProgram.MaxUniformComponents = 4 * MAX_UNIFORMS;
d1086 6
a1091 1
   /* CheckArrayBounds is overriden by drivers/x11 for X server */
d1093 1
d1109 1
a1109 1
   ctx->Const.MaxVarying = MAX_VARYING;
a1116 5

   ASSERT(MAX_NV_FRAGMENT_PROGRAM_TEMPS <= MAX_PROGRAM_TEMPS);
   ASSERT(MAX_NV_VERTEX_PROGRAM_TEMPS <= MAX_PROGRAM_TEMPS);
   ASSERT(MAX_NV_VERTEX_PROGRAM_INPUTS <= VERT_ATTRIB_MAX);
   ASSERT(MAX_NV_VERTEX_PROGRAM_OUTPUTS <= VERT_RESULT_MAX);
d1158 1
a1158 1
init_attrib_groups(GLcontext *ctx)
d1194 1
a1194 1
   _mesa_init_shader_state( ctx );
d1281 5
a1285 5
_mesa_initialize_context(GLcontext *ctx,
                         const GLvisual *visual,
                         GLcontext *share_list,
                         const struct dd_function_table *driverFunctions,
                         void *driverContext)
d1291 8
d1354 6
a1359 10
   ctx->FragmentProgram._MaintainTexEnvProgram
      = (_mesa_getenv("MESA_TEX_PROG") != NULL);
   ctx->FragmentProgram._UseTexEnvProgram = ctx->FragmentProgram._MaintainTexEnvProgram;

   ctx->VertexProgram._MaintainTnlProgram
      = (_mesa_getenv("MESA_TNL_PROG") != NULL);
   if (ctx->VertexProgram._MaintainTnlProgram) {
      /* this is required... */
      ctx->FragmentProgram._MaintainTexEnvProgram = GL_TRUE;
   }
d1382 5
a1386 4
_mesa_create_context(const GLvisual *visual,
                     GLcontext *share_list,
                     const struct dd_function_table *driverFunctions,
                     void *driverContext)
a1421 7
   else {
      /* unreference WinSysDraw/Read buffers */
      _mesa_unreference_framebuffer(&ctx->WinSysDrawBuffer);
      _mesa_unreference_framebuffer(&ctx->WinSysReadBuffer);
      _mesa_unreference_framebuffer(&ctx->DrawBuffer);
      _mesa_unreference_framebuffer(&ctx->ReadBuffer);
   }
a1429 1
   _mesa_free_shader_state(ctx);
a1634 2
#if 0
   /* disabled (see bug 11161) */
a1636 1
#endif
a1680 2
   GET_CURRENT_CONTEXT(oldCtx);

a1704 7
   if (oldCtx) {
      _mesa_unreference_framebuffer(&oldCtx->WinSysDrawBuffer);
      _mesa_unreference_framebuffer(&oldCtx->WinSysReadBuffer);
      _mesa_unreference_framebuffer(&oldCtx->DrawBuffer);
      _mesa_unreference_framebuffer(&oldCtx->ReadBuffer);
   }
         
d1716 2
a1717 2
         _mesa_reference_framebuffer(&newCtx->WinSysDrawBuffer, drawBuffer);
         _mesa_reference_framebuffer(&newCtx->WinSysReadBuffer, readBuffer);
d1724 1
a1724 1
            _mesa_reference_framebuffer(&newCtx->DrawBuffer, drawBuffer);
d1727 1
a1727 1
            _mesa_reference_framebuffer(&newCtx->ReadBuffer, readBuffer);
d1813 3
a1815 1
 * \return pointer to the current GL context for this thread.
d1818 1
a1818 2
 * context.  If you need speed, see the #GET_CURRENT_CONTEXT macro in
 * context.h.
a1825 1

d1865 1
a1865 1
_mesa_record_error(GLcontext *ctx, GLenum error)
d1876 1
a1876 1
      ctx->Driver.Error(ctx);
a1879 1

d1887 1
a1887 1
_mesa_Finish(void)
d1892 1
a1892 1
      ctx->Driver.Finish(ctx);
a1895 1

d1903 1
a1903 1
_mesa_Flush(void)
d1908 1
a1908 1
      ctx->Driver.Flush(ctx);
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d1 6
d9 1
a9 1
 * Version:  7.3
a11 1
 * Copyright (C) 2008  VMware, Inc.  All Rights Reserved.
a30 5
/**
 * \file context.c
 * Mesa context/visual/framebuffer management functions.
 * \author Brian Paul
 */
a79 1
#include "mfeatures.h"
a81 1
#include "api_exec.h"
d87 1
a88 1
#include "cpuinfo.h"
d93 1
d99 4
d105 1
a109 1
#include "multisample.h"
a110 1
#include "pixelstore.h"
d113 3
a116 1
#include "syncobj.h"
a117 4
#include "remap.h"
#include "scissor.h"
#include "shared.h"
#include "shaderobj.h"
d121 3
a123 1
#include "texcompress_s3tc.h"
a124 1
#include "transformfeedback.h"
a127 1
#include "viewport.h"
a128 2
#include "program/program.h"
#include "program/prog_print.h"
d130 1
d132 2
d135 1
a135 1
#include "main/dispatch.h" /* for _gloffset_COUNT */
a140 4
#include "glsl_parser_extras.h"
#include <stdbool.h>


d153 2
d160 1
a160 1
 * \param ctx GL context.
d166 1
a166 1
_mesa_notifySwapBuffers(struct gl_context *ctx)
d168 1
a168 6
   if (MESA_VERBOSE & VERBOSE_SWAPBUFFERS)
      _mesa_debug(ctx, "SwapBuffers\n");
   FLUSH_CURRENT( ctx, 0 );
   if (ctx->Driver.Flush) {
      ctx->Driver.Flush(ctx);
   }
d178 1
a178 1
 * Allocates a struct gl_config structure and initializes it via
d181 1
d197 1
a197 1
 * \return pointer to new struct gl_config or NULL if requested parameters can't be
d202 3
a204 2
struct gl_config *
_mesa_create_visual( GLboolean dbFlag,
d210 1
d219 1
a219 1
   struct gl_config *vis = CALLOC_STRUCT(gl_config);
d221 1
a221 1
      if (!_mesa_initialize_visual(vis, dbFlag, stereoFlag,
d223 1
a223 1
                                   depthBits, stencilBits,
d227 1
a227 1
         free(vis);
a233 1

d235 4
a238 5
 * Makes some sanity checks and fills in the fields of the struct
 * gl_config object with the given parameters.  If the caller needs to
 * set additional fields, he should just probably init the whole
 * gl_config object himself.
 *
d244 2
a245 1
_mesa_initialize_visual( struct gl_config *vis,
d252 1
d274 1
a274 1
   vis->rgbMode          = GL_TRUE;
d284 1
a284 1
   vis->indexBits      = 0;
d299 1
d315 1
a315 1
_mesa_destroy_visual( struct gl_config *vis )
d317 1
a317 1
   free(vis);
a331 32

/**
 * This is lame.  gdb only seems to recognize enum types that are
 * actually used somewhere.  We want to be able to print/use enum
 * values such as TEXTURE_2D_INDEX in gdb.  But we don't actually use
 * the gl_texture_index type anywhere.  Thus, this lame function.
 */
static void
dummy_enum_func(void)
{
   gl_buffer_index bi = BUFFER_FRONT_LEFT;
   gl_face_index fi = FACE_POS_X;
   gl_frag_attrib fa = FRAG_ATTRIB_WPOS;
   gl_frag_result fr = FRAG_RESULT_DEPTH;
   gl_texture_index ti = TEXTURE_2D_ARRAY_INDEX;
   gl_vert_attrib va = VERT_ATTRIB_POS;
   gl_vert_result vr = VERT_RESULT_HPOS;
   gl_geom_attrib ga = GEOM_ATTRIB_POSITION;
   gl_geom_result gr = GEOM_RESULT_POS;

   (void) bi;
   (void) fi;
   (void) fa;
   (void) fr;
   (void) ti;
   (void) va;
   (void) vr;
   (void) ga;
   (void) gr;
}


a338 2


d349 1
a349 1
one_time_init( struct gl_context *ctx )
d351 2
a352 2
   static GLbitfield api_init_mask = 0x0;

d354 1
a354 3

   /* truly one-time init */
   if (!api_init_mask) {
a364 2
      _mesa_get_cpu_features();

d367 2
a368 2
      /* context dependence is never a one-time thing... */
      _mesa_init_get_hash(ctx);
d373 12
d387 2
a388 4
      if (MESA_VERBOSE != 0) {
	 _mesa_debug(ctx, "Mesa %s DEBUG build %s %s\n",
		     MESA_VERSION_STRING, __DATE__, __TIME__);
      }
d390 2
d393 86
d480 154
a633 10
   /* per-API one-time init */
   if (!(api_init_mask & (1 << ctx->API))) {
      /*
       * This is fine as ES does not use the remap table, but it may not be
       * future-proof.  We cannot always initialize the remap table because
       * when an app is linked to libGLES*, there are not enough dynamic
       * entries.
       */
      if (ctx->API == API_OPENGL)
         _mesa_init_remap_table();
d635 1
a636 1
   api_init_mask |= 1 << ctx->API;
d638 20
a657 1
   _glthread_UNLOCK_MUTEX(OneTimeLock);
d659 2
a660 2
   /* Hopefully atexit() is widely available.  If not, we may need some
    * #ifdef tests here.
d662 40
a701 1
   atexit(_mesa_destroy_shader_compiler);
d703 8
a710 1
   dummy_enum_func();
d718 1
a718 1
_mesa_init_current(struct gl_context *ctx)
d723 1
a723 1
   for (i = 0; i < Elements(ctx->Current.Attrib); i++) {
d728 1
a728 1
   ASSIGN_4V( ctx->Current.Attrib[VERT_ATTRIB_WEIGHT], 1.0, 0.0, 0.0, 0.0 );
d738 1
a738 2
 * Init vertex/fragment/geometry program limits.
 * Important: drivers should override these with actual limits.
d741 1
a741 1
init_program_limits(GLenum type, struct gl_program_constants *prog)
d743 8
a750 57
   prog->MaxInstructions = MAX_PROGRAM_INSTRUCTIONS;
   prog->MaxAluInstructions = MAX_PROGRAM_INSTRUCTIONS;
   prog->MaxTexInstructions = MAX_PROGRAM_INSTRUCTIONS;
   prog->MaxTexIndirections = MAX_PROGRAM_INSTRUCTIONS;
   prog->MaxTemps = MAX_PROGRAM_TEMPS;
   prog->MaxEnvParams = MAX_PROGRAM_ENV_PARAMS;
   prog->MaxLocalParams = MAX_PROGRAM_LOCAL_PARAMS;
   prog->MaxUniformComponents = 4 * MAX_UNIFORMS;

   switch (type) {
   case GL_VERTEX_PROGRAM_ARB:
      prog->MaxParameters = MAX_VERTEX_PROGRAM_PARAMS;
      prog->MaxAttribs = MAX_NV_VERTEX_PROGRAM_INPUTS;
      prog->MaxAddressRegs = MAX_VERTEX_PROGRAM_ADDRESS_REGS;
      break;
   case GL_FRAGMENT_PROGRAM_ARB:
      prog->MaxParameters = MAX_NV_FRAGMENT_PROGRAM_PARAMS;
      prog->MaxAttribs = MAX_NV_FRAGMENT_PROGRAM_INPUTS;
      prog->MaxAddressRegs = MAX_FRAGMENT_PROGRAM_ADDRESS_REGS;
      break;
   case MESA_GEOMETRY_PROGRAM:
      prog->MaxParameters = MAX_NV_VERTEX_PROGRAM_PARAMS;
      prog->MaxAttribs = MAX_NV_VERTEX_PROGRAM_INPUTS;
      prog->MaxAddressRegs = MAX_VERTEX_PROGRAM_ADDRESS_REGS;

      prog->MaxGeometryTextureImageUnits = MAX_GEOMETRY_TEXTURE_IMAGE_UNITS;
      prog->MaxGeometryVaryingComponents = MAX_GEOMETRY_VARYING_COMPONENTS;
      prog->MaxVertexVaryingComponents = MAX_VERTEX_VARYING_COMPONENTS;
      prog->MaxGeometryUniformComponents = MAX_GEOMETRY_UNIFORM_COMPONENTS;
      prog->MaxGeometryOutputVertices = MAX_GEOMETRY_OUTPUT_VERTICES;
      prog->MaxGeometryTotalOutputComponents = MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS;
      break;
   default:
      assert(0 && "Bad program type in init_program_limits()");
   }

   /* Set the native limits to zero.  This implies that there is no native
    * support for shaders.  Let the drivers fill in the actual values.
    */
   prog->MaxNativeInstructions = 0;
   prog->MaxNativeAluInstructions = 0;
   prog->MaxNativeTexInstructions = 0;
   prog->MaxNativeTexIndirections = 0;
   prog->MaxNativeAttribs = 0;
   prog->MaxNativeTemps = 0;
   prog->MaxNativeAddressRegs = 0;
   prog->MaxNativeParameters = 0;

   /* Set GLSL datatype range/precision info assuming IEEE float values.
    * Drivers should override these defaults as needed.
    */
   prog->MediumFloat.RangeMin = 127;
   prog->MediumFloat.RangeMax = 127;
   prog->MediumFloat.Precision = 23;
   prog->LowFloat = prog->HighFloat = prog->MediumFloat;
   /* assume ints are stored as floats for now */
   prog->LowInt = prog->MediumInt = prog->HighInt = prog->MediumFloat;
d760 1
a760 1
_mesa_init_constants(struct gl_context *ctx)
d764 6
a770 1
   ctx->Const.MaxTextureMbytes = MAX_TEXTURE_MBYTES;
a774 1
   ctx->Const.MaxArrayTextureLayers = MAX_ARRAY_TEXTURE_LAYERS;
d794 2
d803 12
a814 1
   init_program_limits(GL_VERTEX_PROGRAM_ARB, &ctx->Const.VertexProgram);
d816 1
d818 12
a829 4
   init_program_limits(GL_FRAGMENT_PROGRAM_ARB, &ctx->Const.FragmentProgram);
#endif
#if FEATURE_ARB_geometry_shader4
   init_program_limits(MESA_GEOMETRY_PROGRAM, &ctx->Const.GeometryProgram);
d840 4
a850 1
   ctx->Const.MaxCombinedTextureImageUnits = MAX_COMBINED_TEXTURE_IMAGE_UNITS;
d854 5
a858 22
   /* Shading language version */
   if (ctx->API == API_OPENGL) {
      ctx->Const.GLSLVersion = 120;
   }
   else if (ctx->API == API_OPENGLES2) {
      ctx->Const.GLSLVersion = 100;
   }
   else if (ctx->API == API_OPENGLES) {
      ctx->Const.GLSLVersion = 0; /* GLSL not supported */
   }

   /* GL_ARB_framebuffer_object */
   ctx->Const.MaxSamples = 0;

   /* GL_ARB_sync */
   ctx->Const.MaxServerWaitTimeout = (GLuint64) ~0;

   /* GL_ATI_envmap_bumpmap */
   ctx->Const.SupportedBumpUnits = SUPPORTED_ATI_BUMP_UNITS;

   /* GL_EXT_provoking_vertex */
   ctx->Const.QuadsFollowProvokingVertexConvention = GL_TRUE;
d860 4
a863 11
   /* GL_EXT_transform_feedback */
   ctx->Const.MaxTransformFeedbackSeparateAttribs = MAX_FEEDBACK_ATTRIBS;
   ctx->Const.MaxTransformFeedbackSeparateComponents = 4 * MAX_FEEDBACK_ATTRIBS;
   ctx->Const.MaxTransformFeedbackInterleavedComponents = 4 * MAX_FEEDBACK_ATTRIBS;

   /* GL 3.2: hard-coded for now: */
   ctx->Const.ProfileMask = GL_CONTEXT_COMPATIBILITY_PROFILE_BIT;

   /** GL_EXT_gpu_shader4 */
   ctx->Const.MinProgramTexelOffset = -8;
   ctx->Const.MaxProgramTexelOffset = 7;
d872 1
a872 1
check_context_limits(struct gl_context *ctx)
d874 3
a876 19
   /* check that we don't exceed the size of various bitfields */
   assert(VERT_RESULT_MAX <=
	  (8 * sizeof(ctx->VertexProgram._Current->Base.OutputsWritten)));
   assert(FRAG_ATTRIB_MAX <=
	  (8 * sizeof(ctx->FragmentProgram._Current->Base.InputsRead)));

   assert(MAX_COMBINED_TEXTURE_IMAGE_UNITS <= 8 * sizeof(GLbitfield));

   /* shader-related checks */
   assert(ctx->Const.FragmentProgram.MaxLocalParams <= MAX_PROGRAM_LOCAL_PARAMS);
   assert(ctx->Const.VertexProgram.MaxLocalParams <= MAX_PROGRAM_LOCAL_PARAMS);

   assert(MAX_NV_FRAGMENT_PROGRAM_TEMPS <= MAX_PROGRAM_TEMPS);
   assert(MAX_NV_VERTEX_PROGRAM_TEMPS <= MAX_PROGRAM_TEMPS);
   assert(MAX_NV_VERTEX_PROGRAM_INPUTS <= VERT_ATTRIB_MAX);
   assert(MAX_NV_VERTEX_PROGRAM_OUTPUTS <= VERT_RESULT_MAX);

   /* Texture unit checks */
   assert(ctx->Const.MaxTextureImageUnits > 0);
a877 1
   assert(ctx->Const.MaxTextureCoordUnits > 0);
a878 1
   assert(ctx->Const.MaxTextureUnits > 0);
a880 7
   assert(ctx->Const.MaxTextureUnits == MIN2(ctx->Const.MaxTextureImageUnits,
                                             ctx->Const.MaxTextureCoordUnits));
   assert(ctx->Const.MaxCombinedTextureImageUnits > 0);
   assert(ctx->Const.MaxCombinedTextureImageUnits <= MAX_COMBINED_TEXTURE_IMAGE_UNITS);
   assert(ctx->Const.MaxTextureCoordUnits <= MAX_COMBINED_TEXTURE_IMAGE_UNITS);
   /* number of coord units cannot be greater than number of image units */
   assert(ctx->Const.MaxTextureCoordUnits <= ctx->Const.MaxTextureImageUnits);
d882 2
a883 6

   /* Texture size checks */
   assert(ctx->Const.MaxTextureLevels <= MAX_TEXTURE_LEVELS);
   assert(ctx->Const.Max3DTextureLevels <= MAX_3D_TEXTURE_LEVELS);
   assert(ctx->Const.MaxCubeTextureLevels <= MAX_CUBE_TEXTURE_LEVELS);
   assert(ctx->Const.MaxTextureRectSize <= MAX_TEXTURE_RECT_SIZE);
d886 3
a888 13
   assert((1 << (ctx->Const.MaxTextureLevels - 1)) <= MAX_WIDTH);
   assert((1 << (ctx->Const.MaxCubeTextureLevels - 1)) <= MAX_WIDTH);
   assert((1 << (ctx->Const.Max3DTextureLevels - 1)) <= MAX_WIDTH);

   /* Texture level checks */
   assert(MAX_TEXTURE_LEVELS >= MAX_3D_TEXTURE_LEVELS);
   assert(MAX_TEXTURE_LEVELS >= MAX_CUBE_TEXTURE_LEVELS);

   /* Max texture size should be <= max viewport size (render to texture) */
   assert((1 << (MAX_TEXTURE_LEVELS - 1)) <= MAX_WIDTH);

   assert(ctx->Const.MaxViewportWidth <= MAX_WIDTH);
   assert(ctx->Const.MaxViewportHeight <= MAX_WIDTH);
a891 3
   /* if this fails, add more enum values to gl_buffer_index */
   assert(BUFFER_COLOR0 + MAX_DRAW_BUFFERS <= BUFFER_COUNT);

d905 1
a905 1
init_attrib_groups(struct gl_context *ctx)
d920 1
a925 1
   _mesa_init_fbobjects( ctx );
d928 1
a934 1
   _mesa_init_pixelstore( ctx );
d938 1
a938 2
   _mesa_init_queryobj( ctx );
   _mesa_init_sync( ctx );
a943 1
   _mesa_init_transform_feedback( ctx );
d951 1
d956 1
a956 23
   ctx->varying_vp_inputs = ~0;

   return GL_TRUE;
}


/**
 * Update default objects in a GL context with respect to shared state.
 *
 * \param ctx GL context.
 *
 * Removes references to old default objects, (texture objects, program
 * objects, etc.) and changes to reference those from the current shared
 * state.
 */
static GLboolean
update_default_objects(struct gl_context *ctx)
{
   assert(ctx);

   _mesa_update_default_objects_program(ctx);
   _mesa_update_default_objects_texture(ctx);
   _mesa_update_default_objects_buffer_objects(ctx);
d970 1
a970 1
   _mesa_warning(NULL, "User called no-op dispatch function (an unsupported extension function?)");
d978 2
a979 2
struct _glapi_table *
_mesa_alloc_dispatch_table(int size)
d986 4
a989 7
   GLint numEntries = MAX2(_glapi_get_dispatch_table_size(), _gloffset_COUNT);
   struct _glapi_table *table;

   /* should never happen, but just in case */
   numEntries = MAX2(numEntries, size);

   table = (struct _glapi_table *) malloc(numEntries * sizeof(_glapi_proc));
d1002 1
a1002 1
 * Initialize a struct gl_context struct (rendering context).
a1019 1
 * \param api the GL API type to create the context for
d1028 5
a1032 6
_mesa_initialize_context_for_api(struct gl_context *ctx,
				 gl_api api,
				 const struct gl_config *visual,
				 struct gl_context *share_list,
				 const struct dd_function_table *driverFunctions,
				 void *driverContext)
d1034 1
a1034 4
   struct gl_shared_state *shared;
   int i;

   /*ASSERT(driverContext);*/
d1038 3
a1040 1
   ctx->API = api;
a1046 3
   /* misc one-time initializations */
   one_time_init(ctx);

d1057 1
a1057 1
      shared = share_list->Shared;
d1061 1
a1061 2
      shared = _mesa_alloc_shared_state(ctx);
      if (!shared)
d1063 1
d1065 3
a1067 5

   _glthread_LOCK_MUTEX(shared->Mutex);
   ctx->Shared = shared;
   shared->RefCount++;
   _glthread_UNLOCK_MUTEX(shared->Mutex);
d1070 1
a1070 1
      _mesa_release_shared_state(ctx, ctx->Shared);
a1073 1
#if FEATURE_dispatch
d1075 6
a1080 24
   switch (ctx->API) {
#if FEATURE_GL
   case API_OPENGL:
      ctx->Exec = _mesa_create_exec_table();
      break;
#endif
#if FEATURE_ES1
   case API_OPENGLES:
      ctx->Exec = _mesa_create_exec_table_es1();
      break;
#endif
#if FEATURE_ES2
   case API_OPENGLES2:
      ctx->Exec = _mesa_create_exec_table_es2();
      break;
#endif
   default:
      _mesa_problem(ctx, "unknown or unsupported API");
      break;
   }

   if (!ctx->Exec) {
      _mesa_release_shared_state(ctx, ctx->Shared);
      return GL_FALSE;
d1082 9
a1091 1
   ctx->CurrentDispatch = ctx->Exec;
d1095 1
a1103 35
   switch (ctx->API) {
   case API_OPENGL:
#if FEATURE_dlist
      ctx->Save = _mesa_create_save_table();
      if (!ctx->Save) {
	 _mesa_release_shared_state(ctx, ctx->Shared);
	 free(ctx->Exec);
	 return GL_FALSE;
      }

      _mesa_install_save_vtxfmt( ctx, &ctx->ListState.ListVtxfmt );
#endif
      break;
   case API_OPENGLES:
      /**
       * GL_OES_texture_cube_map says
       * "Initially all texture generation modes are set to REFLECTION_MAP_OES"
       */
      for (i = 0; i < MAX_TEXTURE_UNITS; i++) {
	 struct gl_texture_unit *texUnit = &ctx->Texture.Unit[i];
	 texUnit->GenS.Mode = GL_REFLECTION_MAP_NV;
	 texUnit->GenT.Mode = GL_REFLECTION_MAP_NV;
	 texUnit->GenR.Mode = GL_REFLECTION_MAP_NV;
	 texUnit->GenS._ModeBit = TEXGEN_REFLECTION_MAP_NV;
	 texUnit->GenT._ModeBit = TEXGEN_REFLECTION_MAP_NV;
	 texUnit->GenR._ModeBit = TEXGEN_REFLECTION_MAP_NV;
      }
      break;
   case API_OPENGLES2:
      ctx->FragmentProgram._MaintainTexEnvProgram = GL_TRUE;
      ctx->VertexProgram._MaintainTnlProgram = GL_TRUE;
      ctx->Point.PointSprite = GL_TRUE;  /* always on for ES 2.x */
      break;
   }

d1111 1
a1111 20
 * Initialize an OpenGL context.
 */
GLboolean
_mesa_initialize_context(struct gl_context *ctx,
                         const struct gl_config *visual,
                         struct gl_context *share_list,
                         const struct dd_function_table *driverFunctions,
                         void *driverContext)
{
   return _mesa_initialize_context_for_api(ctx,
					   API_OPENGL,
					   visual,
					   share_list,
					   driverFunctions,
					   driverContext);
}


/**
 * Allocate and initialize a struct gl_context structure.
d1116 1
a1116 2
 * \param api the GL API type to create the context for
 * \param visual a struct gl_config pointer (we copy the struct contents)
d1120 1
a1120 1
 * \param driverContext points to the device driver's private context state
d1122 1
a1122 1
 * \return pointer to a new __struct gl_contextRec or NULL if error.
d1124 5
a1128 6
struct gl_context *
_mesa_create_context_for_api(gl_api api,
			     const struct gl_config *visual,
			     struct gl_context *share_list,
			     const struct dd_function_table *driverFunctions,
			     void *driverContext)
d1130 1
a1130 1
   struct gl_context *ctx;
d1133 1
a1133 1
   /*ASSERT(driverContext);*/
d1135 1
a1135 1
   ctx = (struct gl_context *) calloc(1, sizeof(struct gl_context));
d1139 2
a1140 2
   if (_mesa_initialize_context_for_api(ctx, api, visual, share_list,
					driverFunctions, driverContext)) {
d1144 1
a1144 1
      free(ctx);
a1150 16
 * Create an OpenGL context.
 */
struct gl_context *
_mesa_create_context(const struct gl_config *visual,
		     struct gl_context *share_list,
		     const struct dd_function_table *driverFunctions,
		     void *driverContext)
{
   return _mesa_create_context_for_api(API_OPENGL, visual,
				       share_list,
				       driverFunctions,
				       driverContext);
}


/**
d1153 1
a1153 1
 * But doesn't free the struct gl_context struct itself.
d1158 1
a1158 1
_mesa_free_context_data( struct gl_context *ctx )
d1160 10
a1169 5
   if (!_mesa_get_current_context()){
      /* No current context, but we may need one in order to delete
       * texture objs, etc.  So temporarily bind the context now.
       */
      _mesa_make_current(ctx, NULL, NULL);
a1171 16
   /* unreference WinSysDraw/Read buffers */
   _mesa_reference_framebuffer(&ctx->WinSysDrawBuffer, NULL);
   _mesa_reference_framebuffer(&ctx->WinSysReadBuffer, NULL);
   _mesa_reference_framebuffer(&ctx->DrawBuffer, NULL);
   _mesa_reference_framebuffer(&ctx->ReadBuffer, NULL);

   _mesa_reference_vertprog(ctx, &ctx->VertexProgram.Current, NULL);
   _mesa_reference_vertprog(ctx, &ctx->VertexProgram._Current, NULL);
   _mesa_reference_vertprog(ctx, &ctx->VertexProgram._TnlProgram, NULL);

   _mesa_reference_fragprog(ctx, &ctx->FragmentProgram.Current, NULL);
   _mesa_reference_fragprog(ctx, &ctx->FragmentProgram._Current, NULL);
   _mesa_reference_fragprog(ctx, &ctx->FragmentProgram._TexEnvProgram, NULL);

   _mesa_free_attrib_data(ctx);
   _mesa_free_buffer_objects(ctx);
d1177 1
d1180 1
a1180 12
   _mesa_free_queryobj_data(ctx);
   _mesa_free_sync_data(ctx);
   _mesa_free_varray_data(ctx);
   _mesa_free_transform_feedback(ctx);

   _mesa_delete_array_object(ctx, ctx->Array.DefaultArrayObj);

#if FEATURE_ARB_pixel_buffer_object
   _mesa_reference_buffer_object(ctx, &ctx->Pack.BufferObj, NULL);
   _mesa_reference_buffer_object(ctx, &ctx->Unpack.BufferObj, NULL);
   _mesa_reference_buffer_object(ctx, &ctx->DefaultPacking.BufferObj, NULL);
#endif
d1183 1
a1183 2
   _mesa_reference_buffer_object(ctx, &ctx->Array.ArrayBufferObj, NULL);
   _mesa_reference_buffer_object(ctx, &ctx->Array.ElementArrayBufferObj, NULL);
d1185 1
d1188 2
a1189 2
   free(ctx->Exec);
   free(ctx->Save);
d1192 8
a1199 4
   _mesa_release_shared_state( ctx, ctx->Shared );

   /* needs to be after freeing shared state */
   _mesa_free_display_list_data(ctx);
d1202 1
a1202 9
      free((void *) ctx->Extensions.String);

   if (ctx->VersionString)
      free(ctx->VersionString);

   /* unbind the context if it's currently bound */
   if (ctx == _mesa_get_current_context()) {
      _mesa_make_current(NULL, NULL, NULL);
   }
d1207 1
a1207 1
 * Destroy a struct gl_context structure.
d1211 1
a1211 1
 * Calls _mesa_free_context_data() and frees the gl_context object itself.
d1214 1
a1214 1
_mesa_destroy_context( struct gl_context *ctx )
d1218 1
a1218 1
      free( (void *) ctx );
d1237 1
a1237 1
_mesa_copy_context( const struct gl_context *src, struct gl_context *dst, GLuint mask )
d1303 1
a1303 1
      /* Use loop instead of memcpy due to problem with Portland Group's
d1349 3
a1351 3
 * Most of these tests could go away because Mesa is now pretty flexible
 * in terms of mixing rendering contexts with framebuffers.  As long
 * as RGB vs. CI mode agree, we're probably good.
d1356 1
a1356 2
check_compatible(const struct gl_context *ctx,
                 const struct gl_framebuffer *buffer)
d1358 2
a1359 2
   const struct gl_config *ctxvis = &ctx->Visual;
   const struct gl_config *bufvis = &buffer->Visual;
d1361 1
a1361 1
   if (buffer == _mesa_get_incomplete_framebuffer())
d1364 2
d1404 1
a1404 1
initialize_framebuffer_size(struct gl_context *ctx, struct gl_framebuffer *fb)
a1416 18
 * Check if the viewport/scissor size has not yet been initialized.
 * Initialize the size if the given width and height are non-zero.
 */
void
_mesa_check_init_viewport(struct gl_context *ctx, GLuint width, GLuint height)
{
   if (!ctx->ViewportInitialized && width > 0 && height > 0) {
      /* Note: set flag here, before calling _mesa_set_viewport(), to prevent
       * potential infinite recursion.
       */
      ctx->ViewportInitialized = GL_TRUE;
      _mesa_set_viewport(ctx, 0, 0, width, height);
      _mesa_set_scissor(ctx, 0, 0, width, height);
   }
}


/**
d1430 3
a1432 4
GLboolean
_mesa_make_current( struct gl_context *newCtx,
                    struct gl_framebuffer *drawBuffer,
                    struct gl_framebuffer *readBuffer )
d1434 1
a1434 1
   GET_CURRENT_CONTEXT(curCtx);
d1445 1
a1445 1
         return GL_FALSE;
d1452 1
a1452 1
         return GL_FALSE;
a1455 5
   if (curCtx && 
      (curCtx->WinSysDrawBuffer || curCtx->WinSysReadBuffer) && /* make sure this context is valid for flushing */
      curCtx != newCtx)
      _mesa_flush(curCtx);

d1460 7
a1485 9
            /* KW: merge conflict here, revisit. 
             */
            /* fix up the fb fields - these will end up wrong otherwise
             * if the DRIdrawable changes, and everything relies on them.
             * This is a bit messy (same as needed in _mesa_BindFramebufferEXT)
             */
            unsigned int i;
            GLenum buffers[MAX_DRAW_BUFFERS];

a1486 7

            for(i = 0; i < newCtx->Const.MaxDrawBuffers; i++) {
               buffers[i] = newCtx->Color.DrawBuffer[i];
            }

            _mesa_drawbuffers(newCtx, newCtx->Const.MaxDrawBuffers,
                              buffers, NULL);
a1491 3
         /* XXX only set this flag if we're really changing the draw/read
          * framebuffer bindings.
          */
d1524 7
a1530 3
         if (drawBuffer) {
            _mesa_check_init_viewport(newCtx,
                                      drawBuffer->Width, drawBuffer->Height);
d1534 5
a1539 11
         _mesa_compute_version(newCtx);

         newCtx->Extensions.String = _mesa_make_extension_string(newCtx);

         check_context_limits(newCtx);

         /* We can use this to help debug user's problems.  Tell them to set
          * the MESA_INFO env variable before running their app.  Then the
          * first time each context is made current we'll print some useful
          * information.
          */
a1542 1

a1545 2
   
   return GL_TRUE;
d1556 1
a1556 1
_mesa_share_state(struct gl_context *ctx, struct gl_context *ctxToShare)
d1559 4
a1562 2
      struct gl_shared_state *oldSharedState = ctx->Shared;

a1563 2
      
      _glthread_LOCK_MUTEX(ctx->Shared->Mutex);
a1564 6
      _glthread_UNLOCK_MUTEX(ctx->Shared->Mutex);

      update_default_objects(ctx);

      _mesa_release_shared_state(ctx, oldSharedState);

d1581 1
a1581 1
struct gl_context *
d1584 1
a1584 1
   return (struct gl_context *) _glapi_get_context();
d1598 1
a1598 1
 * Simply returns __struct gl_contextRec::CurrentDispatch.
d1601 1
a1601 1
_mesa_get_dispatch(struct gl_context *ctx)
d1627 1
a1627 1
_mesa_record_error(struct gl_context *ctx, GLenum error)
a1643 27
 * Flush commands and wait for completion.
 */
void
_mesa_finish(struct gl_context *ctx)
{
   FLUSH_CURRENT( ctx, 0 );
   if (ctx->Driver.Finish) {
      ctx->Driver.Finish(ctx);
   }
}


/**
 * Flush commands.
 */
void
_mesa_flush(struct gl_context *ctx)
{
   FLUSH_CURRENT( ctx, 0 );
   if (ctx->Driver.Flush) {
      ctx->Driver.Flush(ctx);
   }
}



/**
d1654 3
a1656 1
   _mesa_finish(ctx);
d1671 2
a1672 55
   _mesa_flush(ctx);
}


/**
 * Set mvp_with_dp4 flag.  If a driver has a preference for DP4 over
 * MUL/MAD, or vice versa, call this function to register that.
 * Otherwise we default to MUL/MAD.
 */
void
_mesa_set_mvp_with_dp4( struct gl_context *ctx,
                        GLboolean flag )
{
   ctx->mvp_with_dp4 = flag;
}



/**
 * Prior to drawing anything with glBegin, glDrawArrays, etc. this function
 * is called to see if it's valid to render.  This involves checking that
 * the current shader is valid and the framebuffer is complete.
 * If an error is detected it'll be recorded here.
 * \return GL_TRUE if OK to render, GL_FALSE if not
 */
GLboolean
_mesa_valid_to_render(struct gl_context *ctx, const char *where)
{
   bool vert_from_glsl_shader = false;
   bool geom_from_glsl_shader = false;
   bool frag_from_glsl_shader = false;

   /* This depends on having up to date derived state (shaders) */
   if (ctx->NewState)
      _mesa_update_state(ctx);

   if (ctx->Shader.CurrentVertexProgram) {
      vert_from_glsl_shader = true;

      if (!ctx->Shader.CurrentVertexProgram->LinkStatus) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "%s(shader not linked)", where);
         return GL_FALSE;
      }
#if 0 /* not normally enabled */
      {
         char errMsg[100];
         if (!_mesa_validate_shader_program(ctx,
					    ctx->Shader.CurrentVertexProgram,
                                            errMsg)) {
            _mesa_warning(ctx, "Shader program %u is invalid: %s",
                          ctx->Shader.CurrentVertexProgram->Name, errMsg);
         }
      }
#endif
a1673 133

   if (ctx->Shader.CurrentGeometryProgram) {
      geom_from_glsl_shader = true;

      if (!ctx->Shader.CurrentGeometryProgram->LinkStatus) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "%s(shader not linked)", where);
         return GL_FALSE;
      }
#if 0 /* not normally enabled */
      {
         char errMsg[100];
         if (!_mesa_validate_shader_program(ctx,
					    ctx->Shader.CurrentGeometryProgram,
                                            errMsg)) {
            _mesa_warning(ctx, "Shader program %u is invalid: %s",
                          ctx->Shader.CurrentGeometryProgram->Name, errMsg);
         }
      }
#endif
   }

   if (ctx->Shader.CurrentFragmentProgram) {
      frag_from_glsl_shader = true;

      if (!ctx->Shader.CurrentFragmentProgram->LinkStatus) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "%s(shader not linked)", where);
         return GL_FALSE;
      }
#if 0 /* not normally enabled */
      {
         char errMsg[100];
         if (!_mesa_validate_shader_program(ctx,
					    ctx->Shader.CurrentFragmentProgram,
                                            errMsg)) {
            _mesa_warning(ctx, "Shader program %u is invalid: %s",
                          ctx->Shader.CurrentFragmentProgram->Name, errMsg);
         }
      }
#endif
   }

   /* Any shader stages that are not supplied by the GLSL shader and have
    * assembly shaders enabled must now be validated.
    */
   if (!vert_from_glsl_shader
       && ctx->VertexProgram.Enabled && !ctx->VertexProgram._Enabled) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
		  "%s(vertex program not valid)", where);
      return GL_FALSE;
   }

   /* FINISHME: If GL_NV_geometry_program4 is ever supported, the current
    * FINISHME: geometry program should validated here.
    */
   (void) geom_from_glsl_shader;

   if (!frag_from_glsl_shader) {
      if (ctx->FragmentProgram.Enabled && !ctx->FragmentProgram._Enabled) {
	 _mesa_error(ctx, GL_INVALID_OPERATION,
		     "%s(fragment program not valid)", where);
	 return GL_FALSE;
      }

      /* If drawing to integer-valued color buffers, there must be an
       * active fragment shader (GL_EXT_texture_integer).
       */
      if (ctx->DrawBuffer && ctx->DrawBuffer->_IntegerColor) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "%s(integer format but no fragment shader)", where);
         return GL_FALSE;
      }
   }

   if (ctx->DrawBuffer->_Status != GL_FRAMEBUFFER_COMPLETE_EXT) {
      _mesa_error(ctx, GL_INVALID_FRAMEBUFFER_OPERATION_EXT,
                  "%s(incomplete framebuffer)", where);
      return GL_FALSE;
   }

#ifdef DEBUG
   if (ctx->Shader.Flags & GLSL_LOG) {
      struct gl_shader_program *shProg[MESA_SHADER_TYPES];
      gl_shader_type i;

      shProg[MESA_SHADER_VERTEX] = ctx->Shader.CurrentVertexProgram;
      shProg[MESA_SHADER_GEOMETRY] = ctx->Shader.CurrentGeometryProgram;
      shProg[MESA_SHADER_FRAGMENT] = ctx->Shader.CurrentFragmentProgram;

      for (i = 0; i < MESA_SHADER_TYPES; i++) {
	 struct gl_shader *sh;

	 if (shProg[i] == NULL || shProg[i]->_Used
	     || shProg[i]->_LinkedShaders[i] == NULL)
	    continue;

	 /* This is the first time this shader is being used.
	  * Append shader's constants/uniforms to log file.
	  *
	  * The logic is a little odd here.  We only want to log data for each
	  * shader target that will actually be used, and we only want to log
	  * it once.  It's possible to have a program bound to the vertex
	  * shader target that also supplied a fragment shader.  If that
	  * program isn't also bound to the fragment shader target we don't
	  * want to log its fragment data.
	  */
	 sh = shProg[i]->_LinkedShaders[i];
	 switch (sh->Type) {
	 case GL_VERTEX_SHADER:
	    _mesa_append_uniforms_to_file(sh, &shProg[i]->VertexProgram->Base);
	    break;

	 case GL_GEOMETRY_SHADER_ARB:
	    _mesa_append_uniforms_to_file(sh,
					  &shProg[i]->GeometryProgram->Base);
	    break;

	 case GL_FRAGMENT_SHADER:
	    _mesa_append_uniforms_to_file(sh,
					  &shProg[i]->FragmentProgram->Base);
	    break;
	 }
      }

      for (i = 0; i < MESA_SHADER_TYPES; i++) {
	 if (shProg[i] != NULL)
	    shProg[i]->_Used = GL_TRUE;
      }
   }
#endif

   return GL_TRUE;
@


1.1.1.5
log
@Import Mesa 9.2.0
@
text
@d3 1
d21 3
a23 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
d80 1
a83 1
#include "api_loopback.h"
a98 1
#include "formats.h"
d131 1
d133 1
d193 1
a193 2
 * \param accumRedBits, accumGreenBits, accumBlueBits, accumAlphaBits number
 * of bits per color component in accum buffer.
d202 2
a203 2
 * \return pointer to new struct gl_config or NULL if requested parameters
 * can't be met.
d269 1
a269 1
   if (stencilBits < 0 || stencilBits > 8) {
d346 1
d350 3
a352 1
   gl_varying_slot vs = VARYING_SLOT_POS;
d356 1
d360 3
a362 1
   (void) vs;
d405 5
d417 1
a417 1
		     PACKAGE_VERSION, __DATE__, __TIME__);
a419 4

#ifdef DEBUG
      _mesa_test_formats();
#endif
d424 8
a431 3
      _mesa_init_get_hash(ctx);

      _mesa_init_remap_table();
d475 1
a475 2
init_program_limits(struct gl_context *ctx, GLenum type,
                    struct gl_program_constants *prog)
d484 1
a484 1
   prog->MaxAddressOffset = MAX_PROGRAM_LOCAL_PARAMS;
d489 1
a489 1
      prog->MaxAttribs = MAX_VERTEX_GENERIC_ATTRIBS;
a490 1
      prog->MaxUniformComponents = 4 * MAX_UNIFORMS;
a495 1
      prog->MaxUniformComponents = 4 * MAX_UNIFORMS;
d498 2
a499 2
      prog->MaxParameters = MAX_VERTEX_PROGRAM_PARAMS;
      prog->MaxAttribs = MAX_VERTEX_GENERIC_ATTRIBS;
d501 7
a507 1
      prog->MaxUniformComponents = MAX_GEOMETRY_UNIFORM_COMPONENTS;
d532 2
a533 16

   /* Assume ints are stored as floats for now, since this is the least-common
    * denominator.  The OpenGL ES spec implies (page 132) that the precision
    * of integer types should be 0.  Practically speaking, IEEE
    * single-precision floating point values can only store integers in the
    * range [-0x01000000, 0x01000000] without loss of precision.
    */
   prog->MediumInt.RangeMin = 24;
   prog->MediumInt.RangeMax = 24;
   prog->MediumInt.Precision = 0;
   prog->LowInt = prog->HighInt = prog->MediumInt;

   prog->MaxUniformBlocks = 12;
   prog->MaxCombinedUniformComponents = (prog->MaxUniformComponents +
                                         ctx->Const.MaxUniformBlockSize / 4 *
                                         prog->MaxUniformBlocks);
d555 1
a555 1
   ctx->Const.FragmentProgram.MaxTextureImageUnits = MAX_TEXTURE_IMAGE_UNITS;
d557 1
a557 1
                                     ctx->Const.FragmentProgram.MaxTextureImageUnits);
a559 2
   ctx->Const.MaxTextureBufferSize = 65536;
   ctx->Const.TextureBufferOffsetAlignment = 1;
d572 2
a573 1
   ctx->Const.MaxClipPlanes = 6;
d577 11
a587 13
   ctx->Const.MaxViewportWidth = MAX_VIEWPORT_WIDTH;
   ctx->Const.MaxViewportHeight = MAX_VIEWPORT_HEIGHT;

   /** GL_ARB_uniform_buffer_object */
   ctx->Const.MaxCombinedUniformBlocks = 36;
   ctx->Const.MaxUniformBufferBindings = 36;
   ctx->Const.MaxUniformBlockSize = 16384;
   ctx->Const.UniformBufferOffsetAlignment = 1;

   init_program_limits(ctx, GL_VERTEX_PROGRAM_ARB, &ctx->Const.VertexProgram);
   init_program_limits(ctx, GL_FRAGMENT_PROGRAM_ARB, &ctx->Const.FragmentProgram);
   init_program_limits(ctx, MESA_GEOMETRY_PROGRAM, &ctx->Const.GeometryProgram);

d597 1
d599 2
a600 1
   ctx->Const.MaxRenderbufferSize = MAX_RENDERBUFFER_SIZE;
d602 2
a603 1
   ctx->Const.VertexProgram.MaxTextureImageUnits = MAX_TEXTURE_IMAGE_UNITS;
d605 2
a606 4
   ctx->Const.MaxVarying = 16; /* old limit not to break tnl and swrast */
   ctx->Const.GeometryProgram.MaxTextureImageUnits = MAX_TEXTURE_IMAGE_UNITS;
   ctx->Const.MaxGeometryOutputVertices = MAX_GEOMETRY_OUTPUT_VERTICES;
   ctx->Const.MaxGeometryTotalOutputComponents = MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS;
d609 1
a609 1
   if (_mesa_is_desktop_gl(ctx)) {
a610 1
      _mesa_override_glsl_version(ctx);
d623 1
a623 1
   ctx->Const.MaxServerWaitTimeout = 0x1fff7fffffffULL;
d632 1
a632 1
   ctx->Const.MaxTransformFeedbackBuffers = MAX_FEEDBACK_BUFFERS;
a634 1
   ctx->Const.MaxVertexStreams = 1;
d636 2
a637 4
   /* GL 3.2  */
   ctx->Const.ProfileMask = ctx->API == API_OPENGL_CORE
                          ? GL_CONTEXT_CORE_PROFILE_BIT
                          : GL_CONTEXT_COMPATIBILITY_PROFILE_BIT;
a641 14

   /* GL_ARB_robustness */
   ctx->Const.ResetStrategy = GL_NO_RESET_NOTIFICATION_ARB;

   /* PrimitiveRestart */
   ctx->Const.PrimitiveRestartInSoftware = GL_FALSE;

   /* ES 3.0 or ARB_ES3_compatibility */
   ctx->Const.MaxElementIndex = 0xffffffffu;

   /* GL_ARB_texture_multisample */
   ctx->Const.MaxColorTextureSamples = 1;
   ctx->Const.MaxDepthTextureSamples = 1;
   ctx->Const.MaxIntegerSamples = 1;
d653 1
a653 1
   assert(VARYING_SLOT_MAX <=
d655 1
a655 1
   assert(VARYING_SLOT_MAX <=
d658 2
d664 5
d670 2
a671 2
   assert(ctx->Const.FragmentProgram.MaxTextureImageUnits > 0);
   assert(ctx->Const.FragmentProgram.MaxTextureImageUnits <= MAX_TEXTURE_IMAGE_UNITS);
d677 1
a677 1
   assert(ctx->Const.MaxTextureUnits == MIN2(ctx->Const.FragmentProgram.MaxTextureImageUnits,
d683 1
a683 1
   assert(ctx->Const.MaxTextureCoordUnits <= ctx->Const.FragmentProgram.MaxTextureImageUnits);
d692 5
d702 4
a705 4
   assert((1U << (ctx->Const.MaxTextureLevels - 1))
          <= ctx->Const.MaxViewportWidth);
   assert((1U << (ctx->Const.MaxTextureLevels - 1))
          <= ctx->Const.MaxViewportHeight);
a743 1
   _mesa_init_errors( ctx );
d776 2
a777 4
   ctx->NewDriverState = ~0;
   ctx->ErrorValue = GL_NO_ERROR;
   ctx->ResetStatus = GL_NO_ERROR;
   ctx->varying_vp_inputs = VERT_BIT_ALL;
d810 2
a811 2
int
_mesa_generic_nop(void)
d813 1
a813 4
   GET_CURRENT_CONTEXT(ctx);
   _mesa_error(ctx, GL_INVALID_OPERATION,
               "unsupported function called "
               "(unsupported extension or deprecated function?)");
d822 1
a822 1
_mesa_alloc_dispatch_table()
d832 4
a835 1
   table = malloc(numEntries * sizeof(_glapi_proc));
d840 1
a840 1
         entry[i] = (_glapi_proc) _mesa_generic_nop;
a845 84
/**
 * Creates a minimal dispatch table for use within glBegin()/glEnd().
 *
 * This ensures that we generate GL_INVALID_OPERATION errors from most
 * functions, since the set of functions that are valid within Begin/End is
 * very small.
 *
 * From the GL 1.0 specification section 2.6.3, "GL Commands within
 * Begin/End"
 *
 *     "The only GL commands that are allowed within any Begin/End pairs are
 *      the commands for specifying vertex coordinates, vertex color, normal
 *      coordinates, and texture coordinates (Vertex, Color, Index, Normal,
 *      TexCoord), EvalCoord and EvalPoint commands (see section 5.1),
 *      commands for specifying lighting material parameters (Material
 *      commands see section 2.12.2), display list invocation commands
 *      (CallList and CallLists see section 5.4), and the EdgeFlag
 *      command. Executing Begin after Begin has already been executed but
 *      before an End is issued generates the INVALID OPERATION error, as does
 *      executing End without a previous corresponding Begin. Executing any
 *      other GL command within Begin/End results in the error INVALID
 *      OPERATION."
 *
 * The table entries for specifying vertex attributes are set up by
 * install_vtxfmt() and _mesa_loopback_init_api_table(), and End() and dlists
 * are set by install_vtxfmt() as well.
 */
static struct _glapi_table *
create_beginend_table(const struct gl_context *ctx)
{
   struct _glapi_table *table;

   table = _mesa_alloc_dispatch_table();
   if (!table)
      return NULL;

   /* Fill in functions which return a value, since they should return some
    * specific value even if they emit a GL_INVALID_OPERATION error from them
    * being called within glBegin()/glEnd().
    */
#define COPY_DISPATCH(func) SET_##func(table, GET_##func(ctx->Exec))

   COPY_DISPATCH(GenLists);
   COPY_DISPATCH(IsProgram);
   COPY_DISPATCH(IsVertexArray);
   COPY_DISPATCH(IsBuffer);
   COPY_DISPATCH(IsEnabled);
   COPY_DISPATCH(IsEnabledi);
   COPY_DISPATCH(IsRenderbuffer);
   COPY_DISPATCH(IsFramebuffer);
   COPY_DISPATCH(CheckFramebufferStatus);
   COPY_DISPATCH(RenderMode);
   COPY_DISPATCH(GetString);
   COPY_DISPATCH(GetStringi);
   COPY_DISPATCH(GetPointerv);
   COPY_DISPATCH(IsQuery);
   COPY_DISPATCH(IsSampler);
   COPY_DISPATCH(IsSync);
   COPY_DISPATCH(IsTexture);
   COPY_DISPATCH(IsTransformFeedback);
   COPY_DISPATCH(DeleteQueries);
   COPY_DISPATCH(AreTexturesResident);
   COPY_DISPATCH(FenceSync);
   COPY_DISPATCH(ClientWaitSync);
   COPY_DISPATCH(MapBuffer);
   COPY_DISPATCH(UnmapBuffer);
   COPY_DISPATCH(MapBufferRange);
   COPY_DISPATCH(ObjectPurgeableAPPLE);
   COPY_DISPATCH(ObjectUnpurgeableAPPLE);

   _mesa_loopback_init_api_table(ctx, table);

   return table;
}

void
_mesa_initialize_dispatch_tables(struct gl_context *ctx)
{
   /* Do the code-generated setup of the exec table in api_exec.c. */
   _mesa_initialize_exec_table(ctx);

   if (ctx->Save)
      _mesa_initialize_save_table(ctx);
}
d872 1
d875 6
a880 5
_mesa_initialize_context(struct gl_context *ctx,
                         gl_api api,
                         const struct gl_config *visual,
                         struct gl_context *share_list,
                         const struct dd_function_table *driverFunctions)
d885 1
d887 1
a887 1
   assert(driverFunctions->FreeTextureImageBuffer);
a895 4
   if (_mesa_is_desktop_gl(ctx)) {
      _mesa_override_gl_version(ctx);
   }

d905 1
d918 4
a921 1
   _mesa_reference_shared_state(ctx, &ctx->Shared, shared);
d923 27
a949 2
   if (!init_attrib_groups( ctx ))
      goto fail;
d951 6
a956 6
   /* setup the API dispatch tables with all nop functions */
   ctx->OutsideBeginEnd = _mesa_alloc_dispatch_table();
   if (!ctx->OutsideBeginEnd)
      goto fail;
   ctx->Exec = ctx->OutsideBeginEnd;
   ctx->CurrentDispatch = ctx->OutsideBeginEnd;
a967 8
   /* Mesa core handles all the formats that mesa core knows about.
    * Drivers will want to override this list with just the formats
    * they can handle, and confirm that appropriate fallbacks exist in
    * _mesa_choose_tex_format().
    */
   memset(&ctx->TextureFormatSupported, GL_TRUE,
	  sizeof(ctx->TextureFormatSupported));

d969 8
a976 5
   case API_OPENGL_COMPAT:
      ctx->BeginEnd = create_beginend_table(ctx);
      ctx->Save = _mesa_alloc_dispatch_table();
      if (!ctx->BeginEnd || !ctx->Save)
         goto fail;
d978 2
a979 2
      /* fall-through */
   case API_OPENGL_CORE:
d999 1
d1006 2
d1009 16
a1024 6
fail:
   _mesa_reference_shared_state(ctx, &ctx->Shared, NULL);
   free(ctx->BeginEnd);
   free(ctx->Exec);
   free(ctx->Save);
   return GL_FALSE;
d1039 1
d1044 5
a1048 4
_mesa_create_context(gl_api api,
                     const struct gl_config *visual,
                     struct gl_context *share_list,
                     const struct dd_function_table *driverFunctions)
d1053 1
d1055 1
a1055 1
   ctx = calloc(1, sizeof(struct gl_context));
d1059 2
a1060 2
   if (_mesa_initialize_context(ctx, api, visual, share_list,
                                driverFunctions)) {
d1071 16
a1116 3
   _mesa_reference_array_object(ctx, &ctx->Array.ArrayObj, NULL);
   _mesa_reference_array_object(ctx, &ctx->Array.DefaultArrayObj, NULL);

d1131 3
d1137 3
d1141 2
a1144 1
   free(ctx->BeginEnd);
d1149 1
a1149 1
   _mesa_reference_shared_state(ctx, &ctx->Shared, NULL);
d1154 2
a1155 1
   _mesa_free_errors_data(ctx);
d1157 2
a1158 3
   free((void *)ctx->Extensions.String);

   free(ctx->VersionString);
d1184 1
d1198 1
a1198 2
_mesa_copy_context( const struct gl_context *src, struct gl_context *dst,
                    GLuint mask )
a1301 1
   dst->NewDriverState = ~0;
d1303 1
d1358 19
d1436 1
a1436 2
      (curCtx->WinSysDrawBuffer || curCtx->WinSysReadBuffer) &&
       /* make sure this context is valid for flushing */
d1451 4
a1454 2
         ASSERT(_mesa_is_winsys_fbo(drawBuffer));
         ASSERT(_mesa_is_winsys_fbo(readBuffer));
d1462 10
a1471 1
         if (!newCtx->DrawBuffer || _mesa_is_winsys_fbo(newCtx->DrawBuffer)) {
d1473 7
a1479 5
            /* Update the FBO's list of drawbuffers/renderbuffers.
             * For winsys FBOs this comes from the GL state (which may have
             * changed since the last time this FBO was bound).
             */
            _mesa_update_draw_buffers(newCtx);
d1481 1
a1481 1
         if (!newCtx->ReadBuffer || _mesa_is_winsys_fbo(newCtx->ReadBuffer)) {
d1490 30
d1527 1
a1527 1
         assert(newCtx->Version > 0);
d1560 1
a1560 4
      struct gl_shared_state *oldShared = NULL;

      /* save ref to old state to prevent it from being deleted immediately */
      _mesa_reference_shared_state(ctx, &oldShared, ctx->Shared);
d1562 5
a1566 2
      /* update ctx's Shared pointer */
      _mesa_reference_shared_state(ctx, &ctx->Shared, ctxToShare->Shared);
d1570 1
a1570 2
      /* release the old shared state */
      _mesa_reference_shared_state(ctx, &oldShared, NULL);
d1642 5
a1655 1
   FLUSH_VERTICES( ctx, 0 );
a1668 1
   FLUSH_VERTICES( ctx, 0 );
d1687 1
a1687 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d1702 1
a1702 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d1707 4
a1710 7
/*
 * ARB_blend_func_extended - ERRORS section
 * "The error INVALID_OPERATION is generated by Begin or any procedure that
 *  implicitly calls Begin if any draw buffer has a blend function requiring the
 *  second color input (SRC1_COLOR, ONE_MINUS_SRC1_COLOR, SRC1_ALPHA or
 *  ONE_MINUS_SRC1_ALPHA), and a framebuffer is bound that has more than
 *  the value of MAX_DUAL_SOURCE_DRAW_BUFFERS-1 active color attachements."
d1712 3
a1714 2
static GLboolean
_mesa_check_blend_func_error(struct gl_context *ctx)
d1716 1
a1716 11
   GLuint i;
   for (i = ctx->Const.MaxDualSourceDrawBuffers;
	i < ctx->DrawBuffer->_NumColorDrawBuffers;
	i++) {
      if (ctx->Color.Blend[i]._UsesDualSrc) {
	 _mesa_error(ctx, GL_INVALID_OPERATION,
		     "dual source blend on illegal attachment");
	 return GL_FALSE;
      }
   }
   return GL_TRUE;
d1719 2
a1839 4
   if (_mesa_check_blend_func_error(ctx) == GL_FALSE) {
      return GL_FALSE;
   }

d1850 2
d1859 3
a1861 2
	  * Only log data for the program target that matches the shader
	  * target.  It's possible to have a program bound to the vertex
d1866 16
a1881 1
	 _mesa_append_uniforms_to_file(shProg[i]->_LinkedShaders[i]);
@


1.1.1.6
log
@Import Mesa 10.2.3
@
text
@a107 2
#include "performance_monitor.h"
#include "pipelineobj.h"
d365 1
a365 1
mtx_t OneTimeLock = _MTX_INITIALIZER_NP;
d383 1
a383 1
   mtx_lock(&OneTimeLock);
d424 1
a424 1
   mtx_unlock(&OneTimeLock);
d463 1
a463 1
init_program_limits(struct gl_context *ctx, gl_shader_stage stage,
d475 2
a476 2
   switch (stage) {
   case MESA_SHADER_VERTEX:
a480 2
      prog->MaxInputComponents = 0; /* value not used */
      prog->MaxOutputComponents = 16 * 4; /* old limit not to break tnl and swrast */
d482 1
a482 1
   case MESA_SHADER_FRAGMENT:
a486 2
      prog->MaxInputComponents = 16 * 4; /* old limit not to break tnl and swrast */
      prog->MaxOutputComponents = 0; /* value not used */
d488 1
a488 1
   case MESA_SHADER_GEOMETRY:
d492 1
a492 11
      prog->MaxUniformComponents = 4 * MAX_UNIFORMS;
      prog->MaxInputComponents = 16 * 4; /* old limit not to break tnl and swrast */
      prog->MaxOutputComponents = 16 * 4; /* old limit not to break tnl and swrast */
      break;
   case MESA_SHADER_COMPUTE:
      prog->MaxParameters = 0; /* not meaningful for compute shaders */
      prog->MaxAttribs = 0; /* not meaningful for compute shaders */
      prog->MaxAddressRegs = 0; /* not meaningful for compute shaders */
      prog->MaxUniformComponents = 4 * MAX_UNIFORMS;
      prog->MaxInputComponents = 0; /* not meaningful for compute shaders */
      prog->MaxOutputComponents = 0; /* not meaningful for compute shaders */
d495 1
a495 1
      assert(0 && "Bad shader stage in init_program_limits()");
a532 3

   prog->MaxAtomicBuffers = 0;
   prog->MaxAtomicCounters = 0;
a543 1
   int i;
d554 1
a554 1
   ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits = MAX_TEXTURE_IMAGE_UNITS;
d556 1
a556 1
                                     ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits);
a578 7
   ctx->Const.MinMapBufferAlignment = 64;

   /* Driver must override these values if ARB_viewport_array is supported. */
   ctx->Const.MaxViewports = 1;
   ctx->Const.ViewportSubpixelBits = 0;
   ctx->Const.ViewportBounds.Min = 0;
   ctx->Const.ViewportBounds.Max = 0;
d586 3
a588 2
   for (i = 0; i < MESA_SHADER_STAGES; i++)
      init_program_limits(ctx, i, &ctx->Const.Program[i]);
d602 1
a602 1
   ctx->Const.Program[MESA_SHADER_VERTEX].MaxTextureImageUnits = MAX_TEXTURE_IMAGE_UNITS;
d605 1
a605 1
   ctx->Const.Program[MESA_SHADER_GEOMETRY].MaxTextureImageUnits = MAX_TEXTURE_IMAGE_UNITS;
a647 4
   /* GL_ARB_texture_gather */
   ctx->Const.MinProgramTextureGatherOffset = -8;
   ctx->Const.MaxProgramTextureGatherOffset = 7;

a660 23

   /* GL_ARB_shader_atomic_counters */
   ctx->Const.MaxAtomicBufferBindings = MAX_COMBINED_ATOMIC_BUFFERS;
   ctx->Const.MaxAtomicBufferSize = MAX_ATOMIC_COUNTERS * ATOMIC_COUNTER_SIZE;
   ctx->Const.MaxCombinedAtomicBuffers = MAX_COMBINED_ATOMIC_BUFFERS;
   ctx->Const.MaxCombinedAtomicCounters = MAX_ATOMIC_COUNTERS;

   /* GL_ARB_vertex_attrib_binding */
   ctx->Const.MaxVertexAttribRelativeOffset = 2047;
   ctx->Const.MaxVertexAttribBindings = MAX_VERTEX_GENERIC_ATTRIBS;

   /* GL_ARB_compute_shader */
   ctx->Const.MaxComputeWorkGroupCount[0] = 65535;
   ctx->Const.MaxComputeWorkGroupCount[1] = 65535;
   ctx->Const.MaxComputeWorkGroupCount[2] = 65535;
   ctx->Const.MaxComputeWorkGroupSize[0] = 1024;
   ctx->Const.MaxComputeWorkGroupSize[1] = 1024;
   ctx->Const.MaxComputeWorkGroupSize[2] = 64;
   ctx->Const.MaxComputeWorkGroupInvocations = 1024;

   /** GL_ARB_gpu_shader5 */
   ctx->Const.MinFragmentInterpolationOffset = MIN_FRAGMENT_INTERPOLATION_OFFSET;
   ctx->Const.MaxFragmentInterpolationOffset = MAX_FRAGMENT_INTERPOLATION_OFFSET;
d678 2
a679 2
   assert(ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxLocalParams <= MAX_PROGRAM_LOCAL_PARAMS);
   assert(ctx->Const.Program[MESA_SHADER_VERTEX].MaxLocalParams <= MAX_PROGRAM_LOCAL_PARAMS);
d682 2
a683 2
   assert(ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits > 0);
   assert(ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits <= MAX_TEXTURE_IMAGE_UNITS);
d689 1
a689 1
   assert(ctx->Const.MaxTextureUnits == MIN2(ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits,
d695 1
a695 1
   assert(ctx->Const.MaxTextureCoordUnits <= ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits);
a760 2
   _mesa_init_performance_monitors( ctx );
   _mesa_init_pipeline( ctx );
d786 1
a786 1
   ctx->ShareGroupReset = false;
d961 1
a961 2
 * \param visual describes the visual attributes for this context or NULL to
 *               create a configless context
d981 1
a986 9
   if (visual) {
      ctx->Visual = *visual;
      ctx->HasConfig = GL_TRUE;
   }
   else {
      memset(&ctx->Visual, 0, sizeof ctx->Visual);
      ctx->HasConfig = GL_FALSE;
   }

d1080 1
a1080 1
   free(ctx->OutsideBeginEnd);
d1093 1
a1093 2
 * \param visual a struct gl_config pointer (we copy the struct contents) or
 *               NULL to create a configless context
d1108 2
d1156 2
a1157 2
   _mesa_reference_vao(ctx, &ctx->Array.VAO, NULL);
   _mesa_reference_vao(ctx, &ctx->Array.DefaultVAO, NULL);
a1165 1
   _mesa_free_pipeline_data(ctx);
a1171 1
   _mesa_free_performance_monitors(ctx);
d1180 1
a1180 1
   free(ctx->OutsideBeginEnd);
d1325 7
a1331 11
      unsigned i;
      for (i = 0; i < src->Const.MaxViewports; i++) {
         dst->ViewportArray[i].X = src->ViewportArray[i].X;
         dst->ViewportArray[i].Y = src->ViewportArray[i].Y;
         dst->ViewportArray[i].Width = src->ViewportArray[i].Width;
         dst->ViewportArray[i].Height = src->ViewportArray[i].Height;
         dst->ViewportArray[i].Near = src->ViewportArray[i].Near;
         dst->ViewportArray[i].Far = src->ViewportArray[i].Far;
         _math_matrix_copy(&dst->ViewportArray[i]._WindowMap,
                           &src->ViewportArray[i]._WindowMap);
      }
a1399 2
      unsigned i;

d1404 2
a1405 8

      /* Note: ctx->Const.MaxViewports may not have been set by the driver
       * yet, so just initialize all of them.
       */
      for (i = 0; i < MAX_VIEWPORTS; i++) {
         _mesa_set_viewport(ctx, i, 0, 0, width, height);
         _mesa_set_scissor(ctx, i, 0, 0, width, height);
      }
a1408 48
static void
handle_first_current(struct gl_context *ctx)
{
   GLenum buffer;
   GLint bufferIndex;

   assert(ctx->Version > 0);

   ctx->Extensions.String = _mesa_make_extension_string(ctx);

   check_context_limits(ctx);

   /* According to GL_MESA_configless_context the default value of
    * glDrawBuffers depends on the config of the first surface it is bound to.
    * For GLES it is always GL_BACK which has a magic interpretation */
   if (!ctx->HasConfig && _mesa_is_desktop_gl(ctx)) {
      if (ctx->DrawBuffer != _mesa_get_incomplete_framebuffer()) {
         if (ctx->DrawBuffer->Visual.doubleBufferMode)
            buffer = GL_BACK;
         else
            buffer = GL_FRONT;

         _mesa_drawbuffers(ctx, 1, &buffer, NULL /* destMask */);
      }

      if (ctx->ReadBuffer != _mesa_get_incomplete_framebuffer()) {
         if (ctx->ReadBuffer->Visual.doubleBufferMode) {
            buffer = GL_BACK;
            bufferIndex = BUFFER_BACK_LEFT;
         }
         else {
            buffer = GL_FRONT;
            bufferIndex = BUFFER_FRONT_LEFT;
         }

         _mesa_readbuffer(ctx, buffer, bufferIndex);
      }
   }

   /* We can use this to help debug user's problems.  Tell them to set
    * the MESA_INFO env variable before running their app.  Then the
    * first time each context is made current we'll print some useful
    * information.
    */
   if (_mesa_getenv("MESA_INFO")) {
      _mesa_print_info(ctx);
   }
}
d1501 15
a1515 1
         handle_first_current(newCtx);
a1702 26
static bool
shader_linked_or_absent(struct gl_context *ctx,
                        const struct gl_shader_program *shProg,
                        bool *shader_present, const char *where)
{
   if (shProg) {
      *shader_present = true;

      if (!shProg->LinkStatus) {
         _mesa_error(ctx, GL_INVALID_OPERATION, "%s(shader not linked)", where);
         return false;
      }
#if 0 /* not normally enabled */
      {
         char errMsg[100];
         if (!_mesa_validate_shader_program(ctx, shProg, errMsg)) {
            _mesa_warning(ctx, "Shader program %u is invalid: %s",
                          shProg->Name, errMsg);
         }
      }
#endif
   }

   return true;
}

a1706 1
 * It also check the current pipeline object is valid if any.
d1713 3
a1715 2
   bool from_glsl_shader[MESA_SHADER_COMPUTE] = { false };
   unsigned i;
d1721 6
a1726 3
   for (i = 0; i < MESA_SHADER_COMPUTE; i++) {
      if (!shader_linked_or_absent(ctx, ctx->_Shader->CurrentProgram[i],
                                   &from_glsl_shader[i], where))
d1728 54
d1787 1
a1787 1
   if (!from_glsl_shader[MESA_SHADER_VERTEX]
d1797 1
a1797 1
   (void) from_glsl_shader[MESA_SHADER_GEOMETRY];
d1799 1
a1799 1
   if (!from_glsl_shader[MESA_SHADER_FRAGMENT]) {
a1815 9
   /* A pipeline object is bound */
   if (ctx->_Shader->Name && !ctx->_Shader->Validated) {
      /* Error message will be printed inside _mesa_validate_program_pipeline.
       */
      if (!_mesa_validate_program_pipeline(ctx, ctx->_Shader, GL_TRUE)) {
         return GL_FALSE;
      }
   }

d1827 7
a1833 3
   if (ctx->_Shader->Flags & GLSL_LOG) {
      struct gl_shader_program **shProg = ctx->_Shader->CurrentProgram;
      gl_shader_stage i;
d1835 1
a1835 1
      for (i = 0; i < MESA_SHADER_STAGES; i++) {
d1852 1
a1852 1
      for (i = 0; i < MESA_SHADER_STAGES; i++) {
@


1.1.1.7
log
@Import Mesa 10.2.7
@
text
@a1214 3
   _mesa_reference_geomprog(ctx, &ctx->GeometryProgram.Current, NULL);
   _mesa_reference_geomprog(ctx, &ctx->GeometryProgram._Current, NULL);

@


1.1.1.8
log
@Import Mesa 10.4.3
@
text
@a135 1
#include "uniforms.h"
a398 2
      _mesa_one_time_init_extension_overrides();

d465 1
a465 1
init_program_limits(struct gl_constants *consts, gl_shader_stage stage,
d547 1
a547 1
                                         consts->MaxUniformBlockSize / 4 *
d560 2
a561 2
void
_mesa_init_constants(struct gl_constants *consts, gl_api api)
d564 1
a564 1
   assert(consts);
d567 33
a599 33
   consts->MaxTextureMbytes = MAX_TEXTURE_MBYTES;
   consts->MaxTextureLevels = MAX_TEXTURE_LEVELS;
   consts->Max3DTextureLevels = MAX_3D_TEXTURE_LEVELS;
   consts->MaxCubeTextureLevels = MAX_CUBE_TEXTURE_LEVELS;
   consts->MaxTextureRectSize = MAX_TEXTURE_RECT_SIZE;
   consts->MaxArrayTextureLayers = MAX_ARRAY_TEXTURE_LAYERS;
   consts->MaxTextureCoordUnits = MAX_TEXTURE_COORD_UNITS;
   consts->Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits = MAX_TEXTURE_IMAGE_UNITS;
   consts->MaxTextureUnits = MIN2(consts->MaxTextureCoordUnits,
                                     consts->Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits);
   consts->MaxTextureMaxAnisotropy = MAX_TEXTURE_MAX_ANISOTROPY;
   consts->MaxTextureLodBias = MAX_TEXTURE_LOD_BIAS;
   consts->MaxTextureBufferSize = 65536;
   consts->TextureBufferOffsetAlignment = 1;
   consts->MaxArrayLockSize = MAX_ARRAY_LOCK_SIZE;
   consts->SubPixelBits = SUB_PIXEL_BITS;
   consts->MinPointSize = MIN_POINT_SIZE;
   consts->MaxPointSize = MAX_POINT_SIZE;
   consts->MinPointSizeAA = MIN_POINT_SIZE;
   consts->MaxPointSizeAA = MAX_POINT_SIZE;
   consts->PointSizeGranularity = (GLfloat) POINT_SIZE_GRANULARITY;
   consts->MinLineWidth = MIN_LINE_WIDTH;
   consts->MaxLineWidth = MAX_LINE_WIDTH;
   consts->MinLineWidthAA = MIN_LINE_WIDTH;
   consts->MaxLineWidthAA = MAX_LINE_WIDTH;
   consts->LineWidthGranularity = (GLfloat) LINE_WIDTH_GRANULARITY;
   consts->MaxClipPlanes = 6;
   consts->MaxLights = MAX_LIGHTS;
   consts->MaxShininess = 128.0;
   consts->MaxSpotExponent = 128.0;
   consts->MaxViewportWidth = MAX_VIEWPORT_WIDTH;
   consts->MaxViewportHeight = MAX_VIEWPORT_HEIGHT;
   consts->MinMapBufferAlignment = 64;
d602 4
a605 4
   consts->MaxViewports = 1;
   consts->ViewportSubpixelBits = 0;
   consts->ViewportBounds.Min = 0;
   consts->ViewportBounds.Max = 0;
d608 4
a611 8
   consts->MaxCombinedUniformBlocks = 36;
   consts->MaxUniformBufferBindings = 36;
   consts->MaxUniformBlockSize = 16384;
   consts->UniformBufferOffsetAlignment = 1;

   /* GL_ARB_explicit_uniform_location, GL_MAX_UNIFORM_LOCATIONS */
   consts->MaxUserAssignableUniformLocations =
      4 * MESA_SHADER_STAGES * MAX_UNIFORMS;
d614 1
a614 1
      init_program_limits(consts, i, &consts->Program[i]);
d616 2
a617 2
   consts->MaxProgramMatrices = MAX_PROGRAM_MATRICES;
   consts->MaxProgramMatrixStackDepth = MAX_PROGRAM_MATRIX_STACK_DEPTH;
d619 2
a620 5
   /* Assume that if GLSL 1.30+ (or GLSL ES 3.00+) is supported that
    * gl_VertexID is implemented using a native hardware register with OpenGL
    * semantics.
    */
   consts->VertexID_is_zero_based = false;
d623 1
a623 1
   consts->MaxDrawBuffers = MAX_DRAW_BUFFERS;
d625 2
a626 2
   consts->MaxColorAttachments = MAX_COLOR_ATTACHMENTS;
   consts->MaxRenderbufferSize = MAX_RENDERBUFFER_SIZE;
d628 6
a633 6
   consts->Program[MESA_SHADER_VERTEX].MaxTextureImageUnits = MAX_TEXTURE_IMAGE_UNITS;
   consts->MaxCombinedTextureImageUnits = MAX_COMBINED_TEXTURE_IMAGE_UNITS;
   consts->MaxVarying = 16; /* old limit not to break tnl and swrast */
   consts->Program[MESA_SHADER_GEOMETRY].MaxTextureImageUnits = MAX_TEXTURE_IMAGE_UNITS;
   consts->MaxGeometryOutputVertices = MAX_GEOMETRY_OUTPUT_VERTICES;
   consts->MaxGeometryTotalOutputComponents = MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS;
d636 10
a645 8
   consts->GLSLVersion = 120;
   _mesa_override_glsl_version(consts);

#ifdef DEBUG
   consts->GenerateTemporaryNames = true;
#else
   consts->GenerateTemporaryNames = false;
#endif
d648 1
a648 1
   consts->MaxSamples = 0;
d650 2
a651 2
   /* GLSL default if NativeIntegers == FALSE */
   consts->UniformBooleanTrue = FLT_AS_UINT(1.0f);
d653 2
a654 2
   /* GL_ARB_sync */
   consts->MaxServerWaitTimeout = 0x1fff7fffffffULL;
d657 1
a657 1
   consts->QuadsFollowProvokingVertexConvention = GL_TRUE;
d660 4
a663 4
   consts->MaxTransformFeedbackBuffers = MAX_FEEDBACK_BUFFERS;
   consts->MaxTransformFeedbackSeparateComponents = 4 * MAX_FEEDBACK_ATTRIBS;
   consts->MaxTransformFeedbackInterleavedComponents = 4 * MAX_FEEDBACK_ATTRIBS;
   consts->MaxVertexStreams = 1;
d666 1
a666 1
   consts->ProfileMask = api == API_OPENGL_CORE
a669 3
   /* GL 4.4 */
   consts->MaxVertexAttribStride = 2048;

d671 2
a672 2
   consts->MinProgramTexelOffset = -8;
   consts->MaxProgramTexelOffset = 7;
d675 2
a676 2
   consts->MinProgramTextureGatherOffset = -8;
   consts->MaxProgramTextureGatherOffset = 7;
d679 4
a682 1
   consts->ResetStrategy = GL_NO_RESET_NOTIFICATION_ARB;
d685 1
a685 1
   consts->MaxElementIndex = 0xffffffffu;
d688 3
a690 3
   consts->MaxColorTextureSamples = 1;
   consts->MaxDepthTextureSamples = 1;
   consts->MaxIntegerSamples = 1;
d693 4
a696 4
   consts->MaxAtomicBufferBindings = MAX_COMBINED_ATOMIC_BUFFERS;
   consts->MaxAtomicBufferSize = MAX_ATOMIC_COUNTERS * ATOMIC_COUNTER_SIZE;
   consts->MaxCombinedAtomicBuffers = MAX_COMBINED_ATOMIC_BUFFERS;
   consts->MaxCombinedAtomicCounters = MAX_ATOMIC_COUNTERS;
d699 2
a700 2
   consts->MaxVertexAttribRelativeOffset = 2047;
   consts->MaxVertexAttribBindings = MAX_VERTEX_GENERIC_ATTRIBS;
d703 7
a709 7
   consts->MaxComputeWorkGroupCount[0] = 65535;
   consts->MaxComputeWorkGroupCount[1] = 65535;
   consts->MaxComputeWorkGroupCount[2] = 65535;
   consts->MaxComputeWorkGroupSize[0] = 1024;
   consts->MaxComputeWorkGroupSize[1] = 1024;
   consts->MaxComputeWorkGroupSize[2] = 64;
   consts->MaxComputeWorkGroupInvocations = 1024;
d712 2
a713 5
   consts->MinFragmentInterpolationOffset = MIN_FRAGMENT_INTERPOLATION_OFFSET;
   consts->MaxFragmentInterpolationOffset = MAX_FRAGMENT_INTERPOLATION_OFFSET;

   /** GL_KHR_context_flush_control */
   consts->ContextReleaseBehavior = GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH;
a723 2
   (void) ctx;

d790 1
a790 1
   _mesa_init_constants(&ctx->Const, ctx->API);
d793 1
a793 1
   _mesa_init_extensions(&ctx->Extensions);
d887 1
a887 15
 * Special no-op glFlush, see below.
 */
#if defined(_WIN32)
static void GLAPIENTRY
nop_glFlush(void)
{
   /* don't record an error like we do in _mesa_generic_nop() */
}
#endif


/**
 * Allocate and initialize a new dispatch table.  All the dispatch
 * function pointers will point at the _mesa_generic_nop() function
 * which raises GL_INVALID_OPERATION.
d890 1
a890 1
_mesa_alloc_dispatch_table(void)
a906 20

#if defined(_WIN32)
      /* This is a special case for Windows in the event that
       * wglGetProcAddress is called between glBegin/End().
       *
       * The MS opengl32.dll library apparently calls glFlush from
       * wglGetProcAddress().  If we're inside glBegin/End(), glFlush
       * will dispatch to _mesa_generic_nop() and we'll generate a
       * GL_INVALID_OPERATION error.
       *
       * The specific case which hits this is piglit's primitive-restart
       * test which calls glPrimitiveRestartNV() inside glBegin/End.  The
       * first time we call glPrimitiveRestartNV() Piglit's API dispatch
       * code will try to resolve the function by calling wglGetProcAddress.
       * This raises GL_INVALID_OPERATION and an assert(glGetError()==0)
       * will fail causing the test to fail.  By suppressing the error, the
       * assertion passes and the test continues.
       */
      SET_Flush(table, nop_glFlush);
#endif
d1089 1
a1089 1
      = (getenv("MESA_TEX_PROG") != NULL);
d1092 1
a1092 1
      = (getenv("MESA_TNL_PROG") != NULL);
d1495 1
a1495 4
   if (ctx->Version == 0) {
      /* probably in the process of tearing down the context */
      return;
   }
d1533 1
a1533 1
   if (getenv("MESA_INFO")) {
d1580 1
a1580 1
       (curCtx->WinSysDrawBuffer || curCtx->WinSysReadBuffer) &&
d1582 1
a1582 3
       curCtx != newCtx &&
       curCtx->Const.ContextReleaseBehavior ==
       GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH)
a1903 11
         return GL_FALSE;
      }
   }

   /* If a program is active and SSO not in use, check if validation of
    * samplers succeeded for the active program. */
   if (ctx->_Shader->ActiveProgram && ctx->_Shader != ctx->Pipeline.Current) {
      char errMsg[100];
      if (!_mesa_sampler_uniforms_are_valid(ctx->_Shader->ActiveProgram,
                                            errMsg, 100)) {
         _mesa_error(ctx, GL_INVALID_OPERATION, "%s", errMsg);
@


1.1.1.9
log
@Import Mesa 10.2.9
@
text
@d136 1
d400 2
d468 1
a468 1
init_program_limits(struct gl_context *ctx, gl_shader_stage stage,
d550 1
a550 1
                                         ctx->Const.MaxUniformBlockSize / 4 *
d563 2
a564 2
static void 
_mesa_init_constants(struct gl_context *ctx)
d567 1
a567 1
   assert(ctx);
d570 33
a602 33
   ctx->Const.MaxTextureMbytes = MAX_TEXTURE_MBYTES;
   ctx->Const.MaxTextureLevels = MAX_TEXTURE_LEVELS;
   ctx->Const.Max3DTextureLevels = MAX_3D_TEXTURE_LEVELS;
   ctx->Const.MaxCubeTextureLevels = MAX_CUBE_TEXTURE_LEVELS;
   ctx->Const.MaxTextureRectSize = MAX_TEXTURE_RECT_SIZE;
   ctx->Const.MaxArrayTextureLayers = MAX_ARRAY_TEXTURE_LAYERS;
   ctx->Const.MaxTextureCoordUnits = MAX_TEXTURE_COORD_UNITS;
   ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits = MAX_TEXTURE_IMAGE_UNITS;
   ctx->Const.MaxTextureUnits = MIN2(ctx->Const.MaxTextureCoordUnits,
                                     ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits);
   ctx->Const.MaxTextureMaxAnisotropy = MAX_TEXTURE_MAX_ANISOTROPY;
   ctx->Const.MaxTextureLodBias = MAX_TEXTURE_LOD_BIAS;
   ctx->Const.MaxTextureBufferSize = 65536;
   ctx->Const.TextureBufferOffsetAlignment = 1;
   ctx->Const.MaxArrayLockSize = MAX_ARRAY_LOCK_SIZE;
   ctx->Const.SubPixelBits = SUB_PIXEL_BITS;
   ctx->Const.MinPointSize = MIN_POINT_SIZE;
   ctx->Const.MaxPointSize = MAX_POINT_SIZE;
   ctx->Const.MinPointSizeAA = MIN_POINT_SIZE;
   ctx->Const.MaxPointSizeAA = MAX_POINT_SIZE;
   ctx->Const.PointSizeGranularity = (GLfloat) POINT_SIZE_GRANULARITY;
   ctx->Const.MinLineWidth = MIN_LINE_WIDTH;
   ctx->Const.MaxLineWidth = MAX_LINE_WIDTH;
   ctx->Const.MinLineWidthAA = MIN_LINE_WIDTH;
   ctx->Const.MaxLineWidthAA = MAX_LINE_WIDTH;
   ctx->Const.LineWidthGranularity = (GLfloat) LINE_WIDTH_GRANULARITY;
   ctx->Const.MaxClipPlanes = 6;
   ctx->Const.MaxLights = MAX_LIGHTS;
   ctx->Const.MaxShininess = 128.0;
   ctx->Const.MaxSpotExponent = 128.0;
   ctx->Const.MaxViewportWidth = MAX_VIEWPORT_WIDTH;
   ctx->Const.MaxViewportHeight = MAX_VIEWPORT_HEIGHT;
   ctx->Const.MinMapBufferAlignment = 64;
d605 4
a608 4
   ctx->Const.MaxViewports = 1;
   ctx->Const.ViewportSubpixelBits = 0;
   ctx->Const.ViewportBounds.Min = 0;
   ctx->Const.ViewportBounds.Max = 0;
d611 8
a618 4
   ctx->Const.MaxCombinedUniformBlocks = 36;
   ctx->Const.MaxUniformBufferBindings = 36;
   ctx->Const.MaxUniformBlockSize = 16384;
   ctx->Const.UniformBufferOffsetAlignment = 1;
d621 1
a621 1
      init_program_limits(ctx, i, &ctx->Const.Program[i]);
d623 2
a624 2
   ctx->Const.MaxProgramMatrices = MAX_PROGRAM_MATRICES;
   ctx->Const.MaxProgramMatrixStackDepth = MAX_PROGRAM_MATRIX_STACK_DEPTH;
d626 5
a630 2
   /* CheckArrayBounds is overriden by drivers/x11 for X server */
   ctx->Const.CheckArrayBounds = GL_FALSE;
d633 1
a633 1
   ctx->Const.MaxDrawBuffers = MAX_DRAW_BUFFERS;
d635 2
a636 2
   ctx->Const.MaxColorAttachments = MAX_COLOR_ATTACHMENTS;
   ctx->Const.MaxRenderbufferSize = MAX_RENDERBUFFER_SIZE;
d638 6
a643 6
   ctx->Const.Program[MESA_SHADER_VERTEX].MaxTextureImageUnits = MAX_TEXTURE_IMAGE_UNITS;
   ctx->Const.MaxCombinedTextureImageUnits = MAX_COMBINED_TEXTURE_IMAGE_UNITS;
   ctx->Const.MaxVarying = 16; /* old limit not to break tnl and swrast */
   ctx->Const.Program[MESA_SHADER_GEOMETRY].MaxTextureImageUnits = MAX_TEXTURE_IMAGE_UNITS;
   ctx->Const.MaxGeometryOutputVertices = MAX_GEOMETRY_OUTPUT_VERTICES;
   ctx->Const.MaxGeometryTotalOutputComponents = MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS;
d646 8
a653 10
   if (_mesa_is_desktop_gl(ctx)) {
      ctx->Const.GLSLVersion = 120;
      _mesa_override_glsl_version(ctx);
   }
   else if (ctx->API == API_OPENGLES2) {
      ctx->Const.GLSLVersion = 100;
   }
   else if (ctx->API == API_OPENGLES) {
      ctx->Const.GLSLVersion = 0; /* GLSL not supported */
   }
d656 1
a656 1
   ctx->Const.MaxSamples = 0;
d659 1
a659 1
   ctx->Const.UniformBooleanTrue = FLT_AS_UINT(1.0f);
d662 1
a662 4
   ctx->Const.MaxServerWaitTimeout = 0x1fff7fffffffULL;

   /* GL_ATI_envmap_bumpmap */
   ctx->Const.SupportedBumpUnits = SUPPORTED_ATI_BUMP_UNITS;
d665 1
a665 1
   ctx->Const.QuadsFollowProvokingVertexConvention = GL_TRUE;
d668 4
a671 4
   ctx->Const.MaxTransformFeedbackBuffers = MAX_FEEDBACK_BUFFERS;
   ctx->Const.MaxTransformFeedbackSeparateComponents = 4 * MAX_FEEDBACK_ATTRIBS;
   ctx->Const.MaxTransformFeedbackInterleavedComponents = 4 * MAX_FEEDBACK_ATTRIBS;
   ctx->Const.MaxVertexStreams = 1;
d674 1
a674 1
   ctx->Const.ProfileMask = ctx->API == API_OPENGL_CORE
d678 3
d682 2
a683 2
   ctx->Const.MinProgramTexelOffset = -8;
   ctx->Const.MaxProgramTexelOffset = 7;
d686 2
a687 2
   ctx->Const.MinProgramTextureGatherOffset = -8;
   ctx->Const.MaxProgramTextureGatherOffset = 7;
d690 1
a690 4
   ctx->Const.ResetStrategy = GL_NO_RESET_NOTIFICATION_ARB;

   /* PrimitiveRestart */
   ctx->Const.PrimitiveRestartInSoftware = GL_FALSE;
d693 1
a693 1
   ctx->Const.MaxElementIndex = 0xffffffffu;
d696 3
a698 3
   ctx->Const.MaxColorTextureSamples = 1;
   ctx->Const.MaxDepthTextureSamples = 1;
   ctx->Const.MaxIntegerSamples = 1;
d701 4
a704 4
   ctx->Const.MaxAtomicBufferBindings = MAX_COMBINED_ATOMIC_BUFFERS;
   ctx->Const.MaxAtomicBufferSize = MAX_ATOMIC_COUNTERS * ATOMIC_COUNTER_SIZE;
   ctx->Const.MaxCombinedAtomicBuffers = MAX_COMBINED_ATOMIC_BUFFERS;
   ctx->Const.MaxCombinedAtomicCounters = MAX_ATOMIC_COUNTERS;
d707 2
a708 2
   ctx->Const.MaxVertexAttribRelativeOffset = 2047;
   ctx->Const.MaxVertexAttribBindings = MAX_VERTEX_GENERIC_ATTRIBS;
d711 7
a717 7
   ctx->Const.MaxComputeWorkGroupCount[0] = 65535;
   ctx->Const.MaxComputeWorkGroupCount[1] = 65535;
   ctx->Const.MaxComputeWorkGroupCount[2] = 65535;
   ctx->Const.MaxComputeWorkGroupSize[0] = 1024;
   ctx->Const.MaxComputeWorkGroupSize[1] = 1024;
   ctx->Const.MaxComputeWorkGroupSize[2] = 64;
   ctx->Const.MaxComputeWorkGroupInvocations = 1024;
d720 5
a724 2
   ctx->Const.MinFragmentInterpolationOffset = MIN_FRAGMENT_INTERPOLATION_OFFSET;
   ctx->Const.MaxFragmentInterpolationOffset = MAX_FRAGMENT_INTERPOLATION_OFFSET;
d735 2
d803 1
a803 1
   _mesa_init_constants( ctx );
d806 1
a806 1
   _mesa_init_extensions( ctx );
d900 15
a914 1
 * Allocate and initialize a new dispatch table.
d917 1
a917 1
_mesa_alloc_dispatch_table()
d934 20
d1136 1
a1136 1
      = (_mesa_getenv("MESA_TEX_PROG") != NULL);
d1139 1
a1139 1
      = (_mesa_getenv("MESA_TNL_PROG") != NULL);
d1542 4
a1545 1
   assert(ctx->Version > 0);
d1583 1
a1583 1
   if (_mesa_getenv("MESA_INFO")) {
d1630 1
a1630 1
      (curCtx->WinSysDrawBuffer || curCtx->WinSysReadBuffer) &&
d1632 3
a1634 1
      curCtx != newCtx)
d1956 11
@


