head	1.12;
access;
symbols
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	v10_2_9:1.1.1.7
	v10_4_3:1.1.1.6
	v10_2_7:1.1.1.5
	OPENBSD_5_6:1.9.0.2
	OPENBSD_5_6_BASE:1.9
	v10_2_3:1.1.1.5
	OPENBSD_5_5:1.8.0.2
	OPENBSD_5_5_BASE:1.8
	v9_2_5:1.1.1.4
	v9_2_3:1.1.1.4
	v9_2_2:1.1.1.4
	v9_2_1:1.1.1.4
	v9_2_0:1.1.1.4
	OPENBSD_5_4:1.7.0.4
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.6.0.4
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	v7_10_3:1.1.1.3
	OPENBSD_5_0:1.5.0.6
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v7_0_1:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v6_5_2:1.1.1.1
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2015.12.23.05.17.53;	author jsg;	state dead;
branches;
next	1.11;
commitid	TnlogFl9nOv2eaRf;

1.11
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.10;
commitid	4ry2gvZGMXkCUD2n;

1.10
date	2015.01.25.14.41.22;	author jsg;	state Exp;
branches;
next	1.9;
commitid	mcxB0JvoI9gTDYXU;

1.9
date	2014.07.09.21.09.00;	author jsg;	state Exp;
branches;
next	1.8;
commitid	WPD6rgPryPkvXOr9;

1.8
date	2013.09.05.14.06.33;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2012.08.17.13.58.19;	author mpi;	state Exp;
branches;
next	1.6;

1.6
date	2011.10.23.13.37.44;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.05.22.20.06.31;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.05.17.20.26.42;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.14.58.21;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.05.31.16.36.48;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.50.32;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.50.32;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.31.30;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.10.23.13.29.47;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.09.05.13.16.59;	author jsg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2014.07.09.20.35.07;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.6
date	2015.01.25.14.13.04;	author jsg;	state Exp;
branches;
next	1.1.1.7;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.7
date	2015.02.20.22.50.10;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.12
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2008  Brian Paul   All Rights Reserved.
 * Copyright (C) 2009  VMware, Inc.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */


#include "glheader.h"
#include "imports.h"
#include "bufferobj.h"
#include "context.h"
#include "enable.h"
#include "enums.h"
#include "hash.h"
#include "image.h"
#include "macros.h"
#include "mtypes.h"
#include "varray.h"
#include "arrayobj.h"
#include "main/dispatch.h"


/** Used to do error checking for GL_EXT_vertex_array_bgra */
#define BGRA_OR_4  5


/** Used to indicate which GL datatypes are accepted by each of the
 * glVertex/Color/Attrib/EtcPointer() functions.
 */
#define BOOL_BIT             0x1
#define BYTE_BIT             0x2
#define UNSIGNED_BYTE_BIT    0x4
#define SHORT_BIT            0x8
#define UNSIGNED_SHORT_BIT   0x10
#define INT_BIT              0x20
#define UNSIGNED_INT_BIT     0x40
#define HALF_BIT             0x80
#define FLOAT_BIT            0x100
#define DOUBLE_BIT           0x200
#define FIXED_ES_BIT         0x400
#define FIXED_GL_BIT         0x800
#define UNSIGNED_INT_2_10_10_10_REV_BIT 0x1000
#define INT_2_10_10_10_REV_BIT 0x2000
#define UNSIGNED_INT_10F_11F_11F_REV_BIT 0x4000


/** Convert GL datatype enum into a <type>_BIT value seen above */
static GLbitfield
type_to_bit(const struct gl_context *ctx, GLenum type)
{
   switch (type) {
   case GL_BOOL:
      return BOOL_BIT;
   case GL_BYTE:
      return BYTE_BIT;
   case GL_UNSIGNED_BYTE:
      return UNSIGNED_BYTE_BIT;
   case GL_SHORT:
      return SHORT_BIT;
   case GL_UNSIGNED_SHORT:
      return UNSIGNED_SHORT_BIT;
   case GL_INT:
      return INT_BIT;
   case GL_UNSIGNED_INT:
      return UNSIGNED_INT_BIT;
   case GL_HALF_FLOAT:
      if (ctx->Extensions.ARB_half_float_vertex)
         return HALF_BIT;
      else
         return 0x0;
   case GL_FLOAT:
      return FLOAT_BIT;
   case GL_DOUBLE:
      return DOUBLE_BIT;
   case GL_FIXED:
      return _mesa_is_desktop_gl(ctx) ? FIXED_GL_BIT : FIXED_ES_BIT;
   case GL_UNSIGNED_INT_2_10_10_10_REV:
      return UNSIGNED_INT_2_10_10_10_REV_BIT;
   case GL_INT_2_10_10_10_REV:
      return INT_2_10_10_10_REV_BIT;
   case GL_UNSIGNED_INT_10F_11F_11F_REV:
      return UNSIGNED_INT_10F_11F_11F_REV_BIT;
   default:
      return 0;
   }
}


/**
 * Sets the VertexBinding field in the vertex attribute given by attribIndex.
 */
static void
vertex_attrib_binding(struct gl_context *ctx, GLuint attribIndex,
                      GLuint bindingIndex)
{
   struct gl_vertex_array_object *vao = ctx->Array.VAO;
   struct gl_vertex_attrib_array *array = &vao->VertexAttrib[attribIndex];

   if (array->VertexBinding != bindingIndex) {
      const GLbitfield64 array_bit = VERT_BIT(attribIndex);

      FLUSH_VERTICES(ctx, _NEW_ARRAY);

      vao->VertexBinding[array->VertexBinding]._BoundArrays &= ~array_bit;
      vao->VertexBinding[bindingIndex]._BoundArrays |= array_bit;

      array->VertexBinding = bindingIndex;

      vao->NewArrays |= array_bit;
   }
}


/**
 * Binds a buffer object to the vertex buffer binding point given by index,
 * and sets the Offset and Stride fields.
 */
static void
bind_vertex_buffer(struct gl_context *ctx, GLuint index,
                   struct gl_buffer_object *vbo,
                   GLintptr offset, GLsizei stride)
{
   struct gl_vertex_array_object *vao = ctx->Array.VAO;
   struct gl_vertex_buffer_binding *binding = &vao->VertexBinding[index];

   if (binding->BufferObj != vbo ||
       binding->Offset != offset ||
       binding->Stride != stride) {

      FLUSH_VERTICES(ctx, _NEW_ARRAY);

      _mesa_reference_buffer_object(ctx, &binding->BufferObj, vbo);

      binding->Offset = offset;
      binding->Stride = stride;

      vao->NewArrays |= binding->_BoundArrays;
   }
}


/**
 * Sets the InstanceDivisor field in the vertex buffer binding point
 * given by bindingIndex.
 */
static void
vertex_binding_divisor(struct gl_context *ctx, GLuint bindingIndex,
                       GLuint divisor)
{
   struct gl_vertex_array_object *vao = ctx->Array.VAO;
   struct gl_vertex_buffer_binding *binding =
      &vao->VertexBinding[bindingIndex];

   if (binding->InstanceDivisor != divisor) {
      FLUSH_VERTICES(ctx, _NEW_ARRAY);
      binding->InstanceDivisor = divisor;
      vao->NewArrays |= binding->_BoundArrays;
   }
}


/**
 * Does error checking and updates the format in an attrib array.
 *
 * Called by update_array() and VertexAttrib*Format().
 *
 * \param func         Name of calling function used for error reporting
 * \param attrib       The index of the attribute array
 * \param legalTypes   Bitmask of *_BIT above indicating legal datatypes
 * \param sizeMin      Min allowable size value
 * \param sizeMax      Max allowable size value (may also be BGRA_OR_4)
 * \param size         Components per element (1, 2, 3 or 4)
 * \param type         Datatype of each component (GL_FLOAT, GL_INT, etc)
 * \param normalized   Whether integer types are converted to floats in [-1, 1]
 * \param integer      Integer-valued values (will not be normalized to [-1, 1])
 * \param relativeOffset Offset of the first element relative to the binding offset.
 */
static bool
update_array_format(struct gl_context *ctx,
                    const char *func,
                    GLuint attrib, GLbitfield legalTypesMask,
                    GLint sizeMin, GLint sizeMax,
                    GLint size, GLenum type,
                    GLboolean normalized, GLboolean integer,
                    GLuint relativeOffset)
{
   struct gl_vertex_attrib_array *array;
   GLbitfield typeBit;
   GLuint elementSize;
   GLenum format = GL_RGBA;

   if (_mesa_is_gles(ctx)) {
      legalTypesMask &= ~(FIXED_GL_BIT | DOUBLE_BIT | UNSIGNED_INT_10F_11F_11F_REV_BIT);

      /* GL_INT and GL_UNSIGNED_INT data is not allowed in OpenGL ES until
       * 3.0.  The 2_10_10_10 types are added in OpenGL ES 3.0 or
       * GL_OES_vertex_type_10_10_10_2.  GL_HALF_FLOAT data is not allowed
       * until 3.0 or with the GL_OES_vertex_half float extension, which isn't
       * quite as trivial as we'd like because it uses a different enum value
       * for GL_HALF_FLOAT_OES.
       */
      if (ctx->Version < 30) {
         legalTypesMask &= ~(UNSIGNED_INT_BIT
                             | INT_BIT
                             | UNSIGNED_INT_2_10_10_10_REV_BIT
                             | INT_2_10_10_10_REV_BIT
                             | HALF_BIT);
      }

      /* BGRA ordering is not supported in ES contexts.
       */
      if (sizeMax == BGRA_OR_4)
         sizeMax = 4;
   } else {
      legalTypesMask &= ~FIXED_ES_BIT;

      if (!ctx->Extensions.ARB_ES2_compatibility)
         legalTypesMask &= ~FIXED_GL_BIT;

      if (!ctx->Extensions.ARB_vertex_type_2_10_10_10_rev)
         legalTypesMask &= ~(UNSIGNED_INT_2_10_10_10_REV_BIT |
                             INT_2_10_10_10_REV_BIT);

      if (!ctx->Extensions.ARB_vertex_type_10f_11f_11f_rev)
         legalTypesMask &= ~UNSIGNED_INT_10F_11F_11F_REV_BIT;
   }

   typeBit = type_to_bit(ctx, type);
   if (typeBit == 0x0 || (typeBit & legalTypesMask) == 0x0) {
      _mesa_error(ctx, GL_INVALID_ENUM, "%s(type = %s)",
                  func, _mesa_lookup_enum_by_nr(type));
      return false;
   }

   /* Do size parameter checking.
    * If sizeMax = BGRA_OR_4 it means that size = GL_BGRA is legal and
    * must be handled specially.
    */
   if (ctx->Extensions.EXT_vertex_array_bgra &&
       sizeMax == BGRA_OR_4 &&
       size == GL_BGRA) {
      /* Page 298 of the PDF of the OpenGL 4.3 (Core Profile) spec says:
       *
       * "An INVALID_OPERATION error is generated under any of the following
       *  conditions:
       *    ...
       *    • size is BGRA and type is not UNSIGNED_BYTE, INT_2_10_10_10_REV
       *      or UNSIGNED_INT_2_10_10_10_REV;
       *    ...
       *    • size is BGRA and normalized is FALSE;"
       */
      bool bgra_error = false;

      if (ctx->Extensions.ARB_vertex_type_2_10_10_10_rev) {
         if (type != GL_UNSIGNED_INT_2_10_10_10_REV &&
             type != GL_INT_2_10_10_10_REV &&
             type != GL_UNSIGNED_BYTE)
            bgra_error = true;
      } else if (type != GL_UNSIGNED_BYTE)
         bgra_error = true;

      if (bgra_error) {
         _mesa_error(ctx, GL_INVALID_OPERATION, "%s(size=GL_BGRA and type=%s)",
                     func, _mesa_lookup_enum_by_nr(type));
         return false;
      }

      if (!normalized) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "%s(size=GL_BGRA and normalized=GL_FALSE)", func);
         return false;
      }

      format = GL_BGRA;
      size = 4;
   }
   else if (size < sizeMin || size > sizeMax || size > 4) {
      _mesa_error(ctx, GL_INVALID_VALUE, "%s(size=%d)", func, size);
      return false;
   }

   if (ctx->Extensions.ARB_vertex_type_2_10_10_10_rev &&
       (type == GL_UNSIGNED_INT_2_10_10_10_REV ||
        type == GL_INT_2_10_10_10_REV) && size != 4) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "%s(size=%d)", func, size);
      return false;
   }

   /* The ARB_vertex_attrib_binding_spec says:
    *
    *   An INVALID_VALUE error is generated if <relativeoffset> is larger than
    *   the value of MAX_VERTEX_ATTRIB_RELATIVE_OFFSET.
    */
   if (relativeOffset > ctx->Const.MaxVertexAttribRelativeOffset) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "%s(relativeOffset=%d > "
                  "GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET)",
                  func, relativeOffset);
      return false;
   }

   if (ctx->Extensions.ARB_vertex_type_10f_11f_11f_rev &&
         type == GL_UNSIGNED_INT_10F_11F_11F_REV && size != 3) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "%s(size=%d)", func, size);
      return false;
   }

   ASSERT(size <= 4);

   elementSize = _mesa_bytes_per_vertex_attrib(size, type);
   assert(elementSize != -1);

   array = &ctx->Array.VAO->VertexAttrib[attrib];
   array->Size = size;
   array->Type = type;
   array->Format = format;
   array->Normalized = normalized;
   array->Integer = integer;
   array->RelativeOffset = relativeOffset;
   array->_ElementSize = elementSize;

   ctx->Array.VAO->NewArrays |= VERT_BIT(attrib);
   ctx->NewState |= _NEW_ARRAY;

   return true;
}


/**
 * Do error checking and update state for glVertex/Color/TexCoord/...Pointer
 * functions.
 *
 * \param func  name of calling function used for error reporting
 * \param attrib  the attribute array index to update
 * \param legalTypes  bitmask of *_BIT above indicating legal datatypes
 * \param sizeMin  min allowable size value
 * \param sizeMax  max allowable size value (may also be BGRA_OR_4)
 * \param size  components per element (1, 2, 3 or 4)
 * \param type  datatype of each component (GL_FLOAT, GL_INT, etc)
 * \param stride  stride between elements, in elements
 * \param normalized  are integer types converted to floats in [-1, 1]?
 * \param integer  integer-valued values (will not be normalized to [-1,1])
 * \param ptr  the address (or offset inside VBO) of the array data
 */
static void
update_array(struct gl_context *ctx,
             const char *func,
             GLuint attrib, GLbitfield legalTypesMask,
             GLint sizeMin, GLint sizeMax,
             GLint size, GLenum type, GLsizei stride,
             GLboolean normalized, GLboolean integer,
             const GLvoid *ptr)
{
   struct gl_vertex_attrib_array *array;
   GLsizei effectiveStride;

   /* Page 407 (page 423 of the PDF) of the OpenGL 3.0 spec says:
    *
    *     "Client vertex arrays - all vertex array attribute pointers must
    *     refer to buffer objects (section 2.9.2). The default vertex array
    *     object (the name zero) is also deprecated. Calling
    *     VertexAttribPointer when no buffer object or no vertex array object
    *     is bound will generate an INVALID_OPERATION error..."
    *
    * The check for VBOs is handled below.
    */
   if (ctx->API == API_OPENGL_CORE
       && (ctx->Array.VAO == ctx->Array.DefaultVAO)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "%s(no array object bound)",
                  func);
      return;
   }

   if (stride < 0) {
      _mesa_error( ctx, GL_INVALID_VALUE, "%s(stride=%d)", func, stride );
      return;
   }

   /* Page 29 (page 44 of the PDF) of the OpenGL 3.3 spec says:
    *
    *     "An INVALID_OPERATION error is generated under any of the following
    *     conditions:
    *
    *     ...
    *
    *     * any of the *Pointer commands specifying the location and
    *       organization of vertex array data are called while zero is bound
    *       to the ARRAY_BUFFER buffer object binding point (see section
    *       2.9.6), and the pointer argument is not NULL."
    */
   if (ptr != NULL && ctx->Array.VAO->ARBsemantics &&
       !_mesa_is_bufferobj(ctx->Array.ArrayBufferObj)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "%s(non-VBO array)", func);
      return;
   }

   if (!update_array_format(ctx, func, attrib, legalTypesMask, sizeMin,
                            sizeMax, size, type, normalized, integer, 0)) {
      return;
   }

   /* Reset the vertex attrib binding */
   vertex_attrib_binding(ctx, attrib, attrib);

   /* The Stride and Ptr fields are not set by update_array_format() */
   array = &ctx->Array.VAO->VertexAttrib[attrib];
   array->Stride = stride;
   array->Ptr = (const GLvoid *) ptr;

   /* Update the vertex buffer binding */
   effectiveStride = stride != 0 ? stride : array->_ElementSize;
   bind_vertex_buffer(ctx, attrib, ctx->Array.ArrayBufferObj,
                      (GLintptr) ptr, effectiveStride);
}


void GLAPIENTRY
_mesa_VertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *ptr)
{
   GET_CURRENT_CONTEXT(ctx);
   GLbitfield legalTypes = (ctx->API == API_OPENGLES)
      ? (BYTE_BIT | SHORT_BIT | FLOAT_BIT | FIXED_ES_BIT)
      : (SHORT_BIT | INT_BIT | FLOAT_BIT |
         DOUBLE_BIT | HALF_BIT |
         UNSIGNED_INT_2_10_10_10_REV_BIT |
         INT_2_10_10_10_REV_BIT);

   FLUSH_VERTICES(ctx, 0);

   update_array(ctx, "glVertexPointer", VERT_ATTRIB_POS,
                legalTypes, 2, 4,
                size, type, stride, GL_FALSE, GL_FALSE, ptr);
}


void GLAPIENTRY
_mesa_NormalPointer(GLenum type, GLsizei stride, const GLvoid *ptr )
{
   GET_CURRENT_CONTEXT(ctx);
   const GLbitfield legalTypes = (ctx->API == API_OPENGLES)
      ? (BYTE_BIT | SHORT_BIT | FLOAT_BIT | FIXED_ES_BIT)
      : (BYTE_BIT | SHORT_BIT | INT_BIT |
         HALF_BIT | FLOAT_BIT | DOUBLE_BIT |
         UNSIGNED_INT_2_10_10_10_REV_BIT |
         INT_2_10_10_10_REV_BIT);

   FLUSH_VERTICES(ctx, 0);

   update_array(ctx, "glNormalPointer", VERT_ATTRIB_NORMAL,
                legalTypes, 3, 3,
                3, type, stride, GL_TRUE, GL_FALSE, ptr);
}


void GLAPIENTRY
_mesa_ColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *ptr)
{
   GET_CURRENT_CONTEXT(ctx);
   const GLbitfield legalTypes = (ctx->API == API_OPENGLES)
      ? (UNSIGNED_BYTE_BIT | HALF_BIT | FLOAT_BIT | FIXED_ES_BIT)
      : (BYTE_BIT | UNSIGNED_BYTE_BIT |
         SHORT_BIT | UNSIGNED_SHORT_BIT |
         INT_BIT | UNSIGNED_INT_BIT |
         HALF_BIT | FLOAT_BIT | DOUBLE_BIT |
         UNSIGNED_INT_2_10_10_10_REV_BIT |
         INT_2_10_10_10_REV_BIT);
   const GLint sizeMin = (ctx->API == API_OPENGLES) ? 4 : 3;

   FLUSH_VERTICES(ctx, 0);

   update_array(ctx, "glColorPointer", VERT_ATTRIB_COLOR0,
                legalTypes, sizeMin, BGRA_OR_4,
                size, type, stride, GL_TRUE, GL_FALSE, ptr);
}


void GLAPIENTRY
_mesa_FogCoordPointer(GLenum type, GLsizei stride, const GLvoid *ptr)
{
   const GLbitfield legalTypes = (HALF_BIT | FLOAT_BIT | DOUBLE_BIT);
   GET_CURRENT_CONTEXT(ctx);

   FLUSH_VERTICES(ctx, 0);

   update_array(ctx, "glFogCoordPointer", VERT_ATTRIB_FOG,
                legalTypes, 1, 1,
                1, type, stride, GL_FALSE, GL_FALSE, ptr);
}


void GLAPIENTRY
_mesa_IndexPointer(GLenum type, GLsizei stride, const GLvoid *ptr)
{
   const GLbitfield legalTypes = (UNSIGNED_BYTE_BIT | SHORT_BIT | INT_BIT |
                                  FLOAT_BIT | DOUBLE_BIT);
   GET_CURRENT_CONTEXT(ctx);

   FLUSH_VERTICES(ctx, 0);

   update_array(ctx, "glIndexPointer", VERT_ATTRIB_COLOR_INDEX,
                legalTypes, 1, 1,
                1, type, stride, GL_FALSE, GL_FALSE, ptr);
}


void GLAPIENTRY
_mesa_SecondaryColorPointer(GLint size, GLenum type,
			       GLsizei stride, const GLvoid *ptr)
{
   const GLbitfield legalTypes = (BYTE_BIT | UNSIGNED_BYTE_BIT |
                                  SHORT_BIT | UNSIGNED_SHORT_BIT |
                                  INT_BIT | UNSIGNED_INT_BIT |
                                  HALF_BIT | FLOAT_BIT | DOUBLE_BIT |
                                  UNSIGNED_INT_2_10_10_10_REV_BIT |
                                  INT_2_10_10_10_REV_BIT);
   GET_CURRENT_CONTEXT(ctx);

   FLUSH_VERTICES(ctx, 0);

   update_array(ctx, "glSecondaryColorPointer", VERT_ATTRIB_COLOR1,
                legalTypes, 3, BGRA_OR_4,
                size, type, stride, GL_TRUE, GL_FALSE, ptr);
}


void GLAPIENTRY
_mesa_TexCoordPointer(GLint size, GLenum type, GLsizei stride,
                      const GLvoid *ptr)
{
   GET_CURRENT_CONTEXT(ctx);
   GLbitfield legalTypes = (ctx->API == API_OPENGLES)
      ? (BYTE_BIT | SHORT_BIT | FLOAT_BIT | FIXED_ES_BIT)
      : (SHORT_BIT | INT_BIT |
         HALF_BIT | FLOAT_BIT | DOUBLE_BIT |
         UNSIGNED_INT_2_10_10_10_REV_BIT |
         INT_2_10_10_10_REV_BIT);
   const GLint sizeMin = (ctx->API == API_OPENGLES) ? 2 : 1;
   const GLuint unit = ctx->Array.ActiveTexture;

   FLUSH_VERTICES(ctx, 0);

   update_array(ctx, "glTexCoordPointer", VERT_ATTRIB_TEX(unit),
                legalTypes, sizeMin, 4,
                size, type, stride, GL_FALSE, GL_FALSE,
                ptr);
}


void GLAPIENTRY
_mesa_EdgeFlagPointer(GLsizei stride, const GLvoid *ptr)
{
   const GLbitfield legalTypes = UNSIGNED_BYTE_BIT;
   /* this is the same type that glEdgeFlag uses */
   const GLboolean integer = GL_FALSE;
   GET_CURRENT_CONTEXT(ctx);

   FLUSH_VERTICES(ctx, 0);

   update_array(ctx, "glEdgeFlagPointer", VERT_ATTRIB_EDGEFLAG,
                legalTypes, 1, 1,
                1, GL_UNSIGNED_BYTE, stride, GL_FALSE, integer, ptr);
}


void GLAPIENTRY
_mesa_PointSizePointerOES(GLenum type, GLsizei stride, const GLvoid *ptr)
{
   const GLbitfield legalTypes = (FLOAT_BIT | FIXED_ES_BIT);
   GET_CURRENT_CONTEXT(ctx);

   FLUSH_VERTICES(ctx, 0);

   if (ctx->API != API_OPENGLES) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glPointSizePointer(ES 1.x only)");
      return;
   }
      
   update_array(ctx, "glPointSizePointer", VERT_ATTRIB_POINT_SIZE,
                legalTypes, 1, 1,
                1, type, stride, GL_FALSE, GL_FALSE, ptr);
}


/**
 * Set a generic vertex attribute array.
 * Note that these arrays DO NOT alias the conventional GL vertex arrays
 * (position, normal, color, fog, texcoord, etc).
 */
void GLAPIENTRY
_mesa_VertexAttribPointer(GLuint index, GLint size, GLenum type,
                             GLboolean normalized,
                             GLsizei stride, const GLvoid *ptr)
{
   const GLbitfield legalTypes = (BYTE_BIT | UNSIGNED_BYTE_BIT |
                                  SHORT_BIT | UNSIGNED_SHORT_BIT |
                                  INT_BIT | UNSIGNED_INT_BIT |
                                  HALF_BIT | FLOAT_BIT | DOUBLE_BIT |
                                  FIXED_ES_BIT | FIXED_GL_BIT |
                                  UNSIGNED_INT_2_10_10_10_REV_BIT |
                                  INT_2_10_10_10_REV_BIT |
                                  UNSIGNED_INT_10F_11F_11F_REV_BIT);
   GET_CURRENT_CONTEXT(ctx);

   if (index >= ctx->Const.Program[MESA_SHADER_VERTEX].MaxAttribs) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glVertexAttribPointerARB(index)");
      return;
   }

   update_array(ctx, "glVertexAttribPointer", VERT_ATTRIB_GENERIC(index),
                legalTypes, 1, BGRA_OR_4,
                size, type, stride, normalized, GL_FALSE, ptr);
}


/**
 * GL_EXT_gpu_shader4 / GL 3.0.
 * Set an integer-valued vertex attribute array.
 * Note that these arrays DO NOT alias the conventional GL vertex arrays
 * (position, normal, color, fog, texcoord, etc).
 */
void GLAPIENTRY
_mesa_VertexAttribIPointer(GLuint index, GLint size, GLenum type,
                           GLsizei stride, const GLvoid *ptr)
{
   const GLbitfield legalTypes = (BYTE_BIT | UNSIGNED_BYTE_BIT |
                                  SHORT_BIT | UNSIGNED_SHORT_BIT |
                                  INT_BIT | UNSIGNED_INT_BIT);
   const GLboolean normalized = GL_FALSE;
   const GLboolean integer = GL_TRUE;
   GET_CURRENT_CONTEXT(ctx);

   if (index >= ctx->Const.Program[MESA_SHADER_VERTEX].MaxAttribs) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glVertexAttribIPointer(index)");
      return;
   }

   update_array(ctx, "glVertexAttribIPointer", VERT_ATTRIB_GENERIC(index),
                legalTypes, 1, 4,
                size, type, stride, normalized, integer, ptr);
}



void GLAPIENTRY
_mesa_EnableVertexAttribArray(GLuint index)
{
   struct gl_vertex_array_object *vao;
   GET_CURRENT_CONTEXT(ctx);

   if (index >= ctx->Const.Program[MESA_SHADER_VERTEX].MaxAttribs) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glEnableVertexAttribArrayARB(index)");
      return;
   }

   vao = ctx->Array.VAO;

   ASSERT(VERT_ATTRIB_GENERIC(index) < Elements(vao->_VertexAttrib));

   if (!vao->VertexAttrib[VERT_ATTRIB_GENERIC(index)].Enabled) {
      /* was disabled, now being enabled */
      FLUSH_VERTICES(ctx, _NEW_ARRAY);
      vao->VertexAttrib[VERT_ATTRIB_GENERIC(index)].Enabled = GL_TRUE;
      vao->_Enabled |= VERT_BIT_GENERIC(index);
      vao->NewArrays |= VERT_BIT_GENERIC(index);
   }
}


void GLAPIENTRY
_mesa_DisableVertexAttribArray(GLuint index)
{
   struct gl_vertex_array_object *vao;
   GET_CURRENT_CONTEXT(ctx);

   if (index >= ctx->Const.Program[MESA_SHADER_VERTEX].MaxAttribs) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glDisableVertexAttribArrayARB(index)");
      return;
   }

   vao = ctx->Array.VAO;

   ASSERT(VERT_ATTRIB_GENERIC(index) < Elements(vao->_VertexAttrib));

   if (vao->VertexAttrib[VERT_ATTRIB_GENERIC(index)].Enabled) {
      /* was enabled, now being disabled */
      FLUSH_VERTICES(ctx, _NEW_ARRAY);
      vao->VertexAttrib[VERT_ATTRIB_GENERIC(index)].Enabled = GL_FALSE;
      vao->_Enabled &= ~VERT_BIT_GENERIC(index);
      vao->NewArrays |= VERT_BIT_GENERIC(index);
   }
}


/**
 * Return info for a vertex attribute array (no alias with legacy
 * vertex attributes (pos, normal, color, etc)).  This function does
 * not handle the 4-element GL_CURRENT_VERTEX_ATTRIB_ARB query.
 */
static GLuint
get_vertex_array_attrib(struct gl_context *ctx, GLuint index, GLenum pname,
                  const char *caller)
{
   const struct gl_vertex_array_object *vao = ctx->Array.VAO;
   const struct gl_vertex_attrib_array *array;

   if (index >= ctx->Const.Program[MESA_SHADER_VERTEX].MaxAttribs) {
      _mesa_error(ctx, GL_INVALID_VALUE, "%s(index=%u)", caller, index);
      return 0;
   }

   ASSERT(VERT_ATTRIB_GENERIC(index) < Elements(vao->VertexAttrib));

   array = &vao->VertexAttrib[VERT_ATTRIB_GENERIC(index)];

   switch (pname) {
   case GL_VERTEX_ATTRIB_ARRAY_ENABLED_ARB:
      return array->Enabled;
   case GL_VERTEX_ATTRIB_ARRAY_SIZE_ARB:
      return (array->Format == GL_BGRA) ? GL_BGRA : array->Size;
   case GL_VERTEX_ATTRIB_ARRAY_STRIDE_ARB:
      return array->Stride;
   case GL_VERTEX_ATTRIB_ARRAY_TYPE_ARB:
      return array->Type;
   case GL_VERTEX_ATTRIB_ARRAY_NORMALIZED_ARB:
      return array->Normalized;
   case GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING_ARB:
      return vao->VertexBinding[array->VertexBinding].BufferObj->Name;
   case GL_VERTEX_ATTRIB_ARRAY_INTEGER:
      if ((_mesa_is_desktop_gl(ctx)
           && (ctx->Version >= 30 || ctx->Extensions.EXT_gpu_shader4))
          || _mesa_is_gles3(ctx)) {
         return array->Integer;
      }
      goto error;
   case GL_VERTEX_ATTRIB_ARRAY_DIVISOR_ARB:
      if ((_mesa_is_desktop_gl(ctx) && ctx->Extensions.ARB_instanced_arrays)
          || _mesa_is_gles3(ctx)) {
         return vao->VertexBinding[array->VertexBinding].InstanceDivisor;
      }
      goto error;
   case GL_VERTEX_ATTRIB_BINDING:
      if (_mesa_is_desktop_gl(ctx)) {
         return array->VertexBinding - VERT_ATTRIB_GENERIC0;
      }
      goto error;
   case GL_VERTEX_ATTRIB_RELATIVE_OFFSET:
      if (_mesa_is_desktop_gl(ctx)) {
         return array->RelativeOffset;
      }
      goto error;
   default:
      ; /* fall-through */
   }

error:
   _mesa_error(ctx, GL_INVALID_ENUM, "%s(pname=0x%x)", caller, pname);
   return 0;
}


static const GLfloat *
get_current_attrib(struct gl_context *ctx, GLuint index, const char *function)
{
   if (index == 0) {
      if (_mesa_attr_zero_aliases_vertex(ctx)) {
	 _mesa_error(ctx, GL_INVALID_OPERATION, "%s(index==0)", function);
	 return NULL;
      }
   }
   else if (index >= ctx->Const.Program[MESA_SHADER_VERTEX].MaxAttribs) {
      _mesa_error(ctx, GL_INVALID_VALUE,
		  "%s(index>=GL_MAX_VERTEX_ATTRIBS)", function);
      return NULL;
   }

   ASSERT(VERT_ATTRIB_GENERIC(index) < Elements(ctx->Array.VAO->_VertexAttrib));

   FLUSH_CURRENT(ctx, 0);
   return ctx->Current.Attrib[VERT_ATTRIB_GENERIC(index)];
}

void GLAPIENTRY
_mesa_GetVertexAttribfv(GLuint index, GLenum pname, GLfloat *params)
{
   GET_CURRENT_CONTEXT(ctx);

   if (pname == GL_CURRENT_VERTEX_ATTRIB_ARB) {
      const GLfloat *v = get_current_attrib(ctx, index, "glGetVertexAttribfv");
      if (v != NULL) {
         COPY_4V(params, v);
      }
   }
   else {
      params[0] = (GLfloat) get_vertex_array_attrib(ctx, index, pname,
                                                    "glGetVertexAttribfv");
   }
}


void GLAPIENTRY
_mesa_GetVertexAttribdv(GLuint index, GLenum pname, GLdouble *params)
{
   GET_CURRENT_CONTEXT(ctx);

   if (pname == GL_CURRENT_VERTEX_ATTRIB_ARB) {
      const GLfloat *v = get_current_attrib(ctx, index, "glGetVertexAttribdv");
      if (v != NULL) {
         params[0] = (GLdouble) v[0];
         params[1] = (GLdouble) v[1];
         params[2] = (GLdouble) v[2];
         params[3] = (GLdouble) v[3];
      }
   }
   else {
      params[0] = (GLdouble) get_vertex_array_attrib(ctx, index, pname,
                                                     "glGetVertexAttribdv");
   }
}


void GLAPIENTRY
_mesa_GetVertexAttribiv(GLuint index, GLenum pname, GLint *params)
{
   GET_CURRENT_CONTEXT(ctx);

   if (pname == GL_CURRENT_VERTEX_ATTRIB_ARB) {
      const GLfloat *v = get_current_attrib(ctx, index, "glGetVertexAttribiv");
      if (v != NULL) {
         /* XXX should floats in[0,1] be scaled to full int range? */
         params[0] = (GLint) v[0];
         params[1] = (GLint) v[1];
         params[2] = (GLint) v[2];
         params[3] = (GLint) v[3];
      }
   }
   else {
      params[0] = (GLint) get_vertex_array_attrib(ctx, index, pname,
                                                  "glGetVertexAttribiv");
   }
}


/** GL 3.0 */
void GLAPIENTRY
_mesa_GetVertexAttribIiv(GLuint index, GLenum pname, GLint *params)
{
   GET_CURRENT_CONTEXT(ctx);

   if (pname == GL_CURRENT_VERTEX_ATTRIB_ARB) {
      const GLint *v = (const GLint *)
	 get_current_attrib(ctx, index, "glGetVertexAttribIiv");
      if (v != NULL) {
         COPY_4V(params, v);
      }
   }
   else {
      params[0] = (GLint) get_vertex_array_attrib(ctx, index, pname,
                                                  "glGetVertexAttribIiv");
   }
}


/** GL 3.0 */
void GLAPIENTRY
_mesa_GetVertexAttribIuiv(GLuint index, GLenum pname, GLuint *params)
{
   GET_CURRENT_CONTEXT(ctx);

   if (pname == GL_CURRENT_VERTEX_ATTRIB_ARB) {
      const GLuint *v = (const GLuint *)
	 get_current_attrib(ctx, index, "glGetVertexAttribIuiv");
      if (v != NULL) {
         COPY_4V(params, v);
      }
   }
   else {
      params[0] = get_vertex_array_attrib(ctx, index, pname,
                                          "glGetVertexAttribIuiv");
   }
}


void GLAPIENTRY
_mesa_GetVertexAttribPointerv(GLuint index, GLenum pname, GLvoid **pointer)
{
   GET_CURRENT_CONTEXT(ctx);

   if (index >= ctx->Const.Program[MESA_SHADER_VERTEX].MaxAttribs) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glGetVertexAttribPointerARB(index)");
      return;
   }

   if (pname != GL_VERTEX_ATTRIB_ARRAY_POINTER_ARB) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetVertexAttribPointerARB(pname)");
      return;
   }

   ASSERT(VERT_ATTRIB_GENERIC(index) < Elements(ctx->Array.VAO->_VertexAttrib));

   *pointer = (GLvoid *) ctx->Array.VAO->VertexAttrib[VERT_ATTRIB_GENERIC(index)].Ptr;
}


void GLAPIENTRY
_mesa_VertexPointerEXT(GLint size, GLenum type, GLsizei stride,
                       GLsizei count, const GLvoid *ptr)
{
   (void) count;
   _mesa_VertexPointer(size, type, stride, ptr);
}


void GLAPIENTRY
_mesa_NormalPointerEXT(GLenum type, GLsizei stride, GLsizei count,
                       const GLvoid *ptr)
{
   (void) count;
   _mesa_NormalPointer(type, stride, ptr);
}


void GLAPIENTRY
_mesa_ColorPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count,
                      const GLvoid *ptr)
{
   (void) count;
   _mesa_ColorPointer(size, type, stride, ptr);
}


void GLAPIENTRY
_mesa_IndexPointerEXT(GLenum type, GLsizei stride, GLsizei count,
                      const GLvoid *ptr)
{
   (void) count;
   _mesa_IndexPointer(type, stride, ptr);
}


void GLAPIENTRY
_mesa_TexCoordPointerEXT(GLint size, GLenum type, GLsizei stride,
                         GLsizei count, const GLvoid *ptr)
{
   (void) count;
   _mesa_TexCoordPointer(size, type, stride, ptr);
}


void GLAPIENTRY
_mesa_EdgeFlagPointerEXT(GLsizei stride, GLsizei count, const GLboolean *ptr)
{
   (void) count;
   _mesa_EdgeFlagPointer(stride, ptr);
}


void GLAPIENTRY
_mesa_InterleavedArrays(GLenum format, GLsizei stride, const GLvoid *pointer)
{
   GET_CURRENT_CONTEXT(ctx);
   GLboolean tflag, cflag, nflag;  /* enable/disable flags */
   GLint tcomps, ccomps, vcomps;   /* components per texcoord, color, vertex */
   GLenum ctype = 0;               /* color type */
   GLint coffset = 0, noffset = 0, voffset;/* color, normal, vertex offsets */
   const GLint toffset = 0;        /* always zero */
   GLint defstride;                /* default stride */
   GLint c, f;

   FLUSH_VERTICES(ctx, 0);

   f = sizeof(GLfloat);
   c = f * ((4 * sizeof(GLubyte) + (f - 1)) / f);

   if (stride < 0) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glInterleavedArrays(stride)" );
      return;
   }

   switch (format) {
      case GL_V2F:
         tflag = GL_FALSE;  cflag = GL_FALSE;  nflag = GL_FALSE;
         tcomps = 0;  ccomps = 0;  vcomps = 2;
         voffset = 0;
         defstride = 2*f;
         break;
      case GL_V3F:
         tflag = GL_FALSE;  cflag = GL_FALSE;  nflag = GL_FALSE;
         tcomps = 0;  ccomps = 0;  vcomps = 3;
         voffset = 0;
         defstride = 3*f;
         break;
      case GL_C4UB_V2F:
         tflag = GL_FALSE;  cflag = GL_TRUE;  nflag = GL_FALSE;
         tcomps = 0;  ccomps = 4;  vcomps = 2;
         ctype = GL_UNSIGNED_BYTE;
         coffset = 0;
         voffset = c;
         defstride = c + 2*f;
         break;
      case GL_C4UB_V3F:
         tflag = GL_FALSE;  cflag = GL_TRUE;  nflag = GL_FALSE;
         tcomps = 0;  ccomps = 4;  vcomps = 3;
         ctype = GL_UNSIGNED_BYTE;
         coffset = 0;
         voffset = c;
         defstride = c + 3*f;
         break;
      case GL_C3F_V3F:
         tflag = GL_FALSE;  cflag = GL_TRUE;  nflag = GL_FALSE;
         tcomps = 0;  ccomps = 3;  vcomps = 3;
         ctype = GL_FLOAT;
         coffset = 0;
         voffset = 3*f;
         defstride = 6*f;
         break;
      case GL_N3F_V3F:
         tflag = GL_FALSE;  cflag = GL_FALSE;  nflag = GL_TRUE;
         tcomps = 0;  ccomps = 0;  vcomps = 3;
         noffset = 0;
         voffset = 3*f;
         defstride = 6*f;
         break;
      case GL_C4F_N3F_V3F:
         tflag = GL_FALSE;  cflag = GL_TRUE;  nflag = GL_TRUE;
         tcomps = 0;  ccomps = 4;  vcomps = 3;
         ctype = GL_FLOAT;
         coffset = 0;
         noffset = 4*f;
         voffset = 7*f;
         defstride = 10*f;
         break;
      case GL_T2F_V3F:
         tflag = GL_TRUE;  cflag = GL_FALSE;  nflag = GL_FALSE;
         tcomps = 2;  ccomps = 0;  vcomps = 3;
         voffset = 2*f;
         defstride = 5*f;
         break;
      case GL_T4F_V4F:
         tflag = GL_TRUE;  cflag = GL_FALSE;  nflag = GL_FALSE;
         tcomps = 4;  ccomps = 0;  vcomps = 4;
         voffset = 4*f;
         defstride = 8*f;
         break;
      case GL_T2F_C4UB_V3F:
         tflag = GL_TRUE;  cflag = GL_TRUE;  nflag = GL_FALSE;
         tcomps = 2;  ccomps = 4;  vcomps = 3;
         ctype = GL_UNSIGNED_BYTE;
         coffset = 2*f;
         voffset = c+2*f;
         defstride = c+5*f;
         break;
      case GL_T2F_C3F_V3F:
         tflag = GL_TRUE;  cflag = GL_TRUE;  nflag = GL_FALSE;
         tcomps = 2;  ccomps = 3;  vcomps = 3;
         ctype = GL_FLOAT;
         coffset = 2*f;
         voffset = 5*f;
         defstride = 8*f;
         break;
      case GL_T2F_N3F_V3F:
         tflag = GL_TRUE;  cflag = GL_FALSE;  nflag = GL_TRUE;
         tcomps = 2;  ccomps = 0;  vcomps = 3;
         noffset = 2*f;
         voffset = 5*f;
         defstride = 8*f;
         break;
      case GL_T2F_C4F_N3F_V3F:
         tflag = GL_TRUE;  cflag = GL_TRUE;  nflag = GL_TRUE;
         tcomps = 2;  ccomps = 4;  vcomps = 3;
         ctype = GL_FLOAT;
         coffset = 2*f;
         noffset = 6*f;
         voffset = 9*f;
         defstride = 12*f;
         break;
      case GL_T4F_C4F_N3F_V4F:
         tflag = GL_TRUE;  cflag = GL_TRUE;  nflag = GL_TRUE;
         tcomps = 4;  ccomps = 4;  vcomps = 4;
         ctype = GL_FLOAT;
         coffset = 4*f;
         noffset = 8*f;
         voffset = 11*f;
         defstride = 15*f;
         break;
      default:
         _mesa_error( ctx, GL_INVALID_ENUM, "glInterleavedArrays(format)" );
         return;
   }

   if (stride==0) {
      stride = defstride;
   }

   _mesa_DisableClientState( GL_EDGE_FLAG_ARRAY );
   _mesa_DisableClientState( GL_INDEX_ARRAY );
   /* XXX also disable secondary color and generic arrays? */

   /* Texcoords */
   if (tflag) {
      _mesa_EnableClientState( GL_TEXTURE_COORD_ARRAY );
      _mesa_TexCoordPointer( tcomps, GL_FLOAT, stride,
                             (GLubyte *) pointer + toffset );
   }
   else {
      _mesa_DisableClientState( GL_TEXTURE_COORD_ARRAY );
   }

   /* Color */
   if (cflag) {
      _mesa_EnableClientState( GL_COLOR_ARRAY );
      _mesa_ColorPointer( ccomps, ctype, stride,
			  (GLubyte *) pointer + coffset );
   }
   else {
      _mesa_DisableClientState( GL_COLOR_ARRAY );
   }


   /* Normals */
   if (nflag) {
      _mesa_EnableClientState( GL_NORMAL_ARRAY );
      _mesa_NormalPointer( GL_FLOAT, stride, (GLubyte *) pointer + noffset );
   }
   else {
      _mesa_DisableClientState( GL_NORMAL_ARRAY );
   }

   /* Vertices */
   _mesa_EnableClientState( GL_VERTEX_ARRAY );
   _mesa_VertexPointer( vcomps, GL_FLOAT, stride,
			(GLubyte *) pointer + voffset );
}


void GLAPIENTRY
_mesa_LockArraysEXT(GLint first, GLsizei count)
{
   GET_CURRENT_CONTEXT(ctx);

   FLUSH_VERTICES(ctx, 0);

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glLockArrays %d %d\n", first, count);

   if (first < 0) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glLockArraysEXT(first)" );
      return;
   }
   if (count <= 0) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glLockArraysEXT(count)" );
      return;
   }
   if (ctx->Array.LockCount != 0) {
      _mesa_error( ctx, GL_INVALID_OPERATION, "glLockArraysEXT(reentry)" );
      return;
   }

   ctx->Array.LockFirst = first;
   ctx->Array.LockCount = count;

   ctx->NewState |= _NEW_ARRAY;
}


void GLAPIENTRY
_mesa_UnlockArraysEXT( void )
{
   GET_CURRENT_CONTEXT(ctx);

   FLUSH_VERTICES(ctx, 0);

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glUnlockArrays\n");

   if (ctx->Array.LockCount == 0) {
      _mesa_error( ctx, GL_INVALID_OPERATION, "glUnlockArraysEXT(reexit)" );
      return;
   }

   ctx->Array.LockFirst = 0;
   ctx->Array.LockCount = 0;
   ctx->NewState |= _NEW_ARRAY;
}


/* GL_EXT_multi_draw_arrays */
void GLAPIENTRY
_mesa_MultiDrawArrays( GLenum mode, const GLint *first,
                          const GLsizei *count, GLsizei primcount )
{
   GET_CURRENT_CONTEXT(ctx);
   GLint i;

   FLUSH_VERTICES(ctx, 0);

   for (i = 0; i < primcount; i++) {
      if (count[i] > 0) {
         CALL_DrawArrays(ctx->CurrentDispatch, (mode, first[i], count[i]));
      }
   }
}


/* GL_IBM_multimode_draw_arrays */
void GLAPIENTRY
_mesa_MultiModeDrawArraysIBM( const GLenum * mode, const GLint * first,
			      const GLsizei * count,
			      GLsizei primcount, GLint modestride )
{
   GET_CURRENT_CONTEXT(ctx);
   GLint i;

   FLUSH_VERTICES(ctx, 0);

   for ( i = 0 ; i < primcount ; i++ ) {
      if ( count[i] > 0 ) {
         GLenum m = *((GLenum *) ((GLubyte *) mode + i * modestride));
	 CALL_DrawArrays(ctx->CurrentDispatch, ( m, first[i], count[i] ));
      }
   }
}


/* GL_IBM_multimode_draw_arrays */
void GLAPIENTRY
_mesa_MultiModeDrawElementsIBM( const GLenum * mode, const GLsizei * count,
				GLenum type, const GLvoid * const * indices,
				GLsizei primcount, GLint modestride )
{
   GET_CURRENT_CONTEXT(ctx);
   GLint i;

   FLUSH_VERTICES(ctx, 0);

   /* XXX not sure about ARB_vertex_buffer_object handling here */

   for ( i = 0 ; i < primcount ; i++ ) {
      if ( count[i] > 0 ) {
         GLenum m = *((GLenum *) ((GLubyte *) mode + i * modestride));
	 CALL_DrawElements(ctx->CurrentDispatch, ( m, count[i], type,
                                                   indices[i] ));
      }
   }
}


/**
 * GL_NV_primitive_restart and GL 3.1
 */
void GLAPIENTRY
_mesa_PrimitiveRestartIndex(GLuint index)
{
   GET_CURRENT_CONTEXT(ctx);

   if (!ctx->Extensions.NV_primitive_restart && ctx->Version < 31) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glPrimitiveRestartIndexNV()");
      return;
   }

   if (ctx->Array.RestartIndex != index) {
      FLUSH_VERTICES(ctx, _NEW_TRANSFORM);
      ctx->Array.RestartIndex = index;
   }
}


/**
 * See GL_ARB_instanced_arrays.
 * Note that the instance divisor only applies to generic arrays, not
 * the legacy vertex arrays.
 */
void GLAPIENTRY
_mesa_VertexAttribDivisor(GLuint index, GLuint divisor)
{
   GET_CURRENT_CONTEXT(ctx);

   const GLuint genericIndex = VERT_ATTRIB_GENERIC(index);

   if (!ctx->Extensions.ARB_instanced_arrays) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glVertexAttribDivisor()");
      return;
   }

   if (index >= ctx->Const.Program[MESA_SHADER_VERTEX].MaxAttribs) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glVertexAttribDivisor(index = %u)",
                  index);
      return;
   }

   ASSERT(genericIndex < Elements(ctx->Array.VAO->VertexAttrib));

   /* The ARB_vertex_attrib_binding spec says:
    *
    *    "The command
    *
    *       void VertexAttribDivisor(uint index, uint divisor);
    *
    *     is equivalent to (assuming no errors are generated):
    *
    *       VertexAttribBinding(index, index);
    *       VertexBindingDivisor(index, divisor);"
    */
   vertex_attrib_binding(ctx, genericIndex, genericIndex);
   vertex_binding_divisor(ctx, genericIndex, divisor);
}


unsigned
_mesa_primitive_restart_index(const struct gl_context *ctx, GLenum ib_type)
{
   /* From the OpenGL 4.3 core specification, page 302:
    * "If both PRIMITIVE_RESTART and PRIMITIVE_RESTART_FIXED_INDEX are
    *  enabled, the index value determined by PRIMITIVE_RESTART_FIXED_INDEX
    *  is used."
    */
   if (ctx->Array.PrimitiveRestartFixedIndex) {
      switch (ib_type) {
      case GL_UNSIGNED_BYTE:
         return 0xff;
      case GL_UNSIGNED_SHORT:
         return 0xffff;
      case GL_UNSIGNED_INT:
         return 0xffffffff;
      default:
         assert(!"_mesa_primitive_restart_index: Invalid index buffer type.");
      }
   }

   return ctx->Array.RestartIndex;
}


/**
 * GL_ARB_vertex_attrib_binding
 */
void GLAPIENTRY
_mesa_BindVertexBuffer(GLuint bindingIndex, GLuint buffer, GLintptr offset,
                       GLsizei stride)
{
   GET_CURRENT_CONTEXT(ctx);
   const struct gl_vertex_array_object *vao = ctx->Array.VAO;
   struct gl_buffer_object *vbo;

   ASSERT_OUTSIDE_BEGIN_END(ctx);

   /* The ARB_vertex_attrib_binding spec says:
    *
    *    "An INVALID_OPERATION error is generated if no vertex array object
    *     is bound."
    */
   if (ctx->API == API_OPENGL_CORE &&
       ctx->Array.VAO == ctx->Array.DefaultVAO) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glBindVertexBuffer(No array object bound)");
      return;
   }

   /* The ARB_vertex_attrib_binding spec says:
    *
    *    "An INVALID_VALUE error is generated if <bindingindex> is greater than
    *     the value of MAX_VERTEX_ATTRIB_BINDINGS."
    */
   if (bindingIndex >= ctx->Const.MaxVertexAttribBindings) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glBindVertexBuffer(bindingindex=%u > "
                  "GL_MAX_VERTEX_ATTRIB_BINDINGS)",
                  bindingIndex);
      return;
   }

   /* The ARB_vertex_attrib_binding spec says:
    *
    *    "The error INVALID_VALUE is generated if <stride> or <offset>
    *     are negative."
    */
   if (offset < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glBindVertexBuffer(offset=%lld < 0)", (long long)offset);
      return;
   }

   if (stride < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glBindVertexBuffer(stride=%d < 0)", stride);
      return;
   }

   if (buffer == vao->VertexBinding[VERT_ATTRIB_GENERIC(bindingIndex)].BufferObj->Name) {
      vbo = vao->VertexBinding[VERT_ATTRIB_GENERIC(bindingIndex)].BufferObj;
   } else if (buffer != 0) {
      vbo = _mesa_lookup_bufferobj(ctx, buffer);

      /* From the GL_ARB_vertex_attrib_array spec:
       *
       *   "[Core profile only:]
       *    An INVALID_OPERATION error is generated if buffer is not zero or a
       *    name returned from a previous call to GenBuffers, or if such a name
       *    has since been deleted with DeleteBuffers.
       *
       * Otherwise, we fall back to the same compat profile behavior as other
       * object references (automatically gen it).
       */
      if (!_mesa_handle_bind_buffer_gen(ctx, GL_ARRAY_BUFFER, buffer,
                                        &vbo, "glBindVertexBuffer"))
         return;
   } else {
      /* The ARB_vertex_attrib_binding spec says:
       *
       *    "If <buffer> is zero, any buffer object attached to this
       *     bindpoint is detached."
       */
      vbo = ctx->Shared->NullBufferObj;
   }

   bind_vertex_buffer(ctx, VERT_ATTRIB_GENERIC(bindingIndex),
                      vbo, offset, stride);
}


void GLAPIENTRY
_mesa_BindVertexBuffers(GLuint first, GLsizei count, const GLuint *buffers,
                        const GLintptr *offsets, const GLsizei *strides)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_vertex_array_object * const vao = ctx->Array.VAO;
   GLuint i;

   ASSERT_OUTSIDE_BEGIN_END(ctx);

   /* The ARB_vertex_attrib_binding spec says:
    *
    *    "An INVALID_OPERATION error is generated if no
    *     vertex array object is bound."
    */
   if (ctx->API == API_OPENGL_CORE &&
       ctx->Array.VAO == ctx->Array.DefaultVAO) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glBindVertexBuffers(No array object bound)");
      return;
   }

   /* The ARB_multi_bind spec says:
    *
    *    "An INVALID_OPERATION error is generated if <first> + <count>
    *     is greater than the value of MAX_VERTEX_ATTRIB_BINDINGS."
    */
   if (first + count > ctx->Const.MaxVertexAttribBindings) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glBindVertexBuffers(first=%u + count=%d > the value of "
                  "GL_MAX_VERTEX_ATTRIB_BINDINGS=%u)",
                  first, count, ctx->Const.MaxVertexAttribBindings);
      return;
   }

   if (!buffers) {
      /**
       * The ARB_multi_bind spec says:
       *
       *    "If <buffers> is NULL, each affected vertex buffer binding point
       *     from <first> through <first>+<count>-1 will be reset to have no
       *     bound buffer object.  In this case, the offsets and strides
       *     associated with the binding points are set to default values,
       *     ignoring <offsets> and <strides>."
       */
      struct gl_buffer_object *vbo = ctx->Shared->NullBufferObj;

      for (i = 0; i < count; i++)
         bind_vertex_buffer(ctx, VERT_ATTRIB_GENERIC(first + i), vbo, 0, 16);

      return;
   }

   /* Note that the error semantics for multi-bind commands differ from
    * those of other GL commands.
    *
    * The Issues section in the ARB_multi_bind spec says:
    *
    *    "(11) Typically, OpenGL specifies that if an error is generated by
    *          a command, that command has no effect.  This is somewhat
    *          unfortunate for multi-bind commands, because it would require
    *          a first pass to scan the entire list of bound objects for
    *          errors and then a second pass to actually perform the
    *          bindings.  Should we have different error semantics?
    *
    *       RESOLVED:  Yes.  In this specification, when the parameters for
    *       one of the <count> binding points are invalid, that binding
    *       point is not updated and an error will be generated.  However,
    *       other binding points in the same command will be updated if
    *       their parameters are valid and no other error occurs."
    */

   _mesa_begin_bufferobj_lookups(ctx);

   for (i = 0; i < count; i++) {
      struct gl_buffer_object *vbo;

      /* The ARB_multi_bind spec says:
       *
       *    "An INVALID_VALUE error is generated if any value in
       *     <offsets> or <strides> is negative (per binding)."
       */
      if (offsets[i] < 0) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glBindVertexBuffer(offsets[%u]=%lldd < 0)",
                     i, (long long int) offsets[i]);
         continue;
      }

      if (strides[i] < 0) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glBindVertexBuffer(strides[%u]=%lld < 0)",
                     i, (long long int) strides[i]);
         continue;
      }

      if (buffers[i]) {
         struct gl_vertex_buffer_binding *binding =
            &vao->VertexBinding[VERT_ATTRIB_GENERIC(first + i)];

         if (buffers[i] == binding->BufferObj->Name)
            vbo = binding->BufferObj;
         else
            vbo = _mesa_multi_bind_lookup_bufferobj(ctx, buffers, i,
                                                    "glBindVertexBuffers");

         if (!vbo)
            continue;
      } else {
         vbo = ctx->Shared->NullBufferObj;
      }

      bind_vertex_buffer(ctx, VERT_ATTRIB_GENERIC(first + i), vbo,
                         offsets[i], strides[i]);
   }

   _mesa_end_bufferobj_lookups(ctx);
}


void GLAPIENTRY
_mesa_VertexAttribFormat(GLuint attribIndex, GLint size, GLenum type,
                         GLboolean normalized, GLuint relativeOffset)
{
    const GLbitfield legalTypes = (BYTE_BIT | UNSIGNED_BYTE_BIT |
                                   SHORT_BIT | UNSIGNED_SHORT_BIT |
                                   INT_BIT | UNSIGNED_INT_BIT |
                                   HALF_BIT | FLOAT_BIT | DOUBLE_BIT |
                                   FIXED_GL_BIT |
                                   UNSIGNED_INT_2_10_10_10_REV_BIT |
                                   INT_2_10_10_10_REV_BIT |
                                   UNSIGNED_INT_10F_11F_11F_REV_BIT);

   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   /* The ARB_vertex_attrib_binding spec says:
    *
    *    "An INVALID_OPERATION error is generated under any of the following
    *     conditions:
    *     - if no vertex array object is currently bound (see section 2.10);
    *     - ..."
    */
   if (ctx->API == API_OPENGL_CORE &&
       ctx->Array.VAO == ctx->Array.DefaultVAO) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glVertexAttribFormat(No array object bound)");
      return;
   }

   /* The ARB_vertex_attrib_binding spec says:
    *
    *   "The error INVALID_VALUE is generated if index is greater than or equal
    *     to the value of MAX_VERTEX_ATTRIBS."
    */
   if (attribIndex >= ctx->Const.Program[MESA_SHADER_VERTEX].MaxAttribs) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glVertexAttribFormat(attribindex=%u > "
                  "GL_MAX_VERTEX_ATTRIBS)",
                  attribIndex);
      return;
   }

   FLUSH_VERTICES(ctx, 0);

   update_array_format(ctx, "glVertexAttribFormat",
                       VERT_ATTRIB_GENERIC(attribIndex),
                       legalTypes, 1, BGRA_OR_4, size, type, normalized,
                       GL_FALSE, relativeOffset);
}


void GLAPIENTRY
_mesa_VertexAttribIFormat(GLuint attribIndex, GLint size, GLenum type,
                          GLuint relativeOffset)
{
   const GLbitfield legalTypes = (BYTE_BIT | UNSIGNED_BYTE_BIT |
                                  SHORT_BIT | UNSIGNED_SHORT_BIT |
                                  INT_BIT | UNSIGNED_INT_BIT);

   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   /* The ARB_vertex_attrib_binding spec says:
    *
    *    "An INVALID_OPERATION error is generated under any of the following
    *     conditions:
    *     - if no vertex array object is currently bound (see section 2.10);
    *     - ..."
    */
   if (ctx->API == API_OPENGL_CORE &&
       ctx->Array.VAO == ctx->Array.DefaultVAO) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glVertexAttribIFormat(No array object bound)");
      return;
   }

   /* The ARB_vertex_attrib_binding spec says:
    *
    *   "The error INVALID_VALUE is generated if index is greater than
    *    or equal to the value of MAX_VERTEX_ATTRIBS."
    */
   if (attribIndex >= ctx->Const.Program[MESA_SHADER_VERTEX].MaxAttribs) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glVertexAttribIFormat(attribindex=%u > "
                  "GL_MAX_VERTEX_ATTRIBS)",
                  attribIndex);
      return;
   }

   FLUSH_VERTICES(ctx, 0);

   update_array_format(ctx, "glVertexAttribIFormat",
                       VERT_ATTRIB_GENERIC(attribIndex),
                       legalTypes, 1, 4, size, type, GL_FALSE, GL_TRUE,
                       relativeOffset);
}


void GLAPIENTRY
_mesa_VertexAttribLFormat(GLuint attribIndex, GLint size, GLenum type,
                          GLuint relativeOffset)
{
   const GLbitfield legalTypes = DOUBLE_BIT;

   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   /* Page 298 of the PDF of the OpenGL 4.3 (Core Profile) spec says:
    *
    *    "An INVALID_OPERATION error is generated under any of the following
    *     conditions:
    *     • if no vertex array object is currently bound (see section 10.4);
    *     • ..."
    *
    * This language is missing from the extension spec, but we assume
    * that this is an oversight.
    */
   if (ctx->API == API_OPENGL_CORE &&
       ctx->Array.VAO == ctx->Array.DefaultVAO) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glVertexAttribLFormat(No array object bound)");
      return;
   }

   /* The ARB_vertex_attrib_binding spec says:
    *
    *   "The error INVALID_VALUE is generated if <attribindex> is greater than
    *    or equal to the value of MAX_VERTEX_ATTRIBS."
    */
   if (attribIndex >= ctx->Const.Program[MESA_SHADER_VERTEX].MaxAttribs) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glVertexAttribLFormat(attribindex=%u > "
                  "GL_MAX_VERTEX_ATTRIBS)",
                  attribIndex);
      return;
   }

   FLUSH_VERTICES(ctx, 0);

   update_array_format(ctx, "glVertexAttribLFormat",
                       VERT_ATTRIB_GENERIC(attribIndex),
                       legalTypes, 1, 4, size, type, GL_FALSE, GL_FALSE,
                       relativeOffset);
}


void GLAPIENTRY
_mesa_VertexAttribBinding(GLuint attribIndex, GLuint bindingIndex)
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   /* The ARB_vertex_attrib_binding spec says:
    *
    *    "An INVALID_OPERATION error is generated if no vertex array object
    *     is bound."
    */
   if (ctx->API == API_OPENGL_CORE &&
       ctx->Array.VAO == ctx->Array.DefaultVAO) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glVertexAttribBinding(No array object bound)");
      return;
   }

   /* The ARB_vertex_attrib_binding spec says:
    *
    *    "<attribindex> must be less than the value of MAX_VERTEX_ATTRIBS and
    *     <bindingindex> must be less than the value of
    *     MAX_VERTEX_ATTRIB_BINDINGS, otherwise the error INVALID_VALUE
    *     is generated."
    */
   if (attribIndex >= ctx->Const.Program[MESA_SHADER_VERTEX].MaxAttribs) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glVertexAttribBinding(attribindex=%u >= "
                  "GL_MAX_VERTEX_ATTRIBS)",
                  attribIndex);
      return;
   }

   if (bindingIndex >= ctx->Const.MaxVertexAttribBindings) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glVertexAttribBinding(bindingindex=%u >= "
                  "GL_MAX_VERTEX_ATTRIB_BINDINGS)",
                  bindingIndex);
      return;
   }

   ASSERT(VERT_ATTRIB_GENERIC(attribIndex) <
          Elements(ctx->Array.VAO->VertexAttrib));

   vertex_attrib_binding(ctx, VERT_ATTRIB_GENERIC(attribIndex),
                         VERT_ATTRIB_GENERIC(bindingIndex));
}


void GLAPIENTRY
_mesa_VertexBindingDivisor(GLuint bindingIndex, GLuint divisor)
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   if (!ctx->Extensions.ARB_instanced_arrays) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glVertexBindingDivisor()");
      return;
   }

   /* The ARB_vertex_attrib_binding spec says:
    *
    *    "An INVALID_OPERATION error is generated if no vertex array object
    *     is bound."
    */
   if (ctx->API == API_OPENGL_CORE &&
       ctx->Array.VAO == ctx->Array.DefaultVAO) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glVertexBindingDivisor(No array object bound)");
      return;
   }

   /* The ARB_vertex_attrib_binding spec says:
    *
    *    "An INVALID_VALUE error is generated if <bindingindex> is greater
    *     than or equal to the value of MAX_VERTEX_ATTRIB_BINDINGS."
    */
   if (bindingIndex >= ctx->Const.MaxVertexAttribBindings) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glVertexBindingDivisor(bindingindex=%u > "
                  "GL_MAX_VERTEX_ATTRIB_BINDINGS)",
                  bindingIndex);
      return;
   }

   vertex_binding_divisor(ctx, VERT_ATTRIB_GENERIC(bindingIndex), divisor);
}


/**
 * Copy one client vertex array to another.
 */
void
_mesa_copy_client_array(struct gl_context *ctx,
                        struct gl_client_array *dst,
                        struct gl_client_array *src)
{
   dst->Size = src->Size;
   dst->Type = src->Type;
   dst->Format = src->Format;
   dst->Stride = src->Stride;
   dst->StrideB = src->StrideB;
   dst->Ptr = src->Ptr;
   dst->Enabled = src->Enabled;
   dst->Normalized = src->Normalized;
   dst->Integer = src->Integer;
   dst->InstanceDivisor = src->InstanceDivisor;
   dst->_ElementSize = src->_ElementSize;
   _mesa_reference_buffer_object(ctx, &dst->BufferObj, src->BufferObj);
   dst->_MaxElement = src->_MaxElement;
}

void
_mesa_copy_vertex_attrib_array(struct gl_context *ctx,
                               struct gl_vertex_attrib_array *dst,
                               const struct gl_vertex_attrib_array *src)
{
   dst->Size           = src->Size;
   dst->Type           = src->Type;
   dst->Format         = src->Format;
   dst->VertexBinding  = src->VertexBinding;
   dst->RelativeOffset = src->RelativeOffset;
   dst->Format         = src->Format;
   dst->Integer        = src->Integer;
   dst->Normalized     = src->Normalized;
   dst->Ptr            = src->Ptr;
   dst->Enabled        = src->Enabled;
   dst->_ElementSize   = src->_ElementSize;
}

void
_mesa_copy_vertex_buffer_binding(struct gl_context *ctx,
                                 struct gl_vertex_buffer_binding *dst,
                                 const struct gl_vertex_buffer_binding *src)
{
   dst->Offset          = src->Offset;
   dst->Stride          = src->Stride;
   dst->InstanceDivisor = src->InstanceDivisor;
   dst->_BoundArrays    = src->_BoundArrays;

   _mesa_reference_buffer_object(ctx, &dst->BufferObj, src->BufferObj);
}

/**
 * Print vertex array's fields.
 */
static void
print_array(const char *name, GLint index, const struct gl_client_array *array)
{
   if (index >= 0)
      printf("  %s[%d]: ", name, index);
   else
      printf("  %s: ", name);
   printf("Ptr=%p, Type=0x%x, Size=%d, ElemSize=%u, Stride=%d, Buffer=%u(Size %lu), MaxElem=%u\n",
	  array->Ptr, array->Type, array->Size,
	  array->_ElementSize, array->StrideB,
	  array->BufferObj->Name, (unsigned long) array->BufferObj->Size,
	  array->_MaxElement);
}


/**
 * Print current vertex object/array info.  For debug.
 */
void
_mesa_print_arrays(struct gl_context *ctx)
{
   struct gl_vertex_array_object *vao = ctx->Array.VAO;
   GLuint i;

   _mesa_update_vao_max_element(ctx, vao);

   printf("Array Object %u\n", vao->Name);
   if (vao->_VertexAttrib[VERT_ATTRIB_POS].Enabled)
      print_array("Vertex", -1, &vao->_VertexAttrib[VERT_ATTRIB_POS]);
   if (vao->_VertexAttrib[VERT_ATTRIB_NORMAL].Enabled)
      print_array("Normal", -1, &vao->_VertexAttrib[VERT_ATTRIB_NORMAL]);
   if (vao->_VertexAttrib[VERT_ATTRIB_COLOR0].Enabled)
      print_array("Color", -1, &vao->_VertexAttrib[VERT_ATTRIB_COLOR0]);
   for (i = 0; i < ctx->Const.MaxTextureCoordUnits; i++)
      if (vao->_VertexAttrib[VERT_ATTRIB_TEX(i)].Enabled)
         print_array("TexCoord", i, &vao->_VertexAttrib[VERT_ATTRIB_TEX(i)]);
   for (i = 0; i < VERT_ATTRIB_GENERIC_MAX; i++)
      if (vao->_VertexAttrib[VERT_ATTRIB_GENERIC(i)].Enabled)
         print_array("Attrib", i, &vao->_VertexAttrib[VERT_ATTRIB_GENERIC(i)]);
   printf("  _MaxElement = %u\n", vao->_MaxElement);
}


/**
 * Initialize vertex array state for given context.
 */
void 
_mesa_init_varray(struct gl_context *ctx)
{
   ctx->Array.DefaultVAO = ctx->Driver.NewArrayObject(ctx, 0);
   _mesa_reference_vao(ctx, &ctx->Array.VAO, ctx->Array.DefaultVAO);
   ctx->Array.ActiveTexture = 0;   /* GL_ARB_multitexture */

   ctx->Array.Objects = _mesa_NewHashTable();
}


/**
 * Callback for deleting an array object.  Called by _mesa_HashDeleteAll().
 */
static void
delete_arrayobj_cb(GLuint id, void *data, void *userData)
{
   struct gl_vertex_array_object *vao = (struct gl_vertex_array_object *) data;
   struct gl_context *ctx = (struct gl_context *) userData;
   _mesa_delete_vao(ctx, vao);
}


/**
 * Free vertex array state for given context.
 */
void 
_mesa_free_varray_data(struct gl_context *ctx)
{
   _mesa_HashDeleteAll(ctx->Array.Objects, delete_arrayobj_cb, ctx);
   _mesa_DeleteHashTable(ctx->Array.Objects);
}
@


1.11
log
@Merge Mesa 10.2.9
@
text
@@


1.10
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a26 2
#include <inttypes.h>  /* for PRId64 macro */

d49 15
a63 16
#define BOOL_BIT                          (1 << 0)
#define BYTE_BIT                          (1 << 1)
#define UNSIGNED_BYTE_BIT                 (1 << 2)
#define SHORT_BIT                         (1 << 3)
#define UNSIGNED_SHORT_BIT                (1 << 4)
#define INT_BIT                           (1 << 5)
#define UNSIGNED_INT_BIT                  (1 << 6)
#define HALF_BIT                          (1 << 7)
#define FLOAT_BIT                         (1 << 8)
#define DOUBLE_BIT                        (1 << 9)
#define FIXED_ES_BIT                      (1 << 10)
#define FIXED_GL_BIT                      (1 << 11)
#define UNSIGNED_INT_2_10_10_10_REV_BIT   (1 << 12)
#define INT_2_10_10_10_REV_BIT            (1 << 13)
#define UNSIGNED_INT_10F_11F_11F_REV_BIT  (1 << 14)
#define ALL_TYPE_BITS                    ((1 << 15) - 1)
a181 47
 * Examine the API profile and extensions to determine which types are legal
 * for vertex arrays.  This is called once from update_array_format().
 */
static GLbitfield
get_legal_types_mask(const struct gl_context *ctx)
{
   GLbitfield legalTypesMask = ALL_TYPE_BITS;

   if (_mesa_is_gles(ctx)) {
      legalTypesMask &= ~(FIXED_GL_BIT |
                          DOUBLE_BIT |
                          UNSIGNED_INT_10F_11F_11F_REV_BIT);

      /* GL_INT and GL_UNSIGNED_INT data is not allowed in OpenGL ES until
       * 3.0.  The 2_10_10_10 types are added in OpenGL ES 3.0 or
       * GL_OES_vertex_type_10_10_10_2.  GL_HALF_FLOAT data is not allowed
       * until 3.0 or with the GL_OES_vertex_half float extension, which isn't
       * quite as trivial as we'd like because it uses a different enum value
       * for GL_HALF_FLOAT_OES.
       */
      if (ctx->Version < 30) {
         legalTypesMask &= ~(UNSIGNED_INT_BIT |
                             INT_BIT |
                             UNSIGNED_INT_2_10_10_10_REV_BIT |
                             INT_2_10_10_10_REV_BIT |
                             HALF_BIT);
      }
   }
   else {
      legalTypesMask &= ~FIXED_ES_BIT;

      if (!ctx->Extensions.ARB_ES2_compatibility)
         legalTypesMask &= ~FIXED_GL_BIT;

      if (!ctx->Extensions.ARB_vertex_type_2_10_10_10_rev)
         legalTypesMask &= ~(UNSIGNED_INT_2_10_10_10_REV_BIT |
                             INT_2_10_10_10_REV_BIT);

      if (!ctx->Extensions.ARB_vertex_type_10f_11f_11f_rev)
         legalTypesMask &= ~UNSIGNED_INT_10F_11F_11F_REV_BIT;
   }

   return legalTypesMask;
}


/**
d211 9
a219 3
   if (ctx->Array.LegalTypesMask == 0) {
      /* One-time initialization.  We can't do this in _mesa_init_varrays()
       * below because extensions are not yet enabled at that point.
d221 7
a227 4
      ctx->Array.LegalTypesMask = get_legal_types_mask(ctx);
   }

   legalTypesMask &= ctx->Array.LegalTypesMask;
a228 1
   if (_mesa_is_gles(ctx) && sizeMax == BGRA_OR_4) {
d231 14
a244 1
      sizeMax = 4;
a397 7
   if (ctx->API == API_OPENGL_CORE && ctx->Version >= 44 &&
       stride > ctx->Const.MaxVertexAttribStride) {
      _mesa_error(ctx, GL_INVALID_VALUE, "%s(stride=%d > "
                  "GL_MAX_VERTEX_ATTRIB_STRIDE)", func, stride);
      return;
   }

d678 1
a678 1
   ASSERT(VERT_ATTRIB_GENERIC(index) < Elements(vao->VertexAttrib));
d704 1
a704 1
   ASSERT(VERT_ATTRIB_GENERIC(index) < Elements(vao->VertexAttrib));
d798 1
a798 1
   ASSERT(VERT_ATTRIB_GENERIC(index) < Elements(ctx->Array.VAO->VertexAttrib));
d920 1
a920 1
   ASSERT(VERT_ATTRIB_GENERIC(index) < Elements(ctx->Array.VAO->VertexAttrib));
d1400 1
a1400 2
                  "glBindVertexBuffer(offset=%" PRId64 " < 0)",
                  (int64_t) offset);
a1409 7
   if (ctx->API == API_OPENGL_CORE && ctx->Version >= 44 &&
       stride > ctx->Const.MaxVertexAttribStride) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glBindVertexBuffer(stride=%d > "
                  "GL_MAX_VERTEX_ATTRIB_STRIDE)", stride);
      return;
   }

d1526 2
a1527 2
                     "glBindVertexBuffers(offsets[%u]=%" PRId64 " < 0)",
                     i, (int64_t) offsets[i]);
d1533 2
a1534 10
                     "glBindVertexBuffers(strides[%u]=%d < 0)",
                     i, strides[i]);
         continue;
      }

      if (ctx->API == API_OPENGL_CORE && ctx->Version >= 44 &&
          strides[i] > ctx->Const.MaxVertexAttribStride) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glBindVertexBuffers(strides[%u]=%d > "
                     "GL_MAX_VERTEX_ATTRIB_STRIDE)", i, strides[i]);
d1818 1
d1859 1
a1859 1
      fprintf(stderr, "  %s[%d]: ", name, index);
d1861 2
a1862 2
      fprintf(stderr, "  %s: ", name);
   fprintf(stderr, "Ptr=%p, Type=0x%x, Size=%d, ElemSize=%u, Stride=%d, Buffer=%u(Size %lu)\n",
d1865 2
a1866 1
	  array->BufferObj->Name, (unsigned long) array->BufferObj->Size);
d1879 2
d1894 1
@


1.9
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d27 2
d51 16
a66 15
#define BOOL_BIT             0x1
#define BYTE_BIT             0x2
#define UNSIGNED_BYTE_BIT    0x4
#define SHORT_BIT            0x8
#define UNSIGNED_SHORT_BIT   0x10
#define INT_BIT              0x20
#define UNSIGNED_INT_BIT     0x40
#define HALF_BIT             0x80
#define FLOAT_BIT            0x100
#define DOUBLE_BIT           0x200
#define FIXED_ES_BIT         0x400
#define FIXED_GL_BIT         0x800
#define UNSIGNED_INT_2_10_10_10_REV_BIT 0x1000
#define INT_2_10_10_10_REV_BIT 0x2000
#define UNSIGNED_INT_10F_11F_11F_REV_BIT 0x4000
d185 47
d261 6
a266 2
   if (_mesa_is_gles(ctx)) {
      legalTypesMask &= ~(FIXED_GL_BIT | DOUBLE_BIT | UNSIGNED_INT_10F_11F_11F_REV_BIT);
d268 1
a268 14
      /* GL_INT and GL_UNSIGNED_INT data is not allowed in OpenGL ES until
       * 3.0.  The 2_10_10_10 types are added in OpenGL ES 3.0 or
       * GL_OES_vertex_type_10_10_10_2.  GL_HALF_FLOAT data is not allowed
       * until 3.0 or with the GL_OES_vertex_half float extension, which isn't
       * quite as trivial as we'd like because it uses a different enum value
       * for GL_HALF_FLOAT_OES.
       */
      if (ctx->Version < 30) {
         legalTypesMask &= ~(UNSIGNED_INT_BIT
                             | INT_BIT
                             | UNSIGNED_INT_2_10_10_10_REV_BIT
                             | INT_2_10_10_10_REV_BIT
                             | HALF_BIT);
      }
d270 1
d273 1
a273 14
      if (sizeMax == BGRA_OR_4)
         sizeMax = 4;
   } else {
      legalTypesMask &= ~FIXED_ES_BIT;

      if (!ctx->Extensions.ARB_ES2_compatibility)
         legalTypesMask &= ~FIXED_GL_BIT;

      if (!ctx->Extensions.ARB_vertex_type_2_10_10_10_rev)
         legalTypesMask &= ~(UNSIGNED_INT_2_10_10_10_REV_BIT |
                             INT_2_10_10_10_REV_BIT);

      if (!ctx->Extensions.ARB_vertex_type_10f_11f_11f_rev)
         legalTypesMask &= ~UNSIGNED_INT_10F_11F_11F_REV_BIT;
d427 7
d714 1
a714 1
   ASSERT(VERT_ATTRIB_GENERIC(index) < Elements(vao->_VertexAttrib));
d740 1
a740 1
   ASSERT(VERT_ATTRIB_GENERIC(index) < Elements(vao->_VertexAttrib));
d834 1
a834 1
   ASSERT(VERT_ATTRIB_GENERIC(index) < Elements(ctx->Array.VAO->_VertexAttrib));
d956 1
a956 1
   ASSERT(VERT_ATTRIB_GENERIC(index) < Elements(ctx->Array.VAO->_VertexAttrib));
d1436 2
a1437 1
                  "glBindVertexBuffer(offset=%lld < 0)", (long long)offset);
d1447 7
d1570 2
a1571 2
                     "glBindVertexBuffer(offsets[%u]=%lldd < 0)",
                     i, (long long int) offsets[i]);
d1577 10
a1586 2
                     "glBindVertexBuffer(strides[%u]=%lld < 0)",
                     i, (long long int) strides[i]);
a1869 1
   dst->_MaxElement = src->_MaxElement;
d1910 1
a1910 1
      printf("  %s[%d]: ", name, index);
d1912 2
a1913 2
      printf("  %s: ", name);
   printf("Ptr=%p, Type=0x%x, Size=%d, ElemSize=%u, Stride=%d, Buffer=%u(Size %lu), MaxElem=%u\n",
d1916 1
a1916 2
	  array->BufferObj->Name, (unsigned long) array->BufferObj->Size,
	  array->_MaxElement);
a1928 2
   _mesa_update_vao_max_element(ctx, vao);

a1941 1
   printf("  _MaxElement = %u\n", vao->_MaxElement);
@


1.8
log
@Merge Mesa 9.2.0
@
text
@d63 1
d100 2
d109 76
a184 2
 * Do error checking and update state for glVertex/Color/TexCoord/...Pointer
 * functions.
d186 10
a195 11
 * \param func  name of calling function used for error reporting
 * \param attrib  the attribute array index to update
 * \param legalTypes  bitmask of *_BIT above indicating legal datatypes
 * \param sizeMin  min allowable size value
 * \param sizeMax  max allowable size value (may also be BGRA_OR_4)
 * \param size  components per element (1, 2, 3 or 4)
 * \param type  datatype of each component (GL_FLOAT, GL_INT, etc)
 * \param stride  stride between elements, in elements
 * \param normalized  are integer types converted to floats in [-1, 1]?
 * \param integer  integer-valued values (will not be normalized to [-1,1])
 * \param ptr  the address (or offset inside VBO) of the array data
d197 8
a204 8
static void
update_array(struct gl_context *ctx,
             const char *func,
             GLuint attrib, GLbitfield legalTypesMask,
             GLint sizeMin, GLint sizeMax,
             GLint size, GLenum type, GLsizei stride,
             GLboolean normalized, GLboolean integer,
             const GLvoid *ptr)
d206 1
a206 1
   struct gl_client_array *array;
d208 1
a208 1
   GLsizei elementSize;
a210 17
   /* Page 407 (page 423 of the PDF) of the OpenGL 3.0 spec says:
    *
    *     "Client vertex arrays - all vertex array attribute pointers must
    *     refer to buffer objects (section 2.9.2). The default vertex array
    *     object (the name zero) is also deprecated. Calling
    *     VertexAttribPointer when no buffer object or no vertex array object
    *     is bound will generate an INVALID_OPERATION error..."
    *
    * The check for VBOs is handled below.
    */
   if (ctx->API == API_OPENGL_CORE
       && (ctx->Array.ArrayObj == ctx->Array.DefaultArrayObj)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "%s(no array object bound)",
                  func);
      return;
   }

d212 1
a212 1
      legalTypesMask &= ~(FIXED_GL_BIT | DOUBLE_BIT);
d242 3
d251 1
a251 1
      return;
d261 11
a271 1
      GLboolean bgra_error = GL_FALSE;
d277 1
a277 1
            bgra_error = GL_TRUE;
d279 1
a279 1
         bgra_error = GL_TRUE;
d282 9
a290 2
         _mesa_error(ctx, GL_INVALID_VALUE, "%s(GL_BGRA/GLubyte)", func);
         return;
d292 1
d298 1
a298 1
      return;
d305 20
a324 1
      return;
d329 64
d410 1
a410 1
   if (ptr != NULL && ctx->Array.ArrayObj->ARBsemantics &&
d416 7
a422 2
   elementSize = _mesa_bytes_per_vertex_attrib(size, type);
   assert(elementSize != -1);
d424 2
a425 4
   array = &ctx->Array.ArrayObj->VertexAttrib[attrib];
   array->Size = size;
   array->Type = type;
   array->Format = format;
d427 1
a427 8
   array->StrideB = stride ? stride : elementSize;
   array->Normalized = normalized;
   array->Integer = integer;
   array->Ptr = (const GLubyte *) ptr;
   array->_ElementSize = elementSize;

   _mesa_reference_buffer_object(ctx, &array->BufferObj,
                                 ctx->Array.ArrayBufferObj);
d429 4
a432 1
   ctx->NewState |= _NEW_ARRAY;
d572 2
a573 2
   /* see table 2.4 edits in GL_EXT_gpu_shader4 spec: */
   const GLboolean integer = GL_TRUE;
d620 2
a621 1
                                  INT_2_10_10_10_REV_BIT);
d624 1
a624 1
   if (index >= ctx->Const.VertexProgram.MaxAttribs) {
d652 1
a652 1
   if (index >= ctx->Const.VertexProgram.MaxAttribs) {
d667 1
a667 1
   struct gl_array_object *arrayObj;
d670 1
a670 1
   if (index >= ctx->Const.VertexProgram.MaxAttribs) {
d676 1
a676 1
   arrayObj = ctx->Array.ArrayObj;
d678 1
a678 1
   ASSERT(VERT_ATTRIB_GENERIC(index) < Elements(arrayObj->VertexAttrib));
d680 1
a680 1
   if (!arrayObj->VertexAttrib[VERT_ATTRIB_GENERIC(index)].Enabled) {
d683 3
a685 2
      arrayObj->VertexAttrib[VERT_ATTRIB_GENERIC(index)].Enabled = GL_TRUE;
      arrayObj->_Enabled |= VERT_BIT_GENERIC(index);
d693 1
a693 1
   struct gl_array_object *arrayObj;
d696 1
a696 1
   if (index >= ctx->Const.VertexProgram.MaxAttribs) {
d702 1
a702 1
   arrayObj = ctx->Array.ArrayObj;
d704 1
a704 1
   ASSERT(VERT_ATTRIB_GENERIC(index) < Elements(arrayObj->VertexAttrib));
d706 1
a706 1
   if (arrayObj->VertexAttrib[VERT_ATTRIB_GENERIC(index)].Enabled) {
d709 3
a711 2
      arrayObj->VertexAttrib[VERT_ATTRIB_GENERIC(index)].Enabled = GL_FALSE;
      arrayObj->_Enabled &= ~VERT_BIT_GENERIC(index);
d725 2
a726 1
   const struct gl_client_array *array;
d728 1
a728 1
   if (index >= ctx->Const.VertexProgram.MaxAttribs) {
d733 1
a733 1
   ASSERT(VERT_ATTRIB_GENERIC(index) < Elements(ctx->Array.ArrayObj->VertexAttrib));
d735 1
a735 1
   array = &ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_GENERIC(index)];
d741 1
a741 1
      return array->Size;
d749 1
a749 1
      return array->BufferObj->Name;
d760 11
a770 1
         return array->InstanceDivisor;
d787 1
a787 7
      /* In OpenGL 3.1 attribute 0 becomes non-magic, just like in OpenGL ES
       * 2.0.  Note that we cannot just check for API_OPENGL_CORE here because
       * that will erroneously allow this usage in a 3.0 forward-compatible
       * context too.
       */
      if ((ctx->API != API_OPENGL_CORE || ctx->Version < 31)
          && ctx->API != API_OPENGLES2) {
d792 1
a792 1
   else if (index >= ctx->Const.VertexProgram.MaxAttribs) {
d798 1
a798 1
   ASSERT(VERT_ATTRIB_GENERIC(index) < Elements(ctx->Array.ArrayObj->VertexAttrib));
d910 1
a910 1
   if (index >= ctx->Const.VertexProgram.MaxAttribs) {
d920 1
a920 1
   ASSERT(VERT_ATTRIB_GENERIC(index) < Elements(ctx->Array.ArrayObj->VertexAttrib));
d922 1
a922 1
   *pointer = (GLvoid *) ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_GENERIC(index)].Ptr;
d1220 1
a1220 1
         CALL_DrawArrays(ctx->Exec, (mode, first[i], count[i]));
d1240 1
a1240 1
	 CALL_DrawArrays(ctx->Exec, ( m, first[i], count[i] ));
d1262 2
a1263 1
	 CALL_DrawElements(ctx->Exec, ( m, count[i], type, indices[i] ));
a1296 1
   struct gl_client_array *array;
d1299 2
d1306 1
a1306 1
   if (index >= ctx->Const.VertexProgram.MaxAttribs) {
d1312 1
a1312 1
   ASSERT(VERT_ATTRIB_GENERIC(index) < Elements(ctx->Array.ArrayObj->VertexAttrib));
d1314 13
a1326 5
   array = &ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_GENERIC(index)];
   if (array->InstanceDivisor != divisor) {
      FLUSH_VERTICES(ctx, _NEW_ARRAY);
      array->InstanceDivisor = divisor;
   }
d1356 443
d1821 27
d1849 2
d1876 1
a1876 1
   struct gl_array_object *arrayObj = ctx->Array.ArrayObj;
d1879 1
a1879 1
   _mesa_update_array_object_max_element(ctx, arrayObj);
d1881 7
a1887 7
   printf("Array Object %u\n", arrayObj->Name);
   if (arrayObj->VertexAttrib[VERT_ATTRIB_POS].Enabled)
      print_array("Vertex", -1, &arrayObj->VertexAttrib[VERT_ATTRIB_POS]);
   if (arrayObj->VertexAttrib[VERT_ATTRIB_NORMAL].Enabled)
      print_array("Normal", -1, &arrayObj->VertexAttrib[VERT_ATTRIB_NORMAL]);
   if (arrayObj->VertexAttrib[VERT_ATTRIB_COLOR0].Enabled)
      print_array("Color", -1, &arrayObj->VertexAttrib[VERT_ATTRIB_COLOR0]);
d1889 2
a1890 2
      if (arrayObj->VertexAttrib[VERT_ATTRIB_TEX(i)].Enabled)
         print_array("TexCoord", i, &arrayObj->VertexAttrib[VERT_ATTRIB_TEX(i)]);
d1892 3
a1894 3
      if (arrayObj->VertexAttrib[VERT_ATTRIB_GENERIC(i)].Enabled)
         print_array("Attrib", i, &arrayObj->VertexAttrib[VERT_ATTRIB_GENERIC(i)]);
   printf("  _MaxElement = %u\n", arrayObj->_MaxElement);
d1904 2
a1905 3
   ctx->Array.DefaultArrayObj = ctx->Driver.NewArrayObject(ctx, 0);
   _mesa_reference_array_object(ctx, &ctx->Array.ArrayObj,
                                ctx->Array.DefaultArrayObj);
d1918 1
a1918 1
   struct gl_array_object *arrayObj = (struct gl_array_object *) data;
d1920 1
a1920 1
   _mesa_delete_array_object(ctx, arrayObj);
@


1.7
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a2 1
 * Version:  7.6
d20 4
a23 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
a35 1
#include "mfeatures.h"
d61 2
d94 5
a98 1
      return ctx->API == API_OPENGL ? FIXED_GL_BIT : FIXED_ES_BIT;
d110 1
a110 2
 * \param array  the array to update
 * \param dirtyBit  which bit to set in ctx->Array.NewState for this array
d124 1
a124 2
             struct gl_client_array *array,
             GLbitfield dirtyBit, GLbitfield legalTypesMask,
d130 1
d135 40
a174 2
   if (ctx->API != API_OPENGLES && ctx->API != API_OPENGLES2) {
      /* fixed point arrays / data is only allowed with OpenGL ES 1.x/2.0 */
d176 7
a182 3
   }
   if (!ctx->Extensions.ARB_ES2_compatibility) {
      legalTypesMask &= ~FIXED_GL_BIT;
d199 11
a209 1
      if (type != GL_UNSIGNED_BYTE) {
d221 7
d235 14
a248 5
   if (ctx->Array.ArrayObj->VBOonly &&
       ctx->Array.ArrayBufferObj->Name == 0) {
      /* GL_ARB_vertex_array_object requires that all arrays reside in VBOs.
       * Generate GL_INVALID_OPERATION if that's not true.
       */
d253 2
a254 1
   elementSize = _mesa_sizeof_type(type) * size;
d256 1
d263 1
a270 1
   ctx->Array.NewState |= dirtyBit;
a276 2
   GLbitfield legalTypes = (SHORT_BIT | INT_BIT | FLOAT_BIT |
                            DOUBLE_BIT | HALF_BIT | FIXED_ES_BIT);
d278 6
a283 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d285 1
a285 2
   if (ctx->API == API_OPENGLES)
      legalTypes |= BYTE_BIT;
d287 1
a287 2
   update_array(ctx, "glVertexPointer",
                &ctx->Array.ArrayObj->Vertex, _NEW_ARRAY_VERTEX,
a295 3
   const GLbitfield legalTypes = (BYTE_BIT | SHORT_BIT | INT_BIT |
                                  HALF_BIT | FLOAT_BIT | DOUBLE_BIT |
                                  FIXED_ES_BIT);
d297 8
a304 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d306 1
a306 2
   update_array(ctx, "glNormalPointer",
                &ctx->Array.ArrayObj->Normal, _NEW_ARRAY_NORMAL,
a314 5
   const GLbitfield legalTypes = (BYTE_BIT | UNSIGNED_BYTE_BIT |
                                  SHORT_BIT | UNSIGNED_SHORT_BIT |
                                  INT_BIT | UNSIGNED_INT_BIT |
                                  HALF_BIT | FLOAT_BIT | DOUBLE_BIT |
                                  FIXED_ES_BIT);
d316 11
a326 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d328 2
a329 3
   update_array(ctx, "glColorPointer",
                &ctx->Array.ArrayObj->Color, _NEW_ARRAY_COLOR0,
                legalTypes, 3, BGRA_OR_4,
d335 1
a335 1
_mesa_FogCoordPointerEXT(GLenum type, GLsizei stride, const GLvoid *ptr)
a338 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d340 3
a342 2
   update_array(ctx, "glFogCoordPointer",
                &ctx->Array.ArrayObj->FogCoord, _NEW_ARRAY_FOGCOORD,
a353 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d355 3
a357 2
   update_array(ctx, "glIndexPointer",
                &ctx->Array.ArrayObj->Index, _NEW_ARRAY_INDEX,
d364 1
a364 1
_mesa_SecondaryColorPointerEXT(GLint size, GLenum type,
d370 3
a372 1
                                  HALF_BIT | FLOAT_BIT | DOUBLE_BIT);
a373 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d375 3
a377 2
   update_array(ctx, "glSecondaryColorPointer",
                &ctx->Array.ArrayObj->SecondaryColor, _NEW_ARRAY_COLOR1,
a386 3
   GLbitfield legalTypes = (SHORT_BIT | INT_BIT |
                            HALF_BIT | FLOAT_BIT | DOUBLE_BIT |
                            FIXED_ES_BIT);
d388 7
a395 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d397 1
a397 2
   if (ctx->API == API_OPENGLES)
      legalTypes |= BYTE_BIT;
d399 2
a400 6
   ASSERT(unit < Elements(ctx->Array.ArrayObj->TexCoord));

   update_array(ctx, "glTexCoordPointer",
                &ctx->Array.ArrayObj->TexCoord[unit],
                _NEW_ARRAY_TEXCOORD(unit),
                legalTypes, 1, 4,
a412 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d414 3
a416 2
   update_array(ctx, "glEdgeFlagPointer",
                &ctx->Array.ArrayObj->EdgeFlag, _NEW_ARRAY_EDGEFLAG,
d423 1
a423 1
_mesa_PointSizePointer(GLenum type, GLsizei stride, const GLvoid *ptr)
d427 2
a428 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d436 1
a436 2
   update_array(ctx, "glPointSizePointer",
                &ctx->Array.ArrayObj->PointSize, _NEW_ARRAY_POINT_SIZE,
a441 37
#if FEATURE_NV_vertex_program
/**
 * Set a vertex attribute array.
 * Note that these arrays DO alias the conventional GL vertex arrays
 * (position, normal, color, fog, texcoord, etc).
 * The generic attribute slots at #16 and above are not touched.
 */
void GLAPIENTRY
_mesa_VertexAttribPointerNV(GLuint index, GLint size, GLenum type,
                            GLsizei stride, const GLvoid *ptr)
{
   const GLbitfield legalTypes = (UNSIGNED_BYTE_BIT | SHORT_BIT |
                                  FLOAT_BIT | DOUBLE_BIT);
   GLboolean normalized = GL_FALSE;
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   if (index >= MAX_NV_VERTEX_PROGRAM_INPUTS) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glVertexAttribPointerNV(index)");
      return;
   }

   if (type == GL_UNSIGNED_BYTE && size != 4) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glVertexAttribPointerNV(size!=4)");
      return;
   }

   update_array(ctx, "glVertexAttribPointerNV",
                &ctx->Array.ArrayObj->VertexAttrib[index],
                _NEW_ARRAY_ATTRIB(index),
                legalTypes, 1, BGRA_OR_4,
                size, type, stride, normalized, GL_FALSE, ptr);
}
#endif


#if FEATURE_ARB_vertex_program
d448 1
a448 1
_mesa_VertexAttribPointerARB(GLuint index, GLint size, GLenum type,
d456 3
a458 1
                                  FIXED_ES_BIT | FIXED_GL_BIT);
a459 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d466 1
a466 3
   update_array(ctx, "glVertexAttribPointer",
                &ctx->Array.ArrayObj->VertexAttrib[index],
                _NEW_ARRAY_ATTRIB(index),
a469 1
#endif
a487 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d494 1
a494 3
   update_array(ctx, "glVertexAttribIPointer",
                &ctx->Array.ArrayObj->VertexAttrib[index],
                _NEW_ARRAY_ATTRIB(index),
d502 1
a502 1
_mesa_EnableVertexAttribArrayARB(GLuint index)
d504 1
a505 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d513 1
a513 1
   ASSERT(index < Elements(ctx->Array.ArrayObj->VertexAttrib));
d515 8
a522 4
   FLUSH_VERTICES(ctx, _NEW_ARRAY);
   ctx->Array.ArrayObj->VertexAttrib[index].Enabled = GL_TRUE;
   ctx->Array.ArrayObj->_Enabled |= _NEW_ARRAY_ATTRIB(index);
   ctx->Array.NewState |= _NEW_ARRAY_ATTRIB(index);
d527 1
a527 1
_mesa_DisableVertexAttribArrayARB(GLuint index)
d529 1
a530 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d538 1
a538 1
   ASSERT(index < Elements(ctx->Array.ArrayObj->VertexAttrib));
d540 8
a547 4
   FLUSH_VERTICES(ctx, _NEW_ARRAY);
   ctx->Array.ArrayObj->VertexAttrib[index].Enabled = GL_FALSE;
   ctx->Array.ArrayObj->_Enabled &= ~_NEW_ARRAY_ATTRIB(index);
   ctx->Array.NewState |= _NEW_ARRAY_ATTRIB(index);
d567 1
a567 1
   ASSERT(index < Elements(ctx->Array.ArrayObj->VertexAttrib));
d569 1
a569 1
   array = &ctx->Array.ArrayObj->VertexAttrib[index];
d585 3
a587 1
      if (ctx->Extensions.EXT_gpu_shader4) {
d592 2
a593 1
      if (ctx->Extensions.ARB_instanced_arrays) {
d611 7
a617 1
      if (ctx->API != API_OPENGLES2) {
d628 2
d631 1
a631 1
   return ctx->Current.Attrib[VERT_ATTRIB_GENERIC0 + index];
d635 1
a635 1
_mesa_GetVertexAttribfvARB(GLuint index, GLenum pname, GLfloat *params)
a637 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d653 1
a653 1
_mesa_GetVertexAttribdvARB(GLuint index, GLenum pname, GLdouble *params)
a655 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d674 1
a674 1
_mesa_GetVertexAttribivARB(GLuint index, GLenum pname, GLint *params)
a676 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
a699 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d702 1
a702 1
      const GLfloat *v =
d705 1
a705 5
         /* XXX we don't have true integer-valued vertex attribs yet */
         params[0] = (GLint) v[0];
         params[1] = (GLint) v[1];
         params[2] = (GLint) v[2];
         params[3] = (GLint) v[3];
a719 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d722 1
a722 1
      const GLfloat *v =
d725 1
a725 5
         /* XXX we don't have true integer-valued vertex attribs yet */
         params[0] = (GLuint) v[0];
         params[1] = (GLuint) v[1];
         params[2] = (GLuint) v[2];
         params[3] = (GLuint) v[3];
d736 1
a736 1
_mesa_GetVertexAttribPointervARB(GLuint index, GLenum pname, GLvoid **pointer)
a738 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d750 1
a750 1
   ASSERT(index < Elements(ctx->Array.ArrayObj->VertexAttrib));
d752 1
a752 1
   *pointer = (GLvoid *) ctx->Array.ArrayObj->VertexAttrib[index].Ptr;
d821 1
a821 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d991 2
a992 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
a1013 1
   ctx->Array.NewState |= _NEW_ARRAY_ALL;
d1021 2
a1022 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
a1034 1
   ctx->Array.NewState |= _NEW_ARRAY_ALL;
d1040 1
a1040 1
_mesa_MultiDrawArraysEXT( GLenum mode, const GLint *first,
d1046 1
a1046 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d1065 1
a1065 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d1085 1
a1085 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d1106 1
a1106 2
   if (!ctx->Extensions.NV_primitive_restart &&
       ctx->VersionMajor * 10 + ctx->VersionMinor < 31) {
d1111 4
a1114 5
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

   FLUSH_VERTICES(ctx, _NEW_TRANSFORM);

   ctx->Array.RestartIndex = index;
d1126 1
a1127 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d1135 1
a1135 1
      _mesa_error(ctx, GL_INVALID_ENUM, "glVertexAttribDivisor(index = %u)",
d1140 7
a1146 1
   ctx->Array.ArrayObj->VertexAttrib[index].InstanceDivisor = divisor;
d1150 24
d1230 12
a1241 12
   if (arrayObj->Vertex.Enabled)
      print_array("Vertex", -1, &arrayObj->Vertex);
   if (arrayObj->Normal.Enabled)
      print_array("Normal", -1, &arrayObj->Normal);
   if (arrayObj->Color.Enabled)
      print_array("Color", -1, &arrayObj->Color);
   for (i = 0; i < Elements(arrayObj->TexCoord); i++)
      if (arrayObj->TexCoord[i].Enabled)
         print_array("TexCoord", i, &arrayObj->TexCoord[i]);
   for (i = 0; i < Elements(arrayObj->VertexAttrib); i++)
      if (arrayObj->VertexAttrib[i].Enabled)
         print_array("Attrib", i, &arrayObj->VertexAttrib[i]);
d1252 1
a1252 1
   ctx->Array.DefaultArrayObj = _mesa_new_array_object(ctx, 0);
@


1.6
log
@Merge Mesa 7.10.3
@
text
@d36 1
d60 2
a61 2
#define FIXED_BIT            0x400

d93 1
a93 1
      return FIXED_BIT;
d133 4
a136 1
      legalTypesMask &= ~FIXED_BIT;
d204 1
a204 1
                            DOUBLE_BIT | HALF_BIT | FIXED_BIT);
d223 1
a223 1
                                  FIXED_BIT);
d241 1
a241 1
                                  FIXED_BIT);
d305 1
a305 1
                            FIXED_BIT);
d343 1
a343 1
   const GLbitfield legalTypes = (FLOAT_BIT | FIXED_BIT);
d411 1
a411 1
                                  FIXED_BIT);
d490 1
a490 1
                  "glEnableVertexAttribArrayARB(index)");
d540 6
a545 1
      /* fall-through */
d547 1
a547 2
      _mesa_error(ctx, GL_INVALID_ENUM, "%s(pname=0x%x)", caller, pname);
      return 0;
d549 4
d1076 27
d1119 1
@


1.5
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d34 2
d42 57
d100 2
a101 3
 * Set the fields of a vertex array.
 * Also do an error check for GL_ARB_vertex_array_object: check that
 * all arrays reside in VBOs when using a vertex array object.
d103 1
d106 3
a108 1
 * \param elementSize  size of each array element, in bytes
a110 1
 * \param format  either GL_RGBA or GL_BGRA
d113 1
d117 8
a124 4
update_array(GLcontext *ctx, struct gl_client_array *array,
             GLbitfield dirtyBit, GLsizei elementSize,
             GLint size, GLenum type, GLenum format,
             GLsizei stride, GLboolean normalized, const GLvoid *ptr)
d126 41
a166 1
   ASSERT(format == GL_RGBA || format == GL_BGRA);
d173 1
a173 2
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glVertex/Normal/EtcPointer(non-VBO array)");
d177 2
d199 2
a200 1
   GLsizei elementSize;
d204 2
a205 45
   if (size < 2 || size > 4) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glVertexPointer(size)" );
      return;
   }
   if (stride < 0) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glVertexPointer(stride)" );
      return;
   }

   if (MESA_VERBOSE&(VERBOSE_VARRAY|VERBOSE_API))
      _mesa_debug(ctx, "glVertexPointer( sz %d type %s stride %d )\n", size,
                  _mesa_lookup_enum_by_nr( type ), stride);

   /* always need to check that <type> is legal */
   switch (type) {
      case GL_SHORT:
         elementSize = size * sizeof(GLshort);
         break;
      case GL_INT:
         elementSize = size * sizeof(GLint);
         break;
      case GL_FLOAT:
         elementSize = size * sizeof(GLfloat);
         break;
      case GL_DOUBLE:
         elementSize = size * sizeof(GLdouble);
         break;
      case GL_HALF_FLOAT:
         elementSize = size * sizeof(GLhalfARB);
         break;
#if FEATURE_fixedpt
      case GL_FIXED:
         elementSize = size * sizeof(GLfixed);
         break;
#endif
#if FEATURE_vertex_array_byte
      case GL_BYTE:
         elementSize = size * sizeof(GLbyte);
         break;
#endif
      default:
         _mesa_error( ctx, GL_INVALID_ENUM, "glVertexPointer(type=%s)",
                      _mesa_lookup_enum_by_nr(type));
         return;
   }
d207 4
a210 2
   update_array(ctx, &ctx->Array.ArrayObj->Vertex, _NEW_ARRAY_VERTEX,
                elementSize, size, type, GL_RGBA, stride, GL_FALSE, ptr);
d217 3
a219 1
   GLsizei elementSize;
d223 4
a226 41
   if (stride < 0) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glNormalPointer(stride)" );
      return;
   }

   if (MESA_VERBOSE&(VERBOSE_VARRAY|VERBOSE_API))
      _mesa_debug(ctx, "glNormalPointer( type %s stride %d )\n",
                  _mesa_lookup_enum_by_nr( type ), stride);

   switch (type) {
      case GL_BYTE:
         elementSize = 3 * sizeof(GLbyte);
         break;
      case GL_SHORT:
         elementSize = 3 * sizeof(GLshort);
         break;
      case GL_INT:
         elementSize = 3 * sizeof(GLint);
         break;
      case GL_FLOAT:
         elementSize = 3 * sizeof(GLfloat);
         break;
      case GL_DOUBLE:
         elementSize = 3 * sizeof(GLdouble);
         break;
      case GL_HALF_FLOAT:
         elementSize = 3 * sizeof(GLhalfARB);
         break;
#if FEATURE_fixedpt
      case GL_FIXED:
         elementSize = 3 * sizeof(GLfixed);
         break;
#endif
      default:
         _mesa_error( ctx, GL_INVALID_ENUM, "glNormalPointer(type=%s)",
                      _mesa_lookup_enum_by_nr(type));
         return;
   }

   update_array(ctx, &ctx->Array.ArrayObj->Normal, _NEW_ARRAY_NORMAL,
                elementSize, 3, type, GL_RGBA, stride, GL_TRUE, ptr);
d233 5
a237 2
   GLsizei elementSize;
   GLenum format;
d241 4
a244 68
   if (size < 3 || size > 4) {
      if (!ctx->Extensions.EXT_vertex_array_bgra || size != GL_BGRA) {
         _mesa_error(ctx, GL_INVALID_VALUE, "glColorPointer(size)");
         return;
      }
   }
   if (stride < 0) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glColorPointer(stride)" );
      return;
   }

   if (MESA_VERBOSE&(VERBOSE_VARRAY|VERBOSE_API))
      _mesa_debug(ctx, "glColorPointer( sz %d type %s stride %d )\n", size,
                  _mesa_lookup_enum_by_nr( type ), stride);

   if (size == GL_BGRA) {
      if (type != GL_UNSIGNED_BYTE) {
         _mesa_error(ctx, GL_INVALID_VALUE, "glColorPointer(GL_BGRA/GLubyte)");
         return;
      }
      format = GL_BGRA;
      size = 4;
   }
   else {
      format = GL_RGBA;
   }

   switch (type) {
      case GL_BYTE:
         elementSize = size * sizeof(GLbyte);
         break;
      case GL_UNSIGNED_BYTE:
         elementSize = size * sizeof(GLubyte);
         break;
      case GL_SHORT:
         elementSize = size * sizeof(GLshort);
         break;
      case GL_UNSIGNED_SHORT:
         elementSize = size * sizeof(GLushort);
         break;
      case GL_INT:
         elementSize = size * sizeof(GLint);
         break;
      case GL_UNSIGNED_INT:
         elementSize = size * sizeof(GLuint);
         break;
      case GL_FLOAT:
         elementSize = size * sizeof(GLfloat);
         break;
      case GL_DOUBLE:
         elementSize = size * sizeof(GLdouble);
         break;
      case GL_HALF_FLOAT:
         elementSize = size * sizeof(GLhalfARB);
         break;
#if FEATURE_fixedpt
      case GL_FIXED:
         elementSize = size * sizeof(GLfixed);
         break;
#endif
      default:
         _mesa_error( ctx, GL_INVALID_ENUM, "glColorPointer(type=%s)",
                      _mesa_lookup_enum_by_nr(type));
         return;
   }

   update_array(ctx, &ctx->Array.ArrayObj->Color, _NEW_ARRAY_COLOR0,
                elementSize, size, type, format, stride, GL_TRUE, ptr);
d251 1
a251 1
   GLint elementSize;
d255 4
a258 22
   if (stride < 0) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glFogCoordPointer(stride)" );
      return;
   }

   switch (type) {
      case GL_FLOAT:
         elementSize = sizeof(GLfloat);
         break;
      case GL_DOUBLE:
         elementSize = sizeof(GLdouble);
         break;
      case GL_HALF_FLOAT:
         elementSize = sizeof(GLhalfARB);
         break;
      default:
         _mesa_error( ctx, GL_INVALID_ENUM, "glFogCoordPointer(type)" );
         return;
   }

   update_array(ctx, &ctx->Array.ArrayObj->FogCoord, _NEW_ARRAY_FOGCOORD,
                elementSize, 1, type, GL_RGBA, stride, GL_FALSE, ptr);
d265 2
a266 1
   GLsizei elementSize;
d270 4
a273 28
   if (stride < 0) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glIndexPointer(stride)" );
      return;
   }

   switch (type) {
      case GL_UNSIGNED_BYTE:
         elementSize = sizeof(GLubyte);
         break;
      case GL_SHORT:
         elementSize = sizeof(GLshort);
         break;
      case GL_INT:
         elementSize = sizeof(GLint);
         break;
      case GL_FLOAT:
         elementSize = sizeof(GLfloat);
         break;
      case GL_DOUBLE:
         elementSize = sizeof(GLdouble);
         break;
      default:
         _mesa_error( ctx, GL_INVALID_ENUM, "glIndexPointer(type)" );
         return;
   }

   update_array(ctx, &ctx->Array.ArrayObj->Index, _NEW_ARRAY_INDEX,
                elementSize, 1, type, GL_RGBA, stride, GL_FALSE, ptr);
d281 4
a284 2
   GLsizei elementSize;
   GLenum format;
d288 4
a291 63
   if (size != 3 && size != 4) {
      if (!ctx->Extensions.EXT_vertex_array_bgra || size != GL_BGRA) {
         _mesa_error(ctx, GL_INVALID_VALUE, "glSecondaryColorPointer(size)");
         return;
      }
   }
   if (stride < 0) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glSecondaryColorPointer(stride)" );
      return;
   }

   if (MESA_VERBOSE&(VERBOSE_VARRAY|VERBOSE_API))
      _mesa_debug(ctx, "glSecondaryColorPointer( sz %d type %s stride %d )\n",
                  size, _mesa_lookup_enum_by_nr( type ), stride);

   if (size == GL_BGRA) {
      if (type != GL_UNSIGNED_BYTE) {
         _mesa_error(ctx, GL_INVALID_VALUE, "glColorPointer(GL_BGRA/GLubyte)");
         return;
      }
      format = GL_BGRA;
      size = 4;
   }
   else {
      format = GL_RGBA;
   }

   switch (type) {
      case GL_BYTE:
         elementSize = size * sizeof(GLbyte);
         break;
      case GL_UNSIGNED_BYTE:
         elementSize = size * sizeof(GLubyte);
         break;
      case GL_SHORT:
         elementSize = size * sizeof(GLshort);
         break;
      case GL_UNSIGNED_SHORT:
         elementSize = size * sizeof(GLushort);
         break;
      case GL_INT:
         elementSize = size * sizeof(GLint);
         break;
      case GL_UNSIGNED_INT:
         elementSize = size * sizeof(GLuint);
         break;
      case GL_FLOAT:
         elementSize = size * sizeof(GLfloat);
         break;
      case GL_DOUBLE:
         elementSize = size * sizeof(GLdouble);
         break;
      case GL_HALF_FLOAT:
         elementSize = size * sizeof(GLhalfARB);
         break;
      default:
         _mesa_error( ctx, GL_INVALID_ENUM, "glSecondaryColorPointer(type=%s)",
                      _mesa_lookup_enum_by_nr(type));
         return;
   }

   update_array(ctx, &ctx->Array.ArrayObj->SecondaryColor, _NEW_ARRAY_COLOR1,
                elementSize, size, type, format, stride, GL_TRUE, ptr);
d299 3
a301 1
   GLint elementSize;
d306 2
a307 45
   if (size < 1 || size > 4) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glTexCoordPointer(size)" );
      return;
   }
   if (stride < 0) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glTexCoordPointer(stride)" );
      return;
   }

   if (MESA_VERBOSE&(VERBOSE_VARRAY|VERBOSE_API))
      _mesa_debug(ctx, "glTexCoordPointer(unit %u sz %d type %s stride %d)\n",
                  unit, size, _mesa_lookup_enum_by_nr( type ), stride);

   /* always need to check that <type> is legal */
   switch (type) {
      case GL_SHORT:
         elementSize = size * sizeof(GLshort);
         break;
      case GL_INT:
         elementSize = size * sizeof(GLint);
         break;
      case GL_FLOAT:
         elementSize = size * sizeof(GLfloat);
         break;
      case GL_DOUBLE:
         elementSize = size * sizeof(GLdouble);
         break;
      case GL_HALF_FLOAT:
         elementSize = size * sizeof(GLhalfARB);
         break;
#if FEATURE_fixedpt
      case GL_FIXED:
         elementSize = size * sizeof(GLfixed);
         break;
#endif
#if FEATURE_vertex_array_byte
      case GL_BYTE:
         elementSize = size * sizeof(GLbyte);
         break;
#endif
      default:
         _mesa_error( ctx, GL_INVALID_ENUM, "glTexCoordPointer(type=%s)",
                      _mesa_lookup_enum_by_nr(type));
         return;
   }
d311 2
a312 1
   update_array(ctx, &ctx->Array.ArrayObj->TexCoord[unit],
d314 3
a316 1
                elementSize, size, type, GL_RGBA, stride, GL_FALSE, ptr);
d323 3
d329 4
a332 8
   if (stride < 0) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glEdgeFlagPointer(stride)" );
      return;
   }

   update_array(ctx, &ctx->Array.ArrayObj->EdgeFlag, _NEW_ARRAY_EDGEFLAG,
                sizeof(GLboolean), 1, GL_UNSIGNED_BYTE, GL_RGBA,
                stride, GL_FALSE, ptr);
d339 1
a339 1
   GLsizei elementSize;
d343 3
a345 2
   if (stride < 0) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glPointSizePointer(stride)" );
d348 5
a352 17

   switch (type) {
      case GL_FLOAT:
         elementSize = sizeof(GLfloat);
         break;
#if FEATURE_fixedpt
      case GL_FIXED:
         elementSize = sizeof(GLfixed);
         break;
#endif
      default:
         _mesa_error( ctx, GL_INVALID_ENUM, "glPointSizePointer(type)" );
         return;
   }

   update_array(ctx, &ctx->Array.ArrayObj->PointSize, _NEW_ARRAY_POINT_SIZE,
                elementSize, 1, type, GL_RGBA, stride, GL_FALSE, ptr);
d367 2
a369 2
   GLsizei elementSize;
   GLenum format;
a377 10
   if (size < 1 || size > 4) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glVertexAttribPointerNV(size)");
      return;
   }

   if (stride < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glVertexAttribPointerNV(stride)");
      return;
   }

d383 2
a384 37
   if (size == GL_BGRA) {
      if (type != GL_UNSIGNED_BYTE) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glVertexAttribPointerNV(GL_BGRA/type)");
         return;
      }

      format = GL_BGRA;
      size = 4;
      normalized = GL_TRUE;
   }
   else {
      format = GL_RGBA;
   }

   /* check for valid 'type' and compute StrideB right away */
   switch (type) {
      case GL_UNSIGNED_BYTE:
         normalized = GL_TRUE;
         elementSize = size * sizeof(GLubyte);
         break;
      case GL_SHORT:
         elementSize = size * sizeof(GLshort);
         break;
      case GL_FLOAT:
         elementSize = size * sizeof(GLfloat);
         break;
      case GL_DOUBLE:
         elementSize = size * sizeof(GLdouble);
         break;
      default:
         _mesa_error( ctx, GL_INVALID_ENUM, "glVertexAttribPointerNV(type=%s)",
                      _mesa_lookup_enum_by_nr(type));
         return;
   }

   update_array(ctx, &ctx->Array.ArrayObj->VertexAttrib[index],
d386 2
a387 1
                elementSize, size, type, format, stride, normalized, ptr);
d403 5
a407 2
   GLsizei elementSize;
   GLenum format;
d416 157
a572 4
   if (size < 1 || size > 4) {
      if (!ctx->Extensions.EXT_vertex_array_bgra || size != GL_BGRA) {
         _mesa_error(ctx, GL_INVALID_VALUE, "glVertexAttribPointerARB(size)");
         return;
d575 5
d581 19
a599 3
   if (stride < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glVertexAttribPointerARB(stride)");
      return;
d601 8
d610 8
a617 5
   if (size == GL_BGRA) {
      if (type != GL_UNSIGNED_BYTE) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glVertexAttribPointerARB(GL_BGRA/type)");
         return;
d619 24
a642 4
      if (normalized != GL_TRUE) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glVertexAttribPointerARB(GL_BGRA/normalized)");
         return;
d644 7
d652 17
a668 2
      format = GL_BGRA;
      size = 4;
d671 2
a672 1
      format = GL_RGBA;
d674 2
d677 14
a690 38
   /* check for valid 'type' and compute StrideB right away */
   /* NOTE: more types are supported here than in the NV extension */
   switch (type) {
      case GL_BYTE:
         elementSize = size * sizeof(GLbyte);
         break;
      case GL_UNSIGNED_BYTE:
         elementSize = size * sizeof(GLubyte);
         break;
      case GL_SHORT:
         elementSize = size * sizeof(GLshort);
         break;
      case GL_UNSIGNED_SHORT:
         elementSize = size * sizeof(GLushort);
         break;
      case GL_INT:
         elementSize = size * sizeof(GLint);
         break;
      case GL_UNSIGNED_INT:
         elementSize = size * sizeof(GLuint);
         break;
      case GL_FLOAT:
         elementSize = size * sizeof(GLfloat);
         break;
      case GL_DOUBLE:
         elementSize = size * sizeof(GLdouble);
         break;
      case GL_HALF_FLOAT:
         elementSize = size * sizeof(GLhalfARB);
         break;
#if FEATURE_fixedpt
      case GL_FIXED:
         elementSize = size * sizeof(GLfixed);
         break;
#endif
      default:
         _mesa_error( ctx, GL_INVALID_ENUM, "glVertexAttribPointerARB(type)" );
         return;
d693 3
a695 3
   update_array(ctx, &ctx->Array.ArrayObj->VertexAttrib[index],
                _NEW_ARRAY_ATTRIB(index),
                elementSize, size, type, format, stride, normalized, ptr);
a696 1
#endif
a981 1
/* Somebody forgot to spec the first and count parameters as const! <sigh> */
d983 2
a984 2
_mesa_MultiDrawArraysEXT( GLenum mode, GLint *first,
                          GLsizei *count, GLsizei primcount )
d1042 22
d1067 1
a1067 1
_mesa_copy_client_array(GLcontext *ctx,
d1079 1
d1097 1
a1097 1
   printf("Ptr=%p, Type=0x%x, Size=%d, ElemSize=%u, Stride=%d, Buffer=%u(Size %u), MaxElem=%u\n",
d1100 1
a1100 1
	  array->BufferObj->Name, array->BufferObj->Size,
d1109 1
a1109 1
_mesa_print_arrays(GLcontext *ctx)
d1137 1
a1137 1
_mesa_init_varray(GLcontext *ctx)
d1155 1
a1155 1
   GLcontext *ctx = (GLcontext *) userData;
d1164 1
a1164 1
_mesa_free_varray_data(GLcontext *ctx)
@


1.4
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d3 1
a3 1
 * Version:  7.2
d6 1
d33 1
d37 1
a37 1
#include "glapi/dispatch.h"
d41 3
a43 3
 * Update the fields of a vertex array object.
 * We need to do a few special things for arrays that live in
 * vertex buffer objects.
d50 1
d58 1
a58 1
             GLint size, GLenum type,
d61 12
d75 1
d80 2
a81 1
#if FEATURE_ARB_vertex_buffer_object
a84 12
   /* Compute the index of the last array element that's inside the buffer.
    * Later in glDrawArrays we'll check if start + count > _MaxElement to
    * be sure we won't go out of bounds.
    */
   if (ctx->Array.ArrayBufferObj->Name)
      array->_MaxElement = ((GLsizeiptrARB) ctx->Array.ArrayBufferObj->Size
                            - (GLsizeiptrARB) array->Ptr + array->StrideB
                            - elementSize) / array->StrideB;
   else
#endif
      array->_MaxElement = 2 * 1000 * 1000 * 1000; /* just a big number */

d124 3
d138 2
a139 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glVertexPointer(type)" );
d144 1
a144 4
                elementSize, size, type, stride, GL_FALSE, ptr);

   if (ctx->Driver.VertexPointer)
      ctx->Driver.VertexPointer( ctx, size, type, stride, ptr );
d180 3
d189 2
a190 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glNormalPointer(type)" );
d195 1
a195 4
                elementSize, 3, type, stride, GL_TRUE, ptr);

   if (ctx->Driver.NormalPointer)
      ctx->Driver.NormalPointer( ctx, type, stride, ptr );
d203 1
d208 4
a211 2
      _mesa_error( ctx, GL_INVALID_VALUE, "glColorPointer(size)" );
      return;
d222 12
d259 3
d268 2
a269 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glColorPointer(type)" );
d274 1
a274 4
                elementSize, size, type, stride, GL_TRUE, ptr);

   if (ctx->Driver.ColorPointer)
      ctx->Driver.ColorPointer( ctx, size, type, stride, ptr );
d297 3
d306 1
a306 4
                elementSize, 1, type, stride, GL_FALSE, ptr);

   if (ctx->Driver.FogCoordPointer)
      ctx->Driver.FogCoordPointer( ctx, type, stride, ptr );
d344 1
a344 4
                elementSize, 1, type, stride, GL_FALSE, ptr);

   if (ctx->Driver.IndexPointer)
      ctx->Driver.IndexPointer( ctx, type, stride, ptr );
d353 1
d358 4
a361 2
      _mesa_error( ctx, GL_INVALID_VALUE, "glSecondaryColorPointer(size)" );
      return;
d372 12
d409 3
d413 2
a414 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glSecondaryColorPointer(type)" );
d419 1
a419 4
                elementSize, size, type, stride, GL_TRUE, ptr);

   if (ctx->Driver.SecondaryColorPointer)
      ctx->Driver.SecondaryColorPointer( ctx, size, type, stride, ptr );
d459 3
d473 2
a474 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glTexCoordPointer(type)" );
d478 2
d482 1
a482 4
                elementSize, size, type, stride, GL_FALSE, ptr);

   if (ctx->Driver.TexCoordPointer)
      ctx->Driver.TexCoordPointer( ctx, size, type, stride, ptr );
d498 2
a499 4
                sizeof(GLboolean), 1, GL_UNSIGNED_BYTE, stride, GL_FALSE, ptr);

   if (ctx->Driver.EdgeFlagPointer)
      ctx->Driver.EdgeFlagPointer( ctx, stride, ptr );
d530 1
a530 1
                elementSize, 1, type, stride, GL_FALSE, ptr);
d535 6
d547 1
d551 1
a551 1
   if (index >= MAX_VERTEX_PROGRAM_ATTRIBS) {
d571 15
d602 2
a603 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glVertexAttribPointerNV(type)" );
d609 1
a609 4
                elementSize, size, type, stride, normalized, ptr);

   if (ctx->Driver.VertexAttribPointer)
      ctx->Driver.VertexAttribPointer( ctx, index, size, type, stride, ptr );
d615 5
d626 1
d636 4
a639 2
      _mesa_error(ctx, GL_INVALID_VALUE, "glVertexAttribPointerARB(size)");
      return;
d647 19
d693 3
d708 1
a708 4
                elementSize, size, type, stride, normalized, ptr);

   if (ctx->Driver.VertexAttribPointer)
      ctx->Driver.VertexAttribPointer(ctx, index, size, type, stride, ptr);
a970 3

   if (ctx->Driver.LockArraysEXT)
      ctx->Driver.LockArraysEXT( ctx, first, count );
a991 3

   if (ctx->Driver.UnlockArraysEXT)
      ctx->Driver.UnlockArraysEXT( ctx );
a1013 18
/* GL_EXT_multi_draw_arrays */
void GLAPIENTRY
_mesa_MultiDrawElementsEXT( GLenum mode, const GLsizei *count, GLenum type,
                            const GLvoid **indices, GLsizei primcount )
{
   GET_CURRENT_CONTEXT(ctx);
   GLint i;

   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

   for (i = 0; i < primcount; i++) {
      if (count[i] > 0) {
         CALL_DrawElements(ctx->Exec, (mode, count[i], type, indices[i]));
      }
   }
}


d1057 69
d1132 3
a1134 1
   ctx->Array.ArrayObj = ctx->Array.DefaultArrayObj;
d1136 24
a1159 1
   ctx->Array.ActiveTexture = 0;   /* GL_ARB_multitexture */
@


1.3
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d119 10
d174 5
d237 5
d423 10
d466 31
d609 5
@


1.2
log
@Update to Mesa 7.0.3. tested my oga@@ and johan@@
@
text
@d3 1
a3 1
 * Version:  6.5.1
d5 1
a5 1
 * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
d35 1
a35 1
#include "dispatch.h"
d65 3
a67 8
   array->BufferObj->RefCount--;
   if (array->BufferObj->RefCount <= 0) {
      ASSERT(array->BufferObj->Name);
      _mesa_remove_buffer_object( ctx, array->BufferObj );
      (*ctx->Driver.DeleteBuffer)( ctx, array->BufferObj );
   }
   array->BufferObj = ctx->Array.ArrayBufferObj;
   array->BufferObj->RefCount++;
a520 5
   if (type == GL_UNSIGNED_BYTE && size != 4) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glVertexAttribPointerARB(size!=4)");
      return;
   }

d803 3
a805 4
   if (first == 0 && count > 0 &&
       count <= (GLint) ctx->Const.MaxArrayLockSize) {
      ctx->Array.LockFirst = first;
      ctx->Array.LockCount = count;
d807 7
a813 3
   else {
      ctx->Array.LockFirst = 0;
      ctx->Array.LockCount = 0;
d816 3
d835 5
@


1.1
log
@Initial revision
@
text
@d79 2
a80 1
                            - (GLsizeiptrARB) array->Ptr) / array->StrideB;
d446 1
a446 1
   const GLboolean normalized = GL_FALSE;
d474 1
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@Mesa 7.0.1
@
text
@d79 1
a79 2
                            - (GLsizeiptrARB) array->Ptr + array->StrideB
                            - elementSize) / array->StrideB;
@


1.1.1.3
log
@Import Mesa 7.10.3
@
text
@d3 1
a3 1
 * Version:  7.6
d5 1
a5 2
 * Copyright (C) 1999-2008  Brian Paul   All Rights Reserved.
 * Copyright (C) 2009  VMware, Inc.  All Rights Reserved.
a31 3
#include "hash.h"
#include "image.h"
#include "macros.h"
d35 1
a35 58
#include "main/dispatch.h"


/** Used to do error checking for GL_EXT_vertex_array_bgra */
#define BGRA_OR_4  5


/** Used to indicate which GL datatypes are accepted by each of the
 * glVertex/Color/Attrib/EtcPointer() functions.
 */
#define BOOL_BIT             0x1
#define BYTE_BIT             0x2
#define UNSIGNED_BYTE_BIT    0x4
#define SHORT_BIT            0x8
#define UNSIGNED_SHORT_BIT   0x10
#define INT_BIT              0x20
#define UNSIGNED_INT_BIT     0x40
#define HALF_BIT             0x80
#define FLOAT_BIT            0x100
#define DOUBLE_BIT           0x200
#define FIXED_BIT            0x400



/** Convert GL datatype enum into a <type>_BIT value seen above */
static GLbitfield
type_to_bit(const struct gl_context *ctx, GLenum type)
{
   switch (type) {
   case GL_BOOL:
      return BOOL_BIT;
   case GL_BYTE:
      return BYTE_BIT;
   case GL_UNSIGNED_BYTE:
      return UNSIGNED_BYTE_BIT;
   case GL_SHORT:
      return SHORT_BIT;
   case GL_UNSIGNED_SHORT:
      return UNSIGNED_SHORT_BIT;
   case GL_INT:
      return INT_BIT;
   case GL_UNSIGNED_INT:
      return UNSIGNED_INT_BIT;
   case GL_HALF_FLOAT:
      if (ctx->Extensions.ARB_half_float_vertex)
         return HALF_BIT;
      else
         return 0x0;
   case GL_FLOAT:
      return FLOAT_BIT;
   case GL_DOUBLE:
      return DOUBLE_BIT;
   case GL_FIXED:
      return FIXED_BIT;
   default:
      return 0;
   }
}
d39 3
a41 2
 * Do error checking and update state for glVertex/Color/TexCoord/...Pointer
 * functions.
a42 1
 * \param func  name of calling function used for error reporting
d45 1
a45 3
 * \param legalTypes  bitmask of *_BIT above indicating legal datatypes
 * \param sizeMin  min allowable size value
 * \param sizeMax  max allowable size value (may also be BGRA_OR_4)
a49 1
 * \param integer  integer-valued values (will not be normalized to [-1,1])
d53 4
a56 8
update_array(struct gl_context *ctx,
             const char *func,
             struct gl_client_array *array,
             GLbitfield dirtyBit, GLbitfield legalTypesMask,
             GLint sizeMin, GLint sizeMax,
             GLint size, GLenum type, GLsizei stride,
             GLboolean normalized, GLboolean integer,
             const GLvoid *ptr)
a57 53
   GLbitfield typeBit;
   GLsizei elementSize;
   GLenum format = GL_RGBA;

   if (ctx->API != API_OPENGLES && ctx->API != API_OPENGLES2) {
      /* fixed point arrays / data is only allowed with OpenGL ES 1.x/2.0 */
      legalTypesMask &= ~FIXED_BIT;
   }

   typeBit = type_to_bit(ctx, type);
   if (typeBit == 0x0 || (typeBit & legalTypesMask) == 0x0) {
      _mesa_error(ctx, GL_INVALID_ENUM, "%s(type = %s)",
                  func, _mesa_lookup_enum_by_nr(type));
      return;
   }

   /* Do size parameter checking.
    * If sizeMax = BGRA_OR_4 it means that size = GL_BGRA is legal and
    * must be handled specially.
    */
   if (ctx->Extensions.EXT_vertex_array_bgra &&
       sizeMax == BGRA_OR_4 &&
       size == GL_BGRA) {
      if (type != GL_UNSIGNED_BYTE) {
         _mesa_error(ctx, GL_INVALID_VALUE, "%s(GL_BGRA/GLubyte)", func);
         return;
      }
      format = GL_BGRA;
      size = 4;
   }
   else if (size < sizeMin || size > sizeMax || size > 4) {
      _mesa_error(ctx, GL_INVALID_VALUE, "%s(size=%d)", func, size);
      return;
   }

   ASSERT(size <= 4);

   if (stride < 0) {
      _mesa_error( ctx, GL_INVALID_VALUE, "%s(stride=%d)", func, stride );
      return;
   }

   if (ctx->Array.ArrayObj->VBOonly &&
       ctx->Array.ArrayBufferObj->Name == 0) {
      /* GL_ARB_vertex_array_object requires that all arrays reside in VBOs.
       * Generate GL_INVALID_OPERATION if that's not true.
       */
      _mesa_error(ctx, GL_INVALID_OPERATION, "%s(non-VBO array)", func);
      return;
   }

   elementSize = _mesa_sizeof_type(type) * size;

a59 1
   array->Format = format;
d64 20
a83 4
   array->_ElementSize = elementSize;

   _mesa_reference_buffer_object(ctx, &array->BufferObj,
                                 ctx->Array.ArrayBufferObj);
d93 1
a93 2
   GLbitfield legalTypes = (SHORT_BIT | INT_BIT | FLOAT_BIT |
                            DOUBLE_BIT | HALF_BIT | FIXED_BIT);
d97 12
a108 2
   if (ctx->API == API_OPENGLES)
      legalTypes |= BYTE_BIT;
d110 24
a133 4
   update_array(ctx, "glVertexPointer",
                &ctx->Array.ArrayObj->Vertex, _NEW_ARRAY_VERTEX,
                legalTypes, 2, 4,
                size, type, stride, GL_FALSE, GL_FALSE, ptr);
d140 1
a140 3
   const GLbitfield legalTypes = (BYTE_BIT | SHORT_BIT | INT_BIT |
                                  HALF_BIT | FLOAT_BIT | DOUBLE_BIT |
                                  FIXED_BIT);
d144 35
a178 4
   update_array(ctx, "glNormalPointer",
                &ctx->Array.ArrayObj->Normal, _NEW_ARRAY_NORMAL,
                legalTypes, 3, 3,
                3, type, stride, GL_TRUE, GL_FALSE, ptr);
d185 1
a185 5
   const GLbitfield legalTypes = (BYTE_BIT | UNSIGNED_BYTE_BIT |
                                  SHORT_BIT | UNSIGNED_SHORT_BIT |
                                  INT_BIT | UNSIGNED_INT_BIT |
                                  HALF_BIT | FLOAT_BIT | DOUBLE_BIT |
                                  FIXED_BIT);
d189 48
a236 4
   update_array(ctx, "glColorPointer",
                &ctx->Array.ArrayObj->Color, _NEW_ARRAY_COLOR0,
                legalTypes, 3, BGRA_OR_4,
                size, type, stride, GL_TRUE, GL_FALSE, ptr);
d243 1
a243 1
   const GLbitfield legalTypes = (HALF_BIT | FLOAT_BIT | DOUBLE_BIT);
d247 22
a268 4
   update_array(ctx, "glFogCoordPointer",
                &ctx->Array.ArrayObj->FogCoord, _NEW_ARRAY_FOGCOORD,
                legalTypes, 1, 1,
                1, type, stride, GL_FALSE, GL_FALSE, ptr);
d275 1
a275 2
   const GLbitfield legalTypes = (UNSIGNED_BYTE_BIT | SHORT_BIT | INT_BIT |
                                  FLOAT_BIT | DOUBLE_BIT);
d279 31
a309 4
   update_array(ctx, "glIndexPointer",
                &ctx->Array.ArrayObj->Index, _NEW_ARRAY_INDEX,
                legalTypes, 1, 1,
                1, type, stride, GL_FALSE, GL_FALSE, ptr);
d317 1
a317 4
   const GLbitfield legalTypes = (BYTE_BIT | UNSIGNED_BYTE_BIT |
                                  SHORT_BIT | UNSIGNED_SHORT_BIT |
                                  INT_BIT | UNSIGNED_INT_BIT |
                                  HALF_BIT | FLOAT_BIT | DOUBLE_BIT);
d321 48
a368 4
   update_array(ctx, "glSecondaryColorPointer",
                &ctx->Array.ArrayObj->SecondaryColor, _NEW_ARRAY_COLOR1,
                legalTypes, 3, BGRA_OR_4,
                size, type, stride, GL_TRUE, GL_FALSE, ptr);
d376 1
a376 3
   GLbitfield legalTypes = (SHORT_BIT | INT_BIT |
                            HALF_BIT | FLOAT_BIT | DOUBLE_BIT |
                            FIXED_BIT);
d381 8
a388 2
   if (ctx->API == API_OPENGLES)
      legalTypes |= BYTE_BIT;
d390 3
a392 1
   ASSERT(unit < Elements(ctx->Array.ArrayObj->TexCoord));
d394 20
a413 2
   update_array(ctx, "glTexCoordPointer",
                &ctx->Array.ArrayObj->TexCoord[unit],
d415 4
a418 3
                legalTypes, 1, 4,
                size, type, stride, GL_FALSE, GL_FALSE,
                ptr);
a424 3
   const GLbitfield legalTypes = UNSIGNED_BYTE_BIT;
   /* see table 2.4 edits in GL_EXT_gpu_shader4 spec: */
   const GLboolean integer = GL_TRUE;
d428 4
a431 5
   update_array(ctx, "glEdgeFlagPointer",
                &ctx->Array.ArrayObj->EdgeFlag, _NEW_ARRAY_EDGEFLAG,
                legalTypes, 1, 1,
                1, GL_UNSIGNED_BYTE, stride, GL_FALSE, integer, ptr);
}
d433 2
d436 2
a437 17
void GLAPIENTRY
_mesa_PointSizePointer(GLenum type, GLsizei stride, const GLvoid *ptr)
{
   const GLbitfield legalTypes = (FLOAT_BIT | FIXED_BIT);
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

   if (ctx->API != API_OPENGLES) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glPointSizePointer(ES 1.x only)");
      return;
   }
      
   update_array(ctx, "glPointSizePointer",
                &ctx->Array.ArrayObj->PointSize, _NEW_ARRAY_POINT_SIZE,
                legalTypes, 1, 1,
                1, type, stride, GL_FALSE, GL_FALSE, ptr);
a441 6
/**
 * Set a vertex attribute array.
 * Note that these arrays DO alias the conventional GL vertex arrays
 * (position, normal, color, fog, texcoord, etc).
 * The generic attribute slots at #16 and above are not touched.
 */
d446 2
a447 3
   const GLbitfield legalTypes = (UNSIGNED_BYTE_BIT | SHORT_BIT |
                                  FLOAT_BIT | DOUBLE_BIT);
   GLboolean normalized = GL_FALSE;
d451 1
a451 1
   if (index >= MAX_NV_VERTEX_PROGRAM_INPUTS) {
d456 10
d471 20
a490 2
   update_array(ctx, "glVertexAttribPointerNV",
                &ctx->Array.ArrayObj->VertexAttrib[index],
d492 4
a495 2
                legalTypes, 1, BGRA_OR_4,
                size, type, stride, normalized, GL_FALSE, ptr);
a500 5
/**
 * Set a generic vertex attribute array.
 * Note that these arrays DO NOT alias the conventional GL vertex arrays
 * (position, normal, color, fog, texcoord, etc).
 */
d506 1
a506 5
   const GLbitfield legalTypes = (BYTE_BIT | UNSIGNED_BYTE_BIT |
                                  SHORT_BIT | UNSIGNED_SHORT_BIT |
                                  INT_BIT | UNSIGNED_INT_BIT |
                                  HALF_BIT | FLOAT_BIT | DOUBLE_BIT |
                                  FIXED_BIT);
d515 2
a516 29
   update_array(ctx, "glVertexAttribPointer",
                &ctx->Array.ArrayObj->VertexAttrib[index],
                _NEW_ARRAY_ATTRIB(index),
                legalTypes, 1, BGRA_OR_4,
                size, type, stride, normalized, GL_FALSE, ptr);
}
#endif


/**
 * GL_EXT_gpu_shader4 / GL 3.0.
 * Set an integer-valued vertex attribute array.
 * Note that these arrays DO NOT alias the conventional GL vertex arrays
 * (position, normal, color, fog, texcoord, etc).
 */
void GLAPIENTRY
_mesa_VertexAttribIPointer(GLuint index, GLint size, GLenum type,
                           GLsizei stride, const GLvoid *ptr)
{
   const GLbitfield legalTypes = (BYTE_BIT | UNSIGNED_BYTE_BIT |
                                  SHORT_BIT | UNSIGNED_SHORT_BIT |
                                  INT_BIT | UNSIGNED_INT_BIT);
   const GLboolean normalized = GL_FALSE;
   const GLboolean integer = GL_TRUE;
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   if (index >= ctx->Const.VertexProgram.MaxAttribs) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glVertexAttribIPointer(index)");
d520 2
a521 18
   update_array(ctx, "glVertexAttribIPointer",
                &ctx->Array.ArrayObj->VertexAttrib[index],
                _NEW_ARRAY_ATTRIB(index),
                legalTypes, 1, 4,
                size, type, stride, normalized, integer, ptr);
}



void GLAPIENTRY
_mesa_EnableVertexAttribArrayARB(GLuint index)
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   if (index >= ctx->Const.VertexProgram.MaxAttribs) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glEnableVertexAttribArrayARB(index)");
d525 2
a526 18
   ASSERT(index < Elements(ctx->Array.ArrayObj->VertexAttrib));

   FLUSH_VERTICES(ctx, _NEW_ARRAY);
   ctx->Array.ArrayObj->VertexAttrib[index].Enabled = GL_TRUE;
   ctx->Array.ArrayObj->_Enabled |= _NEW_ARRAY_ATTRIB(index);
   ctx->Array.NewState |= _NEW_ARRAY_ATTRIB(index);
}


void GLAPIENTRY
_mesa_DisableVertexAttribArrayARB(GLuint index)
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   if (index >= ctx->Const.VertexProgram.MaxAttribs) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glEnableVertexAttribArrayARB(index)");
d530 30
a559 23
   ASSERT(index < Elements(ctx->Array.ArrayObj->VertexAttrib));

   FLUSH_VERTICES(ctx, _NEW_ARRAY);
   ctx->Array.ArrayObj->VertexAttrib[index].Enabled = GL_FALSE;
   ctx->Array.ArrayObj->_Enabled &= ~_NEW_ARRAY_ATTRIB(index);
   ctx->Array.NewState |= _NEW_ARRAY_ATTRIB(index);
}


/**
 * Return info for a vertex attribute array (no alias with legacy
 * vertex attributes (pos, normal, color, etc)).  This function does
 * not handle the 4-element GL_CURRENT_VERTEX_ATTRIB_ARB query.
 */
static GLuint
get_vertex_array_attrib(struct gl_context *ctx, GLuint index, GLenum pname,
                  const char *caller)
{
   const struct gl_client_array *array;

   if (index >= ctx->Const.VertexProgram.MaxAttribs) {
      _mesa_error(ctx, GL_INVALID_VALUE, "%s(index=%u)", caller, index);
      return 0;
d562 3
a564 3
   ASSERT(index < Elements(ctx->Array.ArrayObj->VertexAttrib));

   array = &ctx->Array.ArrayObj->VertexAttrib[index];
d566 2
a567 177
   switch (pname) {
   case GL_VERTEX_ATTRIB_ARRAY_ENABLED_ARB:
      return array->Enabled;
   case GL_VERTEX_ATTRIB_ARRAY_SIZE_ARB:
      return array->Size;
   case GL_VERTEX_ATTRIB_ARRAY_STRIDE_ARB:
      return array->Stride;
   case GL_VERTEX_ATTRIB_ARRAY_TYPE_ARB:
      return array->Type;
   case GL_VERTEX_ATTRIB_ARRAY_NORMALIZED_ARB:
      return array->Normalized;
   case GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING_ARB:
      return array->BufferObj->Name;
   case GL_VERTEX_ATTRIB_ARRAY_INTEGER:
      if (ctx->Extensions.EXT_gpu_shader4) {
         return array->Integer;
      }
      /* fall-through */
   default:
      _mesa_error(ctx, GL_INVALID_ENUM, "%s(pname=0x%x)", caller, pname);
      return 0;
   }
}


static const GLfloat *
get_current_attrib(struct gl_context *ctx, GLuint index, const char *function)
{
   if (index == 0) {
      if (ctx->API != API_OPENGLES2) {
	 _mesa_error(ctx, GL_INVALID_OPERATION, "%s(index==0)", function);
	 return NULL;
      }
   }
   else if (index >= ctx->Const.VertexProgram.MaxAttribs) {
      _mesa_error(ctx, GL_INVALID_VALUE,
		  "%s(index>=GL_MAX_VERTEX_ATTRIBS)", function);
      return NULL;
   }

   FLUSH_CURRENT(ctx, 0);
   return ctx->Current.Attrib[VERT_ATTRIB_GENERIC0 + index];
}

void GLAPIENTRY
_mesa_GetVertexAttribfvARB(GLuint index, GLenum pname, GLfloat *params)
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   if (pname == GL_CURRENT_VERTEX_ATTRIB_ARB) {
      const GLfloat *v = get_current_attrib(ctx, index, "glGetVertexAttribfv");
      if (v != NULL) {
         COPY_4V(params, v);
      }
   }
   else {
      params[0] = (GLfloat) get_vertex_array_attrib(ctx, index, pname,
                                                    "glGetVertexAttribfv");
   }
}


void GLAPIENTRY
_mesa_GetVertexAttribdvARB(GLuint index, GLenum pname, GLdouble *params)
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   if (pname == GL_CURRENT_VERTEX_ATTRIB_ARB) {
      const GLfloat *v = get_current_attrib(ctx, index, "glGetVertexAttribdv");
      if (v != NULL) {
         params[0] = (GLdouble) v[0];
         params[1] = (GLdouble) v[1];
         params[2] = (GLdouble) v[2];
         params[3] = (GLdouble) v[3];
      }
   }
   else {
      params[0] = (GLdouble) get_vertex_array_attrib(ctx, index, pname,
                                                     "glGetVertexAttribdv");
   }
}


void GLAPIENTRY
_mesa_GetVertexAttribivARB(GLuint index, GLenum pname, GLint *params)
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   if (pname == GL_CURRENT_VERTEX_ATTRIB_ARB) {
      const GLfloat *v = get_current_attrib(ctx, index, "glGetVertexAttribiv");
      if (v != NULL) {
         /* XXX should floats in[0,1] be scaled to full int range? */
         params[0] = (GLint) v[0];
         params[1] = (GLint) v[1];
         params[2] = (GLint) v[2];
         params[3] = (GLint) v[3];
      }
   }
   else {
      params[0] = (GLint) get_vertex_array_attrib(ctx, index, pname,
                                                  "glGetVertexAttribiv");
   }
}


/** GL 3.0 */
void GLAPIENTRY
_mesa_GetVertexAttribIiv(GLuint index, GLenum pname, GLint *params)
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   if (pname == GL_CURRENT_VERTEX_ATTRIB_ARB) {
      const GLfloat *v =
	 get_current_attrib(ctx, index, "glGetVertexAttribIiv");
      if (v != NULL) {
         /* XXX we don't have true integer-valued vertex attribs yet */
         params[0] = (GLint) v[0];
         params[1] = (GLint) v[1];
         params[2] = (GLint) v[2];
         params[3] = (GLint) v[3];
      }
   }
   else {
      params[0] = (GLint) get_vertex_array_attrib(ctx, index, pname,
                                                  "glGetVertexAttribIiv");
   }
}


/** GL 3.0 */
void GLAPIENTRY
_mesa_GetVertexAttribIuiv(GLuint index, GLenum pname, GLuint *params)
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   if (pname == GL_CURRENT_VERTEX_ATTRIB_ARB) {
      const GLfloat *v =
	 get_current_attrib(ctx, index, "glGetVertexAttribIuiv");
      if (v != NULL) {
         /* XXX we don't have true integer-valued vertex attribs yet */
         params[0] = (GLuint) v[0];
         params[1] = (GLuint) v[1];
         params[2] = (GLuint) v[2];
         params[3] = (GLuint) v[3];
      }
   }
   else {
      params[0] = get_vertex_array_attrib(ctx, index, pname,
                                          "glGetVertexAttribIuiv");
   }
}


void GLAPIENTRY
_mesa_GetVertexAttribPointervARB(GLuint index, GLenum pname, GLvoid **pointer)
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   if (index >= ctx->Const.VertexProgram.MaxAttribs) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glGetVertexAttribPointerARB(index)");
      return;
   }

   if (pname != GL_VERTEX_ATTRIB_ARRAY_POINTER_ARB) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetVertexAttribPointerARB(pname)");
      return;
   }

   ASSERT(index < Elements(ctx->Array.ArrayObj->VertexAttrib));

   *pointer = (GLvoid *) ctx->Array.ArrayObj->VertexAttrib[index].Ptr;
d569 1
d812 4
a815 3
   if (first < 0) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glLockArraysEXT(first)" );
      return;
d817 3
a819 7
   if (count <= 0) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glLockArraysEXT(count)" );
      return;
   }
   if (ctx->Array.LockCount != 0) {
      _mesa_error( ctx, GL_INVALID_OPERATION, "glLockArraysEXT(reentry)" );
      return;
a821 3
   ctx->Array.LockFirst = first;
   ctx->Array.LockCount = count;

d824 3
a838 5
   if (ctx->Array.LockCount == 0) {
      _mesa_error( ctx, GL_INVALID_OPERATION, "glUnlockArraysEXT(reexit)" );
      return;
   }

d843 3
d850 1
d852 2
a853 2
_mesa_MultiDrawArraysEXT( GLenum mode, const GLint *first,
                          const GLsizei *count, GLsizei primcount )
d868 18
a928 92
 * GL_NV_primitive_restart and GL 3.1
 */
void GLAPIENTRY
_mesa_PrimitiveRestartIndex(GLuint index)
{
   GET_CURRENT_CONTEXT(ctx);

   if (!ctx->Extensions.NV_primitive_restart &&
       ctx->VersionMajor * 10 + ctx->VersionMinor < 31) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glPrimitiveRestartIndexNV()");
      return;
   }

   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

   FLUSH_VERTICES(ctx, _NEW_TRANSFORM);

   ctx->Array.RestartIndex = index;
}


/**
 * Copy one client vertex array to another.
 */
void
_mesa_copy_client_array(struct gl_context *ctx,
                        struct gl_client_array *dst,
                        struct gl_client_array *src)
{
   dst->Size = src->Size;
   dst->Type = src->Type;
   dst->Format = src->Format;
   dst->Stride = src->Stride;
   dst->StrideB = src->StrideB;
   dst->Ptr = src->Ptr;
   dst->Enabled = src->Enabled;
   dst->Normalized = src->Normalized;
   dst->Integer = src->Integer;
   dst->_ElementSize = src->_ElementSize;
   _mesa_reference_buffer_object(ctx, &dst->BufferObj, src->BufferObj);
   dst->_MaxElement = src->_MaxElement;
}



/**
 * Print vertex array's fields.
 */
static void
print_array(const char *name, GLint index, const struct gl_client_array *array)
{
   if (index >= 0)
      printf("  %s[%d]: ", name, index);
   else
      printf("  %s: ", name);
   printf("Ptr=%p, Type=0x%x, Size=%d, ElemSize=%u, Stride=%d, Buffer=%u(Size %lu), MaxElem=%u\n",
	  array->Ptr, array->Type, array->Size,
	  array->_ElementSize, array->StrideB,
	  array->BufferObj->Name, (unsigned long) array->BufferObj->Size,
	  array->_MaxElement);
}


/**
 * Print current vertex object/array info.  For debug.
 */
void
_mesa_print_arrays(struct gl_context *ctx)
{
   struct gl_array_object *arrayObj = ctx->Array.ArrayObj;
   GLuint i;

   _mesa_update_array_object_max_element(ctx, arrayObj);

   printf("Array Object %u\n", arrayObj->Name);
   if (arrayObj->Vertex.Enabled)
      print_array("Vertex", -1, &arrayObj->Vertex);
   if (arrayObj->Normal.Enabled)
      print_array("Normal", -1, &arrayObj->Normal);
   if (arrayObj->Color.Enabled)
      print_array("Color", -1, &arrayObj->Color);
   for (i = 0; i < Elements(arrayObj->TexCoord); i++)
      if (arrayObj->TexCoord[i].Enabled)
         print_array("TexCoord", i, &arrayObj->TexCoord[i]);
   for (i = 0; i < Elements(arrayObj->VertexAttrib); i++)
      if (arrayObj->VertexAttrib[i].Enabled)
         print_array("Attrib", i, &arrayObj->VertexAttrib[i]);
   printf("  _MaxElement = %u\n", arrayObj->_MaxElement);
}


/**
d932 1
a932 1
_mesa_init_varray(struct gl_context *ctx)
d935 2
a936 2
   _mesa_reference_array_object(ctx, &ctx->Array.ArrayObj,
                                ctx->Array.DefaultArrayObj);
a937 25

   ctx->Array.Objects = _mesa_NewHashTable();
}


/**
 * Callback for deleting an array object.  Called by _mesa_HashDeleteAll().
 */
static void
delete_arrayobj_cb(GLuint id, void *data, void *userData)
{
   struct gl_array_object *arrayObj = (struct gl_array_object *) data;
   struct gl_context *ctx = (struct gl_context *) userData;
   _mesa_delete_array_object(ctx, arrayObj);
}


/**
 * Free vertex array state for given context.
 */
void 
_mesa_free_varray_data(struct gl_context *ctx)
{
   _mesa_HashDeleteAll(ctx->Array.Objects, delete_arrayobj_cb, ctx);
   _mesa_DeleteHashTable(ctx->Array.Objects);
@


1.1.1.4
log
@Import Mesa 9.2.0
@
text
@d3 1
d21 3
a23 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
d59 2
a60 4
#define FIXED_ES_BIT         0x400
#define FIXED_GL_BIT         0x800
#define UNSIGNED_INT_2_10_10_10_REV_BIT 0x1000
#define INT_2_10_10_10_REV_BIT 0x2000
d92 1
a92 5
      return _mesa_is_desktop_gl(ctx) ? FIXED_GL_BIT : FIXED_ES_BIT;
   case GL_UNSIGNED_INT_2_10_10_10_REV:
      return UNSIGNED_INT_2_10_10_10_REV_BIT;
   case GL_INT_2_10_10_10_REV:
      return INT_2_10_10_10_REV_BIT;
d104 2
a105 1
 * \param attrib  the attribute array index to update
d119 2
a120 1
             GLuint attrib, GLbitfield legalTypesMask,
a125 1
   struct gl_client_array *array;
d130 3
a132 48
   /* Page 407 (page 423 of the PDF) of the OpenGL 3.0 spec says:
    *
    *     "Client vertex arrays - all vertex array attribute pointers must
    *     refer to buffer objects (section 2.9.2). The default vertex array
    *     object (the name zero) is also deprecated. Calling
    *     VertexAttribPointer when no buffer object or no vertex array object
    *     is bound will generate an INVALID_OPERATION error..."
    *
    * The check for VBOs is handled below.
    */
   if (ctx->API == API_OPENGL_CORE
       && (ctx->Array.ArrayObj == ctx->Array.DefaultArrayObj)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "%s(no array object bound)",
                  func);
      return;
   }

   if (_mesa_is_gles(ctx)) {
      legalTypesMask &= ~(FIXED_GL_BIT | DOUBLE_BIT);

      /* GL_INT and GL_UNSIGNED_INT data is not allowed in OpenGL ES until
       * 3.0.  The 2_10_10_10 types are added in OpenGL ES 3.0 or
       * GL_OES_vertex_type_10_10_10_2.  GL_HALF_FLOAT data is not allowed
       * until 3.0 or with the GL_OES_vertex_half float extension, which isn't
       * quite as trivial as we'd like because it uses a different enum value
       * for GL_HALF_FLOAT_OES.
       */
      if (ctx->Version < 30) {
         legalTypesMask &= ~(UNSIGNED_INT_BIT
                             | INT_BIT
                             | UNSIGNED_INT_2_10_10_10_REV_BIT
                             | INT_2_10_10_10_REV_BIT
                             | HALF_BIT);
      }

      /* BGRA ordering is not supported in ES contexts.
       */
      if (sizeMax == BGRA_OR_4)
         sizeMax = 4;
   } else {
      legalTypesMask &= ~FIXED_ES_BIT;

      if (!ctx->Extensions.ARB_ES2_compatibility)
         legalTypesMask &= ~FIXED_GL_BIT;

      if (!ctx->Extensions.ARB_vertex_type_2_10_10_10_rev)
         legalTypesMask &= ~(UNSIGNED_INT_2_10_10_10_REV_BIT |
                             INT_2_10_10_10_REV_BIT);
d149 1
a149 11
      GLboolean bgra_error = GL_FALSE;

      if (ctx->Extensions.ARB_vertex_type_2_10_10_10_rev) {
         if (type != GL_UNSIGNED_INT_2_10_10_10_REV &&
             type != GL_INT_2_10_10_10_REV &&
             type != GL_UNSIGNED_BYTE)
            bgra_error = GL_TRUE;
      } else if (type != GL_UNSIGNED_BYTE)
         bgra_error = GL_TRUE;

      if (bgra_error) {
a160 7
   if (ctx->Extensions.ARB_vertex_type_2_10_10_10_rev &&
       (type == GL_UNSIGNED_INT_2_10_10_10_REV ||
        type == GL_INT_2_10_10_10_REV) && size != 4) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "%s(size=%d)", func, size);
      return;
   }

d168 5
a172 14
   /* Page 29 (page 44 of the PDF) of the OpenGL 3.3 spec says:
    *
    *     "An INVALID_OPERATION error is generated under any of the following
    *     conditions:
    *
    *     ...
    *
    *     * any of the *Pointer commands specifying the location and
    *       organization of vertex array data are called while zero is bound
    *       to the ARRAY_BUFFER buffer object binding point (see section
    *       2.9.6), and the pointer argument is not NULL."
    */
   if (ptr != NULL && ctx->Array.ArrayObj->ARBsemantics &&
       !_mesa_is_bufferobj(ctx->Array.ArrayBufferObj)) {
d177 1
a177 2
   elementSize = _mesa_bytes_per_vertex_attrib(size, type);
   assert(elementSize != -1);
a178 1
   array = &ctx->Array.ArrayObj->VertexAttrib[attrib];
a184 1
   array->Integer = integer;
d192 1
d199 2
d202 1
a202 6
   GLbitfield legalTypes = (ctx->API == API_OPENGLES)
      ? (BYTE_BIT | SHORT_BIT | FLOAT_BIT | FIXED_ES_BIT)
      : (SHORT_BIT | INT_BIT | FLOAT_BIT |
         DOUBLE_BIT | HALF_BIT |
         UNSIGNED_INT_2_10_10_10_REV_BIT |
         INT_2_10_10_10_REV_BIT);
d204 2
a205 1
   FLUSH_VERTICES(ctx, 0);
d207 2
a208 1
   update_array(ctx, "glVertexPointer", VERT_ATTRIB_POS,
d217 3
d221 1
a221 6
   const GLbitfield legalTypes = (ctx->API == API_OPENGLES)
      ? (BYTE_BIT | SHORT_BIT | FLOAT_BIT | FIXED_ES_BIT)
      : (BYTE_BIT | SHORT_BIT | INT_BIT |
         HALF_BIT | FLOAT_BIT | DOUBLE_BIT |
         UNSIGNED_INT_2_10_10_10_REV_BIT |
         INT_2_10_10_10_REV_BIT);
d223 2
a224 3
   FLUSH_VERTICES(ctx, 0);

   update_array(ctx, "glNormalPointer", VERT_ATTRIB_NORMAL,
d233 5
d239 1
a239 9
   const GLbitfield legalTypes = (ctx->API == API_OPENGLES)
      ? (UNSIGNED_BYTE_BIT | HALF_BIT | FLOAT_BIT | FIXED_ES_BIT)
      : (BYTE_BIT | UNSIGNED_BYTE_BIT |
         SHORT_BIT | UNSIGNED_SHORT_BIT |
         INT_BIT | UNSIGNED_INT_BIT |
         HALF_BIT | FLOAT_BIT | DOUBLE_BIT |
         UNSIGNED_INT_2_10_10_10_REV_BIT |
         INT_2_10_10_10_REV_BIT);
   const GLint sizeMin = (ctx->API == API_OPENGLES) ? 4 : 3;
d241 3
a243 4
   FLUSH_VERTICES(ctx, 0);

   update_array(ctx, "glColorPointer", VERT_ATTRIB_COLOR0,
                legalTypes, sizeMin, BGRA_OR_4,
d249 1
a249 1
_mesa_FogCoordPointer(GLenum type, GLsizei stride, const GLvoid *ptr)
d253 1
d255 2
a256 3
   FLUSH_VERTICES(ctx, 0);

   update_array(ctx, "glFogCoordPointer", VERT_ATTRIB_FOG,
d268 1
d270 2
a271 3
   FLUSH_VERTICES(ctx, 0);

   update_array(ctx, "glIndexPointer", VERT_ATTRIB_COLOR_INDEX,
d278 1
a278 1
_mesa_SecondaryColorPointer(GLint size, GLenum type,
d284 1
a284 3
                                  HALF_BIT | FLOAT_BIT | DOUBLE_BIT |
                                  UNSIGNED_INT_2_10_10_10_REV_BIT |
                                  INT_2_10_10_10_REV_BIT);
d286 1
d288 2
a289 3
   FLUSH_VERTICES(ctx, 0);

   update_array(ctx, "glSecondaryColorPointer", VERT_ATTRIB_COLOR1,
d299 3
a302 7
   GLbitfield legalTypes = (ctx->API == API_OPENGLES)
      ? (BYTE_BIT | SHORT_BIT | FLOAT_BIT | FIXED_ES_BIT)
      : (SHORT_BIT | INT_BIT |
         HALF_BIT | FLOAT_BIT | DOUBLE_BIT |
         UNSIGNED_INT_2_10_10_10_REV_BIT |
         INT_2_10_10_10_REV_BIT);
   const GLint sizeMin = (ctx->API == API_OPENGLES) ? 2 : 1;
d304 4
d309 1
a309 1
   FLUSH_VERTICES(ctx, 0);
d311 4
a314 2
   update_array(ctx, "glTexCoordPointer", VERT_ATTRIB_TEX(unit),
                legalTypes, sizeMin, 4,
d327 1
d329 2
a330 3
   FLUSH_VERTICES(ctx, 0);

   update_array(ctx, "glEdgeFlagPointer", VERT_ATTRIB_EDGEFLAG,
d337 1
a337 1
_mesa_PointSizePointerOES(GLenum type, GLsizei stride, const GLvoid *ptr)
d339 1
a339 1
   const GLbitfield legalTypes = (FLOAT_BIT | FIXED_ES_BIT);
d341 1
a341 2

   FLUSH_VERTICES(ctx, 0);
d349 2
a350 1
   update_array(ctx, "glPointSizePointer", VERT_ATTRIB_POINT_SIZE,
d356 37
d399 1
a399 1
_mesa_VertexAttribPointer(GLuint index, GLint size, GLenum type,
d407 1
a407 3
                                  FIXED_ES_BIT | FIXED_GL_BIT |
                                  UNSIGNED_INT_2_10_10_10_REV_BIT |
                                  INT_2_10_10_10_REV_BIT);
d409 1
d416 3
a418 1
   update_array(ctx, "glVertexAttribPointer", VERT_ATTRIB_GENERIC(index),
d422 1
d441 1
d448 3
a450 1
   update_array(ctx, "glVertexAttribIPointer", VERT_ATTRIB_GENERIC(index),
d458 1
a458 1
_mesa_EnableVertexAttribArray(GLuint index)
a459 1
   struct gl_array_object *arrayObj;
d461 1
d469 1
a469 3
   arrayObj = ctx->Array.ArrayObj;

   ASSERT(VERT_ATTRIB_GENERIC(index) < Elements(arrayObj->VertexAttrib));
d471 4
a474 6
   if (!arrayObj->VertexAttrib[VERT_ATTRIB_GENERIC(index)].Enabled) {
      /* was disabled, now being enabled */
      FLUSH_VERTICES(ctx, _NEW_ARRAY);
      arrayObj->VertexAttrib[VERT_ATTRIB_GENERIC(index)].Enabled = GL_TRUE;
      arrayObj->_Enabled |= VERT_BIT_GENERIC(index);
   }
d479 1
a479 1
_mesa_DisableVertexAttribArray(GLuint index)
a480 1
   struct gl_array_object *arrayObj;
d482 1
d486 1
a486 1
                  "glDisableVertexAttribArrayARB(index)");
d490 1
a490 3
   arrayObj = ctx->Array.ArrayObj;

   ASSERT(VERT_ATTRIB_GENERIC(index) < Elements(arrayObj->VertexAttrib));
d492 4
a495 6
   if (arrayObj->VertexAttrib[VERT_ATTRIB_GENERIC(index)].Enabled) {
      /* was enabled, now being disabled */
      FLUSH_VERTICES(ctx, _NEW_ARRAY);
      arrayObj->VertexAttrib[VERT_ATTRIB_GENERIC(index)].Enabled = GL_FALSE;
      arrayObj->_Enabled &= ~VERT_BIT_GENERIC(index);
   }
d515 1
a515 1
   ASSERT(VERT_ATTRIB_GENERIC(index) < Elements(ctx->Array.ArrayObj->VertexAttrib));
d517 1
a517 1
   array = &ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_GENERIC(index)];
d533 1
a533 3
      if ((_mesa_is_desktop_gl(ctx)
           && (ctx->Version >= 30 || ctx->Extensions.EXT_gpu_shader4))
          || _mesa_is_gles3(ctx)) {
d536 1
a536 7
      goto error;
   case GL_VERTEX_ATTRIB_ARRAY_DIVISOR_ARB:
      if ((_mesa_is_desktop_gl(ctx) && ctx->Extensions.ARB_instanced_arrays)
          || _mesa_is_gles3(ctx)) {
         return array->InstanceDivisor;
      }
      goto error;
d538 2
a539 1
      ; /* fall-through */
a540 4

error:
   _mesa_error(ctx, GL_INVALID_ENUM, "%s(pname=0x%x)", caller, pname);
   return 0;
d548 1
a548 7
      /* In OpenGL 3.1 attribute 0 becomes non-magic, just like in OpenGL ES
       * 2.0.  Note that we cannot just check for API_OPENGL_CORE here because
       * that will erroneously allow this usage in a 3.0 forward-compatible
       * context too.
       */
      if ((ctx->API != API_OPENGL_CORE || ctx->Version < 31)
          && ctx->API != API_OPENGLES2) {
a558 2
   ASSERT(VERT_ATTRIB_GENERIC(index) < Elements(ctx->Array.ArrayObj->VertexAttrib));

d560 1
a560 1
   return ctx->Current.Attrib[VERT_ATTRIB_GENERIC(index)];
d564 1
a564 1
_mesa_GetVertexAttribfv(GLuint index, GLenum pname, GLfloat *params)
d567 1
d583 1
a583 1
_mesa_GetVertexAttribdv(GLuint index, GLenum pname, GLdouble *params)
d586 1
d605 1
a605 1
_mesa_GetVertexAttribiv(GLuint index, GLenum pname, GLint *params)
d608 1
d632 1
d635 1
a635 1
      const GLint *v = (const GLint *)
d638 5
a642 1
         COPY_4V(params, v);
d657 1
d660 1
a660 1
      const GLuint *v = (const GLuint *)
d663 5
a667 1
         COPY_4V(params, v);
d678 1
a678 1
_mesa_GetVertexAttribPointerv(GLuint index, GLenum pname, GLvoid **pointer)
d681 1
d693 1
a693 1
   ASSERT(VERT_ATTRIB_GENERIC(index) < Elements(ctx->Array.ArrayObj->VertexAttrib));
d695 1
a695 1
   *pointer = (GLvoid *) ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_GENERIC(index)].Ptr;
d764 1
a764 1
   FLUSH_VERTICES(ctx, 0);
d934 1
a934 2

   FLUSH_VERTICES(ctx, 0);
d956 1
d964 1
a964 2

   FLUSH_VERTICES(ctx, 0);
d977 1
d983 1
a983 1
_mesa_MultiDrawArrays( GLenum mode, const GLint *first,
d989 1
a989 1
   FLUSH_VERTICES(ctx, 0);
d1008 1
a1008 1
   FLUSH_VERTICES(ctx, 0);
d1028 1
a1028 1
   FLUSH_VERTICES(ctx, 0);
d1049 2
a1050 1
   if (!ctx->Extensions.NV_primitive_restart && ctx->Version < 31) {
d1055 1
a1055 38
   if (ctx->Array.RestartIndex != index) {
      FLUSH_VERTICES(ctx, _NEW_TRANSFORM);
      ctx->Array.RestartIndex = index;
   }
}


/**
 * See GL_ARB_instanced_arrays.
 * Note that the instance divisor only applies to generic arrays, not
 * the legacy vertex arrays.
 */
void GLAPIENTRY
_mesa_VertexAttribDivisor(GLuint index, GLuint divisor)
{
   struct gl_client_array *array;
   GET_CURRENT_CONTEXT(ctx);

   if (!ctx->Extensions.ARB_instanced_arrays) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glVertexAttribDivisor()");
      return;
   }

   if (index >= ctx->Const.VertexProgram.MaxAttribs) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glVertexAttribDivisor(index = %u)",
                  index);
      return;
   }

   ASSERT(VERT_ATTRIB_GENERIC(index) < Elements(ctx->Array.ArrayObj->VertexAttrib));

   array = &ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_GENERIC(index)];
   if (array->InstanceDivisor != divisor) {
      FLUSH_VERTICES(ctx, _NEW_ARRAY);
      array->InstanceDivisor = divisor;
   }
}

d1057 1
a1057 20
unsigned
_mesa_primitive_restart_index(const struct gl_context *ctx, GLenum ib_type)
{
   /* From the OpenGL 4.3 core specification, page 302:
    * "If both PRIMITIVE_RESTART and PRIMITIVE_RESTART_FIXED_INDEX are
    *  enabled, the index value determined by PRIMITIVE_RESTART_FIXED_INDEX
    *  is used."
    */
   if (ctx->Array.PrimitiveRestartFixedIndex) {
      switch (ib_type) {
      case GL_UNSIGNED_BYTE:
         return 0xff;
      case GL_UNSIGNED_SHORT:
         return 0xffff;
      case GL_UNSIGNED_INT:
         return 0xffffffff;
      default:
         assert(!"_mesa_primitive_restart_index: Invalid index buffer type.");
      }
   }
d1059 1
a1059 1
   return ctx->Array.RestartIndex;
a1079 1
   dst->InstanceDivisor = src->InstanceDivisor;
d1117 12
a1128 12
   if (arrayObj->VertexAttrib[VERT_ATTRIB_POS].Enabled)
      print_array("Vertex", -1, &arrayObj->VertexAttrib[VERT_ATTRIB_POS]);
   if (arrayObj->VertexAttrib[VERT_ATTRIB_NORMAL].Enabled)
      print_array("Normal", -1, &arrayObj->VertexAttrib[VERT_ATTRIB_NORMAL]);
   if (arrayObj->VertexAttrib[VERT_ATTRIB_COLOR0].Enabled)
      print_array("Color", -1, &arrayObj->VertexAttrib[VERT_ATTRIB_COLOR0]);
   for (i = 0; i < ctx->Const.MaxTextureCoordUnits; i++)
      if (arrayObj->VertexAttrib[VERT_ATTRIB_TEX(i)].Enabled)
         print_array("TexCoord", i, &arrayObj->VertexAttrib[VERT_ATTRIB_TEX(i)]);
   for (i = 0; i < VERT_ATTRIB_GENERIC_MAX; i++)
      if (arrayObj->VertexAttrib[VERT_ATTRIB_GENERIC(i)].Enabled)
         print_array("Attrib", i, &arrayObj->VertexAttrib[VERT_ATTRIB_GENERIC(i)]);
d1139 1
a1139 1
   ctx->Array.DefaultArrayObj = ctx->Driver.NewArrayObject(ctx, 0);
@


1.1.1.5
log
@Import Mesa 10.2.3
@
text
@a62 1
#define UNSIGNED_INT_10F_11F_11F_REV_BIT 0x4000
a98 2
   case GL_UNSIGNED_INT_10F_11F_11F_REV:
      return UNSIGNED_INT_10F_11F_11F_REV_BIT;
d106 14
a119 1
 * Sets the VertexBinding field in the vertex attribute given by attribIndex.
d122 7
a128 2
vertex_attrib_binding(struct gl_context *ctx, GLuint attribIndex,
                      GLuint bindingIndex)
d130 4
a133 2
   struct gl_vertex_array_object *vao = ctx->Array.VAO;
   struct gl_vertex_attrib_array *array = &vao->VertexAttrib[attribIndex];
d135 15
a149 11
   if (array->VertexBinding != bindingIndex) {
      const GLbitfield64 array_bit = VERT_BIT(attribIndex);

      FLUSH_VERTICES(ctx, _NEW_ARRAY);

      vao->VertexBinding[array->VertexBinding]._BoundArrays &= ~array_bit;
      vao->VertexBinding[bindingIndex]._BoundArrays |= array_bit;

      array->VertexBinding = bindingIndex;

      vao->NewArrays |= array_bit;
a150 80
}


/**
 * Binds a buffer object to the vertex buffer binding point given by index,
 * and sets the Offset and Stride fields.
 */
static void
bind_vertex_buffer(struct gl_context *ctx, GLuint index,
                   struct gl_buffer_object *vbo,
                   GLintptr offset, GLsizei stride)
{
   struct gl_vertex_array_object *vao = ctx->Array.VAO;
   struct gl_vertex_buffer_binding *binding = &vao->VertexBinding[index];

   if (binding->BufferObj != vbo ||
       binding->Offset != offset ||
       binding->Stride != stride) {

      FLUSH_VERTICES(ctx, _NEW_ARRAY);

      _mesa_reference_buffer_object(ctx, &binding->BufferObj, vbo);

      binding->Offset = offset;
      binding->Stride = stride;

      vao->NewArrays |= binding->_BoundArrays;
   }
}


/**
 * Sets the InstanceDivisor field in the vertex buffer binding point
 * given by bindingIndex.
 */
static void
vertex_binding_divisor(struct gl_context *ctx, GLuint bindingIndex,
                       GLuint divisor)
{
   struct gl_vertex_array_object *vao = ctx->Array.VAO;
   struct gl_vertex_buffer_binding *binding =
      &vao->VertexBinding[bindingIndex];

   if (binding->InstanceDivisor != divisor) {
      FLUSH_VERTICES(ctx, _NEW_ARRAY);
      binding->InstanceDivisor = divisor;
      vao->NewArrays |= binding->_BoundArrays;
   }
}


/**
 * Does error checking and updates the format in an attrib array.
 *
 * Called by update_array() and VertexAttrib*Format().
 *
 * \param func         Name of calling function used for error reporting
 * \param attrib       The index of the attribute array
 * \param legalTypes   Bitmask of *_BIT above indicating legal datatypes
 * \param sizeMin      Min allowable size value
 * \param sizeMax      Max allowable size value (may also be BGRA_OR_4)
 * \param size         Components per element (1, 2, 3 or 4)
 * \param type         Datatype of each component (GL_FLOAT, GL_INT, etc)
 * \param normalized   Whether integer types are converted to floats in [-1, 1]
 * \param integer      Integer-valued values (will not be normalized to [-1, 1])
 * \param relativeOffset Offset of the first element relative to the binding offset.
 */
static bool
update_array_format(struct gl_context *ctx,
                    const char *func,
                    GLuint attrib, GLbitfield legalTypesMask,
                    GLint sizeMin, GLint sizeMax,
                    GLint size, GLenum type,
                    GLboolean normalized, GLboolean integer,
                    GLuint relativeOffset)
{
   struct gl_vertex_attrib_array *array;
   GLbitfield typeBit;
   GLuint elementSize;
   GLenum format = GL_RGBA;
d153 1
a153 1
      legalTypesMask &= ~(FIXED_GL_BIT | DOUBLE_BIT | UNSIGNED_INT_10F_11F_11F_REV_BIT);
a182 3

      if (!ctx->Extensions.ARB_vertex_type_10f_11f_11f_rev)
         legalTypesMask &= ~UNSIGNED_INT_10F_11F_11F_REV_BIT;
d189 1
a189 1
      return false;
d199 1
a199 11
      /* Page 298 of the PDF of the OpenGL 4.3 (Core Profile) spec says:
       *
       * "An INVALID_OPERATION error is generated under any of the following
       *  conditions:
       *    ...
       *    • size is BGRA and type is not UNSIGNED_BYTE, INT_2_10_10_10_REV
       *      or UNSIGNED_INT_2_10_10_10_REV;
       *    ...
       *    • size is BGRA and normalized is FALSE;"
       */
      bool bgra_error = false;
d205 1
a205 1
            bgra_error = true;
d207 1
a207 1
         bgra_error = true;
d210 2
a211 9
         _mesa_error(ctx, GL_INVALID_OPERATION, "%s(size=GL_BGRA and type=%s)",
                     func, _mesa_lookup_enum_by_nr(type));
         return false;
      }

      if (!normalized) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "%s(size=GL_BGRA and normalized=GL_FALSE)", func);
         return false;
a212 1

d218 1
a218 1
      return false;
d225 1
a225 20
      return false;
   }

   /* The ARB_vertex_attrib_binding_spec says:
    *
    *   An INVALID_VALUE error is generated if <relativeoffset> is larger than
    *   the value of MAX_VERTEX_ATTRIB_RELATIVE_OFFSET.
    */
   if (relativeOffset > ctx->Const.MaxVertexAttribRelativeOffset) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "%s(relativeOffset=%d > "
                  "GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET)",
                  func, relativeOffset);
      return false;
   }

   if (ctx->Extensions.ARB_vertex_type_10f_11f_11f_rev &&
         type == GL_UNSIGNED_INT_10F_11F_11F_REV && size != 3) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "%s(size=%d)", func, size);
      return false;
a229 64
   elementSize = _mesa_bytes_per_vertex_attrib(size, type);
   assert(elementSize != -1);

   array = &ctx->Array.VAO->VertexAttrib[attrib];
   array->Size = size;
   array->Type = type;
   array->Format = format;
   array->Normalized = normalized;
   array->Integer = integer;
   array->RelativeOffset = relativeOffset;
   array->_ElementSize = elementSize;

   ctx->Array.VAO->NewArrays |= VERT_BIT(attrib);
   ctx->NewState |= _NEW_ARRAY;

   return true;
}


/**
 * Do error checking and update state for glVertex/Color/TexCoord/...Pointer
 * functions.
 *
 * \param func  name of calling function used for error reporting
 * \param attrib  the attribute array index to update
 * \param legalTypes  bitmask of *_BIT above indicating legal datatypes
 * \param sizeMin  min allowable size value
 * \param sizeMax  max allowable size value (may also be BGRA_OR_4)
 * \param size  components per element (1, 2, 3 or 4)
 * \param type  datatype of each component (GL_FLOAT, GL_INT, etc)
 * \param stride  stride between elements, in elements
 * \param normalized  are integer types converted to floats in [-1, 1]?
 * \param integer  integer-valued values (will not be normalized to [-1,1])
 * \param ptr  the address (or offset inside VBO) of the array data
 */
static void
update_array(struct gl_context *ctx,
             const char *func,
             GLuint attrib, GLbitfield legalTypesMask,
             GLint sizeMin, GLint sizeMax,
             GLint size, GLenum type, GLsizei stride,
             GLboolean normalized, GLboolean integer,
             const GLvoid *ptr)
{
   struct gl_vertex_attrib_array *array;
   GLsizei effectiveStride;

   /* Page 407 (page 423 of the PDF) of the OpenGL 3.0 spec says:
    *
    *     "Client vertex arrays - all vertex array attribute pointers must
    *     refer to buffer objects (section 2.9.2). The default vertex array
    *     object (the name zero) is also deprecated. Calling
    *     VertexAttribPointer when no buffer object or no vertex array object
    *     is bound will generate an INVALID_OPERATION error..."
    *
    * The check for VBOs is handled below.
    */
   if (ctx->API == API_OPENGL_CORE
       && (ctx->Array.VAO == ctx->Array.DefaultVAO)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "%s(no array object bound)",
                  func);
      return;
   }

d247 1
a247 1
   if (ptr != NULL && ctx->Array.VAO->ARBsemantics &&
d253 2
a254 4
   if (!update_array_format(ctx, func, attrib, legalTypesMask, sizeMin,
                            sizeMax, size, type, normalized, integer, 0)) {
      return;
   }
d256 10
a265 2
   /* Reset the vertex attrib binding */
   vertex_attrib_binding(ctx, attrib, attrib);
d267 2
a268 4
   /* The Stride and Ptr fields are not set by update_array_format() */
   array = &ctx->Array.VAO->VertexAttrib[attrib];
   array->Stride = stride;
   array->Ptr = (const GLvoid *) ptr;
d270 1
a270 4
   /* Update the vertex buffer binding */
   effectiveStride = stride != 0 ? stride : array->_ElementSize;
   bind_vertex_buffer(ctx, attrib, ctx->Array.ArrayBufferObj,
                      (GLintptr) ptr, effectiveStride);
d410 2
a411 2
   /* this is the same type that glEdgeFlag uses */
   const GLboolean integer = GL_FALSE;
d458 1
a458 2
                                  INT_2_10_10_10_REV_BIT |
                                  UNSIGNED_INT_10F_11F_11F_REV_BIT);
d461 1
a461 1
   if (index >= ctx->Const.Program[MESA_SHADER_VERTEX].MaxAttribs) {
d489 1
a489 1
   if (index >= ctx->Const.Program[MESA_SHADER_VERTEX].MaxAttribs) {
d504 1
a504 1
   struct gl_vertex_array_object *vao;
d507 1
a507 1
   if (index >= ctx->Const.Program[MESA_SHADER_VERTEX].MaxAttribs) {
d513 1
a513 1
   vao = ctx->Array.VAO;
d515 1
a515 1
   ASSERT(VERT_ATTRIB_GENERIC(index) < Elements(vao->_VertexAttrib));
d517 1
a517 1
   if (!vao->VertexAttrib[VERT_ATTRIB_GENERIC(index)].Enabled) {
d520 2
a521 3
      vao->VertexAttrib[VERT_ATTRIB_GENERIC(index)].Enabled = GL_TRUE;
      vao->_Enabled |= VERT_BIT_GENERIC(index);
      vao->NewArrays |= VERT_BIT_GENERIC(index);
d529 1
a529 1
   struct gl_vertex_array_object *vao;
d532 1
a532 1
   if (index >= ctx->Const.Program[MESA_SHADER_VERTEX].MaxAttribs) {
d538 1
a538 1
   vao = ctx->Array.VAO;
d540 1
a540 1
   ASSERT(VERT_ATTRIB_GENERIC(index) < Elements(vao->_VertexAttrib));
d542 1
a542 1
   if (vao->VertexAttrib[VERT_ATTRIB_GENERIC(index)].Enabled) {
d545 2
a546 3
      vao->VertexAttrib[VERT_ATTRIB_GENERIC(index)].Enabled = GL_FALSE;
      vao->_Enabled &= ~VERT_BIT_GENERIC(index);
      vao->NewArrays |= VERT_BIT_GENERIC(index);
d560 1
a560 2
   const struct gl_vertex_array_object *vao = ctx->Array.VAO;
   const struct gl_vertex_attrib_array *array;
d562 1
a562 1
   if (index >= ctx->Const.Program[MESA_SHADER_VERTEX].MaxAttribs) {
d567 1
a567 1
   ASSERT(VERT_ATTRIB_GENERIC(index) < Elements(vao->VertexAttrib));
d569 1
a569 1
   array = &vao->VertexAttrib[VERT_ATTRIB_GENERIC(index)];
d575 1
a575 1
      return (array->Format == GL_BGRA) ? GL_BGRA : array->Size;
d583 1
a583 1
      return vao->VertexBinding[array->VertexBinding].BufferObj->Name;
d594 1
a594 11
         return vao->VertexBinding[array->VertexBinding].InstanceDivisor;
      }
      goto error;
   case GL_VERTEX_ATTRIB_BINDING:
      if (_mesa_is_desktop_gl(ctx)) {
         return array->VertexBinding - VERT_ATTRIB_GENERIC0;
      }
      goto error;
   case GL_VERTEX_ATTRIB_RELATIVE_OFFSET:
      if (_mesa_is_desktop_gl(ctx)) {
         return array->RelativeOffset;
d611 7
a617 1
      if (_mesa_attr_zero_aliases_vertex(ctx)) {
d622 1
a622 1
   else if (index >= ctx->Const.Program[MESA_SHADER_VERTEX].MaxAttribs) {
d628 1
a628 1
   ASSERT(VERT_ATTRIB_GENERIC(index) < Elements(ctx->Array.VAO->_VertexAttrib));
d740 1
a740 1
   if (index >= ctx->Const.Program[MESA_SHADER_VERTEX].MaxAttribs) {
d750 1
a750 1
   ASSERT(VERT_ATTRIB_GENERIC(index) < Elements(ctx->Array.VAO->_VertexAttrib));
d752 1
a752 1
   *pointer = (GLvoid *) ctx->Array.VAO->VertexAttrib[VERT_ATTRIB_GENERIC(index)].Ptr;
d1050 1
a1050 1
         CALL_DrawArrays(ctx->CurrentDispatch, (mode, first[i], count[i]));
d1070 1
a1070 1
	 CALL_DrawArrays(ctx->CurrentDispatch, ( m, first[i], count[i] ));
d1092 1
a1092 2
	 CALL_DrawElements(ctx->CurrentDispatch, ( m, count[i], type,
                                                   indices[i] ));
d1126 1
a1128 2
   const GLuint genericIndex = VERT_ATTRIB_GENERIC(index);

d1134 1
a1134 1
   if (index >= ctx->Const.Program[MESA_SHADER_VERTEX].MaxAttribs) {
d1140 1
a1140 1
   ASSERT(genericIndex < Elements(ctx->Array.VAO->VertexAttrib));
d1142 5
a1146 13
   /* The ARB_vertex_attrib_binding spec says:
    *
    *    "The command
    *
    *       void VertexAttribDivisor(uint index, uint divisor);
    *
    *     is equivalent to (assuming no errors are generated):
    *
    *       VertexAttribBinding(index, index);
    *       VertexBindingDivisor(index, divisor);"
    */
   vertex_attrib_binding(ctx, genericIndex, genericIndex);
   vertex_binding_divisor(ctx, genericIndex, divisor);
a1175 443
 * GL_ARB_vertex_attrib_binding
 */
void GLAPIENTRY
_mesa_BindVertexBuffer(GLuint bindingIndex, GLuint buffer, GLintptr offset,
                       GLsizei stride)
{
   GET_CURRENT_CONTEXT(ctx);
   const struct gl_vertex_array_object *vao = ctx->Array.VAO;
   struct gl_buffer_object *vbo;

   ASSERT_OUTSIDE_BEGIN_END(ctx);

   /* The ARB_vertex_attrib_binding spec says:
    *
    *    "An INVALID_OPERATION error is generated if no vertex array object
    *     is bound."
    */
   if (ctx->API == API_OPENGL_CORE &&
       ctx->Array.VAO == ctx->Array.DefaultVAO) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glBindVertexBuffer(No array object bound)");
      return;
   }

   /* The ARB_vertex_attrib_binding spec says:
    *
    *    "An INVALID_VALUE error is generated if <bindingindex> is greater than
    *     the value of MAX_VERTEX_ATTRIB_BINDINGS."
    */
   if (bindingIndex >= ctx->Const.MaxVertexAttribBindings) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glBindVertexBuffer(bindingindex=%u > "
                  "GL_MAX_VERTEX_ATTRIB_BINDINGS)",
                  bindingIndex);
      return;
   }

   /* The ARB_vertex_attrib_binding spec says:
    *
    *    "The error INVALID_VALUE is generated if <stride> or <offset>
    *     are negative."
    */
   if (offset < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glBindVertexBuffer(offset=%lld < 0)", (long long)offset);
      return;
   }

   if (stride < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glBindVertexBuffer(stride=%d < 0)", stride);
      return;
   }

   if (buffer == vao->VertexBinding[VERT_ATTRIB_GENERIC(bindingIndex)].BufferObj->Name) {
      vbo = vao->VertexBinding[VERT_ATTRIB_GENERIC(bindingIndex)].BufferObj;
   } else if (buffer != 0) {
      vbo = _mesa_lookup_bufferobj(ctx, buffer);

      /* From the GL_ARB_vertex_attrib_array spec:
       *
       *   "[Core profile only:]
       *    An INVALID_OPERATION error is generated if buffer is not zero or a
       *    name returned from a previous call to GenBuffers, or if such a name
       *    has since been deleted with DeleteBuffers.
       *
       * Otherwise, we fall back to the same compat profile behavior as other
       * object references (automatically gen it).
       */
      if (!_mesa_handle_bind_buffer_gen(ctx, GL_ARRAY_BUFFER, buffer,
                                        &vbo, "glBindVertexBuffer"))
         return;
   } else {
      /* The ARB_vertex_attrib_binding spec says:
       *
       *    "If <buffer> is zero, any buffer object attached to this
       *     bindpoint is detached."
       */
      vbo = ctx->Shared->NullBufferObj;
   }

   bind_vertex_buffer(ctx, VERT_ATTRIB_GENERIC(bindingIndex),
                      vbo, offset, stride);
}


void GLAPIENTRY
_mesa_BindVertexBuffers(GLuint first, GLsizei count, const GLuint *buffers,
                        const GLintptr *offsets, const GLsizei *strides)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_vertex_array_object * const vao = ctx->Array.VAO;
   GLuint i;

   ASSERT_OUTSIDE_BEGIN_END(ctx);

   /* The ARB_vertex_attrib_binding spec says:
    *
    *    "An INVALID_OPERATION error is generated if no
    *     vertex array object is bound."
    */
   if (ctx->API == API_OPENGL_CORE &&
       ctx->Array.VAO == ctx->Array.DefaultVAO) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glBindVertexBuffers(No array object bound)");
      return;
   }

   /* The ARB_multi_bind spec says:
    *
    *    "An INVALID_OPERATION error is generated if <first> + <count>
    *     is greater than the value of MAX_VERTEX_ATTRIB_BINDINGS."
    */
   if (first + count > ctx->Const.MaxVertexAttribBindings) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glBindVertexBuffers(first=%u + count=%d > the value of "
                  "GL_MAX_VERTEX_ATTRIB_BINDINGS=%u)",
                  first, count, ctx->Const.MaxVertexAttribBindings);
      return;
   }

   if (!buffers) {
      /**
       * The ARB_multi_bind spec says:
       *
       *    "If <buffers> is NULL, each affected vertex buffer binding point
       *     from <first> through <first>+<count>-1 will be reset to have no
       *     bound buffer object.  In this case, the offsets and strides
       *     associated with the binding points are set to default values,
       *     ignoring <offsets> and <strides>."
       */
      struct gl_buffer_object *vbo = ctx->Shared->NullBufferObj;

      for (i = 0; i < count; i++)
         bind_vertex_buffer(ctx, VERT_ATTRIB_GENERIC(first + i), vbo, 0, 16);

      return;
   }

   /* Note that the error semantics for multi-bind commands differ from
    * those of other GL commands.
    *
    * The Issues section in the ARB_multi_bind spec says:
    *
    *    "(11) Typically, OpenGL specifies that if an error is generated by
    *          a command, that command has no effect.  This is somewhat
    *          unfortunate for multi-bind commands, because it would require
    *          a first pass to scan the entire list of bound objects for
    *          errors and then a second pass to actually perform the
    *          bindings.  Should we have different error semantics?
    *
    *       RESOLVED:  Yes.  In this specification, when the parameters for
    *       one of the <count> binding points are invalid, that binding
    *       point is not updated and an error will be generated.  However,
    *       other binding points in the same command will be updated if
    *       their parameters are valid and no other error occurs."
    */

   _mesa_begin_bufferobj_lookups(ctx);

   for (i = 0; i < count; i++) {
      struct gl_buffer_object *vbo;

      /* The ARB_multi_bind spec says:
       *
       *    "An INVALID_VALUE error is generated if any value in
       *     <offsets> or <strides> is negative (per binding)."
       */
      if (offsets[i] < 0) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glBindVertexBuffer(offsets[%u]=%lldd < 0)",
                     i, (long long int) offsets[i]);
         continue;
      }

      if (strides[i] < 0) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glBindVertexBuffer(strides[%u]=%lld < 0)",
                     i, (long long int) strides[i]);
         continue;
      }

      if (buffers[i]) {
         struct gl_vertex_buffer_binding *binding =
            &vao->VertexBinding[VERT_ATTRIB_GENERIC(first + i)];

         if (buffers[i] == binding->BufferObj->Name)
            vbo = binding->BufferObj;
         else
            vbo = _mesa_multi_bind_lookup_bufferobj(ctx, buffers, i,
                                                    "glBindVertexBuffers");

         if (!vbo)
            continue;
      } else {
         vbo = ctx->Shared->NullBufferObj;
      }

      bind_vertex_buffer(ctx, VERT_ATTRIB_GENERIC(first + i), vbo,
                         offsets[i], strides[i]);
   }

   _mesa_end_bufferobj_lookups(ctx);
}


void GLAPIENTRY
_mesa_VertexAttribFormat(GLuint attribIndex, GLint size, GLenum type,
                         GLboolean normalized, GLuint relativeOffset)
{
    const GLbitfield legalTypes = (BYTE_BIT | UNSIGNED_BYTE_BIT |
                                   SHORT_BIT | UNSIGNED_SHORT_BIT |
                                   INT_BIT | UNSIGNED_INT_BIT |
                                   HALF_BIT | FLOAT_BIT | DOUBLE_BIT |
                                   FIXED_GL_BIT |
                                   UNSIGNED_INT_2_10_10_10_REV_BIT |
                                   INT_2_10_10_10_REV_BIT |
                                   UNSIGNED_INT_10F_11F_11F_REV_BIT);

   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   /* The ARB_vertex_attrib_binding spec says:
    *
    *    "An INVALID_OPERATION error is generated under any of the following
    *     conditions:
    *     - if no vertex array object is currently bound (see section 2.10);
    *     - ..."
    */
   if (ctx->API == API_OPENGL_CORE &&
       ctx->Array.VAO == ctx->Array.DefaultVAO) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glVertexAttribFormat(No array object bound)");
      return;
   }

   /* The ARB_vertex_attrib_binding spec says:
    *
    *   "The error INVALID_VALUE is generated if index is greater than or equal
    *     to the value of MAX_VERTEX_ATTRIBS."
    */
   if (attribIndex >= ctx->Const.Program[MESA_SHADER_VERTEX].MaxAttribs) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glVertexAttribFormat(attribindex=%u > "
                  "GL_MAX_VERTEX_ATTRIBS)",
                  attribIndex);
      return;
   }

   FLUSH_VERTICES(ctx, 0);

   update_array_format(ctx, "glVertexAttribFormat",
                       VERT_ATTRIB_GENERIC(attribIndex),
                       legalTypes, 1, BGRA_OR_4, size, type, normalized,
                       GL_FALSE, relativeOffset);
}


void GLAPIENTRY
_mesa_VertexAttribIFormat(GLuint attribIndex, GLint size, GLenum type,
                          GLuint relativeOffset)
{
   const GLbitfield legalTypes = (BYTE_BIT | UNSIGNED_BYTE_BIT |
                                  SHORT_BIT | UNSIGNED_SHORT_BIT |
                                  INT_BIT | UNSIGNED_INT_BIT);

   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   /* The ARB_vertex_attrib_binding spec says:
    *
    *    "An INVALID_OPERATION error is generated under any of the following
    *     conditions:
    *     - if no vertex array object is currently bound (see section 2.10);
    *     - ..."
    */
   if (ctx->API == API_OPENGL_CORE &&
       ctx->Array.VAO == ctx->Array.DefaultVAO) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glVertexAttribIFormat(No array object bound)");
      return;
   }

   /* The ARB_vertex_attrib_binding spec says:
    *
    *   "The error INVALID_VALUE is generated if index is greater than
    *    or equal to the value of MAX_VERTEX_ATTRIBS."
    */
   if (attribIndex >= ctx->Const.Program[MESA_SHADER_VERTEX].MaxAttribs) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glVertexAttribIFormat(attribindex=%u > "
                  "GL_MAX_VERTEX_ATTRIBS)",
                  attribIndex);
      return;
   }

   FLUSH_VERTICES(ctx, 0);

   update_array_format(ctx, "glVertexAttribIFormat",
                       VERT_ATTRIB_GENERIC(attribIndex),
                       legalTypes, 1, 4, size, type, GL_FALSE, GL_TRUE,
                       relativeOffset);
}


void GLAPIENTRY
_mesa_VertexAttribLFormat(GLuint attribIndex, GLint size, GLenum type,
                          GLuint relativeOffset)
{
   const GLbitfield legalTypes = DOUBLE_BIT;

   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   /* Page 298 of the PDF of the OpenGL 4.3 (Core Profile) spec says:
    *
    *    "An INVALID_OPERATION error is generated under any of the following
    *     conditions:
    *     • if no vertex array object is currently bound (see section 10.4);
    *     • ..."
    *
    * This language is missing from the extension spec, but we assume
    * that this is an oversight.
    */
   if (ctx->API == API_OPENGL_CORE &&
       ctx->Array.VAO == ctx->Array.DefaultVAO) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glVertexAttribLFormat(No array object bound)");
      return;
   }

   /* The ARB_vertex_attrib_binding spec says:
    *
    *   "The error INVALID_VALUE is generated if <attribindex> is greater than
    *    or equal to the value of MAX_VERTEX_ATTRIBS."
    */
   if (attribIndex >= ctx->Const.Program[MESA_SHADER_VERTEX].MaxAttribs) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glVertexAttribLFormat(attribindex=%u > "
                  "GL_MAX_VERTEX_ATTRIBS)",
                  attribIndex);
      return;
   }

   FLUSH_VERTICES(ctx, 0);

   update_array_format(ctx, "glVertexAttribLFormat",
                       VERT_ATTRIB_GENERIC(attribIndex),
                       legalTypes, 1, 4, size, type, GL_FALSE, GL_FALSE,
                       relativeOffset);
}


void GLAPIENTRY
_mesa_VertexAttribBinding(GLuint attribIndex, GLuint bindingIndex)
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   /* The ARB_vertex_attrib_binding spec says:
    *
    *    "An INVALID_OPERATION error is generated if no vertex array object
    *     is bound."
    */
   if (ctx->API == API_OPENGL_CORE &&
       ctx->Array.VAO == ctx->Array.DefaultVAO) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glVertexAttribBinding(No array object bound)");
      return;
   }

   /* The ARB_vertex_attrib_binding spec says:
    *
    *    "<attribindex> must be less than the value of MAX_VERTEX_ATTRIBS and
    *     <bindingindex> must be less than the value of
    *     MAX_VERTEX_ATTRIB_BINDINGS, otherwise the error INVALID_VALUE
    *     is generated."
    */
   if (attribIndex >= ctx->Const.Program[MESA_SHADER_VERTEX].MaxAttribs) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glVertexAttribBinding(attribindex=%u >= "
                  "GL_MAX_VERTEX_ATTRIBS)",
                  attribIndex);
      return;
   }

   if (bindingIndex >= ctx->Const.MaxVertexAttribBindings) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glVertexAttribBinding(bindingindex=%u >= "
                  "GL_MAX_VERTEX_ATTRIB_BINDINGS)",
                  bindingIndex);
      return;
   }

   ASSERT(VERT_ATTRIB_GENERIC(attribIndex) <
          Elements(ctx->Array.VAO->VertexAttrib));

   vertex_attrib_binding(ctx, VERT_ATTRIB_GENERIC(attribIndex),
                         VERT_ATTRIB_GENERIC(bindingIndex));
}


void GLAPIENTRY
_mesa_VertexBindingDivisor(GLuint bindingIndex, GLuint divisor)
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   if (!ctx->Extensions.ARB_instanced_arrays) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glVertexBindingDivisor()");
      return;
   }

   /* The ARB_vertex_attrib_binding spec says:
    *
    *    "An INVALID_OPERATION error is generated if no vertex array object
    *     is bound."
    */
   if (ctx->API == API_OPENGL_CORE &&
       ctx->Array.VAO == ctx->Array.DefaultVAO) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glVertexBindingDivisor(No array object bound)");
      return;
   }

   /* The ARB_vertex_attrib_binding spec says:
    *
    *    "An INVALID_VALUE error is generated if <bindingindex> is greater
    *     than or equal to the value of MAX_VERTEX_ATTRIB_BINDINGS."
    */
   if (bindingIndex >= ctx->Const.MaxVertexAttribBindings) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glVertexBindingDivisor(bindingindex=%u > "
                  "GL_MAX_VERTEX_ATTRIB_BINDINGS)",
                  bindingIndex);
      return;
   }

   vertex_binding_divisor(ctx, VERT_ATTRIB_GENERIC(bindingIndex), divisor);
}


/**
a1197 27
void
_mesa_copy_vertex_attrib_array(struct gl_context *ctx,
                               struct gl_vertex_attrib_array *dst,
                               const struct gl_vertex_attrib_array *src)
{
   dst->Size           = src->Size;
   dst->Type           = src->Type;
   dst->Format         = src->Format;
   dst->VertexBinding  = src->VertexBinding;
   dst->RelativeOffset = src->RelativeOffset;
   dst->Format         = src->Format;
   dst->Integer        = src->Integer;
   dst->Normalized     = src->Normalized;
   dst->Ptr            = src->Ptr;
   dst->Enabled        = src->Enabled;
   dst->_ElementSize   = src->_ElementSize;
}

void
_mesa_copy_vertex_buffer_binding(struct gl_context *ctx,
                                 struct gl_vertex_buffer_binding *dst,
                                 const struct gl_vertex_buffer_binding *src)
{
   dst->Offset          = src->Offset;
   dst->Stride          = src->Stride;
   dst->InstanceDivisor = src->InstanceDivisor;
   dst->_BoundArrays    = src->_BoundArrays;
a1198 2
   _mesa_reference_buffer_object(ctx, &dst->BufferObj, src->BufferObj);
}
d1224 1
a1224 1
   struct gl_vertex_array_object *vao = ctx->Array.VAO;
d1227 1
a1227 1
   _mesa_update_vao_max_element(ctx, vao);
d1229 7
a1235 7
   printf("Array Object %u\n", vao->Name);
   if (vao->_VertexAttrib[VERT_ATTRIB_POS].Enabled)
      print_array("Vertex", -1, &vao->_VertexAttrib[VERT_ATTRIB_POS]);
   if (vao->_VertexAttrib[VERT_ATTRIB_NORMAL].Enabled)
      print_array("Normal", -1, &vao->_VertexAttrib[VERT_ATTRIB_NORMAL]);
   if (vao->_VertexAttrib[VERT_ATTRIB_COLOR0].Enabled)
      print_array("Color", -1, &vao->_VertexAttrib[VERT_ATTRIB_COLOR0]);
d1237 2
a1238 2
      if (vao->_VertexAttrib[VERT_ATTRIB_TEX(i)].Enabled)
         print_array("TexCoord", i, &vao->_VertexAttrib[VERT_ATTRIB_TEX(i)]);
d1240 3
a1242 3
      if (vao->_VertexAttrib[VERT_ATTRIB_GENERIC(i)].Enabled)
         print_array("Attrib", i, &vao->_VertexAttrib[VERT_ATTRIB_GENERIC(i)]);
   printf("  _MaxElement = %u\n", vao->_MaxElement);
d1252 3
a1254 2
   ctx->Array.DefaultVAO = ctx->Driver.NewArrayObject(ctx, 0);
   _mesa_reference_vao(ctx, &ctx->Array.VAO, ctx->Array.DefaultVAO);
d1267 1
a1267 1
   struct gl_vertex_array_object *vao = (struct gl_vertex_array_object *) data;
d1269 1
a1269 1
   _mesa_delete_vao(ctx, vao);
@


1.1.1.6
log
@Import Mesa 10.4.3
@
text
@a26 2
#include <inttypes.h>  /* for PRId64 macro */

d49 15
a63 16
#define BOOL_BIT                          (1 << 0)
#define BYTE_BIT                          (1 << 1)
#define UNSIGNED_BYTE_BIT                 (1 << 2)
#define SHORT_BIT                         (1 << 3)
#define UNSIGNED_SHORT_BIT                (1 << 4)
#define INT_BIT                           (1 << 5)
#define UNSIGNED_INT_BIT                  (1 << 6)
#define HALF_BIT                          (1 << 7)
#define FLOAT_BIT                         (1 << 8)
#define DOUBLE_BIT                        (1 << 9)
#define FIXED_ES_BIT                      (1 << 10)
#define FIXED_GL_BIT                      (1 << 11)
#define UNSIGNED_INT_2_10_10_10_REV_BIT   (1 << 12)
#define INT_2_10_10_10_REV_BIT            (1 << 13)
#define UNSIGNED_INT_10F_11F_11F_REV_BIT  (1 << 14)
#define ALL_TYPE_BITS                    ((1 << 15) - 1)
a181 47
 * Examine the API profile and extensions to determine which types are legal
 * for vertex arrays.  This is called once from update_array_format().
 */
static GLbitfield
get_legal_types_mask(const struct gl_context *ctx)
{
   GLbitfield legalTypesMask = ALL_TYPE_BITS;

   if (_mesa_is_gles(ctx)) {
      legalTypesMask &= ~(FIXED_GL_BIT |
                          DOUBLE_BIT |
                          UNSIGNED_INT_10F_11F_11F_REV_BIT);

      /* GL_INT and GL_UNSIGNED_INT data is not allowed in OpenGL ES until
       * 3.0.  The 2_10_10_10 types are added in OpenGL ES 3.0 or
       * GL_OES_vertex_type_10_10_10_2.  GL_HALF_FLOAT data is not allowed
       * until 3.0 or with the GL_OES_vertex_half float extension, which isn't
       * quite as trivial as we'd like because it uses a different enum value
       * for GL_HALF_FLOAT_OES.
       */
      if (ctx->Version < 30) {
         legalTypesMask &= ~(UNSIGNED_INT_BIT |
                             INT_BIT |
                             UNSIGNED_INT_2_10_10_10_REV_BIT |
                             INT_2_10_10_10_REV_BIT |
                             HALF_BIT);
      }
   }
   else {
      legalTypesMask &= ~FIXED_ES_BIT;

      if (!ctx->Extensions.ARB_ES2_compatibility)
         legalTypesMask &= ~FIXED_GL_BIT;

      if (!ctx->Extensions.ARB_vertex_type_2_10_10_10_rev)
         legalTypesMask &= ~(UNSIGNED_INT_2_10_10_10_REV_BIT |
                             INT_2_10_10_10_REV_BIT);

      if (!ctx->Extensions.ARB_vertex_type_10f_11f_11f_rev)
         legalTypesMask &= ~UNSIGNED_INT_10F_11F_11F_REV_BIT;
   }

   return legalTypesMask;
}


/**
d211 9
a219 3
   if (ctx->Array.LegalTypesMask == 0) {
      /* One-time initialization.  We can't do this in _mesa_init_varrays()
       * below because extensions are not yet enabled at that point.
d221 7
a227 4
      ctx->Array.LegalTypesMask = get_legal_types_mask(ctx);
   }

   legalTypesMask &= ctx->Array.LegalTypesMask;
a228 1
   if (_mesa_is_gles(ctx) && sizeMax == BGRA_OR_4) {
d231 14
a244 1
      sizeMax = 4;
a397 7
   if (ctx->API == API_OPENGL_CORE && ctx->Version >= 44 &&
       stride > ctx->Const.MaxVertexAttribStride) {
      _mesa_error(ctx, GL_INVALID_VALUE, "%s(stride=%d > "
                  "GL_MAX_VERTEX_ATTRIB_STRIDE)", func, stride);
      return;
   }

d678 1
a678 1
   ASSERT(VERT_ATTRIB_GENERIC(index) < Elements(vao->VertexAttrib));
d704 1
a704 1
   ASSERT(VERT_ATTRIB_GENERIC(index) < Elements(vao->VertexAttrib));
d798 1
a798 1
   ASSERT(VERT_ATTRIB_GENERIC(index) < Elements(ctx->Array.VAO->VertexAttrib));
d920 1
a920 1
   ASSERT(VERT_ATTRIB_GENERIC(index) < Elements(ctx->Array.VAO->VertexAttrib));
d1400 1
a1400 2
                  "glBindVertexBuffer(offset=%" PRId64 " < 0)",
                  (int64_t) offset);
a1409 7
   if (ctx->API == API_OPENGL_CORE && ctx->Version >= 44 &&
       stride > ctx->Const.MaxVertexAttribStride) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glBindVertexBuffer(stride=%d > "
                  "GL_MAX_VERTEX_ATTRIB_STRIDE)", stride);
      return;
   }

d1526 2
a1527 2
                     "glBindVertexBuffers(offsets[%u]=%" PRId64 " < 0)",
                     i, (int64_t) offsets[i]);
d1533 2
a1534 10
                     "glBindVertexBuffers(strides[%u]=%d < 0)",
                     i, strides[i]);
         continue;
      }

      if (ctx->API == API_OPENGL_CORE && ctx->Version >= 44 &&
          strides[i] > ctx->Const.MaxVertexAttribStride) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glBindVertexBuffers(strides[%u]=%d > "
                     "GL_MAX_VERTEX_ATTRIB_STRIDE)", i, strides[i]);
d1818 1
d1859 1
a1859 1
      fprintf(stderr, "  %s[%d]: ", name, index);
d1861 2
a1862 2
      fprintf(stderr, "  %s: ", name);
   fprintf(stderr, "Ptr=%p, Type=0x%x, Size=%d, ElemSize=%u, Stride=%d, Buffer=%u(Size %lu)\n",
d1865 2
a1866 1
	  array->BufferObj->Name, (unsigned long) array->BufferObj->Size);
d1879 2
d1894 1
@


1.1.1.7
log
@Import Mesa 10.2.9
@
text
@d27 2
d51 16
a66 15
#define BOOL_BIT             0x1
#define BYTE_BIT             0x2
#define UNSIGNED_BYTE_BIT    0x4
#define SHORT_BIT            0x8
#define UNSIGNED_SHORT_BIT   0x10
#define INT_BIT              0x20
#define UNSIGNED_INT_BIT     0x40
#define HALF_BIT             0x80
#define FLOAT_BIT            0x100
#define DOUBLE_BIT           0x200
#define FIXED_ES_BIT         0x400
#define FIXED_GL_BIT         0x800
#define UNSIGNED_INT_2_10_10_10_REV_BIT 0x1000
#define INT_2_10_10_10_REV_BIT 0x2000
#define UNSIGNED_INT_10F_11F_11F_REV_BIT 0x4000
d185 47
d261 6
a266 2
   if (_mesa_is_gles(ctx)) {
      legalTypesMask &= ~(FIXED_GL_BIT | DOUBLE_BIT | UNSIGNED_INT_10F_11F_11F_REV_BIT);
d268 1
a268 14
      /* GL_INT and GL_UNSIGNED_INT data is not allowed in OpenGL ES until
       * 3.0.  The 2_10_10_10 types are added in OpenGL ES 3.0 or
       * GL_OES_vertex_type_10_10_10_2.  GL_HALF_FLOAT data is not allowed
       * until 3.0 or with the GL_OES_vertex_half float extension, which isn't
       * quite as trivial as we'd like because it uses a different enum value
       * for GL_HALF_FLOAT_OES.
       */
      if (ctx->Version < 30) {
         legalTypesMask &= ~(UNSIGNED_INT_BIT
                             | INT_BIT
                             | UNSIGNED_INT_2_10_10_10_REV_BIT
                             | INT_2_10_10_10_REV_BIT
                             | HALF_BIT);
      }
d270 1
d273 1
a273 14
      if (sizeMax == BGRA_OR_4)
         sizeMax = 4;
   } else {
      legalTypesMask &= ~FIXED_ES_BIT;

      if (!ctx->Extensions.ARB_ES2_compatibility)
         legalTypesMask &= ~FIXED_GL_BIT;

      if (!ctx->Extensions.ARB_vertex_type_2_10_10_10_rev)
         legalTypesMask &= ~(UNSIGNED_INT_2_10_10_10_REV_BIT |
                             INT_2_10_10_10_REV_BIT);

      if (!ctx->Extensions.ARB_vertex_type_10f_11f_11f_rev)
         legalTypesMask &= ~UNSIGNED_INT_10F_11F_11F_REV_BIT;
d427 7
d714 1
a714 1
   ASSERT(VERT_ATTRIB_GENERIC(index) < Elements(vao->_VertexAttrib));
d740 1
a740 1
   ASSERT(VERT_ATTRIB_GENERIC(index) < Elements(vao->_VertexAttrib));
d834 1
a834 1
   ASSERT(VERT_ATTRIB_GENERIC(index) < Elements(ctx->Array.VAO->_VertexAttrib));
d956 1
a956 1
   ASSERT(VERT_ATTRIB_GENERIC(index) < Elements(ctx->Array.VAO->_VertexAttrib));
d1436 2
a1437 1
                  "glBindVertexBuffer(offset=%lld < 0)", (long long)offset);
d1447 7
d1570 2
a1571 2
                     "glBindVertexBuffer(offsets[%u]=%lldd < 0)",
                     i, (long long int) offsets[i]);
d1577 10
a1586 2
                     "glBindVertexBuffer(strides[%u]=%lld < 0)",
                     i, (long long int) strides[i]);
a1869 1
   dst->_MaxElement = src->_MaxElement;
d1910 1
a1910 1
      printf("  %s[%d]: ", name, index);
d1912 2
a1913 2
      printf("  %s: ", name);
   printf("Ptr=%p, Type=0x%x, Size=%d, ElemSize=%u, Stride=%d, Buffer=%u(Size %lu), MaxElem=%u\n",
d1916 1
a1916 2
	  array->BufferObj->Name, (unsigned long) array->BufferObj->Size,
	  array->_MaxElement);
a1928 2
   _mesa_update_vao_max_element(ctx, vao);

a1941 1
   printf("  _MaxElement = %u\n", vao->_MaxElement);
@


