head	1.5;
access;
symbols
	OPENBSD_5_8:1.4.0.6
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.4
	OPENBSD_5_7_BASE:1.4
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2015.12.23.05.17.53;	author jsg;	state dead;
branches;
next	1.4;
commitid	TnlogFl9nOv2eaRf;

1.4
date	2014.07.09.21.09.00;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.06.33;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.17.13.58.19;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.23.13.29.47;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.47;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.16.57;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.35.07;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.5
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 2010  VMware, Inc.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */


/*
 * Transform feedback support.
 *
 * Authors:
 *   Brian Paul
 */


#include "buffers.h"
#include "context.h"
#include "hash.h"
#include "macros.h"
#include "mtypes.h"
#include "transformfeedback.h"
#include "shaderapi.h"
#include "shaderobj.h"
#include "main/dispatch.h"

#include "program/prog_parameter.h"

struct using_program_tuple
{
   struct gl_shader_program *shProg;
   bool found;
};

static void
active_xfb_object_references_program(GLuint key, void *data, void *user_data)
{
   struct using_program_tuple *callback_data = user_data;
   struct gl_transform_feedback_object *obj = data;
   if (obj->Active && obj->shader_program == callback_data->shProg)
      callback_data->found = true;
}

/**
 * Return true if any active transform feedback object is using a program.
 */
bool
_mesa_transform_feedback_is_using_program(struct gl_context *ctx,
                                          struct gl_shader_program *shProg)
{
   struct using_program_tuple callback_data;
   callback_data.shProg = shProg;
   callback_data.found = false;

   _mesa_HashWalk(ctx->TransformFeedback.Objects,
                  active_xfb_object_references_program, &callback_data);

   /* Also check DefaultObject, as it's not in the Objects hash table. */
   active_xfb_object_references_program(0, ctx->TransformFeedback.DefaultObject,
                                        &callback_data);

   return callback_data.found;
}

/**
 * Do reference counting of transform feedback buffers.
 */
static void
reference_transform_feedback_object(struct gl_transform_feedback_object **ptr,
                                    struct gl_transform_feedback_object *obj)
{
   if (*ptr == obj)
      return;

   if (*ptr) {
      /* Unreference the old object */
      struct gl_transform_feedback_object *oldObj = *ptr;

      ASSERT(oldObj->RefCount > 0);
      oldObj->RefCount--;

      if (oldObj->RefCount == 0) {
         GET_CURRENT_CONTEXT(ctx);
         if (ctx)
            ctx->Driver.DeleteTransformFeedback(ctx, oldObj);
      }

      *ptr = NULL;
   }
   ASSERT(!*ptr);

   if (obj) {
      /* reference new object */
      if (obj->RefCount == 0) {
         _mesa_problem(NULL, "referencing deleted transform feedback object");
         *ptr = NULL;
      }
      else {
         obj->RefCount++;
         obj->EverBound = GL_TRUE;
         *ptr = obj;
      }
   }
}


/**
 * Check that all the buffer objects currently bound for transform
 * feedback actually exist.  Raise a GL_INVALID_OPERATION error if
 * any buffers are missing.
 * \return GL_TRUE for success, GL_FALSE if error
 */
GLboolean
_mesa_validate_transform_feedback_buffers(struct gl_context *ctx)
{
   /* XXX to do */
   return GL_TRUE;
}



/**
 * Per-context init for transform feedback.
 */
void
_mesa_init_transform_feedback(struct gl_context *ctx)
{
   /* core mesa expects this, even a dummy one, to be available */
   ASSERT(ctx->Driver.NewTransformFeedback);

   ctx->TransformFeedback.DefaultObject =
      ctx->Driver.NewTransformFeedback(ctx, 0);

   assert(ctx->TransformFeedback.DefaultObject->RefCount == 1);

   reference_transform_feedback_object(&ctx->TransformFeedback.CurrentObject,
                                       ctx->TransformFeedback.DefaultObject);

   assert(ctx->TransformFeedback.DefaultObject->RefCount == 2);

   ctx->TransformFeedback.Objects = _mesa_NewHashTable();

   _mesa_reference_buffer_object(ctx,
                                 &ctx->TransformFeedback.CurrentBuffer,
                                 ctx->Shared->NullBufferObj);
}



/**
 * Callback for _mesa_HashDeleteAll().
 */
static void
delete_cb(GLuint key, void *data, void *userData)
{
   struct gl_context *ctx = (struct gl_context *) userData;
   struct gl_transform_feedback_object *obj =
      (struct gl_transform_feedback_object *) data;

   ctx->Driver.DeleteTransformFeedback(ctx, obj);
}


/**
 * Per-context free/clean-up for transform feedback.
 */
void
_mesa_free_transform_feedback(struct gl_context *ctx)
{
   /* core mesa expects this, even a dummy one, to be available */
   ASSERT(ctx->Driver.NewTransformFeedback);

   _mesa_reference_buffer_object(ctx,
                                 &ctx->TransformFeedback.CurrentBuffer,
                                 NULL);

   /* Delete all feedback objects */
   _mesa_HashDeleteAll(ctx->TransformFeedback.Objects, delete_cb, ctx);
   _mesa_DeleteHashTable(ctx->TransformFeedback.Objects);

   /* Delete the default feedback object */
   assert(ctx->Driver.DeleteTransformFeedback);
   ctx->Driver.DeleteTransformFeedback(ctx,
                                       ctx->TransformFeedback.DefaultObject);

   ctx->TransformFeedback.CurrentObject = NULL;
}


/** Initialize the fields of a gl_transform_feedback_object. */
void
_mesa_init_transform_feedback_object(struct gl_transform_feedback_object *obj,
                                     GLuint name)
{
   if (!obj)
      return;

   obj->Name = name;
   obj->RefCount = 1;
   obj->EverBound = GL_FALSE;
}


/** Default fallback for ctx->Driver.NewTransformFeedback() */
static struct gl_transform_feedback_object *
new_transform_feedback(struct gl_context *ctx, GLuint name)
{
   struct gl_transform_feedback_object *obj;
   obj = CALLOC_STRUCT(gl_transform_feedback_object);
   _mesa_init_transform_feedback_object(obj, name);
   return obj;
}

/** Default fallback for ctx->Driver.DeleteTransformFeedback() */
static void
delete_transform_feedback(struct gl_context *ctx,
                          struct gl_transform_feedback_object *obj)
{
   GLuint i;

   for (i = 0; i < Elements(obj->Buffers); i++) {
      _mesa_reference_buffer_object(ctx, &obj->Buffers[i], NULL);
   }

   free(obj->Label);
   free(obj);
}


/** Default fallback for ctx->Driver.BeginTransformFeedback() */
static void
begin_transform_feedback(struct gl_context *ctx, GLenum mode,
                         struct gl_transform_feedback_object *obj)
{
   /* nop */
}

/** Default fallback for ctx->Driver.EndTransformFeedback() */
static void
end_transform_feedback(struct gl_context *ctx,
                       struct gl_transform_feedback_object *obj)
{
   /* nop */
}

/** Default fallback for ctx->Driver.PauseTransformFeedback() */
static void
pause_transform_feedback(struct gl_context *ctx,
                         struct gl_transform_feedback_object *obj)
{
   /* nop */
}

/** Default fallback for ctx->Driver.ResumeTransformFeedback() */
static void
resume_transform_feedback(struct gl_context *ctx,
                          struct gl_transform_feedback_object *obj)
{
   /* nop */
}


/**
 * Plug in default device driver functions for transform feedback.
 * Most drivers will override some/all of these.
 */
void
_mesa_init_transform_feedback_functions(struct dd_function_table *driver)
{
   driver->NewTransformFeedback = new_transform_feedback;
   driver->DeleteTransformFeedback = delete_transform_feedback;
   driver->BeginTransformFeedback = begin_transform_feedback;
   driver->EndTransformFeedback = end_transform_feedback;
   driver->PauseTransformFeedback = pause_transform_feedback;
   driver->ResumeTransformFeedback = resume_transform_feedback;
}


/**
 * Fill in the correct Size value for each buffer in \c obj.
 *
 * From the GL 4.3 spec, section 6.1.1 ("Binding Buffer Objects to Indexed
 * Targets"):
 *
 *   BindBufferBase binds the entire buffer, even when the size of the buffer
 *   is changed after the binding is established. It is equivalent to calling
 *   BindBufferRange with offset zero, while size is determined by the size of
 *   the bound buffer at the time the binding is used.
 *
 *   Regardless of the size specified with BindBufferRange, or indirectly with
 *   BindBufferBase, the GL will never read or write beyond the end of a bound
 *   buffer. In some cases this constraint may result in visibly different
 *   behavior when a buffer overflow would otherwise result, such as described
 *   for transform feedback operations in section 13.2.2.
 */
static void
compute_transform_feedback_buffer_sizes(
      struct gl_transform_feedback_object *obj)
{
   unsigned i = 0;
   for (i = 0; i < MAX_FEEDBACK_BUFFERS; ++i) {
      GLintptr offset = obj->Offset[i];
      GLsizeiptr buffer_size
         = obj->Buffers[i] == NULL ? 0 : obj->Buffers[i]->Size;
      GLsizeiptr available_space
         = buffer_size <= offset ? 0 : buffer_size - offset;
      GLsizeiptr computed_size;
      if (obj->RequestedSize[i] == 0) {
         /* No size was specified at the time the buffer was bound, so allow
          * writing to all available space in the buffer.
          */
         computed_size = available_space;
      } else {
         /* A size was specified at the time the buffer was bound, however
          * it's possible that the buffer has shrunk since then.  So only
          * allow writing to the minimum of the specified size and the space
          * available.
          */
         computed_size = MIN2(available_space, obj->RequestedSize[i]);
      }

      /* Legal sizes must be multiples of four, so round down if necessary. */
      obj->Size[i] = computed_size & ~0x3;
   }
}


/**
 * Compute the maximum number of vertices that can be written to the currently
 * enabled transform feedback buffers without overflowing any of them.
 */
unsigned
_mesa_compute_max_transform_feedback_vertices(
      const struct gl_transform_feedback_object *obj,
      const struct gl_transform_feedback_info *info)
{
   unsigned max_index = 0xffffffff;
   unsigned i;

   for (i = 0; i < info->NumBuffers; ++i) {
      unsigned stride = info->BufferStride[i];
      unsigned max_for_this_buffer;

      /* Skip any inactive buffers, which have a stride of 0. */
      if (stride == 0)
	 continue;

      max_for_this_buffer = obj->Size[i] / (4 * stride);
      max_index = MIN2(max_index, max_for_this_buffer);
   }

   return max_index;
}


/**
 ** Begin API functions
 **/


/**
 * Figure out which stage of the pipeline is the source of transform feedback
 * data given the current context state, and return its gl_shader_program.
 *
 * If no active program can generate transform feedback data (i.e. no vertex
 * shader is active), returns NULL.
 */
static struct gl_shader_program *
get_xfb_source(struct gl_context *ctx)
{
   int i;
   for (i = MESA_SHADER_GEOMETRY; i >= MESA_SHADER_VERTEX; i--) {
      if (ctx->_Shader->CurrentProgram[i] != NULL)
         return ctx->_Shader->CurrentProgram[i];
   }
   return NULL;
}


void GLAPIENTRY
_mesa_BeginTransformFeedback(GLenum mode)
{
   struct gl_transform_feedback_object *obj;
   struct gl_transform_feedback_info *info = NULL;
   struct gl_shader_program *source;
   GLuint i;
   unsigned vertices_per_prim;
   GET_CURRENT_CONTEXT(ctx);

   obj = ctx->TransformFeedback.CurrentObject;

   /* Figure out what pipeline stage is the source of data for transform
    * feedback.
    */
   source = get_xfb_source(ctx);
   if (source == NULL) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glBeginTransformFeedback(no program active)");
      return;
   }

   info = &source->LinkedTransformFeedback;

   if (info->NumOutputs == 0) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glBeginTransformFeedback(no varyings to record)");
      return;
   }

   switch (mode) {
   case GL_POINTS:
      vertices_per_prim = 1;
      break;
   case GL_LINES:
      vertices_per_prim = 2;
      break;
   case GL_TRIANGLES:
      vertices_per_prim = 3;
      break;
   default:
      _mesa_error(ctx, GL_INVALID_ENUM, "glBeginTransformFeedback(mode)");
      return;
   }

   if (obj->Active) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glBeginTransformFeedback(already active)");
      return;
   }

   for (i = 0; i < info->NumBuffers; ++i) {
      if (obj->BufferNames[i] == 0) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glBeginTransformFeedback(binding point %d does not have "
                     "a buffer object bound)", i);
         return;
      }
   }

   FLUSH_VERTICES(ctx, 0);
   ctx->NewDriverState |= ctx->DriverFlags.NewTransformFeedback;

   obj->Active = GL_TRUE;
   ctx->TransformFeedback.Mode = mode;

   compute_transform_feedback_buffer_sizes(obj);

   if (_mesa_is_gles3(ctx)) {
      /* In GLES3, we are required to track the usage of the transform
       * feedback buffer and report INVALID_OPERATION if a draw call tries to
       * exceed it.  So compute the maximum number of vertices that we can
       * write without overflowing any of the buffers currently being used for
       * feedback.
       */
      unsigned max_vertices
         = _mesa_compute_max_transform_feedback_vertices(obj, info);
      obj->GlesRemainingPrims = max_vertices / vertices_per_prim;
   }

   if (obj->shader_program != source) {
      ctx->NewDriverState |= ctx->DriverFlags.NewTransformFeedbackProg;
      obj->shader_program = source;
   }

   assert(ctx->Driver.BeginTransformFeedback);
   ctx->Driver.BeginTransformFeedback(ctx, mode, obj);
}


void GLAPIENTRY
_mesa_EndTransformFeedback(void)
{
   struct gl_transform_feedback_object *obj;
   GET_CURRENT_CONTEXT(ctx);

   obj = ctx->TransformFeedback.CurrentObject;

   if (!obj->Active) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glEndTransformFeedback(not active)");
      return;
   }

   FLUSH_VERTICES(ctx, 0);
   ctx->NewDriverState |= ctx->DriverFlags.NewTransformFeedback;

   ctx->TransformFeedback.CurrentObject->Active = GL_FALSE;
   ctx->TransformFeedback.CurrentObject->Paused = GL_FALSE;
   ctx->TransformFeedback.CurrentObject->EndedAnytime = GL_TRUE;

   assert(ctx->Driver.EndTransformFeedback);
   ctx->Driver.EndTransformFeedback(ctx, obj);
}


/**
 * Helper used by BindBufferRange() and BindBufferBase().
 */
static void
bind_buffer_range(struct gl_context *ctx, GLuint index,
                  struct gl_buffer_object *bufObj,
                  GLintptr offset, GLsizeiptr size)
{
   struct gl_transform_feedback_object *obj =
      ctx->TransformFeedback.CurrentObject;

   /* Note: no need to FLUSH_VERTICES or flag NewTransformFeedback, because
    * transform feedback buffers can't be changed while transform feedback is
    * active.
    */

   /* The general binding point */
   _mesa_reference_buffer_object(ctx,
                                 &ctx->TransformFeedback.CurrentBuffer,
                                 bufObj);

   /* The per-attribute binding point */
   _mesa_set_transform_feedback_binding(ctx, obj, index, bufObj, offset, size);
}


/**
 * Specify a buffer object to receive transform feedback results.  Plus,
 * specify the starting offset to place the results, and max size.
 * Called from the glBindBufferRange() function.
 */
void
_mesa_bind_buffer_range_transform_feedback(struct gl_context *ctx,
					   GLuint index,
					   struct gl_buffer_object *bufObj,
					   GLintptr offset,
					   GLsizeiptr size)
{
   struct gl_transform_feedback_object *obj;

   obj = ctx->TransformFeedback.CurrentObject;

   if (obj->Active) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glBindBufferRange(transform feedback active)");
      return;
   }

   if (index >= ctx->Const.MaxTransformFeedbackBuffers) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glBindBufferRange(index=%d)", index);
      return;
   }

   if (size & 0x3) {
      /* must a multiple of four */
      _mesa_error(ctx, GL_INVALID_VALUE, "glBindBufferRange(size=%d)", (int) size);
      return;
   }  

   if (offset & 0x3) {
      /* must be multiple of four */
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glBindBufferRange(offset=%d)", (int) offset);
      return;
   }  

   bind_buffer_range(ctx, index, bufObj, offset, size);
}


/**
 * Specify a buffer object to receive transform feedback results.
 * As above, but start at offset = 0.
 * Called from the glBindBufferBase() function.
 */
void
_mesa_bind_buffer_base_transform_feedback(struct gl_context *ctx,
					  GLuint index,
					  struct gl_buffer_object *bufObj)
{
   struct gl_transform_feedback_object *obj;

   obj = ctx->TransformFeedback.CurrentObject;

   if (obj->Active) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glBindBufferBase(transform feedback active)");
      return;
   }

   if (index >= ctx->Const.MaxTransformFeedbackBuffers) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glBindBufferBase(index=%d)", index);
      return;
   }

   bind_buffer_range(ctx, index, bufObj, 0, 0);
}


/**
 * Specify a buffer object to receive transform feedback results, plus the
 * offset in the buffer to start placing results.
 * This function is part of GL_EXT_transform_feedback, but not GL3.
 */
void GLAPIENTRY
_mesa_BindBufferOffsetEXT(GLenum target, GLuint index, GLuint buffer,
                          GLintptr offset)
{
   struct gl_transform_feedback_object *obj;
   struct gl_buffer_object *bufObj;
   GET_CURRENT_CONTEXT(ctx);

   if (target != GL_TRANSFORM_FEEDBACK_BUFFER) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glBindBufferOffsetEXT(target)");
      return;
   }

   obj = ctx->TransformFeedback.CurrentObject;

   if (obj->Active) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glBindBufferOffsetEXT(transform feedback active)");
      return;
   }

   if (index >= ctx->Const.MaxTransformFeedbackBuffers) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glBindBufferOffsetEXT(index=%d)", index);
      return;
   }

   if (offset & 0x3) {
      /* must be multiple of four */
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glBindBufferOffsetEXT(offset=%d)", (int) offset);
      return;
   }

   if (buffer == 0) {
      bufObj = ctx->Shared->NullBufferObj;
   } else {
      bufObj = _mesa_lookup_bufferobj(ctx, buffer);
   }

   if (!bufObj) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glBindBufferOffsetEXT(invalid buffer=%u)", buffer);
      return;
   }

   bind_buffer_range(ctx, index, bufObj, offset, 0);
}


/**
 * This function specifies the transform feedback outputs to be written
 * to the feedback buffer(s), and in what order.
 */
void GLAPIENTRY
_mesa_TransformFeedbackVaryings(GLuint program, GLsizei count,
                                const GLchar * const *varyings,
                                GLenum bufferMode)
{
   struct gl_shader_program *shProg;
   GLint i;
   GET_CURRENT_CONTEXT(ctx);

   /* From the ARB_transform_feedback2 specification:
    * "The error INVALID_OPERATION is generated by TransformFeedbackVaryings
    *  if the current transform feedback object is active, even if paused."
    */
   if (ctx->TransformFeedback.CurrentObject->Active) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
               "glTransformFeedbackVaryings(current object is active)");
      return;
   }

   switch (bufferMode) {
   case GL_INTERLEAVED_ATTRIBS:
      break;
   case GL_SEPARATE_ATTRIBS:
      break;
   default:
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "glTransformFeedbackVaryings(bufferMode)");
      return;
   }

   if (count < 0 ||
       (bufferMode == GL_SEPARATE_ATTRIBS &&
        (GLuint) count > ctx->Const.MaxTransformFeedbackBuffers)) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glTransformFeedbackVaryings(count=%d)", count);
      return;
   }

   shProg = _mesa_lookup_shader_program(ctx, program);
   if (!shProg) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glTransformFeedbackVaryings(program=%u)", program);
      return;
   }

   if (ctx->Extensions.ARB_transform_feedback3) {
      if (bufferMode == GL_INTERLEAVED_ATTRIBS) {
         unsigned buffers = 1;

         for (i = 0; i < count; i++) {
            if (strcmp(varyings[i], "gl_NextBuffer") == 0)
               buffers++;
         }

         if (buffers > ctx->Const.MaxTransformFeedbackBuffers) {
            _mesa_error(ctx, GL_INVALID_OPERATION,
                        "glTransformFeedbackVaryings(too many gl_NextBuffer "
                        "occurences)");
            return;
         }
      } else {
         for (i = 0; i < count; i++) {
            if (strcmp(varyings[i], "gl_NextBuffer") == 0 ||
                strcmp(varyings[i], "gl_SkipComponents1") == 0 ||
                strcmp(varyings[i], "gl_SkipComponents2") == 0 ||
                strcmp(varyings[i], "gl_SkipComponents3") == 0 ||
                strcmp(varyings[i], "gl_SkipComponents4") == 0) {
               _mesa_error(ctx, GL_INVALID_OPERATION,
                           "glTransformFeedbackVaryings(SEPARATE_ATTRIBS,"
                           "varying=%s)",
                           varyings[i]);
               return;
            }
         }
      }
   }

   /* free existing varyings, if any */
   for (i = 0; i < (GLint) shProg->TransformFeedback.NumVarying; i++) {
      free(shProg->TransformFeedback.VaryingNames[i]);
   }
   free(shProg->TransformFeedback.VaryingNames);

   /* allocate new memory for varying names */
   shProg->TransformFeedback.VaryingNames =
      malloc(count * sizeof(GLchar *));

   if (!shProg->TransformFeedback.VaryingNames) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glTransformFeedbackVaryings()");
      return;
   }

   /* Save the new names and the count */
   for (i = 0; i < count; i++) {
      shProg->TransformFeedback.VaryingNames[i] = _mesa_strdup(varyings[i]);
   }
   shProg->TransformFeedback.NumVarying = count;

   shProg->TransformFeedback.BufferMode = bufferMode;

   /* No need to invoke FLUSH_VERTICES or flag NewTransformFeedback since
    * the varyings won't be used until shader link time.
    */
}


/**
 * Get info about the transform feedback outputs which are to be written
 * to the feedback buffer(s).
 */
void GLAPIENTRY
_mesa_GetTransformFeedbackVarying(GLuint program, GLuint index,
                                  GLsizei bufSize, GLsizei *length,
                                  GLsizei *size, GLenum *type, GLchar *name)
{
   const struct gl_shader_program *shProg;
   const struct gl_transform_feedback_info *linked_xfb_info;
   GET_CURRENT_CONTEXT(ctx);

   shProg = _mesa_lookup_shader_program(ctx, program);
   if (!shProg) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glGetTransformFeedbackVarying(program=%u)", program);
      return;
   }

   linked_xfb_info = &shProg->LinkedTransformFeedback;
   if (index >= (GLuint) linked_xfb_info->NumVarying) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glGetTransformFeedbackVarying(index=%u)", index);
      return;
   }

   /* return the varying's name and length */
   _mesa_copy_string(name, bufSize, length,
		     linked_xfb_info->Varyings[index].Name);

   /* return the datatype and value's size (in datatype units) */
   if (type)
      *type = linked_xfb_info->Varyings[index].Type;
   if (size)
      *size = linked_xfb_info->Varyings[index].Size;
}



struct gl_transform_feedback_object *
_mesa_lookup_transform_feedback_object(struct gl_context *ctx, GLuint name)
{
   if (name == 0) {
      return ctx->TransformFeedback.DefaultObject;
   }
   else
      return (struct gl_transform_feedback_object *)
         _mesa_HashLookup(ctx->TransformFeedback.Objects, name);
}


/**
 * Create new transform feedback objects.   Transform feedback objects
 * encapsulate the state related to transform feedback to allow quickly
 * switching state (and drawing the results, below).
 * Part of GL_ARB_transform_feedback2.
 */
void GLAPIENTRY
_mesa_GenTransformFeedbacks(GLsizei n, GLuint *names)
{
   GLuint first;
   GET_CURRENT_CONTEXT(ctx);

   if (n < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glGenTransformFeedbacks(n < 0)");
      return;
   }

   if (!names)
      return;

   /* we don't need contiguous IDs, but this might be faster */
   first = _mesa_HashFindFreeKeyBlock(ctx->TransformFeedback.Objects, n);
   if (first) {
      GLsizei i;
      for (i = 0; i < n; i++) {
         struct gl_transform_feedback_object *obj
            = ctx->Driver.NewTransformFeedback(ctx, first + i);
         if (!obj) {
            _mesa_error(ctx, GL_OUT_OF_MEMORY, "glGenTransformFeedbacks");
            return;
         }
         names[i] = first + i;
         _mesa_HashInsert(ctx->TransformFeedback.Objects, first + i, obj);
      }
   }
   else {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glGenTransformFeedbacks");
   }
}


/**
 * Is the given ID a transform feedback object?
 * Part of GL_ARB_transform_feedback2.
 */
GLboolean GLAPIENTRY
_mesa_IsTransformFeedback(GLuint name)
{
   struct gl_transform_feedback_object *obj;
   GET_CURRENT_CONTEXT(ctx);

   ASSERT_OUTSIDE_BEGIN_END_WITH_RETVAL(ctx, GL_FALSE);

   if (name == 0)
      return GL_FALSE;

   obj = _mesa_lookup_transform_feedback_object(ctx, name);
   if (obj == NULL)
      return GL_FALSE;

   return obj->EverBound;
}


/**
 * Bind the given transform feedback object.
 * Part of GL_ARB_transform_feedback2.
 */
void GLAPIENTRY
_mesa_BindTransformFeedback(GLenum target, GLuint name)
{
   struct gl_transform_feedback_object *obj;
   GET_CURRENT_CONTEXT(ctx);

   if (target != GL_TRANSFORM_FEEDBACK) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glBindTransformFeedback(target)");
      return;
   }

   if (_mesa_is_xfb_active_and_unpaused(ctx)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
              "glBindTransformFeedback(transform is active, or not paused)");
      return;
   }

   obj = _mesa_lookup_transform_feedback_object(ctx, name);
   if (!obj) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glBindTransformFeedback(name=%u)", name);
      return;
   }

   reference_transform_feedback_object(&ctx->TransformFeedback.CurrentObject,
                                       obj);
}


/**
 * Delete the given transform feedback objects.
 * Part of GL_ARB_transform_feedback2.
 */
void GLAPIENTRY
_mesa_DeleteTransformFeedbacks(GLsizei n, const GLuint *names)
{
   GLint i;
   GET_CURRENT_CONTEXT(ctx);

   if (n < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glDeleteTransformFeedbacks(n < 0)");
      return;
   }

   if (!names)
      return;

   for (i = 0; i < n; i++) {
      if (names[i] > 0) {
         struct gl_transform_feedback_object *obj
            = _mesa_lookup_transform_feedback_object(ctx, names[i]);
         if (obj) {
            if (obj->Active) {
               _mesa_error(ctx, GL_INVALID_OPERATION,
                           "glDeleteTransformFeedbacks(object %u is active)",
                           names[i]);
               return;
            }
            _mesa_HashRemove(ctx->TransformFeedback.Objects, names[i]);
            /* unref, but object may not be deleted until later */
            reference_transform_feedback_object(&obj, NULL);
         }
      }
   }
}


/**
 * Pause transform feedback.
 * Part of GL_ARB_transform_feedback2.
 */
void GLAPIENTRY
_mesa_PauseTransformFeedback(void)
{
   struct gl_transform_feedback_object *obj;
   GET_CURRENT_CONTEXT(ctx);

   obj = ctx->TransformFeedback.CurrentObject;

   if (!_mesa_is_xfb_active_and_unpaused(ctx)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
           "glPauseTransformFeedback(feedback not active or already paused)");
      return;
   }

   FLUSH_VERTICES(ctx, 0);
   ctx->NewDriverState |= ctx->DriverFlags.NewTransformFeedback;

   obj->Paused = GL_TRUE;

   assert(ctx->Driver.PauseTransformFeedback);
   ctx->Driver.PauseTransformFeedback(ctx, obj);
}


/**
 * Resume transform feedback.
 * Part of GL_ARB_transform_feedback2.
 */
void GLAPIENTRY
_mesa_ResumeTransformFeedback(void)
{
   struct gl_transform_feedback_object *obj;
   GET_CURRENT_CONTEXT(ctx);

   obj = ctx->TransformFeedback.CurrentObject;

   if (!obj->Active || !obj->Paused) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
               "glResumeTransformFeedback(feedback not active or not paused)");
      return;
   }

   /* From the ARB_transform_feedback2 specification:
    * "The error INVALID_OPERATION is generated by ResumeTransformFeedback if
    *  the program object being used by the current transform feedback object
    *  is not active."
    */
   if (obj->shader_program != get_xfb_source(ctx)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glResumeTransformFeedback(wrong program bound)");
      return;
   }

   FLUSH_VERTICES(ctx, 0);
   ctx->NewDriverState |= ctx->DriverFlags.NewTransformFeedback;

   obj->Paused = GL_FALSE;

   assert(ctx->Driver.ResumeTransformFeedback);
   ctx->Driver.ResumeTransformFeedback(ctx, obj);
}
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.3
log
@Merge Mesa 9.2.0
@
text
@d27 1
a27 1
 * Vertex transform feedback support.
a34 1
#include "bufferobj.h"
d46 35
d207 14
d227 1
a227 5
   if (obj) {
      obj->Name = name;
      obj->RefCount = 1;
      obj->EverBound = GL_FALSE;
   }
d242 1
d378 19
d401 2
a402 1
   struct gl_transform_feedback_info *info;
d409 5
a413 1
   if (ctx->Shader.CurrentVertexProgram == NULL) {
d419 1
a419 1
   info = &ctx->Shader.CurrentVertexProgram->LinkedTransformFeedback;
d477 5
d535 1
a535 8
   _mesa_reference_buffer_object(ctx,
                                 &obj->Buffers[index],
                                 bufObj);

   obj->BufferNames[index] = bufObj->Name;

   obj->Offset[index] = offset;
   obj->RequestedSize[index] = size;
d540 1
a540 1
 * Specify a buffer object to receive vertex shader results.  Plus,
d584 1
a584 1
 * Specify a buffer object to receive vertex shader results.
d613 1
a613 1
 * Specify a buffer object to receive vertex shader results, plus the
d668 1
a668 1
 * This function specifies the vertex shader outputs to be written
d680 10
d778 1
a778 1
 * Get info about the vertex shader's outputs which are to be written
d1007 11
@


1.2
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d19 4
a22 3
 * THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
d38 1
a38 1
#include "mfeatures.h"
a47 3
#if FEATURE_EXT_transform_feedback


d83 1
a90 26
 * Check if the given primitive mode (as in glBegin(mode)) is compatible
 * with the current transform feedback mode (if it's enabled).
 * This is to be called from glBegin(), glDrawArrays(), glDrawElements(), etc.
 *
 * \return GL_TRUE if the mode is OK, GL_FALSE otherwise.
 */
GLboolean
_mesa_validate_primitive_mode(struct gl_context *ctx, GLenum mode)
{
   if (ctx->TransformFeedback.CurrentObject->Active) {
      switch (mode) {
      case GL_POINTS:
         return ctx->TransformFeedback.Mode == GL_POINTS;
      case GL_LINES:
      case GL_LINE_STRIP:
      case GL_LINE_LOOP:
         return ctx->TransformFeedback.Mode == GL_LINES;
      default:
         return ctx->TransformFeedback.Mode == GL_TRIANGLES;
      }
   }
   return GL_TRUE;
}


/**
a172 34
#else /* FEATURE_EXT_transform_feedback */

/* forward declarations */
static struct gl_transform_feedback_object *
new_transform_feedback(struct gl_context *ctx, GLuint name);

static void
delete_transform_feedback(struct gl_context *ctx,
                          struct gl_transform_feedback_object *obj);

/* dummy per-context init/clean-up for transform feedback */
void
_mesa_init_transform_feedback(struct gl_context *ctx)
{
   ctx->TransformFeedback.DefaultObject = new_transform_feedback(ctx, 0);
   ctx->TransformFeedback.CurrentObject = ctx->TransformFeedback.DefaultObject;
   _mesa_reference_buffer_object(ctx,
                                 &ctx->TransformFeedback.CurrentBuffer,
                                 ctx->Shared->NullBufferObj);
}

void
_mesa_free_transform_feedback(struct gl_context *ctx)
{
   _mesa_reference_buffer_object(ctx,
                                 &ctx->TransformFeedback.CurrentBuffer,
                                 NULL);
   ctx->TransformFeedback.CurrentObject = NULL;
   delete_transform_feedback(ctx, ctx->TransformFeedback.DefaultObject);
}

#endif /* FEATURE_EXT_transform_feedback */


d182 1
a201 3
#if FEATURE_EXT_transform_feedback


a233 12
/** Default fallback for ctx->Driver.DrawTransformFeedback() */
static void
draw_transform_feedback(struct gl_context *ctx, GLenum mode,
                        struct gl_transform_feedback_object *obj)
{
   /* XXX to do */
   /*
    * Get number of vertices in obj's feedback buffer.
    * Call ctx->Exec.DrawArrays(mode, 0, count);
    */
}

a247 1
   driver->DrawTransformFeedback = draw_transform_feedback;
d251 57
a307 2
void
_mesa_init_transform_feedback_dispatch(struct _glapi_table *disp)
d309 16
a324 7
   SET_BeginTransformFeedbackEXT(disp, _mesa_BeginTransformFeedback);
   SET_EndTransformFeedbackEXT(disp, _mesa_EndTransformFeedback);
   SET_BindBufferRangeEXT(disp, _mesa_BindBufferRange);
   SET_BindBufferBaseEXT(disp, _mesa_BindBufferBase);
   SET_BindBufferOffsetEXT(disp, _mesa_BindBufferOffsetEXT);
   SET_TransformFeedbackVaryingsEXT(disp, _mesa_TransformFeedbackVaryings);
   SET_GetTransformFeedbackVaryingEXT(disp, _mesa_GetTransformFeedbackVarying);
d337 3
d344 14
d360 2
d363 2
d366 1
a366 1
      /* legal */
d379 12
d394 14
d427 3
d431 2
d450 5
d468 1
a468 1
   obj->Size[index] = size;
d475 1
d477 6
a482 3
void GLAPIENTRY
_mesa_BindBufferRange(GLenum target, GLuint index,
                      GLuint buffer, GLintptr offset, GLsizeiptr size)
a484 7
   struct gl_buffer_object *bufObj;
   GET_CURRENT_CONTEXT(ctx);

   if (target != GL_TRANSFORM_FEEDBACK_BUFFER) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glBindBufferRange(target)");
      return;
   }
d494 1
a494 1
   if (index >= ctx->Const.MaxTransformFeedbackSeparateAttribs) {
d499 3
a501 3
   if ((size <= 0) || (size & 0x3)) {
      /* must be positive and multiple of four */
      _mesa_error(ctx, GL_INVALID_VALUE, "glBindBufferRange(size%d)", (int) size);
a511 14
   bufObj = _mesa_lookup_bufferobj(ctx, buffer);
   if (!bufObj) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glBindBufferRange(invalid buffer=%u)", buffer);
      return;
   }

   if (offset + size >= bufObj->Size) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glBindBufferRange(offset + size %d > buffer size %d)",
		  (int) (offset + size), (int) (bufObj->Size));
      return;
   }  

d519 1
d521 4
a524 2
void GLAPIENTRY
_mesa_BindBufferBase(GLenum target, GLuint index, GLuint buffer)
a526 8
   struct gl_buffer_object *bufObj;
   GLsizeiptr size;
   GET_CURRENT_CONTEXT(ctx);

   if (target != GL_TRANSFORM_FEEDBACK_BUFFER) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glBindBufferBase(target)");
      return;
   }
d536 1
a536 1
   if (index >= ctx->Const.MaxTransformFeedbackSeparateAttribs) {
d541 1
a541 13
   bufObj = _mesa_lookup_bufferobj(ctx, buffer);
   if (!bufObj) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glBindBufferBase(invalid buffer=%u)", buffer);
      return;
   }

   /* default size is the buffer size rounded down to nearest
    * multiple of four.
    */
   size = bufObj->Size & ~0x3;

   bind_buffer_range(ctx, index, bufObj, 0, size);
a556 1
   GLsizeiptr size;
d571 1
a571 1
   if (index >= ctx->Const.MaxTransformFeedbackSeparateAttribs) {
d577 13
a589 1
   bufObj = _mesa_lookup_bufferobj(ctx, buffer);
d596 1
a596 6
   /* default size is the buffer size rounded down to nearest
    * multiple of four.
    */
   size = (bufObj->Size - offset) & ~0x3;

   bind_buffer_range(ctx, index, bufObj, offset, size);
d606 2
a607 1
                                const GLchar **varyings, GLenum bufferMode)
d610 1
a610 1
   GLuint i;
d624 3
a626 1
   if (count < 0 || count > ctx->Const.MaxTransformFeedbackSeparateAttribs) {
d639 32
d672 1
a672 1
   for (i = 0; i < shProg->TransformFeedback.NumVarying; i++) {
d679 1
a679 1
      (GLchar **) malloc(count * sizeof(GLchar *));
d687 1
a687 1
   for (i = 0; i < (GLuint) count; i++) {
d694 3
a696 1
   /* The varyings won't be used until shader link time */
d710 1
a710 2
   const GLchar *varyingName;
   GLint v;
d716 1
a716 1
                  "glGetTransformFeedbackVaryings(program=%u)", program);
d720 2
a721 1
   if (index >= shProg->TransformFeedback.NumVarying) {
d723 1
a723 1
                  "glGetTransformFeedbackVaryings(index=%u)", index);
d727 3
a729 5
   varyingName = shProg->TransformFeedback.VaryingNames[index];

   v = _mesa_lookup_parameter_index(shProg->Varying, -1, varyingName);
   if (v >= 0) {
      struct gl_program_parameter *param = &shProg->Varying->Parameters[v];
d731 5
a735 18
      /* return the varying's name and length */
      _mesa_copy_string(name, bufSize, length, varyingName);

      /* return the datatype and value's size (in datatype units) */
      if (type)
         *type = param->DataType;
      if (size)
         *size = param->Size;
   }
   else {
      name[0] = 0;
      if (length)
         *length = 0;
      if (type)
         *type = 0;
      if (size)
         *size = 0;
   }
d740 2
a741 2
static struct gl_transform_feedback_object *
lookup_transform_feedback_object(struct gl_context *ctx, GLuint name)
a763 2
   ASSERT_OUTSIDE_BEGIN_END(ctx);

d800 1
d805 5
a809 3
   if (name && lookup_transform_feedback_object(ctx, name))
      return GL_TRUE;
   else
d811 2
d831 1
a831 2
   if (ctx->TransformFeedback.CurrentObject->Active &&
       !ctx->TransformFeedback.CurrentObject->Paused) {
d837 1
a837 1
   obj = lookup_transform_feedback_object(ctx, name);
a858 2
   ASSERT_OUTSIDE_BEGIN_END(ctx);

d870 1
a870 1
            = lookup_transform_feedback_object(ctx, names[i]);
d899 1
a899 1
   if (!obj->Active || obj->Paused) {
d905 3
d933 3
a940 39


/**
 * Draw the vertex data in a transform feedback object.
 * \param mode  GL_POINTS, GL_LINES, GL_TRIANGLE_STRIP, etc.
 * \param name  the transform feedback object
 * The number of vertices comes from the transform feedback object.
 * User still has to setup of the vertex attribute info with
 * glVertexPointer, glColorPointer, etc.
 * Part of GL_ARB_transform_feedback2.
 */
void GLAPIENTRY
_mesa_DrawTransformFeedback(GLenum mode, GLuint name)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_transform_feedback_object *obj =
      lookup_transform_feedback_object(ctx, name);

   if (mode > GL_POLYGON) {
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "glDrawTransformFeedback(mode=0x%x)", mode);
      return;
   }
   if (!obj) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glDrawTransformFeedback(name = %u)", name);
      return;
   }

   /* XXX check if EndTransformFeedback has never been called while
    * the object was bound
    */

   assert(ctx->Driver.DrawTransformFeedback);
   ctx->Driver.DrawTransformFeedback(ctx, mode, obj);
}


#endif /* FEATURE_EXT_transform_feedback */
@


1.1
log
@Initial revision
@
text
@d37 2
a44 1
//#include "program/shader_api.h"
d509 1
a509 1
                  "glBindBufferRange(transform feedback active)");
d557 1
a557 1
                  "glBindBufferRange(transform feedback active)");
d887 1
a887 1
               "glPauseTransformFeedback(feedback not active or not paused)");
a931 11


/*
XXX misc to do:

glGet*() for

GL_TRANSFORM_FEEDBACK_BUFFER_PAUSED
GL_TRANSFORM_FEEDBACK_BUFFER_ACTIVE
GL_TRANSFORM_FEEDBACK_BINDING
*/
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d19 3
a21 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
a36 2
#include "macros.h"
#include "mtypes.h"
d43 4
a83 1
         obj->EverBound = GL_TRUE;
d91 26
d199 34
a241 1
      obj->EverBound = GL_FALSE;
d261 3
d296 12
d322 1
d326 2
a327 57
/**
 * Fill in the correct Size value for each buffer in \c obj.
 *
 * From the GL 4.3 spec, section 6.1.1 ("Binding Buffer Objects to Indexed
 * Targets"):
 *
 *   BindBufferBase binds the entire buffer, even when the size of the buffer
 *   is changed after the binding is established. It is equivalent to calling
 *   BindBufferRange with offset zero, while size is determined by the size of
 *   the bound buffer at the time the binding is used.
 *
 *   Regardless of the size specified with BindBufferRange, or indirectly with
 *   BindBufferBase, the GL will never read or write beyond the end of a bound
 *   buffer. In some cases this constraint may result in visibly different
 *   behavior when a buffer overflow would otherwise result, such as described
 *   for transform feedback operations in section 13.2.2.
 */
static void
compute_transform_feedback_buffer_sizes(
      struct gl_transform_feedback_object *obj)
{
   unsigned i = 0;
   for (i = 0; i < MAX_FEEDBACK_BUFFERS; ++i) {
      GLintptr offset = obj->Offset[i];
      GLsizeiptr buffer_size
         = obj->Buffers[i] == NULL ? 0 : obj->Buffers[i]->Size;
      GLsizeiptr available_space
         = buffer_size <= offset ? 0 : buffer_size - offset;
      GLsizeiptr computed_size;
      if (obj->RequestedSize[i] == 0) {
         /* No size was specified at the time the buffer was bound, so allow
          * writing to all available space in the buffer.
          */
         computed_size = available_space;
      } else {
         /* A size was specified at the time the buffer was bound, however
          * it's possible that the buffer has shrunk since then.  So only
          * allow writing to the minimum of the specified size and the space
          * available.
          */
         computed_size = MIN2(available_space, obj->RequestedSize[i]);
      }

      /* Legal sizes must be multiples of four, so round down if necessary. */
      obj->Size[i] = computed_size & ~0x3;
   }
}


/**
 * Compute the maximum number of vertices that can be written to the currently
 * enabled transform feedback buffers without overflowing any of them.
 */
unsigned
_mesa_compute_max_transform_feedback_vertices(
      const struct gl_transform_feedback_object *obj,
      const struct gl_transform_feedback_info *info)
d329 7
a335 16
   unsigned max_index = 0xffffffff;
   unsigned i;

   for (i = 0; i < info->NumBuffers; ++i) {
      unsigned stride = info->BufferStride[i];
      unsigned max_for_this_buffer;

      /* Skip any inactive buffers, which have a stride of 0. */
      if (stride == 0)
	 continue;

      max_for_this_buffer = obj->Size[i] / (4 * stride);
      max_index = MIN2(max_index, max_for_this_buffer);
   }

   return max_index;
a347 3
   struct gl_transform_feedback_info *info;
   GLuint i;
   unsigned vertices_per_prim;
a351 14
   if (ctx->Shader.CurrentVertexProgram == NULL) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glBeginTransformFeedback(no program active)");
      return;
   }

   info = &ctx->Shader.CurrentVertexProgram->LinkedTransformFeedback;

   if (info->NumOutputs == 0) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glBeginTransformFeedback(no varyings to record)");
      return;
   }

a353 2
      vertices_per_prim = 1;
      break;
a354 2
      vertices_per_prim = 2;
      break;
d356 1
a356 1
      vertices_per_prim = 3;
a368 12
   for (i = 0; i < info->NumBuffers; ++i) {
      if (obj->BufferNames[i] == 0) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glBeginTransformFeedback(binding point %d does not have "
                     "a buffer object bound)", i);
         return;
      }
   }

   FLUSH_VERTICES(ctx, 0);
   ctx->NewDriverState |= ctx->DriverFlags.NewTransformFeedback;

a371 14
   compute_transform_feedback_buffer_sizes(obj);

   if (_mesa_is_gles3(ctx)) {
      /* In GLES3, we are required to track the usage of the transform
       * feedback buffer and report INVALID_OPERATION if a draw call tries to
       * exceed it.  So compute the maximum number of vertices that we can
       * write without overflowing any of the buffers currently being used for
       * feedback.
       */
      unsigned max_vertices
         = _mesa_compute_max_transform_feedback_vertices(obj, info);
      obj->GlesRemainingPrims = max_vertices / vertices_per_prim;
   }

a390 3
   FLUSH_VERTICES(ctx, 0);
   ctx->NewDriverState |= ctx->DriverFlags.NewTransformFeedback;

a391 2
   ctx->TransformFeedback.CurrentObject->Paused = GL_FALSE;
   ctx->TransformFeedback.CurrentObject->EndedAnytime = GL_TRUE;
a408 5
   /* Note: no need to FLUSH_VERTICES or flag NewTransformFeedback, because
    * transform feedback buffers can't be changed while transform feedback is
    * active.
    */

d422 1
a422 1
   obj->RequestedSize[index] = size;
a428 1
 * Called from the glBindBufferRange() function.
d430 3
a432 6
void
_mesa_bind_buffer_range_transform_feedback(struct gl_context *ctx,
					   GLuint index,
					   struct gl_buffer_object *bufObj,
					   GLintptr offset,
					   GLsizeiptr size)
d435 7
d451 1
a451 1
   if (index >= ctx->Const.MaxTransformFeedbackBuffers) {
d456 3
a458 3
   if (size & 0x3) {
      /* must a multiple of four */
      _mesa_error(ctx, GL_INVALID_VALUE, "glBindBufferRange(size=%d)", (int) size);
d469 14
a489 1
 * Called from the glBindBufferBase() function.
d491 2
a492 4
void
_mesa_bind_buffer_base_transform_feedback(struct gl_context *ctx,
					  GLuint index,
					  struct gl_buffer_object *bufObj)
d495 8
d508 1
a508 1
                  "glBindBufferBase(transform feedback active)");
d512 1
a512 1
   if (index >= ctx->Const.MaxTransformFeedbackBuffers) {
d517 13
a529 1
   bind_buffer_range(ctx, index, bufObj, 0, 0);
d545 1
d556 1
a556 1
                  "glBindBufferOffsetEXT(transform feedback active)");
d560 1
a560 1
   if (index >= ctx->Const.MaxTransformFeedbackBuffers) {
d566 1
a566 13
   if (offset & 0x3) {
      /* must be multiple of four */
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glBindBufferOffsetEXT(offset=%d)", (int) offset);
      return;
   }

   if (buffer == 0) {
      bufObj = ctx->Shared->NullBufferObj;
   } else {
      bufObj = _mesa_lookup_bufferobj(ctx, buffer);
   }

d573 6
a578 1
   bind_buffer_range(ctx, index, bufObj, offset, 0);
d588 1
a588 2
                                const GLchar * const *varyings,
                                GLenum bufferMode)
d591 1
a591 1
   GLint i;
d605 1
a605 3
   if (count < 0 ||
       (bufferMode == GL_SEPARATE_ATTRIBS &&
        (GLuint) count > ctx->Const.MaxTransformFeedbackBuffers)) {
a617 32
   if (ctx->Extensions.ARB_transform_feedback3) {
      if (bufferMode == GL_INTERLEAVED_ATTRIBS) {
         unsigned buffers = 1;

         for (i = 0; i < count; i++) {
            if (strcmp(varyings[i], "gl_NextBuffer") == 0)
               buffers++;
         }

         if (buffers > ctx->Const.MaxTransformFeedbackBuffers) {
            _mesa_error(ctx, GL_INVALID_OPERATION,
                        "glTransformFeedbackVaryings(too many gl_NextBuffer "
                        "occurences)");
            return;
         }
      } else {
         for (i = 0; i < count; i++) {
            if (strcmp(varyings[i], "gl_NextBuffer") == 0 ||
                strcmp(varyings[i], "gl_SkipComponents1") == 0 ||
                strcmp(varyings[i], "gl_SkipComponents2") == 0 ||
                strcmp(varyings[i], "gl_SkipComponents3") == 0 ||
                strcmp(varyings[i], "gl_SkipComponents4") == 0) {
               _mesa_error(ctx, GL_INVALID_OPERATION,
                           "glTransformFeedbackVaryings(SEPARATE_ATTRIBS,"
                           "varying=%s)",
                           varyings[i]);
               return;
            }
         }
      }
   }

d619 1
a619 1
   for (i = 0; i < (GLint) shProg->TransformFeedback.NumVarying; i++) {
d626 1
a626 1
      malloc(count * sizeof(GLchar *));
d634 1
a634 1
   for (i = 0; i < count; i++) {
d641 1
a641 3
   /* No need to invoke FLUSH_VERTICES or flag NewTransformFeedback since
    * the varyings won't be used until shader link time.
    */
d655 2
a656 1
   const struct gl_transform_feedback_info *linked_xfb_info;
d662 1
a662 1
                  "glGetTransformFeedbackVarying(program=%u)", program);
d666 1
a666 2
   linked_xfb_info = &shProg->LinkedTransformFeedback;
   if (index >= (GLuint) linked_xfb_info->NumVarying) {
d668 1
a668 1
                  "glGetTransformFeedbackVarying(index=%u)", index);
d672 8
a679 3
   /* return the varying's name and length */
   _mesa_copy_string(name, bufSize, length,
		     linked_xfb_info->Varyings[index].Name);
d681 15
a695 5
   /* return the datatype and value's size (in datatype units) */
   if (type)
      *type = linked_xfb_info->Varyings[index].Type;
   if (size)
      *size = linked_xfb_info->Varyings[index].Size;
d700 2
a701 2
struct gl_transform_feedback_object *
_mesa_lookup_transform_feedback_object(struct gl_context *ctx, GLuint name)
d724 2
a761 1
   struct gl_transform_feedback_object *obj;
d766 3
a768 5
   if (name == 0)
      return GL_FALSE;

   obj = _mesa_lookup_transform_feedback_object(ctx, name);
   if (obj == NULL)
a769 2

   return obj->EverBound;
d788 2
a789 1
   if (_mesa_is_xfb_active_and_unpaused(ctx)) {
d795 1
a795 1
   obj = _mesa_lookup_transform_feedback_object(ctx, name);
d817 2
d830 1
a830 1
            = _mesa_lookup_transform_feedback_object(ctx, names[i]);
d859 1
a859 1
   if (!_mesa_is_xfb_active_and_unpaused(ctx)) {
a864 3
   FLUSH_VERTICES(ctx, 0);
   ctx->NewDriverState |= ctx->DriverFlags.NewTransformFeedback;

d886 1
a886 1
               "glResumeTransformFeedback(feedback not active or not paused)");
a889 3
   FLUSH_VERTICES(ctx, 0);
   ctx->NewDriverState |= ctx->DriverFlags.NewTransformFeedback;

d895 50
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d27 1
a27 1
 * Transform feedback support.
d35 1
a46 35
struct using_program_tuple
{
   struct gl_shader_program *shProg;
   bool found;
};

static void
active_xfb_object_references_program(GLuint key, void *data, void *user_data)
{
   struct using_program_tuple *callback_data = user_data;
   struct gl_transform_feedback_object *obj = data;
   if (obj->Active && obj->shader_program == callback_data->shProg)
      callback_data->found = true;
}

/**
 * Return true if any active transform feedback object is using a program.
 */
bool
_mesa_transform_feedback_is_using_program(struct gl_context *ctx,
                                          struct gl_shader_program *shProg)
{
   struct using_program_tuple callback_data;
   callback_data.shProg = shProg;
   callback_data.found = false;

   _mesa_HashWalk(ctx->TransformFeedback.Objects,
                  active_xfb_object_references_program, &callback_data);

   /* Also check DefaultObject, as it's not in the Objects hash table. */
   active_xfb_object_references_program(0, ctx->TransformFeedback.DefaultObject,
                                        &callback_data);

   return callback_data.found;
}
a172 14
/** Initialize the fields of a gl_transform_feedback_object. */
void
_mesa_init_transform_feedback_object(struct gl_transform_feedback_object *obj,
                                     GLuint name)
{
   if (!obj)
      return;

   obj->Name = name;
   obj->RefCount = 1;
   obj->EverBound = GL_FALSE;
}


d179 5
a183 1
   _mesa_init_transform_feedback_object(obj, name);
a197 1
   free(obj->Label);
a332 19
/**
 * Figure out which stage of the pipeline is the source of transform feedback
 * data given the current context state, and return its gl_shader_program.
 *
 * If no active program can generate transform feedback data (i.e. no vertex
 * shader is active), returns NULL.
 */
static struct gl_shader_program *
get_xfb_source(struct gl_context *ctx)
{
   int i;
   for (i = MESA_SHADER_GEOMETRY; i >= MESA_SHADER_VERTEX; i--) {
      if (ctx->_Shader->CurrentProgram[i] != NULL)
         return ctx->_Shader->CurrentProgram[i];
   }
   return NULL;
}


d337 1
a337 2
   struct gl_transform_feedback_info *info = NULL;
   struct gl_shader_program *source;
d344 1
a344 5
   /* Figure out what pipeline stage is the source of data for transform
    * feedback.
    */
   source = get_xfb_source(ctx);
   if (source == NULL) {
d350 1
a350 1
   info = &source->LinkedTransformFeedback;
a407 5
   if (obj->shader_program != source) {
      ctx->NewDriverState |= ctx->DriverFlags.NewTransformFeedbackProg;
      obj->shader_program = source;
   }

d461 8
a468 1
   _mesa_set_transform_feedback_binding(ctx, obj, index, bufObj, offset, size);
d473 1
a473 1
 * Specify a buffer object to receive transform feedback results.  Plus,
d517 1
a517 1
 * Specify a buffer object to receive transform feedback results.
d546 1
a546 1
 * Specify a buffer object to receive transform feedback results, plus the
d601 1
a601 1
 * This function specifies the transform feedback outputs to be written
a612 10
   /* From the ARB_transform_feedback2 specification:
    * "The error INVALID_OPERATION is generated by TransformFeedbackVaryings
    *  if the current transform feedback object is active, even if paused."
    */
   if (ctx->TransformFeedback.CurrentObject->Active) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
               "glTransformFeedbackVaryings(current object is active)");
      return;
   }

d701 1
a701 1
 * Get info about the transform feedback outputs which are to be written
a929 11
      return;
   }

   /* From the ARB_transform_feedback2 specification:
    * "The error INVALID_OPERATION is generated by ResumeTransformFeedback if
    *  the program object being used by the current transform feedback object
    *  is not active."
    */
   if (obj->shader_program != get_xfb_source(ctx)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glResumeTransformFeedback(wrong program bound)");
@


