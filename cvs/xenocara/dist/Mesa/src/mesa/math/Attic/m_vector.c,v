head	1.6;
access;
symbols
	OPENBSD_5_8:1.5.0.8
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.6
	OPENBSD_5_7_BASE:1.5
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.4
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.5.0.2
	OPENBSD_5_5_BASE:1.5
	v9_2_5:1.1.1.3
	v9_2_3:1.1.1.3
	v9_2_2:1.1.1.3
	v9_2_1:1.1.1.3
	v9_2_0:1.1.1.3
	OPENBSD_5_4:1.4.0.8
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.6
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.4
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	v7_10_3:1.1.1.2
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v7_0_1:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v6_5_2:1.1.1.1
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.12.23.05.17.54;	author jsg;	state dead;
branches;
next	1.5;
commitid	TnlogFl9nOv2eaRf;

1.5
date	2013.09.05.14.06.35;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2011.10.23.13.37.44;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.05.22.20.06.32;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.05.17.20.26.42;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.50.52;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.50.52;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2011.10.23.13.29.47;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2013.09.05.13.17.18;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.6
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2001  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * New (3.1) transformation code written by Keith Whitwell.
 */


#include "main/glheader.h"
#include "main/imports.h"
#include "main/macros.h"

#include "m_vector.h"



/**
 * Given a vector [count][4] of floats, set all the [][elt] values
 * to 0 (if elt = 0, 1, 2) or 1.0 (if elt = 3).
 */
void
_mesa_vector4f_clean_elem( GLvector4f *vec, GLuint count, GLuint elt )
{
   static const GLubyte elem_bits[4] = {
      VEC_DIRTY_0,
      VEC_DIRTY_1,
      VEC_DIRTY_2,
      VEC_DIRTY_3
   };
   static const GLfloat clean[4] = { 0, 0, 0, 1 };
   const GLfloat v = clean[elt];
   GLfloat (*data)[4] = (GLfloat (*)[4])vec->start;
   GLuint i;

   for (i = 0; i < count; i++)
      data[i][elt] = v;

   vec->flags &= ~elem_bits[elt];
}


static const GLubyte size_bits[5] = {
   0,
   VEC_SIZE_1,
   VEC_SIZE_2,
   VEC_SIZE_3,
   VEC_SIZE_4,
};


/**
 * Initialize GLvector objects.
 * \param v  the vector object to initialize.
 * \param flags  bitwise-OR of VEC_* flags
 * \param storage  pointer to storage for the vector's data
 */
void
_mesa_vector4f_init( GLvector4f *v, GLbitfield flags, GLfloat (*storage)[4] )
{
   v->stride = 4 * sizeof(GLfloat);
   v->size = 2;   /* may change: 2-4 for vertices and 1-4 for texcoords */
   v->data = storage;
   v->start = (GLfloat *) storage;
   v->count = 0;
   v->flags = size_bits[4] | flags;
}


/**
 * Initialize GLvector objects and allocate storage.
 * \param v  the vector object
 * \param flags  bitwise-OR of VEC_* flags
 * \param count  number of elements to allocate in vector
 * \param alignment  desired memory alignment for the data (in bytes)
 */
void
_mesa_vector4f_alloc( GLvector4f *v, GLbitfield flags, GLuint count,
                      GLuint alignment )
{
   v->stride = 4 * sizeof(GLfloat);
   v->size = 2;
   v->storage = _mesa_align_malloc( count * 4 * sizeof(GLfloat), alignment );
   v->storage_count = count;
   v->start = (GLfloat *) v->storage;
   v->data = (GLfloat (*)[4]) v->storage;
   v->count = 0;
   v->flags = size_bits[4] | flags | VEC_MALLOC;
}


/**
 * Vector deallocation.  Free whatever memory is pointed to by the
 * vector's storage field if the VEC_MALLOC flag is set.
 * DO NOT free the GLvector object itself, though.
 */
void
_mesa_vector4f_free( GLvector4f *v )
{
   if (v->flags & VEC_MALLOC) {
      _mesa_align_free( v->storage );
      v->data = NULL;
      v->start = NULL;
      v->storage = NULL;
      v->flags &= ~VEC_MALLOC;
   }
}


/**
 * For debugging
 */
void
_mesa_vector4f_print( const GLvector4f *v, const GLubyte *cullmask,
                      GLboolean culling )
{
   static const GLfloat c[4] = { 0, 0, 0, 1 };
   static const char *templates[5] = {
      "%d:\t0, 0, 0, 1\n",
      "%d:\t%f, 0, 0, 1\n",
      "%d:\t%f, %f, 0, 1\n",
      "%d:\t%f, %f, %f, 1\n",
      "%d:\t%f, %f, %f, %f\n"
   };

   const char *t = templates[v->size];
   GLfloat *d = (GLfloat *)v->data;
   GLuint j, i = 0, count;

   printf("data-start\n");
   for (; d != v->start; STRIDE_F(d, v->stride), i++)
      printf(t, i, d[0], d[1], d[2], d[3]);

   printf("start-count(%u)\n", v->count);
   count = i + v->count;

   if (culling) {
      for (; i < count; STRIDE_F(d, v->stride), i++)
	 if (cullmask[i])
	    printf(t, i, d[0], d[1], d[2], d[3]);
   }
   else {
      for (; i < count; STRIDE_F(d, v->stride), i++)
	 printf(t, i, d[0], d[1], d[2], d[3]);
   }

   for (j = v->size; j < 4; j++) {
      if ((v->flags & (1<<j)) == 0) {

	 printf("checking col %u is clean as advertised ", j);

	 for (i = 0, d = (GLfloat *) v->data;
	      i < count && d[j] == c[j];
	      i++, STRIDE_F(d, v->stride)) {
            /* no-op */
         }

	 if (i == count)
	    printf(" --> ok\n");
	 else
	    printf(" --> Failed at %u ******\n", i);
      }
   }
}
@


1.5
log
@Merge Mesa 9.2.0
@
text
@@


1.4
log
@Merge Mesa 7.10.3
@
text
@a2 1
 * Version:  3.5
d19 4
a22 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
@


1.3
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@a32 1
#include "main/imports.h"
@


1.2
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@a0 1

d39 1
a39 1
/*
d43 2
a44 1
void _mesa_vector4f_clean_elem( GLvector4f *vec, GLuint count, GLuint elt )
d57 1
a57 1
   for (i = 0 ; i < count ; i++)
d63 1
d73 1
a73 2

/*
d75 3
a77 3
 * Input: v - the vector object to initialize.
 *        flags - bitwise-OR of VEC_* flags
 *        storage - pointer to storage for the vector's data
d79 2
a80 3


void _mesa_vector4f_init( GLvector4f *v, GLuint flags, GLfloat (*storage)[4] )
d87 1
a87 1
   v->flags = size_bits[4] | flags ;
d91 1
a91 3


/*
d93 8
a100 10
 * Input: v - the vector object
 *        sz - unused????
 *        flags - bitwise-OR of VEC_* flags
 *        count - number of elements to allocate in vector
 *        alignment - desired memory alignment for the data (in bytes)
 */


void _mesa_vector4f_alloc( GLvector4f *v, GLuint flags, GLuint count,
			GLuint alignment )
d104 2
a105 1
   v->storage = ALIGN_MALLOC( count * 4 * sizeof(GLfloat), alignment );
d109 1
a109 1
   v->flags = size_bits[4] | flags | VEC_MALLOC ;
d113 1
a113 3


/*
d118 2
a119 3


void _mesa_vector4f_free( GLvector4f *v )
d122 1
a122 1
      ALIGN_FREE( v->storage );
d131 1
a131 1
/*
d134 3
a136 1
void _mesa_vector4f_print( GLvector4f *v, GLubyte *cullmask, GLboolean culling )
d138 2
a139 2
   GLfloat c[4] = { 0, 0, 0, 1 };
   const char *templates[5] = {
d151 3
a153 3
   _mesa_printf("data-start\n");
   for ( ; d != v->start ; STRIDE_F(d, v->stride), i++)
      _mesa_printf(t, i, d[0], d[1], d[2], d[3]);
d155 1
a155 1
   _mesa_printf("start-count(%u)\n", v->count);
d159 1
a159 1
      for ( ; i < count ; STRIDE_F(d, v->stride), i++)
d161 1
a161 1
	    _mesa_printf(t, i, d[0], d[1], d[2], d[3]);
d164 2
a165 2
      for ( ; i < count ; STRIDE_F(d, v->stride), i++)
	 _mesa_printf(t, i, d[0], d[1], d[2], d[3]);
d168 1
a168 1
   for (j = v->size ; j < 4; j++) {
d171 1
a171 1
	 _mesa_printf("checking col %u is clean as advertised ", j);
d173 5
a177 3
	 for (i = 0, d = (GLfloat *) v->data ;
	      i < count && d[j] == c[j] ;
	      i++, STRIDE_F(d, v->stride)) {};
d180 1
a180 1
	    _mesa_printf(" --> ok\n");
d182 1
a182 1
	    _mesa_printf(" --> Failed at %u ******\n", i);
a185 2


@


1.1
log
@Initial revision
@
text
@d31 4
a34 4
#include "glheader.h"
#include "imports.h"
#include "macros.h"
#include "imports.h"
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@Import Mesa 7.10.3
@
text
@d1 1
d31 4
a34 3
#include "main/glheader.h"
#include "main/imports.h"
#include "main/macros.h"
d40 1
a40 1
/**
d44 1
a44 2
void
_mesa_vector4f_clean_elem( GLvector4f *vec, GLuint count, GLuint elt )
d57 1
a57 1
   for (i = 0; i < count; i++)
a62 1

d72 2
a73 1
/**
d75 3
a77 3
 * \param v  the vector object to initialize.
 * \param flags  bitwise-OR of VEC_* flags
 * \param storage  pointer to storage for the vector's data
d79 3
a81 2
void
_mesa_vector4f_init( GLvector4f *v, GLbitfield flags, GLfloat (*storage)[4] )
d88 1
a88 1
   v->flags = size_bits[4] | flags;
d92 3
a94 1
/**
d96 10
a105 8
 * \param v  the vector object
 * \param flags  bitwise-OR of VEC_* flags
 * \param count  number of elements to allocate in vector
 * \param alignment  desired memory alignment for the data (in bytes)
 */
void
_mesa_vector4f_alloc( GLvector4f *v, GLbitfield flags, GLuint count,
                      GLuint alignment )
d109 1
a109 2
   v->storage = _mesa_align_malloc( count * 4 * sizeof(GLfloat), alignment );
   v->storage_count = count;
d113 1
a113 1
   v->flags = size_bits[4] | flags | VEC_MALLOC;
d117 3
a119 1
/**
d124 3
a126 2
void
_mesa_vector4f_free( GLvector4f *v )
d129 1
a129 1
      _mesa_align_free( v->storage );
d138 1
a138 1
/**
d141 1
a141 3
void
_mesa_vector4f_print( const GLvector4f *v, const GLubyte *cullmask,
                      GLboolean culling )
d143 2
a144 2
   static const GLfloat c[4] = { 0, 0, 0, 1 };
   static const char *templates[5] = {
d156 3
a158 3
   printf("data-start\n");
   for (; d != v->start; STRIDE_F(d, v->stride), i++)
      printf(t, i, d[0], d[1], d[2], d[3]);
d160 1
a160 1
   printf("start-count(%u)\n", v->count);
d164 1
a164 1
      for (; i < count; STRIDE_F(d, v->stride), i++)
d166 1
a166 1
	    printf(t, i, d[0], d[1], d[2], d[3]);
d169 2
a170 2
      for (; i < count; STRIDE_F(d, v->stride), i++)
	 printf(t, i, d[0], d[1], d[2], d[3]);
d173 1
a173 1
   for (j = v->size; j < 4; j++) {
d176 1
a176 1
	 printf("checking col %u is clean as advertised ", j);
d178 3
a180 5
	 for (i = 0, d = (GLfloat *) v->data;
	      i < count && d[j] == c[j];
	      i++, STRIDE_F(d, v->stride)) {
            /* no-op */
         }
d183 1
a183 1
	    printf(" --> ok\n");
d185 1
a185 1
	    printf(" --> Failed at %u ******\n", i);
d189 2
@


1.1.1.3
log
@Import Mesa 9.2.0
@
text
@d3 1
d20 3
a22 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
@


