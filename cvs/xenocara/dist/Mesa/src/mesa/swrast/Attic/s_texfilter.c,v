head	1.12;
access;
symbols
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	v10_2_9:1.1.1.8
	v10_4_3:1.1.1.7
	v10_2_7:1.1.1.6
	OPENBSD_5_6:1.9.0.2
	OPENBSD_5_6_BASE:1.9
	v10_2_3:1.1.1.6
	OPENBSD_5_5:1.8.0.2
	OPENBSD_5_5_BASE:1.8
	v9_2_5:1.1.1.5
	v9_2_3:1.1.1.5
	v9_2_2:1.1.1.5
	v9_2_1:1.1.1.5
	v9_2_0:1.1.1.5
	OPENBSD_5_4:1.7.0.4
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.6.0.4
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.5.0.6
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2015.12.23.05.17.55;	author jsg;	state dead;
branches;
next	1.11;
commitid	TnlogFl9nOv2eaRf;

1.11
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.10;
commitid	4ry2gvZGMXkCUD2n;

1.10
date	2015.01.25.14.41.22;	author jsg;	state Exp;
branches;
next	1.9;
commitid	mcxB0JvoI9gTDYXU;

1.9
date	2014.07.09.21.09.01;	author jsg;	state Exp;
branches;
next	1.8;
commitid	WPD6rgPryPkvXOr9;

1.8
date	2013.09.05.14.06.51;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2012.08.17.13.58.20;	author mpi;	state Exp;
branches;
next	1.6;

1.6
date	2011.10.23.13.37.45;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.05.22.20.06.34;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.05.17.20.26.42;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.14.58.23;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.05.31.16.36.49;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.51.26;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.51.26;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.56.51;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.32.14;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.49;	author matthieu;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.09.05.13.17.34;	author jsg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.07.09.20.35.13;	author jsg;	state Exp;
branches;
next	1.1.1.7;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.7
date	2015.01.25.14.13.31;	author jsg;	state Exp;
branches;
next	1.1.1.8;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.8
date	2015.02.20.22.50.36;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.12
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2008  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */


#include "main/glheader.h"
#include "main/context.h"
#include "main/colormac.h"
#include "main/imports.h"
#include "main/texobj.h"
#include "main/samplerobj.h"

#include "s_context.h"
#include "s_texfilter.h"


/*
 * Note, the FRAC macro has to work perfectly.  Otherwise you'll sometimes
 * see 1-pixel bands of improperly weighted linear-filtered textures.
 * The tests/texwrap.c demo is a good test.
 * Also note, FRAC(x) doesn't truly return the fractional part of x for x < 0.
 * Instead, if x < 0 then FRAC(x) = 1 - true_frac(x).
 */
#define FRAC(f)  ((f) - IFLOOR(f))



/**
 * Linear interpolation macro
 */
#define LERP(T, A, B)  ( (A) + (T) * ((B) - (A)) )


/**
 * Do 2D/biliner interpolation of float values.
 * v00, v10, v01 and v11 are typically four texture samples in a square/box.
 * a and b are the horizontal and vertical interpolants.
 * It's important that this function is inlined when compiled with
 * optimization!  If we find that's not true on some systems, convert
 * to a macro.
 */
static inline GLfloat
lerp_2d(GLfloat a, GLfloat b,
        GLfloat v00, GLfloat v10, GLfloat v01, GLfloat v11)
{
   const GLfloat temp0 = LERP(a, v00, v10);
   const GLfloat temp1 = LERP(a, v01, v11);
   return LERP(b, temp0, temp1);
}


/**
 * Do 3D/trilinear interpolation of float values.
 * \sa lerp_2d
 */
static inline GLfloat
lerp_3d(GLfloat a, GLfloat b, GLfloat c,
        GLfloat v000, GLfloat v100, GLfloat v010, GLfloat v110,
        GLfloat v001, GLfloat v101, GLfloat v011, GLfloat v111)
{
   const GLfloat temp00 = LERP(a, v000, v100);
   const GLfloat temp10 = LERP(a, v010, v110);
   const GLfloat temp01 = LERP(a, v001, v101);
   const GLfloat temp11 = LERP(a, v011, v111);
   const GLfloat temp0 = LERP(b, temp00, temp10);
   const GLfloat temp1 = LERP(b, temp01, temp11);
   return LERP(c, temp0, temp1);
}


/**
 * Do linear interpolation of colors.
 */
static inline void
lerp_rgba(GLfloat result[4], GLfloat t, const GLfloat a[4], const GLfloat b[4])
{
   result[0] = LERP(t, a[0], b[0]);
   result[1] = LERP(t, a[1], b[1]);
   result[2] = LERP(t, a[2], b[2]);
   result[3] = LERP(t, a[3], b[3]);
}


/**
 * Do bilinear interpolation of colors.
 */
static inline void
lerp_rgba_2d(GLfloat result[4], GLfloat a, GLfloat b,
             const GLfloat t00[4], const GLfloat t10[4],
             const GLfloat t01[4], const GLfloat t11[4])
{
   result[0] = lerp_2d(a, b, t00[0], t10[0], t01[0], t11[0]);
   result[1] = lerp_2d(a, b, t00[1], t10[1], t01[1], t11[1]);
   result[2] = lerp_2d(a, b, t00[2], t10[2], t01[2], t11[2]);
   result[3] = lerp_2d(a, b, t00[3], t10[3], t01[3], t11[3]);
}


/**
 * Do trilinear interpolation of colors.
 */
static inline void
lerp_rgba_3d(GLfloat result[4], GLfloat a, GLfloat b, GLfloat c,
             const GLfloat t000[4], const GLfloat t100[4],
             const GLfloat t010[4], const GLfloat t110[4],
             const GLfloat t001[4], const GLfloat t101[4],
             const GLfloat t011[4], const GLfloat t111[4])
{
   GLuint k;
   /* compiler should unroll these short loops */
   for (k = 0; k < 4; k++) {
      result[k] = lerp_3d(a, b, c, t000[k], t100[k], t010[k], t110[k],
                                   t001[k], t101[k], t011[k], t111[k]);
   }
}


/**
 * Used for GL_REPEAT wrap mode.  Using A % B doesn't produce the
 * right results for A<0.  Casting to A to be unsigned only works if B
 * is a power of two.  Adding a bias to A (which is a multiple of B)
 * avoids the problems with A < 0 (for reasonable A) without using a
 * conditional.
 */
#define REMAINDER(A, B) (((A) + (B) * 1024) % (B))


/**
 * Used to compute texel locations for linear sampling.
 * Input:
 *    wrapMode = GL_REPEAT, GL_CLAMP, GL_CLAMP_TO_EDGE, GL_CLAMP_TO_BORDER
 *    s = texcoord in [0,1]
 *    size = width (or height or depth) of texture
 * Output:
 *    i0, i1 = returns two nearest texel indexes
 *    weight = returns blend factor between texels
 */
static inline void
linear_texel_locations(GLenum wrapMode,
                       const struct gl_texture_image *img,
                       GLint size, GLfloat s,
                       GLint *i0, GLint *i1, GLfloat *weight)
{
   const struct swrast_texture_image *swImg = swrast_texture_image_const(img);
   GLfloat u;
   switch (wrapMode) {
   case GL_REPEAT:
      u = s * size - 0.5F;
      if (swImg->_IsPowerOfTwo) {
         *i0 = IFLOOR(u) & (size - 1);
         *i1 = (*i0 + 1) & (size - 1);
      }
      else {
         *i0 = REMAINDER(IFLOOR(u), size);
         *i1 = REMAINDER(*i0 + 1, size);
      }
      break;
   case GL_CLAMP_TO_EDGE:
      if (s <= 0.0F)
         u = 0.0F;
      else if (s >= 1.0F)
         u = (GLfloat) size;
      else
         u = s * size;
      u -= 0.5F;
      *i0 = IFLOOR(u);
      *i1 = *i0 + 1;
      if (*i0 < 0)
         *i0 = 0;
      if (*i1 >= (GLint) size)
         *i1 = size - 1;
      break;
   case GL_CLAMP_TO_BORDER:
      {
         const GLfloat min = -1.0F / (2.0F * size);
         const GLfloat max = 1.0F - min;
         if (s <= min)
            u = min * size;
         else if (s >= max)
            u = max * size;
         else
            u = s * size;
         u -= 0.5F;
         *i0 = IFLOOR(u);
         *i1 = *i0 + 1;
      }
      break;
   case GL_MIRRORED_REPEAT:
      {
         const GLint flr = IFLOOR(s);
         if (flr & 1)
            u = 1.0F - (s - (GLfloat) flr);
         else
            u = s - (GLfloat) flr;
         u = (u * size) - 0.5F;
         *i0 = IFLOOR(u);
         *i1 = *i0 + 1;
         if (*i0 < 0)
            *i0 = 0;
         if (*i1 >= (GLint) size)
            *i1 = size - 1;
      }
      break;
   case GL_MIRROR_CLAMP_EXT:
      u = FABSF(s);
      if (u >= 1.0F)
         u = (GLfloat) size;
      else
         u *= size;
      u -= 0.5F;
      *i0 = IFLOOR(u);
      *i1 = *i0 + 1;
      break;
   case GL_MIRROR_CLAMP_TO_EDGE_EXT:
      u = FABSF(s);
      if (u >= 1.0F)
         u = (GLfloat) size;
      else
         u *= size;
      u -= 0.5F;
      *i0 = IFLOOR(u);
      *i1 = *i0 + 1;
      if (*i0 < 0)
         *i0 = 0;
      if (*i1 >= (GLint) size)
         *i1 = size - 1;
      break;
   case GL_MIRROR_CLAMP_TO_BORDER_EXT:
      {
         const GLfloat min = -1.0F / (2.0F * size);
         const GLfloat max = 1.0F - min;
         u = FABSF(s);
         if (u <= min)
            u = min * size;
         else if (u >= max)
            u = max * size;
         else
            u *= size;
         u -= 0.5F;
         *i0 = IFLOOR(u);
         *i1 = *i0 + 1;
      }
      break;
   case GL_CLAMP:
      if (s <= 0.0F)
         u = 0.0F;
      else if (s >= 1.0F)
         u = (GLfloat) size;
      else
         u = s * size;
      u -= 0.5F;
      *i0 = IFLOOR(u);
      *i1 = *i0 + 1;
      break;
   default:
      _mesa_problem(NULL, "Bad wrap mode");
      *i0 = *i1 = 0;
      u = 0.0F;
      break;
   }
   *weight = FRAC(u);
}


/**
 * Used to compute texel location for nearest sampling.
 */
static inline GLint
nearest_texel_location(GLenum wrapMode,
                       const struct gl_texture_image *img,
                       GLint size, GLfloat s)
{
   const struct swrast_texture_image *swImg = swrast_texture_image_const(img);
   GLint i;

   switch (wrapMode) {
   case GL_REPEAT:
      /* s limited to [0,1) */
      /* i limited to [0,size-1] */
      i = IFLOOR(s * size);
      if (swImg->_IsPowerOfTwo)
         i &= (size - 1);
      else
         i = REMAINDER(i, size);
      return i;
   case GL_CLAMP_TO_EDGE:
      {
         /* s limited to [min,max] */
         /* i limited to [0, size-1] */
         const GLfloat min = 1.0F / (2.0F * size);
         const GLfloat max = 1.0F - min;
         if (s < min)
            i = 0;
         else if (s > max)
            i = size - 1;
         else
            i = IFLOOR(s * size);
      }
      return i;
   case GL_CLAMP_TO_BORDER:
      {
         /* s limited to [min,max] */
         /* i limited to [-1, size] */
         const GLfloat min = -1.0F / (2.0F * size);
         const GLfloat max = 1.0F - min;
         if (s <= min)
            i = -1;
         else if (s >= max)
            i = size;
         else
            i = IFLOOR(s * size);
      }
      return i;
   case GL_MIRRORED_REPEAT:
      {
         const GLfloat min = 1.0F / (2.0F * size);
         const GLfloat max = 1.0F - min;
         const GLint flr = IFLOOR(s);
         GLfloat u;
         if (flr & 1)
            u = 1.0F - (s - (GLfloat) flr);
         else
            u = s - (GLfloat) flr;
         if (u < min)
            i = 0;
         else if (u > max)
            i = size - 1;
         else
            i = IFLOOR(u * size);
      }
      return i;
   case GL_MIRROR_CLAMP_EXT:
      {
         /* s limited to [0,1] */
         /* i limited to [0,size-1] */
         const GLfloat u = FABSF(s);
         if (u <= 0.0F)
            i = 0;
         else if (u >= 1.0F)
            i = size - 1;
         else
            i = IFLOOR(u * size);
      }
      return i;
   case GL_MIRROR_CLAMP_TO_EDGE_EXT:
      {
         /* s limited to [min,max] */
         /* i limited to [0, size-1] */
         const GLfloat min = 1.0F / (2.0F * size);
         const GLfloat max = 1.0F - min;
         const GLfloat u = FABSF(s);
         if (u < min)
            i = 0;
         else if (u > max)
            i = size - 1;
         else
            i = IFLOOR(u * size);
      }
      return i;
   case GL_MIRROR_CLAMP_TO_BORDER_EXT:
      {
         /* s limited to [min,max] */
         /* i limited to [0, size-1] */
         const GLfloat min = -1.0F / (2.0F * size);
         const GLfloat max = 1.0F - min;
         const GLfloat u = FABSF(s);
         if (u < min)
            i = -1;
         else if (u > max)
            i = size;
         else
            i = IFLOOR(u * size);
      }
      return i;
   case GL_CLAMP:
      /* s limited to [0,1] */
      /* i limited to [0,size-1] */
      if (s <= 0.0F)
         i = 0;
      else if (s >= 1.0F)
         i = size - 1;
      else
         i = IFLOOR(s * size);
      return i;
   default:
      _mesa_problem(NULL, "Bad wrap mode");
      return 0;
   }
}


/* Power of two image sizes only */
static inline void
linear_repeat_texel_location(GLuint size, GLfloat s,
                             GLint *i0, GLint *i1, GLfloat *weight)
{
   GLfloat u = s * size - 0.5F;
   *i0 = IFLOOR(u) & (size - 1);
   *i1 = (*i0 + 1) & (size - 1);
   *weight = FRAC(u);
}


/**
 * Do clamp/wrap for a texture rectangle coord, GL_NEAREST filter mode.
 */
static inline GLint
clamp_rect_coord_nearest(GLenum wrapMode, GLfloat coord, GLint max)
{
   switch (wrapMode) {
   case GL_CLAMP:
      return IFLOOR( CLAMP(coord, 0.0F, max - 1) );
   case GL_CLAMP_TO_EDGE:
      return IFLOOR( CLAMP(coord, 0.5F, max - 0.5F) );
   case GL_CLAMP_TO_BORDER:
      return IFLOOR( CLAMP(coord, -0.5F, max + 0.5F) );
   default:
      _mesa_problem(NULL, "bad wrapMode in clamp_rect_coord_nearest");
      return 0;
   }
}


/**
 * As above, but GL_LINEAR filtering.
 */
static inline void
clamp_rect_coord_linear(GLenum wrapMode, GLfloat coord, GLint max,
                        GLint *i0out, GLint *i1out, GLfloat *weight)
{
   GLfloat fcol;
   GLint i0, i1;
   switch (wrapMode) {
   case GL_CLAMP:
      /* Not exactly what the spec says, but it matches NVIDIA output */
      fcol = CLAMP(coord - 0.5F, 0.0F, max - 1);
      i0 = IFLOOR(fcol);
      i1 = i0 + 1;
      break;
   case GL_CLAMP_TO_EDGE:
      fcol = CLAMP(coord, 0.5F, max - 0.5F);
      fcol -= 0.5F;
      i0 = IFLOOR(fcol);
      i1 = i0 + 1;
      if (i1 > max - 1)
         i1 = max - 1;
      break;
   case GL_CLAMP_TO_BORDER:
      fcol = CLAMP(coord, -0.5F, max + 0.5F);
      fcol -= 0.5F;
      i0 = IFLOOR(fcol);
      i1 = i0 + 1;
      break;
   default:
      _mesa_problem(NULL, "bad wrapMode in clamp_rect_coord_linear");
      i0 = i1 = 0;
      fcol = 0.0F;
      break;
   }
   *i0out = i0;
   *i1out = i1;
   *weight = FRAC(fcol);
}


/**
 * Compute slice/image to use for 1D or 2D array texture.
 */
static inline GLint
tex_array_slice(GLfloat coord, GLsizei size)
{
   GLint slice = IFLOOR(coord + 0.5f);
   slice = CLAMP(slice, 0, size - 1);
   return slice;
}


/**
 * Compute nearest integer texcoords for given texobj and coordinate.
 * NOTE: only used for depth texture sampling.
 */
static inline void
nearest_texcoord(const struct gl_sampler_object *samp,
                 const struct gl_texture_object *texObj,
                 GLuint level,
                 const GLfloat texcoord[4],
                 GLint *i, GLint *j, GLint *k)
{
   const struct gl_texture_image *img = texObj->Image[0][level];
   const GLint width = img->Width;
   const GLint height = img->Height;
   const GLint depth = img->Depth;

   switch (texObj->Target) {
   case GL_TEXTURE_RECTANGLE_ARB:
      *i = clamp_rect_coord_nearest(samp->WrapS, texcoord[0], width);
      *j = clamp_rect_coord_nearest(samp->WrapT, texcoord[1], height);
      *k = 0;
      break;
   case GL_TEXTURE_1D:
      *i = nearest_texel_location(samp->WrapS, img, width, texcoord[0]);
      *j = 0;
      *k = 0;
      break;
   case GL_TEXTURE_2D:
      *i = nearest_texel_location(samp->WrapS, img, width, texcoord[0]);
      *j = nearest_texel_location(samp->WrapT, img, height, texcoord[1]);
      *k = 0;
      break;
   case GL_TEXTURE_1D_ARRAY_EXT:
      *i = nearest_texel_location(samp->WrapS, img, width, texcoord[0]);
      *j = tex_array_slice(texcoord[1], height);
      *k = 0;
      break;
   case GL_TEXTURE_2D_ARRAY_EXT:
      *i = nearest_texel_location(samp->WrapS, img, width, texcoord[0]);
      *j = nearest_texel_location(samp->WrapT, img, height, texcoord[1]);
      *k = tex_array_slice(texcoord[2], depth);
      break;
   default:
      *i = *j = *k = 0;
      break;
   }
}


/**
 * Compute linear integer texcoords for given texobj and coordinate.
 * NOTE: only used for depth texture sampling.
 */
static inline void
linear_texcoord(const struct gl_sampler_object *samp,
                const struct gl_texture_object *texObj,
                GLuint level,
                const GLfloat texcoord[4],
                GLint *i0, GLint *i1, GLint *j0, GLint *j1, GLint *slice,
                GLfloat *wi, GLfloat *wj)
{
   const struct gl_texture_image *img = texObj->Image[0][level];
   const GLint width = img->Width;
   const GLint height = img->Height;
   const GLint depth = img->Depth;

   switch (texObj->Target) {
   case GL_TEXTURE_RECTANGLE_ARB:
      clamp_rect_coord_linear(samp->WrapS, texcoord[0],
                              width, i0, i1, wi);
      clamp_rect_coord_linear(samp->WrapT, texcoord[1],
                              height, j0, j1, wj);
      *slice = 0;
      break;

   case GL_TEXTURE_1D:
   case GL_TEXTURE_2D:
      linear_texel_locations(samp->WrapS, img, width,
                             texcoord[0], i0, i1, wi);
      linear_texel_locations(samp->WrapT, img, height,
                             texcoord[1], j0, j1, wj);
      *slice = 0;
      break;

   case GL_TEXTURE_1D_ARRAY_EXT:
      linear_texel_locations(samp->WrapS, img, width,
                             texcoord[0], i0, i1, wi);
      *j0 = tex_array_slice(texcoord[1], height);
      *j1 = *j0;
      *slice = 0;
      break;

   case GL_TEXTURE_2D_ARRAY_EXT:
      linear_texel_locations(samp->WrapS, img, width,
                             texcoord[0], i0, i1, wi);
      linear_texel_locations(samp->WrapT, img, height,
                             texcoord[1], j0, j1, wj);
      *slice = tex_array_slice(texcoord[2], depth);
      break;

   default:
      *slice = 0;
      break;
   }
}



/**
 * For linear interpolation between mipmap levels N and N+1, this function
 * computes N.
 */
static inline GLint
linear_mipmap_level(const struct gl_texture_object *tObj, GLfloat lambda)
{
   if (lambda < 0.0F)
      return tObj->BaseLevel;
   else if (lambda > tObj->_MaxLambda)
      return (GLint) (tObj->BaseLevel + tObj->_MaxLambda);
   else
      return (GLint) (tObj->BaseLevel + lambda);
}


/**
 * Compute the nearest mipmap level to take texels from.
 */
static inline GLint
nearest_mipmap_level(const struct gl_texture_object *tObj, GLfloat lambda)
{
   GLfloat l;
   GLint level;
   if (lambda <= 0.5F)
      l = 0.0F;
   else if (lambda > tObj->_MaxLambda + 0.4999F)
      l = tObj->_MaxLambda + 0.4999F;
   else
      l = lambda;
   level = (GLint) (tObj->BaseLevel + l + 0.5F);
   if (level > tObj->_MaxLevel)
      level = tObj->_MaxLevel;
   return level;
}



/*
 * Bitflags for texture border color sampling.
 */
#define I0BIT   1
#define I1BIT   2
#define J0BIT   4
#define J1BIT   8
#define K0BIT  16
#define K1BIT  32



/**
 * The lambda[] array values are always monotonic.  Either the whole span
 * will be minified, magnified, or split between the two.  This function
 * determines the subranges in [0, n-1] that are to be minified or magnified.
 */
static inline void
compute_min_mag_ranges(const struct gl_sampler_object *samp,
                       GLuint n, const GLfloat lambda[],
                       GLuint *minStart, GLuint *minEnd,
                       GLuint *magStart, GLuint *magEnd)
{
   GLfloat minMagThresh;

   /* we shouldn't be here if minfilter == magfilter */
   ASSERT(samp->MinFilter != samp->MagFilter);

   /* This bit comes from the OpenGL spec: */
   if (samp->MagFilter == GL_LINEAR
       && (samp->MinFilter == GL_NEAREST_MIPMAP_NEAREST ||
           samp->MinFilter == GL_NEAREST_MIPMAP_LINEAR)) {
      minMagThresh = 0.5F;
   }
   else {
      minMagThresh = 0.0F;
   }

#if 0
   /* DEBUG CODE: Verify that lambda[] is monotonic.
    * We can't really use this because the inaccuracy in the LOG2 function
    * causes this test to fail, yet the resulting texturing is correct.
    */
   if (n > 1) {
      GLuint i;
      printf("lambda delta = %g\n", lambda[0] - lambda[n-1]);
      if (lambda[0] >= lambda[n-1]) { /* decreasing */
         for (i = 0; i < n - 1; i++) {
            ASSERT((GLint) (lambda[i] * 10) >= (GLint) (lambda[i+1] * 10));
         }
      }
      else { /* increasing */
         for (i = 0; i < n - 1; i++) {
            ASSERT((GLint) (lambda[i] * 10) <= (GLint) (lambda[i+1] * 10));
         }
      }
   }
#endif /* DEBUG */

   if (lambda[0] <= minMagThresh && (n <= 1 || lambda[n-1] <= minMagThresh)) {
      /* magnification for whole span */
      *magStart = 0;
      *magEnd = n;
      *minStart = *minEnd = 0;
   }
   else if (lambda[0] > minMagThresh && (n <=1 || lambda[n-1] > minMagThresh)) {
      /* minification for whole span */
      *minStart = 0;
      *minEnd = n;
      *magStart = *magEnd = 0;
   }
   else {
      /* a mix of minification and magnification */
      GLuint i;
      if (lambda[0] > minMagThresh) {
         /* start with minification */
         for (i = 1; i < n; i++) {
            if (lambda[i] <= minMagThresh)
               break;
         }
         *minStart = 0;
         *minEnd = i;
         *magStart = i;
         *magEnd = n;
      }
      else {
         /* start with magnification */
         for (i = 1; i < n; i++) {
            if (lambda[i] > minMagThresh)
               break;
         }
         *magStart = 0;
         *magEnd = i;
         *minStart = i;
         *minEnd = n;
      }
   }

#if 0
   /* Verify the min/mag Start/End values
    * We don't use this either (see above)
    */
   {
      GLint i;
      for (i = 0; i < n; i++) {
         if (lambda[i] > minMagThresh) {
            /* minification */
            ASSERT(i >= *minStart);
            ASSERT(i < *minEnd);
         }
         else {
            /* magnification */
            ASSERT(i >= *magStart);
            ASSERT(i < *magEnd);
         }
      }
   }
#endif
}


/**
 * When we sample the border color, it must be interpreted according to
 * the base texture format.  Ex: if the texture base format it GL_ALPHA,
 * we return (0,0,0,BorderAlpha).
 */
static inline void
get_border_color(const struct gl_sampler_object *samp,
                 const struct gl_texture_image *img,
                 GLfloat rgba[4])
{
   switch (img->_BaseFormat) {
   case GL_RGB:
      rgba[0] = samp->BorderColor.f[0];
      rgba[1] = samp->BorderColor.f[1];
      rgba[2] = samp->BorderColor.f[2];
      rgba[3] = 1.0F;
      break;
   case GL_ALPHA:
      rgba[0] = rgba[1] = rgba[2] = 0.0;
      rgba[3] = samp->BorderColor.f[3];
      break;
   case GL_LUMINANCE:
      rgba[0] = rgba[1] = rgba[2] = samp->BorderColor.f[0];
      rgba[3] = 1.0;
      break;
   case GL_LUMINANCE_ALPHA:
      rgba[0] = rgba[1] = rgba[2] = samp->BorderColor.f[0];
      rgba[3] = samp->BorderColor.f[3];
      break;
   case GL_INTENSITY:
      rgba[0] = rgba[1] = rgba[2] = rgba[3] = samp->BorderColor.f[0];
      break;
   default:
      COPY_4V(rgba, samp->BorderColor.f);
      break;
   }
}


/**
 * Put z into texel according to GL_DEPTH_MODE.
 */
static INLINE void
apply_depth_mode(GLenum depthMode, GLfloat z, GLfloat texel[4])
{
   switch (depthMode) {
   case GL_LUMINANCE:
      ASSIGN_4V(texel, z, z, z, 1.0F);
      break;
   case GL_INTENSITY:
      ASSIGN_4V(texel, z, z, z, z);
      break;
   case GL_ALPHA:
      ASSIGN_4V(texel, 0.0F, 0.0F, 0.0F, z);
      break;
   case GL_RED:
      ASSIGN_4V(texel, z, 0.0F, 0.0F, 1.0F);
      break;
   default:
      _mesa_problem(NULL, "Bad depth texture mode");
   }
}


/**
 * Is the given texture a depth (or depth/stencil) texture?
 */
static GLboolean
is_depth_texture(const struct gl_texture_object *tObj)
{
   GLenum format = tObj->Image[0][tObj->BaseLevel]->_BaseFormat;
   return format == GL_DEPTH_COMPONENT || format == GL_DEPTH_STENCIL_EXT;
}


/**********************************************************************/
/*                    1-D Texture Sampling Functions                  */
/**********************************************************************/

/**
 * Return the texture sample for coordinate (s) using GL_NEAREST filter.
 */
static inline void
sample_1d_nearest(struct gl_context *ctx,
                  const struct gl_sampler_object *samp,
                  const struct gl_texture_image *img,
                  const GLfloat texcoord[4], GLfloat rgba[4])
{
   const struct swrast_texture_image *swImg = swrast_texture_image_const(img);
   const GLint width = img->Width2;  /* without border, power of two */
   GLint i;
   i = nearest_texel_location(samp->WrapS, img, width, texcoord[0]);
   /* skip over the border, if any */
   i += img->Border;
   if (i < 0 || i >= (GLint) img->Width) {
      /* Need this test for GL_CLAMP_TO_BORDER mode */
      get_border_color(samp, img, rgba);
   }
   else {
      swImg->FetchTexel(swImg, i, 0, 0, rgba);
   }
}


/**
 * Return the texture sample for coordinate (s) using GL_LINEAR filter.
 */
static inline void
sample_1d_linear(struct gl_context *ctx,
                 const struct gl_sampler_object *samp,
                 const struct gl_texture_image *img,
                 const GLfloat texcoord[4], GLfloat rgba[4])
{
   const struct swrast_texture_image *swImg = swrast_texture_image_const(img);
   const GLint width = img->Width2;
   GLint i0, i1;
   GLbitfield useBorderColor = 0x0;
   GLfloat a;
   GLfloat t0[4], t1[4];  /* texels */

   linear_texel_locations(samp->WrapS, img, width, texcoord[0], &i0, &i1, &a);

   if (img->Border) {
      i0 += img->Border;
      i1 += img->Border;
   }
   else {
      if (i0 < 0 || i0 >= width)   useBorderColor |= I0BIT;
      if (i1 < 0 || i1 >= width)   useBorderColor |= I1BIT;
   }

   /* fetch texel colors */
   if (useBorderColor & I0BIT) {
      get_border_color(samp, img, t0);
   }
   else {
      swImg->FetchTexel(swImg, i0, 0, 0, t0);
   }
   if (useBorderColor & I1BIT) {
      get_border_color(samp, img, t1);
   }
   else {
      swImg->FetchTexel(swImg, i1, 0, 0, t1);
   }

   lerp_rgba(rgba, a, t0, t1);
}


static void
sample_1d_nearest_mipmap_nearest(struct gl_context *ctx,
                                 const struct gl_sampler_object *samp,
                                 const struct gl_texture_object *tObj,
                                 GLuint n, const GLfloat texcoord[][4],
                                 const GLfloat lambda[], GLfloat rgba[][4])
{
   GLuint i;
   ASSERT(lambda != NULL);
   for (i = 0; i < n; i++) {
      GLint level = nearest_mipmap_level(tObj, lambda[i]);
      sample_1d_nearest(ctx, samp, tObj->Image[0][level], texcoord[i], rgba[i]);
   }
}


static void
sample_1d_linear_mipmap_nearest(struct gl_context *ctx,
                                const struct gl_sampler_object *samp,
                                const struct gl_texture_object *tObj,
                                GLuint n, const GLfloat texcoord[][4],
                                const GLfloat lambda[], GLfloat rgba[][4])
{
   GLuint i;
   ASSERT(lambda != NULL);
   for (i = 0; i < n; i++) {
      GLint level = nearest_mipmap_level(tObj, lambda[i]);
      sample_1d_linear(ctx, samp, tObj->Image[0][level], texcoord[i], rgba[i]);
   }
}


static void
sample_1d_nearest_mipmap_linear(struct gl_context *ctx,
                                const struct gl_sampler_object *samp,
                                const struct gl_texture_object *tObj,
                                GLuint n, const GLfloat texcoord[][4],
                                const GLfloat lambda[], GLfloat rgba[][4])
{
   GLuint i;
   ASSERT(lambda != NULL);
   for (i = 0; i < n; i++) {
      GLint level = linear_mipmap_level(tObj, lambda[i]);
      if (level >= tObj->_MaxLevel) {
         sample_1d_nearest(ctx, samp, tObj->Image[0][tObj->_MaxLevel],
                           texcoord[i], rgba[i]);
      }
      else {
         GLfloat t0[4], t1[4];
         const GLfloat f = FRAC(lambda[i]);
         sample_1d_nearest(ctx, samp, tObj->Image[0][level  ], texcoord[i], t0);
         sample_1d_nearest(ctx, samp, tObj->Image[0][level+1], texcoord[i], t1);
         lerp_rgba(rgba[i], f, t0, t1);
      }
   }
}


static void
sample_1d_linear_mipmap_linear(struct gl_context *ctx,
                               const struct gl_sampler_object *samp,
                               const struct gl_texture_object *tObj,
                               GLuint n, const GLfloat texcoord[][4],
                               const GLfloat lambda[], GLfloat rgba[][4])
{
   GLuint i;
   ASSERT(lambda != NULL);
   for (i = 0; i < n; i++) {
      GLint level = linear_mipmap_level(tObj, lambda[i]);
      if (level >= tObj->_MaxLevel) {
         sample_1d_linear(ctx, samp, tObj->Image[0][tObj->_MaxLevel],
                          texcoord[i], rgba[i]);
      }
      else {
         GLfloat t0[4], t1[4];
         const GLfloat f = FRAC(lambda[i]);
         sample_1d_linear(ctx, samp, tObj->Image[0][level  ], texcoord[i], t0);
         sample_1d_linear(ctx, samp, tObj->Image[0][level+1], texcoord[i], t1);
         lerp_rgba(rgba[i], f, t0, t1);
      }
   }
}


/** Sample 1D texture, nearest filtering for both min/magnification */
static void
sample_nearest_1d( struct gl_context *ctx,
                   const struct gl_sampler_object *samp,
                   const struct gl_texture_object *tObj, GLuint n,
                   const GLfloat texcoords[][4], const GLfloat lambda[],
                   GLfloat rgba[][4] )
{
   GLuint i;
   struct gl_texture_image *image = tObj->Image[0][tObj->BaseLevel];
   (void) lambda;
   for (i = 0; i < n; i++) {
      sample_1d_nearest(ctx, samp, image, texcoords[i], rgba[i]);
   }
}


/** Sample 1D texture, linear filtering for both min/magnification */
static void
sample_linear_1d( struct gl_context *ctx,
                  const struct gl_sampler_object *samp,
                  const struct gl_texture_object *tObj, GLuint n,
                  const GLfloat texcoords[][4], const GLfloat lambda[],
                  GLfloat rgba[][4] )
{
   GLuint i;
   struct gl_texture_image *image = tObj->Image[0][tObj->BaseLevel];
   (void) lambda;
   for (i = 0; i < n; i++) {
      sample_1d_linear(ctx, samp, image, texcoords[i], rgba[i]);
   }
}


/** Sample 1D texture, using lambda to choose between min/magnification */
static void
sample_lambda_1d( struct gl_context *ctx,
                  const struct gl_sampler_object *samp,
                  const struct gl_texture_object *tObj, GLuint n,
                  const GLfloat texcoords[][4],
                  const GLfloat lambda[], GLfloat rgba[][4] )
{
   GLuint minStart, minEnd;  /* texels with minification */
   GLuint magStart, magEnd;  /* texels with magnification */
   GLuint i;

   ASSERT(lambda != NULL);
   compute_min_mag_ranges(samp, n, lambda,
                          &minStart, &minEnd, &magStart, &magEnd);

   if (minStart < minEnd) {
      /* do the minified texels */
      const GLuint m = minEnd - minStart;
      switch (samp->MinFilter) {
      case GL_NEAREST:
         for (i = minStart; i < minEnd; i++)
            sample_1d_nearest(ctx, samp, tObj->Image[0][tObj->BaseLevel],
                              texcoords[i], rgba[i]);
         break;
      case GL_LINEAR:
         for (i = minStart; i < minEnd; i++)
            sample_1d_linear(ctx, samp, tObj->Image[0][tObj->BaseLevel],
                             texcoords[i], rgba[i]);
         break;
      case GL_NEAREST_MIPMAP_NEAREST:
         sample_1d_nearest_mipmap_nearest(ctx, samp, tObj, m, texcoords + minStart,
                                          lambda + minStart, rgba + minStart);
         break;
      case GL_LINEAR_MIPMAP_NEAREST:
         sample_1d_linear_mipmap_nearest(ctx, samp, tObj, m, texcoords + minStart,
                                         lambda + minStart, rgba + minStart);
         break;
      case GL_NEAREST_MIPMAP_LINEAR:
         sample_1d_nearest_mipmap_linear(ctx, samp, tObj, m, texcoords + minStart,
                                         lambda + minStart, rgba + minStart);
         break;
      case GL_LINEAR_MIPMAP_LINEAR:
         sample_1d_linear_mipmap_linear(ctx, samp, tObj, m, texcoords + minStart,
                                        lambda + minStart, rgba + minStart);
         break;
      default:
         _mesa_problem(ctx, "Bad min filter in sample_1d_texture");
         return;
      }
   }

   if (magStart < magEnd) {
      /* do the magnified texels */
      switch (samp->MagFilter) {
      case GL_NEAREST:
         for (i = magStart; i < magEnd; i++)
            sample_1d_nearest(ctx, samp, tObj->Image[0][tObj->BaseLevel],
                              texcoords[i], rgba[i]);
         break;
      case GL_LINEAR:
         for (i = magStart; i < magEnd; i++)
            sample_1d_linear(ctx, samp, tObj->Image[0][tObj->BaseLevel],
                             texcoords[i], rgba[i]);
         break;
      default:
         _mesa_problem(ctx, "Bad mag filter in sample_1d_texture");
         return;
      }
   }
}


/**********************************************************************/
/*                    2-D Texture Sampling Functions                  */
/**********************************************************************/


/**
 * Return the texture sample for coordinate (s,t) using GL_NEAREST filter.
 */
static inline void
sample_2d_nearest(struct gl_context *ctx,
                  const struct gl_sampler_object *samp,
                  const struct gl_texture_image *img,
                  const GLfloat texcoord[4],
                  GLfloat rgba[])
{
   const struct swrast_texture_image *swImg = swrast_texture_image_const(img);
   const GLint width = img->Width2;    /* without border, power of two */
   const GLint height = img->Height2;  /* without border, power of two */
   GLint i, j;
   (void) ctx;

   i = nearest_texel_location(samp->WrapS, img, width, texcoord[0]);
   j = nearest_texel_location(samp->WrapT, img, height, texcoord[1]);

   /* skip over the border, if any */
   i += img->Border;
   j += img->Border;

   if (i < 0 || i >= (GLint) img->Width || j < 0 || j >= (GLint) img->Height) {
      /* Need this test for GL_CLAMP_TO_BORDER mode */
      get_border_color(samp, img, rgba);
   }
   else {
      swImg->FetchTexel(swImg, i, j, 0, rgba);
   }
}


/**
 * Return the texture sample for coordinate (s,t) using GL_LINEAR filter.
 * New sampling code contributed by Lynn Quam <quam@@ai.sri.com>.
 */
static inline void
sample_2d_linear(struct gl_context *ctx,
                 const struct gl_sampler_object *samp,
                 const struct gl_texture_image *img,
                 const GLfloat texcoord[4],
                 GLfloat rgba[])
{
   const struct swrast_texture_image *swImg = swrast_texture_image_const(img);
   const GLint width = img->Width2;
   const GLint height = img->Height2;
   GLint i0, j0, i1, j1;
   GLbitfield useBorderColor = 0x0;
   GLfloat a, b;
   GLfloat t00[4], t10[4], t01[4], t11[4]; /* sampled texel colors */

   linear_texel_locations(samp->WrapS, img, width, texcoord[0],  &i0, &i1, &a);
   linear_texel_locations(samp->WrapT, img, height, texcoord[1], &j0, &j1, &b);

   if (img->Border) {
      i0 += img->Border;
      i1 += img->Border;
      j0 += img->Border;
      j1 += img->Border;
   }
   else {
      if (i0 < 0 || i0 >= width)   useBorderColor |= I0BIT;
      if (i1 < 0 || i1 >= width)   useBorderColor |= I1BIT;
      if (j0 < 0 || j0 >= height)  useBorderColor |= J0BIT;
      if (j1 < 0 || j1 >= height)  useBorderColor |= J1BIT;
   }

   /* fetch four texel colors */
   if (useBorderColor & (I0BIT | J0BIT)) {
      get_border_color(samp, img, t00);
   }
   else {
      swImg->FetchTexel(swImg, i0, j0, 0, t00);
   }
   if (useBorderColor & (I1BIT | J0BIT)) {
      get_border_color(samp, img, t10);
   }
   else {
      swImg->FetchTexel(swImg, i1, j0, 0, t10);
   }
   if (useBorderColor & (I0BIT | J1BIT)) {
      get_border_color(samp, img, t01);
   }
   else {
      swImg->FetchTexel(swImg, i0, j1, 0, t01);
   }
   if (useBorderColor & (I1BIT | J1BIT)) {
      get_border_color(samp, img, t11);
   }
   else {
      swImg->FetchTexel(swImg, i1, j1, 0, t11);
   }

   lerp_rgba_2d(rgba, a, b, t00, t10, t01, t11);
}


/**
 * As above, but we know WRAP_S == REPEAT and WRAP_T == REPEAT.
 * We don't have to worry about the texture border.
 */
static inline void
sample_2d_linear_repeat(struct gl_context *ctx,
                        const struct gl_sampler_object *samp,
                        const struct gl_texture_image *img,
                        const GLfloat texcoord[4],
                        GLfloat rgba[])
{
   const struct swrast_texture_image *swImg = swrast_texture_image_const(img);
   const GLint width = img->Width2;
   const GLint height = img->Height2;
   GLint i0, j0, i1, j1;
   GLfloat wi, wj;
   GLfloat t00[4], t10[4], t01[4], t11[4]; /* sampled texel colors */

   (void) ctx;

   ASSERT(samp->WrapS == GL_REPEAT);
   ASSERT(samp->WrapT == GL_REPEAT);
   ASSERT(img->Border == 0);
   ASSERT(swImg->_IsPowerOfTwo);

   linear_repeat_texel_location(width,  texcoord[0], &i0, &i1, &wi);
   linear_repeat_texel_location(height, texcoord[1], &j0, &j1, &wj);

   swImg->FetchTexel(swImg, i0, j0, 0, t00);
   swImg->FetchTexel(swImg, i1, j0, 0, t10);
   swImg->FetchTexel(swImg, i0, j1, 0, t01);
   swImg->FetchTexel(swImg, i1, j1, 0, t11);

   lerp_rgba_2d(rgba, wi, wj, t00, t10, t01, t11);
}


static void
sample_2d_nearest_mipmap_nearest(struct gl_context *ctx,
                                 const struct gl_sampler_object *samp,
                                 const struct gl_texture_object *tObj,
                                 GLuint n, const GLfloat texcoord[][4],
                                 const GLfloat lambda[], GLfloat rgba[][4])
{
   GLuint i;
   for (i = 0; i < n; i++) {
      GLint level = nearest_mipmap_level(tObj, lambda[i]);
      sample_2d_nearest(ctx, samp, tObj->Image[0][level], texcoord[i], rgba[i]);
   }
}


static void
sample_2d_linear_mipmap_nearest(struct gl_context *ctx,
                                const struct gl_sampler_object *samp,
                                const struct gl_texture_object *tObj,
                                GLuint n, const GLfloat texcoord[][4],
                                const GLfloat lambda[], GLfloat rgba[][4])
{
   GLuint i;
   ASSERT(lambda != NULL);
   for (i = 0; i < n; i++) {
      GLint level = nearest_mipmap_level(tObj, lambda[i]);
      sample_2d_linear(ctx, samp, tObj->Image[0][level], texcoord[i], rgba[i]);
   }
}


static void
sample_2d_nearest_mipmap_linear(struct gl_context *ctx,
                                const struct gl_sampler_object *samp,
                                const struct gl_texture_object *tObj,
                                GLuint n, const GLfloat texcoord[][4],
                                const GLfloat lambda[], GLfloat rgba[][4])
{
   GLuint i;
   ASSERT(lambda != NULL);
   for (i = 0; i < n; i++) {
      GLint level = linear_mipmap_level(tObj, lambda[i]);
      if (level >= tObj->_MaxLevel) {
         sample_2d_nearest(ctx, samp, tObj->Image[0][tObj->_MaxLevel],
                           texcoord[i], rgba[i]);
      }
      else {
         GLfloat t0[4], t1[4];  /* texels */
         const GLfloat f = FRAC(lambda[i]);
         sample_2d_nearest(ctx, samp, tObj->Image[0][level  ], texcoord[i], t0);
         sample_2d_nearest(ctx, samp, tObj->Image[0][level+1], texcoord[i], t1);
         lerp_rgba(rgba[i], f, t0, t1);
      }
   }
}


static void
sample_2d_linear_mipmap_linear( struct gl_context *ctx,
                                const struct gl_sampler_object *samp,
                                const struct gl_texture_object *tObj,
                                GLuint n, const GLfloat texcoord[][4],
                                const GLfloat lambda[], GLfloat rgba[][4] )
{
   GLuint i;
   ASSERT(lambda != NULL);
   for (i = 0; i < n; i++) {
      GLint level = linear_mipmap_level(tObj, lambda[i]);
      if (level >= tObj->_MaxLevel) {
         sample_2d_linear(ctx, samp, tObj->Image[0][tObj->_MaxLevel],
                          texcoord[i], rgba[i]);
      }
      else {
         GLfloat t0[4], t1[4];  /* texels */
         const GLfloat f = FRAC(lambda[i]);
         sample_2d_linear(ctx, samp, tObj->Image[0][level  ], texcoord[i], t0);
         sample_2d_linear(ctx, samp, tObj->Image[0][level+1], texcoord[i], t1);
         lerp_rgba(rgba[i], f, t0, t1);
      }
   }
}


static void
sample_2d_linear_mipmap_linear_repeat(struct gl_context *ctx,
                                      const struct gl_sampler_object *samp,
                                      const struct gl_texture_object *tObj,
                                      GLuint n, const GLfloat texcoord[][4],
                                      const GLfloat lambda[], GLfloat rgba[][4])
{
   GLuint i;
   ASSERT(lambda != NULL);
   ASSERT(samp->WrapS == GL_REPEAT);
   ASSERT(samp->WrapT == GL_REPEAT);
   for (i = 0; i < n; i++) {
      GLint level = linear_mipmap_level(tObj, lambda[i]);
      if (level >= tObj->_MaxLevel) {
         sample_2d_linear_repeat(ctx, samp, tObj->Image[0][tObj->_MaxLevel],
                                 texcoord[i], rgba[i]);
      }
      else {
         GLfloat t0[4], t1[4];  /* texels */
         const GLfloat f = FRAC(lambda[i]);
         sample_2d_linear_repeat(ctx, samp, tObj->Image[0][level  ],
                                 texcoord[i], t0);
         sample_2d_linear_repeat(ctx, samp, tObj->Image[0][level+1],
                                 texcoord[i], t1);
         lerp_rgba(rgba[i], f, t0, t1);
      }
   }
}


/** Sample 2D texture, nearest filtering for both min/magnification */
static void
sample_nearest_2d(struct gl_context *ctx,
                  const struct gl_sampler_object *samp,
                  const struct gl_texture_object *tObj, GLuint n,
                  const GLfloat texcoords[][4],
                  const GLfloat lambda[], GLfloat rgba[][4])
{
   GLuint i;
   struct gl_texture_image *image = tObj->Image[0][tObj->BaseLevel];
   (void) lambda;
   for (i = 0; i < n; i++) {
      sample_2d_nearest(ctx, samp, image, texcoords[i], rgba[i]);
   }
}


/** Sample 2D texture, linear filtering for both min/magnification */
static void
sample_linear_2d(struct gl_context *ctx,
                 const struct gl_sampler_object *samp,
                 const struct gl_texture_object *tObj, GLuint n,
                 const GLfloat texcoords[][4],
                 const GLfloat lambda[], GLfloat rgba[][4])
{
   GLuint i;
   struct gl_texture_image *image = tObj->Image[0][tObj->BaseLevel];
   const struct swrast_texture_image *swImg = swrast_texture_image_const(image);
   (void) lambda;
   if (samp->WrapS == GL_REPEAT &&
       samp->WrapT == GL_REPEAT &&
       swImg->_IsPowerOfTwo &&
       image->Border == 0) {
      for (i = 0; i < n; i++) {
         sample_2d_linear_repeat(ctx, samp, image, texcoords[i], rgba[i]);
      }
   }
   else {
      for (i = 0; i < n; i++) {
         sample_2d_linear(ctx, samp, image, texcoords[i], rgba[i]);
      }
   }
}


/**
 * Optimized 2-D texture sampling:
 *    S and T wrap mode == GL_REPEAT
 *    GL_NEAREST min/mag filter
 *    No border, 
 *    RowStride == Width,
 *    Format = GL_RGB
 */
static void
opt_sample_rgb_2d(struct gl_context *ctx,
                  const struct gl_sampler_object *samp,
                  const struct gl_texture_object *tObj,
                  GLuint n, const GLfloat texcoords[][4],
                  const GLfloat lambda[], GLfloat rgba[][4])
{
   const struct gl_texture_image *img = tObj->Image[0][tObj->BaseLevel];
   const struct swrast_texture_image *swImg = swrast_texture_image_const(img);
   const GLfloat width = (GLfloat) img->Width;
   const GLfloat height = (GLfloat) img->Height;
   const GLint colMask = img->Width - 1;
   const GLint rowMask = img->Height - 1;
   const GLint shift = img->WidthLog2;
   GLuint k;
   (void) ctx;
   (void) lambda;
   ASSERT(samp->WrapS==GL_REPEAT);
   ASSERT(samp->WrapT==GL_REPEAT);
   ASSERT(img->Border==0);
   ASSERT(img->TexFormat == MESA_FORMAT_BGR_UNORM8);
   ASSERT(swImg->_IsPowerOfTwo);
   (void) swImg;

   for (k=0; k<n; k++) {
      GLint i = IFLOOR(texcoords[k][0] * width) & colMask;
      GLint j = IFLOOR(texcoords[k][1] * height) & rowMask;
      GLint pos = (j << shift) | i;
      GLubyte *texel = (GLubyte *) swImg->ImageSlices[0] + 3 * pos;
      rgba[k][RCOMP] = UBYTE_TO_FLOAT(texel[2]);
      rgba[k][GCOMP] = UBYTE_TO_FLOAT(texel[1]);
      rgba[k][BCOMP] = UBYTE_TO_FLOAT(texel[0]);
      rgba[k][ACOMP] = 1.0F;
   }
}


/**
 * Optimized 2-D texture sampling:
 *    S and T wrap mode == GL_REPEAT
 *    GL_NEAREST min/mag filter
 *    No border
 *    RowStride == Width,
 *    Format = GL_RGBA
 */
static void
opt_sample_rgba_2d(struct gl_context *ctx,
                   const struct gl_sampler_object *samp,
                   const struct gl_texture_object *tObj,
                   GLuint n, const GLfloat texcoords[][4],
                   const GLfloat lambda[], GLfloat rgba[][4])
{
   const struct gl_texture_image *img = tObj->Image[0][tObj->BaseLevel];
   const struct swrast_texture_image *swImg = swrast_texture_image_const(img);
   const GLfloat width = (GLfloat) img->Width;
   const GLfloat height = (GLfloat) img->Height;
   const GLint colMask = img->Width - 1;
   const GLint rowMask = img->Height - 1;
   const GLint shift = img->WidthLog2;
   GLuint i;
   (void) ctx;
   (void) lambda;
   ASSERT(samp->WrapS==GL_REPEAT);
   ASSERT(samp->WrapT==GL_REPEAT);
   ASSERT(img->Border==0);
   ASSERT(img->TexFormat == MESA_FORMAT_A8B8G8R8_UNORM);
   ASSERT(swImg->_IsPowerOfTwo);
   (void) swImg;

   for (i = 0; i < n; i++) {
      const GLint col = IFLOOR(texcoords[i][0] * width) & colMask;
      const GLint row = IFLOOR(texcoords[i][1] * height) & rowMask;
      const GLint pos = (row << shift) | col;
      const GLuint texel = *((GLuint *) swImg->ImageSlices[0] + pos);
      rgba[i][RCOMP] = UBYTE_TO_FLOAT( (texel >> 24)        );
      rgba[i][GCOMP] = UBYTE_TO_FLOAT( (texel >> 16) & 0xff );
      rgba[i][BCOMP] = UBYTE_TO_FLOAT( (texel >>  8) & 0xff );
      rgba[i][ACOMP] = UBYTE_TO_FLOAT( (texel      ) & 0xff );
   }
}


/** Sample 2D texture, using lambda to choose between min/magnification */
static void
sample_lambda_2d(struct gl_context *ctx,
                 const struct gl_sampler_object *samp,
                 const struct gl_texture_object *tObj,
                 GLuint n, const GLfloat texcoords[][4],
                 const GLfloat lambda[], GLfloat rgba[][4])
{
   const struct gl_texture_image *tImg = tObj->Image[0][tObj->BaseLevel];
   const struct swrast_texture_image *swImg = swrast_texture_image_const(tImg);
   GLuint minStart, minEnd;  /* texels with minification */
   GLuint magStart, magEnd;  /* texels with magnification */

   const GLboolean repeatNoBorderPOT = (samp->WrapS == GL_REPEAT)
      && (samp->WrapT == GL_REPEAT)
      && (tImg->Border == 0)
      && (_mesa_format_row_stride(tImg->TexFormat, tImg->Width) ==
          swImg->RowStride)
      && swImg->_IsPowerOfTwo;

   ASSERT(lambda != NULL);
   compute_min_mag_ranges(samp, n, lambda,
                          &minStart, &minEnd, &magStart, &magEnd);

   if (minStart < minEnd) {
      /* do the minified texels */
      const GLuint m = minEnd - minStart;
      switch (samp->MinFilter) {
      case GL_NEAREST:
         if (repeatNoBorderPOT) {
            switch (tImg->TexFormat) {
            case MESA_FORMAT_BGR_UNORM8:
               opt_sample_rgb_2d(ctx, samp, tObj, m, texcoords + minStart,
                                 NULL, rgba + minStart);
               break;
            case MESA_FORMAT_A8B8G8R8_UNORM:
	       opt_sample_rgba_2d(ctx, samp, tObj, m, texcoords + minStart,
                                  NULL, rgba + minStart);
               break;
            default:
               sample_nearest_2d(ctx, samp, tObj, m, texcoords + minStart,
                                 NULL, rgba + minStart );
            }
         }
         else {
            sample_nearest_2d(ctx, samp, tObj, m, texcoords + minStart,
                              NULL, rgba + minStart);
         }
         break;
      case GL_LINEAR:
	 sample_linear_2d(ctx, samp, tObj, m, texcoords + minStart,
			  NULL, rgba + minStart);
         break;
      case GL_NEAREST_MIPMAP_NEAREST:
         sample_2d_nearest_mipmap_nearest(ctx, samp, tObj, m,
                                          texcoords + minStart,
                                          lambda + minStart, rgba + minStart);
         break;
      case GL_LINEAR_MIPMAP_NEAREST:
         sample_2d_linear_mipmap_nearest(ctx, samp, tObj, m, texcoords + minStart,
                                         lambda + minStart, rgba + minStart);
         break;
      case GL_NEAREST_MIPMAP_LINEAR:
         sample_2d_nearest_mipmap_linear(ctx, samp, tObj, m, texcoords + minStart,
                                         lambda + minStart, rgba + minStart);
         break;
      case GL_LINEAR_MIPMAP_LINEAR:
         if (repeatNoBorderPOT)
            sample_2d_linear_mipmap_linear_repeat(ctx, samp, tObj, m,
                  texcoords + minStart, lambda + minStart, rgba + minStart);
         else
            sample_2d_linear_mipmap_linear(ctx, samp, tObj, m, texcoords + minStart,
                                        lambda + minStart, rgba + minStart);
         break;
      default:
         _mesa_problem(ctx, "Bad min filter in sample_2d_texture");
         return;
      }
   }

   if (magStart < magEnd) {
      /* do the magnified texels */
      const GLuint m = magEnd - magStart;

      switch (samp->MagFilter) {
      case GL_NEAREST:
         if (repeatNoBorderPOT) {
            switch (tImg->TexFormat) {
            case MESA_FORMAT_BGR_UNORM8:
               opt_sample_rgb_2d(ctx, samp, tObj, m, texcoords + magStart,
                                 NULL, rgba + magStart);
               break;
            case MESA_FORMAT_A8B8G8R8_UNORM:
	       opt_sample_rgba_2d(ctx, samp, tObj, m, texcoords + magStart,
                                  NULL, rgba + magStart);
               break;
            default:
               sample_nearest_2d(ctx, samp, tObj, m, texcoords + magStart,
                                 NULL, rgba + magStart );
            }
         }
         else {
            sample_nearest_2d(ctx, samp, tObj, m, texcoords + magStart,
                              NULL, rgba + magStart);
         }
         break;
      case GL_LINEAR:
	 sample_linear_2d(ctx, samp, tObj, m, texcoords + magStart,
			  NULL, rgba + magStart);
         break;
      default:
         _mesa_problem(ctx, "Bad mag filter in sample_lambda_2d");
         break;
      }
   }
}


/* For anisotropic filtering */
#define WEIGHT_LUT_SIZE 1024

static GLfloat *weightLut = NULL;

/**
 * Creates the look-up table used to speed-up EWA sampling
 */
static void
create_filter_table(void)
{
   GLuint i;
   if (!weightLut) {
      weightLut = malloc(WEIGHT_LUT_SIZE * sizeof(GLfloat));

      for (i = 0; i < WEIGHT_LUT_SIZE; ++i) {
         GLfloat alpha = 2;
         GLfloat r2 = (GLfloat) i / (GLfloat) (WEIGHT_LUT_SIZE - 1);
         GLfloat weight = (GLfloat) exp(-alpha * r2);
         weightLut[i] = weight;
      }
   }
}


/**
 * Elliptical weighted average (EWA) filter for producing high quality
 * anisotropic filtered results.
 * Based on the Higher Quality Elliptical Weighted Avarage Filter
 * published by Paul S. Heckbert in his Master's Thesis
 * "Fundamentals of Texture Mapping and Image Warping" (1989)
 */
static void
sample_2d_ewa(struct gl_context *ctx,
              const struct gl_sampler_object *samp,
              const struct gl_texture_object *tObj,
              const GLfloat texcoord[4],
              const GLfloat dudx, const GLfloat dvdx,
              const GLfloat dudy, const GLfloat dvdy, const GLint lod,
              GLfloat rgba[])
{
   GLint level = lod > 0 ? lod : 0;
   GLfloat scaling = 1.0f / (1 << level);
   const struct gl_texture_image *img =	tObj->Image[0][level];
   const struct gl_texture_image *mostDetailedImage =
      tObj->Image[0][tObj->BaseLevel];
   const struct swrast_texture_image *swImg =
      swrast_texture_image_const(mostDetailedImage);
   GLfloat tex_u = -0.5f + texcoord[0] * swImg->WidthScale * scaling;
   GLfloat tex_v = -0.5f + texcoord[1] * swImg->HeightScale * scaling;

   GLfloat ux = dudx * scaling;
   GLfloat vx = dvdx * scaling;
   GLfloat uy = dudy * scaling;
   GLfloat vy = dvdy * scaling;

   /* compute ellipse coefficients to bound the region: 
    * A*x*x + B*x*y + C*y*y = F.
    */
   GLfloat A = vx*vx+vy*vy+1;
   GLfloat B = -2*(ux*vx+uy*vy);
   GLfloat C = ux*ux+uy*uy+1;
   GLfloat F = A*C-B*B/4.0f;

   /* check if it is an ellipse */
   /* ASSERT(F > 0.0); */

   /* Compute the ellipse's (u,v) bounding box in texture space */
   GLfloat d = -B*B+4.0f*C*A;
   GLfloat box_u = 2.0f / d * sqrtf(d*C*F); /* box_u -> half of bbox with   */
   GLfloat box_v = 2.0f / d * sqrtf(A*d*F); /* box_v -> half of bbox height */

   GLint u0 = (GLint) floorf(tex_u - box_u);
   GLint u1 = (GLint) ceilf (tex_u + box_u);
   GLint v0 = (GLint) floorf(tex_v - box_v);
   GLint v1 = (GLint) ceilf (tex_v + box_v);

   GLfloat num[4] = {0.0F, 0.0F, 0.0F, 0.0F};
   GLfloat newCoord[2];
   GLfloat den = 0.0F;
   GLfloat ddq;
   GLfloat U = u0 - tex_u;
   GLint v;

   /* Scale ellipse formula to directly index the Filter Lookup Table.
    * i.e. scale so that F = WEIGHT_LUT_SIZE-1
    */
   GLfloat formScale = (GLfloat) (WEIGHT_LUT_SIZE - 1) / F;
   A *= formScale;
   B *= formScale;
   C *= formScale;
   /* F *= formScale; */ /* no need to scale F as we don't use it below here */

   /* Heckbert MS thesis, p. 59; scan over the bounding box of the ellipse
    * and incrementally update the value of Ax^2+Bxy*Cy^2; when this
    * value, q, is less than F, we're inside the ellipse
    */
   ddq = 2 * A;
   for (v = v0; v <= v1; ++v) {
      GLfloat V = v - tex_v;
      GLfloat dq = A * (2 * U + 1) + B * V;
      GLfloat q = (C * V + B * U) * V + A * U * U;

      GLint u;
      for (u = u0; u <= u1; ++u) {
         /* Note that the ellipse has been pre-scaled so F = WEIGHT_LUT_SIZE - 1 */
         if (q < WEIGHT_LUT_SIZE) {
            /* as a LUT is used, q must never be negative;
             * should not happen, though
             */
            const GLint qClamped = q >= 0.0F ? (GLint) q : 0;
            GLfloat weight = weightLut[qClamped];

            newCoord[0] = u / ((GLfloat) img->Width2);
            newCoord[1] = v / ((GLfloat) img->Height2);

            sample_2d_nearest(ctx, samp, img, newCoord, rgba);
            num[0] += weight * rgba[0];
            num[1] += weight * rgba[1];
            num[2] += weight * rgba[2];
            num[3] += weight * rgba[3];

            den += weight;
         }
         q += dq;
         dq += ddq;
      }
   }

   if (den <= 0.0F) {
      /* Reaching this place would mean
       * that no pixels intersected the ellipse.
       * This should never happen because
       * the filter we use always
       * intersects at least one pixel.
       */

      /*rgba[0]=0;
      rgba[1]=0;
      rgba[2]=0;
      rgba[3]=0;*/
      /* not enough pixels in resampling, resort to direct interpolation */
      sample_2d_linear(ctx, samp, img, texcoord, rgba);
      return;
   }

   rgba[0] = num[0] / den;
   rgba[1] = num[1] / den;
   rgba[2] = num[2] / den;
   rgba[3] = num[3] / den;
}


/**
 * Anisotropic filtering using footprint assembly as outlined in the
 * EXT_texture_filter_anisotropic spec:
 * http://www.opengl.org/registry/specs/EXT/texture_filter_anisotropic.txt
 * Faster than EWA but has less quality (more aliasing effects)
 */
static void
sample_2d_footprint(struct gl_context *ctx,
                 const struct gl_sampler_object *samp,
                 const struct gl_texture_object *tObj,
                 const GLfloat texcoord[4],
                 const GLfloat dudx, const GLfloat dvdx,
                 const GLfloat dudy, const GLfloat dvdy, const GLint lod,
                 GLfloat rgba[])
{
   GLint level = lod > 0 ? lod : 0;
   GLfloat scaling = 1.0F / (1 << level);
   const struct gl_texture_image *img = tObj->Image[0][level];

   GLfloat ux = dudx * scaling;
   GLfloat vx = dvdx * scaling;
   GLfloat uy = dudy * scaling;
   GLfloat vy = dvdy * scaling;

   GLfloat Px2 = ux * ux + vx * vx; /* squared length of dx */
   GLfloat Py2 = uy * uy + vy * vy; /* squared length of dy */

   GLint numSamples;
   GLfloat ds;
   GLfloat dt;

   GLfloat num[4] = {0.0F, 0.0F, 0.0F, 0.0F};
   GLfloat newCoord[2];
   GLint s;

   /*  Calculate the per anisotropic sample offsets in s,t space. */
   if (Px2 > Py2) {
      numSamples = (GLint) ceilf(sqrtf(Px2));
      ds = ux / ((GLfloat) img->Width2);
      dt = vx / ((GLfloat) img->Height2);
   }
   else {
      numSamples = (GLint) ceilf(sqrtf(Py2));
      ds = uy / ((GLfloat) img->Width2);
      dt = vy / ((GLfloat) img->Height2);
   }

   for (s = 0; s<numSamples; s++) {
      newCoord[0] = texcoord[0] + ds * ((GLfloat)(s+1) / (numSamples+1) -0.5f);
      newCoord[1] = texcoord[1] + dt * ((GLfloat)(s+1) / (numSamples+1) -0.5f);

      sample_2d_linear(ctx, samp, img, newCoord, rgba);
      num[0] += rgba[0];
      num[1] += rgba[1];
      num[2] += rgba[2];
      num[3] += rgba[3];
   }

   rgba[0] = num[0] / numSamples;
   rgba[1] = num[1] / numSamples;
   rgba[2] = num[2] / numSamples;
   rgba[3] = num[3] / numSamples;
}


/**
 * Returns the index of the specified texture object in the
 * gl_context texture unit array.
 */
static inline GLuint
texture_unit_index(const struct gl_context *ctx,
                   const struct gl_texture_object *tObj)
{
   const GLuint maxUnit
      = (ctx->Texture._EnabledCoordUnits > 1) ? ctx->Const.MaxTextureUnits : 1;
   GLuint u;

   /* XXX CoordUnits vs. ImageUnits */
   for (u = 0; u < maxUnit; u++) {
      if (ctx->Texture.Unit[u]._Current == tObj)
         break; /* found */
   }
   if (u >= maxUnit)
      u = 0; /* not found, use 1st one; should never happen */
   
   return u;
}


/**
 * Sample 2D texture using an anisotropic filter.
 * NOTE: the const GLfloat lambda_iso[] parameter does *NOT* contain
 * the lambda float array but a "hidden" SWspan struct which is required
 * by this function but is not available in the texture_sample_func signature.
 * See _swrast_texture_span( struct gl_context *ctx, SWspan *span ) on how
 * this function is called.
 */
static void
sample_lambda_2d_aniso(struct gl_context *ctx,
                       const struct gl_sampler_object *samp,
                       const struct gl_texture_object *tObj,
                       GLuint n, const GLfloat texcoords[][4],
                       const GLfloat lambda_iso[], GLfloat rgba[][4])
{
   const struct gl_texture_image *tImg = tObj->Image[0][tObj->BaseLevel];
   const struct swrast_texture_image *swImg = swrast_texture_image_const(tImg);
   const GLfloat maxEccentricity =
      samp->MaxAnisotropy * samp->MaxAnisotropy;
   
   /* re-calculate the lambda values so that they are usable with anisotropic
    * filtering
    */
   SWspan *span = (SWspan *)lambda_iso; /* access the "hidden" SWspan struct */

   /* based on interpolate_texcoords(struct gl_context *ctx, SWspan *span)
    * in swrast/s_span.c
    */
   
   /* find the texture unit index by looking up the current texture object
    * from the context list of available texture objects.
    */
   const GLuint u = texture_unit_index(ctx, tObj);
   const GLuint attr = VARYING_SLOT_TEX0 + u;
   GLfloat texW, texH;

   const GLfloat dsdx = span->attrStepX[attr][0];
   const GLfloat dsdy = span->attrStepY[attr][0];
   const GLfloat dtdx = span->attrStepX[attr][1];
   const GLfloat dtdy = span->attrStepY[attr][1];
   const GLfloat dqdx = span->attrStepX[attr][3];
   const GLfloat dqdy = span->attrStepY[attr][3];
   GLfloat s = span->attrStart[attr][0] + span->leftClip * dsdx;
   GLfloat t = span->attrStart[attr][1] + span->leftClip * dtdx;
   GLfloat q = span->attrStart[attr][3] + span->leftClip * dqdx;

   /* from swrast/s_texcombine.c _swrast_texture_span */
   const struct gl_texture_unit *texUnit = &ctx->Texture.Unit[u];
   const GLboolean adjustLOD =
      (texUnit->LodBias + samp->LodBias != 0.0F)
      || (samp->MinLod != -1000.0 || samp->MaxLod != 1000.0);

   GLuint i;
   
   /* on first access create the lookup table containing the filter weights. */
   if (!weightLut) {
      create_filter_table();
   }

   texW = swImg->WidthScale;
   texH = swImg->HeightScale;

   for (i = 0; i < n; i++) {
      const GLfloat invQ = (q == 0.0F) ? 1.0F : (1.0F / q);
      
      GLfloat dudx = texW * ((s + dsdx) / (q + dqdx) - s * invQ);
      GLfloat dvdx = texH * ((t + dtdx) / (q + dqdx) - t * invQ);
      GLfloat dudy = texW * ((s + dsdy) / (q + dqdy) - s * invQ);
      GLfloat dvdy = texH * ((t + dtdy) / (q + dqdy) - t * invQ);
      
      /* note: instead of working with Px and Py, we will use the 
       * squared length instead, to avoid sqrt.
       */
      GLfloat Px2 = dudx * dudx + dvdx * dvdx;
      GLfloat Py2 = dudy * dudy + dvdy * dvdy;

      GLfloat Pmax2;
      GLfloat Pmin2;
      GLfloat e;
      GLfloat lod;

      s += dsdx;
      t += dtdx;
      q += dqdx;
      
      if (Px2 < Py2) {
         Pmax2 = Py2;
         Pmin2 = Px2;
      }
      else {
         Pmax2 = Px2;
         Pmin2 = Py2;
      }
      
      /* if the eccentricity of the ellipse is too big, scale up the shorter
       * of the two vectors to limit the maximum amount of work per pixel
       */
      e = Pmax2 / Pmin2;
      if (e > maxEccentricity) {
         /* GLfloat s=e / maxEccentricity;
            minor[0] *= s;
            minor[1] *= s;
            Pmin2 *= s; */
         Pmin2 = Pmax2 / maxEccentricity;
      }
      
      /* note: we need to have Pmin=sqrt(Pmin2) here, but we can avoid
       * this since 0.5*log(x) = log(sqrt(x))
       */
      lod = 0.5f * LOG2(Pmin2);
      
      if (adjustLOD) {
         /* from swrast/s_texcombine.c _swrast_texture_span */
         if (texUnit->LodBias + samp->LodBias != 0.0F) {
            /* apply LOD bias, but don't clamp yet */
            const GLfloat bias =
               CLAMP(texUnit->LodBias + samp->LodBias,
                     -ctx->Const.MaxTextureLodBias,
                     ctx->Const.MaxTextureLodBias);
            lod += bias;

            if (samp->MinLod != -1000.0 ||
                samp->MaxLod != 1000.0) {
               /* apply LOD clamping to lambda */
               lod = CLAMP(lod, samp->MinLod, samp->MaxLod);
            }
         }
      }
      
      /* If the ellipse covers the whole image, we can
       * simply return the average of the whole image.
       */
      if (lod >= tObj->_MaxLevel) {
         sample_2d_linear(ctx, samp, tObj->Image[0][tObj->_MaxLevel],
                          texcoords[i], rgba[i]);
      }
      else {
         /* don't bother interpolating between multiple LODs; it doesn't
          * seem to be worth the extra running time.
          */
         sample_2d_ewa(ctx, samp, tObj, texcoords[i],
                       dudx, dvdx, dudy, dvdy, (GLint) floorf(lod), rgba[i]);

         /* unused: */
         (void) sample_2d_footprint;
         /*
         sample_2d_footprint(ctx, tObj, texcoords[i],
                             dudx, dvdx, dudy, dvdy, floor(lod), rgba[i]);
         */
      }
   }
}



/**********************************************************************/
/*                    3-D Texture Sampling Functions                  */
/**********************************************************************/

/**
 * Return the texture sample for coordinate (s,t,r) using GL_NEAREST filter.
 */
static inline void
sample_3d_nearest(struct gl_context *ctx,
                  const struct gl_sampler_object *samp,
                  const struct gl_texture_image *img,
                  const GLfloat texcoord[4],
                  GLfloat rgba[4])
{
   const struct swrast_texture_image *swImg = swrast_texture_image_const(img);
   const GLint width = img->Width2;     /* without border, power of two */
   const GLint height = img->Height2;   /* without border, power of two */
   const GLint depth = img->Depth2;     /* without border, power of two */
   GLint i, j, k;
   (void) ctx;

   i = nearest_texel_location(samp->WrapS, img, width, texcoord[0]);
   j = nearest_texel_location(samp->WrapT, img, height, texcoord[1]);
   k = nearest_texel_location(samp->WrapR, img, depth, texcoord[2]);

   if (i < 0 || i >= (GLint) img->Width ||
       j < 0 || j >= (GLint) img->Height ||
       k < 0 || k >= (GLint) img->Depth) {
      /* Need this test for GL_CLAMP_TO_BORDER mode */
      get_border_color(samp, img, rgba);
   }
   else {
      swImg->FetchTexel(swImg, i, j, k, rgba);
   }
}


/**
 * Return the texture sample for coordinate (s,t,r) using GL_LINEAR filter.
 */
static void
sample_3d_linear(struct gl_context *ctx,
                 const struct gl_sampler_object *samp,
                 const struct gl_texture_image *img,
                 const GLfloat texcoord[4],
                 GLfloat rgba[4])
{
   const struct swrast_texture_image *swImg = swrast_texture_image_const(img);
   const GLint width = img->Width2;
   const GLint height = img->Height2;
   const GLint depth = img->Depth2;
   GLint i0, j0, k0, i1, j1, k1;
   GLbitfield useBorderColor = 0x0;
   GLfloat a, b, c;
   GLfloat t000[4], t010[4], t001[4], t011[4];
   GLfloat t100[4], t110[4], t101[4], t111[4];

   linear_texel_locations(samp->WrapS, img, width, texcoord[0],  &i0, &i1, &a);
   linear_texel_locations(samp->WrapT, img, height, texcoord[1], &j0, &j1, &b);
   linear_texel_locations(samp->WrapR, img, depth, texcoord[2],  &k0, &k1, &c);

   if (img->Border) {
      i0 += img->Border;
      i1 += img->Border;
      j0 += img->Border;
      j1 += img->Border;
      k0 += img->Border;
      k1 += img->Border;
   }
   else {
      /* check if sampling texture border color */
      if (i0 < 0 || i0 >= width)   useBorderColor |= I0BIT;
      if (i1 < 0 || i1 >= width)   useBorderColor |= I1BIT;
      if (j0 < 0 || j0 >= height)  useBorderColor |= J0BIT;
      if (j1 < 0 || j1 >= height)  useBorderColor |= J1BIT;
      if (k0 < 0 || k0 >= depth)   useBorderColor |= K0BIT;
      if (k1 < 0 || k1 >= depth)   useBorderColor |= K1BIT;
   }

   /* Fetch texels */
   if (useBorderColor & (I0BIT | J0BIT | K0BIT)) {
      get_border_color(samp, img, t000);
   }
   else {
      swImg->FetchTexel(swImg, i0, j0, k0, t000);
   }
   if (useBorderColor & (I1BIT | J0BIT | K0BIT)) {
      get_border_color(samp, img, t100);
   }
   else {
      swImg->FetchTexel(swImg, i1, j0, k0, t100);
   }
   if (useBorderColor & (I0BIT | J1BIT | K0BIT)) {
      get_border_color(samp, img, t010);
   }
   else {
      swImg->FetchTexel(swImg, i0, j1, k0, t010);
   }
   if (useBorderColor & (I1BIT | J1BIT | K0BIT)) {
      get_border_color(samp, img, t110);
   }
   else {
      swImg->FetchTexel(swImg, i1, j1, k0, t110);
   }

   if (useBorderColor & (I0BIT | J0BIT | K1BIT)) {
      get_border_color(samp, img, t001);
   }
   else {
      swImg->FetchTexel(swImg, i0, j0, k1, t001);
   }
   if (useBorderColor & (I1BIT | J0BIT | K1BIT)) {
      get_border_color(samp, img, t101);
   }
   else {
      swImg->FetchTexel(swImg, i1, j0, k1, t101);
   }
   if (useBorderColor & (I0BIT | J1BIT | K1BIT)) {
      get_border_color(samp, img, t011);
   }
   else {
      swImg->FetchTexel(swImg, i0, j1, k1, t011);
   }
   if (useBorderColor & (I1BIT | J1BIT | K1BIT)) {
      get_border_color(samp, img, t111);
   }
   else {
      swImg->FetchTexel(swImg, i1, j1, k1, t111);
   }

   /* trilinear interpolation of samples */
   lerp_rgba_3d(rgba, a, b, c, t000, t100, t010, t110, t001, t101, t011, t111);
}


static void
sample_3d_nearest_mipmap_nearest(struct gl_context *ctx,
                                 const struct gl_sampler_object *samp,
                                 const struct gl_texture_object *tObj,
                                 GLuint n, const GLfloat texcoord[][4],
                                 const GLfloat lambda[], GLfloat rgba[][4] )
{
   GLuint i;
   for (i = 0; i < n; i++) {
      GLint level = nearest_mipmap_level(tObj, lambda[i]);
      sample_3d_nearest(ctx, samp, tObj->Image[0][level], texcoord[i], rgba[i]);
   }
}


static void
sample_3d_linear_mipmap_nearest(struct gl_context *ctx,
                                const struct gl_sampler_object *samp,
                                const struct gl_texture_object *tObj,
                                GLuint n, const GLfloat texcoord[][4],
                                const GLfloat lambda[], GLfloat rgba[][4])
{
   GLuint i;
   ASSERT(lambda != NULL);
   for (i = 0; i < n; i++) {
      GLint level = nearest_mipmap_level(tObj, lambda[i]);
      sample_3d_linear(ctx, samp, tObj->Image[0][level], texcoord[i], rgba[i]);
   }
}


static void
sample_3d_nearest_mipmap_linear(struct gl_context *ctx,
                                const struct gl_sampler_object *samp,
                                const struct gl_texture_object *tObj,
                                GLuint n, const GLfloat texcoord[][4],
                                const GLfloat lambda[], GLfloat rgba[][4])
{
   GLuint i;
   ASSERT(lambda != NULL);
   for (i = 0; i < n; i++) {
      GLint level = linear_mipmap_level(tObj, lambda[i]);
      if (level >= tObj->_MaxLevel) {
         sample_3d_nearest(ctx, samp, tObj->Image[0][tObj->_MaxLevel],
                           texcoord[i], rgba[i]);
      }
      else {
         GLfloat t0[4], t1[4];  /* texels */
         const GLfloat f = FRAC(lambda[i]);
         sample_3d_nearest(ctx, samp, tObj->Image[0][level  ], texcoord[i], t0);
         sample_3d_nearest(ctx, samp, tObj->Image[0][level+1], texcoord[i], t1);
         lerp_rgba(rgba[i], f, t0, t1);
      }
   }
}


static void
sample_3d_linear_mipmap_linear(struct gl_context *ctx,
                               const struct gl_sampler_object *samp,
                               const struct gl_texture_object *tObj,
                               GLuint n, const GLfloat texcoord[][4],
                               const GLfloat lambda[], GLfloat rgba[][4])
{
   GLuint i;
   ASSERT(lambda != NULL);
   for (i = 0; i < n; i++) {
      GLint level = linear_mipmap_level(tObj, lambda[i]);
      if (level >= tObj->_MaxLevel) {
         sample_3d_linear(ctx, samp, tObj->Image[0][tObj->_MaxLevel],
                          texcoord[i], rgba[i]);
      }
      else {
         GLfloat t0[4], t1[4];  /* texels */
         const GLfloat f = FRAC(lambda[i]);
         sample_3d_linear(ctx, samp, tObj->Image[0][level  ], texcoord[i], t0);
         sample_3d_linear(ctx, samp, tObj->Image[0][level+1], texcoord[i], t1);
         lerp_rgba(rgba[i], f, t0, t1);
      }
   }
}


/** Sample 3D texture, nearest filtering for both min/magnification */
static void
sample_nearest_3d(struct gl_context *ctx,
                  const struct gl_sampler_object *samp,
                  const struct gl_texture_object *tObj, GLuint n,
                  const GLfloat texcoords[][4], const GLfloat lambda[],
                  GLfloat rgba[][4])
{
   GLuint i;
   struct gl_texture_image *image = tObj->Image[0][tObj->BaseLevel];
   (void) lambda;
   for (i = 0; i < n; i++) {
      sample_3d_nearest(ctx, samp, image, texcoords[i], rgba[i]);
   }
}


/** Sample 3D texture, linear filtering for both min/magnification */
static void
sample_linear_3d(struct gl_context *ctx,
                 const struct gl_sampler_object *samp,
                 const struct gl_texture_object *tObj, GLuint n,
                 const GLfloat texcoords[][4],
		 const GLfloat lambda[], GLfloat rgba[][4])
{
   GLuint i;
   struct gl_texture_image *image = tObj->Image[0][tObj->BaseLevel];
   (void) lambda;
   for (i = 0; i < n; i++) {
      sample_3d_linear(ctx, samp, image, texcoords[i], rgba[i]);
   }
}


/** Sample 3D texture, using lambda to choose between min/magnification */
static void
sample_lambda_3d(struct gl_context *ctx,
                 const struct gl_sampler_object *samp,
                 const struct gl_texture_object *tObj, GLuint n,
                 const GLfloat texcoords[][4], const GLfloat lambda[],
                 GLfloat rgba[][4])
{
   GLuint minStart, minEnd;  /* texels with minification */
   GLuint magStart, magEnd;  /* texels with magnification */
   GLuint i;

   ASSERT(lambda != NULL);
   compute_min_mag_ranges(samp, n, lambda,
                          &minStart, &minEnd, &magStart, &magEnd);

   if (minStart < minEnd) {
      /* do the minified texels */
      GLuint m = minEnd - minStart;
      switch (samp->MinFilter) {
      case GL_NEAREST:
         for (i = minStart; i < minEnd; i++)
            sample_3d_nearest(ctx, samp, tObj->Image[0][tObj->BaseLevel],
                              texcoords[i], rgba[i]);
         break;
      case GL_LINEAR:
         for (i = minStart; i < minEnd; i++)
            sample_3d_linear(ctx, samp, tObj->Image[0][tObj->BaseLevel],
                             texcoords[i], rgba[i]);
         break;
      case GL_NEAREST_MIPMAP_NEAREST:
         sample_3d_nearest_mipmap_nearest(ctx, samp, tObj, m, texcoords + minStart,
                                          lambda + minStart, rgba + minStart);
         break;
      case GL_LINEAR_MIPMAP_NEAREST:
         sample_3d_linear_mipmap_nearest(ctx, samp, tObj, m, texcoords + minStart,
                                         lambda + minStart, rgba + minStart);
         break;
      case GL_NEAREST_MIPMAP_LINEAR:
         sample_3d_nearest_mipmap_linear(ctx, samp, tObj, m, texcoords + minStart,
                                         lambda + minStart, rgba + minStart);
         break;
      case GL_LINEAR_MIPMAP_LINEAR:
         sample_3d_linear_mipmap_linear(ctx, samp, tObj, m, texcoords + minStart,
                                        lambda + minStart, rgba + minStart);
         break;
      default:
         _mesa_problem(ctx, "Bad min filter in sample_3d_texture");
         return;
      }
   }

   if (magStart < magEnd) {
      /* do the magnified texels */
      switch (samp->MagFilter) {
      case GL_NEAREST:
         for (i = magStart; i < magEnd; i++)
            sample_3d_nearest(ctx, samp, tObj->Image[0][tObj->BaseLevel],
                              texcoords[i], rgba[i]);
         break;
      case GL_LINEAR:
         for (i = magStart; i < magEnd; i++)
            sample_3d_linear(ctx, samp, tObj->Image[0][tObj->BaseLevel],
                             texcoords[i], rgba[i]);
         break;
      default:
         _mesa_problem(ctx, "Bad mag filter in sample_3d_texture");
         return;
      }
   }
}


/**********************************************************************/
/*                Texture Cube Map Sampling Functions                 */
/**********************************************************************/

/**
 * Choose one of six sides of a texture cube map given the texture
 * coord (rx,ry,rz).  Return pointer to corresponding array of texture
 * images.
 */
static const struct gl_texture_image **
choose_cube_face(const struct gl_texture_object *texObj,
                 const GLfloat texcoord[4], GLfloat newCoord[4])
{
   /*
      major axis
      direction     target                             sc     tc    ma
      ----------    -------------------------------    ---    ---   ---
       +rx          TEXTURE_CUBE_MAP_POSITIVE_X_EXT    -rz    -ry   rx
       -rx          TEXTURE_CUBE_MAP_NEGATIVE_X_EXT    +rz    -ry   rx
       +ry          TEXTURE_CUBE_MAP_POSITIVE_Y_EXT    +rx    +rz   ry
       -ry          TEXTURE_CUBE_MAP_NEGATIVE_Y_EXT    +rx    -rz   ry
       +rz          TEXTURE_CUBE_MAP_POSITIVE_Z_EXT    +rx    -ry   rz
       -rz          TEXTURE_CUBE_MAP_NEGATIVE_Z_EXT    -rx    -ry   rz
   */
   const GLfloat rx = texcoord[0];
   const GLfloat ry = texcoord[1];
   const GLfloat rz = texcoord[2];
   const GLfloat arx = FABSF(rx), ary = FABSF(ry), arz = FABSF(rz);
   GLuint face;
   GLfloat sc, tc, ma;

   if (arx >= ary && arx >= arz) {
      if (rx >= 0.0F) {
         face = FACE_POS_X;
         sc = -rz;
         tc = -ry;
         ma = arx;
      }
      else {
         face = FACE_NEG_X;
         sc = rz;
         tc = -ry;
         ma = arx;
      }
   }
   else if (ary >= arx && ary >= arz) {
      if (ry >= 0.0F) {
         face = FACE_POS_Y;
         sc = rx;
         tc = rz;
         ma = ary;
      }
      else {
         face = FACE_NEG_Y;
         sc = rx;
         tc = -rz;
         ma = ary;
      }
   }
   else {
      if (rz > 0.0F) {
         face = FACE_POS_Z;
         sc = rx;
         tc = -ry;
         ma = arz;
      }
      else {
         face = FACE_NEG_Z;
         sc = -rx;
         tc = -ry;
         ma = arz;
      }
   }

   { 
      const float ima = 1.0F / ma;
      newCoord[0] = ( sc * ima + 1.0F ) * 0.5F;
      newCoord[1] = ( tc * ima + 1.0F ) * 0.5F;
   }

   return (const struct gl_texture_image **) texObj->Image[face];
}


static void
sample_nearest_cube(struct gl_context *ctx,
                    const struct gl_sampler_object *samp,
		    const struct gl_texture_object *tObj, GLuint n,
                    const GLfloat texcoords[][4], const GLfloat lambda[],
                    GLfloat rgba[][4])
{
   GLuint i;
   (void) lambda;
   for (i = 0; i < n; i++) {
      const struct gl_texture_image **images;
      GLfloat newCoord[4];
      images = choose_cube_face(tObj, texcoords[i], newCoord);
      sample_2d_nearest(ctx, samp, images[tObj->BaseLevel],
                        newCoord, rgba[i]);
   }
   if (is_depth_texture(tObj)) {
      for (i = 0; i < n; i++) {
         apply_depth_mode(tObj->DepthMode, rgba[i][0], rgba[i]);
      }
   }
}


static void
sample_linear_cube(struct gl_context *ctx,
                   const struct gl_sampler_object *samp,
		   const struct gl_texture_object *tObj, GLuint n,
                   const GLfloat texcoords[][4],
		   const GLfloat lambda[], GLfloat rgba[][4])
{
   GLuint i;
   (void) lambda;
   for (i = 0; i < n; i++) {
      const struct gl_texture_image **images;
      GLfloat newCoord[4];
      images = choose_cube_face(tObj, texcoords[i], newCoord);
      sample_2d_linear(ctx, samp, images[tObj->BaseLevel],
                       newCoord, rgba[i]);
   }
   if (is_depth_texture(tObj)) {
      for (i = 0; i < n; i++) {
         apply_depth_mode(tObj->DepthMode, rgba[i][0], rgba[i]);
      }
   }
}


static void
sample_cube_nearest_mipmap_nearest(struct gl_context *ctx,
                                   const struct gl_sampler_object *samp,
                                   const struct gl_texture_object *tObj,
                                   GLuint n, const GLfloat texcoord[][4],
                                   const GLfloat lambda[], GLfloat rgba[][4])
{
   GLuint i;
   ASSERT(lambda != NULL);
   for (i = 0; i < n; i++) {
      const struct gl_texture_image **images;
      GLfloat newCoord[4];
      GLint level;
      images = choose_cube_face(tObj, texcoord[i], newCoord);

      /* XXX we actually need to recompute lambda here based on the newCoords.
       * But we would need the texcoords of adjacent fragments to compute that
       * properly, and we don't have those here.
       * For now, do an approximation:  subtracting 1 from the chosen mipmap
       * level seems to work in some test cases.
       * The same adjustment is done in the next few functions.
      */
      level = nearest_mipmap_level(tObj, lambda[i]);
      level = MAX2(level - 1, 0);

      sample_2d_nearest(ctx, samp, images[level], newCoord, rgba[i]);
   }
   if (is_depth_texture(tObj)) {
      for (i = 0; i < n; i++) {
         apply_depth_mode(tObj->DepthMode, rgba[i][0], rgba[i]);
      }
   }
}


static void
sample_cube_linear_mipmap_nearest(struct gl_context *ctx,
                                  const struct gl_sampler_object *samp,
                                  const struct gl_texture_object *tObj,
                                  GLuint n, const GLfloat texcoord[][4],
                                  const GLfloat lambda[], GLfloat rgba[][4])
{
   GLuint i;
   ASSERT(lambda != NULL);
   for (i = 0; i < n; i++) {
      const struct gl_texture_image **images;
      GLfloat newCoord[4];
      GLint level = nearest_mipmap_level(tObj, lambda[i]);
      level = MAX2(level - 1, 0); /* see comment above */
      images = choose_cube_face(tObj, texcoord[i], newCoord);
      sample_2d_linear(ctx, samp, images[level], newCoord, rgba[i]);
   }
   if (is_depth_texture(tObj)) {
      for (i = 0; i < n; i++) {
         apply_depth_mode(tObj->DepthMode, rgba[i][0], rgba[i]);
      }
   }
}


static void
sample_cube_nearest_mipmap_linear(struct gl_context *ctx,
                                  const struct gl_sampler_object *samp,
                                  const struct gl_texture_object *tObj,
                                  GLuint n, const GLfloat texcoord[][4],
                                  const GLfloat lambda[], GLfloat rgba[][4])
{
   GLuint i;
   ASSERT(lambda != NULL);
   for (i = 0; i < n; i++) {
      const struct gl_texture_image **images;
      GLfloat newCoord[4];
      GLint level = linear_mipmap_level(tObj, lambda[i]);
      level = MAX2(level - 1, 0); /* see comment above */
      images = choose_cube_face(tObj, texcoord[i], newCoord);
      if (level >= tObj->_MaxLevel) {
         sample_2d_nearest(ctx, samp, images[tObj->_MaxLevel],
                           newCoord, rgba[i]);
      }
      else {
         GLfloat t0[4], t1[4];  /* texels */
         const GLfloat f = FRAC(lambda[i]);
         sample_2d_nearest(ctx, samp, images[level  ], newCoord, t0);
         sample_2d_nearest(ctx, samp, images[level+1], newCoord, t1);
         lerp_rgba(rgba[i], f, t0, t1);
      }
   }
   if (is_depth_texture(tObj)) {
      for (i = 0; i < n; i++) {
         apply_depth_mode(tObj->DepthMode, rgba[i][0], rgba[i]);
      }
   }
}


static void
sample_cube_linear_mipmap_linear(struct gl_context *ctx,
                                 const struct gl_sampler_object *samp,
                                 const struct gl_texture_object *tObj,
                                 GLuint n, const GLfloat texcoord[][4],
                                 const GLfloat lambda[], GLfloat rgba[][4])
{
   GLuint i;
   ASSERT(lambda != NULL);
   for (i = 0; i < n; i++) {
      const struct gl_texture_image **images;
      GLfloat newCoord[4];
      GLint level = linear_mipmap_level(tObj, lambda[i]);
      level = MAX2(level - 1, 0); /* see comment above */
      images = choose_cube_face(tObj, texcoord[i], newCoord);
      if (level >= tObj->_MaxLevel) {
         sample_2d_linear(ctx, samp, images[tObj->_MaxLevel],
                          newCoord, rgba[i]);
      }
      else {
         GLfloat t0[4], t1[4];
         const GLfloat f = FRAC(lambda[i]);
         sample_2d_linear(ctx, samp, images[level  ], newCoord, t0);
         sample_2d_linear(ctx, samp, images[level+1], newCoord, t1);
         lerp_rgba(rgba[i], f, t0, t1);
      }
   }
   if (is_depth_texture(tObj)) {
      for (i = 0; i < n; i++) {
         apply_depth_mode(tObj->DepthMode, rgba[i][0], rgba[i]);
      }
   }
}


/** Sample cube texture, using lambda to choose between min/magnification */
static void
sample_lambda_cube(struct gl_context *ctx,
                   const struct gl_sampler_object *samp,
		   const struct gl_texture_object *tObj, GLuint n,
		   const GLfloat texcoords[][4], const GLfloat lambda[],
		   GLfloat rgba[][4])
{
   GLuint minStart, minEnd;  /* texels with minification */
   GLuint magStart, magEnd;  /* texels with magnification */

   ASSERT(lambda != NULL);
   compute_min_mag_ranges(samp, n, lambda,
                          &minStart, &minEnd, &magStart, &magEnd);

   if (minStart < minEnd) {
      /* do the minified texels */
      const GLuint m = minEnd - minStart;
      switch (samp->MinFilter) {
      case GL_NEAREST:
         sample_nearest_cube(ctx, samp, tObj, m, texcoords + minStart,
                             lambda + minStart, rgba + minStart);
         break;
      case GL_LINEAR:
         sample_linear_cube(ctx, samp, tObj, m, texcoords + minStart,
                            lambda + minStart, rgba + minStart);
         break;
      case GL_NEAREST_MIPMAP_NEAREST:
         sample_cube_nearest_mipmap_nearest(ctx, samp, tObj, m,
                                            texcoords + minStart,
                                           lambda + minStart, rgba + minStart);
         break;
      case GL_LINEAR_MIPMAP_NEAREST:
         sample_cube_linear_mipmap_nearest(ctx, samp, tObj, m,
                                           texcoords + minStart,
                                           lambda + minStart, rgba + minStart);
         break;
      case GL_NEAREST_MIPMAP_LINEAR:
         sample_cube_nearest_mipmap_linear(ctx, samp, tObj, m,
                                           texcoords + minStart,
                                           lambda + minStart, rgba + minStart);
         break;
      case GL_LINEAR_MIPMAP_LINEAR:
         sample_cube_linear_mipmap_linear(ctx, samp, tObj, m,
                                          texcoords + minStart,
                                          lambda + minStart, rgba + minStart);
         break;
      default:
         _mesa_problem(ctx, "Bad min filter in sample_lambda_cube");
         break;
      }
   }

   if (magStart < magEnd) {
      /* do the magnified texels */
      const GLuint m = magEnd - magStart;
      switch (samp->MagFilter) {
      case GL_NEAREST:
         sample_nearest_cube(ctx, samp, tObj, m, texcoords + magStart,
                             lambda + magStart, rgba + magStart);
         break;
      case GL_LINEAR:
         sample_linear_cube(ctx, samp, tObj, m, texcoords + magStart,
                            lambda + magStart, rgba + magStart);
         break;
      default:
         _mesa_problem(ctx, "Bad mag filter in sample_lambda_cube");
         break;
      }
   }
}


/**********************************************************************/
/*               Texture Rectangle Sampling Functions                 */
/**********************************************************************/


static void
sample_nearest_rect(struct gl_context *ctx,
                    const struct gl_sampler_object *samp,
		    const struct gl_texture_object *tObj, GLuint n,
                    const GLfloat texcoords[][4], const GLfloat lambda[],
                    GLfloat rgba[][4])
{
   const struct gl_texture_image *img = tObj->Image[0][0];
   const struct swrast_texture_image *swImg = swrast_texture_image_const(img);
   const GLint width = img->Width;
   const GLint height = img->Height;
   GLuint i;

   (void) ctx;
   (void) lambda;

   ASSERT(samp->WrapS == GL_CLAMP ||
          samp->WrapS == GL_CLAMP_TO_EDGE ||
          samp->WrapS == GL_CLAMP_TO_BORDER);
   ASSERT(samp->WrapT == GL_CLAMP ||
          samp->WrapT == GL_CLAMP_TO_EDGE ||
          samp->WrapT == GL_CLAMP_TO_BORDER);

   for (i = 0; i < n; i++) {
      GLint row, col;
      col = clamp_rect_coord_nearest(samp->WrapS, texcoords[i][0], width);
      row = clamp_rect_coord_nearest(samp->WrapT, texcoords[i][1], height);
      if (col < 0 || col >= width || row < 0 || row >= height)
         get_border_color(samp, img, rgba[i]);
      else
         swImg->FetchTexel(swImg, col, row, 0, rgba[i]);
   }
}


static void
sample_linear_rect(struct gl_context *ctx,
                   const struct gl_sampler_object *samp,
		   const struct gl_texture_object *tObj, GLuint n,
                   const GLfloat texcoords[][4],
		   const GLfloat lambda[], GLfloat rgba[][4])
{
   const struct gl_texture_image *img = tObj->Image[0][0];
   const struct swrast_texture_image *swImg = swrast_texture_image_const(img);
   const GLint width = img->Width;
   const GLint height = img->Height;
   GLuint i;

   (void) ctx;
   (void) lambda;

   ASSERT(samp->WrapS == GL_CLAMP ||
          samp->WrapS == GL_CLAMP_TO_EDGE ||
          samp->WrapS == GL_CLAMP_TO_BORDER);
   ASSERT(samp->WrapT == GL_CLAMP ||
          samp->WrapT == GL_CLAMP_TO_EDGE ||
          samp->WrapT == GL_CLAMP_TO_BORDER);

   for (i = 0; i < n; i++) {
      GLint i0, j0, i1, j1;
      GLfloat t00[4], t01[4], t10[4], t11[4];
      GLfloat a, b;
      GLbitfield useBorderColor = 0x0;

      clamp_rect_coord_linear(samp->WrapS, texcoords[i][0], width,
                              &i0, &i1, &a);
      clamp_rect_coord_linear(samp->WrapT, texcoords[i][1], height,
                              &j0, &j1, &b);

      /* compute integer rows/columns */
      if (i0 < 0 || i0 >= width)   useBorderColor |= I0BIT;
      if (i1 < 0 || i1 >= width)   useBorderColor |= I1BIT;
      if (j0 < 0 || j0 >= height)  useBorderColor |= J0BIT;
      if (j1 < 0 || j1 >= height)  useBorderColor |= J1BIT;

      /* get four texel samples */
      if (useBorderColor & (I0BIT | J0BIT))
         get_border_color(samp, img, t00);
      else
         swImg->FetchTexel(swImg, i0, j0, 0, t00);

      if (useBorderColor & (I1BIT | J0BIT))
         get_border_color(samp, img, t10);
      else
         swImg->FetchTexel(swImg, i1, j0, 0, t10);

      if (useBorderColor & (I0BIT | J1BIT))
         get_border_color(samp, img, t01);
      else
         swImg->FetchTexel(swImg, i0, j1, 0, t01);

      if (useBorderColor & (I1BIT | J1BIT))
         get_border_color(samp, img, t11);
      else
         swImg->FetchTexel(swImg, i1, j1, 0, t11);

      lerp_rgba_2d(rgba[i], a, b, t00, t10, t01, t11);
   }
}


/** Sample Rect texture, using lambda to choose between min/magnification */
static void
sample_lambda_rect(struct gl_context *ctx,
                   const struct gl_sampler_object *samp,
		   const struct gl_texture_object *tObj, GLuint n,
		   const GLfloat texcoords[][4], const GLfloat lambda[],
		   GLfloat rgba[][4])
{
   GLuint minStart, minEnd, magStart, magEnd;

   /* We only need lambda to decide between minification and magnification.
    * There is no mipmapping with rectangular textures.
    */
   compute_min_mag_ranges(samp, n, lambda,
                          &minStart, &minEnd, &magStart, &magEnd);

   if (minStart < minEnd) {
      if (samp->MinFilter == GL_NEAREST) {
         sample_nearest_rect(ctx, samp, tObj, minEnd - minStart,
                             texcoords + minStart, NULL, rgba + minStart);
      }
      else {
         sample_linear_rect(ctx, samp, tObj, minEnd - minStart,
                            texcoords + minStart, NULL, rgba + minStart);
      }
   }
   if (magStart < magEnd) {
      if (samp->MagFilter == GL_NEAREST) {
         sample_nearest_rect(ctx, samp, tObj, magEnd - magStart,
                             texcoords + magStart, NULL, rgba + magStart);
      }
      else {
         sample_linear_rect(ctx, samp, tObj, magEnd - magStart,
                            texcoords + magStart, NULL, rgba + magStart);
      }
   }
}


/**********************************************************************/
/*                2D Texture Array Sampling Functions                 */
/**********************************************************************/

/**
 * Return the texture sample for coordinate (s,t,r) using GL_NEAREST filter.
 */
static void
sample_2d_array_nearest(struct gl_context *ctx,
                        const struct gl_sampler_object *samp,
                        const struct gl_texture_image *img,
                        const GLfloat texcoord[4],
                        GLfloat rgba[4])
{
   const struct swrast_texture_image *swImg = swrast_texture_image_const(img);
   const GLint width = img->Width2;     /* without border, power of two */
   const GLint height = img->Height2;   /* without border, power of two */
   const GLint depth = img->Depth;
   GLint i, j;
   GLint array;
   (void) ctx;

   i = nearest_texel_location(samp->WrapS, img, width, texcoord[0]);
   j = nearest_texel_location(samp->WrapT, img, height, texcoord[1]);
   array = tex_array_slice(texcoord[2], depth);

   if (i < 0 || i >= (GLint) img->Width ||
       j < 0 || j >= (GLint) img->Height ||
       array < 0 || array >= (GLint) img->Depth) {
      /* Need this test for GL_CLAMP_TO_BORDER mode */
      get_border_color(samp, img, rgba);
   }
   else {
      swImg->FetchTexel(swImg, i, j, array, rgba);
   }
}


/**
 * Return the texture sample for coordinate (s,t,r) using GL_LINEAR filter.
 */
static void
sample_2d_array_linear(struct gl_context *ctx,
                       const struct gl_sampler_object *samp,
                       const struct gl_texture_image *img,
                       const GLfloat texcoord[4],
                       GLfloat rgba[4])
{
   const struct swrast_texture_image *swImg = swrast_texture_image_const(img);
   const GLint width = img->Width2;
   const GLint height = img->Height2;
   const GLint depth = img->Depth;
   GLint i0, j0, i1, j1;
   GLint array;
   GLbitfield useBorderColor = 0x0;
   GLfloat a, b;
   GLfloat t00[4], t01[4], t10[4], t11[4];

   linear_texel_locations(samp->WrapS, img, width,  texcoord[0], &i0, &i1, &a);
   linear_texel_locations(samp->WrapT, img, height, texcoord[1], &j0, &j1, &b);
   array = tex_array_slice(texcoord[2], depth);

   if (array < 0 || array >= depth) {
      COPY_4V(rgba, samp->BorderColor.f);
   }
   else {
      if (img->Border) {
	 i0 += img->Border;
	 i1 += img->Border;
	 j0 += img->Border;
	 j1 += img->Border;
      }
      else {
	 /* check if sampling texture border color */
	 if (i0 < 0 || i0 >= width)   useBorderColor |= I0BIT;
	 if (i1 < 0 || i1 >= width)   useBorderColor |= I1BIT;
	 if (j0 < 0 || j0 >= height)  useBorderColor |= J0BIT;
	 if (j1 < 0 || j1 >= height)  useBorderColor |= J1BIT;
      }

      /* Fetch texels */
      if (useBorderColor & (I0BIT | J0BIT)) {
         get_border_color(samp, img, t00);
      }
      else {
	 swImg->FetchTexel(swImg, i0, j0, array, t00);
      }
      if (useBorderColor & (I1BIT | J0BIT)) {
         get_border_color(samp, img, t10);
      }
      else {
	 swImg->FetchTexel(swImg, i1, j0, array, t10);
      }
      if (useBorderColor & (I0BIT | J1BIT)) {
         get_border_color(samp, img, t01);
      }
      else {
	 swImg->FetchTexel(swImg, i0, j1, array, t01);
      }
      if (useBorderColor & (I1BIT | J1BIT)) {
         get_border_color(samp, img, t11);
      }
      else {
	 swImg->FetchTexel(swImg, i1, j1, array, t11);
      }
      
      /* trilinear interpolation of samples */
      lerp_rgba_2d(rgba, a, b, t00, t10, t01, t11);
   }
}


static void
sample_2d_array_nearest_mipmap_nearest(struct gl_context *ctx,
                                       const struct gl_sampler_object *samp,
                                       const struct gl_texture_object *tObj,
                                       GLuint n, const GLfloat texcoord[][4],
                                       const GLfloat lambda[], GLfloat rgba[][4])
{
   GLuint i;
   for (i = 0; i < n; i++) {
      GLint level = nearest_mipmap_level(tObj, lambda[i]);
      sample_2d_array_nearest(ctx, samp, tObj->Image[0][level], texcoord[i],
                              rgba[i]);
   }
}


static void
sample_2d_array_linear_mipmap_nearest(struct gl_context *ctx,
                                      const struct gl_sampler_object *samp,
                                      const struct gl_texture_object *tObj,
                                      GLuint n, const GLfloat texcoord[][4],
                                      const GLfloat lambda[], GLfloat rgba[][4])
{
   GLuint i;
   ASSERT(lambda != NULL);
   for (i = 0; i < n; i++) {
      GLint level = nearest_mipmap_level(tObj, lambda[i]);
      sample_2d_array_linear(ctx, samp, tObj->Image[0][level],
                             texcoord[i], rgba[i]);
   }
}


static void
sample_2d_array_nearest_mipmap_linear(struct gl_context *ctx,
                                      const struct gl_sampler_object *samp,
                                      const struct gl_texture_object *tObj,
                                      GLuint n, const GLfloat texcoord[][4],
                                      const GLfloat lambda[], GLfloat rgba[][4])
{
   GLuint i;
   ASSERT(lambda != NULL);
   for (i = 0; i < n; i++) {
      GLint level = linear_mipmap_level(tObj, lambda[i]);
      if (level >= tObj->_MaxLevel) {
         sample_2d_array_nearest(ctx, samp, tObj->Image[0][tObj->_MaxLevel],
                                 texcoord[i], rgba[i]);
      }
      else {
         GLfloat t0[4], t1[4];  /* texels */
         const GLfloat f = FRAC(lambda[i]);
         sample_2d_array_nearest(ctx, samp, tObj->Image[0][level  ],
                                 texcoord[i], t0);
         sample_2d_array_nearest(ctx, samp, tObj->Image[0][level+1],
                                 texcoord[i], t1);
         lerp_rgba(rgba[i], f, t0, t1);
      }
   }
}


static void
sample_2d_array_linear_mipmap_linear(struct gl_context *ctx,
                                     const struct gl_sampler_object *samp,
                                     const struct gl_texture_object *tObj,
                                     GLuint n, const GLfloat texcoord[][4],
                                     const GLfloat lambda[], GLfloat rgba[][4])
{
   GLuint i;
   ASSERT(lambda != NULL);
   for (i = 0; i < n; i++) {
      GLint level = linear_mipmap_level(tObj, lambda[i]);
      if (level >= tObj->_MaxLevel) {
         sample_2d_array_linear(ctx, samp, tObj->Image[0][tObj->_MaxLevel],
                          texcoord[i], rgba[i]);
      }
      else {
         GLfloat t0[4], t1[4];  /* texels */
         const GLfloat f = FRAC(lambda[i]);
         sample_2d_array_linear(ctx, samp, tObj->Image[0][level  ],
                                texcoord[i], t0);
         sample_2d_array_linear(ctx, samp, tObj->Image[0][level+1],
                                texcoord[i], t1);
         lerp_rgba(rgba[i], f, t0, t1);
      }
   }
}


/** Sample 2D Array texture, nearest filtering for both min/magnification */
static void
sample_nearest_2d_array(struct gl_context *ctx,
                        const struct gl_sampler_object *samp,
                        const struct gl_texture_object *tObj, GLuint n,
                        const GLfloat texcoords[][4], const GLfloat lambda[],
                        GLfloat rgba[][4])
{
   GLuint i;
   struct gl_texture_image *image = tObj->Image[0][tObj->BaseLevel];
   (void) lambda;
   for (i = 0; i < n; i++) {
      sample_2d_array_nearest(ctx, samp, image, texcoords[i], rgba[i]);
   }
}



/** Sample 2D Array texture, linear filtering for both min/magnification */
static void
sample_linear_2d_array(struct gl_context *ctx,
                       const struct gl_sampler_object *samp,
                       const struct gl_texture_object *tObj, GLuint n,
                       const GLfloat texcoords[][4],
                       const GLfloat lambda[], GLfloat rgba[][4])
{
   GLuint i;
   struct gl_texture_image *image = tObj->Image[0][tObj->BaseLevel];
   (void) lambda;
   for (i = 0; i < n; i++) {
      sample_2d_array_linear(ctx, samp, image, texcoords[i], rgba[i]);
   }
}


/** Sample 2D Array texture, using lambda to choose between min/magnification */
static void
sample_lambda_2d_array(struct gl_context *ctx,
                       const struct gl_sampler_object *samp,
                       const struct gl_texture_object *tObj, GLuint n,
                       const GLfloat texcoords[][4], const GLfloat lambda[],
                       GLfloat rgba[][4])
{
   GLuint minStart, minEnd;  /* texels with minification */
   GLuint magStart, magEnd;  /* texels with magnification */
   GLuint i;

   ASSERT(lambda != NULL);
   compute_min_mag_ranges(samp, n, lambda,
                          &minStart, &minEnd, &magStart, &magEnd);

   if (minStart < minEnd) {
      /* do the minified texels */
      GLuint m = minEnd - minStart;
      switch (samp->MinFilter) {
      case GL_NEAREST:
         for (i = minStart; i < minEnd; i++)
            sample_2d_array_nearest(ctx, samp, tObj->Image[0][tObj->BaseLevel],
                                    texcoords[i], rgba[i]);
         break;
      case GL_LINEAR:
         for (i = minStart; i < minEnd; i++)
            sample_2d_array_linear(ctx, samp, tObj->Image[0][tObj->BaseLevel],
                                   texcoords[i], rgba[i]);
         break;
      case GL_NEAREST_MIPMAP_NEAREST:
         sample_2d_array_nearest_mipmap_nearest(ctx, samp, tObj, m,
                                                texcoords + minStart,
                                                lambda + minStart,
                                                rgba + minStart);
         break;
      case GL_LINEAR_MIPMAP_NEAREST:
         sample_2d_array_linear_mipmap_nearest(ctx, samp, tObj, m,
                                               texcoords + minStart,
                                               lambda + minStart,
                                               rgba + minStart);
         break;
      case GL_NEAREST_MIPMAP_LINEAR:
         sample_2d_array_nearest_mipmap_linear(ctx, samp, tObj, m,
                                               texcoords + minStart,
                                               lambda + minStart,
                                               rgba + minStart);
         break;
      case GL_LINEAR_MIPMAP_LINEAR:
         sample_2d_array_linear_mipmap_linear(ctx, samp, tObj, m,
                                              texcoords + minStart,
                                              lambda + minStart, 
                                              rgba + minStart);
         break;
      default:
         _mesa_problem(ctx, "Bad min filter in sample_2d_array_texture");
         return;
      }
   }

   if (magStart < magEnd) {
      /* do the magnified texels */
      switch (samp->MagFilter) {
      case GL_NEAREST:
         for (i = magStart; i < magEnd; i++)
            sample_2d_array_nearest(ctx, samp, tObj->Image[0][tObj->BaseLevel],
                              texcoords[i], rgba[i]);
         break;
      case GL_LINEAR:
         for (i = magStart; i < magEnd; i++)
            sample_2d_array_linear(ctx, samp, tObj->Image[0][tObj->BaseLevel],
                                   texcoords[i], rgba[i]);
         break;
      default:
         _mesa_problem(ctx, "Bad mag filter in sample_2d_array_texture");
         return;
      }
   }
}




/**********************************************************************/
/*                1D Texture Array Sampling Functions                 */
/**********************************************************************/

/**
 * Return the texture sample for coordinate (s,t,r) using GL_NEAREST filter.
 */
static void
sample_1d_array_nearest(struct gl_context *ctx,
                        const struct gl_sampler_object *samp,
                        const struct gl_texture_image *img,
                        const GLfloat texcoord[4],
                        GLfloat rgba[4])
{
   const struct swrast_texture_image *swImg = swrast_texture_image_const(img);
   const GLint width = img->Width2;     /* without border, power of two */
   const GLint height = img->Height;
   GLint i;
   GLint array;
   (void) ctx;

   i = nearest_texel_location(samp->WrapS, img, width, texcoord[0]);
   array = tex_array_slice(texcoord[1], height);

   if (i < 0 || i >= (GLint) img->Width ||
       array < 0 || array >= (GLint) img->Height) {
      /* Need this test for GL_CLAMP_TO_BORDER mode */
      get_border_color(samp, img, rgba);
   }
   else {
      swImg->FetchTexel(swImg, i, array, 0, rgba);
   }
}


/**
 * Return the texture sample for coordinate (s,t,r) using GL_LINEAR filter.
 */
static void
sample_1d_array_linear(struct gl_context *ctx,
                       const struct gl_sampler_object *samp,
                       const struct gl_texture_image *img,
                       const GLfloat texcoord[4],
                       GLfloat rgba[4])
{
   const struct swrast_texture_image *swImg = swrast_texture_image_const(img);
   const GLint width = img->Width2;
   const GLint height = img->Height;
   GLint i0, i1;
   GLint array;
   GLbitfield useBorderColor = 0x0;
   GLfloat a;
   GLfloat t0[4], t1[4];

   linear_texel_locations(samp->WrapS, img, width, texcoord[0], &i0, &i1, &a);
   array = tex_array_slice(texcoord[1], height);

   if (img->Border) {
      i0 += img->Border;
      i1 += img->Border;
   }
   else {
      /* check if sampling texture border color */
      if (i0 < 0 || i0 >= width)   useBorderColor |= I0BIT;
      if (i1 < 0 || i1 >= width)   useBorderColor |= I1BIT;
   }

   if (array < 0 || array >= height)   useBorderColor |= K0BIT;

   /* Fetch texels */
   if (useBorderColor & (I0BIT | K0BIT)) {
      get_border_color(samp, img, t0);
   }
   else {
      swImg->FetchTexel(swImg, i0, array, 0, t0);
   }
   if (useBorderColor & (I1BIT | K0BIT)) {
      get_border_color(samp, img, t1);
   }
   else {
      swImg->FetchTexel(swImg, i1, array, 0, t1);
   }

   /* bilinear interpolation of samples */
   lerp_rgba(rgba, a, t0, t1);
}


static void
sample_1d_array_nearest_mipmap_nearest(struct gl_context *ctx,
                                       const struct gl_sampler_object *samp,
                                       const struct gl_texture_object *tObj,
                                       GLuint n, const GLfloat texcoord[][4],
                                       const GLfloat lambda[], GLfloat rgba[][4])
{
   GLuint i;
   for (i = 0; i < n; i++) {
      GLint level = nearest_mipmap_level(tObj, lambda[i]);
      sample_1d_array_nearest(ctx, samp, tObj->Image[0][level], texcoord[i],
                              rgba[i]);
   }
}


static void
sample_1d_array_linear_mipmap_nearest(struct gl_context *ctx,
                                      const struct gl_sampler_object *samp,
                                      const struct gl_texture_object *tObj,
                                      GLuint n, const GLfloat texcoord[][4],
                                      const GLfloat lambda[], GLfloat rgba[][4])
{
   GLuint i;
   ASSERT(lambda != NULL);
   for (i = 0; i < n; i++) {
      GLint level = nearest_mipmap_level(tObj, lambda[i]);
      sample_1d_array_linear(ctx, samp, tObj->Image[0][level],
                             texcoord[i], rgba[i]);
   }
}


static void
sample_1d_array_nearest_mipmap_linear(struct gl_context *ctx,
                                      const struct gl_sampler_object *samp,
                                      const struct gl_texture_object *tObj,
                                      GLuint n, const GLfloat texcoord[][4],
                                      const GLfloat lambda[], GLfloat rgba[][4])
{
   GLuint i;
   ASSERT(lambda != NULL);
   for (i = 0; i < n; i++) {
      GLint level = linear_mipmap_level(tObj, lambda[i]);
      if (level >= tObj->_MaxLevel) {
         sample_1d_array_nearest(ctx, samp, tObj->Image[0][tObj->_MaxLevel],
                                 texcoord[i], rgba[i]);
      }
      else {
         GLfloat t0[4], t1[4];  /* texels */
         const GLfloat f = FRAC(lambda[i]);
         sample_1d_array_nearest(ctx, samp, tObj->Image[0][level  ], texcoord[i], t0);
         sample_1d_array_nearest(ctx, samp, tObj->Image[0][level+1], texcoord[i], t1);
         lerp_rgba(rgba[i], f, t0, t1);
      }
   }
}


static void
sample_1d_array_linear_mipmap_linear(struct gl_context *ctx,
                                     const struct gl_sampler_object *samp,
                                     const struct gl_texture_object *tObj,
                                     GLuint n, const GLfloat texcoord[][4],
                                     const GLfloat lambda[], GLfloat rgba[][4])
{
   GLuint i;
   ASSERT(lambda != NULL);
   for (i = 0; i < n; i++) {
      GLint level = linear_mipmap_level(tObj, lambda[i]);
      if (level >= tObj->_MaxLevel) {
         sample_1d_array_linear(ctx, samp, tObj->Image[0][tObj->_MaxLevel],
                          texcoord[i], rgba[i]);
      }
      else {
         GLfloat t0[4], t1[4];  /* texels */
         const GLfloat f = FRAC(lambda[i]);
         sample_1d_array_linear(ctx, samp, tObj->Image[0][level  ], texcoord[i], t0);
         sample_1d_array_linear(ctx, samp, tObj->Image[0][level+1], texcoord[i], t1);
         lerp_rgba(rgba[i], f, t0, t1);
      }
   }
}


/** Sample 1D Array texture, nearest filtering for both min/magnification */
static void
sample_nearest_1d_array(struct gl_context *ctx,
                        const struct gl_sampler_object *samp,
                        const struct gl_texture_object *tObj, GLuint n,
                        const GLfloat texcoords[][4], const GLfloat lambda[],
                        GLfloat rgba[][4])
{
   GLuint i;
   struct gl_texture_image *image = tObj->Image[0][tObj->BaseLevel];
   (void) lambda;
   for (i = 0; i < n; i++) {
      sample_1d_array_nearest(ctx, samp, image, texcoords[i], rgba[i]);
   }
}


/** Sample 1D Array texture, linear filtering for both min/magnification */
static void
sample_linear_1d_array(struct gl_context *ctx,
                       const struct gl_sampler_object *samp,
                       const struct gl_texture_object *tObj, GLuint n,
                       const GLfloat texcoords[][4],
                       const GLfloat lambda[], GLfloat rgba[][4])
{
   GLuint i;
   struct gl_texture_image *image = tObj->Image[0][tObj->BaseLevel];
   (void) lambda;
   for (i = 0; i < n; i++) {
      sample_1d_array_linear(ctx, samp, image, texcoords[i], rgba[i]);
   }
}


/** Sample 1D Array texture, using lambda to choose between min/magnification */
static void
sample_lambda_1d_array(struct gl_context *ctx,
                       const struct gl_sampler_object *samp,
                       const struct gl_texture_object *tObj, GLuint n,
                       const GLfloat texcoords[][4], const GLfloat lambda[],
                       GLfloat rgba[][4])
{
   GLuint minStart, minEnd;  /* texels with minification */
   GLuint magStart, magEnd;  /* texels with magnification */
   GLuint i;

   ASSERT(lambda != NULL);
   compute_min_mag_ranges(samp, n, lambda,
                          &minStart, &minEnd, &magStart, &magEnd);

   if (minStart < minEnd) {
      /* do the minified texels */
      GLuint m = minEnd - minStart;
      switch (samp->MinFilter) {
      case GL_NEAREST:
         for (i = minStart; i < minEnd; i++)
            sample_1d_array_nearest(ctx, samp, tObj->Image[0][tObj->BaseLevel],
                                    texcoords[i], rgba[i]);
         break;
      case GL_LINEAR:
         for (i = minStart; i < minEnd; i++)
            sample_1d_array_linear(ctx, samp, tObj->Image[0][tObj->BaseLevel],
                                   texcoords[i], rgba[i]);
         break;
      case GL_NEAREST_MIPMAP_NEAREST:
         sample_1d_array_nearest_mipmap_nearest(ctx, samp, tObj, m, texcoords + minStart,
                                                lambda + minStart, rgba + minStart);
         break;
      case GL_LINEAR_MIPMAP_NEAREST:
         sample_1d_array_linear_mipmap_nearest(ctx, samp, tObj, m, 
                                               texcoords + minStart,
                                               lambda + minStart,
                                               rgba + minStart);
         break;
      case GL_NEAREST_MIPMAP_LINEAR:
         sample_1d_array_nearest_mipmap_linear(ctx, samp, tObj, m, texcoords + minStart,
                                               lambda + minStart, rgba + minStart);
         break;
      case GL_LINEAR_MIPMAP_LINEAR:
         sample_1d_array_linear_mipmap_linear(ctx, samp, tObj, m, 
                                              texcoords + minStart,
                                              lambda + minStart, 
                                              rgba + minStart);
         break;
      default:
         _mesa_problem(ctx, "Bad min filter in sample_1d_array_texture");
         return;
      }
   }

   if (magStart < magEnd) {
      /* do the magnified texels */
      switch (samp->MagFilter) {
      case GL_NEAREST:
         for (i = magStart; i < magEnd; i++)
            sample_1d_array_nearest(ctx, samp, tObj->Image[0][tObj->BaseLevel],
                              texcoords[i], rgba[i]);
         break;
      case GL_LINEAR:
         for (i = magStart; i < magEnd; i++)
            sample_1d_array_linear(ctx, samp, tObj->Image[0][tObj->BaseLevel],
                                   texcoords[i], rgba[i]);
         break;
      default:
         _mesa_problem(ctx, "Bad mag filter in sample_1d_array_texture");
         return;
      }
   }
}


/**
 * Compare texcoord against depth sample.  Return 1.0 or 0.0 value.
 */
static inline GLfloat
shadow_compare(GLenum function, GLfloat coord, GLfloat depthSample)
{
   switch (function) {
   case GL_LEQUAL:
      return (coord <= depthSample) ? 1.0F : 0.0F;
   case GL_GEQUAL:
      return (coord >= depthSample) ? 1.0F : 0.0F;
   case GL_LESS:
      return (coord < depthSample) ? 1.0F : 0.0F;
   case GL_GREATER:
      return (coord > depthSample) ? 1.0F : 0.0F;
   case GL_EQUAL:
      return (coord == depthSample) ? 1.0F : 0.0F;
   case GL_NOTEQUAL:
      return (coord != depthSample) ? 1.0F : 0.0F;
   case GL_ALWAYS:
      return 1.0F;
   case GL_NEVER:
      return 0.0F;
   case GL_NONE:
      return depthSample;
   default:
      _mesa_problem(NULL, "Bad compare func in shadow_compare");
      return 0.0F;
   }
}


/**
 * Compare texcoord against four depth samples.
 */
static inline GLfloat
shadow_compare4(GLenum function, GLfloat coord,
                GLfloat depth00, GLfloat depth01,
                GLfloat depth10, GLfloat depth11,
                GLfloat wi, GLfloat wj)
{
   const GLfloat d = 0.25F;
   GLfloat luminance = 1.0F;

   switch (function) {
   case GL_LEQUAL:
      if (coord > depth00)  luminance -= d;
      if (coord > depth01)  luminance -= d;
      if (coord > depth10)  luminance -= d;
      if (coord > depth11)  luminance -= d;
      return luminance;
   case GL_GEQUAL:
      if (coord < depth00)  luminance -= d;
      if (coord < depth01)  luminance -= d;
      if (coord < depth10)  luminance -= d;
      if (coord < depth11)  luminance -= d;
      return luminance;
   case GL_LESS:
      if (coord >= depth00)  luminance -= d;
      if (coord >= depth01)  luminance -= d;
      if (coord >= depth10)  luminance -= d;
      if (coord >= depth11)  luminance -= d;
      return luminance;
   case GL_GREATER:
      if (coord <= depth00)  luminance -= d;
      if (coord <= depth01)  luminance -= d;
      if (coord <= depth10)  luminance -= d;
      if (coord <= depth11)  luminance -= d;
      return luminance;
   case GL_EQUAL:
      if (coord != depth00)  luminance -= d;
      if (coord != depth01)  luminance -= d;
      if (coord != depth10)  luminance -= d;
      if (coord != depth11)  luminance -= d;
      return luminance;
   case GL_NOTEQUAL:
      if (coord == depth00)  luminance -= d;
      if (coord == depth01)  luminance -= d;
      if (coord == depth10)  luminance -= d;
      if (coord == depth11)  luminance -= d;
      return luminance;
   case GL_ALWAYS:
      return 1.0F;
   case GL_NEVER:
      return 0.0F;
   case GL_NONE:
      /* ordinary bilinear filtering */
      return lerp_2d(wi, wj, depth00, depth10, depth01, depth11);
   default:
      _mesa_problem(NULL, "Bad compare func in sample_compare4");
      return 0.0F;
   }
}


/**
 * Choose the mipmap level to use when sampling from a depth texture.
 */
static int
choose_depth_texture_level(const struct gl_sampler_object *samp,
                           const struct gl_texture_object *tObj, GLfloat lambda)
{
   GLint level;

   if (samp->MinFilter == GL_NEAREST || samp->MinFilter == GL_LINEAR) {
      /* no mipmapping - use base level */
      level = tObj->BaseLevel;
   }
   else {
      /* choose mipmap level */
      lambda = CLAMP(lambda, samp->MinLod, samp->MaxLod);
      level = (GLint) lambda;
      level = CLAMP(level, tObj->BaseLevel, tObj->_MaxLevel);
   }

   return level;
}


/**
 * Sample a shadow/depth texture.  This function is incomplete.  It doesn't
 * check for minification vs. magnification, etc.
 */
static void
sample_depth_texture( struct gl_context *ctx,
                      const struct gl_sampler_object *samp,
                      const struct gl_texture_object *tObj, GLuint n,
                      const GLfloat texcoords[][4], const GLfloat lambda[],
                      GLfloat texel[][4] )
{
   const GLint level = choose_depth_texture_level(samp, tObj, lambda[0]);
   const struct gl_texture_image *img = tObj->Image[0][level];
   const struct swrast_texture_image *swImg = swrast_texture_image_const(img);
   const GLint width = img->Width;
   const GLint height = img->Height;
   const GLint depth = img->Depth;
   const GLuint compare_coord = (tObj->Target == GL_TEXTURE_2D_ARRAY_EXT)
       ? 3 : 2;
   GLenum function;
   GLfloat result;

   ASSERT(img->_BaseFormat == GL_DEPTH_COMPONENT ||
          img->_BaseFormat == GL_DEPTH_STENCIL_EXT);

   ASSERT(tObj->Target == GL_TEXTURE_1D ||
          tObj->Target == GL_TEXTURE_2D ||
          tObj->Target == GL_TEXTURE_RECTANGLE_NV ||
          tObj->Target == GL_TEXTURE_1D_ARRAY_EXT ||
          tObj->Target == GL_TEXTURE_2D_ARRAY_EXT ||
          tObj->Target == GL_TEXTURE_CUBE_MAP);

   /* XXXX if samp->MinFilter != samp->MagFilter, we're ignoring lambda */

   function = (samp->CompareMode == GL_COMPARE_R_TO_TEXTURE_ARB) ?
      samp->CompareFunc : GL_NONE;

   if (samp->MagFilter == GL_NEAREST) {
      GLuint i;
      for (i = 0; i < n; i++) {
         GLfloat depthSample, depthRef;
         GLint col, row, slice;

         nearest_texcoord(samp, tObj, level, texcoords[i], &col, &row, &slice);

         if (col >= 0 && row >= 0 && col < width && row < height && 
             slice >= 0 && slice < depth) {
            swImg->FetchTexel(swImg, col, row, slice, &depthSample);
         }
         else {
            depthSample = samp->BorderColor.f[0];
         }

         depthRef = CLAMP(texcoords[i][compare_coord], 0.0F, 1.0F);

         result = shadow_compare(function, depthRef, depthSample);

         apply_depth_mode(tObj->DepthMode, result, texel[i]);
      }
   }
   else {
      GLuint i;
      ASSERT(samp->MagFilter == GL_LINEAR);
      for (i = 0; i < n; i++) {
         GLfloat depth00, depth01, depth10, depth11, depthRef;
         GLint i0, i1, j0, j1;
         GLint slice;
         GLfloat wi, wj;
         GLuint useBorderTexel;

         linear_texcoord(samp, tObj, level, texcoords[i], &i0, &i1, &j0, &j1, &slice,
                         &wi, &wj);

         useBorderTexel = 0;
         if (img->Border) {
            i0 += img->Border;
            i1 += img->Border;
            if (tObj->Target != GL_TEXTURE_1D_ARRAY_EXT) {
               j0 += img->Border;
               j1 += img->Border;
            }
         }
         else {
            if (i0 < 0 || i0 >= (GLint) width)   useBorderTexel |= I0BIT;
            if (i1 < 0 || i1 >= (GLint) width)   useBorderTexel |= I1BIT;
            if (j0 < 0 || j0 >= (GLint) height)  useBorderTexel |= J0BIT;
            if (j1 < 0 || j1 >= (GLint) height)  useBorderTexel |= J1BIT;
         }

         if (slice < 0 || slice >= (GLint) depth) {
            depth00 = samp->BorderColor.f[0];
            depth01 = samp->BorderColor.f[0];
            depth10 = samp->BorderColor.f[0];
            depth11 = samp->BorderColor.f[0];
         }
         else {
            /* get four depth samples from the texture */
            if (useBorderTexel & (I0BIT | J0BIT)) {
               depth00 = samp->BorderColor.f[0];
            }
            else {
               swImg->FetchTexel(swImg, i0, j0, slice, &depth00);
            }
            if (useBorderTexel & (I1BIT | J0BIT)) {
               depth10 = samp->BorderColor.f[0];
            }
            else {
               swImg->FetchTexel(swImg, i1, j0, slice, &depth10);
            }

            if (tObj->Target != GL_TEXTURE_1D_ARRAY_EXT) {
               if (useBorderTexel & (I0BIT | J1BIT)) {
                  depth01 = samp->BorderColor.f[0];
               }
               else {
                  swImg->FetchTexel(swImg, i0, j1, slice, &depth01);
               }
               if (useBorderTexel & (I1BIT | J1BIT)) {
                  depth11 = samp->BorderColor.f[0];
               }
               else {
                  swImg->FetchTexel(swImg, i1, j1, slice, &depth11);
               }
            }
            else {
               depth01 = depth00;
               depth11 = depth10;
            }
         }

         depthRef = CLAMP(texcoords[i][compare_coord], 0.0F, 1.0F);

         result = shadow_compare4(function, depthRef,
                                  depth00, depth01, depth10, depth11,
                                  wi, wj);

         apply_depth_mode(tObj->DepthMode, result, texel[i]);
      }  /* for */
   }  /* if filter */
}


/**
 * We use this function when a texture object is in an "incomplete" state.
 * When a fragment program attempts to sample an incomplete texture we
 * return black (see issue 23 in GL_ARB_fragment_program spec).
 * Note: fragment programs don't observe the texture enable/disable flags.
 */
static void
null_sample_func( struct gl_context *ctx,
                  const struct gl_sampler_object *samp,
		  const struct gl_texture_object *tObj, GLuint n,
		  const GLfloat texcoords[][4], const GLfloat lambda[],
		  GLfloat rgba[][4])
{
   GLuint i;
   (void) ctx;
   (void) tObj;
   (void) texcoords;
   (void) lambda;
   (void) samp;
   for (i = 0; i < n; i++) {
      rgba[i][RCOMP] = 0;
      rgba[i][GCOMP] = 0;
      rgba[i][BCOMP] = 0;
      rgba[i][ACOMP] = 1.0;
   }
}


/**
 * Choose the texture sampling function for the given texture object.
 */
texture_sample_func
_swrast_choose_texture_sample_func( struct gl_context *ctx,
				    const struct gl_texture_object *t,
                                    const struct gl_sampler_object *sampler)
{
   if (!t || !_mesa_is_texture_complete(t, sampler)) {
      return &null_sample_func;
   }
   else {
      const GLboolean needLambda =
         (GLboolean) (sampler->MinFilter != sampler->MagFilter);

      switch (t->Target) {
      case GL_TEXTURE_1D:
         if (is_depth_texture(t)) {
            return &sample_depth_texture;
         }
         else if (needLambda) {
            return &sample_lambda_1d;
         }
         else if (sampler->MinFilter == GL_LINEAR) {
            return &sample_linear_1d;
         }
         else {
            ASSERT(sampler->MinFilter == GL_NEAREST);
            return &sample_nearest_1d;
         }
      case GL_TEXTURE_2D:
         if (is_depth_texture(t)) {
            return &sample_depth_texture;
         }
         else if (needLambda) {
            /* Anisotropic filtering extension. Activated only if mipmaps are used */
            if (sampler->MaxAnisotropy > 1.0 &&
                sampler->MinFilter == GL_LINEAR_MIPMAP_LINEAR) {
               return &sample_lambda_2d_aniso;
            }
            return &sample_lambda_2d;
         }
         else if (sampler->MinFilter == GL_LINEAR) {
            return &sample_linear_2d;
         }
         else {
            /* check for a few optimized cases */
            const struct gl_texture_image *img = t->Image[0][t->BaseLevel];
            const struct swrast_texture_image *swImg =
               swrast_texture_image_const(img);
            texture_sample_func func;

            ASSERT(sampler->MinFilter == GL_NEAREST);
            func = &sample_nearest_2d;
            if (sampler->WrapS == GL_REPEAT &&
                sampler->WrapT == GL_REPEAT &&
                swImg->_IsPowerOfTwo &&
                img->Border == 0) {
               if (img->TexFormat == MESA_FORMAT_BGR_UNORM8)
                  func = &opt_sample_rgb_2d;
               else if (img->TexFormat == MESA_FORMAT_A8B8G8R8_UNORM)
                  func = &opt_sample_rgba_2d;
            }

            return func;
         }
      case GL_TEXTURE_3D:
         if (needLambda) {
            return &sample_lambda_3d;
         }
         else if (sampler->MinFilter == GL_LINEAR) {
            return &sample_linear_3d;
         }
         else {
            ASSERT(sampler->MinFilter == GL_NEAREST);
            return &sample_nearest_3d;
         }
      case GL_TEXTURE_CUBE_MAP:
         if (needLambda) {
            return &sample_lambda_cube;
         }
         else if (sampler->MinFilter == GL_LINEAR) {
            return &sample_linear_cube;
         }
         else {
            ASSERT(sampler->MinFilter == GL_NEAREST);
            return &sample_nearest_cube;
         }
      case GL_TEXTURE_RECTANGLE_NV:
         if (is_depth_texture(t)) {
            return &sample_depth_texture;
         }
         else if (needLambda) {
            return &sample_lambda_rect;
         }
         else if (sampler->MinFilter == GL_LINEAR) {
            return &sample_linear_rect;
         }
         else {
            ASSERT(sampler->MinFilter == GL_NEAREST);
            return &sample_nearest_rect;
         }
      case GL_TEXTURE_1D_ARRAY_EXT:
         if (is_depth_texture(t)) {
            return &sample_depth_texture;
         }
	 else if (needLambda) {
            return &sample_lambda_1d_array;
         }
         else if (sampler->MinFilter == GL_LINEAR) {
            return &sample_linear_1d_array;
         }
         else {
            ASSERT(sampler->MinFilter == GL_NEAREST);
            return &sample_nearest_1d_array;
         }
      case GL_TEXTURE_2D_ARRAY_EXT:
         if (is_depth_texture(t)) {
            return &sample_depth_texture;
         }
	 else if (needLambda) {
            return &sample_lambda_2d_array;
         }
         else if (sampler->MinFilter == GL_LINEAR) {
            return &sample_linear_2d_array;
         }
         else {
            ASSERT(sampler->MinFilter == GL_NEAREST);
            return &sample_nearest_2d_array;
         }
      default:
         _mesa_problem(ctx,
                       "invalid target in _swrast_choose_texture_sample_func");
         return &null_sample_func;
      }
   }
}
@


1.11
log
@Merge Mesa 10.2.9
@
text
@@


1.10
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d807 1
a807 1
static inline void
@


1.9
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d807 1
a807 1
static INLINE void
@


1.8
log
@Merge Mesa 9.2.0
@
text
@d277 1
d1431 1
a1431 1
   ASSERT(img->TexFormat == MESA_FORMAT_RGB888);
d1476 1
a1476 1
   ASSERT(img->TexFormat == MESA_FORMAT_RGBA8888);
d1524 1
a1524 1
            case MESA_FORMAT_RGB888:
d1528 1
a1528 1
            case MESA_FORMAT_RGBA8888:
d1581 1
a1581 1
            case MESA_FORMAT_RGB888:
d1585 1
a1585 1
            case MESA_FORMAT_RGBA8888:
d3763 1
a3763 1
               if (img->TexFormat == MESA_FORMAT_RGB888)
d3765 1
a3765 1
               else if (img->TexFormat == MESA_FORMAT_RGBA8888)
@


1.7
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a2 1
 * Version:  7.3
d19 4
a22 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
d30 2
d62 1
a62 1
static INLINE GLfloat
d76 1
a76 1
static INLINE GLfloat
d94 1
a94 1
static INLINE void
d107 1
a107 1
static INLINE void
d122 1
a122 1
static INLINE void
d158 1
a158 1
static INLINE void
d164 1
d169 1
a169 1
      if (img->_IsPowerOfTwo) {
d278 1
d287 1
a287 1
static INLINE GLint
d292 1
d300 1
a300 1
      if (img->_IsPowerOfTwo)
d412 1
a412 1
static INLINE void
d426 1
a426 1
static INLINE GLint
d446 1
a446 1
static INLINE void
d477 1
d488 1
a488 1
static INLINE GLint
d501 3
a503 2
static INLINE void
nearest_texcoord(const struct gl_texture_object *texObj,
d515 2
a516 2
      *i = clamp_rect_coord_nearest(texObj->Sampler.WrapS, texcoord[0], width);
      *j = clamp_rect_coord_nearest(texObj->Sampler.WrapT, texcoord[1], height);
d520 1
a520 1
      *i = nearest_texel_location(texObj->Sampler.WrapS, img, width, texcoord[0]);
d525 2
a526 2
      *i = nearest_texel_location(texObj->Sampler.WrapS, img, width, texcoord[0]);
      *j = nearest_texel_location(texObj->Sampler.WrapT, img, height, texcoord[1]);
d530 1
a530 1
      *i = nearest_texel_location(texObj->Sampler.WrapS, img, width, texcoord[0]);
d535 2
a536 2
      *i = nearest_texel_location(texObj->Sampler.WrapS, img, width, texcoord[0]);
      *j = nearest_texel_location(texObj->Sampler.WrapT, img, height, texcoord[1]);
d541 1
d550 3
a552 2
static INLINE void
linear_texcoord(const struct gl_texture_object *texObj,
d565 1
a565 1
      clamp_rect_coord_linear(texObj->Sampler.WrapS, texcoord[0],
d567 1
a567 1
      clamp_rect_coord_linear(texObj->Sampler.WrapT, texcoord[1],
d574 1
a574 1
      linear_texel_locations(texObj->Sampler.WrapS, img, width,
d576 1
a576 1
      linear_texel_locations(texObj->Sampler.WrapT, img, height,
d582 1
a582 1
      linear_texel_locations(texObj->Sampler.WrapS, img, width,
d590 1
a590 1
      linear_texel_locations(texObj->Sampler.WrapS, img, width,
d592 1
a592 1
      linear_texel_locations(texObj->Sampler.WrapT, img, height,
d599 1
d609 1
a609 1
static INLINE GLint
d624 1
a624 1
static INLINE GLint
d660 2
a661 2
static INLINE void
compute_min_mag_ranges(const struct gl_texture_object *tObj,
d669 1
a669 1
   ASSERT(tObj->Sampler.MinFilter != tObj->Sampler.MagFilter);
d672 3
a674 3
   if (tObj->Sampler.MagFilter == GL_LINEAR
       && (tObj->Sampler.MinFilter == GL_NEAREST_MIPMAP_NEAREST ||
           tObj->Sampler.MinFilter == GL_NEAREST_MIPMAP_LINEAR)) {
d769 2
a770 2
static INLINE void
get_border_color(const struct gl_texture_object *tObj,
d776 3
a778 3
      rgba[0] = tObj->Sampler.BorderColor.f[0];
      rgba[1] = tObj->Sampler.BorderColor.f[1];
      rgba[2] = tObj->Sampler.BorderColor.f[2];
d783 1
a783 1
      rgba[3] = tObj->Sampler.BorderColor.f[3];
d786 1
a786 1
      rgba[0] = rgba[1] = rgba[2] = tObj->Sampler.BorderColor.f[0];
d790 2
a791 2
      rgba[0] = rgba[1] = rgba[2] = tObj->Sampler.BorderColor.f[0];
      rgba[3] = tObj->Sampler.BorderColor.f[3];
d794 1
a794 1
      rgba[0] = rgba[1] = rgba[2] = rgba[3] = tObj->Sampler.BorderColor.f[0];
d797 2
a798 1
      COPY_4V(rgba, tObj->Sampler.BorderColor.f);
d803 36
d846 1
a846 1
static INLINE void
d848 1
a848 1
                  const struct gl_texture_object *tObj,
d852 1
d855 1
a855 1
   i = nearest_texel_location(tObj->Sampler.WrapS, img, width, texcoord[0]);
d860 1
a860 1
      get_border_color(tObj, img, rgba);
d863 1
a863 1
      img->FetchTexelf(img, i, 0, 0, rgba);
d871 1
a871 1
static INLINE void
d873 1
a873 1
                 const struct gl_texture_object *tObj,
d877 1
d884 1
a884 1
   linear_texel_locations(tObj->Sampler.WrapS, img, width, texcoord[0], &i0, &i1, &a);
d897 1
a897 1
      get_border_color(tObj, img, t0);
d900 1
a900 1
      img->FetchTexelf(img, i0, 0, 0, t0);
d903 1
a903 1
      get_border_color(tObj, img, t1);
d906 1
a906 1
      img->FetchTexelf(img, i1, 0, 0, t1);
d915 1
d924 1
a924 1
      sample_1d_nearest(ctx, tObj, tObj->Image[0][level], texcoord[i], rgba[i]);
d931 1
d940 1
a940 1
      sample_1d_linear(ctx, tObj, tObj->Image[0][level], texcoord[i], rgba[i]);
d947 1
d957 1
a957 1
         sample_1d_nearest(ctx, tObj, tObj->Image[0][tObj->_MaxLevel],
d963 2
a964 2
         sample_1d_nearest(ctx, tObj, tObj->Image[0][level  ], texcoord[i], t0);
         sample_1d_nearest(ctx, tObj, tObj->Image[0][level+1], texcoord[i], t1);
d973 1
d983 1
a983 1
         sample_1d_linear(ctx, tObj, tObj->Image[0][tObj->_MaxLevel],
d989 2
a990 2
         sample_1d_linear(ctx, tObj, tObj->Image[0][level  ], texcoord[i], t0);
         sample_1d_linear(ctx, tObj, tObj->Image[0][level+1], texcoord[i], t1);
d1000 1
d1009 1
a1009 1
      sample_1d_nearest(ctx, tObj, image, texcoords[i], rgba[i]);
d1017 1
d1026 1
a1026 1
      sample_1d_linear(ctx, tObj, image, texcoords[i], rgba[i]);
d1034 1
d1044 1
a1044 1
   compute_min_mag_ranges(tObj, n, lambda,
d1050 1
a1050 1
      switch (tObj->Sampler.MinFilter) {
d1053 1
a1053 1
            sample_1d_nearest(ctx, tObj, tObj->Image[0][tObj->BaseLevel],
d1058 1
a1058 1
            sample_1d_linear(ctx, tObj, tObj->Image[0][tObj->BaseLevel],
d1062 1
a1062 1
         sample_1d_nearest_mipmap_nearest(ctx, tObj, m, texcoords + minStart,
d1066 1
a1066 1
         sample_1d_linear_mipmap_nearest(ctx, tObj, m, texcoords + minStart,
d1070 1
a1070 1
         sample_1d_nearest_mipmap_linear(ctx, tObj, m, texcoords + minStart,
d1074 1
a1074 1
         sample_1d_linear_mipmap_linear(ctx, tObj, m, texcoords + minStart,
d1085 1
a1085 1
      switch (tObj->Sampler.MagFilter) {
d1088 1
a1088 1
            sample_1d_nearest(ctx, tObj, tObj->Image[0][tObj->BaseLevel],
d1093 1
a1093 1
            sample_1d_linear(ctx, tObj, tObj->Image[0][tObj->BaseLevel],
d1112 1
a1112 1
static INLINE void
d1114 1
a1114 1
                  const struct gl_texture_object *tObj,
d1119 1
d1125 2
a1126 2
   i = nearest_texel_location(tObj->Sampler.WrapS, img, width, texcoord[0]);
   j = nearest_texel_location(tObj->Sampler.WrapT, img, height, texcoord[1]);
d1134 1
a1134 1
      get_border_color(tObj, img, rgba);
d1137 1
a1137 1
      img->FetchTexelf(img, i, j, 0, rgba);
d1146 1
a1146 1
static INLINE void
d1148 1
a1148 1
                 const struct gl_texture_object *tObj,
d1153 1
d1161 2
a1162 2
   linear_texel_locations(tObj->Sampler.WrapS, img, width, texcoord[0],  &i0, &i1, &a);
   linear_texel_locations(tObj->Sampler.WrapT, img, height, texcoord[1], &j0, &j1, &b);
d1179 1
a1179 1
      get_border_color(tObj, img, t00);
d1182 1
a1182 1
      img->FetchTexelf(img, i0, j0, 0, t00);
d1185 1
a1185 1
      get_border_color(tObj, img, t10);
d1188 1
a1188 1
      img->FetchTexelf(img, i1, j0, 0, t10);
d1191 1
a1191 1
      get_border_color(tObj, img, t01);
d1194 1
a1194 1
      img->FetchTexelf(img, i0, j1, 0, t01);
d1197 1
a1197 1
      get_border_color(tObj, img, t11);
d1200 1
a1200 1
      img->FetchTexelf(img, i1, j1, 0, t11);
d1211 1
a1211 1
static INLINE void
d1213 1
a1213 1
                        const struct gl_texture_object *tObj,
d1218 1
d1227 2
a1228 2
   ASSERT(tObj->Sampler.WrapS == GL_REPEAT);
   ASSERT(tObj->Sampler.WrapT == GL_REPEAT);
d1230 1
a1230 2
   ASSERT(img->_BaseFormat != GL_COLOR_INDEX);
   ASSERT(img->_IsPowerOfTwo);
d1235 4
a1238 4
   img->FetchTexelf(img, i0, j0, 0, t00);
   img->FetchTexelf(img, i1, j0, 0, t10);
   img->FetchTexelf(img, i0, j1, 0, t01);
   img->FetchTexelf(img, i1, j1, 0, t11);
d1246 1
d1254 1
a1254 1
      sample_2d_nearest(ctx, tObj, tObj->Image[0][level], texcoord[i], rgba[i]);
d1261 1
d1270 1
a1270 1
      sample_2d_linear(ctx, tObj, tObj->Image[0][level], texcoord[i], rgba[i]);
d1277 1
d1287 1
a1287 1
         sample_2d_nearest(ctx, tObj, tObj->Image[0][tObj->_MaxLevel],
d1293 2
a1294 2
         sample_2d_nearest(ctx, tObj, tObj->Image[0][level  ], texcoord[i], t0);
         sample_2d_nearest(ctx, tObj, tObj->Image[0][level+1], texcoord[i], t1);
d1303 1
d1313 1
a1313 1
         sample_2d_linear(ctx, tObj, tObj->Image[0][tObj->_MaxLevel],
d1319 2
a1320 2
         sample_2d_linear(ctx, tObj, tObj->Image[0][level  ], texcoord[i], t0);
         sample_2d_linear(ctx, tObj, tObj->Image[0][level+1], texcoord[i], t1);
d1329 1
d1336 2
a1337 2
   ASSERT(tObj->Sampler.WrapS == GL_REPEAT);
   ASSERT(tObj->Sampler.WrapT == GL_REPEAT);
d1341 1
a1341 1
         sample_2d_linear_repeat(ctx, tObj, tObj->Image[0][tObj->_MaxLevel],
d1347 1
a1347 1
         sample_2d_linear_repeat(ctx, tObj, tObj->Image[0][level  ],
d1349 1
a1349 1
         sample_2d_linear_repeat(ctx, tObj, tObj->Image[0][level+1],
d1360 1
d1369 1
a1369 1
      sample_2d_nearest(ctx, tObj, image, texcoords[i], rgba[i]);
d1377 1
d1384 1
d1386 3
a1388 3
   if (tObj->Sampler.WrapS == GL_REPEAT &&
       tObj->Sampler.WrapT == GL_REPEAT &&
       image->_IsPowerOfTwo &&
d1391 1
a1391 1
         sample_2d_linear_repeat(ctx, tObj, image, texcoords[i], rgba[i]);
d1396 1
a1396 1
         sample_2d_linear(ctx, tObj, image, texcoords[i], rgba[i]);
d1412 1
d1418 1
d1427 2
a1428 2
   ASSERT(tObj->Sampler.WrapS==GL_REPEAT);
   ASSERT(tObj->Sampler.WrapT==GL_REPEAT);
d1431 2
a1432 1
   ASSERT(img->_IsPowerOfTwo);
d1438 1
a1438 1
      GLubyte *texel = ((GLubyte *) img->Data) + 3*pos;
d1457 1
d1463 1
d1472 2
a1473 2
   ASSERT(tObj->Sampler.WrapS==GL_REPEAT);
   ASSERT(tObj->Sampler.WrapT==GL_REPEAT);
d1476 2
a1477 1
   ASSERT(img->_IsPowerOfTwo);
d1483 1
a1483 1
      const GLuint texel = *((GLuint *) img->Data + pos);
d1495 1
d1501 1
d1505 6
a1510 5
   const GLboolean repeatNoBorderPOT = (tObj->Sampler.WrapS == GL_REPEAT)
      && (tObj->Sampler.WrapT == GL_REPEAT)
      && (tImg->Border == 0 && (tImg->Width == tImg->RowStride))
      && (tImg->_BaseFormat != GL_COLOR_INDEX)
      && tImg->_IsPowerOfTwo;
d1513 1
a1513 1
   compute_min_mag_ranges(tObj, n, lambda,
d1519 1
a1519 1
      switch (tObj->Sampler.MinFilter) {
d1524 1
a1524 1
               opt_sample_rgb_2d(ctx, tObj, m, texcoords + minStart,
d1528 1
a1528 1
	       opt_sample_rgba_2d(ctx, tObj, m, texcoords + minStart,
d1532 1
a1532 1
               sample_nearest_2d(ctx, tObj, m, texcoords + minStart,
d1537 1
a1537 1
            sample_nearest_2d(ctx, tObj, m, texcoords + minStart,
d1542 1
a1542 1
	 sample_linear_2d(ctx, tObj, m, texcoords + minStart,
d1546 1
a1546 1
         sample_2d_nearest_mipmap_nearest(ctx, tObj, m,
d1551 1
a1551 1
         sample_2d_linear_mipmap_nearest(ctx, tObj, m, texcoords + minStart,
d1555 1
a1555 1
         sample_2d_nearest_mipmap_linear(ctx, tObj, m, texcoords + minStart,
d1560 1
a1560 1
            sample_2d_linear_mipmap_linear_repeat(ctx, tObj, m,
d1563 1
a1563 1
            sample_2d_linear_mipmap_linear(ctx, tObj, m, texcoords + minStart,
d1576 1
a1576 1
      switch (tObj->Sampler.MagFilter) {
d1581 1
a1581 1
               opt_sample_rgb_2d(ctx, tObj, m, texcoords + magStart,
d1585 1
a1585 1
	       opt_sample_rgba_2d(ctx, tObj, m, texcoords + magStart,
d1589 1
a1589 1
               sample_nearest_2d(ctx, tObj, m, texcoords + magStart,
d1594 1
a1594 1
            sample_nearest_2d(ctx, tObj, m, texcoords + magStart,
d1599 1
a1599 1
	 sample_linear_2d(ctx, tObj, m, texcoords + magStart,
d1604 1
d1623 1
a1623 1
      weightLut = (GLfloat *) malloc(WEIGHT_LUT_SIZE * sizeof(GLfloat));
d1644 1
d1652 1
a1652 1
   GLfloat scaling = 1.0 / (1 << level);
d1656 4
a1659 2
   GLfloat tex_u=-0.5 + texcoord[0] * mostDetailedImage->WidthScale * scaling;
   GLfloat tex_v=-0.5 + texcoord[1] * mostDetailedImage->HeightScale * scaling;
d1672 1
a1672 1
   GLfloat F = A*C-B*B/4.0;
d1678 8
a1685 8
   GLfloat d = -B*B+4.0*C*A;
   GLfloat box_u = 2.0 / d * sqrt(d*C*F); /* box_u -> half of bbox with   */
   GLfloat box_v = 2.0 / d * sqrt(A*d*F); /* box_v -> half of bbox height */

   GLint u0 = floor(tex_u - box_u);
   GLint u1 = ceil (tex_u + box_u);
   GLint v0 = floor(tex_v - box_v);
   GLint v1 = ceil (tex_v + box_v);
d1697 1
a1697 1
   double formScale = (double) (WEIGHT_LUT_SIZE - 1) / F;
d1720 1
a1720 1
            const GLint qClamped = q >= 0.0F ? q : 0;
d1726 1
a1726 1
            sample_2d_nearest(ctx, tObj, img, newCoord, rgba);
d1752 1
a1752 1
      sample_2d_linear(ctx, tObj, img, texcoord, rgba);
d1771 1
d1800 1
a1800 1
      numSamples = ceil(SQRTF(Px2));
d1805 1
a1805 1
      numSamples = ceil(SQRTF(Py2));
d1811 2
a1812 2
      newCoord[0] = texcoord[0] + ds * ((GLfloat)(s+1) / (numSamples+1) -0.5);
      newCoord[1] = texcoord[1] + dt * ((GLfloat)(s+1) / (numSamples+1) -0.5);
d1814 1
a1814 1
      sample_2d_linear(ctx, tObj, img, newCoord, rgba);
d1832 1
a1832 1
static INLINE GLuint
d1862 1
d1868 1
d1870 1
a1870 1
      tObj->Sampler.MaxAnisotropy * tObj->Sampler.MaxAnisotropy;
d1885 1
a1885 1
   const GLuint attr = FRAG_ATTRIB_TEX0 + u;
d1901 2
a1902 2
      (texUnit->LodBias + tObj->Sampler.LodBias != 0.0F)
      || (tObj->Sampler.MinLod != -1000.0 || tObj->Sampler.MaxLod != 1000.0);
d1911 2
a1912 2
   texW = tImg->WidthScale;
   texH = tImg->HeightScale;
d1961 1
a1961 1
      lod = 0.5 * LOG2(Pmin2);
d1965 1
a1965 1
         if (texUnit->LodBias + tObj->Sampler.LodBias != 0.0F) {
d1968 1
a1968 1
               CLAMP(texUnit->LodBias + tObj->Sampler.LodBias,
d1973 2
a1974 2
            if (tObj->Sampler.MinLod != -1000.0 ||
                tObj->Sampler.MaxLod != 1000.0) {
d1976 1
a1976 1
               lod = CLAMP(lod, tObj->Sampler.MinLod, tObj->Sampler.MaxLod);
d1985 1
a1985 1
         sample_2d_linear(ctx, tObj, tObj->Image[0][tObj->_MaxLevel],
d1992 2
a1993 2
         sample_2d_ewa(ctx, tObj, texcoords[i],
                       dudx, dvdx, dudy, dvdy, floor(lod), rgba[i]);
d2014 1
a2014 1
static INLINE void
d2016 1
a2016 1
                  const struct gl_texture_object *tObj,
d2021 1
d2028 3
a2030 3
   i = nearest_texel_location(tObj->Sampler.WrapS, img, width, texcoord[0]);
   j = nearest_texel_location(tObj->Sampler.WrapT, img, height, texcoord[1]);
   k = nearest_texel_location(tObj->Sampler.WrapR, img, depth, texcoord[2]);
d2036 1
a2036 1
      get_border_color(tObj, img, rgba);
d2039 1
a2039 1
      img->FetchTexelf(img, i, j, k, rgba);
d2049 1
a2049 1
                 const struct gl_texture_object *tObj,
d2054 1
d2064 3
a2066 3
   linear_texel_locations(tObj->Sampler.WrapS, img, width, texcoord[0],  &i0, &i1, &a);
   linear_texel_locations(tObj->Sampler.WrapT, img, height, texcoord[1], &j0, &j1, &b);
   linear_texel_locations(tObj->Sampler.WrapR, img, depth, texcoord[2],  &k0, &k1, &c);
d2088 1
a2088 1
      get_border_color(tObj, img, t000);
d2091 1
a2091 1
      img->FetchTexelf(img, i0, j0, k0, t000);
d2094 1
a2094 1
      get_border_color(tObj, img, t100);
d2097 1
a2097 1
      img->FetchTexelf(img, i1, j0, k0, t100);
d2100 1
a2100 1
      get_border_color(tObj, img, t010);
d2103 1
a2103 1
      img->FetchTexelf(img, i0, j1, k0, t010);
d2106 1
a2106 1
      get_border_color(tObj, img, t110);
d2109 1
a2109 1
      img->FetchTexelf(img, i1, j1, k0, t110);
d2113 1
a2113 1
      get_border_color(tObj, img, t001);
d2116 1
a2116 1
      img->FetchTexelf(img, i0, j0, k1, t001);
d2119 1
a2119 1
      get_border_color(tObj, img, t101);
d2122 1
a2122 1
      img->FetchTexelf(img, i1, j0, k1, t101);
d2125 1
a2125 1
      get_border_color(tObj, img, t011);
d2128 1
a2128 1
      img->FetchTexelf(img, i0, j1, k1, t011);
d2131 1
a2131 1
      get_border_color(tObj, img, t111);
d2134 1
a2134 1
      img->FetchTexelf(img, i1, j1, k1, t111);
d2144 1
d2152 1
a2152 1
      sample_3d_nearest(ctx, tObj, tObj->Image[0][level], texcoord[i], rgba[i]);
d2159 1
d2168 1
a2168 1
      sample_3d_linear(ctx, tObj, tObj->Image[0][level], texcoord[i], rgba[i]);
d2175 1
d2185 1
a2185 1
         sample_3d_nearest(ctx, tObj, tObj->Image[0][tObj->_MaxLevel],
d2191 2
a2192 2
         sample_3d_nearest(ctx, tObj, tObj->Image[0][level  ], texcoord[i], t0);
         sample_3d_nearest(ctx, tObj, tObj->Image[0][level+1], texcoord[i], t1);
d2201 1
d2211 1
a2211 1
         sample_3d_linear(ctx, tObj, tObj->Image[0][tObj->_MaxLevel],
d2217 2
a2218 2
         sample_3d_linear(ctx, tObj, tObj->Image[0][level  ], texcoord[i], t0);
         sample_3d_linear(ctx, tObj, tObj->Image[0][level+1], texcoord[i], t1);
d2228 1
d2237 1
a2237 1
      sample_3d_nearest(ctx, tObj, image, texcoords[i], rgba[i]);
d2245 1
d2254 1
a2254 1
      sample_3d_linear(ctx, tObj, image, texcoords[i], rgba[i]);
d2262 1
d2272 1
a2272 1
   compute_min_mag_ranges(tObj, n, lambda,
d2278 1
a2278 1
      switch (tObj->Sampler.MinFilter) {
d2281 1
a2281 1
            sample_3d_nearest(ctx, tObj, tObj->Image[0][tObj->BaseLevel],
d2286 1
a2286 1
            sample_3d_linear(ctx, tObj, tObj->Image[0][tObj->BaseLevel],
d2290 1
a2290 1
         sample_3d_nearest_mipmap_nearest(ctx, tObj, m, texcoords + minStart,
d2294 1
a2294 1
         sample_3d_linear_mipmap_nearest(ctx, tObj, m, texcoords + minStart,
d2298 1
a2298 1
         sample_3d_nearest_mipmap_linear(ctx, tObj, m, texcoords + minStart,
d2302 1
a2302 1
         sample_3d_linear_mipmap_linear(ctx, tObj, m, texcoords + minStart,
d2313 1
a2313 1
      switch (tObj->Sampler.MagFilter) {
d2316 1
a2316 1
            sample_3d_nearest(ctx, tObj, tObj->Image[0][tObj->BaseLevel],
d2321 1
a2321 1
            sample_3d_linear(ctx, tObj, tObj->Image[0][tObj->BaseLevel],
d2418 1
d2429 1
a2429 1
      sample_2d_nearest(ctx, tObj, images[tObj->BaseLevel],
d2432 5
d2442 1
d2453 1
a2453 1
      sample_2d_linear(ctx, tObj, images[tObj->BaseLevel],
d2456 5
d2466 1
d2489 6
a2494 1
      sample_2d_nearest(ctx, tObj, images[level], newCoord, rgba[i]);
d2501 1
d2514 6
a2519 1
      sample_2d_linear(ctx, tObj, images[level], newCoord, rgba[i]);
d2526 1
d2540 1
a2540 1
         sample_2d_nearest(ctx, tObj, images[tObj->_MaxLevel],
d2546 2
a2547 2
         sample_2d_nearest(ctx, tObj, images[level  ], newCoord, t0);
         sample_2d_nearest(ctx, tObj, images[level+1], newCoord, t1);
d2551 5
d2561 1
d2575 1
a2575 1
         sample_2d_linear(ctx, tObj, images[tObj->_MaxLevel],
d2581 2
a2582 2
         sample_2d_linear(ctx, tObj, images[level  ], newCoord, t0);
         sample_2d_linear(ctx, tObj, images[level+1], newCoord, t1);
d2586 5
d2597 1
d2606 1
a2606 1
   compute_min_mag_ranges(tObj, n, lambda,
d2612 1
a2612 1
      switch (tObj->Sampler.MinFilter) {
d2614 1
a2614 1
         sample_nearest_cube(ctx, tObj, m, texcoords + minStart,
d2618 1
a2618 1
         sample_linear_cube(ctx, tObj, m, texcoords + minStart,
d2622 1
a2622 1
         sample_cube_nearest_mipmap_nearest(ctx, tObj, m,
d2627 1
a2627 1
         sample_cube_linear_mipmap_nearest(ctx, tObj, m,
d2632 1
a2632 1
         sample_cube_nearest_mipmap_linear(ctx, tObj, m,
d2637 1
a2637 1
         sample_cube_linear_mipmap_linear(ctx, tObj, m,
d2643 1
d2650 1
a2650 1
      switch (tObj->Sampler.MagFilter) {
d2652 1
a2652 1
         sample_nearest_cube(ctx, tObj, m, texcoords + magStart,
d2656 1
a2656 1
         sample_linear_cube(ctx, tObj, m, texcoords + magStart,
d2661 1
d2674 1
d2680 1
d2688 6
a2693 7
   ASSERT(tObj->Sampler.WrapS == GL_CLAMP ||
          tObj->Sampler.WrapS == GL_CLAMP_TO_EDGE ||
          tObj->Sampler.WrapS == GL_CLAMP_TO_BORDER);
   ASSERT(tObj->Sampler.WrapT == GL_CLAMP ||
          tObj->Sampler.WrapT == GL_CLAMP_TO_EDGE ||
          tObj->Sampler.WrapT == GL_CLAMP_TO_BORDER);
   ASSERT(img->_BaseFormat != GL_COLOR_INDEX);
d2697 2
a2698 2
      col = clamp_rect_coord_nearest(tObj->Sampler.WrapS, texcoords[i][0], width);
      row = clamp_rect_coord_nearest(tObj->Sampler.WrapT, texcoords[i][1], height);
d2700 1
a2700 1
         get_border_color(tObj, img, rgba[i]);
d2702 1
a2702 1
         img->FetchTexelf(img, col, row, 0, rgba[i]);
d2709 1
d2715 1
d2723 6
a2728 7
   ASSERT(tObj->Sampler.WrapS == GL_CLAMP ||
          tObj->Sampler.WrapS == GL_CLAMP_TO_EDGE ||
          tObj->Sampler.WrapS == GL_CLAMP_TO_BORDER);
   ASSERT(tObj->Sampler.WrapT == GL_CLAMP ||
          tObj->Sampler.WrapT == GL_CLAMP_TO_EDGE ||
          tObj->Sampler.WrapT == GL_CLAMP_TO_BORDER);
   ASSERT(img->_BaseFormat != GL_COLOR_INDEX);
d2736 1
a2736 1
      clamp_rect_coord_linear(tObj->Sampler.WrapS, texcoords[i][0], width,
d2738 1
a2738 1
      clamp_rect_coord_linear(tObj->Sampler.WrapT, texcoords[i][1], height,
d2749 1
a2749 1
         get_border_color(tObj, img, t00);
d2751 1
a2751 1
         img->FetchTexelf(img, i0, j0, 0, t00);
d2754 1
a2754 1
         get_border_color(tObj, img, t10);
d2756 1
a2756 1
         img->FetchTexelf(img, i1, j0, 0, t10);
d2759 1
a2759 1
         get_border_color(tObj, img, t01);
d2761 1
a2761 1
         img->FetchTexelf(img, i0, j1, 0, t01);
d2764 1
a2764 1
         get_border_color(tObj, img, t11);
d2766 1
a2766 1
         img->FetchTexelf(img, i1, j1, 0, t11);
d2776 1
d2786 1
a2786 1
   compute_min_mag_ranges(tObj, n, lambda,
d2790 2
a2791 2
      if (tObj->Sampler.MinFilter == GL_NEAREST) {
         sample_nearest_rect(ctx, tObj, minEnd - minStart,
d2795 1
a2795 1
         sample_linear_rect(ctx, tObj, minEnd - minStart,
d2800 2
a2801 2
      if (tObj->Sampler.MagFilter == GL_NEAREST) {
         sample_nearest_rect(ctx, tObj, magEnd - magStart,
d2805 1
a2805 1
         sample_linear_rect(ctx, tObj, magEnd - magStart,
d2821 1
a2821 1
                        const struct gl_texture_object *tObj,
d2826 1
d2834 2
a2835 2
   i = nearest_texel_location(tObj->Sampler.WrapS, img, width, texcoord[0]);
   j = nearest_texel_location(tObj->Sampler.WrapT, img, height, texcoord[1]);
d2842 1
a2842 1
      get_border_color(tObj, img, rgba);
d2845 1
a2845 1
      img->FetchTexelf(img, i, j, array, rgba);
d2855 1
a2855 1
                       const struct gl_texture_object *tObj,
d2860 1
d2870 2
a2871 2
   linear_texel_locations(tObj->Sampler.WrapS, img, width,  texcoord[0], &i0, &i1, &a);
   linear_texel_locations(tObj->Sampler.WrapT, img, height, texcoord[1], &j0, &j1, &b);
d2875 1
a2875 1
      COPY_4V(rgba, tObj->Sampler.BorderColor.f);
d2894 1
a2894 1
         get_border_color(tObj, img, t00);
d2897 1
a2897 1
	 img->FetchTexelf(img, i0, j0, array, t00);
d2900 1
a2900 1
         get_border_color(tObj, img, t10);
d2903 1
a2903 1
	 img->FetchTexelf(img, i1, j0, array, t10);
d2906 1
a2906 1
         get_border_color(tObj, img, t01);
d2909 1
a2909 1
	 img->FetchTexelf(img, i0, j1, array, t01);
d2912 1
a2912 1
         get_border_color(tObj, img, t11);
d2915 1
a2915 1
	 img->FetchTexelf(img, i1, j1, array, t11);
d2926 1
d2934 1
a2934 1
      sample_2d_array_nearest(ctx, tObj, tObj->Image[0][level], texcoord[i],
d2942 1
d2951 1
a2951 1
      sample_2d_array_linear(ctx, tObj, tObj->Image[0][level],
d2959 1
d2969 1
a2969 1
         sample_2d_array_nearest(ctx, tObj, tObj->Image[0][tObj->_MaxLevel],
d2975 1
a2975 1
         sample_2d_array_nearest(ctx, tObj, tObj->Image[0][level  ],
d2977 1
a2977 1
         sample_2d_array_nearest(ctx, tObj, tObj->Image[0][level+1],
d2987 1
d2997 1
a2997 1
         sample_2d_array_linear(ctx, tObj, tObj->Image[0][tObj->_MaxLevel],
d3003 1
a3003 1
         sample_2d_array_linear(ctx, tObj, tObj->Image[0][level  ],
d3005 1
a3005 1
         sample_2d_array_linear(ctx, tObj, tObj->Image[0][level+1],
d3016 1
d3025 1
a3025 1
      sample_2d_array_nearest(ctx, tObj, image, texcoords[i], rgba[i]);
d3034 1
d3043 1
a3043 1
      sample_2d_array_linear(ctx, tObj, image, texcoords[i], rgba[i]);
d3051 1
d3061 1
a3061 1
   compute_min_mag_ranges(tObj, n, lambda,
d3067 1
a3067 1
      switch (tObj->Sampler.MinFilter) {
d3070 1
a3070 1
            sample_2d_array_nearest(ctx, tObj, tObj->Image[0][tObj->BaseLevel],
d3075 1
a3075 1
            sample_2d_array_linear(ctx, tObj, tObj->Image[0][tObj->BaseLevel],
d3079 1
a3079 1
         sample_2d_array_nearest_mipmap_nearest(ctx, tObj, m,
d3085 1
a3085 1
         sample_2d_array_linear_mipmap_nearest(ctx, tObj, m, 
d3091 1
a3091 1
         sample_2d_array_nearest_mipmap_linear(ctx, tObj, m,
d3097 1
a3097 1
         sample_2d_array_linear_mipmap_linear(ctx, tObj, m, 
d3110 1
a3110 1
      switch (tObj->Sampler.MagFilter) {
d3113 1
a3113 1
            sample_2d_array_nearest(ctx, tObj, tObj->Image[0][tObj->BaseLevel],
d3118 1
a3118 1
            sample_2d_array_linear(ctx, tObj, tObj->Image[0][tObj->BaseLevel],
d3140 1
a3140 1
                        const struct gl_texture_object *tObj,
d3145 1
d3152 1
a3152 1
   i = nearest_texel_location(tObj->Sampler.WrapS, img, width, texcoord[0]);
d3158 1
a3158 1
      get_border_color(tObj, img, rgba);
d3161 1
a3161 1
      img->FetchTexelf(img, i, array, 0, rgba);
d3171 1
a3171 1
                       const struct gl_texture_object *tObj,
d3176 1
d3185 1
a3185 1
   linear_texel_locations(tObj->Sampler.WrapS, img, width, texcoord[0], &i0, &i1, &a);
d3202 1
a3202 1
      get_border_color(tObj, img, t0);
d3205 1
a3205 1
      img->FetchTexelf(img, i0, array, 0, t0);
d3208 1
a3208 1
      get_border_color(tObj, img, t1);
d3211 1
a3211 1
      img->FetchTexelf(img, i1, array, 0, t1);
d3221 1
d3229 1
a3229 1
      sample_1d_array_nearest(ctx, tObj, tObj->Image[0][level], texcoord[i],
d3237 1
d3246 1
a3246 1
      sample_1d_array_linear(ctx, tObj, tObj->Image[0][level],
d3254 1
d3264 1
a3264 1
         sample_1d_array_nearest(ctx, tObj, tObj->Image[0][tObj->_MaxLevel],
d3270 2
a3271 2
         sample_1d_array_nearest(ctx, tObj, tObj->Image[0][level  ], texcoord[i], t0);
         sample_1d_array_nearest(ctx, tObj, tObj->Image[0][level+1], texcoord[i], t1);
d3280 1
d3290 1
a3290 1
         sample_1d_array_linear(ctx, tObj, tObj->Image[0][tObj->_MaxLevel],
d3296 2
a3297 2
         sample_1d_array_linear(ctx, tObj, tObj->Image[0][level  ], texcoord[i], t0);
         sample_1d_array_linear(ctx, tObj, tObj->Image[0][level+1], texcoord[i], t1);
d3307 1
d3316 1
a3316 1
      sample_1d_array_nearest(ctx, tObj, image, texcoords[i], rgba[i]);
d3324 1
d3333 1
a3333 1
      sample_1d_array_linear(ctx, tObj, image, texcoords[i], rgba[i]);
d3341 1
d3351 1
a3351 1
   compute_min_mag_ranges(tObj, n, lambda,
d3357 1
a3357 1
      switch (tObj->Sampler.MinFilter) {
d3360 1
a3360 1
            sample_1d_array_nearest(ctx, tObj, tObj->Image[0][tObj->BaseLevel],
d3365 1
a3365 1
            sample_1d_array_linear(ctx, tObj, tObj->Image[0][tObj->BaseLevel],
d3369 1
a3369 1
         sample_1d_array_nearest_mipmap_nearest(ctx, tObj, m, texcoords + minStart,
d3373 1
a3373 1
         sample_1d_array_linear_mipmap_nearest(ctx, tObj, m, 
d3379 1
a3379 1
         sample_1d_array_nearest_mipmap_linear(ctx, tObj, m, texcoords + minStart,
d3383 1
a3383 1
         sample_1d_array_linear_mipmap_linear(ctx, tObj, m, 
d3396 1
a3396 1
      switch (tObj->Sampler.MagFilter) {
d3399 1
a3399 1
            sample_1d_array_nearest(ctx, tObj, tObj->Image[0][tObj->BaseLevel],
d3404 1
a3404 1
            sample_1d_array_linear(ctx, tObj, tObj->Image[0][tObj->BaseLevel],
d3416 1
a3416 1
 * Compare texcoord against depth sample.  Return 1.0 or the ambient value.
d3418 2
a3419 3
static INLINE GLfloat
shadow_compare(GLenum function, GLfloat coord, GLfloat depthSample,
               GLfloat ambient)
d3423 1
a3423 1
      return (coord <= depthSample) ? 1.0F : ambient;
d3425 1
a3425 1
      return (coord >= depthSample) ? 1.0F : ambient;
d3427 1
a3427 1
      return (coord < depthSample) ? 1.0F : ambient;
d3429 1
a3429 1
      return (coord > depthSample) ? 1.0F : ambient;
d3431 1
a3431 1
      return (coord == depthSample) ? 1.0F : ambient;
d3433 1
a3433 1
      return (coord != depthSample) ? 1.0F : ambient;
d3437 1
a3437 1
      return ambient;
d3442 1
a3442 1
      return ambient;
d3450 1
a3450 1
static INLINE GLfloat
d3454 1
a3454 1
                GLfloat ambient, GLfloat wi, GLfloat wj)
d3456 1
a3456 1
   const GLfloat d = (1.0F - (GLfloat) ambient) * 0.25F;
d3499 1
a3499 1
      return ambient;
d3505 1
a3505 1
      return ambient;
d3514 2
a3515 1
choose_depth_texture_level(const struct gl_texture_object *tObj, GLfloat lambda)
d3519 1
a3519 1
   if (tObj->Sampler.MinFilter == GL_NEAREST || tObj->Sampler.MinFilter == GL_LINEAR) {
d3525 1
a3525 1
      lambda = CLAMP(lambda, tObj->Sampler.MinLod, tObj->Sampler.MaxLod);
d3540 1
d3545 1
a3545 1
   const GLint level = choose_depth_texture_level(tObj, lambda[0]);
d3547 1
a3552 1
   GLfloat ambient;
d3563 2
a3564 3
          tObj->Target == GL_TEXTURE_2D_ARRAY_EXT);

   ambient = tObj->Sampler.CompareFailValue;
d3566 1
a3566 1
   /* XXXX if tObj->Sampler.MinFilter != tObj->Sampler.MagFilter, we're ignoring lambda */
d3568 2
a3569 2
   function = (tObj->Sampler.CompareMode == GL_COMPARE_R_TO_TEXTURE_ARB) ?
      tObj->Sampler.CompareFunc : GL_NONE;
d3571 1
a3571 1
   if (tObj->Sampler.MagFilter == GL_NEAREST) {
d3577 1
a3577 1
         nearest_texcoord(tObj, level, texcoords[i], &col, &row, &slice);
d3581 1
a3581 1
            img->FetchTexelf(img, col, row, slice, &depthSample);
d3584 1
a3584 1
            depthSample = tObj->Sampler.BorderColor.f[0];
d3589 1
a3589 1
         result = shadow_compare(function, depthRef, depthSample, ambient);
d3591 1
a3591 16
         switch (tObj->Sampler.DepthMode) {
         case GL_LUMINANCE:
            ASSIGN_4V(texel[i], result, result, result, 1.0F);
            break;
         case GL_INTENSITY:
            ASSIGN_4V(texel[i], result, result, result, result);
            break;
         case GL_ALPHA:
            ASSIGN_4V(texel[i], 0.0F, 0.0F, 0.0F, result);
            break;
         case GL_RED:
            ASSIGN_4V(texel[i], result, 0.0F, 0.0F, 1.0F);
            break;
         default:
            _mesa_problem(ctx, "Bad depth texture mode");
         }
d3596 1
a3596 1
      ASSERT(tObj->Sampler.MagFilter == GL_LINEAR);
d3604 1
a3604 1
         linear_texcoord(tObj, level, texcoords[i], &i0, &i1, &j0, &j1, &slice,
d3624 4
a3627 4
            depth00 = tObj->Sampler.BorderColor.f[0];
            depth01 = tObj->Sampler.BorderColor.f[0];
            depth10 = tObj->Sampler.BorderColor.f[0];
            depth11 = tObj->Sampler.BorderColor.f[0];
d3632 1
a3632 1
               depth00 = tObj->Sampler.BorderColor.f[0];
d3635 1
a3635 1
               img->FetchTexelf(img, i0, j0, slice, &depth00);
d3638 1
a3638 1
               depth10 = tObj->Sampler.BorderColor.f[0];
d3641 1
a3641 1
               img->FetchTexelf(img, i1, j0, slice, &depth10);
d3646 1
a3646 1
                  depth01 = tObj->Sampler.BorderColor.f[0];
d3649 1
a3649 1
                  img->FetchTexelf(img, i0, j1, slice, &depth01);
d3652 1
a3652 1
                  depth11 = tObj->Sampler.BorderColor.f[0];
d3655 1
a3655 1
                  img->FetchTexelf(img, i1, j1, slice, &depth11);
d3668 1
a3668 15
                                  ambient, wi, wj);

         switch (tObj->Sampler.DepthMode) {
         case GL_LUMINANCE:
            ASSIGN_4V(texel[i], result, result, result, 1.0F);
            break;
         case GL_INTENSITY:
            ASSIGN_4V(texel[i], result, result, result, result);
            break;
         case GL_ALPHA:
            ASSIGN_4V(texel[i], 0.0F, 0.0F, 0.0F, result);
            break;
         default:
            _mesa_problem(ctx, "Bad depth texture mode");
         }
d3670 1
d3684 1
d3694 1
d3709 2
a3710 1
				    const struct gl_texture_object *t )
d3712 1
a3712 1
   if (!t || !t->_Complete) {
d3717 1
a3717 2
         (GLboolean) (t->Sampler.MinFilter != t->Sampler.MagFilter);
      const GLenum format = t->Image[0][t->BaseLevel]->_BaseFormat;
d3721 1
a3721 1
         if (format == GL_DEPTH_COMPONENT || format == GL_DEPTH_STENCIL_EXT) {
d3727 1
a3727 1
         else if (t->Sampler.MinFilter == GL_LINEAR) {
d3731 1
a3731 1
            ASSERT(t->Sampler.MinFilter == GL_NEAREST);
d3735 1
a3735 1
         if (format == GL_DEPTH_COMPONENT || format == GL_DEPTH_STENCIL_EXT) {
d3740 2
a3741 2
            if (t->Sampler.MaxAnisotropy > 1.0 &&
                t->Sampler.MinFilter == GL_LINEAR_MIPMAP_LINEAR) {
d3746 1
a3746 1
         else if (t->Sampler.MinFilter == GL_LINEAR) {
d3752 14
a3765 17
            ASSERT(t->Sampler.MinFilter == GL_NEAREST);
            if (t->Sampler.WrapS == GL_REPEAT &&
                t->Sampler.WrapT == GL_REPEAT &&
                img->_IsPowerOfTwo &&
                img->Border == 0 &&
                img->TexFormat == MESA_FORMAT_RGB888) {
               return &opt_sample_rgb_2d;
            }
            else if (t->Sampler.WrapS == GL_REPEAT &&
                     t->Sampler.WrapT == GL_REPEAT &&
                     img->_IsPowerOfTwo &&
                     img->Border == 0 &&
                     img->TexFormat == MESA_FORMAT_RGBA8888) {
               return &opt_sample_rgba_2d;
            }
            else {
               return &sample_nearest_2d;
d3767 2
d3774 1
a3774 1
         else if (t->Sampler.MinFilter == GL_LINEAR) {
d3778 1
a3778 1
            ASSERT(t->Sampler.MinFilter == GL_NEAREST);
d3785 1
a3785 1
         else if (t->Sampler.MinFilter == GL_LINEAR) {
d3789 1
a3789 1
            ASSERT(t->Sampler.MinFilter == GL_NEAREST);
d3793 1
a3793 1
         if (format == GL_DEPTH_COMPONENT || format == GL_DEPTH_STENCIL_EXT) {
d3799 1
a3799 1
         else if (t->Sampler.MinFilter == GL_LINEAR) {
d3803 1
a3803 1
            ASSERT(t->Sampler.MinFilter == GL_NEAREST);
d3807 4
a3810 1
         if (needLambda) {
d3813 1
a3813 1
         else if (t->Sampler.MinFilter == GL_LINEAR) {
d3817 1
a3817 1
            ASSERT(t->Sampler.MinFilter == GL_NEAREST);
d3821 4
a3824 1
         if (needLambda) {
d3827 1
a3827 1
         else if (t->Sampler.MinFilter == GL_LINEAR) {
d3831 1
a3831 1
            ASSERT(t->Sampler.MinFilter == GL_NEAREST);
@


1.6
log
@Merge Mesa 7.10.3
@
text
@a29 1
#include "main/texformat.h"
d508 2
a509 2
      *i = clamp_rect_coord_nearest(texObj->WrapS, texcoord[0], width);
      *j = clamp_rect_coord_nearest(texObj->WrapT, texcoord[1], height);
d513 1
a513 1
      *i = nearest_texel_location(texObj->WrapS, img, width, texcoord[0]);
d518 2
a519 2
      *i = nearest_texel_location(texObj->WrapS, img, width, texcoord[0]);
      *j = nearest_texel_location(texObj->WrapT, img, height, texcoord[1]);
d523 1
a523 1
      *i = nearest_texel_location(texObj->WrapS, img, width, texcoord[0]);
d528 2
a529 2
      *i = nearest_texel_location(texObj->WrapS, img, width, texcoord[0]);
      *j = nearest_texel_location(texObj->WrapT, img, height, texcoord[1]);
d556 1
a556 1
      clamp_rect_coord_linear(texObj->WrapS, texcoord[0],
d558 1
a558 1
      clamp_rect_coord_linear(texObj->WrapT, texcoord[1],
d565 1
a565 1
      linear_texel_locations(texObj->WrapS, img, width,
d567 1
a567 1
      linear_texel_locations(texObj->WrapT, img, height,
d573 1
a573 1
      linear_texel_locations(texObj->WrapS, img, width,
d581 1
a581 1
      linear_texel_locations(texObj->WrapS, img, width,
d583 1
a583 1
      linear_texel_locations(texObj->WrapT, img, height,
d659 1
a659 1
   ASSERT(tObj->MinFilter != tObj->MagFilter);
d662 3
a664 3
   if (tObj->MagFilter == GL_LINEAR
       && (tObj->MinFilter == GL_NEAREST_MIPMAP_NEAREST ||
           tObj->MinFilter == GL_NEAREST_MIPMAP_LINEAR)) {
d766 3
a768 3
      rgba[0] = tObj->BorderColor.f[0];
      rgba[1] = tObj->BorderColor.f[1];
      rgba[2] = tObj->BorderColor.f[2];
d773 1
a773 1
      rgba[3] = tObj->BorderColor.f[3];
d776 1
a776 1
      rgba[0] = rgba[1] = rgba[2] = tObj->BorderColor.f[0];
d780 2
a781 2
      rgba[0] = rgba[1] = rgba[2] = tObj->BorderColor.f[0];
      rgba[3] = tObj->BorderColor.f[3];
d784 1
a784 1
      rgba[0] = rgba[1] = rgba[2] = rgba[3] = tObj->BorderColor.f[0];
d787 1
a787 1
      COPY_4V(rgba, tObj->BorderColor.f);
d807 1
a807 1
   i = nearest_texel_location(tObj->WrapS, img, width, texcoord[0]);
d835 1
a835 1
   linear_texel_locations(tObj->WrapS, img, width, texcoord[0], &i0, &i1, &a);
d994 1
a994 1
      switch (tObj->MinFilter) {
d1029 1
a1029 1
      switch (tObj->MagFilter) {
d1068 2
a1069 2
   i = nearest_texel_location(tObj->WrapS, img, width, texcoord[0]);
   j = nearest_texel_location(tObj->WrapT, img, height, texcoord[1]);
d1103 2
a1104 2
   linear_texel_locations(tObj->WrapS, img, width, texcoord[0],  &i0, &i1, &a);
   linear_texel_locations(tObj->WrapT, img, height, texcoord[1], &j0, &j1, &b);
d1168 2
a1169 2
   ASSERT(tObj->WrapS == GL_REPEAT);
   ASSERT(tObj->WrapT == GL_REPEAT);
d1273 2
a1274 2
   ASSERT(tObj->WrapS == GL_REPEAT);
   ASSERT(tObj->WrapT == GL_REPEAT);
d1320 2
a1321 2
   if (tObj->WrapS == GL_REPEAT &&
       tObj->WrapT == GL_REPEAT &&
d1359 2
a1360 2
   ASSERT(tObj->WrapS==GL_REPEAT);
   ASSERT(tObj->WrapT==GL_REPEAT);
d1401 2
a1402 2
   ASSERT(tObj->WrapS==GL_REPEAT);
   ASSERT(tObj->WrapT==GL_REPEAT);
d1431 2
a1432 2
   const GLboolean repeatNoBorderPOT = (tObj->WrapS == GL_REPEAT)
      && (tObj->WrapT == GL_REPEAT)
d1444 1
a1444 1
      switch (tObj->MinFilter) {
d1501 1
a1501 1
      switch (tObj->MagFilter) {
d1534 390
d1945 3
a1947 3
   i = nearest_texel_location(tObj->WrapS, img, width, texcoord[0]);
   j = nearest_texel_location(tObj->WrapT, img, height, texcoord[1]);
   k = nearest_texel_location(tObj->WrapR, img, depth, texcoord[2]);
d1980 3
a1982 3
   linear_texel_locations(tObj->WrapS, img, width, texcoord[0],  &i0, &i1, &a);
   linear_texel_locations(tObj->WrapT, img, height, texcoord[1], &j0, &j1, &b);
   linear_texel_locations(tObj->WrapR, img, depth, texcoord[2],  &k0, &k1, &c);
d2187 1
a2187 1
      switch (tObj->MinFilter) {
d2222 1
a2222 1
      switch (tObj->MagFilter) {
d2484 1
a2484 1
      switch (tObj->MinFilter) {
d2521 1
a2521 1
      switch (tObj->MagFilter) {
d2556 6
a2561 6
   ASSERT(tObj->WrapS == GL_CLAMP ||
          tObj->WrapS == GL_CLAMP_TO_EDGE ||
          tObj->WrapS == GL_CLAMP_TO_BORDER);
   ASSERT(tObj->WrapT == GL_CLAMP ||
          tObj->WrapT == GL_CLAMP_TO_EDGE ||
          tObj->WrapT == GL_CLAMP_TO_BORDER);
d2566 2
a2567 2
      col = clamp_rect_coord_nearest(tObj->WrapS, texcoords[i][0], width);
      row = clamp_rect_coord_nearest(tObj->WrapT, texcoords[i][1], height);
d2590 6
a2595 6
   ASSERT(tObj->WrapS == GL_CLAMP ||
          tObj->WrapS == GL_CLAMP_TO_EDGE ||
          tObj->WrapS == GL_CLAMP_TO_BORDER);
   ASSERT(tObj->WrapT == GL_CLAMP ||
          tObj->WrapT == GL_CLAMP_TO_EDGE ||
          tObj->WrapT == GL_CLAMP_TO_BORDER);
d2604 1
a2604 1
      clamp_rect_coord_linear(tObj->WrapS, texcoords[i][0], width,
d2606 1
a2606 1
      clamp_rect_coord_linear(tObj->WrapT, texcoords[i][1], height,
d2657 1
a2657 1
      if (tObj->MinFilter == GL_NEAREST) {
d2667 1
a2667 1
      if (tObj->MagFilter == GL_NEAREST) {
d2700 2
a2701 2
   i = nearest_texel_location(tObj->WrapS, img, width, texcoord[0]);
   j = nearest_texel_location(tObj->WrapT, img, height, texcoord[1]);
d2735 2
a2736 2
   linear_texel_locations(tObj->WrapS, img, width,  texcoord[0], &i0, &i1, &a);
   linear_texel_locations(tObj->WrapT, img, height, texcoord[1], &j0, &j1, &b);
d2740 1
a2740 1
      COPY_4V(rgba, tObj->BorderColor.f);
d2925 1
a2925 1
      switch (tObj->MinFilter) {
d2968 1
a2968 1
      switch (tObj->MagFilter) {
d3009 1
a3009 1
   i = nearest_texel_location(tObj->WrapS, img, width, texcoord[0]);
d3041 1
a3041 1
   linear_texel_locations(tObj->WrapS, img, width, texcoord[0], &i0, &i1, &a);
d3206 1
a3206 1
      switch (tObj->MinFilter) {
d3245 1
a3245 1
      switch (tObj->MagFilter) {
d3311 4
a3314 4
      if (depth00 <= coord)  luminance -= d;
      if (depth01 <= coord)  luminance -= d;
      if (depth10 <= coord)  luminance -= d;
      if (depth11 <= coord)  luminance -= d;
d3317 4
a3320 4
      if (depth00 >= coord)  luminance -= d;
      if (depth01 >= coord)  luminance -= d;
      if (depth10 >= coord)  luminance -= d;
      if (depth11 >= coord)  luminance -= d;
d3323 4
a3326 4
      if (depth00 < coord)  luminance -= d;
      if (depth01 < coord)  luminance -= d;
      if (depth10 < coord)  luminance -= d;
      if (depth11 < coord)  luminance -= d;
d3329 4
a3332 4
      if (depth00 > coord)  luminance -= d;
      if (depth01 > coord)  luminance -= d;
      if (depth10 > coord)  luminance -= d;
      if (depth11 > coord)  luminance -= d;
d3335 4
a3338 4
      if (depth00 == coord)  luminance -= d;
      if (depth01 == coord)  luminance -= d;
      if (depth10 == coord)  luminance -= d;
      if (depth11 == coord)  luminance -= d;
d3341 4
a3344 4
      if (depth00 != coord)  luminance -= d;
      if (depth01 != coord)  luminance -= d;
      if (depth10 != coord)  luminance -= d;
      if (depth11 != coord)  luminance -= d;
d3347 1
a3347 1
      return 0.0;
d3354 2
a3355 2
      _mesa_problem(NULL, "Bad compare func in sample_depth_texture");
      return 0.0F;
d3368 1
a3368 1
   if (tObj->MinFilter == GL_NEAREST || tObj->MinFilter == GL_LINEAR) {
d3374 1
a3374 1
      lambda = CLAMP(lambda, tObj->MinLod, tObj->MaxLod);
d3413 1
a3413 1
   ambient = tObj->CompareFailValue;
d3415 1
a3415 1
   /* XXXX if tObj->MinFilter != tObj->MagFilter, we're ignoring lambda */
d3417 2
a3418 2
   function = (tObj->CompareMode == GL_COMPARE_R_TO_TEXTURE_ARB) ?
      tObj->CompareFunc : GL_NONE;
d3420 1
a3420 1
   if (tObj->MagFilter == GL_NEAREST) {
d3423 1
a3423 1
         GLfloat depthSample;
d3433 1
a3433 1
            depthSample = tObj->BorderColor.f[0];
d3436 1
a3436 2
         result = shadow_compare(function, texcoords[i][compare_coord],
                                 depthSample, ambient);
d3438 3
a3440 1
         switch (tObj->DepthMode) {
d3460 1
a3460 1
      ASSERT(tObj->MagFilter == GL_LINEAR);
d3462 1
a3462 1
         GLfloat depth00, depth01, depth10, depth11;
d3488 4
a3491 4
            depth00 = tObj->BorderColor.f[0];
            depth01 = tObj->BorderColor.f[0];
            depth10 = tObj->BorderColor.f[0];
            depth11 = tObj->BorderColor.f[0];
d3496 1
a3496 1
               depth00 = tObj->BorderColor.f[0];
d3502 1
a3502 1
               depth10 = tObj->BorderColor.f[0];
d3510 1
a3510 1
                  depth01 = tObj->BorderColor.f[0];
d3516 1
a3516 1
                  depth11 = tObj->BorderColor.f[0];
d3528 3
a3530 1
         result = shadow_compare4(function, texcoords[i][compare_coord],
d3534 1
a3534 1
         switch (tObj->DepthMode) {
d3590 2
a3591 1
      const GLboolean needLambda = (GLboolean) (t->MinFilter != t->MagFilter);
d3602 1
a3602 1
         else if (t->MinFilter == GL_LINEAR) {
d3606 1
a3606 1
            ASSERT(t->MinFilter == GL_NEAREST);
d3614 5
d3621 1
a3621 1
         else if (t->MinFilter == GL_LINEAR) {
d3627 3
a3629 3
            ASSERT(t->MinFilter == GL_NEAREST);
            if (t->WrapS == GL_REPEAT &&
                t->WrapT == GL_REPEAT &&
d3635 2
a3636 2
            else if (t->WrapS == GL_REPEAT &&
                     t->WrapT == GL_REPEAT &&
d3650 1
a3650 1
         else if (t->MinFilter == GL_LINEAR) {
d3654 1
a3654 1
            ASSERT(t->MinFilter == GL_NEAREST);
d3661 1
a3661 1
         else if (t->MinFilter == GL_LINEAR) {
d3665 1
a3665 1
            ASSERT(t->MinFilter == GL_NEAREST);
d3675 1
a3675 1
         else if (t->MinFilter == GL_LINEAR) {
d3679 1
a3679 1
            ASSERT(t->MinFilter == GL_NEAREST);
d3686 1
a3686 1
         else if (t->MinFilter == GL_LINEAR) {
d3690 1
a3690 1
            ASSERT(t->MinFilter == GL_NEAREST);
d3697 1
a3697 1
         else if (t->MinFilter == GL_LINEAR) {
d3701 1
a3701 1
            ASSERT(t->MinFilter == GL_NEAREST);
@


1.5
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d138 5
a142 2
 * If A is a signed integer, A % B doesn't give the right value for A < 0
 * (in terms of texture repeat).  Just casting to unsigned fixes that.
d494 1
d498 1
d502 1
a502 2
   const GLint baseLevel = texObj->BaseLevel;
   const struct gl_texture_image *img = texObj->Image[0][baseLevel];
d541 1
d545 1
d550 1
a550 2
   const GLint baseLevel = texObj->BaseLevel;
   const struct gl_texture_image *img = texObj->Image[0][baseLevel];
d801 1
a801 1
sample_1d_nearest(GLcontext *ctx,
d825 1
a825 1
sample_1d_linear(GLcontext *ctx,
d866 1
a866 1
sample_1d_nearest_mipmap_nearest(GLcontext *ctx,
d881 1
a881 1
sample_1d_linear_mipmap_nearest(GLcontext *ctx,
d896 1
a896 1
sample_1d_nearest_mipmap_linear(GLcontext *ctx,
d921 1
a921 1
sample_1d_linear_mipmap_linear(GLcontext *ctx,
d947 1
a947 1
sample_nearest_1d( GLcontext *ctx,
d963 1
a963 1
sample_linear_1d( GLcontext *ctx,
d979 1
a979 1
sample_lambda_1d( GLcontext *ctx,
d1058 1
a1058 1
sample_2d_nearest(GLcontext *ctx,
d1091 1
a1091 1
sample_2d_linear(GLcontext *ctx,
d1155 1
a1155 1
sample_2d_linear_repeat(GLcontext *ctx,
d1188 1
a1188 1
sample_2d_nearest_mipmap_nearest(GLcontext *ctx,
d1202 1
a1202 1
sample_2d_linear_mipmap_nearest(GLcontext *ctx,
d1217 1
a1217 1
sample_2d_nearest_mipmap_linear(GLcontext *ctx,
d1242 1
a1242 1
sample_2d_linear_mipmap_linear( GLcontext *ctx,
d1267 1
a1267 1
sample_2d_linear_mipmap_linear_repeat(GLcontext *ctx,
d1297 1
a1297 1
sample_nearest_2d(GLcontext *ctx,
d1313 1
a1313 1
sample_linear_2d(GLcontext *ctx,
d1346 1
a1346 1
opt_sample_rgb_2d(GLcontext *ctx,
d1374 1
d1388 1
a1388 1
opt_sample_rgba_2d(GLcontext *ctx,
d1423 1
a1423 1
sample_lambda_2d(GLcontext *ctx,
d1544 1
a1544 1
sample_3d_nearest(GLcontext *ctx,
d1576 1
a1576 1
sample_3d_linear(GLcontext *ctx,
d1670 1
a1670 1
sample_3d_nearest_mipmap_nearest(GLcontext *ctx,
d1684 1
a1684 1
sample_3d_linear_mipmap_nearest(GLcontext *ctx,
d1699 1
a1699 1
sample_3d_nearest_mipmap_linear(GLcontext *ctx,
d1724 1
a1724 1
sample_3d_linear_mipmap_linear(GLcontext *ctx,
d1750 1
a1750 1
sample_nearest_3d(GLcontext *ctx,
d1766 1
a1766 1
sample_linear_3d(GLcontext *ctx,
d1782 1
a1782 1
sample_lambda_3d(GLcontext *ctx,
d1937 1
a1937 1
sample_nearest_cube(GLcontext *ctx,
d1955 1
a1955 1
sample_linear_cube(GLcontext *ctx,
d1973 1
a1973 1
sample_cube_nearest_mipmap_nearest(GLcontext *ctx,
d2002 1
a2002 1
sample_cube_linear_mipmap_nearest(GLcontext *ctx,
d2021 1
a2021 1
sample_cube_nearest_mipmap_linear(GLcontext *ctx,
d2050 1
a2050 1
sample_cube_linear_mipmap_linear(GLcontext *ctx,
d2080 1
a2080 1
sample_lambda_cube(GLcontext *ctx,
d2154 1
a2154 1
sample_nearest_rect(GLcontext *ctx,
d2188 1
a2188 1
sample_linear_rect(GLcontext *ctx,
d2254 1
a2254 1
sample_lambda_rect(GLcontext *ctx,
d2298 1
a2298 1
sample_2d_array_nearest(GLcontext *ctx,
d2331 1
a2331 1
sample_2d_array_linear(GLcontext *ctx,
d2401 1
a2401 1
sample_2d_array_nearest_mipmap_nearest(GLcontext *ctx,
d2416 1
a2416 1
sample_2d_array_linear_mipmap_nearest(GLcontext *ctx,
d2432 1
a2432 1
sample_2d_array_nearest_mipmap_linear(GLcontext *ctx,
d2459 1
a2459 1
sample_2d_array_linear_mipmap_linear(GLcontext *ctx,
d2487 1
a2487 1
sample_nearest_2d_array(GLcontext *ctx,
d2504 1
a2504 1
sample_linear_2d_array(GLcontext *ctx,
d2520 1
a2520 1
sample_lambda_2d_array(GLcontext *ctx,
d2608 1
a2608 1
sample_1d_array_nearest(GLcontext *ctx,
d2638 1
a2638 1
sample_1d_array_linear(GLcontext *ctx,
d2687 1
a2687 1
sample_1d_array_nearest_mipmap_nearest(GLcontext *ctx,
d2702 1
a2702 1
sample_1d_array_linear_mipmap_nearest(GLcontext *ctx,
d2718 1
a2718 1
sample_1d_array_nearest_mipmap_linear(GLcontext *ctx,
d2743 1
a2743 1
sample_1d_array_linear_mipmap_linear(GLcontext *ctx,
d2769 1
a2769 1
sample_nearest_1d_array(GLcontext *ctx,
d2785 1
a2785 1
sample_linear_1d_array(GLcontext *ctx,
d2801 1
a2801 1
sample_lambda_1d_array(GLcontext *ctx,
d2972 25
a2996 1
 * Sample a shadow/depth texture.
d2999 1
a2999 1
sample_depth_texture( GLcontext *ctx,
d3004 2
a3005 2
   const GLint baseLevel = tObj->BaseLevel;
   const struct gl_texture_image *img = tObj->Image[0][baseLevel];
a3014 2
   (void) lambda;

d3037 1
a3037 1
         nearest_texcoord(tObj, texcoords[i], &col, &row, &slice);
d3060 3
d3078 1
a3078 1
         linear_texcoord(tObj, texcoords[i], &i0, &i1, &j0, &j1, &slice,
d3168 1
a3168 1
null_sample_func( GLcontext *ctx,
d3191 1
a3191 1
_swrast_choose_texture_sample_func( GLcontext *ctx,
@


1.4
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@a45 6
/**
 * Constants for integer linear interpolation.
 */
#define ILERP_SCALE 65536.0F
#define ILERP_SHIFT 16

d48 1
a48 1
 * Linear interpolation macros
a50 1
#define ILERP(IT, A, B)  ( (A) + (((IT) * ((B) - (A))) >> ILERP_SHIFT) )
a71 15
 * Do 2D/biliner interpolation of integer values.
 * \sa lerp_2d
 */
static INLINE GLint
ilerp_2d(GLint ia, GLint ib,
         GLint v00, GLint v10, GLint v01, GLint v11)
{
   /* fixed point interpolants in [0, ILERP_SCALE] */
   const GLint temp0 = ILERP(ia, v00, v10);
   const GLint temp1 = ILERP(ia, v01, v11);
   return ILERP(ib, temp0, temp1);
}


/**
a90 20
 * Do 3D/trilinear interpolation of integer values.
 * \sa lerp_2d
 */
static INLINE GLint
ilerp_3d(GLint ia, GLint ib, GLint ic,
         GLint v000, GLint v100, GLint v010, GLint v110,
         GLint v001, GLint v101, GLint v011, GLint v111)
{
   /* fixed point interpolants in [0, ILERP_SCALE] */
   const GLint temp00 = ILERP(ia, v000, v100);
   const GLint temp10 = ILERP(ia, v010, v110);
   const GLint temp01 = ILERP(ia, v001, v101);
   const GLint temp11 = ILERP(ia, v011, v111);
   const GLint temp0 = ILERP(ib, temp00, temp10);
   const GLint temp1 = ILERP(ib, temp01, temp11);
   return ILERP(ic, temp0, temp1);
}


/**
d94 1
a94 1
lerp_rgba(GLchan result[4], GLfloat t, const GLchan a[4], const GLchan b[4])
a95 1
#if CHAN_TYPE == GL_FLOAT
a99 14
#elif CHAN_TYPE == GL_UNSIGNED_SHORT
   result[0] = (GLchan) (LERP(t, a[0], b[0]) + 0.5);
   result[1] = (GLchan) (LERP(t, a[1], b[1]) + 0.5);
   result[2] = (GLchan) (LERP(t, a[2], b[2]) + 0.5);
   result[3] = (GLchan) (LERP(t, a[3], b[3]) + 0.5);
#else
   /* fixed point interpolants in [0, ILERP_SCALE] */
   const GLint it = IROUND_POS(t * ILERP_SCALE);
   ASSERT(CHAN_TYPE == GL_UNSIGNED_BYTE);
   result[0] = ILERP(it, a[0], b[0]);
   result[1] = ILERP(it, a[1], b[1]);
   result[2] = ILERP(it, a[2], b[2]);
   result[3] = ILERP(it, a[3], b[3]);
#endif
d107 3
a109 3
lerp_rgba_2d(GLchan result[4], GLfloat a, GLfloat b,
             const GLchan t00[4], const GLchan t10[4],
             const GLchan t01[4], const GLchan t11[4])
a110 1
#if CHAN_TYPE == GL_FLOAT
a114 14
#elif CHAN_TYPE == GL_UNSIGNED_SHORT
   result[0] = (GLchan) (lerp_2d(a, b, t00[0], t10[0], t01[0], t11[0]) + 0.5);
   result[1] = (GLchan) (lerp_2d(a, b, t00[1], t10[1], t01[1], t11[1]) + 0.5);
   result[2] = (GLchan) (lerp_2d(a, b, t00[2], t10[2], t01[2], t11[2]) + 0.5);
   result[3] = (GLchan) (lerp_2d(a, b, t00[3], t10[3], t01[3], t11[3]) + 0.5);
#else
   const GLint ia = IROUND_POS(a * ILERP_SCALE);
   const GLint ib = IROUND_POS(b * ILERP_SCALE);
   ASSERT(CHAN_TYPE == GL_UNSIGNED_BYTE);
   result[0] = ilerp_2d(ia, ib, t00[0], t10[0], t01[0], t11[0]);
   result[1] = ilerp_2d(ia, ib, t00[1], t10[1], t01[1], t11[1]);
   result[2] = ilerp_2d(ia, ib, t00[2], t10[2], t01[2], t11[2]);
   result[3] = ilerp_2d(ia, ib, t00[3], t10[3], t01[3], t11[3]);
#endif
d122 5
a126 5
lerp_rgba_3d(GLchan result[4], GLfloat a, GLfloat b, GLfloat c,
             const GLchan t000[4], const GLchan t100[4],
             const GLchan t010[4], const GLchan t110[4],
             const GLchan t001[4], const GLchan t101[4],
             const GLchan t011[4], const GLchan t111[4])
a129 1
#if CHAN_TYPE == GL_FLOAT
a133 15
#elif CHAN_TYPE == GL_UNSIGNED_SHORT
   for (k = 0; k < 4; k++) {
      result[k] = (GLchan)(lerp_3d(a, b, c,
                                   t000[k], t100[k], t010[k], t110[k],
                                   t001[k], t101[k], t011[k], t111[k]) + 0.5F);
   }
#else
   GLint ia = IROUND_POS(a * ILERP_SCALE);
   GLint ib = IROUND_POS(b * ILERP_SCALE);
   GLint ic = IROUND_POS(c * ILERP_SCALE);
   for (k = 0; k < 4; k++) {
      result[k] = ilerp_3d(ia, ib, ic, t000[k], t100[k], t010[k], t110[k],
                                       t001[k], t101[k], t011[k], t111[k]);
   }
#endif
d141 1
a141 1
#define REMAINDER(A, B) ((unsigned) (A) % (unsigned) (B))
d417 175
d750 38
d799 1
a799 1
                  const GLfloat texcoord[4], GLchan rgba[4])
d808 1
a808 1
      COPY_CHAN4(rgba, tObj->_BorderChan);
d811 1
a811 1
      img->FetchTexelc(img, i, 0, 0, rgba);
d823 1
a823 1
                 const GLfloat texcoord[4], GLchan rgba[4])
d829 1
a829 1
   GLchan t0[4], t1[4];  /* texels */
d844 1
a844 1
      COPY_CHAN4(t0, tObj->_BorderChan);
d847 1
a847 1
      img->FetchTexelc(img, i0, 0, 0, t0);
d850 1
a850 1
      COPY_CHAN4(t1, tObj->_BorderChan);
d853 1
a853 1
      img->FetchTexelc(img, i1, 0, 0, t1);
d864 1
a864 1
                                 const GLfloat lambda[], GLchan rgba[][4])
d879 1
a879 1
                                const GLfloat lambda[], GLchan rgba[][4])
d894 1
a894 1
                                const GLfloat lambda[], GLchan rgba[][4])
d905 1
a905 1
         GLchan t0[4], t1[4];
d919 1
a919 1
                               const GLfloat lambda[], GLchan rgba[][4])
d930 1
a930 1
         GLchan t0[4], t1[4];
d945 1
a945 1
                   GLchan rgba[][4] )
d961 1
a961 1
                  GLchan rgba[][4] )
d977 1
a977 1
                  const GLfloat lambda[], GLchan rgba[][4] )
d1057 1
a1057 1
                  GLchan rgba[])
d1073 1
a1073 1
      COPY_CHAN4(rgba, tObj->_BorderChan);
d1076 1
a1076 1
      img->FetchTexelc(img, i, j, 0, rgba);
d1090 1
a1090 1
                 GLchan rgba[])
d1097 1
a1097 1
   GLchan t00[4], t10[4], t01[4], t11[4]; /* sampled texel colors */
d1117 1
a1117 1
      COPY_CHAN4(t00, tObj->_BorderChan);
d1120 1
a1120 1
      img->FetchTexelc(img, i0, j0, 0, t00);
d1123 1
a1123 1
      COPY_CHAN4(t10, tObj->_BorderChan);
d1126 1
a1126 1
      img->FetchTexelc(img, i1, j0, 0, t10);
d1129 1
a1129 1
      COPY_CHAN4(t01, tObj->_BorderChan);
d1132 1
a1132 1
      img->FetchTexelc(img, i0, j1, 0, t01);
d1135 1
a1135 1
      COPY_CHAN4(t11, tObj->_BorderChan);
d1138 1
a1138 1
      img->FetchTexelc(img, i1, j1, 0, t11);
d1154 1
a1154 1
                        GLchan rgba[])
d1160 1
a1160 1
   GLchan t00[4], t10[4], t01[4], t11[4]; /* sampled texel colors */
d1167 1
a1167 1
   ASSERT(img->TexFormat->BaseFormat != GL_COLOR_INDEX);
d1173 4
a1176 4
   img->FetchTexelc(img, i0, j0, 0, t00);
   img->FetchTexelc(img, i1, j0, 0, t10);
   img->FetchTexelc(img, i0, j1, 0, t01);
   img->FetchTexelc(img, i1, j1, 0, t11);
d1186 1
a1186 1
                                 const GLfloat lambda[], GLchan rgba[][4])
d1200 1
a1200 1
                                const GLfloat lambda[], GLchan rgba[][4])
d1215 1
a1215 1
                                const GLfloat lambda[], GLchan rgba[][4])
d1226 1
a1226 1
         GLchan t0[4], t1[4];  /* texels */
d1240 1
a1240 1
                                const GLfloat lambda[], GLchan rgba[][4] )
d1251 1
a1251 1
         GLchan t0[4], t1[4];  /* texels */
d1265 1
a1265 1
                                      const GLfloat lambda[], GLchan rgba[][4])
d1278 1
a1278 1
         GLchan t0[4], t1[4];  /* texels */
d1295 1
a1295 1
                  const GLfloat lambda[], GLchan rgba[][4])
d1311 1
a1311 1
                 const GLfloat lambda[], GLchan rgba[][4])
d1344 1
a1344 1
                  const GLfloat lambda[], GLchan rgba[][4])
d1358 1
a1358 1
   ASSERT(img->TexFormat->MesaFormat==MESA_FORMAT_RGB);
d1365 4
a1368 4
      GLchan *texel = ((GLchan *) img->Data) + 3*pos;
      rgba[k][RCOMP] = texel[0];
      rgba[k][GCOMP] = texel[1];
      rgba[k][BCOMP] = texel[2];
d1385 1
a1385 1
                   const GLfloat lambda[], GLchan rgba[][4])
d1399 1
a1399 1
   ASSERT(img->TexFormat->MesaFormat==MESA_FORMAT_RGBA);
d1406 5
a1410 2
      const GLchan *texel = ((GLchan *) img->Data) + (pos << 2);    /* pos*4 */
      COPY_CHAN4(rgba[i], texel);
d1420 1
a1420 1
                 const GLfloat lambda[], GLchan rgba[][4])
d1429 1
a1429 1
      && (tImg->TexFormat->BaseFormat != GL_COLOR_INDEX)
d1442 2
a1443 2
            switch (tImg->TexFormat->MesaFormat) {
            case MESA_FORMAT_RGB:
d1447 1
a1447 1
            case MESA_FORMAT_RGBA:
d1499 2
a1500 2
            switch (tImg->TexFormat->MesaFormat) {
            case MESA_FORMAT_RGB:
d1504 1
a1504 1
            case MESA_FORMAT_RGBA:
d1542 1
a1542 1
                  GLchan rgba[4])
d1558 1
a1558 1
      COPY_CHAN4(rgba, tObj->_BorderChan);
d1561 1
a1561 1
      img->FetchTexelc(img, i, j, k, rgba);
d1574 1
a1574 1
                 GLchan rgba[4])
d1582 2
a1583 2
   GLchan t000[4], t010[4], t001[4], t011[4];
   GLchan t100[4], t110[4], t101[4], t111[4];
d1609 1
a1609 1
      COPY_CHAN4(t000, tObj->_BorderChan);
d1612 1
a1612 1
      img->FetchTexelc(img, i0, j0, k0, t000);
d1615 1
a1615 1
      COPY_CHAN4(t100, tObj->_BorderChan);
d1618 1
a1618 1
      img->FetchTexelc(img, i1, j0, k0, t100);
d1621 1
a1621 1
      COPY_CHAN4(t010, tObj->_BorderChan);
d1624 1
a1624 1
      img->FetchTexelc(img, i0, j1, k0, t010);
d1627 1
a1627 1
      COPY_CHAN4(t110, tObj->_BorderChan);
d1630 1
a1630 1
      img->FetchTexelc(img, i1, j1, k0, t110);
d1634 1
a1634 1
      COPY_CHAN4(t001, tObj->_BorderChan);
d1637 1
a1637 1
      img->FetchTexelc(img, i0, j0, k1, t001);
d1640 1
a1640 1
      COPY_CHAN4(t101, tObj->_BorderChan);
d1643 1
a1643 1
      img->FetchTexelc(img, i1, j0, k1, t101);
d1646 1
a1646 1
      COPY_CHAN4(t011, tObj->_BorderChan);
d1649 1
a1649 1
      img->FetchTexelc(img, i0, j1, k1, t011);
d1652 1
a1652 1
      COPY_CHAN4(t111, tObj->_BorderChan);
d1655 1
a1655 1
      img->FetchTexelc(img, i1, j1, k1, t111);
d1667 1
a1667 1
                                 const GLfloat lambda[], GLchan rgba[][4] )
d1681 1
a1681 1
                                const GLfloat lambda[], GLchan rgba[][4])
d1696 1
a1696 1
                                const GLfloat lambda[], GLchan rgba[][4])
d1707 1
a1707 1
         GLchan t0[4], t1[4];  /* texels */
d1721 1
a1721 1
                               const GLfloat lambda[], GLchan rgba[][4])
d1732 1
a1732 1
         GLchan t0[4], t1[4];  /* texels */
d1747 1
a1747 1
                  GLchan rgba[][4])
d1763 1
a1763 1
		 const GLfloat lambda[], GLchan rgba[][4])
d1779 1
a1779 1
                 GLchan rgba[][4])
d1877 1
a1877 1
   if (arx > ary && arx > arz) {
d1891 1
a1891 1
   else if (ary > arx && ary > arz) {
d1920 6
a1925 2
   newCoord[0] = ( sc / ma + 1.0F ) * 0.5F;
   newCoord[1] = ( tc / ma + 1.0F ) * 0.5F;
d1934 1
a1934 1
                    GLchan rgba[][4])
d1952 1
a1952 1
		   const GLfloat lambda[], GLchan rgba[][4])
d1970 1
a1970 1
                                   const GLfloat lambda[], GLchan rgba[][4])
d1999 1
a1999 1
                                  const GLfloat lambda[], GLchan rgba[][4])
d2018 1
a2018 1
                                  const GLfloat lambda[], GLchan rgba[][4])
d2033 1
a2033 1
         GLchan t0[4], t1[4];  /* texels */
d2047 1
a2047 1
                                 const GLfloat lambda[], GLchan rgba[][4])
d2062 1
a2062 1
         GLchan t0[4], t1[4];
d2077 1
a2077 1
		   GLchan rgba[][4])
a2146 61
/**
 * Do clamp/wrap for a texture rectangle coord, GL_NEAREST filter mode.
 */
static INLINE GLint
clamp_rect_coord_nearest(GLenum wrapMode, GLfloat coord, GLint max)
{
   switch (wrapMode) {
   case GL_CLAMP:
      return IFLOOR( CLAMP(coord, 0.0F, max - 1) );
   case GL_CLAMP_TO_EDGE:
      return IFLOOR( CLAMP(coord, 0.5F, max - 0.5F) );
   case GL_CLAMP_TO_BORDER:
      return IFLOOR( CLAMP(coord, -0.5F, max + 0.5F) );
   default:
      _mesa_problem(NULL, "bad wrapMode in clamp_rect_coord_nearest");
      return 0;
   }
}


/**
 * As above, but GL_LINEAR filtering.
 */
static INLINE void
clamp_rect_coord_linear(GLenum wrapMode, GLfloat coord, GLint max,
                        GLint *i0out, GLint *i1out, GLfloat *weight)
{
   GLfloat fcol;
   GLint i0, i1;
   switch (wrapMode) {
   case GL_CLAMP:
      /* Not exactly what the spec says, but it matches NVIDIA output */
      fcol = CLAMP(coord - 0.5F, 0.0, max-1);
      i0 = IFLOOR(fcol);
      i1 = i0 + 1;
      break;
   case GL_CLAMP_TO_EDGE:
      fcol = CLAMP(coord, 0.5F, max - 0.5F);
      fcol -= 0.5F;
      i0 = IFLOOR(fcol);
      i1 = i0 + 1;
      if (i1 > max - 1)
         i1 = max - 1;
      break;
   case GL_CLAMP_TO_BORDER:
      fcol = CLAMP(coord, -0.5F, max + 0.5F);
      fcol -= 0.5F;
      i0 = IFLOOR(fcol);
      i1 = i0 + 1;
      break;
   default:
      _mesa_problem(NULL, "bad wrapMode in clamp_rect_coord_linear");
      i0 = i1 = 0;
      fcol = 0.0F;
   }
   *i0out = i0;
   *i1out = i1;
   *weight = FRAC(fcol);
}


d2151 1
a2151 1
                    GLchan rgba[][4])
d2167 1
a2167 1
   ASSERT(img->TexFormat->BaseFormat != GL_COLOR_INDEX);
d2174 1
a2174 1
         COPY_CHAN4(rgba[i], tObj->_BorderChan);
d2176 1
a2176 1
         img->FetchTexelc(img, col, row, 0, rgba[i]);
d2185 1
a2185 1
		   const GLfloat lambda[], GLchan rgba[][4])
d2201 1
a2201 1
   ASSERT(img->TexFormat->BaseFormat != GL_COLOR_INDEX);
d2205 1
a2205 1
      GLchan t00[4], t01[4], t10[4], t11[4];
d2222 1
a2222 1
         COPY_CHAN4(t00, tObj->_BorderChan);
d2224 1
a2224 1
         img->FetchTexelc(img, i0, j0, 0, t00);
d2227 1
a2227 1
         COPY_CHAN4(t10, tObj->_BorderChan);
d2229 1
a2229 1
         img->FetchTexelc(img, i1, j0, 0, t10);
d2232 1
a2232 1
         COPY_CHAN4(t01, tObj->_BorderChan);
d2234 1
a2234 1
         img->FetchTexelc(img, i0, j1, 0, t01);
d2237 1
a2237 1
         COPY_CHAN4(t11, tObj->_BorderChan);
d2239 1
a2239 1
         img->FetchTexelc(img, i1, j1, 0, t11);
d2251 1
a2251 1
		   GLchan rgba[][4])
a2283 1

d2296 1
a2296 1
                        GLchan rgba[4])
d2307 1
a2307 1
   array = clamp_rect_coord_nearest(tObj->WrapR, texcoord[2], depth);
d2313 1
a2313 1
      COPY_CHAN4(rgba, tObj->_BorderChan);
d2316 1
a2316 1
      img->FetchTexelc(img, i, j, array, rgba);
d2329 1
a2329 1
                       GLchan rgba[4])
d2338 1
a2338 1
   GLchan t00[4], t01[4], t10[4], t11[4];
d2342 1
a2342 1
   array = clamp_rect_coord_nearest(tObj->WrapR, texcoord[2], depth);
d2345 1
a2345 1
      COPY_CHAN4(rgba, tObj->_BorderChan);
d2364 1
a2364 1
	 COPY_CHAN4(t00, tObj->_BorderChan);
d2367 1
a2367 1
	 img->FetchTexelc(img, i0, j0, array, t00);
d2370 1
a2370 1
	 COPY_CHAN4(t10, tObj->_BorderChan);
d2373 1
a2373 1
	 img->FetchTexelc(img, i1, j0, array, t10);
d2376 1
a2376 1
	 COPY_CHAN4(t01, tObj->_BorderChan);
d2379 1
a2379 1
	 img->FetchTexelc(img, i0, j1, array, t01);
d2382 1
a2382 1
	 COPY_CHAN4(t11, tObj->_BorderChan);
d2385 1
a2385 1
	 img->FetchTexelc(img, i1, j1, array, t11);
d2398 1
a2398 1
                                       const GLfloat lambda[], GLchan rgba[][4])
d2413 1
a2413 1
                                      const GLfloat lambda[], GLchan rgba[][4])
d2429 1
a2429 1
                                      const GLfloat lambda[], GLchan rgba[][4])
d2440 1
a2440 1
         GLchan t0[4], t1[4];  /* texels */
d2456 1
a2456 1
                                     const GLfloat lambda[], GLchan rgba[][4])
d2467 1
a2467 1
         GLchan t0[4], t1[4];  /* texels */
d2484 1
a2484 1
                        GLchan rgba[][4])
d2501 1
a2501 1
                       const GLfloat lambda[], GLchan rgba[][4])
d2517 1
a2517 1
                       GLchan rgba[][4])
d2606 1
a2606 1
                        GLchan rgba[4])
d2615 1
a2615 1
   array = clamp_rect_coord_nearest(tObj->WrapT, texcoord[1], height);
d2620 1
a2620 1
      COPY_CHAN4(rgba, tObj->_BorderChan);
d2623 1
a2623 1
      img->FetchTexelc(img, i, array, 0, rgba);
d2636 1
a2636 1
                       GLchan rgba[4])
d2644 1
a2644 1
   GLchan t0[4], t1[4];
d2647 1
a2647 1
   array = clamp_rect_coord_nearest(tObj->WrapT, texcoord[1], height);
d2663 1
a2663 1
      COPY_CHAN4(t0, tObj->_BorderChan);
d2666 1
a2666 1
      img->FetchTexelc(img, i0, array, 0, t0);
d2669 1
a2669 1
      COPY_CHAN4(t1, tObj->_BorderChan);
d2672 1
a2672 1
      img->FetchTexelc(img, i1, array, 0, t1);
d2684 1
a2684 1
                                       const GLfloat lambda[], GLchan rgba[][4])
d2699 1
a2699 1
                                      const GLfloat lambda[], GLchan rgba[][4])
d2715 1
a2715 1
                                      const GLfloat lambda[], GLchan rgba[][4])
d2726 1
a2726 1
         GLchan t0[4], t1[4];  /* texels */
d2740 1
a2740 1
                                     const GLfloat lambda[], GLchan rgba[][4])
d2751 1
a2751 1
         GLchan t0[4], t1[4];  /* texels */
d2766 1
a2766 1
                        GLchan rgba[][4])
d2782 1
a2782 1
                       const GLfloat lambda[], GLchan rgba[][4])
d2798 1
a2798 1
                       GLchan rgba[][4])
d2870 96
d2972 1
a2972 1
                      GLchan texel[][4] )
d2981 1
a2981 1
   GLchan ambient;
d2983 1
a2983 1
   GLchan result;
d2987 2
a2988 2
   ASSERT(img->TexFormat->BaseFormat == GL_DEPTH_COMPONENT ||
          img->TexFormat->BaseFormat == GL_DEPTH_STENCIL_EXT);
d2996 1
a2996 1
   UNCLAMPED_FLOAT_TO_CHAN(ambient, tObj->ShadowAmbient);
d3000 3
a3002 1
   function = tObj->_Function;
d3009 1
a3009 39
         switch (tObj->Target) {
         case GL_TEXTURE_RECTANGLE_ARB:
            col = clamp_rect_coord_nearest(tObj->WrapS, texcoords[i][0], width);
            row = clamp_rect_coord_nearest(tObj->WrapT, texcoords[i][1], height);
            slice = 0;
            break;
            
         case GL_TEXTURE_1D:
            col = nearest_texel_location(tObj->WrapS, img, width,
                                         texcoords[i][0]);
            row = 0;
            slice = 0;
            break;

         case GL_TEXTURE_2D:
            col = nearest_texel_location(tObj->WrapS, img, width,
                                         texcoords[i][0]);
            row = nearest_texel_location(tObj->WrapT, img, height,
                                         texcoords[i][1]);
            slice = 0;
            break;

         case GL_TEXTURE_1D_ARRAY_EXT:
            col = nearest_texel_location(tObj->WrapS, img, width,
                                         texcoords[i][0]);
            row = clamp_rect_coord_nearest(tObj->WrapT, texcoords[i][1], height);
            slice = 0;
            break;

         case GL_TEXTURE_2D_ARRAY_EXT:
            col = nearest_texel_location(tObj->WrapS, img, width,
                                         texcoords[i][0]);
            row = nearest_texel_location(tObj->WrapT, img, height,
                                         texcoords[i][1]);
            slice = clamp_rect_coord_nearest(tObj->WrapR, texcoords[i][2], depth);
            break;
         default:
            col = row = slice = 0;
         }
d3016 1
a3016 1
            depthSample = tObj->BorderColor[0];
d3019 2
a3020 32
         switch (function) {
         case GL_LEQUAL:
            result = (texcoords[i][compare_coord] <= depthSample) ? CHAN_MAX : ambient;
            break;
         case GL_GEQUAL:
            result = (texcoords[i][compare_coord] >= depthSample) ? CHAN_MAX : ambient;
            break;
         case GL_LESS:
            result = (texcoords[i][compare_coord] < depthSample) ? CHAN_MAX : ambient;
            break;
         case GL_GREATER:
            result = (texcoords[i][compare_coord] > depthSample) ? CHAN_MAX : ambient;
            break;
         case GL_EQUAL:
            result = (texcoords[i][compare_coord] == depthSample) ? CHAN_MAX : ambient;
            break;
         case GL_NOTEQUAL:
            result = (texcoords[i][compare_coord] != depthSample) ? CHAN_MAX : ambient;
            break;
         case GL_ALWAYS:
            result = CHAN_MAX;
            break;
         case GL_NEVER:
            result = ambient;
            break;
         case GL_NONE:
            CLAMPED_FLOAT_TO_CHAN(result, depthSample);
            break;
         default:
            _mesa_problem(ctx, "Bad compare func in sample_depth_texture");
            return;
         }
d3024 1
a3024 4
            texel[i][RCOMP] = result;
            texel[i][GCOMP] = result;
            texel[i][BCOMP] = result;
            texel[i][ACOMP] = CHAN_MAX;
d3027 1
a3027 4
            texel[i][RCOMP] = result;
            texel[i][GCOMP] = result;
            texel[i][BCOMP] = result;
            texel[i][ACOMP] = result;
d3030 1
a3030 4
            texel[i][RCOMP] = 0;
            texel[i][GCOMP] = 0;
            texel[i][BCOMP] = 0;
            texel[i][ACOMP] = result;
d3044 1
a3044 1
         GLfloat a, b;
d3047 2
a3048 36
         switch (tObj->Target) {
         case GL_TEXTURE_RECTANGLE_ARB:
            clamp_rect_coord_linear(tObj->WrapS, texcoords[i][0],
                                    width, &i0, &i1, &a);
            clamp_rect_coord_linear(tObj->WrapT, texcoords[i][1],
                                    height, &j0, &j1, &b);
            slice = 0;
            break;

         case GL_TEXTURE_1D:
         case GL_TEXTURE_2D:
            linear_texel_locations(tObj->WrapS, img, width,
                                   texcoords[i][0], &i0, &i1, &a);
            linear_texel_locations(tObj->WrapT, img, height,
                                   texcoords[i][1], &j0, &j1, &b);
            slice = 0;
            break;

         case GL_TEXTURE_1D_ARRAY_EXT:
            linear_texel_locations(tObj->WrapS, img, width,
                                   texcoords[i][0], &i0, &i1, &a);
            j0 = clamp_rect_coord_nearest(tObj->WrapT, texcoords[i][1], height);
            j1 = j0;
            slice = 0;
            break;

         case GL_TEXTURE_2D_ARRAY_EXT:
            linear_texel_locations(tObj->WrapS, img, width,
                                   texcoords[i][0], &i0, &i1, &a);
            linear_texel_locations(tObj->WrapT, img, height,
                                   texcoords[i][1], &j0, &j1, &b);
            slice = clamp_rect_coord_nearest(tObj->WrapR, texcoords[i][2], depth);
            break;
         default:
            slice = 0;
         }
d3067 4
a3070 4
            depth00 = tObj->BorderColor[0];
            depth01 = tObj->BorderColor[0];
            depth10 = tObj->BorderColor[0];
            depth11 = tObj->BorderColor[0];
d3075 1
a3075 1
               depth00 = tObj->BorderColor[0];
d3081 1
a3081 1
               depth10 = tObj->BorderColor[0];
d3089 1
a3089 1
                  depth01 = tObj->BorderColor[0];
d3095 1
a3095 1
                  depth11 = tObj->BorderColor[0];
d3107 3
a3109 82
         if (0) {
            /* compute a single weighted depth sample and do one comparison */
            const GLfloat depthSample
               = lerp_2d(a, b, depth00, depth10, depth01, depth11);
            if ((depthSample <= texcoords[i][compare_coord] && function == GL_LEQUAL) ||
                (depthSample >= texcoords[i][compare_coord] && function == GL_GEQUAL)) {
               result  = ambient;
            }
            else {
               result = CHAN_MAX;
            }
         }
         else {
            /* Do four depth/R comparisons and compute a weighted result.
             * If this touches on somebody's I.P., I'll remove this code
             * upon request.
             */
            const GLfloat d = (CHAN_MAXF - (GLfloat) ambient) * 0.25F;
            GLfloat luminance = CHAN_MAXF;

            switch (function) {
            case GL_LEQUAL:
               if (depth00 <= texcoords[i][compare_coord])  luminance -= d;
               if (depth01 <= texcoords[i][compare_coord])  luminance -= d;
               if (depth10 <= texcoords[i][compare_coord])  luminance -= d;
               if (depth11 <= texcoords[i][compare_coord])  luminance -= d;
               result = (GLchan) luminance;
               break;
            case GL_GEQUAL:
               if (depth00 >= texcoords[i][compare_coord])  luminance -= d;
               if (depth01 >= texcoords[i][compare_coord])  luminance -= d;
               if (depth10 >= texcoords[i][compare_coord])  luminance -= d;
               if (depth11 >= texcoords[i][compare_coord])  luminance -= d;
               result = (GLchan) luminance;
               break;
            case GL_LESS:
               if (depth00 < texcoords[i][compare_coord])  luminance -= d;
               if (depth01 < texcoords[i][compare_coord])  luminance -= d;
               if (depth10 < texcoords[i][compare_coord])  luminance -= d;
               if (depth11 < texcoords[i][compare_coord])  luminance -= d;
               result = (GLchan) luminance;
               break;
            case GL_GREATER:
               if (depth00 > texcoords[i][compare_coord])  luminance -= d;
               if (depth01 > texcoords[i][compare_coord])  luminance -= d;
               if (depth10 > texcoords[i][compare_coord])  luminance -= d;
               if (depth11 > texcoords[i][compare_coord])  luminance -= d;
               result = (GLchan) luminance;
               break;
            case GL_EQUAL:
               if (depth00 == texcoords[i][compare_coord])  luminance -= d;
               if (depth01 == texcoords[i][compare_coord])  luminance -= d;
               if (depth10 == texcoords[i][compare_coord])  luminance -= d;
               if (depth11 == texcoords[i][compare_coord])  luminance -= d;
               result = (GLchan) luminance;
               break;
            case GL_NOTEQUAL:
               if (depth00 != texcoords[i][compare_coord])  luminance -= d;
               if (depth01 != texcoords[i][compare_coord])  luminance -= d;
               if (depth10 != texcoords[i][compare_coord])  luminance -= d;
               if (depth11 != texcoords[i][compare_coord])  luminance -= d;
               result = (GLchan) luminance;
               break;
            case GL_ALWAYS:
               result = 0;
               break;
            case GL_NEVER:
               result = CHAN_MAX;
               break;
            case GL_NONE:
               /* ordinary bilinear filtering */
               {
                  const GLfloat depthSample
                     = lerp_2d(a, b, depth00, depth10, depth01, depth11);
                  CLAMPED_FLOAT_TO_CHAN(result, depthSample);
               }
               break;
            default:
               _mesa_problem(ctx, "Bad compare func in sample_depth_texture");
               return;
            }
         }
d3113 1
a3113 4
            texel[i][RCOMP] = result;
            texel[i][GCOMP] = result;
            texel[i][BCOMP] = result;
            texel[i][ACOMP] = CHAN_MAX;
d3116 1
a3116 4
            texel[i][RCOMP] = result;
            texel[i][GCOMP] = result;
            texel[i][BCOMP] = result;
            texel[i][ACOMP] = result;
d3119 1
a3119 4
            texel[i][RCOMP] = 0;
            texel[i][GCOMP] = 0;
            texel[i][BCOMP] = 0;
            texel[i][ACOMP] = result;
d3124 1
a3129 97
#if 0
/*
 * Experimental depth texture sampling function.
 */
static void
sample_depth_texture2(const GLcontext *ctx,
                     const struct gl_texture_unit *texUnit,
                     GLuint n, const GLfloat texcoords[][4],
                     GLchan texel[][4])
{
   const struct gl_texture_object *texObj = texUnit->_Current;
   const GLint baseLevel = texObj->BaseLevel;
   const struct gl_texture_image *texImage = texObj->Image[0][baseLevel];
   const GLuint width = texImage->Width;
   const GLuint height = texImage->Height;
   GLchan ambient;
   GLboolean lequal, gequal;

   if (texObj->Target != GL_TEXTURE_2D) {
      _mesa_problem(ctx, "only 2-D depth textures supported at this time");
      return;
   }

   if (texObj->MinFilter != texObj->MagFilter) {
      _mesa_problem(ctx, "mipmapped depth textures not supported at this time");
      return;
   }

   /* XXX the GL_SGIX_shadow extension spec doesn't say what to do if
    * GL_TEXTURE_COMPARE_SGIX == GL_TRUE but the current texture object
    * isn't a depth texture.
    */
   if (texImage->TexFormat->BaseFormat != GL_DEPTH_COMPONENT) {
      _mesa_problem(ctx,"GL_TEXTURE_COMPARE_SGIX enabled with non-depth texture");
      return;
   }

   UNCLAMPED_FLOAT_TO_CHAN(ambient, tObj->ShadowAmbient);

   if (texObj->CompareOperator == GL_TEXTURE_LEQUAL_R_SGIX) {
      lequal = GL_TRUE;
      gequal = GL_FALSE;
   }
   else {
      lequal = GL_FALSE;
      gequal = GL_TRUE;
   }

   {
      GLuint i;
      for (i = 0; i < n; i++) {
         const GLint K = 3;
         GLint col, row, ii, jj, imin, imax, jmin, jmax, samples, count;
         GLfloat w;
         GLchan lum;
         col = nearest_texel_location(texObj->WrapS, img, width,
                                      texcoords[i][0]);
         row = nearest_texel_location(texObj->WrapT, img, height,
                                      texcoords[i][1]);

         imin = col - K;
         imax = col + K;
         jmin = row - K;
         jmax = row + K;

         if (imin < 0)  imin = 0;
         if (imax >= width)  imax = width - 1;
         if (jmin < 0)  jmin = 0;
         if (jmax >= height) jmax = height - 1;

         samples = (imax - imin + 1) * (jmax - jmin + 1);
         count = 0;
         for (jj = jmin; jj <= jmax; jj++) {
            for (ii = imin; ii <= imax; ii++) {
               GLfloat depthSample;
               texImage->FetchTexelf(texImage, ii, jj, 0, &depthSample);
               if ((depthSample <= r[i] && lequal) ||
                   (depthSample >= r[i] && gequal)) {
                  count++;
               }
            }
         }

         w = (GLfloat) count / (GLfloat) samples;
         w = CHAN_MAXF - w * (CHAN_MAXF - (GLfloat) ambient);
         lum = (GLint) w;

         texel[i][RCOMP] = lum;
         texel[i][GCOMP] = lum;
         texel[i][BCOMP] = lum;
         texel[i][ACOMP] = CHAN_MAX;
      }
   }
}
#endif


d3140 1
a3140 1
		  GLchan rgba[][4])
d3151 1
a3151 1
      rgba[i][ACOMP] = CHAN_MAX;
d3168 1
a3168 1
      const GLenum format = t->Image[0][t->BaseLevel]->TexFormat->BaseFormat;
d3203 1
a3203 1
                img->TexFormat->MesaFormat == MESA_FORMAT_RGB) {
d3210 1
a3210 1
                     img->TexFormat->MesaFormat == MESA_FORMAT_RGBA) {
@


1.3
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d3 1
a3 1
 * Version:  7.0.3
d5 1
a5 1
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
d26 5
a30 5
#include "glheader.h"
#include "context.h"
#include "colormac.h"
#include "imports.h"
#include "texformat.h"
d36 10
d236 2
a237 2
 *    S = texcoord in [0,1]
 *    SIZE = width (or height or depth) of texture
d239 2
a240 2
 *    U = texcoord in [0, width]
 *    I0, I1 = two nearest texel indexes
d242 121
a362 115
#define COMPUTE_LINEAR_TEXEL_LOCATIONS(wrapMode, S, U, SIZE, I0, I1)	\
{									\
   switch (wrapMode) {							\
   case GL_REPEAT:							\
      U = S * SIZE - 0.5F;						\
      if (img->_IsPowerOfTwo) {						\
         I0 = IFLOOR(U) & (SIZE - 1);					\
         I1 = (I0 + 1) & (SIZE - 1);					\
      }									\
      else {								\
         I0 = REMAINDER(IFLOOR(U), SIZE);				\
         I1 = REMAINDER(I0 + 1, SIZE);					\
      }									\
      break;								\
   case GL_CLAMP_TO_EDGE:						\
      if (S <= 0.0F)							\
         U = 0.0F;							\
      else if (S >= 1.0F)						\
         U = (GLfloat) SIZE;						\
      else								\
         U = S * SIZE;							\
      U -= 0.5F;							\
      I0 = IFLOOR(U);							\
      I1 = I0 + 1;							\
      if (I0 < 0)							\
         I0 = 0;							\
      if (I1 >= (GLint) SIZE)						\
         I1 = SIZE - 1;							\
      break;								\
   case GL_CLAMP_TO_BORDER:						\
      {									\
         const GLfloat min = -1.0F / (2.0F * SIZE);			\
         const GLfloat max = 1.0F - min;				\
         if (S <= min)							\
            U = min * SIZE;						\
         else if (S >= max)						\
            U = max * SIZE;						\
         else								\
            U = S * SIZE;						\
         U -= 0.5F;							\
         I0 = IFLOOR(U);						\
         I1 = I0 + 1;							\
      }									\
      break;								\
   case GL_MIRRORED_REPEAT:						\
      {									\
         const GLint flr = IFLOOR(S);					\
         if (flr & 1)							\
            U = 1.0F - (S - (GLfloat) flr);	/* flr is odd */	\
         else								\
            U = S - (GLfloat) flr;		/* flr is even */	\
         U = (U * SIZE) - 0.5F;						\
         I0 = IFLOOR(U);						\
         I1 = I0 + 1;							\
         if (I0 < 0)							\
            I0 = 0;							\
         if (I1 >= (GLint) SIZE)					\
            I1 = SIZE - 1;						\
      }									\
      break;								\
   case GL_MIRROR_CLAMP_EXT:						\
      U = FABSF(S);							\
      if (U >= 1.0F)							\
         U = (GLfloat) SIZE;						\
      else								\
         U *= SIZE;							\
      U -= 0.5F;							\
      I0 = IFLOOR(U);							\
      I1 = I0 + 1;							\
      break;								\
   case GL_MIRROR_CLAMP_TO_EDGE_EXT:					\
      U = FABSF(S);							\
      if (U >= 1.0F)							\
         U = (GLfloat) SIZE;						\
      else								\
         U *= SIZE;							\
      U -= 0.5F;							\
      I0 = IFLOOR(U);							\
      I1 = I0 + 1;							\
      if (I0 < 0)							\
         I0 = 0;							\
      if (I1 >= (GLint) SIZE)						\
         I1 = SIZE - 1;							\
      break;								\
   case GL_MIRROR_CLAMP_TO_BORDER_EXT:					\
      {									\
         const GLfloat min = -1.0F / (2.0F * SIZE);			\
         const GLfloat max = 1.0F - min;				\
         U = FABSF(S);							\
         if (U <= min)							\
            U = min * SIZE;						\
         else if (U >= max)						\
            U = max * SIZE;						\
         else								\
            U *= SIZE;							\
         U -= 0.5F;							\
         I0 = IFLOOR(U);						\
         I1 = I0 + 1;							\
      }									\
      break;								\
   case GL_CLAMP:							\
      if (S <= 0.0F)							\
         U = 0.0F;							\
      else if (S >= 1.0F)						\
         U = (GLfloat) SIZE;						\
      else								\
         U = S * SIZE;							\
      U -= 0.5F;							\
      I0 = IFLOOR(U);							\
      I1 = I0 + 1;							\
      break;								\
   default:								\
      _mesa_problem(ctx, "Bad wrap mode");				\
      return;								\
   }									\
d369 120
a488 115
#define COMPUTE_NEAREST_TEXEL_LOCATION(wrapMode, S, SIZE, I)		\
{									\
   switch (wrapMode) {							\
   case GL_REPEAT:							\
      /* s limited to [0,1) */						\
      /* i limited to [0,size-1] */					\
      I = IFLOOR(S * SIZE);						\
      if (img->_IsPowerOfTwo)						\
         I &= (SIZE - 1);						\
      else								\
         I = REMAINDER(I, SIZE);					\
      break;								\
   case GL_CLAMP_TO_EDGE:						\
      {									\
         /* s limited to [min,max] */					\
         /* i limited to [0, size-1] */					\
         const GLfloat min = 1.0F / (2.0F * SIZE);			\
         const GLfloat max = 1.0F - min;				\
         if (S < min)							\
            I = 0;							\
         else if (S > max)						\
            I = SIZE - 1;						\
         else								\
            I = IFLOOR(S * SIZE);					\
      }									\
      break;								\
   case GL_CLAMP_TO_BORDER:						\
      {									\
         /* s limited to [min,max] */					\
         /* i limited to [-1, size] */					\
         const GLfloat min = -1.0F / (2.0F * SIZE);			\
         const GLfloat max = 1.0F - min;				\
         if (S <= min)							\
            I = -1;							\
         else if (S >= max)						\
            I = SIZE;							\
         else								\
            I = IFLOOR(S * SIZE);					\
      }									\
      break;								\
   case GL_MIRRORED_REPEAT:						\
      {									\
         const GLfloat min = 1.0F / (2.0F * SIZE);			\
         const GLfloat max = 1.0F - min;				\
         const GLint flr = IFLOOR(S);					\
         GLfloat u;							\
         if (flr & 1)							\
            u = 1.0F - (S - (GLfloat) flr);	/* flr is odd */	\
         else								\
            u = S - (GLfloat) flr;		/* flr is even */	\
         if (u < min)							\
            I = 0;							\
         else if (u > max)						\
            I = SIZE - 1;						\
         else								\
            I = IFLOOR(u * SIZE);					\
      }									\
      break;								\
   case GL_MIRROR_CLAMP_EXT:						\
      {									\
         /* s limited to [0,1] */					\
         /* i limited to [0,size-1] */					\
         const GLfloat u = FABSF(S);					\
         if (u <= 0.0F)							\
            I = 0;							\
         else if (u >= 1.0F)						\
            I = SIZE - 1;						\
         else								\
            I = IFLOOR(u * SIZE);					\
      }									\
      break;								\
   case GL_MIRROR_CLAMP_TO_EDGE_EXT:					\
      {									\
         /* s limited to [min,max] */					\
         /* i limited to [0, size-1] */					\
         const GLfloat min = 1.0F / (2.0F * SIZE);			\
         const GLfloat max = 1.0F - min;				\
         const GLfloat u = FABSF(S);					\
         if (u < min)							\
            I = 0;							\
         else if (u > max)						\
            I = SIZE - 1;						\
         else								\
            I = IFLOOR(u * SIZE);					\
      }									\
      break;								\
   case GL_MIRROR_CLAMP_TO_BORDER_EXT:					\
      {									\
         /* s limited to [min,max] */					\
         /* i limited to [0, size-1] */					\
         const GLfloat min = -1.0F / (2.0F * SIZE);			\
         const GLfloat max = 1.0F - min;				\
         const GLfloat u = FABSF(S);					\
         if (u < min)							\
            I = -1;							\
         else if (u > max)						\
            I = SIZE;							\
         else								\
            I = IFLOOR(u * SIZE);					\
      }									\
      break;								\
   case GL_CLAMP:							\
      /* s limited to [0,1] */						\
      /* i limited to [0,size-1] */					\
      if (S <= 0.0F)							\
         I = 0;								\
      else if (S >= 1.0F)						\
         I = SIZE - 1;							\
      else								\
         I = IFLOOR(S * SIZE);						\
      break;								\
   default:								\
      _mesa_problem(ctx, "Bad wrap mode");				\
      return;								\
   }									\
d493 8
a500 5
#define COMPUTE_LINEAR_REPEAT_TEXEL_LOCATION(S, U, SIZE, I0, I1)	\
{									\
   U = S * SIZE - 0.5F;							\
   I0 = IFLOOR(U) & (SIZE - 1);						\
   I1 = (I0 + 1) & (SIZE - 1);						\
a542 11
 * Note, the FRAC macro has to work perfectly.  Otherwise you'll sometimes
 * see 1-pixel bands of improperly weighted linear-filtered textures.
 * The tests/texwrap.c demo is a good test.
 * Also note, FRAC(x) doesn't truly return the fractional part of x for x < 0.
 * Instead, if x < 0 then FRAC(x) = 1 - true_frac(x).
 */
#define FRAC(f)  ((f) - IFLOOR(f))



/*
d554 1
a554 1
/*
d667 1
a667 1
/*
d670 1
a670 1
static void
d678 1
a678 1
   COMPUTE_NEAREST_TEXEL_LOCATION(tObj->WrapS, texcoord[0], width, i);
d691 1
a691 1
/*
d694 1
a694 1
static void
a701 1
   GLfloat u;
d706 1
a706 1
   COMPUTE_LINEAR_TEXEL_LOCATIONS(tObj->WrapS, texcoord[0], u, width, i0, i1);
a730 1
   a = FRAC(u);
a789 1

d815 1
a815 1

d825 1
a825 1
   for (i=0;i<n;i++) {
d831 1
a831 1

d841 1
a841 1
   for (i=0;i<n;i++) {
d847 1
a847 5
/*
 * Given an (s) texture coordinate and lambda (level of detail) value,
 * return a texture sample.
 *
 */
d924 1
a924 1
/*
d939 2
a940 2
   COMPUTE_NEAREST_TEXEL_LOCATION(tObj->WrapS, texcoord[0], width,  i);
   COMPUTE_NEAREST_TEXEL_LOCATION(tObj->WrapT, texcoord[1], height, j);
a955 1

a970 1
   GLfloat u, v;
d974 2
a975 2
   COMPUTE_LINEAR_TEXEL_LOCATIONS(tObj->WrapS, texcoord[0], u, width,  i0, i1);
   COMPUTE_LINEAR_TEXEL_LOCATIONS(tObj->WrapT, texcoord[1], v, height, j0, j1);
a1015 2
   a = FRAC(u);
   b = FRAC(v);
d1020 1
a1020 1
/*
d1034 1
a1034 2
   GLfloat u, v;
   GLfloat a, b;
d1045 2
a1046 2
   COMPUTE_LINEAR_REPEAT_TEXEL_LOCATION(texcoord[0], u, width,  i0, i1);
   COMPUTE_LINEAR_REPEAT_TEXEL_LOCATION(texcoord[1], v, height, j0, j1);
d1053 1
a1053 3
   a = FRAC(u);
   b = FRAC(v);
   lerp_rgba_2d(rgba, a, b, t00, t10, t01, t11);
a1056 1

a1070 1

a1085 1

a1110 2

/* Trilinear filtering */
d1137 4
a1140 4
sample_2d_linear_mipmap_linear_repeat( GLcontext *ctx,
                                       const struct gl_texture_object *tObj,
                                       GLuint n, const GLfloat texcoord[][4],
                                       const GLfloat lambda[], GLchan rgba[][4] )
d1155 4
a1158 2
         sample_2d_linear_repeat(ctx, tObj, tObj->Image[0][level  ], texcoord[i], t0);
         sample_2d_linear_repeat(ctx, tObj, tObj->Image[0][level+1], texcoord[i], t1);
d1165 1
d1167 4
a1170 4
sample_nearest_2d( GLcontext *ctx,
                   const struct gl_texture_object *tObj, GLuint n,
                   const GLfloat texcoords[][4],
                   const GLfloat lambda[], GLchan rgba[][4] )
d1175 1
a1175 1
   for (i=0;i<n;i++) {
d1181 1
a1181 1

d1183 4
a1186 4
sample_linear_2d( GLcontext *ctx,
                  const struct gl_texture_object *tObj, GLuint n,
                  const GLfloat texcoords[][4],
                  const GLfloat lambda[], GLchan rgba[][4] )
d1195 1
a1195 1
      for (i=0;i<n;i++) {
d1200 1
a1200 1
      for (i=0;i<n;i++) {
d1207 1
a1207 1
/*
d1216 4
a1219 4
opt_sample_rgb_2d( GLcontext *ctx,
                   const struct gl_texture_object *tObj,
                   GLuint n, const GLfloat texcoords[][4],
                   const GLfloat lambda[], GLchan rgba[][4] )
d1248 1
a1248 1
/*
d1257 4
a1260 4
opt_sample_rgba_2d( GLcontext *ctx,
                    const struct gl_texture_object *tObj,
                    GLuint n, const GLfloat texcoords[][4],
                    const GLfloat lambda[], GLchan rgba[][4] )
d1287 1
a1287 4
/*
 * Given an array of texture coordinate and lambda (level of detail)
 * values, return an array of texture sample.
 */
d1289 4
a1292 4
sample_lambda_2d( GLcontext *ctx,
                  const struct gl_texture_object *tObj,
                  GLuint n, const GLfloat texcoords[][4],
                  const GLfloat lambda[], GLchan rgba[][4] )
d1406 1
a1406 1
/*
d1409 1
a1409 1
static void
d1422 3
a1424 3
   COMPUTE_NEAREST_TEXEL_LOCATION(tObj->WrapS, texcoord[0], width,  i);
   COMPUTE_NEAREST_TEXEL_LOCATION(tObj->WrapT, texcoord[1], height, j);
   COMPUTE_NEAREST_TEXEL_LOCATION(tObj->WrapR, texcoord[2], depth,  k);
d1438 1
a1438 2

/*
a1452 1
   GLfloat u, v, w;
d1457 3
a1459 3
   COMPUTE_LINEAR_TEXEL_LOCATIONS(tObj->WrapS, texcoord[0], u, width,  i0, i1);
   COMPUTE_LINEAR_TEXEL_LOCATIONS(tObj->WrapT, texcoord[1], v, height, j0, j1);
   COMPUTE_LINEAR_TEXEL_LOCATIONS(tObj->WrapR, texcoord[2], w, depth,  k0, k1);
a1530 3
   a = FRAC(u);
   b = FRAC(v);
   c = FRAC(w);
a1534 1

d1614 1
d1624 1
a1624 1
   for (i=0;i<n;i++) {
d1630 1
a1630 1

d1632 4
a1635 4
sample_linear_3d( GLcontext *ctx,
                  const struct gl_texture_object *tObj, GLuint n,
                  const GLfloat texcoords[][4],
		  const GLfloat lambda[], GLchan rgba[][4] )
d1640 1
a1640 1
   for (i=0;i<n;i++) {
d1646 1
a1646 4
/*
 * Given an (s,t,r) texture coordinate and lambda (level of detail) value,
 * return a texture sample.
 */
d1648 4
a1651 4
sample_lambda_3d( GLcontext *ctx,
                  const struct gl_texture_object *tObj, GLuint n,
                  const GLfloat texcoords[][4], const GLfloat lambda[],
                  GLchan rgba[][4] )
d1940 1
d1942 4
a1945 4
sample_lambda_cube( GLcontext *ctx,
		    const struct gl_texture_object *tObj, GLuint n,
		    const GLfloat texcoords[][4], const GLfloat lambda[],
		    GLchan rgba[][4])
d2021 2
a2022 1
   if (wrapMode == GL_CLAMP) {
d2024 1
a2024 2
   }
   else if (wrapMode == GL_CLAMP_TO_EDGE) {
d2026 1
a2026 2
   }
   else {
d2028 3
d2035 1
a2035 1
/*
d2040 1
a2040 1
                        GLint *i0out, GLint *i1out)
d2044 2
a2045 1
   if (wrapMode == GL_CLAMP) {
d2050 2
a2051 2
   }
   else if (wrapMode == GL_CLAMP_TO_EDGE) {
d2058 2
a2059 3
   }
   else {
      ASSERT(wrapMode == GL_CLAMP_TO_BORDER);
d2064 5
d2072 1
d2083 2
a2084 4
   const GLfloat width = (GLfloat) img->Width;
   const GLfloat height = (GLfloat) img->Height;
   const GLint width_minus_1 = img->Width - 1;
   const GLint height_minus_1 = img->Height - 1;
d2102 1
a2102 1
      if (col < 0 || col > width_minus_1 || row < 0 || row > height_minus_1)
d2117 2
a2118 4
   const GLfloat width = (GLfloat) img->Width;
   const GLfloat height = (GLfloat) img->Height;
   const GLint width_minus_1 = img->Width - 1;
   const GLint height_minus_1 = img->Height - 1;
a2131 1
   /* XXX lots of opportunity for optimization in this loop */
a2132 1
      GLfloat frow, fcol;
d2138 4
a2141 44
      /* NOTE: we DO NOT use [0, 1] texture coordinates! */
      if (tObj->WrapS == GL_CLAMP) {
         /* Not exactly what the spec says, but it matches NVIDIA output */
         fcol = CLAMP(texcoords[i][0] - 0.5F, 0.0, width_minus_1);
         i0 = IFLOOR(fcol);
         i1 = i0 + 1;
      }
      else if (tObj->WrapS == GL_CLAMP_TO_EDGE) {
         fcol = CLAMP(texcoords[i][0], 0.5F, width - 0.5F);
         fcol -= 0.5F;
         i0 = IFLOOR(fcol);
         i1 = i0 + 1;
         if (i1 > width_minus_1)
            i1 = width_minus_1;
      }
      else {
         ASSERT(tObj->WrapS == GL_CLAMP_TO_BORDER);
         fcol = CLAMP(texcoords[i][0], -0.5F, width + 0.5F);
         fcol -= 0.5F;
         i0 = IFLOOR(fcol);
         i1 = i0 + 1;
      }

      if (tObj->WrapT == GL_CLAMP) {
         /* Not exactly what the spec says, but it matches NVIDIA output */
         frow = CLAMP(texcoords[i][1] - 0.5F, 0.0, width_minus_1);
         j0 = IFLOOR(frow);
         j1 = j0 + 1;
      }
      else if (tObj->WrapT == GL_CLAMP_TO_EDGE) {
         frow = CLAMP(texcoords[i][1], 0.5F, height - 0.5F);
         frow -= 0.5F;
         j0 = IFLOOR(frow);
         j1 = j0 + 1;
         if (j1 > height_minus_1)
            j1 = height_minus_1;
      }
      else {
         ASSERT(tObj->WrapT == GL_CLAMP_TO_BORDER);
         frow = CLAMP(texcoords[i][1], -0.5F, height + 0.5F);
         frow -= 0.5F;
         j0 = IFLOOR(frow);
         j1 = j0 + 1;
      }
d2144 4
a2147 4
      if (i0 < 0 || i0 > width_minus_1)   useBorderColor |= I0BIT;
      if (i1 < 0 || i1 > width_minus_1)   useBorderColor |= I1BIT;
      if (j0 < 0 || j0 > height_minus_1)  useBorderColor |= J0BIT;
      if (j1 < 0 || j1 > height_minus_1)  useBorderColor |= J1BIT;
a2169 4
      /* compute interpolants */
      a = FRAC(fcol);
      b = FRAC(frow);

d2175 1
d2177 4
a2180 4
sample_lambda_rect( GLcontext *ctx,
		    const struct gl_texture_object *tObj, GLuint n,
		    const GLfloat texcoords[][4], const GLfloat lambda[],
		    GLchan rgba[][4])
d2192 2
a2193 2
         sample_nearest_rect( ctx, tObj, minEnd - minStart,
                              texcoords + minStart, NULL, rgba + minStart);
d2196 2
a2197 2
         sample_linear_rect( ctx, tObj, minEnd - minStart,
                             texcoords + minStart, NULL, rgba + minStart);
d2202 2
a2203 2
         sample_nearest_rect( ctx, tObj, magEnd - magStart,
                              texcoords + magStart, NULL, rgba + magStart);
d2206 2
a2207 2
         sample_linear_rect( ctx, tObj, magEnd - magStart,
                             texcoords + magStart, NULL, rgba + magStart);
d2218 1
a2218 1
/*
d2235 2
a2236 2
   COMPUTE_NEAREST_TEXEL_LOCATION(tObj->WrapS, texcoord[0], width,  i);
   COMPUTE_NEAREST_TEXEL_LOCATION(tObj->WrapT, texcoord[1], height, j);
d2251 1
a2251 2

/*
a2266 1
   GLfloat u, v;
d2270 2
a2271 2
   COMPUTE_LINEAR_TEXEL_LOCATIONS(tObj->WrapS, texcoord[0], u, width,  i0, i1);
   COMPUTE_LINEAR_TEXEL_LOCATIONS(tObj->WrapT, texcoord[1], v, height, j0, j1);
a2318 2
      a = FRAC(u);
      b = FRAC(v);
a2323 1

d2328 1
a2328 1
                                       const GLfloat lambda[], GLchan rgba[][4] )
d2372 4
a2375 2
         sample_2d_array_nearest(ctx, tObj, tObj->Image[0][level  ], texcoord[i], t0);
         sample_2d_array_nearest(ctx, tObj, tObj->Image[0][level+1], texcoord[i], t1);
d2384 3
a2386 3
                               const struct gl_texture_object *tObj,
                               GLuint n, const GLfloat texcoord[][4],
                               const GLfloat lambda[], GLchan rgba[][4])
d2399 4
a2402 2
         sample_2d_array_linear(ctx, tObj, tObj->Image[0][level  ], texcoord[i], t0);
         sample_2d_array_linear(ctx, tObj, tObj->Image[0][level+1], texcoord[i], t1);
d2409 1
d2412 3
a2414 3
                  const struct gl_texture_object *tObj, GLuint n,
                  const GLfloat texcoords[][4], const GLfloat lambda[],
                  GLchan rgba[][4])
d2419 1
a2419 1
   for (i=0;i<n;i++) {
d2426 1
d2436 1
a2436 1
   for (i=0;i<n;i++) {
d2442 1
a2442 4
/*
 * Given an (s,t,r) texture coordinate and lambda (level of detail) value,
 * return a texture sample.
 */
d2472 4
a2475 2
         sample_2d_array_nearest_mipmap_nearest(ctx, tObj, m, texcoords + minStart,
                                                lambda + minStart, rgba + minStart);
d2484 4
a2487 2
         sample_2d_array_nearest_mipmap_linear(ctx, tObj, m, texcoords + minStart,
                                               lambda + minStart, rgba + minStart);
d2528 1
a2528 1
/*
d2544 1
a2544 1
   COMPUTE_NEAREST_TEXEL_LOCATION(tObj->WrapS, texcoord[0], width,  i);
d2558 1
a2558 2

/*
a2572 1
   GLfloat u;
d2576 1
a2576 1
   COMPUTE_LINEAR_TEXEL_LOCATIONS(tObj->WrapS, texcoord[0], u, width,  i0, i1);
a2605 1
   a = FRAC(u);
a2609 1

d2614 1
a2614 1
                                       const GLfloat lambda[], GLchan rgba[][4] )
d2668 3
a2670 3
                               const struct gl_texture_object *tObj,
                               GLuint n, const GLfloat texcoord[][4],
                               const GLfloat lambda[], GLchan rgba[][4])
d2691 1
d2694 3
a2696 3
                  const struct gl_texture_object *tObj, GLuint n,
                  const GLfloat texcoords[][4], const GLfloat lambda[],
                  GLchan rgba[][4])
d2701 1
a2701 1
   for (i=0;i<n;i++) {
d2707 1
a2707 1

d2717 1
a2717 1
   for (i=0;i<n;i++) {
d2723 1
a2723 4
/*
 * Given an (s,t,r) texture coordinate and lambda (level of detail) value,
 * return a texture sample.
 */
d2799 1
a2799 3


/*
d2849 2
a2850 2
            COMPUTE_NEAREST_TEXEL_LOCATION(tObj->WrapS, texcoords[i][0],
                                           width, col);
d2856 4
a2859 4
            COMPUTE_NEAREST_TEXEL_LOCATION(tObj->WrapS, texcoords[i][0],
                                           width, col);
            COMPUTE_NEAREST_TEXEL_LOCATION(tObj->WrapT, texcoords[i][1],
                                           height, row);
d2864 2
a2865 2
            COMPUTE_NEAREST_TEXEL_LOCATION(tObj->WrapS, texcoords[i][0],
                                           width, col);
d2868 1
d2871 4
a2874 4
            COMPUTE_NEAREST_TEXEL_LOCATION(tObj->WrapS, texcoords[i][0],
                                           width, col);
            COMPUTE_NEAREST_TEXEL_LOCATION(tObj->WrapT, texcoords[i][1],
                                           height, row);
d2877 2
d2953 1
a2953 1
         GLfloat u, v;
d2959 1
a2959 1
                                    width, &i0, &i1);
d2961 1
a2961 1
                                    height, &j0, &j1);
d2967 4
a2970 4
            COMPUTE_LINEAR_TEXEL_LOCATIONS(tObj->WrapS, texcoords[i][0],
                                           u, width, i0, i1);
            COMPUTE_LINEAR_TEXEL_LOCATIONS(tObj->WrapT, texcoords[i][1],
                                           v, height,j0, j1);
d2975 2
a2976 2
            COMPUTE_LINEAR_TEXEL_LOCATIONS(tObj->WrapS, texcoords[i][0],
                                           u, width, i0, i1);
d2980 1
d2983 4
a2986 4
            COMPUTE_LINEAR_TEXEL_LOCATIONS(tObj->WrapS, texcoords[i][0],
                                           u, width, i0, i1);
            COMPUTE_LINEAR_TEXEL_LOCATIONS(tObj->WrapT, texcoords[i][1],
                                           v, height,j0, j1);
d2989 2
a3051 2
            const GLfloat a = FRAC(u + 1.0F);
            const GLfloat b = FRAC(v + 1.0F);
a3121 2
                  const GLfloat a = FRAC(u + 1.0F);
                  const GLfloat b = FRAC(v + 1.0F);
d3215 4
a3218 4
         COMPUTE_NEAREST_TEXEL_LOCATION(texObj->WrapS, texcoords[i][0],
					width, col);
         COMPUTE_NEAREST_TEXEL_LOCATION(texObj->WrapT, texcoords[i][1],
					height, row);
@


1.2
log
@Update to Mesa 7.0.3. tested my oga@@ and johan@@
@
text
@d216 2
a217 2
 * Compute the remainder of a divided by b, but be careful with
 * negative values so that GL_REPEAT mode works right.
d219 1
a219 8
static INLINE GLint
repeat_remainder(GLint a, GLint b)
{
   if (a >= 0)
      return a % b;
   else
      return (a + 1) % b + b - 1;
}
d242 2
a243 2
         I0 = repeat_remainder(IFLOOR(U), SIZE);			\
         I1 = repeat_remainder(I0 + 1, SIZE);				\
d345 1
d363 1
a363 1
         I = repeat_remainder(I, SIZE);					\
d466 1
d1196 2
a1197 2
       image->Border == 0 &&
       image->_IsPowerOfTwo) {
d1859 1
a1859 1
      GLint level = nearest_mipmap_level(tObj, lambda[i]);
d1861 11
d1889 1
d1908 1
d1937 1
d2268 591
d2872 3
d2886 3
a2888 1
          tObj->Target == GL_TEXTURE_RECTANGLE_NV);
d2894 1
a2894 19
   /* XXX this could be precomputed and saved in the texture object */
   if (tObj->CompareFlag) {
      /* GL_SGIX_shadow */
      if (tObj->CompareOperator == GL_TEXTURE_LEQUAL_R_SGIX) {
         function = GL_LEQUAL;
      }
      else {
         ASSERT(tObj->CompareOperator == GL_TEXTURE_GEQUAL_R_SGIX);
         function = GL_GEQUAL;
      }
   }
   else if (tObj->CompareMode == GL_COMPARE_R_TO_TEXTURE_ARB) {
      /* GL_ARB_shadow */
      function = tObj->CompareFunc;
   }
   else {
      function = GL_NONE;  /* pass depth through as grayscale */
   }

d2899 1
a2899 1
         GLint col, row;
d2901 2
a2902 1
         if (tObj->Target == GL_TEXTURE_RECTANGLE_ARB) {
d2905 25
a2929 2
         }
         else {
d2934 2
d2937 4
a2940 2
         if (col >= 0 && row >= 0 && col < width && row < height) {
            img->FetchTexelf(img, col, row, 0, &depthSample);
d2948 1
a2948 1
            result = (texcoords[i][2] <= depthSample) ? CHAN_MAX : ambient;
d2951 1
a2951 1
            result = (texcoords[i][2] >= depthSample) ? CHAN_MAX : ambient;
d2954 1
a2954 1
            result = (texcoords[i][2] < depthSample) ? CHAN_MAX : ambient;
d2957 1
a2957 1
            result = (texcoords[i][2] > depthSample) ? CHAN_MAX : ambient;
d2960 1
a2960 1
            result = (texcoords[i][2] == depthSample) ? CHAN_MAX : ambient;
d2963 1
a2963 1
            result = (texcoords[i][2] != depthSample) ? CHAN_MAX : ambient;
d3009 1
d3013 2
a3014 1
         if (tObj->Target == GL_TEXTURE_RECTANGLE_ARB) {
d3019 20
a3038 2
         }
         else {
d3043 2
d3051 4
a3054 2
            j0 += img->Border;
            j1 += img->Border;
d3063 1
a3063 2
         /* get four depth samples from the texture */
         if (useBorderTexel & (I0BIT | J0BIT)) {
d3065 1
a3065 5
         }
         else {
            img->FetchTexelf(img, i0, j0, 0, &depth00);
         }
         if (useBorderTexel & (I1BIT | J0BIT)) {
a3066 11
         }
         else {
            img->FetchTexelf(img, i1, j0, 0, &depth10);
         }
         if (useBorderTexel & (I0BIT | J1BIT)) {
            depth01 = tObj->BorderColor[0];
         }
         else {
            img->FetchTexelf(img, i0, j1, 0, &depth01);
         }
         if (useBorderTexel & (I1BIT | J1BIT)) {
d3070 32
a3101 1
            img->FetchTexelf(img, i1, j1, 0, &depth11);
d3110 2
a3111 2
            if ((depthSample <= texcoords[i][2] && function == GL_LEQUAL) ||
                (depthSample >= texcoords[i][2] && function == GL_GEQUAL)) {
d3128 4
a3131 4
               if (depth00 <= texcoords[i][2])  luminance -= d;
               if (depth01 <= texcoords[i][2])  luminance -= d;
               if (depth10 <= texcoords[i][2])  luminance -= d;
               if (depth11 <= texcoords[i][2])  luminance -= d;
d3135 4
a3138 4
               if (depth00 >= texcoords[i][2])  luminance -= d;
               if (depth01 >= texcoords[i][2])  luminance -= d;
               if (depth10 >= texcoords[i][2])  luminance -= d;
               if (depth11 >= texcoords[i][2])  luminance -= d;
d3142 4
a3145 4
               if (depth00 < texcoords[i][2])  luminance -= d;
               if (depth01 < texcoords[i][2])  luminance -= d;
               if (depth10 < texcoords[i][2])  luminance -= d;
               if (depth11 < texcoords[i][2])  luminance -= d;
d3149 4
a3152 4
               if (depth00 > texcoords[i][2])  luminance -= d;
               if (depth01 > texcoords[i][2])  luminance -= d;
               if (depth10 > texcoords[i][2])  luminance -= d;
               if (depth11 > texcoords[i][2])  luminance -= d;
d3156 4
a3159 4
               if (depth00 == texcoords[i][2])  luminance -= d;
               if (depth01 == texcoords[i][2])  luminance -= d;
               if (depth10 == texcoords[i][2])  luminance -= d;
               if (depth11 == texcoords[i][2])  luminance -= d;
d3163 4
a3166 4
               if (depth00 != texcoords[i][2])  luminance -= d;
               if (depth01 != texcoords[i][2])  luminance -= d;
               if (depth10 != texcoords[i][2])  luminance -= d;
               if (depth11 != texcoords[i][2])  luminance -= d;
d3348 1
a3348 1
   if (!t || !t->Complete) {
d3437 22
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * Version:  6.5.1
d5 1
a5 1
 * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
d593 1
a593 1
   if (lambda[0] <= minMagThresh && lambda[n-1] <= minMagThresh) {
d599 1
a599 1
   else if (lambda[0] > minMagThresh && lambda[n-1] > minMagThresh) {
d1046 1
a1046 1
   ASSERT(img->_BaseFormat != GL_COLOR_INDEX);
d1199 4
a1202 1
   if (tObj->WrapS == GL_REPEAT && tObj->WrapT == GL_REPEAT) {
d1241 1
a1241 1
   ASSERT(img->_BaseFormat==GL_RGB);
d1282 1
a1282 1
   ASSERT(img->_BaseFormat==GL_RGBA);
d1312 1
a1312 1
      && (tImg->_BaseFormat != GL_COLOR_INDEX)
a1326 2
            case MESA_FORMAT_RGB888:
            /*case MESA_FORMAT_BGR888:*/
a1330 4
            case MESA_FORMAT_RGBA8888:
            case MESA_FORMAT_ARGB8888:
            /*case MESA_FORMAT_ABGR8888:*/
            /*case MESA_FORMAT_BGRA8888:*/
a1383 2
            case MESA_FORMAT_RGB888:
            /*case MESA_FORMAT_BGR888:*/
a1387 4
            case MESA_FORMAT_RGBA8888:
            case MESA_FORMAT_ARGB8888:
            /*case MESA_FORMAT_ABGR8888:*/
            /*case MESA_FORMAT_BGRA8888:*/
d2018 54
d2094 1
a2094 1
   ASSERT(img->_BaseFormat != GL_COLOR_INDEX);
a2095 1
   /* XXX move Wrap mode tests outside of loops for common cases */
d2098 2
a2099 20
      /* NOTE: we DO NOT use [0, 1] texture coordinates! */
      if (tObj->WrapS == GL_CLAMP) {
         col = IFLOOR( CLAMP(texcoords[i][0], 0.0F, width - 1) );
      }
      else if (tObj->WrapS == GL_CLAMP_TO_EDGE) {
         col = IFLOOR( CLAMP(texcoords[i][0], 0.5F, width - 0.5F) );
      }
      else {
         col = IFLOOR( CLAMP(texcoords[i][0], -0.5F, width + 0.5F) );
      }
      if (tObj->WrapT == GL_CLAMP) {
         row = IFLOOR( CLAMP(texcoords[i][1], 0.0F, height - 1) );
      }
      else if (tObj->WrapT == GL_CLAMP_TO_EDGE) {
         row = IFLOOR( CLAMP(texcoords[i][1], 0.5F, height - 0.5F) );
      }
      else {
         row = IFLOOR( CLAMP(texcoords[i][1], -0.5F, height + 0.5F) );
      }

d2130 1
a2130 1
   ASSERT(img->_BaseFormat != GL_COLOR_INDEX);
d2278 2
a2279 2
   ASSERT(tObj->Image[0][tObj->BaseLevel]->_BaseFormat == GL_DEPTH_COMPONENT ||
          tObj->Image[0][tObj->BaseLevel]->_BaseFormat == GL_DEPTH_STENCIL_EXT);
d2313 11
a2323 3
         /* XXX fix for texture rectangle! */
         COMPUTE_NEAREST_TEXEL_LOCATION(tObj->WrapS, texcoords[i][0], width, col);
         COMPUTE_NEAREST_TEXEL_LOCATION(tObj->WrapT, texcoords[i][1], height, row);
d2397 12
a2408 3
         /* XXX fix for texture rectangle! */
         COMPUTE_LINEAR_TEXEL_LOCATIONS(tObj->WrapS, texcoords[i][0], u, width, i0, i1);
         COMPUTE_LINEAR_TEXEL_LOCATIONS(tObj->WrapT, texcoords[i][1], v, height,j0, j1);
d2596 1
a2596 1
   if (texImage->_BaseFormat != GL_DEPTH_COMPONENT) {
d2699 1
a2699 1
      const GLenum format = t->Image[0][t->BaseLevel]->_BaseFormat;
d2771 4
a2774 1
         if (needLambda) {
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d3 1
a3 1
 * Version:  6.5.2
d593 1
a593 1
   if (lambda[0] <= minMagThresh && (n <= 1 || lambda[n-1] <= minMagThresh)) {
d599 1
a599 1
   else if (lambda[0] > minMagThresh && (n <=1 || lambda[n-1] > minMagThresh)) {
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d3 1
a3 1
 * Version:  6.5.3
d5 1
a5 1
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
d1199 1
a1199 3
   if (tObj->WrapS == GL_REPEAT &&
       tObj->WrapT == GL_REPEAT &&
       image->_IsPowerOfTwo) {
a2026 54

/**
 * Do clamp/wrap for a texture rectangle coord, GL_NEAREST filter mode.
 */
static INLINE GLint
clamp_rect_coord_nearest(GLenum wrapMode, GLfloat coord, GLint max)
{
   if (wrapMode == GL_CLAMP) {
      return IFLOOR( CLAMP(coord, 0.0F, max - 1) );
   }
   else if (wrapMode == GL_CLAMP_TO_EDGE) {
      return IFLOOR( CLAMP(coord, 0.5F, max - 0.5F) );
   }
   else {
      return IFLOOR( CLAMP(coord, -0.5F, max + 0.5F) );
   }
}


/*
 * As above, but GL_LINEAR filtering.
 */
static INLINE void
clamp_rect_coord_linear(GLenum wrapMode, GLfloat coord, GLint max,
                        GLint *i0out, GLint *i1out)
{
   GLfloat fcol;
   GLint i0, i1;
   if (wrapMode == GL_CLAMP) {
      /* Not exactly what the spec says, but it matches NVIDIA output */
      fcol = CLAMP(coord - 0.5F, 0.0, max-1);
      i0 = IFLOOR(fcol);
      i1 = i0 + 1;
   }
   else if (wrapMode == GL_CLAMP_TO_EDGE) {
      fcol = CLAMP(coord, 0.5F, max - 0.5F);
      fcol -= 0.5F;
      i0 = IFLOOR(fcol);
      i1 = i0 + 1;
      if (i1 > max - 1)
         i1 = max - 1;
   }
   else {
      ASSERT(wrapMode == GL_CLAMP_TO_BORDER);
      fcol = CLAMP(coord, -0.5F, max + 0.5F);
      fcol -= 0.5F;
      i0 = IFLOOR(fcol);
      i1 = i0 + 1;
   }
   *i0out = i0;
   *i1out = i1;
}


d2051 1
d2054 20
a2073 2
      col = clamp_rect_coord_nearest(tObj->WrapS, texcoords[i][0], width);
      row = clamp_rect_coord_nearest(tObj->WrapT, texcoords[i][1], height);
d2287 3
a2289 11

         if (tObj->Target == GL_TEXTURE_RECTANGLE_ARB) {
            col = clamp_rect_coord_nearest(tObj->WrapS, texcoords[i][0], width);
            row = clamp_rect_coord_nearest(tObj->WrapT, texcoords[i][1], height);
         }
         else {
            COMPUTE_NEAREST_TEXEL_LOCATION(tObj->WrapS, texcoords[i][0],
                                           width, col);
            COMPUTE_NEAREST_TEXEL_LOCATION(tObj->WrapT, texcoords[i][1],
                                           height, row);
         }
d2363 3
a2365 12
         if (tObj->Target == GL_TEXTURE_RECTANGLE_ARB) {
            clamp_rect_coord_linear(tObj->WrapS, texcoords[i][0],
                                    width, &i0, &i1);
            clamp_rect_coord_linear(tObj->WrapT, texcoords[i][1],
                                    height, &j0, &j1);
         }
         else {
            COMPUTE_LINEAR_TEXEL_LOCATIONS(tObj->WrapS, texcoords[i][0],
                                           u, width, i0, i1);
            COMPUTE_LINEAR_TEXEL_LOCATIONS(tObj->WrapT, texcoords[i][1],
                                           v, height,j0, j1);
         }
d2728 1
a2728 4
         if (format == GL_DEPTH_COMPONENT || format == GL_DEPTH_STENCIL_EXT) {
            return &sample_depth_texture;
         }
         else if (needLambda) {
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d3 1
a3 1
 * Version:  7.3
d5 1
a5 1
 * Copyright (C) 1999-2008  Brian Paul   All Rights Reserved.
d26 5
a30 5
#include "main/glheader.h"
#include "main/context.h"
#include "main/colormac.h"
#include "main/imports.h"
#include "main/texformat.h"
d36 2
a37 6
/*
 * Note, the FRAC macro has to work perfectly.  Otherwise you'll sometimes
 * see 1-pixel bands of improperly weighted linear-filtered textures.
 * The tests/texwrap.c demo is a good test.
 * Also note, FRAC(x) doesn't truly return the fractional part of x for x < 0.
 * Instead, if x < 0 then FRAC(x) = 1 - true_frac(x).
d39 2
a40 2
#define FRAC(f)  ((f) - IFLOOR(f))

d44 1
a44 1
 * Linear interpolation macro
d47 1
d69 15
d103 20
d126 1
a126 1
lerp_rgba(GLfloat result[4], GLfloat t, const GLfloat a[4], const GLfloat b[4])
d128 1
d133 14
d154 3
a156 3
lerp_rgba_2d(GLfloat result[4], GLfloat a, GLfloat b,
             const GLfloat t00[4], const GLfloat t10[4],
             const GLfloat t01[4], const GLfloat t11[4])
d158 1
d163 14
d184 5
a188 5
lerp_rgba_3d(GLfloat result[4], GLfloat a, GLfloat b, GLfloat c,
             const GLfloat t000[4], const GLfloat t100[4],
             const GLfloat t010[4], const GLfloat t110[4],
             const GLfloat t001[4], const GLfloat t101[4],
             const GLfloat t011[4], const GLfloat t111[4])
d192 1
d197 15
d216 2
a217 5
 * Used for GL_REPEAT wrap mode.  Using A % B doesn't produce the
 * right results for A<0.  Casting to A to be unsigned only works if B
 * is a power of two.  Adding a bias to A (which is a multiple of B)
 * avoids the problems with A < 0 (for reasonable A) without using a
 * conditional.
d219 8
a226 1
#define REMAINDER(A, B) (((A) + (B) * 1024) % (B))
d233 2
a234 2
 *    s = texcoord in [0,1]
 *    size = width (or height or depth) of texture
d236 2
a237 2
 *    i0, i1 = returns two nearest texel indexes
 *    weight = returns blend factor between texels
d239 114
a352 121
static INLINE void
linear_texel_locations(GLenum wrapMode,
                       const struct gl_texture_image *img,
                       GLint size, GLfloat s,
                       GLint *i0, GLint *i1, GLfloat *weight)
{
   GLfloat u;
   switch (wrapMode) {
   case GL_REPEAT:
      u = s * size - 0.5F;
      if (img->_IsPowerOfTwo) {
         *i0 = IFLOOR(u) & (size - 1);
         *i1 = (*i0 + 1) & (size - 1);
      }
      else {
         *i0 = REMAINDER(IFLOOR(u), size);
         *i1 = REMAINDER(*i0 + 1, size);
      }
      break;
   case GL_CLAMP_TO_EDGE:
      if (s <= 0.0F)
         u = 0.0F;
      else if (s >= 1.0F)
         u = (GLfloat) size;
      else
         u = s * size;
      u -= 0.5F;
      *i0 = IFLOOR(u);
      *i1 = *i0 + 1;
      if (*i0 < 0)
         *i0 = 0;
      if (*i1 >= (GLint) size)
         *i1 = size - 1;
      break;
   case GL_CLAMP_TO_BORDER:
      {
         const GLfloat min = -1.0F / (2.0F * size);
         const GLfloat max = 1.0F - min;
         if (s <= min)
            u = min * size;
         else if (s >= max)
            u = max * size;
         else
            u = s * size;
         u -= 0.5F;
         *i0 = IFLOOR(u);
         *i1 = *i0 + 1;
      }
      break;
   case GL_MIRRORED_REPEAT:
      {
         const GLint flr = IFLOOR(s);
         if (flr & 1)
            u = 1.0F - (s - (GLfloat) flr);
         else
            u = s - (GLfloat) flr;
         u = (u * size) - 0.5F;
         *i0 = IFLOOR(u);
         *i1 = *i0 + 1;
         if (*i0 < 0)
            *i0 = 0;
         if (*i1 >= (GLint) size)
            *i1 = size - 1;
      }
      break;
   case GL_MIRROR_CLAMP_EXT:
      u = FABSF(s);
      if (u >= 1.0F)
         u = (GLfloat) size;
      else
         u *= size;
      u -= 0.5F;
      *i0 = IFLOOR(u);
      *i1 = *i0 + 1;
      break;
   case GL_MIRROR_CLAMP_TO_EDGE_EXT:
      u = FABSF(s);
      if (u >= 1.0F)
         u = (GLfloat) size;
      else
         u *= size;
      u -= 0.5F;
      *i0 = IFLOOR(u);
      *i1 = *i0 + 1;
      if (*i0 < 0)
         *i0 = 0;
      if (*i1 >= (GLint) size)
         *i1 = size - 1;
      break;
   case GL_MIRROR_CLAMP_TO_BORDER_EXT:
      {
         const GLfloat min = -1.0F / (2.0F * size);
         const GLfloat max = 1.0F - min;
         u = FABSF(s);
         if (u <= min)
            u = min * size;
         else if (u >= max)
            u = max * size;
         else
            u *= size;
         u -= 0.5F;
         *i0 = IFLOOR(u);
         *i1 = *i0 + 1;
      }
      break;
   case GL_CLAMP:
      if (s <= 0.0F)
         u = 0.0F;
      else if (s >= 1.0F)
         u = (GLfloat) size;
      else
         u = s * size;
      u -= 0.5F;
      *i0 = IFLOOR(u);
      *i1 = *i0 + 1;
      break;
   default:
      _mesa_problem(NULL, "Bad wrap mode");
      u = 0.0F;
   }
   *weight = FRAC(u);
d359 114
a472 120
static INLINE GLint
nearest_texel_location(GLenum wrapMode,
                       const struct gl_texture_image *img,
                       GLint size, GLfloat s)
{
   GLint i;

   switch (wrapMode) {
   case GL_REPEAT:
      /* s limited to [0,1) */
      /* i limited to [0,size-1] */
      i = IFLOOR(s * size);
      if (img->_IsPowerOfTwo)
         i &= (size - 1);
      else
         i = REMAINDER(i, size);
      return i;
   case GL_CLAMP_TO_EDGE:
      {
         /* s limited to [min,max] */
         /* i limited to [0, size-1] */
         const GLfloat min = 1.0F / (2.0F * size);
         const GLfloat max = 1.0F - min;
         if (s < min)
            i = 0;
         else if (s > max)
            i = size - 1;
         else
            i = IFLOOR(s * size);
      }
      return i;
   case GL_CLAMP_TO_BORDER:
      {
         /* s limited to [min,max] */
         /* i limited to [-1, size] */
         const GLfloat min = -1.0F / (2.0F * size);
         const GLfloat max = 1.0F - min;
         if (s <= min)
            i = -1;
         else if (s >= max)
            i = size;
         else
            i = IFLOOR(s * size);
      }
      return i;
   case GL_MIRRORED_REPEAT:
      {
         const GLfloat min = 1.0F / (2.0F * size);
         const GLfloat max = 1.0F - min;
         const GLint flr = IFLOOR(s);
         GLfloat u;
         if (flr & 1)
            u = 1.0F - (s - (GLfloat) flr);
         else
            u = s - (GLfloat) flr;
         if (u < min)
            i = 0;
         else if (u > max)
            i = size - 1;
         else
            i = IFLOOR(u * size);
      }
      return i;
   case GL_MIRROR_CLAMP_EXT:
      {
         /* s limited to [0,1] */
         /* i limited to [0,size-1] */
         const GLfloat u = FABSF(s);
         if (u <= 0.0F)
            i = 0;
         else if (u >= 1.0F)
            i = size - 1;
         else
            i = IFLOOR(u * size);
      }
      return i;
   case GL_MIRROR_CLAMP_TO_EDGE_EXT:
      {
         /* s limited to [min,max] */
         /* i limited to [0, size-1] */
         const GLfloat min = 1.0F / (2.0F * size);
         const GLfloat max = 1.0F - min;
         const GLfloat u = FABSF(s);
         if (u < min)
            i = 0;
         else if (u > max)
            i = size - 1;
         else
            i = IFLOOR(u * size);
      }
      return i;
   case GL_MIRROR_CLAMP_TO_BORDER_EXT:
      {
         /* s limited to [min,max] */
         /* i limited to [0, size-1] */
         const GLfloat min = -1.0F / (2.0F * size);
         const GLfloat max = 1.0F - min;
         const GLfloat u = FABSF(s);
         if (u < min)
            i = -1;
         else if (u > max)
            i = size;
         else
            i = IFLOOR(u * size);
      }
      return i;
   case GL_CLAMP:
      /* s limited to [0,1] */
      /* i limited to [0,size-1] */
      if (s <= 0.0F)
         i = 0;
      else if (s >= 1.0F)
         i = size - 1;
      else
         i = IFLOOR(s * size);
      return i;
   default:
      _mesa_problem(NULL, "Bad wrap mode");
      return 0;
   }
d477 5
a481 184
static INLINE void
linear_repeat_texel_location(GLuint size, GLfloat s,
                             GLint *i0, GLint *i1, GLfloat *weight)
{
   GLfloat u = s * size - 0.5F;
   *i0 = IFLOOR(u) & (size - 1);
   *i1 = (*i0 + 1) & (size - 1);
   *weight = FRAC(u);
}


/**
 * Do clamp/wrap for a texture rectangle coord, GL_NEAREST filter mode.
 */
static INLINE GLint
clamp_rect_coord_nearest(GLenum wrapMode, GLfloat coord, GLint max)
{
   switch (wrapMode) {
   case GL_CLAMP:
      return IFLOOR( CLAMP(coord, 0.0F, max - 1) );
   case GL_CLAMP_TO_EDGE:
      return IFLOOR( CLAMP(coord, 0.5F, max - 0.5F) );
   case GL_CLAMP_TO_BORDER:
      return IFLOOR( CLAMP(coord, -0.5F, max + 0.5F) );
   default:
      _mesa_problem(NULL, "bad wrapMode in clamp_rect_coord_nearest");
      return 0;
   }
}


/**
 * As above, but GL_LINEAR filtering.
 */
static INLINE void
clamp_rect_coord_linear(GLenum wrapMode, GLfloat coord, GLint max,
                        GLint *i0out, GLint *i1out, GLfloat *weight)
{
   GLfloat fcol;
   GLint i0, i1;
   switch (wrapMode) {
   case GL_CLAMP:
      /* Not exactly what the spec says, but it matches NVIDIA output */
      fcol = CLAMP(coord - 0.5F, 0.0F, max - 1);
      i0 = IFLOOR(fcol);
      i1 = i0 + 1;
      break;
   case GL_CLAMP_TO_EDGE:
      fcol = CLAMP(coord, 0.5F, max - 0.5F);
      fcol -= 0.5F;
      i0 = IFLOOR(fcol);
      i1 = i0 + 1;
      if (i1 > max - 1)
         i1 = max - 1;
      break;
   case GL_CLAMP_TO_BORDER:
      fcol = CLAMP(coord, -0.5F, max + 0.5F);
      fcol -= 0.5F;
      i0 = IFLOOR(fcol);
      i1 = i0 + 1;
      break;
   default:
      _mesa_problem(NULL, "bad wrapMode in clamp_rect_coord_linear");
      i0 = i1 = 0;
      fcol = 0.0F;
   }
   *i0out = i0;
   *i1out = i1;
   *weight = FRAC(fcol);
}


/**
 * Compute slice/image to use for 1D or 2D array texture.
 */
static INLINE GLint
tex_array_slice(GLfloat coord, GLsizei size)
{
   GLint slice = IFLOOR(coord + 0.5f);
   slice = CLAMP(slice, 0, size - 1);
   return slice;
}


/**
 * Compute nearest integer texcoords for given texobj and coordinate.
 * NOTE: only used for depth texture sampling.
 */
static INLINE void
nearest_texcoord(const struct gl_texture_object *texObj,
                 GLuint level,
                 const GLfloat texcoord[4],
                 GLint *i, GLint *j, GLint *k)
{
   const struct gl_texture_image *img = texObj->Image[0][level];
   const GLint width = img->Width;
   const GLint height = img->Height;
   const GLint depth = img->Depth;

   switch (texObj->Target) {
   case GL_TEXTURE_RECTANGLE_ARB:
      *i = clamp_rect_coord_nearest(texObj->WrapS, texcoord[0], width);
      *j = clamp_rect_coord_nearest(texObj->WrapT, texcoord[1], height);
      *k = 0;
      break;
   case GL_TEXTURE_1D:
      *i = nearest_texel_location(texObj->WrapS, img, width, texcoord[0]);
      *j = 0;
      *k = 0;
      break;
   case GL_TEXTURE_2D:
      *i = nearest_texel_location(texObj->WrapS, img, width, texcoord[0]);
      *j = nearest_texel_location(texObj->WrapT, img, height, texcoord[1]);
      *k = 0;
      break;
   case GL_TEXTURE_1D_ARRAY_EXT:
      *i = nearest_texel_location(texObj->WrapS, img, width, texcoord[0]);
      *j = tex_array_slice(texcoord[1], height);
      *k = 0;
      break;
   case GL_TEXTURE_2D_ARRAY_EXT:
      *i = nearest_texel_location(texObj->WrapS, img, width, texcoord[0]);
      *j = nearest_texel_location(texObj->WrapT, img, height, texcoord[1]);
      *k = tex_array_slice(texcoord[2], depth);
      break;
   default:
      *i = *j = *k = 0;
   }
}


/**
 * Compute linear integer texcoords for given texobj and coordinate.
 * NOTE: only used for depth texture sampling.
 */
static INLINE void
linear_texcoord(const struct gl_texture_object *texObj,
                GLuint level,
                const GLfloat texcoord[4],
                GLint *i0, GLint *i1, GLint *j0, GLint *j1, GLint *slice,
                GLfloat *wi, GLfloat *wj)
{
   const struct gl_texture_image *img = texObj->Image[0][level];
   const GLint width = img->Width;
   const GLint height = img->Height;
   const GLint depth = img->Depth;

   switch (texObj->Target) {
   case GL_TEXTURE_RECTANGLE_ARB:
      clamp_rect_coord_linear(texObj->WrapS, texcoord[0],
                              width, i0, i1, wi);
      clamp_rect_coord_linear(texObj->WrapT, texcoord[1],
                              height, j0, j1, wj);
      *slice = 0;
      break;

   case GL_TEXTURE_1D:
   case GL_TEXTURE_2D:
      linear_texel_locations(texObj->WrapS, img, width,
                             texcoord[0], i0, i1, wi);
      linear_texel_locations(texObj->WrapT, img, height,
                             texcoord[1], j0, j1, wj);
      *slice = 0;
      break;

   case GL_TEXTURE_1D_ARRAY_EXT:
      linear_texel_locations(texObj->WrapS, img, width,
                             texcoord[0], i0, i1, wi);
      *j0 = tex_array_slice(texcoord[1], height);
      *j1 = *j0;
      *slice = 0;
      break;

   case GL_TEXTURE_2D_ARRAY_EXT:
      linear_texel_locations(texObj->WrapS, img, width,
                             texcoord[0], i0, i1, wi);
      linear_texel_locations(texObj->WrapT, img, height,
                             texcoord[1], j0, j1, wj);
      *slice = tex_array_slice(texcoord[2], depth);
      break;

   default:
      *slice = 0;
   }
a484 1

d524 11
d546 1
a546 1
/**
a654 38
/**
 * When we sample the border color, it must be interpreted according to
 * the base texture format.  Ex: if the texture base format it GL_ALPHA,
 * we return (0,0,0,BorderAlpha).
 */
static INLINE void
get_border_color(const struct gl_texture_object *tObj,
                 const struct gl_texture_image *img,
                 GLfloat rgba[4])
{
   switch (img->_BaseFormat) {
   case GL_RGB:
      rgba[0] = tObj->BorderColor.f[0];
      rgba[1] = tObj->BorderColor.f[1];
      rgba[2] = tObj->BorderColor.f[2];
      rgba[3] = 1.0F;
      break;
   case GL_ALPHA:
      rgba[0] = rgba[1] = rgba[2] = 0.0;
      rgba[3] = tObj->BorderColor.f[3];
      break;
   case GL_LUMINANCE:
      rgba[0] = rgba[1] = rgba[2] = tObj->BorderColor.f[0];
      rgba[3] = 1.0;
      break;
   case GL_LUMINANCE_ALPHA:
      rgba[0] = rgba[1] = rgba[2] = tObj->BorderColor.f[0];
      rgba[3] = tObj->BorderColor.f[3];
      break;
   case GL_INTENSITY:
      rgba[0] = rgba[1] = rgba[2] = rgba[3] = tObj->BorderColor.f[0];
      break;
   default:
      COPY_4V(rgba, tObj->BorderColor.f);
   }
}


d659 1
a659 1
/**
d662 2
a663 2
static INLINE void
sample_1d_nearest(struct gl_context *ctx,
d666 1
a666 1
                  const GLfloat texcoord[4], GLfloat rgba[4])
d670 1
a670 1
   i = nearest_texel_location(tObj->WrapS, img, width, texcoord[0]);
d675 1
a675 1
      get_border_color(tObj, img, rgba);
d678 1
a678 1
      img->FetchTexelf(img, i, 0, 0, rgba);
d683 1
a683 1
/**
d686 2
a687 2
static INLINE void
sample_1d_linear(struct gl_context *ctx,
d690 1
a690 1
                 const GLfloat texcoord[4], GLfloat rgba[4])
d694 1
d697 1
a697 1
   GLfloat t0[4], t1[4];  /* texels */
d699 1
a699 1
   linear_texel_locations(tObj->WrapS, img, width, texcoord[0], &i0, &i1, &a);
d712 1
a712 1
      get_border_color(tObj, img, t0);
d715 1
a715 1
      img->FetchTexelf(img, i0, 0, 0, t0);
d718 1
a718 1
      get_border_color(tObj, img, t1);
d721 1
a721 1
      img->FetchTexelf(img, i1, 0, 0, t1);
d724 1
d730 1
a730 1
sample_1d_nearest_mipmap_nearest(struct gl_context *ctx,
d733 1
a733 1
                                 const GLfloat lambda[], GLfloat rgba[][4])
d745 1
a745 1
sample_1d_linear_mipmap_nearest(struct gl_context *ctx,
d748 1
a748 1
                                const GLfloat lambda[], GLfloat rgba[][4])
d760 1
a760 1
sample_1d_nearest_mipmap_linear(struct gl_context *ctx,
d763 1
a763 1
                                const GLfloat lambda[], GLfloat rgba[][4])
d774 1
a774 1
         GLfloat t0[4], t1[4];
d784 1
d786 1
a786 1
sample_1d_linear_mipmap_linear(struct gl_context *ctx,
d789 1
a789 1
                               const GLfloat lambda[], GLfloat rgba[][4])
d800 1
a800 1
         GLfloat t0[4], t1[4];
d810 1
a810 1
/** Sample 1D texture, nearest filtering for both min/magnification */
d812 1
a812 1
sample_nearest_1d( struct gl_context *ctx,
d815 1
a815 1
                   GLfloat rgba[][4] )
d820 1
a820 1
   for (i = 0; i < n; i++) {
d826 1
a826 1
/** Sample 1D texture, linear filtering for both min/magnification */
d828 1
a828 1
sample_linear_1d( struct gl_context *ctx,
d831 1
a831 1
                  GLfloat rgba[][4] )
d836 1
a836 1
   for (i = 0; i < n; i++) {
d842 5
a846 1
/** Sample 1D texture, using lambda to choose between min/magnification */
d848 1
a848 1
sample_lambda_1d( struct gl_context *ctx,
d851 1
a851 1
                  const GLfloat lambda[], GLfloat rgba[][4] )
d923 1
a923 1
/**
d927 1
a927 1
sample_2d_nearest(struct gl_context *ctx,
d931 1
a931 1
                  GLfloat rgba[])
d938 2
a939 2
   i = nearest_texel_location(tObj->WrapS, img, width, texcoord[0]);
   j = nearest_texel_location(tObj->WrapT, img, height, texcoord[1]);
d947 1
a947 1
      get_border_color(tObj, img, rgba);
d950 1
a950 1
      img->FetchTexelf(img, i, j, 0, rgba);
d955 1
d961 1
a961 1
sample_2d_linear(struct gl_context *ctx,
d965 1
a965 1
                 GLfloat rgba[])
d971 1
d973 1
a973 1
   GLfloat t00[4], t10[4], t01[4], t11[4]; /* sampled texel colors */
d975 2
a976 2
   linear_texel_locations(tObj->WrapS, img, width, texcoord[0],  &i0, &i1, &a);
   linear_texel_locations(tObj->WrapT, img, height, texcoord[1], &j0, &j1, &b);
d993 1
a993 1
      get_border_color(tObj, img, t00);
d996 1
a996 1
      img->FetchTexelf(img, i0, j0, 0, t00);
d999 1
a999 1
      get_border_color(tObj, img, t10);
d1002 1
a1002 1
      img->FetchTexelf(img, i1, j0, 0, t10);
d1005 1
a1005 1
      get_border_color(tObj, img, t01);
d1008 1
a1008 1
      img->FetchTexelf(img, i0, j1, 0, t01);
d1011 1
a1011 1
      get_border_color(tObj, img, t11);
d1014 1
a1014 1
      img->FetchTexelf(img, i1, j1, 0, t11);
d1017 2
d1023 1
a1023 1
/**
d1028 1
a1028 1
sample_2d_linear_repeat(struct gl_context *ctx,
d1032 1
a1032 1
                        GLfloat rgba[])
d1037 3
a1039 2
   GLfloat wi, wj;
   GLfloat t00[4], t10[4], t01[4], t11[4]; /* sampled texel colors */
d1049 2
a1050 2
   linear_repeat_texel_location(width,  texcoord[0], &i0, &i1, &wi);
   linear_repeat_texel_location(height, texcoord[1], &j0, &j1, &wj);
d1052 4
a1055 4
   img->FetchTexelf(img, i0, j0, 0, t00);
   img->FetchTexelf(img, i1, j0, 0, t10);
   img->FetchTexelf(img, i0, j1, 0, t01);
   img->FetchTexelf(img, i1, j1, 0, t11);
d1057 3
a1059 1
   lerp_rgba_2d(rgba, wi, wj, t00, t10, t01, t11);
d1063 1
d1065 1
a1065 1
sample_2d_nearest_mipmap_nearest(struct gl_context *ctx,
d1068 1
a1068 1
                                 const GLfloat lambda[], GLfloat rgba[][4])
d1078 1
d1080 1
a1080 1
sample_2d_linear_mipmap_nearest(struct gl_context *ctx,
d1083 1
a1083 1
                                const GLfloat lambda[], GLfloat rgba[][4])
d1094 1
d1096 1
a1096 1
sample_2d_nearest_mipmap_linear(struct gl_context *ctx,
d1099 1
a1099 1
                                const GLfloat lambda[], GLfloat rgba[][4])
d1110 1
a1110 1
         GLfloat t0[4], t1[4];  /* texels */
d1120 2
d1123 1
a1123 1
sample_2d_linear_mipmap_linear( struct gl_context *ctx,
d1126 1
a1126 1
                                const GLfloat lambda[], GLfloat rgba[][4] )
d1137 1
a1137 1
         GLfloat t0[4], t1[4];  /* texels */
d1148 4
a1151 4
sample_2d_linear_mipmap_linear_repeat(struct gl_context *ctx,
                                      const struct gl_texture_object *tObj,
                                      GLuint n, const GLfloat texcoord[][4],
                                      const GLfloat lambda[], GLfloat rgba[][4])
d1164 1
a1164 1
         GLfloat t0[4], t1[4];  /* texels */
d1166 2
a1167 4
         sample_2d_linear_repeat(ctx, tObj, tObj->Image[0][level  ],
                                 texcoord[i], t0);
         sample_2d_linear_repeat(ctx, tObj, tObj->Image[0][level+1],
                                 texcoord[i], t1);
a1173 1
/** Sample 2D texture, nearest filtering for both min/magnification */
d1175 4
a1178 4
sample_nearest_2d(struct gl_context *ctx,
                  const struct gl_texture_object *tObj, GLuint n,
                  const GLfloat texcoords[][4],
                  const GLfloat lambda[], GLfloat rgba[][4])
d1183 1
a1183 1
   for (i = 0; i < n; i++) {
d1189 1
a1189 1
/** Sample 2D texture, linear filtering for both min/magnification */
d1191 4
a1194 4
sample_linear_2d(struct gl_context *ctx,
                 const struct gl_texture_object *tObj, GLuint n,
                 const GLfloat texcoords[][4],
                 const GLfloat lambda[], GLfloat rgba[][4])
d1201 2
a1202 3
       image->_IsPowerOfTwo &&
       image->Border == 0) {
      for (i = 0; i < n; i++) {
d1207 1
a1207 1
      for (i = 0; i < n; i++) {
d1214 1
a1214 1
/**
d1223 4
a1226 4
opt_sample_rgb_2d(struct gl_context *ctx,
                  const struct gl_texture_object *tObj,
                  GLuint n, const GLfloat texcoords[][4],
                  const GLfloat lambda[], GLfloat rgba[][4])
d1240 1
a1240 1
   ASSERT(img->TexFormat == MESA_FORMAT_RGB888);
d1247 4
a1250 5
      GLubyte *texel = ((GLubyte *) img->Data) + 3*pos;
      rgba[k][RCOMP] = UBYTE_TO_FLOAT(texel[2]);
      rgba[k][GCOMP] = UBYTE_TO_FLOAT(texel[1]);
      rgba[k][BCOMP] = UBYTE_TO_FLOAT(texel[0]);
      rgba[k][ACOMP] = 1.0F;
d1255 1
a1255 1
/**
d1264 4
a1267 4
opt_sample_rgba_2d(struct gl_context *ctx,
                   const struct gl_texture_object *tObj,
                   GLuint n, const GLfloat texcoords[][4],
                   const GLfloat lambda[], GLfloat rgba[][4])
d1281 1
a1281 1
   ASSERT(img->TexFormat == MESA_FORMAT_RGBA8888);
d1288 2
a1289 5
      const GLuint texel = *((GLuint *) img->Data + pos);
      rgba[i][RCOMP] = UBYTE_TO_FLOAT( (texel >> 24)        );
      rgba[i][GCOMP] = UBYTE_TO_FLOAT( (texel >> 16) & 0xff );
      rgba[i][BCOMP] = UBYTE_TO_FLOAT( (texel >>  8) & 0xff );
      rgba[i][ACOMP] = UBYTE_TO_FLOAT( (texel      ) & 0xff );
d1294 4
a1297 1
/** Sample 2D texture, using lambda to choose between min/magnification */
d1299 4
a1302 4
sample_lambda_2d(struct gl_context *ctx,
                 const struct gl_texture_object *tObj,
                 GLuint n, const GLfloat texcoords[][4],
                 const GLfloat lambda[], GLfloat rgba[][4])
d1324 2
a1325 1
            switch (tImg->TexFormat) {
d1327 1
d1331 1
d1333 3
d1387 2
a1388 1
            switch (tImg->TexFormat) {
d1390 1
d1394 1
d1396 3
d1428 1
a1428 1
/**
d1431 2
a1432 2
static INLINE void
sample_3d_nearest(struct gl_context *ctx,
d1436 1
a1436 1
                  GLfloat rgba[4])
d1444 3
a1446 3
   i = nearest_texel_location(tObj->WrapS, img, width, texcoord[0]);
   j = nearest_texel_location(tObj->WrapT, img, height, texcoord[1]);
   k = nearest_texel_location(tObj->WrapR, img, depth, texcoord[2]);
d1452 1
a1452 1
      get_border_color(tObj, img, rgba);
d1455 1
a1455 1
      img->FetchTexelf(img, i, j, k, rgba);
d1460 2
a1461 1
/**
d1465 1
a1465 1
sample_3d_linear(struct gl_context *ctx,
d1469 1
a1469 1
                 GLfloat rgba[4])
d1476 1
d1478 2
a1479 2
   GLfloat t000[4], t010[4], t001[4], t011[4];
   GLfloat t100[4], t110[4], t101[4], t111[4];
d1481 3
a1483 3
   linear_texel_locations(tObj->WrapS, img, width, texcoord[0],  &i0, &i1, &a);
   linear_texel_locations(tObj->WrapT, img, height, texcoord[1], &j0, &j1, &b);
   linear_texel_locations(tObj->WrapR, img, depth, texcoord[2],  &k0, &k1, &c);
d1505 1
a1505 1
      get_border_color(tObj, img, t000);
d1508 1
a1508 1
      img->FetchTexelf(img, i0, j0, k0, t000);
d1511 1
a1511 1
      get_border_color(tObj, img, t100);
d1514 1
a1514 1
      img->FetchTexelf(img, i1, j0, k0, t100);
d1517 1
a1517 1
      get_border_color(tObj, img, t010);
d1520 1
a1520 1
      img->FetchTexelf(img, i0, j1, k0, t010);
d1523 1
a1523 1
      get_border_color(tObj, img, t110);
d1526 1
a1526 1
      img->FetchTexelf(img, i1, j1, k0, t110);
d1530 1
a1530 1
      get_border_color(tObj, img, t001);
d1533 1
a1533 1
      img->FetchTexelf(img, i0, j0, k1, t001);
d1536 1
a1536 1
      get_border_color(tObj, img, t101);
d1539 1
a1539 1
      img->FetchTexelf(img, i1, j0, k1, t101);
d1542 1
a1542 1
      get_border_color(tObj, img, t011);
d1545 1
a1545 1
      img->FetchTexelf(img, i0, j1, k1, t011);
d1548 1
a1548 1
      get_border_color(tObj, img, t111);
d1551 1
a1551 1
      img->FetchTexelf(img, i1, j1, k1, t111);
d1555 3
d1562 1
d1564 1
a1564 1
sample_3d_nearest_mipmap_nearest(struct gl_context *ctx,
d1567 1
a1567 1
                                 const GLfloat lambda[], GLfloat rgba[][4] )
d1578 1
a1578 1
sample_3d_linear_mipmap_nearest(struct gl_context *ctx,
d1581 1
a1581 1
                                const GLfloat lambda[], GLfloat rgba[][4])
d1593 1
a1593 1
sample_3d_nearest_mipmap_linear(struct gl_context *ctx,
d1596 1
a1596 1
                                const GLfloat lambda[], GLfloat rgba[][4])
d1607 1
a1607 1
         GLfloat t0[4], t1[4];  /* texels */
d1618 1
a1618 1
sample_3d_linear_mipmap_linear(struct gl_context *ctx,
d1621 1
a1621 1
                               const GLfloat lambda[], GLfloat rgba[][4])
d1632 1
a1632 1
         GLfloat t0[4], t1[4];  /* texels */
a1641 1
/** Sample 3D texture, nearest filtering for both min/magnification */
d1643 1
a1643 1
sample_nearest_3d(struct gl_context *ctx,
d1646 1
a1646 1
                  GLfloat rgba[][4])
d1651 1
a1651 1
   for (i = 0; i < n; i++) {
d1657 1
a1657 1
/** Sample 3D texture, linear filtering for both min/magnification */
d1659 4
a1662 4
sample_linear_3d(struct gl_context *ctx,
                 const struct gl_texture_object *tObj, GLuint n,
                 const GLfloat texcoords[][4],
		 const GLfloat lambda[], GLfloat rgba[][4])
d1667 1
a1667 1
   for (i = 0; i < n; i++) {
d1673 4
a1676 1
/** Sample 3D texture, using lambda to choose between min/magnification */
d1678 4
a1681 4
sample_lambda_3d(struct gl_context *ctx,
                 const struct gl_texture_object *tObj, GLuint n,
                 const GLfloat texcoords[][4], const GLfloat lambda[],
                 GLfloat rgba[][4])
d1779 1
a1779 1
   if (arx >= ary && arx >= arz) {
d1793 1
a1793 1
   else if (ary >= arx && ary >= arz) {
d1822 2
a1823 6
   { 
      const float ima = 1.0F / ma;
      newCoord[0] = ( sc * ima + 1.0F ) * 0.5F;
      newCoord[1] = ( tc * ima + 1.0F ) * 0.5F;
   }

d1829 1
a1829 1
sample_nearest_cube(struct gl_context *ctx,
d1832 1
a1832 1
                    GLfloat rgba[][4])
d1847 1
a1847 1
sample_linear_cube(struct gl_context *ctx,
d1850 1
a1850 1
		   const GLfloat lambda[], GLfloat rgba[][4])
d1865 1
a1865 1
sample_cube_nearest_mipmap_nearest(struct gl_context *ctx,
d1868 1
a1868 1
                                   const GLfloat lambda[], GLfloat rgba[][4])
d1875 1
a1875 1
      GLint level;
a1876 11

      /* XXX we actually need to recompute lambda here based on the newCoords.
       * But we would need the texcoords of adjacent fragments to compute that
       * properly, and we don't have those here.
       * For now, do an approximation:  subtracting 1 from the chosen mipmap
       * level seems to work in some test cases.
       * The same adjustment is done in the next few functions.
      */
      level = nearest_mipmap_level(tObj, lambda[i]);
      level = MAX2(level - 1, 0);

d1883 1
a1883 1
sample_cube_linear_mipmap_nearest(struct gl_context *ctx,
d1886 1
a1886 1
                                  const GLfloat lambda[], GLfloat rgba[][4])
a1893 1
      level = MAX2(level - 1, 0); /* see comment above */
d1901 1
a1901 1
sample_cube_nearest_mipmap_linear(struct gl_context *ctx,
d1904 1
a1904 1
                                  const GLfloat lambda[], GLfloat rgba[][4])
a1911 1
      level = MAX2(level - 1, 0); /* see comment above */
d1918 1
a1918 1
         GLfloat t0[4], t1[4];  /* texels */
d1929 1
a1929 1
sample_cube_linear_mipmap_linear(struct gl_context *ctx,
d1932 1
a1932 1
                                 const GLfloat lambda[], GLfloat rgba[][4])
a1939 1
      level = MAX2(level - 1, 0); /* see comment above */
d1946 1
a1946 1
         GLfloat t0[4], t1[4];
a1955 1
/** Sample cube texture, using lambda to choose between min/magnification */
d1957 4
a1960 4
sample_lambda_cube(struct gl_context *ctx,
		   const struct gl_texture_object *tObj, GLuint n,
		   const GLfloat texcoords[][4], const GLfloat lambda[],
		   GLfloat rgba[][4])
d2030 5
a2034 5
static void
sample_nearest_rect(struct gl_context *ctx,
		    const struct gl_texture_object *tObj, GLuint n,
                    const GLfloat texcoords[][4], const GLfloat lambda[],
                    GLfloat rgba[][4])
d2036 8
a2043 24
   const struct gl_texture_image *img = tObj->Image[0][0];
   const GLint width = img->Width;
   const GLint height = img->Height;
   GLuint i;

   (void) ctx;
   (void) lambda;

   ASSERT(tObj->WrapS == GL_CLAMP ||
          tObj->WrapS == GL_CLAMP_TO_EDGE ||
          tObj->WrapS == GL_CLAMP_TO_BORDER);
   ASSERT(tObj->WrapT == GL_CLAMP ||
          tObj->WrapT == GL_CLAMP_TO_EDGE ||
          tObj->WrapT == GL_CLAMP_TO_BORDER);
   ASSERT(img->_BaseFormat != GL_COLOR_INDEX);

   for (i = 0; i < n; i++) {
      GLint row, col;
      col = clamp_rect_coord_nearest(tObj->WrapS, texcoords[i][0], width);
      row = clamp_rect_coord_nearest(tObj->WrapT, texcoords[i][1], height);
      if (col < 0 || col >= width || row < 0 || row >= height)
         get_border_color(tObj, img, rgba[i]);
      else
         img->FetchTexelf(img, col, row, 0, rgba[i]);
d2048 2
a2049 109
static void
sample_linear_rect(struct gl_context *ctx,
		   const struct gl_texture_object *tObj, GLuint n,
                   const GLfloat texcoords[][4],
		   const GLfloat lambda[], GLfloat rgba[][4])
{
   const struct gl_texture_image *img = tObj->Image[0][0];
   const GLint width = img->Width;
   const GLint height = img->Height;
   GLuint i;

   (void) ctx;
   (void) lambda;

   ASSERT(tObj->WrapS == GL_CLAMP ||
          tObj->WrapS == GL_CLAMP_TO_EDGE ||
          tObj->WrapS == GL_CLAMP_TO_BORDER);
   ASSERT(tObj->WrapT == GL_CLAMP ||
          tObj->WrapT == GL_CLAMP_TO_EDGE ||
          tObj->WrapT == GL_CLAMP_TO_BORDER);
   ASSERT(img->_BaseFormat != GL_COLOR_INDEX);

   for (i = 0; i < n; i++) {
      GLint i0, j0, i1, j1;
      GLfloat t00[4], t01[4], t10[4], t11[4];
      GLfloat a, b;
      GLbitfield useBorderColor = 0x0;

      clamp_rect_coord_linear(tObj->WrapS, texcoords[i][0], width,
                              &i0, &i1, &a);
      clamp_rect_coord_linear(tObj->WrapT, texcoords[i][1], height,
                              &j0, &j1, &b);

      /* compute integer rows/columns */
      if (i0 < 0 || i0 >= width)   useBorderColor |= I0BIT;
      if (i1 < 0 || i1 >= width)   useBorderColor |= I1BIT;
      if (j0 < 0 || j0 >= height)  useBorderColor |= J0BIT;
      if (j1 < 0 || j1 >= height)  useBorderColor |= J1BIT;

      /* get four texel samples */
      if (useBorderColor & (I0BIT | J0BIT))
         get_border_color(tObj, img, t00);
      else
         img->FetchTexelf(img, i0, j0, 0, t00);

      if (useBorderColor & (I1BIT | J0BIT))
         get_border_color(tObj, img, t10);
      else
         img->FetchTexelf(img, i1, j0, 0, t10);

      if (useBorderColor & (I0BIT | J1BIT))
         get_border_color(tObj, img, t01);
      else
         img->FetchTexelf(img, i0, j1, 0, t01);

      if (useBorderColor & (I1BIT | J1BIT))
         get_border_color(tObj, img, t11);
      else
         img->FetchTexelf(img, i1, j1, 0, t11);

      lerp_rgba_2d(rgba[i], a, b, t00, t10, t01, t11);
   }
}


/** Sample Rect texture, using lambda to choose between min/magnification */
static void
sample_lambda_rect(struct gl_context *ctx,
		   const struct gl_texture_object *tObj, GLuint n,
		   const GLfloat texcoords[][4], const GLfloat lambda[],
		   GLfloat rgba[][4])
{
   GLuint minStart, minEnd, magStart, magEnd;

   /* We only need lambda to decide between minification and magnification.
    * There is no mipmapping with rectangular textures.
    */
   compute_min_mag_ranges(tObj, n, lambda,
                          &minStart, &minEnd, &magStart, &magEnd);

   if (minStart < minEnd) {
      if (tObj->MinFilter == GL_NEAREST) {
         sample_nearest_rect(ctx, tObj, minEnd - minStart,
                             texcoords + minStart, NULL, rgba + minStart);
      }
      else {
         sample_linear_rect(ctx, tObj, minEnd - minStart,
                            texcoords + minStart, NULL, rgba + minStart);
      }
   }
   if (magStart < magEnd) {
      if (tObj->MagFilter == GL_NEAREST) {
         sample_nearest_rect(ctx, tObj, magEnd - magStart,
                             texcoords + magStart, NULL, rgba + magStart);
      }
      else {
         sample_linear_rect(ctx, tObj, magEnd - magStart,
                            texcoords + magStart, NULL, rgba + magStart);
      }
   }
}


/**********************************************************************/
/*                2D Texture Array Sampling Functions                 */
/**********************************************************************/

/**
 * Return the texture sample for coordinate (s,t,r) using GL_NEAREST filter.
d2051 3
a2053 6
static void
sample_2d_array_nearest(struct gl_context *ctx,
                        const struct gl_texture_object *tObj,
                        const struct gl_texture_image *img,
                        const GLfloat texcoord[4],
                        GLfloat rgba[4])
d2055 1
a2055 342
   const GLint width = img->Width2;     /* without border, power of two */
   const GLint height = img->Height2;   /* without border, power of two */
   const GLint depth = img->Depth;
   GLint i, j;
   GLint array;
   (void) ctx;

   i = nearest_texel_location(tObj->WrapS, img, width, texcoord[0]);
   j = nearest_texel_location(tObj->WrapT, img, height, texcoord[1]);
   array = tex_array_slice(texcoord[2], depth);

   if (i < 0 || i >= (GLint) img->Width ||
       j < 0 || j >= (GLint) img->Height ||
       array < 0 || array >= (GLint) img->Depth) {
      /* Need this test for GL_CLAMP_TO_BORDER mode */
      get_border_color(tObj, img, rgba);
   }
   else {
      img->FetchTexelf(img, i, j, array, rgba);
   }
}


/**
 * Return the texture sample for coordinate (s,t,r) using GL_LINEAR filter.
 */
static void
sample_2d_array_linear(struct gl_context *ctx,
                       const struct gl_texture_object *tObj,
                       const struct gl_texture_image *img,
                       const GLfloat texcoord[4],
                       GLfloat rgba[4])
{
   const GLint width = img->Width2;
   const GLint height = img->Height2;
   const GLint depth = img->Depth;
   GLint i0, j0, i1, j1;
   GLint array;
   GLbitfield useBorderColor = 0x0;
   GLfloat a, b;
   GLfloat t00[4], t01[4], t10[4], t11[4];

   linear_texel_locations(tObj->WrapS, img, width,  texcoord[0], &i0, &i1, &a);
   linear_texel_locations(tObj->WrapT, img, height, texcoord[1], &j0, &j1, &b);
   array = tex_array_slice(texcoord[2], depth);

   if (array < 0 || array >= depth) {
      COPY_4V(rgba, tObj->BorderColor.f);
   }
   else {
      if (img->Border) {
	 i0 += img->Border;
	 i1 += img->Border;
	 j0 += img->Border;
	 j1 += img->Border;
      }
      else {
	 /* check if sampling texture border color */
	 if (i0 < 0 || i0 >= width)   useBorderColor |= I0BIT;
	 if (i1 < 0 || i1 >= width)   useBorderColor |= I1BIT;
	 if (j0 < 0 || j0 >= height)  useBorderColor |= J0BIT;
	 if (j1 < 0 || j1 >= height)  useBorderColor |= J1BIT;
      }

      /* Fetch texels */
      if (useBorderColor & (I0BIT | J0BIT)) {
         get_border_color(tObj, img, t00);
      }
      else {
	 img->FetchTexelf(img, i0, j0, array, t00);
      }
      if (useBorderColor & (I1BIT | J0BIT)) {
         get_border_color(tObj, img, t10);
      }
      else {
	 img->FetchTexelf(img, i1, j0, array, t10);
      }
      if (useBorderColor & (I0BIT | J1BIT)) {
         get_border_color(tObj, img, t01);
      }
      else {
	 img->FetchTexelf(img, i0, j1, array, t01);
      }
      if (useBorderColor & (I1BIT | J1BIT)) {
         get_border_color(tObj, img, t11);
      }
      else {
	 img->FetchTexelf(img, i1, j1, array, t11);
      }
      
      /* trilinear interpolation of samples */
      lerp_rgba_2d(rgba, a, b, t00, t10, t01, t11);
   }
}


static void
sample_2d_array_nearest_mipmap_nearest(struct gl_context *ctx,
                                       const struct gl_texture_object *tObj,
                                       GLuint n, const GLfloat texcoord[][4],
                                       const GLfloat lambda[], GLfloat rgba[][4])
{
   GLuint i;
   for (i = 0; i < n; i++) {
      GLint level = nearest_mipmap_level(tObj, lambda[i]);
      sample_2d_array_nearest(ctx, tObj, tObj->Image[0][level], texcoord[i],
                              rgba[i]);
   }
}


static void
sample_2d_array_linear_mipmap_nearest(struct gl_context *ctx,
                                      const struct gl_texture_object *tObj,
                                      GLuint n, const GLfloat texcoord[][4],
                                      const GLfloat lambda[], GLfloat rgba[][4])
{
   GLuint i;
   ASSERT(lambda != NULL);
   for (i = 0; i < n; i++) {
      GLint level = nearest_mipmap_level(tObj, lambda[i]);
      sample_2d_array_linear(ctx, tObj, tObj->Image[0][level],
                             texcoord[i], rgba[i]);
   }
}


static void
sample_2d_array_nearest_mipmap_linear(struct gl_context *ctx,
                                      const struct gl_texture_object *tObj,
                                      GLuint n, const GLfloat texcoord[][4],
                                      const GLfloat lambda[], GLfloat rgba[][4])
{
   GLuint i;
   ASSERT(lambda != NULL);
   for (i = 0; i < n; i++) {
      GLint level = linear_mipmap_level(tObj, lambda[i]);
      if (level >= tObj->_MaxLevel) {
         sample_2d_array_nearest(ctx, tObj, tObj->Image[0][tObj->_MaxLevel],
                                 texcoord[i], rgba[i]);
      }
      else {
         GLfloat t0[4], t1[4];  /* texels */
         const GLfloat f = FRAC(lambda[i]);
         sample_2d_array_nearest(ctx, tObj, tObj->Image[0][level  ],
                                 texcoord[i], t0);
         sample_2d_array_nearest(ctx, tObj, tObj->Image[0][level+1],
                                 texcoord[i], t1);
         lerp_rgba(rgba[i], f, t0, t1);
      }
   }
}


static void
sample_2d_array_linear_mipmap_linear(struct gl_context *ctx,
                                     const struct gl_texture_object *tObj,
                                     GLuint n, const GLfloat texcoord[][4],
                                     const GLfloat lambda[], GLfloat rgba[][4])
{
   GLuint i;
   ASSERT(lambda != NULL);
   for (i = 0; i < n; i++) {
      GLint level = linear_mipmap_level(tObj, lambda[i]);
      if (level >= tObj->_MaxLevel) {
         sample_2d_array_linear(ctx, tObj, tObj->Image[0][tObj->_MaxLevel],
                          texcoord[i], rgba[i]);
      }
      else {
         GLfloat t0[4], t1[4];  /* texels */
         const GLfloat f = FRAC(lambda[i]);
         sample_2d_array_linear(ctx, tObj, tObj->Image[0][level  ],
                                texcoord[i], t0);
         sample_2d_array_linear(ctx, tObj, tObj->Image[0][level+1],
                                texcoord[i], t1);
         lerp_rgba(rgba[i], f, t0, t1);
      }
   }
}


/** Sample 2D Array texture, nearest filtering for both min/magnification */
static void
sample_nearest_2d_array(struct gl_context *ctx,
                        const struct gl_texture_object *tObj, GLuint n,
                        const GLfloat texcoords[][4], const GLfloat lambda[],
                        GLfloat rgba[][4])
{
   GLuint i;
   struct gl_texture_image *image = tObj->Image[0][tObj->BaseLevel];
   (void) lambda;
   for (i = 0; i < n; i++) {
      sample_2d_array_nearest(ctx, tObj, image, texcoords[i], rgba[i]);
   }
}



/** Sample 2D Array texture, linear filtering for both min/magnification */
static void
sample_linear_2d_array(struct gl_context *ctx,
                       const struct gl_texture_object *tObj, GLuint n,
                       const GLfloat texcoords[][4],
                       const GLfloat lambda[], GLfloat rgba[][4])
{
   GLuint i;
   struct gl_texture_image *image = tObj->Image[0][tObj->BaseLevel];
   (void) lambda;
   for (i = 0; i < n; i++) {
      sample_2d_array_linear(ctx, tObj, image, texcoords[i], rgba[i]);
   }
}


/** Sample 2D Array texture, using lambda to choose between min/magnification */
static void
sample_lambda_2d_array(struct gl_context *ctx,
                       const struct gl_texture_object *tObj, GLuint n,
                       const GLfloat texcoords[][4], const GLfloat lambda[],
                       GLfloat rgba[][4])
{
   GLuint minStart, minEnd;  /* texels with minification */
   GLuint magStart, magEnd;  /* texels with magnification */
   GLuint i;

   ASSERT(lambda != NULL);
   compute_min_mag_ranges(tObj, n, lambda,
                          &minStart, &minEnd, &magStart, &magEnd);

   if (minStart < minEnd) {
      /* do the minified texels */
      GLuint m = minEnd - minStart;
      switch (tObj->MinFilter) {
      case GL_NEAREST:
         for (i = minStart; i < minEnd; i++)
            sample_2d_array_nearest(ctx, tObj, tObj->Image[0][tObj->BaseLevel],
                                    texcoords[i], rgba[i]);
         break;
      case GL_LINEAR:
         for (i = minStart; i < minEnd; i++)
            sample_2d_array_linear(ctx, tObj, tObj->Image[0][tObj->BaseLevel],
                                   texcoords[i], rgba[i]);
         break;
      case GL_NEAREST_MIPMAP_NEAREST:
         sample_2d_array_nearest_mipmap_nearest(ctx, tObj, m,
                                                texcoords + minStart,
                                                lambda + minStart,
                                                rgba + minStart);
         break;
      case GL_LINEAR_MIPMAP_NEAREST:
         sample_2d_array_linear_mipmap_nearest(ctx, tObj, m, 
                                               texcoords + minStart,
                                               lambda + minStart,
                                               rgba + minStart);
         break;
      case GL_NEAREST_MIPMAP_LINEAR:
         sample_2d_array_nearest_mipmap_linear(ctx, tObj, m,
                                               texcoords + minStart,
                                               lambda + minStart,
                                               rgba + minStart);
         break;
      case GL_LINEAR_MIPMAP_LINEAR:
         sample_2d_array_linear_mipmap_linear(ctx, tObj, m, 
                                              texcoords + minStart,
                                              lambda + minStart, 
                                              rgba + minStart);
         break;
      default:
         _mesa_problem(ctx, "Bad min filter in sample_2d_array_texture");
         return;
      }
   }

   if (magStart < magEnd) {
      /* do the magnified texels */
      switch (tObj->MagFilter) {
      case GL_NEAREST:
         for (i = magStart; i < magEnd; i++)
            sample_2d_array_nearest(ctx, tObj, tObj->Image[0][tObj->BaseLevel],
                              texcoords[i], rgba[i]);
         break;
      case GL_LINEAR:
         for (i = magStart; i < magEnd; i++)
            sample_2d_array_linear(ctx, tObj, tObj->Image[0][tObj->BaseLevel],
                                   texcoords[i], rgba[i]);
         break;
      default:
         _mesa_problem(ctx, "Bad mag filter in sample_2d_array_texture");
         return;
      }
   }
}




/**********************************************************************/
/*                1D Texture Array Sampling Functions                 */
/**********************************************************************/

/**
 * Return the texture sample for coordinate (s,t,r) using GL_NEAREST filter.
 */
static void
sample_1d_array_nearest(struct gl_context *ctx,
                        const struct gl_texture_object *tObj,
                        const struct gl_texture_image *img,
                        const GLfloat texcoord[4],
                        GLfloat rgba[4])
{
   const GLint width = img->Width2;     /* without border, power of two */
   const GLint height = img->Height;
   GLint i;
   GLint array;
   (void) ctx;

   i = nearest_texel_location(tObj->WrapS, img, width, texcoord[0]);
   array = tex_array_slice(texcoord[1], height);

   if (i < 0 || i >= (GLint) img->Width ||
       array < 0 || array >= (GLint) img->Height) {
      /* Need this test for GL_CLAMP_TO_BORDER mode */
      get_border_color(tObj, img, rgba);
   }
   else {
      img->FetchTexelf(img, i, array, 0, rgba);
   }
}


/**
 * Return the texture sample for coordinate (s,t,r) using GL_LINEAR filter.
 */
static void
sample_1d_array_linear(struct gl_context *ctx,
                       const struct gl_texture_object *tObj,
                       const struct gl_texture_image *img,
                       const GLfloat texcoord[4],
                       GLfloat rgba[4])
{
   const GLint width = img->Width2;
   const GLint height = img->Height;
d2057 5
a2061 11
   GLint array;
   GLbitfield useBorderColor = 0x0;
   GLfloat a;
   GLfloat t0[4], t1[4];

   linear_texel_locations(tObj->WrapS, img, width, texcoord[0], &i0, &i1, &a);
   array = tex_array_slice(texcoord[1], height);

   if (img->Border) {
      i0 += img->Border;
      i1 += img->Border;
d2063 7
a2069 11
   else {
      /* check if sampling texture border color */
      if (i0 < 0 || i0 >= width)   useBorderColor |= I0BIT;
      if (i1 < 0 || i1 >= width)   useBorderColor |= I1BIT;
   }

   if (array < 0 || array >= height)   useBorderColor |= K0BIT;

   /* Fetch texels */
   if (useBorderColor & (I0BIT | K0BIT)) {
      get_border_color(tObj, img, t0);
d2072 5
a2076 91
      img->FetchTexelf(img, i0, array, 0, t0);
   }
   if (useBorderColor & (I1BIT | K0BIT)) {
      get_border_color(tObj, img, t1);
   }
   else {
      img->FetchTexelf(img, i1, array, 0, t1);
   }

   /* bilinear interpolation of samples */
   lerp_rgba(rgba, a, t0, t1);
}


static void
sample_1d_array_nearest_mipmap_nearest(struct gl_context *ctx,
                                       const struct gl_texture_object *tObj,
                                       GLuint n, const GLfloat texcoord[][4],
                                       const GLfloat lambda[], GLfloat rgba[][4])
{
   GLuint i;
   for (i = 0; i < n; i++) {
      GLint level = nearest_mipmap_level(tObj, lambda[i]);
      sample_1d_array_nearest(ctx, tObj, tObj->Image[0][level], texcoord[i],
                              rgba[i]);
   }
}


static void
sample_1d_array_linear_mipmap_nearest(struct gl_context *ctx,
                                      const struct gl_texture_object *tObj,
                                      GLuint n, const GLfloat texcoord[][4],
                                      const GLfloat lambda[], GLfloat rgba[][4])
{
   GLuint i;
   ASSERT(lambda != NULL);
   for (i = 0; i < n; i++) {
      GLint level = nearest_mipmap_level(tObj, lambda[i]);
      sample_1d_array_linear(ctx, tObj, tObj->Image[0][level],
                             texcoord[i], rgba[i]);
   }
}


static void
sample_1d_array_nearest_mipmap_linear(struct gl_context *ctx,
                                      const struct gl_texture_object *tObj,
                                      GLuint n, const GLfloat texcoord[][4],
                                      const GLfloat lambda[], GLfloat rgba[][4])
{
   GLuint i;
   ASSERT(lambda != NULL);
   for (i = 0; i < n; i++) {
      GLint level = linear_mipmap_level(tObj, lambda[i]);
      if (level >= tObj->_MaxLevel) {
         sample_1d_array_nearest(ctx, tObj, tObj->Image[0][tObj->_MaxLevel],
                                 texcoord[i], rgba[i]);
      }
      else {
         GLfloat t0[4], t1[4];  /* texels */
         const GLfloat f = FRAC(lambda[i]);
         sample_1d_array_nearest(ctx, tObj, tObj->Image[0][level  ], texcoord[i], t0);
         sample_1d_array_nearest(ctx, tObj, tObj->Image[0][level+1], texcoord[i], t1);
         lerp_rgba(rgba[i], f, t0, t1);
      }
   }
}


static void
sample_1d_array_linear_mipmap_linear(struct gl_context *ctx,
                                     const struct gl_texture_object *tObj,
                                     GLuint n, const GLfloat texcoord[][4],
                                     const GLfloat lambda[], GLfloat rgba[][4])
{
   GLuint i;
   ASSERT(lambda != NULL);
   for (i = 0; i < n; i++) {
      GLint level = linear_mipmap_level(tObj, lambda[i]);
      if (level >= tObj->_MaxLevel) {
         sample_1d_array_linear(ctx, tObj, tObj->Image[0][tObj->_MaxLevel],
                          texcoord[i], rgba[i]);
      }
      else {
         GLfloat t0[4], t1[4];  /* texels */
         const GLfloat f = FRAC(lambda[i]);
         sample_1d_array_linear(ctx, tObj, tObj->Image[0][level  ], texcoord[i], t0);
         sample_1d_array_linear(ctx, tObj, tObj->Image[0][level+1], texcoord[i], t1);
         lerp_rgba(rgba[i], f, t0, t1);
      }
d2078 2
a2082 1
/** Sample 1D Array texture, nearest filtering for both min/magnification */
d2084 4
a2087 4
sample_nearest_1d_array(struct gl_context *ctx,
                        const struct gl_texture_object *tObj, GLuint n,
                        const GLfloat texcoords[][4], const GLfloat lambda[],
                        GLfloat rgba[][4])
d2089 5
d2095 2
a2096 1
   struct gl_texture_image *image = tObj->Image[0][tObj->BaseLevel];
d2098 9
d2108 7
a2114 1
      sample_1d_array_nearest(ctx, tObj, image, texcoords[i], rgba[i]);
a2118 1
/** Sample 1D Array texture, linear filtering for both min/magnification */
d2120 4
a2123 4
sample_linear_1d_array(struct gl_context *ctx,
                       const struct gl_texture_object *tObj, GLuint n,
                       const GLfloat texcoords[][4],
                       const GLfloat lambda[], GLfloat rgba[][4])
d2125 5
d2131 2
a2132 1
   struct gl_texture_image *image = tObj->Image[0][tObj->BaseLevel];
d2134 10
d2145 83
a2227 1
      sample_1d_array_linear(ctx, tObj, image, texcoords[i], rgba[i]);
a2231 1
/** Sample 1D Array texture, using lambda to choose between min/magnification */
d2233 4
a2236 4
sample_lambda_1d_array(struct gl_context *ctx,
                       const struct gl_texture_object *tObj, GLuint n,
                       const GLfloat texcoords[][4], const GLfloat lambda[],
                       GLfloat rgba[][4])
d2238 1
a2238 3
   GLuint minStart, minEnd;  /* texels with minification */
   GLuint magStart, magEnd;  /* texels with magnification */
   GLuint i;
d2240 3
a2242 1
   ASSERT(lambda != NULL);
d2247 7
a2253 36
      /* do the minified texels */
      GLuint m = minEnd - minStart;
      switch (tObj->MinFilter) {
      case GL_NEAREST:
         for (i = minStart; i < minEnd; i++)
            sample_1d_array_nearest(ctx, tObj, tObj->Image[0][tObj->BaseLevel],
                                    texcoords[i], rgba[i]);
         break;
      case GL_LINEAR:
         for (i = minStart; i < minEnd; i++)
            sample_1d_array_linear(ctx, tObj, tObj->Image[0][tObj->BaseLevel],
                                   texcoords[i], rgba[i]);
         break;
      case GL_NEAREST_MIPMAP_NEAREST:
         sample_1d_array_nearest_mipmap_nearest(ctx, tObj, m, texcoords + minStart,
                                                lambda + minStart, rgba + minStart);
         break;
      case GL_LINEAR_MIPMAP_NEAREST:
         sample_1d_array_linear_mipmap_nearest(ctx, tObj, m, 
                                               texcoords + minStart,
                                               lambda + minStart,
                                               rgba + minStart);
         break;
      case GL_NEAREST_MIPMAP_LINEAR:
         sample_1d_array_nearest_mipmap_linear(ctx, tObj, m, texcoords + minStart,
                                               lambda + minStart, rgba + minStart);
         break;
      case GL_LINEAR_MIPMAP_LINEAR:
         sample_1d_array_linear_mipmap_linear(ctx, tObj, m, 
                                              texcoords + minStart,
                                              lambda + minStart, 
                                              rgba + minStart);
         break;
      default:
         _mesa_problem(ctx, "Bad min filter in sample_1d_array_texture");
         return;
a2255 1

d2257 7
a2263 15
      /* do the magnified texels */
      switch (tObj->MagFilter) {
      case GL_NEAREST:
         for (i = magStart; i < magEnd; i++)
            sample_1d_array_nearest(ctx, tObj, tObj->Image[0][tObj->BaseLevel],
                              texcoords[i], rgba[i]);
         break;
      case GL_LINEAR:
         for (i = magStart; i < magEnd; i++)
            sample_1d_array_linear(ctx, tObj, tObj->Image[0][tObj->BaseLevel],
                                   texcoords[i], rgba[i]);
         break;
      default:
         _mesa_problem(ctx, "Bad mag filter in sample_1d_array_texture");
         return;
a2268 32
/**
 * Compare texcoord against depth sample.  Return 1.0 or the ambient value.
 */
static INLINE GLfloat
shadow_compare(GLenum function, GLfloat coord, GLfloat depthSample,
               GLfloat ambient)
{
   switch (function) {
   case GL_LEQUAL:
      return (coord <= depthSample) ? 1.0F : ambient;
   case GL_GEQUAL:
      return (coord >= depthSample) ? 1.0F : ambient;
   case GL_LESS:
      return (coord < depthSample) ? 1.0F : ambient;
   case GL_GREATER:
      return (coord > depthSample) ? 1.0F : ambient;
   case GL_EQUAL:
      return (coord == depthSample) ? 1.0F : ambient;
   case GL_NOTEQUAL:
      return (coord != depthSample) ? 1.0F : ambient;
   case GL_ALWAYS:
      return 1.0F;
   case GL_NEVER:
      return ambient;
   case GL_NONE:
      return depthSample;
   default:
      _mesa_problem(NULL, "Bad compare func in shadow_compare");
      return ambient;
   }
}

d2270 2
a2271 89
/**
 * Compare texcoord against four depth samples.
 */
static INLINE GLfloat
shadow_compare4(GLenum function, GLfloat coord,
                GLfloat depth00, GLfloat depth01,
                GLfloat depth10, GLfloat depth11,
                GLfloat ambient, GLfloat wi, GLfloat wj)
{
   const GLfloat d = (1.0F - (GLfloat) ambient) * 0.25F;
   GLfloat luminance = 1.0F;

   switch (function) {
   case GL_LEQUAL:
      if (depth00 <= coord)  luminance -= d;
      if (depth01 <= coord)  luminance -= d;
      if (depth10 <= coord)  luminance -= d;
      if (depth11 <= coord)  luminance -= d;
      return luminance;
   case GL_GEQUAL:
      if (depth00 >= coord)  luminance -= d;
      if (depth01 >= coord)  luminance -= d;
      if (depth10 >= coord)  luminance -= d;
      if (depth11 >= coord)  luminance -= d;
      return luminance;
   case GL_LESS:
      if (depth00 < coord)  luminance -= d;
      if (depth01 < coord)  luminance -= d;
      if (depth10 < coord)  luminance -= d;
      if (depth11 < coord)  luminance -= d;
      return luminance;
   case GL_GREATER:
      if (depth00 > coord)  luminance -= d;
      if (depth01 > coord)  luminance -= d;
      if (depth10 > coord)  luminance -= d;
      if (depth11 > coord)  luminance -= d;
      return luminance;
   case GL_EQUAL:
      if (depth00 == coord)  luminance -= d;
      if (depth01 == coord)  luminance -= d;
      if (depth10 == coord)  luminance -= d;
      if (depth11 == coord)  luminance -= d;
      return luminance;
   case GL_NOTEQUAL:
      if (depth00 != coord)  luminance -= d;
      if (depth01 != coord)  luminance -= d;
      if (depth10 != coord)  luminance -= d;
      if (depth11 != coord)  luminance -= d;
      return luminance;
   case GL_ALWAYS:
      return 0.0;
   case GL_NEVER:
      return ambient;
   case GL_NONE:
      /* ordinary bilinear filtering */
      return lerp_2d(wi, wj, depth00, depth10, depth01, depth11);
   default:
      _mesa_problem(NULL, "Bad compare func in sample_depth_texture");
      return 0.0F;
   }
}


/**
 * Choose the mipmap level to use when sampling from a depth texture.
 */
static int
choose_depth_texture_level(const struct gl_texture_object *tObj, GLfloat lambda)
{
   GLint level;

   if (tObj->MinFilter == GL_NEAREST || tObj->MinFilter == GL_LINEAR) {
      /* no mipmapping - use base level */
      level = tObj->BaseLevel;
   }
   else {
      /* choose mipmap level */
      lambda = CLAMP(lambda, tObj->MinLod, tObj->MaxLod);
      level = (GLint) lambda;
      level = CLAMP(level, tObj->BaseLevel, tObj->_MaxLevel);
   }

   return level;
}


/**
 * Sample a shadow/depth texture.  This function is incomplete.  It doesn't
 * check for minification vs. magnification, etc.
d2274 1
a2274 1
sample_depth_texture( struct gl_context *ctx,
d2277 1
a2277 1
                      GLfloat texel[][4] )
d2279 2
a2280 2
   const GLint level = choose_depth_texture_level(tObj, lambda[0]);
   const struct gl_texture_image *img = tObj->Image[0][level];
d2283 1
a2283 4
   const GLint depth = img->Depth;
   const GLuint compare_coord = (tObj->Target == GL_TEXTURE_2D_ARRAY_EXT)
       ? 3 : 2;
   GLfloat ambient;
d2285 1
a2285 1
   GLfloat result;
d2287 4
a2290 2
   ASSERT(img->_BaseFormat == GL_DEPTH_COMPONENT ||
          img->_BaseFormat == GL_DEPTH_STENCIL_EXT);
d2294 1
a2294 3
          tObj->Target == GL_TEXTURE_RECTANGLE_NV ||
          tObj->Target == GL_TEXTURE_1D_ARRAY_EXT ||
          tObj->Target == GL_TEXTURE_2D_ARRAY_EXT);
d2296 1
a2296 1
   ambient = tObj->CompareFailValue;
d2300 18
a2317 2
   function = (tObj->CompareMode == GL_COMPARE_R_TO_TEXTURE_ARB) ?
      tObj->CompareFunc : GL_NONE;
d2323 1
a2323 1
         GLint col, row, slice;
d2325 12
a2336 5
         nearest_texcoord(tObj, level, texcoords[i], &col, &row, &slice);

         if (col >= 0 && row >= 0 && col < width && row < height && 
             slice >= 0 && slice < depth) {
            img->FetchTexelf(img, col, row, slice, &depthSample);
d2339 1
a2339 1
            depthSample = tObj->BorderColor.f[0];
d2342 32
a2373 2
         result = shadow_compare(function, texcoords[i][compare_coord],
                                 depthSample, ambient);
d2377 4
a2380 1
            ASSIGN_4V(texel[i], result, result, result, 1.0F);
d2383 4
a2386 1
            ASSIGN_4V(texel[i], result, result, result, result);
d2389 4
a2392 4
            ASSIGN_4V(texel[i], 0.0F, 0.0F, 0.0F, result);
            break;
         case GL_RED:
            ASSIGN_4V(texel[i], result, 0.0F, 0.0F, 1.0F);
d2405 1
a2405 2
         GLint slice;
         GLfloat wi, wj;
d2408 12
a2419 2
         linear_texcoord(tObj, level, texcoords[i], &i0, &i1, &j0, &j1, &slice,
                         &wi, &wj);
d2425 2
a2426 4
            if (tObj->Target != GL_TEXTURE_1D_ARRAY_EXT) {
               j0 += img->Border;
               j1 += img->Border;
            }
d2435 21
a2455 5
         if (slice < 0 || slice >= (GLint) depth) {
            depth00 = tObj->BorderColor.f[0];
            depth01 = tObj->BorderColor.f[0];
            depth10 = tObj->BorderColor.f[0];
            depth11 = tObj->BorderColor.f[0];
d2458 12
a2469 3
            /* get four depth samples from the texture */
            if (useBorderTexel & (I0BIT | J0BIT)) {
               depth00 = tObj->BorderColor.f[0];
d2472 1
a2472 1
               img->FetchTexelf(img, i0, j0, slice, &depth00);
d2474 66
a2539 10
            if (useBorderTexel & (I1BIT | J0BIT)) {
               depth10 = tObj->BorderColor.f[0];
            }
            else {
               img->FetchTexelf(img, i1, j0, slice, &depth10);
            }

            if (tObj->Target != GL_TEXTURE_1D_ARRAY_EXT) {
               if (useBorderTexel & (I0BIT | J1BIT)) {
                  depth01 = tObj->BorderColor.f[0];
d2541 4
a2544 13
               else {
                  img->FetchTexelf(img, i0, j1, slice, &depth01);
               }
               if (useBorderTexel & (I1BIT | J1BIT)) {
                  depth11 = tObj->BorderColor.f[0];
               }
               else {
                  img->FetchTexelf(img, i1, j1, slice, &depth11);
               }
            }
            else {
               depth01 = depth00;
               depth11 = depth10;
a2547 4
         result = shadow_compare4(function, texcoords[i][compare_coord],
                                  depth00, depth01, depth10, depth11,
                                  ambient, wi, wj);

d2550 4
a2553 1
            ASSIGN_4V(texel[i], result, result, result, 1.0F);
d2556 4
a2559 1
            ASSIGN_4V(texel[i], result, result, result, result);
d2562 4
a2565 1
            ASSIGN_4V(texel[i], 0.0F, 0.0F, 0.0F, result);
a2569 1

d2575 97
d2679 1
a2679 1
null_sample_func( struct gl_context *ctx,
d2682 1
a2682 1
		  GLfloat rgba[][4])
d2693 1
a2693 1
      rgba[i][ACOMP] = 1.0;
d2702 1
a2702 1
_swrast_choose_texture_sample_func( struct gl_context *ctx,
d2705 1
a2705 1
   if (!t || !t->_Complete) {
d2745 1
a2745 1
                img->TexFormat == MESA_FORMAT_RGB888) {
d2752 1
a2752 1
                     img->TexFormat == MESA_FORMAT_RGBA8888) {
a2793 22
         }
      case GL_TEXTURE_1D_ARRAY_EXT:
         if (needLambda) {
            return &sample_lambda_1d_array;
         }
         else if (t->MinFilter == GL_LINEAR) {
            return &sample_linear_1d_array;
         }
         else {
            ASSERT(t->MinFilter == GL_NEAREST);
            return &sample_nearest_1d_array;
         }
      case GL_TEXTURE_2D_ARRAY_EXT:
         if (needLambda) {
            return &sample_lambda_2d_array;
         }
         else if (t->MinFilter == GL_LINEAR) {
            return &sample_linear_2d_array;
         }
         else {
            ASSERT(t->MinFilter == GL_NEAREST);
            return &sample_nearest_2d_array;
@


1.1.1.5
log
@Import Mesa 9.2.0
@
text
@d3 1
d20 3
a22 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
d30 1
a30 2
#include "main/texobj.h"
#include "main/samplerobj.h"
d61 1
a61 1
static inline GLfloat
d75 1
a75 1
static inline GLfloat
d93 1
a93 1
static inline void
d106 1
a106 1
static inline void
d121 1
a121 1
static inline void
d157 1
a157 1
static inline void
a162 1
   const struct swrast_texture_image *swImg = swrast_texture_image_const(img);
d167 1
a167 1
      if (swImg->_IsPowerOfTwo) {
a275 1
      break;
d284 1
a284 1
static inline GLint
a288 1
   const struct swrast_texture_image *swImg = swrast_texture_image_const(img);
d296 1
a296 1
      if (swImg->_IsPowerOfTwo)
d408 1
a408 1
static inline void
d422 1
a422 1
static inline GLint
d442 1
a442 1
static inline void
a472 1
      break;
d483 1
a483 1
static inline GLint
d496 2
a497 3
static inline void
nearest_texcoord(const struct gl_sampler_object *samp,
                 const struct gl_texture_object *texObj,
d509 2
a510 2
      *i = clamp_rect_coord_nearest(samp->WrapS, texcoord[0], width);
      *j = clamp_rect_coord_nearest(samp->WrapT, texcoord[1], height);
d514 1
a514 1
      *i = nearest_texel_location(samp->WrapS, img, width, texcoord[0]);
d519 2
a520 2
      *i = nearest_texel_location(samp->WrapS, img, width, texcoord[0]);
      *j = nearest_texel_location(samp->WrapT, img, height, texcoord[1]);
d524 1
a524 1
      *i = nearest_texel_location(samp->WrapS, img, width, texcoord[0]);
d529 2
a530 2
      *i = nearest_texel_location(samp->WrapS, img, width, texcoord[0]);
      *j = nearest_texel_location(samp->WrapT, img, height, texcoord[1]);
a534 1
      break;
d543 2
a544 3
static inline void
linear_texcoord(const struct gl_sampler_object *samp,
                const struct gl_texture_object *texObj,
d557 1
a557 1
      clamp_rect_coord_linear(samp->WrapS, texcoord[0],
d559 1
a559 1
      clamp_rect_coord_linear(samp->WrapT, texcoord[1],
d566 1
a566 1
      linear_texel_locations(samp->WrapS, img, width,
d568 1
a568 1
      linear_texel_locations(samp->WrapT, img, height,
d574 1
a574 1
      linear_texel_locations(samp->WrapS, img, width,
d582 1
a582 1
      linear_texel_locations(samp->WrapS, img, width,
d584 1
a584 1
      linear_texel_locations(samp->WrapT, img, height,
a590 1
      break;
d600 1
a600 1
static inline GLint
d615 1
a615 1
static inline GLint
d651 2
a652 2
static inline void
compute_min_mag_ranges(const struct gl_sampler_object *samp,
d660 1
a660 1
   ASSERT(samp->MinFilter != samp->MagFilter);
d663 3
a665 3
   if (samp->MagFilter == GL_LINEAR
       && (samp->MinFilter == GL_NEAREST_MIPMAP_NEAREST ||
           samp->MinFilter == GL_NEAREST_MIPMAP_LINEAR)) {
d760 2
a761 2
static inline void
get_border_color(const struct gl_sampler_object *samp,
d767 3
a769 3
      rgba[0] = samp->BorderColor.f[0];
      rgba[1] = samp->BorderColor.f[1];
      rgba[2] = samp->BorderColor.f[2];
d774 1
a774 1
      rgba[3] = samp->BorderColor.f[3];
d777 1
a777 1
      rgba[0] = rgba[1] = rgba[2] = samp->BorderColor.f[0];
d781 2
a782 2
      rgba[0] = rgba[1] = rgba[2] = samp->BorderColor.f[0];
      rgba[3] = samp->BorderColor.f[3];
d785 1
a785 1
      rgba[0] = rgba[1] = rgba[2] = rgba[3] = samp->BorderColor.f[0];
d788 1
a788 2
      COPY_4V(rgba, samp->BorderColor.f);
      break;
a792 36
/**
 * Put z into texel according to GL_DEPTH_MODE.
 */
static INLINE void
apply_depth_mode(GLenum depthMode, GLfloat z, GLfloat texel[4])
{
   switch (depthMode) {
   case GL_LUMINANCE:
      ASSIGN_4V(texel, z, z, z, 1.0F);
      break;
   case GL_INTENSITY:
      ASSIGN_4V(texel, z, z, z, z);
      break;
   case GL_ALPHA:
      ASSIGN_4V(texel, 0.0F, 0.0F, 0.0F, z);
      break;
   case GL_RED:
      ASSIGN_4V(texel, z, 0.0F, 0.0F, 1.0F);
      break;
   default:
      _mesa_problem(NULL, "Bad depth texture mode");
   }
}


/**
 * Is the given texture a depth (or depth/stencil) texture?
 */
static GLboolean
is_depth_texture(const struct gl_texture_object *tObj)
{
   GLenum format = tObj->Image[0][tObj->BaseLevel]->_BaseFormat;
   return format == GL_DEPTH_COMPONENT || format == GL_DEPTH_STENCIL_EXT;
}


d800 1
a800 1
static inline void
d802 1
a802 1
                  const struct gl_sampler_object *samp,
a805 1
   const struct swrast_texture_image *swImg = swrast_texture_image_const(img);
d808 1
a808 1
   i = nearest_texel_location(samp->WrapS, img, width, texcoord[0]);
d813 1
a813 1
      get_border_color(samp, img, rgba);
d816 1
a816 1
      swImg->FetchTexel(swImg, i, 0, 0, rgba);
d824 1
a824 1
static inline void
d826 1
a826 1
                 const struct gl_sampler_object *samp,
a829 1
   const struct swrast_texture_image *swImg = swrast_texture_image_const(img);
d836 1
a836 1
   linear_texel_locations(samp->WrapS, img, width, texcoord[0], &i0, &i1, &a);
d849 1
a849 1
      get_border_color(samp, img, t0);
d852 1
a852 1
      swImg->FetchTexel(swImg, i0, 0, 0, t0);
d855 1
a855 1
      get_border_color(samp, img, t1);
d858 1
a858 1
      swImg->FetchTexel(swImg, i1, 0, 0, t1);
a866 1
                                 const struct gl_sampler_object *samp,
d875 1
a875 1
      sample_1d_nearest(ctx, samp, tObj->Image[0][level], texcoord[i], rgba[i]);
a881 1
                                const struct gl_sampler_object *samp,
d890 1
a890 1
      sample_1d_linear(ctx, samp, tObj->Image[0][level], texcoord[i], rgba[i]);
a896 1
                                const struct gl_sampler_object *samp,
d906 1
a906 1
         sample_1d_nearest(ctx, samp, tObj->Image[0][tObj->_MaxLevel],
d912 2
a913 2
         sample_1d_nearest(ctx, samp, tObj->Image[0][level  ], texcoord[i], t0);
         sample_1d_nearest(ctx, samp, tObj->Image[0][level+1], texcoord[i], t1);
a921 1
                               const struct gl_sampler_object *samp,
d931 1
a931 1
         sample_1d_linear(ctx, samp, tObj->Image[0][tObj->_MaxLevel],
d937 2
a938 2
         sample_1d_linear(ctx, samp, tObj->Image[0][level  ], texcoord[i], t0);
         sample_1d_linear(ctx, samp, tObj->Image[0][level+1], texcoord[i], t1);
a947 1
                   const struct gl_sampler_object *samp,
d956 1
a956 1
      sample_1d_nearest(ctx, samp, image, texcoords[i], rgba[i]);
a963 1
                  const struct gl_sampler_object *samp,
d972 1
a972 1
      sample_1d_linear(ctx, samp, image, texcoords[i], rgba[i]);
a979 1
                  const struct gl_sampler_object *samp,
d989 1
a989 1
   compute_min_mag_ranges(samp, n, lambda,
d995 1
a995 1
      switch (samp->MinFilter) {
d998 1
a998 1
            sample_1d_nearest(ctx, samp, tObj->Image[0][tObj->BaseLevel],
d1003 1
a1003 1
            sample_1d_linear(ctx, samp, tObj->Image[0][tObj->BaseLevel],
d1007 1
a1007 1
         sample_1d_nearest_mipmap_nearest(ctx, samp, tObj, m, texcoords + minStart,
d1011 1
a1011 1
         sample_1d_linear_mipmap_nearest(ctx, samp, tObj, m, texcoords + minStart,
d1015 1
a1015 1
         sample_1d_nearest_mipmap_linear(ctx, samp, tObj, m, texcoords + minStart,
d1019 1
a1019 1
         sample_1d_linear_mipmap_linear(ctx, samp, tObj, m, texcoords + minStart,
d1030 1
a1030 1
      switch (samp->MagFilter) {
d1033 1
a1033 1
            sample_1d_nearest(ctx, samp, tObj->Image[0][tObj->BaseLevel],
d1038 1
a1038 1
            sample_1d_linear(ctx, samp, tObj->Image[0][tObj->BaseLevel],
d1057 1
a1057 1
static inline void
d1059 1
a1059 1
                  const struct gl_sampler_object *samp,
a1063 1
   const struct swrast_texture_image *swImg = swrast_texture_image_const(img);
d1069 2
a1070 2
   i = nearest_texel_location(samp->WrapS, img, width, texcoord[0]);
   j = nearest_texel_location(samp->WrapT, img, height, texcoord[1]);
d1078 1
a1078 1
      get_border_color(samp, img, rgba);
d1081 1
a1081 1
      swImg->FetchTexel(swImg, i, j, 0, rgba);
d1090 1
a1090 1
static inline void
d1092 1
a1092 1
                 const struct gl_sampler_object *samp,
a1096 1
   const struct swrast_texture_image *swImg = swrast_texture_image_const(img);
d1104 2
a1105 2
   linear_texel_locations(samp->WrapS, img, width, texcoord[0],  &i0, &i1, &a);
   linear_texel_locations(samp->WrapT, img, height, texcoord[1], &j0, &j1, &b);
d1122 1
a1122 1
      get_border_color(samp, img, t00);
d1125 1
a1125 1
      swImg->FetchTexel(swImg, i0, j0, 0, t00);
d1128 1
a1128 1
      get_border_color(samp, img, t10);
d1131 1
a1131 1
      swImg->FetchTexel(swImg, i1, j0, 0, t10);
d1134 1
a1134 1
      get_border_color(samp, img, t01);
d1137 1
a1137 1
      swImg->FetchTexel(swImg, i0, j1, 0, t01);
d1140 1
a1140 1
      get_border_color(samp, img, t11);
d1143 1
a1143 1
      swImg->FetchTexel(swImg, i1, j1, 0, t11);
d1154 1
a1154 1
static inline void
d1156 1
a1156 1
                        const struct gl_sampler_object *samp,
a1160 1
   const struct swrast_texture_image *swImg = swrast_texture_image_const(img);
d1169 2
a1170 2
   ASSERT(samp->WrapS == GL_REPEAT);
   ASSERT(samp->WrapT == GL_REPEAT);
d1172 2
a1173 1
   ASSERT(swImg->_IsPowerOfTwo);
d1178 4
a1181 4
   swImg->FetchTexel(swImg, i0, j0, 0, t00);
   swImg->FetchTexel(swImg, i1, j0, 0, t10);
   swImg->FetchTexel(swImg, i0, j1, 0, t01);
   swImg->FetchTexel(swImg, i1, j1, 0, t11);
a1188 1
                                 const struct gl_sampler_object *samp,
d1196 1
a1196 1
      sample_2d_nearest(ctx, samp, tObj->Image[0][level], texcoord[i], rgba[i]);
a1202 1
                                const struct gl_sampler_object *samp,
d1211 1
a1211 1
      sample_2d_linear(ctx, samp, tObj->Image[0][level], texcoord[i], rgba[i]);
a1217 1
                                const struct gl_sampler_object *samp,
d1227 1
a1227 1
         sample_2d_nearest(ctx, samp, tObj->Image[0][tObj->_MaxLevel],
d1233 2
a1234 2
         sample_2d_nearest(ctx, samp, tObj->Image[0][level  ], texcoord[i], t0);
         sample_2d_nearest(ctx, samp, tObj->Image[0][level+1], texcoord[i], t1);
a1242 1
                                const struct gl_sampler_object *samp,
d1252 1
a1252 1
         sample_2d_linear(ctx, samp, tObj->Image[0][tObj->_MaxLevel],
d1258 2
a1259 2
         sample_2d_linear(ctx, samp, tObj->Image[0][level  ], texcoord[i], t0);
         sample_2d_linear(ctx, samp, tObj->Image[0][level+1], texcoord[i], t1);
a1267 1
                                      const struct gl_sampler_object *samp,
d1274 2
a1275 2
   ASSERT(samp->WrapS == GL_REPEAT);
   ASSERT(samp->WrapT == GL_REPEAT);
d1279 1
a1279 1
         sample_2d_linear_repeat(ctx, samp, tObj->Image[0][tObj->_MaxLevel],
d1285 1
a1285 1
         sample_2d_linear_repeat(ctx, samp, tObj->Image[0][level  ],
d1287 1
a1287 1
         sample_2d_linear_repeat(ctx, samp, tObj->Image[0][level+1],
a1297 1
                  const struct gl_sampler_object *samp,
d1306 1
a1306 1
      sample_2d_nearest(ctx, samp, image, texcoords[i], rgba[i]);
a1313 1
                 const struct gl_sampler_object *samp,
a1319 1
   const struct swrast_texture_image *swImg = swrast_texture_image_const(image);
d1321 3
a1323 3
   if (samp->WrapS == GL_REPEAT &&
       samp->WrapT == GL_REPEAT &&
       swImg->_IsPowerOfTwo &&
d1326 1
a1326 1
         sample_2d_linear_repeat(ctx, samp, image, texcoords[i], rgba[i]);
d1331 1
a1331 1
         sample_2d_linear(ctx, samp, image, texcoords[i], rgba[i]);
a1346 1
                  const struct gl_sampler_object *samp,
a1351 1
   const struct swrast_texture_image *swImg = swrast_texture_image_const(img);
d1360 2
a1361 2
   ASSERT(samp->WrapS==GL_REPEAT);
   ASSERT(samp->WrapT==GL_REPEAT);
d1364 1
a1364 2
   ASSERT(swImg->_IsPowerOfTwo);
   (void) swImg;
d1370 1
a1370 1
      GLubyte *texel = (GLubyte *) swImg->ImageSlices[0] + 3 * pos;
a1388 1
                   const struct gl_sampler_object *samp,
a1393 1
   const struct swrast_texture_image *swImg = swrast_texture_image_const(img);
d1402 2
a1403 2
   ASSERT(samp->WrapS==GL_REPEAT);
   ASSERT(samp->WrapT==GL_REPEAT);
d1406 1
a1406 2
   ASSERT(swImg->_IsPowerOfTwo);
   (void) swImg;
d1412 1
a1412 1
      const GLuint texel = *((GLuint *) swImg->ImageSlices[0] + pos);
a1423 1
                 const struct gl_sampler_object *samp,
a1428 1
   const struct swrast_texture_image *swImg = swrast_texture_image_const(tImg);
d1432 5
a1436 6
   const GLboolean repeatNoBorderPOT = (samp->WrapS == GL_REPEAT)
      && (samp->WrapT == GL_REPEAT)
      && (tImg->Border == 0)
      && (_mesa_format_row_stride(tImg->TexFormat, tImg->Width) ==
          swImg->RowStride)
      && swImg->_IsPowerOfTwo;
d1439 1
a1439 1
   compute_min_mag_ranges(samp, n, lambda,
d1445 1
a1445 1
      switch (samp->MinFilter) {
d1450 1
a1450 1
               opt_sample_rgb_2d(ctx, samp, tObj, m, texcoords + minStart,
d1454 1
a1454 1
	       opt_sample_rgba_2d(ctx, samp, tObj, m, texcoords + minStart,
d1458 1
a1458 1
               sample_nearest_2d(ctx, samp, tObj, m, texcoords + minStart,
d1463 1
a1463 1
            sample_nearest_2d(ctx, samp, tObj, m, texcoords + minStart,
d1468 1
a1468 1
	 sample_linear_2d(ctx, samp, tObj, m, texcoords + minStart,
d1472 1
a1472 1
         sample_2d_nearest_mipmap_nearest(ctx, samp, tObj, m,
d1477 1
a1477 1
         sample_2d_linear_mipmap_nearest(ctx, samp, tObj, m, texcoords + minStart,
d1481 1
a1481 1
         sample_2d_nearest_mipmap_linear(ctx, samp, tObj, m, texcoords + minStart,
d1486 1
a1486 1
            sample_2d_linear_mipmap_linear_repeat(ctx, samp, tObj, m,
d1489 1
a1489 1
            sample_2d_linear_mipmap_linear(ctx, samp, tObj, m, texcoords + minStart,
d1502 1
a1502 1
      switch (samp->MagFilter) {
d1507 1
a1507 1
               opt_sample_rgb_2d(ctx, samp, tObj, m, texcoords + magStart,
d1511 1
a1511 1
	       opt_sample_rgba_2d(ctx, samp, tObj, m, texcoords + magStart,
d1515 1
a1515 1
               sample_nearest_2d(ctx, samp, tObj, m, texcoords + magStart,
d1520 1
a1520 1
            sample_nearest_2d(ctx, samp, tObj, m, texcoords + magStart,
d1525 1
a1525 1
	 sample_linear_2d(ctx, samp, tObj, m, texcoords + magStart,
a1529 397
         break;
      }
   }
}


/* For anisotropic filtering */
#define WEIGHT_LUT_SIZE 1024

static GLfloat *weightLut = NULL;

/**
 * Creates the look-up table used to speed-up EWA sampling
 */
static void
create_filter_table(void)
{
   GLuint i;
   if (!weightLut) {
      weightLut = malloc(WEIGHT_LUT_SIZE * sizeof(GLfloat));

      for (i = 0; i < WEIGHT_LUT_SIZE; ++i) {
         GLfloat alpha = 2;
         GLfloat r2 = (GLfloat) i / (GLfloat) (WEIGHT_LUT_SIZE - 1);
         GLfloat weight = (GLfloat) exp(-alpha * r2);
         weightLut[i] = weight;
      }
   }
}


/**
 * Elliptical weighted average (EWA) filter for producing high quality
 * anisotropic filtered results.
 * Based on the Higher Quality Elliptical Weighted Avarage Filter
 * published by Paul S. Heckbert in his Master's Thesis
 * "Fundamentals of Texture Mapping and Image Warping" (1989)
 */
static void
sample_2d_ewa(struct gl_context *ctx,
              const struct gl_sampler_object *samp,
              const struct gl_texture_object *tObj,
              const GLfloat texcoord[4],
              const GLfloat dudx, const GLfloat dvdx,
              const GLfloat dudy, const GLfloat dvdy, const GLint lod,
              GLfloat rgba[])
{
   GLint level = lod > 0 ? lod : 0;
   GLfloat scaling = 1.0f / (1 << level);
   const struct gl_texture_image *img =	tObj->Image[0][level];
   const struct gl_texture_image *mostDetailedImage =
      tObj->Image[0][tObj->BaseLevel];
   const struct swrast_texture_image *swImg =
      swrast_texture_image_const(mostDetailedImage);
   GLfloat tex_u = -0.5f + texcoord[0] * swImg->WidthScale * scaling;
   GLfloat tex_v = -0.5f + texcoord[1] * swImg->HeightScale * scaling;

   GLfloat ux = dudx * scaling;
   GLfloat vx = dvdx * scaling;
   GLfloat uy = dudy * scaling;
   GLfloat vy = dvdy * scaling;

   /* compute ellipse coefficients to bound the region: 
    * A*x*x + B*x*y + C*y*y = F.
    */
   GLfloat A = vx*vx+vy*vy+1;
   GLfloat B = -2*(ux*vx+uy*vy);
   GLfloat C = ux*ux+uy*uy+1;
   GLfloat F = A*C-B*B/4.0f;

   /* check if it is an ellipse */
   /* ASSERT(F > 0.0); */

   /* Compute the ellipse's (u,v) bounding box in texture space */
   GLfloat d = -B*B+4.0f*C*A;
   GLfloat box_u = 2.0f / d * sqrtf(d*C*F); /* box_u -> half of bbox with   */
   GLfloat box_v = 2.0f / d * sqrtf(A*d*F); /* box_v -> half of bbox height */

   GLint u0 = (GLint) floorf(tex_u - box_u);
   GLint u1 = (GLint) ceilf (tex_u + box_u);
   GLint v0 = (GLint) floorf(tex_v - box_v);
   GLint v1 = (GLint) ceilf (tex_v + box_v);

   GLfloat num[4] = {0.0F, 0.0F, 0.0F, 0.0F};
   GLfloat newCoord[2];
   GLfloat den = 0.0F;
   GLfloat ddq;
   GLfloat U = u0 - tex_u;
   GLint v;

   /* Scale ellipse formula to directly index the Filter Lookup Table.
    * i.e. scale so that F = WEIGHT_LUT_SIZE-1
    */
   GLfloat formScale = (GLfloat) (WEIGHT_LUT_SIZE - 1) / F;
   A *= formScale;
   B *= formScale;
   C *= formScale;
   /* F *= formScale; */ /* no need to scale F as we don't use it below here */

   /* Heckbert MS thesis, p. 59; scan over the bounding box of the ellipse
    * and incrementally update the value of Ax^2+Bxy*Cy^2; when this
    * value, q, is less than F, we're inside the ellipse
    */
   ddq = 2 * A;
   for (v = v0; v <= v1; ++v) {
      GLfloat V = v - tex_v;
      GLfloat dq = A * (2 * U + 1) + B * V;
      GLfloat q = (C * V + B * U) * V + A * U * U;

      GLint u;
      for (u = u0; u <= u1; ++u) {
         /* Note that the ellipse has been pre-scaled so F = WEIGHT_LUT_SIZE - 1 */
         if (q < WEIGHT_LUT_SIZE) {
            /* as a LUT is used, q must never be negative;
             * should not happen, though
             */
            const GLint qClamped = q >= 0.0F ? (GLint) q : 0;
            GLfloat weight = weightLut[qClamped];

            newCoord[0] = u / ((GLfloat) img->Width2);
            newCoord[1] = v / ((GLfloat) img->Height2);

            sample_2d_nearest(ctx, samp, img, newCoord, rgba);
            num[0] += weight * rgba[0];
            num[1] += weight * rgba[1];
            num[2] += weight * rgba[2];
            num[3] += weight * rgba[3];

            den += weight;
         }
         q += dq;
         dq += ddq;
      }
   }

   if (den <= 0.0F) {
      /* Reaching this place would mean
       * that no pixels intersected the ellipse.
       * This should never happen because
       * the filter we use always
       * intersects at least one pixel.
       */

      /*rgba[0]=0;
      rgba[1]=0;
      rgba[2]=0;
      rgba[3]=0;*/
      /* not enough pixels in resampling, resort to direct interpolation */
      sample_2d_linear(ctx, samp, img, texcoord, rgba);
      return;
   }

   rgba[0] = num[0] / den;
   rgba[1] = num[1] / den;
   rgba[2] = num[2] / den;
   rgba[3] = num[3] / den;
}


/**
 * Anisotropic filtering using footprint assembly as outlined in the
 * EXT_texture_filter_anisotropic spec:
 * http://www.opengl.org/registry/specs/EXT/texture_filter_anisotropic.txt
 * Faster than EWA but has less quality (more aliasing effects)
 */
static void
sample_2d_footprint(struct gl_context *ctx,
                 const struct gl_sampler_object *samp,
                 const struct gl_texture_object *tObj,
                 const GLfloat texcoord[4],
                 const GLfloat dudx, const GLfloat dvdx,
                 const GLfloat dudy, const GLfloat dvdy, const GLint lod,
                 GLfloat rgba[])
{
   GLint level = lod > 0 ? lod : 0;
   GLfloat scaling = 1.0F / (1 << level);
   const struct gl_texture_image *img = tObj->Image[0][level];

   GLfloat ux = dudx * scaling;
   GLfloat vx = dvdx * scaling;
   GLfloat uy = dudy * scaling;
   GLfloat vy = dvdy * scaling;

   GLfloat Px2 = ux * ux + vx * vx; /* squared length of dx */
   GLfloat Py2 = uy * uy + vy * vy; /* squared length of dy */

   GLint numSamples;
   GLfloat ds;
   GLfloat dt;

   GLfloat num[4] = {0.0F, 0.0F, 0.0F, 0.0F};
   GLfloat newCoord[2];
   GLint s;

   /*  Calculate the per anisotropic sample offsets in s,t space. */
   if (Px2 > Py2) {
      numSamples = (GLint) ceilf(sqrtf(Px2));
      ds = ux / ((GLfloat) img->Width2);
      dt = vx / ((GLfloat) img->Height2);
   }
   else {
      numSamples = (GLint) ceilf(sqrtf(Py2));
      ds = uy / ((GLfloat) img->Width2);
      dt = vy / ((GLfloat) img->Height2);
   }

   for (s = 0; s<numSamples; s++) {
      newCoord[0] = texcoord[0] + ds * ((GLfloat)(s+1) / (numSamples+1) -0.5f);
      newCoord[1] = texcoord[1] + dt * ((GLfloat)(s+1) / (numSamples+1) -0.5f);

      sample_2d_linear(ctx, samp, img, newCoord, rgba);
      num[0] += rgba[0];
      num[1] += rgba[1];
      num[2] += rgba[2];
      num[3] += rgba[3];
   }

   rgba[0] = num[0] / numSamples;
   rgba[1] = num[1] / numSamples;
   rgba[2] = num[2] / numSamples;
   rgba[3] = num[3] / numSamples;
}


/**
 * Returns the index of the specified texture object in the
 * gl_context texture unit array.
 */
static inline GLuint
texture_unit_index(const struct gl_context *ctx,
                   const struct gl_texture_object *tObj)
{
   const GLuint maxUnit
      = (ctx->Texture._EnabledCoordUnits > 1) ? ctx->Const.MaxTextureUnits : 1;
   GLuint u;

   /* XXX CoordUnits vs. ImageUnits */
   for (u = 0; u < maxUnit; u++) {
      if (ctx->Texture.Unit[u]._Current == tObj)
         break; /* found */
   }
   if (u >= maxUnit)
      u = 0; /* not found, use 1st one; should never happen */
   
   return u;
}


/**
 * Sample 2D texture using an anisotropic filter.
 * NOTE: the const GLfloat lambda_iso[] parameter does *NOT* contain
 * the lambda float array but a "hidden" SWspan struct which is required
 * by this function but is not available in the texture_sample_func signature.
 * See _swrast_texture_span( struct gl_context *ctx, SWspan *span ) on how
 * this function is called.
 */
static void
sample_lambda_2d_aniso(struct gl_context *ctx,
                       const struct gl_sampler_object *samp,
                       const struct gl_texture_object *tObj,
                       GLuint n, const GLfloat texcoords[][4],
                       const GLfloat lambda_iso[], GLfloat rgba[][4])
{
   const struct gl_texture_image *tImg = tObj->Image[0][tObj->BaseLevel];
   const struct swrast_texture_image *swImg = swrast_texture_image_const(tImg);
   const GLfloat maxEccentricity =
      samp->MaxAnisotropy * samp->MaxAnisotropy;
   
   /* re-calculate the lambda values so that they are usable with anisotropic
    * filtering
    */
   SWspan *span = (SWspan *)lambda_iso; /* access the "hidden" SWspan struct */

   /* based on interpolate_texcoords(struct gl_context *ctx, SWspan *span)
    * in swrast/s_span.c
    */
   
   /* find the texture unit index by looking up the current texture object
    * from the context list of available texture objects.
    */
   const GLuint u = texture_unit_index(ctx, tObj);
   const GLuint attr = VARYING_SLOT_TEX0 + u;
   GLfloat texW, texH;

   const GLfloat dsdx = span->attrStepX[attr][0];
   const GLfloat dsdy = span->attrStepY[attr][0];
   const GLfloat dtdx = span->attrStepX[attr][1];
   const GLfloat dtdy = span->attrStepY[attr][1];
   const GLfloat dqdx = span->attrStepX[attr][3];
   const GLfloat dqdy = span->attrStepY[attr][3];
   GLfloat s = span->attrStart[attr][0] + span->leftClip * dsdx;
   GLfloat t = span->attrStart[attr][1] + span->leftClip * dtdx;
   GLfloat q = span->attrStart[attr][3] + span->leftClip * dqdx;

   /* from swrast/s_texcombine.c _swrast_texture_span */
   const struct gl_texture_unit *texUnit = &ctx->Texture.Unit[u];
   const GLboolean adjustLOD =
      (texUnit->LodBias + samp->LodBias != 0.0F)
      || (samp->MinLod != -1000.0 || samp->MaxLod != 1000.0);

   GLuint i;
   
   /* on first access create the lookup table containing the filter weights. */
   if (!weightLut) {
      create_filter_table();
   }

   texW = swImg->WidthScale;
   texH = swImg->HeightScale;

   for (i = 0; i < n; i++) {
      const GLfloat invQ = (q == 0.0F) ? 1.0F : (1.0F / q);
      
      GLfloat dudx = texW * ((s + dsdx) / (q + dqdx) - s * invQ);
      GLfloat dvdx = texH * ((t + dtdx) / (q + dqdx) - t * invQ);
      GLfloat dudy = texW * ((s + dsdy) / (q + dqdy) - s * invQ);
      GLfloat dvdy = texH * ((t + dtdy) / (q + dqdy) - t * invQ);
      
      /* note: instead of working with Px and Py, we will use the 
       * squared length instead, to avoid sqrt.
       */
      GLfloat Px2 = dudx * dudx + dvdx * dvdx;
      GLfloat Py2 = dudy * dudy + dvdy * dvdy;

      GLfloat Pmax2;
      GLfloat Pmin2;
      GLfloat e;
      GLfloat lod;

      s += dsdx;
      t += dtdx;
      q += dqdx;
      
      if (Px2 < Py2) {
         Pmax2 = Py2;
         Pmin2 = Px2;
      }
      else {
         Pmax2 = Px2;
         Pmin2 = Py2;
      }
      
      /* if the eccentricity of the ellipse is too big, scale up the shorter
       * of the two vectors to limit the maximum amount of work per pixel
       */
      e = Pmax2 / Pmin2;
      if (e > maxEccentricity) {
         /* GLfloat s=e / maxEccentricity;
            minor[0] *= s;
            minor[1] *= s;
            Pmin2 *= s; */
         Pmin2 = Pmax2 / maxEccentricity;
      }
      
      /* note: we need to have Pmin=sqrt(Pmin2) here, but we can avoid
       * this since 0.5*log(x) = log(sqrt(x))
       */
      lod = 0.5f * LOG2(Pmin2);
      
      if (adjustLOD) {
         /* from swrast/s_texcombine.c _swrast_texture_span */
         if (texUnit->LodBias + samp->LodBias != 0.0F) {
            /* apply LOD bias, but don't clamp yet */
            const GLfloat bias =
               CLAMP(texUnit->LodBias + samp->LodBias,
                     -ctx->Const.MaxTextureLodBias,
                     ctx->Const.MaxTextureLodBias);
            lod += bias;

            if (samp->MinLod != -1000.0 ||
                samp->MaxLod != 1000.0) {
               /* apply LOD clamping to lambda */
               lod = CLAMP(lod, samp->MinLod, samp->MaxLod);
            }
         }
      }
      
      /* If the ellipse covers the whole image, we can
       * simply return the average of the whole image.
       */
      if (lod >= tObj->_MaxLevel) {
         sample_2d_linear(ctx, samp, tObj->Image[0][tObj->_MaxLevel],
                          texcoords[i], rgba[i]);
      }
      else {
         /* don't bother interpolating between multiple LODs; it doesn't
          * seem to be worth the extra running time.
          */
         sample_2d_ewa(ctx, samp, tObj, texcoords[i],
                       dudx, dvdx, dudy, dvdy, (GLint) floorf(lod), rgba[i]);

         /* unused: */
         (void) sample_2d_footprint;
         /*
         sample_2d_footprint(ctx, tObj, texcoords[i],
                             dudx, dvdx, dudy, dvdy, floor(lod), rgba[i]);
         */
d1543 1
a1543 1
static inline void
d1545 1
a1545 1
                  const struct gl_sampler_object *samp,
a1549 1
   const struct swrast_texture_image *swImg = swrast_texture_image_const(img);
d1556 3
a1558 3
   i = nearest_texel_location(samp->WrapS, img, width, texcoord[0]);
   j = nearest_texel_location(samp->WrapT, img, height, texcoord[1]);
   k = nearest_texel_location(samp->WrapR, img, depth, texcoord[2]);
d1564 1
a1564 1
      get_border_color(samp, img, rgba);
d1567 1
a1567 1
      swImg->FetchTexel(swImg, i, j, k, rgba);
d1577 1
a1577 1
                 const struct gl_sampler_object *samp,
a1581 1
   const struct swrast_texture_image *swImg = swrast_texture_image_const(img);
d1591 3
a1593 3
   linear_texel_locations(samp->WrapS, img, width, texcoord[0],  &i0, &i1, &a);
   linear_texel_locations(samp->WrapT, img, height, texcoord[1], &j0, &j1, &b);
   linear_texel_locations(samp->WrapR, img, depth, texcoord[2],  &k0, &k1, &c);
d1615 1
a1615 1
      get_border_color(samp, img, t000);
d1618 1
a1618 1
      swImg->FetchTexel(swImg, i0, j0, k0, t000);
d1621 1
a1621 1
      get_border_color(samp, img, t100);
d1624 1
a1624 1
      swImg->FetchTexel(swImg, i1, j0, k0, t100);
d1627 1
a1627 1
      get_border_color(samp, img, t010);
d1630 1
a1630 1
      swImg->FetchTexel(swImg, i0, j1, k0, t010);
d1633 1
a1633 1
      get_border_color(samp, img, t110);
d1636 1
a1636 1
      swImg->FetchTexel(swImg, i1, j1, k0, t110);
d1640 1
a1640 1
      get_border_color(samp, img, t001);
d1643 1
a1643 1
      swImg->FetchTexel(swImg, i0, j0, k1, t001);
d1646 1
a1646 1
      get_border_color(samp, img, t101);
d1649 1
a1649 1
      swImg->FetchTexel(swImg, i1, j0, k1, t101);
d1652 1
a1652 1
      get_border_color(samp, img, t011);
d1655 1
a1655 1
      swImg->FetchTexel(swImg, i0, j1, k1, t011);
d1658 1
a1658 1
      get_border_color(samp, img, t111);
d1661 1
a1661 1
      swImg->FetchTexel(swImg, i1, j1, k1, t111);
a1670 1
                                 const struct gl_sampler_object *samp,
d1678 1
a1678 1
      sample_3d_nearest(ctx, samp, tObj->Image[0][level], texcoord[i], rgba[i]);
a1684 1
                                const struct gl_sampler_object *samp,
d1693 1
a1693 1
      sample_3d_linear(ctx, samp, tObj->Image[0][level], texcoord[i], rgba[i]);
a1699 1
                                const struct gl_sampler_object *samp,
d1709 1
a1709 1
         sample_3d_nearest(ctx, samp, tObj->Image[0][tObj->_MaxLevel],
d1715 2
a1716 2
         sample_3d_nearest(ctx, samp, tObj->Image[0][level  ], texcoord[i], t0);
         sample_3d_nearest(ctx, samp, tObj->Image[0][level+1], texcoord[i], t1);
a1724 1
                               const struct gl_sampler_object *samp,
d1734 1
a1734 1
         sample_3d_linear(ctx, samp, tObj->Image[0][tObj->_MaxLevel],
d1740 2
a1741 2
         sample_3d_linear(ctx, samp, tObj->Image[0][level  ], texcoord[i], t0);
         sample_3d_linear(ctx, samp, tObj->Image[0][level+1], texcoord[i], t1);
a1750 1
                  const struct gl_sampler_object *samp,
d1759 1
a1759 1
      sample_3d_nearest(ctx, samp, image, texcoords[i], rgba[i]);
a1766 1
                 const struct gl_sampler_object *samp,
d1775 1
a1775 1
      sample_3d_linear(ctx, samp, image, texcoords[i], rgba[i]);
a1782 1
                 const struct gl_sampler_object *samp,
d1792 1
a1792 1
   compute_min_mag_ranges(samp, n, lambda,
d1798 1
a1798 1
      switch (samp->MinFilter) {
d1801 1
a1801 1
            sample_3d_nearest(ctx, samp, tObj->Image[0][tObj->BaseLevel],
d1806 1
a1806 1
            sample_3d_linear(ctx, samp, tObj->Image[0][tObj->BaseLevel],
d1810 1
a1810 1
         sample_3d_nearest_mipmap_nearest(ctx, samp, tObj, m, texcoords + minStart,
d1814 1
a1814 1
         sample_3d_linear_mipmap_nearest(ctx, samp, tObj, m, texcoords + minStart,
d1818 1
a1818 1
         sample_3d_nearest_mipmap_linear(ctx, samp, tObj, m, texcoords + minStart,
d1822 1
a1822 1
         sample_3d_linear_mipmap_linear(ctx, samp, tObj, m, texcoords + minStart,
d1833 1
a1833 1
      switch (samp->MagFilter) {
d1836 1
a1836 1
            sample_3d_nearest(ctx, samp, tObj->Image[0][tObj->BaseLevel],
d1841 1
a1841 1
            sample_3d_linear(ctx, samp, tObj->Image[0][tObj->BaseLevel],
a1937 1
                    const struct gl_sampler_object *samp,
d1948 1
a1948 1
      sample_2d_nearest(ctx, samp, images[tObj->BaseLevel],
a1950 5
   if (is_depth_texture(tObj)) {
      for (i = 0; i < n; i++) {
         apply_depth_mode(tObj->DepthMode, rgba[i][0], rgba[i]);
      }
   }
a1955 1
                   const struct gl_sampler_object *samp,
d1966 1
a1966 1
      sample_2d_linear(ctx, samp, images[tObj->BaseLevel],
a1968 5
   if (is_depth_texture(tObj)) {
      for (i = 0; i < n; i++) {
         apply_depth_mode(tObj->DepthMode, rgba[i][0], rgba[i]);
      }
   }
a1973 1
                                   const struct gl_sampler_object *samp,
d1996 1
a1996 6
      sample_2d_nearest(ctx, samp, images[level], newCoord, rgba[i]);
   }
   if (is_depth_texture(tObj)) {
      for (i = 0; i < n; i++) {
         apply_depth_mode(tObj->DepthMode, rgba[i][0], rgba[i]);
      }
a2002 1
                                  const struct gl_sampler_object *samp,
d2015 1
a2015 6
      sample_2d_linear(ctx, samp, images[level], newCoord, rgba[i]);
   }
   if (is_depth_texture(tObj)) {
      for (i = 0; i < n; i++) {
         apply_depth_mode(tObj->DepthMode, rgba[i][0], rgba[i]);
      }
a2021 1
                                  const struct gl_sampler_object *samp,
d2035 1
a2035 1
         sample_2d_nearest(ctx, samp, images[tObj->_MaxLevel],
d2041 2
a2042 2
         sample_2d_nearest(ctx, samp, images[level  ], newCoord, t0);
         sample_2d_nearest(ctx, samp, images[level+1], newCoord, t1);
a2045 5
   if (is_depth_texture(tObj)) {
      for (i = 0; i < n; i++) {
         apply_depth_mode(tObj->DepthMode, rgba[i][0], rgba[i]);
      }
   }
a2050 1
                                 const struct gl_sampler_object *samp,
d2064 1
a2064 1
         sample_2d_linear(ctx, samp, images[tObj->_MaxLevel],
d2070 2
a2071 2
         sample_2d_linear(ctx, samp, images[level  ], newCoord, t0);
         sample_2d_linear(ctx, samp, images[level+1], newCoord, t1);
a2074 5
   if (is_depth_texture(tObj)) {
      for (i = 0; i < n; i++) {
         apply_depth_mode(tObj->DepthMode, rgba[i][0], rgba[i]);
      }
   }
a2080 1
                   const struct gl_sampler_object *samp,
d2089 1
a2089 1
   compute_min_mag_ranges(samp, n, lambda,
d2095 1
a2095 1
      switch (samp->MinFilter) {
d2097 1
a2097 1
         sample_nearest_cube(ctx, samp, tObj, m, texcoords + minStart,
d2101 1
a2101 1
         sample_linear_cube(ctx, samp, tObj, m, texcoords + minStart,
d2105 1
a2105 1
         sample_cube_nearest_mipmap_nearest(ctx, samp, tObj, m,
d2110 1
a2110 1
         sample_cube_linear_mipmap_nearest(ctx, samp, tObj, m,
d2115 1
a2115 1
         sample_cube_nearest_mipmap_linear(ctx, samp, tObj, m,
d2120 1
a2120 1
         sample_cube_linear_mipmap_linear(ctx, samp, tObj, m,
a2125 1
         break;
d2132 1
a2132 1
      switch (samp->MagFilter) {
d2134 1
a2134 1
         sample_nearest_cube(ctx, samp, tObj, m, texcoords + magStart,
d2138 1
a2138 1
         sample_linear_cube(ctx, samp, tObj, m, texcoords + magStart,
a2142 1
         break;
a2154 1
                    const struct gl_sampler_object *samp,
a2159 1
   const struct swrast_texture_image *swImg = swrast_texture_image_const(img);
d2167 7
a2173 6
   ASSERT(samp->WrapS == GL_CLAMP ||
          samp->WrapS == GL_CLAMP_TO_EDGE ||
          samp->WrapS == GL_CLAMP_TO_BORDER);
   ASSERT(samp->WrapT == GL_CLAMP ||
          samp->WrapT == GL_CLAMP_TO_EDGE ||
          samp->WrapT == GL_CLAMP_TO_BORDER);
d2177 2
a2178 2
      col = clamp_rect_coord_nearest(samp->WrapS, texcoords[i][0], width);
      row = clamp_rect_coord_nearest(samp->WrapT, texcoords[i][1], height);
d2180 1
a2180 1
         get_border_color(samp, img, rgba[i]);
d2182 1
a2182 1
         swImg->FetchTexel(swImg, col, row, 0, rgba[i]);
a2188 1
                   const struct gl_sampler_object *samp,
a2193 1
   const struct swrast_texture_image *swImg = swrast_texture_image_const(img);
d2201 7
a2207 6
   ASSERT(samp->WrapS == GL_CLAMP ||
          samp->WrapS == GL_CLAMP_TO_EDGE ||
          samp->WrapS == GL_CLAMP_TO_BORDER);
   ASSERT(samp->WrapT == GL_CLAMP ||
          samp->WrapT == GL_CLAMP_TO_EDGE ||
          samp->WrapT == GL_CLAMP_TO_BORDER);
d2215 1
a2215 1
      clamp_rect_coord_linear(samp->WrapS, texcoords[i][0], width,
d2217 1
a2217 1
      clamp_rect_coord_linear(samp->WrapT, texcoords[i][1], height,
d2228 1
a2228 1
         get_border_color(samp, img, t00);
d2230 1
a2230 1
         swImg->FetchTexel(swImg, i0, j0, 0, t00);
d2233 1
a2233 1
         get_border_color(samp, img, t10);
d2235 1
a2235 1
         swImg->FetchTexel(swImg, i1, j0, 0, t10);
d2238 1
a2238 1
         get_border_color(samp, img, t01);
d2240 1
a2240 1
         swImg->FetchTexel(swImg, i0, j1, 0, t01);
d2243 1
a2243 1
         get_border_color(samp, img, t11);
d2245 1
a2245 1
         swImg->FetchTexel(swImg, i1, j1, 0, t11);
a2254 1
                   const struct gl_sampler_object *samp,
d2264 1
a2264 1
   compute_min_mag_ranges(samp, n, lambda,
d2268 2
a2269 2
      if (samp->MinFilter == GL_NEAREST) {
         sample_nearest_rect(ctx, samp, tObj, minEnd - minStart,
d2273 1
a2273 1
         sample_linear_rect(ctx, samp, tObj, minEnd - minStart,
d2278 2
a2279 2
      if (samp->MagFilter == GL_NEAREST) {
         sample_nearest_rect(ctx, samp, tObj, magEnd - magStart,
d2283 1
a2283 1
         sample_linear_rect(ctx, samp, tObj, magEnd - magStart,
d2299 1
a2299 1
                        const struct gl_sampler_object *samp,
a2303 1
   const struct swrast_texture_image *swImg = swrast_texture_image_const(img);
d2311 2
a2312 2
   i = nearest_texel_location(samp->WrapS, img, width, texcoord[0]);
   j = nearest_texel_location(samp->WrapT, img, height, texcoord[1]);
d2319 1
a2319 1
      get_border_color(samp, img, rgba);
d2322 1
a2322 1
      swImg->FetchTexel(swImg, i, j, array, rgba);
d2332 1
a2332 1
                       const struct gl_sampler_object *samp,
a2336 1
   const struct swrast_texture_image *swImg = swrast_texture_image_const(img);
d2346 2
a2347 2
   linear_texel_locations(samp->WrapS, img, width,  texcoord[0], &i0, &i1, &a);
   linear_texel_locations(samp->WrapT, img, height, texcoord[1], &j0, &j1, &b);
d2351 1
a2351 1
      COPY_4V(rgba, samp->BorderColor.f);
d2370 1
a2370 1
         get_border_color(samp, img, t00);
d2373 1
a2373 1
	 swImg->FetchTexel(swImg, i0, j0, array, t00);
d2376 1
a2376 1
         get_border_color(samp, img, t10);
d2379 1
a2379 1
	 swImg->FetchTexel(swImg, i1, j0, array, t10);
d2382 1
a2382 1
         get_border_color(samp, img, t01);
d2385 1
a2385 1
	 swImg->FetchTexel(swImg, i0, j1, array, t01);
d2388 1
a2388 1
         get_border_color(samp, img, t11);
d2391 1
a2391 1
	 swImg->FetchTexel(swImg, i1, j1, array, t11);
a2401 1
                                       const struct gl_sampler_object *samp,
d2409 1
a2409 1
      sample_2d_array_nearest(ctx, samp, tObj->Image[0][level], texcoord[i],
a2416 1
                                      const struct gl_sampler_object *samp,
d2425 1
a2425 1
      sample_2d_array_linear(ctx, samp, tObj->Image[0][level],
a2432 1
                                      const struct gl_sampler_object *samp,
d2442 1
a2442 1
         sample_2d_array_nearest(ctx, samp, tObj->Image[0][tObj->_MaxLevel],
d2448 1
a2448 1
         sample_2d_array_nearest(ctx, samp, tObj->Image[0][level  ],
d2450 1
a2450 1
         sample_2d_array_nearest(ctx, samp, tObj->Image[0][level+1],
a2459 1
                                     const struct gl_sampler_object *samp,
d2469 1
a2469 1
         sample_2d_array_linear(ctx, samp, tObj->Image[0][tObj->_MaxLevel],
d2475 1
a2475 1
         sample_2d_array_linear(ctx, samp, tObj->Image[0][level  ],
d2477 1
a2477 1
         sample_2d_array_linear(ctx, samp, tObj->Image[0][level+1],
a2487 1
                        const struct gl_sampler_object *samp,
d2496 1
a2496 1
      sample_2d_array_nearest(ctx, samp, image, texcoords[i], rgba[i]);
a2504 1
                       const struct gl_sampler_object *samp,
d2513 1
a2513 1
      sample_2d_array_linear(ctx, samp, image, texcoords[i], rgba[i]);
a2520 1
                       const struct gl_sampler_object *samp,
d2530 1
a2530 1
   compute_min_mag_ranges(samp, n, lambda,
d2536 1
a2536 1
      switch (samp->MinFilter) {
d2539 1
a2539 1
            sample_2d_array_nearest(ctx, samp, tObj->Image[0][tObj->BaseLevel],
d2544 1
a2544 1
            sample_2d_array_linear(ctx, samp, tObj->Image[0][tObj->BaseLevel],
d2548 1
a2548 1
         sample_2d_array_nearest_mipmap_nearest(ctx, samp, tObj, m,
d2554 1
a2554 1
         sample_2d_array_linear_mipmap_nearest(ctx, samp, tObj, m,
d2560 1
a2560 1
         sample_2d_array_nearest_mipmap_linear(ctx, samp, tObj, m,
d2566 1
a2566 1
         sample_2d_array_linear_mipmap_linear(ctx, samp, tObj, m,
d2579 1
a2579 1
      switch (samp->MagFilter) {
d2582 1
a2582 1
            sample_2d_array_nearest(ctx, samp, tObj->Image[0][tObj->BaseLevel],
d2587 1
a2587 1
            sample_2d_array_linear(ctx, samp, tObj->Image[0][tObj->BaseLevel],
d2609 1
a2609 1
                        const struct gl_sampler_object *samp,
a2613 1
   const struct swrast_texture_image *swImg = swrast_texture_image_const(img);
d2620 1
a2620 1
   i = nearest_texel_location(samp->WrapS, img, width, texcoord[0]);
d2626 1
a2626 1
      get_border_color(samp, img, rgba);
d2629 1
a2629 1
      swImg->FetchTexel(swImg, i, array, 0, rgba);
d2639 1
a2639 1
                       const struct gl_sampler_object *samp,
a2643 1
   const struct swrast_texture_image *swImg = swrast_texture_image_const(img);
d2652 1
a2652 1
   linear_texel_locations(samp->WrapS, img, width, texcoord[0], &i0, &i1, &a);
d2669 1
a2669 1
      get_border_color(samp, img, t0);
d2672 1
a2672 1
      swImg->FetchTexel(swImg, i0, array, 0, t0);
d2675 1
a2675 1
      get_border_color(samp, img, t1);
d2678 1
a2678 1
      swImg->FetchTexel(swImg, i1, array, 0, t1);
a2687 1
                                       const struct gl_sampler_object *samp,
d2695 1
a2695 1
      sample_1d_array_nearest(ctx, samp, tObj->Image[0][level], texcoord[i],
a2702 1
                                      const struct gl_sampler_object *samp,
d2711 1
a2711 1
      sample_1d_array_linear(ctx, samp, tObj->Image[0][level],
a2718 1
                                      const struct gl_sampler_object *samp,
d2728 1
a2728 1
         sample_1d_array_nearest(ctx, samp, tObj->Image[0][tObj->_MaxLevel],
d2734 2
a2735 2
         sample_1d_array_nearest(ctx, samp, tObj->Image[0][level  ], texcoord[i], t0);
         sample_1d_array_nearest(ctx, samp, tObj->Image[0][level+1], texcoord[i], t1);
a2743 1
                                     const struct gl_sampler_object *samp,
d2753 1
a2753 1
         sample_1d_array_linear(ctx, samp, tObj->Image[0][tObj->_MaxLevel],
d2759 2
a2760 2
         sample_1d_array_linear(ctx, samp, tObj->Image[0][level  ], texcoord[i], t0);
         sample_1d_array_linear(ctx, samp, tObj->Image[0][level+1], texcoord[i], t1);
a2769 1
                        const struct gl_sampler_object *samp,
d2778 1
a2778 1
      sample_1d_array_nearest(ctx, samp, image, texcoords[i], rgba[i]);
a2785 1
                       const struct gl_sampler_object *samp,
d2794 1
a2794 1
      sample_1d_array_linear(ctx, samp, image, texcoords[i], rgba[i]);
a2801 1
                       const struct gl_sampler_object *samp,
d2811 1
a2811 1
   compute_min_mag_ranges(samp, n, lambda,
d2817 1
a2817 1
      switch (samp->MinFilter) {
d2820 1
a2820 1
            sample_1d_array_nearest(ctx, samp, tObj->Image[0][tObj->BaseLevel],
d2825 1
a2825 1
            sample_1d_array_linear(ctx, samp, tObj->Image[0][tObj->BaseLevel],
d2829 1
a2829 1
         sample_1d_array_nearest_mipmap_nearest(ctx, samp, tObj, m, texcoords + minStart,
d2833 1
a2833 1
         sample_1d_array_linear_mipmap_nearest(ctx, samp, tObj, m, 
d2839 1
a2839 1
         sample_1d_array_nearest_mipmap_linear(ctx, samp, tObj, m, texcoords + minStart,
d2843 1
a2843 1
         sample_1d_array_linear_mipmap_linear(ctx, samp, tObj, m, 
d2856 1
a2856 1
      switch (samp->MagFilter) {
d2859 1
a2859 1
            sample_1d_array_nearest(ctx, samp, tObj->Image[0][tObj->BaseLevel],
d2864 1
a2864 1
            sample_1d_array_linear(ctx, samp, tObj->Image[0][tObj->BaseLevel],
d2876 1
a2876 1
 * Compare texcoord against depth sample.  Return 1.0 or 0.0 value.
d2878 3
a2880 2
static inline GLfloat
shadow_compare(GLenum function, GLfloat coord, GLfloat depthSample)
d2884 1
a2884 1
      return (coord <= depthSample) ? 1.0F : 0.0F;
d2886 1
a2886 1
      return (coord >= depthSample) ? 1.0F : 0.0F;
d2888 1
a2888 1
      return (coord < depthSample) ? 1.0F : 0.0F;
d2890 1
a2890 1
      return (coord > depthSample) ? 1.0F : 0.0F;
d2892 1
a2892 1
      return (coord == depthSample) ? 1.0F : 0.0F;
d2894 1
a2894 1
      return (coord != depthSample) ? 1.0F : 0.0F;
d2898 1
a2898 1
      return 0.0F;
d2903 1
a2903 1
      return 0.0F;
d2911 1
a2911 1
static inline GLfloat
d2915 1
a2915 1
                GLfloat wi, GLfloat wj)
d2917 1
a2917 1
   const GLfloat d = 0.25F;
d2922 4
a2925 4
      if (coord > depth00)  luminance -= d;
      if (coord > depth01)  luminance -= d;
      if (coord > depth10)  luminance -= d;
      if (coord > depth11)  luminance -= d;
d2928 4
a2931 4
      if (coord < depth00)  luminance -= d;
      if (coord < depth01)  luminance -= d;
      if (coord < depth10)  luminance -= d;
      if (coord < depth11)  luminance -= d;
d2934 4
a2937 4
      if (coord >= depth00)  luminance -= d;
      if (coord >= depth01)  luminance -= d;
      if (coord >= depth10)  luminance -= d;
      if (coord >= depth11)  luminance -= d;
d2940 4
a2943 4
      if (coord <= depth00)  luminance -= d;
      if (coord <= depth01)  luminance -= d;
      if (coord <= depth10)  luminance -= d;
      if (coord <= depth11)  luminance -= d;
d2946 4
a2949 4
      if (coord != depth00)  luminance -= d;
      if (coord != depth01)  luminance -= d;
      if (coord != depth10)  luminance -= d;
      if (coord != depth11)  luminance -= d;
d2952 4
a2955 4
      if (coord == depth00)  luminance -= d;
      if (coord == depth01)  luminance -= d;
      if (coord == depth10)  luminance -= d;
      if (coord == depth11)  luminance -= d;
d2958 1
a2958 1
      return 1.0F;
d2960 1
a2960 1
      return 0.0F;
d2965 1
a2965 1
      _mesa_problem(NULL, "Bad compare func in sample_compare4");
d2975 1
a2975 2
choose_depth_texture_level(const struct gl_sampler_object *samp,
                           const struct gl_texture_object *tObj, GLfloat lambda)
d2979 1
a2979 1
   if (samp->MinFilter == GL_NEAREST || samp->MinFilter == GL_LINEAR) {
d2985 1
a2985 1
      lambda = CLAMP(lambda, samp->MinLod, samp->MaxLod);
a2999 1
                      const struct gl_sampler_object *samp,
d3004 1
a3004 1
   const GLint level = choose_depth_texture_level(samp, tObj, lambda[0]);
a3005 1
   const struct swrast_texture_image *swImg = swrast_texture_image_const(img);
d3011 1
d3022 3
a3024 2
          tObj->Target == GL_TEXTURE_2D_ARRAY_EXT ||
          tObj->Target == GL_TEXTURE_CUBE_MAP);
d3026 1
a3026 1
   /* XXXX if samp->MinFilter != samp->MagFilter, we're ignoring lambda */
d3028 2
a3029 2
   function = (samp->CompareMode == GL_COMPARE_R_TO_TEXTURE_ARB) ?
      samp->CompareFunc : GL_NONE;
d3031 1
a3031 1
   if (samp->MagFilter == GL_NEAREST) {
d3034 1
a3034 1
         GLfloat depthSample, depthRef;
d3037 1
a3037 1
         nearest_texcoord(samp, tObj, level, texcoords[i], &col, &row, &slice);
d3041 1
a3041 1
            swImg->FetchTexel(swImg, col, row, slice, &depthSample);
d3044 1
a3044 1
            depthSample = samp->BorderColor.f[0];
d3047 2
a3048 1
         depthRef = CLAMP(texcoords[i][compare_coord], 0.0F, 1.0F);
d3050 16
a3065 3
         result = shadow_compare(function, depthRef, depthSample);

         apply_depth_mode(tObj->DepthMode, result, texel[i]);
d3070 1
a3070 1
      ASSERT(samp->MagFilter == GL_LINEAR);
d3072 1
a3072 1
         GLfloat depth00, depth01, depth10, depth11, depthRef;
d3078 1
a3078 1
         linear_texcoord(samp, tObj, level, texcoords[i], &i0, &i1, &j0, &j1, &slice,
d3098 4
a3101 4
            depth00 = samp->BorderColor.f[0];
            depth01 = samp->BorderColor.f[0];
            depth10 = samp->BorderColor.f[0];
            depth11 = samp->BorderColor.f[0];
d3106 1
a3106 1
               depth00 = samp->BorderColor.f[0];
d3109 1
a3109 1
               swImg->FetchTexel(swImg, i0, j0, slice, &depth00);
d3112 1
a3112 1
               depth10 = samp->BorderColor.f[0];
d3115 1
a3115 1
               swImg->FetchTexel(swImg, i1, j0, slice, &depth10);
d3120 1
a3120 1
                  depth01 = samp->BorderColor.f[0];
d3123 1
a3123 1
                  swImg->FetchTexel(swImg, i0, j1, slice, &depth01);
d3126 1
a3126 1
                  depth11 = samp->BorderColor.f[0];
d3129 1
a3129 1
                  swImg->FetchTexel(swImg, i1, j1, slice, &depth11);
d3138 3
a3140 1
         depthRef = CLAMP(texcoords[i][compare_coord], 0.0F, 1.0F);
d3142 13
a3154 3
         result = shadow_compare4(function, depthRef,
                                  depth00, depth01, depth10, depth11,
                                  wi, wj);
a3155 1
         apply_depth_mode(tObj->DepthMode, result, texel[i]);
a3168 1
                  const struct gl_sampler_object *samp,
a3177 1
   (void) samp;
d3192 1
a3192 2
				    const struct gl_texture_object *t,
                                    const struct gl_sampler_object *sampler)
d3194 1
a3194 1
   if (!t || !_mesa_is_texture_complete(t, sampler)) {
d3198 2
a3199 2
      const GLboolean needLambda =
         (GLboolean) (sampler->MinFilter != sampler->MagFilter);
d3203 1
a3203 1
         if (is_depth_texture(t)) {
d3209 1
a3209 1
         else if (sampler->MinFilter == GL_LINEAR) {
d3213 1
a3213 1
            ASSERT(sampler->MinFilter == GL_NEAREST);
d3217 1
a3217 1
         if (is_depth_texture(t)) {
a3220 5
            /* Anisotropic filtering extension. Activated only if mipmaps are used */
            if (sampler->MaxAnisotropy > 1.0 &&
                sampler->MinFilter == GL_LINEAR_MIPMAP_LINEAR) {
               return &sample_lambda_2d_aniso;
            }
d3223 1
a3223 1
         else if (sampler->MinFilter == GL_LINEAR) {
d3229 17
a3245 14
            const struct swrast_texture_image *swImg =
               swrast_texture_image_const(img);
            texture_sample_func func;

            ASSERT(sampler->MinFilter == GL_NEAREST);
            func = &sample_nearest_2d;
            if (sampler->WrapS == GL_REPEAT &&
                sampler->WrapT == GL_REPEAT &&
                swImg->_IsPowerOfTwo &&
                img->Border == 0) {
               if (img->TexFormat == MESA_FORMAT_RGB888)
                  func = &opt_sample_rgb_2d;
               else if (img->TexFormat == MESA_FORMAT_RGBA8888)
                  func = &opt_sample_rgba_2d;
a3246 2

            return func;
d3252 1
a3252 1
         else if (sampler->MinFilter == GL_LINEAR) {
d3256 1
a3256 1
            ASSERT(sampler->MinFilter == GL_NEAREST);
d3263 1
a3263 1
         else if (sampler->MinFilter == GL_LINEAR) {
d3267 1
a3267 1
            ASSERT(sampler->MinFilter == GL_NEAREST);
d3271 1
a3271 1
         if (is_depth_texture(t)) {
d3277 1
a3277 1
         else if (sampler->MinFilter == GL_LINEAR) {
d3281 1
a3281 1
            ASSERT(sampler->MinFilter == GL_NEAREST);
d3285 1
a3285 4
         if (is_depth_texture(t)) {
            return &sample_depth_texture;
         }
	 else if (needLambda) {
d3288 1
a3288 1
         else if (sampler->MinFilter == GL_LINEAR) {
d3292 1
a3292 1
            ASSERT(sampler->MinFilter == GL_NEAREST);
d3296 1
a3296 4
         if (is_depth_texture(t)) {
            return &sample_depth_texture;
         }
	 else if (needLambda) {
d3299 1
a3299 1
         else if (sampler->MinFilter == GL_LINEAR) {
d3303 1
a3303 1
            ASSERT(sampler->MinFilter == GL_NEAREST);
@


1.1.1.6
log
@Import Mesa 10.2.3
@
text
@a276 1
      *i0 = *i1 = 0;
d1430 1
a1430 1
   ASSERT(img->TexFormat == MESA_FORMAT_BGR_UNORM8);
d1475 1
a1475 1
   ASSERT(img->TexFormat == MESA_FORMAT_A8B8G8R8_UNORM);
d1523 1
a1523 1
            case MESA_FORMAT_BGR_UNORM8:
d1527 1
a1527 1
            case MESA_FORMAT_A8B8G8R8_UNORM:
d1580 1
a1580 1
            case MESA_FORMAT_BGR_UNORM8:
d1584 1
a1584 1
            case MESA_FORMAT_A8B8G8R8_UNORM:
d3762 1
a3762 1
               if (img->TexFormat == MESA_FORMAT_BGR_UNORM8)
d3764 1
a3764 1
               else if (img->TexFormat == MESA_FORMAT_A8B8G8R8_UNORM)
@


1.1.1.7
log
@Import Mesa 10.4.3
@
text
@d807 1
a807 1
static inline void
@


1.1.1.8
log
@Import Mesa 10.2.9
@
text
@d807 1
a807 1
static INLINE void
@


