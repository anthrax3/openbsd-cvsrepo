head	1.10;
access;
symbols
	OPENBSD_5_8:1.9.0.6
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.4
	OPENBSD_5_7_BASE:1.9
	v10_2_9:1.1.1.6
	v10_4_3:1.1.1.6
	v10_2_7:1.1.1.6
	OPENBSD_5_6:1.9.0.2
	OPENBSD_5_6_BASE:1.9
	v10_2_3:1.1.1.6
	OPENBSD_5_5:1.8.0.2
	OPENBSD_5_5_BASE:1.8
	v9_2_5:1.1.1.5
	v9_2_3:1.1.1.5
	v9_2_2:1.1.1.5
	v9_2_1:1.1.1.5
	v9_2_0:1.1.1.5
	OPENBSD_5_4:1.7.0.4
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.6.0.4
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.5.0.6
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2015.12.23.05.17.55;	author jsg;	state dead;
branches;
next	1.9;
commitid	TnlogFl9nOv2eaRf;

1.9
date	2014.07.09.21.09.01;	author jsg;	state Exp;
branches;
next	1.8;
commitid	WPD6rgPryPkvXOr9;

1.8
date	2013.09.05.14.06.49;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2012.08.17.13.58.20;	author mpi;	state Exp;
branches;
next	1.6;

1.6
date	2011.10.23.13.37.45;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.05.22.20.06.34;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.05.17.20.26.42;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.14.58.23;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.05.31.16.36.49;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.51.19;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.51.19;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.56.50;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.32.08;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.48;	author matthieu;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.09.05.13.17.30;	author jsg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.07.09.20.35.12;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.10
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */


#include "main/glheader.h"
#include "main/bufferobj.h"
#include "main/colormac.h"
#include "main/condrender.h"
#include "main/context.h"
#include "main/format_pack.h"
#include "main/image.h"
#include "main/imports.h"
#include "main/macros.h"
#include "main/pack.h"
#include "main/pbo.h"
#include "main/pixeltransfer.h"
#include "main/state.h"

#include "s_context.h"
#include "s_span.h"
#include "s_stencil.h"
#include "s_zoom.h"


/**
 * Handle a common case of drawing GL_RGB/GL_UNSIGNED_BYTE into a
 * MESA_FORMAT_XRGB888 or MESA_FORMAT_ARGB888 renderbuffer.
 */
static void
fast_draw_rgb_ubyte_pixels(struct gl_context *ctx,
                           struct gl_renderbuffer *rb,
                           GLint x, GLint y,
                           GLsizei width, GLsizei height,
                           const struct gl_pixelstore_attrib *unpack,
                           const GLvoid *pixels)
{
   const GLubyte *src = (const GLubyte *)
      _mesa_image_address2d(unpack, pixels, width,
                            height, GL_RGB, GL_UNSIGNED_BYTE, 0, 0);
   const GLint srcRowStride = _mesa_image_row_stride(unpack, width,
                                                     GL_RGB, GL_UNSIGNED_BYTE);
   GLint i, j;
   GLubyte *dst;
   GLint dstRowStride;

   ctx->Driver.MapRenderbuffer(ctx, rb, x, y, width, height,
                               GL_MAP_WRITE_BIT, &dst, &dstRowStride);

   if (!dst) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glDrawPixels");
      return;
   }

   if (ctx->Pixel.ZoomY == -1.0f) {
      dst = dst + (height - 1) * dstRowStride;
      dstRowStride = -dstRowStride;
   }

   for (i = 0; i < height; i++) {
      GLuint *dst4 = (GLuint *) dst;
      for (j = 0; j < width; j++) {
         dst4[j] = PACK_COLOR_8888(0xff, src[j*3+0], src[j*3+1], src[j*3+2]);
      }
      dst += dstRowStride;
      src += srcRowStride;
   }

   ctx->Driver.UnmapRenderbuffer(ctx, rb);
}


/**
 * Handle a common case of drawing GL_RGBA/GL_UNSIGNED_BYTE into a
 * MESA_FORMAT_ARGB888 or MESA_FORMAT_xRGB888 renderbuffer.
 */
static void
fast_draw_rgba_ubyte_pixels(struct gl_context *ctx,
                           struct gl_renderbuffer *rb,
                           GLint x, GLint y,
                           GLsizei width, GLsizei height,
                           const struct gl_pixelstore_attrib *unpack,
                           const GLvoid *pixels)
{
   const GLubyte *src = (const GLubyte *)
      _mesa_image_address2d(unpack, pixels, width,
                            height, GL_RGBA, GL_UNSIGNED_BYTE, 0, 0);
   const GLint srcRowStride =
      _mesa_image_row_stride(unpack, width, GL_RGBA, GL_UNSIGNED_BYTE);
   GLint i, j;
   GLubyte *dst;
   GLint dstRowStride;

   ctx->Driver.MapRenderbuffer(ctx, rb, x, y, width, height,
                               GL_MAP_WRITE_BIT, &dst, &dstRowStride);

   if (!dst) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glDrawPixels");
      return;
   }

   if (ctx->Pixel.ZoomY == -1.0f) {
      dst = dst + (height - 1) * dstRowStride;
      dstRowStride = -dstRowStride;
   }

   for (i = 0; i < height; i++) {
      GLuint *dst4 = (GLuint *) dst;
      for (j = 0; j < width; j++) {
         dst4[j] = PACK_COLOR_8888(src[j*4+3], src[j*4+0],
                                   src[j*4+1], src[j*4+2]);
      }
      dst += dstRowStride;
      src += srcRowStride;
   }

   ctx->Driver.UnmapRenderbuffer(ctx, rb);
}


/**
 * Handle a common case of drawing a format/type combination that
 * exactly matches the renderbuffer format.
 */
static void
fast_draw_generic_pixels(struct gl_context *ctx,
                         struct gl_renderbuffer *rb,
                         GLint x, GLint y,
                         GLsizei width, GLsizei height,
                         GLenum format, GLenum type,
                         const struct gl_pixelstore_attrib *unpack,
                         const GLvoid *pixels)
{
   const GLubyte *src = (const GLubyte *)
      _mesa_image_address2d(unpack, pixels, width,
                            height, format, type, 0, 0);
   const GLint srcRowStride =
      _mesa_image_row_stride(unpack, width, format, type);
   const GLint rowLength = width * _mesa_get_format_bytes(rb->Format);
   GLint i;
   GLubyte *dst;
   GLint dstRowStride;

   ctx->Driver.MapRenderbuffer(ctx, rb, x, y, width, height,
                               GL_MAP_WRITE_BIT, &dst, &dstRowStride);

   if (!dst) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glDrawPixels");
      return;
   }

   if (ctx->Pixel.ZoomY == -1.0f) {
      dst = dst + (height - 1) * dstRowStride;
      dstRowStride = -dstRowStride;
   }

   for (i = 0; i < height; i++) {
      memcpy(dst, src, rowLength);
      dst += dstRowStride;
      src += srcRowStride;
   }

   ctx->Driver.UnmapRenderbuffer(ctx, rb);
}


/**
 * Try to do a fast and simple RGB(a) glDrawPixels.
 * Return:  GL_TRUE if success, GL_FALSE if slow path must be used instead
 */
static GLboolean
fast_draw_rgba_pixels(struct gl_context *ctx, GLint x, GLint y,
                      GLsizei width, GLsizei height,
                      GLenum format, GLenum type,
                      const struct gl_pixelstore_attrib *userUnpack,
                      const GLvoid *pixels)
{
   struct gl_renderbuffer *rb = ctx->DrawBuffer->_ColorDrawBuffers[0];
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
   struct gl_pixelstore_attrib unpack;

   if (!rb)
      return GL_TRUE; /* no-op */

   if (ctx->DrawBuffer->_NumColorDrawBuffers > 1 ||
       (swrast->_RasterMask & ~CLIP_BIT) ||
       ctx->Texture._EnabledCoordUnits ||
       userUnpack->SwapBytes ||
       ctx->Pixel.ZoomX != 1.0f ||
       fabsf(ctx->Pixel.ZoomY) != 1.0f ||
       ctx->_ImageTransferState) {
      /* can't handle any of those conditions */
      return GL_FALSE;
   }

   unpack = *userUnpack;

   /* clipping */
   if (!_mesa_clip_drawpixels(ctx, &x, &y, &width, &height, &unpack)) {
      /* image was completely clipped: no-op, all done */
      return GL_TRUE;
   }

   if (format == GL_RGB &&
       type == GL_UNSIGNED_BYTE &&
       (rb->Format == MESA_FORMAT_B8G8R8X8_UNORM ||
        rb->Format == MESA_FORMAT_B8G8R8A8_UNORM)) {
      fast_draw_rgb_ubyte_pixels(ctx, rb, x, y, width, height,
                                 &unpack, pixels);
      return GL_TRUE;
   }

   if (format == GL_RGBA &&
       type == GL_UNSIGNED_BYTE &&
       (rb->Format == MESA_FORMAT_B8G8R8X8_UNORM ||
        rb->Format == MESA_FORMAT_B8G8R8A8_UNORM)) {
      fast_draw_rgba_ubyte_pixels(ctx, rb, x, y, width, height,
                                  &unpack, pixels);
      return GL_TRUE;
   }

   if (_mesa_format_matches_format_and_type(rb->Format, format, type,
                                            ctx->Unpack.SwapBytes)) {
      fast_draw_generic_pixels(ctx, rb, x, y, width, height,
                               format, type, &unpack, pixels);
      return GL_TRUE;
   }

   /* can't handle this pixel format and/or data type */
   return GL_FALSE;
}



/*
 * Draw stencil image.
 */
static void
draw_stencil_pixels( struct gl_context *ctx, GLint x, GLint y,
                     GLsizei width, GLsizei height,
                     GLenum type,
                     const struct gl_pixelstore_attrib *unpack,
                     const GLvoid *pixels )
{
   const GLboolean zoom = ctx->Pixel.ZoomX != 1.0 || ctx->Pixel.ZoomY != 1.0;
   const GLenum destType = GL_UNSIGNED_BYTE;
   GLint row;
   GLubyte *values;

   values = malloc(width * sizeof(GLubyte));
   if (!values) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glDrawPixels");
      return;
   }

   for (row = 0; row < height; row++) {
      const GLvoid *source = _mesa_image_address2d(unpack, pixels,
                                                   width, height,
                                                   GL_STENCIL_INDEX, type,
                                                   row, 0);
      _mesa_unpack_stencil_span(ctx, width, destType, values,
                                type, source, unpack,
                                ctx->_ImageTransferState);
      if (zoom) {
         _swrast_write_zoomed_stencil_span(ctx, x, y, width,
                                           x, y, values);
      }
      else {
         _swrast_write_stencil_span(ctx, width, x, y, values);
      }

      y++;
   }

   free(values);
}


/*
 * Draw depth image.
 */
static void
draw_depth_pixels( struct gl_context *ctx, GLint x, GLint y,
                   GLsizei width, GLsizei height,
                   GLenum type,
                   const struct gl_pixelstore_attrib *unpack,
                   const GLvoid *pixels )
{
   const GLboolean scaleOrBias
      = ctx->Pixel.DepthScale != 1.0 || ctx->Pixel.DepthBias != 0.0;
   const GLboolean zoom = ctx->Pixel.ZoomX != 1.0 || ctx->Pixel.ZoomY != 1.0;
   SWspan span;

   INIT_SPAN(span, GL_BITMAP);
   span.arrayMask = SPAN_Z;
   _swrast_span_default_attribs(ctx, &span);

   if (type == GL_UNSIGNED_SHORT
       && ctx->DrawBuffer->Visual.depthBits == 16
       && !scaleOrBias
       && !zoom
       && width <= SWRAST_MAX_WIDTH
       && !unpack->SwapBytes) {
      /* Special case: directly write 16-bit depth values */
      GLint row;
      for (row = 0; row < height; row++) {
         const GLushort *zSrc = (const GLushort *)
            _mesa_image_address2d(unpack, pixels, width, height,
                                  GL_DEPTH_COMPONENT, type, row, 0);
         GLint i;
         for (i = 0; i < width; i++)
            span.array->z[i] = zSrc[i];
         span.x = x;
         span.y = y + row;
         span.end = width;
         _swrast_write_rgba_span(ctx, &span);
      }
   }
   else if (type == GL_UNSIGNED_INT
            && !scaleOrBias
            && !zoom
            && width <= SWRAST_MAX_WIDTH
            && !unpack->SwapBytes) {
      /* Special case: shift 32-bit values down to Visual.depthBits */
      const GLint shift = 32 - ctx->DrawBuffer->Visual.depthBits;
      GLint row;
      for (row = 0; row < height; row++) {
         const GLuint *zSrc = (const GLuint *)
            _mesa_image_address2d(unpack, pixels, width, height,
                                  GL_DEPTH_COMPONENT, type, row, 0);
         if (shift == 0) {
            memcpy(span.array->z, zSrc, width * sizeof(GLuint));
         }
         else {
            GLint col;
            for (col = 0; col < width; col++)
               span.array->z[col] = zSrc[col] >> shift;
         }
         span.x = x;
         span.y = y + row;
         span.end = width;
         _swrast_write_rgba_span(ctx, &span);
      }
   }
   else {
      /* General case */
      const GLuint depthMax = ctx->DrawBuffer->_DepthMax;
      GLint skipPixels = 0;

      /* in case width > SWRAST_MAX_WIDTH do the copy in chunks */
      while (skipPixels < width) {
         const GLint spanWidth = MIN2(width - skipPixels, SWRAST_MAX_WIDTH);
         GLint row;
         ASSERT(span.end <= SWRAST_MAX_WIDTH);
         for (row = 0; row < height; row++) {
            const GLvoid *zSrc = _mesa_image_address2d(unpack,
                                                      pixels, width, height,
                                                      GL_DEPTH_COMPONENT, type,
                                                      row, skipPixels);

            /* Set these for each row since the _swrast_write_* function may
             * change them while clipping.
             */
            span.x = x + skipPixels;
            span.y = y + row;
            span.end = spanWidth;

            _mesa_unpack_depth_span(ctx, spanWidth,
                                    GL_UNSIGNED_INT, span.array->z, depthMax,
                                    type, zSrc, unpack);
            if (zoom) {
               _swrast_write_zoomed_depth_span(ctx, x, y, &span);
            }
            else {
               _swrast_write_rgba_span(ctx, &span);
            }
         }
         skipPixels += spanWidth;
      }
   }
}



/**
 * Draw RGBA image.
 */
static void
draw_rgba_pixels( struct gl_context *ctx, GLint x, GLint y,
                  GLsizei width, GLsizei height,
                  GLenum format, GLenum type,
                  const struct gl_pixelstore_attrib *unpack,
                  const GLvoid *pixels )
{
   const GLint imgX = x, imgY = y;
   const GLboolean zoom = ctx->Pixel.ZoomX!=1.0 || ctx->Pixel.ZoomY!=1.0;
   GLfloat *convImage = NULL;
   GLbitfield transferOps = ctx->_ImageTransferState;
   SWspan span;

   /* Try an optimized glDrawPixels first */
   if (fast_draw_rgba_pixels(ctx, x, y, width, height, format, type,
                             unpack, pixels)) {
      return;
   }

   swrast_render_start(ctx);

   INIT_SPAN(span, GL_BITMAP);
   _swrast_span_default_attribs(ctx, &span);
   span.arrayMask = SPAN_RGBA;
   span.arrayAttribs = VARYING_BIT_COL0; /* we're fill in COL0 attrib values */

   if (ctx->DrawBuffer->_NumColorDrawBuffers > 0) {
      GLenum datatype = _mesa_get_format_datatype(
                 ctx->DrawBuffer->_ColorDrawBuffers[0]->Format);
      if (datatype != GL_FLOAT &&
          ctx->Color.ClampFragmentColor != GL_FALSE) {
         /* need to clamp colors before applying fragment ops */
         transferOps |= IMAGE_CLAMP_BIT;
      }
   }

   /*
    * General solution
    */
   {
      const GLbitfield interpMask = span.interpMask;
      const GLbitfield arrayMask = span.arrayMask;
      const GLint srcStride
         = _mesa_image_row_stride(unpack, width, format, type);
      GLint skipPixels = 0;
      /* use span array for temp color storage */
      GLfloat *rgba = (GLfloat *) span.array->attribs[VARYING_SLOT_COL0];

      /* if the span is wider than SWRAST_MAX_WIDTH we have to do it in chunks */
      while (skipPixels < width) {
         const GLint spanWidth = MIN2(width - skipPixels, SWRAST_MAX_WIDTH);
         const GLubyte *source
            = (const GLubyte *) _mesa_image_address2d(unpack, pixels,
                                                      width, height, format,
                                                      type, 0, skipPixels);
         GLint row;

         for (row = 0; row < height; row++) {
            /* get image row as float/RGBA */
            _mesa_unpack_color_span_float(ctx, spanWidth, GL_RGBA, rgba,
                                     format, type, source, unpack,
                                     transferOps);
	    /* Set these for each row since the _swrast_write_* functions
	     * may change them while clipping/rendering.
	     */
	    span.array->ChanType = GL_FLOAT;
	    span.x = x + skipPixels;
	    span.y = y + row;
	    span.end = spanWidth;
	    span.arrayMask = arrayMask;
	    span.interpMask = interpMask;
	    if (zoom) {
	       _swrast_write_zoomed_rgba_span(ctx, imgX, imgY, &span, rgba);
	    }
	    else {
	       _swrast_write_rgba_span(ctx, &span);
	    }

            source += srcStride;
         } /* for row */

         skipPixels += spanWidth;
      } /* while skipPixels < width */

      /* XXX this is ugly/temporary, to undo above change */
      span.array->ChanType = CHAN_TYPE;
   }

   free(convImage);

   swrast_render_finish(ctx);
}


/**
 * Draw depth+stencil values into a MESA_FORAMT_Z24_S8 or MESA_FORMAT_Z24_UNORM_S8_UINT
 * renderbuffer.  No masking, zooming, scaling, etc.
 */
static void
fast_draw_depth_stencil(struct gl_context *ctx, GLint x, GLint y,
                        GLsizei width, GLsizei height,
                        const struct gl_pixelstore_attrib *unpack,
                        const GLvoid *pixels)
{
   const GLenum format = GL_DEPTH_STENCIL_EXT;
   const GLenum type = GL_UNSIGNED_INT_24_8;
   struct gl_renderbuffer *rb =
      ctx->DrawBuffer->Attachment[BUFFER_DEPTH].Renderbuffer;
   struct swrast_renderbuffer *srb = swrast_renderbuffer(rb);
   GLubyte *src, *dst;
   GLint srcRowStride, dstRowStride;
   GLint i;

   src = _mesa_image_address2d(unpack, pixels, width, height,
                               format, type, 0, 0);
   srcRowStride = _mesa_image_row_stride(unpack, width, format, type);

   dst = _swrast_pixel_address(rb, x, y);
   dstRowStride = srb->RowStride;

   for (i = 0; i < height; i++) {
      _mesa_pack_uint_24_8_depth_stencil_row(rb->Format, width,
                                             (const GLuint *) src, dst);
      dst += dstRowStride;
      src += srcRowStride;
   }
}



/**
 * This is a bit different from drawing GL_DEPTH_COMPONENT pixels.
 * The only per-pixel operations that apply are depth scale/bias,
 * stencil offset/shift, GL_DEPTH_WRITEMASK and GL_STENCIL_WRITEMASK,
 * and pixel zoom.
 * Also, only the depth buffer and stencil buffers are touched, not the
 * color buffer(s).
 */
static void
draw_depth_stencil_pixels(struct gl_context *ctx, GLint x, GLint y,
                          GLsizei width, GLsizei height, GLenum type,
                          const struct gl_pixelstore_attrib *unpack,
                          const GLvoid *pixels)
{
   const GLint imgX = x, imgY = y;
   const GLboolean scaleOrBias
      = ctx->Pixel.DepthScale != 1.0 || ctx->Pixel.DepthBias != 0.0;
   const GLuint stencilMask = ctx->Stencil.WriteMask[0];
   const GLenum stencilType = GL_UNSIGNED_BYTE;
   const GLboolean zoom = ctx->Pixel.ZoomX != 1.0 || ctx->Pixel.ZoomY != 1.0;
   struct gl_renderbuffer *depthRb, *stencilRb;
   struct gl_pixelstore_attrib clippedUnpack = *unpack;

   if (!zoom) {
      if (!_mesa_clip_drawpixels(ctx, &x, &y, &width, &height,
                                 &clippedUnpack)) {
         /* totally clipped */
         return;
      }
   }
   
   depthRb = ctx->ReadBuffer->Attachment[BUFFER_DEPTH].Renderbuffer;
   stencilRb = ctx->ReadBuffer->Attachment[BUFFER_STENCIL].Renderbuffer;
   ASSERT(depthRb);
   ASSERT(stencilRb);

   if (depthRb == stencilRb &&
       (depthRb->Format == MESA_FORMAT_S8_UINT_Z24_UNORM ||
        depthRb->Format == MESA_FORMAT_Z24_UNORM_S8_UINT) &&
       type == GL_UNSIGNED_INT_24_8 &&
       !scaleOrBias &&
       !zoom &&
       ctx->Depth.Mask &&
       (stencilMask & 0xff) == 0xff) {
      fast_draw_depth_stencil(ctx, x, y, width, height,
                              &clippedUnpack, pixels);
   }
   else {
      /* sub-optimal cases:
       * Separate depth/stencil buffers, or pixel transfer ops required.
       */
      /* XXX need to handle very wide images (skippixels) */
      GLuint *zValues;  /* 32-bit Z values */
      GLint i;

      zValues = malloc(width * sizeof(GLuint));
      if (!zValues) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glDrawPixels");
         return;
      }

      for (i = 0; i < height; i++) {
         const GLuint *depthStencilSrc = (const GLuint *)
            _mesa_image_address2d(&clippedUnpack, pixels, width, height,
                                  GL_DEPTH_STENCIL_EXT, type, i, 0);

         if (ctx->Depth.Mask) {
            _mesa_unpack_depth_span(ctx, width,
                                    GL_UNSIGNED_INT, /* dest type */
                                    zValues,         /* dest addr */
                                    0xffffffff,      /* depth max */
                                    type,            /* src type */
                                    depthStencilSrc, /* src addr */
                                    &clippedUnpack);
            if (zoom) {
               _swrast_write_zoomed_z_span(ctx, imgX, imgY, width, x,
                                           y + i, zValues);
            }
            else {
               GLubyte *dst = _swrast_pixel_address(depthRb, x, y + i);
               _mesa_pack_uint_z_row(depthRb->Format, width, zValues, dst);
            }
         }

         if (stencilMask != 0x0) {
            GLubyte *stencilValues = (GLubyte *) zValues; /* re-use buffer */
            /* get stencil values, with shift/offset/mapping */
            _mesa_unpack_stencil_span(ctx, width, stencilType, stencilValues,
                                      type, depthStencilSrc, &clippedUnpack,
                                      ctx->_ImageTransferState);
            if (zoom)
               _swrast_write_zoomed_stencil_span(ctx, imgX, imgY, width,
                                                  x, y + i, stencilValues);
            else
               _swrast_write_stencil_span(ctx, width, x, y + i, stencilValues);
         }
      }

      free(zValues);
   }
}


/**
 * Execute software-based glDrawPixels.
 * By time we get here, all error checking will have been done.
 */
void
_swrast_DrawPixels( struct gl_context *ctx,
		    GLint x, GLint y,
		    GLsizei width, GLsizei height,
		    GLenum format, GLenum type,
		    const struct gl_pixelstore_attrib *unpack,
		    const GLvoid *pixels )
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
   GLboolean save_vp_override = ctx->VertexProgram._Overriden;

   if (!_mesa_check_conditional_render(ctx))
      return; /* don't draw */

   /* We are creating fragments directly, without going through vertex
    * programs.
    *
    * This override flag tells the fragment processing code that its input
    * comes from a non-standard source, and it may therefore not rely on
    * optimizations that assume e.g. constant color if there is no color
    * vertex array.
    */
   _mesa_set_vp_override(ctx, GL_TRUE);

   if (ctx->NewState)
      _mesa_update_state(ctx);

   if (swrast->NewState)
      _swrast_validate_derived( ctx );

   pixels = _mesa_map_pbo_source(ctx, unpack, pixels);
   if (!pixels) {
      _mesa_set_vp_override(ctx, save_vp_override);
      return;
   }

   /*
    * By time we get here, all error checking should have been done.
    */
   switch (format) {
   case GL_STENCIL_INDEX:
      swrast_render_start(ctx);
      draw_stencil_pixels( ctx, x, y, width, height, type, unpack, pixels );
      swrast_render_finish(ctx);
      break;
   case GL_DEPTH_COMPONENT:
      swrast_render_start(ctx);
      draw_depth_pixels( ctx, x, y, width, height, type, unpack, pixels );
      swrast_render_finish(ctx);
      break;
   case GL_DEPTH_STENCIL_EXT:
      swrast_render_start(ctx);
      draw_depth_stencil_pixels(ctx, x, y, width, height, type, unpack, pixels);
      swrast_render_finish(ctx);
      break;
   default:
      /* all other formats should be color formats */
      draw_rgba_pixels(ctx, x, y, width, height, format, type, unpack, pixels);
   }

   _mesa_set_vp_override(ctx, save_vp_override);

   _mesa_unmap_pbo_source(ctx, unpack);
}
@


1.9
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.8
log
@Merge Mesa 9.2.0
@
text
@d226 2
a227 2
       (rb->Format == MESA_FORMAT_XRGB8888 ||
        rb->Format == MESA_FORMAT_ARGB8888)) {
d235 2
a236 2
       (rb->Format == MESA_FORMAT_XRGB8888 ||
        rb->Format == MESA_FORMAT_ARGB8888)) {
d503 1
a503 1
 * Draw depth+stencil values into a MESA_FORAMT_Z24_S8 or MESA_FORMAT_S8_Z24
d575 2
a576 2
       (depthRb->Format == MESA_FORMAT_Z24_S8 ||
        depthRb->Format == MESA_FORMAT_S8_Z24) &&
@


1.7
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a2 1
 * Version:  7.1
d19 4
a22 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
d28 1
d31 1
d46 140
a197 1
   const GLint imgX = x, imgY = y;
a198 1
   GLenum rbType;
a199 3
   SWspan span;
   GLboolean simpleZoom;
   GLint yStep;  /* +1 or -1 */
a200 1
   GLint destX, destY, drawWidth, drawHeight; /* post clipping */
d205 2
a206 3
   rbType = rb->DataType;

   if ((swrast->_RasterMask & ~CLIP_BIT) ||
d209 2
a215 6
   INIT_SPAN(span, GL_BITMAP);
   span.arrayMask = SPAN_RGBA;
   span.arrayAttribs = FRAG_BIT_COL0;
   _swrast_span_default_attribs(ctx, &span);

   /* copy input params since clipping may change them */
a216 24
   destX = x;
   destY = y;
   drawWidth = width;
   drawHeight = height;

   /* check for simple zooming and clipping */
   if (ctx->Pixel.ZoomX == 1.0F &&
       (ctx->Pixel.ZoomY == 1.0F || ctx->Pixel.ZoomY == -1.0F)) {
      if (!_mesa_clip_drawpixels(ctx, &destX, &destY,
                                 &drawWidth, &drawHeight, &unpack)) {
         /* image was completely clipped: no-op, all done */
         return GL_TRUE;
      }
      simpleZoom = GL_TRUE;
      yStep = (GLint) ctx->Pixel.ZoomY;
      ASSERT(yStep == 1 || yStep == -1);
   }
   else {
      /* non-simple zooming */
      simpleZoom = GL_FALSE;
      yStep = 1;
      if (unpack.RowLength == 0)
         unpack.RowLength = width;
   }
d218 3
a220 31
   /*
    * Ready to draw!
    */

   if (format == GL_RGBA && type == rbType) {
      const GLubyte *src
         = (const GLubyte *) _mesa_image_address2d(&unpack, pixels, width,
                                                   height, format, type, 0, 0);
      const GLint srcStride = _mesa_image_row_stride(&unpack, width,
                                                     format, type);
      if (simpleZoom) {
         GLint row;
         for (row = 0; row < drawHeight; row++) {
            rb->PutRow(ctx, rb, drawWidth, destX, destY, src, NULL);
            src += srcStride;
            destY += yStep;
         }
      }
      else {
         /* with zooming */
         GLint row;
         for (row = 0; row < drawHeight; row++) {
            span.x = destX;
            span.y = destY + row;
            span.end = drawWidth;
            span.array->ChanType = rbType;
            _swrast_write_zoomed_rgba_span(ctx, imgX, imgY, &span, src);
            src += srcStride;
         }
         span.array->ChanType = CHAN_TYPE;
      }
d224 6
a229 28
   if (format == GL_RGB && type == rbType) {
      const GLubyte *src
         = (const GLubyte *) _mesa_image_address2d(&unpack, pixels, width,
                                                   height, format, type, 0, 0);
      const GLint srcStride = _mesa_image_row_stride(&unpack, width,
                                                     format, type);
      if (simpleZoom) {
         GLint row;
         for (row = 0; row < drawHeight; row++) {
            rb->PutRowRGB(ctx, rb, drawWidth, destX, destY, src, NULL);
            src += srcStride;
            destY += yStep;
         }
      }
      else {
         /* with zooming */
         GLint row;
         for (row = 0; row < drawHeight; row++) {
            span.x = destX;
            span.y = destY;
            span.end = drawWidth;
            span.array->ChanType = rbType;
            _swrast_write_zoomed_rgb_span(ctx, imgX, imgY, &span, src);
            src += srcStride;
            destY++;
         }
         span.array->ChanType = CHAN_TYPE;
      }
d233 6
a238 44
   /* Remaining cases haven't been tested with alignment != 1 */
   if (userUnpack->Alignment != 1)
      return GL_FALSE;

   if (format == GL_LUMINANCE && type == CHAN_TYPE && rbType == CHAN_TYPE) {
      const GLchan *src = (const GLchan *) pixels
         + (unpack.SkipRows * unpack.RowLength + unpack.SkipPixels);
      if (simpleZoom) {
         /* no zooming */
         GLint row;
         ASSERT(drawWidth <= MAX_WIDTH);
         for (row = 0; row < drawHeight; row++) {
            GLchan rgb[MAX_WIDTH][3];
            GLint i;
            for (i = 0;i<drawWidth;i++) {
               rgb[i][0] = src[i];
               rgb[i][1] = src[i];
               rgb[i][2] = src[i];
            }
            rb->PutRowRGB(ctx, rb, drawWidth, destX, destY, rgb, NULL);
            src += unpack.RowLength;
            destY += yStep;
         }
      }
      else {
         /* with zooming */
         GLint row;
         ASSERT(drawWidth <= MAX_WIDTH);
         for (row = 0; row < drawHeight; row++) {
            GLchan rgb[MAX_WIDTH][3];
            GLint i;
            for (i = 0;i<drawWidth;i++) {
               rgb[i][0] = src[i];
               rgb[i][1] = src[i];
               rgb[i][2] = src[i];
            }
            span.x = destX;
            span.y = destY;
            span.end = drawWidth;
            _swrast_write_zoomed_rgb_span(ctx, imgX, imgY, &span, rgb);
            src += unpack.RowLength;
            destY++;
         }
      }
d242 4
a245 43
   if (format == GL_LUMINANCE_ALPHA && type == CHAN_TYPE && rbType == CHAN_TYPE) {
      const GLchan *src = (const GLchan *) pixels
         + (unpack.SkipRows * unpack.RowLength + unpack.SkipPixels)*2;
      if (simpleZoom) {
         GLint row;
         ASSERT(drawWidth <= MAX_WIDTH);
         for (row = 0; row < drawHeight; row++) {
            GLint i;
            const GLchan *ptr = src;
            for (i = 0;i<drawWidth;i++) {
               span.array->rgba[i][0] = *ptr;
               span.array->rgba[i][1] = *ptr;
               span.array->rgba[i][2] = *ptr++;
               span.array->rgba[i][3] = *ptr++;
            }
            rb->PutRow(ctx, rb, drawWidth, destX, destY,
                       span.array->rgba, NULL);
            src += unpack.RowLength*2;
            destY += yStep;
         }
      }
      else {
         /* with zooming */
         GLint row;
         ASSERT(drawWidth <= MAX_WIDTH);
         for (row = 0; row < drawHeight; row++) {
            const GLchan *ptr = src;
            GLint i;
            for (i = 0;i<drawWidth;i++) {
               span.array->rgba[i][0] = *ptr;
               span.array->rgba[i][1] = *ptr;
               span.array->rgba[i][2] = *ptr++;
               span.array->rgba[i][3] = *ptr++;
            }
            span.x = destX;
            span.y = destY;
            span.end = drawWidth;
            _swrast_write_zoomed_rgba_span(ctx, imgX, imgY, &span,
                                           span.array->rgba);
            src += unpack.RowLength*2;
            destY++;
         }
      }
a248 37
   if (format == GL_COLOR_INDEX && type == GL_UNSIGNED_BYTE) {
      const GLubyte *src = (const GLubyte *) pixels
         + unpack.SkipRows * unpack.RowLength + unpack.SkipPixels;
      if (rbType == GL_UNSIGNED_BYTE) {
         /* convert ubyte/CI data to ubyte/RGBA */
         if (simpleZoom) {
            GLint row;
            for (row = 0; row < drawHeight; row++) {
               ASSERT(drawWidth <= MAX_WIDTH);
               _mesa_map_ci8_to_rgba8(ctx, drawWidth, src,
                                      span.array->rgba8);
               rb->PutRow(ctx, rb, drawWidth, destX, destY,
                          span.array->rgba8, NULL);
               src += unpack.RowLength;
               destY += yStep;
            }
         }
         else {
            /* ubyte/CI to ubyte/RGBA with zooming */
            GLint row;
            for (row = 0; row < drawHeight; row++) {
               ASSERT(drawWidth <= MAX_WIDTH);
               _mesa_map_ci8_to_rgba8(ctx, drawWidth, src,
                                      span.array->rgba8);
               span.x = destX;
               span.y = destY;
               span.end = drawWidth;
               _swrast_write_zoomed_rgba_span(ctx, imgX, imgY, &span,
                                              span.array->rgba8);
               src += unpack.RowLength;
               destY++;
            }
         }
         return GL_TRUE;
      }
   }

d266 9
a274 1
   GLint skipPixels;
d276 14
a289 25
   /* if width > MAX_WIDTH, have to process image in chunks */
   skipPixels = 0;
   while (skipPixels < width) {
      const GLint spanX = x + skipPixels;
      const GLint spanWidth = MIN2(width - skipPixels, MAX_WIDTH);
      GLint row;
      for (row = 0; row < height; row++) {
         const GLint spanY = y + row;
         GLstencil values[MAX_WIDTH];
         GLenum destType = (sizeof(GLstencil) == sizeof(GLubyte))
                         ? GL_UNSIGNED_BYTE : GL_UNSIGNED_SHORT;
         const GLvoid *source = _mesa_image_address2d(unpack, pixels,
                                                      width, height,
                                                      GL_COLOR_INDEX, type,
                                                      row, skipPixels);
         _mesa_unpack_stencil_span(ctx, spanWidth, destType, values,
                                   type, source, unpack,
                                   ctx->_ImageTransferState);
         if (zoom) {
            _swrast_write_zoomed_stencil_span(ctx, x, y, spanWidth,
                                              spanX, spanY, values);
         }
         else {
            _swrast_write_stencil_span(ctx, spanWidth, spanX, spanY, values);
         }
d291 2
a292 1
      skipPixels += spanWidth;
d294 2
d322 1
a322 1
       && width <= MAX_WIDTH
d342 1
a342 1
            && width <= MAX_WIDTH
d370 1
a370 1
      /* in case width > MAX_WIDTH do the copy in chunks */
d372 1
a372 1
         const GLint spanWidth = MIN2(width - skipPixels, MAX_WIDTH);
d374 1
a374 1
         ASSERT(span.end <= MAX_WIDTH);
d427 2
d432 1
a432 1
   span.arrayAttribs = FRAG_BIT_COL0; /* we're fill in COL0 attrib values */
d434 8
a441 5
   if (ctx->DrawBuffer->_NumColorDrawBuffers > 0 &&
       ctx->DrawBuffer->_ColorDrawBuffers[0]->DataType != GL_FLOAT &&
       ctx->Color.ClampFragmentColor != GL_FALSE) {
      /* need to clamp colors before applying fragment ops */
      transferOps |= IMAGE_CLAMP_BIT;
d454 1
a454 1
      GLfloat *rgba = (GLfloat *) span.array->attribs[FRAG_ATTRIB_COL0];
d456 1
a456 1
      /* if the span is wider than MAX_WIDTH we have to do it in chunks */
d458 1
a458 1
         const GLint spanWidth = MIN2(width - skipPixels, MAX_WIDTH);
d496 37
a532 2
   if (convImage) {
      free(convImage);
d537 1
a554 1
   const GLuint depthMax = ctx->DrawBuffer->_DepthMax;
d556 1
a556 2
   const GLuint stencilType = (STENCIL_BITS == 8) ? 
      GL_UNSIGNED_BYTE : GL_UNSIGNED_SHORT;
d574 4
a577 3
   if (depthRb->_BaseFormat == GL_DEPTH_STENCIL_EXT &&
       stencilRb->_BaseFormat == GL_DEPTH_STENCIL_EXT &&
       depthRb == stencilRb &&
d582 2
a583 11
      /* This is the ideal case.
       * Drawing GL_DEPTH_STENCIL pixels into a combined depth/stencil buffer.
       * Plus, no pixel transfer ops, zooming, or masking needed.
       */
      GLint i;
      for (i = 0; i < height; i++) {
         const GLuint *src = (const GLuint *) 
            _mesa_image_address2d(&clippedUnpack, pixels, width, height,
                                  GL_DEPTH_STENCIL_EXT, type, i, 0);
         depthRb->PutRow(ctx, depthRb, width, x, y + i, src, NULL);
      }
d590 1
d593 5
a597 2
      depthRb = ctx->DrawBuffer->_DepthBuffer;
      stencilRb = ctx->DrawBuffer->_StencilBuffer;
d605 10
a614 27
            if (!scaleOrBias && ctx->DrawBuffer->Visual.depthBits == 24) {
               /* fast path 24-bit zbuffer */
               GLuint zValues[MAX_WIDTH];
               GLint j;
               ASSERT(depthRb->DataType == GL_UNSIGNED_INT);
               for (j = 0; j < width; j++) {
                  zValues[j] = depthStencilSrc[j] >> 8;
               }
               if (zoom)
                  _swrast_write_zoomed_z_span(ctx, imgX, imgY, width,
                                              x, y + i, zValues);
               else
                  depthRb->PutRow(ctx, depthRb, width, x, y + i, zValues,NULL);
            }
            else if (!scaleOrBias && ctx->DrawBuffer->Visual.depthBits == 16) {
               /* fast path 16-bit zbuffer */
               GLushort zValues[MAX_WIDTH];
               GLint j;
               ASSERT(depthRb->DataType == GL_UNSIGNED_SHORT);
               for (j = 0; j < width; j++) {
                  zValues[j] = depthStencilSrc[j] >> 16;
               }
               if (zoom)
                  _swrast_write_zoomed_z_span(ctx, imgX, imgY, width,
                                              x, y + i, zValues);
               else
                  depthRb->PutRow(ctx, depthRb, width, x, y + i, zValues,NULL);
d617 2
a618 12
               /* general case */
               GLuint zValues[MAX_WIDTH];  /* 16 or 32-bit Z value storage */
               _mesa_unpack_depth_span(ctx, width,
                                       depthRb->DataType, zValues, depthMax,
                                       type, depthStencilSrc, &clippedUnpack);
               if (zoom) {
                  _swrast_write_zoomed_z_span(ctx, imgX, imgY, width, x,
                                              y + i, zValues);
               }
               else {
                  depthRb->PutRow(ctx, depthRb, width, x, y + i, zValues,NULL);
               }
d623 1
a623 1
            GLstencil stencilValues[MAX_WIDTH];
d635 2
a668 2
   swrast_render_start(ctx);

a676 1
      swrast_render_finish(ctx);
d686 1
d688 1
d691 1
d693 1
d696 1
d698 1
a704 1
   swrast_render_finish(ctx);
@


1.6
log
@Merge Mesa 7.10.3
@
text
@d34 1
@


1.5
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@a29 1
#include "main/convolve.h"
d31 1
d33 2
a34 1
#include "main/imports.h"
d49 1
a49 1
fast_draw_rgba_pixels(GLcontext *ctx, GLint x, GLint y,
d315 1
a315 1
draw_stencil_pixels( GLcontext *ctx, GLint x, GLint y,
d359 1
a359 1
draw_depth_pixels( GLcontext *ctx, GLint x, GLint y,
d465 1
a465 1
draw_rgba_pixels( GLcontext *ctx, GLint x, GLint y,
a487 56
   if (ctx->Pixel.Convolution2DEnabled || ctx->Pixel.Separable2DEnabled) {
      /* Convolution has to be handled specially.  We'll create an
       * intermediate image, applying all pixel transfer operations
       * up to convolution.  Then we'll convolve the image.  Then
       * we'll proceed with the rest of the transfer operations and
       * rasterize the image.
       */
      GLint row;
      GLfloat *dest, *tmpImage;

      tmpImage = (GLfloat *) malloc(width * height * 4 * sizeof(GLfloat));
      if (!tmpImage) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glDrawPixels");
         return;
      }
      convImage = (GLfloat *) malloc(width * height * 4 * sizeof(GLfloat));
      if (!convImage) {
         free(tmpImage);
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glDrawPixels");
         return;
      }

      /* Unpack the image and apply transfer ops up to convolution */
      dest = tmpImage;
      for (row = 0; row < height; row++) {
         const GLvoid *source = _mesa_image_address2d(unpack,
                                  pixels, width, height, format, type, row, 0);
         _mesa_unpack_color_span_float(ctx, width, GL_RGBA, (GLfloat *) dest,
                                     format, type, source, unpack,
                                     transferOps & IMAGE_PRE_CONVOLUTION_BITS);
         dest += width * 4;
      }

      /* do convolution */
      if (ctx->Pixel.Convolution2DEnabled) {
         _mesa_convolve_2d_image(ctx, &width, &height, tmpImage, convImage);
      }
      else {
         ASSERT(ctx->Pixel.Separable2DEnabled);
         _mesa_convolve_sep_image(ctx, &width, &height, tmpImage, convImage);
      }
      free(tmpImage);

      /* continue transfer ops and draw the convolved image */
      unpack = &ctx->DefaultPacking;
      pixels = convImage;
      format = GL_RGBA;
      type = GL_FLOAT;
      transferOps &= IMAGE_POST_CONVOLUTION_BITS;
   }
   else if (ctx->Pixel.Convolution1DEnabled) {
      /* we only want to apply 1D convolution to glTexImage1D */
      transferOps &= ~(IMAGE_CONVOLUTION_BIT |
                       IMAGE_POST_CONVOLUTION_SCALE_BIAS);
   }

a498 2
      const GLboolean sink = (ctx->Pixel.MinMaxEnabled && ctx->MinMax.Sink)
         || (ctx->Pixel.HistogramEnabled && ctx->Histogram.Sink);
d521 15
a535 18
            /* draw the span */
            if (!sink) {
               /* Set these for each row since the _swrast_write_* functions
                * may change them while clipping/rendering.
                */
               span.array->ChanType = GL_FLOAT;
               span.x = x + skipPixels;
               span.y = y + row;
               span.end = spanWidth;
               span.arrayMask = arrayMask;
               span.interpMask = interpMask;
               if (zoom) {
                  _swrast_write_zoomed_rgba_span(ctx, imgX, imgY, &span, rgba);
               }
               else {
                  _swrast_write_rgba_span(ctx, &span);
               }
            }
d562 1
a562 1
draw_depth_stencil_pixels(GLcontext *ctx, GLint x, GLint y,
d692 1
a692 1
_swrast_DrawPixels( GLcontext *ctx,
d723 6
a728 6
    pixels = _mesa_map_pbo_source(ctx, unpack, pixels);
    if (!pixels) {
       swrast_render_finish(ctx);
       _mesa_set_vp_override(ctx, save_vp_override);
       return;
    }
d730 3
a739 14
   case GL_COLOR_INDEX:
   case GL_RED:
   case GL_GREEN:
   case GL_BLUE:
   case GL_ALPHA:
   case GL_LUMINANCE:
   case GL_LUMINANCE_ALPHA:
   case GL_RGB:
   case GL_BGR:
   case GL_RGBA:
   case GL_BGRA:
   case GL_ABGR_EXT:
      draw_rgba_pixels(ctx, x, y, width, height, format, type, unpack, pixels);
      break;
d741 1
a741 2
      draw_depth_stencil_pixels(ctx, x, y, width, height,
                                type, unpack, pixels);
d744 2
a745 2
      _mesa_problem(ctx, "unexpected format in _swrast_DrawPixels");
      /* don't return yet, clean-up */
@


1.4
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d28 1
a33 1
#include "main/pixel.h"
d270 1
a270 1
      if (ctx->Visual.rgbMode && rbType == GL_UNSIGNED_BYTE) {
a301 16
      else if (!ctx->Visual.rgbMode && rbType == GL_UNSIGNED_INT) {
         /* write CI data to CI frame buffer */
         GLint row;
         if (simpleZoom) {
            for (row = 0; row < drawHeight; row++) {
               GLuint index32[MAX_WIDTH];
               GLint col;
               for (col = 0; col < drawWidth; col++)
                  index32[col] = src[col];
               rb->PutRow(ctx, rb, drawWidth, destX, destY, index32, NULL);
               src += unpack.RowLength;
               destY += yStep;
            }
            return GL_TRUE;
         }
      }
a310 51
 * Draw color index image.
 */
static void
draw_index_pixels( GLcontext *ctx, GLint x, GLint y,
                   GLsizei width, GLsizei height,
                   GLenum type,
                   const struct gl_pixelstore_attrib *unpack,
                   const GLvoid *pixels )
{
   const GLint imgX = x, imgY = y;
   const GLboolean zoom = ctx->Pixel.ZoomX!=1.0 || ctx->Pixel.ZoomY!=1.0;
   GLint row, skipPixels;
   SWspan span;

   INIT_SPAN(span, GL_BITMAP);
   span.arrayMask = SPAN_INDEX;
   _swrast_span_default_attribs(ctx, &span);

   /*
    * General solution
    */
   skipPixels = 0;
   while (skipPixels < width) {
      const GLint spanWidth = MIN2(width - skipPixels, MAX_WIDTH);
      ASSERT(spanWidth <= MAX_WIDTH);
      for (row = 0; row < height; row++) {
         const GLvoid *source = _mesa_image_address2d(unpack, pixels,
                                                      width, height,
                                                      GL_COLOR_INDEX, type,
                                                      row, skipPixels);
         _mesa_unpack_index_span(ctx, spanWidth, GL_UNSIGNED_INT,
                                 span.array->index, type, source, unpack,
                                 ctx->_ImageTransferState);

         /* These may get changed during writing/clipping */
         span.x = x + skipPixels;
         span.y = y + row;
         span.end = spanWidth;
         
         if (zoom)
            _swrast_write_zoomed_index_span(ctx, imgX, imgY, &span);
         else
            _swrast_write_index_span(ctx, &span);
      }
      skipPixels += spanWidth;
   }
}



/*
a376 1
       && ctx->Visual.rgbMode
a396 1
            && ctx->Visual.rgbMode
d407 1
a407 1
            _mesa_memcpy(span.array->z, zSrc, width * sizeof(GLuint));
d449 1
a449 1
            else if (ctx->Visual.rgbMode) {
a451 3
            else {
               _swrast_write_index_span(ctx, &span);
            }
d497 1
a497 1
      tmpImage = (GLfloat *) _mesa_malloc(width * height * 4 * sizeof(GLfloat));
d502 1
a502 1
      convImage = (GLfloat *) _mesa_malloc(width * height * 4 * sizeof(GLfloat));
d504 1
a504 1
         _mesa_free(tmpImage);
d528 1
a528 1
      _mesa_free(tmpImage);
d608 1
a608 1
      _mesa_free(convImage);
d760 1
d762 14
a775 1
   RENDER_START(swrast,ctx);
d783 1
a783 1
    pixels = _mesa_map_drawpix_pbo(ctx, unpack, pixels);
d785 2
a786 1
       RENDER_FINISH(swrast,ctx);
a797 5
      if (ctx->Visual.rgbMode)
	 draw_rgba_pixels(ctx, x,y, width, height, format, type, unpack, pixels);
      else
	 draw_index_pixels(ctx, x, y, width, height, type, unpack, pixels);
      break;
d820 2
a821 53
   RENDER_FINISH(swrast,ctx);

   _mesa_unmap_drapix_pbo(ctx, unpack);
}



#if 0  /* experimental */
/*
 * Execute glDrawDepthPixelsMESA().
 */
void
_swrast_DrawDepthPixelsMESA( GLcontext *ctx,
                             GLint x, GLint y,
                             GLsizei width, GLsizei height,
                             GLenum colorFormat, GLenum colorType,
                             const GLvoid *colors,
                             GLenum depthType, const GLvoid *depths,
                             const struct gl_pixelstore_attrib *unpack )
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);

   if (swrast->NewState)
      _swrast_validate_derived( ctx );

   RENDER_START(swrast,ctx);

   switch (colorFormat) {
   case GL_COLOR_INDEX:
      if (ctx->Visual.rgbMode)
	 draw_rgba_pixels(ctx, x,y, width, height, colorFormat, colorType,
                          unpack, colors);
      else
	 draw_index_pixels(ctx, x, y, width, height, colorType,
                           unpack, colors);
      break;
   case GL_RED:
   case GL_GREEN:
   case GL_BLUE:
   case GL_ALPHA:
   case GL_LUMINANCE:
   case GL_LUMINANCE_ALPHA:
   case GL_RGB:
   case GL_BGR:
   case GL_RGBA:
   case GL_BGRA:
   case GL_ABGR_EXT:
      draw_rgba_pixels(ctx, x, y, width, height, colorFormat, colorType,
                       unpack, colors);
      break;
   default:
      _mesa_problem(ctx, "unexpected format in glDrawDepthPixelsMESA");
   }
d823 1
a823 1
   RENDER_FINISH(swrast,ctx);
a824 1
#endif
@


1.3
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d26 9
a34 9
#include "glheader.h"
#include "bufferobj.h"
#include "context.h"
#include "convolve.h"
#include "image.h"
#include "macros.h"
#include "imports.h"
#include "pixel.h"
#include "state.h"
a36 1
#include "s_drawpix.h"
@


1.2
log
@Update to Mesa 7.0.3. tested my oga@@ and johan@@
@
text
@d3 1
a3 1
 * Version:  7.0.1
d56 2
a57 2
   struct gl_renderbuffer *rb = ctx->DrawBuffer->_ColorDrawBuffers[0][0];
   const GLenum rbType = rb->DataType;
d65 5
d78 4
a81 8
   INIT_SPAN(span, GL_BITMAP, 0, 0, SPAN_RGBA);
   _swrast_span_default_secondary_color(ctx, &span);
   if (ctx->Depth.Test)
      _swrast_span_default_z(ctx, &span);
   if (swrast->_FogEnabled)
      _swrast_span_default_fog(ctx, &span);
   if (ctx->Texture._EnabledCoordUnits)
      _swrast_span_default_texcoords(ctx, &span);
d278 1
a278 1
                                      span.array->color.sz1.rgba);
d280 1
a280 1
                          span.array->color.sz1.rgba, NULL);
d291 1
a291 1
                                      span.array->color.sz1.rgba);
d296 1
a296 1
                                              span.array->color.sz1.rgba);
a336 1
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
d342 3
a344 6
   INIT_SPAN(span, GL_BITMAP, 0, 0, SPAN_INDEX);

   if (ctx->Depth.Test)
      _swrast_span_default_z(ctx, &span);
   if (swrast->_FogEnabled)
      _swrast_span_default_fog(ctx, &span);
a431 1
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
d437 3
a439 8
   INIT_SPAN(span, GL_BITMAP, 0, 0, SPAN_Z);

   _swrast_span_default_color(ctx, &span);
   _swrast_span_default_secondary_color(ctx, &span);
   if (swrast->_FogEnabled)
      _swrast_span_default_fog(ctx, &span);
   if (ctx->Texture._EnabledCoordUnits)
      _swrast_span_default_texcoords(ctx, &span);
d492 1
a492 1
      const GLfloat depthMax = ctx->DrawBuffer->_DepthMaxF;
a542 1
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
d551 1
a551 1
                             unpack, pixels))
d553 1
d555 4
a558 8
   INIT_SPAN(span, GL_BITMAP, 0, 0, SPAN_RGBA);
   _swrast_span_default_secondary_color(ctx, &span);
   if (ctx->Depth.Test)
      _swrast_span_default_z(ctx, &span);
   if (swrast->_FogEnabled)
      _swrast_span_default_fog(ctx, &span);
   if (ctx->Texture._EnabledCoordUnits)
      _swrast_span_default_texcoords(ctx, &span);
d616 2
a617 2
   if (ctx->DrawBuffer->_NumColorDrawBuffers[0] > 0 &&
       ctx->DrawBuffer->_ColorDrawBuffers[0][0]->DataType != GL_FLOAT &&
d703 1
a703 1
   const GLfloat depthScale = ctx->DrawBuffer->_DepthMaxF;
d791 1
a791 1
                                       depthRb->DataType, zValues, depthScale,
a819 1

d842 5
a846 21
   if (unpack->BufferObj->Name) {
      /* unpack from PBO */
      GLubyte *buf;
      if (!_mesa_validate_pbo_access(2, unpack, width, height, 1,
                                     format, type, pixels)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glDrawPixels(invalid PBO access)");
         RENDER_FINISH(swrast, ctx);
	 return;
      }
      buf = (GLubyte *) ctx->Driver.MapBuffer(ctx, GL_PIXEL_UNPACK_BUFFER_EXT,
                                              GL_READ_ONLY_ARB,
                                              unpack->BufferObj);
      if (!buf) {
         /* buffer is already mapped - that's an error */
         _mesa_error(ctx, GL_INVALID_OPERATION, "glDrawPixels(PBO is mapped)");
         RENDER_FINISH(swrast, ctx);
	 return;
      }
      pixels = ADD_POINTERS(buf, pixels);
   }
d885 1
a885 5
   if (unpack->BufferObj->Name) {
      /* done with PBO so unmap it now */
      ctx->Driver.UnmapBuffer(ctx, GL_PIXEL_UNPACK_BUFFER_EXT,
                              unpack->BufferObj);
   }
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * Version:  6.5.1
d5 1
a5 1
 * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
d43 2
a44 1
/*
d49 5
a53 5
fast_draw_pixels(GLcontext *ctx, GLint x, GLint y,
                 GLsizei width, GLsizei height,
                 GLenum format, GLenum type,
                 const struct gl_pixelstore_attrib *unpack,
                 const GLvoid *pixels)
d57 1
d59 11
a69 9
   struct sw_span span;

   INIT_SPAN(span, GL_BITMAP, 0, 0, SPAN_RGBA);

   if (swrast->_RasterMask & MULTI_DRAW_BIT)
      return GL_FALSE;

   if (ctx->_ImageTransferState) {
      /* don't handle any pixel transfer options here */
d73 2
d82 26
a107 5
   if ((swrast->_RasterMask & ~CLIP_BIT) == 0
       && ctx->Texture._EnabledCoordUnits == 0
       && unpack->Alignment == 1 /* XXX may not really need this */
       && !unpack->SwapBytes
       && !unpack->LsbFirst) {
d109 3
a111 10
      /* XXX there's a lot of clipping code here that should be replaced
       * by a call to _mesa_clip_drawpixels().
       */
      GLint destX = x;
      GLint destY = y;
      GLint drawWidth = width;           /* actual width drawn */
      GLint drawHeight = height;         /* actual height drawn */
      GLint skipPixels = unpack->SkipPixels;
      GLint skipRows = unpack->SkipRows;
      GLint rowLength;
d113 12
a124 15
      if (unpack->RowLength > 0)
         rowLength = unpack->RowLength;
      else
         rowLength = width;

      /* If we're not using pixel zoom then do all clipping calculations
       * now.  Otherwise, we'll let the _swrast_write_zoomed_*_span() functions
       * handle the clipping.
       */
      if (ctx->Pixel.ZoomX==1.0F && ctx->Pixel.ZoomY==1.0F) {
         /* horizontal clipping */
         if (destX < ctx->DrawBuffer->_Xmin) {
            skipPixels += (ctx->DrawBuffer->_Xmin - destX);
            drawWidth  -= (ctx->DrawBuffer->_Xmin - destX);
            destX = ctx->DrawBuffer->_Xmin;
a125 15
         if (destX + drawWidth > ctx->DrawBuffer->_Xmax)
            drawWidth -= (destX + drawWidth - ctx->DrawBuffer->_Xmax);
         if (drawWidth <= 0)
            return GL_TRUE;

         /* vertical clipping */
         if (destY < ctx->DrawBuffer->_Ymin) {
            skipRows   += (ctx->DrawBuffer->_Ymin - destY);
            drawHeight -= (ctx->DrawBuffer->_Ymin - destY);
            destY = ctx->DrawBuffer->_Ymin;
         }
         if (destY + drawHeight > ctx->DrawBuffer->_Ymax)
            drawHeight -= (destY + drawHeight - ctx->DrawBuffer->_Ymax);
         if (drawHeight <= 0)
            return GL_TRUE;
d127 28
a154 7
      else if (ctx->Pixel.ZoomX==1.0F && ctx->Pixel.ZoomY==-1.0F) {
         /* upside-down image */
         /* horizontal clipping */
         if (destX < ctx->DrawBuffer->_Xmin) {
            skipPixels += (ctx->DrawBuffer->_Xmin - destX);
            drawWidth  -= (ctx->DrawBuffer->_Xmin - destX);
            destX = ctx->DrawBuffer->_Xmin;
a155 15
         if (destX + drawWidth > ctx->DrawBuffer->_Xmax)
            drawWidth -= (destX + drawWidth - ctx->DrawBuffer->_Xmax);
         if (drawWidth <= 0)
            return GL_TRUE;

         /* vertical clipping */
         if (destY > ctx->DrawBuffer->_Ymax) {
            skipRows   += (destY - ctx->DrawBuffer->_Ymax);
            drawHeight -= (destY - ctx->DrawBuffer->_Ymax);
            destY = ctx->DrawBuffer->_Ymax;
         }
         if (destY - drawHeight < ctx->DrawBuffer->_Ymin)
            drawHeight -= (ctx->DrawBuffer->_Ymin - (destY - drawHeight));
         if (drawHeight <= 0)
            return GL_TRUE;
d158 12
a169 2
         if (drawWidth > MAX_WIDTH)
            return GL_FALSE; /* fall back to general case path */
d171 2
d174 3
d178 18
a195 42
      /*
       * Ready to draw!
       * The window region at (destX, destY) of size (drawWidth, drawHeight)
       * will be written to.
       * We'll take pixel data from buffer pointed to by "pixels" but we'll
       * skip "skipRows" rows and skip "skipPixels" pixels/row.
       */

      if (format == GL_RGBA && type == CHAN_TYPE) {
         if (ctx->Visual.rgbMode) {
            const GLchan *src = (const GLchan *) pixels
               + (skipRows * rowLength + skipPixels) * 4;
            if (ctx->Pixel.ZoomX==1.0F && ctx->Pixel.ZoomY==1.0F) {
               /* no zooming */
               GLint row;
               for (row=0; row<drawHeight; row++) {
                  rb->PutRow(ctx, rb, drawWidth, destX, destY, src, NULL);
                  src += rowLength * 4;
                  destY++;
               }
            }
            else if (ctx->Pixel.ZoomX==1.0F && ctx->Pixel.ZoomY==-1.0F) {
               /* upside-down */
               GLint row;
               for (row=0; row<drawHeight; row++) {
                  destY--;
                  rb->PutRow(ctx, rb, drawWidth, destX, destY, src, NULL);
                  src += rowLength * 4;
               }
            }
            else {
               /* with zooming */
               GLint row;
               for (row=0; row<drawHeight; row++) {
                  span.x = destX;
                  span.y = destY + row;
                  span.end = drawWidth;
                  _swrast_write_zoomed_rgba_span(ctx, imgX, imgY, &span,
                                                 (CONST GLchan (*)[4]) src);
                  src += rowLength * 4;
               }
            }
a196 1
         return GL_TRUE;
d198 42
a239 34
      else if (format == GL_RGB && type == CHAN_TYPE) {
         if (ctx->Visual.rgbMode) {
            const GLchan *src = (const GLchan *) pixels
               + (skipRows * rowLength + skipPixels) * 3;
            if (ctx->Pixel.ZoomX==1.0F && ctx->Pixel.ZoomY==1.0F) {
               GLint row;
               for (row=0; row<drawHeight; row++) {
                  rb->PutRowRGB(ctx, rb, drawWidth, destX, destY, src, NULL);
                  src += rowLength * 3;
                  destY++;
               }
            }
            else if (ctx->Pixel.ZoomX==1.0F && ctx->Pixel.ZoomY==-1.0F) {
               /* upside-down */
               GLint row;
               for (row=0; row<drawHeight; row++) {
                  destY--;
                  rb->PutRowRGB(ctx, rb, drawWidth, destX, destY, src, NULL);
                  src += rowLength * 3;
               }
            }
            else {
               /* with zooming */
               GLint row;
               for (row=0; row<drawHeight; row++) {
                  span.x = destX;
                  span.y = destY;
                  span.end = drawWidth;
                  _swrast_write_zoomed_rgb_span(ctx, imgX, imgY, &span, 
                                         (CONST GLchan (*)[3]) src);
                  src += rowLength * 3;
                  destY++;
               }
            }
a240 1
         return GL_TRUE;
d242 33
a274 7
      else if (format == GL_LUMINANCE && type == CHAN_TYPE) {
         if (ctx->Visual.rgbMode) {
            const GLchan *src = (const GLchan *) pixels
               + (skipRows * rowLength + skipPixels);
            if (ctx->Pixel.ZoomX==1.0F && ctx->Pixel.ZoomY==1.0F) {
               /* no zooming */
               GLint row;
d276 6
a281 49
               for (row=0; row<drawHeight; row++) {
                  GLint i;
		  for (i=0;i<drawWidth;i++) {
                     span.array->rgb[i][0] = src[i];
                     span.array->rgb[i][1] = src[i];
                     span.array->rgb[i][2] = src[i];
		  }
                  rb->PutRowRGB(ctx, rb, drawWidth, destX, destY,
                                span.array->rgb, NULL);
                  src += rowLength;
                  destY++;
               }
            }
            else if (ctx->Pixel.ZoomX==1.0F && ctx->Pixel.ZoomY==-1.0F) {
               /* upside-down */
               GLint row;
               ASSERT(drawWidth <= MAX_WIDTH);
               for (row=0; row<drawHeight; row++) {
                  GLint i;
                  for (i=0;i<drawWidth;i++) {
                     span.array->rgb[i][0] = src[i];
                     span.array->rgb[i][1] = src[i];
                     span.array->rgb[i][2] = src[i];
                  }
                  destY--;
                  rb->PutRow(ctx, rb, drawWidth, destX, destY,
                             span.array->rgb, NULL);
                  src += rowLength;
               }
            }
            else {
               /* with zooming */
               GLint row;
               ASSERT(drawWidth <= MAX_WIDTH);
               for (row=0; row<drawHeight; row++) {
                  GLint i;
		  for (i=0;i<drawWidth;i++) {
                     span.array->rgb[i][0] = src[i];
                     span.array->rgb[i][1] = src[i];
                     span.array->rgb[i][2] = src[i];
		  }
                  span.x = destX;
                  span.y = destY;
                  span.end = drawWidth;
                  _swrast_write_zoomed_rgb_span(ctx, imgX, imgY, &span,
                             (CONST GLchan (*)[3]) span.array->rgb);
                  src += rowLength;
                  destY++;
               }
d284 4
a287 9
         return GL_TRUE;
      }
      else if (format == GL_LUMINANCE_ALPHA && type == CHAN_TYPE) {
         if (ctx->Visual.rgbMode) {
            const GLchan *src = (const GLchan *) pixels
               + (skipRows * rowLength + skipPixels)*2;
            if (ctx->Pixel.ZoomX==1.0F && ctx->Pixel.ZoomY==1.0F) {
               /* no zooming */
               GLint row;
d289 9
a297 55
               for (row=0; row<drawHeight; row++) {
                  GLint i;
                  const GLchan *ptr = src;
		  for (i=0;i<drawWidth;i++) {
                     span.array->rgba[i][0] = *ptr;
                     span.array->rgba[i][1] = *ptr;
                     span.array->rgba[i][2] = *ptr++;
                     span.array->rgba[i][3] = *ptr++;
		  }
                  rb->PutRow(ctx, rb, drawWidth, destX, destY,
                             span.array->rgba, NULL);
                  src += rowLength*2;
                  destY++;
               }
            }
            else if (ctx->Pixel.ZoomX==1.0F && ctx->Pixel.ZoomY==-1.0F) {
               /* upside-down */
               GLint row;
               ASSERT(drawWidth <= MAX_WIDTH);
               for (row=0; row<drawHeight; row++) {
                  GLint i;
                  const GLchan *ptr = src;
                  for (i=0;i<drawWidth;i++) {
                     span.array->rgba[i][0] = *ptr;
                     span.array->rgba[i][1] = *ptr;
                     span.array->rgba[i][2] = *ptr++;
                     span.array->rgba[i][3] = *ptr++;
                  }
                  destY--;
                  rb->PutRow(ctx, rb, drawWidth, destX, destY,
                             span.array->rgba, NULL);
                  src += rowLength*2;
               }
            }
            else {
               /* with zooming */
               GLint row;
               ASSERT(drawWidth <= MAX_WIDTH);
               for (row=0; row<drawHeight; row++) {
                  const GLchan *ptr = src;
                  GLint i;
		  for (i=0;i<drawWidth;i++) {
                     span.array->rgba[i][0] = *ptr;
                     span.array->rgba[i][1] = *ptr;
                     span.array->rgba[i][2] = *ptr++;
                     span.array->rgba[i][3] = *ptr++;
		  }
                  span.x = destX;
                  span.y = destY;
                  span.end = drawWidth;
                  _swrast_write_zoomed_rgba_span(ctx, imgX, imgY, &span,
                            (CONST GLchan (*)[4]) span.array->rgba);
                  src += rowLength*2;
                  destY++;
               }
d302 12
a313 46
      else if (format==GL_COLOR_INDEX && type==GL_UNSIGNED_BYTE) {
         const GLubyte *src =
            (const GLubyte *) pixels + skipRows * rowLength + skipPixels;
         if (ctx->Visual.rgbMode) {
            /* convert CI data to RGBA */
            if (ctx->Pixel.ZoomX==1.0F && ctx->Pixel.ZoomY==1.0F) {
               /* no zooming */
               GLint row;
               for (row=0; row<drawHeight; row++) {
                  ASSERT(drawWidth <= MAX_WIDTH);
                  _mesa_map_ci8_to_rgba(ctx, drawWidth, src, span.array->rgba);
                  rb->PutRow(ctx, rb, drawWidth, destX, destY,
                             span.array->rgba, NULL);
                  src += rowLength;
                  destY++;
               }
               return GL_TRUE;
            }
            else if (ctx->Pixel.ZoomX==1.0F && ctx->Pixel.ZoomY==-1.0F) {
               /* upside-down */
               GLint row;
               for (row=0; row<drawHeight; row++) {
                  ASSERT(drawWidth <= MAX_WIDTH);
                  _mesa_map_ci8_to_rgba(ctx, drawWidth, src, span.array->rgba);
                  destY--;
                  rb->PutRow(ctx, rb, drawWidth, destX, destY,
                             span.array->rgba, NULL);
                  src += rowLength;
               }
               return GL_TRUE;
            }
            else {
               /* with zooming */
               GLint row;
               for (row=0; row<drawHeight; row++) {
                  ASSERT(drawWidth <= MAX_WIDTH);
                  _mesa_map_ci8_to_rgba(ctx, drawWidth, src, span.array->rgba);
                  span.x = destX;
                  span.y = destY;
                  span.end = drawWidth;
                  _swrast_write_zoomed_rgba_span(ctx, imgX, imgY, &span,
                            (CONST GLchan (*)[4]) span.array->rgba);
                  src += rowLength;
                  destY++;
               }
               return GL_TRUE;
d315 1
a316 25
         else {
            /* write CI data to CI frame buffer */
            GLint row;
            if (ctx->Pixel.ZoomX==1.0F && ctx->Pixel.ZoomY==1.0F) {
               /* no zooming */
               for (row=0; row<drawHeight; row++) {
                  GLuint index32[MAX_WIDTH];
                  GLint col;
                  for (col = 0; col < drawWidth; col++)
                     index32[col] = src[col];
                  rb->PutRow(ctx, rb, drawWidth, destX, destY, index32, NULL);
                  src += rowLength;
                  destY++;
               }
               return GL_TRUE;
            }
            else {
               /* with zooming */
               return GL_FALSE;
            }
         }
      }
      else {
         /* can't handle this pixel format and/or data type here */
         return GL_FALSE;
d320 1
a320 1
   /* can't do a simple draw, have to use slow path */
d340 1
a340 1
   struct sw_span span;
d409 3
a411 10
         _mesa_unpack_index_span(ctx, spanWidth, destType, values,
                                 type, source, unpack,
                                 ctx->_ImageTransferState);
         if (ctx->_ImageTransferState & IMAGE_SHIFT_OFFSET_BIT) {
            _mesa_shift_and_offset_stencil(ctx, spanWidth, values);
         }
         if (ctx->Pixel.MapStencilFlag) {
            _mesa_map_stencil(ctx, spanWidth, values);
         }

d439 1
a439 1
   struct sw_span span;
d444 1
a444 1

d455 2
a456 1
       && width <= MAX_WIDTH) {
d476 2
a477 1
            && width <= MAX_WIDTH) {
d542 1
a542 1
/*
a553 1
   struct gl_renderbuffer *rb = NULL; /* only used for quickDraw path */
a554 1
   GLboolean quickDraw;
d556 2
a557 4
   GLuint transferOps = ctx->_ImageTransferState;
   struct sw_span span;

   INIT_SPAN(span, GL_BITMAP, 0, 0, SPAN_RGBA);
d560 2
a561 1
   if (fast_draw_pixels(ctx, x, y, width, height, format, type, unpack, pixels))
d564 2
a572 12
   if (swrast->_RasterMask == 0 && !zoom && x >= 0 && y >= 0
       && x + width <= (GLint) ctx->DrawBuffer->Width
       && y + height <= (GLint) ctx->DrawBuffer->Height
       && ctx->DrawBuffer->_NumColorDrawBuffers[0] == 1) {
      quickDraw = GL_TRUE;
      rb = ctx->DrawBuffer->_ColorDrawBuffers[0][0];
   }
   else {
      quickDraw = GL_FALSE;
      rb = NULL;
   }

d623 12
d640 2
d644 2
d647 2
d653 4
a658 2
         ASSERT(span.end <= MAX_WIDTH);

d660 4
a663 21
            const GLvoid *source = _mesa_image_address2d(unpack,
                     pixels, width, height, format, type, row, skipPixels);

            /* Set these for each row since the _swrast_write_* function may
             * change them while clipping.
             */
            span.x = x + skipPixels;
            span.y = y + row;
            span.end = spanWidth;
            span.arrayMask = arrayMask;
            span.interpMask = interpMask;

            _mesa_unpack_color_span_chan(ctx, spanWidth, GL_RGBA,
                                         (GLchan *) span.array->rgba,
                                         format, type, source, unpack,
                                         transferOps);

            if ((ctx->Pixel.MinMaxEnabled && ctx->MinMax.Sink) ||
                (ctx->Pixel.HistogramEnabled && ctx->Histogram.Sink))
               continue;

d665 16
a680 3
            if (quickDraw) {
               rb->PutRow(ctx, rb, span.end, span.x, span.y,
                          span.array->rgba, NULL);
d682 3
a684 8
            else if (zoom) {
               _swrast_write_zoomed_rgba_span(ctx, imgX, imgY, &span,
                                       (CONST GLchan (*)[4]) span.array->rgba);
            }
            else {
               _swrast_write_rgba_span(ctx, &span);
            }
         }
d687 4
a690 1
      }
d863 2
a864 1
         goto end;
d872 2
a873 1
         goto end;
a911 2

end:
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d3 1
a3 1
 * Version:  6.5.2
d43 1
a43 2

/**
d48 5
a52 5
fast_draw_rgba_pixels(GLcontext *ctx, GLint x, GLint y,
                      GLsizei width, GLsizei height,
                      GLenum format, GLenum type,
                      const struct gl_pixelstore_attrib *userUnpack,
                      const GLvoid *pixels)
a55 1
   const GLenum rbType = rb->DataType;
d57 9
a65 11
   SWspan span;
   GLboolean simpleZoom;
   GLint yStep;  /* +1 or -1 */
   struct gl_pixelstore_attrib unpack;
   GLint destX, destY, drawWidth, drawHeight; /* post clipping */

   if ((swrast->_RasterMask & ~CLIP_BIT) ||
       ctx->Texture._EnabledCoordUnits ||
       userUnpack->SwapBytes ||
       ctx->_ImageTransferState) {
      /* can't handle any of those conditions */
a68 1
   INIT_SPAN(span, GL_BITMAP, 0, 0, SPAN_RGBA);
d76 5
a80 26
   /* copy input params since clipping may change them */
   unpack = *userUnpack;
   destX = x;
   destY = y;
   drawWidth = width;
   drawHeight = height;

   /* check for simple zooming and clipping */
   if (ctx->Pixel.ZoomX == 1.0F &&
       (ctx->Pixel.ZoomY == 1.0F || ctx->Pixel.ZoomY == -1.0F)) {
      if (!_mesa_clip_drawpixels(ctx, &destX, &destY,
                                 &drawWidth, &drawHeight, &unpack)) {
         /* image was completely clipped: no-op, all done */
         return GL_TRUE;
      }
      simpleZoom = GL_TRUE;
      yStep = (GLint) ctx->Pixel.ZoomY;
      ASSERT(yStep == 1 || yStep == -1);
   }
   else {
      /* non-simple zooming */
      simpleZoom = GL_FALSE;
      yStep = 1;
      if (unpack.RowLength == 0)
         unpack.RowLength = width;
   }
d82 31
a112 3
   /*
    * Ready to draw!
    */
d114 10
a123 12
   if (format == GL_RGBA && type == rbType) {
      const GLubyte *src = _mesa_image_address2d(&unpack, pixels, width,
                                                 height, format, type, 0, 0);
      const GLint srcStride = _mesa_image_row_stride(&unpack, width,
                                                     format, type);
      if (simpleZoom) {
         GLint row;
         for (row = 0; row < drawHeight; row++) {
            rb->PutRow(ctx, rb, drawWidth, destX, destY, src, NULL);
            src += srcStride;
            destY += yStep;
         }
d125 12
a136 15
      else {
         /* with zooming */
         GLint row;
         for (row = 0; row < drawHeight; row++) {
            span.x = destX;
            span.y = destY + row;
            span.end = drawWidth;
            span.array->ChanType = rbType;
            _swrast_write_zoomed_rgba_span(ctx, imgX, imgY, &span, src);
            src += srcStride;
         }
         span.array->ChanType = CHAN_TYPE;
      }
      return GL_TRUE;
   }
d138 10
a147 12
   if (format == GL_RGB && type == rbType) {
      const GLubyte *src = _mesa_image_address2d(&unpack, pixels, width,
                                                 height, format, type, 0, 0);
      const GLint srcStride = _mesa_image_row_stride(&unpack, width,
                                                     format, type);
      if (simpleZoom) {
         GLint row;
         for (row = 0; row < drawHeight; row++) {
            rb->PutRowRGB(ctx, rb, drawWidth, destX, destY, src, NULL);
            src += srcStride;
            destY += yStep;
         }
d150 2
a151 12
         /* with zooming */
         GLint row;
         for (row = 0; row < drawHeight; row++) {
            span.x = destX;
            span.y = destY;
            span.end = drawWidth;
            span.array->ChanType = rbType;
            _swrast_write_zoomed_rgb_span(ctx, imgX, imgY, &span, src);
            src += srcStride;
            destY++;
         }
         span.array->ChanType = CHAN_TYPE;
a152 2
      return GL_TRUE;
   }
a153 3
   /* Remaining cases haven't been tested with alignment != 1 */
   if (userUnpack->Alignment != 1)
      return GL_FALSE;
d155 42
a196 18
   if (format == GL_LUMINANCE && type == CHAN_TYPE && rbType == CHAN_TYPE) {
      const GLchan *src = (const GLchan *) pixels
         + (unpack.SkipRows * unpack.RowLength + unpack.SkipPixels);
      if (simpleZoom) {
         /* no zooming */
         GLint row;
         ASSERT(drawWidth <= MAX_WIDTH);
         for (row = 0; row < drawHeight; row++) {
            GLchan rgb[MAX_WIDTH][3];
            GLint i;
            for (i = 0;i<drawWidth;i++) {
               rgb[i][0] = src[i];
               rgb[i][1] = src[i];
               rgb[i][2] = src[i];
            }
            rb->PutRowRGB(ctx, rb, drawWidth, destX, destY, rgb, NULL);
            src += unpack.RowLength;
            destY += yStep;
d198 1
d200 34
a233 18
      else {
         /* with zooming */
         GLint row;
         ASSERT(drawWidth <= MAX_WIDTH);
         for (row = 0; row < drawHeight; row++) {
            GLchan rgb[MAX_WIDTH][3];
            GLint i;
            for (i = 0;i<drawWidth;i++) {
               rgb[i][0] = src[i];
               rgb[i][1] = src[i];
               rgb[i][2] = src[i];
            }
            span.x = destX;
            span.y = destY;
            span.end = drawWidth;
            _swrast_write_zoomed_rgb_span(ctx, imgX, imgY, &span, rgb);
            src += unpack.RowLength;
            destY++;
d235 1
d237 58
a294 22
      return GL_TRUE;
   }

   if (format == GL_LUMINANCE_ALPHA && type == CHAN_TYPE && rbType == CHAN_TYPE) {
      const GLchan *src = (const GLchan *) pixels
         + (unpack.SkipRows * unpack.RowLength + unpack.SkipPixels)*2;
      if (simpleZoom) {
         GLint row;
         ASSERT(drawWidth <= MAX_WIDTH);
         for (row = 0; row < drawHeight; row++) {
            GLint i;
            const GLchan *ptr = src;
            for (i = 0;i<drawWidth;i++) {
               span.array->rgba[i][0] = *ptr;
               span.array->rgba[i][1] = *ptr;
               span.array->rgba[i][2] = *ptr++;
               span.array->rgba[i][3] = *ptr++;
            }
            rb->PutRow(ctx, rb, drawWidth, destX, destY,
                       span.array->rgba, NULL);
            src += unpack.RowLength*2;
            destY += yStep;
d296 1
d298 64
a361 20
      else {
         /* with zooming */
         GLint row;
         ASSERT(drawWidth <= MAX_WIDTH);
         for (row = 0; row < drawHeight; row++) {
            const GLchan *ptr = src;
            GLint i;
            for (i = 0;i<drawWidth;i++) {
               span.array->rgba[i][0] = *ptr;
               span.array->rgba[i][1] = *ptr;
               span.array->rgba[i][2] = *ptr++;
               span.array->rgba[i][3] = *ptr++;
            }
            span.x = destX;
            span.y = destY;
            span.end = drawWidth;
            _swrast_write_zoomed_rgba_span(ctx, imgX, imgY, &span,
                                           span.array->rgba);
            src += unpack.RowLength*2;
            destY++;
d363 1
d365 46
a410 18
      return GL_TRUE;
   }

   if (format == GL_COLOR_INDEX && type == GL_UNSIGNED_BYTE) {
      const GLubyte *src = (const GLubyte *) pixels
         + unpack.SkipRows * unpack.RowLength + unpack.SkipPixels;
      if (ctx->Visual.rgbMode && rbType == GL_UNSIGNED_BYTE) {
         /* convert ubyte/CI data to ubyte/RGBA */
         if (simpleZoom) {
            GLint row;
            for (row = 0; row < drawHeight; row++) {
               ASSERT(drawWidth <= MAX_WIDTH);
               _mesa_map_ci8_to_rgba8(ctx, drawWidth, src,
                                      span.array->color.sz1.rgba);
               rb->PutRow(ctx, rb, drawWidth, destX, destY,
                          span.array->color.sz1.rgba, NULL);
               src += unpack.RowLength;
               destY += yStep;
d414 1
a414 1
            /* ubyte/CI to ubyte/RGBA with zooming */
d416 16
a431 11
            for (row = 0; row < drawHeight; row++) {
               ASSERT(drawWidth <= MAX_WIDTH);
               _mesa_map_ci8_to_rgba8(ctx, drawWidth, src,
                                      span.array->color.sz1.rgba);
               span.x = destX;
               span.y = destY;
               span.end = drawWidth;
               _swrast_write_zoomed_rgba_span(ctx, imgX, imgY, &span,
                                              span.array->color.sz1.rgba);
               src += unpack.RowLength;
               destY++;
a433 1
         return GL_TRUE;
d435 3
a437 15
      else if (!ctx->Visual.rgbMode && rbType == GL_UNSIGNED_INT) {
         /* write CI data to CI frame buffer */
         GLint row;
         if (simpleZoom) {
            for (row = 0; row < drawHeight; row++) {
               GLuint index32[MAX_WIDTH];
               GLint col;
               for (col = 0; col < drawWidth; col++)
                  index32[col] = src[col];
               rb->PutRow(ctx, rb, drawWidth, destX, destY, index32, NULL);
               src += unpack.RowLength;
               destY += yStep;
            }
            return GL_TRUE;
         }
d441 1
a441 1
   /* can't handle this pixel format and/or data type */
d461 1
a461 1
   SWspan span;
d533 7
a539 1
         _mesa_apply_stencil_transfer_ops(ctx, spanWidth, values);
d567 1
a567 1
   SWspan span;
d668 1
a668 1
/**
d680 1
d682 1
d684 4
a687 2
   GLbitfield transferOps = ctx->_ImageTransferState;
   SWspan span;
d690 1
a690 2
   if (fast_draw_rgba_pixels(ctx, x, y, width, height, format, type,
                             unpack, pixels))
a692 1
   INIT_SPAN(span, GL_BITMAP, 0, 0, SPAN_RGBA);
d700 12
a762 7
   if (ctx->DrawBuffer->_NumColorDrawBuffers[0] > 0 &&
       ctx->DrawBuffer->_ColorDrawBuffers[0][0]->DataType != GL_FLOAT &&
       ctx->Color.ClampFragmentColor != GL_FALSE) {
      /* need to clamp colors before applying fragment ops */
      transferOps |= IMAGE_CLAMP_BIT;
   }

a766 2
      const GLboolean sink = (ctx->Pixel.MinMaxEnabled && ctx->MinMax.Sink)
         || (ctx->Pixel.HistogramEnabled && ctx->Histogram.Sink);
a768 2
      const GLint srcStride
         = _mesa_image_row_stride(unpack, width, format, type);
a769 2
      /* use span array for temp color storage */
      GLfloat *rgba = (GLfloat *) span.array->color.sz4.rgba;
a773 2
         const GLubyte *source = _mesa_image_address2d(unpack, pixels,
                               width, height, format, type, 0, skipPixels);
d776 2
d779 21
a799 4
            /* get image row as float/RGBA */
            _mesa_unpack_color_span_float(ctx, spanWidth, GL_RGBA, rgba,
                                     format, type, source, unpack,
                                     transferOps);
d801 10
a810 16
            if (!sink) {
               /* Set these for each row since the _swrast_write_* functions
                * may change them while clipping/rendering.
                */
               span.array->ChanType = GL_FLOAT;
               span.x = x + skipPixels;
               span.y = y + row;
               span.end = spanWidth;
               span.arrayMask = arrayMask;
               span.interpMask = interpMask;
               if (zoom) {
                  _swrast_write_zoomed_rgba_span(ctx, imgX, imgY, &span, rgba);
               }
               else {
                  _swrast_write_rgba_span(ctx, &span);
               }
d812 1
a812 3

            source += srcStride;
         } /* for row */
d815 1
a815 4
      } /* while skipPixels < width */

      /* XXX this is ugly/temporary, to undo above change */
      span.array->ChanType = CHAN_TYPE;
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d3 1
a3 1
 * Version:  7.0.1
d5 1
a5 1
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
a73 1
   _swrast_span_default_secondary_color(ctx, &span);
d113 2
a114 3
      const GLubyte *src
         = (const GLubyte *) _mesa_image_address2d(&unpack, pixels, width,
                                                   height, format, type, 0, 0);
d142 2
a143 3
      const GLubyte *src
         = (const GLubyte *) _mesa_image_address2d(&unpack, pixels, width,
                                                   height, format, type, 0, 0);
d406 4
a409 3
         _mesa_unpack_stencil_span(ctx, spanWidth, destType, values,
                                   type, source, unpack,
                                   ctx->_ImageTransferState);
d442 1
a442 1
   _swrast_span_default_secondary_color(ctx, &span);
d453 1
a453 2
       && width <= MAX_WIDTH
       && !unpack->SwapBytes) {
d473 1
a473 2
            && width <= MAX_WIDTH
            && !unpack->SwapBytes) {
a560 1
   _swrast_span_default_secondary_color(ctx, &span);
a617 5
   else if (ctx->Pixel.Convolution1DEnabled) {
      /* we only want to apply 1D convolution to glTexImage1D */
      transferOps &= ~(IMAGE_CONVOLUTION_BIT |
                       IMAGE_POST_CONVOLUTION_SCALE_BIAS);
   }
d638 1
a638 1
      GLfloat *rgba = (GLfloat *) span.array->attribs[FRAG_ATTRIB_COL0];
d643 2
a644 4
         const GLubyte *source
            = (const GLubyte *) _mesa_image_address2d(unpack, pixels,
                                                      width, height, format,
                                                      type, 0, skipPixels);
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d3 1
a3 1
 * Version:  7.1
d26 9
a34 10
#include "main/glheader.h"
#include "main/bufferobj.h"
#include "main/condrender.h"
#include "main/context.h"
#include "main/image.h"
#include "main/imports.h"
#include "main/macros.h"
#include "main/pack.h"
#include "main/pixeltransfer.h"
#include "main/state.h"
d37 1
d49 1
a49 1
fast_draw_rgba_pixels(struct gl_context *ctx, GLint x, GLint y,
d56 2
a57 2
   struct gl_renderbuffer *rb = ctx->DrawBuffer->_ColorDrawBuffers[0];
   GLenum rbType;
a64 5
   if (!rb)
      return GL_TRUE; /* no-op */

   rbType = rb->DataType;

d73 8
a80 4
   INIT_SPAN(span, GL_BITMAP);
   span.arrayMask = SPAN_RGBA;
   span.arrayAttribs = FRAG_BIT_COL0;
   _swrast_span_default_attribs(ctx, &span);
d270 1
a270 1
      if (rbType == GL_UNSIGNED_BYTE) {
d277 1
a277 1
                                      span.array->rgba8);
d279 1
a279 1
                          span.array->rgba8, NULL);
d290 1
a290 1
                                      span.array->rgba8);
d295 1
a295 1
                                              span.array->rgba8);
d302 16
d327 55
d385 1
a385 1
draw_stencil_pixels( struct gl_context *ctx, GLint x, GLint y,
d429 1
a429 1
draw_depth_pixels( struct gl_context *ctx, GLint x, GLint y,
d435 1
d441 8
a448 3
   INIT_SPAN(span, GL_BITMAP);
   span.arrayMask = SPAN_Z;
   _swrast_span_default_attribs(ctx, &span);
d454 1
d475 1
d486 1
a486 1
            memcpy(span.array->z, zSrc, width * sizeof(GLuint));
d501 1
a501 1
      const GLuint depthMax = ctx->DrawBuffer->_DepthMax;
d528 3
d532 1
a532 1
               _swrast_write_rgba_span(ctx, &span);
d546 1
a546 1
draw_rgba_pixels( struct gl_context *ctx, GLint x, GLint y,
d552 1
d561 1
a561 1
                             unpack, pixels)) {
d563 64
d629 2
a630 7
   INIT_SPAN(span, GL_BITMAP);
   _swrast_span_default_attribs(ctx, &span);
   span.arrayMask = SPAN_RGBA;
   span.arrayAttribs = FRAG_BIT_COL0; /* we're fill in COL0 attrib values */

   if (ctx->DrawBuffer->_NumColorDrawBuffers > 0 &&
       ctx->DrawBuffer->_ColorDrawBuffers[0]->DataType != GL_FLOAT &&
d640 2
d664 18
a681 15
	    /* Set these for each row since the _swrast_write_* functions
	     * may change them while clipping/rendering.
	     */
	    span.array->ChanType = GL_FLOAT;
	    span.x = x + skipPixels;
	    span.y = y + row;
	    span.end = spanWidth;
	    span.arrayMask = arrayMask;
	    span.interpMask = interpMask;
	    if (zoom) {
	       _swrast_write_zoomed_rgba_span(ctx, imgX, imgY, &span, rgba);
	    }
	    else {
	       _swrast_write_rgba_span(ctx, &span);
	    }
d694 1
a694 1
      free(convImage);
d708 1
a708 1
draw_depth_stencil_pixels(struct gl_context *ctx, GLint x, GLint y,
d716 1
a716 1
   const GLuint depthMax = ctx->DrawBuffer->_DepthMax;
d804 1
a804 1
                                       depthRb->DataType, zValues, depthMax,
d833 1
d839 1
a839 1
_swrast_DrawPixels( struct gl_context *ctx,
a846 1
   GLboolean save_vp_override = ctx->VertexProgram._Overriden;
d848 1
a848 14
   if (!_mesa_check_conditional_render(ctx))
      return; /* don't draw */

   /* We are creating fragments directly, without going through vertex
    * programs.
    *
    * This override flag tells the fragment processing code that its input
    * comes from a non-standard source, and it may therefore not rely on
    * optimizations that assume e.g. constant color if there is no color
    * vertex array.
    */
   _mesa_set_vp_override(ctx, GL_TRUE);

   swrast_render_start(ctx);
d856 18
a873 5
   pixels = _mesa_map_pbo_source(ctx, unpack, pixels);
   if (!pixels) {
      swrast_render_finish(ctx);
      _mesa_set_vp_override(ctx, save_vp_override);
      return;
a875 3
   /*
    * By time we get here, all error checking should have been done.
    */
d883 19
d903 2
a904 1
      draw_depth_stencil_pixels(ctx, x, y, width, height, type, unpack, pixels);
d907 12
a918 2
      /* all other formats should be color formats */
      draw_rgba_pixels(ctx, x, y, width, height, format, type, unpack, pixels);
d920 18
d939 31
a969 2
   swrast_render_finish(ctx);
   _mesa_set_vp_override(ctx, save_vp_override);
d971 1
a971 1
   _mesa_unmap_pbo_source(ctx, unpack);
d973 1
@


1.1.1.5
log
@Import Mesa 9.2.0
@
text
@d3 1
d20 3
a22 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
a27 1
#include "main/colormac.h"
a29 1
#include "main/format_pack.h"
a33 1
#include "main/pbo.h"
a42 140
/**
 * Handle a common case of drawing GL_RGB/GL_UNSIGNED_BYTE into a
 * MESA_FORMAT_XRGB888 or MESA_FORMAT_ARGB888 renderbuffer.
 */
static void
fast_draw_rgb_ubyte_pixels(struct gl_context *ctx,
                           struct gl_renderbuffer *rb,
                           GLint x, GLint y,
                           GLsizei width, GLsizei height,
                           const struct gl_pixelstore_attrib *unpack,
                           const GLvoid *pixels)
{
   const GLubyte *src = (const GLubyte *)
      _mesa_image_address2d(unpack, pixels, width,
                            height, GL_RGB, GL_UNSIGNED_BYTE, 0, 0);
   const GLint srcRowStride = _mesa_image_row_stride(unpack, width,
                                                     GL_RGB, GL_UNSIGNED_BYTE);
   GLint i, j;
   GLubyte *dst;
   GLint dstRowStride;

   ctx->Driver.MapRenderbuffer(ctx, rb, x, y, width, height,
                               GL_MAP_WRITE_BIT, &dst, &dstRowStride);

   if (!dst) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glDrawPixels");
      return;
   }

   if (ctx->Pixel.ZoomY == -1.0f) {
      dst = dst + (height - 1) * dstRowStride;
      dstRowStride = -dstRowStride;
   }

   for (i = 0; i < height; i++) {
      GLuint *dst4 = (GLuint *) dst;
      for (j = 0; j < width; j++) {
         dst4[j] = PACK_COLOR_8888(0xff, src[j*3+0], src[j*3+1], src[j*3+2]);
      }
      dst += dstRowStride;
      src += srcRowStride;
   }

   ctx->Driver.UnmapRenderbuffer(ctx, rb);
}


/**
 * Handle a common case of drawing GL_RGBA/GL_UNSIGNED_BYTE into a
 * MESA_FORMAT_ARGB888 or MESA_FORMAT_xRGB888 renderbuffer.
 */
static void
fast_draw_rgba_ubyte_pixels(struct gl_context *ctx,
                           struct gl_renderbuffer *rb,
                           GLint x, GLint y,
                           GLsizei width, GLsizei height,
                           const struct gl_pixelstore_attrib *unpack,
                           const GLvoid *pixels)
{
   const GLubyte *src = (const GLubyte *)
      _mesa_image_address2d(unpack, pixels, width,
                            height, GL_RGBA, GL_UNSIGNED_BYTE, 0, 0);
   const GLint srcRowStride =
      _mesa_image_row_stride(unpack, width, GL_RGBA, GL_UNSIGNED_BYTE);
   GLint i, j;
   GLubyte *dst;
   GLint dstRowStride;

   ctx->Driver.MapRenderbuffer(ctx, rb, x, y, width, height,
                               GL_MAP_WRITE_BIT, &dst, &dstRowStride);

   if (!dst) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glDrawPixels");
      return;
   }

   if (ctx->Pixel.ZoomY == -1.0f) {
      dst = dst + (height - 1) * dstRowStride;
      dstRowStride = -dstRowStride;
   }

   for (i = 0; i < height; i++) {
      GLuint *dst4 = (GLuint *) dst;
      for (j = 0; j < width; j++) {
         dst4[j] = PACK_COLOR_8888(src[j*4+3], src[j*4+0],
                                   src[j*4+1], src[j*4+2]);
      }
      dst += dstRowStride;
      src += srcRowStride;
   }

   ctx->Driver.UnmapRenderbuffer(ctx, rb);
}


/**
 * Handle a common case of drawing a format/type combination that
 * exactly matches the renderbuffer format.
 */
static void
fast_draw_generic_pixels(struct gl_context *ctx,
                         struct gl_renderbuffer *rb,
                         GLint x, GLint y,
                         GLsizei width, GLsizei height,
                         GLenum format, GLenum type,
                         const struct gl_pixelstore_attrib *unpack,
                         const GLvoid *pixels)
{
   const GLubyte *src = (const GLubyte *)
      _mesa_image_address2d(unpack, pixels, width,
                            height, format, type, 0, 0);
   const GLint srcRowStride =
      _mesa_image_row_stride(unpack, width, format, type);
   const GLint rowLength = width * _mesa_get_format_bytes(rb->Format);
   GLint i;
   GLubyte *dst;
   GLint dstRowStride;

   ctx->Driver.MapRenderbuffer(ctx, rb, x, y, width, height,
                               GL_MAP_WRITE_BIT, &dst, &dstRowStride);

   if (!dst) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glDrawPixels");
      return;
   }

   if (ctx->Pixel.ZoomY == -1.0f) {
      dst = dst + (height - 1) * dstRowStride;
      dstRowStride = -dstRowStride;
   }

   for (i = 0; i < height; i++) {
      memcpy(dst, src, rowLength);
      dst += dstRowStride;
      src += srcRowStride;
   }

   ctx->Driver.UnmapRenderbuffer(ctx, rb);
}

d55 1
d57 1
d59 3
d63 1
d68 3
a70 2
   if (ctx->DrawBuffer->_NumColorDrawBuffers > 1 ||
       (swrast->_RasterMask & ~CLIP_BIT) ||
a72 2
       ctx->Pixel.ZoomX != 1.0f ||
       fabsf(ctx->Pixel.ZoomY) != 1.0f ||
d78 6
d85 24
d110 31
a140 3
   /* clipping */
   if (!_mesa_clip_drawpixels(ctx, &x, &y, &width, &height, &unpack)) {
      /* image was completely clipped: no-op, all done */
d144 28
a171 6
   if (format == GL_RGB &&
       type == GL_UNSIGNED_BYTE &&
       (rb->Format == MESA_FORMAT_XRGB8888 ||
        rb->Format == MESA_FORMAT_ARGB8888)) {
      fast_draw_rgb_ubyte_pixels(ctx, rb, x, y, width, height,
                                 &unpack, pixels);
d175 44
a218 6
   if (format == GL_RGBA &&
       type == GL_UNSIGNED_BYTE &&
       (rb->Format == MESA_FORMAT_XRGB8888 ||
        rb->Format == MESA_FORMAT_ARGB8888)) {
      fast_draw_rgba_ubyte_pixels(ctx, rb, x, y, width, height,
                                  &unpack, pixels);
d222 43
a264 4
   if (_mesa_format_matches_format_and_type(rb->Format, format, type,
                                            ctx->Unpack.SwapBytes)) {
      fast_draw_generic_pixels(ctx, rb, x, y, width, height,
                               format, type, &unpack, pixels);
d268 37
d322 1
a322 9
   const GLenum destType = GL_UNSIGNED_BYTE;
   GLint row;
   GLubyte *values;

   values = malloc(width * sizeof(GLubyte));
   if (!values) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glDrawPixels");
      return;
   }
d324 25
a348 14
   for (row = 0; row < height; row++) {
      const GLvoid *source = _mesa_image_address2d(unpack, pixels,
                                                   width, height,
                                                   GL_STENCIL_INDEX, type,
                                                   row, 0);
      _mesa_unpack_stencil_span(ctx, width, destType, values,
                                type, source, unpack,
                                ctx->_ImageTransferState);
      if (zoom) {
         _swrast_write_zoomed_stencil_span(ctx, x, y, width,
                                           x, y, values);
      }
      else {
         _swrast_write_stencil_span(ctx, width, x, y, values);
d350 1
a350 2

      y++;
a351 2

   free(values);
d378 1
a378 1
       && width <= SWRAST_MAX_WIDTH
d398 1
a398 1
            && width <= SWRAST_MAX_WIDTH
d426 1
a426 1
      /* in case width > SWRAST_MAX_WIDTH do the copy in chunks */
d428 1
a428 1
         const GLint spanWidth = MIN2(width - skipPixels, SWRAST_MAX_WIDTH);
d430 1
a430 1
         ASSERT(span.end <= SWRAST_MAX_WIDTH);
a482 2
   swrast_render_start(ctx);

d486 1
a486 1
   span.arrayAttribs = VARYING_BIT_COL0; /* we're fill in COL0 attrib values */
d488 5
a492 8
   if (ctx->DrawBuffer->_NumColorDrawBuffers > 0) {
      GLenum datatype = _mesa_get_format_datatype(
                 ctx->DrawBuffer->_ColorDrawBuffers[0]->Format);
      if (datatype != GL_FLOAT &&
          ctx->Color.ClampFragmentColor != GL_FALSE) {
         /* need to clamp colors before applying fragment ops */
         transferOps |= IMAGE_CLAMP_BIT;
      }
d505 1
a505 1
      GLfloat *rgba = (GLfloat *) span.array->attribs[VARYING_SLOT_COL0];
d507 1
a507 1
      /* if the span is wider than SWRAST_MAX_WIDTH we have to do it in chunks */
d509 1
a509 1
         const GLint spanWidth = MIN2(width - skipPixels, SWRAST_MAX_WIDTH);
d547 2
a548 37
   free(convImage);

   swrast_render_finish(ctx);
}


/**
 * Draw depth+stencil values into a MESA_FORAMT_Z24_S8 or MESA_FORMAT_S8_Z24
 * renderbuffer.  No masking, zooming, scaling, etc.
 */
static void
fast_draw_depth_stencil(struct gl_context *ctx, GLint x, GLint y,
                        GLsizei width, GLsizei height,
                        const struct gl_pixelstore_attrib *unpack,
                        const GLvoid *pixels)
{
   const GLenum format = GL_DEPTH_STENCIL_EXT;
   const GLenum type = GL_UNSIGNED_INT_24_8;
   struct gl_renderbuffer *rb =
      ctx->DrawBuffer->Attachment[BUFFER_DEPTH].Renderbuffer;
   struct swrast_renderbuffer *srb = swrast_renderbuffer(rb);
   GLubyte *src, *dst;
   GLint srcRowStride, dstRowStride;
   GLint i;

   src = _mesa_image_address2d(unpack, pixels, width, height,
                               format, type, 0, 0);
   srcRowStride = _mesa_image_row_stride(unpack, width, format, type);

   dst = _swrast_pixel_address(rb, x, y);
   dstRowStride = srb->RowStride;

   for (i = 0; i < height; i++) {
      _mesa_pack_uint_24_8_depth_stencil_row(rb->Format, width,
                                             (const GLuint *) src, dst);
      dst += dstRowStride;
      src += srcRowStride;
a552 1

d570 1
d572 2
a573 1
   const GLenum stencilType = GL_UNSIGNED_BYTE;
d591 3
a593 4
   if (depthRb == stencilRb &&
       (depthRb->Format == MESA_FORMAT_Z24_S8 ||
        depthRb->Format == MESA_FORMAT_S8_Z24) &&
       type == GL_UNSIGNED_INT_24_8 &&
d598 11
a608 2
      fast_draw_depth_stencil(ctx, x, y, width, height,
                              &clippedUnpack, pixels);
a614 1
      GLuint *zValues;  /* 32-bit Z values */
d617 2
a618 5
      zValues = malloc(width * sizeof(GLuint));
      if (!zValues) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glDrawPixels");
         return;
      }
d626 27
a652 10
            _mesa_unpack_depth_span(ctx, width,
                                    GL_UNSIGNED_INT, /* dest type */
                                    zValues,         /* dest addr */
                                    0xffffffff,      /* depth max */
                                    type,            /* src type */
                                    depthStencilSrc, /* src addr */
                                    &clippedUnpack);
            if (zoom) {
               _swrast_write_zoomed_z_span(ctx, imgX, imgY, width, x,
                                           y + i, zValues);
d655 12
a666 2
               GLubyte *dst = _swrast_pixel_address(depthRb, x, y + i);
               _mesa_pack_uint_z_row(depthRb->Format, width, zValues, dst);
d671 1
a671 1
            GLubyte *stencilValues = (GLubyte *) zValues; /* re-use buffer */
a682 2

      free(zValues);
d715 2
d725 1
a734 1
      swrast_render_start(ctx);
a735 1
      swrast_render_finish(ctx);
a737 1
      swrast_render_start(ctx);
a738 1
      swrast_render_finish(ctx);
a740 1
      swrast_render_start(ctx);
a741 1
      swrast_render_finish(ctx);
d748 1
@


1.1.1.6
log
@Import Mesa 10.2.3
@
text
@d226 2
a227 2
       (rb->Format == MESA_FORMAT_B8G8R8X8_UNORM ||
        rb->Format == MESA_FORMAT_B8G8R8A8_UNORM)) {
d235 2
a236 2
       (rb->Format == MESA_FORMAT_B8G8R8X8_UNORM ||
        rb->Format == MESA_FORMAT_B8G8R8A8_UNORM)) {
d503 1
a503 1
 * Draw depth+stencil values into a MESA_FORAMT_Z24_S8 or MESA_FORMAT_Z24_UNORM_S8_UINT
d575 2
a576 2
       (depthRb->Format == MESA_FORMAT_S8_UINT_Z24_UNORM ||
        depthRb->Format == MESA_FORMAT_Z24_UNORM_S8_UINT) &&
@


