head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.6
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.4
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.4
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.4
	OPENBSD_5_6:1.7.0.2
	OPENBSD_5_6_BASE:1.7
	v10_2_3:1.1.1.4
	OPENBSD_5_5:1.6.0.2
	OPENBSD_5_5_BASE:1.6
	v9_2_5:1.1.1.3
	v9_2_3:1.1.1.3
	v9_2_2:1.1.1.3
	v9_2_1:1.1.1.3
	v9_2_0:1.1.1.3
	OPENBSD_5_4:1.5.0.8
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.6
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	v7_10_3:1.1.1.2
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v7_0_1:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v6_5_2:1.1.1.1
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.55;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2014.07.09.21.09.01;	author jsg;	state Exp;
branches;
next	1.6;
commitid	WPD6rgPryPkvXOr9;

1.6
date	2013.09.05.14.06.48;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.23.13.37.45;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.34;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.42;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.23;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.51.17;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.51.17;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2011.10.23.13.29.48;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2013.09.05.13.17.29;	author jsg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.07.09.20.35.12;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */


#include "main/glheader.h"
#include "main/condrender.h"
#include "main/image.h"
#include "main/macros.h"
#include "main/format_unpack.h"
#include "main/format_pack.h"
#include "main/condrender.h"
#include "s_context.h"


#define ABS(X)   ((X) < 0 ? -(X) : (X))


/**
 * Generate a row resampler function for GL_NEAREST mode.
 */
#define RESAMPLE(NAME, PIXELTYPE, SIZE)			\
static void						\
NAME(GLint srcWidth, GLint dstWidth,			\
     const GLvoid *srcBuffer, GLvoid *dstBuffer,	\
     GLboolean flip)					\
{							\
   const PIXELTYPE *src = (const PIXELTYPE *) srcBuffer;\
   PIXELTYPE *dst = (PIXELTYPE *) dstBuffer;		\
   GLint dstCol;					\
							\
   if (flip) {						\
      for (dstCol = 0; dstCol < dstWidth; dstCol++) {	\
         GLint srcCol = (dstCol * srcWidth) / dstWidth;	\
         ASSERT(srcCol >= 0);				\
         ASSERT(srcCol < srcWidth);			\
         srcCol = srcWidth - 1 - srcCol; /* flip */	\
         if (SIZE == 1) {				\
            dst[dstCol] = src[srcCol];			\
         }						\
         else if (SIZE == 2) {				\
            dst[dstCol*2+0] = src[srcCol*2+0];		\
            dst[dstCol*2+1] = src[srcCol*2+1];		\
         }						\
         else if (SIZE == 4) {				\
            dst[dstCol*4+0] = src[srcCol*4+0];		\
            dst[dstCol*4+1] = src[srcCol*4+1];		\
            dst[dstCol*4+2] = src[srcCol*4+2];		\
            dst[dstCol*4+3] = src[srcCol*4+3];		\
         }						\
      }							\
   }							\
   else {						\
      for (dstCol = 0; dstCol < dstWidth; dstCol++) {	\
         GLint srcCol = (dstCol * srcWidth) / dstWidth;	\
         ASSERT(srcCol >= 0);				\
         ASSERT(srcCol < srcWidth);			\
         if (SIZE == 1) {				\
            dst[dstCol] = src[srcCol];			\
         }						\
         else if (SIZE == 2) {				\
            dst[dstCol*2+0] = src[srcCol*2+0];		\
            dst[dstCol*2+1] = src[srcCol*2+1];		\
         }						\
         else if (SIZE == 4) {				\
            dst[dstCol*4+0] = src[srcCol*4+0];		\
            dst[dstCol*4+1] = src[srcCol*4+1];		\
            dst[dstCol*4+2] = src[srcCol*4+2];		\
            dst[dstCol*4+3] = src[srcCol*4+3];		\
         }						\
      }							\
   }							\
}

/**
 * Resamplers for 1, 2, 4, 8 and 16-byte pixels.
 */
RESAMPLE(resample_row_1, GLubyte, 1)
RESAMPLE(resample_row_2, GLushort, 1)
RESAMPLE(resample_row_4, GLuint, 1)
RESAMPLE(resample_row_8, GLuint, 2)
RESAMPLE(resample_row_16, GLuint, 4)


/**
 * Blit color, depth or stencil with GL_NEAREST filtering.
 */
static void
blit_nearest(struct gl_context *ctx,
             GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1,
             GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1,
             GLbitfield buffer)
{
   struct gl_renderbuffer *readRb, *drawRb = NULL;
   struct gl_renderbuffer_attachment *readAtt = NULL, *drawAtt = NULL;
   struct gl_framebuffer *readFb = ctx->ReadBuffer;
   struct gl_framebuffer *drawFb = ctx->DrawBuffer;
   GLuint numDrawBuffers = 0;
   GLuint i;

   const GLint srcWidth = ABS(srcX1 - srcX0);
   const GLint dstWidth = ABS(dstX1 - dstX0);
   const GLint srcHeight = ABS(srcY1 - srcY0);
   const GLint dstHeight = ABS(dstY1 - dstY0);

   const GLint srcXpos = MIN2(srcX0, srcX1);
   const GLint srcYpos = MIN2(srcY0, srcY1);
   const GLint dstXpos = MIN2(dstX0, dstX1);
   const GLint dstYpos = MIN2(dstY0, dstY1);

   const GLboolean invertX = (srcX1 < srcX0) ^ (dstX1 < dstX0);
   const GLboolean invertY = (srcY1 < srcY0) ^ (dstY1 < dstY0);
   enum mode {
      DIRECT,
      UNPACK_RGBA_FLOAT,
      UNPACK_Z_FLOAT,
      UNPACK_Z_INT,
      UNPACK_S,
   } mode = DIRECT;
   GLubyte *srcMap, *dstMap;
   GLint srcRowStride, dstRowStride;
   GLint dstRow;

   GLint pixelSize = 0;
   GLvoid *srcBuffer, *dstBuffer;
   GLint prevY = -1;

   typedef void (*resample_func)(GLint srcWidth, GLint dstWidth,
                                 const GLvoid *srcBuffer, GLvoid *dstBuffer,
                                 GLboolean flip);
   resample_func resampleRow;

   switch (buffer) {
   case GL_COLOR_BUFFER_BIT:
      readAtt = &readFb->Attachment[readFb->_ColorReadBufferIndex];
      readRb = readFb->_ColorReadBuffer;
      numDrawBuffers = drawFb->_NumColorDrawBuffers;
      break;
   case GL_DEPTH_BUFFER_BIT:
      readAtt = &readFb->Attachment[BUFFER_DEPTH];
      drawAtt = &drawFb->Attachment[BUFFER_DEPTH];
      readRb = readAtt->Renderbuffer;
      drawRb = drawAtt->Renderbuffer;
      numDrawBuffers = 1;

      /* Note that for depth/stencil, the formats of src/dst must match.  By
       * using the core helpers for pack/unpack, we avoid needing to handle
       * masking for things like DEPTH copies of Z24S8.
       */
      if (readRb->Format == MESA_FORMAT_Z_FLOAT32 ||
	  readRb->Format == MESA_FORMAT_Z32_FLOAT_S8X24_UINT) {
	 mode = UNPACK_Z_FLOAT;
      } else {
	 mode = UNPACK_Z_INT;
      }
      pixelSize = 4;
      break;
   case GL_STENCIL_BUFFER_BIT:
      readAtt = &readFb->Attachment[BUFFER_STENCIL];
      drawAtt = &drawFb->Attachment[BUFFER_STENCIL];
      readRb = readAtt->Renderbuffer;
      drawRb = drawAtt->Renderbuffer;
      numDrawBuffers = 1;
      mode = UNPACK_S;
      pixelSize = 1;
      break;
   default:
      _mesa_problem(ctx, "unexpected buffer in blit_nearest()");
      return;
   }

   /* allocate the src/dst row buffers */
   srcBuffer = malloc(MAX_PIXEL_BYTES * srcWidth);
   dstBuffer = malloc(MAX_PIXEL_BYTES * dstWidth);
   if (!srcBuffer || !dstBuffer)
      goto fail_no_memory;

   /* Blit to all the draw buffers */
   for (i = 0; i < numDrawBuffers; i++) {
      if (buffer == GL_COLOR_BUFFER_BIT) {
         int idx = drawFb->_ColorDrawBufferIndexes[i];
         if (idx == -1)
            continue;
         drawAtt = &drawFb->Attachment[idx];
         drawRb = drawAtt->Renderbuffer;

         if (!drawRb)
            continue;

         if (readRb->Format == drawRb->Format) {
            mode = DIRECT;
            pixelSize = _mesa_get_format_bytes(readRb->Format);
         } else {
            mode = UNPACK_RGBA_FLOAT;
            pixelSize = 16;
         }
      }

      /* choose row resampler */
      switch (pixelSize) {
      case 1:
         resampleRow = resample_row_1;
         break;
      case 2:
         resampleRow = resample_row_2;
         break;
      case 4:
         resampleRow = resample_row_4;
         break;
      case 8:
         resampleRow = resample_row_8;
         break;
      case 16:
         resampleRow = resample_row_16;
         break;
      default:
         _mesa_problem(ctx, "unexpected pixel size (%d) in blit_nearest",
                       pixelSize);
         goto fail;
      }

      if ((readRb == drawRb) ||
          (readAtt->Texture && drawAtt->Texture &&
           (readAtt->Texture == drawAtt->Texture))) {
         /* map whole buffer for read/write */
         /* XXX we could be clever and just map the union region of the
          * source and dest rects.
          */
         GLubyte *map;
         GLint rowStride;
         GLint formatSize = _mesa_get_format_bytes(readRb->Format);

         ctx->Driver.MapRenderbuffer(ctx, readRb, 0, 0,
                                     readRb->Width, readRb->Height,
                                     GL_MAP_READ_BIT | GL_MAP_WRITE_BIT,
                                     &map, &rowStride);
         if (!map) {
            goto fail_no_memory;
         }

         srcMap = map + srcYpos * rowStride + srcXpos * formatSize;
         dstMap = map + dstYpos * rowStride + dstXpos * formatSize;

         /* this handles overlapping copies */
         if (srcY0 < dstY0) {
            /* copy in reverse (top->down) order */
            srcMap += rowStride * (readRb->Height - 1);
            dstMap += rowStride * (readRb->Height - 1);
            srcRowStride = -rowStride;
            dstRowStride = -rowStride;
         }
         else {
            /* copy in normal (bottom->up) order */
            srcRowStride = rowStride;
            dstRowStride = rowStride;
         }
      }
      else {
         /* different src/dst buffers */
         ctx->Driver.MapRenderbuffer(ctx, readRb,
                                     srcXpos, srcYpos,
                                     srcWidth, srcHeight,
                                     GL_MAP_READ_BIT, &srcMap, &srcRowStride);
         if (!srcMap) {
            goto fail_no_memory;
         }
         ctx->Driver.MapRenderbuffer(ctx, drawRb,
                                     dstXpos, dstYpos,
                                     dstWidth, dstHeight,
                                     GL_MAP_WRITE_BIT, &dstMap, &dstRowStride);
         if (!dstMap) {
            ctx->Driver.UnmapRenderbuffer(ctx, readRb);
            goto fail_no_memory;
         }
      }

      for (dstRow = 0; dstRow < dstHeight; dstRow++) {
         GLfloat srcRowF = (dstRow + 0.5F) / dstHeight * srcHeight - 0.5F;
         GLint srcRow = IROUND(srcRowF);
         GLubyte *dstRowStart = dstMap + dstRowStride * dstRow;

         ASSERT(srcRow >= 0);
         ASSERT(srcRow < srcHeight);

         if (invertY) {
            srcRow = srcHeight - 1 - srcRow;
         }

         /* get pixel row from source and resample to match dest width */
         if (prevY != srcRow) {
            GLubyte *srcRowStart = srcMap + srcRowStride * srcRow;

            switch (mode) {
            case DIRECT:
               memcpy(srcBuffer, srcRowStart, pixelSize * srcWidth);
               break;
            case UNPACK_RGBA_FLOAT:
               _mesa_unpack_rgba_row(readRb->Format, srcWidth, srcRowStart,
                                     srcBuffer);
               break;
            case UNPACK_Z_FLOAT:
               _mesa_unpack_float_z_row(readRb->Format, srcWidth, srcRowStart,
                                        srcBuffer);
               break;
            case UNPACK_Z_INT:
               _mesa_unpack_uint_z_row(readRb->Format, srcWidth, srcRowStart,
                                       srcBuffer);
               break;
            case UNPACK_S:
               _mesa_unpack_ubyte_stencil_row(readRb->Format, srcWidth,
                                              srcRowStart, srcBuffer);
               break;
            }

            (*resampleRow)(srcWidth, dstWidth, srcBuffer, dstBuffer, invertX);
            prevY = srcRow;
         }

         /* store pixel row in destination */
         switch (mode) {
         case DIRECT:
            memcpy(dstRowStart, dstBuffer, pixelSize * dstWidth);
            break;
         case UNPACK_RGBA_FLOAT:
            _mesa_pack_float_rgba_row(drawRb->Format, dstWidth, dstBuffer,
                                      dstRowStart);
            break;
         case UNPACK_Z_FLOAT:
            _mesa_pack_float_z_row(drawRb->Format, dstWidth, dstBuffer,
                                   dstRowStart);
            break;
         case UNPACK_Z_INT:
            _mesa_pack_uint_z_row(drawRb->Format, dstWidth, dstBuffer,
                                  dstRowStart);
            break;
         case UNPACK_S:
            _mesa_pack_ubyte_stencil_row(drawRb->Format, dstWidth, dstBuffer,
                                         dstRowStart);
            break;
         }
      }

      ctx->Driver.UnmapRenderbuffer(ctx, readRb);
      if (drawRb != readRb) {
         ctx->Driver.UnmapRenderbuffer(ctx, drawRb);
      }
   }

fail:
   free(srcBuffer);
   free(dstBuffer);
   return;

fail_no_memory:
   free(srcBuffer);
   free(dstBuffer);
   _mesa_error(ctx, GL_OUT_OF_MEMORY, "glBlitFrameBuffer");
}



#define LERP(T, A, B)  ( (A) + (T) * ((B) - (A)) )

static inline GLfloat
lerp_2d(GLfloat a, GLfloat b,
        GLfloat v00, GLfloat v10, GLfloat v01, GLfloat v11)
{
   const GLfloat temp0 = LERP(a, v00, v10);
   const GLfloat temp1 = LERP(a, v01, v11);
   return LERP(b, temp0, temp1);
}


/**
 * Bilinear interpolation of two source rows.
 * GLubyte pixels.
 */
static void
resample_linear_row_ub(GLint srcWidth, GLint dstWidth,
                       const GLvoid *srcBuffer0, const GLvoid *srcBuffer1,
                       GLvoid *dstBuffer, GLboolean flip, GLfloat rowWeight)
{
   const GLubyte (*srcColor0)[4] = (const GLubyte (*)[4]) srcBuffer0;
   const GLubyte (*srcColor1)[4] = (const GLubyte (*)[4]) srcBuffer1;
   GLubyte (*dstColor)[4] = (GLubyte (*)[4]) dstBuffer;
   GLint dstCol;

   for (dstCol = 0; dstCol < dstWidth; dstCol++) {
      const GLfloat srcCol = (dstCol + 0.5F) / dstWidth * srcWidth - 0.5F;
      GLint srcCol0 = MAX2(0, IFLOOR(srcCol));
      GLint srcCol1 = srcCol0 + 1;
      GLfloat colWeight = srcCol - srcCol0; /* fractional part of srcCol */
      GLfloat red, green, blue, alpha;

      ASSERT(srcCol0 < srcWidth);
      ASSERT(srcCol1 <= srcWidth);

      if (srcCol1 == srcWidth) {
         /* last column fudge */
         srcCol1--;
         colWeight = 0.0;
      }

      if (flip) {
         srcCol0 = srcWidth - 1 - srcCol0;
         srcCol1 = srcWidth - 1 - srcCol1;
      }

      red = lerp_2d(colWeight, rowWeight,
                    srcColor0[srcCol0][RCOMP], srcColor0[srcCol1][RCOMP],
                    srcColor1[srcCol0][RCOMP], srcColor1[srcCol1][RCOMP]);
      green = lerp_2d(colWeight, rowWeight,
                    srcColor0[srcCol0][GCOMP], srcColor0[srcCol1][GCOMP],
                    srcColor1[srcCol0][GCOMP], srcColor1[srcCol1][GCOMP]);
      blue = lerp_2d(colWeight, rowWeight,
                    srcColor0[srcCol0][BCOMP], srcColor0[srcCol1][BCOMP],
                    srcColor1[srcCol0][BCOMP], srcColor1[srcCol1][BCOMP]);
      alpha = lerp_2d(colWeight, rowWeight,
                    srcColor0[srcCol0][ACOMP], srcColor0[srcCol1][ACOMP],
                    srcColor1[srcCol0][ACOMP], srcColor1[srcCol1][ACOMP]);
      
      dstColor[dstCol][RCOMP] = IFLOOR(red);
      dstColor[dstCol][GCOMP] = IFLOOR(green);
      dstColor[dstCol][BCOMP] = IFLOOR(blue);
      dstColor[dstCol][ACOMP] = IFLOOR(alpha);
   }
}


/**
 * Bilinear interpolation of two source rows.  floating point pixels.
 */
static void
resample_linear_row_float(GLint srcWidth, GLint dstWidth,
                          const GLvoid *srcBuffer0, const GLvoid *srcBuffer1,
                          GLvoid *dstBuffer, GLboolean flip, GLfloat rowWeight)
{
   const GLfloat (*srcColor0)[4] = (const GLfloat (*)[4]) srcBuffer0;
   const GLfloat (*srcColor1)[4] = (const GLfloat (*)[4]) srcBuffer1;
   GLfloat (*dstColor)[4] = (GLfloat (*)[4]) dstBuffer;
   GLint dstCol;

   for (dstCol = 0; dstCol < dstWidth; dstCol++) {
      const GLfloat srcCol = (dstCol + 0.5F) / dstWidth * srcWidth - 0.5F;
      GLint srcCol0 = MAX2(0, IFLOOR(srcCol));
      GLint srcCol1 = srcCol0 + 1;
      GLfloat colWeight = srcCol - srcCol0; /* fractional part of srcCol */
      GLfloat red, green, blue, alpha;

      ASSERT(srcCol0 < srcWidth);
      ASSERT(srcCol1 <= srcWidth);

      if (srcCol1 == srcWidth) {
         /* last column fudge */
         srcCol1--;
         colWeight = 0.0;
      }

      if (flip) {
         srcCol0 = srcWidth - 1 - srcCol0;
         srcCol1 = srcWidth - 1 - srcCol1;
      }

      red = lerp_2d(colWeight, rowWeight,
                    srcColor0[srcCol0][RCOMP], srcColor0[srcCol1][RCOMP],
                    srcColor1[srcCol0][RCOMP], srcColor1[srcCol1][RCOMP]);
      green = lerp_2d(colWeight, rowWeight,
                    srcColor0[srcCol0][GCOMP], srcColor0[srcCol1][GCOMP],
                    srcColor1[srcCol0][GCOMP], srcColor1[srcCol1][GCOMP]);
      blue = lerp_2d(colWeight, rowWeight,
                    srcColor0[srcCol0][BCOMP], srcColor0[srcCol1][BCOMP],
                    srcColor1[srcCol0][BCOMP], srcColor1[srcCol1][BCOMP]);
      alpha = lerp_2d(colWeight, rowWeight,
                    srcColor0[srcCol0][ACOMP], srcColor0[srcCol1][ACOMP],
                    srcColor1[srcCol0][ACOMP], srcColor1[srcCol1][ACOMP]);
      
      dstColor[dstCol][RCOMP] = red;
      dstColor[dstCol][GCOMP] = green;
      dstColor[dstCol][BCOMP] = blue;
      dstColor[dstCol][ACOMP] = alpha;
   }
}



/**
 * Bilinear filtered blit (color only, non-integer values).
 */
static void
blit_linear(struct gl_context *ctx,
            GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1,
            GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1)
{
   struct gl_framebuffer *drawFb = ctx->DrawBuffer;
   struct gl_framebuffer *readFb = ctx->ReadBuffer;
   struct gl_renderbuffer *readRb = readFb->_ColorReadBuffer;
   struct gl_renderbuffer_attachment *readAtt =
      &readFb->Attachment[readFb->_ColorReadBufferIndex];

   const GLint srcWidth = ABS(srcX1 - srcX0);
   const GLint dstWidth = ABS(dstX1 - dstX0);
   const GLint srcHeight = ABS(srcY1 - srcY0);
   const GLint dstHeight = ABS(dstY1 - dstY0);

   const GLint srcXpos = MIN2(srcX0, srcX1);
   const GLint srcYpos = MIN2(srcY0, srcY1);
   const GLint dstXpos = MIN2(dstX0, dstX1);
   const GLint dstYpos = MIN2(dstY0, dstY1);

   const GLboolean invertX = (srcX1 < srcX0) ^ (dstX1 < dstX0);
   const GLboolean invertY = (srcY1 < srcY0) ^ (dstY1 < dstY0);

   GLint dstRow;

   GLint pixelSize;
   GLvoid *srcBuffer0, *srcBuffer1;
   GLint srcBufferY0 = -1, srcBufferY1 = -1;
   GLvoid *dstBuffer;

   mesa_format readFormat = _mesa_get_srgb_format_linear(readRb->Format);
   GLuint bpp = _mesa_get_format_bytes(readFormat);

   GLenum pixelType;

   GLubyte *srcMap, *dstMap;
   GLint srcRowStride, dstRowStride;
   GLuint i;


   /* Determine datatype for resampling */
   if (_mesa_get_format_max_bits(readFormat) == 8 &&
       _mesa_get_format_datatype(readFormat) == GL_UNSIGNED_NORMALIZED) {
      pixelType = GL_UNSIGNED_BYTE;
      pixelSize = 4 * sizeof(GLubyte);
   }
   else {
      pixelType = GL_FLOAT;
      pixelSize = 4 * sizeof(GLfloat);
   }

   /* Allocate the src/dst row buffers.
    * Keep two adjacent src rows around for bilinear sampling.
    */
   srcBuffer0 = malloc(pixelSize * srcWidth);
   srcBuffer1 = malloc(pixelSize * srcWidth);
   dstBuffer = malloc(pixelSize * dstWidth);
   if (!srcBuffer0 || !srcBuffer1 || !dstBuffer) {
      goto fail_no_memory;
   }

   for (i = 0; i < drawFb->_NumColorDrawBuffers; i++) {
      GLint idx = drawFb->_ColorDrawBufferIndexes[i];
      struct gl_renderbuffer_attachment *drawAtt;
      struct gl_renderbuffer *drawRb;
      mesa_format drawFormat;

      if (idx == -1)
         continue;

      drawAtt = &drawFb->Attachment[idx];
      drawRb = drawAtt->Renderbuffer;
      if (!drawRb)
         continue;

      drawFormat = _mesa_get_srgb_format_linear(drawRb->Format);

      /*
       * Map src / dst renderbuffers
       */
      if ((readRb == drawRb) ||
          (readAtt->Texture && drawAtt->Texture &&
           (readAtt->Texture == drawAtt->Texture))) {
         /* map whole buffer for read/write */
         ctx->Driver.MapRenderbuffer(ctx, readRb,
                                     0, 0, readRb->Width, readRb->Height,
                                     GL_MAP_READ_BIT | GL_MAP_WRITE_BIT,
                                     &srcMap, &srcRowStride);
         if (!srcMap) {
            goto fail_no_memory;
         }

         dstMap = srcMap;
         dstRowStride = srcRowStride;
      }
      else {
         /* different src/dst buffers */
         /* XXX with a bit of work we could just map the regions to be
          * read/written instead of the whole buffers.
          */
         ctx->Driver.MapRenderbuffer(ctx, readRb,
                                     0, 0, readRb->Width, readRb->Height,
                                     GL_MAP_READ_BIT, &srcMap, &srcRowStride);
         if (!srcMap) {
            goto fail_no_memory;
         }
         ctx->Driver.MapRenderbuffer(ctx, drawRb,
                                     0, 0, drawRb->Width, drawRb->Height,
                                     GL_MAP_WRITE_BIT, &dstMap, &dstRowStride);
         if (!dstMap) {
            ctx->Driver.UnmapRenderbuffer(ctx, readRb);
            goto fail_no_memory;
         }
      }

      for (dstRow = 0; dstRow < dstHeight; dstRow++) {
         const GLint dstY = dstYpos + dstRow;
         GLfloat srcRow = (dstRow + 0.5F) / dstHeight * srcHeight - 0.5F;
         GLint srcRow0 = MAX2(0, IFLOOR(srcRow));
         GLint srcRow1 = srcRow0 + 1;
         GLfloat rowWeight = srcRow - srcRow0; /* fractional part of srcRow */

         if (srcRow1 == srcHeight) {
            /* last row fudge */
            srcRow1 = srcRow0;
            rowWeight = 0.0;
         }

         if (invertY) {
            srcRow0 = srcHeight - 1 - srcRow0;
            srcRow1 = srcHeight - 1 - srcRow1;
         }

         srcY0 = srcYpos + srcRow0;
         srcY1 = srcYpos + srcRow1;

         /* get the two source rows */
         if (srcY0 == srcBufferY0 && srcY1 == srcBufferY1) {
            /* use same source row buffers again */
         }
         else if (srcY0 == srcBufferY1) {
            /* move buffer1 into buffer0 by swapping pointers */
            GLvoid *tmp = srcBuffer0;
            srcBuffer0 = srcBuffer1;
            srcBuffer1 = tmp;
            /* get y1 row */
            {
               GLubyte *src = srcMap + srcY1 * srcRowStride + srcXpos * bpp;
               if (pixelType == GL_UNSIGNED_BYTE) {
                  _mesa_unpack_ubyte_rgba_row(readFormat, srcWidth,
                                              src, srcBuffer1);
               }
               else {
                  _mesa_unpack_rgba_row(readFormat, srcWidth,
                                        src, srcBuffer1);
               }
            }
            srcBufferY0 = srcY0;
            srcBufferY1 = srcY1;
         }
         else {
            /* get both new rows */
            {
               GLubyte *src0 = srcMap + srcY0 * srcRowStride + srcXpos * bpp;
               GLubyte *src1 = srcMap + srcY1 * srcRowStride + srcXpos * bpp;
               if (pixelType == GL_UNSIGNED_BYTE) {
                  _mesa_unpack_ubyte_rgba_row(readFormat, srcWidth,
                                              src0, srcBuffer0);
                  _mesa_unpack_ubyte_rgba_row(readFormat, srcWidth,
                                              src1, srcBuffer1);
               }
               else {
                  _mesa_unpack_rgba_row(readFormat, srcWidth, src0, srcBuffer0);
                  _mesa_unpack_rgba_row(readFormat, srcWidth, src1, srcBuffer1);
               }
            }
            srcBufferY0 = srcY0;
            srcBufferY1 = srcY1;
         }

         if (pixelType == GL_UNSIGNED_BYTE) {
            resample_linear_row_ub(srcWidth, dstWidth, srcBuffer0, srcBuffer1,
                                   dstBuffer, invertX, rowWeight);
         }
         else {
            resample_linear_row_float(srcWidth, dstWidth, srcBuffer0, srcBuffer1,
                                      dstBuffer, invertX, rowWeight);
         }

         /* store pixel row in destination */
         {
            GLubyte *dst = dstMap + dstY * dstRowStride + dstXpos * bpp;
            if (pixelType == GL_UNSIGNED_BYTE) {
               _mesa_pack_ubyte_rgba_row(drawFormat, dstWidth, dstBuffer, dst);
            }
            else {
               _mesa_pack_float_rgba_row(drawFormat, dstWidth, dstBuffer, dst);
            }
         }
      }

      ctx->Driver.UnmapRenderbuffer(ctx, readRb);
      if (drawRb != readRb) {
         ctx->Driver.UnmapRenderbuffer(ctx, drawRb);
      }
   }

   free(srcBuffer0);
   free(srcBuffer1);
   free(dstBuffer);
   return;

fail_no_memory:
   free(srcBuffer0);
   free(srcBuffer1);
   free(dstBuffer);
   _mesa_error(ctx, GL_OUT_OF_MEMORY, "glBlitFramebuffer");
}



/**
 * Software fallback for glBlitFramebufferEXT().
 */
void
_swrast_BlitFramebuffer(struct gl_context *ctx,
                        GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1,
                        GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1,
                        GLbitfield mask, GLenum filter)
{
   static const GLbitfield buffers[3] = {
      GL_COLOR_BUFFER_BIT,
      GL_DEPTH_BUFFER_BIT,
      GL_STENCIL_BUFFER_BIT
   };
   static const GLenum buffer_enums[3] = {
      GL_COLOR,
      GL_DEPTH,
      GL_STENCIL,
   };
   GLint i;

   /* Page 679 of OpenGL 4.4 spec says:
    *    "Added BlitFramebuffer to commands affected by conditional rendering in
    *     section 10.10 (Bug 9562)."
    */
   if (!_mesa_check_conditional_render(ctx))
      return; /* Do not blit */

   if (!_mesa_clip_blit(ctx, &srcX0, &srcY0, &srcX1, &srcY1,
                        &dstX0, &dstY0, &dstX1, &dstY1)) {
      return;
   }

   if (SWRAST_CONTEXT(ctx)->NewState)
      _swrast_validate_derived(ctx);

   /* First, try covering whatever buffers possible using the fast 1:1 copy
    * path.
    */
   if (srcX1 - srcX0 == dstX1 - dstX0 &&
       srcY1 - srcY0 == dstY1 - dstY0 &&
       srcX0 < srcX1 &&
       srcY0 < srcY1 &&
       dstX0 < dstX1 &&
       dstY0 < dstY1) {
      for (i = 0; i < 3; i++) {
         if (mask & buffers[i]) {
	    if (swrast_fast_copy_pixels(ctx,
					srcX0, srcY0,
					srcX1 - srcX0, srcY1 - srcY0,
					dstX0, dstY0,
					buffer_enums[i])) {
	       mask &= ~buffers[i];
	    }
	 }
      }

      if (!mask)
	 return;
   }

   if (filter == GL_NEAREST) {
      for (i = 0; i < 3; i++) {
	 if (mask & buffers[i]) {
	    blit_nearest(ctx,  srcX0, srcY0, srcX1, srcY1,
			 dstX0, dstY0, dstX1, dstY1, buffers[i]);
	 }
      }
   }
   else {
      ASSERT(filter == GL_LINEAR);
      if (mask & GL_COLOR_BUFFER_BIT) {  /* depth/stencil not allowed */
	 blit_linear(ctx,  srcX0, srcY0, srcX1, srcY1,
		     dstX0, dstY0, dstX1, dstY1);
      }
   }

}
@


1.7
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.6
log
@Merge Mesa 9.2.0
@
text
@d32 1
d170 2
a171 2
      if (readRb->Format == MESA_FORMAT_Z32_FLOAT ||
	  readRb->Format == MESA_FORMAT_Z32_FLOAT_X24S8) {
d540 1
a540 1
   gl_format readFormat = _mesa_get_srgb_format_linear(readRb->Format);
d575 1
a575 1
      gl_format drawFormat;
d751 7
@


1.5
log
@Merge Mesa 7.10.3
@
text
@a2 1
 * Version:  6.5
d19 4
a22 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
d30 2
d113 6
a118 1
   struct gl_renderbuffer *readRb, *drawRb;
d132 9
a140 1

d143 1
a143 1
   GLint comps, pixelSize;
d154 3
a156 3
      readRb = ctx->ReadBuffer->_ColorReadBuffer;
      drawRb = ctx->DrawBuffer->_ColorDrawBuffers[0];
      comps = 4;
d159 17
a175 3
      readRb = ctx->ReadBuffer->_DepthBuffer;
      drawRb = ctx->DrawBuffer->_DepthBuffer;
      comps = 1;
d178 7
a184 3
      readRb = ctx->ReadBuffer->_StencilBuffer;
      drawRb = ctx->DrawBuffer->_StencilBuffer;
      comps = 1;
d191 71
a261 18
   switch (readRb->DataType) {
   case GL_UNSIGNED_BYTE:
      pixelSize = comps * sizeof(GLubyte);
      break;
   case GL_UNSIGNED_SHORT:
      pixelSize = comps * sizeof(GLushort);
      break;
   case GL_UNSIGNED_INT:
      pixelSize = comps * sizeof(GLuint);
      break;
   case GL_FLOAT:
      pixelSize = comps * sizeof(GLfloat);
      break;
   default:
      _mesa_problem(ctx, "unexpected buffer type (0x%x) in blit_nearest",
                    readRb->DataType);
      return;
   }
d263 32
a294 22
   /* choose row resampler */
   switch (pixelSize) {
   case 1:
      resampleRow = resample_row_1;
      break;
   case 2:
      resampleRow = resample_row_2;
      break;
   case 4:
      resampleRow = resample_row_4;
      break;
   case 8:
      resampleRow = resample_row_8;
      break;
   case 16:
      resampleRow = resample_row_16;
      break;
   default:
      _mesa_problem(ctx, "unexpected pixel size (%d) in blit_nearest",
                    pixelSize);
      return;
   }
d296 4
a299 12
   /* allocate the src/dst row buffers */
   srcBuffer = malloc(pixelSize * srcWidth);
   if (!srcBuffer) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glBlitFrameBufferEXT");
      return;
   }
   dstBuffer = malloc(pixelSize * dstWidth);
   if (!dstBuffer) {
      free(srcBuffer);
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glBlitFrameBufferEXT");
      return;
   }
d301 2
a302 4
   for (dstRow = 0; dstRow < dstHeight; dstRow++) {
      const GLint dstY = dstYpos + dstRow;
      GLint srcRow = (dstRow * srcHeight) / dstHeight;
      GLint srcY;
d304 3
a306 2
      ASSERT(srcRow >= 0);
      ASSERT(srcRow < srcHeight);
d308 25
a332 3
      if (invertY) {
         srcRow = srcHeight - 1 - srcRow;
      }
d334 3
a336 1
      srcY = srcYpos + srcRow;
d338 22
a359 5
      /* get pixel row from source and resample to match dest width */
      if (prevY != srcY) {
         readRb->GetRow(ctx, readRb, srcWidth, srcXpos, srcY, srcBuffer);
         (*resampleRow)(srcWidth, dstWidth, srcBuffer, dstBuffer, invertX);
         prevY = srcY;
d362 4
a365 2
      /* store pixel row in destination */
      drawRb->PutRow(ctx, drawRb, dstWidth, dstXpos, dstY, dstBuffer, NULL);
d368 1
d371 6
d383 1
a383 1
static INLINE GLfloat
a404 1
   const GLfloat dstWidthF = (GLfloat) dstWidth;
d408 2
a409 2
      const GLfloat srcCol = (dstCol * srcWidth) / dstWidthF;
      GLint srcCol0 = IFLOOR(srcCol);
a413 1
      ASSERT(srcCol0 >= 0);
d449 55
d506 1
a506 1
 * Bilinear filtered blit (color only).
d513 5
a517 2
   struct gl_renderbuffer *readRb = ctx->ReadBuffer->_ColorReadBuffer;
   struct gl_renderbuffer *drawRb = ctx->DrawBuffer->_ColorDrawBuffers[0];
a522 1
   const GLfloat dstHeightF = (GLfloat) dstHeight;
d539 14
a552 2
   switch (readRb->DataType) {
   case GL_UNSIGNED_BYTE:
d554 3
a556 8
      break;
   case GL_UNSIGNED_SHORT:
      pixelSize = 4 * sizeof(GLushort);
      break;
   case GL_UNSIGNED_INT:
      pixelSize = 4 * sizeof(GLuint);
      break;
   case GL_FLOAT:
a557 5
      break;
   default:
      _mesa_problem(ctx, "unexpected buffer type (0x%x) in blit_nearest",
                    readRb->DataType);
      return;
a563 4
   if (!srcBuffer0) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glBlitFrameBufferEXT");
      return;
   }
a564 5
   if (!srcBuffer1) {
      free(srcBuffer0);
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glBlitFrameBufferEXT");
      return;
   }
d566 2
a567 5
   if (!dstBuffer) {
      free(srcBuffer0);
      free(srcBuffer1);
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glBlitFrameBufferEXT");
      return;
d570 30
a599 45
   for (dstRow = 0; dstRow < dstHeight; dstRow++) {
      const GLint dstY = dstYpos + dstRow;
      const GLfloat srcRow = (dstRow * srcHeight) / dstHeightF;
      GLint srcRow0 = IFLOOR(srcRow);
      GLint srcRow1 = srcRow0 + 1;
      GLfloat rowWeight = srcRow - srcRow0; /* fractional part of srcRow */

      ASSERT(srcRow >= 0);
      ASSERT(srcRow < srcHeight);

      if (srcRow1 == srcHeight) {
         /* last row fudge */
         srcRow1 = srcRow0;
         rowWeight = 0.0;
      }

      if (invertY) {
         srcRow0 = srcHeight - 1 - srcRow0;
         srcRow1 = srcHeight - 1 - srcRow1;
      }

      srcY0 = srcYpos + srcRow0;
      srcY1 = srcYpos + srcRow1;

      /* get the two source rows */
      if (srcY0 == srcBufferY0 && srcY1 == srcBufferY1) {
         /* use same source row buffers again */
      }
      else if (srcY0 == srcBufferY1) {
         /* move buffer1 into buffer0 by swapping pointers */
         GLvoid *tmp = srcBuffer0;
         srcBuffer0 = srcBuffer1;
         srcBuffer1 = tmp;
         /* get y1 row */
         readRb->GetRow(ctx, readRb, srcWidth, srcXpos, srcY1, srcBuffer1);
         srcBufferY0 = srcY0;
         srcBufferY1 = srcY1;
      }
      else {
         /* get both new rows */
         readRb->GetRow(ctx, readRb, srcWidth, srcXpos, srcY0, srcBuffer0);
         readRb->GetRow(ctx, readRb, srcWidth, srcXpos, srcY1, srcBuffer1);
         srcBufferY0 = srcY0;
         srcBufferY1 = srcY1;
      }
d601 2
a602 3
      if (readRb->DataType == GL_UNSIGNED_BYTE) {
         resample_linear_row_ub(srcWidth, dstWidth, srcBuffer0, srcBuffer1,
                                dstBuffer, invertX, rowWeight);
d605 17
a621 2
         _mesa_problem(ctx, "Unsupported color channel type in sw blit");
         break;
d624 12
a635 3
      /* store pixel row in destination */
      drawRb->PutRow(ctx, drawRb, dstWidth, dstXpos, dstY, dstBuffer, NULL);
   }
d637 4
a640 4
   free(srcBuffer0);
   free(srcBuffer1);
   free(dstBuffer);
}
d642 2
d645 43
a687 41
/**
 * Simple case:  Blit color, depth or stencil with no scaling or flipping.
 * XXX we could easily support vertical flipping here.
 */
static void
simple_blit(struct gl_context *ctx,
            GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1,
            GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1,
            GLbitfield buffer)
{
   struct gl_renderbuffer *readRb, *drawRb;
   const GLint width = srcX1 - srcX0;
   const GLint height = srcY1 - srcY0;
   GLint row, srcY, dstY, yStep;
   GLint comps, bytesPerRow;
   void *rowBuffer;

   /* only one buffer */
   ASSERT(_mesa_bitcount(buffer) == 1);
   /* no flipping checks */
   ASSERT(srcX0 < srcX1);
   ASSERT(srcY0 < srcY1);
   ASSERT(dstX0 < dstX1);
   ASSERT(dstY0 < dstY1);
   /* size checks */
   ASSERT(srcX1 - srcX0 == dstX1 - dstX0);
   ASSERT(srcY1 - srcY0 == dstY1 - dstY0);

   /* determine if copy should be bottom-to-top or top-to-bottom */
   if (srcY0 > dstY0) {
      /* src above dst: copy bottom-to-top */
      yStep = 1;
      srcY = srcY0;
      dstY = dstY0;
   }
   else {
      /* src below dst: copy top-to-bottom */
      yStep = -1;
      srcY = srcY1 - 1;
      dstY = dstY1 - 1;
   }
d689 8
a696 20
   switch (buffer) {
   case GL_COLOR_BUFFER_BIT:
      readRb = ctx->ReadBuffer->_ColorReadBuffer;
      drawRb = ctx->DrawBuffer->_ColorDrawBuffers[0];
      comps = 4;
      break;
   case GL_DEPTH_BUFFER_BIT:
      readRb = ctx->ReadBuffer->_DepthBuffer;
      drawRb = ctx->DrawBuffer->_DepthBuffer;
      comps = 1;
      break;
   case GL_STENCIL_BUFFER_BIT:
      readRb = ctx->ReadBuffer->_StencilBuffer;
      drawRb = ctx->DrawBuffer->_StencilBuffer;
      comps = 1;
      break;
   default:
      _mesa_problem(ctx, "unexpected buffer in simple_blit()");
      return;
   }
d698 11
a708 1
   ASSERT(readRb->DataType == drawRb->DataType);
d710 4
a713 17
   /* compute bytes per row */
   switch (readRb->DataType) {
   case GL_UNSIGNED_BYTE:
      bytesPerRow = comps * width * sizeof(GLubyte);
      break;
   case GL_UNSIGNED_SHORT:
      bytesPerRow = comps * width * sizeof(GLushort);
      break;
   case GL_UNSIGNED_INT:
      bytesPerRow = comps * width * sizeof(GLuint);
      break;
   case GL_FLOAT:
      bytesPerRow = comps * width * sizeof(GLfloat);
      break;
   default:
      _mesa_problem(ctx, "unexpected buffer type in simple_blit");
      return;
d716 4
a719 6
   /* allocate the row buffer */
   rowBuffer = malloc(bytesPerRow);
   if (!rowBuffer) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glBlitFrameBufferEXT");
      return;
   }
d721 6
a726 6
   for (row = 0; row < height; row++) {
      readRb->GetRow(ctx, readRb, width, srcX0, srcY, rowBuffer);
      drawRb->PutRow(ctx, drawRb, width, dstX0, dstY, rowBuffer, NULL);
      srcY += yStep;
      dstY += yStep;
   }
a727 2
   free(rowBuffer);
}
d744 5
d756 2
a757 1
   swrast_render_start(ctx);
d759 3
a767 3
      /* no stretching or flipping.
       * filter doesn't matter.
       */
d770 20
a789 3
            simple_blit(ctx, srcX0, srcY0, srcX1, srcY1,
                        dstX0, dstY0, dstX1, dstY1, buffers[i]);
         }
d793 4
a796 14
      if (filter == GL_NEAREST) {
         for (i = 0; i < 3; i++) {
            if (mask & buffers[i]) {
               blit_nearest(ctx,  srcX0, srcY0, srcX1, srcY1,
                            dstX0, dstY0, dstX1, dstY1, buffers[i]);
            }
         }
      }
      else {
         ASSERT(filter == GL_LINEAR);
         if (mask & GL_COLOR_BUFFER_BIT) {  /* depth/stencil not allowed */
            blit_linear(ctx,  srcX0, srcY0, srcX1, srcY1,
                        dstX0, dstY0, dstX1, dstY1);
         }
a799 1
   swrast_render_finish(ctx);
@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d106 1
a106 1
blit_nearest(GLcontext *ctx,
d319 1
a319 1
blit_linear(GLcontext *ctx,
d458 1
a458 1
simple_blit(GLcontext *ctx,
d559 1
a559 1
_swrast_BlitFramebuffer(GLcontext *ctx,
a569 6

   if (!_mesa_check_conditional_render(ctx))
      return; /* don't clear */

   if (!ctx->DrawBuffer->_NumColorDrawBuffers)
      return;
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d27 2
d109 1
a109 1
             GLenum buffer)
d201 1
a201 1
   srcBuffer = _mesa_malloc(pixelSize * srcWidth);
d206 1
a206 1
   dstBuffer = _mesa_malloc(pixelSize * dstWidth);
d208 1
a208 1
      _mesa_free(srcBuffer);
d238 2
a239 2
   _mesa_free(srcBuffer);
   _mesa_free(dstBuffer);
d369 1
a369 1
   srcBuffer0 = _mesa_malloc(pixelSize * srcWidth);
d374 1
a374 1
   srcBuffer1 = _mesa_malloc(pixelSize * srcWidth);
d376 1
a376 1
      _mesa_free(srcBuffer0);
d380 1
a380 1
   dstBuffer = _mesa_malloc(pixelSize * dstWidth);
d382 2
a383 2
      _mesa_free(srcBuffer0);
      _mesa_free(srcBuffer1);
d447 3
a449 3
   _mesa_free(srcBuffer0);
   _mesa_free(srcBuffer1);
   _mesa_free(dstBuffer);
d461 1
a461 1
            GLenum buffer)
d538 1
a538 1
   rowBuffer = _mesa_malloc(bytesPerRow);
d551 1
a551 179
   _mesa_free(rowBuffer);
}


/**
 * Clip dst coords against Xmax (or Ymax).
 */
static INLINE void
clip_right_or_top(GLint *srcX0, GLint *srcX1,
                  GLint *dstX0, GLint *dstX1,
                  GLint maxValue)
{
   GLfloat t, bias;

   if (*dstX1 > maxValue) {
      /* X1 outside right edge */
      ASSERT(*dstX0 < maxValue); /* X0 should be inside right edge */
      t = (GLfloat) (maxValue - *dstX0) / (GLfloat) (*dstX1 - *dstX0);
      /* chop off [t, 1] part */
      ASSERT(t >= 0.0 && t <= 1.0);
      *dstX1 = maxValue;
      bias = (*srcX0 < *srcX1) ? 0.5 : -0.5;
      *srcX1 = *srcX0 + (GLint) (t * (*srcX1 - *srcX0) + bias);
   }
   else if (*dstX0 > maxValue) {
      /* X0 outside right edge */
      ASSERT(*dstX1 < maxValue); /* X1 should be inside right edge */
      t = (GLfloat) (maxValue - *dstX1) / (GLfloat) (*dstX0 - *dstX1);
      /* chop off [t, 1] part */
      ASSERT(t >= 0.0 && t <= 1.0);
      *dstX0 = maxValue;
      bias = (*srcX0 < *srcX1) ? -0.5 : 0.5;
      *srcX0 = *srcX1 + (GLint) (t * (*srcX0 - *srcX1) + bias);
   }
}


/**
 * Clip dst coords against Xmin (or Ymin).
 */
static INLINE void
clip_left_or_bottom(GLint *srcX0, GLint *srcX1,
                    GLint *dstX0, GLint *dstX1,
                    GLint minValue)
{
   GLfloat t, bias;

   if (*dstX0 < minValue) {
      /* X0 outside left edge */
      ASSERT(*dstX1 > minValue); /* X1 should be inside left edge */
      t = (GLfloat) (minValue - *dstX0) / (GLfloat) (*dstX1 - *dstX0);
      /* chop off [0, t] part */
      ASSERT(t >= 0.0 && t <= 1.0);
      *dstX0 = minValue;
      bias = (*srcX0 < *srcX1) ? 0.5 : -0.5; /* flipped??? */
      *srcX0 = *srcX0 + (GLint) (t * (*srcX1 - *srcX0) + bias);
   }
   else if (*dstX1 < minValue) {
      /* X1 outside left edge */
      ASSERT(*dstX0 > minValue); /* X0 should be inside left edge */
      t = (GLfloat) (minValue - *dstX1) / (GLfloat) (*dstX0 - *dstX1);
      /* chop off [0, t] part */
      ASSERT(t >= 0.0 && t <= 1.0);
      *dstX1 = minValue;
      bias = (*srcX0 < *srcX1) ? 0.5 : -0.5;
      *srcX1 = *srcX1 + (GLint) (t * (*srcX0 - *srcX1) + bias);
   }
}


/**
 * Do clipping of blit src/dest rectangles.
 * The dest rect is clipped against both the buffer bounds and scissor bounds.
 * The src rect is just clipped against the buffer bounds.
 *
 * When either the src or dest rect is clipped, the other is also clipped
 * proportionately!
 *
 * Note that X0 need not be less than X1 (same for Y) for either the source
 * and dest rects.  That makes the clipping a little trickier.
 *
 * \return GL_TRUE if anything is left to draw, GL_FALSE if totally clipped
 */
static GLboolean
clip_blit(GLcontext *ctx,
          GLint *srcX0, GLint *srcY0, GLint *srcX1, GLint *srcY1,
          GLint *dstX0, GLint *dstY0, GLint *dstX1, GLint *dstY1)
{
   const GLint srcXmin = 0;
   const GLint srcXmax = ctx->ReadBuffer->Width;
   const GLint srcYmin = 0;
   const GLint srcYmax = ctx->ReadBuffer->Height;

   /* these include scissor bounds */
   const GLint dstXmin = ctx->DrawBuffer->_Xmin;
   const GLint dstXmax = ctx->DrawBuffer->_Xmax;
   const GLint dstYmin = ctx->DrawBuffer->_Ymin;
   const GLint dstYmax = ctx->DrawBuffer->_Ymax;

   /*
   printf("PreClipX:  src: %d .. %d  dst: %d .. %d\n",
          *srcX0, *srcX1, *dstX0, *dstX1);
   printf("PreClipY:  src: %d .. %d  dst: %d .. %d\n",
          *srcY0, *srcY1, *dstY0, *dstY1);
   */

   /* trivial rejection tests */
   if (*dstX0 == *dstX1)
      return GL_FALSE; /* no width */
   if (*dstX0 <= dstXmin && *dstX1 <= dstXmin)
      return GL_FALSE; /* totally out (left) of bounds */
   if (*dstX0 >= dstXmax && *dstX1 >= dstXmax)
      return GL_FALSE; /* totally out (right) of bounds */

   if (*dstY0 == *dstY1)
      return GL_FALSE;
   if (*dstY0 <= dstYmin && *dstY1 <= dstYmin)
      return GL_FALSE;
   if (*dstY0 >= dstYmax && *dstY1 >= dstYmax)
      return GL_FALSE;

   if (*srcX0 == *srcX1)
      return GL_FALSE;
   if (*srcX0 <= srcXmin && *srcX1 <= srcXmin)
      return GL_FALSE;
   if (*srcX0 >= srcXmax && *srcX1 >= srcXmax)
      return GL_FALSE;

   if (*srcY0 == *srcY1)
      return GL_FALSE;
   if (*srcY0 <= srcYmin && *srcY1 <= srcYmin)
      return GL_FALSE;
   if (*srcY0 >= srcYmax && *srcY1 >= srcYmax)
      return GL_FALSE;

   /*
    * dest clip
    */
   clip_right_or_top(srcX0, srcX1, dstX0, dstX1, dstXmax);
   clip_right_or_top(srcY0, srcY1, dstY0, dstY1, dstYmax);
   clip_left_or_bottom(srcX0, srcX1, dstX0, dstX1, dstXmin);
   clip_left_or_bottom(srcY0, srcY1, dstY0, dstY1, dstYmin);

   /*
    * src clip (just swap src/dst values from above)
    */
   clip_right_or_top(dstX0, dstX1, srcX0, srcX1, srcXmax);
   clip_right_or_top(dstY0, dstY1, srcY0, srcY1, srcYmax);
   clip_left_or_bottom(dstX0, dstX1, srcX0, srcX1, srcXmin);
   clip_left_or_bottom(dstY0, dstY1, srcY0, srcY1, srcYmin);

   /*
   printf("PostClipX: src: %d .. %d  dst: %d .. %d\n",
          *srcX0, *srcX1, *dstX0, *dstX1);
   printf("PostClipY: src: %d .. %d  dst: %d .. %d\n",
          *srcY0, *srcY1, *dstY0, *dstY1);
   */

   ASSERT(*dstX0 >= dstXmin);
   ASSERT(*dstX0 <= dstXmax);
   ASSERT(*dstX1 >= dstXmin);
   ASSERT(*dstX1 <= dstXmax);

   ASSERT(*dstY0 >= dstYmin);
   ASSERT(*dstY0 <= dstYmax);
   ASSERT(*dstY1 >= dstYmin);
   ASSERT(*dstY1 <= dstYmax);

   ASSERT(*srcX0 >= srcXmin);
   ASSERT(*srcX0 <= srcXmax);
   ASSERT(*srcX1 >= srcXmin);
   ASSERT(*srcX1 <= srcXmax);

   ASSERT(*srcY0 >= srcYmin);
   ASSERT(*srcY0 <= srcYmax);
   ASSERT(*srcY1 >= srcYmin);
   ASSERT(*srcY1 <= srcYmax);

   return GL_TRUE;
d564 1
a564 2
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
   static const GLint buffers[3] = {
d571 3
d577 2
a578 2
   if (!clip_blit(ctx, &srcX0, &srcY0, &srcX1, &srcY1,
                  &dstX0, &dstY0, &dstX1, &dstY1)) {
d582 1
a582 1
   RENDER_START(swrast, ctx);
d618 1
a618 1
   RENDER_FINISH(swrast, ctx);
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d26 2
a27 2
#include "glheader.h"
#include "macros.h"
@


1.1
log
@Initial revision
@
text
@d138 1
a138 1
      drawRb = ctx->DrawBuffer->_ColorDrawBuffers[0][0];
d322 1
a322 1
   struct gl_renderbuffer *drawRb = ctx->DrawBuffer->_ColorDrawBuffers[0][0];
d496 1
a496 1
      drawRb = ctx->DrawBuffer->_ColorDrawBuffers[0][0];
d747 3
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@Import Mesa 7.10.3
@
text
@d26 2
a27 4
#include "main/glheader.h"
#include "main/condrender.h"
#include "main/image.h"
#include "main/macros.h"
d104 1
a104 1
blit_nearest(struct gl_context *ctx,
d107 1
a107 1
             GLbitfield buffer)
d138 1
a138 1
      drawRb = ctx->DrawBuffer->_ColorDrawBuffers[0];
d199 1
a199 1
   srcBuffer = malloc(pixelSize * srcWidth);
d204 1
a204 1
   dstBuffer = malloc(pixelSize * dstWidth);
d206 1
a206 1
      free(srcBuffer);
d236 2
a237 2
   free(srcBuffer);
   free(dstBuffer);
d317 1
a317 1
blit_linear(struct gl_context *ctx,
d322 1
a322 1
   struct gl_renderbuffer *drawRb = ctx->DrawBuffer->_ColorDrawBuffers[0];
d367 1
a367 1
   srcBuffer0 = malloc(pixelSize * srcWidth);
d372 1
a372 1
   srcBuffer1 = malloc(pixelSize * srcWidth);
d374 1
a374 1
      free(srcBuffer0);
d378 1
a378 1
   dstBuffer = malloc(pixelSize * dstWidth);
d380 2
a381 2
      free(srcBuffer0);
      free(srcBuffer1);
d445 3
a447 3
   free(srcBuffer0);
   free(srcBuffer1);
   free(dstBuffer);
d456 1
a456 1
simple_blit(struct gl_context *ctx,
d459 1
a459 1
            GLbitfield buffer)
d496 1
a496 1
      drawRb = ctx->DrawBuffer->_ColorDrawBuffers[0];
d536 1
a536 1
   rowBuffer = malloc(bytesPerRow);
d549 179
a727 1
   free(rowBuffer);
d735 1
a735 1
_swrast_BlitFramebuffer(struct gl_context *ctx,
d740 2
a741 1
   static const GLbitfield buffers[3] = {
d748 2
a749 2
   if (!_mesa_clip_blit(ctx, &srcX0, &srcY0, &srcX1, &srcY1,
                        &dstX0, &dstY0, &dstX1, &dstY1)) {
d753 1
a753 1
   swrast_render_start(ctx);
d789 1
a789 1
   swrast_render_finish(ctx);
@


1.1.1.3
log
@Import Mesa 9.2.0
@
text
@d3 1
d20 3
a22 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
a29 2
#include "main/format_unpack.h"
#include "main/format_pack.h"
d111 1
a111 6
   struct gl_renderbuffer *readRb, *drawRb = NULL;
   struct gl_renderbuffer_attachment *readAtt = NULL, *drawAtt = NULL;
   struct gl_framebuffer *readFb = ctx->ReadBuffer;
   struct gl_framebuffer *drawFb = ctx->DrawBuffer;
   GLuint numDrawBuffers = 0;
   GLuint i;
d125 1
a125 9
   enum mode {
      DIRECT,
      UNPACK_RGBA_FLOAT,
      UNPACK_Z_FLOAT,
      UNPACK_Z_INT,
      UNPACK_S,
   } mode = DIRECT;
   GLubyte *srcMap, *dstMap;
   GLint srcRowStride, dstRowStride;
d128 1
a128 1
   GLint pixelSize = 0;
d139 3
a141 3
      readAtt = &readFb->Attachment[readFb->_ColorReadBufferIndex];
      readRb = readFb->_ColorReadBuffer;
      numDrawBuffers = drawFb->_NumColorDrawBuffers;
d144 3
a146 17
      readAtt = &readFb->Attachment[BUFFER_DEPTH];
      drawAtt = &drawFb->Attachment[BUFFER_DEPTH];
      readRb = readAtt->Renderbuffer;
      drawRb = drawAtt->Renderbuffer;
      numDrawBuffers = 1;

      /* Note that for depth/stencil, the formats of src/dst must match.  By
       * using the core helpers for pack/unpack, we avoid needing to handle
       * masking for things like DEPTH copies of Z24S8.
       */
      if (readRb->Format == MESA_FORMAT_Z32_FLOAT ||
	  readRb->Format == MESA_FORMAT_Z32_FLOAT_X24S8) {
	 mode = UNPACK_Z_FLOAT;
      } else {
	 mode = UNPACK_Z_INT;
      }
      pixelSize = 4;
d149 3
a151 7
      readAtt = &readFb->Attachment[BUFFER_STENCIL];
      drawAtt = &drawFb->Attachment[BUFFER_STENCIL];
      readRb = readAtt->Renderbuffer;
      drawRb = drawAtt->Renderbuffer;
      numDrawBuffers = 1;
      mode = UNPACK_S;
      pixelSize = 1;
d158 42
d201 11
a211 25
   srcBuffer = malloc(MAX_PIXEL_BYTES * srcWidth);
   dstBuffer = malloc(MAX_PIXEL_BYTES * dstWidth);
   if (!srcBuffer || !dstBuffer)
      goto fail_no_memory;

   /* Blit to all the draw buffers */
   for (i = 0; i < numDrawBuffers; i++) {
      if (buffer == GL_COLOR_BUFFER_BIT) {
         int idx = drawFb->_ColorDrawBufferIndexes[i];
         if (idx == -1)
            continue;
         drawAtt = &drawFb->Attachment[idx];
         drawRb = drawAtt->Renderbuffer;

         if (!drawRb)
            continue;

         if (readRb->Format == drawRb->Format) {
            mode = DIRECT;
            pixelSize = _mesa_get_format_bytes(readRb->Format);
         } else {
            mode = UNPACK_RGBA_FLOAT;
            pixelSize = 16;
         }
      }
d213 4
a216 41
      /* choose row resampler */
      switch (pixelSize) {
      case 1:
         resampleRow = resample_row_1;
         break;
      case 2:
         resampleRow = resample_row_2;
         break;
      case 4:
         resampleRow = resample_row_4;
         break;
      case 8:
         resampleRow = resample_row_8;
         break;
      case 16:
         resampleRow = resample_row_16;
         break;
      default:
         _mesa_problem(ctx, "unexpected pixel size (%d) in blit_nearest",
                       pixelSize);
         goto fail;
      }

      if ((readRb == drawRb) ||
          (readAtt->Texture && drawAtt->Texture &&
           (readAtt->Texture == drawAtt->Texture))) {
         /* map whole buffer for read/write */
         /* XXX we could be clever and just map the union region of the
          * source and dest rects.
          */
         GLubyte *map;
         GLint rowStride;
         GLint formatSize = _mesa_get_format_bytes(readRb->Format);

         ctx->Driver.MapRenderbuffer(ctx, readRb, 0, 0,
                                     readRb->Width, readRb->Height,
                                     GL_MAP_READ_BIT | GL_MAP_WRITE_BIT,
                                     &map, &rowStride);
         if (!map) {
            goto fail_no_memory;
         }
d218 2
a219 2
         srcMap = map + srcYpos * rowStride + srcXpos * formatSize;
         dstMap = map + dstYpos * rowStride + dstXpos * formatSize;
d221 2
a222 31
         /* this handles overlapping copies */
         if (srcY0 < dstY0) {
            /* copy in reverse (top->down) order */
            srcMap += rowStride * (readRb->Height - 1);
            dstMap += rowStride * (readRb->Height - 1);
            srcRowStride = -rowStride;
            dstRowStride = -rowStride;
         }
         else {
            /* copy in normal (bottom->up) order */
            srcRowStride = rowStride;
            dstRowStride = rowStride;
         }
      }
      else {
         /* different src/dst buffers */
         ctx->Driver.MapRenderbuffer(ctx, readRb,
                                     srcXpos, srcYpos,
                                     srcWidth, srcHeight,
                                     GL_MAP_READ_BIT, &srcMap, &srcRowStride);
         if (!srcMap) {
            goto fail_no_memory;
         }
         ctx->Driver.MapRenderbuffer(ctx, drawRb,
                                     dstXpos, dstYpos,
                                     dstWidth, dstHeight,
                                     GL_MAP_WRITE_BIT, &dstMap, &dstRowStride);
         if (!dstMap) {
            ctx->Driver.UnmapRenderbuffer(ctx, readRb);
            goto fail_no_memory;
         }
d225 1
a225 41
      for (dstRow = 0; dstRow < dstHeight; dstRow++) {
         GLfloat srcRowF = (dstRow + 0.5F) / dstHeight * srcHeight - 0.5F;
         GLint srcRow = IROUND(srcRowF);
         GLubyte *dstRowStart = dstMap + dstRowStride * dstRow;

         ASSERT(srcRow >= 0);
         ASSERT(srcRow < srcHeight);

         if (invertY) {
            srcRow = srcHeight - 1 - srcRow;
         }

         /* get pixel row from source and resample to match dest width */
         if (prevY != srcRow) {
            GLubyte *srcRowStart = srcMap + srcRowStride * srcRow;

            switch (mode) {
            case DIRECT:
               memcpy(srcBuffer, srcRowStart, pixelSize * srcWidth);
               break;
            case UNPACK_RGBA_FLOAT:
               _mesa_unpack_rgba_row(readRb->Format, srcWidth, srcRowStart,
                                     srcBuffer);
               break;
            case UNPACK_Z_FLOAT:
               _mesa_unpack_float_z_row(readRb->Format, srcWidth, srcRowStart,
                                        srcBuffer);
               break;
            case UNPACK_Z_INT:
               _mesa_unpack_uint_z_row(readRb->Format, srcWidth, srcRowStart,
                                       srcBuffer);
               break;
            case UNPACK_S:
               _mesa_unpack_ubyte_stencil_row(readRb->Format, srcWidth,
                                              srcRowStart, srcBuffer);
               break;
            }

            (*resampleRow)(srcWidth, dstWidth, srcBuffer, dstBuffer, invertX);
            prevY = srcRow;
         }
d227 5
a231 22
         /* store pixel row in destination */
         switch (mode) {
         case DIRECT:
            memcpy(dstRowStart, dstBuffer, pixelSize * dstWidth);
            break;
         case UNPACK_RGBA_FLOAT:
            _mesa_pack_float_rgba_row(drawRb->Format, dstWidth, dstBuffer,
                                      dstRowStart);
            break;
         case UNPACK_Z_FLOAT:
            _mesa_pack_float_z_row(drawRb->Format, dstWidth, dstBuffer,
                                   dstRowStart);
            break;
         case UNPACK_Z_INT:
            _mesa_pack_uint_z_row(drawRb->Format, dstWidth, dstBuffer,
                                  dstRowStart);
            break;
         case UNPACK_S:
            _mesa_pack_ubyte_stencil_row(drawRb->Format, dstWidth, dstBuffer,
                                         dstRowStart);
            break;
         }
d234 2
a235 4
      ctx->Driver.UnmapRenderbuffer(ctx, readRb);
      if (drawRb != readRb) {
         ctx->Driver.UnmapRenderbuffer(ctx, drawRb);
      }
a237 1
fail:
a239 6
   return;

fail_no_memory:
   free(srcBuffer);
   free(dstBuffer);
   _mesa_error(ctx, GL_OUT_OF_MEMORY, "glBlitFrameBuffer");
d246 1
a246 1
static inline GLfloat
d268 1
d272 2
a273 2
      const GLfloat srcCol = (dstCol + 0.5F) / dstWidth * srcWidth - 0.5F;
      GLint srcCol0 = MAX2(0, IFLOOR(srcCol));
d278 1
a313 55
/**
 * Bilinear interpolation of two source rows.  floating point pixels.
 */
static void
resample_linear_row_float(GLint srcWidth, GLint dstWidth,
                          const GLvoid *srcBuffer0, const GLvoid *srcBuffer1,
                          GLvoid *dstBuffer, GLboolean flip, GLfloat rowWeight)
{
   const GLfloat (*srcColor0)[4] = (const GLfloat (*)[4]) srcBuffer0;
   const GLfloat (*srcColor1)[4] = (const GLfloat (*)[4]) srcBuffer1;
   GLfloat (*dstColor)[4] = (GLfloat (*)[4]) dstBuffer;
   GLint dstCol;

   for (dstCol = 0; dstCol < dstWidth; dstCol++) {
      const GLfloat srcCol = (dstCol + 0.5F) / dstWidth * srcWidth - 0.5F;
      GLint srcCol0 = MAX2(0, IFLOOR(srcCol));
      GLint srcCol1 = srcCol0 + 1;
      GLfloat colWeight = srcCol - srcCol0; /* fractional part of srcCol */
      GLfloat red, green, blue, alpha;

      ASSERT(srcCol0 < srcWidth);
      ASSERT(srcCol1 <= srcWidth);

      if (srcCol1 == srcWidth) {
         /* last column fudge */
         srcCol1--;
         colWeight = 0.0;
      }

      if (flip) {
         srcCol0 = srcWidth - 1 - srcCol0;
         srcCol1 = srcWidth - 1 - srcCol1;
      }

      red = lerp_2d(colWeight, rowWeight,
                    srcColor0[srcCol0][RCOMP], srcColor0[srcCol1][RCOMP],
                    srcColor1[srcCol0][RCOMP], srcColor1[srcCol1][RCOMP]);
      green = lerp_2d(colWeight, rowWeight,
                    srcColor0[srcCol0][GCOMP], srcColor0[srcCol1][GCOMP],
                    srcColor1[srcCol0][GCOMP], srcColor1[srcCol1][GCOMP]);
      blue = lerp_2d(colWeight, rowWeight,
                    srcColor0[srcCol0][BCOMP], srcColor0[srcCol1][BCOMP],
                    srcColor1[srcCol0][BCOMP], srcColor1[srcCol1][BCOMP]);
      alpha = lerp_2d(colWeight, rowWeight,
                    srcColor0[srcCol0][ACOMP], srcColor0[srcCol1][ACOMP],
                    srcColor1[srcCol0][ACOMP], srcColor1[srcCol1][ACOMP]);
      
      dstColor[dstCol][RCOMP] = red;
      dstColor[dstCol][GCOMP] = green;
      dstColor[dstCol][BCOMP] = blue;
      dstColor[dstCol][ACOMP] = alpha;
   }
}


d316 1
a316 1
 * Bilinear filtered blit (color only, non-integer values).
d323 2
a324 5
   struct gl_framebuffer *drawFb = ctx->DrawBuffer;
   struct gl_framebuffer *readFb = ctx->ReadBuffer;
   struct gl_renderbuffer *readRb = readFb->_ColorReadBuffer;
   struct gl_renderbuffer_attachment *readAtt =
      &readFb->Attachment[readFb->_ColorReadBufferIndex];
d330 1
d347 2
a348 14
   gl_format readFormat = _mesa_get_srgb_format_linear(readRb->Format);
   GLuint bpp = _mesa_get_format_bytes(readFormat);

   GLenum pixelType;

   GLubyte *srcMap, *dstMap;
   GLint srcRowStride, dstRowStride;
   GLuint i;


   /* Determine datatype for resampling */
   if (_mesa_get_format_max_bits(readFormat) == 8 &&
       _mesa_get_format_datatype(readFormat) == GL_UNSIGNED_NORMALIZED) {
      pixelType = GL_UNSIGNED_BYTE;
d350 8
a357 3
   }
   else {
      pixelType = GL_FLOAT;
d359 5
d370 4
d375 5
d381 5
a385 2
   if (!srcBuffer0 || !srcBuffer1 || !dstBuffer) {
      goto fail_no_memory;
d388 45
a432 30
   for (i = 0; i < drawFb->_NumColorDrawBuffers; i++) {
      GLint idx = drawFb->_ColorDrawBufferIndexes[i];
      struct gl_renderbuffer_attachment *drawAtt;
      struct gl_renderbuffer *drawRb;
      gl_format drawFormat;

      if (idx == -1)
         continue;

      drawAtt = &drawFb->Attachment[idx];
      drawRb = drawAtt->Renderbuffer;
      if (!drawRb)
         continue;

      drawFormat = _mesa_get_srgb_format_linear(drawRb->Format);

      /*
       * Map src / dst renderbuffers
       */
      if ((readRb == drawRb) ||
          (readAtt->Texture && drawAtt->Texture &&
           (readAtt->Texture == drawAtt->Texture))) {
         /* map whole buffer for read/write */
         ctx->Driver.MapRenderbuffer(ctx, readRb,
                                     0, 0, readRb->Width, readRb->Height,
                                     GL_MAP_READ_BIT | GL_MAP_WRITE_BIT,
                                     &srcMap, &srcRowStride);
         if (!srcMap) {
            goto fail_no_memory;
         }
d434 3
a436 2
         dstMap = srcMap;
         dstRowStride = srcRowStride;
d439 2
a440 17
         /* different src/dst buffers */
         /* XXX with a bit of work we could just map the regions to be
          * read/written instead of the whole buffers.
          */
         ctx->Driver.MapRenderbuffer(ctx, readRb,
                                     0, 0, readRb->Width, readRb->Height,
                                     GL_MAP_READ_BIT, &srcMap, &srcRowStride);
         if (!srcMap) {
            goto fail_no_memory;
         }
         ctx->Driver.MapRenderbuffer(ctx, drawRb,
                                     0, 0, drawRb->Width, drawRb->Height,
                                     GL_MAP_WRITE_BIT, &dstMap, &dstRowStride);
         if (!dstMap) {
            ctx->Driver.UnmapRenderbuffer(ctx, readRb);
            goto fail_no_memory;
         }
d443 8
a450 12
      for (dstRow = 0; dstRow < dstHeight; dstRow++) {
         const GLint dstY = dstYpos + dstRow;
         GLfloat srcRow = (dstRow + 0.5F) / dstHeight * srcHeight - 0.5F;
         GLint srcRow0 = MAX2(0, IFLOOR(srcRow));
         GLint srcRow1 = srcRow0 + 1;
         GLfloat rowWeight = srcRow - srcRow0; /* fractional part of srcRow */

         if (srcRow1 == srcHeight) {
            /* last row fudge */
            srcRow1 = srcRow0;
            rowWeight = 0.0;
         }
a451 4
         if (invertY) {
            srcRow0 = srcHeight - 1 - srcRow0;
            srcRow1 = srcHeight - 1 - srcRow1;
         }
d453 41
a493 2
         srcY0 = srcYpos + srcRow0;
         srcY1 = srcYpos + srcRow1;
d495 20
a514 43
         /* get the two source rows */
         if (srcY0 == srcBufferY0 && srcY1 == srcBufferY1) {
            /* use same source row buffers again */
         }
         else if (srcY0 == srcBufferY1) {
            /* move buffer1 into buffer0 by swapping pointers */
            GLvoid *tmp = srcBuffer0;
            srcBuffer0 = srcBuffer1;
            srcBuffer1 = tmp;
            /* get y1 row */
            {
               GLubyte *src = srcMap + srcY1 * srcRowStride + srcXpos * bpp;
               if (pixelType == GL_UNSIGNED_BYTE) {
                  _mesa_unpack_ubyte_rgba_row(readFormat, srcWidth,
                                              src, srcBuffer1);
               }
               else {
                  _mesa_unpack_rgba_row(readFormat, srcWidth,
                                        src, srcBuffer1);
               }
            }
            srcBufferY0 = srcY0;
            srcBufferY1 = srcY1;
         }
         else {
            /* get both new rows */
            {
               GLubyte *src0 = srcMap + srcY0 * srcRowStride + srcXpos * bpp;
               GLubyte *src1 = srcMap + srcY1 * srcRowStride + srcXpos * bpp;
               if (pixelType == GL_UNSIGNED_BYTE) {
                  _mesa_unpack_ubyte_rgba_row(readFormat, srcWidth,
                                              src0, srcBuffer0);
                  _mesa_unpack_ubyte_rgba_row(readFormat, srcWidth,
                                              src1, srcBuffer1);
               }
               else {
                  _mesa_unpack_rgba_row(readFormat, srcWidth, src0, srcBuffer0);
                  _mesa_unpack_rgba_row(readFormat, srcWidth, src1, srcBuffer1);
               }
            }
            srcBufferY0 = srcY0;
            srcBufferY1 = srcY1;
         }
d516 1
a516 8
         if (pixelType == GL_UNSIGNED_BYTE) {
            resample_linear_row_ub(srcWidth, dstWidth, srcBuffer0, srcBuffer1,
                                   dstBuffer, invertX, rowWeight);
         }
         else {
            resample_linear_row_float(srcWidth, dstWidth, srcBuffer0, srcBuffer1,
                                      dstBuffer, invertX, rowWeight);
         }
d518 18
a535 11
         /* store pixel row in destination */
         {
            GLubyte *dst = dstMap + dstY * dstRowStride + dstXpos * bpp;
            if (pixelType == GL_UNSIGNED_BYTE) {
               _mesa_pack_ubyte_rgba_row(drawFormat, dstWidth, dstBuffer, dst);
            }
            else {
               _mesa_pack_float_rgba_row(drawFormat, dstWidth, dstBuffer, dst);
            }
         }
      }
d537 5
a541 4
      ctx->Driver.UnmapRenderbuffer(ctx, readRb);
      if (drawRb != readRb) {
         ctx->Driver.UnmapRenderbuffer(ctx, drawRb);
      }
d544 6
a549 4
   free(srcBuffer0);
   free(srcBuffer1);
   free(dstBuffer);
   return;
d551 1
a551 5
fail_no_memory:
   free(srcBuffer0);
   free(srcBuffer1);
   free(dstBuffer);
   _mesa_error(ctx, GL_OUT_OF_MEMORY, "glBlitFramebuffer");
a554 1

a568 5
   static const GLenum buffer_enums[3] = {
      GL_COLOR,
      GL_DEPTH,
      GL_STENCIL,
   };
d576 1
a576 2
   if (SWRAST_CONTEXT(ctx)->NewState)
      _swrast_validate_derived(ctx);
a577 3
   /* First, try covering whatever buffers possible using the fast 1:1 copy
    * path.
    */
d584 3
d589 3
a591 8
	    if (swrast_fast_copy_pixels(ctx,
					srcX0, srcY0,
					srcX1 - srcX0, srcY1 - srcY0,
					dstX0, dstY0,
					buffer_enums[i])) {
	       mask &= ~buffers[i];
	    }
	 }
a592 3

      if (!mask)
	 return;
d594 8
a601 7

   if (filter == GL_NEAREST) {
      for (i = 0; i < 3; i++) {
	 if (mask & buffers[i]) {
	    blit_nearest(ctx,  srcX0, srcY0, srcX1, srcY1,
			 dstX0, dstY0, dstX1, dstY1, buffers[i]);
	 }
d603 6
a608 6
   }
   else {
      ASSERT(filter == GL_LINEAR);
      if (mask & GL_COLOR_BUFFER_BIT) {  /* depth/stencil not allowed */
	 blit_linear(ctx,  srcX0, srcY0, srcX1, srcY1,
		     dstX0, dstY0, dstX1, dstY1);
d612 1
@


1.1.1.4
log
@Import Mesa 10.2.3
@
text
@a31 1
#include "main/condrender.h"
d169 2
a170 2
      if (readRb->Format == MESA_FORMAT_Z_FLOAT32 ||
	  readRb->Format == MESA_FORMAT_Z32_FLOAT_S8X24_UINT) {
d539 1
a539 1
   mesa_format readFormat = _mesa_get_srgb_format_linear(readRb->Format);
d574 1
a574 1
      mesa_format drawFormat;
a749 7

   /* Page 679 of OpenGL 4.4 spec says:
    *    "Added BlitFramebuffer to commands affected by conditional rendering in
    *     section 10.10 (Bug 9562)."
    */
   if (!_mesa_check_conditional_render(ctx))
      return; /* Do not blit */
@


