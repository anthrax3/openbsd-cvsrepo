head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.8
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.6
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.5
	v10_2_7:1.1.1.5
	OPENBSD_5_6:1.7.0.4
	OPENBSD_5_6_BASE:1.7
	v10_2_3:1.1.1.5
	OPENBSD_5_5:1.7.0.2
	OPENBSD_5_5_BASE:1.7
	v9_2_5:1.1.1.5
	v9_2_3:1.1.1.5
	v9_2_2:1.1.1.5
	v9_2_1:1.1.1.5
	v9_2_0:1.1.1.5
	OPENBSD_5_4:1.6.0.4
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.3.0.4
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.55;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2013.09.05.14.06.49;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2012.08.17.13.58.20;	author mpi;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.23.13.37.45;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.34;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.42;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.23;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.51.20;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.51.20;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.56.50;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.32.08;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.48;	author matthieu;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.09.05.13.17.30;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */


#include "main/glheader.h"
#include "main/colormac.h"
#include "main/macros.h"

#include "s_context.h"
#include "s_fog.h"


/**
 * Used to convert current raster distance to a fog factor in [0,1].
 */
GLfloat
_swrast_z_to_fogfactor(struct gl_context *ctx, GLfloat z)
{
   GLfloat d, f;

   switch (ctx->Fog.Mode) {
   case GL_LINEAR:
      if (ctx->Fog.Start == ctx->Fog.End)
         d = 1.0F;
      else
         d = 1.0F / (ctx->Fog.End - ctx->Fog.Start);
      f = (ctx->Fog.End - z) * d;
      return CLAMP(f, 0.0F, 1.0F);
   case GL_EXP:
      d = ctx->Fog.Density;
      f = EXPF(-d * z);
      f = CLAMP(f, 0.0F, 1.0F);
      return f;
   case GL_EXP2:
      d = ctx->Fog.Density;
      f = EXPF(-(d * d * z * z));
      f = CLAMP(f, 0.0F, 1.0F);
      return f;
   default:
      _mesa_problem(ctx, "Bad fog mode in _swrast_z_to_fogfactor");
      return 0.0; 
   }
}


#define LINEAR_FOG(f, coord)  f = (fogEnd - coord) * fogScale

#define EXP_FOG(f, coord)  f = EXPF(density * coord)

#define EXP2_FOG(f, coord)				\
do {							\
   GLfloat tmp = negDensitySquared * coord * coord;	\
   if (tmp < FLT_MIN_10_EXP)				\
      tmp = FLT_MIN_10_EXP;				\
   f = EXPF(tmp);					\
 } while(0)


#define BLEND_FOG(f, coord)  f = coord



/**
 * Template code for computing fog blend factor and applying it to colors.
 * \param TYPE  either GLubyte, GLushort or GLfloat.
 * \param COMPUTE_F  code to compute the fog blend factor, f.
 */
#define FOG_LOOP(TYPE, FOG_FUNC)						\
if (span->arrayAttribs & VARYING_BIT_FOGC) {					\
   GLuint i;									\
   for (i = 0; i < span->end; i++) {						\
      const GLfloat fogCoord = span->array->attribs[VARYING_SLOT_FOGC][i][0];	\
      const GLfloat c = FABSF(fogCoord);					\
      GLfloat f, oneMinusF;							\
      FOG_FUNC(f, c);								\
      f = CLAMP(f, 0.0F, 1.0F);							\
      oneMinusF = 1.0F - f;							\
      rgba[i][RCOMP] = (TYPE) (f * rgba[i][RCOMP] + oneMinusF * rFog);		\
      rgba[i][GCOMP] = (TYPE) (f * rgba[i][GCOMP] + oneMinusF * gFog);		\
      rgba[i][BCOMP] = (TYPE) (f * rgba[i][BCOMP] + oneMinusF * bFog);		\
   }										\
}										\
else {										\
   const GLfloat fogStep = span->attrStepX[VARYING_SLOT_FOGC][0];		\
   GLfloat fogCoord = span->attrStart[VARYING_SLOT_FOGC][0];			\
   const GLfloat wStep = span->attrStepX[VARYING_SLOT_POS][3];			\
   GLfloat w = span->attrStart[VARYING_SLOT_POS][3];				\
   GLuint i;									\
   for (i = 0; i < span->end; i++) {						\
      const GLfloat c = FABSF(fogCoord) / w;					\
      GLfloat f, oneMinusF;							\
      FOG_FUNC(f, c);								\
      f = CLAMP(f, 0.0F, 1.0F);							\
      oneMinusF = 1.0F - f;							\
      rgba[i][RCOMP] = (TYPE) (f * rgba[i][RCOMP] + oneMinusF * rFog);		\
      rgba[i][GCOMP] = (TYPE) (f * rgba[i][GCOMP] + oneMinusF * gFog);		\
      rgba[i][BCOMP] = (TYPE) (f * rgba[i][BCOMP] + oneMinusF * bFog);		\
      fogCoord += fogStep;							\
      w += wStep;								\
   }										\
}

/**
 * Apply fog to a span of RGBA pixels.
 * The fog value are either in the span->array->fog array or interpolated from
 * the fog/fogStep values.
 * They fog values are either fog coordinates (Z) or fog blend factors.
 * _PreferPixelFog should be in sync with that state!
 */
void
_swrast_fog_rgba_span( const struct gl_context *ctx, SWspan *span )
{
   const SWcontext *swrast = CONST_SWRAST_CONTEXT(ctx);
   GLfloat rFog, gFog, bFog;

   ASSERT(swrast->_FogEnabled);
   ASSERT(span->arrayMask & SPAN_RGBA);

   /* compute (scaled) fog color */
   if (span->array->ChanType == GL_UNSIGNED_BYTE) {
      rFog = ctx->Fog.Color[RCOMP] * 255.0F;
      gFog = ctx->Fog.Color[GCOMP] * 255.0F;
      bFog = ctx->Fog.Color[BCOMP] * 255.0F;
   }
   else if (span->array->ChanType == GL_UNSIGNED_SHORT) {
      rFog = ctx->Fog.Color[RCOMP] * 65535.0F;
      gFog = ctx->Fog.Color[GCOMP] * 65535.0F;
      bFog = ctx->Fog.Color[BCOMP] * 65535.0F;
   }
   else {
      rFog = ctx->Fog.Color[RCOMP];
      gFog = ctx->Fog.Color[GCOMP];
      bFog = ctx->Fog.Color[BCOMP];
   }

   if (swrast->_PreferPixelFog) {
      /* The span's fog values are fog coordinates, now compute blend factors
       * and blend the fragment colors with the fog color.
       */
      switch (ctx->Fog.Mode) {
      case GL_LINEAR:
         {
            const GLfloat fogEnd = ctx->Fog.End;
            const GLfloat fogScale = (ctx->Fog.Start == ctx->Fog.End)
               ? 1.0F : 1.0F / (ctx->Fog.End - ctx->Fog.Start);
            if (span->array->ChanType == GL_UNSIGNED_BYTE) {
               GLubyte (*rgba)[4] = span->array->rgba8;
               FOG_LOOP(GLubyte, LINEAR_FOG);
            }
            else if (span->array->ChanType == GL_UNSIGNED_SHORT) {
               GLushort (*rgba)[4] = span->array->rgba16;
               FOG_LOOP(GLushort, LINEAR_FOG);
            }
            else {
               GLfloat (*rgba)[4] = span->array->attribs[VARYING_SLOT_COL0];
               ASSERT(span->array->ChanType == GL_FLOAT);
               FOG_LOOP(GLfloat, LINEAR_FOG);
            }
         }
         break;

      case GL_EXP:
         {
            const GLfloat density = -ctx->Fog.Density;
            if (span->array->ChanType == GL_UNSIGNED_BYTE) {
               GLubyte (*rgba)[4] = span->array->rgba8;
               FOG_LOOP(GLubyte, EXP_FOG);
            }
            else if (span->array->ChanType == GL_UNSIGNED_SHORT) {
               GLushort (*rgba)[4] = span->array->rgba16;
               FOG_LOOP(GLushort, EXP_FOG);
            }
            else {
               GLfloat (*rgba)[4] = span->array->attribs[VARYING_SLOT_COL0];
               ASSERT(span->array->ChanType == GL_FLOAT);
               FOG_LOOP(GLfloat, EXP_FOG);
            }
         }
         break;

      case GL_EXP2:
         {
            const GLfloat negDensitySquared = -ctx->Fog.Density * ctx->Fog.Density;
            if (span->array->ChanType == GL_UNSIGNED_BYTE) {
               GLubyte (*rgba)[4] = span->array->rgba8;
               FOG_LOOP(GLubyte, EXP2_FOG);
            }
            else if (span->array->ChanType == GL_UNSIGNED_SHORT) {
               GLushort (*rgba)[4] = span->array->rgba16;
               FOG_LOOP(GLushort, EXP2_FOG);
            }
            else {
               GLfloat (*rgba)[4] = span->array->attribs[VARYING_SLOT_COL0];
               ASSERT(span->array->ChanType == GL_FLOAT);
               FOG_LOOP(GLfloat, EXP2_FOG);
            }
         }
         break;

      default:
         _mesa_problem(ctx, "Bad fog mode in _swrast_fog_rgba_span");
         return;
      }
   }
   else {
      /* The span's fog start/step/array values are blend factors in [0,1].
       * They were previously computed per-vertex.
       */
      if (span->array->ChanType == GL_UNSIGNED_BYTE) {
         GLubyte (*rgba)[4] = span->array->rgba8;
         FOG_LOOP(GLubyte, BLEND_FOG);
      }
      else if (span->array->ChanType == GL_UNSIGNED_SHORT) {
         GLushort (*rgba)[4] = span->array->rgba16;
         FOG_LOOP(GLushort, BLEND_FOG);
      }
      else {
         GLfloat (*rgba)[4] = span->array->attribs[VARYING_SLOT_COL0];
         ASSERT(span->array->ChanType == GL_FLOAT);
         FOG_LOOP(GLfloat, BLEND_FOG);
      }
   }
}
@


1.7
log
@Merge Mesa 9.2.0
@
text
@@


1.6
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a2 1
 * Version:  6.5.2
d19 4
a22 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
d90 1
a90 1
if (span->arrayAttribs & FRAG_BIT_FOGC) {					\
d93 1
a93 1
      const GLfloat fogCoord = span->array->attribs[FRAG_ATTRIB_FOGC][i][0];	\
d105 4
a108 4
   const GLfloat fogStep = span->attrStepX[FRAG_ATTRIB_FOGC][0];		\
   GLfloat fogCoord = span->attrStart[FRAG_ATTRIB_FOGC][0];			\
   const GLfloat wStep = span->attrStepX[FRAG_ATTRIB_WPOS][3];			\
   GLfloat w = span->attrStart[FRAG_ATTRIB_WPOS][3];				\
d176 1
a176 1
               GLfloat (*rgba)[4] = span->array->attribs[FRAG_ATTRIB_COL0];
d195 1
a195 1
               GLfloat (*rgba)[4] = span->array->attribs[FRAG_ATTRIB_COL0];
d214 1
a214 1
               GLfloat (*rgba)[4] = span->array->attribs[FRAG_ATTRIB_COL0];
d239 1
a239 1
         GLfloat (*rgba)[4] = span->array->attribs[FRAG_ATTRIB_COL0];
@


1.5
log
@Merge Mesa 7.10.3
@
text
@d161 1
a161 1
      switch (swrast->_FogMode) {
@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@a27 1
#include "main/context.h"
d38 1
a38 1
_swrast_z_to_fogfactor(GLcontext *ctx, GLfloat z)
d132 1
a132 1
_swrast_fog_rgba_span( const GLcontext *ctx, SWspan *span )
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@a124 32
/* As above, but CI mode (XXX try to merge someday) */
#define FOG_LOOP_CI(FOG_FUNC)							\
if (span->arrayAttribs & FRAG_BIT_FOGC) {					\
   GLuint i;									\
   for (i = 0; i < span->end; i++) {						\
      const GLfloat fogCoord = span->array->attribs[FRAG_ATTRIB_FOGC][i][0];	\
      const GLfloat c = FABSF(fogCoord);					\
      GLfloat f;								\
      FOG_FUNC(f, c);								\
      f = CLAMP(f, 0.0F, 1.0F);							\
      index[i] = (GLuint) ((GLfloat) index[i] + (1.0F - f) * fogIndex);		\
   }										\
}										\
else {										\
   const GLfloat fogStep = span->attrStepX[FRAG_ATTRIB_FOGC][0];		\
   GLfloat fogCoord = span->attrStart[FRAG_ATTRIB_FOGC][0];			\
   const GLfloat wStep = span->attrStepX[FRAG_ATTRIB_WPOS][3];  		\
   GLfloat w = span->attrStart[FRAG_ATTRIB_WPOS][3];				\
   GLuint i;									\
   for (i = 0; i < span->end; i++) {						\
      const GLfloat c = FABSF(fogCoord) / w;					\
      GLfloat f;								\
      FOG_FUNC(f, c);								\
      f = CLAMP(f, 0.0F, 1.0F);							\
      index[i] = (GLuint) ((GLfloat) index[i] + (1.0F - f) * fogIndex);		\
      fogCoord += fogStep;							\
      w += wStep;								\
   }										\
}



d135 1
a135 1
   const SWcontext *swrast = SWRAST_CONTEXT(ctx);
d143 3
a145 3
      rFog = ctx->Fog.Color[RCOMP] * 255.0;
      gFog = ctx->Fog.Color[GCOMP] * 255.0;
      bFog = ctx->Fog.Color[BCOMP] * 255.0;
d148 3
a150 3
      rFog = ctx->Fog.Color[RCOMP] * 65535.0;
      gFog = ctx->Fog.Color[GCOMP] * 65535.0;
      bFog = ctx->Fog.Color[BCOMP] * 65535.0;
a243 53
   }
}


/**
 * As above, but color index mode.
 */
void
_swrast_fog_ci_span( const GLcontext *ctx, SWspan *span )
{
   const SWcontext *swrast = SWRAST_CONTEXT(ctx);
   const GLuint fogIndex = (GLuint) ctx->Fog.Index;
   GLuint *index = span->array->index;

   ASSERT(swrast->_FogEnabled);
   ASSERT(span->arrayMask & SPAN_INDEX);

   /* we need to compute fog blend factors */
   if (swrast->_PreferPixelFog) {
      /* The span's fog values are fog coordinates, now compute blend factors
       * and blend the fragment colors with the fog color.
       */
      switch (ctx->Fog.Mode) {
      case GL_LINEAR:
         {
            const GLfloat fogEnd = ctx->Fog.End;
            const GLfloat fogScale = (ctx->Fog.Start == ctx->Fog.End)
               ? 1.0F : 1.0F / (ctx->Fog.End - ctx->Fog.Start);
            FOG_LOOP_CI(LINEAR_FOG);
         }
         break;
      case GL_EXP:
         {
            const GLfloat density = -ctx->Fog.Density;
            FOG_LOOP_CI(EXP_FOG);
         }
         break;
      case GL_EXP2:
         {
            const GLfloat negDensitySquared = -ctx->Fog.Density * ctx->Fog.Density;
            FOG_LOOP_CI(EXP2_FOG);
         }
         break;
      default:
         _mesa_problem(ctx, "Bad fog mode in _swrast_fog_ci_span");
         return;
      }
   }
   else {
      /* The span's fog start/step/array values are blend factors in [0,1].
       * They were previously computed per-vertex.
       */
      FOG_LOOP_CI(BLEND_FOG);
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d26 4
a29 4
#include "glheader.h"
#include "colormac.h"
#include "context.h"
#include "macros.h"
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * Version:  6.3
d5 1
a5 1
 * Copyright (C) 1999-2005  Brian Paul   All Rights Reserved.
a32 1
#include "s_span.h"
d68 89
d165 1
a165 1
_swrast_fog_rgba_span( const GLcontext *ctx, struct sw_span *span )
d168 1
a168 5
   const GLchan rFog = swrast->_FogColor[RCOMP];
   const GLchan gFog = swrast->_FogColor[GCOMP];
   const GLchan bFog = swrast->_FogColor[BCOMP];
   const GLuint haveW = (span->interpMask & SPAN_W);
   GLchan (*rgba)[4] = (GLchan (*)[4]) span->array->rgba;
a170 1
   ASSERT((span->interpMask | span->arrayMask) & SPAN_FOG);
d173 16
a188 3
   /* NOTE: if haveW is true, that means the fog start/step values are
    * perspective-corrected and we have to divide each fog coord by W.
    */
a189 1
   /* we need to compute fog blend factors */
d200 12
a211 15
            const GLfloat fogStep = span->fogStep;
            GLfloat fogCoord = span->fog;
            const GLfloat wStep = haveW ? span->dwdx : 0.0F;
            GLfloat w = haveW ? span->w : 1.0F;
            GLuint i;
            for (i = 0; i < span->end; i++) {
               GLfloat f, oneMinusF;
               f = (fogEnd - FABSF(fogCoord) / w) * fogScale;
               f = CLAMP(f, 0.0F, 1.0F);
               oneMinusF = 1.0F - f;
               rgba[i][RCOMP] = (GLchan) (f * rgba[i][RCOMP] + oneMinusF * rFog);
               rgba[i][GCOMP] = (GLchan) (f * rgba[i][GCOMP] + oneMinusF * gFog);
               rgba[i][BCOMP] = (GLchan) (f * rgba[i][BCOMP] + oneMinusF * bFog);
               fogCoord += fogStep;
               w += wStep;
d215 1
d219 12
a230 15
            const GLfloat fogStep = span->fogStep;
            GLfloat fogCoord = span->fog;
            const GLfloat wStep = haveW ? span->dwdx : 0.0F;
            GLfloat w = haveW ? span->w : 1.0F;
            GLuint i;
            for (i = 0; i < span->end; i++) {
               GLfloat f, oneMinusF;
               f = EXPF(density * FABSF(fogCoord) / w);
               f = CLAMP(f, 0.0F, 1.0F);
               oneMinusF = 1.0F - f;
               rgba[i][RCOMP] = (GLchan) (f * rgba[i][RCOMP] + oneMinusF * rFog);
               rgba[i][GCOMP] = (GLchan) (f * rgba[i][GCOMP] + oneMinusF * gFog);
               rgba[i][BCOMP] = (GLchan) (f * rgba[i][BCOMP] + oneMinusF * bFog);
               fogCoord += fogStep;
               w += wStep;
d234 1
d238 12
a249 22
            const GLfloat fogStep = span->fogStep;
            GLfloat fogCoord = span->fog;
            const GLfloat wStep = haveW ? span->dwdx : 0.0F;
            GLfloat w = haveW ? span->w : 1.0F;
            GLuint i;
            for (i = 0; i < span->end; i++) {
               const GLfloat coord = fogCoord / w;
               GLfloat tmp = negDensitySquared * coord * coord;
               GLfloat f, oneMinusF;
#if defined(__alpha__) || defined(__alpha)
               /* XXX this underflow check may be needed for other systems*/
               if (tmp < FLT_MIN_10_EXP)
                  tmp = FLT_MIN_10_EXP;
#endif
               f = EXPF(tmp);
               f = CLAMP(f, 0.0F, 1.0F);
               oneMinusF = 1.0F - f;
               rgba[i][RCOMP] = (GLchan) (f * rgba[i][RCOMP] + oneMinusF * rFog);
               rgba[i][GCOMP] = (GLchan) (f * rgba[i][GCOMP] + oneMinusF * gFog);
               rgba[i][BCOMP] = (GLchan) (f * rgba[i][BCOMP] + oneMinusF * bFog);
               fogCoord += fogStep;
               w += wStep;
d253 1
d259 2
a260 2
   else if (span->arrayMask & SPAN_FOG) {
      /* The span's fog array values are blend factors.
d263 7
a269 7
      GLuint i;
      for (i = 0; i < span->end; i++) {
         const GLfloat f = span->array->fog[i];
         const GLfloat oneMinusF = 1.0F - f;
         rgba[i][RCOMP] = (GLchan) (f * rgba[i][RCOMP] + oneMinusF * rFog);
         rgba[i][GCOMP] = (GLchan) (f * rgba[i][GCOMP] + oneMinusF * gFog);
         rgba[i][BCOMP] = (GLchan) (f * rgba[i][BCOMP] + oneMinusF * bFog);
d271 4
a274 19
   }
   else {
      /* The span's fog start/step values are blend factors.
       * They were previously computed per-vertex.
       */
      const GLfloat fogStep = span->fogStep;
      GLfloat fog = span->fog;
      const GLfloat wStep = haveW ? span->dwdx : 0.0F;
      GLfloat w = haveW ? span->w : 1.0F;
      GLuint i;
      ASSERT(span->interpMask & SPAN_FOG);
      for (i = 0; i < span->end; i++) {
         const GLfloat fact = fog / w;
         const GLfloat oneMinusF = 1.0F - fact;
         rgba[i][RCOMP] = (GLchan) (fact * rgba[i][RCOMP] + oneMinusF * rFog);
         rgba[i][GCOMP] = (GLchan) (fact * rgba[i][GCOMP] + oneMinusF * gFog);
         rgba[i][BCOMP] = (GLchan) (fact * rgba[i][BCOMP] + oneMinusF * bFog);
         fog += fogStep;
         w += wStep;
d284 1
a284 1
_swrast_fog_ci_span( const GLcontext *ctx, struct sw_span *span )
a286 1
   const GLuint haveW = (span->interpMask & SPAN_W);
a291 1
   ASSERT((span->interpMask | span->arrayMask) & SPAN_FOG);
d304 1
a304 12
            const GLfloat fogStep = span->fogStep;
            GLfloat fogCoord = span->fog;
            const GLfloat wStep = haveW ? span->dwdx : 0.0F;
            GLfloat w = haveW ? span->w : 1.0F;
            GLuint i;
            for (i = 0; i < span->end; i++) {
               GLfloat f = (fogEnd - fogCoord / w) * fogScale;
               f = CLAMP(f, 0.0F, 1.0F);
               index[i] = (GLuint) ((GLfloat) index[i] + (1.0F - f) * fogIndex);
               fogCoord += fogStep;
               w += wStep;
            }
d310 1
a310 12
            const GLfloat fogStep = span->fogStep;
            GLfloat fogCoord = span->fog;
            const GLfloat wStep = haveW ? span->dwdx : 0.0F;
            GLfloat w = haveW ? span->w : 1.0F;
            GLuint i;
            for (i = 0; i < span->end; i++) {
               GLfloat f = EXPF(density * fogCoord / w);
               f = CLAMP(f, 0.0F, 1.0F);
               index[i] = (GLuint) ((GLfloat) index[i] + (1.0F - f) * fogIndex);
               fogCoord += fogStep;
               w += wStep;
            }
d316 1
a316 20
            const GLfloat fogStep = span->fogStep;
            GLfloat fogCoord = span->fog;
            const GLfloat wStep = haveW ? span->dwdx : 0.0F;
            GLfloat w = haveW ? span->w : 1.0F;
            GLuint i;
            for (i = 0; i < span->end; i++) {
               const GLfloat coord = fogCoord / w;
               GLfloat tmp = negDensitySquared * coord * coord;
               GLfloat f;
#if defined(__alpha__) || defined(__alpha)
               /* XXX this underflow check may be needed for other systems*/
               if (tmp < FLT_MIN_10_EXP)
                  tmp = FLT_MIN_10_EXP;
#endif
               f = EXPF(tmp);
               f = CLAMP(f, 0.0F, 1.0F);
               index[i] = (GLuint) ((GLfloat) index[i] + (1.0F - f) * fogIndex);
               fogCoord += fogStep;
               w += wStep;
            }
a323 10
   else if (span->arrayMask & SPAN_FOG) {
      /* The span's fog array values are blend factors.
       * They were previously computed per-vertex.
       */
      GLuint i;
      for (i = 0; i < span->end; i++) {
         const GLfloat f = span->array->fog[i];
         index[i] = (GLuint) ((GLfloat) index[i] + (1.0F - f) * fogIndex);
      }
   }
d325 1
a325 1
      /* The span's fog start/step values are blend factors.
d328 1
a328 12
      const GLfloat fogStep = span->fogStep;
      GLfloat fog = span->fog;
      const GLfloat wStep = haveW ? span->dwdx : 0.0F;
      GLfloat w = haveW ? span->w : 1.0F;
      GLuint i;
      ASSERT(span->interpMask & SPAN_FOG);
      for (i = 0; i < span->end; i++) {
         const GLfloat f = fog / w;
         index[i] = (GLuint) ((GLfloat) index[i] + (1.0F - f) * fogIndex);
         fog += fogStep;
         w += wStep;
      }
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d3 1
a3 1
 * Version:  6.5.2
d5 1
a5 1
 * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
d33 1
a69 27
 * Template code for computing fog blend factor and applying it to colors.
 * \param TYPE  either GLubyte, GLushort or GLfloat.
 * \param COMPUTE_F  code to compute the fog blend factor, f.
 */
#define FOG_LOOP(TYPE, COMPUTE_F)					\
do {									\
   const GLfloat fogStep = span->fogStep;				\
   GLfloat fogCoord = span->fog;					\
   const GLfloat wStep = haveW ? span->dwdx : 0.0F;			\
   GLfloat w = haveW ? span->w : 1.0F;					\
   GLuint i;								\
   for (i = 0; i < span->end; i++) {					\
      GLfloat f, oneMinusF;						\
      COMPUTE_F;							\
      f = CLAMP(f, 0.0F, 1.0F);						\
      oneMinusF = 1.0F - f;						\
      rgba[i][RCOMP] = (TYPE) (f * rgba[i][RCOMP] + oneMinusF * rFog);	\
      rgba[i][GCOMP] = (TYPE) (f * rgba[i][GCOMP] + oneMinusF * gFog);	\
      rgba[i][BCOMP] = (TYPE) (f * rgba[i][BCOMP] + oneMinusF * bFog);	\
      fogCoord += fogStep;						\
      w += wStep;							\
   }									\
} while (0)



/**
d77 1
a77 1
_swrast_fog_rgba_span( const GLcontext *ctx, SWspan *span )
d80 3
a82 1
   GLfloat rFog, gFog, bFog;
d84 1
a89 17
   if (span->array->ChanType == GL_UNSIGNED_BYTE) {
      rFog = ctx->Fog.Color[RCOMP] * 255.0;
      gFog = ctx->Fog.Color[GCOMP] * 255.0;
      bFog = ctx->Fog.Color[BCOMP] * 255.0;
   }
   else if (span->array->ChanType == GL_UNSIGNED_SHORT) {
      rFog = ctx->Fog.Color[RCOMP] * 65535.0;
      gFog = ctx->Fog.Color[GCOMP] * 65535.0;
      bFog = ctx->Fog.Color[BCOMP] * 65535.0;
   }
   else {
      rFog = ctx->Fog.Color[RCOMP];
      gFog = ctx->Fog.Color[GCOMP];
      bFog = ctx->Fog.Color[BCOMP];
   }


a98 6
      const GLfloat fogEnd = ctx->Fog.End;
      const GLfloat fogScale = (ctx->Fog.Start == ctx->Fog.End)
         ? 1.0F : 1.0F / (ctx->Fog.End - ctx->Fog.Start);
      const GLfloat density = -ctx->Fog.Density;
      const GLfloat negDensitySquared = -ctx->Fog.Density * ctx->Fog.Density;

d101 20
a120 4
#define COMPUTE_F  f = (fogEnd - FABSF(fogCoord) / w) * fogScale;
         if (span->array->ChanType == GL_UNSIGNED_BYTE) {
            GLubyte (*rgba)[4] = span->array->color.sz1.rgba;
            FOG_LOOP(GLubyte, COMPUTE_F);
a121 10
         else if (span->array->ChanType == GL_UNSIGNED_SHORT) {
            GLushort (*rgba)[4] = span->array->color.sz2.rgba;
            FOG_LOOP(GLushort, COMPUTE_F);
         }
         else {
            GLfloat (*rgba)[4] = span->array->color.sz4.rgba;
            ASSERT(span->array->ChanType == GL_FLOAT);
            FOG_LOOP(GLfloat, COMPUTE_F);
         }
#undef COMPUTE_F
a122 1

d124 18
a141 4
#define COMPUTE_F  f = EXPF(density * FABSF(fogCoord) / w);
         if (span->array->ChanType == GL_UNSIGNED_BYTE) {
            GLubyte (*rgba)[4] = span->array->color.sz1.rgba;
            FOG_LOOP(GLubyte, COMPUTE_F);
a142 10
         else if (span->array->ChanType == GL_UNSIGNED_SHORT) {
            GLushort (*rgba)[4] = span->array->color.sz2.rgba;
            FOG_LOOP(GLushort, COMPUTE_F);
         }
         else {
            GLfloat (*rgba)[4] = span->array->color.sz4.rgba;
            ASSERT(span->array->ChanType == GL_FLOAT);
            FOG_LOOP(GLfloat, COMPUTE_F);
         }
#undef COMPUTE_F
a143 1

d145 25
a169 12
#define COMPUTE_F  const GLfloat coord = fogCoord / w; \
                   GLfloat tmp = negDensitySquared * coord * coord; \
                   if (tmp < FLT_MIN_10_EXP) \
                      tmp = FLT_MIN_10_EXP; \
                   f = EXPF(tmp);
         if (span->array->ChanType == GL_UNSIGNED_BYTE) {
            GLubyte (*rgba)[4] = span->array->color.sz1.rgba;
            FOG_LOOP(GLubyte, COMPUTE_F);
         }
         else if (span->array->ChanType == GL_UNSIGNED_SHORT) {
            GLushort (*rgba)[4] = span->array->color.sz2.rgba;
            FOG_LOOP(GLushort, COMPUTE_F);
a170 6
         else {
            GLfloat (*rgba)[4] = span->array->color.sz4.rgba;
            ASSERT(span->array->ChanType == GL_FLOAT);
            FOG_LOOP(GLfloat, COMPUTE_F);
         }
#undef COMPUTE_F
a171 1

d182 6
a187 9
      if (span->array->ChanType == GL_UNSIGNED_BYTE) {
         GLubyte (*rgba)[4] = span->array->color.sz1.rgba;
         for (i = 0; i < span->end; i++) {
            const GLfloat f = span->array->fog[i];
            const GLfloat oneMinusF = 1.0F - f;
            rgba[i][RCOMP] = (GLubyte) (f * rgba[i][RCOMP] + oneMinusF * rFog);
            rgba[i][GCOMP] = (GLubyte) (f * rgba[i][GCOMP] + oneMinusF * gFog);
            rgba[i][BCOMP] = (GLubyte) (f * rgba[i][BCOMP] + oneMinusF * bFog);
         }
a188 22
      else if (span->array->ChanType == GL_UNSIGNED_SHORT) {
         GLushort (*rgba)[4] = span->array->color.sz2.rgba;
         for (i = 0; i < span->end; i++) {
            const GLfloat f = span->array->fog[i];
            const GLfloat oneMinusF = 1.0F - f;
            rgba[i][RCOMP] = (GLushort) (f * rgba[i][RCOMP] + oneMinusF * rFog);
            rgba[i][GCOMP] = (GLushort) (f * rgba[i][GCOMP] + oneMinusF * gFog);
            rgba[i][BCOMP] = (GLushort) (f * rgba[i][BCOMP] + oneMinusF * bFog);
         }
      }
      else {
         GLfloat (*rgba)[4] = span->array->color.sz4.rgba;
         ASSERT(span->array->ChanType == GL_FLOAT);
         for (i = 0; i < span->end; i++) {
            const GLfloat f = span->array->fog[i];
            const GLfloat oneMinusF = 1.0F - f;
            rgba[i][RCOMP] = f * rgba[i][RCOMP] + oneMinusF * rFog;
            rgba[i][GCOMP] = f * rgba[i][GCOMP] + oneMinusF * gFog;
            rgba[i][BCOMP] = f * rgba[i][BCOMP] + oneMinusF * bFog;
         }
      }

d194 14
a207 13
#define COMPUTE_F f = fogCoord / w;
      if (span->array->ChanType == GL_UNSIGNED_BYTE) {
         GLubyte (*rgba)[4] = span->array->color.sz1.rgba;
         FOG_LOOP(GLubyte, COMPUTE_F);
      }
      else if (span->array->ChanType == GL_UNSIGNED_SHORT) {
         GLushort (*rgba)[4] = span->array->color.sz2.rgba;
         FOG_LOOP(GLushort, COMPUTE_F);
      }
      else {
         GLfloat (*rgba)[4] = span->array->color.sz4.rgba;
         ASSERT(span->array->ChanType == GL_FLOAT);
         FOG_LOOP(GLfloat, COMPUTE_F);
a208 1
#undef COMPUTE_F
d217 1
a217 1
_swrast_fog_ci_span( const GLcontext *ctx, SWspan *span )
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d75 4
a78 4
   const GLfloat fogStep = span->attrStepX[FRAG_ATTRIB_FOGC][0];	\
   GLfloat fogCoord = span->attrStart[FRAG_ATTRIB_FOGC][0];		\
   const GLfloat wStep = haveW ? span->attrStepX[FRAG_ATTRIB_WPOS][3] : 0.0F;\
   GLfloat w = haveW ? span->attrStart[FRAG_ATTRIB_WPOS][3] : 1.0F;	\
d157 1
a157 1
            GLfloat (*rgba)[4] = span->array->attribs[FRAG_ATTRIB_COL0];
d175 1
a175 1
            GLfloat (*rgba)[4] = span->array->attribs[FRAG_ATTRIB_COL0];
d197 1
a197 1
            GLfloat (*rgba)[4] = span->array->attribs[FRAG_ATTRIB_COL0];
d217 1
a217 1
            const GLfloat f = span->array->attribs[FRAG_ATTRIB_FOGC][i][0];
d227 1
a227 1
            const GLfloat f = span->array->attribs[FRAG_ATTRIB_FOGC][i][0];
d235 1
a235 1
         GLfloat (*rgba)[4] = span->array->attribs[FRAG_ATTRIB_COL0];
d238 1
a238 1
            const GLfloat f = span->array->attribs[FRAG_ATTRIB_FOGC][i][0];
d261 1
a261 1
         GLfloat (*rgba)[4] = span->array->attribs[FRAG_ATTRIB_COL0];
d296 4
a299 4
            const GLfloat fogStep = span->attrStepX[FRAG_ATTRIB_FOGC][0];
            GLfloat fogCoord = span->attrStart[FRAG_ATTRIB_FOGC][0];
            const GLfloat wStep = haveW ? span->attrStepX[FRAG_ATTRIB_WPOS][3] : 0.0F;
            GLfloat w = haveW ? span->attrStart[FRAG_ATTRIB_WPOS][3] : 1.0F;
d313 4
a316 4
            const GLfloat fogStep = span->attrStepX[FRAG_ATTRIB_FOGC][0];
            GLfloat fogCoord = span->attrStart[FRAG_ATTRIB_FOGC][0];
            const GLfloat wStep = haveW ? span->attrStepX[FRAG_ATTRIB_WPOS][3] : 0.0F;
            GLfloat w = haveW ? span->attrStart[FRAG_ATTRIB_WPOS][3] : 1.0F;
d330 4
a333 4
            const GLfloat fogStep = span->attrStepX[FRAG_ATTRIB_FOGC][0];
            GLfloat fogCoord = span->attrStart[FRAG_ATTRIB_FOGC][0];
            const GLfloat wStep = haveW ? span->attrStepX[FRAG_ATTRIB_WPOS][3] : 0.0F;
            GLfloat w = haveW ? span->attrStart[FRAG_ATTRIB_WPOS][3] : 1.0F;
d363 1
a363 1
         const GLfloat f = span->array->attribs[FRAG_ATTRIB_FOGC][i][0];
d371 4
a374 4
      const GLfloat fogStep = span->attrStepX[FRAG_ATTRIB_FOGC][0];
      GLfloat fog = span->attrStart[FRAG_ATTRIB_FOGC][0];
      const GLfloat wStep = haveW ? span->attrStepX[FRAG_ATTRIB_WPOS][3] : 0.0F;
      GLfloat w = haveW ? span->attrStart[FRAG_ATTRIB_WPOS][3] : 1.0F;
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d26 4
a29 3
#include "main/glheader.h"
#include "main/colormac.h"
#include "main/macros.h"
d39 1
a39 1
_swrast_z_to_fogfactor(struct gl_context *ctx, GLfloat z)
a67 17
#define LINEAR_FOG(f, coord)  f = (fogEnd - coord) * fogScale

#define EXP_FOG(f, coord)  f = EXPF(density * coord)

#define EXP2_FOG(f, coord)				\
do {							\
   GLfloat tmp = negDensitySquared * coord * coord;	\
   if (tmp < FLT_MIN_10_EXP)				\
      tmp = FLT_MIN_10_EXP;				\
   f = EXPF(tmp);					\
 } while(0)


#define BLEND_FOG(f, coord)  f = coord



d73 21
a93 34
#define FOG_LOOP(TYPE, FOG_FUNC)						\
if (span->arrayAttribs & FRAG_BIT_FOGC) {					\
   GLuint i;									\
   for (i = 0; i < span->end; i++) {						\
      const GLfloat fogCoord = span->array->attribs[FRAG_ATTRIB_FOGC][i][0];	\
      const GLfloat c = FABSF(fogCoord);					\
      GLfloat f, oneMinusF;							\
      FOG_FUNC(f, c);								\
      f = CLAMP(f, 0.0F, 1.0F);							\
      oneMinusF = 1.0F - f;							\
      rgba[i][RCOMP] = (TYPE) (f * rgba[i][RCOMP] + oneMinusF * rFog);		\
      rgba[i][GCOMP] = (TYPE) (f * rgba[i][GCOMP] + oneMinusF * gFog);		\
      rgba[i][BCOMP] = (TYPE) (f * rgba[i][BCOMP] + oneMinusF * bFog);		\
   }										\
}										\
else {										\
   const GLfloat fogStep = span->attrStepX[FRAG_ATTRIB_FOGC][0];		\
   GLfloat fogCoord = span->attrStart[FRAG_ATTRIB_FOGC][0];			\
   const GLfloat wStep = span->attrStepX[FRAG_ATTRIB_WPOS][3];			\
   GLfloat w = span->attrStart[FRAG_ATTRIB_WPOS][3];				\
   GLuint i;									\
   for (i = 0; i < span->end; i++) {						\
      const GLfloat c = FABSF(fogCoord) / w;					\
      GLfloat f, oneMinusF;							\
      FOG_FUNC(f, c);								\
      f = CLAMP(f, 0.0F, 1.0F);							\
      oneMinusF = 1.0F - f;							\
      rgba[i][RCOMP] = (TYPE) (f * rgba[i][RCOMP] + oneMinusF * rFog);		\
      rgba[i][GCOMP] = (TYPE) (f * rgba[i][GCOMP] + oneMinusF * gFog);		\
      rgba[i][BCOMP] = (TYPE) (f * rgba[i][BCOMP] + oneMinusF * bFog);		\
      fogCoord += fogStep;							\
      w += wStep;								\
   }										\
}
d103 1
a103 1
_swrast_fog_rgba_span( const struct gl_context *ctx, SWspan *span )
d105 1
a105 1
   const SWcontext *swrast = CONST_SWRAST_CONTEXT(ctx);
d107 1
d110 1
a112 1
   /* compute (scaled) fog color */
d114 3
a116 3
      rFog = ctx->Fog.Color[RCOMP] * 255.0F;
      gFog = ctx->Fog.Color[GCOMP] * 255.0F;
      bFog = ctx->Fog.Color[BCOMP] * 255.0F;
d119 3
a121 3
      rFog = ctx->Fog.Color[RCOMP] * 65535.0F;
      gFog = ctx->Fog.Color[GCOMP] * 65535.0F;
      bFog = ctx->Fog.Color[BCOMP] * 65535.0F;
d129 6
d139 6
d147 145
d296 11
a306 12
            if (span->array->ChanType == GL_UNSIGNED_BYTE) {
               GLubyte (*rgba)[4] = span->array->rgba8;
               FOG_LOOP(GLubyte, LINEAR_FOG);
            }
            else if (span->array->ChanType == GL_UNSIGNED_SHORT) {
               GLushort (*rgba)[4] = span->array->rgba16;
               FOG_LOOP(GLushort, LINEAR_FOG);
            }
            else {
               GLfloat (*rgba)[4] = span->array->attribs[FRAG_ATTRIB_COL0];
               ASSERT(span->array->ChanType == GL_FLOAT);
               FOG_LOOP(GLfloat, LINEAR_FOG);
a309 1

d313 11
a323 12
            if (span->array->ChanType == GL_UNSIGNED_BYTE) {
               GLubyte (*rgba)[4] = span->array->rgba8;
               FOG_LOOP(GLubyte, EXP_FOG);
            }
            else if (span->array->ChanType == GL_UNSIGNED_SHORT) {
               GLushort (*rgba)[4] = span->array->rgba16;
               FOG_LOOP(GLushort, EXP_FOG);
            }
            else {
               GLfloat (*rgba)[4] = span->array->attribs[FRAG_ATTRIB_COL0];
               ASSERT(span->array->ChanType == GL_FLOAT);
               FOG_LOOP(GLfloat, EXP_FOG);
a326 1

d330 19
a348 12
            if (span->array->ChanType == GL_UNSIGNED_BYTE) {
               GLubyte (*rgba)[4] = span->array->rgba8;
               FOG_LOOP(GLubyte, EXP2_FOG);
            }
            else if (span->array->ChanType == GL_UNSIGNED_SHORT) {
               GLushort (*rgba)[4] = span->array->rgba16;
               FOG_LOOP(GLushort, EXP2_FOG);
            }
            else {
               GLfloat (*rgba)[4] = span->array->attribs[FRAG_ATTRIB_COL0];
               ASSERT(span->array->ChanType == GL_FLOAT);
               FOG_LOOP(GLfloat, EXP2_FOG);
a351 1

d353 1
a353 1
         _mesa_problem(ctx, "Bad fog mode in _swrast_fog_rgba_span");
d357 10
d368 1
a368 1
      /* The span's fog start/step/array values are blend factors in [0,1].
d371 11
a381 12
      if (span->array->ChanType == GL_UNSIGNED_BYTE) {
         GLubyte (*rgba)[4] = span->array->rgba8;
         FOG_LOOP(GLubyte, BLEND_FOG);
      }
      else if (span->array->ChanType == GL_UNSIGNED_SHORT) {
         GLushort (*rgba)[4] = span->array->rgba16;
         FOG_LOOP(GLushort, BLEND_FOG);
      }
      else {
         GLfloat (*rgba)[4] = span->array->attribs[FRAG_ATTRIB_COL0];
         ASSERT(span->array->ChanType == GL_FLOAT);
         FOG_LOOP(GLfloat, BLEND_FOG);
@


1.1.1.5
log
@Import Mesa 9.2.0
@
text
@d3 1
d20 3
a22 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
d90 1
a90 1
if (span->arrayAttribs & VARYING_BIT_FOGC) {					\
d93 1
a93 1
      const GLfloat fogCoord = span->array->attribs[VARYING_SLOT_FOGC][i][0];	\
d105 4
a108 4
   const GLfloat fogStep = span->attrStepX[VARYING_SLOT_FOGC][0];		\
   GLfloat fogCoord = span->attrStart[VARYING_SLOT_FOGC][0];			\
   const GLfloat wStep = span->attrStepX[VARYING_SLOT_POS][3];			\
   GLfloat w = span->attrStart[VARYING_SLOT_POS][3];				\
d161 1
a161 1
      switch (ctx->Fog.Mode) {
d176 1
a176 1
               GLfloat (*rgba)[4] = span->array->attribs[VARYING_SLOT_COL0];
d195 1
a195 1
               GLfloat (*rgba)[4] = span->array->attribs[VARYING_SLOT_COL0];
d214 1
a214 1
               GLfloat (*rgba)[4] = span->array->attribs[VARYING_SLOT_COL0];
d239 1
a239 1
         GLfloat (*rgba)[4] = span->array->attribs[VARYING_SLOT_COL0];
@


