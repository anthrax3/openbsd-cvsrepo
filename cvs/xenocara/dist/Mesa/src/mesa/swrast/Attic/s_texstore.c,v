head	1.4;
access;
symbols
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.6
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.4
	v7_0_1:1.1.1.2
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2010.05.22.20.06.34;	author matthieu;	state dead;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.42;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.23;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.51.26;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.51.26;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.56.51;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@/*
 * Mesa 3-D graphics library
 * Version:  6.5.2
 *
 * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * Authors:
 *   Brian Paul
 */


/*
 * The functions in this file are mostly related to software texture fallbacks.
 * This includes texture image transfer/packing and texel fetching.
 * Hardware drivers will likely override most of this.
 */



#include "main/glheader.h"
#include "main/imports.h"
#include "main/colormac.h"
#include "main/context.h"
#include "main/convolve.h"
#include "main/image.h"
#include "main/macros.h"
#include "main/mipmap.h"
#include "main/texformat.h"
#include "main/teximage.h"
#include "main/texstore.h"

#include "s_context.h"
#include "s_depth.h"
#include "s_span.h"


/**
 * Read an RGBA image from the frame buffer.
 * This is used by glCopyTex[Sub]Image[12]D().
 * \param x  window source x
 * \param y  window source y
 * \param width  image width
 * \param height  image height
 * \param type  datatype for returned GL_RGBA image
 * \return pointer to image
 */
static GLvoid *
read_color_image( GLcontext *ctx, GLint x, GLint y, GLenum type,
                  GLsizei width, GLsizei height )
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
   struct gl_renderbuffer *rb = ctx->ReadBuffer->_ColorReadBuffer;
   const GLint pixelSize = _mesa_bytes_per_pixel(GL_RGBA, type);
   const GLint stride = width * pixelSize;
   GLint row;
   GLubyte *image, *dst;

   image = (GLubyte *) _mesa_malloc(width * height * pixelSize);
   if (!image)
      return NULL;

   RENDER_START(swrast, ctx);

   dst = image;
   for (row = 0; row < height; row++) {
      _swrast_read_rgba_span(ctx, rb, width, x, y + row, type, dst);
      dst += stride;
   }

   RENDER_FINISH(swrast, ctx);

   return image;
}


/**
 * As above, but read data from depth buffer.  Returned as GLuints.
 * \sa read_color_image
 */
static GLuint *
read_depth_image( GLcontext *ctx, GLint x, GLint y,
                  GLsizei width, GLsizei height )
{
   struct gl_renderbuffer *rb = ctx->ReadBuffer->_DepthBuffer;
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
   GLuint *image, *dst;
   GLint i;

   image = (GLuint *) _mesa_malloc(width * height * sizeof(GLuint));
   if (!image)
      return NULL;

   RENDER_START(swrast, ctx);

   dst = image;
   for (i = 0; i < height; i++) {
      _swrast_read_depth_span_uint(ctx, rb, width, x, y + i, dst);
      dst += width;
   }

   RENDER_FINISH(swrast, ctx);

   return image;
}


/**
 * As above, but read data from depth+stencil buffers.
 */
static GLuint *
read_depth_stencil_image(GLcontext *ctx, GLint x, GLint y,
                         GLsizei width, GLsizei height)
{
   struct gl_renderbuffer *depthRb = ctx->ReadBuffer->_DepthBuffer;
   struct gl_renderbuffer *stencilRb = ctx->ReadBuffer->_StencilBuffer;
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
   GLuint *image, *dst;
   GLint i;

   ASSERT(depthRb);
   ASSERT(stencilRb);

   image = (GLuint *) _mesa_malloc(width * height * sizeof(GLuint));
   if (!image)
      return NULL;

   RENDER_START(swrast, ctx);

   /* read from depth buffer */
   dst = image;
   if (depthRb->DataType == GL_UNSIGNED_INT) {
      for (i = 0; i < height; i++) {
         _swrast_get_row(ctx, depthRb, width, x, y + i, dst, sizeof(GLuint));
         dst += width;
      }
   }
   else {
      GLushort z16[MAX_WIDTH];
      ASSERT(depthRb->DataType == GL_UNSIGNED_SHORT);
      for (i = 0; i < height; i++) {
         GLint j;
         _swrast_get_row(ctx, depthRb, width, x, y + i, z16, sizeof(GLushort));
         /* convert GLushorts to GLuints */
         for (j = 0; j < width; j++) {
            dst[j] = z16[j];
         }
         dst += width;
      }
   }

   /* put depth values into bits 0xffffff00 */
   if (ctx->ReadBuffer->Visual.depthBits == 24) {
      GLint j;
      for (j = 0; j < width * height; j++) {
         image[j] <<= 8;
      }
   }
   else if (ctx->ReadBuffer->Visual.depthBits == 16) {
      GLint j;
      for (j = 0; j < width * height; j++) {
         image[j] = (image[j] << 16) | (image[j] & 0xff00);
      }      
   }
   else {
      /* this handles arbitrary depthBits >= 12 */
      const GLint rShift = ctx->ReadBuffer->Visual.depthBits;
      const GLint lShift = 32 - rShift;
      GLint j;
      for (j = 0; j < width * height; j++) {
         GLuint z = (image[j] << lShift);
         image[j] = z | (z >> rShift);
      }
   }

   /* read stencil values and interleave into image array */
   dst = image;
   for (i = 0; i < height; i++) {
      GLstencil stencil[MAX_WIDTH];
      GLint j;
      ASSERT(8 * sizeof(GLstencil) == stencilRb->StencilBits);
      _swrast_get_row(ctx, stencilRb, width, x, y + i,
                      stencil, sizeof(GLstencil));
      for (j = 0; j < width; j++) {
         dst[j] = (dst[j] & 0xffffff00) | (stencil[j] & 0xff);
      }
      dst += width;
   }

   RENDER_FINISH(swrast, ctx);

   return image;
}


static GLboolean
is_depth_format(GLenum format)
{
   switch (format) {
      case GL_DEPTH_COMPONENT:
      case GL_DEPTH_COMPONENT16:
      case GL_DEPTH_COMPONENT24:
      case GL_DEPTH_COMPONENT32:
         return GL_TRUE;
      default:
         return GL_FALSE;
   }
}


static GLboolean
is_depth_stencil_format(GLenum format)
{
   switch (format) {
      case GL_DEPTH_STENCIL_EXT:
      case GL_DEPTH24_STENCIL8_EXT:
         return GL_TRUE;
      default:
         return GL_FALSE;
   }
}


/*
 * Fallback for Driver.CopyTexImage1D().
 */
void
_swrast_copy_teximage1d( GLcontext *ctx, GLenum target, GLint level,
                         GLenum internalFormat,
                         GLint x, GLint y, GLsizei width, GLint border )
{
   struct gl_texture_unit *texUnit;
   struct gl_texture_object *texObj;
   struct gl_texture_image *texImage;

   texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
   texObj = _mesa_select_tex_object(ctx, texUnit, target);
   ASSERT(texObj);
   texImage = _mesa_select_tex_image(ctx, texObj, target, level);
   ASSERT(texImage);

   ASSERT(ctx->Driver.TexImage1D);

   if (is_depth_format(internalFormat)) {
      /* read depth image from framebuffer */
      GLuint *image = read_depth_image(ctx, x, y, width, 1);
      if (!image) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCopyTexImage1D");
         return;
      }
      /* call glTexImage1D to redefine the texture */
      ctx->Driver.TexImage1D(ctx, target, level, internalFormat,
                             width, border,
                             GL_DEPTH_COMPONENT, GL_UNSIGNED_INT, image,
                             &ctx->DefaultPacking, texObj, texImage);
      _mesa_free(image);
   }
   else if (is_depth_stencil_format(internalFormat)) {
      /* read depth/stencil image from framebuffer */
      GLuint *image = read_depth_stencil_image(ctx, x, y, width, 1);
      if (!image) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCopyTexImage1D");
         return;
      }
      /* call glTexImage1D to redefine the texture */
      ctx->Driver.TexImage1D(ctx, target, level, internalFormat,
                             width, border,
                             GL_DEPTH_STENCIL_EXT, GL_UNSIGNED_INT_24_8_EXT,
                             image, &ctx->DefaultPacking, texObj, texImage);
      _mesa_free(image);
   }
   else {
      /* read RGBA image from framebuffer */
      const GLenum format = GL_RGBA;
      const GLenum type = ctx->ReadBuffer->_ColorReadBuffer->DataType;
      GLvoid *image = read_color_image(ctx, x, y, type, width, 1);
      if (!image) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCopyTexImage1D");
         return;
      }
      /* call glTexImage1D to redefine the texture */
      ctx->Driver.TexImage1D(ctx, target, level, internalFormat,
                             width, border, format, type, image,
                             &ctx->DefaultPacking, texObj, texImage);
      _mesa_free(image);
   }

   /* GL_SGIS_generate_mipmap */
   if (level == texObj->BaseLevel && texObj->GenerateMipmap) {
      ctx->Driver.GenerateMipmap(ctx, target, texObj);
   }
}


/**
 * Fallback for Driver.CopyTexImage2D().
 *
 * We implement CopyTexImage by reading the image from the framebuffer
 * then passing it to the ctx->Driver.TexImage2D() function.
 *
 * Device drivers should try to implement direct framebuffer->texture copies.
 */
void
_swrast_copy_teximage2d( GLcontext *ctx, GLenum target, GLint level,
                         GLenum internalFormat,
                         GLint x, GLint y, GLsizei width, GLsizei height,
                         GLint border )
{
   struct gl_texture_unit *texUnit;
   struct gl_texture_object *texObj;
   struct gl_texture_image *texImage;

   texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
   texObj = _mesa_select_tex_object(ctx, texUnit, target);
   ASSERT(texObj);
   texImage = _mesa_select_tex_image(ctx, texObj, target, level);
   ASSERT(texImage);

   ASSERT(ctx->Driver.TexImage2D);

   if (is_depth_format(internalFormat)) {
      /* read depth image from framebuffer */
      GLuint *image = read_depth_image(ctx, x, y, width, height);
      if (!image) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCopyTexImage2D");
         return;
      }
      /* call glTexImage2D to redefine the texture */
      ctx->Driver.TexImage2D(ctx, target, level, internalFormat,
                             width, height, border,
                             GL_DEPTH_COMPONENT, GL_UNSIGNED_INT, image,
                             &ctx->DefaultPacking, texObj, texImage);
      _mesa_free(image);
   }
   else if (is_depth_stencil_format(internalFormat)) {
      GLuint *image = read_depth_stencil_image(ctx, x, y, width, height);
      if (!image) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCopyTexImage2D");
         return;
      }
      /* call glTexImage2D to redefine the texture */
      ctx->Driver.TexImage2D(ctx, target, level, internalFormat,
                             width, height, border,
                             GL_DEPTH_STENCIL_EXT, GL_UNSIGNED_INT_24_8_EXT,
                             image, &ctx->DefaultPacking, texObj, texImage);
      _mesa_free(image);
   }
   else {
      /* read RGBA image from framebuffer */
      const GLenum format = GL_RGBA;
      const GLenum type = ctx->ReadBuffer->_ColorReadBuffer->DataType;
      GLvoid *image = read_color_image(ctx, x, y, type, width, height);
      if (!image) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCopyTexImage2D");
         return;
      }
      /* call glTexImage2D to redefine the texture */
      ctx->Driver.TexImage2D(ctx, target, level, internalFormat,
                             width, height, border, format, type, image,
                             &ctx->DefaultPacking, texObj, texImage);
      _mesa_free(image);
   }

   /* GL_SGIS_generate_mipmap */
   if (level == texObj->BaseLevel && texObj->GenerateMipmap) {
      ctx->Driver.GenerateMipmap(ctx, target, texObj);
   }
}


/*
 * Fallback for Driver.CopyTexSubImage1D().
 */
void
_swrast_copy_texsubimage1d( GLcontext *ctx, GLenum target, GLint level,
                            GLint xoffset, GLint x, GLint y, GLsizei width )
{
   struct gl_texture_unit *texUnit;
   struct gl_texture_object *texObj;
   struct gl_texture_image *texImage;

   texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
   texObj = _mesa_select_tex_object(ctx, texUnit, target);
   ASSERT(texObj);
   texImage = _mesa_select_tex_image(ctx, texObj, target, level);
   ASSERT(texImage);

   ASSERT(ctx->Driver.TexImage1D);

   if (texImage->_BaseFormat == GL_DEPTH_COMPONENT) {
      /* read depth image from framebuffer */
      GLuint *image = read_depth_image(ctx, x, y, width, 1);
      if (!image) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCopyTexSubImage1D");
         return;
      }

      /* call glTexSubImage1D to redefine the texture */
      ctx->Driver.TexSubImage1D(ctx, target, level, xoffset, width,
                                GL_DEPTH_COMPONENT, GL_UNSIGNED_INT, image,
                                &ctx->DefaultPacking, texObj, texImage);
      _mesa_free(image);
   }
   else if (texImage->_BaseFormat == GL_DEPTH_STENCIL_EXT) {
      /* read depth/stencil image from framebuffer */
      GLuint *image = read_depth_stencil_image(ctx, x, y, width, 1);
      if (!image) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCopyTexSubImage1D");
         return;
      }
      /* call glTexImage1D to redefine the texture */
      ctx->Driver.TexSubImage1D(ctx, target, level, xoffset, width,
                                GL_DEPTH_STENCIL_EXT, GL_UNSIGNED_INT_24_8_EXT,
                                image, &ctx->DefaultPacking, texObj, texImage);
      _mesa_free(image);
   }
   else {
      /* read RGBA image from framebuffer */
      const GLenum format = GL_RGBA;
      const GLenum type = ctx->ReadBuffer->_ColorReadBuffer->DataType;
      GLvoid *image = read_color_image(ctx, x, y, type, width, 1);
      if (!image) {
         _mesa_error( ctx, GL_OUT_OF_MEMORY, "glCopyTexSubImage1D" );
         return;
      }
      /* now call glTexSubImage1D to do the real work */
      ctx->Driver.TexSubImage1D(ctx, target, level, xoffset, width,
                                format, type, image,
                                &ctx->DefaultPacking, texObj, texImage);
      _mesa_free(image);
   }

   /* GL_SGIS_generate_mipmap */
   if (level == texObj->BaseLevel && texObj->GenerateMipmap) {
      ctx->Driver.GenerateMipmap(ctx, target, texObj);
   }
}


/**
 * Fallback for Driver.CopyTexSubImage2D().
 *
 * Read the image from the framebuffer then hand it
 * off to ctx->Driver.TexSubImage2D().
 */
void
_swrast_copy_texsubimage2d( GLcontext *ctx,
                            GLenum target, GLint level,
                            GLint xoffset, GLint yoffset,
                            GLint x, GLint y, GLsizei width, GLsizei height )
{
   struct gl_texture_unit *texUnit;
   struct gl_texture_object *texObj;
   struct gl_texture_image *texImage;

   texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
   texObj = _mesa_select_tex_object(ctx, texUnit, target);
   ASSERT(texObj);
   texImage = _mesa_select_tex_image(ctx, texObj, target, level);
   ASSERT(texImage);

   ASSERT(ctx->Driver.TexImage2D);

   if (texImage->_BaseFormat == GL_DEPTH_COMPONENT) {
      /* read depth image from framebuffer */
      GLuint *image = read_depth_image(ctx, x, y, width, height);
      if (!image) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCopyTexSubImage2D");
         return;
      }
      /* call glTexImage2D to redefine the texture */
      ctx->Driver.TexSubImage2D(ctx, target, level,
                                xoffset, yoffset, width, height,
                                GL_DEPTH_COMPONENT, GL_UNSIGNED_INT, image,
                                &ctx->DefaultPacking, texObj, texImage);
      _mesa_free(image);
   }
   else if (texImage->_BaseFormat == GL_DEPTH_STENCIL_EXT) {
      /* read depth/stencil image from framebuffer */
      GLuint *image = read_depth_stencil_image(ctx, x, y, width, height);
      if (!image) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCopyTexSubImage2D");
         return;
      }
      /* call glTexImage2D to redefine the texture */
      ctx->Driver.TexSubImage2D(ctx, target, level,
                                xoffset, yoffset, width, height,
                                GL_DEPTH_STENCIL_EXT, GL_UNSIGNED_INT_24_8_EXT,
                                image, &ctx->DefaultPacking, texObj, texImage);
      _mesa_free(image);
   }
   else {
      /* read RGBA image from framebuffer */
      const GLenum format = GL_RGBA;
      const GLenum type = ctx->ReadBuffer->_ColorReadBuffer->DataType;
      GLvoid *image = read_color_image(ctx, x, y, type, width, height);
      if (!image) {
         _mesa_error( ctx, GL_OUT_OF_MEMORY, "glCopyTexSubImage2D" );
         return;
      }
      /* now call glTexSubImage2D to do the real work */
      ctx->Driver.TexSubImage2D(ctx, target, level,
                                xoffset, yoffset, width, height,
                                format, type, image,
                                &ctx->DefaultPacking, texObj, texImage);
      _mesa_free(image);
   }

   /* GL_SGIS_generate_mipmap */
   if (level == texObj->BaseLevel && texObj->GenerateMipmap) {
      ctx->Driver.GenerateMipmap(ctx, target, texObj);
   }
}


/*
 * Fallback for Driver.CopyTexSubImage3D().
 */
void
_swrast_copy_texsubimage3d( GLcontext *ctx,
                            GLenum target, GLint level,
                            GLint xoffset, GLint yoffset, GLint zoffset,
                            GLint x, GLint y, GLsizei width, GLsizei height )
{
   struct gl_texture_unit *texUnit;
   struct gl_texture_object *texObj;
   struct gl_texture_image *texImage;

   texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
   texObj = _mesa_select_tex_object(ctx, texUnit, target);
   ASSERT(texObj);
   texImage = _mesa_select_tex_image(ctx, texObj, target, level);
   ASSERT(texImage);

   ASSERT(ctx->Driver.TexImage3D);

   if (texImage->_BaseFormat == GL_DEPTH_COMPONENT) {
      /* read depth image from framebuffer */
      GLuint *image = read_depth_image(ctx, x, y, width, height);
      if (!image) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCopyTexSubImage3D");
         return;
      }
      /* call glTexImage3D to redefine the texture */
      ctx->Driver.TexSubImage3D(ctx, target, level,
                                xoffset, yoffset, zoffset, width, height, 1,
                                GL_DEPTH_COMPONENT, GL_UNSIGNED_INT, image,
                                &ctx->DefaultPacking, texObj, texImage);
      _mesa_free(image);
   }
   else if (texImage->_BaseFormat == GL_DEPTH_STENCIL_EXT) {
      /* read depth/stencil image from framebuffer */
      GLuint *image = read_depth_stencil_image(ctx, x, y, width, height);
      if (!image) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCopyTexSubImage3D");
         return;
      }
      /* call glTexImage3D to redefine the texture */
      ctx->Driver.TexSubImage3D(ctx, target, level,
                                xoffset, yoffset, zoffset, width, height, 1,
                                GL_DEPTH_STENCIL_EXT, GL_UNSIGNED_INT_24_8_EXT,
                                image, &ctx->DefaultPacking, texObj, texImage);
      _mesa_free(image);
   }
   else {
      /* read RGBA image from framebuffer */
      const GLenum format = GL_RGBA;
      const GLenum type = ctx->ReadBuffer->_ColorReadBuffer->DataType;
      GLvoid *image = read_color_image(ctx, x, y, type, width, height);
      if (!image) {
         _mesa_error( ctx, GL_OUT_OF_MEMORY, "glCopyTexSubImage3D" );
         return;
      }
      /* now call glTexSubImage3D to do the real work */
      ctx->Driver.TexSubImage3D(ctx, target, level,
                                xoffset, yoffset, zoffset, width, height, 1,
                                format, type, image,
                                &ctx->DefaultPacking, texObj, texImage);
      _mesa_free(image);
   }

   /* GL_SGIS_generate_mipmap */
   if (level == texObj->BaseLevel && texObj->GenerateMipmap) {
      ctx->Driver.GenerateMipmap(ctx, target, texObj);
   }
}
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d39 11
a49 11
#include "glheader.h"
#include "imports.h"
#include "colormac.h"
#include "context.h"
#include "convolve.h"
#include "image.h"
#include "macros.h"
#include "mipmap.h"
#include "texformat.h"
#include "teximage.h"
#include "texstore.h"
d219 3
a221 3
      case GL_DEPTH_COMPONENT16_SGIX:
      case GL_DEPTH_COMPONENT24_SGIX:
      case GL_DEPTH_COMPONENT32_SGIX:
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * Version:  6.5.1
d46 1
d55 2
a56 1
/*
d59 6
a64 4
 * Input:  ctx - the context
 *         x, y - lower left corner
 *         width, height - size of region to read
 * Return: pointer to block of GL_RGBA, GLchan data.
d66 2
a67 2
static GLchan *
read_color_image( GLcontext *ctx, GLint x, GLint y,
d71 5
a75 3
   const GLint stride = 4 * width;
   GLint i;
   GLchan *image, *dst;
d77 1
a77 1
   image = (GLchan *) _mesa_malloc(width * height * 4 * sizeof(GLchan));
d84 2
a85 3
   for (i = 0; i < height; i++) {
      _swrast_read_rgba_span(ctx, ctx->ReadBuffer->_ColorReadBuffer,
                             width, x, y + i, (GLchan (*)[4]) dst);
d257 1
a257 1
   texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
d292 3
a294 1
      GLchan *image = read_color_image(ctx, x, y, width, 1);
d301 1
a301 2
                             width, border,
                             GL_RGBA, CHAN_TYPE, image,
d308 1
a308 1
      _mesa_generate_mipmap(ctx, target, texUnit, texObj);
d334 1
a334 1
   texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
d368 3
a370 1
      GLchan *image = read_color_image(ctx, x, y, width, height);
d377 1
a377 2
                             width, height, border,
                             GL_RGBA, CHAN_TYPE, image,
d384 1
a384 1
      _mesa_generate_mipmap(ctx, target, texUnit, texObj);
d403 1
a403 1
   texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
d437 3
a439 1
      GLchan *image = read_color_image(ctx, x, y, width, 1);
d446 1
a446 1
                                GL_RGBA, CHAN_TYPE, image,
d453 1
a453 1
      _mesa_generate_mipmap(ctx, target, texUnit, texObj);
d477 1
a477 1
   texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
d512 3
a514 1
      GLchan *image = read_color_image(ctx, x, y, width, height);
d522 1
a522 1
                                GL_RGBA, CHAN_TYPE, image,
d529 1
a529 1
      _mesa_generate_mipmap(ctx, target, texUnit, texObj);
d550 1
a550 1
   texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
d585 3
a587 1
      GLchan *image = read_color_image(ctx, x, y, width, height);
d595 1
a595 1
                                GL_RGBA, CHAN_TYPE, image,
d602 1
a602 1
      _mesa_generate_mipmap(ctx, target, texUnit, texObj);
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d3 1
a3 1
 * Version:  6.5.2
a45 1
#include "mipmap.h"
d54 1
a54 2

/**
d57 4
a60 6
 * \param x  window source x
 * \param y  window source y
 * \param width  image width
 * \param height  image height
 * \param type  datatype for returned GL_RGBA image
 * \return pointer to image
d62 2
a63 2
static GLvoid *
read_color_image( GLcontext *ctx, GLint x, GLint y, GLenum type,
d67 3
a69 5
   struct gl_renderbuffer *rb = ctx->ReadBuffer->_ColorReadBuffer;
   const GLint pixelSize = _mesa_bytes_per_pixel(GL_RGBA, type);
   const GLint stride = width * pixelSize;
   GLint row;
   GLubyte *image, *dst;
d71 1
a71 1
   image = (GLubyte *) _mesa_malloc(width * height * pixelSize);
d78 3
a80 2
   for (row = 0; row < height; row++) {
      _swrast_read_rgba_span(ctx, rb, width, x, y + row, type, dst);
d252 1
a252 1
   texImage = _mesa_select_tex_image(ctx, texObj, target, level);
d287 1
a287 3
      const GLenum format = GL_RGBA;
      const GLenum type = ctx->ReadBuffer->_ColorReadBuffer->DataType;
      GLvoid *image = read_color_image(ctx, x, y, type, width, 1);
d294 2
a295 1
                             width, border, format, type, image,
d328 1
a328 1
   texImage = _mesa_select_tex_image(ctx, texObj, target, level);
d362 1
a362 3
      const GLenum format = GL_RGBA;
      const GLenum type = ctx->ReadBuffer->_ColorReadBuffer->DataType;
      GLvoid *image = read_color_image(ctx, x, y, type, width, height);
d369 2
a370 1
                             width, height, border, format, type, image,
d396 1
a396 1
   texImage = _mesa_select_tex_image(ctx, texObj, target, level);
d430 1
a430 3
      const GLenum format = GL_RGBA;
      const GLenum type = ctx->ReadBuffer->_ColorReadBuffer->DataType;
      GLvoid *image = read_color_image(ctx, x, y, type, width, 1);
d437 1
a437 1
                                format, type, image,
d468 1
a468 1
   texImage = _mesa_select_tex_image(ctx, texObj, target, level);
d503 1
a503 3
      const GLenum format = GL_RGBA;
      const GLenum type = ctx->ReadBuffer->_ColorReadBuffer->DataType;
      GLvoid *image = read_color_image(ctx, x, y, type, width, height);
d511 1
a511 1
                                format, type, image,
d539 1
a539 1
   texImage = _mesa_select_tex_image(ctx, texObj, target, level);
d574 1
a574 3
      const GLenum format = GL_RGBA;
      const GLenum type = ctx->ReadBuffer->_ColorReadBuffer->DataType;
      GLvoid *image = read_color_image(ctx, x, y, type, width, height);
d582 1
a582 1
                                format, type, image,
@

