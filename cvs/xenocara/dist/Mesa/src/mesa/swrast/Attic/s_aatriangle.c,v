head	1.10;
access;
symbols
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	v10_2_9:1.1.1.6
	v10_4_3:1.1.1.5
	v10_2_7:1.1.1.4
	OPENBSD_5_6:1.7.0.4
	OPENBSD_5_6_BASE:1.7
	v10_2_3:1.1.1.4
	OPENBSD_5_5:1.7.0.2
	OPENBSD_5_5_BASE:1.7
	v9_2_5:1.1.1.4
	v9_2_3:1.1.1.4
	v9_2_2:1.1.1.4
	v9_2_1:1.1.1.4
	v9_2_0:1.1.1.4
	OPENBSD_5_4:1.6.0.4
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	v7_10_3:1.1.1.3
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v7_0_1:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v6_5_2:1.1.1.1
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2015.12.23.05.17.54;	author jsg;	state dead;
branches;
next	1.9;
commitid	TnlogFl9nOv2eaRf;

1.9
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.8;
commitid	4ry2gvZGMXkCUD2n;

1.8
date	2015.01.25.14.41.22;	author jsg;	state Exp;
branches;
next	1.7;
commitid	mcxB0JvoI9gTDYXU;

1.7
date	2013.09.05.14.06.47;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2012.08.17.13.58.20;	author mpi;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.23.13.37.45;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.34;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.42;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.22;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.51.15;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.51.15;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.32.04;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.10.23.13.29.48;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.09.05.13.17.28;	author jsg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2015.01.25.14.13.25;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.6
date	2015.02.20.22.50.31;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.10
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */


/*
 * Antialiased Triangle rasterizers
 */


#include "main/glheader.h"
#include "main/context.h"
#include "main/colormac.h"
#include "main/macros.h"
#include "main/imports.h"
#include "main/state.h"
#include "s_aatriangle.h"
#include "s_context.h"
#include "s_span.h"


/*
 * Compute coefficients of a plane using the X,Y coords of the v0, v1, v2
 * vertices and the given Z values.
 * A point (x,y,z) lies on plane iff a*x+b*y+c*z+d = 0.
 */
static inline void
compute_plane(const GLfloat v0[], const GLfloat v1[], const GLfloat v2[],
              GLfloat z0, GLfloat z1, GLfloat z2, GLfloat plane[4])
{
   const GLfloat px = v1[0] - v0[0];
   const GLfloat py = v1[1] - v0[1];
   const GLfloat pz = z1 - z0;

   const GLfloat qx = v2[0] - v0[0];
   const GLfloat qy = v2[1] - v0[1];
   const GLfloat qz = z2 - z0;

   /* Crossproduct "(a,b,c):= dv1 x dv2" is orthogonal to plane. */
   const GLfloat a = py * qz - pz * qy;
   const GLfloat b = pz * qx - px * qz;
   const GLfloat c = px * qy - py * qx;
   /* Point on the plane = "r*(a,b,c) + w", with fixed "r" depending
      on the distance of plane from origin and arbitrary "w" parallel
      to the plane. */
   /* The scalar product "(r*(a,b,c)+w)*(a,b,c)" is "r*(a^2+b^2+c^2)",
      which is equal to "-d" below. */
   const GLfloat d = -(a * v0[0] + b * v0[1] + c * z0);

   plane[0] = a;
   plane[1] = b;
   plane[2] = c;
   plane[3] = d;
}


/*
 * Compute coefficients of a plane with a constant Z value.
 */
static inline void
constant_plane(GLfloat value, GLfloat plane[4])
{
   plane[0] = 0.0;
   plane[1] = 0.0;
   plane[2] = -1.0;
   plane[3] = value;
}

#define CONSTANT_PLANE(VALUE, PLANE)	\
do {					\
   PLANE[0] = 0.0F;			\
   PLANE[1] = 0.0F;			\
   PLANE[2] = -1.0F;			\
   PLANE[3] = VALUE;			\
} while (0)



/*
 * Solve plane equation for Z at (X,Y).
 */
static inline GLfloat
solve_plane(GLfloat x, GLfloat y, const GLfloat plane[4])
{
   ASSERT(plane[2] != 0.0F);
   return (plane[3] + plane[0] * x + plane[1] * y) / -plane[2];
}


#define SOLVE_PLANE(X, Y, PLANE) \
   ((PLANE[3] + PLANE[0] * (X) + PLANE[1] * (Y)) / -PLANE[2])


/*
 * Return 1 / solve_plane().
 */
static inline GLfloat
solve_plane_recip(GLfloat x, GLfloat y, const GLfloat plane[4])
{
   const GLfloat denom = plane[3] + plane[0] * x + plane[1] * y;
   if (denom == 0.0F)
      return 0.0F;
   else
      return -plane[2] / denom;
}


/*
 * Solve plane and return clamped GLchan value.
 */
static inline GLchan
solve_plane_chan(GLfloat x, GLfloat y, const GLfloat plane[4])
{
   const GLfloat z = (plane[3] + plane[0] * x + plane[1] * y) / -plane[2];
#if CHAN_TYPE == GL_FLOAT
   return CLAMP(z, 0.0F, CHAN_MAXF);
#else
   if (z < 0)
      return 0;
   else if (z > CHAN_MAX)
      return CHAN_MAX;
   return (GLchan) IROUND_POS(z);
#endif
}


static inline GLfloat
plane_dx(const GLfloat plane[4])
{
   return -plane[0] / plane[2];
}

static inline GLfloat
plane_dy(const GLfloat plane[4])
{
   return -plane[1] / plane[2];
}



/*
 * Compute how much (area) of the given pixel is inside the triangle.
 * Vertices MUST be specified in counter-clockwise order.
 * Return:  coverage in [0, 1].
 */
static GLfloat
compute_coveragef(const GLfloat v0[3], const GLfloat v1[3],
                  const GLfloat v2[3], GLint winx, GLint winy)
{
   /* Given a position [0,3]x[0,3] return the sub-pixel sample position.
    * Contributed by Ray Tice.
    *
    * Jitter sample positions -
    * - average should be .5 in x & y for each column
    * - each of the 16 rows and columns should be used once
    * - the rectangle formed by the first four points
    *   should contain the other points
    * - the distrubition should be fairly even in any given direction
    *
    * The pattern drawn below isn't optimal, but it's better than a regular
    * grid.  In the drawing, the center of each subpixel is surrounded by
    * four dots.  The "x" marks the jittered position relative to the
    * subpixel center.
    */
#define POS(a, b) (0.5+a*4+b)/16
   static const GLfloat samples[16][2] = {
      /* start with the four corners */
      { POS(0, 2), POS(0, 0) },
      { POS(3, 3), POS(0, 2) },
      { POS(0, 0), POS(3, 1) },
      { POS(3, 1), POS(3, 3) },
      /* continue with interior samples */
      { POS(1, 1), POS(0, 1) },
      { POS(2, 0), POS(0, 3) },
      { POS(0, 3), POS(1, 3) },
      { POS(1, 2), POS(1, 0) },
      { POS(2, 3), POS(1, 2) },
      { POS(3, 2), POS(1, 1) },
      { POS(0, 1), POS(2, 2) },
      { POS(1, 0), POS(2, 1) },
      { POS(2, 1), POS(2, 3) },
      { POS(3, 0), POS(2, 0) },
      { POS(1, 3), POS(3, 0) },
      { POS(2, 2), POS(3, 2) }
   };

   const GLfloat x = (GLfloat) winx;
   const GLfloat y = (GLfloat) winy;
   const GLfloat dx0 = v1[0] - v0[0];
   const GLfloat dy0 = v1[1] - v0[1];
   const GLfloat dx1 = v2[0] - v1[0];
   const GLfloat dy1 = v2[1] - v1[1];
   const GLfloat dx2 = v0[0] - v2[0];
   const GLfloat dy2 = v0[1] - v2[1];
   GLint stop = 4, i;
   GLfloat insideCount = 16.0F;

   ASSERT(dx0 * dy1 - dx1 * dy0 >= 0.0); /* area >= 0.0 */

   for (i = 0; i < stop; i++) {
      const GLfloat sx = x + samples[i][0];
      const GLfloat sy = y + samples[i][1];
      /* cross product determines if sample is inside or outside each edge */
      GLfloat cross = (dx0 * (sy - v0[1]) - dy0 * (sx - v0[0]));
      /* Check if the sample is exactly on an edge.  If so, let cross be a
       * positive or negative value depending on the direction of the edge.
       */
      if (cross == 0.0F)
         cross = dx0 + dy0;
      if (cross < 0.0F) {
         /* sample point is outside first edge */
         insideCount -= 1.0F;
         stop = 16;
      }
      else {
         /* sample point is inside first edge */
         cross = (dx1 * (sy - v1[1]) - dy1 * (sx - v1[0]));
         if (cross == 0.0F)
            cross = dx1 + dy1;
         if (cross < 0.0F) {
            /* sample point is outside second edge */
            insideCount -= 1.0F;
            stop = 16;
         }
         else {
            /* sample point is inside first and second edges */
            cross = (dx2 * (sy - v2[1]) -  dy2 * (sx - v2[0]));
            if (cross == 0.0F)
               cross = dx2 + dy2;
            if (cross < 0.0F) {
               /* sample point is outside third edge */
               insideCount -= 1.0F;
               stop = 16;
            }
         }
      }
   }
   if (stop == 4)
      return 1.0F;
   else
      return insideCount * (1.0F / 16.0F);
}



static void
rgba_aa_tri(struct gl_context *ctx,
	    const SWvertex *v0,
	    const SWvertex *v1,
	    const SWvertex *v2)
{
#define DO_Z
#include "s_aatritemp.h"
}


static void
general_aa_tri(struct gl_context *ctx,
               const SWvertex *v0,
               const SWvertex *v1,
               const SWvertex *v2)
{
#define DO_Z
#define DO_ATTRIBS
#include "s_aatritemp.h"
}



/*
 * Examine GL state and set swrast->Triangle to an
 * appropriate antialiased triangle rasterizer function.
 */
void
_swrast_set_aa_triangle_function(struct gl_context *ctx)
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);

   ASSERT(ctx->Polygon.SmoothFlag);

   if (ctx->Texture._EnabledCoordUnits != 0
       || _swrast_use_fragment_program(ctx)
       || swrast->_FogEnabled
       || _mesa_need_secondary_color(ctx)) {
      SWRAST_CONTEXT(ctx)->Triangle = general_aa_tri;
   }
   else {
      SWRAST_CONTEXT(ctx)->Triangle = rgba_aa_tri;
   }

   ASSERT(SWRAST_CONTEXT(ctx)->Triangle);
}
@


1.9
log
@Merge Mesa 10.2.9
@
text
@@


1.8
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d115 14
@


1.7
log
@Merge Mesa 9.2.0
@
text
@a114 14
 * Return 1 / solve_plane().
 */
static inline GLfloat
solve_plane_recip(GLfloat x, GLfloat y, const GLfloat plane[4])
{
   const GLfloat denom = plane[3] + plane[0] * x + plane[1] * y;
   if (denom == 0.0F)
      return 0.0F;
   else
      return -plane[2] / denom;
}


/*
@


1.6
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a2 1
 * Version:  6.5.3
d19 4
a22 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
d47 1
a47 1
static INLINE void
d80 1
a80 1
static INLINE void
d102 1
a102 1
static INLINE GLfloat
d117 1
a117 1
static INLINE GLfloat
d131 1
a131 1
static INLINE GLchan
d147 1
a147 1
static INLINE GLfloat
d153 1
a153 1
static INLINE GLfloat
d302 1
a302 1
       || ctx->FragmentProgram._Current
@


1.5
log
@Merge Mesa 7.10.3
@
text
@d36 1
d218 1
a218 6
#ifdef DEBUG
   {
      const GLfloat area = dx0 * dy1 - dx1 * dy0;
      ASSERT(area >= 0.0);
   }
#endif
d304 1
a304 1
       || NEED_SECONDARY_COLOR(ctx)) {
@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@a33 1
#include "main/context.h"
d271 1
a271 1
rgba_aa_tri(GLcontext *ctx,
d282 1
a282 1
general_aa_tri(GLcontext *ctx,
d299 1
a299 1
_swrast_set_aa_triangle_function(GLcontext *ctx)
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@a270 82
/*
 * Compute how much (area) of the given pixel is inside the triangle.
 * Vertices MUST be specified in counter-clockwise order.
 * Return:  coverage in [0, 15].
 */
static GLint
compute_coveragei(const GLfloat v0[3], const GLfloat v1[3],
                  const GLfloat v2[3], GLint winx, GLint winy)
{
   /* NOTE: 15 samples instead of 16. */
   static const GLfloat samples[15][2] = {
      /* start with the four corners */
      { POS(0, 2), POS(0, 0) },
      { POS(3, 3), POS(0, 2) },
      { POS(0, 0), POS(3, 1) },
      { POS(3, 1), POS(3, 3) },
      /* continue with interior samples */
      { POS(1, 1), POS(0, 1) },
      { POS(2, 0), POS(0, 3) },
      { POS(0, 3), POS(1, 3) },
      { POS(1, 2), POS(1, 0) },
      { POS(2, 3), POS(1, 2) },
      { POS(3, 2), POS(1, 1) },
      { POS(0, 1), POS(2, 2) },
      { POS(1, 0), POS(2, 1) },
      { POS(2, 1), POS(2, 3) },
      { POS(3, 0), POS(2, 0) },
      { POS(1, 3), POS(3, 0) }
   };
   const GLfloat x = (GLfloat) winx;
   const GLfloat y = (GLfloat) winy;
   const GLfloat dx0 = v1[0] - v0[0];
   const GLfloat dy0 = v1[1] - v0[1];
   const GLfloat dx1 = v2[0] - v1[0];
   const GLfloat dy1 = v2[1] - v1[1];
   const GLfloat dx2 = v0[0] - v2[0];
   const GLfloat dy2 = v0[1] - v2[1];
   GLint stop = 4, i;
   GLint insideCount = 15;

#ifdef DEBUG
   {
      const GLfloat area = dx0 * dy1 - dx1 * dy0;
      ASSERT(area >= 0.0);
   }
#endif

   for (i = 0; i < stop; i++) {
      const GLfloat sx = x + samples[i][0];
      const GLfloat sy = y + samples[i][1];
      const GLfloat fx0 = sx - v0[0];
      const GLfloat fy0 = sy - v0[1];
      const GLfloat fx1 = sx - v1[0];
      const GLfloat fy1 = sy - v1[1];
      const GLfloat fx2 = sx - v2[0];
      const GLfloat fy2 = sy - v2[1];
      /* cross product determines if sample is inside or outside each edge */
      GLfloat cross0 = (dx0 * fy0 - dy0 * fx0);
      GLfloat cross1 = (dx1 * fy1 - dy1 * fx1);
      GLfloat cross2 = (dx2 * fy2 - dy2 * fx2);
      /* Check if the sample is exactly on an edge.  If so, let cross be a
       * positive or negative value depending on the direction of the edge.
       */
      if (cross0 == 0.0F)
         cross0 = dx0 + dy0;
      if (cross1 == 0.0F)
         cross1 = dx1 + dy1;
      if (cross2 == 0.0F)
         cross2 = dx2 + dy2;
      if (cross0 < 0.0F || cross1 < 0.0F || cross2 < 0.0F) {
         /* point is outside triangle */
         insideCount--;
         stop = 15;
      }
   }
   if (stop == 4)
      return 15;
   else
      return insideCount;
}


a277 14
#define DO_RGBA
#include "s_aatritemp.h"
}


static void
index_aa_tri(GLcontext *ctx,
	     const SWvertex *v0,
	     const SWvertex *v1,
	     const SWvertex *v2)
{
#define DO_Z
#define DO_ATTRIBS
#define DO_INDEX
a288 1
#define DO_RGBA
d312 1
a312 1
   else if (ctx->Visual.rgbMode) {
a313 3
   }
   else {
      SWRAST_CONTEXT(ctx)->Triangle = index_aa_tri;
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d31 6
a36 6
#include "glheader.h"
#include "context.h"
#include "colormac.h"
#include "context.h"
#include "macros.h"
#include "imports.h"
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * Version:  6.3
d5 1
a5 1
 * Copyright (C) 1999-2004  Brian Paul   All Rights Reserved.
d147 13
a352 1

a359 1
#define DO_FOG
d372 1
a372 1
#define DO_FOG
a377 49
/*
 * Compute mipmap level of detail.
 * XXX we should really include the R coordinate in this computation
 * in order to do 3-D texture mipmapping.
 */
static INLINE GLfloat
compute_lambda(const GLfloat sPlane[4], const GLfloat tPlane[4],
               const GLfloat qPlane[4], GLfloat cx, GLfloat cy,
               GLfloat invQ, GLfloat texWidth, GLfloat texHeight)
{
   const GLfloat s = solve_plane(cx, cy, sPlane);
   const GLfloat t = solve_plane(cx, cy, tPlane);
   const GLfloat invQ_x1 = solve_plane_recip(cx+1.0F, cy, qPlane);
   const GLfloat invQ_y1 = solve_plane_recip(cx, cy+1.0F, qPlane);
   const GLfloat s_x1 = s - sPlane[0] / sPlane[2];
   const GLfloat s_y1 = s - sPlane[1] / sPlane[2];
   const GLfloat t_x1 = t - tPlane[0] / tPlane[2];
   const GLfloat t_y1 = t - tPlane[1] / tPlane[2];
   GLfloat dsdx = s_x1 * invQ_x1 - s * invQ;
   GLfloat dsdy = s_y1 * invQ_y1 - s * invQ;
   GLfloat dtdx = t_x1 * invQ_x1 - t * invQ;
   GLfloat dtdy = t_y1 * invQ_y1 - t * invQ;
   GLfloat maxU, maxV, rho, lambda;
   dsdx = FABSF(dsdx);
   dsdy = FABSF(dsdy);
   dtdx = FABSF(dtdx);
   dtdy = FABSF(dtdy);
   maxU = MAX2(dsdx, dsdy) * texWidth;
   maxV = MAX2(dtdx, dtdy) * texHeight;
   rho = MAX2(maxU, maxV);
   lambda = LOG2(rho);
   return lambda;
}


static void
tex_aa_tri(GLcontext *ctx,
	   const SWvertex *v0,
	   const SWvertex *v1,
	   const SWvertex *v2)
{
#define DO_Z
#define DO_FOG
#define DO_RGBA
#define DO_TEX
#include "s_aatritemp.h"
}


d379 4
a382 4
spec_tex_aa_tri(GLcontext *ctx,
		const SWvertex *v0,
		const SWvertex *v1,
		const SWvertex *v2)
a384 1
#define DO_FOG
d386 1
a386 2
#define DO_TEX
#define DO_SPEC
a390 27
static void
multitex_aa_tri(GLcontext *ctx,
		const SWvertex *v0,
		const SWvertex *v1,
		const SWvertex *v2)
{
#define DO_Z
#define DO_FOG
#define DO_RGBA
#define DO_MULTITEX
#include "s_aatritemp.h"
}

static void
spec_multitex_aa_tri(GLcontext *ctx,
		     const SWvertex *v0,
		     const SWvertex *v1,
		     const SWvertex *v2)
{
#define DO_Z
#define DO_FOG
#define DO_RGBA
#define DO_MULTITEX
#define DO_SPEC
#include "s_aatritemp.h"
}

d399 2
d403 5
a407 17
   if (ctx->Texture._EnabledCoordUnits != 0) {
      if (NEED_SECONDARY_COLOR(ctx)) {
         if (ctx->Texture._EnabledCoordUnits > 1) {
            SWRAST_CONTEXT(ctx)->Triangle = spec_multitex_aa_tri;
         }
         else {
            SWRAST_CONTEXT(ctx)->Triangle = spec_tex_aa_tri;
         }
      }
      else {
         if (ctx->Texture._EnabledCoordUnits > 1) {
            SWRAST_CONTEXT(ctx)->Triangle = multitex_aa_tri;
         }
         else {
            SWRAST_CONTEXT(ctx)->Triangle = tex_aa_tri;
         }
      }
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@Mesa 7.0.1
@
text
@d3 1
a3 1
 * Version:  6.5.3
d5 1
a5 1
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
d411 1
a411 1
#define DO_ATTRIBS
d425 1
a425 1
#define DO_ATTRIBS
d431 27
d468 1
a468 2
   if (ctx->Texture._EnabledCoordUnits != 0
       || ctx->FragmentProgram._Current) {
d470 6
a475 1
         SWRAST_CONTEXT(ctx)->Triangle = spec_tex_aa_tri;
d478 6
a483 1
         SWRAST_CONTEXT(ctx)->Triangle = tex_aa_tri;
@


1.1.1.3
log
@Import Mesa 7.10.3
@
text
@d31 6
a36 5
#include "main/glheader.h"
#include "main/context.h"
#include "main/colormac.h"
#include "main/macros.h"
#include "main/imports.h"
a146 13
static INLINE GLfloat
plane_dx(const GLfloat plane[4])
{
   return -plane[0] / plane[2];
}

static INLINE GLfloat
plane_dy(const GLfloat plane[4])
{
   return -plane[1] / plane[2];
}


d258 83
d342 1
a342 1
rgba_aa_tri(struct gl_context *ctx,
d348 15
d367 35
d403 4
a406 4
general_aa_tri(struct gl_context *ctx,
               const SWvertex *v0,
               const SWvertex *v1,
               const SWvertex *v2)
d409 2
d416 15
d437 1
a437 1
_swrast_set_aa_triangle_function(struct gl_context *ctx)
a438 2
   SWcontext *swrast = SWRAST_CONTEXT(ctx);

d442 10
a451 4
       || ctx->FragmentProgram._Current
       || swrast->_FogEnabled
       || NEED_SECONDARY_COLOR(ctx)) {
      SWRAST_CONTEXT(ctx)->Triangle = general_aa_tri;
d454 1
a454 1
      SWRAST_CONTEXT(ctx)->Triangle = rgba_aa_tri;
@


1.1.1.4
log
@Import Mesa 9.2.0
@
text
@d3 1
d20 3
a22 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
a35 1
#include "main/state.h"
d46 1
a46 1
static inline void
d79 1
a79 1
static inline void
d101 1
a101 1
static inline GLfloat
d116 1
a116 1
static inline GLfloat
d130 1
a130 1
static inline GLchan
d146 1
a146 1
static inline GLfloat
d152 1
a152 1
static inline GLfloat
d217 6
a222 1
   ASSERT(dx0 * dy1 - dx1 * dy0 >= 0.0); /* area >= 0.0 */
d306 1
a306 1
       || _swrast_use_fragment_program(ctx)
d308 1
a308 1
       || _mesa_need_secondary_color(ctx)) {
@


1.1.1.5
log
@Import Mesa 10.4.3
@
text
@d115 14
@


1.1.1.6
log
@Import Mesa 10.2.9
@
text
@a114 14
 * Return 1 / solve_plane().
 */
static inline GLfloat
solve_plane_recip(GLfloat x, GLfloat y, const GLfloat plane[4])
{
   const GLfloat denom = plane[3] + plane[0] * x + plane[1] * y;
   if (denom == 0.0F)
      return 0.0F;
   else
      return -plane[2] / denom;
}


/*
@


