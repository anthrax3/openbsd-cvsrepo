head	1.10;
access;
symbols
	OPENBSD_5_8:1.9.0.6
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.4
	OPENBSD_5_7_BASE:1.9
	v10_2_9:1.1.1.6
	v10_4_3:1.1.1.6
	v10_2_7:1.1.1.6
	OPENBSD_5_6:1.9.0.2
	OPENBSD_5_6_BASE:1.9
	v10_2_3:1.1.1.6
	OPENBSD_5_5:1.8.0.2
	OPENBSD_5_5_BASE:1.8
	v9_2_5:1.1.1.5
	v9_2_3:1.1.1.5
	v9_2_2:1.1.1.5
	v9_2_1:1.1.1.5
	v9_2_0:1.1.1.5
	OPENBSD_5_4:1.7.0.4
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.6.0.4
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.5.0.6
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2015.12.23.05.17.55;	author jsg;	state dead;
branches;
next	1.9;
commitid	TnlogFl9nOv2eaRf;

1.9
date	2014.07.09.21.09.01;	author jsg;	state Exp;
branches;
next	1.8;
commitid	WPD6rgPryPkvXOr9;

1.8
date	2013.09.05.14.06.51;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2012.08.17.13.58.20;	author mpi;	state Exp;
branches;
next	1.6;

1.6
date	2011.10.23.13.37.45;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.05.22.20.06.34;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.05.17.20.26.42;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.14.58.23;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.05.31.16.36.49;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.51.27;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.51.27;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.56.51;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.32.15;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.49;	author matthieu;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.09.05.13.17.35;	author jsg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.07.09.20.35.13;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.10
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */


/*
 * When the device driver doesn't implement triangle rasterization it
 * can hook in _swrast_Triangle, which eventually calls one of these
 * functions to draw triangles.
 */

#include "main/glheader.h"
#include "main/context.h"
#include "main/colormac.h"
#include "main/imports.h"
#include "main/macros.h"
#include "main/mtypes.h"
#include "main/state.h"
#include "main/samplerobj.h"
#include "program/prog_instruction.h"

#include "s_aatriangle.h"
#include "s_context.h"
#include "s_feedback.h"
#include "s_span.h"
#include "s_triangle.h"


/**
 * Test if a triangle should be culled.  Used for feedback and selection mode.
 * \return GL_TRUE if the triangle is to be culled, GL_FALSE otherwise.
 */
GLboolean
_swrast_culltriangle( struct gl_context *ctx,
                      const SWvertex *v0,
                      const SWvertex *v1,
                      const SWvertex *v2 )
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
   GLfloat ex = v1->attrib[VARYING_SLOT_POS][0] - v0->attrib[VARYING_SLOT_POS][0];
   GLfloat ey = v1->attrib[VARYING_SLOT_POS][1] - v0->attrib[VARYING_SLOT_POS][1];
   GLfloat fx = v2->attrib[VARYING_SLOT_POS][0] - v0->attrib[VARYING_SLOT_POS][0];
   GLfloat fy = v2->attrib[VARYING_SLOT_POS][1] - v0->attrib[VARYING_SLOT_POS][1];
   GLfloat c = ex*fy-ey*fx;

   if (c * swrast->_BackfaceSign * swrast->_BackfaceCullSign <= 0.0F)
      return GL_FALSE;

   return GL_TRUE;
}



/*
 * Render a flat-shaded RGBA triangle.
 */
#define NAME flat_rgba_triangle
#define INTERP_Z 1
#define SETUP_CODE				\
   ASSERT(ctx->Texture._EnabledCoordUnits == 0);\
   ASSERT(ctx->Light.ShadeModel==GL_FLAT);	\
   span.interpMask |= SPAN_RGBA;		\
   span.red = ChanToFixed(v2->color[0]);	\
   span.green = ChanToFixed(v2->color[1]);	\
   span.blue = ChanToFixed(v2->color[2]);	\
   span.alpha = ChanToFixed(v2->color[3]);	\
   span.redStep = 0;				\
   span.greenStep = 0;				\
   span.blueStep = 0;				\
   span.alphaStep = 0;
#define RENDER_SPAN( span )  _swrast_write_rgba_span(ctx, &span);
#include "s_tritemp.h"



/*
 * Render a smooth-shaded RGBA triangle.
 */
#define NAME smooth_rgba_triangle
#define INTERP_Z 1
#define INTERP_RGB 1
#define INTERP_ALPHA 1
#define SETUP_CODE				\
   {						\
      /* texturing must be off */		\
      ASSERT(ctx->Texture._EnabledCoordUnits == 0);	\
      ASSERT(ctx->Light.ShadeModel==GL_SMOOTH);	\
   }
#define RENDER_SPAN( span )  _swrast_write_rgba_span(ctx, &span);
#include "s_tritemp.h"



/*
 * Render an RGB, GL_DECAL, textured triangle.
 * Interpolate S,T only w/out mipmapping or perspective correction.
 *
 * No fog.  No depth testing.
 */
#define NAME simple_textured_triangle
#define INTERP_INT_TEX 1
#define S_SCALE twidth
#define T_SCALE theight

#define SETUP_CODE							\
   struct gl_renderbuffer *rb = ctx->DrawBuffer->_ColorDrawBuffers[0];	\
   const struct gl_texture_object *obj = 				\
      ctx->Texture.Unit[0].CurrentTex[TEXTURE_2D_INDEX];		\
   const struct gl_texture_image *texImg =				\
      obj->Image[0][obj->BaseLevel];					\
   const struct swrast_texture_image *swImg =				\
      swrast_texture_image_const(texImg);				\
   const GLfloat twidth = (GLfloat) texImg->Width;			\
   const GLfloat theight = (GLfloat) texImg->Height;			\
   const GLint twidth_log2 = texImg->WidthLog2;				\
   const GLubyte *texture = (const GLubyte *) swImg->ImageSlices[0];	\
   const GLint smask = texImg->Width - 1;				\
   const GLint tmask = texImg->Height - 1;				\
   ASSERT(texImg->TexFormat == MESA_FORMAT_BGR_UNORM8);			\
   if (!rb || !texture) {						\
      return;								\
   }

#define RENDER_SPAN( span )						\
   GLuint i;								\
   GLubyte (*rgba)[4] = swrast->SpanArrays->rgba8;			\
   span.intTex[0] -= FIXED_HALF; /* off-by-one error? */		\
   span.intTex[1] -= FIXED_HALF;					\
   for (i = 0; i < span.end; i++) {					\
      GLint s = FixedToInt(span.intTex[0]) & smask;			\
      GLint t = FixedToInt(span.intTex[1]) & tmask;			\
      GLint pos = (t << twidth_log2) + s;				\
      pos = pos + pos + pos;  /* multiply by 3 */			\
      rgba[i][RCOMP] = texture[pos+2];					\
      rgba[i][GCOMP] = texture[pos+1];					\
      rgba[i][BCOMP] = texture[pos+0];					\
      rgba[i][ACOMP] = 0xff;                                            \
      span.intTex[0] += span.intTexStep[0];				\
      span.intTex[1] += span.intTexStep[1];				\
   }									\
   _swrast_put_row(ctx, rb, GL_UNSIGNED_BYTE, span.end,                 \
                   span.x, span.y, rgba, NULL);

#include "s_tritemp.h"



/*
 * Render an RGB, GL_DECAL, textured triangle.
 * Interpolate S,T, GL_LESS depth test, w/out mipmapping or
 * perspective correction.
 * Depth buffer bits must be <= sizeof(DEFAULT_SOFTWARE_DEPTH_TYPE)
 *
 * No fog.
 */
#define NAME simple_z_textured_triangle
#define INTERP_Z 1
#define DEPTH_TYPE DEFAULT_SOFTWARE_DEPTH_TYPE
#define INTERP_INT_TEX 1
#define S_SCALE twidth
#define T_SCALE theight

#define SETUP_CODE							\
   struct gl_renderbuffer *rb = ctx->DrawBuffer->_ColorDrawBuffers[0];	\
   const struct gl_texture_object *obj = 				\
      ctx->Texture.Unit[0].CurrentTex[TEXTURE_2D_INDEX];		\
   const struct gl_texture_image *texImg = 				\
       obj->Image[0][obj->BaseLevel]; 					\
   const struct swrast_texture_image *swImg =				\
      swrast_texture_image_const(texImg);				\
   const GLfloat twidth = (GLfloat) texImg->Width;			\
   const GLfloat theight = (GLfloat) texImg->Height;			\
   const GLint twidth_log2 = texImg->WidthLog2;				\
   const GLubyte *texture = (const GLubyte *) swImg->ImageSlices[0];	\
   const GLint smask = texImg->Width - 1;				\
   const GLint tmask = texImg->Height - 1;				\
   ASSERT(texImg->TexFormat == MESA_FORMAT_BGR_UNORM8);			\
   if (!rb || !texture) {						\
      return;								\
   }

#define RENDER_SPAN( span )						\
   GLuint i;				    				\
   GLubyte (*rgba)[4] = swrast->SpanArrays->rgba8;			\
   GLubyte *mask = swrast->SpanArrays->mask;                            \
   span.intTex[0] -= FIXED_HALF; /* off-by-one error? */		\
   span.intTex[1] -= FIXED_HALF;					\
   for (i = 0; i < span.end; i++) {					\
      const GLuint z = FixedToDepth(span.z);				\
      if (z < zRow[i]) {						\
         GLint s = FixedToInt(span.intTex[0]) & smask;			\
         GLint t = FixedToInt(span.intTex[1]) & tmask;			\
         GLint pos = (t << twidth_log2) + s;				\
         pos = pos + pos + pos;  /* multiply by 3 */			\
         rgba[i][RCOMP] = texture[pos+2];				\
         rgba[i][GCOMP] = texture[pos+1];				\
         rgba[i][BCOMP] = texture[pos+0];				\
         rgba[i][ACOMP] = 0xff;          				\
         zRow[i] = z;							\
         mask[i] = 1;							\
      }									\
      else {								\
         mask[i] = 0;							\
      }									\
      span.intTex[0] += span.intTexStep[0];				\
      span.intTex[1] += span.intTexStep[1];				\
      span.z += span.zStep;						\
   }									\
   _swrast_put_row(ctx, rb, GL_UNSIGNED_BYTE,                           \
                   span.end, span.x, span.y, rgba, mask);

#include "s_tritemp.h"


#if CHAN_TYPE != GL_FLOAT

struct affine_info
{
   GLenum filter;
   GLenum format;
   GLenum envmode;
   GLint smask, tmask;
   GLint twidth_log2;
   const GLchan *texture;
   GLfixed er, eg, eb, ea;
   GLint tbytesline, tsize;
};


static inline GLint
ilerp(GLint t, GLint a, GLint b)
{
   return a + ((t * (b - a)) >> FIXED_SHIFT);
}

static inline GLint
ilerp_2d(GLint ia, GLint ib, GLint v00, GLint v10, GLint v01, GLint v11)
{
   const GLint temp0 = ilerp(ia, v00, v10);
   const GLint temp1 = ilerp(ia, v01, v11);
   return ilerp(ib, temp0, temp1);
}


/* This function can handle GL_NEAREST or GL_LINEAR sampling of 2D RGB or RGBA
 * textures with GL_REPLACE, GL_MODULATE, GL_BLEND, GL_DECAL or GL_ADD
 * texture env modes.
 */
static inline void
affine_span(struct gl_context *ctx, SWspan *span,
            struct affine_info *info)
{
   GLchan sample[4];  /* the filtered texture sample */
   const GLuint texEnableSave = ctx->Texture._EnabledCoordUnits;

   /* Instead of defining a function for each mode, a test is done
    * between the outer and inner loops. This is to reduce code size
    * and complexity. Observe that an optimizing compiler kills
    * unused variables (for instance tf,sf,ti,si in case of GL_NEAREST).
    */

#define NEAREST_RGB		\
   sample[RCOMP] = tex00[2];	\
   sample[GCOMP] = tex00[1];	\
   sample[BCOMP] = tex00[0];	\
   sample[ACOMP] = CHAN_MAX;

#define LINEAR_RGB							\
   sample[RCOMP] = ilerp_2d(sf, tf, tex00[2], tex01[2], tex10[2], tex11[2]);\
   sample[GCOMP] = ilerp_2d(sf, tf, tex00[1], tex01[1], tex10[1], tex11[1]);\
   sample[BCOMP] = ilerp_2d(sf, tf, tex00[0], tex01[0], tex10[0], tex11[0]);\
   sample[ACOMP] = CHAN_MAX;

#define NEAREST_RGBA  \
   sample[RCOMP] = tex00[3];	\
   sample[GCOMP] = tex00[2];	\
   sample[BCOMP] = tex00[1];	\
   sample[ACOMP] = tex00[0];

#define LINEAR_RGBA							\
   sample[RCOMP] = ilerp_2d(sf, tf, tex00[3], tex01[3], tex10[3], tex11[3]);\
   sample[GCOMP] = ilerp_2d(sf, tf, tex00[2], tex01[2], tex10[2], tex11[2]);\
   sample[BCOMP] = ilerp_2d(sf, tf, tex00[1], tex01[1], tex10[1], tex11[1]);\
   sample[ACOMP] = ilerp_2d(sf, tf, tex00[0], tex01[0], tex10[0], tex11[0])

#define MODULATE							  \
   dest[RCOMP] = span->red   * (sample[RCOMP] + 1u) >> (FIXED_SHIFT + 8); \
   dest[GCOMP] = span->green * (sample[GCOMP] + 1u) >> (FIXED_SHIFT + 8); \
   dest[BCOMP] = span->blue  * (sample[BCOMP] + 1u) >> (FIXED_SHIFT + 8); \
   dest[ACOMP] = span->alpha * (sample[ACOMP] + 1u) >> (FIXED_SHIFT + 8)

#define DECAL								\
   dest[RCOMP] = ((CHAN_MAX - sample[ACOMP]) * span->red +		\
               ((sample[ACOMP] + 1) * sample[RCOMP] << FIXED_SHIFT))	\
               >> (FIXED_SHIFT + 8);					\
   dest[GCOMP] = ((CHAN_MAX - sample[ACOMP]) * span->green +		\
               ((sample[ACOMP] + 1) * sample[GCOMP] << FIXED_SHIFT))	\
               >> (FIXED_SHIFT + 8);					\
   dest[BCOMP] = ((CHAN_MAX - sample[ACOMP]) * span->blue +		\
               ((sample[ACOMP] + 1) * sample[BCOMP] << FIXED_SHIFT))	\
               >> (FIXED_SHIFT + 8);					\
   dest[ACOMP] = FixedToInt(span->alpha)

#define BLEND								\
   dest[RCOMP] = ((CHAN_MAX - sample[RCOMP]) * span->red		\
               + (sample[RCOMP] + 1) * info->er) >> (FIXED_SHIFT + 8);	\
   dest[GCOMP] = ((CHAN_MAX - sample[GCOMP]) * span->green		\
               + (sample[GCOMP] + 1) * info->eg) >> (FIXED_SHIFT + 8);	\
   dest[BCOMP] = ((CHAN_MAX - sample[BCOMP]) * span->blue		\
               + (sample[BCOMP] + 1) * info->eb) >> (FIXED_SHIFT + 8);	\
   dest[ACOMP] = span->alpha * (sample[ACOMP] + 1) >> (FIXED_SHIFT + 8)

#define REPLACE  COPY_CHAN4(dest, sample)

#define ADD								\
   {									\
      GLint rSum = FixedToInt(span->red)   + (GLint) sample[RCOMP];	\
      GLint gSum = FixedToInt(span->green) + (GLint) sample[GCOMP];	\
      GLint bSum = FixedToInt(span->blue)  + (GLint) sample[BCOMP];	\
      dest[RCOMP] = MIN2(rSum, CHAN_MAX);				\
      dest[GCOMP] = MIN2(gSum, CHAN_MAX);				\
      dest[BCOMP] = MIN2(bSum, CHAN_MAX);				\
      dest[ACOMP] = span->alpha * (sample[ACOMP] + 1) >> (FIXED_SHIFT + 8); \
  }

/* shortcuts */

#define NEAREST_RGB_REPLACE		\
   NEAREST_RGB;				\
   dest[0] = sample[0];			\
   dest[1] = sample[1];			\
   dest[2] = sample[2];			\
   dest[3] = FixedToInt(span->alpha);

#define NEAREST_RGBA_REPLACE  \
   dest[RCOMP] = tex00[3]; \
   dest[GCOMP] = tex00[2]; \
   dest[BCOMP] = tex00[1]; \
   dest[ACOMP] = tex00[0]

#define SPAN_NEAREST(DO_TEX, COMPS)					\
	for (i = 0; i < span->end; i++) {				\
           /* Isn't it necessary to use FixedFloor below?? */		\
           GLint s = FixedToInt(span->intTex[0]) & info->smask;		\
           GLint t = FixedToInt(span->intTex[1]) & info->tmask;		\
           GLint pos = (t << info->twidth_log2) + s;			\
           const GLchan *tex00 = info->texture + COMPS * pos;		\
           DO_TEX;							\
           span->red += span->redStep;					\
	   span->green += span->greenStep;				\
           span->blue += span->blueStep;				\
	   span->alpha += span->alphaStep;				\
	   span->intTex[0] += span->intTexStep[0];			\
	   span->intTex[1] += span->intTexStep[1];			\
           dest += 4;							\
	}

#define SPAN_LINEAR(DO_TEX, COMPS)					\
	for (i = 0; i < span->end; i++) {				\
           /* Isn't it necessary to use FixedFloor below?? */		\
           const GLint s = FixedToInt(span->intTex[0]) & info->smask;	\
           const GLint t = FixedToInt(span->intTex[1]) & info->tmask;	\
           const GLfixed sf = span->intTex[0] & FIXED_FRAC_MASK;	\
           const GLfixed tf = span->intTex[1] & FIXED_FRAC_MASK;	\
           const GLint pos = (t << info->twidth_log2) + s;		\
           const GLchan *tex00 = info->texture + COMPS * pos;		\
           const GLchan *tex10 = tex00 + info->tbytesline;		\
           const GLchan *tex01 = tex00 + COMPS;				\
           const GLchan *tex11 = tex10 + COMPS;				\
           if (t == info->tmask) {					\
              tex10 -= info->tsize;					\
              tex11 -= info->tsize;					\
           }								\
           if (s == info->smask) {					\
              tex01 -= info->tbytesline;				\
              tex11 -= info->tbytesline;				\
           }								\
           DO_TEX;							\
           span->red += span->redStep;					\
	   span->green += span->greenStep;				\
           span->blue += span->blueStep;				\
	   span->alpha += span->alphaStep;				\
	   span->intTex[0] += span->intTexStep[0];			\
	   span->intTex[1] += span->intTexStep[1];			\
           dest += 4;							\
	}


   GLuint i;
   GLchan *dest = span->array->rgba[0];

   /* Disable tex units so they're not re-applied in swrast_write_rgba_span */
   ctx->Texture._EnabledCoordUnits = 0x0;

   span->intTex[0] -= FIXED_HALF;
   span->intTex[1] -= FIXED_HALF;
   switch (info->filter) {
   case GL_NEAREST:
      switch (info->format) {
      case MESA_FORMAT_BGR_UNORM8:
         switch (info->envmode) {
         case GL_MODULATE:
            SPAN_NEAREST(NEAREST_RGB;MODULATE,3);
            break;
         case GL_DECAL:
         case GL_REPLACE:
            SPAN_NEAREST(NEAREST_RGB_REPLACE,3);
            break;
         case GL_BLEND:
            SPAN_NEAREST(NEAREST_RGB;BLEND,3);
            break;
         case GL_ADD:
            SPAN_NEAREST(NEAREST_RGB;ADD,3);
            break;
         default:
            _mesa_problem(ctx, "bad tex env mode in SPAN_LINEAR");
            return;
         }
         break;
      case MESA_FORMAT_A8B8G8R8_UNORM:
         switch(info->envmode) {
         case GL_MODULATE:
            SPAN_NEAREST(NEAREST_RGBA;MODULATE,4);
            break;
         case GL_DECAL:
            SPAN_NEAREST(NEAREST_RGBA;DECAL,4);
            break;
         case GL_BLEND:
            SPAN_NEAREST(NEAREST_RGBA;BLEND,4);
            break;
         case GL_ADD:
            SPAN_NEAREST(NEAREST_RGBA;ADD,4);
            break;
         case GL_REPLACE:
            SPAN_NEAREST(NEAREST_RGBA_REPLACE,4);
            break;
         default:
            _mesa_problem(ctx, "bad tex env mode (2) in SPAN_LINEAR");
            return;
         }
         break;
      }
      break;

   case GL_LINEAR:
      span->intTex[0] -= FIXED_HALF;
      span->intTex[1] -= FIXED_HALF;
      switch (info->format) {
      case MESA_FORMAT_BGR_UNORM8:
         switch (info->envmode) {
         case GL_MODULATE:
            SPAN_LINEAR(LINEAR_RGB;MODULATE,3);
            break;
         case GL_DECAL:
         case GL_REPLACE:
            SPAN_LINEAR(LINEAR_RGB;REPLACE,3);
            break;
         case GL_BLEND:
            SPAN_LINEAR(LINEAR_RGB;BLEND,3);
            break;
         case GL_ADD:
            SPAN_LINEAR(LINEAR_RGB;ADD,3);
            break;
         default:
            _mesa_problem(ctx, "bad tex env mode (3) in SPAN_LINEAR");
            return;
         }
         break;
      case MESA_FORMAT_A8B8G8R8_UNORM:
         switch (info->envmode) {
         case GL_MODULATE:
            SPAN_LINEAR(LINEAR_RGBA;MODULATE,4);
            break;
         case GL_DECAL:
            SPAN_LINEAR(LINEAR_RGBA;DECAL,4);
            break;
         case GL_BLEND:
            SPAN_LINEAR(LINEAR_RGBA;BLEND,4);
            break;
         case GL_ADD:
            SPAN_LINEAR(LINEAR_RGBA;ADD,4);
            break;
         case GL_REPLACE:
            SPAN_LINEAR(LINEAR_RGBA;REPLACE,4);
            break;
         default:
            _mesa_problem(ctx, "bad tex env mode (4) in SPAN_LINEAR");
            return;
         }
         break;
      }
      break;
   }
   span->interpMask &= ~SPAN_RGBA;
   ASSERT(span->arrayMask & SPAN_RGBA);

   _swrast_write_rgba_span(ctx, span);

   /* re-enable texture units */
   ctx->Texture._EnabledCoordUnits = texEnableSave;

#undef SPAN_NEAREST
#undef SPAN_LINEAR
}



/*
 * Render an RGB/RGBA textured triangle without perspective correction.
 */
#define NAME affine_textured_triangle
#define INTERP_Z 1
#define INTERP_RGB 1
#define INTERP_ALPHA 1
#define INTERP_INT_TEX 1
#define S_SCALE twidth
#define T_SCALE theight

#define SETUP_CODE							\
   struct affine_info info;						\
   struct gl_texture_unit *unit = ctx->Texture.Unit+0;			\
   const struct gl_texture_object *obj = 				\
      ctx->Texture.Unit[0].CurrentTex[TEXTURE_2D_INDEX];		\
   const struct gl_texture_image *texImg = 				\
      obj->Image[0][obj->BaseLevel]; 					\
   const struct swrast_texture_image *swImg =				\
      swrast_texture_image_const(texImg);				\
   const GLfloat twidth = (GLfloat) texImg->Width;			\
   const GLfloat theight = (GLfloat) texImg->Height;			\
   info.texture = (const GLchan *) swImg->ImageSlices[0];		\
   info.twidth_log2 = texImg->WidthLog2;				\
   info.smask = texImg->Width - 1;					\
   info.tmask = texImg->Height - 1;					\
   info.format = texImg->TexFormat;					\
   info.filter = obj->Sampler.MinFilter;				\
   info.envmode = unit->EnvMode;					\
   info.er = 0;					\
   info.eg = 0;					\
   info.eb = 0;					\
   span.arrayMask |= SPAN_RGBA;						\
									\
   if (info.envmode == GL_BLEND) {					\
      /* potential off-by-one error here? (1.0f -> 2048 -> 0) */	\
      info.er = FloatToFixed(unit->EnvColor[RCOMP] * CHAN_MAXF);	\
      info.eg = FloatToFixed(unit->EnvColor[GCOMP] * CHAN_MAXF);	\
      info.eb = FloatToFixed(unit->EnvColor[BCOMP] * CHAN_MAXF);	\
      info.ea = FloatToFixed(unit->EnvColor[ACOMP] * CHAN_MAXF);	\
   }									\
   if (!info.texture) {							\
      /* this shouldn't happen */					\
      return;								\
   }									\
									\
   switch (info.format) {						\
   case MESA_FORMAT_BGR_UNORM8:						\
      info.tbytesline = texImg->Width * 3;				\
      break;								\
   case MESA_FORMAT_A8B8G8R8_UNORM:						\
      info.tbytesline = texImg->Width * 4;				\
      break;								\
   default:								\
      _mesa_problem(NULL, "Bad texture format in affine_texture_triangle");\
      return;								\
   }									\
   info.tsize = texImg->Height * info.tbytesline;

#define RENDER_SPAN( span )   affine_span(ctx, &span, &info);

#include "s_tritemp.h"



struct persp_info
{
   GLenum filter;
   GLenum format;
   GLenum envmode;
   GLint smask, tmask;
   GLint twidth_log2;
   const GLchan *texture;
   GLfixed er, eg, eb, ea;   /* texture env color */
   GLint tbytesline, tsize;
};


static inline void
fast_persp_span(struct gl_context *ctx, SWspan *span,
		struct persp_info *info)
{
   GLchan sample[4];  /* the filtered texture sample */

  /* Instead of defining a function for each mode, a test is done
   * between the outer and inner loops. This is to reduce code size
   * and complexity. Observe that an optimizing compiler kills
   * unused variables (for instance tf,sf,ti,si in case of GL_NEAREST).
   */
#define SPAN_NEAREST(DO_TEX,COMP)					\
	for (i = 0; i < span->end; i++) {				\
           GLdouble invQ = tex_coord[2] ?				\
                                 (1.0 / tex_coord[2]) : 1.0;            \
           GLfloat s_tmp = (GLfloat) (tex_coord[0] * invQ);		\
           GLfloat t_tmp = (GLfloat) (tex_coord[1] * invQ);		\
           GLint s = IFLOOR(s_tmp) & info->smask;	        	\
           GLint t = IFLOOR(t_tmp) & info->tmask;	        	\
           GLint pos = (t << info->twidth_log2) + s;			\
           const GLchan *tex00 = info->texture + COMP * pos;		\
           DO_TEX;							\
           span->red += span->redStep;					\
	   span->green += span->greenStep;				\
           span->blue += span->blueStep;				\
	   span->alpha += span->alphaStep;				\
	   tex_coord[0] += tex_step[0];					\
	   tex_coord[1] += tex_step[1];					\
	   tex_coord[2] += tex_step[2];					\
           dest += 4;							\
	}

#define SPAN_LINEAR(DO_TEX,COMP)					\
	for (i = 0; i < span->end; i++) {				\
           GLdouble invQ = tex_coord[2] ?				\
                                 (1.0 / tex_coord[2]) : 1.0;            \
           const GLfloat s_tmp = (GLfloat) (tex_coord[0] * invQ);	\
           const GLfloat t_tmp = (GLfloat) (tex_coord[1] * invQ);	\
           const GLfixed s_fix = FloatToFixed(s_tmp) - FIXED_HALF;	\
           const GLfixed t_fix = FloatToFixed(t_tmp) - FIXED_HALF;      \
           const GLint s = FixedToInt(FixedFloor(s_fix)) & info->smask;	\
           const GLint t = FixedToInt(FixedFloor(t_fix)) & info->tmask;	\
           const GLfixed sf = s_fix & FIXED_FRAC_MASK;			\
           const GLfixed tf = t_fix & FIXED_FRAC_MASK;			\
           const GLint pos = (t << info->twidth_log2) + s;		\
           const GLchan *tex00 = info->texture + COMP * pos;		\
           const GLchan *tex10 = tex00 + info->tbytesline;		\
           const GLchan *tex01 = tex00 + COMP;				\
           const GLchan *tex11 = tex10 + COMP;				\
           if (t == info->tmask) {					\
              tex10 -= info->tsize;					\
              tex11 -= info->tsize;					\
           }								\
           if (s == info->smask) {					\
              tex01 -= info->tbytesline;				\
              tex11 -= info->tbytesline;				\
           }								\
           DO_TEX;							\
           span->red   += span->redStep;				\
	   span->green += span->greenStep;				\
           span->blue  += span->blueStep;				\
	   span->alpha += span->alphaStep;				\
	   tex_coord[0] += tex_step[0];					\
	   tex_coord[1] += tex_step[1];					\
	   tex_coord[2] += tex_step[2];					\
           dest += 4;							\
	}

   GLuint i;
   GLfloat tex_coord[3], tex_step[3];
   GLchan *dest = span->array->rgba[0];

   const GLuint texEnableSave = ctx->Texture._EnabledCoordUnits;
   ctx->Texture._EnabledCoordUnits = 0;

   tex_coord[0] = span->attrStart[VARYING_SLOT_TEX0][0]  * (info->smask + 1);
   tex_step[0] = span->attrStepX[VARYING_SLOT_TEX0][0] * (info->smask + 1);
   tex_coord[1] = span->attrStart[VARYING_SLOT_TEX0][1] * (info->tmask + 1);
   tex_step[1] = span->attrStepX[VARYING_SLOT_TEX0][1] * (info->tmask + 1);
   /* span->attrStart[VARYING_SLOT_TEX0][2] only if 3D-texturing, here only 2D */
   tex_coord[2] = span->attrStart[VARYING_SLOT_TEX0][3];
   tex_step[2] = span->attrStepX[VARYING_SLOT_TEX0][3];

   switch (info->filter) {
   case GL_NEAREST:
      switch (info->format) {
      case MESA_FORMAT_BGR_UNORM8:
         switch (info->envmode) {
         case GL_MODULATE:
            SPAN_NEAREST(NEAREST_RGB;MODULATE,3);
            break;
         case GL_DECAL:
         case GL_REPLACE:
            SPAN_NEAREST(NEAREST_RGB_REPLACE,3);
            break;
         case GL_BLEND:
            SPAN_NEAREST(NEAREST_RGB;BLEND,3);
            break;
         case GL_ADD:
            SPAN_NEAREST(NEAREST_RGB;ADD,3);
            break;
         default:
            _mesa_problem(ctx, "bad tex env mode (5) in SPAN_LINEAR");
            return;
         }
         break;
      case MESA_FORMAT_A8B8G8R8_UNORM:
         switch(info->envmode) {
         case GL_MODULATE:
            SPAN_NEAREST(NEAREST_RGBA;MODULATE,4);
            break;
         case GL_DECAL:
            SPAN_NEAREST(NEAREST_RGBA;DECAL,4);
            break;
         case GL_BLEND:
            SPAN_NEAREST(NEAREST_RGBA;BLEND,4);
            break;
         case GL_ADD:
            SPAN_NEAREST(NEAREST_RGBA;ADD,4);
            break;
         case GL_REPLACE:
            SPAN_NEAREST(NEAREST_RGBA_REPLACE,4);
            break;
         default:
            _mesa_problem(ctx, "bad tex env mode (6) in SPAN_LINEAR");
            return;
         }
         break;
      }
      break;

   case GL_LINEAR:
      switch (info->format) {
      case MESA_FORMAT_BGR_UNORM8:
         switch (info->envmode) {
         case GL_MODULATE:
            SPAN_LINEAR(LINEAR_RGB;MODULATE,3);
            break;
         case GL_DECAL:
         case GL_REPLACE:
            SPAN_LINEAR(LINEAR_RGB;REPLACE,3);
            break;
         case GL_BLEND:
            SPAN_LINEAR(LINEAR_RGB;BLEND,3);
            break;
         case GL_ADD:
            SPAN_LINEAR(LINEAR_RGB;ADD,3);
            break;
         default:
            _mesa_problem(ctx, "bad tex env mode (7) in SPAN_LINEAR");
            return;
         }
         break;
      case MESA_FORMAT_A8B8G8R8_UNORM:
         switch (info->envmode) {
         case GL_MODULATE:
            SPAN_LINEAR(LINEAR_RGBA;MODULATE,4);
            break;
         case GL_DECAL:
            SPAN_LINEAR(LINEAR_RGBA;DECAL,4);
            break;
         case GL_BLEND:
            SPAN_LINEAR(LINEAR_RGBA;BLEND,4);
            break;
         case GL_ADD:
            SPAN_LINEAR(LINEAR_RGBA;ADD,4);
            break;
         case GL_REPLACE:
            SPAN_LINEAR(LINEAR_RGBA;REPLACE,4);
            break;
         default:
            _mesa_problem(ctx, "bad tex env mode (8) in SPAN_LINEAR");
            return;
         }
         break;
      }
      break;
   }
   
   ASSERT(span->arrayMask & SPAN_RGBA);
   _swrast_write_rgba_span(ctx, span);

#undef SPAN_NEAREST
#undef SPAN_LINEAR

   /* restore state */
   ctx->Texture._EnabledCoordUnits = texEnableSave;
}


/*
 * Render an perspective corrected RGB/RGBA textured triangle.
 * The Q (aka V in Mesa) coordinate must be zero such that the divide
 * by interpolated Q/W comes out right.
 *
 */
#define NAME persp_textured_triangle
#define INTERP_Z 1
#define INTERP_RGB 1
#define INTERP_ALPHA 1
#define INTERP_ATTRIBS 1

#define SETUP_CODE							\
   struct persp_info info;						\
   const struct gl_texture_unit *unit = ctx->Texture.Unit+0;		\
   const struct gl_texture_object *obj = 				\
      ctx->Texture.Unit[0].CurrentTex[TEXTURE_2D_INDEX];		\
   const struct gl_texture_image *texImg = 				\
      obj->Image[0][obj->BaseLevel];			 		\
   const struct swrast_texture_image *swImg =				\
      swrast_texture_image_const(texImg);				\
   info.texture = (const GLchan *) swImg->ImageSlices[0];		\
   info.twidth_log2 = texImg->WidthLog2;				\
   info.smask = texImg->Width - 1;					\
   info.tmask = texImg->Height - 1;					\
   info.format = texImg->TexFormat;					\
   info.filter = obj->Sampler.MinFilter;				\
   info.envmode = unit->EnvMode;					\
   info.er = 0;					\
   info.eg = 0;					\
   info.eb = 0;					\
									\
   if (info.envmode == GL_BLEND) {					\
      /* potential off-by-one error here? (1.0f -> 2048 -> 0) */	\
      info.er = FloatToFixed(unit->EnvColor[RCOMP] * CHAN_MAXF);	\
      info.eg = FloatToFixed(unit->EnvColor[GCOMP] * CHAN_MAXF);	\
      info.eb = FloatToFixed(unit->EnvColor[BCOMP] * CHAN_MAXF);	\
      info.ea = FloatToFixed(unit->EnvColor[ACOMP] * CHAN_MAXF);	\
   }									\
   if (!info.texture) {							\
      /* this shouldn't happen */					\
      return;								\
   }									\
									\
   switch (info.format) {						\
   case MESA_FORMAT_BGR_UNORM8:						\
      info.tbytesline = texImg->Width * 3;				\
      break;								\
   case MESA_FORMAT_A8B8G8R8_UNORM:						\
      info.tbytesline = texImg->Width * 4;				\
      break;								\
   default:								\
      _mesa_problem(NULL, "Bad texture format in persp_textured_triangle");\
      return;								\
   }									\
   info.tsize = texImg->Height * info.tbytesline;

#define RENDER_SPAN( span )			\
   span.interpMask &= ~SPAN_RGBA;		\
   span.arrayMask |= SPAN_RGBA;			\
   fast_persp_span(ctx, &span, &info);

#include "s_tritemp.h"

#endif /*CHAN_TYPE != GL_FLOAT*/



/*
 * Render an RGBA triangle with arbitrary attributes.
 */
#define NAME general_triangle
#define INTERP_Z 1
#define INTERP_RGB 1
#define INTERP_ALPHA 1
#define INTERP_ATTRIBS 1
#define RENDER_SPAN( span )   _swrast_write_rgba_span(ctx, &span);
#include "s_tritemp.h"




/*
 * Special tri function for occlusion testing
 */
#define NAME occlusion_zless_16_triangle
#define INTERP_Z 1
#define SETUP_CODE							\
   struct gl_renderbuffer *rb =                                         \
      ctx->DrawBuffer->Attachment[BUFFER_DEPTH].Renderbuffer;           \
   struct gl_query_object *q = ctx->Query.CurrentOcclusionObject;	\
   ASSERT(ctx->Depth.Test);						\
   ASSERT(!ctx->Depth.Mask);						\
   ASSERT(ctx->Depth.Func == GL_LESS);					\
   assert(rb->Format == MESA_FORMAT_Z_UNORM16);                               \
   if (!q) {								\
      return;								\
   }
#define RENDER_SPAN( span )						\
   {                                                                    \
      GLuint i;								\
      const GLushort *zRow = (const GLushort *)				\
         _swrast_pixel_address(rb, span.x, span.y);                     \
      for (i = 0; i < span.end; i++) {					\
         GLuint z = FixedToDepth(span.z);				\
         if (z < zRow[i]) {						\
            q->Result++;						\
         }								\
         span.z += span.zStep;						\
      }									\
   }
#include "s_tritemp.h"



static void
nodraw_triangle( struct gl_context *ctx,
                 const SWvertex *v0,
                 const SWvertex *v1,
                 const SWvertex *v2 )
{
   (void) (ctx && v0 && v1 && v2);
}


/*
 * This is used when separate specular color is enabled, but not
 * texturing.  We add the specular color to the primary color,
 * draw the triangle, then restore the original primary color.
 * Inefficient, but seldom needed.
 */
void
_swrast_add_spec_terms_triangle(struct gl_context *ctx, const SWvertex *v0,
                                const SWvertex *v1, const SWvertex *v2)
{
   SWvertex *ncv0 = (SWvertex *)v0; /* drop const qualifier */
   SWvertex *ncv1 = (SWvertex *)v1;
   SWvertex *ncv2 = (SWvertex *)v2;
   GLfloat rSum, gSum, bSum;
   GLchan cSave[3][4];

   /* save original colors */
   COPY_CHAN4( cSave[0], ncv0->color );
   COPY_CHAN4( cSave[1], ncv1->color );
   COPY_CHAN4( cSave[2], ncv2->color );
   /* sum v0 */
   rSum = CHAN_TO_FLOAT(ncv0->color[0]) + ncv0->attrib[VARYING_SLOT_COL1][0];
   gSum = CHAN_TO_FLOAT(ncv0->color[1]) + ncv0->attrib[VARYING_SLOT_COL1][1];
   bSum = CHAN_TO_FLOAT(ncv0->color[2]) + ncv0->attrib[VARYING_SLOT_COL1][2];
   UNCLAMPED_FLOAT_TO_CHAN(ncv0->color[0], rSum);
   UNCLAMPED_FLOAT_TO_CHAN(ncv0->color[1], gSum);
   UNCLAMPED_FLOAT_TO_CHAN(ncv0->color[2], bSum);
   /* sum v1 */
   rSum = CHAN_TO_FLOAT(ncv1->color[0]) + ncv1->attrib[VARYING_SLOT_COL1][0];
   gSum = CHAN_TO_FLOAT(ncv1->color[1]) + ncv1->attrib[VARYING_SLOT_COL1][1];
   bSum = CHAN_TO_FLOAT(ncv1->color[2]) + ncv1->attrib[VARYING_SLOT_COL1][2];
   UNCLAMPED_FLOAT_TO_CHAN(ncv1->color[0], rSum);
   UNCLAMPED_FLOAT_TO_CHAN(ncv1->color[1], gSum);
   UNCLAMPED_FLOAT_TO_CHAN(ncv1->color[2], bSum);
   /* sum v2 */
   rSum = CHAN_TO_FLOAT(ncv2->color[0]) + ncv2->attrib[VARYING_SLOT_COL1][0];
   gSum = CHAN_TO_FLOAT(ncv2->color[1]) + ncv2->attrib[VARYING_SLOT_COL1][1];
   bSum = CHAN_TO_FLOAT(ncv2->color[2]) + ncv2->attrib[VARYING_SLOT_COL1][2];
   UNCLAMPED_FLOAT_TO_CHAN(ncv2->color[0], rSum);
   UNCLAMPED_FLOAT_TO_CHAN(ncv2->color[1], gSum);
   UNCLAMPED_FLOAT_TO_CHAN(ncv2->color[2], bSum);
   /* draw */
   SWRAST_CONTEXT(ctx)->SpecTriangle( ctx, ncv0, ncv1, ncv2 );
   /* restore original colors */
   COPY_CHAN4( ncv0->color, cSave[0] );
   COPY_CHAN4( ncv1->color, cSave[1] );
   COPY_CHAN4( ncv2->color, cSave[2] );
}



#ifdef DEBUG

/* record the current triangle function name */
const char *_mesa_triFuncName = NULL;

#define USE(triFunc)				\
do {						\
    _mesa_triFuncName = #triFunc;		\
    /*printf("%s\n", _mesa_triFuncName);*/	\
    swrast->Triangle = triFunc;			\
} while (0)

#else

#define USE(triFunc)  swrast->Triangle = triFunc;

#endif




/*
 * Determine which triangle rendering function to use given the current
 * rendering context.
 *
 * Please update the summary flag _SWRAST_NEW_TRIANGLE if you add or
 * remove tests to this code.
 */
void
_swrast_choose_triangle( struct gl_context *ctx )
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);

   if (ctx->Polygon.CullFlag &&
       ctx->Polygon.CullFaceMode == GL_FRONT_AND_BACK) {
      USE(nodraw_triangle);
      return;
   }

   if (ctx->RenderMode==GL_RENDER) {
      struct gl_renderbuffer *depthRb =
         ctx->DrawBuffer->Attachment[BUFFER_DEPTH].Renderbuffer;

      if (ctx->Polygon.SmoothFlag) {
         _swrast_set_aa_triangle_function(ctx);
         ASSERT(swrast->Triangle);
         return;
      }

      /* special case for occlusion testing */
      if (ctx->Query.CurrentOcclusionObject &&
          ctx->Depth.Test &&
          ctx->Depth.Mask == GL_FALSE &&
          ctx->Depth.Func == GL_LESS &&
          !ctx->Stencil._Enabled &&
          depthRb &&
          depthRb->Format == MESA_FORMAT_Z_UNORM16) {
         if (ctx->Color.ColorMask[0][0] == 0 &&
	     ctx->Color.ColorMask[0][1] == 0 &&
	     ctx->Color.ColorMask[0][2] == 0 &&
	     ctx->Color.ColorMask[0][3] == 0) {
            USE(occlusion_zless_16_triangle);
            return;
         }
      }

      /*
       * XXX should examine swrast->_ActiveAttribMask to determine what
       * needs to be interpolated.
       */
      if (ctx->Texture._EnabledCoordUnits ||
	  _swrast_use_fragment_program(ctx) ||
          ctx->ATIFragmentShader._Enabled ||
          _mesa_need_secondary_color(ctx) ||
          swrast->_FogEnabled) {
         /* Ugh, we do a _lot_ of tests to pick the best textured tri func */
         const struct gl_texture_object *texObj2D;
         const struct gl_sampler_object *samp;
         const struct gl_texture_image *texImg;
         const struct swrast_texture_image *swImg;
         GLenum minFilter, magFilter, envMode;
         mesa_format format;
         texObj2D = ctx->Texture.Unit[0].CurrentTex[TEXTURE_2D_INDEX];
         if (ctx->Texture.Unit[0].Sampler)
            samp = ctx->Texture.Unit[0].Sampler;
         else if (texObj2D)
            samp = &texObj2D->Sampler;
         else
            samp = NULL;

         texImg = texObj2D ? texObj2D->Image[0][texObj2D->BaseLevel] : NULL;
         swImg = swrast_texture_image_const(texImg);

         format = texImg ? texImg->TexFormat : MESA_FORMAT_NONE;
         minFilter = texObj2D ? samp->MinFilter : GL_NONE;
         magFilter = texObj2D ? samp->MagFilter : GL_NONE;
         envMode = ctx->Texture.Unit[0].EnvMode;

         /* First see if we can use an optimized 2-D texture function */
         if (ctx->Texture._EnabledCoordUnits == 0x1
             && !_swrast_use_fragment_program(ctx)
             && !ctx->ATIFragmentShader._Enabled
             && ctx->Texture._MaxEnabledTexImageUnit == 0
             && ctx->Texture.Unit[0]._Current->Target == GL_TEXTURE_2D
             && samp->WrapS == GL_REPEAT
             && samp->WrapT == GL_REPEAT
             && texObj2D->_Swizzle == SWIZZLE_NOOP
             && swImg->_IsPowerOfTwo
             && texImg->Border == 0
             && (_mesa_format_row_stride(format, texImg->Width) ==
                 swImg->RowStride)
             && (format == MESA_FORMAT_BGR_UNORM8 || format == MESA_FORMAT_A8B8G8R8_UNORM)
             && minFilter == magFilter
             && ctx->Light.Model.ColorControl == GL_SINGLE_COLOR
             && !swrast->_FogEnabled
             && ctx->Texture.Unit[0].EnvMode != GL_COMBINE_EXT
             && ctx->Texture.Unit[0].EnvMode != GL_COMBINE4_NV) {
	    if (ctx->Hint.PerspectiveCorrection==GL_FASTEST) {
	       if (minFilter == GL_NEAREST
		   && format == MESA_FORMAT_BGR_UNORM8
		   && (envMode == GL_REPLACE || envMode == GL_DECAL)
		   && ((swrast->_RasterMask == (DEPTH_BIT | TEXTURE_BIT)
			&& ctx->Depth.Func == GL_LESS
			&& ctx->Depth.Mask == GL_TRUE)
		       || swrast->_RasterMask == TEXTURE_BIT)
		   && ctx->Polygon.StippleFlag == GL_FALSE
                   && ctx->DrawBuffer->Visual.depthBits <= 16) {
		  if (swrast->_RasterMask == (DEPTH_BIT | TEXTURE_BIT)) {
		     USE(simple_z_textured_triangle);
		  }
		  else {
		     USE(simple_textured_triangle);
		  }
	       }
	       else {
#if CHAN_BITS != 8
                  USE(general_triangle);
#else
                  if (format == MESA_FORMAT_A8B8G8R8_UNORM && !_mesa_little_endian()) {
                     /* We only handle RGBA8888 correctly on little endian
                      * in the optimized code above.
                      */
                     USE(general_triangle);
                  }
                  else {
                     USE(affine_textured_triangle);
                 }
#endif
	       }
	    }
	    else {
#if CHAN_BITS != 8
               USE(general_triangle);
#else
               USE(persp_textured_triangle);
#endif
	    }
	 }
         else {
            /* general case textured triangles */
            USE(general_triangle);
         }
      }
      else {
         ASSERT(!swrast->_FogEnabled);
         ASSERT(!_mesa_need_secondary_color(ctx));
	 if (ctx->Light.ShadeModel==GL_SMOOTH) {
	    /* smooth shaded, no texturing, stippled or some raster ops */
#if CHAN_BITS != 8
               USE(general_triangle);
#else
               USE(smooth_rgba_triangle);
#endif
	 }
	 else {
	    /* flat shaded, no texturing, stippled or some raster ops */
#if CHAN_BITS != 8
            USE(general_triangle);
#else
            USE(flat_rgba_triangle);
#endif
	 }
      }
   }
   else if (ctx->RenderMode==GL_FEEDBACK) {
      USE(_swrast_feedback_triangle);
   }
   else {
      /* GL_SELECT mode */
      USE(_swrast_select_triangle);
   }
}
@


1.9
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.8
log
@Merge Mesa 9.2.0
@
text
@d139 1
a139 1
   ASSERT(texImg->TexFormat == MESA_FORMAT_RGB888);			\
d197 1
a197 1
   ASSERT(texImg->TexFormat == MESA_FORMAT_RGB888);			\
d420 1
a420 1
      case MESA_FORMAT_RGB888:
d440 1
a440 1
      case MESA_FORMAT_RGBA8888:
d469 1
a469 1
      case MESA_FORMAT_RGB888:
d489 1
a489 1
      case MESA_FORMAT_RGBA8888:
d575 1
a575 1
   case MESA_FORMAT_RGB888:						\
d578 1
a578 1
   case MESA_FORMAT_RGBA8888:						\
d692 1
a692 1
      case MESA_FORMAT_RGB888:
d712 1
a712 1
      case MESA_FORMAT_RGBA8888:
d739 1
a739 1
      case MESA_FORMAT_RGB888:
d759 1
a759 1
      case MESA_FORMAT_RGBA8888:
d841 1
a841 1
   case MESA_FORMAT_RGB888:						\
d844 1
a844 1
   case MESA_FORMAT_RGBA8888:						\
d890 1
a890 1
   assert(rb->Format == MESA_FORMAT_Z16);                               \
d1028 1
a1028 1
          depthRb->Format == MESA_FORMAT_Z16) {
d1053 1
a1053 1
         gl_format format;
d1074 2
a1075 2
             && ctx->Texture._EnabledUnits == 0x1
             && ctx->Texture.Unit[0]._ReallyEnabled == TEXTURE_2D_BIT
d1083 1
a1083 1
             && (format == MESA_FORMAT_RGB888 || format == MESA_FORMAT_RGBA8888)
d1091 1
a1091 1
		   && format == MESA_FORMAT_RGB888
d1110 1
a1110 1
                  if (format == MESA_FORMAT_RGBA8888 && !_mesa_little_endian()) {
@


1.7
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a2 1
 * Version:  7.3
d19 4
a22 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
d39 1
d60 4
a63 4
   GLfloat ex = v1->attrib[FRAG_ATTRIB_WPOS][0] - v0->attrib[FRAG_ATTRIB_WPOS][0];
   GLfloat ey = v1->attrib[FRAG_ATTRIB_WPOS][1] - v0->attrib[FRAG_ATTRIB_WPOS][1];
   GLfloat fx = v2->attrib[FRAG_ATTRIB_WPOS][0] - v0->attrib[FRAG_ATTRIB_WPOS][0];
   GLfloat fy = v2->attrib[FRAG_ATTRIB_WPOS][1] - v0->attrib[FRAG_ATTRIB_WPOS][1];
d131 2
d136 1
a136 1
   const GLubyte *texture = (const GLubyte *) texImg->Data;		\
d146 1
a146 1
   GLubyte rgb[MAX_WIDTH][3];						\
d154 4
a157 3
      rgb[i][RCOMP] = texture[pos+2];					\
      rgb[i][GCOMP] = texture[pos+1];					\
      rgb[i][BCOMP] = texture[pos+0];					\
d161 2
a162 1
   rb->PutRowRGB(ctx, rb, span.end, span.x, span.y, rgb, NULL);
d189 2
d194 1
a194 1
   const GLubyte *texture = (const GLubyte *) texImg->Data;		\
d204 2
a205 1
   GLubyte rgb[MAX_WIDTH][3];						\
d215 4
a218 3
         rgb[i][RCOMP] = texture[pos+2];				\
         rgb[i][GCOMP] = texture[pos+1];				\
         rgb[i][BCOMP] = texture[pos+0];				\
d220 1
a220 1
         span.array->mask[i] = 1;					\
d223 1
a223 1
         span.array->mask[i] = 0;					\
d229 2
a230 1
   rb->PutRowRGB(ctx, rb, span.end, span.x, span.y, rgb, span.array->mask);
d250 1
a250 1
static INLINE GLint
d256 1
a256 1
static INLINE GLint
d269 1
a269 1
static INLINE void
d546 2
d550 1
a550 1
   info.texture = (const GLchan *) texImg->Data;			\
d606 1
a606 1
static INLINE void
d681 7
a687 7
   tex_coord[0] = span->attrStart[FRAG_ATTRIB_TEX0][0]  * (info->smask + 1);
   tex_step[0] = span->attrStepX[FRAG_ATTRIB_TEX0][0] * (info->smask + 1);
   tex_coord[1] = span->attrStart[FRAG_ATTRIB_TEX0][1] * (info->tmask + 1);
   tex_step[1] = span->attrStepX[FRAG_ATTRIB_TEX0][1] * (info->tmask + 1);
   /* span->attrStart[FRAG_ATTRIB_TEX0][2] only if 3D-texturing, here only 2D */
   tex_coord[2] = span->attrStart[FRAG_ATTRIB_TEX0][3];
   tex_step[2] = span->attrStepX[FRAG_ATTRIB_TEX0][3];
d815 3
a817 1
   info.texture = (const GLchan *) texImg->Data;			\
d881 1
a881 1
#define NAME occlusion_zless_triangle
d884 2
a885 1
   struct gl_renderbuffer *rb = ctx->DrawBuffer->_DepthBuffer;		\
d890 1
d895 1
a895 1
   if (rb->Format == MESA_FORMAT_Z16) {					\
d898 1
a898 1
         rb->GetPointer(ctx, rb, span.x, span.y);			\
a905 11
   }									\
   else {								\
      GLuint i;								\
      const GLuint *zRow = (const GLuint *)				\
         rb->GetPointer(ctx, rb, span.x, span.y);			\
      for (i = 0; i < span.end; i++) {					\
         if ((GLuint)span.z < zRow[i]) {				\
            q->Result++;						\
         }								\
         span.z += span.zStep;						\
      }									\
d942 3
a944 3
   rSum = CHAN_TO_FLOAT(ncv0->color[0]) + ncv0->attrib[FRAG_ATTRIB_COL1][0];
   gSum = CHAN_TO_FLOAT(ncv0->color[1]) + ncv0->attrib[FRAG_ATTRIB_COL1][1];
   bSum = CHAN_TO_FLOAT(ncv0->color[2]) + ncv0->attrib[FRAG_ATTRIB_COL1][2];
d949 3
a951 3
   rSum = CHAN_TO_FLOAT(ncv1->color[0]) + ncv1->attrib[FRAG_ATTRIB_COL1][0];
   gSum = CHAN_TO_FLOAT(ncv1->color[1]) + ncv1->attrib[FRAG_ATTRIB_COL1][1];
   bSum = CHAN_TO_FLOAT(ncv1->color[2]) + ncv1->attrib[FRAG_ATTRIB_COL1][2];
d956 3
a958 3
   rSum = CHAN_TO_FLOAT(ncv2->color[0]) + ncv2->attrib[FRAG_ATTRIB_COL1][0];
   gSum = CHAN_TO_FLOAT(ncv2->color[1]) + ncv2->attrib[FRAG_ATTRIB_COL1][1];
   bSum = CHAN_TO_FLOAT(ncv2->color[2]) + ncv2->attrib[FRAG_ATTRIB_COL1][2];
d1012 2
d1026 3
a1028 1
          !ctx->Stencil._Enabled) {
d1033 1
a1033 1
            USE(occlusion_zless_triangle);
d1043 1
a1043 1
          ctx->FragmentProgram._Current ||
d1049 1
d1051 1
d1055 6
d1063 2
d1066 2
a1067 2
         minFilter = texObj2D ? texObj2D->Sampler.MinFilter : GL_NONE;
         magFilter = texObj2D ? texObj2D->Sampler.MagFilter : GL_NONE;
d1072 1
a1072 1
             && !ctx->FragmentProgram._Current
d1076 2
a1077 2
             && texObj2D->Sampler.WrapS == GL_REPEAT
             && texObj2D->Sampler.WrapT == GL_REPEAT
d1079 1
a1079 1
             && texImg->_IsPowerOfTwo
d1081 2
a1082 1
             && texImg->Width == texImg->RowStride
@


1.6
log
@Merge Mesa 7.10.3
@
text
@d37 2
a38 1
#include "main/texformat.h"
d543 1
a543 1
   info.filter = obj->MinFilter;					\
d808 1
a808 1
   info.filter = obj->MinFilter;					\
d1036 1
a1036 1
          NEED_SECONDARY_COLOR(ctx) ||
d1047 2
a1048 2
         minFilter = texObj2D ? texObj2D->MinFilter : GL_NONE;
         magFilter = texObj2D ? texObj2D->MagFilter : GL_NONE;
d1057 2
a1058 2
             && texObj2D->WrapS == GL_REPEAT
             && texObj2D->WrapT == GL_REPEAT
d1117 1
a1117 1
         ASSERT(!NEED_SECONDARY_COLOR(ctx));
@


1.5
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d38 1
a38 1
#include "shader/prog_instruction.h"
d52 1
a52 1
_swrast_culltriangle( GLcontext *ctx,
d259 1
a259 1
affine_span(GLcontext *ctx, SWspan *span,
d594 1
a594 1
fast_persp_span(GLcontext *ctx, SWspan *span,
d906 1
a906 1
nodraw_triangle( GLcontext *ctx,
d922 1
a922 1
_swrast_add_spec_terms_triangle(GLcontext *ctx, const SWvertex *v0,
d995 1
a995 1
_swrast_choose_triangle( GLcontext *ctx )
@


1.4
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d38 1
d47 3
a49 2
/*
 * Just used for feedback mode.
d57 1
d64 2
a65 2
   if (c * SWRAST_CONTEXT(ctx)->_BackfaceCullSign > 0)
      return 0;
d67 1
a67 1
   return 1;
a72 12
 * Render a smooth or flat-shaded color index triangle.
 */
#define NAME ci_triangle
#define INTERP_Z 1
#define INTERP_ATTRIBS 1  /* just for fog */
#define INTERP_INDEX 1
#define RENDER_SPAN( span )  _swrast_write_index_span(ctx, &span);
#include "s_tritemp.h"



/*
d125 1
a125 1
   struct gl_texture_object *obj = 					\
d127 9
a135 7
   const GLint b = obj->BaseLevel;					\
   const GLfloat twidth = (GLfloat) obj->Image[0][b]->Width;		\
   const GLfloat theight = (GLfloat) obj->Image[0][b]->Height;		\
   const GLint twidth_log2 = obj->Image[0][b]->WidthLog2;		\
   const GLchan *texture = (const GLchan *) obj->Image[0][b]->Data;	\
   const GLint smask = obj->Image[0][b]->Width - 1;			\
   const GLint tmask = obj->Image[0][b]->Height - 1;			\
d142 1
a142 1
   GLchan rgb[MAX_WIDTH][3];						\
d150 1
a150 1
      rgb[i][RCOMP] = texture[pos];					\
d152 1
a152 1
      rgb[i][BCOMP] = texture[pos+2];					\
d179 1
a179 1
   struct gl_texture_object *obj = 					\
d181 9
a189 7
   const GLint b = obj->BaseLevel;					\
   const GLfloat twidth = (GLfloat) obj->Image[0][b]->Width;		\
   const GLfloat theight = (GLfloat) obj->Image[0][b]->Height;		\
   const GLint twidth_log2 = obj->Image[0][b]->WidthLog2;		\
   const GLchan *texture = (const GLchan *) obj->Image[0][b]->Data;	\
   const GLint smask = obj->Image[0][b]->Width - 1;			\
   const GLint tmask = obj->Image[0][b]->Height - 1;			\
d196 1
a196 1
   GLchan rgb[MAX_WIDTH][3];						\
d206 1
a206 1
         rgb[i][RCOMP] = texture[pos];					\
d208 1
a208 1
         rgb[i][BCOMP] = texture[pos+2];				\
d263 1
a263 1
   const GLuint texEnableSave = ctx->Texture._EnabledUnits;
d271 5
a275 5
#define NEAREST_RGB			\
   sample[RCOMP] = tex00[RCOMP];	\
   sample[GCOMP] = tex00[GCOMP];	\
   sample[BCOMP] = tex00[BCOMP];	\
   sample[ACOMP] = CHAN_MAX
d278 1
a278 1
   sample[RCOMP] = ilerp_2d(sf, tf, tex00[0], tex01[0], tex10[0], tex11[0]);\
d280 1
a280 1
   sample[BCOMP] = ilerp_2d(sf, tf, tex00[2], tex01[2], tex10[2], tex11[2]);\
d283 5
a287 1
#define NEAREST_RGBA  COPY_CHAN4(sample, tex00)
d290 4
a293 4
   sample[RCOMP] = ilerp_2d(sf, tf, tex00[0], tex01[0], tex10[0], tex11[0]);\
   sample[GCOMP] = ilerp_2d(sf, tf, tex00[1], tex01[1], tex10[1], tex11[1]);\
   sample[BCOMP] = ilerp_2d(sf, tf, tex00[2], tex01[2], tex10[2], tex11[2]);\
   sample[ACOMP] = ilerp_2d(sf, tf, tex00[3], tex01[3], tex10[3], tex11[3])
d344 5
a348 1
#define NEAREST_RGBA_REPLACE  COPY_CHAN4(dest, tex00)
d402 1
a402 1
   ctx->Texture._EnabledUnits = 0x0;
d409 1
a409 1
      case GL_RGB:
d429 1
a429 1
      case GL_RGBA:
d458 1
a458 1
      case GL_RGB:
d478 1
a478 1
      case GL_RGBA:
d509 1
a509 1
   ctx->Texture._EnabledUnits = texEnableSave;
d531 1
a531 1
   struct gl_texture_object *obj = 					\
d533 9
a541 8
   const GLint b = obj->BaseLevel;					\
   const GLfloat twidth = (GLfloat) obj->Image[0][b]->Width;		\
   const GLfloat theight = (GLfloat) obj->Image[0][b]->Height;		\
   info.texture = (const GLchan *) obj->Image[0][b]->Data;		\
   info.twidth_log2 = obj->Image[0][b]->WidthLog2;			\
   info.smask = obj->Image[0][b]->Width - 1;				\
   info.tmask = obj->Image[0][b]->Height - 1;				\
   info.format = obj->Image[0][b]->_BaseFormat;				\
d544 3
d562 2
a563 7
   case GL_ALPHA:							\
   case GL_LUMINANCE:							\
   case GL_INTENSITY:							\
      info.tbytesline = obj->Image[0][b]->Width;			\
      break;								\
   case GL_LUMINANCE_ALPHA:						\
      info.tbytesline = obj->Image[0][b]->Width * 2;			\
d565 2
a566 5
   case GL_RGB:								\
      info.tbytesline = obj->Image[0][b]->Width * 3;			\
      break;								\
   case GL_RGBA:							\
      info.tbytesline = obj->Image[0][b]->Width * 4;			\
d572 1
a572 1
   info.tsize = obj->Image[0][b]->Height * info.tbytesline;
d665 2
a666 2
   const GLuint savedTexEnable = ctx->Texture._EnabledUnits;
   ctx->Texture._EnabledUnits = 0;
d679 1
a679 1
      case GL_RGB:
d699 1
a699 1
      case GL_RGBA:
d726 1
a726 1
      case GL_RGB:
d746 1
a746 1
      case GL_RGBA:
d779 1
a779 1
   ctx->Texture._EnabledUnits = savedTexEnable;
d798 1
a798 1
   struct gl_texture_object *obj = 					\
d800 7
a806 6
   const GLint b = obj->BaseLevel;					\
   info.texture = (const GLchan *) obj->Image[0][b]->Data;		\
   info.twidth_log2 = obj->Image[0][b]->WidthLog2;			\
   info.smask = obj->Image[0][b]->Width - 1;				\
   info.tmask = obj->Image[0][b]->Height - 1;				\
   info.format = obj->Image[0][b]->_BaseFormat;				\
d809 3
d826 2
a827 7
   case GL_ALPHA:							\
   case GL_LUMINANCE:							\
   case GL_INTENSITY:							\
      info.tbytesline = obj->Image[0][b]->Width;			\
      break;								\
   case GL_LUMINANCE_ALPHA:						\
      info.tbytesline = obj->Image[0][b]->Width * 2;			\
d829 2
a830 5
   case GL_RGB:								\
      info.tbytesline = obj->Image[0][b]->Width * 3;			\
      break;								\
   case GL_RGBA:							\
      info.tbytesline = obj->Image[0][b]->Width * 4;			\
d836 1
a836 1
   info.tsize = obj->Image[0][b]->Height * info.tbytesline;
d878 1
a878 1
   if (rb->DepthBits <= 16) {						\
a997 1
   const GLboolean rgbmode = ctx->Visual.rgbMode;
d1018 5
a1022 8
          !ctx->Stencil.Enabled) {
         if ((rgbmode &&
              ctx->Color.ColorMask[0] == 0 &&
              ctx->Color.ColorMask[1] == 0 &&
              ctx->Color.ColorMask[2] == 0 &&
              ctx->Color.ColorMask[3] == 0)
             ||
             (!rgbmode && ctx->Color.IndexMask == 0)) {
a1027 5
      if (!rgbmode) {
         USE(ci_triangle);
         return;
      }

d1041 1
a1041 1
         GLint format;
d1045 3
a1047 3
         format = texImg ? texImg->TexFormat->MesaFormat : -1;
         minFilter = texObj2D ? texObj2D->MinFilter : (GLenum) 0;
         magFilter = texObj2D ? texObj2D->MagFilter : (GLenum) 0;
d1054 1
d1058 1
d1062 1
a1062 1
             && (format == MESA_FORMAT_RGB || format == MESA_FORMAT_RGBA)
d1066 2
a1067 1
             && ctx->Texture.Unit[0].EnvMode != GL_COMBINE_EXT) {
d1070 1
a1070 1
		   && format == MESA_FORMAT_RGB
d1089 9
a1097 1
                  USE(affine_textured_triangle);
@


1.3
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d3 1
a3 1
 * Version:  6.5.3
d32 6
a37 6
#include "glheader.h"
#include "context.h"
#include "colormac.h"
#include "imports.h"
#include "macros.h"
#include "texformat.h"
d134 2
a135 1
   struct gl_texture_object *obj = ctx->Texture.Unit[0].Current2D;	\
d186 2
a187 1
   struct gl_texture_object *obj = ctx->Texture.Unit[0].Current2D;	\
d268 1
d398 3
d502 1
d505 3
d528 2
a529 1
   struct gl_texture_object *obj = unit->Current2D;			\
d799 2
a800 1
   const struct gl_texture_object *obj = unit->Current2D;		\
d1056 2
a1057 1
         texObj2D = ctx->Texture.Unit[0].Current2D;
@


1.2
log
@Update to Mesa 7.0.3. tested my oga@@ and johan@@
@
text
@d55 4
a58 4
   GLfloat ex = v1->win[0] - v0->win[0];
   GLfloat ey = v1->win[1] - v0->win[1];
   GLfloat fx = v2->win[0] - v0->win[0];
   GLfloat fy = v2->win[1] - v0->win[1];
d74 1
a74 1
#define INTERP_FOG 1
a85 1
#define INTERP_FOG 1
a107 1
#define INTERP_FOG 1
d133 1
a133 1
   struct gl_renderbuffer *rb = ctx->DrawBuffer->_ColorDrawBuffers[0][0];\
d142 1
a142 2
   if (!texture) {							\
      /* this shouldn't happen */					\
d184 1
a184 1
   struct gl_renderbuffer *rb = ctx->DrawBuffer->_ColorDrawBuffers[0][0];\
d193 1
a193 2
   if (!texture) {							\
      /* this shouldn't happen */					\
a226 1

a508 1
#define INTERP_FOG 1
a780 2
#define INTERP_W 1
#define INTERP_FOG 1
d838 1
a839 3
#endif /* CHAN_BITS != GL_FLOAT */

                
a846 2
#define INTERP_W 1
#define INTERP_FOG 1
a847 1
#define INTERP_SPEC 1
d914 3
a916 4
void _swrast_add_spec_terms_triangle( GLcontext *ctx,
				      const SWvertex *v0,
				      const SWvertex *v1,
				      const SWvertex *v2 )
a920 1
#if CHAN_TYPE == GL_FLOAT
d922 2
a923 4
#else
   GLint rSum, gSum, bSum;
#endif
   GLchan c[3][4];
d925 3
a927 3
   COPY_CHAN4( c[0], ncv0->color );
   COPY_CHAN4( c[1], ncv1->color );
   COPY_CHAN4( c[2], ncv2->color );
d929 6
a934 6
   rSum = ncv0->color[0] + ncv0->specular[0];
   gSum = ncv0->color[1] + ncv0->specular[1];
   bSum = ncv0->color[2] + ncv0->specular[2];
   ncv0->color[0] = MIN2(rSum, CHAN_MAX);
   ncv0->color[1] = MIN2(gSum, CHAN_MAX);
   ncv0->color[2] = MIN2(bSum, CHAN_MAX);
d936 6
a941 6
   rSum = ncv1->color[0] + ncv1->specular[0];
   gSum = ncv1->color[1] + ncv1->specular[1];
   bSum = ncv1->color[2] + ncv1->specular[2];
   ncv1->color[0] = MIN2(rSum, CHAN_MAX);
   ncv1->color[1] = MIN2(gSum, CHAN_MAX);
   ncv1->color[2] = MIN2(bSum, CHAN_MAX);
d943 6
a948 6
   rSum = ncv2->color[0] + ncv2->specular[0];
   gSum = ncv2->color[1] + ncv2->specular[1];
   bSum = ncv2->color[2] + ncv2->specular[2];
   ncv2->color[0] = MIN2(rSum, CHAN_MAX);
   ncv2->color[1] = MIN2(gSum, CHAN_MAX);
   ncv2->color[2] = MIN2(bSum, CHAN_MAX);
d952 3
a954 3
   COPY_CHAN4( ncv0->color, c[0] );
   COPY_CHAN4( ncv1->color, c[1] );
   COPY_CHAN4( ncv2->color, c[2] );
d1030 4
d1036 3
a1038 1
          ctx->ATIFragmentShader._Enabled) {
d1064 1
d1084 1
a1084 1
#if (CHAN_BITS == 16 || CHAN_BITS == 32)
d1092 1
a1092 1
#if (CHAN_BITS == 16 || CHAN_BITS == 32)
d1105 2
a1106 1
         ASSERT(!ctx->Texture._EnabledCoordUnits);
d1109 5
a1113 1
            USE(smooth_rgba_triangle);
d1117 3
d1121 1
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * Version:  6.5
d5 1
a5 1
 * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
d61 1
a61 1
   if (c * SWRAST_CONTEXT(ctx)->_BackfaceSign > 0)
d70 1
a70 1
 * Render a flat-shaded color index triangle.
d72 1
a72 16
#define NAME flat_ci_triangle
#define INTERP_Z 1
#define INTERP_FOG 1
#define SETUP_CODE			\
   span.interpMask |= SPAN_INDEX;	\
   span.index = FloatToFixed(v2->index);\
   span.indexStep = 0;
#define RENDER_SPAN( span )  _swrast_write_index_span(ctx, &span);
#include "s_tritemp.h"



/*
 * Render a smooth-shaded color index triangle.
 */
#define NAME smooth_ci_triangle
d127 1
a127 1
 * No fog.
d151 1
d159 3
a161 3
      span.array->rgb[i][RCOMP] = texture[pos];				\
      span.array->rgb[i][GCOMP] = texture[pos+1];			\
      span.array->rgb[i][BCOMP] = texture[pos+2];			\
d165 1
a165 1
   rb->PutRowRGB(ctx, rb, span.end, span.x, span.y, span.array->rgb, NULL);
d203 1
d213 3
a215 3
         span.array->rgb[i][RCOMP] = texture[pos];			\
         span.array->rgb[i][GCOMP] = texture[pos+1];			\
         span.array->rgb[i][BCOMP] = texture[pos+2];			\
d226 1
a226 2
   rb->PutRowRGB(ctx, rb, span.end, span.x, span.y,			\
                 span.array->rgb, span.array->mask);
d267 1
a267 1
affine_span(GLcontext *ctx, struct sw_span *span,
d590 1
a590 1
fast_persp_span(GLcontext *ctx, struct sw_span *span,
d664 7
a670 7
   tex_coord[0] = span->tex[0][0]  * (info->smask + 1);
   tex_step[0] = span->texStepX[0][0] * (info->smask + 1);
   tex_coord[1] = span->tex[0][1] * (info->tmask + 1);
   tex_step[1] = span->texStepX[0][1] * (info->tmask + 1);
   /* span->tex[0][2] only if 3D-texturing, here only 2D */
   tex_coord[2] = span->tex[0][3];
   tex_step[2] = span->texStepX[0][3];
d791 1
a791 1
#define INTERP_TEX 1
d853 1
a853 2
 * Render a smooth-shaded, textured, RGBA triangle.
 * Interpolate S,T,R with perspective correction, w/out mipmapping.
d855 1
a855 1
#define NAME general_textured_triangle
d862 1
a862 1
#define INTERP_TEX 1
a867 18
/*
 * This is the big one!
 * Interpolate Z, RGB, Alpha, specular, fog, N sets of texture coordinates, and varying floats.
 * Yup, it's slow.
 */
#define NAME multitextured_triangle
#define INTERP_Z 1
#define INTERP_W 1
#define INTERP_FOG 1
#define INTERP_RGB 1
#define INTERP_ALPHA 1
#define INTERP_SPEC 1
#define INTERP_MULTITEX 1
#define INTERP_VARYING 1
#define RENDER_SPAN( span )   _swrast_write_rgba_span(ctx, &span);
#include "s_tritemp.h"


d1042 8
a1049 2
      if (ctx->Texture._EnabledCoordUnits || ctx->FragmentProgram._Active ||
          ctx->ATIFragmentShader._Enabled || ctx->ShaderObjects._FragmentShaderPresent) {
d1064 1
a1064 1
             && !ctx->FragmentProgram._Active
a1065 1
             && !ctx->ShaderObjects._FragmentShaderPresent
d1095 1
a1095 1
                  USE(general_textured_triangle);
d1103 1
a1103 1
               USE(general_textured_triangle);
d1111 1
a1111 6
            if (ctx->Texture._EnabledCoordUnits > 1) {
               USE(multitextured_triangle);
            }
            else {
               USE(general_textured_triangle);
            }
d1118 1
a1118 6
            if (rgbmode) {
	       USE(smooth_rgba_triangle);
            }
            else {
               USE(smooth_ci_triangle);
            }
d1122 1
a1122 6
            if (rgbmode) {
	       USE(flat_rgba_triangle);
            }
            else {
               USE(flat_ci_triangle);
            }
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d3 1
a3 1
 * Version:  6.5.2
a165 1
   GLchan rgb[MAX_WIDTH][3];						\
d173 3
a175 3
      rgb[i][RCOMP] = texture[pos];					\
      rgb[i][GCOMP] = texture[pos+1];					\
      rgb[i][BCOMP] = texture[pos+2];					\
d179 1
a179 1
   rb->PutRowRGB(ctx, rb, span.end, span.x, span.y, rgb, NULL);
a216 1
   GLchan rgb[MAX_WIDTH][3];						\
d226 3
a228 3
         rgb[i][RCOMP] = texture[pos];					\
         rgb[i][GCOMP] = texture[pos+1];				\
         rgb[i][BCOMP] = texture[pos+2];				\
d239 2
a240 1
   rb->PutRowRGB(ctx, rb, span.end, span.x, span.y, rgb, span.array->mask);
d281 1
a281 1
affine_span(GLcontext *ctx, SWspan *span,
d604 1
a604 1
fast_persp_span(GLcontext *ctx, SWspan *span,
d1075 1
a1075 1
      if (ctx->Texture._EnabledCoordUnits || ctx->FragmentProgram._Enabled ||
d1091 1
a1091 1
             && !ctx->FragmentProgram._Enabled
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d3 1
a3 1
 * Version:  6.5.3
d5 1
a5 1
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
d70 1
a70 1
 * Render a smooth or flat-shaded color index triangle.
d72 16
a87 1
#define NAME ci_triangle
d142 1
a142 1
 * No fog.  No depth testing.
d679 7
a685 7
   tex_coord[0] = span->attrStart[FRAG_ATTRIB_TEX0][0]  * (info->smask + 1);
   tex_step[0] = span->attrStepX[FRAG_ATTRIB_TEX0][0] * (info->smask + 1);
   tex_coord[1] = span->attrStart[FRAG_ATTRIB_TEX0][1] * (info->tmask + 1);
   tex_step[1] = span->attrStepX[FRAG_ATTRIB_TEX0][1] * (info->tmask + 1);
   /* span->attrStart[FRAG_ATTRIB_TEX0][2] only if 3D-texturing, here only 2D */
   tex_coord[2] = span->attrStart[FRAG_ATTRIB_TEX0][3];
   tex_step[2] = span->attrStepX[FRAG_ATTRIB_TEX0][3];
d806 1
a806 1
#define INTERP_ATTRIBS 1
d868 2
a869 1
 * Render an RGBA triangle with arbitrary attributes.
d871 1
a871 1
#define NAME general_triangle
d878 1
a878 1
#define INTERP_ATTRIBS 1
d884 18
d1076 2
a1077 8
      if (!rgbmode) {
         USE(ci_triangle);
         return;
      }

      if (ctx->Texture._EnabledCoordUnits ||
          ctx->FragmentProgram._Current ||
          ctx->ATIFragmentShader._Enabled) {
d1092 1
a1092 1
             && !ctx->FragmentProgram._Current
d1094 1
d1124 1
a1124 1
                  USE(general_triangle);
d1132 1
a1132 1
               USE(general_triangle);
d1140 6
a1145 1
            USE(general_triangle);
d1152 6
a1157 1
            USE(smooth_rgba_triangle);
d1161 6
a1166 1
            USE(flat_rgba_triangle);
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d3 1
a3 1
 * Version:  7.3
d32 6
a37 7
#include "main/glheader.h"
#include "main/context.h"
#include "main/colormac.h"
#include "main/imports.h"
#include "main/macros.h"
#include "main/texformat.h"
#include "program/prog_instruction.h"
d46 2
a47 3
/**
 * Test if a triangle should be culled.  Used for feedback and selection mode.
 * \return GL_TRUE if the triangle is to be culled, GL_FALSE otherwise.
d50 1
a50 1
_swrast_culltriangle( struct gl_context *ctx,
d55 4
a58 5
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
   GLfloat ex = v1->attrib[FRAG_ATTRIB_WPOS][0] - v0->attrib[FRAG_ATTRIB_WPOS][0];
   GLfloat ey = v1->attrib[FRAG_ATTRIB_WPOS][1] - v0->attrib[FRAG_ATTRIB_WPOS][1];
   GLfloat fx = v2->attrib[FRAG_ATTRIB_WPOS][0] - v0->attrib[FRAG_ATTRIB_WPOS][0];
   GLfloat fy = v2->attrib[FRAG_ATTRIB_WPOS][1] - v0->attrib[FRAG_ATTRIB_WPOS][1];
d61 2
a62 2
   if (c * swrast->_BackfaceSign * swrast->_BackfaceCullSign <= 0.0F)
      return GL_FALSE;
d64 1
a64 1
   return GL_TRUE;
d70 12
d86 1
d109 1
d135 11
a145 13
   struct gl_renderbuffer *rb = ctx->DrawBuffer->_ColorDrawBuffers[0];	\
   const struct gl_texture_object *obj = 				\
      ctx->Texture.Unit[0].CurrentTex[TEXTURE_2D_INDEX];		\
   const struct gl_texture_image *texImg =				\
      obj->Image[0][obj->BaseLevel];					\
   const GLfloat twidth = (GLfloat) texImg->Width;			\
   const GLfloat theight = (GLfloat) texImg->Height;			\
   const GLint twidth_log2 = texImg->WidthLog2;				\
   const GLubyte *texture = (const GLubyte *) texImg->Data;		\
   const GLint smask = texImg->Width - 1;				\
   const GLint tmask = texImg->Height - 1;				\
   ASSERT(texImg->TexFormat == MESA_FORMAT_RGB888);			\
   if (!rb || !texture) {						\
d151 1
a151 1
   GLubyte rgb[MAX_WIDTH][3];						\
d159 1
a159 1
      rgb[i][RCOMP] = texture[pos+2];					\
d161 1
a161 1
      rgb[i][BCOMP] = texture[pos+0];					\
d187 11
a197 13
   struct gl_renderbuffer *rb = ctx->DrawBuffer->_ColorDrawBuffers[0];	\
   const struct gl_texture_object *obj = 				\
      ctx->Texture.Unit[0].CurrentTex[TEXTURE_2D_INDEX];		\
   const struct gl_texture_image *texImg = 				\
       obj->Image[0][obj->BaseLevel]; 					\
   const GLfloat twidth = (GLfloat) texImg->Width;			\
   const GLfloat theight = (GLfloat) texImg->Height;			\
   const GLint twidth_log2 = texImg->WidthLog2;				\
   const GLubyte *texture = (const GLubyte *) texImg->Data;		\
   const GLint smask = texImg->Width - 1;				\
   const GLint tmask = texImg->Height - 1;				\
   ASSERT(texImg->TexFormat == MESA_FORMAT_RGB888);			\
   if (!rb || !texture) {						\
d203 1
a203 1
   GLubyte rgb[MAX_WIDTH][3];						\
d213 1
a213 1
         rgb[i][RCOMP] = texture[pos+2];				\
d215 1
a215 1
         rgb[i][BCOMP] = texture[pos+0];				\
d231 1
d267 1
a267 1
affine_span(struct gl_context *ctx, SWspan *span,
a270 1
   const GLuint texEnableSave = ctx->Texture._EnabledCoordUnits;
d278 5
a282 5
#define NEAREST_RGB		\
   sample[RCOMP] = tex00[2];	\
   sample[GCOMP] = tex00[1];	\
   sample[BCOMP] = tex00[0];	\
   sample[ACOMP] = CHAN_MAX;
d285 1
a285 1
   sample[RCOMP] = ilerp_2d(sf, tf, tex00[2], tex01[2], tex10[2], tex11[2]);\
d287 1
a287 1
   sample[BCOMP] = ilerp_2d(sf, tf, tex00[0], tex01[0], tex10[0], tex11[0]);\
d290 1
a290 5
#define NEAREST_RGBA  \
   sample[RCOMP] = tex00[3];	\
   sample[GCOMP] = tex00[2];	\
   sample[BCOMP] = tex00[1];	\
   sample[ACOMP] = tex00[0];
d293 4
a296 4
   sample[RCOMP] = ilerp_2d(sf, tf, tex00[3], tex01[3], tex10[3], tex11[3]);\
   sample[GCOMP] = ilerp_2d(sf, tf, tex00[2], tex01[2], tex10[2], tex11[2]);\
   sample[BCOMP] = ilerp_2d(sf, tf, tex00[1], tex01[1], tex10[1], tex11[1]);\
   sample[ACOMP] = ilerp_2d(sf, tf, tex00[0], tex01[0], tex10[0], tex11[0])
d347 1
a347 5
#define NEAREST_RGBA_REPLACE  \
   dest[RCOMP] = tex00[3]; \
   dest[GCOMP] = tex00[2]; \
   dest[BCOMP] = tex00[1]; \
   dest[ACOMP] = tex00[0]
a399 3
   /* Disable tex units so they're not re-applied in swrast_write_rgba_span */
   ctx->Texture._EnabledCoordUnits = 0x0;

d405 1
a405 1
      case MESA_FORMAT_RGB888:
d425 1
a425 1
      case MESA_FORMAT_RGBA8888:
d454 1
a454 1
      case MESA_FORMAT_RGB888:
d474 1
a474 1
      case MESA_FORMAT_RGBA8888:
a500 1

a502 3
   /* re-enable texture units */
   ctx->Texture._EnabledCoordUnits = texEnableSave;

d514 1
d524 9
a532 11
   const struct gl_texture_object *obj = 				\
      ctx->Texture.Unit[0].CurrentTex[TEXTURE_2D_INDEX];		\
   const struct gl_texture_image *texImg = 				\
      obj->Image[0][obj->BaseLevel]; 					\
   const GLfloat twidth = (GLfloat) texImg->Width;			\
   const GLfloat theight = (GLfloat) texImg->Height;			\
   info.texture = (const GLchan *) texImg->Data;			\
   info.twidth_log2 = texImg->WidthLog2;				\
   info.smask = texImg->Width - 1;					\
   info.tmask = texImg->Height - 1;					\
   info.format = texImg->TexFormat;					\
a534 3
   info.er = 0;					\
   info.eg = 0;					\
   info.eb = 0;					\
d550 7
a556 2
   case MESA_FORMAT_RGB888:						\
      info.tbytesline = texImg->Width * 3;				\
d558 5
a562 2
   case MESA_FORMAT_RGBA8888:						\
      info.tbytesline = texImg->Width * 4;				\
d568 1
a568 1
   info.tsize = texImg->Height * info.tbytesline;
d590 1
a590 1
fast_persp_span(struct gl_context *ctx, SWspan *span,
d661 2
a662 2
   const GLuint texEnableSave = ctx->Texture._EnabledCoordUnits;
   ctx->Texture._EnabledCoordUnits = 0;
d675 1
a675 1
      case MESA_FORMAT_RGB888:
d695 1
a695 1
      case MESA_FORMAT_RGBA8888:
d722 1
a722 1
      case MESA_FORMAT_RGB888:
d742 1
a742 1
      case MESA_FORMAT_RGBA8888:
d775 1
a775 1
   ctx->Texture._EnabledCoordUnits = texEnableSave;
d787 2
d796 7
a802 9
   const struct gl_texture_object *obj = 				\
      ctx->Texture.Unit[0].CurrentTex[TEXTURE_2D_INDEX];		\
   const struct gl_texture_image *texImg = 				\
      obj->Image[0][obj->BaseLevel];			 		\
   info.texture = (const GLchan *) texImg->Data;			\
   info.twidth_log2 = texImg->WidthLog2;				\
   info.smask = texImg->Width - 1;					\
   info.tmask = texImg->Height - 1;					\
   info.format = texImg->TexFormat;					\
a804 3
   info.er = 0;					\
   info.eg = 0;					\
   info.eb = 0;					\
d819 10
a828 2
   case MESA_FORMAT_RGB888:						\
      info.tbytesline = texImg->Width * 3;				\
d830 2
a831 2
   case MESA_FORMAT_RGBA8888:						\
      info.tbytesline = texImg->Width * 4;				\
d837 1
a837 1
   info.tsize = texImg->Height * info.tbytesline;
a845 1
#endif /*CHAN_TYPE != GL_FLOAT*/
d847 3
d857 2
d860 1
d884 1
a884 1
   if (rb->Format == MESA_FORMAT_Z16) {					\
d912 1
a912 1
nodraw_triangle( struct gl_context *ctx,
d927 4
a930 3
void
_swrast_add_spec_terms_triangle(struct gl_context *ctx, const SWvertex *v0,
                                const SWvertex *v1, const SWvertex *v2)
d935 1
d937 4
a940 2
   GLchan cSave[3][4];

d942 3
a944 3
   COPY_CHAN4( cSave[0], ncv0->color );
   COPY_CHAN4( cSave[1], ncv1->color );
   COPY_CHAN4( cSave[2], ncv2->color );
d946 6
a951 6
   rSum = CHAN_TO_FLOAT(ncv0->color[0]) + ncv0->attrib[FRAG_ATTRIB_COL1][0];
   gSum = CHAN_TO_FLOAT(ncv0->color[1]) + ncv0->attrib[FRAG_ATTRIB_COL1][1];
   bSum = CHAN_TO_FLOAT(ncv0->color[2]) + ncv0->attrib[FRAG_ATTRIB_COL1][2];
   UNCLAMPED_FLOAT_TO_CHAN(ncv0->color[0], rSum);
   UNCLAMPED_FLOAT_TO_CHAN(ncv0->color[1], gSum);
   UNCLAMPED_FLOAT_TO_CHAN(ncv0->color[2], bSum);
d953 6
a958 6
   rSum = CHAN_TO_FLOAT(ncv1->color[0]) + ncv1->attrib[FRAG_ATTRIB_COL1][0];
   gSum = CHAN_TO_FLOAT(ncv1->color[1]) + ncv1->attrib[FRAG_ATTRIB_COL1][1];
   bSum = CHAN_TO_FLOAT(ncv1->color[2]) + ncv1->attrib[FRAG_ATTRIB_COL1][2];
   UNCLAMPED_FLOAT_TO_CHAN(ncv1->color[0], rSum);
   UNCLAMPED_FLOAT_TO_CHAN(ncv1->color[1], gSum);
   UNCLAMPED_FLOAT_TO_CHAN(ncv1->color[2], bSum);
d960 6
a965 6
   rSum = CHAN_TO_FLOAT(ncv2->color[0]) + ncv2->attrib[FRAG_ATTRIB_COL1][0];
   gSum = CHAN_TO_FLOAT(ncv2->color[1]) + ncv2->attrib[FRAG_ATTRIB_COL1][1];
   bSum = CHAN_TO_FLOAT(ncv2->color[2]) + ncv2->attrib[FRAG_ATTRIB_COL1][2];
   UNCLAMPED_FLOAT_TO_CHAN(ncv2->color[0], rSum);
   UNCLAMPED_FLOAT_TO_CHAN(ncv2->color[1], gSum);
   UNCLAMPED_FLOAT_TO_CHAN(ncv2->color[2], bSum);
d969 3
a971 3
   COPY_CHAN4( ncv0->color, cSave[0] );
   COPY_CHAN4( ncv1->color, cSave[1] );
   COPY_CHAN4( ncv2->color, cSave[2] );
d1005 1
a1005 1
_swrast_choose_triangle( struct gl_context *ctx )
d1008 1
d1029 8
a1036 5
          !ctx->Stencil._Enabled) {
         if (ctx->Color.ColorMask[0][0] == 0 &&
	     ctx->Color.ColorMask[0][1] == 0 &&
	     ctx->Color.ColorMask[0][2] == 0 &&
	     ctx->Color.ColorMask[0][3] == 0) {
d1042 5
a1046 4
      /*
       * XXX should examine swrast->_ActiveAttribMask to determine what
       * needs to be interpolated.
       */
d1049 1
a1049 3
          ctx->ATIFragmentShader._Enabled ||
          NEED_SECONDARY_COLOR(ctx) ||
          swrast->_FogEnabled) {
d1054 2
a1055 3
         gl_format format;
         texObj2D = ctx->Texture.Unit[0].CurrentTex[TEXTURE_2D_INDEX];

d1057 3
a1059 3
         format = texImg ? texImg->TexFormat : MESA_FORMAT_NONE;
         minFilter = texObj2D ? texObj2D->MinFilter : GL_NONE;
         magFilter = texObj2D ? texObj2D->MagFilter : GL_NONE;
a1065 1
             && ctx->Texture._EnabledUnits == 0x1
a1068 1
             && texObj2D->_Swizzle == SWIZZLE_NOOP
d1072 1
a1072 1
             && (format == MESA_FORMAT_RGB888 || format == MESA_FORMAT_RGBA8888)
d1075 1
a1075 3
             && !swrast->_FogEnabled
             && ctx->Texture.Unit[0].EnvMode != GL_COMBINE_EXT
             && ctx->Texture.Unit[0].EnvMode != GL_COMBINE4_NV) {
d1078 1
a1078 1
		   && format == MESA_FORMAT_RGB888
d1094 1
a1094 1
#if CHAN_BITS != 8
d1097 1
a1097 9
                  if (format == MESA_FORMAT_RGBA8888 && !_mesa_little_endian()) {
                     /* We only handle RGBA8888 correctly on little endian
                      * in the optimized code above.
                      */
                     USE(general_triangle);
                  }
                  else {
                     USE(affine_textured_triangle);
                 }
d1102 1
a1102 1
#if CHAN_BITS != 8
d1115 1
a1115 2
         ASSERT(!swrast->_FogEnabled);
         ASSERT(!NEED_SECONDARY_COLOR(ctx));
d1118 1
a1118 5
#if CHAN_BITS != 8
               USE(general_triangle);
#else
               USE(smooth_rgba_triangle);
#endif
a1121 3
#if CHAN_BITS != 8
            USE(general_triangle);
#else
a1122 1
#endif
@


1.1.1.5
log
@Import Mesa 9.2.0
@
text
@d3 1
d20 3
a22 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
d37 1
a37 3
#include "main/mtypes.h"
#include "main/state.h"
#include "main/samplerobj.h"
d58 4
a61 4
   GLfloat ex = v1->attrib[VARYING_SLOT_POS][0] - v0->attrib[VARYING_SLOT_POS][0];
   GLfloat ey = v1->attrib[VARYING_SLOT_POS][1] - v0->attrib[VARYING_SLOT_POS][1];
   GLfloat fx = v2->attrib[VARYING_SLOT_POS][0] - v0->attrib[VARYING_SLOT_POS][0];
   GLfloat fy = v2->attrib[VARYING_SLOT_POS][1] - v0->attrib[VARYING_SLOT_POS][1];
a128 2
   const struct swrast_texture_image *swImg =				\
      swrast_texture_image_const(texImg);				\
d132 1
a132 1
   const GLubyte *texture = (const GLubyte *) swImg->ImageSlices[0];	\
d142 1
a142 1
   GLubyte (*rgba)[4] = swrast->SpanArrays->rgba8;			\
d150 3
a152 4
      rgba[i][RCOMP] = texture[pos+2];					\
      rgba[i][GCOMP] = texture[pos+1];					\
      rgba[i][BCOMP] = texture[pos+0];					\
      rgba[i][ACOMP] = 0xff;                                            \
d156 1
a156 2
   _swrast_put_row(ctx, rb, GL_UNSIGNED_BYTE, span.end,                 \
                   span.x, span.y, rgba, NULL);
a182 2
   const struct swrast_texture_image *swImg =				\
      swrast_texture_image_const(texImg);				\
d186 1
a186 1
   const GLubyte *texture = (const GLubyte *) swImg->ImageSlices[0];	\
d196 1
a196 2
   GLubyte (*rgba)[4] = swrast->SpanArrays->rgba8;			\
   GLubyte *mask = swrast->SpanArrays->mask;                            \
d206 3
a208 4
         rgba[i][RCOMP] = texture[pos+2];				\
         rgba[i][GCOMP] = texture[pos+1];				\
         rgba[i][BCOMP] = texture[pos+0];				\
         rgba[i][ACOMP] = 0xff;          				\
d210 1
a210 1
         mask[i] = 1;							\
d213 1
a213 1
         mask[i] = 0;							\
d219 1
a219 2
   _swrast_put_row(ctx, rb, GL_UNSIGNED_BYTE,                           \
                   span.end, span.x, span.y, rgba, mask);
d239 1
a239 1
static inline GLint
d245 1
a245 1
static inline GLint
d258 1
a258 1
static inline void
a534 2
   const struct swrast_texture_image *swImg =				\
      swrast_texture_image_const(texImg);				\
d537 1
a537 1
   info.texture = (const GLchan *) swImg->ImageSlices[0];		\
d542 1
a542 1
   info.filter = obj->Sampler.MinFilter;				\
d593 1
a593 1
static inline void
d668 7
a674 7
   tex_coord[0] = span->attrStart[VARYING_SLOT_TEX0][0]  * (info->smask + 1);
   tex_step[0] = span->attrStepX[VARYING_SLOT_TEX0][0] * (info->smask + 1);
   tex_coord[1] = span->attrStart[VARYING_SLOT_TEX0][1] * (info->tmask + 1);
   tex_step[1] = span->attrStepX[VARYING_SLOT_TEX0][1] * (info->tmask + 1);
   /* span->attrStart[VARYING_SLOT_TEX0][2] only if 3D-texturing, here only 2D */
   tex_coord[2] = span->attrStart[VARYING_SLOT_TEX0][3];
   tex_step[2] = span->attrStepX[VARYING_SLOT_TEX0][3];
d802 1
a802 3
   const struct swrast_texture_image *swImg =				\
      swrast_texture_image_const(texImg);				\
   info.texture = (const GLchan *) swImg->ImageSlices[0];		\
d807 1
a807 1
   info.filter = obj->Sampler.MinFilter;				\
d866 1
a866 1
#define NAME occlusion_zless_16_triangle
d869 1
a869 2
   struct gl_renderbuffer *rb =                                         \
      ctx->DrawBuffer->Attachment[BUFFER_DEPTH].Renderbuffer;           \
a873 1
   assert(rb->Format == MESA_FORMAT_Z16);                               \
d878 1
a878 1
   {                                                                    \
d881 1
a881 1
         _swrast_pixel_address(rb, span.x, span.y);                     \
d889 11
d936 3
a938 3
   rSum = CHAN_TO_FLOAT(ncv0->color[0]) + ncv0->attrib[VARYING_SLOT_COL1][0];
   gSum = CHAN_TO_FLOAT(ncv0->color[1]) + ncv0->attrib[VARYING_SLOT_COL1][1];
   bSum = CHAN_TO_FLOAT(ncv0->color[2]) + ncv0->attrib[VARYING_SLOT_COL1][2];
d943 3
a945 3
   rSum = CHAN_TO_FLOAT(ncv1->color[0]) + ncv1->attrib[VARYING_SLOT_COL1][0];
   gSum = CHAN_TO_FLOAT(ncv1->color[1]) + ncv1->attrib[VARYING_SLOT_COL1][1];
   bSum = CHAN_TO_FLOAT(ncv1->color[2]) + ncv1->attrib[VARYING_SLOT_COL1][2];
d950 3
a952 3
   rSum = CHAN_TO_FLOAT(ncv2->color[0]) + ncv2->attrib[VARYING_SLOT_COL1][0];
   gSum = CHAN_TO_FLOAT(ncv2->color[1]) + ncv2->attrib[VARYING_SLOT_COL1][1];
   bSum = CHAN_TO_FLOAT(ncv2->color[2]) + ncv2->attrib[VARYING_SLOT_COL1][2];
a1005 2
      struct gl_renderbuffer *depthRb =
         ctx->DrawBuffer->Attachment[BUFFER_DEPTH].Renderbuffer;
d1018 1
a1018 3
          !ctx->Stencil._Enabled &&
          depthRb &&
          depthRb->Format == MESA_FORMAT_Z16) {
d1023 1
a1023 1
            USE(occlusion_zless_16_triangle);
d1033 1
a1033 1
	  _swrast_use_fragment_program(ctx) ||
d1035 1
a1035 1
          _mesa_need_secondary_color(ctx) ||
a1038 1
         const struct gl_sampler_object *samp;
a1039 1
         const struct swrast_texture_image *swImg;
a1042 6
         if (ctx->Texture.Unit[0].Sampler)
            samp = ctx->Texture.Unit[0].Sampler;
         else if (texObj2D)
            samp = &texObj2D->Sampler;
         else
            samp = NULL;
a1044 2
         swImg = swrast_texture_image_const(texImg);

d1046 2
a1047 2
         minFilter = texObj2D ? samp->MinFilter : GL_NONE;
         magFilter = texObj2D ? samp->MagFilter : GL_NONE;
d1052 1
a1052 1
             && !_swrast_use_fragment_program(ctx)
d1056 2
a1057 2
             && samp->WrapS == GL_REPEAT
             && samp->WrapT == GL_REPEAT
d1059 1
a1059 1
             && swImg->_IsPowerOfTwo
d1061 1
a1061 2
             && (_mesa_format_row_stride(format, texImg->Width) ==
                 swImg->RowStride)
d1116 1
a1116 1
         ASSERT(!_mesa_need_secondary_color(ctx));
@


1.1.1.6
log
@Import Mesa 10.2.3
@
text
@d139 1
a139 1
   ASSERT(texImg->TexFormat == MESA_FORMAT_BGR_UNORM8);			\
d197 1
a197 1
   ASSERT(texImg->TexFormat == MESA_FORMAT_BGR_UNORM8);			\
d420 1
a420 1
      case MESA_FORMAT_BGR_UNORM8:
d440 1
a440 1
      case MESA_FORMAT_A8B8G8R8_UNORM:
d469 1
a469 1
      case MESA_FORMAT_BGR_UNORM8:
d489 1
a489 1
      case MESA_FORMAT_A8B8G8R8_UNORM:
d575 1
a575 1
   case MESA_FORMAT_BGR_UNORM8:						\
d578 1
a578 1
   case MESA_FORMAT_A8B8G8R8_UNORM:						\
d692 1
a692 1
      case MESA_FORMAT_BGR_UNORM8:
d712 1
a712 1
      case MESA_FORMAT_A8B8G8R8_UNORM:
d739 1
a739 1
      case MESA_FORMAT_BGR_UNORM8:
d759 1
a759 1
      case MESA_FORMAT_A8B8G8R8_UNORM:
d841 1
a841 1
   case MESA_FORMAT_BGR_UNORM8:						\
d844 1
a844 1
   case MESA_FORMAT_A8B8G8R8_UNORM:						\
d890 1
a890 1
   assert(rb->Format == MESA_FORMAT_Z_UNORM16);                               \
d1028 1
a1028 1
          depthRb->Format == MESA_FORMAT_Z_UNORM16) {
d1053 1
a1053 1
         mesa_format format;
d1074 2
a1075 2
             && ctx->Texture._MaxEnabledTexImageUnit == 0
             && ctx->Texture.Unit[0]._Current->Target == GL_TEXTURE_2D
d1083 1
a1083 1
             && (format == MESA_FORMAT_BGR_UNORM8 || format == MESA_FORMAT_A8B8G8R8_UNORM)
d1091 1
a1091 1
		   && format == MESA_FORMAT_BGR_UNORM8
d1110 1
a1110 1
                  if (format == MESA_FORMAT_A8B8G8R8_UNORM && !_mesa_little_endian()) {
@


