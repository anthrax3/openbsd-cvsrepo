head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.8
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.6
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.5
	v10_2_7:1.1.1.5
	OPENBSD_5_6:1.7.0.4
	OPENBSD_5_6_BASE:1.7
	v10_2_3:1.1.1.5
	OPENBSD_5_5:1.7.0.2
	OPENBSD_5_5_BASE:1.7
	v9_2_5:1.1.1.5
	v9_2_3:1.1.1.5
	v9_2_2:1.1.1.5
	v9_2_1:1.1.1.5
	v9_2_0:1.1.1.5
	OPENBSD_5_4:1.6.0.4
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.3.0.4
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.55;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2013.09.05.14.06.50;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2012.08.17.13.58.20;	author mpi;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.23.13.37.45;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.34;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.42;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.23;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.51.23;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.51.23;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.56.50;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.32.11;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.48;	author matthieu;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.09.05.13.17.32;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2008  Brian Paul   All Rights Reserved.
 * Copyright (C) 2009  VMware, Inc.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */


#ifndef S_SPAN_H
#define S_SPAN_H


#include "main/config.h"
#include "main/glheader.h"
#include "main/mtypes.h"
#include "swrast/s_chan.h"
#include "swrast/swrast.h"


struct gl_context;
struct gl_renderbuffer;


/**
 * \defgroup SpanFlags
 * Special bitflags to describe span data.
 *
 * In general, the point/line/triangle functions interpolate/emit the
 * attributes specified by swrast->_ActiveAttribs (i.e. FRAT_BIT_* values).
 * Some things don't fit into that, though, so we have these flags.
 */
/*@@{*/
#define SPAN_RGBA       0x01  /**< interpMask and arrayMask */
#define SPAN_Z          0x02  /**< interpMask and arrayMask */
#define SPAN_FLAT       0x04  /**< interpMask: flat shading? */
#define SPAN_XY         0x08  /**< array.x[], y[] valid? */
#define SPAN_MASK       0x10  /**< was array.mask[] filled in by caller? */
#define SPAN_LAMBDA     0x20  /**< array.lambda[] valid? */
#define SPAN_COVERAGE   0x40  /**< array.coverage[] valid? */
/*@@}*/


/**
 * \sw_span_arrays 
 * \brief Arrays of fragment values.
 *
 * These will either be computed from the span x/xStep values or
 * filled in by glDraw/CopyPixels, etc.
 * These arrays are separated out of sw_span to conserve memory.
 */
typedef struct sw_span_arrays
{
   /** Per-fragment attributes (indexed by VARYING_SLOT_* tokens) */
   /* XXX someday look at transposing first two indexes for better memory
    * access pattern.
    */
   GLfloat attribs[VARYING_SLOT_MAX][SWRAST_MAX_WIDTH][4];

   /** This mask indicates which fragments are alive or culled */
   GLubyte mask[SWRAST_MAX_WIDTH];

   GLenum ChanType; /**< Color channel type, GL_UNSIGNED_BYTE, GL_FLOAT */

   /** Attribute arrays that don't fit into attribs[] array above */
   /*@@{*/
   GLubyte rgba8[SWRAST_MAX_WIDTH][4];
   GLushort rgba16[SWRAST_MAX_WIDTH][4];
   GLchan (*rgba)[4];  /** either == rgba8 or rgba16 */
   GLint   x[SWRAST_MAX_WIDTH];  /**< fragment X coords */
   GLint   y[SWRAST_MAX_WIDTH];  /**< fragment Y coords */
   GLuint  z[SWRAST_MAX_WIDTH];  /**< fragment Z coords */
   GLuint  index[SWRAST_MAX_WIDTH];  /**< Color indexes */
   GLfloat lambda[MAX_TEXTURE_COORD_UNITS][SWRAST_MAX_WIDTH]; /**< Texture LOD */
   GLfloat coverage[SWRAST_MAX_WIDTH];  /**< Fragment coverage for AA/smoothing */
   /*@@}*/
} SWspanarrays;


/**
 * The SWspan structure describes the colors, Z, fogcoord, texcoords,
 * etc for either a horizontal run or an array of independent pixels.
 * We can either specify a base/step to indicate interpolated values, or
 * fill in explicit arrays of values.  The interpMask and arrayMask bitfields
 * indicate which attributes are active interpolants or arrays, respectively.
 *
 * It would be interesting to experiment with multiprocessor rasterization
 * with this structure.  The triangle rasterizer could simply emit a
 * stream of these structures which would be consumed by one or more
 * span-processing threads which could run in parallel.
 */
typedef struct sw_span
{
   /** Coord of first fragment in horizontal span/run */
   GLint x, y;

   /** Number of fragments in the span */
   GLuint end;

   /** for clipping left edge of spans */
   GLuint leftClip;

   /** This flag indicates that mask[] array is effectively filled with ones */
   GLboolean writeAll;

   /** either GL_POLYGON, GL_LINE, GL_POLYGON, GL_BITMAP */
   GLenum primitive;

   /** 0 = front-facing span, 1 = back-facing span (for two-sided stencil) */
   GLuint facing;

   /**
    * This bitmask (of  \link SpanFlags SPAN_* flags\endlink) indicates
    * which of the attrStart/StepX/StepY variables are relevant.
    */
   GLbitfield interpMask;

   /** Fragment attribute interpolants */
   GLfloat attrStart[VARYING_SLOT_MAX][4];   /**< initial value */
   GLfloat attrStepX[VARYING_SLOT_MAX][4];   /**< dvalue/dx */
   GLfloat attrStepY[VARYING_SLOT_MAX][4];   /**< dvalue/dy */

   /* XXX the rest of these will go away eventually... */

   /* For horizontal spans, step is the partial derivative wrt X.
    * For lines, step is the delta from one fragment to the next.
    */
   GLfixed red, redStep;
   GLfixed green, greenStep;
   GLfixed blue, blueStep;
   GLfixed alpha, alphaStep;
   GLfixed index, indexStep;
   GLfixed z, zStep;    /**< XXX z should probably be GLuint */
   GLfixed intTex[2], intTexStep[2];  /**< (s,t) for unit[0] only */

   /**
    * This bitmask (of \link SpanFlags SPAN_* flags\endlink) indicates
    * which of the fragment arrays in the span_arrays struct are relevant.
    */
   GLbitfield arrayMask;

   /** Mask of VARYING_BIT_x bits */
   GLbitfield64 arrayAttribs;

   /**
    * We store the arrays of fragment values in a separate struct so
    * that we can allocate sw_span structs on the stack without using
    * a lot of memory.  The span_arrays struct is about 1.4MB while the
    * sw_span struct is only about 512 bytes.
    */
   SWspanarrays *array;
} SWspan;



#define INIT_SPAN(S, PRIMITIVE)			\
do {						\
   (S).primitive = (PRIMITIVE);			\
   (S).interpMask = 0x0;			\
   (S).arrayMask = 0x0;				\
   (S).arrayAttribs = 0x0;			\
   (S).end = 0;					\
   (S).leftClip = 0;				\
   (S).facing = 0;				\
   (S).array = SWRAST_CONTEXT(ctx)->SpanArrays;	\
} while (0)



extern void
_swrast_span_default_attribs(struct gl_context *ctx, SWspan *span);

extern void
_swrast_span_interpolate_z( const struct gl_context *ctx, SWspan *span );

extern GLfloat
_swrast_compute_lambda(GLfloat dsdx, GLfloat dsdy, GLfloat dtdx, GLfloat dtdy,
                       GLfloat dqdx, GLfloat dqdy, GLfloat texW, GLfloat texH,
                       GLfloat s, GLfloat t, GLfloat q, GLfloat invQ);


extern void
_swrast_write_rgba_span( struct gl_context *ctx, SWspan *span);


extern void
_swrast_read_rgba_span(struct gl_context *ctx, struct gl_renderbuffer *rb,
                       GLuint n, GLint x, GLint y, GLvoid *rgba);

extern void
_swrast_put_row(struct gl_context *ctx, struct gl_renderbuffer *rb,
                GLenum datatype,
                GLuint count, GLint x, GLint y,
                const void *values, const GLubyte *mask);

extern void *
_swrast_get_dest_rgba(struct gl_context *ctx, struct gl_renderbuffer *rb,
                      SWspan *span);

#endif
@


1.7
log
@Merge Mesa 9.2.0
@
text
@@


1.6
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a2 1
 * Version:  7.5
d20 4
a23 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
d34 3
d71 1
a71 1
   /** Per-fragment attributes (indexed by FRAG_ATTRIB_* tokens) */
d75 1
a75 1
   GLfloat attribs[FRAG_ATTRIB_MAX][MAX_WIDTH][4];
d78 1
a78 1
   GLubyte mask[MAX_WIDTH];
d84 2
a85 2
   GLubyte rgba8[MAX_WIDTH][4];
   GLushort rgba16[MAX_WIDTH][4];
d87 6
a92 6
   GLint   x[MAX_WIDTH];  /**< fragment X coords */
   GLint   y[MAX_WIDTH];  /**< fragment Y coords */
   GLuint  z[MAX_WIDTH];  /**< fragment Z coords */
   GLuint  index[MAX_WIDTH];  /**< Color indexes */
   GLfloat lambda[MAX_TEXTURE_COORD_UNITS][MAX_WIDTH]; /**< Texture LOD */
   GLfloat coverage[MAX_WIDTH];  /**< Fragment coverage for AA/smoothing */
d136 3
a138 3
   GLfloat attrStart[FRAG_ATTRIB_MAX][4];   /**< initial value */
   GLfloat attrStepX[FRAG_ATTRIB_MAX][4];   /**< dvalue/dx */
   GLfloat attrStepY[FRAG_ATTRIB_MAX][4];   /**< dvalue/dy */
d159 2
a160 1
   GLbitfield arrayAttribs;
d205 1
a205 6
                       GLuint n, GLint x, GLint y, GLenum type, GLvoid *rgba);

extern void
_swrast_get_values(struct gl_context *ctx, struct gl_renderbuffer *rb,
                   GLuint count, const GLint x[], const GLint y[],
                   void *values, GLuint valueSize);
d209 1
d211 1
a211 7
                const GLvoid *values, GLuint valueSize);

extern void
_swrast_get_row(struct gl_context *ctx, struct gl_renderbuffer *rb,
                GLuint count, GLint x, GLint y,
                GLvoid *values, GLuint valueSize);

@


1.5
log
@Merge Mesa 7.10.3
@
text
@d31 6
a36 1
#include "swrast.h"
@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d179 1
a179 1
_swrast_span_default_attribs(GLcontext *ctx, SWspan *span);
d182 1
a182 1
_swrast_span_interpolate_z( const GLcontext *ctx, SWspan *span );
d191 1
a191 1
_swrast_write_rgba_span( GLcontext *ctx, SWspan *span);
d195 1
a195 1
_swrast_read_rgba_span(GLcontext *ctx, struct gl_renderbuffer *rb,
d199 1
a199 1
_swrast_get_values(GLcontext *ctx, struct gl_renderbuffer *rb,
d204 1
a204 1
_swrast_put_row(GLcontext *ctx, struct gl_renderbuffer *rb,
d209 1
a209 1
_swrast_get_row(GLcontext *ctx, struct gl_renderbuffer *rb,
d215 1
a215 1
_swrast_get_dest_rgba(GLcontext *ctx, struct gl_renderbuffer *rb,
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d3 1
a3 1
 * Version:  6.5
d5 2
a6 1
 * Copyright (C) 1999-2005  Brian Paul   All Rights Reserved.
d44 6
a49 7
#define SPAN_INDEX      0x02  /**< interpMask and arrayMask */
#define SPAN_Z          0x04  /**< interpMask and arrayMask */
#define SPAN_FLAT       0x08  /**< interpMask: flat shading? */
#define SPAN_XY         0x10  /**< array.x[], y[] valid? */
#define SPAN_MASK       0x20  /**< was array.mask[] filled in by caller? */
#define SPAN_LAMBDA     0x40  /**< array.lambda[] valid? */
#define SPAN_COVERAGE   0x80  /**< array.coverage[] valid? */
d109 3
d171 1
a188 3
extern void
_swrast_write_index_span( GLcontext *ctx, SWspan *span);

a196 4

extern void
_swrast_read_index_span( GLcontext *ctx, struct gl_renderbuffer *rb,
                         GLuint n, GLint x, GLint y, GLuint indx[] );
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@a29 1
#include "mtypes.h"
@


1.1
log
@Initial revision
@
text
@d34 138
a171 2
extern void
_swrast_span_default_z( GLcontext *ctx, struct sw_span *span );
a172 2
extern void
_swrast_span_interpolate_z( const GLcontext *ctx, struct sw_span *span );
a173 2
extern void
_swrast_span_default_fog( GLcontext *ctx, struct sw_span *span );
d176 1
a176 1
_swrast_span_default_color( GLcontext *ctx, struct sw_span *span );
d179 1
a179 1
_swrast_span_default_texcoords( GLcontext *ctx, struct sw_span *span );
d187 1
a187 1
_swrast_write_index_span( GLcontext *ctx, struct sw_span *span);
d191 1
a191 1
_swrast_write_rgba_span( GLcontext *ctx, struct sw_span *span);
d195 2
a196 2
_swrast_read_rgba_span( GLcontext *ctx, struct gl_renderbuffer *rb,
                        GLuint n, GLint x, GLint y, GLchan rgba[][4] );
d216 5
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d35 1
a35 1
_swrast_span_default_z( GLcontext *ctx, SWspan *span );
d38 1
a38 1
_swrast_span_interpolate_z( const GLcontext *ctx, SWspan *span );
d41 1
a41 1
_swrast_span_default_fog( GLcontext *ctx, SWspan *span );
d44 1
a44 1
_swrast_span_default_color( GLcontext *ctx, SWspan *span );
d47 1
a47 1
_swrast_span_default_texcoords( GLcontext *ctx, SWspan *span );
d55 1
a55 1
_swrast_write_index_span( GLcontext *ctx, SWspan *span);
d59 1
a59 1
_swrast_write_rgba_span( GLcontext *ctx, SWspan *span);
d63 2
a64 2
_swrast_read_rgba_span(GLcontext *ctx, struct gl_renderbuffer *rb,
                       GLuint n, GLint x, GLint y, GLenum type, GLvoid *rgba);
a83 5


extern void *
_swrast_get_dest_rgba(GLcontext *ctx, struct gl_renderbuffer *rb,
                      SWspan *span);
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@a33 179
/**
 * \defgroup SpanFlags
 * Bitflags used for interpMask and arrayMask fields below to indicate
 * which interpolant values and fragment arrays are in use, respectively.
 *
 * XXX We should replace these flags with the FRAG_BIT_ values someday...
 */
/*@@{*/
#define SPAN_RGBA         0x001
#define SPAN_SPEC         0x002
#define SPAN_INDEX        0x004
#define SPAN_Z            0x008
#define SPAN_W            0x010
#define SPAN_FOG          0x020
#define SPAN_TEXTURE      0x040
#define SPAN_INT_TEXTURE  0x080
#define SPAN_LAMBDA       0x100
#define SPAN_COVERAGE     0x200
#define SPAN_FLAT         0x400  /**< flat shading? */
#define SPAN_XY           0x800
#define SPAN_MASK        0x1000
#define SPAN_VARYING     0x2000
/*@@}*/


#if 0
/* alternate arrangement for code below */
struct arrays2 {
   union {
      GLubyte  sz1[MAX_WIDTH][4]; /* primary color */
      GLushort sz2[MAX_WIDTH][4];
   } rgba;
   union {
      GLubyte  sz1[MAX_WIDTH][4]; /* specular color and temp storage */
      GLushort sz2[MAX_WIDTH][4];
   } spec;
};
#endif



/**
 * \sw_span_arrays 
 * \brief Arrays of fragment values.
 *
 * These will either be computed from the span x/xStep values or
 * filled in by glDraw/CopyPixels, etc.
 * These arrays are separated out of sw_span to conserve memory.
 */
typedef struct sw_span_arrays
{
   /** Per-fragment attributes (indexed by FRAG_ATTRIB_* tokens) */
   /* XXX someday look at transposing first two indexes for better memory
    * access pattern.
    */
   GLfloat attribs[FRAG_ATTRIB_MAX][MAX_WIDTH][4];

   /** This mask indicates which fragments are alive or culled */
   GLubyte mask[MAX_WIDTH];

   GLenum ChanType; /**< Color channel type, GL_UNSIGNED_BYTE, GL_FLOAT */
   union {
      struct {
         GLubyte rgba[MAX_WIDTH][4]; /**< primary color */
         GLubyte spec[MAX_WIDTH][4]; /**< specular color and temp storage */
      } sz1;
      struct {
         GLushort rgba[MAX_WIDTH][4];
         GLushort spec[MAX_WIDTH][4];
      } sz2;
   } color;
   /** XXX these are temporary fields, pointing into above color arrays */
   GLchan (*rgba)[4];
   GLchan (*spec)[4];

   GLint   x[MAX_WIDTH];  /**< fragment X coords */
   GLint   y[MAX_WIDTH];  /**< fragment Y coords */
   GLuint  z[MAX_WIDTH];  /**< fragment Z coords */
   GLuint  index[MAX_WIDTH];  /**< Color indexes */
   GLfloat lambda[MAX_TEXTURE_COORD_UNITS][MAX_WIDTH]; /**< Texture LOD */
   GLfloat coverage[MAX_WIDTH];  /**< Fragment coverage for AA/smoothing */
} SWspanarrays;


/**
 * The SWspan structure describes the colors, Z, fogcoord, texcoords,
 * etc for either a horizontal run or an array of independent pixels.
 * We can either specify a base/step to indicate interpolated values, or
 * fill in explicit arrays of values.  The interpMask and arrayMask bitfields
 * indicate which attributes are active interpolants or arrays, respectively.
 *
 * It would be interesting to experiment with multiprocessor rasterization
 * with this structure.  The triangle rasterizer could simply emit a
 * stream of these structures which would be consumed by one or more
 * span-processing threads which could run in parallel.
 */
typedef struct sw_span
{
   /** Coord of first fragment in horizontal span/run */
   GLint x, y;

   /** Number of fragments in the span */
   GLuint end;

   /** This flag indicates that mask[] array is effectively filled with ones */
   GLboolean writeAll;

   /** either GL_POLYGON, GL_LINE, GL_POLYGON, GL_BITMAP */
   GLenum primitive;

   /** 0 = front-facing span, 1 = back-facing span (for two-sided stencil) */
   GLuint facing;

   /**
    * This bitmask (of  \link SpanFlags SPAN_* flags\endlink) indicates
    * which of the attrStart/StepX/StepY variables are relevant.
    */
   GLbitfield interpMask;

   /** Fragment attribute interpolants */
   GLfloat attrStart[FRAG_ATTRIB_MAX][4];   /**< initial value */
   GLfloat attrStepX[FRAG_ATTRIB_MAX][4];   /**< dvalue/dx */
   GLfloat attrStepY[FRAG_ATTRIB_MAX][4];   /**< dvalue/dy */

   /* XXX the rest of these will go away eventually... */

   /* For horizontal spans, step is the partial derivative wrt X.
    * For lines, step is the delta from one fragment to the next.
    */
#if CHAN_TYPE == GL_FLOAT
   GLfloat red, redStep;
   GLfloat green, greenStep;
   GLfloat blue, blueStep;
   GLfloat alpha, alphaStep;
   GLfloat specRed, specRedStep;
   GLfloat specGreen, specGreenStep;
   GLfloat specBlue, specBlueStep;
#else /* CHAN_TYPE == GL_UNSIGNED_BYTE or GL_UNSIGNED_SHORT */
   GLfixed red, redStep;
   GLfixed green, greenStep;
   GLfixed blue, blueStep;
   GLfixed alpha, alphaStep;
   GLfixed specRed, specRedStep;
   GLfixed specGreen, specGreenStep;
   GLfixed specBlue, specBlueStep;
#endif
   GLfixed index, indexStep;
   GLfixed z, zStep;    /* XXX z should probably be GLuint */
   GLfixed intTex[2], intTexStep[2];  /* s, t only */

   /**
    * This bitmask (of \link SpanFlags SPAN_* flags\endlink) indicates
    * which of the fragment arrays in the span_arrays struct are relevant.
    */
   GLbitfield arrayMask;

   /**
    * We store the arrays of fragment values in a separate struct so
    * that we can allocate sw_span structs on the stack without using
    * a lot of memory.  The span_arrays struct is about 1.4MB while the
    * sw_span struct is only about 512 bytes.
    */
   SWspanarrays *array;
} SWspan;



#define INIT_SPAN(S, PRIMITIVE, END, INTERP_MASK, ARRAY_MASK)	\
do {								\
   (S).primitive = (PRIMITIVE);					\
   (S).interpMask = (INTERP_MASK);				\
   (S).arrayMask = (ARRAY_MASK);				\
   (S).end = (END);						\
   (S).facing = 0;						\
   (S).array = SWRAST_CONTEXT(ctx)->SpanArrays;			\
} while (0)



a44 3

extern void
_swrast_span_default_secondary_color(GLcontext *ctx, SWspan *span);
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d3 1
a3 1
 * Version:  7.5
d5 1
a5 2
 * Copyright (C) 1999-2008  Brian Paul   All Rights Reserved.
 * Copyright (C) 2009  VMware, Inc.  All Rights Reserved.
d30 1
d36 2
a37 1
 * Special bitflags to describe span data.
d39 1
a39 3
 * In general, the point/line/triangle functions interpolate/emit the
 * attributes specified by swrast->_ActiveAttribs (i.e. FRAT_BIT_* values).
 * Some things don't fit into that, though, so we have these flags.
d42 14
a55 7
#define SPAN_RGBA       0x01  /**< interpMask and arrayMask */
#define SPAN_Z          0x02  /**< interpMask and arrayMask */
#define SPAN_FLAT       0x04  /**< interpMask: flat shading? */
#define SPAN_XY         0x08  /**< array.x[], y[] valid? */
#define SPAN_MASK       0x10  /**< was array.mask[] filled in by caller? */
#define SPAN_LAMBDA     0x20  /**< array.lambda[] valid? */
#define SPAN_COVERAGE   0x40  /**< array.coverage[] valid? */
d59 16
d95 13
a108 5
   /** Attribute arrays that don't fit into attribs[] array above */
   /*@@{*/
   GLubyte rgba8[MAX_WIDTH][4];
   GLushort rgba16[MAX_WIDTH][4];
   GLchan (*rgba)[4];  /** either == rgba8 or rgba16 */
a114 1
   /*@@}*/
a137 3
   /** for clipping left edge of spans */
   GLuint leftClip;

d163 9
d176 4
d181 2
a182 2
   GLfixed z, zStep;    /**< XXX z should probably be GLuint */
   GLfixed intTex[2], intTexStep[2];  /**< (s,t) for unit[0] only */
a189 2
   GLbitfield arrayAttribs;

d201 8
a208 10
#define INIT_SPAN(S, PRIMITIVE)			\
do {						\
   (S).primitive = (PRIMITIVE);			\
   (S).interpMask = 0x0;			\
   (S).arrayMask = 0x0;				\
   (S).arrayAttribs = 0x0;			\
   (S).end = 0;					\
   (S).leftClip = 0;				\
   (S).facing = 0;				\
   (S).array = SWRAST_CONTEXT(ctx)->SpanArrays;	\
d214 7
a220 1
_swrast_span_default_attribs(struct gl_context *ctx, SWspan *span);
d223 7
a229 1
_swrast_span_interpolate_z( const struct gl_context *ctx, SWspan *span );
d236 3
d241 1
a241 1
_swrast_write_rgba_span( struct gl_context *ctx, SWspan *span);
d245 1
a245 1
_swrast_read_rgba_span(struct gl_context *ctx, struct gl_renderbuffer *rb,
d249 5
a253 1
_swrast_get_values(struct gl_context *ctx, struct gl_renderbuffer *rb,
d258 1
a258 1
_swrast_put_row(struct gl_context *ctx, struct gl_renderbuffer *rb,
d263 1
a263 1
_swrast_get_row(struct gl_context *ctx, struct gl_renderbuffer *rb,
d269 1
a269 1
_swrast_get_dest_rgba(struct gl_context *ctx, struct gl_renderbuffer *rb,
@


1.1.1.5
log
@Import Mesa 9.2.0
@
text
@d3 1
d21 3
a23 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
d31 1
a31 9
#include "main/config.h"
#include "main/glheader.h"
#include "main/mtypes.h"
#include "swrast/s_chan.h"
#include "swrast/swrast.h"


struct gl_context;
struct gl_renderbuffer;
d63 1
a63 1
   /** Per-fragment attributes (indexed by VARYING_SLOT_* tokens) */
d67 1
a67 1
   GLfloat attribs[VARYING_SLOT_MAX][SWRAST_MAX_WIDTH][4];
d70 1
a70 1
   GLubyte mask[SWRAST_MAX_WIDTH];
d76 2
a77 2
   GLubyte rgba8[SWRAST_MAX_WIDTH][4];
   GLushort rgba16[SWRAST_MAX_WIDTH][4];
d79 6
a84 6
   GLint   x[SWRAST_MAX_WIDTH];  /**< fragment X coords */
   GLint   y[SWRAST_MAX_WIDTH];  /**< fragment Y coords */
   GLuint  z[SWRAST_MAX_WIDTH];  /**< fragment Z coords */
   GLuint  index[SWRAST_MAX_WIDTH];  /**< Color indexes */
   GLfloat lambda[MAX_TEXTURE_COORD_UNITS][SWRAST_MAX_WIDTH]; /**< Texture LOD */
   GLfloat coverage[SWRAST_MAX_WIDTH];  /**< Fragment coverage for AA/smoothing */
d128 3
a130 3
   GLfloat attrStart[VARYING_SLOT_MAX][4];   /**< initial value */
   GLfloat attrStepX[VARYING_SLOT_MAX][4];   /**< dvalue/dx */
   GLfloat attrStepY[VARYING_SLOT_MAX][4];   /**< dvalue/dy */
d151 1
a151 2
   /** Mask of VARYING_BIT_x bits */
   GLbitfield64 arrayAttribs;
d196 6
a201 1
                       GLuint n, GLint x, GLint y, GLvoid *rgba);
a204 1
                GLenum datatype,
d206 7
a212 1
                const void *values, const GLubyte *mask);
@


