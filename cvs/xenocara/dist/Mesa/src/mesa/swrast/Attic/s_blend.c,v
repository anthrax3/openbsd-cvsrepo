head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.8
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.6
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.4
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.4
	OPENBSD_5_6:1.7.0.4
	OPENBSD_5_6_BASE:1.7
	v10_2_3:1.1.1.4
	OPENBSD_5_5:1.7.0.2
	OPENBSD_5_5_BASE:1.7
	v9_2_5:1.1.1.4
	v9_2_3:1.1.1.4
	v9_2_2:1.1.1.4
	v9_2_1:1.1.1.4
	v9_2_0:1.1.1.4
	OPENBSD_5_4:1.6.0.4
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	v7_10_3:1.1.1.3
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.6
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.4
	v7_0_1:1.1.1.2
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.55;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2013.09.05.14.06.48;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2012.08.17.13.58.20;	author mpi;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.23.13.37.45;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.34;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.42;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.23;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.51.17;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.51.17;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.56.49;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.10.23.13.29.48;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.09.05.13.17.28;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2008  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */


/**
 * \file swrast/s_blend.c
 * \brief software blending.
 * \author Brian Paul
 *
 * Only a few blend modes have been optimized (min, max, transparency, add)
 * more optimized cases can easily be added if needed.
 * Celestia uses glBlendFunc(GL_SRC_ALPHA, GL_ONE), for example.
 */



#include "main/glheader.h"
#include "main/context.h"
#include "main/colormac.h"
#include "main/macros.h"

#include "s_blend.h"
#include "s_context.h"
#include "s_span.h"


#if defined(USE_MMX_ASM)
#include "x86/mmx.h"
#include "x86/common_x86_asm.h"
#define _BLENDAPI _ASMAPI
#else
#define _BLENDAPI
#endif


/**
 * Integer divide by 255
 * Declare "int divtemp" before using.
 * This satisfies Glean and should be reasonably fast.
 * Contributed by Nathan Hand.
 */
#define DIV255(X)  (divtemp = (X), ((divtemp << 8) + divtemp + 256) >> 16)



/**
 * Special case for glBlendFunc(GL_ZERO, GL_ONE).
 * No-op means the framebuffer values remain unchanged.
 * Any chanType ok.
 */
static void _BLENDAPI
blend_noop(struct gl_context *ctx, GLuint n, const GLubyte mask[],
           GLvoid *src, const GLvoid *dst, GLenum chanType)
{
   GLint bytes;

   ASSERT(ctx->Color.Blend[0].EquationRGB == GL_FUNC_ADD);
   ASSERT(ctx->Color.Blend[0].EquationA == GL_FUNC_ADD);
   ASSERT(ctx->Color.Blend[0].SrcRGB == GL_ZERO);
   ASSERT(ctx->Color.Blend[0].DstRGB == GL_ONE);
   (void) ctx;

   /* just memcpy */
   if (chanType == GL_UNSIGNED_BYTE)
      bytes = 4 * n * sizeof(GLubyte);
   else if (chanType == GL_UNSIGNED_SHORT)
      bytes = 4 * n * sizeof(GLushort);
   else
      bytes = 4 * n * sizeof(GLfloat);

   memcpy(src, dst, bytes);
}


/**
 * Special case for glBlendFunc(GL_ONE, GL_ZERO)
 * Any chanType ok.
 */
static void _BLENDAPI
blend_replace(struct gl_context *ctx, GLuint n, const GLubyte mask[],
              GLvoid *src, const GLvoid *dst, GLenum chanType)
{
   ASSERT(ctx->Color.Blend[0].EquationRGB == GL_FUNC_ADD);
   ASSERT(ctx->Color.Blend[0].EquationA == GL_FUNC_ADD);
   ASSERT(ctx->Color.Blend[0].SrcRGB == GL_ONE);
   ASSERT(ctx->Color.Blend[0].DstRGB == GL_ZERO);
   (void) ctx;
   (void) n;
   (void) mask;
   (void) src;
   (void) dst;
}


/**
 * Common transparency blending mode:
 * glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA).
 */
static void _BLENDAPI
blend_transparency_ubyte(struct gl_context *ctx, GLuint n, const GLubyte mask[],
                         GLvoid *src, const GLvoid *dst, GLenum chanType)
{
   GLubyte (*rgba)[4] = (GLubyte (*)[4]) src;
   const GLubyte (*dest)[4] = (const GLubyte (*)[4]) dst;
   GLuint i;

   ASSERT(ctx->Color.Blend[0].EquationRGB == GL_FUNC_ADD);
   ASSERT(ctx->Color.Blend[0].EquationA == GL_FUNC_ADD);
   ASSERT(ctx->Color.Blend[0].SrcRGB == GL_SRC_ALPHA);
   ASSERT(ctx->Color.Blend[0].SrcA == GL_SRC_ALPHA);
   ASSERT(ctx->Color.Blend[0].DstRGB == GL_ONE_MINUS_SRC_ALPHA);
   ASSERT(ctx->Color.Blend[0].DstA == GL_ONE_MINUS_SRC_ALPHA);
   ASSERT(chanType == GL_UNSIGNED_BYTE);

   (void) ctx;

   for (i = 0; i < n; i++) {
      if (mask[i]) {
         const GLint t = rgba[i][ACOMP];  /* t is in [0, 255] */
         if (t == 0) {
            /* 0% alpha */
            COPY_4UBV(rgba[i], dest[i]);
         }
         else if (t != 255) {
	    GLint divtemp;
            const GLint r = DIV255((rgba[i][RCOMP] - dest[i][RCOMP]) * t) + dest[i][RCOMP];
            const GLint g = DIV255((rgba[i][GCOMP] - dest[i][GCOMP]) * t) + dest[i][GCOMP];
            const GLint b = DIV255((rgba[i][BCOMP] - dest[i][BCOMP]) * t) + dest[i][BCOMP];
            const GLint a = DIV255((rgba[i][ACOMP] - dest[i][ACOMP]) * t) + dest[i][ACOMP]; 
            ASSERT(r <= 255);
            ASSERT(g <= 255);
            ASSERT(b <= 255);
            ASSERT(a <= 255);
            rgba[i][RCOMP] = (GLubyte) r;
            rgba[i][GCOMP] = (GLubyte) g;
            rgba[i][BCOMP] = (GLubyte) b;
            rgba[i][ACOMP] = (GLubyte) a;
         }
      }
   }
}


static void _BLENDAPI
blend_transparency_ushort(struct gl_context *ctx, GLuint n, const GLubyte mask[],
                          GLvoid *src, const GLvoid *dst, GLenum chanType)
{
   GLushort (*rgba)[4] = (GLushort (*)[4]) src;
   const GLushort (*dest)[4] = (const GLushort (*)[4]) dst;
   GLuint i;

   ASSERT(ctx->Color.Blend[0].EquationRGB == GL_FUNC_ADD);
   ASSERT(ctx->Color.Blend[0].EquationA == GL_FUNC_ADD);
   ASSERT(ctx->Color.Blend[0].SrcRGB == GL_SRC_ALPHA);
   ASSERT(ctx->Color.Blend[0].SrcA == GL_SRC_ALPHA);
   ASSERT(ctx->Color.Blend[0].DstRGB == GL_ONE_MINUS_SRC_ALPHA);
   ASSERT(ctx->Color.Blend[0].DstA == GL_ONE_MINUS_SRC_ALPHA);
   ASSERT(chanType == GL_UNSIGNED_SHORT);

   (void) ctx;

   for (i = 0; i < n; i++) {
      if (mask[i]) {
         const GLint t = rgba[i][ACOMP];
         if (t == 0) {
            /* 0% alpha */
            COPY_4V(rgba[i], dest[i]);
         }
         else if (t != 65535) {
            const GLfloat tt = (GLfloat) t / 65535.0F;
            GLushort r = (GLushort) ((rgba[i][RCOMP] - dest[i][RCOMP]) * tt + dest[i][RCOMP]);
            GLushort g = (GLushort) ((rgba[i][GCOMP] - dest[i][GCOMP]) * tt + dest[i][GCOMP]);
            GLushort b = (GLushort) ((rgba[i][BCOMP] - dest[i][BCOMP]) * tt + dest[i][BCOMP]);
            GLushort a = (GLushort) ((rgba[i][ACOMP] - dest[i][ACOMP]) * tt + dest[i][ACOMP]);
            ASSIGN_4V(rgba[i], r, g, b, a);
         }
      }
   }
}


static void _BLENDAPI
blend_transparency_float(struct gl_context *ctx, GLuint n, const GLubyte mask[],
                         GLvoid *src, const GLvoid *dst, GLenum chanType)
{
   GLfloat (*rgba)[4] = (GLfloat (*)[4]) src;
   const GLfloat (*dest)[4] = (const GLfloat (*)[4]) dst;
   GLuint i;

   ASSERT(ctx->Color.Blend[0].EquationRGB == GL_FUNC_ADD);
   ASSERT(ctx->Color.Blend[0].EquationA == GL_FUNC_ADD);
   ASSERT(ctx->Color.Blend[0].SrcRGB == GL_SRC_ALPHA);
   ASSERT(ctx->Color.Blend[0].SrcA == GL_SRC_ALPHA);
   ASSERT(ctx->Color.Blend[0].DstRGB == GL_ONE_MINUS_SRC_ALPHA);
   ASSERT(ctx->Color.Blend[0].DstA == GL_ONE_MINUS_SRC_ALPHA);
   ASSERT(chanType == GL_FLOAT);

   (void) ctx;

   for (i = 0; i < n; i++) {
      if (mask[i]) {
         const GLfloat t = rgba[i][ACOMP];  /* t in [0, 1] */
         if (t == 0.0F) {
            /* 0% alpha */
            COPY_4V(rgba[i], dest[i]);
         }
         else if (t != 1.0F) {
            GLfloat r = (rgba[i][RCOMP] - dest[i][RCOMP]) * t + dest[i][RCOMP];
            GLfloat g = (rgba[i][GCOMP] - dest[i][GCOMP]) * t + dest[i][GCOMP];
            GLfloat b = (rgba[i][BCOMP] - dest[i][BCOMP]) * t + dest[i][BCOMP];
            GLfloat a = (rgba[i][ACOMP] - dest[i][ACOMP]) * t + dest[i][ACOMP];
            ASSIGN_4V(rgba[i], r, g, b, a);
         }
      }
   }
}



/**
 * Add src and dest: glBlendFunc(GL_ONE, GL_ONE).
 * Any chanType ok.
 */
static void _BLENDAPI
blend_add(struct gl_context *ctx, GLuint n, const GLubyte mask[],
          GLvoid *src, const GLvoid *dst, GLenum chanType)
{
   GLuint i;

   ASSERT(ctx->Color.Blend[0].EquationRGB == GL_FUNC_ADD);
   ASSERT(ctx->Color.Blend[0].EquationA == GL_FUNC_ADD);
   ASSERT(ctx->Color.Blend[0].SrcRGB == GL_ONE);
   ASSERT(ctx->Color.Blend[0].DstRGB == GL_ONE);
   (void) ctx;

   if (chanType == GL_UNSIGNED_BYTE) {
      GLubyte (*rgba)[4] = (GLubyte (*)[4]) src;
      const GLubyte (*dest)[4] = (const GLubyte (*)[4]) dst;
      for (i=0;i<n;i++) {
         if (mask[i]) {
            GLint r = rgba[i][RCOMP] + dest[i][RCOMP];
            GLint g = rgba[i][GCOMP] + dest[i][GCOMP];
            GLint b = rgba[i][BCOMP] + dest[i][BCOMP];
            GLint a = rgba[i][ACOMP] + dest[i][ACOMP];
            rgba[i][RCOMP] = (GLubyte) MIN2( r, 255 );
            rgba[i][GCOMP] = (GLubyte) MIN2( g, 255 );
            rgba[i][BCOMP] = (GLubyte) MIN2( b, 255 );
            rgba[i][ACOMP] = (GLubyte) MIN2( a, 255 );
         }
      }
   }
   else if (chanType == GL_UNSIGNED_SHORT) {
      GLushort (*rgba)[4] = (GLushort (*)[4]) src;
      const GLushort (*dest)[4] = (const GLushort (*)[4]) dst;
      for (i=0;i<n;i++) {
         if (mask[i]) {
            GLint r = rgba[i][RCOMP] + dest[i][RCOMP];
            GLint g = rgba[i][GCOMP] + dest[i][GCOMP];
            GLint b = rgba[i][BCOMP] + dest[i][BCOMP];
            GLint a = rgba[i][ACOMP] + dest[i][ACOMP];
            rgba[i][RCOMP] = (GLshort) MIN2( r, 255 );
            rgba[i][GCOMP] = (GLshort) MIN2( g, 255 );
            rgba[i][BCOMP] = (GLshort) MIN2( b, 255 );
            rgba[i][ACOMP] = (GLshort) MIN2( a, 255 );
         }
      }
   }
   else {
      GLfloat (*rgba)[4] = (GLfloat (*)[4]) src;
      const GLfloat (*dest)[4] = (const GLfloat (*)[4]) dst;
      ASSERT(chanType == GL_FLOAT);
      for (i=0;i<n;i++) {
         if (mask[i]) {
            /* don't RGB clamp to max */
            rgba[i][RCOMP] += dest[i][RCOMP];
            rgba[i][GCOMP] += dest[i][GCOMP];
            rgba[i][BCOMP] += dest[i][BCOMP];
            rgba[i][ACOMP] += dest[i][ACOMP];
         }
      }
   }
}



/**
 * Blend min function.
 * Any chanType ok.
 */
static void _BLENDAPI
blend_min(struct gl_context *ctx, GLuint n, const GLubyte mask[],
          GLvoid *src, const GLvoid *dst, GLenum chanType)
{
   GLuint i;
   ASSERT(ctx->Color.Blend[0].EquationRGB == GL_MIN);
   ASSERT(ctx->Color.Blend[0].EquationA == GL_MIN);
   (void) ctx;

   if (chanType == GL_UNSIGNED_BYTE) {
      GLubyte (*rgba)[4] = (GLubyte (*)[4]) src;
      const GLubyte (*dest)[4] = (const GLubyte (*)[4]) dst;
      for (i=0;i<n;i++) {
         if (mask[i]) {
            rgba[i][RCOMP] = MIN2( rgba[i][RCOMP], dest[i][RCOMP] );
            rgba[i][GCOMP] = MIN2( rgba[i][GCOMP], dest[i][GCOMP] );
            rgba[i][BCOMP] = MIN2( rgba[i][BCOMP], dest[i][BCOMP] );
            rgba[i][ACOMP] = MIN2( rgba[i][ACOMP], dest[i][ACOMP] );
         }
      }
   }
   else if (chanType == GL_UNSIGNED_SHORT) {
      GLushort (*rgba)[4] = (GLushort (*)[4]) src;
      const GLushort (*dest)[4] = (const GLushort (*)[4]) dst;
      for (i=0;i<n;i++) {
         if (mask[i]) {
            rgba[i][RCOMP] = MIN2( rgba[i][RCOMP], dest[i][RCOMP] );
            rgba[i][GCOMP] = MIN2( rgba[i][GCOMP], dest[i][GCOMP] );
            rgba[i][BCOMP] = MIN2( rgba[i][BCOMP], dest[i][BCOMP] );
            rgba[i][ACOMP] = MIN2( rgba[i][ACOMP], dest[i][ACOMP] );
         }
      }
   }
   else {
      GLfloat (*rgba)[4] = (GLfloat (*)[4]) src;
      const GLfloat (*dest)[4] = (const GLfloat (*)[4]) dst;
      ASSERT(chanType == GL_FLOAT);
      for (i=0;i<n;i++) {
         if (mask[i]) {
            rgba[i][RCOMP] = MIN2( rgba[i][RCOMP], dest[i][RCOMP] );
            rgba[i][GCOMP] = MIN2( rgba[i][GCOMP], dest[i][GCOMP] );
            rgba[i][BCOMP] = MIN2( rgba[i][BCOMP], dest[i][BCOMP] );
            rgba[i][ACOMP] = MIN2( rgba[i][ACOMP], dest[i][ACOMP] );
         }
      }
   }
}


/**
 * Blend max function.
 * Any chanType ok.
 */
static void _BLENDAPI
blend_max(struct gl_context *ctx, GLuint n, const GLubyte mask[],
          GLvoid *src, const GLvoid *dst, GLenum chanType)
{
   GLuint i;
   ASSERT(ctx->Color.Blend[0].EquationRGB == GL_MAX);
   ASSERT(ctx->Color.Blend[0].EquationA == GL_MAX);
   (void) ctx;

   if (chanType == GL_UNSIGNED_BYTE) {
      GLubyte (*rgba)[4] = (GLubyte (*)[4]) src;
      const GLubyte (*dest)[4] = (const GLubyte (*)[4]) dst;
      for (i=0;i<n;i++) {
         if (mask[i]) {
            rgba[i][RCOMP] = MAX2( rgba[i][RCOMP], dest[i][RCOMP] );
            rgba[i][GCOMP] = MAX2( rgba[i][GCOMP], dest[i][GCOMP] );
            rgba[i][BCOMP] = MAX2( rgba[i][BCOMP], dest[i][BCOMP] );
            rgba[i][ACOMP] = MAX2( rgba[i][ACOMP], dest[i][ACOMP] );
         }
      }
   }
   else if (chanType == GL_UNSIGNED_SHORT) {
      GLushort (*rgba)[4] = (GLushort (*)[4]) src;
      const GLushort (*dest)[4] = (const GLushort (*)[4]) dst;
      for (i=0;i<n;i++) {
         if (mask[i]) {
            rgba[i][RCOMP] = MAX2( rgba[i][RCOMP], dest[i][RCOMP] );
            rgba[i][GCOMP] = MAX2( rgba[i][GCOMP], dest[i][GCOMP] );
            rgba[i][BCOMP] = MAX2( rgba[i][BCOMP], dest[i][BCOMP] );
            rgba[i][ACOMP] = MAX2( rgba[i][ACOMP], dest[i][ACOMP] );
         }
      }
   }
   else {
      GLfloat (*rgba)[4] = (GLfloat (*)[4]) src;
      const GLfloat (*dest)[4] = (const GLfloat (*)[4]) dst;
      ASSERT(chanType == GL_FLOAT);
      for (i=0;i<n;i++) {
         if (mask[i]) {
            rgba[i][RCOMP] = MAX2( rgba[i][RCOMP], dest[i][RCOMP] );
            rgba[i][GCOMP] = MAX2( rgba[i][GCOMP], dest[i][GCOMP] );
            rgba[i][BCOMP] = MAX2( rgba[i][BCOMP], dest[i][BCOMP] );
            rgba[i][ACOMP] = MAX2( rgba[i][ACOMP], dest[i][ACOMP] );
         }
      }
   }
}



/**
 * Modulate:  result = src * dest
 * Any chanType ok.
 */
static void _BLENDAPI
blend_modulate(struct gl_context *ctx, GLuint n, const GLubyte mask[],
               GLvoid *src, const GLvoid *dst, GLenum chanType)
{
   GLuint i;
   (void) ctx;

   if (chanType == GL_UNSIGNED_BYTE) {
      GLubyte (*rgba)[4] = (GLubyte (*)[4]) src;
      const GLubyte (*dest)[4] = (const GLubyte (*)[4]) dst;
      for (i=0;i<n;i++) {
         if (mask[i]) {
	    GLint divtemp;
            rgba[i][RCOMP] = DIV255(rgba[i][RCOMP] * dest[i][RCOMP]);
            rgba[i][GCOMP] = DIV255(rgba[i][GCOMP] * dest[i][GCOMP]);
            rgba[i][BCOMP] = DIV255(rgba[i][BCOMP] * dest[i][BCOMP]);
            rgba[i][ACOMP] = DIV255(rgba[i][ACOMP] * dest[i][ACOMP]);
         }
      }
   }
   else if (chanType == GL_UNSIGNED_SHORT) {
      GLushort (*rgba)[4] = (GLushort (*)[4]) src;
      const GLushort (*dest)[4] = (const GLushort (*)[4]) dst;
      for (i=0;i<n;i++) {
         if (mask[i]) {
            rgba[i][RCOMP] = (rgba[i][RCOMP] * dest[i][RCOMP] + 65535) >> 16;
            rgba[i][GCOMP] = (rgba[i][GCOMP] * dest[i][GCOMP] + 65535) >> 16;
            rgba[i][BCOMP] = (rgba[i][BCOMP] * dest[i][BCOMP] + 65535) >> 16;
            rgba[i][ACOMP] = (rgba[i][ACOMP] * dest[i][ACOMP] + 65535) >> 16;
         }
      }
   }
   else {
      GLfloat (*rgba)[4] = (GLfloat (*)[4]) src;
      const GLfloat (*dest)[4] = (const GLfloat (*)[4]) dst;
      ASSERT(chanType == GL_FLOAT);
      for (i=0;i<n;i++) {
         if (mask[i]) {
            rgba[i][RCOMP] = rgba[i][RCOMP] * dest[i][RCOMP];
            rgba[i][GCOMP] = rgba[i][GCOMP] * dest[i][GCOMP];
            rgba[i][BCOMP] = rgba[i][BCOMP] * dest[i][BCOMP];
            rgba[i][ACOMP] = rgba[i][ACOMP] * dest[i][ACOMP];
         }
      }
   }
}


/**
 * Do any blending operation, using floating point.
 * \param n  number of pixels
 * \param mask  fragment writemask array
 * \param rgba  array of incoming (and modified) pixels
 * \param dest  array of pixels from the dest color buffer
 */
static void
blend_general_float(struct gl_context *ctx, GLuint n, const GLubyte mask[],
                    GLfloat rgba[][4], GLfloat dest[][4],
                    GLenum chanType)
{
   GLuint i;

   for (i = 0; i < n; i++) {
      if (mask[i]) {
         /* Incoming/source Color */
         const GLfloat Rs = rgba[i][RCOMP];
         const GLfloat Gs = rgba[i][GCOMP];
         const GLfloat Bs = rgba[i][BCOMP];
         const GLfloat As = rgba[i][ACOMP];

         /* Frame buffer/dest color */
         const GLfloat Rd = dest[i][RCOMP];
         const GLfloat Gd = dest[i][GCOMP];
         const GLfloat Bd = dest[i][BCOMP];
         const GLfloat Ad = dest[i][ACOMP];

         GLfloat sR, sG, sB, sA;  /* Source factor */
         GLfloat dR, dG, dB, dA;  /* Dest factor */
         GLfloat r, g, b, a;      /* result color */

         /* XXX for the case of constant blend terms we could init
          * the sX and dX variables just once before the loop.
          */

         /* Source RGB factor */
         switch (ctx->Color.Blend[0].SrcRGB) {
            case GL_ZERO:
               sR = sG = sB = 0.0F;
               break;
            case GL_ONE:
               sR = sG = sB = 1.0F;
               break;
            case GL_DST_COLOR:
               sR = Rd;
               sG = Gd;
               sB = Bd;
               break;
            case GL_ONE_MINUS_DST_COLOR:
               sR = 1.0F - Rd;
               sG = 1.0F - Gd;
               sB = 1.0F - Bd;
               break;
            case GL_SRC_ALPHA:
               sR = sG = sB = As;
               break;
            case GL_ONE_MINUS_SRC_ALPHA:
               sR = sG = sB = 1.0F - As;
               break;
            case GL_DST_ALPHA:
               sR = sG = sB = Ad;
               break;
            case GL_ONE_MINUS_DST_ALPHA:
               sR = sG = sB = 1.0F - Ad;
               break;
            case GL_SRC_ALPHA_SATURATE:
               if (As < 1.0F - Ad) {
                  sR = sG = sB = As;
               }
               else {
                  sR = sG = sB = 1.0F - Ad;
               }
               break;
            case GL_CONSTANT_COLOR:
               sR = ctx->Color.BlendColor[0];
               sG = ctx->Color.BlendColor[1];
               sB = ctx->Color.BlendColor[2];
               break;
            case GL_ONE_MINUS_CONSTANT_COLOR:
               sR = 1.0F - ctx->Color.BlendColor[0];
               sG = 1.0F - ctx->Color.BlendColor[1];
               sB = 1.0F - ctx->Color.BlendColor[2];
               break;
            case GL_CONSTANT_ALPHA:
               sR = sG = sB = ctx->Color.BlendColor[3];
               break;
            case GL_ONE_MINUS_CONSTANT_ALPHA:
               sR = sG = sB = 1.0F - ctx->Color.BlendColor[3];
               break;
            case GL_SRC_COLOR:
               sR = Rs;
               sG = Gs;
               sB = Bs;
               break;
            case GL_ONE_MINUS_SRC_COLOR:
               sR = 1.0F - Rs;
               sG = 1.0F - Gs;
               sB = 1.0F - Bs;
               break;
            default:
               /* this should never happen */
               _mesa_problem(ctx, "Bad blend source RGB factor in blend_general_float");
               return;
         }

         /* Source Alpha factor */
         switch (ctx->Color.Blend[0].SrcA) {
            case GL_ZERO:
               sA = 0.0F;
               break;
            case GL_ONE:
               sA = 1.0F;
               break;
            case GL_DST_COLOR:
               sA = Ad;
               break;
            case GL_ONE_MINUS_DST_COLOR:
               sA = 1.0F - Ad;
               break;
            case GL_SRC_ALPHA:
               sA = As;
               break;
            case GL_ONE_MINUS_SRC_ALPHA:
               sA = 1.0F - As;
               break;
            case GL_DST_ALPHA:
               sA = Ad;
               break;
            case GL_ONE_MINUS_DST_ALPHA:
               sA = 1.0F - Ad;
               break;
            case GL_SRC_ALPHA_SATURATE:
               sA = 1.0;
               break;
            case GL_CONSTANT_COLOR:
               sA = ctx->Color.BlendColor[3];
               break;
            case GL_ONE_MINUS_CONSTANT_COLOR:
               sA = 1.0F - ctx->Color.BlendColor[3];
               break;
            case GL_CONSTANT_ALPHA:
               sA = ctx->Color.BlendColor[3];
               break;
            case GL_ONE_MINUS_CONSTANT_ALPHA:
               sA = 1.0F - ctx->Color.BlendColor[3];
               break;
            case GL_SRC_COLOR:
               sA = As;
               break;
            case GL_ONE_MINUS_SRC_COLOR:
               sA = 1.0F - As;
               break;
            default:
               /* this should never happen */
               sA = 0.0F;
               _mesa_problem(ctx, "Bad blend source A factor in blend_general_float");
               return;
         }

         /* Dest RGB factor */
         switch (ctx->Color.Blend[0].DstRGB) {
            case GL_ZERO:
               dR = dG = dB = 0.0F;
               break;
            case GL_ONE:
               dR = dG = dB = 1.0F;
               break;
            case GL_SRC_COLOR:
               dR = Rs;
               dG = Gs;
               dB = Bs;
               break;
            case GL_ONE_MINUS_SRC_COLOR:
               dR = 1.0F - Rs;
               dG = 1.0F - Gs;
               dB = 1.0F - Bs;
               break;
            case GL_SRC_ALPHA:
               dR = dG = dB = As;
               break;
            case GL_ONE_MINUS_SRC_ALPHA:
               dR = dG = dB = 1.0F - As;
               break;
            case GL_DST_ALPHA:
               dR = dG = dB = Ad;
               break;
            case GL_ONE_MINUS_DST_ALPHA:
               dR = dG = dB = 1.0F - Ad;
               break;
            case GL_CONSTANT_COLOR:
               dR = ctx->Color.BlendColor[0];
               dG = ctx->Color.BlendColor[1];
               dB = ctx->Color.BlendColor[2];
               break;
            case GL_ONE_MINUS_CONSTANT_COLOR:
               dR = 1.0F - ctx->Color.BlendColor[0];
               dG = 1.0F - ctx->Color.BlendColor[1];
               dB = 1.0F - ctx->Color.BlendColor[2];
               break;
            case GL_CONSTANT_ALPHA:
               dR = dG = dB = ctx->Color.BlendColor[3];
               break;
            case GL_ONE_MINUS_CONSTANT_ALPHA:
               dR = dG = dB = 1.0F - ctx->Color.BlendColor[3];
               break;
            case GL_DST_COLOR:
               dR = Rd;
               dG = Gd;
               dB = Bd;
               break;
            case GL_ONE_MINUS_DST_COLOR:
               dR = 1.0F - Rd;
               dG = 1.0F - Gd;
               dB = 1.0F - Bd;
               break;
            default:
               /* this should never happen */
               dR = dG = dB = 0.0F;
               _mesa_problem(ctx, "Bad blend dest RGB factor in blend_general_float");
               return;
         }

         /* Dest Alpha factor */
         switch (ctx->Color.Blend[0].DstA) {
            case GL_ZERO:
               dA = 0.0F;
               break;
            case GL_ONE:
               dA = 1.0F;
               break;
            case GL_SRC_COLOR:
               dA = As;
               break;
            case GL_ONE_MINUS_SRC_COLOR:
               dA = 1.0F - As;
               break;
            case GL_SRC_ALPHA:
               dA = As;
               break;
            case GL_ONE_MINUS_SRC_ALPHA:
               dA = 1.0F - As;
               break;
            case GL_DST_ALPHA:
               dA = Ad;
               break;
            case GL_ONE_MINUS_DST_ALPHA:
               dA = 1.0F - Ad;
               break;
            case GL_CONSTANT_COLOR:
               dA = ctx->Color.BlendColor[3];
               break;
            case GL_ONE_MINUS_CONSTANT_COLOR:
               dA = 1.0F - ctx->Color.BlendColor[3];
               break;
            case GL_CONSTANT_ALPHA:
               dA = ctx->Color.BlendColor[3];
               break;
            case GL_ONE_MINUS_CONSTANT_ALPHA:
               dA = 1.0F - ctx->Color.BlendColor[3];
               break;
            case GL_DST_COLOR:
               dA = Ad;
               break;
            case GL_ONE_MINUS_DST_COLOR:
               dA = 1.0F - Ad;
               break;
            default:
               /* this should never happen */
               dA = 0.0F;
               _mesa_problem(ctx, "Bad blend dest A factor in blend_general_float");
               return;
         }

         /* compute the blended RGB */
         switch (ctx->Color.Blend[0].EquationRGB) {
         case GL_FUNC_ADD:
            r = Rs * sR + Rd * dR;
            g = Gs * sG + Gd * dG;
            b = Bs * sB + Bd * dB;
            a = As * sA + Ad * dA;
            break;
         case GL_FUNC_SUBTRACT:
            r = Rs * sR - Rd * dR;
            g = Gs * sG - Gd * dG;
            b = Bs * sB - Bd * dB;
            a = As * sA - Ad * dA;
            break;
         case GL_FUNC_REVERSE_SUBTRACT:
            r = Rd * dR - Rs * sR;
            g = Gd * dG - Gs * sG;
            b = Bd * dB - Bs * sB;
            a = Ad * dA - As * sA;
            break;
         case GL_MIN:
	    r = MIN2( Rd, Rs );
	    g = MIN2( Gd, Gs );
	    b = MIN2( Bd, Bs );
            break;
         case GL_MAX:
	    r = MAX2( Rd, Rs );
	    g = MAX2( Gd, Gs );
	    b = MAX2( Bd, Bs );
            break;
	 default:
            /* should never get here */
            r = g = b = 0.0F;  /* silence uninitialized var warning */
            _mesa_problem(ctx, "unexpected BlendEquation in blend_general()");
            return;
         }

         /* compute the blended alpha */
         switch (ctx->Color.Blend[0].EquationA) {
         case GL_FUNC_ADD:
            a = As * sA + Ad * dA;
            break;
         case GL_FUNC_SUBTRACT:
            a = As * sA - Ad * dA;
            break;
         case GL_FUNC_REVERSE_SUBTRACT:
            a = Ad * dA - As * sA;
            break;
         case GL_MIN:
	    a = MIN2( Ad, As );
            break;
         case GL_MAX:
	    a = MAX2( Ad, As );
            break;
         default:
            /* should never get here */
            a = 0.0F;  /* silence uninitialized var warning */
            _mesa_problem(ctx, "unexpected BlendEquation in blend_general()");
            return;
         }

         /* final clamping */
#if 0
         rgba[i][RCOMP] = MAX2( r, 0.0F );
         rgba[i][GCOMP] = MAX2( g, 0.0F );
         rgba[i][BCOMP] = MAX2( b, 0.0F );
         rgba[i][ACOMP] = CLAMP( a, 0.0F, 1.0F );
#else
         ASSIGN_4V(rgba[i], r, g, b, a);
#endif
      }
   }
}


/**
 * Do any blending operation, any chanType.
 */
static void
blend_general(struct gl_context *ctx, GLuint n, const GLubyte mask[],
              void *src, const void *dst, GLenum chanType)
{
   GLfloat (*rgbaF)[4], (*destF)[4];

   rgbaF = (GLfloat (*)[4]) malloc(4 * n * sizeof(GLfloat));
   destF = (GLfloat (*)[4]) malloc(4 * n * sizeof(GLfloat));
   if (!rgbaF || !destF) {
      free(rgbaF);
      free(destF);
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "blending");
      return;
   }

   if (chanType == GL_UNSIGNED_BYTE) {
      GLubyte (*rgba)[4] = (GLubyte (*)[4]) src;
      const GLubyte (*dest)[4] = (const GLubyte (*)[4]) dst;
      GLuint i;
      /* convert ubytes to floats */
      for (i = 0; i < n; i++) {
         if (mask[i]) {
            rgbaF[i][RCOMP] = UBYTE_TO_FLOAT(rgba[i][RCOMP]);
            rgbaF[i][GCOMP] = UBYTE_TO_FLOAT(rgba[i][GCOMP]);
            rgbaF[i][BCOMP] = UBYTE_TO_FLOAT(rgba[i][BCOMP]);
            rgbaF[i][ACOMP] = UBYTE_TO_FLOAT(rgba[i][ACOMP]);
            destF[i][RCOMP] = UBYTE_TO_FLOAT(dest[i][RCOMP]);
            destF[i][GCOMP] = UBYTE_TO_FLOAT(dest[i][GCOMP]);
            destF[i][BCOMP] = UBYTE_TO_FLOAT(dest[i][BCOMP]);
            destF[i][ACOMP] = UBYTE_TO_FLOAT(dest[i][ACOMP]);
         }
      }
      /* do blend */
      blend_general_float(ctx, n, mask, rgbaF, destF, chanType);
      /* convert back to ubytes */
      for (i = 0; i < n; i++) {
         if (mask[i])
	   _mesa_unclamped_float_rgba_to_ubyte(rgba[i], rgbaF[i]);
      }
   }
   else if (chanType == GL_UNSIGNED_SHORT) {
      GLushort (*rgba)[4] = (GLushort (*)[4]) src;
      const GLushort (*dest)[4] = (const GLushort (*)[4]) dst;
      GLuint i;
      /* convert ushorts to floats */
      for (i = 0; i < n; i++) {
         if (mask[i]) {
            rgbaF[i][RCOMP] = USHORT_TO_FLOAT(rgba[i][RCOMP]);
            rgbaF[i][GCOMP] = USHORT_TO_FLOAT(rgba[i][GCOMP]);
            rgbaF[i][BCOMP] = USHORT_TO_FLOAT(rgba[i][BCOMP]);
            rgbaF[i][ACOMP] = USHORT_TO_FLOAT(rgba[i][ACOMP]);
            destF[i][RCOMP] = USHORT_TO_FLOAT(dest[i][RCOMP]);
            destF[i][GCOMP] = USHORT_TO_FLOAT(dest[i][GCOMP]);
            destF[i][BCOMP] = USHORT_TO_FLOAT(dest[i][BCOMP]);
            destF[i][ACOMP] = USHORT_TO_FLOAT(dest[i][ACOMP]);
         }
      }
      /* do blend */
      blend_general_float(ctx, n, mask, rgbaF, destF, chanType);
      /* convert back to ushorts */
      for (i = 0; i < n; i++) {
         if (mask[i]) {
            UNCLAMPED_FLOAT_TO_USHORT(rgba[i][RCOMP], rgbaF[i][RCOMP]);
            UNCLAMPED_FLOAT_TO_USHORT(rgba[i][GCOMP], rgbaF[i][GCOMP]);
            UNCLAMPED_FLOAT_TO_USHORT(rgba[i][BCOMP], rgbaF[i][BCOMP]);
            UNCLAMPED_FLOAT_TO_USHORT(rgba[i][ACOMP], rgbaF[i][ACOMP]);
         }
      }
   }
   else {
      blend_general_float(ctx, n, mask, (GLfloat (*)[4]) src,
                          (GLfloat (*)[4]) dst, chanType);
   }

   free(rgbaF);
   free(destF);
}



/**
 * Analyze current blending parameters to pick fastest blending function.
 * Result: the ctx->Color.BlendFunc pointer is updated.
 */
void
_swrast_choose_blend_func(struct gl_context *ctx, GLenum chanType)
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
   const GLenum eq = ctx->Color.Blend[0].EquationRGB;
   const GLenum srcRGB = ctx->Color.Blend[0].SrcRGB;
   const GLenum dstRGB = ctx->Color.Blend[0].DstRGB;
   const GLenum srcA = ctx->Color.Blend[0].SrcA;
   const GLenum dstA = ctx->Color.Blend[0].DstA;

   if (ctx->Color.Blend[0].EquationRGB != ctx->Color.Blend[0].EquationA) {
      swrast->BlendFunc = blend_general;
   }
   else if (eq == GL_MIN) {
      /* Note: GL_MIN ignores the blending weight factors */
#if defined(USE_MMX_ASM)
      if (cpu_has_mmx && chanType == GL_UNSIGNED_BYTE) {
         swrast->BlendFunc = _mesa_mmx_blend_min;
      }
      else
#endif
         swrast->BlendFunc = blend_min;
   }
   else if (eq == GL_MAX) {
      /* Note: GL_MAX ignores the blending weight factors */
#if defined(USE_MMX_ASM)
      if (cpu_has_mmx && chanType == GL_UNSIGNED_BYTE) {
         swrast->BlendFunc = _mesa_mmx_blend_max;
      }
      else
#endif
         swrast->BlendFunc = blend_max;
   }
   else if (srcRGB != srcA || dstRGB != dstA) {
      swrast->BlendFunc = blend_general;
   }
   else if (eq == GL_FUNC_ADD && srcRGB == GL_SRC_ALPHA
            && dstRGB == GL_ONE_MINUS_SRC_ALPHA) {
#if defined(USE_MMX_ASM)
      if (cpu_has_mmx && chanType == GL_UNSIGNED_BYTE) {
         swrast->BlendFunc = _mesa_mmx_blend_transparency;
      }
      else
#endif
      {
         if (chanType == GL_UNSIGNED_BYTE)
            swrast->BlendFunc = blend_transparency_ubyte;
         else if (chanType == GL_UNSIGNED_SHORT)
            swrast->BlendFunc = blend_transparency_ushort;
         else
            swrast->BlendFunc = blend_transparency_float;
      }
   }
   else if (eq == GL_FUNC_ADD && srcRGB == GL_ONE && dstRGB == GL_ONE) {
#if defined(USE_MMX_ASM)
      if (cpu_has_mmx && chanType == GL_UNSIGNED_BYTE) {
         swrast->BlendFunc = _mesa_mmx_blend_add;
      }
      else
#endif
         swrast->BlendFunc = blend_add;
   }
   else if (((eq == GL_FUNC_ADD || eq == GL_FUNC_REVERSE_SUBTRACT)
	     && (srcRGB == GL_ZERO && dstRGB == GL_SRC_COLOR))
	    ||
	    ((eq == GL_FUNC_ADD || eq == GL_FUNC_SUBTRACT)
	     && (srcRGB == GL_DST_COLOR && dstRGB == GL_ZERO))) {
#if defined(USE_MMX_ASM)
      if (cpu_has_mmx && chanType == GL_UNSIGNED_BYTE) {
         swrast->BlendFunc = _mesa_mmx_blend_modulate;
      }
      else
#endif
         swrast->BlendFunc = blend_modulate;
   }
   else if (eq == GL_FUNC_ADD && srcRGB == GL_ZERO && dstRGB == GL_ONE) {
      swrast->BlendFunc = blend_noop;
   }
   else if (eq == GL_FUNC_ADD && srcRGB == GL_ONE && dstRGB == GL_ZERO) {
      swrast->BlendFunc = blend_replace;
   }
   else {
      swrast->BlendFunc = blend_general;
   }
}



/**
 * Apply the blending operator to a span of pixels.
 * We can handle horizontal runs of pixels (spans) or arrays of x/y
 * pixel coordinates.
 */
void
_swrast_blend_span(struct gl_context *ctx, struct gl_renderbuffer *rb, SWspan *span)
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
   void *rbPixels;

   ASSERT(span->end <= SWRAST_MAX_WIDTH);
   ASSERT(span->arrayMask & SPAN_RGBA);
   ASSERT(!ctx->Color.ColorLogicOpEnabled);

   rbPixels = _swrast_get_dest_rgba(ctx, rb, span);

   swrast->BlendFunc(ctx, span->end, span->array->mask,
                     span->array->rgba, rbPixels, span->array->ChanType);
}
@


1.7
log
@Merge Mesa 9.2.0
@
text
@@


1.6
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a2 1
 * Version:  7.1
d19 4
a22 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
d854 2
a855 6
         if (mask[i]) {
            UNCLAMPED_FLOAT_TO_UBYTE(rgba[i][RCOMP], rgbaF[i][RCOMP]);
            UNCLAMPED_FLOAT_TO_UBYTE(rgba[i][GCOMP], rgbaF[i][GCOMP]);
            UNCLAMPED_FLOAT_TO_UBYTE(rgba[i][BCOMP], rgbaF[i][BCOMP]);
            UNCLAMPED_FLOAT_TO_UBYTE(rgba[i][ACOMP], rgbaF[i][ACOMP]);
         }
d1001 1
a1001 1
   ASSERT(span->end <= MAX_WIDTH);
d1003 1
a1003 2
   ASSERT(rb->DataType == span->array->ChanType);
   ASSERT(!ctx->Color._LogicOpEnabled);
@


1.5
log
@Merge Mesa 7.10.3
@
text
@d78 4
a81 4
   ASSERT(ctx->Color.BlendEquationRGB == GL_FUNC_ADD);
   ASSERT(ctx->Color.BlendEquationA == GL_FUNC_ADD);
   ASSERT(ctx->Color.BlendSrcRGB == GL_ZERO);
   ASSERT(ctx->Color.BlendDstRGB == GL_ONE);
d104 4
a107 4
   ASSERT(ctx->Color.BlendEquationRGB == GL_FUNC_ADD);
   ASSERT(ctx->Color.BlendEquationA == GL_FUNC_ADD);
   ASSERT(ctx->Color.BlendSrcRGB == GL_ONE);
   ASSERT(ctx->Color.BlendDstRGB == GL_ZERO);
d128 6
a133 6
   ASSERT(ctx->Color.BlendEquationRGB == GL_FUNC_ADD);
   ASSERT(ctx->Color.BlendEquationA == GL_FUNC_ADD);
   ASSERT(ctx->Color.BlendSrcRGB == GL_SRC_ALPHA);
   ASSERT(ctx->Color.BlendSrcA == GL_SRC_ALPHA);
   ASSERT(ctx->Color.BlendDstRGB == GL_ONE_MINUS_SRC_ALPHA);
   ASSERT(ctx->Color.BlendDstA == GL_ONE_MINUS_SRC_ALPHA);
d173 6
a178 6
   ASSERT(ctx->Color.BlendEquationRGB == GL_FUNC_ADD);
   ASSERT(ctx->Color.BlendEquationA == GL_FUNC_ADD);
   ASSERT(ctx->Color.BlendSrcRGB == GL_SRC_ALPHA);
   ASSERT(ctx->Color.BlendSrcA == GL_SRC_ALPHA);
   ASSERT(ctx->Color.BlendDstRGB == GL_ONE_MINUS_SRC_ALPHA);
   ASSERT(ctx->Color.BlendDstA == GL_ONE_MINUS_SRC_ALPHA);
d211 6
a216 6
   ASSERT(ctx->Color.BlendEquationRGB == GL_FUNC_ADD);
   ASSERT(ctx->Color.BlendEquationA == GL_FUNC_ADD);
   ASSERT(ctx->Color.BlendSrcRGB == GL_SRC_ALPHA);
   ASSERT(ctx->Color.BlendSrcA == GL_SRC_ALPHA);
   ASSERT(ctx->Color.BlendDstRGB == GL_ONE_MINUS_SRC_ALPHA);
   ASSERT(ctx->Color.BlendDstA == GL_ONE_MINUS_SRC_ALPHA);
d251 4
a254 4
   ASSERT(ctx->Color.BlendEquationRGB == GL_FUNC_ADD);
   ASSERT(ctx->Color.BlendEquationA == GL_FUNC_ADD);
   ASSERT(ctx->Color.BlendSrcRGB == GL_ONE);
   ASSERT(ctx->Color.BlendDstRGB == GL_ONE);
d316 2
a317 2
   ASSERT(ctx->Color.BlendEquationRGB == GL_MIN);
   ASSERT(ctx->Color.BlendEquationA == GL_MIN);
d369 2
a370 2
   ASSERT(ctx->Color.BlendEquationRGB == GL_MAX);
   ASSERT(ctx->Color.BlendEquationA == GL_MAX);
d503 1
a503 1
         switch (ctx->Color.BlendSrcRGB) {
d573 1
a573 1
         switch (ctx->Color.BlendSrcA) {
d627 1
a627 1
         switch (ctx->Color.BlendDstRGB) {
d690 1
a690 1
         switch (ctx->Color.BlendDstA) {
d741 1
a741 1
         switch (ctx->Color.BlendEquationRGB) {
d778 1
a778 1
         switch (ctx->Color.BlendEquationA) {
d910 5
a914 5
   const GLenum eq = ctx->Color.BlendEquationRGB;
   const GLenum srcRGB = ctx->Color.BlendSrcRGB;
   const GLenum dstRGB = ctx->Color.BlendDstRGB;
   const GLenum srcA = ctx->Color.BlendSrcA;
   const GLenum dstA = ctx->Color.BlendDstA;
d916 1
a916 1
   if (ctx->Color.BlendEquationRGB != ctx->Color.BlendEquationA) {
@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d73 1
a73 1
blend_noop(GLcontext *ctx, GLuint n, const GLubyte mask[],
d101 1
a101 1
blend_replace(GLcontext *ctx, GLuint n, const GLubyte mask[],
d121 1
a121 1
blend_transparency_ubyte(GLcontext *ctx, GLuint n, const GLubyte mask[],
d166 1
a166 1
blend_transparency_ushort(GLcontext *ctx, GLuint n, const GLubyte mask[],
d204 1
a204 1
blend_transparency_float(GLcontext *ctx, GLuint n, const GLubyte mask[],
d246 1
a246 1
blend_add(GLcontext *ctx, GLuint n, const GLubyte mask[],
d312 1
a312 1
blend_min(GLcontext *ctx, GLuint n, const GLubyte mask[],
d365 1
a365 1
blend_max(GLcontext *ctx, GLuint n, const GLubyte mask[],
d419 1
a419 1
blend_modulate(GLcontext *ctx, GLuint n, const GLubyte mask[],
d474 1
a474 1
blend_general_float(GLcontext *ctx, GLuint n, const GLubyte mask[],
d819 1
a819 1
blend_general(GLcontext *ctx, GLuint n, const GLubyte mask[],
d822 10
a831 1
   GLfloat rgbaF[MAX_WIDTH][4], destF[MAX_WIDTH][4];
d895 3
d907 1
a907 1
_swrast_choose_blend_func(GLcontext *ctx, GLenum chanType)
d1000 1
a1000 1
_swrast_blend_span(GLcontext *ctx, struct gl_renderbuffer *rb, SWspan *span)
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d92 1
a92 1
   _mesa_memcpy(src, dst, bytes);
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d38 4
a41 4
#include "glheader.h"
#include "context.h"
#include "colormac.h"
#include "macros.h"
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * Version:  6.3
d5 1
a5 1
 * Copyright (C) 1999-2005  Brian Paul   All Rights Reserved.
d25 5
a29 2
/*
 * Regarding GL_NV_blend_square:
d31 3
a33 4
 * Portions of this software may use or implement intellectual
 * property owned and licensed by NVIDIA Corporation. NVIDIA disclaims
 * any and all warranties with respect to such intellectual property,
 * including any use thereof or modifications thereto.
d37 1
d57 14
a70 2
/*
 * Special case for glBlendFunc(GL_ZERO, GL_ONE)
d73 2
a74 2
blend_noop( GLcontext *ctx, GLuint n, const GLubyte mask[],
            GLchan rgba[][4], CONST GLchan dest[][4] )
d76 6
a81 5
   GLuint i;
   ASSERT(ctx->Color.BlendEquationRGB==GL_FUNC_ADD);
   ASSERT(ctx->Color.BlendEquationA==GL_FUNC_ADD);
   ASSERT(ctx->Color.BlendSrcRGB==GL_ZERO);
   ASSERT(ctx->Color.BlendDstRGB==GL_ONE);
d84 9
a92 5
   for (i = 0; i < n; i++) {
      if (mask[i]) {
         COPY_CHAN4( rgba[i], dest[i] );
      }
   }
d96 1
a96 1
/*
d98 1
d101 2
a102 2
blend_replace( GLcontext *ctx, GLuint n, const GLubyte mask[],
               GLchan rgba[][4], CONST GLchan dest[][4] )
d104 4
a107 4
   ASSERT(ctx->Color.BlendEquationRGB==GL_FUNC_ADD);
   ASSERT(ctx->Color.BlendEquationA==GL_FUNC_ADD);
   ASSERT(ctx->Color.BlendSrcRGB==GL_ONE);
   ASSERT(ctx->Color.BlendDstRGB==GL_ZERO);
d111 2
a112 2
   (void) rgba;
   (void) dest;
d116 3
a118 2
/*
 * Common transparency blending mode.
d121 2
a122 2
blend_transparency( GLcontext *ctx, GLuint n, const GLubyte mask[],
                    GLchan rgba[][4], CONST GLchan dest[][4] )
d124 2
d127 9
a135 4
   ASSERT(ctx->Color.BlendEquationRGB==GL_FUNC_ADD);
   ASSERT(ctx->Color.BlendEquationA==GL_FUNC_ADD);
   ASSERT(ctx->Color.BlendSrcRGB==GL_SRC_ALPHA);
   ASSERT(ctx->Color.BlendDstRGB==GL_ONE_MINUS_SRC_ALPHA);
d138 1
a138 1
   for (i=0;i<n;i++) {
d140 1
a140 1
         const GLchan t = rgba[i][ACOMP];  /* t in [0, CHAN_MAX] */
d143 1
a143 7
            rgba[i][RCOMP] = dest[i][RCOMP];
            rgba[i][GCOMP] = dest[i][GCOMP];
            rgba[i][BCOMP] = dest[i][BCOMP];
            rgba[i][ACOMP] = dest[i][ACOMP];
         }
         else if (t == CHAN_MAX) {
            /* 100% alpha, no-op */
d145 2
a146 25
         else {
#if 0
            /* This is pretty close, but Glean complains */
            const GLint s = CHAN_MAX - t;
            const GLint r = (rgba[i][RCOMP] * t + dest[i][RCOMP] * s + 1) >> 8;
            const GLint g = (rgba[i][GCOMP] * t + dest[i][GCOMP] * s + 1) >> 8;
            const GLint b = (rgba[i][BCOMP] * t + dest[i][BCOMP] * s + 1) >> 8;
            const GLint a = (rgba[i][ACOMP] * t + dest[i][ACOMP] * s + 1) >> 8;
#elif 0
            /* This is slower but satisfies Glean */
            const GLint s = CHAN_MAX - t;
            const GLint r = (rgba[i][RCOMP] * t + dest[i][RCOMP] * s) / 255;
            const GLint g = (rgba[i][GCOMP] * t + dest[i][GCOMP] * s) / 255;
            const GLint b = (rgba[i][BCOMP] * t + dest[i][BCOMP] * s) / 255;
            const GLint a = (rgba[i][ACOMP] * t + dest[i][ACOMP] * s) / 255;
#else
#if CHAN_BITS == 8
            /* This satisfies Glean and should be reasonably fast */
            /* Contributed by Nathan Hand */
#if 0
#define DIV255(X)  (((X) << 8) + (X) + 256) >> 16
#else
	    GLint temp;
#define DIV255(X)  (temp = (X), ((temp << 8) + temp + 256) >> 16)
#endif
d151 31
d183 14
a196 24
#undef DIV255
#elif CHAN_BITS == 16
            const GLfloat tt = (GLfloat) t / CHAN_MAXF;
            const GLint r = (GLint) ((rgba[i][RCOMP] - dest[i][RCOMP]) * tt + dest[i][RCOMP]);
            const GLint g = (GLint) ((rgba[i][GCOMP] - dest[i][GCOMP]) * tt + dest[i][GCOMP]);
            const GLint b = (GLint) ((rgba[i][BCOMP] - dest[i][BCOMP]) * tt + dest[i][BCOMP]);
            const GLint a = (GLint) ((rgba[i][ACOMP] - dest[i][ACOMP]) * tt + dest[i][ACOMP]);
#else /* CHAN_BITS == 32 */
            const GLfloat tt = (GLfloat) t / CHAN_MAXF;
            const GLfloat r = (rgba[i][RCOMP] - dest[i][RCOMP]) * tt + dest[i][RCOMP];
            const GLfloat g = (rgba[i][GCOMP] - dest[i][GCOMP]) * tt + dest[i][GCOMP];
            const GLfloat b = (rgba[i][BCOMP] - dest[i][BCOMP]) * tt + dest[i][BCOMP];
            const GLfloat a = CLAMP( rgba[i][ACOMP], 0.0F, CHAN_MAXF ) * t +
                              CLAMP( dest[i][ACOMP], 0.0F, CHAN_MAXF ) * (1.0F - t);
#endif
#endif
            ASSERT(r <= CHAN_MAX);
            ASSERT(g <= CHAN_MAX);
            ASSERT(b <= CHAN_MAX);
            ASSERT(a <= CHAN_MAX);
            rgba[i][RCOMP] = (GLchan) r;
            rgba[i][GCOMP] = (GLchan) g;
            rgba[i][BCOMP] = (GLchan) b;
            rgba[i][ACOMP] = (GLchan) a;
a202 4

/*
 * Add src and dest.
 */
d204 2
a205 2
blend_add( GLcontext *ctx, GLuint n, const GLubyte mask[],
           GLchan rgba[][4], CONST GLchan dest[][4] )
d207 2
d210 9
a218 4
   ASSERT(ctx->Color.BlendEquationRGB==GL_FUNC_ADD);
   ASSERT(ctx->Color.BlendEquationA==GL_FUNC_ADD);
   ASSERT(ctx->Color.BlendSrcRGB==GL_ONE);
   ASSERT(ctx->Color.BlendDstRGB==GL_ONE);
d221 1
a221 1
   for (i=0;i<n;i++) {
d223 12
a234 17
#if CHAN_TYPE == GL_FLOAT
         /* don't RGB clamp to max */
         GLfloat a = CLAMP(rgba[i][ACOMP], 0.0F, CHAN_MAXF) + dest[i][ACOMP];
         rgba[i][RCOMP] += dest[i][RCOMP];
         rgba[i][GCOMP] += dest[i][GCOMP];
         rgba[i][BCOMP] += dest[i][BCOMP];
         rgba[i][ACOMP] = (GLchan) MIN2( a, CHAN_MAXF );
#else
         GLint r = rgba[i][RCOMP] + dest[i][RCOMP];
         GLint g = rgba[i][GCOMP] + dest[i][GCOMP];
         GLint b = rgba[i][BCOMP] + dest[i][BCOMP];
         GLint a = rgba[i][ACOMP] + dest[i][ACOMP];
         rgba[i][RCOMP] = (GLchan) MIN2( r, CHAN_MAX );
         rgba[i][GCOMP] = (GLchan) MIN2( g, CHAN_MAX );
         rgba[i][BCOMP] = (GLchan) MIN2( b, CHAN_MAX );
         rgba[i][ACOMP] = (GLchan) MIN2( a, CHAN_MAX );
#endif
d241 3
a243 2
/*
 * Blend min function  (for GL_EXT_blend_minmax)
d246 2
a247 2
blend_min( GLcontext *ctx, GLuint n, const GLubyte mask[],
           GLchan rgba[][4], CONST GLchan dest[][4] )
d250 5
a254 2
   ASSERT(ctx->Color.BlendEquationRGB==GL_MIN);
   ASSERT(ctx->Color.BlendEquationA==GL_MIN);
d257 44
a300 11
   for (i=0;i<n;i++) {
      if (mask[i]) {
         rgba[i][RCOMP] = (GLchan) MIN2( rgba[i][RCOMP], dest[i][RCOMP] );
         rgba[i][GCOMP] = (GLchan) MIN2( rgba[i][GCOMP], dest[i][GCOMP] );
         rgba[i][BCOMP] = (GLchan) MIN2( rgba[i][BCOMP], dest[i][BCOMP] );
#if CHAN_TYPE == GL_FLOAT
         rgba[i][ACOMP] = (GLchan) MIN2(CLAMP(rgba[i][ACOMP], 0.0F, CHAN_MAXF),
                                        dest[i][ACOMP]);
#else
         rgba[i][ACOMP] = (GLchan) MIN2( rgba[i][ACOMP], dest[i][ACOMP] );
#endif
d307 3
a309 2
/*
 * Blend max function  (for GL_EXT_blend_minmax)
d312 2
a313 2
blend_max( GLcontext *ctx, GLuint n, const GLubyte mask[],
           GLchan rgba[][4], CONST GLchan dest[][4] )
d316 2
a317 2
   ASSERT(ctx->Color.BlendEquationRGB==GL_MAX);
   ASSERT(ctx->Color.BlendEquationA==GL_MAX);
d320 35
a354 11
   for (i=0;i<n;i++) {
      if (mask[i]) {
         rgba[i][RCOMP] = (GLchan) MAX2( rgba[i][RCOMP], dest[i][RCOMP] );
         rgba[i][GCOMP] = (GLchan) MAX2( rgba[i][GCOMP], dest[i][GCOMP] );
         rgba[i][BCOMP] = (GLchan) MAX2( rgba[i][BCOMP], dest[i][BCOMP] );
#if CHAN_TYPE == GL_FLOAT
         rgba[i][ACOMP] = (GLchan) MAX2(CLAMP(rgba[i][ACOMP], 0.0F, CHAN_MAXF),
                                        dest[i][ACOMP]);
#else
         rgba[i][ACOMP] = (GLchan) MAX2( rgba[i][ACOMP], dest[i][ACOMP] );
#endif
d360 3
a362 3

/*
 * Modulate:  result = src * dest
d365 2
a366 2
blend_modulate( GLcontext *ctx, GLuint n, const GLubyte mask[],
                GLchan rgba[][4], CONST GLchan dest[][4] )
d369 2
d373 35
a407 26
   for (i=0;i<n;i++) {
      if (mask[i]) {
#if CHAN_TYPE == GL_FLOAT
         rgba[i][RCOMP] = rgba[i][RCOMP] * dest[i][RCOMP];
         rgba[i][GCOMP] = rgba[i][GCOMP] * dest[i][GCOMP];
         rgba[i][BCOMP] = rgba[i][BCOMP] * dest[i][BCOMP];
         rgba[i][ACOMP] = rgba[i][ACOMP] * dest[i][ACOMP];
#elif CHAN_TYPE == GL_UNSIGNED_SHORT
         GLint r = (rgba[i][RCOMP] * dest[i][RCOMP] + 65535) >> 16;
         GLint g = (rgba[i][GCOMP] * dest[i][GCOMP] + 65535) >> 16;
         GLint b = (rgba[i][BCOMP] * dest[i][BCOMP] + 65535) >> 16;
         GLint a = (rgba[i][ACOMP] * dest[i][ACOMP] + 65535) >> 16;
         rgba[i][RCOMP] = (GLchan) r;
         rgba[i][GCOMP] = (GLchan) g;
         rgba[i][BCOMP] = (GLchan) b;
         rgba[i][ACOMP] = (GLchan) a;
#else
         GLint r = (rgba[i][RCOMP] * dest[i][RCOMP] + 255) >> 8;
         GLint g = (rgba[i][GCOMP] * dest[i][GCOMP] + 255) >> 8;
         GLint b = (rgba[i][BCOMP] * dest[i][BCOMP] + 255) >> 8;
         GLint a = (rgba[i][ACOMP] * dest[i][ACOMP] + 255) >> 8;
         rgba[i][RCOMP] = (GLchan) r;
         rgba[i][GCOMP] = (GLchan) g;
         rgba[i][BCOMP] = (GLchan) b;
         rgba[i][ACOMP] = (GLchan) a;
#endif
d414 3
a416 6
/*
 * General case blend pixels.
 * Input:  n - number of pixels
 *         mask - the usual write mask
 * In/Out:  rgba - the incoming and modified pixels
 * Input:  dest - the pixels from the dest color buffer
d419 58
a476 2
blend_general( GLcontext *ctx, GLuint n, const GLubyte mask[],
               GLchan rgba[][4], CONST GLchan dest[][4] )
a477 4
   const GLfloat rscale = 1.0F / CHAN_MAXF;
   const GLfloat gscale = 1.0F / CHAN_MAXF;
   const GLfloat bscale = 1.0F / CHAN_MAXF;
   const GLfloat ascale = 1.0F / CHAN_MAXF;
d480 1
a480 1
   for (i=0;i<n;i++) {
a481 11
#if CHAN_TYPE == GL_FLOAT
         GLfloat Rs, Gs, Bs, As;  /* Source colors */
         GLfloat Rd, Gd, Bd, Ad;  /* Dest colors */
#else
         GLint Rs, Gs, Bs, As;  /* Source colors */
         GLint Rd, Gd, Bd, Ad;  /* Dest colors */
#endif
         GLfloat sR, sG, sB, sA;  /* Source scaling */
         GLfloat dR, dG, dB, dA;  /* Dest scaling */
         GLfloat r, g, b, a;      /* result color */

d483 4
a486 11
         Rs = rgba[i][RCOMP];
         Gs = rgba[i][GCOMP];
         Bs = rgba[i][BCOMP];
         As = rgba[i][ACOMP];
#if CHAN_TYPE == GL_FLOAT
         /* clamp */
         Rs = MIN2(Rs, CHAN_MAXF);
         Gs = MIN2(Gs, CHAN_MAXF);
         Bs = MIN2(Bs, CHAN_MAXF);
         As = MIN2(As, CHAN_MAXF);
#endif
d489 12
a500 11
         Rd = dest[i][RCOMP];
         Gd = dest[i][GCOMP];
         Bd = dest[i][BCOMP];
         Ad = dest[i][ACOMP];
#if CHAN_TYPE == GL_FLOAT
         /* clamp */
         Rd = MIN2(Rd, CHAN_MAXF);
         Gd = MIN2(Gd, CHAN_MAXF);
         Bd = MIN2(Bd, CHAN_MAXF);
         Ad = MIN2(Ad, CHAN_MAXF);
#endif
d511 3
a513 3
               sR = (GLfloat) Rd * rscale;
               sG = (GLfloat) Gd * gscale;
               sB = (GLfloat) Bd * bscale;
d516 3
a518 3
               sR = 1.0F - (GLfloat) Rd * rscale;
               sG = 1.0F - (GLfloat) Gd * gscale;
               sB = 1.0F - (GLfloat) Bd * bscale;
d521 1
a521 1
               sR = sG = sB = (GLfloat) As * ascale;
d524 1
a524 1
               sR = sG = sB = 1.0F - (GLfloat) As * ascale;
d527 1
a527 1
               sR = sG = sB = (GLfloat) Ad * ascale;
d530 1
a530 1
               sR = sG = sB = 1.0F - (GLfloat) Ad * ascale;
d533 2
a534 2
               if (As < CHAN_MAX - Ad) {
                  sR = sG = sB = (GLfloat) As * ascale;
d537 1
a537 1
                  sR = sG = sB = 1.0F - (GLfloat) Ad * ascale;
d556 9
a564 9
            case GL_SRC_COLOR: /* GL_NV_blend_square */
               sR = (GLfloat) Rs * rscale;
               sG = (GLfloat) Gs * gscale;
               sB = (GLfloat) Bs * bscale;
               break;
            case GL_ONE_MINUS_SRC_COLOR: /* GL_NV_blend_square */
               sR = 1.0F - (GLfloat) Rs * rscale;
               sG = 1.0F - (GLfloat) Gs * gscale;
               sB = 1.0F - (GLfloat) Bs * bscale;
d568 1
a568 1
               _mesa_problem(ctx, "Bad blend source RGB factor in do_blend");
d581 1
a581 1
               sA = (GLfloat) Ad * ascale;
d584 1
a584 1
               sA = 1.0F - (GLfloat) Ad * ascale;
d587 1
a587 1
               sA = (GLfloat) As * ascale;
d590 1
a590 1
               sA = 1.0F - (GLfloat) As * ascale;
d593 1
a593 1
               sA =(GLfloat) Ad * ascale;
d596 1
a596 1
               sA = 1.0F - (GLfloat) Ad * ascale;
d613 2
a614 2
            case GL_SRC_COLOR: /* GL_NV_blend_square */
               sA = (GLfloat) As * ascale;
d616 2
a617 2
            case GL_ONE_MINUS_SRC_COLOR: /* GL_NV_blend_square */
               sA = 1.0F - (GLfloat) As * ascale;
d622 2
a623 1
               _mesa_problem(ctx, "Bad blend source A factor in do_blend");
d635 3
a637 3
               dR = (GLfloat) Rs * rscale;
               dG = (GLfloat) Gs * gscale;
               dB = (GLfloat) Bs * bscale;
d640 3
a642 3
               dR = 1.0F - (GLfloat) Rs * rscale;
               dG = 1.0F - (GLfloat) Gs * gscale;
               dB = 1.0F - (GLfloat) Bs * bscale;
d645 1
a645 1
               dR = dG = dB = (GLfloat) As * ascale;
d648 1
a648 1
               dR = dG = dB = 1.0F - (GLfloat) As * ascale;
d651 1
a651 1
               dR = dG = dB = (GLfloat) Ad * ascale;
d654 1
a654 1
               dR = dG = dB = 1.0F - (GLfloat) Ad * ascale;
d672 9
a680 9
            case GL_DST_COLOR: /* GL_NV_blend_square */
               dR = (GLfloat) Rd * rscale;
               dG = (GLfloat) Gd * gscale;
               dB = (GLfloat) Bd * bscale;
               break;
            case GL_ONE_MINUS_DST_COLOR: /* GL_NV_blend_square */
               dR = 1.0F - (GLfloat) Rd * rscale;
               dG = 1.0F - (GLfloat) Gd * gscale;
               dB = 1.0F - (GLfloat) Bd * bscale;
d685 2
a686 1
               _mesa_problem(ctx, "Bad blend dest RGB factor in do_blend");
d698 1
a698 1
               dA = (GLfloat) As * ascale;
d701 1
a701 1
               dA = 1.0F - (GLfloat) As * ascale;
d704 1
a704 1
               dA = (GLfloat) As * ascale;
d707 1
a707 1
               dA = 1.0F - (GLfloat) As * ascale;
d710 1
a710 1
               dA = (GLfloat) Ad * ascale;
d713 1
a713 1
               dA = 1.0F - (GLfloat) Ad * ascale;
d727 2
a728 2
            case GL_DST_COLOR: /* GL_NV_blend_square */
               dA = (GLfloat) Ad * ascale;
d730 2
a731 2
            case GL_ONE_MINUS_DST_COLOR: /* GL_NV_blend_square */
               dA = 1.0F - (GLfloat) Ad * ascale;
d736 1
a736 1
               _mesa_problem(ctx, "Bad blend dest A factor in do_blend");
d740 3
a742 23
         /* Due to round-off problems we have to clamp against zero. */
         /* Optimization: we don't have to do this for all src & dst factors */
         if (dA < 0.0F)  dA = 0.0F;
         if (dR < 0.0F)  dR = 0.0F;
         if (dG < 0.0F)  dG = 0.0F;
         if (dB < 0.0F)  dB = 0.0F;
         if (sA < 0.0F)  sA = 0.0F;
         if (sR < 0.0F)  sR = 0.0F;
         if (sG < 0.0F)  sG = 0.0F;
         if (sB < 0.0F)  sB = 0.0F;

         ASSERT( sR <= 1.0 );
         ASSERT( sG <= 1.0 );
         ASSERT( sB <= 1.0 );
         ASSERT( sA <= 1.0 );
         ASSERT( dR <= 1.0 );
         ASSERT( dG <= 1.0 );
         ASSERT( dB <= 1.0 );
         ASSERT( dA <= 1.0 );

         /* compute blended color */
#if CHAN_TYPE == GL_FLOAT
         if (ctx->Color.BlendEquationRGB==GL_FUNC_ADD) {
d747 2
a748 2
         }
         else if (ctx->Color.BlendEquationRGB==GL_FUNC_SUBTRACT) {
d753 2
a754 2
         }
         else if (ctx->Color.BlendEquationRGB==GL_FUNC_REVERSE_SUBTRACT) {
d759 2
a760 2
         }
         else if (ctx->Color.BlendEquationRGB==GL_MIN) {
d764 2
a765 2
	 }
         else if (ctx->Color.BlendEquationRGB==GL_MAX) {
d769 2
a770 2
	 }
         else {
d774 1
d777 3
a779 1
         if (ctx->Color.BlendEquationA==GL_FUNC_ADD) {
d781 2
a782 2
         }
         else if (ctx->Color.BlendEquationA==GL_FUNC_SUBTRACT) {
d784 2
a785 2
         }
         else if (ctx->Color.BlendEquationA==GL_FUNC_REVERSE_SUBTRACT) {
d787 2
a788 2
         }
         else if (ctx->Color.BlendEquationA==GL_MIN) {
d790 2
a791 2
	 }
         else if (ctx->Color.BlendEquationA==GL_MAX) {
d793 2
a794 2
	 }
         else {
d798 1
d802 1
d806 1
a806 1
         rgba[i][ACOMP] = CLAMP( a, 0.0F, CHAN_MAXF );
d808 15
a822 30
         if (ctx->Color.BlendEquationRGB==GL_FUNC_ADD) {
            r = Rs * sR + Rd * dR + 0.5F;
            g = Gs * sG + Gd * dG + 0.5F;
            b = Bs * sB + Bd * dB + 0.5F;
         }
         else if (ctx->Color.BlendEquationRGB==GL_FUNC_SUBTRACT) {
            r = Rs * sR - Rd * dR + 0.5F;
            g = Gs * sG - Gd * dG + 0.5F;
            b = Bs * sB - Bd * dB + 0.5F;
         }
         else if (ctx->Color.BlendEquationRGB==GL_FUNC_REVERSE_SUBTRACT) {
            r = Rd * dR - Rs * sR + 0.5F;
            g = Gd * dG - Gs * sG + 0.5F;
            b = Bd * dB - Bs * sB + 0.5F;
         }
         else if (ctx->Color.BlendEquationRGB==GL_MIN) {
	    r = MIN2( Rd, Rs );
	    g = MIN2( Gd, Gs );
	    b = MIN2( Bd, Bs );
	 }
         else if (ctx->Color.BlendEquationRGB==GL_MAX) {
	    r = MAX2( Rd, Rs );
	    g = MAX2( Gd, Gs );
	    b = MAX2( Bd, Bs );
	 }
         else {
            /* should never get here */
            r = g = b = 0.0F;  /* silence uninitialized var warning */
            _mesa_problem(ctx, "unexpected BlendEquation in blend_general()");
         }
d824 26
a849 2
         if (ctx->Color.BlendEquationA==GL_FUNC_ADD) {
            a = As * sA + Ad * dA + 0.5F;
d851 28
a878 2
         else if (ctx->Color.BlendEquationA==GL_FUNC_SUBTRACT) {
            a = As * sA - Ad * dA + 0.5F;
a879 21
         else if (ctx->Color.BlendEquationA==GL_FUNC_REVERSE_SUBTRACT) {
            a = Ad * dA - As * sA + 0.5F;
         }
         else if (ctx->Color.BlendEquationA==GL_MIN) {
	    a = MIN2( Ad, As );
	 }
         else if (ctx->Color.BlendEquationA==GL_MAX) {
	    a = MAX2( Ad, As );
	 }
         else {
            /* should never get here */
            a = 0.0F;  /* silence uninitialized var warning */
            _mesa_problem(ctx, "unexpected BlendEquation in blend_general()");
         }

         /* final clamping */
         rgba[i][RCOMP] = (GLchan) (GLint) CLAMP( r, 0.0F, CHAN_MAXF );
         rgba[i][GCOMP] = (GLchan) (GLint) CLAMP( g, 0.0F, CHAN_MAXF );
         rgba[i][BCOMP] = (GLchan) (GLint) CLAMP( b, 0.0F, CHAN_MAXF );
         rgba[i][ACOMP] = (GLchan) (GLint) CLAMP( a, 0.0F, CHAN_MAXF );
#endif
d882 4
d889 2
a890 1
/*
d894 2
a895 1
void _swrast_choose_blend_func( GLcontext *ctx )
d897 1
d905 1
a905 1
      SWRAST_CONTEXT(ctx)->BlendFunc = blend_general;
d907 1
a907 1
   else if (eq==GL_MIN) {
d910 2
a911 2
      if ( cpu_has_mmx ) {
         SWRAST_CONTEXT(ctx)->BlendFunc = _mesa_mmx_blend_min;
d915 1
a915 1
         SWRAST_CONTEXT(ctx)->BlendFunc = blend_min;
d917 1
a917 1
   else if (eq==GL_MAX) {
d920 2
a921 2
      if ( cpu_has_mmx ) {
         SWRAST_CONTEXT(ctx)->BlendFunc = _mesa_mmx_blend_max;
d925 1
a925 1
         SWRAST_CONTEXT(ctx)->BlendFunc = blend_max;
d928 1
a928 1
      SWRAST_CONTEXT(ctx)->BlendFunc = blend_general;
d930 2
a931 2
   else if (eq==GL_FUNC_ADD && srcRGB==GL_SRC_ALPHA
            && dstRGB==GL_ONE_MINUS_SRC_ALPHA) {
d933 2
a934 2
      if ( cpu_has_mmx ) {
         SWRAST_CONTEXT(ctx)->BlendFunc = _mesa_mmx_blend_transparency;
d938 8
a945 1
	 SWRAST_CONTEXT(ctx)->BlendFunc = blend_transparency;
d947 1
a947 1
   else if (eq==GL_FUNC_ADD && srcRGB==GL_ONE && dstRGB==GL_ONE) {
d949 2
a950 2
      if ( cpu_has_mmx ) {
         SWRAST_CONTEXT(ctx)->BlendFunc = _mesa_mmx_blend_add;
d954 1
a954 1
         SWRAST_CONTEXT(ctx)->BlendFunc = blend_add;
d956 2
a957 2
   else if (((eq==GL_FUNC_ADD || eq==GL_FUNC_REVERSE_SUBTRACT)
	     && (srcRGB==GL_ZERO && dstRGB==GL_SRC_COLOR))
d959 2
a960 2
	    ((eq==GL_FUNC_ADD || eq==GL_FUNC_SUBTRACT)
	     && (srcRGB==GL_DST_COLOR && dstRGB==GL_ZERO))) {
d962 2
a963 2
      if ( cpu_has_mmx ) {
         SWRAST_CONTEXT(ctx)->BlendFunc = _mesa_mmx_blend_modulate;
d967 1
a967 1
         SWRAST_CONTEXT(ctx)->BlendFunc = blend_modulate;
d969 2
a970 2
   else if (eq==GL_FUNC_ADD && srcRGB == GL_ZERO && dstRGB == GL_ONE) {
      SWRAST_CONTEXT(ctx)->BlendFunc = blend_noop;
d972 2
a973 2
   else if (eq==GL_FUNC_ADD && srcRGB == GL_ONE && dstRGB == GL_ZERO) {
      SWRAST_CONTEXT(ctx)->BlendFunc = blend_replace;
d976 1
a976 1
      SWRAST_CONTEXT(ctx)->BlendFunc = blend_general;
d982 1
a982 1
/*
d988 1
a988 2
_swrast_blend_span(GLcontext *ctx, struct gl_renderbuffer *rb,
                   const struct sw_span *span, GLchan rgba[][4])
d990 2
a991 1
   GLchan framebuffer[MAX_WIDTH][4];
d995 1
d998 1
a998 11
   /* Read span of current frame buffer pixels */
   if (span->arrayMask & SPAN_XY) {
      /* array of x/y pixel coords */
      _swrast_get_values(ctx, rb, span->end, span->array->x, span->array->y,
                         framebuffer, 4 * sizeof(GLchan));
   }
   else {
      /* horizontal run of pixels */
      _swrast_read_rgba_span(ctx, rb, span->end, span->x, span->y,
                             framebuffer);
   }
d1000 2
a1001 2
   SWRAST_CONTEXT(ctx)->BlendFunc( ctx, span->end, span->array->mask, rgba,
				   (const GLchan (*)[4]) framebuffer );
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d3 1
a3 1
 * Version:  6.5.2
d5 1
a5 1
 * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
d25 2
a26 5

/**
 * \file swrast/s_blend.c
 * \brief software blending.
 * \author Brian Paul
d28 4
a31 3
 * Only a few blend modes have been optimized (min, max, transparency, add)
 * more optimized cases can easily be added if needed.
 * Celestia uses glBlendFunc(GL_SRC_ALPHA, GL_ONE), for example.
a34 1

d54 2
a55 14
/**
 * Integer divide by 255
 * Declare "int divtemp" before using.
 * This satisfies Glean and should be reasonably fast.
 * Contributed by Nathan Hand.
 */
#define DIV255(X)  (divtemp = (X), ((divtemp << 8) + divtemp + 256) >> 16)



/**
 * Special case for glBlendFunc(GL_ZERO, GL_ONE).
 * No-op means the framebuffer values remain unchanged.
 * Any chanType ok.
d58 2
a59 2
blend_noop(GLcontext *ctx, GLuint n, const GLubyte mask[],
           GLvoid *src, const GLvoid *dst, GLenum chanType)
d61 5
a65 6
   GLint bytes;

   ASSERT(ctx->Color.BlendEquationRGB == GL_FUNC_ADD);
   ASSERT(ctx->Color.BlendEquationA == GL_FUNC_ADD);
   ASSERT(ctx->Color.BlendSrcRGB == GL_ZERO);
   ASSERT(ctx->Color.BlendDstRGB == GL_ONE);
d68 5
a72 9
   /* just memcpy */
   if (chanType == GL_UNSIGNED_BYTE)
      bytes = 4 * n * sizeof(GLubyte);
   else if (chanType == GL_UNSIGNED_SHORT)
      bytes = 4 * n * sizeof(GLushort);
   else
      bytes = 4 * n * sizeof(GLfloat);

   _mesa_memcpy(src, dst, bytes);
d76 1
a76 1
/**
a77 1
 * Any chanType ok.
d80 2
a81 2
blend_replace(GLcontext *ctx, GLuint n, const GLubyte mask[],
              GLvoid *src, const GLvoid *dst, GLenum chanType)
d83 4
a86 4
   ASSERT(ctx->Color.BlendEquationRGB == GL_FUNC_ADD);
   ASSERT(ctx->Color.BlendEquationA == GL_FUNC_ADD);
   ASSERT(ctx->Color.BlendSrcRGB == GL_ONE);
   ASSERT(ctx->Color.BlendDstRGB == GL_ZERO);
d90 2
a91 2
   (void) src;
   (void) dst;
d95 2
a96 3
/**
 * Common transparency blending mode:
 * glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA).
d99 2
a100 2
blend_transparency_ubyte(GLcontext *ctx, GLuint n, const GLubyte mask[],
                         GLvoid *src, const GLvoid *dst, GLenum chanType)
a101 2
   GLubyte (*rgba)[4] = (GLubyte (*)[4]) src;
   const GLubyte (*dest)[4] = (const GLubyte (*)[4]) dst;
d103 4
a106 9

   ASSERT(ctx->Color.BlendEquationRGB == GL_FUNC_ADD);
   ASSERT(ctx->Color.BlendEquationA == GL_FUNC_ADD);
   ASSERT(ctx->Color.BlendSrcRGB == GL_SRC_ALPHA);
   ASSERT(ctx->Color.BlendSrcA == GL_SRC_ALPHA);
   ASSERT(ctx->Color.BlendDstRGB == GL_ONE_MINUS_SRC_ALPHA);
   ASSERT(ctx->Color.BlendDstA == GL_ONE_MINUS_SRC_ALPHA);
   ASSERT(chanType == GL_UNSIGNED_BYTE);

d109 1
a109 1
   for (i = 0; i < n; i++) {
d111 1
a111 1
         const GLint t = rgba[i][ACOMP];  /* t is in [0, 255] */
d114 7
a120 1
            COPY_4UBV(rgba[i], dest[i]);
d122 25
a146 2
         else if (t != 255) {
	    GLint divtemp;
d151 25
a175 8
            ASSERT(r <= 255);
            ASSERT(g <= 255);
            ASSERT(b <= 255);
            ASSERT(a <= 255);
            rgba[i][RCOMP] = (GLubyte) r;
            rgba[i][GCOMP] = (GLubyte) g;
            rgba[i][BCOMP] = (GLubyte) b;
            rgba[i][ACOMP] = (GLubyte) a;
a181 37
static void _BLENDAPI
blend_transparency_ushort(GLcontext *ctx, GLuint n, const GLubyte mask[],
                          GLvoid *src, const GLvoid *dst, GLenum chanType)
{
   GLushort (*rgba)[4] = (GLushort (*)[4]) src;
   const GLushort (*dest)[4] = (const GLushort (*)[4]) dst;
   GLuint i;

   ASSERT(ctx->Color.BlendEquationRGB == GL_FUNC_ADD);
   ASSERT(ctx->Color.BlendEquationA == GL_FUNC_ADD);
   ASSERT(ctx->Color.BlendSrcRGB == GL_SRC_ALPHA);
   ASSERT(ctx->Color.BlendSrcA == GL_SRC_ALPHA);
   ASSERT(ctx->Color.BlendDstRGB == GL_ONE_MINUS_SRC_ALPHA);
   ASSERT(ctx->Color.BlendDstA == GL_ONE_MINUS_SRC_ALPHA);
   ASSERT(chanType == GL_UNSIGNED_SHORT);

   (void) ctx;

   for (i = 0; i < n; i++) {
      if (mask[i]) {
         const GLint t = rgba[i][ACOMP];
         if (t == 0) {
            /* 0% alpha */
            COPY_4V(rgba[i], dest[i]);
         }
         else if (t != 65535) {
            const GLfloat tt = (GLfloat) t / 65535.0F;
            GLushort r = (GLushort) ((rgba[i][RCOMP] - dest[i][RCOMP]) * tt + dest[i][RCOMP]);
            GLushort g = (GLushort) ((rgba[i][GCOMP] - dest[i][GCOMP]) * tt + dest[i][GCOMP]);
            GLushort b = (GLushort) ((rgba[i][BCOMP] - dest[i][BCOMP]) * tt + dest[i][BCOMP]);
            GLushort a = (GLushort) ((rgba[i][ACOMP] - dest[i][ACOMP]) * tt + dest[i][ACOMP]);
            ASSIGN_4V(rgba[i], r, g, b, a);
         }
      }
   }
}

d183 3
d187 2
a188 2
blend_transparency_float(GLcontext *ctx, GLuint n, const GLubyte mask[],
                         GLvoid *src, const GLvoid *dst, GLenum chanType)
a189 2
   GLfloat (*rgba)[4] = (GLfloat (*)[4]) src;
   const GLfloat (*dest)[4] = (const GLfloat (*)[4]) dst;
d191 4
a194 9

   ASSERT(ctx->Color.BlendEquationRGB == GL_FUNC_ADD);
   ASSERT(ctx->Color.BlendEquationA == GL_FUNC_ADD);
   ASSERT(ctx->Color.BlendSrcRGB == GL_SRC_ALPHA);
   ASSERT(ctx->Color.BlendSrcA == GL_SRC_ALPHA);
   ASSERT(ctx->Color.BlendDstRGB == GL_ONE_MINUS_SRC_ALPHA);
   ASSERT(ctx->Color.BlendDstA == GL_ONE_MINUS_SRC_ALPHA);
   ASSERT(chanType == GL_FLOAT);

d197 1
a197 1
   for (i = 0; i < n; i++) {
d199 17
a215 12
         const GLfloat t = rgba[i][ACOMP];  /* t in [0, 1] */
         if (t == 0.0F) {
            /* 0% alpha */
            COPY_4V(rgba[i], dest[i]);
         }
         else if (t != 1.0F) {
            GLfloat r = (rgba[i][RCOMP] - dest[i][RCOMP]) * t + dest[i][RCOMP];
            GLfloat g = (rgba[i][GCOMP] - dest[i][GCOMP]) * t + dest[i][GCOMP];
            GLfloat b = (rgba[i][BCOMP] - dest[i][BCOMP]) * t + dest[i][BCOMP];
            GLfloat a = (rgba[i][ACOMP] - dest[i][ACOMP]) * t + dest[i][ACOMP];
            ASSIGN_4V(rgba[i], r, g, b, a);
         }
d222 2
a223 3
/**
 * Add src and dest: glBlendFunc(GL_ONE, GL_ONE).
 * Any chanType ok.
d226 2
a227 2
blend_add(GLcontext *ctx, GLuint n, const GLubyte mask[],
          GLvoid *src, const GLvoid *dst, GLenum chanType)
d230 2
a231 5

   ASSERT(ctx->Color.BlendEquationRGB == GL_FUNC_ADD);
   ASSERT(ctx->Color.BlendEquationA == GL_FUNC_ADD);
   ASSERT(ctx->Color.BlendSrcRGB == GL_ONE);
   ASSERT(ctx->Color.BlendDstRGB == GL_ONE);
d234 11
a244 44
   if (chanType == GL_UNSIGNED_BYTE) {
      GLubyte (*rgba)[4] = (GLubyte (*)[4]) src;
      const GLubyte (*dest)[4] = (const GLubyte (*)[4]) dst;
      for (i=0;i<n;i++) {
         if (mask[i]) {
            GLint r = rgba[i][RCOMP] + dest[i][RCOMP];
            GLint g = rgba[i][GCOMP] + dest[i][GCOMP];
            GLint b = rgba[i][BCOMP] + dest[i][BCOMP];
            GLint a = rgba[i][ACOMP] + dest[i][ACOMP];
            rgba[i][RCOMP] = (GLubyte) MIN2( r, 255 );
            rgba[i][GCOMP] = (GLubyte) MIN2( g, 255 );
            rgba[i][BCOMP] = (GLubyte) MIN2( b, 255 );
            rgba[i][ACOMP] = (GLubyte) MIN2( a, 255 );
         }
      }
   }
   else if (chanType == GL_UNSIGNED_SHORT) {
      GLushort (*rgba)[4] = (GLushort (*)[4]) src;
      const GLushort (*dest)[4] = (const GLushort (*)[4]) dst;
      for (i=0;i<n;i++) {
         if (mask[i]) {
            GLint r = rgba[i][RCOMP] + dest[i][RCOMP];
            GLint g = rgba[i][GCOMP] + dest[i][GCOMP];
            GLint b = rgba[i][BCOMP] + dest[i][BCOMP];
            GLint a = rgba[i][ACOMP] + dest[i][ACOMP];
            rgba[i][RCOMP] = (GLshort) MIN2( r, 255 );
            rgba[i][GCOMP] = (GLshort) MIN2( g, 255 );
            rgba[i][BCOMP] = (GLshort) MIN2( b, 255 );
            rgba[i][ACOMP] = (GLshort) MIN2( a, 255 );
         }
      }
   }
   else {
      GLfloat (*rgba)[4] = (GLfloat (*)[4]) src;
      const GLfloat (*dest)[4] = (const GLfloat (*)[4]) dst;
      ASSERT(chanType == GL_FLOAT);
      for (i=0;i<n;i++) {
         if (mask[i]) {
            /* don't RGB clamp to max */
            rgba[i][RCOMP] += dest[i][RCOMP];
            rgba[i][GCOMP] += dest[i][GCOMP];
            rgba[i][BCOMP] += dest[i][BCOMP];
            rgba[i][ACOMP] += dest[i][ACOMP];
         }
d251 2
a252 3
/**
 * Blend min function.
 * Any chanType ok.
d255 2
a256 2
blend_min(GLcontext *ctx, GLuint n, const GLubyte mask[],
          GLvoid *src, const GLvoid *dst, GLenum chanType)
d259 2
a260 2
   ASSERT(ctx->Color.BlendEquationRGB == GL_MIN);
   ASSERT(ctx->Color.BlendEquationA == GL_MIN);
d263 11
a273 35
   if (chanType == GL_UNSIGNED_BYTE) {
      GLubyte (*rgba)[4] = (GLubyte (*)[4]) src;
      const GLubyte (*dest)[4] = (const GLubyte (*)[4]) dst;
      for (i=0;i<n;i++) {
         if (mask[i]) {
            rgba[i][RCOMP] = MIN2( rgba[i][RCOMP], dest[i][RCOMP] );
            rgba[i][GCOMP] = MIN2( rgba[i][GCOMP], dest[i][GCOMP] );
            rgba[i][BCOMP] = MIN2( rgba[i][BCOMP], dest[i][BCOMP] );
            rgba[i][ACOMP] = MIN2( rgba[i][ACOMP], dest[i][ACOMP] );
         }
      }
   }
   else if (chanType == GL_UNSIGNED_SHORT) {
      GLushort (*rgba)[4] = (GLushort (*)[4]) src;
      const GLushort (*dest)[4] = (const GLushort (*)[4]) dst;
      for (i=0;i<n;i++) {
         if (mask[i]) {
            rgba[i][RCOMP] = MIN2( rgba[i][RCOMP], dest[i][RCOMP] );
            rgba[i][GCOMP] = MIN2( rgba[i][GCOMP], dest[i][GCOMP] );
            rgba[i][BCOMP] = MIN2( rgba[i][BCOMP], dest[i][BCOMP] );
            rgba[i][ACOMP] = MIN2( rgba[i][ACOMP], dest[i][ACOMP] );
         }
      }
   }
   else {
      GLfloat (*rgba)[4] = (GLfloat (*)[4]) src;
      const GLfloat (*dest)[4] = (const GLfloat (*)[4]) dst;
      ASSERT(chanType == GL_FLOAT);
      for (i=0;i<n;i++) {
         if (mask[i]) {
            rgba[i][RCOMP] = MIN2( rgba[i][RCOMP], dest[i][RCOMP] );
            rgba[i][GCOMP] = MIN2( rgba[i][GCOMP], dest[i][GCOMP] );
            rgba[i][BCOMP] = MIN2( rgba[i][BCOMP], dest[i][BCOMP] );
            rgba[i][ACOMP] = MIN2( rgba[i][ACOMP], dest[i][ACOMP] );
         }
d279 3
a281 3
/**
 * Blend max function.
 * Any chanType ok.
d284 2
a285 2
blend_max(GLcontext *ctx, GLuint n, const GLubyte mask[],
          GLvoid *src, const GLvoid *dst, GLenum chanType)
a287 2
   ASSERT(ctx->Color.BlendEquationRGB == GL_MAX);
   ASSERT(ctx->Color.BlendEquationA == GL_MAX);
d290 26
a315 35
   if (chanType == GL_UNSIGNED_BYTE) {
      GLubyte (*rgba)[4] = (GLubyte (*)[4]) src;
      const GLubyte (*dest)[4] = (const GLubyte (*)[4]) dst;
      for (i=0;i<n;i++) {
         if (mask[i]) {
            rgba[i][RCOMP] = MAX2( rgba[i][RCOMP], dest[i][RCOMP] );
            rgba[i][GCOMP] = MAX2( rgba[i][GCOMP], dest[i][GCOMP] );
            rgba[i][BCOMP] = MAX2( rgba[i][BCOMP], dest[i][BCOMP] );
            rgba[i][ACOMP] = MAX2( rgba[i][ACOMP], dest[i][ACOMP] );
         }
      }
   }
   else if (chanType == GL_UNSIGNED_SHORT) {
      GLushort (*rgba)[4] = (GLushort (*)[4]) src;
      const GLushort (*dest)[4] = (const GLushort (*)[4]) dst;
      for (i=0;i<n;i++) {
         if (mask[i]) {
            rgba[i][RCOMP] = MAX2( rgba[i][RCOMP], dest[i][RCOMP] );
            rgba[i][GCOMP] = MAX2( rgba[i][GCOMP], dest[i][GCOMP] );
            rgba[i][BCOMP] = MAX2( rgba[i][BCOMP], dest[i][BCOMP] );
            rgba[i][ACOMP] = MAX2( rgba[i][ACOMP], dest[i][ACOMP] );
         }
      }
   }
   else {
      GLfloat (*rgba)[4] = (GLfloat (*)[4]) src;
      const GLfloat (*dest)[4] = (const GLfloat (*)[4]) dst;
      ASSERT(chanType == GL_FLOAT);
      for (i=0;i<n;i++) {
         if (mask[i]) {
            rgba[i][RCOMP] = MAX2( rgba[i][RCOMP], dest[i][RCOMP] );
            rgba[i][GCOMP] = MAX2( rgba[i][GCOMP], dest[i][GCOMP] );
            rgba[i][BCOMP] = MAX2( rgba[i][BCOMP], dest[i][BCOMP] );
            rgba[i][ACOMP] = MAX2( rgba[i][ACOMP], dest[i][ACOMP] );
         }
d322 6
a327 3
/**
 * Modulate:  result = src * dest
 * Any chanType ok.
d330 2
a331 2
blend_modulate(GLcontext *ctx, GLuint n, const GLubyte mask[],
               GLvoid *src, const GLvoid *dst, GLenum chanType)
d333 4
a337 1
   (void) ctx;
d339 12
a350 39
   if (chanType == GL_UNSIGNED_BYTE) {
      GLubyte (*rgba)[4] = (GLubyte (*)[4]) src;
      const GLubyte (*dest)[4] = (const GLubyte (*)[4]) dst;
      for (i=0;i<n;i++) {
         if (mask[i]) {
	    GLint divtemp;
            rgba[i][RCOMP] = DIV255(rgba[i][RCOMP] * dest[i][RCOMP]);
            rgba[i][GCOMP] = DIV255(rgba[i][GCOMP] * dest[i][GCOMP]);
            rgba[i][BCOMP] = DIV255(rgba[i][BCOMP] * dest[i][BCOMP]);
            rgba[i][ACOMP] = DIV255(rgba[i][ACOMP] * dest[i][ACOMP]);
         }
      }
   }
   else if (chanType == GL_UNSIGNED_SHORT) {
      GLushort (*rgba)[4] = (GLushort (*)[4]) src;
      const GLushort (*dest)[4] = (const GLushort (*)[4]) dst;
      for (i=0;i<n;i++) {
         if (mask[i]) {
            rgba[i][RCOMP] = (rgba[i][RCOMP] * dest[i][RCOMP] + 65535) >> 16;
            rgba[i][GCOMP] = (rgba[i][GCOMP] * dest[i][GCOMP] + 65535) >> 16;
            rgba[i][BCOMP] = (rgba[i][BCOMP] * dest[i][BCOMP] + 65535) >> 16;
            rgba[i][ACOMP] = (rgba[i][ACOMP] * dest[i][ACOMP] + 65535) >> 16;
         }
      }
   }
   else {
      GLfloat (*rgba)[4] = (GLfloat (*)[4]) src;
      const GLfloat (*dest)[4] = (const GLfloat (*)[4]) dst;
      ASSERT(chanType == GL_FLOAT);
      for (i=0;i<n;i++) {
         if (mask[i]) {
            rgba[i][RCOMP] = rgba[i][RCOMP] * dest[i][RCOMP];
            rgba[i][GCOMP] = rgba[i][GCOMP] * dest[i][GCOMP];
            rgba[i][BCOMP] = rgba[i][BCOMP] * dest[i][BCOMP];
            rgba[i][ACOMP] = rgba[i][ACOMP] * dest[i][ACOMP];
         }
      }
   }
}
a351 17

/**
 * Do any blending operation, using floating point.
 * \param n  number of pixels
 * \param mask  fragment writemask array
 * \param rgba  array of incoming (and modified) pixels
 * \param dest  array of pixels from the dest color buffer
 */
static void
blend_general_float(GLcontext *ctx, GLuint n, const GLubyte mask[],
                    GLfloat rgba[][4], GLfloat dest[][4],
                    GLenum chanType)
{
   GLuint i;

   for (i = 0; i < n; i++) {
      if (mask[i]) {
d353 11
a363 4
         const GLfloat Rs = rgba[i][RCOMP];
         const GLfloat Gs = rgba[i][GCOMP];
         const GLfloat Bs = rgba[i][BCOMP];
         const GLfloat As = rgba[i][ACOMP];
d366 11
a376 12
         const GLfloat Rd = dest[i][RCOMP];
         const GLfloat Gd = dest[i][GCOMP];
         const GLfloat Bd = dest[i][BCOMP];
         const GLfloat Ad = dest[i][ACOMP];

         GLfloat sR, sG, sB, sA;  /* Source factor */
         GLfloat dR, dG, dB, dA;  /* Dest factor */
         GLfloat r, g, b, a;      /* result color */

         /* XXX for the case of constant blend terms we could init
          * the sX and dX variables just once before the loop.
          */
d387 3
a389 3
               sR = Rd;
               sG = Gd;
               sB = Bd;
d392 3
a394 3
               sR = 1.0F - Rd;
               sG = 1.0F - Gd;
               sB = 1.0F - Bd;
d397 1
a397 1
               sR = sG = sB = As;
d400 1
a400 1
               sR = sG = sB = 1.0F - As;
d403 1
a403 1
               sR = sG = sB = Ad;
d406 1
a406 1
               sR = sG = sB = 1.0F - Ad;
d409 2
a410 2
               if (As < 1.0F - Ad) {
                  sR = sG = sB = As;
d413 1
a413 1
                  sR = sG = sB = 1.0F - Ad;
d432 9
a440 9
            case GL_SRC_COLOR:
               sR = Rs;
               sG = Gs;
               sB = Bs;
               break;
            case GL_ONE_MINUS_SRC_COLOR:
               sR = 1.0F - Rs;
               sG = 1.0F - Gs;
               sB = 1.0F - Bs;
d444 1
a444 1
               _mesa_problem(ctx, "Bad blend source RGB factor in blend_general_float");
d457 1
a457 1
               sA = Ad;
d460 1
a460 1
               sA = 1.0F - Ad;
d463 1
a463 1
               sA = As;
d466 1
a466 1
               sA = 1.0F - As;
d469 1
a469 1
               sA = Ad;
d472 1
a472 1
               sA = 1.0F - Ad;
d489 2
a490 2
            case GL_SRC_COLOR:
               sA = As;
d492 2
a493 2
            case GL_ONE_MINUS_SRC_COLOR:
               sA = 1.0F - As;
d498 1
a498 2
               _mesa_problem(ctx, "Bad blend source A factor in blend_general_float");
               return;
d510 3
a512 3
               dR = Rs;
               dG = Gs;
               dB = Bs;
d515 3
a517 3
               dR = 1.0F - Rs;
               dG = 1.0F - Gs;
               dB = 1.0F - Bs;
d520 1
a520 1
               dR = dG = dB = As;
d523 1
a523 1
               dR = dG = dB = 1.0F - As;
d526 1
a526 1
               dR = dG = dB = Ad;
d529 1
a529 1
               dR = dG = dB = 1.0F - Ad;
d547 9
a555 9
            case GL_DST_COLOR:
               dR = Rd;
               dG = Gd;
               dB = Bd;
               break;
            case GL_ONE_MINUS_DST_COLOR:
               dR = 1.0F - Rd;
               dG = 1.0F - Gd;
               dB = 1.0F - Bd;
d560 1
a560 2
               _mesa_problem(ctx, "Bad blend dest RGB factor in blend_general_float");
               return;
d572 1
a572 1
               dA = As;
d575 1
a575 1
               dA = 1.0F - As;
d578 1
a578 1
               dA = As;
d581 1
a581 1
               dA = 1.0F - As;
d584 1
a584 1
               dA = Ad;
d587 1
a587 1
               dA = 1.0F - Ad;
d601 2
a602 2
            case GL_DST_COLOR:
               dA = Ad;
d604 2
a605 2
            case GL_ONE_MINUS_DST_COLOR:
               dA = 1.0F - Ad;
d610 1
a610 1
               _mesa_problem(ctx, "Bad blend dest A factor in blend_general_float");
d614 23
a636 3
         /* compute the blended RGB */
         switch (ctx->Color.BlendEquationRGB) {
         case GL_FUNC_ADD:
d641 2
a642 2
            break;
         case GL_FUNC_SUBTRACT:
d647 2
a648 2
            break;
         case GL_FUNC_REVERSE_SUBTRACT:
d653 2
a654 2
            break;
         case GL_MIN:
d658 2
a659 2
            break;
         case GL_MAX:
d663 2
a664 2
            break;
	 default:
a667 1
            return;
d670 1
a670 3
         /* compute the blended alpha */
         switch (ctx->Color.BlendEquationA) {
         case GL_FUNC_ADD:
d672 2
a673 2
            break;
         case GL_FUNC_SUBTRACT:
d675 2
a676 2
            break;
         case GL_FUNC_REVERSE_SUBTRACT:
d678 2
a679 2
            break;
         case GL_MIN:
d681 2
a682 2
            break;
         case GL_MAX:
d684 2
a685 2
            break;
         default:
a688 1
            return;
a691 1
#if 0
d695 1
a695 1
         rgba[i][ACOMP] = CLAMP( a, 0.0F, 1.0F );
d697 30
a726 5
         ASSIGN_4V(rgba[i], r, g, b, a);
#endif
      }
   }
}
d728 8
a735 36

/**
 * Do any blending operation, any chanType.
 */
static void
blend_general(GLcontext *ctx, GLuint n, const GLubyte mask[],
              void *src, const void *dst, GLenum chanType)
{
   GLfloat rgbaF[MAX_WIDTH][4], destF[MAX_WIDTH][4];

   if (chanType == GL_UNSIGNED_BYTE) {
      GLubyte (*rgba)[4] = (GLubyte (*)[4]) src;
      const GLubyte (*dest)[4] = (const GLubyte (*)[4]) dst;
      GLuint i;
      /* convert ubytes to floats */
      for (i = 0; i < n; i++) {
         if (mask[i]) {
            rgbaF[i][RCOMP] = UBYTE_TO_FLOAT(rgba[i][RCOMP]);
            rgbaF[i][GCOMP] = UBYTE_TO_FLOAT(rgba[i][GCOMP]);
            rgbaF[i][BCOMP] = UBYTE_TO_FLOAT(rgba[i][BCOMP]);
            rgbaF[i][ACOMP] = UBYTE_TO_FLOAT(rgba[i][ACOMP]);
            destF[i][RCOMP] = UBYTE_TO_FLOAT(dest[i][RCOMP]);
            destF[i][GCOMP] = UBYTE_TO_FLOAT(dest[i][GCOMP]);
            destF[i][BCOMP] = UBYTE_TO_FLOAT(dest[i][BCOMP]);
            destF[i][ACOMP] = UBYTE_TO_FLOAT(dest[i][ACOMP]);
         }
      }
      /* do blend */
      blend_general_float(ctx, n, mask, rgbaF, destF, chanType);
      /* convert back to ubytes */
      for (i = 0; i < n; i++) {
         if (mask[i]) {
            UNCLAMPED_FLOAT_TO_UBYTE(rgba[i][RCOMP], rgbaF[i][RCOMP]);
            UNCLAMPED_FLOAT_TO_UBYTE(rgba[i][GCOMP], rgbaF[i][GCOMP]);
            UNCLAMPED_FLOAT_TO_UBYTE(rgba[i][BCOMP], rgbaF[i][BCOMP]);
            UNCLAMPED_FLOAT_TO_UBYTE(rgba[i][ACOMP], rgbaF[i][ACOMP]);
d737 10
a746 28
      }
   }
   else if (chanType == GL_UNSIGNED_SHORT) {
      GLushort (*rgba)[4] = (GLushort (*)[4]) src;
      const GLushort (*dest)[4] = (const GLushort (*)[4]) dst;
      GLuint i;
      /* convert ushorts to floats */
      for (i = 0; i < n; i++) {
         if (mask[i]) {
            rgbaF[i][RCOMP] = USHORT_TO_FLOAT(rgba[i][RCOMP]);
            rgbaF[i][GCOMP] = USHORT_TO_FLOAT(rgba[i][GCOMP]);
            rgbaF[i][BCOMP] = USHORT_TO_FLOAT(rgba[i][BCOMP]);
            rgbaF[i][ACOMP] = USHORT_TO_FLOAT(rgba[i][ACOMP]);
            destF[i][RCOMP] = USHORT_TO_FLOAT(dest[i][RCOMP]);
            destF[i][GCOMP] = USHORT_TO_FLOAT(dest[i][GCOMP]);
            destF[i][BCOMP] = USHORT_TO_FLOAT(dest[i][BCOMP]);
            destF[i][ACOMP] = USHORT_TO_FLOAT(dest[i][ACOMP]);
         }
      }
      /* do blend */
      blend_general_float(ctx, n, mask, rgbaF, destF, chanType);
      /* convert back to ushorts */
      for (i = 0; i < n; i++) {
         if (mask[i]) {
            UNCLAMPED_FLOAT_TO_USHORT(rgba[i][RCOMP], rgbaF[i][RCOMP]);
            UNCLAMPED_FLOAT_TO_USHORT(rgba[i][GCOMP], rgbaF[i][GCOMP]);
            UNCLAMPED_FLOAT_TO_USHORT(rgba[i][BCOMP], rgbaF[i][BCOMP]);
            UNCLAMPED_FLOAT_TO_USHORT(rgba[i][ACOMP], rgbaF[i][ACOMP]);
d748 7
a756 3
   else {
      blend_general_float(ctx, n, mask, rgbaF, destF, chanType);
   }
d760 1
a760 2

/**
d764 1
a764 2
void
_swrast_choose_blend_func(GLcontext *ctx, GLenum chanType)
a765 1
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
d773 1
a773 1
      swrast->BlendFunc = blend_general;
d775 1
a775 1
   else if (eq == GL_MIN) {
d778 2
a779 2
      if (cpu_has_mmx && chanType == GL_UNSIGNED_BYTE) {
         swrast->BlendFunc = _mesa_mmx_blend_min;
d783 1
a783 1
         swrast->BlendFunc = blend_min;
d785 1
a785 1
   else if (eq == GL_MAX) {
d788 2
a789 2
      if (cpu_has_mmx && chanType == GL_UNSIGNED_BYTE) {
         swrast->BlendFunc = _mesa_mmx_blend_max;
d793 1
a793 1
         swrast->BlendFunc = blend_max;
d796 1
a796 1
      swrast->BlendFunc = blend_general;
d798 2
a799 2
   else if (eq == GL_FUNC_ADD && srcRGB == GL_SRC_ALPHA
            && dstRGB == GL_ONE_MINUS_SRC_ALPHA) {
d801 2
a802 2
      if (cpu_has_mmx && chanType == GL_UNSIGNED_BYTE) {
         swrast->BlendFunc = _mesa_mmx_blend_transparency;
d806 1
a806 8
      {
         if (chanType == GL_UNSIGNED_BYTE)
            swrast->BlendFunc = blend_transparency_ubyte;
         else if (chanType == GL_UNSIGNED_SHORT)
            swrast->BlendFunc = blend_transparency_ushort;
         else
            swrast->BlendFunc = blend_transparency_float;
      }
d808 1
a808 1
   else if (eq == GL_FUNC_ADD && srcRGB == GL_ONE && dstRGB == GL_ONE) {
d810 2
a811 2
      if (cpu_has_mmx && chanType == GL_UNSIGNED_BYTE) {
         swrast->BlendFunc = _mesa_mmx_blend_add;
d815 1
a815 1
         swrast->BlendFunc = blend_add;
d817 2
a818 2
   else if (((eq == GL_FUNC_ADD || eq == GL_FUNC_REVERSE_SUBTRACT)
	     && (srcRGB == GL_ZERO && dstRGB == GL_SRC_COLOR))
d820 2
a821 2
	    ((eq == GL_FUNC_ADD || eq == GL_FUNC_SUBTRACT)
	     && (srcRGB == GL_DST_COLOR && dstRGB == GL_ZERO))) {
d823 2
a824 2
      if (cpu_has_mmx && chanType == GL_UNSIGNED_BYTE) {
         swrast->BlendFunc = _mesa_mmx_blend_modulate;
d828 1
a828 1
         swrast->BlendFunc = blend_modulate;
d830 2
a831 2
   else if (eq == GL_FUNC_ADD && srcRGB == GL_ZERO && dstRGB == GL_ONE) {
      swrast->BlendFunc = blend_noop;
d833 2
a834 2
   else if (eq == GL_FUNC_ADD && srcRGB == GL_ONE && dstRGB == GL_ZERO) {
      swrast->BlendFunc = blend_replace;
d837 1
a837 1
      swrast->BlendFunc = blend_general;
d843 1
a843 1
/**
d849 2
a850 1
_swrast_blend_span(GLcontext *ctx, struct gl_renderbuffer *rb, SWspan *span)
d852 1
a852 2
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
   void *rbPixels;
a855 1
   ASSERT(rb->DataType == span->array->ChanType);
d858 11
a868 1
   rbPixels = _swrast_get_dest_rgba(ctx, rb, span);
d870 2
a871 2
   swrast->BlendFunc(ctx, span->end, span->array->mask,
                     span->array->rgba, rbPixels, span->array->ChanType);
@


1.1.1.3
log
@Import Mesa 7.10.3
@
text
@d3 1
a3 1
 * Version:  7.1
d5 1
a5 1
 * Copyright (C) 1999-2008  Brian Paul   All Rights Reserved.
d38 4
a41 4
#include "main/glheader.h"
#include "main/context.h"
#include "main/colormac.h"
#include "main/macros.h"
d73 1
a73 1
blend_noop(struct gl_context *ctx, GLuint n, const GLubyte mask[],
d92 1
a92 1
   memcpy(src, dst, bytes);
d101 1
a101 1
blend_replace(struct gl_context *ctx, GLuint n, const GLubyte mask[],
d121 1
a121 1
blend_transparency_ubyte(struct gl_context *ctx, GLuint n, const GLubyte mask[],
d166 1
a166 1
blend_transparency_ushort(struct gl_context *ctx, GLuint n, const GLubyte mask[],
d204 1
a204 1
blend_transparency_float(struct gl_context *ctx, GLuint n, const GLubyte mask[],
d246 1
a246 1
blend_add(struct gl_context *ctx, GLuint n, const GLubyte mask[],
d312 1
a312 1
blend_min(struct gl_context *ctx, GLuint n, const GLubyte mask[],
d365 1
a365 1
blend_max(struct gl_context *ctx, GLuint n, const GLubyte mask[],
d419 1
a419 1
blend_modulate(struct gl_context *ctx, GLuint n, const GLubyte mask[],
d474 1
a474 1
blend_general_float(struct gl_context *ctx, GLuint n, const GLubyte mask[],
d819 1
a819 1
blend_general(struct gl_context *ctx, GLuint n, const GLubyte mask[],
d822 1
a822 10
   GLfloat (*rgbaF)[4], (*destF)[4];

   rgbaF = (GLfloat (*)[4]) malloc(4 * n * sizeof(GLfloat));
   destF = (GLfloat (*)[4]) malloc(4 * n * sizeof(GLfloat));
   if (!rgbaF || !destF) {
      free(rgbaF);
      free(destF);
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "blending");
      return;
   }
d883 1
a883 2
      blend_general_float(ctx, n, mask, (GLfloat (*)[4]) src,
                          (GLfloat (*)[4]) dst, chanType);
a884 3

   free(rgbaF);
   free(destF);
d894 1
a894 1
_swrast_choose_blend_func(struct gl_context *ctx, GLenum chanType)
d987 1
a987 1
_swrast_blend_span(struct gl_context *ctx, struct gl_renderbuffer *rb, SWspan *span)
@


1.1.1.4
log
@Import Mesa 9.2.0
@
text
@d3 1
d20 3
a22 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
d78 4
a81 4
   ASSERT(ctx->Color.Blend[0].EquationRGB == GL_FUNC_ADD);
   ASSERT(ctx->Color.Blend[0].EquationA == GL_FUNC_ADD);
   ASSERT(ctx->Color.Blend[0].SrcRGB == GL_ZERO);
   ASSERT(ctx->Color.Blend[0].DstRGB == GL_ONE);
d104 4
a107 4
   ASSERT(ctx->Color.Blend[0].EquationRGB == GL_FUNC_ADD);
   ASSERT(ctx->Color.Blend[0].EquationA == GL_FUNC_ADD);
   ASSERT(ctx->Color.Blend[0].SrcRGB == GL_ONE);
   ASSERT(ctx->Color.Blend[0].DstRGB == GL_ZERO);
d128 6
a133 6
   ASSERT(ctx->Color.Blend[0].EquationRGB == GL_FUNC_ADD);
   ASSERT(ctx->Color.Blend[0].EquationA == GL_FUNC_ADD);
   ASSERT(ctx->Color.Blend[0].SrcRGB == GL_SRC_ALPHA);
   ASSERT(ctx->Color.Blend[0].SrcA == GL_SRC_ALPHA);
   ASSERT(ctx->Color.Blend[0].DstRGB == GL_ONE_MINUS_SRC_ALPHA);
   ASSERT(ctx->Color.Blend[0].DstA == GL_ONE_MINUS_SRC_ALPHA);
d173 6
a178 6
   ASSERT(ctx->Color.Blend[0].EquationRGB == GL_FUNC_ADD);
   ASSERT(ctx->Color.Blend[0].EquationA == GL_FUNC_ADD);
   ASSERT(ctx->Color.Blend[0].SrcRGB == GL_SRC_ALPHA);
   ASSERT(ctx->Color.Blend[0].SrcA == GL_SRC_ALPHA);
   ASSERT(ctx->Color.Blend[0].DstRGB == GL_ONE_MINUS_SRC_ALPHA);
   ASSERT(ctx->Color.Blend[0].DstA == GL_ONE_MINUS_SRC_ALPHA);
d211 6
a216 6
   ASSERT(ctx->Color.Blend[0].EquationRGB == GL_FUNC_ADD);
   ASSERT(ctx->Color.Blend[0].EquationA == GL_FUNC_ADD);
   ASSERT(ctx->Color.Blend[0].SrcRGB == GL_SRC_ALPHA);
   ASSERT(ctx->Color.Blend[0].SrcA == GL_SRC_ALPHA);
   ASSERT(ctx->Color.Blend[0].DstRGB == GL_ONE_MINUS_SRC_ALPHA);
   ASSERT(ctx->Color.Blend[0].DstA == GL_ONE_MINUS_SRC_ALPHA);
d251 4
a254 4
   ASSERT(ctx->Color.Blend[0].EquationRGB == GL_FUNC_ADD);
   ASSERT(ctx->Color.Blend[0].EquationA == GL_FUNC_ADD);
   ASSERT(ctx->Color.Blend[0].SrcRGB == GL_ONE);
   ASSERT(ctx->Color.Blend[0].DstRGB == GL_ONE);
d316 2
a317 2
   ASSERT(ctx->Color.Blend[0].EquationRGB == GL_MIN);
   ASSERT(ctx->Color.Blend[0].EquationA == GL_MIN);
d369 2
a370 2
   ASSERT(ctx->Color.Blend[0].EquationRGB == GL_MAX);
   ASSERT(ctx->Color.Blend[0].EquationA == GL_MAX);
d503 1
a503 1
         switch (ctx->Color.Blend[0].SrcRGB) {
d573 1
a573 1
         switch (ctx->Color.Blend[0].SrcA) {
d627 1
a627 1
         switch (ctx->Color.Blend[0].DstRGB) {
d690 1
a690 1
         switch (ctx->Color.Blend[0].DstA) {
d741 1
a741 1
         switch (ctx->Color.Blend[0].EquationRGB) {
d778 1
a778 1
         switch (ctx->Color.Blend[0].EquationA) {
d854 6
a859 2
         if (mask[i])
	   _mesa_unclamped_float_rgba_to_ubyte(rgba[i], rgbaF[i]);
d910 5
a914 5
   const GLenum eq = ctx->Color.Blend[0].EquationRGB;
   const GLenum srcRGB = ctx->Color.Blend[0].SrcRGB;
   const GLenum dstRGB = ctx->Color.Blend[0].DstRGB;
   const GLenum srcA = ctx->Color.Blend[0].SrcA;
   const GLenum dstA = ctx->Color.Blend[0].DstA;
d916 1
a916 1
   if (ctx->Color.Blend[0].EquationRGB != ctx->Color.Blend[0].EquationA) {
d1005 1
a1005 1
   ASSERT(span->end <= SWRAST_MAX_WIDTH);
d1007 2
a1008 1
   ASSERT(!ctx->Color.ColorLogicOpEnabled);
@


