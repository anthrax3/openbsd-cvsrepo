head	1.9;
access;
symbols
	OPENBSD_5_8:1.8.0.8
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.6
	OPENBSD_5_7_BASE:1.8
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.5
	v10_2_7:1.1.1.5
	OPENBSD_5_6:1.8.0.4
	OPENBSD_5_6_BASE:1.8
	v10_2_3:1.1.1.5
	OPENBSD_5_5:1.8.0.2
	OPENBSD_5_5_BASE:1.8
	v9_2_5:1.1.1.5
	v9_2_3:1.1.1.5
	v9_2_2:1.1.1.5
	v9_2_1:1.1.1.5
	v9_2_0:1.1.1.5
	OPENBSD_5_4:1.7.0.4
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.6.0.4
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.5.0.6
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.4
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_3:1.2.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2015.12.23.05.17.55;	author jsg;	state dead;
branches;
next	1.8;
commitid	TnlogFl9nOv2eaRf;

1.8
date	2013.09.05.14.06.50;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2012.08.17.13.58.20;	author mpi;	state Exp;
branches;
next	1.6;

1.6
date	2011.10.23.13.37.45;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.05.22.20.06.34;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.05.17.20.26.42;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.14.58.23;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.02.12.21.09.27;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.51.23;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.51.23;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.56.50;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.32.11;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.48;	author matthieu;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.09.05.13.17.31;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.9
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2008  Brian Paul   All Rights Reserved.
 * Copyright (C) 2009  VMware, Inc.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */


/**
 * \file swrast/s_span.c
 * \brief Span processing functions used by all rasterization functions.
 * This is where all the per-fragment tests are performed
 * \author Brian Paul
 */

#include "main/glheader.h"
#include "main/colormac.h"
#include "main/format_pack.h"
#include "main/format_unpack.h"
#include "main/macros.h"
#include "main/imports.h"
#include "main/image.h"
#include "main/samplerobj.h"

#include "s_atifragshader.h"
#include "s_alpha.h"
#include "s_blend.h"
#include "s_context.h"
#include "s_depth.h"
#include "s_fog.h"
#include "s_logic.h"
#include "s_masking.h"
#include "s_fragprog.h"
#include "s_span.h"
#include "s_stencil.h"
#include "s_texcombine.h"

#include <stdbool.h>

/**
 * Set default fragment attributes for the span using the
 * current raster values.  Used prior to glDraw/CopyPixels
 * and glBitmap.
 */
void
_swrast_span_default_attribs(struct gl_context *ctx, SWspan *span)
{
   GLchan r, g, b, a;
   /* Z*/
   {
      const GLfloat depthMax = ctx->DrawBuffer->_DepthMaxF;
      if (ctx->DrawBuffer->Visual.depthBits <= 16)
         span->z = FloatToFixed(ctx->Current.RasterPos[2] * depthMax + 0.5F);
      else {
         GLfloat tmpf = ctx->Current.RasterPos[2] * depthMax; 
         tmpf = MIN2(tmpf, depthMax);
         span->z = (GLint)tmpf;
      }
      span->zStep = 0;
      span->interpMask |= SPAN_Z;
   }

   /* W (for perspective correction) */
   span->attrStart[VARYING_SLOT_POS][3] = 1.0;
   span->attrStepX[VARYING_SLOT_POS][3] = 0.0;
   span->attrStepY[VARYING_SLOT_POS][3] = 0.0;

   /* primary color, or color index */
   UNCLAMPED_FLOAT_TO_CHAN(r, ctx->Current.RasterColor[0]);
   UNCLAMPED_FLOAT_TO_CHAN(g, ctx->Current.RasterColor[1]);
   UNCLAMPED_FLOAT_TO_CHAN(b, ctx->Current.RasterColor[2]);
   UNCLAMPED_FLOAT_TO_CHAN(a, ctx->Current.RasterColor[3]);
#if CHAN_TYPE == GL_FLOAT
   span->red = r;
   span->green = g;
   span->blue = b;
   span->alpha = a;
#else
   span->red   = IntToFixed(r);
   span->green = IntToFixed(g);
   span->blue  = IntToFixed(b);
   span->alpha = IntToFixed(a);
#endif
   span->redStep = 0;
   span->greenStep = 0;
   span->blueStep = 0;
   span->alphaStep = 0;
   span->interpMask |= SPAN_RGBA;

   COPY_4V(span->attrStart[VARYING_SLOT_COL0], ctx->Current.RasterColor);
   ASSIGN_4V(span->attrStepX[VARYING_SLOT_COL0], 0.0, 0.0, 0.0, 0.0);
   ASSIGN_4V(span->attrStepY[VARYING_SLOT_COL0], 0.0, 0.0, 0.0, 0.0);

   /* Secondary color */
   if (ctx->Light.Enabled || ctx->Fog.ColorSumEnabled)
   {
      COPY_4V(span->attrStart[VARYING_SLOT_COL1], ctx->Current.RasterSecondaryColor);
      ASSIGN_4V(span->attrStepX[VARYING_SLOT_COL1], 0.0, 0.0, 0.0, 0.0);
      ASSIGN_4V(span->attrStepY[VARYING_SLOT_COL1], 0.0, 0.0, 0.0, 0.0);
   }

   /* fog */
   {
      const SWcontext *swrast = SWRAST_CONTEXT(ctx);
      GLfloat fogVal; /* a coord or a blend factor */
      if (swrast->_PreferPixelFog) {
         /* fog blend factors will be computed from fog coordinates per pixel */
         fogVal = ctx->Current.RasterDistance;
      }
      else {
         /* fog blend factor should be computed from fogcoord now */
         fogVal = _swrast_z_to_fogfactor(ctx, ctx->Current.RasterDistance);
      }
      span->attrStart[VARYING_SLOT_FOGC][0] = fogVal;
      span->attrStepX[VARYING_SLOT_FOGC][0] = 0.0;
      span->attrStepY[VARYING_SLOT_FOGC][0] = 0.0;
   }

   /* texcoords */
   {
      GLuint i;
      for (i = 0; i < ctx->Const.MaxTextureCoordUnits; i++) {
         const GLuint attr = VARYING_SLOT_TEX0 + i;
         const GLfloat *tc = ctx->Current.RasterTexCoords[i];
         if (_swrast_use_fragment_program(ctx) ||
             ctx->ATIFragmentShader._Enabled) {
            COPY_4V(span->attrStart[attr], tc);
         }
         else if (tc[3] > 0.0F) {
            /* use (s/q, t/q, r/q, 1) */
            span->attrStart[attr][0] = tc[0] / tc[3];
            span->attrStart[attr][1] = tc[1] / tc[3];
            span->attrStart[attr][2] = tc[2] / tc[3];
            span->attrStart[attr][3] = 1.0;
         }
         else {
            ASSIGN_4V(span->attrStart[attr], 0.0F, 0.0F, 0.0F, 1.0F);
         }
         ASSIGN_4V(span->attrStepX[attr], 0.0F, 0.0F, 0.0F, 0.0F);
         ASSIGN_4V(span->attrStepY[attr], 0.0F, 0.0F, 0.0F, 0.0F);
      }
   }
}


/**
 * Interpolate the active attributes (and'd with attrMask) to
 * fill in span->array->attribs[].
 * Perspective correction will be done.  The point/line/triangle function
 * should have computed attrStart/Step values for VARYING_SLOT_POS[3]!
 */
static inline void
interpolate_active_attribs(struct gl_context *ctx, SWspan *span,
                           GLbitfield64 attrMask)
{
   const SWcontext *swrast = SWRAST_CONTEXT(ctx);

   /*
    * Don't overwrite existing array values, such as colors that may have
    * been produced by glDraw/CopyPixels.
    */
   attrMask &= ~span->arrayAttribs;

   ATTRIB_LOOP_BEGIN
      if (attrMask & BITFIELD64_BIT(attr)) {
         const GLfloat dwdx = span->attrStepX[VARYING_SLOT_POS][3];
         GLfloat w = span->attrStart[VARYING_SLOT_POS][3];
         const GLfloat dv0dx = span->attrStepX[attr][0];
         const GLfloat dv1dx = span->attrStepX[attr][1];
         const GLfloat dv2dx = span->attrStepX[attr][2];
         const GLfloat dv3dx = span->attrStepX[attr][3];
         GLfloat v0 = span->attrStart[attr][0] + span->leftClip * dv0dx;
         GLfloat v1 = span->attrStart[attr][1] + span->leftClip * dv1dx;
         GLfloat v2 = span->attrStart[attr][2] + span->leftClip * dv2dx;
         GLfloat v3 = span->attrStart[attr][3] + span->leftClip * dv3dx;
         GLuint k;
         for (k = 0; k < span->end; k++) {
            const GLfloat invW = 1.0f / w;
            span->array->attribs[attr][k][0] = v0 * invW;
            span->array->attribs[attr][k][1] = v1 * invW;
            span->array->attribs[attr][k][2] = v2 * invW;
            span->array->attribs[attr][k][3] = v3 * invW;
            v0 += dv0dx;
            v1 += dv1dx;
            v2 += dv2dx;
            v3 += dv3dx;
            w += dwdx;
         }
         ASSERT((span->arrayAttribs & BITFIELD64_BIT(attr)) == 0);
         span->arrayAttribs |= BITFIELD64_BIT(attr);
      }
   ATTRIB_LOOP_END
}


/**
 * Interpolate primary colors to fill in the span->array->rgba8 (or rgb16)
 * color array.
 */
static inline void
interpolate_int_colors(struct gl_context *ctx, SWspan *span)
{
#if CHAN_BITS != 32
   const GLuint n = span->end;
   GLuint i;

   ASSERT(!(span->arrayMask & SPAN_RGBA));
#endif

   switch (span->array->ChanType) {
#if CHAN_BITS != 32
   case GL_UNSIGNED_BYTE:
      {
         GLubyte (*rgba)[4] = span->array->rgba8;
         if (span->interpMask & SPAN_FLAT) {
            GLubyte color[4];
            color[RCOMP] = FixedToInt(span->red);
            color[GCOMP] = FixedToInt(span->green);
            color[BCOMP] = FixedToInt(span->blue);
            color[ACOMP] = FixedToInt(span->alpha);
            for (i = 0; i < n; i++) {
               COPY_4UBV(rgba[i], color);
            }
         }
         else {
            GLfixed r = span->red;
            GLfixed g = span->green;
            GLfixed b = span->blue;
            GLfixed a = span->alpha;
            GLint dr = span->redStep;
            GLint dg = span->greenStep;
            GLint db = span->blueStep;
            GLint da = span->alphaStep;
            for (i = 0; i < n; i++) {
               rgba[i][RCOMP] = FixedToChan(r);
               rgba[i][GCOMP] = FixedToChan(g);
               rgba[i][BCOMP] = FixedToChan(b);
               rgba[i][ACOMP] = FixedToChan(a);
               r += dr;
               g += dg;
               b += db;
               a += da;
            }
         }
      }
      break;
   case GL_UNSIGNED_SHORT:
      {
         GLushort (*rgba)[4] = span->array->rgba16;
         if (span->interpMask & SPAN_FLAT) {
            GLushort color[4];
            color[RCOMP] = FixedToInt(span->red);
            color[GCOMP] = FixedToInt(span->green);
            color[BCOMP] = FixedToInt(span->blue);
            color[ACOMP] = FixedToInt(span->alpha);
            for (i = 0; i < n; i++) {
               COPY_4V(rgba[i], color);
            }
         }
         else {
            GLushort (*rgba)[4] = span->array->rgba16;
            GLfixed r, g, b, a;
            GLint dr, dg, db, da;
            r = span->red;
            g = span->green;
            b = span->blue;
            a = span->alpha;
            dr = span->redStep;
            dg = span->greenStep;
            db = span->blueStep;
            da = span->alphaStep;
            for (i = 0; i < n; i++) {
               rgba[i][RCOMP] = FixedToChan(r);
               rgba[i][GCOMP] = FixedToChan(g);
               rgba[i][BCOMP] = FixedToChan(b);
               rgba[i][ACOMP] = FixedToChan(a);
               r += dr;
               g += dg;
               b += db;
               a += da;
            }
         }
      }
      break;
#endif
   case GL_FLOAT:
      interpolate_active_attribs(ctx, span, VARYING_BIT_COL0);
      break;
   default:
      _mesa_problem(ctx, "bad datatype 0x%x in interpolate_int_colors",
                    span->array->ChanType);
   }
   span->arrayMask |= SPAN_RGBA;
}


/**
 * Populate the VARYING_SLOT_COL0 array.
 */
static inline void
interpolate_float_colors(SWspan *span)
{
   GLfloat (*col0)[4] = span->array->attribs[VARYING_SLOT_COL0];
   const GLuint n = span->end;
   GLuint i;

   assert(!(span->arrayAttribs & VARYING_BIT_COL0));

   if (span->arrayMask & SPAN_RGBA) {
      /* convert array of int colors */
      for (i = 0; i < n; i++) {
         col0[i][0] = UBYTE_TO_FLOAT(span->array->rgba8[i][0]);
         col0[i][1] = UBYTE_TO_FLOAT(span->array->rgba8[i][1]);
         col0[i][2] = UBYTE_TO_FLOAT(span->array->rgba8[i][2]);
         col0[i][3] = UBYTE_TO_FLOAT(span->array->rgba8[i][3]);
      }
   }
   else {
      /* interpolate red/green/blue/alpha to get float colors */
      ASSERT(span->interpMask & SPAN_RGBA);
      if (span->interpMask & SPAN_FLAT) {
         GLfloat r = FixedToFloat(span->red);
         GLfloat g = FixedToFloat(span->green);
         GLfloat b = FixedToFloat(span->blue);
         GLfloat a = FixedToFloat(span->alpha);
         for (i = 0; i < n; i++) {
            ASSIGN_4V(col0[i], r, g, b, a);
         }
      }
      else {
         GLfloat r = FixedToFloat(span->red);
         GLfloat g = FixedToFloat(span->green);
         GLfloat b = FixedToFloat(span->blue);
         GLfloat a = FixedToFloat(span->alpha);
         GLfloat dr = FixedToFloat(span->redStep);
         GLfloat dg = FixedToFloat(span->greenStep);
         GLfloat db = FixedToFloat(span->blueStep);
         GLfloat da = FixedToFloat(span->alphaStep);
         for (i = 0; i < n; i++) {
            col0[i][0] = r;
            col0[i][1] = g;
            col0[i][2] = b;
            col0[i][3] = a;
            r += dr;
            g += dg;
            b += db;
            a += da;
         }
      }
   }

   span->arrayAttribs |= VARYING_BIT_COL0;
   span->array->ChanType = GL_FLOAT;
}



/**
 * Fill in the span.zArray array from the span->z, zStep values.
 */
void
_swrast_span_interpolate_z( const struct gl_context *ctx, SWspan *span )
{
   const GLuint n = span->end;
   GLuint i;

   ASSERT(!(span->arrayMask & SPAN_Z));

   if (ctx->DrawBuffer->Visual.depthBits <= 16) {
      GLfixed zval = span->z;
      GLuint *z = span->array->z; 
      for (i = 0; i < n; i++) {
         z[i] = FixedToInt(zval);
         zval += span->zStep;
      }
   }
   else {
      /* Deep Z buffer, no fixed->int shift */
      GLuint zval = span->z;
      GLuint *z = span->array->z;
      for (i = 0; i < n; i++) {
         z[i] = zval;
         zval += span->zStep;
      }
   }
   span->interpMask &= ~SPAN_Z;
   span->arrayMask |= SPAN_Z;
}


/**
 * Compute mipmap LOD from partial derivatives.
 * This the ideal solution, as given in the OpenGL spec.
 */
GLfloat
_swrast_compute_lambda(GLfloat dsdx, GLfloat dsdy, GLfloat dtdx, GLfloat dtdy,
                       GLfloat dqdx, GLfloat dqdy, GLfloat texW, GLfloat texH,
                       GLfloat s, GLfloat t, GLfloat q, GLfloat invQ)
{
   GLfloat dudx = texW * ((s + dsdx) / (q + dqdx) - s * invQ);
   GLfloat dvdx = texH * ((t + dtdx) / (q + dqdx) - t * invQ);
   GLfloat dudy = texW * ((s + dsdy) / (q + dqdy) - s * invQ);
   GLfloat dvdy = texH * ((t + dtdy) / (q + dqdy) - t * invQ);
   GLfloat x = sqrtf(dudx * dudx + dvdx * dvdx);
   GLfloat y = sqrtf(dudy * dudy + dvdy * dvdy);
   GLfloat rho = MAX2(x, y);
   GLfloat lambda = LOG2(rho);
   return lambda;
}


/**
 * Compute mipmap LOD from partial derivatives.
 * This is a faster approximation than above function.
 */
#if 0
GLfloat
_swrast_compute_lambda(GLfloat dsdx, GLfloat dsdy, GLfloat dtdx, GLfloat dtdy,
                     GLfloat dqdx, GLfloat dqdy, GLfloat texW, GLfloat texH,
                     GLfloat s, GLfloat t, GLfloat q, GLfloat invQ)
{
   GLfloat dsdx2 = (s + dsdx) / (q + dqdx) - s * invQ;
   GLfloat dtdx2 = (t + dtdx) / (q + dqdx) - t * invQ;
   GLfloat dsdy2 = (s + dsdy) / (q + dqdy) - s * invQ;
   GLfloat dtdy2 = (t + dtdy) / (q + dqdy) - t * invQ;
   GLfloat maxU, maxV, rho, lambda;
   dsdx2 = FABSF(dsdx2);
   dsdy2 = FABSF(dsdy2);
   dtdx2 = FABSF(dtdx2);
   dtdy2 = FABSF(dtdy2);
   maxU = MAX2(dsdx2, dsdy2) * texW;
   maxV = MAX2(dtdx2, dtdy2) * texH;
   rho = MAX2(maxU, maxV);
   lambda = LOG2(rho);
   return lambda;
}
#endif


/**
 * Fill in the span.array->attrib[VARYING_SLOT_TEXn] arrays from the
 * using the attrStart/Step values.
 *
 * This function only used during fixed-function fragment processing.
 *
 * Note: in the places where we divide by Q (or mult by invQ) we're
 * really doing two things: perspective correction and texcoord
 * projection.  Remember, for texcoord (s,t,r,q) we need to index
 * texels with (s/q, t/q, r/q).
 */
static void
interpolate_texcoords(struct gl_context *ctx, SWspan *span)
{
   const GLuint maxUnit
      = (ctx->Texture._EnabledCoordUnits > 1) ? ctx->Const.MaxTextureUnits : 1;
   GLuint u;

   /* XXX CoordUnits vs. ImageUnits */
   for (u = 0; u < maxUnit; u++) {
      if (ctx->Texture._EnabledCoordUnits & (1 << u)) {
         const GLuint attr = VARYING_SLOT_TEX0 + u;
         const struct gl_texture_object *obj = ctx->Texture.Unit[u]._Current;
         GLfloat texW, texH;
         GLboolean needLambda;
         GLfloat (*texcoord)[4] = span->array->attribs[attr];
         GLfloat *lambda = span->array->lambda[u];
         const GLfloat dsdx = span->attrStepX[attr][0];
         const GLfloat dsdy = span->attrStepY[attr][0];
         const GLfloat dtdx = span->attrStepX[attr][1];
         const GLfloat dtdy = span->attrStepY[attr][1];
         const GLfloat drdx = span->attrStepX[attr][2];
         const GLfloat dqdx = span->attrStepX[attr][3];
         const GLfloat dqdy = span->attrStepY[attr][3];
         GLfloat s = span->attrStart[attr][0] + span->leftClip * dsdx;
         GLfloat t = span->attrStart[attr][1] + span->leftClip * dtdx;
         GLfloat r = span->attrStart[attr][2] + span->leftClip * drdx;
         GLfloat q = span->attrStart[attr][3] + span->leftClip * dqdx;

         if (obj) {
            const struct gl_texture_image *img = obj->Image[0][obj->BaseLevel];
            const struct swrast_texture_image *swImg =
               swrast_texture_image_const(img);
            const struct gl_sampler_object *samp = _mesa_get_samplerobj(ctx, u);

            needLambda = (samp->MinFilter != samp->MagFilter)
               || _swrast_use_fragment_program(ctx);
            /* LOD is calculated directly in the ansiotropic filter, we can
             * skip the normal lambda function as the result is ignored.
             */
            if (samp->MaxAnisotropy > 1.0 &&
                samp->MinFilter == GL_LINEAR_MIPMAP_LINEAR) {
               needLambda = GL_FALSE;
            }
            texW = swImg->WidthScale;
            texH = swImg->HeightScale;
         }
         else {
            /* using a fragment program */
            texW = 1.0;
            texH = 1.0;
            needLambda = GL_FALSE;
         }

         if (needLambda) {
            GLuint i;
            if (_swrast_use_fragment_program(ctx)
                || ctx->ATIFragmentShader._Enabled) {
               /* do perspective correction but don't divide s, t, r by q */
               const GLfloat dwdx = span->attrStepX[VARYING_SLOT_POS][3];
               GLfloat w = span->attrStart[VARYING_SLOT_POS][3] + span->leftClip * dwdx;
               for (i = 0; i < span->end; i++) {
                  const GLfloat invW = 1.0F / w;
                  texcoord[i][0] = s * invW;
                  texcoord[i][1] = t * invW;
                  texcoord[i][2] = r * invW;
                  texcoord[i][3] = q * invW;
                  lambda[i] = _swrast_compute_lambda(dsdx, dsdy, dtdx, dtdy,
                                                     dqdx, dqdy, texW, texH,
                                                     s, t, q, invW);
                  s += dsdx;
                  t += dtdx;
                  r += drdx;
                  q += dqdx;
                  w += dwdx;
               }
            }
            else {
               for (i = 0; i < span->end; i++) {
                  const GLfloat invQ = (q == 0.0F) ? 1.0F : (1.0F / q);
                  texcoord[i][0] = s * invQ;
                  texcoord[i][1] = t * invQ;
                  texcoord[i][2] = r * invQ;
                  texcoord[i][3] = q;
                  lambda[i] = _swrast_compute_lambda(dsdx, dsdy, dtdx, dtdy,
                                                     dqdx, dqdy, texW, texH,
                                                     s, t, q, invQ);
                  s += dsdx;
                  t += dtdx;
                  r += drdx;
                  q += dqdx;
               }
            }
            span->arrayMask |= SPAN_LAMBDA;
         }
         else {
            GLuint i;
            if (_swrast_use_fragment_program(ctx) ||
                ctx->ATIFragmentShader._Enabled) {
               /* do perspective correction but don't divide s, t, r by q */
               const GLfloat dwdx = span->attrStepX[VARYING_SLOT_POS][3];
               GLfloat w = span->attrStart[VARYING_SLOT_POS][3] + span->leftClip * dwdx;
               for (i = 0; i < span->end; i++) {
                  const GLfloat invW = 1.0F / w;
                  texcoord[i][0] = s * invW;
                  texcoord[i][1] = t * invW;
                  texcoord[i][2] = r * invW;
                  texcoord[i][3] = q * invW;
                  lambda[i] = 0.0;
                  s += dsdx;
                  t += dtdx;
                  r += drdx;
                  q += dqdx;
                  w += dwdx;
               }
            }
            else if (dqdx == 0.0F) {
               /* Ortho projection or polygon's parallel to window X axis */
               const GLfloat invQ = (q == 0.0F) ? 1.0F : (1.0F / q);
               for (i = 0; i < span->end; i++) {
                  texcoord[i][0] = s * invQ;
                  texcoord[i][1] = t * invQ;
                  texcoord[i][2] = r * invQ;
                  texcoord[i][3] = q;
                  lambda[i] = 0.0;
                  s += dsdx;
                  t += dtdx;
                  r += drdx;
               }
            }
            else {
               for (i = 0; i < span->end; i++) {
                  const GLfloat invQ = (q == 0.0F) ? 1.0F : (1.0F / q);
                  texcoord[i][0] = s * invQ;
                  texcoord[i][1] = t * invQ;
                  texcoord[i][2] = r * invQ;
                  texcoord[i][3] = q;
                  lambda[i] = 0.0;
                  s += dsdx;
                  t += dtdx;
                  r += drdx;
                  q += dqdx;
               }
            }
         } /* lambda */
      } /* if */
   } /* for */
}


/**
 * Fill in the arrays->attribs[VARYING_SLOT_POS] array.
 */
static inline void
interpolate_wpos(struct gl_context *ctx, SWspan *span)
{
   GLfloat (*wpos)[4] = span->array->attribs[VARYING_SLOT_POS];
   GLuint i;
   const GLfloat zScale = 1.0F / ctx->DrawBuffer->_DepthMaxF;
   GLfloat w, dw;

   if (span->arrayMask & SPAN_XY) {
      for (i = 0; i < span->end; i++) {
         wpos[i][0] = (GLfloat) span->array->x[i];
         wpos[i][1] = (GLfloat) span->array->y[i];
      }
   }
   else {
      for (i = 0; i < span->end; i++) {
         wpos[i][0] = (GLfloat) span->x + i;
         wpos[i][1] = (GLfloat) span->y;
      }
   }

   dw = span->attrStepX[VARYING_SLOT_POS][3];
   w = span->attrStart[VARYING_SLOT_POS][3] + span->leftClip * dw;
   for (i = 0; i < span->end; i++) {
      wpos[i][2] = (GLfloat) span->array->z[i] * zScale;
      wpos[i][3] = w;
      w += dw;
   }
}


/**
 * Apply the current polygon stipple pattern to a span of pixels.
 */
static inline void
stipple_polygon_span(struct gl_context *ctx, SWspan *span)
{
   GLubyte *mask = span->array->mask;

   ASSERT(ctx->Polygon.StippleFlag);

   if (span->arrayMask & SPAN_XY) {
      /* arrays of x/y pixel coords */
      GLuint i;
      for (i = 0; i < span->end; i++) {
         const GLint col = span->array->x[i] % 32;
         const GLint row = span->array->y[i] % 32;
         const GLuint stipple = ctx->PolygonStipple[row];
         if (((1 << col) & stipple) == 0) {
            mask[i] = 0;
         }
      }
   }
   else {
      /* horizontal span of pixels */
      const GLuint highBit = 1 << 31;
      const GLuint stipple = ctx->PolygonStipple[span->y % 32];
      GLuint i, m = highBit >> (GLuint) (span->x % 32);
      for (i = 0; i < span->end; i++) {
         if ((m & stipple) == 0) {
            mask[i] = 0;
         }
         m = m >> 1;
         if (m == 0) {
            m = highBit;
         }
      }
   }
   span->writeAll = GL_FALSE;
}


/**
 * Clip a pixel span to the current buffer/window boundaries:
 * DrawBuffer->_Xmin, _Xmax, _Ymin, _Ymax.  This will accomplish
 * window clipping and scissoring.
 * Return:   GL_TRUE   some pixels still visible
 *           GL_FALSE  nothing visible
 */
static inline GLuint
clip_span( struct gl_context *ctx, SWspan *span )
{
   const GLint xmin = ctx->DrawBuffer->_Xmin;
   const GLint xmax = ctx->DrawBuffer->_Xmax;
   const GLint ymin = ctx->DrawBuffer->_Ymin;
   const GLint ymax = ctx->DrawBuffer->_Ymax;

   span->leftClip = 0;

   if (span->arrayMask & SPAN_XY) {
      /* arrays of x/y pixel coords */
      const GLint *x = span->array->x;
      const GLint *y = span->array->y;
      const GLint n = span->end;
      GLubyte *mask = span->array->mask;
      GLint i;
      GLuint passed = 0;
      if (span->arrayMask & SPAN_MASK) {
         /* note: using & intead of && to reduce branches */
         for (i = 0; i < n; i++) {
            mask[i] &= (x[i] >= xmin) & (x[i] < xmax)
                     & (y[i] >= ymin) & (y[i] < ymax);
            passed += mask[i];
         }
      }
      else {
         /* note: using & intead of && to reduce branches */
         for (i = 0; i < n; i++) {
            mask[i] = (x[i] >= xmin) & (x[i] < xmax)
                    & (y[i] >= ymin) & (y[i] < ymax);
            passed += mask[i];
         }
      }
      return passed > 0;
   }
   else {
      /* horizontal span of pixels */
      const GLint x = span->x;
      const GLint y = span->y;
      GLint n = span->end;

      /* Trivial rejection tests */
      if (y < ymin || y >= ymax || x + n <= xmin || x >= xmax) {
         span->end = 0;
         return GL_FALSE;  /* all pixels clipped */
      }

      /* Clip to right */
      if (x + n > xmax) {
         ASSERT(x < xmax);
         n = span->end = xmax - x;
      }

      /* Clip to the left */
      if (x < xmin) {
         const GLint leftClip = xmin - x;
         GLuint i;

         ASSERT(leftClip > 0);
         ASSERT(x + n > xmin);

         /* Clip 'leftClip' pixels from the left side.
          * The span->leftClip field will be applied when we interpolate
          * fragment attributes.
          * For arrays of values, shift them left.
          */
         for (i = 0; i < VARYING_SLOT_MAX; i++) {
            if (span->interpMask & (1 << i)) {
               GLuint j;
               for (j = 0; j < 4; j++) {
                  span->attrStart[i][j] += leftClip * span->attrStepX[i][j];
               }
            }
         }

         span->red += leftClip * span->redStep;
         span->green += leftClip * span->greenStep;
         span->blue += leftClip * span->blueStep;
         span->alpha += leftClip * span->alphaStep;
         span->index += leftClip * span->indexStep;
         span->z += leftClip * span->zStep;
         span->intTex[0] += leftClip * span->intTexStep[0];
         span->intTex[1] += leftClip * span->intTexStep[1];

#define SHIFT_ARRAY(ARRAY, SHIFT, LEN) \
         memmove(ARRAY, ARRAY + (SHIFT), (LEN) * sizeof(ARRAY[0]))

         for (i = 0; i < VARYING_SLOT_MAX; i++) {
            if (span->arrayAttribs & (1 << i)) {
               /* shift array elements left by 'leftClip' */
               SHIFT_ARRAY(span->array->attribs[i], leftClip, n - leftClip);
            }
         }

         SHIFT_ARRAY(span->array->mask, leftClip, n - leftClip);
         SHIFT_ARRAY(span->array->rgba8, leftClip, n - leftClip);
         SHIFT_ARRAY(span->array->rgba16, leftClip, n - leftClip);
         SHIFT_ARRAY(span->array->x, leftClip, n - leftClip);
         SHIFT_ARRAY(span->array->y, leftClip, n - leftClip);
         SHIFT_ARRAY(span->array->z, leftClip, n - leftClip);
         SHIFT_ARRAY(span->array->index, leftClip, n - leftClip);
         for (i = 0; i < MAX_TEXTURE_COORD_UNITS; i++) {
            SHIFT_ARRAY(span->array->lambda[i], leftClip, n - leftClip);
         }
         SHIFT_ARRAY(span->array->coverage, leftClip, n - leftClip);

#undef SHIFT_ARRAY

         span->leftClip = leftClip;
         span->x = xmin;
         span->end -= leftClip;
         span->writeAll = GL_FALSE;
      }

      ASSERT(span->x >= xmin);
      ASSERT(span->x + span->end <= xmax);
      ASSERT(span->y >= ymin);
      ASSERT(span->y < ymax);

      return GL_TRUE;  /* some pixels visible */
   }
}


/**
 * Add specular colors to primary colors.
 * Only called during fixed-function operation.
 * Result is float color array (VARYING_SLOT_COL0).
 */
static inline void
add_specular(struct gl_context *ctx, SWspan *span)
{
   const SWcontext *swrast = SWRAST_CONTEXT(ctx);
   const GLubyte *mask = span->array->mask;
   GLfloat (*col0)[4] = span->array->attribs[VARYING_SLOT_COL0];
   GLfloat (*col1)[4] = span->array->attribs[VARYING_SLOT_COL1];
   GLuint i;

   ASSERT(!_swrast_use_fragment_program(ctx));
   ASSERT(span->arrayMask & SPAN_RGBA);
   ASSERT(swrast->_ActiveAttribMask & VARYING_BIT_COL1);
   (void) swrast; /* silence warning */

   if (span->array->ChanType == GL_FLOAT) {
      if ((span->arrayAttribs & VARYING_BIT_COL0) == 0) {
         interpolate_active_attribs(ctx, span, VARYING_BIT_COL0);
      }
   }
   else {
      /* need float colors */
      if ((span->arrayAttribs & VARYING_BIT_COL0) == 0) {
         interpolate_float_colors(span);
      }
   }

   if ((span->arrayAttribs & VARYING_BIT_COL1) == 0) {
      /* XXX could avoid this and interpolate COL1 in the loop below */
      interpolate_active_attribs(ctx, span, VARYING_BIT_COL1);
   }

   ASSERT(span->arrayAttribs & VARYING_BIT_COL0);
   ASSERT(span->arrayAttribs & VARYING_BIT_COL1);

   for (i = 0; i < span->end; i++) {
      if (mask[i]) {
         col0[i][0] += col1[i][0];
         col0[i][1] += col1[i][1];
         col0[i][2] += col1[i][2];
      }
   }

   span->array->ChanType = GL_FLOAT;
}


/**
 * Apply antialiasing coverage value to alpha values.
 */
static inline void
apply_aa_coverage(SWspan *span)
{
   const GLfloat *coverage = span->array->coverage;
   GLuint i;
   if (span->array->ChanType == GL_UNSIGNED_BYTE) {
      GLubyte (*rgba)[4] = span->array->rgba8;
      for (i = 0; i < span->end; i++) {
         const GLfloat a = rgba[i][ACOMP] * coverage[i];
         rgba[i][ACOMP] = (GLubyte) CLAMP(a, 0.0, 255.0);
         ASSERT(coverage[i] >= 0.0);
         ASSERT(coverage[i] <= 1.0);
      }
   }
   else if (span->array->ChanType == GL_UNSIGNED_SHORT) {
      GLushort (*rgba)[4] = span->array->rgba16;
      for (i = 0; i < span->end; i++) {
         const GLfloat a = rgba[i][ACOMP] * coverage[i];
         rgba[i][ACOMP] = (GLushort) CLAMP(a, 0.0, 65535.0);
      }
   }
   else {
      GLfloat (*rgba)[4] = span->array->attribs[VARYING_SLOT_COL0];
      for (i = 0; i < span->end; i++) {
         rgba[i][ACOMP] = rgba[i][ACOMP] * coverage[i];
         /* clamp later */
      }
   }
}


/**
 * Clamp span's float colors to [0,1]
 */
static inline void
clamp_colors(SWspan *span)
{
   GLfloat (*rgba)[4] = span->array->attribs[VARYING_SLOT_COL0];
   GLuint i;
   ASSERT(span->array->ChanType == GL_FLOAT);
   for (i = 0; i < span->end; i++) {
      rgba[i][RCOMP] = CLAMP(rgba[i][RCOMP], 0.0F, 1.0F);
      rgba[i][GCOMP] = CLAMP(rgba[i][GCOMP], 0.0F, 1.0F);
      rgba[i][BCOMP] = CLAMP(rgba[i][BCOMP], 0.0F, 1.0F);
      rgba[i][ACOMP] = CLAMP(rgba[i][ACOMP], 0.0F, 1.0F);
   }
}


/**
 * Convert the span's color arrays to the given type.
 * The only way 'output' can be greater than zero is when we have a fragment
 * program that writes to gl_FragData[1] or higher.
 * \param output  which fragment program color output is being processed
 */
static inline void
convert_color_type(SWspan *span, GLenum newType, GLuint output)
{
   GLvoid *src, *dst;

   if (output > 0 || span->array->ChanType == GL_FLOAT) {
      src = span->array->attribs[VARYING_SLOT_COL0 + output];
      span->array->ChanType = GL_FLOAT;
   }
   else if (span->array->ChanType == GL_UNSIGNED_BYTE) {
      src = span->array->rgba8;
   }
   else {
      ASSERT(span->array->ChanType == GL_UNSIGNED_SHORT);
      src = span->array->rgba16;
   }

   if (newType == GL_UNSIGNED_BYTE) {
      dst = span->array->rgba8;
   }
   else if (newType == GL_UNSIGNED_SHORT) {
      dst = span->array->rgba16;
   }
   else {
      dst = span->array->attribs[VARYING_SLOT_COL0];
   }

   _mesa_convert_colors(span->array->ChanType, src,
                        newType, dst,
                        span->end, span->array->mask);

   span->array->ChanType = newType;
   span->array->rgba = dst;
}



/**
 * Apply fragment shader, fragment program or normal texturing to span.
 */
static inline void
shade_texture_span(struct gl_context *ctx, SWspan *span)
{
   if (_swrast_use_fragment_program(ctx) ||
       ctx->ATIFragmentShader._Enabled) {
      /* programmable shading */
      if (span->primitive == GL_BITMAP && span->array->ChanType != GL_FLOAT) {
         convert_color_type(span, GL_FLOAT, 0);
      }
      else {
         span->array->rgba = (void *) span->array->attribs[VARYING_SLOT_COL0];
      }

      if (span->primitive != GL_POINT ||
	  (span->interpMask & SPAN_RGBA) ||
	  ctx->Point.PointSprite) {
         /* for single-pixel points, we populated the arrays already */
         interpolate_active_attribs(ctx, span, ~0);
      }
      span->array->ChanType = GL_FLOAT;

      if (!(span->arrayMask & SPAN_Z))
         _swrast_span_interpolate_z (ctx, span);

#if 0
      if (inputsRead & VARYING_BIT_POS)
#else
      /* XXX always interpolate wpos so that DDX/DDY work */
#endif
         interpolate_wpos(ctx, span);

      /* Run fragment program/shader now */
      if (_swrast_use_fragment_program(ctx)) {
         _swrast_exec_fragment_program(ctx, span);
      }
      else {
         ASSERT(ctx->ATIFragmentShader._Enabled);
         _swrast_exec_fragment_shader(ctx, span);
      }
   }
   else if (ctx->Texture._EnabledCoordUnits) {
      /* conventional texturing */

#if CHAN_BITS == 32
      if ((span->arrayAttribs & VARYING_BIT_COL0) == 0) {
         interpolate_int_colors(ctx, span);
      }
#else
      if (!(span->arrayMask & SPAN_RGBA))
         interpolate_int_colors(ctx, span);
#endif
      if ((span->arrayAttribs & VARYING_BITS_TEX_ANY) == 0x0)
         interpolate_texcoords(ctx, span);

      _swrast_texture_span(ctx, span);
   }
}


/** Put colors at x/y locations into a renderbuffer */
static void
put_values(struct gl_context *ctx, struct gl_renderbuffer *rb,
           GLenum datatype,
           GLuint count, const GLint x[], const GLint y[],
           const void *values, const GLubyte *mask)
{
   gl_pack_ubyte_rgba_func pack_ubyte = NULL;
   gl_pack_float_rgba_func pack_float = NULL;
   GLuint i;

   if (datatype == GL_UNSIGNED_BYTE)
      pack_ubyte = _mesa_get_pack_ubyte_rgba_function(rb->Format);
   else
      pack_float = _mesa_get_pack_float_rgba_function(rb->Format);

   for (i = 0; i < count; i++) {
      if (mask[i]) {
         GLubyte *dst = _swrast_pixel_address(rb, x[i], y[i]);

         if (datatype == GL_UNSIGNED_BYTE) {
            pack_ubyte((const GLubyte *) values + 4 * i, dst);
         }
         else {
            assert(datatype == GL_FLOAT);
            pack_float((const GLfloat *) values + 4 * i, dst);
         }
      }
   }
}


/** Put row of colors into renderbuffer */
void
_swrast_put_row(struct gl_context *ctx, struct gl_renderbuffer *rb,
                GLenum datatype,
                GLuint count, GLint x, GLint y,
                const void *values, const GLubyte *mask)
{
   GLubyte *dst = _swrast_pixel_address(rb, x, y);

   if (!mask) {
      if (datatype == GL_UNSIGNED_BYTE) {
         _mesa_pack_ubyte_rgba_row(rb->Format, count,
                                   (const GLubyte (*)[4]) values, dst);
      }
      else {
         assert(datatype == GL_FLOAT);
         _mesa_pack_float_rgba_row(rb->Format, count,
                                   (const GLfloat (*)[4]) values, dst);
      }
   }
   else {
      const GLuint bpp = _mesa_get_format_bytes(rb->Format);
      GLuint i, runLen, runStart;
      /* We can't pass a 'mask' array to the _mesa_pack_rgba_row() functions
       * so look for runs where mask=1...
       */
      runLen = runStart = 0;
      for (i = 0; i < count; i++) {
         if (mask[i]) {
            if (runLen == 0)
               runStart = i;
            runLen++;
         }

         if (!mask[i] || i == count - 1) {
            /* might be the end of a run of pixels */
            if (runLen > 0) {
               if (datatype == GL_UNSIGNED_BYTE) {
                  _mesa_pack_ubyte_rgba_row(rb->Format, runLen,
                                     (const GLubyte (*)[4]) values + runStart,
                                     dst + runStart * bpp);
               }
               else {
                  assert(datatype == GL_FLOAT);
                  _mesa_pack_float_rgba_row(rb->Format, runLen,
                                   (const GLfloat (*)[4]) values + runStart,
                                   dst + runStart * bpp);
               }
               runLen = 0;
            }
         }
      }
   }
}



/**
 * Apply all the per-fragment operations to a span.
 * This now includes texturing (_swrast_write_texture_span() is history).
 * This function may modify any of the array values in the span.
 * span->interpMask and span->arrayMask may be changed but will be restored
 * to their original values before returning.
 */
void
_swrast_write_rgba_span( struct gl_context *ctx, SWspan *span)
{
   const SWcontext *swrast = SWRAST_CONTEXT(ctx);
   const GLuint *colorMask = (GLuint *) ctx->Color.ColorMask;
   const GLbitfield origInterpMask = span->interpMask;
   const GLbitfield origArrayMask = span->arrayMask;
   const GLbitfield64 origArrayAttribs = span->arrayAttribs;
   const GLenum origChanType = span->array->ChanType;
   void * const origRgba = span->array->rgba;
   const GLboolean shader = (_swrast_use_fragment_program(ctx)
                             || ctx->ATIFragmentShader._Enabled);
   const GLboolean shaderOrTexture = shader || ctx->Texture._EnabledCoordUnits;
   struct gl_framebuffer *fb = ctx->DrawBuffer;

   /*
   printf("%s()  interp 0x%x  array 0x%x\n", __FUNCTION__,
          span->interpMask, span->arrayMask);
   */

   ASSERT(span->primitive == GL_POINT ||
          span->primitive == GL_LINE ||
	  span->primitive == GL_POLYGON ||
          span->primitive == GL_BITMAP);

   /* Fragment write masks */
   if (span->arrayMask & SPAN_MASK) {
      /* mask was initialized by caller, probably glBitmap */
      span->writeAll = GL_FALSE;
   }
   else {
      memset(span->array->mask, 1, span->end);
      span->writeAll = GL_TRUE;
   }

   /* Clip to window/scissor box */
   if (!clip_span(ctx, span)) {
      return;
   }

   ASSERT(span->end <= SWRAST_MAX_WIDTH);

   /* Depth bounds test */
   if (ctx->Depth.BoundsTest && fb->Visual.depthBits > 0) {
      if (!_swrast_depth_bounds_test(ctx, span)) {
         return;
      }
   }

#ifdef DEBUG
   /* Make sure all fragments are within window bounds */
   if (span->arrayMask & SPAN_XY) {
      /* array of pixel locations */
      GLuint i;
      for (i = 0; i < span->end; i++) {
         if (span->array->mask[i]) {
            assert(span->array->x[i] >= fb->_Xmin);
            assert(span->array->x[i] < fb->_Xmax);
            assert(span->array->y[i] >= fb->_Ymin);
            assert(span->array->y[i] < fb->_Ymax);
         }
      }
   }
#endif

   /* Polygon Stippling */
   if (ctx->Polygon.StippleFlag && span->primitive == GL_POLYGON) {
      stipple_polygon_span(ctx, span);
   }

   /* This is the normal place to compute the fragment color/Z
    * from texturing or shading.
    */
   if (shaderOrTexture && !swrast->_DeferredTexture) {
      shade_texture_span(ctx, span);
   }

   /* Do the alpha test */
   if (ctx->Color.AlphaEnabled) {
      if (!_swrast_alpha_test(ctx, span)) {
         /* all fragments failed test */
         goto end;
      }
   }

   /* Stencil and Z testing */
   if (ctx->Stencil._Enabled || ctx->Depth.Test) {
      if (!(span->arrayMask & SPAN_Z))
         _swrast_span_interpolate_z(ctx, span);

      if (ctx->Transform.DepthClamp)
	 _swrast_depth_clamp_span(ctx, span);

      if (ctx->Stencil._Enabled) {
         /* Combined Z/stencil tests */
         if (!_swrast_stencil_and_ztest_span(ctx, span)) {
            /* all fragments failed test */
            goto end;
         }
      }
      else if (fb->Visual.depthBits > 0) {
         /* Just regular depth testing */
         ASSERT(ctx->Depth.Test);
         ASSERT(span->arrayMask & SPAN_Z);
         if (!_swrast_depth_test_span(ctx, span)) {
            /* all fragments failed test */
            goto end;
         }
      }
   }

   if (ctx->Query.CurrentOcclusionObject) {
      /* update count of 'passed' fragments */
      struct gl_query_object *q = ctx->Query.CurrentOcclusionObject;
      GLuint i;
      for (i = 0; i < span->end; i++)
         q->Result += span->array->mask[i];
   }

   /* We had to wait until now to check for glColorMask(0,0,0,0) because of
    * the occlusion test.
    */
   if (fb->_NumColorDrawBuffers == 1 && colorMask[0] == 0x0) {
      /* no colors to write */
      goto end;
   }

   /* If we were able to defer fragment color computation to now, there's
    * a good chance that many fragments will have already been killed by
    * Z/stencil testing.
    */
   if (shaderOrTexture && swrast->_DeferredTexture) {
      shade_texture_span(ctx, span);
   }

#if CHAN_BITS == 32
   if ((span->arrayAttribs & VARYING_BIT_COL0) == 0) {
      interpolate_active_attribs(ctx, span, VARYING_BIT_COL0);
   }
#else
   if ((span->arrayMask & SPAN_RGBA) == 0) {
      interpolate_int_colors(ctx, span);
   }
#endif

   ASSERT(span->arrayMask & SPAN_RGBA);

   if (span->primitive == GL_BITMAP || !swrast->SpecularVertexAdd) {
      /* Add primary and specular (diffuse + specular) colors */
      if (!shader) {
         if (ctx->Fog.ColorSumEnabled ||
             (ctx->Light.Enabled &&
              ctx->Light.Model.ColorControl == GL_SEPARATE_SPECULAR_COLOR)) {
            add_specular(ctx, span);
         }
      }
   }

   /* Fog */
   if (swrast->_FogEnabled) {
      _swrast_fog_rgba_span(ctx, span);
   }

   /* Antialias coverage application */
   if (span->arrayMask & SPAN_COVERAGE) {
      apply_aa_coverage(span);
   }

   /* Clamp color/alpha values over the range [0.0, 1.0] before storage */
   if (ctx->Color.ClampFragmentColor == GL_TRUE &&
       span->array->ChanType == GL_FLOAT) {
      clamp_colors(span);
   }

   /*
    * Write to renderbuffers.
    * Depending on glDrawBuffer() state and the which color outputs are
    * written by the fragment shader, we may either replicate one color to
    * all renderbuffers or write a different color to each renderbuffer.
    * multiFragOutputs=TRUE for the later case.
    */
   {
      const GLuint numBuffers = fb->_NumColorDrawBuffers;
      const struct gl_fragment_program *fp = ctx->FragmentProgram._Current;
      const GLboolean multiFragOutputs = 
         _swrast_use_fragment_program(ctx)
         && fp->Base.OutputsWritten >= (1 << FRAG_RESULT_DATA0);
      GLuint buf;

      for (buf = 0; buf < numBuffers; buf++) {
         struct gl_renderbuffer *rb = fb->_ColorDrawBuffers[buf];

         /* color[fragOutput] will be written to buffer[buf] */

         if (rb) {
            /* re-use one of the attribute array buffers for rgbaSave */
            GLchan (*rgbaSave)[4] = (GLchan (*)[4]) span->array->attribs[0];
            struct swrast_renderbuffer *srb = swrast_renderbuffer(rb);
            GLenum colorType = srb->ColorType;

            assert(colorType == GL_UNSIGNED_BYTE ||
                   colorType == GL_FLOAT);

            /* set span->array->rgba to colors for renderbuffer's datatype */
            if (span->array->ChanType != colorType) {
               convert_color_type(span, colorType, 0);
            }
            else {
               if (span->array->ChanType == GL_UNSIGNED_BYTE) {
                  span->array->rgba = span->array->rgba8;
               }
               else {
                  span->array->rgba = (void *)
                     span->array->attribs[VARYING_SLOT_COL0];
               }
            }

            if (!multiFragOutputs && numBuffers > 1) {
               /* save colors for second, third renderbuffer writes */
               memcpy(rgbaSave, span->array->rgba,
                      4 * span->end * sizeof(GLchan));
            }

            ASSERT(rb->_BaseFormat == GL_RGBA ||
                   rb->_BaseFormat == GL_RGB ||
                   rb->_BaseFormat == GL_RED ||
                   rb->_BaseFormat == GL_RG ||
		   rb->_BaseFormat == GL_ALPHA);

            if (ctx->Color.ColorLogicOpEnabled) {
               _swrast_logicop_rgba_span(ctx, rb, span);
            }
            else if ((ctx->Color.BlendEnabled >> buf) & 1) {
               _swrast_blend_span(ctx, rb, span);
            }

            if (colorMask[buf] != 0xffffffff) {
               _swrast_mask_rgba_span(ctx, rb, span, buf);
            }

            if (span->arrayMask & SPAN_XY) {
               /* array of pixel coords */
               put_values(ctx, rb,
                          span->array->ChanType, span->end,
                          span->array->x, span->array->y,
                          span->array->rgba, span->array->mask);
            }
            else {
               /* horizontal run of pixels */
               _swrast_put_row(ctx, rb,
                               span->array->ChanType,
                               span->end, span->x, span->y,
                               span->array->rgba,
                               span->writeAll ? NULL: span->array->mask);
            }

            if (!multiFragOutputs && numBuffers > 1) {
               /* restore original span values */
               memcpy(span->array->rgba, rgbaSave,
                      4 * span->end * sizeof(GLchan));
            }

         } /* if rb */
      } /* for buf */
   }

end:
   /* restore these values before returning */
   span->interpMask = origInterpMask;
   span->arrayMask = origArrayMask;
   span->arrayAttribs = origArrayAttribs;
   span->array->ChanType = origChanType;
   span->array->rgba = origRgba;
}


/**
 * Read float RGBA pixels from a renderbuffer.  Clipping will be done to
 * prevent reading ouside the buffer's boundaries.
 * \param rgba  the returned colors
 */
void
_swrast_read_rgba_span( struct gl_context *ctx, struct gl_renderbuffer *rb,
                        GLuint n, GLint x, GLint y,
                        GLvoid *rgba)
{
   struct swrast_renderbuffer *srb = swrast_renderbuffer(rb);
   GLenum dstType = GL_FLOAT;
   const GLint bufWidth = (GLint) rb->Width;
   const GLint bufHeight = (GLint) rb->Height;

   if (y < 0 || y >= bufHeight || x + (GLint) n < 0 || x >= bufWidth) {
      /* completely above, below, or right */
      /* XXX maybe leave rgba values undefined? */
      memset(rgba, 0, 4 * n * sizeof(GLchan));
   }
   else {
      GLint skip, length;
      GLubyte *src;

      if (x < 0) {
         /* left edge clipping */
         skip = -x;
         length = (GLint) n - skip;
         if (length < 0) {
            /* completely left of window */
            return;
         }
         if (length > bufWidth) {
            length = bufWidth;
         }
      }
      else if ((GLint) (x + n) > bufWidth) {
         /* right edge clipping */
         skip = 0;
         length = bufWidth - x;
         if (length < 0) {
            /* completely to right of window */
            return;
         }
      }
      else {
         /* no clipping */
         skip = 0;
         length = (GLint) n;
      }

      ASSERT(rb);
      ASSERT(rb->_BaseFormat == GL_RGBA ||
	     rb->_BaseFormat == GL_RGB ||
	     rb->_BaseFormat == GL_RG ||
	     rb->_BaseFormat == GL_RED ||
	     rb->_BaseFormat == GL_LUMINANCE ||
	     rb->_BaseFormat == GL_INTENSITY ||
	     rb->_BaseFormat == GL_LUMINANCE_ALPHA ||
	     rb->_BaseFormat == GL_ALPHA);

      assert(srb->Map);

      src = _swrast_pixel_address(rb, x + skip, y);

      if (dstType == GL_UNSIGNED_BYTE) {
         _mesa_unpack_ubyte_rgba_row(rb->Format, length, src,
                                     (GLubyte (*)[4]) rgba + skip);
      }
      else if (dstType == GL_FLOAT) {
         _mesa_unpack_rgba_row(rb->Format, length, src,
                               (GLfloat (*)[4]) rgba + skip);
      }
      else {
         _mesa_problem(ctx, "unexpected type in _swrast_read_rgba_span()");
      }
   }
}


/**
 * Get colors at x/y positions with clipping.
 * \param type  type of values to return
 */
static void
get_values(struct gl_context *ctx, struct gl_renderbuffer *rb,
           GLuint count, const GLint x[], const GLint y[],
           void *values, GLenum type)
{
   GLuint i;

   for (i = 0; i < count; i++) {
      if (x[i] >= 0 && y[i] >= 0 &&
	  x[i] < (GLint) rb->Width && y[i] < (GLint) rb->Height) {
         /* inside */
         const GLubyte *src = _swrast_pixel_address(rb, x[i], y[i]);

         if (type == GL_UNSIGNED_BYTE) {
            _mesa_unpack_ubyte_rgba_row(rb->Format, 1, src,
                                        (GLubyte (*)[4]) values + i);
         }
         else if (type == GL_FLOAT) {
            _mesa_unpack_rgba_row(rb->Format, 1, src,
                                  (GLfloat (*)[4]) values + i);
         }
         else {
            _mesa_problem(ctx, "unexpected type in get_values()");
         }
      }
   }
}


/**
 * Get row of colors with clipping.
 * \param type  type of values to return
 */
static void
get_row(struct gl_context *ctx, struct gl_renderbuffer *rb,
        GLuint count, GLint x, GLint y,
        GLvoid *values, GLenum type)
{
   GLint skip = 0;
   GLubyte *src;

   if (y < 0 || y >= (GLint) rb->Height)
      return; /* above or below */

   if (x + (GLint) count <= 0 || x >= (GLint) rb->Width)
      return; /* entirely left or right */

   if (x + count > rb->Width) {
      /* right clip */
      GLint clip = x + count - rb->Width;
      count -= clip;
   }

   if (x < 0) {
      /* left clip */
      skip = -x;
      x = 0;
      count -= skip;
   }

   src = _swrast_pixel_address(rb, x, y);

   if (type == GL_UNSIGNED_BYTE) {
      _mesa_unpack_ubyte_rgba_row(rb->Format, count, src,
                                  (GLubyte (*)[4]) values + skip);
   }
   else if (type == GL_FLOAT) {
      _mesa_unpack_rgba_row(rb->Format, count, src,
                            (GLfloat (*)[4]) values + skip);
   }
   else {
      _mesa_problem(ctx, "unexpected type in get_row()");
   }
}


/**
 * Get RGBA pixels from the given renderbuffer.
 * Used by blending, logicop and masking functions.
 * \return pointer to the colors we read.
 */
void *
_swrast_get_dest_rgba(struct gl_context *ctx, struct gl_renderbuffer *rb,
                      SWspan *span)
{
   void *rbPixels;

   /* Point rbPixels to a temporary space */
   rbPixels = span->array->attribs[VARYING_SLOT_MAX - 1];

   /* Get destination values from renderbuffer */
   if (span->arrayMask & SPAN_XY) {
      get_values(ctx, rb, span->end, span->array->x, span->array->y,
                 rbPixels, span->array->ChanType);
   }
   else {
      get_row(ctx, rb, span->end, span->x, span->y,
              rbPixels, span->array->ChanType);
   }

   return rbPixels;
}
@


1.8
log
@Merge Mesa 9.2.0
@
text
@@


1.7
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a2 1
 * Version:  7.5
d20 4
a23 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
d36 2
d41 1
d56 1
d82 3
a84 3
   span->attrStart[FRAG_ATTRIB_WPOS][3] = 1.0;
   span->attrStepX[FRAG_ATTRIB_WPOS][3] = 0.0;
   span->attrStepY[FRAG_ATTRIB_WPOS][3] = 0.0;
d108 3
a110 3
   COPY_4V(span->attrStart[FRAG_ATTRIB_COL0], ctx->Current.RasterColor);
   ASSIGN_4V(span->attrStepX[FRAG_ATTRIB_COL0], 0.0, 0.0, 0.0, 0.0);
   ASSIGN_4V(span->attrStepY[FRAG_ATTRIB_COL0], 0.0, 0.0, 0.0, 0.0);
d115 3
a117 3
      COPY_4V(span->attrStart[FRAG_ATTRIB_COL1], ctx->Current.RasterSecondaryColor);
      ASSIGN_4V(span->attrStepX[FRAG_ATTRIB_COL1], 0.0, 0.0, 0.0, 0.0);
      ASSIGN_4V(span->attrStepY[FRAG_ATTRIB_COL1], 0.0, 0.0, 0.0, 0.0);
d132 3
a134 3
      span->attrStart[FRAG_ATTRIB_FOGC][0] = fogVal;
      span->attrStepX[FRAG_ATTRIB_FOGC][0] = 0.0;
      span->attrStepY[FRAG_ATTRIB_FOGC][0] = 0.0;
d141 1
a141 1
         const GLuint attr = FRAG_ATTRIB_TEX0 + i;
d143 2
a144 1
         if (ctx->FragmentProgram._Current || ctx->ATIFragmentShader._Enabled) {
d168 1
a168 1
 * should have computed attrStart/Step values for FRAG_ATTRIB_WPOS[3]!
d170 3
a172 2
static INLINE void
interpolate_active_attribs(struct gl_context *ctx, SWspan *span, GLbitfield attrMask)
d183 3
a185 3
      if (attrMask & (1 << attr)) {
         const GLfloat dwdx = span->attrStepX[FRAG_ATTRIB_WPOS][3];
         GLfloat w = span->attrStart[FRAG_ATTRIB_WPOS][3];
d207 2
a208 2
         ASSERT((span->arrayAttribs & (1 << attr)) == 0);
         span->arrayAttribs |= (1 << attr);
d218 1
a218 1
static INLINE void
d221 1
a224 1
#if CHAN_BITS != 32
d305 1
a305 1
      interpolate_active_attribs(ctx, span, FRAG_BIT_COL0);
d316 1
a316 1
 * Populate the FRAG_ATTRIB_COL0 array.
d318 1
a318 1
static INLINE void
d321 1
a321 1
   GLfloat (*col0)[4] = span->array->attribs[FRAG_ATTRIB_COL0];
d325 1
a325 1
   assert(!(span->arrayAttribs & FRAG_BIT_COL0));
d370 1
a370 1
   span->arrayAttribs |= FRAG_BIT_COL0;
d422 2
a423 2
   GLfloat x = SQRTF(dudx * dudx + dvdx * dvdx);
   GLfloat y = SQRTF(dudy * dudy + dvdy * dvdy);
d459 1
a459 1
 * Fill in the span.array->attrib[FRAG_ATTRIB_TEXn] arrays from the
d479 1
a479 1
         const GLuint attr = FRAG_ATTRIB_TEX0 + u;
d499 6
a504 2
            needLambda = (obj->Sampler.MinFilter != obj->Sampler.MagFilter)
               || ctx->FragmentProgram._Current;
d508 2
a509 2
            if (obj->Sampler.MaxAnisotropy > 1.0 &&
                obj->Sampler.MinFilter == GL_LINEAR_MIPMAP_LINEAR) {
d512 2
a513 2
            texW = img->WidthScale;
            texH = img->HeightScale;
d524 1
a524 1
            if (ctx->FragmentProgram._Current
d527 2
a528 2
               const GLfloat dwdx = span->attrStepX[FRAG_ATTRIB_WPOS][3];
               GLfloat w = span->attrStart[FRAG_ATTRIB_WPOS][3] + span->leftClip * dwdx;
d565 1
a565 1
            if (ctx->FragmentProgram._Current ||
d568 2
a569 2
               const GLfloat dwdx = span->attrStepX[FRAG_ATTRIB_WPOS][3];
               GLfloat w = span->attrStart[FRAG_ATTRIB_WPOS][3] + span->leftClip * dwdx;
d619 1
a619 1
 * Fill in the arrays->attribs[FRAG_ATTRIB_WPOS] array.
d621 1
a621 1
static INLINE void
d624 1
a624 1
   GLfloat (*wpos)[4] = span->array->attribs[FRAG_ATTRIB_WPOS];
d642 2
a643 2
   dw = span->attrStepX[FRAG_ATTRIB_WPOS][3];
   w = span->attrStart[FRAG_ATTRIB_WPOS][3] + span->leftClip * dw;
d655 1
a655 1
static INLINE void
d700 1
a700 1
static INLINE GLuint
d717 1
d723 1
d731 1
d734 1
a734 1
      return GL_TRUE;  /* some pixels visible */
d767 1
a767 1
         for (i = 0; i < FRAG_ATTRIB_MAX; i++) {
d786 1
a786 1
         memcpy(ARRAY, ARRAY + (SHIFT), (LEN) * sizeof(ARRAY[0]))
d788 1
a788 1
         for (i = 0; i < FRAG_ATTRIB_MAX; i++) {
d828 1
a828 1
 * Result is float color array (FRAG_ATTRIB_COL0).
d830 1
a830 1
static INLINE void
d835 2
a836 2
   GLfloat (*col0)[4] = span->array->attribs[FRAG_ATTRIB_COL0];
   GLfloat (*col1)[4] = span->array->attribs[FRAG_ATTRIB_COL1];
d839 1
a839 1
   ASSERT(!ctx->FragmentProgram._Current);
d841 1
a841 1
   ASSERT(swrast->_ActiveAttribMask & FRAG_BIT_COL1);
d845 2
a846 2
      if ((span->arrayAttribs & FRAG_BIT_COL0) == 0) {
         interpolate_active_attribs(ctx, span, FRAG_BIT_COL0);
d851 1
a851 1
      if ((span->arrayAttribs & FRAG_BIT_COL0) == 0) {
d856 1
a856 1
   if ((span->arrayAttribs & FRAG_BIT_COL1) == 0) {
d858 1
a858 1
      interpolate_active_attribs(ctx, span, FRAG_BIT_COL1);
d861 2
a862 2
   ASSERT(span->arrayAttribs & FRAG_BIT_COL0);
   ASSERT(span->arrayAttribs & FRAG_BIT_COL1);
d879 1
a879 1
static INLINE void
d901 1
a901 1
      GLfloat (*rgba)[4] = span->array->attribs[FRAG_ATTRIB_COL0];
d913 1
a913 1
static INLINE void
d916 1
a916 1
   GLfloat (*rgba)[4] = span->array->attribs[FRAG_ATTRIB_COL0];
d934 1
a934 1
static INLINE void
d940 1
a940 1
      src = span->array->attribs[FRAG_ATTRIB_COL0 + output];
d958 1
a958 1
      dst = span->array->attribs[FRAG_ATTRIB_COL0];
d974 1
a974 1
static INLINE void
d977 1
a977 12
   GLbitfield inputsRead;

   /* Determine which fragment attributes are actually needed */
   if (ctx->FragmentProgram._Current) {
      inputsRead = ctx->FragmentProgram._Current->Base.InputsRead;
   }
   else {
      /* XXX we could be a bit smarter about this */
      inputsRead = ~0;
   }

   if (ctx->FragmentProgram._Current ||
d984 1
a984 1
         span->array->rgba = (void *) span->array->attribs[FRAG_ATTRIB_COL0];
d999 1
a999 1
      if (inputsRead & FRAG_BIT_WPOS)
d1006 1
a1006 1
      if (ctx->FragmentProgram._Current) {
d1018 1
a1018 1
      if ((span->arrayAttribs & FRAG_BIT_COL0) == 0) {
d1025 1
a1025 1
      if ((span->arrayAttribs & FRAG_BITS_TEX_ANY) == 0x0)
d1033 88
d1136 1
a1136 1
   const GLbitfield origArrayAttribs = span->arrayAttribs;
d1139 1
a1139 1
   const GLboolean shader = (ctx->FragmentProgram._Current
d1169 1
a1169 1
   ASSERT(span->end <= MAX_WIDTH);
d1265 2
a1266 2
   if ((span->arrayAttribs & FRAG_BIT_COL0) == 0) {
      interpolate_active_attribs(ctx, span, FRAG_BIT_COL0);
d1314 2
a1315 1
         (fp && fp->Base.OutputsWritten >= (1 << FRAG_RESULT_DATA0));
d1324 11
a1334 6
            GLchan rgbaSave[MAX_WIDTH][4];
            const GLuint fragOutput = multiFragOutputs ? buf : 0;

            /* set span->array->rgba to colors for render buffer's datatype */
            if (rb->DataType != span->array->ChanType || fragOutput > 0) {
               convert_color_type(span, rb->DataType, fragOutput);
d1337 1
a1337 1
               if (rb->DataType == GL_UNSIGNED_BYTE) {
a1339 3
               else if (rb->DataType == GL_UNSIGNED_SHORT) {
                  span->array->rgba = (void *) span->array->rgba16;
               }
d1342 1
a1342 1
                     span->array->attribs[FRAG_ATTRIB_COL0];
d1352 4
a1355 1
            ASSERT(rb->_BaseFormat == GL_RGBA || rb->_BaseFormat == GL_RGB ||
d1358 1
a1358 1
            if (ctx->Color._LogicOpEnabled) {
d1371 4
a1374 4
               ASSERT(rb->PutValues);
               rb->PutValues(ctx, rb, span->end,
                             span->array->x, span->array->y,
                             span->array->rgba, span->array->mask);
d1378 5
a1382 4
               ASSERT(rb->PutRow);
               rb->PutRow(ctx, rb, span->end, span->x, span->y,
                          span->array->rgba,
                          span->writeAll ? NULL: span->array->mask);
d1406 2
a1407 3
 * Read RGBA pixels from a renderbuffer.  Clipping will be done to prevent
 * reading ouside the buffer's boundaries.
 * \param dstType  datatype for returned colors
d1412 1
a1412 1
                        GLuint n, GLint x, GLint y, GLenum dstType,
d1415 2
d1427 2
a1456 1
      ASSERT(rb->GetRow);
d1466 11
a1476 3
      if (rb->DataType == dstType) {
         rb->GetRow(ctx, rb, length, x + skip, y,
                    (GLubyte *) rgba + skip * RGBA_PIXEL_SIZE(rb->DataType));
d1479 1
a1479 5
         GLuint temp[MAX_WIDTH * 4];
         rb->GetRow(ctx, rb, length, x + skip, y, temp);
         _mesa_convert_colors(rb->DataType, temp,
                   dstType, (GLubyte *) rgba + skip * RGBA_PIXEL_SIZE(dstType),
                   length, NULL);
d1486 2
a1487 5
 * Wrapper for gl_renderbuffer::GetValues() which does clipping to avoid
 * reading values outside the buffer bounds.
 * We can use this for reading any format/type of renderbuffer.
 * \param valueSize is the size in bytes of each value (pixel) put into the
 *                  values array.
d1489 4
a1492 4
void
_swrast_get_values(struct gl_context *ctx, struct gl_renderbuffer *rb,
                   GLuint count, const GLint x[], const GLint y[],
                   void *values, GLuint valueSize)
d1494 1
a1494 1
   GLuint i, inCount = 0, inStart = 0;
d1500 12
a1511 10
         if (inCount == 0)
            inStart = i;
         inCount++;
      }
      else {
         if (inCount > 0) {
            /* read [inStart, inStart + inCount) */
            rb->GetValues(ctx, rb, inCount, x + inStart, y + inStart,
                          (GLubyte *) values + inStart * valueSize);
            inCount = 0;
a1514 5
   if (inCount > 0) {
      /* read last values */
      rb->GetValues(ctx, rb, inCount, x + inStart, y + inStart,
                    (GLubyte *) values + inStart * valueSize);
   }
d1519 2
a1520 2
 * Wrapper for gl_renderbuffer::PutRow() which does clipping.
 * \param valueSize  size of each value (pixel) in bytes
d1522 4
a1525 4
void
_swrast_put_row(struct gl_context *ctx, struct gl_renderbuffer *rb,
                GLuint count, GLint x, GLint y,
                const GLvoid *values, GLuint valueSize)
d1528 1
d1536 1
a1536 1
   if ((GLint) (x + count) > (GLint) rb->Width) {
d1549 1
a1549 21
   rb->PutRow(ctx, rb, count, x, y,
              (const GLubyte *) values + skip * valueSize, NULL);
}


/**
 * Wrapper for gl_renderbuffer::GetRow() which does clipping.
 * \param valueSize  size of each value (pixel) in bytes
 */
void
_swrast_get_row(struct gl_context *ctx, struct gl_renderbuffer *rb,
                GLuint count, GLint x, GLint y,
                GLvoid *values, GLuint valueSize)
{
   GLint skip = 0;

   if (y < 0 || y >= (GLint) rb->Height)
      return; /* above or below */

   if (x + (GLint) count <= 0 || x >= (GLint) rb->Width)
      return; /* entirely left or right */
d1551 7
a1557 4
   if (x + count > rb->Width) {
      /* right clip */
      GLint clip = x + count - rb->Width;
      count -= clip;
d1559 2
a1560 6

   if (x < 0) {
      /* left clip */
      skip = -x;
      x = 0;
      count -= skip;
a1561 2

   rb->GetRow(ctx, rb, count, x, y, (GLubyte *) values + skip * valueSize);
a1573 1
   const GLuint pixelSize = RGBA_PIXEL_SIZE(span->array->ChanType);
d1577 1
a1577 1
   rbPixels = span->array->attribs[FRAG_ATTRIB_MAX - 1];
d1581 2
a1582 2
      _swrast_get_values(ctx, rb, span->end, span->array->x, span->array->y,
                         rbPixels, pixelSize);
d1585 2
a1586 2
      _swrast_get_row(ctx, rb, span->end, span->x, span->y,
                      rbPixels, pixelSize);
@


1.6
log
@Merge Mesa 7.10.3
@
text
@d302 2
a303 1
      _mesa_problem(NULL, "bad datatype in interpolate_int_colors");
d493 1
a493 1
            needLambda = (obj->MinFilter != obj->MagFilter)
d495 7
d1362 3
@


1.5
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@a35 1
#include "main/context.h"
d60 1
a60 1
_swrast_span_default_attribs(GLcontext *ctx, SWspan *span)
d166 1
a166 1
interpolate_active_attribs(GLcontext *ctx, SWspan *span, GLbitfield attrMask)
d213 1
a213 1
interpolate_int_colors(GLcontext *ctx, SWspan *span)
d373 1
a373 1
_swrast_span_interpolate_z( const GLcontext *ctx, SWspan *span )
d463 1
a463 1
interpolate_texcoords(GLcontext *ctx, SWspan *span)
d604 1
a604 1
interpolate_wpos(GLcontext *ctx, SWspan *span)
d638 1
a638 1
stipple_polygon_span(GLcontext *ctx, SWspan *span)
d683 1
a683 1
clip_span( GLcontext *ctx, SWspan *span )
d810 1
a810 1
add_specular(GLcontext *ctx, SWspan *span)
d954 1
a954 1
shade_texture_span(GLcontext *ctx, SWspan *span)
d973 4
d1032 1
a1032 1
_swrast_write_rgba_span( GLcontext *ctx, SWspan *span)
d1228 1
d1232 12
d1251 2
a1252 1
            ASSERT(rb->_BaseFormat == GL_RGBA || rb->_BaseFormat == GL_RGB);
d1307 1
a1307 1
_swrast_read_rgba_span( GLcontext *ctx, struct gl_renderbuffer *rb,
d1350 5
a1354 1
      ASSERT(rb->_BaseFormat == GL_RGB || rb->_BaseFormat == GL_RGBA);
d1379 1
a1379 1
_swrast_get_values(GLcontext *ctx, struct gl_renderbuffer *rb,
d1415 1
a1415 1
_swrast_put_row(GLcontext *ctx, struct gl_renderbuffer *rb,
d1450 1
a1450 1
_swrast_get_row(GLcontext *ctx, struct gl_renderbuffer *rb,
d1485 1
a1485 1
_swrast_get_dest_rgba(GLcontext *ctx, struct gl_renderbuffer *rb,
@


1.4
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d3 1
a3 1
 * Version:  7.1
d5 2
a6 1
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
d63 1
d84 4
a87 6
   if (ctx->Visual.rgbMode) {
      GLchan r, g, b, a;
      UNCLAMPED_FLOAT_TO_CHAN(r, ctx->Current.RasterColor[0]);
      UNCLAMPED_FLOAT_TO_CHAN(g, ctx->Current.RasterColor[1]);
      UNCLAMPED_FLOAT_TO_CHAN(b, ctx->Current.RasterColor[2]);
      UNCLAMPED_FLOAT_TO_CHAN(a, ctx->Current.RasterColor[3]);
d89 4
a92 4
      span->red = r;
      span->green = g;
      span->blue = b;
      span->alpha = a;
d94 4
a97 4
      span->red   = IntToFixed(r);
      span->green = IntToFixed(g);
      span->blue  = IntToFixed(b);
      span->alpha = IntToFixed(a);
d99 9
a107 15
      span->redStep = 0;
      span->greenStep = 0;
      span->blueStep = 0;
      span->alphaStep = 0;
      span->interpMask |= SPAN_RGBA;

      COPY_4V(span->attrStart[FRAG_ATTRIB_COL0], ctx->Current.RasterColor);
      ASSIGN_4V(span->attrStepX[FRAG_ATTRIB_COL0], 0.0, 0.0, 0.0, 0.0);
      ASSIGN_4V(span->attrStepY[FRAG_ATTRIB_COL0], 0.0, 0.0, 0.0, 0.0);
   }
   else {
      span->index = FloatToFixed(ctx->Current.RasterIndex);
      span->indexStep = 0;
      span->interpMask |= SPAN_INDEX;
   }
d110 1
a110 1
   if (ctx->Visual.rgbMode && (ctx->Light.Enabled || ctx->Fog.ColorSumEnabled))
d185 4
a188 4
         GLfloat v0 = span->attrStart[attr][0];
         GLfloat v1 = span->attrStart[attr][1];
         GLfloat v2 = span->attrStart[attr][2];
         GLfloat v3 = span->attrStart[attr][3];
a369 32
/* Fill in the span.color.index array from the interpolation values */
static INLINE void
interpolate_indexes(GLcontext *ctx, SWspan *span)
{
   GLfixed index = span->index;
   const GLint indexStep = span->indexStep;
   const GLuint n = span->end;
   GLuint *indexes = span->array->index;
   GLuint i;
   (void) ctx;

   ASSERT(!(span->arrayMask & SPAN_INDEX));

   if ((span->interpMask & SPAN_FLAT) || (indexStep == 0)) {
      /* constant color */
      index = FixedToInt(index);
      for (i = 0; i < n; i++) {
         indexes[i] = index;
      }
   }
   else {
      /* interpolate */
      for (i = 0; i < n; i++) {
         indexes[i] = FixedToInt(index);
         index += indexStep;
      }
   }
   span->arrayMask |= SPAN_INDEX;
   span->interpMask &= ~SPAN_INDEX;
}


d486 4
a489 4
         GLfloat s = span->attrStart[attr][0];
         GLfloat t = span->attrStart[attr][1];
         GLfloat r = span->attrStart[attr][2];
         GLfloat q = span->attrStart[attr][3];
d511 1
a511 1
               GLfloat w = span->attrStart[FRAG_ATTRIB_WPOS][3];
d552 1
a552 1
               GLfloat w = span->attrStart[FRAG_ATTRIB_WPOS][3];
d609 1
a609 1
   const GLfloat zScale = 1.0 / ctx->DrawBuffer->_DepthMaxF;
a624 1
   w = span->attrStart[FRAG_ATTRIB_WPOS][3];
d626 1
d691 2
d720 1
a720 1
      const GLint n = span->end;
a727 7
      /* Clip to the left */
      if (x < xmin) {
         ASSERT(x + n > xmin);
         span->writeAll = GL_FALSE;
         _mesa_bzero(span->array->mask, (xmin - x) * sizeof(GLubyte));
      }

d731 1
a731 1
         span->end = xmax - x;
d734 4
a737 3
      return GL_TRUE;  /* some pixels visible */
   }
}
d739 2
d742 12
a753 56
/**
 * Apply all the per-fragment opertions to a span of color index fragments
 * and write them to the enabled color drawbuffers.
 * The 'span' parameter can be considered to be const.  Note that
 * span->interpMask and span->arrayMask may be changed but will be restored
 * to their original values before returning.
 */
void
_swrast_write_index_span( GLcontext *ctx, SWspan *span)
{
   const SWcontext *swrast = SWRAST_CONTEXT(ctx);
   const GLbitfield origInterpMask = span->interpMask;
   const GLbitfield origArrayMask = span->arrayMask;
   struct gl_framebuffer *fb = ctx->DrawBuffer;

   ASSERT(span->end <= MAX_WIDTH);
   ASSERT(span->primitive == GL_POINT  ||  span->primitive == GL_LINE ||
	  span->primitive == GL_POLYGON  ||  span->primitive == GL_BITMAP);
   ASSERT((span->interpMask | span->arrayMask) & SPAN_INDEX);
   /*
   ASSERT((span->interpMask & span->arrayMask) == 0);
   */

   if (span->arrayMask & SPAN_MASK) {
      /* mask was initialized by caller, probably glBitmap */
      span->writeAll = GL_FALSE;
   }
   else {
      _mesa_memset(span->array->mask, 1, span->end);
      span->writeAll = GL_TRUE;
   }

   /* Clipping */
   if ((swrast->_RasterMask & CLIP_BIT) || (span->primitive != GL_POLYGON)) {
      if (!clip_span(ctx, span)) {
         return;
      }
   }

   /* Depth bounds test */
   if (ctx->Depth.BoundsTest && fb->Visual.depthBits > 0) {
      if (!_swrast_depth_bounds_test(ctx, span)) {
         return;
      }
   }

#ifdef DEBUG
   /* Make sure all fragments are within window bounds */
   if (span->arrayMask & SPAN_XY) {
      GLuint i;
      for (i = 0; i < span->end; i++) {
         if (span->array->mask[i]) {
            assert(span->array->x[i] >= fb->_Xmin);
            assert(span->array->x[i] < fb->_Xmax);
            assert(span->array->y[i] >= fb->_Ymin);
            assert(span->array->y[i] < fb->_Ymax);
a754 3
      }
   }
#endif
d756 17
a772 14
   /* Polygon Stippling */
   if (ctx->Polygon.StippleFlag && span->primitive == GL_POLYGON) {
      stipple_polygon_span(ctx, span);
   }

   /* Stencil and Z testing */
   if (ctx->Depth.Test || ctx->Stencil.Enabled) {
      if (!(span->arrayMask & SPAN_Z))
         _swrast_span_interpolate_z(ctx, span);

      if (ctx->Stencil.Enabled) {
         if (!_swrast_stencil_and_ztest_span(ctx, span)) {
            span->arrayMask = origArrayMask;
            return;
a773 10
      }
      else {
         ASSERT(ctx->Depth.Test);
         if (!_swrast_depth_test_span(ctx, span)) {
            span->interpMask = origInterpMask;
            span->arrayMask = origArrayMask;
            return;
         }
      }
   }
d775 18
a792 24
#if FEATURE_ARB_occlusion_query
   if (ctx->Query.CurrentOcclusionObject) {
      /* update count of 'passed' fragments */
      struct gl_query_object *q = ctx->Query.CurrentOcclusionObject;
      GLuint i;
      for (i = 0; i < span->end; i++)
         q->Result += span->array->mask[i];
   }
#endif

   /* we have to wait until after occlusion to do this test */
   if (ctx->Color.IndexMask == 0) {
      /* write no pixels */
      span->arrayMask = origArrayMask;
      return;
   }

   /* Interpolate the color indexes if needed */
   if (swrast->_FogEnabled ||
       ctx->Color.IndexLogicOpEnabled ||
       ctx->Color.IndexMask != 0xffffffff ||
       (span->arrayMask & SPAN_COVERAGE)) {
      if (!(span->arrayMask & SPAN_INDEX) /*span->interpMask & SPAN_INDEX*/) {
         interpolate_indexes(ctx, span);
a793 1
   }
d795 4
a798 4
   /* Fog */
   if (swrast->_FogEnabled) {
      _swrast_fog_ci_span(ctx, span);
   }
d800 1
a800 110
   /* Antialias coverage application */
   if (span->arrayMask & SPAN_COVERAGE) {
      const GLfloat *coverage = span->array->coverage;
      GLuint *index = span->array->index;
      GLuint i;
      for (i = 0; i < span->end; i++) {
         ASSERT(coverage[i] < 16);
         index[i] = (index[i] & ~0xf) | ((GLuint) coverage[i]);
      }
   }

   /*
    * Write to renderbuffers
    */
   {
      const GLuint numBuffers = fb->_NumColorDrawBuffers;
      GLuint buf;

      for (buf = 0; buf < numBuffers; buf++) {
         struct gl_renderbuffer *rb = fb->_ColorDrawBuffers[buf];
         GLuint indexSave[MAX_WIDTH];

         ASSERT(rb->_BaseFormat == GL_COLOR_INDEX);

         if (numBuffers > 1) {
            /* save indexes for second, third renderbuffer writes */
            _mesa_memcpy(indexSave, span->array->index,
                         span->end * sizeof(indexSave[0]));
         }

         if (ctx->Color.IndexLogicOpEnabled) {
            _swrast_logicop_ci_span(ctx, rb, span);
         }

         if (ctx->Color.IndexMask != 0xffffffff) {
            _swrast_mask_ci_span(ctx, rb, span);
         }

         if (!(span->arrayMask & SPAN_INDEX) && span->indexStep == 0) {
            /* all fragments have same color index */
            GLubyte index8;
            GLushort index16;
            GLuint index32;
            void *value;

            if (rb->DataType == GL_UNSIGNED_BYTE) {
               index8 = FixedToInt(span->index);
               value = &index8;
            }
            else if (rb->DataType == GL_UNSIGNED_SHORT) {
               index16 = FixedToInt(span->index);
               value = &index16;
            }
            else {
               ASSERT(rb->DataType == GL_UNSIGNED_INT);
               index32 = FixedToInt(span->index);
               value = &index32;
            }

            if (span->arrayMask & SPAN_XY) {
               rb->PutMonoValues(ctx, rb, span->end, span->array->x, 
                                 span->array->y, value, span->array->mask);
            }
            else {
               rb->PutMonoRow(ctx, rb, span->end, span->x, span->y,
                              value, span->array->mask);
            }
         }
         else {
            /* each fragment is a different color */
            GLubyte index8[MAX_WIDTH];
            GLushort index16[MAX_WIDTH];
            void *values;

            if (rb->DataType == GL_UNSIGNED_BYTE) {
               GLuint k;
               for (k = 0; k < span->end; k++) {
                  index8[k] = (GLubyte) span->array->index[k];
               }
               values = index8;
            }
            else if (rb->DataType == GL_UNSIGNED_SHORT) {
               GLuint k;
               for (k = 0; k < span->end; k++) {
                  index16[k] = (GLushort) span->array->index[k];
               }
               values = index16;
            }
            else {
               ASSERT(rb->DataType == GL_UNSIGNED_INT);
               values = span->array->index;
            }

            if (span->arrayMask & SPAN_XY) {
               rb->PutValues(ctx, rb, span->end,
                             span->array->x, span->array->y,
                             values, span->array->mask);
            }
            else {
               rb->PutRow(ctx, rb, span->end, span->x, span->y,
                          values, span->array->mask);
            }
         }

         if (buf + 1 < numBuffers) {
            /* restore original span values */
            _mesa_memcpy(span->array->index, indexSave,
                         span->end * sizeof(indexSave[0]));
         }
      } /* for buf */
a801 3

   span->interpMask = origInterpMask;
   span->arrayMask = origArrayMask;
d1001 1
a1001 1
   else if (ctx->Texture._EnabledUnits) {
d1032 1
a1032 1
   const GLuint colorMask = *((GLuint *) ctx->Color.ColorMask);
d1040 1
a1040 1
   const GLboolean shaderOrTexture = shader || ctx->Texture._EnabledUnits;
a1051 1
   ASSERT(span->end <= MAX_WIDTH);
d1059 1
a1059 1
      _mesa_memset(span->array->mask, 1, span->end);
d1064 10
a1073 3
   if ((swrast->_RasterMask & CLIP_BIT) || (span->primitive != GL_POLYGON)) {
      if (!clip_span(ctx, span)) {
	 return;
d1080 1
d1108 1
d1114 1
a1114 1
   if (ctx->Stencil.Enabled || ctx->Depth.Test) {
d1118 4
a1121 1
      if (ctx->Stencil.Enabled && fb->Visual.stencilBits > 0) {
d1124 1
d1133 1
a1138 1
#if FEATURE_ARB_occlusion_query
a1145 1
#endif
d1150 2
a1151 1
   if (colorMask == 0x0) {
d1175 8
a1182 6
   if (!shader) {
      /* Add base and specular colors */
      if (ctx->Fog.ColorSumEnabled ||
          (ctx->Light.Enabled &&
           ctx->Light.Model.ColorControl == GL_SEPARATE_SPECULAR_COLOR)) {
         add_specular(ctx, span);
d1231 2
a1232 2
               _mesa_memcpy(rgbaSave, span->array->rgba,
                            4 * span->end * sizeof(GLchan));
d1240 1
a1240 1
            else if (ctx->Color.BlendEnabled) {
d1244 2
a1245 2
            if (colorMask != 0xffffffff) {
               _swrast_mask_rgba_span(ctx, rb, span);
d1265 2
a1266 2
               _mesa_memcpy(span->array->rgba, rgbaSave,
                            4 * span->end * sizeof(GLchan));
d1300 1
a1300 1
      _mesa_bzero(rgba, 4 * n * sizeof(GLchan));
a1350 68
 * Read CI pixels from a renderbuffer.  Clipping will be done to prevent
 * reading ouside the buffer's boundaries.
 */
void
_swrast_read_index_span( GLcontext *ctx, struct gl_renderbuffer *rb,
                         GLuint n, GLint x, GLint y, GLuint index[] )
{
   const GLint bufWidth = (GLint) rb->Width;
   const GLint bufHeight = (GLint) rb->Height;

   if (y < 0 || y >= bufHeight || x + (GLint) n < 0 || x >= bufWidth) {
      /* completely above, below, or right */
      _mesa_bzero(index, n * sizeof(GLuint));
   }
   else {
      GLint skip, length;
      if (x < 0) {
         /* left edge clipping */
         skip = -x;
         length = (GLint) n - skip;
         if (length < 0) {
            /* completely left of window */
            return;
         }
         if (length > bufWidth) {
            length = bufWidth;
         }
      }
      else if ((GLint) (x + n) > bufWidth) {
         /* right edge clipping */
         skip = 0;
         length = bufWidth - x;
         if (length < 0) {
            /* completely to right of window */
            return;
         }
      }
      else {
         /* no clipping */
         skip = 0;
         length = (GLint) n;
      }

      ASSERT(rb->GetRow);
      ASSERT(rb->_BaseFormat == GL_COLOR_INDEX);

      if (rb->DataType == GL_UNSIGNED_BYTE) {
         GLubyte index8[MAX_WIDTH];
         GLint i;
         rb->GetRow(ctx, rb, length, x + skip, y, index8);
         for (i = 0; i < length; i++)
            index[skip + i] = index8[i];
      }
      else if (rb->DataType == GL_UNSIGNED_SHORT) {
         GLushort index16[MAX_WIDTH];
         GLint i;
         rb->GetRow(ctx, rb, length, x + skip, y, index16);
         for (i = 0; i < length; i++)
            index[skip + i] = index16[i];
      }
      else if (rb->DataType == GL_UNSIGNED_INT) {
         rb->GetRow(ctx, rb, length, x + skip, y, index + skip);
      }
   }
}


/**
d1459 1
a1459 3
 * Get RGBA pixels from the given renderbuffer.  Put the pixel colors into
 * the span's specular color arrays.  The specular color arrays should no
 * longer be needed by time this function is called.
d1470 2
a1471 4
   /*
    * Point rbPixels to a temporary space (use specular color arrays).
    */
   rbPixels = span->array->attribs[FRAG_ATTRIB_COL1];
@


1.3
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d33 6
a38 6
#include "glheader.h"
#include "colormac.h"
#include "context.h"
#include "macros.h"
#include "imports.h"
#include "image.h"
d445 4
a448 5
#if 0
static GLfloat
compute_lambda(GLfloat dsdx, GLfloat dsdy, GLfloat dtdx, GLfloat dtdy,
               GLfloat dqdx, GLfloat dqdy, GLfloat texW, GLfloat texH,
               GLfloat s, GLfloat t, GLfloat q, GLfloat invQ)
a459 1
#endif
d466 1
d487 1
d1035 1
d1402 5
a1406 1
    * Write to renderbuffers
d1410 3
a1412 1
      const GLboolean multiFragOutputs = numBuffers > 1;
@


1.2
log
@Update to Mesa 7.0.2. Tested by naddy@@ (full ports build), simon@@
and oga@@ (with dri enabled).
@
text
@d3 1
a3 1
 * Version:  6.5.3
d55 3
a57 2
 * Init span's Z interpolation values to the RasterPos Z.
 * Used during setup for glDraw/CopyPixels.
d60 1
a60 1
_swrast_span_default_z( GLcontext *ctx, SWspan *span )
d62 12
a73 29
   const GLfloat depthMax = ctx->DrawBuffer->_DepthMaxF;
   if (ctx->DrawBuffer->Visual.depthBits <= 16)
      span->z = FloatToFixed(ctx->Current.RasterPos[2] * depthMax + 0.5F);
   else {
      GLfloat tmpf = ctx->Current.RasterPos[2] * depthMax; 
      tmpf = MIN2(tmpf, depthMax);
      span->z = (GLint) tmpf;
   }
   span->zStep = 0;
   span->interpMask |= SPAN_Z;
}


/**
 * Init span's fogcoord interpolation values to the RasterPos fog.
 * Used during setup for glDraw/CopyPixels.
 */
void
_swrast_span_default_fog( GLcontext *ctx, SWspan *span )
{
   const SWcontext *swrast = SWRAST_CONTEXT(ctx);
   GLfloat fogVal; /* a coord or a blend factor */
   if (swrast->_PreferPixelFog) {
      /* fog blend factors will be computed from fog coordinates per pixel */
      fogVal = ctx->Current.RasterDistance;
   }
   else {
      /* fog blend factor should be computed from fogcoord now */
      fogVal = _swrast_z_to_fogfactor(ctx, ctx->Current.RasterDistance);
a74 5
   span->attrStart[FRAG_ATTRIB_FOGC][0] = fogVal;
   span->attrStepX[FRAG_ATTRIB_FOGC][0] = 0.0;
   span->attrStepY[FRAG_ATTRIB_FOGC][0] = 0.0;
   span->interpMask |= SPAN_FOG;
}
d76 4
d81 1
a81 7
/**
 * Init span's rgba or index interpolation values to the RasterPos color.
 * Used during setup for glDraw/CopyPixels.
 */
void
_swrast_span_default_color( GLcontext *ctx, SWspan *span )
{
d104 4
a113 1
}
d115 7
d123 18
a140 8
/**
 * Set the span's secondary color info to the current raster position's
 * secondary color, when needed (lighting enabled or colorsum enabled).
 */
void
_swrast_span_default_secondary_color(GLcontext *ctx, SWspan *span)
{
   if (ctx->Visual.rgbMode && (ctx->Light.Enabled || ctx->Fog.ColorSumEnabled))
d142 20
a161 21
      GLchan r, g, b, a;
      UNCLAMPED_FLOAT_TO_CHAN(r, ctx->Current.RasterSecondaryColor[0]);
      UNCLAMPED_FLOAT_TO_CHAN(g, ctx->Current.RasterSecondaryColor[1]);
      UNCLAMPED_FLOAT_TO_CHAN(b, ctx->Current.RasterSecondaryColor[2]);
      UNCLAMPED_FLOAT_TO_CHAN(a, ctx->Current.RasterSecondaryColor[3]);
#if CHAN_TYPE == GL_FLOAT
      span->specRed = r;
      span->specGreen = g;
      span->specBlue = b;
      /*span->specAlpha = a;*/
#else
      span->specRed   = IntToFixed(r);
      span->specGreen = IntToFixed(g);
      span->specBlue  = IntToFixed(b);
      /*span->specAlpha = IntToFixed(a);*/
#endif
      span->specRedStep = 0;
      span->specGreenStep = 0;
      span->specBlueStep = 0;
      /*span->specAlphaStep = 0;*/
      span->interpMask |= SPAN_SPEC;
d167 4
a170 2
 * Init span's texcoord interpolation values to the RasterPos texcoords.
 * Used during setup for glDraw/CopyPixels.
d172 2
a173 2
void
_swrast_span_default_texcoords( GLcontext *ctx, SWspan *span )
d175 35
a209 16
   GLuint i;
   for (i = 0; i < ctx->Const.MaxTextureCoordUnits; i++) {
      const GLuint attr = FRAG_ATTRIB_TEX0 + i;
      const GLfloat *tc = ctx->Current.RasterTexCoords[i];
      if (ctx->FragmentProgram._Current || ctx->ATIFragmentShader._Enabled) {
         COPY_4V(span->attrStart[attr], tc);
      }
      else if (tc[3] > 0.0F) {
         /* use (s/q, t/q, r/q, 1) */
         span->attrStart[attr][0] = tc[0] / tc[3];
         span->attrStart[attr][1] = tc[1] / tc[3];
         span->attrStart[attr][2] = tc[2] / tc[3];
         span->attrStart[attr][3] = 1.0;
      }
      else {
         ASSIGN_4V(span->attrStart[attr], 0.0F, 0.0F, 0.0F, 1.0F);
d211 1
a211 4
      ASSIGN_4V(span->attrStepX[attr], 0.0F, 0.0F, 0.0F, 0.0F);
      ASSIGN_4V(span->attrStepY[attr], 0.0F, 0.0F, 0.0F, 0.0F);
   }
   span->interpMask |= SPAN_TEXTURE;
d216 2
a217 1
 * Interpolate primary colors to fill in the span->array->color array.
d220 1
a220 1
interpolate_colors(SWspan *span)
d225 3
a227 2
   ASSERT((span->interpMask & SPAN_RGBA)  &&
          !(span->arrayMask & SPAN_RGBA));
d233 1
a233 1
         GLubyte (*rgba)[4] = span->array->color.sz1.rgba;
d268 1
a268 1
         GLushort (*rgba)[4] = span->array->color.sz2.rgba;
d280 1
a280 1
            GLushort (*rgba)[4] = span->array->color.sz2.rgba;
d306 1
a306 27
      {
         GLfloat (*rgba)[4] = span->array->attribs[FRAG_ATTRIB_COL0];
         GLfloat r, g, b, a, dr, dg, db, da;
         r = span->red;
         g = span->green;
         b = span->blue;
         a = span->alpha;
         if (span->interpMask & SPAN_FLAT) {
            dr = dg = db = da = 0.0;
         }
         else {
            dr = span->redStep;
            dg = span->greenStep;
            db = span->blueStep;
            da = span->alphaStep;
         }
         for (i = 0; i < n; i++) {
            rgba[i][RCOMP] = r;
            rgba[i][GCOMP] = g;
            rgba[i][BCOMP] = b;
            rgba[i][ACOMP] = a;
            r += dr;
            g += dg;
            b += db;
            a += da;
         }
      }
d309 1
a309 1
      _mesa_problem(NULL, "bad datatype in interpolate_colors");
d316 1
a316 1
 * Interpolate specular/secondary colors.
d319 1
a319 1
interpolate_specular(SWspan *span)
d321 1
d325 9
a333 32
   switch (span->array->ChanType) {
#if CHAN_BITS != 32
   case GL_UNSIGNED_BYTE:
      {
         GLubyte (*spec)[4] = span->array->color.sz1.spec;
         if (span->interpMask & SPAN_FLAT) {
            GLubyte color[4];
            color[RCOMP] = FixedToInt(span->specRed);
            color[GCOMP] = FixedToInt(span->specGreen);
            color[BCOMP] = FixedToInt(span->specBlue);
            color[ACOMP] = 0;
            for (i = 0; i < n; i++) {
               COPY_4UBV(spec[i], color);
            }
         }
         else {
            GLfixed r = span->specRed;
            GLfixed g = span->specGreen;
            GLfixed b = span->specBlue;
            GLint dr = span->specRedStep;
            GLint dg = span->specGreenStep;
            GLint db = span->specBlueStep;
            for (i = 0; i < n; i++) {
               spec[i][RCOMP] = CLAMP(FixedToChan(r), 0, 255);
               spec[i][GCOMP] = CLAMP(FixedToChan(g), 0, 255);
               spec[i][BCOMP] = CLAMP(FixedToChan(b), 0, 255);
               spec[i][ACOMP] = 0;
               r += dr;
               g += dg;
               b += db;
            }
         }
d335 11
a345 30
      break;
   case GL_UNSIGNED_SHORT:
      {
         GLushort (*spec)[4] = span->array->color.sz2.spec;
         if (span->interpMask & SPAN_FLAT) {
            GLushort color[4];
            color[RCOMP] = FixedToInt(span->specRed);
            color[GCOMP] = FixedToInt(span->specGreen);
            color[BCOMP] = FixedToInt(span->specBlue);
            color[ACOMP] = 0;
            for (i = 0; i < n; i++) {
               COPY_4V(spec[i], color);
            }
         }
         else {
            GLfixed r = FloatToFixed(span->specRed);
            GLfixed g = FloatToFixed(span->specGreen);
            GLfixed b = FloatToFixed(span->specBlue);
            GLint dr = FloatToFixed(span->specRedStep);
            GLint dg = FloatToFixed(span->specGreenStep);
            GLint db = FloatToFixed(span->specBlueStep);
            for (i = 0; i < n; i++) {
               spec[i][RCOMP] = FixedToInt(r);
               spec[i][GCOMP] = FixedToInt(g);
               spec[i][BCOMP] = FixedToInt(b);
               spec[i][ACOMP] = 0;
               r += dr;
               g += dg;
               b += db;
            }
d348 9
a356 29
      break;
#endif
   case GL_FLOAT:
      {
         GLfloat (*spec)[4] = span->array->attribs[FRAG_ATTRIB_COL1];
#if CHAN_BITS <= 16
         GLfloat r = CHAN_TO_FLOAT(FixedToChan(span->specRed));
         GLfloat g = CHAN_TO_FLOAT(FixedToChan(span->specGreen));
         GLfloat b = CHAN_TO_FLOAT(FixedToChan(span->specBlue));
#else
         GLfloat r = span->specRed;
         GLfloat g = span->specGreen;
         GLfloat b = span->specBlue;
#endif
         GLfloat dr, dg, db;
         if (span->interpMask & SPAN_FLAT) {
            dr = dg = db = 0.0;
         }
         else {
#if CHAN_BITS <= 16
            dr = CHAN_TO_FLOAT(FixedToChan(span->specRedStep));
            dg = CHAN_TO_FLOAT(FixedToChan(span->specGreenStep));
            db = CHAN_TO_FLOAT(FixedToChan(span->specBlueStep));
#else
            dr = span->specRedStep;
            dg = span->specGreenStep;
            db = span->specBlueStep;
#endif
         }
d358 4
a361 4
            spec[i][RCOMP] = r;
            spec[i][GCOMP] = g;
            spec[i][BCOMP] = b;
            spec[i][ACOMP] = 0.0F;
d365 1
a367 3
      break;
   default:
      _mesa_problem(NULL, "bad datatype in interpolate_specular");
d369 3
a371 1
   span->arrayMask |= SPAN_SPEC;
d375 1
d386 2
a387 2
   ASSERT((span->interpMask & SPAN_INDEX)  &&
	  !(span->arrayMask & SPAN_INDEX));
d408 3
a410 21
/* Fill in the span.array.fog values from the interpolation values */
static INLINE void
interpolate_fog(const GLcontext *ctx, SWspan *span)
{
   GLfloat (*fog)[4] = span->array->attribs[FRAG_ATTRIB_FOGC];
   const GLfloat fogStep = span->attrStepX[FRAG_ATTRIB_FOGC][0];
   GLfloat fogCoord = span->attrStart[FRAG_ATTRIB_FOGC][0];
   const GLuint haveW = (span->interpMask & SPAN_W);
   const GLfloat wStep = haveW ? span->attrStepX[FRAG_ATTRIB_WPOS][3] : 0.0F;
   GLfloat w = haveW ? span->attrStart[FRAG_ATTRIB_WPOS][3] : 1.0F;
   GLuint i;
   for (i = 0; i < span->end; i++) {
      fog[i][0] = fogCoord / w;
      fogCoord += fogStep;
      w += wStep;
   }
   span->arrayMask |= SPAN_FOG;
}


/* Fill in the span.zArray array from the interpolation values */
d417 1
a417 2
   ASSERT((span->interpMask & SPAN_Z)  &&
	  !(span->arrayMask & SPAN_Z));
d441 2
a442 1
/*
d464 3
a466 2
/*
 * This is a faster approximation
d491 5
a495 1
 * Fill in the span.texcoords array from the interpolation values.
a499 3
 * If we're using a fragment program, we never do the division
 * for texcoord projection.  That's done by the TXP instruction
 * or user-written code.
a507 5
   ASSERT(span->interpMask & SPAN_TEXTURE);
   ASSERT(!(span->arrayMask & SPAN_TEXTURE));

   span->arrayMask |= SPAN_TEXTURE;

a638 49

/**
 * Fill in the arrays->attribs[FRAG_ATTRIB_VARx] arrays from the
 * interpolation values.
 * XXX since interpolants/arrays are getting uniformed, we might merge
 * this with interpolate_texcoords(), interpolate_Fog(), etc. someday.
 */
static INLINE void
interpolate_varying(GLcontext *ctx, SWspan *span)
{
   GLuint var;
   const GLbitfield inputsUsed = ctx->FragmentProgram._Current->Base.InputsRead;

   ASSERT(span->interpMask & SPAN_VARYING);
   ASSERT(!(span->arrayMask & SPAN_VARYING));

   span->arrayMask |= SPAN_VARYING;

   for (var = 0; var < MAX_VARYING; var++) {
      if (inputsUsed & FRAG_BIT_VAR(var)) {
         const GLuint attr = FRAG_ATTRIB_VAR0 + var;
         const GLfloat dwdx = span->attrStepX[FRAG_ATTRIB_WPOS][3];
         GLfloat w = span->attrStart[FRAG_ATTRIB_WPOS][3];
         const GLfloat dv0dx = span->attrStepX[attr][0];
         const GLfloat dv1dx = span->attrStepX[attr][1];
         const GLfloat dv2dx = span->attrStepX[attr][2];
         const GLfloat dv3dx = span->attrStepX[attr][3];
         GLfloat v0 = span->attrStart[attr][0];
         GLfloat v1 = span->attrStart[attr][1];
         GLfloat v2 = span->attrStart[attr][2];
         GLfloat v3 = span->attrStart[attr][3];
         GLuint k;
         for (k = 0; k < span->end; k++) {
            GLfloat invW = 1.0f / w;
            span->array->attribs[attr][k][0] = v0 * invW;
            span->array->attribs[attr][k][1] = v1 * invW;
            span->array->attribs[attr][k][2] = v2 * invW;
            span->array->attribs[attr][k][3] = v3 * invW;
            v0 += dv0dx;
            v1 += dv1dx;
            v2 += dv2dx;
            v3 += dv3dx;
            w += dwdx;
         }
      }
   }
}


d795 1
d801 1
d803 1
d822 1
a822 1
   if (ctx->Depth.BoundsTest && ctx->DrawBuffer->Visual.depthBits > 0) {
d834 4
a837 4
            assert(span->array->x[i] >= ctx->DrawBuffer->_Xmin);
            assert(span->array->x[i] < ctx->DrawBuffer->_Xmax);
            assert(span->array->y[i] >= ctx->DrawBuffer->_Ymin);
            assert(span->array->y[i] < ctx->DrawBuffer->_Ymax);
d850 1
a850 1
      if (span->interpMask & SPAN_Z)
d880 1
a880 1
   if (ctx->Color.DrawBuffer == GL_NONE || ctx->Color.IndexMask == 0) {
d891 1
a891 1
      if (span->interpMask & SPAN_INDEX) {
d916 1
a916 4
      struct gl_framebuffer *fb = ctx->DrawBuffer;
      const GLuint output = 0; /* only frag progs can write to other outputs */
      const GLuint numDrawBuffers = fb->_NumColorDrawBuffers[output];
      GLuint indexSave[MAX_WIDTH];
d919 3
a921 5
      if (numDrawBuffers > 1) {
         /* save indexes for second, third renderbuffer writes */
         _mesa_memcpy(indexSave, span->array->index,
                      span->end * sizeof(indexSave[0]));
      }
a922 2
      for (buf = 0; buf < fb->_NumColorDrawBuffers[output]; buf++) {
         struct gl_renderbuffer *rb = fb->_ColorDrawBuffers[output][buf];
d925 6
d939 1
a939 1
         if ((span->interpMask & SPAN_INDEX) && span->indexStep == 0) {
d1005 1
a1005 1
         if (buf + 1 < numDrawBuffers) {
d1019 3
a1021 2
 * Add specular color to base color.  This is used only when
 * GL_LIGHT_MODEL_COLOR_CONTROL = GL_SEPARATE_SPECULAR_COLOR.
d1026 13
a1038 16
   switch (span->array->ChanType) {
   case GL_UNSIGNED_BYTE:
      {
         GLubyte (*rgba)[4] = span->array->color.sz1.rgba;
         GLubyte (*spec)[4] = span->array->color.sz1.spec;
         GLuint i;
         for (i = 0; i < span->end; i++) {
            GLint r = rgba[i][RCOMP] + spec[i][RCOMP];
            GLint g = rgba[i][GCOMP] + spec[i][GCOMP];
            GLint b = rgba[i][BCOMP] + spec[i][BCOMP];
            GLint a = rgba[i][ACOMP] + spec[i][ACOMP];
            rgba[i][RCOMP] = MIN2(r, 255);
            rgba[i][GCOMP] = MIN2(g, 255);
            rgba[i][BCOMP] = MIN2(b, 255);
            rgba[i][ACOMP] = MIN2(a, 255);
         }
d1040 5
a1044 16
      break;
   case GL_UNSIGNED_SHORT:
      {
         GLushort (*rgba)[4] = span->array->color.sz2.rgba;
         GLushort (*spec)[4] = span->array->color.sz2.spec;
         GLuint i;
         for (i = 0; i < span->end; i++) {
            GLint r = rgba[i][RCOMP] + spec[i][RCOMP];
            GLint g = rgba[i][GCOMP] + spec[i][GCOMP];
            GLint b = rgba[i][BCOMP] + spec[i][BCOMP];
            GLint a = rgba[i][ACOMP] + spec[i][ACOMP];
            rgba[i][RCOMP] = MIN2(r, 65535);
            rgba[i][GCOMP] = MIN2(g, 65535);
            rgba[i][BCOMP] = MIN2(b, 65535);
            rgba[i][ACOMP] = MIN2(a, 65535);
         }
d1046 15
a1060 12
      break;
   case GL_FLOAT:
      {
         GLfloat (*rgba)[4] = span->array->attribs[FRAG_ATTRIB_COL0];
         GLfloat (*spec)[4] = span->array->attribs[FRAG_ATTRIB_COL1];
         GLuint i;
         for (i = 0; i < span->end; i++) {
            rgba[i][RCOMP] += spec[i][RCOMP];
            rgba[i][GCOMP] += spec[i][GCOMP];
            rgba[i][BCOMP] += spec[i][BCOMP];
            rgba[i][ACOMP] += spec[i][ACOMP];
         }
a1061 3
      break;
   default:
      _mesa_problem(ctx, "Invalid datatype in add_specular");
d1063 2
d1077 1
a1077 1
      GLubyte (*rgba)[4] = span->array->color.sz1.rgba;
d1086 1
a1086 1
      GLushort (*rgba)[4] = span->array->color.sz2.rgba;
d1096 1
d1122 1
a1122 1
 * The only way 'output' can be greater than one is when we have a fragment
d1136 1
a1136 1
      src = span->array->color.sz1.rgba;
d1140 1
a1140 1
      src = span->array->color.sz2.rgba;
d1144 1
a1144 1
      dst = span->array->color.sz1.rgba;
d1147 1
a1147 1
      dst = span->array->color.sz2.rgba;
d1158 1
a1179 6
   if ((inputsRead & FRAG_BIT_COL0) && (span->interpMask & SPAN_RGBA))
      interpolate_colors(span);

   if (ctx->Texture._EnabledCoordUnits && (span->interpMask & SPAN_TEXTURE))
      interpolate_texcoords(ctx, span);

d1182 11
a1192 18
      /* use float colors if running a fragment program or shader */
      const GLenum oldType = span->array->ChanType;
      const GLenum newType = GL_FLOAT;

      if ((inputsRead & FRAG_BIT_COL0) && (oldType != newType)) {
         GLvoid *src = (oldType == GL_UNSIGNED_BYTE)
            ? (GLvoid *) span->array->color.sz1.rgba
            : (GLvoid *) span->array->color.sz2.rgba;
         assert(span->arrayMask & SPAN_RGBA);
         _mesa_convert_colors(oldType, src,
                              newType, span->array->attribs[FRAG_ATTRIB_COL0],
                              span->end, span->array->mask);
      }
      span->array->ChanType = newType;

      /* fragment programs/shaders may need specular, fog and Z coords */
      if ((inputsRead & FRAG_BIT_COL1) && (span->interpMask & SPAN_SPEC))
         interpolate_specular(span);
d1194 1
a1194 4
      if ((inputsRead & FRAG_BIT_FOGC) && (span->interpMask & SPAN_FOG))
         interpolate_fog(ctx, span);

      if (span->interpMask & SPAN_Z)
a1196 3
      if ((inputsRead >= FRAG_BIT_VAR0) && (span->interpMask & SPAN_VARYING))
         interpolate_varying(ctx, span);

d1213 1
a1213 1
   else if (ctx->Texture._EnabledUnits && (span->arrayMask & SPAN_TEXTURE)) {
d1215 12
d1247 3
a1249 1
   const GLenum chanType = span->array->ChanType;
a1253 2
   GLuint output;
   GLboolean deferredTexture;
a1264 35
   ASSERT((span->interpMask & span->arrayMask) == 0);
   ASSERT((span->interpMask & SPAN_RGBA) ^ (span->arrayMask & SPAN_RGBA));

   /* check for conditions that prevent deferred shading (doing shading
    * after stencil/ztest).
    * XXX move this code into state validation.
    */
   if (ctx->Color.AlphaEnabled) {
      /* alpha test depends on post-texture/shader colors */
      deferredTexture = GL_FALSE;
   }
   else if (shaderOrTexture) {
      if (ctx->FragmentProgram._Current) {
         if (ctx->FragmentProgram._Current->Base.OutputsWritten
             & (1 << FRAG_RESULT_DEPR)) {
            /* Z comes from fragment program/shader */
            deferredTexture = GL_FALSE;
         }
         else if (ctx->Query.CurrentOcclusionObject) {
            /* occlusion query depends on shader discard/kill results */
            deferredTexture = GL_FALSE;
         }
         else {
            deferredTexture = GL_TRUE;
         }
      }
      else {
         /* ATI frag shader or conventional texturing */
         deferredTexture = GL_TRUE;
      }
   }
   else {
      /* no texturing or shadering */
      deferredTexture = GL_FALSE;
   }
d1303 2
a1304 4
   /* This is the normal place to compute the resulting fragment color/Z.
    * As an optimization, we try to defer this until after Z/stencil
    * testing in order to try to avoid computing colors that we won't
    * actually need.
d1306 1
a1306 1
   if (shaderOrTexture && !deferredTexture) {
d1319 1
a1319 1
      if (span->interpMask & SPAN_Z)
d1359 1
a1359 2
   if (deferredTexture) {
      ASSERT(shaderOrTexture);
d1363 5
d1369 1
a1369 1
      interpolate_colors(span);
d1371 1
d1380 1
a1380 11
         if (span->interpMask & SPAN_SPEC) {
            interpolate_specular(span);
         }
         if (span->arrayMask & SPAN_SPEC) {
            add_specular(ctx, span);
         }
         else {
            /* We probably added the base/specular colors during the
             * vertex stage!
             */
         }
d1403 61
a1463 61
   /* Loop over color outputs (GL_ARB_draw_buffers) written by frag prog */
   for (output = 0; output < swrast->_NumColorOutputs; output++) {
      if (swrast->_ColorOutputsMask & (1 << output)) {
        const GLuint numDrawBuffers = fb->_NumColorDrawBuffers[output];
        GLchan rgbaSave[MAX_WIDTH][4];
        GLuint buf;

        ASSERT(numDrawBuffers > 0);

        if (fb->_ColorDrawBuffers[output][0]->DataType
            != span->array->ChanType || output > 0) {
           convert_color_type(span,
                              fb->_ColorDrawBuffers[output][0]->DataType,
                              output);
        }

        if (numDrawBuffers > 1) {
           /* save colors for second, third renderbuffer writes */
           _mesa_memcpy(rgbaSave, span->array->rgba,
                        4 * span->end * sizeof(GLchan));
        }

        /* Loop over renderbuffers (i.e. GL_FRONT_AND_BACK) */
        for (buf = 0; buf < numDrawBuffers; buf++) {
           struct gl_renderbuffer *rb = fb->_ColorDrawBuffers[output][buf];
           ASSERT(rb->_BaseFormat == GL_RGBA || rb->_BaseFormat == GL_RGB);

           if (ctx->Color._LogicOpEnabled) {
              _swrast_logicop_rgba_span(ctx, rb, span);
           }
           else if (ctx->Color.BlendEnabled) {
              _swrast_blend_span(ctx, rb, span);
           }

           if (colorMask != 0xffffffff) {
              _swrast_mask_rgba_span(ctx, rb, span);
           }

           if (span->arrayMask & SPAN_XY) {
              /* array of pixel coords */
              ASSERT(rb->PutValues);
              rb->PutValues(ctx, rb, span->end,
                            span->array->x, span->array->y,
                            span->array->rgba, span->array->mask);
           }
           else {
              /* horizontal run of pixels */
              ASSERT(rb->PutRow);
              rb->PutRow(ctx, rb, span->end, span->x, span->y,
                         span->array->rgba,
                         span->writeAll ? NULL: span->array->mask);
           }

           if (buf + 1 < numDrawBuffers) {
              /* restore original span values */
              _mesa_memcpy(span->array->rgba, rgbaSave,
                           4 * span->end * sizeof(GLchan));
           }
        } /* for buf */
      } /* if output is written to */
   } /* for output */
d1469 3
a1471 1
   span->array->ChanType = chanType;
a1732 1
    * Determine pixel size (in bytes).
d1735 1
a1735 9
   if (span->array->ChanType == GL_UNSIGNED_BYTE) {
      rbPixels = span->array->color.sz1.spec;
   }
   else if (span->array->ChanType == GL_UNSIGNED_SHORT) {
      rbPixels = span->array->color.sz2.spec;
   }
   else {
      rbPixels = span->array->attribs[FRAG_ATTRIB_COL1];
   }
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * Version:  6.5
d5 1
a5 1
 * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
d38 1
a41 1
#include "s_arbshader.h"
d48 1
a48 1
#include "s_nvfragprog.h"
d59 1
a59 1
_swrast_span_default_z( GLcontext *ctx, struct sw_span *span )
d64 5
a68 2
   else
      span->z = (GLint) (ctx->Current.RasterPos[2] * depthMax + 0.5F);
d75 1
a75 1
 * Init span's fog interpolation values to the RasterPos fog.
d79 1
a79 1
_swrast_span_default_fog( GLcontext *ctx, struct sw_span *span )
d81 13
a93 2
   span->fog = _swrast_z_to_fogfactor(ctx, ctx->Current.RasterDistance);
   span->fogStep = span->dfogdx = span->dfogdy = 0.0F;
d103 1
a103 1
_swrast_span_default_color( GLcontext *ctx, struct sw_span *span )
d137 34
d175 1
a175 1
_swrast_span_default_texcoords( GLcontext *ctx, struct sw_span *span )
d179 1
d181 2
a182 2
      if (ctx->FragmentProgram._Active || ctx->ATIFragmentShader._Enabled) {
         COPY_4V(span->tex[i], tc);
d186 4
a189 4
         span->tex[i][0] = tc[0] / tc[3];
         span->tex[i][1] = tc[1] / tc[3];
         span->tex[i][2] = tc[2] / tc[3];
         span->tex[i][3] = 1.0;
d192 1
a192 1
         ASSIGN_4V(span->tex[i], 0.0F, 0.0F, 0.0F, 1.0F);
d194 2
a195 2
      ASSIGN_4V(span->texStepX[i], 0.0F, 0.0F, 0.0F, 0.0F);
      ASSIGN_4V(span->texStepY[i], 0.0F, 0.0F, 0.0F, 0.0F);
d201 5
a205 3
/* Fill in the span.color.rgba array from the interpolation values */
static void
interpolate_colors(GLcontext *ctx, struct sw_span *span)
a207 1
   GLchan (*rgba)[4] = span->array->rgba;
a208 1
   (void) ctx;
d211 1
a211 1
	  !(span->arrayMask & SPAN_RGBA));
d213 103
a315 9
   if (span->interpMask & SPAN_FLAT) {
      /* constant color */
      GLchan color[4];
      color[RCOMP] = FixedToChan(span->red);
      color[GCOMP] = FixedToChan(span->green);
      color[BCOMP] = FixedToChan(span->blue);
      color[ACOMP] = FixedToChan(span->alpha);
      for (i = 0; i < n; i++) {
         COPY_CHAN4(span->array->rgba[i], color);
d317 3
d321 101
a421 11
   else {
      /* interpolate */
#if CHAN_TYPE == GL_FLOAT
      GLfloat r = span->red;
      GLfloat g = span->green;
      GLfloat b = span->blue;
      GLfloat a = span->alpha;
      const GLfloat dr = span->redStep;
      const GLfloat dg = span->greenStep;
      const GLfloat db = span->blueStep;
      const GLfloat da = span->alphaStep;
d423 3
a425 8
      GLfixed r = span->red;
      GLfixed g = span->green;
      GLfixed b = span->blue;
      GLfixed a = span->alpha;
      const GLint dr = span->redStep;
      const GLint dg = span->greenStep;
      const GLint db = span->blueStep;
      const GLint da = span->alphaStep;
d427 10
a436 9
      for (i = 0; i < n; i++) {
         rgba[i][RCOMP] = FixedToChan(r);
         rgba[i][GCOMP] = FixedToChan(g);
         rgba[i][BCOMP] = FixedToChan(b);
         rgba[i][ACOMP] = FixedToChan(a);
         r += dr;
         g += dg;
         b += db;
         a += da;
d438 3
d442 1
a442 1
   span->arrayMask |= SPAN_RGBA;
d447 2
a448 2
static void
interpolate_indexes(GLcontext *ctx, struct sw_span *span)
a477 42
/* Fill in the span.->array->spec array from the interpolation values */
static void
interpolate_specular(GLcontext *ctx, struct sw_span *span)
{
   (void) ctx;
   if (span->interpMask & SPAN_FLAT) {
      /* constant color */
      const GLchan r = FixedToChan(span->specRed);
      const GLchan g = FixedToChan(span->specGreen);
      const GLchan b = FixedToChan(span->specBlue);
      GLuint i;
      for (i = 0; i < span->end; i++) {
         span->array->spec[i][RCOMP] = r;
         span->array->spec[i][GCOMP] = g;
         span->array->spec[i][BCOMP] = b;
      }
   }
   else {
      /* interpolate */
#if CHAN_TYPE == GL_FLOAT
      GLfloat r = span->specRed;
      GLfloat g = span->specGreen;
      GLfloat b = span->specBlue;
#else
      GLfixed r = span->specRed;
      GLfixed g = span->specGreen;
      GLfixed b = span->specBlue;
#endif
      GLuint i;
      for (i = 0; i < span->end; i++) {
         span->array->spec[i][RCOMP] = FixedToChan(r);
         span->array->spec[i][GCOMP] = FixedToChan(g);
         span->array->spec[i][BCOMP] = FixedToChan(b);
         r += span->specRedStep;
         g += span->specGreenStep;
         b += span->specBlueStep;
      }
   }
   span->arrayMask |= SPAN_SPEC;
}


d479 2
a480 2
static void
interpolate_fog(const GLcontext *ctx, struct sw_span *span)
d482 3
a484 3
   GLfloat *fog = span->array->fog;
   const GLfloat fogStep = span->fogStep;
   GLfloat fogCoord = span->fog;
d486 2
a487 2
   const GLfloat wStep = haveW ? span->dwdx : 0.0F;
   GLfloat w = haveW ? span->w : 1.0F;
d490 1
a490 1
      fog[i] = fogCoord / w;
d500 1
a500 1
_swrast_span_interpolate_z( const GLcontext *ctx, struct sw_span *span )
d588 1
a588 1
interpolate_texcoords(GLcontext *ctx, struct sw_span *span)
d590 4
d597 1
a597 58
   if (ctx->Texture._EnabledCoordUnits > 1) {
      /* multitexture */
      GLuint u;
      span->arrayMask |= SPAN_TEXTURE;
      /* XXX CoordUnits vs. ImageUnits */
      for (u = 0; u < ctx->Const.MaxTextureUnits; u++) {
         if (ctx->Texture._EnabledCoordUnits & (1 << u)) {
            const struct gl_texture_object *obj =ctx->Texture.Unit[u]._Current;
            GLfloat texW, texH;
            GLboolean needLambda;
            if (obj) {
               const struct gl_texture_image *img = obj->Image[0][obj->BaseLevel];
               needLambda = (obj->MinFilter != obj->MagFilter)
                  || ctx->FragmentProgram._Active;
               texW = img->WidthScale;
               texH = img->HeightScale;
            }
            else {
               /* using a fragment program */
               texW = 1.0;
               texH = 1.0;
               needLambda = GL_FALSE;
            }
            if (needLambda) {
               GLfloat (*texcoord)[4] = span->array->texcoords[u];
               GLfloat *lambda = span->array->lambda[u];
               const GLfloat dsdx = span->texStepX[u][0];
               const GLfloat dsdy = span->texStepY[u][0];
               const GLfloat dtdx = span->texStepX[u][1];
               const GLfloat dtdy = span->texStepY[u][1];
               const GLfloat drdx = span->texStepX[u][2];
               const GLfloat dqdx = span->texStepX[u][3];
               const GLfloat dqdy = span->texStepY[u][3];
               GLfloat s = span->tex[u][0];
               GLfloat t = span->tex[u][1];
               GLfloat r = span->tex[u][2];
               GLfloat q = span->tex[u][3];
               GLuint i;
               if (ctx->FragmentProgram._Active || ctx->ATIFragmentShader._Enabled ||
                   ctx->ShaderObjects._FragmentShaderPresent) {
                  /* do perspective correction but don't divide s, t, r by q */
                  const GLfloat dwdx = span->dwdx;
                  GLfloat w = span->w;
                  for (i = 0; i < span->end; i++) {
                     const GLfloat invW = 1.0F / w;
                     texcoord[i][0] = s * invW;
                     texcoord[i][1] = t * invW;
                     texcoord[i][2] = r * invW;
                     texcoord[i][3] = q * invW;
                     lambda[i] = _swrast_compute_lambda(dsdx, dsdy, dtdx, dtdy,
                                                        dqdx, dqdy, texW, texH,
                                                        s, t, q, invW);
                     s += dsdx;
                     t += dtdx;
                     r += drdx;
                     q += dqdx;
                     w += dwdx;
                  }
d599 56
a655 17
               else {
                  for (i = 0; i < span->end; i++) {
                     const GLfloat invQ = (q == 0.0F) ? 1.0F : (1.0F / q);
                     texcoord[i][0] = s * invQ;
                     texcoord[i][1] = t * invQ;
                     texcoord[i][2] = r * invQ;
                     texcoord[i][3] = q;
                     lambda[i] = _swrast_compute_lambda(dsdx, dsdy, dtdx, dtdy,
                                                        dqdx, dqdy, texW, texH,
                                                        s, t, q, invQ);
                     s += dsdx;
                     t += dtdx;
                     r += drdx;
                     q += dqdx;
                  }
               }
               span->arrayMask |= SPAN_LAMBDA;
d658 1
a658 32
               GLfloat (*texcoord)[4] = span->array->texcoords[u];
               GLfloat *lambda = span->array->lambda[u];
               const GLfloat dsdx = span->texStepX[u][0];
               const GLfloat dtdx = span->texStepX[u][1];
               const GLfloat drdx = span->texStepX[u][2];
               const GLfloat dqdx = span->texStepX[u][3];
               GLfloat s = span->tex[u][0];
               GLfloat t = span->tex[u][1];
               GLfloat r = span->tex[u][2];
               GLfloat q = span->tex[u][3];
               GLuint i;
               if (ctx->FragmentProgram._Active || ctx->ATIFragmentShader._Enabled ||
                   ctx->ShaderObjects._FragmentShaderPresent) {
                  /* do perspective correction but don't divide s, t, r by q */
                  const GLfloat dwdx = span->dwdx;
                  GLfloat w = span->w;
                  for (i = 0; i < span->end; i++) {
                     const GLfloat invW = 1.0F / w;
                     texcoord[i][0] = s * invW;
                     texcoord[i][1] = t * invW;
                     texcoord[i][2] = r * invW;
                     texcoord[i][3] = q * invW;
                     lambda[i] = 0.0;
                     s += dsdx;
                     t += dtdx;
                     r += drdx;
                     q += dqdx;
                     w += dwdx;
                  }
               }
               else if (dqdx == 0.0F) {
                  /* Ortho projection or polygon's parallel to window X axis */
d660 11
a670 24
                  for (i = 0; i < span->end; i++) {
                     texcoord[i][0] = s * invQ;
                     texcoord[i][1] = t * invQ;
                     texcoord[i][2] = r * invQ;
                     texcoord[i][3] = q;
                     lambda[i] = 0.0;
                     s += dsdx;
                     t += dtdx;
                     r += drdx;
                  }
               }
               else {
                  for (i = 0; i < span->end; i++) {
                     const GLfloat invQ = (q == 0.0F) ? 1.0F : (1.0F / q);
                     texcoord[i][0] = s * invQ;
                     texcoord[i][1] = t * invQ;
                     texcoord[i][2] = r * invQ;
                     texcoord[i][3] = q;
                     lambda[i] = 0.0;
                     s += dsdx;
                     t += dtdx;
                     r += drdx;
                     q += dqdx;
                  }
a671 56
            } /* lambda */
         } /* if */
      } /* for */
   }
   else {
      /* single texture */
      const struct gl_texture_object *obj = ctx->Texture.Unit[0]._Current;
      GLfloat texW, texH;
      GLboolean needLambda;
      if (obj) {
         const struct gl_texture_image *img = obj->Image[0][obj->BaseLevel];
         needLambda = (obj->MinFilter != obj->MagFilter)
            || ctx->FragmentProgram._Active;
         texW = (GLfloat) img->WidthScale;
         texH = (GLfloat) img->HeightScale;
      }
      else {
         needLambda = GL_FALSE;
         texW = texH = 1.0;
      }
      span->arrayMask |= SPAN_TEXTURE;
      if (needLambda) {
         /* just texture unit 0, with lambda */
         GLfloat (*texcoord)[4] = span->array->texcoords[0];
         GLfloat *lambda = span->array->lambda[0];
         const GLfloat dsdx = span->texStepX[0][0];
         const GLfloat dsdy = span->texStepY[0][0];
         const GLfloat dtdx = span->texStepX[0][1];
         const GLfloat dtdy = span->texStepY[0][1];
         const GLfloat drdx = span->texStepX[0][2];
         const GLfloat dqdx = span->texStepX[0][3];
         const GLfloat dqdy = span->texStepY[0][3];
         GLfloat s = span->tex[0][0];
         GLfloat t = span->tex[0][1];
         GLfloat r = span->tex[0][2];
         GLfloat q = span->tex[0][3];
         GLuint i;
         if (ctx->FragmentProgram._Active || ctx->ATIFragmentShader._Enabled ||
             ctx->ShaderObjects._FragmentShaderPresent) {
            /* do perspective correction but don't divide s, t, r by q */
            const GLfloat dwdx = span->dwdx;
            GLfloat w = span->w;
            for (i = 0; i < span->end; i++) {
               const GLfloat invW = 1.0F / w;
               texcoord[i][0] = s * invW;
               texcoord[i][1] = t * invW;
               texcoord[i][2] = r * invW;
               texcoord[i][3] = q * invW;
               lambda[i] = _swrast_compute_lambda(dsdx, dsdy, dtdx, dtdy,
                                                  dqdx, dqdy, texW, texH,
                                                  s, t, q, invW);
               s += dsdx;
               t += dtdx;
               r += drdx;
               q += dqdx;
               w += dwdx;
d673 1
d676 22
a697 2
            /* tex.c */
            for (i = 0; i < span->end; i++) {
d699 10
a708 11
               lambda[i] = _swrast_compute_lambda(dsdx, dsdy, dtdx, dtdy,
                                                dqdx, dqdy, texW, texH,
                                                s, t, q, invQ);
               texcoord[i][0] = s * invQ;
               texcoord[i][1] = t * invQ;
               texcoord[i][2] = r * invQ;
               texcoord[i][3] = q;
               s += dsdx;
               t += dtdx;
               r += drdx;
               q += dqdx;
d710 13
a722 57
         }
         span->arrayMask |= SPAN_LAMBDA;
      }
      else {
         /* just texture 0, without lambda */
         GLfloat (*texcoord)[4] = span->array->texcoords[0];
         const GLfloat dsdx = span->texStepX[0][0];
         const GLfloat dtdx = span->texStepX[0][1];
         const GLfloat drdx = span->texStepX[0][2];
         const GLfloat dqdx = span->texStepX[0][3];
         GLfloat s = span->tex[0][0];
         GLfloat t = span->tex[0][1];
         GLfloat r = span->tex[0][2];
         GLfloat q = span->tex[0][3];
         GLuint i;
         if (ctx->FragmentProgram._Active || ctx->ATIFragmentShader._Enabled ||
             ctx->ShaderObjects._FragmentShaderPresent) {
            /* do perspective correction but don't divide s, t, r by q */
            const GLfloat dwdx = span->dwdx;
            GLfloat w = span->w;
            for (i = 0; i < span->end; i++) {
               const GLfloat invW = 1.0F / w;
               texcoord[i][0] = s * invW;
               texcoord[i][1] = t * invW;
               texcoord[i][2] = r * invW;
               texcoord[i][3] = q * invW;
               s += dsdx;
               t += dtdx;
               r += drdx;
               q += dqdx;
               w += dwdx;
            }
         }
         else if (dqdx == 0.0F) {
            /* Ortho projection or polygon's parallel to window X axis */
            const GLfloat invQ = (q == 0.0F) ? 1.0F : (1.0F / q);
            for (i = 0; i < span->end; i++) {
               texcoord[i][0] = s * invQ;
               texcoord[i][1] = t * invQ;
               texcoord[i][2] = r * invQ;
               texcoord[i][3] = q;
               s += dsdx;
               t += dtdx;
               r += drdx;
            }
         }
         else {
            for (i = 0; i < span->end; i++) {
               const GLfloat invQ = (q == 0.0F) ? 1.0F : (1.0F / q);
               texcoord[i][0] = s * invQ;
               texcoord[i][1] = t * invQ;
               texcoord[i][2] = r * invQ;
               texcoord[i][3] = q;
               s += dsdx;
               t += dtdx;
               r += drdx;
               q += dqdx;
d724 3
a726 3
         }
      }
   }
d730 1
d732 4
a735 1
 * Fill in the span.varying array from the interpolation values.
d737 2
a738 2
static void
interpolate_varying(GLcontext *ctx, struct sw_span *span)
d740 2
a741 1
   GLuint i, j;
d748 13
a760 6
   for (i = 0; i < MAX_VARYING_VECTORS; i++) {
      for (j = 0; j < VARYINGS_PER_VECTOR; j++) {
         const GLfloat dvdx = span->varStepX[i][j];
         GLfloat v = span->var[i][j];
         const GLfloat dwdx = span->dwdx;
         GLfloat w = span->w;
a761 1

d764 8
a771 2
            span->array->varying[k][i][j] = v * invW;
            v += dvdx;
d780 34
d816 2
a817 2
static void
stipple_polygon_span( GLcontext *ctx, struct sw_span *span )
a818 2
   const GLuint highbit = 0x80000000;
   const GLuint stipple = ctx->PolygonStipple[span->y % 32];
a819 1
   GLuint i, m;
a821 1
   ASSERT((span->arrayMask & SPAN_XY) == 0);
d823 10
a832 5
   m = highbit >> (GLuint) (span->x % 32);

   for (i = 0; i < span->end; i++) {
      if ((m & stipple) == 0) {
	 mask[i] = 0;
d834 14
a847 3
      m = m >> 1;
      if (m == 0) {
         m = highbit;
d861 2
a862 2
static GLuint
clip_span( GLcontext *ctx, struct sw_span *span )
d930 1
a930 1
_swrast_write_index_span( GLcontext *ctx, struct sw_span *span)
a932 2
   const struct gl_framebuffer *fb = ctx->DrawBuffer;
   const GLuint output = 0;
a934 1
   GLuint buf;
d1049 19
a1067 11
   /* Loop over drawing buffers */
   for (buf = 0; buf < fb->_NumColorDrawBuffers[output]; buf++) {
      struct gl_renderbuffer *rb = fb->_ColorDrawBuffers[output][buf];
      GLuint indexTemp[MAX_WIDTH], *index32;

      ASSERT(rb->_BaseFormat == GL_COLOR_INDEX);

      if (ctx->Color.IndexLogicOpEnabled ||
          ctx->Color.IndexMask != 0xffffffff) {
         /* make copy of incoming indexes */
         MEMCPY(indexTemp, span->array->index, span->end * sizeof(GLuint));
d1070 1
a1070 1
            _swrast_logicop_ci_span(ctx, rb, span, indexTemp);
d1074 1
a1074 1
            _swrast_mask_ci_span(ctx, rb, span, indexTemp);
a1075 5
         index32 = indexTemp;
      }
      else {
         index32 = span->array->index;
      }
d1077 20
a1096 20
      if ((span->interpMask & SPAN_INDEX) && span->indexStep == 0) {
         /* all fragments have same color index */
         GLubyte index8;
         GLushort index16;
         GLuint index32;
         void *value;

         if (rb->DataType == GL_UNSIGNED_BYTE) {
            index8 = FixedToInt(span->index);
            value = &index8;
         }
         else if (rb->DataType == GL_UNSIGNED_SHORT) {
            index16 = FixedToInt(span->index);
            value = &index16;
         }
         else {
            ASSERT(rb->DataType == GL_UNSIGNED_INT);
            index32 = FixedToInt(span->index);
            value = &index32;
         }
d1098 8
a1105 3
         if (span->arrayMask & SPAN_XY) {
            rb->PutMonoValues(ctx, rb, span->end, span->array->x, 
                              span->array->y, value, span->array->mask);
d1108 23
a1130 9
            rb->PutMonoRow(ctx, rb, span->end, span->x, span->y,
                           value, span->array->mask);
         }
      }
      else {
         /* each fragment is a different color */
         GLubyte index8[MAX_WIDTH];
         GLushort index16[MAX_WIDTH];
         void *values;
d1132 4
a1135 4
         if (rb->DataType == GL_UNSIGNED_BYTE) {
            GLuint k;
            for (k = 0; k < span->end; k++) {
               index8[k] = (GLubyte) index32[k];
d1137 3
a1139 6
            values = index8;
         }
         else if (rb->DataType == GL_UNSIGNED_SHORT) {
            GLuint k;
            for (k = 0; k < span->end; k++) {
               index16[k] = (GLushort) index32[k];
a1140 5
            values = index16;
         }
         else {
            ASSERT(rb->DataType == GL_UNSIGNED_INT);
            values = index32;
d1143 4
a1146 7
         if (span->arrayMask & SPAN_XY) {
            rb->PutValues(ctx, rb, span->end, span->array->x, span->array->y,
                          values, span->array->mask);
         }
         else {
            rb->PutRow(ctx, rb, span->end, span->x, span->y,
                       values, span->array->mask);
d1148 1
a1148 1
      }
d1160 62
a1221 2
static void
add_colors(GLuint n, GLchan rgba[][4], GLchan specular[][4] )
d1223 1
d1225 21
a1245 14
   for (i = 0; i < n; i++) {
#if CHAN_TYPE == GL_FLOAT
      /* no clamping */
      rgba[i][RCOMP] += specular[i][RCOMP];
      rgba[i][GCOMP] += specular[i][GCOMP];
      rgba[i][BCOMP] += specular[i][BCOMP];
#else
      GLint r = rgba[i][RCOMP] + specular[i][RCOMP];
      GLint g = rgba[i][GCOMP] + specular[i][GCOMP];
      GLint b = rgba[i][BCOMP] + specular[i][BCOMP];
      rgba[i][RCOMP] = (GLchan) MIN2(r, CHAN_MAX);
      rgba[i][GCOMP] = (GLchan) MIN2(g, CHAN_MAX);
      rgba[i][BCOMP] = (GLchan) MIN2(b, CHAN_MAX);
#endif
d1251 1
a1251 5
 * XXX merge this code into the _swrast_write_rgba_span() routine!
 *
 * Draw to more than one RGBA color buffer (or none).
 * All fragment operations, up to (but not) blending/logicop should
 * have been done first.
d1253 2
a1254 2
static void
multi_write_rgba_span( GLcontext *ctx, struct sw_span *span )
d1256 1
a1256 3
   const GLuint colorMask = *((GLuint *) ctx->Color.ColorMask);
   struct gl_framebuffer *fb = ctx->DrawBuffer;
   const GLuint output = 0;
d1258 68
d1327 2
a1328 2
   ASSERT(span->end < MAX_WIDTH);
   ASSERT(colorMask != 0x0);
d1330 26
a1355 3
   for (i = 0; i < fb->_NumColorDrawBuffers[output]; i++) {
      struct gl_renderbuffer *rb = fb->_ColorDrawBuffers[output][i];
      GLchan rgbaTmp[MAX_WIDTH][4];
d1357 2
a1358 2
      /* make copy of incoming colors */
      MEMCPY( rgbaTmp, span->array->rgba, 4 * span->end * sizeof(GLchan) );
d1360 2
a1361 6
      if (ctx->Color._LogicOpEnabled) {
         _swrast_logicop_rgba_span(ctx, rb, span, rgbaTmp);
      }
      else if (ctx->Color.BlendEnabled) {
         _swrast_blend_span(ctx, rb, span, rgbaTmp);
      }
d1363 6
a1368 3
      if (colorMask != 0xffffffff) {
         _swrast_mask_rgba_span(ctx, rb, span, rgbaTmp);
      }
d1370 3
a1372 5
      if (span->arrayMask & SPAN_XY) {
         /* array of pixel coords */
         ASSERT(rb->PutValues);
         rb->PutValues(ctx, rb, span->end, span->array->x,
                       span->array->y, rgbaTmp, span->array->mask);
d1375 2
a1376 4
         /* horizontal run of pixels */
         ASSERT(rb->PutRow);
         rb->PutRow(ctx, rb, span->end, span->x, span->y, rgbaTmp,
                    span->array->mask);
d1379 4
d1386 1
d1395 1
a1395 1
_swrast_write_rgba_span( GLcontext *ctx, struct sw_span *span)
d1397 1
a1398 1
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
d1401 7
a1407 8
   const GLboolean deferredTexture = !(ctx->Color.AlphaEnabled ||
                                       ctx->FragmentProgram._Active ||
                                       ctx->ShaderObjects._FragmentShaderPresent);

   ASSERT(span->primitive == GL_POINT  ||  span->primitive == GL_LINE ||
	  span->primitive == GL_POLYGON  ||  span->primitive == GL_BITMAP);
   ASSERT(span->end <= MAX_WIDTH);
   ASSERT((span->interpMask & span->arrayMask) == 0);
d1414 42
d1478 4
a1481 4
            assert(span->array->x[i] >= ctx->DrawBuffer->_Xmin);
            assert(span->array->x[i] < ctx->DrawBuffer->_Xmax);
            assert(span->array->y[i] >= ctx->DrawBuffer->_Ymin);
            assert(span->array->y[i] < ctx->DrawBuffer->_Ymax);
a1491 11
   /* Interpolate texcoords? */
   if (ctx->Texture._EnabledCoordUnits
       && (span->interpMask & SPAN_TEXTURE)
       && (span->arrayMask & SPAN_TEXTURE) == 0) {
      interpolate_texcoords(ctx, span);
   }

   if (ctx->ShaderObjects._FragmentShaderPresent) {
      interpolate_varying(ctx, span);
   }

d1497 3
a1499 10
   if (!deferredTexture) {
      /* Now we need the rgba array, fill it in if needed */
      if ((span->interpMask & SPAN_RGBA) && (span->arrayMask & SPAN_RGBA) == 0)
         interpolate_colors(ctx, span);

      if (span->interpMask & SPAN_SPEC)
         interpolate_specular(ctx, span);

      if (span->interpMask & SPAN_FOG)
         interpolate_fog(ctx, span);
d1501 4
a1504 26
      /* Compute fragment colors with fragment program or texture lookups */
#if FEATURE_ARB_fragment_shader
      if (ctx->ShaderObjects._FragmentShaderPresent) {
         if (span->interpMask & SPAN_Z)
            _swrast_span_interpolate_z (ctx, span);
         _swrast_exec_arbshader (ctx, span);
      }
      else
#endif
      if (ctx->FragmentProgram._Active) {
         /* frag prog may need Z values */
         if (span->interpMask & SPAN_Z)
            _swrast_span_interpolate_z(ctx, span);
         _swrast_exec_fragment_program( ctx, span );
      }
      else if (ctx->ATIFragmentShader._Enabled)
         _swrast_exec_fragment_shader( ctx, span );
      else if (ctx->Texture._EnabledUnits && (span->arrayMask & SPAN_TEXTURE))
         _swrast_texture_span( ctx, span );

      /* Do the alpha test */
      if (ctx->Color.AlphaEnabled) {
         if (!_swrast_alpha_test(ctx, span)) {
            span->arrayMask = origArrayMask;
	    return;
	 }
d1513 1
a1513 1
      if (ctx->Stencil.Enabled && ctx->DrawBuffer->Visual.stencilBits > 0) {
d1516 1
a1516 3
            span->interpMask = origInterpMask;
            span->arrayMask = origArrayMask;
            return;
d1519 1
a1519 1
      else if (ctx->DrawBuffer->Visual.depthBits > 0) {
d1524 1
a1524 3
            span->interpMask = origInterpMask;
            span->arrayMask = origArrayMask;
            return;
d1543 1
a1543 3
      span->interpMask = origInterpMask;
      span->arrayMask = origArrayMask;
      return;
d1551 3
a1553 3
      /* Now we need the rgba array, fill it in if needed */
      if ((span->interpMask & SPAN_RGBA) && (span->arrayMask & SPAN_RGBA) == 0)
         interpolate_colors(ctx, span);
d1555 2
a1556 20
      if (span->interpMask & SPAN_SPEC)
         interpolate_specular(ctx, span);

      if (span->interpMask & SPAN_FOG)
         interpolate_fog(ctx, span);

#if FEATURE_ARB_fragment_shader
      if (ctx->ShaderObjects._FragmentShaderPresent) {
         if (span->interpMask & SPAN_Z)
            _swrast_span_interpolate_z (ctx, span);
         _swrast_exec_arbshader (ctx, span);
      }
      else
#endif
      if (ctx->FragmentProgram._Active)
         _swrast_exec_fragment_program( ctx, span );
      else if (ctx->ATIFragmentShader._Enabled)
         _swrast_exec_fragment_shader( ctx, span );
      else if (ctx->Texture._EnabledUnits && (span->arrayMask & SPAN_TEXTURE))
         _swrast_texture_span( ctx, span );
d1561 1
a1561 1
   if (!ctx->FragmentProgram._Enabled) {
d1567 1
a1567 1
            interpolate_specular(ctx, span);
d1570 1
a1570 1
            add_colors( span->end, span->array->rgba, span->array->spec );
d1587 1
a1587 6
      GLchan (*rgba)[4] = span->array->rgba;
      GLfloat *coverage = span->array->coverage;
      GLuint i;
      for (i = 0; i < span->end; i++) {
         rgba[i][ACOMP] = (GLchan) (rgba[i][ACOMP] * coverage[i]);
      }
d1591 3
a1593 10
#if CHAN_TYPE == GL_FLOAT
   if (ctx->Color.ClampFragmentColor) {
      GLchan (*rgba)[4] = span->array->rgba;
      GLuint i;
      for (i = 0; i < span->end; i++) {
         rgba[i][RCOMP] = CLAMP(rgba[i][RCOMP], 0.0, CHAN_MAXF);
         rgba[i][GCOMP] = CLAMP(rgba[i][GCOMP], 0.0, CHAN_MAXF);
         rgba[i][BCOMP] = CLAMP(rgba[i][BCOMP], 0.0, CHAN_MAXF);
         rgba[i][ACOMP] = CLAMP(rgba[i][ACOMP], 0.0, CHAN_MAXF);
      }
a1594 1
#endif
d1596 64
a1659 38
   if (swrast->_RasterMask & MULTI_DRAW_BIT) {
      /* need to do blend/logicop separately for each color buffer */
      multi_write_rgba_span(ctx, span);
   }
   else {
      /* normal: write to exactly one buffer */
      struct gl_renderbuffer *rb = ctx->DrawBuffer->_ColorDrawBuffers[0][0];

      if (ctx->Color._LogicOpEnabled) {
         _swrast_logicop_rgba_span(ctx, rb, span, span->array->rgba);
      }
      else if (ctx->Color.BlendEnabled) {
         _swrast_blend_span(ctx, rb, span, span->array->rgba);
      }

      /* Color component masking */
      if (colorMask != 0xffffffff) {
         _swrast_mask_rgba_span(ctx, rb, span, span->array->rgba);
      }

      /* Finally, write the pixels to a color buffer */
      if (span->arrayMask & SPAN_XY) {
         /* array of pixel coords */
         ASSERT(rb->PutValues);
         ASSERT(rb->_BaseFormat == GL_RGB || rb->_BaseFormat == GL_RGBA);
         /* XXX check datatype */
         rb->PutValues(ctx, rb, span->end, span->array->x, span->array->y,
                       span->array->rgba, span->array->mask);
      }
      else {
         /* horizontal run of pixels */
         ASSERT(rb->PutRow);
         ASSERT(rb->_BaseFormat == GL_RGB || rb->_BaseFormat == GL_RGBA);
         /* XXX check datatype */
         rb->PutRow(ctx, rb, span->end, span->x, span->y, span->array->rgba,
                    span->writeAll ? NULL : span->array->mask);
      }
   }
d1661 2
d1665 1
a1668 1

d1670 1
a1670 1
 * Read RGBA pixels from frame buffer.  Clipping will be done to prevent
d1672 2
d1677 2
a1678 1
                        GLuint n, GLint x, GLint y, GLchan rgba[][4] )
d1720 12
a1731 2
      ASSERT(rb->DataType == CHAN_TYPE);
      rb->GetRow(ctx, rb, length, x + skip, y, rgba + skip);
d1737 1
a1737 1
 * Read CI pixels from frame buffer.  Clipping will be done to prevent
d1808 1
a1808 1
 * \param valueSize is the size in bytes of each value put into the
d1819 2
a1820 1
      if (x[i] >= 0 && y[i] >= 0 && x[i] < rb->Width && y[i] < rb->Height) {
d1845 1
d1854 1
a1854 1
   if (y < 0 || y >= rb->Height)
d1857 1
a1857 1
   if (x + (GLint) count <= 0 || x >= rb->Width)
d1860 1
a1860 1
   if (x + count > rb->Width) {
d1880 1
d1889 1
a1889 1
   if (y < 0 || y >= rb->Height)
d1892 1
a1892 1
   if (x + (GLint) count <= 0 || x >= rb->Width)
d1909 42
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@a37 1
#include "image.h"
d59 1
a59 1
_swrast_span_default_z( GLcontext *ctx, SWspan *span )
d76 1
a76 1
_swrast_span_default_fog( GLcontext *ctx, SWspan *span )
d89 1
a89 1
_swrast_span_default_color( GLcontext *ctx, SWspan *span )
d127 1
a127 1
_swrast_span_default_texcoords( GLcontext *ctx, SWspan *span )
d132 1
a132 1
      if (ctx->FragmentProgram._Enabled || ctx->ATIFragmentShader._Enabled) {
d152 3
a154 5
/**
 * Interpolate primary colors to fill in the span->array->color array.
 */
static INLINE void
interpolate_colors(SWspan *span)
d157 1
d159 1
d162 1
a162 1
          !(span->arrayMask & SPAN_RGBA));
d164 9
a172 35
   switch (span->array->ChanType) {
#if CHAN_BITS != 32
   case GL_UNSIGNED_BYTE:
      {
         GLubyte (*rgba)[4] = span->array->color.sz1.rgba;
         if (span->interpMask & SPAN_FLAT) {
            GLubyte color[4];
            color[RCOMP] = FixedToInt(span->red);
            color[GCOMP] = FixedToInt(span->green);
            color[BCOMP] = FixedToInt(span->blue);
            color[ACOMP] = FixedToInt(span->alpha);
            for (i = 0; i < n; i++) {
               COPY_4UBV(rgba[i], color);
            }
         }
         else {
            GLfixed r = span->red;
            GLfixed g = span->green;
            GLfixed b = span->blue;
            GLfixed a = span->alpha;
            GLint dr = span->redStep;
            GLint dg = span->greenStep;
            GLint db = span->blueStep;
            GLint da = span->alphaStep;
            for (i = 0; i < n; i++) {
               rgba[i][RCOMP] = FixedToChan(r);
               rgba[i][GCOMP] = FixedToChan(g);
               rgba[i][BCOMP] = FixedToChan(b);
               rgba[i][ACOMP] = FixedToChan(a);
               r += dr;
               g += dg;
               b += db;
               a += da;
            }
         }
a173 71
      break;
   case GL_UNSIGNED_SHORT:
      {
         GLushort (*rgba)[4] = span->array->color.sz2.rgba;
         if (span->interpMask & SPAN_FLAT) {
            GLushort color[4];
            color[RCOMP] = FixedToInt(span->red);
            color[GCOMP] = FixedToInt(span->green);
            color[BCOMP] = FixedToInt(span->blue);
            color[ACOMP] = FixedToInt(span->alpha);
            for (i = 0; i < n; i++) {
               COPY_4V(rgba[i], color);
            }
         }
         else {
            GLushort (*rgba)[4] = span->array->color.sz2.rgba;
            GLfixed r, g, b, a;
            GLint dr, dg, db, da;
            r = span->red;
            g = span->green;
            b = span->blue;
            a = span->alpha;
            dr = span->redStep;
            dg = span->greenStep;
            db = span->blueStep;
            da = span->alphaStep;
            for (i = 0; i < n; i++) {
               rgba[i][RCOMP] = FixedToChan(r);
               rgba[i][GCOMP] = FixedToChan(g);
               rgba[i][BCOMP] = FixedToChan(b);
               rgba[i][ACOMP] = FixedToChan(a);
               r += dr;
               g += dg;
               b += db;
               a += da;
            }
         }
      }
      break;
#endif
   case GL_FLOAT:
      {
         GLfloat (*rgba)[4] = span->array->color.sz4.rgba;
         GLfloat r, g, b, a, dr, dg, db, da;
         r = span->red;
         g = span->green;
         b = span->blue;
         a = span->alpha;
         if (span->interpMask & SPAN_FLAT) {
            dr = dg = db = da = 0.0;
         }
         else {
            dr = span->redStep;
            dg = span->greenStep;
            db = span->blueStep;
            da = span->alphaStep;
         }
         for (i = 0; i < n; i++) {
            rgba[i][RCOMP] = r;
            rgba[i][GCOMP] = g;
            rgba[i][BCOMP] = b;
            rgba[i][ACOMP] = a;
            r += dr;
            g += dg;
            b += db;
            a += da;
         }
      }
      break;
   default:
      _mesa_problem(NULL, "bad datatype in interpolate_colors");
d175 11
a185 87
   span->arrayMask |= SPAN_RGBA;
}


/**
 * Interpolate specular/secondary colors.
 */
static INLINE void
interpolate_specular(SWspan *span)
{
   const GLuint n = span->end;
   GLuint i;

   switch (span->array->ChanType) {
#if CHAN_BITS != 32
   case GL_UNSIGNED_BYTE:
      {
         GLubyte (*spec)[4] = span->array->color.sz1.spec;
         if (span->interpMask & SPAN_FLAT) {
            GLubyte color[4];
            color[RCOMP] = FixedToInt(span->specRed);
            color[GCOMP] = FixedToInt(span->specGreen);
            color[BCOMP] = FixedToInt(span->specBlue);
            color[ACOMP] = 0;
            for (i = 0; i < n; i++) {
               COPY_4UBV(spec[i], color);
            }
         }
         else {
            GLfixed r = span->specRed;
            GLfixed g = span->specGreen;
            GLfixed b = span->specBlue;
            GLint dr = span->specRedStep;
            GLint dg = span->specGreenStep;
            GLint db = span->specBlueStep;
            for (i = 0; i < n; i++) {
               spec[i][RCOMP] = CLAMP(FixedToChan(r), 0, 255);
               spec[i][GCOMP] = CLAMP(FixedToChan(g), 0, 255);
               spec[i][BCOMP] = CLAMP(FixedToChan(b), 0, 255);
               spec[i][ACOMP] = 0;
               r += dr;
               g += dg;
               b += db;
            }
         }
      }
      break;
   case GL_UNSIGNED_SHORT:
      {
         GLushort (*spec)[4] = span->array->color.sz2.spec;
         if (span->interpMask & SPAN_FLAT) {
            GLushort color[4];
            color[RCOMP] = FixedToInt(span->specRed);
            color[GCOMP] = FixedToInt(span->specGreen);
            color[BCOMP] = FixedToInt(span->specBlue);
            color[ACOMP] = 0;
            for (i = 0; i < n; i++) {
               COPY_4V(spec[i], color);
            }
         }
         else {
            GLfixed r = FloatToFixed(span->specRed);
            GLfixed g = FloatToFixed(span->specGreen);
            GLfixed b = FloatToFixed(span->specBlue);
            GLint dr = FloatToFixed(span->specRedStep);
            GLint dg = FloatToFixed(span->specGreenStep);
            GLint db = FloatToFixed(span->specBlueStep);
            for (i = 0; i < n; i++) {
               spec[i][RCOMP] = FixedToInt(r);
               spec[i][GCOMP] = FixedToInt(g);
               spec[i][BCOMP] = FixedToInt(b);
               spec[i][ACOMP] = 0;
               r += dr;
               g += dg;
               b += db;
            }
         }
      }
      break;
#endif
   case GL_FLOAT:
      {
         GLfloat (*spec)[4] = span->array->color.sz4.spec;
#if CHAN_BITS <= 16
         GLfloat r = CHAN_TO_FLOAT(FixedToChan(span->specRed));
         GLfloat g = CHAN_TO_FLOAT(FixedToChan(span->specGreen));
         GLfloat b = CHAN_TO_FLOAT(FixedToChan(span->specBlue));
d187 8
a194 3
         GLfloat r = span->specRed;
         GLfloat g = span->specGreen;
         GLfloat b = span->specBlue;
d196 9
a204 24
         GLfloat dr, dg, db;
         if (span->interpMask & SPAN_FLAT) {
            dr = dg = db = 0.0;
         }
         else {
#if CHAN_BITS <= 16
            dr = CHAN_TO_FLOAT(FixedToChan(span->specRedStep));
            dg = CHAN_TO_FLOAT(FixedToChan(span->specGreenStep));
            db = CHAN_TO_FLOAT(FixedToChan(span->specBlueStep));
#else
            dr = span->specRedStep;
            dg = span->specGreenStep;
            db = span->specBlueStep;
#endif
         }
         for (i = 0; i < n; i++) {
            spec[i][RCOMP] = r;
            spec[i][GCOMP] = g;
            spec[i][BCOMP] = b;
            spec[i][ACOMP] = 0.0F;
            r += dr;
            g += dg;
            b += db;
         }
a205 3
      break;
   default:
      _mesa_problem(NULL, "bad datatype in interpolate_specular");
d207 1
a207 1
   span->arrayMask |= SPAN_SPEC;
d212 2
a213 2
static INLINE void
interpolate_indexes(GLcontext *ctx, SWspan *span)
d243 42
d286 2
a287 2
static INLINE void
interpolate_fog(const GLcontext *ctx, SWspan *span)
d307 1
a307 1
_swrast_span_interpolate_z( const GLcontext *ctx, SWspan *span )
d395 1
a395 1
interpolate_texcoords(GLcontext *ctx, SWspan *span)
d413 1
a413 1
                  || ctx->FragmentProgram._Enabled;
d438 1
a438 1
               if (ctx->FragmentProgram._Enabled || ctx->ATIFragmentShader._Enabled ||
d490 1
a490 1
               if (ctx->FragmentProgram._Enabled || ctx->ATIFragmentShader._Enabled ||
d549 1
a549 1
            || ctx->FragmentProgram._Enabled;
d574 1
a574 1
         if (ctx->FragmentProgram._Enabled || ctx->ATIFragmentShader._Enabled ||
d626 1
a626 1
         if (ctx->FragmentProgram._Enabled || ctx->ATIFragmentShader._Enabled ||
d678 2
a679 2
static INLINE void
interpolate_varying(GLcontext *ctx, SWspan *span)
d710 2
a711 2
static INLINE void
stipple_polygon_span( GLcontext *ctx, SWspan *span )
d743 2
a744 2
static INLINE GLuint
clip_span( GLcontext *ctx, SWspan *span )
d812 1
a812 1
_swrast_write_index_span( GLcontext *ctx, SWspan *span)
d815 2
d819 1
d934 11
a944 19
   /*
    * Write to renderbuffers
    */
   {
      struct gl_framebuffer *fb = ctx->DrawBuffer;
      const GLuint output = 0; /* only frag progs can write to other outputs */
      const GLuint numDrawBuffers = fb->_NumColorDrawBuffers[output];
      GLuint indexSave[MAX_WIDTH];
      GLuint buf;

      if (numDrawBuffers > 1) {
         /* save indexes for second, third renderbuffer writes */
         _mesa_memcpy(indexSave, span->array->index,
                      span->end * sizeof(indexSave[0]));
      }

      for (buf = 0; buf < fb->_NumColorDrawBuffers[output]; buf++) {
         struct gl_renderbuffer *rb = fb->_ColorDrawBuffers[output][buf];
         ASSERT(rb->_BaseFormat == GL_COLOR_INDEX);
d947 1
a947 1
            _swrast_logicop_ci_span(ctx, rb, span);
d951 1
a951 1
            _swrast_mask_ci_span(ctx, rb, span);
d953 5
d959 35
a993 20
         if ((span->interpMask & SPAN_INDEX) && span->indexStep == 0) {
            /* all fragments have same color index */
            GLubyte index8;
            GLushort index16;
            GLuint index32;
            void *value;

            if (rb->DataType == GL_UNSIGNED_BYTE) {
               index8 = FixedToInt(span->index);
               value = &index8;
            }
            else if (rb->DataType == GL_UNSIGNED_SHORT) {
               index16 = FixedToInt(span->index);
               value = &index16;
            }
            else {
               ASSERT(rb->DataType == GL_UNSIGNED_INT);
               index32 = FixedToInt(span->index);
               value = &index32;
            }
d995 4
a998 3
            if (span->arrayMask & SPAN_XY) {
               rb->PutMonoValues(ctx, rb, span->end, span->array->x, 
                                 span->array->y, value, span->array->mask);
d1000 6
a1005 3
            else {
               rb->PutMonoRow(ctx, rb, span->end, span->x, span->y,
                              value, span->array->mask);
d1007 1
d1010 3
a1012 23
            /* each fragment is a different color */
            GLubyte index8[MAX_WIDTH];
            GLushort index16[MAX_WIDTH];
            void *values;

            if (rb->DataType == GL_UNSIGNED_BYTE) {
               GLuint k;
               for (k = 0; k < span->end; k++) {
                  index8[k] = (GLubyte) span->array->index[k];
               }
               values = index8;
            }
            else if (rb->DataType == GL_UNSIGNED_SHORT) {
               GLuint k;
               for (k = 0; k < span->end; k++) {
                  index16[k] = (GLushort) span->array->index[k];
               }
               values = index16;
            }
            else {
               ASSERT(rb->DataType == GL_UNSIGNED_INT);
               values = span->array->index;
            }
d1014 2
a1015 7
            if (span->arrayMask & SPAN_XY) {
               rb->PutValues(ctx, rb, span->end,
                             span->array->x, span->array->y,
                             values, span->array->mask);
            }
            else {
               rb->PutRow(ctx, rb, span->end, span->x, span->y,
a1016 1
            }
d1018 3
a1020 5

         if (buf + 1 < numDrawBuffers) {
            /* restore original span values */
            _mesa_memcpy(span->array->index, indexSave,
                         span->end * sizeof(indexSave[0]));
d1022 1
a1022 1
      } /* for buf */
d1034 2
a1035 62
static INLINE void
add_specular(GLcontext *ctx, SWspan *span)
{
   switch (span->array->ChanType) {
   case GL_UNSIGNED_BYTE:
      {
         GLubyte (*rgba)[4] = span->array->color.sz1.rgba;
         GLubyte (*spec)[4] = span->array->color.sz1.spec;
         GLuint i;
         for (i = 0; i < span->end; i++) {
            GLint r = rgba[i][RCOMP] + spec[i][RCOMP];
            GLint g = rgba[i][GCOMP] + spec[i][GCOMP];
            GLint b = rgba[i][BCOMP] + spec[i][BCOMP];
            GLint a = rgba[i][ACOMP] + spec[i][ACOMP];
            rgba[i][RCOMP] = MIN2(r, 255);
            rgba[i][GCOMP] = MIN2(g, 255);
            rgba[i][BCOMP] = MIN2(b, 255);
            rgba[i][ACOMP] = MIN2(a, 255);
         }
      }
      break;
   case GL_UNSIGNED_SHORT:
      {
         GLushort (*rgba)[4] = span->array->color.sz2.rgba;
         GLushort (*spec)[4] = span->array->color.sz2.spec;
         GLuint i;
         for (i = 0; i < span->end; i++) {
            GLint r = rgba[i][RCOMP] + spec[i][RCOMP];
            GLint g = rgba[i][GCOMP] + spec[i][GCOMP];
            GLint b = rgba[i][BCOMP] + spec[i][BCOMP];
            GLint a = rgba[i][ACOMP] + spec[i][ACOMP];
            rgba[i][RCOMP] = MIN2(r, 65535);
            rgba[i][GCOMP] = MIN2(g, 65535);
            rgba[i][BCOMP] = MIN2(b, 65535);
            rgba[i][ACOMP] = MIN2(a, 65535);
         }
      }
      break;
   case GL_FLOAT:
      {
         GLfloat (*rgba)[4] = span->array->color.sz4.rgba;
         GLfloat (*spec)[4] = span->array->color.sz4.spec;
         GLuint i;
         for (i = 0; i < span->end; i++) {
            rgba[i][RCOMP] += spec[i][RCOMP];
            rgba[i][GCOMP] += spec[i][GCOMP];
            rgba[i][BCOMP] += spec[i][BCOMP];
            rgba[i][ACOMP] += spec[i][ACOMP];
         }
      }
      break;
   default:
      _mesa_problem(ctx, "Invalid datatype in add_specular");
   }
}


/**
 * Apply antialiasing coverage value to alpha values.
 */
static INLINE void
apply_aa_coverage(SWspan *span)
a1036 1
   const GLfloat *coverage = span->array->coverage;
d1038 14
a1051 21
   if (span->array->ChanType == GL_UNSIGNED_BYTE) {
      GLubyte (*rgba)[4] = span->array->color.sz1.rgba;
      for (i = 0; i < span->end; i++) {
         const GLfloat a = rgba[i][ACOMP] * coverage[i];
         rgba[i][ACOMP] = (GLubyte) CLAMP(a, 0.0, 255.0);
         ASSERT(coverage[i] >= 0.0);
         ASSERT(coverage[i] <= 1.0);
      }
   }
   else if (span->array->ChanType == GL_UNSIGNED_SHORT) {
      GLushort (*rgba)[4] = span->array->color.sz2.rgba;
      for (i = 0; i < span->end; i++) {
         const GLfloat a = rgba[i][ACOMP] * coverage[i];
         rgba[i][ACOMP] = (GLushort) CLAMP(a, 0.0, 65535.0);
      }
   }
   else {
      GLfloat (*rgba)[4] = span->array->color.sz4.rgba;
      for (i = 0; i < span->end; i++) {
         rgba[i][ACOMP] = rgba[i][ACOMP] * coverage[i];
      }
d1057 5
a1061 1
 * Clamp span's float colors to [0,1]
d1063 2
a1064 2
static INLINE void
clamp_colors(SWspan *span)
d1066 3
a1068 1
   GLfloat (*rgba)[4] = span->array->color.sz4.rgba;
a1069 8
   ASSERT(span->array->ChanType == GL_FLOAT);
   for (i = 0; i < span->end; i++) {
      rgba[i][RCOMP] = CLAMP(rgba[i][RCOMP], 0.0F, 1.0F);
      rgba[i][GCOMP] = CLAMP(rgba[i][GCOMP], 0.0F, 1.0F);
      rgba[i][BCOMP] = CLAMP(rgba[i][BCOMP], 0.0F, 1.0F);
      rgba[i][ACOMP] = CLAMP(rgba[i][ACOMP], 0.0F, 1.0F);
   }
}
d1071 2
d1074 3
a1076 25
/**
 * Convert the span's color arrays to the given type.
 */
static INLINE void
convert_color_type(GLcontext *ctx, SWspan *span, GLenum newType)
{
   GLvoid *src, *dst;
   if (span->array->ChanType == GL_UNSIGNED_BYTE) {
      src = span->array->color.sz1.rgba;
   }
   else if (span->array->ChanType == GL_UNSIGNED_BYTE) {
      src = span->array->color.sz2.rgba;
   }
   else {
      src = span->array->color.sz4.rgba;
   }
   if (newType == GL_UNSIGNED_BYTE) {
      dst = span->array->color.sz1.rgba;
   }
   else if (newType == GL_UNSIGNED_BYTE) {
      dst = span->array->color.sz2.rgba;
   }
   else {
      dst = span->array->color.sz4.rgba;
   }
d1078 2
a1079 3
   _mesa_convert_colors(span->array->ChanType, src,
                        newType, dst,
                        span->end, span->array->mask);
d1081 6
a1086 14
   span->array->ChanType = newType;
}



/**
 * Apply fragment shader, fragment program or normal texturing to span.
 */
static INLINE void
shade_texture_span(GLcontext *ctx, SWspan *span)
{
   /* Now we need the rgba array, fill it in if needed */
   if (span->interpMask & SPAN_RGBA)
      interpolate_colors(span);
d1088 2
a1089 18
   if (ctx->Texture._EnabledCoordUnits && (span->interpMask & SPAN_TEXTURE))
      interpolate_texcoords(ctx, span);

   if (ctx->ShaderObjects._FragmentShaderPresent ||
       ctx->FragmentProgram._Enabled ||
       ctx->ATIFragmentShader._Enabled) {

      /* use float colors if running a fragment program or shader */
      const GLenum oldType = span->array->ChanType;
      const GLenum newType = GL_FLOAT;
      if (oldType != newType) {
         GLvoid *src = (oldType == GL_UNSIGNED_BYTE)
            ? (GLvoid *) span->array->color.sz1.rgba
            : (GLvoid *) span->array->color.sz2.rgba;
         _mesa_convert_colors(oldType, src,
                              newType, span->array->color.sz4.rgba,
                              span->end, span->array->mask);
         span->array->ChanType = newType;
d1092 5
a1096 17
      /* fragment programs/shaders may need specular, fog and Z coords */
      if (span->interpMask & SPAN_SPEC)
         interpolate_specular(span);

      if (span->interpMask & SPAN_FOG)
         interpolate_fog(ctx, span);

      if (span->interpMask & SPAN_Z)
         _swrast_span_interpolate_z (ctx, span);

      /* Run fragment program/shader now */
      if (ctx->ShaderObjects._FragmentShaderPresent) {
         interpolate_varying(ctx, span);
         _swrast_exec_arbshader(ctx, span);
      }
      else if (ctx->FragmentProgram._Enabled) {
         _swrast_exec_fragment_program(ctx, span);
d1099 4
a1102 2
         ASSERT(ctx->ATIFragmentShader._Enabled);
         _swrast_exec_fragment_shader(ctx, span);
a1104 4
   else if (ctx->Texture._EnabledUnits && (span->arrayMask & SPAN_TEXTURE)) {
      /* conventional texturing */
      _swrast_texture_span(ctx, span);
   }
a1107 1

d1116 1
a1116 1
_swrast_write_rgba_span( GLcontext *ctx, SWspan *span)
a1117 1
   const SWcontext *swrast = SWRAST_CONTEXT(ctx);
d1119 1
d1122 8
a1129 7
   const GLenum chanType = span->array->ChanType;
   const GLboolean shader
      = ctx->FragmentProgram._Enabled
      || ctx->ShaderObjects._FragmentShaderPresent
      || ctx->ATIFragmentShader._Enabled;
   const GLboolean shaderOrTexture = shader || ctx->Texture._EnabledUnits;
   GLboolean deferredTexture;
a1135 39
   ASSERT(span->primitive == GL_POINT ||
          span->primitive == GL_LINE ||
	  span->primitive == GL_POLYGON ||
          span->primitive == GL_BITMAP);
   ASSERT(span->end <= MAX_WIDTH);
   ASSERT((span->interpMask & span->arrayMask) == 0);
   ASSERT((span->interpMask & SPAN_RGBA) ^ (span->arrayMask & SPAN_RGBA));

   /* check for conditions that prevent deferred shading */
   if (ctx->Color.AlphaEnabled) {
      /* alpha test depends on post-texture/shader colors */
      deferredTexture = GL_FALSE;
   }
   else if (shaderOrTexture) {
      if (ctx->FragmentProgram._Enabled) {
         if (ctx->FragmentProgram.Current->Base.OutputsWritten
             & (1 << FRAG_RESULT_DEPR)) {
            /* Z comes from fragment program */
            deferredTexture = GL_FALSE;
         }
         else {
            deferredTexture = GL_TRUE;
         }
      }
      else if (ctx->ShaderObjects._FragmentShaderPresent) {
         /* XXX how do we test if Z is written by shader? */
         deferredTexture = GL_FALSE; /* never defer to be safe */
      }
      else {
         /* ATI frag shader or conventional texturing */
         deferredTexture = GL_TRUE;
      }
   }
   else {
      /* no texturing or shadering */
      deferredTexture = GL_FALSE;
   }

   /* Fragment write masks */
d1172 11
d1188 10
a1197 3
   if (shaderOrTexture && !deferredTexture) {
      shade_texture_span(ctx, span);
   }
d1199 26
a1224 4
   /* Do the alpha test */
   if (ctx->Color.AlphaEnabled) {
      if (!_swrast_alpha_test(ctx, span)) {
         goto end;
d1236 3
a1238 1
            goto end;
d1246 3
a1248 1
            goto end;
d1267 3
a1269 1
      goto end;
d1277 9
a1285 3
      ASSERT(shaderOrTexture);
      shade_texture_span(ctx, span);
   }
d1287 14
a1300 2
   if ((span->arrayMask & SPAN_RGBA) == 0) {
      interpolate_colors(span);
d1305 1
a1305 1
   if (!shader) {
d1311 1
a1311 1
            interpolate_specular(span);
d1314 1
a1314 1
            add_specular(ctx, span);
d1331 6
a1336 1
      apply_aa_coverage(span);
d1340 10
a1349 3
   if (ctx->Color.ClampFragmentColor == GL_TRUE &&
       span->array->ChanType == GL_FLOAT) {
      clamp_colors(span);
d1351 1
d1353 7
a1359 9
   /*
    * Write to renderbuffers
    */
   {
      struct gl_framebuffer *fb = ctx->DrawBuffer;
      const GLuint output = 0; /* only frag progs can write to other outputs */
      const GLuint numDrawBuffers = fb->_NumColorDrawBuffers[output];
      GLchan rgbaSave[MAX_WIDTH][4];
      GLuint buf;
d1361 5
a1365 6
      if (numDrawBuffers > 0) {
         if (fb->_ColorDrawBuffers[output][0]->DataType
             != span->array->ChanType) {
            convert_color_type(ctx, span,
                               fb->_ColorDrawBuffers[output][0]->DataType);
         }
d1368 3
a1370 4
      if (numDrawBuffers > 1) {
         /* save colors for second, third renderbuffer writes */
         _mesa_memcpy(rgbaSave, span->array->rgba,
                      4 * span->end * sizeof(GLchan));
d1373 17
a1389 36
      for (buf = 0; buf < numDrawBuffers; buf++) {
         struct gl_renderbuffer *rb = fb->_ColorDrawBuffers[output][buf];
         ASSERT(rb->_BaseFormat == GL_RGBA || rb->_BaseFormat == GL_RGB);

         if (ctx->Color._LogicOpEnabled) {
            _swrast_logicop_rgba_span(ctx, rb, span);
         }
         else if (ctx->Color.BlendEnabled) {
            _swrast_blend_span(ctx, rb, span);
         }

         if (colorMask != 0xffffffff) {
            _swrast_mask_rgba_span(ctx, rb, span);
         }

         if (span->arrayMask & SPAN_XY) {
            /* array of pixel coords */
            ASSERT(rb->PutValues);
            rb->PutValues(ctx, rb, span->end,
                          span->array->x, span->array->y,
                          span->array->rgba, span->array->mask);
         }
         else {
            /* horizontal run of pixels */
            ASSERT(rb->PutRow);
            rb->PutRow(ctx, rb, span->end, span->x, span->y, span->array->rgba,
                       span->writeAll ? NULL: span->array->mask);
         }

         if (buf + 1 < numDrawBuffers) {
            /* restore original span values */
            _mesa_memcpy(span->array->rgba, rgbaSave,
                         4 * span->end * sizeof(GLchan));
         }
      } /* for buf */

a1391 2
end:
   /* restore these values before returning */
a1393 1
   span->array->ChanType = chanType;
d1397 1
a1400 2
 * \param type  datatype for returned colors
 * \param rgba  the returned colors
d1404 1
a1404 2
                        GLuint n, GLint x, GLint y, GLenum dstType,
                        GLvoid *rgba)
d1446 2
a1447 12

      if (rb->DataType == dstType) {
         rb->GetRow(ctx, rb, length, x + skip, y,
                    (GLubyte *) rgba + skip * RGBA_PIXEL_SIZE(rb->DataType));
      }
      else {
         GLuint temp[MAX_WIDTH * 4];
         rb->GetRow(ctx, rb, length, x + skip, y, temp);
         _mesa_convert_colors(rb->DataType, temp,
                   dstType, (GLubyte *) rgba + skip * RGBA_PIXEL_SIZE(dstType),
                   length, NULL);
      }
d1524 1
a1524 1
 * \param valueSize is the size in bytes of each value (pixel) put into the
a1559 1
 * \param valueSize  size of each value (pixel) in bytes
a1593 1
 * \param valueSize  size of each value (pixel) in bytes
a1621 42
}


/**
 * Get RGBA pixels from the given renderbuffer.  Put the pixel colors into
 * the span's specular color arrays.  The specular color arrays should no
 * longer be needed by time this function is called.
 * Used by blending, logicop and masking functions.
 * \return pointer to the colors we read.
 */
void *
_swrast_get_dest_rgba(GLcontext *ctx, struct gl_renderbuffer *rb,
                      SWspan *span)
{
   const GLuint pixelSize = RGBA_PIXEL_SIZE(span->array->ChanType);
   void *rbPixels;

   /*
    * Determine pixel size (in bytes).
    * Point rbPixels to a temporary space (use specular color arrays).
    */
   if (span->array->ChanType == GL_UNSIGNED_BYTE) {
      rbPixels = span->array->color.sz1.spec;
   }
   else if (span->array->ChanType == GL_UNSIGNED_SHORT) {
      rbPixels = span->array->color.sz2.spec;
   }
   else {
      rbPixels = span->array->color.sz4.spec;
   }

   /* Get destination values from renderbuffer */
   if (span->arrayMask & SPAN_XY) {
      _swrast_get_values(ctx, rb, span->end, span->array->x, span->array->y,
                         rbPixels, pixelSize);
   }
   else {
      _swrast_get_row(ctx, rb, span->end, span->x, span->y,
                      rbPixels, pixelSize);
   }

   return rbPixels;
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d3 1
a3 1
 * Version:  6.5.3
d5 1
a5 1
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
d42 1
d49 1
a49 1
#include "s_fragprog.h"
d73 1
a73 1
 * Init span's fogcoord interpolation values to the RasterPos fog.
d79 2
a80 13
   const SWcontext *swrast = SWRAST_CONTEXT(ctx);
   GLfloat fogVal; /* a coord or a blend factor */
   if (swrast->_PreferPixelFog) {
      /* fog blend factors will be computed from fog coordinates per pixel */
      fogVal = ctx->Current.RasterDistance;
   }
   else {
      /* fog blend factor should be computed from fogcoord now */
      fogVal = _swrast_z_to_fogfactor(ctx, ctx->Current.RasterDistance);
   }
   span->attrStart[FRAG_ATTRIB_FOGC][0] = fogVal;
   span->attrStepX[FRAG_ATTRIB_FOGC][0] = 0.0;
   span->attrStepY[FRAG_ATTRIB_FOGC][0] = 0.0;
a123 34
 * Set the span's secondary color info to the current raster position's
 * secondary color, when needed (lighting enabled or colorsum enabled).
 */
void
_swrast_span_default_secondary_color(GLcontext *ctx, SWspan *span)
{
   if (ctx->Visual.rgbMode && (ctx->Light.Enabled || ctx->Fog.ColorSumEnabled))
   {
      GLchan r, g, b, a;
      UNCLAMPED_FLOAT_TO_CHAN(r, ctx->Current.RasterSecondaryColor[0]);
      UNCLAMPED_FLOAT_TO_CHAN(g, ctx->Current.RasterSecondaryColor[1]);
      UNCLAMPED_FLOAT_TO_CHAN(b, ctx->Current.RasterSecondaryColor[2]);
      UNCLAMPED_FLOAT_TO_CHAN(a, ctx->Current.RasterSecondaryColor[3]);
#if CHAN_TYPE == GL_FLOAT
      span->specRed = r;
      span->specGreen = g;
      span->specBlue = b;
      /*span->specAlpha = a;*/
#else
      span->specRed   = IntToFixed(r);
      span->specGreen = IntToFixed(g);
      span->specBlue  = IntToFixed(b);
      /*span->specAlpha = IntToFixed(a);*/
#endif
      span->specRedStep = 0;
      span->specGreenStep = 0;
      span->specBlueStep = 0;
      /*span->specAlphaStep = 0;*/
      span->interpMask |= SPAN_SPEC;
   }
}


/**
a131 1
      const GLuint attr = FRAG_ATTRIB_TEX0 + i;
d133 2
a134 2
      if (ctx->FragmentProgram._Current || ctx->ATIFragmentShader._Enabled) {
         COPY_4V(span->attrStart[attr], tc);
d138 4
a141 4
         span->attrStart[attr][0] = tc[0] / tc[3];
         span->attrStart[attr][1] = tc[1] / tc[3];
         span->attrStart[attr][2] = tc[2] / tc[3];
         span->attrStart[attr][3] = 1.0;
d144 1
a144 1
         ASSIGN_4V(span->attrStart[attr], 0.0F, 0.0F, 0.0F, 1.0F);
d146 2
a147 2
      ASSIGN_4V(span->attrStepX[attr], 0.0F, 0.0F, 0.0F, 0.0F);
      ASSIGN_4V(span->attrStepY[attr], 0.0F, 0.0F, 0.0F, 0.0F);
d243 1
a243 1
         GLfloat (*rgba)[4] = span->array->attribs[FRAG_ATTRIB_COL0];
d355 1
a355 1
         GLfloat (*spec)[4] = span->array->attribs[FRAG_ATTRIB_COL1];
d434 3
a436 3
   GLfloat (*fog)[4] = span->array->attribs[FRAG_ATTRIB_FOGC];
   const GLfloat fogStep = span->attrStepX[FRAG_ATTRIB_FOGC][0];
   GLfloat fogCoord = span->attrStart[FRAG_ATTRIB_FOGC][0];
d438 2
a439 2
   const GLfloat wStep = haveW ? span->attrStepX[FRAG_ATTRIB_WPOS][3] : 0.0F;
   GLfloat w = haveW ? span->attrStart[FRAG_ATTRIB_WPOS][3] : 1.0F;
d442 1
a442 1
      fog[i][0] = fogCoord / w;
a541 4
   const GLuint maxUnit
      = (ctx->Texture._EnabledCoordUnits > 1) ? ctx->Const.MaxTextureUnits : 1;
   GLuint u;

d545 58
a602 1
   span->arrayMask |= SPAN_TEXTURE;
a603 56
   /* XXX CoordUnits vs. ImageUnits */
   for (u = 0; u < maxUnit; u++) {
      if (ctx->Texture._EnabledCoordUnits & (1 << u)) {
         const GLuint attr = FRAG_ATTRIB_TEX0 + u;
         const struct gl_texture_object *obj = ctx->Texture.Unit[u]._Current;
         GLfloat texW, texH;
         GLboolean needLambda;
         GLfloat (*texcoord)[4] = span->array->attribs[attr];
         GLfloat *lambda = span->array->lambda[u];
         const GLfloat dsdx = span->attrStepX[attr][0];
         const GLfloat dsdy = span->attrStepY[attr][0];
         const GLfloat dtdx = span->attrStepX[attr][1];
         const GLfloat dtdy = span->attrStepY[attr][1];
         const GLfloat drdx = span->attrStepX[attr][2];
         const GLfloat dqdx = span->attrStepX[attr][3];
         const GLfloat dqdy = span->attrStepY[attr][3];
         GLfloat s = span->attrStart[attr][0];
         GLfloat t = span->attrStart[attr][1];
         GLfloat r = span->attrStart[attr][2];
         GLfloat q = span->attrStart[attr][3];

         if (obj) {
            const struct gl_texture_image *img = obj->Image[0][obj->BaseLevel];
            needLambda = (obj->MinFilter != obj->MagFilter)
               || ctx->FragmentProgram._Current;
            texW = img->WidthScale;
            texH = img->HeightScale;
         }
         else {
            /* using a fragment program */
            texW = 1.0;
            texH = 1.0;
            needLambda = GL_FALSE;
         }

         if (needLambda) {
            GLuint i;
            if (ctx->FragmentProgram._Current
                || ctx->ATIFragmentShader._Enabled) {
               /* do perspective correction but don't divide s, t, r by q */
               const GLfloat dwdx = span->attrStepX[FRAG_ATTRIB_WPOS][3];
               GLfloat w = span->attrStart[FRAG_ATTRIB_WPOS][3];
               for (i = 0; i < span->end; i++) {
                  const GLfloat invW = 1.0F / w;
                  texcoord[i][0] = s * invW;
                  texcoord[i][1] = t * invW;
                  texcoord[i][2] = r * invW;
                  texcoord[i][3] = q * invW;
                  lambda[i] = _swrast_compute_lambda(dsdx, dsdy, dtdx, dtdy,
                                                     dqdx, dqdy, texW, texH,
                                                     s, t, q, invW);
                  s += dsdx;
                  t += dtdx;
                  r += drdx;
                  q += dqdx;
                  w += dwdx;
d605 17
d624 32
a655 1
               for (i = 0; i < span->end; i++) {
d657 24
a680 11
                  texcoord[i][0] = s * invQ;
                  texcoord[i][1] = t * invQ;
                  texcoord[i][2] = r * invQ;
                  texcoord[i][3] = q;
                  lambda[i] = _swrast_compute_lambda(dsdx, dsdy, dtdx, dtdy,
                                                     dqdx, dqdy, texW, texH,
                                                     s, t, q, invQ);
                  s += dsdx;
                  t += dtdx;
                  r += drdx;
                  q += dqdx;
d682 56
a738 1
            span->arrayMask |= SPAN_LAMBDA;
d741 59
a799 19
            GLuint i;
            if (ctx->FragmentProgram._Current ||
                ctx->ATIFragmentShader._Enabled) {
               /* do perspective correction but don't divide s, t, r by q */
               const GLfloat dwdx = span->attrStepX[FRAG_ATTRIB_WPOS][3];
               GLfloat w = span->attrStart[FRAG_ATTRIB_WPOS][3];
               for (i = 0; i < span->end; i++) {
                  const GLfloat invW = 1.0F / w;
                  texcoord[i][0] = s * invW;
                  texcoord[i][1] = t * invW;
                  texcoord[i][2] = r * invW;
                  texcoord[i][3] = q * invW;
                  lambda[i] = 0.0;
                  s += dsdx;
                  t += dtdx;
                  r += drdx;
                  q += dqdx;
                  w += dwdx;
               }
d801 3
a803 2
            else if (dqdx == 0.0F) {
               /* Ortho projection or polygon's parallel to window X axis */
d805 8
a812 10
               for (i = 0; i < span->end; i++) {
                  texcoord[i][0] = s * invQ;
                  texcoord[i][1] = t * invQ;
                  texcoord[i][2] = r * invQ;
                  texcoord[i][3] = q;
                  lambda[i] = 0.0;
                  s += dsdx;
                  t += dtdx;
                  r += drdx;
               }
d814 3
a816 17
            else {
               for (i = 0; i < span->end; i++) {
                  const GLfloat invQ = (q == 0.0F) ? 1.0F : (1.0F / q);
                  texcoord[i][0] = s * invQ;
                  texcoord[i][1] = t * invQ;
                  texcoord[i][2] = r * invQ;
                  texcoord[i][3] = q;
                  lambda[i] = 0.0;
                  s += dsdx;
                  t += dtdx;
                  r += drdx;
                  q += dqdx;
               }
            }
         } /* lambda */
      } /* if */
   } /* for */
a819 1

d821 1
a821 4
 * Fill in the arrays->attribs[FRAG_ATTRIB_VARx] arrays from the
 * interpolation values.
 * XXX since interpolants/arrays are getting uniformed, we might merge
 * this with interpolate_texcoords(), interpolate_Fog(), etc. someday.
d826 1
a826 2
   GLuint var;
   const GLbitfield inputsUsed = ctx->FragmentProgram._Current->Base.InputsRead;
d833 6
a838 13
   for (var = 0; var < MAX_VARYING; var++) {
      if (inputsUsed & FRAG_BIT_VAR(var)) {
         const GLuint attr = FRAG_ATTRIB_VAR0 + var;
         const GLfloat dwdx = span->attrStepX[FRAG_ATTRIB_WPOS][3];
         GLfloat w = span->attrStart[FRAG_ATTRIB_WPOS][3];
         const GLfloat dv0dx = span->attrStepX[attr][0];
         const GLfloat dv1dx = span->attrStepX[attr][1];
         const GLfloat dv2dx = span->attrStepX[attr][2];
         const GLfloat dv3dx = span->attrStepX[attr][3];
         GLfloat v0 = span->attrStart[attr][0];
         GLfloat v1 = span->attrStart[attr][1];
         GLfloat v2 = span->attrStart[attr][2];
         GLfloat v3 = span->attrStart[attr][3];
d840 1
d843 2
a844 8
            span->array->attribs[attr][k][0] = v0 * invW;
            span->array->attribs[attr][k][1] = v1 * invW;
            span->array->attribs[attr][k][2] = v2 * invW;
            span->array->attribs[attr][k][3] = v3 * invW;
            v0 += dv0dx;
            v1 += dv1dx;
            v2 += dv2dx;
            v3 += dv3dx;
a852 34
 * Fill in the arrays->attribs[FRAG_ATTRIB_WPOS] array.
 */
static INLINE void
interpolate_wpos(GLcontext *ctx, SWspan *span)
{
   GLfloat (*wpos)[4] = span->array->attribs[FRAG_ATTRIB_WPOS];
   GLuint i;
   const GLfloat zScale = 1.0 / ctx->DrawBuffer->_DepthMaxF;
   GLfloat w, dw;

   if (span->arrayMask & SPAN_XY) {
      for (i = 0; i < span->end; i++) {
         wpos[i][0] = (GLfloat) span->array->x[i];
         wpos[i][1] = (GLfloat) span->array->y[i];
      }
   }
   else {
      for (i = 0; i < span->end; i++) {
         wpos[i][0] = (GLfloat) span->x + i;
         wpos[i][1] = (GLfloat) span->y;
      }
   }

   w = span->attrStart[FRAG_ATTRIB_WPOS][3];
   dw = span->attrStepX[FRAG_ATTRIB_WPOS][3];
   for (i = 0; i < span->end; i++) {
      wpos[i][2] = (GLfloat) span->array->z[i] * zScale;
      wpos[i][3] = w;
      w += dw;
   }
}


/**
d856 1
a856 1
stipple_polygon_span(GLcontext *ctx, SWspan *span)
d858 2
d861 1
d864 1
d866 5
a870 10
   if (span->arrayMask & SPAN_XY) {
      /* arrays of x/y pixel coords */
      GLuint i;
      for (i = 0; i < span->end; i++) {
         const GLint col = span->array->x[i] % 32;
         const GLint row = span->array->y[i] % 32;
         const GLuint stipple = ctx->PolygonStipple[row];
         if (((1 << col) & stipple) == 0) {
            mask[i] = 0;
         }
d872 3
a874 14
   }
   else {
      /* horizontal span of pixels */
      const GLuint highBit = 1 << 31;
      const GLuint stipple = ctx->PolygonStipple[span->y % 32];
      GLuint i, m = highBit >> (GLuint) (span->x % 32);
      for (i = 0; i < span->end; i++) {
         if ((m & stipple) == 0) {
            mask[i] = 0;
         }
         m = m >> 1;
         if (m == 0) {
            m = highBit;
         }
d1227 2
a1228 2
         GLfloat (*rgba)[4] = span->array->attribs[FRAG_ATTRIB_COL0];
         GLfloat (*spec)[4] = span->array->attribs[FRAG_ATTRIB_COL1];
d1269 1
a1269 1
      GLfloat (*rgba)[4] = span->array->attribs[FRAG_ATTRIB_COL0];
d1283 1
a1283 1
   GLfloat (*rgba)[4] = span->array->attribs[FRAG_ATTRIB_COL0];
a1296 3
 * The only way 'output' can be greater than one is when we have a fragment
 * program that writes to gl_FragData[1] or higher.
 * \param output  which fragment program color output is being processed
d1299 1
a1299 1
convert_color_type(SWspan *span, GLenum newType, GLuint output)
d1302 2
a1303 4

   if (output > 0 || span->array->ChanType == GL_FLOAT) {
      src = span->array->attribs[FRAG_ATTRIB_COL0 + output];
      span->array->ChanType = GL_FLOAT;
d1306 1
a1306 1
      src = span->array->color.sz1.rgba;
d1309 1
a1309 2
      ASSERT(span->array->ChanType == GL_UNSIGNED_SHORT);
      src = span->array->color.sz2.rgba;
a1310 1

d1314 1
a1314 1
   else if (newType == GL_UNSIGNED_SHORT) {
d1318 1
a1318 1
      dst = span->array->attribs[FRAG_ATTRIB_COL0];
d1336 2
a1337 12
   GLbitfield inputsRead;

   /* Determine which fragment attributes are actually needed */
   if (ctx->FragmentProgram._Current) {
      inputsRead = ctx->FragmentProgram._Current->Base.InputsRead;
   }
   else {
      /* XXX we could be a bit smarter about this */
      inputsRead = ~0;
   }

   if ((inputsRead & FRAG_BIT_COL0) && (span->interpMask & SPAN_RGBA))
d1343 2
a1344 1
   if (ctx->FragmentProgram._Current ||
d1346 1
d1350 1
a1350 2

      if ((inputsRead & FRAG_BIT_COL0) && (oldType != newType)) {
a1353 1
         assert(span->arrayMask & SPAN_RGBA);
d1355 1
a1355 1
                              newType, span->array->attribs[FRAG_ATTRIB_COL0],
d1357 1
a1358 1
      span->array->ChanType = newType;
d1361 1
a1361 1
      if ((inputsRead & FRAG_BIT_COL1) && (span->interpMask & SPAN_SPEC))
d1364 1
a1364 1
      if ((inputsRead & FRAG_BIT_FOGC) && (span->interpMask & SPAN_FOG))
d1370 2
a1371 1
      if ((inputsRead >= FRAG_BIT_VAR0) && (span->interpMask & SPAN_VARYING))
d1373 3
a1375 10

#if 0
      if (inputsRead & FRAG_BIT_WPOS)
#else
      /* XXX always interpolate wpos so that DDX/DDY work */
#endif
         interpolate_wpos(ctx, span);

      /* Run fragment program/shader now */
      if (ctx->FragmentProgram._Current) {
d1406 4
a1409 2
   const GLboolean shader = (ctx->FragmentProgram._Current
                             || ctx->ATIFragmentShader._Enabled);
a1410 2
   struct gl_framebuffer *fb = ctx->DrawBuffer;
   GLuint output;
d1426 1
a1426 4
   /* check for conditions that prevent deferred shading (doing shading
    * after stencil/ztest).
    * XXX move this code into state validation.
    */
d1432 2
a1433 2
      if (ctx->FragmentProgram._Current) {
         if (ctx->FragmentProgram._Current->Base.OutputsWritten
d1435 1
a1435 5
            /* Z comes from fragment program/shader */
            deferredTexture = GL_FALSE;
         }
         else if (ctx->Query.CurrentOcclusionObject) {
            /* occlusion query depends on shader discard/kill results */
d1442 4
d1479 4
a1482 4
            assert(span->array->x[i] >= fb->_Xmin);
            assert(span->array->x[i] < fb->_Xmax);
            assert(span->array->y[i] >= fb->_Ymin);
            assert(span->array->y[i] < fb->_Ymax);
d1514 1
a1514 1
      if (ctx->Stencil.Enabled && fb->Visual.stencilBits > 0) {
d1520 1
a1520 1
      else if (fb->Visual.depthBits > 0) {
d1600 58
a1657 61
   /* Loop over color outputs (GL_ARB_draw_buffers) written by frag prog */
   for (output = 0; output < swrast->_NumColorOutputs; output++) {
      if (swrast->_ColorOutputsMask & (1 << output)) {
        const GLuint numDrawBuffers = fb->_NumColorDrawBuffers[output];
        GLchan rgbaSave[MAX_WIDTH][4];
        GLuint buf;

        ASSERT(numDrawBuffers > 0);

        if (fb->_ColorDrawBuffers[output][0]->DataType
            != span->array->ChanType || output > 0) {
           convert_color_type(span,
                              fb->_ColorDrawBuffers[output][0]->DataType,
                              output);
        }

        if (numDrawBuffers > 1) {
           /* save colors for second, third renderbuffer writes */
           _mesa_memcpy(rgbaSave, span->array->rgba,
                        4 * span->end * sizeof(GLchan));
        }

        /* Loop over renderbuffers (i.e. GL_FRONT_AND_BACK) */
        for (buf = 0; buf < numDrawBuffers; buf++) {
           struct gl_renderbuffer *rb = fb->_ColorDrawBuffers[output][buf];
           ASSERT(rb->_BaseFormat == GL_RGBA || rb->_BaseFormat == GL_RGB);

           if (ctx->Color._LogicOpEnabled) {
              _swrast_logicop_rgba_span(ctx, rb, span);
           }
           else if (ctx->Color.BlendEnabled) {
              _swrast_blend_span(ctx, rb, span);
           }

           if (colorMask != 0xffffffff) {
              _swrast_mask_rgba_span(ctx, rb, span);
           }

           if (span->arrayMask & SPAN_XY) {
              /* array of pixel coords */
              ASSERT(rb->PutValues);
              rb->PutValues(ctx, rb, span->end,
                            span->array->x, span->array->y,
                            span->array->rgba, span->array->mask);
           }
           else {
              /* horizontal run of pixels */
              ASSERT(rb->PutRow);
              rb->PutRow(ctx, rb, span->end, span->x, span->y,
                         span->array->rgba,
                         span->writeAll ? NULL: span->array->mask);
           }

           if (buf + 1 < numDrawBuffers) {
              /* restore original span values */
              _mesa_memcpy(span->array->rgba, rgbaSave,
                           4 * span->end * sizeof(GLchan));
           }
        } /* for buf */
      } /* if output is written to */
   } /* for output */
d1668 1
a1668 1
 * Read RGBA pixels from a renderbuffer.  Clipping will be done to prevent
d1670 1
a1670 1
 * \param dstType  datatype for returned colors
d1735 1
a1735 1
 * Read CI pixels from a renderbuffer.  Clipping will be done to prevent
d1817 1
a1817 2
      if (x[i] >= 0 && y[i] >= 0 &&
	  x[i] < (GLint) rb->Width && y[i] < (GLint) rb->Height) {
d1851 1
a1851 1
   if (y < 0 || y >= (GLint) rb->Height)
d1854 1
a1854 1
   if (x + (GLint) count <= 0 || x >= (GLint) rb->Width)
d1857 1
a1857 1
   if ((GLint) (x + count) > (GLint) rb->Width) {
d1886 1
a1886 1
   if (y < 0 || y >= (GLint) rb->Height)
d1889 1
a1889 1
   if (x + (GLint) count <= 0 || x >= (GLint) rb->Width)
d1934 1
a1934 1
      rbPixels = span->array->attribs[FRAG_ATTRIB_COL1];
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d3 1
a3 1
 * Version:  7.5
d5 1
a5 2
 * Copyright (C) 1999-2008  Brian Paul   All Rights Reserved.
 * Copyright (C) 2009  VMware, Inc.  All Rights Reserved.
d33 6
a38 5
#include "main/glheader.h"
#include "main/colormac.h"
#include "main/macros.h"
#include "main/imports.h"
#include "main/image.h"
d55 2
a56 3
 * Set default fragment attributes for the span using the
 * current raster values.  Used prior to glDraw/CopyPixels
 * and glBitmap.
d59 1
a59 1
_swrast_span_default_attribs(struct gl_context *ctx, SWspan *span)
d61 47
a107 25
   GLchan r, g, b, a;
   /* Z*/
   {
      const GLfloat depthMax = ctx->DrawBuffer->_DepthMaxF;
      if (ctx->DrawBuffer->Visual.depthBits <= 16)
         span->z = FloatToFixed(ctx->Current.RasterPos[2] * depthMax + 0.5F);
      else {
         GLfloat tmpf = ctx->Current.RasterPos[2] * depthMax; 
         tmpf = MIN2(tmpf, depthMax);
         span->z = (GLint)tmpf;
      }
      span->zStep = 0;
      span->interpMask |= SPAN_Z;
   }

   /* W (for perspective correction) */
   span->attrStart[FRAG_ATTRIB_WPOS][3] = 1.0;
   span->attrStepX[FRAG_ATTRIB_WPOS][3] = 0.0;
   span->attrStepY[FRAG_ATTRIB_WPOS][3] = 0.0;

   /* primary color, or color index */
   UNCLAMPED_FLOAT_TO_CHAN(r, ctx->Current.RasterColor[0]);
   UNCLAMPED_FLOAT_TO_CHAN(g, ctx->Current.RasterColor[1]);
   UNCLAMPED_FLOAT_TO_CHAN(b, ctx->Current.RasterColor[2]);
   UNCLAMPED_FLOAT_TO_CHAN(a, ctx->Current.RasterColor[3]);
d109 4
a112 4
   span->red = r;
   span->green = g;
   span->blue = b;
   span->alpha = a;
d114 4
a117 4
   span->red   = IntToFixed(r);
   span->green = IntToFixed(g);
   span->blue  = IntToFixed(b);
   span->alpha = IntToFixed(a);
d119 10
a128 16
   span->redStep = 0;
   span->greenStep = 0;
   span->blueStep = 0;
   span->alphaStep = 0;
   span->interpMask |= SPAN_RGBA;

   COPY_4V(span->attrStart[FRAG_ATTRIB_COL0], ctx->Current.RasterColor);
   ASSIGN_4V(span->attrStepX[FRAG_ATTRIB_COL0], 0.0, 0.0, 0.0, 0.0);
   ASSIGN_4V(span->attrStepY[FRAG_ATTRIB_COL0], 0.0, 0.0, 0.0, 0.0);

   /* Secondary color */
   if (ctx->Light.Enabled || ctx->Fog.ColorSumEnabled)
   {
      COPY_4V(span->attrStart[FRAG_ATTRIB_COL1], ctx->Current.RasterSecondaryColor);
      ASSIGN_4V(span->attrStepX[FRAG_ATTRIB_COL1], 0.0, 0.0, 0.0, 0.0);
      ASSIGN_4V(span->attrStepY[FRAG_ATTRIB_COL1], 0.0, 0.0, 0.0, 0.0);
d130 1
a131 16
   /* fog */
   {
      const SWcontext *swrast = SWRAST_CONTEXT(ctx);
      GLfloat fogVal; /* a coord or a blend factor */
      if (swrast->_PreferPixelFog) {
         /* fog blend factors will be computed from fog coordinates per pixel */
         fogVal = ctx->Current.RasterDistance;
      }
      else {
         /* fog blend factor should be computed from fogcoord now */
         fogVal = _swrast_z_to_fogfactor(ctx, ctx->Current.RasterDistance);
      }
      span->attrStart[FRAG_ATTRIB_FOGC][0] = fogVal;
      span->attrStepX[FRAG_ATTRIB_FOGC][0] = 0.0;
      span->attrStepY[FRAG_ATTRIB_FOGC][0] = 0.0;
   }
d133 8
a140 1
   /* texcoords */
d142 21
a162 20
      GLuint i;
      for (i = 0; i < ctx->Const.MaxTextureCoordUnits; i++) {
         const GLuint attr = FRAG_ATTRIB_TEX0 + i;
         const GLfloat *tc = ctx->Current.RasterTexCoords[i];
         if (ctx->FragmentProgram._Current || ctx->ATIFragmentShader._Enabled) {
            COPY_4V(span->attrStart[attr], tc);
         }
         else if (tc[3] > 0.0F) {
            /* use (s/q, t/q, r/q, 1) */
            span->attrStart[attr][0] = tc[0] / tc[3];
            span->attrStart[attr][1] = tc[1] / tc[3];
            span->attrStart[attr][2] = tc[2] / tc[3];
            span->attrStart[attr][3] = 1.0;
         }
         else {
            ASSIGN_4V(span->attrStart[attr], 0.0F, 0.0F, 0.0F, 1.0F);
         }
         ASSIGN_4V(span->attrStepX[attr], 0.0F, 0.0F, 0.0F, 0.0F);
         ASSIGN_4V(span->attrStepY[attr], 0.0F, 0.0F, 0.0F, 0.0F);
      }
d168 2
a169 4
 * Interpolate the active attributes (and'd with attrMask) to
 * fill in span->array->attribs[].
 * Perspective correction will be done.  The point/line/triangle function
 * should have computed attrStart/Step values for FRAG_ATTRIB_WPOS[3]!
d171 2
a172 2
static INLINE void
interpolate_active_attribs(struct gl_context *ctx, SWspan *span, GLbitfield attrMask)
d174 16
a189 35
   const SWcontext *swrast = SWRAST_CONTEXT(ctx);

   /*
    * Don't overwrite existing array values, such as colors that may have
    * been produced by glDraw/CopyPixels.
    */
   attrMask &= ~span->arrayAttribs;

   ATTRIB_LOOP_BEGIN
      if (attrMask & (1 << attr)) {
         const GLfloat dwdx = span->attrStepX[FRAG_ATTRIB_WPOS][3];
         GLfloat w = span->attrStart[FRAG_ATTRIB_WPOS][3];
         const GLfloat dv0dx = span->attrStepX[attr][0];
         const GLfloat dv1dx = span->attrStepX[attr][1];
         const GLfloat dv2dx = span->attrStepX[attr][2];
         const GLfloat dv3dx = span->attrStepX[attr][3];
         GLfloat v0 = span->attrStart[attr][0] + span->leftClip * dv0dx;
         GLfloat v1 = span->attrStart[attr][1] + span->leftClip * dv1dx;
         GLfloat v2 = span->attrStart[attr][2] + span->leftClip * dv2dx;
         GLfloat v3 = span->attrStart[attr][3] + span->leftClip * dv3dx;
         GLuint k;
         for (k = 0; k < span->end; k++) {
            const GLfloat invW = 1.0f / w;
            span->array->attribs[attr][k][0] = v0 * invW;
            span->array->attribs[attr][k][1] = v1 * invW;
            span->array->attribs[attr][k][2] = v2 * invW;
            span->array->attribs[attr][k][3] = v3 * invW;
            v0 += dv0dx;
            v1 += dv1dx;
            v2 += dv2dx;
            v3 += dv3dx;
            w += dwdx;
         }
         ASSERT((span->arrayAttribs & (1 << attr)) == 0);
         span->arrayAttribs |= (1 << attr);
d191 4
a194 1
   ATTRIB_LOOP_END
d199 1
a199 2
 * Interpolate primary colors to fill in the span->array->rgba8 (or rgb16)
 * color array.
d202 1
a202 1
interpolate_int_colors(struct gl_context *ctx, SWspan *span)
d207 2
a208 3
#if CHAN_BITS != 32
   ASSERT(!(span->arrayMask & SPAN_RGBA));
#endif
d214 1
a214 1
         GLubyte (*rgba)[4] = span->array->rgba8;
d249 1
a249 1
         GLushort (*rgba)[4] = span->array->rgba16;
d261 1
a261 1
            GLushort (*rgba)[4] = span->array->rgba16;
d287 27
a313 1
      interpolate_active_attribs(ctx, span, FRAG_BIT_COL0);
d316 1
a316 1
      _mesa_problem(NULL, "bad datatype in interpolate_int_colors");
d323 1
a323 1
 * Populate the FRAG_ATTRIB_COL0 array.
d326 1
a326 1
interpolate_float_colors(SWspan *span)
a327 1
   GLfloat (*col0)[4] = span->array->attribs[FRAG_ATTRIB_COL0];
d331 32
a362 9
   assert(!(span->arrayAttribs & FRAG_BIT_COL0));

   if (span->arrayMask & SPAN_RGBA) {
      /* convert array of int colors */
      for (i = 0; i < n; i++) {
         col0[i][0] = UBYTE_TO_FLOAT(span->array->rgba8[i][0]);
         col0[i][1] = UBYTE_TO_FLOAT(span->array->rgba8[i][1]);
         col0[i][2] = UBYTE_TO_FLOAT(span->array->rgba8[i][2]);
         col0[i][3] = UBYTE_TO_FLOAT(span->array->rgba8[i][3]);
d364 30
a393 11
   }
   else {
      /* interpolate red/green/blue/alpha to get float colors */
      ASSERT(span->interpMask & SPAN_RGBA);
      if (span->interpMask & SPAN_FLAT) {
         GLfloat r = FixedToFloat(span->red);
         GLfloat g = FixedToFloat(span->green);
         GLfloat b = FixedToFloat(span->blue);
         GLfloat a = FixedToFloat(span->alpha);
         for (i = 0; i < n; i++) {
            ASSIGN_4V(col0[i], r, g, b, a);
d396 29
a424 9
      else {
         GLfloat r = FixedToFloat(span->red);
         GLfloat g = FixedToFloat(span->green);
         GLfloat b = FixedToFloat(span->blue);
         GLfloat a = FixedToFloat(span->alpha);
         GLfloat dr = FixedToFloat(span->redStep);
         GLfloat dg = FixedToFloat(span->greenStep);
         GLfloat db = FixedToFloat(span->blueStep);
         GLfloat da = FixedToFloat(span->alphaStep);
d426 4
a429 4
            col0[i][0] = r;
            col0[i][1] = g;
            col0[i][2] = b;
            col0[i][3] = a;
a432 1
            a += da;
d435 3
d439 2
d442 30
a471 2
   span->arrayAttribs |= FRAG_BIT_COL0;
   span->array->ChanType = GL_FLOAT;
d475 19
d495 1
a495 3
/**
 * Fill in the span.zArray array from the span->z, zStep values.
 */
d497 1
a497 1
_swrast_span_interpolate_z( const struct gl_context *ctx, SWspan *span )
d502 2
a503 1
   ASSERT(!(span->arrayMask & SPAN_Z));
d527 1
a527 2
/**
 * Compute mipmap LOD from partial derivatives.
d530 5
a534 4
GLfloat
_swrast_compute_lambda(GLfloat dsdx, GLfloat dsdy, GLfloat dtdx, GLfloat dtdy,
                       GLfloat dqdx, GLfloat dqdy, GLfloat texW, GLfloat texH,
                       GLfloat s, GLfloat t, GLfloat q, GLfloat invQ)
d546 1
d549 2
a550 3
/**
 * Compute mipmap LOD from partial derivatives.
 * This is a faster approximation than above function.
a551 1
#if 0
a571 1
#endif
d575 1
a575 5
 * Fill in the span.array->attrib[FRAG_ATTRIB_TEXn] arrays from the
 * using the attrStart/Step values.
 *
 * This function only used during fixed-function fragment processing.
 *
d580 3
d585 1
a585 1
interpolate_texcoords(struct gl_context *ctx, SWspan *span)
d591 5
d612 4
a615 4
         GLfloat s = span->attrStart[attr][0] + span->leftClip * dsdx;
         GLfloat t = span->attrStart[attr][1] + span->leftClip * dtdx;
         GLfloat r = span->attrStart[attr][2] + span->leftClip * drdx;
         GLfloat q = span->attrStart[attr][3] + span->leftClip * dqdx;
d637 1
a637 1
               GLfloat w = span->attrStart[FRAG_ATTRIB_WPOS][3] + span->leftClip * dwdx;
d678 1
a678 1
               GLfloat w = span->attrStart[FRAG_ATTRIB_WPOS][3] + span->leftClip * dwdx;
d727 49
d780 1
a780 1
interpolate_wpos(struct gl_context *ctx, SWspan *span)
d784 1
a784 1
   const GLfloat zScale = 1.0F / ctx->DrawBuffer->_DepthMaxF;
d800 1
a801 1
   w = span->attrStart[FRAG_ATTRIB_WPOS][3] + span->leftClip * dw;
d814 1
a814 1
stipple_polygon_span(struct gl_context *ctx, SWspan *span)
d859 1
a859 1
clip_span( struct gl_context *ctx, SWspan *span )
a865 2
   span->leftClip = 0;

d893 1
a893 1
      GLint n = span->end;
a900 6
      /* Clip to right */
      if (x + n > xmax) {
         ASSERT(x < xmax);
         n = span->end = xmax - x;
      }

a902 4
         const GLint leftClip = xmin - x;
         GLuint i;

         ASSERT(leftClip > 0);
a903 51

         /* Clip 'leftClip' pixels from the left side.
          * The span->leftClip field will be applied when we interpolate
          * fragment attributes.
          * For arrays of values, shift them left.
          */
         for (i = 0; i < FRAG_ATTRIB_MAX; i++) {
            if (span->interpMask & (1 << i)) {
               GLuint j;
               for (j = 0; j < 4; j++) {
                  span->attrStart[i][j] += leftClip * span->attrStepX[i][j];
               }
            }
         }

         span->red += leftClip * span->redStep;
         span->green += leftClip * span->greenStep;
         span->blue += leftClip * span->blueStep;
         span->alpha += leftClip * span->alphaStep;
         span->index += leftClip * span->indexStep;
         span->z += leftClip * span->zStep;
         span->intTex[0] += leftClip * span->intTexStep[0];
         span->intTex[1] += leftClip * span->intTexStep[1];

#define SHIFT_ARRAY(ARRAY, SHIFT, LEN) \
         memcpy(ARRAY, ARRAY + (SHIFT), (LEN) * sizeof(ARRAY[0]))

         for (i = 0; i < FRAG_ATTRIB_MAX; i++) {
            if (span->arrayAttribs & (1 << i)) {
               /* shift array elements left by 'leftClip' */
               SHIFT_ARRAY(span->array->attribs[i], leftClip, n - leftClip);
            }
         }

         SHIFT_ARRAY(span->array->mask, leftClip, n - leftClip);
         SHIFT_ARRAY(span->array->rgba8, leftClip, n - leftClip);
         SHIFT_ARRAY(span->array->rgba16, leftClip, n - leftClip);
         SHIFT_ARRAY(span->array->x, leftClip, n - leftClip);
         SHIFT_ARRAY(span->array->y, leftClip, n - leftClip);
         SHIFT_ARRAY(span->array->z, leftClip, n - leftClip);
         SHIFT_ARRAY(span->array->index, leftClip, n - leftClip);
         for (i = 0; i < MAX_TEXTURE_COORD_UNITS; i++) {
            SHIFT_ARRAY(span->array->lambda[i], leftClip, n - leftClip);
         }
         SHIFT_ARRAY(span->array->coverage, leftClip, n - leftClip);

#undef SHIFT_ARRAY

         span->leftClip = leftClip;
         span->x = xmin;
         span->end -= leftClip;
d905 1
d908 5
a912 4
      ASSERT(span->x >= xmin);
      ASSERT(span->x + span->end <= xmax);
      ASSERT(span->y >= ymin);
      ASSERT(span->y < ymax);
d920 5
a924 3
 * Add specular colors to primary colors.
 * Only called during fixed-function operation.
 * Result is float color array (FRAG_ATTRIB_COL0).
d926 2
a927 2
static INLINE void
add_specular(struct gl_context *ctx, SWspan *span)
d930 51
a980 4
   const GLubyte *mask = span->array->mask;
   GLfloat (*col0)[4] = span->array->attribs[FRAG_ATTRIB_COL0];
   GLfloat (*col1)[4] = span->array->attribs[FRAG_ATTRIB_COL1];
   GLuint i;
d982 4
a985 4
   ASSERT(!ctx->FragmentProgram._Current);
   ASSERT(span->arrayMask & SPAN_RGBA);
   ASSERT(swrast->_ActiveAttribMask & FRAG_BIT_COL1);
   (void) swrast; /* silence warning */
d987 13
a999 3
   if (span->array->ChanType == GL_FLOAT) {
      if ((span->arrayAttribs & FRAG_BIT_COL0) == 0) {
         interpolate_active_attribs(ctx, span, FRAG_BIT_COL0);
d1002 25
a1026 4
   else {
      /* need float colors */
      if ((span->arrayAttribs & FRAG_BIT_COL0) == 0) {
         interpolate_float_colors(span);
d1030 14
a1043 3
   if ((span->arrayAttribs & FRAG_BIT_COL1) == 0) {
      /* XXX could avoid this and interpolate COL1 in the loop below */
      interpolate_active_attribs(ctx, span, FRAG_BIT_COL1);
d1046 9
a1054 2
   ASSERT(span->arrayAttribs & FRAG_BIT_COL0);
   ASSERT(span->arrayAttribs & FRAG_BIT_COL1);
d1056 4
a1059 5
   for (i = 0; i < span->end; i++) {
      if (mask[i]) {
         col0[i][0] += col1[i][0];
         col0[i][1] += col1[i][1];
         col0[i][2] += col1[i][2];
d1061 85
d1148 63
a1210 1
   span->array->ChanType = GL_FLOAT;
d1223 1
a1223 1
      GLubyte (*rgba)[4] = span->array->rgba8;
d1232 1
a1232 1
      GLushort (*rgba)[4] = span->array->rgba16;
a1241 1
         /* clamp later */
d1267 1
a1267 1
 * The only way 'output' can be greater than zero is when we have a fragment
d1281 1
a1281 1
      src = span->array->rgba8;
d1285 1
a1285 1
      src = span->array->rgba16;
d1289 1
a1289 1
      dst = span->array->rgba8;
d1292 1
a1292 1
      dst = span->array->rgba16;
a1302 1
   span->array->rgba = dst;
d1311 1
a1311 1
shade_texture_span(struct gl_context *ctx, SWspan *span)
d1324 6
d1332 18
a1349 7
      /* programmable shading */
      if (span->primitive == GL_BITMAP && span->array->ChanType != GL_FLOAT) {
         convert_color_type(span, GL_FLOAT, 0);
      }
      else {
         span->array->rgba = (void *) span->array->attribs[FRAG_ATTRIB_COL0];
      }
d1351 2
a1352 7
      if (span->primitive != GL_POINT ||
	  (span->interpMask & SPAN_RGBA) ||
	  ctx->Point.PointSprite) {
         /* for single-pixel points, we populated the arrays already */
         interpolate_active_attribs(ctx, span, ~0);
      }
      span->array->ChanType = GL_FLOAT;
d1354 1
a1354 1
      if (!(span->arrayMask & SPAN_Z))
d1357 3
d1376 1
a1376 1
   else if (ctx->Texture._EnabledCoordUnits) {
a1377 12

#if CHAN_BITS == 32
      if ((span->arrayAttribs & FRAG_BIT_COL0) == 0) {
         interpolate_int_colors(ctx, span);
      }
#else
      if (!(span->arrayMask & SPAN_RGBA))
         interpolate_int_colors(ctx, span);
#endif
      if ((span->arrayAttribs & FRAG_BITS_TEX_ANY) == 0x0)
         interpolate_texcoords(ctx, span);

d1392 1
a1392 1
_swrast_write_rgba_span( struct gl_context *ctx, SWspan *span)
d1395 1
a1395 1
   const GLuint *colorMask = (GLuint *) ctx->Color.ColorMask;
d1398 1
a1398 3
   const GLbitfield origArrayAttribs = span->arrayAttribs;
   const GLenum origChanType = span->array->ChanType;
   void * const origRgba = span->array->rgba;
d1401 1
a1401 1
   const GLboolean shaderOrTexture = shader || ctx->Texture._EnabledCoordUnits;
d1403 2
d1415 36
d1458 1
a1458 1
      memset(span->array->mask, 1, span->end);
d1463 3
a1465 10
   if (!clip_span(ctx, span)) {
      return;
   }

   ASSERT(span->end <= MAX_WIDTH);

   /* Depth bounds test */
   if (ctx->Depth.BoundsTest && fb->Visual.depthBits > 0) {
      if (!_swrast_depth_bounds_test(ctx, span)) {
         return;
a1471 1
      /* array of pixel locations */
d1489 4
a1492 2
   /* This is the normal place to compute the fragment color/Z
    * from texturing or shading.
d1494 1
a1494 1
   if (shaderOrTexture && !swrast->_DeferredTexture) {
a1500 1
         /* all fragments failed test */
d1506 2
a1507 2
   if (ctx->Stencil._Enabled || ctx->Depth.Test) {
      if (!(span->arrayMask & SPAN_Z))
d1510 1
a1510 4
      if (ctx->Transform.DepthClamp)
	 _swrast_depth_clamp_span(ctx, span);

      if (ctx->Stencil._Enabled) {
a1512 1
            /* all fragments failed test */
a1520 1
            /* all fragments failed test */
d1526 1
d1534 1
d1539 1
a1539 2
   if (fb->_NumColorDrawBuffers == 1 && colorMask[0] == 0x0) {
      /* no colors to write */
d1547 2
a1548 1
   if (shaderOrTexture && swrast->_DeferredTexture) {
a1551 5
#if CHAN_BITS == 32
   if ((span->arrayAttribs & FRAG_BIT_COL0) == 0) {
      interpolate_active_attribs(ctx, span, FRAG_BIT_COL0);
   }
#else
d1553 1
a1553 1
      interpolate_int_colors(ctx, span);
a1554 1
#endif
d1558 9
a1566 6
   if (span->primitive == GL_BITMAP || !swrast->SpecularVertexAdd) {
      /* Add primary and specular (diffuse + specular) colors */
      if (!shader) {
         if (ctx->Fog.ColorSumEnabled ||
             (ctx->Light.Enabled &&
              ctx->Light.Model.ColorControl == GL_SEPARATE_SPECULAR_COLOR)) {
d1569 5
d1594 1
a1594 5
    * Write to renderbuffers.
    * Depending on glDrawBuffer() state and the which color outputs are
    * written by the fragment shader, we may either replicate one color to
    * all renderbuffers or write a different color to each renderbuffer.
    * multiFragOutputs=TRUE for the later case.
d1596 61
a1656 77
   {
      const GLuint numBuffers = fb->_NumColorDrawBuffers;
      const struct gl_fragment_program *fp = ctx->FragmentProgram._Current;
      const GLboolean multiFragOutputs = 
         (fp && fp->Base.OutputsWritten >= (1 << FRAG_RESULT_DATA0));
      GLuint buf;

      for (buf = 0; buf < numBuffers; buf++) {
         struct gl_renderbuffer *rb = fb->_ColorDrawBuffers[buf];

         /* color[fragOutput] will be written to buffer[buf] */

         if (rb) {
            GLchan rgbaSave[MAX_WIDTH][4];
            const GLuint fragOutput = multiFragOutputs ? buf : 0;

            /* set span->array->rgba to colors for render buffer's datatype */
            if (rb->DataType != span->array->ChanType || fragOutput > 0) {
               convert_color_type(span, rb->DataType, fragOutput);
            }
            else {
               if (rb->DataType == GL_UNSIGNED_BYTE) {
                  span->array->rgba = span->array->rgba8;
               }
               else if (rb->DataType == GL_UNSIGNED_SHORT) {
                  span->array->rgba = (void *) span->array->rgba16;
               }
               else {
                  span->array->rgba = (void *)
                     span->array->attribs[FRAG_ATTRIB_COL0];
               }
            }

            if (!multiFragOutputs && numBuffers > 1) {
               /* save colors for second, third renderbuffer writes */
               memcpy(rgbaSave, span->array->rgba,
                      4 * span->end * sizeof(GLchan));
            }

            ASSERT(rb->_BaseFormat == GL_RGBA || rb->_BaseFormat == GL_RGB ||
		   rb->_BaseFormat == GL_ALPHA);

            if (ctx->Color._LogicOpEnabled) {
               _swrast_logicop_rgba_span(ctx, rb, span);
            }
            else if ((ctx->Color.BlendEnabled >> buf) & 1) {
               _swrast_blend_span(ctx, rb, span);
            }

            if (colorMask[buf] != 0xffffffff) {
               _swrast_mask_rgba_span(ctx, rb, span, buf);
            }

            if (span->arrayMask & SPAN_XY) {
               /* array of pixel coords */
               ASSERT(rb->PutValues);
               rb->PutValues(ctx, rb, span->end,
                             span->array->x, span->array->y,
                             span->array->rgba, span->array->mask);
            }
            else {
               /* horizontal run of pixels */
               ASSERT(rb->PutRow);
               rb->PutRow(ctx, rb, span->end, span->x, span->y,
                          span->array->rgba,
                          span->writeAll ? NULL: span->array->mask);
            }

            if (!multiFragOutputs && numBuffers > 1) {
               /* restore original span values */
               memcpy(span->array->rgba, rgbaSave,
                      4 * span->end * sizeof(GLchan));
            }

         } /* if rb */
      } /* for buf */
   }
d1662 1
a1662 3
   span->arrayAttribs = origArrayAttribs;
   span->array->ChanType = origChanType;
   span->array->rgba = origRgba;
d1673 1
a1673 1
_swrast_read_rgba_span( struct gl_context *ctx, struct gl_renderbuffer *rb,
d1683 1
a1683 1
      memset(rgba, 0, 4 * n * sizeof(GLchan));
d1716 1
a1716 5
      ASSERT(rb->_BaseFormat == GL_RGBA ||
	     rb->_BaseFormat == GL_RGB ||
	     rb->_BaseFormat == GL_RG ||
	     rb->_BaseFormat == GL_RED ||
	     rb->_BaseFormat == GL_ALPHA);
d1734 68
d1809 1
a1809 1
_swrast_get_values(struct gl_context *ctx, struct gl_renderbuffer *rb,
d1845 1
a1845 1
_swrast_put_row(struct gl_context *ctx, struct gl_renderbuffer *rb,
d1880 1
a1880 1
_swrast_get_row(struct gl_context *ctx, struct gl_renderbuffer *rb,
d1910 3
a1912 1
 * Get RGBA pixels from the given renderbuffer.
d1917 1
a1917 1
_swrast_get_dest_rgba(struct gl_context *ctx, struct gl_renderbuffer *rb,
d1923 13
a1935 2
   /* Point rbPixels to a temporary space */
   rbPixels = span->array->attribs[FRAG_ATTRIB_MAX - 1];
@


1.1.1.5
log
@Import Mesa 9.2.0
@
text
@d3 1
d21 3
a23 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
a35 2
#include "main/format_pack.h"
#include "main/format_unpack.h"
a38 1
#include "main/samplerobj.h"
a52 1
#include <stdbool.h>
d78 3
a80 3
   span->attrStart[VARYING_SLOT_POS][3] = 1.0;
   span->attrStepX[VARYING_SLOT_POS][3] = 0.0;
   span->attrStepY[VARYING_SLOT_POS][3] = 0.0;
d104 3
a106 3
   COPY_4V(span->attrStart[VARYING_SLOT_COL0], ctx->Current.RasterColor);
   ASSIGN_4V(span->attrStepX[VARYING_SLOT_COL0], 0.0, 0.0, 0.0, 0.0);
   ASSIGN_4V(span->attrStepY[VARYING_SLOT_COL0], 0.0, 0.0, 0.0, 0.0);
d111 3
a113 3
      COPY_4V(span->attrStart[VARYING_SLOT_COL1], ctx->Current.RasterSecondaryColor);
      ASSIGN_4V(span->attrStepX[VARYING_SLOT_COL1], 0.0, 0.0, 0.0, 0.0);
      ASSIGN_4V(span->attrStepY[VARYING_SLOT_COL1], 0.0, 0.0, 0.0, 0.0);
d128 3
a130 3
      span->attrStart[VARYING_SLOT_FOGC][0] = fogVal;
      span->attrStepX[VARYING_SLOT_FOGC][0] = 0.0;
      span->attrStepY[VARYING_SLOT_FOGC][0] = 0.0;
d137 1
a137 1
         const GLuint attr = VARYING_SLOT_TEX0 + i;
d139 1
a139 2
         if (_swrast_use_fragment_program(ctx) ||
             ctx->ATIFragmentShader._Enabled) {
d163 1
a163 1
 * should have computed attrStart/Step values for VARYING_SLOT_POS[3]!
d165 2
a166 3
static inline void
interpolate_active_attribs(struct gl_context *ctx, SWspan *span,
                           GLbitfield64 attrMask)
d177 3
a179 3
      if (attrMask & BITFIELD64_BIT(attr)) {
         const GLfloat dwdx = span->attrStepX[VARYING_SLOT_POS][3];
         GLfloat w = span->attrStart[VARYING_SLOT_POS][3];
d201 2
a202 2
         ASSERT((span->arrayAttribs & BITFIELD64_BIT(attr)) == 0);
         span->arrayAttribs |= BITFIELD64_BIT(attr);
d212 1
a212 1
static inline void
a214 1
#if CHAN_BITS != 32
d218 1
d299 1
a299 1
      interpolate_active_attribs(ctx, span, VARYING_BIT_COL0);
d302 1
a302 2
      _mesa_problem(ctx, "bad datatype 0x%x in interpolate_int_colors",
                    span->array->ChanType);
d309 1
a309 1
 * Populate the VARYING_SLOT_COL0 array.
d311 1
a311 1
static inline void
d314 1
a314 1
   GLfloat (*col0)[4] = span->array->attribs[VARYING_SLOT_COL0];
d318 1
a318 1
   assert(!(span->arrayAttribs & VARYING_BIT_COL0));
d363 1
a363 1
   span->arrayAttribs |= VARYING_BIT_COL0;
d415 2
a416 2
   GLfloat x = sqrtf(dudx * dudx + dvdx * dvdx);
   GLfloat y = sqrtf(dudy * dudy + dvdy * dvdy);
d452 1
a452 1
 * Fill in the span.array->attrib[VARYING_SLOT_TEXn] arrays from the
d472 1
a472 1
         const GLuint attr = VARYING_SLOT_TEX0 + u;
d492 4
a495 15
            const struct swrast_texture_image *swImg =
               swrast_texture_image_const(img);
            const struct gl_sampler_object *samp = _mesa_get_samplerobj(ctx, u);

            needLambda = (samp->MinFilter != samp->MagFilter)
               || _swrast_use_fragment_program(ctx);
            /* LOD is calculated directly in the ansiotropic filter, we can
             * skip the normal lambda function as the result is ignored.
             */
            if (samp->MaxAnisotropy > 1.0 &&
                samp->MinFilter == GL_LINEAR_MIPMAP_LINEAR) {
               needLambda = GL_FALSE;
            }
            texW = swImg->WidthScale;
            texH = swImg->HeightScale;
d506 1
a506 1
            if (_swrast_use_fragment_program(ctx)
d509 2
a510 2
               const GLfloat dwdx = span->attrStepX[VARYING_SLOT_POS][3];
               GLfloat w = span->attrStart[VARYING_SLOT_POS][3] + span->leftClip * dwdx;
d547 1
a547 1
            if (_swrast_use_fragment_program(ctx) ||
d550 2
a551 2
               const GLfloat dwdx = span->attrStepX[VARYING_SLOT_POS][3];
               GLfloat w = span->attrStart[VARYING_SLOT_POS][3] + span->leftClip * dwdx;
d601 1
a601 1
 * Fill in the arrays->attribs[VARYING_SLOT_POS] array.
d603 1
a603 1
static inline void
d606 1
a606 1
   GLfloat (*wpos)[4] = span->array->attribs[VARYING_SLOT_POS];
d624 2
a625 2
   dw = span->attrStepX[VARYING_SLOT_POS][3];
   w = span->attrStart[VARYING_SLOT_POS][3] + span->leftClip * dw;
d637 1
a637 1
static inline void
d682 1
a682 1
static inline GLuint
a698 1
      GLuint passed = 0;
a703 1
            passed += mask[i];
a710 1
            passed += mask[i];
d713 1
a713 1
      return passed > 0;
d746 1
a746 1
         for (i = 0; i < VARYING_SLOT_MAX; i++) {
d765 1
a765 1
         memmove(ARRAY, ARRAY + (SHIFT), (LEN) * sizeof(ARRAY[0]))
d767 1
a767 1
         for (i = 0; i < VARYING_SLOT_MAX; i++) {
d807 1
a807 1
 * Result is float color array (VARYING_SLOT_COL0).
d809 1
a809 1
static inline void
d814 2
a815 2
   GLfloat (*col0)[4] = span->array->attribs[VARYING_SLOT_COL0];
   GLfloat (*col1)[4] = span->array->attribs[VARYING_SLOT_COL1];
d818 1
a818 1
   ASSERT(!_swrast_use_fragment_program(ctx));
d820 1
a820 1
   ASSERT(swrast->_ActiveAttribMask & VARYING_BIT_COL1);
d824 2
a825 2
      if ((span->arrayAttribs & VARYING_BIT_COL0) == 0) {
         interpolate_active_attribs(ctx, span, VARYING_BIT_COL0);
d830 1
a830 1
      if ((span->arrayAttribs & VARYING_BIT_COL0) == 0) {
d835 1
a835 1
   if ((span->arrayAttribs & VARYING_BIT_COL1) == 0) {
d837 1
a837 1
      interpolate_active_attribs(ctx, span, VARYING_BIT_COL1);
d840 2
a841 2
   ASSERT(span->arrayAttribs & VARYING_BIT_COL0);
   ASSERT(span->arrayAttribs & VARYING_BIT_COL1);
d858 1
a858 1
static inline void
d880 1
a880 1
      GLfloat (*rgba)[4] = span->array->attribs[VARYING_SLOT_COL0];
d892 1
a892 1
static inline void
d895 1
a895 1
   GLfloat (*rgba)[4] = span->array->attribs[VARYING_SLOT_COL0];
d913 1
a913 1
static inline void
d919 1
a919 1
      src = span->array->attribs[VARYING_SLOT_COL0 + output];
d937 1
a937 1
      dst = span->array->attribs[VARYING_SLOT_COL0];
d953 1
a953 1
static inline void
d956 12
a967 1
   if (_swrast_use_fragment_program(ctx) ||
d974 1
a974 1
         span->array->rgba = (void *) span->array->attribs[VARYING_SLOT_COL0];
d989 1
a989 1
      if (inputsRead & VARYING_BIT_POS)
d996 1
a996 1
      if (_swrast_use_fragment_program(ctx)) {
d1008 1
a1008 1
      if ((span->arrayAttribs & VARYING_BIT_COL0) == 0) {
d1015 1
a1015 1
      if ((span->arrayAttribs & VARYING_BITS_TEX_ANY) == 0x0)
a1022 88
/** Put colors at x/y locations into a renderbuffer */
static void
put_values(struct gl_context *ctx, struct gl_renderbuffer *rb,
           GLenum datatype,
           GLuint count, const GLint x[], const GLint y[],
           const void *values, const GLubyte *mask)
{
   gl_pack_ubyte_rgba_func pack_ubyte = NULL;
   gl_pack_float_rgba_func pack_float = NULL;
   GLuint i;

   if (datatype == GL_UNSIGNED_BYTE)
      pack_ubyte = _mesa_get_pack_ubyte_rgba_function(rb->Format);
   else
      pack_float = _mesa_get_pack_float_rgba_function(rb->Format);

   for (i = 0; i < count; i++) {
      if (mask[i]) {
         GLubyte *dst = _swrast_pixel_address(rb, x[i], y[i]);

         if (datatype == GL_UNSIGNED_BYTE) {
            pack_ubyte((const GLubyte *) values + 4 * i, dst);
         }
         else {
            assert(datatype == GL_FLOAT);
            pack_float((const GLfloat *) values + 4 * i, dst);
         }
      }
   }
}


/** Put row of colors into renderbuffer */
void
_swrast_put_row(struct gl_context *ctx, struct gl_renderbuffer *rb,
                GLenum datatype,
                GLuint count, GLint x, GLint y,
                const void *values, const GLubyte *mask)
{
   GLubyte *dst = _swrast_pixel_address(rb, x, y);

   if (!mask) {
      if (datatype == GL_UNSIGNED_BYTE) {
         _mesa_pack_ubyte_rgba_row(rb->Format, count,
                                   (const GLubyte (*)[4]) values, dst);
      }
      else {
         assert(datatype == GL_FLOAT);
         _mesa_pack_float_rgba_row(rb->Format, count,
                                   (const GLfloat (*)[4]) values, dst);
      }
   }
   else {
      const GLuint bpp = _mesa_get_format_bytes(rb->Format);
      GLuint i, runLen, runStart;
      /* We can't pass a 'mask' array to the _mesa_pack_rgba_row() functions
       * so look for runs where mask=1...
       */
      runLen = runStart = 0;
      for (i = 0; i < count; i++) {
         if (mask[i]) {
            if (runLen == 0)
               runStart = i;
            runLen++;
         }

         if (!mask[i] || i == count - 1) {
            /* might be the end of a run of pixels */
            if (runLen > 0) {
               if (datatype == GL_UNSIGNED_BYTE) {
                  _mesa_pack_ubyte_rgba_row(rb->Format, runLen,
                                     (const GLubyte (*)[4]) values + runStart,
                                     dst + runStart * bpp);
               }
               else {
                  assert(datatype == GL_FLOAT);
                  _mesa_pack_float_rgba_row(rb->Format, runLen,
                                   (const GLfloat (*)[4]) values + runStart,
                                   dst + runStart * bpp);
               }
               runLen = 0;
            }
         }
      }
   }
}


d1038 1
a1038 1
   const GLbitfield64 origArrayAttribs = span->arrayAttribs;
d1041 1
a1041 1
   const GLboolean shader = (_swrast_use_fragment_program(ctx)
d1071 1
a1071 1
   ASSERT(span->end <= SWRAST_MAX_WIDTH);
d1167 2
a1168 2
   if ((span->arrayAttribs & VARYING_BIT_COL0) == 0) {
      interpolate_active_attribs(ctx, span, VARYING_BIT_COL0);
d1216 1
a1216 2
         _swrast_use_fragment_program(ctx)
         && fp->Base.OutputsWritten >= (1 << FRAG_RESULT_DATA0);
d1225 6
a1230 11
            /* re-use one of the attribute array buffers for rgbaSave */
            GLchan (*rgbaSave)[4] = (GLchan (*)[4]) span->array->attribs[0];
            struct swrast_renderbuffer *srb = swrast_renderbuffer(rb);
            GLenum colorType = srb->ColorType;

            assert(colorType == GL_UNSIGNED_BYTE ||
                   colorType == GL_FLOAT);

            /* set span->array->rgba to colors for renderbuffer's datatype */
            if (span->array->ChanType != colorType) {
               convert_color_type(span, colorType, 0);
d1233 1
a1233 1
               if (span->array->ChanType == GL_UNSIGNED_BYTE) {
d1236 3
d1241 1
a1241 1
                     span->array->attribs[VARYING_SLOT_COL0];
d1251 1
a1251 4
            ASSERT(rb->_BaseFormat == GL_RGBA ||
                   rb->_BaseFormat == GL_RGB ||
                   rb->_BaseFormat == GL_RED ||
                   rb->_BaseFormat == GL_RG ||
d1254 1
a1254 1
            if (ctx->Color.ColorLogicOpEnabled) {
d1267 4
a1270 4
               put_values(ctx, rb,
                          span->array->ChanType, span->end,
                          span->array->x, span->array->y,
                          span->array->rgba, span->array->mask);
d1274 4
a1277 5
               _swrast_put_row(ctx, rb,
                               span->array->ChanType,
                               span->end, span->x, span->y,
                               span->array->rgba,
                               span->writeAll ? NULL: span->array->mask);
d1301 3
a1303 2
 * Read float RGBA pixels from a renderbuffer.  Clipping will be done to
 * prevent reading ouside the buffer's boundaries.
d1308 1
a1308 1
                        GLuint n, GLint x, GLint y,
a1310 2
   struct swrast_renderbuffer *srb = swrast_renderbuffer(rb);
   GLenum dstType = GL_FLOAT;
a1320 2
      GLubyte *src;

d1349 1
a1353 3
	     rb->_BaseFormat == GL_LUMINANCE ||
	     rb->_BaseFormat == GL_INTENSITY ||
	     rb->_BaseFormat == GL_LUMINANCE_ALPHA ||
d1356 3
a1358 11
      assert(srb->Map);

      src = _swrast_pixel_address(rb, x + skip, y);

      if (dstType == GL_UNSIGNED_BYTE) {
         _mesa_unpack_ubyte_rgba_row(rb->Format, length, src,
                                     (GLubyte (*)[4]) rgba + skip);
      }
      else if (dstType == GL_FLOAT) {
         _mesa_unpack_rgba_row(rb->Format, length, src,
                               (GLfloat (*)[4]) rgba + skip);
d1361 5
a1365 1
         _mesa_problem(ctx, "unexpected type in _swrast_read_rgba_span()");
d1372 5
a1376 2
 * Get colors at x/y positions with clipping.
 * \param type  type of values to return
d1378 4
a1381 4
static void
get_values(struct gl_context *ctx, struct gl_renderbuffer *rb,
           GLuint count, const GLint x[], const GLint y[],
           void *values, GLenum type)
d1383 1
a1383 1
   GLuint i;
d1389 10
a1398 12
         const GLubyte *src = _swrast_pixel_address(rb, x[i], y[i]);

         if (type == GL_UNSIGNED_BYTE) {
            _mesa_unpack_ubyte_rgba_row(rb->Format, 1, src,
                                        (GLubyte (*)[4]) values + i);
         }
         else if (type == GL_FLOAT) {
            _mesa_unpack_rgba_row(rb->Format, 1, src,
                                  (GLfloat (*)[4]) values + i);
         }
         else {
            _mesa_problem(ctx, "unexpected type in get_values()");
d1402 5
d1411 2
a1412 2
 * Get row of colors with clipping.
 * \param type  type of values to return
d1414 4
a1417 4
static void
get_row(struct gl_context *ctx, struct gl_renderbuffer *rb,
        GLuint count, GLint x, GLint y,
        GLvoid *values, GLenum type)
a1419 1
   GLubyte *src;
d1427 1
a1427 1
   if (x + count > rb->Width) {
d1440 21
a1460 1
   src = _swrast_pixel_address(rb, x, y);
d1462 4
a1465 7
   if (type == GL_UNSIGNED_BYTE) {
      _mesa_unpack_ubyte_rgba_row(rb->Format, count, src,
                                  (GLubyte (*)[4]) values + skip);
   }
   else if (type == GL_FLOAT) {
      _mesa_unpack_rgba_row(rb->Format, count, src,
                            (GLfloat (*)[4]) values + skip);
d1467 6
a1472 2
   else {
      _mesa_problem(ctx, "unexpected type in get_row()");
d1474 2
d1488 1
d1492 1
a1492 1
   rbPixels = span->array->attribs[VARYING_SLOT_MAX - 1];
d1496 2
a1497 2
      get_values(ctx, rb, span->end, span->array->x, span->array->y,
                 rbPixels, span->array->ChanType);
d1500 2
a1501 2
      get_row(ctx, rb, span->end, span->x, span->y,
              rbPixels, span->array->ChanType);
@


