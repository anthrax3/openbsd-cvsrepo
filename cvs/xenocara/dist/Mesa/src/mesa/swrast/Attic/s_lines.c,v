head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.8
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.6
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.5
	v10_2_7:1.1.1.5
	OPENBSD_5_6:1.6.0.4
	OPENBSD_5_6_BASE:1.6
	v10_2_3:1.1.1.5
	OPENBSD_5_5:1.6.0.2
	OPENBSD_5_5_BASE:1.6
	v9_2_5:1.1.1.5
	v9_2_3:1.1.1.5
	v9_2_2:1.1.1.5
	v9_2_1:1.1.1.5
	v9_2_0:1.1.1.5
	OPENBSD_5_4:1.5.0.8
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.6
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.3.0.4
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.12.23.05.17.55;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2013.09.05.14.06.49;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.23.13.37.45;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.34;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.42;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.23;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.51.20;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.51.20;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.56.50;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.32.09;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.48;	author matthieu;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.09.05.13.17.30;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */


#include "main/glheader.h"
#include "main/context.h"
#include "main/colormac.h"
#include "main/macros.h"
#include "s_aaline.h"
#include "s_context.h"
#include "s_feedback.h"
#include "s_lines.h"
#include "s_span.h"


/*
 * Init the mask[] array to implement a line stipple.
 */
static void
compute_stipple_mask( struct gl_context *ctx, GLuint len, GLubyte mask[] )
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
   GLuint i;

   for (i = 0; i < len; i++) {
      GLuint bit = (swrast->StippleCounter / ctx->Line.StippleFactor) & 0xf;
      if ((1 << bit) & ctx->Line.StipplePattern) {
         mask[i] = GL_TRUE;
      }
      else {
         mask[i] = GL_FALSE;
      }
      swrast->StippleCounter++;
   }
}


/*
 * To draw a wide line we can simply redraw the span N times, side by side.
 */
static void
draw_wide_line( struct gl_context *ctx, SWspan *span, GLboolean xMajor )
{
   const GLint width = (GLint) CLAMP(ctx->Line.Width,
                                     ctx->Const.MinLineWidth,
                                     ctx->Const.MaxLineWidth);
   GLint start;

   ASSERT(span->end < SWRAST_MAX_WIDTH);

   if (width & 1)
      start = width / 2;
   else
      start = width / 2 - 1;

   if (xMajor) {
      GLint *y = span->array->y;
      GLuint i;
      GLint w;
      for (w = 0; w < width; w++) {
         if (w == 0) {
            for (i = 0; i < span->end; i++)
               y[i] -= start;
         }
         else {
            for (i = 0; i < span->end; i++)
               y[i]++;
         }
	 _swrast_write_rgba_span(ctx, span);
      }
   }
   else {
      GLint *x = span->array->x;
      GLuint i;
      GLint w;
      for (w = 0; w < width; w++) {
         if (w == 0) {
            for (i = 0; i < span->end; i++)
               x[i] -= start;
         }
         else {
            for (i = 0; i < span->end; i++)
               x[i]++;
         }
	 _swrast_write_rgba_span(ctx, span);
      }
   }
}



/**********************************************************************/
/*****                    Rasterization                           *****/
/**********************************************************************/

/* Simple RGBA index line (no stipple, width=1, no Z, no fog, no tex)*/
#define NAME simple_no_z_rgba_line
#define INTERP_RGBA
#define RENDER_SPAN(span) _swrast_write_rgba_span(ctx, &span);
#include "s_linetemp.h"


/* Z, fog, wide, stipple RGBA line */
#define NAME rgba_line
#define INTERP_RGBA
#define INTERP_Z
#define RENDER_SPAN(span)					\
   if (ctx->Line.StippleFlag) {					\
      span.arrayMask |= SPAN_MASK;				\
      compute_stipple_mask(ctx, span.end, span.array->mask);	\
   }								\
   if (ctx->Line.Width > 1.0) {					\
      draw_wide_line(ctx, &span, (GLboolean)(dx > dy));		\
   }								\
   else {							\
      _swrast_write_rgba_span(ctx, &span);			\
   }
#include "s_linetemp.h"


/* General-purpose line (any/all features). */
#define NAME general_line
#define INTERP_RGBA
#define INTERP_Z
#define INTERP_ATTRIBS
#define RENDER_SPAN(span)					\
   if (ctx->Line.StippleFlag) {					\
      span.arrayMask |= SPAN_MASK;				\
      compute_stipple_mask(ctx, span.end, span.array->mask);	\
   }								\
   if (ctx->Line.Width > 1.0) {					\
      draw_wide_line(ctx, &span, (GLboolean)(dx > dy));		\
   }								\
   else {							\
      _swrast_write_rgba_span(ctx, &span);			\
   }
#include "s_linetemp.h"



void
_swrast_add_spec_terms_line(struct gl_context *ctx,
                            const SWvertex *v0, const SWvertex *v1)
{
   SWvertex *ncv0 = (SWvertex *)v0;
   SWvertex *ncv1 = (SWvertex *)v1;
   GLfloat rSum, gSum, bSum;
   GLchan cSave[2][4];

   /* save original colors */
   COPY_CHAN4(cSave[0], ncv0->color);
   COPY_CHAN4(cSave[1], ncv1->color);
   /* sum v0 */
   rSum = CHAN_TO_FLOAT(ncv0->color[0]) + ncv0->attrib[VARYING_SLOT_COL1][0];
   gSum = CHAN_TO_FLOAT(ncv0->color[1]) + ncv0->attrib[VARYING_SLOT_COL1][1];
   bSum = CHAN_TO_FLOAT(ncv0->color[2]) + ncv0->attrib[VARYING_SLOT_COL1][2];
   UNCLAMPED_FLOAT_TO_CHAN(ncv0->color[0], rSum);
   UNCLAMPED_FLOAT_TO_CHAN(ncv0->color[1], gSum);
   UNCLAMPED_FLOAT_TO_CHAN(ncv0->color[2], bSum);
   /* sum v1 */
   rSum = CHAN_TO_FLOAT(ncv1->color[0]) + ncv1->attrib[VARYING_SLOT_COL1][0];
   gSum = CHAN_TO_FLOAT(ncv1->color[1]) + ncv1->attrib[VARYING_SLOT_COL1][1];
   bSum = CHAN_TO_FLOAT(ncv1->color[2]) + ncv1->attrib[VARYING_SLOT_COL1][2];
   UNCLAMPED_FLOAT_TO_CHAN(ncv1->color[0], rSum);
   UNCLAMPED_FLOAT_TO_CHAN(ncv1->color[1], gSum);
   UNCLAMPED_FLOAT_TO_CHAN(ncv1->color[2], bSum);
   /* draw */
   SWRAST_CONTEXT(ctx)->SpecLine( ctx, ncv0, ncv1 );
   /* restore original colors */
   COPY_CHAN4(ncv0->color, cSave[0]);
   COPY_CHAN4(ncv1->color, cSave[1]);
}



#ifdef DEBUG

/* record the current line function name */
static const char *lineFuncName = NULL;

#define USE(lineFunc)                   \
do {                                    \
    lineFuncName = #lineFunc;           \
    /*printf("%s\n", lineFuncName);*/   \
    swrast->Line = lineFunc;            \
} while (0)

#else

#define USE(lineFunc)  swrast->Line = lineFunc

#endif



/**
 * Determine which line drawing function to use given the current
 * rendering context.
 *
 * Please update the summary flag _SWRAST_NEW_LINE if you add or remove
 * tests to this code.
 */
void
_swrast_choose_line( struct gl_context *ctx )
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
   GLboolean specular = (ctx->Fog.ColorSumEnabled ||
                         (ctx->Light.Enabled &&
                          ctx->Light.Model.ColorControl == GL_SEPARATE_SPECULAR_COLOR));

   if (ctx->RenderMode == GL_RENDER) {
      if (ctx->Line.SmoothFlag) {
         /* antialiased lines */
         _swrast_choose_aa_line_function(ctx);
         ASSERT(swrast->Line);
      }
      else if (ctx->Texture._EnabledCoordUnits
               || _swrast_use_fragment_program(ctx)
               || swrast->_FogEnabled
               || specular) {
         USE(general_line);
      }
      else if (ctx->Depth.Test
               || ctx->Line.Width != 1.0
               || ctx->Line.StippleFlag) {
         /* no texture, but Z, fog, width>1, stipple, etc. */
#if CHAN_BITS == 32
         USE(general_line);
#else
         USE(rgba_line);
#endif
      }
      else {
         ASSERT(!ctx->Depth.Test);
         ASSERT(ctx->Line.Width == 1.0);
         /* simple lines */
         USE(simple_no_z_rgba_line);
      }
   }
   else if (ctx->RenderMode == GL_FEEDBACK) {
      USE(_swrast_feedback_line);
   }
   else {
      ASSERT(ctx->RenderMode == GL_SELECT);
      USE(_swrast_select_line);
   }
}
@


1.6
log
@Merge Mesa 9.2.0
@
text
@@


1.5
log
@Merge Mesa 7.10.3
@
text
@a2 1
 * Version:  7.1
d19 4
a22 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
d70 1
a70 1
   ASSERT(span->end < MAX_WIDTH);
d175 3
a177 3
   rSum = CHAN_TO_FLOAT(ncv0->color[0]) + ncv0->attrib[FRAG_ATTRIB_COL1][0];
   gSum = CHAN_TO_FLOAT(ncv0->color[1]) + ncv0->attrib[FRAG_ATTRIB_COL1][1];
   bSum = CHAN_TO_FLOAT(ncv0->color[2]) + ncv0->attrib[FRAG_ATTRIB_COL1][2];
d182 3
a184 3
   rSum = CHAN_TO_FLOAT(ncv1->color[0]) + ncv1->attrib[FRAG_ATTRIB_COL1][0];
   gSum = CHAN_TO_FLOAT(ncv1->color[1]) + ncv1->attrib[FRAG_ATTRIB_COL1][1];
   bSum = CHAN_TO_FLOAT(ncv1->color[2]) + ncv1->attrib[FRAG_ATTRIB_COL1][2];
d191 2
a192 2
   COPY_CHAN4( ncv0->attrib[FRAG_ATTRIB_COL0], cSave[0] );
   COPY_CHAN4( ncv1->attrib[FRAG_ATTRIB_COL0], cSave[1] );
d239 1
a239 1
               || ctx->FragmentProgram._Current
@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d41 1
a41 1
compute_stipple_mask( GLcontext *ctx, GLuint len, GLubyte mask[] )
d63 1
a63 1
draw_wide_line( GLcontext *ctx, SWspan *span, GLboolean xMajor )
d163 1
a163 1
_swrast_add_spec_terms_line(GLcontext *ctx,
d225 1
a225 1
_swrast_choose_line( GLcontext *ctx )
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@a31 1
#include "s_depth.h"
d90 1
a90 4
         if (ctx->Visual.rgbMode)
            _swrast_write_rgba_span(ctx, span);
         else
            _swrast_write_index_span(ctx, span);
d106 1
a106 4
         if (ctx->Visual.rgbMode)
            _swrast_write_rgba_span(ctx, span);
         else
            _swrast_write_index_span(ctx, span);
a116 6
/* Simple color index line (no stipple, width=1, no Z, no fog, no tex)*/
#define NAME simple_no_z_ci_line
#define INTERP_INDEX
#define RENDER_SPAN(span) _swrast_write_index_span(ctx, &span)
#include "s_linetemp.h"

a123 19
/* Z, fog, wide, stipple color index line */
#define NAME ci_line
#define INTERP_INDEX
#define INTERP_Z
#define INTERP_ATTRIBS /* for fog */
#define RENDER_SPAN(span)					\
   if (ctx->Line.StippleFlag) {					\
      span.arrayMask |= SPAN_MASK;				\
      compute_stipple_mask(ctx, span.end, span.array->mask);    \
   }								\
   if (ctx->Line.Width > 1.0) {					\
      draw_wide_line(ctx, &span, (GLboolean)(dx > dy));		\
   }								\
   else {							\
      _swrast_write_index_span(ctx, &span);			\
   }
#include "s_linetemp.h"


d205 1
a205 1
    /*_mesa_printf("%s\n", lineFuncName);*/   \
a227 1
   const GLboolean rgbmode = ctx->Visual.rgbMode;
a247 1
         if (rgbmode)
d249 1
a249 1
            USE(general_line);
d251 1
a251 1
            USE(rgba_line);
a252 2
         else
            USE(ci_line);
d258 1
a258 4
         if (rgbmode)
            USE(simple_no_z_rgba_line);
         else
            USE(simple_no_z_ci_line);
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d26 4
a29 4
#include "glheader.h"
#include "context.h"
#include "colormac.h"
#include "macros.h"
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * Version:  6.5
d5 1
a5 1
 * Copyright (C) 1999-2005  Brian Paul   All Rights Reserved.
d64 1
a64 1
draw_wide_line( GLcontext *ctx, struct sw_span *span, GLboolean xMajor )
d66 4
a69 1
   GLint width, start;
a72 2
   width = (GLint) CLAMP( ctx->Line._Width, MIN_LINE_WIDTH, MAX_LINE_WIDTH );

d125 1
a125 1
#define NAME simple_ci_line
d131 1
a131 1
#define NAME simple_rgba_line
d138 1
a138 1
#define NAME general_ci_line
d141 1
a141 1
#define INTERP_FOG
d147 1
a147 1
   if (ctx->Line._Width > 1.0) {					\
d157 1
a157 1
#define NAME general_rgba_line
a159 1
#define INTERP_FOG
d165 1
a165 1
   if (ctx->Line._Width > 1.0) {					\
d174 2
a175 2
/* Single-texture line, w/ fog, Z, specular, etc. */
#define NAME textured_line
d178 1
a178 2
#define INTERP_FOG
#define INTERP_TEX
d184 1
a184 22
   if (ctx->Line._Width > 1.0) {					\
      draw_wide_line(ctx, &span, (GLboolean)(dx > dy));		\
   }								\
   else {							\
      _swrast_write_rgba_span(ctx, &span);			\
   }
#include "s_linetemp.h"


/* Multi-texture or separate specular line, w/ fog, Z, specular, etc. */
#define NAME multitextured_line
#define INTERP_RGBA
#define INTERP_SPEC
#define INTERP_Z
#define INTERP_FOG
#define INTERP_MULTITEX
#define RENDER_SPAN(span)					\
   if (ctx->Line.StippleFlag) {					\
      span.arrayMask |= SPAN_MASK;				\
      compute_stipple_mask(ctx, span.end, span.array->mask);	\
   }								\
   if (ctx->Line._Width > 1.0) {					\
d195 2
a196 3
_swrast_add_spec_terms_line( GLcontext *ctx,
                             const SWvertex *v0,
                             const SWvertex *v1 )
d200 21
a220 5
   GLchan c[2][4];
   COPY_CHAN4( c[0], ncv0->color );
   COPY_CHAN4( c[1], ncv1->color );
   ACC_3V( ncv0->color, ncv0->specular );
   ACC_3V( ncv1->color, ncv1->specular );
d222 3
a224 2
   COPY_CHAN4( ncv0->color, c[0] );
   COPY_CHAN4( ncv1->color, c[1] );
a227 27
#ifdef DEBUG
extern void
_mesa_print_line_function(GLcontext *ctx);  /* silence compiler warning */
void
_mesa_print_line_function(GLcontext *ctx)
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);

   _mesa_printf("Line Func == ");
   if (swrast->Line == simple_ci_line)
      _mesa_printf("simple_ci_line\n");
   else if (swrast->Line == simple_rgba_line)
      _mesa_printf("simple_rgba_line\n");
   else if (swrast->Line == general_ci_line)
      _mesa_printf("general_ci_line\n");
   else if (swrast->Line == general_rgba_line)
      _mesa_printf("general_rgba_line\n");
   else if (swrast->Line == textured_line)
      _mesa_printf("textured_line\n");
   else if (swrast->Line == multitextured_line)
      _mesa_printf("multitextured_line\n");
   else
      _mesa_printf("Driver func %p\n", (void *(*)()) swrast->Line);
}
#endif


d249 1
a249 1
/*
d261 3
d271 5
a275 10
      else if (ctx->Texture._EnabledCoordUnits) {
         /* textured lines */
         if (ctx->Texture._EnabledCoordUnits > 0x1
             || NEED_SECONDARY_COLOR(ctx)) {
            /* multi-texture and/or separate specular color */
            USE(multitextured_line);
         }
         else {
            USE(textured_line);
         }
d277 2
a278 1
      else if (ctx->Depth.Test || swrast->_FogEnabled || ctx->Line._Width != 1.0
d282 5
a286 1
            USE(general_rgba_line);
d288 1
a288 1
            USE(general_ci_line);
d291 3
a293 1
         /* simplest lines */
d295 1
a295 1
            USE(simple_rgba_line);
d297 1
a297 1
            USE(simple_ci_line);
a306 2

   /*_mesa_print_line_function(ctx);*/
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d64 1
a64 1
draw_wide_line( GLcontext *ctx, SWspan *span, GLboolean xMajor )
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d3 1
a3 1
 * Version:  6.5.3
d5 1
a5 1
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
d174 1
a174 1
/* General-purpose textured line (any/all features). */
d177 20
d200 1
a200 1
#define INTERP_ATTRIBS
d253 2
d301 1
a301 2
      else if (ctx->Texture._EnabledCoordUnits
             || ctx->FragmentProgram._Current) {
d303 8
a310 1
         USE(textured_line);
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d3 1
a3 1
 * Version:  7.1
d26 4
a29 4
#include "main/glheader.h"
#include "main/context.h"
#include "main/colormac.h"
#include "main/macros.h"
d32 1
d42 1
a42 1
compute_stipple_mask( struct gl_context *ctx, GLuint len, GLubyte mask[] )
d64 1
a64 1
draw_wide_line( struct gl_context *ctx, SWspan *span, GLboolean xMajor )
d66 1
a66 4
   const GLint width = (GLint) CLAMP(ctx->Line.Width,
                                     ctx->Const.MinLineWidth,
                                     ctx->Const.MaxLineWidth);
   GLint start;
d70 2
d90 4
a93 1
	 _swrast_write_rgba_span(ctx, span);
d109 4
a112 1
	 _swrast_write_rgba_span(ctx, span);
d123 6
d130 1
a130 1
#define NAME simple_no_z_rgba_line
d136 19
d156 1
a156 1
#define NAME rgba_line
d159 1
d165 1
a165 1
   if (ctx->Line.Width > 1.0) {					\
d174 2
a175 2
/* General-purpose line (any/all features). */
#define NAME general_line
d177 1
d179 1
d186 1
a186 1
   if (ctx->Line.Width > 1.0) {					\
d197 3
a199 2
_swrast_add_spec_terms_line(struct gl_context *ctx,
                            const SWvertex *v0, const SWvertex *v1)
d203 18
a220 2
   GLfloat rSum, gSum, bSum;
   GLchan cSave[2][4];
d222 13
a234 22
   /* save original colors */
   COPY_CHAN4(cSave[0], ncv0->color);
   COPY_CHAN4(cSave[1], ncv1->color);
   /* sum v0 */
   rSum = CHAN_TO_FLOAT(ncv0->color[0]) + ncv0->attrib[FRAG_ATTRIB_COL1][0];
   gSum = CHAN_TO_FLOAT(ncv0->color[1]) + ncv0->attrib[FRAG_ATTRIB_COL1][1];
   bSum = CHAN_TO_FLOAT(ncv0->color[2]) + ncv0->attrib[FRAG_ATTRIB_COL1][2];
   UNCLAMPED_FLOAT_TO_CHAN(ncv0->color[0], rSum);
   UNCLAMPED_FLOAT_TO_CHAN(ncv0->color[1], gSum);
   UNCLAMPED_FLOAT_TO_CHAN(ncv0->color[2], bSum);
   /* sum v1 */
   rSum = CHAN_TO_FLOAT(ncv1->color[0]) + ncv1->attrib[FRAG_ATTRIB_COL1][0];
   gSum = CHAN_TO_FLOAT(ncv1->color[1]) + ncv1->attrib[FRAG_ATTRIB_COL1][1];
   bSum = CHAN_TO_FLOAT(ncv1->color[2]) + ncv1->attrib[FRAG_ATTRIB_COL1][2];
   UNCLAMPED_FLOAT_TO_CHAN(ncv1->color[0], rSum);
   UNCLAMPED_FLOAT_TO_CHAN(ncv1->color[1], gSum);
   UNCLAMPED_FLOAT_TO_CHAN(ncv1->color[2], bSum);
   /* draw */
   SWRAST_CONTEXT(ctx)->SpecLine( ctx, ncv0, ncv1 );
   /* restore original colors */
   COPY_CHAN4( ncv0->attrib[FRAG_ATTRIB_COL0], cSave[0] );
   COPY_CHAN4( ncv1->attrib[FRAG_ATTRIB_COL0], cSave[1] );
d236 1
d248 1
a248 1
    /*printf("%s\n", lineFuncName);*/   \
d260 1
a260 1
/**
d268 1
a268 1
_swrast_choose_line( struct gl_context *ctx )
d271 1
a271 3
   GLboolean specular = (ctx->Fog.ColorSumEnabled ||
                         (ctx->Light.Enabled &&
                          ctx->Light.Model.ColorControl == GL_SEPARATE_SPECULAR_COLOR));
d280 3
a282 4
               || ctx->FragmentProgram._Current
               || swrast->_FogEnabled
               || specular) {
         USE(general_line);
d284 1
a284 2
      else if (ctx->Depth.Test
               || ctx->Line.Width != 1.0
d287 4
a290 5
#if CHAN_BITS == 32
         USE(general_line);
#else
         USE(rgba_line);
#endif
d293 5
a297 4
         ASSERT(!ctx->Depth.Test);
         ASSERT(ctx->Line.Width == 1.0);
         /* simple lines */
         USE(simple_no_z_rgba_line);
d307 2
@


1.1.1.5
log
@Import Mesa 9.2.0
@
text
@d3 1
d20 3
a22 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
d70 1
a70 1
   ASSERT(span->end < SWRAST_MAX_WIDTH);
d175 3
a177 3
   rSum = CHAN_TO_FLOAT(ncv0->color[0]) + ncv0->attrib[VARYING_SLOT_COL1][0];
   gSum = CHAN_TO_FLOAT(ncv0->color[1]) + ncv0->attrib[VARYING_SLOT_COL1][1];
   bSum = CHAN_TO_FLOAT(ncv0->color[2]) + ncv0->attrib[VARYING_SLOT_COL1][2];
d182 3
a184 3
   rSum = CHAN_TO_FLOAT(ncv1->color[0]) + ncv1->attrib[VARYING_SLOT_COL1][0];
   gSum = CHAN_TO_FLOAT(ncv1->color[1]) + ncv1->attrib[VARYING_SLOT_COL1][1];
   bSum = CHAN_TO_FLOAT(ncv1->color[2]) + ncv1->attrib[VARYING_SLOT_COL1][2];
d191 2
a192 2
   COPY_CHAN4(ncv0->color, cSave[0]);
   COPY_CHAN4(ncv1->color, cSave[1]);
d239 1
a239 1
               || _swrast_use_fragment_program(ctx)
@


