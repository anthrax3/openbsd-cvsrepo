head	1.10;
access;
symbols
	OPENBSD_5_8:1.9.0.6
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.4
	OPENBSD_5_7_BASE:1.9
	v10_2_9:1.1.1.6
	v10_4_3:1.1.1.6
	v10_2_7:1.1.1.6
	OPENBSD_5_6:1.9.0.2
	OPENBSD_5_6_BASE:1.9
	v10_2_3:1.1.1.6
	OPENBSD_5_5:1.8.0.2
	OPENBSD_5_5_BASE:1.8
	v9_2_5:1.1.1.5
	v9_2_3:1.1.1.5
	v9_2_2:1.1.1.5
	v9_2_1:1.1.1.5
	v9_2_0:1.1.1.5
	OPENBSD_5_4:1.7.0.4
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.6.0.4
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.5.0.6
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2015.12.23.05.17.55;	author jsg;	state dead;
branches;
next	1.9;
commitid	TnlogFl9nOv2eaRf;

1.9
date	2014.07.09.21.09.01;	author jsg;	state Exp;
branches;
next	1.8;
commitid	WPD6rgPryPkvXOr9;

1.8
date	2013.09.05.14.06.48;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2012.08.17.13.58.20;	author mpi;	state Exp;
branches;
next	1.6;

1.6
date	2011.10.23.13.37.45;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.05.22.20.06.34;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.05.17.20.26.42;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.14.58.23;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.05.31.16.36.49;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.51.18;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.51.18;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.56.49;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.32.07;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.48;	author matthieu;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.09.05.13.17.29;	author jsg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.07.09.20.35.12;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.10
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2008  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Authors:
 *    Keith Whitwell <keithw@@vmware.com> Brian Paul
 */

#include "main/imports.h"
#include "main/bufferobj.h"
#include "main/colormac.h"
#include "main/mtypes.h"
#include "main/samplerobj.h"
#include "main/teximage.h"
#include "program/prog_parameter.h"
#include "program/prog_statevars.h"
#include "swrast.h"
#include "s_blend.h"
#include "s_context.h"
#include "s_lines.h"
#include "s_points.h"
#include "s_span.h"
#include "s_texfetch.h"
#include "s_triangle.h"
#include "s_texfilter.h"


/**
 * Recompute the value of swrast->_RasterMask, etc. according to
 * the current context.  The _RasterMask field can be easily tested by
 * drivers to determine certain basic GL state (does the primitive need
 * stenciling, logic-op, fog, etc?).
 */
static void
_swrast_update_rasterflags( struct gl_context *ctx )
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
   GLbitfield rasterMask = 0;
   GLuint i;

   if (ctx->Color.AlphaEnabled)           rasterMask |= ALPHATEST_BIT;
   if (ctx->Color.BlendEnabled)           rasterMask |= BLEND_BIT;
   if (ctx->Depth.Test)                   rasterMask |= DEPTH_BIT;
   if (swrast->_FogEnabled)               rasterMask |= FOG_BIT;
   if (ctx->Scissor.EnableFlags)          rasterMask |= CLIP_BIT;
   if (ctx->Stencil._Enabled)             rasterMask |= STENCIL_BIT;
   for (i = 0; i < ctx->Const.MaxDrawBuffers; i++) {
      if (!ctx->Color.ColorMask[i][0] ||
          !ctx->Color.ColorMask[i][1] ||
          !ctx->Color.ColorMask[i][2] ||
          !ctx->Color.ColorMask[i][3]) {
         rasterMask |= MASKING_BIT;
         break;
      }
   }
   if (ctx->Color.ColorLogicOpEnabled) rasterMask |= LOGIC_OP_BIT;
   if (ctx->Texture._MaxEnabledTexImageUnit >= 0) rasterMask |= TEXTURE_BIT;
   if (   ctx->ViewportArray[0].X < 0
       || ctx->ViewportArray[0].X + ctx->ViewportArray[0].Width > (GLfloat) ctx->DrawBuffer->Width
       || ctx->ViewportArray[0].Y < 0
       || ctx->ViewportArray[0].Y + ctx->ViewportArray[0].Height > (GLfloat) ctx->DrawBuffer->Height) {
      rasterMask |= CLIP_BIT;
   }

   if (ctx->Query.CurrentOcclusionObject)
      rasterMask |= OCCLUSION_BIT;


   /* If we're not drawing to exactly one color buffer set the
    * MULTI_DRAW_BIT flag.  Also set it if we're drawing to no
    * buffers or the RGBA or CI mask disables all writes.
    */
   if (ctx->DrawBuffer->_NumColorDrawBuffers != 1) {
      /* more than one color buffer designated for writing (or zero buffers) */
      rasterMask |= MULTI_DRAW_BIT;
   }

   for (i = 0; i < ctx->Const.MaxDrawBuffers; i++) {
      if (ctx->Color.ColorMask[i][0] +
          ctx->Color.ColorMask[i][1] +
          ctx->Color.ColorMask[i][2] +
          ctx->Color.ColorMask[i][3] == 0) {
         rasterMask |= MULTI_DRAW_BIT; /* all RGBA channels disabled */
         break;
      }
   }


   if (_swrast_use_fragment_program(ctx)) {
      rasterMask |= FRAGPROG_BIT;
   }

   if (ctx->ATIFragmentShader._Enabled) {
      rasterMask |= ATIFRAGSHADER_BIT;
   }

#if CHAN_TYPE == GL_FLOAT
   if (ctx->Color.ClampFragmentColor == GL_TRUE) {
      rasterMask |= CLAMPING_BIT;
   }
#endif

   SWRAST_CONTEXT(ctx)->_RasterMask = rasterMask;
}


/**
 * Examine polygon cull state to compute the _BackfaceCullSign field.
 * _BackfaceCullSign will be 0 if no culling, -1 if culling back-faces,
 * and 1 if culling front-faces.  The Polygon FrontFace state also
 * factors in.
 */
static void
_swrast_update_polygon( struct gl_context *ctx )
{
   GLfloat backface_sign;

   if (ctx->Polygon.CullFlag) {
      switch (ctx->Polygon.CullFaceMode) {
      case GL_BACK:
         backface_sign = -1.0F;
	 break;
      case GL_FRONT:
         backface_sign = 1.0F;
	 break;
      case GL_FRONT_AND_BACK:
         /* fallthrough */
      default:
	 backface_sign = 0.0F;
      }
   }
   else {
      backface_sign = 0.0F;
   }

   SWRAST_CONTEXT(ctx)->_BackfaceCullSign = backface_sign;

   /* This is for front/back-face determination, but not for culling */
   SWRAST_CONTEXT(ctx)->_BackfaceSign
      = (ctx->Polygon.FrontFace == GL_CW) ? -1.0F : 1.0F;
}



/**
 * Update the _PreferPixelFog field to indicate if we need to compute
 * fog blend factors (from the fog coords) per-fragment.
 */
static void
_swrast_update_fog_hint( struct gl_context *ctx )
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
   swrast->_PreferPixelFog = (!swrast->AllowVertexFog ||
			      _swrast_use_fragment_program(ctx) ||
			      (ctx->Hint.Fog == GL_NICEST &&
			       swrast->AllowPixelFog));
}



/**
 * Update the swrast->_TextureCombinePrimary flag.
 */
static void
_swrast_update_texture_env( struct gl_context *ctx )
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
   GLuint i;

   swrast->_TextureCombinePrimary = GL_FALSE;

   for (i = 0; i < ctx->Const.MaxTextureUnits; i++) {
      const struct gl_tex_env_combine_state *combine =
         ctx->Texture.Unit[i]._CurrentCombine;
      GLuint term;
      for (term = 0; term < combine->_NumArgsRGB; term++) {
         if (combine->SourceRGB[term] == GL_PRIMARY_COLOR) {
            swrast->_TextureCombinePrimary = GL_TRUE;
            return;
         }
         if (combine->SourceA[term] == GL_PRIMARY_COLOR) {
            swrast->_TextureCombinePrimary = GL_TRUE;
            return;
         }
      }
   }
}


/**
 * Determine if we can defer texturing/shading until after Z/stencil
 * testing.  This potentially allows us to skip texturing/shading for
 * lots of fragments.
 */
static void
_swrast_update_deferred_texture(struct gl_context *ctx)
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
   if (ctx->Color.AlphaEnabled) {
      /* alpha test depends on post-texture/shader colors */
      swrast->_DeferredTexture = GL_FALSE;
   }
   else {
      GLboolean use_fprog = _swrast_use_fragment_program(ctx);
      const struct gl_fragment_program *fprog
         = ctx->FragmentProgram._Current;
      if (use_fprog && (fprog->Base.OutputsWritten & (1 << FRAG_RESULT_DEPTH))) {
         /* Z comes from fragment program/shader */
         swrast->_DeferredTexture = GL_FALSE;
      }
      else if (use_fprog && fprog->UsesKill) {
         swrast->_DeferredTexture = GL_FALSE;
      }
      else if (ctx->Query.CurrentOcclusionObject) {
         /* occlusion query depends on shader discard/kill results */
         swrast->_DeferredTexture = GL_FALSE;
      }
      else {
         swrast->_DeferredTexture = GL_TRUE;
      }
   }
}


/**
 * Update swrast->_FogColor and swrast->_FogEnable values.
 */
static void
_swrast_update_fog_state( struct gl_context *ctx )
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
   const struct gl_fragment_program *fp = ctx->FragmentProgram._Current;

   assert(fp == NULL || fp->Base.Target == GL_FRAGMENT_PROGRAM_ARB);

   /* determine if fog is needed, and if so, which fog mode */
   swrast->_FogEnabled = (!_swrast_use_fragment_program(ctx) &&
			  ctx->Fog.Enabled);
}


/**
 * Update state for running fragment programs.  Basically, load the
 * program parameters with current state values.
 */
static void
_swrast_update_fragment_program(struct gl_context *ctx, GLbitfield newState)
{
   if (!_swrast_use_fragment_program(ctx))
      return;

   _mesa_load_state_parameters(ctx,
                               ctx->FragmentProgram._Current->Base.Parameters);
}


/**
 * See if we can do early diffuse+specular (primary+secondary) color
 * add per vertex instead of per-fragment.
 */
static void
_swrast_update_specular_vertex_add(struct gl_context *ctx)
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
   GLboolean separateSpecular = ctx->Fog.ColorSumEnabled ||
      (ctx->Light.Enabled &&
       ctx->Light.Model.ColorControl == GL_SEPARATE_SPECULAR_COLOR);

   swrast->SpecularVertexAdd = (separateSpecular
                                && ctx->Texture._MaxEnabledTexImageUnit == -1
                                && !_swrast_use_fragment_program(ctx)
                                && !ctx->ATIFragmentShader._Enabled);
}


#define _SWRAST_NEW_DERIVED (_SWRAST_NEW_RASTERMASK |	\
                             _NEW_PROGRAM_CONSTANTS |   \
			     _NEW_TEXTURE |		\
			     _NEW_HINT |		\
			     _NEW_POLYGON )

/* State referenced by _swrast_choose_triangle, _swrast_choose_line.
 */
#define _SWRAST_NEW_TRIANGLE (_SWRAST_NEW_DERIVED |		\
			      _NEW_RENDERMODE|			\
                              _NEW_POLYGON|			\
                              _NEW_DEPTH|			\
                              _NEW_STENCIL|			\
                              _NEW_COLOR|			\
                              _NEW_TEXTURE|			\
                              _SWRAST_NEW_RASTERMASK|		\
                              _NEW_LIGHT|			\
                              _NEW_FOG |			\
			      _MESA_NEW_SEPARATE_SPECULAR)

#define _SWRAST_NEW_LINE (_SWRAST_NEW_DERIVED |		\
			  _NEW_RENDERMODE|		\
                          _NEW_LINE|			\
                          _NEW_TEXTURE|			\
                          _NEW_LIGHT|			\
                          _NEW_FOG|			\
                          _NEW_DEPTH |			\
                          _MESA_NEW_SEPARATE_SPECULAR)

#define _SWRAST_NEW_POINT (_SWRAST_NEW_DERIVED |	\
			   _NEW_RENDERMODE |		\
			   _NEW_POINT |			\
			   _NEW_TEXTURE |		\
			   _NEW_LIGHT |			\
			   _NEW_FOG |			\
                           _MESA_NEW_SEPARATE_SPECULAR)

#define _SWRAST_NEW_TEXTURE_SAMPLE_FUNC _NEW_TEXTURE

#define _SWRAST_NEW_TEXTURE_ENV_MODE _NEW_TEXTURE

#define _SWRAST_NEW_BLEND_FUNC _NEW_COLOR



/**
 * Stub for swrast->Triangle to select a true triangle function
 * after a state change.
 */
static void
_swrast_validate_triangle( struct gl_context *ctx,
			   const SWvertex *v0,
                           const SWvertex *v1,
                           const SWvertex *v2 )
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);

   _swrast_validate_derived( ctx );
   swrast->choose_triangle( ctx );
   ASSERT(swrast->Triangle);

   if (swrast->SpecularVertexAdd) {
      /* separate specular color, but no texture */
      swrast->SpecTriangle = swrast->Triangle;
      swrast->Triangle = _swrast_add_spec_terms_triangle;
   }

   swrast->Triangle( ctx, v0, v1, v2 );
}

/**
 * Called via swrast->Line.  Examine current GL state and choose a software
 * line routine.  Then call it.
 */
static void
_swrast_validate_line( struct gl_context *ctx, const SWvertex *v0, const SWvertex *v1 )
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);

   _swrast_validate_derived( ctx );
   swrast->choose_line( ctx );
   ASSERT(swrast->Line);

   if (swrast->SpecularVertexAdd) {
      swrast->SpecLine = swrast->Line;
      swrast->Line = _swrast_add_spec_terms_line;
   }

   swrast->Line( ctx, v0, v1 );
}

/**
 * Called via swrast->Point.  Examine current GL state and choose a software
 * point routine.  Then call it.
 */
static void
_swrast_validate_point( struct gl_context *ctx, const SWvertex *v0 )
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);

   _swrast_validate_derived( ctx );
   swrast->choose_point( ctx );

   if (swrast->SpecularVertexAdd) {
      swrast->SpecPoint = swrast->Point;
      swrast->Point = _swrast_add_spec_terms_point;
   }

   swrast->Point( ctx, v0 );
}


/**
 * Called via swrast->BlendFunc.  Examine GL state to choose a blending
 * function, then call it.
 */
static void _ASMAPI
_swrast_validate_blend_func(struct gl_context *ctx, GLuint n, const GLubyte mask[],
                            GLvoid *src, const GLvoid *dst,
                            GLenum chanType )
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);

   _swrast_validate_derived( ctx ); /* why is this needed? */
   _swrast_choose_blend_func( ctx, chanType );

   swrast->BlendFunc( ctx, n, mask, src, dst, chanType );
}

static void
_swrast_sleep( struct gl_context *ctx, GLbitfield new_state )
{
   (void) ctx; (void) new_state;
}


static void
_swrast_invalidate_state( struct gl_context *ctx, GLbitfield new_state )
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
   GLuint i;

   swrast->NewState |= new_state;

   /* After 10 statechanges without any swrast functions being called,
    * put the module to sleep.
    */
   if (++swrast->StateChanges > 10) {
      swrast->InvalidateState = _swrast_sleep;
      swrast->NewState = ~0;
      new_state = ~0;
   }

   if (new_state & swrast->InvalidateTriangleMask)
      swrast->Triangle = _swrast_validate_triangle;

   if (new_state & swrast->InvalidateLineMask)
      swrast->Line = _swrast_validate_line;

   if (new_state & swrast->InvalidatePointMask)
      swrast->Point = _swrast_validate_point;

   if (new_state & _SWRAST_NEW_BLEND_FUNC)
      swrast->BlendFunc = _swrast_validate_blend_func;

   if (new_state & _SWRAST_NEW_TEXTURE_SAMPLE_FUNC)
      for (i = 0 ; i < ARRAY_SIZE(swrast->TextureSample); i++)
	 swrast->TextureSample[i] = NULL;
}


void
_swrast_update_texture_samplers(struct gl_context *ctx)
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
   GLuint u;

   if (!swrast)
      return; /* pipe hack */

   for (u = 0; u < ARRAY_SIZE(swrast->TextureSample); u++) {
      struct gl_texture_object *tObj = ctx->Texture.Unit[u]._Current;
      /* Note: If tObj is NULL, the sample function will be a simple
       * function that just returns opaque black (0,0,0,1).
       */
      _mesa_update_fetch_functions(ctx, u);
      swrast->TextureSample[u] =
         _swrast_choose_texture_sample_func(ctx, tObj,
                                            _mesa_get_samplerobj(ctx, u));
   }
}


/**
 * Update swrast->_ActiveAttribs, swrast->_NumActiveAttribs,
 * swrast->_ActiveAtttribMask.
 */
static void
_swrast_update_active_attribs(struct gl_context *ctx)
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
   GLbitfield64 attribsMask;

   /*
    * Compute _ActiveAttribsMask = which fragment attributes are needed.
    */
   if (_swrast_use_fragment_program(ctx)) {
      /* fragment program/shader */
      attribsMask = ctx->FragmentProgram._Current->Base.InputsRead;
      attribsMask &= ~VARYING_BIT_POS; /* WPOS is always handled specially */
   }
   else if (ctx->ATIFragmentShader._Enabled) {
      attribsMask = ~0;  /* XXX fix me */
   }
   else {
      /* fixed function */
      attribsMask = 0x0;

#if CHAN_TYPE == GL_FLOAT
      attribsMask |= VARYING_BIT_COL0;
#endif

      if (ctx->Fog.ColorSumEnabled ||
          (ctx->Light.Enabled &&
           ctx->Light.Model.ColorControl == GL_SEPARATE_SPECULAR_COLOR)) {
         attribsMask |= VARYING_BIT_COL1;
      }

      if (swrast->_FogEnabled)
         attribsMask |= VARYING_BIT_FOGC;

      attribsMask |= (ctx->Texture._EnabledCoordUnits << VARYING_SLOT_TEX0);
   }

   swrast->_ActiveAttribMask = attribsMask;

   /* Update _ActiveAttribs[] list */
   {
      GLuint i, num = 0;
      for (i = 0; i < VARYING_SLOT_MAX; i++) {
         if (attribsMask & BITFIELD64_BIT(i)) {
            swrast->_ActiveAttribs[num++] = i;
            /* how should this attribute be interpolated? */
            if (i == VARYING_SLOT_COL0 || i == VARYING_SLOT_COL1)
               swrast->_InterpMode[i] = ctx->Light.ShadeModel;
            else
               swrast->_InterpMode[i] = GL_SMOOTH;
         }
      }
      swrast->_NumActiveAttribs = num;
   }
}


void
_swrast_validate_derived( struct gl_context *ctx )
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);

   if (swrast->NewState) {
      if (swrast->NewState & _NEW_POLYGON)
	 _swrast_update_polygon( ctx );

      if (swrast->NewState & (_NEW_HINT | _NEW_PROGRAM))
	 _swrast_update_fog_hint( ctx );

      if (swrast->NewState & _SWRAST_NEW_TEXTURE_ENV_MODE)
	 _swrast_update_texture_env( ctx );

      if (swrast->NewState & (_NEW_FOG | _NEW_PROGRAM))
         _swrast_update_fog_state( ctx );

      if (swrast->NewState & (_NEW_PROGRAM_CONSTANTS | _NEW_PROGRAM))
	 _swrast_update_fragment_program( ctx, swrast->NewState );

      if (swrast->NewState & (_NEW_TEXTURE | _NEW_PROGRAM)) {
         _swrast_update_texture_samplers( ctx );
      }

      if (swrast->NewState & (_NEW_COLOR | _NEW_PROGRAM))
         _swrast_update_deferred_texture(ctx);

      if (swrast->NewState & _SWRAST_NEW_RASTERMASK)
 	 _swrast_update_rasterflags( ctx );

      if (swrast->NewState & (_NEW_DEPTH |
                              _NEW_FOG |
                              _NEW_LIGHT |
                              _NEW_PROGRAM |
                              _NEW_TEXTURE))
         _swrast_update_active_attribs(ctx);

      if (swrast->NewState & (_NEW_FOG | 
                              _NEW_PROGRAM |
                              _NEW_LIGHT |
                              _NEW_TEXTURE))
         _swrast_update_specular_vertex_add(ctx);

      swrast->NewState = 0;
      swrast->StateChanges = 0;
      swrast->InvalidateState = _swrast_invalidate_state;
   }
}

#define SWRAST_DEBUG 0

/* Public entrypoints:  See also s_bitmap.c, etc.
 */
void
_swrast_Quad( struct gl_context *ctx,
	      const SWvertex *v0, const SWvertex *v1,
              const SWvertex *v2, const SWvertex *v3 )
{
   if (SWRAST_DEBUG) {
      _mesa_debug(ctx, "_swrast_Quad\n");
      _swrast_print_vertex( ctx, v0 );
      _swrast_print_vertex( ctx, v1 );
      _swrast_print_vertex( ctx, v2 );
      _swrast_print_vertex( ctx, v3 );
   }
   SWRAST_CONTEXT(ctx)->Triangle( ctx, v0, v1, v3 );
   SWRAST_CONTEXT(ctx)->Triangle( ctx, v1, v2, v3 );
}

void
_swrast_Triangle( struct gl_context *ctx, const SWvertex *v0,
                  const SWvertex *v1, const SWvertex *v2 )
{
   if (SWRAST_DEBUG) {
      _mesa_debug(ctx, "_swrast_Triangle\n");
      _swrast_print_vertex( ctx, v0 );
      _swrast_print_vertex( ctx, v1 );
      _swrast_print_vertex( ctx, v2 );
   }
   SWRAST_CONTEXT(ctx)->Triangle( ctx, v0, v1, v2 );
}

void
_swrast_Line( struct gl_context *ctx, const SWvertex *v0, const SWvertex *v1 )
{
   if (SWRAST_DEBUG) {
      _mesa_debug(ctx, "_swrast_Line\n");
      _swrast_print_vertex( ctx, v0 );
      _swrast_print_vertex( ctx, v1 );
   }
   SWRAST_CONTEXT(ctx)->Line( ctx, v0, v1 );
}

void
_swrast_Point( struct gl_context *ctx, const SWvertex *v0 )
{
   if (SWRAST_DEBUG) {
      _mesa_debug(ctx, "_swrast_Point\n");
      _swrast_print_vertex( ctx, v0 );
   }
   SWRAST_CONTEXT(ctx)->Point( ctx, v0 );
}

void
_swrast_InvalidateState( struct gl_context *ctx, GLbitfield new_state )
{
   if (SWRAST_DEBUG) {
      _mesa_debug(ctx, "_swrast_InvalidateState\n");
   }
   SWRAST_CONTEXT(ctx)->InvalidateState( ctx, new_state );
}

void
_swrast_ResetLineStipple( struct gl_context *ctx )
{
   if (SWRAST_DEBUG) {
      _mesa_debug(ctx, "_swrast_ResetLineStipple\n");
   }
   SWRAST_CONTEXT(ctx)->StippleCounter = 0;
}

void
_swrast_SetFacing(struct gl_context *ctx, GLuint facing)
{
   SWRAST_CONTEXT(ctx)->PointLineFacing = facing;
}

void
_swrast_allow_vertex_fog( struct gl_context *ctx, GLboolean value )
{
   if (SWRAST_DEBUG) {
      _mesa_debug(ctx, "_swrast_allow_vertex_fog %d\n", value);
   }
   SWRAST_CONTEXT(ctx)->InvalidateState( ctx, _NEW_HINT );
   SWRAST_CONTEXT(ctx)->AllowVertexFog = value;
}

void
_swrast_allow_pixel_fog( struct gl_context *ctx, GLboolean value )
{
   if (SWRAST_DEBUG) {
      _mesa_debug(ctx, "_swrast_allow_pixel_fog %d\n", value);
   }
   SWRAST_CONTEXT(ctx)->InvalidateState( ctx, _NEW_HINT );
   SWRAST_CONTEXT(ctx)->AllowPixelFog = value;
}


/**
 * Initialize native program limits by copying the logical limits.
 * See comments in init_program_limits() in context.c
 */
static void
init_program_native_limits(struct gl_program_constants *prog)
{
   prog->MaxNativeInstructions = prog->MaxInstructions;
   prog->MaxNativeAluInstructions = prog->MaxAluInstructions;
   prog->MaxNativeTexInstructions = prog->MaxTexInstructions;
   prog->MaxNativeTexIndirections = prog->MaxTexIndirections;
   prog->MaxNativeAttribs = prog->MaxAttribs;
   prog->MaxNativeTemps = prog->MaxTemps;
   prog->MaxNativeAddressRegs = prog->MaxAddressRegs;
   prog->MaxNativeParameters = prog->MaxParameters;
}


GLboolean
_swrast_CreateContext( struct gl_context *ctx )
{
   GLuint i;
   SWcontext *swrast = calloc(1, sizeof(SWcontext));
#ifdef _OPENMP
   const GLuint maxThreads = omp_get_max_threads();
#else
   const GLuint maxThreads = 1;
#endif

   assert(ctx->Const.MaxViewportWidth <= SWRAST_MAX_WIDTH);
   assert(ctx->Const.MaxViewportHeight <= SWRAST_MAX_WIDTH);

   assert(ctx->Const.MaxRenderbufferSize <= SWRAST_MAX_WIDTH);

   /* make sure largest texture image is <= SWRAST_MAX_WIDTH in size */
   assert((1 << (ctx->Const.MaxTextureLevels - 1)) <= SWRAST_MAX_WIDTH);
   assert((1 << (ctx->Const.MaxCubeTextureLevels - 1)) <= SWRAST_MAX_WIDTH);
   assert((1 << (ctx->Const.Max3DTextureLevels - 1)) <= SWRAST_MAX_WIDTH);

   assert(PROG_MAX_WIDTH == SWRAST_MAX_WIDTH);

   if (SWRAST_DEBUG) {
      _mesa_debug(ctx, "_swrast_CreateContext\n");
   }

   if (!swrast)
      return GL_FALSE;

   swrast->NewState = ~0;

   swrast->choose_point = _swrast_choose_point;
   swrast->choose_line = _swrast_choose_line;
   swrast->choose_triangle = _swrast_choose_triangle;

   swrast->InvalidatePointMask = _SWRAST_NEW_POINT;
   swrast->InvalidateLineMask = _SWRAST_NEW_LINE;
   swrast->InvalidateTriangleMask = _SWRAST_NEW_TRIANGLE;

   swrast->Point = _swrast_validate_point;
   swrast->Line = _swrast_validate_line;
   swrast->Triangle = _swrast_validate_triangle;
   swrast->InvalidateState = _swrast_sleep;
   swrast->BlendFunc = _swrast_validate_blend_func;

   swrast->AllowVertexFog = GL_TRUE;
   swrast->AllowPixelFog = GL_TRUE;

   swrast->Driver.SpanRenderStart = _swrast_span_render_start;
   swrast->Driver.SpanRenderFinish = _swrast_span_render_finish;

   for (i = 0; i < ARRAY_SIZE(swrast->TextureSample); i++)
      swrast->TextureSample[i] = NULL;

   /* SpanArrays is global and shared by all SWspan instances. However, when
    * using multiple threads, it is necessary to have one SpanArrays instance
    * per thread.
    */
   swrast->SpanArrays = malloc(maxThreads * sizeof(SWspanarrays));
   if (!swrast->SpanArrays) {
      free(swrast);
      return GL_FALSE;
   }
   for(i = 0; i < maxThreads; i++) {
      swrast->SpanArrays[i].ChanType = CHAN_TYPE;
#if CHAN_TYPE == GL_UNSIGNED_BYTE
      swrast->SpanArrays[i].rgba = swrast->SpanArrays[i].rgba8;
#elif CHAN_TYPE == GL_UNSIGNED_SHORT
      swrast->SpanArrays[i].rgba = swrast->SpanArrays[i].rgba16;
#else
      swrast->SpanArrays[i].rgba = swrast->SpanArrays[i].attribs[VARYING_SLOT_COL0];
#endif
   }

   /* init point span buffer */
   swrast->PointSpan.primitive = GL_POINT;
   swrast->PointSpan.end = 0;
   swrast->PointSpan.facing = 0;
   swrast->PointSpan.array = swrast->SpanArrays;

   init_program_native_limits(&ctx->Const.Program[MESA_SHADER_VERTEX]);
   init_program_native_limits(&ctx->Const.Program[MESA_SHADER_GEOMETRY]);
   init_program_native_limits(&ctx->Const.Program[MESA_SHADER_FRAGMENT]);

   ctx->swrast_context = swrast;

   swrast->stencil_temp.buf1 = malloc(SWRAST_MAX_WIDTH * sizeof(GLubyte));
   swrast->stencil_temp.buf2 = malloc(SWRAST_MAX_WIDTH * sizeof(GLubyte));
   swrast->stencil_temp.buf3 = malloc(SWRAST_MAX_WIDTH * sizeof(GLubyte));
   swrast->stencil_temp.buf4 = malloc(SWRAST_MAX_WIDTH * sizeof(GLubyte));

   if (!swrast->stencil_temp.buf1 ||
       !swrast->stencil_temp.buf2 ||
       !swrast->stencil_temp.buf3 ||
       !swrast->stencil_temp.buf4) {
      _swrast_DestroyContext(ctx);
      return GL_FALSE;
   }

   return GL_TRUE;
}

void
_swrast_DestroyContext( struct gl_context *ctx )
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);

   if (SWRAST_DEBUG) {
      _mesa_debug(ctx, "_swrast_DestroyContext\n");
   }

   free( swrast->SpanArrays );
   free( swrast->ZoomedArrays );
   free( swrast->TexelBuffer );

   free(swrast->stencil_temp.buf1);
   free(swrast->stencil_temp.buf2);
   free(swrast->stencil_temp.buf3);
   free(swrast->stencil_temp.buf4);

   free( swrast );

   ctx->swrast_context = 0;
}


struct swrast_device_driver *
_swrast_GetDeviceDriverReference( struct gl_context *ctx )
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
   return &swrast->Driver;
}

void
_swrast_flush( struct gl_context *ctx )
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
   /* flush any pending fragments from rendering points */
   if (swrast->PointSpan.end > 0) {
      _swrast_write_rgba_span(ctx, &(swrast->PointSpan));
      swrast->PointSpan.end = 0;
   }
}

void
_swrast_render_primitive( struct gl_context *ctx, GLenum prim )
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
   if (swrast->Primitive == GL_POINTS && prim != GL_POINTS) {
      _swrast_flush(ctx);
   }
   swrast->Primitive = prim;
}


/** called via swrast->Driver.SpanRenderStart() */
void
_swrast_span_render_start(struct gl_context *ctx)
{
   _swrast_map_textures(ctx);
   _swrast_map_renderbuffers(ctx);
}


/** called via swrast->Driver.SpanRenderFinish() */
void
_swrast_span_render_finish(struct gl_context *ctx)
{
   _swrast_unmap_textures(ctx);
   _swrast_unmap_renderbuffers(ctx);
}


void
_swrast_render_start( struct gl_context *ctx )
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
   if (swrast->Driver.SpanRenderStart)
      swrast->Driver.SpanRenderStart( ctx );
   swrast->PointSpan.end = 0;
}
 
void
_swrast_render_finish( struct gl_context *ctx )
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);

   _swrast_flush(ctx);

   if (swrast->Driver.SpanRenderFinish)
      swrast->Driver.SpanRenderFinish( ctx );
}


#define SWRAST_DEBUG_VERTICES 0

void
_swrast_print_vertex( struct gl_context *ctx, const SWvertex *v )
{
   GLuint i;

   if (SWRAST_DEBUG_VERTICES) {
      _mesa_debug(ctx, "win %f %f %f %f\n",
                  v->attrib[VARYING_SLOT_POS][0],
                  v->attrib[VARYING_SLOT_POS][1],
                  v->attrib[VARYING_SLOT_POS][2],
                  v->attrib[VARYING_SLOT_POS][3]);

      for (i = 0 ; i < ctx->Const.MaxTextureCoordUnits ; i++)
	 if (ctx->Texture.Unit[i]._Current)
	    _mesa_debug(ctx, "texcoord[%d] %f %f %f %f\n", i,
                        v->attrib[VARYING_SLOT_TEX0 + i][0],
                        v->attrib[VARYING_SLOT_TEX0 + i][1],
                        v->attrib[VARYING_SLOT_TEX0 + i][2],
                        v->attrib[VARYING_SLOT_TEX0 + i][3]);

#if CHAN_TYPE == GL_FLOAT
      _mesa_debug(ctx, "color %f %f %f %f\n",
                  v->color[0], v->color[1], v->color[2], v->color[3]);
#else
      _mesa_debug(ctx, "color %d %d %d %d\n",
                  v->color[0], v->color[1], v->color[2], v->color[3]);
#endif
      _mesa_debug(ctx, "spec %g %g %g %g\n",
                  v->attrib[VARYING_SLOT_COL1][0],
                  v->attrib[VARYING_SLOT_COL1][1],
                  v->attrib[VARYING_SLOT_COL1][2],
                  v->attrib[VARYING_SLOT_COL1][3]);
      _mesa_debug(ctx, "fog %f\n", v->attrib[VARYING_SLOT_FOGC][0]);
      _mesa_debug(ctx, "index %f\n", v->attrib[VARYING_SLOT_CI][0]);
      _mesa_debug(ctx, "pointsize %f\n", v->pointSize);
      _mesa_debug(ctx, "\n");
   }
}
@


1.9
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.8
log
@Merge Mesa 9.2.0
@
text
@d25 1
a25 1
 *    Keith Whitwell <keith@@tungstengraphics.com> Brian Paul
d64 1
a64 1
   if (ctx->Scissor.Enabled)              rasterMask |= CLIP_BIT;
d76 5
a80 5
   if (ctx->Texture._EnabledUnits)     rasterMask |= TEXTURE_BIT;
   if (   ctx->Viewport.X < 0
       || ctx->Viewport.X + ctx->Viewport.Width > (GLint) ctx->DrawBuffer->Width
       || ctx->Viewport.Y < 0
       || ctx->Viewport.Y + ctx->Viewport.Height > (GLint) ctx->DrawBuffer->Height) {
d289 1
a289 1
                                && ctx->Texture._EnabledUnits == 0x0
d526 1
a526 1
      attribsMask |= (ctx->Texture._EnabledUnits << VARYING_SLOT_TEX0);
d797 3
a799 3
   init_program_native_limits(&ctx->Const.VertexProgram);
   init_program_native_limits(&ctx->Const.GeometryProgram);
   init_program_native_limits(&ctx->Const.FragmentProgram);
d926 1
a926 1
	 if (ctx->Texture.Unit[i]._ReallyEnabled)
@


1.7
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a2 1
 * Version:  7.1
d19 4
a22 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
d25 1
a25 2
 *    Keith Whitwell <keith@@tungstengraphics.com>
 *    Brian Paul
d32 1
d42 1
d75 1
a75 1
   if (ctx->Color._LogicOpEnabled)     rasterMask |= LOGIC_OP_BIT;
d108 1
a108 1
   if (ctx->FragmentProgram._Current) {
d173 1
a173 1
                              ctx->FragmentProgram._Current ||
d223 1
d226 1
a226 1
      if (fprog && (fprog->Base.OutputsWritten & (1 << FRAG_RESULT_DEPTH))) {
d230 1
a230 1
      else if (fprog && fprog->UsesKill) {
d253 1
a253 1
   assert((fp == NULL) || (fp->Base.Target == GL_FRAGMENT_PROGRAM_ARB));
d256 2
a257 1
   swrast->_FogEnabled = (fp == NULL && ctx->Fog.Enabled);
d268 5
a272 4
   const struct gl_fragment_program *fp = ctx->FragmentProgram._Current;
   if (fp) {
      _mesa_load_state_parameters(ctx, fp->Base.Parameters);
   }
d290 1
a290 1
                                && !ctx->FragmentProgram._Current
d313 1
a313 1
			      _DD_NEW_SEPARATE_SPECULAR)
d322 1
a322 1
                          _DD_NEW_SEPARATE_SPECULAR)
d330 1
a330 1
                           _DD_NEW_SEPARATE_SPECULAR)
a423 78

/**
 * Make sure we have texture image data for all the textures we may need
 * for subsequent rendering.
 */
static void
_swrast_validate_texture_images(struct gl_context *ctx)
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
   GLuint u;

   if (!swrast->ValidateTextureImage || !ctx->Texture._EnabledUnits) {
      /* no textures enabled, or no way to validate images! */
      return;
   }

   for (u = 0; u < ctx->Const.MaxTextureImageUnits; u++) {
      if (ctx->Texture.Unit[u]._ReallyEnabled) {
         struct gl_texture_object *texObj = ctx->Texture.Unit[u]._Current;
         ASSERT(texObj);
         if (texObj) {
            GLuint numFaces = (texObj->Target == GL_TEXTURE_CUBE_MAP) ? 6 : 1;
            GLuint face;
            for (face = 0; face < numFaces; face++) {
               GLint lvl;
               for (lvl = texObj->BaseLevel; lvl <= texObj->_MaxLevel; lvl++) {
                  struct gl_texture_image *texImg = texObj->Image[face][lvl];
                  if (texImg && !texImg->Data) {
                     swrast->ValidateTextureImage(ctx, texObj, face, lvl);
                     ASSERT(texObj->Image[face][lvl]->Data);
                  }
               }
            }
         }
      }
   }
}


/**
 * Free the texture image data attached to all currently enabled
 * textures.  Meant to be called by device drivers when transitioning
 * from software to hardware rendering.
 */
void
_swrast_eject_texture_images(struct gl_context *ctx)
{
   GLuint u;

   if (!ctx->Texture._EnabledUnits) {
      /* no textures enabled */
      return;
   }

   for (u = 0; u < ctx->Const.MaxTextureImageUnits; u++) {
      if (ctx->Texture.Unit[u]._ReallyEnabled) {
         struct gl_texture_object *texObj = ctx->Texture.Unit[u]._Current;
         ASSERT(texObj);
         if (texObj) {
            GLuint numFaces = (texObj->Target == GL_TEXTURE_CUBE_MAP) ? 6 : 1;
            GLuint face;
            for (face = 0; face < numFaces; face++) {
               GLint lvl;
               for (lvl = texObj->BaseLevel; lvl <= texObj->_MaxLevel; lvl++) {
                  struct gl_texture_image *texImg = texObj->Image[face][lvl];
                  if (texImg && texImg->Data) {
                     _mesa_free_texmemory(texImg->Data);
                     texImg->Data = NULL;
                  }
               }
            }
         }
      }
   }
}



d461 1
a461 1
      for (i = 0 ; i < ctx->Const.MaxTextureImageUnits ; i++)
d475 2
a476 2
   for (u = 0; u < ctx->Const.MaxTextureImageUnits; u++) {
      const struct gl_texture_object *tObj = ctx->Texture.Unit[u]._Current;
d480 4
a483 1
      swrast->TextureSample[u] = _swrast_choose_texture_sample_func(ctx, tObj);
d496 1
a496 1
   GLuint attribsMask;
d501 1
a501 1
   if (ctx->FragmentProgram._Current) {
d504 1
a504 1
      attribsMask &= ~FRAG_BIT_WPOS; /* WPOS is always handled specially */
d514 1
a514 1
      attribsMask |= FRAG_BIT_COL0;
d520 1
a520 1
         attribsMask |= FRAG_BIT_COL1;
d524 1
a524 1
         attribsMask |= FRAG_BIT_FOGC;
d526 1
a526 1
      attribsMask |= (ctx->Texture._EnabledUnits << FRAG_ATTRIB_TEX0);
d534 2
a535 2
      for (i = 0; i < FRAG_ATTRIB_MAX; i++) {
         if (attribsMask & (1 << i)) {
d538 1
a538 1
            if (i == FRAG_ATTRIB_COL0 || i == FRAG_ATTRIB_COL1)
a571 1
         _swrast_validate_texture_images(ctx);
d601 1
a601 1
/* Public entrypoints:  See also s_accum.c, s_bitmap.c, etc.
d698 18
d720 18
a737 1
   SWcontext *swrast = (SWcontext *)CALLOC(sizeof(SWcontext));
d765 2
a766 3
   /* Optimized Accum buffer */
   swrast->_IntegerAccumMode = GL_FALSE;
   swrast->_IntegerAccumScaler = 0.0;
d768 1
a768 1
   for (i = 0; i < MAX_TEXTURE_IMAGE_UNITS; i++)
d771 5
a775 1
   swrast->SpanArrays = MALLOC_STRUCT(sw_span_arrays);
d777 1
a777 1
      FREE(swrast);
d780 2
a781 1
   swrast->SpanArrays->ChanType = CHAN_TYPE;
d783 1
a783 1
   swrast->SpanArrays->rgba = swrast->SpanArrays->rgba8;
d785 1
a785 1
   swrast->SpanArrays->rgba = swrast->SpanArrays->rgba16;
d787 1
a787 1
   swrast->SpanArrays->rgba = swrast->SpanArrays->attribs[FRAG_ATTRIB_COL0];
d789 1
d797 16
a812 5
   swrast->TexelBuffer = (GLfloat *) MALLOC(ctx->Const.MaxTextureImageUnits *
                                           MAX_WIDTH * 4 * sizeof(GLfloat));
   if (!swrast->TexelBuffer) {
      FREE(swrast->SpanArrays);
      FREE(swrast);
a815 2
   ctx->swrast_context = swrast;

d828 10
a837 5
   FREE( swrast->SpanArrays );
   if (swrast->ZoomedArrays)
      FREE( swrast->ZoomedArrays );
   FREE( swrast->TexelBuffer );
   FREE( swrast );
d872 18
d903 3
a907 2

   _swrast_flush(ctx);
d920 4
a923 4
                  v->attrib[FRAG_ATTRIB_WPOS][0],
                  v->attrib[FRAG_ATTRIB_WPOS][1],
                  v->attrib[FRAG_ATTRIB_WPOS][2],
                  v->attrib[FRAG_ATTRIB_WPOS][3]);
d928 4
a931 4
                        v->attrib[FRAG_ATTRIB_TEX0 + i][0],
                        v->attrib[FRAG_ATTRIB_TEX0 + i][1],
                        v->attrib[FRAG_ATTRIB_TEX0 + i][2],
                        v->attrib[FRAG_ATTRIB_TEX0 + i][3]);
d941 6
a946 6
                  v->attrib[FRAG_ATTRIB_COL1][0],
                  v->attrib[FRAG_ATTRIB_COL1][1],
                  v->attrib[FRAG_ATTRIB_COL1][2],
                  v->attrib[FRAG_ATTRIB_COL1][3]);
      _mesa_debug(ctx, "fog %f\n", v->attrib[FRAG_ATTRIB_FOGC][0]);
      _mesa_debug(ctx, "index %f\n", v->attrib[FRAG_ATTRIB_CI][0]);
@


1.6
log
@Merge Mesa 7.10.3
@
text
@d251 2
d254 1
a254 11
   swrast->_FogEnabled = GL_FALSE;
   if (fp && fp->Base.Target == GL_FRAGMENT_PROGRAM_ARB) {
      if (fp->FogOption != GL_NONE) {
         swrast->_FogEnabled = GL_TRUE;
         swrast->_FogMode = fp->FogOption;
      }
   }
   else if (ctx->Fog.Enabled) {
      swrast->_FogEnabled = GL_TRUE;
      swrast->_FogMode = ctx->Fog.Mode;
   }
@


1.5
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@a30 1
#include "main/context.h"
d34 2
a35 2
#include "shader/prog_parameter.h"
#include "shader/prog_statevars.h"
d53 1
a53 1
_swrast_update_rasterflags( GLcontext *ctx )
d132 1
a132 1
_swrast_update_polygon( GLcontext *ctx )
d168 1
a168 1
_swrast_update_fog_hint( GLcontext *ctx )
d183 1
a183 1
_swrast_update_texture_env( GLcontext *ctx )
d214 1
a214 1
_swrast_update_deferred_texture(GLcontext *ctx)
d246 1
a246 1
_swrast_update_fog_state( GLcontext *ctx )
d271 1
a271 1
_swrast_update_fragment_program(GLcontext *ctx, GLbitfield newState)
d285 1
a285 1
_swrast_update_specular_vertex_add(GLcontext *ctx)
d349 1
a349 1
_swrast_validate_triangle( GLcontext *ctx,
d374 1
a374 1
_swrast_validate_line( GLcontext *ctx, const SWvertex *v0, const SWvertex *v1 )
d395 1
a395 1
_swrast_validate_point( GLcontext *ctx, const SWvertex *v0 )
d416 1
a416 1
_swrast_validate_blend_func(GLcontext *ctx, GLuint n, const GLubyte mask[],
d434 1
a434 1
_swrast_validate_texture_images(GLcontext *ctx)
d473 1
a473 1
_swrast_eject_texture_images(GLcontext *ctx)
d507 1
a507 1
_swrast_sleep( GLcontext *ctx, GLbitfield new_state )
d514 1
a514 1
_swrast_invalidate_state( GLcontext *ctx, GLbitfield new_state )
d549 1
a549 1
_swrast_update_texture_samplers(GLcontext *ctx)
d572 1
a572 1
_swrast_update_active_attribs(GLcontext *ctx)
d629 1
a629 1
_swrast_validate_derived( GLcontext *ctx )
d684 1
a684 1
_swrast_Quad( GLcontext *ctx,
d700 1
a700 1
_swrast_Triangle( GLcontext *ctx, const SWvertex *v0,
d713 1
a713 1
_swrast_Line( GLcontext *ctx, const SWvertex *v0, const SWvertex *v1 )
d724 1
a724 1
_swrast_Point( GLcontext *ctx, const SWvertex *v0 )
d734 1
a734 1
_swrast_InvalidateState( GLcontext *ctx, GLbitfield new_state )
d743 1
a743 1
_swrast_ResetLineStipple( GLcontext *ctx )
d752 1
a752 1
_swrast_SetFacing(GLcontext *ctx, GLuint facing)
d758 1
a758 1
_swrast_allow_vertex_fog( GLcontext *ctx, GLboolean value )
d768 1
a768 1
_swrast_allow_pixel_fog( GLcontext *ctx, GLboolean value )
d779 1
a779 1
_swrast_CreateContext( GLcontext *ctx )
d851 1
a851 1
_swrast_DestroyContext( GLcontext *ctx )
d870 1
a870 1
_swrast_GetDeviceDriverReference( GLcontext *ctx )
d877 1
a877 1
_swrast_flush( GLcontext *ctx )
d888 1
a888 1
_swrast_render_primitive( GLcontext *ctx, GLenum prim )
d899 1
a899 1
_swrast_render_start( GLcontext *ctx )
d908 1
a908 1
_swrast_render_finish( GLcontext *ctx )
d921 1
a921 1
_swrast_print_vertex( GLcontext *ctx, const SWvertex *v )
d953 1
a953 1
      _mesa_debug(ctx, "index %d\n", v->attrib[FRAG_ATTRIB_CI][0]);
@


1.4
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d58 1
d65 9
a73 6
   if (ctx->Stencil.Enabled)              rasterMask |= STENCIL_BIT;
   if (ctx->Visual.rgbMode) {
      const GLuint colorMask = *((GLuint *) &ctx->Color.ColorMask);
      if (colorMask != 0xffffffff)        rasterMask |= MASKING_BIT;
      if (ctx->Color._LogicOpEnabled)     rasterMask |= LOGIC_OP_BIT;
      if (ctx->Texture._EnabledUnits)     rasterMask |= TEXTURE_BIT;
d75 2
a76 5
   else {
      if (ctx->Color.IndexMask != 0xffffffff) rasterMask |= MASKING_BIT;
      if (ctx->Color.IndexLogicOpEnabled)     rasterMask |= LOGIC_OP_BIT;
   }

d96 9
a104 5
   else if (ctx->Visual.rgbMode && *((GLuint *) ctx->Color.ColorMask) == 0) {
      rasterMask |= MULTI_DRAW_BIT; /* all RGBA channels disabled */
   }
   else if (!ctx->Visual.rgbMode && ctx->Color.IndexMask==0) {
      rasterMask |= MULTI_DRAW_BIT; /* all color index bits disabled */
d106 1
d140 1
a140 1
         backface_sign = -1.0;
d143 1
a143 1
         backface_sign = 1.0;
d148 1
a148 1
	 backface_sign = 0.0;
d152 1
a152 1
      backface_sign = 0.0;
d159 1
a159 1
      = (ctx->Polygon.FrontFace == GL_CW) ? -1.0 : 1.0;
d181 1
a181 1
 * Update the swrast->_AnyTextureCombine flag.
d188 3
a190 1
   swrast->_AnyTextureCombine = GL_FALSE;
d192 12
a203 4
      if (ctx->Texture.Unit[i].EnvMode == GL_COMBINE_EXT ||
          ctx->Texture.Unit[i].EnvMode == GL_COMBINE4_NV) {
         swrast->_AnyTextureCombine = GL_TRUE;
         return;
d225 1
a225 1
      if (fprog && (fprog->Base.OutputsWritten & (1 << FRAG_RESULT_DEPR))) {
d229 3
d276 1
a276 7
#if 0
      /* XXX Need a way to trigger the initial loading of parameters
       * even when there's no recent state changes.
       */
      if (fp->Base.Parameters->StateFlags & newState)
#endif
         _mesa_load_state_parameters(ctx, fp->Base.Parameters);
d281 18
d301 1
d361 1
a361 3
   if (ctx->Texture._EnabledUnits == 0
       && NEED_SECONDARY_COLOR(ctx)
       && !ctx->FragmentProgram._Current) {
d383 1
a383 3
   if (ctx->Texture._EnabledUnits == 0
       && NEED_SECONDARY_COLOR(ctx)
       && !ctx->FragmentProgram._Current) {
d403 1
a403 3
   if (ctx->Texture._EnabledUnits == 0
       && NEED_SECONDARY_COLOR(ctx)
       && !ctx->FragmentProgram._Current) {
a530 7
   {
      const struct gl_fragment_program *fp = ctx->FragmentProgram._Current;
      if (fp && (fp->Base.Parameters->StateFlags & new_state)) {
         _mesa_load_state_parameters(ctx, fp->Base.Parameters);
      }
   }

d555 3
d647 1
a647 11
      if (swrast->NewState & (_NEW_MODELVIEW |
                              _NEW_PROJECTION |
                              _NEW_TEXTURE_MATRIX |
                              _NEW_FOG |
                              _NEW_LIGHT |
                              _NEW_LINE |
                              _NEW_TEXTURE |
                              _NEW_TRANSFORM |
                              _NEW_POINT |
                              _NEW_VIEWPORT |
                              _NEW_PROGRAM))
d668 6
d838 2
a839 2
   swrast->TexelBuffer = (GLchan *) MALLOC(ctx->Const.MaxTextureImageUnits *
                                           MAX_WIDTH * 4 * sizeof(GLchan));
d883 1
a883 6
      if (ctx->Visual.rgbMode) {
         _swrast_write_rgba_span(ctx, &(swrast->PointSpan));
      }
      else {
         _swrast_write_index_span(ctx, &(swrast->PointSpan));
      }
@


1.3
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d29 6
a34 7
#include "imports.h"
#include "bufferobj.h"
#include "context.h"
#include "colormac.h"
#include "mtypes.h"
#include "teximage.h"
#include "swrast.h"
d37 1
@


1.2
log
@Update to Mesa 7.0.3. tested my oga@@ and johan@@
@
text
@d3 1
a3 1
 * Version:  7.0.3
d5 1
a5 1
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
a33 1
#include "prog_statevars.h"
d36 2
d91 1
a91 1
   if (ctx->DrawBuffer->_NumColorDrawBuffers[0] != 1) {
d121 1
a121 1
 * Examine polycon culls tate to compute the _BackfaceCullSign field.
d194 31
a359 1

d505 7
d547 2
a548 1
 * Update swrast->_ActiveAttribs and swrast->_NumActiveAttribs
d551 1
a551 1
_swrast_update_fragment_attribs(GLcontext *ctx)
d555 4
a558 1
   
d560 1
d562 4
d568 1
a568 1
      GLuint u;
d571 7
a577 4
#if 0 /* not yet */
      if (ctx->Depth.Test)
         attribsMask |= FRAG_BIT_WPOS;
      if (NEED_SECONDARY_COLOR(ctx))
d579 2
a580 1
#endif
d584 1
a584 5
      for (u = 0; u < ctx->Const.MaxTextureUnits; u++) {
         if (ctx->Texture.Unit[u]._ReallyEnabled) {
            attribsMask |= FRAG_BIT_TEX(u);
         }
      }
d587 1
a587 6
   /* don't want to interpolate these generic attribs just yet */
   /* XXX temporary */
   attribsMask &= ~(FRAG_BIT_WPOS |
                    FRAG_BIT_COL0 |
                    FRAG_BIT_COL1 |
                    FRAG_BIT_FOGC);
d593 1
a593 1
         if (attribsMask & (1 << i))
d595 6
a606 38
/**
 * Update the swrast->_ColorOutputsMask which indicates which color
 * renderbuffers (aka rendertargets) are being written to by the current
 * fragment program.
 * We also take glDrawBuffers() into account to skip outputs that are
 * set to GL_NONE.
 */
static void
_swrast_update_color_outputs(GLcontext *ctx)
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
   const struct gl_framebuffer *fb = ctx->DrawBuffer;

   swrast->_ColorOutputsMask = 0;
   swrast->_NumColorOutputs = 0;

   if (ctx->FragmentProgram._Current) {
      const GLbitfield outputsWritten
         = ctx->FragmentProgram._Current->Base.OutputsWritten;
      GLuint output;
      for (output = 0; output < ctx->Const.MaxDrawBuffers; output++) {
         if ((outputsWritten & (1 << (FRAG_RESULT_DATA0 + output)))
             && (fb->_NumColorDrawBuffers[output] > 0)) {
            swrast->_ColorOutputsMask |= (1 << output);
            swrast->_NumColorOutputs = output + 1;
         }
      }
   }
   if (swrast->_ColorOutputsMask == 0x0) {
      /* no fragment program, or frag prog didn't write to gl_FragData[] */
      if (fb->_NumColorDrawBuffers[0] > 0) {
         swrast->_ColorOutputsMask = 0x1;
         swrast->_NumColorOutputs = 1;
      }
   }
}


d638 1
a638 1
      if (swrast->NewState & (_NEW_TEXTURE | _NEW_PROGRAM))
d640 2
d643 2
a644 2
      if (swrast->NewState & (_NEW_TEXTURE | _NEW_PROGRAM))
         _swrast_validate_texture_images( ctx );
d651 1
d654 1
a654 4
         _swrast_update_fragment_attribs(ctx);

      if (swrast->NewState & (_NEW_PROGRAM | _NEW_BUFFERS))
         _swrast_update_color_outputs(ctx);
d807 1
a807 2
   swrast->SpanArrays->rgba = swrast->SpanArrays->color.sz1.rgba;
   swrast->SpanArrays->spec = swrast->SpanArrays->color.sz1.spec;
d809 1
a809 2
   swrast->SpanArrays->rgba = swrast->SpanArrays->color.sz2.rgba;
   swrast->SpanArrays->spec = swrast->SpanArrays->color.sz2.spec;
a811 1
   swrast->SpanArrays->spec = swrast->SpanArrays->attribs[FRAG_ATTRIB_COL1];
d843 2
d915 4
a918 1
                  v->win[0], v->win[1], v->win[2], v->win[3]);
a930 3
      _mesa_debug(ctx, "spec %f %f %f %f\n",
                  v->specular[0], v->specular[1],
                  v->specular[2], v->specular[3]);
a933 3
      _mesa_debug(ctx, "spec %d %d %d %d\n",
                  v->specular[0], v->specular[1],
                  v->specular[2], v->specular[3]);
d935 5
d941 1
a941 1
      _mesa_debug(ctx, "index %d\n", v->index);
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * Version:  6.5.1
d5 1
a5 1
 * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
d34 1
a34 1
#include "program.h"
d101 1
a101 5
   if (ctx->FragmentProgram._Active) {
      rasterMask |= FRAGPROG_BIT;
   }

   if (ctx->ShaderObjects._FragmentShaderPresent) {
d120 2
a121 2
 * Examine polycon culls tate to compute the _BackfaceSign field.
 * _BackfaceSign will be 0 if no culling, -1 if culling back-faces,
d128 1
a128 1
   GLfloat backface_sign = 1;
d131 1
a131 2
      backface_sign = 1;
      switch(ctx->Polygon.CullFaceMode) {
d133 1
a133 2
	 if(ctx->Polygon.FrontFace==GL_CCW)
	    backface_sign = -1;
d136 1
a136 2
	 if(ctx->Polygon.FrontFace!=GL_CCW)
	    backface_sign = -1;
d138 2
d141 1
a141 3
      case GL_FRONT_AND_BACK:
	 backface_sign = 0;
	 break;
d145 1
a145 1
      backface_sign = 0;
d148 5
a152 1
   SWRAST_CONTEXT(ctx)->_BackfaceSign = backface_sign;
d156 1
d159 1
a159 1
 * fog factors per-fragment.
d166 1
a166 1
                              ctx->FragmentProgram._Enabled || /* not _Active! */
d199 1
a199 5

   /* convert fog color to GLchan values */
   CLAMPED_FLOAT_TO_CHAN(swrast->_FogColor[RCOMP], ctx->Fog.Color[RCOMP]);
   CLAMPED_FLOAT_TO_CHAN(swrast->_FogColor[GCOMP], ctx->Fog.Color[GCOMP]);
   CLAMPED_FLOAT_TO_CHAN(swrast->_FogColor[BCOMP], ctx->Fog.Color[BCOMP]);
d203 4
a206 8
   if (ctx->FragmentProgram._Active) {
      if (ctx->FragmentProgram._Current->Base.Target==GL_FRAGMENT_PROGRAM_ARB) {
         const struct gl_fragment_program *fp
            = ctx->FragmentProgram._Current;
         if (fp->FogOption != GL_NONE) {
            swrast->_FogEnabled = GL_TRUE;
            swrast->_FogMode = fp->FogOption;
         }
d221 1
a221 1
_swrast_update_fragment_program( GLcontext *ctx )
d223 9
a231 3
   if (ctx->FragmentProgram._Active) {
      const struct gl_fragment_program *fp = ctx->FragmentProgram._Current;
      _mesa_load_state_parameters(ctx, fp->Base.Parameters);
d295 1
d299 1
a299 1
       && !ctx->FragmentProgram._Active) {
d319 1
d323 1
a323 1
       && !ctx->FragmentProgram._Active) {
d346 1
a346 1
       && !ctx->FragmentProgram._Active) {
d360 3
a362 4
_swrast_validate_blend_func( GLcontext *ctx, GLuint n,
			     const GLubyte mask[],
			     GLchan src[][4],
			     CONST GLchan dst[][4] )
d366 2
a367 2
   _swrast_validate_derived( ctx );
   _swrast_choose_blend_func( ctx );
d369 1
a369 1
   swrast->BlendFunc( ctx, n, mask, src, dst );
d396 1
a396 1
               GLuint lvl;
d434 1
a434 1
               GLuint lvl;
d492 1
a492 1
static void
d500 93
a592 3
      if (tObj)
         swrast->TextureSample[u] =
            _swrast_choose_texture_sample_func(ctx, tObj);
d615 12
a626 2
      if (swrast->NewState & _NEW_PROGRAM)
	 _swrast_update_fragment_program( ctx );
d628 1
a628 1
      if (swrast->NewState & _NEW_TEXTURE)
d637 9
d725 6
d790 1
a790 1
   swrast->SpanArrays = MALLOC_STRUCT(span_arrays);
d795 11
a808 1
   swrast->PointSpan.start = 0;
d911 4
a914 2
                        v->texcoord[i][0], v->texcoord[i][1],
                        v->texcoord[i][2], v->texcoord[i][3]);
d929 1
a929 1
      _mesa_debug(ctx, "fog %f\n", v->fog);
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d101 1
a101 1
   if (ctx->FragmentProgram._Enabled) {
d202 5
d209 1
a209 1
   if (ctx->FragmentProgram._Enabled) {
d231 1
a231 1
_swrast_update_fragment_program(GLcontext *ctx, GLbitfield newState)
d233 1
a233 1
   if (ctx->FragmentProgram._Enabled) {
d235 1
a235 7
#if 0
      /* XXX Need a way to trigger the initial loading of parameters
       * even when there's no recent state changes.
       */
      if (fp->Base.Parameters->StateFlags & newState)
#endif
         _mesa_load_state_parameters(ctx, fp->Base.Parameters);
a298 1
   ASSERT(swrast->Triangle);
d302 1
a302 1
       && !ctx->FragmentProgram._Enabled) {
a321 1
   ASSERT(swrast->Line);
d325 1
a325 1
       && !ctx->FragmentProgram._Enabled) {
d348 1
a348 1
       && !ctx->FragmentProgram._Enabled) {
d362 4
a365 3
_swrast_validate_blend_func(GLcontext *ctx, GLuint n, const GLubyte mask[],
                            GLvoid *src, const GLvoid *dst,
                            GLenum chanType )
d369 2
a370 2
   _swrast_validate_derived( ctx ); /* why is this needed? */
   _swrast_choose_blend_func( ctx, chanType );
d372 1
a372 1
   swrast->BlendFunc( ctx, n, mask, src, dst, chanType );
d528 2
a529 12
      if (swrast->NewState & (_NEW_MODELVIEW |
                              _NEW_PROJECTION |
                              _NEW_TEXTURE_MATRIX |
                              _NEW_FOG |
                              _NEW_LIGHT |
                              _NEW_LINE |
                              _NEW_TEXTURE |
                              _NEW_TRANSFORM |
                              _NEW_POINT |
                              _NEW_VIEWPORT |
                              _NEW_PROGRAM))
	 _swrast_update_fragment_program( ctx, swrast->NewState );
d678 1
a678 1
   swrast->SpanArrays = MALLOC_STRUCT(sw_span_arrays);
a682 11
   swrast->SpanArrays->ChanType = CHAN_TYPE;
#if CHAN_TYPE == GL_UNSIGNED_BYTE
   swrast->SpanArrays->rgba = swrast->SpanArrays->color.sz1.rgba;
   swrast->SpanArrays->spec = swrast->SpanArrays->color.sz1.spec;
#elif CHAN_TYPE == GL_UNSIGNED_SHORT
   swrast->SpanArrays->rgba = swrast->SpanArrays->color.sz2.rgba;
   swrast->SpanArrays->spec = swrast->SpanArrays->color.sz2.spec;
#else
   swrast->SpanArrays->rgba = swrast->SpanArrays->color.sz4.rgba;
   swrast->SpanArrays->spec = swrast->SpanArrays->color.sz4.spec;
#endif
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d3 1
a3 1
 * Version:  6.5.3
d5 1
a5 1
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
d34 1
a34 1
#include "prog_statevars.h"
d101 5
a105 1
   if (ctx->FragmentProgram._Current) {
d132 1
a132 1
   GLfloat backface_sign;
d135 2
a136 2
      backface_sign = 1.0;
      switch (ctx->Polygon.CullFaceMode) {
d138 2
a139 2
	 if (ctx->Polygon.FrontFace == GL_CCW)
	    backface_sign = -1.0;
d142 2
a143 2
	 if (ctx->Polygon.FrontFace != GL_CCW)
	    backface_sign = -1.0;
d145 1
d147 1
a147 3
         /* fallthrough */
      default:
	 backface_sign = 0.0;
d152 1
a152 1
      backface_sign = 0.0;
d161 1
a161 1
 * fog blend factors (from the fog coords) per-fragment.
d168 1
a168 1
                              ctx->FragmentProgram._Current ||
a200 1
   const struct gl_fragment_program *fp = ctx->FragmentProgram._Current;
d204 8
a211 4
   if (fp && fp->Base.Target == GL_FRAGMENT_PROGRAM_ARB) {
      if (fp->FogOption != GL_NONE) {
         swrast->_FogEnabled = GL_TRUE;
         swrast->_FogMode = fp->FogOption;
d228 2
a229 2
   const struct gl_fragment_program *fp = ctx->FragmentProgram._Current;
   if (fp) {
d304 1
a304 1
       && !ctx->FragmentProgram._Current) {
d328 1
a328 1
       && !ctx->FragmentProgram._Current) {
d351 1
a351 1
       && !ctx->FragmentProgram._Current) {
d401 1
a401 1
               GLint lvl;
d439 1
a439 1
               GLint lvl;
d497 1
a497 1
void
d505 3
a507 93
      /* Note: If tObj is NULL, the sample function will be a simple
       * function that just returns opaque black (0,0,0,1).
       */
      swrast->TextureSample[u] = _swrast_choose_texture_sample_func(ctx, tObj);
   }
}


/**
 * Update swrast->_ActiveAttribs and swrast->_NumActiveAttribs
 */
static void
_swrast_update_fragment_attribs(GLcontext *ctx)
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
   GLuint attribsMask;
   
   if (ctx->FragmentProgram._Current) {
      attribsMask = ctx->FragmentProgram._Current->Base.InputsRead;
   }
   else {
      GLuint u;
      attribsMask = 0x0;

#if 0 /* not yet */
      if (ctx->Depth.Test)
         attribsMask |= FRAG_BIT_WPOS;
      if (NEED_SECONDARY_COLOR(ctx))
         attribsMask |= FRAG_BIT_COL1;
#endif
      if (swrast->_FogEnabled)
         attribsMask |= FRAG_BIT_FOGC;

      for (u = 0; u < ctx->Const.MaxTextureUnits; u++) {
         if (ctx->Texture.Unit[u]._ReallyEnabled) {
            attribsMask |= FRAG_BIT_TEX(u);
         }
      }
   }

   /* don't want to interpolate these generic attribs just yet */
   /* XXX temporary */
   attribsMask &= ~(FRAG_BIT_WPOS |
                    FRAG_BIT_COL0 |
                    FRAG_BIT_COL1 |
                    FRAG_BIT_FOGC);

   /* Update _ActiveAttribs[] list */
   {
      GLuint i, num = 0;
      for (i = 0; i < FRAG_ATTRIB_MAX; i++) {
         if (attribsMask & (1 << i))
            swrast->_ActiveAttribs[num++] = i;
      }
      swrast->_NumActiveAttribs = num;
   }
}


/**
 * Update the swrast->_ColorOutputsMask which indicates which color
 * renderbuffers (aka rendertargets) are being written to by the current
 * fragment program.
 * We also take glDrawBuffers() into account to skip outputs that are
 * set to GL_NONE.
 */
static void
_swrast_update_color_outputs(GLcontext *ctx)
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
   const struct gl_framebuffer *fb = ctx->DrawBuffer;

   swrast->_ColorOutputsMask = 0;
   swrast->_NumColorOutputs = 0;

   if (ctx->FragmentProgram._Current) {
      const GLbitfield outputsWritten
         = ctx->FragmentProgram._Current->Base.OutputsWritten;
      GLuint output;
      for (output = 0; output < ctx->Const.MaxDrawBuffers; output++) {
         if ((outputsWritten & (1 << (FRAG_RESULT_DATA0 + output)))
             && (fb->_NumColorDrawBuffers[output] > 0)) {
            swrast->_ColorOutputsMask |= (1 << output);
            swrast->_NumColorOutputs = output + 1;
         }
      }
   }
   if (swrast->_ColorOutputsMask == 0x0) {
      /* no fragment program, or frag prog didn't write to gl_FragData[] */
      if (fb->_NumColorDrawBuffers[0] > 0) {
         swrast->_ColorOutputsMask = 0x1;
         swrast->_NumColorOutputs = 1;
      }
d543 1
a543 1
      if (swrast->NewState & (_NEW_TEXTURE | _NEW_PROGRAM))
a551 9
      if (swrast->NewState & (_NEW_DEPTH |
                              _NEW_FOG |
                              _NEW_PROGRAM |
                              _NEW_TEXTURE))
         _swrast_update_fragment_attribs(ctx);

      if (swrast->NewState & (_NEW_PROGRAM | _NEW_BUFFERS))
         _swrast_update_color_outputs(ctx);

d703 2
a704 2
   swrast->SpanArrays->rgba = swrast->SpanArrays->attribs[FRAG_ATTRIB_COL0];
   swrast->SpanArrays->spec = swrast->SpanArrays->attribs[FRAG_ATTRIB_COL1];
d709 1
d812 2
a813 4
                        v->attrib[FRAG_ATTRIB_TEX0 + i][0],
                        v->attrib[FRAG_ATTRIB_TEX0 + i][1],
                        v->attrib[FRAG_ATTRIB_TEX0 + i][2],
                        v->attrib[FRAG_ATTRIB_TEX0 + i][3]);
d828 1
a828 1
      _mesa_debug(ctx, "fog %f\n", v->attrib[FRAG_ATTRIB_FOGC][0]);
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d3 1
a3 1
 * Version:  7.1
d5 1
a5 1
 * Copyright (C) 1999-2008  Brian Paul   All Rights Reserved.
d29 7
a35 7
#include "main/imports.h"
#include "main/bufferobj.h"
#include "main/colormac.h"
#include "main/mtypes.h"
#include "main/teximage.h"
#include "program/prog_parameter.h"
#include "program/prog_statevars.h"
d53 1
a53 1
_swrast_update_rasterflags( struct gl_context *ctx )
a56 1
   GLuint i;
d63 10
a72 9
   if (ctx->Stencil._Enabled)             rasterMask |= STENCIL_BIT;
   for (i = 0; i < ctx->Const.MaxDrawBuffers; i++) {
      if (!ctx->Color.ColorMask[i][0] ||
          !ctx->Color.ColorMask[i][1] ||
          !ctx->Color.ColorMask[i][2] ||
          !ctx->Color.ColorMask[i][3]) {
         rasterMask |= MASKING_BIT;
         break;
      }
d74 1
a74 2
   if (ctx->Color._LogicOpEnabled)     rasterMask |= LOGIC_OP_BIT;
   if (ctx->Texture._EnabledUnits)     rasterMask |= TEXTURE_BIT;
d90 1
a90 1
   if (ctx->DrawBuffer->_NumColorDrawBuffers != 1) {
d94 5
a98 9

   for (i = 0; i < ctx->Const.MaxDrawBuffers; i++) {
      if (ctx->Color.ColorMask[i][0] +
          ctx->Color.ColorMask[i][1] +
          ctx->Color.ColorMask[i][2] +
          ctx->Color.ColorMask[i][3] == 0) {
         rasterMask |= MULTI_DRAW_BIT; /* all RGBA channels disabled */
         break;
      }
a100 1

d120 2
a121 2
 * Examine polygon cull state to compute the _BackfaceCullSign field.
 * _BackfaceCullSign will be 0 if no culling, -1 if culling back-faces,
d126 1
a126 1
_swrast_update_polygon( struct gl_context *ctx )
d131 1
d134 2
a135 1
         backface_sign = -1.0F;
d138 2
a139 1
         backface_sign = 1.0F;
d144 2
a145 1
	 backface_sign = 0.0F;
d149 1
a149 1
      backface_sign = 0.0F;
d152 1
a152 5
   SWRAST_CONTEXT(ctx)->_BackfaceCullSign = backface_sign;

   /* This is for front/back-face determination, but not for culling */
   SWRAST_CONTEXT(ctx)->_BackfaceSign
      = (ctx->Polygon.FrontFace == GL_CW) ? -1.0F : 1.0F;
a155 1

d161 1
a161 1
_swrast_update_fog_hint( struct gl_context *ctx )
d173 1
a173 1
 * Update the swrast->_TextureCombinePrimary flag.
d176 1
a176 1
_swrast_update_texture_env( struct gl_context *ctx )
d180 1
a180 3

   swrast->_TextureCombinePrimary = GL_FALSE;

d182 4
a185 46
      const struct gl_tex_env_combine_state *combine =
         ctx->Texture.Unit[i]._CurrentCombine;
      GLuint term;
      for (term = 0; term < combine->_NumArgsRGB; term++) {
         if (combine->SourceRGB[term] == GL_PRIMARY_COLOR) {
            swrast->_TextureCombinePrimary = GL_TRUE;
            return;
         }
         if (combine->SourceA[term] == GL_PRIMARY_COLOR) {
            swrast->_TextureCombinePrimary = GL_TRUE;
            return;
         }
      }
   }
}


/**
 * Determine if we can defer texturing/shading until after Z/stencil
 * testing.  This potentially allows us to skip texturing/shading for
 * lots of fragments.
 */
static void
_swrast_update_deferred_texture(struct gl_context *ctx)
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
   if (ctx->Color.AlphaEnabled) {
      /* alpha test depends on post-texture/shader colors */
      swrast->_DeferredTexture = GL_FALSE;
   }
   else {
      const struct gl_fragment_program *fprog
         = ctx->FragmentProgram._Current;
      if (fprog && (fprog->Base.OutputsWritten & (1 << FRAG_RESULT_DEPTH))) {
         /* Z comes from fragment program/shader */
         swrast->_DeferredTexture = GL_FALSE;
      }
      else if (fprog && fprog->UsesKill) {
         swrast->_DeferredTexture = GL_FALSE;
      }
      else if (ctx->Query.CurrentOcclusionObject) {
         /* occlusion query depends on shader discard/kill results */
         swrast->_DeferredTexture = GL_FALSE;
      }
      else {
         swrast->_DeferredTexture = GL_TRUE;
d195 1
a195 1
_swrast_update_fog_state( struct gl_context *ctx )
d220 1
a220 1
_swrast_update_fragment_program(struct gl_context *ctx, GLbitfield newState)
d224 7
a230 1
      _mesa_load_state_parameters(ctx, fp->Base.Parameters);
a234 18
/**
 * See if we can do early diffuse+specular (primary+secondary) color
 * add per vertex instead of per-fragment.
 */
static void
_swrast_update_specular_vertex_add(struct gl_context *ctx)
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
   GLboolean separateSpecular = ctx->Fog.ColorSumEnabled ||
      (ctx->Light.Enabled &&
       ctx->Light.Model.ColorControl == GL_SEPARATE_SPECULAR_COLOR);

   swrast->SpecularVertexAdd = (separateSpecular
                                && ctx->Texture._EnabledUnits == 0x0
                                && !ctx->FragmentProgram._Current
                                && !ctx->ATIFragmentShader._Enabled);
}

a236 1
                             _NEW_PROGRAM_CONSTANTS |   \
d285 1
a285 1
_swrast_validate_triangle( struct gl_context *ctx,
d296 3
a298 1
   if (swrast->SpecularVertexAdd) {
d312 1
a312 1
_swrast_validate_line( struct gl_context *ctx, const SWvertex *v0, const SWvertex *v1 )
d320 3
a322 1
   if (swrast->SpecularVertexAdd) {
d327 1
d336 1
a336 1
_swrast_validate_point( struct gl_context *ctx, const SWvertex *v0 )
d343 3
a345 1
   if (swrast->SpecularVertexAdd) {
d359 1
a359 1
_swrast_validate_blend_func(struct gl_context *ctx, GLuint n, const GLubyte mask[],
d377 1
a377 1
_swrast_validate_texture_images(struct gl_context *ctx)
d416 1
a416 1
_swrast_eject_texture_images(struct gl_context *ctx)
d450 1
a450 1
_swrast_sleep( struct gl_context *ctx, GLbitfield new_state )
d457 1
a457 1
_swrast_invalidate_state( struct gl_context *ctx, GLbitfield new_state )
d492 1
a492 1
_swrast_update_texture_samplers(struct gl_context *ctx)
a496 3
   if (!swrast)
      return; /* pipe hack */

d508 1
a508 2
 * Update swrast->_ActiveAttribs, swrast->_NumActiveAttribs,
 * swrast->_ActiveAtttribMask.
d511 1
a511 1
_swrast_update_active_attribs(struct gl_context *ctx)
d515 1
a515 4

   /*
    * Compute _ActiveAttribsMask = which fragment attributes are needed.
    */
a516 1
      /* fragment program/shader */
a517 4
      attribsMask &= ~FRAG_BIT_WPOS; /* WPOS is always handled specially */
   }
   else if (ctx->ATIFragmentShader._Enabled) {
      attribsMask = ~0;  /* XXX fix me */
d520 1
a520 1
      /* fixed function */
d523 5
a527 2
#if CHAN_TYPE == GL_FLOAT
      attribsMask |= FRAG_BIT_COL0;
a528 7

      if (ctx->Fog.ColorSumEnabled ||
          (ctx->Light.Enabled &&
           ctx->Light.Model.ColorControl == GL_SEPARATE_SPECULAR_COLOR)) {
         attribsMask |= FRAG_BIT_COL1;
      }

d532 5
a536 1
      attribsMask |= (ctx->Texture._EnabledUnits << FRAG_ATTRIB_TEX0);
d539 6
a544 1
   swrast->_ActiveAttribMask = attribsMask;
d550 1
a550 1
         if (attribsMask & (1 << i)) {
d552 31
a582 5
            /* how should this attribute be interpolated? */
            if (i == FRAG_ATTRIB_COL0 || i == FRAG_ATTRIB_COL1)
               swrast->_InterpMode[i] = ctx->Light.ShadeModel;
            else
               swrast->_InterpMode[i] = GL_SMOOTH;
d585 7
a591 1
      swrast->_NumActiveAttribs = num;
d597 1
a597 1
_swrast_validate_derived( struct gl_context *ctx )
d614 11
a624 1
      if (swrast->NewState & (_NEW_PROGRAM_CONSTANTS | _NEW_PROGRAM))
d627 1
a627 1
      if (swrast->NewState & (_NEW_TEXTURE | _NEW_PROGRAM)) {
a628 2
         _swrast_validate_texture_images(ctx);
      }
d630 2
a631 2
      if (swrast->NewState & (_NEW_COLOR | _NEW_PROGRAM))
         _swrast_update_deferred_texture(ctx);
a637 1
                              _NEW_LIGHT |
d640 1
a640 1
         _swrast_update_active_attribs(ctx);
d642 2
a643 5
      if (swrast->NewState & (_NEW_FOG | 
                              _NEW_PROGRAM |
                              _NEW_LIGHT |
                              _NEW_TEXTURE))
         _swrast_update_specular_vertex_add(ctx);
d656 1
a656 1
_swrast_Quad( struct gl_context *ctx,
d672 1
a672 1
_swrast_Triangle( struct gl_context *ctx, const SWvertex *v0,
d685 1
a685 1
_swrast_Line( struct gl_context *ctx, const SWvertex *v0, const SWvertex *v1 )
d696 1
a696 1
_swrast_Point( struct gl_context *ctx, const SWvertex *v0 )
d706 1
a706 1
_swrast_InvalidateState( struct gl_context *ctx, GLbitfield new_state )
d715 1
a715 1
_swrast_ResetLineStipple( struct gl_context *ctx )
d724 1
a724 7
_swrast_SetFacing(struct gl_context *ctx, GLuint facing)
{
   SWRAST_CONTEXT(ctx)->PointLineFacing = facing;
}

void
_swrast_allow_vertex_fog( struct gl_context *ctx, GLboolean value )
d734 1
a734 1
_swrast_allow_pixel_fog( struct gl_context *ctx, GLboolean value )
d745 1
a745 1
_swrast_CreateContext( struct gl_context *ctx )
d790 2
a791 1
   swrast->SpanArrays->rgba = swrast->SpanArrays->rgba8;
d793 2
a794 1
   swrast->SpanArrays->rgba = swrast->SpanArrays->rgba16;
d797 1
d806 2
a807 2
   swrast->TexelBuffer = (GLfloat *) MALLOC(ctx->Const.MaxTextureImageUnits *
                                           MAX_WIDTH * 4 * sizeof(GLfloat));
d820 1
a820 1
_swrast_DestroyContext( struct gl_context *ctx )
a828 2
   if (swrast->ZoomedArrays)
      FREE( swrast->ZoomedArrays );
d837 1
a837 1
_swrast_GetDeviceDriverReference( struct gl_context *ctx )
d844 1
a844 1
_swrast_flush( struct gl_context *ctx )
d849 6
a854 1
      _swrast_write_rgba_span(ctx, &(swrast->PointSpan));
d860 1
a860 1
_swrast_render_primitive( struct gl_context *ctx, GLenum prim )
d871 1
a871 1
_swrast_render_start( struct gl_context *ctx )
d880 1
a880 1
_swrast_render_finish( struct gl_context *ctx )
d893 1
a893 1
_swrast_print_vertex( struct gl_context *ctx, const SWvertex *v )
d899 1
a899 4
                  v->attrib[FRAG_ATTRIB_WPOS][0],
                  v->attrib[FRAG_ATTRIB_WPOS][1],
                  v->attrib[FRAG_ATTRIB_WPOS][2],
                  v->attrib[FRAG_ATTRIB_WPOS][3]);
d912 3
d918 3
a921 5
      _mesa_debug(ctx, "spec %g %g %g %g\n",
                  v->attrib[FRAG_ATTRIB_COL1][0],
                  v->attrib[FRAG_ATTRIB_COL1][1],
                  v->attrib[FRAG_ATTRIB_COL1][2],
                  v->attrib[FRAG_ATTRIB_COL1][3]);
d923 1
a923 1
      _mesa_debug(ctx, "index %f\n", v->attrib[FRAG_ATTRIB_CI][0]);
@


1.1.1.5
log
@Import Mesa 9.2.0
@
text
@d3 1
d20 3
a22 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
d25 2
a26 1
 *    Keith Whitwell <keith@@tungstengraphics.com> Brian Paul
a32 1
#include "main/samplerobj.h"
a41 1
#include "s_texfetch.h"
d74 1
a74 1
   if (ctx->Color.ColorLogicOpEnabled) rasterMask |= LOGIC_OP_BIT;
d107 1
a107 1
   if (_swrast_use_fragment_program(ctx)) {
d172 1
a172 1
			      _swrast_use_fragment_program(ctx) ||
a221 1
      GLboolean use_fprog = _swrast_use_fragment_program(ctx);
d224 1
a224 1
      if (use_fprog && (fprog->Base.OutputsWritten & (1 << FRAG_RESULT_DEPTH))) {
d228 1
a228 1
      else if (use_fprog && fprog->UsesKill) {
a250 2
   assert(fp == NULL || fp->Base.Target == GL_FRAGMENT_PROGRAM_ARB);

d252 11
a262 2
   swrast->_FogEnabled = (!_swrast_use_fragment_program(ctx) &&
			  ctx->Fog.Enabled);
d273 4
a276 5
   if (!_swrast_use_fragment_program(ctx))
      return;

   _mesa_load_state_parameters(ctx,
                               ctx->FragmentProgram._Current->Base.Parameters);
d294 1
a294 1
                                && !_swrast_use_fragment_program(ctx)
d317 1
a317 1
			      _MESA_NEW_SEPARATE_SPECULAR)
d326 1
a326 1
                          _MESA_NEW_SEPARATE_SPECULAR)
d334 1
a334 1
                           _MESA_NEW_SEPARATE_SPECULAR)
d428 78
d543 1
a543 1
      for (i = 0 ; i < ARRAY_SIZE(swrast->TextureSample); i++)
d557 2
a558 2
   for (u = 0; u < ARRAY_SIZE(swrast->TextureSample); u++) {
      struct gl_texture_object *tObj = ctx->Texture.Unit[u]._Current;
d562 1
a562 4
      _mesa_update_fetch_functions(ctx, u);
      swrast->TextureSample[u] =
         _swrast_choose_texture_sample_func(ctx, tObj,
                                            _mesa_get_samplerobj(ctx, u));
d575 1
a575 1
   GLbitfield64 attribsMask;
d580 1
a580 1
   if (_swrast_use_fragment_program(ctx)) {
d583 1
a583 1
      attribsMask &= ~VARYING_BIT_POS; /* WPOS is always handled specially */
d593 1
a593 1
      attribsMask |= VARYING_BIT_COL0;
d599 1
a599 1
         attribsMask |= VARYING_BIT_COL1;
d603 1
a603 1
         attribsMask |= VARYING_BIT_FOGC;
d605 1
a605 1
      attribsMask |= (ctx->Texture._EnabledUnits << VARYING_SLOT_TEX0);
d613 2
a614 2
      for (i = 0; i < VARYING_SLOT_MAX; i++) {
         if (attribsMask & BITFIELD64_BIT(i)) {
d617 1
a617 1
            if (i == VARYING_SLOT_COL0 || i == VARYING_SLOT_COL1)
d651 1
d681 1
a681 1
/* Public entrypoints:  See also s_bitmap.c, etc.
a777 18
/**
 * Initialize native program limits by copying the logical limits.
 * See comments in init_program_limits() in context.c
 */
static void
init_program_native_limits(struct gl_program_constants *prog)
{
   prog->MaxNativeInstructions = prog->MaxInstructions;
   prog->MaxNativeAluInstructions = prog->MaxAluInstructions;
   prog->MaxNativeTexInstructions = prog->MaxTexInstructions;
   prog->MaxNativeTexIndirections = prog->MaxTexIndirections;
   prog->MaxNativeAttribs = prog->MaxAttribs;
   prog->MaxNativeTemps = prog->MaxTemps;
   prog->MaxNativeAddressRegs = prog->MaxAddressRegs;
   prog->MaxNativeParameters = prog->MaxParameters;
}


d782 1
a782 18
   SWcontext *swrast = calloc(1, sizeof(SWcontext));
#ifdef _OPENMP
   const GLuint maxThreads = omp_get_max_threads();
#else
   const GLuint maxThreads = 1;
#endif

   assert(ctx->Const.MaxViewportWidth <= SWRAST_MAX_WIDTH);
   assert(ctx->Const.MaxViewportHeight <= SWRAST_MAX_WIDTH);

   assert(ctx->Const.MaxRenderbufferSize <= SWRAST_MAX_WIDTH);

   /* make sure largest texture image is <= SWRAST_MAX_WIDTH in size */
   assert((1 << (ctx->Const.MaxTextureLevels - 1)) <= SWRAST_MAX_WIDTH);
   assert((1 << (ctx->Const.MaxCubeTextureLevels - 1)) <= SWRAST_MAX_WIDTH);
   assert((1 << (ctx->Const.Max3DTextureLevels - 1)) <= SWRAST_MAX_WIDTH);

   assert(PROG_MAX_WIDTH == SWRAST_MAX_WIDTH);
d810 3
a812 2
   swrast->Driver.SpanRenderStart = _swrast_span_render_start;
   swrast->Driver.SpanRenderFinish = _swrast_span_render_finish;
d814 1
a814 1
   for (i = 0; i < ARRAY_SIZE(swrast->TextureSample); i++)
d817 1
a817 5
   /* SpanArrays is global and shared by all SWspan instances. However, when
    * using multiple threads, it is necessary to have one SpanArrays instance
    * per thread.
    */
   swrast->SpanArrays = malloc(maxThreads * sizeof(SWspanarrays));
d819 1
a819 1
      free(swrast);
d822 1
a822 2
   for(i = 0; i < maxThreads; i++) {
      swrast->SpanArrays[i].ChanType = CHAN_TYPE;
d824 1
a824 1
      swrast->SpanArrays[i].rgba = swrast->SpanArrays[i].rgba8;
d826 1
a826 1
      swrast->SpanArrays[i].rgba = swrast->SpanArrays[i].rgba16;
d828 1
a828 1
      swrast->SpanArrays[i].rgba = swrast->SpanArrays[i].attribs[VARYING_SLOT_COL0];
a829 1
   }
d837 7
a843 3
   init_program_native_limits(&ctx->Const.VertexProgram);
   init_program_native_limits(&ctx->Const.GeometryProgram);
   init_program_native_limits(&ctx->Const.FragmentProgram);
a846 13
   swrast->stencil_temp.buf1 = malloc(SWRAST_MAX_WIDTH * sizeof(GLubyte));
   swrast->stencil_temp.buf2 = malloc(SWRAST_MAX_WIDTH * sizeof(GLubyte));
   swrast->stencil_temp.buf3 = malloc(SWRAST_MAX_WIDTH * sizeof(GLubyte));
   swrast->stencil_temp.buf4 = malloc(SWRAST_MAX_WIDTH * sizeof(GLubyte));

   if (!swrast->stencil_temp.buf1 ||
       !swrast->stencil_temp.buf2 ||
       !swrast->stencil_temp.buf3 ||
       !swrast->stencil_temp.buf4) {
      _swrast_DestroyContext(ctx);
      return GL_FALSE;
   }

d859 5
a863 10
   free( swrast->SpanArrays );
   free( swrast->ZoomedArrays );
   free( swrast->TexelBuffer );

   free(swrast->stencil_temp.buf1);
   free(swrast->stencil_temp.buf2);
   free(swrast->stencil_temp.buf3);
   free(swrast->stencil_temp.buf4);

   free( swrast );
a897 18
/** called via swrast->Driver.SpanRenderStart() */
void
_swrast_span_render_start(struct gl_context *ctx)
{
   _swrast_map_textures(ctx);
   _swrast_map_renderbuffers(ctx);
}


/** called via swrast->Driver.SpanRenderFinish() */
void
_swrast_span_render_finish(struct gl_context *ctx)
{
   _swrast_unmap_textures(ctx);
   _swrast_unmap_renderbuffers(ctx);
}


d911 2
a914 3

   if (swrast->Driver.SpanRenderFinish)
      swrast->Driver.SpanRenderFinish( ctx );
d927 4
a930 4
                  v->attrib[VARYING_SLOT_POS][0],
                  v->attrib[VARYING_SLOT_POS][1],
                  v->attrib[VARYING_SLOT_POS][2],
                  v->attrib[VARYING_SLOT_POS][3]);
d935 4
a938 4
                        v->attrib[VARYING_SLOT_TEX0 + i][0],
                        v->attrib[VARYING_SLOT_TEX0 + i][1],
                        v->attrib[VARYING_SLOT_TEX0 + i][2],
                        v->attrib[VARYING_SLOT_TEX0 + i][3]);
d948 6
a953 6
                  v->attrib[VARYING_SLOT_COL1][0],
                  v->attrib[VARYING_SLOT_COL1][1],
                  v->attrib[VARYING_SLOT_COL1][2],
                  v->attrib[VARYING_SLOT_COL1][3]);
      _mesa_debug(ctx, "fog %f\n", v->attrib[VARYING_SLOT_FOGC][0]);
      _mesa_debug(ctx, "index %f\n", v->attrib[VARYING_SLOT_CI][0]);
@


1.1.1.6
log
@Import Mesa 10.2.3
@
text
@d25 1
a25 1
 *    Keith Whitwell <keithw@@vmware.com> Brian Paul
d64 1
a64 1
   if (ctx->Scissor.EnableFlags)          rasterMask |= CLIP_BIT;
d76 5
a80 5
   if (ctx->Texture._MaxEnabledTexImageUnit >= 0) rasterMask |= TEXTURE_BIT;
   if (   ctx->ViewportArray[0].X < 0
       || ctx->ViewportArray[0].X + ctx->ViewportArray[0].Width > (GLfloat) ctx->DrawBuffer->Width
       || ctx->ViewportArray[0].Y < 0
       || ctx->ViewportArray[0].Y + ctx->ViewportArray[0].Height > (GLfloat) ctx->DrawBuffer->Height) {
d289 1
a289 1
                                && ctx->Texture._MaxEnabledTexImageUnit == -1
d526 1
a526 1
      attribsMask |= (ctx->Texture._EnabledCoordUnits << VARYING_SLOT_TEX0);
d797 3
a799 3
   init_program_native_limits(&ctx->Const.Program[MESA_SHADER_VERTEX]);
   init_program_native_limits(&ctx->Const.Program[MESA_SHADER_GEOMETRY]);
   init_program_native_limits(&ctx->Const.Program[MESA_SHADER_FRAGMENT]);
d926 1
a926 1
	 if (ctx->Texture.Unit[i]._Current)
@


