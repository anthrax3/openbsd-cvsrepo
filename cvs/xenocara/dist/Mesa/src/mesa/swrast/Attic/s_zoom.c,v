head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.8
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.6
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.5
	v10_2_7:1.1.1.5
	OPENBSD_5_6:1.6.0.4
	OPENBSD_5_6_BASE:1.6
	v10_2_3:1.1.1.5
	OPENBSD_5_5:1.6.0.2
	OPENBSD_5_5_BASE:1.6
	v9_2_5:1.1.1.5
	v9_2_3:1.1.1.5
	v9_2_2:1.1.1.5
	v9_2_1:1.1.1.5
	v9_2_0:1.1.1.5
	OPENBSD_5_4:1.5.0.8
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.6
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.3.0.4
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.12.23.05.17.55;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2013.09.05.14.06.51;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.23.13.37.45;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.34;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.42;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.23;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.51.28;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.51.28;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.56.52;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.32.16;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.49;	author matthieu;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.09.05.13.17.36;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2008  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#include "main/glheader.h"
#include "main/macros.h"
#include "main/imports.h"
#include "main/format_pack.h"
#include "main/colormac.h"

#include "s_context.h"
#include "s_span.h"
#include "s_stencil.h"
#include "s_zoom.h"


/**
 * Compute the bounds of the region resulting from zooming a pixel span.
 * The resulting region will be entirely inside the window/scissor bounds
 * so no additional clipping is needed.
 * \param imageX, imageY  position of the mage being drawn (gl WindowPos)
 * \param spanX, spanY  position of span being drawing
 * \param width  number of pixels in span
 * \param x0, x1  returned X bounds of zoomed region [x0, x1)
 * \param y0, y1  returned Y bounds of zoomed region [y0, y1)
 * \return GL_TRUE if any zoomed pixels visible, GL_FALSE if totally clipped
 */
static GLboolean
compute_zoomed_bounds(struct gl_context *ctx, GLint imageX, GLint imageY,
                      GLint spanX, GLint spanY, GLint width,
                      GLint *x0, GLint *x1, GLint *y0, GLint *y1)
{
   const struct gl_framebuffer *fb = ctx->DrawBuffer;
   GLint c0, c1, r0, r1;

   ASSERT(spanX >= imageX);
   ASSERT(spanY >= imageY);

   /*
    * Compute destination columns: [c0, c1)
    */
   c0 = imageX + (GLint) ((spanX - imageX) * ctx->Pixel.ZoomX);
   c1 = imageX + (GLint) ((spanX + width - imageX) * ctx->Pixel.ZoomX);
   if (c1 < c0) {
      /* swap */
      GLint tmp = c1;
      c1 = c0;
      c0 = tmp;
   }
   c0 = CLAMP(c0, fb->_Xmin, fb->_Xmax);
   c1 = CLAMP(c1, fb->_Xmin, fb->_Xmax);
   if (c0 == c1) {
      return GL_FALSE; /* no width */
   }

   /*
    * Compute destination rows: [r0, r1)
    */
   r0 = imageY + (GLint) ((spanY - imageY) * ctx->Pixel.ZoomY);
   r1 = imageY + (GLint) ((spanY + 1 - imageY) * ctx->Pixel.ZoomY);
   if (r1 < r0) {
      /* swap */
      GLint tmp = r1;
      r1 = r0;
      r0 = tmp;
   }
   r0 = CLAMP(r0, fb->_Ymin, fb->_Ymax);
   r1 = CLAMP(r1, fb->_Ymin, fb->_Ymax);
   if (r0 == r1) {
      return GL_FALSE; /* no height */
   }

   *x0 = c0;
   *x1 = c1;
   *y0 = r0;
   *y1 = r1;

   return GL_TRUE;
}


/**
 * Convert a zoomed x image coordinate back to an unzoomed x coord.
 * 'zx' is screen position of a pixel in the zoomed image, who's left edge
 * is at 'imageX'.
 * return corresponding x coord in the original, unzoomed image.
 * This can use this for unzooming X or Y values.
 */
static inline GLint
unzoom_x(GLfloat zoomX, GLint imageX, GLint zx)
{
   /*
   zx = imageX + (x - imageX) * zoomX;
   zx - imageX = (x - imageX) * zoomX;
   (zx - imageX) / zoomX = x - imageX;
   */
   GLint x;
   if (zoomX < 0.0)
      zx++;
   x = imageX + (GLint) ((zx - imageX) / zoomX);
   return x;
}



/**
 * Helper function called from _swrast_write_zoomed_rgba/rgb/
 * index/depth_span().
 */
static void
zoom_span( struct gl_context *ctx, GLint imgX, GLint imgY, const SWspan *span,
           const GLvoid *src, GLenum format )
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
   SWspan zoomed;
   GLint x0, x1, y0, y1;
   GLint zoomedWidth;

   if (!compute_zoomed_bounds(ctx, imgX, imgY, span->x, span->y, span->end,
                              &x0, &x1, &y0, &y1)) {
      return;  /* totally clipped */
   }

   if (!swrast->ZoomedArrays) {
      /* allocate on demand */
      swrast->ZoomedArrays = (SWspanarrays *) calloc(1, sizeof(SWspanarrays));
      if (!swrast->ZoomedArrays)
         return;
   }

   zoomedWidth = x1 - x0;
   ASSERT(zoomedWidth > 0);
   ASSERT(zoomedWidth <= SWRAST_MAX_WIDTH);

   /* no pixel arrays! must be horizontal spans. */
   ASSERT((span->arrayMask & SPAN_XY) == 0);
   ASSERT(span->primitive == GL_BITMAP);

   INIT_SPAN(zoomed, GL_BITMAP);
   zoomed.x = x0;
   zoomed.end = zoomedWidth;
   zoomed.array = swrast->ZoomedArrays;
   zoomed.array->ChanType = span->array->ChanType;
   if (zoomed.array->ChanType == GL_UNSIGNED_BYTE)
      zoomed.array->rgba = (GLchan (*)[4]) zoomed.array->rgba8;
   else if (zoomed.array->ChanType == GL_UNSIGNED_SHORT)
      zoomed.array->rgba = (GLchan (*)[4]) zoomed.array->rgba16;
   else
      zoomed.array->rgba = (GLchan (*)[4]) zoomed.array->attribs[VARYING_SLOT_COL0];

   COPY_4V(zoomed.attrStart[VARYING_SLOT_POS], span->attrStart[VARYING_SLOT_POS]);
   COPY_4V(zoomed.attrStepX[VARYING_SLOT_POS], span->attrStepX[VARYING_SLOT_POS]);
   COPY_4V(zoomed.attrStepY[VARYING_SLOT_POS], span->attrStepY[VARYING_SLOT_POS]);

   zoomed.attrStart[VARYING_SLOT_FOGC][0] = span->attrStart[VARYING_SLOT_FOGC][0];
   zoomed.attrStepX[VARYING_SLOT_FOGC][0] = span->attrStepX[VARYING_SLOT_FOGC][0];
   zoomed.attrStepY[VARYING_SLOT_FOGC][0] = span->attrStepY[VARYING_SLOT_FOGC][0];

   if (format == GL_RGBA || format == GL_RGB) {
      /* copy Z info */
      zoomed.z = span->z;
      zoomed.zStep = span->zStep;
      /* we'll generate an array of colorss */
      zoomed.interpMask = span->interpMask & ~SPAN_RGBA;
      zoomed.arrayMask |= SPAN_RGBA;
      zoomed.arrayAttribs |= VARYING_BIT_COL0;  /* we'll produce these values */
      ASSERT(span->arrayMask & SPAN_RGBA);
   }
   else if (format == GL_DEPTH_COMPONENT) {
      /* Copy color info */
      zoomed.red = span->red;
      zoomed.green = span->green;
      zoomed.blue = span->blue;
      zoomed.alpha = span->alpha;
      zoomed.redStep = span->redStep;
      zoomed.greenStep = span->greenStep;
      zoomed.blueStep = span->blueStep;
      zoomed.alphaStep = span->alphaStep;
      /* we'll generate an array of depth values */
      zoomed.interpMask = span->interpMask & ~SPAN_Z;
      zoomed.arrayMask |= SPAN_Z;
      ASSERT(span->arrayMask & SPAN_Z);
   }
   else {
      _mesa_problem(ctx, "Bad format in zoom_span");
      return;
   }

   /* zoom the span horizontally */
   if (format == GL_RGBA) {
      if (zoomed.array->ChanType == GL_UNSIGNED_BYTE) {
         const GLubyte (*rgba)[4] = (const GLubyte (*)[4]) src;
         GLint i;
         for (i = 0; i < zoomedWidth; i++) {
            GLint j = unzoom_x(ctx->Pixel.ZoomX, imgX, x0 + i) - span->x;
            ASSERT(j >= 0);
            ASSERT(j < (GLint) span->end);
            COPY_4UBV(zoomed.array->rgba8[i], rgba[j]);
         }
      }
      else if (zoomed.array->ChanType == GL_UNSIGNED_SHORT) {
         const GLushort (*rgba)[4] = (const GLushort (*)[4]) src;
         GLint i;
         for (i = 0; i < zoomedWidth; i++) {
            GLint j = unzoom_x(ctx->Pixel.ZoomX, imgX, x0 + i) - span->x;
            ASSERT(j >= 0);
            ASSERT(j < (GLint) span->end);
            COPY_4V(zoomed.array->rgba16[i], rgba[j]);
         }
      }
      else {
         const GLfloat (*rgba)[4] = (const GLfloat (*)[4]) src;
         GLint i;
         for (i = 0; i < zoomedWidth; i++) {
            GLint j = unzoom_x(ctx->Pixel.ZoomX, imgX, x0 + i) - span->x;
            ASSERT(j >= 0);
            ASSERT(j < (GLint) span->end);
            COPY_4V(zoomed.array->attribs[VARYING_SLOT_COL0][i], rgba[j]);
         }
      }
   }
   else if (format == GL_RGB) {
      if (zoomed.array->ChanType == GL_UNSIGNED_BYTE) {
         const GLubyte (*rgb)[3] = (const GLubyte (*)[3]) src;
         GLint i;
         for (i = 0; i < zoomedWidth; i++) {
            GLint j = unzoom_x(ctx->Pixel.ZoomX, imgX, x0 + i) - span->x;
            ASSERT(j >= 0);
            ASSERT(j < (GLint) span->end);
            zoomed.array->rgba8[i][0] = rgb[j][0];
            zoomed.array->rgba8[i][1] = rgb[j][1];
            zoomed.array->rgba8[i][2] = rgb[j][2];
            zoomed.array->rgba8[i][3] = 0xff;
         }
      }
      else if (zoomed.array->ChanType == GL_UNSIGNED_SHORT) {
         const GLushort (*rgb)[3] = (const GLushort (*)[3]) src;
         GLint i;
         for (i = 0; i < zoomedWidth; i++) {
            GLint j = unzoom_x(ctx->Pixel.ZoomX, imgX, x0 + i) - span->x;
            ASSERT(j >= 0);
            ASSERT(j < (GLint) span->end);
            zoomed.array->rgba16[i][0] = rgb[j][0];
            zoomed.array->rgba16[i][1] = rgb[j][1];
            zoomed.array->rgba16[i][2] = rgb[j][2];
            zoomed.array->rgba16[i][3] = 0xffff;
         }
      }
      else {
         const GLfloat (*rgb)[3] = (const GLfloat (*)[3]) src;
         GLint i;
         for (i = 0; i < zoomedWidth; i++) {
            GLint j = unzoom_x(ctx->Pixel.ZoomX, imgX, x0 + i) - span->x;
            ASSERT(j >= 0);
            ASSERT(j < (GLint) span->end);
            zoomed.array->attribs[VARYING_SLOT_COL0][i][0] = rgb[j][0];
            zoomed.array->attribs[VARYING_SLOT_COL0][i][1] = rgb[j][1];
            zoomed.array->attribs[VARYING_SLOT_COL0][i][2] = rgb[j][2];
            zoomed.array->attribs[VARYING_SLOT_COL0][i][3] = 1.0F;
         }
      }
   }
   else if (format == GL_DEPTH_COMPONENT) {
      const GLuint *zValues = (const GLuint *) src;
      GLint i;
      for (i = 0; i < zoomedWidth; i++) {
         GLint j = unzoom_x(ctx->Pixel.ZoomX, imgX, x0 + i) - span->x;
         ASSERT(j >= 0);
         ASSERT(j < (GLint) span->end);
         zoomed.array->z[i] = zValues[j];
      }
      /* Now, fall into the RGB path below */
      format = GL_RGBA;
   }

   /* write the span in rows [r0, r1) */
   if (format == GL_RGBA || format == GL_RGB) {
      /* Writing the span may modify the colors, so make a backup now if we're
       * going to call _swrast_write_zoomed_span() more than once.
       * Also, clipping may change the span end value, so store it as well.
       */
      const GLint end = zoomed.end; /* save */
      void *rgbaSave;
      const GLint pixelSize =
         (zoomed.array->ChanType == GL_UNSIGNED_BYTE) ? 4 * sizeof(GLubyte) :
         ((zoomed.array->ChanType == GL_UNSIGNED_SHORT) ? 4 * sizeof(GLushort)
          : 4 * sizeof(GLfloat));

      rgbaSave = malloc(zoomed.end * pixelSize);
      if (!rgbaSave) {
         return;
      }

      if (y1 - y0 > 1) {
         memcpy(rgbaSave, zoomed.array->rgba, zoomed.end * pixelSize);
      }
      for (zoomed.y = y0; zoomed.y < y1; zoomed.y++) {
         _swrast_write_rgba_span(ctx, &zoomed);
         zoomed.end = end;  /* restore */
         if (y1 - y0 > 1) {
            /* restore the colors */
            memcpy(zoomed.array->rgba, rgbaSave, zoomed.end * pixelSize);
         }
      }

      free(rgbaSave);
   }
}


void
_swrast_write_zoomed_rgba_span(struct gl_context *ctx, GLint imgX, GLint imgY,
                               const SWspan *span, const GLvoid *rgba)
{
   zoom_span(ctx, imgX, imgY, span, rgba, GL_RGBA);
}


void
_swrast_write_zoomed_rgb_span(struct gl_context *ctx, GLint imgX, GLint imgY,
                              const SWspan *span, const GLvoid *rgb)
{
   zoom_span(ctx, imgX, imgY, span, rgb, GL_RGB);
}


void
_swrast_write_zoomed_depth_span(struct gl_context *ctx, GLint imgX, GLint imgY,
                                const SWspan *span)
{
   zoom_span(ctx, imgX, imgY, span,
             (const GLvoid *) span->array->z, GL_DEPTH_COMPONENT);
}


/**
 * Zoom/write stencil values.
 * No per-fragment operations are applied.
 */
void
_swrast_write_zoomed_stencil_span(struct gl_context *ctx, GLint imgX, GLint imgY,
                                  GLint width, GLint spanX, GLint spanY,
                                  const GLubyte stencil[])
{
   GLubyte *zoomedVals;
   GLint x0, x1, y0, y1, y;
   GLint i, zoomedWidth;

   if (!compute_zoomed_bounds(ctx, imgX, imgY, spanX, spanY, width,
                              &x0, &x1, &y0, &y1)) {
      return;  /* totally clipped */
   }

   zoomedWidth = x1 - x0;
   ASSERT(zoomedWidth > 0);
   ASSERT(zoomedWidth <= SWRAST_MAX_WIDTH);

   zoomedVals = malloc(zoomedWidth * sizeof(GLubyte));
   if (!zoomedVals)
      return;

   /* zoom the span horizontally */
   for (i = 0; i < zoomedWidth; i++) {
      GLint j = unzoom_x(ctx->Pixel.ZoomX, imgX, x0 + i) - spanX;
      ASSERT(j >= 0);
      ASSERT(j < width);
      zoomedVals[i] = stencil[j];
   }

   /* write the zoomed spans */
   for (y = y0; y < y1; y++) {
      _swrast_write_stencil_span(ctx, zoomedWidth, x0, y, zoomedVals);
   }

   free(zoomedVals);
}


/**
 * Zoom/write 32-bit Z values.
 * No per-fragment operations are applied.
 */
void
_swrast_write_zoomed_z_span(struct gl_context *ctx, GLint imgX, GLint imgY,
                            GLint width, GLint spanX, GLint spanY,
                            const GLuint *zVals)
{
   struct gl_renderbuffer *rb =
      ctx->DrawBuffer->Attachment[BUFFER_DEPTH].Renderbuffer;
   GLuint *zoomedVals;
   GLint x0, x1, y0, y1, y;
   GLint i, zoomedWidth;

   if (!compute_zoomed_bounds(ctx, imgX, imgY, spanX, spanY, width,
                              &x0, &x1, &y0, &y1)) {
      return;  /* totally clipped */
   }

   zoomedWidth = x1 - x0;
   ASSERT(zoomedWidth > 0);
   ASSERT(zoomedWidth <= SWRAST_MAX_WIDTH);

   zoomedVals = malloc(zoomedWidth * sizeof(GLuint));
   if (!zoomedVals)
      return;

   /* zoom the span horizontally */
   for (i = 0; i < zoomedWidth; i++) {
      GLint j = unzoom_x(ctx->Pixel.ZoomX, imgX, x0 + i) - spanX;
      ASSERT(j >= 0);
      ASSERT(j < width);
      zoomedVals[i] = zVals[j];
   }

   /* write the zoomed spans */
   for (y = y0; y < y1; y++) {
      GLubyte *dst = _swrast_pixel_address(rb, x0, y);
      _mesa_pack_uint_z_row(rb->Format, zoomedWidth, zoomedVals, dst);
   }

   free(zoomedVals);
}
@


1.6
log
@Merge Mesa 9.2.0
@
text
@@


1.5
log
@Merge Mesa 7.10.3
@
text
@a2 1
 * Version:  7.1
d19 4
a22 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
d28 1
d109 1
a109 1
static INLINE GLint
d146 1
a146 1
      swrast->ZoomedArrays = (SWspanarrays *) CALLOC(sizeof(SWspanarrays));
d153 1
a153 1
   ASSERT(zoomedWidth <= MAX_WIDTH);
d169 1
a169 1
      zoomed.array->rgba = (GLchan (*)[4]) zoomed.array->attribs[FRAG_ATTRIB_COL0];
d171 7
a177 7
   COPY_4V(zoomed.attrStart[FRAG_ATTRIB_WPOS], span->attrStart[FRAG_ATTRIB_WPOS]);
   COPY_4V(zoomed.attrStepX[FRAG_ATTRIB_WPOS], span->attrStepX[FRAG_ATTRIB_WPOS]);
   COPY_4V(zoomed.attrStepY[FRAG_ATTRIB_WPOS], span->attrStepY[FRAG_ATTRIB_WPOS]);

   zoomed.attrStart[FRAG_ATTRIB_FOGC][0] = span->attrStart[FRAG_ATTRIB_FOGC][0];
   zoomed.attrStepX[FRAG_ATTRIB_FOGC][0] = span->attrStepX[FRAG_ATTRIB_FOGC][0];
   zoomed.attrStepY[FRAG_ATTRIB_FOGC][0] = span->attrStepY[FRAG_ATTRIB_FOGC][0];
d186 1
a186 1
      zoomed.arrayAttribs |= FRAG_BIT_COL0;  /* we'll produce these values */
d237 2
a238 2
            ASSERT(j < span->end);
            COPY_4V(zoomed.array->attribs[FRAG_ATTRIB_COL0][i], rgba[j]);
d275 5
a279 5
            ASSERT(j < span->end);
            zoomed.array->attribs[FRAG_ATTRIB_COL0][i][0] = rgb[j][0];
            zoomed.array->attribs[FRAG_ATTRIB_COL0][i][1] = rgb[j][1];
            zoomed.array->attribs[FRAG_ATTRIB_COL0][i][2] = rgb[j][2];
            zoomed.array->attribs[FRAG_ATTRIB_COL0][i][3] = 1.0F;
d303 1
a303 1
      GLuint rgbaSave[MAX_WIDTH][4];
d308 6
d325 2
d363 1
a363 1
                                  const GLstencil stencil[])
d365 1
a365 1
   GLstencil zoomedVals[MAX_WIDTH];
d376 5
a380 1
   ASSERT(zoomedWidth <= MAX_WIDTH);
d394 2
d400 1
a400 1
 * Zoom/write z values (16 or 32-bit).
d406 1
a406 1
                            const GLvoid *z)
d408 3
a410 3
   struct gl_renderbuffer *rb = ctx->DrawBuffer->_DepthBuffer;
   GLushort zoomedVals16[MAX_WIDTH];
   GLuint zoomedVals32[MAX_WIDTH];
d421 5
a425 1
   ASSERT(zoomedWidth <= MAX_WIDTH);
d428 5
a432 18
   if (rb->DataType == GL_UNSIGNED_SHORT) {
      for (i = 0; i < zoomedWidth; i++) {
         GLint j = unzoom_x(ctx->Pixel.ZoomX, imgX, x0 + i) - spanX;
         ASSERT(j >= 0);
         ASSERT(j < width);
         zoomedVals16[i] = ((GLushort *) z)[j];
      }
      z = zoomedVals16;
   }
   else {
      ASSERT(rb->DataType == GL_UNSIGNED_INT);
      for (i = 0; i < zoomedWidth; i++) {
         GLint j = unzoom_x(ctx->Pixel.ZoomX, imgX, x0 + i) - spanX;
         ASSERT(j >= 0);
         ASSERT(j < width);
         zoomedVals32[i] = ((GLuint *) z)[j];
      }
      z = zoomedVals32;
d437 2
a438 1
      rb->PutRow(ctx, rb, zoomedWidth, x0, y, z, NULL);
d440 2
@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d48 1
a48 1
compute_zoomed_bounds(GLcontext *ctx, GLint imageX, GLint imageY,
d130 1
a130 1
zoom_span( GLcontext *ctx, GLint imgX, GLint imgY, const SWspan *span,
d323 1
a323 1
_swrast_write_zoomed_rgba_span(GLcontext *ctx, GLint imgX, GLint imgY,
d331 1
a331 1
_swrast_write_zoomed_rgb_span(GLcontext *ctx, GLint imgX, GLint imgY,
d339 1
a339 1
_swrast_write_zoomed_depth_span(GLcontext *ctx, GLint imgX, GLint imgY,
d352 1
a352 1
_swrast_write_zoomed_stencil_span(GLcontext *ctx, GLint imgX, GLint imgY,
d389 1
a389 1
_swrast_write_zoomed_z_span(GLcontext *ctx, GLint imgX, GLint imgY,
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@a187 9
   else if (format == GL_COLOR_INDEX) {
      /* copy Z info */
      zoomed.z = span->z;
      zoomed.zStep = span->zStep;
      /* we'll generate an array of color indexes */
      zoomed.interpMask = span->interpMask & ~SPAN_INDEX;
      zoomed.arrayMask |= SPAN_INDEX;
      ASSERT(span->arrayMask & SPAN_INDEX);
   }
a281 10
   else if (format == GL_COLOR_INDEX) {
      const GLuint *indexes = (const GLuint *) src;
      GLint i;
      for (i = 0; i < zoomedWidth; i++) {
         GLint j = unzoom_x(ctx->Pixel.ZoomX, imgX, x0 + i) - span->x;
         ASSERT(j >= 0);
         ASSERT(j < (GLint) span->end);
         zoomed.array->index[i] = indexes[j];
      }
   }
d291 2
a292 2
      /* Now, fall into either the RGB or COLOR_INDEX path below */
      format = ctx->Visual.rgbMode ? GL_RGBA : GL_COLOR_INDEX;
d308 1
a308 1
         MEMCPY(rgbaSave, zoomed.array->rgba, zoomed.end * pixelSize);
d315 1
a315 17
            MEMCPY(zoomed.array->rgba, rgbaSave, zoomed.end * pixelSize);
         }
      }
   }
   else if (format == GL_COLOR_INDEX) {
      /* use specular color array for temp storage */
      GLuint *indexSave = (GLuint *) zoomed.array->attribs[FRAG_ATTRIB_FOGC];
      const GLint end = zoomed.end; /* save */
      if (y1 - y0 > 1) {
         MEMCPY(indexSave, zoomed.array->index, zoomed.end * sizeof(GLuint));
      }
      for (zoomed.y = y0; zoomed.y < y1; zoomed.y++) {
         _swrast_write_index_span(ctx, &zoomed);
         zoomed.end = end;  /* restore */
         if (y1 - y0 > 1) {
            /* restore the colors */
            MEMCPY(zoomed.array->index, indexSave, zoomed.end * sizeof(GLuint));
a334 9
}


void
_swrast_write_zoomed_index_span(GLcontext *ctx, GLint imgX, GLint imgY,
                                const SWspan *span)
{
   zoom_span(ctx, imgX, imgY, span,
             (const GLvoid *) span->array->index, GL_COLOR_INDEX);
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d25 4
a28 4
#include "glheader.h"
#include "macros.h"
#include "imports.h"
#include "colormac.h"
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * Version:  6.5
d5 1
a5 1
 * Copyright (C) 1999-2005  Brian Paul   All Rights Reserved.
d40 1
a40 1
 * \param imageX, imageY  position of the overall image being drawn
d42 1
d102 5
a106 1
 * Can use this for unzooming X or Y values.
d116 4
a119 1
   GLint x = imageX + (GLint) ((zx - imageX) / zoomX);
d130 1
a130 1
zoom_span( GLcontext *ctx, GLint imgX, GLint imgY, const struct sw_span *span,
d133 2
a134 2
   struct sw_span zoomed;
   struct span_arrays zoomed_arrays;  /* this is big! */
d143 7
d158 1
a158 1
   INIT_SPAN(zoomed, GL_BITMAP, 0, 0, 0);
d161 16
a176 6
   zoomed.array = &zoomed_arrays;

   /* copy fog interp info */
   zoomed.fog = span->fog;
   zoomed.fogStep = span->fogStep;
   /* XXX copy texcoord info? */
d185 1
d219 29
a247 7
      const GLchan (*rgba)[4] = (const GLchan (*)[4]) src;
      GLint i;
      for (i = 0; i < zoomedWidth; i++) {
         GLint j = unzoom_x(ctx->Pixel.ZoomX, imgX, x0 + i) - span->x;
         ASSERT(j >= 0);
         ASSERT(j < span->end);
         COPY_CHAN4(zoomed.array->rgba[i], rgba[j]);
d251 38
a288 10
      const GLchan (*rgb)[3] = (const GLchan (*)[3]) src;
      GLint i;
      for (i = 0; i < zoomedWidth; i++) {
         GLint j = unzoom_x(ctx->Pixel.ZoomX, imgX, x0 + i) - span->x;
         ASSERT(j >= 0);
         ASSERT(j < span->end);
         zoomed.array->rgba[i][0] = rgb[j][0];
         zoomed.array->rgba[i][1] = rgb[j][1];
         zoomed.array->rgba[i][2] = rgb[j][2];
         zoomed.array->rgba[i][3] = CHAN_MAX;
d297 1
a297 1
         ASSERT(j < span->end);
d307 1
a307 1
         ASSERT(j < span->end);
a319 1
      GLchan rgbaSave[MAX_WIDTH][4];
d321 5
d327 1
a327 1
         MEMCPY(rgbaSave, zoomed.array->rgba, zoomed.end * 4 * sizeof(GLchan));
d334 1
a334 1
            MEMCPY(zoomed.array->rgba, rgbaSave, zoomed.end*4 * sizeof(GLchan));
d339 2
a340 1
      GLuint indexSave[MAX_WIDTH];
d358 2
a359 3
_swrast_write_zoomed_rgba_span( GLcontext *ctx, GLint imgX, GLint imgY,
                               const struct sw_span *span,
                               CONST GLchan rgba[][4])
d361 1
a361 1
   zoom_span(ctx, imgX, imgY, span, (const GLvoid *) rgba, GL_RGBA);
d367 1
a367 2
                              const struct sw_span *span,
                              CONST GLchan rgb[][3])
d369 1
a369 1
   zoom_span(ctx, imgX, imgY, span, (const GLvoid *) rgb, GL_RGB);
d375 1
a375 1
                                const struct sw_span *span)
d384 1
a384 1
                                const struct sw_span *span)
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d3 1
a3 1
 * Version:  6.5.2
d5 1
a5 1
 * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
d122 1
a122 1
zoom_span( GLcontext *ctx, GLint imgX, GLint imgY, const SWspan *span,
d125 2
a126 2
   SWspan zoomed;
   SWspanarrays zoomed_arrays;  /* this is big! */
a146 13
   zoomed_arrays.ChanType = span->array->ChanType;
   /* XXX temporary */
#if CHAN_TYPE == GL_UNSIGNED_BYTE
   zoomed_arrays.rgba = zoomed_arrays.color.sz1.rgba;
   zoomed_arrays.spec = zoomed_arrays.color.sz1.spec;
#elif CHAN_TYPE == GL_UNSIGNED_SHORT
   zoomed_arrays.rgba = zoomed_arrays.color.sz2.rgba;
   zoomed_arrays.spec = zoomed_arrays.color.sz2.spec;
#else
   zoomed_arrays.rgba = zoomed_arrays.color.sz4.rgba;
   zoomed_arrays.spec = zoomed_arrays.color.sz4.spec;
#endif

d193 7
a199 29
      if (zoomed.array->ChanType == GL_UNSIGNED_BYTE) {
         const GLubyte (*rgba)[4] = (const GLubyte (*)[4]) src;
         GLint i;
         for (i = 0; i < zoomedWidth; i++) {
            GLint j = unzoom_x(ctx->Pixel.ZoomX, imgX, x0 + i) - span->x;
            ASSERT(j >= 0);
            ASSERT(j < span->end);
            COPY_4UBV(zoomed.array->color.sz1.rgba[i], rgba[j]);
         }
      }
      else if (zoomed.array->ChanType == GL_UNSIGNED_SHORT) {
         const GLushort (*rgba)[4] = (const GLushort (*)[4]) src;
         GLint i;
         for (i = 0; i < zoomedWidth; i++) {
            GLint j = unzoom_x(ctx->Pixel.ZoomX, imgX, x0 + i) - span->x;
            ASSERT(j >= 0);
            ASSERT(j < span->end);
            COPY_4V(zoomed.array->color.sz2.rgba[i], rgba[j]);
         }
      }
      else {
         const GLfloat (*rgba)[4] = (const GLfloat (*)[4]) src;
         GLint i;
         for (i = 0; i < zoomedWidth; i++) {
            GLint j = unzoom_x(ctx->Pixel.ZoomX, imgX, x0 + i) - span->x;
            ASSERT(j >= 0);
            ASSERT(j < span->end);
            COPY_4V(zoomed.array->color.sz4.rgba[i], rgba[j]);
         }
d203 10
a212 38
      if (zoomed.array->ChanType == GL_UNSIGNED_BYTE) {
         const GLubyte (*rgb)[3] = (const GLubyte (*)[3]) src;
         GLint i;
         for (i = 0; i < zoomedWidth; i++) {
            GLint j = unzoom_x(ctx->Pixel.ZoomX, imgX, x0 + i) - span->x;
            ASSERT(j >= 0);
            ASSERT(j < span->end);
            zoomed.array->color.sz1.rgba[i][0] = rgb[j][0];
            zoomed.array->color.sz1.rgba[i][1] = rgb[j][1];
            zoomed.array->color.sz1.rgba[i][2] = rgb[j][2];
            zoomed.array->color.sz1.rgba[i][3] = 0xff;
         }
      }
      else if (zoomed.array->ChanType == GL_UNSIGNED_SHORT) {
         const GLushort (*rgb)[3] = (const GLushort (*)[3]) src;
         GLint i;
         for (i = 0; i < zoomedWidth; i++) {
            GLint j = unzoom_x(ctx->Pixel.ZoomX, imgX, x0 + i) - span->x;
            ASSERT(j >= 0);
            ASSERT(j < span->end);
            zoomed.array->color.sz2.rgba[i][0] = rgb[j][0];
            zoomed.array->color.sz2.rgba[i][1] = rgb[j][1];
            zoomed.array->color.sz2.rgba[i][2] = rgb[j][2];
            zoomed.array->color.sz2.rgba[i][3] = 0xffff;
         }
      }
      else {
         const GLfloat (*rgb)[3] = (const GLfloat (*)[3]) src;
         GLint i;
         for (i = 0; i < zoomedWidth; i++) {
            GLint j = unzoom_x(ctx->Pixel.ZoomX, imgX, x0 + i) - span->x;
            ASSERT(j >= 0);
            ASSERT(j < span->end);
            zoomed.array->color.sz4.rgba[i][0] = rgb[j][0];
            zoomed.array->color.sz4.rgba[i][1] = rgb[j][1];
            zoomed.array->color.sz4.rgba[i][2] = rgb[j][2];
            zoomed.array->color.sz4.rgba[i][3] = 1.0F;
         }
d244 1
a245 6
      /* use specular color array for temp storage */
      void *rgbaSave = zoomed.array->spec;
      const GLint pixelSize =
         (zoomed.array->ChanType == GL_UNSIGNED_BYTE) ? 4 * sizeof(GLubyte) :
         ((zoomed.array->ChanType == GL_UNSIGNED_SHORT) ? 4 * sizeof(GLushort)
          : 4 * sizeof(GLfloat));
d247 1
a247 1
         MEMCPY(rgbaSave, zoomed.array->rgba, zoomed.end * pixelSize);
d254 1
a254 1
            MEMCPY(zoomed.array->rgba, rgbaSave, zoomed.end * pixelSize);
d259 1
a259 2
      /* use specular color array for temp storage */
      GLuint *indexSave = (GLuint *) zoomed.array->spec;
d277 3
a279 2
_swrast_write_zoomed_rgba_span(GLcontext *ctx, GLint imgX, GLint imgY,
                               const SWspan *span, const GLvoid *rgba)
d281 1
a281 1
   zoom_span(ctx, imgX, imgY, span, rgba, GL_RGBA);
d287 2
a288 1
                              const SWspan *span, const GLvoid *rgb)
d290 1
a290 1
   zoom_span(ctx, imgX, imgY, span, rgb, GL_RGB);
d296 1
a296 1
                                const SWspan *span)
d305 1
a305 1
                                const SWspan *span)
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d40 1
a40 1
 * \param imageX, imageY  position of the mage being drawn (gl WindowPos)
a41 1
 * \param width  number of pixels in span
d101 1
a101 5
 * Convert a zoomed x image coordinate back to an unzoomed x coord.
 * 'zx' is screen position of a pixel in the zoomed image, who's left edge
 * is at 'imageX'.
 * return corresponding x coord in the original, unzoomed image.
 * This can use this for unzooming X or Y values.
d111 1
a111 4
   GLint x;
   if (zoomX < 0.0)
      zx++;
   x = imageX + (GLint) ((zx - imageX) / zoomX);
d156 2
a157 2
   zoomed_arrays.rgba = zoomed_arrays.attribs[FRAG_ATTRIB_COL0];
   zoomed_arrays.spec = zoomed_arrays.attribs[FRAG_ATTRIB_COL1];
d162 2
a163 3
   zoomed.attrStart[FRAG_ATTRIB_FOGC][0] = span->attrStart[FRAG_ATTRIB_FOGC][0];
   zoomed.attrStepX[FRAG_ATTRIB_FOGC][0] = span->attrStepX[FRAG_ATTRIB_FOGC][0];
   zoomed.attrStepY[FRAG_ATTRIB_FOGC][0] = span->attrStepY[FRAG_ATTRIB_FOGC][0];
d212 1
a212 1
            ASSERT(j < (GLint) span->end);
d222 1
a222 1
            ASSERT(j < (GLint) span->end);
d233 1
a233 1
            COPY_4V(zoomed.array->attribs[FRAG_ATTRIB_COL0][i], rgba[j]);
d244 1
a244 1
            ASSERT(j < (GLint) span->end);
d257 1
a257 1
            ASSERT(j < (GLint) span->end);
d271 4
a274 4
            zoomed.array->attribs[FRAG_ATTRIB_COL0][i][0] = rgb[j][0];
            zoomed.array->attribs[FRAG_ATTRIB_COL0][i][1] = rgb[j][1];
            zoomed.array->attribs[FRAG_ATTRIB_COL0][i][2] = rgb[j][2];
            zoomed.array->attribs[FRAG_ATTRIB_COL0][i][3] = 1.0F;
d284 1
a284 1
         ASSERT(j < (GLint) span->end);
d294 1
a294 1
         ASSERT(j < (GLint) span->end);
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d3 1
a3 1
 * Version:  7.1
d5 1
a5 1
 * Copyright (C) 1999-2008  Brian Paul   All Rights Reserved.
d25 4
a28 4
#include "main/glheader.h"
#include "main/macros.h"
#include "main/imports.h"
#include "main/colormac.h"
d48 1
a48 1
compute_zoomed_bounds(struct gl_context *ctx, GLint imageX, GLint imageY,
d130 1
a130 1
zoom_span( struct gl_context *ctx, GLint imgX, GLint imgY, const SWspan *span,
a132 1
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
d134 1
a142 7
   if (!swrast->ZoomedArrays) {
      /* allocate on demand */
      swrast->ZoomedArrays = (SWspanarrays *) CALLOC(sizeof(SWspanarrays));
      if (!swrast->ZoomedArrays)
         return;
   }

d151 1
a151 1
   INIT_SPAN(zoomed, GL_BITMAP);
d154 13
a166 12
   zoomed.array = swrast->ZoomedArrays;
   zoomed.array->ChanType = span->array->ChanType;
   if (zoomed.array->ChanType == GL_UNSIGNED_BYTE)
      zoomed.array->rgba = (GLchan (*)[4]) zoomed.array->rgba8;
   else if (zoomed.array->ChanType == GL_UNSIGNED_SHORT)
      zoomed.array->rgba = (GLchan (*)[4]) zoomed.array->rgba16;
   else
      zoomed.array->rgba = (GLchan (*)[4]) zoomed.array->attribs[FRAG_ATTRIB_COL0];

   COPY_4V(zoomed.attrStart[FRAG_ATTRIB_WPOS], span->attrStart[FRAG_ATTRIB_WPOS]);
   COPY_4V(zoomed.attrStepX[FRAG_ATTRIB_WPOS], span->attrStepX[FRAG_ATTRIB_WPOS]);
   COPY_4V(zoomed.attrStepY[FRAG_ATTRIB_WPOS], span->attrStepY[FRAG_ATTRIB_WPOS]);
d168 2
d173 1
a181 1
      zoomed.arrayAttribs |= FRAG_BIT_COL0;  /* we'll produce these values */
d184 9
d222 1
a222 1
            COPY_4UBV(zoomed.array->rgba8[i], rgba[j]);
d232 1
a232 1
            COPY_4V(zoomed.array->rgba16[i], rgba[j]);
d254 4
a257 4
            zoomed.array->rgba8[i][0] = rgb[j][0];
            zoomed.array->rgba8[i][1] = rgb[j][1];
            zoomed.array->rgba8[i][2] = rgb[j][2];
            zoomed.array->rgba8[i][3] = 0xff;
d267 4
a270 4
            zoomed.array->rgba16[i][0] = rgb[j][0];
            zoomed.array->rgba16[i][1] = rgb[j][1];
            zoomed.array->rgba16[i][2] = rgb[j][2];
            zoomed.array->rgba16[i][3] = 0xffff;
d287 10
d306 2
a307 2
      /* Now, fall into the RGB path below */
      format = GL_RGBA;
d317 2
a318 1
      GLuint rgbaSave[MAX_WIDTH][4];
d324 1
a324 1
         memcpy(rgbaSave, zoomed.array->rgba, zoomed.end * pixelSize);
d331 17
a347 1
            memcpy(zoomed.array->rgba, rgbaSave, zoomed.end * pixelSize);
d355 1
a355 1
_swrast_write_zoomed_rgba_span(struct gl_context *ctx, GLint imgX, GLint imgY,
d363 1
a363 1
_swrast_write_zoomed_rgb_span(struct gl_context *ctx, GLint imgX, GLint imgY,
d371 10
a380 1
_swrast_write_zoomed_depth_span(struct gl_context *ctx, GLint imgX, GLint imgY,
d393 1
a393 1
_swrast_write_zoomed_stencil_span(struct gl_context *ctx, GLint imgX, GLint imgY,
d430 1
a430 1
_swrast_write_zoomed_z_span(struct gl_context *ctx, GLint imgX, GLint imgY,
@


1.1.1.5
log
@Import Mesa 9.2.0
@
text
@d3 1
d20 3
a22 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
a27 1
#include "main/format_pack.h"
d108 1
a108 1
static inline GLint
d145 1
a145 1
      swrast->ZoomedArrays = (SWspanarrays *) calloc(1, sizeof(SWspanarrays));
d152 1
a152 1
   ASSERT(zoomedWidth <= SWRAST_MAX_WIDTH);
d168 1
a168 1
      zoomed.array->rgba = (GLchan (*)[4]) zoomed.array->attribs[VARYING_SLOT_COL0];
d170 7
a176 7
   COPY_4V(zoomed.attrStart[VARYING_SLOT_POS], span->attrStart[VARYING_SLOT_POS]);
   COPY_4V(zoomed.attrStepX[VARYING_SLOT_POS], span->attrStepX[VARYING_SLOT_POS]);
   COPY_4V(zoomed.attrStepY[VARYING_SLOT_POS], span->attrStepY[VARYING_SLOT_POS]);

   zoomed.attrStart[VARYING_SLOT_FOGC][0] = span->attrStart[VARYING_SLOT_FOGC][0];
   zoomed.attrStepX[VARYING_SLOT_FOGC][0] = span->attrStepX[VARYING_SLOT_FOGC][0];
   zoomed.attrStepY[VARYING_SLOT_FOGC][0] = span->attrStepY[VARYING_SLOT_FOGC][0];
d185 1
a185 1
      zoomed.arrayAttribs |= VARYING_BIT_COL0;  /* we'll produce these values */
d236 2
a237 2
            ASSERT(j < (GLint) span->end);
            COPY_4V(zoomed.array->attribs[VARYING_SLOT_COL0][i], rgba[j]);
d274 5
a278 5
            ASSERT(j < (GLint) span->end);
            zoomed.array->attribs[VARYING_SLOT_COL0][i][0] = rgb[j][0];
            zoomed.array->attribs[VARYING_SLOT_COL0][i][1] = rgb[j][1];
            zoomed.array->attribs[VARYING_SLOT_COL0][i][2] = rgb[j][2];
            zoomed.array->attribs[VARYING_SLOT_COL0][i][3] = 1.0F;
d302 1
a302 1
      void *rgbaSave;
a306 6

      rgbaSave = malloc(zoomed.end * pixelSize);
      if (!rgbaSave) {
         return;
      }

a317 2

      free(rgbaSave);
d354 1
a354 1
                                  const GLubyte stencil[])
d356 1
a356 1
   GLubyte *zoomedVals;
d367 1
a367 5
   ASSERT(zoomedWidth <= SWRAST_MAX_WIDTH);

   zoomedVals = malloc(zoomedWidth * sizeof(GLubyte));
   if (!zoomedVals)
      return;
a380 2

   free(zoomedVals);
d385 1
a385 1
 * Zoom/write 32-bit Z values.
d391 1
a391 1
                            const GLuint *zVals)
d393 3
a395 3
   struct gl_renderbuffer *rb =
      ctx->DrawBuffer->Attachment[BUFFER_DEPTH].Renderbuffer;
   GLuint *zoomedVals;
d406 1
a406 5
   ASSERT(zoomedWidth <= SWRAST_MAX_WIDTH);

   zoomedVals = malloc(zoomedWidth * sizeof(GLuint));
   if (!zoomedVals)
      return;
d409 18
a426 5
   for (i = 0; i < zoomedWidth; i++) {
      GLint j = unzoom_x(ctx->Pixel.ZoomX, imgX, x0 + i) - spanX;
      ASSERT(j >= 0);
      ASSERT(j < width);
      zoomedVals[i] = zVals[j];
d431 1
a431 2
      GLubyte *dst = _swrast_pixel_address(rb, x0, y);
      _mesa_pack_uint_z_row(rb->Format, zoomedWidth, zoomedVals, dst);
a432 2

   free(zoomedVals);
@


