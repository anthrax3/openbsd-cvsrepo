head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.8
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.6
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.5
	v10_2_7:1.1.1.5
	OPENBSD_5_6:1.6.0.4
	OPENBSD_5_6_BASE:1.6
	v10_2_3:1.1.1.5
	OPENBSD_5_5:1.6.0.2
	OPENBSD_5_5_BASE:1.6
	v9_2_5:1.1.1.5
	v9_2_3:1.1.1.5
	v9_2_2:1.1.1.5
	v9_2_1:1.1.1.5
	v9_2_0:1.1.1.5
	OPENBSD_5_4:1.5.0.8
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.6
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.6
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.4
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.12.23.05.17.54;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2013.09.05.14.06.47;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.23.13.37.45;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.34;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.14.58.22;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.05.31.16.36.49;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.51.15;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.51.15;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.56.49;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.32.04;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.48;	author matthieu;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.09.05.13.17.28;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */


/*
 * Antialiased Triangle Rasterizer Template
 *
 * This file is #include'd to generate custom AA triangle rasterizers.
 * NOTE: this code hasn't been optimized yet.  That'll come after it
 * works correctly.
 *
 * The following macros may be defined to indicate what auxillary information
 * must be copmuted across the triangle:
 *    DO_Z         - if defined, compute Z values
 *    DO_ATTRIBS   - if defined, compute texcoords, varying, etc.
 */

/*void triangle( struct gl_context *ctx, GLuint v0, GLuint v1, GLuint v2, GLuint pv )*/
{
   const SWcontext *swrast = SWRAST_CONTEXT(ctx);
   const GLfloat *p0 = v0->attrib[VARYING_SLOT_POS];
   const GLfloat *p1 = v1->attrib[VARYING_SLOT_POS];
   const GLfloat *p2 = v2->attrib[VARYING_SLOT_POS];
   const SWvertex *vMin, *vMid, *vMax;
   GLint iyMin, iyMax;
   GLfloat yMin, yMax;
   GLboolean ltor;
   GLfloat majDx, majDy;  /* major (i.e. long) edge dx and dy */
   
   SWspan span;
   
#ifdef DO_Z
   GLfloat zPlane[4];
#endif
   GLfloat rPlane[4], gPlane[4], bPlane[4], aPlane[4];
#if defined(DO_ATTRIBS)
   GLfloat attrPlane[VARYING_SLOT_MAX][4][4];
   GLfloat wPlane[4];  /* win[3] */
#endif
   GLfloat bf = SWRAST_CONTEXT(ctx)->_BackfaceCullSign;
   
   (void) swrast;

   INIT_SPAN(span, GL_POLYGON);
   span.arrayMask = SPAN_COVERAGE;

   /* determine bottom to top order of vertices */
   {
      GLfloat y0 = v0->attrib[VARYING_SLOT_POS][1];
      GLfloat y1 = v1->attrib[VARYING_SLOT_POS][1];
      GLfloat y2 = v2->attrib[VARYING_SLOT_POS][1];
      if (y0 <= y1) {
	 if (y1 <= y2) {
	    vMin = v0;   vMid = v1;   vMax = v2;   /* y0<=y1<=y2 */
	 }
	 else if (y2 <= y0) {
	    vMin = v2;   vMid = v0;   vMax = v1;   /* y2<=y0<=y1 */
	 }
	 else {
	    vMin = v0;   vMid = v2;   vMax = v1;  bf = -bf; /* y0<=y2<=y1 */
	 }
      }
      else {
	 if (y0 <= y2) {
	    vMin = v1;   vMid = v0;   vMax = v2;  bf = -bf; /* y1<=y0<=y2 */
	 }
	 else if (y2 <= y1) {
	    vMin = v2;   vMid = v1;   vMax = v0;  bf = -bf; /* y2<=y1<=y0 */
	 }
	 else {
	    vMin = v1;   vMid = v2;   vMax = v0;   /* y1<=y2<=y0 */
	 }
      }
   }

   majDx = vMax->attrib[VARYING_SLOT_POS][0] - vMin->attrib[VARYING_SLOT_POS][0];
   majDy = vMax->attrib[VARYING_SLOT_POS][1] - vMin->attrib[VARYING_SLOT_POS][1];

   /* front/back-face determination and cullling */
   {
      const GLfloat botDx = vMid->attrib[VARYING_SLOT_POS][0] - vMin->attrib[VARYING_SLOT_POS][0];
      const GLfloat botDy = vMid->attrib[VARYING_SLOT_POS][1] - vMin->attrib[VARYING_SLOT_POS][1];
      const GLfloat area = majDx * botDy - botDx * majDy;
      /* Do backface culling */
      if (area * bf < 0 || area == 0 || IS_INF_OR_NAN(area))
	 return;
      ltor = (GLboolean) (area < 0.0F);

      span.facing = area * swrast->_BackfaceSign > 0.0F;
   }

   /* Plane equation setup:
    * We evaluate plane equations at window (x,y) coordinates in order
    * to compute color, Z, fog, texcoords, etc.  This isn't terribly
    * efficient but it's easy and reliable.
    */
#ifdef DO_Z
   compute_plane(p0, p1, p2, p0[2], p1[2], p2[2], zPlane);
   span.arrayMask |= SPAN_Z;
#endif
   if (ctx->Light.ShadeModel == GL_SMOOTH) {
      compute_plane(p0, p1, p2, v0->color[RCOMP], v1->color[RCOMP], v2->color[RCOMP], rPlane);
      compute_plane(p0, p1, p2, v0->color[GCOMP], v1->color[GCOMP], v2->color[GCOMP], gPlane);
      compute_plane(p0, p1, p2, v0->color[BCOMP], v1->color[BCOMP], v2->color[BCOMP], bPlane);
      compute_plane(p0, p1, p2, v0->color[ACOMP], v1->color[ACOMP], v2->color[ACOMP], aPlane);
   }
   else {
      constant_plane(v2->color[RCOMP], rPlane);
      constant_plane(v2->color[GCOMP], gPlane);
      constant_plane(v2->color[BCOMP], bPlane);
      constant_plane(v2->color[ACOMP], aPlane);
   }
   span.arrayMask |= SPAN_RGBA;
#if defined(DO_ATTRIBS)
   {
      const GLfloat invW0 = v0->attrib[VARYING_SLOT_POS][3];
      const GLfloat invW1 = v1->attrib[VARYING_SLOT_POS][3];
      const GLfloat invW2 = v2->attrib[VARYING_SLOT_POS][3];
      compute_plane(p0, p1, p2, invW0, invW1, invW2, wPlane);
      span.attrStepX[VARYING_SLOT_POS][3] = plane_dx(wPlane);
      span.attrStepY[VARYING_SLOT_POS][3] = plane_dy(wPlane);
      ATTRIB_LOOP_BEGIN
         GLuint c;
         if (swrast->_InterpMode[attr] == GL_FLAT) {
            for (c = 0; c < 4; c++) {
               constant_plane(v2->attrib[attr][c] * invW2, attrPlane[attr][c]);
            }
         }
         else {
            for (c = 0; c < 4; c++) {
               const GLfloat a0 = v0->attrib[attr][c] * invW0;
               const GLfloat a1 = v1->attrib[attr][c] * invW1;
               const GLfloat a2 = v2->attrib[attr][c] * invW2;
               compute_plane(p0, p1, p2, a0, a1, a2, attrPlane[attr][c]);
            }
         }
         for (c = 0; c < 4; c++) {
            span.attrStepX[attr][c] = plane_dx(attrPlane[attr][c]);
            span.attrStepY[attr][c] = plane_dy(attrPlane[attr][c]);
         }
      ATTRIB_LOOP_END
   }
#endif

   /* Begin bottom-to-top scan over the triangle.
    * The long edge will either be on the left or right side of the
    * triangle.  We always scan from the long edge toward the shorter
    * edges, stopping when we find that coverage = 0.  If the long edge
    * is on the left we scan left-to-right.  Else, we scan right-to-left.
    */
   yMin = vMin->attrib[VARYING_SLOT_POS][1];
   yMax = vMax->attrib[VARYING_SLOT_POS][1];
   iyMin = (GLint) yMin;
   iyMax = (GLint) yMax + 1;

   if (ltor) {
      /* scan left to right */
      const GLfloat *pMin = vMin->attrib[VARYING_SLOT_POS];
      const GLfloat *pMid = vMid->attrib[VARYING_SLOT_POS];
      const GLfloat *pMax = vMax->attrib[VARYING_SLOT_POS];
      const GLfloat dxdy = majDx / majDy;
      const GLfloat xAdj = dxdy < 0.0F ? -dxdy : 0.0F;
      GLint iy;
#ifdef _OPENMP
#pragma omp parallel for schedule(dynamic) private(iy) firstprivate(span)
#endif
      for (iy = iyMin; iy < iyMax; iy++) {
         GLfloat x = pMin[0] - (yMin - iy) * dxdy;
         GLint ix, startX = (GLint) (x - xAdj);
         GLuint count;
         GLfloat coverage = 0.0F;

#ifdef _OPENMP
         /* each thread needs to use a different (global) SpanArrays variable */
         span.array = SWRAST_CONTEXT(ctx)->SpanArrays + omp_get_thread_num();
#endif
         /* skip over fragments with zero coverage */
         while (startX < SWRAST_MAX_WIDTH) {
            coverage = compute_coveragef(pMin, pMid, pMax, startX, iy);
            if (coverage > 0.0F)
               break;
            startX++;
         }

         /* enter interior of triangle */
         ix = startX;

#if defined(DO_ATTRIBS)
         /* compute attributes at left-most fragment */
         span.attrStart[VARYING_SLOT_POS][3] = solve_plane(ix + 0.5F, iy + 0.5F, wPlane);
         ATTRIB_LOOP_BEGIN
            GLuint c;
            for (c = 0; c < 4; c++) {
               span.attrStart[attr][c] = solve_plane(ix + 0.5F, iy + 0.5F, attrPlane[attr][c]);
            }
         ATTRIB_LOOP_END
#endif

         count = 0;
         while (coverage > 0.0F) {
            /* (cx,cy) = center of fragment */
            const GLfloat cx = ix + 0.5F, cy = iy + 0.5F;
            SWspanarrays *array = span.array;
            array->coverage[count] = coverage;
#ifdef DO_Z
            array->z[count] = (GLuint) solve_plane(cx, cy, zPlane);
#endif
            array->rgba[count][RCOMP] = solve_plane_chan(cx, cy, rPlane);
            array->rgba[count][GCOMP] = solve_plane_chan(cx, cy, gPlane);
            array->rgba[count][BCOMP] = solve_plane_chan(cx, cy, bPlane);
            array->rgba[count][ACOMP] = solve_plane_chan(cx, cy, aPlane);
            ix++;
            count++;
            coverage = compute_coveragef(pMin, pMid, pMax, ix, iy);
         }
         
         if (ix > startX) {
            span.x = startX;
            span.y = iy;
            span.end = (GLuint) ix - (GLuint) startX;
            _swrast_write_rgba_span(ctx, &span);
         }
      }
   }
   else {
      /* scan right to left */
      const GLfloat *pMin = vMin->attrib[VARYING_SLOT_POS];
      const GLfloat *pMid = vMid->attrib[VARYING_SLOT_POS];
      const GLfloat *pMax = vMax->attrib[VARYING_SLOT_POS];
      const GLfloat dxdy = majDx / majDy;
      const GLfloat xAdj = dxdy > 0 ? dxdy : 0.0F;
      GLint iy;
#ifdef _OPENMP
#pragma omp parallel for schedule(dynamic) private(iy) firstprivate(span)
#endif
      for (iy = iyMin; iy < iyMax; iy++) {
         GLfloat x = pMin[0] - (yMin - iy) * dxdy;
         GLint ix, left, startX = (GLint) (x + xAdj);
         GLuint count, n;
         GLfloat coverage = 0.0F;
         
#ifdef _OPENMP
         /* each thread needs to use a different (global) SpanArrays variable */
         span.array = SWRAST_CONTEXT(ctx)->SpanArrays + omp_get_thread_num();
#endif
         /* make sure we're not past the window edge */
         if (startX >= ctx->DrawBuffer->_Xmax) {
            startX = ctx->DrawBuffer->_Xmax - 1;
         }

         /* skip fragments with zero coverage */
         while (startX > 0) {
            coverage = compute_coveragef(pMin, pMax, pMid, startX, iy);
            if (coverage > 0.0F)
               break;
            startX--;
         }
         
         /* enter interior of triangle */
         ix = startX;
         count = 0;
         while (coverage > 0.0F) {
            /* (cx,cy) = center of fragment */
            const GLfloat cx = ix + 0.5F, cy = iy + 0.5F;
            SWspanarrays *array = span.array;
            ASSERT(ix >= 0);
            array->coverage[ix] = coverage;
#ifdef DO_Z
            array->z[ix] = (GLuint) solve_plane(cx, cy, zPlane);
#endif
            array->rgba[ix][RCOMP] = solve_plane_chan(cx, cy, rPlane);
            array->rgba[ix][GCOMP] = solve_plane_chan(cx, cy, gPlane);
            array->rgba[ix][BCOMP] = solve_plane_chan(cx, cy, bPlane);
            array->rgba[ix][ACOMP] = solve_plane_chan(cx, cy, aPlane);
            ix--;
            count++;
            coverage = compute_coveragef(pMin, pMax, pMid, ix, iy);
         }
         
#if defined(DO_ATTRIBS)
         /* compute attributes at left-most fragment */
         span.attrStart[VARYING_SLOT_POS][3] = solve_plane(ix + 1.5F, iy + 0.5F, wPlane);
         ATTRIB_LOOP_BEGIN
            GLuint c;
            for (c = 0; c < 4; c++) {
               span.attrStart[attr][c] = solve_plane(ix + 1.5F, iy + 0.5F, attrPlane[attr][c]);
            }
         ATTRIB_LOOP_END
#endif

         if (startX > ix) {
            n = (GLuint) startX - (GLuint) ix;

            left = ix + 1;

            /* shift all values to the left */
            /* XXX this is temporary */
            {
               SWspanarrays *array = span.array;
               GLint j;
               for (j = 0; j < (GLint) n; j++) {
                  array->coverage[j] = array->coverage[j + left];
                  COPY_CHAN4(array->rgba[j], array->rgba[j + left]);
#ifdef DO_Z
                  array->z[j] = array->z[j + left];
#endif
               }
            }

            span.x = left;
            span.y = iy;
            span.end = n;
            _swrast_write_rgba_span(ctx, &span);
         }
      }
   }
}


#undef DO_Z
#undef DO_ATTRIBS
#undef DO_OCCLUSION_TEST
@


1.6
log
@Merge Mesa 9.2.0
@
text
@@


1.5
log
@Merge Mesa 7.10.3
@
text
@a2 1
 * Version:  7.0.3
d19 4
a22 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
d42 3
a44 3
   const GLfloat *p0 = v0->attrib[FRAG_ATTRIB_WPOS];
   const GLfloat *p1 = v1->attrib[FRAG_ATTRIB_WPOS];
   const GLfloat *p2 = v2->attrib[FRAG_ATTRIB_WPOS];
d58 1
a58 1
   GLfloat attrPlane[FRAG_ATTRIB_MAX][4][4];
d70 3
a72 3
      GLfloat y0 = v0->attrib[FRAG_ATTRIB_WPOS][1];
      GLfloat y1 = v1->attrib[FRAG_ATTRIB_WPOS][1];
      GLfloat y2 = v2->attrib[FRAG_ATTRIB_WPOS][1];
d97 2
a98 2
   majDx = vMax->attrib[FRAG_ATTRIB_WPOS][0] - vMin->attrib[FRAG_ATTRIB_WPOS][0];
   majDy = vMax->attrib[FRAG_ATTRIB_WPOS][1] - vMin->attrib[FRAG_ATTRIB_WPOS][1];
d102 2
a103 2
      const GLfloat botDx = vMid->attrib[FRAG_ATTRIB_WPOS][0] - vMin->attrib[FRAG_ATTRIB_WPOS][0];
      const GLfloat botDy = vMid->attrib[FRAG_ATTRIB_WPOS][1] - vMin->attrib[FRAG_ATTRIB_WPOS][1];
d137 3
a139 3
      const GLfloat invW0 = v0->attrib[FRAG_ATTRIB_WPOS][3];
      const GLfloat invW1 = v1->attrib[FRAG_ATTRIB_WPOS][3];
      const GLfloat invW2 = v2->attrib[FRAG_ATTRIB_WPOS][3];
d141 2
a142 2
      span.attrStepX[FRAG_ATTRIB_WPOS][3] = plane_dx(wPlane);
      span.attrStepY[FRAG_ATTRIB_WPOS][3] = plane_dy(wPlane);
d172 2
a173 2
   yMin = vMin->attrib[FRAG_ATTRIB_WPOS][1];
   yMax = vMax->attrib[FRAG_ATTRIB_WPOS][1];
d179 3
a181 3
      const GLfloat *pMin = vMin->attrib[FRAG_ATTRIB_WPOS];
      const GLfloat *pMid = vMid->attrib[FRAG_ATTRIB_WPOS];
      const GLfloat *pMax = vMax->attrib[FRAG_ATTRIB_WPOS];
a183 1
      GLfloat x = pMin[0] - (yMin - iyMin) * dxdy;
d185 5
a189 1
      for (iy = iyMin; iy < iyMax; iy++, x += dxdy) {
d194 4
d199 1
a199 1
         while (startX < MAX_WIDTH) {
d211 1
a211 1
         span.attrStart[FRAG_ATTRIB_WPOS][3] = solve_plane(ix + 0.5F, iy + 0.5F, wPlane);
d238 6
a243 7
         if (ix <= startX)
            continue;
         
         span.x = startX;
         span.y = iy;
         span.end = (GLuint) ix - (GLuint) startX;
         _swrast_write_rgba_span(ctx, &span);
d248 3
a250 3
      const GLfloat *pMin = vMin->attrib[FRAG_ATTRIB_WPOS];
      const GLfloat *pMid = vMid->attrib[FRAG_ATTRIB_WPOS];
      const GLfloat *pMax = vMax->attrib[FRAG_ATTRIB_WPOS];
a252 1
      GLfloat x = pMin[0] - (yMin - iyMin) * dxdy;
d254 5
a258 1
      for (iy = iyMin; iy < iyMax; iy++, x += dxdy) {
d263 4
d303 1
a303 1
         span.attrStart[FRAG_ATTRIB_WPOS][3] = solve_plane(ix + 1.5F, iy + 0.5F, wPlane);
d312 2
a313 4
         if (startX <= ix)
            continue;

         n = (GLuint) startX - (GLuint) ix;
d315 1
a315 1
         left = ix + 1;
d317 8
a324 8
         /* shift all values to the left */
         /* XXX this is temporary */
         {
            SWspanarrays *array = span.array;
            GLint j;
            for (j = 0; j < (GLint) n; j++) {
               array->coverage[j] = array->coverage[j + left];
               COPY_CHAN4(array->rgba[j], array->rgba[j + left]);
d326 1
a326 1
               array->z[j] = array->z[j + left];
d328 1
d330 5
a335 5

         span.x = left;
         span.y = iy;
         span.end = n;
         _swrast_write_rgba_span(ctx, &span);
@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d39 1
a39 1
/*void triangle( GLcontext *ctx, GLuint v0, GLuint v1, GLuint v2, GLuint pv )*/
@


1.3
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@a35 2
 *    DO_RGBA      - if defined, compute RGBA values
 *    DO_INDEX     - if defined, compute color index values
a55 1
#ifdef DO_RGBA
a56 4
#endif
#ifdef DO_INDEX
   GLfloat iPlane[4];
#endif
a121 1
#ifdef DO_RGBA
a134 11
#endif
#ifdef DO_INDEX
   if (ctx->Light.ShadeModel == GL_SMOOTH) {
      compute_plane(p0, p1, p2, (GLfloat) v0->attrib[FRAG_ATTRIB_CI][0],
                    v1->attrib[FRAG_ATTRIB_CI][0], v2->attrib[FRAG_ATTRIB_CI][0], iPlane);
   }
   else {
      constant_plane(v2->attrib[FRAG_ATTRIB_CI][0], iPlane);
   }
   span.arrayMask |= SPAN_INDEX;
#endif
d204 1
a204 1
         span.attrStart[FRAG_ATTRIB_WPOS][3] = solve_plane(ix + 0.5, iy + 0.5, wPlane);
d208 1
a208 1
               span.attrStart[attr][c] = solve_plane(ix + 0.5, iy + 0.5, attrPlane[attr][c]);
a217 3
#ifdef DO_INDEX
            array->coverage[count] = (GLfloat) compute_coveragei(pMin, pMid, pMax, ix, iy);
#else
a218 1
#endif
a221 1
#ifdef DO_RGBA
a225 4
#endif
#ifdef DO_INDEX
            array->index[count] = (GLint) solve_plane(cx, cy, iPlane);
#endif
a236 1
#if defined(DO_RGBA)
a237 3
#else
         _swrast_write_index_span(ctx, &span);
#endif
a274 3
#ifdef DO_INDEX
            array->coverage[ix] = (GLfloat) compute_coveragei(pMin, pMax, pMid, ix, iy);
#else
a275 1
#endif
a278 1
#ifdef DO_RGBA
a282 4
#endif
#ifdef DO_INDEX
            array->index[ix] = (GLint) solve_plane(cx, cy, iPlane);
#endif
d290 1
a290 1
         span.attrStart[FRAG_ATTRIB_WPOS][3] = solve_plane(ix + 1.5, iy + 0.5, wPlane);
d294 1
a294 1
               span.attrStart[attr][c] = solve_plane(ix + 1.5, iy + 0.5, attrPlane[attr][c]);
a312 1
#ifdef DO_RGBA
a313 4
#endif
#ifdef DO_INDEX
               array->index[j] = array->index[j + left];
#endif
a322 1
#if defined(DO_RGBA)
a323 3
#else
         _swrast_write_index_span(ctx, &span);
#endif
a329 2
#undef DO_RGBA
#undef DO_INDEX
@


1.2
log
@Update to Mesa 7.0.3. tested my oga@@ and johan@@
@
text
@a37 1
 *    DO_SPEC      - if defined, compute specular RGB values
d44 3
a46 3
   const GLfloat *p0 = v0->win;
   const GLfloat *p1 = v1->win;
   const GLfloat *p2 = v2->win;
a57 5
#ifdef DO_FOG
   GLfloat fogPlane[4];
#else
   GLfloat *fog = NULL;
#endif
a63 3
#ifdef DO_SPEC
   GLfloat srPlane[4], sgPlane[4], sbPlane[4];
#endif
d65 2
a66 6
   GLfloat sPlane[FRAG_ATTRIB_MAX][4];  /* texture S */
   GLfloat tPlane[FRAG_ATTRIB_MAX][4];  /* texture T */
   GLfloat uPlane[FRAG_ATTRIB_MAX][4];  /* texture R */
   GLfloat vPlane[FRAG_ATTRIB_MAX][4];  /* texture Q */
   GLfloat texWidth[FRAG_ATTRIB_MAX];
   GLfloat texHeight[FRAG_ATTRIB_MAX];
d72 2
a73 1
   INIT_SPAN(span, GL_POLYGON, 0, 0, SPAN_COVERAGE);
d77 3
a79 3
      GLfloat y0 = v0->win[1];
      GLfloat y1 = v1->win[1];
      GLfloat y2 = v2->win[1];
d104 2
a105 2
   majDx = vMax->win[0] - vMin->win[0];
   majDy = vMax->win[1] - vMin->win[1];
d109 2
a110 2
      const GLfloat botDx = vMid->win[0] - vMin->win[0];
      const GLfloat botDy = vMid->win[1] - vMin->win[1];
a128 8
#ifdef DO_FOG
   compute_plane(p0, p1, p2,
                 v0->attrib[FRAG_ATTRIB_FOGC][0],
                 v1->attrib[FRAG_ATTRIB_FOGC][0],
                 v2->attrib[FRAG_ATTRIB_FOGC][0],
                 fogPlane);
   span.arrayMask |= SPAN_FOG;
#endif
d146 2
a147 2
      compute_plane(p0, p1, p2, (GLfloat) v0->index,
                    v1->index, v2->index, iPlane);
d150 1
a150 1
      constant_plane(v2->index, iPlane);
a153 13
#ifdef DO_SPEC
   if (ctx->Light.ShadeModel == GL_SMOOTH) {
      compute_plane(p0, p1, p2, v0->specular[RCOMP], v1->specular[RCOMP], v2->specular[RCOMP], srPlane);
      compute_plane(p0, p1, p2, v0->specular[GCOMP], v1->specular[GCOMP], v2->specular[GCOMP], sgPlane);
      compute_plane(p0, p1, p2, v0->specular[BCOMP], v1->specular[BCOMP], v2->specular[BCOMP], sbPlane);
   }
   else {
      constant_plane(v2->specular[RCOMP], srPlane);
      constant_plane(v2->specular[GCOMP], sgPlane);
      constant_plane(v2->specular[BCOMP], sbPlane);
   }
   span.arrayMask |= SPAN_SPEC;
#endif
d156 6
a161 3
      const GLfloat invW0 = v0->win[3];
      const GLfloat invW1 = v1->win[3];
      const GLfloat invW2 = v2->win[3];
d163 5
a167 22
         const GLfloat s0 = v0->attrib[attr][0] * invW0;
         const GLfloat s1 = v1->attrib[attr][0] * invW1;
         const GLfloat s2 = v2->attrib[attr][0] * invW2;
         const GLfloat t0 = v0->attrib[attr][1] * invW0;
         const GLfloat t1 = v1->attrib[attr][1] * invW1;
         const GLfloat t2 = v2->attrib[attr][1] * invW2;
         const GLfloat r0 = v0->attrib[attr][2] * invW0;
         const GLfloat r1 = v1->attrib[attr][2] * invW1;
         const GLfloat r2 = v2->attrib[attr][2] * invW2;
         const GLfloat q0 = v0->attrib[attr][3] * invW0;
         const GLfloat q1 = v1->attrib[attr][3] * invW1;
         const GLfloat q2 = v2->attrib[attr][3] * invW2;
         compute_plane(p0, p1, p2, s0, s1, s2, sPlane[attr]);
         compute_plane(p0, p1, p2, t0, t1, t2, tPlane[attr]);
         compute_plane(p0, p1, p2, r0, r1, r2, uPlane[attr]);
         compute_plane(p0, p1, p2, q0, q1, q2, vPlane[attr]);
         if (attr < FRAG_ATTRIB_VAR0 && attr >= FRAG_ATTRIB_TEX0) {
            const GLuint u = attr - FRAG_ATTRIB_TEX0;
            const struct gl_texture_object *obj = ctx->Texture.Unit[u]._Current;
            const struct gl_texture_image *texImage = obj->Image[0][obj->BaseLevel];
            texWidth[attr]  = (GLfloat) texImage->Width;
            texHeight[attr] = (GLfloat) texImage->Height;
d170 10
a179 1
            texWidth[attr] = texHeight[attr] = 1.0;
a182 1
   span.arrayMask |= (SPAN_TEXTURE | SPAN_LAMBDA | SPAN_VARYING);
d191 2
a192 2
   yMin = vMin->win[1];
   yMax = vMax->win[1];
d198 3
a200 3
      const GLfloat *pMin = vMin->win;
      const GLfloat *pMid = vMid->win;
      const GLfloat *pMax = vMax->win;
d220 12
a244 3
#ifdef DO_FOG
	    array->attribs[FRAG_ATTRIB_FOGC][count][0] = solve_plane(cx, cy, fogPlane);
#endif
a253 19
#ifdef DO_SPEC
            array->spec[count][RCOMP] = solve_plane_chan(cx, cy, srPlane);
            array->spec[count][GCOMP] = solve_plane_chan(cx, cy, sgPlane);
            array->spec[count][BCOMP] = solve_plane_chan(cx, cy, sbPlane);
#endif
#if defined(DO_ATTRIBS)
            ATTRIB_LOOP_BEGIN
               GLfloat invQ = solve_plane_recip(cx, cy, vPlane[attr]);
               array->attribs[attr][count][0] = solve_plane(cx, cy, sPlane[attr]) * invQ;
               array->attribs[attr][count][1] = solve_plane(cx, cy, tPlane[attr]) * invQ;
               array->attribs[attr][count][2] = solve_plane(cx, cy, uPlane[attr]) * invQ;
               if (attr < FRAG_ATTRIB_VAR0 && attr >= FRAG_ATTRIB_TEX0) {
                  const GLuint unit = attr - FRAG_ATTRIB_TEX0;
                  array->lambda[unit][count] = compute_lambda(sPlane[attr], tPlane[attr],
                                                              vPlane[attr], cx, cy, invQ,
                                                              texWidth[attr], texHeight[attr]);
               }
            ATTRIB_LOOP_END
#endif
a264 1
         ASSERT(span.interpMask == 0);
d274 3
a276 3
      const GLfloat *pMin = vMin->win;
      const GLfloat *pMid = vMid->win;
      const GLfloat *pMax = vMax->win;
a314 3
#ifdef DO_FOG
            array->attribs[FRAG_ATTRIB_FOGC][ix][0] = solve_plane(cx, cy, fogPlane);
#endif
a323 22
#ifdef DO_SPEC
            array->spec[ix][RCOMP] = solve_plane_chan(cx, cy, srPlane);
            array->spec[ix][GCOMP] = solve_plane_chan(cx, cy, sgPlane);
            array->spec[ix][BCOMP] = solve_plane_chan(cx, cy, sbPlane);
#endif
#if defined(DO_ATTRIBS)
            ATTRIB_LOOP_BEGIN
               GLfloat invQ = solve_plane_recip(cx, cy, vPlane[attr]);
               array->attribs[attr][ix][0] = solve_plane(cx, cy, sPlane[attr]) * invQ;
               array->attribs[attr][ix][1] = solve_plane(cx, cy, tPlane[attr]) * invQ;
               array->attribs[attr][ix][2] = solve_plane(cx, cy, uPlane[attr]) * invQ;
               if (attr < FRAG_ATTRIB_VAR0 && attr >= FRAG_ATTRIB_TEX0) {
                  const GLuint unit = attr - FRAG_ATTRIB_TEX0;
                  array->lambda[unit][ix] = compute_lambda(sPlane[attr],
                                                           tPlane[attr],
                                                           vPlane[attr],
                                                           cx, cy, invQ,
                                                           texWidth[attr],
                                                           texHeight[attr]);
               }
            ATTRIB_LOOP_END
#endif
d329 11
d353 1
a356 3
#ifdef DO_SPEC
               COPY_CHAN4(array->spec[j], array->spec[j + left]);
#endif
a362 8
#ifdef DO_FOG
               array->attribs[FRAG_ATTRIB_FOGC][j][0]
                  = array->attribs[FRAG_ATTRIB_FOGC][j + left][0];
#endif
#if defined(DO_ATTRIBS)
               array->lambda[0][j] = array->lambda[0][j + left];
#endif
               array->coverage[j] = array->coverage[j + left];
a364 15
#ifdef DO_ATTRIBS
         /* shift texcoords, varying */
         {
            SWspanarrays *array = span.array;
            ATTRIB_LOOP_BEGIN
               GLint j;
               for (j = 0; j < (GLint) n; j++) {
                  array->attribs[attr][j][0] = array->attribs[attr][j + left][0];
                  array->attribs[attr][j][1] = array->attribs[attr][j + left][1];
                  array->attribs[attr][j][2] = array->attribs[attr][j + left][2];
                  /*array->lambda[unit][j] = array->lambda[unit][j + left];*/
               }
            ATTRIB_LOOP_END
         }
#endif
a368 1
         ASSERT(span.interpMask == 0);
a378 1
#ifdef DO_Z
a379 7
#endif

#ifdef DO_FOG
#undef DO_FOG
#endif

#ifdef DO_RGBA
a380 3
#endif

#ifdef DO_INDEX
a381 7
#endif

#ifdef DO_SPEC
#undef DO_SPEC
#endif

#ifdef DO_ATTRIBS
a382 3
#endif

#ifdef DO_OCCLUSION_TEST
a383 1
#endif
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * Version:  6.5
d5 1
a5 1
 * Copyright (C) 1999-2005  Brian Paul   All Rights Reserved.
d39 1
a39 2
 *    DO_TEX       - if defined, compute unit 0 STRQ texcoords
 *    DO_MULTITEX  - if defined, compute all unit's STRQ texcoords
d44 1
d54 1
a54 1
   struct sw_span span;
d73 7
a79 10
#ifdef DO_TEX
   GLfloat sPlane[4], tPlane[4], uPlane[4], vPlane[4];
   GLfloat texWidth, texHeight;
#elif defined(DO_MULTITEX)
   GLfloat sPlane[MAX_TEXTURE_COORD_UNITS][4];  /* texture S */
   GLfloat tPlane[MAX_TEXTURE_COORD_UNITS][4];  /* texture T */
   GLfloat uPlane[MAX_TEXTURE_COORD_UNITS][4];  /* texture R */
   GLfloat vPlane[MAX_TEXTURE_COORD_UNITS][4];  /* texture Q */
   GLfloat texWidth[MAX_TEXTURE_COORD_UNITS];
   GLfloat texHeight[MAX_TEXTURE_COORD_UNITS];
d81 1
a81 2
   GLfloat bf = SWRAST_CONTEXT(ctx)->_BackfaceSign;
   
d83 2
d119 1
d128 2
d142 5
a146 1
   compute_plane(p0, p1, p2, v0->fog, v1->fog, v2->fog, fogPlane);
d187 1
a187 1
#ifdef DO_TEX
a188 2
      const struct gl_texture_object *obj = ctx->Texture.Unit[0]._Current;
      const struct gl_texture_image *texImage = obj->Image[0][obj->BaseLevel];
d192 19
a210 25
      const GLfloat s0 = v0->texcoord[0][0] * invW0;
      const GLfloat s1 = v1->texcoord[0][0] * invW1;
      const GLfloat s2 = v2->texcoord[0][0] * invW2;
      const GLfloat t0 = v0->texcoord[0][1] * invW0;
      const GLfloat t1 = v1->texcoord[0][1] * invW1;
      const GLfloat t2 = v2->texcoord[0][1] * invW2;
      const GLfloat r0 = v0->texcoord[0][2] * invW0;
      const GLfloat r1 = v1->texcoord[0][2] * invW1;
      const GLfloat r2 = v2->texcoord[0][2] * invW2;
      const GLfloat q0 = v0->texcoord[0][3] * invW0;
      const GLfloat q1 = v1->texcoord[0][3] * invW1;
      const GLfloat q2 = v2->texcoord[0][3] * invW2;
      compute_plane(p0, p1, p2, s0, s1, s2, sPlane);
      compute_plane(p0, p1, p2, t0, t1, t2, tPlane);
      compute_plane(p0, p1, p2, r0, r1, r2, uPlane);
      compute_plane(p0, p1, p2, q0, q1, q2, vPlane);
      texWidth = (GLfloat) texImage->Width;
      texHeight = (GLfloat) texImage->Height;
   }
   span.arrayMask |= (SPAN_TEXTURE | SPAN_LAMBDA);
#elif defined(DO_MULTITEX)
   {
      GLuint u;
      for (u = 0; u < ctx->Const.MaxTextureUnits; u++) {
         if (ctx->Texture.Unit[u]._ReallyEnabled) {
d213 5
a217 21
            const GLfloat invW0 = v0->win[3];
            const GLfloat invW1 = v1->win[3];
            const GLfloat invW2 = v2->win[3];
            const GLfloat s0 = v0->texcoord[u][0] * invW0;
            const GLfloat s1 = v1->texcoord[u][0] * invW1;
            const GLfloat s2 = v2->texcoord[u][0] * invW2;
            const GLfloat t0 = v0->texcoord[u][1] * invW0;
            const GLfloat t1 = v1->texcoord[u][1] * invW1;
            const GLfloat t2 = v2->texcoord[u][1] * invW2;
            const GLfloat r0 = v0->texcoord[u][2] * invW0;
            const GLfloat r1 = v1->texcoord[u][2] * invW1;
            const GLfloat r2 = v2->texcoord[u][2] * invW2;
            const GLfloat q0 = v0->texcoord[u][3] * invW0;
            const GLfloat q1 = v1->texcoord[u][3] * invW1;
            const GLfloat q2 = v2->texcoord[u][3] * invW2;
            compute_plane(p0, p1, p2, s0, s1, s2, sPlane[u]);
            compute_plane(p0, p1, p2, t0, t1, t2, tPlane[u]);
            compute_plane(p0, p1, p2, r0, r1, r2, uPlane[u]);
            compute_plane(p0, p1, p2, q0, q1, q2, vPlane[u]);
            texWidth[u]  = (GLfloat) texImage->Width;
            texHeight[u] = (GLfloat) texImage->Height;
d219 1
a219 1
      }
d221 1
a221 1
   span.arrayMask |= (SPAN_TEXTURE | SPAN_LAMBDA);
d263 1
a263 1
            struct span_arrays *array = span.array;
d273 1
a273 1
	    array->fog[count] = solve_plane(cx, cy, fogPlane);
d289 11
a299 23
#ifdef DO_TEX
            {
               const GLfloat invQ = solve_plane_recip(cx, cy, vPlane);
               array->texcoords[0][count][0] = solve_plane(cx, cy, sPlane) * invQ;
               array->texcoords[0][count][1] = solve_plane(cx, cy, tPlane) * invQ;
               array->texcoords[0][count][2] = solve_plane(cx, cy, uPlane) * invQ;
               array->lambda[0][count] = compute_lambda(sPlane, tPlane, vPlane,
                                                      cx, cy, invQ,
                                                      texWidth, texHeight);
            }
#elif defined(DO_MULTITEX)
            {
               GLuint unit;
               for (unit = 0; unit < ctx->Const.MaxTextureUnits; unit++) {
                  if (ctx->Texture.Unit[unit]._ReallyEnabled) {
                     GLfloat invQ = solve_plane_recip(cx, cy, vPlane[unit]);
                     array->texcoords[unit][count][0] = solve_plane(cx, cy, sPlane[unit]) * invQ;
                     array->texcoords[unit][count][1] = solve_plane(cx, cy, tPlane[unit]) * invQ;
                     array->texcoords[unit][count][2] = solve_plane(cx, cy, uPlane[unit]) * invQ;
                     array->lambda[unit][count] = compute_lambda(sPlane[unit],
                                      tPlane[unit], vPlane[unit], cx, cy, invQ,
                                      texWidth[unit], texHeight[unit]);
                  }
d301 1
a301 1
            }
d342 1
a342 1
         while (startX >= 0) {
d355 2
a356 1
            struct span_arrays *array = span.array;
d366 1
a366 1
            array->fog[ix] = solve_plane(cx, cy, fogPlane);
d382 14
a395 25
#ifdef DO_TEX
            {
               const GLfloat invQ = solve_plane_recip(cx, cy, vPlane);
               array->texcoords[0][ix][0] = solve_plane(cx, cy, sPlane) * invQ;
               array->texcoords[0][ix][1] = solve_plane(cx, cy, tPlane) * invQ;
               array->texcoords[0][ix][2] = solve_plane(cx, cy, uPlane) * invQ;
               array->lambda[0][ix] = compute_lambda(sPlane, tPlane, vPlane,
                                          cx, cy, invQ, texWidth, texHeight);
            }
#elif defined(DO_MULTITEX)
            {
               GLuint unit;
               for (unit = 0; unit < ctx->Const.MaxTextureUnits; unit++) {
                  if (ctx->Texture.Unit[unit]._ReallyEnabled) {
                     GLfloat invQ = solve_plane_recip(cx, cy, vPlane[unit]);
                     array->texcoords[unit][ix][0] = solve_plane(cx, cy, sPlane[unit]) * invQ;
                     array->texcoords[unit][ix][1] = solve_plane(cx, cy, tPlane[unit]) * invQ;
                     array->texcoords[unit][ix][2] = solve_plane(cx, cy, uPlane[unit]) * invQ;
                     array->lambda[unit][ix] = compute_lambda(sPlane[unit],
                                                            tPlane[unit],
                                                            vPlane[unit],
                                                            cx, cy, invQ,
                                                            texWidth[unit],
                                                            texHeight[unit]);
                  }
d397 1
a397 1
            }
d414 1
a414 1
            struct span_arrays *array = span.array;
d430 2
a431 4
               array->fog[j] = array->fog[j + left];
#endif
#ifdef DO_TEX
               COPY_4V(array->texcoords[0][j], array->texcoords[0][j + left]);
d433 1
a433 1
#if defined(DO_MULTITEX) || defined(DO_TEX)
d439 2
a440 2
#ifdef DO_MULTITEX
         /* shift texcoords */
d442 8
a449 11
            struct span_arrays *array = span.array;
            GLuint unit;
            for (unit = 0; unit < ctx->Const.MaxTextureUnits; unit++) {
               if (ctx->Texture.Unit[unit]._ReallyEnabled) {
                  GLint j;
                  for (j = 0; j < (GLint) n; j++) {
		     array->texcoords[unit][j][0] = array->texcoords[unit][j + left][0];
                     array->texcoords[unit][j][1] = array->texcoords[unit][j + left][1];
                     array->texcoords[unit][j][2] = array->texcoords[unit][j + left][2];
                     array->lambda[unit][j] = array->lambda[unit][j + left];
                  }
d451 1
a451 1
            }
d489 2
a490 6
#ifdef DO_TEX
#undef DO_TEX
#endif

#ifdef DO_MULTITEX
#undef DO_MULTITEX
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d54 1
a54 1
   SWspan span;
d282 1
a282 1
            SWspanarrays *array = span.array;
d386 1
a386 1
            SWspanarrays *array = span.array;
d455 1
a455 1
            SWspanarrays *array = span.array;
d485 1
a485 1
            SWspanarrays *array = span.array;
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d3 1
a3 1
 * Version:  6.5.3
d5 1
a5 1
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
d39 2
a40 1
 *    DO_ATTRIBS   - if defined, compute texcoords, varying, etc.
a44 1
   const SWcontext *swrast = SWRAST_CONTEXT(ctx);
d73 10
a82 7
#if defined(DO_ATTRIBS)
   GLfloat sPlane[FRAG_ATTRIB_MAX][4];  /* texture S */
   GLfloat tPlane[FRAG_ATTRIB_MAX][4];  /* texture T */
   GLfloat uPlane[FRAG_ATTRIB_MAX][4];  /* texture R */
   GLfloat vPlane[FRAG_ATTRIB_MAX][4];  /* texture Q */
   GLfloat texWidth[FRAG_ATTRIB_MAX];
   GLfloat texHeight[FRAG_ATTRIB_MAX];
d86 1
a86 2
   (void) swrast;

d141 1
a141 5
   compute_plane(p0, p1, p2,
                 v0->attrib[FRAG_ATTRIB_FOGC][0],
                 v1->attrib[FRAG_ATTRIB_FOGC][0],
                 v2->attrib[FRAG_ATTRIB_FOGC][0],
                 fogPlane);
d182 1
a182 1
#if defined(DO_ATTRIBS)
d184 2
d189 25
a213 19
      ATTRIB_LOOP_BEGIN
         const GLfloat s0 = v0->attrib[attr][0] * invW0;
         const GLfloat s1 = v1->attrib[attr][0] * invW1;
         const GLfloat s2 = v2->attrib[attr][0] * invW2;
         const GLfloat t0 = v0->attrib[attr][1] * invW0;
         const GLfloat t1 = v1->attrib[attr][1] * invW1;
         const GLfloat t2 = v2->attrib[attr][1] * invW2;
         const GLfloat r0 = v0->attrib[attr][2] * invW0;
         const GLfloat r1 = v1->attrib[attr][2] * invW1;
         const GLfloat r2 = v2->attrib[attr][2] * invW2;
         const GLfloat q0 = v0->attrib[attr][3] * invW0;
         const GLfloat q1 = v1->attrib[attr][3] * invW1;
         const GLfloat q2 = v2->attrib[attr][3] * invW2;
         compute_plane(p0, p1, p2, s0, s1, s2, sPlane[attr]);
         compute_plane(p0, p1, p2, t0, t1, t2, tPlane[attr]);
         compute_plane(p0, p1, p2, r0, r1, r2, uPlane[attr]);
         compute_plane(p0, p1, p2, q0, q1, q2, vPlane[attr]);
         if (attr < FRAG_ATTRIB_VAR0 && attr >= FRAG_ATTRIB_TEX0) {
            const GLuint u = attr - FRAG_ATTRIB_TEX0;
d216 21
a236 2
            texWidth[attr]  = (GLfloat) texImage->Width;
            texHeight[attr] = (GLfloat) texImage->Height;
d238 1
a238 4
         else {
            texWidth[attr] = texHeight[attr] = 1.0;
         }
      ATTRIB_LOOP_END
d240 1
a240 1
   span.arrayMask |= (SPAN_TEXTURE | SPAN_LAMBDA | SPAN_VARYING);
d292 1
a292 1
	    array->attribs[FRAG_ATTRIB_FOGC][count][0] = solve_plane(cx, cy, fogPlane);
d308 23
a330 11
#if defined(DO_ATTRIBS)
            ATTRIB_LOOP_BEGIN
               GLfloat invQ = solve_plane_recip(cx, cy, vPlane[attr]);
               array->attribs[attr][count][0] = solve_plane(cx, cy, sPlane[attr]) * invQ;
               array->attribs[attr][count][1] = solve_plane(cx, cy, tPlane[attr]) * invQ;
               array->attribs[attr][count][2] = solve_plane(cx, cy, uPlane[attr]) * invQ;
               if (attr < FRAG_ATTRIB_VAR0 && attr >= FRAG_ATTRIB_TEX0) {
                  const GLuint unit = attr - FRAG_ATTRIB_TEX0;
                  array->lambda[unit][count] = compute_lambda(sPlane[attr], tPlane[attr],
                                                              vPlane[attr], cx, cy, invQ,
                                                              texWidth[attr], texHeight[attr]);
d332 1
a332 1
            ATTRIB_LOOP_END
d396 1
a396 1
            array->attribs[FRAG_ATTRIB_FOGC][ix][0] = solve_plane(cx, cy, fogPlane);
d412 25
a436 14
#if defined(DO_ATTRIBS)
            ATTRIB_LOOP_BEGIN
               GLfloat invQ = solve_plane_recip(cx, cy, vPlane[attr]);
               array->attribs[attr][ix][0] = solve_plane(cx, cy, sPlane[attr]) * invQ;
               array->attribs[attr][ix][1] = solve_plane(cx, cy, tPlane[attr]) * invQ;
               array->attribs[attr][ix][2] = solve_plane(cx, cy, uPlane[attr]) * invQ;
               if (attr < FRAG_ATTRIB_VAR0 && attr >= FRAG_ATTRIB_TEX0) {
                  const GLuint unit = attr - FRAG_ATTRIB_TEX0;
                  array->lambda[unit][ix] = compute_lambda(sPlane[attr],
                                                           tPlane[attr],
                                                           vPlane[attr],
                                                           cx, cy, invQ,
                                                           texWidth[attr],
                                                           texHeight[attr]);
d438 1
a438 1
            ATTRIB_LOOP_END
d471 4
a474 2
               array->attribs[FRAG_ATTRIB_FOGC][j][0]
                  = array->attribs[FRAG_ATTRIB_FOGC][j + left][0];
d476 1
a476 1
#if defined(DO_ATTRIBS)
d482 2
a483 2
#ifdef DO_ATTRIBS
         /* shift texcoords, varying */
d486 10
a495 7
            ATTRIB_LOOP_BEGIN
               GLint j;
               for (j = 0; j < (GLint) n; j++) {
                  array->attribs[attr][j][0] = array->attribs[attr][j + left][0];
                  array->attribs[attr][j][1] = array->attribs[attr][j + left][1];
                  array->attribs[attr][j][2] = array->attribs[attr][j + left][2];
                  /*array->lambda[unit][j] = array->lambda[unit][j + left];*/
d497 1
a497 1
            ATTRIB_LOOP_END
d535 6
a540 2
#ifdef DO_ATTRIBS
#undef DO_ATTRIBS
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d3 1
a3 1
 * Version:  7.0.3
d36 3
d42 1
a42 1
/*void triangle( struct gl_context *ctx, GLuint v0, GLuint v1, GLuint v2, GLuint pv )*/
d45 3
a47 3
   const GLfloat *p0 = v0->attrib[FRAG_ATTRIB_WPOS];
   const GLfloat *p1 = v1->attrib[FRAG_ATTRIB_WPOS];
   const GLfloat *p2 = v2->attrib[FRAG_ATTRIB_WPOS];
d59 6
d66 7
d74 6
a79 2
   GLfloat attrPlane[FRAG_ATTRIB_MAX][4][4];
   GLfloat wPlane[4];  /* win[3] */
d81 1
a81 1
   GLfloat bf = SWRAST_CONTEXT(ctx)->_BackfaceCullSign;
d85 1
a85 2
   INIT_SPAN(span, GL_POLYGON);
   span.arrayMask = SPAN_COVERAGE;
d89 3
a91 3
      GLfloat y0 = v0->attrib[FRAG_ATTRIB_WPOS][1];
      GLfloat y1 = v1->attrib[FRAG_ATTRIB_WPOS][1];
      GLfloat y2 = v2->attrib[FRAG_ATTRIB_WPOS][1];
d116 2
a117 2
   majDx = vMax->attrib[FRAG_ATTRIB_WPOS][0] - vMin->attrib[FRAG_ATTRIB_WPOS][0];
   majDy = vMax->attrib[FRAG_ATTRIB_WPOS][1] - vMin->attrib[FRAG_ATTRIB_WPOS][1];
a118 1
   /* front/back-face determination and cullling */
d120 2
a121 2
      const GLfloat botDx = vMid->attrib[FRAG_ATTRIB_WPOS][0] - vMin->attrib[FRAG_ATTRIB_WPOS][0];
      const GLfloat botDy = vMid->attrib[FRAG_ATTRIB_WPOS][1] - vMin->attrib[FRAG_ATTRIB_WPOS][1];
a126 2

      span.facing = area * swrast->_BackfaceSign > 0.0F;
d138 9
d160 24
d186 3
a188 6
      const GLfloat invW0 = v0->attrib[FRAG_ATTRIB_WPOS][3];
      const GLfloat invW1 = v1->attrib[FRAG_ATTRIB_WPOS][3];
      const GLfloat invW2 = v2->attrib[FRAG_ATTRIB_WPOS][3];
      compute_plane(p0, p1, p2, invW0, invW1, invW2, wPlane);
      span.attrStepX[FRAG_ATTRIB_WPOS][3] = plane_dx(wPlane);
      span.attrStepY[FRAG_ATTRIB_WPOS][3] = plane_dy(wPlane);
d190 22
a211 5
         GLuint c;
         if (swrast->_InterpMode[attr] == GL_FLAT) {
            for (c = 0; c < 4; c++) {
               constant_plane(v2->attrib[attr][c] * invW2, attrPlane[attr][c]);
            }
d214 1
a214 10
            for (c = 0; c < 4; c++) {
               const GLfloat a0 = v0->attrib[attr][c] * invW0;
               const GLfloat a1 = v1->attrib[attr][c] * invW1;
               const GLfloat a2 = v2->attrib[attr][c] * invW2;
               compute_plane(p0, p1, p2, a0, a1, a2, attrPlane[attr][c]);
            }
         }
         for (c = 0; c < 4; c++) {
            span.attrStepX[attr][c] = plane_dx(attrPlane[attr][c]);
            span.attrStepY[attr][c] = plane_dy(attrPlane[attr][c]);
d218 1
d227 2
a228 2
   yMin = vMin->attrib[FRAG_ATTRIB_WPOS][1];
   yMax = vMax->attrib[FRAG_ATTRIB_WPOS][1];
d234 3
a236 3
      const GLfloat *pMin = vMin->attrib[FRAG_ATTRIB_WPOS];
      const GLfloat *pMid = vMid->attrib[FRAG_ATTRIB_WPOS];
      const GLfloat *pMax = vMax->attrib[FRAG_ATTRIB_WPOS];
a255 12

#if defined(DO_ATTRIBS)
         /* compute attributes at left-most fragment */
         span.attrStart[FRAG_ATTRIB_WPOS][3] = solve_plane(ix + 0.5F, iy + 0.5F, wPlane);
         ATTRIB_LOOP_BEGIN
            GLuint c;
            for (c = 0; c < 4; c++) {
               span.attrStart[attr][c] = solve_plane(ix + 0.5F, iy + 0.5F, attrPlane[attr][c]);
            }
         ATTRIB_LOOP_END
#endif

d261 3
d265 1
d269 4
d277 23
d311 2
d314 3
d321 3
a323 3
      const GLfloat *pMin = vMin->attrib[FRAG_ATTRIB_WPOS];
      const GLfloat *pMid = vMid->attrib[FRAG_ATTRIB_WPOS];
      const GLfloat *pMax = vMax->attrib[FRAG_ATTRIB_WPOS];
d339 1
a339 1
         while (startX > 0) {
d353 3
a355 1
            ASSERT(ix >= 0);
d357 1
d361 4
d369 26
a399 11
#if defined(DO_ATTRIBS)
         /* compute attributes at left-most fragment */
         span.attrStart[FRAG_ATTRIB_WPOS][3] = solve_plane(ix + 1.5F, iy + 0.5F, wPlane);
         ATTRIB_LOOP_BEGIN
            GLuint c;
            for (c = 0; c < 4; c++) {
               span.attrStart[attr][c] = solve_plane(ix + 1.5F, iy + 0.5F, attrPlane[attr][c]);
            }
         ATTRIB_LOOP_END
#endif

d413 1
a413 1
               array->coverage[j] = array->coverage[j + left];
d415 7
d425 8
d435 15
d454 2
d457 3
d465 1
d467 19
d487 3
d491 1
@


1.1.1.5
log
@Import Mesa 9.2.0
@
text
@d3 1
d20 3
a22 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
d42 3
a44 3
   const GLfloat *p0 = v0->attrib[VARYING_SLOT_POS];
   const GLfloat *p1 = v1->attrib[VARYING_SLOT_POS];
   const GLfloat *p2 = v2->attrib[VARYING_SLOT_POS];
d58 1
a58 1
   GLfloat attrPlane[VARYING_SLOT_MAX][4][4];
d70 3
a72 3
      GLfloat y0 = v0->attrib[VARYING_SLOT_POS][1];
      GLfloat y1 = v1->attrib[VARYING_SLOT_POS][1];
      GLfloat y2 = v2->attrib[VARYING_SLOT_POS][1];
d97 2
a98 2
   majDx = vMax->attrib[VARYING_SLOT_POS][0] - vMin->attrib[VARYING_SLOT_POS][0];
   majDy = vMax->attrib[VARYING_SLOT_POS][1] - vMin->attrib[VARYING_SLOT_POS][1];
d102 2
a103 2
      const GLfloat botDx = vMid->attrib[VARYING_SLOT_POS][0] - vMin->attrib[VARYING_SLOT_POS][0];
      const GLfloat botDy = vMid->attrib[VARYING_SLOT_POS][1] - vMin->attrib[VARYING_SLOT_POS][1];
d137 3
a139 3
      const GLfloat invW0 = v0->attrib[VARYING_SLOT_POS][3];
      const GLfloat invW1 = v1->attrib[VARYING_SLOT_POS][3];
      const GLfloat invW2 = v2->attrib[VARYING_SLOT_POS][3];
d141 2
a142 2
      span.attrStepX[VARYING_SLOT_POS][3] = plane_dx(wPlane);
      span.attrStepY[VARYING_SLOT_POS][3] = plane_dy(wPlane);
d172 2
a173 2
   yMin = vMin->attrib[VARYING_SLOT_POS][1];
   yMax = vMax->attrib[VARYING_SLOT_POS][1];
d179 3
a181 3
      const GLfloat *pMin = vMin->attrib[VARYING_SLOT_POS];
      const GLfloat *pMid = vMid->attrib[VARYING_SLOT_POS];
      const GLfloat *pMax = vMax->attrib[VARYING_SLOT_POS];
d184 1
d186 1
a186 5
#ifdef _OPENMP
#pragma omp parallel for schedule(dynamic) private(iy) firstprivate(span)
#endif
      for (iy = iyMin; iy < iyMax; iy++) {
         GLfloat x = pMin[0] - (yMin - iy) * dxdy;
a190 4
#ifdef _OPENMP
         /* each thread needs to use a different (global) SpanArrays variable */
         span.array = SWRAST_CONTEXT(ctx)->SpanArrays + omp_get_thread_num();
#endif
d192 1
a192 1
         while (startX < SWRAST_MAX_WIDTH) {
d204 1
a204 1
         span.attrStart[VARYING_SLOT_POS][3] = solve_plane(ix + 0.5F, iy + 0.5F, wPlane);
d231 7
a237 6
         if (ix > startX) {
            span.x = startX;
            span.y = iy;
            span.end = (GLuint) ix - (GLuint) startX;
            _swrast_write_rgba_span(ctx, &span);
         }
d242 3
a244 3
      const GLfloat *pMin = vMin->attrib[VARYING_SLOT_POS];
      const GLfloat *pMid = vMid->attrib[VARYING_SLOT_POS];
      const GLfloat *pMax = vMax->attrib[VARYING_SLOT_POS];
d247 1
d249 1
a249 5
#ifdef _OPENMP
#pragma omp parallel for schedule(dynamic) private(iy) firstprivate(span)
#endif
      for (iy = iyMin; iy < iyMax; iy++) {
         GLfloat x = pMin[0] - (yMin - iy) * dxdy;
a253 4
#ifdef _OPENMP
         /* each thread needs to use a different (global) SpanArrays variable */
         span.array = SWRAST_CONTEXT(ctx)->SpanArrays + omp_get_thread_num();
#endif
d290 1
a290 1
         span.attrStart[VARYING_SLOT_POS][3] = solve_plane(ix + 1.5F, iy + 0.5F, wPlane);
d299 4
a302 2
         if (startX > ix) {
            n = (GLuint) startX - (GLuint) ix;
d304 1
a304 1
            left = ix + 1;
d306 8
a313 8
            /* shift all values to the left */
            /* XXX this is temporary */
            {
               SWspanarrays *array = span.array;
               GLint j;
               for (j = 0; j < (GLint) n; j++) {
                  array->coverage[j] = array->coverage[j + left];
                  COPY_CHAN4(array->rgba[j], array->rgba[j + left]);
d315 1
a315 1
                  array->z[j] = array->z[j + left];
a316 1
               }
d318 1
d320 4
a323 5
            span.x = left;
            span.y = iy;
            span.end = n;
            _swrast_write_rgba_span(ctx, &span);
         }
@


