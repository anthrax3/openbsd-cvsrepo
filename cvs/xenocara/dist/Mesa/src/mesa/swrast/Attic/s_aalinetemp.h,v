head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.8
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.6
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.4
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.4
	OPENBSD_5_6:1.7.0.4
	OPENBSD_5_6_BASE:1.7
	v10_2_3:1.1.1.4
	OPENBSD_5_5:1.7.0.2
	OPENBSD_5_5_BASE:1.7
	v9_2_5:1.1.1.4
	v9_2_3:1.1.1.4
	v9_2_2:1.1.1.4
	v9_2_1:1.1.1.4
	v9_2_0:1.1.1.4
	OPENBSD_5_4:1.6.0.8
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.6
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.4
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	v7_10_3:1.1.1.3
	OPENBSD_5_0:1.5.0.6
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v7_0_1:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v6_5_2:1.1.1.1
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.54;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2013.09.05.14.06.47;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2011.10.23.13.37.45;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.05.22.20.06.34;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.05.17.20.26.42;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.14.58.22;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.05.31.16.36.49;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.51.14;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.51.14;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.32.03;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.10.23.13.29.48;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.09.05.13.17.28;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */


/*
 * Antialiased line template.
 */


/*
 * Function to render each fragment in the AA line.
 * \param ix  - integer fragment window X coordiante
 * \param iy  - integer fragment window Y coordiante
 */
static void
NAME(plot)(struct gl_context *ctx, struct LineInfo *line, int ix, int iy)
{
   const SWcontext *swrast = SWRAST_CONTEXT(ctx);
   const GLfloat fx = (GLfloat) ix;
   const GLfloat fy = (GLfloat) iy;
   const GLfloat coverage = compute_coveragef(line, ix, iy);
   const GLuint i = line->span.end;

   (void) swrast;

   if (coverage == 0.0)
      return;

   line->span.end++;
   line->span.array->coverage[i] = coverage;
   line->span.array->x[i] = ix;
   line->span.array->y[i] = iy;

   /*
    * Compute Z, color, texture coords, fog for the fragment by
    * solving the plane equations at (ix,iy).
    */
#ifdef DO_Z
   line->span.array->z[i] = (GLuint) solve_plane(fx, fy, line->zPlane);
#endif
   line->span.array->rgba[i][RCOMP] = solve_plane_chan(fx, fy, line->rPlane);
   line->span.array->rgba[i][GCOMP] = solve_plane_chan(fx, fy, line->gPlane);
   line->span.array->rgba[i][BCOMP] = solve_plane_chan(fx, fy, line->bPlane);
   line->span.array->rgba[i][ACOMP] = solve_plane_chan(fx, fy, line->aPlane);
#if defined(DO_ATTRIBS)
   ATTRIB_LOOP_BEGIN
      GLfloat (*attribArray)[4] = line->span.array->attribs[attr];
      if (attr >= VARYING_SLOT_TEX0 && attr < VARYING_SLOT_VAR0
          && !_swrast_use_fragment_program(ctx)) {
         /* texcoord w/ divide by Q */
         const GLuint unit = attr - VARYING_SLOT_TEX0;
         const GLfloat invQ = solve_plane_recip(fx, fy, line->attrPlane[attr][3]);
         GLuint c;
         for (c = 0; c < 3; c++) {
            attribArray[i][c] = solve_plane(fx, fy, line->attrPlane[attr][c]) * invQ;
         }
         line->span.array->lambda[unit][i]
            = compute_lambda(line->attrPlane[attr][0],
                             line->attrPlane[attr][1], invQ,
                             line->texWidth[attr], line->texHeight[attr]);
      }
      else {
         /* non-texture attrib */
         const GLfloat invW = solve_plane_recip(fx, fy, line->wPlane);
         GLuint c;
         for (c = 0; c < 4; c++) {
            attribArray[i][c] = solve_plane(fx, fy, line->attrPlane[attr][c]) * invW;
         }
      }
   ATTRIB_LOOP_END
#endif

   if (line->span.end == SWRAST_MAX_WIDTH) {
      _swrast_write_rgba_span(ctx, &(line->span));
      line->span.end = 0; /* reset counter */
   }
}



/*
 * Line setup
 */
static void
NAME(line)(struct gl_context *ctx, const SWvertex *v0, const SWvertex *v1)
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
   GLfloat tStart, tEnd;   /* segment start, end along line length */
   GLboolean inSegment;
   GLint iLen, i;

   /* Init the LineInfo struct */
   struct LineInfo line;
   line.x0 = v0->attrib[VARYING_SLOT_POS][0];
   line.y0 = v0->attrib[VARYING_SLOT_POS][1];
   line.x1 = v1->attrib[VARYING_SLOT_POS][0];
   line.y1 = v1->attrib[VARYING_SLOT_POS][1];
   line.dx = line.x1 - line.x0;
   line.dy = line.y1 - line.y0;
   line.len = sqrtf(line.dx * line.dx + line.dy * line.dy);
   line.halfWidth = 0.5F * CLAMP(ctx->Line.Width,
                                 ctx->Const.MinLineWidthAA,
                                 ctx->Const.MaxLineWidthAA);

   if (line.len == 0.0 || IS_INF_OR_NAN(line.len))
      return;

   INIT_SPAN(line.span, GL_LINE);
   line.span.arrayMask = SPAN_XY | SPAN_COVERAGE;
   line.span.facing = swrast->PointLineFacing;
   line.xAdj = line.dx / line.len * line.halfWidth;
   line.yAdj = line.dy / line.len * line.halfWidth;

#ifdef DO_Z
   line.span.arrayMask |= SPAN_Z;
   compute_plane(line.x0, line.y0, line.x1, line.y1,
                 v0->attrib[VARYING_SLOT_POS][2], v1->attrib[VARYING_SLOT_POS][2], line.zPlane);
#endif
   line.span.arrayMask |= SPAN_RGBA;
   if (ctx->Light.ShadeModel == GL_SMOOTH) {
      compute_plane(line.x0, line.y0, line.x1, line.y1,
                    v0->color[RCOMP], v1->color[RCOMP], line.rPlane);
      compute_plane(line.x0, line.y0, line.x1, line.y1,
                    v0->color[GCOMP], v1->color[GCOMP], line.gPlane);
      compute_plane(line.x0, line.y0, line.x1, line.y1,
                    v0->color[BCOMP], v1->color[BCOMP], line.bPlane);
      compute_plane(line.x0, line.y0, line.x1, line.y1,
                    v0->color[ACOMP], v1->color[ACOMP], line.aPlane);
   }
   else {
      constant_plane(v1->color[RCOMP], line.rPlane);
      constant_plane(v1->color[GCOMP], line.gPlane);
      constant_plane(v1->color[BCOMP], line.bPlane);
      constant_plane(v1->color[ACOMP], line.aPlane);
   }
#if defined(DO_ATTRIBS)
   {
      const GLfloat invW0 = v0->attrib[VARYING_SLOT_POS][3];
      const GLfloat invW1 = v1->attrib[VARYING_SLOT_POS][3];
      line.span.arrayMask |= SPAN_LAMBDA;
      compute_plane(line.x0, line.y0, line.x1, line.y1, invW0, invW1, line.wPlane);
      ATTRIB_LOOP_BEGIN
         GLuint c;
         if (swrast->_InterpMode[attr] == GL_FLAT) {
            for (c = 0; c < 4; c++) {
               constant_plane(v1->attrib[attr][c], line.attrPlane[attr][c]);
            }
         }
         else {
            for (c = 0; c < 4; c++) {
               const GLfloat a0 = v0->attrib[attr][c] * invW0;
               const GLfloat a1 = v1->attrib[attr][c] * invW1;
               compute_plane(line.x0, line.y0, line.x1, line.y1, a0, a1,
                             line.attrPlane[attr][c]);
            }
         }
         line.span.arrayAttribs |= BITFIELD64_BIT(attr);
         if (attr >= VARYING_SLOT_TEX0 && attr < VARYING_SLOT_VAR0) {
            const GLuint u = attr - VARYING_SLOT_TEX0;
            const struct gl_texture_object *obj = ctx->Texture.Unit[u]._Current;
            const struct gl_texture_image *texImage = obj->Image[0][obj->BaseLevel];
            line.texWidth[attr]  = (GLfloat) texImage->Width;
            line.texHeight[attr] = (GLfloat) texImage->Height;
         }
      ATTRIB_LOOP_END
   }
#endif

   tStart = tEnd = 0.0;
   inSegment = GL_FALSE;
   iLen = (GLint) line.len;

   if (ctx->Line.StippleFlag) {
      for (i = 0; i < iLen; i++) {
         const GLuint bit = (swrast->StippleCounter / ctx->Line.StippleFactor) & 0xf;
         if ((1 << bit) & ctx->Line.StipplePattern) {
            /* stipple bit is on */
            const GLfloat t = (GLfloat) i / (GLfloat) line.len;
            if (!inSegment) {
               /* start new segment */
               inSegment = GL_TRUE;
               tStart = t;
            }
            else {
               /* still in the segment, extend it */
               tEnd = t;
            }
         }
         else {
            /* stipple bit is off */
            if (inSegment && (tEnd > tStart)) {
               /* draw the segment */
               segment(ctx, &line, NAME(plot), tStart, tEnd);
               inSegment = GL_FALSE;
            }
            else {
               /* still between segments, do nothing */
            }
         }
         swrast->StippleCounter++;
      }

      if (inSegment) {
         /* draw the final segment of the line */
         segment(ctx, &line, NAME(plot), tStart, 1.0F);
      }
   }
   else {
      /* non-stippled */
      segment(ctx, &line, NAME(plot), 0.0, 1.0);
   }

   _swrast_write_rgba_span(ctx, &(line.span));
}




#undef DO_Z
#undef DO_ATTRIBS
#undef NAME
@


1.7
log
@Merge Mesa 9.2.0
@
text
@@


1.6
log
@Merge Mesa 7.10.3
@
text
@a2 1
 * Version:  7.1
d19 4
a22 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
d69 2
a70 2
      if (attr >= FRAG_ATTRIB_TEX0 && attr < FRAG_ATTRIB_VAR0
          && !ctx->FragmentProgram._Current) {
d72 1
a72 1
         const GLuint unit = attr - FRAG_ATTRIB_TEX0;
d94 1
a94 1
   if (line->span.end == MAX_WIDTH) {
d115 4
a118 4
   line.x0 = v0->attrib[FRAG_ATTRIB_WPOS][0];
   line.y0 = v0->attrib[FRAG_ATTRIB_WPOS][1];
   line.x1 = v1->attrib[FRAG_ATTRIB_WPOS][0];
   line.y1 = v1->attrib[FRAG_ATTRIB_WPOS][1];
d121 1
a121 1
   line.len = SQRTF(line.dx * line.dx + line.dy * line.dy);
d138 1
a138 1
                 v0->attrib[FRAG_ATTRIB_WPOS][2], v1->attrib[FRAG_ATTRIB_WPOS][2], line.zPlane);
d159 2
a160 2
      const GLfloat invW0 = v0->attrib[FRAG_ATTRIB_WPOS][3];
      const GLfloat invW1 = v1->attrib[FRAG_ATTRIB_WPOS][3];
d178 3
a180 3
         line.span.arrayAttribs |= (1 << attr);
         if (attr >= FRAG_ATTRIB_TEX0 && attr < FRAG_ATTRIB_VAR0) {
            const GLuint u = attr - FRAG_ATTRIB_TEX0;
@


1.5
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d37 1
a37 1
NAME(plot)(GLcontext *ctx, struct LineInfo *line, int ix, int iy)
d106 1
a106 1
NAME(line)(GLcontext *ctx, const SWvertex *v0, const SWvertex *v1)
@


1.4
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@a41 3
#ifdef DO_INDEX
   const GLfloat coverage = compute_coveragei(line, ix, iy);
#else
a42 1
#endif
a61 1
#ifdef DO_RGBA
a65 4
#endif
#ifdef DO_INDEX
   line->span.array->index[i] = (GLint) solve_plane(fx, fy, line->iPlane);
#endif
a94 1
#if defined(DO_RGBA)
a95 3
#else
      _swrast_write_index_span(ctx, &(line->span));
#endif
a139 1
#ifdef DO_RGBA
a156 12
#endif
#ifdef DO_INDEX
   line.span.arrayMask |= SPAN_INDEX;
   if (ctx->Light.ShadeModel == GL_SMOOTH) {
      compute_plane(line.x0, line.y0, line.x1, line.y1,
                    v0->attrib[FRAG_ATTRIB_CI][0],
                    v1->attrib[FRAG_ATTRIB_CI][0], line.iPlane);
   }
   else {
      constant_plane(v1->attrib[FRAG_ATTRIB_CI][0], line.iPlane);
   }
#endif
a233 1
#if defined(DO_RGBA)
a234 3
#else
   _swrast_write_index_span(ctx, &(line.span));
#endif
a240 2
#undef DO_RGBA
#undef DO_INDEX
@


1.3
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d79 1
a79 1
          && !ctx->FragmentProgram._Active) {
@


1.2
log
@Update to Mesa 7.0.3. tested my oga@@ and johan@@
@
text
@d3 1
a3 1
 * Version:  6.5.3
a65 3
#ifdef DO_FOG
   line->span.array->attribs[FRAG_ATTRIB_FOGC][i][0] = solve_plane(fx, fy, line->fPlane);
#endif
a74 5
#ifdef DO_SPEC
   line->span.array->spec[i][RCOMP] = solve_plane_chan(fx, fy, line->srPlane);
   line->span.array->spec[i][GCOMP] = solve_plane_chan(fx, fy, line->sgPlane);
   line->span.array->spec[i][BCOMP] = solve_plane_chan(fx, fy, line->sbPlane);
#endif
d78 3
a80 11
      GLfloat invQ;
      if (ctx->FragmentProgram._Active) {
         invQ = 1.0F;
      }
      else {
         invQ = solve_plane_recip(fx, fy, line->vPlane[attr]);
      }
      attribArray[i][0] = solve_plane(fx, fy, line->sPlane[attr]) * invQ;
      attribArray[i][1] = solve_plane(fx, fy, line->tPlane[attr]) * invQ;
      attribArray[i][2] = solve_plane(fx, fy, line->uPlane[attr]) * invQ;
      if (attr < FRAG_ATTRIB_VAR0 && attr >= FRAG_ATTRIB_TEX0) {
d82 5
d88 2
a89 2
            = compute_lambda(line->sPlane[attr],
                             line->tPlane[attr], invQ,
d92 8
d128 4
a131 4
   line.x0 = v0->win[0];
   line.y0 = v0->win[1];
   line.x1 = v1->win[0];
   line.y1 = v1->win[1];
d135 3
a137 1
   line.halfWidth = 0.5F * ctx->Line._Width;
d142 2
a143 1
   INIT_SPAN(line.span, GL_LINE, 0, 0, SPAN_XY | SPAN_COVERAGE);
a144 1

d151 1
a151 8
                 v0->win[2], v1->win[2], line.zPlane);
#endif
#ifdef DO_FOG
   line.span.arrayMask |= SPAN_FOG;
   compute_plane(line.x0, line.y0, line.x1, line.y1,
                 v0->attrib[FRAG_ATTRIB_FOGC][0],
                 v1->attrib[FRAG_ATTRIB_FOGC][0],
                 line.fPlane);
a171 16
#ifdef DO_SPEC
   line.span.arrayMask |= SPAN_SPEC;
   if (ctx->Light.ShadeModel == GL_SMOOTH) {
      compute_plane(line.x0, line.y0, line.x1, line.y1,
                    v0->specular[RCOMP], v1->specular[RCOMP], line.srPlane);
      compute_plane(line.x0, line.y0, line.x1, line.y1,
                    v0->specular[GCOMP], v1->specular[GCOMP], line.sgPlane);
      compute_plane(line.x0, line.y0, line.x1, line.y1,
                    v0->specular[BCOMP], v1->specular[BCOMP], line.sbPlane);
   }
   else {
      constant_plane(v1->specular[RCOMP], line.srPlane);
      constant_plane(v1->specular[GCOMP], line.sgPlane);
      constant_plane(v1->specular[BCOMP], line.sbPlane);
   }
#endif
d176 2
a177 1
                    v0->index, v1->index, line.iPlane);
d180 1
a180 1
      constant_plane(v1->index, line.iPlane);
d185 4
a188 3
      const GLfloat invW0 = v0->win[3];
      const GLfloat invW1 = v1->win[3];
      line.span.arrayMask |= (SPAN_TEXTURE | SPAN_LAMBDA | SPAN_VARYING);
d190 16
a205 13
         const GLfloat s0 = v0->attrib[attr][0] * invW0;
         const GLfloat s1 = v1->attrib[attr][0] * invW1;
         const GLfloat t0 = v0->attrib[attr][1] * invW0;
         const GLfloat t1 = v1->attrib[attr][1] * invW1;
         const GLfloat r0 = v0->attrib[attr][2] * invW0;
         const GLfloat r1 = v1->attrib[attr][2] * invW1;
         const GLfloat q0 = v0->attrib[attr][3] * invW0;
         const GLfloat q1 = v1->attrib[attr][3] * invW1;
         compute_plane(line.x0, line.y0, line.x1, line.y1, s0, s1, line.sPlane[attr]);
         compute_plane(line.x0, line.y0, line.x1, line.y1, t0, t1, line.tPlane[attr]);
         compute_plane(line.x0, line.y0, line.x1, line.y1, r0, r1, line.uPlane[attr]);
         compute_plane(line.x0, line.y0, line.x1, line.y1, q0, q1, line.vPlane[attr]);
         if (attr < FRAG_ATTRIB_VAR0 && attr >= FRAG_ATTRIB_TEX0) {
a270 1
#undef DO_FOG
a272 1
#undef DO_SPEC
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * Version:  6.5
d5 1
a5 1
 * Copyright (C) 1999-2005  Brian Paul   All Rights Reserved.
d39 1
d49 2
d67 1
a67 1
   line->span.array->fog[i] = solve_plane(fx, fy, line->fPlane);
d83 3
a85 2
#ifdef DO_TEX
   {
d91 1
a91 1
         invQ = solve_plane_recip(fx, fy, line->vPlane[0]);
d93 9
a101 27
      line->span.array->texcoords[0][i][0] = solve_plane(fx, fy, line->sPlane[0]) * invQ;
      line->span.array->texcoords[0][i][1] = solve_plane(fx, fy, line->tPlane[0]) * invQ;
      line->span.array->texcoords[0][i][2] = solve_plane(fx, fy, line->uPlane[0]) * invQ;
      line->span.array->lambda[0][i] = compute_lambda(line->sPlane[0],
                                                      line->tPlane[0], invQ,
                                                      line->texWidth[0],
                                                      line->texHeight[0]);
   }
#elif defined(DO_MULTITEX)
   {
      GLuint unit;
      for (unit = 0; unit < ctx->Const.MaxTextureUnits; unit++) {
         if (ctx->Texture.Unit[unit]._ReallyEnabled) {
            GLfloat invQ;
            if (ctx->FragmentProgram._Active) {
               invQ = 1.0F;
            }
            else {
               invQ = solve_plane_recip(fx, fy, line->vPlane[unit]);
            }
            line->span.array->texcoords[unit][i][0] = solve_plane(fx, fy, line->sPlane[unit]) * invQ;
            line->span.array->texcoords[unit][i][1] = solve_plane(fx, fy, line->tPlane[unit]) * invQ;
            line->span.array->texcoords[unit][i][2] = solve_plane(fx, fy, line->uPlane[unit]) * invQ;
            line->span.array->lambda[unit][i] = compute_lambda(line->sPlane[unit],
                                                               line->tPlane[unit], invQ,
                                                               line->texWidth[unit], line->texHeight[unit]);
         }
d103 1
a103 1
   }
d144 1
d157 3
a159 1
                 v0->fog, v1->fog, line.fPlane);
d206 1
a206 1
#ifdef DO_TEX
a207 2
      const struct gl_texture_object *obj = ctx->Texture.Unit[0]._Current;
      const struct gl_texture_image *texImage = obj->Image[0][obj->BaseLevel];
d210 16
a225 22
      const GLfloat s0 = v0->texcoord[0][0] * invW0;
      const GLfloat s1 = v1->texcoord[0][0] * invW1;
      const GLfloat t0 = v0->texcoord[0][1] * invW0;
      const GLfloat t1 = v1->texcoord[0][1] * invW1;
      const GLfloat r0 = v0->texcoord[0][2] * invW0;
      const GLfloat r1 = v1->texcoord[0][2] * invW1;
      const GLfloat q0 = v0->texcoord[0][3] * invW0;
      const GLfloat q1 = v1->texcoord[0][3] * invW1;
      line.span.arrayMask |= (SPAN_TEXTURE | SPAN_LAMBDA);
      compute_plane(line.x0, line.y0, line.x1, line.y1, s0, s1, line.sPlane[0]);
      compute_plane(line.x0, line.y0, line.x1, line.y1, t0, t1, line.tPlane[0]);
      compute_plane(line.x0, line.y0, line.x1, line.y1, r0, r1, line.uPlane[0]);
      compute_plane(line.x0, line.y0, line.x1, line.y1, q0, q1, line.vPlane[0]);
      line.texWidth[0] = (GLfloat) texImage->Width;
      line.texHeight[0] = (GLfloat) texImage->Height;
   }
#elif defined(DO_MULTITEX)
   {
      GLuint u;
      line.span.arrayMask |= (SPAN_TEXTURE | SPAN_LAMBDA);
      for (u = 0; u < ctx->Const.MaxTextureUnits; u++) {
         if (ctx->Texture.Unit[u]._ReallyEnabled) {
d228 2
a229 16
            const GLfloat invW0 = v0->win[3];
            const GLfloat invW1 = v1->win[3];
            const GLfloat s0 = v0->texcoord[u][0] * invW0;
            const GLfloat s1 = v1->texcoord[u][0] * invW1;
            const GLfloat t0 = v0->texcoord[u][1] * invW0;
            const GLfloat t1 = v1->texcoord[u][1] * invW1;
            const GLfloat r0 = v0->texcoord[u][2] * invW0;
            const GLfloat r1 = v1->texcoord[u][2] * invW1;
            const GLfloat q0 = v0->texcoord[u][3] * invW0;
            const GLfloat q1 = v1->texcoord[u][3] * invW1;
            compute_plane(line.x0, line.y0, line.x1, line.y1, s0, s1, line.sPlane[u]);
            compute_plane(line.x0, line.y0, line.x1, line.y1, t0, t1, line.tPlane[u]);
            compute_plane(line.x0, line.y0, line.x1, line.y1, r0, r1, line.uPlane[u]);
            compute_plane(line.x0, line.y0, line.x1, line.y1, q0, q1, line.vPlane[u]);
            line.texWidth[u]  = (GLfloat) texImage->Width;
            line.texHeight[u] = (GLfloat) texImage->Height;
d231 1
a231 1
      }
d294 1
a294 2
#undef DO_TEX
#undef DO_MULTITEX
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@Mesa 7.0.1
@
text
@d3 1
a3 1
 * Version:  6.5.3
d5 1
a5 1
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
a38 1
   const SWcontext *swrast = SWRAST_CONTEXT(ctx);
a47 2
   (void) swrast;

d64 1
a64 1
   line->span.array->attribs[FRAG_ATTRIB_FOGC][i][0] = solve_plane(fx, fy, line->fPlane);
d80 2
a81 3
#if defined(DO_ATTRIBS)
   ATTRIB_LOOP_BEGIN
      GLfloat (*attribArray)[4] = line->span.array->attribs[attr];
d87 1
a87 1
         invQ = solve_plane_recip(fx, fy, line->vPlane[attr]);
d89 27
a115 9
      attribArray[i][0] = solve_plane(fx, fy, line->sPlane[attr]) * invQ;
      attribArray[i][1] = solve_plane(fx, fy, line->tPlane[attr]) * invQ;
      attribArray[i][2] = solve_plane(fx, fy, line->uPlane[attr]) * invQ;
      if (attr < FRAG_ATTRIB_VAR0 && attr >= FRAG_ATTRIB_TEX0) {
         const GLuint unit = attr - FRAG_ATTRIB_TEX0;
         line->span.array->lambda[unit][i]
            = compute_lambda(line->sPlane[attr],
                             line->tPlane[attr], invQ,
                             line->texWidth[attr], line->texHeight[attr]);
d117 1
a117 1
   ATTRIB_LOOP_END
d170 1
a170 3
                 v0->attrib[FRAG_ATTRIB_FOGC][0],
                 v1->attrib[FRAG_ATTRIB_FOGC][0],
                 line.fPlane);
d217 1
a217 1
#if defined(DO_ATTRIBS)
d219 2
d223 22
a244 16
      line.span.arrayMask |= (SPAN_TEXTURE | SPAN_LAMBDA | SPAN_VARYING);
      ATTRIB_LOOP_BEGIN
         const GLfloat s0 = v0->attrib[attr][0] * invW0;
         const GLfloat s1 = v1->attrib[attr][0] * invW1;
         const GLfloat t0 = v0->attrib[attr][1] * invW0;
         const GLfloat t1 = v1->attrib[attr][1] * invW1;
         const GLfloat r0 = v0->attrib[attr][2] * invW0;
         const GLfloat r1 = v1->attrib[attr][2] * invW1;
         const GLfloat q0 = v0->attrib[attr][3] * invW0;
         const GLfloat q1 = v1->attrib[attr][3] * invW1;
         compute_plane(line.x0, line.y0, line.x1, line.y1, s0, s1, line.sPlane[attr]);
         compute_plane(line.x0, line.y0, line.x1, line.y1, t0, t1, line.tPlane[attr]);
         compute_plane(line.x0, line.y0, line.x1, line.y1, r0, r1, line.uPlane[attr]);
         compute_plane(line.x0, line.y0, line.x1, line.y1, q0, q1, line.vPlane[attr]);
         if (attr < FRAG_ATTRIB_VAR0 && attr >= FRAG_ATTRIB_TEX0) {
            const GLuint u = attr - FRAG_ATTRIB_TEX0;
d247 16
a262 2
            line.texWidth[attr]  = (GLfloat) texImage->Width;
            line.texHeight[attr] = (GLfloat) texImage->Height;
d264 1
a264 1
      ATTRIB_LOOP_END
d327 2
a328 1
#undef DO_ATTRIBS
@


1.1.1.3
log
@Import Mesa 7.10.3
@
text
@d3 1
a3 1
 * Version:  7.1
d37 1
a37 1
NAME(plot)(struct gl_context *ctx, struct LineInfo *line, int ix, int iy)
d42 3
d46 1
d66 4
d74 9
d86 11
a96 3
      if (attr >= FRAG_ATTRIB_TEX0 && attr < FRAG_ATTRIB_VAR0
          && !ctx->FragmentProgram._Current) {
         /* texcoord w/ divide by Q */
a97 5
         const GLfloat invQ = solve_plane_recip(fx, fy, line->attrPlane[attr][3]);
         GLuint c;
         for (c = 0; c < 3; c++) {
            attribArray[i][c] = solve_plane(fx, fy, line->attrPlane[attr][c]) * invQ;
         }
d99 2
a100 2
            = compute_lambda(line->attrPlane[attr][0],
                             line->attrPlane[attr][1], invQ,
a102 8
      else {
         /* non-texture attrib */
         const GLfloat invW = solve_plane_recip(fx, fy, line->wPlane);
         GLuint c;
         for (c = 0; c < 4; c++) {
            attribArray[i][c] = solve_plane(fx, fy, line->attrPlane[attr][c]) * invW;
         }
      }
d107 1
d109 3
d122 1
a122 1
NAME(line)(struct gl_context *ctx, const SWvertex *v0, const SWvertex *v1)
d131 4
a134 4
   line.x0 = v0->attrib[FRAG_ATTRIB_WPOS][0];
   line.y0 = v0->attrib[FRAG_ATTRIB_WPOS][1];
   line.x1 = v1->attrib[FRAG_ATTRIB_WPOS][0];
   line.y1 = v1->attrib[FRAG_ATTRIB_WPOS][1];
d138 1
a138 3
   line.halfWidth = 0.5F * CLAMP(ctx->Line.Width,
                                 ctx->Const.MinLineWidthAA,
                                 ctx->Const.MaxLineWidthAA);
d143 2
a144 3
   INIT_SPAN(line.span, GL_LINE);
   line.span.arrayMask = SPAN_XY | SPAN_COVERAGE;
   line.span.facing = swrast->PointLineFacing;
d151 1
a151 1
                 v0->attrib[FRAG_ATTRIB_WPOS][2], v1->attrib[FRAG_ATTRIB_WPOS][2], line.zPlane);
d153 8
d178 27
d207 3
a209 4
      const GLfloat invW0 = v0->attrib[FRAG_ATTRIB_WPOS][3];
      const GLfloat invW1 = v1->attrib[FRAG_ATTRIB_WPOS][3];
      line.span.arrayMask |= SPAN_LAMBDA;
      compute_plane(line.x0, line.y0, line.x1, line.y1, invW0, invW1, line.wPlane);
d211 13
a223 16
         GLuint c;
         if (swrast->_InterpMode[attr] == GL_FLAT) {
            for (c = 0; c < 4; c++) {
               constant_plane(v1->attrib[attr][c], line.attrPlane[attr][c]);
            }
         }
         else {
            for (c = 0; c < 4; c++) {
               const GLfloat a0 = v0->attrib[attr][c] * invW0;
               const GLfloat a1 = v1->attrib[attr][c] * invW1;
               compute_plane(line.x0, line.y0, line.x1, line.y1, a0, a1,
                             line.attrPlane[attr][c]);
            }
         }
         line.span.arrayAttribs |= (1 << attr);
         if (attr >= FRAG_ATTRIB_TEX0 && attr < FRAG_ATTRIB_VAR0) {
d278 1
d280 3
d289 4
@


1.1.1.4
log
@Import Mesa 9.2.0
@
text
@d3 1
d20 3
a22 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
d69 2
a70 2
      if (attr >= VARYING_SLOT_TEX0 && attr < VARYING_SLOT_VAR0
          && !_swrast_use_fragment_program(ctx)) {
d72 1
a72 1
         const GLuint unit = attr - VARYING_SLOT_TEX0;
d94 1
a94 1
   if (line->span.end == SWRAST_MAX_WIDTH) {
d115 4
a118 4
   line.x0 = v0->attrib[VARYING_SLOT_POS][0];
   line.y0 = v0->attrib[VARYING_SLOT_POS][1];
   line.x1 = v1->attrib[VARYING_SLOT_POS][0];
   line.y1 = v1->attrib[VARYING_SLOT_POS][1];
d121 1
a121 1
   line.len = sqrtf(line.dx * line.dx + line.dy * line.dy);
d138 1
a138 1
                 v0->attrib[VARYING_SLOT_POS][2], v1->attrib[VARYING_SLOT_POS][2], line.zPlane);
d159 2
a160 2
      const GLfloat invW0 = v0->attrib[VARYING_SLOT_POS][3];
      const GLfloat invW1 = v1->attrib[VARYING_SLOT_POS][3];
d178 3
a180 3
         line.span.arrayAttribs |= BITFIELD64_BIT(attr);
         if (attr >= VARYING_SLOT_TEX0 && attr < VARYING_SLOT_VAR0) {
            const GLuint u = attr - VARYING_SLOT_TEX0;
@


