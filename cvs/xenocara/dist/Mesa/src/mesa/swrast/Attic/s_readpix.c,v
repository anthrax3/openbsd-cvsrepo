head	1.8;
access;
symbols
	OPENBSD_5_4:1.7.0.4
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.6.0.4
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.5.0.6
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2013.09.05.14.06.50;	author jsg;	state dead;
branches;
next	1.7;

1.7
date	2012.08.17.13.58.20;	author mpi;	state Exp;
branches;
next	1.6;

1.6
date	2011.10.23.13.37.45;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.05.22.20.06.34;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.05.17.20.26.42;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.14.58.23;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.05.31.16.36.49;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.51.22;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.51.22;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.56.50;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.32.10;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.48;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Merge Mesa 9.2.0
@
text
@/*
 * Mesa 3-D graphics library
 * Version:  7.0.3
 *
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */


#include "main/glheader.h"
#include "main/colormac.h"
#include "main/feedback.h"
#include "main/formats.h"
#include "main/image.h"
#include "main/imports.h"
#include "main/macros.h"
#include "main/pack.h"
#include "main/pbo.h"
#include "main/state.h"

#include "s_context.h"
#include "s_depth.h"
#include "s_span.h"
#include "s_stencil.h"


/**
 * Read pixels for format=GL_DEPTH_COMPONENT.
 */
static void
read_depth_pixels( struct gl_context *ctx,
                   GLint x, GLint y,
                   GLsizei width, GLsizei height,
                   GLenum type, GLvoid *pixels,
                   const struct gl_pixelstore_attrib *packing )
{
   struct gl_framebuffer *fb = ctx->ReadBuffer;
   struct gl_renderbuffer *rb = fb->_DepthBuffer;
   const GLboolean biasOrScale
      = ctx->Pixel.DepthScale != 1.0 || ctx->Pixel.DepthBias != 0.0;

   if (!rb)
      return;

   /* clipping should have been done already */
   ASSERT(x >= 0);
   ASSERT(y >= 0);
   ASSERT(x + width <= (GLint) rb->Width);
   ASSERT(y + height <= (GLint) rb->Height);
   /* width should never be > MAX_WIDTH since we did clipping earlier */
   ASSERT(width <= MAX_WIDTH);

   if (type == GL_UNSIGNED_SHORT && fb->Visual.depthBits == 16
       && !biasOrScale && !packing->SwapBytes) {
      /* Special case: directly read 16-bit unsigned depth values. */
      GLint j;
      ASSERT(rb->Format == MESA_FORMAT_Z16);
      ASSERT(rb->DataType == GL_UNSIGNED_SHORT);
      for (j = 0; j < height; j++, y++) {
         void *dest =_mesa_image_address2d(packing, pixels, width, height,
                                           GL_DEPTH_COMPONENT, type, j, 0);
         rb->GetRow(ctx, rb, width, x, y, dest);
      }
   }
   else if (type == GL_UNSIGNED_INT && fb->Visual.depthBits == 24
            && !biasOrScale && !packing->SwapBytes) {
      /* Special case: directly read 24-bit unsigned depth values. */
      GLint j;
      ASSERT(rb->Format == MESA_FORMAT_X8_Z24 ||
             rb->Format == MESA_FORMAT_S8_Z24 ||
             rb->Format == MESA_FORMAT_Z24_X8 ||
             rb->Format == MESA_FORMAT_Z24_S8);
      ASSERT(rb->DataType == GL_UNSIGNED_INT ||
             rb->DataType == GL_UNSIGNED_INT_24_8);
      for (j = 0; j < height; j++, y++) {
         GLuint *dest = (GLuint *)
            _mesa_image_address2d(packing, pixels, width, height,
                                  GL_DEPTH_COMPONENT, type, j, 0);
         GLint k;
         rb->GetRow(ctx, rb, width, x, y, dest);
         /* convert range from 24-bit to 32-bit */
         if (rb->Format == MESA_FORMAT_X8_Z24 ||
             rb->Format == MESA_FORMAT_S8_Z24) {
            for (k = 0; k < width; k++) {
               /* Note: put MSByte of 24-bit value into LSByte */
               dest[k] = (dest[k] << 8) | ((dest[k] >> 16) & 0xff);
            }
         }
         else {
            for (k = 0; k < width; k++) {
               /* Note: fill in LSByte by replication */
               dest[k] = dest[k] | ((dest[k] >> 8) & 0xff);
            }
         }
      }
   }
   else if (type == GL_UNSIGNED_INT && fb->Visual.depthBits == 32
            && !biasOrScale && !packing->SwapBytes) {
      /* Special case: directly read 32-bit unsigned depth values. */
      GLint j;
      ASSERT(rb->Format == MESA_FORMAT_Z32);
      ASSERT(rb->DataType == GL_UNSIGNED_INT);
      for (j = 0; j < height; j++, y++) {
         void *dest = _mesa_image_address2d(packing, pixels, width, height,
                                            GL_DEPTH_COMPONENT, type, j, 0);
         rb->GetRow(ctx, rb, width, x, y, dest);
      }
   }
   else {
      /* General case (slower) */
      GLint j;
      for (j = 0; j < height; j++, y++) {
         GLfloat depthValues[MAX_WIDTH];
         GLvoid *dest = _mesa_image_address2d(packing, pixels, width, height,
                                              GL_DEPTH_COMPONENT, type, j, 0);
         _swrast_read_depth_span_float(ctx, rb, width, x, y, depthValues);
         _mesa_pack_depth_span(ctx, width, dest, type, depthValues, packing);
      }
   }
}


/**
 * Read pixels for format=GL_STENCIL_INDEX.
 */
static void
read_stencil_pixels( struct gl_context *ctx,
                     GLint x, GLint y,
                     GLsizei width, GLsizei height,
                     GLenum type, GLvoid *pixels,
                     const struct gl_pixelstore_attrib *packing )
{
   struct gl_framebuffer *fb = ctx->ReadBuffer;
   struct gl_renderbuffer *rb = fb->_StencilBuffer;
   GLint j;

   if (!rb)
      return;

   /* width should never be > MAX_WIDTH since we did clipping earlier */
   ASSERT(width <= MAX_WIDTH);

   /* process image row by row */
   for (j=0;j<height;j++,y++) {
      GLvoid *dest;
      GLstencil stencil[MAX_WIDTH];

      _swrast_read_stencil_span(ctx, rb, width, x, y, stencil);

      dest = _mesa_image_address2d(packing, pixels, width, height,
                                   GL_STENCIL_INDEX, type, j, 0);

      _mesa_pack_stencil_span(ctx, width, type, dest, stencil, packing);
   }
}



/**
 * Optimized glReadPixels for particular pixel formats when pixel
 * scaling, biasing, mapping, etc. are disabled.
 * \return GL_TRUE if success, GL_FALSE if unable to do the readpixels
 */
static GLboolean
fast_read_rgba_pixels( struct gl_context *ctx,
                       GLint x, GLint y,
                       GLsizei width, GLsizei height,
                       GLenum format, GLenum type,
                       GLvoid *pixels,
                       const struct gl_pixelstore_attrib *packing,
                       GLbitfield transferOps)
{
   struct gl_renderbuffer *rb = ctx->ReadBuffer->_ColorReadBuffer;

   if (!rb)
      return GL_FALSE;

   ASSERT(rb->_BaseFormat == GL_RGBA ||
	  rb->_BaseFormat == GL_RGB ||
	  rb->_BaseFormat == GL_RG ||
	  rb->_BaseFormat == GL_RED ||
	  rb->_BaseFormat == GL_LUMINANCE ||
	  rb->_BaseFormat == GL_INTENSITY ||
	  rb->_BaseFormat == GL_LUMINANCE_ALPHA ||
	  rb->_BaseFormat == GL_ALPHA);

   /* clipping should have already been done */
   ASSERT(x + width <= (GLint) rb->Width);
   ASSERT(y + height <= (GLint) rb->Height);

   /* check for things we can't handle here */
   if (transferOps ||
       packing->SwapBytes ||
       packing->LsbFirst) {
      return GL_FALSE;
   }

   if (format == GL_RGBA && rb->DataType == type) {
      const GLint dstStride = _mesa_image_row_stride(packing, width,
                                                     format, type);
      GLubyte *dest
         = (GLubyte *) _mesa_image_address2d(packing, pixels, width, height,
                                             format, type, 0, 0);
      GLint row;
      ASSERT(rb->GetRow);
      for (row = 0; row < height; row++) {
         rb->GetRow(ctx, rb, width, x, y + row, dest);
         dest += dstStride;
      }
      return GL_TRUE;
   }

   if (format == GL_RGB &&
       rb->DataType == GL_UNSIGNED_BYTE &&
       type == GL_UNSIGNED_BYTE) {
      const GLint dstStride = _mesa_image_row_stride(packing, width,
                                                     format, type);
      GLubyte *dest
         = (GLubyte *) _mesa_image_address2d(packing, pixels, width, height,
                                             format, type, 0, 0);
      GLint row;
      ASSERT(rb->GetRow);
      for (row = 0; row < height; row++) {
         GLubyte tempRow[MAX_WIDTH][4];
         GLint col;
         rb->GetRow(ctx, rb, width, x, y + row, tempRow);
         /* convert RGBA to RGB */
         for (col = 0; col < width; col++) {
            dest[col * 3 + 0] = tempRow[col][0];
            dest[col * 3 + 1] = tempRow[col][1];
            dest[col * 3 + 2] = tempRow[col][2];
         }
         dest += dstStride;
      }
      return GL_TRUE;
   }

   /* not handled */
   return GL_FALSE;
}


/**
 * When we're using a low-precision color buffer (like 16-bit 5/6/5)
 * we have to adjust our color values a bit to pass conformance.
 * The problem is when a 5 or 6-bit color value is converted to an 8-bit
 * value and then a floating point value, the floating point values don't
 * increment uniformly as the 5 or 6-bit value is incremented.
 *
 * This function adjusts floating point values to compensate.
 */
static void
adjust_colors(const struct gl_framebuffer *fb, GLuint n, GLfloat rgba[][4])
{
   const GLuint rShift = 8 - fb->Visual.redBits;
   const GLuint gShift = 8 - fb->Visual.greenBits;
   const GLuint bShift = 8 - fb->Visual.blueBits;
   GLfloat rScale = 1.0F / (GLfloat) ((1 << fb->Visual.redBits  ) - 1);
   GLfloat gScale = 1.0F / (GLfloat) ((1 << fb->Visual.greenBits) - 1);
   GLfloat bScale = 1.0F / (GLfloat) ((1 << fb->Visual.blueBits ) - 1);
   GLuint i;

   if (fb->Visual.redBits == 0)
      rScale = 0;
   if (fb->Visual.greenBits == 0)
      gScale = 0;
   if (fb->Visual.blueBits == 0)
      bScale = 0;

   for (i = 0; i < n; i++) {
      GLint r, g, b;
      /* convert float back to ubyte */
      CLAMPED_FLOAT_TO_UBYTE(r, rgba[i][RCOMP]);
      CLAMPED_FLOAT_TO_UBYTE(g, rgba[i][GCOMP]);
      CLAMPED_FLOAT_TO_UBYTE(b, rgba[i][BCOMP]);
      /* using only the N most significant bits of the ubyte value, convert to
       * float in [0,1].
       */
      rgba[i][RCOMP] = (GLfloat) (r >> rShift) * rScale;
      rgba[i][GCOMP] = (GLfloat) (g >> gShift) * gScale;
      rgba[i][BCOMP] = (GLfloat) (b >> bShift) * bScale;
   }
}



/*
 * Read R, G, B, A, RGB, L, or LA pixels.
 */
static void
read_rgba_pixels( struct gl_context *ctx,
                  GLint x, GLint y,
                  GLsizei width, GLsizei height,
                  GLenum format, GLenum type, GLvoid *pixels,
                  const struct gl_pixelstore_attrib *packing )
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
   GLbitfield transferOps = ctx->_ImageTransferState;
   struct gl_framebuffer *fb = ctx->ReadBuffer;
   struct gl_renderbuffer *rb = fb->_ColorReadBuffer;

   if (!rb)
      return;

   if ((ctx->Color._ClampReadColor == GL_TRUE || type != GL_FLOAT) &&
       !_mesa_is_integer_format(format)) {
      transferOps |= IMAGE_CLAMP_BIT;
   }

   /* Try the optimized path first. */
   if (fast_read_rgba_pixels(ctx, x, y, width, height,
                             format, type, pixels, packing, transferOps)) {
      return; /* done! */
   }

   /* width should never be > MAX_WIDTH since we did clipping earlier */
   ASSERT(width <= MAX_WIDTH);

   do {
      const GLint dstStride
         = _mesa_image_row_stride(packing, width, format, type);
      GLfloat (*rgba)[4] = swrast->SpanArrays->attribs[FRAG_ATTRIB_COL0];
      GLint row;
      GLubyte *dst
         = (GLubyte *) _mesa_image_address2d(packing, pixels, width, height,
                                             format, type, 0, 0);

      for (row = 0; row < height; row++, y++) {

         /* Get float rgba pixels */
         _swrast_read_rgba_span(ctx, rb, width, x, y, GL_FLOAT, rgba);

         /* apply fudge factor for shallow color buffers */
         if ((fb->Visual.redBits < 8 && fb->Visual.redBits != 0) ||
             (fb->Visual.greenBits < 8 && fb->Visual.greenBits != 0) ||
	     (fb->Visual.blueBits < 8 && fb->Visual.blueBits != 0)) {
            adjust_colors(fb, width, rgba);
         }

         /* pack the row of RGBA pixels into user's buffer */
         _mesa_pack_rgba_span_float(ctx, width, rgba, format, type, dst,
                                    packing, transferOps);

         dst += dstStride;
      }
   } while (0);
}


/**
 * Read combined depth/stencil values.
 * We'll have already done error checking to be sure the expected
 * depth and stencil buffers really exist.
 */
static void
read_depth_stencil_pixels(struct gl_context *ctx,
                          GLint x, GLint y,
                          GLsizei width, GLsizei height,
                          GLenum type, GLvoid *pixels,
                          const struct gl_pixelstore_attrib *packing )
{
   const GLboolean scaleOrBias
      = ctx->Pixel.DepthScale != 1.0 || ctx->Pixel.DepthBias != 0.0;
   const GLboolean stencilTransfer = ctx->Pixel.IndexShift
      || ctx->Pixel.IndexOffset || ctx->Pixel.MapStencilFlag;
   struct gl_renderbuffer *depthRb, *stencilRb;

   depthRb = ctx->ReadBuffer->_DepthBuffer;
   stencilRb = ctx->ReadBuffer->_StencilBuffer;

   if (!depthRb || !stencilRb)
      return;

   depthRb = ctx->ReadBuffer->Attachment[BUFFER_DEPTH].Renderbuffer;
   stencilRb = ctx->ReadBuffer->Attachment[BUFFER_STENCIL].Renderbuffer;

   if (depthRb->_BaseFormat == GL_DEPTH_STENCIL_EXT &&
       stencilRb->_BaseFormat == GL_DEPTH_STENCIL_EXT &&
       depthRb == stencilRb &&
       !scaleOrBias &&
       !stencilTransfer) {
      /* This is the ideal case.
       * Reading GL_DEPTH_STENCIL pixels from combined depth/stencil buffer.
       * Plus, no pixel transfer ops to worry about!
       */
      GLint i;
      GLint dstStride = _mesa_image_row_stride(packing, width,
                                               GL_DEPTH_STENCIL_EXT, type);
      GLubyte *dst = (GLubyte *) _mesa_image_address2d(packing, pixels,
                                                       width, height,
                                                       GL_DEPTH_STENCIL_EXT,
                                                       type, 0, 0);
      for (i = 0; i < height; i++) {
         depthRb->GetRow(ctx, depthRb, width, x, y + i, dst);
         dst += dstStride;
      }
   }
   else {
      /* Reading GL_DEPTH_STENCIL pixels from separate depth/stencil buffers,
       * or we need pixel transfer.
       */
      GLint i;
      depthRb = ctx->ReadBuffer->_DepthBuffer;
      stencilRb = ctx->ReadBuffer->_StencilBuffer;

      for (i = 0; i < height; i++) {
         GLstencil stencilVals[MAX_WIDTH];

         GLuint *depthStencilDst = (GLuint *)
            _mesa_image_address2d(packing, pixels, width, height,
                                  GL_DEPTH_STENCIL_EXT, type, i, 0);

         _swrast_read_stencil_span(ctx, stencilRb, width,
                                   x, y + i, stencilVals);

         if (!scaleOrBias && !stencilTransfer
             && ctx->ReadBuffer->Visual.depthBits == 24) {
            /* ideal case */
            GLuint zVals[MAX_WIDTH]; /* 24-bit values! */
            GLint j;
            ASSERT(depthRb->DataType == GL_UNSIGNED_INT);
            /* note, we've already been clipped */
            depthRb->GetRow(ctx, depthRb, width, x, y + i, zVals);
            for (j = 0; j < width; j++) {
               depthStencilDst[j] = (zVals[j] << 8) | (stencilVals[j] & 0xff);
            }
         }
         else {
            /* general case */
            GLfloat depthVals[MAX_WIDTH];
            _swrast_read_depth_span_float(ctx, depthRb, width, x, y + i,
                                          depthVals);
            _mesa_pack_depth_stencil_span(ctx, width, depthStencilDst,
                                          depthVals, stencilVals, packing);
         }
      }
   }
}



/**
 * Software fallback routine for ctx->Driver.ReadPixels().
 * By time we get here, all error checking will have been done.
 */
void
_swrast_ReadPixels( struct gl_context *ctx,
		    GLint x, GLint y, GLsizei width, GLsizei height,
		    GLenum format, GLenum type,
		    const struct gl_pixelstore_attrib *packing,
		    GLvoid *pixels )
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
   struct gl_pixelstore_attrib clippedPacking = *packing;

   if (ctx->NewState)
      _mesa_update_state(ctx);

   /* Need to do swrast_render_start() before clipping or anything else
    * since this is where a driver may grab the hw lock and get an updated
    * window size.
    */
   swrast_render_start(ctx);

   if (swrast->NewState)
      _swrast_validate_derived( ctx );

   /* Do all needed clipping here, so that we can forget about it later */
   if (_mesa_clip_readpixels(ctx, &x, &y, &width, &height, &clippedPacking)) {

      pixels = _mesa_map_pbo_dest(ctx, &clippedPacking, pixels);

      if (pixels) {
         switch (format) {
         case GL_STENCIL_INDEX:
            read_stencil_pixels(ctx, x, y, width, height, type, pixels,
                                &clippedPacking);
            break;
         case GL_DEPTH_COMPONENT:
            read_depth_pixels(ctx, x, y, width, height, type, pixels,
                              &clippedPacking);
            break;
         case GL_DEPTH_STENCIL_EXT:
            read_depth_stencil_pixels(ctx, x, y, width, height, type, pixels,
                                      &clippedPacking);
            break;
         default:
            /* all other formats should be color formats */
            read_rgba_pixels(ctx, x, y, width, height, format, type, pixels,
                             &clippedPacking);
         }

         _mesa_unmap_pbo_dest(ctx, &clippedPacking);
      }
   }

   swrast_render_finish(ctx);
}
@


1.7
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@@


1.6
log
@Merge Mesa 7.10.3
@
text
@a26 1
#include "main/bufferobj.h"
d34 1
d198 3
d321 2
a322 3
   if (type == GL_FLOAT && ((ctx->Color.ClampReadColor == GL_TRUE) ||
                            (ctx->Color.ClampReadColor == GL_FIXED_ONLY_ARB &&
                             rb->DataType != GL_FLOAT)))
d324 1
d326 1
a326 1
   /* Try optimized path first */
@


1.5
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@a28 2
#include "main/convolve.h"
#include "main/context.h"
d32 1
d34 1
a34 1
#include "main/imports.h"
d47 1
a47 1
read_depth_pixels( GLcontext *ctx,
d143 1
a143 1
read_stencil_pixels( GLcontext *ctx,
d181 1
a181 1
fast_read_rgba_pixels( GLcontext *ctx,
d194 5
a198 1
   ASSERT(rb->_BaseFormat == GL_RGBA || rb->_BaseFormat == GL_RGB);
d271 3
a273 3
   const GLfloat rScale = 1.0F / (GLfloat) ((1 << fb->Visual.redBits  ) - 1);
   const GLfloat gScale = 1.0F / (GLfloat) ((1 << fb->Visual.greenBits) - 1);
   const GLfloat bScale = 1.0F / (GLfloat) ((1 << fb->Visual.blueBits ) - 1);
d275 8
d304 1
a304 1
read_rgba_pixels( GLcontext *ctx,
d332 1
a332 51
   if (ctx->Pixel.Convolution2DEnabled || ctx->Pixel.Separable2DEnabled) {
      GLfloat *dest, *src, *tmpImage, *convImage;
      GLint row;

      tmpImage = (GLfloat *) malloc(width * height * 4 * sizeof(GLfloat));
      if (!tmpImage) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glReadPixels");
         return;
      }
      convImage = (GLfloat *) malloc(width * height * 4 * sizeof(GLfloat));
      if (!convImage) {
         free(tmpImage);
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glReadPixels");
         return;
      }

      /* read full RGBA, FLOAT image */
      dest = tmpImage;
      for (row = 0; row < height; row++, y++) {
         _swrast_read_rgba_span(ctx, rb, width, x, y, GL_FLOAT, dest);
         _mesa_apply_rgba_transfer_ops(ctx, 
                                      transferOps & IMAGE_PRE_CONVOLUTION_BITS,
                                      width, (GLfloat (*)[4]) dest);
         dest += width * 4;
      }

      /* do convolution */
      if (ctx->Pixel.Convolution2DEnabled) {
         _mesa_convolve_2d_image(ctx, &width, &height, tmpImage, convImage);
      }
      else {
         ASSERT(ctx->Pixel.Separable2DEnabled);
         _mesa_convolve_sep_image(ctx, &width, &height, tmpImage, convImage);
      }
      free(tmpImage);

      /* finish transfer ops and pack the resulting image */
      src = convImage;
      for (row = 0; row < height; row++) {
         GLvoid *dest;
         dest = _mesa_image_address2d(packing, pixels, width, height,
                                      format, type, row, 0);
         _mesa_pack_rgba_span_float(ctx, width, (GLfloat (*)[4]) src,
                                    format, type, dest, packing,
                                    transferOps & IMAGE_POST_CONVOLUTION_BITS);
         src += width * 4;
      }
      free(convImage);
   }
   else {
      /* no convolution */
a340 4
      /* make sure we don't apply 1D convolution */
      transferOps &= ~(IMAGE_CONVOLUTION_BIT |
                       IMAGE_POST_CONVOLUTION_SCALE_BIAS);

d347 3
a349 3
         if (fb->Visual.redBits < 8 ||
             fb->Visual.greenBits < 8 ||
             fb->Visual.blueBits < 8) {
d359 1
a359 1
   }
d369 1
a369 1
read_depth_stencil_pixels(GLcontext *ctx,
d460 1
a460 1
_swrast_ReadPixels( GLcontext *ctx,
d482 3
a484 5
   if (!_mesa_clip_readpixels(ctx, &x, &y, &width, &height, &clippedPacking)) {
      /* The ReadPixels region is totally outside the window bounds */
      swrast_render_finish(ctx);
      return;
   }
d486 17
a502 7
   pixels = _mesa_map_pbo_dest(ctx, &clippedPacking, pixels);
   if (!pixels)
      return;
  
   switch (format) {
      case GL_STENCIL_INDEX:
	 read_stencil_pixels(ctx, x, y, width, height, type, pixels,
d504 4
a507 26
         break;
      case GL_DEPTH_COMPONENT:
	 read_depth_pixels(ctx, x, y, width, height, type, pixels,
                           &clippedPacking);
	 break;
      case GL_RED:
      case GL_GREEN:
      case GL_BLUE:
      case GL_ALPHA:
      case GL_RGB:
      case GL_LUMINANCE:
      case GL_LUMINANCE_ALPHA:
      case GL_RGBA:
      case GL_BGR:
      case GL_BGRA:
      case GL_ABGR_EXT:
         read_rgba_pixels(ctx, x, y, width, height,
                          format, type, pixels, &clippedPacking);
	 break;
      case GL_DEPTH_STENCIL_EXT:
         read_depth_stencil_pixels(ctx, x, y, width, height,
                                   type, pixels, &clippedPacking);
         break;
      default:
	 _mesa_problem(ctx, "unexpected format in _swrast_ReadPixels");
         /* don't return yet, clean-up */
a510 2

   _mesa_unmap_pbo_dest(ctx, &clippedPacking);
@


1.4
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d32 1
a35 1
#include "main/pixel.h"
a43 36
/*
 * Read a block of color index pixels.
 */
static void
read_index_pixels( GLcontext *ctx,
                   GLint x, GLint y,
                   GLsizei width, GLsizei height,
                   GLenum type, GLvoid *pixels,
                   const struct gl_pixelstore_attrib *packing )
{
   struct gl_renderbuffer *rb = ctx->ReadBuffer->_ColorReadBuffer;
   GLint i;

   if (!rb)
      return;

   /* width should never be > MAX_WIDTH since we did clipping earlier */
   ASSERT(width <= MAX_WIDTH);

   /* process image row by row */
   for (i = 0; i < height; i++) {
      GLuint index[MAX_WIDTH];
      GLvoid *dest;
      ASSERT(rb->DataType == GL_UNSIGNED_INT);
      rb->GetRow(ctx, rb, width, x, y + i, index);

      dest = _mesa_image_address2d(packing, pixels, width, height,
                                   GL_COLOR_INDEX, type, i, 0);

      _mesa_pack_index_span(ctx, width, type, dest, index,
                            &ctx->Pack, ctx->_ImageTransferState);
   }
}



d74 1
a74 1
      ASSERT(rb->InternalFormat == GL_DEPTH_COMPONENT16);
d86 6
a91 2
      ASSERT(rb->InternalFormat == GL_DEPTH_COMPONENT24);
      ASSERT(rb->DataType == GL_UNSIGNED_INT);
d99 12
a110 3
         for (k = 0; k < width; k++) {
            /* Note: put MSByte of 24-bit value into LSByte */
            dest[k] = (dest[k] << 8) | ((dest[k] >> 16) & 0xff);
d118 1
a118 1
      ASSERT(rb->InternalFormat == GL_DEPTH_COMPONENT32);
d256 1
a256 1
 * The problem is when a 5 or 6-bit color value is convert to an 8-bit
d263 1
a263 1
adjust_colors(GLcontext *ctx, GLuint n, GLfloat rgba[][4])
d265 6
a270 6
   const GLuint rShift = 8 - ctx->Visual.redBits;
   const GLuint gShift = 8 - ctx->Visual.greenBits;
   const GLuint bShift = 8 - ctx->Visual.blueBits;
   const GLfloat rScale = 1.0F / (GLfloat) ((1 << ctx->Visual.redBits  ) - 1);
   const GLfloat gScale = 1.0F / (GLfloat) ((1 << ctx->Visual.greenBits) - 1);
   const GLfloat bScale = 1.0F / (GLfloat) ((1 << ctx->Visual.blueBits ) - 1);
d325 1
a325 1
      tmpImage = (GLfloat *) _mesa_malloc(width * height * 4 * sizeof(GLfloat));
d330 1
a330 1
      convImage = (GLfloat *) _mesa_malloc(width * height * 4 * sizeof(GLfloat));
d332 1
a332 1
         _mesa_free(tmpImage);
d340 1
a340 12
         if (fb->Visual.rgbMode) {
            _swrast_read_rgba_span(ctx, rb, width, x, y, GL_FLOAT, dest);
         }
         else {
            GLuint index[MAX_WIDTH];
            ASSERT(rb->DataType == GL_UNSIGNED_INT);
            rb->GetRow(ctx, rb, width, x, y, index);
            _mesa_apply_ci_transfer_ops(ctx,
                                        transferOps & IMAGE_SHIFT_OFFSET_BIT,
                                        width, index);
            _mesa_map_ci_to_rgba(ctx, width, index, (GLfloat (*)[4]) dest);
         }
d355 1
a355 1
      _mesa_free(tmpImage);
d368 1
a368 1
      _mesa_free(convImage);
d387 1
a387 13
         if (fb->Visual.rgbMode) {
            _swrast_read_rgba_span(ctx, rb, width, x, y, GL_FLOAT, rgba);
         }
         else {
            /* read CI and convert to RGBA */
            GLuint index[MAX_WIDTH];
            ASSERT(rb->DataType == GL_UNSIGNED_INT);
            rb->GetRow(ctx, rb, width, x, y, index);
            _mesa_apply_ci_transfer_ops(ctx,
                                        transferOps & IMAGE_SHIFT_OFFSET_BIT,
                                        width, index);
            _mesa_map_ci_to_rgba(ctx, width, index, rgba);
         }
d393 1
a393 1
            adjust_colors(ctx, width, rgba);
a511 6
   /* Need to do RENDER_START before clipping or anything else since this
    * is where a driver may grab the hw lock and get an updated window
    * size.
    */
   RENDER_START(swrast, ctx);

d515 6
d527 1
a527 1
      RENDER_FINISH(swrast, ctx);
d531 1
a531 1
   pixels = _mesa_map_readpix_pbo(ctx, &clippedPacking, pixels);
a535 4
      case GL_COLOR_INDEX:
         read_index_pixels(ctx, x, y, width, height, type, pixels,
                           &clippedPacking);
	 break;
d567 1
a567 1
   RENDER_FINISH(swrast, ctx);
d569 1
a569 1
   _mesa_unmap_readpix_pbo(ctx, &clippedPacking);
@


1.3
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d26 11
a36 11
#include "glheader.h"
#include "bufferobj.h"
#include "colormac.h"
#include "convolve.h"
#include "context.h"
#include "feedback.h"
#include "image.h"
#include "macros.h"
#include "imports.h"
#include "pixel.h"
#include "state.h"
@


1.2
log
@Update to Mesa 7.0.3. tested my oga@@ and johan@@
@
text
@d577 4
a580 22
   if (clippedPacking.BufferObj->Name) {
      /* pack into PBO */
      GLubyte *buf;
      if (!_mesa_validate_pbo_access(2, &clippedPacking, width, height, 1,
                                     format, type, pixels)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glReadPixels(invalid PBO access)");
	 RENDER_FINISH(swrast, ctx);
	 return;
      }
      buf = (GLubyte *) ctx->Driver.MapBuffer(ctx, GL_PIXEL_PACK_BUFFER_EXT,
                                              GL_WRITE_ONLY_ARB,
                                              clippedPacking.BufferObj);
      if (!buf) {
         /* buffer is already mapped - that's an error */
         _mesa_error(ctx, GL_INVALID_OPERATION, "glReadPixels(PBO is mapped)");
	 RENDER_FINISH(swrast, ctx);
	 return;
      }
      pixels = ADD_POINTERS(buf, pixels);
   }

d619 1
a619 5
   if (clippedPacking.BufferObj->Name) {
      /* done with PBO so unmap it now */
      ctx->Driver.UnmapBuffer(ctx, GL_PIXEL_PACK_BUFFER_EXT,
                              clippedPacking.BufferObj);
   }
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * Version:  6.5
d5 1
a5 1
 * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
d57 2
a58 1
   ASSERT(rb);
d95 3
d101 2
a102 2
   ASSERT(x + width <= rb->Width);
   ASSERT(y + height <= rb->Height);
a105 2
   ASSERT(rb);

d122 1
a122 1
      ASSERT(rb->InternalFormat == GL_DEPTH_COMPONENT32);
d132 2
a133 1
            dest[k] = (dest[k] << 8) | (dest[k] >> 24);
d177 2
a178 1
   ASSERT(rb);
d200 3
a202 3
 * Optimized glReadPixels for particular pixel formats:
 *   GL_UNSIGNED_BYTE, GL_RGBA
 * when pixel scaling, biasing and mapping are disabled.
d205 1
a205 1
read_fast_rgba_pixels( GLcontext *ctx,
d210 2
a211 1
                       const struct gl_pixelstore_attrib *packing )
d215 4
a218 3
   /* can't do scale, bias, mapping, etc */
   if (ctx->_ImageTransferState)
       return GL_FALSE;
d220 8
a227 2
   /* can't do fancy pixel packing */
   if (packing->Alignment != 1 || packing->SwapBytes || packing->LsbFirst)
d229 1
d231 14
a244 38
   {
      GLint srcX = x;
      GLint srcY = y;
      GLint readWidth = width;           /* actual width read */
      GLint readHeight = height;         /* actual height read */
      GLint skipPixels = packing->SkipPixels;
      GLint skipRows = packing->SkipRows;
      GLint rowLength;

      if (packing->RowLength > 0)
         rowLength = packing->RowLength;
      else
         rowLength = width;

      /*
       * Ready to read!
       * The window region at (destX, destY) of size (readWidth, readHeight)
       * will be read back.
       * We'll write pixel data to buffer pointed to by "pixels" but we'll
       * skip "skipRows" rows and skip "skipPixels" pixels/row.
       */
#if CHAN_BITS == 8
      if (format == GL_RGBA && type == GL_UNSIGNED_BYTE)
#elif CHAN_BITS == 16
      if (format == GL_RGBA && type == GL_UNSIGNED_SHORT)
#else
      if (0)
#endif
      {
         GLchan *dest = (GLchan *) pixels
                      + (skipRows * rowLength + skipPixels) * 4;
         GLint row;

         if (packing->Invert) {
            /* start at top and go down */
            dest += (readHeight - 1) * rowLength * 4;
            rowLength = -rowLength;
         }
d246 19
a264 5
         ASSERT(rb->GetRow);
         for (row=0; row<readHeight; row++) {
            rb->GetRow(ctx, rb, readWidth, srcX, srcY, dest);
            dest += rowLength * 4;
            srcY++;
d266 1
a266 5
         return GL_TRUE;
      }
      else {
         /* can't do this format/type combination */
         return GL_FALSE;
d268 39
d322 2
d327 7
a333 1
   ASSERT(rb);
d336 2
a337 2
   if (read_fast_rgba_pixels( ctx, x, y, width, height,
                              format, type, pixels, packing )) {
a344 1
      const GLuint transferOps = ctx->_ImageTransferState;
a362 1
         GLchan rgba[MAX_WIDTH][4];
d364 1
a364 1
            _swrast_read_rgba_span(ctx, rb, width, x, y, rgba);
d370 8
a377 8
            if (ctx->Pixel.IndexShift != 0 || ctx->Pixel.IndexOffset !=0 ) {
               _mesa_map_ci(ctx, width, index);
            }
            _mesa_map_ci_to_rgba_chan(ctx, width, index, rgba);
         }
         _mesa_pack_rgba_span_chan(ctx, width, (const GLchan (*)[4]) rgba,
                              GL_RGBA, GL_FLOAT, dest, &ctx->DefaultPacking,
                              transferOps & IMAGE_PRE_CONVOLUTION_BITS);
d397 1
a397 2
         _mesa_pack_rgba_span_float(ctx, width,
                                    (const GLfloat (*)[4]) src,
d406 3
d410 8
d419 2
a420 2
         GLchan rgba[MAX_WIDTH][4];
         GLvoid *dst;
d422 1
a422 1
            _swrast_read_rgba_span(ctx, rb, width, x, y, rgba);
d425 1
d429 18
a446 28
            if (ctx->Pixel.IndexShift != 0 || ctx->Pixel.IndexOffset != 0) {
               _mesa_map_ci(ctx, width, index);
            }
            _mesa_map_ci_to_rgba_chan(ctx, width, index, rgba);
         }
         dst = _mesa_image_address2d(packing, pixels, width, height,
                                     format, type, row, 0);
         if (fb->Visual.redBits < CHAN_BITS ||
             fb->Visual.greenBits < CHAN_BITS ||
             fb->Visual.blueBits < CHAN_BITS) {
            /* Requantize the color values into floating point and go from
             * there.  This fixes conformance failures with 5/6/5 color
             * buffers, for example.
             */
            GLfloat rgbaf[MAX_WIDTH][4];
            _mesa_chan_to_float_span(ctx, width,
                                     (CONST GLchan (*)[4]) rgba, rgbaf);
            _mesa_pack_rgba_span_float(ctx, width,
                                       (CONST GLfloat (*)[4]) rgbaf,
                                       format, type, dst, packing,
                                       ctx->_ImageTransferState);
         }
         else {
            /* GLubytes are fine */
            _mesa_pack_rgba_span_chan(ctx, width, (CONST GLchan (*)[4]) rgba,
                                 format, type, dst, packing,
                                 ctx->_ImageTransferState);
         }
d473 2
a474 2
   ASSERT(depthRb);
   ASSERT(stencilRb);
d573 1
d584 2
a585 1
         goto end;
d593 2
a594 1
         goto end;
a634 2

end:
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d3 1
a3 1
 * Version:  6.5.2
d196 3
a198 2
 * Optimized glReadPixels for particular pixel formats when pixel
 * scaling, biasing, mapping, etc. are disabled.
d201 1
a201 1
fast_read_rgba_pixels( GLcontext *ctx,
d206 1
a206 2
                       const struct gl_pixelstore_attrib *packing,
                       GLbitfield transferOps)
d210 3
a212 1
   ASSERT(rb->_BaseFormat == GL_RGBA || rb->_BaseFormat == GL_RGB);
d214 2
a215 8
   /* clipping should have already been done */
   ASSERT(x + width <= rb->Width);
   ASSERT(y + height <= rb->Height);

   /* check for things we can't handle here */
   if (transferOps ||
       packing->SwapBytes ||
       packing->LsbFirst) {
a216 1
   }
d218 38
a255 13
   if (format == GL_RGBA && rb->DataType == type) {
      const GLint dstStride = _mesa_image_row_stride(packing, width,
                                                     format, type);
      GLubyte *dest = _mesa_image_address2d(packing, pixels, width, height,
                                            format, type, 0, 0);
      GLint row;
      ASSERT(rb->GetRow);
      for (row = 0; row < height; row++) {
         rb->GetRow(ctx, rb, width, x, y + row, dest);
         dest += dstStride;
      }
      return GL_TRUE;
   }
d257 5
a261 18
   if (format == GL_RGB &&
       rb->DataType == GL_UNSIGNED_BYTE &&
       type == GL_UNSIGNED_BYTE) {
      const GLint dstStride = _mesa_image_row_stride(packing, width,
                                                     format, type);
      GLubyte *dest = _mesa_image_address2d(packing, pixels, width, height,
                                            format, type, 0, 0);
      GLint row;
      ASSERT(rb->GetRow);
      for (row = 0; row < height; row++) {
         GLubyte tempRow[MAX_WIDTH][4];
         GLint col;
         rb->GetRow(ctx, rb, width, x, y + row, tempRow);
         /* convert RGBA to RGB */
         for (col = 0; col < width; col++) {
            dest[col * 3 + 0] = tempRow[col][0];
            dest[col * 3 + 1] = tempRow[col][1];
            dest[col * 3 + 2] = tempRow[col][2];
d263 5
a267 1
         dest += dstStride;
a268 39
      return GL_TRUE;
   }

   /* not handled */
   return GL_FALSE;
}


/**
 * When we're using a low-precision color buffer (like 16-bit 5/6/5)
 * we have to adjust our color values a bit to pass conformance.
 * The problem is when a 5 or 6-bit color value is convert to an 8-bit
 * value and then a floating point value, the floating point values don't
 * increment uniformly as the 5 or 6-bit value is incremented.
 *
 * This function adjusts floating point values to compensate.
 */
static void
adjust_colors(GLcontext *ctx, GLuint n, GLfloat rgba[][4])
{
   const GLuint rShift = 8 - ctx->Visual.redBits;
   const GLuint gShift = 8 - ctx->Visual.greenBits;
   const GLuint bShift = 8 - ctx->Visual.blueBits;
   const GLfloat rScale = 1.0F / (GLfloat) ((1 << ctx->Visual.redBits  ) - 1);
   const GLfloat gScale = 1.0F / (GLfloat) ((1 << ctx->Visual.greenBits) - 1);
   const GLfloat bScale = 1.0F / (GLfloat) ((1 << ctx->Visual.blueBits ) - 1);
   GLuint i;
   for (i = 0; i < n; i++) {
      GLint r, g, b;
      /* convert float back to ubyte */
      CLAMPED_FLOAT_TO_UBYTE(r, rgba[i][RCOMP]);
      CLAMPED_FLOAT_TO_UBYTE(g, rgba[i][GCOMP]);
      CLAMPED_FLOAT_TO_UBYTE(b, rgba[i][BCOMP]);
      /* using only the N most significant bits of the ubyte value, convert to
       * float in [0,1].
       */
      rgba[i][RCOMP] = (GLfloat) (r >> rShift) * rScale;
      rgba[i][GCOMP] = (GLfloat) (g >> gShift) * gScale;
      rgba[i][BCOMP] = (GLfloat) (b >> bShift) * bScale;
a283 2
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
   GLbitfield transferOps = ctx->_ImageTransferState;
a288 5
   if (type == GL_FLOAT && ((ctx->Color.ClampReadColor == GL_TRUE) ||
                            (ctx->Color.ClampReadColor == GL_FIXED_ONLY_ARB &&
                             rb->DataType != GL_FLOAT)))
      transferOps |= IMAGE_CLAMP_BIT;

d290 2
a291 2
   if (fast_read_rgba_pixels(ctx, x, y, width, height,
                             format, type, pixels, packing, transferOps)) {
d299 1
d318 1
d320 1
a320 1
            _swrast_read_rgba_span(ctx, rb, width, x, y, GL_FLOAT, dest);
d326 8
a333 8
            _mesa_apply_ci_transfer_ops(ctx,
                                        transferOps & IMAGE_SHIFT_OFFSET_BIT,
                                        width, index);
            _mesa_map_ci_to_rgba(ctx, width, index, (GLfloat (*)[4]) dest);
         }
         _mesa_apply_rgba_transfer_ops(ctx, 
                                      transferOps & IMAGE_PRE_CONVOLUTION_BITS,
                                      width, (GLfloat (*)[4]) dest);
d353 2
a354 1
         _mesa_pack_rgba_span_float(ctx, width, (GLfloat (*)[4]) src,
a362 3
      const GLint dstStride
         = _mesa_image_row_stride(packing, width, format, type);
      GLfloat (*rgba)[4] = swrast->SpanArrays->color.sz4.rgba;
a363 3
      GLubyte *dst = _mesa_image_address2d(packing, pixels, width, height,
                                           format, type, 0, 0);

d365 2
a366 2

         /* Get float rgba pixels */
d368 1
a368 1
            _swrast_read_rgba_span(ctx, rb, width, x, y, GL_FLOAT, rgba);
a370 1
            /* read CI and convert to RGBA */
d374 28
a401 18
            _mesa_apply_ci_transfer_ops(ctx,
                                        transferOps & IMAGE_SHIFT_OFFSET_BIT,
                                        width, index);
            _mesa_map_ci_to_rgba(ctx, width, index, rgba);
         }

         /* apply fudge factor for shallow color buffers */
         if (fb->Visual.redBits < 8 ||
             fb->Visual.greenBits < 8 ||
             fb->Visual.blueBits < 8) {
            adjust_colors(ctx, width, rgba);
         }

         /* pack the row of RGBA pixels into user's buffer */
         _mesa_pack_rgba_span_float(ctx, width, rgba, format, type, dst,
                                    packing, transferOps);

         dst += dstStride;
d528 1
a528 1
      goto end;
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d3 1
a3 1
 * Version:  6.5.3
d5 1
a5 1
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
d57 1
a57 2
   if (!rb)
      return;
a93 3
   if (!rb)
      return;

d97 2
a98 2
   ASSERT(x + width <= (GLint) rb->Width);
   ASSERT(y + height <= (GLint) rb->Height);
d102 2
d120 1
a120 1
      ASSERT(rb->InternalFormat == GL_DEPTH_COMPONENT24);
d174 1
a174 2
   if (!rb)
      return;
a197 1
 * \return GL_TRUE if success, GL_FALSE if unable to do the readpixels
a209 3
   if (!rb)
      return GL_FALSE;

d213 2
a214 2
   ASSERT(x + width <= (GLint) rb->Width);
   ASSERT(y + height <= (GLint) rb->Height);
d226 2
a227 3
      GLubyte *dest
         = (GLubyte *) _mesa_image_address2d(packing, pixels, width, height,
                                             format, type, 0, 0);
d242 2
a243 3
      GLubyte *dest
         = (GLubyte *) _mesa_image_address2d(packing, pixels, width, height,
                                             format, type, 0, 0);
d317 1
a317 2
   if (!rb)
      return;
d397 1
a397 1
      GLfloat (*rgba)[4] = swrast->SpanArrays->attribs[FRAG_ATTRIB_COL0];
d399 2
a400 7
      GLubyte *dst
         = (GLubyte *) _mesa_image_address2d(packing, pixels, width, height,
                                             format, type, 0, 0);

      /* make sure we don't apply 1D convolution */
      transferOps &= ~(IMAGE_CONVOLUTION_BIT |
                       IMAGE_POST_CONVOLUTION_SCALE_BIAS);
d457 2
a458 2
   if (!depthRb || !stencilRb)
      return;
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d3 1
a3 1
 * Version:  7.0.3
d26 11
a36 10
#include "main/glheader.h"
#include "main/bufferobj.h"
#include "main/colormac.h"
#include "main/feedback.h"
#include "main/formats.h"
#include "main/image.h"
#include "main/imports.h"
#include "main/macros.h"
#include "main/pack.h"
#include "main/state.h"
d44 36
d84 1
a84 1
read_depth_pixels( struct gl_context *ctx,
d110 1
a110 1
      ASSERT(rb->Format == MESA_FORMAT_Z16);
d122 2
a123 6
      ASSERT(rb->Format == MESA_FORMAT_X8_Z24 ||
             rb->Format == MESA_FORMAT_S8_Z24 ||
             rb->Format == MESA_FORMAT_Z24_X8 ||
             rb->Format == MESA_FORMAT_Z24_S8);
      ASSERT(rb->DataType == GL_UNSIGNED_INT ||
             rb->DataType == GL_UNSIGNED_INT_24_8);
d131 2
a132 12
         if (rb->Format == MESA_FORMAT_X8_Z24 ||
             rb->Format == MESA_FORMAT_S8_Z24) {
            for (k = 0; k < width; k++) {
               /* Note: put MSByte of 24-bit value into LSByte */
               dest[k] = (dest[k] << 8) | ((dest[k] >> 16) & 0xff);
            }
         }
         else {
            for (k = 0; k < width; k++) {
               /* Note: fill in LSByte by replication */
               dest[k] = dest[k] | ((dest[k] >> 8) & 0xff);
            }
d140 1
a140 1
      ASSERT(rb->Format == MESA_FORMAT_Z32);
d166 1
a166 1
read_stencil_pixels( struct gl_context *ctx,
d204 1
a204 1
fast_read_rgba_pixels( struct gl_context *ctx,
d217 1
a217 5
   ASSERT(rb->_BaseFormat == GL_RGBA ||
	  rb->_BaseFormat == GL_RGB ||
	  rb->_BaseFormat == GL_RG ||
	  rb->_BaseFormat == GL_RED ||
	  rb->_BaseFormat == GL_ALPHA);
d278 1
a278 1
 * The problem is when a 5 or 6-bit color value is converted to an 8-bit
d285 1
a285 1
adjust_colors(const struct gl_framebuffer *fb, GLuint n, GLfloat rgba[][4])
d287 6
a292 6
   const GLuint rShift = 8 - fb->Visual.redBits;
   const GLuint gShift = 8 - fb->Visual.greenBits;
   const GLuint bShift = 8 - fb->Visual.blueBits;
   GLfloat rScale = 1.0F / (GLfloat) ((1 << fb->Visual.redBits  ) - 1);
   GLfloat gScale = 1.0F / (GLfloat) ((1 << fb->Visual.greenBits) - 1);
   GLfloat bScale = 1.0F / (GLfloat) ((1 << fb->Visual.blueBits ) - 1);
a293 8

   if (fb->Visual.redBits == 0)
      rScale = 0;
   if (fb->Visual.greenBits == 0)
      gScale = 0;
   if (fb->Visual.blueBits == 0)
      bScale = 0;

d315 1
a315 1
read_rgba_pixels( struct gl_context *ctx,
d343 62
a404 1
   do {
d413 4
d420 13
a432 1
         _swrast_read_rgba_span(ctx, rb, width, x, y, GL_FLOAT, rgba);
d435 4
a438 4
         if ((fb->Visual.redBits < 8 && fb->Visual.redBits != 0) ||
             (fb->Visual.greenBits < 8 && fb->Visual.greenBits != 0) ||
	     (fb->Visual.blueBits < 8 && fb->Visual.blueBits != 0)) {
            adjust_colors(fb, width, rgba);
d447 1
a447 1
   } while (0);
d457 1
a457 1
read_depth_stencil_pixels(struct gl_context *ctx,
d548 1
a548 1
_swrast_ReadPixels( struct gl_context *ctx,
d557 6
a565 6
   /* Need to do swrast_render_start() before clipping or anything else
    * since this is where a driver may grab the hw lock and get an updated
    * window size.
    */
   swrast_render_start(ctx);

d570 4
a573 1
   if (_mesa_clip_readpixels(ctx, &x, &y, &width, &height, &clippedPacking)) {
d575 19
a593 1
      pixels = _mesa_map_pbo_dest(ctx, &clippedPacking, pixels);
d595 7
a601 17
      if (pixels) {
         switch (format) {
         case GL_STENCIL_INDEX:
            read_stencil_pixels(ctx, x, y, width, height, type, pixels,
                                &clippedPacking);
            break;
         case GL_DEPTH_COMPONENT:
            read_depth_pixels(ctx, x, y, width, height, type, pixels,
                              &clippedPacking);
            break;
         case GL_DEPTH_STENCIL_EXT:
            read_depth_stencil_pixels(ctx, x, y, width, height, type, pixels,
                                      &clippedPacking);
            break;
         default:
            /* all other formats should be color formats */
            read_rgba_pixels(ctx, x, y, width, height, format, type, pixels,
d603 28
a630 1
         }
d632 7
a638 2
         _mesa_unmap_pbo_dest(ctx, &clippedPacking);
      }
a639 2

   swrast_render_finish(ctx);
@


