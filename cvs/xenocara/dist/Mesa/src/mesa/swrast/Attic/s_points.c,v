head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.8
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.6
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.4
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.4
	OPENBSD_5_6:1.6.0.4
	OPENBSD_5_6_BASE:1.6
	v10_2_3:1.1.1.4
	OPENBSD_5_5:1.6.0.2
	OPENBSD_5_5_BASE:1.6
	v9_2_5:1.1.1.4
	v9_2_3:1.1.1.4
	v9_2_2:1.1.1.4
	v9_2_1:1.1.1.4
	v9_2_0:1.1.1.4
	OPENBSD_5_4:1.5.0.8
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.6
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	v7_10_3:1.1.1.3
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v7_0_1:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v6_5_2:1.1.1.1
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.12.23.05.17.55;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2013.09.05.14.06.50;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.23.13.37.45;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.34;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.42;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.23;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.51.22;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.51.22;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.32.09;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.10.23.13.29.48;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.09.05.13.17.31;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */


#include "main/glheader.h"
#include "main/colormac.h"
#include "main/macros.h"
#include "s_context.h"
#include "s_feedback.h"
#include "s_points.h"
#include "s_span.h"


/**
 * Used to cull points with invalid coords
 */
#define CULL_INVALID(V)                              \
   do {                                              \
      float tmp = (V)->attrib[VARYING_SLOT_POS][0]   \
                + (V)->attrib[VARYING_SLOT_POS][1];  \
      if (IS_INF_OR_NAN(tmp))                        \
	 return;                                     \
   } while(0)



/**
 * Get/compute the point size.
 * The size may come from a vertex shader, or computed with attentuation
 * or just the glPointSize value.
 * Must also clamp to user-defined range and implmentation limits.
 */
static inline GLfloat
get_size(const struct gl_context *ctx, const SWvertex *vert, GLboolean smoothed)
{
   GLfloat size;

   if (ctx->Point._Attenuated || ctx->VertexProgram.PointSizeEnabled) {
      /* use vertex's point size */
      size = vert->pointSize;
   }
   else {
      /* use constant point size */
      size = ctx->Point.Size;
   }
   /* always clamp to user-specified limits */
   size = CLAMP(size, ctx->Point.MinSize, ctx->Point.MaxSize);
   /* clamp to implementation limits */
   if (smoothed)
      size = CLAMP(size, ctx->Const.MinPointSizeAA, ctx->Const.MaxPointSizeAA);
   else
      size = CLAMP(size, ctx->Const.MinPointSize, ctx->Const.MaxPointSize);

   return size;
}


/**
 * Draw a point sprite
 */
static void
sprite_point(struct gl_context *ctx, const SWvertex *vert)
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
   SWspan span;
   GLfloat size;
   GLuint tCoords[MAX_TEXTURE_COORD_UNITS + 1];
   GLuint numTcoords = 0;
   GLfloat t0, dtdy;

   CULL_INVALID(vert);

   /* z coord */
   if (ctx->DrawBuffer->Visual.depthBits <= 16)
      span.z = FloatToFixed(vert->attrib[VARYING_SLOT_POS][2] + 0.5F);
   else
      span.z = (GLuint) (vert->attrib[VARYING_SLOT_POS][2] + 0.5F);
   span.zStep = 0;

   size = get_size(ctx, vert, GL_FALSE);

   /* span init */
   INIT_SPAN(span, GL_POINT);
   span.interpMask = SPAN_Z | SPAN_RGBA;

   span.facing = swrast->PointLineFacing;

   span.red   = ChanToFixed(vert->color[0]);
   span.green = ChanToFixed(vert->color[1]);
   span.blue  = ChanToFixed(vert->color[2]);
   span.alpha = ChanToFixed(vert->color[3]);
   span.redStep = 0;
   span.greenStep = 0;
   span.blueStep = 0;
   span.alphaStep = 0;

   /* need these for fragment programs */
   span.attrStart[VARYING_SLOT_POS][3] = 1.0F;
   span.attrStepX[VARYING_SLOT_POS][3] = 0.0F;
   span.attrStepY[VARYING_SLOT_POS][3] = 0.0F;

   {
      GLfloat s, r, dsdx;

      /* texcoord / pointcoord interpolants */
      s = 0.0F;
      dsdx = 1.0F / size;
      if (ctx->Point.SpriteOrigin == GL_LOWER_LEFT) {
         dtdy = 1.0F / size;
         t0 = 0.5F * dtdy;
      }
      else {
         /* GL_UPPER_LEFT */
         dtdy = -1.0F / size;
         t0 = 1.0F + 0.5F * dtdy;
      }

      ATTRIB_LOOP_BEGIN
         if (attr >= VARYING_SLOT_TEX0 && attr <= VARYING_SLOT_TEX7) {
            /* a texcoord attribute */
            const GLuint u = attr - VARYING_SLOT_TEX0;
            ASSERT(u < Elements(ctx->Point.CoordReplace));
            if (ctx->Point.CoordReplace[u]) {
               tCoords[numTcoords++] = attr;

               if (ctx->Point.SpriteRMode == GL_ZERO)
                  r = 0.0F;
               else if (ctx->Point.SpriteRMode == GL_S)
                  r = vert->attrib[attr][0];
               else /* GL_R */
                  r = vert->attrib[attr][2];

               span.attrStart[attr][0] = s;
               span.attrStart[attr][1] = 0.0; /* overwritten below */
               span.attrStart[attr][2] = r;
               span.attrStart[attr][3] = 1.0;

               span.attrStepX[attr][0] = dsdx;
               span.attrStepX[attr][1] = 0.0;
               span.attrStepX[attr][2] = 0.0;
               span.attrStepX[attr][3] = 0.0;

               span.attrStepY[attr][0] = 0.0;
               span.attrStepY[attr][1] = dtdy;
               span.attrStepY[attr][2] = 0.0;
               span.attrStepY[attr][3] = 0.0;

               continue;
            }
         }
         else if (attr == VARYING_SLOT_PNTC) {
            /* GLSL gl_PointCoord.xy (.zw undefined) */
            span.attrStart[VARYING_SLOT_PNTC][0] = 0.0;
            span.attrStart[VARYING_SLOT_PNTC][1] = 0.0; /* t0 set below */
            span.attrStepX[VARYING_SLOT_PNTC][0] = dsdx;
            span.attrStepX[VARYING_SLOT_PNTC][1] = 0.0;
            span.attrStepY[VARYING_SLOT_PNTC][0] = 0.0;
            span.attrStepY[VARYING_SLOT_PNTC][1] = dtdy;
            tCoords[numTcoords++] = VARYING_SLOT_PNTC;
            continue;
         }
         /* use vertex's texcoord/attrib */
         COPY_4V(span.attrStart[attr], vert->attrib[attr]);
         ASSIGN_4V(span.attrStepX[attr], 0, 0, 0, 0);
         ASSIGN_4V(span.attrStepY[attr], 0, 0, 0, 0);
      ATTRIB_LOOP_END;
   }

   /* compute pos, bounds and render */
   {
      const GLfloat x = vert->attrib[VARYING_SLOT_POS][0];
      const GLfloat y = vert->attrib[VARYING_SLOT_POS][1];
      GLint iSize = (GLint) (size + 0.5F);
      GLint xmin, xmax, ymin, ymax, iy;
      GLint iRadius;
      GLfloat tcoord = t0;

      iSize = MAX2(1, iSize);
      iRadius = iSize / 2;

      if (iSize & 1) {
         /* odd size */
         xmin = (GLint) (x - iRadius);
         xmax = (GLint) (x + iRadius);
         ymin = (GLint) (y - iRadius);
         ymax = (GLint) (y + iRadius);
      }
      else {
         /* even size */
         /* 0.501 factor allows conformance to pass */
         xmin = (GLint) (x + 0.501) - iRadius;
         xmax = xmin + iSize - 1;
         ymin = (GLint) (y + 0.501) - iRadius;
         ymax = ymin + iSize - 1;
      }

      /* render spans */
      for (iy = ymin; iy <= ymax; iy++) {
         GLuint i;
         /* setup texcoord T for this row */
         for (i = 0; i < numTcoords; i++) {
            span.attrStart[tCoords[i]][1] = tcoord;
         }

         /* these might get changed by span clipping */
         span.x = xmin;
         span.y = iy;
         span.end = xmax - xmin + 1;

         _swrast_write_rgba_span(ctx, &span);

         tcoord += dtdy;
      }
   }
}


/**
 * Draw smooth/antialiased point.  RGB or CI mode.
 */
static void
smooth_point(struct gl_context *ctx, const SWvertex *vert)
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
   SWspan span;
   GLfloat size, alphaAtten;

   CULL_INVALID(vert);

   /* z coord */
   if (ctx->DrawBuffer->Visual.depthBits <= 16)
      span.z = FloatToFixed(vert->attrib[VARYING_SLOT_POS][2] + 0.5F);
   else
      span.z = (GLuint) (vert->attrib[VARYING_SLOT_POS][2] + 0.5F);
   span.zStep = 0;

   size = get_size(ctx, vert, GL_TRUE);

   /* alpha attenuation / fade factor */
   if (ctx->Multisample._Enabled) {
      if (vert->pointSize >= ctx->Point.Threshold) {
         alphaAtten = 1.0F;
      }
      else {
         GLfloat dsize = vert->pointSize / ctx->Point.Threshold;
         alphaAtten = dsize * dsize;
      }
   }
   else {
      alphaAtten = 1.0;
   }
   (void) alphaAtten; /* not used */

   /* span init */
   INIT_SPAN(span, GL_POINT);
   span.interpMask = SPAN_Z | SPAN_RGBA;
   span.arrayMask = SPAN_COVERAGE | SPAN_MASK;

   span.facing = swrast->PointLineFacing;

   span.red   = ChanToFixed(vert->color[0]);
   span.green = ChanToFixed(vert->color[1]);
   span.blue  = ChanToFixed(vert->color[2]);
   span.alpha = ChanToFixed(vert->color[3]);
   span.redStep = 0;
   span.greenStep = 0;
   span.blueStep = 0;
   span.alphaStep = 0;

   /* need these for fragment programs */
   span.attrStart[VARYING_SLOT_POS][3] = 1.0F;
   span.attrStepX[VARYING_SLOT_POS][3] = 0.0F;
   span.attrStepY[VARYING_SLOT_POS][3] = 0.0F;

   ATTRIB_LOOP_BEGIN
      COPY_4V(span.attrStart[attr], vert->attrib[attr]);
      ASSIGN_4V(span.attrStepX[attr], 0, 0, 0, 0);
      ASSIGN_4V(span.attrStepY[attr], 0, 0, 0, 0);
   ATTRIB_LOOP_END

   /* compute pos, bounds and render */
   {
      const GLfloat x = vert->attrib[VARYING_SLOT_POS][0];
      const GLfloat y = vert->attrib[VARYING_SLOT_POS][1];
      const GLfloat radius = 0.5F * size;
      const GLfloat rmin = radius - 0.7071F;  /* 0.7071 = sqrt(2)/2 */
      const GLfloat rmax = radius + 0.7071F;
      const GLfloat rmin2 = MAX2(0.0F, rmin * rmin);
      const GLfloat rmax2 = rmax * rmax;
      const GLfloat cscale = 1.0F / (rmax2 - rmin2);
      const GLint xmin = (GLint) (x - radius);
      const GLint xmax = (GLint) (x + radius);
      const GLint ymin = (GLint) (y - radius);
      const GLint ymax = (GLint) (y + radius);
      GLint ix, iy;

      for (iy = ymin; iy <= ymax; iy++) {

         /* these might get changed by span clipping */
         span.x = xmin;
         span.y = iy;
         span.end = xmax - xmin + 1;

         /* compute coverage for each pixel in span */
         for (ix = xmin; ix <= xmax; ix++) {
            const GLfloat dx = ix - x + 0.5F;
            const GLfloat dy = iy - y + 0.5F;
            const GLfloat dist2 = dx * dx + dy * dy;
            GLfloat coverage;

            if (dist2 < rmax2) {
               if (dist2 >= rmin2) {
                  /* compute partial coverage */
                  coverage = 1.0F - (dist2 - rmin2) * cscale;
               }
               else {
                  /* full coverage */
                  coverage = 1.0F;
               }
               span.array->mask[ix - xmin] = 1;
            }
            else {
               /* zero coverage - fragment outside the radius */
               coverage = 0.0;
               span.array->mask[ix - xmin] = 0;
            }
            span.array->coverage[ix - xmin] = coverage;
         }

         /* render span */
         _swrast_write_rgba_span(ctx, &span);

      }
   }
}


/**
 * Draw large (size >= 1) non-AA point.  RGB or CI mode.
 */
static void
large_point(struct gl_context *ctx, const SWvertex *vert)
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
   SWspan span;
   GLfloat size;

   CULL_INVALID(vert);

   /* z coord */
   if (ctx->DrawBuffer->Visual.depthBits <= 16)
      span.z = FloatToFixed(vert->attrib[VARYING_SLOT_POS][2] + 0.5F);
   else
      span.z = (GLuint) (vert->attrib[VARYING_SLOT_POS][2] + 0.5F);
   span.zStep = 0;

   size = get_size(ctx, vert, GL_FALSE);

   /* span init */
   INIT_SPAN(span, GL_POINT);
   span.arrayMask = SPAN_XY;
   span.facing = swrast->PointLineFacing;

   span.interpMask = SPAN_Z | SPAN_RGBA;
   span.red   = ChanToFixed(vert->color[0]);
   span.green = ChanToFixed(vert->color[1]);
   span.blue  = ChanToFixed(vert->color[2]);
   span.alpha = ChanToFixed(vert->color[3]);
   span.redStep = 0;
   span.greenStep = 0;
   span.blueStep = 0;
   span.alphaStep = 0;

   /* need these for fragment programs */
   span.attrStart[VARYING_SLOT_POS][3] = 1.0F;
   span.attrStepX[VARYING_SLOT_POS][3] = 0.0F;
   span.attrStepY[VARYING_SLOT_POS][3] = 0.0F;

   ATTRIB_LOOP_BEGIN
      COPY_4V(span.attrStart[attr], vert->attrib[attr]);
      ASSIGN_4V(span.attrStepX[attr], 0, 0, 0, 0);
      ASSIGN_4V(span.attrStepY[attr], 0, 0, 0, 0);
   ATTRIB_LOOP_END

   /* compute pos, bounds and render */
   {
      const GLfloat x = vert->attrib[VARYING_SLOT_POS][0];
      const GLfloat y = vert->attrib[VARYING_SLOT_POS][1];
      GLint iSize = (GLint) (size + 0.5F);
      GLint xmin, xmax, ymin, ymax, ix, iy;
      GLint iRadius;

      iSize = MAX2(1, iSize);
      iRadius = iSize / 2;

      if (iSize & 1) {
         /* odd size */
         xmin = (GLint) (x - iRadius);
         xmax = (GLint) (x + iRadius);
         ymin = (GLint) (y - iRadius);
         ymax = (GLint) (y + iRadius);
      }
      else {
         /* even size */
         /* 0.501 factor allows conformance to pass */
         xmin = (GLint) (x + 0.501) - iRadius;
         xmax = xmin + iSize - 1;
         ymin = (GLint) (y + 0.501) - iRadius;
         ymax = ymin + iSize - 1;
      }

      /* generate fragments */
      span.end = 0;
      for (iy = ymin; iy <= ymax; iy++) {
         for (ix = xmin; ix <= xmax; ix++) {
            span.array->x[span.end] = ix;
            span.array->y[span.end] = iy;
            span.end++;
         }
      }
      assert(span.end <= SWRAST_MAX_WIDTH);
      _swrast_write_rgba_span(ctx, &span);
   }
}


/**
 * Draw size=1, single-pixel point
 */
static void
pixel_point(struct gl_context *ctx, const SWvertex *vert)
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
   /*
    * Note that unlike the other functions, we put single-pixel points
    * into a special span array in order to render as many points as
    * possible with a single _swrast_write_rgba_span() call.
    */
   SWspan *span = &(swrast->PointSpan);
   GLuint count;

   CULL_INVALID(vert);

   /* Span init */
   span->interpMask = 0;
   span->arrayMask = SPAN_XY | SPAN_Z;
   span->arrayMask |= SPAN_RGBA;
   /*span->arrayMask |= SPAN_LAMBDA;*/
   span->arrayAttribs = swrast->_ActiveAttribMask; /* we'll produce these vals */

   /* need these for fragment programs */
   span->attrStart[VARYING_SLOT_POS][3] = 1.0F;
   span->attrStepX[VARYING_SLOT_POS][3] = 0.0F;
   span->attrStepY[VARYING_SLOT_POS][3] = 0.0F;

   /* check if we need to flush */
   if (span->end >= SWRAST_MAX_WIDTH ||
       (swrast->_RasterMask & (BLEND_BIT | LOGIC_OP_BIT | MASKING_BIT)) ||
       span->facing != swrast->PointLineFacing) {
      if (span->end > 0) {
	 _swrast_write_rgba_span(ctx, span);
         span->end = 0;
      }
   }

   count = span->end;

   span->facing = swrast->PointLineFacing;

   /* fragment attributes */
   span->array->rgba[count][RCOMP] = vert->color[0];
   span->array->rgba[count][GCOMP] = vert->color[1];
   span->array->rgba[count][BCOMP] = vert->color[2];
   span->array->rgba[count][ACOMP] = vert->color[3];

   ATTRIB_LOOP_BEGIN
      COPY_4V(span->array->attribs[attr][count], vert->attrib[attr]);
   ATTRIB_LOOP_END

   /* fragment position */
   span->array->x[count] = (GLint) vert->attrib[VARYING_SLOT_POS][0];
   span->array->y[count] = (GLint) vert->attrib[VARYING_SLOT_POS][1];
   span->array->z[count] = (GLint) (vert->attrib[VARYING_SLOT_POS][2] + 0.5F);

   span->end = count + 1;
   ASSERT(span->end <= SWRAST_MAX_WIDTH);
}


/**
 * Add specular color to primary color, draw point, restore original
 * primary color.
 */
void
_swrast_add_spec_terms_point(struct gl_context *ctx, const SWvertex *v0)
{
   SWvertex *ncv0 = (SWvertex *) v0; /* cast away const */
   GLfloat rSum, gSum, bSum;
   GLchan cSave[4];

   /* save */
   COPY_CHAN4(cSave, ncv0->color);
   /* sum */
   rSum = CHAN_TO_FLOAT(ncv0->color[0]) + ncv0->attrib[VARYING_SLOT_COL1][0];
   gSum = CHAN_TO_FLOAT(ncv0->color[1]) + ncv0->attrib[VARYING_SLOT_COL1][1];
   bSum = CHAN_TO_FLOAT(ncv0->color[2]) + ncv0->attrib[VARYING_SLOT_COL1][2];
   UNCLAMPED_FLOAT_TO_CHAN(ncv0->color[0], rSum);
   UNCLAMPED_FLOAT_TO_CHAN(ncv0->color[1], gSum);
   UNCLAMPED_FLOAT_TO_CHAN(ncv0->color[2], bSum);
   /* draw */
   SWRAST_CONTEXT(ctx)->SpecPoint(ctx, ncv0);
   /* restore */
   COPY_CHAN4(ncv0->color, cSave);
}


/**
 * Examine current state to determine which point drawing function to use.
 */
void
_swrast_choose_point(struct gl_context *ctx)
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
   const GLfloat size = CLAMP(ctx->Point.Size,
                              ctx->Point.MinSize,
                              ctx->Point.MaxSize);

   if (ctx->RenderMode == GL_RENDER) {
      if (ctx->Point.PointSprite) {
         swrast->Point = sprite_point;
      }
      else if (ctx->Point.SmoothFlag) {
         swrast->Point = smooth_point;
      }
      else if (size > 1.0 ||
               ctx->Point._Attenuated ||
               ctx->VertexProgram.PointSizeEnabled) {
         swrast->Point = large_point;
      }
      else {
         swrast->Point = pixel_point;
      }
   }
   else if (ctx->RenderMode == GL_FEEDBACK) {
      swrast->Point = _swrast_feedback_point;
   }
   else {
      /* GL_SELECT mode */
      swrast->Point = _swrast_select_point;
   }
}
@


1.6
log
@Merge Mesa 9.2.0
@
text
@@


1.5
log
@Merge Mesa 7.10.3
@
text
@a2 1
 * Version:  7.1
d19 4
a22 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
d40 2
a41 2
      float tmp = (V)->attrib[FRAG_ATTRIB_WPOS][0]   \
                + (V)->attrib[FRAG_ATTRIB_WPOS][1];  \
d54 1
a54 1
static INLINE GLfloat
d96 1
a96 1
      span.z = FloatToFixed(vert->attrib[FRAG_ATTRIB_WPOS][2] + 0.5F);
d98 1
a98 1
      span.z = (GLuint) (vert->attrib[FRAG_ATTRIB_WPOS][2] + 0.5F);
d119 3
a121 3
   span.attrStart[FRAG_ATTRIB_WPOS][3] = 1.0F;
   span.attrStepX[FRAG_ATTRIB_WPOS][3] = 0.0F;
   span.attrStepY[FRAG_ATTRIB_WPOS][3] = 0.0F;
d140 1
a140 1
         if (attr >= FRAG_ATTRIB_TEX0 && attr <= FRAG_ATTRIB_TEX7) {
d142 1
a142 1
            const GLuint u = attr - FRAG_ATTRIB_TEX0;
d172 1
a172 1
         else if (attr == FRAG_ATTRIB_PNTC) {
d174 7
a180 7
            span.attrStart[FRAG_ATTRIB_PNTC][0] = 0.0;
            span.attrStart[FRAG_ATTRIB_PNTC][1] = 0.0; /* t0 set below */
            span.attrStepX[FRAG_ATTRIB_PNTC][0] = dsdx;
            span.attrStepX[FRAG_ATTRIB_PNTC][1] = 0.0;
            span.attrStepY[FRAG_ATTRIB_PNTC][0] = 0.0;
            span.attrStepY[FRAG_ATTRIB_PNTC][1] = dtdy;
            tCoords[numTcoords++] = FRAG_ATTRIB_PNTC;
d192 2
a193 2
      const GLfloat x = vert->attrib[FRAG_ATTRIB_WPOS][0];
      const GLfloat y = vert->attrib[FRAG_ATTRIB_WPOS][1];
d253 1
a253 1
      span.z = FloatToFixed(vert->attrib[FRAG_ATTRIB_WPOS][2] + 0.5F);
d255 1
a255 1
      span.z = (GLuint) (vert->attrib[FRAG_ATTRIB_WPOS][2] + 0.5F);
d292 3
a294 3
   span.attrStart[FRAG_ATTRIB_WPOS][3] = 1.0F;
   span.attrStepX[FRAG_ATTRIB_WPOS][3] = 0.0F;
   span.attrStepY[FRAG_ATTRIB_WPOS][3] = 0.0F;
d304 2
a305 2
      const GLfloat x = vert->attrib[FRAG_ATTRIB_WPOS][0];
      const GLfloat y = vert->attrib[FRAG_ATTRIB_WPOS][1];
d373 1
a373 1
      span.z = FloatToFixed(vert->attrib[FRAG_ATTRIB_WPOS][2] + 0.5F);
d375 1
a375 1
      span.z = (GLuint) (vert->attrib[FRAG_ATTRIB_WPOS][2] + 0.5F);
d396 3
a398 3
   span.attrStart[FRAG_ATTRIB_WPOS][3] = 1.0F;
   span.attrStepX[FRAG_ATTRIB_WPOS][3] = 0.0F;
   span.attrStepY[FRAG_ATTRIB_WPOS][3] = 0.0F;
d408 2
a409 2
      const GLfloat x = vert->attrib[FRAG_ATTRIB_WPOS][0];
      const GLfloat y = vert->attrib[FRAG_ATTRIB_WPOS][1];
d442 1
a442 1
      assert(span.end <= MAX_WIDTH);
d473 3
a475 3
   span->attrStart[FRAG_ATTRIB_WPOS][3] = 1.0F;
   span->attrStepX[FRAG_ATTRIB_WPOS][3] = 0.0F;
   span->attrStepY[FRAG_ATTRIB_WPOS][3] = 0.0F;
d478 1
a478 1
   if (span->end >= MAX_WIDTH ||
d502 3
a504 3
   span->array->x[count] = (GLint) vert->attrib[FRAG_ATTRIB_WPOS][0];
   span->array->y[count] = (GLint) vert->attrib[FRAG_ATTRIB_WPOS][1];
   span->array->z[count] = (GLint) (vert->attrib[FRAG_ATTRIB_WPOS][2] + 0.5F);
d507 1
a507 1
   ASSERT(span->end <= MAX_WIDTH);
d525 3
a527 3
   rSum = CHAN_TO_FLOAT(ncv0->color[0]) + ncv0->attrib[FRAG_ATTRIB_COL1][0];
   gSum = CHAN_TO_FLOAT(ncv0->color[1]) + ncv0->attrib[FRAG_ATTRIB_COL1][1];
   bSum = CHAN_TO_FLOAT(ncv0->color[2]) + ncv0->attrib[FRAG_ATTRIB_COL1][2];
@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@a27 1
#include "main/context.h"
d55 1
a55 1
get_size(const GLcontext *ctx, const SWvertex *vert, GLboolean smoothed)
d83 1
a83 1
sprite_point(GLcontext *ctx, const SWvertex *vert)
d243 1
a243 1
smooth_point(GLcontext *ctx, const SWvertex *vert)
d363 1
a363 1
large_point(GLcontext *ctx, const SWvertex *vert)
d452 1
a452 1
pixel_point(GLcontext *ctx, const SWvertex *vert)
d516 1
a516 1
_swrast_add_spec_terms_point(GLcontext *ctx, const SWvertex *v0)
d542 1
a542 1
_swrast_choose_point(GLcontext *ctx)
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@a29 1
#include "main/texstate.h"
d128 2
a129 2
      s = 0.0;
      dsdx = 1.0 / size;
d131 2
a132 2
         dtdy = 1.0 / size;
         t0 = 0.5 * dtdy;
d136 2
a137 2
         dtdy = -1.0 / size;
         t0 = 1.0 + 0.5 * dtdy;
d141 2
a142 1
         if (attr >= FRAG_ATTRIB_TEX0 && attr < FRAG_ATTRIB_VAR0) {
d144 1
a144 1
            /* a texcoord */
d173 9
a181 9
         else if (attr == FRAG_ATTRIB_FOGC) {
            /* GLSL gl_PointCoord is stored in fog.zw */
            span.attrStart[FRAG_ATTRIB_FOGC][2] = 0.0;
            span.attrStart[FRAG_ATTRIB_FOGC][3] = 0.0; /* t0 set below */
            span.attrStepX[FRAG_ATTRIB_FOGC][2] = dsdx;
            span.attrStepX[FRAG_ATTRIB_FOGC][3] = 0.0;
            span.attrStepY[FRAG_ATTRIB_FOGC][2] = 0.0;
            span.attrStepY[FRAG_ATTRIB_FOGC][3] = dtdy;
            tCoords[numTcoords++] = FRAG_ATTRIB_FOGC;
d224 1
a224 4
            if (tCoords[i] == FRAG_ATTRIB_FOGC)
               span.attrStart[FRAG_ATTRIB_FOGC][3] = tcoord;
            else
               span.attrStart[tCoords[i]][1] = tcoord;
a246 1
   const GLboolean ciMode = !ctx->Visual.rgbMode;
a336 4
                  if (ciMode) {
                     /* coverage in [0,15] */
                     coverage *= 15.0;
                  }
a366 1
   const GLboolean ciMode = !ctx->Visual.rgbMode;
d386 9
a394 16
   if (ciMode) {
      span.interpMask = SPAN_Z | SPAN_INDEX;
      span.index = FloatToFixed(vert->attrib[FRAG_ATTRIB_CI][0]);
      span.indexStep = 0;
   }
   else {
      span.interpMask = SPAN_Z | SPAN_RGBA;
      span.red   = ChanToFixed(vert->color[0]);
      span.green = ChanToFixed(vert->color[1]);
      span.blue  = ChanToFixed(vert->color[2]);
      span.alpha = ChanToFixed(vert->color[3]);
      span.redStep = 0;
      span.greenStep = 0;
      span.blueStep = 0;
      span.alphaStep = 0;
   }
a455 1
   const GLboolean ciMode = !ctx->Visual.rgbMode;
d469 1
a469 4
   if (ciMode)
      span->arrayMask |= SPAN_INDEX;
   else
      span->arrayMask |= SPAN_RGBA;
d483 1
a483 4
         if (ciMode)
            _swrast_write_index_span(ctx, span);
         else
            _swrast_write_rgba_span(ctx, span);
d493 5
a497 9
   if (ciMode) {
      span->array->index[count] = (GLuint) vert->attrib[FRAG_ATTRIB_CI][0];
   }
   else {
      span->array->rgba[count][RCOMP] = vert->color[0];
      span->array->rgba[count][GCOMP] = vert->color[1];
      span->array->rgba[count][BCOMP] = vert->color[2];
      span->array->rgba[count][ACOMP] = vert->color[3];
   }
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d26 5
a30 5
#include "glheader.h"
#include "colormac.h"
#include "context.h"
#include "macros.h"
#include "texstate.h"
a131 1
         t0 = 0.0;
d133 1
a136 1
         t0 = 1.0;
d138 1
d573 3
d584 1
a584 1
      else if (ctx->Point.Size > 1.0 ||
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * Version:  6.1
d5 1
a5 1
 * Copyright (C) 1999-2004  Brian Paul   All Rights Reserved.
d37 10
a47 8
#define RGBA       0x1
#define INDEX      0x2
#define SMOOTH     0x4
#define TEXTURE    0x8
#define SPECULAR  0x10
#define LARGE     0x20
#define ATTENUATE 0x40
#define SPRITE    0x80
d50 5
a54 2
/*
 * CI points with size == 1.0
d56 4
a59 3
#define FLAGS (INDEX)
#define NAME size1_ci_point
#include "s_pointtemp.h"
d61 15
d77 2
a78 6
/*
 * General CI points.
 */
#define FLAGS (INDEX | LARGE)
#define NAME general_ci_point
#include "s_pointtemp.h"
d81 2
a82 2
/*
 * Antialiased CI points.
d84 85
a168 3
#define FLAGS (INDEX | SMOOTH)
#define NAME antialiased_ci_point
#include "s_pointtemp.h"
d170 20
d191 27
a217 6
/*
 * Distance attenuated, general CI points.
 */
#define FLAGS (INDEX | ATTENUATE)
#define NAME atten_general_ci_point
#include "s_pointtemp.h"
d219 10
d230 4
a233 6
/*
 * RGBA points with size == 1.0
 */
#define FLAGS (RGBA)
#define NAME size1_rgba_point
#include "s_pointtemp.h"
d235 1
d237 4
a240 6
/*
 * General RGBA points.
 */
#define FLAGS (RGBA | LARGE)
#define NAME general_rgba_point
#include "s_pointtemp.h"
d243 2
a244 2
/*
 * Antialiased RGBA points.
d246 33
a278 3
#define FLAGS (RGBA | SMOOTH)
#define NAME antialiased_rgba_point
#include "s_pointtemp.h"
d280 79
d360 2
a361 6
/*
 * Textured RGBA points.
 */
#define FLAGS (RGBA | LARGE | TEXTURE | SPECULAR)
#define NAME textured_rgba_point
#include "s_pointtemp.h"
d363 3
a365 7

/*
 * Antialiased points with texture mapping.
 */
#define FLAGS (RGBA | SMOOTH | TEXTURE | SPECULAR)
#define NAME antialiased_tex_rgba_point
#include "s_pointtemp.h"
d368 2
a369 2
/*
 * Distance attenuated, general RGBA points.
d371 40
a410 3
#define FLAGS (RGBA | ATTENUATE)
#define NAME atten_general_rgba_point
#include "s_pointtemp.h"
d412 37
d450 13
a462 6
/*
 * Distance attenuated, textured RGBA points.
 */
#define FLAGS (RGBA | ATTENUATE | TEXTURE | SPECULAR)
#define NAME atten_textured_rgba_point
#include "s_pointtemp.h"
d465 2
a466 2
/*
 * Distance attenuated, antialiased points with or without texture mapping.
d468 42
a509 3
#define FLAGS (RGBA | ATTENUATE | TEXTURE | SMOOTH)
#define NAME atten_antialiased_rgba_point
#include "s_pointtemp.h"
d511 1
d513 1
a513 6
/*
 * Sprite (textured point)
 */
#define FLAGS (RGBA | SPRITE | SPECULAR)
#define NAME sprite_point
#include "s_pointtemp.h"
d515 18
d534 3
a536 3
#define FLAGS (RGBA | SPRITE | SPECULAR | ATTENUATE)
#define NAME atten_sprite_point
#include "s_pointtemp.h"
d539 6
a544 3

void _swrast_add_spec_terms_point( GLcontext *ctx,
				   const SWvertex *v0 )
d546 17
a562 6
   SWvertex *ncv0 = (SWvertex *)v0;
   GLchan c[1][4];
   COPY_CHAN4( c[0], ncv0->color );
   ACC_3V( ncv0->color, ncv0->specular );
   SWRAST_CONTEXT(ctx)->SpecPoint( ctx, ncv0 );
   COPY_CHAN4( ncv0->color, c[0] );
d566 2
a567 23

/* record the current point function name */
#ifdef DEBUG

static const char *pntFuncName = NULL;

#define USE(pntFunc)                   \
do {                                   \
    pntFuncName = #pntFunc;            \
    /*printf("%s\n", pntFuncName);*/   \
    swrast->Point = pntFunc;           \
} while (0)

#else

#define USE(pntFunc)  swrast->Point = pntFunc

#endif


/*
 * Examine the current context to determine which point drawing function
 * should be used.
d570 1
a570 1
_swrast_choose_point( GLcontext *ctx )
a572 1
   GLboolean rgbMode = ctx->Visual.rgbMode;
d574 1
a574 1
   if (ctx->RenderMode==GL_RENDER) {
d576 1
a576 6
         /* GL_ARB_point_sprite / GL_NV_point_sprite */
         /* XXX this might not be good enough */
         if (ctx->Point._Attenuated)
            USE(atten_sprite_point);
         else
            USE(sprite_point);
d579 1
a579 15
         /* Smooth points */
         if (rgbMode) {
            if (ctx->Point._Attenuated || ctx->VertexProgram.PointSizeEnabled) {
               USE(atten_antialiased_rgba_point);
            }
            else if (ctx->Texture._EnabledCoordUnits) {
               USE(antialiased_tex_rgba_point);
            }
            else {
               USE(antialiased_rgba_point);
            }
         }
         else {
            USE(antialiased_ci_point);
         }
d581 4
a584 31
      else if (ctx->Point._Attenuated || ctx->VertexProgram.PointSizeEnabled) {
         if (rgbMode) {
            if (ctx->Texture._EnabledCoordUnits) {
               if (ctx->Point.SmoothFlag) {
                  USE(atten_antialiased_rgba_point);
               }
               else {
                  USE(atten_textured_rgba_point);
               }
            }
            else {
               USE(atten_general_rgba_point);
            }
         }
         else {
            /* ci, atten */
            USE(atten_general_ci_point);
         }
      }
      else if (ctx->Texture._EnabledCoordUnits && rgbMode) {
         /* textured */
         USE(textured_rgba_point);
      }
      else if (ctx->Point._Size != 1.0) {
         /* large points */
         if (rgbMode) {
            USE(general_rgba_point);
         }
         else {
            USE(general_ci_point);
         }
d587 1
a587 7
         /* single pixel points */
         if (rgbMode) {
            USE(size1_rgba_point);
         }
         else {
            USE(size1_ci_point);
         }
d590 2
a591 2
   else if (ctx->RenderMode==GL_FEEDBACK) {
      USE(_swrast_feedback_point);
d595 1
a595 1
      USE(_swrast_select_point);
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@Mesa 7.0.1
@
text
@d41 1
a41 1
#define ATTRIBS    0x8
d107 1
a107 1
#define FLAGS (RGBA | LARGE | ATTRIBS | SPECULAR)
d115 1
a115 1
#define FLAGS (RGBA | SMOOTH | ATTRIBS | SPECULAR)
d131 1
a131 1
#define FLAGS (RGBA | ATTENUATE | ATTRIBS | SPECULAR)
d139 1
a139 1
#define FLAGS (RGBA | ATTENUATE | ATTRIBS | SMOOTH)
@


1.1.1.3
log
@Import Mesa 7.10.3
@
text
@d3 1
a3 1
 * Version:  7.1
d5 1
a5 1
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
d26 5
a30 3
#include "main/glheader.h"
#include "main/colormac.h"
#include "main/macros.h"
d37 13
a49 2
/**
 * Used to cull points with invalid coords
d51 3
a53 7
#define CULL_INVALID(V)                              \
   do {                                              \
      float tmp = (V)->attrib[FRAG_ATTRIB_WPOS][0]   \
                + (V)->attrib[FRAG_ATTRIB_WPOS][1];  \
      if (IS_INF_OR_NAN(tmp))                        \
	 return;                                     \
   } while(0)
d56 7
d64 2
a65 5
/**
 * Get/compute the point size.
 * The size may come from a vertex shader, or computed with attentuation
 * or just the glPointSize value.
 * Must also clamp to user-defined range and implmentation limits.
d67 3
a69 4
static INLINE GLfloat
get_size(const struct gl_context *ctx, const SWvertex *vert, GLboolean smoothed)
{
   GLfloat size;
a70 15
   if (ctx->Point._Attenuated || ctx->VertexProgram.PointSizeEnabled) {
      /* use vertex's point size */
      size = vert->pointSize;
   }
   else {
      /* use constant point size */
      size = ctx->Point.Size;
   }
   /* always clamp to user-specified limits */
   size = CLAMP(size, ctx->Point.MinSize, ctx->Point.MaxSize);
   /* clamp to implementation limits */
   if (smoothed)
      size = CLAMP(size, ctx->Const.MinPointSizeAA, ctx->Const.MaxPointSizeAA);
   else
      size = CLAMP(size, ctx->Const.MinPointSize, ctx->Const.MaxPointSize);
d72 6
a77 2
   return size;
}
d80 2
a81 2
/**
 * Draw a point sprite
d83 4
a86 56
static void
sprite_point(struct gl_context *ctx, const SWvertex *vert)
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
   SWspan span;
   GLfloat size;
   GLuint tCoords[MAX_TEXTURE_COORD_UNITS + 1];
   GLuint numTcoords = 0;
   GLfloat t0, dtdy;

   CULL_INVALID(vert);

   /* z coord */
   if (ctx->DrawBuffer->Visual.depthBits <= 16)
      span.z = FloatToFixed(vert->attrib[FRAG_ATTRIB_WPOS][2] + 0.5F);
   else
      span.z = (GLuint) (vert->attrib[FRAG_ATTRIB_WPOS][2] + 0.5F);
   span.zStep = 0;

   size = get_size(ctx, vert, GL_FALSE);

   /* span init */
   INIT_SPAN(span, GL_POINT);
   span.interpMask = SPAN_Z | SPAN_RGBA;

   span.facing = swrast->PointLineFacing;

   span.red   = ChanToFixed(vert->color[0]);
   span.green = ChanToFixed(vert->color[1]);
   span.blue  = ChanToFixed(vert->color[2]);
   span.alpha = ChanToFixed(vert->color[3]);
   span.redStep = 0;
   span.greenStep = 0;
   span.blueStep = 0;
   span.alphaStep = 0;

   /* need these for fragment programs */
   span.attrStart[FRAG_ATTRIB_WPOS][3] = 1.0F;
   span.attrStepX[FRAG_ATTRIB_WPOS][3] = 0.0F;
   span.attrStepY[FRAG_ATTRIB_WPOS][3] = 0.0F;

   {
      GLfloat s, r, dsdx;

      /* texcoord / pointcoord interpolants */
      s = 0.0F;
      dsdx = 1.0F / size;
      if (ctx->Point.SpriteOrigin == GL_LOWER_LEFT) {
         dtdy = 1.0F / size;
         t0 = 0.5F * dtdy;
      }
      else {
         /* GL_UPPER_LEFT */
         dtdy = -1.0F / size;
         t0 = 1.0F + 0.5F * dtdy;
      }
d88 6
a93 29
      ATTRIB_LOOP_BEGIN
         if (attr >= FRAG_ATTRIB_TEX0 && attr <= FRAG_ATTRIB_TEX7) {
            /* a texcoord attribute */
            const GLuint u = attr - FRAG_ATTRIB_TEX0;
            ASSERT(u < Elements(ctx->Point.CoordReplace));
            if (ctx->Point.CoordReplace[u]) {
               tCoords[numTcoords++] = attr;

               if (ctx->Point.SpriteRMode == GL_ZERO)
                  r = 0.0F;
               else if (ctx->Point.SpriteRMode == GL_S)
                  r = vert->attrib[attr][0];
               else /* GL_R */
                  r = vert->attrib[attr][2];

               span.attrStart[attr][0] = s;
               span.attrStart[attr][1] = 0.0; /* overwritten below */
               span.attrStart[attr][2] = r;
               span.attrStart[attr][3] = 1.0;

               span.attrStepX[attr][0] = dsdx;
               span.attrStepX[attr][1] = 0.0;
               span.attrStepX[attr][2] = 0.0;
               span.attrStepX[attr][3] = 0.0;

               span.attrStepY[attr][0] = 0.0;
               span.attrStepY[attr][1] = dtdy;
               span.attrStepY[attr][2] = 0.0;
               span.attrStepY[attr][3] = 0.0;
a94 20
               continue;
            }
         }
         else if (attr == FRAG_ATTRIB_PNTC) {
            /* GLSL gl_PointCoord.xy (.zw undefined) */
            span.attrStart[FRAG_ATTRIB_PNTC][0] = 0.0;
            span.attrStart[FRAG_ATTRIB_PNTC][1] = 0.0; /* t0 set below */
            span.attrStepX[FRAG_ATTRIB_PNTC][0] = dsdx;
            span.attrStepX[FRAG_ATTRIB_PNTC][1] = 0.0;
            span.attrStepY[FRAG_ATTRIB_PNTC][0] = 0.0;
            span.attrStepY[FRAG_ATTRIB_PNTC][1] = dtdy;
            tCoords[numTcoords++] = FRAG_ATTRIB_PNTC;
            continue;
         }
         /* use vertex's texcoord/attrib */
         COPY_4V(span.attrStart[attr], vert->attrib[attr]);
         ASSIGN_4V(span.attrStepX[attr], 0, 0, 0, 0);
         ASSIGN_4V(span.attrStepY[attr], 0, 0, 0, 0);
      ATTRIB_LOOP_END;
   }
d96 6
a101 27
   /* compute pos, bounds and render */
   {
      const GLfloat x = vert->attrib[FRAG_ATTRIB_WPOS][0];
      const GLfloat y = vert->attrib[FRAG_ATTRIB_WPOS][1];
      GLint iSize = (GLint) (size + 0.5F);
      GLint xmin, xmax, ymin, ymax, iy;
      GLint iRadius;
      GLfloat tcoord = t0;

      iSize = MAX2(1, iSize);
      iRadius = iSize / 2;

      if (iSize & 1) {
         /* odd size */
         xmin = (GLint) (x - iRadius);
         xmax = (GLint) (x + iRadius);
         ymin = (GLint) (y - iRadius);
         ymax = (GLint) (y + iRadius);
      }
      else {
         /* even size */
         /* 0.501 factor allows conformance to pass */
         xmin = (GLint) (x + 0.501) - iRadius;
         xmax = xmin + iSize - 1;
         ymin = (GLint) (y + 0.501) - iRadius;
         ymax = ymin + iSize - 1;
      }
a102 7
      /* render spans */
      for (iy = ymin; iy <= ymax; iy++) {
         GLuint i;
         /* setup texcoord T for this row */
         for (i = 0; i < numTcoords; i++) {
            span.attrStart[tCoords[i]][1] = tcoord;
         }
d104 6
a109 4
         /* these might get changed by span clipping */
         span.x = xmin;
         span.y = iy;
         span.end = xmax - xmin + 1;
a110 1
         _swrast_write_rgba_span(ctx, &span);
d112 6
a117 4
         tcoord += dtdy;
      }
   }
}
d120 2
a121 2
/**
 * Draw smooth/antialiased point.  RGB or CI mode.
d123 4
a126 6
static void
smooth_point(struct gl_context *ctx, const SWvertex *vert)
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
   SWspan span;
   GLfloat size, alphaAtten;
d128 6
a133 1
   CULL_INVALID(vert);
a134 23
   /* z coord */
   if (ctx->DrawBuffer->Visual.depthBits <= 16)
      span.z = FloatToFixed(vert->attrib[FRAG_ATTRIB_WPOS][2] + 0.5F);
   else
      span.z = (GLuint) (vert->attrib[FRAG_ATTRIB_WPOS][2] + 0.5F);
   span.zStep = 0;

   size = get_size(ctx, vert, GL_TRUE);

   /* alpha attenuation / fade factor */
   if (ctx->Multisample._Enabled) {
      if (vert->pointSize >= ctx->Point.Threshold) {
         alphaAtten = 1.0F;
      }
      else {
         GLfloat dsize = vert->pointSize / ctx->Point.Threshold;
         alphaAtten = dsize * dsize;
      }
   }
   else {
      alphaAtten = 1.0;
   }
   (void) alphaAtten; /* not used */
d136 6
a141 75
   /* span init */
   INIT_SPAN(span, GL_POINT);
   span.interpMask = SPAN_Z | SPAN_RGBA;
   span.arrayMask = SPAN_COVERAGE | SPAN_MASK;

   span.facing = swrast->PointLineFacing;

   span.red   = ChanToFixed(vert->color[0]);
   span.green = ChanToFixed(vert->color[1]);
   span.blue  = ChanToFixed(vert->color[2]);
   span.alpha = ChanToFixed(vert->color[3]);
   span.redStep = 0;
   span.greenStep = 0;
   span.blueStep = 0;
   span.alphaStep = 0;

   /* need these for fragment programs */
   span.attrStart[FRAG_ATTRIB_WPOS][3] = 1.0F;
   span.attrStepX[FRAG_ATTRIB_WPOS][3] = 0.0F;
   span.attrStepY[FRAG_ATTRIB_WPOS][3] = 0.0F;

   ATTRIB_LOOP_BEGIN
      COPY_4V(span.attrStart[attr], vert->attrib[attr]);
      ASSIGN_4V(span.attrStepX[attr], 0, 0, 0, 0);
      ASSIGN_4V(span.attrStepY[attr], 0, 0, 0, 0);
   ATTRIB_LOOP_END

   /* compute pos, bounds and render */
   {
      const GLfloat x = vert->attrib[FRAG_ATTRIB_WPOS][0];
      const GLfloat y = vert->attrib[FRAG_ATTRIB_WPOS][1];
      const GLfloat radius = 0.5F * size;
      const GLfloat rmin = radius - 0.7071F;  /* 0.7071 = sqrt(2)/2 */
      const GLfloat rmax = radius + 0.7071F;
      const GLfloat rmin2 = MAX2(0.0F, rmin * rmin);
      const GLfloat rmax2 = rmax * rmax;
      const GLfloat cscale = 1.0F / (rmax2 - rmin2);
      const GLint xmin = (GLint) (x - radius);
      const GLint xmax = (GLint) (x + radius);
      const GLint ymin = (GLint) (y - radius);
      const GLint ymax = (GLint) (y + radius);
      GLint ix, iy;

      for (iy = ymin; iy <= ymax; iy++) {

         /* these might get changed by span clipping */
         span.x = xmin;
         span.y = iy;
         span.end = xmax - xmin + 1;

         /* compute coverage for each pixel in span */
         for (ix = xmin; ix <= xmax; ix++) {
            const GLfloat dx = ix - x + 0.5F;
            const GLfloat dy = iy - y + 0.5F;
            const GLfloat dist2 = dx * dx + dy * dy;
            GLfloat coverage;

            if (dist2 < rmax2) {
               if (dist2 >= rmin2) {
                  /* compute partial coverage */
                  coverage = 1.0F - (dist2 - rmin2) * cscale;
               }
               else {
                  /* full coverage */
                  coverage = 1.0F;
               }
               span.array->mask[ix - xmin] = 1;
            }
            else {
               /* zero coverage - fragment outside the radius */
               coverage = 0.0;
               span.array->mask[ix - xmin] = 0;
            }
            span.array->coverage[ix - xmin] = coverage;
         }
a142 2
         /* render span */
         _swrast_write_rgba_span(ctx, &span);
d144 6
a149 3
      }
   }
}
d152 3
a154 9
/**
 * Draw large (size >= 1) non-AA point.  RGB or CI mode.
 */
static void
large_point(struct gl_context *ctx, const SWvertex *vert)
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
   SWspan span;
   GLfloat size;
a155 1
   CULL_INVALID(vert);
a156 61
   /* z coord */
   if (ctx->DrawBuffer->Visual.depthBits <= 16)
      span.z = FloatToFixed(vert->attrib[FRAG_ATTRIB_WPOS][2] + 0.5F);
   else
      span.z = (GLuint) (vert->attrib[FRAG_ATTRIB_WPOS][2] + 0.5F);
   span.zStep = 0;

   size = get_size(ctx, vert, GL_FALSE);

   /* span init */
   INIT_SPAN(span, GL_POINT);
   span.arrayMask = SPAN_XY;
   span.facing = swrast->PointLineFacing;

   span.interpMask = SPAN_Z | SPAN_RGBA;
   span.red   = ChanToFixed(vert->color[0]);
   span.green = ChanToFixed(vert->color[1]);
   span.blue  = ChanToFixed(vert->color[2]);
   span.alpha = ChanToFixed(vert->color[3]);
   span.redStep = 0;
   span.greenStep = 0;
   span.blueStep = 0;
   span.alphaStep = 0;

   /* need these for fragment programs */
   span.attrStart[FRAG_ATTRIB_WPOS][3] = 1.0F;
   span.attrStepX[FRAG_ATTRIB_WPOS][3] = 0.0F;
   span.attrStepY[FRAG_ATTRIB_WPOS][3] = 0.0F;

   ATTRIB_LOOP_BEGIN
      COPY_4V(span.attrStart[attr], vert->attrib[attr]);
      ASSIGN_4V(span.attrStepX[attr], 0, 0, 0, 0);
      ASSIGN_4V(span.attrStepY[attr], 0, 0, 0, 0);
   ATTRIB_LOOP_END

   /* compute pos, bounds and render */
   {
      const GLfloat x = vert->attrib[FRAG_ATTRIB_WPOS][0];
      const GLfloat y = vert->attrib[FRAG_ATTRIB_WPOS][1];
      GLint iSize = (GLint) (size + 0.5F);
      GLint xmin, xmax, ymin, ymax, ix, iy;
      GLint iRadius;

      iSize = MAX2(1, iSize);
      iRadius = iSize / 2;

      if (iSize & 1) {
         /* odd size */
         xmin = (GLint) (x - iRadius);
         xmax = (GLint) (x + iRadius);
         ymin = (GLint) (y - iRadius);
         ymax = (GLint) (y + iRadius);
      }
      else {
         /* even size */
         /* 0.501 factor allows conformance to pass */
         xmin = (GLint) (x + 0.501) - iRadius;
         xmax = xmin + iSize - 1;
         ymin = (GLint) (y + 0.501) - iRadius;
         ymax = ymin + iSize - 1;
      }
d158 9
a166 12
      /* generate fragments */
      span.end = 0;
      for (iy = ymin; iy <= ymax; iy++) {
         for (ix = xmin; ix <= xmax; ix++) {
            span.array->x[span.end] = ix;
            span.array->y[span.end] = iy;
            span.end++;
         }
      }
      assert(span.end <= MAX_WIDTH);
      _swrast_write_rgba_span(ctx, &span);
   }
a169 38
/**
 * Draw size=1, single-pixel point
 */
static void
pixel_point(struct gl_context *ctx, const SWvertex *vert)
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
   /*
    * Note that unlike the other functions, we put single-pixel points
    * into a special span array in order to render as many points as
    * possible with a single _swrast_write_rgba_span() call.
    */
   SWspan *span = &(swrast->PointSpan);
   GLuint count;

   CULL_INVALID(vert);

   /* Span init */
   span->interpMask = 0;
   span->arrayMask = SPAN_XY | SPAN_Z;
   span->arrayMask |= SPAN_RGBA;
   /*span->arrayMask |= SPAN_LAMBDA;*/
   span->arrayAttribs = swrast->_ActiveAttribMask; /* we'll produce these vals */

   /* need these for fragment programs */
   span->attrStart[FRAG_ATTRIB_WPOS][3] = 1.0F;
   span->attrStepX[FRAG_ATTRIB_WPOS][3] = 0.0F;
   span->attrStepY[FRAG_ATTRIB_WPOS][3] = 0.0F;

   /* check if we need to flush */
   if (span->end >= MAX_WIDTH ||
       (swrast->_RasterMask & (BLEND_BIT | LOGIC_OP_BIT | MASKING_BIT)) ||
       span->facing != swrast->PointLineFacing) {
      if (span->end > 0) {
	 _swrast_write_rgba_span(ctx, span);
         span->end = 0;
      }
   }
d171 2
a172 1
   count = span->end;
d174 1
a174 1
   span->facing = swrast->PointLineFacing;
d176 6
a181 14
   /* fragment attributes */
   span->array->rgba[count][RCOMP] = vert->color[0];
   span->array->rgba[count][GCOMP] = vert->color[1];
   span->array->rgba[count][BCOMP] = vert->color[2];
   span->array->rgba[count][ACOMP] = vert->color[3];

   ATTRIB_LOOP_BEGIN
      COPY_4V(span->array->attribs[attr][count], vert->attrib[attr]);
   ATTRIB_LOOP_END

   /* fragment position */
   span->array->x[count] = (GLint) vert->attrib[FRAG_ATTRIB_WPOS][0];
   span->array->y[count] = (GLint) vert->attrib[FRAG_ATTRIB_WPOS][1];
   span->array->z[count] = (GLint) (vert->attrib[FRAG_ATTRIB_WPOS][2] + 0.5F);
d183 1
a183 3
   span->end = count + 1;
   ASSERT(span->end <= MAX_WIDTH);
}
d185 1
d187 1
a187 25
/**
 * Add specular color to primary color, draw point, restore original
 * primary color.
 */
void
_swrast_add_spec_terms_point(struct gl_context *ctx, const SWvertex *v0)
{
   SWvertex *ncv0 = (SWvertex *) v0; /* cast away const */
   GLfloat rSum, gSum, bSum;
   GLchan cSave[4];

   /* save */
   COPY_CHAN4(cSave, ncv0->color);
   /* sum */
   rSum = CHAN_TO_FLOAT(ncv0->color[0]) + ncv0->attrib[FRAG_ATTRIB_COL1][0];
   gSum = CHAN_TO_FLOAT(ncv0->color[1]) + ncv0->attrib[FRAG_ATTRIB_COL1][1];
   bSum = CHAN_TO_FLOAT(ncv0->color[2]) + ncv0->attrib[FRAG_ATTRIB_COL1][2];
   UNCLAMPED_FLOAT_TO_CHAN(ncv0->color[0], rSum);
   UNCLAMPED_FLOAT_TO_CHAN(ncv0->color[1], gSum);
   UNCLAMPED_FLOAT_TO_CHAN(ncv0->color[2], bSum);
   /* draw */
   SWRAST_CONTEXT(ctx)->SpecPoint(ctx, ncv0);
   /* restore */
   COPY_CHAN4(ncv0->color, cSave);
}
d190 3
a192 2
/**
 * Examine current state to determine which point drawing function to use.
d195 1
a195 1
_swrast_choose_point(struct gl_context *ctx)
d198 1
a198 3
   const GLfloat size = CLAMP(ctx->Point.Size,
                              ctx->Point.MinSize,
                              ctx->Point.MaxSize);
d200 1
a200 1
   if (ctx->RenderMode == GL_RENDER) {
d202 6
a207 1
         swrast->Point = sprite_point;
d210 15
a224 1
         swrast->Point = smooth_point;
d226 31
a256 4
      else if (size > 1.0 ||
               ctx->Point._Attenuated ||
               ctx->VertexProgram.PointSizeEnabled) {
         swrast->Point = large_point;
d259 7
a265 1
         swrast->Point = pixel_point;
d268 2
a269 2
   else if (ctx->RenderMode == GL_FEEDBACK) {
      swrast->Point = _swrast_feedback_point;
d273 1
a273 1
      swrast->Point = _swrast_select_point;
@


1.1.1.4
log
@Import Mesa 9.2.0
@
text
@d3 1
d20 3
a22 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
d40 2
a41 2
      float tmp = (V)->attrib[VARYING_SLOT_POS][0]   \
                + (V)->attrib[VARYING_SLOT_POS][1];  \
d54 1
a54 1
static inline GLfloat
d96 1
a96 1
      span.z = FloatToFixed(vert->attrib[VARYING_SLOT_POS][2] + 0.5F);
d98 1
a98 1
      span.z = (GLuint) (vert->attrib[VARYING_SLOT_POS][2] + 0.5F);
d119 3
a121 3
   span.attrStart[VARYING_SLOT_POS][3] = 1.0F;
   span.attrStepX[VARYING_SLOT_POS][3] = 0.0F;
   span.attrStepY[VARYING_SLOT_POS][3] = 0.0F;
d140 1
a140 1
         if (attr >= VARYING_SLOT_TEX0 && attr <= VARYING_SLOT_TEX7) {
d142 1
a142 1
            const GLuint u = attr - VARYING_SLOT_TEX0;
d172 1
a172 1
         else if (attr == VARYING_SLOT_PNTC) {
d174 7
a180 7
            span.attrStart[VARYING_SLOT_PNTC][0] = 0.0;
            span.attrStart[VARYING_SLOT_PNTC][1] = 0.0; /* t0 set below */
            span.attrStepX[VARYING_SLOT_PNTC][0] = dsdx;
            span.attrStepX[VARYING_SLOT_PNTC][1] = 0.0;
            span.attrStepY[VARYING_SLOT_PNTC][0] = 0.0;
            span.attrStepY[VARYING_SLOT_PNTC][1] = dtdy;
            tCoords[numTcoords++] = VARYING_SLOT_PNTC;
d192 2
a193 2
      const GLfloat x = vert->attrib[VARYING_SLOT_POS][0];
      const GLfloat y = vert->attrib[VARYING_SLOT_POS][1];
d253 1
a253 1
      span.z = FloatToFixed(vert->attrib[VARYING_SLOT_POS][2] + 0.5F);
d255 1
a255 1
      span.z = (GLuint) (vert->attrib[VARYING_SLOT_POS][2] + 0.5F);
d292 3
a294 3
   span.attrStart[VARYING_SLOT_POS][3] = 1.0F;
   span.attrStepX[VARYING_SLOT_POS][3] = 0.0F;
   span.attrStepY[VARYING_SLOT_POS][3] = 0.0F;
d304 2
a305 2
      const GLfloat x = vert->attrib[VARYING_SLOT_POS][0];
      const GLfloat y = vert->attrib[VARYING_SLOT_POS][1];
d373 1
a373 1
      span.z = FloatToFixed(vert->attrib[VARYING_SLOT_POS][2] + 0.5F);
d375 1
a375 1
      span.z = (GLuint) (vert->attrib[VARYING_SLOT_POS][2] + 0.5F);
d396 3
a398 3
   span.attrStart[VARYING_SLOT_POS][3] = 1.0F;
   span.attrStepX[VARYING_SLOT_POS][3] = 0.0F;
   span.attrStepY[VARYING_SLOT_POS][3] = 0.0F;
d408 2
a409 2
      const GLfloat x = vert->attrib[VARYING_SLOT_POS][0];
      const GLfloat y = vert->attrib[VARYING_SLOT_POS][1];
d442 1
a442 1
      assert(span.end <= SWRAST_MAX_WIDTH);
d473 3
a475 3
   span->attrStart[VARYING_SLOT_POS][3] = 1.0F;
   span->attrStepX[VARYING_SLOT_POS][3] = 0.0F;
   span->attrStepY[VARYING_SLOT_POS][3] = 0.0F;
d478 1
a478 1
   if (span->end >= SWRAST_MAX_WIDTH ||
d502 3
a504 3
   span->array->x[count] = (GLint) vert->attrib[VARYING_SLOT_POS][0];
   span->array->y[count] = (GLint) vert->attrib[VARYING_SLOT_POS][1];
   span->array->z[count] = (GLint) (vert->attrib[VARYING_SLOT_POS][2] + 0.5F);
d507 1
a507 1
   ASSERT(span->end <= SWRAST_MAX_WIDTH);
d525 3
a527 3
   rSum = CHAN_TO_FLOAT(ncv0->color[0]) + ncv0->attrib[VARYING_SLOT_COL1][0];
   gSum = CHAN_TO_FLOAT(ncv0->color[1]) + ncv0->attrib[VARYING_SLOT_COL1][1];
   bSum = CHAN_TO_FLOAT(ncv0->color[2]) + ncv0->attrib[VARYING_SLOT_COL1][2];
@


