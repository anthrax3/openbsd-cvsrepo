head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.8
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.6
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.5
	v10_2_7:1.1.1.5
	OPENBSD_5_6:1.7.0.4
	OPENBSD_5_6_BASE:1.7
	v10_2_3:1.1.1.5
	OPENBSD_5_5:1.7.0.2
	OPENBSD_5_5_BASE:1.7
	v9_2_5:1.1.1.5
	v9_2_3:1.1.1.5
	v9_2_2:1.1.1.5
	v9_2_1:1.1.1.5
	v9_2_0:1.1.1.5
	OPENBSD_5_4:1.6.0.8
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.6
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.4
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.5.0.6
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.4
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_3:1.2.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.55;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2013.09.05.14.06.48;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2011.10.23.13.37.45;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.05.22.20.06.34;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.05.17.20.26.42;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.14.58.23;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.02.12.21.09.27;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.51.18;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.51.18;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.56.50;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.32.07;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.48;	author matthieu;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.09.05.13.17.30;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */


#include "main/glheader.h"
#include "main/context.h"
#include "main/colormac.h"
#include "main/condrender.h"
#include "main/macros.h"
#include "main/pixeltransfer.h"
#include "main/imports.h"

#include "s_context.h"
#include "s_depth.h"
#include "s_span.h"
#include "s_stencil.h"
#include "s_zoom.h"



/**
 * Determine if there's overlap in an image copy.
 * This test also compensates for the fact that copies are done from
 * bottom to top and overlaps can sometimes be handled correctly
 * without making a temporary image copy.
 * \return GL_TRUE if the regions overlap, GL_FALSE otherwise.
 */
static GLboolean
regions_overlap(GLint srcx, GLint srcy,
                GLint dstx, GLint dsty,
                GLint width, GLint height,
                GLfloat zoomX, GLfloat zoomY)
{
   if (zoomX == 1.0 && zoomY == 1.0) {
      /* no zoom */
      if (srcx >= dstx + width || (srcx + width <= dstx)) {
         return GL_FALSE;
      }
      else if (srcy < dsty) { /* this is OK */
         return GL_FALSE;
      }
      else if (srcy > dsty + height) {
         return GL_FALSE;
      }
      else {
         return GL_TRUE;
      }
   }
   else {
      /* add one pixel of slop when zooming, just to be safe */
      if (srcx > (dstx + ((zoomX > 0.0F) ? (width * zoomX + 1.0F) : 0.0F))) {
         /* src is completely right of dest */
         return GL_FALSE;
      }
      else if (srcx + width + 1.0F < dstx + ((zoomX > 0.0F) ? 0.0F : (width * zoomX))) {
         /* src is completely left of dest */
         return GL_FALSE;
      }
      else if ((srcy < dsty) && (srcy + height < dsty + (height * zoomY))) {
         /* src is completely below dest */
         return GL_FALSE;
      }
      else if ((srcy > dsty) && (srcy + height > dsty + (height * zoomY))) {
         /* src is completely above dest */
         return GL_FALSE;
      }
      else {
         return GL_TRUE;
      }
   }
}


/**
 * RGBA copypixels
 */
static void
copy_rgba_pixels(struct gl_context *ctx, GLint srcx, GLint srcy,
                 GLint width, GLint height, GLint destx, GLint desty)
{
   GLfloat *tmpImage, *p;
   GLint sy, dy, stepy, row;
   const GLboolean zoom = ctx->Pixel.ZoomX != 1.0F || ctx->Pixel.ZoomY != 1.0F;
   GLint overlapping;
   GLuint transferOps = ctx->_ImageTransferState;
   SWspan span;

   if (!ctx->ReadBuffer->_ColorReadBuffer) {
      /* no readbuffer - OK */
      return;
   }

   if (ctx->DrawBuffer == ctx->ReadBuffer) {
      overlapping = regions_overlap(srcx, srcy, destx, desty, width, height,
                                    ctx->Pixel.ZoomX, ctx->Pixel.ZoomY);
   }
   else {
      overlapping = GL_FALSE;
   }

   /* Determine if copy should be done bottom-to-top or top-to-bottom */
   if (!overlapping && srcy < desty) {
      /* top-down  max-to-min */
      sy = srcy + height - 1;
      dy = desty + height - 1;
      stepy = -1;
   }
   else {
      /* bottom-up  min-to-max */
      sy = srcy;
      dy = desty;
      stepy = 1;
   }

   INIT_SPAN(span, GL_BITMAP);
   _swrast_span_default_attribs(ctx, &span);
   span.arrayMask = SPAN_RGBA;
   span.arrayAttribs = VARYING_BIT_COL0; /* we'll fill in COL0 attrib values */

   if (overlapping) {
      tmpImage = malloc(width * height * sizeof(GLfloat) * 4);
      if (!tmpImage) {
         _mesa_error( ctx, GL_OUT_OF_MEMORY, "glCopyPixels" );
         return;
      }
      /* read the source image as RGBA/float */
      p = tmpImage;
      for (row = 0; row < height; row++) {
         _swrast_read_rgba_span( ctx, ctx->ReadBuffer->_ColorReadBuffer,
                                 width, srcx, sy + row, p );
         p += width * 4;
      }
      p = tmpImage;
   }
   else {
      tmpImage = NULL;  /* silence compiler warnings */
      p = NULL;
   }

   ASSERT(width < SWRAST_MAX_WIDTH);

   for (row = 0; row < height; row++, sy += stepy, dy += stepy) {
      GLvoid *rgba = span.array->attribs[VARYING_SLOT_COL0];

      /* Get row/span of source pixels */
      if (overlapping) {
         /* get from buffered image */
         memcpy(rgba, p, width * sizeof(GLfloat) * 4);
         p += width * 4;
      }
      else {
         /* get from framebuffer */
         _swrast_read_rgba_span( ctx, ctx->ReadBuffer->_ColorReadBuffer,
                                 width, srcx, sy, rgba );
      }

      if (transferOps) {
         _mesa_apply_rgba_transfer_ops(ctx, transferOps, width,
                                       (GLfloat (*)[4]) rgba);
      }

      /* Write color span */
      span.x = destx;
      span.y = dy;
      span.end = width;
      span.array->ChanType = GL_FLOAT;
      if (zoom) {
         _swrast_write_zoomed_rgba_span(ctx, destx, desty, &span, rgba);
      }
      else {
         _swrast_write_rgba_span(ctx, &span);
      }
   }

   span.array->ChanType = CHAN_TYPE; /* restore */

   if (overlapping)
      free(tmpImage);
}


/**
 * Convert floating point Z values to integer Z values with pixel transfer's
 * Z scale and bias.
 */
static void
scale_and_bias_z(struct gl_context *ctx, GLuint width,
                 const GLfloat depth[], GLuint z[])
{
   const GLuint depthMax = ctx->DrawBuffer->_DepthMax;
   GLuint i;

   if (depthMax <= 0xffffff &&
       ctx->Pixel.DepthScale == 1.0 &&
       ctx->Pixel.DepthBias == 0.0) {
      /* no scale or bias and no clamping and no worry of overflow */
      const GLfloat depthMaxF = ctx->DrawBuffer->_DepthMaxF;
      for (i = 0; i < width; i++) {
         z[i] = (GLuint) (depth[i] * depthMaxF);
      }
   }
   else {
      /* need to be careful with overflow */
      const GLdouble depthMaxF = ctx->DrawBuffer->_DepthMaxF;
      for (i = 0; i < width; i++) {
         GLdouble d = depth[i] * ctx->Pixel.DepthScale + ctx->Pixel.DepthBias;
         d = CLAMP(d, 0.0, 1.0) * depthMaxF;
         if (d >= depthMaxF)
            z[i] = depthMax;
         else
            z[i] = (GLuint) d;
      }
   }
}



/*
 * TODO: Optimize!!!!
 */
static void
copy_depth_pixels( struct gl_context *ctx, GLint srcx, GLint srcy,
                   GLint width, GLint height,
                   GLint destx, GLint desty )
{
   struct gl_framebuffer *fb = ctx->ReadBuffer;
   struct gl_renderbuffer *readRb = fb->Attachment[BUFFER_DEPTH].Renderbuffer;
   GLfloat *p, *tmpImage, *depth;
   GLint sy, dy, stepy;
   GLint j;
   const GLboolean zoom = ctx->Pixel.ZoomX != 1.0F || ctx->Pixel.ZoomY != 1.0F;
   GLint overlapping;
   SWspan span;

   if (!readRb) {
      /* no readbuffer - OK */
      return;
   }

   INIT_SPAN(span, GL_BITMAP);
   _swrast_span_default_attribs(ctx, &span);
   span.arrayMask = SPAN_Z;

   if (ctx->DrawBuffer == ctx->ReadBuffer) {
      overlapping = regions_overlap(srcx, srcy, destx, desty, width, height,
                                    ctx->Pixel.ZoomX, ctx->Pixel.ZoomY);
   }
   else {
      overlapping = GL_FALSE;
   }

   /* Determine if copy should be bottom-to-top or top-to-bottom */
   if (!overlapping && srcy < desty) {
      /* top-down  max-to-min */
      sy = srcy + height - 1;
      dy = desty + height - 1;
      stepy = -1;
   }
   else {
      /* bottom-up  min-to-max */
      sy = srcy;
      dy = desty;
      stepy = 1;
   }

   if (overlapping) {
      GLint ssy = sy;
      tmpImage = malloc(width * height * sizeof(GLfloat));
      if (!tmpImage) {
         _mesa_error( ctx, GL_OUT_OF_MEMORY, "glCopyPixels" );
         return;
      }
      p = tmpImage;
      for (j = 0; j < height; j++, ssy += stepy) {
         _swrast_read_depth_span_float(ctx, readRb, width, srcx, ssy, p);
         p += width;
      }
      p = tmpImage;
   }
   else {
      tmpImage = NULL;  /* silence compiler warning */
      p = NULL;
   }

   depth = malloc(width * sizeof(GLfloat));
   if (!depth) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCopyPixels()");
      goto end;
   }

   for (j = 0; j < height; j++, sy += stepy, dy += stepy) {
      /* get depth values */
      if (overlapping) {
         memcpy(depth, p, width * sizeof(GLfloat));
         p += width;
      }
      else {
         _swrast_read_depth_span_float(ctx, readRb, width, srcx, sy, depth);
      }

      /* apply scale and bias */
      scale_and_bias_z(ctx, width, depth, span.array->z);

      /* write depth values */
      span.x = destx;
      span.y = dy;
      span.end = width;
      if (zoom)
         _swrast_write_zoomed_depth_span(ctx, destx, desty, &span);
      else
         _swrast_write_rgba_span(ctx, &span);
   }

   free(depth);

end:
   if (overlapping)
      free(tmpImage);
}



static void
copy_stencil_pixels( struct gl_context *ctx, GLint srcx, GLint srcy,
                     GLint width, GLint height,
                     GLint destx, GLint desty )
{
   struct gl_framebuffer *fb = ctx->ReadBuffer;
   struct gl_renderbuffer *rb = fb->Attachment[BUFFER_STENCIL].Renderbuffer;
   GLint sy, dy, stepy;
   GLint j;
   GLubyte *p, *tmpImage, *stencil;
   const GLboolean zoom = ctx->Pixel.ZoomX != 1.0F || ctx->Pixel.ZoomY != 1.0F;
   GLint overlapping;

   if (!rb) {
      /* no readbuffer - OK */
      return;
   }

   if (ctx->DrawBuffer == ctx->ReadBuffer) {
      overlapping = regions_overlap(srcx, srcy, destx, desty, width, height,
                                    ctx->Pixel.ZoomX, ctx->Pixel.ZoomY);
   }
   else {
      overlapping = GL_FALSE;
   }

   /* Determine if copy should be bottom-to-top or top-to-bottom */
   if (!overlapping && srcy < desty) {
      /* top-down  max-to-min */
      sy = srcy + height - 1;
      dy = desty + height - 1;
      stepy = -1;
   }
   else {
      /* bottom-up  min-to-max */
      sy = srcy;
      dy = desty;
      stepy = 1;
   }

   if (overlapping) {
      GLint ssy = sy;
      tmpImage = malloc(width * height * sizeof(GLubyte));
      if (!tmpImage) {
         _mesa_error( ctx, GL_OUT_OF_MEMORY, "glCopyPixels" );
         return;
      }
      p = tmpImage;
      for (j = 0; j < height; j++, ssy += stepy) {
         _swrast_read_stencil_span( ctx, rb, width, srcx, ssy, p );
         p += width;
      }
      p = tmpImage;
   }
   else {
      tmpImage = NULL;  /* silence compiler warning */
      p = NULL;
   }

   stencil = malloc(width * sizeof(GLubyte));
   if (!stencil) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCopyPixels()");
      goto end;
   }

   for (j = 0; j < height; j++, sy += stepy, dy += stepy) {
      /* Get stencil values */
      if (overlapping) {
         memcpy(stencil, p, width * sizeof(GLubyte));
         p += width;
      }
      else {
         _swrast_read_stencil_span( ctx, rb, width, srcx, sy, stencil );
      }

      _mesa_apply_stencil_transfer_ops(ctx, width, stencil);

      /* Write stencil values */
      if (zoom) {
         _swrast_write_zoomed_stencil_span(ctx, destx, desty, width,
                                           destx, dy, stencil);
      }
      else {
         _swrast_write_stencil_span( ctx, width, destx, dy, stencil );
      }
   }

   free(stencil);

end:
   if (overlapping)
      free(tmpImage);
}


/**
 * Try to do a fast 1:1 blit with memcpy.
 * \return GL_TRUE if successful, GL_FALSE otherwise.
 */
GLboolean
swrast_fast_copy_pixels(struct gl_context *ctx,
			GLint srcX, GLint srcY, GLsizei width, GLsizei height,
			GLint dstX, GLint dstY, GLenum type)
{
   struct gl_framebuffer *srcFb = ctx->ReadBuffer;
   struct gl_framebuffer *dstFb = ctx->DrawBuffer;
   struct gl_renderbuffer *srcRb, *dstRb;
   GLint row;
   GLuint pixelBytes, widthInBytes;
   GLubyte *srcMap, *dstMap;
   GLint srcRowStride, dstRowStride;

   if (type == GL_COLOR) {
      if (dstFb->_NumColorDrawBuffers != 1)
         return GL_FALSE;
      srcRb = srcFb->_ColorReadBuffer;
      dstRb = dstFb->_ColorDrawBuffers[0];
   }
   else if (type == GL_STENCIL) {
      srcRb = srcFb->Attachment[BUFFER_STENCIL].Renderbuffer;
      dstRb = dstFb->Attachment[BUFFER_STENCIL].Renderbuffer;
   }
   else if (type == GL_DEPTH) {
      srcRb = srcFb->Attachment[BUFFER_DEPTH].Renderbuffer;
      dstRb = dstFb->Attachment[BUFFER_DEPTH].Renderbuffer;
   }
   else {
      ASSERT(type == GL_DEPTH_STENCIL_EXT);
      /* XXX correct? */
      srcRb = srcFb->Attachment[BUFFER_DEPTH].Renderbuffer;
      dstRb = dstFb->Attachment[BUFFER_DEPTH].Renderbuffer;
   }

   /* src and dst renderbuffers must be same format */
   if (!srcRb || !dstRb || srcRb->Format != dstRb->Format) {
      return GL_FALSE;
   }

   if (type == GL_STENCIL || type == GL_DEPTH_COMPONENT) {
      /* can't handle packed depth+stencil here */
      if (_mesa_is_format_packed_depth_stencil(srcRb->Format) ||
          _mesa_is_format_packed_depth_stencil(dstRb->Format))
         return GL_FALSE;
   }
   else if (type == GL_DEPTH_STENCIL) {
      /* can't handle separate depth/stencil buffers */
      if (srcRb != srcFb->Attachment[BUFFER_STENCIL].Renderbuffer ||
          dstRb != dstFb->Attachment[BUFFER_STENCIL].Renderbuffer)
         return GL_FALSE;
   }

   /* clipping not supported */
   if (srcX < 0 || srcX + width > (GLint) srcFb->Width ||
       srcY < 0 || srcY + height > (GLint) srcFb->Height ||
       dstX < dstFb->_Xmin || dstX + width > dstFb->_Xmax ||
       dstY < dstFb->_Ymin || dstY + height > dstFb->_Ymax) {
      return GL_FALSE;
   }

   pixelBytes = _mesa_get_format_bytes(srcRb->Format);
   widthInBytes = width * pixelBytes;

   if (srcRb == dstRb) {
      /* map whole buffer for read/write */
      /* XXX we could be clever and just map the union region of the
       * source and dest rects.
       */
      GLubyte *map;
      GLint rowStride;

      ctx->Driver.MapRenderbuffer(ctx, srcRb, 0, 0,
                                  srcRb->Width, srcRb->Height,
                                  GL_MAP_READ_BIT | GL_MAP_WRITE_BIT,
                                  &map, &rowStride);
      if (!map) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCopyPixels");
         return GL_TRUE; /* don't retry with slow path */
      }

      srcMap = map + srcY * rowStride + srcX * pixelBytes;
      dstMap = map + dstY * rowStride + dstX * pixelBytes;

      /* this handles overlapping copies */
      if (srcY < dstY) {
         /* copy in reverse (top->down) order */
         srcMap += rowStride * (height - 1);
         dstMap += rowStride * (height - 1);
         srcRowStride = -rowStride;
         dstRowStride = -rowStride;
      }
      else {
         /* copy in normal (bottom->up) order */
         srcRowStride = rowStride;
         dstRowStride = rowStride;
      }
   }
   else {
      /* different src/dst buffers */
      ctx->Driver.MapRenderbuffer(ctx, srcRb, srcX, srcY,
                                  width, height,
                                  GL_MAP_READ_BIT, &srcMap, &srcRowStride);
      if (!srcMap) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCopyPixels");
         return GL_TRUE; /* don't retry with slow path */
      }
      ctx->Driver.MapRenderbuffer(ctx, dstRb, dstX, dstY,
                                  width, height,
                                  GL_MAP_WRITE_BIT, &dstMap, &dstRowStride);
      if (!dstMap) {
         ctx->Driver.UnmapRenderbuffer(ctx, srcRb);
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCopyPixels");
         return GL_TRUE; /* don't retry with slow path */
      }
   }

   for (row = 0; row < height; row++) {
      /* memmove() in case of overlap */
      memmove(dstMap, srcMap, widthInBytes);
      dstMap += dstRowStride;
      srcMap += srcRowStride;
   }

   ctx->Driver.UnmapRenderbuffer(ctx, srcRb);
   if (dstRb != srcRb) {
      ctx->Driver.UnmapRenderbuffer(ctx, dstRb);
   }

   return GL_TRUE;
}


/**
 * Find/map the renderbuffer that we'll be reading from.
 * The swrast_render_start() function only maps the drawing buffers,
 * not the read buffer.
 */
static struct gl_renderbuffer *
map_readbuffer(struct gl_context *ctx, GLenum type)
{
   struct gl_framebuffer *fb = ctx->ReadBuffer;
   struct gl_renderbuffer *rb;
   struct swrast_renderbuffer *srb;

   switch (type) {
   case GL_COLOR:
      rb = fb->Attachment[fb->_ColorReadBufferIndex].Renderbuffer;
      break;
   case GL_DEPTH:
   case GL_DEPTH_STENCIL:
      rb = fb->Attachment[BUFFER_DEPTH].Renderbuffer;
      break;
   case GL_STENCIL:
      rb = fb->Attachment[BUFFER_STENCIL].Renderbuffer;
      break;
   default:
      return NULL;
   }

   srb = swrast_renderbuffer(rb);

   if (!srb || srb->Map) {
      /* no buffer, or buffer is mapped already, we're done */
      return NULL;
   }

   ctx->Driver.MapRenderbuffer(ctx, rb,
                               0, 0, rb->Width, rb->Height,
                               GL_MAP_READ_BIT,
                               &srb->Map, &srb->RowStride);

   return rb;
}


/**
 * Do software-based glCopyPixels.
 * By time we get here, all parameters will have been error-checked.
 */
void
_swrast_CopyPixels( struct gl_context *ctx,
		    GLint srcx, GLint srcy, GLsizei width, GLsizei height,
		    GLint destx, GLint desty, GLenum type )
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
   struct gl_renderbuffer *rb;
      
   if (!_mesa_check_conditional_render(ctx))
      return; /* don't copy */

   if (swrast->NewState)
      _swrast_validate_derived( ctx );

   if (!(SWRAST_CONTEXT(ctx)->_RasterMask != 0x0 ||
	 ctx->Pixel.ZoomX != 1.0F ||
	 ctx->Pixel.ZoomY != 1.0F ||
	 ctx->_ImageTransferState) &&
       swrast_fast_copy_pixels(ctx, srcx, srcy, width, height, destx, desty,
			       type)) {
      /* all done */
      return;
   }

   swrast_render_start(ctx);
   rb = map_readbuffer(ctx, type);

   switch (type) {
   case GL_COLOR:
      copy_rgba_pixels( ctx, srcx, srcy, width, height, destx, desty );
      break;
   case GL_DEPTH:
      copy_depth_pixels( ctx, srcx, srcy, width, height, destx, desty );
      break;
   case GL_STENCIL:
      copy_stencil_pixels( ctx, srcx, srcy, width, height, destx, desty );
      break;
   case GL_DEPTH_STENCIL_EXT:
      /* Copy buffers separately (if the fast copy path wasn't taken) */
      copy_depth_pixels(ctx, srcx, srcy, width, height, destx, desty);
      copy_stencil_pixels(ctx, srcx, srcy, width, height, destx, desty);
      break;
   default:
      _mesa_problem(ctx, "unexpected type in _swrast_CopyPixels");
   }

   swrast_render_finish(ctx);

   if (rb) {
      struct swrast_renderbuffer *srb = swrast_renderbuffer(rb);
      ctx->Driver.UnmapRenderbuffer(ctx, rb);
      srb->Map = NULL;
   }
}
@


1.7
log
@Merge Mesa 9.2.0
@
text
@@


1.6
log
@Merge Mesa 7.10.3
@
text
@a2 1
 * Version:  7.1
d19 4
a22 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
d139 1
a139 1
   span.arrayAttribs = FRAG_BIT_COL0; /* we'll fill in COL0 attrib values */
d142 1
a142 1
      tmpImage = (GLfloat *) malloc(width * height * sizeof(GLfloat) * 4);
d151 1
a151 1
                                 width, srcx, sy + row, GL_FLOAT, p );
d161 1
a161 1
   ASSERT(width < MAX_WIDTH);
d164 1
a164 1
      GLvoid *rgba = span.array->attribs[FRAG_ATTRIB_COL0];
d175 1
a175 1
                                 width, srcx, sy, GL_FLOAT, rgba );
d248 2
a249 2
   struct gl_renderbuffer *readRb = fb->_DepthBuffer;
   GLfloat *p, *tmpImage;
d289 1
a289 1
      tmpImage = (GLfloat *) malloc(width * height * sizeof(GLfloat));
d306 6
a312 1
      GLfloat depth[MAX_WIDTH];
d335 3
d350 1
a350 1
   struct gl_renderbuffer *rb = fb->_StencilBuffer;
d353 1
a353 1
   GLstencil *p, *tmpImage;
d386 1
a386 1
      tmpImage = (GLstencil *) malloc(width * height * sizeof(GLstencil));
d403 6
a409 2
      GLstencil stencil[MAX_WIDTH];

d412 1
a412 1
         memcpy(stencil, p, width * sizeof(GLstencil));
d431 3
d440 2
a441 3
 * This isn't terribly efficient.  If a driver really has combined
 * depth/stencil buffers the driver should implement an optimized
 * CopyPixels function.
d443 4
a446 179
static void
copy_depth_stencil_pixels(struct gl_context *ctx,
                          const GLint srcX, const GLint srcY,
                          const GLint width, const GLint height,
                          const GLint destX, const GLint destY)
{
   struct gl_renderbuffer *stencilReadRb, *depthReadRb, *depthDrawRb;
   GLint sy, dy, stepy;
   GLint j;
   GLstencil *tempStencilImage = NULL, *stencilPtr = NULL;
   GLfloat *tempDepthImage = NULL, *depthPtr = NULL;
   const GLfloat depthScale = ctx->DrawBuffer->_DepthMaxF;
   const GLuint stencilMask = ctx->Stencil.WriteMask[0];
   const GLboolean zoom = ctx->Pixel.ZoomX != 1.0F || ctx->Pixel.ZoomY != 1.0F;
   const GLboolean scaleOrBias
      = ctx->Pixel.DepthScale != 1.0 || ctx->Pixel.DepthBias != 0.0;
   GLint overlapping;

   depthDrawRb = ctx->DrawBuffer->_DepthBuffer;
   depthReadRb = ctx->ReadBuffer->_DepthBuffer;
   stencilReadRb = ctx->ReadBuffer->_StencilBuffer;

   ASSERT(depthDrawRb);
   ASSERT(depthReadRb);
   ASSERT(stencilReadRb);

   if (ctx->DrawBuffer == ctx->ReadBuffer) {
      overlapping = regions_overlap(srcX, srcY, destX, destY, width, height,
                                    ctx->Pixel.ZoomX, ctx->Pixel.ZoomY);
   }
   else {
      overlapping = GL_FALSE;
   }

   /* Determine if copy should be bottom-to-top or top-to-bottom */
   if (!overlapping && srcY < destY) {
      /* top-down  max-to-min */
      sy = srcY + height - 1;
      dy = destY + height - 1;
      stepy = -1;
   }
   else {
      /* bottom-up  min-to-max */
      sy = srcY;
      dy = destY;
      stepy = 1;
   }

   if (overlapping) {
      GLint ssy = sy;

      if (stencilMask != 0x0) {
         tempStencilImage
            = (GLstencil *) malloc(width * height * sizeof(GLstencil));
         if (!tempStencilImage) {
            _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCopyPixels");
            return;
         }

         /* get copy of stencil pixels */
         stencilPtr = tempStencilImage;
         for (j = 0; j < height; j++, ssy += stepy) {
            _swrast_read_stencil_span(ctx, stencilReadRb,
                                      width, srcX, ssy, stencilPtr);
            stencilPtr += width;
         }
         stencilPtr = tempStencilImage;
      }

      if (ctx->Depth.Mask) {
         tempDepthImage
            = (GLfloat *) malloc(width * height * sizeof(GLfloat));
         if (!tempDepthImage) {
            _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCopyPixels");
            free(tempStencilImage);
            return;
         }

         /* get copy of depth pixels */
         depthPtr = tempDepthImage;
         for (j = 0; j < height; j++, ssy += stepy) {
            _swrast_read_depth_span_float(ctx, depthReadRb,
                                          width, srcX, ssy, depthPtr);
            depthPtr += width;
         }
         depthPtr = tempDepthImage;
      }
   }

   for (j = 0; j < height; j++, sy += stepy, dy += stepy) {
      if (stencilMask != 0x0) {
         GLstencil stencil[MAX_WIDTH];

         /* Get stencil values */
         if (overlapping) {
            memcpy(stencil, stencilPtr, width * sizeof(GLstencil));
            stencilPtr += width;
         }
         else {
            _swrast_read_stencil_span(ctx, stencilReadRb,
                                      width, srcX, sy, stencil);
         }

         _mesa_apply_stencil_transfer_ops(ctx, width, stencil);

         /* Write values */
         if (zoom) {
            _swrast_write_zoomed_stencil_span(ctx, destX, destY, width,
                                              destX, dy, stencil);
         }
         else {
            _swrast_write_stencil_span( ctx, width, destX, dy, stencil );
         }
      }

      if (ctx->Depth.Mask) {
         GLfloat depth[MAX_WIDTH];
         GLuint zVals32[MAX_WIDTH];
         GLushort zVals16[MAX_WIDTH];
         GLvoid *zVals;
         GLuint zBytes;

         /* get depth values */
         if (overlapping) {
            memcpy(depth, depthPtr, width * sizeof(GLfloat));
            depthPtr += width;
         }
         else {
            _swrast_read_depth_span_float(ctx, depthReadRb,
                                          width, srcX, sy, depth);
         }

         /* scale & bias */
         if (scaleOrBias) {
            _mesa_scale_and_bias_depth(ctx, width, depth);
         }
         /* convert to integer Z values */
         if (depthDrawRb->DataType == GL_UNSIGNED_SHORT) {
            GLint k;
            for (k = 0; k < width; k++)
               zVals16[k] = (GLushort) (depth[k] * depthScale);
            zVals = zVals16;
            zBytes = 2;
         }
         else {
            GLint k;
            for (k = 0; k < width; k++)
               zVals32[k] = (GLuint) (depth[k] * depthScale);
            zVals = zVals32;
            zBytes = 4;
         }

         /* Write values */
         if (zoom) {
            _swrast_write_zoomed_z_span(ctx, destX, destY, width,
                                        destX, dy, zVals);
         }
         else {
            _swrast_put_row(ctx, depthDrawRb, width, destX, dy, zVals, zBytes);
         }
      }
   }

   if (tempStencilImage)
      free(tempStencilImage);

   if (tempDepthImage)
      free(tempDepthImage);
}



/**
 * Try to do a fast copy pixels.
 */
static GLboolean
fast_copy_pixels(struct gl_context *ctx,
                 GLint srcX, GLint srcY, GLsizei width, GLsizei height,
                 GLint dstX, GLint dstY, GLenum type)
d451 4
a454 9
   GLint row, yStep;

   if (SWRAST_CONTEXT(ctx)->_RasterMask != 0x0 ||
       ctx->Pixel.ZoomX != 1.0F ||
       ctx->Pixel.ZoomY != 1.0F ||
       ctx->_ImageTransferState) {
      /* can't handle these */
      return GL_FALSE;
   }
d463 2
a464 2
      srcRb = srcFb->_StencilBuffer;
      dstRb = dstFb->_StencilBuffer;
d467 2
a468 2
      srcRb = srcFb->_DepthBuffer;
      dstRb = dstFb->_DepthBuffer;
d477 2
a478 4
   /* src and dst renderbuffers must be same format and type */
   if (!srcRb || !dstRb ||
       srcRb->DataType != dstRb->DataType ||
       srcRb->_BaseFormat != dstRb->_BaseFormat) {
d482 13
d503 36
a538 6
   /* overlapping src/dst doesn't matter, just determine Y direction */
   if (srcY < dstY) {
      /* top-down  max-to-min */
      srcY = srcY + height - 1;
      dstY = dstY + height - 1;
      yStep = -1;
d541 16
a556 2
      /* bottom-up  min-to-max */
      yStep = 1;
d560 9
a568 5
      GLuint temp[MAX_WIDTH][4];
      srcRb->GetRow(ctx, srcRb, width, srcX, srcY, temp);
      dstRb->PutRow(ctx, dstRb, width, dstX, dstY, temp, NULL);
      srcY += yStep;
      dstY += yStep;
d576 43
d628 1
a628 1
   swrast_render_start(ctx);
d636 30
a665 17
   if (!fast_copy_pixels(ctx, srcx, srcy, width, height, destx, desty, type)) {
      switch (type) {
      case GL_COLOR:
         copy_rgba_pixels( ctx, srcx, srcy, width, height, destx, desty );
         break;
      case GL_DEPTH:
         copy_depth_pixels( ctx, srcx, srcy, width, height, destx, desty );
         break;
      case GL_STENCIL:
         copy_stencil_pixels( ctx, srcx, srcy, width, height, destx, desty );
         break;
      case GL_DEPTH_STENCIL_EXT:
         copy_depth_stencil_pixels(ctx, srcx, srcy, width, height, destx, desty);
         break;
      default:
         _mesa_problem(ctx, "unexpected type in _swrast_CopyPixels");
      }
d669 6
@


1.5
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@a29 2
#include "main/convolve.h"
#include "main/image.h"
d31 1
a95 96
 * RGBA copypixels with convolution.
 */
static void
copy_conv_rgba_pixels(GLcontext *ctx, GLint srcx, GLint srcy,
                      GLint width, GLint height, GLint destx, GLint desty)
{
   GLint row;
   const GLboolean zoom = ctx->Pixel.ZoomX != 1.0F || ctx->Pixel.ZoomY != 1.0F;
   const GLbitfield transferOps = ctx->_ImageTransferState;
   const GLboolean sink = (ctx->Pixel.MinMaxEnabled && ctx->MinMax.Sink)
      || (ctx->Pixel.HistogramEnabled && ctx->Histogram.Sink);
   GLfloat *dest, *tmpImage, *convImage;
   SWspan span;

   INIT_SPAN(span, GL_BITMAP);
   _swrast_span_default_attribs(ctx, &span);
   span.arrayMask = SPAN_RGBA;
   span.arrayAttribs = FRAG_BIT_COL0;

   /* allocate space for GLfloat image */
   tmpImage = (GLfloat *) malloc(width * height * 4 * sizeof(GLfloat));
   if (!tmpImage) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCopyPixels");
      return;
   }
   convImage = (GLfloat *) malloc(width * height * 4 * sizeof(GLfloat));
   if (!convImage) {
      free(tmpImage);
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCopyPixels");
      return;
   }

   /* read source image as float/RGBA */
   dest = tmpImage;
   for (row = 0; row < height; row++) {
      _swrast_read_rgba_span(ctx, ctx->ReadBuffer->_ColorReadBuffer,
                             width, srcx, srcy + row, GL_FLOAT, dest);
      dest += 4 * width;
   }

   /* do the image transfer ops which preceed convolution */
   for (row = 0; row < height; row++) {
      GLfloat (*rgba)[4] = (GLfloat (*)[4]) (tmpImage + row * width * 4);
      _mesa_apply_rgba_transfer_ops(ctx,
                                    transferOps & IMAGE_PRE_CONVOLUTION_BITS,
                                    width, rgba);
   }

   /* do convolution */
   if (ctx->Pixel.Convolution2DEnabled) {
      _mesa_convolve_2d_image(ctx, &width, &height, tmpImage, convImage);
   }
   else {
      ASSERT(ctx->Pixel.Separable2DEnabled);
      _mesa_convolve_sep_image(ctx, &width, &height, tmpImage, convImage);
   }
   free(tmpImage);

   /* do remaining post-convolution image transfer ops */
   for (row = 0; row < height; row++) {
      GLfloat (*rgba)[4] = (GLfloat (*)[4]) (convImage + row * width * 4);
      _mesa_apply_rgba_transfer_ops(ctx,
                                    transferOps & IMAGE_POST_CONVOLUTION_BITS,
                                    width, rgba);
   }

   if (!sink) {
      /* write the new image */
      for (row = 0; row < height; row++) {
         const GLfloat *src = convImage + row * width * 4;
         GLfloat *rgba = (GLfloat *) span.array->attribs[FRAG_ATTRIB_COL0];

         /* copy convolved colors into span array */
         memcpy(rgba, src, width * 4 * sizeof(GLfloat));

         /* write span */
         span.x = destx;
         span.y = desty + row;
         span.end = width;
         span.array->ChanType = GL_FLOAT;
         if (zoom) {
            _swrast_write_zoomed_rgba_span(ctx, destx, desty, &span, rgba);
         }
         else {
            _swrast_write_rgba_span(ctx, &span);
         }
      }
      /* restore this */
      span.array->ChanType = CHAN_TYPE;
   }

   free(convImage);
}


/**
d99 1
a99 1
copy_rgba_pixels(GLcontext *ctx, GLint srcx, GLint srcy,
a113 10
   if (ctx->Pixel.Convolution2DEnabled || ctx->Pixel.Separable2DEnabled) {
      copy_conv_rgba_pixels(ctx, srcx, srcy, width, height, destx, desty);
      return;
   }
   else if (ctx->Pixel.Convolution1DEnabled) {
      /* make sure we don't apply 1D convolution */
      transferOps &= ~(IMAGE_CONVOLUTION_BIT |
                       IMAGE_POST_CONVOLUTION_SCALE_BIAS);
   }

d208 1
a208 1
scale_and_bias_z(GLcontext *ctx, GLuint width,
d243 1
a243 1
copy_depth_pixels( GLcontext *ctx, GLint srcx, GLint srcy,
d337 1
a337 1
copy_stencil_pixels( GLcontext *ctx, GLint srcx, GLint srcy,
d430 1
a430 1
copy_depth_stencil_pixels(GLcontext *ctx,
d605 1
a605 1
fast_copy_pixels(GLcontext *ctx,
d687 1
a687 1
_swrast_CopyPixels( GLcontext *ctx,
@


1.4
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d29 1
a30 1
#include "main/histogram.h"
a33 1
#include "main/pixel.h"
d117 1
a117 1
   tmpImage = (GLfloat *) _mesa_malloc(width * height * 4 * sizeof(GLfloat));
d122 1
a122 1
   convImage = (GLfloat *) _mesa_malloc(width * height * 4 * sizeof(GLfloat));
d124 1
a124 1
      _mesa_free(tmpImage);
d153 1
a153 1
   _mesa_free(tmpImage);
d170 1
a170 1
         _mesa_memcpy(rgba, src, width * 4 * sizeof(GLfloat));
d188 1
a188 1
   _mesa_free(convImage);
d249 1
a249 1
      tmpImage = (GLfloat *) _mesa_malloc(width * height * sizeof(GLfloat) * 4);
d276 1
a276 1
         _mesa_memcpy(rgba, p, width * sizeof(GLfloat) * 4);
d306 1
a306 95
      _mesa_free(tmpImage);
}


static void
copy_ci_pixels( GLcontext *ctx, GLint srcx, GLint srcy,
                GLint width, GLint height,
                GLint destx, GLint desty )
{
   GLuint *tmpImage,*p;
   GLint sy, dy, stepy;
   GLint j;
   const GLboolean zoom = ctx->Pixel.ZoomX != 1.0F || ctx->Pixel.ZoomY != 1.0F;
   GLint overlapping;
   SWspan span;

   if (!ctx->ReadBuffer->_ColorReadBuffer) {
      /* no readbuffer - OK */
      return;
   }

   INIT_SPAN(span, GL_BITMAP);
   _swrast_span_default_attribs(ctx, &span);
   span.arrayMask = SPAN_INDEX;

   if (ctx->DrawBuffer == ctx->ReadBuffer) {
      overlapping = regions_overlap(srcx, srcy, destx, desty, width, height,
                                    ctx->Pixel.ZoomX, ctx->Pixel.ZoomY);
   }
   else {
      overlapping = GL_FALSE;
   }

   /* Determine if copy should be bottom-to-top or top-to-bottom */
   if (!overlapping && srcy < desty) {
      /* top-down  max-to-min */
      sy = srcy + height - 1;
      dy = desty + height - 1;
      stepy = -1;
   }
   else {
      /* bottom-up  min-to-max */
      sy = srcy;
      dy = desty;
      stepy = 1;
   }

   if (overlapping) {
      GLint ssy = sy;
      tmpImage = (GLuint *) _mesa_malloc(width * height * sizeof(GLuint));
      if (!tmpImage) {
         _mesa_error( ctx, GL_OUT_OF_MEMORY, "glCopyPixels" );
         return;
      }
      /* read the image */
      p = tmpImage;
      for (j = 0; j < height; j++, ssy += stepy) {
         _swrast_read_index_span( ctx, ctx->ReadBuffer->_ColorReadBuffer,
                                  width, srcx, ssy, p );
         p += width;
      }
      p = tmpImage;
   }
   else {
      tmpImage = NULL;  /* silence compiler warning */
      p = NULL;
   }

   for (j = 0; j < height; j++, sy += stepy, dy += stepy) {
      /* Get color indexes */
      if (overlapping) {
         _mesa_memcpy(span.array->index, p, width * sizeof(GLuint));
         p += width;
      }
      else {
         _swrast_read_index_span( ctx, ctx->ReadBuffer->_ColorReadBuffer,
                                  width, srcx, sy, span.array->index );
      }

      if (ctx->_ImageTransferState)
         _mesa_apply_ci_transfer_ops(ctx, ctx->_ImageTransferState,
                                     width, span.array->index);

      /* write color indexes */
      span.x = destx;
      span.y = dy;
      span.end = width;
      if (zoom)
         _swrast_write_zoomed_index_span(ctx, destx, desty, &span);
      else
         _swrast_write_index_span(ctx, &span);
   }

   if (overlapping)
      _mesa_free(tmpImage);
d396 1
a396 1
      tmpImage = (GLfloat *) _mesa_malloc(width * height * sizeof(GLfloat));
d417 1
a417 1
         _mesa_memcpy(depth, p, width * sizeof(GLfloat));
d431 4
a434 12
      if (fb->Visual.rgbMode) {
         if (zoom)
            _swrast_write_zoomed_depth_span(ctx, destx, desty, &span);
         else
            _swrast_write_rgba_span(ctx, &span);
      }
      else {
         if (zoom)
            _swrast_write_zoomed_depth_span(ctx, destx, desty, &span);
         else
            _swrast_write_index_span(ctx, &span);
      }
d438 1
a438 1
      _mesa_free(tmpImage);
d485 1
a485 1
      tmpImage = (GLstencil *) _mesa_malloc(width * height * sizeof(GLstencil));
d507 1
a507 1
         _mesa_memcpy(stencil, p, width * sizeof(GLstencil));
d527 1
a527 1
      _mesa_free(tmpImage);
d589 1
a589 1
            = (GLstencil *) _mesa_malloc(width * height * sizeof(GLstencil));
d607 1
a607 1
            = (GLfloat *) _mesa_malloc(width * height * sizeof(GLfloat));
d610 1
a610 1
            _mesa_free(tempStencilImage);
d631 1
a631 1
            _mesa_memcpy(stencil, stencilPtr, width * sizeof(GLstencil));
d660 1
a660 1
            _mesa_memcpy(depth, depthPtr, width * sizeof(GLfloat));
d700 1
a700 1
      _mesa_free(tempStencilImage);
d703 1
a703 1
      _mesa_free(tempDepthImage);
d799 1
a799 1
   RENDER_START(swrast,ctx);
d801 3
d810 1
a810 6
         if (ctx->Visual.rgbMode) {
            copy_rgba_pixels( ctx, srcx, srcy, width, height, destx, desty );
         }
         else {
            copy_ci_pixels( ctx, srcx, srcy, width, height, destx, desty );
         }
d826 1
a826 1
   RENDER_FINISH(swrast,ctx);
@


1.3
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d26 9
a34 9
#include "glheader.h"
#include "context.h"
#include "colormac.h"
#include "convolve.h"
#include "histogram.h"
#include "image.h"
#include "macros.h"
#include "imports.h"
#include "pixel.h"
@


1.2
log
@Update to Mesa 7.0.2. Tested by naddy@@ (full ports build), simon@@
and oga@@ (with dri enabled).
@
text
@d3 1
a3 1
 * Version:  7.0.2
a103 1
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
d112 4
a115 7
   INIT_SPAN(span, GL_BITMAP, 0, 0, SPAN_RGBA);

   if (ctx->Depth.Test)
      _swrast_span_default_z(ctx, &span);
   if (swrast->_FogEnabled)
      _swrast_span_default_fog(ctx, &span);
   _swrast_span_default_secondary_color(ctx, &span);
d168 1
a168 1
         GLvoid *rgba = (GLvoid *) span.array->attribs[FRAG_ATTRIB_COL0];
a199 1
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
d244 4
a247 6
   INIT_SPAN(span, GL_BITMAP, 0, 0, SPAN_RGBA);
   if (ctx->Depth.Test)
      _swrast_span_default_z(ctx, &span);
   if (swrast->_FogEnabled)
      _swrast_span_default_fog(ctx, &span);
   _swrast_span_default_secondary_color(ctx, &span);
a315 1
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
d328 3
a330 1
   INIT_SPAN(span, GL_BITMAP, 0, 0, SPAN_INDEX);
a353 5
   if (ctx->Depth.Test)
      _swrast_span_default_z(ctx, &span);
   if (swrast->_FogEnabled)
      _swrast_span_default_fog(ctx, &span);

a448 1
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
d463 3
a465 1
   INIT_SPAN(span, GL_BITMAP, 0, 0, SPAN_Z);
a488 5
   _swrast_span_default_color(ctx, &span);
   _swrast_span_default_secondary_color(ctx, &span);
   if (swrast->_FogEnabled)
      _swrast_span_default_fog(ctx, &span);

d833 1
a833 1
      if (dstFb->_NumColorDrawBuffers[0] != 1)
d836 1
a836 1
      dstRb = dstFb->_ColorDrawBuffers[0][0];
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * Version:  6.5.1
d5 1
a5 1
 * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
d44 1
a44 1
/*
d49 1
d74 6
a79 1
      if ((srcx > dstx + (width * zoomX) + 1) || (srcx + width + 1 < dstx)) {
d83 1
d87 1
a97 35
 * Convert GLfloat[n][4] colors to GLchan[n][4].
 * XXX maybe move into image.c
 */
static void
float_span_to_chan(GLuint n, CONST GLfloat in[][4], GLchan out[][4])
{
   GLuint i;
   for (i = 0; i < n; i++) {
      UNCLAMPED_FLOAT_TO_CHAN(out[i][RCOMP], in[i][RCOMP]);
      UNCLAMPED_FLOAT_TO_CHAN(out[i][GCOMP], in[i][GCOMP]);
      UNCLAMPED_FLOAT_TO_CHAN(out[i][BCOMP], in[i][BCOMP]);
      UNCLAMPED_FLOAT_TO_CHAN(out[i][ACOMP], in[i][ACOMP]);
   }
}


/**
 * Convert GLchan[n][4] colors to GLfloat[n][4].
 * XXX maybe move into image.c
 */
static void
chan_span_to_float(GLuint n, CONST GLchan in[][4], GLfloat out[][4])
{
   GLuint i;
   for (i = 0; i < n; i++) {
      out[i][RCOMP] = CHAN_TO_FLOAT(in[i][RCOMP]);
      out[i][GCOMP] = CHAN_TO_FLOAT(in[i][GCOMP]);
      out[i][BCOMP] = CHAN_TO_FLOAT(in[i][BCOMP]);
      out[i][ACOMP] = CHAN_TO_FLOAT(in[i][ACOMP]);
   }
}



/*
a104 2
   struct gl_renderbuffer *drawRb = NULL;
   GLboolean quick_draw;
d107 3
a109 1
   const GLuint transferOps = ctx->_ImageTransferState;
d111 1
a111 1
   struct sw_span span;
d119 1
a119 12


   if (SWRAST_CONTEXT(ctx)->_RasterMask == 0
       && !zoom
       && destx >= 0
       && destx + width <= (GLint) ctx->DrawBuffer->Width) {
      quick_draw = GL_TRUE;
      drawRb = ctx->DrawBuffer->_ColorDrawBuffers[0][0];
   }
   else {
      quick_draw = GL_FALSE;
   }
d134 1
a134 1
   /* read source image */
a136 2
      GLchan rgba[MAX_WIDTH][4];
      /* Read GLchan and convert to GLfloat */
d138 1
a138 3
                             width, srcx, srcy + row, rgba);
      chan_span_to_float(width, (CONST GLchan (*)[4]) rgba,
                         (GLfloat (*)[4]) dest);
d168 5
a172 4
   /* write the new image */
   for (row = 0; row < height; row++) {
      const GLfloat *src = convImage + row * width * 4;
      GLint dy;
d174 2
a175 2
      /* convert floats back to chan */
      float_span_to_chan(width, (const GLfloat (*)[4]) src, span.array->rgba);
d177 1
a177 6
      /* write row to framebuffer */
      dy = desty + row;
      if (quick_draw && dy >= 0 && dy < (GLint) ctx->DrawBuffer->Height) {
         drawRb->PutRow(ctx, drawRb, width, destx, dy, span.array->rgba, NULL);
      }
      else {
d179 1
a179 1
         span.y = dy;
d181 1
d183 1
a183 2
            _swrast_write_zoomed_rgba_span(ctx, destx, desty, &span, 
                                        (CONST GLchan (*)[4])span.array->rgba);
d189 2
d197 1
a197 1
/*
d205 2
a206 4
   struct gl_renderbuffer *drawRb;
   GLchan *tmpImage,*p;
   GLboolean quick_draw;
   GLint sy, dy, stepy, j;
d209 2
a210 2
   const GLuint transferOps = ctx->_ImageTransferState;
   struct sw_span span;
a216 2
   INIT_SPAN(span, GL_BITMAP, 0, 0, SPAN_RGBA);

d221 13
d236 1
a236 1
   if (srcy < desty) {
d249 1
a249 8
   if (ctx->DrawBuffer == ctx->ReadBuffer) {
      overlapping = regions_overlap(srcx, srcy, destx, desty, width, height,
                                    ctx->Pixel.ZoomX, ctx->Pixel.ZoomY);
   }
   else {
      overlapping = GL_FALSE;
   }

d254 1
a254 12

   if (SWRAST_CONTEXT(ctx)->_RasterMask == 0
       && !zoom
       && destx >= 0
       && destx + width <= (GLint) ctx->DrawBuffer->Width) {
      quick_draw = GL_TRUE;
      drawRb = ctx->DrawBuffer->_ColorDrawBuffers[0][0];
   }
   else {
      quick_draw = GL_FALSE;
      drawRb = NULL;
   }
d257 1
a257 2
      GLint ssy = sy;
      tmpImage = (GLchan *) _mesa_malloc(width * height * sizeof(GLchan) * 4);
d262 1
a262 1
      /* read the source image */
d264 1
a264 1
      for (j = 0; j < height; j++, ssy += stepy) {
d266 1
a266 1
                                 width, srcx, ssy, (GLchan (*)[4]) p );
d276 6
a281 2
   for (j = 0; j < height; j++, sy += stepy, dy += stepy) {
      /* Get source pixels */
d284 1
a284 2
         ASSERT(width < MAX_WIDTH);
         _mesa_memcpy(span.array->rgba, p, width * sizeof(GLchan) * 4);
a288 1
         ASSERT(width < MAX_WIDTH);
d290 1
a290 1
                                 width, srcx, sy, span.array->rgba );
d294 2
a295 7
         GLfloat rgbaFloat[MAX_WIDTH][4];
         /* convert to float, transfer, convert back to chan */
         chan_span_to_float(width, (CONST GLchan (*)[4]) span.array->rgba,
                            rgbaFloat);
         _mesa_apply_rgba_transfer_ops(ctx, transferOps, width, rgbaFloat);
         float_span_to_chan(width, (CONST GLfloat (*)[4]) rgbaFloat,
                            span.array->rgba);
d299 6
a304 2
      if (quick_draw && dy >= 0 && dy < (GLint) ctx->DrawBuffer->Height) {
         drawRb->PutRow(ctx, drawRb, width, destx, dy, span.array->rgba, NULL);
d307 1
a307 10
         span.x = destx;
         span.y = dy;
         span.end = width;
         if (zoom) {
            _swrast_write_zoomed_rgba_span(ctx, destx, desty, &span,
                                       (CONST GLchan (*)[4]) span.array->rgba);
         }
         else {
            _swrast_write_rgba_span(ctx, &span);
         }
d311 2
a327 1
   const GLboolean shift_or_offset = ctx->Pixel.IndexShift || ctx->Pixel.IndexOffset;
d329 1
a329 1
   struct sw_span span;
d338 8
d347 1
a347 1
   if (srcy<desty) {
a359 8
   if (ctx->DrawBuffer == ctx->ReadBuffer) {
      overlapping = regions_overlap(srcx, srcy, destx, desty, width, height,
                                    ctx->Pixel.ZoomX, ctx->Pixel.ZoomY);
   }
   else {
      overlapping = GL_FALSE;
   }

d397 3
a399 7
      /* Apply shift, offset, look-up table */
      if (shift_or_offset) {
         _mesa_shift_and_offset_ci( ctx, width, span.array->index );
      }
      if (ctx->Pixel.MapColorFlag) {
         _mesa_map_ci( ctx, width, span.array->index );
      }
d468 1
a468 1
   struct sw_span span;
d477 8
d486 1
a486 1
   if (srcy<desty) {
a498 8
   if (ctx->DrawBuffer == ctx->ReadBuffer) {
      overlapping = regions_overlap(srcx, srcy, destx, desty, width, height,
                                    ctx->Pixel.ZoomX, ctx->Pixel.ZoomY);
   }
   else {
      overlapping = GL_FALSE;
   }

d500 1
d543 1
a543 2
            _swrast_write_zoomed_rgba_span(ctx, destx, desty, &span, 
                                       (const GLchan (*)[4]) span.array->rgba);
d549 1
a549 1
            _swrast_write_zoomed_index_span(ctx, destx, desty, &span);
a571 1
   const GLboolean shift_or_offset = ctx->Pixel.IndexShift || ctx->Pixel.IndexOffset;
d579 8
d588 1
a588 1
   if (srcy < desty) {
a600 8
   if (ctx->DrawBuffer == ctx->ReadBuffer) {
      overlapping = regions_overlap(srcx, srcy, destx, desty, width, height,
                                    ctx->Pixel.ZoomX, ctx->Pixel.ZoomY);
   }
   else {
      overlapping = GL_FALSE;
   }

d632 1
a632 7
      /* Apply shift, offset, look-up table */
      if (shift_or_offset) {
         _mesa_shift_and_offset_stencil( ctx, width, stencil );
      }
      if (ctx->Pixel.MapStencilFlag) {
         _mesa_map_stencil( ctx, width, stencil );
      }
a667 2
   const GLboolean shiftOrOffset
      = ctx->Pixel.IndexShift || ctx->Pixel.IndexOffset;
d680 8
d689 1
a689 1
   if (srcY < destY) {
a701 8
   if (ctx->DrawBuffer == ctx->ReadBuffer) {
      overlapping = regions_overlap(srcX, srcY, destX, destY, width, height,
                                    ctx->Pixel.ZoomX, ctx->Pixel.ZoomY);
   }
   else {
      overlapping = GL_FALSE;
   }

d757 1
a757 7
         /* Apply shift, offset, look-up table */
         if (shiftOrOffset) {
            _mesa_shift_and_offset_stencil(ctx, width, stencil);
         }
         if (ctx->Pixel.MapStencilFlag) {
            _mesa_map_stencil(ctx, width, stencil);
         }
d825 82
d922 21
a942 7
   switch (type) {
   case GL_COLOR:
      if (ctx->Visual.rgbMode) {
         copy_rgba_pixels( ctx, srcx, srcy, width, height, destx, desty );
      }
      else {
         copy_ci_pixels( ctx, srcx, srcy, width, height, destx, desty );
a943 12
      break;
   case GL_DEPTH:
      copy_depth_pixels( ctx, srcx, srcy, width, height, destx, desty );
      break;
   case GL_STENCIL:
      copy_stencil_pixels( ctx, srcx, srcy, width, height, destx, desty );
      break;
   case GL_DEPTH_STENCIL_EXT:
      copy_depth_stencil_pixels(ctx, srcx, srcy, width, height, destx, desty);
      break;
   default:
      _mesa_problem(ctx, "unexpected type in _swrast_CopyPixels");
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d3 1
a3 1
 * Version:  6.5.2
d44 1
a44 1
/**
a48 1
 * \return GL_TRUE if the regions overlap, GL_FALSE otherwise.
d90 35
d132 2
d136 1
a136 3
   const GLbitfield transferOps = ctx->_ImageTransferState;
   const GLboolean sink = (ctx->Pixel.MinMaxEnabled && ctx->MinMax.Sink)
      || (ctx->Pixel.HistogramEnabled && ctx->Histogram.Sink);
d138 1
a138 1
   SWspan span;
d148 11
d172 1
a172 1
   /* read source image as float/RGBA */
d175 2
d178 3
a180 1
                             width, srcx, srcy + row, GL_FLOAT, dest);
d210 4
a213 5
   if (!sink) {
      /* write the new image */
      for (row = 0; row < height; row++) {
         const GLfloat *src = convImage + row * width * 4;
         GLvoid *rgba = span.array->color.sz1.rgba; /* row storage */
d215 2
a216 2
         /* copy convolved colors into span array */
         _mesa_memcpy(rgba, src, width * 4 * sizeof(GLfloat));
d218 6
a223 1
         /* write span */
d225 1
a225 1
         span.y = desty + row;
a226 1
         span.array->ChanType = GL_FLOAT;
d228 2
a229 1
            _swrast_write_zoomed_rgba_span(ctx, destx, desty, &span, rgba);
a234 2
      /* restore this */
      span.array->ChanType = CHAN_TYPE;
d241 1
a241 1
/**
d249 4
a252 2
   GLfloat *tmpImage, *p;
   GLint sy, dy, stepy, row;
d256 1
a256 1
   SWspan span;
d263 2
a291 1
   INIT_SPAN(span, GL_BITMAP, 0, 0, SPAN_RGBA);
d297 12
d310 2
a311 1
      tmpImage = (GLfloat *) _mesa_malloc(width * height * sizeof(GLfloat) * 4);
d316 1
a316 1
      /* read the source image as RGBA/float */
d318 1
a318 1
      for (row = 0; row < height; row++) {
d320 1
a320 1
                                 width, srcx, sy + row, GL_FLOAT, p );
d330 2
a331 6
   ASSERT(width < MAX_WIDTH);

   for (row = 0; row < height; row++, sy += stepy, dy += stepy) {
      GLvoid *rgba = span.array->color.sz4.rgba;

      /* Get row/span of source pixels */
d334 2
a335 1
         _mesa_memcpy(rgba, p, width * sizeof(GLfloat) * 4);
d340 1
d342 1
a342 1
                                 width, srcx, sy, GL_FLOAT, rgba );
d346 7
a352 2
         _mesa_apply_rgba_transfer_ops(ctx, transferOps, width,
                                       (GLfloat (*)[4]) rgba);
d356 2
a357 6
      span.x = destx;
      span.y = dy;
      span.end = width;
      span.array->ChanType = GL_FLOAT;
      if (zoom) {
         _swrast_write_zoomed_rgba_span(ctx, destx, desty, &span, rgba);
d360 10
a369 1
         _swrast_write_rgba_span(ctx, &span);
a372 2
   span.array->ChanType = CHAN_TYPE; /* restore */

d388 1
d390 1
a390 1
   SWspan span;
d458 7
a464 3
      if (ctx->_ImageTransferState)
         _mesa_apply_ci_transfer_ops(ctx, ctx->_ImageTransferState,
                                     width, span.array->index);
d533 1
a533 1
   SWspan span;
d608 1
a608 1
                                           span.array->rgba);
d637 1
d698 7
a704 1
      _mesa_apply_stencil_transfer_ops(ctx, width, stencil);
d740 2
d831 7
a837 1
         _mesa_apply_stencil_transfer_ops(ctx, width, stencil);
a904 82

/**
 * Try to do a fast copy pixels.
 */
static GLboolean
fast_copy_pixels(GLcontext *ctx,
                 GLint srcX, GLint srcY, GLsizei width, GLsizei height,
                 GLint dstX, GLint dstY, GLenum type)
{
   struct gl_framebuffer *srcFb = ctx->ReadBuffer;
   struct gl_framebuffer *dstFb = ctx->DrawBuffer;
   struct gl_renderbuffer *srcRb, *dstRb;
   GLint row, yStep;

   if (SWRAST_CONTEXT(ctx)->_RasterMask != 0x0 ||
       ctx->Pixel.ZoomX != 1.0F ||
       ctx->Pixel.ZoomY != 1.0F ||
       ctx->_ImageTransferState) {
      /* can't handle these */
      return GL_FALSE;
   }

   if (type == GL_COLOR) {
      if (dstFb->_NumColorDrawBuffers[0] != 1)
         return GL_FALSE;
      srcRb = srcFb->_ColorReadBuffer;
      dstRb = dstFb->_ColorDrawBuffers[0][0];
   }
   else if (type == GL_STENCIL) {
      srcRb = srcFb->_StencilBuffer;
      dstRb = dstFb->_StencilBuffer;
   }
   else if (type == GL_DEPTH) {
      srcRb = srcFb->_DepthBuffer;
      dstRb = dstFb->_DepthBuffer;
   }
   else {
      ASSERT(type == GL_DEPTH_STENCIL_EXT);
      /* XXX correct? */
      srcRb = srcFb->Attachment[BUFFER_DEPTH].Renderbuffer;
      dstRb = dstFb->Attachment[BUFFER_DEPTH].Renderbuffer;
   }

   /* src and dst renderbuffers must be same format and type */
   if (!srcRb || !dstRb ||
       srcRb->DataType != dstRb->DataType ||
       srcRb->_BaseFormat != dstRb->_BaseFormat) {
      return GL_FALSE;
   }

   /* clipping not supported */
   if (srcX < 0 || srcX + width > srcFb->Width ||
       srcY < 0 || srcY + height > srcFb->Height ||
       dstX < dstFb->_Xmin || dstX + width > dstFb->_Xmax ||
       dstY < dstFb->_Ymin || dstY + height > dstFb->_Ymax) {
      return GL_FALSE;
   }

   /* overlapping src/dst doesn't matter, just determine Y direction */
   if (srcY < dstY) {
      /* top-down  max-to-min */
      srcY = srcY + height - 1;
      dstY = dstY + height - 1;
      yStep = -1;
   }
   else {
      /* bottom-up  min-to-max */
      yStep = 1;
   }

   for (row = 0; row < height; row++) {
      GLuint temp[MAX_WIDTH][4];
      srcRb->GetRow(ctx, srcRb, width, srcX, srcY, temp);
      dstRb->PutRow(ctx, dstRb, width, dstX, dstY, temp, NULL);
      srcY += yStep;
      dstY += yStep;
   }

   return GL_TRUE;
}


d920 7
a926 21
   if (!fast_copy_pixels(ctx, srcx, srcy, width, height, destx, desty, type)) {
      switch (type) {
      case GL_COLOR:
         if (ctx->Visual.rgbMode) {
            copy_rgba_pixels( ctx, srcx, srcy, width, height, destx, desty );
         }
         else {
            copy_ci_pixels( ctx, srcx, srcy, width, height, destx, desty );
         }
         break;
      case GL_DEPTH:
         copy_depth_pixels( ctx, srcx, srcy, width, height, destx, desty );
         break;
      case GL_STENCIL:
         copy_stencil_pixels( ctx, srcx, srcy, width, height, destx, desty );
         break;
      case GL_DEPTH_STENCIL_EXT:
         copy_depth_stencil_pixels(ctx, srcx, srcy, width, height, destx, desty);
         break;
      default:
         _mesa_problem(ctx, "unexpected type in _swrast_CopyPixels");
d928 12
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d3 1
a3 1
 * Version:  6.5.3
d5 1
a5 1
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
d112 1
a112 1
   _swrast_span_default_secondary_color(ctx, &span);
d165 1
a165 1
         GLvoid *rgba = (GLvoid *) span.array->attribs[FRAG_ATTRIB_COL0];
d202 1
a202 1
   GLuint transferOps = ctx->_ImageTransferState;
a213 13
   else if (ctx->Pixel.Convolution1DEnabled) {
      /* make sure we don't apply 1D convolution */
      transferOps &= ~(IMAGE_CONVOLUTION_BIT |
                       IMAGE_POST_CONVOLUTION_SCALE_BIAS);
   }

   if (ctx->DrawBuffer == ctx->ReadBuffer) {
      overlapping = regions_overlap(srcx, srcy, destx, desty, width, height,
                                    ctx->Pixel.ZoomX, ctx->Pixel.ZoomY);
   }
   else {
      overlapping = GL_FALSE;
   }
d216 1
a216 1
   if (!overlapping && srcy < desty) {
d229 8
a241 1
   _swrast_span_default_secondary_color(ctx, &span);
d266 1
a266 1
      GLvoid *rgba = span.array->attribs[FRAG_ATTRIB_COL0];
a324 8
   if (ctx->DrawBuffer == ctx->ReadBuffer) {
      overlapping = regions_overlap(srcx, srcy, destx, desty, width, height,
                                    ctx->Pixel.ZoomX, ctx->Pixel.ZoomY);
   }
   else {
      overlapping = GL_FALSE;
   }

d326 1
a326 1
   if (!overlapping && srcy < desty) {
d339 8
a463 8
   if (ctx->DrawBuffer == ctx->ReadBuffer) {
      overlapping = regions_overlap(srcx, srcy, destx, desty, width, height,
                                    ctx->Pixel.ZoomX, ctx->Pixel.ZoomY);
   }
   else {
      overlapping = GL_FALSE;
   }

d465 1
a465 1
   if (!overlapping && srcy < desty) {
d478 8
a486 1
   _swrast_span_default_secondary_color(ctx, &span);
d529 2
a530 1
            _swrast_write_zoomed_depth_span(ctx, destx, desty, &span);
d536 1
a536 1
            _swrast_write_zoomed_depth_span(ctx, destx, desty, &span);
a565 8
   if (ctx->DrawBuffer == ctx->ReadBuffer) {
      overlapping = regions_overlap(srcx, srcy, destx, desty, width, height,
                                    ctx->Pixel.ZoomX, ctx->Pixel.ZoomY);
   }
   else {
      overlapping = GL_FALSE;
   }

d567 1
a567 1
   if (!overlapping && srcy < desty) {
d580 8
a666 8
   if (ctx->DrawBuffer == ctx->ReadBuffer) {
      overlapping = regions_overlap(srcX, srcY, destX, destY, width, height,
                                    ctx->Pixel.ZoomX, ctx->Pixel.ZoomY);
   }
   else {
      overlapping = GL_FALSE;
   }

d668 1
a668 1
   if (!overlapping && srcY < destY) {
d681 8
d863 2
a864 2
   if (srcX < 0 || srcX + width > (GLint) srcFb->Width ||
       srcY < 0 || srcY + height > (GLint) srcFb->Height ||
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d3 1
a3 1
 * Version:  7.1
d26 9
a34 7
#include "main/glheader.h"
#include "main/context.h"
#include "main/colormac.h"
#include "main/condrender.h"
#include "main/macros.h"
#include "main/pixeltransfer.h"
#include "main/imports.h"
d74 1
a74 6
      if (srcx > (dstx + ((zoomX > 0.0F) ? (width * zoomX + 1.0F) : 0.0F))) {
         /* src is completely right of dest */
         return GL_FALSE;
      }
      else if (srcx + width + 1.0F < dstx + ((zoomX > 0.0F) ? 0.0F : (width * zoomX))) {
         /* src is completely left of dest */
a77 1
         /* src is completely below dest */
a80 1
         /* src is completely above dest */
d91 100
d194 1
a194 1
copy_rgba_pixels(struct gl_context *ctx, GLint srcx, GLint srcy,
d197 1
d210 10
d242 6
a247 4
   INIT_SPAN(span, GL_BITMAP);
   _swrast_span_default_attribs(ctx, &span);
   span.arrayMask = SPAN_RGBA;
   span.arrayAttribs = FRAG_BIT_COL0; /* we'll fill in COL0 attrib values */
d250 1
a250 1
      tmpImage = (GLfloat *) malloc(width * height * sizeof(GLfloat) * 4);
d277 1
a277 1
         memcpy(rgba, p, width * sizeof(GLfloat) * 4);
d307 99
a405 1
      free(tmpImage);
d414 1
a414 1
scale_and_bias_z(struct gl_context *ctx, GLuint width,
d449 1
a449 1
copy_depth_pixels( struct gl_context *ctx, GLint srcx, GLint srcy,
d453 1
d468 1
a468 3
   INIT_SPAN(span, GL_BITMAP);
   _swrast_span_default_attribs(ctx, &span);
   span.arrayMask = SPAN_Z;
d492 5
d499 1
a499 1
      tmpImage = (GLfloat *) malloc(width * height * sizeof(GLfloat));
d520 1
a520 1
         memcpy(depth, p, width * sizeof(GLfloat));
d534 12
a545 4
      if (zoom)
         _swrast_write_zoomed_depth_span(ctx, destx, desty, &span);
      else
         _swrast_write_rgba_span(ctx, &span);
d549 1
a549 1
      free(tmpImage);
d555 1
a555 1
copy_stencil_pixels( struct gl_context *ctx, GLint srcx, GLint srcy,
d596 1
a596 1
      tmpImage = (GLstencil *) malloc(width * height * sizeof(GLstencil));
d618 1
a618 1
         memcpy(stencil, p, width * sizeof(GLstencil));
d638 1
a638 1
      free(tmpImage);
d648 1
a648 1
copy_depth_stencil_pixels(struct gl_context *ctx,
d700 1
a700 1
            = (GLstencil *) malloc(width * height * sizeof(GLstencil));
d718 1
a718 1
            = (GLfloat *) malloc(width * height * sizeof(GLfloat));
d721 1
a721 1
            free(tempStencilImage);
d742 1
a742 1
            memcpy(stencil, stencilPtr, width * sizeof(GLstencil));
d771 1
a771 1
            memcpy(depth, depthPtr, width * sizeof(GLfloat));
d811 1
a811 1
      free(tempStencilImage);
d814 1
a814 1
      free(tempDepthImage);
d823 1
a823 1
fast_copy_pixels(struct gl_context *ctx,
d841 1
a841 1
      if (dstFb->_NumColorDrawBuffers != 1)
d844 1
a844 1
      dstRb = dstFb->_ColorDrawBuffers[0];
d905 1
a905 1
_swrast_CopyPixels( struct gl_context *ctx,
d910 1
a910 1
   swrast_render_start(ctx);
a911 3
   if (!_mesa_check_conditional_render(ctx))
      return; /* don't copy */

d918 6
a923 1
         copy_rgba_pixels( ctx, srcx, srcy, width, height, destx, desty );
d939 1
a939 1
   swrast_render_finish(ctx);
@


1.1.1.5
log
@Import Mesa 9.2.0
@
text
@d3 1
d20 3
a22 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
d139 1
a139 1
   span.arrayAttribs = VARYING_BIT_COL0; /* we'll fill in COL0 attrib values */
d142 1
a142 1
      tmpImage = malloc(width * height * sizeof(GLfloat) * 4);
d151 1
a151 1
                                 width, srcx, sy + row, p );
d161 1
a161 1
   ASSERT(width < SWRAST_MAX_WIDTH);
d164 1
a164 1
      GLvoid *rgba = span.array->attribs[VARYING_SLOT_COL0];
d175 1
a175 1
                                 width, srcx, sy, rgba );
d248 2
a249 2
   struct gl_renderbuffer *readRb = fb->Attachment[BUFFER_DEPTH].Renderbuffer;
   GLfloat *p, *tmpImage, *depth;
d289 1
a289 1
      tmpImage = malloc(width * height * sizeof(GLfloat));
a305 6
   depth = malloc(width * sizeof(GLfloat));
   if (!depth) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCopyPixels()");
      goto end;
   }

d307 1
a329 3
   free(depth);

end:
d342 1
a342 1
   struct gl_renderbuffer *rb = fb->Attachment[BUFFER_STENCIL].Renderbuffer;
d345 1
a345 1
   GLubyte *p, *tmpImage, *stencil;
d378 1
a378 1
      tmpImage = malloc(width * height * sizeof(GLubyte));
d395 2
a396 5
   stencil = malloc(width * sizeof(GLubyte));
   if (!stencil) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCopyPixels()");
      goto end;
   }
a397 1
   for (j = 0; j < height; j++, sy += stepy, dy += stepy) {
d400 1
a400 1
         memcpy(stencil, p, width * sizeof(GLubyte));
a418 3
   free(stencil);

end:
d425 3
a427 2
 * Try to do a fast 1:1 blit with memcpy.
 * \return GL_TRUE if successful, GL_FALSE otherwise.
d429 179
a607 4
GLboolean
swrast_fast_copy_pixels(struct gl_context *ctx,
			GLint srcX, GLint srcY, GLsizei width, GLsizei height,
			GLint dstX, GLint dstY, GLenum type)
d612 9
a620 4
   GLint row;
   GLuint pixelBytes, widthInBytes;
   GLubyte *srcMap, *dstMap;
   GLint srcRowStride, dstRowStride;
d629 2
a630 2
      srcRb = srcFb->Attachment[BUFFER_STENCIL].Renderbuffer;
      dstRb = dstFb->Attachment[BUFFER_STENCIL].Renderbuffer;
d633 2
a634 2
      srcRb = srcFb->Attachment[BUFFER_DEPTH].Renderbuffer;
      dstRb = dstFb->Attachment[BUFFER_DEPTH].Renderbuffer;
d643 4
a646 2
   /* src and dst renderbuffers must be same format */
   if (!srcRb || !dstRb || srcRb->Format != dstRb->Format) {
a649 13
   if (type == GL_STENCIL || type == GL_DEPTH_COMPONENT) {
      /* can't handle packed depth+stencil here */
      if (_mesa_is_format_packed_depth_stencil(srcRb->Format) ||
          _mesa_is_format_packed_depth_stencil(dstRb->Format))
         return GL_FALSE;
   }
   else if (type == GL_DEPTH_STENCIL) {
      /* can't handle separate depth/stencil buffers */
      if (srcRb != srcFb->Attachment[BUFFER_STENCIL].Renderbuffer ||
          dstRb != dstFb->Attachment[BUFFER_STENCIL].Renderbuffer)
         return GL_FALSE;
   }

d658 6
a663 36
   pixelBytes = _mesa_get_format_bytes(srcRb->Format);
   widthInBytes = width * pixelBytes;

   if (srcRb == dstRb) {
      /* map whole buffer for read/write */
      /* XXX we could be clever and just map the union region of the
       * source and dest rects.
       */
      GLubyte *map;
      GLint rowStride;

      ctx->Driver.MapRenderbuffer(ctx, srcRb, 0, 0,
                                  srcRb->Width, srcRb->Height,
                                  GL_MAP_READ_BIT | GL_MAP_WRITE_BIT,
                                  &map, &rowStride);
      if (!map) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCopyPixels");
         return GL_TRUE; /* don't retry with slow path */
      }

      srcMap = map + srcY * rowStride + srcX * pixelBytes;
      dstMap = map + dstY * rowStride + dstX * pixelBytes;

      /* this handles overlapping copies */
      if (srcY < dstY) {
         /* copy in reverse (top->down) order */
         srcMap += rowStride * (height - 1);
         dstMap += rowStride * (height - 1);
         srcRowStride = -rowStride;
         dstRowStride = -rowStride;
      }
      else {
         /* copy in normal (bottom->up) order */
         srcRowStride = rowStride;
         dstRowStride = rowStride;
      }
d666 2
a667 16
      /* different src/dst buffers */
      ctx->Driver.MapRenderbuffer(ctx, srcRb, srcX, srcY,
                                  width, height,
                                  GL_MAP_READ_BIT, &srcMap, &srcRowStride);
      if (!srcMap) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCopyPixels");
         return GL_TRUE; /* don't retry with slow path */
      }
      ctx->Driver.MapRenderbuffer(ctx, dstRb, dstX, dstY,
                                  width, height,
                                  GL_MAP_WRITE_BIT, &dstMap, &dstRowStride);
      if (!dstMap) {
         ctx->Driver.UnmapRenderbuffer(ctx, srcRb);
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCopyPixels");
         return GL_TRUE; /* don't retry with slow path */
      }
d671 5
a675 9
      /* memmove() in case of overlap */
      memmove(dstMap, srcMap, widthInBytes);
      dstMap += dstRowStride;
      srcMap += srcRowStride;
   }

   ctx->Driver.UnmapRenderbuffer(ctx, srcRb);
   if (dstRb != srcRb) {
      ctx->Driver.UnmapRenderbuffer(ctx, dstRb);
a682 43
 * Find/map the renderbuffer that we'll be reading from.
 * The swrast_render_start() function only maps the drawing buffers,
 * not the read buffer.
 */
static struct gl_renderbuffer *
map_readbuffer(struct gl_context *ctx, GLenum type)
{
   struct gl_framebuffer *fb = ctx->ReadBuffer;
   struct gl_renderbuffer *rb;
   struct swrast_renderbuffer *srb;

   switch (type) {
   case GL_COLOR:
      rb = fb->Attachment[fb->_ColorReadBufferIndex].Renderbuffer;
      break;
   case GL_DEPTH:
   case GL_DEPTH_STENCIL:
      rb = fb->Attachment[BUFFER_DEPTH].Renderbuffer;
      break;
   case GL_STENCIL:
      rb = fb->Attachment[BUFFER_STENCIL].Renderbuffer;
      break;
   default:
      return NULL;
   }

   srb = swrast_renderbuffer(rb);

   if (!srb || srb->Map) {
      /* no buffer, or buffer is mapped already, we're done */
      return NULL;
   }

   ctx->Driver.MapRenderbuffer(ctx, rb,
                               0, 0, rb->Width, rb->Height,
                               GL_MAP_READ_BIT,
                               &srb->Map, &srb->RowStride);

   return rb;
}


/**
d692 1
a692 1
   struct gl_renderbuffer *rb;
d700 17
a716 30
   if (!(SWRAST_CONTEXT(ctx)->_RasterMask != 0x0 ||
	 ctx->Pixel.ZoomX != 1.0F ||
	 ctx->Pixel.ZoomY != 1.0F ||
	 ctx->_ImageTransferState) &&
       swrast_fast_copy_pixels(ctx, srcx, srcy, width, height, destx, desty,
			       type)) {
      /* all done */
      return;
   }

   swrast_render_start(ctx);
   rb = map_readbuffer(ctx, type);

   switch (type) {
   case GL_COLOR:
      copy_rgba_pixels( ctx, srcx, srcy, width, height, destx, desty );
      break;
   case GL_DEPTH:
      copy_depth_pixels( ctx, srcx, srcy, width, height, destx, desty );
      break;
   case GL_STENCIL:
      copy_stencil_pixels( ctx, srcx, srcy, width, height, destx, desty );
      break;
   case GL_DEPTH_STENCIL_EXT:
      /* Copy buffers separately (if the fast copy path wasn't taken) */
      copy_depth_pixels(ctx, srcx, srcy, width, height, destx, desty);
      copy_stencil_pixels(ctx, srcx, srcy, width, height, destx, desty);
      break;
   default:
      _mesa_problem(ctx, "unexpected type in _swrast_CopyPixels");
a719 6

   if (rb) {
      struct swrast_renderbuffer *srb = swrast_renderbuffer(rb);
      ctx->Driver.UnmapRenderbuffer(ctx, rb);
      srb->Map = NULL;
   }
@


