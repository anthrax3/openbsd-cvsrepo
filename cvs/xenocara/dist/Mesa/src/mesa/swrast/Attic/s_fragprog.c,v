head	1.10;
access;
symbols
	OPENBSD_5_8:1.9.0.6
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.4
	OPENBSD_5_7_BASE:1.9
	v10_2_9:1.1.1.4
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.4
	OPENBSD_5_6:1.9.0.2
	OPENBSD_5_6_BASE:1.9
	v10_2_3:1.1.1.4
	OPENBSD_5_5:1.8.0.2
	OPENBSD_5_5_BASE:1.8
	v9_2_5:1.1.1.3
	v9_2_3:1.1.1.3
	v9_2_2:1.1.1.3
	v9_2_1:1.1.1.3
	v9_2_0:1.1.1.3
	OPENBSD_5_4:1.7.0.4
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.6.0.4
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	v7_10_3:1.1.1.2
	OPENBSD_5_0:1.5.0.6
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.2
	v7_0_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2015.12.23.05.17.55;	author jsg;	state dead;
branches;
next	1.9;
commitid	TnlogFl9nOv2eaRf;

1.9
date	2014.07.09.21.09.01;	author jsg;	state Exp;
branches;
next	1.8;
commitid	WPD6rgPryPkvXOr9;

1.8
date	2013.09.05.14.06.49;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2012.08.17.13.58.20;	author mpi;	state Exp;
branches;
next	1.6;

1.6
date	2011.10.23.13.37.45;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.05.22.20.06.34;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.05.17.20.26.42;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.14.58.23;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.05.31.16.36.49;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.24.17.32.09;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.11.24.17.32.09;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2011.10.23.13.29.48;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2013.09.05.13.17.30;	author jsg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.07.09.20.35.12;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.10
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#include "main/glheader.h"
#include "main/colormac.h"
#include "main/samplerobj.h"
#include "program/prog_instruction.h"

#include "s_context.h"
#include "s_fragprog.h"
#include "s_span.h"

/**
 * \brief Should swrast use a fragment program?
 *
 * \return true if the current fragment program exists and is not the fixed
 *         function fragment program
 */
GLboolean
_swrast_use_fragment_program(struct gl_context *ctx)
{
   struct gl_fragment_program *fp = ctx->FragmentProgram._Current;
   return fp && !(fp == ctx->FragmentProgram._TexEnvProgram
                  && fp->Base.NumInstructions == 0);
}

/**
 * Apply texture object's swizzle (X/Y/Z/W/0/1) to incoming 'texel'
 * and return results in 'colorOut'.
 */
static inline void
swizzle_texel(const GLfloat texel[4], GLfloat colorOut[4], GLuint swizzle)
{
   if (swizzle == SWIZZLE_NOOP) {
      COPY_4V(colorOut, texel);
   }
   else {
      GLfloat vector[6];
      vector[SWIZZLE_X] = texel[0];
      vector[SWIZZLE_Y] = texel[1];
      vector[SWIZZLE_Z] = texel[2];
      vector[SWIZZLE_W] = texel[3];
      vector[SWIZZLE_ZERO] = 0.0F;
      vector[SWIZZLE_ONE] = 1.0F;
      colorOut[0] = vector[GET_SWZ(swizzle, 0)];
      colorOut[1] = vector[GET_SWZ(swizzle, 1)];
      colorOut[2] = vector[GET_SWZ(swizzle, 2)];
      colorOut[3] = vector[GET_SWZ(swizzle, 3)];
   }
}


/**
 * Fetch a texel with given lod.
 * Called via machine->FetchTexelLod()
 */
static void
fetch_texel_lod( struct gl_context *ctx, const GLfloat texcoord[4], GLfloat lambda,
                 GLuint unit, GLfloat color[4] )
{
   const struct gl_texture_object *texObj = ctx->Texture.Unit[unit]._Current;

   if (texObj) {
      SWcontext *swrast = SWRAST_CONTEXT(ctx);
      GLfloat rgba[4];
      const struct gl_sampler_object *samp = _mesa_get_samplerobj(ctx, unit);

      lambda = CLAMP(lambda, samp->MinLod, samp->MaxLod);

      swrast->TextureSample[unit](ctx, samp, ctx->Texture.Unit[unit]._Current,
                                  1, (const GLfloat (*)[4]) texcoord,
                                  &lambda, &rgba);
      swizzle_texel(rgba, color, texObj->_Swizzle);
   }
   else {
      ASSIGN_4V(color, 0.0F, 0.0F, 0.0F, 1.0F);
   }
}


/**
 * Fetch a texel with the given partial derivatives to compute a level
 * of detail in the mipmap.
 * Called via machine->FetchTexelDeriv()
 * \param lodBias  the lod bias which may be specified by a TXB instruction,
 *                 otherwise zero.
 */
static void
fetch_texel_deriv( struct gl_context *ctx, const GLfloat texcoord[4],
                   const GLfloat texdx[4], const GLfloat texdy[4],
                   GLfloat lodBias, GLuint unit, GLfloat color[4] )
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
   const struct gl_texture_unit *texUnit = &ctx->Texture.Unit[unit];
   const struct gl_texture_object *texObj = texUnit->_Current;

   if (texObj) {
      const struct gl_texture_image *texImg =
         texObj->Image[0][texObj->BaseLevel];
      const struct swrast_texture_image *swImg =
         swrast_texture_image_const(texImg);
      const struct gl_sampler_object *samp = _mesa_get_samplerobj(ctx, unit);
      const GLfloat texW = (GLfloat) swImg->WidthScale;
      const GLfloat texH = (GLfloat) swImg->HeightScale;
      GLfloat lambda;
      GLfloat rgba[4];

      lambda = _swrast_compute_lambda(texdx[0], texdy[0], /* ds/dx, ds/dy */
                                      texdx[1], texdy[1], /* dt/dx, dt/dy */
                                      texdx[3], texdy[3], /* dq/dx, dq/dy */
                                      texW, texH,
                                      texcoord[0], texcoord[1], texcoord[3],
                                      1.0F / texcoord[3]);

      lambda += lodBias + texUnit->LodBias + samp->LodBias;

      lambda = CLAMP(lambda, samp->MinLod, samp->MaxLod);

      swrast->TextureSample[unit](ctx, samp, ctx->Texture.Unit[unit]._Current,
                                  1, (const GLfloat (*)[4]) texcoord,
                                  &lambda, &rgba);
      swizzle_texel(rgba, color, texObj->_Swizzle);
   }
   else {
      ASSIGN_4V(color, 0.0F, 0.0F, 0.0F, 1.0F);
   }
}


/**
 * Initialize the virtual fragment program machine state prior to running
 * fragment program on a fragment.  This involves initializing the input
 * registers, condition codes, etc.
 * \param machine  the virtual machine state to init
 * \param program  the fragment program we're about to run
 * \param span  the span of pixels we'll operate on
 * \param col  which element (column) of the span we'll operate on
 */
static void
init_machine(struct gl_context *ctx, struct gl_program_machine *machine,
             const struct gl_fragment_program *program,
             const SWspan *span, GLuint col)
{
   GLfloat *wpos = span->array->attribs[VARYING_SLOT_POS][col];

   /* ARB_fragment_coord_conventions */
   if (program->OriginUpperLeft)
      wpos[1] = ctx->DrawBuffer->Height - 1 - wpos[1];
   if (!program->PixelCenterInteger) {
      wpos[0] += 0.5F;
      wpos[1] += 0.5F;
   }

   /* Setup pointer to input attributes */
   machine->Attribs = span->array->attribs;

   machine->DerivX = (GLfloat (*)[4]) span->attrStepX;
   machine->DerivY = (GLfloat (*)[4]) span->attrStepY;
   machine->NumDeriv = VARYING_SLOT_MAX;

   machine->Samplers = program->Base.SamplerUnits;

   /* if running a GLSL program (not ARB_fragment_program) */
   if (ctx->_Shader->CurrentProgram[MESA_SHADER_FRAGMENT]) {
      /* Store front/back facing value */
      machine->Attribs[VARYING_SLOT_FACE][col][0] = 1.0F - span->facing;
   }

   machine->CurElement = col;

   /* init condition codes */
   machine->CondCodes[0] = COND_EQ;
   machine->CondCodes[1] = COND_EQ;
   machine->CondCodes[2] = COND_EQ;
   machine->CondCodes[3] = COND_EQ;

   /* init call stack */
   machine->StackDepth = 0;

   machine->FetchTexelLod = fetch_texel_lod;
   machine->FetchTexelDeriv = fetch_texel_deriv;
}


/**
 * Run fragment program on the pixels in span from 'start' to 'end' - 1.
 */
static void
run_program(struct gl_context *ctx, SWspan *span, GLuint start, GLuint end)
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
   const struct gl_fragment_program *program = ctx->FragmentProgram._Current;
   const GLbitfield64 outputsWritten = program->Base.OutputsWritten;
   struct gl_program_machine *machine = &swrast->FragProgMachine;
   GLuint i;

   for (i = start; i < end; i++) {
      if (span->array->mask[i]) {
         init_machine(ctx, machine, program, span, i);

         if (_mesa_execute_program(ctx, &program->Base, machine)) {

            /* Store result color */
	    if (outputsWritten & BITFIELD64_BIT(FRAG_RESULT_COLOR)) {
               COPY_4V(span->array->attribs[VARYING_SLOT_COL0][i],
                       machine->Outputs[FRAG_RESULT_COLOR]);
            }
            else {
               /* Multiple drawbuffers / render targets
                * Note that colors beyond 0 and 1 will overwrite other
                * attributes, such as FOGC, TEX0, TEX1, etc.  That's OK.
                */
               GLuint buf;
               for (buf = 0; buf < ctx->DrawBuffer->_NumColorDrawBuffers; buf++) {
                  if (outputsWritten & BITFIELD64_BIT(FRAG_RESULT_DATA0 + buf)) {
                     COPY_4V(span->array->attribs[VARYING_SLOT_COL0 + buf][i],
                             machine->Outputs[FRAG_RESULT_DATA0 + buf]);
                  }
               }
            }

            /* Store result depth/z */
            if (outputsWritten & BITFIELD64_BIT(FRAG_RESULT_DEPTH)) {
               const GLfloat depth = machine->Outputs[FRAG_RESULT_DEPTH][2];
               if (depth <= 0.0)
                  span->array->z[i] = 0;
               else if (depth >= 1.0)
                  span->array->z[i] = ctx->DrawBuffer->_DepthMax;
               else
                  span->array->z[i] =
                     (GLuint) (depth * ctx->DrawBuffer->_DepthMaxF + 0.5F);
            }
         }
         else {
            /* killed fragment */
            span->array->mask[i] = GL_FALSE;
            span->writeAll = GL_FALSE;
         }
      }
   }
}


/**
 * Execute the current fragment program for all the fragments
 * in the given span.
 */
void
_swrast_exec_fragment_program( struct gl_context *ctx, SWspan *span )
{
   const struct gl_fragment_program *program = ctx->FragmentProgram._Current;

   /* incoming colors should be floats */
   if (program->Base.InputsRead & VARYING_BIT_COL0) {
      ASSERT(span->array->ChanType == GL_FLOAT);
   }

   run_program(ctx, span, 0, span->end);

   if (program->Base.OutputsWritten & BITFIELD64_BIT(FRAG_RESULT_COLOR)) {
      span->interpMask &= ~SPAN_RGBA;
      span->arrayMask |= SPAN_RGBA;
   }

   if (program->Base.OutputsWritten & BITFIELD64_BIT(FRAG_RESULT_DEPTH)) {
      span->interpMask &= ~SPAN_Z;
      span->arrayMask |= SPAN_Z;
   }
}

@


1.9
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.8
log
@Merge Mesa 9.2.0
@
text
@d185 1
a185 1
   if (ctx->Shader.CurrentFragmentProgram) {
@


1.7
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a2 1
 * Version:  7.0.3
d19 4
a22 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
d27 1
d34 13
d52 1
a52 1
static INLINE void
d87 1
d89 1
a89 1
      lambda = CLAMP(lambda, texObj->Sampler.MinLod, texObj->Sampler.MaxLod);
d91 2
a92 2
      swrast->TextureSample[unit](ctx, texObj, 1,
                                  (const GLfloat (*)[4]) texcoord,
d121 5
a125 2
      const GLfloat texW = (GLfloat) texImg->WidthScale;
      const GLfloat texH = (GLfloat) texImg->HeightScale;
d136 1
a136 1
      lambda += lodBias + texUnit->LodBias + texObj->Sampler.LodBias;
d138 1
a138 1
      lambda = CLAMP(lambda, texObj->Sampler.MinLod, texObj->Sampler.MaxLod);
d140 2
a141 2
      swrast->TextureSample[unit](ctx, texObj, 1,
                                  (const GLfloat (*)[4]) texcoord,
d165 1
a165 6
   GLfloat *wpos = span->array->attribs[FRAG_ATTRIB_WPOS][col];

   if (program->Base.Target == GL_FRAGMENT_PROGRAM_NV) {
      /* Clear temporary registers (undefined for ARB_f_p) */
      memset(machine->Temporaries, 0, MAX_PROGRAM_TEMPS * 4 * sizeof(GLfloat));
   }
d180 1
a180 1
   machine->NumDeriv = FRAG_ATTRIB_MAX;
d187 1
a187 1
      machine->Attribs[FRAG_ATTRIB_FACE][col][0] = 1.0F - span->facing;
d226 1
a226 1
               COPY_4V(span->array->attribs[FRAG_ATTRIB_COL0][i],
d237 1
a237 1
                     COPY_4V(span->array->attribs[FRAG_ATTRIB_COL0 + buf][i],
d251 2
a252 1
                  span->array->z[i] = IROUND(depth * ctx->DrawBuffer->_DepthMaxF);
d275 1
a275 1
   if (program->Base.InputsRead & FRAG_BIT_COL0) {
@


1.6
log
@Merge Mesa 7.10.3
@
text
@d74 1
a74 1
      lambda = CLAMP(lambda, texObj->MinLod, texObj->MaxLod);
d118 1
a118 1
      lambda += lodBias + texUnit->LodBias + texObj->LodBias;
d120 1
a120 1
      lambda = CLAMP(lambda, texObj->MinLod, texObj->MaxLod);
@


1.5
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d27 1
a27 2
#include "main/context.h"
#include "shader/prog_instruction.h"
d29 1
d65 1
a65 1
fetch_texel_lod( GLcontext *ctx, const GLfloat texcoord[4], GLfloat lambda,
d95 1
a95 1
fetch_texel_deriv( GLcontext *ctx, const GLfloat texcoord[4],
d143 1
a143 1
init_machine(GLcontext *ctx, struct gl_program_machine *machine,
d172 1
a172 1
   if (ctx->Shader.CurrentProgram) {
d197 1
a197 1
run_program(GLcontext *ctx, SWspan *span, GLuint start, GLuint end)
d256 1
a256 1
_swrast_exec_fragment_program( GLcontext *ctx, SWspan *span )
@


1.4
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@a27 1
#include "main/texstate.h"
d35 26
d72 1
a72 1
      GLchan rgba[4];
a75 1
      /* XXX use a float-valued TextureSample routine here!!! */
d79 1
a79 4
      color[0] = CHAN_TO_FLOAT(rgba[0]);
      color[1] = CHAN_TO_FLOAT(rgba[1]);
      color[2] = CHAN_TO_FLOAT(rgba[2]);
      color[3] = CHAN_TO_FLOAT(rgba[3]);
d82 1
a82 2
      color[0] = color[1] = color[2] = 0.0F;
      color[3] = 1.0F;
d91 2
d100 2
a101 1
   const struct gl_texture_object *texObj = ctx->Texture.Unit[unit]._Current;
d109 1
a109 1
      GLchan rgba[4];
d113 1
a113 1
                                      texdx[3], texdy[2], /* dq/dx, dq/dy */
d116 3
a118 1
                                      1.0F / texcoord[3]) + lodBias;
a121 1
      /* XXX use a float-valued TextureSample routine here!!! */
d125 1
a125 4
      color[0] = CHAN_TO_FLOAT(rgba[0]);
      color[1] = CHAN_TO_FLOAT(rgba[1]);
      color[2] = CHAN_TO_FLOAT(rgba[2]);
      color[3] = CHAN_TO_FLOAT(rgba[3]);
d128 1
a128 2
      color[0] = color[1] = color[2] = 0.0F;
      color[3] = 1.0F;
d147 2
d151 9
a159 2
      _mesa_bzero(machine->Temporaries,
                  MAX_PROGRAM_TEMPS * 4 * sizeof(GLfloat));
d173 2
a174 3
      /* Store front/back facing value in register FOGC.Y */
      machine->Attribs[FRAG_ATTRIB_FOGC][col][1] = 1.0 - span->facing;
      /* Note FOGC.ZW is gl_PointCoord if drawing a sprite */
d201 1
a201 1
   const GLbitfield outputsWritten = program->Base.OutputsWritten;
d212 1
a212 1
            if (outputsWritten & (1 << FRAG_RESULT_COLR)) {
d214 1
a214 1
                       machine->Outputs[FRAG_RESULT_COLR]);
d223 1
a223 1
                  if (outputsWritten & (1 << (FRAG_RESULT_DATA0 + buf))) {
d231 2
a232 2
            if (outputsWritten & (1 << FRAG_RESULT_DEPR)) {
               const GLfloat depth = machine->Outputs[FRAG_RESULT_DEPR][2];
a264 2
   ctx->_CurrentProgram = GL_FRAGMENT_PROGRAM_ARB; /* or NV, doesn't matter */

d267 1
a267 1
   if (program->Base.OutputsWritten & (1 << FRAG_RESULT_COLR)) {
d272 1
a272 1
   if (program->Base.OutputsWritten & (1 << FRAG_RESULT_DEPR)) {
a275 2

   ctx->_CurrentProgram = 0;
@


1.3
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@a42 2
   GLchan rgba[4];
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
d45 4
a48 1
   if (texObj)
d51 13
a63 7
   /* XXX use a float-valued TextureSample routine here!!! */
   swrast->TextureSample[unit](ctx, texObj, 1, (const GLfloat (*)[4]) texcoord,
                               &lambda, &rgba);
   color[0] = CHAN_TO_FLOAT(rgba[0]);
   color[1] = CHAN_TO_FLOAT(rgba[1]);
   color[2] = CHAN_TO_FLOAT(rgba[2]);
   color[3] = CHAN_TO_FLOAT(rgba[3]);
a78 2
   GLfloat lambda;
   GLchan rgba[4];
d81 2
a82 1
      const struct gl_texture_image *texImg = texObj->Image[0][texObj->BaseLevel];
d85 2
d96 13
a109 7

   swrast->TextureSample[unit](ctx, texObj, 1, (const GLfloat (*)[4]) texcoord,
                               &lambda, &rgba);
   color[0] = CHAN_TO_FLOAT(rgba[0]);
   color[1] = CHAN_TO_FLOAT(rgba[1]);
   color[2] = CHAN_TO_FLOAT(rgba[2]);
   color[3] = CHAN_TO_FLOAT(rgba[3]);
@


1.2
log
@Update to Mesa 7.0.3. tested my oga@@ and johan@@
@
text
@d25 5
a29 4
#include "glheader.h"
#include "colormac.h"
#include "context.h"
#include "prog_instruction.h"
d36 2
a37 1
 * Fetch a texel.
d40 2
a41 2
fetch_texel( GLcontext *ctx, const GLfloat texcoord[4], GLfloat lambda,
             GLuint unit, GLfloat color[4] )
d47 2
a48 1
   lambda = CLAMP(lambda, texObj->MinLod, texObj->MaxLod);
d63 1
d72 1
a72 3
   const struct gl_texture_image *texImg = texObj->Image[0][texObj->BaseLevel];
   const GLfloat texW = (GLfloat) texImg->WidthScale;
   const GLfloat texH = (GLfloat) texImg->HeightScale;
d75 11
a85 7
   GLfloat lambda
      = _swrast_compute_lambda(texdx[0], texdy[0], /* ds/dx, ds/dy */
                               texdx[1], texdy[1], /* dt/dx, dt/dy */
                               texdx[3], texdy[2], /* dq/dx, dq/dy */
                               texW, texH,
                               texcoord[0], texcoord[1], texcoord[3],
                               1.0F / texcoord[3]) + lodBias;
d87 2
a88 1
   lambda = CLAMP(lambda, texObj->MinLod, texObj->MaxLod);
d126 3
d132 1
d146 1
a146 1
   machine->FetchTexelLod = fetch_texel;
d179 5
a183 5
               GLuint output;
               for (output = 0; output < swrast->_NumColorOutputs; output++) {
                  if (outputsWritten & (1 << (FRAG_RESULT_DATA0 + output))) {
                     COPY_4V(span->array->attribs[FRAG_ATTRIB_COL0+output][i],
                             machine->Outputs[FRAG_RESULT_DATA0 + output]);
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * Version:  6.5.2
d5 1
a5 1
 * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
d43 3
d48 1
a48 2
   swrast->TextureSample[unit](ctx, ctx->Texture.Unit[unit]._Current,
                               1, (const GLfloat (*)[4]) texcoord,
d64 1
a64 1
                   GLuint unit, GLfloat color[4] )
d73 9
a81 6
   GLfloat lambda = _swrast_compute_lambda(texdx[0], texdy[0], /* ds/dx, ds/dy */
                                         texdx[1], texdy[1], /* dt/dx, dt/dy */
                                         texdx[3], texdy[2], /* dq/dx, dq/dy */
                                         texW, texH,
                                         texcoord[0], texcoord[1], texcoord[3],
                                         1.0F / texcoord[3]);
d83 1
a83 2
   swrast->TextureSample[unit](ctx, ctx->Texture.Unit[unit]._Current,
                               1, (const GLfloat (*)[4]) texcoord,
d121 1
a121 1
      machine->Attribs[FRAG_ATTRIB_FOGC][col][1] = (GLfloat) ctx->_Facing;
@


1.1.1.1
log
@Mesa 7.0.1
@
text
@@


1.1.1.2
log
@Import Mesa 7.10.3
@
text
@d3 1
a3 1
 * Version:  7.0.3
d5 1
a5 1
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
d25 4
a28 3
#include "main/glheader.h"
#include "main/colormac.h"
#include "program/prog_instruction.h"
a29 1
#include "s_context.h"
d35 1
a35 28
 * Apply texture object's swizzle (X/Y/Z/W/0/1) to incoming 'texel'
 * and return results in 'colorOut'.
 */
static INLINE void
swizzle_texel(const GLfloat texel[4], GLfloat colorOut[4], GLuint swizzle)
{
   if (swizzle == SWIZZLE_NOOP) {
      COPY_4V(colorOut, texel);
   }
   else {
      GLfloat vector[6];
      vector[SWIZZLE_X] = texel[0];
      vector[SWIZZLE_Y] = texel[1];
      vector[SWIZZLE_Z] = texel[2];
      vector[SWIZZLE_W] = texel[3];
      vector[SWIZZLE_ZERO] = 0.0F;
      vector[SWIZZLE_ONE] = 1.0F;
      colorOut[0] = vector[GET_SWZ(swizzle, 0)];
      colorOut[1] = vector[GET_SWZ(swizzle, 1)];
      colorOut[2] = vector[GET_SWZ(swizzle, 2)];
      colorOut[3] = vector[GET_SWZ(swizzle, 3)];
   }
}


/**
 * Fetch a texel with given lod.
 * Called via machine->FetchTexelLod()
d38 2
a39 2
fetch_texel_lod( struct gl_context *ctx, const GLfloat texcoord[4], GLfloat lambda,
                 GLuint unit, GLfloat color[4] )
d41 2
a42 1
   const struct gl_texture_object *texObj = ctx->Texture.Unit[unit]._Current;
d44 8
a51 14
   if (texObj) {
      SWcontext *swrast = SWRAST_CONTEXT(ctx);
      GLfloat rgba[4];

      lambda = CLAMP(lambda, texObj->MinLod, texObj->MaxLod);

      swrast->TextureSample[unit](ctx, texObj, 1,
                                  (const GLfloat (*)[4]) texcoord,
                                  &lambda, &rgba);
      swizzle_texel(rgba, color, texObj->_Swizzle);
   }
   else {
      ASSIGN_4V(color, 0.0F, 0.0F, 0.0F, 1.0F);
   }
a57 3
 * Called via machine->FetchTexelDeriv()
 * \param lodBias  the lod bias which may be specified by a TXB instruction,
 *                 otherwise zero.
d60 1
a60 1
fetch_texel_deriv( struct gl_context *ctx, const GLfloat texcoord[4],
d62 1
a62 1
                   GLfloat lodBias, GLuint unit, GLfloat color[4] )
d65 20
a84 30
   const struct gl_texture_unit *texUnit = &ctx->Texture.Unit[unit];
   const struct gl_texture_object *texObj = texUnit->_Current;

   if (texObj) {
      const struct gl_texture_image *texImg =
         texObj->Image[0][texObj->BaseLevel];
      const GLfloat texW = (GLfloat) texImg->WidthScale;
      const GLfloat texH = (GLfloat) texImg->HeightScale;
      GLfloat lambda;
      GLfloat rgba[4];

      lambda = _swrast_compute_lambda(texdx[0], texdy[0], /* ds/dx, ds/dy */
                                      texdx[1], texdy[1], /* dt/dx, dt/dy */
                                      texdx[3], texdy[3], /* dq/dx, dq/dy */
                                      texW, texH,
                                      texcoord[0], texcoord[1], texcoord[3],
                                      1.0F / texcoord[3]);

      lambda += lodBias + texUnit->LodBias + texObj->LodBias;

      lambda = CLAMP(lambda, texObj->MinLod, texObj->MaxLod);

      swrast->TextureSample[unit](ctx, texObj, 1,
                                  (const GLfloat (*)[4]) texcoord,
                                  &lambda, &rgba);
      swizzle_texel(rgba, color, texObj->_Swizzle);
   }
   else {
      ASSIGN_4V(color, 0.0F, 0.0F, 0.0F, 1.0F);
   }
d98 1
a98 1
init_machine(struct gl_context *ctx, struct gl_program_machine *machine,
a101 2
   GLfloat *wpos = span->array->attribs[FRAG_ATTRIB_WPOS][col];

d104 2
a105 9
      memset(machine->Temporaries, 0, MAX_PROGRAM_TEMPS * 4 * sizeof(GLfloat));
   }

   /* ARB_fragment_coord_conventions */
   if (program->OriginUpperLeft)
      wpos[1] = ctx->DrawBuffer->Height - 1 - wpos[1];
   if (!program->PixelCenterInteger) {
      wpos[0] += 0.5F;
      wpos[1] += 0.5F;
d115 3
a117 6
   machine->Samplers = program->Base.SamplerUnits;

   /* if running a GLSL program (not ARB_fragment_program) */
   if (ctx->Shader.CurrentFragmentProgram) {
      /* Store front/back facing value */
      machine->Attribs[FRAG_ATTRIB_FACE][col][0] = 1.0F - span->facing;
d131 1
a131 1
   machine->FetchTexelLod = fetch_texel_lod;
d140 1
a140 1
run_program(struct gl_context *ctx, SWspan *span, GLuint start, GLuint end)
d144 1
a144 1
   const GLbitfield64 outputsWritten = program->Base.OutputsWritten;
d155 1
a155 1
	    if (outputsWritten & BITFIELD64_BIT(FRAG_RESULT_COLOR)) {
d157 1
a157 1
                       machine->Outputs[FRAG_RESULT_COLOR]);
d164 5
a168 5
               GLuint buf;
               for (buf = 0; buf < ctx->DrawBuffer->_NumColorDrawBuffers; buf++) {
                  if (outputsWritten & BITFIELD64_BIT(FRAG_RESULT_DATA0 + buf)) {
                     COPY_4V(span->array->attribs[FRAG_ATTRIB_COL0 + buf][i],
                             machine->Outputs[FRAG_RESULT_DATA0 + buf]);
d174 2
a175 2
            if (outputsWritten & BITFIELD64_BIT(FRAG_RESULT_DEPTH)) {
               const GLfloat depth = machine->Outputs[FRAG_RESULT_DEPTH][2];
d199 1
a199 1
_swrast_exec_fragment_program( struct gl_context *ctx, SWspan *span )
d208 2
d212 1
a212 1
   if (program->Base.OutputsWritten & BITFIELD64_BIT(FRAG_RESULT_COLOR)) {
d217 1
a217 1
   if (program->Base.OutputsWritten & BITFIELD64_BIT(FRAG_RESULT_DEPTH)) {
d221 2
@


1.1.1.3
log
@Import Mesa 9.2.0
@
text
@d3 1
d20 3
a22 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
a26 1
#include "main/samplerobj.h"
a32 13
/**
 * \brief Should swrast use a fragment program?
 *
 * \return true if the current fragment program exists and is not the fixed
 *         function fragment program
 */
GLboolean
_swrast_use_fragment_program(struct gl_context *ctx)
{
   struct gl_fragment_program *fp = ctx->FragmentProgram._Current;
   return fp && !(fp == ctx->FragmentProgram._TexEnvProgram
                  && fp->Base.NumInstructions == 0);
}
d38 1
a38 1
static inline void
a72 1
      const struct gl_sampler_object *samp = _mesa_get_samplerobj(ctx, unit);
d74 1
a74 1
      lambda = CLAMP(lambda, samp->MinLod, samp->MaxLod);
d76 2
a77 2
      swrast->TextureSample[unit](ctx, samp, ctx->Texture.Unit[unit]._Current,
                                  1, (const GLfloat (*)[4]) texcoord,
d106 2
a107 5
      const struct swrast_texture_image *swImg =
         swrast_texture_image_const(texImg);
      const struct gl_sampler_object *samp = _mesa_get_samplerobj(ctx, unit);
      const GLfloat texW = (GLfloat) swImg->WidthScale;
      const GLfloat texH = (GLfloat) swImg->HeightScale;
d118 1
a118 1
      lambda += lodBias + texUnit->LodBias + samp->LodBias;
d120 1
a120 1
      lambda = CLAMP(lambda, samp->MinLod, samp->MaxLod);
d122 2
a123 2
      swrast->TextureSample[unit](ctx, samp, ctx->Texture.Unit[unit]._Current,
                                  1, (const GLfloat (*)[4]) texcoord,
d147 6
a152 1
   GLfloat *wpos = span->array->attribs[VARYING_SLOT_POS][col];
d167 1
a167 1
   machine->NumDeriv = VARYING_SLOT_MAX;
d174 1
a174 1
      machine->Attribs[VARYING_SLOT_FACE][col][0] = 1.0F - span->facing;
d213 1
a213 1
               COPY_4V(span->array->attribs[VARYING_SLOT_COL0][i],
d224 1
a224 1
                     COPY_4V(span->array->attribs[VARYING_SLOT_COL0 + buf][i],
d238 1
a238 2
                  span->array->z[i] =
                     (GLuint) (depth * ctx->DrawBuffer->_DepthMaxF + 0.5F);
d261 1
a261 1
   if (program->Base.InputsRead & VARYING_BIT_COL0) {
@


1.1.1.4
log
@Import Mesa 10.2.3
@
text
@d185 1
a185 1
   if (ctx->_Shader->CurrentProgram[MESA_SHADER_FRAGMENT]) {
@


