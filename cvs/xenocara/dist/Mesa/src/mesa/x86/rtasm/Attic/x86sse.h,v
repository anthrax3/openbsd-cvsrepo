head	1.4;
access;
symbols
	OPENBSD_5_8:1.3.0.30
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.28
	OPENBSD_5_7_BASE:1.3
	v10_2_9:1.1.1.2
	v10_4_3:1.1.1.2
	v10_2_7:1.1.1.2
	OPENBSD_5_6:1.3.0.26
	OPENBSD_5_6_BASE:1.3
	v10_2_3:1.1.1.2
	OPENBSD_5_5:1.3.0.24
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.22
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.20
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.18
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.16
	v7_10_3:1.1.1.2
	OPENBSD_5_0:1.3.0.14
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.10
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.12
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.8
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.6
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.4
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.2
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_3:1.2.0.2
	v7_0_1:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v6_5_2:1.1.1.1
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2015.12.23.05.17.56;	author jsg;	state dead;
branches;
next	1.3;
commitid	TnlogFl9nOv2eaRf;

1.3
date	2008.05.31.16.36.49;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.02.12.21.09.27;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.54.23;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.54.23;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2011.10.23.13.29.50;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.4
log
@remove the now unused Mesa 10.2.9 code
@
text
@
#ifndef _X86SSE_H_
#define _X86SSE_H_

#if defined(__i386__) || defined(__386__)

/* It is up to the caller to ensure that instructions issued are
 * suitable for the host cpu.  There are no checks made in this module
 * for mmx/sse/sse2 support on the cpu.
 */
struct x86_reg {
   unsigned file:3;
   unsigned idx:3;
   unsigned mod:2;		/* mod_REG if this is just a register */
   int      disp:24;		/* only +/- 23bits of offset - should be enough... */
};

struct x86_function {
   unsigned size;
   unsigned char *store;
   unsigned char *csr;
   unsigned stack_offset;
   int need_emms;
   const char *fn;
};

enum x86_reg_file {
   file_REG32,
   file_MMX,
   file_XMM,
   file_x87
};

/* Values for mod field of modr/m byte
 */
enum x86_reg_mod {
   mod_INDIRECT,
   mod_DISP8,
   mod_DISP32,
   mod_REG
};

enum x86_reg_name {
   reg_AX,
   reg_CX,
   reg_DX,
   reg_BX,
   reg_SP,
   reg_BP,
   reg_SI,
   reg_DI
};


enum x86_cc {
   cc_O,			/* overflow */
   cc_NO,			/* not overflow */
   cc_NAE,			/* not above or equal / carry */
   cc_AE,			/* above or equal / not carry */
   cc_E,			/* equal / zero */
   cc_NE			/* not equal / not zero */
};

enum sse_cc {
   cc_Equal,
   cc_LessThan,
   cc_LessThanEqual,
   cc_Unordered,
   cc_NotEqual,
   cc_NotLessThan,
   cc_NotLessThanEqual,
   cc_Ordered
};

#define cc_Z  cc_E
#define cc_NZ cc_NE

/* Begin/end/retreive function creation:
 */


void x86_init_func( struct x86_function *p );
int x86_init_func_size( struct x86_function *p, unsigned code_size );
void x86_release_func( struct x86_function *p );
void (*x86_get_func( struct x86_function *p ))( void );



/* Create and manipulate registers and regmem values:
 */
struct x86_reg x86_make_reg( enum x86_reg_file file,
			     enum x86_reg_name idx );

struct x86_reg x86_make_disp( struct x86_reg reg,
			      int disp );

struct x86_reg x86_deref( struct x86_reg reg );

struct x86_reg x86_get_base_reg( struct x86_reg reg );


/* Labels, jumps and fixup:
 */
unsigned char *x86_get_label( struct x86_function *p );

void x86_jcc( struct x86_function *p,
	      enum x86_cc cc,
	      unsigned char *label );

unsigned char *x86_jcc_forward( struct x86_function *p,
			  enum x86_cc cc );

unsigned char *x86_jmp_forward( struct x86_function *p);

unsigned char *x86_call_forward( struct x86_function *p);

void x86_fixup_fwd_jump( struct x86_function *p,
			 unsigned char *fixup );

void x86_jmp( struct x86_function *p, unsigned char *label );

/* void x86_call( struct x86_function *p, void (*label)() ); */
void x86_call( struct x86_function *p, struct x86_reg reg);

/* michal:
 * Temporary. As I need immediate operands, and dont want to mess with the codegen,
 * I load the immediate into general purpose register and use it.
 */
void x86_mov_reg_imm( struct x86_function *p, struct x86_reg dst, int imm );


/* Macro for sse_shufps() and sse2_pshufd():
 */
#define SHUF(_x,_y,_z,_w)       (((_x)<<0) | ((_y)<<2) | ((_z)<<4) | ((_w)<<6))
#define SHUF_NOOP               RSW(0,1,2,3)
#define GET_SHUF(swz, idx)      (((swz) >> ((idx)*2)) & 0x3)

void mmx_emms( struct x86_function *p );
void mmx_movd( struct x86_function *p, struct x86_reg dst, struct x86_reg src );
void mmx_movq( struct x86_function *p, struct x86_reg dst, struct x86_reg src );
void mmx_packssdw( struct x86_function *p, struct x86_reg dst, struct x86_reg src );
void mmx_packuswb( struct x86_function *p, struct x86_reg dst, struct x86_reg src );

void sse2_cvtps2dq( struct x86_function *p, struct x86_reg dst, struct x86_reg src );
void sse2_cvttps2dq( struct x86_function *p, struct x86_reg dst, struct x86_reg src );
void sse2_movd( struct x86_function *p, struct x86_reg dst, struct x86_reg src );
void sse2_packssdw( struct x86_function *p, struct x86_reg dst, struct x86_reg src );
void sse2_packsswb( struct x86_function *p, struct x86_reg dst, struct x86_reg src );
void sse2_packuswb( struct x86_function *p, struct x86_reg dst, struct x86_reg src );
void sse2_pshufd( struct x86_function *p, struct x86_reg dest, struct x86_reg arg0,
                  unsigned char shuf );
void sse2_rcpps( struct x86_function *p, struct x86_reg dst, struct x86_reg src );
void sse2_rcpss( struct x86_function *p, struct x86_reg dst, struct x86_reg src );

void sse_addps( struct x86_function *p, struct x86_reg dst, struct x86_reg src );
void sse_addss( struct x86_function *p, struct x86_reg dst, struct x86_reg src );
void sse_cvtps2pi( struct x86_function *p, struct x86_reg dst, struct x86_reg src );
void sse_divss( struct x86_function *p, struct x86_reg dst, struct x86_reg src );
void sse_andnps( struct x86_function *p, struct x86_reg dst, struct x86_reg src );
void sse_andps( struct x86_function *p, struct x86_reg dst, struct x86_reg src );
void sse_cmpps( struct x86_function *p, struct x86_reg dst, struct x86_reg src,
                unsigned char cc );
void sse_maxps( struct x86_function *p, struct x86_reg dst, struct x86_reg src );
void sse_maxss( struct x86_function *p, struct x86_reg dst, struct x86_reg src );
void sse_minps( struct x86_function *p, struct x86_reg dst, struct x86_reg src );
void sse_movaps( struct x86_function *p, struct x86_reg dst, struct x86_reg src );
void sse_movhlps( struct x86_function *p, struct x86_reg dst, struct x86_reg src );
void sse_movhps( struct x86_function *p, struct x86_reg dst, struct x86_reg src );
void sse_movlhps( struct x86_function *p, struct x86_reg dst, struct x86_reg src );
void sse_movlps( struct x86_function *p, struct x86_reg dst, struct x86_reg src );
void sse_movss( struct x86_function *p, struct x86_reg dst, struct x86_reg src );
void sse_movups( struct x86_function *p, struct x86_reg dst, struct x86_reg src );
void sse_mulps( struct x86_function *p, struct x86_reg dst, struct x86_reg src );
void sse_mulss( struct x86_function *p, struct x86_reg dst, struct x86_reg src );
void sse_orps( struct x86_function *p, struct x86_reg dst, struct x86_reg src );
void sse_xorps( struct x86_function *p, struct x86_reg dst, struct x86_reg src );
void sse_subps( struct x86_function *p, struct x86_reg dst, struct x86_reg src );
void sse_rsqrtps( struct x86_function *p, struct x86_reg dst, struct x86_reg src );
void sse_rsqrtss( struct x86_function *p, struct x86_reg dst, struct x86_reg src );
void sse_shufps( struct x86_function *p, struct x86_reg dest, struct x86_reg arg0,
                 unsigned char shuf );
void sse_pmovmskb( struct x86_function *p, struct x86_reg dest, struct x86_reg src );

void x86_add( struct x86_function *p, struct x86_reg dst, struct x86_reg src );
void x86_and( struct x86_function *p, struct x86_reg dst, struct x86_reg src );
void x86_cmp( struct x86_function *p, struct x86_reg dst, struct x86_reg src );
void x86_dec( struct x86_function *p, struct x86_reg reg );
void x86_inc( struct x86_function *p, struct x86_reg reg );
void x86_lea( struct x86_function *p, struct x86_reg dst, struct x86_reg src );
void x86_mov( struct x86_function *p, struct x86_reg dst, struct x86_reg src );
void x86_mul( struct x86_function *p, struct x86_reg src );
void x86_or( struct x86_function *p, struct x86_reg dst, struct x86_reg src );
void x86_pop( struct x86_function *p, struct x86_reg reg );
void x86_push( struct x86_function *p, struct x86_reg reg );
void x86_ret( struct x86_function *p );
void x86_sub( struct x86_function *p, struct x86_reg dst, struct x86_reg src );
void x86_test( struct x86_function *p, struct x86_reg dst, struct x86_reg src );
void x86_xor( struct x86_function *p, struct x86_reg dst, struct x86_reg src );
void x86_sahf( struct x86_function *p );

void x87_f2xm1( struct x86_function *p );
void x87_fabs( struct x86_function *p );
void x87_fadd( struct x86_function *p, struct x86_reg dst, struct x86_reg arg );
void x87_faddp( struct x86_function *p, struct x86_reg dst );
void x87_fchs( struct x86_function *p );
void x87_fclex( struct x86_function *p );
void x87_fcom( struct x86_function *p, struct x86_reg dst );
void x87_fcomp( struct x86_function *p, struct x86_reg dst );
void x87_fcos( struct x86_function *p );
void x87_fdiv( struct x86_function *p, struct x86_reg dst, struct x86_reg arg );
void x87_fdivp( struct x86_function *p, struct x86_reg dst );
void x87_fdivr( struct x86_function *p, struct x86_reg dst, struct x86_reg arg );
void x87_fdivrp( struct x86_function *p, struct x86_reg dst );
void x87_fild( struct x86_function *p, struct x86_reg arg );
void x87_fist( struct x86_function *p, struct x86_reg dst );
void x87_fistp( struct x86_function *p, struct x86_reg dst );
void x87_fld( struct x86_function *p, struct x86_reg arg );
void x87_fld1( struct x86_function *p );
void x87_fldcw( struct x86_function *p, struct x86_reg arg );
void x87_fldl2e( struct x86_function *p );
void x87_fldln2( struct x86_function *p );
void x87_fldz( struct x86_function *p );
void x87_fmul( struct x86_function *p, struct x86_reg dst, struct x86_reg arg );
void x87_fmulp( struct x86_function *p, struct x86_reg dst );
void x87_fnclex( struct x86_function *p );
void x87_fprndint( struct x86_function *p );
void x87_fscale( struct x86_function *p );
void x87_fsin( struct x86_function *p );
void x87_fsincos( struct x86_function *p );
void x87_fsqrt( struct x86_function *p );
void x87_fst( struct x86_function *p, struct x86_reg dst );
void x87_fstp( struct x86_function *p, struct x86_reg dst );
void x87_fsub( struct x86_function *p, struct x86_reg dst, struct x86_reg arg );
void x87_fsubp( struct x86_function *p, struct x86_reg dst );
void x87_fsubr( struct x86_function *p, struct x86_reg dst, struct x86_reg arg );
void x87_fsubrp( struct x86_function *p, struct x86_reg dst );
void x87_fxch( struct x86_function *p, struct x86_reg dst );
void x87_fxtract( struct x86_function *p );
void x87_fyl2x( struct x86_function *p );
void x87_fyl2xp1( struct x86_function *p );
void x87_fwait( struct x86_function *p );
void x87_fnstsw( struct x86_function *p, struct x86_reg dst );
void x87_fucompp( struct x86_function *p );
void x87_fucomp( struct x86_function *p, struct x86_reg arg );
void x87_fucom( struct x86_function *p, struct x86_reg arg );



/* Retreive a reference to one of the function arguments, taking into
 * account any push/pop activity.  Note - doesn't track explict
 * manipulation of ESP by other instructions.
 */
struct x86_reg x86_fn_arg( struct x86_function *p, unsigned arg );

#endif
#endif
@


1.3
log
@Update to Mesa 7.0.3. tested my oga@@ and johan@@
@
text
@@


1.2
log
@Update to Mesa 7.0.2. Tested by naddy@@ (full ports build), simon@@
and oga@@ (with dri enabled).
@
text
@d5 1
a5 3
#if defined(USE_X86_ASM) || defined(SLANG_X86)

#include "glheader.h"
d12 4
a15 4
   GLuint file:3;
   GLuint idx:3;
   GLuint mod:2;		/* mod_REG if this is just a register */
   GLint  disp:24;		/* only +/- 23bits of offset - should be enough... */
d19 5
a23 4
   GLubyte *store;
   GLubyte *csr;
   GLuint stack_offset;
   GLint need_emms;
d82 2
a83 1
GLboolean x86_init_func( struct x86_function *p, GLuint code_size );
d95 1
a95 1
			      GLint disp );
d104 1
a104 1
GLubyte *x86_get_label( struct x86_function *p );
d108 1
a108 1
	      GLubyte *label );
d110 1
a110 1
GLubyte *x86_jcc_forward( struct x86_function *p,
d113 1
a113 1
GLubyte *x86_jmp_forward( struct x86_function *p);
d115 1
a115 1
GLubyte *x86_call_forward( struct x86_function *p);
d118 1
a118 1
			 GLubyte *fixup );
d120 1
a120 1
void x86_jmp( struct x86_function *p, GLubyte *label );
d122 2
a123 1
void x86_call( struct x86_function *p, GLubyte *label );
d129 1
a129 1
void x86_mov_reg_imm( struct x86_function *p, struct x86_reg dst, GLint imm );
d145 1
d150 3
a152 1
void sse2_pshufd( struct x86_function *p, struct x86_reg dest, struct x86_reg arg0, GLubyte shuf );
d159 1
d161 2
a162 1
void sse_cmpps( struct x86_function *p, struct x86_reg dst, struct x86_reg src, GLubyte cc );
d175 2
d178 1
d180 3
a182 1
void sse_shufps( struct x86_function *p, struct x86_reg dest, struct x86_reg arg0, GLubyte shuf );
d253 1
a253 1
struct x86_reg x86_fn_arg( struct x86_function *p, GLuint arg );
@


1.1
log
@Initial revision
@
text
@d83 1
a83 2
void x86_init_func( struct x86_function *p );
void x86_init_func_size( struct x86_function *p, GLuint code_size );
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@Import Mesa 7.10.3
@
text
@d5 3
a7 1
#if defined(__i386__) || defined(__386__)
d14 4
a17 4
   unsigned file:3;
   unsigned idx:3;
   unsigned mod:2;		/* mod_REG if this is just a register */
   int      disp:24;		/* only +/- 23bits of offset - should be enough... */
d21 4
a24 5
   unsigned size;
   unsigned char *store;
   unsigned char *csr;
   unsigned stack_offset;
   int need_emms;
d84 1
a84 1
int x86_init_func_size( struct x86_function *p, unsigned code_size );
d96 1
a96 1
			      int disp );
d105 1
a105 1
unsigned char *x86_get_label( struct x86_function *p );
d109 1
a109 1
	      unsigned char *label );
d111 1
a111 1
unsigned char *x86_jcc_forward( struct x86_function *p,
d114 1
a114 1
unsigned char *x86_jmp_forward( struct x86_function *p);
d116 1
a116 1
unsigned char *x86_call_forward( struct x86_function *p);
d119 1
a119 1
			 unsigned char *fixup );
d121 1
a121 1
void x86_jmp( struct x86_function *p, unsigned char *label );
d123 1
a123 2
/* void x86_call( struct x86_function *p, void (*label)() ); */
void x86_call( struct x86_function *p, struct x86_reg reg);
d129 1
a129 1
void x86_mov_reg_imm( struct x86_function *p, struct x86_reg dst, int imm );
a144 1
void sse2_cvttps2dq( struct x86_function *p, struct x86_reg dst, struct x86_reg src );
d149 1
a149 3
void sse2_pshufd( struct x86_function *p, struct x86_reg dest, struct x86_reg arg0,
                  unsigned char shuf );
void sse2_rcpps( struct x86_function *p, struct x86_reg dst, struct x86_reg src );
a155 1
void sse_andnps( struct x86_function *p, struct x86_reg dst, struct x86_reg src );
d157 1
a157 2
void sse_cmpps( struct x86_function *p, struct x86_reg dst, struct x86_reg src,
                unsigned char cc );
a169 2
void sse_orps( struct x86_function *p, struct x86_reg dst, struct x86_reg src );
void sse_xorps( struct x86_function *p, struct x86_reg dst, struct x86_reg src );
a170 1
void sse_rsqrtps( struct x86_function *p, struct x86_reg dst, struct x86_reg src );
d172 1
a172 3
void sse_shufps( struct x86_function *p, struct x86_reg dest, struct x86_reg arg0,
                 unsigned char shuf );
void sse_pmovmskb( struct x86_function *p, struct x86_reg dest, struct x86_reg src );
d243 1
a243 1
struct x86_reg x86_fn_arg( struct x86_function *p, unsigned arg );
@

