head	1.5;
access;
symbols
	OPENBSD_5_8:1.4.0.6
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.4
	OPENBSD_5_7_BASE:1.4
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2015.12.23.05.17.54;	author jsg;	state dead;
branches;
next	1.4;
commitid	TnlogFl9nOv2eaRf;

1.4
date	2014.07.09.21.09.01;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.06.38;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.17.13.58.20;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.23.13.29.47;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.47;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.17.08;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.35.09;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.5
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2008  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */


/**
 * \file prog_instruction.h
 *
 * Vertex/fragment program instruction datatypes and constants.
 *
 * \author Brian Paul
 * \author Keith Whitwell
 * \author Ian Romanick <idr@@us.ibm.com>
 */


#ifndef PROG_INSTRUCTION_H
#define PROG_INSTRUCTION_H


#include "main/glheader.h"


/**
 * Swizzle indexes.
 * Do not change!
 */
/*@@{*/
#define SWIZZLE_X    0
#define SWIZZLE_Y    1
#define SWIZZLE_Z    2
#define SWIZZLE_W    3
#define SWIZZLE_ZERO 4   /**< For SWZ instruction only */
#define SWIZZLE_ONE  5   /**< For SWZ instruction only */
#define SWIZZLE_NIL  7   /**< used during shader code gen (undefined value) */
/*@@}*/

#define MAKE_SWIZZLE4(a,b,c,d) (((a)<<0) | ((b)<<3) | ((c)<<6) | ((d)<<9))
#define SWIZZLE_NOOP           MAKE_SWIZZLE4(0,1,2,3)
#define GET_SWZ(swz, idx)      (((swz) >> ((idx)*3)) & 0x7)
#define GET_BIT(msk, idx)      (((msk) >> (idx)) & 0x1)

#define SWIZZLE_XYZW MAKE_SWIZZLE4(SWIZZLE_X, SWIZZLE_Y, SWIZZLE_Z, SWIZZLE_W)
#define SWIZZLE_XXXX MAKE_SWIZZLE4(SWIZZLE_X, SWIZZLE_X, SWIZZLE_X, SWIZZLE_X)
#define SWIZZLE_YYYY MAKE_SWIZZLE4(SWIZZLE_Y, SWIZZLE_Y, SWIZZLE_Y, SWIZZLE_Y)
#define SWIZZLE_ZZZZ MAKE_SWIZZLE4(SWIZZLE_Z, SWIZZLE_Z, SWIZZLE_Z, SWIZZLE_Z)
#define SWIZZLE_WWWW MAKE_SWIZZLE4(SWIZZLE_W, SWIZZLE_W, SWIZZLE_W, SWIZZLE_W)


/**
 * Writemask values, 1 bit per component.
 */
/*@@{*/
#define WRITEMASK_X     0x1
#define WRITEMASK_Y     0x2
#define WRITEMASK_XY    0x3
#define WRITEMASK_Z     0x4
#define WRITEMASK_XZ    0x5
#define WRITEMASK_YZ    0x6
#define WRITEMASK_XYZ   0x7
#define WRITEMASK_W     0x8
#define WRITEMASK_XW    0x9
#define WRITEMASK_YW    0xa
#define WRITEMASK_XYW   0xb
#define WRITEMASK_ZW    0xc
#define WRITEMASK_XZW   0xd
#define WRITEMASK_YZW   0xe
#define WRITEMASK_XYZW  0xf
/*@@}*/


/**
 * Condition codes
 */
/*@@{*/
#define COND_GT  1  /**< greater than zero */
#define COND_EQ  2  /**< equal to zero */
#define COND_LT  3  /**< less than zero */
#define COND_UN  4  /**< unordered (NaN) */
#define COND_GE  5  /**< greater than or equal to zero */
#define COND_LE  6  /**< less than or equal to zero */
#define COND_NE  7  /**< not equal to zero */
#define COND_TR  8  /**< always true */
#define COND_FL  9  /**< always false */
/*@@}*/


/**
 * Instruction precision for GL_NV_fragment_program
 */
/*@@{*/
#define FLOAT32  0x1
#define FLOAT16  0x2
#define FIXED12  0x4
/*@@}*/


/**
 * Saturation modes when storing values.
 */
/*@@{*/
#define SATURATE_OFF            0
#define SATURATE_ZERO_ONE       1
/*@@}*/


/**
 * Per-component negation masks
 */
/*@@{*/
#define NEGATE_X    0x1
#define NEGATE_Y    0x2
#define NEGATE_Z    0x4
#define NEGATE_W    0x8
#define NEGATE_XYZ  0x7
#define NEGATE_XYZW 0xf
#define NEGATE_NONE 0x0
/*@@}*/


/**
 * Program instruction opcodes for vertex, fragment and geometry programs.
 */
typedef enum prog_opcode {
                     /* ARB_vp   ARB_fp   NV_vp   NV_fp     GLSL */
                     /*------------------------------------------*/
   OPCODE_NOP = 0,   /*                                      X   */
   OPCODE_ABS,       /*   X        X       1.1               X   */
   OPCODE_ADD,       /*   X        X       X       X         X   */
   OPCODE_ARL,       /*   X                X                 X   */
   OPCODE_BGNLOOP,   /*                                     opt  */
   OPCODE_BGNSUB,    /*                                     opt  */
   OPCODE_BRK,       /*                    2                opt  */
   OPCODE_CAL,       /*                    2       2        opt  */
   OPCODE_CMP,       /*            X                         X   */
   OPCODE_CONT,      /*                                     opt  */
   OPCODE_COS,       /*            X       2       X         X   */
   OPCODE_DDX,       /*                            X         X   */
   OPCODE_DDY,       /*                            X         X   */
   OPCODE_DP2,       /*                            2         X   */
   OPCODE_DP3,       /*   X        X       X       X         X   */
   OPCODE_DP4,       /*   X        X       X       X         X   */
   OPCODE_DPH,       /*   X        X       1.1                   */
   OPCODE_DST,       /*   X        X       X       X             */
   OPCODE_ELSE,      /*                                     opt  */
   OPCODE_END,       /*   X        X       X       X        opt  */
   OPCODE_ENDIF,     /*                                     opt  */
   OPCODE_ENDLOOP,   /*                                     opt  */
   OPCODE_ENDSUB,    /*                                     opt  */
   OPCODE_EX2,       /*   X        X       2       X         X   */
   OPCODE_EXP,       /*   X                X                     */
   OPCODE_FLR,       /*   X        X       2       X         X   */
   OPCODE_FRC,       /*   X        X       2       X         X   */
   OPCODE_IF,        /*                                     opt  */
   OPCODE_KIL,       /*            X                         X   */
   OPCODE_KIL_NV,    /*                            X         X   */
   OPCODE_LG2,       /*   X        X       2       X         X   */
   OPCODE_LIT,       /*   X        X       X       X             */
   OPCODE_LOG,       /*   X                X                     */
   OPCODE_LRP,       /*            X               X             */
   OPCODE_MAD,       /*   X        X       X       X         X   */
   OPCODE_MAX,       /*   X        X       X       X         X   */
   OPCODE_MIN,       /*   X        X       X       X         X   */
   OPCODE_MOV,       /*   X        X       X       X         X   */
   OPCODE_MUL,       /*   X        X       X       X         X   */
   OPCODE_NOISE1,    /*                                      X   */
   OPCODE_NOISE2,    /*                                      X   */
   OPCODE_NOISE3,    /*                                      X   */
   OPCODE_NOISE4,    /*                                      X   */
   OPCODE_PK2H,      /*                            X             */
   OPCODE_PK2US,     /*                            X             */
   OPCODE_PK4B,      /*                            X             */
   OPCODE_PK4UB,     /*                            X             */
   OPCODE_POW,       /*   X        X               X         X   */
   OPCODE_RCP,       /*   X        X       X       X         X   */
   OPCODE_RET,       /*                    2       2        opt  */
   OPCODE_RFL,       /*                            X             */
   OPCODE_RSQ,       /*   X        X       X       X         X   */
   OPCODE_SCS,       /*            X                         X   */
   OPCODE_SEQ,       /*                    2       X         X   */
   OPCODE_SFL,       /*                    2       X             */
   OPCODE_SGE,       /*   X        X       X       X         X   */
   OPCODE_SGT,       /*                    2       X         X   */
   OPCODE_SIN,       /*            X       2       X         X   */
   OPCODE_SLE,       /*                    2       X         X   */
   OPCODE_SLT,       /*   X        X       X       X         X   */
   OPCODE_SNE,       /*                    2       X         X   */
   OPCODE_SSG,       /*                    2                 X   */
   OPCODE_STR,       /*                    2       X             */
   OPCODE_SUB,       /*   X        X       1.1     X         X   */
   OPCODE_SWZ,       /*   X        X                         X   */
   OPCODE_TEX,       /*            X       3       X         X   */
   OPCODE_TXB,       /*            X       3                 X   */
   OPCODE_TXD,       /*                            X         X   */
   OPCODE_TXL,       /*                    3       2         X   */
   OPCODE_TXP,       /*            X                         X   */
   OPCODE_TXP_NV,    /*                    3       X             */
   OPCODE_TRUNC,     /*                                      X   */
   OPCODE_UP2H,      /*                            X             */
   OPCODE_UP2US,     /*                            X             */
   OPCODE_UP4B,      /*                            X             */
   OPCODE_UP4UB,     /*                            X             */
   OPCODE_X2D,       /*                            X             */
   OPCODE_XPD,       /*   X        X                             */
   MAX_OPCODE
} gl_inst_opcode;


/**
 * Number of bits for the src/dst register Index field.
 * This limits the size of temp/uniform register files.
 */
#define INST_INDEX_BITS 12


/**
 * Instruction source register.
 */
struct prog_src_register
{
   GLuint File:4;	/**< One of the PROGRAM_* register file values. */
   GLint Index:(INST_INDEX_BITS+1); /**< Extra bit here for sign bit.
                                     * May be negative for relative addressing.
                                     */
   GLuint Swizzle:12;
   GLuint RelAddr:1;

   /** Take the component-wise absolute value */
   GLuint Abs:1;

   /**
    * Post-Abs negation.
    * This will either be NEGATE_NONE or NEGATE_XYZW, except for the SWZ
    * instruction which allows per-component negation.
    */
   GLuint Negate:4;

   /**
    * Is the register two-dimensional.
    * Two dimensional registers are of the
    * REGISTER[index][index2] format.
    * They are used by the geometry shaders where
    * the first index is the index within an array
    * and the second index is the semantic of the
    * array, e.g. gl_PositionIn[index] would become
    * INPUT[index][gl_PositionIn]
    */
   GLuint HasIndex2:1;
   GLuint RelAddr2:1;
   GLint Index2:(INST_INDEX_BITS+1); /**< Extra bit here for sign bit.
                                       * May be negative for relative
                                       * addressing. */
};


/**
 * Instruction destination register.
 */
struct prog_dst_register
{
   GLuint File:4;      /**< One of the PROGRAM_* register file values */
   GLuint Index:INST_INDEX_BITS;  /**< Unsigned, never negative */
   GLuint WriteMask:4;
   GLuint RelAddr:1;

   /**
    * \name Conditional destination update control.
    *
    * \since
    * NV_fragment_program_option, NV_vertex_program2, NV_vertex_program2_option.
    */
   /*@@{*/
   /**
    * Takes one of the 9 possible condition values (EQ, FL, GT, GE, LE, LT,
    * NE, TR, or UN).  Dest reg is only written to if the matching
    * (swizzled) condition code value passes.  When a conditional update mask
    * is not specified, this will be \c COND_TR.
    */
   GLuint CondMask:4;

   /**
    * Condition code swizzle value.
    */
   GLuint CondSwizzle:12;
};


/**
 * Vertex/fragment program instruction.
 */
struct prog_instruction
{
   gl_inst_opcode Opcode;
   struct prog_src_register SrcReg[3];
   struct prog_dst_register DstReg;

   /**
    * Indicates that the instruction should update the condition code
    * register.
    *
    * \since
    * NV_fragment_program_option, NV_vertex_program2, NV_vertex_program2_option.
    */
   GLuint CondUpdate:1;

   /**
    * If prog_instruction::CondUpdate is \c GL_TRUE, this value selects the
    * condition code register that is to be updated.
    *
    * In GL_NV_fragment_program or GL_NV_vertex_program2 mode, only condition
    * code register 0 is available.  In GL_NV_vertex_program3 mode, condition
    * code registers 0 and 1 are available.
    *
    * \since
    * NV_fragment_program_option, NV_vertex_program2, NV_vertex_program2_option.
    */
   GLuint CondDst:1;

   /**
    * Saturate each value of the vectored result to the range [0,1] or the
    * range [-1,1].  \c SSAT mode (i.e., saturation to the range [-1,1]) is
    * only available in NV_fragment_program2 mode.
    * Value is one of the SATURATE_* tokens.
    *
    * \since
    * NV_fragment_program_option, NV_vertex_program3.
    */
   GLuint SaturateMode:2;

   /**
    * Per-instruction selectable precision: FLOAT32, FLOAT16, FIXED12.
    *
    * \since
    * NV_fragment_program_option.
    */
   GLuint Precision:3;

   /**
    * \name Extra fields for TEX, TXB, TXD, TXL, TXP instructions.
    */
   /*@@{*/
   /** Source texture unit. */
   GLuint TexSrcUnit:5;

   /** Source texture target, one of TEXTURE_{1D,2D,3D,CUBE,RECT}_INDEX */
   GLuint TexSrcTarget:4;

   /** True if tex instruction should do shadow comparison */
   GLuint TexShadow:1;
   /*@@}*/

   /**
    * For BRA and CAL instructions, the location to jump to.
    * For BGNLOOP, points to ENDLOOP (and vice-versa).
    * For BRK, points to ENDLOOP
    * For IF, points to ELSE or ENDIF.
    * For ELSE, points to ENDIF.
    */
   GLint BranchTarget;

   /** for debugging purposes */
   const char *Comment;

   /** for driver use (try to remove someday) */
   GLint Aux;
};


#ifdef __cplusplus
extern "C" {
#endif

extern void
_mesa_init_instructions(struct prog_instruction *inst, GLuint count);

extern struct prog_instruction *
_mesa_alloc_instructions(GLuint numInst);

extern struct prog_instruction *
_mesa_realloc_instructions(struct prog_instruction *oldInst,
                           GLuint numOldInst, GLuint numNewInst);

extern struct prog_instruction *
_mesa_copy_instructions(struct prog_instruction *dest,
                        const struct prog_instruction *src, GLuint n);

extern void
_mesa_free_instructions(struct prog_instruction *inst, GLuint count);

extern GLuint
_mesa_num_inst_src_regs(gl_inst_opcode opcode);

extern GLuint
_mesa_num_inst_dst_regs(gl_inst_opcode opcode);

extern GLboolean
_mesa_is_tex_instruction(gl_inst_opcode opcode);

extern GLboolean
_mesa_check_soa_dependencies(const struct prog_instruction *inst);

extern const char *
_mesa_opcode_string(gl_inst_opcode opcode);


#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* PROG_INSTRUCTION_H */
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.3
log
@Merge Mesa 9.2.0
@
text
@d389 4
d425 4
@


1.2
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a2 1
 * Version:  7.3
d19 4
a22 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
a149 2
   OPCODE_AND,       /*                                          */
   OPCODE_ARA,       /*                    2                     */
a150 2
   OPCODE_ARL_NV,    /*                    2                     */
   OPCODE_ARR,       /*                    2                     */
a152 1
   OPCODE_BRA,       /*                    2                     */
a160 1
   OPCODE_DP2A,      /*                            2             */
a165 1
   OPCODE_EMIT_VERTEX,/*                                     X   */
a166 1
   OPCODE_END_PRIMITIVE,/*                                   X   */
a189 4
   OPCODE_NOT,       /*                                          */
   OPCODE_NRM3,      /*                                          */
   OPCODE_NRM4,      /*                                          */
   OPCODE_OR,        /*                                          */
a194 4
   OPCODE_POPA,      /*                    3                     */
   OPCODE_PRINT,     /*                    X       X             */
   OPCODE_PUSHA,     /*                    3                     */
   OPCODE_RCC,       /*                    1.1                   */
d197 1
a197 1
   OPCODE_RFL,       /*            X               X             */
a223 1
   OPCODE_XOR,       /*                                          */
d290 1
a290 2
    * NV_fragment_program, NV_fragment_program_option, NV_vertex_program2,
    * NV_vertex_program2_option.
a304 9

   /**
    * Selects the condition code register to use for conditional destination
    * update masking.  In NV_fragmnet_program or NV_vertex_program2 mode, only
    * condition code register 0 is available.  In NV_vertex_program3 mode,
    * condition code registers 0 and 1 are available.
    */
   GLuint CondSrc:1;
   /*@@}*/
d322 1
a322 2
    * NV_fragment_program, NV_fragment_program_option, NV_vertex_program2,
    * NV_vertex_program2_option.
d335 1
a335 2
    * NV_fragment_program, NV_fragment_program_option, NV_vertex_program2,
    * NV_vertex_program2_option.
d346 1
a346 1
    * NV_fragment_program, NV_fragment_program_option, NV_vertex_program3.
d354 1
a354 1
    * NV_fragment_program, NV_fragment_program_option.
d366 1
a366 1
   GLuint TexSrcTarget:3;
a382 3

   /** Arbitrary data.  Used for OPCODE_PRINT and some drivers */
   void *Data;
@


1.1
log
@Initial revision
@
text
@d157 1
a157 1
   OPCODE_BRA,       /*                    2                 X   */
d159 1
a159 1
   OPCODE_CAL,       /*                    2       2         X   */
d171 1
a171 1
   OPCODE_ELSE,      /*                                      X   */
d179 1
a179 1
   OPCODE_EXP,       /*   X                X                 X   */
d183 1
a183 1
   OPCODE_KIL,       /*            X                             */
d187 2
a188 2
   OPCODE_LOG,       /*   X                X                 X   */
   OPCODE_LRP,       /*            X               X         X   */
d199 2
a200 2
   OPCODE_NRM3,      /*                                      X   */
   OPCODE_NRM4,      /*                                      X   */
d212 1
a212 1
   OPCODE_RET,       /*                    2       2         X   */
d215 1
a215 1
   OPCODE_SCS,       /*            X                             */
d224 1
a224 1
   OPCODE_SSG,       /*                    2                     */
d227 1
a227 1
   OPCODE_SWZ,       /*   X        X                             */
d241 1
a241 1
   OPCODE_XPD,       /*   X        X                         X   */
d250 1
a250 1
#define INST_INDEX_BITS 11
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d3 1
d20 3
a22 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
d150 2
d153 2
d157 1
d159 1
a159 1
   OPCODE_CAL,       /*                    2       2        opt  */
d166 1
d171 2
a172 1
   OPCODE_ELSE,      /*                                     opt  */
d174 1
d179 1
a179 1
   OPCODE_EXP,       /*   X                X                     */
d183 1
a183 1
   OPCODE_KIL,       /*            X                         X   */
d187 2
a188 2
   OPCODE_LOG,       /*   X                X                     */
   OPCODE_LRP,       /*            X               X             */
d198 4
d207 4
d212 2
a213 2
   OPCODE_RET,       /*                    2       2        opt  */
   OPCODE_RFL,       /*                            X             */
d215 1
a215 1
   OPCODE_SCS,       /*            X                         X   */
d224 1
a224 1
   OPCODE_SSG,       /*                    2                 X   */
d227 1
a227 1
   OPCODE_SWZ,       /*   X        X                         X   */
d240 2
a241 1
   OPCODE_XPD,       /*   X        X                             */
d250 1
a250 1
#define INST_INDEX_BITS 12
d307 2
a308 1
    * NV_fragment_program_option, NV_vertex_program2, NV_vertex_program2_option.
d323 9
d349 2
a350 1
    * NV_fragment_program_option, NV_vertex_program2, NV_vertex_program2_option.
d363 2
a364 1
    * NV_fragment_program_option, NV_vertex_program2, NV_vertex_program2_option.
d375 1
a375 1
    * NV_fragment_program_option, NV_vertex_program3.
d383 1
a383 1
    * NV_fragment_program_option.
d395 1
a395 1
   GLuint TexSrcTarget:4;
d412 3
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@a388 4
#ifdef __cplusplus
extern "C" {
#endif

a420 4

#ifdef __cplusplus
} /* extern "C" */
#endif
@


