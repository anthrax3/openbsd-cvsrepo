head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@// @;


1.7
date	2015.12.23.05.17.54;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.5;
commitid	4ry2gvZGMXkCUD2n;

1.5
date	2015.01.25.14.41.22;	author jsg;	state Exp;
branches;
next	1.4;
commitid	mcxB0JvoI9gTDYXU;

1.4
date	2014.07.09.21.09.01;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.06.40;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.17.13.58.20;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.23.13.29.47;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.47;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.17.11;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.35.09;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.13.14;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.50.20;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright (C) 2005-2007  Brian Paul   All Rights Reserved.
 * Copyright (C) 2008  VMware, Inc.   All Rights Reserved.
 * Copyright Â© 2010 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include "ir.h"
#include "glsl_types.h"
#include "ir_visitor.h"
#include "../glsl/program.h"
#include "program/hash_table.h"
#include "ir_uniform.h"

extern "C" {
#include "main/compiler.h"
#include "main/mtypes.h"
#include "program/prog_parameter.h"
#include "program/program.h"
}

class get_sampler_name : public ir_hierarchical_visitor
{
public:
   get_sampler_name(ir_dereference *last,
		    struct gl_shader_program *shader_program)
   {
      this->mem_ctx = ralloc_context(NULL);
      this->shader_program = shader_program;
      this->name = NULL;
      this->offset = 0;
      this->last = last;
   }

   ~get_sampler_name()
   {
      ralloc_free(this->mem_ctx);
   }

   virtual ir_visitor_status visit(ir_dereference_variable *ir)
   {
      this->name = ir->var->name;
      return visit_continue;
   }

   virtual ir_visitor_status visit_leave(ir_dereference_record *ir)
   {
      this->name = ralloc_asprintf(mem_ctx, "%s.%s", name, ir->field);
      return visit_continue;
   }

   virtual ir_visitor_status visit_leave(ir_dereference_array *ir)
   {
      ir_constant *index = ir->array_index->as_constant();
      int i;

      if (index) {
	 i = index->value.i[0];
      } else {
	 /* GLSL 1.10 and 1.20 allowed variable sampler array indices,
	  * while GLSL 1.30 requires that the array indices be
	  * constant integer expressions.  We don't expect any driver
	  * to actually work with a really variable array index, so
	  * all that would work would be an unrolled loop counter that ends
	  * up being constant above.
	  */
	 ralloc_strcat(&shader_program->InfoLog,
		       "warning: Variable sampler array index unsupported.\n"
		       "This feature of the language was removed in GLSL 1.20 "
		       "and is unlikely to be supported for 1.10 in Mesa.\n");
	 i = 0;
      }
      if (ir != last) {
	 this->name = ralloc_asprintf(mem_ctx, "%s[%d]", name, i);
      } else {
	 offset = i;
      }
      return visit_continue;
   }

   struct gl_shader_program *shader_program;
   const char *name;
   void *mem_ctx;
   int offset;
   ir_dereference *last;
};


extern "C" int
_mesa_get_sampler_uniform_value(class ir_dereference *sampler,
				struct gl_shader_program *shader_program,
				const struct gl_program *prog)
{
   get_sampler_name getname(sampler, shader_program);

   GLuint shader = _mesa_program_enum_to_shader_stage(prog->Target);

   sampler->accept(&getname);

   unsigned location;
   if (!shader_program->UniformHash->get(location, getname.name)) {
      linker_error(shader_program,
		   "failed to find sampler named %s.\n", getname.name);
      return 0;
   }

   if (!shader_program->UniformStorage[location].sampler[shader].active) {
      assert(0 && "cannot return a sampler");
      linker_error(shader_program,
		   "cannot return a sampler named %s, because it is not "
                   "used in this shader stage. This is a driver bug.\n",
                   getname.name);
      return 0;
   }

   return shader_program->UniformStorage[location].sampler[shader].index +
          getname.offset;
}
@


1.6
log
@Merge Mesa 10.2.9
@
text
@@


1.5
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a136 11


extern "C" class ir_rvalue *
_mesa_get_sampler_array_nonconst_index(class ir_dereference *sampler)
{
   ir_dereference_array *deref_arr = sampler->as_dereference_array();
   if (!deref_arr || deref_arr->array_index->as_constant())
      return NULL;

   return deref_arr->array_index;
}
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d137 11
@


1.3
log
@Merge Mesa 9.2.0
@
text
@d114 1
a114 1
   GLuint shader = _mesa_program_target_to_index(prog->Target);
@


1.2
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d29 3
d37 1
a37 12
}

static void fail_link(struct gl_shader_program *prog, const char *fmt, ...) PRINTFLIKE(2, 3);

static void fail_link(struct gl_shader_program *prog, const char *fmt, ...)
{
   va_list args;
   va_start(args, fmt);
   ralloc_vasprintf_append(&prog->InfoLog, fmt, args);
   va_end(args);

   prog->LinkStatus = GL_FALSE;
d106 2
a107 2
extern "C" {
int
d114 2
d118 6
a123 2
   GLint index = _mesa_lookup_parameter_index(prog->Parameters, -1,
					      getname.name);
d125 6
a130 3
   if (index < 0) {
      fail_link(shader_program,
		"failed to find sampler named %s.\n", getname.name);
d134 2
a135 4
   index += getname.offset;

   return prog->Parameters->ParameterValues[index][0];
}
@


1.1
log
@Initial revision
@
text
@a25 1
#include <stdio.h>
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d26 1
a29 3
#include "../glsl/program.h"
#include "program/hash_table.h"
#include "ir_uniform.h"
d35 12
a46 1
#include "program/program.h"
d115 2
a116 2

extern "C" int
d123 1
a123 1
   GLuint shader = _mesa_program_target_to_index(prog->Target);
d125 2
a126 1
   sampler->accept(&getname);
d128 3
a130 4
   unsigned location;
   if (!shader_program->UniformHash->get(location, getname.name)) {
      linker_error(shader_program,
		   "failed to find sampler named %s.\n", getname.name);
d134 1
a134 8
   if (!shader_program->UniformStorage[location].sampler[shader].active) {
      assert(0 && "cannot return a sampler");
      linker_error(shader_program,
		   "cannot return a sampler named %s, because it is not "
                   "used in this shader stage. This is a driver bug.\n",
                   getname.name);
      return 0;
   }
d136 2
a137 2
   return shader_program->UniformStorage[location].sampler[shader].index +
          getname.offset;
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d114 1
a114 1
   GLuint shader = _mesa_program_enum_to_shader_stage(prog->Target);
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@a136 11


extern "C" class ir_rvalue *
_mesa_get_sampler_array_nonconst_index(class ir_dereference *sampler)
{
   ir_dereference_array *deref_arr = sampler->as_dereference_array();
   if (!deref_arr || deref_arr->array_index->as_constant())
      return NULL;

   return deref_arr->array_index;
}
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d137 11
@


