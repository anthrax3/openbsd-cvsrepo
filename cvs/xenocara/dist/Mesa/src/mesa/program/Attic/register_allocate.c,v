head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.12.23.05.17.54;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.5;
commitid	4ry2gvZGMXkCUD2n;

1.5
date	2015.01.25.14.41.22;	author jsg;	state dead;
branches;
next	1.4;
commitid	mcxB0JvoI9gTDYXU;

1.4
date	2014.07.09.21.09.01;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.06.39;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.17.13.58.20;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.23.13.29.47;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.47;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.17.11;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.35.09;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright © 2010 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * Authors:
 *    Eric Anholt <eric@@anholt.net>
 *
 */

/** @@file register_allocate.c
 *
 * Graph-coloring register allocator.
 *
 * The basic idea of graph coloring is to make a node in a graph for
 * every thing that needs a register (color) number assigned, and make
 * edges in the graph between nodes that interfere (can't be allocated
 * to the same register at the same time).
 *
 * During the "simplify" process, any any node with fewer edges than
 * there are registers means that that edge can get assigned a
 * register regardless of what its neighbors choose, so that node is
 * pushed on a stack and removed (with its edges) from the graph.
 * That likely causes other nodes to become trivially colorable as well.
 *
 * Then during the "select" process, nodes are popped off of that
 * stack, their edges restored, and assigned a color different from
 * their neighbors.  Because they were pushed on the stack only when
 * they were trivially colorable, any color chosen won't interfere
 * with the registers to be popped later.
 *
 * The downside to most graph coloring is that real hardware often has
 * limitations, like registers that need to be allocated to a node in
 * pairs, or aligned on some boundary.  This implementation follows
 * the paper "Retargetable Graph-Coloring Register Allocation for
 * Irregular Architectures" by Johan Runeson and Sven-Olof Nyström.
 *
 * In this system, there are register classes each containing various
 * registers, and registers may interfere with other registers.  For
 * example, one might have a class of base registers, and a class of
 * aligned register pairs that would each interfere with their pair of
 * the base registers.  Each node has a register class it needs to be
 * assigned to.  Define p(B) to be the size of register class B, and
 * q(B,C) to be the number of registers in B that the worst choice
 * register in C could conflict with.  Then, this system replaces the
 * basic graph coloring test of "fewer edges from this node than there
 * are registers" with "For this node of class B, the sum of q(B,C)
 * for each neighbor node of class C is less than pB".
 *
 * A nice feature of the pq test is that q(B,C) can be computed once
 * up front and stored in a 2-dimensional array, so that the cost of
 * coloring a node is constant with the number of registers.  We do
 * this during ra_set_finalize().
 */

#include <stdbool.h>
#include <ralloc.h>

#include "main/imports.h"
#include "main/macros.h"
#include "main/mtypes.h"
#include "main/bitset.h"
#include "register_allocate.h"

#define NO_REG ~0

struct ra_reg {
   BITSET_WORD *conflicts;
   unsigned int *conflict_list;
   unsigned int conflict_list_size;
   unsigned int num_conflicts;
};

struct ra_regs {
   struct ra_reg *regs;
   unsigned int count;

   struct ra_class **classes;
   unsigned int class_count;

   bool round_robin;
};

struct ra_class {
   /**
    * Bitset indicating which registers belong to this class.
    *
    * (If bit N is set, then register N belongs to this class.)
    */
   BITSET_WORD *regs;

   /**
    * p(B) in Runeson/Nyström paper.
    *
    * This is "how many regs are in the set."
    */
   unsigned int p;

   /**
    * q(B,C) (indexed by C, B is this register class) in
    * Runeson/Nyström paper.  This is "how many registers of B could
    * the worst choice register from C conflict with".
    */
   unsigned int *q;
};

struct ra_node {
   /** @@{
    *
    * List of which nodes this node interferes with.  This should be
    * symmetric with the other node.
    */
   BITSET_WORD *adjacency;
   unsigned int *adjacency_list;
   unsigned int adjacency_list_size;
   unsigned int adjacency_count;
   /** @@} */

   unsigned int class;

   /* Register, if assigned, or NO_REG. */
   unsigned int reg;

   /**
    * Set when the node is in the trivially colorable stack.  When
    * set, the adjacency to this node is ignored, to implement the
    * "remove the edge from the graph" in simplification without
    * having to actually modify the adjacency_list.
    */
   bool in_stack;

   /* For an implementation that needs register spilling, this is the
    * approximate cost of spilling this node.
    */
   float spill_cost;
};

struct ra_graph {
   struct ra_regs *regs;
   /**
    * the variables that need register allocation.
    */
   struct ra_node *nodes;
   unsigned int count; /**< count of nodes. */

   unsigned int *stack;
   unsigned int stack_count;

   /**
    * Tracks the start of the set of optimistically-colored registers in the
    * stack.
    *
    * Along with any registers not in the stack (if one called ra_simplify()
    * and didn't do optimistic coloring), these need to be considered for
    * spilling.
    */
   unsigned int stack_optimistic_start;
};

/**
 * Creates a set of registers for the allocator.
 *
 * mem_ctx is a ralloc context for the allocator.  The reg set may be freed
 * using ralloc_free().
 */
struct ra_regs *
ra_alloc_reg_set(void *mem_ctx, unsigned int count)
{
   unsigned int i;
   struct ra_regs *regs;

   regs = rzalloc(mem_ctx, struct ra_regs);
   regs->count = count;
   regs->regs = rzalloc_array(regs, struct ra_reg, count);

   for (i = 0; i < count; i++) {
      regs->regs[i].conflicts = rzalloc_array(regs->regs, BITSET_WORD,
                                              BITSET_WORDS(count));
      BITSET_SET(regs->regs[i].conflicts, i);

      regs->regs[i].conflict_list = ralloc_array(regs->regs, unsigned int, 4);
      regs->regs[i].conflict_list_size = 4;
      regs->regs[i].conflict_list[0] = i;
      regs->regs[i].num_conflicts = 1;
   }

   return regs;
}

/**
 * The register allocator by default prefers to allocate low register numbers,
 * since it was written for hardware (gen4/5 Intel) that is limited in its
 * multithreadedness by the number of registers used in a given shader.
 *
 * However, for hardware without that restriction, densely packed register
 * allocation can put serious constraints on instruction scheduling.  This
 * function tells the allocator to rotate around the registers if possible as
 * it allocates the nodes.
 */
void
ra_set_allocate_round_robin(struct ra_regs *regs)
{
   regs->round_robin = true;
}

static void
ra_add_conflict_list(struct ra_regs *regs, unsigned int r1, unsigned int r2)
{
   struct ra_reg *reg1 = &regs->regs[r1];

   if (reg1->conflict_list_size == reg1->num_conflicts) {
      reg1->conflict_list_size *= 2;
      reg1->conflict_list = reralloc(regs->regs, reg1->conflict_list,
				     unsigned int, reg1->conflict_list_size);
   }
   reg1->conflict_list[reg1->num_conflicts++] = r2;
   BITSET_SET(reg1->conflicts, r2);
}

void
ra_add_reg_conflict(struct ra_regs *regs, unsigned int r1, unsigned int r2)
{
   if (!BITSET_TEST(regs->regs[r1].conflicts, r2)) {
      ra_add_conflict_list(regs, r1, r2);
      ra_add_conflict_list(regs, r2, r1);
   }
}

/**
 * Adds a conflict between base_reg and reg, and also between reg and
 * anything that base_reg conflicts with.
 *
 * This can simplify code for setting up multiple register classes
 * which are aggregates of some base hardware registers, compared to
 * explicitly using ra_add_reg_conflict.
 */
void
ra_add_transitive_reg_conflict(struct ra_regs *regs,
			       unsigned int base_reg, unsigned int reg)
{
   int i;

   ra_add_reg_conflict(regs, reg, base_reg);

   for (i = 0; i < regs->regs[base_reg].num_conflicts; i++) {
      ra_add_reg_conflict(regs, reg, regs->regs[base_reg].conflict_list[i]);
   }
}

unsigned int
ra_alloc_reg_class(struct ra_regs *regs)
{
   struct ra_class *class;

   regs->classes = reralloc(regs->regs, regs->classes, struct ra_class *,
			    regs->class_count + 1);

   class = rzalloc(regs, struct ra_class);
   regs->classes[regs->class_count] = class;

   class->regs = rzalloc_array(class, BITSET_WORD, BITSET_WORDS(regs->count));

   return regs->class_count++;
}

void
ra_class_add_reg(struct ra_regs *regs, unsigned int c, unsigned int r)
{
   struct ra_class *class = regs->classes[c];

   BITSET_SET(class->regs, r);
   class->p++;
}

/**
 * Returns true if the register belongs to the given class.
 */
static bool
reg_belongs_to_class(unsigned int r, struct ra_class *c)
{
   return BITSET_TEST(c->regs, r);
}

/**
 * Must be called after all conflicts and register classes have been
 * set up and before the register set is used for allocation.
 * To avoid costly q value computation, use the q_values paramater
 * to pass precomputed q values to this function.
 */
void
ra_set_finalize(struct ra_regs *regs, unsigned int **q_values)
{
   unsigned int b, c;

   for (b = 0; b < regs->class_count; b++) {
      regs->classes[b]->q = ralloc_array(regs, unsigned int, regs->class_count);
   }

   if (q_values) {
      for (b = 0; b < regs->class_count; b++) {
         for (c = 0; c < regs->class_count; c++) {
            regs->classes[b]->q[c] = q_values[b][c];
	 }
      }
      return;
   }

   /* Compute, for each class B and C, how many regs of B an
    * allocation to C could conflict with.
    */
   for (b = 0; b < regs->class_count; b++) {
      for (c = 0; c < regs->class_count; c++) {
	 unsigned int rc;
	 int max_conflicts = 0;

	 for (rc = 0; rc < regs->count; rc++) {
	    int conflicts = 0;
	    int i;

            if (!reg_belongs_to_class(rc, regs->classes[c]))
	       continue;

	    for (i = 0; i < regs->regs[rc].num_conflicts; i++) {
	       unsigned int rb = regs->regs[rc].conflict_list[i];
	       if (BITSET_TEST(regs->classes[b]->regs, rb))
		  conflicts++;
	    }
	    max_conflicts = MAX2(max_conflicts, conflicts);
	 }
	 regs->classes[b]->q[c] = max_conflicts;
      }
   }
}

static void
ra_add_node_adjacency(struct ra_graph *g, unsigned int n1, unsigned int n2)
{
   BITSET_SET(g->nodes[n1].adjacency, n2);

   if (g->nodes[n1].adjacency_count >=
       g->nodes[n1].adjacency_list_size) {
      g->nodes[n1].adjacency_list_size *= 2;
      g->nodes[n1].adjacency_list = reralloc(g, g->nodes[n1].adjacency_list,
                                             unsigned int,
                                             g->nodes[n1].adjacency_list_size);
   }

   g->nodes[n1].adjacency_list[g->nodes[n1].adjacency_count] = n2;
   g->nodes[n1].adjacency_count++;
}

struct ra_graph *
ra_alloc_interference_graph(struct ra_regs *regs, unsigned int count)
{
   struct ra_graph *g;
   unsigned int i;

   g = rzalloc(regs, struct ra_graph);
   g->regs = regs;
   g->nodes = rzalloc_array(g, struct ra_node, count);
   g->count = count;

   g->stack = rzalloc_array(g, unsigned int, count);

   for (i = 0; i < count; i++) {
      int bitset_count = BITSET_WORDS(count);
      g->nodes[i].adjacency = rzalloc_array(g, BITSET_WORD, bitset_count);

      g->nodes[i].adjacency_list_size = 4;
      g->nodes[i].adjacency_list =
         ralloc_array(g, unsigned int, g->nodes[i].adjacency_list_size);
      g->nodes[i].adjacency_count = 0;

      ra_add_node_adjacency(g, i, i);
      g->nodes[i].reg = NO_REG;
   }

   return g;
}

void
ra_set_node_class(struct ra_graph *g,
		  unsigned int n, unsigned int class)
{
   g->nodes[n].class = class;
}

void
ra_add_node_interference(struct ra_graph *g,
			 unsigned int n1, unsigned int n2)
{
   if (!BITSET_TEST(g->nodes[n1].adjacency, n2)) {
      ra_add_node_adjacency(g, n1, n2);
      ra_add_node_adjacency(g, n2, n1);
   }
}

static bool
pq_test(struct ra_graph *g, unsigned int n)
{
   unsigned int j;
   unsigned int q = 0;
   int n_class = g->nodes[n].class;

   for (j = 0; j < g->nodes[n].adjacency_count; j++) {
      unsigned int n2 = g->nodes[n].adjacency_list[j];
      unsigned int n2_class = g->nodes[n2].class;

      if (n != n2 && !g->nodes[n2].in_stack) {
	 q += g->regs->classes[n_class]->q[n2_class];
      }
   }

   return q < g->regs->classes[n_class]->p;
}

/**
 * Simplifies the interference graph by pushing all
 * trivially-colorable nodes into a stack of nodes to be colored,
 * removing them from the graph, and rinsing and repeating.
 *
 * Returns true if all nodes were removed from the graph.  false
 * means that either spilling will be required, or optimistic coloring
 * should be applied.
 */
bool
ra_simplify(struct ra_graph *g)
{
   bool progress = true;
   int i;

   while (progress) {
      progress = false;

      for (i = g->count - 1; i >= 0; i--) {
	 if (g->nodes[i].in_stack || g->nodes[i].reg != NO_REG)
	    continue;

	 if (pq_test(g, i)) {
	    g->stack[g->stack_count] = i;
	    g->stack_count++;
	    g->nodes[i].in_stack = true;
	    progress = true;
	 }
      }
   }

   for (i = 0; i < g->count; i++) {
      if (!g->nodes[i].in_stack && g->nodes[i].reg == -1)
	 return false;
   }

   return true;
}

/**
 * Pops nodes from the stack back into the graph, coloring them with
 * registers as they go.
 *
 * If all nodes were trivially colorable, then this must succeed.  If
 * not (optimistic coloring), then it may return false;
 */
bool
ra_select(struct ra_graph *g)
{
   int i;
   int start_search_reg = 0;

   while (g->stack_count != 0) {
      unsigned int ri;
      unsigned int r = -1;
      int n = g->stack[g->stack_count - 1];
      struct ra_class *c = g->regs->classes[g->nodes[n].class];

      /* Find the lowest-numbered reg which is not used by a member
       * of the graph adjacent to us.
       */
      for (ri = 0; ri < g->regs->count; ri++) {
         r = (start_search_reg + ri) % g->regs->count;
         if (!reg_belongs_to_class(r, c))
	    continue;

	 /* Check if any of our neighbors conflict with this register choice. */
	 for (i = 0; i < g->nodes[n].adjacency_count; i++) {
	    unsigned int n2 = g->nodes[n].adjacency_list[i];

	    if (!g->nodes[n2].in_stack &&
		BITSET_TEST(g->regs->regs[r].conflicts, g->nodes[n2].reg)) {
	       break;
	    }
	 }
	 if (i == g->nodes[n].adjacency_count)
	    break;
      }
      if (ri == g->regs->count)
	 return false;

      g->nodes[n].reg = r;
      g->nodes[n].in_stack = false;
      g->stack_count--;

      if (g->regs->round_robin)
         start_search_reg = r + 1;
   }

   return true;
}

/**
 * Optimistic register coloring: Just push the remaining nodes
 * on the stack.  They'll be colored first in ra_select(), and
 * if they succeed then the locally-colorable nodes are still
 * locally-colorable and the rest of the register allocation
 * will succeed.
 */
void
ra_optimistic_color(struct ra_graph *g)
{
   unsigned int i;

   g->stack_optimistic_start = g->stack_count;
   for (i = 0; i < g->count; i++) {
      if (g->nodes[i].in_stack || g->nodes[i].reg != NO_REG)
	 continue;

      g->stack[g->stack_count] = i;
      g->stack_count++;
      g->nodes[i].in_stack = true;
   }
}

bool
ra_allocate_no_spills(struct ra_graph *g)
{
   if (!ra_simplify(g)) {
      ra_optimistic_color(g);
   }
   return ra_select(g);
}

unsigned int
ra_get_node_reg(struct ra_graph *g, unsigned int n)
{
   return g->nodes[n].reg;
}

/**
 * Forces a node to a specific register.  This can be used to avoid
 * creating a register class containing one node when handling data
 * that must live in a fixed location and is known to not conflict
 * with other forced register assignment (as is common with shader
 * input data).  These nodes do not end up in the stack during
 * ra_simplify(), and thus at ra_select() time it is as if they were
 * the first popped off the stack and assigned their fixed locations.
 * Nodes that use this function do not need to be assigned a register
 * class.
 *
 * Must be called before ra_simplify().
 */
void
ra_set_node_reg(struct ra_graph *g, unsigned int n, unsigned int reg)
{
   g->nodes[n].reg = reg;
   g->nodes[n].in_stack = false;
}

static float
ra_get_spill_benefit(struct ra_graph *g, unsigned int n)
{
   int j;
   float benefit = 0;
   int n_class = g->nodes[n].class;

   /* Define the benefit of eliminating an interference between n, n2
    * through spilling as q(C, B) / p(C).  This is similar to the
    * "count number of edges" approach of traditional graph coloring,
    * but takes classes into account.
    */
   for (j = 0; j < g->nodes[n].adjacency_count; j++) {
      unsigned int n2 = g->nodes[n].adjacency_list[j];
      if (n != n2) {
	 unsigned int n2_class = g->nodes[n2].class;
	 benefit += ((float)g->regs->classes[n_class]->q[n2_class] /
		     g->regs->classes[n_class]->p);
      }
   }

   return benefit;
}

/**
 * Returns a node number to be spilled according to the cost/benefit using
 * the pq test, or -1 if there are no spillable nodes.
 */
int
ra_get_best_spill_node(struct ra_graph *g)
{
   unsigned int best_node = -1;
   float best_benefit = 0.0;
   unsigned int n, i;

   /* For any registers not in the stack to be colored, consider them for
    * spilling.  This will mostly collect nodes that were being optimistally
    * colored as part of ra_allocate_no_spills() if we didn't successfully
    * optimistically color.
    *
    * It also includes nodes not trivially colorable by ra_simplify() if it
    * was used directly instead of as part of ra_allocate_no_spills().
    */
   for (n = 0; n < g->count; n++) {
      float cost = g->nodes[n].spill_cost;
      float benefit;

      if (cost <= 0.0)
	 continue;

      if (g->nodes[n].in_stack)
         continue;

      benefit = ra_get_spill_benefit(g, n);

      if (benefit / cost > best_benefit) {
	 best_benefit = benefit / cost;
	 best_node = n;
      }
   }

   /* Also consider spilling any nodes that were set up to be optimistically
    * colored that we couldn't manage to color in ra_select().
    */
   for (i = g->stack_optimistic_start; i < g->stack_count; i++) {
      float cost, benefit;

      n = g->stack[i];
      cost = g->nodes[n].spill_cost;

      if (cost <= 0.0)
         continue;

      benefit = ra_get_spill_benefit(g, n);

      if (benefit / cost > best_benefit) {
         best_benefit = benefit / cost;
         best_node = n;
      }
   }

   return best_node;
}

/**
 * Only nodes with a spill cost set (cost != 0.0) will be considered
 * for register spilling.
 */
void
ra_set_node_spill_cost(struct ra_graph *g, unsigned int n, float cost)
{
   g->nodes[n].spill_cost = cost;
}
@


1.6
log
@Merge Mesa 10.2.9
@
text
@@


1.5
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.3
log
@Merge Mesa 9.2.0
@
text
@d85 1
a85 1
   GLboolean *conflicts;
d102 6
a107 1
   GLboolean *regs;
d147 1
a147 1
   GLboolean in_stack;
d194 3
a196 2
      regs->regs[i].conflicts = rzalloc_array(regs->regs, GLboolean, count);
      regs->regs[i].conflicts[i] = GL_TRUE;
d234 1
a234 1
   reg1->conflicts[r2] = GL_TRUE;
d240 1
a240 1
   if (!regs->regs[r1].conflicts[r2]) {
d278 1
a278 1
   class->regs = rzalloc_array(class, GLboolean, regs->count);
d288 1
a288 1
   class->regs[r] = GL_TRUE;
d293 9
d337 1
a337 1
	    if (!regs->classes[c]->regs[rc])
d342 1
a342 1
	       if (regs->classes[b]->regs[rb])
d415 2
a416 1
static GLboolean pq_test(struct ra_graph *g, unsigned int n)
d439 1
a439 1
 * Returns GL_TRUE if all nodes were removed from the graph.  GL_FALSE
d443 1
a443 1
GLboolean
d446 1
a446 1
   GLboolean progress = GL_TRUE;
d450 1
a450 1
      progress = GL_FALSE;
d459 2
a460 2
	    g->nodes[i].in_stack = GL_TRUE;
	    progress = GL_TRUE;
d467 1
a467 1
	 return GL_FALSE;
d470 1
a470 1
   return GL_TRUE;
d478 1
a478 1
 * not (optimistic coloring), then it may return GL_FALSE;
d480 1
a480 1
GLboolean
d497 1
a497 1
	 if (!c->regs[r])
d505 1
a505 1
		g->regs->regs[r].conflicts[g->nodes[n2].reg]) {
d513 1
a513 1
	 return GL_FALSE;
d516 1
a516 1
      g->nodes[n].in_stack = GL_FALSE;
d523 1
a523 1
   return GL_TRUE;
d545 1
a545 1
      g->nodes[i].in_stack = GL_TRUE;
d549 1
a549 1
GLboolean
d581 1
a581 1
   g->nodes[n].in_stack = GL_FALSE;
@


1.2
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d73 1
d79 1
d97 2
d125 1
a125 1
   GLboolean *adjacency;
d127 1
d160 10
d172 6
d179 1
a179 1
ra_alloc_reg_set(unsigned int count)
d184 1
a184 1
   regs = rzalloc(NULL, struct ra_regs);
d201 16
d240 21
d289 2
d293 1
a293 1
ra_set_finalize(struct ra_regs *regs)
d301 9
d340 10
a349 1
   g->nodes[n1].adjacency[n2] = GL_TRUE;
d368 6
a373 2
      g->nodes[i].adjacency = rzalloc_array(g, GLboolean, count);
      g->nodes[i].adjacency_list = ralloc_array(g, unsigned int, count);
d375 1
d394 1
a394 1
   if (!g->nodes[n1].adjacency[n2]) {
d450 1
a450 1
      if (!g->nodes[i].in_stack)
d468 1
d471 2
a472 1
      unsigned int r;
d479 2
a480 1
      for (r = 0; r < g->regs->count; r++) {
d496 1
a496 1
      if (r == g->regs->count)
d502 3
d522 1
d556 2
d600 2
a601 2
   unsigned int best_benefit = 0.0;
   unsigned int n;
d603 8
d618 3
d626 20
@


1.1
log
@Initial revision
@
text
@d31 40
d80 2
a82 1
   char *name;
d84 3
d101 1
a101 1
    * p_B in Runeson/Nyström paper.
d108 3
a110 1
    * q_B,C in Runeson/Nyström paper.
d116 5
d122 4
d127 2
a128 1
   unsigned int adjacency_count;
d130 7
d138 4
d170 5
d180 14
d197 4
a200 2
   regs->regs[r1].conflicts[r2] = GL_TRUE;
   regs->regs[r2].conflicts[r1] = GL_TRUE;
a249 1
	    unsigned int rb;
d251 1
d256 3
a258 3
	    for (rb = 0; rb < regs->count; rb++) {
	       if (regs->classes[b]->regs[rb] &&
		   regs->regs[rb].conflicts[rc])
d268 8
d291 4
a294 2
      g->nodes[i].adjacency[i] = GL_TRUE;
      g->nodes[i].reg = ~0;
d311 4
a314 7
   if (g->nodes[n1].adjacency[n2])
      return;

   g->nodes[n1].adjacency[n2] = GL_TRUE;
   g->nodes[n2].adjacency_count++;
   g->nodes[n2].adjacency[n1] = GL_TRUE;
   g->nodes[n2].adjacency_count++;
d323 3
a325 3
   for (j = 0; j < g->count; j++) {
      if (j == n || g->nodes[j].in_stack)
	 continue;
d327 2
a328 3
      if (g->nodes[n].adjacency[j]) {
	 unsigned int j_class = g->nodes[j].class;
	 q += g->regs->classes[n_class]->q[j_class];
d354 1
a354 1
	 if (g->nodes[i].in_stack)
d399 5
a403 4
	 for (i = 0; i < g->count; i++) {
	    if (g->nodes[n].adjacency[i] &&
	       !g->nodes[i].in_stack &&
		g->regs->regs[r].conflicts[g->nodes[i].reg]) {
d407 1
a407 1
	 if (i == g->count)
d434 1
a434 1
      if (g->nodes[i].in_stack)
d458 18
d483 1
a483 1
   /* Define the benefit of eliminating an interference between n, j
d488 5
a492 4
   for (j = 0; j < g->count; j++) {
      if (j != n && g->nodes[n].adjacency[j]) {
	 unsigned int j_class = g->nodes[j].class;
	 benefit += ((float)g->regs->classes[n_class]->q[j_class] /
a493 1
	 break;
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a30 40
 *
 * The basic idea of graph coloring is to make a node in a graph for
 * every thing that needs a register (color) number assigned, and make
 * edges in the graph between nodes that interfere (can't be allocated
 * to the same register at the same time).
 *
 * During the "simplify" process, any any node with fewer edges than
 * there are registers means that that edge can get assigned a
 * register regardless of what its neighbors choose, so that node is
 * pushed on a stack and removed (with its edges) from the graph.
 * That likely causes other nodes to become trivially colorable as well.
 *
 * Then during the "select" process, nodes are popped off of that
 * stack, their edges restored, and assigned a color different from
 * their neighbors.  Because they were pushed on the stack only when
 * they were trivially colorable, any color chosen won't interfere
 * with the registers to be popped later.
 *
 * The downside to most graph coloring is that real hardware often has
 * limitations, like registers that need to be allocated to a node in
 * pairs, or aligned on some boundary.  This implementation follows
 * the paper "Retargetable Graph-Coloring Register Allocation for
 * Irregular Architectures" by Johan Runeson and Sven-Olof Nyström.
 *
 * In this system, there are register classes each containing various
 * registers, and registers may interfere with other registers.  For
 * example, one might have a class of base registers, and a class of
 * aligned register pairs that would each interfere with their pair of
 * the base registers.  Each node has a register class it needs to be
 * assigned to.  Define p(B) to be the size of register class B, and
 * q(B,C) to be the number of registers in B that the worst choice
 * register in C could conflict with.  Then, this system replaces the
 * basic graph coloring test of "fewer edges from this node than there
 * are registers" with "For this node of class B, the sum of q(B,C)
 * for each neighbor node of class C is less than pB".
 *
 * A nice feature of the pq test is that q(B,C) can be computed once
 * up front and stored in a 2-dimensional array, so that the cost of
 * coloring a node is constant with the number of registers.  We do
 * this during ra_set_finalize().
a32 1
#include <stdbool.h>
a37 1
#include "main/bitset.h"
a39 2
#define NO_REG ~0

d41 1
a42 3
   unsigned int *conflict_list;
   unsigned int conflict_list_size;
   unsigned int num_conflicts;
a50 2

   bool round_robin;
d57 1
a57 1
    * p(B) in Runeson/Nyström paper.
d64 1
a64 3
    * q(B,C) (indexed by C, B is this register class) in
    * Runeson/Nyström paper.  This is "how many registers of B could
    * the worst choice register from C conflict with".
d70 2
a71 8
   /** @@{
    *
    * List of which nodes this node interferes with.  This should be
    * symmetric with the other node.
    */
   BITSET_WORD *adjacency;
   unsigned int *adjacency_list;
   unsigned int adjacency_list_size;
a72 5
   /** @@} */

   unsigned int class;

   /* Register, if assigned, or NO_REG. */
a73 7

   /**
    * Set when the node is in the trivially colorable stack.  When
    * set, the adjacency to this node is ignored, to implement the
    * "remove the edge from the graph" in simplification without
    * having to actually modify the adjacency_list.
    */
a74 4

   /* For an implementation that needs register spilling, this is the
    * approximate cost of spilling this node.
    */
a87 10

   /**
    * Tracks the start of the set of optimistically-colored registers in the
    * stack.
    *
    * Along with any registers not in the stack (if one called ra_simplify()
    * and didn't do optimistic coloring), these need to be considered for
    * spilling.
    */
   unsigned int stack_optimistic_start;
a89 6
/**
 * Creates a set of registers for the allocator.
 *
 * mem_ctx is a ralloc context for the allocator.  The reg set may be freed
 * using ralloc_free().
 */
d91 1
a91 1
ra_alloc_reg_set(void *mem_ctx, unsigned int count)
d96 1
a96 1
   regs = rzalloc(mem_ctx, struct ra_regs);
a102 5

      regs->regs[i].conflict_list = ralloc_array(regs->regs, unsigned int, 4);
      regs->regs[i].conflict_list_size = 4;
      regs->regs[i].conflict_list[0] = i;
      regs->regs[i].num_conflicts = 1;
a107 30
/**
 * The register allocator by default prefers to allocate low register numbers,
 * since it was written for hardware (gen4/5 Intel) that is limited in its
 * multithreadedness by the number of registers used in a given shader.
 *
 * However, for hardware without that restriction, densely packed register
 * allocation can put serious constraints on instruction scheduling.  This
 * function tells the allocator to rotate around the registers if possible as
 * it allocates the nodes.
 */
void
ra_set_allocate_round_robin(struct ra_regs *regs)
{
   regs->round_robin = true;
}

static void
ra_add_conflict_list(struct ra_regs *regs, unsigned int r1, unsigned int r2)
{
   struct ra_reg *reg1 = &regs->regs[r1];

   if (reg1->conflict_list_size == reg1->num_conflicts) {
      reg1->conflict_list_size *= 2;
      reg1->conflict_list = reralloc(regs->regs, reg1->conflict_list,
				     unsigned int, reg1->conflict_list_size);
   }
   reg1->conflict_list[reg1->num_conflicts++] = r2;
   reg1->conflicts[r2] = GL_TRUE;
}

d111 2
a112 25
   if (!regs->regs[r1].conflicts[r2]) {
      ra_add_conflict_list(regs, r1, r2);
      ra_add_conflict_list(regs, r2, r1);
   }
}

/**
 * Adds a conflict between base_reg and reg, and also between reg and
 * anything that base_reg conflicts with.
 *
 * This can simplify code for setting up multiple register classes
 * which are aggregates of some base hardware registers, compared to
 * explicitly using ra_add_reg_conflict.
 */
void
ra_add_transitive_reg_conflict(struct ra_regs *regs,
			       unsigned int base_reg, unsigned int reg)
{
   int i;

   ra_add_reg_conflict(regs, reg, base_reg);

   for (i = 0; i < regs->regs[base_reg].num_conflicts; i++) {
      ra_add_reg_conflict(regs, reg, regs->regs[base_reg].conflict_list[i]);
   }
a142 2
 * To avoid costly q value computation, use the q_values paramater
 * to pass precomputed q values to this function.
d145 1
a145 1
ra_set_finalize(struct ra_regs *regs, unsigned int **q_values)
a152 9
   if (q_values) {
      for (b = 0; b < regs->class_count; b++) {
         for (c = 0; c < regs->class_count; c++) {
            regs->classes[b]->q[c] = q_values[b][c];
	 }
      }
      return;
   }

d162 1
a163 1
	    int i;
d168 3
a170 3
	    for (i = 0; i < regs->regs[rc].num_conflicts; i++) {
	       unsigned int rb = regs->regs[rc].conflict_list[i];
	       if (regs->classes[b]->regs[rb])
a179 17
static void
ra_add_node_adjacency(struct ra_graph *g, unsigned int n1, unsigned int n2)
{
   BITSET_SET(g->nodes[n1].adjacency, n2);

   if (g->nodes[n1].adjacency_count >=
       g->nodes[n1].adjacency_list_size) {
      g->nodes[n1].adjacency_list_size *= 2;
      g->nodes[n1].adjacency_list = reralloc(g, g->nodes[n1].adjacency_list,
                                             unsigned int,
                                             g->nodes[n1].adjacency_list_size);
   }

   g->nodes[n1].adjacency_list[g->nodes[n1].adjacency_count] = n2;
   g->nodes[n1].adjacency_count++;
}

d194 3
a196 10
      int bitset_count = BITSET_WORDS(count);
      g->nodes[i].adjacency = rzalloc_array(g, BITSET_WORD, bitset_count);

      g->nodes[i].adjacency_list_size = 4;
      g->nodes[i].adjacency_list =
         ralloc_array(g, unsigned int, g->nodes[i].adjacency_list_size);
      g->nodes[i].adjacency_count = 0;

      ra_add_node_adjacency(g, i, i);
      g->nodes[i].reg = NO_REG;
d213 7
a219 4
   if (!BITSET_TEST(g->nodes[n1].adjacency, n2)) {
      ra_add_node_adjacency(g, n1, n2);
      ra_add_node_adjacency(g, n2, n1);
   }
d228 3
a230 3
   for (j = 0; j < g->nodes[n].adjacency_count; j++) {
      unsigned int n2 = g->nodes[n].adjacency_list[j];
      unsigned int n2_class = g->nodes[n2].class;
d232 3
a234 2
      if (n != n2 && !g->nodes[n2].in_stack) {
	 q += g->regs->classes[n_class]->q[n2_class];
d260 1
a260 1
	 if (g->nodes[i].in_stack || g->nodes[i].reg != NO_REG)
d273 1
a273 1
      if (!g->nodes[i].in_stack && g->nodes[i].reg == -1)
a290 1
   int start_search_reg = 0;
d293 1
a293 2
      unsigned int ri;
      unsigned int r = -1;
d300 1
a300 2
      for (ri = 0; ri < g->regs->count; ri++) {
         r = (start_search_reg + ri) % g->regs->count;
d305 4
a308 5
	 for (i = 0; i < g->nodes[n].adjacency_count; i++) {
	    unsigned int n2 = g->nodes[n].adjacency_list[i];

	    if (!g->nodes[n2].in_stack &&
		g->regs->regs[r].conflicts[g->nodes[n2].reg]) {
d312 1
a312 1
	 if (i == g->nodes[n].adjacency_count)
d315 1
a315 1
      if (ri == g->regs->count)
a320 3

      if (g->regs->round_robin)
         start_search_reg = r + 1;
a337 1
   g->stack_optimistic_start = g->stack_count;
d339 1
a339 1
      if (g->nodes[i].in_stack || g->nodes[i].reg != NO_REG)
a362 20
/**
 * Forces a node to a specific register.  This can be used to avoid
 * creating a register class containing one node when handling data
 * that must live in a fixed location and is known to not conflict
 * with other forced register assignment (as is common with shader
 * input data).  These nodes do not end up in the stack during
 * ra_simplify(), and thus at ra_select() time it is as if they were
 * the first popped off the stack and assigned their fixed locations.
 * Nodes that use this function do not need to be assigned a register
 * class.
 *
 * Must be called before ra_simplify().
 */
void
ra_set_node_reg(struct ra_graph *g, unsigned int n, unsigned int reg)
{
   g->nodes[n].reg = reg;
   g->nodes[n].in_stack = GL_FALSE;
}

d370 1
a370 1
   /* Define the benefit of eliminating an interference between n, n2
d375 4
a378 5
   for (j = 0; j < g->nodes[n].adjacency_count; j++) {
      unsigned int n2 = g->nodes[n].adjacency_list[j];
      if (n != n2) {
	 unsigned int n2_class = g->nodes[n2].class;
	 benefit += ((float)g->regs->classes[n_class]->q[n2_class] /
d380 1
d395 2
a396 2
   float best_benefit = 0.0;
   unsigned int n, i;
a397 8
   /* For any registers not in the stack to be colored, consider them for
    * spilling.  This will mostly collect nodes that were being optimistally
    * colored as part of ra_allocate_no_spills() if we didn't successfully
    * optimistically color.
    *
    * It also includes nodes not trivially colorable by ra_simplify() if it
    * was used directly instead of as part of ra_allocate_no_spills().
    */
a404 3
      if (g->nodes[n].in_stack)
         continue;

a409 20
      }
   }

   /* Also consider spilling any nodes that were set up to be optimistically
    * colored that we couldn't manage to color in ra_select().
    */
   for (i = g->stack_optimistic_start; i < g->stack_count; i++) {
      float cost, benefit;

      n = g->stack[i];
      cost = g->nodes[n].spill_cost;

      if (cost <= 0.0)
         continue;

      benefit = ra_get_spill_benefit(g, n);

      if (benefit / cost > best_benefit) {
         best_benefit = benefit / cost;
         best_node = n;
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d85 1
a85 1
   BITSET_WORD *conflicts;
d102 1
a102 6
   /**
    * Bitset indicating which registers belong to this class.
    *
    * (If bit N is set, then register N belongs to this class.)
    */
   BITSET_WORD *regs;
d142 1
a142 1
   bool in_stack;
d189 2
a190 3
      regs->regs[i].conflicts = rzalloc_array(regs->regs, BITSET_WORD,
                                              BITSET_WORDS(count));
      BITSET_SET(regs->regs[i].conflicts, i);
d228 1
a228 1
   BITSET_SET(reg1->conflicts, r2);
d234 1
a234 1
   if (!BITSET_TEST(regs->regs[r1].conflicts, r2)) {
d272 1
a272 1
   class->regs = rzalloc_array(class, BITSET_WORD, BITSET_WORDS(regs->count));
d282 1
a282 1
   BITSET_SET(class->regs, r);
a286 9
 * Returns true if the register belongs to the given class.
 */
static bool
reg_belongs_to_class(unsigned int r, struct ra_class *c)
{
   return BITSET_TEST(c->regs, r);
}

/**
d322 1
a322 1
            if (!reg_belongs_to_class(rc, regs->classes[c]))
d327 1
a327 1
	       if (BITSET_TEST(regs->classes[b]->regs, rb))
d400 1
a400 2
static bool
pq_test(struct ra_graph *g, unsigned int n)
d423 1
a423 1
 * Returns true if all nodes were removed from the graph.  false
d427 1
a427 1
bool
d430 1
a430 1
   bool progress = true;
d434 1
a434 1
      progress = false;
d443 2
a444 2
	    g->nodes[i].in_stack = true;
	    progress = true;
d451 1
a451 1
	 return false;
d454 1
a454 1
   return true;
d462 1
a462 1
 * not (optimistic coloring), then it may return false;
d464 1
a464 1
bool
d481 1
a481 1
         if (!reg_belongs_to_class(r, c))
d489 1
a489 1
		BITSET_TEST(g->regs->regs[r].conflicts, g->nodes[n2].reg)) {
d497 1
a497 1
	 return false;
d500 1
a500 1
      g->nodes[n].in_stack = false;
d507 1
a507 1
   return true;
d529 1
a529 1
      g->nodes[i].in_stack = true;
d533 1
a533 1
bool
d565 1
a565 1
   g->nodes[n].in_stack = false;
@


