head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@// @;


1.7
date	2015.12.23.05.17.54;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.5;
commitid	4ry2gvZGMXkCUD2n;

1.5
date	2015.01.25.14.41.22;	author jsg;	state Exp;
branches;
next	1.4;
commitid	mcxB0JvoI9gTDYXU;

1.4
date	2014.07.09.21.09.00;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.06.37;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.17.13.58.20;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.23.13.29.47;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.47;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.17.07;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.35.08;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.13.09;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.50.16;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright (C) 2005-2007  Brian Paul   All Rights Reserved.
 * Copyright (C) 2008  VMware, Inc.   All Rights Reserved.
 * Copyright Â© 2010 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 * \file ir_to_mesa.cpp
 *
 * Translate GLSL IR to Mesa's gl_program representation.
 */

#include <stdio.h>
#include "main/compiler.h"
#include "ir.h"
#include "ir_visitor.h"
#include "ir_expression_flattening.h"
#include "ir_uniform.h"
#include "glsl_types.h"
#include "glsl_parser_extras.h"
#include "../glsl/program.h"
#include "ir_optimization.h"
#include "ast.h"
#include "linker.h"

#include "main/mtypes.h"
#include "main/shaderobj.h"
#include "main/uniforms.h"
#include "program/hash_table.h"

extern "C" {
#include "main/shaderapi.h"
#include "program/prog_instruction.h"
#include "program/prog_optimize.h"
#include "program/prog_print.h"
#include "program/program.h"
#include "program/prog_parameter.h"
#include "program/sampler.h"
}

static int swizzle_for_size(int size);

namespace {

class src_reg;
class dst_reg;

/**
 * This struct is a corresponding struct to Mesa prog_src_register, with
 * wider fields.
 */
class src_reg {
public:
   src_reg(gl_register_file file, int index, const glsl_type *type)
   {
      this->file = file;
      this->index = index;
      if (type && (type->is_scalar() || type->is_vector() || type->is_matrix()))
	 this->swizzle = swizzle_for_size(type->vector_elements);
      else
	 this->swizzle = SWIZZLE_XYZW;
      this->negate = 0;
      this->reladdr = NULL;
   }

   src_reg()
   {
      this->file = PROGRAM_UNDEFINED;
      this->index = 0;
      this->swizzle = 0;
      this->negate = 0;
      this->reladdr = NULL;
   }

   explicit src_reg(dst_reg reg);

   gl_register_file file; /**< PROGRAM_* from Mesa */
   int index; /**< temporary index, VERT_ATTRIB_*, VARYING_SLOT_*, etc. */
   GLuint swizzle; /**< SWIZZLE_XYZWONEZERO swizzles from Mesa. */
   int negate; /**< NEGATE_XYZW mask from mesa */
   /** Register index should be offset by the integer in this reg. */
   src_reg *reladdr;
};

class dst_reg {
public:
   dst_reg(gl_register_file file, int writemask)
   {
      this->file = file;
      this->index = 0;
      this->writemask = writemask;
      this->cond_mask = COND_TR;
      this->reladdr = NULL;
   }

   dst_reg()
   {
      this->file = PROGRAM_UNDEFINED;
      this->index = 0;
      this->writemask = 0;
      this->cond_mask = COND_TR;
      this->reladdr = NULL;
   }

   explicit dst_reg(src_reg reg);

   gl_register_file file; /**< PROGRAM_* from Mesa */
   int index; /**< temporary index, VERT_ATTRIB_*, VARYING_SLOT_*, etc. */
   int writemask; /**< Bitfield of WRITEMASK_[XYZW] */
   GLuint cond_mask:4;
   /** Register index should be offset by the integer in this reg. */
   src_reg *reladdr;
};

} /* anonymous namespace */

src_reg::src_reg(dst_reg reg)
{
   this->file = reg.file;
   this->index = reg.index;
   this->swizzle = SWIZZLE_XYZW;
   this->negate = 0;
   this->reladdr = reg.reladdr;
}

dst_reg::dst_reg(src_reg reg)
{
   this->file = reg.file;
   this->index = reg.index;
   this->writemask = WRITEMASK_XYZW;
   this->cond_mask = COND_TR;
   this->reladdr = reg.reladdr;
}

namespace {

class ir_to_mesa_instruction : public exec_node {
public:
   DECLARE_RALLOC_CXX_OPERATORS(ir_to_mesa_instruction)

   enum prog_opcode op;
   dst_reg dst;
   src_reg src[3];
   /** Pointer to the ir source this tree came from for debugging */
   ir_instruction *ir;
   GLboolean cond_update;
   bool saturate;
   int sampler; /**< sampler index */
   int tex_target; /**< One of TEXTURE_*_INDEX */
   GLboolean tex_shadow;
};

class variable_storage : public exec_node {
public:
   variable_storage(ir_variable *var, gl_register_file file, int index)
      : file(file), index(index), var(var)
   {
      /* empty */
   }

   gl_register_file file;
   int index;
   ir_variable *var; /* variable that maps to this, if any */
};

class function_entry : public exec_node {
public:
   ir_function_signature *sig;

   /**
    * identifier of this function signature used by the program.
    *
    * At the point that Mesa instructions for function calls are
    * generated, we don't know the address of the first instruction of
    * the function body.  So we make the BranchTarget that is called a
    * small integer and rewrite them during set_branchtargets().
    */
   int sig_id;

   /**
    * Pointer to first instruction of the function body.
    *
    * Set during function body emits after main() is processed.
    */
   ir_to_mesa_instruction *bgn_inst;

   /**
    * Index of the first instruction of the function body in actual
    * Mesa IR.
    *
    * Set after convertion from ir_to_mesa_instruction to prog_instruction.
    */
   int inst;

   /** Storage for the return value. */
   src_reg return_reg;
};

class ir_to_mesa_visitor : public ir_visitor {
public:
   ir_to_mesa_visitor();
   ~ir_to_mesa_visitor();

   function_entry *current_function;

   struct gl_context *ctx;
   struct gl_program *prog;
   struct gl_shader_program *shader_program;
   struct gl_shader_compiler_options *options;

   int next_temp;

   variable_storage *find_variable_storage(const ir_variable *var);

   src_reg get_temp(const glsl_type *type);
   void reladdr_to_temp(ir_instruction *ir, src_reg *reg, int *num_reladdr);

   src_reg src_reg_for_float(float val);

   /**
    * \name Visit methods
    *
    * As typical for the visitor pattern, there must be one \c visit method for
    * each concrete subclass of \c ir_instruction.  Virtual base classes within
    * the hierarchy should not have \c visit methods.
    */
   /*@@{*/
   virtual void visit(ir_variable *);
   virtual void visit(ir_loop *);
   virtual void visit(ir_loop_jump *);
   virtual void visit(ir_function_signature *);
   virtual void visit(ir_function *);
   virtual void visit(ir_expression *);
   virtual void visit(ir_swizzle *);
   virtual void visit(ir_dereference_variable  *);
   virtual void visit(ir_dereference_array *);
   virtual void visit(ir_dereference_record *);
   virtual void visit(ir_assignment *);
   virtual void visit(ir_constant *);
   virtual void visit(ir_call *);
   virtual void visit(ir_return *);
   virtual void visit(ir_discard *);
   virtual void visit(ir_texture *);
   virtual void visit(ir_if *);
   virtual void visit(ir_emit_vertex *);
   virtual void visit(ir_end_primitive *);
   /*@@}*/

   src_reg result;

   /** List of variable_storage */
   exec_list variables;

   /** List of function_entry */
   exec_list function_signatures;
   int next_signature_id;

   /** List of ir_to_mesa_instruction */
   exec_list instructions;

   ir_to_mesa_instruction *emit(ir_instruction *ir, enum prog_opcode op);

   ir_to_mesa_instruction *emit(ir_instruction *ir, enum prog_opcode op,
			        dst_reg dst, src_reg src0);

   ir_to_mesa_instruction *emit(ir_instruction *ir, enum prog_opcode op,
			        dst_reg dst, src_reg src0, src_reg src1);

   ir_to_mesa_instruction *emit(ir_instruction *ir, enum prog_opcode op,
			        dst_reg dst,
			        src_reg src0, src_reg src1, src_reg src2);

   /**
    * Emit the correct dot-product instruction for the type of arguments
    */
   ir_to_mesa_instruction * emit_dp(ir_instruction *ir,
				    dst_reg dst,
				    src_reg src0,
				    src_reg src1,
				    unsigned elements);

   void emit_scalar(ir_instruction *ir, enum prog_opcode op,
		    dst_reg dst, src_reg src0);

   void emit_scalar(ir_instruction *ir, enum prog_opcode op,
		    dst_reg dst, src_reg src0, src_reg src1);

   void emit_scs(ir_instruction *ir, enum prog_opcode op,
		 dst_reg dst, const src_reg &src);

   bool try_emit_mad(ir_expression *ir,
			  int mul_operand);
   bool try_emit_mad_for_and_not(ir_expression *ir,
				 int mul_operand);
   bool try_emit_sat(ir_expression *ir);

   void emit_swz(ir_expression *ir);

   bool process_move_condition(ir_rvalue *ir);

   void copy_propagate(void);

   void *mem_ctx;
};

} /* anonymous namespace */

static src_reg undef_src = src_reg(PROGRAM_UNDEFINED, 0, NULL);

static dst_reg undef_dst = dst_reg(PROGRAM_UNDEFINED, SWIZZLE_NOOP);

static dst_reg address_reg = dst_reg(PROGRAM_ADDRESS, WRITEMASK_X);

static int
swizzle_for_size(int size)
{
   static const int size_swizzles[4] = {
      MAKE_SWIZZLE4(SWIZZLE_X, SWIZZLE_X, SWIZZLE_X, SWIZZLE_X),
      MAKE_SWIZZLE4(SWIZZLE_X, SWIZZLE_Y, SWIZZLE_Y, SWIZZLE_Y),
      MAKE_SWIZZLE4(SWIZZLE_X, SWIZZLE_Y, SWIZZLE_Z, SWIZZLE_Z),
      MAKE_SWIZZLE4(SWIZZLE_X, SWIZZLE_Y, SWIZZLE_Z, SWIZZLE_W),
   };

   assert((size >= 1) && (size <= 4));
   return size_swizzles[size - 1];
}

ir_to_mesa_instruction *
ir_to_mesa_visitor::emit(ir_instruction *ir, enum prog_opcode op,
			 dst_reg dst,
			 src_reg src0, src_reg src1, src_reg src2)
{
   ir_to_mesa_instruction *inst = new(mem_ctx) ir_to_mesa_instruction();
   int num_reladdr = 0;

   /* If we have to do relative addressing, we want to load the ARL
    * reg directly for one of the regs, and preload the other reladdr
    * sources into temps.
    */
   num_reladdr += dst.reladdr != NULL;
   num_reladdr += src0.reladdr != NULL;
   num_reladdr += src1.reladdr != NULL;
   num_reladdr += src2.reladdr != NULL;

   reladdr_to_temp(ir, &src2, &num_reladdr);
   reladdr_to_temp(ir, &src1, &num_reladdr);
   reladdr_to_temp(ir, &src0, &num_reladdr);

   if (dst.reladdr) {
      emit(ir, OPCODE_ARL, address_reg, *dst.reladdr);
      num_reladdr--;
   }
   assert(num_reladdr == 0);

   inst->op = op;
   inst->dst = dst;
   inst->src[0] = src0;
   inst->src[1] = src1;
   inst->src[2] = src2;
   inst->ir = ir;

   this->instructions.push_tail(inst);

   return inst;
}


ir_to_mesa_instruction *
ir_to_mesa_visitor::emit(ir_instruction *ir, enum prog_opcode op,
			 dst_reg dst, src_reg src0, src_reg src1)
{
   return emit(ir, op, dst, src0, src1, undef_src);
}

ir_to_mesa_instruction *
ir_to_mesa_visitor::emit(ir_instruction *ir, enum prog_opcode op,
			 dst_reg dst, src_reg src0)
{
   assert(dst.writemask != 0);
   return emit(ir, op, dst, src0, undef_src, undef_src);
}

ir_to_mesa_instruction *
ir_to_mesa_visitor::emit(ir_instruction *ir, enum prog_opcode op)
{
   return emit(ir, op, undef_dst, undef_src, undef_src, undef_src);
}

ir_to_mesa_instruction *
ir_to_mesa_visitor::emit_dp(ir_instruction *ir,
			    dst_reg dst, src_reg src0, src_reg src1,
			    unsigned elements)
{
   static const gl_inst_opcode dot_opcodes[] = {
      OPCODE_DP2, OPCODE_DP3, OPCODE_DP4
   };

   return emit(ir, dot_opcodes[elements - 2], dst, src0, src1);
}

/**
 * Emits Mesa scalar opcodes to produce unique answers across channels.
 *
 * Some Mesa opcodes are scalar-only, like ARB_fp/vp.  The src X
 * channel determines the result across all channels.  So to do a vec4
 * of this operation, we want to emit a scalar per source channel used
 * to produce dest channels.
 */
void
ir_to_mesa_visitor::emit_scalar(ir_instruction *ir, enum prog_opcode op,
			        dst_reg dst,
				src_reg orig_src0, src_reg orig_src1)
{
   int i, j;
   int done_mask = ~dst.writemask;

   /* Mesa RCP is a scalar operation splatting results to all channels,
    * like ARB_fp/vp.  So emit as many RCPs as necessary to cover our
    * dst channels.
    */
   for (i = 0; i < 4; i++) {
      GLuint this_mask = (1 << i);
      ir_to_mesa_instruction *inst;
      src_reg src0 = orig_src0;
      src_reg src1 = orig_src1;

      if (done_mask & this_mask)
	 continue;

      GLuint src0_swiz = GET_SWZ(src0.swizzle, i);
      GLuint src1_swiz = GET_SWZ(src1.swizzle, i);
      for (j = i + 1; j < 4; j++) {
	 /* If there is another enabled component in the destination that is
	  * derived from the same inputs, generate its value on this pass as
	  * well.
	  */
	 if (!(done_mask & (1 << j)) &&
	     GET_SWZ(src0.swizzle, j) == src0_swiz &&
	     GET_SWZ(src1.swizzle, j) == src1_swiz) {
	    this_mask |= (1 << j);
	 }
      }
      src0.swizzle = MAKE_SWIZZLE4(src0_swiz, src0_swiz,
				   src0_swiz, src0_swiz);
      src1.swizzle = MAKE_SWIZZLE4(src1_swiz, src1_swiz,
				  src1_swiz, src1_swiz);

      inst = emit(ir, op, dst, src0, src1);
      inst->dst.writemask = this_mask;
      done_mask |= this_mask;
   }
}

void
ir_to_mesa_visitor::emit_scalar(ir_instruction *ir, enum prog_opcode op,
			        dst_reg dst, src_reg src0)
{
   src_reg undef = undef_src;

   undef.swizzle = SWIZZLE_XXXX;

   emit_scalar(ir, op, dst, src0, undef);
}

/**
 * Emit an OPCODE_SCS instruction
 *
 * The \c SCS opcode functions a bit differently than the other Mesa (or
 * ARB_fragment_program) opcodes.  Instead of splatting its result across all
 * four components of the destination, it writes one value to the \c x
 * component and another value to the \c y component.
 *
 * \param ir        IR instruction being processed
 * \param op        Either \c OPCODE_SIN or \c OPCODE_COS depending on which
 *                  value is desired.
 * \param dst       Destination register
 * \param src       Source register
 */
void
ir_to_mesa_visitor::emit_scs(ir_instruction *ir, enum prog_opcode op,
			     dst_reg dst,
			     const src_reg &src)
{
   /* Vertex programs cannot use the SCS opcode.
    */
   if (this->prog->Target == GL_VERTEX_PROGRAM_ARB) {
      emit_scalar(ir, op, dst, src);
      return;
   }

   const unsigned component = (op == OPCODE_SIN) ? 0 : 1;
   const unsigned scs_mask = (1U << component);
   int done_mask = ~dst.writemask;
   src_reg tmp;

   assert(op == OPCODE_SIN || op == OPCODE_COS);

   /* If there are compnents in the destination that differ from the component
    * that will be written by the SCS instrution, we'll need a temporary.
    */
   if (scs_mask != unsigned(dst.writemask)) {
      tmp = get_temp(glsl_type::vec4_type);
   }

   for (unsigned i = 0; i < 4; i++) {
      unsigned this_mask = (1U << i);
      src_reg src0 = src;

      if ((done_mask & this_mask) != 0)
	 continue;

      /* The source swizzle specified which component of the source generates
       * sine / cosine for the current component in the destination.  The SCS
       * instruction requires that this value be swizzle to the X component.
       * Replace the current swizzle with a swizzle that puts the source in
       * the X component.
       */
      unsigned src0_swiz = GET_SWZ(src.swizzle, i);

      src0.swizzle = MAKE_SWIZZLE4(src0_swiz, src0_swiz,
				   src0_swiz, src0_swiz);
      for (unsigned j = i + 1; j < 4; j++) {
	 /* If there is another enabled component in the destination that is
	  * derived from the same inputs, generate its value on this pass as
	  * well.
	  */
	 if (!(done_mask & (1 << j)) &&
	     GET_SWZ(src0.swizzle, j) == src0_swiz) {
	    this_mask |= (1 << j);
	 }
      }

      if (this_mask != scs_mask) {
	 ir_to_mesa_instruction *inst;
	 dst_reg tmp_dst = dst_reg(tmp);

	 /* Emit the SCS instruction.
	  */
	 inst = emit(ir, OPCODE_SCS, tmp_dst, src0);
	 inst->dst.writemask = scs_mask;

	 /* Move the result of the SCS instruction to the desired location in
	  * the destination.
	  */
	 tmp.swizzle = MAKE_SWIZZLE4(component, component,
				     component, component);
	 inst = emit(ir, OPCODE_SCS, dst, tmp);
	 inst->dst.writemask = this_mask;
      } else {
	 /* Emit the SCS instruction to write directly to the destination.
	  */
	 ir_to_mesa_instruction *inst = emit(ir, OPCODE_SCS, dst, src0);
	 inst->dst.writemask = scs_mask;
      }

      done_mask |= this_mask;
   }
}

src_reg
ir_to_mesa_visitor::src_reg_for_float(float val)
{
   src_reg src(PROGRAM_CONSTANT, -1, NULL);

   src.index = _mesa_add_unnamed_constant(this->prog->Parameters,
					  (const gl_constant_value *)&val, 1, &src.swizzle);

   return src;
}

static int
type_size(const struct glsl_type *type)
{
   unsigned int i;
   int size;

   switch (type->base_type) {
   case GLSL_TYPE_UINT:
   case GLSL_TYPE_INT:
   case GLSL_TYPE_FLOAT:
   case GLSL_TYPE_BOOL:
      if (type->is_matrix()) {
	 return type->matrix_columns;
      } else {
	 /* Regardless of size of vector, it gets a vec4. This is bad
	  * packing for things like floats, but otherwise arrays become a
	  * mess.  Hopefully a later pass over the code can pack scalars
	  * down if appropriate.
	  */
	 return 1;
      }
   case GLSL_TYPE_ARRAY:
      assert(type->length > 0);
      return type_size(type->fields.array) * type->length;
   case GLSL_TYPE_STRUCT:
      size = 0;
      for (i = 0; i < type->length; i++) {
	 size += type_size(type->fields.structure[i].type);
      }
      return size;
   case GLSL_TYPE_SAMPLER:
   case GLSL_TYPE_IMAGE:
      /* Samplers take up one slot in UNIFORMS[], but they're baked in
       * at link time.
       */
      return 1;
   case GLSL_TYPE_ATOMIC_UINT:
   case GLSL_TYPE_VOID:
   case GLSL_TYPE_ERROR:
   case GLSL_TYPE_INTERFACE:
      assert(!"Invalid type in type_size");
      break;
   }

   return 0;
}

/**
 * In the initial pass of codegen, we assign temporary numbers to
 * intermediate results.  (not SSA -- variable assignments will reuse
 * storage).  Actual register allocation for the Mesa VM occurs in a
 * pass over the Mesa IR later.
 */
src_reg
ir_to_mesa_visitor::get_temp(const glsl_type *type)
{
   src_reg src;

   src.file = PROGRAM_TEMPORARY;
   src.index = next_temp;
   src.reladdr = NULL;
   next_temp += type_size(type);

   if (type->is_array() || type->is_record()) {
      src.swizzle = SWIZZLE_NOOP;
   } else {
      src.swizzle = swizzle_for_size(type->vector_elements);
   }
   src.negate = 0;

   return src;
}

variable_storage *
ir_to_mesa_visitor::find_variable_storage(const ir_variable *var)
{
   variable_storage *entry;

   foreach_list(node, &this->variables) {
      entry = (variable_storage *) node;

      if (entry->var == var)
	 return entry;
   }

   return NULL;
}

void
ir_to_mesa_visitor::visit(ir_variable *ir)
{
   if (strcmp(ir->name, "gl_FragCoord") == 0) {
      struct gl_fragment_program *fp = (struct gl_fragment_program *)this->prog;

      fp->OriginUpperLeft = ir->data.origin_upper_left;
      fp->PixelCenterInteger = ir->data.pixel_center_integer;
   }

   if (ir->data.mode == ir_var_uniform && strncmp(ir->name, "gl_", 3) == 0) {
      unsigned int i;
      const ir_state_slot *const slots = ir->state_slots;
      assert(ir->state_slots != NULL);

      /* Check if this statevar's setup in the STATE file exactly
       * matches how we'll want to reference it as a
       * struct/array/whatever.  If not, then we need to move it into
       * temporary storage and hope that it'll get copy-propagated
       * out.
       */
      for (i = 0; i < ir->num_state_slots; i++) {
	 if (slots[i].swizzle != SWIZZLE_XYZW) {
	    break;
	 }
      }

      variable_storage *storage;
      dst_reg dst;
      if (i == ir->num_state_slots) {
	 /* We'll set the index later. */
	 storage = new(mem_ctx) variable_storage(ir, PROGRAM_STATE_VAR, -1);
	 this->variables.push_tail(storage);

	 dst = undef_dst;
      } else {
	 /* The variable_storage constructor allocates slots based on the size
	  * of the type.  However, this had better match the number of state
	  * elements that we're going to copy into the new temporary.
	  */
	 assert((int) ir->num_state_slots == type_size(ir->type));

	 storage = new(mem_ctx) variable_storage(ir, PROGRAM_TEMPORARY,
						 this->next_temp);
	 this->variables.push_tail(storage);
	 this->next_temp += type_size(ir->type);

	 dst = dst_reg(src_reg(PROGRAM_TEMPORARY, storage->index, NULL));
      }


      for (unsigned int i = 0; i < ir->num_state_slots; i++) {
	 int index = _mesa_add_state_reference(this->prog->Parameters,
					       (gl_state_index *)slots[i].tokens);

	 if (storage->file == PROGRAM_STATE_VAR) {
	    if (storage->index == -1) {
	       storage->index = index;
	    } else {
	       assert(index == storage->index + (int)i);
	    }
	 } else {
	    src_reg src(PROGRAM_STATE_VAR, index, NULL);
	    src.swizzle = slots[i].swizzle;
	    emit(ir, OPCODE_MOV, dst, src);
	    /* even a float takes up a whole vec4 reg in a struct/array. */
	    dst.index++;
	 }
      }

      if (storage->file == PROGRAM_TEMPORARY &&
	  dst.index != storage->index + (int) ir->num_state_slots) {
	 linker_error(this->shader_program,
		      "failed to load builtin uniform `%s' "
		      "(%d/%d regs loaded)\n",
		      ir->name, dst.index - storage->index,
		      type_size(ir->type));
      }
   }
}

void
ir_to_mesa_visitor::visit(ir_loop *ir)
{
   emit(NULL, OPCODE_BGNLOOP);

   visit_exec_list(&ir->body_instructions, this);

   emit(NULL, OPCODE_ENDLOOP);
}

void
ir_to_mesa_visitor::visit(ir_loop_jump *ir)
{
   switch (ir->mode) {
   case ir_loop_jump::jump_break:
      emit(NULL, OPCODE_BRK);
      break;
   case ir_loop_jump::jump_continue:
      emit(NULL, OPCODE_CONT);
      break;
   }
}


void
ir_to_mesa_visitor::visit(ir_function_signature *ir)
{
   assert(0);
   (void)ir;
}

void
ir_to_mesa_visitor::visit(ir_function *ir)
{
   /* Ignore function bodies other than main() -- we shouldn't see calls to
    * them since they should all be inlined before we get to ir_to_mesa.
    */
   if (strcmp(ir->name, "main") == 0) {
      const ir_function_signature *sig;
      exec_list empty;

      sig = ir->matching_signature(NULL, &empty);

      assert(sig);

      foreach_list(node, &sig->body) {
	 ir_instruction *ir = (ir_instruction *) node;

	 ir->accept(this);
      }
   }
}

bool
ir_to_mesa_visitor::try_emit_mad(ir_expression *ir, int mul_operand)
{
   int nonmul_operand = 1 - mul_operand;
   src_reg a, b, c;

   ir_expression *expr = ir->operands[mul_operand]->as_expression();
   if (!expr || expr->operation != ir_binop_mul)
      return false;

   expr->operands[0]->accept(this);
   a = this->result;
   expr->operands[1]->accept(this);
   b = this->result;
   ir->operands[nonmul_operand]->accept(this);
   c = this->result;

   this->result = get_temp(ir->type);
   emit(ir, OPCODE_MAD, dst_reg(this->result), a, b, c);

   return true;
}

/**
 * Emit OPCODE_MAD(a, -b, a) instead of AND(a, NOT(b))
 *
 * The logic values are 1.0 for true and 0.0 for false.  Logical-and is
 * implemented using multiplication, and logical-or is implemented using
 * addition.  Logical-not can be implemented as (true - x), or (1.0 - x).
 * As result, the logical expression (a & !b) can be rewritten as:
 *
 *     - a * !b
 *     - a * (1 - b)
 *     - (a * 1) - (a * b)
 *     - a + -(a * b)
 *     - a + (a * -b)
 *
 * This final expression can be implemented as a single MAD(a, -b, a)
 * instruction.
 */
bool
ir_to_mesa_visitor::try_emit_mad_for_and_not(ir_expression *ir, int try_operand)
{
   const int other_operand = 1 - try_operand;
   src_reg a, b;

   ir_expression *expr = ir->operands[try_operand]->as_expression();
   if (!expr || expr->operation != ir_unop_logic_not)
      return false;

   ir->operands[other_operand]->accept(this);
   a = this->result;
   expr->operands[0]->accept(this);
   b = this->result;

   b.negate = ~b.negate;

   this->result = get_temp(ir->type);
   emit(ir, OPCODE_MAD, dst_reg(this->result), a, b, a);

   return true;
}

bool
ir_to_mesa_visitor::try_emit_sat(ir_expression *ir)
{
   /* Saturates were only introduced to vertex programs in
    * NV_vertex_program3, so don't give them to drivers in the VP.
    */
   if (this->prog->Target == GL_VERTEX_PROGRAM_ARB)
      return false;

   ir_rvalue *sat_src = ir->as_rvalue_to_saturate();
   if (!sat_src)
      return false;

   sat_src->accept(this);
   src_reg src = this->result;

   /* If we generated an expression instruction into a temporary in
    * processing the saturate's operand, apply the saturate to that
    * instruction.  Otherwise, generate a MOV to do the saturate.
    *
    * Note that we have to be careful to only do this optimization if
    * the instruction in question was what generated src->result.  For
    * example, ir_dereference_array might generate a MUL instruction
    * to create the reladdr, and return us a src reg using that
    * reladdr.  That MUL result is not the value we're trying to
    * saturate.
    */
   ir_expression *sat_src_expr = sat_src->as_expression();
   ir_to_mesa_instruction *new_inst;
   new_inst = (ir_to_mesa_instruction *)this->instructions.get_tail();
   if (sat_src_expr && (sat_src_expr->operation == ir_binop_mul ||
			sat_src_expr->operation == ir_binop_add ||
			sat_src_expr->operation == ir_binop_dot)) {
      new_inst->saturate = true;
   } else {
      this->result = get_temp(ir->type);
      ir_to_mesa_instruction *inst;
      inst = emit(ir, OPCODE_MOV, dst_reg(this->result), src);
      inst->saturate = true;
   }

   return true;
}

void
ir_to_mesa_visitor::reladdr_to_temp(ir_instruction *ir,
				    src_reg *reg, int *num_reladdr)
{
   if (!reg->reladdr)
      return;

   emit(ir, OPCODE_ARL, address_reg, *reg->reladdr);

   if (*num_reladdr != 1) {
      src_reg temp = get_temp(glsl_type::vec4_type);

      emit(ir, OPCODE_MOV, dst_reg(temp), *reg);
      *reg = temp;
   }

   (*num_reladdr)--;
}

void
ir_to_mesa_visitor::emit_swz(ir_expression *ir)
{
   /* Assume that the vector operator is in a form compatible with OPCODE_SWZ.
    * This means that each of the operands is either an immediate value of -1,
    * 0, or 1, or is a component from one source register (possibly with
    * negation).
    */
   uint8_t components[4] = { 0 };
   bool negate[4] = { false };
   ir_variable *var = NULL;

   for (unsigned i = 0; i < ir->type->vector_elements; i++) {
      ir_rvalue *op = ir->operands[i];

      assert(op->type->is_scalar());

      while (op != NULL) {
	 switch (op->ir_type) {
	 case ir_type_constant: {

	    assert(op->type->is_scalar());

	    const ir_constant *const c = op->as_constant();
	    if (c->is_one()) {
	       components[i] = SWIZZLE_ONE;
	    } else if (c->is_zero()) {
	       components[i] = SWIZZLE_ZERO;
	    } else if (c->is_negative_one()) {
	       components[i] = SWIZZLE_ONE;
	       negate[i] = true;
	    } else {
	       assert(!"SWZ constant must be 0.0 or 1.0.");
	    }

	    op = NULL;
	    break;
	 }

	 case ir_type_dereference_variable: {
	    ir_dereference_variable *const deref =
	       (ir_dereference_variable *) op;

	    assert((var == NULL) || (deref->var == var));
	    components[i] = SWIZZLE_X;
	    var = deref->var;
	    op = NULL;
	    break;
	 }

	 case ir_type_expression: {
	    ir_expression *const expr = (ir_expression *) op;

	    assert(expr->operation == ir_unop_neg);
	    negate[i] = true;

	    op = expr->operands[0];
	    break;
	 }

	 case ir_type_swizzle: {
	    ir_swizzle *const swiz = (ir_swizzle *) op;

	    components[i] = swiz->mask.x;
	    op = swiz->val;
	    break;
	 }

	 default:
	    assert(!"Should not get here.");
	    return;
	 }
      }
   }

   assert(var != NULL);

   ir_dereference_variable *const deref =
      new(mem_ctx) ir_dereference_variable(var);

   this->result.file = PROGRAM_UNDEFINED;
   deref->accept(this);
   if (this->result.file == PROGRAM_UNDEFINED) {
      printf("Failed to get tree for expression operand:\n");
      deref->print();
      printf("\n");
      exit(1);
   }

   src_reg src;

   src = this->result;
   src.swizzle = MAKE_SWIZZLE4(components[0],
			       components[1],
			       components[2],
			       components[3]);
   src.negate = ((unsigned(negate[0]) << 0)
		 | (unsigned(negate[1]) << 1)
		 | (unsigned(negate[2]) << 2)
		 | (unsigned(negate[3]) << 3));

   /* Storage for our result.  Ideally for an assignment we'd be using the
    * actual storage for the result here, instead.
    */
   const src_reg result_src = get_temp(ir->type);
   dst_reg result_dst = dst_reg(result_src);

   /* Limit writes to the channels that will be used by result_src later.
    * This does limit this temp's use as a temporary for multi-instruction
    * sequences.
    */
   result_dst.writemask = (1 << ir->type->vector_elements) - 1;

   emit(ir, OPCODE_SWZ, result_dst, src);
   this->result = result_src;
}

void
ir_to_mesa_visitor::visit(ir_expression *ir)
{
   unsigned int operand;
   src_reg op[Elements(ir->operands)];
   src_reg result_src;
   dst_reg result_dst;

   /* Quick peephole: Emit OPCODE_MAD(a, b, c) instead of ADD(MUL(a, b), c)
    */
   if (ir->operation == ir_binop_add) {
      if (try_emit_mad(ir, 1))
	 return;
      if (try_emit_mad(ir, 0))
	 return;
   }

   /* Quick peephole: Emit OPCODE_MAD(-a, -b, a) instead of AND(a, NOT(b))
    */
   if (ir->operation == ir_binop_logic_and) {
      if (try_emit_mad_for_and_not(ir, 1))
	 return;
      if (try_emit_mad_for_and_not(ir, 0))
	 return;
   }

   if (try_emit_sat(ir))
      return;

   if (ir->operation == ir_quadop_vector) {
      this->emit_swz(ir);
      return;
   }

   for (operand = 0; operand < ir->get_num_operands(); operand++) {
      this->result.file = PROGRAM_UNDEFINED;
      ir->operands[operand]->accept(this);
      if (this->result.file == PROGRAM_UNDEFINED) {
	 printf("Failed to get tree for expression operand:\n");
         ir->operands[operand]->print();
         printf("\n");
	 exit(1);
      }
      op[operand] = this->result;

      /* Matrix expression operands should have been broken down to vector
       * operations already.
       */
      assert(!ir->operands[operand]->type->is_matrix());
   }

   int vector_elements = ir->operands[0]->type->vector_elements;
   if (ir->operands[1]) {
      vector_elements = MAX2(vector_elements,
			     ir->operands[1]->type->vector_elements);
   }

   this->result.file = PROGRAM_UNDEFINED;

   /* Storage for our result.  Ideally for an assignment we'd be using
    * the actual storage for the result here, instead.
    */
   result_src = get_temp(ir->type);
   /* convenience for the emit functions below. */
   result_dst = dst_reg(result_src);
   /* Limit writes to the channels that will be used by result_src later.
    * This does limit this temp's use as a temporary for multi-instruction
    * sequences.
    */
   result_dst.writemask = (1 << ir->type->vector_elements) - 1;

   switch (ir->operation) {
   case ir_unop_logic_not:
      /* Previously 'SEQ dst, src, 0.0' was used for this.  However, many
       * older GPUs implement SEQ using multiple instructions (i915 uses two
       * SGE instructions and a MUL instruction).  Since our logic values are
       * 0.0 and 1.0, 1-x also implements !x.
       */
      op[0].negate = ~op[0].negate;
      emit(ir, OPCODE_ADD, result_dst, op[0], src_reg_for_float(1.0));
      break;
   case ir_unop_neg:
      op[0].negate = ~op[0].negate;
      result_src = op[0];
      break;
   case ir_unop_abs:
      emit(ir, OPCODE_ABS, result_dst, op[0]);
      break;
   case ir_unop_sign:
      emit(ir, OPCODE_SSG, result_dst, op[0]);
      break;
   case ir_unop_rcp:
      emit_scalar(ir, OPCODE_RCP, result_dst, op[0]);
      break;

   case ir_unop_exp2:
      emit_scalar(ir, OPCODE_EX2, result_dst, op[0]);
      break;
   case ir_unop_exp:
   case ir_unop_log:
      assert(!"not reached: should be handled by ir_explog_to_explog2");
      break;
   case ir_unop_log2:
      emit_scalar(ir, OPCODE_LG2, result_dst, op[0]);
      break;
   case ir_unop_sin:
      emit_scalar(ir, OPCODE_SIN, result_dst, op[0]);
      break;
   case ir_unop_cos:
      emit_scalar(ir, OPCODE_COS, result_dst, op[0]);
      break;
   case ir_unop_sin_reduced:
      emit_scs(ir, OPCODE_SIN, result_dst, op[0]);
      break;
   case ir_unop_cos_reduced:
      emit_scs(ir, OPCODE_COS, result_dst, op[0]);
      break;

   case ir_unop_dFdx:
      emit(ir, OPCODE_DDX, result_dst, op[0]);
      break;
   case ir_unop_dFdy:
      emit(ir, OPCODE_DDY, result_dst, op[0]);
      break;

   case ir_unop_noise: {
      const enum prog_opcode opcode =
	 prog_opcode(OPCODE_NOISE1
		     + (ir->operands[0]->type->vector_elements) - 1);
      assert((opcode >= OPCODE_NOISE1) && (opcode <= OPCODE_NOISE4));

      emit(ir, opcode, result_dst, op[0]);
      break;
   }

   case ir_binop_add:
      emit(ir, OPCODE_ADD, result_dst, op[0], op[1]);
      break;
   case ir_binop_sub:
      emit(ir, OPCODE_SUB, result_dst, op[0], op[1]);
      break;

   case ir_binop_mul:
      emit(ir, OPCODE_MUL, result_dst, op[0], op[1]);
      break;
   case ir_binop_div:
      assert(!"not reached: should be handled by ir_div_to_mul_rcp");
      break;
   case ir_binop_mod:
      /* Floating point should be lowered by MOD_TO_FRACT in the compiler. */
      assert(ir->type->is_integer());
      emit(ir, OPCODE_MUL, result_dst, op[0], op[1]);
      break;

   case ir_binop_less:
      emit(ir, OPCODE_SLT, result_dst, op[0], op[1]);
      break;
   case ir_binop_greater:
      emit(ir, OPCODE_SGT, result_dst, op[0], op[1]);
      break;
   case ir_binop_lequal:
      emit(ir, OPCODE_SLE, result_dst, op[0], op[1]);
      break;
   case ir_binop_gequal:
      emit(ir, OPCODE_SGE, result_dst, op[0], op[1]);
      break;
   case ir_binop_equal:
      emit(ir, OPCODE_SEQ, result_dst, op[0], op[1]);
      break;
   case ir_binop_nequal:
      emit(ir, OPCODE_SNE, result_dst, op[0], op[1]);
      break;
   case ir_binop_all_equal:
      /* "==" operator producing a scalar boolean. */
      if (ir->operands[0]->type->is_vector() ||
	  ir->operands[1]->type->is_vector()) {
	 src_reg temp = get_temp(glsl_type::vec4_type);
	 emit(ir, OPCODE_SNE, dst_reg(temp), op[0], op[1]);

	 /* After the dot-product, the value will be an integer on the
	  * range [0,4].  Zero becomes 1.0, and positive values become zero.
	  */
	 emit_dp(ir, result_dst, temp, temp, vector_elements);

	 /* Negating the result of the dot-product gives values on the range
	  * [-4, 0].  Zero becomes 1.0, and negative values become zero.  This
	  * achieved using SGE.
	  */
	 src_reg sge_src = result_src;
	 sge_src.negate = ~sge_src.negate;
	 emit(ir, OPCODE_SGE, result_dst, sge_src, src_reg_for_float(0.0));
      } else {
	 emit(ir, OPCODE_SEQ, result_dst, op[0], op[1]);
      }
      break;
   case ir_binop_any_nequal:
      /* "!=" operator producing a scalar boolean. */
      if (ir->operands[0]->type->is_vector() ||
	  ir->operands[1]->type->is_vector()) {
	 src_reg temp = get_temp(glsl_type::vec4_type);
	 emit(ir, OPCODE_SNE, dst_reg(temp), op[0], op[1]);

	 /* After the dot-product, the value will be an integer on the
	  * range [0,4].  Zero stays zero, and positive values become 1.0.
	  */
	 ir_to_mesa_instruction *const dp =
	    emit_dp(ir, result_dst, temp, temp, vector_elements);
	 if (this->prog->Target == GL_FRAGMENT_PROGRAM_ARB) {
	    /* The clamping to [0,1] can be done for free in the fragment
	     * shader with a saturate.
	     */
	    dp->saturate = true;
	 } else {
	    /* Negating the result of the dot-product gives values on the range
	     * [-4, 0].  Zero stays zero, and negative values become 1.0.  This
	     * achieved using SLT.
	     */
	    src_reg slt_src = result_src;
	    slt_src.negate = ~slt_src.negate;
	    emit(ir, OPCODE_SLT, result_dst, slt_src, src_reg_for_float(0.0));
	 }
      } else {
	 emit(ir, OPCODE_SNE, result_dst, op[0], op[1]);
      }
      break;

   case ir_unop_any: {
      assert(ir->operands[0]->type->is_vector());

      /* After the dot-product, the value will be an integer on the
       * range [0,4].  Zero stays zero, and positive values become 1.0.
       */
      ir_to_mesa_instruction *const dp =
	 emit_dp(ir, result_dst, op[0], op[0],
		 ir->operands[0]->type->vector_elements);
      if (this->prog->Target == GL_FRAGMENT_PROGRAM_ARB) {
	 /* The clamping to [0,1] can be done for free in the fragment
	  * shader with a saturate.
	  */
	 dp->saturate = true;
      } else {
	 /* Negating the result of the dot-product gives values on the range
	  * [-4, 0].  Zero stays zero, and negative values become 1.0.  This
	  * is achieved using SLT.
	  */
	 src_reg slt_src = result_src;
	 slt_src.negate = ~slt_src.negate;
	 emit(ir, OPCODE_SLT, result_dst, slt_src, src_reg_for_float(0.0));
      }
      break;
   }

   case ir_binop_logic_xor:
      emit(ir, OPCODE_SNE, result_dst, op[0], op[1]);
      break;

   case ir_binop_logic_or: {
      /* After the addition, the value will be an integer on the
       * range [0,2].  Zero stays zero, and positive values become 1.0.
       */
      ir_to_mesa_instruction *add =
	 emit(ir, OPCODE_ADD, result_dst, op[0], op[1]);
      if (this->prog->Target == GL_FRAGMENT_PROGRAM_ARB) {
	 /* The clamping to [0,1] can be done for free in the fragment
	  * shader with a saturate.
	  */
	 add->saturate = true;
      } else {
	 /* Negating the result of the addition gives values on the range
	  * [-2, 0].  Zero stays zero, and negative values become 1.0.  This
	  * is achieved using SLT.
	  */
	 src_reg slt_src = result_src;
	 slt_src.negate = ~slt_src.negate;
	 emit(ir, OPCODE_SLT, result_dst, slt_src, src_reg_for_float(0.0));
      }
      break;
   }

   case ir_binop_logic_and:
      /* the bool args are stored as float 0.0 or 1.0, so "mul" gives us "and". */
      emit(ir, OPCODE_MUL, result_dst, op[0], op[1]);
      break;

   case ir_binop_dot:
      assert(ir->operands[0]->type->is_vector());
      assert(ir->operands[0]->type == ir->operands[1]->type);
      emit_dp(ir, result_dst, op[0], op[1],
	      ir->operands[0]->type->vector_elements);
      break;

   case ir_unop_sqrt:
      /* sqrt(x) = x * rsq(x). */
      emit_scalar(ir, OPCODE_RSQ, result_dst, op[0]);
      emit(ir, OPCODE_MUL, result_dst, result_src, op[0]);
      /* For incoming channels <= 0, set the result to 0. */
      op[0].negate = ~op[0].negate;
      emit(ir, OPCODE_CMP, result_dst,
			  op[0], result_src, src_reg_for_float(0.0));
      break;
   case ir_unop_rsq:
      emit_scalar(ir, OPCODE_RSQ, result_dst, op[0]);
      break;
   case ir_unop_i2f:
   case ir_unop_u2f:
   case ir_unop_b2f:
   case ir_unop_b2i:
   case ir_unop_i2u:
   case ir_unop_u2i:
      /* Mesa IR lacks types, ints are stored as truncated floats. */
      result_src = op[0];
      break;
   case ir_unop_f2i:
   case ir_unop_f2u:
      emit(ir, OPCODE_TRUNC, result_dst, op[0]);
      break;
   case ir_unop_f2b:
   case ir_unop_i2b:
      emit(ir, OPCODE_SNE, result_dst,
			  op[0], src_reg_for_float(0.0));
      break;
   case ir_unop_bitcast_f2i: // Ignore these 4, they can't happen here anyway
   case ir_unop_bitcast_f2u:
   case ir_unop_bitcast_i2f:
   case ir_unop_bitcast_u2f:
      break;
   case ir_unop_trunc:
      emit(ir, OPCODE_TRUNC, result_dst, op[0]);
      break;
   case ir_unop_ceil:
      op[0].negate = ~op[0].negate;
      emit(ir, OPCODE_FLR, result_dst, op[0]);
      result_src.negate = ~result_src.negate;
      break;
   case ir_unop_floor:
      emit(ir, OPCODE_FLR, result_dst, op[0]);
      break;
   case ir_unop_fract:
      emit(ir, OPCODE_FRC, result_dst, op[0]);
      break;
   case ir_unop_pack_snorm_2x16:
   case ir_unop_pack_snorm_4x8:
   case ir_unop_pack_unorm_2x16:
   case ir_unop_pack_unorm_4x8:
   case ir_unop_pack_half_2x16:
   case ir_unop_unpack_snorm_2x16:
   case ir_unop_unpack_snorm_4x8:
   case ir_unop_unpack_unorm_2x16:
   case ir_unop_unpack_unorm_4x8:
   case ir_unop_unpack_half_2x16:
   case ir_unop_unpack_half_2x16_split_x:
   case ir_unop_unpack_half_2x16_split_y:
   case ir_binop_pack_half_2x16_split:
   case ir_unop_bitfield_reverse:
   case ir_unop_bit_count:
   case ir_unop_find_msb:
   case ir_unop_find_lsb:
      assert(!"not supported");
      break;
   case ir_binop_min:
      emit(ir, OPCODE_MIN, result_dst, op[0], op[1]);
      break;
   case ir_binop_max:
      emit(ir, OPCODE_MAX, result_dst, op[0], op[1]);
      break;
   case ir_binop_pow:
      emit_scalar(ir, OPCODE_POW, result_dst, op[0], op[1]);
      break;

      /* GLSL 1.30 integer ops are unsupported in Mesa IR, but since
       * hardware backends have no way to avoid Mesa IR generation
       * even if they don't use it, we need to emit "something" and
       * continue.
       */
   case ir_binop_lshift:
   case ir_binop_rshift:
   case ir_binop_bit_and:
   case ir_binop_bit_xor:
   case ir_binop_bit_or:
      emit(ir, OPCODE_ADD, result_dst, op[0], op[1]);
      break;

   case ir_unop_bit_not:
   case ir_unop_round_even:
      emit(ir, OPCODE_MOV, result_dst, op[0]);
      break;

   case ir_binop_ubo_load:
      assert(!"not supported");
      break;

   case ir_triop_lrp:
      /* ir_triop_lrp operands are (x, y, a) while
       * OPCODE_LRP operands are (a, y, x) to match ARB_fragment_program.
       */
      emit(ir, OPCODE_LRP, result_dst, op[2], op[1], op[0]);
      break;

   case ir_binop_vector_extract:
   case ir_binop_bfm:
   case ir_triop_fma:
   case ir_triop_bfi:
   case ir_triop_bitfield_extract:
   case ir_triop_vector_insert:
   case ir_quadop_bitfield_insert:
   case ir_binop_ldexp:
   case ir_triop_csel:
   case ir_binop_carry:
   case ir_binop_borrow:
   case ir_binop_imul_high:
      assert(!"not supported");
      break;

   case ir_quadop_vector:
      /* This operation should have already been handled.
       */
      assert(!"Should not get here.");
      break;
   }

   this->result = result_src;
}


void
ir_to_mesa_visitor::visit(ir_swizzle *ir)
{
   src_reg src;
   int i;
   int swizzle[4];

   /* Note that this is only swizzles in expressions, not those on the left
    * hand side of an assignment, which do write masking.  See ir_assignment
    * for that.
    */

   ir->val->accept(this);
   src = this->result;
   assert(src.file != PROGRAM_UNDEFINED);

   for (i = 0; i < 4; i++) {
      if (i < ir->type->vector_elements) {
	 switch (i) {
	 case 0:
	    swizzle[i] = GET_SWZ(src.swizzle, ir->mask.x);
	    break;
	 case 1:
	    swizzle[i] = GET_SWZ(src.swizzle, ir->mask.y);
	    break;
	 case 2:
	    swizzle[i] = GET_SWZ(src.swizzle, ir->mask.z);
	    break;
	 case 3:
	    swizzle[i] = GET_SWZ(src.swizzle, ir->mask.w);
	    break;
	 }
      } else {
	 /* If the type is smaller than a vec4, replicate the last
	  * channel out.
	  */
	 swizzle[i] = swizzle[ir->type->vector_elements - 1];
      }
   }

   src.swizzle = MAKE_SWIZZLE4(swizzle[0], swizzle[1], swizzle[2], swizzle[3]);

   this->result = src;
}

void
ir_to_mesa_visitor::visit(ir_dereference_variable *ir)
{
   variable_storage *entry = find_variable_storage(ir->var);
   ir_variable *var = ir->var;

   if (!entry) {
      switch (var->data.mode) {
      case ir_var_uniform:
	 entry = new(mem_ctx) variable_storage(var, PROGRAM_UNIFORM,
					       var->data.location);
	 this->variables.push_tail(entry);
	 break;
      case ir_var_shader_in:
	 /* The linker assigns locations for varyings and attributes,
	  * including deprecated builtins (like gl_Color),
	  * user-assigned generic attributes (glBindVertexLocation),
	  * and user-defined varyings.
	  */
	 assert(var->data.location != -1);
         entry = new(mem_ctx) variable_storage(var,
                                               PROGRAM_INPUT,
                                               var->data.location);
         break;
      case ir_var_shader_out:
	 assert(var->data.location != -1);
         entry = new(mem_ctx) variable_storage(var,
                                               PROGRAM_OUTPUT,
                                               var->data.location);
	 break;
      case ir_var_system_value:
         entry = new(mem_ctx) variable_storage(var,
                                               PROGRAM_SYSTEM_VALUE,
                                               var->data.location);
         break;
      case ir_var_auto:
      case ir_var_temporary:
	 entry = new(mem_ctx) variable_storage(var, PROGRAM_TEMPORARY,
					       this->next_temp);
	 this->variables.push_tail(entry);

	 next_temp += type_size(var->type);
	 break;
      }

      if (!entry) {
	 printf("Failed to make storage for %s\n", var->name);
	 exit(1);
      }
   }

   this->result = src_reg(entry->file, entry->index, var->type);
}

void
ir_to_mesa_visitor::visit(ir_dereference_array *ir)
{
   ir_constant *index;
   src_reg src;
   int element_size = type_size(ir->type);

   index = ir->array_index->constant_expression_value();

   ir->array->accept(this);
   src = this->result;

   if (index) {
      src.index += index->value.i[0] * element_size;
   } else {
      /* Variable index array dereference.  It eats the "vec4" of the
       * base of the array and an index that offsets the Mesa register
       * index.
       */
      ir->array_index->accept(this);

      src_reg index_reg;

      if (element_size == 1) {
	 index_reg = this->result;
      } else {
	 index_reg = get_temp(glsl_type::float_type);

	 emit(ir, OPCODE_MUL, dst_reg(index_reg),
	      this->result, src_reg_for_float(element_size));
      }

      /* If there was already a relative address register involved, add the
       * new and the old together to get the new offset.
       */
      if (src.reladdr != NULL)  {
	 src_reg accum_reg = get_temp(glsl_type::float_type);

	 emit(ir, OPCODE_ADD, dst_reg(accum_reg),
	      index_reg, *src.reladdr);

	 index_reg = accum_reg;
      }

      src.reladdr = ralloc(mem_ctx, src_reg);
      memcpy(src.reladdr, &index_reg, sizeof(index_reg));
   }

   /* If the type is smaller than a vec4, replicate the last channel out. */
   if (ir->type->is_scalar() || ir->type->is_vector())
      src.swizzle = swizzle_for_size(ir->type->vector_elements);
   else
      src.swizzle = SWIZZLE_NOOP;

   this->result = src;
}

void
ir_to_mesa_visitor::visit(ir_dereference_record *ir)
{
   unsigned int i;
   const glsl_type *struct_type = ir->record->type;
   int offset = 0;

   ir->record->accept(this);

   for (i = 0; i < struct_type->length; i++) {
      if (strcmp(struct_type->fields.structure[i].name, ir->field) == 0)
	 break;
      offset += type_size(struct_type->fields.structure[i].type);
   }

   /* If the type is smaller than a vec4, replicate the last channel out. */
   if (ir->type->is_scalar() || ir->type->is_vector())
      this->result.swizzle = swizzle_for_size(ir->type->vector_elements);
   else
      this->result.swizzle = SWIZZLE_NOOP;

   this->result.index += offset;
}

/**
 * We want to be careful in assignment setup to hit the actual storage
 * instead of potentially using a temporary like we might with the
 * ir_dereference handler.
 */
static dst_reg
get_assignment_lhs(ir_dereference *ir, ir_to_mesa_visitor *v)
{
   /* The LHS must be a dereference.  If the LHS is a variable indexed array
    * access of a vector, it must be separated into a series conditional moves
    * before reaching this point (see ir_vec_index_to_cond_assign).
    */
   assert(ir->as_dereference());
   ir_dereference_array *deref_array = ir->as_dereference_array();
   if (deref_array) {
      assert(!deref_array->array->type->is_vector());
   }

   /* Use the rvalue deref handler for the most part.  We'll ignore
    * swizzles in it and write swizzles using writemask, though.
    */
   ir->accept(v);
   return dst_reg(v->result);
}

/**
 * Process the condition of a conditional assignment
 *
 * Examines the condition of a conditional assignment to generate the optimal
 * first operand of a \c CMP instruction.  If the condition is a relational
 * operator with 0 (e.g., \c ir_binop_less), the value being compared will be
 * used as the source for the \c CMP instruction.  Otherwise the comparison
 * is processed to a boolean result, and the boolean result is used as the
 * operand to the CMP instruction.
 */
bool
ir_to_mesa_visitor::process_move_condition(ir_rvalue *ir)
{
   ir_rvalue *src_ir = ir;
   bool negate = true;
   bool switch_order = false;

   ir_expression *const expr = ir->as_expression();
   if ((expr != NULL) && (expr->get_num_operands() == 2)) {
      bool zero_on_left = false;

      if (expr->operands[0]->is_zero()) {
	 src_ir = expr->operands[1];
	 zero_on_left = true;
      } else if (expr->operands[1]->is_zero()) {
	 src_ir = expr->operands[0];
	 zero_on_left = false;
      }

      /*      a is -  0  +            -  0  +
       * (a <  0)  T  F  F  ( a < 0)  T  F  F
       * (0 <  a)  F  F  T  (-a < 0)  F  F  T
       * (a <= 0)  T  T  F  (-a < 0)  F  F  T  (swap order of other operands)
       * (0 <= a)  F  T  T  ( a < 0)  T  F  F  (swap order of other operands)
       * (a >  0)  F  F  T  (-a < 0)  F  F  T
       * (0 >  a)  T  F  F  ( a < 0)  T  F  F
       * (a >= 0)  F  T  T  ( a < 0)  T  F  F  (swap order of other operands)
       * (0 >= a)  T  T  F  (-a < 0)  F  F  T  (swap order of other operands)
       *
       * Note that exchanging the order of 0 and 'a' in the comparison simply
       * means that the value of 'a' should be negated.
       */
      if (src_ir != ir) {
	 switch (expr->operation) {
	 case ir_binop_less:
	    switch_order = false;
	    negate = zero_on_left;
	    break;

	 case ir_binop_greater:
	    switch_order = false;
	    negate = !zero_on_left;
	    break;

	 case ir_binop_lequal:
	    switch_order = true;
	    negate = !zero_on_left;
	    break;

	 case ir_binop_gequal:
	    switch_order = true;
	    negate = zero_on_left;
	    break;

	 default:
	    /* This isn't the right kind of comparison afterall, so make sure
	     * the whole condition is visited.
	     */
	    src_ir = ir;
	    break;
	 }
      }
   }

   src_ir->accept(this);

   /* We use the OPCODE_CMP (a < 0 ? b : c) for conditional moves, and the
    * condition we produced is 0.0 or 1.0.  By flipping the sign, we can
    * choose which value OPCODE_CMP produces without an extra instruction
    * computing the condition.
    */
   if (negate)
      this->result.negate = ~this->result.negate;

   return switch_order;
}

void
ir_to_mesa_visitor::visit(ir_assignment *ir)
{
   dst_reg l;
   src_reg r;
   int i;

   ir->rhs->accept(this);
   r = this->result;

   l = get_assignment_lhs(ir->lhs, this);

   /* FINISHME: This should really set to the correct maximal writemask for each
    * FINISHME: component written (in the loops below).  This case can only
    * FINISHME: occur for matrices, arrays, and structures.
    */
   if (ir->write_mask == 0) {
      assert(!ir->lhs->type->is_scalar() && !ir->lhs->type->is_vector());
      l.writemask = WRITEMASK_XYZW;
   } else if (ir->lhs->type->is_scalar()) {
      /* FINISHME: This hack makes writing to gl_FragDepth, which lives in the
       * FINISHME: W component of fragment shader output zero, work correctly.
       */
      l.writemask = WRITEMASK_XYZW;
   } else {
      int swizzles[4];
      int first_enabled_chan = 0;
      int rhs_chan = 0;

      assert(ir->lhs->type->is_vector());
      l.writemask = ir->write_mask;

      for (int i = 0; i < 4; i++) {
	 if (l.writemask & (1 << i)) {
	    first_enabled_chan = GET_SWZ(r.swizzle, i);
	    break;
	 }
      }

      /* Swizzle a small RHS vector into the channels being written.
       *
       * glsl ir treats write_mask as dictating how many channels are
       * present on the RHS while Mesa IR treats write_mask as just
       * showing which channels of the vec4 RHS get written.
       */
      for (int i = 0; i < 4; i++) {
	 if (l.writemask & (1 << i))
	    swizzles[i] = GET_SWZ(r.swizzle, rhs_chan++);
	 else
	    swizzles[i] = first_enabled_chan;
      }
      r.swizzle = MAKE_SWIZZLE4(swizzles[0], swizzles[1],
				swizzles[2], swizzles[3]);
   }

   assert(l.file != PROGRAM_UNDEFINED);
   assert(r.file != PROGRAM_UNDEFINED);

   if (ir->condition) {
      const bool switch_order = this->process_move_condition(ir->condition);
      src_reg condition = this->result;

      for (i = 0; i < type_size(ir->lhs->type); i++) {
	 if (switch_order) {
	    emit(ir, OPCODE_CMP, l, condition, src_reg(l), r);
	 } else {
	    emit(ir, OPCODE_CMP, l, condition, r, src_reg(l));
	 }

	 l.index++;
	 r.index++;
      }
   } else {
      for (i = 0; i < type_size(ir->lhs->type); i++) {
	 emit(ir, OPCODE_MOV, l, r);
	 l.index++;
	 r.index++;
      }
   }
}


void
ir_to_mesa_visitor::visit(ir_constant *ir)
{
   src_reg src;
   GLfloat stack_vals[4] = { 0 };
   GLfloat *values = stack_vals;
   unsigned int i;

   /* Unfortunately, 4 floats is all we can get into
    * _mesa_add_unnamed_constant.  So, make a temp to store an
    * aggregate constant and move each constant value into it.  If we
    * get lucky, copy propagation will eliminate the extra moves.
    */

   if (ir->type->base_type == GLSL_TYPE_STRUCT) {
      src_reg temp_base = get_temp(ir->type);
      dst_reg temp = dst_reg(temp_base);

      foreach_list(node, &ir->components) {
	 ir_constant *field_value = (ir_constant *) node;
	 int size = type_size(field_value->type);

	 assert(size > 0);

	 field_value->accept(this);
	 src = this->result;

	 for (i = 0; i < (unsigned int)size; i++) {
	    emit(ir, OPCODE_MOV, temp, src);

	    src.index++;
	    temp.index++;
	 }
      }
      this->result = temp_base;
      return;
   }

   if (ir->type->is_array()) {
      src_reg temp_base = get_temp(ir->type);
      dst_reg temp = dst_reg(temp_base);
      int size = type_size(ir->type->fields.array);

      assert(size > 0);

      for (i = 0; i < ir->type->length; i++) {
	 ir->array_elements[i]->accept(this);
	 src = this->result;
	 for (int j = 0; j < size; j++) {
	    emit(ir, OPCODE_MOV, temp, src);

	    src.index++;
	    temp.index++;
	 }
      }
      this->result = temp_base;
      return;
   }

   if (ir->type->is_matrix()) {
      src_reg mat = get_temp(ir->type);
      dst_reg mat_column = dst_reg(mat);

      for (i = 0; i < ir->type->matrix_columns; i++) {
	 assert(ir->type->base_type == GLSL_TYPE_FLOAT);
	 values = &ir->value.f[i * ir->type->vector_elements];

	 src = src_reg(PROGRAM_CONSTANT, -1, NULL);
	 src.index = _mesa_add_unnamed_constant(this->prog->Parameters,
						(gl_constant_value *) values,
						ir->type->vector_elements,
						&src.swizzle);
	 emit(ir, OPCODE_MOV, mat_column, src);

	 mat_column.index++;
      }

      this->result = mat;
      return;
   }

   src.file = PROGRAM_CONSTANT;
   switch (ir->type->base_type) {
   case GLSL_TYPE_FLOAT:
      values = &ir->value.f[0];
      break;
   case GLSL_TYPE_UINT:
      for (i = 0; i < ir->type->vector_elements; i++) {
	 values[i] = ir->value.u[i];
      }
      break;
   case GLSL_TYPE_INT:
      for (i = 0; i < ir->type->vector_elements; i++) {
	 values[i] = ir->value.i[i];
      }
      break;
   case GLSL_TYPE_BOOL:
      for (i = 0; i < ir->type->vector_elements; i++) {
	 values[i] = ir->value.b[i];
      }
      break;
   default:
      assert(!"Non-float/uint/int/bool constant");
   }

   this->result = src_reg(PROGRAM_CONSTANT, -1, ir->type);
   this->result.index = _mesa_add_unnamed_constant(this->prog->Parameters,
						   (gl_constant_value *) values,
						   ir->type->vector_elements,
						   &this->result.swizzle);
}

void
ir_to_mesa_visitor::visit(ir_call *)
{
   assert(!"ir_to_mesa: All function calls should have been inlined by now.");
}

void
ir_to_mesa_visitor::visit(ir_texture *ir)
{
   src_reg result_src, coord, lod_info, projector, dx, dy;
   dst_reg result_dst, coord_dst;
   ir_to_mesa_instruction *inst = NULL;
   prog_opcode opcode = OPCODE_NOP;

   if (ir->op == ir_txs)
      this->result = src_reg_for_float(0.0);
   else
      ir->coordinate->accept(this);

   /* Put our coords in a temp.  We'll need to modify them for shadow,
    * projection, or LOD, so the only case we'd use it as is is if
    * we're doing plain old texturing.  Mesa IR optimization should
    * handle cleaning up our mess in that case.
    */
   coord = get_temp(glsl_type::vec4_type);
   coord_dst = dst_reg(coord);
   emit(ir, OPCODE_MOV, coord_dst, this->result);

   if (ir->projector) {
      ir->projector->accept(this);
      projector = this->result;
   }

   /* Storage for our result.  Ideally for an assignment we'd be using
    * the actual storage for the result here, instead.
    */
   result_src = get_temp(glsl_type::vec4_type);
   result_dst = dst_reg(result_src);

   switch (ir->op) {
   case ir_tex:
   case ir_txs:
      opcode = OPCODE_TEX;
      break;
   case ir_txb:
      opcode = OPCODE_TXB;
      ir->lod_info.bias->accept(this);
      lod_info = this->result;
      break;
   case ir_txf:
      /* Pretend to be TXL so the sampler, coordinate, lod are available */
   case ir_txl:
      opcode = OPCODE_TXL;
      ir->lod_info.lod->accept(this);
      lod_info = this->result;
      break;
   case ir_txd:
      opcode = OPCODE_TXD;
      ir->lod_info.grad.dPdx->accept(this);
      dx = this->result;
      ir->lod_info.grad.dPdy->accept(this);
      dy = this->result;
      break;
   case ir_txf_ms:
      assert(!"Unexpected ir_txf_ms opcode");
      break;
   case ir_lod:
      assert(!"Unexpected ir_lod opcode");
      break;
   case ir_tg4:
      assert(!"Unexpected ir_tg4 opcode");
      break;
   case ir_query_levels:
      assert(!"Unexpected ir_query_levels opcode");
      break;
   }

   const glsl_type *sampler_type = ir->sampler->type;

   if (ir->projector) {
      if (opcode == OPCODE_TEX) {
	 /* Slot the projector in as the last component of the coord. */
	 coord_dst.writemask = WRITEMASK_W;
	 emit(ir, OPCODE_MOV, coord_dst, projector);
	 coord_dst.writemask = WRITEMASK_XYZW;
	 opcode = OPCODE_TXP;
      } else {
	 src_reg coord_w = coord;
	 coord_w.swizzle = SWIZZLE_WWWW;

	 /* For the other TEX opcodes there's no projective version
	  * since the last slot is taken up by lod info.  Do the
	  * projective divide now.
	  */
	 coord_dst.writemask = WRITEMASK_W;
	 emit(ir, OPCODE_RCP, coord_dst, projector);

	 /* In the case where we have to project the coordinates "by hand,"
	  * the shadow comparitor value must also be projected.
	  */
	 src_reg tmp_src = coord;
	 if (ir->shadow_comparitor) {
	    /* Slot the shadow value in as the second to last component of the
	     * coord.
	     */
	    ir->shadow_comparitor->accept(this);

	    tmp_src = get_temp(glsl_type::vec4_type);
	    dst_reg tmp_dst = dst_reg(tmp_src);

	    /* Projective division not allowed for array samplers. */
	    assert(!sampler_type->sampler_array);

	    tmp_dst.writemask = WRITEMASK_Z;
	    emit(ir, OPCODE_MOV, tmp_dst, this->result);

	    tmp_dst.writemask = WRITEMASK_XY;
	    emit(ir, OPCODE_MOV, tmp_dst, coord);
	 }

	 coord_dst.writemask = WRITEMASK_XYZ;
	 emit(ir, OPCODE_MUL, coord_dst, tmp_src, coord_w);

	 coord_dst.writemask = WRITEMASK_XYZW;
	 coord.swizzle = SWIZZLE_XYZW;
      }
   }

   /* If projection is done and the opcode is not OPCODE_TXP, then the shadow
    * comparitor was put in the correct place (and projected) by the code,
    * above, that handles by-hand projection.
    */
   if (ir->shadow_comparitor && (!ir->projector || opcode == OPCODE_TXP)) {
      /* Slot the shadow value in as the second to last component of the
       * coord.
       */
      ir->shadow_comparitor->accept(this);

      /* XXX This will need to be updated for cubemap array samplers. */
      if (sampler_type->sampler_dimensionality == GLSL_SAMPLER_DIM_2D &&
          sampler_type->sampler_array) {
         coord_dst.writemask = WRITEMASK_W;
      } else {
         coord_dst.writemask = WRITEMASK_Z;
      }

      emit(ir, OPCODE_MOV, coord_dst, this->result);
      coord_dst.writemask = WRITEMASK_XYZW;
   }

   if (opcode == OPCODE_TXL || opcode == OPCODE_TXB) {
      /* Mesa IR stores lod or lod bias in the last channel of the coords. */
      coord_dst.writemask = WRITEMASK_W;
      emit(ir, OPCODE_MOV, coord_dst, lod_info);
      coord_dst.writemask = WRITEMASK_XYZW;
   }

   if (opcode == OPCODE_TXD)
      inst = emit(ir, opcode, result_dst, coord, dx, dy);
   else
      inst = emit(ir, opcode, result_dst, coord);

   if (ir->shadow_comparitor)
      inst->tex_shadow = GL_TRUE;

   inst->sampler = _mesa_get_sampler_uniform_value(ir->sampler,
						   this->shader_program,
						   this->prog);

   switch (sampler_type->sampler_dimensionality) {
   case GLSL_SAMPLER_DIM_1D:
      inst->tex_target = (sampler_type->sampler_array)
	 ? TEXTURE_1D_ARRAY_INDEX : TEXTURE_1D_INDEX;
      break;
   case GLSL_SAMPLER_DIM_2D:
      inst->tex_target = (sampler_type->sampler_array)
	 ? TEXTURE_2D_ARRAY_INDEX : TEXTURE_2D_INDEX;
      break;
   case GLSL_SAMPLER_DIM_3D:
      inst->tex_target = TEXTURE_3D_INDEX;
      break;
   case GLSL_SAMPLER_DIM_CUBE:
      inst->tex_target = TEXTURE_CUBE_INDEX;
      break;
   case GLSL_SAMPLER_DIM_RECT:
      inst->tex_target = TEXTURE_RECT_INDEX;
      break;
   case GLSL_SAMPLER_DIM_BUF:
      assert(!"FINISHME: Implement ARB_texture_buffer_object");
      break;
   case GLSL_SAMPLER_DIM_EXTERNAL:
      inst->tex_target = TEXTURE_EXTERNAL_INDEX;
      break;
   default:
      assert(!"Should not get here.");
   }

   this->result = result_src;
}

void
ir_to_mesa_visitor::visit(ir_return *ir)
{
   /* Non-void functions should have been inlined.  We may still emit RETs
    * from main() unless the EmitNoMainReturn option is set.
    */
   assert(!ir->get_value());
   emit(ir, OPCODE_RET);
}

void
ir_to_mesa_visitor::visit(ir_discard *ir)
{
   if (ir->condition) {
      ir->condition->accept(this);
      this->result.negate = ~this->result.negate;
      emit(ir, OPCODE_KIL, undef_dst, this->result);
   } else {
      emit(ir, OPCODE_KIL_NV);
   }
}

void
ir_to_mesa_visitor::visit(ir_if *ir)
{
   ir_to_mesa_instruction *cond_inst, *if_inst;
   ir_to_mesa_instruction *prev_inst;

   prev_inst = (ir_to_mesa_instruction *)this->instructions.get_tail();

   ir->condition->accept(this);
   assert(this->result.file != PROGRAM_UNDEFINED);

   if (this->options->EmitCondCodes) {
      cond_inst = (ir_to_mesa_instruction *)this->instructions.get_tail();

      /* See if we actually generated any instruction for generating
       * the condition.  If not, then cook up a move to a temp so we
       * have something to set cond_update on.
       */
      if (cond_inst == prev_inst) {
	 src_reg temp = get_temp(glsl_type::bool_type);
	 cond_inst = emit(ir->condition, OPCODE_MOV, dst_reg(temp), result);
      }
      cond_inst->cond_update = GL_TRUE;

      if_inst = emit(ir->condition, OPCODE_IF);
      if_inst->dst.cond_mask = COND_NE;
   } else {
      if_inst = emit(ir->condition, OPCODE_IF, undef_dst, this->result);
   }

   this->instructions.push_tail(if_inst);

   visit_exec_list(&ir->then_instructions, this);

   if (!ir->else_instructions.is_empty()) {
      emit(ir->condition, OPCODE_ELSE);
      visit_exec_list(&ir->else_instructions, this);
   }

   emit(ir->condition, OPCODE_ENDIF);
}

void
ir_to_mesa_visitor::visit(ir_emit_vertex *)
{
   assert(!"Geometry shaders not supported.");
}

void
ir_to_mesa_visitor::visit(ir_end_primitive *)
{
   assert(!"Geometry shaders not supported.");
}

ir_to_mesa_visitor::ir_to_mesa_visitor()
{
   result.file = PROGRAM_UNDEFINED;
   next_temp = 1;
   next_signature_id = 1;
   current_function = NULL;
   mem_ctx = ralloc_context(NULL);
}

ir_to_mesa_visitor::~ir_to_mesa_visitor()
{
   ralloc_free(mem_ctx);
}

static struct prog_src_register
mesa_src_reg_from_ir_src_reg(src_reg reg)
{
   struct prog_src_register mesa_reg;

   mesa_reg.File = reg.file;
   assert(reg.index < (1 << INST_INDEX_BITS));
   mesa_reg.Index = reg.index;
   mesa_reg.Swizzle = reg.swizzle;
   mesa_reg.RelAddr = reg.reladdr != NULL;
   mesa_reg.Negate = reg.negate;
   mesa_reg.Abs = 0;
   mesa_reg.HasIndex2 = GL_FALSE;
   mesa_reg.RelAddr2 = 0;
   mesa_reg.Index2 = 0;

   return mesa_reg;
}

static void
set_branchtargets(ir_to_mesa_visitor *v,
		  struct prog_instruction *mesa_instructions,
		  int num_instructions)
{
   int if_count = 0, loop_count = 0;
   int *if_stack, *loop_stack;
   int if_stack_pos = 0, loop_stack_pos = 0;
   int i, j;

   for (i = 0; i < num_instructions; i++) {
      switch (mesa_instructions[i].Opcode) {
      case OPCODE_IF:
	 if_count++;
	 break;
      case OPCODE_BGNLOOP:
	 loop_count++;
	 break;
      case OPCODE_BRK:
      case OPCODE_CONT:
	 mesa_instructions[i].BranchTarget = -1;
	 break;
      default:
	 break;
      }
   }

   if_stack = rzalloc_array(v->mem_ctx, int, if_count);
   loop_stack = rzalloc_array(v->mem_ctx, int, loop_count);

   for (i = 0; i < num_instructions; i++) {
      switch (mesa_instructions[i].Opcode) {
      case OPCODE_IF:
	 if_stack[if_stack_pos] = i;
	 if_stack_pos++;
	 break;
      case OPCODE_ELSE:
	 mesa_instructions[if_stack[if_stack_pos - 1]].BranchTarget = i;
	 if_stack[if_stack_pos - 1] = i;
	 break;
      case OPCODE_ENDIF:
	 mesa_instructions[if_stack[if_stack_pos - 1]].BranchTarget = i;
	 if_stack_pos--;
	 break;
      case OPCODE_BGNLOOP:
	 loop_stack[loop_stack_pos] = i;
	 loop_stack_pos++;
	 break;
      case OPCODE_ENDLOOP:
	 loop_stack_pos--;
	 /* Rewrite any breaks/conts at this nesting level (haven't
	  * already had a BranchTarget assigned) to point to the end
	  * of the loop.
	  */
	 for (j = loop_stack[loop_stack_pos]; j < i; j++) {
	    if (mesa_instructions[j].Opcode == OPCODE_BRK ||
		mesa_instructions[j].Opcode == OPCODE_CONT) {
	       if (mesa_instructions[j].BranchTarget == -1) {
		  mesa_instructions[j].BranchTarget = i;
	       }
	    }
	 }
	 /* The loop ends point at each other. */
	 mesa_instructions[i].BranchTarget = loop_stack[loop_stack_pos];
	 mesa_instructions[loop_stack[loop_stack_pos]].BranchTarget = i;
	 break;
      case OPCODE_CAL:
	 foreach_list(n, &v->function_signatures) {
	    function_entry *entry = (function_entry *) n;

	    if (entry->sig_id == mesa_instructions[i].BranchTarget) {
	       mesa_instructions[i].BranchTarget = entry->inst;
	       break;
	    }
	 }
	 break;
      default:
	 break;
      }
   }
}

static void
print_program(struct prog_instruction *mesa_instructions,
	      ir_instruction **mesa_instruction_annotation,
	      int num_instructions)
{
   ir_instruction *last_ir = NULL;
   int i;
   int indent = 0;

   for (i = 0; i < num_instructions; i++) {
      struct prog_instruction *mesa_inst = mesa_instructions + i;
      ir_instruction *ir = mesa_instruction_annotation[i];

      fprintf(stdout, "%3d: ", i);

      if (last_ir != ir && ir) {
	 int j;

	 for (j = 0; j < indent; j++) {
	    fprintf(stdout, " ");
	 }
	 ir->print();
	 printf("\n");
	 last_ir = ir;

	 fprintf(stdout, "     "); /* line number spacing. */
      }

      indent = _mesa_fprint_instruction_opt(stdout, mesa_inst, indent,
					    PROG_PRINT_DEBUG, NULL);
   }
}

namespace {

class add_uniform_to_shader : public program_resource_visitor {
public:
   add_uniform_to_shader(struct gl_shader_program *shader_program,
			 struct gl_program_parameter_list *params,
                         gl_shader_stage shader_type)
      : shader_program(shader_program), params(params), idx(-1),
        shader_type(shader_type)
   {
      /* empty */
   }

   void process(ir_variable *var)
   {
      this->idx = -1;
      this->program_resource_visitor::process(var);

      var->data.location = this->idx;
   }

private:
   virtual void visit_field(const glsl_type *type, const char *name,
                            bool row_major);

   struct gl_shader_program *shader_program;
   struct gl_program_parameter_list *params;
   int idx;
   gl_shader_stage shader_type;
};

} /* anonymous namespace */

void
add_uniform_to_shader::visit_field(const glsl_type *type, const char *name,
                                   bool row_major)
{
   unsigned int size;

   (void) row_major;

   if (type->is_vector() || type->is_scalar()) {
      size = type->vector_elements;
   } else {
      size = type_size(type) * 4;
   }

   gl_register_file file;
   if (type->is_sampler() ||
       (type->is_array() && type->fields.array->is_sampler())) {
      file = PROGRAM_SAMPLER;
   } else {
      file = PROGRAM_UNIFORM;
   }

   int index = _mesa_lookup_parameter_index(params, -1, name);
   if (index < 0) {
      index = _mesa_add_parameter(params, file, name, size, type->gl_type,
				  NULL, NULL);

      /* Sampler uniform values are stored in prog->SamplerUnits,
       * and the entry in that array is selected by this index we
       * store in ParameterValues[].
       */
      if (file == PROGRAM_SAMPLER) {
	 unsigned location;
	 const bool found =
	    this->shader_program->UniformHash->get(location,
						   params->Parameters[index].Name);
	 assert(found);

	 if (!found)
	    return;

	 struct gl_uniform_storage *storage =
	    &this->shader_program->UniformStorage[location];

         assert(storage->sampler[shader_type].active);

	 for (unsigned int j = 0; j < size / 4; j++)
            params->ParameterValues[index + j][0].f =
               storage->sampler[shader_type].index + j;
      }
   }

   /* The first part of the uniform that's processed determines the base
    * location of the whole uniform (for structures).
    */
   if (this->idx < 0)
      this->idx = index;
}

/**
 * Generate the program parameters list for the user uniforms in a shader
 *
 * \param shader_program Linked shader program.  This is only used to
 *                       emit possible link errors to the info log.
 * \param sh             Shader whose uniforms are to be processed.
 * \param params         Parameter list to be filled in.
 */
void
_mesa_generate_parameters_list_for_uniforms(struct gl_shader_program
					    *shader_program,
					    struct gl_shader *sh,
					    struct gl_program_parameter_list
					    *params)
{
   add_uniform_to_shader add(shader_program, params, sh->Stage);

   foreach_list(node, sh->ir) {
      ir_variable *var = ((ir_instruction *) node)->as_variable();

      if ((var == NULL) || (var->data.mode != ir_var_uniform)
	  || var->is_in_uniform_block() || (strncmp(var->name, "gl_", 3) == 0))
	 continue;

      add.process(var);
   }
}

void
_mesa_associate_uniform_storage(struct gl_context *ctx,
				struct gl_shader_program *shader_program,
				struct gl_program_parameter_list *params)
{
   /* After adding each uniform to the parameter list, connect the storage for
    * the parameter with the tracking structure used by the API for the
    * uniform.
    */
   unsigned last_location = unsigned(~0);
   for (unsigned i = 0; i < params->NumParameters; i++) {
      if (params->Parameters[i].Type != PROGRAM_UNIFORM)
	 continue;

      unsigned location;
      const bool found =
	 shader_program->UniformHash->get(location, params->Parameters[i].Name);
      assert(found);

      if (!found)
	 continue;

      if (location != last_location) {
	 struct gl_uniform_storage *storage =
	    &shader_program->UniformStorage[location];
	 enum gl_uniform_driver_format format = uniform_native;

	 unsigned columns = 0;
	 switch (storage->type->base_type) {
	 case GLSL_TYPE_UINT:
	    assert(ctx->Const.NativeIntegers);
	    format = uniform_native;
	    columns = 1;
	    break;
	 case GLSL_TYPE_INT:
	    format =
	       (ctx->Const.NativeIntegers) ? uniform_native : uniform_int_float;
	    columns = 1;
	    break;
	 case GLSL_TYPE_FLOAT:
	    format = uniform_native;
	    columns = storage->type->matrix_columns;
	    break;
	 case GLSL_TYPE_BOOL:
	    if (ctx->Const.NativeIntegers) {
	       format = (ctx->Const.UniformBooleanTrue == 1)
		  ? uniform_bool_int_0_1 : uniform_bool_int_0_not0;
	    } else {
	       format = uniform_bool_float;
	    }
	    columns = 1;
	    break;
	 case GLSL_TYPE_SAMPLER:
	 case GLSL_TYPE_IMAGE:
	    format = uniform_native;
	    columns = 1;
	    break;
         case GLSL_TYPE_ATOMIC_UINT:
         case GLSL_TYPE_ARRAY:
         case GLSL_TYPE_VOID:
         case GLSL_TYPE_STRUCT:
         case GLSL_TYPE_ERROR:
         case GLSL_TYPE_INTERFACE:
	    assert(!"Should not get here.");
	    break;
	 }

	 _mesa_uniform_attach_driver_storage(storage,
					     4 * sizeof(float) * columns,
					     4 * sizeof(float),
					     format,
					     &params->ParameterValues[i]);

	 /* After attaching the driver's storage to the uniform, propagate any
	  * data from the linker's backing store.  This will cause values from
	  * initializers in the source code to be copied over.
	  */
	 _mesa_propagate_uniforms_to_driver_storage(storage,
						    0,
						    MAX2(1, storage->array_elements));

	 last_location = location;
      }
   }
}

/*
 * On a basic block basis, tracks available PROGRAM_TEMPORARY register
 * channels for copy propagation and updates following instructions to
 * use the original versions.
 *
 * The ir_to_mesa_visitor lazily produces code assuming that this pass
 * will occur.  As an example, a TXP production before this pass:
 *
 * 0: MOV TEMP[1], INPUT[4].xyyy;
 * 1: MOV TEMP[1].w, INPUT[4].wwww;
 * 2: TXP TEMP[2], TEMP[1], texture[0], 2D;
 *
 * and after:
 *
 * 0: MOV TEMP[1], INPUT[4].xyyy;
 * 1: MOV TEMP[1].w, INPUT[4].wwww;
 * 2: TXP TEMP[2], INPUT[4].xyyw, texture[0], 2D;
 *
 * which allows for dead code elimination on TEMP[1]'s writes.
 */
void
ir_to_mesa_visitor::copy_propagate(void)
{
   ir_to_mesa_instruction **acp = rzalloc_array(mem_ctx,
						    ir_to_mesa_instruction *,
						    this->next_temp * 4);
   int *acp_level = rzalloc_array(mem_ctx, int, this->next_temp * 4);
   int level = 0;

   foreach_list(node, &this->instructions) {
      ir_to_mesa_instruction *inst = (ir_to_mesa_instruction *) node;

      assert(inst->dst.file != PROGRAM_TEMPORARY
	     || inst->dst.index < this->next_temp);

      /* First, do any copy propagation possible into the src regs. */
      for (int r = 0; r < 3; r++) {
	 ir_to_mesa_instruction *first = NULL;
	 bool good = true;
	 int acp_base = inst->src[r].index * 4;

	 if (inst->src[r].file != PROGRAM_TEMPORARY ||
	     inst->src[r].reladdr)
	    continue;

	 /* See if we can find entries in the ACP consisting of MOVs
	  * from the same src register for all the swizzled channels
	  * of this src register reference.
	  */
	 for (int i = 0; i < 4; i++) {
	    int src_chan = GET_SWZ(inst->src[r].swizzle, i);
	    ir_to_mesa_instruction *copy_chan = acp[acp_base + src_chan];

	    if (!copy_chan) {
	       good = false;
	       break;
	    }

	    assert(acp_level[acp_base + src_chan] <= level);

	    if (!first) {
	       first = copy_chan;
	    } else {
	       if (first->src[0].file != copy_chan->src[0].file ||
		   first->src[0].index != copy_chan->src[0].index) {
		  good = false;
		  break;
	       }
	    }
	 }

	 if (good) {
	    /* We've now validated that we can copy-propagate to
	     * replace this src register reference.  Do it.
	     */
	    inst->src[r].file = first->src[0].file;
	    inst->src[r].index = first->src[0].index;

	    int swizzle = 0;
	    for (int i = 0; i < 4; i++) {
	       int src_chan = GET_SWZ(inst->src[r].swizzle, i);
	       ir_to_mesa_instruction *copy_inst = acp[acp_base + src_chan];
	       swizzle |= (GET_SWZ(copy_inst->src[0].swizzle, src_chan) <<
			   (3 * i));
	    }
	    inst->src[r].swizzle = swizzle;
	 }
      }

      switch (inst->op) {
      case OPCODE_BGNLOOP:
      case OPCODE_ENDLOOP:
	 /* End of a basic block, clear the ACP entirely. */
	 memset(acp, 0, sizeof(*acp) * this->next_temp * 4);
	 break;

      case OPCODE_IF:
	 ++level;
	 break;

      case OPCODE_ENDIF:
      case OPCODE_ELSE:
	 /* Clear all channels written inside the block from the ACP, but
	  * leaving those that were not touched.
	  */
	 for (int r = 0; r < this->next_temp; r++) {
	    for (int c = 0; c < 4; c++) {
	       if (!acp[4 * r + c])
		  continue;

	       if (acp_level[4 * r + c] >= level)
		  acp[4 * r + c] = NULL;
	    }
	 }
	 if (inst->op == OPCODE_ENDIF)
	    --level;
	 break;

      default:
	 /* Continuing the block, clear any written channels from
	  * the ACP.
	  */
	 if (inst->dst.file == PROGRAM_TEMPORARY && inst->dst.reladdr) {
	    /* Any temporary might be written, so no copy propagation
	     * across this instruction.
	     */
	    memset(acp, 0, sizeof(*acp) * this->next_temp * 4);
	 } else if (inst->dst.file == PROGRAM_OUTPUT &&
		    inst->dst.reladdr) {
	    /* Any output might be written, so no copy propagation
	     * from outputs across this instruction.
	     */
	    for (int r = 0; r < this->next_temp; r++) {
	       for (int c = 0; c < 4; c++) {
		  if (!acp[4 * r + c])
		     continue;

		  if (acp[4 * r + c]->src[0].file == PROGRAM_OUTPUT)
		     acp[4 * r + c] = NULL;
	       }
	    }
	 } else if (inst->dst.file == PROGRAM_TEMPORARY ||
		    inst->dst.file == PROGRAM_OUTPUT) {
	    /* Clear where it's used as dst. */
	    if (inst->dst.file == PROGRAM_TEMPORARY) {
	       for (int c = 0; c < 4; c++) {
		  if (inst->dst.writemask & (1 << c)) {
		     acp[4 * inst->dst.index + c] = NULL;
		  }
	       }
	    }

	    /* Clear where it's used as src. */
	    for (int r = 0; r < this->next_temp; r++) {
	       for (int c = 0; c < 4; c++) {
		  if (!acp[4 * r + c])
		     continue;

		  int src_chan = GET_SWZ(acp[4 * r + c]->src[0].swizzle, c);

		  if (acp[4 * r + c]->src[0].file == inst->dst.file &&
		      acp[4 * r + c]->src[0].index == inst->dst.index &&
		      inst->dst.writemask & (1 << src_chan))
		  {
		     acp[4 * r + c] = NULL;
		  }
	       }
	    }
	 }
	 break;
      }

      /* If this is a copy, add it to the ACP. */
      if (inst->op == OPCODE_MOV &&
	  inst->dst.file == PROGRAM_TEMPORARY &&
	  !(inst->dst.file == inst->src[0].file &&
	    inst->dst.index == inst->src[0].index) &&
	  !inst->dst.reladdr &&
	  !inst->saturate &&
	  !inst->src[0].reladdr &&
	  !inst->src[0].negate) {
	 for (int i = 0; i < 4; i++) {
	    if (inst->dst.writemask & (1 << i)) {
	       acp[4 * inst->dst.index + i] = inst;
	       acp_level[4 * inst->dst.index + i] = level;
	    }
	 }
      }
   }

   ralloc_free(acp_level);
   ralloc_free(acp);
}


/**
 * Convert a shader's GLSL IR into a Mesa gl_program.
 */
static struct gl_program *
get_mesa_program(struct gl_context *ctx,
                 struct gl_shader_program *shader_program,
		 struct gl_shader *shader)
{
   ir_to_mesa_visitor v;
   struct prog_instruction *mesa_instructions, *mesa_inst;
   ir_instruction **mesa_instruction_annotation;
   int i;
   struct gl_program *prog;
   GLenum target = _mesa_shader_stage_to_program(shader->Stage);
   const char *target_string = _mesa_shader_stage_to_string(shader->Stage);
   struct gl_shader_compiler_options *options =
         &ctx->ShaderCompilerOptions[shader->Stage];

   validate_ir_tree(shader->ir);

   prog = ctx->Driver.NewProgram(ctx, target, shader_program->Name);
   if (!prog)
      return NULL;
   prog->Parameters = _mesa_new_parameter_list();
   v.ctx = ctx;
   v.prog = prog;
   v.shader_program = shader_program;
   v.options = options;

   _mesa_generate_parameters_list_for_uniforms(shader_program, shader,
					       prog->Parameters);

   /* Emit Mesa IR for main(). */
   visit_exec_list(shader->ir, &v);
   v.emit(NULL, OPCODE_END);

   prog->NumTemporaries = v.next_temp;

   int num_instructions = 0;
   foreach_list(node, &v.instructions) {
      num_instructions++;
   }

   mesa_instructions =
      (struct prog_instruction *)calloc(num_instructions,
					sizeof(*mesa_instructions));
   mesa_instruction_annotation = ralloc_array(v.mem_ctx, ir_instruction *,
					      num_instructions);

   v.copy_propagate();

   /* Convert ir_mesa_instructions into prog_instructions.
    */
   mesa_inst = mesa_instructions;
   i = 0;
   foreach_list(node, &v.instructions) {
      const ir_to_mesa_instruction *inst = (ir_to_mesa_instruction *) node;

      mesa_inst->Opcode = inst->op;
      mesa_inst->CondUpdate = inst->cond_update;
      if (inst->saturate)
	 mesa_inst->SaturateMode = SATURATE_ZERO_ONE;
      mesa_inst->DstReg.File = inst->dst.file;
      mesa_inst->DstReg.Index = inst->dst.index;
      mesa_inst->DstReg.CondMask = inst->dst.cond_mask;
      mesa_inst->DstReg.WriteMask = inst->dst.writemask;
      mesa_inst->DstReg.RelAddr = inst->dst.reladdr != NULL;
      mesa_inst->SrcReg[0] = mesa_src_reg_from_ir_src_reg(inst->src[0]);
      mesa_inst->SrcReg[1] = mesa_src_reg_from_ir_src_reg(inst->src[1]);
      mesa_inst->SrcReg[2] = mesa_src_reg_from_ir_src_reg(inst->src[2]);
      mesa_inst->TexSrcUnit = inst->sampler;
      mesa_inst->TexSrcTarget = inst->tex_target;
      mesa_inst->TexShadow = inst->tex_shadow;
      mesa_instruction_annotation[i] = inst->ir;

      /* Set IndirectRegisterFiles. */
      if (mesa_inst->DstReg.RelAddr)
         prog->IndirectRegisterFiles |= 1 << mesa_inst->DstReg.File;

      /* Update program's bitmask of indirectly accessed register files */
      for (unsigned src = 0; src < 3; src++)
         if (mesa_inst->SrcReg[src].RelAddr)
            prog->IndirectRegisterFiles |= 1 << mesa_inst->SrcReg[src].File;

      switch (mesa_inst->Opcode) {
      case OPCODE_IF:
	 if (options->MaxIfDepth == 0) {
	    linker_warning(shader_program,
			   "Couldn't flatten if-statement.  "
			   "This will likely result in software "
			   "rasterization.\n");
	 }
	 break;
      case OPCODE_BGNLOOP:
	 if (options->EmitNoLoops) {
	    linker_warning(shader_program,
			   "Couldn't unroll loop.  "
			   "This will likely result in software "
			   "rasterization.\n");
	 }
	 break;
      case OPCODE_CONT:
	 if (options->EmitNoCont) {
	    linker_warning(shader_program,
			   "Couldn't lower continue-statement.  "
			   "This will likely result in software "
			   "rasterization.\n");
	 }
	 break;
      case OPCODE_ARL:
	 prog->NumAddressRegs = 1;
	 break;
      default:
	 break;
      }

      mesa_inst++;
      i++;

      if (!shader_program->LinkStatus)
         break;
   }

   if (!shader_program->LinkStatus) {
      goto fail_exit;
   }

   set_branchtargets(&v, mesa_instructions, num_instructions);

   if (ctx->_Shader->Flags & GLSL_DUMP) {
      fprintf(stderr, "\n");
      fprintf(stderr, "GLSL IR for linked %s program %d:\n", target_string,
	      shader_program->Name);
      _mesa_print_ir(stderr, shader->ir, NULL);
      fprintf(stderr, "\n");
      fprintf(stderr, "\n");
      fprintf(stderr, "Mesa IR for linked %s program %d:\n", target_string,
	      shader_program->Name);
      print_program(mesa_instructions, mesa_instruction_annotation,
		    num_instructions);
      fflush(stderr);
   }

   prog->Instructions = mesa_instructions;
   prog->NumInstructions = num_instructions;

   /* Setting this to NULL prevents a possible double free in the fail_exit
    * path (far below).
    */
   mesa_instructions = NULL;

   do_set_program_inouts(shader->ir, prog, shader->Stage);

   prog->SamplersUsed = shader->active_samplers;
   prog->ShadowSamplers = shader->shadow_samplers;
   _mesa_update_shader_textures_used(shader_program, prog);

   /* Set the gl_FragDepth layout. */
   if (target == GL_FRAGMENT_PROGRAM_ARB) {
      struct gl_fragment_program *fp = (struct gl_fragment_program *)prog;
      fp->FragDepthLayout = shader_program->FragDepthLayout;
   }

   _mesa_reference_program(ctx, &shader->Program, prog);

   if ((ctx->_Shader->Flags & GLSL_NO_OPT) == 0) {
      _mesa_optimize_program(ctx, prog);
   }

   /* This has to be done last.  Any operation that can cause
    * prog->ParameterValues to get reallocated (e.g., anything that adds a
    * program constant) has to happen before creating this linkage.
    */
   _mesa_associate_uniform_storage(ctx, shader_program, prog->Parameters);
   if (!shader_program->LinkStatus) {
      goto fail_exit;
   }

   return prog;

fail_exit:
   free(mesa_instructions);
   _mesa_reference_program(ctx, &shader->Program, NULL);
   return NULL;
}

extern "C" {

/**
 * Link a shader.
 * Called via ctx->Driver.LinkShader()
 * This actually involves converting GLSL IR into Mesa gl_programs with
 * code lowering and other optimizations.
 */
GLboolean
_mesa_ir_link_shader(struct gl_context *ctx, struct gl_shader_program *prog)
{
   assert(prog->LinkStatus);

   for (unsigned i = 0; i < MESA_SHADER_STAGES; i++) {
      if (prog->_LinkedShaders[i] == NULL)
	 continue;

      bool progress;
      exec_list *ir = prog->_LinkedShaders[i]->ir;
      const struct gl_shader_compiler_options *options =
            &ctx->ShaderCompilerOptions[prog->_LinkedShaders[i]->Stage];

      do {
	 progress = false;

	 /* Lowering */
	 do_mat_op_to_vec(ir);
	 lower_instructions(ir, (MOD_TO_FRACT | DIV_TO_MUL_RCP | EXP_TO_EXP2
				 | LOG_TO_LOG2 | INT_DIV_TO_MUL_RCP
				 | ((options->EmitNoPow) ? POW_TO_EXP2 : 0)));

	 progress = do_lower_jumps(ir, true, true, options->EmitNoMainReturn, options->EmitNoCont, options->EmitNoLoops) || progress;

	 progress = do_common_optimization(ir, true, true,
                                           options, ctx->Const.NativeIntegers)
	   || progress;

	 progress = lower_quadop_vector(ir, true) || progress;

	 if (options->MaxIfDepth == 0)
	    progress = lower_discard(ir) || progress;

	 progress = lower_if_to_cond_assign(ir, options->MaxIfDepth) || progress;

	 if (options->EmitNoNoise)
	    progress = lower_noise(ir) || progress;

	 /* If there are forms of indirect addressing that the driver
	  * cannot handle, perform the lowering pass.
	  */
	 if (options->EmitNoIndirectInput || options->EmitNoIndirectOutput
	     || options->EmitNoIndirectTemp || options->EmitNoIndirectUniform)
	   progress =
	     lower_variable_index_to_cond_assign(ir,
						 options->EmitNoIndirectInput,
						 options->EmitNoIndirectOutput,
						 options->EmitNoIndirectTemp,
						 options->EmitNoIndirectUniform)
	     || progress;

	 progress = do_vec_index_to_cond_assign(ir) || progress;
         progress = lower_vector_insert(ir, true) || progress;
      } while (progress);

      validate_ir_tree(ir);
   }

   for (unsigned i = 0; i < MESA_SHADER_STAGES; i++) {
      struct gl_program *linked_prog;

      if (prog->_LinkedShaders[i] == NULL)
	 continue;

      linked_prog = get_mesa_program(ctx, prog, prog->_LinkedShaders[i]);

      if (linked_prog) {
         _mesa_copy_linked_program_data((gl_shader_stage) i, prog, linked_prog);

	 _mesa_reference_program(ctx, &prog->_LinkedShaders[i]->Program,
				 linked_prog);
         if (!ctx->Driver.ProgramStringNotify(ctx,
                                              _mesa_shader_stage_to_program(i),
                                              linked_prog)) {
            return GL_FALSE;
         }
      }

      _mesa_reference_program(ctx, &linked_prog, NULL);
   }

   return prog->LinkStatus;
}

/**
 * Link a GLSL shader program.  Called via glLinkProgram().
 */
void
_mesa_glsl_link_shader(struct gl_context *ctx, struct gl_shader_program *prog)
{
   unsigned int i;

   _mesa_clear_shader_program_data(ctx, prog);

   prog->LinkStatus = GL_TRUE;

   for (i = 0; i < prog->NumShaders; i++) {
      if (!prog->Shaders[i]->CompileStatus) {
	 linker_error(prog, "linking with uncompiled shader");
      }
   }

   if (prog->LinkStatus) {
      link_shaders(ctx, prog);
   }

   if (prog->LinkStatus) {
      if (!ctx->Driver.LinkShader(ctx, prog)) {
	 prog->LinkStatus = GL_FALSE;
      }
   }

   if (ctx->_Shader->Flags & GLSL_DUMP) {
      if (!prog->LinkStatus) {
	 fprintf(stderr, "GLSL shader program %d failed to link\n", prog->Name);
      }

      if (prog->InfoLog && prog->InfoLog[0] != 0) {
	 fprintf(stderr, "GLSL shader program %d info log:\n", prog->Name);
	 fprintf(stderr, "%s\n", prog->InfoLog);
      }
   }
}

} /* extern "C" */
@


1.6
log
@Merge Mesa 10.2.9
@
text
@@


1.5
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d314 1
d666 5
a670 1
   foreach_in_list(variable_storage, entry, &this->variables) {
d690 2
a691 2
      const ir_state_slot *const slots = ir->get_state_slots();
      assert(slots != NULL);
d699 1
a699 1
      for (i = 0; i < ir->get_num_state_slots(); i++) {
d707 1
a707 1
      if (i == ir->get_num_state_slots()) {
d718 1
a718 1
	 assert((int) ir->get_num_state_slots() == type_size(ir->type));
d729 1
a729 1
      for (unsigned int i = 0; i < ir->get_num_state_slots(); i++) {
d749 1
a749 1
	  dst.index != storage->index + (int) ir->get_num_state_slots()) {
d800 1
a800 1
      sig = ir->matching_signature(NULL, &empty, false);
d804 3
a806 1
      foreach_in_list(ir_instruction, ir, &sig->body) {
d875 44
d1081 3
a1179 6
   case ir_unop_saturate: {
      ir_to_mesa_instruction *inst = emit(ir, OPCODE_MOV,
                                          result_dst, op[0]);
      inst->saturate = true;
      break;
   }
a1464 7
   case ir_unop_interpolate_at_centroid:
   case ir_binop_interpolate_at_offset:
   case ir_binop_interpolate_at_sample:
   case ir_unop_dFdx_coarse:
   case ir_unop_dFdx_fine:
   case ir_unop_dFdy_coarse:
   case ir_unop_dFdy_fine:
d1871 2
a1872 1
      foreach_in_list(ir_constant, field_value, &ir->components) {
d2341 3
a2343 1
	 foreach_in_list(function_entry, entry, &v->function_signatures) {
d2437 2
a2438 1
   if (type->without_array()->is_sampler()) {
d2498 2
a2499 2
   foreach_in_list(ir_instruction, node, sh->ir) {
      ir_variable *var = node->as_variable();
d2553 6
a2558 1
	    format = uniform_native;
d2624 3
a2626 1
   foreach_in_list(ir_to_mesa_instruction, inst, &this->instructions) {
d2806 1
a2806 1
         &ctx->Const.ShaderCompilerOptions[shader->Stage];
d2828 4
a2831 1
   unsigned num_instructions = v.instructions.length();
d2845 3
a2847 1
   foreach_in_list(const ir_to_mesa_instruction, inst, &v.instructions) {
d2996 1
a2996 1
            &ctx->Const.ShaderCompilerOptions[prog->_LinkedShaders[i]->Stage];
a3002 1
	 GLenum target = _mesa_shader_stage_to_program(prog->_LinkedShaders[i]->Stage);
d3077 1
a3077 1
   _mesa_clear_shader_program_data(prog);
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@a313 1
   bool try_emit_sat(ir_expression *ir);
d665 1
a665 5
   variable_storage *entry;

   foreach_list(node, &this->variables) {
      entry = (variable_storage *) node;

d685 2
a686 2
      const ir_state_slot *const slots = ir->state_slots;
      assert(ir->state_slots != NULL);
d694 1
a694 1
      for (i = 0; i < ir->num_state_slots; i++) {
d702 1
a702 1
      if (i == ir->num_state_slots) {
d713 1
a713 1
	 assert((int) ir->num_state_slots == type_size(ir->type));
d724 1
a724 1
      for (unsigned int i = 0; i < ir->num_state_slots; i++) {
d744 1
a744 1
	  dst.index != storage->index + (int) ir->num_state_slots) {
d795 1
a795 1
      sig = ir->matching_signature(NULL, &empty);
d799 1
a799 3
      foreach_list(node, &sig->body) {
	 ir_instruction *ir = (ir_instruction *) node;

a867 44
bool
ir_to_mesa_visitor::try_emit_sat(ir_expression *ir)
{
   /* Saturates were only introduced to vertex programs in
    * NV_vertex_program3, so don't give them to drivers in the VP.
    */
   if (this->prog->Target == GL_VERTEX_PROGRAM_ARB)
      return false;

   ir_rvalue *sat_src = ir->as_rvalue_to_saturate();
   if (!sat_src)
      return false;

   sat_src->accept(this);
   src_reg src = this->result;

   /* If we generated an expression instruction into a temporary in
    * processing the saturate's operand, apply the saturate to that
    * instruction.  Otherwise, generate a MOV to do the saturate.
    *
    * Note that we have to be careful to only do this optimization if
    * the instruction in question was what generated src->result.  For
    * example, ir_dereference_array might generate a MUL instruction
    * to create the reladdr, and return us a src reg using that
    * reladdr.  That MUL result is not the value we're trying to
    * saturate.
    */
   ir_expression *sat_src_expr = sat_src->as_expression();
   ir_to_mesa_instruction *new_inst;
   new_inst = (ir_to_mesa_instruction *)this->instructions.get_tail();
   if (sat_src_expr && (sat_src_expr->operation == ir_binop_mul ||
			sat_src_expr->operation == ir_binop_add ||
			sat_src_expr->operation == ir_binop_dot)) {
      new_inst->saturate = true;
   } else {
      this->result = get_temp(ir->type);
      ir_to_mesa_instruction *inst;
      inst = emit(ir, OPCODE_MOV, dst_reg(this->result), src);
      inst->saturate = true;
   }

   return true;
}

a1029 3
   if (try_emit_sat(ir))
      return;

d1126 6
d1417 7
d1830 1
a1830 2
      foreach_list(node, &ir->components) {
	 ir_constant *field_value = (ir_constant *) node;
d2299 1
a2299 3
	 foreach_list(n, &v->function_signatures) {
	    function_entry *entry = (function_entry *) n;

d2393 1
a2393 2
   if (type->is_sampler() ||
       (type->is_array() && type->fields.array->is_sampler())) {
d2453 2
a2454 2
   foreach_list(node, sh->ir) {
      ir_variable *var = ((ir_instruction *) node)->as_variable();
d2508 1
a2508 6
	    if (ctx->Const.NativeIntegers) {
	       format = (ctx->Const.UniformBooleanTrue == 1)
		  ? uniform_bool_int_0_1 : uniform_bool_int_0_not0;
	    } else {
	       format = uniform_bool_float;
	    }
d2574 1
a2574 3
   foreach_list(node, &this->instructions) {
      ir_to_mesa_instruction *inst = (ir_to_mesa_instruction *) node;

d2754 1
a2754 1
         &ctx->ShaderCompilerOptions[shader->Stage];
d2776 1
a2776 4
   int num_instructions = 0;
   foreach_list(node, &v.instructions) {
      num_instructions++;
   }
d2790 1
a2790 3
   foreach_list(node, &v.instructions) {
      const ir_to_mesa_instruction *inst = (ir_to_mesa_instruction *) node;

d2939 1
a2939 1
            &ctx->ShaderCompilerOptions[prog->_LinkedShaders[i]->Stage];
d2946 1
d3021 1
a3021 1
   _mesa_clear_shader_program_data(ctx, prog);
@


1.3
log
@Merge Mesa 9.2.0
@
text
@d47 1
a51 1
#include "main/uniforms.h"
d60 4
a66 2
static int swizzle_for_size(int size);

d134 2
d154 2
d158 1
a158 11
   /* Callers of this ralloc-based new need not call delete. It's
    * easier to just ralloc_free 'ctx' (or any of its ancestors). */
   static void* operator new(size_t size, void *ctx)
   {
      void *node;

      node = rzalloc_size(ctx, size);
      assert(node != NULL);

      return node;
   }
d232 1
a232 1
   variable_storage *find_variable_storage(ir_variable *var);
d264 2
d325 2
d621 1
d626 1
d664 1
a664 1
ir_to_mesa_visitor::find_variable_storage(ir_variable *var)
a665 1
   
d668 2
a669 2
   foreach_iter(exec_list_iterator, iter, this->variables) {
      entry = (variable_storage *)iter.get();
d684 2
a685 2
      fp->OriginUpperLeft = ir->origin_upper_left;
      fp->PixelCenterInteger = ir->pixel_center_integer;
d688 1
a688 1
   if (ir->mode == ir_var_uniform && strncmp(ir->name, "gl_", 3) == 0) {
a761 14
   ir_dereference_variable *counter = NULL;

   if (ir->counter != NULL)
      counter = new(mem_ctx) ir_dereference_variable(ir->counter);

   if (ir->from != NULL) {
      assert(ir->counter != NULL);

      ir_assignment *a =
	new(mem_ctx) ir_assignment(counter, ir->from, NULL);

      a->accept(this);
   }

a763 14
   if (ir->to) {
      ir_expression *e =
	 new(mem_ctx) ir_expression(ir->cmp, glsl_type::bool_type,
					  counter, ir->to);
      ir_if *if_stmt =  new(mem_ctx) ir_if(e);

      ir_loop_jump *brk =
	new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break);

      if_stmt->then_instructions.push_tail(brk);

      if_stmt->accept(this);
   }

a765 11
   if (ir->increment) {
      ir_expression *e =
	 new(mem_ctx) ir_expression(ir_binop_add, counter->type,
					  counter, ir->increment);

      ir_assignment *a =
	new(mem_ctx) ir_assignment(counter, e, NULL);

      a->accept(this);
   }

d800 1
a800 1
      sig = ir->matching_signature(&empty);
d804 2
a805 2
      foreach_iter(exec_list_iterator, iter, sig->body) {
	 ir_instruction *ir = (ir_instruction *)iter.get();
d1455 1
d1460 5
d1531 1
a1531 1
      switch (var->mode) {
d1534 1
a1534 1
					       var->location);
d1543 1
a1543 1
	 assert(var->location != -1);
d1546 1
a1546 1
                                               var->location);
d1549 1
a1549 1
	 assert(var->location != -1);
d1552 1
a1552 1
                                               var->location);
d1557 1
a1557 1
                                               var->location);
d1871 2
a1872 2
      foreach_iter(exec_list_iterator, iter, ir->components) {
	 ir_constant *field_value = (ir_constant *)iter.get();
d1966 1
a1966 1
ir_to_mesa_visitor::visit(ir_call *ir)
d2034 6
d2226 13
a2238 1
   if_inst = emit(ir->condition, OPCODE_ENDIF);
d2341 2
a2342 2
	 foreach_iter(exec_list_iterator, iter, v->function_signatures) {
	    function_entry *entry = (function_entry *)iter.get();
d2389 2
d2395 1
a2395 1
                         gl_shader_type shader_type)
d2407 1
a2407 1
      var->location = this->idx;
d2417 1
a2417 1
   gl_shader_type shader_type;
d2420 2
d2496 1
a2496 2
   add_uniform_to_shader add(shader_program, params,
                             _mesa_shader_type_to_index(sh->Type));
d2501 1
a2501 1
      if ((var == NULL) || (var->mode != ir_var_uniform)
d2562 1
d2566 1
d2624 2
a2625 2
   foreach_iter(exec_list_iterator, iter, this->instructions) {
      ir_to_mesa_instruction *inst = (ir_to_mesa_instruction *)iter.get();
d2803 2
a2804 2
   GLenum target;
   const char *target_string = _mesa_glsl_shader_target_name(shader->Type);
d2806 1
a2806 16
         &ctx->ShaderCompilerOptions[_mesa_shader_type_to_index(shader->Type)];

   switch (shader->Type) {
   case GL_VERTEX_SHADER:
      target = GL_VERTEX_PROGRAM_ARB;
      break;
   case GL_FRAGMENT_SHADER:
      target = GL_FRAGMENT_PROGRAM_ARB;
      break;
   case GL_GEOMETRY_SHADER:
      target = GL_GEOMETRY_PROGRAM_NV;
      break;
   default:
      assert(!"should not be reached");
      return NULL;
   }
d2829 1
a2829 1
   foreach_iter(exec_list_iterator, iter, v.instructions) {
d2845 2
a2846 2
   foreach_iter(exec_list_iterator, iter, v.instructions) {
      const ir_to_mesa_instruction *inst = (ir_to_mesa_instruction *)iter.get();
d2919 9
a2927 9
   if (ctx->Shader.Flags & GLSL_DUMP) {
      printf("\n");
      printf("GLSL IR for linked %s program %d:\n", target_string,
	     shader_program->Name);
      _mesa_print_ir(shader->ir, NULL);
      printf("\n");
      printf("\n");
      printf("Mesa IR for linked %s program %d:\n", target_string,
	     shader_program->Name);
d2930 1
d2941 1
a2941 1
   do_set_program_inouts(shader->ir, prog, shader->Type == GL_FRAGMENT_SHADER);
d2955 1
a2955 1
   if ((ctx->Shader.Flags & GLSL_NO_OPT) == 0) {
d2989 1
a2989 1
   for (unsigned i = 0; i < MESA_SHADER_TYPES; i++) {
d2996 1
a2996 1
            &ctx->ShaderCompilerOptions[_mesa_shader_type_to_index(prog->_LinkedShaders[i]->Type)];
d3010 1
a3010 2
					   options->MaxUnrollIterations,
                                           options)
d3043 1
a3043 1
   for (unsigned i = 0; i < MESA_SHADER_TYPES; i++) {
d3052 1
a3052 4
	 if (i == MESA_SHADER_VERTEX) {
            ((struct gl_vertex_program *)linked_prog)->UsesClipDistance
               = prog->Vert.UsesClipDistance;
	 }
d3057 1
a3057 1
                                              _mesa_program_index_to_target(i),
a3083 1
	 prog->LinkStatus = GL_FALSE;
d3097 1
a3097 1
   if (ctx->Shader.Flags & GLSL_DUMP) {
d3099 1
a3099 1
	 printf("GLSL shader program %d failed to link\n", prog->Name);
d3103 2
a3104 2
	 printf("GLSL shader program %d info log:\n", prog->Name);
	 printf("%s\n", prog->InfoLog);
@


1.2
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a35 1
#include "ir_print_visitor.h"
d37 1
d43 5
a49 1
#include "main/mtypes.h"
a50 1
#include "main/shaderobj.h"
a51 1
#include "program/hash_table.h"
a55 1
#include "program/prog_uniform.h"
d95 1
a95 1
   int index; /**< temporary index, VERT_ATTRIB_*, FRAG_ATTRIB_*, etc. */
d125 1
a125 1
   int index; /**< temporary index, VERT_ATTRIB_*, FRAG_ATTRIB_*, etc. */
a173 2

   class function_entry *function; /* Set on OPCODE_CAL or OPCODE_BGNSUB */
a237 2
   function_entry *get_function_signature(ir_function_signature *sig);

d297 5
a301 5
   void emit_dp(ir_instruction *ir,
	        dst_reg dst,
	        src_reg src0,
	        src_reg src1,
	        unsigned elements);
d312 1
a312 1
   GLboolean try_emit_mad(ir_expression *ir,
d314 3
a316 1
   GLboolean try_emit_sat(ir_expression *ir);
d327 1
a327 1
src_reg undef_src = src_reg(PROGRAM_UNDEFINED, 0, NULL);
d329 1
a329 1
dst_reg undef_dst = dst_reg(PROGRAM_UNDEFINED, SWIZZLE_NOOP);
d331 1
a331 1
dst_reg address_reg = dst_reg(PROGRAM_ADDRESS, WRITEMASK_X);
d336 1
a336 1
   int size_swizzles[4] = {
a380 2
   inst->function = NULL;

d408 1
a408 1
void
d417 1
a417 1
   emit(ir, dot_opcodes[elements - 2], dst, src0, src1);
d579 1
a579 1
struct src_reg
d585 1
a585 1
					  &val, 1, &src.swizzle);
d625 5
a629 3
   default:
      assert(0);
      return 0;
d631 2
a644 2
   int swizzle[4];
   int i;
d654 1
a654 6
      for (i = 0; i < type->vector_elements; i++)
	 swizzle[i] = i;
      for (; i < 4; i++)
	 swizzle[i] = type->vector_elements - 1;
      src.swizzle = MAKE_SWIZZLE4(swizzle[0], swizzle[1],
				  swizzle[2], swizzle[3]);
a684 23

   } else if (strcmp(ir->name, "gl_FragDepth") == 0) {
      struct gl_fragment_program *fp = (struct gl_fragment_program *)this->prog;
      switch (ir->depth_layout) {
      case ir_depth_layout_none:
	 fp->FragDepthLayout = FRAG_DEPTH_LAYOUT_NONE;
	 break;
      case ir_depth_layout_any:
	 fp->FragDepthLayout = FRAG_DEPTH_LAYOUT_ANY;
	 break;
      case ir_depth_layout_greater:
	 fp->FragDepthLayout = FRAG_DEPTH_LAYOUT_GREATER;
	 break;
      case ir_depth_layout_less:
	 fp->FragDepthLayout = FRAG_DEPTH_LAYOUT_LESS;
	 break;
      case ir_depth_layout_unchanged:
	 fp->FragDepthLayout = FRAG_DEPTH_LAYOUT_UNCHANGED;
	 break;
      default:
	 assert(0);
	 break;
      }
d704 1
a704 1
      struct variable_storage *storage;
d850 1
a850 1
GLboolean
d873 41
a913 1
GLboolean
d929 24
a952 4
   this->result = get_temp(ir->type);
   ir_to_mesa_instruction *inst;
   inst = emit(ir, OPCODE_MOV, dst_reg(this->result), src);
   inst->saturate = true;
a1058 1
      ir_print_visitor v;
d1060 2
a1061 1
      deref->accept(&v);
d1109 10
a1130 1
	 ir_print_visitor v;
d1132 2
a1133 1
	 ir->operands[operand]->accept(&v);
d1166 7
a1172 1
      emit(ir, OPCODE_SEQ, result_dst, op[0], src_reg_for_float(0.0));
d1240 1
d1242 3
a1244 1
      assert(!"ir_binop_mod should have been converted to b * fract(a/b)");
d1271 4
d1276 8
a1283 1
	 emit(ir, OPCODE_SEQ, result_dst, result_src, src_reg_for_float(0.0));
d1294 20
a1313 2
	 emit_dp(ir, result_dst, temp, temp, vector_elements);
	 emit(ir, OPCODE_SNE, result_dst, result_src, src_reg_for_float(0.0));
d1319 1
a1319 1
   case ir_unop_any:
d1321 21
a1341 3
      emit_dp(ir, result_dst, op[0], op[0],
	      ir->operands[0]->type->vector_elements);
      emit(ir, OPCODE_SNE, result_dst, result_src, src_reg_for_float(0.0));
d1343 1
d1349 20
a1368 4
   case ir_binop_logic_or:
      /* This could be a saturated add and skip the SNE. */
      emit(ir, OPCODE_ADD, result_dst, op[0], op[1]);
      emit(ir, OPCODE_SNE, result_dst, result_src, src_reg_for_float(0.0));
d1370 1
d1397 1
d1400 2
d1406 1
d1414 5
d1433 19
a1451 1

d1462 5
a1466 2
   case ir_unop_bit_not:
   case ir_unop_u2f:
d1472 4
d1477 21
a1497 1
      assert(!"GLSL 1.30 features unsupported");
d1569 1
a1569 2
      case ir_var_in:
      case ir_var_inout:
d1571 3
a1573 5
	  * including deprecated builtins (like gl_Color), user-assign
	  * generic attributes (glBindVertexLocation), and
	  * user-defined varyings.
	  *
	  * FINISHME: We would hit this path for function arguments.  Fix!
a1578 8
         if (this->prog->Target == GL_VERTEX_PROGRAM_ARB &&
             var->location >= VERT_ATTRIB_GENERIC0) {
            _mesa_add_attribute(this->prog->Attributes,
                                var->name,
                                _mesa_sizeof_glsl_type(var->type->gl_type),
                                var->type->gl_type,
                                var->location - VERT_ATTRIB_GENERIC0);
         }
d1580 1
a1580 1
      case ir_var_out:
d1954 1
a1954 1
						values,
d1992 1
a1992 1
						   values,
a1996 42
function_entry *
ir_to_mesa_visitor::get_function_signature(ir_function_signature *sig)
{
   function_entry *entry;

   foreach_iter(exec_list_iterator, iter, this->function_signatures) {
      entry = (function_entry *)iter.get();

      if (entry->sig == sig)
	 return entry;
   }

   entry = ralloc(mem_ctx, function_entry);
   entry->sig = sig;
   entry->sig_id = this->next_signature_id++;
   entry->bgn_inst = NULL;

   /* Allocate storage for all the parameters. */
   foreach_iter(exec_list_iterator, iter, sig->parameters) {
      ir_variable *param = (ir_variable *)iter.get();
      variable_storage *storage;

      storage = find_variable_storage(param);
      assert(!storage);

      storage = new(mem_ctx) variable_storage(param, PROGRAM_TEMPORARY,
					      this->next_temp);
      this->variables.push_tail(storage);

      this->next_temp += type_size(param->type);
   }

   if (!sig->return_type->is_void()) {
      entry->return_reg = get_temp(sig->return_type);
   } else {
      entry->return_reg = undef_src;
   }

   this->function_signatures.push_tail(entry);
   return entry;
}

d2000 1
a2000 75
   ir_to_mesa_instruction *call_inst;
   ir_function_signature *sig = ir->get_callee();
   function_entry *entry = get_function_signature(sig);
   int i;

   /* Process in parameters. */
   exec_list_iterator sig_iter = sig->parameters.iterator();
   foreach_iter(exec_list_iterator, iter, *ir) {
      ir_rvalue *param_rval = (ir_rvalue *)iter.get();
      ir_variable *param = (ir_variable *)sig_iter.get();

      if (param->mode == ir_var_in ||
	  param->mode == ir_var_inout) {
	 variable_storage *storage = find_variable_storage(param);
	 assert(storage);

	 param_rval->accept(this);
	 src_reg r = this->result;

	 dst_reg l;
	 l.file = storage->file;
	 l.index = storage->index;
	 l.reladdr = NULL;
	 l.writemask = WRITEMASK_XYZW;
	 l.cond_mask = COND_TR;

	 for (i = 0; i < type_size(param->type); i++) {
	    emit(ir, OPCODE_MOV, l, r);
	    l.index++;
	    r.index++;
	 }
      }

      sig_iter.next();
   }
   assert(!sig_iter.has_next());

   /* Emit call instruction */
   call_inst = emit(ir, OPCODE_CAL);
   call_inst->function = entry;

   /* Process out parameters. */
   sig_iter = sig->parameters.iterator();
   foreach_iter(exec_list_iterator, iter, *ir) {
      ir_rvalue *param_rval = (ir_rvalue *)iter.get();
      ir_variable *param = (ir_variable *)sig_iter.get();

      if (param->mode == ir_var_out ||
	  param->mode == ir_var_inout) {
	 variable_storage *storage = find_variable_storage(param);
	 assert(storage);

	 src_reg r;
	 r.file = storage->file;
	 r.index = storage->index;
	 r.reladdr = NULL;
	 r.swizzle = SWIZZLE_NOOP;
	 r.negate = 0;

	 param_rval->accept(this);
	 dst_reg l = dst_reg(this->result);

	 for (i = 0; i < type_size(param->type); i++) {
	    emit(ir, OPCODE_MOV, l, r);
	    l.index++;
	    r.index++;
	 }
      }

      sig_iter.next();
   }
   assert(!sig_iter.has_next());

   /* Process return value. */
   this->result = entry->return_reg;
d2011 4
a2014 1
   ir->coordinate->accept(this);
d2038 1
d2046 2
d2060 5
a2064 2
   case ir_txf:
      assert(!"GLSL 1.30 features unsupported");
d2068 2
d2101 3
d2128 9
a2136 1
      coord_dst.writemask = WRITEMASK_Z;
a2159 2
   const glsl_type *sampler_type = ir->sampler->type;

d2181 3
d2194 4
a2197 18
   if (ir->get_value()) {
      dst_reg l;
      int i;

      assert(current_function);

      ir->get_value()->accept(this);
      src_reg r = this->result;

      l = dst_reg(current_function->return_reg);

      for (i = 0; i < type_size(current_function->sig->return_type); i++) {
	 emit(ir, OPCODE_MOV, l, r);
	 l.index++;
	 r.index++;
      }
   }

a2203 2
   struct gl_fragment_program *fp = (struct gl_fragment_program *)this->prog;

a2210 2

   fp->UsesKill = GL_TRUE;
d2403 9
a2411 23

/**
 * Count resources used by the given gpu program (number of texture
 * samplers, etc).
 */
static void
count_resources(struct gl_program *prog)
{
   unsigned int i;

   prog->SamplersUsed = 0;

   for (i = 0; i < prog->NumInstructions; i++) {
      struct prog_instruction *inst = &prog->Instructions[i];

      if (_mesa_is_tex_instruction(inst->Opcode)) {
	 prog->SamplerTargets[inst->TexSrcUnit] =
	    (gl_texture_index)inst->TexSrcTarget;
	 prog->SamplersUsed |= 1 << inst->TexSrcUnit;
	 if (inst->TexShadow) {
	    prog->ShadowSamplers |= 1 << inst->TexSrcUnit;
	 }
      }
d2414 4
a2417 2
   _mesa_update_shader_textures_used(prog);
}
d2419 1
a2419 47

/**
 * Check if the given vertex/fragment/shader program is within the
 * resource limits of the context (number of texture units, etc).
 * If any of those checks fail, record a linker error.
 *
 * XXX more checks are needed...
 */
static void
check_resources(const struct gl_context *ctx,
                struct gl_shader_program *shader_program,
                struct gl_program *prog)
{
   switch (prog->Target) {
   case GL_VERTEX_PROGRAM_ARB:
      if (_mesa_bitcount(prog->SamplersUsed) >
          ctx->Const.MaxVertexTextureImageUnits) {
         linker_error(shader_program,
		      "Too many vertex shader texture samplers");
      }
      if (prog->Parameters->NumParameters > MAX_UNIFORMS) {
         linker_error(shader_program, "Too many vertex shader constants");
      }
      break;
   case MESA_GEOMETRY_PROGRAM:
      if (_mesa_bitcount(prog->SamplersUsed) >
          ctx->Const.MaxGeometryTextureImageUnits) {
         linker_error(shader_program,
		      "Too many geometry shader texture samplers");
      }
      if (prog->Parameters->NumParameters >
          MAX_GEOMETRY_UNIFORM_COMPONENTS / 4) {
         linker_error(shader_program, "Too many geometry shader constants");
      }
      break;
   case GL_FRAGMENT_PROGRAM_ARB:
      if (_mesa_bitcount(prog->SamplersUsed) >
          ctx->Const.MaxTextureImageUnits) {
         linker_error(shader_program,
		      "Too many fragment shader texture samplers");
      }
      if (prog->Parameters->NumParameters > MAX_UNIFORMS) {
         linker_error(shader_program, "Too many fragment shader constants");
      }
      break;
   default:
      _mesa_problem(ctx, "unexpected program type in check_resources()");
a2420 1
}
d2422 3
d2426 4
a2429 4

struct uniform_sort {
   struct gl_uniform *u;
   int pos;
d2432 3
a2434 7
/* The shader_program->Uniforms list is almost sorted in increasing
 * uniform->{Frag,Vert}Pos locations, but not quite when there are
 * uniforms shared between targets.  We need to add parameters in
 * increasing order for the targets.
 */
static int
sort_uniforms(const void *a, const void *b)
d2436 1
a2436 2
   struct uniform_sort *u1 = (struct uniform_sort *)a;
   struct uniform_sort *u2 = (struct uniform_sort *)b;
d2438 1
a2438 2
   return u1->pos - u2->pos;
}
d2440 5
a2444 13
/* Add the uniforms to the parameters.  The linker chose locations
 * in our parameters lists (which weren't created yet), which the
 * uniforms code will use to poke values into our parameters list
 * when uniforms are updated.
 */
static void
add_uniforms_to_parameters_list(struct gl_shader_program *shader_program,
				struct gl_shader *shader,
				struct gl_program *prog)
{
   unsigned int i;
   unsigned int next_sampler = 0, num_uniforms = 0;
   struct uniform_sort *sorted_uniforms;
d2446 6
a2451 25
   sorted_uniforms = ralloc_array(NULL, struct uniform_sort,
				  shader_program->Uniforms->NumUniforms);

   for (i = 0; i < shader_program->Uniforms->NumUniforms; i++) {
      struct gl_uniform *uniform = shader_program->Uniforms->Uniforms + i;
      int parameter_index = -1;

      switch (shader->Type) {
      case GL_VERTEX_SHADER:
	 parameter_index = uniform->VertPos;
	 break;
      case GL_FRAGMENT_SHADER:
	 parameter_index = uniform->FragPos;
	 break;
      case GL_GEOMETRY_SHADER:
	 parameter_index = uniform->GeomPos;
	 break;
      }

      /* Only add uniforms used in our target. */
      if (parameter_index != -1) {
	 sorted_uniforms[num_uniforms].pos = parameter_index;
	 sorted_uniforms[num_uniforms].u = uniform;
	 num_uniforms++;
      }
d2454 4
a2457 2
   qsort(sorted_uniforms, num_uniforms, sizeof(struct uniform_sort),
	 sort_uniforms);
d2459 10
a2468 5
   for (i = 0; i < num_uniforms; i++) {
      struct gl_uniform *uniform = sorted_uniforms[i].u;
      int parameter_index = sorted_uniforms[i].pos;
      const glsl_type *type = uniform->Type;
      unsigned int size;
d2470 2
a2471 14
      if (type->is_vector() ||
	  type->is_scalar()) {
	 size = type->vector_elements;
      } else {
	 size = type_size(type) * 4;
      }

      gl_register_file file;
      if (type->is_sampler() ||
	  (type->is_array() && type->fields.array->is_sampler())) {
	 file = PROGRAM_SAMPLER;
      } else {
	 file = PROGRAM_UNIFORM;
      }
d2473 2
a2474 2
      GLint index = _mesa_lookup_parameter_index(prog->Parameters, -1,
						 uniform->Name);
d2476 1
a2476 4
      if (index < 0) {
	 index = _mesa_add_parameter(prog->Parameters, file,
				     uniform->Name, size, type->gl_type,
				     NULL, NULL, 0x0);
d2478 3
a2480 18
	 /* Sampler uniform values are stored in prog->SamplerUnits,
	  * and the entry in that array is selected by this index we
	  * store in ParameterValues[].
	  */
	 if (file == PROGRAM_SAMPLER) {
	    for (unsigned int j = 0; j < size / 4; j++)
	       prog->Parameters->ParameterValues[index + j][0] = next_sampler++;
	 }

	 /* The location chosen in the Parameters list here (returned
	  * from _mesa_add_uniform) has to match what the linker chose.
	  */
	 if (index != parameter_index) {
	    linker_error(shader_program,
			 "Allocation of uniform `%s' to target failed "
			 "(%d vs %d)\n",
			 uniform->Name, index, parameter_index);
	 }
d2484 5
a2488 1
   ralloc_free(sorted_uniforms);
d2491 17
a2507 21
static void
set_uniform_initializer(struct gl_context *ctx, void *mem_ctx,
			struct gl_shader_program *shader_program,
			const char *name, const glsl_type *type,
			ir_constant *val)
{
   if (type->is_record()) {
      ir_constant *field_constant;

      field_constant = (ir_constant *)val->components.get_head();

      for (unsigned int i = 0; i < type->length; i++) {
	 const glsl_type *field_type = type->fields.structure[i].type;
	 const char *field_name = ralloc_asprintf(mem_ctx, "%s.%s", name,
					    type->fields.structure[i].name);
	 set_uniform_initializer(ctx, mem_ctx, shader_program, field_name,
				 field_type, field_constant);
	 field_constant = (ir_constant *)field_constant->next;
      }
      return;
   }
d2509 2
a2510 1
   int loc = _mesa_get_uniform_location(ctx, shader_program, name);
d2512 3
a2514 5
   if (loc == -1) {
      linker_error(shader_program,
		   "Couldn't find uniform for initializer %s\n", name);
      return;
   }
d2516 1
a2516 37
   for (unsigned int i = 0; i < (type->is_array() ? type->length : 1); i++) {
      ir_constant *element;
      const glsl_type *element_type;
      if (type->is_array()) {
	 element = val->array_elements[i];
	 element_type = type->fields.array;
      } else {
	 element = val;
	 element_type = type;
      }

      void *values;

      if (element_type->base_type == GLSL_TYPE_BOOL) {
	 int *conv = ralloc_array(mem_ctx, int, element_type->components());
	 for (unsigned int j = 0; j < element_type->components(); j++) {
	    conv[j] = element->value.b[j];
	 }
	 values = (void *)conv;
	 element_type = glsl_type::get_instance(GLSL_TYPE_INT,
						element_type->vector_elements,
						1);
      } else {
	 values = &element->value;
      }

      if (element_type->is_matrix()) {
	 _mesa_uniform_matrix(ctx, shader_program,
			      element_type->matrix_columns,
			      element_type->vector_elements,
			      loc, 1, GL_FALSE, (GLfloat *)values);
	 loc += element_type->matrix_columns;
      } else {
	 _mesa_uniform(ctx, shader_program, loc, element_type->matrix_columns,
		       values, element_type->gl_type);
	 loc += type_size(element_type);
      }
d2520 4
a2523 3
static void
set_uniform_initializers(struct gl_context *ctx,
			 struct gl_shader_program *shader_program)
d2525 8
a2532 1
   void *mem_ctx = NULL;
d2534 4
a2537 2
   for (unsigned int i = 0; i < MESA_SHADER_TYPES; i++) {
      struct gl_shader *shader = shader_program->_LinkedShaders[i];
d2539 1
a2539 1
      if (shader == NULL)
d2542 42
a2583 3
      foreach_iter(exec_list_iterator, iter, *shader->ir) {
	 ir_instruction *ir = (ir_instruction *)iter.get();
	 ir_variable *var = ir->as_variable();
d2585 13
a2597 2
	 if (!var || var->mode != ir_var_uniform || !var->constant_value)
	    continue;
d2599 1
a2599 5
	 if (!mem_ctx)
	    mem_ctx = ralloc_context(NULL);

	 set_uniform_initializer(ctx, mem_ctx, shader_program, var->name,
				 var->type, var->constant_value);
a2601 2

   ralloc_free(mem_ctx);
d2779 2
d2813 1
a2813 2
   const char *target_string;
   GLboolean progress;
a2819 1
      target_string = "vertex";
a2822 1
      target_string = "fragment";
a2825 1
      target_string = "geometry";
a2837 2
   prog->Varying = _mesa_new_parameter_list();
   prog->Attributes = _mesa_new_parameter_list();
d2843 2
a2844 1
   add_uniforms_to_parameters_list(shader_program, shader, prog);
a2849 29
   /* Now emit bodies for any functions that were used. */
   do {
      progress = GL_FALSE;

      foreach_iter(exec_list_iterator, iter, v.function_signatures) {
	 function_entry *entry = (function_entry *)iter.get();

	 if (!entry->bgn_inst) {
	    v.current_function = entry;

	    entry->bgn_inst = v.emit(NULL, OPCODE_BGNSUB);
	    entry->bgn_inst->function = entry;

	    visit_exec_list(&entry->sig->body, &v);

	    ir_to_mesa_instruction *last;
	    last = (ir_to_mesa_instruction *)v.instructions.get_tail();
	    if (last->op != OPCODE_RET)
	       v.emit(NULL, OPCODE_RET);

	    ir_to_mesa_instruction *end;
	    end = v.emit(NULL, OPCODE_ENDSUB);
	    end->function = entry;

	    progress = GL_TRUE;
	 }
      }
   } while (progress);

d2900 1
a2900 1
	 if (options->EmitNoIfs) {
a2922 10
      case OPCODE_BGNSUB:
	 inst->function->inst = i;
	 mesa_inst->Comment = strdup(inst->function->sig->function_name());
	 break;
      case OPCODE_ENDSUB:
	 mesa_inst->Comment = strdup(inst->function->sig->function_name());
	 break;
      case OPCODE_CAL:
	 mesa_inst->BranchTarget = inst->function->sig_id; /* rewritten later */
	 break;
d2938 1
a2938 3
      free(mesa_instructions);
      _mesa_reference_program(ctx, &shader->Program, NULL);
      return NULL;
d2959 10
a2968 2
   do_set_program_inouts(shader->ir, prog);
   count_resources(prog);
d2970 5
a2974 1
   check_resources(ctx, shader_program, prog);
d2982 9
d2992 5
d3027 1
a3027 1
				 | LOG_TO_LOG2
d3032 4
a3035 1
	 progress = do_common_optimization(ir, true, options->MaxUnrollIterations) || progress;
d3039 1
a3039 1
	 if (options->EmitNoIfs) {
d3041 2
a3042 2
	    progress = lower_if_to_cond_assign(ir) || progress;
	 }
d3061 1
d3076 4
a3079 1
         bool ok = true;
d3081 5
a3085 21
         switch (prog->_LinkedShaders[i]->Type) {
         case GL_VERTEX_SHADER:
            _mesa_reference_vertprog(ctx, &prog->VertexProgram,
                                     (struct gl_vertex_program *)linked_prog);
            ok = ctx->Driver.ProgramStringNotify(ctx, GL_VERTEX_PROGRAM_ARB,
                                                 linked_prog);
            break;
         case GL_FRAGMENT_SHADER:
            _mesa_reference_fragprog(ctx, &prog->FragmentProgram,
                                     (struct gl_fragment_program *)linked_prog);
            ok = ctx->Driver.ProgramStringNotify(ctx, GL_FRAGMENT_PROGRAM_ARB,
                                                 linked_prog);
            break;
         case GL_GEOMETRY_SHADER:
            _mesa_reference_geomprog(ctx, &prog->GeometryProgram,
                                     (struct gl_geometry_program *)linked_prog);
            ok = ctx->Driver.ProgramStringNotify(ctx, GL_GEOMETRY_PROGRAM_NV,
                                                 linked_prog);
            break;
         }
         if (!ok) {
d3093 1
a3093 1
   return GL_TRUE;
a3095 85

/**
 * Compile a GLSL shader.  Called via glCompileShader().
 */
void
_mesa_glsl_compile_shader(struct gl_context *ctx, struct gl_shader *shader)
{
   struct _mesa_glsl_parse_state *state =
      new(shader) _mesa_glsl_parse_state(ctx, shader->Type, shader);

   const char *source = shader->Source;
   /* Check if the user called glCompileShader without first calling
    * glShaderSource.  This should fail to compile, but not raise a GL_ERROR.
    */
   if (source == NULL) {
      shader->CompileStatus = GL_FALSE;
      return;
   }

   state->error = preprocess(state, &source, &state->info_log,
			     &ctx->Extensions, ctx->API);

   if (ctx->Shader.Flags & GLSL_DUMP) {
      printf("GLSL source for %s shader %d:\n",
	     _mesa_glsl_shader_target_name(state->target), shader->Name);
      printf("%s\n", shader->Source);
   }

   if (!state->error) {
     _mesa_glsl_lexer_ctor(state, source);
     _mesa_glsl_parse(state);
     _mesa_glsl_lexer_dtor(state);
   }

   ralloc_free(shader->ir);
   shader->ir = new(shader) exec_list;
   if (!state->error && !state->translation_unit.is_empty())
      _mesa_ast_to_hir(shader->ir, state);

   if (!state->error && !shader->ir->is_empty()) {
      validate_ir_tree(shader->ir);

      /* Do some optimization at compile time to reduce shader IR size
       * and reduce later work if the same shader is linked multiple times
       */
      while (do_common_optimization(shader->ir, false, 32))
	 ;

      validate_ir_tree(shader->ir);
   }

   shader->symbols = state->symbols;

   shader->CompileStatus = !state->error;
   shader->InfoLog = state->info_log;
   shader->Version = state->language_version;
   memcpy(shader->builtins_to_link, state->builtins_to_link,
	  sizeof(shader->builtins_to_link[0]) * state->num_builtins_to_link);
   shader->num_builtins_to_link = state->num_builtins_to_link;

   if (ctx->Shader.Flags & GLSL_LOG) {
      _mesa_write_shader_to_file(shader);
   }

   if (ctx->Shader.Flags & GLSL_DUMP) {
      if (shader->CompileStatus) {
	 printf("GLSL IR for shader %d:\n", shader->Name);
	 _mesa_print_ir(shader->ir, NULL);
	 printf("\n\n");
      } else {
	 printf("GLSL shader %d failed to compile.\n", shader->Name);
      }
      if (shader->InfoLog && shader->InfoLog[0] != 0) {
	 printf("GLSL shader %d info log:\n", shader->Name);
	 printf("%s\n", shader->InfoLog);
      }
   }

   /* Retain any live IR, but trash the rest. */
   reparent_ir(shader->ir, shader->ir);

   ralloc_free(state);
}


a3114 5
   prog->Varying = _mesa_new_parameter_list();
   _mesa_reference_vertprog(ctx, &prog->VertexProgram, NULL);
   _mesa_reference_fragprog(ctx, &prog->FragmentProgram, NULL);
   _mesa_reference_geomprog(ctx, &prog->GeometryProgram, NULL);

a3123 2

   set_uniform_initializers(ctx, prog);
@


1.1
log
@Initial revision
@
text
@d59 3
d68 3
a70 2
typedef struct ir_to_mesa_src_reg {
   ir_to_mesa_src_reg(int file, int index, const glsl_type *type)
d72 1
a72 1
      this->file = (gl_register_file) file;
d82 1
a82 1
   ir_to_mesa_src_reg()
d91 2
d98 24
a121 2
   ir_to_mesa_src_reg *reladdr;
} ir_to_mesa_src_reg;
d123 1
a123 2
typedef struct ir_to_mesa_dst_reg {
   int file; /**< PROGRAM_* from Mesa */
d128 2
a129 2
   ir_to_mesa_src_reg *reladdr;
} ir_to_mesa_dst_reg;
d131 17
a147 1
extern ir_to_mesa_src_reg ir_to_mesa_undef;
d164 2
a165 2
   ir_to_mesa_dst_reg dst_reg;
   ir_to_mesa_src_reg src_reg[3];
d220 1
a220 1
   ir_to_mesa_src_reg return_reg;
d241 2
a242 3
   ir_to_mesa_src_reg get_temp(const glsl_type *type);
   void reladdr_to_temp(ir_instruction *ir,
			ir_to_mesa_src_reg *reg, int *num_reladdr);
d244 1
a244 1
   struct ir_to_mesa_src_reg src_reg_for_float(float val);
d273 1
a273 1
   struct ir_to_mesa_src_reg result;
d285 7
a291 2
   ir_to_mesa_instruction *ir_to_mesa_emit_op0(ir_instruction *ir,
					       enum prog_opcode op);
d293 3
a295 17
   ir_to_mesa_instruction *ir_to_mesa_emit_op1(ir_instruction *ir,
					       enum prog_opcode op,
					       ir_to_mesa_dst_reg dst,
					       ir_to_mesa_src_reg src0);

   ir_to_mesa_instruction *ir_to_mesa_emit_op2(ir_instruction *ir,
					       enum prog_opcode op,
					       ir_to_mesa_dst_reg dst,
					       ir_to_mesa_src_reg src0,
					       ir_to_mesa_src_reg src1);

   ir_to_mesa_instruction *ir_to_mesa_emit_op3(ir_instruction *ir,
					       enum prog_opcode op,
					       ir_to_mesa_dst_reg dst,
					       ir_to_mesa_src_reg src0,
					       ir_to_mesa_src_reg src1,
					       ir_to_mesa_src_reg src2);
a298 2
    *
    * \sa ir_to_mesa_emit_op2
d300 11
a310 16
   void ir_to_mesa_emit_dp(ir_instruction *ir,
			   ir_to_mesa_dst_reg dst,
			   ir_to_mesa_src_reg src0,
			   ir_to_mesa_src_reg src1,
			   unsigned elements);

   void ir_to_mesa_emit_scalar_op1(ir_instruction *ir,
				   enum prog_opcode op,
				   ir_to_mesa_dst_reg dst,
				   ir_to_mesa_src_reg src0);

   void ir_to_mesa_emit_scalar_op2(ir_instruction *ir,
				   enum prog_opcode op,
				   ir_to_mesa_dst_reg dst,
				   ir_to_mesa_src_reg src0,
				   ir_to_mesa_src_reg src1);
d313 1
a313 2
		 ir_to_mesa_dst_reg dst,
		 const ir_to_mesa_src_reg &src);
d323 2
d328 1
a328 1
ir_to_mesa_src_reg ir_to_mesa_undef = ir_to_mesa_src_reg(PROGRAM_UNDEFINED, 0, NULL);
d330 1
a330 3
ir_to_mesa_dst_reg ir_to_mesa_undef_dst = {
   PROGRAM_UNDEFINED, 0, SWIZZLE_NOOP, COND_TR, NULL,
};
d332 1
a332 17
ir_to_mesa_dst_reg ir_to_mesa_address_reg = {
   PROGRAM_ADDRESS, 0, WRITEMASK_X, COND_TR, NULL
};

static void
fail_link(struct gl_shader_program *prog, const char *fmt, ...) PRINTFLIKE(2, 3);

static void
fail_link(struct gl_shader_program *prog, const char *fmt, ...)
{
   va_list args;
   va_start(args, fmt);
   ralloc_vasprintf_append(&prog->InfoLog, fmt, args);
   va_end(args);

   prog->LinkStatus = GL_FALSE;
}
d349 3
a351 6
ir_to_mesa_visitor::ir_to_mesa_emit_op3(ir_instruction *ir,
					enum prog_opcode op,
					ir_to_mesa_dst_reg dst,
					ir_to_mesa_src_reg src0,
					ir_to_mesa_src_reg src1,
					ir_to_mesa_src_reg src2)
d370 1
a370 3
      ir_to_mesa_emit_op1(ir, OPCODE_ARL, ir_to_mesa_address_reg,
                          *dst.reladdr);

d376 4
a379 4
   inst->dst_reg = dst;
   inst->src_reg[0] = src0;
   inst->src_reg[1] = src1;
   inst->src_reg[2] = src2;
d391 2
a392 5
ir_to_mesa_visitor::ir_to_mesa_emit_op2(ir_instruction *ir,
					enum prog_opcode op,
					ir_to_mesa_dst_reg dst,
					ir_to_mesa_src_reg src0,
					ir_to_mesa_src_reg src1)
d394 1
a394 1
   return ir_to_mesa_emit_op3(ir, op, dst, src0, src1, ir_to_mesa_undef);
d398 2
a399 4
ir_to_mesa_visitor::ir_to_mesa_emit_op1(ir_instruction *ir,
					enum prog_opcode op,
					ir_to_mesa_dst_reg dst,
					ir_to_mesa_src_reg src0)
d402 1
a402 2
   return ir_to_mesa_emit_op3(ir, op, dst,
			      src0, ir_to_mesa_undef, ir_to_mesa_undef);
d406 1
a406 2
ir_to_mesa_visitor::ir_to_mesa_emit_op0(ir_instruction *ir,
					enum prog_opcode op)
d408 1
a408 4
   return ir_to_mesa_emit_op3(ir, op, ir_to_mesa_undef_dst,
			      ir_to_mesa_undef,
			      ir_to_mesa_undef,
			      ir_to_mesa_undef);
d412 3
a414 5
ir_to_mesa_visitor::ir_to_mesa_emit_dp(ir_instruction *ir,
				       ir_to_mesa_dst_reg dst,
				       ir_to_mesa_src_reg src0,
				       ir_to_mesa_src_reg src1,
				       unsigned elements)
d420 1
a420 22
   ir_to_mesa_emit_op3(ir, dot_opcodes[elements - 2],
		       dst, src0, src1, ir_to_mesa_undef);
}

inline ir_to_mesa_dst_reg
ir_to_mesa_dst_reg_from_src(ir_to_mesa_src_reg reg)
{
   ir_to_mesa_dst_reg dst_reg;

   dst_reg.file = reg.file;
   dst_reg.index = reg.index;
   dst_reg.writemask = WRITEMASK_XYZW;
   dst_reg.cond_mask = COND_TR;
   dst_reg.reladdr = reg.reladdr;

   return dst_reg;
}

inline ir_to_mesa_src_reg
ir_to_mesa_src_reg_from_dst(ir_to_mesa_dst_reg reg)
{
   return ir_to_mesa_src_reg(reg.file, reg.index, NULL);
d432 3
a434 5
ir_to_mesa_visitor::ir_to_mesa_emit_scalar_op2(ir_instruction *ir,
					       enum prog_opcode op,
					       ir_to_mesa_dst_reg dst,
					       ir_to_mesa_src_reg orig_src0,
					       ir_to_mesa_src_reg orig_src1)
d446 2
a447 2
      ir_to_mesa_src_reg src0 = orig_src0;
      ir_to_mesa_src_reg src1 = orig_src1;
d470 2
a471 5
      inst = ir_to_mesa_emit_op2(ir, op,
				 dst,
				 src0,
				 src1);
      inst->dst_reg.writemask = this_mask;
d477 2
a478 4
ir_to_mesa_visitor::ir_to_mesa_emit_scalar_op1(ir_instruction *ir,
					       enum prog_opcode op,
					       ir_to_mesa_dst_reg dst,
					       ir_to_mesa_src_reg src0)
d480 1
a480 1
   ir_to_mesa_src_reg undef = ir_to_mesa_undef;
d484 1
a484 1
   ir_to_mesa_emit_scalar_op2(ir, op, dst, src0, undef);
d503 2
a504 2
			     ir_to_mesa_dst_reg dst,
			     const ir_to_mesa_src_reg &src)
d509 1
a509 1
      ir_to_mesa_emit_scalar_op1(ir, op, dst, src);
d516 1
a516 1
   ir_to_mesa_src_reg tmp;
d529 1
a529 1
      ir_to_mesa_src_reg src0 = src;
d557 1
a557 1
	 ir_to_mesa_dst_reg tmp_dst = ir_to_mesa_dst_reg_from_src(tmp);
d561 2
a562 2
	 inst = ir_to_mesa_emit_op1(ir, OPCODE_SCS, tmp_dst, src0);
	 inst->dst_reg.writemask = scs_mask;
d569 2
a570 2
	 inst = ir_to_mesa_emit_op1(ir, OPCODE_SCS, dst, tmp);
	 inst->dst_reg.writemask = this_mask;
d574 2
a575 3
	 ir_to_mesa_instruction *inst =
	    ir_to_mesa_emit_op1(ir, OPCODE_SCS, dst, src0);
	 inst->dst_reg.writemask = scs_mask;
d582 1
a582 1
struct ir_to_mesa_src_reg
d585 1
a585 1
   ir_to_mesa_src_reg src_reg(PROGRAM_CONSTANT, -1, NULL);
d587 2
a588 2
   src_reg.index = _mesa_add_unnamed_constant(this->prog->Parameters,
					      &val, 1, &src_reg.swizzle);
d590 1
a590 1
   return src_reg;
d615 1
d640 1
a640 1
ir_to_mesa_src_reg
d643 1
a643 1
   ir_to_mesa_src_reg src_reg;
d647 3
a649 3
   src_reg.file = PROGRAM_TEMPORARY;
   src_reg.index = next_temp;
   src_reg.reladdr = NULL;
d653 1
a653 1
      src_reg.swizzle = SWIZZLE_NOOP;
d659 2
a660 2
      src_reg.swizzle = MAKE_SWIZZLE4(swizzle[0], swizzle[1],
				      swizzle[2], swizzle[3]);
d662 1
a662 1
   src_reg.negate = 0;
d664 1
a664 1
   return src_reg;
d691 23
d718 2
a719 21
      const struct gl_builtin_uniform_desc *statevar;

      for (i = 0; _mesa_builtin_uniform_desc[i].name; i++) {
	 if (strcmp(ir->name, _mesa_builtin_uniform_desc[i].name) == 0)
	    break;
      }

      if (!_mesa_builtin_uniform_desc[i].name) {
	 fail_link(this->shader_program,
		   "Failed to find builtin uniform `%s'\n", ir->name);
	 return;
      }

      statevar = &_mesa_builtin_uniform_desc[i];

      int array_count;
      if (ir->type->is_array()) {
	 array_count = ir->type->length;
      } else {
	 array_count = 1;
      }
d727 2
a728 2
      for (i = 0; i < statevar->num_elements; i++) {
	 if (statevar->elements[i].swizzle != SWIZZLE_XYZW) {
d734 2
a735 2
      ir_to_mesa_dst_reg dst;
      if (i == statevar->num_elements) {
d740 1
a740 1
	 dst = ir_to_mesa_undef_dst;
d742 6
d753 1
a753 3
	 dst = ir_to_mesa_dst_reg_from_src(ir_to_mesa_src_reg(PROGRAM_TEMPORARY,
							      storage->index,
							      NULL));
d757 3
a759 12
      for (int a = 0; a < array_count; a++) {
	 for (unsigned int i = 0; i < statevar->num_elements; i++) {
	    struct gl_builtin_uniform_element *element = &statevar->elements[i];
	    int tokens[STATE_LENGTH];

	    memcpy(tokens, element->tokens, sizeof(element->tokens));
	    if (ir->type->is_array()) {
	       tokens[1] = a;
	    }

	    int index = _mesa_add_state_reference(this->prog->Parameters,
						  (gl_state_index *)tokens);
d761 3
a763 7
	    if (storage->file == PROGRAM_STATE_VAR) {
	       if (storage->index == -1) {
		  storage->index = index;
	       } else {
		  assert(index ==
                         (int)(storage->index + a * statevar->num_elements + i));
	       }
d765 1
a765 5
	       ir_to_mesa_src_reg src(PROGRAM_STATE_VAR, index, NULL);
	       src.swizzle = element->swizzle;
	       ir_to_mesa_emit_op1(ir, OPCODE_MOV, dst, src);
	       /* even a float takes up a whole vec4 reg in a struct/array. */
	       dst.index++;
d767 6
d775 1
d777 6
a782 5
	  dst.index != storage->index + type_size(ir->type)) {
	 fail_link(this->shader_program,
		   "failed to load builtin uniform `%s'  (%d/%d regs loaded)\n",
		   ir->name, dst.index - storage->index,
		   type_size(ir->type));
d804 1
a804 1
   ir_to_mesa_emit_op0(NULL, OPCODE_BGNLOOP);
d833 1
a833 1
   ir_to_mesa_emit_op0(NULL, OPCODE_ENDLOOP);
d841 1
a841 1
      ir_to_mesa_emit_op0(NULL, OPCODE_BRK);
d844 1
a844 1
      ir_to_mesa_emit_op0(NULL, OPCODE_CONT);
d883 1
a883 1
   ir_to_mesa_src_reg a, b, c;
d897 1
a897 2
   ir_to_mesa_emit_op3(ir, OPCODE_MAD,
		       ir_to_mesa_dst_reg_from_src(this->result), a, b, c);
d916 1
a916 1
   ir_to_mesa_src_reg src = this->result;
d920 1
a920 3
   inst = ir_to_mesa_emit_op1(ir, OPCODE_MOV,
			      ir_to_mesa_dst_reg_from_src(this->result),
			      src);
d928 1
a928 1
				    ir_to_mesa_src_reg *reg, int *num_reladdr)
d933 1
a933 1
   ir_to_mesa_emit_op1(ir, OPCODE_ARL, ir_to_mesa_address_reg, *reg->reladdr);
d936 1
a936 1
      ir_to_mesa_src_reg temp = get_temp(glsl_type::vec4_type);
d938 1
a938 2
      ir_to_mesa_emit_op1(ir, OPCODE_MOV,
			  ir_to_mesa_dst_reg_from_src(temp), *reg);
d1034 1
a1034 1
   ir_to_mesa_src_reg src;
d1049 2
a1050 2
   const ir_to_mesa_src_reg result_src = get_temp(ir->type);
   ir_to_mesa_dst_reg result_dst = ir_to_mesa_dst_reg_from_src(result_src);
d1058 1
a1058 1
   ir_to_mesa_emit_op1(ir, OPCODE_SWZ, result_dst, src);
d1066 3
a1068 3
   struct ir_to_mesa_src_reg op[Elements(ir->operands)];
   struct ir_to_mesa_src_reg result_src;
   struct ir_to_mesa_dst_reg result_dst;
d1116 1
a1116 1
   result_dst = ir_to_mesa_dst_reg_from_src(result_src);
d1125 1
a1125 2
      ir_to_mesa_emit_op2(ir, OPCODE_SEQ, result_dst,
			  op[0], src_reg_for_float(0.0));
d1132 1
a1132 1
      ir_to_mesa_emit_op1(ir, OPCODE_ABS, result_dst, op[0]);
d1135 1
a1135 1
      ir_to_mesa_emit_op1(ir, OPCODE_SSG, result_dst, op[0]);
d1138 1
a1138 1
      ir_to_mesa_emit_scalar_op1(ir, OPCODE_RCP, result_dst, op[0]);
d1142 1
a1142 1
      ir_to_mesa_emit_scalar_op1(ir, OPCODE_EX2, result_dst, op[0]);
d1149 1
a1149 1
      ir_to_mesa_emit_scalar_op1(ir, OPCODE_LG2, result_dst, op[0]);
d1152 1
a1152 1
      ir_to_mesa_emit_scalar_op1(ir, OPCODE_SIN, result_dst, op[0]);
d1155 1
a1155 1
      ir_to_mesa_emit_scalar_op1(ir, OPCODE_COS, result_dst, op[0]);
d1165 1
a1165 1
      ir_to_mesa_emit_op1(ir, OPCODE_DDX, result_dst, op[0]);
d1168 1
a1168 1
      ir_to_mesa_emit_op1(ir, OPCODE_DDY, result_dst, op[0]);
d1177 1
a1177 1
      ir_to_mesa_emit_op1(ir, opcode, result_dst, op[0]);
d1182 1
a1182 1
      ir_to_mesa_emit_op2(ir, OPCODE_ADD, result_dst, op[0], op[1]);
d1185 1
a1185 1
      ir_to_mesa_emit_op2(ir, OPCODE_SUB, result_dst, op[0], op[1]);
d1189 1
a1189 1
      ir_to_mesa_emit_op2(ir, OPCODE_MUL, result_dst, op[0], op[1]);
d1198 1
a1198 1
      ir_to_mesa_emit_op2(ir, OPCODE_SLT, result_dst, op[0], op[1]);
d1201 1
a1201 1
      ir_to_mesa_emit_op2(ir, OPCODE_SGT, result_dst, op[0], op[1]);
d1204 1
a1204 1
      ir_to_mesa_emit_op2(ir, OPCODE_SLE, result_dst, op[0], op[1]);
d1207 1
a1207 1
      ir_to_mesa_emit_op2(ir, OPCODE_SGE, result_dst, op[0], op[1]);
d1210 1
a1210 1
      ir_to_mesa_emit_op2(ir, OPCODE_SEQ, result_dst, op[0], op[1]);
d1213 1
a1213 1
      ir_to_mesa_emit_op2(ir, OPCODE_SNE, result_dst, op[0], op[1]);
d1219 4
a1222 6
	 ir_to_mesa_src_reg temp = get_temp(glsl_type::vec4_type);
	 ir_to_mesa_emit_op2(ir, OPCODE_SNE,
			     ir_to_mesa_dst_reg_from_src(temp), op[0], op[1]);
	 ir_to_mesa_emit_dp(ir, result_dst, temp, temp, vector_elements);
	 ir_to_mesa_emit_op2(ir, OPCODE_SEQ,
			     result_dst, result_src, src_reg_for_float(0.0));
d1224 1
a1224 1
	 ir_to_mesa_emit_op2(ir, OPCODE_SEQ, result_dst, op[0], op[1]);
d1231 4
a1234 6
	 ir_to_mesa_src_reg temp = get_temp(glsl_type::vec4_type);
	 ir_to_mesa_emit_op2(ir, OPCODE_SNE,
			     ir_to_mesa_dst_reg_from_src(temp), op[0], op[1]);
	 ir_to_mesa_emit_dp(ir, result_dst, temp, temp, vector_elements);
	 ir_to_mesa_emit_op2(ir, OPCODE_SNE,
			     result_dst, result_src, src_reg_for_float(0.0));
d1236 1
a1236 1
	 ir_to_mesa_emit_op2(ir, OPCODE_SNE, result_dst, op[0], op[1]);
d1242 3
a1244 4
      ir_to_mesa_emit_dp(ir, result_dst, op[0], op[0],
			 ir->operands[0]->type->vector_elements);
      ir_to_mesa_emit_op2(ir, OPCODE_SNE,
			  result_dst, result_src, src_reg_for_float(0.0));
d1248 1
a1248 1
      ir_to_mesa_emit_op2(ir, OPCODE_SNE, result_dst, op[0], op[1]);
d1253 2
a1254 7
      ir_to_mesa_emit_op2(ir, OPCODE_ADD,
			  result_dst,
			  op[0], op[1]);

      ir_to_mesa_emit_op2(ir, OPCODE_SNE,
			  result_dst,
			  result_src, src_reg_for_float(0.0));
d1259 1
a1259 3
      ir_to_mesa_emit_op2(ir, OPCODE_MUL,
			  result_dst,
			  op[0], op[1]);
d1265 2
a1266 2
      ir_to_mesa_emit_dp(ir, result_dst, op[0], op[1],
			 ir->operands[0]->type->vector_elements);
d1271 2
a1272 2
      ir_to_mesa_emit_scalar_op1(ir, OPCODE_RSQ, result_dst, op[0]);
      ir_to_mesa_emit_op2(ir, OPCODE_MUL, result_dst, result_src, op[0]);
d1275 1
a1275 1
      ir_to_mesa_emit_op3(ir, OPCODE_CMP, result_dst,
d1279 1
a1279 1
      ir_to_mesa_emit_scalar_op1(ir, OPCODE_RSQ, result_dst, op[0]);
d1288 1
a1288 1
      ir_to_mesa_emit_op1(ir, OPCODE_TRUNC, result_dst, op[0]);
d1292 1
a1292 1
      ir_to_mesa_emit_op2(ir, OPCODE_SNE, result_dst,
d1296 1
a1296 1
      ir_to_mesa_emit_op1(ir, OPCODE_TRUNC, result_dst, op[0]);
d1300 1
a1300 1
      ir_to_mesa_emit_op1(ir, OPCODE_FLR, result_dst, op[0]);
d1304 1
a1304 1
      ir_to_mesa_emit_op1(ir, OPCODE_FLR, result_dst, op[0]);
d1307 1
a1307 1
      ir_to_mesa_emit_op1(ir, OPCODE_FRC, result_dst, op[0]);
d1311 1
a1311 1
      ir_to_mesa_emit_op2(ir, OPCODE_MIN, result_dst, op[0], op[1]);
d1314 1
a1314 1
      ir_to_mesa_emit_op2(ir, OPCODE_MAX, result_dst, op[0], op[1]);
d1317 1
a1317 1
      ir_to_mesa_emit_scalar_op2(ir, OPCODE_POW, result_dst, op[0], op[1]);
d1345 1
a1345 1
   ir_to_mesa_src_reg src_reg;
d1355 2
a1356 2
   src_reg = this->result;
   assert(src_reg.file != PROGRAM_UNDEFINED);
d1362 1
a1362 1
	    swizzle[i] = GET_SWZ(src_reg.swizzle, ir->mask.x);
d1365 1
a1365 1
	    swizzle[i] = GET_SWZ(src_reg.swizzle, ir->mask.y);
d1368 1
a1368 1
	    swizzle[i] = GET_SWZ(src_reg.swizzle, ir->mask.z);
d1371 1
a1371 1
	    swizzle[i] = GET_SWZ(src_reg.swizzle, ir->mask.w);
d1382 1
a1382 4
   src_reg.swizzle = MAKE_SWIZZLE4(swizzle[0],
				   swizzle[1],
				   swizzle[2],
				   swizzle[3]);
d1384 1
a1384 1
   this->result = src_reg;
d1391 1
d1394 1
a1394 1
      switch (ir->var->mode) {
d1396 2
a1397 2
	 entry = new(mem_ctx) variable_storage(ir->var, PROGRAM_UNIFORM,
					       ir->var->location);
a1400 1
      case ir_var_out:
d1409 24
a1432 22
	 assert(ir->var->location != -1);
	 if (ir->var->mode == ir_var_in ||
	     ir->var->mode == ir_var_inout) {
	    entry = new(mem_ctx) variable_storage(ir->var,
						  PROGRAM_INPUT,
						  ir->var->location);

	    if (this->prog->Target == GL_VERTEX_PROGRAM_ARB &&
		ir->var->location >= VERT_ATTRIB_GENERIC0) {
	       _mesa_add_attribute(prog->Attributes,
				   ir->var->name,
				   _mesa_sizeof_glsl_type(ir->var->type->gl_type),
				   ir->var->type->gl_type,
				   ir->var->location - VERT_ATTRIB_GENERIC0);
	    }
	 } else {
	    entry = new(mem_ctx) variable_storage(ir->var,
						  PROGRAM_OUTPUT,
						  ir->var->location);
	 }

	 break;
d1435 1
a1435 1
	 entry = new(mem_ctx) variable_storage(ir->var, PROGRAM_TEMPORARY,
d1439 1
a1439 1
	 next_temp += type_size(ir->var->type);
d1444 1
a1444 1
	 printf("Failed to make storage for %s\n", ir->var->name);
d1449 1
a1449 1
   this->result = ir_to_mesa_src_reg(entry->file, entry->index, ir->var->type);
d1456 1
a1456 1
   ir_to_mesa_src_reg src_reg;
d1462 1
a1462 1
   src_reg = this->result;
d1465 1
a1465 1
      src_reg.index += index->value.i[0] * element_size;
a1466 1
      ir_to_mesa_src_reg array_base = this->result;
d1473 1
a1473 1
      ir_to_mesa_src_reg index_reg;
d1480 2
a1481 3
	 ir_to_mesa_emit_op2(ir, OPCODE_MUL,
			     ir_to_mesa_dst_reg_from_src(index_reg),
			     this->result, src_reg_for_float(element_size));
d1484 14
a1497 2
      src_reg.reladdr = ralloc(mem_ctx, ir_to_mesa_src_reg);
      memcpy(src_reg.reladdr, &index_reg, sizeof(index_reg));
d1502 1
a1502 1
      src_reg.swizzle = swizzle_for_size(ir->type->vector_elements);
d1504 1
a1504 1
      src_reg.swizzle = SWIZZLE_NOOP;
d1506 1
a1506 1
   this->result = src_reg;
d1538 1
a1538 1
static struct ir_to_mesa_dst_reg
d1555 1
a1555 1
   return ir_to_mesa_dst_reg_from_src(v->result);
d1648 2
a1649 2
   struct ir_to_mesa_dst_reg l;
   struct ir_to_mesa_src_reg r;
d1705 1
a1705 1
      ir_to_mesa_src_reg condition = this->result;
d1709 1
a1709 2
	    ir_to_mesa_emit_op3(ir, OPCODE_CMP, l,
				condition, ir_to_mesa_src_reg_from_dst(l), r);
d1711 1
a1711 2
	    ir_to_mesa_emit_op3(ir, OPCODE_CMP, l,
				condition, r, ir_to_mesa_src_reg_from_dst(l));
d1719 1
a1719 1
	 ir_to_mesa_emit_op1(ir, OPCODE_MOV, l, r);
d1730 1
a1730 1
   ir_to_mesa_src_reg src_reg;
d1742 2
a1743 2
      ir_to_mesa_src_reg temp_base = get_temp(ir->type);
      ir_to_mesa_dst_reg temp = ir_to_mesa_dst_reg_from_src(temp_base);
d1752 1
a1752 1
	 src_reg = this->result;
d1755 1
a1755 1
	    ir_to_mesa_emit_op1(ir, OPCODE_MOV, temp, src_reg);
d1757 1
a1757 1
	    src_reg.index++;
d1766 2
a1767 2
      ir_to_mesa_src_reg temp_base = get_temp(ir->type);
      ir_to_mesa_dst_reg temp = ir_to_mesa_dst_reg_from_src(temp_base);
d1774 1
a1774 1
	 src_reg = this->result;
d1776 1
a1776 1
	    ir_to_mesa_emit_op1(ir, OPCODE_MOV, temp, src_reg);
d1778 1
a1778 1
	    src_reg.index++;
d1787 2
a1788 2
      ir_to_mesa_src_reg mat = get_temp(ir->type);
      ir_to_mesa_dst_reg mat_column = ir_to_mesa_dst_reg_from_src(mat);
d1794 2
a1795 2
	 src_reg = ir_to_mesa_src_reg(PROGRAM_CONSTANT, -1, NULL);
	 src_reg.index = _mesa_add_unnamed_constant(this->prog->Parameters,
d1798 2
a1799 2
						&src_reg.swizzle);
	 ir_to_mesa_emit_op1(ir, OPCODE_MOV, mat_column, src_reg);
d1808 1
a1808 1
   src_reg.file = PROGRAM_CONSTANT;
d1832 1
a1832 1
   this->result = ir_to_mesa_src_reg(PROGRAM_CONSTANT, -1, ir->type);
d1874 1
a1874 1
      entry->return_reg = ir_to_mesa_undef;
d1901 1
a1901 1
	 ir_to_mesa_src_reg r = this->result;
d1903 1
a1903 1
	 ir_to_mesa_dst_reg l;
d1911 1
a1911 1
	    ir_to_mesa_emit_op1(ir, OPCODE_MOV, l, r);
d1922 1
a1922 2
   call_inst = ir_to_mesa_emit_op1(ir, OPCODE_CAL,
				   ir_to_mesa_undef_dst, ir_to_mesa_undef);
d1936 1
a1936 1
	 ir_to_mesa_src_reg r;
d1944 1
a1944 1
	 ir_to_mesa_dst_reg l = ir_to_mesa_dst_reg_from_src(this->result);
d1947 1
a1947 1
	    ir_to_mesa_emit_op1(ir, OPCODE_MOV, l, r);
d1964 2
a1965 2
   ir_to_mesa_src_reg result_src, coord, lod_info, projector;
   ir_to_mesa_dst_reg result_dst, coord_dst;
d1977 2
a1978 3
   coord_dst = ir_to_mesa_dst_reg_from_src(coord);
   ir_to_mesa_emit_op1(ir, OPCODE_MOV, coord_dst,
		       this->result);
d1989 1
a1989 1
   result_dst = ir_to_mesa_dst_reg_from_src(result_src);
d2006 6
d2021 1
a2021 1
	 ir_to_mesa_emit_op1(ir, OPCODE_MOV, coord_dst, projector);
d2025 1
a2025 1
	 ir_to_mesa_src_reg coord_w = coord;
d2033 1
a2033 1
	 ir_to_mesa_emit_op1(ir, OPCODE_RCP, coord_dst, projector);
d2038 1
a2038 1
	 ir_to_mesa_src_reg tmp_src = coord;
d2046 1
a2046 1
	    ir_to_mesa_dst_reg tmp_dst = ir_to_mesa_dst_reg_from_src(tmp_src);
d2049 1
a2049 1
	    ir_to_mesa_emit_op1(ir, OPCODE_MOV, tmp_dst, this->result);
d2052 1
a2052 1
	    ir_to_mesa_emit_op1(ir, OPCODE_MOV, tmp_dst, coord);
d2056 1
a2056 1
	 ir_to_mesa_emit_op2(ir, OPCODE_MUL, coord_dst, tmp_src, coord_w);
d2073 1
a2073 1
      ir_to_mesa_emit_op1(ir, OPCODE_MOV, coord_dst, this->result);
d2080 1
a2080 1
      ir_to_mesa_emit_op1(ir, OPCODE_MOV, coord_dst, lod_info);
d2084 4
a2087 1
   inst = ir_to_mesa_emit_op1(ir, opcode, result_dst, coord);
d2130 1
a2130 1
      ir_to_mesa_dst_reg l;
d2136 1
a2136 1
      ir_to_mesa_src_reg r = this->result;
d2138 1
a2138 1
      l = ir_to_mesa_dst_reg_from_src(current_function->return_reg);
d2141 1
a2141 1
	 ir_to_mesa_emit_op1(ir, OPCODE_MOV, l, r);
d2147 1
a2147 1
   ir_to_mesa_emit_op0(ir, OPCODE_RET);
d2158 1
a2158 1
      ir_to_mesa_emit_op1(ir, OPCODE_KIL, ir_to_mesa_undef_dst, this->result);
d2160 1
a2160 1
      ir_to_mesa_emit_op0(ir, OPCODE_KIL_NV);
d2169 1
a2169 1
   ir_to_mesa_instruction *cond_inst, *if_inst, *else_inst = NULL;
d2185 2
a2186 4
	 ir_to_mesa_src_reg temp = get_temp(glsl_type::bool_type);
	 cond_inst = ir_to_mesa_emit_op1(ir->condition, OPCODE_MOV,
					 ir_to_mesa_dst_reg_from_src(temp),
					 result);
d2190 2
a2191 2
      if_inst = ir_to_mesa_emit_op0(ir->condition, OPCODE_IF);
      if_inst->dst_reg.cond_mask = COND_NE;
d2193 1
a2193 3
      if_inst = ir_to_mesa_emit_op1(ir->condition,
				    OPCODE_IF, ir_to_mesa_undef_dst,
				    this->result);
d2201 1
a2201 1
      else_inst = ir_to_mesa_emit_op0(ir->condition, OPCODE_ELSE);
d2205 1
a2205 2
   if_inst = ir_to_mesa_emit_op1(ir->condition, OPCODE_ENDIF,
				 ir_to_mesa_undef_dst, ir_to_mesa_undef);
d2223 1
a2223 1
mesa_src_reg_from_ir_src_reg(ir_to_mesa_src_reg reg)
d2356 5
d2384 52
d2541 4
a2544 3
	    fail_link(shader_program, "Allocation of uniform `%s' to target "
		      "failed (%d vs %d)\n",
		      uniform->Name, index, parameter_index);
d2577 2
a2578 2
      fail_link(shader_program,
		"Couldn't find uniform for initializer %s\n", name);
d2652 192
d2899 1
a2899 1
   v.ir_to_mesa_emit_op0(NULL, OPCODE_END);
d2911 1
a2911 1
	    entry->bgn_inst = v.ir_to_mesa_emit_op0(NULL, OPCODE_BGNSUB);
d2919 1
a2919 1
	       v.ir_to_mesa_emit_op0(NULL, OPCODE_RET);
d2922 1
a2922 1
	    end = v.ir_to_mesa_emit_op0(NULL, OPCODE_ENDSUB);
d2943 2
d2956 8
a2963 8
      mesa_inst->DstReg.File = inst->dst_reg.file;
      mesa_inst->DstReg.Index = inst->dst_reg.index;
      mesa_inst->DstReg.CondMask = inst->dst_reg.cond_mask;
      mesa_inst->DstReg.WriteMask = inst->dst_reg.writemask;
      mesa_inst->DstReg.RelAddr = inst->dst_reg.reladdr != NULL;
      mesa_inst->SrcReg[0] = mesa_src_reg_from_ir_src_reg(inst->src_reg[0]);
      mesa_inst->SrcReg[1] = mesa_src_reg_from_ir_src_reg(inst->src_reg[1]);
      mesa_inst->SrcReg[2] = mesa_src_reg_from_ir_src_reg(inst->src_reg[2]);
a2977 4
      if (options->EmitNoIfs && mesa_inst->Opcode == OPCODE_IF) {
	 fail_link(shader_program, "Couldn't flatten if statement\n");
      }

d2979 24
d3054 2
a3067 15
 * Called via ctx->Driver.CompilerShader().
 * This is a no-op.
 * XXX can we remove the ctx->Driver.CompileShader() hook?
 */
GLboolean
_mesa_ir_compile_shader(struct gl_context *ctx, struct gl_shader *shader)
{
   assert(shader->CompileStatus);
   (void) ctx;

   return GL_TRUE;
}


/**
d3194 2
a3195 1
      printf("GLSL source for shader %d:\n", shader->Name);
a3252 5

   if (shader->CompileStatus) {
      if (!ctx->Driver.CompileShader(ctx, shader))
	 shader->CompileStatus = GL_FALSE;
   }
d3270 1
a3270 1
	 fail_link(prog, "linking with uncompiled shader");
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d36 1
a37 1
#include "ir_uniform.h"
a42 1
#include "linker.h"
d44 1
d46 1
d48 1
a49 4

extern "C" {
#include "main/shaderapi.h"
#include "main/uniforms.h"
d54 1
a58 3
class src_reg;
class dst_reg;

d65 2
a66 3
class src_reg {
public:
   src_reg(gl_register_file file, int index, const glsl_type *type)
d68 1
a68 1
      this->file = file;
d78 1
a78 1
   src_reg()
a86 2
   explicit src_reg(dst_reg reg);

d88 1
a88 1
   int index; /**< temporary index, VERT_ATTRIB_*, VARYING_SLOT_*, etc. */
d92 2
a93 2
   src_reg *reladdr;
};
d95 3
a97 24
class dst_reg {
public:
   dst_reg(gl_register_file file, int writemask)
   {
      this->file = file;
      this->index = 0;
      this->writemask = writemask;
      this->cond_mask = COND_TR;
      this->reladdr = NULL;
   }

   dst_reg()
   {
      this->file = PROGRAM_UNDEFINED;
      this->index = 0;
      this->writemask = 0;
      this->cond_mask = COND_TR;
      this->reladdr = NULL;
   }

   explicit dst_reg(src_reg reg);

   gl_register_file file; /**< PROGRAM_* from Mesa */
   int index; /**< temporary index, VERT_ATTRIB_*, VARYING_SLOT_*, etc. */
d101 2
a102 2
   src_reg *reladdr;
};
d104 1
a104 17
src_reg::src_reg(dst_reg reg)
{
   this->file = reg.file;
   this->index = reg.index;
   this->swizzle = SWIZZLE_XYZW;
   this->negate = 0;
   this->reladdr = reg.reladdr;
}

dst_reg::dst_reg(src_reg reg)
{
   this->file = reg.file;
   this->index = reg.index;
   this->writemask = WRITEMASK_XYZW;
   this->cond_mask = COND_TR;
   this->reladdr = reg.reladdr;
}
d121 2
a122 2
   dst_reg dst;
   src_reg src[3];
d130 2
d177 1
a177 1
   src_reg return_reg;
d196 1
a196 2
   src_reg get_temp(const glsl_type *type);
   void reladdr_to_temp(ir_instruction *ir, src_reg *reg, int *num_reladdr);
d198 5
a202 1
   src_reg src_reg_for_float(float val);
d231 1
a231 1
   src_reg result;
d243 2
a244 4
   ir_to_mesa_instruction *emit(ir_instruction *ir, enum prog_opcode op);

   ir_to_mesa_instruction *emit(ir_instruction *ir, enum prog_opcode op,
			        dst_reg dst, src_reg src0);
d246 17
a262 6
   ir_to_mesa_instruction *emit(ir_instruction *ir, enum prog_opcode op,
			        dst_reg dst, src_reg src0, src_reg src1);

   ir_to_mesa_instruction *emit(ir_instruction *ir, enum prog_opcode op,
			        dst_reg dst,
			        src_reg src0, src_reg src1, src_reg src2);
d266 2
d269 16
a284 11
   ir_to_mesa_instruction * emit_dp(ir_instruction *ir,
				    dst_reg dst,
				    src_reg src0,
				    src_reg src1,
				    unsigned elements);

   void emit_scalar(ir_instruction *ir, enum prog_opcode op,
		    dst_reg dst, src_reg src0);

   void emit_scalar(ir_instruction *ir, enum prog_opcode op,
		    dst_reg dst, src_reg src0, src_reg src1);
d287 2
a288 1
		 dst_reg dst, const src_reg &src);
d290 1
a290 1
   bool try_emit_mad(ir_expression *ir,
d292 1
a292 3
   bool try_emit_mad_for_and_not(ir_expression *ir,
				 int mul_operand);
   bool try_emit_sat(ir_expression *ir);
d298 2
a299 1
   void copy_propagate(void);
d301 4
a304 1
   void *mem_ctx;
d307 3
a309 1
static src_reg undef_src = src_reg(PROGRAM_UNDEFINED, 0, NULL);
d311 2
a312 1
static dst_reg undef_dst = dst_reg(PROGRAM_UNDEFINED, SWIZZLE_NOOP);
d314 10
a323 1
static dst_reg address_reg = dst_reg(PROGRAM_ADDRESS, WRITEMASK_X);
d328 1
a328 1
   static const int size_swizzles[4] = {
d340 6
a345 3
ir_to_mesa_visitor::emit(ir_instruction *ir, enum prog_opcode op,
			 dst_reg dst,
			 src_reg src0, src_reg src1, src_reg src2)
d364 3
a366 1
      emit(ir, OPCODE_ARL, address_reg, *dst.reladdr);
d372 4
a375 4
   inst->dst = dst;
   inst->src[0] = src0;
   inst->src[1] = src1;
   inst->src[2] = src2;
d378 2
d387 5
a391 2
ir_to_mesa_visitor::emit(ir_instruction *ir, enum prog_opcode op,
			 dst_reg dst, src_reg src0, src_reg src1)
d393 1
a393 1
   return emit(ir, op, dst, src0, src1, undef_src);
d397 4
a400 2
ir_to_mesa_visitor::emit(ir_instruction *ir, enum prog_opcode op,
			 dst_reg dst, src_reg src0)
d403 2
a404 1
   return emit(ir, op, dst, src0, undef_src, undef_src);
d408 2
a409 1
ir_to_mesa_visitor::emit(ir_instruction *ir, enum prog_opcode op)
d411 4
a414 1
   return emit(ir, op, undef_dst, undef_src, undef_src, undef_src);
d417 6
a422 4
ir_to_mesa_instruction *
ir_to_mesa_visitor::emit_dp(ir_instruction *ir,
			    dst_reg dst, src_reg src0, src_reg src1,
			    unsigned elements)
d428 22
a449 1
   return emit(ir, dot_opcodes[elements - 2], dst, src0, src1);
d461 5
a465 3
ir_to_mesa_visitor::emit_scalar(ir_instruction *ir, enum prog_opcode op,
			        dst_reg dst,
				src_reg orig_src0, src_reg orig_src1)
d477 2
a478 2
      src_reg src0 = orig_src0;
      src_reg src1 = orig_src1;
d501 5
a505 2
      inst = emit(ir, op, dst, src0, src1);
      inst->dst.writemask = this_mask;
d511 4
a514 2
ir_to_mesa_visitor::emit_scalar(ir_instruction *ir, enum prog_opcode op,
			        dst_reg dst, src_reg src0)
d516 1
a516 1
   src_reg undef = undef_src;
d520 1
a520 1
   emit_scalar(ir, op, dst, src0, undef);
d539 2
a540 2
			     dst_reg dst,
			     const src_reg &src)
d545 1
a545 1
      emit_scalar(ir, op, dst, src);
d552 1
a552 1
   src_reg tmp;
d565 1
a565 1
      src_reg src0 = src;
d593 1
a593 1
	 dst_reg tmp_dst = dst_reg(tmp);
d597 2
a598 2
	 inst = emit(ir, OPCODE_SCS, tmp_dst, src0);
	 inst->dst.writemask = scs_mask;
d605 2
a606 2
	 inst = emit(ir, OPCODE_SCS, dst, tmp);
	 inst->dst.writemask = this_mask;
d610 3
a612 2
	 ir_to_mesa_instruction *inst = emit(ir, OPCODE_SCS, dst, src0);
	 inst->dst.writemask = scs_mask;
d619 1
a619 1
src_reg
d622 1
a622 1
   src_reg src(PROGRAM_CONSTANT, -1, NULL);
d624 2
a625 2
   src.index = _mesa_add_unnamed_constant(this->prog->Parameters,
					  (const gl_constant_value *)&val, 1, &src.swizzle);
d627 1
a627 1
   return src;
a651 1
      assert(type->length > 0);
d664 3
a666 5
   case GLSL_TYPE_VOID:
   case GLSL_TYPE_ERROR:
   case GLSL_TYPE_INTERFACE:
      assert(!"Invalid type in type_size");
      break;
a667 2

   return 0;
d676 1
a676 1
src_reg
d679 3
a681 1
   src_reg src;
d683 3
a685 3
   src.file = PROGRAM_TEMPORARY;
   src.index = next_temp;
   src.reladdr = NULL;
d689 1
a689 1
      src.swizzle = SWIZZLE_NOOP;
d691 6
a696 1
      src.swizzle = swizzle_for_size(type->vector_elements);
d698 1
a698 1
   src.negate = 0;
d700 1
a700 1
   return src;
d731 21
a751 2
      const ir_state_slot *const slots = ir->state_slots;
      assert(ir->state_slots != NULL);
d759 2
a760 2
      for (i = 0; i < ir->num_state_slots; i++) {
	 if (slots[i].swizzle != SWIZZLE_XYZW) {
d765 3
a767 3
      variable_storage *storage;
      dst_reg dst;
      if (i == ir->num_state_slots) {
d772 1
a772 1
	 dst = undef_dst;
a773 6
	 /* The variable_storage constructor allocates slots based on the size
	  * of the type.  However, this had better match the number of state
	  * elements that we're going to copy into the new temporary.
	  */
	 assert((int) ir->num_state_slots == type_size(ir->type));

d779 3
a781 1
	 dst = dst_reg(src_reg(PROGRAM_TEMPORARY, storage->index, NULL));
d785 9
a793 3
      for (unsigned int i = 0; i < ir->num_state_slots; i++) {
	 int index = _mesa_add_state_reference(this->prog->Parameters,
					       (gl_state_index *)slots[i].tokens);
d795 10
a804 3
	 if (storage->file == PROGRAM_STATE_VAR) {
	    if (storage->index == -1) {
	       storage->index = index;
d806 5
a810 1
	       assert(index == storage->index + (int)i);
a811 6
	 } else {
	    src_reg src(PROGRAM_STATE_VAR, index, NULL);
	    src.swizzle = slots[i].swizzle;
	    emit(ir, OPCODE_MOV, dst, src);
	    /* even a float takes up a whole vec4 reg in a struct/array. */
	    dst.index++;
a813 1

d815 5
a819 6
	  dst.index != storage->index + (int) ir->num_state_slots) {
	 linker_error(this->shader_program,
		      "failed to load builtin uniform `%s' "
		      "(%d/%d regs loaded)\n",
		      ir->name, dst.index - storage->index,
		      type_size(ir->type));
d841 1
a841 1
   emit(NULL, OPCODE_BGNLOOP);
d870 1
a870 1
   emit(NULL, OPCODE_ENDLOOP);
d878 1
a878 1
      emit(NULL, OPCODE_BRK);
d881 1
a881 1
      emit(NULL, OPCODE_CONT);
d916 1
a916 1
bool
d920 1
a920 1
   src_reg a, b, c;
d934 2
a935 1
   emit(ir, OPCODE_MAD, dst_reg(this->result), a, b, c);
d940 1
a940 41
/**
 * Emit OPCODE_MAD(a, -b, a) instead of AND(a, NOT(b))
 *
 * The logic values are 1.0 for true and 0.0 for false.  Logical-and is
 * implemented using multiplication, and logical-or is implemented using
 * addition.  Logical-not can be implemented as (true - x), or (1.0 - x).
 * As result, the logical expression (a & !b) can be rewritten as:
 *
 *     - a * !b
 *     - a * (1 - b)
 *     - (a * 1) - (a * b)
 *     - a + -(a * b)
 *     - a + (a * -b)
 *
 * This final expression can be implemented as a single MAD(a, -b, a)
 * instruction.
 */
bool
ir_to_mesa_visitor::try_emit_mad_for_and_not(ir_expression *ir, int try_operand)
{
   const int other_operand = 1 - try_operand;
   src_reg a, b;

   ir_expression *expr = ir->operands[try_operand]->as_expression();
   if (!expr || expr->operation != ir_unop_logic_not)
      return false;

   ir->operands[other_operand]->accept(this);
   a = this->result;
   expr->operands[0]->accept(this);
   b = this->result;

   b.negate = ~b.negate;

   this->result = get_temp(ir->type);
   emit(ir, OPCODE_MAD, dst_reg(this->result), a, b, a);

   return true;
}

bool
d954 1
a954 1
   src_reg src = this->result;
d956 6
a961 24
   /* If we generated an expression instruction into a temporary in
    * processing the saturate's operand, apply the saturate to that
    * instruction.  Otherwise, generate a MOV to do the saturate.
    *
    * Note that we have to be careful to only do this optimization if
    * the instruction in question was what generated src->result.  For
    * example, ir_dereference_array might generate a MUL instruction
    * to create the reladdr, and return us a src reg using that
    * reladdr.  That MUL result is not the value we're trying to
    * saturate.
    */
   ir_expression *sat_src_expr = sat_src->as_expression();
   ir_to_mesa_instruction *new_inst;
   new_inst = (ir_to_mesa_instruction *)this->instructions.get_tail();
   if (sat_src_expr && (sat_src_expr->operation == ir_binop_mul ||
			sat_src_expr->operation == ir_binop_add ||
			sat_src_expr->operation == ir_binop_dot)) {
      new_inst->saturate = true;
   } else {
      this->result = get_temp(ir->type);
      ir_to_mesa_instruction *inst;
      inst = emit(ir, OPCODE_MOV, dst_reg(this->result), src);
      inst->saturate = true;
   }
d968 1
a968 1
				    src_reg *reg, int *num_reladdr)
d973 1
a973 1
   emit(ir, OPCODE_ARL, address_reg, *reg->reladdr);
d976 1
a976 1
      src_reg temp = get_temp(glsl_type::vec4_type);
d978 2
a979 1
      emit(ir, OPCODE_MOV, dst_reg(temp), *reg);
d1069 1
d1071 1
a1071 2
      deref->print();
      printf("\n");
d1075 1
a1075 1
   src_reg src;
d1090 2
a1091 2
   const src_reg result_src = get_temp(ir->type);
   dst_reg result_dst = dst_reg(result_src);
d1099 1
a1099 1
   emit(ir, OPCODE_SWZ, result_dst, src);
d1107 3
a1109 3
   src_reg op[Elements(ir->operands)];
   src_reg result_src;
   dst_reg result_dst;
a1118 10

   /* Quick peephole: Emit OPCODE_MAD(-a, -b, a) instead of AND(a, NOT(b))
    */
   if (ir->operation == ir_binop_logic_and) {
      if (try_emit_mad_for_and_not(ir, 1))
	 return;
      if (try_emit_mad_for_and_not(ir, 0))
	 return;
   }

d1131 1
d1133 1
a1133 2
         ir->operands[operand]->print();
         printf("\n");
d1157 1
a1157 1
   result_dst = dst_reg(result_src);
d1166 2
a1167 7
      /* Previously 'SEQ dst, src, 0.0' was used for this.  However, many
       * older GPUs implement SEQ using multiple instructions (i915 uses two
       * SGE instructions and a MUL instruction).  Since our logic values are
       * 0.0 and 1.0, 1-x also implements !x.
       */
      op[0].negate = ~op[0].negate;
      emit(ir, OPCODE_ADD, result_dst, op[0], src_reg_for_float(1.0));
d1174 1
a1174 1
      emit(ir, OPCODE_ABS, result_dst, op[0]);
d1177 1
a1177 1
      emit(ir, OPCODE_SSG, result_dst, op[0]);
d1180 1
a1180 1
      emit_scalar(ir, OPCODE_RCP, result_dst, op[0]);
d1184 1
a1184 1
      emit_scalar(ir, OPCODE_EX2, result_dst, op[0]);
d1191 1
a1191 1
      emit_scalar(ir, OPCODE_LG2, result_dst, op[0]);
d1194 1
a1194 1
      emit_scalar(ir, OPCODE_SIN, result_dst, op[0]);
d1197 1
a1197 1
      emit_scalar(ir, OPCODE_COS, result_dst, op[0]);
d1207 1
a1207 1
      emit(ir, OPCODE_DDX, result_dst, op[0]);
d1210 1
a1210 1
      emit(ir, OPCODE_DDY, result_dst, op[0]);
d1219 1
a1219 1
      emit(ir, opcode, result_dst, op[0]);
d1224 1
a1224 1
      emit(ir, OPCODE_ADD, result_dst, op[0], op[1]);
d1227 1
a1227 1
      emit(ir, OPCODE_SUB, result_dst, op[0], op[1]);
d1231 1
a1231 1
      emit(ir, OPCODE_MUL, result_dst, op[0], op[1]);
a1234 1
      break;
d1236 1
a1236 3
      /* Floating point should be lowered by MOD_TO_FRACT in the compiler. */
      assert(ir->type->is_integer());
      emit(ir, OPCODE_MUL, result_dst, op[0], op[1]);
d1240 1
a1240 1
      emit(ir, OPCODE_SLT, result_dst, op[0], op[1]);
d1243 1
a1243 1
      emit(ir, OPCODE_SGT, result_dst, op[0], op[1]);
d1246 1
a1246 1
      emit(ir, OPCODE_SLE, result_dst, op[0], op[1]);
d1249 1
a1249 1
      emit(ir, OPCODE_SGE, result_dst, op[0], op[1]);
d1252 1
a1252 1
      emit(ir, OPCODE_SEQ, result_dst, op[0], op[1]);
d1255 1
a1255 1
      emit(ir, OPCODE_SNE, result_dst, op[0], op[1]);
d1261 6
a1266 15
	 src_reg temp = get_temp(glsl_type::vec4_type);
	 emit(ir, OPCODE_SNE, dst_reg(temp), op[0], op[1]);

	 /* After the dot-product, the value will be an integer on the
	  * range [0,4].  Zero becomes 1.0, and positive values become zero.
	  */
	 emit_dp(ir, result_dst, temp, temp, vector_elements);

	 /* Negating the result of the dot-product gives values on the range
	  * [-4, 0].  Zero becomes 1.0, and negative values become zero.  This
	  * achieved using SGE.
	  */
	 src_reg sge_src = result_src;
	 sge_src.negate = ~sge_src.negate;
	 emit(ir, OPCODE_SGE, result_dst, sge_src, src_reg_for_float(0.0));
d1268 1
a1268 1
	 emit(ir, OPCODE_SEQ, result_dst, op[0], op[1]);
d1275 6
a1280 22
	 src_reg temp = get_temp(glsl_type::vec4_type);
	 emit(ir, OPCODE_SNE, dst_reg(temp), op[0], op[1]);

	 /* After the dot-product, the value will be an integer on the
	  * range [0,4].  Zero stays zero, and positive values become 1.0.
	  */
	 ir_to_mesa_instruction *const dp =
	    emit_dp(ir, result_dst, temp, temp, vector_elements);
	 if (this->prog->Target == GL_FRAGMENT_PROGRAM_ARB) {
	    /* The clamping to [0,1] can be done for free in the fragment
	     * shader with a saturate.
	     */
	    dp->saturate = true;
	 } else {
	    /* Negating the result of the dot-product gives values on the range
	     * [-4, 0].  Zero stays zero, and negative values become 1.0.  This
	     * achieved using SLT.
	     */
	    src_reg slt_src = result_src;
	    slt_src.negate = ~slt_src.negate;
	    emit(ir, OPCODE_SLT, result_dst, slt_src, src_reg_for_float(0.0));
	 }
d1282 1
a1282 1
	 emit(ir, OPCODE_SNE, result_dst, op[0], op[1]);
d1286 1
a1286 1
   case ir_unop_any: {
d1288 4
a1291 21

      /* After the dot-product, the value will be an integer on the
       * range [0,4].  Zero stays zero, and positive values become 1.0.
       */
      ir_to_mesa_instruction *const dp =
	 emit_dp(ir, result_dst, op[0], op[0],
		 ir->operands[0]->type->vector_elements);
      if (this->prog->Target == GL_FRAGMENT_PROGRAM_ARB) {
	 /* The clamping to [0,1] can be done for free in the fragment
	  * shader with a saturate.
	  */
	 dp->saturate = true;
      } else {
	 /* Negating the result of the dot-product gives values on the range
	  * [-4, 0].  Zero stays zero, and negative values become 1.0.  This
	  * is achieved using SLT.
	  */
	 src_reg slt_src = result_src;
	 slt_src.negate = ~slt_src.negate;
	 emit(ir, OPCODE_SLT, result_dst, slt_src, src_reg_for_float(0.0));
      }
a1292 1
   }
d1295 1
a1295 1
      emit(ir, OPCODE_SNE, result_dst, op[0], op[1]);
d1298 9
a1306 20
   case ir_binop_logic_or: {
      /* After the addition, the value will be an integer on the
       * range [0,2].  Zero stays zero, and positive values become 1.0.
       */
      ir_to_mesa_instruction *add =
	 emit(ir, OPCODE_ADD, result_dst, op[0], op[1]);
      if (this->prog->Target == GL_FRAGMENT_PROGRAM_ARB) {
	 /* The clamping to [0,1] can be done for free in the fragment
	  * shader with a saturate.
	  */
	 add->saturate = true;
      } else {
	 /* Negating the result of the addition gives values on the range
	  * [-2, 0].  Zero stays zero, and negative values become 1.0.  This
	  * is achieved using SLT.
	  */
	 src_reg slt_src = result_src;
	 slt_src.negate = ~slt_src.negate;
	 emit(ir, OPCODE_SLT, result_dst, slt_src, src_reg_for_float(0.0));
      }
a1307 1
   }
d1311 3
a1313 1
      emit(ir, OPCODE_MUL, result_dst, op[0], op[1]);
d1319 2
a1320 2
      emit_dp(ir, result_dst, op[0], op[1],
	      ir->operands[0]->type->vector_elements);
d1325 2
a1326 2
      emit_scalar(ir, OPCODE_RSQ, result_dst, op[0]);
      emit(ir, OPCODE_MUL, result_dst, result_src, op[0]);
d1329 1
a1329 1
      emit(ir, OPCODE_CMP, result_dst,
d1333 1
a1333 1
      emit_scalar(ir, OPCODE_RSQ, result_dst, op[0]);
a1335 1
   case ir_unop_u2f:
a1337 2
   case ir_unop_i2u:
   case ir_unop_u2i:
d1342 1
a1342 2
   case ir_unop_f2u:
      emit(ir, OPCODE_TRUNC, result_dst, op[0]);
d1346 1
a1346 1
      emit(ir, OPCODE_SNE, result_dst,
a1348 5
   case ir_unop_bitcast_f2i: // Ignore these 4, they can't happen here anyway
   case ir_unop_bitcast_f2u:
   case ir_unop_bitcast_i2f:
   case ir_unop_bitcast_u2f:
      break;
d1350 1
a1350 1
      emit(ir, OPCODE_TRUNC, result_dst, op[0]);
d1354 1
a1354 1
      emit(ir, OPCODE_FLR, result_dst, op[0]);
d1358 1
a1358 1
      emit(ir, OPCODE_FLR, result_dst, op[0]);
d1361 1
a1361 20
      emit(ir, OPCODE_FRC, result_dst, op[0]);
      break;
   case ir_unop_pack_snorm_2x16:
   case ir_unop_pack_snorm_4x8:
   case ir_unop_pack_unorm_2x16:
   case ir_unop_pack_unorm_4x8:
   case ir_unop_pack_half_2x16:
   case ir_unop_unpack_snorm_2x16:
   case ir_unop_unpack_snorm_4x8:
   case ir_unop_unpack_unorm_2x16:
   case ir_unop_unpack_unorm_4x8:
   case ir_unop_unpack_half_2x16:
   case ir_unop_unpack_half_2x16_split_x:
   case ir_unop_unpack_half_2x16_split_y:
   case ir_binop_pack_half_2x16_split:
   case ir_unop_bitfield_reverse:
   case ir_unop_bit_count:
   case ir_unop_find_msb:
   case ir_unop_find_lsb:
      assert(!"not supported");
d1363 1
d1365 1
a1365 1
      emit(ir, OPCODE_MIN, result_dst, op[0], op[1]);
d1368 1
a1368 1
      emit(ir, OPCODE_MAX, result_dst, op[0], op[1]);
d1371 1
a1371 1
      emit_scalar(ir, OPCODE_POW, result_dst, op[0], op[1]);
d1374 2
a1375 5
      /* GLSL 1.30 integer ops are unsupported in Mesa IR, but since
       * hardware backends have no way to avoid Mesa IR generation
       * even if they don't use it, we need to emit "something" and
       * continue.
       */
a1380 4
      emit(ir, OPCODE_ADD, result_dst, op[0], op[1]);
      break;

   case ir_unop_bit_not:
d1382 1
a1382 21
      emit(ir, OPCODE_MOV, result_dst, op[0]);
      break;

   case ir_binop_ubo_load:
      assert(!"not supported");
      break;

   case ir_triop_lrp:
      /* ir_triop_lrp operands are (x, y, a) while
       * OPCODE_LRP operands are (a, y, x) to match ARB_fragment_program.
       */
      emit(ir, OPCODE_LRP, result_dst, op[2], op[1], op[0]);
      break;

   case ir_binop_vector_extract:
   case ir_binop_bfm:
   case ir_triop_bfi:
   case ir_triop_bitfield_extract:
   case ir_triop_vector_insert:
   case ir_quadop_bitfield_insert:
      assert(!"not supported");
d1399 1
a1399 1
   src_reg src;
d1409 2
a1410 2
   src = this->result;
   assert(src.file != PROGRAM_UNDEFINED);
d1416 1
a1416 1
	    swizzle[i] = GET_SWZ(src.swizzle, ir->mask.x);
d1419 1
a1419 1
	    swizzle[i] = GET_SWZ(src.swizzle, ir->mask.y);
d1422 1
a1422 1
	    swizzle[i] = GET_SWZ(src.swizzle, ir->mask.z);
d1425 1
a1425 1
	    swizzle[i] = GET_SWZ(src.swizzle, ir->mask.w);
d1436 4
a1439 1
   src.swizzle = MAKE_SWIZZLE4(swizzle[0], swizzle[1], swizzle[2], swizzle[3]);
d1441 1
a1441 1
   this->result = src;
a1447 1
   ir_variable *var = ir->var;
d1450 1
a1450 1
      switch (var->mode) {
d1452 2
a1453 2
	 entry = new(mem_ctx) variable_storage(var, PROGRAM_UNIFORM,
					       var->location);
d1456 3
a1458 1
      case ir_var_shader_in:
d1460 28
a1487 20
	  * including deprecated builtins (like gl_Color),
	  * user-assigned generic attributes (glBindVertexLocation),
	  * and user-defined varyings.
	  */
	 assert(var->location != -1);
         entry = new(mem_ctx) variable_storage(var,
                                               PROGRAM_INPUT,
                                               var->location);
         break;
      case ir_var_shader_out:
	 assert(var->location != -1);
         entry = new(mem_ctx) variable_storage(var,
                                               PROGRAM_OUTPUT,
                                               var->location);
	 break;
      case ir_var_system_value:
         entry = new(mem_ctx) variable_storage(var,
                                               PROGRAM_SYSTEM_VALUE,
                                               var->location);
         break;
d1490 1
a1490 1
	 entry = new(mem_ctx) variable_storage(var, PROGRAM_TEMPORARY,
d1494 1
a1494 1
	 next_temp += type_size(var->type);
d1499 1
a1499 1
	 printf("Failed to make storage for %s\n", var->name);
d1504 1
a1504 1
   this->result = src_reg(entry->file, entry->index, var->type);
d1511 1
a1511 1
   src_reg src;
d1517 1
a1517 1
   src = this->result;
d1520 1
a1520 1
      src.index += index->value.i[0] * element_size;
d1522 1
d1529 1
a1529 1
      src_reg index_reg;
d1536 3
a1538 2
	 emit(ir, OPCODE_MUL, dst_reg(index_reg),
	      this->result, src_reg_for_float(element_size));
d1541 2
a1542 14
      /* If there was already a relative address register involved, add the
       * new and the old together to get the new offset.
       */
      if (src.reladdr != NULL)  {
	 src_reg accum_reg = get_temp(glsl_type::float_type);

	 emit(ir, OPCODE_ADD, dst_reg(accum_reg),
	      index_reg, *src.reladdr);

	 index_reg = accum_reg;
      }

      src.reladdr = ralloc(mem_ctx, src_reg);
      memcpy(src.reladdr, &index_reg, sizeof(index_reg));
d1547 1
a1547 1
      src.swizzle = swizzle_for_size(ir->type->vector_elements);
d1549 1
a1549 1
      src.swizzle = SWIZZLE_NOOP;
d1551 1
a1551 1
   this->result = src;
d1583 1
a1583 1
static dst_reg
d1600 1
a1600 1
   return dst_reg(v->result);
d1693 2
a1694 2
   dst_reg l;
   src_reg r;
d1750 1
a1750 1
      src_reg condition = this->result;
d1754 2
a1755 1
	    emit(ir, OPCODE_CMP, l, condition, src_reg(l), r);
d1757 2
a1758 1
	    emit(ir, OPCODE_CMP, l, condition, r, src_reg(l));
d1766 1
a1766 1
	 emit(ir, OPCODE_MOV, l, r);
d1777 1
a1777 1
   src_reg src;
d1789 2
a1790 2
      src_reg temp_base = get_temp(ir->type);
      dst_reg temp = dst_reg(temp_base);
d1799 1
a1799 1
	 src = this->result;
d1802 1
a1802 1
	    emit(ir, OPCODE_MOV, temp, src);
d1804 1
a1804 1
	    src.index++;
d1813 2
a1814 2
      src_reg temp_base = get_temp(ir->type);
      dst_reg temp = dst_reg(temp_base);
d1821 1
a1821 1
	 src = this->result;
d1823 1
a1823 1
	    emit(ir, OPCODE_MOV, temp, src);
d1825 1
a1825 1
	    src.index++;
d1834 2
a1835 2
      src_reg mat = get_temp(ir->type);
      dst_reg mat_column = dst_reg(mat);
d1841 3
a1843 3
	 src = src_reg(PROGRAM_CONSTANT, -1, NULL);
	 src.index = _mesa_add_unnamed_constant(this->prog->Parameters,
						(gl_constant_value *) values,
d1845 2
a1846 2
						&src.swizzle);
	 emit(ir, OPCODE_MOV, mat_column, src);
d1855 1
a1855 1
   src.file = PROGRAM_CONSTANT;
d1879 1
a1879 1
   this->result = src_reg(PROGRAM_CONSTANT, -1, ir->type);
d1881 1
a1881 1
						   (gl_constant_value *) values,
d1886 42
d1931 76
a2006 1
   assert(!"ir_to_mesa: All function calls should have been inlined by now.");
d2012 2
a2013 2
   src_reg result_src, coord, lod_info, projector, dx, dy;
   dst_reg result_dst, coord_dst;
d2017 1
a2017 4
   if (ir->op == ir_txs)
      this->result = src_reg_for_float(0.0);
   else
      ir->coordinate->accept(this);
d2025 3
a2027 2
   coord_dst = dst_reg(coord);
   emit(ir, OPCODE_MOV, coord_dst, this->result);
d2038 1
a2038 1
   result_dst = dst_reg(result_src);
a2041 1
   case ir_txs:
a2048 2
   case ir_txf:
      /* Pretend to be TXL so the sampler, coordinate, lod are available */
d2055 2
a2056 11
      opcode = OPCODE_TXD;
      ir->lod_info.grad.dPdx->accept(this);
      dx = this->result;
      ir->lod_info.grad.dPdy->accept(this);
      dy = this->result;
      break;
   case ir_txf_ms:
      assert(!"Unexpected ir_txf_ms opcode");
      break;
   case ir_lod:
      assert(!"Unexpected ir_lod opcode");
a2059 2
   const glsl_type *sampler_type = ir->sampler->type;

d2064 1
a2064 1
	 emit(ir, OPCODE_MOV, coord_dst, projector);
d2068 1
a2068 1
	 src_reg coord_w = coord;
d2076 1
a2076 1
	 emit(ir, OPCODE_RCP, coord_dst, projector);
d2081 1
a2081 1
	 src_reg tmp_src = coord;
d2089 1
a2089 4
	    dst_reg tmp_dst = dst_reg(tmp_src);

	    /* Projective division not allowed for array samplers. */
	    assert(!sampler_type->sampler_array);
d2092 1
a2092 1
	    emit(ir, OPCODE_MOV, tmp_dst, this->result);
d2095 1
a2095 1
	    emit(ir, OPCODE_MOV, tmp_dst, coord);
d2099 1
a2099 1
	 emit(ir, OPCODE_MUL, coord_dst, tmp_src, coord_w);
d2115 2
a2116 10

      /* XXX This will need to be updated for cubemap array samplers. */
      if (sampler_type->sampler_dimensionality == GLSL_SAMPLER_DIM_2D &&
          sampler_type->sampler_array) {
         coord_dst.writemask = WRITEMASK_W;
      } else {
         coord_dst.writemask = WRITEMASK_Z;
      }

      emit(ir, OPCODE_MOV, coord_dst, this->result);
d2123 1
a2123 1
      emit(ir, OPCODE_MOV, coord_dst, lod_info);
d2127 1
a2127 4
   if (opcode == OPCODE_TXD)
      inst = emit(ir, opcode, result_dst, coord, dx, dy);
   else
      inst = emit(ir, opcode, result_dst, coord);
d2136 2
a2158 3
   case GLSL_SAMPLER_DIM_EXTERNAL:
      inst->tex_target = TEXTURE_EXTERNAL_INDEX;
      break;
d2169 19
a2187 5
   /* Non-void functions should have been inlined.  We may still emit RETs
    * from main() unless the EmitNoMainReturn option is set.
    */
   assert(!ir->get_value());
   emit(ir, OPCODE_RET);
d2193 2
d2198 1
a2198 1
      emit(ir, OPCODE_KIL, undef_dst, this->result);
d2200 1
a2200 1
      emit(ir, OPCODE_KIL_NV);
d2202 2
d2209 1
a2209 1
   ir_to_mesa_instruction *cond_inst, *if_inst;
d2225 4
a2228 2
	 src_reg temp = get_temp(glsl_type::bool_type);
	 cond_inst = emit(ir->condition, OPCODE_MOV, dst_reg(temp), result);
d2232 2
a2233 2
      if_inst = emit(ir->condition, OPCODE_IF);
      if_inst->dst.cond_mask = COND_NE;
d2235 3
a2237 1
      if_inst = emit(ir->condition, OPCODE_IF, undef_dst, this->result);
d2245 1
a2245 1
      emit(ir->condition, OPCODE_ELSE);
d2249 2
a2250 1
   if_inst = emit(ir->condition, OPCODE_ENDIF);
d2268 1
a2268 1
mesa_src_reg_from_ir_src_reg(src_reg reg)
d2401 6
a2406 10
class add_uniform_to_shader : public program_resource_visitor {
public:
   add_uniform_to_shader(struct gl_shader_program *shader_program,
			 struct gl_program_parameter_list *params,
                         gl_shader_type shader_type)
      : shader_program(shader_program), params(params), idx(-1),
        shader_type(shader_type)
   {
      /* empty */
   }
d2408 2
a2409 4
   void process(ir_variable *var)
   {
      this->idx = -1;
      this->program_resource_visitor::process(var);
d2411 8
a2418 1
      var->location = this->idx;
d2421 2
a2422 3
private:
   virtual void visit_field(const glsl_type *type, const char *name,
                            bool row_major);
d2424 3
a2426 4
   struct gl_shader_program *shader_program;
   struct gl_program_parameter_list *params;
   int idx;
   gl_shader_type shader_type;
d2429 7
a2435 3
void
add_uniform_to_shader::visit_field(const glsl_type *type, const char *name,
                                   bool row_major)
d2437 2
a2438 1
   unsigned int size;
d2440 2
a2441 1
   (void) row_major;
d2443 13
a2455 5
   if (type->is_vector() || type->is_scalar()) {
      size = type->vector_elements;
   } else {
      size = type_size(type) * 4;
   }
d2457 2
a2458 7
   gl_register_file file;
   if (type->is_sampler() ||
       (type->is_array() && type->fields.array->is_sampler())) {
      file = PROGRAM_SAMPLER;
   } else {
      file = PROGRAM_UNIFORM;
   }
d2460 3
a2462 4
   int index = _mesa_lookup_parameter_index(params, -1, name);
   if (index < 0) {
      index = _mesa_add_parameter(params, file, name, size, type->gl_type,
				  NULL, NULL);
d2464 11
a2474 10
      /* Sampler uniform values are stored in prog->SamplerUnits,
       * and the entry in that array is selected by this index we
       * store in ParameterValues[].
       */
      if (file == PROGRAM_SAMPLER) {
	 unsigned location;
	 const bool found =
	    this->shader_program->UniformHash->get(location,
						   params->Parameters[index].Name);
	 assert(found);
d2476 5
a2480 11
	 if (!found)
	    return;

	 struct gl_uniform_storage *storage =
	    &this->shader_program->UniformStorage[location];

         assert(storage->sampler[shader_type].active);

	 for (unsigned int j = 0; j < size / 4; j++)
            params->ParameterValues[index + j][0].f =
               storage->sampler[shader_type].index + j;
d2484 2
a2485 6
   /* The first part of the uniform that's processed determines the base
    * location of the whole uniform (for structures).
    */
   if (this->idx < 0)
      this->idx = index;
}
d2487 5
a2491 17
/**
 * Generate the program parameters list for the user uniforms in a shader
 *
 * \param shader_program Linked shader program.  This is only used to
 *                       emit possible link errors to the info log.
 * \param sh             Shader whose uniforms are to be processed.
 * \param params         Parameter list to be filled in.
 */
void
_mesa_generate_parameters_list_for_uniforms(struct gl_shader_program
					    *shader_program,
					    struct gl_shader *sh,
					    struct gl_program_parameter_list
					    *params)
{
   add_uniform_to_shader add(shader_program, params,
                             _mesa_shader_type_to_index(sh->Type));
d2493 6
a2498 2
   foreach_list(node, sh->ir) {
      ir_variable *var = ((ir_instruction *) node)->as_variable();
d2500 7
a2506 3
      if ((var == NULL) || (var->mode != ir_var_uniform)
	  || var->is_in_uniform_block() || (strncmp(var->name, "gl_", 3) == 0))
	 continue;
d2508 2
a2509 3
      add.process(var);
   }
}
d2511 4
a2514 13
void
_mesa_associate_uniform_storage(struct gl_context *ctx,
				struct gl_shader_program *shader_program,
				struct gl_program_parameter_list *params)
{
   /* After adding each uniform to the parameter list, connect the storage for
    * the parameter with the tracking structure used by the API for the
    * uniform.
    */
   unsigned last_location = unsigned(~0);
   for (unsigned i = 0; i < params->NumParameters; i++) {
      if (params->Parameters[i].Type != PROGRAM_UNIFORM)
	 continue;
d2516 7
a2522 49
      unsigned location;
      const bool found =
	 shader_program->UniformHash->get(location, params->Parameters[i].Name);
      assert(found);

      if (!found)
	 continue;

      if (location != last_location) {
	 struct gl_uniform_storage *storage =
	    &shader_program->UniformStorage[location];
	 enum gl_uniform_driver_format format = uniform_native;

	 unsigned columns = 0;
	 switch (storage->type->base_type) {
	 case GLSL_TYPE_UINT:
	    assert(ctx->Const.NativeIntegers);
	    format = uniform_native;
	    columns = 1;
	    break;
	 case GLSL_TYPE_INT:
	    format =
	       (ctx->Const.NativeIntegers) ? uniform_native : uniform_int_float;
	    columns = 1;
	    break;
	 case GLSL_TYPE_FLOAT:
	    format = uniform_native;
	    columns = storage->type->matrix_columns;
	    break;
	 case GLSL_TYPE_BOOL:
	    if (ctx->Const.NativeIntegers) {
	       format = (ctx->Const.UniformBooleanTrue == 1)
		  ? uniform_bool_int_0_1 : uniform_bool_int_0_not0;
	    } else {
	       format = uniform_bool_float;
	    }
	    columns = 1;
	    break;
	 case GLSL_TYPE_SAMPLER:
	    format = uniform_native;
	    columns = 1;
	    break;
         case GLSL_TYPE_ARRAY:
         case GLSL_TYPE_VOID:
         case GLSL_TYPE_STRUCT:
         case GLSL_TYPE_ERROR:
         case GLSL_TYPE_INTERFACE:
	    assert(!"Should not get here.");
	    break;
d2525 2
a2526 9
	 _mesa_uniform_attach_driver_storage(storage,
					     4 * sizeof(float) * columns,
					     4 * sizeof(float),
					     format,
					     &params->ParameterValues[i]);

	 /* After attaching the driver's storage to the uniform, propagate any
	  * data from the linker's backing store.  This will cause values from
	  * initializers in the source code to be copied over.
d2528 5
a2532 5
	 _mesa_propagate_uniforms_to_driver_storage(storage,
						    0,
						    MAX2(1, storage->array_elements));

	 last_location = location;
d2535 2
d2539 21
a2559 40
/*
 * On a basic block basis, tracks available PROGRAM_TEMPORARY register
 * channels for copy propagation and updates following instructions to
 * use the original versions.
 *
 * The ir_to_mesa_visitor lazily produces code assuming that this pass
 * will occur.  As an example, a TXP production before this pass:
 *
 * 0: MOV TEMP[1], INPUT[4].xyyy;
 * 1: MOV TEMP[1].w, INPUT[4].wwww;
 * 2: TXP TEMP[2], TEMP[1], texture[0], 2D;
 *
 * and after:
 *
 * 0: MOV TEMP[1], INPUT[4].xyyy;
 * 1: MOV TEMP[1].w, INPUT[4].wwww;
 * 2: TXP TEMP[2], INPUT[4].xyyw, texture[0], 2D;
 *
 * which allows for dead code elimination on TEMP[1]'s writes.
 */
void
ir_to_mesa_visitor::copy_propagate(void)
{
   ir_to_mesa_instruction **acp = rzalloc_array(mem_ctx,
						    ir_to_mesa_instruction *,
						    this->next_temp * 4);
   int *acp_level = rzalloc_array(mem_ctx, int, this->next_temp * 4);
   int level = 0;

   foreach_iter(exec_list_iterator, iter, this->instructions) {
      ir_to_mesa_instruction *inst = (ir_to_mesa_instruction *)iter.get();

      assert(inst->dst.file != PROGRAM_TEMPORARY
	     || inst->dst.index < this->next_temp);

      /* First, do any copy propagation possible into the src regs. */
      for (int r = 0; r < 3; r++) {
	 ir_to_mesa_instruction *first = NULL;
	 bool good = true;
	 int acp_base = inst->src[r].index * 4;
d2561 1
a2561 3
	 if (inst->src[r].file != PROGRAM_TEMPORARY ||
	     inst->src[r].reladdr)
	    continue;
d2563 5
a2567 7
	 /* See if we can find entries in the ACP consisting of MOVs
	  * from the same src register for all the swizzled channels
	  * of this src register reference.
	  */
	 for (int i = 0; i < 4; i++) {
	    int src_chan = GET_SWZ(inst->src[r].swizzle, i);
	    ir_to_mesa_instruction *copy_chan = acp[acp_base + src_chan];
d2569 10
a2578 4
	    if (!copy_chan) {
	       good = false;
	       break;
	    }
d2580 1
a2580 1
	    assert(acp_level[acp_base + src_chan] <= level);
d2582 4
a2585 9
	    if (!first) {
	       first = copy_chan;
	    } else {
	       if (first->src[0].file != copy_chan->src[0].file ||
		   first->src[0].index != copy_chan->src[0].index) {
		  good = false;
		  break;
	       }
	    }
d2587 7
d2595 10
a2604 16
	 if (good) {
	    /* We've now validated that we can copy-propagate to
	     * replace this src register reference.  Do it.
	     */
	    inst->src[r].file = first->src[0].file;
	    inst->src[r].index = first->src[0].index;

	    int swizzle = 0;
	    for (int i = 0; i < 4; i++) {
	       int src_chan = GET_SWZ(inst->src[r].swizzle, i);
	       ir_to_mesa_instruction *copy_inst = acp[acp_base + src_chan];
	       swizzle |= (GET_SWZ(copy_inst->src[0].swizzle, src_chan) <<
			   (3 * i));
	    }
	    inst->src[r].swizzle = swizzle;
	 }
d2606 2
d2609 5
a2613 6
      switch (inst->op) {
      case OPCODE_BGNLOOP:
      case OPCODE_ENDLOOP:
	 /* End of a basic block, clear the ACP entirely. */
	 memset(acp, 0, sizeof(*acp) * this->next_temp * 4);
	 break;
d2615 2
a2616 3
      case OPCODE_IF:
	 ++level;
	 break;
d2618 2
a2619 9
      case OPCODE_ENDIF:
      case OPCODE_ELSE:
	 /* Clear all channels written inside the block from the ACP, but
	  * leaving those that were not touched.
	  */
	 for (int r = 0; r < this->next_temp; r++) {
	    for (int c = 0; c < 4; c++) {
	       if (!acp[4 * r + c])
		  continue;
d2621 3
a2623 7
	       if (acp_level[4 * r + c] >= level)
		  acp[4 * r + c] = NULL;
	    }
	 }
	 if (inst->op == OPCODE_ENDIF)
	    --level;
	 break;
d2625 2
a2626 33
      default:
	 /* Continuing the block, clear any written channels from
	  * the ACP.
	  */
	 if (inst->dst.file == PROGRAM_TEMPORARY && inst->dst.reladdr) {
	    /* Any temporary might be written, so no copy propagation
	     * across this instruction.
	     */
	    memset(acp, 0, sizeof(*acp) * this->next_temp * 4);
	 } else if (inst->dst.file == PROGRAM_OUTPUT &&
		    inst->dst.reladdr) {
	    /* Any output might be written, so no copy propagation
	     * from outputs across this instruction.
	     */
	    for (int r = 0; r < this->next_temp; r++) {
	       for (int c = 0; c < 4; c++) {
		  if (!acp[4 * r + c])
		     continue;

		  if (acp[4 * r + c]->src[0].file == PROGRAM_OUTPUT)
		     acp[4 * r + c] = NULL;
	       }
	    }
	 } else if (inst->dst.file == PROGRAM_TEMPORARY ||
		    inst->dst.file == PROGRAM_OUTPUT) {
	    /* Clear where it's used as dst. */
	    if (inst->dst.file == PROGRAM_TEMPORARY) {
	       for (int c = 0; c < 4; c++) {
		  if (inst->dst.writemask & (1 << c)) {
		     acp[4 * inst->dst.index + c] = NULL;
		  }
	       }
	    }
d2628 2
a2629 19
	    /* Clear where it's used as src. */
	    for (int r = 0; r < this->next_temp; r++) {
	       for (int c = 0; c < 4; c++) {
		  if (!acp[4 * r + c])
		     continue;

		  int src_chan = GET_SWZ(acp[4 * r + c]->src[0].swizzle, c);

		  if (acp[4 * r + c]->src[0].file == inst->dst.file &&
		      acp[4 * r + c]->src[0].index == inst->dst.index &&
		      inst->dst.writemask & (1 << src_chan))
		  {
		     acp[4 * r + c] = NULL;
		  }
	       }
	    }
	 }
	 break;
      }
d2631 2
a2632 15
      /* If this is a copy, add it to the ACP. */
      if (inst->op == OPCODE_MOV &&
	  inst->dst.file == PROGRAM_TEMPORARY &&
	  !(inst->dst.file == inst->src[0].file &&
	    inst->dst.index == inst->src[0].index) &&
	  !inst->dst.reladdr &&
	  !inst->saturate &&
	  !inst->src[0].reladdr &&
	  !inst->src[0].negate) {
	 for (int i = 0; i < 4; i++) {
	    if (inst->dst.writemask & (1 << i)) {
	       acp[4 * inst->dst.index + i] = inst;
	       acp_level[4 * inst->dst.index + i] = level;
	    }
	 }
d2636 1
a2636 2
   ralloc_free(acp_level);
   ralloc_free(acp);
d2654 2
a2655 1
   const char *target_string = _mesa_glsl_shader_target_name(shader->Type);
d2662 1
d2666 1
d2670 1
d2683 2
d2690 1
a2690 2
   _mesa_generate_parameters_list_for_uniforms(shader_program, shader,
					       prog->Parameters);
d2694 30
a2723 1
   v.emit(NULL, OPCODE_END);
a2737 2
   v.copy_propagate();

d2749 8
a2756 8
      mesa_inst->DstReg.File = inst->dst.file;
      mesa_inst->DstReg.Index = inst->dst.index;
      mesa_inst->DstReg.CondMask = inst->dst.cond_mask;
      mesa_inst->DstReg.WriteMask = inst->dst.writemask;
      mesa_inst->DstReg.RelAddr = inst->dst.reladdr != NULL;
      mesa_inst->SrcReg[0] = mesa_src_reg_from_ir_src_reg(inst->src[0]);
      mesa_inst->SrcReg[1] = mesa_src_reg_from_ir_src_reg(inst->src[1]);
      mesa_inst->SrcReg[2] = mesa_src_reg_from_ir_src_reg(inst->src[2]);
d2771 4
d2776 3
a2778 7
      case OPCODE_IF:
	 if (options->MaxIfDepth == 0) {
	    linker_warning(shader_program,
			   "Couldn't flatten if-statement.  "
			   "This will likely result in software "
			   "rasterization.\n");
	 }
d2780 2
a2781 7
      case OPCODE_BGNLOOP:
	 if (options->EmitNoLoops) {
	    linker_warning(shader_program,
			   "Couldn't unroll loop.  "
			   "This will likely result in software "
			   "rasterization.\n");
	 }
d2783 2
a2784 7
      case OPCODE_CONT:
	 if (options->EmitNoCont) {
	    linker_warning(shader_program,
			   "Couldn't lower continue-statement.  "
			   "This will likely result in software "
			   "rasterization.\n");
	 }
d2801 3
a2803 1
      goto fail_exit;
d2824 2
a2825 16
   /* Setting this to NULL prevents a possible double free in the fail_exit
    * path (far below).
    */
   mesa_instructions = NULL;

   do_set_program_inouts(shader->ir, prog, shader->Type == GL_FRAGMENT_SHADER);

   prog->SamplersUsed = shader->active_samplers;
   prog->ShadowSamplers = shader->shadow_samplers;
   _mesa_update_shader_textures_used(shader_program, prog);

   /* Set the gl_FragDepth layout. */
   if (target == GL_FRAGMENT_PROGRAM_ARB) {
      struct gl_fragment_program *fp = (struct gl_fragment_program *)prog;
      fp->FragDepthLayout = shader_program->FragDepthLayout;
   }
d2833 4
a2836 8
   /* This has to be done last.  Any operation that can cause
    * prog->ParameterValues to get reallocated (e.g., anything that adds a
    * program constant) has to happen before creating this linkage.
    */
   _mesa_associate_uniform_storage(ctx, shader_program, prog->Parameters);
   if (!shader_program->LinkStatus) {
      goto fail_exit;
   }
d2838 10
a2847 1
   return prog;
d2849 1
a2849 4
fail_exit:
   free(mesa_instructions);
   _mesa_reference_program(ctx, &shader->Program, NULL);
   return NULL;
a2851 1
extern "C" {
d2879 1
a2879 1
				 | LOG_TO_LOG2 | INT_DIV_TO_MUL_RCP
d2884 1
a2884 4
	 progress = do_common_optimization(ir, true, true,
					   options->MaxUnrollIterations,
                                           options)
	   || progress;
d2888 1
a2888 1
	 if (options->MaxIfDepth == 0)
d2890 2
a2891 2

	 progress = lower_if_to_cond_assign(ir, options->MaxIfDepth) || progress;
a2909 1
         progress = lower_vector_insert(ir, true) || progress;
d2924 1
a2924 4
	 if (i == MESA_SHADER_VERTEX) {
            ((struct gl_vertex_program *)linked_prog)->UsesClipDistance
               = prog->Vert.UsesClipDistance;
	 }
d2926 21
a2946 5
	 _mesa_reference_program(ctx, &prog->_LinkedShaders[i]->Program,
				 linked_prog);
         if (!ctx->Driver.ProgramStringNotify(ctx,
                                              _mesa_program_index_to_target(i),
                                              linked_prog)) {
d2954 1
a2954 1
   return prog->LinkStatus;
d2957 89
d3060 1
a3060 1
	 linker_error(prog, "linking with uncompiled shader");
d3065 5
d3079 2
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@a46 1
#include "main/uniforms.h"
d51 1
a59 4
static int swizzle_for_size(int size);

namespace {

d63 2
a131 2
} /* anonymous namespace */

a149 2
namespace {

d152 11
a162 1
   DECLARE_RALLOC_CXX_OPERATORS(ir_to_mesa_instruction)
d236 1
a236 1
   variable_storage *find_variable_storage(const ir_variable *var);
a267 2
   virtual void visit(ir_emit_vertex *);
   virtual void visit(ir_end_primitive *);
a326 2
} /* anonymous namespace */

a620 1
   case GLSL_TYPE_IMAGE:
a624 1
   case GLSL_TYPE_ATOMIC_UINT:
d662 1
a662 1
ir_to_mesa_visitor::find_variable_storage(const ir_variable *var)
d664 1
d667 2
a668 2
   foreach_list(node, &this->variables) {
      entry = (variable_storage *) node;
d683 2
a684 2
      fp->OriginUpperLeft = ir->data.origin_upper_left;
      fp->PixelCenterInteger = ir->data.pixel_center_integer;
d687 1
a687 1
   if (ir->data.mode == ir_var_uniform && strncmp(ir->name, "gl_", 3) == 0) {
d761 14
d777 14
d793 11
d838 1
a838 1
      sig = ir->matching_signature(NULL, &empty);
d842 2
a843 2
      foreach_list(node, &sig->body) {
	 ir_instruction *ir = (ir_instruction *) node;
a1492 1
   case ir_triop_fma:
a1496 5
   case ir_binop_ldexp:
   case ir_triop_csel:
   case ir_binop_carry:
   case ir_binop_borrow:
   case ir_binop_imul_high:
d1563 1
a1563 1
      switch (var->data.mode) {
d1566 1
a1566 1
					       var->data.location);
d1575 1
a1575 1
	 assert(var->data.location != -1);
d1578 1
a1578 1
                                               var->data.location);
d1581 1
a1581 1
	 assert(var->data.location != -1);
d1584 1
a1584 1
                                               var->data.location);
d1589 1
a1589 1
                                               var->data.location);
d1903 2
a1904 2
      foreach_list(node, &ir->components) {
	 ir_constant *field_value = (ir_constant *) node;
d1998 1
a1998 1
ir_to_mesa_visitor::visit(ir_call *)
a2065 6
   case ir_tg4:
      assert(!"Unexpected ir_tg4 opcode");
      break;
   case ir_query_levels:
      assert(!"Unexpected ir_query_levels opcode");
      break;
d2252 1
a2252 13
   emit(ir->condition, OPCODE_ENDIF);
}

void
ir_to_mesa_visitor::visit(ir_emit_vertex *)
{
   assert(!"Geometry shaders not supported.");
}

void
ir_to_mesa_visitor::visit(ir_end_primitive *)
{
   assert(!"Geometry shaders not supported.");
d2355 2
a2356 2
	 foreach_list(n, &v->function_signatures) {
	    function_entry *entry = (function_entry *) n;
a2402 2
namespace {

d2407 1
a2407 1
                         gl_shader_stage shader_type)
d2419 1
a2419 1
      var->data.location = this->idx;
d2429 1
a2429 1
   gl_shader_stage shader_type;
a2431 2
} /* anonymous namespace */

d2506 2
a2507 1
   add_uniform_to_shader add(shader_program, params, sh->Stage);
d2512 1
a2512 1
      if ((var == NULL) || (var->data.mode != ir_var_uniform)
a2572 1
	 case GLSL_TYPE_IMAGE:
a2575 1
         case GLSL_TYPE_ATOMIC_UINT:
d2633 2
a2634 2
   foreach_list(node, &this->instructions) {
      ir_to_mesa_instruction *inst = (ir_to_mesa_instruction *) node;
d2812 2
a2813 2
   GLenum target = _mesa_shader_stage_to_program(shader->Stage);
   const char *target_string = _mesa_shader_stage_to_string(shader->Stage);
d2815 16
a2830 1
         &ctx->ShaderCompilerOptions[shader->Stage];
d2853 1
a2853 1
   foreach_list(node, &v.instructions) {
d2869 2
a2870 2
   foreach_list(node, &v.instructions) {
      const ir_to_mesa_instruction *inst = (ir_to_mesa_instruction *) node;
d2943 9
a2951 9
   if (ctx->_Shader->Flags & GLSL_DUMP) {
      fprintf(stderr, "\n");
      fprintf(stderr, "GLSL IR for linked %s program %d:\n", target_string,
	      shader_program->Name);
      _mesa_print_ir(stderr, shader->ir, NULL);
      fprintf(stderr, "\n");
      fprintf(stderr, "\n");
      fprintf(stderr, "Mesa IR for linked %s program %d:\n", target_string,
	      shader_program->Name);
a2953 1
      fflush(stderr);
d2964 1
a2964 1
   do_set_program_inouts(shader->ir, prog, shader->Stage);
d2978 1
a2978 1
   if ((ctx->_Shader->Flags & GLSL_NO_OPT) == 0) {
d3012 1
a3012 1
   for (unsigned i = 0; i < MESA_SHADER_STAGES; i++) {
d3019 1
a3019 1
            &ctx->ShaderCompilerOptions[prog->_LinkedShaders[i]->Stage];
d3033 2
a3034 1
                                           options, ctx->Const.NativeIntegers)
d3067 1
a3067 1
   for (unsigned i = 0; i < MESA_SHADER_STAGES; i++) {
d3076 4
a3079 1
         _mesa_copy_linked_program_data((gl_shader_stage) i, prog, linked_prog);
d3084 1
a3084 1
                                              _mesa_shader_stage_to_program(i),
d3111 1
d3125 1
a3125 1
   if (ctx->_Shader->Flags & GLSL_DUMP) {
d3127 1
a3127 1
	 fprintf(stderr, "GLSL shader program %d failed to link\n", prog->Name);
d3131 2
a3132 2
	 fprintf(stderr, "GLSL shader program %d info log:\n", prog->Name);
	 fprintf(stderr, "%s\n", prog->InfoLog);
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d314 1
d666 5
a670 1
   foreach_in_list(variable_storage, entry, &this->variables) {
d690 2
a691 2
      const ir_state_slot *const slots = ir->get_state_slots();
      assert(slots != NULL);
d699 1
a699 1
      for (i = 0; i < ir->get_num_state_slots(); i++) {
d707 1
a707 1
      if (i == ir->get_num_state_slots()) {
d718 1
a718 1
	 assert((int) ir->get_num_state_slots() == type_size(ir->type));
d729 1
a729 1
      for (unsigned int i = 0; i < ir->get_num_state_slots(); i++) {
d749 1
a749 1
	  dst.index != storage->index + (int) ir->get_num_state_slots()) {
d800 1
a800 1
      sig = ir->matching_signature(NULL, &empty, false);
d804 3
a806 1
      foreach_in_list(ir_instruction, ir, &sig->body) {
d875 44
d1081 3
a1179 6
   case ir_unop_saturate: {
      ir_to_mesa_instruction *inst = emit(ir, OPCODE_MOV,
                                          result_dst, op[0]);
      inst->saturate = true;
      break;
   }
a1464 7
   case ir_unop_interpolate_at_centroid:
   case ir_binop_interpolate_at_offset:
   case ir_binop_interpolate_at_sample:
   case ir_unop_dFdx_coarse:
   case ir_unop_dFdx_fine:
   case ir_unop_dFdy_coarse:
   case ir_unop_dFdy_fine:
d1871 2
a1872 1
      foreach_in_list(ir_constant, field_value, &ir->components) {
d2341 3
a2343 1
	 foreach_in_list(function_entry, entry, &v->function_signatures) {
d2437 2
a2438 1
   if (type->without_array()->is_sampler()) {
d2498 2
a2499 2
   foreach_in_list(ir_instruction, node, sh->ir) {
      ir_variable *var = node->as_variable();
d2553 6
a2558 1
	    format = uniform_native;
d2624 3
a2626 1
   foreach_in_list(ir_to_mesa_instruction, inst, &this->instructions) {
d2806 1
a2806 1
         &ctx->Const.ShaderCompilerOptions[shader->Stage];
d2828 4
a2831 1
   unsigned num_instructions = v.instructions.length();
d2845 3
a2847 1
   foreach_in_list(const ir_to_mesa_instruction, inst, &v.instructions) {
d2996 1
a2996 1
            &ctx->Const.ShaderCompilerOptions[prog->_LinkedShaders[i]->Stage];
a3002 1
	 GLenum target = _mesa_shader_stage_to_program(prog->_LinkedShaders[i]->Stage);
d3077 1
a3077 1
   _mesa_clear_shader_program_data(prog);
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@a313 1
   bool try_emit_sat(ir_expression *ir);
d665 1
a665 5
   variable_storage *entry;

   foreach_list(node, &this->variables) {
      entry = (variable_storage *) node;

d685 2
a686 2
      const ir_state_slot *const slots = ir->state_slots;
      assert(ir->state_slots != NULL);
d694 1
a694 1
      for (i = 0; i < ir->num_state_slots; i++) {
d702 1
a702 1
      if (i == ir->num_state_slots) {
d713 1
a713 1
	 assert((int) ir->num_state_slots == type_size(ir->type));
d724 1
a724 1
      for (unsigned int i = 0; i < ir->num_state_slots; i++) {
d744 1
a744 1
	  dst.index != storage->index + (int) ir->num_state_slots) {
d795 1
a795 1
      sig = ir->matching_signature(NULL, &empty);
d799 1
a799 3
      foreach_list(node, &sig->body) {
	 ir_instruction *ir = (ir_instruction *) node;

a867 44
bool
ir_to_mesa_visitor::try_emit_sat(ir_expression *ir)
{
   /* Saturates were only introduced to vertex programs in
    * NV_vertex_program3, so don't give them to drivers in the VP.
    */
   if (this->prog->Target == GL_VERTEX_PROGRAM_ARB)
      return false;

   ir_rvalue *sat_src = ir->as_rvalue_to_saturate();
   if (!sat_src)
      return false;

   sat_src->accept(this);
   src_reg src = this->result;

   /* If we generated an expression instruction into a temporary in
    * processing the saturate's operand, apply the saturate to that
    * instruction.  Otherwise, generate a MOV to do the saturate.
    *
    * Note that we have to be careful to only do this optimization if
    * the instruction in question was what generated src->result.  For
    * example, ir_dereference_array might generate a MUL instruction
    * to create the reladdr, and return us a src reg using that
    * reladdr.  That MUL result is not the value we're trying to
    * saturate.
    */
   ir_expression *sat_src_expr = sat_src->as_expression();
   ir_to_mesa_instruction *new_inst;
   new_inst = (ir_to_mesa_instruction *)this->instructions.get_tail();
   if (sat_src_expr && (sat_src_expr->operation == ir_binop_mul ||
			sat_src_expr->operation == ir_binop_add ||
			sat_src_expr->operation == ir_binop_dot)) {
      new_inst->saturate = true;
   } else {
      this->result = get_temp(ir->type);
      ir_to_mesa_instruction *inst;
      inst = emit(ir, OPCODE_MOV, dst_reg(this->result), src);
      inst->saturate = true;
   }

   return true;
}

a1029 3
   if (try_emit_sat(ir))
      return;

d1126 6
d1417 7
d1830 1
a1830 2
      foreach_list(node, &ir->components) {
	 ir_constant *field_value = (ir_constant *) node;
d2299 1
a2299 3
	 foreach_list(n, &v->function_signatures) {
	    function_entry *entry = (function_entry *) n;

d2393 1
a2393 2
   if (type->is_sampler() ||
       (type->is_array() && type->fields.array->is_sampler())) {
d2453 2
a2454 2
   foreach_list(node, sh->ir) {
      ir_variable *var = ((ir_instruction *) node)->as_variable();
d2508 1
a2508 6
	    if (ctx->Const.NativeIntegers) {
	       format = (ctx->Const.UniformBooleanTrue == 1)
		  ? uniform_bool_int_0_1 : uniform_bool_int_0_not0;
	    } else {
	       format = uniform_bool_float;
	    }
d2574 1
a2574 3
   foreach_list(node, &this->instructions) {
      ir_to_mesa_instruction *inst = (ir_to_mesa_instruction *) node;

d2754 1
a2754 1
         &ctx->ShaderCompilerOptions[shader->Stage];
d2776 1
a2776 4
   int num_instructions = 0;
   foreach_list(node, &v.instructions) {
      num_instructions++;
   }
d2790 1
a2790 3
   foreach_list(node, &v.instructions) {
      const ir_to_mesa_instruction *inst = (ir_to_mesa_instruction *) node;

d2939 1
a2939 1
            &ctx->ShaderCompilerOptions[prog->_LinkedShaders[i]->Stage];
d2946 1
d3021 1
a3021 1
   _mesa_clear_shader_program_data(ctx, prog);
@


