head	1.11;
access;
symbols
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	v10_2_9:1.1.1.6
	v10_4_3:1.1.1.5
	v10_2_7:1.1.1.4
	OPENBSD_5_6:1.7.0.2
	OPENBSD_5_6_BASE:1.7
	v10_2_3:1.1.1.4
	OPENBSD_5_5:1.6.0.2
	OPENBSD_5_5_BASE:1.6
	v9_2_5:1.1.1.3
	v9_2_3:1.1.1.3
	v9_2_2:1.1.1.3
	v9_2_1:1.1.1.3
	v9_2_0:1.1.1.3
	OPENBSD_5_4:1.5.0.4
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.2
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.4.0.4
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	v7_10_3:1.1.1.2
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.6
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.1.0.4
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.2
	v7_0_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2015.12.23.05.17.55;	author jsg;	state dead;
branches;
next	1.10;
commitid	TnlogFl9nOv2eaRf;

1.10
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.9;
commitid	4ry2gvZGMXkCUD2n;

1.9
date	2015.01.31.05.41.14;	author jsg;	state Exp;
branches;
next	1.8;
commitid	MrqvfysMyyM82lGg;

1.8
date	2015.01.25.14.41.22;	author jsg;	state Exp;
branches;
next	1.7;
commitid	mcxB0JvoI9gTDYXU;

1.7
date	2014.07.09.21.09.01;	author jsg;	state Exp;
branches;
next	1.6;
commitid	WPD6rgPryPkvXOr9;

1.6
date	2013.09.05.14.06.59;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2012.08.17.13.58.20;	author mpi;	state Exp;
branches;
next	1.4;

1.4
date	2011.10.23.13.37.46;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.05.22.20.06.37;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.23;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.24.17.32.26;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.11.24.17.32.26;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2011.10.23.13.29.50;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2013.09.05.13.17.47;	author jsg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.07.09.20.35.14;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.5
date	2015.01.25.14.13.39;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.6
date	2015.02.20.22.50.44;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.11
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************

Copyright 2002-2008 VMware, Inc.

All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
on the rights to use, copy, modify, merge, publish, distribute, sub
license, and/or sell copies of the Software, and to permit persons to whom
the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice (including the next
paragraph) shall be included in all copies or substantial portions of the
Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
VMWARE AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
USE OR OTHER DEALINGS IN THE SOFTWARE.

**************************************************************************/

/*
 * Authors:
 *   Keith Whitwell <keithw@@vmware.com>
 */



/* Display list compiler attempts to store lists of vertices with the
 * same vertex layout.  Additionally it attempts to minimize the need
 * for execute-time fixup of these vertex lists, allowing them to be
 * cached on hardware.
 *
 * There are still some circumstances where this can be thwarted, for
 * example by building a list that consists of one very long primitive
 * (eg Begin(Triangles), 1000 vertices, End), and calling that list
 * from inside a different begin/end object (Begin(Lines), CallList,
 * End).
 *
 * In that case the code will have to replay the list as individual
 * commands through the Exec dispatch table, or fix up the copied
 * vertices at execute-time.
 *
 * The other case where fixup is required is when a vertex attribute
 * is introduced in the middle of a primitive.  Eg:
 *  Begin(Lines)
 *  TexCoord1f()           Vertex2f()
 *  TexCoord1f() Color3f() Vertex2f()
 *  End()
 *
 *  If the current value of Color isn't known at compile-time, this
 *  primitive will require fixup.
 *
 *
 * The list compiler currently doesn't attempt to compile lists
 * containing EvalCoord or EvalPoint commands.  On encountering one of
 * these, compilation falls back to opcodes.
 *
 * This could be improved to fallback only when a mix of EvalCoord and
 * Vertex commands are issued within a single primitive.
 */


#include "main/glheader.h"
#include "main/bufferobj.h"
#include "main/context.h"
#include "main/dlist.h"
#include "main/enums.h"
#include "main/eval.h"
#include "main/macros.h"
#include "main/api_validate.h"
#include "main/api_arrayelt.h"
#include "main/vtxfmt.h"
#include "main/dispatch.h"

#include "vbo_context.h"
#include "vbo_noop.h"


#ifdef ERROR
#undef ERROR
#endif


/* An interesting VBO number/name to help with debugging */
#define VBO_BUF_ID  12345


/*
 * NOTE: Old 'parity' issue is gone, but copying can still be
 * wrong-footed on replay.
 */
static GLuint
_save_copy_vertices(struct gl_context *ctx,
                    const struct vbo_save_vertex_list *node,
                    const GLfloat * src_buffer)
{
   struct vbo_save_context *save = &vbo_context(ctx)->save;
   const struct _mesa_prim *prim = &node->prim[node->prim_count - 1];
   GLuint nr = prim->count;
   GLuint sz = save->vertex_size;
   const GLfloat *src = src_buffer + prim->start * sz;
   GLfloat *dst = save->copied.buffer;
   GLuint ovf, i;

   if (prim->end)
      return 0;

   switch (prim->mode) {
   case GL_POINTS:
      return 0;
   case GL_LINES:
      ovf = nr & 1;
      for (i = 0; i < ovf; i++)
         memcpy(dst + i * sz, src + (nr - ovf + i) * sz,
                sz * sizeof(GLfloat));
      return i;
   case GL_TRIANGLES:
      ovf = nr % 3;
      for (i = 0; i < ovf; i++)
         memcpy(dst + i * sz, src + (nr - ovf + i) * sz,
                sz * sizeof(GLfloat));
      return i;
   case GL_QUADS:
      ovf = nr & 3;
      for (i = 0; i < ovf; i++)
         memcpy(dst + i * sz, src + (nr - ovf + i) * sz,
                sz * sizeof(GLfloat));
      return i;
   case GL_LINE_STRIP:
      if (nr == 0)
         return 0;
      else {
         memcpy(dst, src + (nr - 1) * sz, sz * sizeof(GLfloat));
         return 1;
      }
   case GL_LINE_LOOP:
   case GL_TRIANGLE_FAN:
   case GL_POLYGON:
      if (nr == 0)
         return 0;
      else if (nr == 1) {
         memcpy(dst, src + 0, sz * sizeof(GLfloat));
         return 1;
      }
      else {
         memcpy(dst, src + 0, sz * sizeof(GLfloat));
         memcpy(dst + sz, src + (nr - 1) * sz, sz * sizeof(GLfloat));
         return 2;
      }
   case GL_TRIANGLE_STRIP:
   case GL_QUAD_STRIP:
      switch (nr) {
      case 0:
         ovf = 0;
         break;
      case 1:
         ovf = 1;
         break;
      default:
         ovf = 2 + (nr & 1);
         break;
      }
      for (i = 0; i < ovf; i++)
         memcpy(dst + i * sz, src + (nr - ovf + i) * sz,
                sz * sizeof(GLfloat));
      return i;
   default:
      assert(0);
      return 0;
   }
}


static struct vbo_save_vertex_store *
alloc_vertex_store(struct gl_context *ctx)
{
   struct vbo_save_context *save = &vbo_context(ctx)->save;
   struct vbo_save_vertex_store *vertex_store =
      CALLOC_STRUCT(vbo_save_vertex_store);

   /* obj->Name needs to be non-zero, but won't ever be examined more
    * closely than that.  In particular these buffers won't be entered
    * into the hash and can never be confused with ones visible to the
    * user.  Perhaps there could be a special number for internal
    * buffers:
    */
   vertex_store->bufferobj = ctx->Driver.NewBufferObject(ctx,
                                                         VBO_BUF_ID,
                                                         GL_ARRAY_BUFFER_ARB);
   if (vertex_store->bufferobj) {
      save->out_of_memory =
         !ctx->Driver.BufferData(ctx,
                                 GL_ARRAY_BUFFER_ARB,
                                 VBO_SAVE_BUFFER_SIZE * sizeof(GLfloat),
                                 NULL, GL_STATIC_DRAW_ARB,
                                 GL_MAP_WRITE_BIT |
                                 GL_DYNAMIC_STORAGE_BIT,
                                 vertex_store->bufferobj);
   }
   else {
      save->out_of_memory = GL_TRUE;
   }

   if (save->out_of_memory) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "internal VBO allocation");
      _mesa_install_save_vtxfmt(ctx, &save->vtxfmt_noop);
   }

   vertex_store->buffer = NULL;
   vertex_store->used = 0;
   vertex_store->refcount = 1;

   return vertex_store;
}


static void
free_vertex_store(struct gl_context *ctx,
                  struct vbo_save_vertex_store *vertex_store)
{
   assert(!vertex_store->buffer);

   if (vertex_store->bufferobj) {
      _mesa_reference_buffer_object(ctx, &vertex_store->bufferobj, NULL);
   }

   free(vertex_store);
}


GLfloat *
vbo_save_map_vertex_store(struct gl_context *ctx,
                          struct vbo_save_vertex_store *vertex_store)
{
   const GLbitfield access = (GL_MAP_WRITE_BIT |
                              GL_MAP_INVALIDATE_RANGE_BIT |
                              GL_MAP_UNSYNCHRONIZED_BIT |
                              GL_MAP_FLUSH_EXPLICIT_BIT);

   assert(vertex_store->bufferobj);
   assert(!vertex_store->buffer);  /* the buffer should not be mapped */

   if (vertex_store->bufferobj->Size > 0) {
      /* Map the remaining free space in the VBO */
      GLintptr offset = vertex_store->used * sizeof(GLfloat);
      GLsizeiptr size = vertex_store->bufferobj->Size - offset;
      GLfloat *range = (GLfloat *)
         ctx->Driver.MapBufferRange(ctx, offset, size, access,
                                    vertex_store->bufferobj,
                                    MAP_INTERNAL);
      if (range) {
         /* compute address of start of whole buffer (needed elsewhere) */
         vertex_store->buffer = range - vertex_store->used;
         assert(vertex_store->buffer);
         return range;
      }
      else {
         vertex_store->buffer = NULL;
         return NULL;
      }
   }
   else {
      /* probably ran out of memory for buffers */
      return NULL;
   }
}


void
vbo_save_unmap_vertex_store(struct gl_context *ctx,
                            struct vbo_save_vertex_store *vertex_store)
{
   if (vertex_store->bufferobj->Size > 0) {
      GLintptr offset = 0;
      GLsizeiptr length = vertex_store->used * sizeof(GLfloat)
         - vertex_store->bufferobj->Mappings[MAP_INTERNAL].Offset;

      /* Explicitly flush the region we wrote to */
      ctx->Driver.FlushMappedBufferRange(ctx, offset, length,
                                         vertex_store->bufferobj,
                                         MAP_INTERNAL);

      ctx->Driver.UnmapBuffer(ctx, vertex_store->bufferobj, MAP_INTERNAL);
   }
   vertex_store->buffer = NULL;
}


static struct vbo_save_primitive_store *
alloc_prim_store(struct gl_context *ctx)
{
   struct vbo_save_primitive_store *store =
      CALLOC_STRUCT(vbo_save_primitive_store);
   (void) ctx;
   store->used = 0;
   store->refcount = 1;
   return store;
}


static void
_save_reset_counters(struct gl_context *ctx)
{
   struct vbo_save_context *save = &vbo_context(ctx)->save;

   save->prim = save->prim_store->buffer + save->prim_store->used;
   save->buffer = save->vertex_store->buffer + save->vertex_store->used;

   assert(save->buffer == save->buffer_ptr);

   if (save->vertex_size)
      save->max_vert = (VBO_SAVE_BUFFER_SIZE - save->vertex_store->used) /
                        save->vertex_size;
   else
      save->max_vert = 0;

   save->vert_count = 0;
   save->prim_count = 0;
   save->prim_max = VBO_SAVE_PRIM_SIZE - save->prim_store->used;
   save->dangling_attr_ref = GL_FALSE;
}

/**
 * For a list of prims, try merging prims that can just be extensions of the
 * previous prim.
 */
static void
merge_prims(struct gl_context *ctx,
            struct _mesa_prim *prim_list,
            GLuint *prim_count)
{
   GLuint i;
   struct _mesa_prim *prev_prim = prim_list;

   for (i = 1; i < *prim_count; i++) {
      struct _mesa_prim *this_prim = prim_list + i;

      vbo_try_prim_conversion(this_prim);

      if (vbo_can_merge_prims(prev_prim, this_prim)) {
         /* We've found a prim that just extend the previous one.  Tack it
          * onto the previous one, and let this primitive struct get dropped.
          */
         vbo_merge_prims(prev_prim, this_prim);
         continue;
      }

      /* If any previous primitives have been dropped, then we need to copy
       * this later one into the next available slot.
       */
      prev_prim++;
      if (prev_prim != this_prim)
         *prev_prim = *this_prim;
   }

   *prim_count = prev_prim - prim_list + 1;
}

/**
 * Insert the active immediate struct onto the display list currently
 * being built.
 */
static void
_save_compile_vertex_list(struct gl_context *ctx)
{
   struct vbo_save_context *save = &vbo_context(ctx)->save;
   struct vbo_save_vertex_list *node;

   /* Allocate space for this structure in the display list currently
    * being compiled.
    */
   node = (struct vbo_save_vertex_list *)
      _mesa_dlist_alloc_aligned(ctx, save->opcode_vertex_list, sizeof(*node));

   if (!node)
      return;

   /* Make sure the pointer is aligned to the size of a pointer */
   assert((GLintptr) node % sizeof(void *) == 0);

   /* Duplicate our template, increment refcounts to the storage structs:
    */
   memcpy(node->attrsz, save->attrsz, sizeof(node->attrsz));
   memcpy(node->attrtype, save->attrtype, sizeof(node->attrtype));
   node->vertex_size = save->vertex_size;
   node->buffer_offset =
      (save->buffer - save->vertex_store->buffer) * sizeof(GLfloat);
   node->count = save->vert_count;
   node->wrap_count = save->copied.nr;
   node->dangling_attr_ref = save->dangling_attr_ref;
   node->prim = save->prim;
   node->prim_count = save->prim_count;
   node->vertex_store = save->vertex_store;
   node->prim_store = save->prim_store;

   node->vertex_store->refcount++;
   node->prim_store->refcount++;

   if (node->prim[0].no_current_update) {
      node->current_size = 0;
      node->current_data = NULL;
   }
   else {
      node->current_size = node->vertex_size - node->attrsz[0];
      node->current_data = NULL;

      if (node->current_size) {
         /* If the malloc fails, we just pull the data out of the VBO
          * later instead.
          */
         node->current_data = malloc(node->current_size * sizeof(GLfloat));
         if (node->current_data) {
            const char *buffer = (const char *) save->vertex_store->buffer;
            unsigned attr_offset = node->attrsz[0] * sizeof(GLfloat);
            unsigned vertex_offset = 0;

            if (node->count)
               vertex_offset =
                  (node->count - 1) * node->vertex_size * sizeof(GLfloat);

            memcpy(node->current_data,
                   buffer + node->buffer_offset + vertex_offset + attr_offset,
                   node->current_size * sizeof(GLfloat));
         }
      }
   }

   assert(node->attrsz[VBO_ATTRIB_POS] != 0 || node->count == 0);

   if (save->dangling_attr_ref)
      ctx->ListState.CurrentList->Flags |= DLIST_DANGLING_REFS;

   save->vertex_store->used += save->vertex_size * node->count;
   save->prim_store->used += node->prim_count;

   /* Copy duplicated vertices
    */
   save->copied.nr = _save_copy_vertices(ctx, node, save->buffer);

   merge_prims(ctx, node->prim, &node->prim_count);

   /* Deal with GL_COMPILE_AND_EXECUTE:
    */
   if (ctx->ExecuteFlag) {
      struct _glapi_table *dispatch = GET_DISPATCH();

      _glapi_set_dispatch(ctx->Exec);

      vbo_loopback_vertex_list(ctx,
                               (const GLfloat *) ((const char *) save->
                                                  vertex_store->buffer +
                                                  node->buffer_offset),
                               node->attrsz, node->prim, node->prim_count,
                               node->wrap_count, node->vertex_size);

      _glapi_set_dispatch(dispatch);
   }

   /* Decide whether the storage structs are full, or can be used for
    * the next vertex lists as well.
    */
   if (save->vertex_store->used >
       VBO_SAVE_BUFFER_SIZE - 16 * (save->vertex_size + 4)) {

      /* Unmap old store:
       */
      vbo_save_unmap_vertex_store(ctx, save->vertex_store);

      /* Release old reference:
       */
      save->vertex_store->refcount--;
      assert(save->vertex_store->refcount != 0);
      save->vertex_store = NULL;

      /* Allocate and map new store:
       */
      save->vertex_store = alloc_vertex_store(ctx);
      save->buffer_ptr = vbo_save_map_vertex_store(ctx, save->vertex_store);
      save->out_of_memory = save->buffer_ptr == NULL;
   }

   if (save->prim_store->used > VBO_SAVE_PRIM_SIZE - 6) {
      save->prim_store->refcount--;
      assert(save->prim_store->refcount != 0);
      save->prim_store = alloc_prim_store(ctx);
   }

   /* Reset our structures for the next run of vertices:
    */
   _save_reset_counters(ctx);
}


/**
 * This is called when we fill a vertex buffer before we hit a glEnd().
 * We
 * TODO -- If no new vertices have been stored, don't bother saving it.
 */
static void
_save_wrap_buffers(struct gl_context *ctx)
{
   struct vbo_save_context *save = &vbo_context(ctx)->save;
   GLint i = save->prim_count - 1;
   GLenum mode;
   GLboolean weak;
   GLboolean no_current_update;

   assert(i < (GLint) save->prim_max);
   assert(i >= 0);

   /* Close off in-progress primitive.
    */
   save->prim[i].count = (save->vert_count - save->prim[i].start);
   mode = save->prim[i].mode;
   weak = save->prim[i].weak;
   no_current_update = save->prim[i].no_current_update;

   /* store the copied vertices, and allocate a new list.
    */
   _save_compile_vertex_list(ctx);

   /* Restart interrupted primitive
    */
   save->prim[0].mode = mode;
   save->prim[0].weak = weak;
   save->prim[0].no_current_update = no_current_update;
   save->prim[0].begin = 0;
   save->prim[0].end = 0;
   save->prim[0].pad = 0;
   save->prim[0].start = 0;
   save->prim[0].count = 0;
   save->prim[0].num_instances = 1;
   save->prim[0].base_instance = 0;
   save->prim[0].is_indirect = 0;
   save->prim_count = 1;
}


/**
 * Called only when buffers are wrapped as the result of filling the
 * vertex_store struct.
 */
static void
_save_wrap_filled_vertex(struct gl_context *ctx)
{
   struct vbo_save_context *save = &vbo_context(ctx)->save;
   GLfloat *data = save->copied.buffer;
   GLuint i;

   /* Emit a glEnd to close off the last vertex list.
    */
   _save_wrap_buffers(ctx);

   /* Copy stored stored vertices to start of new list.
    */
   assert(save->max_vert - save->vert_count > save->copied.nr);

   for (i = 0; i < save->copied.nr; i++) {
      memcpy(save->buffer_ptr, data, save->vertex_size * sizeof(GLfloat));
      data += save->vertex_size;
      save->buffer_ptr += save->vertex_size;
      save->vert_count++;
   }
}


static void
_save_copy_to_current(struct gl_context *ctx)
{
   struct vbo_save_context *save = &vbo_context(ctx)->save;
   GLuint i;

   for (i = VBO_ATTRIB_POS + 1; i < VBO_ATTRIB_MAX; i++) {
      if (save->attrsz[i]) {
         save->currentsz[i][0] = save->attrsz[i];
         COPY_CLEAN_4V_TYPE_AS_FLOAT(save->current[i], save->attrsz[i],
                                     save->attrptr[i], save->attrtype[i]);
      }
   }
}


static void
_save_copy_from_current(struct gl_context *ctx)
{
   struct vbo_save_context *save = &vbo_context(ctx)->save;
   GLint i;

   for (i = VBO_ATTRIB_POS + 1; i < VBO_ATTRIB_MAX; i++) {
      switch (save->attrsz[i]) {
      case 4:
         save->attrptr[i][3] = save->current[i][3];
      case 3:
         save->attrptr[i][2] = save->current[i][2];
      case 2:
         save->attrptr[i][1] = save->current[i][1];
      case 1:
         save->attrptr[i][0] = save->current[i][0];
      case 0:
         break;
      }
   }
}


/**
 * Called when we increase the size of a vertex attribute.  For example,
 * if we've seen one or more glTexCoord2f() calls and now we get a
 * glTexCoord3f() call.
 * Flush existing data, set new attrib size, replay copied vertices.
 */
static void
_save_upgrade_vertex(struct gl_context *ctx, GLuint attr, GLuint newsz)
{
   struct vbo_save_context *save = &vbo_context(ctx)->save;
   GLuint oldsz;
   GLuint i;
   GLfloat *tmp;

   /* Store the current run of vertices, and emit a GL_END.  Emit a
    * BEGIN in the new buffer.
    */
   if (save->vert_count)
      _save_wrap_buffers(ctx);
   else
      assert(save->copied.nr == 0);

   /* Do a COPY_TO_CURRENT to ensure back-copying works for the case
    * when the attribute already exists in the vertex and is having
    * its size increased.
    */
   _save_copy_to_current(ctx);

   /* Fix up sizes:
    */
   oldsz = save->attrsz[attr];
   save->attrsz[attr] = newsz;

   save->vertex_size += newsz - oldsz;
   save->max_vert = ((VBO_SAVE_BUFFER_SIZE - save->vertex_store->used) /
                     save->vertex_size);
   save->vert_count = 0;

   /* Recalculate all the attrptr[] values:
    */
   for (i = 0, tmp = save->vertex; i < VBO_ATTRIB_MAX; i++) {
      if (save->attrsz[i]) {
         save->attrptr[i] = tmp;
         tmp += save->attrsz[i];
      }
      else {
         save->attrptr[i] = NULL;       /* will not be dereferenced. */
      }
   }

   /* Copy from current to repopulate the vertex with correct values.
    */
   _save_copy_from_current(ctx);

   /* Replay stored vertices to translate them to new format here.
    *
    * If there are copied vertices and the new (upgraded) attribute
    * has not been defined before, this list is somewhat degenerate,
    * and will need fixup at runtime.
    */
   if (save->copied.nr) {
      const GLfloat *data = save->copied.buffer;
      GLfloat *dest = save->buffer;
      GLuint j;

      /* Need to note this and fix up at runtime (or loopback):
       */
      if (attr != VBO_ATTRIB_POS && save->currentsz[attr][0] == 0) {
         assert(oldsz == 0);
         save->dangling_attr_ref = GL_TRUE;
      }

      for (i = 0; i < save->copied.nr; i++) {
         for (j = 0; j < VBO_ATTRIB_MAX; j++) {
            if (save->attrsz[j]) {
               if (j == attr) {
                  if (oldsz) {
                     COPY_CLEAN_4V_TYPE_AS_FLOAT(dest, oldsz, data,
                                                 save->attrtype[j]);
                     data += oldsz;
                     dest += newsz;
                  }
                  else {
                     COPY_SZ_4V(dest, newsz, save->current[attr]);
                     dest += newsz;
                  }
               }
               else {
                  GLint sz = save->attrsz[j];
                  COPY_SZ_4V(dest, sz, data);
                  data += sz;
                  dest += sz;
               }
            }
         }
      }

      save->buffer_ptr = dest;
      save->vert_count += save->copied.nr;
   }
}


/**
 * This is called when the size of a vertex attribute changes.
 * For example, after seeing one or more glTexCoord2f() calls we
 * get a glTexCoord4f() or glTexCoord1f() call.
 */
static void
save_fixup_vertex(struct gl_context *ctx, GLuint attr, GLuint sz)
{
   struct vbo_save_context *save = &vbo_context(ctx)->save;

   if (sz > save->attrsz[attr]) {
      /* New size is larger.  Need to flush existing vertices and get
       * an enlarged vertex format.
       */
      _save_upgrade_vertex(ctx, attr, sz);
   }
   else if (sz < save->active_sz[attr]) {
      GLuint i;
      const GLfloat *id = vbo_get_default_vals_as_float(save->attrtype[attr]);

      /* New size is equal or smaller - just need to fill in some
       * zeros.
       */
      for (i = sz; i <= save->attrsz[attr]; i++)
         save->attrptr[attr][i - 1] = id[i - 1];
   }

   save->active_sz[attr] = sz;
}


/**
 * Reset the current size of all vertex attributes to the default
 * value of 0.  This signals that we haven't yet seen any per-vertex
 * commands such as glNormal3f() or glTexCoord2f().
 */
static void
_save_reset_vertex(struct gl_context *ctx)
{
   struct vbo_save_context *save = &vbo_context(ctx)->save;
   GLuint i;

   for (i = 0; i < VBO_ATTRIB_MAX; i++) {
      save->attrsz[i] = 0;
      save->active_sz[i] = 0;
   }

   save->vertex_size = 0;
}



#define ERROR(err)   _mesa_compile_error(ctx, err, __FUNCTION__);


/* Only one size for each attribute may be active at once.  Eg. if
 * Color3f is installed/active, then Color4f may not be, even if the
 * vertex actually contains 4 color coordinates.  This is because the
 * 3f version won't otherwise set color[3] to 1.0 -- this is the job
 * of the chooser function when switching between Color4f and Color3f.
 */
#define ATTR(A, N, T, V0, V1, V2, V3)				\
do {								\
   struct vbo_save_context *save = &vbo_context(ctx)->save;	\
								\
   if (save->active_sz[A] != N)					\
      save_fixup_vertex(ctx, A, N);				\
								\
   {								\
      GLfloat *dest = save->attrptr[A];				\
      if (N>0) dest[0] = V0;					\
      if (N>1) dest[1] = V1;					\
      if (N>2) dest[2] = V2;					\
      if (N>3) dest[3] = V3;					\
      save->attrtype[A] = T;                                    \
   }								\
								\
   if ((A) == 0) {						\
      GLuint i;							\
								\
      for (i = 0; i < save->vertex_size; i++)			\
	 save->buffer_ptr[i] = save->vertex[i];			\
								\
      save->buffer_ptr += save->vertex_size;			\
								\
      if (++save->vert_count >= save->max_vert)			\
	 _save_wrap_filled_vertex(ctx);				\
   }								\
} while (0)

#define TAG(x) _save_##x

#include "vbo_attrib_tmp.h"



#define MAT( ATTR, N, face, params )			\
do {							\
   if (face != GL_BACK)					\
      MAT_ATTR( ATTR, N, params ); /* front */		\
   if (face != GL_FRONT)				\
      MAT_ATTR( ATTR + 1, N, params ); /* back */	\
} while (0)


/**
 * Save a glMaterial call found between glBegin/End.
 * glMaterial calls outside Begin/End are handled in dlist.c.
 */
static void GLAPIENTRY
_save_Materialfv(GLenum face, GLenum pname, const GLfloat *params)
{
   GET_CURRENT_CONTEXT(ctx);

   if (face != GL_FRONT && face != GL_BACK && face != GL_FRONT_AND_BACK) {
      _mesa_compile_error(ctx, GL_INVALID_ENUM, "glMaterial(face)");
      return;
   }

   switch (pname) {
   case GL_EMISSION:
      MAT(VBO_ATTRIB_MAT_FRONT_EMISSION, 4, face, params);
      break;
   case GL_AMBIENT:
      MAT(VBO_ATTRIB_MAT_FRONT_AMBIENT, 4, face, params);
      break;
   case GL_DIFFUSE:
      MAT(VBO_ATTRIB_MAT_FRONT_DIFFUSE, 4, face, params);
      break;
   case GL_SPECULAR:
      MAT(VBO_ATTRIB_MAT_FRONT_SPECULAR, 4, face, params);
      break;
   case GL_SHININESS:
      if (*params < 0 || *params > ctx->Const.MaxShininess) {
         _mesa_compile_error(ctx, GL_INVALID_VALUE, "glMaterial(shininess)");
      }
      else {
         MAT(VBO_ATTRIB_MAT_FRONT_SHININESS, 1, face, params);
      }
      break;
   case GL_COLOR_INDEXES:
      MAT(VBO_ATTRIB_MAT_FRONT_INDEXES, 3, face, params);
      break;
   case GL_AMBIENT_AND_DIFFUSE:
      MAT(VBO_ATTRIB_MAT_FRONT_AMBIENT, 4, face, params);
      MAT(VBO_ATTRIB_MAT_FRONT_DIFFUSE, 4, face, params);
      break;
   default:
      _mesa_compile_error(ctx, GL_INVALID_ENUM, "glMaterial(pname)");
      return;
   }
}


/* Cope with EvalCoord/CallList called within a begin/end object:
 *     -- Flush current buffer
 *     -- Fallback to opcodes for the rest of the begin/end object.
 */
static void
dlist_fallback(struct gl_context *ctx)
{
   struct vbo_save_context *save = &vbo_context(ctx)->save;

   if (save->vert_count || save->prim_count) {
      if (save->prim_count > 0) {
         /* Close off in-progress primitive. */
         GLint i = save->prim_count - 1;
         save->prim[i].count = save->vert_count - save->prim[i].start;
      }

      /* Need to replay this display list with loopback,
       * unfortunately, otherwise this primitive won't be handled
       * properly:
       */
      save->dangling_attr_ref = GL_TRUE;

      _save_compile_vertex_list(ctx);
   }

   _save_copy_to_current(ctx);
   _save_reset_vertex(ctx);
   _save_reset_counters(ctx);
   if (save->out_of_memory) {
      _mesa_install_save_vtxfmt(ctx, &save->vtxfmt_noop);
   }
   else {
      _mesa_install_save_vtxfmt(ctx, &ctx->ListState.ListVtxfmt);
   }
   ctx->Driver.SaveNeedFlush = GL_FALSE;
}


static void GLAPIENTRY
_save_EvalCoord1f(GLfloat u)
{
   GET_CURRENT_CONTEXT(ctx);
   dlist_fallback(ctx);
   CALL_EvalCoord1f(ctx->Save, (u));
}

static void GLAPIENTRY
_save_EvalCoord1fv(const GLfloat * v)
{
   GET_CURRENT_CONTEXT(ctx);
   dlist_fallback(ctx);
   CALL_EvalCoord1fv(ctx->Save, (v));
}

static void GLAPIENTRY
_save_EvalCoord2f(GLfloat u, GLfloat v)
{
   GET_CURRENT_CONTEXT(ctx);
   dlist_fallback(ctx);
   CALL_EvalCoord2f(ctx->Save, (u, v));
}

static void GLAPIENTRY
_save_EvalCoord2fv(const GLfloat * v)
{
   GET_CURRENT_CONTEXT(ctx);
   dlist_fallback(ctx);
   CALL_EvalCoord2fv(ctx->Save, (v));
}

static void GLAPIENTRY
_save_EvalPoint1(GLint i)
{
   GET_CURRENT_CONTEXT(ctx);
   dlist_fallback(ctx);
   CALL_EvalPoint1(ctx->Save, (i));
}

static void GLAPIENTRY
_save_EvalPoint2(GLint i, GLint j)
{
   GET_CURRENT_CONTEXT(ctx);
   dlist_fallback(ctx);
   CALL_EvalPoint2(ctx->Save, (i, j));
}

static void GLAPIENTRY
_save_CallList(GLuint l)
{
   GET_CURRENT_CONTEXT(ctx);
   dlist_fallback(ctx);
   CALL_CallList(ctx->Save, (l));
}

static void GLAPIENTRY
_save_CallLists(GLsizei n, GLenum type, const GLvoid * v)
{
   GET_CURRENT_CONTEXT(ctx);
   dlist_fallback(ctx);
   CALL_CallLists(ctx->Save, (n, type, v));
}



/**
 * Called via ctx->Driver.NotifySaveBegin() when a glBegin is getting
 * compiled into a display list.
 * Updating of ctx->Driver.CurrentSavePrimitive is already taken care of.
 */
GLboolean
vbo_save_NotifyBegin(struct gl_context *ctx, GLenum mode)
{
   struct vbo_save_context *save = &vbo_context(ctx)->save;
   const GLuint i = save->prim_count++;

   assert(i < save->prim_max);
   save->prim[i].mode = mode & VBO_SAVE_PRIM_MODE_MASK;
   save->prim[i].begin = 1;
   save->prim[i].end = 0;
   save->prim[i].weak = (mode & VBO_SAVE_PRIM_WEAK) ? 1 : 0;
   save->prim[i].no_current_update =
      (mode & VBO_SAVE_PRIM_NO_CURRENT_UPDATE) ? 1 : 0;
   save->prim[i].pad = 0;
   save->prim[i].start = save->vert_count;
   save->prim[i].count = 0;
   save->prim[i].num_instances = 1;
   save->prim[i].base_instance = 0;
   save->prim[i].is_indirect = 0;

   if (save->out_of_memory) {
      _mesa_install_save_vtxfmt(ctx, &save->vtxfmt_noop);
   }
   else {
      _mesa_install_save_vtxfmt(ctx, &save->vtxfmt);
   }

   /* We need to call SaveFlushVertices() if there's state change */
   ctx->Driver.SaveNeedFlush = GL_TRUE;

   /* GL_TRUE means we've handled this glBegin here; don't compile a BEGIN
    * opcode into the display list.
    */
   return GL_TRUE;
}


static void GLAPIENTRY
_save_End(void)
{
   GET_CURRENT_CONTEXT(ctx);
   struct vbo_save_context *save = &vbo_context(ctx)->save;
   const GLint i = save->prim_count - 1;

   ctx->Driver.CurrentSavePrimitive = PRIM_OUTSIDE_BEGIN_END;
   save->prim[i].end = 1;
   save->prim[i].count = (save->vert_count - save->prim[i].start);

   if (i == (GLint) save->prim_max - 1) {
      _save_compile_vertex_list(ctx);
      assert(save->copied.nr == 0);
   }

   /* Swap out this vertex format while outside begin/end.  Any color,
    * etc. received between here and the next begin will be compiled
    * as opcodes.
    */
   if (save->out_of_memory) {
      _mesa_install_save_vtxfmt(ctx, &save->vtxfmt_noop);
   }
   else {
      _mesa_install_save_vtxfmt(ctx, &ctx->ListState.ListVtxfmt);
   }
}


static void GLAPIENTRY
_save_Begin(GLenum mode)
{
   GET_CURRENT_CONTEXT(ctx);
   (void) mode;
   _mesa_compile_error(ctx, GL_INVALID_OPERATION, "Recursive glBegin");
}


static void GLAPIENTRY
_save_PrimitiveRestartNV(void)
{
   GLenum curPrim;
   GET_CURRENT_CONTEXT(ctx);

   curPrim = ctx->Driver.CurrentSavePrimitive;

   _save_End();
   _save_Begin(curPrim);
}


/* Unlike the functions above, these are to be hooked into the vtxfmt
 * maintained in ctx->ListState, active when the list is known or
 * suspected to be outside any begin/end primitive.
 * Note: OBE = Outside Begin/End
 */
static void GLAPIENTRY
_save_OBE_Rectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2)
{
   GET_CURRENT_CONTEXT(ctx);
   vbo_save_NotifyBegin(ctx, GL_QUADS | VBO_SAVE_PRIM_WEAK);
   CALL_Vertex2f(GET_DISPATCH(), (x1, y1));
   CALL_Vertex2f(GET_DISPATCH(), (x2, y1));
   CALL_Vertex2f(GET_DISPATCH(), (x2, y2));
   CALL_Vertex2f(GET_DISPATCH(), (x1, y2));
   CALL_End(GET_DISPATCH(), ());
}


static void GLAPIENTRY
_save_OBE_DrawArrays(GLenum mode, GLint start, GLsizei count)
{
   GET_CURRENT_CONTEXT(ctx);
   struct vbo_save_context *save = &vbo_context(ctx)->save;
   GLint i;

   if (!_mesa_is_valid_prim_mode(ctx, mode)) {
      _mesa_compile_error(ctx, GL_INVALID_ENUM, "glDrawArrays(mode)");
      return;
   }
   if (count < 0) {
      _mesa_compile_error(ctx, GL_INVALID_VALUE, "glDrawArrays(count<0)");
      return;
   }

   if (save->out_of_memory)
      return;

   _ae_map_vbos(ctx);

   vbo_save_NotifyBegin(ctx, (mode | VBO_SAVE_PRIM_WEAK
                              | VBO_SAVE_PRIM_NO_CURRENT_UPDATE));

   for (i = 0; i < count; i++)
      CALL_ArrayElement(GET_DISPATCH(), (start + i));
   CALL_End(GET_DISPATCH(), ());

   _ae_unmap_vbos(ctx);
}


/* Could do better by copying the arrays and element list intact and
 * then emitting an indexed prim at runtime.
 */
static void GLAPIENTRY
_save_OBE_DrawElements(GLenum mode, GLsizei count, GLenum type,
                       const GLvoid * indices)
{
   GET_CURRENT_CONTEXT(ctx);
   struct vbo_save_context *save = &vbo_context(ctx)->save;
   struct gl_buffer_object *indexbuf = ctx->Array.VAO->IndexBufferObj;
   GLint i;

   if (!_mesa_is_valid_prim_mode(ctx, mode)) {
      _mesa_compile_error(ctx, GL_INVALID_ENUM, "glDrawElements(mode)");
      return;
   }
   if (count < 0) {
      _mesa_compile_error(ctx, GL_INVALID_VALUE, "glDrawElements(count<0)");
      return;
   }
   if (type != GL_UNSIGNED_BYTE &&
       type != GL_UNSIGNED_SHORT &&
       type != GL_UNSIGNED_INT) {
      _mesa_compile_error(ctx, GL_INVALID_VALUE, "glDrawElements(count<0)");
      return;
   }

   if (save->out_of_memory)
      return;

   _ae_map_vbos(ctx);

   if (_mesa_is_bufferobj(indexbuf))
      indices =
         ADD_POINTERS(indexbuf->Mappings[MAP_INTERNAL].Pointer, indices);

   vbo_save_NotifyBegin(ctx, (mode | VBO_SAVE_PRIM_WEAK |
                              VBO_SAVE_PRIM_NO_CURRENT_UPDATE));

   switch (type) {
   case GL_UNSIGNED_BYTE:
      for (i = 0; i < count; i++)
         CALL_ArrayElement(GET_DISPATCH(), (((GLubyte *) indices)[i]));
      break;
   case GL_UNSIGNED_SHORT:
      for (i = 0; i < count; i++)
         CALL_ArrayElement(GET_DISPATCH(), (((GLushort *) indices)[i]));
      break;
   case GL_UNSIGNED_INT:
      for (i = 0; i < count; i++)
         CALL_ArrayElement(GET_DISPATCH(), (((GLuint *) indices)[i]));
      break;
   default:
      _mesa_error(ctx, GL_INVALID_ENUM, "glDrawElements(type)");
      break;
   }

   CALL_End(GET_DISPATCH(), ());

   _ae_unmap_vbos(ctx);
}


static void GLAPIENTRY
_save_OBE_DrawRangeElements(GLenum mode, GLuint start, GLuint end,
                            GLsizei count, GLenum type,
                            const GLvoid * indices)
{
   GET_CURRENT_CONTEXT(ctx);
   struct vbo_save_context *save = &vbo_context(ctx)->save;

   if (!_mesa_is_valid_prim_mode(ctx, mode)) {
      _mesa_compile_error(ctx, GL_INVALID_ENUM, "glDrawRangeElements(mode)");
      return;
   }
   if (count < 0) {
      _mesa_compile_error(ctx, GL_INVALID_VALUE,
                          "glDrawRangeElements(count<0)");
      return;
   }
   if (type != GL_UNSIGNED_BYTE &&
       type != GL_UNSIGNED_SHORT &&
       type != GL_UNSIGNED_INT) {
      _mesa_compile_error(ctx, GL_INVALID_ENUM, "glDrawRangeElements(type)");
      return;
   }
   if (end < start) {
      _mesa_compile_error(ctx, GL_INVALID_VALUE,
                          "glDrawRangeElements(end < start)");
      return;
   }

   if (save->out_of_memory)
      return;

   _save_OBE_DrawElements(mode, count, type, indices);
}


static void GLAPIENTRY
_save_OBE_MultiDrawElements(GLenum mode, const GLsizei *count, GLenum type,
                            const GLvoid * const *indices, GLsizei primcount)
{
   GLsizei i;

   for (i = 0; i < primcount; i++) {
      if (count[i] > 0) {
	 CALL_DrawElements(GET_DISPATCH(), (mode, count[i], type, indices[i]));
      }
   }
}


static void GLAPIENTRY
_save_OBE_MultiDrawElementsBaseVertex(GLenum mode, const GLsizei *count,
                                      GLenum type,
                                      const GLvoid * const *indices,
                                      GLsizei primcount,
                                      const GLint *basevertex)
{
   GLsizei i;

   for (i = 0; i < primcount; i++) {
      if (count[i] > 0) {
	 CALL_DrawElementsBaseVertex(GET_DISPATCH(), (mode, count[i], type,
						      indices[i],
						      basevertex[i]));
      }
   }
}


static void
_save_vtxfmt_init(struct gl_context *ctx)
{
   struct vbo_save_context *save = &vbo_context(ctx)->save;
   GLvertexformat *vfmt = &save->vtxfmt;

   vfmt->ArrayElement = _ae_ArrayElement;

   vfmt->Color3f = _save_Color3f;
   vfmt->Color3fv = _save_Color3fv;
   vfmt->Color4f = _save_Color4f;
   vfmt->Color4fv = _save_Color4fv;
   vfmt->EdgeFlag = _save_EdgeFlag;
   vfmt->End = _save_End;
   vfmt->PrimitiveRestartNV = _save_PrimitiveRestartNV;
   vfmt->FogCoordfEXT = _save_FogCoordfEXT;
   vfmt->FogCoordfvEXT = _save_FogCoordfvEXT;
   vfmt->Indexf = _save_Indexf;
   vfmt->Indexfv = _save_Indexfv;
   vfmt->Materialfv = _save_Materialfv;
   vfmt->MultiTexCoord1fARB = _save_MultiTexCoord1f;
   vfmt->MultiTexCoord1fvARB = _save_MultiTexCoord1fv;
   vfmt->MultiTexCoord2fARB = _save_MultiTexCoord2f;
   vfmt->MultiTexCoord2fvARB = _save_MultiTexCoord2fv;
   vfmt->MultiTexCoord3fARB = _save_MultiTexCoord3f;
   vfmt->MultiTexCoord3fvARB = _save_MultiTexCoord3fv;
   vfmt->MultiTexCoord4fARB = _save_MultiTexCoord4f;
   vfmt->MultiTexCoord4fvARB = _save_MultiTexCoord4fv;
   vfmt->Normal3f = _save_Normal3f;
   vfmt->Normal3fv = _save_Normal3fv;
   vfmt->SecondaryColor3fEXT = _save_SecondaryColor3fEXT;
   vfmt->SecondaryColor3fvEXT = _save_SecondaryColor3fvEXT;
   vfmt->TexCoord1f = _save_TexCoord1f;
   vfmt->TexCoord1fv = _save_TexCoord1fv;
   vfmt->TexCoord2f = _save_TexCoord2f;
   vfmt->TexCoord2fv = _save_TexCoord2fv;
   vfmt->TexCoord3f = _save_TexCoord3f;
   vfmt->TexCoord3fv = _save_TexCoord3fv;
   vfmt->TexCoord4f = _save_TexCoord4f;
   vfmt->TexCoord4fv = _save_TexCoord4fv;
   vfmt->Vertex2f = _save_Vertex2f;
   vfmt->Vertex2fv = _save_Vertex2fv;
   vfmt->Vertex3f = _save_Vertex3f;
   vfmt->Vertex3fv = _save_Vertex3fv;
   vfmt->Vertex4f = _save_Vertex4f;
   vfmt->Vertex4fv = _save_Vertex4fv;
   vfmt->VertexAttrib1fARB = _save_VertexAttrib1fARB;
   vfmt->VertexAttrib1fvARB = _save_VertexAttrib1fvARB;
   vfmt->VertexAttrib2fARB = _save_VertexAttrib2fARB;
   vfmt->VertexAttrib2fvARB = _save_VertexAttrib2fvARB;
   vfmt->VertexAttrib3fARB = _save_VertexAttrib3fARB;
   vfmt->VertexAttrib3fvARB = _save_VertexAttrib3fvARB;
   vfmt->VertexAttrib4fARB = _save_VertexAttrib4fARB;
   vfmt->VertexAttrib4fvARB = _save_VertexAttrib4fvARB;

   vfmt->VertexAttrib1fNV = _save_VertexAttrib1fNV;
   vfmt->VertexAttrib1fvNV = _save_VertexAttrib1fvNV;
   vfmt->VertexAttrib2fNV = _save_VertexAttrib2fNV;
   vfmt->VertexAttrib2fvNV = _save_VertexAttrib2fvNV;
   vfmt->VertexAttrib3fNV = _save_VertexAttrib3fNV;
   vfmt->VertexAttrib3fvNV = _save_VertexAttrib3fvNV;
   vfmt->VertexAttrib4fNV = _save_VertexAttrib4fNV;
   vfmt->VertexAttrib4fvNV = _save_VertexAttrib4fvNV;

   /* integer-valued */
   vfmt->VertexAttribI1i = _save_VertexAttribI1i;
   vfmt->VertexAttribI2i = _save_VertexAttribI2i;
   vfmt->VertexAttribI3i = _save_VertexAttribI3i;
   vfmt->VertexAttribI4i = _save_VertexAttribI4i;
   vfmt->VertexAttribI2iv = _save_VertexAttribI2iv;
   vfmt->VertexAttribI3iv = _save_VertexAttribI3iv;
   vfmt->VertexAttribI4iv = _save_VertexAttribI4iv;

   /* unsigned integer-valued */
   vfmt->VertexAttribI1ui = _save_VertexAttribI1ui;
   vfmt->VertexAttribI2ui = _save_VertexAttribI2ui;
   vfmt->VertexAttribI3ui = _save_VertexAttribI3ui;
   vfmt->VertexAttribI4ui = _save_VertexAttribI4ui;
   vfmt->VertexAttribI2uiv = _save_VertexAttribI2uiv;
   vfmt->VertexAttribI3uiv = _save_VertexAttribI3uiv;
   vfmt->VertexAttribI4uiv = _save_VertexAttribI4uiv;

   vfmt->VertexP2ui = _save_VertexP2ui;
   vfmt->VertexP3ui = _save_VertexP3ui;
   vfmt->VertexP4ui = _save_VertexP4ui;
   vfmt->VertexP2uiv = _save_VertexP2uiv;
   vfmt->VertexP3uiv = _save_VertexP3uiv;
   vfmt->VertexP4uiv = _save_VertexP4uiv;

   vfmt->TexCoordP1ui = _save_TexCoordP1ui;
   vfmt->TexCoordP2ui = _save_TexCoordP2ui;
   vfmt->TexCoordP3ui = _save_TexCoordP3ui;
   vfmt->TexCoordP4ui = _save_TexCoordP4ui;
   vfmt->TexCoordP1uiv = _save_TexCoordP1uiv;
   vfmt->TexCoordP2uiv = _save_TexCoordP2uiv;
   vfmt->TexCoordP3uiv = _save_TexCoordP3uiv;
   vfmt->TexCoordP4uiv = _save_TexCoordP4uiv;

   vfmt->MultiTexCoordP1ui = _save_MultiTexCoordP1ui;
   vfmt->MultiTexCoordP2ui = _save_MultiTexCoordP2ui;
   vfmt->MultiTexCoordP3ui = _save_MultiTexCoordP3ui;
   vfmt->MultiTexCoordP4ui = _save_MultiTexCoordP4ui;
   vfmt->MultiTexCoordP1uiv = _save_MultiTexCoordP1uiv;
   vfmt->MultiTexCoordP2uiv = _save_MultiTexCoordP2uiv;
   vfmt->MultiTexCoordP3uiv = _save_MultiTexCoordP3uiv;
   vfmt->MultiTexCoordP4uiv = _save_MultiTexCoordP4uiv;

   vfmt->NormalP3ui = _save_NormalP3ui;
   vfmt->NormalP3uiv = _save_NormalP3uiv;

   vfmt->ColorP3ui = _save_ColorP3ui;
   vfmt->ColorP4ui = _save_ColorP4ui;
   vfmt->ColorP3uiv = _save_ColorP3uiv;
   vfmt->ColorP4uiv = _save_ColorP4uiv;

   vfmt->SecondaryColorP3ui = _save_SecondaryColorP3ui;
   vfmt->SecondaryColorP3uiv = _save_SecondaryColorP3uiv;

   vfmt->VertexAttribP1ui = _save_VertexAttribP1ui;
   vfmt->VertexAttribP2ui = _save_VertexAttribP2ui;
   vfmt->VertexAttribP3ui = _save_VertexAttribP3ui;
   vfmt->VertexAttribP4ui = _save_VertexAttribP4ui;

   vfmt->VertexAttribP1uiv = _save_VertexAttribP1uiv;
   vfmt->VertexAttribP2uiv = _save_VertexAttribP2uiv;
   vfmt->VertexAttribP3uiv = _save_VertexAttribP3uiv;
   vfmt->VertexAttribP4uiv = _save_VertexAttribP4uiv;

   /* This will all require us to fallback to saving the list as opcodes:
    */
   vfmt->CallList = _save_CallList;
   vfmt->CallLists = _save_CallLists;

   vfmt->EvalCoord1f = _save_EvalCoord1f;
   vfmt->EvalCoord1fv = _save_EvalCoord1fv;
   vfmt->EvalCoord2f = _save_EvalCoord2f;
   vfmt->EvalCoord2fv = _save_EvalCoord2fv;
   vfmt->EvalPoint1 = _save_EvalPoint1;
   vfmt->EvalPoint2 = _save_EvalPoint2;

   /* These calls all generate GL_INVALID_OPERATION since this vtxfmt is
    * only used when we're inside a glBegin/End pair.
    */
   vfmt->Begin = _save_Begin;
}


/**
 * Initialize the dispatch table with the VBO functions for display
 * list compilation.
 */
void
vbo_initialize_save_dispatch(const struct gl_context *ctx,
                             struct _glapi_table *exec)
{
   SET_DrawArrays(exec, _save_OBE_DrawArrays);
   SET_DrawElements(exec, _save_OBE_DrawElements);
   SET_DrawRangeElements(exec, _save_OBE_DrawRangeElements);
   SET_MultiDrawElementsEXT(exec, _save_OBE_MultiDrawElements);
   SET_MultiDrawElementsBaseVertex(exec, _save_OBE_MultiDrawElementsBaseVertex);
   SET_Rectf(exec, _save_OBE_Rectf);
   /* Note: other glDraw functins aren't compiled into display lists */
}



void
vbo_save_SaveFlushVertices(struct gl_context *ctx)
{
   struct vbo_save_context *save = &vbo_context(ctx)->save;

   /* Noop when we are actually active:
    */
   if (ctx->Driver.CurrentSavePrimitive <= PRIM_MAX)
      return;

   if (save->vert_count || save->prim_count)
      _save_compile_vertex_list(ctx);

   _save_copy_to_current(ctx);
   _save_reset_vertex(ctx);
   _save_reset_counters(ctx);
   ctx->Driver.SaveNeedFlush = GL_FALSE;
}


void
vbo_save_NewList(struct gl_context *ctx, GLuint list, GLenum mode)
{
   struct vbo_save_context *save = &vbo_context(ctx)->save;

   (void) list;
   (void) mode;

   if (!save->prim_store)
      save->prim_store = alloc_prim_store(ctx);

   if (!save->vertex_store)
      save->vertex_store = alloc_vertex_store(ctx);

   save->buffer_ptr = vbo_save_map_vertex_store(ctx, save->vertex_store);

   _save_reset_vertex(ctx);
   _save_reset_counters(ctx);
   ctx->Driver.SaveNeedFlush = GL_FALSE;
}


void
vbo_save_EndList(struct gl_context *ctx)
{
   struct vbo_save_context *save = &vbo_context(ctx)->save;

   /* EndList called inside a (saved) Begin/End pair?
    */
   if (_mesa_inside_dlist_begin_end(ctx)) {
      if (save->prim_count > 0) {
         GLint i = save->prim_count - 1;
         ctx->Driver.CurrentSavePrimitive = PRIM_OUTSIDE_BEGIN_END;
         save->prim[i].end = 0;
         save->prim[i].count = save->vert_count - save->prim[i].start;
      }

      /* Make sure this vertex list gets replayed by the "loopback"
       * mechanism:
       */
      save->dangling_attr_ref = GL_TRUE;
      vbo_save_SaveFlushVertices(ctx);

      /* Swap out this vertex format while outside begin/end.  Any color,
       * etc. received between here and the next begin will be compiled
       * as opcodes.
       */
      _mesa_install_save_vtxfmt(ctx, &ctx->ListState.ListVtxfmt);
   }

   vbo_save_unmap_vertex_store(ctx, save->vertex_store);

   assert(save->vertex_size == 0);
}


void
vbo_save_BeginCallList(struct gl_context *ctx, struct gl_display_list *dlist)
{
   struct vbo_save_context *save = &vbo_context(ctx)->save;
   save->replay_flags |= dlist->Flags;
}


void
vbo_save_EndCallList(struct gl_context *ctx)
{
   struct vbo_save_context *save = &vbo_context(ctx)->save;

   if (ctx->ListState.CallDepth == 1) {
      /* This is correct: want to keep only the VBO_SAVE_FALLBACK
       * flag, if it is set:
       */
      save->replay_flags &= VBO_SAVE_FALLBACK;
   }
}


static void
vbo_destroy_vertex_list(struct gl_context *ctx, void *data)
{
   struct vbo_save_vertex_list *node = (struct vbo_save_vertex_list *) data;
   (void) ctx;

   if (--node->vertex_store->refcount == 0)
      free_vertex_store(ctx, node->vertex_store);

   if (--node->prim_store->refcount == 0)
      free(node->prim_store);

   free(node->current_data);
   node->current_data = NULL;
}


static void
vbo_print_vertex_list(struct gl_context *ctx, void *data)
{
   struct vbo_save_vertex_list *node = (struct vbo_save_vertex_list *) data;
   GLuint i;
   (void) ctx;

   printf("VBO-VERTEX-LIST, %u vertices %d primitives, %d vertsize\n",
          node->count, node->prim_count, node->vertex_size);

   for (i = 0; i < node->prim_count; i++) {
      struct _mesa_prim *prim = &node->prim[i];
      printf("   prim %d: %s%s %d..%d %s %s\n",
             i,
             _mesa_lookup_prim_by_nr(prim->mode),
             prim->weak ? " (weak)" : "",
             prim->start,
             prim->start + prim->count,
             (prim->begin) ? "BEGIN" : "(wrap)",
             (prim->end) ? "END" : "(wrap)");
   }
}


/**
 * Called during context creation/init.
 */
static void
_save_current_init(struct gl_context *ctx)
{
   struct vbo_save_context *save = &vbo_context(ctx)->save;
   GLint i;

   for (i = VBO_ATTRIB_POS; i <= VBO_ATTRIB_GENERIC15; i++) {
      const GLuint j = i - VBO_ATTRIB_POS;
      ASSERT(j < VERT_ATTRIB_MAX);
      save->currentsz[i] = &ctx->ListState.ActiveAttribSize[j];
      save->current[i] = ctx->ListState.CurrentAttrib[j];
   }

   for (i = VBO_ATTRIB_FIRST_MATERIAL; i <= VBO_ATTRIB_LAST_MATERIAL; i++) {
      const GLuint j = i - VBO_ATTRIB_FIRST_MATERIAL;
      ASSERT(j < MAT_ATTRIB_MAX);
      save->currentsz[i] = &ctx->ListState.ActiveMaterialSize[j];
      save->current[i] = ctx->ListState.CurrentMaterial[j];
   }
}


/**
 * Initialize the display list compiler.  Called during context creation.
 */
void
vbo_save_api_init(struct vbo_save_context *save)
{
   struct gl_context *ctx = save->ctx;
   GLuint i;

   save->opcode_vertex_list =
      _mesa_dlist_alloc_opcode(ctx,
                               sizeof(struct vbo_save_vertex_list),
                               vbo_save_playback_vertex_list,
                               vbo_destroy_vertex_list,
                               vbo_print_vertex_list);

   ctx->Driver.NotifySaveBegin = vbo_save_NotifyBegin;

   _save_vtxfmt_init(ctx);
   _save_current_init(ctx);
   _mesa_noop_vtxfmt_init(&save->vtxfmt_noop);

   /* These will actually get set again when binding/drawing */
   for (i = 0; i < VBO_ATTRIB_MAX; i++)
      save->inputs[i] = &save->arrays[i];
}
@


1.10
log
@Merge Mesa 10.2.9
@
text
@@


1.9
log
@Remove the local workaround for alignment faults in the VBO code on
archs with strict 64 bit pointer alignment and use Brian Paul's fix
which has been committed upstream and should end up in future releases
of 10.4.x.
@
text
@d194 3
a196 1
   vertex_store->bufferobj = ctx->Driver.NewBufferObject(ctx, VBO_BUF_ID);
@


1.8
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d378 1
a378 1
      _mesa_dlist_alloc(ctx, save->opcode_vertex_list, sizeof(*node));
d382 3
@


1.7
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d194 1
a194 3
   vertex_store->bufferobj = ctx->Driver.NewBufferObject(ctx,
                                                         VBO_BUF_ID,
                                                         GL_ARRAY_BUFFER_ARB);
@


1.6
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
Copyright 2002-2008 Tungsten Graphics Inc., Cedar Park, Texas.
d21 1
a21 1
TUNGSTEN GRAPHICS AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
d30 1
a30 1
 *   Keith Whitwell <keith@@tungstengraphics.com>
d44 1
a44 1
 * End).  
d63 1
a63 1
 * these, compilation falls back to opcodes.  
d203 2
d242 5
d248 2
a249 1
   assert(!vertex_store->buffer);
d251 17
a267 7
      vertex_store->buffer =
         (GLfloat *) ctx->Driver.MapBufferRange(ctx, 0,
                                                vertex_store->bufferobj->Size,
                                                GL_MAP_WRITE_BIT,  /* not used */
                                                vertex_store->bufferobj);
      assert(vertex_store->buffer);
      return vertex_store->buffer + vertex_store->used;
d281 10
a290 1
      ctx->Driver.UnmapBuffer(ctx, vertex_store->bufferobj);
d319 2
a320 2
      save->max_vert = ((VBO_SAVE_BUFFER_SIZE - save->vertex_store->used) /
                        save->vertex_size);
d327 1
a327 1
   save->dangling_attr_ref = 0;
d440 1
a440 1
   /* Copy duplicated vertices 
d538 1
d545 1
a545 1
 * vertex_store struct.  
d634 1
a634 1
    * its size increased.  
d887 1
a887 1
      save->dangling_attr_ref = 1;
d994 1
d1123 1
d1146 1
a1146 1
   if (_mesa_is_bufferobj(ctx->Array.ArrayObj->ElementArrayBufferObj))
d1148 1
a1148 1
         ADD_POINTERS(ctx->Array.ArrayObj->ElementArrayBufferObj->Pointer, indices);
d1466 1
a1466 1
         save->prim[i].count = (save->vert_count - save->prim[i].start);
d1472 1
a1472 1
      save->dangling_attr_ref = 1;
@


1.5
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a76 2
#include "main/mfeatures.h"
#include "main/api_noop.h"
d83 1
a83 3


#if FEATURE_dlist
d184 1
d197 11
d209 4
a212 4
   ctx->Driver.BufferData(ctx,
                          GL_ARRAY_BUFFER_ARB,
                          VBO_SAVE_BUFFER_SIZE * sizeof(GLfloat),
                          NULL, GL_STATIC_DRAW_ARB, vertex_store->bufferobj);
d232 1
a232 1
   FREE(vertex_store);
d236 3
a238 3
static GLfloat *
map_vertex_store(struct gl_context *ctx,
                 struct vbo_save_vertex_store *vertex_store)
d242 13
a254 9
   vertex_store->buffer =
      (GLfloat *) ctx->Driver.MapBuffer(ctx,
                                        GL_ARRAY_BUFFER_ARB,   /* not used */
                                        GL_WRITE_ONLY,      /* not used */
                                        vertex_store->
                                        bufferobj);

   assert(vertex_store->buffer);
   return vertex_store->buffer + vertex_store->used;
d258 3
a260 3
static void
unmap_vertex_store(struct gl_context *ctx,
                   struct vbo_save_vertex_store *vertex_store)
d262 3
a264 1
   ctx->Driver.UnmapBuffer(ctx, GL_ARRAY_BUFFER_ARB, vertex_store->bufferobj);
d303 35
d361 1
d388 1
a388 1
         node->current_data = MALLOC(node->current_size * sizeof(GLfloat));
d417 2
d444 1
a444 1
      unmap_vertex_store(ctx, save->vertex_store);
d455 2
a456 1
      save->buffer_ptr = map_vertex_store(ctx, save->vertex_store);
d472 2
d510 1
d552 2
a553 1
         COPY_CLEAN_4V(save->current[i], save->attrsz[i], save->attrptr[i]);
d582 5
a586 1
/* Flush existing data, set new attrib size, replay copied vertices.
d643 1
a643 1
      GLfloat *data = save->copied.buffer;
d659 2
a660 1
                     COPY_CLEAN_4V(dest, oldsz, data);
d685 5
a701 1
      static GLfloat id[4] = { 0, 0, 0, 1 };
d703 1
d716 5
d746 1
a746 1
#define ATTR(A, N, V0, V1, V2, V3)				\
d759 1
d781 57
d867 7
a873 2
   _mesa_install_save_vtxfmt(ctx, &ctx->ListState.ListVtxfmt);
   ctx->Driver.SaveNeedFlush = 0;
d943 4
a946 2
/* This begin is hooked into ...  Updating of
 * ctx->Driver.CurrentSavePrimitive is already taken care of.
d952 1
a952 2

   GLuint i = save->prim_count++;
d965 11
d977 3
a979 2
   _mesa_install_save_vtxfmt(ctx, &save->vtxfmt);
   ctx->Driver.SaveNeedFlush = 1;
d989 1
a989 1
   GLint i = save->prim_count - 1;
d1004 6
a1009 113
   _mesa_install_save_vtxfmt(ctx, &ctx->ListState.ListVtxfmt);
}


/* These are all errors as this vtxfmt is only installed inside
 * begin/end pairs.
 */
static void GLAPIENTRY
_save_DrawElements(GLenum mode, GLsizei count, GLenum type,
                   const GLvoid * indices)
{
   GET_CURRENT_CONTEXT(ctx);
   (void) mode;
   (void) count;
   (void) type;
   (void) indices;
   _mesa_compile_error(ctx, GL_INVALID_OPERATION, "glDrawElements");
}


static void GLAPIENTRY
_save_DrawRangeElements(GLenum mode, GLuint start, GLuint end,
                        GLsizei count, GLenum type, const GLvoid * indices)
{
   GET_CURRENT_CONTEXT(ctx);
   (void) mode;
   (void) start;
   (void) end;
   (void) count;
   (void) type;
   (void) indices;
   _mesa_compile_error(ctx, GL_INVALID_OPERATION, "glDrawRangeElements");
}


static void GLAPIENTRY
_save_DrawElementsBaseVertex(GLenum mode, GLsizei count, GLenum type,
                             const GLvoid * indices, GLint basevertex)
{
   GET_CURRENT_CONTEXT(ctx);
   (void) mode;
   (void) count;
   (void) type;
   (void) indices;
   (void) basevertex;
   _mesa_compile_error(ctx, GL_INVALID_OPERATION, "glDrawElements");
}


static void GLAPIENTRY
_save_DrawRangeElementsBaseVertex(GLenum mode,
                                  GLuint start,
                                  GLuint end,
                                  GLsizei count,
                                  GLenum type,
                                  const GLvoid * indices, GLint basevertex)
{
   GET_CURRENT_CONTEXT(ctx);
   (void) mode;
   (void) start;
   (void) end;
   (void) count;
   (void) type;
   (void) indices;
   (void) basevertex;
   _mesa_compile_error(ctx, GL_INVALID_OPERATION, "glDrawRangeElements");
}


static void GLAPIENTRY
_save_DrawArrays(GLenum mode, GLint start, GLsizei count)
{
   GET_CURRENT_CONTEXT(ctx);
   (void) mode;
   (void) start;
   (void) count;
   _mesa_compile_error(ctx, GL_INVALID_OPERATION, "glDrawArrays");
}


static void GLAPIENTRY
_save_Rectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2)
{
   GET_CURRENT_CONTEXT(ctx);
   (void) x1;
   (void) y1;
   (void) x2;
   (void) y2;
   _mesa_compile_error(ctx, GL_INVALID_OPERATION, "glRectf");
}


static void GLAPIENTRY
_save_EvalMesh1(GLenum mode, GLint i1, GLint i2)
{
   GET_CURRENT_CONTEXT(ctx);
   (void) mode;
   (void) i1;
   (void) i2;
   _mesa_compile_error(ctx, GL_INVALID_OPERATION, "glEvalMesh1");
}


static void GLAPIENTRY
_save_EvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2)
{
   GET_CURRENT_CONTEXT(ctx);
   (void) mode;
   (void) i1;
   (void) i2;
   (void) j1;
   (void) j2;
   _mesa_compile_error(ctx, GL_INVALID_OPERATION, "glEvalMesh2");
d1038 1
d1057 1
d1060 10
a1069 1
   if (!_mesa_validate_DrawArrays(ctx, mode, start, count))
d1093 1
d1096 16
a1111 1
   if (!_mesa_validate_DrawElements(ctx, mode, count, type, indices, 0))
d1116 1
a1116 1
   if (_mesa_is_bufferobj(ctx->Array.ElementArrayBufferObj))
d1118 1
a1118 1
         ADD_POINTERS(ctx->Array.ElementArrayBufferObj->Pointer, indices);
d1153 59
a1211 3
   if (_mesa_validate_DrawRangeElements(ctx, mode,
                                        start, end, count, type, indices, 0)) {
      _save_OBE_DrawElements(mode, count, type, indices);
d1222 1
a1222 1
   _MESA_INIT_ARRAYELT_VTXFMT(vfmt, _ae_);
a1223 1
   vfmt->Begin = _save_Begin;
d1298 46
d1346 2
a1347 1
   _MESA_INIT_DLIST_VTXFMT(vfmt, _save_);       /* inside begin/end */
d1349 6
a1354 1
   _MESA_INIT_EVAL_VTXFMT(vfmt, _save_);
d1356 2
a1357 2
   /* These are all errors as we at least know we are in some sort of
    * begin/end pair:
a1359 9
   vfmt->Rectf = _save_Rectf;
   vfmt->DrawArrays = _save_DrawArrays;
   vfmt->DrawElements = _save_DrawElements;
   vfmt->DrawRangeElements = _save_DrawRangeElements;
   vfmt->DrawElementsBaseVertex = _save_DrawElementsBaseVertex;
   vfmt->DrawRangeElementsBaseVertex = _save_DrawRangeElementsBaseVertex;
   /* Loops back into vfmt->DrawElements */
   vfmt->MultiDrawElementsEXT = _mesa_noop_MultiDrawElements;
   vfmt->MultiDrawElementsBaseVertex = _mesa_noop_MultiDrawElementsBaseVertex;
d1363 19
d1389 1
a1389 2
   if (ctx->Driver.CurrentSavePrimitive == PRIM_INSIDE_UNKNOWN_PRIM ||
       ctx->Driver.CurrentSavePrimitive <= GL_POLYGON)
d1398 1
a1398 1
   ctx->Driver.SaveNeedFlush = 0;
d1416 1
a1416 1
   save->buffer_ptr = map_vertex_store(ctx, save->vertex_store);
d1420 1
a1420 1
   ctx->Driver.SaveNeedFlush = 0;
d1431 1
a1431 2
   if (ctx->Driver.CurrentSavePrimitive != PRIM_OUTSIDE_BEGIN_END) {

d1452 1
a1452 1
   unmap_vertex_store(ctx, save->vertex_store);
d1490 1
a1490 1
      FREE(node->prim_store);
d1492 2
a1493 4
   if (node->current_data) {
      FREE(node->current_data);
      node->current_data = NULL;
   }
d1509 8
a1516 8
      _mesa_debug(NULL, "   prim %d: %s%s %d..%d %s %s\n",
                  i,
                  _mesa_lookup_prim_by_nr(prim->mode),
                  prim->weak ? " (weak)" : "",
                  prim->start,
                  prim->start + prim->count,
                  (prim->begin) ? "BEGIN" : "(wrap)",
                  (prim->end) ? "END" : "(wrap)");
d1521 3
d1547 1
a1547 1
 * Initialize the display list compiler
d1566 1
a1570 14

   /* Hook our array functions into the outside-begin-end vtxfmt in 
    * ctx->ListState.
    */
   ctx->ListState.ListVtxfmt.Rectf = _save_OBE_Rectf;
   ctx->ListState.ListVtxfmt.DrawArrays = _save_OBE_DrawArrays;
   ctx->ListState.ListVtxfmt.DrawElements = _save_OBE_DrawElements;
   ctx->ListState.ListVtxfmt.DrawRangeElements = _save_OBE_DrawRangeElements;
   /* loops back into _save_OBE_DrawElements */
   ctx->ListState.ListVtxfmt.MultiDrawElementsEXT =
      _mesa_noop_MultiDrawElements;
   ctx->ListState.ListVtxfmt.MultiDrawElementsBaseVertex =
      _mesa_noop_MultiDrawElementsBaseVertex;
   _mesa_install_save_vtxfmt(ctx, &ctx->ListState.ListVtxfmt);
a1571 3


#endif /* FEATURE_dlist */
@


1.4
log
@Merge Mesa 7.10.3
@
text
@d77 1
d103 4
a106 3
static GLuint _save_copy_vertices( struct gl_context *ctx, 
				   const struct vbo_save_vertex_list *node,
				   const GLfloat *src_buffer)
d108 2
a109 2
   struct vbo_save_context *save = &vbo_context( ctx )->save;
   const struct _mesa_prim *prim = &node->prim[node->prim_count-1];
d118 2
a119 3
	 
   switch( prim->mode )
   {
d123 4
a126 3
      ovf = nr&1;
      for (i = 0 ; i < ovf ; i++)
	 memcpy( dst+i*sz, src+(nr-ovf+i)*sz, sz*sizeof(GLfloat) );
d129 4
a132 3
      ovf = nr%3;
      for (i = 0 ; i < ovf ; i++)
	 memcpy( dst+i*sz, src+(nr-ovf+i)*sz, sz*sizeof(GLfloat) );
d135 4
a138 3
      ovf = nr&3;
      for (i = 0 ; i < ovf ; i++)
	 memcpy( dst+i*sz, src+(nr-ovf+i)*sz, sz*sizeof(GLfloat) );
d141 2
a142 2
      if (nr == 0) 
	 return 0;
d144 2
a145 2
	 memcpy( dst, src+(nr-1)*sz, sz*sizeof(GLfloat) );
	 return 1;
d150 2
a151 2
      if (nr == 0) 
	 return 0;
d153 7
a159 6
	 memcpy( dst, src+0, sz*sizeof(GLfloat) );
	 return 1;
      } else {
	 memcpy( dst, src+0, sz*sizeof(GLfloat) );
	 memcpy( dst+sz, src+(nr-1)*sz, sz*sizeof(GLfloat) );
	 return 2;
d164 9
a172 3
      case 0: ovf = 0; break;
      case 1: ovf = 1; break;
      default: ovf = 2 + (nr&1); break;
d174 3
a176 2
      for (i = 0 ; i < ovf ; i++)
	 memcpy( dst+i*sz, src+(nr-ovf+i)*sz, sz*sizeof(GLfloat) );
d185 2
a186 1
static struct vbo_save_vertex_store *alloc_vertex_store( struct gl_context *ctx )
d188 2
a189 1
   struct vbo_save_vertex_store *vertex_store = CALLOC_STRUCT(vbo_save_vertex_store);
d201 4
a204 6
   ctx->Driver.BufferData( ctx, 
			   GL_ARRAY_BUFFER_ARB, 
			   VBO_SAVE_BUFFER_SIZE * sizeof(GLfloat),
			   NULL,
			   GL_STATIC_DRAW_ARB,
			   vertex_store->bufferobj);
d213 4
a216 1
static void free_vertex_store( struct gl_context *ctx, struct vbo_save_vertex_store *vertex_store )
d224 1
a224 1
   FREE( vertex_store );
d227 4
a230 1
static GLfloat *map_vertex_store( struct gl_context *ctx, struct vbo_save_vertex_store *vertex_store )
d234 6
a239 4
   vertex_store->buffer = (GLfloat *)ctx->Driver.MapBuffer(ctx, 
							   GL_ARRAY_BUFFER_ARB,	/* not used */
							   GL_WRITE_ONLY, /* not used */
							   vertex_store->bufferobj); 
d245 4
a248 1
static void unmap_vertex_store( struct gl_context *ctx, struct vbo_save_vertex_store *vertex_store )
d250 1
a250 1
   ctx->Driver.UnmapBuffer( ctx, GL_ARRAY_BUFFER_ARB, vertex_store->bufferobj );
d255 2
a256 1
static struct vbo_save_primitive_store *alloc_prim_store( struct gl_context *ctx )
d258 2
a259 1
   struct vbo_save_primitive_store *store = CALLOC_STRUCT(vbo_save_primitive_store);
d266 3
a268 1
static void _save_reset_counters( struct gl_context *ctx )
d273 1
a273 2
   save->buffer = (save->vertex_store->buffer + 
		   save->vertex_store->used);
d278 2
a279 2
      save->max_vert = ((VBO_SAVE_BUFFER_SIZE - save->vertex_store->used) / 
			 save->vertex_size);
d290 2
a291 1
/* Insert the active immediate struct onto the display list currently
d294 2
a295 1
static void _save_compile_vertex_list( struct gl_context *ctx )
d313 2
a314 1
   node->buffer_offset = (save->buffer - save->vertex_store->buffer) * sizeof(GLfloat); 
d326 7
d334 18
a351 19
   node->current_size = node->vertex_size - node->attrsz[0];
   node->current_data = NULL;

   if (node->current_size) {
      /* If the malloc fails, we just pull the data out of the VBO
       * later instead.
       */
      node->current_data = MALLOC( node->current_size * sizeof(GLfloat) );
      if (node->current_data) {
         const char *buffer = (const char *)save->vertex_store->buffer;
         unsigned attr_offset = node->attrsz[0] * sizeof(GLfloat);
         unsigned vertex_offset = 0;

         if (node->count)
            vertex_offset = (node->count-1) * node->vertex_size * sizeof(GLfloat);

         memcpy( node->current_data,
                 buffer + node->buffer_offset + vertex_offset + attr_offset,
                 node->current_size * sizeof(GLfloat) );
d355 1
a355 4


   assert(node->attrsz[VBO_ATTRIB_POS] != 0 ||
	  node->count == 0);
a362 1

d365 1
a365 2
   save->copied.nr = _save_copy_vertices( ctx, node, save->buffer );

d374 6
a379 8
      vbo_loopback_vertex_list( ctx,
				(const GLfloat *)((const char *)save->vertex_store->buffer + 
						  node->buffer_offset),
				node->attrsz,
				node->prim,
				node->prim_count,
				node->wrap_count,
				node->vertex_size);
a383 1

d387 1
a387 1
   if (save->vertex_store->used > 
d392 1
a392 1
      unmap_vertex_store( ctx, save->vertex_store );
d396 1
a396 1
      save->vertex_store->refcount--; 
d402 3
a404 3
      save->vertex_store = alloc_vertex_store( ctx );
      save->buffer_ptr = map_vertex_store( ctx, save->vertex_store );
   } 
d407 1
a407 1
      save->prim_store->refcount--; 
d409 2
a410 2
      save->prim_store = alloc_prim_store( ctx );
   } 
d414 1
a414 1
   _save_reset_counters( ctx );
d418 2
a419 2
/* TODO -- If no new vertices have been stored, don't bother saving
 * it.
d421 2
a422 1
static void _save_wrap_buffers( struct gl_context *ctx )
d428 1
d435 1
a435 2
   save->prim[i].count = (save->vert_count - 
			  save->prim[i].start);
d438 2
a439 1
   
d442 1
a442 1
   _save_compile_vertex_list( ctx );
d448 1
d459 2
a460 2

/* Called only when buffers are wrapped as the result of filling the
d463 2
a464 1
static void _save_wrap_filled_vertex( struct gl_context *ctx )
d472 3
a474 3
   _save_wrap_buffers( ctx );
   
    /* Copy stored stored vertices to start of new list.
d478 2
a479 2
   for (i = 0 ; i < save->copied.nr ; i++) {
      memcpy( save->buffer_ptr, data, save->vertex_size * sizeof(GLfloat));
d487 2
a488 1
static void _save_copy_to_current( struct gl_context *ctx )
d490 1
a490 1
   struct vbo_save_context *save = &vbo_context(ctx)->save; 
d493 1
a493 1
   for (i = VBO_ATTRIB_POS+1 ; i < VBO_ATTRIB_MAX ; i++) {
d495 2
a496 4
	 save->currentsz[i][0] = save->attrsz[i];
	 COPY_CLEAN_4V(save->current[i], 
		       save->attrsz[i], 
		       save->attrptr[i]);
d502 2
a503 1
static void _save_copy_from_current( struct gl_context *ctx )
d505 1
a505 1
   struct vbo_save_context *save = &vbo_context(ctx)->save; 
d508 1
a508 1
   for (i = VBO_ATTRIB_POS+1 ; i < VBO_ATTRIB_MAX ; i++) {
d510 10
a519 5
      case 4: save->attrptr[i][3] = save->current[i][3];
      case 3: save->attrptr[i][2] = save->current[i][2];
      case 2: save->attrptr[i][1] = save->current[i][1];
      case 1: save->attrptr[i][0] = save->current[i][0];
      case 0: break;
a524 2


d526 3
a528 4
 */ 
static void _save_upgrade_vertex( struct gl_context *ctx, 
				 GLuint attr,
				 GLuint newsz )
d538 2
a539 2
   if (save->vert_count) 
      _save_wrap_buffers( ctx );
d541 1
a541 1
      assert( save->copied.nr == 0 );
d547 1
a547 1
   _save_copy_to_current( ctx );
d555 2
a556 2
   save->max_vert = ((VBO_SAVE_BUFFER_SIZE - save->vertex_store->used) / 
		      save->vertex_size);
d561 1
a561 1
   for (i = 0, tmp = save->vertex ; i < VBO_ATTRIB_MAX ; i++) {
d563 5
a567 2
	 save->attrptr[i] = tmp;
	 tmp += save->attrsz[i];
a568 2
      else 
	 save->attrptr[i] = NULL; /* will not be dereferenced. */
d573 1
a573 1
   _save_copy_from_current( ctx );
d581 1
a581 2
   if (save->copied.nr)
   {
d589 2
a590 2
	 assert(oldsz == 0);
	 save->dangling_attr_ref = GL_TRUE;
d593 22
a614 22
      for (i = 0 ; i < save->copied.nr ; i++) {
	 for (j = 0 ; j < VBO_ATTRIB_MAX ; j++) {
	    if (save->attrsz[j]) {
	       if (j == attr) {
		  if (oldsz) {
		     COPY_CLEAN_4V( dest, oldsz, data );
		     data += oldsz;
		     dest += newsz;
		  }
		  else {
		     COPY_SZ_4V( dest, newsz, save->current[attr] );
		     dest += newsz;
		  }
	       }
	       else {
		  GLint sz = save->attrsz[j];
		  COPY_SZ_4V( dest, sz, data );
		  data += sz;
		  dest += sz;
	       }
	    }
	 }
d622 3
a624 1
static void save_fixup_vertex( struct gl_context *ctx, GLuint attr, GLuint sz )
d626 1
a626 1
   struct vbo_save_context *save = &vbo_context(ctx)->save; 
d632 1
a632 1
      _save_upgrade_vertex( ctx, attr, sz );
d641 2
a642 2
      for (i = sz ; i <= save->attrsz[attr] ; i++)
	 save->attrptr[attr][i-1] = id[i-1];
d648 3
a650 1
static void _save_reset_vertex( struct gl_context *ctx )
d655 1
a655 1
   for (i = 0 ; i < VBO_ATTRIB_MAX ; i++) {
d659 1
a659 1
      
d665 1
a665 1
#define ERROR()   _mesa_compile_error( ctx, GL_INVALID_ENUM, __FUNCTION__ );
d674 1
a674 1
#define ATTR( A, N, V0, V1, V2, V3 )				\
d678 1
a678 1
   if (save->active_sz[A] != N)				\
d682 1
a682 1
      GLfloat *dest = save->attrptr[A];			\
d695 1
a695 1
      save->buffer_ptr += save->vertex_size;				\
d698 1
a698 1
	 _save_wrap_filled_vertex( ctx );			\
d713 2
a714 1
static void DO_FALLBACK( struct gl_context *ctx )
d730 2
a731 2
      
      _save_compile_vertex_list( ctx );
d734 4
a737 4
   _save_copy_to_current( ctx );
   _save_reset_vertex( ctx );
   _save_reset_counters( ctx );
   _mesa_install_save_vtxfmt( ctx, &ctx->ListState.ListVtxfmt );
d741 3
a743 1
static void GLAPIENTRY _save_EvalCoord1f( GLfloat u )
d746 1
a746 1
   DO_FALLBACK(ctx);
d750 2
a751 1
static void GLAPIENTRY _save_EvalCoord1fv( const GLfloat *v )
d754 1
a754 1
   DO_FALLBACK(ctx);
d758 2
a759 1
static void GLAPIENTRY _save_EvalCoord2f( GLfloat u, GLfloat v )
d762 1
a762 1
   DO_FALLBACK(ctx);
d766 2
a767 1
static void GLAPIENTRY _save_EvalCoord2fv( const GLfloat *v )
d770 1
a770 1
   DO_FALLBACK(ctx);
d774 2
a775 1
static void GLAPIENTRY _save_EvalPoint1( GLint i )
d778 1
a778 1
   DO_FALLBACK(ctx);
d782 2
a783 1
static void GLAPIENTRY _save_EvalPoint2( GLint i, GLint j )
d786 1
a786 1
   DO_FALLBACK(ctx);
d790 2
a791 1
static void GLAPIENTRY _save_CallList( GLuint l )
d794 1
a794 1
   DO_FALLBACK(ctx);
d798 2
a799 1
static void GLAPIENTRY _save_CallLists( GLsizei n, GLenum type, const GLvoid *v )
d802 1
a802 1
   DO_FALLBACK(ctx);
a807 1

d811 2
a812 1
GLboolean vbo_save_NotifyBegin( struct gl_context *ctx, GLenum mode )
d814 1
a814 1
   struct vbo_save_context *save = &vbo_context(ctx)->save; 
d819 1
a819 1
   save->prim[i].mode = mode & ~VBO_SAVE_PRIM_WEAK;
d823 2
d827 2
a828 2
   save->prim[i].count = 0;   
   save->prim[i].num_instances = 1;   
d830 1
a830 1
   _mesa_install_save_vtxfmt( ctx, &save->vtxfmt );      
d836 2
a837 2

static void GLAPIENTRY _save_End( void )
d839 2
a840 2
   GET_CURRENT_CONTEXT( ctx ); 
   struct vbo_save_context *save = &vbo_context(ctx)->save; 
d845 1
a845 2
   save->prim[i].count = (save->vert_count - 
			  save->prim[i].start);
d848 1
a848 1
      _save_compile_vertex_list( ctx );
d855 2
a856 2
    */   
   _mesa_install_save_vtxfmt( ctx, &ctx->ListState.ListVtxfmt );
d863 3
a865 2
static void GLAPIENTRY _save_DrawElements(GLenum mode, GLsizei count, GLenum type,
			       const GLvoid *indices)
d868 5
a872 2
   (void) mode; (void) count; (void) type; (void) indices;
   _mesa_compile_error( ctx, GL_INVALID_OPERATION, "glDrawElements" );
d876 3
a878 4
static void GLAPIENTRY _save_DrawRangeElements(GLenum mode,
				    GLuint start, GLuint end,
				    GLsizei count, GLenum type,
				    const GLvoid *indices)
d881 7
a887 2
   (void) mode; (void) start; (void) end; (void) count; (void) type; (void) indices;
   _mesa_compile_error( ctx, GL_INVALID_OPERATION, "glDrawRangeElements" );
d890 4
a893 5
static void GLAPIENTRY _save_DrawElementsBaseVertex(GLenum mode,
						    GLsizei count,
						    GLenum type,
						    const GLvoid *indices,
						    GLint basevertex)
d896 7
a902 1
   (void) mode; (void) count; (void) type; (void) indices; (void)basevertex;
a903 2
   _mesa_compile_error( ctx, GL_INVALID_OPERATION, "glDrawElements" );
}
d905 7
a911 7
static void GLAPIENTRY _save_DrawRangeElementsBaseVertex(GLenum mode,
							 GLuint start,
							 GLuint end,
							 GLsizei count,
							 GLenum type,
							 const GLvoid *indices,
							 GLint basevertex)
d914 9
a922 2
   (void) mode; (void) start; (void) end; (void) count; (void) type;
   (void) indices; (void)basevertex;
a923 2
   _mesa_compile_error( ctx, GL_INVALID_OPERATION, "glDrawRangeElements" );
}
d925 2
a926 1
static void GLAPIENTRY _save_DrawArrays(GLenum mode, GLint start, GLsizei count)
d929 4
a932 2
   (void) mode; (void) start; (void) count;
   _mesa_compile_error( ctx, GL_INVALID_OPERATION, "glDrawArrays" );
d935 3
a937 1
static void GLAPIENTRY _save_Rectf( GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2 )
d940 5
a944 2
   (void) x1; (void) y1; (void) x2; (void) y2;
   _mesa_compile_error( ctx, GL_INVALID_OPERATION, "glRectf" );
d947 3
a949 1
static void GLAPIENTRY _save_EvalMesh1( GLenum mode, GLint i1, GLint i2 )
d952 4
a955 2
   (void) mode; (void) i1; (void) i2;
   _mesa_compile_error( ctx, GL_INVALID_OPERATION, "glEvalMesh1" );
d958 3
a960 2
static void GLAPIENTRY _save_EvalMesh2( GLenum mode, GLint i1, GLint i2,
				  GLint j1, GLint j2 )
d963 6
a968 2
   (void) mode; (void) i1; (void) i2; (void) j1; (void) j2;
   _mesa_compile_error( ctx, GL_INVALID_OPERATION, "glEvalMesh2" );
d971 3
a973 1
static void GLAPIENTRY _save_Begin( GLenum mode )
d975 1
a975 1
   GET_CURRENT_CONTEXT( ctx );
d977 1
a977 1
   _mesa_compile_error( ctx, GL_INVALID_OPERATION, "Recursive glBegin" );
d981 2
a982 1
static void GLAPIENTRY _save_PrimitiveRestartNV( void )
d985 1
a985 1
   GET_CURRENT_CONTEXT( ctx ); 
d998 2
a999 1
static void GLAPIENTRY _save_OBE_Rectf( GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2 )
d1002 5
a1006 5
   vbo_save_NotifyBegin( ctx, GL_QUADS | VBO_SAVE_PRIM_WEAK );
   CALL_Vertex2f(GET_DISPATCH(), ( x1, y1 ));
   CALL_Vertex2f(GET_DISPATCH(), ( x2, y1 ));
   CALL_Vertex2f(GET_DISPATCH(), ( x2, y2 ));
   CALL_Vertex2f(GET_DISPATCH(), ( x1, y2 ));
d1011 2
a1012 1
static void GLAPIENTRY _save_OBE_DrawArrays(GLenum mode, GLint start, GLsizei count)
d1017 1
a1017 1
   if (!_mesa_validate_DrawArrays( ctx, mode, start, count ))
d1020 1
a1020 1
   _ae_map_vbos( ctx );
d1022 2
a1023 1
   vbo_save_NotifyBegin( ctx, mode | VBO_SAVE_PRIM_WEAK );
d1026 1
a1026 1
       CALL_ArrayElement(GET_DISPATCH(), (start + i));
d1029 1
a1029 1
   _ae_unmap_vbos( ctx );
d1032 1
d1036 3
a1038 2
static void GLAPIENTRY _save_OBE_DrawElements(GLenum mode, GLsizei count, GLenum type,
				   const GLvoid *indices)
d1043 1
a1043 1
   if (!_mesa_validate_DrawElements( ctx, mode, count, type, indices, 0 ))
d1046 1
a1046 1
   _ae_map_vbos( ctx );
d1049 2
a1050 1
      indices = ADD_POINTERS(ctx->Array.ElementArrayBufferObj->Pointer, indices);
d1052 2
a1053 1
   vbo_save_NotifyBegin( ctx, mode | VBO_SAVE_PRIM_WEAK );
d1057 2
a1058 2
      for (i = 0 ; i < count ; i++)
	  CALL_ArrayElement(GET_DISPATCH(), ( ((GLubyte *)indices)[i] ));
d1061 2
a1062 2
      for (i = 0 ; i < count ; i++)
	  CALL_ArrayElement(GET_DISPATCH(), ( ((GLushort *)indices)[i] ));
d1065 2
a1066 2
      for (i = 0 ; i < count ; i++)
	  CALL_ArrayElement(GET_DISPATCH(), ( ((GLuint *)indices)[i] ));
d1069 1
a1069 1
      _mesa_error( ctx, GL_INVALID_ENUM, "glDrawElements(type)" );
d1075 1
a1075 1
   _ae_unmap_vbos( ctx );
d1078 5
a1082 4
static void GLAPIENTRY _save_OBE_DrawRangeElements(GLenum mode,
					GLuint start, GLuint end,
					GLsizei count, GLenum type,
					const GLvoid *indices)
d1085 4
a1088 4
   if (_mesa_validate_DrawRangeElements( ctx, mode,
					 start, end,
					 count, type, indices, 0 ))
      _save_OBE_DrawElements( mode, count, type, indices );
d1092 2
a1093 4



static void _save_vtxfmt_init( struct gl_context *ctx )
d1156 1
a1156 1
   
d1176 2
a1177 2
    */ 
   _MESA_INIT_DLIST_VTXFMT(vfmt, _save_); /* inside begin/end */
d1197 2
a1198 1
void vbo_save_SaveFlushVertices( struct gl_context *ctx )
d1208 6
a1213 7
   if (save->vert_count ||
       save->prim_count) 
      _save_compile_vertex_list( ctx );
   
   _save_copy_to_current( ctx );
   _save_reset_vertex( ctx );
   _save_reset_counters( ctx );  
d1217 3
a1219 1
void vbo_save_NewList( struct gl_context *ctx, GLuint list, GLenum mode )
d1223 2
a1224 1
   (void) list; (void) mode;
d1227 6
a1232 1
      save->prim_store = alloc_prim_store( ctx );
d1234 2
a1235 7
   if (!save->vertex_store) 
      save->vertex_store = alloc_vertex_store( ctx );
      
   save->buffer_ptr = map_vertex_store( ctx, save->vertex_store );
   
   _save_reset_vertex( ctx );
   _save_reset_counters( ctx );  
d1239 3
a1241 1
void vbo_save_EndList( struct gl_context *ctx )
d1253 1
a1253 2
         save->prim[i].count = (save->vert_count - 
                                save->prim[i].start);
d1260 1
a1260 1
      vbo_save_SaveFlushVertices( ctx );
d1265 2
a1266 2
       */   
      _mesa_install_save_vtxfmt( ctx, &ctx->ListState.ListVtxfmt );
d1269 1
a1269 1
   unmap_vertex_store( ctx, save->vertex_store );
d1273 4
a1276 2
 
void vbo_save_BeginCallList( struct gl_context *ctx, struct gl_display_list *dlist )
d1282 3
a1284 1
void vbo_save_EndCallList( struct gl_context *ctx )
d1287 1
a1287 1
   
d1297 2
a1298 1
static void vbo_destroy_vertex_list( struct gl_context *ctx, void *data )
d1300 1
a1300 1
   struct vbo_save_vertex_list *node = (struct vbo_save_vertex_list *)data;
d1303 2
a1304 2
   if ( --node->vertex_store->refcount == 0 ) 
      free_vertex_store( ctx, node->vertex_store );
d1306 2
a1307 2
   if ( --node->prim_store->refcount == 0 )
      FREE( node->prim_store );
d1316 2
a1317 1
static void vbo_print_vertex_list( struct gl_context *ctx, void *data )
d1319 1
a1319 1
   struct vbo_save_vertex_list *node = (struct vbo_save_vertex_list *)data;
d1324 1
a1324 3
	  node->count,
	  node->prim_count,
	  node->vertex_size);
d1326 1
a1326 1
   for (i = 0 ; i < node->prim_count ; i++) {
d1329 7
a1335 7
		  i, 
		  _mesa_lookup_prim_by_nr(prim->mode),
		  prim->weak ? " (weak)" : "",
		  prim->start, 
		  prim->start + prim->count,
		  (prim->begin) ? "BEGIN" : "(wrap)",
		  (prim->end) ? "END" : "(wrap)");
d1340 2
a1341 1
static void _save_current_init( struct gl_context *ctx ) 
d1361 1
d1365 2
a1366 1
void vbo_save_api_init( struct vbo_save_context *save )
d1372 5
a1376 5
      _mesa_dlist_alloc_opcode( ctx,
                                sizeof(struct vbo_save_vertex_list),
                                vbo_save_playback_vertex_list,
                                vbo_destroy_vertex_list,
                                vbo_print_vertex_list );
d1380 2
a1381 2
   _save_vtxfmt_init( ctx );
   _save_current_init( ctx );
d1395 5
a1399 3
   ctx->ListState.ListVtxfmt.MultiDrawElementsEXT = _mesa_noop_MultiDrawElements;
   ctx->ListState.ListVtxfmt.MultiDrawElementsBaseVertex = _mesa_noop_MultiDrawElementsBaseVertex;
   _mesa_install_save_vtxfmt( ctx, &ctx->ListState.ListVtxfmt );
@


1.3
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d86 3
d102 1
a102 1
static GLuint _save_copy_vertices( GLcontext *ctx, 
d173 1
a173 1
static struct vbo_save_vertex_store *alloc_vertex_store( GLcontext *ctx )
d201 1
a201 1
static void free_vertex_store( GLcontext *ctx, struct vbo_save_vertex_store *vertex_store )
d212 1
a212 1
static GLfloat *map_vertex_store( GLcontext *ctx, struct vbo_save_vertex_store *vertex_store )
d225 1
a225 1
static void unmap_vertex_store( GLcontext *ctx, struct vbo_save_vertex_store *vertex_store )
d232 1
a232 1
static struct vbo_save_primitive_store *alloc_prim_store( GLcontext *ctx )
d241 1
a241 1
static void _save_reset_counters( GLcontext *ctx )
d267 1
a267 1
static void _save_compile_vertex_list( GLcontext *ctx )
d394 1
a394 1
static void _save_wrap_buffers( GLcontext *ctx )
d424 1
d433 1
a433 1
static void _save_wrap_filled_vertex( GLcontext *ctx )
d456 1
a456 1
static void _save_copy_to_current( GLcontext *ctx )
d472 1
a472 1
static void _save_copy_from_current( GLcontext *ctx )
d493 1
a493 1
static void _save_upgrade_vertex( GLcontext *ctx, 
d589 1
a589 1
static void save_fixup_vertex( GLcontext *ctx, GLuint attr, GLuint sz )
d613 1
a613 1
static void _save_reset_vertex( GLcontext *ctx )
d676 1
a676 1
static void DO_FALLBACK( GLcontext *ctx )
d681 5
a685 6
      GLint i = save->prim_count - 1;

      /* Close off in-progress primitive.
       */
      save->prim[i].count = (save->vert_count - 
                             save->prim[i].start);
d707 1
a707 1
   ctx->Save->EvalCoord1f( u );
d714 1
a714 1
   ctx->Save->EvalCoord1fv( v );
d721 1
a721 1
   ctx->Save->EvalCoord2f( u, v );
d728 1
a728 1
   ctx->Save->EvalCoord2fv( v );
d735 1
a735 1
   ctx->Save->EvalPoint1( i );
d742 1
a742 1
   ctx->Save->EvalPoint2( i, j );
d749 1
a749 1
   ctx->Save->CallList( l );
d756 1
a756 1
   ctx->Save->CallLists( n, type, v );
d765 1
a765 1
GLboolean vbo_save_NotifyBegin( GLcontext *ctx, GLenum mode )
d779 1
d898 12
d1003 1
a1003 1
static void _save_vtxfmt_init( GLcontext *ctx )
d1017 1
d1067 18
d1107 1
a1107 1
void vbo_save_SaveFlushVertices( GLcontext *ctx )
d1127 1
a1127 1
void vbo_save_NewList( GLcontext *ctx, GLuint list, GLenum mode )
d1146 1
a1146 1
void vbo_save_EndList( GLcontext *ctx )
d1180 1
a1180 1
void vbo_save_BeginCallList( GLcontext *ctx, struct gl_display_list *dlist )
d1186 1
a1186 1
void vbo_save_EndCallList( GLcontext *ctx )
d1199 1
a1199 1
static void vbo_destroy_vertex_list( GLcontext *ctx, void *data )
d1217 1
a1217 1
static void vbo_print_vertex_list( GLcontext *ctx, void *data )
d1242 1
a1242 1
static void _save_current_init( GLcontext *ctx ) 
d1267 1
a1267 1
   GLcontext *ctx = save->ctx;
d1299 2
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d75 1
d77 1
d81 1
a81 1
#include "glapi/dispatch.h"
d121 1
a121 1
	 _mesa_memcpy( dst+i*sz, src+(nr-ovf+i)*sz, sz*sizeof(GLfloat) );
d126 1
a126 1
	 _mesa_memcpy( dst+i*sz, src+(nr-ovf+i)*sz, sz*sizeof(GLfloat) );
d131 1
a131 1
	 _mesa_memcpy( dst+i*sz, src+(nr-ovf+i)*sz, sz*sizeof(GLfloat) );
d137 1
a137 1
	 _mesa_memcpy( dst, src+(nr-1)*sz, sz*sizeof(GLfloat) );
d146 1
a146 1
	 _mesa_memcpy( dst, src+0, sz*sizeof(GLfloat) );
d149 2
a150 2
	 _mesa_memcpy( dst, src+0, sz*sizeof(GLfloat) );
	 _mesa_memcpy( dst+sz, src+(nr-1)*sz, sz*sizeof(GLfloat) );
d161 1
a161 1
	 _mesa_memcpy( dst+i*sz, src+(nr-ovf+i)*sz, sz*sizeof(GLfloat) );
d246 1
a246 1
   assert(save->buffer == save->vbptr);
d273 1
a273 1
      _mesa_alloc_instruction(ctx, save->opcode_vertex_list, sizeof(*node));
d280 1
a280 1
   _mesa_memcpy(node->attrsz, save->attrsz, sizeof(node->attrsz)); 
d294 25
d323 1
a323 1
      ctx->ListState.CurrentList->flags |= MESA_DLIST_DANGLING_REFS;
d373 1
a373 1
      save->vbptr = map_vertex_store( ctx, save->vertex_store );
d444 1
a444 1
      _mesa_memcpy( save->vbptr, data, save->vertex_size * sizeof(GLfloat));
d446 1
a446 1
      save->vbptr += save->vertex_size;
d580 1
a580 1
      save->vbptr = dest;
d652 1
a652 1
	 save->vbptr[i] = save->vertex[i];			\
d654 1
a654 1
      save->vbptr += save->vertex_size;				\
d672 27
a698 13
#define DO_FALLBACK(ctx) 							\
do {									\
   struct vbo_save_context *save = &vbo_context(ctx)->save;					\
									\
   if (save->vert_count || save->prim_count) 						\
      _save_compile_vertex_list( ctx );					\
									\
   _save_copy_to_current( ctx );					\
   _save_reset_vertex( ctx );						\
   _save_reset_counters( ctx );  \
   _mesa_install_save_vtxfmt( ctx, &ctx->ListState.ListVtxfmt );	\
   ctx->Driver.SaveNeedFlush = 0;					\
} while (0)
d830 27
d938 1
a938 1
   if (!_mesa_validate_DrawElements( ctx, mode, count, type, indices ))
d943 1
a943 1
   if (ctx->Array.ElementArrayBufferObj->Name)
d979 1
a979 1
					 count, type, indices ))
d992 2
a993 1
   vfmt->ArrayElement = _ae_loopback_array_elt;	        /* generic helper */
d1052 3
a1054 8
   vfmt->CallList = _save_CallList; /* inside begin/end */
   vfmt->CallLists = _save_CallLists; /* inside begin/end */
   vfmt->EvalCoord1f = _save_EvalCoord1f;
   vfmt->EvalCoord1fv = _save_EvalCoord1fv;
   vfmt->EvalCoord2f = _save_EvalCoord2f;
   vfmt->EvalCoord2fv = _save_EvalCoord2fv;
   vfmt->EvalPoint1 = _save_EvalPoint1;
   vfmt->EvalPoint2 = _save_EvalPoint2;
a1058 2
   vfmt->EvalMesh1 = _save_EvalMesh1;	
   vfmt->EvalMesh2 = _save_EvalMesh2;
d1064 5
a1068 1

d1104 1
a1104 1
   save->vbptr = map_vertex_store( ctx, save->vertex_store );
d1145 1
a1145 1
void vbo_save_BeginCallList( GLcontext *ctx, struct mesa_display_list *dlist )
d1148 1
a1148 1
   save->replay_flags |= dlist->flags;
d1174 5
d1188 4
a1191 4
   _mesa_debug(NULL, "VBO-VERTEX-LIST, %u vertices %d primitives, %d vertsize\n",
               node->count,
	       node->prim_count,
	       node->vertex_size);
d1197 1
a1197 1
		  _mesa_lookup_enum_by_nr(prim->mode),
d1236 5
a1240 5
      _mesa_alloc_opcode( ctx,
			  sizeof(struct vbo_save_vertex_list),
			  vbo_save_playback_vertex_list,
			  vbo_destroy_vertex_list,
			  vbo_print_vertex_list );
d1258 3
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
Copyright 2002 Tungsten Graphics Inc., Cedar Park, Texas.
d70 10
a79 9
#include "glheader.h"
#include "context.h"
#include "dlist.h"
#include "enums.h"
#include "macros.h"
#include "api_validate.h"
#include "api_arrayelt.h"
#include "vtxfmt.h"
#include "dispatch.h"
d89 4
d178 3
a180 1
   vertex_store->bufferobj = ctx->Driver.NewBufferObject(ctx, 1, GL_ARRAY_BUFFER_ARB);
d200 3
a202 2
   if (vertex_store->bufferobj)
      ctx->Driver.DeleteBuffer( ctx, vertex_store->bufferobj );
d875 3
d1048 26
d1176 1
@


1.1.1.1
log
@Mesa 7.0.1
@
text
@@


1.1.1.2
log
@Import Mesa 7.10.3
@
text
@d3 1
a3 1
Copyright 2002-2008 Tungsten Graphics Inc., Cedar Park, Texas.
d70 9
a78 12
#include "main/glheader.h"
#include "main/bufferobj.h"
#include "main/context.h"
#include "main/dlist.h"
#include "main/enums.h"
#include "main/eval.h"
#include "main/macros.h"
#include "main/api_noop.h"
#include "main/api_validate.h"
#include "main/api_arrayelt.h"
#include "main/vtxfmt.h"
#include "main/dispatch.h"
a82 3
#if FEATURE_dlist


a87 4
/* An interesting VBO number/name to help with debugging */
#define VBO_BUF_ID  12345


d92 1
a92 1
static GLuint _save_copy_vertices( struct gl_context *ctx, 
d114 1
a114 1
	 memcpy( dst+i*sz, src+(nr-ovf+i)*sz, sz*sizeof(GLfloat) );
d119 1
a119 1
	 memcpy( dst+i*sz, src+(nr-ovf+i)*sz, sz*sizeof(GLfloat) );
d124 1
a124 1
	 memcpy( dst+i*sz, src+(nr-ovf+i)*sz, sz*sizeof(GLfloat) );
d130 1
a130 1
	 memcpy( dst, src+(nr-1)*sz, sz*sizeof(GLfloat) );
d139 1
a139 1
	 memcpy( dst, src+0, sz*sizeof(GLfloat) );
d142 2
a143 2
	 memcpy( dst, src+0, sz*sizeof(GLfloat) );
	 memcpy( dst+sz, src+(nr-1)*sz, sz*sizeof(GLfloat) );
d154 1
a154 1
	 memcpy( dst+i*sz, src+(nr-ovf+i)*sz, sz*sizeof(GLfloat) );
d163 1
a163 1
static struct vbo_save_vertex_store *alloc_vertex_store( struct gl_context *ctx )
d173 1
a173 3
   vertex_store->bufferobj = ctx->Driver.NewBufferObject(ctx,
                                                         VBO_BUF_ID,
                                                         GL_ARRAY_BUFFER_ARB);
d189 1
a189 1
static void free_vertex_store( struct gl_context *ctx, struct vbo_save_vertex_store *vertex_store )
d193 2
a194 3
   if (vertex_store->bufferobj) {
      _mesa_reference_buffer_object(ctx, &vertex_store->bufferobj, NULL);
   }
d199 1
a199 1
static GLfloat *map_vertex_store( struct gl_context *ctx, struct vbo_save_vertex_store *vertex_store )
d212 1
a212 1
static void unmap_vertex_store( struct gl_context *ctx, struct vbo_save_vertex_store *vertex_store )
d219 1
a219 1
static struct vbo_save_primitive_store *alloc_prim_store( struct gl_context *ctx )
d228 1
a228 1
static void _save_reset_counters( struct gl_context *ctx )
d236 1
a236 1
   assert(save->buffer == save->buffer_ptr);
d254 1
a254 1
static void _save_compile_vertex_list( struct gl_context *ctx )
d263 1
a263 1
      _mesa_dlist_alloc(ctx, save->opcode_vertex_list, sizeof(*node));
d270 1
a270 1
   memcpy(node->attrsz, save->attrsz, sizeof(node->attrsz));
a283 25

   node->current_size = node->vertex_size - node->attrsz[0];
   node->current_data = NULL;

   if (node->current_size) {
      /* If the malloc fails, we just pull the data out of the VBO
       * later instead.
       */
      node->current_data = MALLOC( node->current_size * sizeof(GLfloat) );
      if (node->current_data) {
         const char *buffer = (const char *)save->vertex_store->buffer;
         unsigned attr_offset = node->attrsz[0] * sizeof(GLfloat);
         unsigned vertex_offset = 0;

         if (node->count)
            vertex_offset = (node->count-1) * node->vertex_size * sizeof(GLfloat);

         memcpy( node->current_data,
                 buffer + node->buffer_offset + vertex_offset + attr_offset,
                 node->current_size * sizeof(GLfloat) );
      }
   }



d288 1
a288 1
      ctx->ListState.CurrentList->Flags |= DLIST_DANGLING_REFS;
d338 1
a338 1
      save->buffer_ptr = map_vertex_store( ctx, save->vertex_store );
d356 1
a356 1
static void _save_wrap_buffers( struct gl_context *ctx )
a385 1
   save->prim[0].num_instances = 1;
d394 1
a394 1
static void _save_wrap_filled_vertex( struct gl_context *ctx )
d409 1
a409 1
      memcpy( save->buffer_ptr, data, save->vertex_size * sizeof(GLfloat));
d411 1
a411 1
      save->buffer_ptr += save->vertex_size;
d417 1
a417 1
static void _save_copy_to_current( struct gl_context *ctx )
d433 1
a433 1
static void _save_copy_from_current( struct gl_context *ctx )
d454 1
a454 1
static void _save_upgrade_vertex( struct gl_context *ctx, 
d545 1
a545 1
      save->buffer_ptr = dest;
d550 1
a550 1
static void save_fixup_vertex( struct gl_context *ctx, GLuint attr, GLuint sz )
d574 1
a574 1
static void _save_reset_vertex( struct gl_context *ctx )
d617 1
a617 1
	 save->buffer_ptr[i] = save->vertex[i];			\
d619 1
a619 1
      save->buffer_ptr += save->vertex_size;				\
d637 13
a649 26
static void DO_FALLBACK( struct gl_context *ctx )
{
   struct vbo_save_context *save = &vbo_context(ctx)->save;

   if (save->vert_count || save->prim_count) {
      if (save->prim_count > 0) {
         /* Close off in-progress primitive. */
         GLint i = save->prim_count - 1;
         save->prim[i].count = save->vert_count - save->prim[i].start;
      }

      /* Need to replay this display list with loopback,
       * unfortunately, otherwise this primitive won't be handled
       * properly:
       */
      save->dangling_attr_ref = 1;
      
      _save_compile_vertex_list( ctx );
   }

   _save_copy_to_current( ctx );
   _save_reset_vertex( ctx );
   _save_reset_counters( ctx );
   _mesa_install_save_vtxfmt( ctx, &ctx->ListState.ListVtxfmt );
   ctx->Driver.SaveNeedFlush = 0;
}
d655 1
a655 1
   CALL_EvalCoord1f(ctx->Save, (u));
d662 1
a662 1
   CALL_EvalCoord1fv(ctx->Save, (v));
d669 1
a669 1
   CALL_EvalCoord2f(ctx->Save, (u, v));
d676 1
a676 1
   CALL_EvalCoord2fv(ctx->Save, (v));
d683 1
a683 1
   CALL_EvalPoint1(ctx->Save, (i));
d690 1
a690 1
   CALL_EvalPoint2(ctx->Save, (i, j));
d697 1
a697 1
   CALL_CallList(ctx->Save, (l));
d704 1
a704 1
   CALL_CallLists(ctx->Save, (n, type, v));
d713 1
a713 1
GLboolean vbo_save_NotifyBegin( struct gl_context *ctx, GLenum mode )
a726 1
   save->prim[i].num_instances = 1;   
a780 27
static void GLAPIENTRY _save_DrawElementsBaseVertex(GLenum mode,
						    GLsizei count,
						    GLenum type,
						    const GLvoid *indices,
						    GLint basevertex)
{
   GET_CURRENT_CONTEXT(ctx);
   (void) mode; (void) count; (void) type; (void) indices; (void)basevertex;

   _mesa_compile_error( ctx, GL_INVALID_OPERATION, "glDrawElements" );
}

static void GLAPIENTRY _save_DrawRangeElementsBaseVertex(GLenum mode,
							 GLuint start,
							 GLuint end,
							 GLsizei count,
							 GLenum type,
							 const GLvoid *indices,
							 GLint basevertex)
{
   GET_CURRENT_CONTEXT(ctx);
   (void) mode; (void) start; (void) end; (void) count; (void) type;
   (void) indices; (void)basevertex;

   _mesa_compile_error( ctx, GL_INVALID_OPERATION, "glDrawRangeElements" );
}

a817 12
static void GLAPIENTRY _save_PrimitiveRestartNV( void )
{
   GLenum curPrim;
   GET_CURRENT_CONTEXT( ctx ); 

   curPrim = ctx->Driver.CurrentSavePrimitive;

   _save_End();
   _save_Begin(curPrim);
}


d862 1
a862 1
   if (!_mesa_validate_DrawElements( ctx, mode, count, type, indices, 0 ))
a866 3
   if (_mesa_is_bufferobj(ctx->Array.ElementArrayBufferObj))
      indices = ADD_POINTERS(ctx->Array.ElementArrayBufferObj->Pointer, indices);

d900 1
a900 1
					 count, type, indices, 0 ))
d908 1
a908 1
static void _save_vtxfmt_init( struct gl_context *ctx )
d913 1
a913 2
   _MESA_INIT_ARRAYELT_VTXFMT(vfmt, _ae_);

a920 1
   vfmt->PrimitiveRestartNV = _save_PrimitiveRestartNV;
a969 18
   /* integer-valued */
   vfmt->VertexAttribI1i = _save_VertexAttribI1i;
   vfmt->VertexAttribI2i = _save_VertexAttribI2i;
   vfmt->VertexAttribI3i = _save_VertexAttribI3i;
   vfmt->VertexAttribI4i = _save_VertexAttribI4i;
   vfmt->VertexAttribI2iv = _save_VertexAttribI2iv;
   vfmt->VertexAttribI3iv = _save_VertexAttribI3iv;
   vfmt->VertexAttribI4iv = _save_VertexAttribI4iv;

   /* unsigned integer-valued */
   vfmt->VertexAttribI1ui = _save_VertexAttribI1ui;
   vfmt->VertexAttribI2ui = _save_VertexAttribI2ui;
   vfmt->VertexAttribI3ui = _save_VertexAttribI3ui;
   vfmt->VertexAttribI4ui = _save_VertexAttribI4ui;
   vfmt->VertexAttribI2uiv = _save_VertexAttribI2uiv;
   vfmt->VertexAttribI3uiv = _save_VertexAttribI3uiv;
   vfmt->VertexAttribI4uiv = _save_VertexAttribI4uiv;

d972 8
a979 3
   _MESA_INIT_DLIST_VTXFMT(vfmt, _save_); /* inside begin/end */

   _MESA_INIT_EVAL_VTXFMT(vfmt, _save_);
d984 2
d991 1
a991 5
   vfmt->DrawElementsBaseVertex = _save_DrawElementsBaseVertex;
   vfmt->DrawRangeElementsBaseVertex = _save_DrawRangeElementsBaseVertex;
   /* Loops back into vfmt->DrawElements */
   vfmt->MultiDrawElementsEXT = _mesa_noop_MultiDrawElements;
   vfmt->MultiDrawElementsBaseVertex = _mesa_noop_MultiDrawElementsBaseVertex;
d995 1
a995 1
void vbo_save_SaveFlushVertices( struct gl_context *ctx )
d1015 1
a1015 1
void vbo_save_NewList( struct gl_context *ctx, GLuint list, GLenum mode )
d1027 1
a1027 1
   save->buffer_ptr = map_vertex_store( ctx, save->vertex_store );
d1034 1
a1034 1
void vbo_save_EndList( struct gl_context *ctx )
a1036 26

   /* EndList called inside a (saved) Begin/End pair?
    */
   if (ctx->Driver.CurrentSavePrimitive != PRIM_OUTSIDE_BEGIN_END) {

      if (save->prim_count > 0) {
         GLint i = save->prim_count - 1;
         ctx->Driver.CurrentSavePrimitive = PRIM_OUTSIDE_BEGIN_END;
         save->prim[i].end = 0;
         save->prim[i].count = (save->vert_count - 
                                save->prim[i].start);
      }

      /* Make sure this vertex list gets replayed by the "loopback"
       * mechanism:
       */
      save->dangling_attr_ref = 1;
      vbo_save_SaveFlushVertices( ctx );

      /* Swap out this vertex format while outside begin/end.  Any color,
       * etc. received between here and the next begin will be compiled
       * as opcodes.
       */   
      _mesa_install_save_vtxfmt( ctx, &ctx->ListState.ListVtxfmt );
   }

d1042 1
a1042 1
void vbo_save_BeginCallList( struct gl_context *ctx, struct gl_display_list *dlist )
d1045 1
a1045 1
   save->replay_flags |= dlist->Flags;
d1048 1
a1048 1
void vbo_save_EndCallList( struct gl_context *ctx )
d1061 1
a1061 1
static void vbo_destroy_vertex_list( struct gl_context *ctx, void *data )
a1070 5

   if (node->current_data) {
      FREE(node->current_data);
      node->current_data = NULL;
   }
d1074 1
a1074 1
static void vbo_print_vertex_list( struct gl_context *ctx, void *data )
d1080 4
a1083 4
   printf("VBO-VERTEX-LIST, %u vertices %d primitives, %d vertsize\n",
	  node->count,
	  node->prim_count,
	  node->vertex_size);
d1089 1
a1089 1
		  _mesa_lookup_prim_by_nr(prim->mode),
d1099 1
a1099 1
static void _save_current_init( struct gl_context *ctx ) 
d1124 1
a1124 1
   struct gl_context *ctx = save->ctx;
d1128 5
a1132 5
      _mesa_dlist_alloc_opcode( ctx,
                                sizeof(struct vbo_save_vertex_list),
                                vbo_save_playback_vertex_list,
                                vbo_destroy_vertex_list,
                                vbo_print_vertex_list );
a1138 1
   /* These will actually get set again when binding/drawing */
a1148 3
   /* loops back into _save_OBE_DrawElements */
   ctx->ListState.ListVtxfmt.MultiDrawElementsEXT = _mesa_noop_MultiDrawElements;
   ctx->ListState.ListVtxfmt.MultiDrawElementsBaseVertex = _mesa_noop_MultiDrawElementsBaseVertex;
a1151 2

#endif /* FEATURE_dlist */
@


1.1.1.3
log
@Import Mesa 9.2.0
@
text
@d77 1
d84 3
a86 1
#include "vbo_noop.h"
d102 3
a104 4
static GLuint
_save_copy_vertices(struct gl_context *ctx,
                    const struct vbo_save_vertex_list *node,
                    const GLfloat * src_buffer)
d106 2
a107 2
   struct vbo_save_context *save = &vbo_context(ctx)->save;
   const struct _mesa_prim *prim = &node->prim[node->prim_count - 1];
d116 3
a118 2

   switch (prim->mode) {
d122 3
a124 4
      ovf = nr & 1;
      for (i = 0; i < ovf; i++)
         memcpy(dst + i * sz, src + (nr - ovf + i) * sz,
                sz * sizeof(GLfloat));
d127 3
a129 4
      ovf = nr % 3;
      for (i = 0; i < ovf; i++)
         memcpy(dst + i * sz, src + (nr - ovf + i) * sz,
                sz * sizeof(GLfloat));
d132 3
a134 4
      ovf = nr & 3;
      for (i = 0; i < ovf; i++)
         memcpy(dst + i * sz, src + (nr - ovf + i) * sz,
                sz * sizeof(GLfloat));
d137 2
a138 2
      if (nr == 0)
         return 0;
d140 2
a141 2
         memcpy(dst, src + (nr - 1) * sz, sz * sizeof(GLfloat));
         return 1;
d146 2
a147 2
      if (nr == 0)
         return 0;
d149 6
a154 7
         memcpy(dst, src + 0, sz * sizeof(GLfloat));
         return 1;
      }
      else {
         memcpy(dst, src + 0, sz * sizeof(GLfloat));
         memcpy(dst + sz, src + (nr - 1) * sz, sz * sizeof(GLfloat));
         return 2;
d159 3
a161 9
      case 0:
         ovf = 0;
         break;
      case 1:
         ovf = 1;
         break;
      default:
         ovf = 2 + (nr & 1);
         break;
d163 2
a164 3
      for (i = 0; i < ovf; i++)
         memcpy(dst + i * sz, src + (nr - ovf + i) * sz,
                sz * sizeof(GLfloat));
d173 1
a173 2
static struct vbo_save_vertex_store *
alloc_vertex_store(struct gl_context *ctx)
d175 1
a175 3
   struct vbo_save_context *save = &vbo_context(ctx)->save;
   struct vbo_save_vertex_store *vertex_store =
      CALLOC_STRUCT(vbo_save_vertex_store);
a185 11
   if (vertex_store->bufferobj) {
      save->out_of_memory =
         !ctx->Driver.BufferData(ctx,
                                 GL_ARRAY_BUFFER_ARB,
                                 VBO_SAVE_BUFFER_SIZE * sizeof(GLfloat),
                                 NULL, GL_STATIC_DRAW_ARB,
                                 vertex_store->bufferobj);
   }
   else {
      save->out_of_memory = GL_TRUE;
   }
d187 6
a192 4
   if (save->out_of_memory) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "internal VBO allocation");
      _mesa_install_save_vtxfmt(ctx, &save->vtxfmt_noop);
   }
d201 1
a201 4

static void
free_vertex_store(struct gl_context *ctx,
                  struct vbo_save_vertex_store *vertex_store)
d209 1
a209 1
   free(vertex_store);
d212 1
a212 4

GLfloat *
vbo_save_map_vertex_store(struct gl_context *ctx,
                          struct vbo_save_vertex_store *vertex_store)
d216 7
a222 13
   if (vertex_store->bufferobj->Size > 0) {
      vertex_store->buffer =
         (GLfloat *) ctx->Driver.MapBufferRange(ctx, 0,
                                                vertex_store->bufferobj->Size,
                                                GL_MAP_WRITE_BIT,  /* not used */
                                                vertex_store->bufferobj);
      assert(vertex_store->buffer);
      return vertex_store->buffer + vertex_store->used;
   }
   else {
      /* probably ran out of memory for buffers */
      return NULL;
   }
d225 1
a225 4

void
vbo_save_unmap_vertex_store(struct gl_context *ctx,
                            struct vbo_save_vertex_store *vertex_store)
d227 1
a227 3
   if (vertex_store->bufferobj->Size > 0) {
      ctx->Driver.UnmapBuffer(ctx, vertex_store->bufferobj);
   }
d232 1
a232 2
static struct vbo_save_primitive_store *
alloc_prim_store(struct gl_context *ctx)
d234 1
a234 2
   struct vbo_save_primitive_store *store =
      CALLOC_STRUCT(vbo_save_primitive_store);
d241 1
a241 3

static void
_save_reset_counters(struct gl_context *ctx)
d246 2
a247 1
   save->buffer = save->vertex_store->buffer + save->vertex_store->used;
d252 2
a253 2
      save->max_vert = ((VBO_SAVE_BUFFER_SIZE - save->vertex_store->used) /
                        save->vertex_size);
a262 14
/**
 * For a list of prims, try merging prims that can just be extensions of the
 * previous prim.
 */
static void
merge_prims(struct gl_context *ctx,
            struct _mesa_prim *prim_list,
            GLuint *prim_count)
{
   GLuint i;
   struct _mesa_prim *prev_prim = prim_list;

   for (i = 1; i < *prim_count; i++) {
      struct _mesa_prim *this_prim = prim_list + i;
d264 1
a264 23
      vbo_try_prim_conversion(this_prim);

      if (vbo_can_merge_prims(prev_prim, this_prim)) {
         /* We've found a prim that just extend the previous one.  Tack it
          * onto the previous one, and let this primitive struct get dropped.
          */
         vbo_merge_prims(prev_prim, this_prim);
         continue;
      }

      /* If any previous primitives have been dropped, then we need to copy
       * this later one into the next available slot.
       */
      prev_prim++;
      if (prev_prim != this_prim)
         *prev_prim = *this_prim;
   }

   *prim_count = prev_prim - prim_list + 1;
}

/**
 * Insert the active immediate struct onto the display list currently
d267 1
a267 2
static void
_save_compile_vertex_list(struct gl_context *ctx)
a283 1
   memcpy(node->attrtype, save->attrtype, sizeof(node->attrtype));
d285 1
a285 2
   node->buffer_offset =
      (save->buffer - save->vertex_store->buffer) * sizeof(GLfloat);
a296 7
   if (node->prim[0].no_current_update) {
      node->current_size = 0;
      node->current_data = NULL;
   }
   else {
      node->current_size = node->vertex_size - node->attrsz[0];
      node->current_data = NULL;
d298 19
a316 18
      if (node->current_size) {
         /* If the malloc fails, we just pull the data out of the VBO
          * later instead.
          */
         node->current_data = malloc(node->current_size * sizeof(GLfloat));
         if (node->current_data) {
            const char *buffer = (const char *) save->vertex_store->buffer;
            unsigned attr_offset = node->attrsz[0] * sizeof(GLfloat);
            unsigned vertex_offset = 0;

            if (node->count)
               vertex_offset =
                  (node->count - 1) * node->vertex_size * sizeof(GLfloat);

            memcpy(node->current_data,
                   buffer + node->buffer_offset + vertex_offset + attr_offset,
                   node->current_size * sizeof(GLfloat));
         }
d320 4
a323 1
   assert(node->attrsz[VBO_ATTRIB_POS] != 0 || node->count == 0);
d331 1
d334 1
a334 1
   save->copied.nr = _save_copy_vertices(ctx, node, save->buffer);
a335 1
   merge_prims(ctx, node->prim, &node->prim_count);
d344 8
a351 6
      vbo_loopback_vertex_list(ctx,
                               (const GLfloat *) ((const char *) save->
                                                  vertex_store->buffer +
                                                  node->buffer_offset),
                               node->attrsz, node->prim, node->prim_count,
                               node->wrap_count, node->vertex_size);
d356 1
d360 1
a360 1
   if (save->vertex_store->used >
d365 1
a365 1
      vbo_save_unmap_vertex_store(ctx, save->vertex_store);
d369 1
a369 1
      save->vertex_store->refcount--;
d375 3
a377 4
      save->vertex_store = alloc_vertex_store(ctx);
      save->buffer_ptr = vbo_save_map_vertex_store(ctx, save->vertex_store);
      save->out_of_memory = save->buffer_ptr == NULL;
   }
d380 1
a380 1
      save->prim_store->refcount--;
d382 2
a383 2
      save->prim_store = alloc_prim_store(ctx);
   }
d387 1
a387 1
   _save_reset_counters(ctx);
d391 2
a392 4
/**
 * This is called when we fill a vertex buffer before we hit a glEnd().
 * We
 * TODO -- If no new vertices have been stored, don't bother saving it.
d394 1
a394 2
static void
_save_wrap_buffers(struct gl_context *ctx)
a399 1
   GLboolean no_current_update;
d406 2
a407 1
   save->prim[i].count = (save->vert_count - save->prim[i].start);
d410 1
a410 2
   no_current_update = save->prim[i].no_current_update;

d413 1
a413 1
   _save_compile_vertex_list(ctx);
a418 1
   save->prim[0].no_current_update = no_current_update;
a424 1
   save->prim[0].base_instance = 0;
d429 2
a430 2
/**
 * Called only when buffers are wrapped as the result of filling the
d433 1
a433 2
static void
_save_wrap_filled_vertex(struct gl_context *ctx)
d441 3
a443 3
   _save_wrap_buffers(ctx);

   /* Copy stored stored vertices to start of new list.
d447 2
a448 2
   for (i = 0; i < save->copied.nr; i++) {
      memcpy(save->buffer_ptr, data, save->vertex_size * sizeof(GLfloat));
d456 1
a456 2
static void
_save_copy_to_current(struct gl_context *ctx)
d458 1
a458 1
   struct vbo_save_context *save = &vbo_context(ctx)->save;
d461 1
a461 1
   for (i = VBO_ATTRIB_POS + 1; i < VBO_ATTRIB_MAX; i++) {
d463 4
a466 3
         save->currentsz[i][0] = save->attrsz[i];
         COPY_CLEAN_4V_TYPE_AS_FLOAT(save->current[i], save->attrsz[i],
                                     save->attrptr[i], save->attrtype[i]);
d472 1
a472 2
static void
_save_copy_from_current(struct gl_context *ctx)
d474 1
a474 1
   struct vbo_save_context *save = &vbo_context(ctx)->save;
d477 1
a477 1
   for (i = VBO_ATTRIB_POS + 1; i < VBO_ATTRIB_MAX; i++) {
d479 5
a483 10
      case 4:
         save->attrptr[i][3] = save->current[i][3];
      case 3:
         save->attrptr[i][2] = save->current[i][2];
      case 2:
         save->attrptr[i][1] = save->current[i][1];
      case 1:
         save->attrptr[i][0] = save->current[i][0];
      case 0:
         break;
d489 7
a495 8
/**
 * Called when we increase the size of a vertex attribute.  For example,
 * if we've seen one or more glTexCoord2f() calls and now we get a
 * glTexCoord3f() call.
 * Flush existing data, set new attrib size, replay copied vertices.
 */
static void
_save_upgrade_vertex(struct gl_context *ctx, GLuint attr, GLuint newsz)
d505 2
a506 2
   if (save->vert_count)
      _save_wrap_buffers(ctx);
d508 1
a508 1
      assert(save->copied.nr == 0);
d514 1
a514 1
   _save_copy_to_current(ctx);
d522 2
a523 2
   save->max_vert = ((VBO_SAVE_BUFFER_SIZE - save->vertex_store->used) /
                     save->vertex_size);
d528 1
a528 1
   for (i = 0, tmp = save->vertex; i < VBO_ATTRIB_MAX; i++) {
d530 2
a531 5
         save->attrptr[i] = tmp;
         tmp += save->attrsz[i];
      }
      else {
         save->attrptr[i] = NULL;       /* will not be dereferenced. */
d533 2
d539 1
a539 1
   _save_copy_from_current(ctx);
d547 3
a549 2
   if (save->copied.nr) {
      const GLfloat *data = save->copied.buffer;
d556 2
a557 2
         assert(oldsz == 0);
         save->dangling_attr_ref = GL_TRUE;
d560 22
a581 23
      for (i = 0; i < save->copied.nr; i++) {
         for (j = 0; j < VBO_ATTRIB_MAX; j++) {
            if (save->attrsz[j]) {
               if (j == attr) {
                  if (oldsz) {
                     COPY_CLEAN_4V_TYPE_AS_FLOAT(dest, oldsz, data,
                                                 save->attrtype[j]);
                     data += oldsz;
                     dest += newsz;
                  }
                  else {
                     COPY_SZ_4V(dest, newsz, save->current[attr]);
                     dest += newsz;
                  }
               }
               else {
                  GLint sz = save->attrsz[j];
                  COPY_SZ_4V(dest, sz, data);
                  data += sz;
                  dest += sz;
               }
            }
         }
d589 1
a589 8

/**
 * This is called when the size of a vertex attribute changes.
 * For example, after seeing one or more glTexCoord2f() calls we
 * get a glTexCoord4f() or glTexCoord1f() call.
 */
static void
save_fixup_vertex(struct gl_context *ctx, GLuint attr, GLuint sz)
d591 1
a591 1
   struct vbo_save_context *save = &vbo_context(ctx)->save;
d597 1
a597 1
      _save_upgrade_vertex(ctx, attr, sz);
d600 1
a601 1
      const GLfloat *id = vbo_get_default_vals_as_float(save->attrtype[attr]);
d606 2
a607 2
      for (i = sz; i <= save->attrsz[attr]; i++)
         save->attrptr[attr][i - 1] = id[i - 1];
d613 1
a613 8

/**
 * Reset the current size of all vertex attributes to the default
 * value of 0.  This signals that we haven't yet seen any per-vertex
 * commands such as glNormal3f() or glTexCoord2f().
 */
static void
_save_reset_vertex(struct gl_context *ctx)
d618 1
a618 1
   for (i = 0; i < VBO_ATTRIB_MAX; i++) {
d622 1
a622 1

d628 1
a628 1
#define ERROR(err)   _mesa_compile_error(ctx, err, __FUNCTION__);
d637 1
a637 1
#define ATTR(A, N, T, V0, V1, V2, V3)				\
d641 1
a641 1
   if (save->active_sz[A] != N)					\
d645 1
a645 1
      GLfloat *dest = save->attrptr[A];				\
a649 1
      save->attrtype[A] = T;                                    \
d658 1
a658 1
      save->buffer_ptr += save->vertex_size;			\
d661 1
a661 1
	 _save_wrap_filled_vertex(ctx);				\
a670 57
#define MAT( ATTR, N, face, params )			\
do {							\
   if (face != GL_BACK)					\
      MAT_ATTR( ATTR, N, params ); /* front */		\
   if (face != GL_FRONT)				\
      MAT_ATTR( ATTR + 1, N, params ); /* back */	\
} while (0)


/**
 * Save a glMaterial call found between glBegin/End.
 * glMaterial calls outside Begin/End are handled in dlist.c.
 */
static void GLAPIENTRY
_save_Materialfv(GLenum face, GLenum pname, const GLfloat *params)
{
   GET_CURRENT_CONTEXT(ctx);

   if (face != GL_FRONT && face != GL_BACK && face != GL_FRONT_AND_BACK) {
      _mesa_compile_error(ctx, GL_INVALID_ENUM, "glMaterial(face)");
      return;
   }

   switch (pname) {
   case GL_EMISSION:
      MAT(VBO_ATTRIB_MAT_FRONT_EMISSION, 4, face, params);
      break;
   case GL_AMBIENT:
      MAT(VBO_ATTRIB_MAT_FRONT_AMBIENT, 4, face, params);
      break;
   case GL_DIFFUSE:
      MAT(VBO_ATTRIB_MAT_FRONT_DIFFUSE, 4, face, params);
      break;
   case GL_SPECULAR:
      MAT(VBO_ATTRIB_MAT_FRONT_SPECULAR, 4, face, params);
      break;
   case GL_SHININESS:
      if (*params < 0 || *params > ctx->Const.MaxShininess) {
         _mesa_compile_error(ctx, GL_INVALID_VALUE, "glMaterial(shininess)");
      }
      else {
         MAT(VBO_ATTRIB_MAT_FRONT_SHININESS, 1, face, params);
      }
      break;
   case GL_COLOR_INDEXES:
      MAT(VBO_ATTRIB_MAT_FRONT_INDEXES, 3, face, params);
      break;
   case GL_AMBIENT_AND_DIFFUSE:
      MAT(VBO_ATTRIB_MAT_FRONT_AMBIENT, 4, face, params);
      MAT(VBO_ATTRIB_MAT_FRONT_DIFFUSE, 4, face, params);
      break;
   default:
      _mesa_compile_error(ctx, GL_INVALID_ENUM, "glMaterial(pname)");
      return;
   }
}

d676 1
a676 2
static void
dlist_fallback(struct gl_context *ctx)
d692 2
a693 2

      _save_compile_vertex_list(ctx);
d696 5
a700 10
   _save_copy_to_current(ctx);
   _save_reset_vertex(ctx);
   _save_reset_counters(ctx);
   if (save->out_of_memory) {
      _mesa_install_save_vtxfmt(ctx, &save->vtxfmt_noop);
   }
   else {
      _mesa_install_save_vtxfmt(ctx, &ctx->ListState.ListVtxfmt);
   }
   ctx->Driver.SaveNeedFlush = GL_FALSE;
d703 1
a703 3

static void GLAPIENTRY
_save_EvalCoord1f(GLfloat u)
d706 1
a706 1
   dlist_fallback(ctx);
d710 1
a710 2
static void GLAPIENTRY
_save_EvalCoord1fv(const GLfloat * v)
d713 1
a713 1
   dlist_fallback(ctx);
d717 1
a717 2
static void GLAPIENTRY
_save_EvalCoord2f(GLfloat u, GLfloat v)
d720 1
a720 1
   dlist_fallback(ctx);
d724 1
a724 2
static void GLAPIENTRY
_save_EvalCoord2fv(const GLfloat * v)
d727 1
a727 1
   dlist_fallback(ctx);
d731 1
a731 2
static void GLAPIENTRY
_save_EvalPoint1(GLint i)
d734 1
a734 1
   dlist_fallback(ctx);
d738 1
a738 2
static void GLAPIENTRY
_save_EvalPoint2(GLint i, GLint j)
d741 1
a741 1
   dlist_fallback(ctx);
d745 1
a745 2
static void GLAPIENTRY
_save_CallList(GLuint l)
d748 1
a748 1
   dlist_fallback(ctx);
d752 1
a752 2
static void GLAPIENTRY
_save_CallLists(GLsizei n, GLenum type, const GLvoid * v)
d755 1
a755 1
   dlist_fallback(ctx);
d761 3
a763 4
/**
 * Called via ctx->Driver.NotifySaveBegin() when a glBegin is getting
 * compiled into a display list.
 * Updating of ctx->Driver.CurrentSavePrimitive is already taken care of.
d765 1
a765 2
GLboolean
vbo_save_NotifyBegin(struct gl_context *ctx, GLenum mode)
d767 3
a769 2
   struct vbo_save_context *save = &vbo_context(ctx)->save;
   const GLuint i = save->prim_count++;
d772 1
a772 1
   save->prim[i].mode = mode & VBO_SAVE_PRIM_MODE_MASK;
a775 2
   save->prim[i].no_current_update =
      (mode & VBO_SAVE_PRIM_NO_CURRENT_UPDATE) ? 1 : 0;
d778 2
a779 13
   save->prim[i].count = 0;
   save->prim[i].num_instances = 1;
   save->prim[i].base_instance = 0;

   if (save->out_of_memory) {
      _mesa_install_save_vtxfmt(ctx, &save->vtxfmt_noop);
   }
   else {
      _mesa_install_save_vtxfmt(ctx, &save->vtxfmt);
   }

   /* We need to call SaveFlushVertices() if there's state change */
   ctx->Driver.SaveNeedFlush = GL_TRUE;
d781 2
a782 3
   /* GL_TRUE means we've handled this glBegin here; don't compile a BEGIN
    * opcode into the display list.
    */
d787 2
a788 2
static void GLAPIENTRY
_save_End(void)
d790 3
a792 3
   GET_CURRENT_CONTEXT(ctx);
   struct vbo_save_context *save = &vbo_context(ctx)->save;
   const GLint i = save->prim_count - 1;
d796 2
a797 1
   save->prim[i].count = (save->vert_count - save->prim[i].start);
d800 1
a800 1
      _save_compile_vertex_list(ctx);
d807 66
a872 7
    */
   if (save->out_of_memory) {
      _mesa_install_save_vtxfmt(ctx, &save->vtxfmt_noop);
   }
   else {
      _mesa_install_save_vtxfmt(ctx, &ctx->ListState.ListVtxfmt);
   }
d875 6
d882 2
a883 2
static void GLAPIENTRY
_save_Begin(GLenum mode)
d886 7
d894 1
a894 1
   _mesa_compile_error(ctx, GL_INVALID_OPERATION, "Recursive glBegin");
d898 1
a898 2
static void GLAPIENTRY
_save_PrimitiveRestartNV(void)
d901 1
a901 1
   GET_CURRENT_CONTEXT(ctx);
a912 1
 * Note: OBE = Outside Begin/End
d914 1
a914 2
static void GLAPIENTRY
_save_OBE_Rectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2)
d917 5
a921 5
   vbo_save_NotifyBegin(ctx, GL_QUADS | VBO_SAVE_PRIM_WEAK);
   CALL_Vertex2f(GET_DISPATCH(), (x1, y1));
   CALL_Vertex2f(GET_DISPATCH(), (x2, y1));
   CALL_Vertex2f(GET_DISPATCH(), (x2, y2));
   CALL_Vertex2f(GET_DISPATCH(), (x1, y2));
d926 1
a926 2
static void GLAPIENTRY
_save_OBE_DrawArrays(GLenum mode, GLint start, GLsizei count)
a928 1
   struct vbo_save_context *save = &vbo_context(ctx)->save;
d931 1
a931 2
   if (!_mesa_is_valid_prim_mode(ctx, mode)) {
      _mesa_compile_error(ctx, GL_INVALID_ENUM, "glDrawArrays(mode)");
a932 5
   }
   if (count < 0) {
      _mesa_compile_error(ctx, GL_INVALID_VALUE, "glDrawArrays(count<0)");
      return;
   }
d934 1
a934 4
   if (save->out_of_memory)
      return;

   _ae_map_vbos(ctx);
d936 1
a936 2
   vbo_save_NotifyBegin(ctx, (mode | VBO_SAVE_PRIM_WEAK
                              | VBO_SAVE_PRIM_NO_CURRENT_UPDATE));
d939 1
a939 1
      CALL_ArrayElement(GET_DISPATCH(), (start + i));
d942 1
a942 1
   _ae_unmap_vbos(ctx);
a944 1

d948 2
a949 3
static void GLAPIENTRY
_save_OBE_DrawElements(GLenum mode, GLsizei count, GLenum type,
                       const GLvoid * indices)
a951 1
   struct vbo_save_context *save = &vbo_context(ctx)->save;
d954 1
a954 16
   if (!_mesa_is_valid_prim_mode(ctx, mode)) {
      _mesa_compile_error(ctx, GL_INVALID_ENUM, "glDrawElements(mode)");
      return;
   }
   if (count < 0) {
      _mesa_compile_error(ctx, GL_INVALID_VALUE, "glDrawElements(count<0)");
      return;
   }
   if (type != GL_UNSIGNED_BYTE &&
       type != GL_UNSIGNED_SHORT &&
       type != GL_UNSIGNED_INT) {
      _mesa_compile_error(ctx, GL_INVALID_VALUE, "glDrawElements(count<0)");
      return;
   }

   if (save->out_of_memory)
d957 1
a957 1
   _ae_map_vbos(ctx);
d959 2
a960 3
   if (_mesa_is_bufferobj(ctx->Array.ArrayObj->ElementArrayBufferObj))
      indices =
         ADD_POINTERS(ctx->Array.ArrayObj->ElementArrayBufferObj->Pointer, indices);
d962 1
a962 2
   vbo_save_NotifyBegin(ctx, (mode | VBO_SAVE_PRIM_WEAK |
                              VBO_SAVE_PRIM_NO_CURRENT_UPDATE));
d966 2
a967 2
      for (i = 0; i < count; i++)
         CALL_ArrayElement(GET_DISPATCH(), (((GLubyte *) indices)[i]));
d970 2
a971 2
      for (i = 0; i < count; i++)
         CALL_ArrayElement(GET_DISPATCH(), (((GLushort *) indices)[i]));
d974 2
a975 2
      for (i = 0; i < count; i++)
         CALL_ArrayElement(GET_DISPATCH(), (((GLuint *) indices)[i]));
d978 1
a978 1
      _mesa_error(ctx, GL_INVALID_ENUM, "glDrawElements(type)");
d984 1
a984 1
   _ae_unmap_vbos(ctx);
d987 4
a990 5

static void GLAPIENTRY
_save_OBE_DrawRangeElements(GLenum mode, GLuint start, GLuint end,
                            GLsizei count, GLenum type,
                            const GLvoid * indices)
d993 4
a996 27
   struct vbo_save_context *save = &vbo_context(ctx)->save;

   if (!_mesa_is_valid_prim_mode(ctx, mode)) {
      _mesa_compile_error(ctx, GL_INVALID_ENUM, "glDrawRangeElements(mode)");
      return;
   }
   if (count < 0) {
      _mesa_compile_error(ctx, GL_INVALID_VALUE,
                          "glDrawRangeElements(count<0)");
      return;
   }
   if (type != GL_UNSIGNED_BYTE &&
       type != GL_UNSIGNED_SHORT &&
       type != GL_UNSIGNED_INT) {
      _mesa_compile_error(ctx, GL_INVALID_ENUM, "glDrawRangeElements(type)");
      return;
   }
   if (end < start) {
      _mesa_compile_error(ctx, GL_INVALID_VALUE,
                          "glDrawRangeElements(end < start)");
      return;
   }

   if (save->out_of_memory)
      return;

   _save_OBE_DrawElements(mode, count, type, indices);
a999 5
static void GLAPIENTRY
_save_OBE_MultiDrawElements(GLenum mode, const GLsizei *count, GLenum type,
                            const GLvoid * const *indices, GLsizei primcount)
{
   GLsizei i;
a1000 25
   for (i = 0; i < primcount; i++) {
      if (count[i] > 0) {
	 CALL_DrawElements(GET_DISPATCH(), (mode, count[i], type, indices[i]));
      }
   }
}


static void GLAPIENTRY
_save_OBE_MultiDrawElementsBaseVertex(GLenum mode, const GLsizei *count,
                                      GLenum type,
                                      const GLvoid * const *indices,
                                      GLsizei primcount,
                                      const GLint *basevertex)
{
   GLsizei i;

   for (i = 0; i < primcount; i++) {
      if (count[i] > 0) {
	 CALL_DrawElementsBaseVertex(GET_DISPATCH(), (mode, count[i], type,
						      indices[i],
						      basevertex[i]));
      }
   }
}
d1003 1
a1003 2
static void
_save_vtxfmt_init(struct gl_context *ctx)
d1008 1
a1008 1
   vfmt->ArrayElement = _ae_ArrayElement;
d1010 1
d1066 1
a1066 1

a1084 46
   vfmt->VertexP2ui = _save_VertexP2ui;
   vfmt->VertexP3ui = _save_VertexP3ui;
   vfmt->VertexP4ui = _save_VertexP4ui;
   vfmt->VertexP2uiv = _save_VertexP2uiv;
   vfmt->VertexP3uiv = _save_VertexP3uiv;
   vfmt->VertexP4uiv = _save_VertexP4uiv;

   vfmt->TexCoordP1ui = _save_TexCoordP1ui;
   vfmt->TexCoordP2ui = _save_TexCoordP2ui;
   vfmt->TexCoordP3ui = _save_TexCoordP3ui;
   vfmt->TexCoordP4ui = _save_TexCoordP4ui;
   vfmt->TexCoordP1uiv = _save_TexCoordP1uiv;
   vfmt->TexCoordP2uiv = _save_TexCoordP2uiv;
   vfmt->TexCoordP3uiv = _save_TexCoordP3uiv;
   vfmt->TexCoordP4uiv = _save_TexCoordP4uiv;

   vfmt->MultiTexCoordP1ui = _save_MultiTexCoordP1ui;
   vfmt->MultiTexCoordP2ui = _save_MultiTexCoordP2ui;
   vfmt->MultiTexCoordP3ui = _save_MultiTexCoordP3ui;
   vfmt->MultiTexCoordP4ui = _save_MultiTexCoordP4ui;
   vfmt->MultiTexCoordP1uiv = _save_MultiTexCoordP1uiv;
   vfmt->MultiTexCoordP2uiv = _save_MultiTexCoordP2uiv;
   vfmt->MultiTexCoordP3uiv = _save_MultiTexCoordP3uiv;
   vfmt->MultiTexCoordP4uiv = _save_MultiTexCoordP4uiv;

   vfmt->NormalP3ui = _save_NormalP3ui;
   vfmt->NormalP3uiv = _save_NormalP3uiv;

   vfmt->ColorP3ui = _save_ColorP3ui;
   vfmt->ColorP4ui = _save_ColorP4ui;
   vfmt->ColorP3uiv = _save_ColorP3uiv;
   vfmt->ColorP4uiv = _save_ColorP4uiv;

   vfmt->SecondaryColorP3ui = _save_SecondaryColorP3ui;
   vfmt->SecondaryColorP3uiv = _save_SecondaryColorP3uiv;

   vfmt->VertexAttribP1ui = _save_VertexAttribP1ui;
   vfmt->VertexAttribP2ui = _save_VertexAttribP2ui;
   vfmt->VertexAttribP3ui = _save_VertexAttribP3ui;
   vfmt->VertexAttribP4ui = _save_VertexAttribP4ui;

   vfmt->VertexAttribP1uiv = _save_VertexAttribP1uiv;
   vfmt->VertexAttribP2uiv = _save_VertexAttribP2uiv;
   vfmt->VertexAttribP3uiv = _save_VertexAttribP3uiv;
   vfmt->VertexAttribP4uiv = _save_VertexAttribP4uiv;

d1086 2
a1087 3
    */
   vfmt->CallList = _save_CallList;
   vfmt->CallLists = _save_CallLists;
d1089 1
a1089 6
   vfmt->EvalCoord1f = _save_EvalCoord1f;
   vfmt->EvalCoord1fv = _save_EvalCoord1fv;
   vfmt->EvalCoord2f = _save_EvalCoord2f;
   vfmt->EvalCoord2fv = _save_EvalCoord2fv;
   vfmt->EvalPoint1 = _save_EvalPoint1;
   vfmt->EvalPoint2 = _save_EvalPoint2;
d1091 2
a1092 2
   /* These calls all generate GL_INVALID_OPERATION since this vtxfmt is
    * only used when we're inside a glBegin/End pair.
d1095 9
d1107 1
a1107 21
/**
 * Initialize the dispatch table with the VBO functions for display
 * list compilation.
 */
void
vbo_initialize_save_dispatch(const struct gl_context *ctx,
                             struct _glapi_table *exec)
{
   SET_DrawArrays(exec, _save_OBE_DrawArrays);
   SET_DrawElements(exec, _save_OBE_DrawElements);
   SET_DrawRangeElements(exec, _save_OBE_DrawRangeElements);
   SET_MultiDrawElementsEXT(exec, _save_OBE_MultiDrawElements);
   SET_MultiDrawElementsBaseVertex(exec, _save_OBE_MultiDrawElementsBaseVertex);
   SET_Rectf(exec, _save_OBE_Rectf);
   /* Note: other glDraw functins aren't compiled into display lists */
}



void
vbo_save_SaveFlushVertices(struct gl_context *ctx)
d1113 2
a1114 1
   if (ctx->Driver.CurrentSavePrimitive <= PRIM_MAX)
d1117 8
a1124 7
   if (save->vert_count || save->prim_count)
      _save_compile_vertex_list(ctx);

   _save_copy_to_current(ctx);
   _save_reset_vertex(ctx);
   _save_reset_counters(ctx);
   ctx->Driver.SaveNeedFlush = GL_FALSE;
d1127 1
a1127 3

void
vbo_save_NewList(struct gl_context *ctx, GLuint list, GLenum mode)
d1131 1
a1131 2
   (void) list;
   (void) mode;
d1134 1
a1134 4
      save->prim_store = alloc_prim_store(ctx);

   if (!save->vertex_store)
      save->vertex_store = alloc_vertex_store(ctx);
d1136 8
a1143 5
   save->buffer_ptr = vbo_save_map_vertex_store(ctx, save->vertex_store);

   _save_reset_vertex(ctx);
   _save_reset_counters(ctx);
   ctx->Driver.SaveNeedFlush = GL_FALSE;
d1146 1
a1146 3

void
vbo_save_EndList(struct gl_context *ctx)
d1152 2
a1153 1
   if (_mesa_inside_dlist_begin_end(ctx)) {
d1158 2
a1159 1
         save->prim[i].count = (save->vert_count - save->prim[i].start);
d1166 1
a1166 1
      vbo_save_SaveFlushVertices(ctx);
d1171 2
a1172 2
       */
      _mesa_install_save_vtxfmt(ctx, &ctx->ListState.ListVtxfmt);
d1175 1
a1175 1
   vbo_save_unmap_vertex_store(ctx, save->vertex_store);
d1179 2
a1180 4


void
vbo_save_BeginCallList(struct gl_context *ctx, struct gl_display_list *dlist)
d1186 1
a1186 3

void
vbo_save_EndCallList(struct gl_context *ctx)
d1189 1
a1189 1

d1199 1
a1199 2
static void
vbo_destroy_vertex_list(struct gl_context *ctx, void *data)
d1201 1
a1201 1
   struct vbo_save_vertex_list *node = (struct vbo_save_vertex_list *) data;
d1204 2
a1205 2
   if (--node->vertex_store->refcount == 0)
      free_vertex_store(ctx, node->vertex_store);
d1207 2
a1208 2
   if (--node->prim_store->refcount == 0)
      free(node->prim_store);
d1210 4
a1213 2
   free(node->current_data);
   node->current_data = NULL;
d1217 1
a1217 2
static void
vbo_print_vertex_list(struct gl_context *ctx, void *data)
d1219 1
a1219 1
   struct vbo_save_vertex_list *node = (struct vbo_save_vertex_list *) data;
d1224 3
a1226 1
          node->count, node->prim_count, node->vertex_size);
d1228 1
a1228 1
   for (i = 0; i < node->prim_count; i++) {
d1230 8
a1237 8
      printf("   prim %d: %s%s %d..%d %s %s\n",
             i,
             _mesa_lookup_prim_by_nr(prim->mode),
             prim->weak ? " (weak)" : "",
             prim->start,
             prim->start + prim->count,
             (prim->begin) ? "BEGIN" : "(wrap)",
             (prim->end) ? "END" : "(wrap)");
d1242 1
a1242 5
/**
 * Called during context creation/init.
 */
static void
_save_current_init(struct gl_context *ctx)
a1261 1

d1263 1
a1263 1
 * Initialize the display list compiler.  Called during context creation.
d1265 1
a1265 2
void
vbo_save_api_init(struct vbo_save_context *save)
d1271 5
a1275 5
      _mesa_dlist_alloc_opcode(ctx,
                               sizeof(struct vbo_save_vertex_list),
                               vbo_save_playback_vertex_list,
                               vbo_destroy_vertex_list,
                               vbo_print_vertex_list);
d1279 2
a1280 3
   _save_vtxfmt_init(ctx);
   _save_current_init(ctx);
   _mesa_noop_vtxfmt_init(&save->vtxfmt_noop);
d1285 12
d1298 3
@


1.1.1.4
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
Copyright 2002-2008 VMware, Inc.
d21 1
a21 1
VMWARE AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
d30 1
a30 1
 *   Keith Whitwell <keithw@@vmware.com>
d44 1
a44 1
 * End).
d63 1
a63 1
 * these, compilation falls back to opcodes.
a202 2
                                 GL_MAP_WRITE_BIT |
                                 GL_DYNAMIC_STORAGE_BIT,
a239 5
   const GLbitfield access = (GL_MAP_WRITE_BIT |
                              GL_MAP_INVALIDATE_RANGE_BIT |
                              GL_MAP_UNSYNCHRONIZED_BIT |
                              GL_MAP_FLUSH_EXPLICIT_BIT);

d241 1
a241 2
   assert(!vertex_store->buffer);  /* the buffer should not be mapped */

d243 7
a249 17
      /* Map the remaining free space in the VBO */
      GLintptr offset = vertex_store->used * sizeof(GLfloat);
      GLsizeiptr size = vertex_store->bufferobj->Size - offset;
      GLfloat *range = (GLfloat *)
         ctx->Driver.MapBufferRange(ctx, offset, size, access,
                                    vertex_store->bufferobj,
                                    MAP_INTERNAL);
      if (range) {
         /* compute address of start of whole buffer (needed elsewhere) */
         vertex_store->buffer = range - vertex_store->used;
         assert(vertex_store->buffer);
         return range;
      }
      else {
         vertex_store->buffer = NULL;
         return NULL;
      }
d263 1
a263 10
      GLintptr offset = 0;
      GLsizeiptr length = vertex_store->used * sizeof(GLfloat)
         - vertex_store->bufferobj->Mappings[MAP_INTERNAL].Offset;

      /* Explicitly flush the region we wrote to */
      ctx->Driver.FlushMappedBufferRange(ctx, offset, length,
                                         vertex_store->bufferobj,
                                         MAP_INTERNAL);

      ctx->Driver.UnmapBuffer(ctx, vertex_store->bufferobj, MAP_INTERNAL);
d292 2
a293 2
      save->max_vert = (VBO_SAVE_BUFFER_SIZE - save->vertex_store->used) /
                        save->vertex_size;
d300 1
a300 1
   save->dangling_attr_ref = GL_FALSE;
d413 1
a413 1
   /* Copy duplicated vertices
a510 1
   save->prim[0].is_indirect = 0;
d517 1
a517 1
 * vertex_store struct.
d606 1
a606 1
    * its size increased.
d859 1
a859 1
      save->dangling_attr_ref = GL_TRUE;
a965 1
   save->prim[i].is_indirect = 0;
a1093 1
   struct gl_buffer_object *indexbuf = ctx->Array.VAO->IndexBufferObj;
d1116 1
a1116 1
   if (_mesa_is_bufferobj(indexbuf))
d1118 1
a1118 1
         ADD_POINTERS(indexbuf->Mappings[MAP_INTERNAL].Pointer, indices);
d1436 1
a1436 1
         save->prim[i].count = save->vert_count - save->prim[i].start;
d1442 1
a1442 1
      save->dangling_attr_ref = GL_TRUE;
@


1.1.1.5
log
@Import Mesa 10.4.3
@
text
@d194 3
a196 1
   vertex_store->bufferobj = ctx->Driver.NewBufferObject(ctx, VBO_BUF_ID);
@


1.1.1.6
log
@Import Mesa 10.2.9
@
text
@d194 1
a194 3
   vertex_store->bufferobj = ctx->Driver.NewBufferObject(ctx,
                                                         VBO_BUF_ID,
                                                         GL_ARRAY_BUFFER_ARB);
@


