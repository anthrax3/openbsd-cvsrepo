head	1.12;
access;
symbols
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	v10_2_9:1.1.1.6
	v10_4_3:1.1.1.5
	v10_2_7:1.1.1.4
	OPENBSD_5_6:1.9.0.2
	OPENBSD_5_6_BASE:1.9
	v10_2_3:1.1.1.4
	OPENBSD_5_5:1.8.0.2
	OPENBSD_5_5_BASE:1.8
	v9_2_5:1.1.1.3
	v9_2_3:1.1.1.3
	v9_2_2:1.1.1.3
	v9_2_1:1.1.1.3
	v9_2_0:1.1.1.3
	OPENBSD_5_4:1.7.0.4
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.6.0.4
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	v7_10_3:1.1.1.2
	OPENBSD_5_0:1.5.0.6
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.2
	v7_0_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2015.12.23.05.17.55;	author jsg;	state dead;
branches;
next	1.11;
commitid	TnlogFl9nOv2eaRf;

1.11
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.10;
commitid	4ry2gvZGMXkCUD2n;

1.10
date	2015.01.25.14.41.22;	author jsg;	state Exp;
branches;
next	1.9;
commitid	mcxB0JvoI9gTDYXU;

1.9
date	2014.07.09.21.09.01;	author jsg;	state Exp;
branches;
next	1.8;
commitid	WPD6rgPryPkvXOr9;

1.8
date	2013.09.05.14.06.58;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2012.08.17.13.58.20;	author mpi;	state Exp;
branches;
next	1.6;

1.6
date	2011.10.23.13.37.46;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.05.22.20.06.37;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.05.17.20.26.43;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.14.58.23;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.05.31.16.36.49;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.24.17.32.25;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.11.24.17.32.25;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2011.10.23.13.29.50;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2013.09.05.13.17.45;	author jsg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.07.09.20.35.14;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.5
date	2015.01.25.14.13.38;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.6
date	2015.02.20.22.50.43;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.12
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2003 VMware, Inc.
 * Copyright 2009 VMware, Inc.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

#include "main/glheader.h"
#include "main/context.h"
#include "main/state.h"
#include "main/api_validate.h"
#include "main/dispatch.h"
#include "main/varray.h"
#include "main/bufferobj.h"
#include "main/enums.h"
#include "main/macros.h"
#include "main/transformfeedback.h"

#include "vbo_context.h"


/**
 * All vertex buffers should be in an unmapped state when we're about
 * to draw.  This debug function checks that.
 */
static void
check_buffers_are_unmapped(const struct gl_client_array **inputs)
{
#ifdef DEBUG
   GLuint i;

   for (i = 0; i < VERT_ATTRIB_MAX; i++) {
      if (inputs[i]) {
         struct gl_buffer_object *obj = inputs[i]->BufferObj;
         assert(!_mesa_check_disallowed_mapping(obj));
         (void) obj;
      }
   }
#endif
}


/**
 * A debug function that may be called from other parts of Mesa as
 * needed during debugging.
 */
void
vbo_check_buffers_are_unmapped(struct gl_context *ctx)
{
   struct vbo_context *vbo = vbo_context(ctx);
   struct vbo_exec_context *exec = &vbo->exec;
   /* check the current vertex arrays */
   check_buffers_are_unmapped(exec->array.inputs);
   /* check the current glBegin/glVertex/glEnd-style VBO */
   assert(!_mesa_check_disallowed_mapping(exec->vtx.bufferobj));
}



/**
 * Compute min and max elements by scanning the index buffer for
 * glDraw[Range]Elements() calls.
 * If primitive restart is enabled, we need to ignore restart
 * indexes when computing min/max.
 */
static void
vbo_get_minmax_index(struct gl_context *ctx,
		     const struct _mesa_prim *prim,
		     const struct _mesa_index_buffer *ib,
		     GLuint *min_index, GLuint *max_index,
		     const GLuint count)
{
   const GLboolean restart = ctx->Array._PrimitiveRestart;
   const GLuint restartIndex = _mesa_primitive_restart_index(ctx, ib->type);
   const int index_size = vbo_sizeof_ib_type(ib->type);
   const char *indices;
   GLuint i;

   indices = (char *) ib->ptr + prim->start * index_size;
   if (_mesa_is_bufferobj(ib->obj)) {
      GLsizeiptr size = MIN2(count * index_size, ib->obj->Size);
      indices = ctx->Driver.MapBufferRange(ctx, (GLintptr) indices, size,
                                           GL_MAP_READ_BIT, ib->obj,
                                           MAP_INTERNAL);
   }

   switch (ib->type) {
   case GL_UNSIGNED_INT: {
      const GLuint *ui_indices = (const GLuint *)indices;
      GLuint max_ui = 0;
      GLuint min_ui = ~0U;
      if (restart) {
         for (i = 0; i < count; i++) {
            if (ui_indices[i] != restartIndex) {
               if (ui_indices[i] > max_ui) max_ui = ui_indices[i];
               if (ui_indices[i] < min_ui) min_ui = ui_indices[i];
            }
         }
      }
      else {
         for (i = 0; i < count; i++) {
            if (ui_indices[i] > max_ui) max_ui = ui_indices[i];
            if (ui_indices[i] < min_ui) min_ui = ui_indices[i];
         }
      }
      *min_index = min_ui;
      *max_index = max_ui;
      break;
   }
   case GL_UNSIGNED_SHORT: {
      const GLushort *us_indices = (const GLushort *)indices;
      GLuint max_us = 0;
      GLuint min_us = ~0U;
      if (restart) {
         for (i = 0; i < count; i++) {
            if (us_indices[i] != restartIndex) {
               if (us_indices[i] > max_us) max_us = us_indices[i];
               if (us_indices[i] < min_us) min_us = us_indices[i];
            }
         }
      }
      else {
         for (i = 0; i < count; i++) {
            if (us_indices[i] > max_us) max_us = us_indices[i];
            if (us_indices[i] < min_us) min_us = us_indices[i];
         }
      }
      *min_index = min_us;
      *max_index = max_us;
      break;
   }
   case GL_UNSIGNED_BYTE: {
      const GLubyte *ub_indices = (const GLubyte *)indices;
      GLuint max_ub = 0;
      GLuint min_ub = ~0U;
      if (restart) {
         for (i = 0; i < count; i++) {
            if (ub_indices[i] != restartIndex) {
               if (ub_indices[i] > max_ub) max_ub = ub_indices[i];
               if (ub_indices[i] < min_ub) min_ub = ub_indices[i];
            }
         }
      }
      else {
         for (i = 0; i < count; i++) {
            if (ub_indices[i] > max_ub) max_ub = ub_indices[i];
            if (ub_indices[i] < min_ub) min_ub = ub_indices[i];
         }
      }
      *min_index = min_ub;
      *max_index = max_ub;
      break;
   }
   default:
      assert(0);
      break;
   }

   if (_mesa_is_bufferobj(ib->obj)) {
      ctx->Driver.UnmapBuffer(ctx, ib->obj, MAP_INTERNAL);
   }
}

/**
 * Compute min and max elements for nr_prims
 */
void
vbo_get_minmax_indices(struct gl_context *ctx,
                       const struct _mesa_prim *prims,
                       const struct _mesa_index_buffer *ib,
                       GLuint *min_index,
                       GLuint *max_index,
                       GLuint nr_prims)
{
   GLuint tmp_min, tmp_max;
   GLuint i;
   GLuint count;

   *min_index = ~0;
   *max_index = 0;

   for (i = 0; i < nr_prims; i++) {
      const struct _mesa_prim *start_prim;

      start_prim = &prims[i];
      count = start_prim->count;
      /* Do combination if possible to reduce map/unmap count */
      while ((i + 1 < nr_prims) &&
             (prims[i].start + prims[i].count == prims[i+1].start)) {
         count += prims[i+1].count;
         i++;
      }
      vbo_get_minmax_index(ctx, start_prim, ib, &tmp_min, &tmp_max, count);
      *min_index = MIN2(*min_index, tmp_min);
      *max_index = MAX2(*max_index, tmp_max);
   }
}


/**
 * Check that element 'j' of the array has reasonable data.
 * Map VBO if needed.
 * For debugging purposes; not normally used.
 */
static void
check_array_data(struct gl_context *ctx, struct gl_client_array *array,
                 GLuint attrib, GLuint j)
{
   if (array->Enabled) {
      const void *data = array->Ptr;
      if (_mesa_is_bufferobj(array->BufferObj)) {
         if (!array->BufferObj->Mappings[MAP_INTERNAL].Pointer) {
            /* need to map now */
            array->BufferObj->Mappings[MAP_INTERNAL].Pointer =
               ctx->Driver.MapBufferRange(ctx, 0, array->BufferObj->Size,
					  GL_MAP_READ_BIT, array->BufferObj,
                                          MAP_INTERNAL);
         }
         data = ADD_POINTERS(data,
                             array->BufferObj->Mappings[MAP_INTERNAL].Pointer);
      }
      switch (array->Type) {
      case GL_FLOAT:
         {
            GLfloat *f = (GLfloat *) ((GLubyte *) data + array->StrideB * j);
            GLint k;
            for (k = 0; k < array->Size; k++) {
               if (IS_INF_OR_NAN(f[k]) ||
                   f[k] >= 1.0e20 || f[k] <= -1.0e10) {
                  printf("Bad array data:\n");
                  printf("  Element[%u].%u = %f\n", j, k, f[k]);
                  printf("  Array %u at %p\n", attrib, (void* ) array);
                  printf("  Type 0x%x, Size %d, Stride %d\n",
			 array->Type, array->Size, array->Stride);
                  printf("  Address/offset %p in Buffer Object %u\n",
			 array->Ptr, array->BufferObj->Name);
                  f[k] = 1.0; /* XXX replace the bad value! */
               }
               /*assert(!IS_INF_OR_NAN(f[k]));*/
            }
         }
         break;
      default:
         ;
      }
   }
}


/**
 * Unmap the buffer object referenced by given array, if mapped.
 */
static void
unmap_array_buffer(struct gl_context *ctx, struct gl_client_array *array)
{
   if (array->Enabled &&
       _mesa_is_bufferobj(array->BufferObj) &&
       _mesa_bufferobj_mapped(array->BufferObj, MAP_INTERNAL)) {
      ctx->Driver.UnmapBuffer(ctx, array->BufferObj, MAP_INTERNAL);
   }
}


/**
 * Examine the array's data for NaNs, etc.
 * For debug purposes; not normally used.
 */
static void
check_draw_elements_data(struct gl_context *ctx, GLsizei count, GLenum elemType,
                         const void *elements, GLint basevertex)
{
   struct gl_vertex_array_object *vao = ctx->Array.VAO;
   const void *elemMap;
   GLint i, k;

   if (_mesa_is_bufferobj(ctx->Array.VAO->IndexBufferObj)) {
      elemMap = ctx->Driver.MapBufferRange(ctx, 0,
					   ctx->Array.VAO->IndexBufferObj->Size,
					   GL_MAP_READ_BIT,
					   ctx->Array.VAO->IndexBufferObj,
                                           MAP_INTERNAL);
      elements = ADD_POINTERS(elements, elemMap);
   }

   for (i = 0; i < count; i++) {
      GLuint j;

      /* j = element[i] */
      switch (elemType) {
      case GL_UNSIGNED_BYTE:
         j = ((const GLubyte *) elements)[i];
         break;
      case GL_UNSIGNED_SHORT:
         j = ((const GLushort *) elements)[i];
         break;
      case GL_UNSIGNED_INT:
         j = ((const GLuint *) elements)[i];
         break;
      default:
         assert(0);
      }

      /* check element j of each enabled array */
      for (k = 0; k < Elements(vao->_VertexAttrib); k++) {
         check_array_data(ctx, &vao->_VertexAttrib[k], k, j);
      }
   }

   if (_mesa_is_bufferobj(vao->IndexBufferObj)) {
      ctx->Driver.UnmapBuffer(ctx, ctx->Array.VAO->IndexBufferObj,
                              MAP_INTERNAL);
   }

   for (k = 0; k < Elements(vao->_VertexAttrib); k++) {
      unmap_array_buffer(ctx, &vao->_VertexAttrib[k]);
   }
}


/**
 * Check array data, looking for NaNs, etc.
 */
static void
check_draw_arrays_data(struct gl_context *ctx, GLint start, GLsizei count)
{
   /* TO DO */
}


/**
 * Print info/data for glDrawArrays(), for debugging.
 */
static void
print_draw_arrays(struct gl_context *ctx,
                  GLenum mode, GLint start, GLsizei count)
{
   struct vbo_context *vbo = vbo_context(ctx);
   struct vbo_exec_context *exec = &vbo->exec;
   struct gl_vertex_array_object *vao = ctx->Array.VAO;
   int i;

   printf("vbo_exec_DrawArrays(mode 0x%x, start %d, count %d):\n",
	  mode, start, count);

   for (i = 0; i < 32; i++) {
      struct gl_buffer_object *bufObj = exec->array.inputs[i]->BufferObj;
      GLuint bufName = bufObj->Name;
      GLint stride = exec->array.inputs[i]->Stride;
      printf("attr %2d: size %d stride %d  enabled %d  "
	     "ptr %p  Bufobj %u\n",
	     i,
	     exec->array.inputs[i]->Size,
	     stride,
	     /*exec->array.inputs[i]->Enabled,*/
	     vao->_VertexAttrib[VERT_ATTRIB_FF(i)].Enabled,
	     exec->array.inputs[i]->Ptr,
	     bufName);

      if (bufName) {
         GLubyte *p = ctx->Driver.MapBufferRange(ctx, 0, bufObj->Size,
						 GL_MAP_READ_BIT, bufObj,
                                                 MAP_INTERNAL);
         int offset = (int) (GLintptr) exec->array.inputs[i]->Ptr;
         float *f = (float *) (p + offset);
         int *k = (int *) f;
         int i;
         int n = (count * stride) / 4;
         if (n > 32)
            n = 32;
         printf("  Data at offset %d:\n", offset);
         for (i = 0; i < n; i++) {
            printf("    float[%d] = 0x%08x %f\n", i, k[i], f[i]);
         }
         ctx->Driver.UnmapBuffer(ctx, bufObj, MAP_INTERNAL);
      }
   }
}


/**
 * Set the vbo->exec->inputs[] pointers to point to the enabled
 * vertex arrays.  This depends on the current vertex program/shader
 * being executed because of whether or not generic vertex arrays
 * alias the conventional vertex arrays.
 * For arrays that aren't enabled, we set the input[attrib] pointer
 * to point at a zero-stride current value "array".
 */
static void
recalculate_input_bindings(struct gl_context *ctx)
{
   struct vbo_context *vbo = vbo_context(ctx);
   struct vbo_exec_context *exec = &vbo->exec;
   struct gl_client_array *vertexAttrib = ctx->Array.VAO->_VertexAttrib;
   const struct gl_client_array **inputs = &exec->array.inputs[0];
   GLbitfield64 const_inputs = 0x0;
   GLuint i;

   switch (get_program_mode(ctx)) {
   case VP_NONE:
      /* When no vertex program is active (or the vertex program is generated
       * from fixed-function state).  We put the material values into the
       * generic slots.  This is the only situation where material values
       * are available as per-vertex attributes.
       */
      for (i = 0; i < VERT_ATTRIB_FF_MAX; i++) {
	 if (vertexAttrib[VERT_ATTRIB_FF(i)].Enabled)
	    inputs[i] = &vertexAttrib[VERT_ATTRIB_FF(i)];
	 else {
	    inputs[i] = &vbo->currval[VBO_ATTRIB_POS+i];
            const_inputs |= VERT_BIT(i);
         }
      }

      for (i = 0; i < MAT_ATTRIB_MAX; i++) {
	 inputs[VERT_ATTRIB_GENERIC(i)] =
	    &vbo->currval[VBO_ATTRIB_MAT_FRONT_AMBIENT+i];
         const_inputs |= VERT_BIT_GENERIC(i);
      }

      /* Could use just about anything, just to fill in the empty
       * slots:
       */
      for (i = MAT_ATTRIB_MAX; i < VERT_ATTRIB_GENERIC_MAX; i++) {
	 inputs[VERT_ATTRIB_GENERIC(i)] = &vbo->currval[VBO_ATTRIB_GENERIC0+i];
         const_inputs |= VERT_BIT_GENERIC(i);
      }
      break;

   case VP_ARB:
      /* There are no shaders in OpenGL ES 1.x, so this code path should be
       * impossible to reach.  The meta code is careful to not use shaders in
       * ES1.
       */
      assert(ctx->API != API_OPENGLES);

      /* In the compatibility profile of desktop OpenGL, the generic[0]
       * attribute array aliases and overrides the legacy position array.  
       * Otherwise, legacy attributes available in the legacy slots,
       * generic attributes in the generic slots and materials are not
       * available as per-vertex attributes.
       *
       * In all other APIs, only the generic attributes exist, and none of the
       * slots are considered "magic."
       */
      if (ctx->API == API_OPENGL_COMPAT) {
         if (vertexAttrib[VERT_ATTRIB_GENERIC0].Enabled)
            inputs[0] = &vertexAttrib[VERT_ATTRIB_GENERIC0];
         else if (vertexAttrib[VERT_ATTRIB_POS].Enabled)
            inputs[0] = &vertexAttrib[VERT_ATTRIB_POS];
         else {
            inputs[0] = &vbo->currval[VBO_ATTRIB_POS];
            const_inputs |= VERT_BIT_POS;
         }

         for (i = 1; i < VERT_ATTRIB_FF_MAX; i++) {
            if (vertexAttrib[VERT_ATTRIB_FF(i)].Enabled)
               inputs[i] = &vertexAttrib[VERT_ATTRIB_FF(i)];
            else {
               inputs[i] = &vbo->currval[VBO_ATTRIB_POS+i];
               const_inputs |= VERT_BIT_FF(i);
            }
         }

         for (i = 1; i < VERT_ATTRIB_GENERIC_MAX; i++) {
            if (vertexAttrib[VERT_ATTRIB_GENERIC(i)].Enabled)
               inputs[VERT_ATTRIB_GENERIC(i)] =
                  &vertexAttrib[VERT_ATTRIB_GENERIC(i)];
            else {
               inputs[VERT_ATTRIB_GENERIC(i)] =
                  &vbo->currval[VBO_ATTRIB_GENERIC0+i];
               const_inputs |= VERT_BIT_GENERIC(i);
            }
         }

         inputs[VERT_ATTRIB_GENERIC0] = inputs[0];
      } else {
         /* Other parts of the code assume that inputs[0] through
          * inputs[VERT_ATTRIB_FF_MAX] will be non-NULL.  However, in OpenGL
          * ES 2.0+ or OpenGL core profile, none of these arrays should ever
          * be enabled.
          */
         for (i = 0; i < VERT_ATTRIB_FF_MAX; i++) {
            assert(!vertexAttrib[VERT_ATTRIB_FF(i)].Enabled);

            inputs[i] = &vbo->currval[VBO_ATTRIB_POS+i];
            const_inputs |= VERT_BIT_FF(i);
         }

         for (i = 0; i < VERT_ATTRIB_GENERIC_MAX; i++) {
            if (vertexAttrib[VERT_ATTRIB_GENERIC(i)].Enabled)
               inputs[VERT_ATTRIB_GENERIC(i)] =
                  &vertexAttrib[VERT_ATTRIB_GENERIC(i)];
            else {
               inputs[VERT_ATTRIB_GENERIC(i)] =
                  &vbo->currval[VBO_ATTRIB_GENERIC0+i];
               const_inputs |= VERT_BIT_GENERIC(i);
            }
         }
      }

      break;
   }

   _mesa_set_varying_vp_inputs( ctx, VERT_BIT_ALL & (~const_inputs) );
   ctx->NewDriverState |= ctx->DriverFlags.NewArray;
}


/**
 * Examine the enabled vertex arrays to set the exec->array.inputs[] values.
 * These will point to the arrays to actually use for drawing.  Some will
 * be user-provided arrays, other will be zero-stride const-valued arrays.
 * Note that this might set the _NEW_VARYING_VP_INPUTS dirty flag so state
 * validation must be done after this call.
 */
void
vbo_bind_arrays(struct gl_context *ctx)
{
   struct vbo_context *vbo = vbo_context(ctx);
   struct vbo_exec_context *exec = &vbo->exec;

   vbo_draw_method(vbo, DRAW_ARRAYS);

   if (exec->array.recalculate_inputs) {
      recalculate_input_bindings(ctx);
      exec->array.recalculate_inputs = GL_FALSE;

      /* Again... because we may have changed the bitmask of per-vertex varying
       * attributes.  If we regenerate the fixed-function vertex program now
       * we may be able to prune down the number of vertex attributes which we
       * need in the shader.
       */
      if (ctx->NewState) {
         /* Setting "validating" to TRUE prevents _mesa_update_state from
          * invalidating what we just did.
          */
         exec->validating = GL_TRUE;
         _mesa_update_state(ctx);
         exec->validating = GL_FALSE;
      }
   }
}


/**
 * Handle a draw case that potentially has primitive restart enabled.
 *
 * If primitive restart is enabled, and PrimitiveRestartInSoftware is
 * set, then vbo_sw_primitive_restart is used to handle the primitive
 * restart case in software.
 */
static void
vbo_handle_primitive_restart(struct gl_context *ctx,
                             const struct _mesa_prim *prim,
                             GLuint nr_prims,
                             const struct _mesa_index_buffer *ib,
                             GLboolean index_bounds_valid,
                             GLuint min_index,
                             GLuint max_index)
{
   struct vbo_context *vbo = vbo_context(ctx);

   if ((ib != NULL) &&
       ctx->Const.PrimitiveRestartInSoftware &&
       ctx->Array._PrimitiveRestart) {
      /* Handle primitive restart in software */
      vbo_sw_primitive_restart(ctx, prim, nr_prims, ib, NULL);
   } else {
      /* Call driver directly for draw_prims */
      vbo->draw_prims(ctx, prim, nr_prims, ib,
                      index_bounds_valid, min_index, max_index, NULL, NULL);
   }
}


/**
 * Helper function called by the other DrawArrays() functions below.
 * This is where we handle primitive restart for drawing non-indexed
 * arrays.  If primitive restart is enabled, it typically means
 * splitting one DrawArrays() into two.
 */
static void
vbo_draw_arrays(struct gl_context *ctx, GLenum mode, GLint start,
                GLsizei count, GLuint numInstances, GLuint baseInstance)
{
   struct vbo_context *vbo = vbo_context(ctx);
   struct vbo_exec_context *exec = &vbo->exec;
   struct _mesa_prim prim[2];

   vbo_bind_arrays(ctx);

   /* init most fields to zero */
   memset(prim, 0, sizeof(prim));
   prim[0].begin = 1;
   prim[0].end = 1;
   prim[0].mode = mode;
   prim[0].num_instances = numInstances;
   prim[0].base_instance = baseInstance;
   prim[0].is_indirect = 0;

   /* Implement the primitive restart index */
   if (ctx->Array.PrimitiveRestart && ctx->Array.RestartIndex < count) {
      GLuint primCount = 0;

      if (ctx->Array.RestartIndex == start) {
         /* special case: RestartIndex at beginning */
         if (count > 1) {
            prim[0].start = start + 1;
            prim[0].count = count - 1;
            primCount = 1;
         }
      }
      else if (ctx->Array.RestartIndex == start + count - 1) {
         /* special case: RestartIndex at end */
         if (count > 1) {
            prim[0].start = start;
            prim[0].count = count - 1;
            primCount = 1;
         }
      }
      else {
         /* general case: RestartIndex in middle, split into two prims */
         prim[0].start = start;
         prim[0].count = ctx->Array.RestartIndex - start;

         prim[1] = prim[0];
         prim[1].start = ctx->Array.RestartIndex + 1;
         prim[1].count = count - prim[1].start;

         primCount = 2;
      }

      if (primCount > 0) {
         /* draw one or two prims */
         check_buffers_are_unmapped(exec->array.inputs);
         vbo->draw_prims(ctx, prim, primCount, NULL,
                         GL_TRUE, start, start + count - 1, NULL, NULL);
      }
   }
   else {
      /* no prim restart */
      prim[0].start = start;
      prim[0].count = count;

      check_buffers_are_unmapped(exec->array.inputs);
      vbo->draw_prims(ctx, prim, 1, NULL,
                      GL_TRUE, start, start + count - 1,
                      NULL, NULL);
   }

   if (MESA_DEBUG_FLAGS & DEBUG_ALWAYS_FLUSH) {
      _mesa_flush(ctx);
   }
}


/**
 * Execute a glRectf() function.
 */
static void GLAPIENTRY
vbo_exec_Rectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2)
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   CALL_Begin(GET_DISPATCH(), (GL_QUADS));
   CALL_Vertex2f(GET_DISPATCH(), (x1, y1));
   CALL_Vertex2f(GET_DISPATCH(), (x2, y1));
   CALL_Vertex2f(GET_DISPATCH(), (x2, y2));
   CALL_Vertex2f(GET_DISPATCH(), (x1, y2));
   CALL_End(GET_DISPATCH(), ());
}


static void GLAPIENTRY
vbo_exec_EvalMesh1(GLenum mode, GLint i1, GLint i2)
{
   GET_CURRENT_CONTEXT(ctx);
   GLint i;
   GLfloat u, du;
   GLenum prim;

   switch (mode) {
   case GL_POINT:
      prim = GL_POINTS;
      break;
   case GL_LINE:
      prim = GL_LINE_STRIP;
      break;
   default:
      _mesa_error( ctx, GL_INVALID_ENUM, "glEvalMesh1(mode)" );
      return;
   }

   /* No effect if vertex maps disabled.
    */
   if (!ctx->Eval.Map1Vertex4 && 
       !ctx->Eval.Map1Vertex3)
      return;

   du = ctx->Eval.MapGrid1du;
   u = ctx->Eval.MapGrid1u1 + i1 * du;

   CALL_Begin(GET_DISPATCH(), (prim));
   for (i=i1;i<=i2;i++,u+=du) {
      CALL_EvalCoord1f(GET_DISPATCH(), (u));
   }
   CALL_End(GET_DISPATCH(), ());
}


static void GLAPIENTRY
vbo_exec_EvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2)
{
   GET_CURRENT_CONTEXT(ctx);
   GLfloat u, du, v, dv, v1, u1;
   GLint i, j;

   switch (mode) {
   case GL_POINT:
   case GL_LINE:
   case GL_FILL:
      break;
   default:
      _mesa_error( ctx, GL_INVALID_ENUM, "glEvalMesh2(mode)" );
      return;
   }

   /* No effect if vertex maps disabled.
    */
   if (!ctx->Eval.Map2Vertex4 && 
       !ctx->Eval.Map2Vertex3)
      return;

   du = ctx->Eval.MapGrid2du;
   dv = ctx->Eval.MapGrid2dv;
   v1 = ctx->Eval.MapGrid2v1 + j1 * dv;
   u1 = ctx->Eval.MapGrid2u1 + i1 * du;

   switch (mode) {
   case GL_POINT:
      CALL_Begin(GET_DISPATCH(), (GL_POINTS));
      for (v=v1,j=j1;j<=j2;j++,v+=dv) {
	 for (u=u1,i=i1;i<=i2;i++,u+=du) {
	    CALL_EvalCoord2f(GET_DISPATCH(), (u, v));
	 }
      }
      CALL_End(GET_DISPATCH(), ());
      break;
   case GL_LINE:
      for (v=v1,j=j1;j<=j2;j++,v+=dv) {
	 CALL_Begin(GET_DISPATCH(), (GL_LINE_STRIP));
	 for (u=u1,i=i1;i<=i2;i++,u+=du) {
	    CALL_EvalCoord2f(GET_DISPATCH(), (u, v));
	 }
	 CALL_End(GET_DISPATCH(), ());
      }
      for (u=u1,i=i1;i<=i2;i++,u+=du) {
	 CALL_Begin(GET_DISPATCH(), (GL_LINE_STRIP));
	 for (v=v1,j=j1;j<=j2;j++,v+=dv) {
	    CALL_EvalCoord2f(GET_DISPATCH(), (u, v));
	 }
	 CALL_End(GET_DISPATCH(), ());
      }
      break;
   case GL_FILL:
      for (v=v1,j=j1;j<j2;j++,v+=dv) {
	 CALL_Begin(GET_DISPATCH(), (GL_TRIANGLE_STRIP));
	 for (u=u1,i=i1;i<=i2;i++,u+=du) {
	    CALL_EvalCoord2f(GET_DISPATCH(), (u, v));
	    CALL_EvalCoord2f(GET_DISPATCH(), (u, v+dv));
	 }
	 CALL_End(GET_DISPATCH(), ());
      }
      break;
   }
}


/**
 * Called from glDrawArrays when in immediate mode (not display list mode).
 */
static void GLAPIENTRY
vbo_exec_DrawArrays(GLenum mode, GLint start, GLsizei count)
{
   GET_CURRENT_CONTEXT(ctx);

   if (MESA_VERBOSE & VERBOSE_DRAW)
      _mesa_debug(ctx, "glDrawArrays(%s, %d, %d)\n",
                  _mesa_lookup_enum_by_nr(mode), start, count);

   if (!_mesa_validate_DrawArrays( ctx, mode, start, count ))
      return;

   if (0)
      check_draw_arrays_data(ctx, start, count);

   vbo_draw_arrays(ctx, mode, start, count, 1, 0);

   if (0)
      print_draw_arrays(ctx, mode, start, count);
}


/**
 * Called from glDrawArraysInstanced when in immediate mode (not
 * display list mode).
 */
static void GLAPIENTRY
vbo_exec_DrawArraysInstanced(GLenum mode, GLint start, GLsizei count,
                             GLsizei numInstances)
{
   GET_CURRENT_CONTEXT(ctx);

   if (MESA_VERBOSE & VERBOSE_DRAW)
      _mesa_debug(ctx, "glDrawArraysInstanced(%s, %d, %d, %d)\n",
                  _mesa_lookup_enum_by_nr(mode), start, count, numInstances);

   if (!_mesa_validate_DrawArraysInstanced(ctx, mode, start, count, numInstances))
      return;

   if (0)
      check_draw_arrays_data(ctx, start, count);

   vbo_draw_arrays(ctx, mode, start, count, numInstances, 0);

   if (0)
      print_draw_arrays(ctx, mode, start, count);
}


/**
 * Called from glDrawArraysInstancedBaseInstance when in immediate mode.
 */
static void GLAPIENTRY
vbo_exec_DrawArraysInstancedBaseInstance(GLenum mode, GLint first, GLsizei count,
                                         GLsizei numInstances, GLuint baseInstance)
{
   GET_CURRENT_CONTEXT(ctx);

   if (MESA_VERBOSE & VERBOSE_DRAW)
      _mesa_debug(ctx, "glDrawArraysInstancedBaseInstance(%s, %d, %d, %d, %d)\n",
                  _mesa_lookup_enum_by_nr(mode), first, count,
                  numInstances, baseInstance);

   if (!_mesa_validate_DrawArraysInstanced(ctx, mode, first, count,
                                           numInstances))
      return;

   if (0)
      check_draw_arrays_data(ctx, first, count);

   vbo_draw_arrays(ctx, mode, first, count, numInstances, baseInstance);

   if (0)
      print_draw_arrays(ctx, mode, first, count);
}



/**
 * Map GL_ELEMENT_ARRAY_BUFFER and print contents.
 * For debugging.
 */
#if 0
static void
dump_element_buffer(struct gl_context *ctx, GLenum type)
{
   const GLvoid *map =
      ctx->Driver.MapBufferRange(ctx, 0,
				 ctx->Array.VAO->IndexBufferObj->Size,
				 GL_MAP_READ_BIT,
                                 ctx->Array.VAO->IndexBufferObj,
                                 MAP_INTERNAL);
   switch (type) {
   case GL_UNSIGNED_BYTE:
      {
         const GLubyte *us = (const GLubyte *) map;
         GLint i;
         for (i = 0; i < ctx->Array.VAO->IndexBufferObj->Size; i++) {
            printf("%02x ", us[i]);
            if (i % 32 == 31)
               printf("\n");
         }
         printf("\n");
      }
      break;
   case GL_UNSIGNED_SHORT:
      {
         const GLushort *us = (const GLushort *) map;
         GLint i;
         for (i = 0; i < ctx->Array.VAO->IndexBufferObj->Size / 2; i++) {
            printf("%04x ", us[i]);
            if (i % 16 == 15)
               printf("\n");
         }
         printf("\n");
      }
      break;
   case GL_UNSIGNED_INT:
      {
         const GLuint *us = (const GLuint *) map;
         GLint i;
         for (i = 0; i < ctx->Array.VAO->IndexBufferObj->Size / 4; i++) {
            printf("%08x ", us[i]);
            if (i % 8 == 7)
               printf("\n");
         }
         printf("\n");
      }
      break;
   default:
      ;
   }

   ctx->Driver.UnmapBuffer(ctx, ctx->Array.VAO->IndexBufferObj,
                           MAP_INTERNAL);
}
#endif


/**
 * Inner support for both _mesa_DrawElements and _mesa_DrawRangeElements.
 * Do the rendering for a glDrawElements or glDrawRangeElements call after
 * we've validated buffer bounds, etc.
 */
static void
vbo_validated_drawrangeelements(struct gl_context *ctx, GLenum mode,
				GLboolean index_bounds_valid,
				GLuint start, GLuint end,
				GLsizei count, GLenum type,
				const GLvoid *indices,
				GLint basevertex, GLuint numInstances,
				GLuint baseInstance)
{
   struct vbo_context *vbo = vbo_context(ctx);
   struct vbo_exec_context *exec = &vbo->exec;
   struct _mesa_index_buffer ib;
   struct _mesa_prim prim[1];

   vbo_bind_arrays(ctx);

   ib.count = count;
   ib.type = type;
   ib.obj = ctx->Array.VAO->IndexBufferObj;
   ib.ptr = indices;

   prim[0].begin = 1;
   prim[0].end = 1;
   prim[0].weak = 0;
   prim[0].pad = 0;
   prim[0].mode = mode;
   prim[0].start = 0;
   prim[0].count = count;
   prim[0].indexed = 1;
   prim[0].is_indirect = 0;
   prim[0].basevertex = basevertex;
   prim[0].num_instances = numInstances;
   prim[0].base_instance = baseInstance;

   /* Need to give special consideration to rendering a range of
    * indices starting somewhere above zero.  Typically the
    * application is issuing multiple DrawRangeElements() to draw
    * successive primitives layed out linearly in the vertex arrays.
    * Unless the vertex arrays are all in a VBO (or locked as with
    * CVA), the OpenGL semantics imply that we need to re-read or
    * re-upload the vertex data on each draw call.  
    *
    * In the case of hardware tnl, we want to avoid starting the
    * upload at zero, as it will mean every draw call uploads an
    * increasing amount of not-used vertex data.  Worse - in the
    * software tnl module, all those vertices might be transformed and
    * lit but never rendered.
    *
    * If we just upload or transform the vertices in start..end,
    * however, the indices will be incorrect.
    *
    * At this level, we don't know exactly what the requirements of
    * the backend are going to be, though it will likely boil down to
    * either:
    *
    * 1) Do nothing, everything is in a VBO and is processed once
    *       only.
    *
    * 2) Adjust the indices and vertex arrays so that start becomes
    *    zero.
    *
    * Rather than doing anything here, I'll provide a helper function
    * for the latter case elsewhere.
    */

   check_buffers_are_unmapped(exec->array.inputs);
   vbo_handle_primitive_restart(ctx, prim, 1, &ib,
                                index_bounds_valid, start, end);

   if (MESA_DEBUG_FLAGS & DEBUG_ALWAYS_FLUSH) {
      _mesa_flush(ctx);
   }
}


/**
 * Called by glDrawRangeElementsBaseVertex() in immediate mode.
 */
static void GLAPIENTRY
vbo_exec_DrawRangeElementsBaseVertex(GLenum mode,
				     GLuint start, GLuint end,
				     GLsizei count, GLenum type,
				     const GLvoid *indices,
				     GLint basevertex)
{
   static GLuint warnCount = 0;
   GLboolean index_bounds_valid = GL_TRUE;
   GLuint max_element;
   GET_CURRENT_CONTEXT(ctx);

   if (MESA_VERBOSE & VERBOSE_DRAW)
      _mesa_debug(ctx,
                "glDrawRangeElementsBaseVertex(%s, %u, %u, %d, %s, %p, %d)\n",
                _mesa_lookup_enum_by_nr(mode), start, end, count,
                _mesa_lookup_enum_by_nr(type), indices, basevertex);

   if (!_mesa_validate_DrawRangeElements( ctx, mode, start, end, count,
                                          type, indices, basevertex ))
      return;

   if (ctx->Const.CheckArrayBounds) {
      /* _MaxElement was computed, so we can use it.
       * This path is used for drivers which need strict bounds checking.
       */
      max_element = ctx->Array.VAO->_MaxElement;
   }
   else {
      /* Generally, hardware drivers don't need to know the buffer bounds
       * if all vertex attributes are in VBOs.
       * However, if none of vertex attributes are in VBOs, _MaxElement
       * is always set to some random big number anyway, so bounds checking
       * is mostly useless.
       *
       * This is only useful to catch invalid values in the "end" parameter
       * like ~0.
       */
      max_element = 2 * 1000 * 1000 * 1000; /* just a big number */
   }

   if ((int) end + basevertex < 0 ||
       start + basevertex >= max_element) {
      /* The application requested we draw using a range of indices that's
       * outside the bounds of the current VBO.  This is invalid and appears
       * to give undefined results.  The safest thing to do is to simply
       * ignore the range, in case the application botched their range tracking
       * but did provide valid indices.  Also issue a warning indicating that
       * the application is broken.
       */
      if (warnCount++ < 10) {
         _mesa_warning(ctx, "glDrawRangeElements(start %u, end %u, "
                       "basevertex %d, count %d, type 0x%x, indices=%p):\n"
                       "\trange is outside VBO bounds (max=%u); ignoring.\n"
                       "\tThis should be fixed in the application.",
                       start, end, basevertex, count, type, indices,
                       max_element - 1);
      }
      index_bounds_valid = GL_FALSE;
   }

   /* NOTE: It's important that 'end' is a reasonable value.
    * in _tnl_draw_prims(), we use end to determine how many vertices
    * to transform.  If it's too large, we can unnecessarily split prims
    * or we can read/write out of memory in several different places!
    */

   /* Catch/fix some potential user errors */
   if (type == GL_UNSIGNED_BYTE) {
      start = MIN2(start, 0xff);
      end = MIN2(end, 0xff);
   }
   else if (type == GL_UNSIGNED_SHORT) {
      start = MIN2(start, 0xffff);
      end = MIN2(end, 0xffff);
   }

   if (0) {
      printf("glDraw[Range]Elements{,BaseVertex}"
	     "(start %u, end %u, type 0x%x, count %d) ElemBuf %u, "
	     "base %d\n",
	     start, end, type, count,
	     ctx->Array.VAO->IndexBufferObj->Name,
	     basevertex);
   }

   if ((int) start + basevertex < 0 ||
       end + basevertex >= max_element)
      index_bounds_valid = GL_FALSE;

#if 0
   check_draw_elements_data(ctx, count, type, indices);
#else
   (void) check_draw_elements_data;
#endif

   vbo_validated_drawrangeelements(ctx, mode, index_bounds_valid, start, end,
				   count, type, indices, basevertex, 1, 0);
}


/**
 * Called by glDrawRangeElements() in immediate mode.
 */
static void GLAPIENTRY
vbo_exec_DrawRangeElements(GLenum mode, GLuint start, GLuint end,
                           GLsizei count, GLenum type, const GLvoid *indices)
{
   if (MESA_VERBOSE & VERBOSE_DRAW) {
      GET_CURRENT_CONTEXT(ctx);
      _mesa_debug(ctx,
                  "glDrawRangeElements(%s, %u, %u, %d, %s, %p)\n",
                  _mesa_lookup_enum_by_nr(mode), start, end, count,
                  _mesa_lookup_enum_by_nr(type), indices);
   }

   vbo_exec_DrawRangeElementsBaseVertex(mode, start, end, count, type,
					indices, 0);
}


/**
 * Called by glDrawElements() in immediate mode.
 */
static void GLAPIENTRY
vbo_exec_DrawElements(GLenum mode, GLsizei count, GLenum type,
                      const GLvoid *indices)
{
   GET_CURRENT_CONTEXT(ctx);

   if (MESA_VERBOSE & VERBOSE_DRAW)
      _mesa_debug(ctx, "glDrawElements(%s, %u, %s, %p)\n",
                  _mesa_lookup_enum_by_nr(mode), count,
                  _mesa_lookup_enum_by_nr(type), indices);

   if (!_mesa_validate_DrawElements( ctx, mode, count, type, indices, 0 ))
      return;

   vbo_validated_drawrangeelements(ctx, mode, GL_FALSE, ~0, ~0,
				   count, type, indices, 0, 1, 0);
}


/**
 * Called by glDrawElementsBaseVertex() in immediate mode.
 */
static void GLAPIENTRY
vbo_exec_DrawElementsBaseVertex(GLenum mode, GLsizei count, GLenum type,
				const GLvoid *indices, GLint basevertex)
{
   GET_CURRENT_CONTEXT(ctx);

   if (MESA_VERBOSE & VERBOSE_DRAW)
      _mesa_debug(ctx, "glDrawElementsBaseVertex(%s, %d, %s, %p, %d)\n",
                  _mesa_lookup_enum_by_nr(mode), count,
                  _mesa_lookup_enum_by_nr(type), indices, basevertex);

   if (!_mesa_validate_DrawElements( ctx, mode, count, type, indices,
				     basevertex ))
      return;

   vbo_validated_drawrangeelements(ctx, mode, GL_FALSE, ~0, ~0,
				   count, type, indices, basevertex, 1, 0);
}


/**
 * Called by glDrawElementsInstanced() in immediate mode.
 */
static void GLAPIENTRY
vbo_exec_DrawElementsInstanced(GLenum mode, GLsizei count, GLenum type,
                               const GLvoid *indices, GLsizei numInstances)
{
   GET_CURRENT_CONTEXT(ctx);

   if (MESA_VERBOSE & VERBOSE_DRAW)
      _mesa_debug(ctx, "glDrawElementsInstanced(%s, %d, %s, %p, %d)\n",
                  _mesa_lookup_enum_by_nr(mode), count,
                  _mesa_lookup_enum_by_nr(type), indices, numInstances);

   if (!_mesa_validate_DrawElementsInstanced(ctx, mode, count, type, indices,
                                             numInstances, 0))
      return;

   vbo_validated_drawrangeelements(ctx, mode, GL_FALSE, ~0, ~0,
				   count, type, indices, 0, numInstances, 0);
}


/**
 * Called by glDrawElementsInstancedBaseVertex() in immediate mode.
 */
static void GLAPIENTRY
vbo_exec_DrawElementsInstancedBaseVertex(GLenum mode, GLsizei count, GLenum type,
                               const GLvoid *indices, GLsizei numInstances,
                               GLint basevertex)
{
   GET_CURRENT_CONTEXT(ctx);

   if (MESA_VERBOSE & VERBOSE_DRAW)
      _mesa_debug(ctx, "glDrawElementsInstancedBaseVertex(%s, %d, %s, %p, %d; %d)\n",
                  _mesa_lookup_enum_by_nr(mode), count,
                  _mesa_lookup_enum_by_nr(type), indices,
                  numInstances, basevertex);

   if (!_mesa_validate_DrawElementsInstanced(ctx, mode, count, type, indices,
                                             numInstances, basevertex))
      return;

   vbo_validated_drawrangeelements(ctx, mode, GL_FALSE, ~0, ~0,
				   count, type, indices, basevertex, numInstances, 0);
}


/**
 * Called by glDrawElementsInstancedBaseInstance() in immediate mode.
 */
static void GLAPIENTRY
vbo_exec_DrawElementsInstancedBaseInstance(GLenum mode, GLsizei count, GLenum type,
                                           const GLvoid *indices, GLsizei numInstances,
                                           GLuint baseInstance)
{
   GET_CURRENT_CONTEXT(ctx);

   if (MESA_VERBOSE & VERBOSE_DRAW)
      _mesa_debug(ctx, "glDrawElementsInstancedBaseInstance(%s, %d, %s, %p, %d, %d)\n",
                  _mesa_lookup_enum_by_nr(mode), count,
                  _mesa_lookup_enum_by_nr(type), indices,
                  numInstances, baseInstance);

   if (!_mesa_validate_DrawElementsInstanced(ctx, mode, count, type, indices,
                                             numInstances, 0))
      return;

   vbo_validated_drawrangeelements(ctx, mode, GL_FALSE, ~0, ~0,
                                   count, type, indices, 0, numInstances,
                                   baseInstance);
}


/**
 * Called by glDrawElementsInstancedBaseVertexBaseInstance() in immediate mode.
 */
static void GLAPIENTRY
vbo_exec_DrawElementsInstancedBaseVertexBaseInstance(GLenum mode, GLsizei count, GLenum type,
                                                     const GLvoid *indices, GLsizei numInstances,
                                                     GLint basevertex, GLuint baseInstance)
{
   GET_CURRENT_CONTEXT(ctx);

   if (MESA_VERBOSE & VERBOSE_DRAW)
      _mesa_debug(ctx, "glDrawElementsInstancedBaseVertexBaseInstance(%s, %d, %s, %p, %d, %d, %d)\n",
                  _mesa_lookup_enum_by_nr(mode), count,
                  _mesa_lookup_enum_by_nr(type), indices,
                  numInstances, basevertex, baseInstance);

   if (!_mesa_validate_DrawElementsInstanced(ctx, mode, count, type, indices,
                                             numInstances, basevertex))
      return;

   vbo_validated_drawrangeelements(ctx, mode, GL_FALSE, ~0, ~0,
                                   count, type, indices, basevertex, numInstances,
                                   baseInstance);
}


/**
 * Inner support for both _mesa_MultiDrawElements() and
 * _mesa_MultiDrawRangeElements().
 * This does the actual rendering after we've checked array indexes, etc.
 */
static void
vbo_validated_multidrawelements(struct gl_context *ctx, GLenum mode,
				const GLsizei *count, GLenum type,
				const GLvoid * const *indices,
				GLsizei primcount,
				const GLint *basevertex)
{
   struct vbo_context *vbo = vbo_context(ctx);
   struct vbo_exec_context *exec = &vbo->exec;
   struct _mesa_index_buffer ib;
   struct _mesa_prim *prim;
   unsigned int index_type_size = vbo_sizeof_ib_type(type);
   uintptr_t min_index_ptr, max_index_ptr;
   GLboolean fallback = GL_FALSE;
   int i;

   if (primcount == 0)
      return;

   prim = calloc(1, primcount * sizeof(*prim));
   if (prim == NULL) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glMultiDrawElements");
      return;
   }

   vbo_bind_arrays(ctx);

   min_index_ptr = (uintptr_t)indices[0];
   max_index_ptr = 0;
   for (i = 0; i < primcount; i++) {
      min_index_ptr = MIN2(min_index_ptr, (uintptr_t)indices[i]);
      max_index_ptr = MAX2(max_index_ptr, (uintptr_t)indices[i] +
			   index_type_size * count[i]);
   }

   /* Check if we can handle this thing as a bunch of index offsets from the
    * same index pointer.  If we can't, then we have to fall back to doing
    * a draw_prims per primitive.
    * Check that the difference between each prim's indexes is a multiple of
    * the index/element size.
    */
   if (index_type_size != 1) {
      for (i = 0; i < primcount; i++) {
	 if ((((uintptr_t)indices[i] - min_index_ptr) % index_type_size) != 0) {
	    fallback = GL_TRUE;
	    break;
	 }
      }
   }

   /* Draw primitives individually if one count is zero, so we can easily skip
    * that primitive.
    */
   for (i = 0; i < primcount; i++) {
      if (count[i] == 0) {
         fallback = GL_TRUE;
         break;
      }
   }

   /* If the index buffer isn't in a VBO, then treating the application's
    * subranges of the index buffer as one large index buffer may lead to
    * us reading unmapped memory.
    */
   if (!_mesa_is_bufferobj(ctx->Array.VAO->IndexBufferObj))
      fallback = GL_TRUE;

   if (!fallback) {
      ib.count = (max_index_ptr - min_index_ptr) / index_type_size;
      ib.type = type;
      ib.obj = ctx->Array.VAO->IndexBufferObj;
      ib.ptr = (void *)min_index_ptr;

      for (i = 0; i < primcount; i++) {
	 prim[i].begin = (i == 0);
	 prim[i].end = (i == primcount - 1);
	 prim[i].weak = 0;
	 prim[i].pad = 0;
	 prim[i].mode = mode;
	 prim[i].start = ((uintptr_t)indices[i] - min_index_ptr) / index_type_size;
	 prim[i].count = count[i];
	 prim[i].indexed = 1;
         prim[i].num_instances = 1;
         prim[i].base_instance = 0;
         prim[i].is_indirect = 0;
	 if (basevertex != NULL)
	    prim[i].basevertex = basevertex[i];
	 else
	    prim[i].basevertex = 0;
      }

      check_buffers_are_unmapped(exec->array.inputs);
      vbo_handle_primitive_restart(ctx, prim, primcount, &ib,
                                   GL_FALSE, ~0, ~0);
   } else {
      /* render one prim at a time */
      for (i = 0; i < primcount; i++) {
	 if (count[i] == 0)
	    continue;
	 ib.count = count[i];
	 ib.type = type;
	 ib.obj = ctx->Array.VAO->IndexBufferObj;
	 ib.ptr = indices[i];

	 prim[0].begin = 1;
	 prim[0].end = 1;
	 prim[0].weak = 0;
	 prim[0].pad = 0;
	 prim[0].mode = mode;
	 prim[0].start = 0;
	 prim[0].count = count[i];
	 prim[0].indexed = 1;
         prim[0].num_instances = 1;
         prim[0].base_instance = 0;
         prim[0].is_indirect = 0;
	 if (basevertex != NULL)
	    prim[0].basevertex = basevertex[i];
	 else
	    prim[0].basevertex = 0;

         check_buffers_are_unmapped(exec->array.inputs);
         vbo_handle_primitive_restart(ctx, prim, 1, &ib,
                                      GL_FALSE, ~0, ~0);
      }
   }

   free(prim);

   if (MESA_DEBUG_FLAGS & DEBUG_ALWAYS_FLUSH) {
      _mesa_flush(ctx);
   }
}


static void GLAPIENTRY
vbo_exec_MultiDrawElements(GLenum mode,
			   const GLsizei *count, GLenum type,
			   const GLvoid * const *indices,
			   GLsizei primcount)
{
   GET_CURRENT_CONTEXT(ctx);

   if (!_mesa_validate_MultiDrawElements(ctx, mode, count, type, indices,
                                         primcount, NULL))
      return;

   vbo_validated_multidrawelements(ctx, mode, count, type, indices, primcount,
				   NULL);
}


static void GLAPIENTRY
vbo_exec_MultiDrawElementsBaseVertex(GLenum mode,
				     const GLsizei *count, GLenum type,
				     const GLvoid * const *indices,
				     GLsizei primcount,
				     const GLsizei *basevertex)
{
   GET_CURRENT_CONTEXT(ctx);

   if (!_mesa_validate_MultiDrawElements(ctx, mode, count, type, indices,
                                         primcount, basevertex))
      return;

   vbo_validated_multidrawelements(ctx, mode, count, type, indices, primcount,
				   basevertex);
}

static void
vbo_draw_transform_feedback(struct gl_context *ctx, GLenum mode,
                            struct gl_transform_feedback_object *obj,
                            GLuint stream, GLuint numInstances)
{
   struct vbo_context *vbo = vbo_context(ctx);
   struct vbo_exec_context *exec = &vbo->exec;
   struct _mesa_prim prim[2];

   if (!_mesa_validate_DrawTransformFeedback(ctx, mode, obj, stream,
                                             numInstances)) {
      return;
   }

   if (ctx->Driver.GetTransformFeedbackVertexCount &&
       (ctx->Const.AlwaysUseGetTransformFeedbackVertexCount ||
        (ctx->Const.PrimitiveRestartInSoftware &&
         ctx->Array._PrimitiveRestart) ||
        !vbo_all_varyings_in_vbos(exec->array.inputs))) {
      GLsizei n = ctx->Driver.GetTransformFeedbackVertexCount(ctx, obj, stream);
      vbo_draw_arrays(ctx, mode, 0, n, numInstances, 0);
      return;
   }

   vbo_bind_arrays(ctx);

   /* init most fields to zero */
   memset(prim, 0, sizeof(prim));
   prim[0].begin = 1;
   prim[0].end = 1;
   prim[0].mode = mode;
   prim[0].num_instances = numInstances;
   prim[0].base_instance = 0;
   prim[0].is_indirect = 0;

   /* Maybe we should do some primitive splitting for primitive restart
    * (like in DrawArrays), but we have no way to know how many vertices
    * will be rendered. */

   check_buffers_are_unmapped(exec->array.inputs);
   vbo->draw_prims(ctx, prim, 1, NULL,
                   GL_TRUE, 0, 0, obj, NULL);

   if (MESA_DEBUG_FLAGS & DEBUG_ALWAYS_FLUSH) {
      _mesa_flush(ctx);
   }
}

/**
 * Like DrawArrays, but take the count from a transform feedback object.
 * \param mode  GL_POINTS, GL_LINES, GL_TRIANGLE_STRIP, etc.
 * \param name  the transform feedback object
 * User still has to setup of the vertex attribute info with
 * glVertexPointer, glColorPointer, etc.
 * Part of GL_ARB_transform_feedback2.
 */
static void GLAPIENTRY
vbo_exec_DrawTransformFeedback(GLenum mode, GLuint name)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_transform_feedback_object *obj =
      _mesa_lookup_transform_feedback_object(ctx, name);

   if (MESA_VERBOSE & VERBOSE_DRAW)
      _mesa_debug(ctx, "glDrawTransformFeedback(%s, %d)\n",
                  _mesa_lookup_enum_by_nr(mode), name);

   vbo_draw_transform_feedback(ctx, mode, obj, 0, 1);
}

static void GLAPIENTRY
vbo_exec_DrawTransformFeedbackStream(GLenum mode, GLuint name, GLuint stream)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_transform_feedback_object *obj =
      _mesa_lookup_transform_feedback_object(ctx, name);

   if (MESA_VERBOSE & VERBOSE_DRAW)
      _mesa_debug(ctx, "glDrawTransformFeedbackStream(%s, %u, %u)\n",
                  _mesa_lookup_enum_by_nr(mode), name, stream);

   vbo_draw_transform_feedback(ctx, mode, obj, stream, 1);
}

static void GLAPIENTRY
vbo_exec_DrawTransformFeedbackInstanced(GLenum mode, GLuint name,
                                        GLsizei primcount)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_transform_feedback_object *obj =
      _mesa_lookup_transform_feedback_object(ctx, name);

   if (MESA_VERBOSE & VERBOSE_DRAW)
      _mesa_debug(ctx, "glDrawTransformFeedbackInstanced(%s, %d)\n",
                  _mesa_lookup_enum_by_nr(mode), name);

   vbo_draw_transform_feedback(ctx, mode, obj, 0, primcount);
}

static void GLAPIENTRY
vbo_exec_DrawTransformFeedbackStreamInstanced(GLenum mode, GLuint name,
                                              GLuint stream, GLsizei primcount)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_transform_feedback_object *obj =
      _mesa_lookup_transform_feedback_object(ctx, name);

   if (MESA_VERBOSE & VERBOSE_DRAW)
      _mesa_debug(ctx, "glDrawTransformFeedbackStreamInstanced"
                  "(%s, %u, %u, %i)\n",
                  _mesa_lookup_enum_by_nr(mode), name, stream, primcount);

   vbo_draw_transform_feedback(ctx, mode, obj, stream, primcount);
}

static void
vbo_validated_drawarraysindirect(struct gl_context *ctx,
                                 GLenum mode, const GLvoid *indirect)
{
   struct vbo_context *vbo = vbo_context(ctx);
   struct vbo_exec_context *exec = &vbo->exec;
   struct _mesa_prim prim[1];

   vbo_bind_arrays(ctx);

   memset(prim, 0, sizeof(prim));
   prim[0].begin = 1;
   prim[0].end = 1;
   prim[0].mode = mode;
   prim[0].is_indirect = 1;
   prim[0].indirect_offset = (GLsizeiptr)indirect;

   /* NOTE: We do NOT want to handle primitive restart here, nor perform any
    * other checks that require knowledge of the values in the command buffer.
    * That would defeat the whole purpose of this function.
    */

   check_buffers_are_unmapped(exec->array.inputs);
   vbo->draw_prims(ctx, prim, 1,
                   NULL, GL_TRUE, 0, ~0,
                   NULL,
                   ctx->DrawIndirectBuffer);

   if (MESA_DEBUG_FLAGS & DEBUG_ALWAYS_FLUSH)
      _mesa_flush(ctx);
}

static void
vbo_validated_multidrawarraysindirect(struct gl_context *ctx,
                                      GLenum mode,
                                      const GLvoid *indirect,
                                      GLsizei primcount, GLsizei stride)
{
   struct vbo_context *vbo = vbo_context(ctx);
   struct vbo_exec_context *exec = &vbo->exec;
   struct _mesa_prim *prim;
   GLsizei i;
   GLsizeiptr offset = (GLsizeiptr)indirect;

   if (primcount == 0)
      return;
   prim = calloc(primcount, sizeof(*prim));
   if (prim == NULL) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glMultiDrawArraysIndirect");
      return;
   }

   vbo_bind_arrays(ctx);

   prim[0].begin = 1;
   prim[primcount - 1].end = 1;
   for (i = 0; i < primcount; ++i, offset += stride) {
      prim[i].mode = mode;
      prim[i].indirect_offset = offset;
      prim[i].is_indirect = 1;
   }

   check_buffers_are_unmapped(exec->array.inputs);
   vbo->draw_prims(ctx, prim, primcount,
                   NULL, GL_TRUE, 0, ~0,
                   NULL,
                   ctx->DrawIndirectBuffer);

   free(prim);

   if (MESA_DEBUG_FLAGS & DEBUG_ALWAYS_FLUSH)
      _mesa_flush(ctx);
}

static void
vbo_validated_drawelementsindirect(struct gl_context *ctx,
                                   GLenum mode, GLenum type,
                                   const GLvoid *indirect)
{
   struct vbo_context *vbo = vbo_context(ctx);
   struct vbo_exec_context *exec = &vbo->exec;
   struct _mesa_index_buffer ib;
   struct _mesa_prim prim[1];

   vbo_bind_arrays(ctx);

   ib.count = 0; /* unknown */
   ib.type = type;
   ib.obj = ctx->Array.VAO->IndexBufferObj;
   ib.ptr = NULL;

   memset(prim, 0, sizeof(prim));
   prim[0].begin = 1;
   prim[0].end = 1;
   prim[0].mode = mode;
   prim[0].indexed = 1;
   prim[0].indirect_offset = (GLsizeiptr)indirect;
   prim[0].is_indirect = 1;

   check_buffers_are_unmapped(exec->array.inputs);
   vbo->draw_prims(ctx, prim, 1,
                   &ib, GL_TRUE, 0, ~0,
                   NULL,
                   ctx->DrawIndirectBuffer);

   if (MESA_DEBUG_FLAGS & DEBUG_ALWAYS_FLUSH)
      _mesa_flush(ctx);
}

static void
vbo_validated_multidrawelementsindirect(struct gl_context *ctx,
                                        GLenum mode, GLenum type,
                                        const GLvoid *indirect,
                                        GLsizei primcount, GLsizei stride)
{
   struct vbo_context *vbo = vbo_context(ctx);
   struct vbo_exec_context *exec = &vbo->exec;
   struct _mesa_index_buffer ib;
   struct _mesa_prim *prim;
   GLsizei i;
   GLsizeiptr offset = (GLsizeiptr)indirect;

   if (primcount == 0)
      return;
   prim = calloc(primcount, sizeof(*prim));
   if (prim == NULL) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glMultiDrawElementsIndirect");
      return;
   }

   vbo_bind_arrays(ctx);

   /* NOTE: IndexBufferObj is guaranteed to be a VBO. */

   ib.count = 0; /* unknown */
   ib.type = type;
   ib.obj = ctx->Array.VAO->IndexBufferObj;
   ib.ptr = NULL;

   prim[0].begin = 1;
   prim[primcount - 1].end = 1;
   for (i = 0; i < primcount; ++i, offset += stride) {
      prim[i].mode = mode;
      prim[i].indexed = 1;
      prim[i].indirect_offset = offset;
      prim[i].is_indirect = 1;
   }

   check_buffers_are_unmapped(exec->array.inputs);
   vbo->draw_prims(ctx, prim, primcount,
                   &ib, GL_TRUE, 0, ~0,
                   NULL,
                   ctx->DrawIndirectBuffer);

   free(prim);

   if (MESA_DEBUG_FLAGS & DEBUG_ALWAYS_FLUSH)
      _mesa_flush(ctx);
}

/**
 * Like [Multi]DrawArrays/Elements, but they take most arguments from
 * a buffer object.
 */
static void GLAPIENTRY
vbo_exec_DrawArraysIndirect(GLenum mode, const GLvoid *indirect)
{
   GET_CURRENT_CONTEXT(ctx);

   if (MESA_VERBOSE & VERBOSE_DRAW)
      _mesa_debug(ctx, "glDrawArraysIndirect(%s, %p)\n",
                  _mesa_lookup_enum_by_nr(mode), indirect);

   if (!_mesa_validate_DrawArraysIndirect(ctx, mode, indirect))
      return;

   vbo_validated_drawarraysindirect(ctx, mode, indirect);
}

static void GLAPIENTRY
vbo_exec_DrawElementsIndirect(GLenum mode, GLenum type,
                              const GLvoid *indirect)
{
   GET_CURRENT_CONTEXT(ctx);

   if (MESA_VERBOSE & VERBOSE_DRAW)
      _mesa_debug(ctx, "glDrawElementsIndirect(%s, %s, %p)\n",
                  _mesa_lookup_enum_by_nr(mode),
                  _mesa_lookup_enum_by_nr(type), indirect);

   if (!_mesa_validate_DrawElementsIndirect(ctx, mode, type, indirect))
      return;

   vbo_validated_drawelementsindirect(ctx, mode, type, indirect);
}

static void GLAPIENTRY
vbo_exec_MultiDrawArraysIndirect(GLenum mode,
                                 const GLvoid *indirect,
                                 GLsizei primcount, GLsizei stride)
{
   GET_CURRENT_CONTEXT(ctx);

   if (MESA_VERBOSE & VERBOSE_DRAW)
      _mesa_debug(ctx, "glMultiDrawArraysIndirect(%s, %p, %i, %i)\n",
                  _mesa_lookup_enum_by_nr(mode), indirect, primcount, stride);

   /* If <stride> is zero, the array elements are treated as tightly packed. */
   if (stride == 0)
      stride = 4 * sizeof(GLuint); /* sizeof(DrawArraysIndirectCommand) */

   if (!_mesa_validate_MultiDrawArraysIndirect(ctx, mode,
                                               indirect,
                                               primcount, stride))
      return;

   vbo_validated_multidrawarraysindirect(ctx, mode,
                                         indirect,
                                         primcount, stride);
}

static void GLAPIENTRY
vbo_exec_MultiDrawElementsIndirect(GLenum mode, GLenum type,
                                   const GLvoid *indirect,
                                   GLsizei primcount, GLsizei stride)
{
   GET_CURRENT_CONTEXT(ctx);

   if (MESA_VERBOSE & VERBOSE_DRAW)
      _mesa_debug(ctx, "glMultiDrawElementsIndirect(%s, %s, %p, %i, %i)\n",
                  _mesa_lookup_enum_by_nr(mode),
                  _mesa_lookup_enum_by_nr(type), indirect, primcount, stride);

   /* If <stride> is zero, the array elements are treated as tightly packed. */
   if (stride == 0)
      stride = 5 * sizeof(GLuint); /* sizeof(DrawElementsIndirectCommand) */

   if (!_mesa_validate_MultiDrawElementsIndirect(ctx, mode, type,
                                                 indirect,
                                                 primcount, stride))
      return;

   vbo_validated_multidrawelementsindirect(ctx, mode, type,
                                           indirect,
                                           primcount, stride);
}

/**
 * Initialize the dispatch table with the VBO functions for drawing.
 */
void
vbo_initialize_exec_dispatch(const struct gl_context *ctx,
                             struct _glapi_table *exec)
{
   SET_DrawArrays(exec, vbo_exec_DrawArrays);
   SET_DrawElements(exec, vbo_exec_DrawElements);

   if (_mesa_is_desktop_gl(ctx) || _mesa_is_gles3(ctx)) {
      SET_DrawRangeElements(exec, vbo_exec_DrawRangeElements);
   }

   SET_MultiDrawElementsEXT(exec, vbo_exec_MultiDrawElements);

   if (ctx->API == API_OPENGL_COMPAT) {
      SET_Rectf(exec, vbo_exec_Rectf);
      SET_EvalMesh1(exec, vbo_exec_EvalMesh1);
      SET_EvalMesh2(exec, vbo_exec_EvalMesh2);
   }

   if (_mesa_is_desktop_gl(ctx)) {
      SET_DrawElementsBaseVertex(exec, vbo_exec_DrawElementsBaseVertex);
      SET_DrawRangeElementsBaseVertex(exec, vbo_exec_DrawRangeElementsBaseVertex);
      SET_MultiDrawElementsBaseVertex(exec, vbo_exec_MultiDrawElementsBaseVertex);
      SET_DrawArraysInstancedBaseInstance(exec, vbo_exec_DrawArraysInstancedBaseInstance);
      SET_DrawElementsInstancedBaseInstance(exec, vbo_exec_DrawElementsInstancedBaseInstance);
      SET_DrawElementsInstancedBaseVertex(exec, vbo_exec_DrawElementsInstancedBaseVertex);
      SET_DrawElementsInstancedBaseVertexBaseInstance(exec, vbo_exec_DrawElementsInstancedBaseVertexBaseInstance);
   }

   if (ctx->API == API_OPENGL_CORE) {
      SET_DrawArraysIndirect(exec, vbo_exec_DrawArraysIndirect);
      SET_DrawElementsIndirect(exec, vbo_exec_DrawElementsIndirect);
      SET_MultiDrawArraysIndirect(exec, vbo_exec_MultiDrawArraysIndirect);
      SET_MultiDrawElementsIndirect(exec, vbo_exec_MultiDrawElementsIndirect);
   }

   if (_mesa_is_desktop_gl(ctx) || _mesa_is_gles3(ctx)) {
      SET_DrawArraysInstancedARB(exec, vbo_exec_DrawArraysInstanced);
      SET_DrawElementsInstancedARB(exec, vbo_exec_DrawElementsInstanced);
   }

   if (_mesa_is_desktop_gl(ctx)) {
      SET_DrawTransformFeedback(exec, vbo_exec_DrawTransformFeedback);
      SET_DrawTransformFeedbackStream(exec, vbo_exec_DrawTransformFeedbackStream);
      SET_DrawTransformFeedbackInstanced(exec, vbo_exec_DrawTransformFeedbackInstanced);
      SET_DrawTransformFeedbackStreamInstanced(exec, vbo_exec_DrawTransformFeedbackStreamInstanced);
   }
}



/**
 * The following functions are only used for OpenGL ES 1/2 support.
 * And some aren't even supported (yet) in ES 1/2.
 */


void GLAPIENTRY
_mesa_DrawArrays(GLenum mode, GLint first, GLsizei count)
{
   vbo_exec_DrawArrays(mode, first, count);
}


void GLAPIENTRY
_mesa_DrawElements(GLenum mode, GLsizei count, GLenum type,
                   const GLvoid *indices)
{
   vbo_exec_DrawElements(mode, count, type, indices);
}


void GLAPIENTRY
_mesa_DrawElementsBaseVertex(GLenum mode, GLsizei count, GLenum type,
			     const GLvoid *indices, GLint basevertex)
{
   vbo_exec_DrawElementsBaseVertex(mode, count, type, indices, basevertex);
}


void GLAPIENTRY
_mesa_DrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count,
                        GLenum type, const GLvoid *indices)
{
   vbo_exec_DrawRangeElements(mode, start, end, count, type, indices);
}


void GLAPIENTRY
_mesa_DrawRangeElementsBaseVertex(GLenum mode, GLuint start, GLuint end,
				  GLsizei count, GLenum type,
				  const GLvoid *indices, GLint basevertex)
{
   vbo_exec_DrawRangeElementsBaseVertex(mode, start, end, count, type,
					indices, basevertex);
}


void GLAPIENTRY
_mesa_MultiDrawElementsEXT(GLenum mode, const GLsizei *count, GLenum type,
			   const GLvoid **indices, GLsizei primcount)
{
   vbo_exec_MultiDrawElements(mode, count, type, indices, primcount);
}


void GLAPIENTRY
_mesa_MultiDrawElementsBaseVertex(GLenum mode,
				  const GLsizei *count, GLenum type,
				  const GLvoid **indices, GLsizei primcount,
				  const GLint *basevertex)
{
   vbo_exec_MultiDrawElementsBaseVertex(mode, count, type, indices,
					primcount, basevertex);
}

void GLAPIENTRY
_mesa_DrawTransformFeedback(GLenum mode, GLuint name)
{
   vbo_exec_DrawTransformFeedback(mode, name);
}
@


1.11
log
@Merge Mesa 10.2.9
@
text
@@


1.10
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a38 2
#include "main/sse_minmax.h"
#include "x86/common_x86_asm.h"
d122 3
a124 3
#if defined(USE_SSE41)
         if (cpu_has_sse4_1) {
            _mesa_uint_array_min_max(ui_indices, &min_ui, &max_ui, count);
a125 6
         else
#endif
            for (i = 0; i < count; i++) {
               if (ui_indices[i] > max_ui) max_ui = ui_indices[i];
               if (ui_indices[i] < min_ui) min_ui = ui_indices[i];
            }
d565 32
d623 1
a623 2
   if (ctx->Array.PrimitiveRestart && !ctx->Array.PrimitiveRestartFixedIndex &&
       ctx->Array.RestartIndex < count) {
d1014 2
a1015 2
   vbo->draw_prims(ctx, prim, 1, &ib,
                   index_bounds_valid, start, end, NULL, NULL);
d1035 1
a1035 6

   /* This is only useful to catch invalid values in the "end" parameter
    * like ~0.
    */
   GLuint max_element = 2 * 1000 * 1000 * 1000; /* just a big number */

d1048 19
d1316 1
a1316 1
   prim = calloc(primcount, sizeof(*prim));
d1389 2
a1390 2
      vbo->draw_prims(ctx, prim, primcount, &ib,
                      false, ~0, ~0, NULL, NULL);
d1418 2
a1419 2
         vbo->draw_prims(ctx, prim, 1, &ib,
                         false, ~0, ~0, NULL, NULL);
d1481 2
a1892 6
void GLAPIENTRY
_mesa_DrawArraysInstanced(GLenum mode, GLint first, GLsizei count,
                          GLsizei primcount)
{
   vbo_exec_DrawArraysInstanced(mode, first, count, primcount);
}
@


1.9
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d39 2
d124 3
a126 3
         for (i = 0; i < count; i++) {
            if (ui_indices[i] > max_ui) max_ui = ui_indices[i];
            if (ui_indices[i] < min_ui) min_ui = ui_indices[i];
d128 6
a572 32

/**
 * Handle a draw case that potentially has primitive restart enabled.
 *
 * If primitive restart is enabled, and PrimitiveRestartInSoftware is
 * set, then vbo_sw_primitive_restart is used to handle the primitive
 * restart case in software.
 */
static void
vbo_handle_primitive_restart(struct gl_context *ctx,
                             const struct _mesa_prim *prim,
                             GLuint nr_prims,
                             const struct _mesa_index_buffer *ib,
                             GLboolean index_bounds_valid,
                             GLuint min_index,
                             GLuint max_index)
{
   struct vbo_context *vbo = vbo_context(ctx);

   if ((ib != NULL) &&
       ctx->Const.PrimitiveRestartInSoftware &&
       ctx->Array._PrimitiveRestart) {
      /* Handle primitive restart in software */
      vbo_sw_primitive_restart(ctx, prim, nr_prims, ib, NULL);
   } else {
      /* Call driver directly for draw_prims */
      vbo->draw_prims(ctx, prim, nr_prims, ib,
                      index_bounds_valid, min_index, max_index, NULL, NULL);
   }
}


d599 2
a600 1
   if (ctx->Array.PrimitiveRestart && ctx->Array.RestartIndex < count) {
d991 2
a992 2
   vbo_handle_primitive_restart(ctx, prim, 1, &ib,
                                index_bounds_valid, start, end);
d1012 6
a1017 1
   GLuint max_element;
a1029 19
   if (ctx->Const.CheckArrayBounds) {
      /* _MaxElement was computed, so we can use it.
       * This path is used for drivers which need strict bounds checking.
       */
      max_element = ctx->Array.VAO->_MaxElement;
   }
   else {
      /* Generally, hardware drivers don't need to know the buffer bounds
       * if all vertex attributes are in VBOs.
       * However, if none of vertex attributes are in VBOs, _MaxElement
       * is always set to some random big number anyway, so bounds checking
       * is mostly useless.
       *
       * This is only useful to catch invalid values in the "end" parameter
       * like ~0.
       */
      max_element = 2 * 1000 * 1000 * 1000; /* just a big number */
   }

d1279 1
a1279 1
   prim = calloc(1, primcount * sizeof(*prim));
d1352 2
a1353 2
      vbo_handle_primitive_restart(ctx, prim, primcount, &ib,
                                   GL_FALSE, ~0, ~0);
d1381 2
a1382 2
         vbo_handle_primitive_restart(ctx, prim, 1, &ib,
                                      GL_FALSE, ~0, ~0);
a1443 2
        (ctx->Const.PrimitiveRestartInSoftware &&
         ctx->Array._PrimitiveRestart) ||
d1854 6
@


1.8
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
d22 1
a22 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
d56 1
a56 1
         assert(!_mesa_bufferobj_mapped(obj));
d76 1
a76 1
   assert(!_mesa_bufferobj_mapped(exec->vtx.bufferobj));
d104 2
a105 1
                                           GL_MAP_READ_BIT, ib->obj);
d181 1
a181 1
      ctx->Driver.UnmapBuffer(ctx, ib->obj);
d233 1
a233 1
         if (!array->BufferObj->Pointer) {
d235 1
a235 1
            array->BufferObj->Pointer =
d237 2
a238 1
					  GL_MAP_READ_BIT, array->BufferObj);
d240 2
a241 1
         data = ADD_POINTERS(data, array->BufferObj->Pointer);
d279 2
a280 2
       _mesa_bufferobj_mapped(array->BufferObj)) {
      ctx->Driver.UnmapBuffer(ctx, array->BufferObj);
d293 1
a293 1
   struct gl_array_object *arrayObj = ctx->Array.ArrayObj;
d297 1
a297 1
   if (_mesa_is_bufferobj(ctx->Array.ArrayObj->ElementArrayBufferObj)) {
d299 1
a299 1
					   ctx->Array.ArrayObj->ElementArrayBufferObj->Size,
d301 2
a302 1
					   ctx->Array.ArrayObj->ElementArrayBufferObj);
d325 2
a326 2
      for (k = 0; k < Elements(arrayObj->VertexAttrib); k++) {
         check_array_data(ctx, &arrayObj->VertexAttrib[k], k, j);
d330 3
a332 2
   if (_mesa_is_bufferobj(arrayObj->ElementArrayBufferObj)) {
      ctx->Driver.UnmapBuffer(ctx, ctx->Array.ArrayObj->ElementArrayBufferObj);
d335 2
a336 2
   for (k = 0; k < Elements(arrayObj->VertexAttrib); k++) {
      unmap_array_buffer(ctx, &arrayObj->VertexAttrib[k]);
d360 1
a360 1
   struct gl_array_object *arrayObj = ctx->Array.ArrayObj;
d376 1
a376 1
	     arrayObj->VertexAttrib[VERT_ATTRIB_FF(i)].Enabled,
d382 2
a383 1
						 GL_MAP_READ_BIT, bufObj);
d395 1
a395 1
         ctx->Driver.UnmapBuffer(ctx, bufObj);
d414 1
a414 1
   struct gl_client_array *vertexAttrib = ctx->Array.ArrayObj->VertexAttrib;
d588 1
a588 1
      vbo_sw_primitive_restart(ctx, prim, nr_prims, ib);
d592 1
a592 1
                      index_bounds_valid, min_index, max_index, NULL);
d620 1
d658 1
a658 1
                         GL_TRUE, start, start + count - 1, NULL);
d669 1
a669 1
                      NULL);
d892 1
a892 1
				 ctx->Array.ArrayObj->ElementArrayBufferObj->Size,
d894 2
a895 1
				 ctx->Array.ArrayObj->ElementArrayBufferObj);
d901 1
a901 1
         for (i = 0; i < ctx->Array.ArrayObj->ElementArrayBufferObj->Size; i++) {
d913 1
a913 1
         for (i = 0; i < ctx->Array.ArrayObj->ElementArrayBufferObj->Size / 2; i++) {
d925 1
a925 1
         for (i = 0; i < ctx->Array.ArrayObj->ElementArrayBufferObj->Size / 4; i++) {
d937 2
a938 1
   ctx->Driver.UnmapBuffer(ctx, ctx->Array.ArrayObj->ElementArrayBufferObj);
d966 1
a966 1
   ib.obj = ctx->Array.ArrayObj->ElementArrayBufferObj;
d977 1
d1052 1
a1052 1
      max_element = ctx->Array.ArrayObj->_MaxElement;
d1108 1
a1108 1
	     ctx->Array.ArrayObj->ElementArrayBufferObj->Name,
d1347 10
d1361 1
a1361 1
   if (!_mesa_is_bufferobj(ctx->Array.ArrayObj->ElementArrayBufferObj))
d1367 1
a1367 1
      ib.obj = ctx->Array.ArrayObj->ElementArrayBufferObj;
d1381 1
d1394 2
d1398 1
a1398 1
	 ib.obj = ctx->Array.ArrayObj->ElementArrayBufferObj;
d1411 1
d1479 10
d1498 1
d1506 1
a1506 1
                   GL_TRUE, 0, 0, obj);
d1580 246
d1857 7
@


1.7
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d33 1
d38 1
d87 1
a87 1
void
d91 2
a92 1
		     GLuint *min_index, GLuint *max_index)
d94 4
a97 4
   const GLboolean restart = ctx->Array.PrimitiveRestart;
   const GLuint restartIndex = ctx->Array.RestartIndex;
   const GLuint count = prim->count;
   const void *indices;
d100 1
d102 3
a104 6
      const GLvoid *map =
         ctx->Driver.MapBuffer(ctx, GL_ELEMENT_ARRAY_BUFFER_ARB,
                               GL_READ_ONLY, ib->obj);
      indices = ADD_POINTERS(map, ib->ptr);
   } else {
      indices = ib->ptr;
d180 36
a215 1
      ctx->Driver.UnmapBuffer(ctx, GL_ELEMENT_ARRAY_BUFFER_ARB, ib->obj);
d235 2
a236 2
               ctx->Driver.MapBuffer(ctx, GL_ARRAY_BUFFER_ARB,
                                     GL_READ_ONLY, array->BufferObj);
d277 1
a277 1
      ctx->Driver.UnmapBuffer(ctx, GL_ARRAY_BUFFER_ARB, array->BufferObj);
d294 5
a298 5
   if (_mesa_is_bufferobj(ctx->Array.ElementArrayBufferObj)) {
      elemMap = ctx->Driver.MapBuffer(ctx,
                                      GL_ELEMENT_ARRAY_BUFFER_ARB,
                                      GL_READ_ONLY,
                                      ctx->Array.ElementArrayBufferObj);
a320 7
      check_array_data(ctx, &arrayObj->Vertex, VERT_ATTRIB_POS, j);
      check_array_data(ctx, &arrayObj->Normal, VERT_ATTRIB_NORMAL, j);
      check_array_data(ctx, &arrayObj->Color, VERT_ATTRIB_COLOR0, j);
      check_array_data(ctx, &arrayObj->SecondaryColor, VERT_ATTRIB_COLOR1, j);
      for (k = 0; k < Elements(arrayObj->TexCoord); k++) {
         check_array_data(ctx, &arrayObj->TexCoord[k], VERT_ATTRIB_TEX0 + k, j);
      }
d322 1
a322 2
         check_array_data(ctx, &arrayObj->VertexAttrib[k],
                          VERT_ATTRIB_GENERIC0 + k, j);
d326 2
a327 3
   if (_mesa_is_bufferobj(ctx->Array.ElementArrayBufferObj)) {
      ctx->Driver.UnmapBuffer(ctx, GL_ELEMENT_ARRAY_BUFFER_ARB,
			      ctx->Array.ElementArrayBufferObj);
a329 6
   unmap_array_buffer(ctx, &arrayObj->Vertex);
   unmap_array_buffer(ctx, &arrayObj->Normal);
   unmap_array_buffer(ctx, &arrayObj->Color);
   for (k = 0; k < Elements(arrayObj->TexCoord); k++) {
      unmap_array_buffer(ctx, &arrayObj->TexCoord[k]);
   }
d355 1
d371 1
a371 1
	     exec->array.legacy_array[i]->Enabled,
d376 2
a377 2
         GLubyte *p = ctx->Driver.MapBuffer(ctx, GL_ARRAY_BUFFER_ARB,
                                            GL_READ_ONLY_ARB, bufObj);
d389 1
a389 1
         ctx->Driver.UnmapBuffer(ctx, GL_ARRAY_BUFFER_ARB, bufObj);
a395 43
 * Bind the VBO executor to the current vertex array object prior
 * to drawing.
 *
 * Just translate the arrayobj into a sane layout.
 */
static void
bind_array_obj(struct gl_context *ctx)
{
   struct vbo_context *vbo = vbo_context(ctx);
   struct vbo_exec_context *exec = &vbo->exec;
   struct gl_array_object *arrayObj = ctx->Array.ArrayObj;
   GLuint i;

   /* TODO: Fix the ArrayObj struct to keep legacy arrays in an array
    * rather than as individual named arrays.  Then this function can
    * go away.
    */
   exec->array.legacy_array[VERT_ATTRIB_POS] = &arrayObj->Vertex;
   exec->array.legacy_array[VERT_ATTRIB_WEIGHT] = &arrayObj->Weight;
   exec->array.legacy_array[VERT_ATTRIB_NORMAL] = &arrayObj->Normal;
   exec->array.legacy_array[VERT_ATTRIB_COLOR0] = &arrayObj->Color;
   exec->array.legacy_array[VERT_ATTRIB_COLOR1] = &arrayObj->SecondaryColor;
   exec->array.legacy_array[VERT_ATTRIB_FOG] = &arrayObj->FogCoord;
   exec->array.legacy_array[VERT_ATTRIB_COLOR_INDEX] = &arrayObj->Index;
   if (arrayObj->PointSize.Enabled) {
      /* this aliases COLOR_INDEX */
      exec->array.legacy_array[VERT_ATTRIB_POINT_SIZE] = &arrayObj->PointSize;
   }
   exec->array.legacy_array[VERT_ATTRIB_EDGEFLAG] = &arrayObj->EdgeFlag;

   for (i = 0; i < Elements(arrayObj->TexCoord); i++)
      exec->array.legacy_array[VERT_ATTRIB_TEX0 + i] = &arrayObj->TexCoord[i];

   for (i = 0; i < Elements(arrayObj->VertexAttrib); i++) {
      assert(i < Elements(exec->array.generic_array));
      exec->array.generic_array[i] = &arrayObj->VertexAttrib[i];
   }
   
   exec->array.array_obj = arrayObj->Name;
}


/**
d408 1
d410 1
a410 1
   GLbitfield const_inputs = 0x0;
d413 1
a413 4
   exec->array.program_mode = get_program_mode(ctx);
   exec->array.enabled_flags = ctx->Array.ArrayObj->_Enabled;

   switch (exec->array.program_mode) {
d420 3
a422 3
      for (i = 0; i <= VERT_ATTRIB_TEX7; i++) {
	 if (exec->array.legacy_array[i]->Enabled)
	    inputs[i] = exec->array.legacy_array[i];
d424 2
a425 2
	    inputs[i] = &vbo->legacy_currval[i];
            const_inputs |= 1 << i;
d430 3
a432 2
	 inputs[VERT_ATTRIB_GENERIC0 + i] = &vbo->mat_currval[i];
         const_inputs |= 1 << (VERT_ATTRIB_GENERIC0 + i);
d438 3
a440 3
      for (i = MAT_ATTRIB_MAX; i < VERT_ATTRIB_MAX - VERT_ATTRIB_GENERIC0; i++) {
	 inputs[VERT_ATTRIB_GENERIC0 + i] = &vbo->generic_currval[i];
         const_inputs |= 1 << (VERT_ATTRIB_GENERIC0 + i);
a441 8

      /* There is no need to make _NEW_ARRAY dirty here for the TnL program,
       * because it already takes care of invalidating the state necessary
       * to revalidate vertex arrays. Not marking the state as dirty also
       * improves performance (quite significantly in some apps).
       */
      if (!ctx->VertexProgram._MaintainTnlProgram)
         ctx->NewState |= _NEW_ARRAY;
d444 4
a447 18
   case VP_NV:
      /* NV_vertex_program - attribute arrays alias and override
       * conventional, legacy arrays.  No materials, and the generic
       * slots are vacant.
       */
      for (i = 0; i <= VERT_ATTRIB_TEX7; i++) {
	 if (exec->array.generic_array[i]->Enabled)
	    inputs[i] = exec->array.generic_array[i];
	 else if (exec->array.legacy_array[i]->Enabled)
	    inputs[i] = exec->array.legacy_array[i];
	 else {
	    inputs[i] = &vbo->legacy_currval[i];
            const_inputs |= 1 << i;
         }
      }

      /* Could use just about anything, just to fill in the empty
       * slots:
d449 1
a449 7
      for (i = VERT_ATTRIB_GENERIC0; i < VERT_ATTRIB_MAX; i++) {
	 inputs[i] = &vbo->generic_currval[i - VERT_ATTRIB_GENERIC0];
         const_inputs |= 1 << i;
      }

      ctx->NewState |= _NEW_ARRAY;
      break;
d451 1
a451 2
   case VP_ARB:
      /* GL_ARB_vertex_program or GLSL vertex shader - Only the generic[0]
a452 1
       *
d456 3
d460 39
a498 8
      if (exec->array.generic_array[0]->Enabled)
	 inputs[0] = exec->array.generic_array[0];
      else if (exec->array.legacy_array[0]->Enabled)
	 inputs[0] = exec->array.legacy_array[0];
      else {
	 inputs[0] = &vbo->legacy_currval[0];
         const_inputs |= 1 << 0;
      }
d500 2
a501 6
      for (i = 1; i <= VERT_ATTRIB_TEX7; i++) {
	 if (exec->array.legacy_array[i]->Enabled)
	    inputs[i] = exec->array.legacy_array[i];
	 else {
	    inputs[i] = &vbo->legacy_currval[i];
            const_inputs |= 1 << i;
a502 1
      }
d504 9
a512 6
      for (i = 0; i < MAX_VERTEX_GENERIC_ATTRIBS; i++) {
	 if (exec->array.generic_array[i]->Enabled)
	    inputs[VERT_ATTRIB_GENERIC0 + i] = exec->array.generic_array[i];
	 else {
	    inputs[VERT_ATTRIB_GENERIC0 + i] = &vbo->generic_currval[i];
            const_inputs |= 1 << (VERT_ATTRIB_GENERIC0 + i);
a515 1
      ctx->NewState |= _NEW_ARRAY;
d519 2
a520 1
   _mesa_set_varying_vp_inputs( ctx, ~const_inputs );
d528 38
a565 2
 * Note that this might set the _NEW_ARRAY dirty flag so state validation
 * must be done after this call.
d568 7
a574 1
bind_arrays(struct gl_context *ctx)
d576 11
a586 2
   if (!ctx->Array.RebindArrays) {
      return;
a587 4

   bind_array_obj(ctx);
   recalculate_input_bindings(ctx);
   ctx->Array.RebindArrays = GL_FALSE;
d599 1
a599 1
                GLsizei count, GLuint numInstances)
d605 1
a605 9
   bind_arrays(ctx);

   /* Again... because we may have changed the bitmask of per-vertex varying
    * attributes.  If we regenerate the fixed-function vertex program now
    * we may be able to prune down the number of vertex attributes which we
    * need in the shader.
    */
   if (ctx->NewState)
      _mesa_update_state(ctx);
d613 1
d650 2
a651 2
         vbo->draw_prims(ctx, exec->array.inputs, prim, primCount, NULL,
                         GL_TRUE, start, start + count - 1);
d660 7
a666 2
      vbo->draw_prims(ctx, exec->array.inputs, prim, 1, NULL,
                      GL_TRUE, start, start + count - 1);
d671 122
a808 6
   FLUSH_CURRENT( ctx, 0 );

   if (!_mesa_valid_to_render(ctx, "glDrawArrays")) {
      return;
   }

d812 1
a812 1
   vbo_draw_arrays(ctx, mode, start, count, 1);
d836 4
a839 1
   FLUSH_CURRENT( ctx, 0 );
d841 21
a861 1
   if (!_mesa_valid_to_render(ctx, "glDrawArraysInstanced")) {
a862 1
   }
d865 1
a865 1
      check_draw_arrays_data(ctx, start, count);
d867 1
a867 1
   vbo_draw_arrays(ctx, mode, start, count, numInstances);
d870 1
a870 1
      print_draw_arrays(ctx, mode, start, count);
d874 1
d879 1
d883 5
a887 4
   const GLvoid *map = ctx->Driver.MapBuffer(ctx,
                                             GL_ELEMENT_ARRAY_BUFFER_ARB,
                                             GL_READ_ONLY,
                                             ctx->Array.ElementArrayBufferObj);
d893 1
a893 1
         for (i = 0; i < ctx->Array.ElementArrayBufferObj->Size; i++) {
d905 1
a905 1
         for (i = 0; i < ctx->Array.ElementArrayBufferObj->Size / 2; i++) {
d917 1
a917 1
         for (i = 0; i < ctx->Array.ElementArrayBufferObj->Size / 4; i++) {
d929 1
a929 2
   ctx->Driver.UnmapBuffer(ctx, GL_ELEMENT_ARRAY_BUFFER_ARB,
                           ctx->Array.ElementArrayBufferObj);
d931 1
d945 2
a946 1
				GLint basevertex, GLint numInstances)
d953 1
a953 11
   FLUSH_CURRENT( ctx, 0 );

   if (!_mesa_valid_to_render(ctx, "glDraw[Range]Elements")) {
      return;
   }

   bind_arrays( ctx );

   /* check for dirty state again */
   if (ctx->NewState)
      _mesa_update_state( ctx );
d957 1
a957 1
   ib.obj = ctx->Array.ElementArrayBufferObj;
d970 1
d1004 6
a1009 2
   vbo->draw_prims( ctx, exec->array.inputs, prim, 1, &ib,
		    index_bounds_valid, start, end );
d1024 2
d1038 39
a1092 56
   if (end >= ctx->Array.ArrayObj->_MaxElement) {
      /* the max element is out of bounds of one or more enabled arrays */
      warnCount++;

      if (warnCount < 10) {
         _mesa_warning(ctx, "glDraw[Range]Elements(start %u, end %u, count %d, "
                       "type 0x%x, indices=%p)\n"
                       "\tend is out of bounds (max=%u)  "
                       "Element Buffer %u (size %d)\n"
                       "\tThis should probably be fixed in the application.",
                       start, end, count, type, indices,
                       ctx->Array.ArrayObj->_MaxElement - 1,
                       ctx->Array.ElementArrayBufferObj->Name,
                       (int) ctx->Array.ElementArrayBufferObj->Size);
      }

      if (0)
         dump_element_buffer(ctx, type);

      if (0)
         _mesa_print_arrays(ctx);

      /* 'end' was out of bounds, but now let's check the actual array
       * indexes to see if any of them are out of bounds.
       */
      if (0) {
         GLuint max = _mesa_max_buffer_index(ctx, count, type, indices,
                                             ctx->Array.ElementArrayBufferObj);
         if (max >= ctx->Array.ArrayObj->_MaxElement) {
            if (warnCount < 10) {
               _mesa_warning(ctx, "glDraw[Range]Elements(start %u, end %u, "
                             "count %d, type 0x%x, indices=%p)\n"
                             "\tindex=%u is out of bounds (max=%u)  "
                             "Element Buffer %u (size %d)\n"
                             "\tSkipping the glDrawRangeElements() call",
                             start, end, count, type, indices, max,
                             ctx->Array.ArrayObj->_MaxElement - 1,
                             ctx->Array.ElementArrayBufferObj->Name,
                             (int) ctx->Array.ElementArrayBufferObj->Size);
            }
         }
         /* XXX we could also find the min index and compare to 'start'
          * to see if start is correct.  But it's more likely to get the
          * upper bound wrong.
          */
      }

      /* Set 'end' to the max possible legal value */
      assert(ctx->Array.ArrayObj->_MaxElement >= 1);
      end = ctx->Array.ArrayObj->_MaxElement - 1;

      if (end < start) {
         return;
      }
   }

d1098 1
a1098 1
	     ctx->Array.ElementArrayBufferObj->Name,
d1102 4
d1112 2
a1113 2
   vbo_validated_drawrangeelements(ctx, mode, GL_TRUE, start, end,
				   count, type, indices, basevertex, 1);
d1124 2
a1125 3
   GET_CURRENT_CONTEXT(ctx);

   if (MESA_VERBOSE & VERBOSE_DRAW)
d1130 1
d1155 1
a1155 1
				   count, type, indices, 0, 1);
d1178 1
a1178 1
				   count, type, indices, basevertex, 1);
d1201 1
a1201 1
				   count, type, indices, 0, numInstances);
d1204 1
d1226 53
a1278 1
				   count, type, indices, basevertex, numInstances);
d1290 2
a1291 1
				const GLvoid **indices, GLsizei primcount,
d1298 1
a1298 1
   unsigned int index_type_size = 0;
a1305 6
   FLUSH_CURRENT( ctx, 0 );

   if (!_mesa_valid_to_render(ctx, "glMultiDrawElements")) {
      return;
   }

d1312 1
a1312 23
   /* Decide if we can do this all as one set of primitives sharing the
    * same index buffer, or if we have to reset the index pointer per
    * primitive.
    */
   bind_arrays( ctx );

   /* check for dirty state again */
   if (ctx->NewState)
      _mesa_update_state( ctx );

   switch (type) {
   case GL_UNSIGNED_INT:
      index_type_size = 4;
      break;
   case GL_UNSIGNED_SHORT:
      index_type_size = 2;
      break;
   case GL_UNSIGNED_BYTE:
      index_type_size = 1;
      break;
   default:
      assert(0);
   }
d1341 1
a1341 1
   if (!_mesa_is_bufferobj(ctx->Array.ElementArrayBufferObj))
d1347 1
a1347 1
      ib.obj = ctx->Array.ElementArrayBufferObj;
d1360 1
d1368 2
a1369 2
      vbo->draw_prims(ctx, exec->array.inputs, prim, primcount, &ib,
		      GL_FALSE, ~0, ~0);
d1375 1
a1375 1
	 ib.obj = ctx->Array.ElementArrayBufferObj;
d1387 1
d1394 2
a1395 2
         vbo->draw_prims(ctx, exec->array.inputs, prim, 1, &ib,
                         GL_FALSE, ~0, ~0);
d1400 4
d1410 1
a1410 1
			   const GLvoid **indices,
a1413 1
   GLint i;
d1415 3
a1417 7
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

   for (i = 0; i < primcount; i++) {
      if (!_mesa_validate_DrawElements(ctx, mode, count[i], type, indices[i],
				       0))
	 return;
   }
d1427 1
a1427 1
				     const GLvoid **indices,
a1431 1
   GLint i;
d1433 3
a1435 7
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

   for (i = 0; i < primcount; i++) {
      if (!_mesa_validate_DrawElements(ctx, mode, count[i], type, indices[i],
				       basevertex[i]))
	 return;
   }
d1441 36
d1479 6
a1484 2
 * Plug in the immediate-mode vertex array drawing commands into the
 * givven vbo_exec_context object.
d1486 46
a1531 2
void
vbo_exec_array_init( struct vbo_exec_context *exec )
d1533 10
a1542 10
   exec->vtxfmt.DrawArrays = vbo_exec_DrawArrays;
   exec->vtxfmt.DrawElements = vbo_exec_DrawElements;
   exec->vtxfmt.DrawRangeElements = vbo_exec_DrawRangeElements;
   exec->vtxfmt.MultiDrawElementsEXT = vbo_exec_MultiDrawElements;
   exec->vtxfmt.DrawElementsBaseVertex = vbo_exec_DrawElementsBaseVertex;
   exec->vtxfmt.DrawRangeElementsBaseVertex = vbo_exec_DrawRangeElementsBaseVertex;
   exec->vtxfmt.MultiDrawElementsBaseVertex = vbo_exec_MultiDrawElementsBaseVertex;
   exec->vtxfmt.DrawArraysInstanced = vbo_exec_DrawArraysInstanced;
   exec->vtxfmt.DrawElementsInstanced = vbo_exec_DrawElementsInstanced;
   exec->vtxfmt.DrawElementsInstancedBaseVertex = vbo_exec_DrawElementsInstancedBaseVertex;
d1546 3
d1550 2
a1551 1
vbo_exec_array_destroy( struct vbo_exec_context *exec )
d1553 36
a1588 1
   /* nothing to do */
d1656 6
@


1.6
log
@Merge Mesa 7.10.3
@
text
@d42 38
d340 2
a341 1
      GLuint bufName = exec->array.inputs[i]->BufferObj->Name;
a353 1
         struct gl_buffer_object *buf = _mesa_lookup_bufferobj(ctx, bufName);
d355 1
a355 1
                                            GL_READ_ONLY_ARB, buf);
d367 1
a367 1
         ctx->Driver.UnmapBuffer(ctx, GL_ARRAY_BUFFER_ARB, buf);
d464 8
d497 2
d534 1
d536 1
a536 1
      }
d554 4
d560 1
d588 2
a591 2
   prim[0].weak = 0;
   prim[0].pad = 0;
a592 4
   prim[0].start = 0; /* filled in below */
   prim[0].count = 0; /* filled in below */
   prim[0].indexed = 0;
   prim[0].basevertex = 0;
d629 1
d639 1
d684 1
a684 1
                             GLsizei primcount)
d690 1
a690 1
                  _mesa_lookup_enum_by_nr(mode), start, count, primcount);
d692 1
a692 1
   if (!_mesa_validate_DrawArraysInstanced(ctx, mode, start, count, primcount))
d704 1
a704 1
   vbo_draw_arrays(ctx, mode, start, count, primcount);
d779 1
a779 1
				GLint basevertex, GLint primcount)
d812 1
a812 1
   prim[0].num_instances = primcount;
d845 1
a911 1
#ifdef DEBUG
d915 1
a915 1
      {
a935 1
#endif
d940 4
d945 2
a946 1
   else if (0) {
d1036 1
a1036 1
                               const GLvoid *indices, GLsizei primcount)
d1043 25
a1067 1
                  _mesa_lookup_enum_by_nr(type), indices, primcount);
d1070 1
a1070 1
                                             primcount))
d1074 1
a1074 1
				   count, type, indices, 0, primcount);
d1189 1
d1214 1
d1285 1
@


1.5
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@a32 1
#include "main/api_noop.h"
d42 4
a45 1
 * Compute min and max elements for glDraw[Range]Elements() calls.
d48 1
a48 1
vbo_get_minmax_index(GLcontext *ctx,
d53 4
a57 2
   GLuint count = prim->count;
   const void *indices;
d71 15
a85 5
      GLuint max_ui = ui_indices[count-1];
      GLuint min_ui = ui_indices[0];
      for (i = 0; i < count; i++) {
	 if (ui_indices[i] > max_ui) max_ui = ui_indices[i];
	 if (ui_indices[i] < min_ui) min_ui = ui_indices[i];
d93 15
a107 5
      GLuint max_us = us_indices[count-1];
      GLuint min_us = us_indices[0];
      for (i = 0; i < count; i++) {
	 if (us_indices[i] > max_us) max_us = us_indices[i];
	 if (us_indices[i] < min_us) min_us = us_indices[i];
d115 15
a129 5
      GLuint max_ub = ub_indices[count-1];
      GLuint min_ub = ub_indices[0];
      for (i = 0; i < count; i++) {
	 if (ub_indices[i] > max_ub) max_ub = ub_indices[i];
	 if (ub_indices[i] < min_ub) min_ub = ub_indices[i];
d149 1
d152 1
a152 1
check_array_data(GLcontext *ctx, struct gl_client_array *array,
d198 1
a198 1
unmap_array_buffer(GLcontext *ctx, struct gl_client_array *array)
d210 1
d213 1
a213 1
check_draw_elements_data(GLcontext *ctx, GLsizei count, GLenum elemType,
d281 1
a281 1
check_draw_arrays_data(GLcontext *ctx, GLint start, GLsizei count)
d288 1
a288 1
 * Print info/data for glDrawArrays().
d291 1
a291 1
print_draw_arrays(GLcontext *ctx, struct vbo_exec_context *exec,
d294 2
d336 3
d342 1
a342 1
bind_array_obj(GLcontext *ctx)
d378 8
d387 1
a387 1
recalculate_input_bindings(GLcontext *ctx)
d503 1
a503 1
bind_arrays(GLcontext *ctx)
a504 10
#if 0
   if (ctx->Array.ArrayObj.Name != exec->array.array_obj) {
      bind_array_obj(ctx);
      recalculate_input_bindings(ctx);
   }
   else if (exec->array.program_mode != get_program_mode(ctx) ||
	    exec->array.enabled_flags != ctx->Array.ArrayObj->_Enabled) {
      recalculate_input_bindings(ctx);
   }
#else
d507 84
a590 1
#endif
d595 2
a596 2
/***********************************************************************
 * API functions.
a597 1

a601 3
   struct vbo_context *vbo = vbo_context(ctx);
   struct vbo_exec_context *exec = &vbo->exec;
   struct _mesa_prim prim[1];
d616 26
a641 5
#if 0
   check_draw_arrays_data(ctx, start, count);
#else
   (void) check_draw_arrays_data;
#endif
d643 1
a643 1
   bind_arrays( ctx );
d645 3
a647 7
   /* Again... because we may have changed the bitmask of per-vertex varying
    * attributes.  If we regenerate the fixed-function vertex program now
    * we may be able to prune down the number of vertex attributes which we
    * need in the shader.
    */
   if (ctx->NewState)
      _mesa_update_state( ctx );
d649 2
a650 9
   prim[0].begin = 1;
   prim[0].end = 1;
   prim[0].weak = 0;
   prim[0].pad = 0;
   prim[0].mode = mode;
   prim[0].start = start;
   prim[0].count = count;
   prim[0].indexed = 0;
   prim[0].basevertex = 0;
d652 1
a652 2
   vbo->draw_prims( ctx, exec->array.inputs, prim, 1, NULL,
                    GL_TRUE, start, start + count - 1 );
d654 2
a655 5
#if 0
   print_draw_arrays(ctx, exec, mode, start, count);
#else
   (void) print_draw_arrays;
#endif
d661 1
d664 1
a664 1
dump_element_buffer(GLcontext *ctx, GLenum type)
d716 5
a720 1
/* Inner support for both _mesa_DrawElements and _mesa_DrawRangeElements */
d722 1
a722 1
vbo_validated_drawrangeelements(GLcontext *ctx, GLenum mode,
d727 1
a727 1
				GLint basevertex)
d760 1
d797 4
d850 1
a850 1
                       ctx->Array.ElementArrayBufferObj->Size);
d876 1
a876 1
                             ctx->Array.ElementArrayBufferObj->Size);
d906 1
a906 1
				   count, type, indices, basevertex);
d910 3
d930 3
d948 1
a948 1
				   count, type, indices, 0);
d952 3
d971 24
a994 1
				   count, type, indices, basevertex);
d998 5
a1002 1
/** Inner support for both _mesa_DrawElements and _mesa_DrawRangeElements */
d1004 1
a1004 1
vbo_validated_multidrawelements(GLcontext *ctx, GLenum mode,
d1034 2
a1035 1
    * same index buffer, or if we have to reset the index pointer per primitive.
d1068 2
d1102 1
d1127 1
d1187 3
a1189 2
/***********************************************************************
 * Initialization
a1190 1

a1193 1
#if 1
d1201 2
a1202 9
#else
   exec->vtxfmt.DrawArrays = _mesa_noop_DrawArrays;
   exec->vtxfmt.DrawElements = _mesa_noop_DrawElements;
   exec->vtxfmt.DrawRangeElements = _mesa_noop_DrawRangeElements;
   exec->vtxfmt.MultiDrawElementsEXT = _mesa_noop_MultiDrawElements;
   exec->vtxfmt.DrawElementsBaseVertex = _mesa_noop_DrawElementsBaseVertex;
   exec->vtxfmt.DrawRangeElementsBaseVertex = _mesa_noop_DrawRangeElementsBaseVertex;
   exec->vtxfmt.MultiDrawElementsBaseVertex = _mesa_noop_MultiDrawElementsBaseVertex;
#endif
d1213 7
a1219 1
/* This API entrypoint is not ordinarily used */
a1226 1
/* This API entrypoint is not ordinarily used */
d1234 1
a1242 1
/* This API entrypoint is not ordinarily used */
a1260 1
/* GL_EXT_multi_draw_arrays */
@


1.4
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d4 1
d34 4
d41 3
a43 1
/* Compute min and max elements for drawelements calls.
d45 5
a49 4
static void get_minmax_index( GLuint count, GLuint type, 
			      const GLvoid *indices,
			      GLuint *min_index,
			      GLuint *max_index)
d52 11
d64 1
a64 1
   switch(type) {
d105 143
d251 2
a252 1
/* Just translate the arrayobj into a sane layout.
d254 48
a301 1
static void bind_array_obj( GLcontext *ctx )
d305 1
d312 8
a319 8
   exec->array.legacy_array[VERT_ATTRIB_POS] = &ctx->Array.ArrayObj->Vertex;
   exec->array.legacy_array[VERT_ATTRIB_WEIGHT] = &vbo->legacy_currval[VERT_ATTRIB_WEIGHT];
   exec->array.legacy_array[VERT_ATTRIB_NORMAL] = &ctx->Array.ArrayObj->Normal;
   exec->array.legacy_array[VERT_ATTRIB_COLOR0] = &ctx->Array.ArrayObj->Color;
   exec->array.legacy_array[VERT_ATTRIB_COLOR1] = &ctx->Array.ArrayObj->SecondaryColor;
   exec->array.legacy_array[VERT_ATTRIB_FOG] = &ctx->Array.ArrayObj->FogCoord;
   exec->array.legacy_array[VERT_ATTRIB_COLOR_INDEX] = &ctx->Array.ArrayObj->Index;
   if (ctx->Array.ArrayObj->PointSize.Enabled) {
d321 1
a321 1
      exec->array.legacy_array[VERT_ATTRIB_POINT_SIZE] = &ctx->Array.ArrayObj->PointSize;
d323 1
a323 1
   exec->array.legacy_array[VERT_ATTRIB_EDGEFLAG] = &ctx->Array.ArrayObj->EdgeFlag;
d325 2
a326 2
   for (i = 0; i < 8; i++)
      exec->array.legacy_array[VERT_ATTRIB_TEX0 + i] = &ctx->Array.ArrayObj->TexCoord[i];
d328 4
a331 2
   for (i = 0; i < VERT_ATTRIB_MAX; i++)
      exec->array.generic_array[i] = &ctx->Array.ArrayObj->VertexAttrib[i];
d333 1
a333 1
   exec->array.array_obj = ctx->Array.ArrayObj->Name;
d336 3
a338 1
static void recalculate_input_bindings( GLcontext *ctx )
d343 1
d351 4
a354 3
      /* When no vertex program is active, we put the material values
       * into the generic slots.  This is the only situation where
       * material values are available as per-vertex attributes.
d359 1
a359 1
	 else
d361 2
d367 1
d373 1
a373 1
      for (i = MAT_ATTRIB_MAX; i < VERT_ATTRIB_MAX - VERT_ATTRIB_GENERIC0; i++)
d375 3
a378 1
      break;
d389 1
a389 1
	 else
d391 2
d398 1
a398 1
      for (i = VERT_ATTRIB_GENERIC0; i < VERT_ATTRIB_MAX; i++)
d400 3
a403 1
      break;
d405 2
a406 2
      /* ARB_vertex_program - Only the attribute zero (position) array
       * aliases and overrides the legacy position array.  
d416 1
a416 1
      else
d418 2
a419 1

d424 1
a424 1
	 else
d426 2
d430 1
a430 1
      for (i = 0; i < 16; i++) {
d433 1
a433 1
	 else
d435 3
d441 2
d445 10
a454 1
static void bind_arrays( GLcontext *ctx )
a462 1
      
d485 4
d494 1
a494 5
   if (ctx->NewState)
      _mesa_update_state( ctx );
      
   if (!vbo_validate_shaders(ctx)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glDrawArrays(bad shader)");
d498 6
d506 8
d522 4
d527 5
a531 1
   vbo->draw_prims( ctx, exec->array.inputs, prim, 1, NULL, start, start + count - 1 );
d535 55
d591 8
a598 4
static void GLAPIENTRY
vbo_exec_DrawRangeElements(GLenum mode,
			   GLuint start, GLuint end,
			   GLsizei count, GLenum type, const GLvoid *indices)
a599 1
   GET_CURRENT_CONTEXT(ctx);
a604 3
   if (!_mesa_validate_DrawRangeElements( ctx, mode, start, end, count, type, indices ))
      return;

d607 1
a607 5
   if (ctx->NewState)
      _mesa_update_state( ctx );

   if (!vbo_validate_shaders(ctx)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glDrawRangeElements(bad shader)");
d613 4
d618 1
a618 1
   ib.type = type; 
d630 1
d663 2
a664 1
   vbo->draw_prims( ctx, exec->array.inputs, prim, 1, &ib, start, end );
d668 5
a672 1
vbo_exec_DrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices)
d674 1
a675 2
   GLuint min_index = 0;
   GLuint max_index = 0;
d677 8
a684 1
   if (!_mesa_validate_DrawElements( ctx, mode, count, type, indices ))
d687 167
a853 2
   if (!vbo_validate_shaders(ctx)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glDrawElements(bad shader)");
d857 5
a861 5
   if (ctx->Array.ElementArrayBufferObj->Name) {
      const GLvoid *map = ctx->Driver.MapBuffer(ctx,
						 GL_ELEMENT_ARRAY_BUFFER_ARB,
						 GL_READ_ONLY,
						 ctx->Array.ElementArrayBufferObj);
d863 8
a870 1
      get_minmax_index(count, type, ADD_POINTERS(map, indices), &min_index, &max_index);
d872 110
a981 3
      ctx->Driver.UnmapBuffer(ctx,
			      GL_ELEMENT_ARRAY_BUFFER_ARB,
			      ctx->Array.ElementArrayBufferObj);
d983 22
a1004 2
   else {
      get_minmax_index(count, type, indices, &min_index, &max_index);
d1007 2
a1008 1
   vbo_exec_DrawRangeElements(mode, min_index, max_index, count, type, indices);
d1016 2
a1017 4



void vbo_exec_array_init( struct vbo_exec_context *exec )
d1023 4
d1031 4
d1039 2
a1040 1
void vbo_exec_array_destroy( struct vbo_exec_context *exec )
d1043 63
@


1.3
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d43 1
a43 1
   GLint i;
d48 1
a48 1
      GLuint max_ui = ui_indices[0];
d50 1
a50 1
      for (i = 1; i < count; i++) {
d60 1
a60 1
      GLuint max_us = us_indices[0];
d62 1
a62 1
      for (i = 1; i < count; i++) {
d72 1
a72 1
      GLuint max_ub = ub_indices[0];
d74 1
a74 1
      for (i = 1; i < count; i++) {
d108 4
@


1.2
log
@Update to Mesa 7.0.3. tested my oga@@ and johan@@
@
text
@d28 5
a32 6
#include "glheader.h"
#include "context.h"
#include "state.h"
#include "api_validate.h"
#include "api_noop.h"
#include "dispatch.h"
@


1.1
log
@Initial revision
@
text
@d248 5
d288 5
d352 5
@


1.1.1.1
log
@Mesa 7.0.1
@
text
@@


1.1.1.2
log
@Import Mesa 7.10.3
@
text
@a3 1
 * Copyright 2009 VMware, Inc.
d28 6
a33 8
#include "main/glheader.h"
#include "main/context.h"
#include "main/state.h"
#include "main/api_validate.h"
#include "main/varray.h"
#include "main/bufferobj.h"
#include "main/enums.h"
#include "main/macros.h"
d37 1
a37 6

/**
 * Compute min and max elements by scanning the index buffer for
 * glDraw[Range]Elements() calls.
 * If primitive restart is enabled, we need to ignore restart
 * indexes when computing min/max.
d39 4
a42 5
void
vbo_get_minmax_index(struct gl_context *ctx,
		     const struct _mesa_prim *prim,
		     const struct _mesa_index_buffer *ib,
		     GLuint *min_index, GLuint *max_index)
d44 1
a44 5
   const GLboolean restart = ctx->Array.PrimitiveRestart;
   const GLuint restartIndex = ctx->Array.RestartIndex;
   const GLuint count = prim->count;
   const void *indices;
   GLuint i;
d46 1
a46 10
   if (_mesa_is_bufferobj(ib->obj)) {
      const GLvoid *map =
         ctx->Driver.MapBuffer(ctx, GL_ELEMENT_ARRAY_BUFFER_ARB,
                               GL_READ_ONLY, ib->obj);
      indices = ADD_POINTERS(map, ib->ptr);
   } else {
      indices = ib->ptr;
   }

   switch (ib->type) {
d49 5
a53 15
      GLuint max_ui = 0;
      GLuint min_ui = ~0U;
      if (restart) {
         for (i = 0; i < count; i++) {
            if (ui_indices[i] != restartIndex) {
               if (ui_indices[i] > max_ui) max_ui = ui_indices[i];
               if (ui_indices[i] < min_ui) min_ui = ui_indices[i];
            }
         }
      }
      else {
         for (i = 0; i < count; i++) {
            if (ui_indices[i] > max_ui) max_ui = ui_indices[i];
            if (ui_indices[i] < min_ui) min_ui = ui_indices[i];
         }
d61 5
a65 15
      GLuint max_us = 0;
      GLuint min_us = ~0U;
      if (restart) {
         for (i = 0; i < count; i++) {
            if (us_indices[i] != restartIndex) {
               if (us_indices[i] > max_us) max_us = us_indices[i];
               if (us_indices[i] < min_us) min_us = us_indices[i];
            }
         }
      }
      else {
         for (i = 0; i < count; i++) {
            if (us_indices[i] > max_us) max_us = us_indices[i];
            if (us_indices[i] < min_us) min_us = us_indices[i];
         }
d73 5
a77 15
      GLuint max_ub = 0;
      GLuint min_ub = ~0U;
      if (restart) {
         for (i = 0; i < count; i++) {
            if (ub_indices[i] != restartIndex) {
               if (ub_indices[i] > max_ub) max_ub = ub_indices[i];
               if (ub_indices[i] < min_ub) min_ub = ub_indices[i];
            }
         }
      }
      else {
         for (i = 0; i < count; i++) {
            if (ub_indices[i] > max_ub) max_ub = ub_indices[i];
            if (ub_indices[i] < min_ub) min_ub = ub_indices[i];
         }
a86 135

   if (_mesa_is_bufferobj(ib->obj)) {
      ctx->Driver.UnmapBuffer(ctx, GL_ELEMENT_ARRAY_BUFFER_ARB, ib->obj);
   }
}


/**
 * Check that element 'j' of the array has reasonable data.
 * Map VBO if needed.
 * For debugging purposes; not normally used.
 */
static void
check_array_data(struct gl_context *ctx, struct gl_client_array *array,
                 GLuint attrib, GLuint j)
{
   if (array->Enabled) {
      const void *data = array->Ptr;
      if (_mesa_is_bufferobj(array->BufferObj)) {
         if (!array->BufferObj->Pointer) {
            /* need to map now */
            array->BufferObj->Pointer =
               ctx->Driver.MapBuffer(ctx, GL_ARRAY_BUFFER_ARB,
                                     GL_READ_ONLY, array->BufferObj);
         }
         data = ADD_POINTERS(data, array->BufferObj->Pointer);
      }
      switch (array->Type) {
      case GL_FLOAT:
         {
            GLfloat *f = (GLfloat *) ((GLubyte *) data + array->StrideB * j);
            GLint k;
            for (k = 0; k < array->Size; k++) {
               if (IS_INF_OR_NAN(f[k]) ||
                   f[k] >= 1.0e20 || f[k] <= -1.0e10) {
                  printf("Bad array data:\n");
                  printf("  Element[%u].%u = %f\n", j, k, f[k]);
                  printf("  Array %u at %p\n", attrib, (void* ) array);
                  printf("  Type 0x%x, Size %d, Stride %d\n",
			 array->Type, array->Size, array->Stride);
                  printf("  Address/offset %p in Buffer Object %u\n",
			 array->Ptr, array->BufferObj->Name);
                  f[k] = 1.0; /* XXX replace the bad value! */
               }
               /*assert(!IS_INF_OR_NAN(f[k]));*/
            }
         }
         break;
      default:
         ;
      }
   }
}


/**
 * Unmap the buffer object referenced by given array, if mapped.
 */
static void
unmap_array_buffer(struct gl_context *ctx, struct gl_client_array *array)
{
   if (array->Enabled &&
       _mesa_is_bufferobj(array->BufferObj) &&
       _mesa_bufferobj_mapped(array->BufferObj)) {
      ctx->Driver.UnmapBuffer(ctx, GL_ARRAY_BUFFER_ARB, array->BufferObj);
   }
}


/**
 * Examine the array's data for NaNs, etc.
 * For debug purposes; not normally used.
 */
static void
check_draw_elements_data(struct gl_context *ctx, GLsizei count, GLenum elemType,
                         const void *elements, GLint basevertex)
{
   struct gl_array_object *arrayObj = ctx->Array.ArrayObj;
   const void *elemMap;
   GLint i, k;

   if (_mesa_is_bufferobj(ctx->Array.ElementArrayBufferObj)) {
      elemMap = ctx->Driver.MapBuffer(ctx,
                                      GL_ELEMENT_ARRAY_BUFFER_ARB,
                                      GL_READ_ONLY,
                                      ctx->Array.ElementArrayBufferObj);
      elements = ADD_POINTERS(elements, elemMap);
   }

   for (i = 0; i < count; i++) {
      GLuint j;

      /* j = element[i] */
      switch (elemType) {
      case GL_UNSIGNED_BYTE:
         j = ((const GLubyte *) elements)[i];
         break;
      case GL_UNSIGNED_SHORT:
         j = ((const GLushort *) elements)[i];
         break;
      case GL_UNSIGNED_INT:
         j = ((const GLuint *) elements)[i];
         break;
      default:
         assert(0);
      }

      /* check element j of each enabled array */
      check_array_data(ctx, &arrayObj->Vertex, VERT_ATTRIB_POS, j);
      check_array_data(ctx, &arrayObj->Normal, VERT_ATTRIB_NORMAL, j);
      check_array_data(ctx, &arrayObj->Color, VERT_ATTRIB_COLOR0, j);
      check_array_data(ctx, &arrayObj->SecondaryColor, VERT_ATTRIB_COLOR1, j);
      for (k = 0; k < Elements(arrayObj->TexCoord); k++) {
         check_array_data(ctx, &arrayObj->TexCoord[k], VERT_ATTRIB_TEX0 + k, j);
      }
      for (k = 0; k < Elements(arrayObj->VertexAttrib); k++) {
         check_array_data(ctx, &arrayObj->VertexAttrib[k],
                          VERT_ATTRIB_GENERIC0 + k, j);
      }
   }

   if (_mesa_is_bufferobj(ctx->Array.ElementArrayBufferObj)) {
      ctx->Driver.UnmapBuffer(ctx, GL_ELEMENT_ARRAY_BUFFER_ARB,
			      ctx->Array.ElementArrayBufferObj);
   }

   unmap_array_buffer(ctx, &arrayObj->Vertex);
   unmap_array_buffer(ctx, &arrayObj->Normal);
   unmap_array_buffer(ctx, &arrayObj->Color);
   for (k = 0; k < Elements(arrayObj->TexCoord); k++) {
      unmap_array_buffer(ctx, &arrayObj->TexCoord[k]);
   }
   for (k = 0; k < Elements(arrayObj->VertexAttrib); k++) {
      unmap_array_buffer(ctx, &arrayObj->VertexAttrib[k]);
   }
d90 1
a90 2
/**
 * Check array data, looking for NaNs, etc.
d92 1
a92 13
static void
check_draw_arrays_data(struct gl_context *ctx, GLint start, GLsizei count)
{
   /* TO DO */
}


/**
 * Print info/data for glDrawArrays(), for debugging.
 */
static void
print_draw_arrays(struct gl_context *ctx,
                  GLenum mode, GLint start, GLsizei count)
a95 51
   int i;

   printf("vbo_exec_DrawArrays(mode 0x%x, start %d, count %d):\n",
	  mode, start, count);

   for (i = 0; i < 32; i++) {
      GLuint bufName = exec->array.inputs[i]->BufferObj->Name;
      GLint stride = exec->array.inputs[i]->Stride;
      printf("attr %2d: size %d stride %d  enabled %d  "
	     "ptr %p  Bufobj %u\n",
	     i,
	     exec->array.inputs[i]->Size,
	     stride,
	     /*exec->array.inputs[i]->Enabled,*/
	     exec->array.legacy_array[i]->Enabled,
	     exec->array.inputs[i]->Ptr,
	     bufName);

      if (bufName) {
         struct gl_buffer_object *buf = _mesa_lookup_bufferobj(ctx, bufName);
         GLubyte *p = ctx->Driver.MapBuffer(ctx, GL_ARRAY_BUFFER_ARB,
                                            GL_READ_ONLY_ARB, buf);
         int offset = (int) (GLintptr) exec->array.inputs[i]->Ptr;
         float *f = (float *) (p + offset);
         int *k = (int *) f;
         int i;
         int n = (count * stride) / 4;
         if (n > 32)
            n = 32;
         printf("  Data at offset %d:\n", offset);
         for (i = 0; i < n; i++) {
            printf("    float[%d] = 0x%08x %f\n", i, k[i], f[i]);
         }
         ctx->Driver.UnmapBuffer(ctx, GL_ARRAY_BUFFER_ARB, buf);
      }
   }
}


/**
 * Bind the VBO executor to the current vertex array object prior
 * to drawing.
 *
 * Just translate the arrayobj into a sane layout.
 */
static void
bind_array_obj(struct gl_context *ctx)
{
   struct vbo_context *vbo = vbo_context(ctx);
   struct vbo_exec_context *exec = &vbo->exec;
   struct gl_array_object *arrayObj = ctx->Array.ArrayObj;
d102 8
a109 12
   exec->array.legacy_array[VERT_ATTRIB_POS] = &arrayObj->Vertex;
   exec->array.legacy_array[VERT_ATTRIB_WEIGHT] = &arrayObj->Weight;
   exec->array.legacy_array[VERT_ATTRIB_NORMAL] = &arrayObj->Normal;
   exec->array.legacy_array[VERT_ATTRIB_COLOR0] = &arrayObj->Color;
   exec->array.legacy_array[VERT_ATTRIB_COLOR1] = &arrayObj->SecondaryColor;
   exec->array.legacy_array[VERT_ATTRIB_FOG] = &arrayObj->FogCoord;
   exec->array.legacy_array[VERT_ATTRIB_COLOR_INDEX] = &arrayObj->Index;
   if (arrayObj->PointSize.Enabled) {
      /* this aliases COLOR_INDEX */
      exec->array.legacy_array[VERT_ATTRIB_POINT_SIZE] = &arrayObj->PointSize;
   }
   exec->array.legacy_array[VERT_ATTRIB_EDGEFLAG] = &arrayObj->EdgeFlag;
d111 2
a112 2
   for (i = 0; i < Elements(arrayObj->TexCoord); i++)
      exec->array.legacy_array[VERT_ATTRIB_TEX0 + i] = &arrayObj->TexCoord[i];
d114 2
a115 4
   for (i = 0; i < Elements(arrayObj->VertexAttrib); i++) {
      assert(i < Elements(exec->array.generic_array));
      exec->array.generic_array[i] = &arrayObj->VertexAttrib[i];
   }
d117 1
a117 1
   exec->array.array_obj = arrayObj->Name;
d120 1
a120 11

/**
 * Set the vbo->exec->inputs[] pointers to point to the enabled
 * vertex arrays.  This depends on the current vertex program/shader
 * being executed because of whether or not generic vertex arrays
 * alias the conventional vertex arrays.
 * For arrays that aren't enabled, we set the input[attrib] pointer
 * to point at a zero-stride current value "array".
 */
static void
recalculate_input_bindings(struct gl_context *ctx)
a124 1
   GLbitfield const_inputs = 0x0;
d132 3
a134 4
      /* When no vertex program is active (or the vertex program is generated
       * from fixed-function state).  We put the material values into the
       * generic slots.  This is the only situation where material values
       * are available as per-vertex attributes.
d139 1
a139 1
	 else {
a140 2
            const_inputs |= 1 << i;
         }
a144 1
         const_inputs |= 1 << (VERT_ATTRIB_GENERIC0 + i);
d150 1
a150 1
      for (i = MAT_ATTRIB_MAX; i < VERT_ATTRIB_MAX - VERT_ATTRIB_GENERIC0; i++) {
d152 1
a152 2
         const_inputs |= 1 << (VERT_ATTRIB_GENERIC0 + i);
      }
a153 1

d164 1
a164 1
	 else {
a165 2
            const_inputs |= 1 << i;
         }
d171 1
a171 1
      for (i = VERT_ATTRIB_GENERIC0; i < VERT_ATTRIB_MAX; i++) {
d173 1
a173 2
         const_inputs |= 1 << i;
      }
a174 1

d176 2
a177 2
      /* GL_ARB_vertex_program or GLSL vertex shader - Only the generic[0]
       * attribute array aliases and overrides the legacy position array.  
d187 1
a187 1
      else {
d189 1
a189 2
         const_inputs |= 1 << 0;
      }
d194 1
a194 1
	 else {
a195 2
            const_inputs |= 1 << i;
         }
d198 1
a198 1
      for (i = 0; i < MAX_VERTEX_GENERIC_ATTRIBS; i++) {
d201 1
a201 1
	 else {
a202 3
            const_inputs |= 1 << (VERT_ATTRIB_GENERIC0 + i);
         }

a205 2

   _mesa_set_varying_vp_inputs( ctx, ~const_inputs );
d208 1
a208 10

/**
 * Examine the enabled vertex arrays to set the exec->array.inputs[] values.
 * These will point to the arrays to actually use for drawing.  Some will
 * be user-provided arrays, other will be zero-stride const-valued arrays.
 * Note that this might set the _NEW_ARRAY dirty flag so state validation
 * must be done after this call.
 */
static void
bind_arrays(struct gl_context *ctx)
d210 11
d223 1
d227 3
a229 5
/**
 * Helper function called by the other DrawArrays() functions below.
 * This is where we handle primitive restart for drawing non-indexed
 * arrays.  If primitive restart is enabled, it typically means
 * splitting one DrawArrays() into two.
d231 3
a233 3
static void
vbo_draw_arrays(struct gl_context *ctx, GLenum mode, GLint start,
                GLsizei count, GLuint numInstances)
d235 1
d238 1
a238 1
   struct _mesa_prim prim[2];
d240 4
a243 1
   bind_arrays(ctx);
a244 5
   /* Again... because we may have changed the bitmask of per-vertex varying
    * attributes.  If we regenerate the fixed-function vertex program now
    * we may be able to prune down the number of vertex attributes which we
    * need in the shader.
    */
d246 3
a248 1
      _mesa_update_state(ctx);
d255 2
a256 2
   prim[0].start = 0; /* filled in below */
   prim[0].count = 0; /* filled in below */
a257 31
   prim[0].basevertex = 0;
   prim[0].num_instances = numInstances;

   /* Implement the primitive restart index */
   if (ctx->Array.PrimitiveRestart && ctx->Array.RestartIndex < count) {
      GLuint primCount = 0;

      if (ctx->Array.RestartIndex == start) {
         /* special case: RestartIndex at beginning */
         if (count > 1) {
            prim[0].start = start + 1;
            prim[0].count = count - 1;
            primCount = 1;
         }
      }
      else if (ctx->Array.RestartIndex == start + count - 1) {
         /* special case: RestartIndex at end */
         if (count > 1) {
            prim[0].start = start;
            prim[0].count = count - 1;
            primCount = 1;
         }
      }
      else {
         /* general case: RestartIndex in middle, split into two prims */
         prim[0].start = start;
         prim[0].count = ctx->Array.RestartIndex - start;

         prim[1] = prim[0];
         prim[1].start = ctx->Array.RestartIndex + 1;
         prim[1].count = count - prim[1].start;
d259 1
a259 17
         primCount = 2;
      }

      if (primCount > 0) {
         /* draw one or two prims */
         vbo->draw_prims(ctx, exec->array.inputs, prim, primCount, NULL,
                         GL_TRUE, start, start + count - 1);
      }
   }
   else {
      /* no prim restart */
      prim[0].start = start;
      prim[0].count = count;

      vbo->draw_prims(ctx, exec->array.inputs, prim, 1, NULL,
                      GL_TRUE, start, start + count - 1);
   }
a263 35
/**
 * Called from glDrawArrays when in immediate mode (not display list mode).
 */
static void GLAPIENTRY
vbo_exec_DrawArrays(GLenum mode, GLint start, GLsizei count)
{
   GET_CURRENT_CONTEXT(ctx);

   if (MESA_VERBOSE & VERBOSE_DRAW)
      _mesa_debug(ctx, "glDrawArrays(%s, %d, %d)\n",
                  _mesa_lookup_enum_by_nr(mode), start, count);

   if (!_mesa_validate_DrawArrays( ctx, mode, start, count ))
      return;

   FLUSH_CURRENT( ctx, 0 );

   if (!_mesa_valid_to_render(ctx, "glDrawArrays")) {
      return;
   }

   if (0)
      check_draw_arrays_data(ctx, start, count);

   vbo_draw_arrays(ctx, mode, start, count, 1);

   if (0)
      print_draw_arrays(ctx, mode, start, count);
}


/**
 * Called from glDrawArraysInstanced when in immediate mode (not
 * display list mode).
 */
d265 3
a267 2
vbo_exec_DrawArraysInstanced(GLenum mode, GLint start, GLsizei count,
                             GLsizei primcount)
a269 94

   if (MESA_VERBOSE & VERBOSE_DRAW)
      _mesa_debug(ctx, "glDrawArraysInstanced(%s, %d, %d, %d)\n",
                  _mesa_lookup_enum_by_nr(mode), start, count, primcount);

   if (!_mesa_validate_DrawArraysInstanced(ctx, mode, start, count, primcount))
      return;

   FLUSH_CURRENT( ctx, 0 );

   if (!_mesa_valid_to_render(ctx, "glDrawArraysInstanced")) {
      return;
   }

   if (0)
      check_draw_arrays_data(ctx, start, count);

   vbo_draw_arrays(ctx, mode, start, count, primcount);

   if (0)
      print_draw_arrays(ctx, mode, start, count);
}


/**
 * Map GL_ELEMENT_ARRAY_BUFFER and print contents.
 * For debugging.
 */
static void
dump_element_buffer(struct gl_context *ctx, GLenum type)
{
   const GLvoid *map = ctx->Driver.MapBuffer(ctx,
                                             GL_ELEMENT_ARRAY_BUFFER_ARB,
                                             GL_READ_ONLY,
                                             ctx->Array.ElementArrayBufferObj);
   switch (type) {
   case GL_UNSIGNED_BYTE:
      {
         const GLubyte *us = (const GLubyte *) map;
         GLint i;
         for (i = 0; i < ctx->Array.ElementArrayBufferObj->Size; i++) {
            printf("%02x ", us[i]);
            if (i % 32 == 31)
               printf("\n");
         }
         printf("\n");
      }
      break;
   case GL_UNSIGNED_SHORT:
      {
         const GLushort *us = (const GLushort *) map;
         GLint i;
         for (i = 0; i < ctx->Array.ElementArrayBufferObj->Size / 2; i++) {
            printf("%04x ", us[i]);
            if (i % 16 == 15)
               printf("\n");
         }
         printf("\n");
      }
      break;
   case GL_UNSIGNED_INT:
      {
         const GLuint *us = (const GLuint *) map;
         GLint i;
         for (i = 0; i < ctx->Array.ElementArrayBufferObj->Size / 4; i++) {
            printf("%08x ", us[i]);
            if (i % 8 == 7)
               printf("\n");
         }
         printf("\n");
      }
      break;
   default:
      ;
   }

   ctx->Driver.UnmapBuffer(ctx, GL_ELEMENT_ARRAY_BUFFER_ARB,
                           ctx->Array.ElementArrayBufferObj);
}


/**
 * Inner support for both _mesa_DrawElements and _mesa_DrawRangeElements.
 * Do the rendering for a glDrawElements or glDrawRangeElements call after
 * we've validated buffer bounds, etc.
 */
static void
vbo_validated_drawrangeelements(struct gl_context *ctx, GLenum mode,
				GLboolean index_bounds_valid,
				GLuint start, GLuint end,
				GLsizei count, GLenum type,
				const GLvoid *indices,
				GLint basevertex, GLint primcount)
{
d275 1
a275 3
   FLUSH_CURRENT( ctx, 0 );

   if (!_mesa_valid_to_render(ctx, "glDraw[Range]Elements")) {
a276 1
   }
d278 1
a278 1
   bind_arrays( ctx );
a279 1
   /* check for dirty state again */
d283 2
d286 1
a286 1
   ib.type = type;
a297 2
   prim[0].basevertex = basevertex;
   prim[0].num_instances = primcount;
d330 1
a330 2
   vbo->draw_prims( ctx, exec->array.inputs, prim, 1, &ib,
		    index_bounds_valid, start, end );
a332 4

/**
 * Called by glDrawRangeElementsBaseVertex() in immediate mode.
 */
d334 1
a334 5
vbo_exec_DrawRangeElementsBaseVertex(GLenum mode,
				     GLuint start, GLuint end,
				     GLsizei count, GLenum type,
				     const GLvoid *indices,
				     GLint basevertex)
a335 1
   static GLuint warnCount = 0;
d337 2
d340 1
a340 8
   if (MESA_VERBOSE & VERBOSE_DRAW)
      _mesa_debug(ctx,
                "glDrawRangeElementsBaseVertex(%s, %u, %u, %d, %s, %p, %d)\n",
                _mesa_lookup_enum_by_nr(mode), start, end, count,
                _mesa_lookup_enum_by_nr(type), indices, basevertex);

   if (!_mesa_validate_DrawRangeElements( ctx, mode, start, end, count,
                                          type, indices, basevertex ))
d343 5
a347 5
   /* NOTE: It's important that 'end' is a reasonable value.
    * in _tnl_draw_prims(), we use end to determine how many vertices
    * to transform.  If it's too large, we can unnecessarily split prims
    * or we can read/write out of memory in several different places!
    */
d349 1
a349 9
   /* Catch/fix some potential user errors */
   if (type == GL_UNSIGNED_BYTE) {
      start = MIN2(start, 0xff);
      end = MIN2(end, 0xff);
   }
   else if (type == GL_UNSIGNED_SHORT) {
      start = MIN2(start, 0xffff);
      end = MIN2(end, 0xffff);
   }
d351 3
a353 52
   if (end >= ctx->Array.ArrayObj->_MaxElement) {
      /* the max element is out of bounds of one or more enabled arrays */
      warnCount++;

      if (warnCount < 10) {
         _mesa_warning(ctx, "glDraw[Range]Elements(start %u, end %u, count %d, "
                       "type 0x%x, indices=%p)\n"
                       "\tend is out of bounds (max=%u)  "
                       "Element Buffer %u (size %d)\n"
                       "\tThis should probably be fixed in the application.",
                       start, end, count, type, indices,
                       ctx->Array.ArrayObj->_MaxElement - 1,
                       ctx->Array.ElementArrayBufferObj->Name,
                       (int) ctx->Array.ElementArrayBufferObj->Size);
      }

      if (0)
         dump_element_buffer(ctx, type);

      if (0)
         _mesa_print_arrays(ctx);

#ifdef DEBUG
      /* 'end' was out of bounds, but now let's check the actual array
       * indexes to see if any of them are out of bounds.
       */
      {
         GLuint max = _mesa_max_buffer_index(ctx, count, type, indices,
                                             ctx->Array.ElementArrayBufferObj);
         if (max >= ctx->Array.ArrayObj->_MaxElement) {
            if (warnCount < 10) {
               _mesa_warning(ctx, "glDraw[Range]Elements(start %u, end %u, "
                             "count %d, type 0x%x, indices=%p)\n"
                             "\tindex=%u is out of bounds (max=%u)  "
                             "Element Buffer %u (size %d)\n"
                             "\tSkipping the glDrawRangeElements() call",
                             start, end, count, type, indices, max,
                             ctx->Array.ArrayObj->_MaxElement - 1,
                             ctx->Array.ElementArrayBufferObj->Name,
                             (int) ctx->Array.ElementArrayBufferObj->Size);
            }
         }
         /* XXX we could also find the min index and compare to 'start'
          * to see if start is correct.  But it's more likely to get the
          * upper bound wrong.
          */
      }
#endif

      /* Set 'end' to the max possible legal value */
      assert(ctx->Array.ArrayObj->_MaxElement >= 1);
      end = ctx->Array.ArrayObj->_MaxElement - 1;
d355 2
a356 7
   else if (0) {
      printf("glDraw[Range]Elements{,BaseVertex}"
	     "(start %u, end %u, type 0x%x, count %d) ElemBuf %u, "
	     "base %d\n",
	     start, end, type, count,
	     ctx->Array.ElementArrayBufferObj->Name,
	     basevertex);
d359 1
a359 50
#if 0
   check_draw_elements_data(ctx, count, type, indices);
#else
   (void) check_draw_elements_data;
#endif

   vbo_validated_drawrangeelements(ctx, mode, GL_TRUE, start, end,
				   count, type, indices, basevertex, 1);
}


/**
 * Called by glDrawRangeElements() in immediate mode.
 */
static void GLAPIENTRY
vbo_exec_DrawRangeElements(GLenum mode, GLuint start, GLuint end,
                           GLsizei count, GLenum type, const GLvoid *indices)
{
   GET_CURRENT_CONTEXT(ctx);

   if (MESA_VERBOSE & VERBOSE_DRAW)
      _mesa_debug(ctx,
                  "glDrawRangeElements(%s, %u, %u, %d, %s, %p)\n",
                  _mesa_lookup_enum_by_nr(mode), start, end, count,
                  _mesa_lookup_enum_by_nr(type), indices);

   vbo_exec_DrawRangeElementsBaseVertex(mode, start, end, count, type,
					indices, 0);
}


/**
 * Called by glDrawElements() in immediate mode.
 */
static void GLAPIENTRY
vbo_exec_DrawElements(GLenum mode, GLsizei count, GLenum type,
                      const GLvoid *indices)
{
   GET_CURRENT_CONTEXT(ctx);

   if (MESA_VERBOSE & VERBOSE_DRAW)
      _mesa_debug(ctx, "glDrawElements(%s, %u, %s, %p)\n",
                  _mesa_lookup_enum_by_nr(mode), count,
                  _mesa_lookup_enum_by_nr(type), indices);

   if (!_mesa_validate_DrawElements( ctx, mode, count, type, indices, 0 ))
      return;

   vbo_validated_drawrangeelements(ctx, mode, GL_FALSE, ~0, ~0,
				   count, type, indices, 0, 1);
d363 2
a364 2
/**
 * Called by glDrawElementsBaseVertex() in immediate mode.
a365 5
static void GLAPIENTRY
vbo_exec_DrawElementsBaseVertex(GLenum mode, GLsizei count, GLenum type,
				const GLvoid *indices, GLint basevertex)
{
   GET_CURRENT_CONTEXT(ctx);
a366 4
   if (MESA_VERBOSE & VERBOSE_DRAW)
      _mesa_debug(ctx, "glDrawElementsBaseVertex(%s, %d, %s, %p, %d)\n",
                  _mesa_lookup_enum_by_nr(mode), count,
                  _mesa_lookup_enum_by_nr(type), indices, basevertex);
a367 7
   if (!_mesa_validate_DrawElements( ctx, mode, count, type, indices,
				     basevertex ))
      return;

   vbo_validated_drawrangeelements(ctx, mode, GL_FALSE, ~0, ~0,
				   count, type, indices, basevertex, 1);
}
d370 1
a370 218
/**
 * Called by glDrawElementsInstanced() in immediate mode.
 */
static void GLAPIENTRY
vbo_exec_DrawElementsInstanced(GLenum mode, GLsizei count, GLenum type,
                               const GLvoid *indices, GLsizei primcount)
{
   GET_CURRENT_CONTEXT(ctx);

   if (MESA_VERBOSE & VERBOSE_DRAW)
      _mesa_debug(ctx, "glDrawElementsInstanced(%s, %d, %s, %p, %d)\n",
                  _mesa_lookup_enum_by_nr(mode), count,
                  _mesa_lookup_enum_by_nr(type), indices, primcount);

   if (!_mesa_validate_DrawElementsInstanced(ctx, mode, count, type, indices,
                                             primcount))
      return;

   vbo_validated_drawrangeelements(ctx, mode, GL_FALSE, ~0, ~0,
				   count, type, indices, 0, primcount);
}


/**
 * Inner support for both _mesa_MultiDrawElements() and
 * _mesa_MultiDrawRangeElements().
 * This does the actual rendering after we've checked array indexes, etc.
 */
static void
vbo_validated_multidrawelements(struct gl_context *ctx, GLenum mode,
				const GLsizei *count, GLenum type,
				const GLvoid **indices, GLsizei primcount,
				const GLint *basevertex)
{
   struct vbo_context *vbo = vbo_context(ctx);
   struct vbo_exec_context *exec = &vbo->exec;
   struct _mesa_index_buffer ib;
   struct _mesa_prim *prim;
   unsigned int index_type_size = 0;
   uintptr_t min_index_ptr, max_index_ptr;
   GLboolean fallback = GL_FALSE;
   int i;

   if (primcount == 0)
      return;

   FLUSH_CURRENT( ctx, 0 );

   if (!_mesa_valid_to_render(ctx, "glMultiDrawElements")) {
      return;
   }

   prim = calloc(1, primcount * sizeof(*prim));
   if (prim == NULL) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glMultiDrawElements");
      return;
   }

   /* Decide if we can do this all as one set of primitives sharing the
    * same index buffer, or if we have to reset the index pointer per
    * primitive.
    */
   bind_arrays( ctx );

   /* check for dirty state again */
   if (ctx->NewState)
      _mesa_update_state( ctx );

   switch (type) {
   case GL_UNSIGNED_INT:
      index_type_size = 4;
      break;
   case GL_UNSIGNED_SHORT:
      index_type_size = 2;
      break;
   case GL_UNSIGNED_BYTE:
      index_type_size = 1;
      break;
   default:
      assert(0);
   }

   min_index_ptr = (uintptr_t)indices[0];
   max_index_ptr = 0;
   for (i = 0; i < primcount; i++) {
      min_index_ptr = MIN2(min_index_ptr, (uintptr_t)indices[i]);
      max_index_ptr = MAX2(max_index_ptr, (uintptr_t)indices[i] +
			   index_type_size * count[i]);
   }

   /* Check if we can handle this thing as a bunch of index offsets from the
    * same index pointer.  If we can't, then we have to fall back to doing
    * a draw_prims per primitive.
    * Check that the difference between each prim's indexes is a multiple of
    * the index/element size.
    */
   if (index_type_size != 1) {
      for (i = 0; i < primcount; i++) {
	 if ((((uintptr_t)indices[i] - min_index_ptr) % index_type_size) != 0) {
	    fallback = GL_TRUE;
	    break;
	 }
      }
   }

   /* If the index buffer isn't in a VBO, then treating the application's
    * subranges of the index buffer as one large index buffer may lead to
    * us reading unmapped memory.
    */
   if (!_mesa_is_bufferobj(ctx->Array.ElementArrayBufferObj))
      fallback = GL_TRUE;

   if (!fallback) {
      ib.count = (max_index_ptr - min_index_ptr) / index_type_size;
      ib.type = type;
      ib.obj = ctx->Array.ElementArrayBufferObj;
      ib.ptr = (void *)min_index_ptr;

      for (i = 0; i < primcount; i++) {
	 prim[i].begin = (i == 0);
	 prim[i].end = (i == primcount - 1);
	 prim[i].weak = 0;
	 prim[i].pad = 0;
	 prim[i].mode = mode;
	 prim[i].start = ((uintptr_t)indices[i] - min_index_ptr) / index_type_size;
	 prim[i].count = count[i];
	 prim[i].indexed = 1;
         prim[i].num_instances = 1;
	 if (basevertex != NULL)
	    prim[i].basevertex = basevertex[i];
	 else
	    prim[i].basevertex = 0;
      }

      vbo->draw_prims(ctx, exec->array.inputs, prim, primcount, &ib,
		      GL_FALSE, ~0, ~0);
   } else {
      /* render one prim at a time */
      for (i = 0; i < primcount; i++) {
	 ib.count = count[i];
	 ib.type = type;
	 ib.obj = ctx->Array.ElementArrayBufferObj;
	 ib.ptr = indices[i];

	 prim[0].begin = 1;
	 prim[0].end = 1;
	 prim[0].weak = 0;
	 prim[0].pad = 0;
	 prim[0].mode = mode;
	 prim[0].start = 0;
	 prim[0].count = count[i];
	 prim[0].indexed = 1;
         prim[0].num_instances = 1;
	 if (basevertex != NULL)
	    prim[0].basevertex = basevertex[i];
	 else
	    prim[0].basevertex = 0;

         vbo->draw_prims(ctx, exec->array.inputs, prim, 1, &ib,
                         GL_FALSE, ~0, ~0);
      }
   }

   free(prim);
}


static void GLAPIENTRY
vbo_exec_MultiDrawElements(GLenum mode,
			   const GLsizei *count, GLenum type,
			   const GLvoid **indices,
			   GLsizei primcount)
{
   GET_CURRENT_CONTEXT(ctx);
   GLint i;

   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

   for (i = 0; i < primcount; i++) {
      if (!_mesa_validate_DrawElements(ctx, mode, count[i], type, indices[i],
				       0))
	 return;
   }

   vbo_validated_multidrawelements(ctx, mode, count, type, indices, primcount,
				   NULL);
}


static void GLAPIENTRY
vbo_exec_MultiDrawElementsBaseVertex(GLenum mode,
				     const GLsizei *count, GLenum type,
				     const GLvoid **indices,
				     GLsizei primcount,
				     const GLsizei *basevertex)
{
   GET_CURRENT_CONTEXT(ctx);
   GLint i;

   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

   for (i = 0; i < primcount; i++) {
      if (!_mesa_validate_DrawElements(ctx, mode, count[i], type, indices[i],
				       basevertex[i]))
	 return;
   }

   vbo_validated_multidrawelements(ctx, mode, count, type, indices, primcount,
				   basevertex);
}


/**
 * Plug in the immediate-mode vertex array drawing commands into the
 * givven vbo_exec_context object.
 */
void
vbo_exec_array_init( struct vbo_exec_context *exec )
d372 1
d376 5
a380 6
   exec->vtxfmt.MultiDrawElementsEXT = vbo_exec_MultiDrawElements;
   exec->vtxfmt.DrawElementsBaseVertex = vbo_exec_DrawElementsBaseVertex;
   exec->vtxfmt.DrawRangeElementsBaseVertex = vbo_exec_DrawRangeElementsBaseVertex;
   exec->vtxfmt.MultiDrawElementsBaseVertex = vbo_exec_MultiDrawElementsBaseVertex;
   exec->vtxfmt.DrawArraysInstanced = vbo_exec_DrawArraysInstanced;
   exec->vtxfmt.DrawElementsInstanced = vbo_exec_DrawElementsInstanced;
d384 1
a384 2
void
vbo_exec_array_destroy( struct vbo_exec_context *exec )
a386 67
}



/**
 * The following functions are only used for OpenGL ES 1/2 support.
 * And some aren't even supported (yet) in ES 1/2.
 */


void GLAPIENTRY
_mesa_DrawArrays(GLenum mode, GLint first, GLsizei count)
{
   vbo_exec_DrawArrays(mode, first, count);
}


void GLAPIENTRY
_mesa_DrawElements(GLenum mode, GLsizei count, GLenum type,
                   const GLvoid *indices)
{
   vbo_exec_DrawElements(mode, count, type, indices);
}


void GLAPIENTRY
_mesa_DrawElementsBaseVertex(GLenum mode, GLsizei count, GLenum type,
			     const GLvoid *indices, GLint basevertex)
{
   vbo_exec_DrawElementsBaseVertex(mode, count, type, indices, basevertex);
}


void GLAPIENTRY
_mesa_DrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count,
                        GLenum type, const GLvoid *indices)
{
   vbo_exec_DrawRangeElements(mode, start, end, count, type, indices);
}


void GLAPIENTRY
_mesa_DrawRangeElementsBaseVertex(GLenum mode, GLuint start, GLuint end,
				  GLsizei count, GLenum type,
				  const GLvoid *indices, GLint basevertex)
{
   vbo_exec_DrawRangeElementsBaseVertex(mode, start, end, count, type,
					indices, basevertex);
}


void GLAPIENTRY
_mesa_MultiDrawElementsEXT(GLenum mode, const GLsizei *count, GLenum type,
			   const GLvoid **indices, GLsizei primcount)
{
   vbo_exec_MultiDrawElements(mode, count, type, indices, primcount);
}


void GLAPIENTRY
_mesa_MultiDrawElementsBaseVertex(GLenum mode,
				  const GLsizei *count, GLenum type,
				  const GLvoid **indices, GLsizei primcount,
				  const GLint *basevertex)
{
   vbo_exec_MultiDrawElementsBaseVertex(mode, count, type, indices,
					primcount, basevertex);
@


1.1.1.3
log
@Import Mesa 9.2.0
@
text
@a32 1
#include "main/dispatch.h"
a36 1
#include "main/transformfeedback.h"
a41 38
 * All vertex buffers should be in an unmapped state when we're about
 * to draw.  This debug function checks that.
 */
static void
check_buffers_are_unmapped(const struct gl_client_array **inputs)
{
#ifdef DEBUG
   GLuint i;

   for (i = 0; i < VERT_ATTRIB_MAX; i++) {
      if (inputs[i]) {
         struct gl_buffer_object *obj = inputs[i]->BufferObj;
         assert(!_mesa_bufferobj_mapped(obj));
         (void) obj;
      }
   }
#endif
}


/**
 * A debug function that may be called from other parts of Mesa as
 * needed during debugging.
 */
void
vbo_check_buffers_are_unmapped(struct gl_context *ctx)
{
   struct vbo_context *vbo = vbo_context(ctx);
   struct vbo_exec_context *exec = &vbo->exec;
   /* check the current vertex arrays */
   check_buffers_are_unmapped(exec->array.inputs);
   /* check the current glBegin/glVertex/glEnd-style VBO */
   assert(!_mesa_bufferobj_mapped(exec->vtx.bufferobj));
}



/**
d47 1
a47 1
static void
d51 1
a51 2
		     GLuint *min_index, GLuint *max_index,
		     const GLuint count)
d53 4
a56 4
   const GLboolean restart = ctx->Array._PrimitiveRestart;
   const GLuint restartIndex = _mesa_primitive_restart_index(ctx, ib->type);
   const int index_size = vbo_sizeof_ib_type(ib->type);
   const char *indices;
a58 1
   indices = (char *) ib->ptr + prim->start * index_size;
d60 6
a65 3
      GLsizeiptr size = MIN2(count * index_size, ib->obj->Size);
      indices = ctx->Driver.MapBufferRange(ctx, (GLintptr) indices, size,
                                           GL_MAP_READ_BIT, ib->obj);
d141 1
a141 36
      ctx->Driver.UnmapBuffer(ctx, ib->obj);
   }
}

/**
 * Compute min and max elements for nr_prims
 */
void
vbo_get_minmax_indices(struct gl_context *ctx,
                       const struct _mesa_prim *prims,
                       const struct _mesa_index_buffer *ib,
                       GLuint *min_index,
                       GLuint *max_index,
                       GLuint nr_prims)
{
   GLuint tmp_min, tmp_max;
   GLuint i;
   GLuint count;

   *min_index = ~0;
   *max_index = 0;

   for (i = 0; i < nr_prims; i++) {
      const struct _mesa_prim *start_prim;

      start_prim = &prims[i];
      count = start_prim->count;
      /* Do combination if possible to reduce map/unmap count */
      while ((i + 1 < nr_prims) &&
             (prims[i].start + prims[i].count == prims[i+1].start)) {
         count += prims[i+1].count;
         i++;
      }
      vbo_get_minmax_index(ctx, start_prim, ib, &tmp_min, &tmp_max, count);
      *min_index = MIN2(*min_index, tmp_min);
      *max_index = MAX2(*max_index, tmp_max);
d161 2
a162 2
               ctx->Driver.MapBufferRange(ctx, 0, array->BufferObj->Size,
					  GL_MAP_READ_BIT, array->BufferObj);
d203 1
a203 1
      ctx->Driver.UnmapBuffer(ctx, array->BufferObj);
d220 5
a224 5
   if (_mesa_is_bufferobj(ctx->Array.ArrayObj->ElementArrayBufferObj)) {
      elemMap = ctx->Driver.MapBufferRange(ctx, 0,
					   ctx->Array.ArrayObj->ElementArrayBufferObj->Size,
					   GL_MAP_READ_BIT,
					   ctx->Array.ArrayObj->ElementArrayBufferObj);
d247 7
d255 2
a256 1
         check_array_data(ctx, &arrayObj->VertexAttrib[k], k, j);
d260 3
a262 2
   if (_mesa_is_bufferobj(arrayObj->ElementArrayBufferObj)) {
      ctx->Driver.UnmapBuffer(ctx, ctx->Array.ArrayObj->ElementArrayBufferObj);
d265 6
a295 1
   struct gl_array_object *arrayObj = ctx->Array.ArrayObj;
d302 1
a302 2
      struct gl_buffer_object *bufObj = exec->array.inputs[i]->BufferObj;
      GLuint bufName = bufObj->Name;
d310 1
a310 1
	     arrayObj->VertexAttrib[VERT_ATTRIB_FF(i)].Enabled,
d315 3
a317 2
         GLubyte *p = ctx->Driver.MapBufferRange(ctx, 0, bufObj->Size,
						 GL_MAP_READ_BIT, bufObj);
d329 1
a329 1
         ctx->Driver.UnmapBuffer(ctx, bufObj);
d336 43
a390 1
   struct gl_client_array *vertexAttrib = ctx->Array.ArrayObj->VertexAttrib;
d392 1
a392 1
   GLbitfield64 const_inputs = 0x0;
d395 4
a398 1
   switch (get_program_mode(ctx)) {
d405 3
a407 3
      for (i = 0; i < VERT_ATTRIB_FF_MAX; i++) {
	 if (vertexAttrib[VERT_ATTRIB_FF(i)].Enabled)
	    inputs[i] = &vertexAttrib[VERT_ATTRIB_FF(i)];
d409 2
a410 2
	    inputs[i] = &vbo->currval[VBO_ATTRIB_POS+i];
            const_inputs |= VERT_BIT(i);
d415 2
a416 3
	 inputs[VERT_ATTRIB_GENERIC(i)] =
	    &vbo->currval[VBO_ATTRIB_MAT_FRONT_AMBIENT+i];
         const_inputs |= VERT_BIT_GENERIC(i);
d422 3
a424 3
      for (i = MAT_ATTRIB_MAX; i < VERT_ATTRIB_GENERIC_MAX; i++) {
	 inputs[VERT_ATTRIB_GENERIC(i)] = &vbo->currval[VBO_ATTRIB_GENERIC0+i];
         const_inputs |= VERT_BIT_GENERIC(i);
d428 18
a445 4
   case VP_ARB:
      /* There are no shaders in OpenGL ES 1.x, so this code path should be
       * impossible to reach.  The meta code is careful to not use shaders in
       * ES1.
d447 5
a451 1
      assert(ctx->API != API_OPENGLES);
d453 2
a454 1
      /* In the compatibility profile of desktop OpenGL, the generic[0]
d456 1
a459 3
       *
       * In all other APIs, only the generic attributes exist, and none of the
       * slots are considered "magic."
d461 8
a468 9
      if (ctx->API == API_OPENGL_COMPAT) {
         if (vertexAttrib[VERT_ATTRIB_GENERIC0].Enabled)
            inputs[0] = &vertexAttrib[VERT_ATTRIB_GENERIC0];
         else if (vertexAttrib[VERT_ATTRIB_POS].Enabled)
            inputs[0] = &vertexAttrib[VERT_ATTRIB_POS];
         else {
            inputs[0] = &vbo->currval[VBO_ATTRIB_POS];
            const_inputs |= VERT_BIT_POS;
         }
d470 6
a475 7
         for (i = 1; i < VERT_ATTRIB_FF_MAX; i++) {
            if (vertexAttrib[VERT_ATTRIB_FF(i)].Enabled)
               inputs[i] = &vertexAttrib[VERT_ATTRIB_FF(i)];
            else {
               inputs[i] = &vbo->currval[VBO_ATTRIB_POS+i];
               const_inputs |= VERT_BIT_FF(i);
            }
d477 1
d479 6
a484 23
         for (i = 1; i < VERT_ATTRIB_GENERIC_MAX; i++) {
            if (vertexAttrib[VERT_ATTRIB_GENERIC(i)].Enabled)
               inputs[VERT_ATTRIB_GENERIC(i)] =
                  &vertexAttrib[VERT_ATTRIB_GENERIC(i)];
            else {
               inputs[VERT_ATTRIB_GENERIC(i)] =
                  &vbo->currval[VBO_ATTRIB_GENERIC0+i];
               const_inputs |= VERT_BIT_GENERIC(i);
            }
         }

         inputs[VERT_ATTRIB_GENERIC0] = inputs[0];
      } else {
         /* Other parts of the code assume that inputs[0] through
          * inputs[VERT_ATTRIB_FF_MAX] will be non-NULL.  However, in OpenGL
          * ES 2.0+ or OpenGL core profile, none of these arrays should ever
          * be enabled.
          */
         for (i = 0; i < VERT_ATTRIB_FF_MAX; i++) {
            assert(!vertexAttrib[VERT_ATTRIB_FF(i)].Enabled);

            inputs[i] = &vbo->currval[VBO_ATTRIB_POS+i];
            const_inputs |= VERT_BIT_FF(i);
a486 10
         for (i = 0; i < VERT_ATTRIB_GENERIC_MAX; i++) {
            if (vertexAttrib[VERT_ATTRIB_GENERIC(i)].Enabled)
               inputs[VERT_ATTRIB_GENERIC(i)] =
                  &vertexAttrib[VERT_ATTRIB_GENERIC(i)];
            else {
               inputs[VERT_ATTRIB_GENERIC(i)] =
                  &vbo->currval[VBO_ATTRIB_GENERIC0+i];
               const_inputs |= VERT_BIT_GENERIC(i);
            }
         }
a487 1

d491 1
a491 2
   _mesa_set_varying_vp_inputs( ctx, VERT_BIT_ALL & (~const_inputs) );
   ctx->NewDriverState |= ctx->DriverFlags.NewArray;
d499 2
a500 38
 * Note that this might set the _NEW_VARYING_VP_INPUTS dirty flag so state
 * validation must be done after this call.
 */
void
vbo_bind_arrays(struct gl_context *ctx)
{
   struct vbo_context *vbo = vbo_context(ctx);
   struct vbo_exec_context *exec = &vbo->exec;

   vbo_draw_method(vbo, DRAW_ARRAYS);

   if (exec->array.recalculate_inputs) {
      recalculate_input_bindings(ctx);
      exec->array.recalculate_inputs = GL_FALSE;

      /* Again... because we may have changed the bitmask of per-vertex varying
       * attributes.  If we regenerate the fixed-function vertex program now
       * we may be able to prune down the number of vertex attributes which we
       * need in the shader.
       */
      if (ctx->NewState) {
         /* Setting "validating" to TRUE prevents _mesa_update_state from
          * invalidating what we just did.
          */
         exec->validating = GL_TRUE;
         _mesa_update_state(ctx);
         exec->validating = GL_FALSE;
      }
   }
}


/**
 * Handle a draw case that potentially has primitive restart enabled.
 *
 * If primitive restart is enabled, and PrimitiveRestartInSoftware is
 * set, then vbo_sw_primitive_restart is used to handle the primitive
 * restart case in software.
d503 1
a503 7
vbo_handle_primitive_restart(struct gl_context *ctx,
                             const struct _mesa_prim *prim,
                             GLuint nr_prims,
                             const struct _mesa_index_buffer *ib,
                             GLboolean index_bounds_valid,
                             GLuint min_index,
                             GLuint max_index)
d505 2
a506 12
   struct vbo_context *vbo = vbo_context(ctx);

   if ((ib != NULL) &&
       ctx->Const.PrimitiveRestartInSoftware &&
       ctx->Array._PrimitiveRestart) {
      /* Handle primitive restart in software */
      vbo_sw_primitive_restart(ctx, prim, nr_prims, ib);
   } else {
      /* Call driver directly for draw_prims */
      vbo->draw_prims(ctx, prim, nr_prims, ib,
                      index_bounds_valid, min_index, max_index, NULL);
   }
d518 1
a518 1
                GLsizei count, GLuint numInstances, GLuint baseInstance)
d524 9
a532 1
   vbo_bind_arrays(ctx);
a533 2
   /* init most fields to zero */
   memset(prim, 0, sizeof(prim));
d536 2
d539 4
a543 1
   prim[0].base_instance = baseInstance;
d579 2
a580 3
         check_buffers_are_unmapped(exec->array.inputs);
         vbo->draw_prims(ctx, prim, primCount, NULL,
                         GL_TRUE, start, start + count - 1, NULL);
d588 2
a589 8
      check_buffers_are_unmapped(exec->array.inputs);
      vbo->draw_prims(ctx, prim, 1, NULL,
                      GL_TRUE, start, start + count - 1,
                      NULL);
   }

   if (MESA_DEBUG_FLAGS & DEBUG_ALWAYS_FLUSH) {
      _mesa_flush(ctx);
a593 122
/**
 * Execute a glRectf() function.
 */
static void GLAPIENTRY
vbo_exec_Rectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2)
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   CALL_Begin(GET_DISPATCH(), (GL_QUADS));
   CALL_Vertex2f(GET_DISPATCH(), (x1, y1));
   CALL_Vertex2f(GET_DISPATCH(), (x2, y1));
   CALL_Vertex2f(GET_DISPATCH(), (x2, y2));
   CALL_Vertex2f(GET_DISPATCH(), (x1, y2));
   CALL_End(GET_DISPATCH(), ());
}


static void GLAPIENTRY
vbo_exec_EvalMesh1(GLenum mode, GLint i1, GLint i2)
{
   GET_CURRENT_CONTEXT(ctx);
   GLint i;
   GLfloat u, du;
   GLenum prim;

   switch (mode) {
   case GL_POINT:
      prim = GL_POINTS;
      break;
   case GL_LINE:
      prim = GL_LINE_STRIP;
      break;
   default:
      _mesa_error( ctx, GL_INVALID_ENUM, "glEvalMesh1(mode)" );
      return;
   }

   /* No effect if vertex maps disabled.
    */
   if (!ctx->Eval.Map1Vertex4 && 
       !ctx->Eval.Map1Vertex3)
      return;

   du = ctx->Eval.MapGrid1du;
   u = ctx->Eval.MapGrid1u1 + i1 * du;

   CALL_Begin(GET_DISPATCH(), (prim));
   for (i=i1;i<=i2;i++,u+=du) {
      CALL_EvalCoord1f(GET_DISPATCH(), (u));
   }
   CALL_End(GET_DISPATCH(), ());
}


static void GLAPIENTRY
vbo_exec_EvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2)
{
   GET_CURRENT_CONTEXT(ctx);
   GLfloat u, du, v, dv, v1, u1;
   GLint i, j;

   switch (mode) {
   case GL_POINT:
   case GL_LINE:
   case GL_FILL:
      break;
   default:
      _mesa_error( ctx, GL_INVALID_ENUM, "glEvalMesh2(mode)" );
      return;
   }

   /* No effect if vertex maps disabled.
    */
   if (!ctx->Eval.Map2Vertex4 && 
       !ctx->Eval.Map2Vertex3)
      return;

   du = ctx->Eval.MapGrid2du;
   dv = ctx->Eval.MapGrid2dv;
   v1 = ctx->Eval.MapGrid2v1 + j1 * dv;
   u1 = ctx->Eval.MapGrid2u1 + i1 * du;

   switch (mode) {
   case GL_POINT:
      CALL_Begin(GET_DISPATCH(), (GL_POINTS));
      for (v=v1,j=j1;j<=j2;j++,v+=dv) {
	 for (u=u1,i=i1;i<=i2;i++,u+=du) {
	    CALL_EvalCoord2f(GET_DISPATCH(), (u, v));
	 }
      }
      CALL_End(GET_DISPATCH(), ());
      break;
   case GL_LINE:
      for (v=v1,j=j1;j<=j2;j++,v+=dv) {
	 CALL_Begin(GET_DISPATCH(), (GL_LINE_STRIP));
	 for (u=u1,i=i1;i<=i2;i++,u+=du) {
	    CALL_EvalCoord2f(GET_DISPATCH(), (u, v));
	 }
	 CALL_End(GET_DISPATCH(), ());
      }
      for (u=u1,i=i1;i<=i2;i++,u+=du) {
	 CALL_Begin(GET_DISPATCH(), (GL_LINE_STRIP));
	 for (v=v1,j=j1;j<=j2;j++,v+=dv) {
	    CALL_EvalCoord2f(GET_DISPATCH(), (u, v));
	 }
	 CALL_End(GET_DISPATCH(), ());
      }
      break;
   case GL_FILL:
      for (v=v1,j=j1;j<j2;j++,v+=dv) {
	 CALL_Begin(GET_DISPATCH(), (GL_TRIANGLE_STRIP));
	 for (u=u1,i=i1;i<=i2;i++,u+=du) {
	    CALL_EvalCoord2f(GET_DISPATCH(), (u, v));
	    CALL_EvalCoord2f(GET_DISPATCH(), (u, v+dv));
	 }
	 CALL_End(GET_DISPATCH(), ());
      }
      break;
   }
}

d610 6
d619 1
a619 1
   vbo_draw_arrays(ctx, mode, start, count, 1, 0);
d632 1
a632 1
                             GLsizei numInstances)
d638 1
a638 1
                  _mesa_lookup_enum_by_nr(mode), start, count, numInstances);
d640 1
a640 1
   if (!_mesa_validate_DrawArraysInstanced(ctx, mode, start, count, numInstances))
d643 1
a643 8
   if (0)
      check_draw_arrays_data(ctx, start, count);

   vbo_draw_arrays(ctx, mode, start, count, numInstances, 0);

   if (0)
      print_draw_arrays(ctx, mode, start, count);
}
d645 1
a645 17

/**
 * Called from glDrawArraysInstancedBaseInstance when in immediate mode.
 */
static void GLAPIENTRY
vbo_exec_DrawArraysInstancedBaseInstance(GLenum mode, GLint first, GLsizei count,
                                         GLsizei numInstances, GLuint baseInstance)
{
   GET_CURRENT_CONTEXT(ctx);

   if (MESA_VERBOSE & VERBOSE_DRAW)
      _mesa_debug(ctx, "glDrawArraysInstancedBaseInstance(%s, %d, %d, %d, %d)\n",
                  _mesa_lookup_enum_by_nr(mode), first, count,
                  numInstances, baseInstance);

   if (!_mesa_validate_DrawArraysInstanced(ctx, mode, first, count,
                                           numInstances))
d647 1
d650 1
a650 1
      check_draw_arrays_data(ctx, first, count);
d652 1
a652 1
   vbo_draw_arrays(ctx, mode, first, count, numInstances, baseInstance);
d655 1
a655 1
      print_draw_arrays(ctx, mode, first, count);
a658 1

a662 1
#if 0
d666 4
a669 5
   const GLvoid *map =
      ctx->Driver.MapBufferRange(ctx, 0,
				 ctx->Array.ArrayObj->ElementArrayBufferObj->Size,
				 GL_MAP_READ_BIT,
				 ctx->Array.ArrayObj->ElementArrayBufferObj);
d675 1
a675 1
         for (i = 0; i < ctx->Array.ArrayObj->ElementArrayBufferObj->Size; i++) {
d687 1
a687 1
         for (i = 0; i < ctx->Array.ArrayObj->ElementArrayBufferObj->Size / 2; i++) {
d699 1
a699 1
         for (i = 0; i < ctx->Array.ArrayObj->ElementArrayBufferObj->Size / 4; i++) {
d711 2
a712 1
   ctx->Driver.UnmapBuffer(ctx, ctx->Array.ArrayObj->ElementArrayBufferObj);
a713 1
#endif
d727 1
a727 2
				GLint basevertex, GLuint numInstances,
				GLuint baseInstance)
d734 11
a744 1
   vbo_bind_arrays(ctx);
d748 1
a748 1
   ib.obj = ctx->Array.ArrayObj->ElementArrayBufferObj;
d760 1
a760 2
   prim[0].num_instances = numInstances;
   prim[0].base_instance = baseInstance;
d793 2
a794 7
   check_buffers_are_unmapped(exec->array.inputs);
   vbo_handle_primitive_restart(ctx, prim, 1, &ib,
                                index_bounds_valid, start, end);

   if (MESA_DEBUG_FLAGS & DEBUG_ALWAYS_FLUSH) {
      _mesa_flush(ctx);
   }
a808 2
   GLboolean index_bounds_valid = GL_TRUE;
   GLuint max_element;
a820 39
   if (ctx->Const.CheckArrayBounds) {
      /* _MaxElement was computed, so we can use it.
       * This path is used for drivers which need strict bounds checking.
       */
      max_element = ctx->Array.ArrayObj->_MaxElement;
   }
   else {
      /* Generally, hardware drivers don't need to know the buffer bounds
       * if all vertex attributes are in VBOs.
       * However, if none of vertex attributes are in VBOs, _MaxElement
       * is always set to some random big number anyway, so bounds checking
       * is mostly useless.
       *
       * This is only useful to catch invalid values in the "end" parameter
       * like ~0.
       */
      max_element = 2 * 1000 * 1000 * 1000; /* just a big number */
   }

   if ((int) end + basevertex < 0 ||
       start + basevertex >= max_element) {
      /* The application requested we draw using a range of indices that's
       * outside the bounds of the current VBO.  This is invalid and appears
       * to give undefined results.  The safest thing to do is to simply
       * ignore the range, in case the application botched their range tracking
       * but did provide valid indices.  Also issue a warning indicating that
       * the application is broken.
       */
      if (warnCount++ < 10) {
         _mesa_warning(ctx, "glDrawRangeElements(start %u, end %u, "
                       "basevertex %d, count %d, type 0x%x, indices=%p):\n"
                       "\trange is outside VBO bounds (max=%u); ignoring.\n"
                       "\tThis should be fixed in the application.",
                       start, end, basevertex, count, type, indices,
                       max_element - 1);
      }
      index_bounds_valid = GL_FALSE;
   }

d837 54
a890 1
   if (0) {
d895 1
a895 1
	     ctx->Array.ArrayObj->ElementArrayBufferObj->Name,
a898 4
   if ((int) start + basevertex < 0 ||
       end + basevertex >= max_element)
      index_bounds_valid = GL_FALSE;

d905 2
a906 2
   vbo_validated_drawrangeelements(ctx, mode, index_bounds_valid, start, end,
				   count, type, indices, basevertex, 1, 0);
d917 3
a919 2
   if (MESA_VERBOSE & VERBOSE_DRAW) {
      GET_CURRENT_CONTEXT(ctx);
a923 1
   }
d948 1
a948 1
				   count, type, indices, 0, 1, 0);
d971 1
a971 1
				   count, type, indices, basevertex, 1, 0);
d980 1
a980 1
                               const GLvoid *indices, GLsizei numInstances)
d987 1
a987 1
                  _mesa_lookup_enum_by_nr(type), indices, numInstances);
d990 1
a990 1
                                             numInstances, 0))
d994 1
a994 78
				   count, type, indices, 0, numInstances, 0);
}


/**
 * Called by glDrawElementsInstancedBaseVertex() in immediate mode.
 */
static void GLAPIENTRY
vbo_exec_DrawElementsInstancedBaseVertex(GLenum mode, GLsizei count, GLenum type,
                               const GLvoid *indices, GLsizei numInstances,
                               GLint basevertex)
{
   GET_CURRENT_CONTEXT(ctx);

   if (MESA_VERBOSE & VERBOSE_DRAW)
      _mesa_debug(ctx, "glDrawElementsInstancedBaseVertex(%s, %d, %s, %p, %d; %d)\n",
                  _mesa_lookup_enum_by_nr(mode), count,
                  _mesa_lookup_enum_by_nr(type), indices,
                  numInstances, basevertex);

   if (!_mesa_validate_DrawElementsInstanced(ctx, mode, count, type, indices,
                                             numInstances, basevertex))
      return;

   vbo_validated_drawrangeelements(ctx, mode, GL_FALSE, ~0, ~0,
				   count, type, indices, basevertex, numInstances, 0);
}


/**
 * Called by glDrawElementsInstancedBaseInstance() in immediate mode.
 */
static void GLAPIENTRY
vbo_exec_DrawElementsInstancedBaseInstance(GLenum mode, GLsizei count, GLenum type,
                                           const GLvoid *indices, GLsizei numInstances,
                                           GLuint baseInstance)
{
   GET_CURRENT_CONTEXT(ctx);

   if (MESA_VERBOSE & VERBOSE_DRAW)
      _mesa_debug(ctx, "glDrawElementsInstancedBaseInstance(%s, %d, %s, %p, %d, %d)\n",
                  _mesa_lookup_enum_by_nr(mode), count,
                  _mesa_lookup_enum_by_nr(type), indices,
                  numInstances, baseInstance);

   if (!_mesa_validate_DrawElementsInstanced(ctx, mode, count, type, indices,
                                             numInstances, 0))
      return;

   vbo_validated_drawrangeelements(ctx, mode, GL_FALSE, ~0, ~0,
                                   count, type, indices, 0, numInstances,
                                   baseInstance);
}


/**
 * Called by glDrawElementsInstancedBaseVertexBaseInstance() in immediate mode.
 */
static void GLAPIENTRY
vbo_exec_DrawElementsInstancedBaseVertexBaseInstance(GLenum mode, GLsizei count, GLenum type,
                                                     const GLvoid *indices, GLsizei numInstances,
                                                     GLint basevertex, GLuint baseInstance)
{
   GET_CURRENT_CONTEXT(ctx);

   if (MESA_VERBOSE & VERBOSE_DRAW)
      _mesa_debug(ctx, "glDrawElementsInstancedBaseVertexBaseInstance(%s, %d, %s, %p, %d, %d, %d)\n",
                  _mesa_lookup_enum_by_nr(mode), count,
                  _mesa_lookup_enum_by_nr(type), indices,
                  numInstances, basevertex, baseInstance);

   if (!_mesa_validate_DrawElementsInstanced(ctx, mode, count, type, indices,
                                             numInstances, basevertex))
      return;

   vbo_validated_drawrangeelements(ctx, mode, GL_FALSE, ~0, ~0,
                                   count, type, indices, basevertex, numInstances,
                                   baseInstance);
d1006 1
a1006 2
				const GLvoid * const *indices,
				GLsizei primcount,
d1013 1
a1013 1
   unsigned int index_type_size = vbo_sizeof_ib_type(type);
d1021 6
d1033 23
a1055 1
   vbo_bind_arrays(ctx);
d1084 1
a1084 1
   if (!_mesa_is_bufferobj(ctx->Array.ArrayObj->ElementArrayBufferObj))
d1090 1
a1090 1
      ib.obj = ctx->Array.ArrayObj->ElementArrayBufferObj;
a1102 1
         prim[i].base_instance = 0;
d1109 2
a1110 3
      check_buffers_are_unmapped(exec->array.inputs);
      vbo_handle_primitive_restart(ctx, prim, primcount, &ib,
                                   GL_FALSE, ~0, ~0);
d1116 1
a1116 1
	 ib.obj = ctx->Array.ArrayObj->ElementArrayBufferObj;
a1127 1
         prim[0].base_instance = 0;
d1133 2
a1134 3
         check_buffers_are_unmapped(exec->array.inputs);
         vbo_handle_primitive_restart(ctx, prim, 1, &ib,
                                      GL_FALSE, ~0, ~0);
a1138 4

   if (MESA_DEBUG_FLAGS & DEBUG_ALWAYS_FLUSH) {
      _mesa_flush(ctx);
   }
d1145 1
a1145 1
			   const GLvoid * const *indices,
d1149 3
d1153 5
a1157 3
   if (!_mesa_validate_MultiDrawElements(ctx, mode, count, type, indices,
                                         primcount, NULL))
      return;
d1167 1
a1167 1
				     const GLvoid * const *indices,
d1172 3
d1176 5
a1180 3
   if (!_mesa_validate_MultiDrawElements(ctx, mode, count, type, indices,
                                         primcount, basevertex))
      return;
a1185 36
static void
vbo_draw_transform_feedback(struct gl_context *ctx, GLenum mode,
                            struct gl_transform_feedback_object *obj,
                            GLuint stream, GLuint numInstances)
{
   struct vbo_context *vbo = vbo_context(ctx);
   struct vbo_exec_context *exec = &vbo->exec;
   struct _mesa_prim prim[2];

   if (!_mesa_validate_DrawTransformFeedback(ctx, mode, obj, stream,
                                             numInstances)) {
      return;
   }

   vbo_bind_arrays(ctx);

   /* init most fields to zero */
   memset(prim, 0, sizeof(prim));
   prim[0].begin = 1;
   prim[0].end = 1;
   prim[0].mode = mode;
   prim[0].num_instances = numInstances;
   prim[0].base_instance = 0;

   /* Maybe we should do some primitive splitting for primitive restart
    * (like in DrawArrays), but we have no way to know how many vertices
    * will be rendered. */

   check_buffers_are_unmapped(exec->array.inputs);
   vbo->draw_prims(ctx, prim, 1, NULL,
                   GL_TRUE, 0, 0, obj);

   if (MESA_DEBUG_FLAGS & DEBUG_ALWAYS_FLUSH) {
      _mesa_flush(ctx);
   }
}
d1188 2
a1189 6
 * Like DrawArrays, but take the count from a transform feedback object.
 * \param mode  GL_POINTS, GL_LINES, GL_TRIANGLE_STRIP, etc.
 * \param name  the transform feedback object
 * User still has to setup of the vertex attribute info with
 * glVertexPointer, glColorPointer, etc.
 * Part of GL_ARB_transform_feedback2.
d1191 2
a1192 46
static void GLAPIENTRY
vbo_exec_DrawTransformFeedback(GLenum mode, GLuint name)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_transform_feedback_object *obj =
      _mesa_lookup_transform_feedback_object(ctx, name);

   if (MESA_VERBOSE & VERBOSE_DRAW)
      _mesa_debug(ctx, "glDrawTransformFeedback(%s, %d)\n",
                  _mesa_lookup_enum_by_nr(mode), name);

   vbo_draw_transform_feedback(ctx, mode, obj, 0, 1);
}

static void GLAPIENTRY
vbo_exec_DrawTransformFeedbackStream(GLenum mode, GLuint name, GLuint stream)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_transform_feedback_object *obj =
      _mesa_lookup_transform_feedback_object(ctx, name);

   if (MESA_VERBOSE & VERBOSE_DRAW)
      _mesa_debug(ctx, "glDrawTransformFeedbackStream(%s, %u, %u)\n",
                  _mesa_lookup_enum_by_nr(mode), name, stream);

   vbo_draw_transform_feedback(ctx, mode, obj, stream, 1);
}

static void GLAPIENTRY
vbo_exec_DrawTransformFeedbackInstanced(GLenum mode, GLuint name,
                                        GLsizei primcount)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_transform_feedback_object *obj =
      _mesa_lookup_transform_feedback_object(ctx, name);

   if (MESA_VERBOSE & VERBOSE_DRAW)
      _mesa_debug(ctx, "glDrawTransformFeedbackInstanced(%s, %d)\n",
                  _mesa_lookup_enum_by_nr(mode), name);

   vbo_draw_transform_feedback(ctx, mode, obj, 0, primcount);
}

static void GLAPIENTRY
vbo_exec_DrawTransformFeedbackStreamInstanced(GLenum mode, GLuint name,
                                              GLuint stream, GLsizei primcount)
d1194 9
a1202 10
   GET_CURRENT_CONTEXT(ctx);
   struct gl_transform_feedback_object *obj =
      _mesa_lookup_transform_feedback_object(ctx, name);

   if (MESA_VERBOSE & VERBOSE_DRAW)
      _mesa_debug(ctx, "glDrawTransformFeedbackStreamInstanced"
                  "(%s, %u, %u, %i)\n",
                  _mesa_lookup_enum_by_nr(mode), name, stream, primcount);

   vbo_draw_transform_feedback(ctx, mode, obj, stream, primcount);
a1205 3
/**
 * Initialize the dispatch table with the VBO functions for drawing.
 */
d1207 1
a1207 2
vbo_initialize_exec_dispatch(const struct gl_context *ctx,
                             struct _glapi_table *exec)
d1209 1
a1209 36
   SET_DrawArrays(exec, vbo_exec_DrawArrays);
   SET_DrawElements(exec, vbo_exec_DrawElements);

   if (_mesa_is_desktop_gl(ctx) || _mesa_is_gles3(ctx)) {
      SET_DrawRangeElements(exec, vbo_exec_DrawRangeElements);
   }

   SET_MultiDrawElementsEXT(exec, vbo_exec_MultiDrawElements);

   if (ctx->API == API_OPENGL_COMPAT) {
      SET_Rectf(exec, vbo_exec_Rectf);
      SET_EvalMesh1(exec, vbo_exec_EvalMesh1);
      SET_EvalMesh2(exec, vbo_exec_EvalMesh2);
   }

   if (_mesa_is_desktop_gl(ctx)) {
      SET_DrawElementsBaseVertex(exec, vbo_exec_DrawElementsBaseVertex);
      SET_DrawRangeElementsBaseVertex(exec, vbo_exec_DrawRangeElementsBaseVertex);
      SET_MultiDrawElementsBaseVertex(exec, vbo_exec_MultiDrawElementsBaseVertex);
      SET_DrawArraysInstancedBaseInstance(exec, vbo_exec_DrawArraysInstancedBaseInstance);
      SET_DrawElementsInstancedBaseInstance(exec, vbo_exec_DrawElementsInstancedBaseInstance);
      SET_DrawElementsInstancedBaseVertex(exec, vbo_exec_DrawElementsInstancedBaseVertex);
      SET_DrawElementsInstancedBaseVertexBaseInstance(exec, vbo_exec_DrawElementsInstancedBaseVertexBaseInstance);
   }

   if (_mesa_is_desktop_gl(ctx) || _mesa_is_gles3(ctx)) {
      SET_DrawArraysInstancedARB(exec, vbo_exec_DrawArraysInstanced);
      SET_DrawElementsInstancedARB(exec, vbo_exec_DrawElementsInstanced);
   }

   if (_mesa_is_desktop_gl(ctx)) {
      SET_DrawTransformFeedback(exec, vbo_exec_DrawTransformFeedback);
      SET_DrawTransformFeedbackStream(exec, vbo_exec_DrawTransformFeedbackStream);
      SET_DrawTransformFeedbackInstanced(exec, vbo_exec_DrawTransformFeedbackInstanced);
      SET_DrawTransformFeedbackStreamInstanced(exec, vbo_exec_DrawTransformFeedbackStreamInstanced);
   }
a1276 6
}

void GLAPIENTRY
_mesa_DrawTransformFeedback(GLenum mode, GLuint name)
{
   vbo_exec_DrawTransformFeedback(mode, name);
@


1.1.1.4
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2003 VMware, Inc.
d22 1
a22 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
d56 1
a56 1
         assert(!_mesa_check_disallowed_mapping(obj));
d76 1
a76 1
   assert(!_mesa_check_disallowed_mapping(exec->vtx.bufferobj));
d104 1
a104 2
                                           GL_MAP_READ_BIT, ib->obj,
                                           MAP_INTERNAL);
d180 1
a180 1
      ctx->Driver.UnmapBuffer(ctx, ib->obj, MAP_INTERNAL);
d232 1
a232 1
         if (!array->BufferObj->Mappings[MAP_INTERNAL].Pointer) {
d234 1
a234 1
            array->BufferObj->Mappings[MAP_INTERNAL].Pointer =
d236 1
a236 2
					  GL_MAP_READ_BIT, array->BufferObj,
                                          MAP_INTERNAL);
d238 1
a238 2
         data = ADD_POINTERS(data,
                             array->BufferObj->Mappings[MAP_INTERNAL].Pointer);
d276 2
a277 2
       _mesa_bufferobj_mapped(array->BufferObj, MAP_INTERNAL)) {
      ctx->Driver.UnmapBuffer(ctx, array->BufferObj, MAP_INTERNAL);
d290 1
a290 1
   struct gl_vertex_array_object *vao = ctx->Array.VAO;
d294 1
a294 1
   if (_mesa_is_bufferobj(ctx->Array.VAO->IndexBufferObj)) {
d296 1
a296 1
					   ctx->Array.VAO->IndexBufferObj->Size,
d298 1
a298 2
					   ctx->Array.VAO->IndexBufferObj,
                                           MAP_INTERNAL);
d321 2
a322 2
      for (k = 0; k < Elements(vao->_VertexAttrib); k++) {
         check_array_data(ctx, &vao->_VertexAttrib[k], k, j);
d326 2
a327 3
   if (_mesa_is_bufferobj(vao->IndexBufferObj)) {
      ctx->Driver.UnmapBuffer(ctx, ctx->Array.VAO->IndexBufferObj,
                              MAP_INTERNAL);
d330 2
a331 2
   for (k = 0; k < Elements(vao->_VertexAttrib); k++) {
      unmap_array_buffer(ctx, &vao->_VertexAttrib[k]);
d355 1
a355 1
   struct gl_vertex_array_object *vao = ctx->Array.VAO;
d371 1
a371 1
	     vao->_VertexAttrib[VERT_ATTRIB_FF(i)].Enabled,
d377 1
a377 2
						 GL_MAP_READ_BIT, bufObj,
                                                 MAP_INTERNAL);
d389 1
a389 1
         ctx->Driver.UnmapBuffer(ctx, bufObj, MAP_INTERNAL);
d408 1
a408 1
   struct gl_client_array *vertexAttrib = ctx->Array.VAO->_VertexAttrib;
d582 1
a582 1
      vbo_sw_primitive_restart(ctx, prim, nr_prims, ib, NULL);
d586 1
a586 1
                      index_bounds_valid, min_index, max_index, NULL, NULL);
a613 1
   prim[0].is_indirect = 0;
d651 1
a651 1
                         GL_TRUE, start, start + count - 1, NULL, NULL);
d662 1
a662 1
                      NULL, NULL);
d885 1
a885 1
				 ctx->Array.VAO->IndexBufferObj->Size,
d887 1
a887 2
                                 ctx->Array.VAO->IndexBufferObj,
                                 MAP_INTERNAL);
d893 1
a893 1
         for (i = 0; i < ctx->Array.VAO->IndexBufferObj->Size; i++) {
d905 1
a905 1
         for (i = 0; i < ctx->Array.VAO->IndexBufferObj->Size / 2; i++) {
d917 1
a917 1
         for (i = 0; i < ctx->Array.VAO->IndexBufferObj->Size / 4; i++) {
d929 1
a929 2
   ctx->Driver.UnmapBuffer(ctx, ctx->Array.VAO->IndexBufferObj,
                           MAP_INTERNAL);
d957 1
a957 1
   ib.obj = ctx->Array.VAO->IndexBufferObj;
a967 1
   prim[0].is_indirect = 0;
d1042 1
a1042 1
      max_element = ctx->Array.VAO->_MaxElement;
d1098 1
a1098 1
	     ctx->Array.VAO->IndexBufferObj->Name,
a1336 10
   /* Draw primitives individually if one count is zero, so we can easily skip
    * that primitive.
    */
   for (i = 0; i < primcount; i++) {
      if (count[i] == 0) {
         fallback = GL_TRUE;
         break;
      }
   }

d1341 1
a1341 1
   if (!_mesa_is_bufferobj(ctx->Array.VAO->IndexBufferObj))
d1347 1
a1347 1
      ib.obj = ctx->Array.VAO->IndexBufferObj;
a1360 1
         prim[i].is_indirect = 0;
a1372 2
	 if (count[i] == 0)
	    continue;
d1375 1
a1375 1
	 ib.obj = ctx->Array.VAO->IndexBufferObj;
a1387 1
         prim[0].is_indirect = 0;
a1454 10
   if (ctx->Driver.GetTransformFeedbackVertexCount &&
       (ctx->Const.AlwaysUseGetTransformFeedbackVertexCount ||
        (ctx->Const.PrimitiveRestartInSoftware &&
         ctx->Array._PrimitiveRestart) ||
        !vbo_all_varyings_in_vbos(exec->array.inputs))) {
      GLsizei n = ctx->Driver.GetTransformFeedbackVertexCount(ctx, obj, stream);
      vbo_draw_arrays(ctx, mode, 0, n, numInstances, 0);
      return;
   }

a1463 1
   prim[0].is_indirect = 0;
d1471 1
a1471 1
                   GL_TRUE, 0, 0, obj, NULL);
a1544 246
static void
vbo_validated_drawarraysindirect(struct gl_context *ctx,
                                 GLenum mode, const GLvoid *indirect)
{
   struct vbo_context *vbo = vbo_context(ctx);
   struct vbo_exec_context *exec = &vbo->exec;
   struct _mesa_prim prim[1];

   vbo_bind_arrays(ctx);

   memset(prim, 0, sizeof(prim));
   prim[0].begin = 1;
   prim[0].end = 1;
   prim[0].mode = mode;
   prim[0].is_indirect = 1;
   prim[0].indirect_offset = (GLsizeiptr)indirect;

   /* NOTE: We do NOT want to handle primitive restart here, nor perform any
    * other checks that require knowledge of the values in the command buffer.
    * That would defeat the whole purpose of this function.
    */

   check_buffers_are_unmapped(exec->array.inputs);
   vbo->draw_prims(ctx, prim, 1,
                   NULL, GL_TRUE, 0, ~0,
                   NULL,
                   ctx->DrawIndirectBuffer);

   if (MESA_DEBUG_FLAGS & DEBUG_ALWAYS_FLUSH)
      _mesa_flush(ctx);
}

static void
vbo_validated_multidrawarraysindirect(struct gl_context *ctx,
                                      GLenum mode,
                                      const GLvoid *indirect,
                                      GLsizei primcount, GLsizei stride)
{
   struct vbo_context *vbo = vbo_context(ctx);
   struct vbo_exec_context *exec = &vbo->exec;
   struct _mesa_prim *prim;
   GLsizei i;
   GLsizeiptr offset = (GLsizeiptr)indirect;

   if (primcount == 0)
      return;
   prim = calloc(primcount, sizeof(*prim));
   if (prim == NULL) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glMultiDrawArraysIndirect");
      return;
   }

   vbo_bind_arrays(ctx);

   prim[0].begin = 1;
   prim[primcount - 1].end = 1;
   for (i = 0; i < primcount; ++i, offset += stride) {
      prim[i].mode = mode;
      prim[i].indirect_offset = offset;
      prim[i].is_indirect = 1;
   }

   check_buffers_are_unmapped(exec->array.inputs);
   vbo->draw_prims(ctx, prim, primcount,
                   NULL, GL_TRUE, 0, ~0,
                   NULL,
                   ctx->DrawIndirectBuffer);

   free(prim);

   if (MESA_DEBUG_FLAGS & DEBUG_ALWAYS_FLUSH)
      _mesa_flush(ctx);
}

static void
vbo_validated_drawelementsindirect(struct gl_context *ctx,
                                   GLenum mode, GLenum type,
                                   const GLvoid *indirect)
{
   struct vbo_context *vbo = vbo_context(ctx);
   struct vbo_exec_context *exec = &vbo->exec;
   struct _mesa_index_buffer ib;
   struct _mesa_prim prim[1];

   vbo_bind_arrays(ctx);

   ib.count = 0; /* unknown */
   ib.type = type;
   ib.obj = ctx->Array.VAO->IndexBufferObj;
   ib.ptr = NULL;

   memset(prim, 0, sizeof(prim));
   prim[0].begin = 1;
   prim[0].end = 1;
   prim[0].mode = mode;
   prim[0].indexed = 1;
   prim[0].indirect_offset = (GLsizeiptr)indirect;
   prim[0].is_indirect = 1;

   check_buffers_are_unmapped(exec->array.inputs);
   vbo->draw_prims(ctx, prim, 1,
                   &ib, GL_TRUE, 0, ~0,
                   NULL,
                   ctx->DrawIndirectBuffer);

   if (MESA_DEBUG_FLAGS & DEBUG_ALWAYS_FLUSH)
      _mesa_flush(ctx);
}

static void
vbo_validated_multidrawelementsindirect(struct gl_context *ctx,
                                        GLenum mode, GLenum type,
                                        const GLvoid *indirect,
                                        GLsizei primcount, GLsizei stride)
{
   struct vbo_context *vbo = vbo_context(ctx);
   struct vbo_exec_context *exec = &vbo->exec;
   struct _mesa_index_buffer ib;
   struct _mesa_prim *prim;
   GLsizei i;
   GLsizeiptr offset = (GLsizeiptr)indirect;

   if (primcount == 0)
      return;
   prim = calloc(primcount, sizeof(*prim));
   if (prim == NULL) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glMultiDrawElementsIndirect");
      return;
   }

   vbo_bind_arrays(ctx);

   /* NOTE: IndexBufferObj is guaranteed to be a VBO. */

   ib.count = 0; /* unknown */
   ib.type = type;
   ib.obj = ctx->Array.VAO->IndexBufferObj;
   ib.ptr = NULL;

   prim[0].begin = 1;
   prim[primcount - 1].end = 1;
   for (i = 0; i < primcount; ++i, offset += stride) {
      prim[i].mode = mode;
      prim[i].indexed = 1;
      prim[i].indirect_offset = offset;
      prim[i].is_indirect = 1;
   }

   check_buffers_are_unmapped(exec->array.inputs);
   vbo->draw_prims(ctx, prim, primcount,
                   &ib, GL_TRUE, 0, ~0,
                   NULL,
                   ctx->DrawIndirectBuffer);

   free(prim);

   if (MESA_DEBUG_FLAGS & DEBUG_ALWAYS_FLUSH)
      _mesa_flush(ctx);
}

/**
 * Like [Multi]DrawArrays/Elements, but they take most arguments from
 * a buffer object.
 */
static void GLAPIENTRY
vbo_exec_DrawArraysIndirect(GLenum mode, const GLvoid *indirect)
{
   GET_CURRENT_CONTEXT(ctx);

   if (MESA_VERBOSE & VERBOSE_DRAW)
      _mesa_debug(ctx, "glDrawArraysIndirect(%s, %p)\n",
                  _mesa_lookup_enum_by_nr(mode), indirect);

   if (!_mesa_validate_DrawArraysIndirect(ctx, mode, indirect))
      return;

   vbo_validated_drawarraysindirect(ctx, mode, indirect);
}

static void GLAPIENTRY
vbo_exec_DrawElementsIndirect(GLenum mode, GLenum type,
                              const GLvoid *indirect)
{
   GET_CURRENT_CONTEXT(ctx);

   if (MESA_VERBOSE & VERBOSE_DRAW)
      _mesa_debug(ctx, "glDrawElementsIndirect(%s, %s, %p)\n",
                  _mesa_lookup_enum_by_nr(mode),
                  _mesa_lookup_enum_by_nr(type), indirect);

   if (!_mesa_validate_DrawElementsIndirect(ctx, mode, type, indirect))
      return;

   vbo_validated_drawelementsindirect(ctx, mode, type, indirect);
}

static void GLAPIENTRY
vbo_exec_MultiDrawArraysIndirect(GLenum mode,
                                 const GLvoid *indirect,
                                 GLsizei primcount, GLsizei stride)
{
   GET_CURRENT_CONTEXT(ctx);

   if (MESA_VERBOSE & VERBOSE_DRAW)
      _mesa_debug(ctx, "glMultiDrawArraysIndirect(%s, %p, %i, %i)\n",
                  _mesa_lookup_enum_by_nr(mode), indirect, primcount, stride);

   /* If <stride> is zero, the array elements are treated as tightly packed. */
   if (stride == 0)
      stride = 4 * sizeof(GLuint); /* sizeof(DrawArraysIndirectCommand) */

   if (!_mesa_validate_MultiDrawArraysIndirect(ctx, mode,
                                               indirect,
                                               primcount, stride))
      return;

   vbo_validated_multidrawarraysindirect(ctx, mode,
                                         indirect,
                                         primcount, stride);
}

static void GLAPIENTRY
vbo_exec_MultiDrawElementsIndirect(GLenum mode, GLenum type,
                                   const GLvoid *indirect,
                                   GLsizei primcount, GLsizei stride)
{
   GET_CURRENT_CONTEXT(ctx);

   if (MESA_VERBOSE & VERBOSE_DRAW)
      _mesa_debug(ctx, "glMultiDrawElementsIndirect(%s, %s, %p, %i, %i)\n",
                  _mesa_lookup_enum_by_nr(mode),
                  _mesa_lookup_enum_by_nr(type), indirect, primcount, stride);

   /* If <stride> is zero, the array elements are treated as tightly packed. */
   if (stride == 0)
      stride = 5 * sizeof(GLuint); /* sizeof(DrawElementsIndirectCommand) */

   if (!_mesa_validate_MultiDrawElementsIndirect(ctx, mode, type,
                                                 indirect,
                                                 primcount, stride))
      return;

   vbo_validated_multidrawelementsindirect(ctx, mode, type,
                                           indirect,
                                           primcount, stride);
}
a1575 7
   }

   if (ctx->API == API_OPENGL_CORE) {
      SET_DrawArraysIndirect(exec, vbo_exec_DrawArraysIndirect);
      SET_DrawElementsIndirect(exec, vbo_exec_DrawElementsIndirect);
      SET_MultiDrawArraysIndirect(exec, vbo_exec_MultiDrawArraysIndirect);
      SET_MultiDrawElementsIndirect(exec, vbo_exec_MultiDrawElementsIndirect);
@


1.1.1.5
log
@Import Mesa 10.4.3
@
text
@a38 2
#include "main/sse_minmax.h"
#include "x86/common_x86_asm.h"
d122 3
a124 3
#if defined(USE_SSE41)
         if (cpu_has_sse4_1) {
            _mesa_uint_array_min_max(ui_indices, &min_ui, &max_ui, count);
a125 6
         else
#endif
            for (i = 0; i < count; i++) {
               if (ui_indices[i] > max_ui) max_ui = ui_indices[i];
               if (ui_indices[i] < min_ui) min_ui = ui_indices[i];
            }
d565 32
d623 1
a623 2
   if (ctx->Array.PrimitiveRestart && !ctx->Array.PrimitiveRestartFixedIndex &&
       ctx->Array.RestartIndex < count) {
d1014 2
a1015 2
   vbo->draw_prims(ctx, prim, 1, &ib,
                   index_bounds_valid, start, end, NULL, NULL);
d1035 1
a1035 6

   /* This is only useful to catch invalid values in the "end" parameter
    * like ~0.
    */
   GLuint max_element = 2 * 1000 * 1000 * 1000; /* just a big number */

d1048 19
d1316 1
a1316 1
   prim = calloc(primcount, sizeof(*prim));
d1389 2
a1390 2
      vbo->draw_prims(ctx, prim, primcount, &ib,
                      false, ~0, ~0, NULL, NULL);
d1418 2
a1419 2
         vbo->draw_prims(ctx, prim, 1, &ib,
                         false, ~0, ~0, NULL, NULL);
d1481 2
a1892 6
void GLAPIENTRY
_mesa_DrawArraysInstanced(GLenum mode, GLint first, GLsizei count,
                          GLsizei primcount)
{
   vbo_exec_DrawArraysInstanced(mode, first, count, primcount);
}
@


1.1.1.6
log
@Import Mesa 10.2.9
@
text
@d39 2
d124 3
a126 3
         for (i = 0; i < count; i++) {
            if (ui_indices[i] > max_ui) max_ui = ui_indices[i];
            if (ui_indices[i] < min_ui) min_ui = ui_indices[i];
d128 6
a572 32

/**
 * Handle a draw case that potentially has primitive restart enabled.
 *
 * If primitive restart is enabled, and PrimitiveRestartInSoftware is
 * set, then vbo_sw_primitive_restart is used to handle the primitive
 * restart case in software.
 */
static void
vbo_handle_primitive_restart(struct gl_context *ctx,
                             const struct _mesa_prim *prim,
                             GLuint nr_prims,
                             const struct _mesa_index_buffer *ib,
                             GLboolean index_bounds_valid,
                             GLuint min_index,
                             GLuint max_index)
{
   struct vbo_context *vbo = vbo_context(ctx);

   if ((ib != NULL) &&
       ctx->Const.PrimitiveRestartInSoftware &&
       ctx->Array._PrimitiveRestart) {
      /* Handle primitive restart in software */
      vbo_sw_primitive_restart(ctx, prim, nr_prims, ib, NULL);
   } else {
      /* Call driver directly for draw_prims */
      vbo->draw_prims(ctx, prim, nr_prims, ib,
                      index_bounds_valid, min_index, max_index, NULL, NULL);
   }
}


d599 2
a600 1
   if (ctx->Array.PrimitiveRestart && ctx->Array.RestartIndex < count) {
d991 2
a992 2
   vbo_handle_primitive_restart(ctx, prim, 1, &ib,
                                index_bounds_valid, start, end);
d1012 6
a1017 1
   GLuint max_element;
a1029 19
   if (ctx->Const.CheckArrayBounds) {
      /* _MaxElement was computed, so we can use it.
       * This path is used for drivers which need strict bounds checking.
       */
      max_element = ctx->Array.VAO->_MaxElement;
   }
   else {
      /* Generally, hardware drivers don't need to know the buffer bounds
       * if all vertex attributes are in VBOs.
       * However, if none of vertex attributes are in VBOs, _MaxElement
       * is always set to some random big number anyway, so bounds checking
       * is mostly useless.
       *
       * This is only useful to catch invalid values in the "end" parameter
       * like ~0.
       */
      max_element = 2 * 1000 * 1000 * 1000; /* just a big number */
   }

d1279 1
a1279 1
   prim = calloc(1, primcount * sizeof(*prim));
d1352 2
a1353 2
      vbo_handle_primitive_restart(ctx, prim, primcount, &ib,
                                   GL_FALSE, ~0, ~0);
d1381 2
a1382 2
         vbo_handle_primitive_restart(ctx, prim, 1, &ib,
                                      GL_FALSE, ~0, ~0);
a1443 2
        (ctx->Const.PrimitiveRestartInSoftware &&
         ctx->Array._PrimitiveRestart) ||
d1854 6
@


