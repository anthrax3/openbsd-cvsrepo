head	1.11;
access;
symbols
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	v10_2_9:1.1.1.6
	v10_4_3:1.1.1.5
	v10_2_7:1.1.1.4
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	v10_2_3:1.1.1.4
	OPENBSD_5_5:1.7.0.2
	OPENBSD_5_5_BASE:1.7
	v9_2_5:1.1.1.3
	v9_2_3:1.1.1.3
	v9_2_2:1.1.1.3
	v9_2_1:1.1.1.3
	v9_2_0:1.1.1.3
	OPENBSD_5_4:1.6.0.4
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	v7_10_3:1.1.1.2
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.6
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.4
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.4
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_3:1.2.0.2
	v7_0_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2015.12.23.05.17.55;	author jsg;	state dead;
branches;
next	1.10;
commitid	TnlogFl9nOv2eaRf;

1.10
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.9;
commitid	4ry2gvZGMXkCUD2n;

1.9
date	2015.01.25.14.41.22;	author jsg;	state Exp;
branches;
next	1.8;
commitid	mcxB0JvoI9gTDYXU;

1.8
date	2014.07.09.21.09.01;	author jsg;	state Exp;
branches;
next	1.7;
commitid	WPD6rgPryPkvXOr9;

1.7
date	2013.09.05.14.06.59;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2012.08.17.13.58.21;	author mpi;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.23.13.37.46;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.37;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.14.58.23;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.02.12.21.09.27;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.24.17.32.24;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.11.24.17.32.24;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2011.10.23.13.29.50;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2013.09.05.13.17.47;	author jsg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.07.09.20.35.14;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.5
date	2015.01.25.14.13.40;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.6
date	2015.02.20.22.50.44;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.11
log
@remove the now unused Mesa 10.2.9 code
@
text
@
/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Authors:
 *    Keith Whitwell <keithw@@vmware.com>
 */

/* Split indexed primitives with per-vertex copying.
 */

#include "main/glheader.h"
#include "main/bufferobj.h"
#include "main/imports.h"
#include "main/glformats.h"
#include "main/macros.h"
#include "main/mtypes.h"

#include "vbo_split.h"
#include "vbo.h"


#define ELT_TABLE_SIZE 16

/**
 * Used for vertex-level splitting of indexed buffers.  Note that
 * non-indexed primitives may be converted to indexed in some cases
 * (eg loops, fans) in order to use this splitting path.
 */
struct copy_context {

   struct gl_context *ctx;
   const struct gl_client_array **array;
   const struct _mesa_prim *prim;
   GLuint nr_prims;
   const struct _mesa_index_buffer *ib;
   vbo_draw_func draw;

   const struct split_limits *limits;

   struct {
      GLuint attr;
      GLuint size;
      const struct gl_client_array *array;
      const GLubyte *src_ptr;

      struct gl_client_array dstarray;

   } varying[VERT_ATTRIB_MAX];
   GLuint nr_varying;

   const struct gl_client_array *dstarray_ptr[VERT_ATTRIB_MAX];
   struct _mesa_index_buffer dstib;

   GLuint *translated_elt_buf;
   const GLuint *srcelt;

   /** A baby hash table to avoid re-emitting (some) duplicate
    * vertices when splitting indexed primitives.
    */
   struct { 
      GLuint in;
      GLuint out;
   } vert_cache[ELT_TABLE_SIZE];

   GLuint vertex_size;
   GLubyte *dstbuf;
   GLubyte *dstptr;     /**< dstptr == dstbuf + dstelt_max * vertsize */
   GLuint dstbuf_size;  /**< in vertices */
   GLuint dstbuf_nr;    /**< count of emitted vertices, also the largest value
                         * in dstelt.  Our MaxIndex.
                         */

   GLuint *dstelt;
   GLuint dstelt_nr;
   GLuint dstelt_size;

#define MAX_PRIM 32
   struct _mesa_prim dstprim[MAX_PRIM];
   GLuint dstprim_nr;

};


static GLuint attr_size( const struct gl_client_array *array )
{
   return array->Size * _mesa_sizeof_type(array->Type);
}


/**
 * Starts returning true slightly before the buffer fills, to ensure
 * that there is sufficient room for any remaining vertices to finish
 * off the prim:
 */
static GLboolean
check_flush( struct copy_context *copy )
{
   GLenum mode = copy->dstprim[copy->dstprim_nr].mode; 

   if (GL_TRIANGLE_STRIP == mode &&
       copy->dstelt_nr & 1) { /* see bug9962 */
       return GL_FALSE;
   }

   if (copy->dstbuf_nr + 4 > copy->dstbuf_size)
      return GL_TRUE;

   if (copy->dstelt_nr + 4 > copy->dstelt_size)
      return GL_TRUE;

   return GL_FALSE;
}


/**
 * Dump the parameters/info for a vbo->draw() call.
 */
static void
dump_draw_info(struct gl_context *ctx,
               const struct gl_client_array **arrays,
               const struct _mesa_prim *prims,
               GLuint nr_prims,
               const struct _mesa_index_buffer *ib,
               GLuint min_index,
               GLuint max_index)
{
   GLuint i, j;

   printf("VBO Draw:\n");
   for (i = 0; i < nr_prims; i++) {
      printf("Prim %u of %u\n", i, nr_prims);
      printf("  Prim mode 0x%x\n", prims[i].mode);
      printf("  IB: %p\n", (void*) ib);
      for (j = 0; j < VERT_ATTRIB_MAX; j++) {
         printf("    array %d at %p:\n", j, (void*) arrays[j]);
         printf("      enabled %d, ptr %p, size %d, type 0x%x, stride %d\n",
		arrays[j]->Enabled, arrays[j]->Ptr,
		arrays[j]->Size, arrays[j]->Type, arrays[j]->StrideB);
         if (0) {
            GLint k = prims[i].start + prims[i].count - 1;
            GLfloat *last = (GLfloat *) (arrays[j]->Ptr + arrays[j]->Stride * k);
            printf("        last: %f %f %f\n",
		   last[0], last[1], last[2]);
         }
      }
   }
}


static void
flush( struct copy_context *copy )
{
   struct gl_context *ctx = copy->ctx;
   const struct gl_client_array **saved_arrays = ctx->Array._DrawArrays;
   GLuint i;

   /* Set some counters: 
    */
   copy->dstib.count = copy->dstelt_nr;

#if 0
   dump_draw_info(copy->ctx,
                  copy->dstarray_ptr,
                  copy->dstprim,
                  copy->dstprim_nr,
                  &copy->dstib,
                  0,
                  copy->dstbuf_nr);
#else
   (void) dump_draw_info;
#endif

   ctx->Array._DrawArrays = copy->dstarray_ptr;
   ctx->NewDriverState |= ctx->DriverFlags.NewArray;

   copy->draw( ctx,
	       copy->dstprim,
	       copy->dstprim_nr,
	       &copy->dstib,
	       GL_TRUE,
	       0,
	       copy->dstbuf_nr - 1,
	       NULL, NULL );

   ctx->Array._DrawArrays = saved_arrays;
   ctx->NewDriverState |= ctx->DriverFlags.NewArray;

   /* Reset all pointers: 
    */
   copy->dstprim_nr = 0;
   copy->dstelt_nr = 0;
   copy->dstbuf_nr = 0;
   copy->dstptr = copy->dstbuf;

   /* Clear the vertex cache:
    */
   for (i = 0; i < ELT_TABLE_SIZE; i++)
      copy->vert_cache[i].in = ~0;
}


/**
 * Called at begin of each primitive during replay.
 */
static void
begin( struct copy_context *copy, GLenum mode, GLboolean begin_flag )
{
   struct _mesa_prim *prim = &copy->dstprim[copy->dstprim_nr];

   prim->mode = mode;
   prim->begin = begin_flag;
   prim->num_instances = 1;
}


/**
 * Use a hashtable to attempt to identify recently-emitted vertices
 * and avoid re-emitting them.
 */
static GLuint
elt(struct copy_context *copy, GLuint elt_idx)
{
   GLuint elt = copy->srcelt[elt_idx];
   GLuint slot = elt & (ELT_TABLE_SIZE-1);

/*    printf("elt %d\n", elt); */

   /* Look up the incoming element in the vertex cache.  Re-emit if
    * necessary.   
    */
   if (copy->vert_cache[slot].in != elt) {
      GLubyte *csr = copy->dstptr;
      GLuint i;

/*       printf("  --> emit to dstelt %d\n", copy->dstbuf_nr); */

      for (i = 0; i < copy->nr_varying; i++) {
	 const struct gl_client_array *srcarray = copy->varying[i].array;
	 const GLubyte *srcptr = copy->varying[i].src_ptr + elt * srcarray->StrideB;

	 memcpy(csr, srcptr, copy->varying[i].size);
	 csr += copy->varying[i].size;

#ifdef NAN_CHECK
         if (srcarray->Type == GL_FLOAT) {
            GLuint k;
            GLfloat *f = (GLfloat *) srcptr;
            for (k = 0; k < srcarray->Size; k++) {
               assert(!IS_INF_OR_NAN(f[k]));
               assert(f[k] <= 1.0e20 && f[k] >= -1.0e20);
            }
         }
#endif

	 if (0) 
	 {
	    const GLuint *f = (const GLuint *)srcptr;
	    GLuint j;
	    printf("  varying %d: ", i);
	    for(j = 0; j < copy->varying[i].size / 4; j++)
	       printf("%x ", f[j]);
	    printf("\n");
	 }
      }

      copy->vert_cache[slot].in = elt;
      copy->vert_cache[slot].out = copy->dstbuf_nr++;
      copy->dstptr += copy->vertex_size;

      assert(csr == copy->dstptr);
      assert(copy->dstptr == (copy->dstbuf +
                              copy->dstbuf_nr * copy->vertex_size));
   }
/*    else */
/*       printf("  --> reuse vertex\n"); */
   
/*    printf("  --> emit %d\n", copy->vert_cache[slot].out); */
   copy->dstelt[copy->dstelt_nr++] = copy->vert_cache[slot].out;
   return check_flush(copy);
}


/**
 * Called at end of each primitive during replay.
 */
static void
end( struct copy_context *copy, GLboolean end_flag )
{
   struct _mesa_prim *prim = &copy->dstprim[copy->dstprim_nr];

/*    printf("end (%d)\n", end_flag); */

   prim->end = end_flag;
   prim->count = copy->dstelt_nr - prim->start;

   if (++copy->dstprim_nr == MAX_PRIM ||
       check_flush(copy)) 
      flush(copy);
}


static void
replay_elts( struct copy_context *copy )
{
   GLuint i, j, k;
   GLboolean split;

   for (i = 0; i < copy->nr_prims; i++) {
      const struct _mesa_prim *prim = &copy->prim[i];
      const GLuint start = prim->start;
      GLuint first, incr;

      switch (prim->mode) {
	 
      case GL_LINE_LOOP:
	 /* Convert to linestrip and emit the final vertex explicitly,
	  * but only in the resultant strip that requires it.
	  */
	 j = 0;
	 while (j != prim->count) {
	    begin(copy, GL_LINE_STRIP, prim->begin && j == 0);

	    for (split = GL_FALSE; j != prim->count && !split; j++)
	       split = elt(copy, start + j);

	    if (j == prim->count) {
	       /* Done, emit final line.  Split doesn't matter as
		* it is always raised a bit early so we can emit
		* the last verts if necessary!
		*/
	       if (prim->end) 
		  (void)elt(copy, start + 0);

	       end(copy, prim->end);
	    }
	    else {
	       /* Wrap
		*/
	       assert(split);
	       end(copy, 0);
	       j--;
	    }
	 }
	 break;

      case GL_TRIANGLE_FAN:
      case GL_POLYGON:
	 j = 2;
	 while (j != prim->count) {
	    begin(copy, prim->mode, prim->begin && j == 0);

	    split = elt(copy, start+0); 
	    assert(!split);

	    split = elt(copy, start+j-1); 
	    assert(!split);

	    for (; j != prim->count && !split; j++)
	       split = elt(copy, start+j);

	    end(copy, prim->end && j == prim->count);

	    if (j != prim->count) {
	       /* Wrapped the primitive, need to repeat some vertices:
		*/
	       j -= 1;
	    }
	 }
	 break;

      default:
	 (void)split_prim_inplace(prim->mode, &first, &incr);
	 
	 j = 0;
	 while (j != prim->count) {

	    begin(copy, prim->mode, prim->begin && j == 0);

	    split = 0;
	    for (k = 0; k < first; k++, j++)
	       split |= elt(copy, start+j);

	    assert(!split);

	    for (; j != prim->count && !split; )
	       for (k = 0; k < incr; k++, j++)
		  split |= elt(copy, start+j);

	    end(copy, prim->end && j == prim->count);

	    if (j != prim->count) {
	       /* Wrapped the primitive, need to repeat some vertices:
		*/
	       assert(j > first - incr);
	       j -= (first - incr);
	    }
	 }
	 break;
      }
   }

   if (copy->dstprim_nr)
      flush(copy);
}


static void
replay_init( struct copy_context *copy )
{
   struct gl_context *ctx = copy->ctx;
   GLuint i;
   GLuint offset;
   const GLvoid *srcptr;

   /* Make a list of varying attributes and their vbo's.  Also
    * calculate vertex size.
    */
   copy->vertex_size = 0;
   for (i = 0; i < VERT_ATTRIB_MAX; i++) {
      struct gl_buffer_object *vbo = copy->array[i]->BufferObj;

      if (copy->array[i]->StrideB == 0) {
	 copy->dstarray_ptr[i] = copy->array[i];
      }
      else {
	 GLuint j = copy->nr_varying++;
	 
	 copy->varying[j].attr = i;
	 copy->varying[j].array = copy->array[i];
	 copy->varying[j].size = attr_size(copy->array[i]);
	 copy->vertex_size += attr_size(copy->array[i]);
      
	 if (_mesa_is_bufferobj(vbo) &&
             !_mesa_bufferobj_mapped(vbo, MAP_INTERNAL))
	    ctx->Driver.MapBufferRange(ctx, 0, vbo->Size, GL_MAP_READ_BIT, vbo,
                                       MAP_INTERNAL);

	 copy->varying[j].src_ptr =
               ADD_POINTERS(vbo->Mappings[MAP_INTERNAL].Pointer,
                            copy->array[i]->Ptr);

	 copy->dstarray_ptr[i] = &copy->varying[j].dstarray;
      }
   }

   /* There must always be an index buffer.  Currently require the
    * caller convert non-indexed prims to indexed.  Could alternately
    * do it internally.
    */
   if (_mesa_is_bufferobj(copy->ib->obj) &&
       !_mesa_bufferobj_mapped(copy->ib->obj, MAP_INTERNAL))
      ctx->Driver.MapBufferRange(ctx, 0, copy->ib->obj->Size, GL_MAP_READ_BIT,
				 copy->ib->obj, MAP_INTERNAL);

   srcptr = (const GLubyte *)
            ADD_POINTERS(copy->ib->obj->Mappings[MAP_INTERNAL].Pointer,
                         copy->ib->ptr);

   switch (copy->ib->type) {
   case GL_UNSIGNED_BYTE:
      copy->translated_elt_buf = malloc(sizeof(GLuint) * copy->ib->count);
      copy->srcelt = copy->translated_elt_buf;

      for (i = 0; i < copy->ib->count; i++)
	 copy->translated_elt_buf[i] = ((const GLubyte *)srcptr)[i];
      break;

   case GL_UNSIGNED_SHORT:
      copy->translated_elt_buf = malloc(sizeof(GLuint) * copy->ib->count);
      copy->srcelt = copy->translated_elt_buf;

      for (i = 0; i < copy->ib->count; i++)
	 copy->translated_elt_buf[i] = ((const GLushort *)srcptr)[i];
      break;

   case GL_UNSIGNED_INT:
      copy->translated_elt_buf = NULL;
      copy->srcelt = (const GLuint *)srcptr;
      break;
   }

   /* Figure out the maximum allowed vertex buffer size:
    */
   if (copy->vertex_size * copy->limits->max_verts <= copy->limits->max_vb_size) {
      copy->dstbuf_size = copy->limits->max_verts;
   }
   else {
      copy->dstbuf_size = copy->limits->max_vb_size / copy->vertex_size;
   }

   /* Allocate an output vertex buffer:
    *
    * XXX:  This should be a VBO!
    */
   copy->dstbuf = malloc(copy->dstbuf_size * copy->vertex_size);   
   copy->dstptr = copy->dstbuf;

   /* Setup new vertex arrays to point into the output buffer: 
    */
   for (offset = 0, i = 0; i < copy->nr_varying; i++) {
      const struct gl_client_array *src = copy->varying[i].array;
      struct gl_client_array *dst = &copy->varying[i].dstarray;

      dst->Size = src->Size;
      dst->Type = src->Type;
      dst->Format = GL_RGBA;
      dst->Stride = copy->vertex_size;
      dst->StrideB = copy->vertex_size;
      dst->Ptr = copy->dstbuf + offset;
      dst->Enabled = GL_TRUE;
      dst->Normalized = src->Normalized; 
      dst->Integer = src->Integer;
      dst->BufferObj = ctx->Shared->NullBufferObj;
      dst->_ElementSize = src->_ElementSize;
      dst->_MaxElement = copy->dstbuf_size; /* may be less! */

      offset += copy->varying[i].size;
   }

   /* Allocate an output element list:
    */
   copy->dstelt_size = MIN2(65536,
			    copy->ib->count * 2 + 3);
   copy->dstelt_size = MIN2(copy->dstelt_size,
			    copy->limits->max_indices);
   copy->dstelt = malloc(sizeof(GLuint) * copy->dstelt_size);
   copy->dstelt_nr = 0;

   /* Setup the new index buffer to point to the allocated element
    * list:
    */
   copy->dstib.count = 0;	/* duplicates dstelt_nr */
   copy->dstib.type = GL_UNSIGNED_INT;
   copy->dstib.obj = ctx->Shared->NullBufferObj;
   copy->dstib.ptr = copy->dstelt;
}


/**
 * Free up everything allocated during split/replay.
 */
static void
replay_finish( struct copy_context *copy )
{
   struct gl_context *ctx = copy->ctx;
   GLuint i;

   /* Free our vertex and index buffers: 
    */
   free(copy->translated_elt_buf);
   free(copy->dstbuf);
   free(copy->dstelt);

   /* Unmap VBO's 
    */
   for (i = 0; i < copy->nr_varying; i++) {
      struct gl_buffer_object *vbo = copy->varying[i].array->BufferObj;
      if (_mesa_is_bufferobj(vbo) && _mesa_bufferobj_mapped(vbo, MAP_INTERNAL))
	 ctx->Driver.UnmapBuffer(ctx, vbo, MAP_INTERNAL);
   }

   /* Unmap index buffer:
    */
   if (_mesa_is_bufferobj(copy->ib->obj) &&
       _mesa_bufferobj_mapped(copy->ib->obj, MAP_INTERNAL)) {
      ctx->Driver.UnmapBuffer(ctx, copy->ib->obj, MAP_INTERNAL);
   }
}


/**
 * Split VBO into smaller pieces, draw the pieces.
 */
void vbo_split_copy( struct gl_context *ctx,
		     const struct gl_client_array *arrays[],
		     const struct _mesa_prim *prim,
		     GLuint nr_prims,
		     const struct _mesa_index_buffer *ib,
		     vbo_draw_func draw,
		     const struct split_limits *limits )
{
   struct copy_context copy;
   GLuint i, this_nr_prims;

   for (i = 0; i < nr_prims;) {
      /* Our SW TNL pipeline doesn't handle basevertex yet, so bind_indices
       * will rebase the elements to the basevertex, and we'll only
       * emit strings of prims with the same basevertex in one draw call.
       */
      for (this_nr_prims = 1; i + this_nr_prims < nr_prims;
	   this_nr_prims++) {
	 if (prim[i].basevertex != prim[i + this_nr_prims].basevertex)
	    break;
      }

      memset(&copy, 0, sizeof(copy));

      /* Require indexed primitives:
       */
      assert(ib);

      copy.ctx = ctx;
      copy.array = arrays;
      copy.prim = &prim[i];
      copy.nr_prims = this_nr_prims;
      copy.ib = ib;
      copy.draw = draw;
      copy.limits = limits;

      /* Clear the vertex cache:
       */
      for (i = 0; i < ELT_TABLE_SIZE; i++)
	 copy.vert_cache[i].in = ~0;

      replay_init(&copy);
      replay_elts(&copy);
      replay_finish(&copy);
   }
}
@


1.10
log
@Merge Mesa 10.2.9
@
text
@@


1.9
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d536 1
@


1.8
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@a535 1
      dst->_MaxElement = copy->dstbuf_size; /* may be less! */
@


1.7
log
@Merge Mesa 9.2.0
@
text
@d26 1
a26 1
 *    Keith Whitwell <keith@@tungstengraphics.com>
d204 1
a204 1
	       NULL );
d454 8
a461 5
	 if (_mesa_is_bufferobj(vbo) && !_mesa_bufferobj_mapped(vbo)) 
	    ctx->Driver.MapBufferRange(ctx, 0, vbo->Size, GL_MAP_READ_BIT, vbo);

	 copy->varying[j].src_ptr = ADD_POINTERS(vbo->Pointer,
						 copy->array[i]->Ptr);
d472 1
a472 1
       !_mesa_bufferobj_mapped(copy->ib->obj)) 
d474 1
a474 1
				 copy->ib->obj);
d476 3
a478 2
   srcptr = (const GLubyte *) ADD_POINTERS(copy->ib->obj->Pointer,
                                           copy->ib->ptr);
d579 2
a580 2
      if (_mesa_is_bufferobj(vbo) && _mesa_bufferobj_mapped(vbo)) 
	 ctx->Driver.UnmapBuffer(ctx, vbo);
d586 2
a587 2
       _mesa_bufferobj_mapped(copy->ib->obj)) {
      ctx->Driver.UnmapBuffer(ctx, copy->ib->obj);
@


1.6
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a3 1
 * Version:  6.5
d20 4
a23 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
d35 1
a35 1
#include "main/image.h"
d174 2
d194 4
a197 2
   copy->draw( copy->ctx,
	       copy->dstarray_ptr,
d203 5
a207 1
	       copy->dstbuf_nr - 1 );
d455 1
a455 1
	    ctx->Driver.MapBuffer(ctx, GL_ARRAY_BUFFER, GL_READ_ONLY, vbo);
d470 2
a471 2
      ctx->Driver.MapBuffer(ctx, GL_ELEMENT_ARRAY_BUFFER, GL_READ_ONLY,
			    copy->ib->obj);
d529 1
d576 1
a576 1
	 ctx->Driver.UnmapBuffer(ctx, GL_ARRAY_BUFFER, vbo);
d583 1
a583 1
      ctx->Driver.UnmapBuffer(ctx, GL_ELEMENT_ARRAY_BUFFER, copy->ib->obj);
@


1.5
log
@Merge Mesa 7.10.3
@
text
@d225 1
d522 1
@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d52 1
a52 1
   GLcontext *ctx;
d140 1
a140 1
dump_draw_info(GLcontext *ctx,
d422 1
a422 1
   GLcontext *ctx = copy->ctx;
d551 1
a551 1
   GLcontext *ctx = copy->ctx;
d580 1
a580 1
void vbo_split_copy( GLcontext *ctx,
@


1.3
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d33 1
d35 1
a36 1
#include "main/enums.h"
d45 2
a46 1
/* Used for vertex-level splitting of indexed buffers.  Note that
d78 1
a78 1
   /* A baby hash table to avoid re-emitting (some) duplicate
a84 1
      
d88 5
a92 6
   GLubyte *dstptr;		/* dstptr == dstbuf + dstelt_max * vertsize */
   GLuint dstbuf_size;	/* in vertices */
   GLuint dstbuf_nr;		/* count of emitted vertices, also the
				 * largest value in dstelt.  Our
				 * MaxIndex.
				 */
a104 15
static GLuint type_size( GLenum type )
{
   switch(type) {
   case GL_BYTE: return sizeof(GLbyte);
   case GL_UNSIGNED_BYTE: return sizeof(GLubyte);
   case GL_SHORT: return sizeof(GLshort);
   case GL_UNSIGNED_SHORT: return sizeof(GLushort);
   case GL_INT: return sizeof(GLint);
   case GL_UNSIGNED_INT: return sizeof(GLuint);
   case GL_FLOAT: return sizeof(GLfloat);
   case GL_DOUBLE: return sizeof(GLdouble);
   default: return 0;
   }
}

d107 1
a107 1
   return array->Size * type_size(array->Type);
d111 2
a112 1
/* Starts returning true slightly before the buffer fills, to ensure
d116 2
a117 1
static GLboolean check_flush( struct copy_context *copy )
d135 38
a172 1
static void flush( struct copy_context *copy )
d180 12
d197 1
d199 1
a199 1
	       copy->dstbuf_nr );
d215 5
a219 2

static void begin( struct copy_context *copy, GLenum mode, GLboolean begin_flag )
a222 2
/*    _mesa_printf("begin %s (%d)\n", _mesa_lookup_enum_by_nr(mode), begin_flag); */
		
d228 2
a229 1
/* Use a hashtable to attempt to identify recently-emitted vertices
d232 2
a233 1
static GLuint elt(struct copy_context *copy, GLuint elt_idx)
d238 1
a238 1
/*    _mesa_printf("elt %d\n", elt); */
d247 1
a247 1
/*       _mesa_printf("  --> emit to dstelt %d\n", copy->dstbuf_nr); */
d256 11
d271 1
a271 1
	    _mesa_printf("  varying %d: ", i);
d273 2
a274 2
	       _mesa_printf("%x ", f[j]);
	    _mesa_printf("\n");
a275 1
	       
d283 2
a284 3
      assert(copy->dstptr == (copy->dstbuf + 
				    copy->dstbuf_nr * 
				    copy->vertex_size));
d287 1
a287 1
/*       _mesa_printf("  --> reuse vertex\n"); */
d289 1
a289 1
/*    _mesa_printf("  --> emit %d\n", copy->vert_cache[slot].out); */
d294 6
a299 1
static void end( struct copy_context *copy, GLboolean end_flag )
d303 1
a303 1
/*    _mesa_printf("end (%d)\n", end_flag); */
d314 2
a315 2

static void replay_elts( struct copy_context *copy )
d419 2
a420 1
static void replay_init( struct copy_context *copy )
d445 2
a446 5
	 if (vbo->Name && !vbo->Pointer) 
	    ctx->Driver.MapBuffer(ctx,
				  GL_ARRAY_BUFFER_ARB, 
				  GL_WRITE_ONLY, /* XXX */
				  vbo);
d459 3
a461 4
   if (copy->ib->obj->Name && !copy->ib->obj->Pointer) 
      ctx->Driver.MapBuffer(ctx, 
			    GL_ARRAY_BUFFER_ARB, /* XXX */
			    GL_WRITE_ONLY, /* XXX */
d464 2
a465 1
   srcptr = (const GLubyte *)ADD_POINTERS(copy->ib->obj->Pointer, copy->ib->ptr);
d469 1
a469 1
      copy->translated_elt_buf = _mesa_malloc(sizeof(GLuint) * copy->ib->count);
d477 1
a477 1
      copy->translated_elt_buf = _mesa_malloc(sizeof(GLuint) * copy->ib->count);
a488 1
   
d503 1
a503 2
   copy->dstbuf = _mesa_malloc(copy->dstbuf_size * 
			       copy->vertex_size);   
d514 1
d520 1
a520 1
      dst->BufferObj = ctx->Array.NullBufferObj;
d532 1
a532 1
   copy->dstelt = _mesa_malloc(sizeof(GLuint) * copy->dstelt_size);
d540 1
a540 1
   copy->dstib.obj = ctx->Array.NullBufferObj;
d545 5
a549 1
static void replay_finish( struct copy_context *copy )
d556 4
a559 4
   _mesa_free(copy->translated_elt_buf);
   _mesa_free(copy->dstbuf);
   _mesa_free(copy->dstelt);
   
d564 2
a565 3

      if (vbo->Name && vbo->Pointer) 
	 ctx->Driver.UnmapBuffer(ctx, GL_ARRAY_BUFFER_ARB, vbo);
d570 3
a572 4
   if (copy->ib->obj->Name && copy->ib->obj->Pointer) {
      ctx->Driver.UnmapBuffer(ctx, 
			      GL_ARRAY_BUFFER_ARB, /* XXX */
			      copy->ib->obj);
d576 4
d589 1
a589 1
   GLuint i;
d591 10
a600 1
   memset(&copy, 0, sizeof(copy));
d602 1
a602 11
   /* Require indexed primitives:
    */
   assert(ib);
   
   copy.ctx = ctx;
   copy.array = arrays;
   copy.prim = prim;
   copy.nr_prims = nr_prims;
   copy.ib = ib;
   copy.draw = draw;
   copy.limits = limits;
d604 21
a624 10

   /* Clear the vertex cache:
    */
   for (i = 0; i < ELT_TABLE_SIZE; i++)
      copy.vert_cache[i].in = ~0;


   replay_init(&copy);
   replay_elts(&copy);
   replay_finish(&copy);
@


1.2
log
@Update to Mesa 7.0.2. Tested by naddy@@ (full ports build), simon@@
and oga@@ (with dri enabled).
@
text
@d32 5
a36 5
#include "glheader.h"
#include "imports.h"
#include "macros.h"
#include "enums.h"
#include "mtypes.h"
d132 1
a132 1
   GLenum mode = copy->dstprim[copy->dstprim_nr].mode;
d136 1
a136 1
      return GL_FALSE;
d468 1
a468 1
      dst->Normalized = src->Normalized;
@


1.1
log
@Initial revision
@
text
@d132 7
d468 1
a468 1
      dst->Normalized = GL_TRUE;
@


1.1.1.1
log
@Mesa 7.0.1
@
text
@@


1.1.1.2
log
@Import Mesa 7.10.3
@
text
@d32 5
a36 6
#include "main/glheader.h"
#include "main/bufferobj.h"
#include "main/imports.h"
#include "main/image.h"
#include "main/macros.h"
#include "main/mtypes.h"
d44 1
a44 2
/**
 * Used for vertex-level splitting of indexed buffers.  Note that
d50 1
a50 1
   struct gl_context *ctx;
d76 1
a76 1
   /** A baby hash table to avoid re-emitting (some) duplicate
d83 1
d87 6
a92 5
   GLubyte *dstptr;     /**< dstptr == dstbuf + dstelt_max * vertsize */
   GLuint dstbuf_size;  /**< in vertices */
   GLuint dstbuf_nr;    /**< count of emitted vertices, also the largest value
                         * in dstelt.  Our MaxIndex.
                         */
d105 15
d122 1
a122 1
   return array->Size * _mesa_sizeof_type(array->Type);
d126 1
a126 2
/**
 * Starts returning true slightly before the buffer fills, to ensure
d130 1
a130 2
static GLboolean
check_flush( struct copy_context *copy )
a131 7
   GLenum mode = copy->dstprim[copy->dstprim_nr].mode; 

   if (GL_TRIANGLE_STRIP == mode &&
       copy->dstelt_nr & 1) { /* see bug9962 */
       return GL_FALSE;
   }

d141 1
a141 38

/**
 * Dump the parameters/info for a vbo->draw() call.
 */
static void
dump_draw_info(struct gl_context *ctx,
               const struct gl_client_array **arrays,
               const struct _mesa_prim *prims,
               GLuint nr_prims,
               const struct _mesa_index_buffer *ib,
               GLuint min_index,
               GLuint max_index)
{
   GLuint i, j;

   printf("VBO Draw:\n");
   for (i = 0; i < nr_prims; i++) {
      printf("Prim %u of %u\n", i, nr_prims);
      printf("  Prim mode 0x%x\n", prims[i].mode);
      printf("  IB: %p\n", (void*) ib);
      for (j = 0; j < VERT_ATTRIB_MAX; j++) {
         printf("    array %d at %p:\n", j, (void*) arrays[j]);
         printf("      enabled %d, ptr %p, size %d, type 0x%x, stride %d\n",
		arrays[j]->Enabled, arrays[j]->Ptr,
		arrays[j]->Size, arrays[j]->Type, arrays[j]->StrideB);
         if (0) {
            GLint k = prims[i].start + prims[i].count - 1;
            GLfloat *last = (GLfloat *) (arrays[j]->Ptr + arrays[j]->Stride * k);
            printf("        last: %f %f %f\n",
		   last[0], last[1], last[2]);
         }
      }
   }
}


static void
flush( struct copy_context *copy )
a148 12
#if 0
   dump_draw_info(copy->ctx,
                  copy->dstarray_ptr,
                  copy->dstprim,
                  copy->dstprim_nr,
                  &copy->dstib,
                  0,
                  copy->dstbuf_nr);
#else
   (void) dump_draw_info;
#endif

a153 1
	       GL_TRUE,
d155 1
a155 1
	       copy->dstbuf_nr - 1 );
d171 2
a172 5
/**
 * Called at begin of each primitive during replay.
 */
static void
begin( struct copy_context *copy, GLenum mode, GLboolean begin_flag )
d176 2
d183 1
a183 2
/**
 * Use a hashtable to attempt to identify recently-emitted vertices
d186 1
a186 2
static GLuint
elt(struct copy_context *copy, GLuint elt_idx)
d191 1
a191 1
/*    printf("elt %d\n", elt); */
d200 1
a200 1
/*       printf("  --> emit to dstelt %d\n", copy->dstbuf_nr); */
a208 11
#ifdef NAN_CHECK
         if (srcarray->Type == GL_FLOAT) {
            GLuint k;
            GLfloat *f = (GLfloat *) srcptr;
            for (k = 0; k < srcarray->Size; k++) {
               assert(!IS_INF_OR_NAN(f[k]));
               assert(f[k] <= 1.0e20 && f[k] >= -1.0e20);
            }
         }
#endif

d213 1
a213 1
	    printf("  varying %d: ", i);
d215 2
a216 2
	       printf("%x ", f[j]);
	    printf("\n");
d218 1
d226 3
a228 2
      assert(copy->dstptr == (copy->dstbuf +
                              copy->dstbuf_nr * copy->vertex_size));
d231 1
a231 1
/*       printf("  --> reuse vertex\n"); */
d233 1
a233 1
/*    printf("  --> emit %d\n", copy->vert_cache[slot].out); */
d238 1
a238 6

/**
 * Called at end of each primitive during replay.
 */
static void
end( struct copy_context *copy, GLboolean end_flag )
d242 1
a242 1
/*    printf("end (%d)\n", end_flag); */
d253 2
a254 2
static void
replay_elts( struct copy_context *copy )
d358 1
a358 2
static void
replay_init( struct copy_context *copy )
d360 1
a360 1
   struct gl_context *ctx = copy->ctx;
d383 5
a387 2
	 if (_mesa_is_bufferobj(vbo) && !_mesa_bufferobj_mapped(vbo)) 
	    ctx->Driver.MapBuffer(ctx, GL_ARRAY_BUFFER, GL_READ_ONLY, vbo);
d400 4
a403 3
   if (_mesa_is_bufferobj(copy->ib->obj) &&
       !_mesa_bufferobj_mapped(copy->ib->obj)) 
      ctx->Driver.MapBuffer(ctx, GL_ELEMENT_ARRAY_BUFFER, GL_READ_ONLY,
d406 1
a406 2
   srcptr = (const GLubyte *) ADD_POINTERS(copy->ib->obj->Pointer,
                                           copy->ib->ptr);
d410 1
a410 1
      copy->translated_elt_buf = malloc(sizeof(GLuint) * copy->ib->count);
d418 1
a418 1
      copy->translated_elt_buf = malloc(sizeof(GLuint) * copy->ib->count);
d430 1
d445 2
a446 1
   copy->dstbuf = malloc(copy->dstbuf_size * copy->vertex_size);   
a456 1
      dst->Format = GL_RGBA;
d461 2
a462 2
      dst->Normalized = src->Normalized; 
      dst->BufferObj = ctx->Shared->NullBufferObj;
d474 1
a474 1
   copy->dstelt = malloc(sizeof(GLuint) * copy->dstelt_size);
d482 1
a482 1
   copy->dstib.obj = ctx->Shared->NullBufferObj;
d487 1
a487 5
/**
 * Free up everything allocated during split/replay.
 */
static void
replay_finish( struct copy_context *copy )
d489 1
a489 1
   struct gl_context *ctx = copy->ctx;
d494 4
a497 4
   free(copy->translated_elt_buf);
   free(copy->dstbuf);
   free(copy->dstelt);

d502 3
a504 2
      if (_mesa_is_bufferobj(vbo) && _mesa_bufferobj_mapped(vbo)) 
	 ctx->Driver.UnmapBuffer(ctx, GL_ARRAY_BUFFER, vbo);
d509 4
a512 3
   if (_mesa_is_bufferobj(copy->ib->obj) &&
       _mesa_bufferobj_mapped(copy->ib->obj)) {
      ctx->Driver.UnmapBuffer(ctx, GL_ELEMENT_ARRAY_BUFFER, copy->ib->obj);
d516 1
a516 5

/**
 * Split VBO into smaller pieces, draw the pieces.
 */
void vbo_split_copy( struct gl_context *ctx,
d525 1
a525 1
   GLuint i, this_nr_prims;
d527 19
a545 10
   for (i = 0; i < nr_prims;) {
      /* Our SW TNL pipeline doesn't handle basevertex yet, so bind_indices
       * will rebase the elements to the basevertex, and we'll only
       * emit strings of prims with the same basevertex in one draw call.
       */
      for (this_nr_prims = 1; i + this_nr_prims < nr_prims;
	   this_nr_prims++) {
	 if (prim[i].basevertex != prim[i + this_nr_prims].basevertex)
	    break;
      }
a546 1
      memset(&copy, 0, sizeof(copy));
d548 3
a550 21
      /* Require indexed primitives:
       */
      assert(ib);

      copy.ctx = ctx;
      copy.array = arrays;
      copy.prim = &prim[i];
      copy.nr_prims = this_nr_prims;
      copy.ib = ib;
      copy.draw = draw;
      copy.limits = limits;

      /* Clear the vertex cache:
       */
      for (i = 0; i < ELT_TABLE_SIZE; i++)
	 copy.vert_cache[i].in = ~0;

      replay_init(&copy);
      replay_elts(&copy);
      replay_finish(&copy);
   }
@


1.1.1.3
log
@Import Mesa 9.2.0
@
text
@d4 1
d21 3
a23 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
d35 1
a35 1
#include "main/glformats.h"
a173 2
   struct gl_context *ctx = copy->ctx;
   const struct gl_client_array **saved_arrays = ctx->Array._DrawArrays;
d192 2
a193 4
   ctx->Array._DrawArrays = copy->dstarray_ptr;
   ctx->NewDriverState |= ctx->DriverFlags.NewArray;

   copy->draw( ctx,
d199 1
a199 5
	       copy->dstbuf_nr - 1,
	       NULL );

   ctx->Array._DrawArrays = saved_arrays;
   ctx->NewDriverState |= ctx->DriverFlags.NewArray;
a224 1
   prim->num_instances = 1;
d446 1
a446 1
	    ctx->Driver.MapBufferRange(ctx, 0, vbo->Size, GL_MAP_READ_BIT, vbo);
d461 2
a462 2
      ctx->Driver.MapBufferRange(ctx, 0, copy->ib->obj->Size, GL_MAP_READ_BIT,
				 copy->ib->obj);
a519 1
      dst->Integer = src->Integer;
a520 1
      dst->_ElementSize = src->_ElementSize;
d565 1
a565 1
	 ctx->Driver.UnmapBuffer(ctx, vbo);
d572 1
a572 1
      ctx->Driver.UnmapBuffer(ctx, copy->ib->obj);
@


1.1.1.4
log
@Import Mesa 10.2.3
@
text
@d26 1
a26 1
 *    Keith Whitwell <keithw@@vmware.com>
d204 1
a204 1
	       NULL, NULL );
d454 5
a458 8
	 if (_mesa_is_bufferobj(vbo) &&
             !_mesa_bufferobj_mapped(vbo, MAP_INTERNAL))
	    ctx->Driver.MapBufferRange(ctx, 0, vbo->Size, GL_MAP_READ_BIT, vbo,
                                       MAP_INTERNAL);

	 copy->varying[j].src_ptr =
               ADD_POINTERS(vbo->Mappings[MAP_INTERNAL].Pointer,
                            copy->array[i]->Ptr);
d469 1
a469 1
       !_mesa_bufferobj_mapped(copy->ib->obj, MAP_INTERNAL))
d471 1
a471 1
				 copy->ib->obj, MAP_INTERNAL);
d473 2
a474 3
   srcptr = (const GLubyte *)
            ADD_POINTERS(copy->ib->obj->Mappings[MAP_INTERNAL].Pointer,
                         copy->ib->ptr);
d575 2
a576 2
      if (_mesa_is_bufferobj(vbo) && _mesa_bufferobj_mapped(vbo, MAP_INTERNAL))
	 ctx->Driver.UnmapBuffer(ctx, vbo, MAP_INTERNAL);
d582 2
a583 2
       _mesa_bufferobj_mapped(copy->ib->obj, MAP_INTERNAL)) {
      ctx->Driver.UnmapBuffer(ctx, copy->ib->obj, MAP_INTERNAL);
@


1.1.1.5
log
@Import Mesa 10.4.3
@
text
@d536 1
@


1.1.1.6
log
@Import Mesa 10.2.9
@
text
@a535 1
      dst->_MaxElement = copy->dstbuf_size; /* may be less! */
@


