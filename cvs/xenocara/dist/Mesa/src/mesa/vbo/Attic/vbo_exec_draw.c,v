head	1.11;
access;
symbols
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	v10_2_9:1.1.1.6
	v10_4_3:1.1.1.5
	v10_2_7:1.1.1.4
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	v10_2_3:1.1.1.4
	OPENBSD_5_5:1.7.0.2
	OPENBSD_5_5_BASE:1.7
	v9_2_5:1.1.1.3
	v9_2_3:1.1.1.3
	v9_2_2:1.1.1.3
	v9_2_1:1.1.1.3
	v9_2_0:1.1.1.3
	OPENBSD_5_4:1.6.0.4
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	v7_10_3:1.1.1.2
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.1.0.4
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.2
	v7_0_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2015.12.23.05.17.55;	author jsg;	state dead;
branches;
next	1.10;
commitid	TnlogFl9nOv2eaRf;

1.10
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.9;
commitid	4ry2gvZGMXkCUD2n;

1.9
date	2015.01.25.14.41.22;	author jsg;	state Exp;
branches;
next	1.8;
commitid	mcxB0JvoI9gTDYXU;

1.8
date	2014.07.09.21.09.01;	author jsg;	state Exp;
branches;
next	1.7;
commitid	WPD6rgPryPkvXOr9;

1.7
date	2013.09.05.14.06.59;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2012.08.17.13.58.20;	author mpi;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.23.13.37.46;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.37;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.43;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.23;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.24.17.32.25;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.11.24.17.32.25;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2011.10.23.13.29.50;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2013.09.05.13.17.45;	author jsg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.07.09.20.35.14;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.5
date	2015.01.25.14.13.38;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.6
date	2015.02.20.22.50.43;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.11
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2008  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Authors:
 *    Keith Whitwell <keithw@@vmware.com>
 */

#include "main/glheader.h"
#include "main/bufferobj.h"
#include "main/compiler.h"
#include "main/context.h"
#include "main/enums.h"
#include "main/state.h"
#include "main/vtxfmt.h"

#include "vbo_context.h"
#include "vbo_noop.h"


static void
vbo_exec_debug_verts( struct vbo_exec_context *exec )
{
   GLuint count = exec->vtx.vert_count;
   GLuint i;

   printf("%s: %u vertices %d primitives, %d vertsize\n",
	  __FUNCTION__,
	  count,
	  exec->vtx.prim_count,
	  exec->vtx.vertex_size);

   for (i = 0 ; i < exec->vtx.prim_count ; i++) {
      struct _mesa_prim *prim = &exec->vtx.prim[i];
      printf("   prim %d: %s%s %d..%d %s %s\n",
	     i, 
	     _mesa_lookup_prim_by_nr(prim->mode),
	     prim->weak ? " (weak)" : "",
	     prim->start, 
	     prim->start + prim->count,
	     prim->begin ? "BEGIN" : "(wrap)",
	     prim->end ? "END" : "(wrap)");
   }
}


/*
 * NOTE: Need to have calculated primitives by this point -- do it on the fly.
 * NOTE: Old 'parity' issue is gone.
 */
static GLuint
vbo_copy_vertices( struct vbo_exec_context *exec )
{
   GLuint nr = exec->vtx.prim[exec->vtx.prim_count-1].count;
   GLuint ovf, i;
   GLuint sz = exec->vtx.vertex_size;
   GLfloat *dst = exec->vtx.copied.buffer;
   const GLfloat *src = (exec->vtx.buffer_map + 
                         exec->vtx.prim[exec->vtx.prim_count-1].start * 
                         exec->vtx.vertex_size);


   switch (exec->ctx->Driver.CurrentExecPrimitive) {
   case GL_POINTS:
      return 0;
   case GL_LINES:
      ovf = nr&1;
      for (i = 0 ; i < ovf ; i++)
	 memcpy( dst+i*sz, src+(nr-ovf+i)*sz, sz * sizeof(GLfloat) );
      return i;
   case GL_TRIANGLES:
      ovf = nr%3;
      for (i = 0 ; i < ovf ; i++)
	 memcpy( dst+i*sz, src+(nr-ovf+i)*sz, sz * sizeof(GLfloat) );
      return i;
   case GL_QUADS:
      ovf = nr&3;
      for (i = 0 ; i < ovf ; i++)
	 memcpy( dst+i*sz, src+(nr-ovf+i)*sz, sz * sizeof(GLfloat) );
      return i;
   case GL_LINE_STRIP:
      if (nr == 0) {
	 return 0;
      }
      else {
	 memcpy( dst, src+(nr-1)*sz, sz * sizeof(GLfloat) );
	 return 1;
      }
   case GL_LINE_LOOP:
   case GL_TRIANGLE_FAN:
   case GL_POLYGON:
      if (nr == 0) {
	 return 0;
      }
      else if (nr == 1) {
	 memcpy( dst, src+0, sz * sizeof(GLfloat) );
	 return 1;
      }
      else {
	 memcpy( dst, src+0, sz * sizeof(GLfloat) );
	 memcpy( dst+sz, src+(nr-1)*sz, sz * sizeof(GLfloat) );
	 return 2;
      }
   case GL_TRIANGLE_STRIP:
      /* no parity issue, but need to make sure the tri is not drawn twice */
      if (nr & 1) {
	 exec->vtx.prim[exec->vtx.prim_count-1].count--;
      }
      /* fallthrough */
   case GL_QUAD_STRIP:
      switch (nr) {
      case 0:
         ovf = 0;
         break;
      case 1:
         ovf = 1;
         break;
      default:
         ovf = 2 + (nr & 1);
         break;
      }
      for (i = 0 ; i < ovf ; i++)
	 memcpy( dst+i*sz, src+(nr-ovf+i)*sz, sz * sizeof(GLfloat) );
      return i;
   case PRIM_OUTSIDE_BEGIN_END:
      return 0;
   default:
      assert(0);
      return 0;
   }
}



/* TODO: populate these as the vertex is defined:
 */
static void
vbo_exec_bind_arrays( struct gl_context *ctx )
{
   struct vbo_context *vbo = vbo_context(ctx);
   struct vbo_exec_context *exec = &vbo->exec;
   struct gl_client_array *arrays = exec->vtx.arrays;
   const GLuint count = exec->vtx.vert_count;
   const GLuint *map;
   GLuint attr;
   GLbitfield64 varying_inputs = 0x0;

   /* Install the default (ie Current) attributes first, then overlay
    * all active ones.
    */
   switch (get_program_mode(exec->ctx)) {
   case VP_NONE:
      for (attr = 0; attr < VERT_ATTRIB_FF_MAX; attr++) {
         exec->vtx.inputs[attr] = &vbo->currval[VBO_ATTRIB_POS+attr];
      }
      for (attr = 0; attr < MAT_ATTRIB_MAX; attr++) {
         ASSERT(VERT_ATTRIB_GENERIC(attr) < Elements(exec->vtx.inputs));
         exec->vtx.inputs[VERT_ATTRIB_GENERIC(attr)] =
            &vbo->currval[VBO_ATTRIB_MAT_FRONT_AMBIENT+attr];
      }
      map = vbo->map_vp_none;
      break;
   case VP_ARB:
      for (attr = 0; attr < VERT_ATTRIB_FF_MAX; attr++) {
         exec->vtx.inputs[attr] = &vbo->currval[VBO_ATTRIB_POS+attr];
      }
      for (attr = 0; attr < VERT_ATTRIB_GENERIC_MAX; attr++) {
         ASSERT(VERT_ATTRIB_GENERIC(attr) < Elements(exec->vtx.inputs));
         exec->vtx.inputs[VERT_ATTRIB_GENERIC(attr)] =
            &vbo->currval[VBO_ATTRIB_GENERIC0+attr];
      }
      map = vbo->map_vp_arb;

      /* check if VERT_ATTRIB_POS is not read but VERT_BIT_GENERIC0 is read.
       * In that case we effectively need to route the data from
       * glVertexAttrib(0, val) calls to feed into the GENERIC0 input.
       */
      if ((ctx->VertexProgram._Current->Base.InputsRead & VERT_BIT_POS) == 0 &&
          (ctx->VertexProgram._Current->Base.InputsRead & VERT_BIT_GENERIC0)) {
         exec->vtx.inputs[VERT_ATTRIB_GENERIC0] = exec->vtx.inputs[0];
         exec->vtx.attrsz[VERT_ATTRIB_GENERIC0] = exec->vtx.attrsz[0];
         exec->vtx.attrptr[VERT_ATTRIB_GENERIC0] = exec->vtx.attrptr[0];
         exec->vtx.attrsz[0] = 0;
      }
      break;
   default:
      assert(0);
   }

   for (attr = 0; attr < VERT_ATTRIB_MAX ; attr++) {
      const GLuint src = map[attr];

      if (exec->vtx.attrsz[src]) {
	 GLsizeiptr offset = (GLbyte *)exec->vtx.attrptr[src] -
	    (GLbyte *)exec->vtx.vertex;

         /* override the default array set above */
         ASSERT(attr < Elements(exec->vtx.inputs));
         ASSERT(attr < Elements(exec->vtx.arrays)); /* arrays[] */
         exec->vtx.inputs[attr] = &arrays[attr];

         if (_mesa_is_bufferobj(exec->vtx.bufferobj)) {
            /* a real buffer obj: Ptr is an offset, not a pointer*/
            assert(exec->vtx.bufferobj->Mappings[MAP_INTERNAL].Pointer);
            assert(offset >= 0);
            arrays[attr].Ptr = (GLubyte *)
               exec->vtx.bufferobj->Mappings[MAP_INTERNAL].Offset + offset;
         }
         else {
            /* Ptr into ordinary app memory */
            arrays[attr].Ptr = (GLubyte *)exec->vtx.buffer_map + offset;
         }
	 arrays[attr].Size = exec->vtx.attrsz[src];
	 arrays[attr].StrideB = exec->vtx.vertex_size * sizeof(GLfloat);
	 arrays[attr].Stride = exec->vtx.vertex_size * sizeof(GLfloat);
	 arrays[attr].Type = exec->vtx.attrtype[src];
	 arrays[attr].Integer =
               vbo_attrtype_to_integer_flag(exec->vtx.attrtype[src]);
         arrays[attr].Format = GL_RGBA;
	 arrays[attr].Enabled = 1;
         arrays[attr]._ElementSize = arrays[attr].Size * sizeof(GLfloat);
         _mesa_reference_buffer_object(ctx,
                                       &arrays[attr].BufferObj,
                                       exec->vtx.bufferobj);
	 arrays[attr]._MaxElement = count; /* ??? */

         varying_inputs |= VERT_BIT(attr);
      }
   }

   _mesa_set_varying_vp_inputs( ctx, varying_inputs );
   ctx->NewDriverState |= ctx->DriverFlags.NewArray;
}


/**
 * Unmap the VBO.  This is called before drawing.
 */
static void
vbo_exec_vtx_unmap( struct vbo_exec_context *exec )
{
   if (_mesa_is_bufferobj(exec->vtx.bufferobj)) {
      struct gl_context *ctx = exec->ctx;
      
      if (ctx->Driver.FlushMappedBufferRange) {
         GLintptr offset = exec->vtx.buffer_used -
                           exec->vtx.bufferobj->Mappings[MAP_INTERNAL].Offset;
         GLsizeiptr length = (exec->vtx.buffer_ptr - exec->vtx.buffer_map) *
                             sizeof(float);

         if (length)
            ctx->Driver.FlushMappedBufferRange(ctx, offset, length,
                                               exec->vtx.bufferobj,
                                               MAP_INTERNAL);
      }

      exec->vtx.buffer_used += (exec->vtx.buffer_ptr -
                                exec->vtx.buffer_map) * sizeof(float);

      assert(exec->vtx.buffer_used <= VBO_VERT_BUFFER_SIZE);
      assert(exec->vtx.buffer_ptr != NULL);
      
      ctx->Driver.UnmapBuffer(ctx, exec->vtx.bufferobj, MAP_INTERNAL);
      exec->vtx.buffer_map = NULL;
      exec->vtx.buffer_ptr = NULL;
      exec->vtx.max_vert = 0;
   }
}


/**
 * Map the vertex buffer to begin storing glVertex, glColor, etc data.
 */
void
vbo_exec_vtx_map( struct vbo_exec_context *exec )
{
   struct gl_context *ctx = exec->ctx;
   const GLenum accessRange = GL_MAP_WRITE_BIT |  /* for MapBufferRange */
                              GL_MAP_INVALIDATE_RANGE_BIT |
                              GL_MAP_UNSYNCHRONIZED_BIT |
                              GL_MAP_FLUSH_EXPLICIT_BIT |
                              MESA_MAP_NOWAIT_BIT;
   const GLenum usage = GL_STREAM_DRAW_ARB;
   
   if (!_mesa_is_bufferobj(exec->vtx.bufferobj))
      return;

   assert(!exec->vtx.buffer_map);
   assert(!exec->vtx.buffer_ptr);

   if (VBO_VERT_BUFFER_SIZE > exec->vtx.buffer_used + 1024) {
      /* The VBO exists and there's room for more */
      if (exec->vtx.bufferobj->Size > 0) {
         exec->vtx.buffer_map =
            (GLfloat *)ctx->Driver.MapBufferRange(ctx, 
                                                  exec->vtx.buffer_used,
                                                  (VBO_VERT_BUFFER_SIZE - 
                                                   exec->vtx.buffer_used),
                                                  accessRange,
                                                  exec->vtx.bufferobj,
                                                  MAP_INTERNAL);
         exec->vtx.buffer_ptr = exec->vtx.buffer_map;
      }
      else {
         exec->vtx.buffer_ptr = exec->vtx.buffer_map = NULL;
      }
   }
   
   if (!exec->vtx.buffer_map) {
      /* Need to allocate a new VBO */
      exec->vtx.buffer_used = 0;

      if (ctx->Driver.BufferData(ctx, GL_ARRAY_BUFFER_ARB,
                                 VBO_VERT_BUFFER_SIZE,
                                 NULL, usage,
                                 GL_MAP_WRITE_BIT |
                                 GL_DYNAMIC_STORAGE_BIT |
                                 GL_CLIENT_STORAGE_BIT,
                                 exec->vtx.bufferobj)) {
         /* buffer allocation worked, now map the buffer */
         exec->vtx.buffer_map =
            (GLfloat *)ctx->Driver.MapBufferRange(ctx,
                                                  0, VBO_VERT_BUFFER_SIZE,
                                                  accessRange,
                                                  exec->vtx.bufferobj,
                                                  MAP_INTERNAL);
      }
      else {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "VBO allocation");
         exec->vtx.buffer_map = NULL;
      }
   }

   exec->vtx.buffer_ptr = exec->vtx.buffer_map;

   if (!exec->vtx.buffer_map) {
      /* out of memory */
      _mesa_install_exec_vtxfmt( ctx, &exec->vtxfmt_noop );
   }
   else {
      if (_mesa_using_noop_vtxfmt(ctx->Exec)) {
         /* The no-op functions are installed so switch back to regular
          * functions.  We do this test just to avoid frequent and needless
          * calls to _mesa_install_exec_vtxfmt().
          */
         _mesa_install_exec_vtxfmt(ctx, &exec->vtxfmt);
      }
   }

   if (0)
      printf("map %d..\n", exec->vtx.buffer_used);
}



/**
 * Execute the buffer and save copied verts.
 * \param keep_unmapped  if true, leave the VBO unmapped when we're done.
 */
void
vbo_exec_vtx_flush(struct vbo_exec_context *exec, GLboolean keepUnmapped)
{
   if (0)
      vbo_exec_debug_verts( exec );

   if (exec->vtx.prim_count && 
       exec->vtx.vert_count) {

      exec->vtx.copied.nr = vbo_copy_vertices( exec ); 

      if (exec->vtx.copied.nr != exec->vtx.vert_count) {
	 struct gl_context *ctx = exec->ctx;
	 
	 /* Before the update_state() as this may raise _NEW_VARYING_VP_INPUTS
          * from _mesa_set_varying_vp_inputs().
	  */
	 vbo_exec_bind_arrays( ctx );

         if (ctx->NewState)
            _mesa_update_state( ctx );

         if (_mesa_is_bufferobj(exec->vtx.bufferobj)) {
            vbo_exec_vtx_unmap( exec );
         }

         if (0)
            printf("%s %d %d\n", __FUNCTION__, exec->vtx.prim_count,
		   exec->vtx.vert_count);

	 vbo_context(ctx)->draw_prims( ctx, 
				       exec->vtx.prim,
				       exec->vtx.prim_count,
				       NULL,
				       GL_TRUE,
				       0,
				       exec->vtx.vert_count - 1,
				       NULL, NULL);

	 /* If using a real VBO, get new storage -- unless asked not to.
          */
         if (_mesa_is_bufferobj(exec->vtx.bufferobj) && !keepUnmapped) {
            vbo_exec_vtx_map( exec );
         }
      }
   }

   /* May have to unmap explicitly if we didn't draw:
    */
   if (keepUnmapped &&
       _mesa_is_bufferobj(exec->vtx.bufferobj) &&
       exec->vtx.buffer_map) {
      vbo_exec_vtx_unmap( exec );
   }

   if (keepUnmapped || exec->vtx.vertex_size == 0)
      exec->vtx.max_vert = 0;
   else
      exec->vtx.max_vert = ((VBO_VERT_BUFFER_SIZE - exec->vtx.buffer_used) / 
                            (exec->vtx.vertex_size * sizeof(GLfloat)));

   exec->vtx.buffer_ptr = exec->vtx.buffer_map;
   exec->vtx.prim_count = 0;
   exec->vtx.vert_count = 0;
}
@


1.10
log
@Merge Mesa 10.2.9
@
text
@@


1.9
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d162 1
d244 1
@


1.8
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@a161 1
   const GLuint count = exec->vtx.vert_count;
a242 1
	 arrays[attr]._MaxElement = count; /* ??? */
@


1.7
log
@Merge Mesa 9.2.0
@
text
@d25 1
a25 1
 *    Keith Whitwell <keith@@tungstengraphics.com>
d223 1
a223 1
            assert(exec->vtx.bufferobj->Pointer);  /* buf should be mapped */
d225 2
a226 1
            arrays[attr].Ptr = (GLubyte *)exec->vtx.bufferobj->Offset + offset;
d265 4
a268 2
         GLintptr offset = exec->vtx.buffer_used - exec->vtx.bufferobj->Offset;
         GLsizeiptr length = (exec->vtx.buffer_ptr - exec->vtx.buffer_map) * sizeof(float);
d272 2
a273 1
                                               exec->vtx.bufferobj);
d282 1
a282 1
      ctx->Driver.UnmapBuffer(ctx, exec->vtx.bufferobj);
d319 2
a320 1
                                                  exec->vtx.bufferobj);
d333 6
a338 2
                                  VBO_VERT_BUFFER_SIZE, 
                                  NULL, usage, exec->vtx.bufferobj)) {
d344 2
a345 1
                                                  exec->vtx.bufferobj);
d416 1
a416 1
				       NULL);
@


1.6
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a2 1
 * Version:  7.2
d19 4
a22 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
d31 1
a32 1
#include "main/mfeatures.h"
d34 1
d37 1
a37 3


#if FEATURE_beginend
d165 1
a165 1
   GLbitfield varying_inputs = 0x0;
d172 2
a173 2
      for (attr = 0; attr < 16; attr++) {
         exec->vtx.inputs[attr] = &vbo->legacy_currval[attr];
d176 3
a178 2
         ASSERT(attr + 16 < Elements(exec->vtx.inputs));
         exec->vtx.inputs[attr + 16] = &vbo->mat_currval[attr];
a181 1
   case VP_NV:
d183 7
a189 8
      /* The aliasing of attributes for NV vertex programs has already
       * occurred.  NV vertex programs cannot access material values,
       * nor attributes greater than VERT_ATTRIB_TEX7.  
       */
      for (attr = 0; attr < 16; attr++) {
         exec->vtx.inputs[attr] = &vbo->legacy_currval[attr];
         ASSERT(attr + 16 < Elements(exec->vtx.inputs));
         exec->vtx.inputs[attr + 16] = &vbo->generic_currval[attr];
d199 3
a201 3
         exec->vtx.inputs[16] = exec->vtx.inputs[0];
         exec->vtx.attrsz[16] = exec->vtx.attrsz[0];
         exec->vtx.attrptr[16] = exec->vtx.attrptr[0];
a208 3
   /* Make all active attributes (including edgeflag) available as
    * arrays of floats.
    */
d234 3
a236 1
	 arrays[attr].Type = GL_FLOAT;
d245 1
a245 2
         varying_inputs |= 1 << attr;
         ctx->NewState |= _NEW_ARRAY;
d250 1
a259 2
   GLenum target = GL_ARRAY_BUFFER_ARB;

d268 1
a268 2
            ctx->Driver.FlushMappedBufferRange(ctx, target,
                                               offset, length,
d278 1
a278 1
      ctx->Driver.UnmapBuffer(ctx, target, exec->vtx.bufferobj);
a292 2
   const GLenum target = GL_ARRAY_BUFFER_ARB;
   const GLenum access = GL_READ_WRITE_ARB; /* for MapBuffer */
d306 1
a306 2
   if (VBO_VERT_BUFFER_SIZE > exec->vtx.buffer_used + 1024 &&
       ctx->Driver.MapBufferRange) {
d308 13
a320 9
      exec->vtx.buffer_map = 
         (GLfloat *)ctx->Driver.MapBufferRange(ctx, 
                                               target, 
                                               exec->vtx.buffer_used,
                                               (VBO_VERT_BUFFER_SIZE - 
                                                exec->vtx.buffer_used),
                                               accessRange,
                                               exec->vtx.bufferobj);
      exec->vtx.buffer_ptr = exec->vtx.buffer_map;
d327 6
a332 8
      ctx->Driver.BufferData(ctx, target, 
                             VBO_VERT_BUFFER_SIZE, 
                             NULL, usage, exec->vtx.bufferobj);


      if (ctx->Driver.MapBufferRange)
         exec->vtx.buffer_map = 
            (GLfloat *)ctx->Driver.MapBufferRange(ctx, target,
d336 21
a356 5
      if (!exec->vtx.buffer_map)
         exec->vtx.buffer_map =
            (GLfloat *)ctx->Driver.MapBuffer(ctx, target, access, exec->vtx.bufferobj);
      assert(exec->vtx.buffer_map);
      exec->vtx.buffer_ptr = exec->vtx.buffer_map;
d383 1
a383 1
	 /* Before the update_state() as this may raise _NEW_ARRAY
d400 1
a400 2
				       exec->vtx.inputs, 
				       exec->vtx.prim, 
d405 2
a406 1
				       exec->vtx.vert_count - 1);
a433 3


#endif /* FEATURE_beginend */
@


1.5
log
@Merge Mesa 7.10.3
@
text
@d32 1
d242 1
d249 1
d257 3
d292 3
d311 2
a312 5
   if (exec->vtx.buffer_map != NULL) {
      assert(0);
      exec->vtx.buffer_map = NULL;
      exec->vtx.buffer_ptr = NULL;
   }
d316 1
d329 1
d358 1
d361 1
a361 1
vbo_exec_vtx_flush( struct vbo_exec_context *exec, GLboolean unmap )
d401 1
a401 1
         if (_mesa_is_bufferobj(exec->vtx.bufferobj) && !unmap) {
d409 1
a409 1
   if (unmap && 
d415 1
a415 2

   if (unmap || exec->vtx.vertex_size == 0)
@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d30 1
a30 1
#include "main/context.h"
d157 1
a157 1
vbo_exec_bind_arrays( GLcontext *ctx )
a162 1
   const GLubyte *data = (GLubyte *) exec->vtx.buffer_map;
d217 3
a226 1
            GLsizeiptr offset;
a227 3
            offset = (GLbyte *) data -
	       (GLbyte *) exec->vtx.bufferobj->Pointer +
	       exec->vtx.bufferobj->Offset;
d229 1
a229 1
            arrays[attr].Ptr = (void *) offset;
d233 1
a233 1
            arrays[attr].Ptr = (void *) data;
a245 1
	 data += exec->vtx.attrsz[src] * sizeof(GLfloat);
d260 1
a260 1
      GLcontext *ctx = exec->ctx;
d289 1
a289 1
   GLcontext *ctx = exec->ctx;
d363 1
a363 1
	 GLcontext *ctx = exec->ctx;
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@a32 1
#include "main/macros.h"
d37 5
a41 1
static void vbo_exec_debug_verts( struct vbo_exec_context *exec )
d46 5
a50 5
   _mesa_printf("%s: %u vertices %d primitives, %d vertsize\n",
		__FUNCTION__,
		count,
		exec->vtx.prim_count,
		exec->vtx.vertex_size);
d54 8
a61 8
      _mesa_printf("   prim %d: %s%s %d..%d %s %s\n",
		   i, 
		   _mesa_lookup_enum_by_nr(prim->mode),
		   prim->weak ? " (weak)" : "",
		   prim->start, 
		   prim->start + prim->count,
		   prim->begin ? "BEGIN" : "(wrap)",
		   prim->end ? "END" : "(wrap)");
d70 2
a71 1
static GLuint vbo_copy_vertices( struct vbo_exec_context *exec )
d77 3
a79 3
   GLfloat *src = ((GLfloat *)exec->vtx.buffer_map + 
		   exec->vtx.prim[exec->vtx.prim_count-1].start * 
		   exec->vtx.vertex_size);
d82 1
a82 2
   switch( exec->ctx->Driver.CurrentExecPrimitive )
   {
d88 1
a88 1
	 _mesa_memcpy( dst+i*sz, src+(nr-ovf+i)*sz, sz * sizeof(GLfloat) );
d93 1
a93 1
	 _mesa_memcpy( dst+i*sz, src+(nr-ovf+i)*sz, sz * sizeof(GLfloat) );
d98 1
a98 1
	 _mesa_memcpy( dst+i*sz, src+(nr-ovf+i)*sz, sz * sizeof(GLfloat) );
d101 1
a101 1
      if (nr == 0) 
d103 1
d105 1
a105 1
	 _mesa_memcpy( dst, src+(nr-1)*sz, sz * sizeof(GLfloat) );
d111 1
a111 1
      if (nr == 0) 
d113 1
d115 1
a115 1
	 _mesa_memcpy( dst, src+0, sz * sizeof(GLfloat) );
d117 4
a120 3
      } else {
	 _mesa_memcpy( dst, src+0, sz * sizeof(GLfloat) );
	 _mesa_memcpy( dst+sz, src+(nr-1)*sz, sz * sizeof(GLfloat) );
d131 9
a139 3
      case 0: ovf = 0; break;
      case 1: ovf = 1; break;
      default: ovf = 2 + (nr&1); break;
d142 1
a142 1
	 _mesa_memcpy( dst+i*sz, src+(nr-ovf+i)*sz, sz * sizeof(GLfloat) );
d156 2
a157 1
static void vbo_exec_bind_arrays( GLcontext *ctx )
d162 2
a163 2
   GLuint count = exec->vtx.vert_count;
   GLubyte *data = exec->vtx.buffer_map;
d166 1
d177 1
d190 1
d203 1
d219 2
d223 1
a223 1
         if (exec->vtx.bufferobj->Name) {
d225 1
a225 1
            int offset;
d227 3
a229 1
            offset = (GLbyte *) data - (GLbyte *) exec->vtx.bufferobj->Pointer;
d241 1
d249 1
d252 2
d257 94
d354 2
a355 1
void vbo_exec_vtx_flush( struct vbo_exec_context *exec )
a359 1

a366 5

	 GLenum target = GL_ARRAY_BUFFER_ARB;
	 GLenum access = GL_READ_WRITE_ARB;
	 GLenum usage = GL_STREAM_DRAW_ARB;
	 GLsizei size = VBO_VERT_BUFFER_SIZE * sizeof(GLfloat);
d368 2
a369 1
	 /* Before the unmap (why?)
d373 5
a377 4
         /* if using a real VBO, unmap it before drawing */
         if (exec->vtx.bufferobj->Name) {
            ctx->Driver.UnmapBuffer(ctx, target, exec->vtx.bufferobj);
            exec->vtx.buffer_map = NULL;
d380 4
d389 1
d393 4
a396 5
	 /* If using a real VBO, get new storage */
         if (exec->vtx.bufferobj->Name) {
            ctx->Driver.BufferData(ctx, target, size, NULL, usage, exec->vtx.bufferobj);
            exec->vtx.buffer_map = 
               ctx->Driver.MapBuffer(ctx, target, access, exec->vtx.bufferobj);
d401 16
a418 1
   exec->vtx.vbptr = (GLfloat *)exec->vtx.buffer_map;
d420 3
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d132 1
a132 1
   case GL_POLYGON+1:
d178 11
d190 2
d198 1
a198 1
      GLuint src = map[attr];
d204 12
a215 1
	 arrays[attr].Ptr = (void *)data;
d249 7
d258 6
d271 7
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * Version:  5.1
d5 1
a5 1
 * Copyright (C) 1999-2003  Brian Paul   All Rights Reserved.
d28 6
a33 5
#include "glheader.h"
#include "context.h"
#include "enums.h"
#include "state.h"
#include "macros.h"
d159 6
a164 2
      memcpy(arrays,      vbo->legacy_currval, 16 * sizeof(arrays[0]));
      memcpy(arrays + 16, vbo->mat_currval,    MAT_ATTRIB_MAX * sizeof(arrays[0]));
d173 4
a176 2
      memcpy(arrays,      vbo->legacy_currval,  16 * sizeof(arrays[0]));
      memcpy(arrays + 16, vbo->generic_currval, 16 * sizeof(arrays[0]));
d188 3
d197 3
a199 1
	 arrays[attr].BufferObj = exec->vtx.bufferobj; /* NullBufferObj */
d202 1
a202 1
	 data += exec->vtx.attrsz[attr] * sizeof(GLfloat);
@


1.1.1.1
log
@Mesa 7.0.1
@
text
@@


1.1.1.2
log
@Import Mesa 7.10.3
@
text
@d3 1
a3 1
 * Version:  7.2
d5 1
a5 1
 * Copyright (C) 1999-2008  Brian Paul   All Rights Reserved.
d28 5
a32 5
#include "main/glheader.h"
#include "main/bufferobj.h"
#include "main/compiler.h"
#include "main/enums.h"
#include "main/state.h"
d37 1
a37 5
#if FEATURE_beginend


static void
vbo_exec_debug_verts( struct vbo_exec_context *exec )
d42 5
a46 5
   printf("%s: %u vertices %d primitives, %d vertsize\n",
	  __FUNCTION__,
	  count,
	  exec->vtx.prim_count,
	  exec->vtx.vertex_size);
d50 8
a57 8
      printf("   prim %d: %s%s %d..%d %s %s\n",
	     i, 
	     _mesa_lookup_prim_by_nr(prim->mode),
	     prim->weak ? " (weak)" : "",
	     prim->start, 
	     prim->start + prim->count,
	     prim->begin ? "BEGIN" : "(wrap)",
	     prim->end ? "END" : "(wrap)");
d66 1
a66 2
static GLuint
vbo_copy_vertices( struct vbo_exec_context *exec )
d72 3
a74 3
   const GLfloat *src = (exec->vtx.buffer_map + 
                         exec->vtx.prim[exec->vtx.prim_count-1].start * 
                         exec->vtx.vertex_size);
d77 2
a78 1
   switch (exec->ctx->Driver.CurrentExecPrimitive) {
d84 1
a84 1
	 memcpy( dst+i*sz, src+(nr-ovf+i)*sz, sz * sizeof(GLfloat) );
d89 1
a89 1
	 memcpy( dst+i*sz, src+(nr-ovf+i)*sz, sz * sizeof(GLfloat) );
d94 1
a94 1
	 memcpy( dst+i*sz, src+(nr-ovf+i)*sz, sz * sizeof(GLfloat) );
d97 1
a97 1
      if (nr == 0) {
a98 1
      }
d100 1
a100 1
	 memcpy( dst, src+(nr-1)*sz, sz * sizeof(GLfloat) );
d106 1
a106 1
      if (nr == 0) {
a107 1
      }
d109 1
a109 1
	 memcpy( dst, src+0, sz * sizeof(GLfloat) );
d111 3
a113 4
      }
      else {
	 memcpy( dst, src+0, sz * sizeof(GLfloat) );
	 memcpy( dst+sz, src+(nr-1)*sz, sz * sizeof(GLfloat) );
d124 3
a126 9
      case 0:
         ovf = 0;
         break;
      case 1:
         ovf = 1;
         break;
      default:
         ovf = 2 + (nr & 1);
         break;
d129 1
a129 1
	 memcpy( dst+i*sz, src+(nr-ovf+i)*sz, sz * sizeof(GLfloat) );
d131 1
a131 1
   case PRIM_OUTSIDE_BEGIN_END:
d143 1
a143 2
static void
vbo_exec_bind_arrays( struct gl_context *ctx )
d148 2
a149 1
   const GLuint count = exec->vtx.vert_count;
a151 1
   GLbitfield varying_inputs = 0x0;
d158 2
a159 7
      for (attr = 0; attr < 16; attr++) {
         exec->vtx.inputs[attr] = &vbo->legacy_currval[attr];
      }
      for (attr = 0; attr < MAT_ATTRIB_MAX; attr++) {
         ASSERT(attr + 16 < Elements(exec->vtx.inputs));
         exec->vtx.inputs[attr + 16] = &vbo->mat_currval[attr];
      }
d168 2
a169 5
      for (attr = 0; attr < 16; attr++) {
         exec->vtx.inputs[attr] = &vbo->legacy_currval[attr];
         ASSERT(attr + 16 < Elements(exec->vtx.inputs));
         exec->vtx.inputs[attr + 16] = &vbo->generic_currval[attr];
      }
a170 12

      /* check if VERT_ATTRIB_POS is not read but VERT_BIT_GENERIC0 is read.
       * In that case we effectively need to route the data from
       * glVertexAttrib(0, val) calls to feed into the GENERIC0 input.
       */
      if ((ctx->VertexProgram._Current->Base.InputsRead & VERT_BIT_POS) == 0 &&
          (ctx->VertexProgram._Current->Base.InputsRead & VERT_BIT_GENERIC0)) {
         exec->vtx.inputs[16] = exec->vtx.inputs[0];
         exec->vtx.attrsz[16] = exec->vtx.attrsz[0];
         exec->vtx.attrptr[16] = exec->vtx.attrptr[0];
         exec->vtx.attrsz[0] = 0;
      }
a171 2
   default:
      assert(0);
d178 1
a178 1
      const GLuint src = map[attr];
d181 1
a181 18
	 GLsizeiptr offset = (GLbyte *)exec->vtx.attrptr[src] -
	    (GLbyte *)exec->vtx.vertex;

         /* override the default array set above */
         ASSERT(attr < Elements(exec->vtx.inputs));
         ASSERT(attr < Elements(exec->vtx.arrays)); /* arrays[] */
         exec->vtx.inputs[attr] = &arrays[attr];

         if (_mesa_is_bufferobj(exec->vtx.bufferobj)) {
            /* a real buffer obj: Ptr is an offset, not a pointer*/
            assert(exec->vtx.bufferobj->Pointer);  /* buf should be mapped */
            assert(offset >= 0);
            arrays[attr].Ptr = (GLubyte *)exec->vtx.bufferobj->Offset + offset;
         }
         else {
            /* Ptr into ordinary app memory */
            arrays[attr].Ptr = (GLubyte *)exec->vtx.buffer_map + offset;
         }
a185 1
         arrays[attr].Format = GL_RGBA;
d187 1
a187 3
         _mesa_reference_buffer_object(ctx,
                                       &arrays[attr].BufferObj,
                                       exec->vtx.bufferobj);
d190 1
a190 1
         varying_inputs |= 1 << attr;
a192 34

   _mesa_set_varying_vp_inputs( ctx, varying_inputs );
}


static void
vbo_exec_vtx_unmap( struct vbo_exec_context *exec )
{
   GLenum target = GL_ARRAY_BUFFER_ARB;

   if (_mesa_is_bufferobj(exec->vtx.bufferobj)) {
      struct gl_context *ctx = exec->ctx;
      
      if (ctx->Driver.FlushMappedBufferRange) {
         GLintptr offset = exec->vtx.buffer_used - exec->vtx.bufferobj->Offset;
         GLsizeiptr length = (exec->vtx.buffer_ptr - exec->vtx.buffer_map) * sizeof(float);

         if (length)
            ctx->Driver.FlushMappedBufferRange(ctx, target,
                                               offset, length,
                                               exec->vtx.bufferobj);
      }

      exec->vtx.buffer_used += (exec->vtx.buffer_ptr -
                                exec->vtx.buffer_map) * sizeof(float);

      assert(exec->vtx.buffer_used <= VBO_VERT_BUFFER_SIZE);
      assert(exec->vtx.buffer_ptr != NULL);
      
      ctx->Driver.UnmapBuffer(ctx, target, exec->vtx.bufferobj);
      exec->vtx.buffer_map = NULL;
      exec->vtx.buffer_ptr = NULL;
      exec->vtx.max_vert = 0;
   }
a195 62
void
vbo_exec_vtx_map( struct vbo_exec_context *exec )
{
   struct gl_context *ctx = exec->ctx;
   const GLenum target = GL_ARRAY_BUFFER_ARB;
   const GLenum access = GL_READ_WRITE_ARB; /* for MapBuffer */
   const GLenum accessRange = GL_MAP_WRITE_BIT |  /* for MapBufferRange */
                              GL_MAP_INVALIDATE_RANGE_BIT |
                              GL_MAP_UNSYNCHRONIZED_BIT |
                              GL_MAP_FLUSH_EXPLICIT_BIT |
                              MESA_MAP_NOWAIT_BIT;
   const GLenum usage = GL_STREAM_DRAW_ARB;
   
   if (!_mesa_is_bufferobj(exec->vtx.bufferobj))
      return;

   if (exec->vtx.buffer_map != NULL) {
      assert(0);
      exec->vtx.buffer_map = NULL;
      exec->vtx.buffer_ptr = NULL;
   }

   if (VBO_VERT_BUFFER_SIZE > exec->vtx.buffer_used + 1024 &&
       ctx->Driver.MapBufferRange) {
      exec->vtx.buffer_map = 
         (GLfloat *)ctx->Driver.MapBufferRange(ctx, 
                                               target, 
                                               exec->vtx.buffer_used,
                                               (VBO_VERT_BUFFER_SIZE - 
                                                exec->vtx.buffer_used),
                                               accessRange,
                                               exec->vtx.bufferobj);
      exec->vtx.buffer_ptr = exec->vtx.buffer_map;
   }
   
   if (!exec->vtx.buffer_map) {
      exec->vtx.buffer_used = 0;

      ctx->Driver.BufferData(ctx, target, 
                             VBO_VERT_BUFFER_SIZE, 
                             NULL, usage, exec->vtx.bufferobj);


      if (ctx->Driver.MapBufferRange)
         exec->vtx.buffer_map = 
            (GLfloat *)ctx->Driver.MapBufferRange(ctx, target,
                                                  0, VBO_VERT_BUFFER_SIZE,
                                                  accessRange,
                                                  exec->vtx.bufferobj);
      if (!exec->vtx.buffer_map)
         exec->vtx.buffer_map =
            (GLfloat *)ctx->Driver.MapBuffer(ctx, target, access, exec->vtx.bufferobj);
      assert(exec->vtx.buffer_map);
      exec->vtx.buffer_ptr = exec->vtx.buffer_map;
   }

   if (0)
      printf("map %d..\n", exec->vtx.buffer_used);
}



d199 1
a199 2
void
vbo_exec_vtx_flush( struct vbo_exec_context *exec, GLboolean unmap )
d204 1
d211 2
a212 5
	 struct gl_context *ctx = exec->ctx;
	 
	 /* Before the update_state() as this may raise _NEW_ARRAY
          * from _mesa_set_varying_vp_inputs().
	  */
a214 11
         if (ctx->NewState)
            _mesa_update_state( ctx );

         if (_mesa_is_bufferobj(exec->vtx.bufferobj)) {
            vbo_exec_vtx_unmap( exec );
         }

         if (0)
            printf("%s %d %d\n", __FUNCTION__, exec->vtx.prim_count,
		   exec->vtx.vert_count);

a219 1
				       GL_TRUE,
a221 6

	 /* If using a real VBO, get new storage -- unless asked not to.
          */
         if (_mesa_is_bufferobj(exec->vtx.bufferobj) && !unmap) {
            vbo_exec_vtx_map( exec );
         }
a224 16
   /* May have to unmap explicitly if we didn't draw:
    */
   if (unmap && 
       _mesa_is_bufferobj(exec->vtx.bufferobj) &&
       exec->vtx.buffer_map) {
      vbo_exec_vtx_unmap( exec );
   }


   if (unmap || exec->vtx.vertex_size == 0)
      exec->vtx.max_vert = 0;
   else
      exec->vtx.max_vert = ((VBO_VERT_BUFFER_SIZE - exec->vtx.buffer_used) / 
                            (exec->vtx.vertex_size * sizeof(GLfloat)));

   exec->vtx.buffer_ptr = exec->vtx.buffer_map;
d227 1
a228 3


#endif /* FEATURE_beginend */
@


1.1.1.3
log
@Import Mesa 9.2.0
@
text
@d3 1
d20 3
a22 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
a30 1
#include "main/context.h"
a32 1
#include "main/vtxfmt.h"
d35 3
a37 1
#include "vbo_noop.h"
d165 1
a165 1
   GLbitfield64 varying_inputs = 0x0;
d172 2
a173 2
      for (attr = 0; attr < VERT_ATTRIB_FF_MAX; attr++) {
         exec->vtx.inputs[attr] = &vbo->currval[VBO_ATTRIB_POS+attr];
d176 2
a177 3
         ASSERT(VERT_ATTRIB_GENERIC(attr) < Elements(exec->vtx.inputs));
         exec->vtx.inputs[VERT_ATTRIB_GENERIC(attr)] =
            &vbo->currval[VBO_ATTRIB_MAT_FRONT_AMBIENT+attr];
d181 1
d183 8
a190 7
      for (attr = 0; attr < VERT_ATTRIB_FF_MAX; attr++) {
         exec->vtx.inputs[attr] = &vbo->currval[VBO_ATTRIB_POS+attr];
      }
      for (attr = 0; attr < VERT_ATTRIB_GENERIC_MAX; attr++) {
         ASSERT(VERT_ATTRIB_GENERIC(attr) < Elements(exec->vtx.inputs));
         exec->vtx.inputs[VERT_ATTRIB_GENERIC(attr)] =
            &vbo->currval[VBO_ATTRIB_GENERIC0+attr];
d200 3
a202 3
         exec->vtx.inputs[VERT_ATTRIB_GENERIC0] = exec->vtx.inputs[0];
         exec->vtx.attrsz[VERT_ATTRIB_GENERIC0] = exec->vtx.attrsz[0];
         exec->vtx.attrptr[VERT_ATTRIB_GENERIC0] = exec->vtx.attrptr[0];
d210 3
d238 1
a238 3
	 arrays[attr].Type = exec->vtx.attrtype[src];
	 arrays[attr].Integer =
               vbo_attrtype_to_integer_flag(exec->vtx.attrtype[src]);
a240 1
         arrays[attr]._ElementSize = arrays[attr].Size * sizeof(GLfloat);
d246 1
a246 1
         varying_inputs |= VERT_BIT(attr);
a250 1
   ctx->NewDriverState |= ctx->DriverFlags.NewArray;
a253 3
/**
 * Unmap the VBO.  This is called before drawing.
 */
d257 2
d267 2
a268 1
            ctx->Driver.FlushMappedBufferRange(ctx, offset, length,
d278 1
a278 1
      ctx->Driver.UnmapBuffer(ctx, exec->vtx.bufferobj);
a285 3
/**
 * Map the vertex buffer to begin storing glVertex, glColor, etc data.
 */
d290 2
d302 5
a306 2
   assert(!exec->vtx.buffer_map);
   assert(!exec->vtx.buffer_ptr);
d308 11
a318 15
   if (VBO_VERT_BUFFER_SIZE > exec->vtx.buffer_used + 1024) {
      /* The VBO exists and there's room for more */
      if (exec->vtx.bufferobj->Size > 0) {
         exec->vtx.buffer_map =
            (GLfloat *)ctx->Driver.MapBufferRange(ctx, 
                                                  exec->vtx.buffer_used,
                                                  (VBO_VERT_BUFFER_SIZE - 
                                                   exec->vtx.buffer_used),
                                                  accessRange,
                                                  exec->vtx.bufferobj);
         exec->vtx.buffer_ptr = exec->vtx.buffer_map;
      }
      else {
         exec->vtx.buffer_ptr = exec->vtx.buffer_map = NULL;
      }
a321 1
      /* Need to allocate a new VBO */
d324 8
a331 6
      if (ctx->Driver.BufferData(ctx, GL_ARRAY_BUFFER_ARB,
                                  VBO_VERT_BUFFER_SIZE, 
                                  NULL, usage, exec->vtx.bufferobj)) {
         /* buffer allocation worked, now map the buffer */
         exec->vtx.buffer_map =
            (GLfloat *)ctx->Driver.MapBufferRange(ctx,
d335 5
a339 21
      }
      else {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "VBO allocation");
         exec->vtx.buffer_map = NULL;
      }
   }

   exec->vtx.buffer_ptr = exec->vtx.buffer_map;

   if (!exec->vtx.buffer_map) {
      /* out of memory */
      _mesa_install_exec_vtxfmt( ctx, &exec->vtxfmt_noop );
   }
   else {
      if (_mesa_using_noop_vtxfmt(ctx->Exec)) {
         /* The no-op functions are installed so switch back to regular
          * functions.  We do this test just to avoid frequent and needless
          * calls to _mesa_install_exec_vtxfmt().
          */
         _mesa_install_exec_vtxfmt(ctx, &exec->vtxfmt);
      }
a349 1
 * \param keep_unmapped  if true, leave the VBO unmapped when we're done.
d352 1
a352 1
vbo_exec_vtx_flush(struct vbo_exec_context *exec, GLboolean keepUnmapped)
d365 1
a365 1
	 /* Before the update_state() as this may raise _NEW_VARYING_VP_INPUTS
d382 2
a383 1
				       exec->vtx.prim,
d388 1
a388 2
				       exec->vtx.vert_count - 1,
				       NULL);
d392 1
a392 1
         if (_mesa_is_bufferobj(exec->vtx.bufferobj) && !keepUnmapped) {
d400 1
a400 1
   if (keepUnmapped &&
d406 2
a407 1
   if (keepUnmapped || exec->vtx.vertex_size == 0)
d417 3
@


1.1.1.4
log
@Import Mesa 10.2.3
@
text
@d25 1
a25 1
 *    Keith Whitwell <keithw@@vmware.com>
d223 1
a223 1
            assert(exec->vtx.bufferobj->Mappings[MAP_INTERNAL].Pointer);
d225 1
a225 2
            arrays[attr].Ptr = (GLubyte *)
               exec->vtx.bufferobj->Mappings[MAP_INTERNAL].Offset + offset;
d264 2
a265 4
         GLintptr offset = exec->vtx.buffer_used -
                           exec->vtx.bufferobj->Mappings[MAP_INTERNAL].Offset;
         GLsizeiptr length = (exec->vtx.buffer_ptr - exec->vtx.buffer_map) *
                             sizeof(float);
d269 1
a269 2
                                               exec->vtx.bufferobj,
                                               MAP_INTERNAL);
d278 1
a278 1
      ctx->Driver.UnmapBuffer(ctx, exec->vtx.bufferobj, MAP_INTERNAL);
d315 1
a315 2
                                                  exec->vtx.bufferobj,
                                                  MAP_INTERNAL);
d328 2
a329 6
                                 VBO_VERT_BUFFER_SIZE,
                                 NULL, usage,
                                 GL_MAP_WRITE_BIT |
                                 GL_DYNAMIC_STORAGE_BIT |
                                 GL_CLIENT_STORAGE_BIT,
                                 exec->vtx.bufferobj)) {
d335 1
a335 2
                                                  exec->vtx.bufferobj,
                                                  MAP_INTERNAL);
d406 1
a406 1
				       NULL, NULL);
@


1.1.1.5
log
@Import Mesa 10.4.3
@
text
@d162 1
d244 1
@


1.1.1.6
log
@Import Mesa 10.2.9
@
text
@a161 1
   const GLuint count = exec->vtx.vert_count;
a242 1
	 arrays[attr]._MaxElement = count; /* ??? */
@


