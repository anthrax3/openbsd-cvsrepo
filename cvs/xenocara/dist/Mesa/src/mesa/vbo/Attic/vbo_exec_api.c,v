head	1.12;
access;
symbols
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	v10_2_9:1.1.1.6
	v10_4_3:1.1.1.5
	v10_2_7:1.1.1.4
	OPENBSD_5_6:1.9.0.2
	OPENBSD_5_6_BASE:1.9
	v10_2_3:1.1.1.4
	OPENBSD_5_5:1.8.0.2
	OPENBSD_5_5_BASE:1.8
	v9_2_5:1.1.1.3
	v9_2_3:1.1.1.3
	v9_2_2:1.1.1.3
	v9_2_1:1.1.1.3
	v9_2_0:1.1.1.3
	OPENBSD_5_4:1.7.0.4
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.6.0.4
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	v7_10_3:1.1.1.2
	OPENBSD_5_0:1.5.0.6
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.2
	v7_0_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2015.12.23.05.17.55;	author jsg;	state dead;
branches;
next	1.11;
commitid	TnlogFl9nOv2eaRf;

1.11
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.10;
commitid	4ry2gvZGMXkCUD2n;

1.10
date	2015.01.25.14.41.22;	author jsg;	state Exp;
branches;
next	1.9;
commitid	mcxB0JvoI9gTDYXU;

1.9
date	2014.07.09.21.09.01;	author jsg;	state Exp;
branches;
next	1.8;
commitid	WPD6rgPryPkvXOr9;

1.8
date	2013.09.05.14.06.58;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2012.08.17.13.58.20;	author mpi;	state Exp;
branches;
next	1.6;

1.6
date	2011.10.23.13.37.46;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.05.22.20.06.37;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.05.17.20.26.43;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.14.58.23;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.05.31.16.36.49;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.24.17.32.25;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.11.24.17.32.25;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2011.10.23.13.29.50;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2013.09.05.13.17.44;	author jsg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.07.09.20.35.14;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.5
date	2015.01.25.14.13.37;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.6
date	2015.02.20.22.50.42;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.12
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************

Copyright 2002-2008 VMware, Inc.

All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
on the rights to use, copy, modify, merge, publish, distribute, sub
license, and/or sell copies of the Software, and to permit persons to whom
the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice (including the next
paragraph) shall be included in all copies or substantial portions of the
Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
VMWARE AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
USE OR OTHER DEALINGS IN THE SOFTWARE.

**************************************************************************/

/*
 * Authors:
 *   Keith Whitwell <keithw@@vmware.com>
 */

#include "main/glheader.h"
#include "main/bufferobj.h"
#include "main/context.h"
#include "main/macros.h"
#include "main/vtxfmt.h"
#include "main/dlist.h"
#include "main/eval.h"
#include "main/state.h"
#include "main/light.h"
#include "main/api_arrayelt.h"
#include "main/api_validate.h"
#include "main/dispatch.h"

#include "vbo_context.h"
#include "vbo_noop.h"


#ifdef ERROR
#undef ERROR
#endif


/** ID/name for immediate-mode VBO */
#define IMM_BUFFER_NAME 0xaabbccdd


static void reset_attrfv( struct vbo_exec_context *exec );


/**
 * Close off the last primitive, execute the buffer, restart the
 * primitive.  
 */
static void vbo_exec_wrap_buffers( struct vbo_exec_context *exec )
{
   if (exec->vtx.prim_count == 0) {
      exec->vtx.copied.nr = 0;
      exec->vtx.vert_count = 0;
      exec->vtx.buffer_ptr = exec->vtx.buffer_map;
   }
   else {
      GLuint last_begin = exec->vtx.prim[exec->vtx.prim_count-1].begin;
      GLuint last_count;

      if (_mesa_inside_begin_end(exec->ctx)) {
	 GLint i = exec->vtx.prim_count - 1;
	 assert(i >= 0);
	 exec->vtx.prim[i].count = (exec->vtx.vert_count - 
				    exec->vtx.prim[i].start);
      }

      last_count = exec->vtx.prim[exec->vtx.prim_count-1].count;

      /* Execute the buffer and save copied vertices.
       */
      if (exec->vtx.vert_count)
	 vbo_exec_vtx_flush( exec, GL_FALSE );
      else {
	 exec->vtx.prim_count = 0;
	 exec->vtx.copied.nr = 0;
      }

      /* Emit a glBegin to start the new list.
       */
      assert(exec->vtx.prim_count == 0);

      if (_mesa_inside_begin_end(exec->ctx)) {
	 exec->vtx.prim[0].mode = exec->ctx->Driver.CurrentExecPrimitive;
	 exec->vtx.prim[0].start = 0;
	 exec->vtx.prim[0].count = 0;
	 exec->vtx.prim_count++;
      
	 if (exec->vtx.copied.nr == last_count)
	    exec->vtx.prim[0].begin = last_begin;
      }
   }
}


/**
 * Deal with buffer wrapping where provoked by the vertex buffer
 * filling up, as opposed to upgrade_vertex().
 */
void vbo_exec_vtx_wrap( struct vbo_exec_context *exec )
{
   GLfloat *data = exec->vtx.copied.buffer;
   GLuint i;

   /* Run pipeline on current vertices, copy wrapped vertices
    * to exec->vtx.copied.
    */
   vbo_exec_wrap_buffers( exec );
   
   if (!exec->vtx.buffer_ptr) {
      /* probably ran out of memory earlier when allocating the VBO */
      return;
   }

   /* Copy stored stored vertices to start of new list. 
    */
   assert(exec->vtx.max_vert - exec->vtx.vert_count > exec->vtx.copied.nr);

   for (i = 0 ; i < exec->vtx.copied.nr ; i++) {
      memcpy( exec->vtx.buffer_ptr, data, 
	      exec->vtx.vertex_size * sizeof(GLfloat));
      exec->vtx.buffer_ptr += exec->vtx.vertex_size;
      data += exec->vtx.vertex_size;
      exec->vtx.vert_count++;
   }

   exec->vtx.copied.nr = 0;
}


/**
 * Copy the active vertex's values to the ctx->Current fields.
 */
static void vbo_exec_copy_to_current( struct vbo_exec_context *exec )
{
   struct gl_context *ctx = exec->ctx;
   struct vbo_context *vbo = vbo_context(ctx);
   GLuint i;

   for (i = VBO_ATTRIB_POS+1 ; i < VBO_ATTRIB_MAX ; i++) {
      if (exec->vtx.attrsz[i]) {
         /* Note: the exec->vtx.current[i] pointers point into the
          * ctx->Current.Attrib and ctx->Light.Material.Attrib arrays.
          */
	 GLfloat *current = (GLfloat *)vbo->currval[i].Ptr;
         GLfloat tmp[4];

         COPY_CLEAN_4V_TYPE_AS_FLOAT(tmp,
                                     exec->vtx.attrsz[i],
                                     exec->vtx.attrptr[i],
                                     exec->vtx.attrtype[i]);
         
         if (exec->vtx.attrtype[i] != vbo->currval[i].Type ||
             memcmp(current, tmp, sizeof(tmp)) != 0) {
            memcpy(current, tmp, sizeof(tmp));
	 
            /* Given that we explicitly state size here, there is no need
             * for the COPY_CLEAN above, could just copy 16 bytes and be
             * done.  The only problem is when Mesa accesses ctx->Current
             * directly.
             */
            vbo->currval[i].Size = exec->vtx.attrsz[i];
            vbo->currval[i]._ElementSize = vbo->currval[i].Size * sizeof(GLfloat);
            vbo->currval[i].Type = exec->vtx.attrtype[i];
            vbo->currval[i].Integer =
                  vbo_attrtype_to_integer_flag(exec->vtx.attrtype[i]);

            /* This triggers rather too much recalculation of Mesa state
             * that doesn't get used (eg light positions).
             */
            if (i >= VBO_ATTRIB_MAT_FRONT_AMBIENT &&
                i <= VBO_ATTRIB_MAT_BACK_INDEXES)
               ctx->NewState |= _NEW_LIGHT;
            
            ctx->NewState |= _NEW_CURRENT_ATTRIB;
         }
      }
   }

   /* Colormaterial -- this kindof sucks.
    */
   if (ctx->Light.ColorMaterialEnabled &&
       exec->vtx.attrsz[VBO_ATTRIB_COLOR0]) {
      _mesa_update_color_material(ctx, 
				  ctx->Current.Attrib[VBO_ATTRIB_COLOR0]);
   }
}


/**
 * Copy current vertex attribute values into the current vertex.
 */
static void
vbo_exec_copy_from_current(struct vbo_exec_context *exec)
{
   struct gl_context *ctx = exec->ctx;
   struct vbo_context *vbo = vbo_context(ctx);
   GLint i;

   for (i = VBO_ATTRIB_POS + 1; i < VBO_ATTRIB_MAX; i++) {
      const GLfloat *current = (GLfloat *) vbo->currval[i].Ptr;
      switch (exec->vtx.attrsz[i]) {
      case 4: exec->vtx.attrptr[i][3] = current[3];
      case 3: exec->vtx.attrptr[i][2] = current[2];
      case 2: exec->vtx.attrptr[i][1] = current[1];
      case 1: exec->vtx.attrptr[i][0] = current[0];
	 break;
      }
   }
}


/**
 * Flush existing data, set new attrib size, replay copied vertices.
 * This is called when we transition from a small vertex attribute size
 * to a larger one.  Ex: glTexCoord2f -> glTexCoord4f.
 * We need to go back over the previous 2-component texcoords and insert
 * zero and one values.
 */ 
static void
vbo_exec_wrap_upgrade_vertex(struct vbo_exec_context *exec,
                             GLuint attr, GLuint newSize )
{
   struct gl_context *ctx = exec->ctx;
   struct vbo_context *vbo = vbo_context(ctx);
   const GLint lastcount = exec->vtx.vert_count;
   GLfloat *old_attrptr[VBO_ATTRIB_MAX];
   const GLuint old_vtx_size = exec->vtx.vertex_size; /* floats per vertex */
   const GLuint oldSize = exec->vtx.attrsz[attr];
   GLuint i;

   /* Run pipeline on current vertices, copy wrapped vertices
    * to exec->vtx.copied.
    */
   vbo_exec_wrap_buffers( exec );

   if (unlikely(exec->vtx.copied.nr)) {
      /* We're in the middle of a primitive, keep the old vertex
       * format around to be able to translate the copied vertices to
       * the new format.
       */
      memcpy(old_attrptr, exec->vtx.attrptr, sizeof(old_attrptr));
   }

   if (unlikely(oldSize)) {
      /* Do a COPY_TO_CURRENT to ensure back-copying works for the
       * case when the attribute already exists in the vertex and is
       * having its size increased.
       */
      vbo_exec_copy_to_current( exec );
   }

   /* Heuristic: Attempt to isolate attributes received outside
    * begin/end so that they don't bloat the vertices.
    */
   if (!_mesa_inside_begin_end(ctx) &&
       !oldSize && lastcount > 8 && exec->vtx.vertex_size) {
      vbo_exec_copy_to_current( exec );
      reset_attrfv( exec );
   }

   /* Fix up sizes:
    */
   exec->vtx.attrsz[attr] = newSize;
   exec->vtx.vertex_size += newSize - oldSize;
   exec->vtx.max_vert = ((VBO_VERT_BUFFER_SIZE - exec->vtx.buffer_used) / 
                         (exec->vtx.vertex_size * sizeof(GLfloat)));
   exec->vtx.vert_count = 0;
   exec->vtx.buffer_ptr = exec->vtx.buffer_map;

   if (unlikely(oldSize)) {
      /* Size changed, recalculate all the attrptr[] values
       */
      GLfloat *tmp = exec->vtx.vertex;

      for (i = 0 ; i < VBO_ATTRIB_MAX ; i++) {
	 if (exec->vtx.attrsz[i]) {
	    exec->vtx.attrptr[i] = tmp;
	    tmp += exec->vtx.attrsz[i];
	 }
	 else
	    exec->vtx.attrptr[i] = NULL; /* will not be dereferenced */
      }

      /* Copy from current to repopulate the vertex with correct
       * values.
       */
      vbo_exec_copy_from_current( exec );
   }
   else {
      /* Just have to append the new attribute at the end */
      exec->vtx.attrptr[attr] = exec->vtx.vertex +
	 exec->vtx.vertex_size - newSize;
   }

   /* Replay stored vertices to translate them
    * to new format here.
    *
    * -- No need to replay - just copy piecewise
    */
   if (unlikely(exec->vtx.copied.nr)) {
      GLfloat *data = exec->vtx.copied.buffer;
      GLfloat *dest = exec->vtx.buffer_ptr;
      GLuint j;

      assert(exec->vtx.buffer_ptr == exec->vtx.buffer_map);

      for (i = 0 ; i < exec->vtx.copied.nr ; i++) {
	 for (j = 0 ; j < VBO_ATTRIB_MAX ; j++) {
	    GLuint sz = exec->vtx.attrsz[j];

	    if (sz) {
	       GLint old_offset = old_attrptr[j] - exec->vtx.vertex;
	       GLint new_offset = exec->vtx.attrptr[j] - exec->vtx.vertex;

	       if (j == attr) {
		  if (oldSize) {
		     GLfloat tmp[4];
                     COPY_CLEAN_4V_TYPE_AS_FLOAT(tmp, oldSize,
                                                 data + old_offset,
                                                 exec->vtx.attrtype[j]);
		     COPY_SZ_4V(dest + new_offset, newSize, tmp);
		  } else {
		     GLfloat *current = (GLfloat *)vbo->currval[j].Ptr;
		     COPY_SZ_4V(dest + new_offset, sz, current);
		  }
	       }
	       else {
		  COPY_SZ_4V(dest + new_offset, sz, data + old_offset);
	       }
	    }
	 }

	 data += old_vtx_size;
	 dest += exec->vtx.vertex_size;
      }

      exec->vtx.buffer_ptr = dest;
      exec->vtx.vert_count += exec->vtx.copied.nr;
      exec->vtx.copied.nr = 0;
   }
}


/**
 * This is when a vertex attribute transitions to a different size.
 * For example, we saw a bunch of glTexCoord2f() calls and now we got a
 * glTexCoord4f() call.  We promote the array from size=2 to size=4.
 */
static void
vbo_exec_fixup_vertex(struct gl_context *ctx, GLuint attr, GLuint newSize)
{
   struct vbo_exec_context *exec = &vbo_context(ctx)->exec;

   if (newSize > exec->vtx.attrsz[attr]) {
      /* New size is larger.  Need to flush existing vertices and get
       * an enlarged vertex format.
       */
      vbo_exec_wrap_upgrade_vertex( exec, attr, newSize );
   }
   else if (newSize < exec->vtx.active_sz[attr]) {
      GLuint i;
      const GLfloat *id =
            vbo_get_default_vals_as_float(exec->vtx.attrtype[attr]);

      /* New size is smaller - just need to fill in some
       * zeros.  Don't need to flush or wrap.
       */
      for (i = newSize; i <= exec->vtx.attrsz[attr]; i++)
	 exec->vtx.attrptr[attr][i-1] = id[i-1];
   }

   exec->vtx.active_sz[attr] = newSize;

   /* Does setting NeedFlush belong here?  Necessitates resetting
    * vtxfmt on each flush (otherwise flags won't get reset
    * afterwards).
    */
   if (attr == 0) 
      ctx->Driver.NeedFlush |= FLUSH_STORED_VERTICES;
}


/**
 * This macro is used to implement all the glVertex, glColor, glTexCoord,
 * glVertexAttrib, etc functions.
 */
#define ATTR( A, N, T, V0, V1, V2, V3 )					\
do {									\
   struct vbo_exec_context *exec = &vbo_context(ctx)->exec;		\
									\
   if (unlikely(!(ctx->Driver.NeedFlush & FLUSH_UPDATE_CURRENT)))	\
      ctx->Driver.BeginVertices( ctx );					\
   									\
   if (unlikely(exec->vtx.active_sz[A] != N))				\
      vbo_exec_fixup_vertex(ctx, A, N);					\
   									\
   {									\
      GLfloat *dest = exec->vtx.attrptr[A];				\
      if (N>0) dest[0] = V0;						\
      if (N>1) dest[1] = V1;						\
      if (N>2) dest[2] = V2;						\
      if (N>3) dest[3] = V3;						\
      exec->vtx.attrtype[A] = T;                                        \
   }									\
									\
   if ((A) == 0) {							\
      /* This is a glVertex call */					\
      GLuint i;								\
									\
      for (i = 0; i < exec->vtx.vertex_size; i++)			\
	 exec->vtx.buffer_ptr[i] = exec->vtx.vertex[i];			\
									\
      exec->vtx.buffer_ptr += exec->vtx.vertex_size;			\
									\
      /* Set FLUSH_STORED_VERTICES to indicate that there's now */	\
      /* something to draw (not just updating a color or texcoord).*/	\
      ctx->Driver.NeedFlush |= FLUSH_STORED_VERTICES;			\
									\
      if (++exec->vtx.vert_count >= exec->vtx.max_vert)			\
	 vbo_exec_vtx_wrap( exec );					\
   }									\
} while (0)


#define ERROR(err) _mesa_error( ctx, err, __FUNCTION__ )
#define TAG(x) vbo_##x

#include "vbo_attrib_tmp.h"



/**
 * Execute a glMaterial call.  Note that if GL_COLOR_MATERIAL is enabled,
 * this may be a (partial) no-op.
 */
static void GLAPIENTRY
vbo_Materialfv(GLenum face, GLenum pname, const GLfloat *params)
{
   GLbitfield updateMats;
   GET_CURRENT_CONTEXT(ctx);

   /* This function should be a no-op when it tries to update material
    * attributes which are currently tracking glColor via glColorMaterial.
    * The updateMats var will be a mask of the MAT_BIT_FRONT/BACK_x bits
    * indicating which material attributes can actually be updated below.
    */
   if (ctx->Light.ColorMaterialEnabled) {
      updateMats = ~ctx->Light._ColorMaterialBitmask;
   }
   else {
      /* GL_COLOR_MATERIAL is disabled so don't skip any material updates */
      updateMats = ALL_MATERIAL_BITS;
   }

   if (ctx->API == API_OPENGL_COMPAT && face == GL_FRONT) {
      updateMats &= FRONT_MATERIAL_BITS;
   }
   else if (ctx->API == API_OPENGL_COMPAT && face == GL_BACK) {
      updateMats &= BACK_MATERIAL_BITS;
   }
   else if (face != GL_FRONT_AND_BACK) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glMaterial(invalid face)");
      return;
   }

   switch (pname) {
   case GL_EMISSION:
      if (updateMats & MAT_BIT_FRONT_EMISSION)
         MAT_ATTR(VBO_ATTRIB_MAT_FRONT_EMISSION, 4, params);
      if (updateMats & MAT_BIT_BACK_EMISSION)
         MAT_ATTR(VBO_ATTRIB_MAT_BACK_EMISSION, 4, params);
      break;
   case GL_AMBIENT:
      if (updateMats & MAT_BIT_FRONT_AMBIENT)
         MAT_ATTR(VBO_ATTRIB_MAT_FRONT_AMBIENT, 4, params);
      if (updateMats & MAT_BIT_BACK_AMBIENT)
         MAT_ATTR(VBO_ATTRIB_MAT_BACK_AMBIENT, 4, params);
      break;
   case GL_DIFFUSE:
      if (updateMats & MAT_BIT_FRONT_DIFFUSE)
         MAT_ATTR(VBO_ATTRIB_MAT_FRONT_DIFFUSE, 4, params);
      if (updateMats & MAT_BIT_BACK_DIFFUSE)
         MAT_ATTR(VBO_ATTRIB_MAT_BACK_DIFFUSE, 4, params);
      break;
   case GL_SPECULAR:
      if (updateMats & MAT_BIT_FRONT_SPECULAR)
         MAT_ATTR(VBO_ATTRIB_MAT_FRONT_SPECULAR, 4, params);
      if (updateMats & MAT_BIT_BACK_SPECULAR)
         MAT_ATTR(VBO_ATTRIB_MAT_BACK_SPECULAR, 4, params);
      break;
   case GL_SHININESS:
      if (*params < 0 || *params > ctx->Const.MaxShininess) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glMaterial(invalid shininess: %f out range [0, %f])",
		     *params, ctx->Const.MaxShininess);
         return;
      }
      if (updateMats & MAT_BIT_FRONT_SHININESS)
         MAT_ATTR(VBO_ATTRIB_MAT_FRONT_SHININESS, 1, params);
      if (updateMats & MAT_BIT_BACK_SHININESS)
         MAT_ATTR(VBO_ATTRIB_MAT_BACK_SHININESS, 1, params);
      break;
   case GL_COLOR_INDEXES:
      if (ctx->API != API_OPENGL_COMPAT) {
         _mesa_error(ctx, GL_INVALID_ENUM, "glMaterialfv(pname)");
         return;
      }
      if (updateMats & MAT_BIT_FRONT_INDEXES)
         MAT_ATTR(VBO_ATTRIB_MAT_FRONT_INDEXES, 3, params);
      if (updateMats & MAT_BIT_BACK_INDEXES)
         MAT_ATTR(VBO_ATTRIB_MAT_BACK_INDEXES, 3, params);
      break;
   case GL_AMBIENT_AND_DIFFUSE:
      if (updateMats & MAT_BIT_FRONT_AMBIENT)
         MAT_ATTR(VBO_ATTRIB_MAT_FRONT_AMBIENT, 4, params);
      if (updateMats & MAT_BIT_FRONT_DIFFUSE)
         MAT_ATTR(VBO_ATTRIB_MAT_FRONT_DIFFUSE, 4, params);
      if (updateMats & MAT_BIT_BACK_AMBIENT)
         MAT_ATTR(VBO_ATTRIB_MAT_BACK_AMBIENT, 4, params);
      if (updateMats & MAT_BIT_BACK_DIFFUSE)
         MAT_ATTR(VBO_ATTRIB_MAT_BACK_DIFFUSE, 4, params);
      break;
   default:
      _mesa_error(ctx, GL_INVALID_ENUM, "glMaterialfv(pname)");
      return;
   }
}


/**
 * Flush (draw) vertices.
 * \param  unmap - leave VBO unmapped after flushing?
 */
static void
vbo_exec_FlushVertices_internal(struct vbo_exec_context *exec, GLboolean unmap)
{
   if (exec->vtx.vert_count || unmap) {
      vbo_exec_vtx_flush( exec, unmap );
   }

   if (exec->vtx.vertex_size) {
      vbo_exec_copy_to_current( exec );
      reset_attrfv( exec );
   }
}


static void GLAPIENTRY vbo_exec_EvalCoord1f( GLfloat u )
{
   GET_CURRENT_CONTEXT( ctx );
   struct vbo_exec_context *exec = &vbo_context(ctx)->exec;

   {
      GLint i;
      if (exec->eval.recalculate_maps) 
	 vbo_exec_eval_update( exec );

      for (i = 0; i <= VBO_ATTRIB_TEX7; i++) {
	 if (exec->eval.map1[i].map) 
	    if (exec->vtx.active_sz[i] != exec->eval.map1[i].sz)
	       vbo_exec_fixup_vertex( ctx, i, exec->eval.map1[i].sz );
      }
   }


   memcpy( exec->vtx.copied.buffer, exec->vtx.vertex, 
           exec->vtx.vertex_size * sizeof(GLfloat));

   vbo_exec_do_EvalCoord1f( exec, u );

   memcpy( exec->vtx.vertex, exec->vtx.copied.buffer,
           exec->vtx.vertex_size * sizeof(GLfloat));
}

static void GLAPIENTRY vbo_exec_EvalCoord2f( GLfloat u, GLfloat v )
{
   GET_CURRENT_CONTEXT( ctx );
   struct vbo_exec_context *exec = &vbo_context(ctx)->exec;

   {
      GLint i;
      if (exec->eval.recalculate_maps) 
	 vbo_exec_eval_update( exec );

      for (i = 0; i <= VBO_ATTRIB_TEX7; i++) {
	 if (exec->eval.map2[i].map) 
	    if (exec->vtx.active_sz[i] != exec->eval.map2[i].sz)
	       vbo_exec_fixup_vertex( ctx, i, exec->eval.map2[i].sz );
      }

      if (ctx->Eval.AutoNormal) 
	 if (exec->vtx.active_sz[VBO_ATTRIB_NORMAL] != 3)
	    vbo_exec_fixup_vertex( ctx, VBO_ATTRIB_NORMAL, 3 );
   }

   memcpy( exec->vtx.copied.buffer, exec->vtx.vertex, 
           exec->vtx.vertex_size * sizeof(GLfloat));

   vbo_exec_do_EvalCoord2f( exec, u, v );

   memcpy( exec->vtx.vertex, exec->vtx.copied.buffer, 
           exec->vtx.vertex_size * sizeof(GLfloat));
}

static void GLAPIENTRY vbo_exec_EvalCoord1fv( const GLfloat *u )
{
   vbo_exec_EvalCoord1f( u[0] );
}

static void GLAPIENTRY vbo_exec_EvalCoord2fv( const GLfloat *u )
{
   vbo_exec_EvalCoord2f( u[0], u[1] );
}

static void GLAPIENTRY vbo_exec_EvalPoint1( GLint i )
{
   GET_CURRENT_CONTEXT( ctx );
   GLfloat du = ((ctx->Eval.MapGrid1u2 - ctx->Eval.MapGrid1u1) /
		 (GLfloat) ctx->Eval.MapGrid1un);
   GLfloat u = i * du + ctx->Eval.MapGrid1u1;

   vbo_exec_EvalCoord1f( u );
}


static void GLAPIENTRY vbo_exec_EvalPoint2( GLint i, GLint j )
{
   GET_CURRENT_CONTEXT( ctx );
   GLfloat du = ((ctx->Eval.MapGrid2u2 - ctx->Eval.MapGrid2u1) / 
		 (GLfloat) ctx->Eval.MapGrid2un);
   GLfloat dv = ((ctx->Eval.MapGrid2v2 - ctx->Eval.MapGrid2v1) / 
		 (GLfloat) ctx->Eval.MapGrid2vn);
   GLfloat u = i * du + ctx->Eval.MapGrid2u1;
   GLfloat v = j * dv + ctx->Eval.MapGrid2v1;

   vbo_exec_EvalCoord2f( u, v );
}


/**
 * Called via glBegin.
 */
static void GLAPIENTRY vbo_exec_Begin( GLenum mode )
{
   GET_CURRENT_CONTEXT( ctx ); 
   struct vbo_exec_context *exec = &vbo_context(ctx)->exec;
   int i;

   if (_mesa_inside_begin_end(ctx)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glBegin");
      return;
   }

   if (!_mesa_valid_prim_mode(ctx, mode, "glBegin")) {
      return;
   }

   vbo_draw_method(vbo_context(ctx), DRAW_BEGIN_END);

   if (ctx->NewState) {
      _mesa_update_state( ctx );

      CALL_Begin(ctx->Exec, (mode));
      return;
   }

   if (!_mesa_valid_to_render(ctx, "glBegin")) {
      return;
   }

   /* Heuristic: attempt to isolate attributes occuring outside
    * begin/end pairs.
    */
   if (exec->vtx.vertex_size && !exec->vtx.attrsz[0])
      vbo_exec_FlushVertices_internal(exec, GL_FALSE);

   i = exec->vtx.prim_count++;
   exec->vtx.prim[i].mode = mode;
   exec->vtx.prim[i].begin = 1;
   exec->vtx.prim[i].end = 0;
   exec->vtx.prim[i].indexed = 0;
   exec->vtx.prim[i].weak = 0;
   exec->vtx.prim[i].pad = 0;
   exec->vtx.prim[i].start = exec->vtx.vert_count;
   exec->vtx.prim[i].count = 0;
   exec->vtx.prim[i].num_instances = 1;
   exec->vtx.prim[i].base_instance = 0;
   exec->vtx.prim[i].is_indirect = 0;

   ctx->Driver.CurrentExecPrimitive = mode;

   ctx->Exec = ctx->BeginEnd;
   /* We may have been called from a display list, in which case we should
    * leave dlist.c's dispatch table in place.
    */
   if (ctx->CurrentDispatch == ctx->OutsideBeginEnd) {
      ctx->CurrentDispatch = ctx->BeginEnd;
      _glapi_set_dispatch(ctx->CurrentDispatch);
   } else {
      assert(ctx->CurrentDispatch == ctx->Save);
   }
}


/**
 * Try to merge / concatenate the two most recent VBO primitives.
 */
static void
try_vbo_merge(struct vbo_exec_context *exec)
{
   struct _mesa_prim *cur =  &exec->vtx.prim[exec->vtx.prim_count - 1];

   assert(exec->vtx.prim_count >= 1);

   vbo_try_prim_conversion(cur);

   if (exec->vtx.prim_count >= 2) {
      struct _mesa_prim *prev = &exec->vtx.prim[exec->vtx.prim_count - 2];
      assert(prev == cur - 1);

      if (vbo_can_merge_prims(prev, cur)) {
         assert(cur->begin);
         assert(cur->end);
         assert(prev->begin);
         assert(prev->end);
         vbo_merge_prims(prev, cur);
         exec->vtx.prim_count--;  /* drop the last primitive */
      }
   }
}


/**
 * Called via glEnd.
 */
static void GLAPIENTRY vbo_exec_End( void )
{
   GET_CURRENT_CONTEXT( ctx ); 
   struct vbo_exec_context *exec = &vbo_context(ctx)->exec;

   if (!_mesa_inside_begin_end(ctx)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glEnd");
      return;
   }

   ctx->Exec = ctx->OutsideBeginEnd;
   if (ctx->CurrentDispatch == ctx->BeginEnd) {
      ctx->CurrentDispatch = ctx->OutsideBeginEnd;
      _glapi_set_dispatch(ctx->CurrentDispatch);
   }

   if (exec->vtx.prim_count > 0) {
      /* close off current primitive */
      int idx = exec->vtx.vert_count;
      int i = exec->vtx.prim_count - 1;

      exec->vtx.prim[i].end = 1;
      exec->vtx.prim[i].count = idx - exec->vtx.prim[i].start;

      try_vbo_merge(exec);
   }

   ctx->Driver.CurrentExecPrimitive = PRIM_OUTSIDE_BEGIN_END;

   if (exec->vtx.prim_count == VBO_MAX_PRIM)
      vbo_exec_vtx_flush( exec, GL_FALSE );

   if (MESA_DEBUG_FLAGS & DEBUG_ALWAYS_FLUSH) {
      _mesa_flush(ctx);
   }
}


/**
 * Called via glPrimitiveRestartNV()
 */
static void GLAPIENTRY
vbo_exec_PrimitiveRestartNV(void)
{
   GLenum curPrim;
   GET_CURRENT_CONTEXT( ctx ); 

   curPrim = ctx->Driver.CurrentExecPrimitive;

   if (curPrim == PRIM_OUTSIDE_BEGIN_END) {
      _mesa_error( ctx, GL_INVALID_OPERATION, "glPrimitiveRestartNV" );
   }
   else {
      vbo_exec_End();
      vbo_exec_Begin(curPrim);
   }
}



static void vbo_exec_vtxfmt_init( struct vbo_exec_context *exec )
{
   struct gl_context *ctx = exec->ctx;
   GLvertexformat *vfmt = &exec->vtxfmt;

   vfmt->ArrayElement = _ae_ArrayElement;

   vfmt->Begin = vbo_exec_Begin;
   vfmt->End = vbo_exec_End;
   vfmt->PrimitiveRestartNV = vbo_exec_PrimitiveRestartNV;

   vfmt->CallList = _mesa_CallList;
   vfmt->CallLists = _mesa_CallLists;

   vfmt->EvalCoord1f = vbo_exec_EvalCoord1f;
   vfmt->EvalCoord1fv = vbo_exec_EvalCoord1fv;
   vfmt->EvalCoord2f = vbo_exec_EvalCoord2f;
   vfmt->EvalCoord2fv = vbo_exec_EvalCoord2fv;
   vfmt->EvalPoint1 = vbo_exec_EvalPoint1;
   vfmt->EvalPoint2 = vbo_exec_EvalPoint2;

   /* from attrib_tmp.h:
    */
   vfmt->Color3f = vbo_Color3f;
   vfmt->Color3fv = vbo_Color3fv;
   vfmt->Color4f = vbo_Color4f;
   vfmt->Color4fv = vbo_Color4fv;
   vfmt->FogCoordfEXT = vbo_FogCoordfEXT;
   vfmt->FogCoordfvEXT = vbo_FogCoordfvEXT;
   vfmt->MultiTexCoord1fARB = vbo_MultiTexCoord1f;
   vfmt->MultiTexCoord1fvARB = vbo_MultiTexCoord1fv;
   vfmt->MultiTexCoord2fARB = vbo_MultiTexCoord2f;
   vfmt->MultiTexCoord2fvARB = vbo_MultiTexCoord2fv;
   vfmt->MultiTexCoord3fARB = vbo_MultiTexCoord3f;
   vfmt->MultiTexCoord3fvARB = vbo_MultiTexCoord3fv;
   vfmt->MultiTexCoord4fARB = vbo_MultiTexCoord4f;
   vfmt->MultiTexCoord4fvARB = vbo_MultiTexCoord4fv;
   vfmt->Normal3f = vbo_Normal3f;
   vfmt->Normal3fv = vbo_Normal3fv;
   vfmt->SecondaryColor3fEXT = vbo_SecondaryColor3fEXT;
   vfmt->SecondaryColor3fvEXT = vbo_SecondaryColor3fvEXT;
   vfmt->TexCoord1f = vbo_TexCoord1f;
   vfmt->TexCoord1fv = vbo_TexCoord1fv;
   vfmt->TexCoord2f = vbo_TexCoord2f;
   vfmt->TexCoord2fv = vbo_TexCoord2fv;
   vfmt->TexCoord3f = vbo_TexCoord3f;
   vfmt->TexCoord3fv = vbo_TexCoord3fv;
   vfmt->TexCoord4f = vbo_TexCoord4f;
   vfmt->TexCoord4fv = vbo_TexCoord4fv;
   vfmt->Vertex2f = vbo_Vertex2f;
   vfmt->Vertex2fv = vbo_Vertex2fv;
   vfmt->Vertex3f = vbo_Vertex3f;
   vfmt->Vertex3fv = vbo_Vertex3fv;
   vfmt->Vertex4f = vbo_Vertex4f;
   vfmt->Vertex4fv = vbo_Vertex4fv;
   
   if (ctx->API == API_OPENGLES2) {
      vfmt->VertexAttrib1fARB = _es_VertexAttrib1f;
      vfmt->VertexAttrib1fvARB = _es_VertexAttrib1fv;
      vfmt->VertexAttrib2fARB = _es_VertexAttrib2f;
      vfmt->VertexAttrib2fvARB = _es_VertexAttrib2fv;
      vfmt->VertexAttrib3fARB = _es_VertexAttrib3f;
      vfmt->VertexAttrib3fvARB = _es_VertexAttrib3fv;
      vfmt->VertexAttrib4fARB = _es_VertexAttrib4f;
      vfmt->VertexAttrib4fvARB = _es_VertexAttrib4fv;
   } else {
      vfmt->VertexAttrib1fARB = vbo_VertexAttrib1fARB;
      vfmt->VertexAttrib1fvARB = vbo_VertexAttrib1fvARB;
      vfmt->VertexAttrib2fARB = vbo_VertexAttrib2fARB;
      vfmt->VertexAttrib2fvARB = vbo_VertexAttrib2fvARB;
      vfmt->VertexAttrib3fARB = vbo_VertexAttrib3fARB;
      vfmt->VertexAttrib3fvARB = vbo_VertexAttrib3fvARB;
      vfmt->VertexAttrib4fARB = vbo_VertexAttrib4fARB;
      vfmt->VertexAttrib4fvARB = vbo_VertexAttrib4fvARB;
   }

   /* Note that VertexAttrib4fNV is used from dlist.c and api_arrayelt.c so
    * they can have a single entrypoint for updating any of the legacy
    * attribs.
    */
   vfmt->VertexAttrib1fNV = vbo_VertexAttrib1fNV;
   vfmt->VertexAttrib1fvNV = vbo_VertexAttrib1fvNV;
   vfmt->VertexAttrib2fNV = vbo_VertexAttrib2fNV;
   vfmt->VertexAttrib2fvNV = vbo_VertexAttrib2fvNV;
   vfmt->VertexAttrib3fNV = vbo_VertexAttrib3fNV;
   vfmt->VertexAttrib3fvNV = vbo_VertexAttrib3fvNV;
   vfmt->VertexAttrib4fNV = vbo_VertexAttrib4fNV;
   vfmt->VertexAttrib4fvNV = vbo_VertexAttrib4fvNV;

   /* integer-valued */
   vfmt->VertexAttribI1i = vbo_VertexAttribI1i;
   vfmt->VertexAttribI2i = vbo_VertexAttribI2i;
   vfmt->VertexAttribI3i = vbo_VertexAttribI3i;
   vfmt->VertexAttribI4i = vbo_VertexAttribI4i;
   vfmt->VertexAttribI2iv = vbo_VertexAttribI2iv;
   vfmt->VertexAttribI3iv = vbo_VertexAttribI3iv;
   vfmt->VertexAttribI4iv = vbo_VertexAttribI4iv;

   /* unsigned integer-valued */
   vfmt->VertexAttribI1ui = vbo_VertexAttribI1ui;
   vfmt->VertexAttribI2ui = vbo_VertexAttribI2ui;
   vfmt->VertexAttribI3ui = vbo_VertexAttribI3ui;
   vfmt->VertexAttribI4ui = vbo_VertexAttribI4ui;
   vfmt->VertexAttribI2uiv = vbo_VertexAttribI2uiv;
   vfmt->VertexAttribI3uiv = vbo_VertexAttribI3uiv;
   vfmt->VertexAttribI4uiv = vbo_VertexAttribI4uiv;

   vfmt->Materialfv = vbo_Materialfv;

   vfmt->EdgeFlag = vbo_EdgeFlag;
   vfmt->Indexf = vbo_Indexf;
   vfmt->Indexfv = vbo_Indexfv;

   /* ARB_vertex_type_2_10_10_10_rev */
   vfmt->VertexP2ui = vbo_VertexP2ui;
   vfmt->VertexP2uiv = vbo_VertexP2uiv;
   vfmt->VertexP3ui = vbo_VertexP3ui;
   vfmt->VertexP3uiv = vbo_VertexP3uiv;
   vfmt->VertexP4ui = vbo_VertexP4ui;
   vfmt->VertexP4uiv = vbo_VertexP4uiv;

   vfmt->TexCoordP1ui = vbo_TexCoordP1ui;
   vfmt->TexCoordP1uiv = vbo_TexCoordP1uiv;
   vfmt->TexCoordP2ui = vbo_TexCoordP2ui;
   vfmt->TexCoordP2uiv = vbo_TexCoordP2uiv;
   vfmt->TexCoordP3ui = vbo_TexCoordP3ui;
   vfmt->TexCoordP3uiv = vbo_TexCoordP3uiv;
   vfmt->TexCoordP4ui = vbo_TexCoordP4ui;
   vfmt->TexCoordP4uiv = vbo_TexCoordP4uiv;

   vfmt->MultiTexCoordP1ui = vbo_MultiTexCoordP1ui;
   vfmt->MultiTexCoordP1uiv = vbo_MultiTexCoordP1uiv;
   vfmt->MultiTexCoordP2ui = vbo_MultiTexCoordP2ui;
   vfmt->MultiTexCoordP2uiv = vbo_MultiTexCoordP2uiv;
   vfmt->MultiTexCoordP3ui = vbo_MultiTexCoordP3ui;
   vfmt->MultiTexCoordP3uiv = vbo_MultiTexCoordP3uiv;
   vfmt->MultiTexCoordP4ui = vbo_MultiTexCoordP4ui;
   vfmt->MultiTexCoordP4uiv = vbo_MultiTexCoordP4uiv;
   
   vfmt->NormalP3ui = vbo_NormalP3ui;
   vfmt->NormalP3uiv = vbo_NormalP3uiv;

   vfmt->ColorP3ui = vbo_ColorP3ui;
   vfmt->ColorP3uiv = vbo_ColorP3uiv;
   vfmt->ColorP4ui = vbo_ColorP4ui;
   vfmt->ColorP4uiv = vbo_ColorP4uiv;

   vfmt->SecondaryColorP3ui = vbo_SecondaryColorP3ui;
   vfmt->SecondaryColorP3uiv = vbo_SecondaryColorP3uiv;

   vfmt->VertexAttribP1ui = vbo_VertexAttribP1ui;
   vfmt->VertexAttribP1uiv = vbo_VertexAttribP1uiv;
   vfmt->VertexAttribP2ui = vbo_VertexAttribP2ui;
   vfmt->VertexAttribP2uiv = vbo_VertexAttribP2uiv;
   vfmt->VertexAttribP3ui = vbo_VertexAttribP3ui;
   vfmt->VertexAttribP3uiv = vbo_VertexAttribP3uiv;
   vfmt->VertexAttribP4ui = vbo_VertexAttribP4ui;
   vfmt->VertexAttribP4uiv = vbo_VertexAttribP4uiv;
}


/**
 * Tell the VBO module to use a real OpenGL vertex buffer object to
 * store accumulated immediate-mode vertex data.
 * This replaces the malloced buffer which was created in
 * vb_exec_vtx_init() below.
 */
void vbo_use_buffer_objects(struct gl_context *ctx)
{
   struct vbo_exec_context *exec = &vbo_context(ctx)->exec;
   /* Any buffer name but 0 can be used here since this bufferobj won't
    * go into the bufferobj hashtable.
    */
   GLuint bufName = IMM_BUFFER_NAME;
   GLenum target = GL_ARRAY_BUFFER_ARB;
   GLenum usage = GL_STREAM_DRAW_ARB;
   GLsizei size = VBO_VERT_BUFFER_SIZE;

   /* Make sure this func is only used once */
   assert(exec->vtx.bufferobj == ctx->Shared->NullBufferObj);

   _mesa_align_free(exec->vtx.buffer_map);
   exec->vtx.buffer_map = NULL;
   exec->vtx.buffer_ptr = NULL;

   /* Allocate a real buffer object now */
   _mesa_reference_buffer_object(ctx, &exec->vtx.bufferobj, NULL);
   exec->vtx.bufferobj = ctx->Driver.NewBufferObject(ctx, bufName, target);
   if (!ctx->Driver.BufferData(ctx, target, size, NULL, usage,
                               GL_MAP_WRITE_BIT |
                               GL_DYNAMIC_STORAGE_BIT |
                               GL_CLIENT_STORAGE_BIT,
                               exec->vtx.bufferobj)) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "VBO allocation");
   }
}


/**
 * If this function is called, all VBO buffers will be unmapped when
 * we flush.
 * Otherwise, if a simple command like glColor3f() is called and we flush,
 * the current VBO may be left mapped.
 */
void
vbo_always_unmap_buffers(struct gl_context *ctx)
{
   struct vbo_exec_context *exec = &vbo_context(ctx)->exec;
   exec->begin_vertices_flags |= FLUSH_STORED_VERTICES;
}


void vbo_exec_vtx_init( struct vbo_exec_context *exec )
{
   struct gl_context *ctx = exec->ctx;
   struct vbo_context *vbo = vbo_context(ctx);
   GLuint i;

   /* Allocate a buffer object.  Will just reuse this object
    * continuously, unless vbo_use_buffer_objects() is called to enable
    * use of real VBOs.
    */
   _mesa_reference_buffer_object(ctx,
                                 &exec->vtx.bufferobj,
                                 ctx->Shared->NullBufferObj);

   ASSERT(!exec->vtx.buffer_map);
   exec->vtx.buffer_map = _mesa_align_malloc(VBO_VERT_BUFFER_SIZE, 64);
   exec->vtx.buffer_ptr = exec->vtx.buffer_map;

   vbo_exec_vtxfmt_init( exec );
   _mesa_noop_vtxfmt_init(&exec->vtxfmt_noop);

   for (i = 0 ; i < VBO_ATTRIB_MAX ; i++) {
      ASSERT(i < Elements(exec->vtx.attrsz));
      exec->vtx.attrsz[i] = 0;
      ASSERT(i < Elements(exec->vtx.attrtype));
      exec->vtx.attrtype[i] = GL_FLOAT;
      ASSERT(i < Elements(exec->vtx.active_sz));
      exec->vtx.active_sz[i] = 0;
   }
   for (i = 0 ; i < VERT_ATTRIB_MAX; i++) {
      ASSERT(i < Elements(exec->vtx.inputs));
      ASSERT(i < Elements(exec->vtx.arrays));
      exec->vtx.inputs[i] = &exec->vtx.arrays[i];
   }
   
   {
      struct gl_client_array *arrays = exec->vtx.arrays;
      unsigned i;

      memcpy(arrays, &vbo->currval[VBO_ATTRIB_POS],
             VERT_ATTRIB_FF_MAX * sizeof(arrays[0]));
      for (i = 0; i < VERT_ATTRIB_FF_MAX; ++i) {
         struct gl_client_array *array;
         array = &arrays[VERT_ATTRIB_FF(i)];
         array->BufferObj = NULL;
         _mesa_reference_buffer_object(ctx, &arrays->BufferObj,
                                 vbo->currval[VBO_ATTRIB_POS+i].BufferObj);
      }

      memcpy(arrays + VERT_ATTRIB_GENERIC(0),
             &vbo->currval[VBO_ATTRIB_GENERIC0],
             VERT_ATTRIB_GENERIC_MAX * sizeof(arrays[0]));

      for (i = 0; i < VERT_ATTRIB_GENERIC_MAX; ++i) {
         struct gl_client_array *array;
         array = &arrays[VERT_ATTRIB_GENERIC(i)];
         array->BufferObj = NULL;
         _mesa_reference_buffer_object(ctx, &array->BufferObj,
                           vbo->currval[VBO_ATTRIB_GENERIC0+i].BufferObj);
      }
   }

   exec->vtx.vertex_size = 0;

   exec->begin_vertices_flags = FLUSH_UPDATE_CURRENT;
}


void vbo_exec_vtx_destroy( struct vbo_exec_context *exec )
{
   /* using a real VBO for vertex data */
   struct gl_context *ctx = exec->ctx;
   unsigned i;

   /* True VBOs should already be unmapped
    */
   if (exec->vtx.buffer_map) {
      ASSERT(exec->vtx.bufferobj->Name == 0 ||
             exec->vtx.bufferobj->Name == IMM_BUFFER_NAME);
      if (exec->vtx.bufferobj->Name == 0) {
         _mesa_align_free(exec->vtx.buffer_map);
         exec->vtx.buffer_map = NULL;
         exec->vtx.buffer_ptr = NULL;
      }
   }

   /* Drop any outstanding reference to the vertex buffer
    */
   for (i = 0; i < Elements(exec->vtx.arrays); i++) {
      _mesa_reference_buffer_object(ctx,
                                    &exec->vtx.arrays[i].BufferObj,
                                    NULL);
   }

   /* Free the vertex buffer.  Unmap first if needed.
    */
   if (_mesa_bufferobj_mapped(exec->vtx.bufferobj, MAP_INTERNAL)) {
      ctx->Driver.UnmapBuffer(ctx, exec->vtx.bufferobj, MAP_INTERNAL);
   }
   _mesa_reference_buffer_object(ctx, &exec->vtx.bufferobj, NULL);
}


/**
 * Called upon first glVertex, glColor, glTexCoord, etc.
 */
void vbo_exec_BeginVertices( struct gl_context *ctx )
{
   struct vbo_exec_context *exec = &vbo_context(ctx)->exec;

   vbo_exec_vtx_map( exec );

   assert((ctx->Driver.NeedFlush & FLUSH_UPDATE_CURRENT) == 0);
   assert(exec->begin_vertices_flags);

   ctx->Driver.NeedFlush |= exec->begin_vertices_flags;
}


/**
 * Called via ctx->Driver.FlushVertices()
 * \param flags  bitmask of FLUSH_STORED_VERTICES, FLUSH_UPDATE_CURRENT
 */
void vbo_exec_FlushVertices( struct gl_context *ctx, GLuint flags )
{
   struct vbo_exec_context *exec = &vbo_context(ctx)->exec;

#ifdef DEBUG
   /* debug check: make sure we don't get called recursively */
   exec->flush_call_depth++;
   assert(exec->flush_call_depth == 1);
#endif

   if (_mesa_inside_begin_end(ctx)) {
      /* We've had glBegin but not glEnd! */
#ifdef DEBUG
      exec->flush_call_depth--;
      assert(exec->flush_call_depth == 0);
#endif
      return;
   }

   /* Flush (draw), and make sure VBO is left unmapped when done */
   vbo_exec_FlushVertices_internal(exec, GL_TRUE);

   /* Need to do this to ensure BeginVertices gets called again:
    */
   ctx->Driver.NeedFlush &= ~(FLUSH_UPDATE_CURRENT | flags);

#ifdef DEBUG
   exec->flush_call_depth--;
   assert(exec->flush_call_depth == 0);
#endif
}


static void reset_attrfv( struct vbo_exec_context *exec )
{   
   GLuint i;

   for (i = 0 ; i < VBO_ATTRIB_MAX ; i++) {
      exec->vtx.attrsz[i] = 0;
      exec->vtx.attrtype[i] = GL_FLOAT;
      exec->vtx.active_sz[i] = 0;
   }

   exec->vtx.vertex_size = 0;
}
      

void GLAPIENTRY
_es_Color4f(GLfloat r, GLfloat g, GLfloat b, GLfloat a)
{
   vbo_Color4f(r, g, b, a);
}


void GLAPIENTRY
_es_Normal3f(GLfloat x, GLfloat y, GLfloat z)
{
   vbo_Normal3f(x, y, z);
}


void GLAPIENTRY
_es_MultiTexCoord4f(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
{
   vbo_MultiTexCoord4f(target, s, t, r, q);
}


void GLAPIENTRY
_es_Materialfv(GLenum face, GLenum pname, const GLfloat *params)
{
   vbo_Materialfv(face, pname, params);
}


void GLAPIENTRY
_es_Materialf(GLenum face, GLenum pname, GLfloat param)
{
   GLfloat p[4];
   p[0] = param;
   p[1] = p[2] = p[3] = 0.0F;
   vbo_Materialfv(face, pname, p);
}


/**
 * A special version of glVertexAttrib4f that does not treat index 0 as
 * VBO_ATTRIB_POS.
 */
static void
VertexAttrib4f_nopos(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   GET_CURRENT_CONTEXT(ctx);
   if (index < MAX_VERTEX_GENERIC_ATTRIBS)
      ATTR(VBO_ATTRIB_GENERIC0 + index, 4, GL_FLOAT, x, y, z, w);
   else
      ERROR(GL_INVALID_VALUE);
}

void GLAPIENTRY
_es_VertexAttrib4f(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   VertexAttrib4f_nopos(index, x, y, z, w);
}


void GLAPIENTRY
_es_VertexAttrib1f(GLuint indx, GLfloat x)
{
   VertexAttrib4f_nopos(indx, x, 0.0f, 0.0f, 1.0f);
}


void GLAPIENTRY
_es_VertexAttrib1fv(GLuint indx, const GLfloat* values)
{
   VertexAttrib4f_nopos(indx, values[0], 0.0f, 0.0f, 1.0f);
}


void GLAPIENTRY
_es_VertexAttrib2f(GLuint indx, GLfloat x, GLfloat y)
{
   VertexAttrib4f_nopos(indx, x, y, 0.0f, 1.0f);
}


void GLAPIENTRY
_es_VertexAttrib2fv(GLuint indx, const GLfloat* values)
{
   VertexAttrib4f_nopos(indx, values[0], values[1], 0.0f, 1.0f);
}


void GLAPIENTRY
_es_VertexAttrib3f(GLuint indx, GLfloat x, GLfloat y, GLfloat z)
{
   VertexAttrib4f_nopos(indx, x, y, z, 1.0f);
}


void GLAPIENTRY
_es_VertexAttrib3fv(GLuint indx, const GLfloat* values)
{
   VertexAttrib4f_nopos(indx, values[0], values[1], values[2], 1.0f);
}


void GLAPIENTRY
_es_VertexAttrib4fv(GLuint indx, const GLfloat* values)
{
   VertexAttrib4f_nopos(indx, values[0], values[1], values[2], values[3]);
}
@


1.11
log
@Merge Mesa 10.2.9
@
text
@@


1.10
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d1000 1
a1000 1
   exec->vtx.bufferobj = ctx->Driver.NewBufferObject(ctx, bufName);
d1070 1
a1070 1
         _mesa_reference_buffer_object(ctx, &array->BufferObj,
@


1.9
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d1000 1
a1000 1
   exec->vtx.bufferobj = ctx->Driver.NewBufferObject(ctx, bufName, target);
d1070 1
a1070 1
         _mesa_reference_buffer_object(ctx, &arrays->BufferObj,
@


1.8
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
Copyright 2002-2008 Tungsten Graphics Inc., Cedar Park, Texas.
d21 1
a21 1
TUNGSTEN GRAPHICS AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
d30 1
a30 1
 *   Keith Whitwell <keith@@tungstengraphics.com>
d705 1
d993 4
a996 5
   if (exec->vtx.buffer_map) {
      _mesa_align_free(exec->vtx.buffer_map);
      exec->vtx.buffer_map = NULL;
      exec->vtx.buffer_ptr = NULL;
   }
d1001 5
a1005 1
   if (!ctx->Driver.BufferData(ctx, target, size, NULL, usage, exec->vtx.bufferobj)) {
d1121 2
a1122 2
   if (_mesa_bufferobj_mapped(exec->vtx.bufferobj)) {
      ctx->Driver.UnmapBuffer(ctx, exec->vtx.bufferobj);
@


1.7
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a36 1
#include "main/mfeatures.h"
d43 1
a43 1
#include "main/api_noop.h"
d47 2
d77 1
a77 1
      if (exec->ctx->Driver.CurrentExecPrimitive != PRIM_OUTSIDE_BEGIN_END) {
d99 1
a99 1
      if (exec->ctx->Driver.CurrentExecPrimitive != PRIM_OUTSIDE_BEGIN_END) {
d126 5
d164 4
a167 3
         COPY_CLEAN_4V(tmp, 
                       exec->vtx.attrsz[i], 
                       exec->vtx.attrptr[i]);
d169 2
a170 1
         if (memcmp(current, tmp, sizeof(tmp)) != 0) { 
a178 1
            assert(vbo->currval[i].Type == GL_FLOAT);
d180 3
d272 1
a272 1
   if (ctx->Driver.CurrentExecPrimitive == PRIM_OUTSIDE_BEGIN_END &&
d335 3
a337 1
		     COPY_CLEAN_4V(tmp, oldSize, data + old_offset);
a377 1
      static const GLfloat id[4] = { 0, 0, 0, 1 };
d379 2
d404 1
a404 1
#define ATTR( A, N, V0, V1, V2, V3 )					\
d420 1
a447 1
#if FEATURE_beginend
d449 114
a563 1
#if FEATURE_evaluators
a655 6
/* use noop eval mesh */
#define vbo_exec_EvalMesh1 _mesa_noop_EvalMesh1
#define vbo_exec_EvalMesh2 _mesa_noop_EvalMesh2

#endif /* FEATURE_evaluators */

d658 1
a658 2
 * Flush (draw) vertices.
 * \param  unmap - leave VBO unmapped after flushing?
d660 1
a660 2
static void
vbo_exec_FlushVertices_internal(struct vbo_exec_context *exec, GLboolean unmap)
d662 24
a685 2
   if (exec->vtx.vert_count || unmap) {
      vbo_exec_vtx_flush( exec, unmap );
d688 29
a716 3
   if (exec->vtx.vertex_size) {
      vbo_exec_copy_to_current( exec );
      reset_attrfv( exec );
d722 1
a722 1
 * Called via glBegin.
d724 2
a725 1
static void GLAPIENTRY vbo_exec_Begin( GLenum mode )
d727 1
a727 1
   GET_CURRENT_CONTEXT( ctx ); 
d729 1
a729 3
   if (ctx->Driver.CurrentExecPrimitive == PRIM_OUTSIDE_BEGIN_END) {
      struct vbo_exec_context *exec = &vbo_context(ctx)->exec;
      int i;
d731 1
a731 2
      if (ctx->NewState) {
	 _mesa_update_state( ctx );
d733 3
a735 3
	 CALL_Begin(ctx->Exec, (mode));
	 return;
      }
d737 7
a743 2
      if (!_mesa_valid_to_render(ctx, "glBegin")) {
         return;
a744 19

      /* Heuristic: attempt to isolate attributes occuring outside
       * begin/end pairs.
       */
      if (exec->vtx.vertex_size && !exec->vtx.attrsz[0]) 
	 vbo_exec_FlushVertices_internal(exec, GL_FALSE);

      i = exec->vtx.prim_count++;
      exec->vtx.prim[i].mode = mode;
      exec->vtx.prim[i].begin = 1;
      exec->vtx.prim[i].end = 0;
      exec->vtx.prim[i].indexed = 0;
      exec->vtx.prim[i].weak = 0;
      exec->vtx.prim[i].pad = 0;
      exec->vtx.prim[i].start = exec->vtx.vert_count;
      exec->vtx.prim[i].count = 0;
      exec->vtx.prim[i].num_instances = 1;

      ctx->Driver.CurrentExecPrimitive = mode;
a745 3
   else 
      _mesa_error( ctx, GL_INVALID_OPERATION, "glBegin" );
      
d755 17
d773 2
a774 2
   if (ctx->Driver.CurrentExecPrimitive != PRIM_OUTSIDE_BEGIN_END) {
      struct vbo_exec_context *exec = &vbo_context(ctx)->exec;
d776 2
a777 4
      if (exec->vtx.prim_count > 0) {
         /* close off current primitive */
         int idx = exec->vtx.vert_count;
         int i = exec->vtx.prim_count - 1;
d779 1
a779 3
         exec->vtx.prim[i].end = 1; 
         exec->vtx.prim[i].count = idx - exec->vtx.prim[i].start;
      }
d781 2
a782 1
      ctx->Driver.CurrentExecPrimitive = PRIM_OUTSIDE_BEGIN_END;
d784 2
a785 2
      if (exec->vtx.prim_count == VBO_MAX_PRIM)
	 vbo_exec_vtx_flush( exec, GL_FALSE );
a786 2
   else 
      _mesa_error( ctx, GL_INVALID_OPERATION, "glEnd" );
d814 1
d817 1
a817 1
   _MESA_INIT_ARRAYELT_VTXFMT(vfmt, _ae_);
d823 2
a824 2
   _MESA_INIT_DLIST_VTXFMT(vfmt, _mesa_);
   _MESA_INIT_EVAL_VTXFMT(vfmt, vbo_exec_);
d826 6
a831 1
   vfmt->Rectf = _mesa_noop_Rectf;
d868 24
a891 9
   vfmt->VertexAttrib1fARB = vbo_VertexAttrib1fARB;
   vfmt->VertexAttrib1fvARB = vbo_VertexAttrib1fvARB;
   vfmt->VertexAttrib2fARB = vbo_VertexAttrib2fARB;
   vfmt->VertexAttrib2fvARB = vbo_VertexAttrib2fvARB;
   vfmt->VertexAttrib3fARB = vbo_VertexAttrib3fARB;
   vfmt->VertexAttrib3fvARB = vbo_VertexAttrib3fvARB;
   vfmt->VertexAttrib4fARB = vbo_VertexAttrib4fARB;
   vfmt->VertexAttrib4fvARB = vbo_VertexAttrib4fvARB;

d925 28
a952 2
}

d954 16
a969 62
#else /* FEATURE_beginend */


static void vbo_exec_vtxfmt_init( struct vbo_exec_context *exec )
{
   /* silence warnings */
   (void) vbo_Color3f;
   (void) vbo_Color3fv;
   (void) vbo_Color4f;
   (void) vbo_Color4fv;
   (void) vbo_FogCoordfEXT;
   (void) vbo_FogCoordfvEXT;
   (void) vbo_MultiTexCoord1f;
   (void) vbo_MultiTexCoord1fv;
   (void) vbo_MultiTexCoord2f;
   (void) vbo_MultiTexCoord2fv;
   (void) vbo_MultiTexCoord3f;
   (void) vbo_MultiTexCoord3fv;
   (void) vbo_MultiTexCoord4f;
   (void) vbo_MultiTexCoord4fv;
   (void) vbo_Normal3f;
   (void) vbo_Normal3fv;
   (void) vbo_SecondaryColor3fEXT;
   (void) vbo_SecondaryColor3fvEXT;
   (void) vbo_TexCoord1f;
   (void) vbo_TexCoord1fv;
   (void) vbo_TexCoord2f;
   (void) vbo_TexCoord2fv;
   (void) vbo_TexCoord3f;
   (void) vbo_TexCoord3fv;
   (void) vbo_TexCoord4f;
   (void) vbo_TexCoord4fv;
   (void) vbo_Vertex2f;
   (void) vbo_Vertex2fv;
   (void) vbo_Vertex3f;
   (void) vbo_Vertex3fv;
   (void) vbo_Vertex4f;
   (void) vbo_Vertex4fv;

   (void) vbo_VertexAttrib1fARB;
   (void) vbo_VertexAttrib1fvARB;
   (void) vbo_VertexAttrib2fARB;
   (void) vbo_VertexAttrib2fvARB;
   (void) vbo_VertexAttrib3fARB;
   (void) vbo_VertexAttrib3fvARB;
   (void) vbo_VertexAttrib4fARB;
   (void) vbo_VertexAttrib4fvARB;

   (void) vbo_VertexAttrib1fNV;
   (void) vbo_VertexAttrib1fvNV;
   (void) vbo_VertexAttrib2fNV;
   (void) vbo_VertexAttrib2fvNV;
   (void) vbo_VertexAttrib3fNV;
   (void) vbo_VertexAttrib3fvNV;
   (void) vbo_VertexAttrib4fNV;
   (void) vbo_VertexAttrib4fvNV;

   (void) vbo_Materialfv;

   (void) vbo_EdgeFlag;
   (void) vbo_Indexf;
   (void) vbo_Indexfv;
a972 3
#endif /* FEATURE_beginend */


d1001 3
a1003 1
   ctx->Driver.BufferData(ctx, target, size, NULL, usage, exec->vtx.bufferobj);
d1036 1
a1036 1
   exec->vtx.buffer_map = (GLfloat *)_mesa_align_malloc(VBO_VERT_BUFFER_SIZE, 64);
d1040 1
a1040 4

   /* Hook our functions into the dispatch table.
    */
   _mesa_install_exec_vtxfmt( ctx, &exec->vtxfmt );
d1045 2
d1060 9
a1068 2
      memcpy(arrays,      vbo->legacy_currval,  16 * sizeof(arrays[0]));
      memcpy(arrays + 16, vbo->generic_currval, 16 * sizeof(arrays[0]));
d1070 10
a1079 7
      for (i = 0; i < 16; ++i) {
         arrays[i     ].BufferObj = NULL;
         arrays[i + 16].BufferObj = NULL;
         _mesa_reference_buffer_object(ctx, &arrays[i     ].BufferObj,
                                       vbo->legacy_currval[i].BufferObj);
         _mesa_reference_buffer_object(ctx, &arrays[i + 16].BufferObj,
                                       vbo->generic_currval[i].BufferObj);
d1118 1
a1118 1
      ctx->Driver.UnmapBuffer(ctx, GL_ARRAY_BUFFER, exec->vtx.bufferobj);
d1154 1
a1154 1
   if (ctx->Driver.CurrentExecPrimitive != PRIM_OUTSIDE_BEGIN_END) {
d1183 1
d1238 1
a1238 1
      ATTR(VBO_ATTRIB_GENERIC0 + index, 4, x, y, z, w);
@


1.6
log
@Merge Mesa 7.10.3
@
text
@d37 1
d162 1
a162 2
         if (memcmp(current, tmp, sizeof(tmp)) != 0)
         { 
d171 2
d196 5
a200 1
static void vbo_exec_copy_from_current( struct vbo_exec_context *exec )
d206 2
a207 2
   for (i = VBO_ATTRIB_POS+1 ; i < VBO_ATTRIB_MAX ; i++) {
      const GLfloat *current = (GLfloat *)vbo->currval[i].Ptr;
d221 4
d226 3
a228 3
static void vbo_exec_wrap_upgrade_vertex( struct vbo_exec_context *exec,
					  GLuint attr,
					  GLuint newsz )
d232 1
a232 1
   GLint lastcount = exec->vtx.vert_count;
d234 2
a235 2
   GLuint old_vtx_size = exec->vtx.vertex_size;
   GLuint oldsz = exec->vtx.attrsz[attr];
d251 1
a251 1
   if (unlikely(oldsz)) {
d263 1
a263 1
       !oldsz && lastcount > 8 && exec->vtx.vertex_size) {
d270 2
a271 2
   exec->vtx.attrsz[attr] = newsz;
   exec->vtx.vertex_size += newsz - oldsz;
d277 1
a277 1
   if (unlikely(oldsz)) {
d295 2
a296 2

   } else {
d299 1
a299 1
	 exec->vtx.vertex_size - newsz;
d323 1
a323 1
		  if (oldsz) {
d325 2
a326 2
		     COPY_CLEAN_4V(tmp, oldsz, data + old_offset);
		     COPY_SZ_4V(dest + new_offset, newsz, tmp);
d349 7
a355 2
static void vbo_exec_fixup_vertex( struct gl_context *ctx,
				   GLuint attr, GLuint sz )
a357 1
   int i;
d359 1
a359 1
   if (sz > exec->vtx.attrsz[attr]) {
d363 1
a363 1
      vbo_exec_wrap_upgrade_vertex( exec, attr, sz );
d365 1
a365 1
   else if (sz < exec->vtx.active_sz[attr]) {
d367 1
d372 1
a372 1
      for (i = sz ; i <= exec->vtx.attrsz[attr] ; i++)
d376 1
a376 1
   exec->vtx.active_sz[attr] = sz;
d383 1
a383 1
      exec->ctx->Driver.NeedFlush |= FLUSH_STORED_VERTICES;
d387 3
a389 1
/* 
d391 3
a393 3
#define ATTR( A, N, V0, V1, V2, V3 )				\
do {								\
   struct vbo_exec_context *exec = &vbo_context(ctx)->exec;	\
d395 3
a397 2
   if (unlikely(!(exec->ctx->Driver.NeedFlush & FLUSH_UPDATE_CURRENT))) \
      ctx->Driver.BeginVertices( ctx );                                 \
d401 15
a415 14
   {								\
      GLfloat *dest = exec->vtx.attrptr[A];			\
      if (N>0) dest[0] = V0;					\
      if (N>1) dest[1] = V1;					\
      if (N>2) dest[2] = V2;					\
      if (N>3) dest[3] = V3;					\
   }								\
								\
   if ((A) == 0) {						\
      GLuint i;							\
								\
      for (i = 0; i < exec->vtx.vertex_size; i++)		\
	 exec->vtx.buffer_ptr[i] = exec->vtx.vertex[i];		\
								\
d417 8
a424 5
      exec->ctx->Driver.NeedFlush |= FLUSH_STORED_VERTICES;	\
								\
      if (++exec->vtx.vert_count >= exec->vtx.max_vert)		\
	 vbo_exec_vtx_wrap( exec );				\
   }								\
d428 1
a428 1
#define ERROR() _mesa_error( ctx, GL_INVALID_ENUM, __FUNCTION__ )
d538 18
d581 1
a581 1
	 vbo_exec_FlushVertices_internal( ctx, GL_FALSE );
d848 13
d884 1
a884 1
   _mesa_install_exec_vtxfmt( exec->ctx, &exec->vtxfmt );
d916 2
d955 4
d962 1
a962 1
   if (0) printf("%s\n", __FUNCTION__);
d965 2
a966 3
   assert((exec->ctx->Driver.NeedFlush & FLUSH_UPDATE_CURRENT) == 0);
   exec->ctx->Driver.NeedFlush |= FLUSH_UPDATE_CURRENT;
}
d968 1
a968 12
void vbo_exec_FlushVertices_internal( struct gl_context *ctx, GLboolean unmap )
{
   struct vbo_exec_context *exec = &vbo_context(ctx)->exec;

   if (exec->vtx.vert_count || unmap) {
      vbo_exec_vtx_flush( exec, unmap );
   }

   if (exec->vtx.vertex_size) {
      vbo_exec_copy_to_current( exec );
      reset_attrfv( exec );
   }
d973 1
d986 2
a987 4
   if (0) printf("%s\n", __FUNCTION__);

   if (exec->ctx->Driver.CurrentExecPrimitive != PRIM_OUTSIDE_BEGIN_END) {
      if (0) printf("%s - inside begin/end\n", __FUNCTION__);
d995 2
a996 1
   vbo_exec_FlushVertices_internal( ctx, GL_TRUE );
d1000 1
a1000 4
   if (exec->ctx->Driver.NeedFlush & FLUSH_UPDATE_CURRENT)
      exec->ctx->Driver.NeedFlush &= ~FLUSH_UPDATE_CURRENT;

   exec->ctx->Driver.NeedFlush &= ~flags;
d1071 1
a1071 1
      ERROR();
@


1.5
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d145 1
a145 1
   GLcontext *ctx = exec->ctx;
d196 1
a196 1
   GLcontext *ctx = exec->ctx;
d220 1
a220 1
   GLcontext *ctx = exec->ctx;
d223 3
a225 2
   GLfloat *tmp;
   GLuint oldsz;
d233 7
d241 7
a247 6
   /* Do a COPY_TO_CURRENT to ensure back-copying works for the case
    * when the attribute already exists in the vertex and is having
    * its size increased.  
    */
   vbo_exec_copy_to_current( exec );

d253 2
a254 3
       exec->vtx.attrsz[attr] == 0 && 
       lastcount > 8 &&
       exec->vtx.vertex_size) {
a259 1
   oldsz = exec->vtx.attrsz[attr];
a260 1

a265 1
   
d267 12
a278 6
   /* Recalculate all the attrptr[] values
    */
   for (i = 0, tmp = exec->vtx.vertex ; i < VBO_ATTRIB_MAX ; i++) {
      if (exec->vtx.attrsz[i]) {
	 exec->vtx.attrptr[i] = tmp;
	 tmp += exec->vtx.attrsz[i];
d280 10
a289 2
      else 
	 exec->vtx.attrptr[i] = NULL; /* will not be dereferenced */
a291 4
   /* Copy from current to repopulate the vertex with correct values.
    */
   vbo_exec_copy_from_current( exec );

d297 1
a297 2
   if (exec->vtx.copied.nr)
   {
d303 1
a303 1
      
d306 6
a311 1
	    if (exec->vtx.attrsz[j]) {
d314 3
a316 3
		     COPY_CLEAN_4V( dest, oldsz, data );
		     data += oldsz;
		     dest += newsz;
d318 2
a319 3
		     const GLfloat *current = (const GLfloat *)vbo->currval[j].Ptr;
		     COPY_SZ_4V( dest, newsz, current );
		     dest += newsz;
d323 1
a323 4
		  GLuint sz = exec->vtx.attrsz[j];
		  COPY_SZ_4V( dest, sz, data );
		  dest += sz;
		  data += sz;
d327 3
d339 1
a339 1
static void vbo_exec_fixup_vertex( GLcontext *ctx,
a371 2
#if FEATURE_beginend

d377 6
a382 4
								\
   if (exec->vtx.active_sz[A] != N)				\
      vbo_exec_fixup_vertex(ctx, A, N);			\
								\
d412 1
a412 1

d552 1
a570 2
      int idx = exec->vtx.vert_count;
      int i = exec->vtx.prim_count - 1;
d572 8
a579 2
      exec->vtx.prim[i].end = 1; 
      exec->vtx.prim[i].count = idx - exec->vtx.prim[i].start;
d591 22
d621 1
d681 18
a710 24
#define ATTR( A, N, V0, V1, V2, V3 )				\
do {								\
   struct vbo_exec_context *exec = &vbo_context(ctx)->exec;	\
								\
   /* FLUSH_UPDATE_CURRENT needs to be set manually */		\
   exec->ctx->Driver.NeedFlush |= FLUSH_UPDATE_CURRENT;		\
								\
   if (exec->vtx.active_sz[A] != N)				\
      vbo_exec_fixup_vertex(ctx, A, N);				\
								\
   {								\
      GLfloat *dest = exec->vtx.attrptr[A];			\
      if (N>0) dest[0] = V0;					\
      if (N>1) dest[1] = V1;					\
      if (N>2) dest[2] = V2;					\
      if (N>3) dest[3] = V3;					\
   }								\
} while (0)

#define ERROR() _mesa_error( ctx, GL_INVALID_ENUM, __FUNCTION__ )
#define TAG(x) vbo_##x

#include "vbo_attrib_tmp.h"

d782 1
a782 1
void vbo_use_buffer_objects(GLcontext *ctx)
d811 1
a811 1
   GLcontext *ctx = exec->ctx;
d869 1
a869 1
   GLcontext *ctx = exec->ctx;
d892 1
a892 1
   /* Free the vertex buffer:
d894 3
d900 1
a900 1
void vbo_exec_BeginVertices( GLcontext *ctx )
d910 1
a910 1
void vbo_exec_FlushVertices_internal( GLcontext *ctx, GLboolean unmap )
d928 1
a928 1
void vbo_exec_FlushVertices( GLcontext *ctx, GLuint flags )
d953 1
a953 2
   if (exec->ctx->Driver.NeedFlush & FLUSH_UPDATE_CURRENT) {
      _mesa_restore_exec_vtxfmt( ctx );
a954 1
   }
d979 1
a979 1
_vbo_Color4f(GLfloat r, GLfloat g, GLfloat b, GLfloat a)
d986 1
a986 1
_vbo_Normal3f(GLfloat x, GLfloat y, GLfloat z)
d993 1
a993 1
_vbo_MultiTexCoord4f(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
d998 1
d1000 1
a1000 1
_vbo_Materialfv(GLenum face, GLenum pname, const GLfloat *params)
d1007 74
a1080 1
_vbo_VertexAttrib4f(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
d1082 1
a1082 1
   vbo_VertexAttrib4fARB(index, x, y, z, w);
@


1.4
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@a37 1
#if FEATURE_dlist
d39 1
a39 1
#endif
d44 1
a44 1
#include "glapi/dispatch.h"
d53 4
d60 2
a61 1
/* Close off the last primitive, execute the buffer, restart the
d69 1
a69 1
      exec->vtx.vbptr = (GLfloat *)exec->vtx.buffer_map;
d87 1
a87 1
	 vbo_exec_vtx_flush( exec );
d110 2
a111 1
/* Deal with buffer wrapping where provoked by the vertex buffer
d129 3
a131 3
      _mesa_memcpy( exec->vtx.vbptr, data, 
		    exec->vtx.vertex_size * sizeof(GLfloat));
      exec->vtx.vbptr += exec->vtx.vertex_size;
d140 1
a140 1
/*
a150 2
	 GLfloat *current = (GLfloat *)vbo->currval[i].Ptr;

d154 2
a155 7
         if (exec->vtx.attrptr[i]) {

	 COPY_CLEAN_4V(current, 
		       exec->vtx.attrsz[i], 
		       exec->vtx.attrptr[i]);

	 }
d157 24
a180 13
	 /* Given that we explicitly state size here, there is no need
	  * for the COPY_CLEAN above, could just copy 16 bytes and be
	  * done.  The only problem is when Mesa accesses ctx->Current
	  * directly.
	  */
	 vbo->currval[i].Size = exec->vtx.attrsz[i];

	 /* This triggers rather too much recalculation of Mesa state
	  * that doesn't get used (eg light positions).
	  */
	 if (i >= VBO_ATTRIB_MAT_FRONT_AMBIENT &&
	     i <= VBO_ATTRIB_MAT_BACK_INDEXES)
	    ctx->NewState |= _NEW_LIGHT;
a190 2

   ctx->Driver.NeedFlush &= ~FLUSH_UPDATE_CURRENT;
a209 2

   ctx->Driver.NeedFlush |= FLUSH_UPDATE_CURRENT;
d213 2
a214 1
/* Flush existing data, set new attrib size, replay copied vertices.
d256 2
a257 1
   exec->vtx.max_vert = VBO_VERT_BUFFER_SIZE / exec->vtx.vertex_size;
d259 1
a259 1
   exec->vtx.vbptr = (GLfloat *)exec->vtx.buffer_map;
d285 1
a285 1
      GLfloat *dest = exec->vtx.vbptr;
d288 1
a288 1
      assert(exec->vtx.vbptr == (GLfloat *)exec->vtx.buffer_map);
d314 1
a314 1
      exec->vtx.vbptr = dest;
a350 2
   else 
      exec->ctx->Driver.NeedFlush |= FLUSH_UPDATE_CURRENT;
d354 1
a354 1

d377 1
a377 1
	 exec->vtx.vbptr[i] = exec->vtx.vertex[i];		\
d379 1
a379 1
      exec->vtx.vbptr += exec->vtx.vertex_size;			\
d397 2
a398 2
/* Eval
 */
d417 2
a418 2
   _mesa_memcpy( exec->vtx.copied.buffer, exec->vtx.vertex, 
                 exec->vtx.vertex_size * sizeof(GLfloat));
d422 2
a423 2
   _mesa_memcpy( exec->vtx.vertex, exec->vtx.copied.buffer,
                 exec->vtx.vertex_size * sizeof(GLfloat));
d447 2
a448 2
   _mesa_memcpy( exec->vtx.copied.buffer, exec->vtx.vertex, 
                 exec->vtx.vertex_size * sizeof(GLfloat));
d452 2
a453 2
   _mesa_memcpy( exec->vtx.vertex, exec->vtx.copied.buffer, 
                 exec->vtx.vertex_size * sizeof(GLfloat));
d490 3
d494 1
a494 15
/**
 * Check if programs/shaders are enabled and valid at glBegin time.
 */
GLboolean 
vbo_validate_shaders(GLcontext *ctx)
{
   if ((ctx->VertexProgram.Enabled && !ctx->VertexProgram._Enabled) ||
       (ctx->FragmentProgram.Enabled && !ctx->FragmentProgram._Enabled)) {
      return GL_FALSE;
   }
   if (ctx->Shader.CurrentProgram && !ctx->Shader.CurrentProgram->LinkStatus) {
      return GL_FALSE;
   }
   return GL_TRUE;
}
d497 2
a498 2
/* Build a list of primitives on the fly.  Keep
 * ctx->Driver.CurrentExecPrimitive uptodate as well.
d515 1
a515 3
      if (!vbo_validate_shaders(ctx)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glBegin (invalid vertex/fragment program)");
d523 1
a523 1
	 vbo_exec_FlushVertices( ctx, ~0 );
d542 4
d561 1
a561 1
	 vbo_exec_vtx_flush( exec );	
d572 2
a573 1
   vfmt->ArrayElement = _ae_loopback_array_elt;	        /* generic helper */
a574 4
#if FEATURE_dlist
   vfmt->CallList = _mesa_CallList;
   vfmt->CallLists = _mesa_CallLists;
#endif
d576 3
a578 6
   vfmt->EvalCoord1f = vbo_exec_EvalCoord1f;
   vfmt->EvalCoord1fv = vbo_exec_EvalCoord1fv;
   vfmt->EvalCoord2f = vbo_exec_EvalCoord2f;
   vfmt->EvalCoord2fv = vbo_exec_EvalCoord2fv;
   vfmt->EvalPoint1 = vbo_exec_EvalPoint1;
   vfmt->EvalPoint2 = vbo_exec_EvalPoint2;
a580 3
   vfmt->EvalMesh1 = _mesa_noop_EvalMesh1;
   vfmt->EvalMesh2 = _mesa_noop_EvalMesh2;

d644 92
d748 1
a748 1
   GLuint bufName = 0xaabbccdd;
a749 1
   GLenum access = GL_READ_WRITE_ARB;
d751 1
a751 1
   GLsizei size = VBO_VERT_BUFFER_SIZE * sizeof(GLfloat);
d754 1
a754 1
   assert(exec->vtx.bufferobj == ctx->Array.NullBufferObj);
d757 2
d762 1
a764 4

   /* and map it */
   exec->vtx.buffer_map
      = ctx->Driver.MapBuffer(ctx, target, access, exec->vtx.bufferobj);
d776 2
a777 1
    * continuously.
d781 1
a781 1
                                 ctx->Array.NullBufferObj);
d784 3
a786 1
   exec->vtx.buffer_map = ALIGN_MALLOC(VBO_VERT_BUFFER_SIZE * sizeof(GLfloat), 64);
d794 1
d796 1
d798 4
d807 2
d811 9
d828 11
a838 9
   if (exec->vtx.bufferobj->Name) {
      /* using a real VBO for vertex data */
      GLcontext *ctx = exec->ctx;
      _mesa_reference_buffer_object(ctx, &exec->vtx.bufferobj, NULL);
   }
   else {
      /* just using malloc'd space for vertex data */
      if (exec->vtx.buffer_map) {
         ALIGN_FREE(exec->vtx.buffer_map);
d840 1
d843 12
d857 9
d867 1
a867 1
void vbo_exec_FlushVertices( GLcontext *ctx, GLuint flags )
d871 2
a872 5
   if (exec->ctx->Driver.CurrentExecPrimitive != PRIM_OUTSIDE_BEGIN_END)
      return;

   if (exec->vtx.vert_count) {
      vbo_exec_vtx_flush( exec );
d879 9
d889 32
a920 1
   exec->ctx->Driver.NeedFlush = 0;
d936 33
@


1.3
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d38 1
d40 1
d71 1
a71 1
      if (exec->ctx->Driver.CurrentExecPrimitive != GL_POLYGON+1) {
d93 1
a93 1
      if (exec->ctx->Driver.CurrentExecPrimitive != GL_POLYGON+1) {
d151 2
d157 2
a158 1
	 
d510 1
a510 1
   if (ctx->Driver.CurrentExecPrimitive == GL_POLYGON+1) {
d554 1
a554 1
   if (ctx->Driver.CurrentExecPrimitive != GL_POLYGON+1) {
d562 1
a562 1
      ctx->Driver.CurrentExecPrimitive = GL_POLYGON+1;
d578 1
d581 1
d657 35
d705 1
a706 1

d731 11
a741 3
   if (exec->vtx.buffer_map) {
      ALIGN_FREE(exec->vtx.buffer_map);
      exec->vtx.buffer_map = NULL;
@


1.2
log
@Update to Mesa 7.0.3. tested my oga@@ and johan@@
@
text
@d3 1
a3 1
Copyright 2002 Tungsten Graphics Inc., Cedar Park, Texas.
d33 11
a43 10
#include "glheader.h"
#include "context.h"
#include "macros.h"
#include "vtxfmt.h"
#include "dlist.h"
#include "state.h"
#include "light.h"
#include "api_arrayelt.h"
#include "api_noop.h"
#include "dispatch.h"
d659 4
a662 1
   exec->vtx.bufferobj = ctx->Array.NullBufferObj;
@


1.1
log
@Initial revision
@
text
@d480 17
a510 8
         /* XXX also need to check if shader enabled, but invalid */
         if ((ctx->VertexProgram.Enabled && !ctx->VertexProgram._Enabled) ||
            (ctx->FragmentProgram.Enabled && !ctx->FragmentProgram._Enabled)) {
            _mesa_error(ctx, GL_INVALID_OPERATION,
                        "glBegin (invalid vertex/fragment program)");
            return;
         }

d513 6
@


1.1.1.1
log
@Mesa 7.0.1
@
text
@@


1.1.1.2
log
@Import Mesa 7.10.3
@
text
@d3 1
a3 1
Copyright 2002-2008 Tungsten Graphics Inc., Cedar Park, Texas.
d33 10
a42 12
#include "main/glheader.h"
#include "main/bufferobj.h"
#include "main/context.h"
#include "main/macros.h"
#include "main/vtxfmt.h"
#include "main/dlist.h"
#include "main/eval.h"
#include "main/state.h"
#include "main/light.h"
#include "main/api_arrayelt.h"
#include "main/api_noop.h"
#include "main/dispatch.h"
a50 4
/** ID/name for immediate-mode VBO */
#define IMM_BUFFER_NAME 0xaabbccdd


d54 1
a54 2
/**
 * Close off the last primitive, execute the buffer, restart the
d62 1
a62 1
      exec->vtx.buffer_ptr = exec->vtx.buffer_map;
d68 1
a68 1
      if (exec->ctx->Driver.CurrentExecPrimitive != PRIM_OUTSIDE_BEGIN_END) {
d80 1
a80 1
	 vbo_exec_vtx_flush( exec, GL_FALSE );
d90 1
a90 1
      if (exec->ctx->Driver.CurrentExecPrimitive != PRIM_OUTSIDE_BEGIN_END) {
d103 1
a103 2
/**
 * Deal with buffer wrapping where provoked by the vertex buffer
d121 3
a123 3
      memcpy( exec->vtx.buffer_ptr, data, 
	      exec->vtx.vertex_size * sizeof(GLfloat));
      exec->vtx.buffer_ptr += exec->vtx.vertex_size;
d132 1
a132 1
/**
d137 1
a137 1
   struct gl_context *ctx = exec->ctx;
d143 2
d148 3
a150 2
	 GLfloat *current = (GLfloat *)vbo->currval[i].Ptr;
         GLfloat tmp[4];
a151 7
         COPY_CLEAN_4V(tmp, 
                       exec->vtx.attrsz[i], 
                       exec->vtx.attrptr[i]);
         
         if (memcmp(current, tmp, sizeof(tmp)) != 0)
         { 
            memcpy(current, tmp, sizeof(tmp));
d153 13
a165 16
            /* Given that we explicitly state size here, there is no need
             * for the COPY_CLEAN above, could just copy 16 bytes and be
             * done.  The only problem is when Mesa accesses ctx->Current
             * directly.
             */
            vbo->currval[i].Size = exec->vtx.attrsz[i];

            /* This triggers rather too much recalculation of Mesa state
             * that doesn't get used (eg light positions).
             */
            if (i >= VBO_ATTRIB_MAT_FRONT_AMBIENT &&
                i <= VBO_ATTRIB_MAT_BACK_INDEXES)
               ctx->NewState |= _NEW_LIGHT;
            
            ctx->NewState |= _NEW_CURRENT_ATTRIB;
         }
d176 2
d183 1
a183 1
   struct gl_context *ctx = exec->ctx;
d197 2
d202 1
a202 2
/**
 * Flush existing data, set new attrib size, replay copied vertices.
d208 1
a208 1
   struct gl_context *ctx = exec->ctx;
d211 2
a212 3
   GLfloat *old_attrptr[VBO_ATTRIB_MAX];
   GLuint old_vtx_size = exec->vtx.vertex_size;
   GLuint oldsz = exec->vtx.attrsz[attr];
a219 7
   if (unlikely(exec->vtx.copied.nr)) {
      /* We're in the middle of a primitive, keep the old vertex
       * format around to be able to translate the copied vertices to
       * the new format.
       */
      memcpy(old_attrptr, exec->vtx.attrptr, sizeof(old_attrptr));
   }
d221 6
a226 7
   if (unlikely(oldsz)) {
      /* Do a COPY_TO_CURRENT to ensure back-copying works for the
       * case when the attribute already exists in the vertex and is
       * having its size increased.
       */
      vbo_exec_copy_to_current( exec );
   }
d232 3
a234 2
       !oldsz && lastcount > 8 && exec->vtx.vertex_size) {
      vbo_exec_copy_to_current( exec );
d240 1
d242 1
d244 1
a244 2
   exec->vtx.max_vert = ((VBO_VERT_BUFFER_SIZE - exec->vtx.buffer_used) / 
                         (exec->vtx.vertex_size * sizeof(GLfloat)));
d246 2
a247 1
   exec->vtx.buffer_ptr = exec->vtx.buffer_map;
d249 6
a254 12
   if (unlikely(oldsz)) {
      /* Size changed, recalculate all the attrptr[] values
       */
      GLfloat *tmp = exec->vtx.vertex;

      for (i = 0 ; i < VBO_ATTRIB_MAX ; i++) {
	 if (exec->vtx.attrsz[i]) {
	    exec->vtx.attrptr[i] = tmp;
	    tmp += exec->vtx.attrsz[i];
	 }
	 else
	    exec->vtx.attrptr[i] = NULL; /* will not be dereferenced */
d256 3
d260 3
a262 10
      /* Copy from current to repopulate the vertex with correct
       * values.
       */
      vbo_exec_copy_from_current( exec );

   } else {
      /* Just have to append the new attribute at the end */
      exec->vtx.attrptr[attr] = exec->vtx.vertex +
	 exec->vtx.vertex_size - newsz;
   }
d269 2
a270 1
   if (unlikely(exec->vtx.copied.nr)) {
d272 1
a272 1
      GLfloat *dest = exec->vtx.buffer_ptr;
d275 2
a276 2
      assert(exec->vtx.buffer_ptr == exec->vtx.buffer_map);

d279 1
a279 6
	    GLuint sz = exec->vtx.attrsz[j];

	    if (sz) {
	       GLint old_offset = old_attrptr[j] - exec->vtx.vertex;
	       GLint new_offset = exec->vtx.attrptr[j] - exec->vtx.vertex;

d282 3
a284 3
		     GLfloat tmp[4];
		     COPY_CLEAN_4V(tmp, oldsz, data + old_offset);
		     COPY_SZ_4V(dest + new_offset, newsz, tmp);
d286 3
a288 2
		     GLfloat *current = (GLfloat *)vbo->currval[j].Ptr;
		     COPY_SZ_4V(dest + new_offset, sz, current);
d292 4
a295 1
		  COPY_SZ_4V(dest + new_offset, sz, data + old_offset);
a298 3

	 data += old_vtx_size;
	 dest += exec->vtx.vertex_size;
d301 1
a301 1
      exec->vtx.buffer_ptr = dest;
d308 1
a308 1
static void vbo_exec_fixup_vertex( struct gl_context *ctx,
d338 2
d343 2
d350 4
a353 6
									\
   if (unlikely(!(exec->ctx->Driver.NeedFlush & FLUSH_UPDATE_CURRENT))) \
      ctx->Driver.BeginVertices( ctx );                                 \
   if (unlikely(exec->vtx.active_sz[A] != N))				\
      vbo_exec_fixup_vertex(ctx, A, N);					\
   									\
d366 1
a366 1
	 exec->vtx.buffer_ptr[i] = exec->vtx.vertex[i];		\
d368 1
a368 1
      exec->vtx.buffer_ptr += exec->vtx.vertex_size;			\
a382 1
#if FEATURE_beginend
a384 1
#if FEATURE_evaluators
d386 2
d406 2
a407 2
   memcpy( exec->vtx.copied.buffer, exec->vtx.vertex, 
           exec->vtx.vertex_size * sizeof(GLfloat));
d411 2
a412 2
   memcpy( exec->vtx.vertex, exec->vtx.copied.buffer,
           exec->vtx.vertex_size * sizeof(GLfloat));
d436 2
a437 2
   memcpy( exec->vtx.copied.buffer, exec->vtx.vertex, 
           exec->vtx.vertex_size * sizeof(GLfloat));
d441 2
a442 2
   memcpy( exec->vtx.vertex, exec->vtx.copied.buffer, 
           exec->vtx.vertex_size * sizeof(GLfloat));
a478 3
/* use noop eval mesh */
#define vbo_exec_EvalMesh1 _mesa_noop_EvalMesh1
#define vbo_exec_EvalMesh2 _mesa_noop_EvalMesh2
d480 2
a481 5
#endif /* FEATURE_evaluators */


/**
 * Called via glBegin.
d487 1
a487 1
   if (ctx->Driver.CurrentExecPrimitive == PRIM_OUTSIDE_BEGIN_END) {
d494 8
a505 4
      if (!_mesa_valid_to_render(ctx, "glBegin")) {
         return;
      }

d510 1
a510 1
	 vbo_exec_FlushVertices_internal( ctx, GL_FALSE );
a520 1
      exec->vtx.prim[i].num_instances = 1;
a528 4

/**
 * Called via glEnd.
 */
d533 1
a533 1
   if (ctx->Driver.CurrentExecPrimitive != PRIM_OUTSIDE_BEGIN_END) {
d535 2
d538 2
a539 4
      if (exec->vtx.prim_count > 0) {
         /* close off current primitive */
         int idx = exec->vtx.vert_count;
         int i = exec->vtx.prim_count - 1;
d541 1
a541 5
         exec->vtx.prim[i].end = 1; 
         exec->vtx.prim[i].count = idx - exec->vtx.prim[i].start;
      }

      ctx->Driver.CurrentExecPrimitive = PRIM_OUTSIDE_BEGIN_END;
d544 1
a544 1
	 vbo_exec_vtx_flush( exec, GL_FALSE );
a550 22
/**
 * Called via glPrimitiveRestartNV()
 */
static void GLAPIENTRY
vbo_exec_PrimitiveRestartNV(void)
{
   GLenum curPrim;
   GET_CURRENT_CONTEXT( ctx ); 

   curPrim = ctx->Driver.CurrentExecPrimitive;

   if (curPrim == PRIM_OUTSIDE_BEGIN_END) {
      _mesa_error( ctx, GL_INVALID_OPERATION, "glPrimitiveRestartNV" );
   }
   else {
      vbo_exec_End();
      vbo_exec_Begin(curPrim);
   }
}



d555 1
a555 2
   _MESA_INIT_ARRAYELT_VTXFMT(vfmt, _ae_);

d557 2
d560 6
a565 1
   vfmt->PrimitiveRestartNV = vbo_exec_PrimitiveRestartNV;
d567 3
a569 2
   _MESA_INIT_DLIST_VTXFMT(vfmt, _mesa_);
   _MESA_INIT_EVAL_VTXFMT(vfmt, vbo_exec_);
a570 1
   vfmt->Rectf = _mesa_noop_Rectf;
a624 18
   /* integer-valued */
   vfmt->VertexAttribI1i = vbo_VertexAttribI1i;
   vfmt->VertexAttribI2i = vbo_VertexAttribI2i;
   vfmt->VertexAttribI3i = vbo_VertexAttribI3i;
   vfmt->VertexAttribI4i = vbo_VertexAttribI4i;
   vfmt->VertexAttribI2iv = vbo_VertexAttribI2iv;
   vfmt->VertexAttribI3iv = vbo_VertexAttribI3iv;
   vfmt->VertexAttribI4iv = vbo_VertexAttribI4iv;

   /* unsigned integer-valued */
   vfmt->VertexAttribI1ui = vbo_VertexAttribI1ui;
   vfmt->VertexAttribI2ui = vbo_VertexAttribI2ui;
   vfmt->VertexAttribI3ui = vbo_VertexAttribI3ui;
   vfmt->VertexAttribI4ui = vbo_VertexAttribI4ui;
   vfmt->VertexAttribI2uiv = vbo_VertexAttribI2uiv;
   vfmt->VertexAttribI3uiv = vbo_VertexAttribI3uiv;
   vfmt->VertexAttribI4uiv = vbo_VertexAttribI4uiv;

a633 101
#else /* FEATURE_beginend */


static void vbo_exec_vtxfmt_init( struct vbo_exec_context *exec )
{
   /* silence warnings */
   (void) vbo_Color3f;
   (void) vbo_Color3fv;
   (void) vbo_Color4f;
   (void) vbo_Color4fv;
   (void) vbo_FogCoordfEXT;
   (void) vbo_FogCoordfvEXT;
   (void) vbo_MultiTexCoord1f;
   (void) vbo_MultiTexCoord1fv;
   (void) vbo_MultiTexCoord2f;
   (void) vbo_MultiTexCoord2fv;
   (void) vbo_MultiTexCoord3f;
   (void) vbo_MultiTexCoord3fv;
   (void) vbo_MultiTexCoord4f;
   (void) vbo_MultiTexCoord4fv;
   (void) vbo_Normal3f;
   (void) vbo_Normal3fv;
   (void) vbo_SecondaryColor3fEXT;
   (void) vbo_SecondaryColor3fvEXT;
   (void) vbo_TexCoord1f;
   (void) vbo_TexCoord1fv;
   (void) vbo_TexCoord2f;
   (void) vbo_TexCoord2fv;
   (void) vbo_TexCoord3f;
   (void) vbo_TexCoord3fv;
   (void) vbo_TexCoord4f;
   (void) vbo_TexCoord4fv;
   (void) vbo_Vertex2f;
   (void) vbo_Vertex2fv;
   (void) vbo_Vertex3f;
   (void) vbo_Vertex3fv;
   (void) vbo_Vertex4f;
   (void) vbo_Vertex4fv;

   (void) vbo_VertexAttrib1fARB;
   (void) vbo_VertexAttrib1fvARB;
   (void) vbo_VertexAttrib2fARB;
   (void) vbo_VertexAttrib2fvARB;
   (void) vbo_VertexAttrib3fARB;
   (void) vbo_VertexAttrib3fvARB;
   (void) vbo_VertexAttrib4fARB;
   (void) vbo_VertexAttrib4fvARB;

   (void) vbo_VertexAttrib1fNV;
   (void) vbo_VertexAttrib1fvNV;
   (void) vbo_VertexAttrib2fNV;
   (void) vbo_VertexAttrib2fvNV;
   (void) vbo_VertexAttrib3fNV;
   (void) vbo_VertexAttrib3fvNV;
   (void) vbo_VertexAttrib4fNV;
   (void) vbo_VertexAttrib4fvNV;

   (void) vbo_Materialfv;

   (void) vbo_EdgeFlag;
   (void) vbo_Indexf;
   (void) vbo_Indexfv;
}


#endif /* FEATURE_beginend */


/**
 * Tell the VBO module to use a real OpenGL vertex buffer object to
 * store accumulated immediate-mode vertex data.
 * This replaces the malloced buffer which was created in
 * vb_exec_vtx_init() below.
 */
void vbo_use_buffer_objects(struct gl_context *ctx)
{
   struct vbo_exec_context *exec = &vbo_context(ctx)->exec;
   /* Any buffer name but 0 can be used here since this bufferobj won't
    * go into the bufferobj hashtable.
    */
   GLuint bufName = IMM_BUFFER_NAME;
   GLenum target = GL_ARRAY_BUFFER_ARB;
   GLenum usage = GL_STREAM_DRAW_ARB;
   GLsizei size = VBO_VERT_BUFFER_SIZE;

   /* Make sure this func is only used once */
   assert(exec->vtx.bufferobj == ctx->Shared->NullBufferObj);
   if (exec->vtx.buffer_map) {
      _mesa_align_free(exec->vtx.buffer_map);
      exec->vtx.buffer_map = NULL;
      exec->vtx.buffer_ptr = NULL;
   }

   /* Allocate a real buffer object now */
   _mesa_reference_buffer_object(ctx, &exec->vtx.bufferobj, NULL);
   exec->vtx.bufferobj = ctx->Driver.NewBufferObject(ctx, bufName, target);
   ctx->Driver.BufferData(ctx, target, size, NULL, usage, exec->vtx.bufferobj);
}



d636 1
a636 1
   struct gl_context *ctx = exec->ctx;
d641 1
a641 2
    * continuously, unless vbo_use_buffer_objects() is called to enable
    * use of real VBOs.
d643 2
a644 7
   _mesa_reference_buffer_object(ctx,
                                 &exec->vtx.bufferobj,
                                 ctx->Shared->NullBufferObj);

   ASSERT(!exec->vtx.buffer_map);
   exec->vtx.buffer_map = (GLfloat *)_mesa_align_malloc(VBO_VERT_BUFFER_SIZE, 64);
   exec->vtx.buffer_ptr = exec->vtx.buffer_map;
a652 1
      ASSERT(i < Elements(exec->vtx.attrsz));
a653 1
      ASSERT(i < Elements(exec->vtx.active_sz));
a654 4
   }
   for (i = 0 ; i < VERT_ATTRIB_MAX; i++) {
      ASSERT(i < Elements(exec->vtx.inputs));
      ASSERT(i < Elements(exec->vtx.arrays));
a659 2
      unsigned i;

a661 9

      for (i = 0; i < 16; ++i) {
         arrays[i     ].BufferObj = NULL;
         arrays[i + 16].BufferObj = NULL;
         _mesa_reference_buffer_object(ctx, &arrays[i     ].BufferObj,
                                       vbo->legacy_currval[i].BufferObj);
         _mesa_reference_buffer_object(ctx, &arrays[i + 16].BufferObj,
                                       vbo->generic_currval[i].BufferObj);
      }
a669 6
   /* using a real VBO for vertex data */
   struct gl_context *ctx = exec->ctx;
   unsigned i;

   /* True VBOs should already be unmapped
    */
d671 2
a672 7
      ASSERT(exec->vtx.bufferobj->Name == 0 ||
             exec->vtx.bufferobj->Name == IMM_BUFFER_NAME);
      if (exec->vtx.bufferobj->Name == 0) {
         _mesa_align_free(exec->vtx.buffer_map);
         exec->vtx.buffer_map = NULL;
         exec->vtx.buffer_ptr = NULL;
      }
d674 1
a675 7
   /* Drop any outstanding reference to the vertex buffer
    */
   for (i = 0; i < Elements(exec->vtx.arrays); i++) {
      _mesa_reference_buffer_object(ctx,
                                    &exec->vtx.arrays[i].BufferObj,
                                    NULL);
   }
d677 1
a677 9
   /* Free the vertex buffer.  Unmap first if needed.
    */
   if (_mesa_bufferobj_mapped(exec->vtx.bufferobj)) {
      ctx->Driver.UnmapBuffer(ctx, GL_ARRAY_BUFFER, exec->vtx.bufferobj);
   }
   _mesa_reference_buffer_object(ctx, &exec->vtx.bufferobj, NULL);
}

void vbo_exec_BeginVertices( struct gl_context *ctx )
a679 2
   if (0) printf("%s\n", __FUNCTION__);
   vbo_exec_vtx_map( exec );
d681 2
a682 7
   assert((exec->ctx->Driver.NeedFlush & FLUSH_UPDATE_CURRENT) == 0);
   exec->ctx->Driver.NeedFlush |= FLUSH_UPDATE_CURRENT;
}

void vbo_exec_FlushVertices_internal( struct gl_context *ctx, GLboolean unmap )
{
   struct vbo_exec_context *exec = &vbo_context(ctx)->exec;
d684 2
a685 2
   if (exec->vtx.vert_count || unmap) {
      vbo_exec_vtx_flush( exec, unmap );
a691 35
}


/**
 * \param flags  bitmask of FLUSH_STORED_VERTICES, FLUSH_UPDATE_CURRENT
 */
void vbo_exec_FlushVertices( struct gl_context *ctx, GLuint flags )
{
   struct vbo_exec_context *exec = &vbo_context(ctx)->exec;

#ifdef DEBUG
   /* debug check: make sure we don't get called recursively */
   exec->flush_call_depth++;
   assert(exec->flush_call_depth == 1);
#endif

   if (0) printf("%s\n", __FUNCTION__);

   if (exec->ctx->Driver.CurrentExecPrimitive != PRIM_OUTSIDE_BEGIN_END) {
      if (0) printf("%s - inside begin/end\n", __FUNCTION__);
#ifdef DEBUG
      exec->flush_call_depth--;
      assert(exec->flush_call_depth == 0);
#endif
      return;
   }

   vbo_exec_FlushVertices_internal( ctx, GL_TRUE );

   /* Need to do this to ensure BeginVertices gets called again:
    */
   if (exec->ctx->Driver.NeedFlush & FLUSH_UPDATE_CURRENT)
      exec->ctx->Driver.NeedFlush &= ~FLUSH_UPDATE_CURRENT;

   exec->ctx->Driver.NeedFlush &= ~flags;
d693 1
a693 4
#ifdef DEBUG
   exec->flush_call_depth--;
   assert(exec->flush_call_depth == 0);
#endif
a708 107

void GLAPIENTRY
_es_Color4f(GLfloat r, GLfloat g, GLfloat b, GLfloat a)
{
   vbo_Color4f(r, g, b, a);
}


void GLAPIENTRY
_es_Normal3f(GLfloat x, GLfloat y, GLfloat z)
{
   vbo_Normal3f(x, y, z);
}


void GLAPIENTRY
_es_MultiTexCoord4f(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
{
   vbo_MultiTexCoord4f(target, s, t, r, q);
}


void GLAPIENTRY
_es_Materialfv(GLenum face, GLenum pname, const GLfloat *params)
{
   vbo_Materialfv(face, pname, params);
}


void GLAPIENTRY
_es_Materialf(GLenum face, GLenum pname, GLfloat param)
{
   GLfloat p[4];
   p[0] = param;
   p[1] = p[2] = p[3] = 0.0F;
   vbo_Materialfv(face, pname, p);
}


/**
 * A special version of glVertexAttrib4f that does not treat index 0 as
 * VBO_ATTRIB_POS.
 */
static void
VertexAttrib4f_nopos(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   GET_CURRENT_CONTEXT(ctx);
   if (index < MAX_VERTEX_GENERIC_ATTRIBS)
      ATTR(VBO_ATTRIB_GENERIC0 + index, 4, x, y, z, w);
   else
      ERROR();
}

void GLAPIENTRY
_es_VertexAttrib4f(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   VertexAttrib4f_nopos(index, x, y, z, w);
}


void GLAPIENTRY
_es_VertexAttrib1f(GLuint indx, GLfloat x)
{
   VertexAttrib4f_nopos(indx, x, 0.0f, 0.0f, 1.0f);
}


void GLAPIENTRY
_es_VertexAttrib1fv(GLuint indx, const GLfloat* values)
{
   VertexAttrib4f_nopos(indx, values[0], 0.0f, 0.0f, 1.0f);
}


void GLAPIENTRY
_es_VertexAttrib2f(GLuint indx, GLfloat x, GLfloat y)
{
   VertexAttrib4f_nopos(indx, x, y, 0.0f, 1.0f);
}


void GLAPIENTRY
_es_VertexAttrib2fv(GLuint indx, const GLfloat* values)
{
   VertexAttrib4f_nopos(indx, values[0], values[1], 0.0f, 1.0f);
}


void GLAPIENTRY
_es_VertexAttrib3f(GLuint indx, GLfloat x, GLfloat y, GLfloat z)
{
   VertexAttrib4f_nopos(indx, x, y, z, 1.0f);
}


void GLAPIENTRY
_es_VertexAttrib3fv(GLuint indx, const GLfloat* values)
{
   VertexAttrib4f_nopos(indx, values[0], values[1], values[2], 1.0f);
}


void GLAPIENTRY
_es_VertexAttrib4fv(GLuint indx, const GLfloat* values)
{
   VertexAttrib4f_nopos(indx, values[0], values[1], values[2], values[3]);
}
@


1.1.1.3
log
@Import Mesa 9.2.0
@
text
@d43 1
a43 1
#include "main/api_validate.h"
a46 2
#include "vbo_noop.h"

d75 1
a75 1
      if (_mesa_inside_begin_end(exec->ctx)) {
d97 1
a97 1
      if (_mesa_inside_begin_end(exec->ctx)) {
a123 5
   if (!exec->vtx.buffer_ptr) {
      /* probably ran out of memory earlier when allocating the VBO */
      return;
   }

d157 3
a159 4
         COPY_CLEAN_4V_TYPE_AS_FLOAT(tmp,
                                     exec->vtx.attrsz[i],
                                     exec->vtx.attrptr[i],
                                     exec->vtx.attrtype[i]);
d161 2
a162 2
         if (exec->vtx.attrtype[i] != vbo->currval[i].Type ||
             memcmp(current, tmp, sizeof(tmp)) != 0) {
a170 4
            vbo->currval[i]._ElementSize = vbo->currval[i].Size * sizeof(GLfloat);
            vbo->currval[i].Type = exec->vtx.attrtype[i];
            vbo->currval[i].Integer =
                  vbo_attrtype_to_integer_flag(exec->vtx.attrtype[i]);
d194 1
a194 5
/**
 * Copy current vertex attribute values into the current vertex.
 */
static void
vbo_exec_copy_from_current(struct vbo_exec_context *exec)
d200 2
a201 2
   for (i = VBO_ATTRIB_POS + 1; i < VBO_ATTRIB_MAX; i++) {
      const GLfloat *current = (GLfloat *) vbo->currval[i].Ptr;
a214 4
 * This is called when we transition from a small vertex attribute size
 * to a larger one.  Ex: glTexCoord2f -> glTexCoord4f.
 * We need to go back over the previous 2-component texcoords and insert
 * zero and one values.
d216 3
a218 3
static void
vbo_exec_wrap_upgrade_vertex(struct vbo_exec_context *exec,
                             GLuint attr, GLuint newSize )
d222 1
a222 1
   const GLint lastcount = exec->vtx.vert_count;
d224 2
a225 2
   const GLuint old_vtx_size = exec->vtx.vertex_size; /* floats per vertex */
   const GLuint oldSize = exec->vtx.attrsz[attr];
d241 1
a241 1
   if (unlikely(oldSize)) {
d252 2
a253 2
   if (!_mesa_inside_begin_end(ctx) &&
       !oldSize && lastcount > 8 && exec->vtx.vertex_size) {
d260 2
a261 2
   exec->vtx.attrsz[attr] = newSize;
   exec->vtx.vertex_size += newSize - oldSize;
d267 1
a267 1
   if (unlikely(oldSize)) {
d285 2
a286 2
   }
   else {
d289 1
a289 1
	 exec->vtx.vertex_size - newSize;
d313 1
a313 1
		  if (oldSize) {
d315 2
a316 4
                     COPY_CLEAN_4V_TYPE_AS_FLOAT(tmp, oldSize,
                                                 data + old_offset,
                                                 exec->vtx.attrtype[j]);
		     COPY_SZ_4V(dest + new_offset, newSize, tmp);
d339 2
a340 7
/**
 * This is when a vertex attribute transitions to a different size.
 * For example, we saw a bunch of glTexCoord2f() calls and now we got a
 * glTexCoord4f() call.  We promote the array from size=2 to size=4.
 */
static void
vbo_exec_fixup_vertex(struct gl_context *ctx, GLuint attr, GLuint newSize)
d343 1
d345 1
a345 1
   if (newSize > exec->vtx.attrsz[attr]) {
d349 1
a349 1
      vbo_exec_wrap_upgrade_vertex( exec, attr, newSize );
d351 2
a352 4
   else if (newSize < exec->vtx.active_sz[attr]) {
      GLuint i;
      const GLfloat *id =
            vbo_get_default_vals_as_float(exec->vtx.attrtype[attr]);
d357 1
a357 1
      for (i = newSize; i <= exec->vtx.attrsz[attr]; i++)
d361 1
a361 1
   exec->vtx.active_sz[attr] = newSize;
d368 1
a368 1
      ctx->Driver.NeedFlush |= FLUSH_STORED_VERTICES;
d372 1
a372 3
/**
 * This macro is used to implement all the glVertex, glColor, glTexCoord,
 * glVertexAttrib, etc functions.
d374 3
a376 3
#define ATTR( A, N, T, V0, V1, V2, V3 )					\
do {									\
   struct vbo_exec_context *exec = &vbo_context(ctx)->exec;		\
d378 2
a379 3
   if (unlikely(!(ctx->Driver.NeedFlush & FLUSH_UPDATE_CURRENT)))	\
      ctx->Driver.BeginVertices( ctx );					\
   									\
d383 14
a396 16
   {									\
      GLfloat *dest = exec->vtx.attrptr[A];				\
      if (N>0) dest[0] = V0;						\
      if (N>1) dest[1] = V1;						\
      if (N>2) dest[2] = V2;						\
      if (N>3) dest[3] = V3;						\
      exec->vtx.attrtype[A] = T;                                        \
   }									\
									\
   if ((A) == 0) {							\
      /* This is a glVertex call */					\
      GLuint i;								\
									\
      for (i = 0; i < exec->vtx.vertex_size; i++)			\
	 exec->vtx.buffer_ptr[i] = exec->vtx.vertex[i];			\
									\
d398 5
a402 8
									\
      /* Set FLUSH_STORED_VERTICES to indicate that there's now */	\
      /* something to draw (not just updating a color or texcoord).*/	\
      ctx->Driver.NeedFlush |= FLUSH_STORED_VERTICES;			\
									\
      if (++exec->vtx.vert_count >= exec->vtx.max_vert)			\
	 vbo_exec_vtx_wrap( exec );					\
   }									\
d406 1
a406 1
#define ERROR(err) _mesa_error( ctx, err, __FUNCTION__ )
d412 1
a412 97

/**
 * Execute a glMaterial call.  Note that if GL_COLOR_MATERIAL is enabled,
 * this may be a (partial) no-op.
 */
static void GLAPIENTRY
vbo_Materialfv(GLenum face, GLenum pname, const GLfloat *params)
{
   GLbitfield updateMats;
   GET_CURRENT_CONTEXT(ctx);

   /* This function should be a no-op when it tries to update material
    * attributes which are currently tracking glColor via glColorMaterial.
    * The updateMats var will be a mask of the MAT_BIT_FRONT/BACK_x bits
    * indicating which material attributes can actually be updated below.
    */
   if (ctx->Light.ColorMaterialEnabled) {
      updateMats = ~ctx->Light._ColorMaterialBitmask;
   }
   else {
      /* GL_COLOR_MATERIAL is disabled so don't skip any material updates */
      updateMats = ALL_MATERIAL_BITS;
   }

   if (ctx->API == API_OPENGL_COMPAT && face == GL_FRONT) {
      updateMats &= FRONT_MATERIAL_BITS;
   }
   else if (ctx->API == API_OPENGL_COMPAT && face == GL_BACK) {
      updateMats &= BACK_MATERIAL_BITS;
   }
   else if (face != GL_FRONT_AND_BACK) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glMaterial(invalid face)");
      return;
   }

   switch (pname) {
   case GL_EMISSION:
      if (updateMats & MAT_BIT_FRONT_EMISSION)
         MAT_ATTR(VBO_ATTRIB_MAT_FRONT_EMISSION, 4, params);
      if (updateMats & MAT_BIT_BACK_EMISSION)
         MAT_ATTR(VBO_ATTRIB_MAT_BACK_EMISSION, 4, params);
      break;
   case GL_AMBIENT:
      if (updateMats & MAT_BIT_FRONT_AMBIENT)
         MAT_ATTR(VBO_ATTRIB_MAT_FRONT_AMBIENT, 4, params);
      if (updateMats & MAT_BIT_BACK_AMBIENT)
         MAT_ATTR(VBO_ATTRIB_MAT_BACK_AMBIENT, 4, params);
      break;
   case GL_DIFFUSE:
      if (updateMats & MAT_BIT_FRONT_DIFFUSE)
         MAT_ATTR(VBO_ATTRIB_MAT_FRONT_DIFFUSE, 4, params);
      if (updateMats & MAT_BIT_BACK_DIFFUSE)
         MAT_ATTR(VBO_ATTRIB_MAT_BACK_DIFFUSE, 4, params);
      break;
   case GL_SPECULAR:
      if (updateMats & MAT_BIT_FRONT_SPECULAR)
         MAT_ATTR(VBO_ATTRIB_MAT_FRONT_SPECULAR, 4, params);
      if (updateMats & MAT_BIT_BACK_SPECULAR)
         MAT_ATTR(VBO_ATTRIB_MAT_BACK_SPECULAR, 4, params);
      break;
   case GL_SHININESS:
      if (*params < 0 || *params > ctx->Const.MaxShininess) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glMaterial(invalid shininess: %f out range [0, %f])",
		     *params, ctx->Const.MaxShininess);
         return;
      }
      if (updateMats & MAT_BIT_FRONT_SHININESS)
         MAT_ATTR(VBO_ATTRIB_MAT_FRONT_SHININESS, 1, params);
      if (updateMats & MAT_BIT_BACK_SHININESS)
         MAT_ATTR(VBO_ATTRIB_MAT_BACK_SHININESS, 1, params);
      break;
   case GL_COLOR_INDEXES:
      if (ctx->API != API_OPENGL_COMPAT) {
         _mesa_error(ctx, GL_INVALID_ENUM, "glMaterialfv(pname)");
         return;
      }
      if (updateMats & MAT_BIT_FRONT_INDEXES)
         MAT_ATTR(VBO_ATTRIB_MAT_FRONT_INDEXES, 3, params);
      if (updateMats & MAT_BIT_BACK_INDEXES)
         MAT_ATTR(VBO_ATTRIB_MAT_BACK_INDEXES, 3, params);
      break;
   case GL_AMBIENT_AND_DIFFUSE:
      if (updateMats & MAT_BIT_FRONT_AMBIENT)
         MAT_ATTR(VBO_ATTRIB_MAT_FRONT_AMBIENT, 4, params);
      if (updateMats & MAT_BIT_FRONT_DIFFUSE)
         MAT_ATTR(VBO_ATTRIB_MAT_FRONT_DIFFUSE, 4, params);
      if (updateMats & MAT_BIT_BACK_AMBIENT)
         MAT_ATTR(VBO_ATTRIB_MAT_BACK_AMBIENT, 4, params);
      if (updateMats & MAT_BIT_BACK_DIFFUSE)
         MAT_ATTR(VBO_ATTRIB_MAT_BACK_DIFFUSE, 4, params);
      break;
   default:
      _mesa_error(ctx, GL_INVALID_ENUM, "glMaterialfv(pname)");
      return;
   }
}
d415 1
a415 17
/**
 * Flush (draw) vertices.
 * \param  unmap - leave VBO unmapped after flushing?
 */
static void
vbo_exec_FlushVertices_internal(struct vbo_exec_context *exec, GLboolean unmap)
{
   if (exec->vtx.vert_count || unmap) {
      vbo_exec_vtx_flush( exec, unmap );
   }

   if (exec->vtx.vertex_size) {
      vbo_exec_copy_to_current( exec );
      reset_attrfv( exec );
   }
}

d508 6
a520 2
   struct vbo_exec_context *exec = &vbo_context(ctx)->exec;
   int i;
d522 3
a524 4
   if (_mesa_inside_begin_end(ctx)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glBegin");
      return;
   }
d526 2
a527 3
   if (!_mesa_valid_prim_mode(ctx, mode, "glBegin")) {
      return;
   }
d529 3
a531 1
   vbo_draw_method(vbo_context(ctx), DRAW_BEGIN_END);
d533 3
a535 2
   if (ctx->NewState) {
      _mesa_update_state( ctx );
d537 5
a541 7
      CALL_Begin(ctx->Exec, (mode));
      return;
   }

   if (!_mesa_valid_to_render(ctx, "glBegin")) {
      return;
   }
d543 10
a552 5
   /* Heuristic: attempt to isolate attributes occuring outside
    * begin/end pairs.
    */
   if (exec->vtx.vertex_size && !exec->vtx.attrsz[0])
      vbo_exec_FlushVertices_internal(exec, GL_FALSE);
d554 1
a554 51
   i = exec->vtx.prim_count++;
   exec->vtx.prim[i].mode = mode;
   exec->vtx.prim[i].begin = 1;
   exec->vtx.prim[i].end = 0;
   exec->vtx.prim[i].indexed = 0;
   exec->vtx.prim[i].weak = 0;
   exec->vtx.prim[i].pad = 0;
   exec->vtx.prim[i].start = exec->vtx.vert_count;
   exec->vtx.prim[i].count = 0;
   exec->vtx.prim[i].num_instances = 1;
   exec->vtx.prim[i].base_instance = 0;

   ctx->Driver.CurrentExecPrimitive = mode;

   ctx->Exec = ctx->BeginEnd;
   /* We may have been called from a display list, in which case we should
    * leave dlist.c's dispatch table in place.
    */
   if (ctx->CurrentDispatch == ctx->OutsideBeginEnd) {
      ctx->CurrentDispatch = ctx->BeginEnd;
      _glapi_set_dispatch(ctx->CurrentDispatch);
   } else {
      assert(ctx->CurrentDispatch == ctx->Save);
   }
}


/**
 * Try to merge / concatenate the two most recent VBO primitives.
 */
static void
try_vbo_merge(struct vbo_exec_context *exec)
{
   struct _mesa_prim *cur =  &exec->vtx.prim[exec->vtx.prim_count - 1];

   assert(exec->vtx.prim_count >= 1);

   vbo_try_prim_conversion(cur);

   if (exec->vtx.prim_count >= 2) {
      struct _mesa_prim *prev = &exec->vtx.prim[exec->vtx.prim_count - 2];
      assert(prev == cur - 1);

      if (vbo_can_merge_prims(prev, cur)) {
         assert(cur->begin);
         assert(cur->end);
         assert(prev->begin);
         assert(prev->end);
         vbo_merge_prims(prev, cur);
         exec->vtx.prim_count--;  /* drop the last primitive */
      }
d556 3
a567 1
   struct vbo_exec_context *exec = &vbo_context(ctx)->exec;
d569 2
a570 4
   if (!_mesa_inside_begin_end(ctx)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glEnd");
      return;
   }
d572 4
a575 5
   ctx->Exec = ctx->OutsideBeginEnd;
   if (ctx->CurrentDispatch == ctx->BeginEnd) {
      ctx->CurrentDispatch = ctx->OutsideBeginEnd;
      _glapi_set_dispatch(ctx->CurrentDispatch);
   }
d577 3
a579 4
   if (exec->vtx.prim_count > 0) {
      /* close off current primitive */
      int idx = exec->vtx.vert_count;
      int i = exec->vtx.prim_count - 1;
d581 1
a581 2
      exec->vtx.prim[i].end = 1;
      exec->vtx.prim[i].count = idx - exec->vtx.prim[i].start;
d583 2
a584 10
      try_vbo_merge(exec);
   }

   ctx->Driver.CurrentExecPrimitive = PRIM_OUTSIDE_BEGIN_END;

   if (exec->vtx.prim_count == VBO_MAX_PRIM)
      vbo_exec_vtx_flush( exec, GL_FALSE );

   if (MESA_DEBUG_FLAGS & DEBUG_ALWAYS_FLUSH) {
      _mesa_flush(ctx);
d586 2
a614 1
   struct gl_context *ctx = exec->ctx;
d617 1
a617 1
   vfmt->ArrayElement = _ae_ArrayElement;
d623 2
a624 2
   vfmt->CallList = _mesa_CallList;
   vfmt->CallLists = _mesa_CallLists;
d626 1
a626 6
   vfmt->EvalCoord1f = vbo_exec_EvalCoord1f;
   vfmt->EvalCoord1fv = vbo_exec_EvalCoord1fv;
   vfmt->EvalCoord2f = vbo_exec_EvalCoord2f;
   vfmt->EvalCoord2fv = vbo_exec_EvalCoord2fv;
   vfmt->EvalPoint1 = vbo_exec_EvalPoint1;
   vfmt->EvalPoint2 = vbo_exec_EvalPoint2;
d663 8
a670 19
   if (ctx->API == API_OPENGLES2) {
      vfmt->VertexAttrib1fARB = _es_VertexAttrib1f;
      vfmt->VertexAttrib1fvARB = _es_VertexAttrib1fv;
      vfmt->VertexAttrib2fARB = _es_VertexAttrib2f;
      vfmt->VertexAttrib2fvARB = _es_VertexAttrib2fv;
      vfmt->VertexAttrib3fARB = _es_VertexAttrib3f;
      vfmt->VertexAttrib3fvARB = _es_VertexAttrib3fv;
      vfmt->VertexAttrib4fARB = _es_VertexAttrib4f;
      vfmt->VertexAttrib4fvARB = _es_VertexAttrib4fv;
   } else {
      vfmt->VertexAttrib1fARB = vbo_VertexAttrib1fARB;
      vfmt->VertexAttrib1fvARB = vbo_VertexAttrib1fvARB;
      vfmt->VertexAttrib2fARB = vbo_VertexAttrib2fARB;
      vfmt->VertexAttrib2fvARB = vbo_VertexAttrib2fvARB;
      vfmt->VertexAttrib3fARB = vbo_VertexAttrib3fARB;
      vfmt->VertexAttrib3fvARB = vbo_VertexAttrib3fvARB;
      vfmt->VertexAttrib4fARB = vbo_VertexAttrib4fARB;
      vfmt->VertexAttrib4fvARB = vbo_VertexAttrib4fvARB;
   }
a671 4
   /* Note that VertexAttrib4fNV is used from dlist.c and api_arrayelt.c so
    * they can have a single entrypoint for updating any of the legacy
    * attribs.
    */
d705 5
a709 28
   /* ARB_vertex_type_2_10_10_10_rev */
   vfmt->VertexP2ui = vbo_VertexP2ui;
   vfmt->VertexP2uiv = vbo_VertexP2uiv;
   vfmt->VertexP3ui = vbo_VertexP3ui;
   vfmt->VertexP3uiv = vbo_VertexP3uiv;
   vfmt->VertexP4ui = vbo_VertexP4ui;
   vfmt->VertexP4uiv = vbo_VertexP4uiv;

   vfmt->TexCoordP1ui = vbo_TexCoordP1ui;
   vfmt->TexCoordP1uiv = vbo_TexCoordP1uiv;
   vfmt->TexCoordP2ui = vbo_TexCoordP2ui;
   vfmt->TexCoordP2uiv = vbo_TexCoordP2uiv;
   vfmt->TexCoordP3ui = vbo_TexCoordP3ui;
   vfmt->TexCoordP3uiv = vbo_TexCoordP3uiv;
   vfmt->TexCoordP4ui = vbo_TexCoordP4ui;
   vfmt->TexCoordP4uiv = vbo_TexCoordP4uiv;

   vfmt->MultiTexCoordP1ui = vbo_MultiTexCoordP1ui;
   vfmt->MultiTexCoordP1uiv = vbo_MultiTexCoordP1uiv;
   vfmt->MultiTexCoordP2ui = vbo_MultiTexCoordP2ui;
   vfmt->MultiTexCoordP2uiv = vbo_MultiTexCoordP2uiv;
   vfmt->MultiTexCoordP3ui = vbo_MultiTexCoordP3ui;
   vfmt->MultiTexCoordP3uiv = vbo_MultiTexCoordP3uiv;
   vfmt->MultiTexCoordP4ui = vbo_MultiTexCoordP4ui;
   vfmt->MultiTexCoordP4uiv = vbo_MultiTexCoordP4uiv;
   
   vfmt->NormalP3ui = vbo_NormalP3ui;
   vfmt->NormalP3uiv = vbo_NormalP3uiv;
d711 59
a769 16
   vfmt->ColorP3ui = vbo_ColorP3ui;
   vfmt->ColorP3uiv = vbo_ColorP3uiv;
   vfmt->ColorP4ui = vbo_ColorP4ui;
   vfmt->ColorP4uiv = vbo_ColorP4uiv;

   vfmt->SecondaryColorP3ui = vbo_SecondaryColorP3ui;
   vfmt->SecondaryColorP3uiv = vbo_SecondaryColorP3uiv;

   vfmt->VertexAttribP1ui = vbo_VertexAttribP1ui;
   vfmt->VertexAttribP1uiv = vbo_VertexAttribP1uiv;
   vfmt->VertexAttribP2ui = vbo_VertexAttribP2ui;
   vfmt->VertexAttribP2uiv = vbo_VertexAttribP2uiv;
   vfmt->VertexAttribP3ui = vbo_VertexAttribP3ui;
   vfmt->VertexAttribP3uiv = vbo_VertexAttribP3uiv;
   vfmt->VertexAttribP4ui = vbo_VertexAttribP4ui;
   vfmt->VertexAttribP4uiv = vbo_VertexAttribP4uiv;
d773 3
d804 1
a804 3
   if (!ctx->Driver.BufferData(ctx, target, size, NULL, usage, exec->vtx.bufferobj)) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "VBO allocation");
   }
a807 13
/**
 * If this function is called, all VBO buffers will be unmapped when
 * we flush.
 * Otherwise, if a simple command like glColor3f() is called and we flush,
 * the current VBO may be left mapped.
 */
void
vbo_always_unmap_buffers(struct gl_context *ctx)
{
   struct vbo_exec_context *exec = &vbo_context(ctx)->exec;
   exec->begin_vertices_flags |= FLUSH_STORED_VERTICES;
}

d824 1
a824 1
   exec->vtx.buffer_map = _mesa_align_malloc(VBO_VERT_BUFFER_SIZE, 64);
d828 4
a831 1
   _mesa_noop_vtxfmt_init(&exec->vtxfmt_noop);
a835 2
      ASSERT(i < Elements(exec->vtx.attrtype));
      exec->vtx.attrtype[i] = GL_FLOAT;
d849 2
a850 9
      memcpy(arrays, &vbo->currval[VBO_ATTRIB_POS],
             VERT_ATTRIB_FF_MAX * sizeof(arrays[0]));
      for (i = 0; i < VERT_ATTRIB_FF_MAX; ++i) {
         struct gl_client_array *array;
         array = &arrays[VERT_ATTRIB_FF(i)];
         array->BufferObj = NULL;
         _mesa_reference_buffer_object(ctx, &arrays->BufferObj,
                                 vbo->currval[VBO_ATTRIB_POS+i].BufferObj);
      }
d852 7
a858 10
      memcpy(arrays + VERT_ATTRIB_GENERIC(0),
             &vbo->currval[VBO_ATTRIB_GENERIC0],
             VERT_ATTRIB_GENERIC_MAX * sizeof(arrays[0]));

      for (i = 0; i < VERT_ATTRIB_GENERIC_MAX; ++i) {
         struct gl_client_array *array;
         array = &arrays[VERT_ATTRIB_GENERIC(i)];
         array->BufferObj = NULL;
         _mesa_reference_buffer_object(ctx, &array->BufferObj,
                           vbo->currval[VBO_ATTRIB_GENERIC0+i].BufferObj);
a862 2

   exec->begin_vertices_flags = FLUSH_UPDATE_CURRENT;
d895 1
a895 1
      ctx->Driver.UnmapBuffer(ctx, exec->vtx.bufferobj);
a899 4

/**
 * Called upon first glVertex, glColor, glTexCoord, etc.
 */
d903 2
d906 7
a912 1
   vbo_exec_vtx_map( exec );
d914 3
a916 2
   assert((ctx->Driver.NeedFlush & FLUSH_UPDATE_CURRENT) == 0);
   assert(exec->begin_vertices_flags);
d918 4
a921 1
   ctx->Driver.NeedFlush |= exec->begin_vertices_flags;
a925 1
 * Called via ctx->Driver.FlushVertices()
d938 4
a941 2
   if (_mesa_inside_begin_end(ctx)) {
      /* We've had glBegin but not glEnd! */
d949 1
a949 2
   /* Flush (draw), and make sure VBO is left unmapped when done */
   vbo_exec_FlushVertices_internal(exec, GL_TRUE);
d953 4
a956 1
   ctx->Driver.NeedFlush &= ~(FLUSH_UPDATE_CURRENT | flags);
a970 1
      exec->vtx.attrtype[i] = GL_FLOAT;
d1025 1
a1025 1
      ATTR(VBO_ATTRIB_GENERIC0 + index, 4, GL_FLOAT, x, y, z, w);
d1027 1
a1027 1
      ERROR(GL_INVALID_VALUE);
@


1.1.1.4
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
Copyright 2002-2008 VMware, Inc.
d21 1
a21 1
VMWARE AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
d30 1
a30 1
 *   Keith Whitwell <keithw@@vmware.com>
a704 1
   exec->vtx.prim[i].is_indirect = 0;
d992 5
a996 4

   _mesa_align_free(exec->vtx.buffer_map);
   exec->vtx.buffer_map = NULL;
   exec->vtx.buffer_ptr = NULL;
d1001 1
a1001 5
   if (!ctx->Driver.BufferData(ctx, target, size, NULL, usage,
                               GL_MAP_WRITE_BIT |
                               GL_DYNAMIC_STORAGE_BIT |
                               GL_CLIENT_STORAGE_BIT,
                               exec->vtx.bufferobj)) {
d1117 2
a1118 2
   if (_mesa_bufferobj_mapped(exec->vtx.bufferobj, MAP_INTERNAL)) {
      ctx->Driver.UnmapBuffer(ctx, exec->vtx.bufferobj, MAP_INTERNAL);
@


1.1.1.5
log
@Import Mesa 10.4.3
@
text
@d1000 1
a1000 1
   exec->vtx.bufferobj = ctx->Driver.NewBufferObject(ctx, bufName);
d1070 1
a1070 1
         _mesa_reference_buffer_object(ctx, &array->BufferObj,
@


1.1.1.6
log
@Import Mesa 10.2.9
@
text
@d1000 1
a1000 1
   exec->vtx.bufferobj = ctx->Driver.NewBufferObject(ctx, bufName, target);
d1070 1
a1070 1
         _mesa_reference_buffer_object(ctx, &arrays->BufferObj,
@


