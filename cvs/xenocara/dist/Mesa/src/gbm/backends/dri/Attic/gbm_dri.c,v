head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.1
	v9_2_1:1.1.1.1
	v9_2_0:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_4:1.1.0.4
	OPENBSD_5_4_BASE:1.1
	OPENBSD_5_3:1.1.0.2
	OPENBSD_5_3_BASE:1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.12.23.05.17.43;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2015.02.20.23.09.56;	author jsg;	state Exp;
branches;
next	1.5;
commitid	4ry2gvZGMXkCUD2n;

1.5
date	2015.01.25.14.41.19;	author jsg;	state Exp;
branches;
next	1.4;
commitid	mcxB0JvoI9gTDYXU;

1.4
date	2014.07.09.21.08.57;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.11.24.06.19.52;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2013.09.05.14.02.21;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2012.08.17.13.58.10;	author mpi;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.09.05.13.14.03;	author jsg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.11.24.05.58.05;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.25;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.10.04;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.47.11;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright Â© 2011 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Authors:
 *    Benjamin Franzke <benjaminfranzke@@googlemail.com>
 */

#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <stdint.h>
#include <string.h>
#include <errno.h>
#include <limits.h>

#include <sys/types.h>
#include <sys/mman.h>
#include <unistd.h>
#include <dlfcn.h>
#include <xf86drm.h>

#include <GL/gl.h> /* dri_interface needs GL types */
#include <GL/internal/dri_interface.h>

#include "gbm_driint.h"

#include "gbmint.h"
#include "loader.h"

/* For importing wl_buffer */
#if HAVE_WAYLAND_PLATFORM
#include "../../../egl/wayland/wayland-drm/wayland-drm.h"
#endif

static __DRIimage *
dri_lookup_egl_image(__DRIscreen *screen, void *image, void *data)
{
   struct gbm_dri_device *dri = data;

   if (dri->lookup_image == NULL)
      return NULL;

   return dri->lookup_image(screen, image, dri->lookup_user_data);
}

static __DRIbuffer *
dri_get_buffers(__DRIdrawable * driDrawable,
		 int *width, int *height,
		 unsigned int *attachments, int count,
		 int *out_count, void *data)
{
   struct gbm_dri_surface *surf = data;
   struct gbm_dri_device *dri = gbm_dri_device(surf->base.gbm);

   if (dri->get_buffers == NULL)
      return NULL;

   return dri->get_buffers(driDrawable, width, height, attachments,
                           count, out_count, surf->dri_private);
}

static void
dri_flush_front_buffer(__DRIdrawable * driDrawable, void *data)
{
   struct gbm_dri_surface *surf = data;
   struct gbm_dri_device *dri = gbm_dri_device(surf->base.gbm);

   if (dri->flush_front_buffer != NULL)
      dri->flush_front_buffer(driDrawable, surf->dri_private);
}

static __DRIbuffer *
dri_get_buffers_with_format(__DRIdrawable * driDrawable,
                            int *width, int *height,
                            unsigned int *attachments, int count,
                            int *out_count, void *data)
{
   struct gbm_dri_surface *surf = data;
   struct gbm_dri_device *dri = gbm_dri_device(surf->base.gbm);

   if (dri->get_buffers_with_format == NULL)
      return NULL;

   return
      dri->get_buffers_with_format(driDrawable, width, height, attachments,
                                   count, out_count, surf->dri_private);
}

static int
image_get_buffers(__DRIdrawable *driDrawable,
                  unsigned int format,
                  uint32_t *stamp,
                  void *loaderPrivate,
                  uint32_t buffer_mask,
                  struct __DRIimageList *buffers)
{
   struct gbm_dri_surface *surf = loaderPrivate;
   struct gbm_dri_device *dri = gbm_dri_device(surf->base.gbm);

   if (dri->image_get_buffers == NULL)
      return 0;

   return dri->image_get_buffers(driDrawable, format, stamp,
                                 surf->dri_private, buffer_mask, buffers);
}

static const __DRIuseInvalidateExtension use_invalidate = {
   .base = { __DRI_USE_INVALIDATE, 1 }
};

static const __DRIimageLookupExtension image_lookup_extension = {
   .base = { __DRI_IMAGE_LOOKUP, 1 },

   .lookupEGLImage          = dri_lookup_egl_image
};

static const __DRIdri2LoaderExtension dri2_loader_extension = {
   .base = { __DRI_DRI2_LOADER, 3 },

   .getBuffers              = dri_get_buffers,
   .flushFrontBuffer        = dri_flush_front_buffer,
   .getBuffersWithFormat    = dri_get_buffers_with_format,
};

static const __DRIimageLoaderExtension image_loader_extension = {
   .base = { __DRI_IMAGE_LOADER, 1 },

   .getBuffers          = image_get_buffers,
   .flushFrontBuffer    = dri_flush_front_buffer,
};

static const __DRIextension *gbm_dri_screen_extensions[] = {
   &image_lookup_extension.base,
   &use_invalidate.base,
   &dri2_loader_extension.base,
   &image_loader_extension.base,
   NULL,
};

struct dri_extension_match {
   const char *name;
   int version;
   int offset;
};

static struct dri_extension_match dri_core_extensions[] = {
   { __DRI2_FLUSH, 1, offsetof(struct gbm_dri_device, flush) },
   { __DRI_IMAGE, 1, offsetof(struct gbm_dri_device, image) },
   { NULL, 0, 0 }
};

static struct dri_extension_match gbm_dri_device_extensions[] = {
   { __DRI_CORE, 1, offsetof(struct gbm_dri_device, core) },
   { __DRI_DRI2, 1, offsetof(struct gbm_dri_device, dri2) },
   { NULL, 0, 0 }
};

static int
dri_bind_extensions(struct gbm_dri_device *dri,
                    struct dri_extension_match *matches,
                    const __DRIextension **extensions)
{
   int i, j, ret = 0;
   void *field;

   for (i = 0; extensions[i]; i++) {
      for (j = 0; matches[j].name; j++) {
         if (strcmp(extensions[i]->name, matches[j].name) == 0 &&
             extensions[i]->version >= matches[j].version) {
            field = ((char *) dri + matches[j].offset);
            *(const __DRIextension **) field = extensions[i];
         }
      }
   }

   for (j = 0; matches[j].name; j++) {
      field = ((char *) dri + matches[j].offset);
      if (*(const __DRIextension **) field == NULL) {
         ret = -1;
      }
   }

   return ret;
}

static int
dri_load_driver(struct gbm_dri_device *dri)
{
   const __DRIextension **extensions = NULL;
   char path[PATH_MAX], *search_paths, *p, *next, *end;
   char *get_extensions_name;

   search_paths = NULL;
   if (geteuid() == getuid()) {
      /* don't allow setuid apps to use GBM_DRIVERS_PATH */
      search_paths = getenv("GBM_DRIVERS_PATH");
   }
   if (search_paths == NULL)
      search_paths = DEFAULT_DRIVER_DIR;

   dri->driver = NULL;
   end = search_paths + strlen(search_paths);
   for (p = search_paths; p < end && dri->driver == NULL; p = next + 1) {
      int len;
      next = strchr(p, ':');
      if (next == NULL)
         next = end;

      len = next - p;
#if GLX_USE_TLS
      snprintf(path, sizeof path,
               "%.*s/tls/%s_dri.so", len, p, dri->base.driver_name);
      dri->driver = dlopen(path, RTLD_NOW | RTLD_GLOBAL);
#endif
      if (dri->driver == NULL) {
         snprintf(path, sizeof path,
                  "%.*s/%s_dri.so", len, p, dri->base.driver_name);
         dri->driver = dlopen(path, RTLD_NOW | RTLD_GLOBAL);
      }
      /* not need continue to loop all paths once the driver is found */
      if (dri->driver != NULL)
         break;
   }

   if (dri->driver == NULL) {
      fprintf(stderr, "gbm: failed to open any driver (search paths %s)",
              search_paths);
      return -1;
   }

   if (asprintf(&get_extensions_name, "%s_%s",
                __DRI_DRIVER_GET_EXTENSIONS, dri->base.driver_name) != -1) {
      const __DRIextension **(*get_extensions)(void);

      get_extensions = dlsym(dri->driver, get_extensions_name);
      free(get_extensions_name);

      if (get_extensions)
         extensions = get_extensions();
   }

   if (!extensions)
      extensions = dlsym(dri->driver, __DRI_DRIVER_EXTENSIONS);
   if (extensions == NULL) {
      fprintf(stderr, "gbm: driver exports no extensions (%s)", dlerror());
      dlclose(dri->driver);
      return -1;
   }
   dri->driver_extensions = extensions;

   if (dri_bind_extensions(dri, gbm_dri_device_extensions, extensions) < 0) {
      dlclose(dri->driver);
      fprintf(stderr, "failed to bind extensions\n");
      return -1;
   }

   return 0;
}

static int
dri_screen_create(struct gbm_dri_device *dri)
{
   const __DRIextension **extensions;
   int ret = 0;

   dri->base.driver_name = loader_get_driver_for_fd(dri->base.base.fd, 0);
   if (dri->base.driver_name == NULL)
      return -1;

   ret = dri_load_driver(dri);
   if (ret) {
      fprintf(stderr, "failed to load driver: %s\n", dri->base.driver_name);
      return ret;
   };

   dri->extensions = gbm_dri_screen_extensions;

   if (dri->dri2 == NULL)
      return -1;

   if (dri->dri2->base.version >= 4) {
      dri->screen = dri->dri2->createNewScreen2(0, dri->base.base.fd,
                                                dri->extensions,
                                                dri->driver_extensions,
                                                &dri->driver_configs, dri);
   } else {
      dri->screen = dri->dri2->createNewScreen(0, dri->base.base.fd,
                                               dri->extensions,
                                               &dri->driver_configs, dri);
   }
   if (dri->screen == NULL)
      return -1;

   extensions = dri->core->getExtensions(dri->screen);
   if (dri_bind_extensions(dri, dri_core_extensions, extensions) < 0) {
      ret = -1;
      goto free_screen;
   }

   dri->lookup_image = NULL;
   dri->lookup_user_data = NULL;

   return 0;

free_screen:
   dri->core->destroyScreen(dri->screen);

   return ret;
}

static int
gbm_dri_is_format_supported(struct gbm_device *gbm,
                            uint32_t format,
                            uint32_t usage)
{
   switch (format) {
   case GBM_BO_FORMAT_XRGB8888:
   case GBM_FORMAT_XRGB8888:
      break;
   case GBM_BO_FORMAT_ARGB8888:
   case GBM_FORMAT_ARGB8888:
      if (usage & GBM_BO_USE_SCANOUT)
         return 0;
      break;
   default:
      return 0;
   }

   if (usage & GBM_BO_USE_CURSOR_64X64 &&
       usage & GBM_BO_USE_RENDERING)
      return 0;

   return 1;
}

static int
gbm_dri_bo_write(struct gbm_bo *_bo, const void *buf, size_t count)
{
   struct gbm_dri_bo *bo = gbm_dri_bo(_bo);

   if (bo->image != NULL) {
      errno = EINVAL;
      return -1;
   }

   memcpy(bo->map, buf, count);

   return 0;
}

static int
gbm_dri_bo_get_fd(struct gbm_bo *_bo)
{
   struct gbm_dri_device *dri = gbm_dri_device(_bo->gbm);
   struct gbm_dri_bo *bo = gbm_dri_bo(_bo);
   int fd;

   if (bo->image == NULL)
      return -1;

   dri->image->queryImage(bo->image, __DRI_IMAGE_ATTRIB_FD, &fd);

   return fd;
}

static void
gbm_dri_bo_destroy(struct gbm_bo *_bo)
{
   struct gbm_dri_device *dri = gbm_dri_device(_bo->gbm);
   struct gbm_dri_bo *bo = gbm_dri_bo(_bo);
   struct drm_mode_destroy_dumb arg;

   if (bo->image != NULL) {
      dri->image->destroyImage(bo->image);
   } else {
      munmap(bo->map, bo->size);
      memset(&arg, 0, sizeof(arg));
      arg.handle = bo->handle;
      drmIoctl(dri->base.base.fd, DRM_IOCTL_MODE_DESTROY_DUMB, &arg);
   }

   free(bo);
}

static uint32_t
gbm_dri_to_gbm_format(uint32_t dri_format)
{
   uint32_t ret = 0;

   switch (dri_format) {
   case __DRI_IMAGE_FORMAT_RGB565:
      ret = GBM_FORMAT_RGB565;
      break;
   case __DRI_IMAGE_FORMAT_XRGB8888:
      ret = GBM_FORMAT_XRGB8888;
      break;
   case __DRI_IMAGE_FORMAT_ARGB8888:
      ret = GBM_FORMAT_ARGB8888;
      break;
   case __DRI_IMAGE_FORMAT_ABGR8888:
      ret = GBM_FORMAT_ABGR8888;
      break;
   default:
      ret = 0;
      break;
   }

   return ret;
}

static struct gbm_bo *
gbm_dri_bo_import(struct gbm_device *gbm,
                  uint32_t type, void *buffer, uint32_t usage)
{
   struct gbm_dri_device *dri = gbm_dri_device(gbm);
   struct gbm_dri_bo *bo;
   __DRIimage *image;
   unsigned dri_use = 0;
   int gbm_format;

   /* Required for query image WIDTH & HEIGHT */
   if (dri->image->base.version < 4) {
      errno = ENOSYS;
      return NULL;
   }

   switch (type) {
#if HAVE_WAYLAND_PLATFORM
   case GBM_BO_IMPORT_WL_BUFFER:
   {
      struct wl_drm_buffer *wb;

      if (!dri->wl_drm) {
         errno = EINVAL;
         return NULL;
      }

      wb = wayland_drm_buffer_get(dri->wl_drm, (struct wl_resource *) buffer);
      if (!wb) {
         errno = EINVAL;
         return NULL;
      }

      image = dri->image->dupImage(wb->driver_buffer, NULL);

      switch (wb->format) {
      case WL_DRM_FORMAT_XRGB8888:
         gbm_format = GBM_FORMAT_XRGB8888;
         break;
      case WL_DRM_FORMAT_ARGB8888:
         gbm_format = GBM_FORMAT_ARGB8888;
         break;
      case WL_DRM_FORMAT_RGB565:
         gbm_format = GBM_FORMAT_RGB565;
         break;
      case WL_DRM_FORMAT_YUYV:
         gbm_format = GBM_FORMAT_YUYV;
         break;
      default:
         return NULL;
      }
      break;
   }
#endif

   case GBM_BO_IMPORT_EGL_IMAGE:
   {
      int dri_format;
      if (dri->lookup_image == NULL) {
         errno = EINVAL;
         return NULL;
      }

      image = dri->lookup_image(dri->screen, buffer, dri->lookup_user_data);
      image = dri->image->dupImage(image, NULL);
      dri->image->queryImage(image, __DRI_IMAGE_ATTRIB_FORMAT, &dri_format);
      gbm_format = gbm_dri_to_gbm_format(dri_format);
      if (gbm_format == 0) {
         errno = EINVAL;
         return NULL;
      }
      break;
   }

   case GBM_BO_IMPORT_FD:
   {
      struct gbm_import_fd_data *fd_data = buffer;
      int stride = fd_data->stride, offset = 0;

      image = dri->image->createImageFromFds(dri->screen,
                                             fd_data->width,
                                             fd_data->height,
                                             fd_data->format,
                                             &fd_data->fd, 1,
                                             &stride, &offset,
                                             NULL);
      gbm_format = fd_data->format;
      break;
   }

   default:
      errno = ENOSYS;
      return NULL;
   }


   bo = calloc(1, sizeof *bo);
   if (bo == NULL)
      return NULL;

   bo->image = image;

   if (usage & GBM_BO_USE_SCANOUT)
      dri_use |= __DRI_IMAGE_USE_SCANOUT;
   if (usage & GBM_BO_USE_CURSOR_64X64)
      dri_use |= __DRI_IMAGE_USE_CURSOR;
   if (dri->image->base.version >= 2 &&
       !dri->image->validateUsage(bo->image, dri_use)) {
      errno = EINVAL;
      free(bo);
      return NULL;
   }

   bo->base.base.gbm = gbm;
   bo->base.base.format = gbm_format;

   dri->image->queryImage(bo->image, __DRI_IMAGE_ATTRIB_WIDTH,
                          (int*)&bo->base.base.width);
   dri->image->queryImage(bo->image, __DRI_IMAGE_ATTRIB_HEIGHT,
                          (int*)&bo->base.base.height);
   dri->image->queryImage(bo->image, __DRI_IMAGE_ATTRIB_STRIDE,
                          (int*)&bo->base.base.stride);
   dri->image->queryImage(bo->image, __DRI_IMAGE_ATTRIB_HANDLE,
                          &bo->base.base.handle.s32);

   return &bo->base.base;
}

static struct gbm_bo *
create_dumb(struct gbm_device *gbm,
                  uint32_t width, uint32_t height,
                  uint32_t format, uint32_t usage)
{
   struct gbm_dri_device *dri = gbm_dri_device(gbm);
   struct drm_mode_create_dumb create_arg;
   struct drm_mode_map_dumb map_arg;
   struct gbm_dri_bo *bo;
   struct drm_mode_destroy_dumb destroy_arg;
   int ret;

   if (!(usage & GBM_BO_USE_CURSOR_64X64)) {
      errno = EINVAL;
      return NULL;
   }
   if (format != GBM_FORMAT_ARGB8888) {
      errno = EINVAL;
      return NULL;
   }

   bo = calloc(1, sizeof *bo);
   if (bo == NULL)
      return NULL;

   create_arg.bpp = 32;
   create_arg.width = width;
   create_arg.height = height;

   ret = drmIoctl(dri->base.base.fd, DRM_IOCTL_MODE_CREATE_DUMB, &create_arg);
   if (ret)
      goto free_bo;

   bo->base.base.gbm = gbm;
   bo->base.base.width = width;
   bo->base.base.height = height;
   bo->base.base.stride = create_arg.pitch;
   bo->base.base.format = format;
   bo->base.base.handle.u32 = create_arg.handle;
   bo->handle = create_arg.handle;
   bo->size = create_arg.size;

   memset(&map_arg, 0, sizeof(map_arg));
   map_arg.handle = bo->handle;

   ret = drmIoctl(dri->base.base.fd, DRM_IOCTL_MODE_MAP_DUMB, &map_arg);
   if (ret)
      goto destroy_dumb;

   bo->map = mmap(0, bo->size, PROT_WRITE,
                  MAP_SHARED, dri->base.base.fd, map_arg.offset);
   if (bo->map == MAP_FAILED)
      goto destroy_dumb;

   return &bo->base.base;

destroy_dumb:
   memset(&destroy_arg, 0, sizeof destroy_arg);
   destroy_arg.handle = create_arg.handle;
   drmIoctl(dri->base.base.fd, DRM_IOCTL_MODE_DESTROY_DUMB, &destroy_arg);
free_bo:
   free(bo);

   return NULL;
}

static struct gbm_bo *
gbm_dri_bo_create(struct gbm_device *gbm,
                  uint32_t width, uint32_t height,
                  uint32_t format, uint32_t usage)
{
   struct gbm_dri_device *dri = gbm_dri_device(gbm);
   struct gbm_dri_bo *bo;
   int dri_format;
   unsigned dri_use = 0;

   if (usage & GBM_BO_USE_WRITE)
      return create_dumb(gbm, width, height, format, usage);

   bo = calloc(1, sizeof *bo);
   if (bo == NULL)
      return NULL;

   bo->base.base.gbm = gbm;
   bo->base.base.width = width;
   bo->base.base.height = height;
   bo->base.base.format = format;

   switch (format) {
   case GBM_FORMAT_RGB565:
      dri_format =__DRI_IMAGE_FORMAT_RGB565;
      break;
   case GBM_FORMAT_XRGB8888:
   case GBM_BO_FORMAT_XRGB8888:
      dri_format = __DRI_IMAGE_FORMAT_XRGB8888;
      break;
   case GBM_FORMAT_ARGB8888:
   case GBM_BO_FORMAT_ARGB8888:
      dri_format = __DRI_IMAGE_FORMAT_ARGB8888;
      break;
   case GBM_FORMAT_ABGR8888:
      dri_format = __DRI_IMAGE_FORMAT_ABGR8888;
      break;
   case GBM_FORMAT_ARGB2101010:
      dri_format = __DRI_IMAGE_FORMAT_ARGB2101010;
      break;
   case GBM_FORMAT_XRGB2101010:
      dri_format = __DRI_IMAGE_FORMAT_XRGB2101010;
      break;
   default:
      errno = EINVAL;
      goto failed;
   }

   if (usage & GBM_BO_USE_SCANOUT)
      dri_use |= __DRI_IMAGE_USE_SCANOUT;
   if (usage & GBM_BO_USE_CURSOR_64X64)
      dri_use |= __DRI_IMAGE_USE_CURSOR;

   /* Gallium drivers requires shared in order to get the handle/stride */
   dri_use |= __DRI_IMAGE_USE_SHARE;

   bo->image =
      dri->image->createImage(dri->screen,
                              width, height,
                              dri_format, dri_use,
                              bo);
   if (bo->image == NULL)
      goto failed;

   dri->image->queryImage(bo->image, __DRI_IMAGE_ATTRIB_HANDLE,
                          &bo->base.base.handle.s32);
   dri->image->queryImage(bo->image, __DRI_IMAGE_ATTRIB_STRIDE,
                          (int *) &bo->base.base.stride);

   return &bo->base.base;

failed:
   free(bo);
   return NULL;
}

static struct gbm_surface *
gbm_dri_surface_create(struct gbm_device *gbm,
                       uint32_t width, uint32_t height,
		       uint32_t format, uint32_t flags)
{
   struct gbm_dri_surface *surf;

   surf = calloc(1, sizeof *surf);
   if (surf == NULL)
      return NULL;

   surf->base.gbm = gbm;
   surf->base.width = width;
   surf->base.height = height;
   surf->base.format = format;
   surf->base.flags = flags;

   return &surf->base;
}

static void
gbm_dri_surface_destroy(struct gbm_surface *_surf)
{
   struct gbm_dri_surface *surf = gbm_dri_surface(_surf);

   free(surf);
}

static void
dri_destroy(struct gbm_device *gbm)
{
   struct gbm_dri_device *dri = gbm_dri_device(gbm);

   dri->core->destroyScreen(dri->screen);
   free(dri->driver_configs);
   dlclose(dri->driver);
   free(dri->base.driver_name);

   free(dri);
}

static struct gbm_device *
dri_device_create(int fd)
{
   struct gbm_dri_device *dri;
   int ret;

   dri = calloc(1, sizeof *dri);
   if (!dri)
      return NULL;

   dri->base.base.fd = fd;
   dri->base.base.bo_create = gbm_dri_bo_create;
   dri->base.base.bo_import = gbm_dri_bo_import;
   dri->base.base.is_format_supported = gbm_dri_is_format_supported;
   dri->base.base.bo_write = gbm_dri_bo_write;
   dri->base.base.bo_get_fd = gbm_dri_bo_get_fd;
   dri->base.base.bo_destroy = gbm_dri_bo_destroy;
   dri->base.base.destroy = dri_destroy;
   dri->base.base.surface_create = gbm_dri_surface_create;
   dri->base.base.surface_destroy = gbm_dri_surface_destroy;

   dri->base.type = GBM_DRM_DRIVER_TYPE_DRI;
   dri->base.base.name = "drm";

   ret = dri_screen_create(dri);
   if (ret)
      goto err_dri;

   return &dri->base.base;

err_dri:
   free(dri);

   return NULL;
}

struct gbm_backend gbm_dri_backend = {
   .backend_name = "dri",
   .create_device = dri_device_create,
};
@


1.6
log
@Merge Mesa 10.2.9
@
text
@@


1.5
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d37 1
a126 68
static void
swrast_get_drawable_info(__DRIdrawable *driDrawable,
                         int           *x,
                         int           *y,
                         int           *width,
                         int           *height,
                         void          *loaderPrivate)
{
   struct gbm_dri_surface *surf = loaderPrivate;

   *x = 0;
   *y = 0;
   *width = surf->base.width;
   *height = surf->base.height;
}

static void
swrast_put_image2(__DRIdrawable *driDrawable,
                  int            op,
                  int            x,
                  int            y,
                  int            width,
                  int            height,
                  int            stride,
                  char          *data,
                  void          *loaderPrivate)
{
   struct gbm_dri_surface *surf = loaderPrivate;
   struct gbm_dri_device *dri = gbm_dri_device(surf->base.gbm);

   dri->swrast_put_image2(driDrawable,
                          op, x, y,
                          width, height, stride,
                          data, surf->dri_private);
}

static void
swrast_put_image(__DRIdrawable *driDrawable,
                 int            op,
                 int            x,
                 int            y,
                 int            width,
                 int            height,
                 char          *data,
                 void          *loaderPrivate)
{
   return swrast_put_image2(driDrawable, op, x, y, width, height,
                            width * 4, data, loaderPrivate);
}

static void
swrast_get_image(__DRIdrawable *driDrawable,
                 int            x,
                 int            y,
                 int            width,
                 int            height,
                 char          *data,
                 void          *loaderPrivate)
{
   struct gbm_dri_surface *surf = loaderPrivate;
   struct gbm_dri_device *dri = gbm_dri_device(surf->base.gbm);

   dri->swrast_get_image(driDrawable,
                         x, y,
                         width, height,
                         data, surf->dri_private);
}

a151 9
static const __DRIswrastLoaderExtension swrast_loader_extension = {
   .base = { __DRI_SWRAST_LOADER, 2 },

   .getDrawableInfo = swrast_get_drawable_info,
   .putImage        = swrast_put_image,
   .getImage        = swrast_get_image,
   .putImage2       = swrast_put_image2
};

a156 1
   &swrast_loader_extension.base,
a177 6
static struct dri_extension_match gbm_swrast_device_extensions[] = {
   { __DRI_CORE, 1, offsetof(struct gbm_dri_device, core), },
   { __DRI_SWRAST, 1, offsetof(struct gbm_dri_device, swrast) },
   { NULL, 0, 0 }
};

d206 2
a207 2
static const __DRIextension **
dri_open_driver(struct gbm_dri_device *dri)
a213 1
   /* don't allow setuid apps to use LIBGL_DRIVERS_PATH or GBM_DRIVERS_PATH */
d215 1
a215 3
      /* Read GBM_DRIVERS_PATH first for compatibility, but LIBGL_DRIVERS_PATH
       * is recommended over GBM_DRIVERS_PATH.
       */
a216 7

      /* Read LIBGL_DRIVERS_PATH if GBM_DRIVERS_PATH was not set.
       * LIBGL_DRIVERS_PATH is recommended over GBM_DRIVERS_PATH.
       */
      if (search_paths == NULL) {
         search_paths = getenv("LIBGL_DRIVERS_PATH");
      }
d246 1
a246 1
      fprintf(stderr, "gbm: failed to open any driver (search paths %s)\n",
d248 1
a248 2
      fprintf(stderr, "gbm: Last dlopen error: %s\n", dlerror());
      return NULL;
a266 17
   }

   return extensions;
}

static int
dri_load_driver(struct gbm_dri_device *dri)
{
   const __DRIextension **extensions;

   extensions = dri_open_driver(dri);
   if (!extensions)
      return -1;

   if (dri_bind_extensions(dri, gbm_dri_device_extensions, extensions) < 0) {
      dlclose(dri->driver);
      fprintf(stderr, "failed to bind extensions\n");
a268 1

d271 1
a271 13
   return 0;
}

static int
dri_load_driver_swrast(struct gbm_dri_device *dri)
{
   const __DRIextension **extensions;

   extensions = dri_open_driver(dri);
   if (!extensions)
      return -1;

   if (dri_bind_extensions(dri, gbm_swrast_device_extensions, extensions) < 0) {
a276 2
   dri->driver_extensions = extensions;

d281 1
a281 2
dri_screen_create_dri2(struct gbm_dri_device *dri,
                       const char *driver_name)
d286 1
a286 1
   dri->base.driver_name = driver_name;
a331 66
dri_screen_create_swrast(struct gbm_dri_device *dri)
{
   int ret;

   dri->base.driver_name = strdup("swrast");
   if (dri->base.driver_name == NULL)
      return -1;

   ret = dri_load_driver_swrast(dri);
   if (ret) {
      fprintf(stderr, "failed to load swrast driver\n");
      return ret;
   }

   dri->extensions = gbm_dri_screen_extensions;

   if (dri->swrast == NULL)
      return -1;

   if (dri->swrast->base.version >= 4) {
      dri->screen = dri->swrast->createNewScreen2(0, dri->extensions,
                                                  dri->driver_extensions,
                                                  &dri->driver_configs, dri);
   } else {
      dri->screen = dri->swrast->createNewScreen(0, dri->extensions,
                                                 &dri->driver_configs, dri);
   }
   if (dri->screen == NULL)
      return -1;

   dri->lookup_image = NULL;
   dri->lookup_user_data = NULL;

   return 0;
}

static int
dri_screen_create(struct gbm_dri_device *dri)
{
   const char *driver_name;

   driver_name = loader_get_driver_for_fd(dri->base.base.fd, 0);
   if (!driver_name)
      return -1;

   return dri_screen_create_dri2(dri, driver_name);
}

static int
dri_screen_create_sw(struct gbm_dri_device *dri)
{
   const char *driver_name;
   int ret;

   driver_name = strdup("kms_swrast");
   if (!driver_name)
      return -errno;

   ret = dri_screen_create_dri2(dri, driver_name);
   if (ret == 0)
      return ret;

   return dri_screen_create_swrast(dri);
}

static int
d349 1
a349 1
   if (usage & GBM_BO_USE_CURSOR &&
d396 1
a396 1
      gbm_dri_bo_unmap(bo);
d442 1
a442 1
   if (dri->image == NULL || dri->image->base.version < 4) {
d535 1
a535 1
   if (usage & GBM_BO_USE_CURSOR)
d566 1
a569 1
   int is_cursor, is_scanout;
d571 5
a575 5
   is_cursor = (usage & GBM_BO_USE_CURSOR) != 0 &&
      format == GBM_FORMAT_ARGB8888;
   is_scanout = (usage & GBM_BO_USE_SCANOUT) != 0 &&
      format == GBM_FORMAT_XRGB8888;
   if (!is_cursor && !is_scanout) {
d601 10
a610 1
   if (gbm_dri_bo_map(bo) == NULL)
d635 1
a635 1
   if (usage & GBM_BO_USE_WRITE || dri->image == NULL)
d675 1
a675 1
   if (usage & GBM_BO_USE_CURSOR)
a732 1
   unsigned i;
a734 2
   for (i = 0; dri->driver_configs[i]; i++)
      free((__DRIconfig *) dri->driver_configs[i]);
d746 1
a746 1
   int ret, force_sw;
d766 1
a766 9
   force_sw = getenv("GBM_ALWAYS_SOFTWARE") != NULL;
   if (!force_sw) {
      ret = dri_screen_create(dri);
      if (ret)
         ret = dri_screen_create_sw(dri);
   } else {
      ret = dri_screen_create_sw(dri);
   }

@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@a36 1
#include <sys/mman.h>
d126 68
d219 9
d233 1
d255 6
d289 2
a290 2
static int
dri_load_driver(struct gbm_dri_device *dri)
d297 1
d299 3
a301 1
      /* don't allow setuid apps to use GBM_DRIVERS_PATH */
d303 7
d339 1
a339 1
      fprintf(stderr, "gbm: failed to open any driver (search paths %s)",
d341 2
a342 1
      return -1;
d361 17
d380 1
d383 13
a395 1
   if (dri_bind_extensions(dri, gbm_dri_device_extensions, extensions) < 0) {
d401 2
d407 2
a408 1
dri_screen_create(struct gbm_dri_device *dri)
d413 1
a413 1
   dri->base.driver_name = loader_get_driver_for_fd(dri->base.base.fd, 0);
d459 66
d542 1
a542 1
   if (usage & GBM_BO_USE_CURSOR_64X64 &&
d589 1
a589 1
      munmap(bo->map, bo->size);
d635 1
a635 1
   if (dri->image->base.version < 4) {
d728 1
a728 1
   if (usage & GBM_BO_USE_CURSOR_64X64)
a758 1
   struct drm_mode_map_dumb map_arg;
d762 1
d764 5
a768 5
   if (!(usage & GBM_BO_USE_CURSOR_64X64)) {
      errno = EINVAL;
      return NULL;
   }
   if (format != GBM_FORMAT_ARGB8888) {
d794 1
a794 10
   memset(&map_arg, 0, sizeof(map_arg));
   map_arg.handle = bo->handle;

   ret = drmIoctl(dri->base.base.fd, DRM_IOCTL_MODE_MAP_DUMB, &map_arg);
   if (ret)
      goto destroy_dumb;

   bo->map = mmap(0, bo->size, PROT_WRITE,
                  MAP_SHARED, dri->base.base.fd, map_arg.offset);
   if (bo->map == MAP_FAILED)
d819 1
a819 1
   if (usage & GBM_BO_USE_WRITE)
d859 1
a859 1
   if (usage & GBM_BO_USE_CURSOR_64X64)
d917 1
d920 2
d933 1
a933 1
   int ret;
d953 9
a961 1
   ret = dri_screen_create(dri);
@


1.3
log
@Merge Mesa 9.2.3
ok mpi@@ kettenis@@
@
text
@d33 1
d48 1
d109 18
d128 1
a128 1
   { __DRI_USE_INVALIDATE, 1 }
d132 18
a149 2
   { __DRI_IMAGE_LOOKUP, 1 },
   dri_lookup_egl_image
d152 6
a157 5
const __DRIdri2LoaderExtension dri2_loader_extension = {
   { __DRI_DRI2_LOADER, 3 },
   dri_get_buffers,
   dri_flush_front_buffer,
   dri_get_buffers_with_format,
d209 1
a209 1
   const __DRIextension **extensions;
d211 1
a238 2
         if (dri->driver == NULL)
            fprintf(stderr, "failed to open %s: %s\n", path, dlerror());
d240 3
d251 13
a263 1
   extensions = dlsym(dri->driver, __DRI_DRIVER_EXTENSIONS);
d269 1
a269 1

d286 1
a286 1
   dri->base.driver_name = dri_fd_get_driver_name(dri->base.base.fd);
d296 1
a296 4
   dri->extensions[0] = &image_lookup_extension.base;
   dri->extensions[1] = &use_invalidate.base;
   dri->extensions[2] = &dri2_loader_extension.base;
   dri->extensions[3] = NULL;
d301 10
a310 3
   dri->screen = dri->dri2->createNewScreen(0, dri->base.base.fd,
                                            dri->extensions,
                                            &dri->driver_configs, dri);
d361 2
a362 1
   if (bo->image != NULL)
d364 1
d371 15
d442 2
a443 1
   if (dri->image->base.version < 4)
d445 1
d451 1
a451 1
      struct wl_drm_buffer *wb = (struct wl_drm_buffer *) buffer;
d453 2
a454 1
      if (dri->wl_drm == NULL)
d456 1
d458 3
a460 1
      if (!wayland_buffer_is_drm(dri->wl_drm, buffer))
d462 1
d464 1
a464 1
      image = wb->driver_buffer;
d473 3
d489 2
a490 1
      if (dri->lookup_image == NULL)
d492 1
d495 1
d498 2
a499 1
      if (gbm_format == 0)
d501 17
d522 1
d531 1
a531 1
   bo->image = dri->image->dupImage(image, NULL);
d539 1
d571 2
a572 1
   if (!(usage & GBM_BO_USE_CURSOR_64X64))
d574 3
a576 1
   if (format != GBM_FORMAT_ARGB8888)
d578 1
d662 6
d669 2
a670 1
      return NULL;
d687 1
a687 1
      return NULL;
d695 4
d749 2
d757 1
@


1.2
log
@Merge Mesa 9.2.0
@
text
@d379 4
a382 1
      if (!wayland_buffer_is_drm(buffer))
@


1.1
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d36 1
d39 1
d48 5
d64 44
a107 1
const __DRIuseInvalidateExtension use_invalidate = {
d111 1
a111 1
const __DRIimageLookupExtension image_lookup_extension = {
d116 7
d130 1
d247 2
a248 1
   dri->extensions[2] = NULL;
d256 2
d278 1
a278 1
                            enum gbm_bo_format format,
d283 1
d286 1
d301 13
d319 10
a329 1
   dri->image->destroyImage(bo->image);
d333 26
d360 2
a361 4
gbm_dri_bo_create_from_egl_image(struct gbm_device *gbm,
                                 void *egl_dpy, void *egl_img,
                                 uint32_t width, uint32_t height,
                                 uint32_t usage)
d365 53
a418 1
   (void) egl_dpy;
d420 46
a465 1
   if (dri->lookup_image == NULL)
d472 8
d483 17
d501 1
a501 2
   __DRIimage *tmp = dri->lookup_image(dri->screen, egl_img,
                                       dri->lookup_user_data);
d503 6
a508 8
   bo->image = dri->image->dupImage(tmp, bo);
   if (bo->image == NULL)
      return NULL;
   
   dri->image->queryImage(bo->image, __DRI_IMAGE_ATTRIB_HANDLE,
                          &bo->base.base.handle.s32);
   dri->image->queryImage(bo->image, __DRI_IMAGE_ATTRIB_STRIDE,
                          (int *) &bo->base.base.pitch);
d510 1
a510 1
   return &bo->base.base;
d516 1
a516 1
                  enum gbm_bo_format format, uint32_t usage)
d523 3
d533 1
d536 4
d543 1
d547 3
d559 3
d573 1
a573 1
                          (int *) &bo->base.base.pitch);
d578 28
d629 1
a629 1
   dri->base.base.bo_create_from_egl_image = gbm_dri_bo_create_from_egl_image;
d631 1
d634 2
d641 2
a642 4
   if (ret) {
      free(dri);
      return NULL;
   }
d645 5
@


1.1.1.1
log
@Import Mesa 9.2.0
@
text
@a35 1
#include <sys/mman.h>
a37 1
#include <xf86drm.h>
a45 5
/* For importing wl_buffer */
#if HAVE_WAYLAND_PLATFORM
#include "../../../egl/wayland/wayland-drm/wayland-drm.h"
#endif

d57 1
a57 44
static __DRIbuffer *
dri_get_buffers(__DRIdrawable * driDrawable,
		 int *width, int *height,
		 unsigned int *attachments, int count,
		 int *out_count, void *data)
{
   struct gbm_dri_surface *surf = data;
   struct gbm_dri_device *dri = gbm_dri_device(surf->base.gbm);

   if (dri->get_buffers == NULL)
      return NULL;

   return dri->get_buffers(driDrawable, width, height, attachments,
                           count, out_count, surf->dri_private);
}

static void
dri_flush_front_buffer(__DRIdrawable * driDrawable, void *data)
{
   struct gbm_dri_surface *surf = data;
   struct gbm_dri_device *dri = gbm_dri_device(surf->base.gbm);

   if (dri->flush_front_buffer != NULL)
      dri->flush_front_buffer(driDrawable, surf->dri_private);
}

static __DRIbuffer *
dri_get_buffers_with_format(__DRIdrawable * driDrawable,
                            int *width, int *height,
                            unsigned int *attachments, int count,
                            int *out_count, void *data)
{
   struct gbm_dri_surface *surf = data;
   struct gbm_dri_device *dri = gbm_dri_device(surf->base.gbm);

   if (dri->get_buffers_with_format == NULL)
      return NULL;

   return
      dri->get_buffers_with_format(driDrawable, width, height, attachments,
                                   count, out_count, surf->dri_private);
}

static const __DRIuseInvalidateExtension use_invalidate = {
d61 1
a61 1
static const __DRIimageLookupExtension image_lookup_extension = {
a65 7
const __DRIdri2LoaderExtension dri2_loader_extension = {
   { __DRI_DRI2_LOADER, 3 },
   dri_get_buffers,
   dri_flush_front_buffer,
   dri_get_buffers_with_format,
};

a72 1
   { __DRI2_FLUSH, 1, offsetof(struct gbm_dri_device, flush) },
d189 1
a189 2
   dri->extensions[2] = &dri2_loader_extension.base;
   dri->extensions[3] = NULL;
a196 2
   if (dri->screen == NULL)
      return -1;
d217 1
a217 1
                            uint32_t format,
a221 1
   case GBM_FORMAT_XRGB8888:
a223 1
   case GBM_FORMAT_ARGB8888:
a237 13
static int
gbm_dri_bo_write(struct gbm_bo *_bo, const void *buf, size_t count)
{
   struct gbm_dri_bo *bo = gbm_dri_bo(_bo);

   if (bo->image != NULL)
      return -1;

   memcpy(bo->map, buf, count);

   return 0;
}

a242 10
   struct drm_mode_destroy_dumb arg;

   if (bo->image != NULL) {
      dri->image->destroyImage(bo->image);
   } else {
      munmap(bo->map, bo->size);
      memset(&arg, 0, sizeof(arg));
      arg.handle = bo->handle;
      drmIoctl(dri->base.base.fd, DRM_IOCTL_MODE_DESTROY_DUMB, &arg);
   }
d244 1
a247 26
static uint32_t
gbm_dri_to_gbm_format(uint32_t dri_format)
{
   uint32_t ret = 0;

   switch (dri_format) {
   case __DRI_IMAGE_FORMAT_RGB565:
      ret = GBM_FORMAT_RGB565;
      break;
   case __DRI_IMAGE_FORMAT_XRGB8888:
      ret = GBM_FORMAT_XRGB8888;
      break;
   case __DRI_IMAGE_FORMAT_ARGB8888:
      ret = GBM_FORMAT_ARGB8888;
      break;
   case __DRI_IMAGE_FORMAT_ABGR8888:
      ret = GBM_FORMAT_ABGR8888;
      break;
   default:
      ret = 0;
      break;
   }

   return ret;
}

d249 4
a252 2
gbm_dri_bo_import(struct gbm_device *gbm,
                  uint32_t type, void *buffer, uint32_t usage)
a255 3
   __DRIimage *image;
   unsigned dri_use = 0;
   int gbm_format;
d257 1
a257 3
   /* Required for query image WIDTH & HEIGHT */
   if (dri->image->base.version < 4)
      return NULL;
d259 1
a259 43
   switch (type) {
#if HAVE_WAYLAND_PLATFORM
   case GBM_BO_IMPORT_WL_BUFFER:
   {
      struct wl_drm_buffer *wb = (struct wl_drm_buffer *) buffer;

      if (!wayland_buffer_is_drm(buffer))
         return NULL;

      image = wb->driver_buffer;

      switch (wb->format) {
      case WL_DRM_FORMAT_XRGB8888:
         gbm_format = GBM_FORMAT_XRGB8888;
         break;
      case WL_DRM_FORMAT_ARGB8888:
         gbm_format = GBM_FORMAT_ARGB8888;
         break;
      case WL_DRM_FORMAT_YUYV:
         gbm_format = GBM_FORMAT_YUYV;
         break;
      default:
         return NULL;
      }
      break;
   }
#endif

   case GBM_BO_IMPORT_EGL_IMAGE:
   {
      int dri_format;
      if (dri->lookup_image == NULL)
         return NULL;

      image = dri->lookup_image(dri->screen, buffer, dri->lookup_user_data);
      dri->image->queryImage(image, __DRI_IMAGE_ATTRIB_FORMAT, &dri_format);
      gbm_format = gbm_dri_to_gbm_format(dri_format);
      if (gbm_format == 0)
         return NULL;
      break;
   }

   default:
a260 2
   }

d266 3
a268 1
   bo->image = dri->image->dupImage(image, NULL);
d270 5
a274 7
   if (usage & GBM_BO_USE_SCANOUT)
      dri_use |= __DRI_IMAGE_USE_SCANOUT;
   if (usage & GBM_BO_USE_CURSOR_64X64)
      dri_use |= __DRI_IMAGE_USE_CURSOR;
   if (dri->image->base.version >= 2 &&
       !dri->image->validateUsage(bo->image, dri_use)) {
      free(bo);
d276 1
a276 11
   }

   bo->base.base.gbm = gbm;
   bo->base.base.format = gbm_format;

   dri->image->queryImage(bo->image, __DRI_IMAGE_ATTRIB_WIDTH,
                          (int*)&bo->base.base.width);
   dri->image->queryImage(bo->image, __DRI_IMAGE_ATTRIB_HEIGHT,
                          (int*)&bo->base.base.height);
   dri->image->queryImage(bo->image, __DRI_IMAGE_ATTRIB_STRIDE,
                          (int*)&bo->base.base.stride);
d279 2
a285 62
create_dumb(struct gbm_device *gbm,
                  uint32_t width, uint32_t height,
                  uint32_t format, uint32_t usage)
{
   struct gbm_dri_device *dri = gbm_dri_device(gbm);
   struct drm_mode_create_dumb create_arg;
   struct drm_mode_map_dumb map_arg;
   struct gbm_dri_bo *bo;
   struct drm_mode_destroy_dumb destroy_arg;
   int ret;

   if (!(usage & GBM_BO_USE_CURSOR_64X64))
      return NULL;
   if (format != GBM_FORMAT_ARGB8888)
      return NULL;

   bo = calloc(1, sizeof *bo);
   if (bo == NULL)
      return NULL;

   create_arg.bpp = 32;
   create_arg.width = width;
   create_arg.height = height;

   ret = drmIoctl(dri->base.base.fd, DRM_IOCTL_MODE_CREATE_DUMB, &create_arg);
   if (ret)
      goto free_bo;

   bo->base.base.gbm = gbm;
   bo->base.base.width = width;
   bo->base.base.height = height;
   bo->base.base.stride = create_arg.pitch;
   bo->base.base.format = format;
   bo->base.base.handle.u32 = create_arg.handle;
   bo->handle = create_arg.handle;
   bo->size = create_arg.size;

   memset(&map_arg, 0, sizeof(map_arg));
   map_arg.handle = bo->handle;

   ret = drmIoctl(dri->base.base.fd, DRM_IOCTL_MODE_MAP_DUMB, &map_arg);
   if (ret)
      goto destroy_dumb;

   bo->map = mmap(0, bo->size, PROT_WRITE,
                  MAP_SHARED, dri->base.base.fd, map_arg.offset);
   if (bo->map == MAP_FAILED)
      goto destroy_dumb;

   return &bo->base.base;

destroy_dumb:
   memset(&destroy_arg, 0, sizeof destroy_arg);
   destroy_arg.handle = create_arg.handle;
   drmIoctl(dri->base.base.fd, DRM_IOCTL_MODE_DESTROY_DUMB, &destroy_arg);
free_bo:
   free(bo);

   return NULL;
}

static struct gbm_bo *
d288 1
a288 1
                  uint32_t format, uint32_t usage)
a294 3
   if (usage & GBM_BO_USE_WRITE)
      return create_dumb(gbm, width, height, format, usage);

a301 1
   bo->base.base.format = format;
a303 4
   case GBM_FORMAT_RGB565:
      dri_format =__DRI_IMAGE_FORMAT_RGB565;
      break;
   case GBM_FORMAT_XRGB8888:
a306 1
   case GBM_FORMAT_ARGB8888:
a309 3
   case GBM_FORMAT_ABGR8888:
      dri_format = __DRI_IMAGE_FORMAT_ABGR8888;
      break;
a318 3
   /* Gallium drivers requires shared in order to get the handle/stride */
   dri_use |= __DRI_IMAGE_USE_SHARE;

d330 1
a330 1
                          (int *) &bo->base.base.stride);
a334 28
static struct gbm_surface *
gbm_dri_surface_create(struct gbm_device *gbm,
                       uint32_t width, uint32_t height,
		       uint32_t format, uint32_t flags)
{
   struct gbm_dri_surface *surf;

   surf = calloc(1, sizeof *surf);
   if (surf == NULL)
      return NULL;

   surf->base.gbm = gbm;
   surf->base.width = width;
   surf->base.height = height;
   surf->base.format = format;
   surf->base.flags = flags;

   return &surf->base;
}

static void
gbm_dri_surface_destroy(struct gbm_surface *_surf)
{
   struct gbm_dri_surface *surf = gbm_dri_surface(_surf);

   free(surf);
}

d358 1
a358 1
   dri->base.base.bo_import = gbm_dri_bo_import;
a359 1
   dri->base.base.bo_write = gbm_dri_bo_write;
a361 2
   dri->base.base.surface_create = gbm_dri_surface_create;
   dri->base.base.surface_destroy = gbm_dri_surface_destroy;
d367 4
a370 2
   if (ret)
      goto err_dri;
a372 5

err_dri:
   free(dri);

   return NULL;
@


1.1.1.2
log
@Import Mesa 9.2.3
@
text
@d379 1
a379 4
      if (dri->wl_drm == NULL)
         return NULL;

      if (!wayland_buffer_is_drm(dri->wl_drm, buffer))
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@a32 1
#include <errno.h>
a46 1
#include "loader.h"
a106 18
static int
image_get_buffers(__DRIdrawable *driDrawable,
                  unsigned int format,
                  uint32_t *stamp,
                  void *loaderPrivate,
                  uint32_t buffer_mask,
                  struct __DRIimageList *buffers)
{
   struct gbm_dri_surface *surf = loaderPrivate;
   struct gbm_dri_device *dri = gbm_dri_device(surf->base.gbm);

   if (dri->image_get_buffers == NULL)
      return 0;

   return dri->image_get_buffers(driDrawable, format, stamp,
                                 surf->dri_private, buffer_mask, buffers);
}

d108 1
a108 1
   .base = { __DRI_USE_INVALIDATE, 1 }
d112 2
a113 18
   .base = { __DRI_IMAGE_LOOKUP, 1 },

   .lookupEGLImage          = dri_lookup_egl_image
};

static const __DRIdri2LoaderExtension dri2_loader_extension = {
   .base = { __DRI_DRI2_LOADER, 3 },

   .getBuffers              = dri_get_buffers,
   .flushFrontBuffer        = dri_flush_front_buffer,
   .getBuffersWithFormat    = dri_get_buffers_with_format,
};

static const __DRIimageLoaderExtension image_loader_extension = {
   .base = { __DRI_IMAGE_LOADER, 1 },

   .getBuffers          = image_get_buffers,
   .flushFrontBuffer    = dri_flush_front_buffer,
d116 5
a120 6
static const __DRIextension *gbm_dri_screen_extensions[] = {
   &image_lookup_extension.base,
   &use_invalidate.base,
   &dri2_loader_extension.base,
   &image_loader_extension.base,
   NULL,
d172 1
a172 1
   const __DRIextension **extensions = NULL;
a173 1
   char *get_extensions_name;
d201 2
a203 3
      /* not need continue to loop all paths once the driver is found */
      if (dri->driver != NULL)
         break;
d212 1
a212 13
   if (asprintf(&get_extensions_name, "%s_%s",
                __DRI_DRIVER_GET_EXTENSIONS, dri->base.driver_name) != -1) {
      const __DRIextension **(*get_extensions)(void);

      get_extensions = dlsym(dri->driver, get_extensions_name);
      free(get_extensions_name);

      if (get_extensions)
         extensions = get_extensions();
   }

   if (!extensions)
      extensions = dlsym(dri->driver, __DRI_DRIVER_EXTENSIONS);
d218 1
a218 1
   dri->driver_extensions = extensions;
d235 1
a235 1
   dri->base.driver_name = loader_get_driver_for_fd(dri->base.base.fd, 0);
d245 4
a248 1
   dri->extensions = gbm_dri_screen_extensions;
d253 3
a255 10
   if (dri->dri2->base.version >= 4) {
      dri->screen = dri->dri2->createNewScreen2(0, dri->base.base.fd,
                                                dri->extensions,
                                                dri->driver_extensions,
                                                &dri->driver_configs, dri);
   } else {
      dri->screen = dri->dri2->createNewScreen(0, dri->base.base.fd,
                                               dri->extensions,
                                               &dri->driver_configs, dri);
   }
d306 1
a306 2
   if (bo->image != NULL) {
      errno = EINVAL;
a307 1
   }
a313 15
static int
gbm_dri_bo_get_fd(struct gbm_bo *_bo)
{
   struct gbm_dri_device *dri = gbm_dri_device(_bo->gbm);
   struct gbm_dri_bo *bo = gbm_dri_bo(_bo);
   int fd;

   if (bo->image == NULL)
      return -1;

   dri->image->queryImage(bo->image, __DRI_IMAGE_ATTRIB_FD, &fd);

   return fd;
}

d370 1
a370 2
   if (dri->image->base.version < 4) {
      errno = ENOSYS;
a371 1
   }
d377 1
a377 1
      struct wl_drm_buffer *wb;
d379 1
a379 2
      if (!dri->wl_drm) {
         errno = EINVAL;
a380 1
      }
d382 1
a382 3
      wb = wayland_drm_buffer_get(dri->wl_drm, (struct wl_resource *) buffer);
      if (!wb) {
         errno = EINVAL;
a383 1
      }
d385 1
a385 1
      image = dri->image->dupImage(wb->driver_buffer, NULL);
a393 3
      case WL_DRM_FORMAT_RGB565:
         gbm_format = GBM_FORMAT_RGB565;
         break;
d407 1
a407 2
      if (dri->lookup_image == NULL) {
         errno = EINVAL;
a408 1
      }
a410 1
      image = dri->image->dupImage(image, NULL);
d413 1
a413 2
      if (gbm_format == 0) {
         errno = EINVAL;
a414 17
      }
      break;
   }

   case GBM_BO_IMPORT_FD:
   {
      struct gbm_import_fd_data *fd_data = buffer;
      int stride = fd_data->stride, offset = 0;

      image = dri->image->createImageFromFds(dri->screen,
                                             fd_data->width,
                                             fd_data->height,
                                             fd_data->format,
                                             &fd_data->fd, 1,
                                             &stride, &offset,
                                             NULL);
      gbm_format = fd_data->format;
a418 1
      errno = ENOSYS;
d427 1
a427 1
   bo->image = image;
a434 1
      errno = EINVAL;
d466 1
a466 2
   if (!(usage & GBM_BO_USE_CURSOR_64X64)) {
      errno = EINVAL;
d468 1
a468 3
   }
   if (format != GBM_FORMAT_ARGB8888) {
      errno = EINVAL;
a469 1
   }
a552 6
   case GBM_FORMAT_ARGB2101010:
      dri_format = __DRI_IMAGE_FORMAT_ARGB2101010;
      break;
   case GBM_FORMAT_XRGB2101010:
      dri_format = __DRI_IMAGE_FORMAT_XRGB2101010;
      break;
d554 1
a554 2
      errno = EINVAL;
      goto failed;
d571 1
a571 1
      goto failed;
a578 4

failed:
   free(bo);
   return NULL;
a628 2
   if (!dri)
      return NULL;
a634 1
   dri->base.base.bo_get_fd = gbm_dri_bo_get_fd;
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d37 1
a126 68
static void
swrast_get_drawable_info(__DRIdrawable *driDrawable,
                         int           *x,
                         int           *y,
                         int           *width,
                         int           *height,
                         void          *loaderPrivate)
{
   struct gbm_dri_surface *surf = loaderPrivate;

   *x = 0;
   *y = 0;
   *width = surf->base.width;
   *height = surf->base.height;
}

static void
swrast_put_image2(__DRIdrawable *driDrawable,
                  int            op,
                  int            x,
                  int            y,
                  int            width,
                  int            height,
                  int            stride,
                  char          *data,
                  void          *loaderPrivate)
{
   struct gbm_dri_surface *surf = loaderPrivate;
   struct gbm_dri_device *dri = gbm_dri_device(surf->base.gbm);

   dri->swrast_put_image2(driDrawable,
                          op, x, y,
                          width, height, stride,
                          data, surf->dri_private);
}

static void
swrast_put_image(__DRIdrawable *driDrawable,
                 int            op,
                 int            x,
                 int            y,
                 int            width,
                 int            height,
                 char          *data,
                 void          *loaderPrivate)
{
   return swrast_put_image2(driDrawable, op, x, y, width, height,
                            width * 4, data, loaderPrivate);
}

static void
swrast_get_image(__DRIdrawable *driDrawable,
                 int            x,
                 int            y,
                 int            width,
                 int            height,
                 char          *data,
                 void          *loaderPrivate)
{
   struct gbm_dri_surface *surf = loaderPrivate;
   struct gbm_dri_device *dri = gbm_dri_device(surf->base.gbm);

   dri->swrast_get_image(driDrawable,
                         x, y,
                         width, height,
                         data, surf->dri_private);
}

a151 9
static const __DRIswrastLoaderExtension swrast_loader_extension = {
   .base = { __DRI_SWRAST_LOADER, 2 },

   .getDrawableInfo = swrast_get_drawable_info,
   .putImage        = swrast_put_image,
   .getImage        = swrast_get_image,
   .putImage2       = swrast_put_image2
};

a156 1
   &swrast_loader_extension.base,
a177 6
static struct dri_extension_match gbm_swrast_device_extensions[] = {
   { __DRI_CORE, 1, offsetof(struct gbm_dri_device, core), },
   { __DRI_SWRAST, 1, offsetof(struct gbm_dri_device, swrast) },
   { NULL, 0, 0 }
};

d206 2
a207 2
static const __DRIextension **
dri_open_driver(struct gbm_dri_device *dri)
a213 1
   /* don't allow setuid apps to use LIBGL_DRIVERS_PATH or GBM_DRIVERS_PATH */
d215 1
a215 3
      /* Read GBM_DRIVERS_PATH first for compatibility, but LIBGL_DRIVERS_PATH
       * is recommended over GBM_DRIVERS_PATH.
       */
a216 7

      /* Read LIBGL_DRIVERS_PATH if GBM_DRIVERS_PATH was not set.
       * LIBGL_DRIVERS_PATH is recommended over GBM_DRIVERS_PATH.
       */
      if (search_paths == NULL) {
         search_paths = getenv("LIBGL_DRIVERS_PATH");
      }
d246 1
a246 1
      fprintf(stderr, "gbm: failed to open any driver (search paths %s)\n",
d248 1
a248 2
      fprintf(stderr, "gbm: Last dlopen error: %s\n", dlerror());
      return NULL;
a266 17
   }

   return extensions;
}

static int
dri_load_driver(struct gbm_dri_device *dri)
{
   const __DRIextension **extensions;

   extensions = dri_open_driver(dri);
   if (!extensions)
      return -1;

   if (dri_bind_extensions(dri, gbm_dri_device_extensions, extensions) < 0) {
      dlclose(dri->driver);
      fprintf(stderr, "failed to bind extensions\n");
a268 1

d271 1
a271 13
   return 0;
}

static int
dri_load_driver_swrast(struct gbm_dri_device *dri)
{
   const __DRIextension **extensions;

   extensions = dri_open_driver(dri);
   if (!extensions)
      return -1;

   if (dri_bind_extensions(dri, gbm_swrast_device_extensions, extensions) < 0) {
a276 2
   dri->driver_extensions = extensions;

d281 1
a281 2
dri_screen_create_dri2(struct gbm_dri_device *dri,
                       const char *driver_name)
d286 1
a286 1
   dri->base.driver_name = driver_name;
a331 66
dri_screen_create_swrast(struct gbm_dri_device *dri)
{
   int ret;

   dri->base.driver_name = strdup("swrast");
   if (dri->base.driver_name == NULL)
      return -1;

   ret = dri_load_driver_swrast(dri);
   if (ret) {
      fprintf(stderr, "failed to load swrast driver\n");
      return ret;
   }

   dri->extensions = gbm_dri_screen_extensions;

   if (dri->swrast == NULL)
      return -1;

   if (dri->swrast->base.version >= 4) {
      dri->screen = dri->swrast->createNewScreen2(0, dri->extensions,
                                                  dri->driver_extensions,
                                                  &dri->driver_configs, dri);
   } else {
      dri->screen = dri->swrast->createNewScreen(0, dri->extensions,
                                                 &dri->driver_configs, dri);
   }
   if (dri->screen == NULL)
      return -1;

   dri->lookup_image = NULL;
   dri->lookup_user_data = NULL;

   return 0;
}

static int
dri_screen_create(struct gbm_dri_device *dri)
{
   const char *driver_name;

   driver_name = loader_get_driver_for_fd(dri->base.base.fd, 0);
   if (!driver_name)
      return -1;

   return dri_screen_create_dri2(dri, driver_name);
}

static int
dri_screen_create_sw(struct gbm_dri_device *dri)
{
   const char *driver_name;
   int ret;

   driver_name = strdup("kms_swrast");
   if (!driver_name)
      return -errno;

   ret = dri_screen_create_dri2(dri, driver_name);
   if (ret == 0)
      return ret;

   return dri_screen_create_swrast(dri);
}

static int
d349 1
a349 1
   if (usage & GBM_BO_USE_CURSOR &&
d396 1
a396 1
      gbm_dri_bo_unmap(bo);
d442 1
a442 1
   if (dri->image == NULL || dri->image->base.version < 4) {
d535 1
a535 1
   if (usage & GBM_BO_USE_CURSOR)
d566 1
a569 1
   int is_cursor, is_scanout;
d571 5
a575 5
   is_cursor = (usage & GBM_BO_USE_CURSOR) != 0 &&
      format == GBM_FORMAT_ARGB8888;
   is_scanout = (usage & GBM_BO_USE_SCANOUT) != 0 &&
      format == GBM_FORMAT_XRGB8888;
   if (!is_cursor && !is_scanout) {
d601 10
a610 1
   if (gbm_dri_bo_map(bo) == NULL)
d635 1
a635 1
   if (usage & GBM_BO_USE_WRITE || dri->image == NULL)
d675 1
a675 1
   if (usage & GBM_BO_USE_CURSOR)
a732 1
   unsigned i;
a734 2
   for (i = 0; dri->driver_configs[i]; i++)
      free((__DRIconfig *) dri->driver_configs[i]);
d746 1
a746 1
   int ret, force_sw;
d766 1
a766 9
   force_sw = getenv("GBM_ALWAYS_SOFTWARE") != NULL;
   if (!force_sw) {
      ret = dri_screen_create(dri);
      if (ret)
         ret = dri_screen_create_sw(dri);
   } else {
      ret = dri_screen_create_sw(dri);
   }

@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@a36 1
#include <sys/mman.h>
d126 68
d219 9
d233 1
d255 6
d289 2
a290 2
static int
dri_load_driver(struct gbm_dri_device *dri)
d297 1
d299 3
a301 1
      /* don't allow setuid apps to use GBM_DRIVERS_PATH */
d303 7
d339 1
a339 1
      fprintf(stderr, "gbm: failed to open any driver (search paths %s)",
d341 2
a342 1
      return -1;
d361 17
d380 1
d383 13
a395 1
   if (dri_bind_extensions(dri, gbm_dri_device_extensions, extensions) < 0) {
d401 2
d407 2
a408 1
dri_screen_create(struct gbm_dri_device *dri)
d413 1
a413 1
   dri->base.driver_name = loader_get_driver_for_fd(dri->base.base.fd, 0);
d459 66
d542 1
a542 1
   if (usage & GBM_BO_USE_CURSOR_64X64 &&
d589 1
a589 1
      munmap(bo->map, bo->size);
d635 1
a635 1
   if (dri->image->base.version < 4) {
d728 1
a728 1
   if (usage & GBM_BO_USE_CURSOR_64X64)
a758 1
   struct drm_mode_map_dumb map_arg;
d762 1
d764 5
a768 5
   if (!(usage & GBM_BO_USE_CURSOR_64X64)) {
      errno = EINVAL;
      return NULL;
   }
   if (format != GBM_FORMAT_ARGB8888) {
d794 1
a794 10
   memset(&map_arg, 0, sizeof(map_arg));
   map_arg.handle = bo->handle;

   ret = drmIoctl(dri->base.base.fd, DRM_IOCTL_MODE_MAP_DUMB, &map_arg);
   if (ret)
      goto destroy_dumb;

   bo->map = mmap(0, bo->size, PROT_WRITE,
                  MAP_SHARED, dri->base.base.fd, map_arg.offset);
   if (bo->map == MAP_FAILED)
d819 1
a819 1
   if (usage & GBM_BO_USE_WRITE)
d859 1
a859 1
   if (usage & GBM_BO_USE_CURSOR_64X64)
d917 1
d920 2
d933 1
a933 1
   int ret;
d953 9
a961 1
   ret = dri_screen_create(dri);
@


