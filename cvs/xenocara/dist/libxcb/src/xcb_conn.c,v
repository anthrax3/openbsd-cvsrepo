head	1.10;
access;
symbols
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.9.0.8
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.6
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.7.0.6
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.4
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.6
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	v1_2:1.1.1.1
	XCB:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2016.09.02.10.09.43;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	mKDGsTNpiR2zRHYQ;

1.9
date	2015.01.26.21.32.11;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	01TEvO4uNHLqFv7N;

1.8
date	2014.04.14.19.02.17;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.11.22.20.31.32;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2012.03.27.19.14.21;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.10.06.07.50.06;	author dcoppa;	state Exp;
branches;
next	1.4;

1.4
date	2010.09.04.10.00.58;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.04.18.20.06.18;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.05.31.16.44.43;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2009.05.22.15.56.12;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2009.05.22.15.56.12;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Update to xcb-proto/libxcb 1.12. "Just commit it" naddy@@
@
text
@/* Copyright (C) 2001-2004 Bart Massey and Jamey Sharp.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 * Except as contained in this notice, the names of the authors or their
 * institutions shall not be used in advertising or otherwise to promote the
 * sale, use or other dealings in this Software without prior written
 * authorization from the authors.
 */

/* Connection management: the core of XCB. */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <assert.h>
#include <string.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <fcntl.h>
#include <errno.h>
#include <limits.h>

#include "xcb.h"
#include "xcbint.h"
#if USE_POLL
#include <poll.h>
#elif !defined _WIN32
#include <sys/select.h>
#endif

#ifdef _WIN32
#include "xcb_windefs.h"
#else
#include <sys/socket.h>
#include <netinet/in.h>
#endif /* _WIN32 */

/* SHUT_RDWR is fairly recent and is not available on all platforms */
#if !defined(SHUT_RDWR)
#define SHUT_RDWR 2
#endif

typedef struct {
    uint8_t  status;
    uint8_t  pad0[5];
    uint16_t length;
} xcb_setup_generic_t;

static const xcb_setup_t xcb_error_setup = {
    0,     /* status: failed (but we wouldn't have a xcb_setup_t in this case) */
    0,     /* pad0 */
    0, 0,  /* protocol version, should be 11.0, but isn't */
    0,     /* length, invalid value */
    0,     /* release_number */
    0, 0,  /* resource_id_{base,mask} */
    0,     /* motion_buffer_size */
    0,     /* vendor_len */
    0,     /* maximum_request_length */
    0,     /* roots_len */
    0,     /* pixmap_formats_len */
    0,     /* image_byte_order */
    0,     /* bitmap_format_bit_order */
    0,     /* bitmap_format_scanline_unit */
    0,     /* bitmap_format_scanline_pad */
    0, 0,  /* {min,max}_keycode */
    { 0, 0, 0, 0 } /* pad1 */
};

/* Keep this list in sync with is_static_error_conn()! */
static const int xcb_con_error = XCB_CONN_ERROR;
static const int xcb_con_closed_mem_er = XCB_CONN_CLOSED_MEM_INSUFFICIENT;
static const int xcb_con_closed_parse_er = XCB_CONN_CLOSED_PARSE_ERR;
static const int xcb_con_closed_screen_er = XCB_CONN_CLOSED_INVALID_SCREEN;

static int is_static_error_conn(xcb_connection_t *c)
{
    return c == (xcb_connection_t *) &xcb_con_error ||
           c == (xcb_connection_t *) &xcb_con_closed_mem_er ||
           c == (xcb_connection_t *) &xcb_con_closed_parse_er ||
           c == (xcb_connection_t *) &xcb_con_closed_screen_er;
}

static int set_fd_flags(const int fd)
{
/* Win32 doesn't have file descriptors and the fcntl function. This block sets the socket in non-blocking mode */

#ifdef _WIN32
   u_long iMode = 1; /* non-zero puts it in non-blocking mode, 0 in blocking mode */
   int ret = 0;

   ret = ioctlsocket(fd, FIONBIO, &iMode);
   if(ret != 0)
       return 0;
   return 1;
#else
    int flags = fcntl(fd, F_GETFL, 0);
    if(flags == -1)
        return 0;
    flags |= O_NONBLOCK;
    if(fcntl(fd, F_SETFL, flags) == -1)
        return 0;
    if(fcntl(fd, F_SETFD, FD_CLOEXEC) == -1)
        return 0;
    return 1;
#endif /* _WIN32 */
}

static int write_setup(xcb_connection_t *c, xcb_auth_info_t *auth_info)
{
    static const char pad[3];
    xcb_setup_request_t out;
    struct iovec parts[6];
    int count = 0;
    static const uint32_t endian = 0x01020304;
    int ret;

    memset(&out, 0, sizeof(out));

    /* B = 0x42 = MSB first, l = 0x6c = LSB first */
    if(htonl(endian) == endian)
        out.byte_order = 0x42;
    else
        out.byte_order = 0x6c;
    out.protocol_major_version = X_PROTOCOL;
    out.protocol_minor_version = X_PROTOCOL_REVISION;
    out.authorization_protocol_name_len = 0;
    out.authorization_protocol_data_len = 0;
    parts[count].iov_len = sizeof(xcb_setup_request_t);
    parts[count++].iov_base = &out;
    parts[count].iov_len = XCB_PAD(sizeof(xcb_setup_request_t));
    parts[count++].iov_base = (char *) pad;

    if(auth_info)
    {
        parts[count].iov_len = out.authorization_protocol_name_len = auth_info->namelen;
        parts[count++].iov_base = auth_info->name;
        parts[count].iov_len = XCB_PAD(out.authorization_protocol_name_len);
        parts[count++].iov_base = (char *) pad;
        parts[count].iov_len = out.authorization_protocol_data_len = auth_info->datalen;
        parts[count++].iov_base = auth_info->data;
        parts[count].iov_len = XCB_PAD(out.authorization_protocol_data_len);
        parts[count++].iov_base = (char *) pad;
    }
    assert(count <= (int) (sizeof(parts) / sizeof(*parts)));

    pthread_mutex_lock(&c->iolock);
    ret = _xcb_out_send(c, parts, count);
    pthread_mutex_unlock(&c->iolock);
    return ret;
}

static int read_setup(xcb_connection_t *c)
{
    /* Read the server response */
    c->setup = malloc(sizeof(xcb_setup_generic_t));
    if(!c->setup)
        return 0;

    if(_xcb_in_read_block(c, c->setup, sizeof(xcb_setup_generic_t)) != sizeof(xcb_setup_generic_t))
        return 0;

    {
        void *tmp = realloc(c->setup, c->setup->length * 4 + sizeof(xcb_setup_generic_t));
        if(!tmp)
            return 0;
        c->setup = tmp;
    }

    if(_xcb_in_read_block(c, (char *) c->setup + sizeof(xcb_setup_generic_t), c->setup->length * 4) <= 0)
        return 0;

    /* 0 = failed, 2 = authenticate, 1 = success */
    switch(c->setup->status)
    {
    case 0: /* failed */
        {
            xcb_setup_failed_t *setup = (xcb_setup_failed_t *) c->setup;
            write(STDERR_FILENO, xcb_setup_failed_reason(setup), xcb_setup_failed_reason_length(setup));
            return 0;
        }

    case 2: /* authenticate */
        {
            xcb_setup_authenticate_t *setup = (xcb_setup_authenticate_t *) c->setup;
            write(STDERR_FILENO, xcb_setup_authenticate_reason(setup), xcb_setup_authenticate_reason_length(setup));
            return 0;
        }
    }

    return 1;
}

/* precondition: there must be something for us to write. */
static int write_vec(xcb_connection_t *c, struct iovec **vector, int *count)
{
    int n;
    assert(!c->out.queue_len);

#ifdef _WIN32
    int i = 0;
    int ret = 0,err = 0;
    struct iovec *vec;
    n = 0;

    /* Could use the WSASend win32 function for scatter/gather i/o but setting up the WSABUF struct from
       an iovec would require more work and I'm not sure of the benefit....works for now */
    vec = *vector;
    while(i < *count)
    {
         ret = send(c->fd,vec->iov_base,vec->iov_len,0);
         if(ret == SOCKET_ERROR)
         {
             err  = WSAGetLastError();
             if(err == WSAEWOULDBLOCK)
             {
                 return 1;
             }
         }
         n += ret;
         *vec++;
         i++;
    }
#else
    n = *count;
    if (n > IOV_MAX)
        n = IOV_MAX;

#if HAVE_SENDMSG
    if (c->out.out_fd.nfd) {
        union {
            struct cmsghdr cmsghdr;
            char buf[CMSG_SPACE(XCB_MAX_PASS_FD * sizeof(int))];
        } cmsgbuf;
        struct msghdr msg = {
            .msg_name = NULL,
            .msg_namelen = 0,
            .msg_iov = *vector,
            .msg_iovlen = n,
            .msg_control = cmsgbuf.buf,
            .msg_controllen = CMSG_LEN(c->out.out_fd.nfd * sizeof (int)),
        };
        int i;
        struct cmsghdr *hdr = CMSG_FIRSTHDR(&msg);

        hdr->cmsg_len = msg.msg_controllen;
        hdr->cmsg_level = SOL_SOCKET;
        hdr->cmsg_type = SCM_RIGHTS;
        memcpy(CMSG_DATA(hdr), c->out.out_fd.fd, c->out.out_fd.nfd * sizeof (int));

        n = sendmsg(c->fd, &msg, 0);
        if(n < 0 && errno == EAGAIN)
            return 1;
        for (i = 0; i < c->out.out_fd.nfd; i++)
            close(c->out.out_fd.fd[i]);
        c->out.out_fd.nfd = 0;
    } else
#endif
    {
        n = writev(c->fd, *vector, n);
        if(n < 0 && errno == EAGAIN)
            return 1;
    }

#endif /* _WIN32 */

    if(n <= 0)
    {
        _xcb_conn_shutdown(c, XCB_CONN_ERROR);
        return 0;
    }

    for(; *count; --*count, ++*vector)
    {
        int cur = (*vector)->iov_len;
        if(cur > n)
            cur = n;
        (*vector)->iov_len -= cur;
        (*vector)->iov_base = (char *) (*vector)->iov_base + cur;
        n -= cur;
        if((*vector)->iov_len)
            break;
    }
    if(!*count)
        *vector = 0;
    assert(n == 0);
    return 1;
}

/* Public interface */

const xcb_setup_t *xcb_get_setup(xcb_connection_t *c)
{
    if(is_static_error_conn(c))
        return &xcb_error_setup;
    /* doesn't need locking because it's never written to. */
    return c->setup;
}

int xcb_get_file_descriptor(xcb_connection_t *c)
{
    if(is_static_error_conn(c))
        return -1;
    /* doesn't need locking because it's never written to. */
    return c->fd;
}

int xcb_connection_has_error(xcb_connection_t *c)
{
    /* doesn't need locking because it's read and written atomically. */
    return c->has_error;
}

xcb_connection_t *xcb_connect_to_fd(int fd, xcb_auth_info_t *auth_info)
{
    xcb_connection_t* c;

#ifndef _WIN32
#ifndef USE_POLL
    if(fd >= FD_SETSIZE) /* would overflow in FD_SET */
    {
        close(fd);
        return _xcb_conn_ret_error(XCB_CONN_ERROR);
    }
#endif
#endif /* !_WIN32*/

    c = calloc(1, sizeof(xcb_connection_t));
    if(!c) {
        close(fd);
        return _xcb_conn_ret_error(XCB_CONN_CLOSED_MEM_INSUFFICIENT) ;
    }

    c->fd = fd;

    if(!(
        set_fd_flags(fd) &&
        pthread_mutex_init(&c->iolock, 0) == 0 &&
        _xcb_in_init(&c->in) &&
        _xcb_out_init(&c->out) &&
        write_setup(c, auth_info) &&
        read_setup(c) &&
        _xcb_ext_init(c) &&
        _xcb_xid_init(c)
        ))
    {
        xcb_disconnect(c);
        return _xcb_conn_ret_error(XCB_CONN_ERROR);
    }

    return c;
}

void xcb_disconnect(xcb_connection_t *c)
{
    if(c == NULL || is_static_error_conn(c))
        return;

    free(c->setup);

    /* disallow further sends and receives */
    shutdown(c->fd, SHUT_RDWR);
    close(c->fd);

    pthread_mutex_destroy(&c->iolock);
    _xcb_in_destroy(&c->in);
    _xcb_out_destroy(&c->out);

    _xcb_ext_destroy(c);
    _xcb_xid_destroy(c);

    free(c);

#ifdef _WIN32
    WSACleanup();
#endif
}

/* Private interface */

void _xcb_conn_shutdown(xcb_connection_t *c, int err)
{
    c->has_error = err;
}

/* Return connection error state.
 * To make thread-safe, I need a seperate static
 * variable for every possible error.
 * has_error is the first field in xcb_connection_t, so just
 * return a casted int here; checking has_error (and only
 * has_error) will be safe.
 */
xcb_connection_t *_xcb_conn_ret_error(int err)
{

    switch(err)
    {
        case XCB_CONN_CLOSED_MEM_INSUFFICIENT:
        {
            return (xcb_connection_t *) &xcb_con_closed_mem_er;
        }
        case XCB_CONN_CLOSED_PARSE_ERR:
        {
            return (xcb_connection_t *) &xcb_con_closed_parse_er;
        }
        case XCB_CONN_CLOSED_INVALID_SCREEN:
        {
            return (xcb_connection_t *) &xcb_con_closed_screen_er;
        }
        case XCB_CONN_ERROR:
        default:
        {
            return (xcb_connection_t *) &xcb_con_error;
        }
    }
}

int _xcb_conn_wait(xcb_connection_t *c, pthread_cond_t *cond, struct iovec **vector, int *count)
{
    int ret;
#if USE_POLL
    struct pollfd fd;
#else
    fd_set rfds, wfds;
#endif

    /* If the thing I should be doing is already being done, wait for it. */
    if(count ? c->out.writing : c->in.reading)
    {
        pthread_cond_wait(cond, &c->iolock);
        return 1;
    }

#if USE_POLL
    memset(&fd, 0, sizeof(fd));
    fd.fd = c->fd;
    fd.events = POLLIN;
#else
    FD_ZERO(&rfds);
    FD_SET(c->fd, &rfds);
#endif
    ++c->in.reading;

#if USE_POLL
    if(count)
    {
        fd.events |= POLLOUT;
        ++c->out.writing;
    }
#else
    FD_ZERO(&wfds);
    if(count)
    {
        FD_SET(c->fd, &wfds);
        ++c->out.writing;
    }
#endif

    pthread_mutex_unlock(&c->iolock);
    do {
#if USE_POLL
        ret = poll(&fd, 1, -1);
        /* If poll() returns an event we didn't expect, such as POLLNVAL, treat
         * it as if it failed. */
        if(ret >= 0 && (fd.revents & ~fd.events))
        {
            ret = -1;
            break;
        }
#else
        ret = select(c->fd + 1, &rfds, &wfds, 0, 0);
#endif
    } while (ret == -1 && errno == EINTR);
    if(ret < 0)
    {
        _xcb_conn_shutdown(c, XCB_CONN_ERROR);
        ret = 0;
    }
    pthread_mutex_lock(&c->iolock);

    if(ret)
    {
        /* The code allows two threads to call select()/poll() at the same time.
         * First thread just wants to read, a second thread wants to write, too.
         * We have to make sure that we don't steal the reading thread's reply
         * and let it get stuck in select()/poll().
         * So a thread may read if either:
         * - There is no other thread that wants to read (the above situation
         *   did not occur).
         * - It is the reading thread (above situation occurred).
         */
        int may_read = c->in.reading == 1 || !count;
#if USE_POLL
        if(may_read && (fd.revents & POLLIN) != 0)
#else
        if(may_read && FD_ISSET(c->fd, &rfds))
#endif
            ret = ret && _xcb_in_read(c);

#if USE_POLL
        if((fd.revents & POLLOUT) != 0)
#else
        if(FD_ISSET(c->fd, &wfds))
#endif
            ret = ret && write_vec(c, vector, count);
    }

    if(count)
        --c->out.writing;
    --c->in.reading;

    return ret;
}
@


1.9
log
@Update to libxcb and xcb-proto 1.11.
Tested on a bulk ports build by naddy@@.
Lots of churn due to white-space and comments changes in generated code.
@
text
@d67 20
d311 2
a312 2
    if(c->has_error)
        return 0;
d319 1
a319 1
    if(c->has_error)
@


1.8
log
@Update libxcb to version 1.10. Tested by naddy@@ and shadchin@@.
@
text
@d67 1
d73 8
d86 1
a86 1
   u_long iMode = 1; /* non-zero puts it in non-blocking mode, 0 in blocking mode */   
d90 1
a90 1
   if(ret != 0) 
d207 2
a208 2
    {         	 
         ret = send(c->fd,vec->iov_base,vec->iov_len,0);	 
d224 1
a224 1
	n = IOV_MAX;
d262 1
a262 1
#endif /* _WIN32 */    
d353 1
a353 1
    if(c->has_error)
d386 3
@


1.7
log
@Update to libxcb 1.9.0.
tested by ajacoutot@@ and naddy@@ on a full ports build
@
text
@d217 36
a252 3
    n = writev(c->fd, *vector, n);
    if(n < 0 && errno == EAGAIN)
        return 1;
d479 1
a479 1
        if(may_read && (fd.revents & POLLIN) == POLLIN)
d486 1
a486 1
        if((fd.revents & POLLOUT) == POLLOUT)
@


1.6
log
@Update to libxcb 1.8.1. Tested by krw@@, mpi@@, shadchin@@
@
text
@d28 4
d39 1
d70 1
d213 5
a217 1
    n = writev(c->fd, *vector, *count);
d358 4
d435 10
d446 1
a446 1
        if((fd.revents & POLLIN) == POLLIN)
d448 1
a448 1
        if(FD_ISSET(c->fd, &rfds))
@


1.5
log
@Bugfixes from upstream.
Minor tweaks (shutdown(2) related bits) by me.

OK matthieu@@
@
text
@a28 2
#include <sys/types.h>
#include <sys/socket.h>
a32 1
#include <netinet/in.h>
d40 6
d47 7
a53 1
#include <sys/select.h>
d62 3
a64 1
const int error_connection = 1;
d68 11
d88 1
d181 26
d210 2
d214 1
a214 1
        _xcb_conn_shutdown(c);
d263 1
d268 1
a268 1
        return (xcb_connection_t *) &error_connection;
d271 1
d276 1
a276 1
        return (xcb_connection_t *) &error_connection;
d293 1
a293 1
        return (xcb_connection_t *) &error_connection;
d301 1
a301 1
    if(c == (xcb_connection_t *) &error_connection)
d318 4
d326 10
a335 1
void _xcb_conn_shutdown(xcb_connection_t *c)
d337 17
a353 1
    c->has_error = 1;
d414 1
a414 1
        _xcb_conn_shutdown(c);
@


1.4
log
@Update to libxcb 1.7
@
text
@d29 2
d53 1
a53 1
static const int error_connection = 1;
d248 1
a248 1
    if(c->has_error)
d252 3
d319 7
@


1.3
log
@Update to libxcb 1.6. Mostly for new dri2 helper lib, requested by oga@@.
@
text
@d105 1
a105 4
    {
        struct iovec *parts_ptr = parts;
        ret = _xcb_out_send(c, &parts_ptr, &count);
    }
d313 1
a313 1
    ret = poll(&fd, 1, -1);
d315 1
a315 1
	ret = select(c->fd + 1, &rfds, &wfds, 0, 0);
d318 1
a318 1
    if (ret < 0)
d321 1
a321 1
	ret = 0;
@


1.2
log
@update to libxcb 1.3
@
text
@d213 8
d222 2
a223 1
    if(!c)
d225 1
@


1.1
log
@Initial revision
@
text
@a33 1
#include <sys/select.h>
d39 5
d265 3
d269 1
d278 5
d285 1
d288 7
d301 1
d305 3
d309 1
d320 3
d324 1
d327 3
d331 1
@


1.1.1.1
log
@import libxcb 1.2
@
text
@@
