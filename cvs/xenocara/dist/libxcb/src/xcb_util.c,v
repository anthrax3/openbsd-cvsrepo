head	1.11;
access;
symbols
	OPENBSD_6_1:1.11.0.6
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.4
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.9.0.2
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.8.0.6
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.4
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.2
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.6
	OPENBSD_5_0:1.6.0.4
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	v1_2:1.1.1.1
	XCB:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2016.02.02.18.42.22;	author kettenis;	state Exp;
branches;
next	1.10;
commitid	Xlm1Yuci540FsS9s;

1.10
date	2015.01.26.21.32.11;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	01TEvO4uNHLqFv7N;

1.9
date	2014.04.14.19.02.17;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2012.11.22.20.31.32;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.03.27.19.14.21;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.10.06.07.50.06;	author dcoppa;	state Exp;
branches;
next	1.5;

1.5
date	2010.09.04.10.00.59;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.08.04.07.47.53;	author dcoppa;	state Exp;
branches;
next	1.3;

1.3
date	2010.04.18.20.06.18;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.05.31.16.44.44;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2009.05.22.15.56.13;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2009.05.22.15.56.13;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Make sure the socket send buffer is at least 64KB.  This reduces the number of
writev(2) system calls made for largish requests.  A similar change was made
to the libxtrans code a while ago.  This should speed up applications that
send images to the X server, like Firefox.  The seedupmight not be noticable
though.  But it reduces the noice in ktrace logs.

ok matthieu@@
@
text
@/* Copyright (C) 2001-2004 Bart Massey and Jamey Sharp.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 * Except as contained in this notice, the names of the authors or their
 * institutions shall not be used in advertising or otherwise to promote the
 * sale, use or other dealings in this Software without prior written
 * authorization from the authors.
 */

/* Utility functions implementable using only public APIs. */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <assert.h>
#include <sys/types.h>
#include <limits.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <unistd.h>
#include <string.h>

#ifdef _WIN32
#include "xcb_windefs.h"
#else
#include <arpa/inet.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <fcntl.h>
#include <netdb.h>
#endif /* _WIN32 */

#include "xcb.h"
#include "xcbext.h"
#include "xcbint.h"

#if defined(HAVE_TSOL_LABEL_H) && defined(HAVE_IS_SYSTEM_LABELED)
# include <tsol/label.h>
# include <sys/stat.h>
#endif

#ifdef HAVE_LAUNCHD
#include <sys/stat.h>
#endif

int xcb_popcount(uint32_t mask)
{
    uint32_t y;
    y = (mask >> 1) & 033333333333;
    y = mask - y - ((y >> 1) & 033333333333);
    return ((y + (y >> 3)) & 030707070707) % 077;
}

int xcb_sumof(uint8_t *list, int len)
{
  int i, s = 0;
  for(i=0; i<len; i++) {
    s += *list;
    list++;
  }
  return s;
}

#ifdef HAVE_LAUNCHD
/* Return true and parse if name matches <path to socket>[.<screen>]
 * Upon success:
 *     host = <path to socket>
 *     protocol = "unix"
 *     display = 0
 *     screen = <screen>
 */
static int _xcb_parse_display_path_to_socket(const char *name, char **host, char **protocol,
                                             int *displayp, int *screenp)
{
    struct stat sbuf;
    char path[PATH_MAX];
    int _screen = 0;

    strlcpy(path, name, sizeof(path));
    if (0 != stat(path, &sbuf)) {
        char *dot = strrchr(path, '.');
        if (!dot)
            return 0;
        *dot = '\0';

        if (0 != stat(path, &sbuf))
            return 0;

        _screen = atoi(dot + 1);
    }

    if (host) {
        *host = strdup(path);
        if (!*host)
            return 0;
    }

    if (protocol) {
        *protocol = strdup("unix");
        if (!*protocol) {
            if (host)
                free(*host);
            return 0;
        }
    }

    if (displayp)
        *displayp = 0;

    if (screenp)
        *screenp = _screen;

    return 1;
}
#endif

static int _xcb_parse_display(const char *name, char **host, char **protocol,
                      int *displayp, int *screenp)
{
    int len, display, screen;
    char *slash, *colon, *dot, *end;

    if(!name || !*name)
        name = getenv("DISPLAY");
    if(!name)
        return 0;

#ifdef HAVE_LAUNCHD
    /* First check for <path to socket>[.<screen>] */
    if (_xcb_parse_display_path_to_socket(name, host, protocol, displayp, screenp))
        return 1;
#endif

    slash = strrchr(name, '/');

    if (slash) {
        len = slash - name;
        if (protocol) {
            *protocol = malloc(len + 1);
            if(!*protocol)
                return 0;
            memcpy(*protocol, name, len);
            (*protocol)[len] = '\0';
        }
        name = slash + 1;
    } else
        if (protocol)
            *protocol = NULL;

    colon = strrchr(name, ':');
    if(!colon)
        goto error_out;
    len = colon - name;
    ++colon;
    display = strtoul(colon, &dot, 10);
    if(dot == colon)
        goto error_out;
    if(*dot == '\0')
        screen = 0;
    else
    {
        if(*dot != '.')
            goto error_out;
        ++dot;
        screen = strtoul(dot, &end, 10);
        if(end == dot || *end != '\0')
            goto error_out;
    }
    /* At this point, the display string is fully parsed and valid, but
     * the caller's memory is untouched. */

    *host = malloc(len + 1);
    if(!*host)
        goto error_out;
    memcpy(*host, name, len);
    (*host)[len] = '\0';
    *displayp = display;
    if(screenp)
        *screenp = screen;
    return 1;

error_out:
    if (protocol) {
        free(*protocol);
        *protocol = NULL;
    }

    return 0;
}

int xcb_parse_display(const char *name, char **host, int *displayp,
                             int *screenp)
{
    return _xcb_parse_display(name, host, NULL, displayp, screenp);
}

static int _xcb_open_tcp(const char *host, char *protocol, const unsigned short port);
#ifndef _WIN32
static int _xcb_open_unix(char *protocol, const char *file);
#endif /* !WIN32 */
#ifdef HAVE_ABSTRACT_SOCKETS
static int _xcb_open_abstract(char *protocol, const char *file, size_t filelen);
#endif

static int _xcb_open(const char *host, char *protocol, const int display)
{
    int fd;
#ifdef __hpux
    static const char unix_base[] = "/usr/spool/sockets/X11/";
#else
    static const char unix_base[] = "/tmp/.X11-unix/X";
#endif
    const char *base = unix_base;
    size_t filelen;
    char *file = NULL;
    int actual_filelen;

    /* If protocol or host is "unix", fall through to Unix socket code below */
    if ((!protocol || (strcmp("unix",protocol) != 0)) &&
        (*host != '\0') && (strcmp("unix",host) != 0))
    {
        /* display specifies TCP */
        unsigned short port = X_TCP_PORT + display;
        return _xcb_open_tcp(host, protocol, port);
    }

#ifndef _WIN32
#if defined(HAVE_TSOL_LABEL_H) && defined(HAVE_IS_SYSTEM_LABELED)
    /* Check special path for Unix sockets under Solaris Trusted Extensions */
    if (is_system_labeled())
    {
        struct stat sbuf;
        const char *tsol_base = "/var/tsol/doors/.X11-unix/X";
        char tsol_socket[PATH_MAX];

        snprintf(tsol_socket, sizeof(tsol_socket), "%s%d", tsol_base, display);

        if (stat(tsol_socket, &sbuf) == 0)
            base = tsol_base;
    }
#endif

#ifdef HAVE_LAUNCHD
    struct stat sbuf;
    if (0 == stat(host, &sbuf)) {
        file = strdup(host);
        filelen = actual_filelen = strlen(file);
    } else
#endif
    {
        filelen = strlen(base) + 1 + sizeof(display) * 3 + 1;
        file = malloc(filelen);
        if(file == NULL)
            return -1;

        /* display specifies Unix socket */
        actual_filelen = snprintf(file, filelen, "%s%d", base, display);
    }

    if(actual_filelen < 0)
    {
        free(file);
        return -1;
    }
    /* snprintf may truncate the file */
    filelen = MIN(actual_filelen, filelen - 1);
#ifdef HAVE_ABSTRACT_SOCKETS
    fd = _xcb_open_abstract(protocol, file, filelen);
    if (fd >= 0 || (errno != ENOENT && errno != ECONNREFUSED))
    {
        free(file);
        return fd;
    }

#endif
    fd = _xcb_open_unix(protocol, file);
    free(file);

    if (fd < 0 && !protocol && *host == '\0') {
            unsigned short port = X_TCP_PORT + display;
            fd = _xcb_open_tcp(host, protocol, port);
    }

    return fd;
#endif /* !_WIN32 */
    return -1; /* if control reaches here then something has gone wrong */
}

static int _xcb_socket(int family, int type, int proto)
{
    int fd;

#ifdef SOCK_CLOEXEC
    fd = socket(family, type | SOCK_CLOEXEC, proto);
    if (fd == -1 && errno == EINVAL)
#endif
    {
        fd = socket(family, type, proto);
#ifndef _WIN32
        if (fd >= 0)
            fcntl(fd, F_SETFD, FD_CLOEXEC);
#endif
    }
    return fd;
}


static int _xcb_do_connect(int fd, const struct sockaddr* addr, int addrlen) {
    int on = 1;

    if(fd < 0)
        return -1;

    setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &on, sizeof(on));
    setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &on, sizeof(on));

    return connect(fd, addr, addrlen);
}

static int _xcb_open_tcp(const char *host, char *protocol, const unsigned short port)
{
    int fd = -1;
#if HAVE_GETADDRINFO
    struct addrinfo hints;
    char service[6]; /* "65535" with the trailing '\0' */
    struct addrinfo *results, *addr;
    char *bracket;
#endif

    if (protocol && strcmp("tcp",protocol) && strcmp("inet",protocol)
#ifdef AF_INET6
                 && strcmp("inet6",protocol)
#endif
        )
        return -1;

    if (*host == '\0')
        host = "localhost";

#if HAVE_GETADDRINFO
    memset(&hints, 0, sizeof(hints));
#ifdef AI_NUMERICSERV
    hints.ai_flags |= AI_NUMERICSERV;
#endif
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;

#ifdef AF_INET6
    /* Allow IPv6 addresses enclosed in brackets. */
    if(host[0] == '[' && (bracket = strrchr(host, ']')) && bracket[1] == '\0')
    {
        *bracket = '\0';
        ++host;
        hints.ai_flags |= AI_NUMERICHOST;
        hints.ai_family = AF_INET6;
    }
#endif

    snprintf(service, sizeof(service), "%hu", port);
    if(getaddrinfo(host, service, &hints, &results))
        /* FIXME: use gai_strerror, and fill in error connection */
        return -1;

    for(addr = results; addr; addr = addr->ai_next)
    {
        fd = _xcb_socket(addr->ai_family, addr->ai_socktype, addr->ai_protocol);
        if (_xcb_do_connect(fd, addr->ai_addr, addr->ai_addrlen) >= 0)
            break;
        close(fd);
        fd = -1;
    }
    freeaddrinfo(results);
    return fd;
#else
    {
        struct hostent* _h;
        struct sockaddr_in _s;
        struct in_addr ** _c;

        if((_h = gethostbyname(host)) == NULL)
            return -1;

        _c = (struct in_addr**)_h->h_addr_list;
        fd = -1;

        while(*_c) {
            _s.sin_family = AF_INET;
            _s.sin_port = htons(port);
            _s.sin_addr = *(*_c);

            fd = _xcb_socket(_s.sin_family, SOCK_STREAM, 0);
            if(_xcb_do_connect(fd, (struct sockaddr*)&_s, sizeof(_s)) >= 0)
                break;

            close(fd);
            fd = -1;
            ++_c;
        }

        return fd;
    }
#endif
}

#ifndef _WIN32
static int _xcb_open_unix(char *protocol, const char *file)
{
    int fd;
    struct sockaddr_un addr;
    socklen_t len = sizeof(int);
    int val;

    if (protocol && strcmp("unix",protocol))
        return -1;

    strcpy(addr.sun_path, file);
    addr.sun_family = AF_UNIX;
#ifdef HAVE_SOCKADDR_SUN_LEN
    addr.sun_len = SUN_LEN(&addr);
#endif
    fd = _xcb_socket(AF_UNIX, SOCK_STREAM, 0);
    if(fd == -1)
        return -1;
    if(getsockopt(fd, SOL_SOCKET, SO_SNDBUF, &val, &len) == 0 && val < 64 * 1024)
    {
        val = 64 * 1024;
        setsockopt(fd, SOL_SOCKET, SO_SNDBUF, &val, sizeof(int));
    }
    if(connect(fd, (struct sockaddr *) &addr, sizeof(addr)) == -1) {
        close(fd);
        return -1;
    }
    return fd;
}
#endif /* !_WIN32 */

#ifdef HAVE_ABSTRACT_SOCKETS
static int _xcb_open_abstract(char *protocol, const char *file, size_t filelen)
{
    int fd;
    struct sockaddr_un addr = {0};
    socklen_t namelen;

    if (protocol && strcmp("unix",protocol))
        return -1;

    strcpy(addr.sun_path + 1, file);
    addr.sun_family = AF_UNIX;
    namelen = offsetof(struct sockaddr_un, sun_path) + 1 + filelen;
#ifdef HAVE_SOCKADDR_SUN_LEN
    addr.sun_len = 1 + filelen;
#endif
    fd = _xcb_socket(AF_UNIX, SOCK_STREAM, 0);
    if (fd == -1)
        return -1;
    if (connect(fd, (struct sockaddr *) &addr, namelen) == -1) {
        close(fd);
        return -1;
    }
    return fd;
}
#endif

xcb_connection_t *xcb_connect(const char *displayname, int *screenp)
{
    return xcb_connect_to_display_with_auth_info(displayname, NULL, screenp);
}

xcb_connection_t *xcb_connect_to_display_with_auth_info(const char *displayname, xcb_auth_info_t *auth, int *screenp)
{
    int fd, display = 0;
    char *host = NULL;
    char *protocol = NULL;
    xcb_auth_info_t ourauth;
    xcb_connection_t *c;

    int parsed = _xcb_parse_display(displayname, &host, &protocol, &display, screenp);

    if(!parsed) {
        c = _xcb_conn_ret_error(XCB_CONN_CLOSED_PARSE_ERR);
        goto out;
    }

#ifdef _WIN32
    WSADATA wsaData;
    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {
        c = _xcb_conn_ret_error(XCB_CONN_ERROR);
        goto out;
    }
#endif

    fd = _xcb_open(host, protocol, display);

    if(fd == -1) {
        c = _xcb_conn_ret_error(XCB_CONN_ERROR);
#ifdef _WIN32
        WSACleanup();
#endif
        goto out;
    }

    if(auth) {
        c = xcb_connect_to_fd(fd, auth);
        goto out;
    }

    if(_xcb_get_auth_info(fd, &ourauth, display))
    {
        c = xcb_connect_to_fd(fd, &ourauth);
        free(ourauth.name);
        free(ourauth.data);
    }
    else
        c = xcb_connect_to_fd(fd, 0);

    if(c->has_error)
        goto out;

    /* Make sure requested screen number is in bounds for this server */
    if((screenp != NULL) && (*screenp >= (int) c->setup->roots_len)) {
        xcb_disconnect(c);
        c = _xcb_conn_ret_error(XCB_CONN_CLOSED_INVALID_SCREEN);
        goto out;
    }

out:
    free(host);
    free(protocol);
    return c;
}
@


1.10
log
@Update to libxcb and xcb-proto 1.11.
Tested on a bulk ports build by naddy@@.
Lots of churn due to white-space and comments changes in generated code.
@
text
@d431 2
d445 5
@


1.9
log
@Update libxcb to version 1.10. Tested by naddy@@ and shadchin@@.
@
text
@d63 4
d85 53
d150 3
a152 3
    if(strncmp(name, "/tmp/launch", 11) == 0)
        slash = NULL;
    else
d154 1
a238 8
#ifdef HAVE_LAUNCHD
    if(strncmp(host, "/tmp/launch", 11) == 0) {
        base = host;
        host = "";
        protocol = "unix";
    }
#endif

a263 6
    filelen = strlen(base) + 1 + sizeof(display) * 3 + 1;
    file = malloc(filelen);
    if(file == NULL)
        return -1;

    /* display specifies Unix socket */
d265 5
a269 3
    if(strncmp(base, "/tmp/launch", 11) == 0)
        actual_filelen = snprintf(file, filelen, "%s:%d", base, display);
    else
d271 7
d279 2
d301 2
a302 2
	    unsigned short port = X_TCP_PORT + display;
	    fd = _xcb_open_tcp(host, protocol, port);
d319 1
a319 1
	fd = socket(family, type, proto);
d321 2
a322 2
	if (fd >= 0)
	    fcntl(fd, F_SETFD, FD_CLOEXEC);
d330 1
a330 1
	int on = 1;
d332 2
a333 2
	if(fd < 0)
		return -1;
d335 2
a336 2
	setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &on, sizeof(on));
	setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &on, sizeof(on));
d338 1
a338 1
	return connect(fd, addr, addrlen);
d353 1
a353 1
	         && strcmp("inet6",protocol)
d355 1
a355 1
	)
d357 1
a357 1
	
d359 1
a359 1
	host = "localhost";
d492 1
a492 1
    
d496 2
a497 1
    } else {
d499 5
a503 5
        WSADATA wsaData;
        if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {
            c = _xcb_conn_ret_error(XCB_CONN_ERROR);
            goto out;
        }
d505 2
a506 2
        fd = _xcb_open(host, protocol, display);
    }
@


1.8
log
@Update to libxcb 1.9.0.
tested by ajacoutot@@ and naddy@@ on a full ports build
@
text
@d171 3
d175 1
@


1.7
log
@Update to libxcb 1.8.1. Tested by krw@@, mpi@@, shadchin@@
@
text
@d28 4
a57 1
/* must be after "xcbint.h" to get autoconf #defines */
d181 1
a181 1
        protocol = NULL;
d469 10
@


1.6
log
@Bugfixes from upstream.
Minor tweaks (shutdown(2) related bits) by me.

OK matthieu@@
@
text
@a29 1
#include <sys/socket.h>
a30 8
#include <sys/un.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#ifdef DNETCONN
#include <netdnet/dnetdb.h>
#include <netdnet/dn.h>
#endif
#include <netdb.h>
d36 10
d47 2
a48 1
#include <string.h>
d54 6
d68 10
d158 1
d160 1
a160 3
#ifdef DNETCONN
static int _xcb_open_decnet(const char *host, char *protocol, const unsigned short port);
#endif
d175 5
a179 5
        if(strncmp(host, "/tmp/launch", 11) == 0) {
		base = host;
		host = "";
		protocol = NULL;
        }
d182 13
a194 1
    if(*host || protocol)
d196 5
a200 15
#ifdef DNETCONN
        /* DECnet displays have two colons, so _xcb_parse_display will have
           left one at the end.  However, an IPv6 address can end with *two*
           colons, so only treat this as a DECnet display if host ends with
           exactly one colon. */
        char *colon = strchr(host, ':');
        if(colon && *(colon+1) == '\0')
        {
            *colon = '\0';
            return _xcb_open_decnet(host, protocol, display);
        }
        else
#endif
            if (protocol
                || strcmp("unix",host)) { /* follow the old unix: rule */
d202 2
a203 4
                /* display specifies TCP */
                unsigned short port = X_TCP_PORT + display;
                return _xcb_open_tcp(host, protocol, port);
            }
d205 1
d238 5
d244 2
d258 1
d261 1
a265 13
#ifdef DNETCONN
static int _xcb_open_decnet(const char *host, const char *protocol, const unsigned short port)
{
    int fd;
    struct sockaddr_dn addr;
    struct accessdata_dn accessdata;
    struct nodeent *nodeaddr = getnodebyname(host);

    if(!nodeaddr)
        return -1;
    if (protocol && strcmp("dnet",protocol))
        return -1;
    addr.sdn_family = AF_DECnet;
d267 2
a268 2
    addr.sdn_add.a_len = nodeaddr->n_length;
    memcpy(addr.sdn_add.a_addr, nodeaddr->n_addr, addr.sdn_add.a_len);
d270 2
a271 4
    addr.sdn_objnamel = sprintf((char *)addr.sdn_objname, "X$X%d", port);
    if(addr.sdn_objnamel < 0)
        return -1;
    addr.sdn_objnum = 0;
d273 2
a274 9
    fd = _xcb_socket(PF_DECnet, SOCK_STREAM, 0);
    if(fd == -1)
        return -1;

    memset(&accessdata, 0, sizeof(accessdata));
    accessdata.acc_accl = sprintf((char*)accessdata.acc_acc, "%d", getuid());
    if(accessdata.acc_accl < 0)
        return -1;
    setsockopt(fd, DNPROTO_NSP, SO_CONACCESS, &accessdata, sizeof(accessdata));
d276 1
a276 5
    if(connect(fd, (struct sockaddr *) &addr, sizeof(addr)) == -1) {
        close(fd);
        return -1;
    }
    return fd;
a277 1
#endif
d282 1
d287 1
d299 1
a300 3
#ifdef AI_ADDRCONFIG
    hints.ai_flags |= AI_ADDRCONFIG;
#endif
d326 23
a348 4
        if(fd >= 0) {
            int on = 1;
            setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &on, sizeof(on));
	    setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &on, sizeof(on));
d350 2
a351 1
            if (connect(fd, addr->ai_addr, addr->ai_addrlen) >= 0)
d353 1
d356 1
d358 2
d361 1
a361 2
    freeaddrinfo(results);
    return fd;
d364 1
d387 1
d432 1
a432 1
        c = (xcb_connection_t *) &error_connection;
d434 8
a441 1
    } else
d443 1
d446 4
a449 1
        c = (xcb_connection_t *) &error_connection;
@


1.5
log
@Update to libxcb 1.7
@
text
@a51 2
static const int error_connection = 1;

@


1.4
log
@Pull in some fixes from upstream:

o various memleak fixes
o ensure get_wm_class_from_reply returns a valid C-string

OK matthieu@@, deraadt@@
@
text
@d31 1
d67 1
d72 6
d79 1
d141 1
a141 1
static int _xcb_open_tcp(char *host, char *protocol, const unsigned short port);
d150 1
a150 1
static int _xcb_open(char *host, char *protocol, const int display)
a151 1
#ifdef HAVE_ABSTRACT_SOCKETS
d153 12
a165 3
    static const char base[] = "/tmp/.X11-unix/X";
    char file[sizeof(base) + 20];
    int filelen;
d167 1
a167 1
    if(*host)
d191 5
d197 9
a205 2
    filelen = snprintf(file, sizeof(file), "%s%d", base, display);
    if(filelen < 0)
d207 1
d209 1
a209 1
    filelen = MIN(filelen, sizeof(file) - 1);
d213 2
d216 1
d219 4
a222 1
    return  _xcb_open_unix(protocol, file);
d281 1
a281 1
static int _xcb_open_tcp(char *host, char *protocol, const unsigned short port)
d289 5
a293 1
    if (protocol && strcmp("tcp",protocol))
d295 3
a407 7
#ifdef HAVE_LAUNCHD
    if(!displayname)
        displayname = getenv("DISPLAY");
    if(displayname && strlen(displayname)>11 && !strncmp(displayname, "/tmp/launch", 11))
        fd = _xcb_open_unix(NULL, displayname);
    else
#endif
@


1.3
log
@Update to libxcb 1.6. Mostly for new dri2 helper lib, requested by oga@@.
@
text
@d87 1
a87 1
        return 0;
d92 1
a92 1
        return 0;
d98 1
a98 1
            return 0;
d102 1
a102 1
            return 0;
d109 1
a109 1
        return 0;
d116 8
d358 2
a359 2
    char *host;
    char *protocol;
d372 4
a375 3
    if(!parsed)
        return (xcb_connection_t *) &error_connection;
    else
a376 1
    free(host);
d378 4
a381 2
    if(fd == -1)
        return (xcb_connection_t *) &error_connection;
d383 4
a386 2
    if(auth)
        return xcb_connect_to_fd(fd, auth);
d397 3
@


1.2
log
@update to libxcb 1.3
@
text
@d44 1
d181 16
d219 1
a219 1
    fd = socket(PF_DECnet, SOCK_STREAM, 0);
d276 1
a276 1
        fd = socket(addr->ai_family, addr->ai_socktype, addr->ai_protocol);
d280 1
d305 1
a305 1
    fd = socket(AF_UNIX, SOCK_STREAM, 0);
d331 1
a331 1
    fd = socket(AF_UNIX, SOCK_STREAM, 0);
@


1.1
log
@Initial revision
@
text
@d33 1
d129 1
a129 1
static int _xcb_open_abstract(char *protocol, const char *file);
d139 1
d166 5
a170 1
    snprintf(file, sizeof(file), "%s%d", base, display);
d172 1
a172 1
    fd = _xcb_open_abstract(protocol, file);
d197 3
a199 2
    sprintf((char *)addr.sdn_objname, "X$X%d", port);
    addr.sdn_objnamel = strlen((char *)addr.sdn_objname);
d207 3
a209 2
    sprintf((char*)accessdata.acc_acc, "%d", getuid());
    accessdata.acc_accl = strlen((char *)accessdata.acc_acc);
d261 3
d298 1
a298 1
static int _xcb_open_abstract(char *protocol, const char *file)
d309 1
a309 1
    namelen = offsetof(struct sockaddr_un, sun_path) + 1 + strlen(file);
d311 1
a311 1
    addr.sun_len = 1 + strlen(file);
d326 5
d334 1
d336 2
a337 1
    xcb_auth_info_t auth;
a338 2
    int parsed = _xcb_parse_display(displayname, &host, &protocol, &display, screenp);

d355 4
a358 1
    if(_xcb_get_auth_info(fd, &auth, display))
d360 3
a362 3
        c = xcb_connect_to_fd(fd, &auth);
        free(auth.name);
        free(auth.data);
d366 1
a367 27
}

xcb_connection_t *xcb_connect_to_display_with_auth_info(const char *displayname, xcb_auth_info_t *auth, int *screenp)
{
    int fd, display = 0;
    char *host;
    char *protocol;

    int parsed = _xcb_parse_display(displayname, &host, &protocol, &display, screenp);
    
#ifdef HAVE_LAUNCHD
    if(!displayname)
        displayname = getenv("DISPLAY");
    if(displayname && strlen(displayname)>11 && !strncmp(displayname, "/tmp/launch", 11))
        fd = _xcb_open_unix(NULL, displayname);
    else
#endif
    if(!parsed)
        return (xcb_connection_t *) &error_connection;
    else
        fd = _xcb_open(host, protocol, display);
    free(host);

    if(fd == -1)
        return (xcb_connection_t *) &error_connection;

    return xcb_connect_to_fd(fd, auth);
@


1.1.1.1
log
@import libxcb 1.2
@
text
@@
