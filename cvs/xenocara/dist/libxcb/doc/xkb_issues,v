head	1.1;
access;
symbols
	OPENBSD_6_2:1.1.0.22
	OPENBSD_6_2_BASE:1.1
	OPENBSD_6_1:1.1.0.20
	OPENBSD_6_1_BASE:1.1
	OPENBSD_6_0:1.1.0.18
	OPENBSD_6_0_BASE:1.1
	OPENBSD_5_9:1.1.0.16
	OPENBSD_5_9_BASE:1.1
	OPENBSD_5_8:1.1.0.14
	OPENBSD_5_8_BASE:1.1
	OPENBSD_5_7:1.1.0.12
	OPENBSD_5_7_BASE:1.1
	OPENBSD_5_6:1.1.0.10
	OPENBSD_5_6_BASE:1.1
	OPENBSD_5_5:1.1.0.8
	OPENBSD_5_5_BASE:1.1
	OPENBSD_5_4:1.1.0.6
	OPENBSD_5_4_BASE:1.1
	OPENBSD_5_3:1.1.0.4
	OPENBSD_5_3_BASE:1.1
	OPENBSD_5_2:1.1.0.2
	OPENBSD_5_2_BASE:1.1;
locks; strict;
comment	@# @;


1.1
date	2012.03.27.19.14.21;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Update to libxcb 1.8.1. Tested by krw@@, mpi@@, shadchin@@
@
text
@
There are a number of problematic special cases in XKB. The issues 
mentioned here are at most partly resolved.
 
1. The are several XxxDoodad structures defined in xkb.xml. They are used
   in a few lists, but in a rather special way: 
   The struct "CommonDoodad" is supposed to be a rather generic data type, 
   combining the most basic Doodad fields that are common in all these structures. 
   All Doodads are encapsulated in a union type simply called "Doodad". 
   Now this union is used in subsequent list definitions, aiming at a kind of 
   'polymorphism': From inspection of the protocol and Xlib, the Doodads are to 
   be discriminated based on their type field.
   However the special meaning of the type field is not encoded in the protocol. 
   Furthermore the TextDoodad and the LogoDoodad are variable size types due to
   some fields of type CountedString16, thereby turning the union into a 
   possibly variable size type as well. 
   However, for lists with variable size elements, special sizeof functions are 
   required. These cannot be autogenerated as it cannot be referred which 
   Doodad type to use for the union. 
   Therefore, the Doodad type structures are unsupported at the moment. 

2. There are still some bugs in xkb.xml: Either certain fields are missing
   that are required by the protocol, or Xlib simply has another understanding
   of the protocol. 

3. The interface for accessors should be reviewed. 

4. Currently some bitcases carry 'name' attributes. These could be avoided if 
   the data within would consist of a singe struct field only. 

5. switch could get a 'fixed_size' attribute, so when rewriting valueparam to switch, 
   an uint32_t * pointer could be used instead of void *. 

6. The automatic inclusion of padding requires some complicated coding in the 
   generator. This is errorprone and could be avoided if all padding is explicitly
   given in the protocol definition. For variable size fields that require padding, 
   the pad tag could get a 'fieldref' attribute. That way padding could be handled
   a lot easier in the autogenerator. @
