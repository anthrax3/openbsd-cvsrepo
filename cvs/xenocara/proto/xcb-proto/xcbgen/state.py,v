head	1.4;
access;
symbols
	OPENBSD_6_0:1.4.0.8
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.6
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.4
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.2
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.3.0.2
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.2.0.8
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.6
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.4
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.2
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.12
	OPENBSD_5_0:1.1.1.1.0.10
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.6
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.8
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.4
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.2
	OPENBSD_4_6_BASE:1.1.1.1
	v1_4:1.1.1.1
	XCB:1.1.1;
locks; strict;
comment	@# @;


1.4
date	2015.01.26.21.32.12;	author matthieu;	state Exp;
branches;
next	1.3;
commitid	01TEvO4uNHLqFv7N;

1.3
date	2014.03.15.17.24.20;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2012.03.27.19.12.47;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2009.05.22.15.48.50;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2009.05.22.15.48.50;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Update to libxcb and xcb-proto 1.11.
Tested on a bulk ports build by naddy@@.
Lots of churn due to white-space and comments changes in generated code.
@
text
@'''
This module contains the namespace class and the singleton module class.
'''
from os.path import dirname, basename
from xml.etree.cElementTree import parse

from xcbgen import matcher
from xcbgen.error import *
from xcbgen.xtypes import *

import __main__

class Namespace(object):
    '''
    Contains the naming information for an extension.

    Public fields:

    header is the header attribute ("header file" name).
    is_ext is true for extensions, false for xproto.
    major_version and minor_version are extension version info.
    ext_xname is the X extension name string.
    ext_name is the XCB extension name prefix.
    '''
    def __init__(self, filename):
        # Path info
        self.path = filename
        self.dir = dirname(filename)
        self.file = basename(filename)

        # Parse XML
        self.root = parse(filename).getroot()
        self.header = self.root.get('header')
        self.ns = self.header + ':'
        
        # Get root element attributes
        if self.root.get('extension-xname', False): 
            self.is_ext = True
            self.major_version = self.root.get('major-version')
            self.minor_version = self.root.get('minor-version')
            self.ext_xname = self.root.get('extension-xname')
            self.ext_name = self.root.get('extension-name')
            self.prefix = ('xcb', self.ext_name)
        else:
            self.is_ext = False
            self.ext_name = ''
            self.prefix = ('xcb',)


class Module(object):
    '''
    This is the grand, encompassing class that represents an entire XCB specification.
    Only gets instantiated once, in the main() routine.

    Don't need to worry about this much except to declare it and to get the namespace.

    Public fields:
    namespace contains the namespace info for the spec.
    '''
    open = __main__.output['open']
    close = __main__.output['close']

    def __init__(self, filename, output):
        self.namespace = Namespace(filename)
        self.output = output

        self.imports = []
        self.direct_imports = []
        self.import_level = 0
        self.types = {}
        self.events = {}
        self.errors = {}
        self.all = []

        # Register some common types
        self.add_type('CARD8', '', ('uint8_t',), tcard8)
        self.add_type('CARD16', '', ('uint16_t',), tcard16)
        self.add_type('CARD32', '', ('uint32_t',), tcard32)
        self.add_type('CARD64', '', ('uint64_t',), tcard64)
        self.add_type('INT8', '', ('int8_t',), tint8)
        self.add_type('INT16', '', ('int16_t',), tint16)
        self.add_type('INT32', '', ('int32_t',), tint32)
        self.add_type('INT64', '', ('int64_t',), tint64)
        self.add_type('BYTE', '', ('uint8_t',), tcard8)
        self.add_type('BOOL', '', ('uint8_t',), tcard8)
        self.add_type('char', '', ('char',), tchar)
        self.add_type('float', '', ('float',), tfloat)
        self.add_type('double', '', ('double',), tdouble)
        self.add_type('void', '', ('void',), tcard8)

    # This goes out and parses the rest of the XML
    def register(self):
        matcher.execute(self, self.namespace)

    # Recursively resolve all types
    def resolve(self):
        for (name, item) in self.all:
            self.pads = 0
            item.resolve(self)

    # Call all the output methods
    def generate(self):
        self.open()

        for (name, item) in self.all:
            item.out(name)

        self.close()

    # Keeps track of what's been imported so far.
    def add_import(self, name, namespace):
        if self.import_level == 0:
            self.direct_imports.append((name, namespace.header))
        self.imports.append((name, namespace.header))

    def has_import(self, name):
        for (name_, header) in self.imports:
            if name_ == name:
                return True
        return False

    # Keeps track of non-request/event/error datatypes
    def add_type(self, id, ns, name, item):
        key = ns + id
        if key in self.types:
            return
        self.types[key] = (name, item)
        if name[:-1] == self.namespace.prefix:
            self.all.append((name, item))

    def get_type_impl(self, id, idx):
        key = id
        if key in self.types:
            return self.types[key][idx]

        key = self.namespace.ns + id
        if key in self.types:
            return self.types[key][idx]

        for key in self.types.keys():
            if key.rpartition(':')[2] == id:
                return self.types[key][idx]

        raise ResolveException('Type %s not found' % id)

    def get_type(self, id):
        return self.get_type_impl(id, 1)

    def get_type_name(self, id):
        return self.get_type_impl(id, 0)

    # Keeps track of request datatypes
    def add_request(self, id, name, item):
        if name[:-1] == self.namespace.prefix:
            self.all.append((name, item))

    # Keeps track of event datatypes
    def add_event(self, id, name, item):
        self.events[id] = (name, item)
        if name[:-1] == self.namespace.prefix:
            self.all.append((name, item))

    def get_event(self, id):
        return self.events[id][1]

    # Keeps track of error datatypes
    def add_error(self, id, name, item):
        self.errors[id] = (name, item)
        if name[:-1] == self.namespace.prefix:
            self.all.append((name, item))

    def get_error(self, id):
        return self.errors[id][1]
@


1.3
log
@Update to xcb-proto 1.10
@
text
@d68 2
d98 1
d112 2
@


1.2
log
@Update to xcb-proto 1.7. Tested by krw@@, mpi@@, shadchin@@
@
text
@d77 1
d81 1
@


1.1
log
@Initial revision
@
text
@d7 3
a9 3
import matcher
from error import *
from xtypes import *
@


1.1.1.1
log
@initial import of xcb-proto 1.4
@
text
@@
