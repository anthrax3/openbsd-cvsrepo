head	1.5;
access;
symbols
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.8
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.6
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.4
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.4.0.6
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.4
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.2
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.3.0.4
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.2
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2014.09.27.17.53.05;	author matthieu;	state Exp;
branches;
next	1.4;
commitid	cVXoV5PxI8YrEaVA;

1.4
date	2013.06.07.17.28.55;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2012.06.10.13.21.31;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2011.11.05.13.32.58;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.07.27.19.02.38;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@/**
 * Copyright Â© 2009 Red Hat, Inc.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a
 *  copy of this software and associated documentation files (the "Software"),
 *  to deal in the Software without restriction, including without limitation
 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *  and/or sell copies of the Software, and to permit persons to whom the
 *  Software is furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice (including the next
 *  paragraph) shall be included in all copies or substantial portions of the
 *  Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *  DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "scrnintstr.h"
#include "windowstr.h"
#include "exevents.h"
#include <assert.h>

#ifndef PROTOCOL_COMMON_H
#define PROTOCOL_COMMON_H

/* Check default values in a reply */
#define reply_check_defaults(rep, len, type) \
    { \
        assert((len) >= sz_x##type##Reply); \
        assert((rep)->repType == X_Reply); \
        assert((rep)->RepType == X_##type); \
        assert((rep)->sequenceNumber == CLIENT_SEQUENCE); \
        assert((rep)->length >= (sz_x##type##Reply - 32)/4); \
    }

/* initialise default values for request */
#define request_init(req, type) \
    { \
        (req)->reqType = 128; /* doesn't matter */ \
        (req)->ReqType = X_##type; \
        (req)->length = (sz_x##type##Req >> 2); \
    }

/* Various defines used in the tests. Some tests may use different values
 * than these defaults */
/* default client index */
#define CLIENT_INDEX            1
/* default client mask for resources and windows */
#define CLIENT_MASK             ((CLIENT_INDEX) << CLIENTOFFSET)
/* default client sequence number for replies */
#define CLIENT_SEQUENCE         0x100
/* default root window id */
#define ROOT_WINDOW_ID          0x10
/* default client window id */
#define CLIENT_WINDOW_ID        0x100001
/* invalid window ID. use for BadWindow checks. */
#define INVALID_WINDOW_ID       0x111111
/* initial fake sprite position */
#define SPRITE_X                100
#define SPRITE_Y                200

/* Various structs used throughout the tests */

/* The default devices struct, contains one pointer + keyboard and the
 * matching master devices. Initialize with init_devices() if needed. */
struct devices {
    DeviceIntPtr vcp;
    DeviceIntPtr vck;
    DeviceIntPtr mouse;
    DeviceIntPtr kbd;

    int num_devices;
    int num_master_devices;
};

/**
 * The set of default devices available in all tests if necessary.
 */
extern struct devices devices;

/**
 * test-specific userdata, passed into the reply handler.
 */
extern void *global_userdata;

/**
 * The reply handler called from WriteToClient. Set this handler if you need
 * to check the reply values.
 */
void (*reply_handler) (ClientPtr client, int len, char *data, void *userdata);

/**
 * The default screen used for the windows. Initialized by init_simple().
 */
extern ScreenRec screen;

/**
 * Semi-initialized root window. initialized by init().
 */
extern WindowRec root;

/**
 * Semi-initialized top-level window. initialized by init().
 */
extern WindowRec window;

/* various simple functions for quick setup */
/**
 * Initialize the above struct with default devices and return the struct.
 * Usually not needed if you call ::init_simple.
 */
struct devices init_devices(void);

/**
 * Init a mostly zeroed out client with default values for index and mask.
 */
ClientRec init_client(int request_len, void *request_data);

/**
 * Init a mostly zeroed out window with the given window ID.
 * Usually not needed if you call ::init_simple which sets up root and
 * window.
 */
void init_window(WindowPtr window, WindowPtr parent, int id);

/**
 * Create a very simple setup that provides the minimum values for most
 * tests, including a screen, the root and client window and the default
 * device setup.
 */
void init_simple(void);

/* Declarations for various overrides in the test files. */
void __wrap_WriteToClient(ClientPtr client, int len, void *data);
int __wrap_XISetEventMask(DeviceIntPtr dev, WindowPtr win, int len,
                          unsigned char *mask);
int __wrap_dixLookupWindow(WindowPtr *win, XID id, ClientPtr client,
                           Mask access);
int __real_dixLookupWindow(WindowPtr *win, XID id, ClientPtr client,
                           Mask access);
Bool __wrap_AddResource(XID id, RESTYPE type, void *value);
int __wrap_dixLookupClient(ClientPtr *c, XID id, ClientPtr client, Mask access);
int __real_dixLookupClient(ClientPtr *c, XID id, ClientPtr client, Mask access);

#endif                          /* PROTOCOL_COMMON_H */
@


1.4
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d94 1
a94 1
extern void *userdata;
d151 1
a151 1
Bool __wrap_AddResource(XID id, RESTYPE type, pointer value);
@


1.3
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@a35 2
extern int BadDevice;

d84 1
a84 1
} devices;
@


1.2
log
@Update to xserver 1.11.2
@
text
@a55 1

a73 1

a75 1

d97 1
d102 1
a102 1
void (*reply_handler)(ClientPtr client, int len, char *data, void *userdata);
d108 1
d113 1
d125 1
d130 1
d137 1
d147 6
a152 3
int __wrap_XISetEventMask(DeviceIntPtr dev, WindowPtr win, int len, unsigned char* mask);
int __wrap_dixLookupWindow(WindowPtr *win, XID id, ClientPtr client, Mask access);
int __real_dixLookupWindow(WindowPtr *win, XID id, ClientPtr client, Mask access);
d157 1
a157 3

#endif /* PROTOCOL_COMMON_H */

@


1.1
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@a29 1
#include "scrnintstr.h"
d31 1
d41 5
a45 5
        g_assert((len) >= sz_x##type##Reply); \
        g_assert((rep)->repType == X_Reply); \
        g_assert((rep)->RepType == X_##type); \
        g_assert((rep)->sequenceNumber == CLIENT_SEQUENCE); \
        g_assert((rep)->length >= (sz_x##type##Reply - 32)/4); \
@

