head	1.5;
access;
symbols
	OPENBSD_6_0:1.5.0.8
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.6
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.4
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.4.0.6
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.4
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.2
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.3.0.4
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.2
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2014.12.09.17.58.53;	author matthieu;	state Exp;
branches;
next	1.4;
commitid	vcnjRBuLQw44cPHf;

1.4
date	2013.06.07.17.28.56;	author matthieu;	state Exp;
branches
	1.4.4.1
	1.4.6.1;
next	1.3;

1.3
date	2012.06.10.13.21.31;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2011.11.05.13.32.58;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.07.27.19.02.38;	author matthieu;	state Exp;
branches;
next	;

1.4.4.1
date	2014.12.09.18.00.13;	author matthieu;	state Exp;
branches;
next	;
commitid	xg6qoZmMsIovdaEA;

1.4.6.1
date	2014.12.09.17.59.33;	author matthieu;	state Exp;
branches;
next	;
commitid	TlkXlepp8erAnwcR;


desc
@@


1.5
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@/**
 * Copyright Â© 2009 Red Hat, Inc.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a
 *  copy of this software and associated documentation files (the "Software"),
 *  to deal in the Software without restriction, including without limitation
 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *  and/or sell copies of the Software, and to permit persons to whom the
 *  Software is furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice (including the next
 *  paragraph) shall be included in all copies or substantial portions of the
 *  Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *  DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

/*
 * Protocol testing for XIWarpPointer request.
 */
#include <stdint.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/extensions/XI2proto.h>
#include "inputstr.h"
#include "windowstr.h"
#include "scrnintstr.h"
#include "xiwarppointer.h"
#include "exevents.h"
#include "exglobals.h"

#include "protocol-common.h"

static int expected_x = SPRITE_X;
static int expected_y = SPRITE_Y;

/* dixLookupWindow requires a lot of setup not necessary for this test.
 * Simple wrapper that returns either one of the fake root window or the
 * fake client window. If the requested ID is neither of those wanted,
 * return whatever the real dixLookupWindow does.
 */
int
__wrap_dixLookupWindow(WindowPtr *win, XID id, ClientPtr client, Mask access)
{
    if (id == root.drawable.id) {
        *win = &root;
        return Success;
    }
    else if (id == window.drawable.id) {
        *win = &window;
        return Success;
    }

    return __real_dixLookupWindow(win, id, client, access);
}

/**
 * This function overrides the one in the screen rec.
 */
static Bool
ScreenSetCursorPosition(DeviceIntPtr dev, ScreenPtr scr,
                        int x, int y, Bool generateEvent)
{
    assert(x == expected_x);
    assert(y == expected_y);
    return TRUE;
}

static void
request_XIWarpPointer(ClientPtr client, xXIWarpPointerReq * req, int error)
{
    int rc;

    rc = ProcXIWarpPointer(client);
    assert(rc == error);

    if (rc == BadDevice)
        assert(client->errorValue == req->deviceid);
    else if (rc == BadWindow)
        assert(client->errorValue == req->dst_win ||
               client->errorValue == req->src_win);

    client->swapped = TRUE;

    swapl(&req->src_win);
    swapl(&req->dst_win);
    swapl(&req->src_x);
    swapl(&req->src_y);
    swapl(&req->dst_x);
    swapl(&req->dst_y);
    swaps(&req->src_width);
    swaps(&req->src_height);
    swaps(&req->deviceid);

    rc = SProcXIWarpPointer(client);
    assert(rc == error);

    if (rc == BadDevice)
        assert(client->errorValue == req->deviceid);
    else if (rc == BadWindow)
        assert(client->errorValue == req->dst_win ||
               client->errorValue == req->src_win);

    client->swapped = FALSE;
}

static void
test_XIWarpPointer(void)
{
    int i;
    ClientRec client_request;
    xXIWarpPointerReq request;

    memset(&request, 0, sizeof(request));

    request_init(&request, XIWarpPointer);

    client_request = init_client(request.length, &request);

    request.deviceid = XIAllDevices;
    request_XIWarpPointer(&client_request, &request, BadDevice);

    request.deviceid = XIAllMasterDevices;
    request_XIWarpPointer(&client_request, &request, BadDevice);

    request.src_win = root.drawable.id;
    request.dst_win = root.drawable.id;
    request.deviceid = devices.vcp->id;
    request_XIWarpPointer(&client_request, &request, Success);
    request.deviceid = devices.vck->id;
    request_XIWarpPointer(&client_request, &request, BadDevice);
    request.deviceid = devices.mouse->id;
    request_XIWarpPointer(&client_request, &request, BadDevice);
    request.deviceid = devices.kbd->id;
    request_XIWarpPointer(&client_request, &request, BadDevice);

    devices.mouse->master = NULL;       /* Float, kind-of */
    request.deviceid = devices.mouse->id;
    request_XIWarpPointer(&client_request, &request, Success);

    for (i = devices.kbd->id + 1; i <= 0xFFFF; i++) {
        request.deviceid = i;
        request_XIWarpPointer(&client_request, &request, BadDevice);
    }

    request.src_win = window.drawable.id;
    request.deviceid = devices.vcp->id;
    request_XIWarpPointer(&client_request, &request, Success);

    request.deviceid = devices.mouse->id;
    request_XIWarpPointer(&client_request, &request, Success);

    request.src_win = root.drawable.id;
    request.dst_win = 0xFFFF;   /* invalid window */
    request_XIWarpPointer(&client_request, &request, BadWindow);

    request.src_win = 0xFFFF;   /* invalid window */
    request.dst_win = root.drawable.id;
    request_XIWarpPointer(&client_request, &request, BadWindow);

    request.src_win = None;
    request.dst_win = None;

    request.dst_y = 0;
    expected_y = SPRITE_Y;

    request.dst_x = 1 << 16;
    expected_x = SPRITE_X + 1;
    request.deviceid = devices.vcp->id;
    request_XIWarpPointer(&client_request, &request, Success);

    request.dst_x = -1 << 16;
    expected_x = SPRITE_X - 1;
    request.deviceid = devices.vcp->id;
    request_XIWarpPointer(&client_request, &request, Success);

    request.dst_x = 0;
    expected_x = SPRITE_X;

    request.dst_y = 1 << 16;
    expected_y = SPRITE_Y + 1;
    request.deviceid = devices.vcp->id;
    request_XIWarpPointer(&client_request, &request, Success);

    request.dst_y = -1 << 16;
    expected_y = SPRITE_Y - 1;
    request.deviceid = devices.vcp->id;
    request_XIWarpPointer(&client_request, &request, Success);

    /* FIXME: src_x/y checks */

    client_request.req_len -= 2; /* invalid length */
    request_XIWarpPointer(&client_request, &request, BadLength);
}

int
main(int argc, char **argv)
{
    init_simple();
    screen.SetCursorPosition = ScreenSetCursorPosition;

    test_XIWarpPointer();

    return 0;
}
@


1.4
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d201 3
@


1.4.4.1
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@a200 3

    client_request.req_len -= 2; /* invalid length */
    request_XIWarpPointer(&client_request, &request, BadLength);
@


1.4.6.1
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@a200 3

    client_request.req_len -= 2; /* invalid length */
    request_XIWarpPointer(&client_request, &request, BadLength);
@


1.3
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d40 1
d71 1
a71 1
ScreenSetCursorPosition(DeviceIntPtr dev, ScreenPtr screen,
@


1.2
log
@Update to xserver 1.11.2
@
text
@d51 2
a52 1
int __wrap_dixLookupWindow(WindowPtr *win, XID id, ClientPtr client, Mask access)
d54 1
a54 2
    if (id == root.drawable.id)
    {
d57 2
a58 2
    } else if (id == window.drawable.id)
    {
d69 3
a71 2
static Bool ScreenSetCursorPosition(DeviceIntPtr dev, ScreenPtr screen,
                                    int x, int y, Bool generateEvent)
d78 2
a79 3

static void request_XIWarpPointer(ClientPtr client, xXIWarpPointerReq* req,
        int error)
a80 1
    char n;
d90 1
a90 2
                 client->errorValue == req->src_win);

d94 9
a102 9
    swapl(&req->src_win, n);
    swapl(&req->dst_win, n);
    swapl(&req->src_x, n);
    swapl(&req->src_y, n);
    swapl(&req->dst_x, n);
    swapl(&req->dst_y, n);
    swaps(&req->src_width, n);
    swaps(&req->src_height, n);
    swaps(&req->deviceid, n);
d111 1
a111 1
                 client->errorValue == req->src_win);
d116 2
a117 1
static void test_XIWarpPointer(void)
d146 1
a146 1
    devices.mouse->master = NULL; /* Float, kind-of */
d150 1
a150 2
    for (i = devices.kbd->id + 1; i <= 0xFFFF; i++)
    {
d163 1
a163 1
    request.dst_win = 0xFFFF; /* invalid window */
d166 1
a166 1
    request.src_win = 0xFFFF; /* invalid window */
d202 2
a203 1
int main(int argc, char** argv)
@


1.1
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@a41 1
#include <glib.h>
d72 2
a73 2
    g_assert(x == expected_x);
    g_assert(y == expected_y);
d85 1
a85 1
    g_assert(rc == error);
d88 1
a88 1
        g_assert(client->errorValue == req->deviceid);
d90 1
a90 1
        g_assert(client->errorValue == req->dst_win ||
d107 1
a107 1
    g_assert(rc == error);
d110 1
a110 1
        g_assert(client->errorValue == req->deviceid);
d112 1
a112 1
        g_assert(client->errorValue == req->dst_win ||
d147 1
a147 1
    devices.mouse->u.master = NULL; /* Float, kind-of */
a205 3
    g_test_init(&argc, &argv,NULL);
    g_test_bug_base("https://bugzilla.freedesktop.org/show_bug.cgi?id=");

d209 1
a209 1
    g_test_add_func("/xi2/protocol/XIWarpPointer", test_XIWarpPointer);
d211 1
a211 1
    return g_test_run();
@

