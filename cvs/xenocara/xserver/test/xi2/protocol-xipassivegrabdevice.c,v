head	1.6;
access;
symbols
	OPENBSD_6_1:1.6.0.10
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.8
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.6
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.3.0.4
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.2
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.2.0.4
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.2
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.2;
locks; strict;
comment	@ * @;


1.6
date	2014.12.09.17.58.53;	author matthieu;	state Exp;
branches;
next	1.5;
commitid	vcnjRBuLQw44cPHf;

1.5
date	2014.09.27.17.53.05;	author matthieu;	state Exp;
branches;
next	1.4;
commitid	cVXoV5PxI8YrEaVA;

1.4
date	2014.05.02.19.27.51;	author matthieu;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2013.06.07.17.28.56;	author matthieu;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	2012.06.10.13.21.31;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2011.11.05.13.32.58;	author matthieu;	state Exp;
branches;
next	;

1.3.4.1
date	2014.12.09.18.00.13;	author matthieu;	state Exp;
branches;
next	;
commitid	xg6qoZmMsIovdaEA;

1.4.2.1
date	2014.12.09.17.59.33;	author matthieu;	state Exp;
branches;
next	;
commitid	TlkXlepp8erAnwcR;


desc
@@


1.6
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@/**
 * Copyright Â© 2011 Red Hat, Inc.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a
 *  copy of this software and associated documentation files (the "Software"),
 *  to deal in the Software without restriction, including without limitation
 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *  and/or sell copies of the Software, and to permit persons to whom the
 *  Software is furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice (including the next
 *  paragraph) shall be included in all copies or substantial portions of the
 *  Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *  DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

/*
 * Protocol testing for XIPassiveGrab request.
 */
#include <stdint.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/extensions/XI2proto.h>
#include "inputstr.h"
#include "windowstr.h"
#include "scrnintstr.h"
#include "xipassivegrab.h"
#include "exevents.h"
#include "exglobals.h"

#include "protocol-common.h"

static ClientRec client_request;

#define N_MODS 7
static uint32_t modifiers[N_MODS] = { 1, 2, 3, 4, 5, 6, 7 };

struct test_data {
    int num_modifiers;
} testdata;

int __wrap_GrabButton(ClientPtr client, DeviceIntPtr dev,
                      DeviceIntPtr modifier_device, int button,
                      GrabParameters *param, enum InputLevel grabtype,
                      GrabMask *mask);
static void reply_XIPassiveGrabDevice_data(ClientPtr client, int len,
                                           char *data, void *closure);

int
__wrap_dixLookupWindow(WindowPtr *win, XID id, ClientPtr client, Mask access)
{
    if (id == root.drawable.id) {
        *win = &root;
        return Success;
    }
    else if (id == window.drawable.id) {
        *win = &window;
        return Success;
    }

    return __real_dixLookupWindow(win, id, client, access);
}

int
__wrap_GrabButton(ClientPtr client, DeviceIntPtr dev,
                  DeviceIntPtr modifier_device, int button,
                  GrabParameters *param, enum InputLevel grabtype,
                  GrabMask *mask)
{
    /* Fail every odd modifier */
    if (param->modifiers % 2)
        return BadAccess;

    return Success;
}

static void
reply_XIPassiveGrabDevice(ClientPtr client, int len, char *data, void *closure)
{
    xXIPassiveGrabDeviceReply *rep = (xXIPassiveGrabDeviceReply *) data;

    if (client->swapped) {
        swaps(&rep->sequenceNumber);
        swapl(&rep->length);
        swaps(&rep->num_modifiers);

        testdata.num_modifiers = rep->num_modifiers;
    }

    reply_check_defaults(rep, len, XIPassiveGrabDevice);

    /* ProcXIPassiveGrabDevice sends the data in two batches, let the second
     * handler handle the modifier data */
    if (rep->num_modifiers > 0)
        reply_handler = reply_XIPassiveGrabDevice_data;
}

static void
reply_XIPassiveGrabDevice_data(ClientPtr client, int len, char *data,
                               void *closure)
{
    int i;

    xXIGrabModifierInfo *mods = (xXIGrabModifierInfo *) data;

    for (i = 0; i < testdata.num_modifiers; i++, mods++) {
        if (client->swapped)
            swapl(&mods->modifiers);

        /* 1 - 7 is the range we use for the global modifiers array
         * above */
        assert(mods->modifiers > 0);
        assert(mods->modifiers <= 7);
        assert(mods->modifiers % 2 == 1);       /* because we fail odd ones */
        assert(mods->status != Success);
        assert(mods->pad0 == 0);
        assert(mods->pad1 == 0);
    }

    reply_handler = reply_XIPassiveGrabDevice;
}

static void
request_XIPassiveGrabDevice(ClientPtr client, xXIPassiveGrabDeviceReq * req,
                            int error, int errval)
{
    int rc;
    int local_modifiers;
    int mask_len;

    client_request.req_len = req->length;
    rc = ProcXIPassiveGrabDevice(&client_request);
    assert(rc == error);

    if (rc != Success)
        assert(client_request.errorValue == errval);

    client_request.swapped = TRUE;
    swaps(&req->length);
    swapl(&req->time);
    swapl(&req->grab_window);
    swapl(&req->cursor);
    swapl(&req->detail);
    swaps(&req->deviceid);
    local_modifiers = req->num_modifiers;
    swaps(&req->num_modifiers);
    mask_len = req->mask_len;
    swaps(&req->mask_len);

    while (local_modifiers--) {
        CARD32 *mod = (CARD32 *) (req + 1) + mask_len + local_modifiers;

        swapl(mod);
    }

    rc = SProcXIPassiveGrabDevice(&client_request);
    assert(rc == error);

    if (rc != Success)
        assert(client_request.errorValue == errval);
}

static unsigned char *data[4096];       /* the request buffer */
static void
test_XIPassiveGrabDevice(void)
{
    int i;
    xXIPassiveGrabDeviceReq *request = (xXIPassiveGrabDeviceReq *) data;
    unsigned char *mask;

    request_init(request, XIPassiveGrabDevice);

    request->grab_window = CLIENT_WINDOW_ID;

    reply_handler = reply_XIPassiveGrabDevice;
    client_request = init_client(request->length, request);

    printf("Testing invalid device\n");
    request->deviceid = 12;
    request_XIPassiveGrabDevice(&client_request, request, BadDevice,
                                request->deviceid);

    printf("Testing invalid length\n");
    request->length -= 2;
    request_XIPassiveGrabDevice(&client_request, request, BadLength,
                                client_request.errorValue);
    /* re-init request since swapped length test leaves some values swapped */
    request_init(request, XIPassiveGrabDevice);
    request->grab_window = CLIENT_WINDOW_ID;
    request->deviceid = XIAllMasterDevices;

    printf("Testing invalid grab types\n");
    for (i = XIGrabtypeTouchBegin + 1; i < 0xFF; i++) {
        request->grab_type = i;
        request_XIPassiveGrabDevice(&client_request, request, BadValue,
                                    request->grab_type);
    }

    printf("Testing invalid grab type + detail combinations\n");
    request->grab_type = XIGrabtypeEnter;
    request->detail = 1;
    request_XIPassiveGrabDevice(&client_request, request, BadValue,
                                request->detail);

    request->grab_type = XIGrabtypeFocusIn;
    request_XIPassiveGrabDevice(&client_request, request, BadValue,
                                request->detail);

    request->detail = 0;

    printf("Testing invalid masks\n");
    mask = (unsigned char *) &request[1];

    request->mask_len = bytes_to_int32(XI2LASTEVENT + 1);
    request->length += request->mask_len;
    SetBit(mask, XI2LASTEVENT + 1);
    request_XIPassiveGrabDevice(&client_request, request, BadValue,
                                XI2LASTEVENT + 1);

    ClearBit(mask, XI2LASTEVENT + 1);

    /* tested all special cases now, test a few valid cases */

    /* no modifiers */
    request->deviceid = XIAllDevices;
    request->grab_type = XIGrabtypeButton;
    request->detail = XIAnyButton;
    request_XIPassiveGrabDevice(&client_request, request, Success, 0);

    /* Set a few random masks to make sure we handle modifiers correctly */
    SetBit(mask, XI_ButtonPress);
    SetBit(mask, XI_KeyPress);
    SetBit(mask, XI_Enter);

    /* some modifiers */
    request->num_modifiers = N_MODS;
    request->length += N_MODS;
    memcpy((uint32_t *) (request + 1) + request->mask_len, modifiers,
           sizeof(modifiers));
    request_XIPassiveGrabDevice(&client_request, request, Success, 0);
}

int
main(int argc, char **argv)
{
    init_simple();

    test_XIPassiveGrabDevice();

    return 0;
}
@


1.5
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d142 1
d194 7
@


1.4
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d139 1
a139 1
    int modifiers;
d155 1
a155 1
    modifiers = req->num_modifiers;
d160 2
a161 2
    while (modifiers--) {
        CARD32 *mod = ((CARD32 *) (req + 1)) + mask_len + modifiers;
@


1.4.2.1
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@a141 1
    client_request.req_len = req->length;
a192 7
    printf("Testing invalid length\n");
    request->length -= 2;
    request_XIPassiveGrabDevice(&client_request, request, BadLength,
                                client_request.errorValue);
    /* re-init request since swapped length test leaves some values swapped */
    request_init(request, XIPassiveGrabDevice);
    request->grab_window = CLIENT_WINDOW_ID;
@


1.3
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d140 1
d157 1
d161 1
a161 1
        CARD32 *mod = ((CARD32 *) (req + 1)) + modifiers;
d232 5
@


1.3.4.1
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@a140 1
    client_request.req_len = req->length;
a190 7
    printf("Testing invalid length\n");
    request->length -= 2;
    request_XIPassiveGrabDevice(&client_request, request, BadLength,
                                client_request.errorValue);
    /* re-init request since swapped length test leaves some values swapped */
    request_init(request, XIPassiveGrabDevice);
    request->grab_window = CLIENT_WINDOW_ID;
@


1.2
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d40 1
d58 1
a58 1
                                           char *data, void *userdata);
d89 1
a89 1
reply_XIPassiveGrabDevice(ClientPtr client, int len, char *data, void *userdata)
d111 1
a111 1
                               void *userdata)
@


1.1
log
@Update to xserver 1.11.2
@
text
@d44 1
d46 1
a46 1
static uint32_t modifiers[N_MODS] = {1, 2, 3, 4, 5, 6, 7};
d52 3
a54 2
int __wrap_GrabButton(ClientPtr client, DeviceIntPtr dev, DeviceIntPtr modifier_device,
                      int button, GrabParameters *param, GrabType grabtype,
d56 2
a57 1
static void reply_XIPassiveGrabDevice_data(ClientPtr client, int len, char *data, void *userdata);
d59 2
a60 1
int __wrap_dixLookupWindow(WindowPtr *win, XID id, ClientPtr client, Mask access)
d62 1
a62 2
    if (id == root.drawable.id)
    {
d65 2
a66 2
    } else if (id == window.drawable.id)
    {
d74 5
a78 3
int __wrap_GrabButton(ClientPtr client, DeviceIntPtr dev, DeviceIntPtr modifier_device,
                      int button, GrabParameters *param, GrabType grabtype,
                      GrabMask *mask)
d87 2
a88 1
static void reply_XIPassiveGrabDevice(ClientPtr client, int len, char *data, void *userdata)
d90 1
a90 1
    xXIPassiveGrabDeviceReply *rep = (xXIPassiveGrabDeviceReply*)data;
d92 4
a95 6
    if (client->swapped)
    {
        char n;
        swaps(&rep->sequenceNumber, n);
        swapl(&rep->length, n);
        swaps(&rep->num_modifiers, n);
d108 3
a110 1
static void reply_XIPassiveGrabDevice_data(ClientPtr client, int len, char *data, void *userdata)
a112 1
    int n;
d114 1
a114 1
    xXIGrabModifierInfo *mods = (xXIGrabModifierInfo*)data;
d116 1
a116 2
    for (i = 0; i < testdata.num_modifiers; i++, mods++)
    {
d118 1
a118 1
            swapl(&mods->modifiers, n);
d124 1
a124 1
        assert(mods->modifiers % 2 == 1); /* because we fail odd ones */
d133 3
a135 1
static void request_XIPassiveGrabDevice(ClientPtr client, xXIPassiveGrabDeviceReq* req, int error, int errval)
a136 1
    char n;
d147 6
a152 6
    swaps(&req->length, n);
    swapl(&req->time, n);
    swapl(&req->grab_window, n);
    swapl(&req->cursor, n);
    swapl(&req->detail, n);
    swaps(&req->deviceid, n);
d154 5
a158 2
    swaps(&req->num_modifiers, n);
    swaps(&req->mask_len, n);
d160 1
a160 4
    while(modifiers--)
    {
        CARD32 *mod = ((CARD32*)(req + 1)) + modifiers;
        swapl(mod, n);
d170 3
a172 2
static unsigned char *data[4096]; /* the request buffer */
static void test_XIPassiveGrabDevice(void)
d175 1
a175 1
    xXIPassiveGrabDeviceReq *request = (xXIPassiveGrabDeviceReq*)data;
d187 2
a188 1
    request_XIPassiveGrabDevice(&client_request, request, BadDevice, request->deviceid);
d193 1
a193 2
    for (i = XIGrabtypeFocusIn + 1; i < 0xFF; i++)
    {
d195 2
a196 1
        request_XIPassiveGrabDevice(&client_request, request, BadValue, request->grab_type);
d202 2
a203 1
    request_XIPassiveGrabDevice(&client_request, request, BadValue, request->detail);
d206 2
a207 1
    request_XIPassiveGrabDevice(&client_request, request, BadValue, request->detail);
d212 1
a212 1
    mask = (unsigned char*)&request[1];
d217 2
a218 1
    request_XIPassiveGrabDevice(&client_request, request, BadValue, XI2LASTEVENT + 1);
d233 2
a234 1
    memcpy((uint32_t*)(request + 1) + request->mask_len, modifiers, sizeof(modifiers));
d238 2
a239 1
int main(int argc, char** argv)
@

