head	1.8;
access;
symbols
	OPENBSD_6_1:1.8.0.6
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.4
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.2
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.6.0.6
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.4
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	OPENBSD_5_0:1.3.0.4
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.09.16.19.10.26;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	Te1daavkBLskZ8gc;

1.7
date	2014.09.27.17.53.05;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	cVXoV5PxI8YrEaVA;

1.6
date	2013.06.07.17.28.55;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2012.06.10.13.21.31;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.11.05.13.32.58;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.12.21.20.10.49;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.12.05.15.36.11;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.07.27.19.02.38;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/**
 * Copyright Â© 2009 Red Hat, Inc.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a
 *  copy of this software and associated documentation files (the "Software"),
 *  to deal in the Software without restriction, including without limitation
 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *  and/or sell copies of the Software, and to permit persons to whom the
 *  Software is furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice (including the next
 *  paragraph) shall be included in all copies or substantial portions of the
 *  Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *  DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <errno.h>
#include <stdint.h>
#include "extinit.h"            /* for XInputExtensionInit */
#include "exglobals.h"
#include "xkbsrv.h"             /* for XkbInitPrivates */
#include "xserver-properties.h"
#include "syncsrv.h"
#include <X11/extensions/XI2.h>

#include "protocol-common.h"

struct devices devices;
ScreenRec screen;
WindowRec root;
WindowRec window;
static ClientRec server_client;

void *global_userdata;

static void
fake_init_sprite(DeviceIntPtr dev)
{
    SpritePtr sprite;

    sprite = dev->spriteInfo->sprite;

    sprite->spriteTraceSize = 10;
    sprite->spriteTrace = calloc(sprite->spriteTraceSize, sizeof(WindowPtr));
    sprite->spriteTraceGood = 1;
    sprite->spriteTrace[0] = &root;
    sprite->hot.x = SPRITE_X;
    sprite->hot.y = SPRITE_Y;
    sprite->hotPhys.x = sprite->hot.x;
    sprite->hotPhys.y = sprite->hot.y;
    sprite->win = &window;
    sprite->hotPhys.pScreen = &screen;
    sprite->physLimits.x1 = 0;
    sprite->physLimits.y1 = 0;
    sprite->physLimits.x2 = screen.width;
    sprite->physLimits.y2 = screen.height;
}

/* This is essentially CorePointerProc with ScrollAxes added */
static int
TestPointerProc(DeviceIntPtr pDev, int what)
{
#define NBUTTONS 10
#define NAXES 4
    BYTE map[NBUTTONS + 1];
    int i = 0;
    Atom btn_labels[NBUTTONS] = { 0 };
    Atom axes_labels[NAXES] = { 0 };

    switch (what) {
    case DEVICE_INIT:
        for (i = 1; i <= NBUTTONS; i++)
            map[i] = i;

        btn_labels[0] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_LEFT);
        btn_labels[1] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_MIDDLE);
        btn_labels[2] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_RIGHT);
        btn_labels[3] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_WHEEL_UP);
        btn_labels[4] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_WHEEL_DOWN);
        btn_labels[5] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_HWHEEL_LEFT);
        btn_labels[6] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_HWHEEL_RIGHT);
        /* don't know about the rest */

        axes_labels[0] = XIGetKnownProperty(AXIS_LABEL_PROP_REL_X);
        axes_labels[1] = XIGetKnownProperty(AXIS_LABEL_PROP_REL_Y);
        axes_labels[0] = XIGetKnownProperty(AXIS_LABEL_PROP_REL_VSCROLL);
        axes_labels[1] = XIGetKnownProperty(AXIS_LABEL_PROP_REL_HSCROLL);

        if (!InitPointerDeviceStruct
            ((DevicePtr) pDev, map, NBUTTONS, btn_labels,
             (PtrCtrlProcPtr) NoopDDA, GetMotionHistorySize(), NAXES,
             axes_labels)) {
            ErrorF("Could not initialize device '%s'. Out of memory.\n",
                   pDev->name);
            return BadAlloc;
        }
        pDev->valuator->axisVal[0] = screenInfo.screens[0]->width / 2;
        pDev->last.valuators[0] = pDev->valuator->axisVal[0];
        pDev->valuator->axisVal[1] = screenInfo.screens[0]->height / 2;
        pDev->last.valuators[1] = pDev->valuator->axisVal[1];

        /* protocol-xiquerydevice.c relies on these increment */
        SetScrollValuator(pDev, 2, SCROLL_TYPE_VERTICAL, 2.4, SCROLL_FLAG_NONE);
        SetScrollValuator(pDev, 3, SCROLL_TYPE_HORIZONTAL, 3.5,
                          SCROLL_FLAG_PREFERRED);
        break;

    case DEVICE_CLOSE:
        break;

    default:
        break;
    }

    return Success;

#undef NBUTTONS
#undef NAXES
}

/**
 * Create and init 2 master devices (VCP + VCK) and two slave devices, one
 * default mouse, one default keyboard.
 */
struct devices
init_devices(void)
{
    ClientRec client;
    struct devices local_devices;
    int ret;

    /*
     * Put a unique name in display pointer so that when tests are run in
     * parallel, their xkbcomp outputs to /tmp/server-<display>.xkm don't
     * stomp on each other.
     */
#ifdef HAVE_GETPROGNAME
    display = getprogname();
#elif HAVE_DECL_PROGRAM_INVOCATION_SHORT_NAME
    display = program_invocation_short_name;
#endif

    client = init_client(0, NULL);

    AllocDevicePair(&client, "Virtual core", &local_devices.vcp, &local_devices.vck,
                    CorePointerProc, CoreKeyboardProc, TRUE);
    inputInfo.pointer = local_devices.vcp;

    inputInfo.keyboard = local_devices.vck;
    ret = ActivateDevice(local_devices.vcp, FALSE);
    assert(ret == Success);
    /* This may fail if xkbcomp fails or xkb-config is not found. */
    ret = ActivateDevice(local_devices.vck, FALSE);
    assert(ret == Success);
    EnableDevice(local_devices.vcp, FALSE);
    EnableDevice(local_devices.vck, FALSE);

    AllocDevicePair(&client, "", &local_devices.mouse, &local_devices.kbd,
                    TestPointerProc, CoreKeyboardProc, FALSE);
    ret = ActivateDevice(local_devices.mouse, FALSE);
    assert(ret == Success);
    ret = ActivateDevice(local_devices.kbd, FALSE);
    assert(ret == Success);
    EnableDevice(local_devices.mouse, FALSE);
    EnableDevice(local_devices.kbd, FALSE);

    local_devices.num_devices = 4;
    local_devices.num_master_devices = 2;

    fake_init_sprite(local_devices.mouse);
    fake_init_sprite(local_devices.vcp);

    return local_devices;
}

/* Create minimal client, with the given buffer and len as request buffer */
ClientRec
init_client(int len, void *data)
{
    ClientRec client = { 0 };

    /* we store the privates now and reassign it after the memset. this way
     * we can share them across multiple test runs and don't have to worry
     * about freeing them after each test run. */

    client.index = CLIENT_INDEX;
    client.clientAsMask = CLIENT_MASK;
    client.sequence = CLIENT_SEQUENCE;
    client.req_len = len;

    client.requestBuffer = data;
    dixAllocatePrivates(&client.devPrivates, PRIVATE_CLIENT);
    return client;
}

void
init_window(WindowPtr local_window, WindowPtr parent, int id)
{
    memset(local_window, 0, sizeof(*local_window));

    local_window->drawable.id = id;
    if (parent) {
        local_window->drawable.x = 30;
        local_window->drawable.y = 50;
        local_window->drawable.width = 100;
        local_window->drawable.height = 200;
    }
    local_window->parent = parent;
    local_window->optional = calloc(1, sizeof(WindowOptRec));
    assert(local_window->optional);
}

extern DevPrivateKeyRec miPointerScreenKeyRec;
extern DevPrivateKeyRec miPointerPrivKeyRec;

/* Needed for the screen setup, otherwise we crash during sprite initialization */
static Bool
device_cursor_init(DeviceIntPtr dev, ScreenPtr local_screen)
{
    return TRUE;
}

static void
device_cursor_cleanup(DeviceIntPtr dev, ScreenPtr local_screen)
{
}

static Bool
set_cursor_pos(DeviceIntPtr dev, ScreenPtr local_screen, int x, int y, Bool event)
{
    return TRUE;
}

void
init_simple(void)
{
    screenInfo.numScreens = 1;
    screenInfo.screens[0] = &screen;

    screen.myNum = 0;
    screen.id = 100;
    screen.width = 640;
    screen.height = 480;
    screen.DeviceCursorInitialize = device_cursor_init;
    screen.DeviceCursorCleanup = device_cursor_cleanup;
    screen.SetCursorPosition = set_cursor_pos;

    dixResetPrivates();
    InitAtoms();
    XkbInitPrivates();
    dixRegisterPrivateKey(&XIClientPrivateKeyRec, PRIVATE_CLIENT,
                          sizeof(XIClientRec));
    dixRegisterPrivateKey(&miPointerScreenKeyRec, PRIVATE_SCREEN, 0);
    dixRegisterPrivateKey(&miPointerPrivKeyRec, PRIVATE_DEVICE, 0);
    XInputExtensionInit();

    init_window(&root, NULL, ROOT_WINDOW_ID);
    init_window(&window, &root, CLIENT_WINDOW_ID);

    serverClient = &server_client;
    InitClient(serverClient, 0, (void *) NULL);
    if (!InitClientResources(serverClient)) /* for root resources */
        FatalError("couldn't init server resources");
    SyncExtensionInit();

    devices = init_devices();
}

void
__wrap_WriteToClient(ClientPtr client, int len, void *data)
{
    assert(reply_handler != NULL);

    (*reply_handler) (client, len, data, global_userdata);
}
@


1.7
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d28 1
d141 12
d161 5
a165 2
    ActivateDevice(local_devices.vcp, FALSE);
    ActivateDevice(local_devices.vck, FALSE);
d171 4
a174 2
    ActivateDevice(local_devices.mouse, FALSE);
    ActivateDevice(local_devices.kbd, FALSE);
@


1.6
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d44 1
a44 4
void *userdata;

extern int CorePointerProc(DeviceIntPtr pDev, int what);
extern int CoreKeyboardProc(DeviceIntPtr pDev, int what);
d139 1
a139 1
    struct devices devices;
d143 1
a143 1
    AllocDevicePair(&client, "Virtual core", &devices.vcp, &devices.vck,
d145 1
a145 1
    inputInfo.pointer = devices.vcp;
d147 5
a151 5
    inputInfo.keyboard = devices.vck;
    ActivateDevice(devices.vcp, FALSE);
    ActivateDevice(devices.vck, FALSE);
    EnableDevice(devices.vcp, FALSE);
    EnableDevice(devices.vck, FALSE);
d153 1
a153 1
    AllocDevicePair(&client, "", &devices.mouse, &devices.kbd,
d155 4
a158 4
    ActivateDevice(devices.mouse, FALSE);
    ActivateDevice(devices.kbd, FALSE);
    EnableDevice(devices.mouse, FALSE);
    EnableDevice(devices.kbd, FALSE);
d160 2
a161 2
    devices.num_devices = 4;
    devices.num_master_devices = 2;
d163 2
a164 2
    fake_init_sprite(devices.mouse);
    fake_init_sprite(devices.vcp);
d166 1
a166 1
    return devices;
d190 1
a190 1
init_window(WindowPtr window, WindowPtr parent, int id)
d192 1
a192 1
    memset(window, 0, sizeof(*window));
d194 1
a194 1
    window->drawable.id = id;
d196 4
a199 4
        window->drawable.x = 30;
        window->drawable.y = 50;
        window->drawable.width = 100;
        window->drawable.height = 200;
d201 3
a203 3
    window->parent = parent;
    window->optional = calloc(1, sizeof(WindowOptRec));
    assert(window->optional);
d211 1
a211 1
device_cursor_init(DeviceIntPtr dev, ScreenPtr screen)
d217 1
a217 1
device_cursor_cleanup(DeviceIntPtr dev, ScreenPtr screen)
d222 1
a222 1
set_cursor_pos(DeviceIntPtr dev, ScreenPtr screen, int x, int y, Bool event)
d254 1
a254 1
    InitClient(serverClient, 0, (pointer) NULL);
d267 1
a267 1
    (*reply_handler) (client, len, data, userdata);
@


1.5
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d33 1
d42 1
d219 5
d241 1
d255 6
@


1.4
log
@Update to xserver 1.11.2
@
text
@d29 1
a29 1
#include "extinit.h" /* for XInputExtensionInit */
d31 3
a33 1
#include "xkbsrv.h" /* for XkbInitPrivates */
d47 2
a48 1
static void fake_init_sprite(DeviceIntPtr dev)
d51 1
d70 62
d136 2
a137 1
struct devices init_devices(void)
d147 1
d155 1
a155 1
                    CorePointerProc, CoreKeyboardProc, FALSE);
a169 1

d171 2
a172 1
ClientRec init_client(int len, void *data)
d190 2
a191 1
void init_window(WindowPtr window, WindowPtr parent, int id)
d196 1
a196 2
    if (parent)
    {
d211 14
a224 3
static Bool device_cursor_init(DeviceIntPtr dev, ScreenPtr screen) { return TRUE; }
static Bool set_cursor_pos(DeviceIntPtr dev, ScreenPtr screen, int x, int y, Bool event) { return TRUE; }
void init_simple(void)
d239 2
a240 1
    dixRegisterPrivateKey(&XIClientPrivateKeyRec, PRIVATE_CLIENT, sizeof(XIClientRec));
d251 2
a252 1
void __wrap_WriteToClient(ClientPtr client, int len, void *data)
d256 1
a256 1
    (*reply_handler)(client, len, data, userdata);
a257 1

@


1.3
log
@Update to xorg-server 1.9.3. Tested by japser@@, landry@@ and ajacoutot@@
in various configurations.
@
text
@a31 1
#include <glib.h>
d124 1
a124 1
    memset(window, 0, sizeof(window));
d136 1
a136 1
    g_assert(window->optional);
d173 1
a173 1
    g_assert(reply_handler != NULL);
@


1.2
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d31 1
@


1.1
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d30 1
d51 1
a51 1
    sprite->spriteTrace = xcalloc(sprite->spriteTraceSize, sizeof(WindowPtr));
a110 1
    PrivateRec *privates = client.devPrivates;
d118 1
a118 1
    client.devPrivates = privates;
d135 1
a135 1
    window->optional = xcalloc(1, sizeof(WindowOptRec));
d139 3
a146 1
    screenInfo.arraySize = MAXSCREENS;
d159 4
d164 1
@

