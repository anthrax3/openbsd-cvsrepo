head	1.4;
access;
symbols
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.4.0.8
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.6
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.4
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.2
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.3.0.10
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.8
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.6
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.4
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.2
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.4
date	2014.09.27.17.53.05;	author matthieu;	state Exp;
branches;
next	1.3;
commitid	cVXoV5PxI8YrEaVA;

1.3
date	2012.06.10.13.21.31;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2011.11.05.13.32.58;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.07.27.19.02.37;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@/**
 * Copyright Â© 2009 Red Hat, Inc.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a
 *  copy of this software and associated documentation files (the "Software"),
 *  to deal in the Software without restriction, including without limitation
 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *  and/or sell copies of the Software, and to permit persons to whom the
 *  Software is furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice (including the next
 *  paragraph) shall be included in all copies or substantial portions of the
 *  Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *  DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <xkb-config.h>

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <unistd.h>
#include <math.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/keysym.h>
#include <X11/Xatom.h>
#include "misc.h"
#include "inputstr.h"
#include "opaque.h"
#include "property.h"
#define	XKBSRV_NEED_FILE_FUNCS
#include <xkbsrv.h>
#include "../xkb/xkbgeom.h"
#include <X11/extensions/XKMformat.h>
#include "xkbfile.h"
#include "../xkb/xkb.h"
#include <assert.h>

/**
 * Initialize an empty XkbRMLVOSet.
 * Call XkbGetRulesDflts to obtain the default ruleset.
 * Compare obtained ruleset with the built-in defaults.
 *
 * Result: RMLVO defaults are the same as obtained.
 */
static void
xkb_get_rules_test(void)
{
    XkbRMLVOSet rmlvo = { NULL };
    XkbGetRulesDflts(&rmlvo);

    assert(rmlvo.rules);
    assert(rmlvo.model);
    assert(rmlvo.layout);
    assert(rmlvo.variant);
    assert(rmlvo.options);
    assert(strcmp(rmlvo.rules, XKB_DFLT_RULES) == 0);
    assert(strcmp(rmlvo.model, XKB_DFLT_MODEL) == 0);
    assert(strcmp(rmlvo.layout, XKB_DFLT_LAYOUT) == 0);
    assert(strcmp(rmlvo.variant, XKB_DFLT_VARIANT) == 0);
    assert(strcmp(rmlvo.options, XKB_DFLT_OPTIONS) == 0);
}

/**
 * Initialize an random XkbRMLVOSet.
 * Call XkbGetRulesDflts to obtain the default ruleset.
 * Compare obtained ruleset with the built-in defaults.
 * Result: RMLVO defaults are the same as obtained.
 */
static void
xkb_set_rules_test(void)
{
    XkbRMLVOSet rmlvo;
    XkbRMLVOSet rmlvo_new = { NULL };

    XkbInitRules(&rmlvo, "test-rules", "test-model", "test-layout",
                         "test-variant", "test-options");
    assert(rmlvo.rules);
    assert(rmlvo.model);
    assert(rmlvo.layout);
    assert(rmlvo.variant);
    assert(rmlvo.options);

    XkbSetRulesDflts(&rmlvo);
    XkbGetRulesDflts(&rmlvo_new);

    /* XkbGetRulesDflts strdups the values */
    assert(rmlvo.rules != rmlvo_new.rules);
    assert(rmlvo.model != rmlvo_new.model);
    assert(rmlvo.layout != rmlvo_new.layout);
    assert(rmlvo.variant != rmlvo_new.variant);
    assert(rmlvo.options != rmlvo_new.options);

    assert(strcmp(rmlvo.rules, rmlvo_new.rules) == 0);
    assert(strcmp(rmlvo.model, rmlvo_new.model) == 0);
    assert(strcmp(rmlvo.layout, rmlvo_new.layout) == 0);
    assert(strcmp(rmlvo.variant, rmlvo_new.variant) == 0);
    assert(strcmp(rmlvo.options, rmlvo_new.options) == 0);

    XkbFreeRMLVOSet(&rmlvo, FALSE);
}

/**
 * Get the default RMLVO set.
 * Set the default RMLVO set.
 * Get the default RMLVO set.
 * Repeat the last two steps.
 *
 * Result: RMLVO set obtained is the same as previously set.
 */
static void
xkb_set_get_rules_test(void)
{
/* This test failed before XkbGetRulesDftlts changed to strdup.
   We test this twice because the first time using XkbGetRulesDflts we obtain
   the built-in defaults. The unexpected free isn't triggered until the second
   XkbSetRulesDefaults.
 */
    XkbRMLVOSet rmlvo = { NULL };
    XkbRMLVOSet rmlvo_backup;

    XkbGetRulesDflts(&rmlvo);

    /* pass 1 */
    XkbSetRulesDflts(&rmlvo);
    XkbGetRulesDflts(&rmlvo);

    /* Make a backup copy */
    rmlvo_backup.rules = strdup(rmlvo.rules);
    rmlvo_backup.layout = strdup(rmlvo.layout);
    rmlvo_backup.model = strdup(rmlvo.model);
    rmlvo_backup.variant = strdup(rmlvo.variant);
    rmlvo_backup.options = strdup(rmlvo.options);

    /* pass 2 */
    XkbSetRulesDflts(&rmlvo);

    /* This test is iffy, because strictly we may be comparing against already
     * freed memory */
    assert(strcmp(rmlvo.rules, rmlvo_backup.rules) == 0);
    assert(strcmp(rmlvo.model, rmlvo_backup.model) == 0);
    assert(strcmp(rmlvo.layout, rmlvo_backup.layout) == 0);
    assert(strcmp(rmlvo.variant, rmlvo_backup.variant) == 0);
    assert(strcmp(rmlvo.options, rmlvo_backup.options) == 0);

    XkbGetRulesDflts(&rmlvo);
    assert(strcmp(rmlvo.rules, rmlvo_backup.rules) == 0);
    assert(strcmp(rmlvo.model, rmlvo_backup.model) == 0);
    assert(strcmp(rmlvo.layout, rmlvo_backup.layout) == 0);
    assert(strcmp(rmlvo.variant, rmlvo_backup.variant) == 0);
    assert(strcmp(rmlvo.options, rmlvo_backup.options) == 0);
}

int
main(int argc, char **argv)
{
    xkb_set_get_rules_test();
    xkb_get_rules_test();
    xkb_set_rules_test();

    return 0;
}
@


1.3
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d85 1
a85 7
    XkbRMLVOSet rmlvo = {
        .rules = "test-rules",
        .model = "test-model",
        .layout = "test-layout",
        .variant = "test-variant",
        .options = "test-options"
    };
d88 8
d111 2
@


1.2
log
@Update to xserver 1.11.2
@
text
@d58 2
a59 1
static void xkb_get_rules_test(void)
d61 1
a61 1
    XkbRMLVOSet rmlvo = { NULL};
a63 1

d82 2
a83 1
static void xkb_set_rules_test(void)
a110 1

d119 2
a120 1
static void xkb_set_get_rules_test(void)
d162 2
a163 2

int main(int argc, char** argv)
@


1.1
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d49 1
a49 2

#include <glib.h>
d64 10
a73 10
    g_assert(rmlvo.rules);
    g_assert(rmlvo.model);
    g_assert(rmlvo.layout);
    g_assert(rmlvo.variant);
    g_assert(rmlvo.options);
    g_assert(strcmp(rmlvo.rules, XKB_DFLT_RULES) == 0);
    g_assert(strcmp(rmlvo.model, XKB_DFLT_MODEL) == 0);
    g_assert(strcmp(rmlvo.layout, XKB_DFLT_LAYOUT) == 0);
    g_assert(strcmp(rmlvo.variant, XKB_DFLT_VARIANT) == 0);
    g_assert(strcmp(rmlvo.options, XKB_DFLT_OPTIONS) == 0);
d97 11
a107 11
    g_assert(rmlvo.rules != rmlvo_new.rules);
    g_assert(rmlvo.model != rmlvo_new.model);
    g_assert(rmlvo.layout != rmlvo_new.layout);
    g_assert(rmlvo.variant != rmlvo_new.variant);
    g_assert(rmlvo.options != rmlvo_new.options);

    g_assert(strcmp(rmlvo.rules, rmlvo_new.rules) == 0);
    g_assert(strcmp(rmlvo.model, rmlvo_new.model) == 0);
    g_assert(strcmp(rmlvo.layout, rmlvo_new.layout) == 0);
    g_assert(strcmp(rmlvo.variant, rmlvo_new.variant) == 0);
    g_assert(strcmp(rmlvo.options, rmlvo_new.options) == 0);
d147 5
a151 5
    g_assert(strcmp(rmlvo.rules, rmlvo_backup.rules) == 0);
    g_assert(strcmp(rmlvo.model, rmlvo_backup.model) == 0);
    g_assert(strcmp(rmlvo.layout, rmlvo_backup.layout) == 0);
    g_assert(strcmp(rmlvo.variant, rmlvo_backup.variant) == 0);
    g_assert(strcmp(rmlvo.options, rmlvo_backup.options) == 0);
d154 5
a158 5
    g_assert(strcmp(rmlvo.rules, rmlvo_backup.rules) == 0);
    g_assert(strcmp(rmlvo.model, rmlvo_backup.model) == 0);
    g_assert(strcmp(rmlvo.layout, rmlvo_backup.layout) == 0);
    g_assert(strcmp(rmlvo.variant, rmlvo_backup.variant) == 0);
    g_assert(strcmp(rmlvo.options, rmlvo_backup.options) == 0);
d164 3
a166 6
    g_test_init(&argc, &argv,NULL);
    g_test_bug_base("https://bugzilla.freedesktop.org/show_bug.cgi?id=");

    g_test_add_func("/xkb/set-get-rules", xkb_set_get_rules_test);
    g_test_add_func("/xkb/get-rules", xkb_get_rules_test);
    g_test_add_func("/xkb/set-rules", xkb_set_rules_test);
d168 1
a168 1
    return g_test_run();
@

